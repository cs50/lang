[MUSIKK] 

Dette er CS50-- Harvard Universitetet introduksjon til den intellektuelle foretak av informatikk og kunsten programmering. Og mitt navn er David Malan, og Jeg bare tenkte i morges, det har vært utrolig 20 år i dag siden sist jeg satt der dere gjør nå. 

Det var 1996. Jeg var en sophomore, og jeg tok CS50 for aller første gang. Og jeg hadde ikke engang fått opp nerve å ta det selv freshman året, dels på grunn av tiden. Informatikk til meg var typen som, meh. Jeg var litt av en geek voksende opp, men jeg gjorde egentlig ikke har noen intellektuell interesse i hva som syntes å bare være en hel haug med folk programmering hele tiden. 

Og jeg var redd for å være ærlig. Kurset og informatikk mer generelt har hatt, og i noen grad fortsatt har dette ryktet fra et felt til pass på, hvis bare fordi så mange av oss er kjent med det, og usikker på det. Og det var ikke før jeg handlet denne klassen som sophomore fall-- og selv da, jeg bare registrert fordi professor-- en av mine første mentorer, Brian Kernighan nå på Princeton-- tillatt meg å ta klassen pass mislykkes. Og ja, det er derfor i dag vi tillate og oppmuntre studenter til å ta denne klassen satt / unsat. 

Og bare da, ved de slutten av semesteret gjorde jeg innser at, wow, dette var ikke slik et ukjent felt. Dette var faktisk en veldig myndig feltet, og mer spennende, spesielt senere, så jeg tok kurs i Dramatiske Arts 101 og Latin-A og så til slutt grad skolen arkeologi, gjorde jeg virkelig begynne å se skjæringene mellom dette felt, datamaskin vitenskap, med humaniora, naturfag, kunst, medisin, o.l. Og så det er det er bare så ryddig om informatikk slutt, som vi håper du vil see-- er dens anvendbarhet til disse andre felt, og hvordan du kan ta noen av dagens og semesterets ideer og praktiske ferdigheter tilbake til ditt eget domene, og faktisk utforske dette krysset av de liberale kunst og vitenskap. 

Så 73% av dere, hvis siste Året er noen indikasjon, har aldri tatt en CS kurs før. Så hvis du, som meg, er du følelsen litt redd, eller ærlig du ikke helt sikker på hvorfor du selv her. Kanskje du bare fulgte noen venner over til Sanders akkurat nå. Det er helt greit. Målet her er å koble du og for å forsikre deg at hvis du ser på venstre og til høyre, du kommer til å se klassekamerater med så lite eller så mye erfaring at du selv måtte ha. Og ja, vil vi dele noen statistikk senere i dag Når det gjelder hva den demografiske sammensetningen av klassen typisk se ut. 

Og som ekstra reassurance-- og dette vi mener siden jeg tok i løpet noen år ago-- i kursets pensum er dette-- at det som til slutt saker i dette kurset er ikke så mye hvor du ender opp i forhold til klassekameratene dine, men hvor man i uke 11, enden av semester, ender opp i forhold til deg selv i uke 0, som er hvor vi er her i dag. Og dette er hva jeg innså alle disse år siden. Og jeg kjenner mange klasser si dette, men det er særlig i informatikk. På slutten av dagen, dette feltet er kjent som det var for meg og kan være for deg, er egentlig bare om problemløsning. Og som sådan, har den denne anvendelighet for å få andre felt. Og faktisk, hvis vi forsøkt å destillere hva dette betyr, dette er problemløsning i sin essens, daresay jeg. Det er input-- så hva det er at du prøver å løse. Det er utgang, som er forhåpentligvis løsningen på det problemet. Og så, som vi ville si i informatikk, det er denne svarte boksen i midten at du ikke nødvendigvis å bry seg om hvordan det fungerer. Du selv etterhvert kanskje implementere hva som er inni den boksen. Men for dagens formål og flere generelt i livet, bryr alt du om er at disse problemene bli løst. 

Og hva dette kurset er syvende og sist om er å utforske krysset av Disse innganger og utganger, og disse såkalte algoritmer, som vi snart se, som implementerer det som er under der, panseret. Men disse innganger og disse outputs-- hva betyr egentlig det? Vel, på slutten av dagen, må vi noen måte å representere informasjon. Dette gjelder spesielt i en datamaskin, som så fancy og komplisert som det kan virke, er en ganske dum enhet. Det tar electricity-- enten fra en kabel eller et batteri som input-- og da er det produserer noen preprogramed svarene på skjermen. 

Men hvordan får vi fra begynne å fullføre det? Vel, hva som er et problem som må løses? Vel, kanskje vi kan, på starten på noen semester, prøv å ta frammøte i et rom som dette. Så jeg kan gjøre som en, to, tre. Eller kanskje, hvis jeg gjorde det å liksom holde styr av myself-- å holde styr på things-- Jeg kunne raskt kjøre ut av fingrene. Så jeg kan bare gjøre hash marks-- en person, to, tre, fire, fem, seks, syv, åtte. Og alle av oss har trolig gjort dette, enten på hendene eller på et stykke papir. Og dette er faktisk bare noe som kalles enhetlige notation-- der hvis du bare har én bokstav i alfabetet, en eller hash merke i dette tilfellet, for hvert innspill du ønsker å telle, du trenger å legge ned en av disse letters-- ett av disse merkene. 

Greit. Det er alt fint og bra og ikke så komplisert. Men datamaskiner er ikke alt så mye mer komplisert. Faktisk, de fleste av dere sikkert vet selv om du har virkelig ikke vurderes hva dette betyr, at datamaskiner bare forstår nuller og ones-- den såkalte binære systemet. Vi mennesker, derimot, er så mye mer sofistikert i den utstrekning som vi forstår nuller gjennom niere. 

Men selv om binære er, først blikk, ikke alt som er kjent, det viser seg at det er akkurat som systemene og ideer som vi allerede vet. Så for eksempel, bør du vurdere dette. Dette er bare en sekvens av symboler. Og alle dere, når skotter på det, sannsynligvis tror 123-- ingenting veldig interessant der. Men hvorfor er det dette nummeret, 123? Dette er bare innskrifter på den screen-- bare mønstre at noen kanskje har tegnet eller skrevet. Men hvis du er som meg, du sikkert husker fra grunnskolen at det er liksom kolonner eller steder her. Det er en plass og tierplassen og hundre plass. Og grunnen til at dette er 123 og ikke bare et mønster av tre symboler er fordi, selvfølgelig, hvis vi har en i hundrevis sted, du gjør regnestykket over 100 ganger én, og deretter to i tierplassen. Så det er 10 ganger 2, og deretter tre i ett sted og det er 1 ganger 3. Og når du legger alle disse opp, for Selvfølgelig får du 100 pluss 20 pluss tre. 

Så vi startet med bare et mønster av symbols-- en alphabet-- men da vi kartlagt betydning på det ved hjelp av disse kolonnene. Vel, det viser seg at datamaskiner er egentlig ikke så forskjellig fra deg og meg. Men i stedet for å bruke krefter på 10, så til speak-- 1, 10, 100, 1000, 10000 sted og så forth-- de faktisk bare bruke krefter 2-- slik at en, to, fire, og deretter hvis vi legger flere sifre, 8, 16, 32, 64, 128, og så videre. Og så dette er hvordan en datamaskin ville representere tallet 0, akkurat som vi mennesker. 

0, 0, 0-- og du kan sikkert gjette hva mønster av nuller og enere, Hvis en datamaskin kan bare snakke 0 eller 1-- hva mønster kommer til å representere tall vi mennesker kjenner som en? Yeah-- 0, 0, 1. Greit. Så 0, 0, 1 er hvordan vi representerer 1, slik at du kan være tilbøyelig deretter til å representere nummer to, hvis du har de fire plass og de to plass som ett sted, kan du si, vel, hvis vi hadde en 1 i ett sted, og nå ønsker vi å telle opp til to, kanskje du gjøre dette og la dette være et null. Men dette er selvsagt ikke hvordan desimalsystemet fungerer heller. Hvis du putter et tall begge disse kolonner, du er nødt til å gjøre det aritmetiske. Så hva nummer gjorde jeg tilfeldigvis bare representerer? 

Så det er tre, fordi 2 ganger 1 pluss 1 ganger 1, selvfølgelig, gir oss tre. Så dette ville være to. Den litt sånn knipser, så å si, som 0 blir en one, mye som en 9 roller enn og blir en 0 når du bærer en. Dette vil da være tre av kurset. Four-- annen interessant ting skjer, og hvor de ruller over og du bærer en, så å si. Så dette, selvfølgelig, er 4. 

Men hvis du spole fremover nå, Hva er det største antallet kommer å være at en datamaskin kan representere? Så det er bare sju i dette tilfellet, ikke sant? Fordi du har en i de fire, en en i to, ett i den ene. Så det er fire pluss to pluss en. Slik som gir deg sju. Og ja, det ville virke ved første øyekast at datamaskiner kan telle ikke er høyere enn dette. 

Men dette er selvfølgelig ikke sant. Hva gjør vi mennesker gjør når vi ønsker å telle høyere enn som 999? Bare bære en og bare legge til en fjerde sifferet til venstre. Og så faktisk vi kunne. Vi kunne ha en åtte s plassere og en 16. plass, og en 32 plass, 64, 128-- og du kan bare fortsette videre opp til uendelig. Så disse nuller og ones-- den såkalte binære system-- er det en datamaskin vitenskapsmann ville vanligvis kaller en bit, eller binære siffer. 

Men nå, hvordan vi får fra konsept eller grafikken på disse tingene til en faktisk datamaskin? Vi ser ut til å hoppe over et trinn her. Vel, det eneste inngang på slutten av dagen, til min laptop her er denne flyten av strøm. Selv om det har vært en lang siden du tenkte på eller aldri tenkt på hvordan elektrisitet fungerer, det er elektroner flyter i eller ut, og det er min form for innspill. 

Så hvis det er alt som vi er får som input her, hva kan vi gjøre med denne informasjonen? Vel, vi kan tenke på en null som bare et fravær av elektrisitet. Ingenting er flowinw, er ingenting flytting, ingenting skjer. Det er bare standard state-- null. Men hvis det er strøm flyter, hvorfor gjør vi ikke bare vilkårlig, men globalt konsekvent, kaller dette en en. 

Så bare ved å ha ingen makt, vi har en null, ja makt, vi har en one-- ingen makt, ja makt. Og på den måten, ved hjelp av noe mer fysisk eller elektronisk vi begynner å implementere denne oppfatningen av noe enten være en eller en null. Ja, vi kan bare gjøre det over her. Så her har jeg ikke tre, men åtte lyspærer, som hver har sin egen bryter. 

Og så hvis jeg ønsket å representere nummer syv her, Jeg kan slå på disse tre lyspærer. Og ja, på innsiden av datamaskinen min er millioner, milliarder av ting som er bare mindre enn det, som kalles transistorer brytere, som du bare slå av og på. Så disse er big-- relativt big-- brytere inni min laptop-- er mange, mange, mange, mange flere brytere. Men alt de gjør er nøyaktig at-- slå noe på, slår noe av. Og som sådan, kan en datamaskin representere, med de millioner eller milliarder av transistorer, masse og mange nuller og enere. Og det er annen maskinvare likevel at kan du lagre informasjon på lang sikt, slik at når du trekker plugg, trenger du ikke mister den. Men det er en historie for en annen dag. 

Så hva kan vi gjøre med disse bitene? Kan vi bare ta presset ut av me-- kanskje noen ønsker å komme opp her og gi opp en demo? Jeg så denne hånden først. Hva heter du? Maday: Maday. DAVID MALAN: Maday, kom opp. Hyggelig å møte deg. Maday: Hyggelig å møte deg. 

DAVID MALAN: Kom på denne måten. Jeg trenger ikke å leppe deg opp. Greit. Så her har vi, notice-- en, two-- vi vil redigere out-- en, to, fire, åtte, 16, 32, 64, 128. Dette er bevisst. Det er åtte biter her-- binære digits-- nuller og enere. Og en bit er en nyttig enhet av measure-- ikke så nyttig en måleenhet på seg selv. Vanligvis du vil ha minst åtte av disse tingene, også kjent som en byte. Så vi har en byte av biter her. 

Så hvis vi ønsket å utfordre deg med, for eksempel, å stave ut, i binær, denne verdien her-- 42. Ønsker du å ta en stikke på det? 

Maday: [hørbar]. DAVID MALAN: Ja, bare trykk på små hvite brytere i front. Og du ønsker å stave ut 42, og opp til tak er dette CS50 stresset ball hvis du får dette. Greit. Så har du 32. Vi kommer til å trenge 42. Så det er en åtte, så det er 40. Og excellent-- veldig pent gjort. Takk skal du ha. 

[BIFALL] Greit. Så vi har en mer stress ball. La oss gjøre dette på nytt hvis vi kan. En annen frivillig? Gratis stress ball, gratis stress ball. OK. Over her i midten, vil du komme ned? Greit. Jeg vet. Det vi går. 

Så tallene her-- komme ned. Hva heter du? 

DAVEY: Davey. 

DAVID MALAN: Davey. OK. Kom opp, Davey. Hyggelig å møte deg. Og hva vi kommer til å ha deg spell-- hvis du kunne somle det for bare én moment-- er nummer 50. Men, men, men men, men disse er grunnskolen magneter for en grunn. Bare fikk litt hardere, ok? Det er fortsatt åtte. Greit. Så hva har vi på det? Vi har 32. Hyggelig. 32 pluss 16 gir oss 48-- så nær. Og flott. Gratulerer til Davey også. 

[BIFALL] 

Greit. Så vi kan gjøre dette hele dagen lang, og det blir ikke så mye mer interessant og mer utfordrende. Men det er egentlig den point-- Slik relativt enkel Det er, på slutten av dagen, hvilken Datamaskinen gjør for å lagre informasjon, til å lagre innganger og til slutt lagre eller representerer disse utgangene. Men tallene alene er ikke alt det interessante. 

Så mennesker, noen år siden, besluttet, vet du hva? Det ville være fint om datamaskiner var ikke bare kalkulatorer for aritmetikk operasjoner, men faktisk kunne gjøre ting som tekstbehandling, eller e-post, eller mer moderne inkarnasjoner av slike teknologier. Og så verden besluttet vilkårlig, men universelt, at hvis du ønsker å lagre hovedstaden bokstaven A i en datamaskin, vet du hva? La oss bare bli enige alle til å lagre noen mønster av nuller og ones-- bits-- som til slutt representerer desimaltallet 65. Vi får bare alle enige om det. 

66 ville representere B, 67 ville representere C, og det er bunter av andre mønstre av nuller og enere, eller underliggende tall, som ville representere andre bokstaver fortsatt. Så hvis du slags mentalt absorbere dette for et øyeblikk, Jeg bevisst satt opp A til Jeg, hvor H en 72 og jeg er 73. Hvis en datamaskin og deretter, i sammenheng et tekstbehandlingsprogram eller en e-post, avdekket under panseret for å ha disse mønstrene av bits-- mønster bit som representerer 72, deretter 73, deretter 33-- hva kan dette stave på det programmet? 

Så hei, og deretter noe. Vi trenger ikke nødvendigvis vet, men faktisk 33-- ikke på kartet earlier-- var rett og slett et utropstegn. Så 72 var H, 73 er ​​jeg, 33 skjer å være et utropstegn fortsatt. Men det er alt fint og bra, og i virkeligheten i dag, i stedet for bare bruke syv eller åtte biter, takket være noe kalt Unicode motsetning til ASCII tilbake i dag, vi faktisk kan representere enda mer interessante karakterer enn bare disse originale engelske partisk bokstaver. Men vi kan også representere selv penere ting som farger. 

Hvis du noen gang har hørt forkortelsen RGB, rød, grønn, blå, at betyr bare at en datamaskin vanligvis bruker tre sett med bits-- et antall av biter som representerer et tall for hvor mye rødt du vil, et annet sett av biter for hvor mye grønt du vil, og et annet sett nummer for hvor mye blått du ønsker. Så et stort tall betyr mange rødt, lite antall betyr ingen rødt. Og så disse er snill middelverdier her. 

Så gi meg noen røde, gi meg litt grønn, og gi meg en liten bit av blått. Og hvis du blander disse tre nyanser av farge sammen, i dette tilfellet du får denne skummel skygge av gul eller brun. Men det mønsteret av åtte pluss åtte pluss eight-- så 24 bits-- venstre til høyre, er hvordan en datamaskin vil representere en bestemt farge. Nå er dette bare en prikk på en skjerm. Hvis du ser virkelig tett på TVen din datamaskin, vil du se prikker eller piksler. Og hvis du har en hel rutenett av piksler horisontalt og vertikalt, du har bilder. Og så hvis du tar et bilde og deretter vaske vis deg et annet bilde, en annen bilde, et annet bilde, et annet bilde, veldig fort, du selvsagt har filmer. 

Og så legge merke til hvor vi startet. Vi startet med disse nuller og enere. Vi jobbet derfra til desimal tall, hvordan vi representere dem. Nå har vi bokstavene i alfabetet. Men i andre sammenhenger vente, kan vi bruke noen flere biter og representerer farger. Så snart du har evne til å vise fargene, man har muligheten til å representere bilder og animerte gifs og andre slike tegn på skjermen. Og når du har en hel haug med bilder flyr av det menneskelige på en gang, det ser ut som levende bilder, og slik at du får videoer også. 

Så bruker disse svært enkle primitive gjør vi ha den måte å representere til slutt alle disse former for media. Og vi har abstrahert igjen og igjen og igjen, helt til vi få fra det laveste nivået til denne høyeste nivå. Så det gir oss denne generelt bilde av abstraksjon. Men vi startet her. 

Her Nå kan vi representerer i en datamaskin våre innganger med nuller og enere, våre utganger i nuller og enere, men hva som foregår inne i boksen? Det er der PC vitenskap blir interessant. Det er der du faktisk ta med eget sinn for å tåle å løse problemer. Vi kan nå fastsette, for Resten av semesteret, ja. Jeg vet hvordan binære fungerer. Jeg husker hvordan Ascii eller Unicode-- kartleggingen til letters-- fungerer. Og det absolutt står til grunn at vi kunne representere rødt og grønt og blå, og representerer multimedia i tillegg. Men dette er det interessante ting. Dette er hva som gjør noen stand til å løse problemer. 

Og et slikt problem vi liker å gjøre, ja, tar oppmøte, eller gjør dette algoritmer. Og igjen, kan jeg gjøre dette. Jeg kan gjøre en, to, tre, fire fem, seks, sju, åtte ni. Og jeg kunne skrive det ned for å holde styr på det. Men det er bare hvordan jeg ville representerer informasjonen. Eller jeg kunne gjøre dette faster-- to, fire, seks, åtte, ti, 12, 14, 16, 18, 20, 22-- det føles som to ganger så fort, men det er fortsatt kommer til å ta en hel masse tid. 

Men det viser seg, hvis vi utnytter ennå en annen resource-- og faktisk datamaskiner disse dager har flere prosessorer eller hjerne. Det viser seg datamaskiner kan gjøre mange ting på en gang, og faktisk vi, i dette rommet, kan representere akkurat dette. 

Så det er litt sosialt vanskelig, men hvis du ville humor meg for bare en tre-trinns prosess, la meg spørre alle på plass er det bare å stå opp for et øyeblikk. Stå opp. Så tenk deg selv, nummer one-- slik at alle i dette rommet, bortsett fra folk som ikke gjorde det oblige, tenker nummer én. Så det er nummeret ditt akkurat nå. Det er det første skrittet, eller som en datamaskin vitenskapsmann eller en programmerer vanligvis ville gjøre, skal vi for å begynne å telle til null. Hvis minste tallet vi kan representerer med disse lyspærer er null, ved bare å forlate dem hele av, jeg kan like godt bare begynne å telle fra null er i stedet for en. Og så det er hva dataforskere gjør. Så steg null, stå opp og tenke på nummer én. Det neste trinnet er dette-- par med noen stående og legge tallene sammen. Herlig. 

Så på dette tidspunkt, bokstavelig talt alle som deltar tenker på nummer 2, med unntak av for en merkelig person hvis vi har et ulikt antall personer i rommet. Og nå det tredje trinnet her kommer til å bli dette-- en av dere bør sette seg ned. En av dere bør sette seg ned, og hvis du fortsatt står oppreist, gå tilbake til trinn en. Greit. Greit. Slik at flere og flere mennesker bør bli sittende. Legg merke til at dette har indusert en loop-- en slags syklus. Noen av dere bør være klønete fast, går frem og tilbake mellom trinn en og to, en og to, en og to. Det er greit. Vår første bug. Vi skal beskjeftige seg med. Greit. La meg prøve å anspore ting sammen. 

I teorien er det bare en person som står som alle fortsetter å pare seg. Men la meg få fart på sakene med folk som fremdeles står. Hvilket nummer er det du tenker på? 46. OK. Gå videre og sette seg ned. Dere står fremdeles. Hvem er fortsatt stående? Hvilket nummer er det du tenker på? OK. 

Så vi vil komme tilbake til deg. I ryggen? Hva er det? 22. OK noen andre opp top-- ja? 34. OK. Over her på min right-- opp her? 132, veldig hyggelig. 22? 

OK. Og hvem som fremdeles står? Her borte? 46, veldig hyggelig. 72. Jeg kan ikke stoppe mye lenger. Ja? 30, hyggelig. Her borte? 23? 23. 

Og jeg tror det er alle bortsett fra dere, ikke noe press. Å vent. 28? Bare åtte. OK. Bare åtte. Her nede? 30. 23. 24. 18. Dette er det verst gjennomføring av denne algoritmen noensinne. OK. Så noen andre? Noen andre? OK. En til. 16? OK. 16. Greit. Så hvis jeg ikke har gått glipp av noen i blende her, når jeg trykker Enter, vi vil se, algoritmer, den Totalt antall personer i Sanders. Fordi igjen, det er som om alle som du satte seg, gikk antall bort til noen andre, til noen andre, til noen andre, slik at i teorien, til slutt, bare en klosset person bør overlates stående. Men det er fint. Vi sped ting opp manuelt. Det er spesielt vanskelig å se i denne bestemte plass. 

Og det totale antall personer vi tror det er her er 546. Det totale antallet jeg var hendt av undervisning stipendiater, som gjorde det den gamle skole treg måte, var 820. 

[Ler] 

[BIFALL] 

Det er greit. Så sikkert da, det er disse feilene. Og det er greit. Og så tenker tilbake på denne første gang noe du skriver ikke nødvendigvis fungere. Dette har skjedd med meg her også. Men la oss nå se på hvordan vi kan anvende denne samme idé til noe du kanskje har sett før, som er denne gammeldagse teknologien her-- en virkelig stor telefonbok. Og anta at denne telefonboken har 1000 sider og 1000 navn og tall alfabetisk innsiden av det. 

Vel, vi kan slags bruke en lignende Ideen til denne svært skadet, bare bruker meg. Jeg bare slags jukset ved å utnytte alle dere med mange og massevis av forskjellige CPUer eller hjernen utfører noen algoritme. Men hvis det er bare litt gamle meg, kan jeg fortsatt utnytte den samme essensen av en idé å dele og erobre det problemet igjen og igjen, hvor halvparten av dere, halvparten av dere, halvparten av dere, halvparten av dere, teoretisk holdt sitte ned, før vi igjen, teoretisk, med bare én person. 

Så i denne gamle skolen technology-- gjør vi ikke trenger denne map-- dette old school teknologi, vi kan begynne å lete etter noen liker Mike Smith, en side av gangen. Og jeg ser at nei, er ikke Mike her. Jeg er fortsatt i A-delen. Til slutt, jeg finner meg selv i B-delen. Og dette er en algorithm-- steg-for-steg instruksjoner. Begynn på begynnelsen og én side om gangen, se etter Mike Smith. Er dette correct-- dette algoritme eller tilnærming? 

Ja, det er riktig. Hvis Mike er her, til slutt Jeg får til ham. Men det er ikke effektiv. Det er tydeligvis veldig sakte. Så jeg kan utnytte samme twosies tilnærming. Jeg kan gjøre liksom to, fire, seks, åtte, ti, tolv. Det er dobbelt så rask. Jeg kommer til å komme til Mike raskere om han er der. Er det riktig? Ja, men jeg hørte en little-- nei. Nå hørte jeg et nei. Yeah. Det er en bug potensielt. Kanskje Mike bare tilfeldigvis blir klemt mellom to sider, fordi jeg flyr gjennom dette to om gangen. Så minst trenger vi noen slags betinget fix. Jeg trenger å si hei, hvis jeg treffer noen som navn som begynner med en T i stedet for S, Jeg bedre doble tilbake minst én side. Så buggy i starten, men fikses. Men ingen av oss kommer til å se etter Mike Smith gjennom en 1000 siders telefon bestille en side av gangen. Hva er en normal person skal gjøre? Du kommer til å gå til S ', hvis du visste hvor S-tallet. Du kan gå omtrent til midten eller litt skjevt mot slutten. Og jeg ser ned her og Jeg er i M-delen. Men hva vet du om dette problemet nå, at vi ikke nødvendigvis vet før med alle av oss bare å telle oss equivalently? Vel, Mike er helt klart kommer å være i denne halvdelen av boken hvis han er her i det hele tatt fordi det er sortert. 

Og så kan du veldig dramatically-- 

[Gisper] 

Jeg vet. 

[BIFALL] 

Det er faktisk veldig enkelt hvis du gjør det nedover ryggraden der. Men du kan da kaste halvparten av problemet bort. Nå er jeg igjen med det samme problem-- finne Mike Smith i en telefon book-- men nå telefonboken starter på M og går til Z, men det er halvparten så stor. 

Men dette er hva som er imponerende. Akkurat som i teorien, dere, når dere alle satte seg bare halvparten om gangen, problemet fikk halvparten så stor, halvparten så stor, igjen og igjen. Så har dette problemet blitt samme problem, men halvparten så stor. Nå er det en 250-side problem. Så snart jeg skjønner, oh, jeg er i T seksjon ved et uhell. Jeg har gått for langt. Jeg kan kaste at halvparten av telefonboken unna. Nå er jeg ned til en fjerdedel av problemet. 

Og du kan gjenta, gjenta, gjenta til, i teorien, er du igjen med bare én side. Og hvis Mike er på den siden, Jeg kan nå løse dette problemet. Men hvor fort jeg løse det? I det første tilfellet, tok det meg som kanskje 1.000 skritt for å finne Mike Smith. Det kan ha tatt me-- Jeg plukket opp telefonboken og jeg begynte å se en side om gangen, og Mike kanskje 1000 sider senere. 

Andre tilnærmingen kanskje tar meg 500 trinn, fordi jeg flyr gjennom to om gangen. Og den tredje tilnærming skjønt, det er spesielt kraftig. Men la oss vurdere hva vi faktisk gjorde med denne tredje tilnærmingen. Jeg har det jeg vil kalle nettopp disse uttalelser her, en av gangen. Plukk opp en telefonkatalog. Åpne til midten av telefonboken. Se på navnene. Og så ting blir litt mer intellektuelt interessant, hvis det fortsatt enkelt. Hvis Smith er blant navn på den gjeldende siden, deretter gjøre noe betinget. Det er som et veiskille. Ring Mike. Hvis Mike er blant navnene På den siden som heter Mike. Men bare gjøre linjen fire hvis linjen treet, om du vil, er sant. Svaret på det spørsmålet er ja. 

Else hvis Smith er tidligere i book-- med andre ord, hvis jeg er i M seksjon og jeg leter etter noen å venstre, så hva jeg skal gjøre er noe lignende. Da skal jeg åpne til midten av den venstre halvdelen av boken. Så går du til venstre, og deretter gå tilbake til trinn to. Se på navnene der. 

Så med andre ord, gjøre det samme, men på et problem som er blitt halvert. Du vet hva annet? Hvis Smith er senere i boken basert på den siden jeg ser på, åpen til midten av høyre halvdel av boken og deretter gå tilbake igjen til trinn to, else-- det er en fjerde mulighet her. Mike enten her eller til venstre eller til høyre eller ikke der. Og her er vi bedre vurdere dette. Og faktisk, hvis du noen gang har hatt datamaskinen bare krasje på deg, det er noen ganger, men ikke alltid, Resultatet av bare en human programmerer ikke realisere, oh skyte, det er faktisk denne fjerde scenario. Og hvis du ikke skrive kode å håndtere dette scenariet, noen ganger du ikke vet hva maskinen kan gjøre. Og faktisk et program kan krasje. 

Men i dette tilfellet, tenkte jeg om det, og jeg sa, ellers slutte, fordi det er den fjerde logisk mulig scenario. Nå, la oss bare legge noen vokabular så vi kan begynne å kaste rundt begreper som er ellers ganske intuitiv. Alle de tingene jeg har bare uthevet i gult her, Jeg skal bare til funksjoner eller prosedyrer. De er bare slags handlinger. Så plukker opp, åpen, se på, ring, åpne, åpne, quit-- disse er bare handlinger, eller vi vil kalle dem mer formelt, funksjoner. 

I mellomtiden, nå i gul, Jeg har uthevet ting at-- la oss bare begynne å ringe dem forhold eller grener. Dette er beslutningspunkter der du kan gå på denne måten, på denne måten, eller annen retning i ro. Så de som vil være forhold. Og nå er dette en er litt mer avansert. La oss kalle disse spørsmålene Boolske uttrykk, etter noen med et etternavn Bool. 

Og en boolsk uttrykk er bare noe det er enten sant eller usant, ja eller nei. Så det er spørsmålet som har svaret du bry seg om, slik at det i en betingelse lage en decision-- få tilbake et svar, og deretter gå til venstre eller høyre, eller noe helt annet. 

Og så til slutt, disse linjer her-- gå tilbake til trinn to, gå tilbake til trinn two-- vi kunne implementere denne ideen på forskjellige måter. Og så de av dere med programmeringserfaring kan ha gjort eller kan tenke deg å gjøre dette på en annen måte. Men for dagens formål, er det bare tanken som teller. Dette er induserende hva vi vanligvis kaller en loop-- en slags syklus, fordi det gjør meg til å gjøre noe nytt. 

Så nå, la oss bare vurdere hvor god denne algoritmen er. Det er riktig. Hvis Mike i boken, er det en av de fire scenarios-- igjen og igjen og igjen, vil vi finne ham. Men hvor bra er det? Vel, vi har ikke å være for formell her. Men la oss bare plotte noe, x og y, å komme en følelse av formen på dette problemet. 

På x-aksen er her størrelsen på mitt problem. Og de en y-akse her vil være tid til å løse. Så kanskje dette er antall sider. Kanskje dette er sekunder side turns-- uansett. Men du vil telle er hva dette bildet vil representere. Og det første algoritme, jeg kommer å beskrive som bare en rett linje. Hvis det er n sider telefonboken, så det kan ta meg så mange som n skritt for å finne Mike. Hvis Verizon eller telefonselskapet legger en mer side neste år, det kan ta meg en mer step-- en mer enhet av tid til å finne Mike. Så det er nettopp dette 12:59 forholdet. Det er en rett linje skråning. 

I mellomtiden, det andre algorithm-- hvis jeg er kommer to på en tid-- to, fire, seks, åtte eller double-- gå gjennom sidene to ganger på en gang, to om gangen, det er fortsatt rett linje. Det er nå ett til to forhold, men litt lavere. Så hvis det er så mange sider på kartet her i gult, som kan ta meg dette mange trinn eller sekunder, ellers kommer det til å ta meg dobbelt så mange på den røde linjen. 

Men den grønne linjen er den virkelige takeaway. Dette er hva vi vanligvis kalle en logorithm-- logg n, der n er antall sider. Men det er den formen som teller i dag, fordi vi ikke har å engang tenke på å plotte poeng. 

Tenk om en ekstrem situasjon. Anta at Verizon morgen dobler antall sider i denne telefonboken, fra 1000 til 2000. I den første algoritme, jeg kan kaste bort en ekstra 1000 trinn leter etter Mike, bare fordi Verizon doblet størrelsen på boken. Den andre algorithm-- det kanskje ta meg en ekstra 500 trinn. 1.000 flere sider, går jeg to på en tid-- 500 flere trinn for å finne Mike. 

Men det tredje algoritme er litt magisk. Verizon dobler antall sider fra 1000 til 2000, Men hvor mange flere trinn gjør det tar meg å lete etter Mike? Det er bare en, fordi jeg kan bare rive telefonboken en gang til fra en 2000-side problem til en 1000 side problem, og voila. Jeg har tatt en massiv bit av det. 

Og hvis du går virkelig ekstreme, anta at telefonboken Selskapet hadde noe gale som en 4 milliarder siden telefonboken. Vel hvor mange skritt kan det ta å finne Mike Smith i en 4 milliarder side telefonboken? Det er et stort tall, men bare 4 milliarder til 2-1 milliarder for å 500 millioner kroner, 250 million-- fortsatt høres ut som store tall, men jeg er veldig fort bli mindre verdier. 

Og faktisk, hvis jeg gjør matte Greit, jeg kan bare dele 4000000000 med om lag 32 ganger før Jeg kommer ned til bare én. Så hvis det telefonboken var 4 milliard sider lang, ingen big deal. I løpet av noen sekunder, kanskje 32 sekunder, jeg kunne dele den i to og til slutt finne Mike eller konkludere med at han ikke er der. Og det er essensen av en algorithm-- en god algoritme. Og det er en av de målene for en klasse som dette, prøver å finne ut hvordan jeg løse problemet ikke bare riktig, som jeg alltid visste hvordan du gjør det en side om tid-- men riktig og godt. Hvordan utforme jeg god løsninger på problemer? Så la oss ta et øyeblikk her og gi deg en følelse nå av CS50 kurset itself-- introdusere noen kurs medarbeidere. Like før 02:00, vil vi ta en kort pause slik at de av dere som kjøper kan dukke ut og ta en se på noen annen klasse og se resten av dette nettet. Men for nå, la meg introdusere CS50, klassen selv, og spesielt det som er nytt. 

Så fortiden vår, vi brukt ganske mye av tid-- kursets ansatte og I-- tenkning om hva det er vi ønsker CS50 å være, og gå tilbake til første prinsipper, så å si, å vurdere hva det er vi ønsker dette kurset for å se ut og være som for sine studenter. Og så vil du se i problemet satt null i tillegg, en invitasjon å ta en titt på det URL som oppsummerer noen av motivene bak følgende karakteristikk av høsten 2016. 

Så som du kanskje har sanket fra TL: DR handout, pensum i dag, samt fra kurskatalogen i år i CS50, du er bare forventet å delta today-- så jobben godt done-- og den siste forelesningen 21. november. Og du er velkommen, men ikke forventet å delta på disse foredragene i midten, fordi det vi gjør dette året, er skyting i sanntid kursets materiale. Så alt vil bli nåværende og innlemmet som best vi can-- aktuelle hendelser og samtaler som folk kan være å ha i industrien i verden, men gjør at materialet tilgjengelig, som et resultat, selv earlier-- komplett med fulltekst transkripsjoner og søkbarhet og lenker til andre ressurser. 

Og ja, vi har vært hevdet i noen tid og vi har nå tror dette, at vi kan skape, digitalt, en mer oppslukende, en mer overbevisende pedagogisk erfaring, i motsetning å samle her noen 23 ganger i person, høre noen liker meg bare snakke om informatikk, i motsetning til å engasjere mer aktivt. Så du vil se i kursets pensum en skisse av semesteret her, sammen med når forelesninger vil bli filmet, som du er velkommen, men ikke forventet, og når de vil bli utgitt på kursets hjemmeside. 

Og hva vi skal gjøre her på Onsdager starter neste uke, er mye mer intimt, med bare de folkene som ønsker å delta, er en såkalt vandring gjennom, der jeg og kursets hoder faktisk vil gjøre ting en litt mer intim ned her i orkesteret delen, fortsatt har noen teknologi og gå gjennom værende ukes problem sett, og tilbyr deg particularly-- om blant de mindre komfortabel-- alle mer veiledning som du kanskje ønsker eller trenger for ukens utfordring. Og på samme måte, for de som ikke kan tilfalle den i person, ingen big deal. Det skal likeledes ledet av en av kursets seniorer, Zamalya, den samme muligheten innebygd i problemet setter seg. 

Problem setter i år vil bli utgitt på fredager og ikke lenger gjøre syv dager senere, men 10 dager later-- bevisst overlappende med hvert problem satt, for derved å bedre plass, vi håper, flo og fjære i student tidsplaner, spesielt når midterms eller friidrett eller akademikere eller extracurriculars tendens til å komme og gå spesielt mid-semester. Det burde gi deg litt mer skjønn om hvorvidt du foran laste uke med CS50 eller returfrakt det på neste helg i stedet. Så se til kursets pensum her for planen om dette. Og du vil legge merke til også blant endringene i år, for de mer kjent med programmering i det siste, Vi starter semesteret som vi vil i dag i Scratch, fokusere spesielt på språk heter C, og deretter overgang ikke til PHP, men til et språk som heter Python mot slutten av semesteret i sammenheng med web-programmering, sammen med SQL og Javascript, HTML, CSS, og enda mer. 

Og som svar på et spørsmål, det er faktisk tilfelle at CS er ikke så skummelt som jeg en gang trodde det var, men det er så mye arbeid som jeg hadde hørt det kan være. Men dette er det å si at her er noen statistikk fra høsten 2015 studentmasse, der de horisontale blå linjer representerer gjennomsnittlig antall timer rapportert. Og du vil se et gjennomsnitt på seks til 10 til 12-- kanskje 16 eller så og så videre, men med høy varians for å være klar. Og så innser at det er ikke bare studentene mer behagelig og mindre komfortabel i kurset, men en tilsvarende støtte struktur for å få de studentene gjennom semesteret vellykket. 

Faktisk, som svar på et spørsmål, bør du tar CS50 som et første året? Absolutt. Og faktisk, jeg angrer ikke ha funnet min vei eller funnet et nytt felt det første året også. Og skulle du ta CS50 med andre kurs, absolutt samt-- og generelle råd vi kan gi studentene, det er CS50 sannsynligvis ikke den slags klasse eller intro klasse at du bør ta med tre andre eller fire andre p-set klasser. Men hvis du tar to andre p-set klasser, noe annet, og CS50, absolutt overkommelig. Jeg har hatt mange studenter i tidligere gjort det ganske vellykket. 

Og for å få deg mot at Finish Line vellykket, har kurset har sections-- ulike spor for studenter mindre behagelig, mer komfortable, og et sted i mellom, hvor i kursets første problemet sett, du blir bedt om å beskrive deg selv. Og hvis du er blant de mindre komfortabel, det er den type ting som du bare heller vet. Og ja, det har vært det voksende demografisk i CS50 for ganske mange år. 

Som i fjor høst for eksempel 58% av klassen beskrev seg selv som blant de mindre komfortable, med 9% blant de mer komfortabel, og deretter de andre elevene der i rød beskriver seg selv som et sted i mellom. Og du vil se her emnene generelle og tidsplan for seksjoner, som alle tilbys i person i sanntid, med kursets fantastisk stab av undervisning stipendiater og selvfølgelig assistenter, noen av dem du vil møte i løpet av et øyeblikk. 

Seksjoner seg selv, som du ser, vil være mandager og tirsdager og onsdager, slik som å tillate deg å dykke i etter engasjerende, om du så velge, i kursets foredrag tidligere denne uken. Og deretter kontortid, som absolutt, med hvert år som går, ha vært noen mindre av en utfordrer for kurset. Og i år, vi planlegger ikke bare for å holde kontoret timer-- en på ett muligheter for hjelp til studenter på onsdager tors og søndager, den siste av dem å være i ettermiddag ved design å redusere noen av stress som alltid oppstår med sen kveld p-settting med en frist looming-- men kontortid vil også bli tilbudt på mandager og tirsdager og Onsdager og fredager og lørdager, Takk til våre venner på HSA. 

CS50 har nå sin egen plass for studenter og CS50 ansatte, toppen 67 Mount Auburn Street, akkurat der i Harvard Square. Visjonen for dem er at CS50 er TFS og instanser i løpet av uken, ganske mye gjennom det meste dager, vil være der for støtte. Så hvis du har noen spørsmålet på en p-sett eller du føler deg litt blokkert eller litt forvirret, og pokker, du har en time eller en halv time mellom klasser, spesielt i square-- kan du sette inn og ta det spørsmålet besvart av har det forvirring clarified-- veldig mye i ånden, du er kjent, for regnestykket avdelingens egen matematiske spørsmål sentrum, men ganske mye døgnet per rundt [? Gcal?] At vi vil legge ut på nettet. 

Veiledning er også tilgjengelig for de studenter, fritt fra kursets egne ansatte hvis du ønsker mer intimt en mot en, eller to eller tre klassekamerater bare, arbeider med en av kursets ansatte. Og ja, er disse her bare noen av kursets ansatte, noen av dem vil du møte i løpet av et øyeblikk. Faktisk, CS50 egen hode undervisning stipendiat, og hodet kurs assistent, og veileder, kunne komme på opp, tillate dem til å si hei. 

[BIFALL] SPEAKER 1: [hørbar]. 

[BIFALL] SPEAKER 2: [hørbar]. 

[BIFALL] SPEAKER 3: [hørbar]. 

[BIFALL] 

DAVID MALAN: Og la oss bringe ombord to av CS50 mest seniorer, Rob og Zamayla også. 

[BIFALL] 

Ja, både Rob og Zamayla har vært med oss så lenge, at jeg var i stand å gå inn i CS50 arkiver og finner dette svært SD opptakene av dem som deltar på scenen selv for noen år siden. ROB: [hørbar]. 

[BIFALL] ZAMAYLA: [uhørbart] 

[BIFALL] DAVID MALAN: Takk. Så i tillegg til disse gruppemedlemmer her, CS50 har et team av nesten 100 ansatte, som alle vil være tilgjengelig for seksjoner og arbeidstid og så mye mer. Og som Rob sier også, er dette den mest signifikante overhaling av CS50 i de 10 årene som Jeg har vært i [hørbar]. [Hørbar] fokusert spesielt i å gi en støttestruktur, trimming bort mye bulk som har vært akkumulert i 10 år iterative utviklingen på kursets oppgavesett. 

Så dette året, ikke bare i klassen, men også i form av kursets problem sett, bør du finne ting til bli mer strømlinjeformet, trimmer, mye mer håndterlig enn i år tidligere, som vi felle noen av bagasjen som er utviklet av natur utviklende år etter år og itera. Så den nye og forbedrede begynner i dag. 

Du vil møte litt mer av kursets ansatte ut i [hørbar] på 2:30, hvor vi serverer, som en tradisjon, kake. Det er litt mer kake enn det, men du vil møte Erin og Tobias og andre fortsatt. Og la meg gi deg en tur før vi hører fra noen av de andre ansatte i klassen, av hva som venter i tillegg. Faktisk starter vi alltid CS50 s semester kommende lørdag, med det som kalles CS50 Puzzle Day. 

Det har ingenting å gjøre med informatikk per se, men med om problemet løse mer generelt. Og hvis du velger å delta, per noen av invitasjoner, du kanskje har sett dør droppet eller på scenen her, det er en mulighet i team av to eller tre eller fire, til å delta for gåter og pizza og premier og mer-- denne lørdagen, følg med for mer. 

Du finner også at hver Fredag, på Fire and Ice, gjør CS50 bringe en hel haug av studenter til lunsj, for å gjøre en stor klassen føler seg mer intimt, og generelt bringe sammen alumni og venner fra industrien å snakke om hva de har vært opp til siden han ble uteksaminert. På samme måte i år, vil vi innvie den første noensinne CS50 50 koding contest-- en mid-semester mulighet til å tillate alle på en opt in basis, for å ha en Utfordringen med vettet mot klassekamerater, igjen i team på to eller tre eller fire, kun ved hjelp av at programmering kunnskapsrike at du da har under beltet etter bare seks eller syv uker med klassen, og deltar i denne type konkurranse online-- hvis du ønsker å finpusse din egen ferdigheter enda mer i denne utfordringen. På slutten av semesteret er den såkalte CS50 Hackathon-- en mulighet som begynner på 07:00 PM slutter kl 07:00, og underveis er 12 kveldstimene der å dykke i kursets siste project-- en mulighet til å designe og implementere de fleste noe av interesse til deg med undervisningen stipendiat veiledning. Rundt 09:00 gjør vi vanligvis serverer pizza, 01:00, Philippe-tallet, og noen av oss som fortsatt er våken på 05:00, er shuttle busset ned Veien til IHOP for frokost. 

Og så et par dager senere er den såkalte CS50 billettpris en slutten av semesteret utstillingen i feiring av hvor langt så mange av CS50 studenter har kommet fra uke null hele veien til uke, og husk at 73% av de klassekamerater og din dette året har aldri tatt en CS klasse før. Faktisk, for å reemphasize så mye, her er noen flere ansikter fra CS50 ansatte. SPEAKER 4: [hørbar]. SPEAKER 5: [hørbar]. SPEAKER 6: [hørbar]. SPEAKER 7: [hørbar]. SPEAKER 8: [uhørbart] SPEAKER 9: [hørbar]. 

SPEAKER 4: [hørbar]. 

SPEAKER 10: [hørbar]. SPEAKER 11: [hørbar]. SPEAKER 12: [hørbar]. SPEAKER 13: [uhørbart] 

SPEAKER 14: [hørbar]. 

SPEAKER 13: [hørbar]. SPEAKER 15: [uhørbart] SPEAKER 16: [hørbar]. 

SPEAKER 11: [uhørbart] SPEAKER 5: [hørbar]. DAVID MALAN: Noen av teamet er selv handle klasser. Men hvis disse medlemmene av CS50 ansatte er her, kunne komme på opp for bare et øyeblikk. CS50 er TFS og instanser og [? ansatte?] Medlemmer her-- disse er bare noen få av faces-- hvorav du bare så, og noen other-- og noen få andre fortsatt. Hvorfor kan ikke vi gå videre og tillate dere en fem minutters pause. Hvis du trenger å dukke ut til butikk klasser, er det helt greit. Og i fem minutter, vil vi fortsette, ta en titt på Scratch-- første av vår programmeringsspråk, møte kursets ansatte her litt mer, og fokus slutt på oppgavesettet null. Så vi vil være tilbake i fem minutter. 

[BIFALL] 

Greit. Så vi er tilbake. Og i våre rester tid i dag, målet er til nivået de spiller feltet i form av noen terminologi, i form av noen ideer. Fordi ja, som per noen av listene tidligere, det kommer til å være en rekke nivåer av erfaring i klassen, noen av som studentene har tatt noen programmering før, noen av dem har ikke det. Og så med dette første problemet set og med dette første språk har vi en mulighet til å starte å ta for gitt etter i dag noen felles vokabular og idé. 

Og vi vil gjøre dette ved hjelp av kursets første languages-- i tillegg til C og Python og Javascript og SQL og HTML og CSS, Vi skal fokusere utgangspunktet og bare for oppgavesettet null på dette grafisk språk, kalt Scratch, utviklet av MIT Media Lab nedover veien, for å hjelpe studenter og barn spesielt uttrykke seg algorithmically-- på en måte mer i samsvar med hva vi kan kalle beregnings tenkning. 

Og det er et nyttig språk fordi svært raskt neste uke i uke en, gjør overgangen vi til en mer tradisjonelle og uforståelige språket kalles C, som er en ren tekst. Du bruker bare tastaturet i For å skrive instruksjoner som disse på skjermen. Men selv om du aldri har sett et programmeringsspråk før, i bare skotter på dette, alle være det kryptisk, du kan sikkert gjette at sannsynligvis skriver Hello World. Men det er mye syntaktisk overhead der. Det er rart hash symbol eller hash tag opp toppen. Det er de vinkelparenteser, noen parentes, klammeparentes, semi-colon-- det er bare så mye visuell syntaks som kommer i veien. Vi starter kurset med Scratch, slik som å bli forbi alle de intellektuelt uinteressante distraksjoner, og fokuserer i stedet på ideene. 

Faktisk kan dette være før. Dette, for dette skal uke være etter. Dette, i denne grafiske språket Scratch, er hvordan du vil implementere det samme program-- et program som når det kjøres, bare sier hei verden. Og hva er fint om Scratch er at det er dette grafisk programmering miljø som bruker puslebiter eller blokker, som bare forrigling sammen om det er logisk fornuftig å gjøre det. Og med Scratch kan du utvikle animasjoner og interaktive spill og kunst, og en rekke ting som du kan forestille deg i ditt eget sinn, og implementere dem bare ved dra og slippe puslebiter. 

Og ja, vi har muligheten å uttrykke noen av de samme ideene som jeg nettopp nevnte et øyeblikk siden i sammenheng med Mike Smith og søker en telefon book-- ting som fungerer, bare handlinger, ting som sløyfer som gjør ting igjen og igjen, variabler, som er noe vi vil innføre, men det er kjent kanskje fra algebra-- bare en slags plassholder til å lagre noen verdi du kanskje trenger later-- boolske uttrykk, hvor de ja nei eller sann falske spørsmål fra før. Forholdene er de gafler i road-- disse grenene så å si. Og så er det noen mer avansert funksjonene vi vil se selv i dag, kalt arrays og tråder og hendelser, som vi vil da se i løpet av tid på forskjellige språk. Men Scratch tillater oss å utforske alle disse. Så her i Scratch, fiolett blokken er hva en funksjon er vanligvis kommer til å se ut. Denne lilla puslespill brikke som har noen ord som sier, som er handlingen, og da kan det ha en argument eller en parameter-- noen måte av typen tilpassing hva som blokkerer gjør slik at det ikke er forhåndsbestemt av MIT hva dette lilla blokken sier. Faktisk vil du se i en øyeblikk at jeg er i stand til å skrive ordene som hello world, eller Hei David, eller hallo Zamayla, eller hva jeg vil, i argumentet til at puslespillet piece-- den hvite boksen der. I mellomtiden, hvis jeg vil ha en løkke, vil vi se at det er puslebiter som ser litt oransje som dette. Og formen slags tyder på at noe skjer igjen og igjen i en syklus. 

Så hvis jeg vikle en si hei verden blokk med en evig blokk i Scratch, det bare kommer til å fortsette å si hei verden for alltid, bokstavelig talt. I mellomtiden, det er en annen type sløyfe i Scratch at vi vil see-- en gjentakelse block-- der, hvis du vite på forhånd hvor mange ganger du vil at loopen skal utføre et endelig antall ganger i fact-- deg kan spesifisere at ved å skrive inn et tall eller til og med koble til en variabel, som x eller y som vi får se. 

Faktisk, variabler som I I dette tilfellet, som er et vanlig navn på en heltall variabel som bare lagrer en number-- et helt tall kan være, å bruke denne oransje blokk her for å sette en variabel som jeg til null. Her er et eksempel på grønne av en Boolsk uttrykk i Scratch. Selv om dette ser ut som en matte formel, matematiske ulikheter som dette egentlig er boolske uttrykk. Dette er enten sant eller usant. I er mindre enn 50. Det er enten et ja eller nei svar eller sant eller usant svar. Og vi vil vanligvis kaller de boolske uttrykk. Og det trenger ikke å være 50. Det kan være x mindre enn y, er større enn y, lik Y- hvilket som helst antall annen spørsmål kan bli spurt. 

Nå, ved første øyekast kan dette se plutselig ganske dristig her, og det er. Men konseptet er lurt, det ganske kjent fra før. Dersom x er mindre enn y, enn si så mye. Else hvis x er større enn y, så si så mye. Else si x er lik y. Så vi har et eksempel det av en tredje scenario-- den eneste tredje possibility-- x er enten større enn, mindre enn, eller lik. Så vi har en treveis veiskille. 

Og legg merke til hva som er kult her-- Scratch, det ville virke, har bare en oppgave stykke, i dette tilfelle, i hvis annen blokk. Og likevel som synes å innebære at du kan bare har en toveis veiskille. Du kan gå til venstre eller høyre, men hva om det tredje scenariet? Hva hvis x er lik y? Ingen stor sak. Ta en puslespillbrikke, sette en annen en på innsiden av det for å lage den tilsvarende semantiske om hvis, annet hvis, else-- og nå har din treveis veiskille. Og så får vi se, det Scratch brikkene kan strekkes og vokser, så som å stappe flere ting i dem. Du trenger ikke å passe alt i standardstørrelse. 

Dette er noe vi vil snart se kalles en matrise. Det er som en list-- noen måte lagre flere opplysninger i en variabel, ikke bare et tall. Dette vil vi se en representant for noe som kalles multi-threading. Faktisk, alle dine Mac og PC i disse dager støtter multi-threading, noe som betyr at du kan bokstavelig talt gjøre flere ting på en gang. Du kan ha Microsoft Word opp i forgrunnen, arbeider på noen essay. Du har kanskje en nettleser i bakgrunnen åpningen G-post eller Facebook eller lignende. Datamaskinen kan gjøre flere ting i dag fordi det er multi-threaded, og programmene de er ii Spesielt er også multi-threaded. 

Det finnes ting som kalles hendelser som godt i verden av Scratch, og så er det en måte også, for å gjøre våre egne tilpassede brikkene hvis ting ikke faktisk eksisterer på forhånd. Så la oss motivere dette som følger. For noen år siden, da jeg først oppdaget Scratch, da jeg var faktisk en grad student ved MIT, vi selv fikk i oppdrag å gjøre lekser. Og jeg implemented-- som i ettertid var en veldig dårlig avgjørelse fordi det er den mest irriterende sangen i verden å høre på i åtte timer mens du arbeider på din homework-- men noe jeg hadde kalt Oscar Time, som er kanskje en kjent sang. 

CS50s eier Jordan Hayashi, en av våre mer senior medarbeidere, har oppgradert det for 2015 og nå 2016, siden tilbake i dag, Jeg hadde alt bare går i Oscars søppelbøtta. Nå støtter vi resirkulering og kompostering. 

Men for å male bildet av hva vi kan gjøre her og for å motivere noen av lavere nivå eksempler, kan vi få en annen frivillig å bare komme på opp og spille min første lekser oppdrag noensinne? Kom opp. Hva heter du? 

HENRY: Henry. 

DAVID MALAN: Henry, kom opp. Kom opp. Hodet uansett, og du vil se i et øyeblikk, Jeg kommer til å gå videre og traff grønt flagg i øverste høyre hånd hjørne, noe som betyr gå. Den lille stoppskiltet ikonet kommer til å si stopp, og det er da du begynner og stoppe programmet. Hyggelig å møte deg. Greit. Så vi kommer til å se instruksjonene på skjermen i bare et øyeblikk. Og bare ved å spille dette spillet for noen seconds-- stole på meg, vi kommer ikke til å ønske å spille hele veien til end-- du vil få en følelse av hva programmet gjør. Og mer enn bare fokusere på Henry være god eller dårlig i dette spillet, fokus og hvordan ble det iverksatt av meg opprinnelig og deretter ved Jordan. Med andre ord, der er variablene? Hvor er sløyfene? Hvor er de funksjonene? Og vi får se om vi ikke ser de under panseret. 

Bare klikk og dra søppel til riktig bin. 

[MUSIKK] Greit. Det er veldig bra. Hvorfor kan ikke vi stoppe det der. Takk skal du ha. Gratulerer til Henry. Takk skal du ha. 

[BIFALL] 

Tenk deg debugging det programmet. Hvis det er et problem to minutter inn i song-- men så hva som skjer her egentlig? Så komplisert som det kan begynner å virke for å komme over tid, faktisk mer og mer ting begynte å falle, hva som er interessant om denne typen example-- og vi får se noen others-- er at hvis du se forbi kompleksitet eller raffinement av spillet, det er en veldig enkel bygning blokker som spill slik: alle, hvis du destillere dem til de byggeklosser, er svært tilgjengelig og gjennomfør til seg selv. For eksempel er det vært en stund, men jeg er ganske sikker på hva jeg i utgangspunktet gjorde da noe som gjør dette spillet for første gang var jeg helt like utsatte. Jeg fokuserte ikke i det hele tatt på logikk eller brikkene, Jeg fokuserte på grafikk og funn gaten innlegg og søppelbøtta og alt dette. Men det var nødvendig ingrediensene først. Og når jeg er ferdig procrastinating og legge ut det overordnede rammeverket, Jeg bestemte meg, la meg bare gjøre en stykke søppel falle ned fra himmelen. Og vi får se Scratch støtter ting som kalles sprites-- tegn som kan har ulike kostymer på, slik at de se annerledes ut. 

Og så satte jeg en søppel drakt på en slik sprite. Og jeg trengte det å falle ned fra himmelen. Og så viser det seg, Scratch, som de fleste programmeringsspråk, støtter tilfeldige tall eller teknisk pseudo tilfeldige tall, slik at ved å dra og slippe enkelte brikkene, Jeg var i stand til å ha søppel kommer fra venstre først. Og så neste gang det falt, fra høyre og deretter fra midten. Og hele spillet gjorde var bare har søppel som faller fra himmelen. Du kan ikke peke på den, eller klikk på den. Du kan ikke åpne søppelbøtta. Du kunne ikke gjøre noe. Men det var en baby trinn mot min ultimate visjon. 

Og etter det, jeg faktisk implementert noen form av føle slik at hvis du klikket og dra på stykke søppel over søppelbøtta, Oscar Lokket vil åpne og lukke. Ingenting ville skje med søppel, men i det minste lokket vil åpne og lukke. Så sjekk, trinn to av to. Og dette er hva som kommer til å være nøkkelen i både oppgavesettet null og i programmerings mer generelt, skal ta disse svært bevisste baby trinn. Fordi ikke bare tillater det deg å føler ærlig oppnådd mye mer quickly-- det er verste i verden å prøve å gjennomføre alle Oscar Time, deretter timer senere traff den grønne flagg, og ingenting fungerer som forventet fordi der har du selv begynne å feilsøke eller til feilsøke dette programmet? Det er bare overveldende. 

Og så virkelig omfavnende denne ideen av å ta steps-- små steg igjen og igjen-- bygge opp noe som er, til slutt, virkelig imponerende og komplisert, men i begynnelsen, er ikke på langt nær så mye så. Faktisk, la oss gjøre dette. La meg gå videre og-- Skrap selv finnes på Internett på Scratch.MIT.edu, og du vil bli fortalt som mye igjen i problemet angi null, spesifikasjonen for som allerede er på CS50 hjemmeside. 

Men dette er hva Scratch selv er. Og det er egentlig bare tre hovedområder. Øverst til venstre der er den såkalte stadium. Dette er Scratch. Standard drakt er en katt. Og dette er den rektangulære verden som du kan move-- opp, ned, venstre, høyre og noen andre ting. I midten her er våre kategorier eller våre paller med puslespillbiter, og forskjellige farger bety forskjellige ting. Og hvis du rote rundt, vil du se ting som looper og vilkår og variabler og andre ingredienser. 

Og så over her er det skript området. Det er der jeg kan dra og slippe disse brikkene til å gjøre ting. Så la oss gjøre en slik ting. La meg gå videre og-- og jeg vet hvor det er. Så jeg kommer til å umiddelbart klikk på der jeg vet at ting er klar til å være, men å peke og klikke og poking rundt er uunngåelig. Så når grønne flagget klikket, hva jeg ønsker å gjøre? Jeg kommer til å gjøre dette. Jeg kommer til å dra denne lilla puslespill stykke, si hei i to sekunder, og la meg zoome inn. 

Og jeg kommer til å endre dette å være hva jeg vil den skal be-- hallo verden i to sekunder er greit. Nå kommer jeg til å klikke på grønt flagg, eller hvis jeg virkelig vil, Jeg kan fullskjerm det og deretter komme tilbake. Det vil bare fortsette alt i ett vindu. Grønn flag-- hello world. Greit. Ikke alle som interessant. Så la meg gå videre og gjøre dette. La meg prøve en annen. Når grønt flagg clicked-- la oss gjøre noe som en lyd. Og legg merke til at av boksen for gratis du får en katt lyd, er som standard sprite. Så nå la meg gå videre og treffer det grønne flagget nå. 

[Meowing] 

Aw. Det er søt. Jeg programmering. Så hva har jeg gjort? Dette tilsvarer et program. Det er åpenbart super enkelt. Det gjorde egentlig ikke ta så mye innsats og MIT gjorde mesteparten av arbeidet, men jeg har kalt en funksjon. Jeg har brukt en funksjon. Jeg har gjort litt action, med bare at en lilla puslespill brikke. 

Vel, hvis jeg ønsker å gjøre tre meows på rad? La meg gå videre og gjøre to og tre. Og legg merke til at når du sveve i nærheten en puslespillbrikke, en liten hvit linje vises slags magnetisk, og det vil knipse sammen når du la gå. La oss se hva som skjer her. 

[Meowing] 

Det er en bug. Jeg hører bare ett meow. Hvorfor kan det være? Ja? Yeah. Vi har egentlig ikke høre det, men det er god intuisjon. De er alle spiller på samme tid. Hvorfor? Vel, er datamaskinen bare kommer å gjøre det du ber den om. Så hvis du sier, spille lyd, spille av lyd, spille av lyd, men du trenger ikke fortelle det å spille til du er ferdig, spille til du er ferdig, det kommer til å blåse gjennom programmet veldig fort og ikke bare det du ber den om. 

Så jeg faktisk trenger å fikse dette i et par måter. Jeg kunne bare gjøre dette, bli kvitt dette. La meg prøve denne andre pusle piece-- spille av lyd mjaue til ferdig, og deretter drar tre av disse og klikker Play. 

[Meowing] 

Det er egentlig ikke very-- takker you-- veldig naturlig. Så hvorfor ikke I-- la meg gå å styre her. Hyggelig. Vent ett sekund, og nå la meg gå tilbake til lyder og spill lyd til ferdig, og så la meg få vente ett sekund. Og så la meg gå og få en mer lyd, og her vi går. 

[Meowing] 

Litt mer naturlig, men dette er ikke veldig effektivt. Som jeg begynte å bli lei, alle være det kort, klikke frem og tilbake og virkelig duplisere min work-- ganske mye kopiere og lime inn. Faktisk, hvis jeg styre klikket eller høyre klikket, Jeg kunne bare ha kopiert og limt inn. Hva ville være en bedre konstruere å bruke? Hva idé fra før? 

Ja, så en loop. Og faktisk, hvis vi poked rundt, vi kan finne akkurat det. La meg gå til arrangementer eller snarere Control. Så repeat-- jeg ikke vil den skal være 10 ganger. Det kommer til å bli irriterende raskt. Men jeg vil gjenta tre ganger. La meg gå tilbake til lyd og spille av lyden før det er gjort. La meg gå tilbake til kontroll og bare vente ett sekund. Og legg merke til, kanskje du tror det ikke passer, men igjen hvis magnetisk du lar den snap på plass, vil det vokse til å fylle. Hvordan er det å spille nå? 

[Meowing] OK. Hyggelig. Og dette er hva som ville bli kalt et program som også er riktig. Det mjauet tre ganger ganske naturlig, men det er bedre utformet. Jeg bruker mindre redundans. Jeg hadde ikke kopiere og lime inn noe. Jeg bare brukt en bedre idé. 

Nå er dette fortsatt ikke alle som interessant med Scratch ikke gjør hva som helst. Så la oss gjøre noe annet i stedet. La oss gjøre noe for alltid. Og vet du hva? Motion virker interessant. La oss få ham flytte 10 trinn og trykke play nå. 

OK. Vel, vi kan slags drag ham tilbake, og han er fortsatt kjører fordi han gjør dette for alltid. Slik at sløyfen gjør hva det sier å gjøre, men dette er ikke alt som er interessant. La oss gjøre dette. La meg legge til et kontrollblokk, og bruke en av disse betingelser for første gang. 

Så det kommer til å flytte 10 steps-- 10 prikker, 10 piksler på screen-- så det kommer til å stille dette spørsmålet. Hvis noe er sant, så gjør noe inne i denne blokken. Så det viser seg sensing har en hel haug med boolsk expressions-- spørsmål av ja nei eller sann falsk form-- la meg gjøre dette. 

Hvis touching-- og så er det denne lille rullegardinmeny. Jeg kan parametrisere det. Hvis berøre edge-- la oss gjøre noe sånt. Så hvis berøre edge-- la meg gå tilbake til bevegelse. Og hvorfor gjør vi ikke bare snu 180 grader? Greit. Så evig, flytte 10 trinn. Hvis du berører den kanten, snu 180 grader. Og det er ikke slutten av programmet fordi du er i en evig blokkere, så det kommer til å gå igjen og igjen og igjen og igjen. Så la oss se hva som skjer. OK. Litt buggy, men litt kult. 

Og vi kan legge til denne noen dumme ting som ikke er alt som intellektuelt interessant. Men hvis vi traff denne lille mikrofon button-- au. La meg rydde opp dette. La meg forbedre dette som de ville si på TV. Rydde det opp, lagre og nå gå opp til skript. 

Og nå, la meg gå til lyd. La meg gi den et navn. Jeg vil kalle dette au. Og nå spille av lyd au. Legg merke til det vises i liten rullegardinmeny. La oss se. 

[AU] 

[Ler] Men vi kan endre t hans på fly. Vi kan være dobbelt så irriterende. 

[AU] 

Eller hvis vi gjør det som 1000 skritt på en tid-- 

OK. Så vi kommer til å la den ene alene. Så igjen, bygge blocks-- jeg startet med noe super enkelt, og da jeg lagt til en funksjon, lagt til en funksjon, lagt til en funksjon. Og jeg trenger ikke lenger å bekymre deg for hvor den første av disse funksjoner ble gjennomført som jeg fortsetter til lag ting på toppen. Så faktisk, la meg gjøre en annen her. La meg gå videre og åpne en fil som Jeg tok på forhånd, heter Sheep. 

Slik at den har en litt annen tegn som ser ut som dette. Og la meg se om jeg ikke kan gjøre noe ved hjelp av en teller i dette case-- en såkalt variabel. Jeg kommer til å gå videre og under Events-- la meg få et grønt flagg klikket. Så la meg gå til Data, som jeg vet fra bare spille rundt før, er der variablene er. Og jeg kommer til å gå foran og dra dette. 

Så en variabel kalt teller, og Jeg kommer til å initialisere den til null. Jeg kan kalle det anything-- x eller y eller z-- men i programmering, kalle noe i en semantisk nyttig måte, som teller, som beskriver hva det er, det er en mye lettere å lese koden din senere. La meg gå videre og få en evig blokkere her. Og la meg gå til utseende side og gjøre en Say blokk. Men hva som er kult om variabler er jeg trenger ikke å bare skrive inn noe som hallo verden, som vi allerede har gjort, kan jeg i stedet gå til Data og dra min variabel, og selv selv om formen ikke helt ser ut som det skal passe, det vil vokse til å fylle. Og jeg vil bare si telleren for en second-- spoiler-- han kommer til å telle. Vi vil si det i ett sekund. Så jeg kommer til å gå og ha ham vente i ett sekund, så det teller ikke opp for fort. Og så til slutt, endre teller ved one-- med andre ord øke telleren med en merverdi og gjøre dette for alltid. 

Så sau også, som en programmerer, teller fra 0. Og hvis vi venter lenge nok, han vil gjøre dette for alltid. Men det er ikke helt sant, fordi faktisk, som vi vil oppdage i uke en, heltall og datamaskiner mer generelt, teknisk har bare en finite-- godt, heller datamaskiner, når de representerer heltall, bare har et endelig antall biter. Disse lyspærer der kan bare telle så høyt før du er ute av lyspærer. Og en datamaskin også, bare har så mye minne, bare har så mange transistorer, slik at det bare kan telle så høy. 

Så det viser seg at sauene, Jeg tror, ​​kan telle til 2 milliarder eller noe ganske stort. Så vi ikke kommer til å vente på at dette skal skje. Men til slutt noen feil vil skje som kan ha noen svært virkelige verden ramifications. Men utover sauene, som bare innfører en variabel. La oss gå videre og åpne opp noe jeg har gjort på forhånd her kalt Pet den Cat-- Pet katten over her. Og legg merke til her er det noen blokker, men når grønne flagget klikket, for alltid å gjøre følgende. Hvis du berører musen pointer-- slik at markøren på skjermen, den arrow-- play sound meow og deretter vente i to sekunder. Og bare gjøre dette for alltid. Bare stadig vente for å se om den pointer-- hvis katten er rørende pekeren. 

Så jeg trykke play. Ingenting skjer. Men som jeg flytter markøren over katten, 

[Meowing] 

Og hvis jeg flytter den bort, ikke klappe katten lenger. Så noen betinget logikk nestet inne i en løkke. Hva med dette eksemplet, bevisst heter Ikke Pet katten? Hva er dette kommer til å gjøre? 

[Meowing] 

Hvorfor skulle du ikke klappe katten? 

[Meowing] 

OK. Slik at dette er et eksempel på en hvis annet. Det er et beslutningspunkt og fordi det er å sitte i loop, de er både å få sjekket. Er dette sant? Er dette sant? Er dette sant? Er dette sant? Og til slutt, en av de kommer til å søke og slik at du hører enten mjaue eller brølet av løven i så fall. 

Vel, la oss gjøre en litt mer fancy en som jeg har gjort på forhånd også-- tråder. Så en tråd er bare ett ting som en datamaskin kan gjøre. Så en multi-threaded program er et program som kan gjøre flere ting på en gang. Og alle disse eksemplene hittil har hatt bare ett skript, så å speak-- ett program som dette her oppe. Men legg merke til dette programmet har to sprites, to tegn. Den ene er en fugl. Den ene er en katt. 

Og legg merke til når jeg klikker på disse ned venstre, de har sine egne skript eller programmer som er knyttet til dem. Og begge disse programmer, varsel, start med når grønt flagg clicked-- La oss se på cat-- når grønt flagg klikket. Og så ja, når jeg trykker på play nå, to ting kommer til å skje på en gang. Katten og fuglen er begge kommer til å operere samtidig å skape denne effekten. Og du kan forestille deg hva som skjer. Det er en løkke og fuglen og katten er i en sløyfe. Fuglen er bare å sprette ut Jeg var før da jeg sa au. Men katten har helt klart en fordel. Det er en annen sensing blokk som peker katten med vilje til fuglen i dette tilfellet her. Så vi kan erte hverandre, ved å se gjennom disse blokkene, hva som skjer. Men hovedingrediensen her er ett. Fuglen, slik at dette spillet er ikke helt boring-- eller dette animation-- starter på et tilfeldig retning. Og datamaskinen er rørt et tall mellom 90 og 180 hovedsak, slik at det er en litt forskjellig animasjon hver gang. 

Og så merker her, hvis katt berører fuglen, da spille løven fire sound-- brølet. Men i mellomtiden i fugle palett, har vi dette. For alltid, hvis ikke berører katten, bare holde flytte tre trinn. Og så her er en annen puslespill brikke. Hvis du er på kanten, sprette. Så fuglen er bare slags minding sin egen virksomhet, bare flyr rundt og spretter, og det er virkelig katten som hadde betinget logikk for å fastslå om det hadde fanget fuglen. Greit. Så la oss gjøre en annen her, dette blir kalt Hi Hi Hi. Og dette her bare gjør dette i en evig løkke. Men notice-- hvordan stopper vi dette veldig irriterende program? Hit mellomromstasten. For hvis jeg gjør det, venstre hånd program-- merker det er stadig listening-- er nøkkelen plass pressen. Hvis mellomromstasten trykkes, og i så fall, hva gjør den? Det gjør en svært vanlig teknikk. Det setter en variabel lik noen verdi. Men det slår denne verdien. [? Så utseende?] basert på det shape-- I har en variabel som jeg skrev på forhånd kalt Dempet, som bare sier ja eller nei. Er lyden dempet eller ikke? Sant eller usant? Og legg merke til, jeg sier dette-- hvis dempet er null, og deretter endre til en, annet satt mute den til null. Så bare snu verdi fra null til en. Jeg kunne ha done-- endre det fra to til tre og ett femtisytti eller 04:56 eller 05:56. Men det spiller ingen rolle hva tallene jeg bruker, så lenge jeg holder endre det motsatt. 

Og de fleste enhver programmerer ville bare velge null og one-- falsk og sann, av og on-- å representere dette. Og dette er fortsatt kjører. Hvis jeg treffer på mellomromstasten igjen 

[SEAL SOUNDS] 

Programmet er fremdeles i gang. Fordi det er dette andre script som sier, alltid gjøre følgende. Dersom dempet variabel lik zero-- så hvis du ikke er dempet er logic-- om det er falsk eller nei, så spille av lyden, fordi du ikke er dempet. Du bør spille av lyden og deretter tror hi hi hi i to sekunder og deretter vente, og gjøre det igjen og igjen og igjen. 

Og så på den måten har vi en måte for folk to-- for programmer til å samhandle. Og de trenger ikke å bli som datert som andre. Faktisk, poking around-- Beklager ordspillet-- noen har brukt en stor mengde tid på internett implementere PokemonGo i Scratch. Det geolocates deg selv i Cambridge eller Allston her. Så hvis du ønsker å se for hva folk kan gjøre er dette-- veldig fancy meny. Klikk på her. 

Dette er meg med mine piltastene nå. Jeg kommer til å gå etter dette. Klikk. Og nå du klikker Pokeball. Jeg mener, jeg tror du er ment å klikke på Pokeball. Greit. Så jeg gjorde det. Jeg kan gå over her. Og denne personen iverksatt noen mer Pokeballs enn her-- tre Pokeballs. 

Vi vil legge ut en link til denne online slik at du kan spille. Men legg merke til det er bare noen grunnleggende byggesteiner. Det ser mye mer avansert, og det er. Dette er imponerende og mer enn vi ville vanligvis forvente, sikkert for oppgavesettet null. Jeg aner ikke hvor lenge denne personen brukt på nettet. Men det er bare en loop. Det er en lyd spilles. Det er en slags løkke lytter etter om jeg er trykke pil opp eller ned pil eller venstre og høyre, og hvis så, er den i bevegelse det enkelte antall piksler. Og så hvis jeg klikker på en annen sprite, det er en slags hvis tilstanden der. Ja, dette blir for intens. Vi kommer til å stoppe. Det er alle de grunnleggende byggesteinene. Det er ingen andre ingredienser andre enn de vi har sett på allerede. 

Og likevel her, la meg gjøre en endelig sett eksempler som tegner et bilde også av hva du kan gjøre her. Her er et veldig enkelt program som bare gjør dette-- hoste, hoste, hoste. Og kun basert på hva vi har sett på så langt, hvor er det åpenbare mulighet for forbedring. Dette program er korrekte. Det hoster tre ganger, som er det jeg hadde tenkt. Men det er dårlig implementert. Det er dårlig utformet. Hvorfor? Yeah. Det er ikke en loop. Og det er ikke så mye at det ikke er en loop, det er at det er mye redundans. Det er kopiert og limt inn koden, så å si. Og løsningen trolig er faktisk en løkke. Så la meg gå videre og forbedre det. Og jeg kommer til å dra disse over her. La meg gå videre og få en rapport blokk, endre dette til tre. Jeg kommer til å kaste bort noen av disse blokkene. 

Og du vil legge merke til det er ganske intuitivt. Du dra og slippe ting komme og forsvinne etter hvert. Og jeg kan bare dra dette inn her, og nå har jeg en renere versjon fortsatt. Men vet du hva? Det er denne muligheten nå for abstraction-- å begynne å definere nye vokabular at MIT ikke hadde forutsett. Det er vente og gjenta og for alltid, og hvis, men hva om jeg ønsker å introdusere ordet hoste som en blokk? Hva om jeg ønsker en puslespillbrikke hvis formål i livet er å hoste? 

Vel, la oss se på denne versjonen her, som jeg har gjort som følger. Magisk, jeg har laget dette puslespill brikke her, som Scratch lar deg gjøre. Og faktisk C og Python og Javascript er kommer til å tillate deg å gjøre dette også. Du kan lage dine egne brikker som du kaller det du ønsker. I dette tilfellet, føles hoste som en fornuftig definisjon. Og så med disse brikkene ned Her kan du definere hva det betyr. 

Jeg dras og slippes fra denne paletten her-- mer blocks-- denne store lilla blokk, der jeg skrev i hoste som navnet på min nye puslespill brikke. Og så jeg sier hver gang en bruker kaller dette nye hoste puslespill brikke, gjøre noe å si og en vente. Og så opp her i min gjenta blokk, Jeg kan bare hoste tre ganger. 

Og jeg vil hevde, spesielt hvis nå du skjule denne detalj. Hvem bryr seg om hvor hoste er implementert? Alt jeg bryr meg om som en programmerer som jeg kan hoste. Jeg bryr meg ikke om hvordan si er implementert. Jeg bare bryr seg om at katt kan si noe. Jeg kan abstrakt bort at detaljer og bare fokusere på det som er på skjermen her. Men jeg kan ta dette ett skritt videre. 

Legg merke til at her har jeg implementert sløyfen tre ganger. Men hva om stedet jeg hente denne versjonen? Og hva om stedet i denne versjonen her, Jeg bare endre min puslespill brikke for å ta et argument og innspill i seg selv? Og at innspill kan være et tall som tre. Så nå, hvis jeg skriver et program og jeg vil at katten å hoste, Jeg kan faktisk fortelle gåten sette hvor mange ganger å hoste, fordi nederst her, en mer avansert versjon av disse tilpasset puslespillbrikker lar meg spesifisere at hoste faktisk tar en input-- tar et argument som dette. Og vet du hva? Kanskje jeg skjønner, vent litt. Hoste er same-- det er fundamentalt den samme ideen som nysing. Det er bare en annen ord på skjermen. Jeg kan abstrakt bort videre og implementere denne siste versjonen av en hoste, som ved første øyekast er langt mer kompleks ute. Men legg merke til hva jeg har gjort. Jeg har nå generalized-- genericized really-- dette puslespill brikke å bli kalt si ordet n ganger. 

Og nå har jeg to nye brikkene ned her definere hoste n ganger. Og hva gjør hoste funksjonen gjøre? Hva har min egendefinert puslespill brikke gjøre? Det kaller bare si blokken, passerer ordet jeg vil si, bestått i antall ganger jeg ønsker å si. Fordi nå kan jeg implementere nyse ved å si Achoo, i dette tilfellet, et antall ganger. 

Og så jeg lagdeling og lagdeling. Og igjen, er ikke nøkkelen her hvordan jeg implementert det, men faktum at hvis jeg bare bokstavelig flytte disse ut av skjermen, se hvor enkelt hvis ikke pen programmet mitt nå ser. Fordi det gjør hva det sier, jeg har abstrahert bort hva som er inni den svarte boksen. det skjer for å være en lilla boks her, men jeg har hindret en gang hva som er inni fordi jeg ikke bryr seg hvordan det fungerer. Jeg bryr nå at det fungerer. 

Og ja, i problemet satt null, dette er akkurat den type lagdeling av ideer du vil har mulighet til å utforske. Det er nøyaktig anledning til å gjelder problemløsning teknikker, til hva som er nok en ukjent miljø. Og om du ikke har programmert før eller programmert før, du vil finne at det er litt noe i dette miljøet for alle. Og med oppgavesettet en i en ukes tid, vi skal overført til fokus på et høyere nivå språk kalt C-- eller snarere en nedre nivå språk kalt C-- som er enda mer kraftig, selv om det er litt mer kryptisk ved første øyekast. 

Og vil du innse per dagens TL: DR, at dette problemet satt har en kortere vindu av tid enn fremtidige seg, rett og slett fordi du bør finne det ganske tilgjengelig. Og ikke å bekymre deg hvis du legger klassen sent. Vi vil ta for oss det før lenge. Og før vi utsette for kake, la oss avslutt med kun to minutters titt på hva som venter deg her i CS50. [MUSIKK] Greit. Det er det for CS50. Vi vil se deg snart. Cake serveres nå. [MUSIKK] SPEAKER 17: Har du hørt av et sabbatsår, Chief? SPEAKER 18: Kanskje det er mer under panseret. 