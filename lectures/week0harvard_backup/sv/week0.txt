[Musik spelar] 

Detta är CS50-- Harvard University introduktion till den intellektuella företag i datavetenskap och konsten att programmera. Och mitt namn är David Malan, och Jag tänkte bara i morse, det har varit otroligt 20 år idag sedan jag senast satt där ni gör nu. 

Det var 1996. Jag var en sophomore, och jag tog CS50 för allra första gången. Och jag hade inte ens fått upp nerven att ta det själv första år, delvis på grund av tiden. Datavetenskap till mig var typ av, meh. Jag var lite av en nörd växer upp, men jag visste inte riktigt har någon intellektuell intresse i vad som föreföll att bara vara en massa människor programmering hela tiden. 

Och jag var rädd för att vara ärlig. Kursen och datalogi mer i allmänhet haft och i viss mån, fortfarande har detta rykte av ett fält för att akta, om bara för att så många av oss är obekanta med det och osäker på det. Och det var verkligen inte förrän jag shoppade denna klass som sophomore fall-- och även då, jag bara inskrivna eftersom professor-- en av mina första mentorer, Brian Kernighan nu på Princeton-- tillät mig att ta klassen pass misslyckas. Och faktiskt, det är därför idag vi tillåter och uppmuntrar studenter att ta denna klass satt / omättad. 

Och först då, vid slutet av terminen jag inser som, wow, detta var inte en sådan obekant område. I själva verket var detta en mycket ge fält, och mer spännande, speciellt senare, som jag tog kurser i Dramatiska Arts 101 och Latin A och sedan så småningom magister arkeologi, började jag verkligen att se korsningar i detta fält, dator vetenskap, med humaniora, naturvetenskap, konst, medicin, och liknande. Och så det är vad är bara så snyggt om datavetenskap i slutändan, som vi hoppas att du see-- är dess tillämplighet dessa andra områden, och hur du kan ta del av dagens och terminens idéer och praktiska färdigheter tillbaka till din egen domän, och faktiskt utforska denna korsning av de fria konsterna och vetenskaperna. 

Så 73% av dig, om förra år är någon indikation, har aldrig tagit en CS kurs innan. Så om, liksom jag, du är känner mig lite rädd, eller ärligt talat du inte verkligen säker på varför du även här. Kanske du bara följde några vänner över till Sanders just nu. Det är helt bra. Målet här är att koppla du och för att försäkra dig att om man ser till vänster och till höger, du kommer att se klasskamrater med så lite eller så mycket erfarenhet att du själv kan ha. Och faktiskt, vi delar del statistik senare i dag När det gäller vad demografin i klassen ser normalt ut. 

Och som extra reassurance-- och detta har vi menar eftersom jag tog under loppet några år ago-- i kursens kursplan är this-- att det i slutändan frågor i den här kursen är inte så mycket när du avslutar upp i förhållande till dina klasskamrater, men där man i vecka 11, i slutet av den termin, hamnar i förhållande till sig själv i vecka 0, vilket är där vi är här i dag. Och detta är vad jag insåg alla dessa år sedan. Och jag vet en hel del klasser säga detta, men det är särskilt i datavetenskap. Vid slutet av dagen, detta fält är obekant som det var för mig och kan vara att du är verkligen bara om problemlösning. Och som sådan har den här tillämplighet att få andra områden. Och i själva verket, om vi försökte att destillera vad detta innebär, detta är problemlösning i sitt väsen, jag förmodar. Det finns input-- så vad det är att du försöker lösa. Det finns utgång, vilket är förhoppningsvis lösningen på detta problem. Och sedan, när vi skulle säga i datavetenskap, Det är det här svarta lådan i mitten som du inte nödvändigtvis måste bry sig om hur det fungerar. Du själv så småningom kanske genomföra vad som finns inuti den rutan. Men för dagens ändamål och fler i allmänhet i livet, allt du bryr dig om är att dessa problem lösas. 

Och vad denna kurs är i slutändan om undersöker skärningspunkten mellan dessa ingångar och utgångar, och dessa så kallade algoritmer, som vi snart kommer att se, att genomföra det är under det, huven. Men dessa ingångar och dessa outputs-- Vad innebär det egentligen? Ja, vid slutet av dagen, behöver vi något sätt att representera information. Detta gäller särskilt i en dator, som så snygga och komplicerat som det kan tyckas, är en ganska dum enhet. Det tar electricity-- om från en kabel eller ett batteri som input-- och sedan ger det några förprogrammerad svar på skärmen. 

Men hur får vi från början till slut där? Tja, vad ett problem som ska lösas? Tja, kanske vi kan, på I början av varje termin, Försök att ta närvaro i ett rum så här. Så jag kan göra som en, två, tre. Eller kanske, om jag gjorde det till slags hålla koll av myself-- att hålla reda på saker-- Jag kunde snabbt slut på fingrarna. Så jag kan bara göra hash marks-- en person, två, tre, fyra, fem, sex, sju, åtta. Och alla av oss har förmodligen gjort detta, vare sig på händerna eller på en bit papper. Och det är faktiskt bara något som kallas unära notation-- där om du bara har en bokstav i alfabetet, en eller hash märke i detta fall, för varje ingång du vill räkna, du måste lägga ner en av dessa letters-- ett av dessa märken. 

Okej. Det är allt bra och gott och inte så komplicerat. Men datorer är inte alla så mycket mer komplicerat. I själva verket de flesta av er förmodligen ens vet om du har inte riktigt funderat på vad det innebär att datorer bara förstår nollor och ones-- det så kallade binära systemet. Vi människor, däremot, är så mycket mer sofistikerad mån som vi förstår nollor genom nior. 

Men även om binär är, vid första blick, inte så bekant, Det visar sig att det är precis som de system och de idéer som vi redan vet. Så till exempel, överväga detta. Detta är bara en sekvens av symboler. Och alla ni, när blick på det, förmodligen tror 123-- ingenting verkligen intressant där. Men varför är det här numret, 123? Dessa är bara glyfer på den Screen-- bara mönster att någon skulle ha dragit eller skrivit. Men om du är som jag, du förmodligen minns från grundskolan att det är typ av kolumner eller platser här. Det är en plats och tio plats och hundra plats. Och anledningen till att detta är 123 och inte bara ett mönster av tre symboler är därför att, naturligtvis, om vi har en på hundra plats, du räknar 100 gånger en, och sedan två på tio plats. Så det är 10 gånger 2 och sedan tre den plats och det är 1 gånger 3. Och när du lägger alla dessa upp av Naturligtvis får du 100 plus 20 plus tre. 

Så vi började med bara ett mönster av symbols-- en alphabet-- men då vi kartlagt mening på det med hjälp av dessa kolumner. Tja, visar det sig att datorer är egentligen inte allt som skiljer sig från dig och mig. Men istället för att använda befogenheter 10, så att speak-- 1, 10, 100, 1000, 10.000 plats och så forth-- de faktiskt bara använda befogenheter 2-- så en, två, fyra, och sedan Om vi ​​sätter fler siffror, 8, 16, 32, 64, 128, och så vidare. Och så detta är hur en dator skulle representera siffran 0, precis som vi människor. 

0, 0, 0-- och du kan nog gissa vilket mönster av ettor och nollor, Om en dator kan bara tala 0 eller 1-- vad mönster kommer att representera siffer vi människor känner som en? Yeah-- 0, 0, 1. Okej. Så 0, 0, 1 är hur vi representerar 1, så att du kan vara benägna sedan att representera nummer två, om du har fyra plats och de två plats som en plats, skulle man kunna säga, ja, Om vi ​​hade en 1 i en plats, och nu vill vi räkna upp till två, kanske du göra detta och lämna detta för att vara en nolla. Men detta är naturligtvis inte hur decimalsystemet fungerar heller. Om du sätter en siffra i båda dessa kolumner, du har att göra det aritmetiska. Så hur många gjorde jag oavsiktligt bara representerar? 

Så det är tre, eftersom 2 gånger 1 plus 1 gånger 1, naturligtvis, ger oss tre. Så det skulle vara två. Biten slags flips, så att säga, som 0 blir en, ungefär som en 9 roller över och blir en 0 när du bär en. Detta skulle då vara tre naturligtvis. Four-- annan intressant sak händer, där de som rullar över och du bär en, så att säga. Så detta, naturligtvis, är fyra. 

Men om du snabbt framåt nu, Vad är det största antalet kommer vara att en dator kan representera? Så det är bara sju i det här fallet, eller hur? Eftersom du har en i fyra, en en i två, en en i en. Så det är fyra plus två plus ett. Så som ger dig sju. Och faktiskt, skulle det verkar vid första anblicken att datorer kan räkna inte högre än detta. 

Men detta är naturligtvis inte sant. Vad gör vi människor gör när vi vill att räkna högre än som 999? Bara bära en och bara lägga till en fjärde siffra till vänster. Och så verkligen vi kunde. Vi skulle kunna ha en åtta s plats och en 16: e plats, och en 32 plats, 64, 128-- och du kan bara fortsätta på upp till oändligheten. Så dessa nollor och ones-- den så kallade binära system-- är det en datorforskare skulle vanligen kallar en bit, eller binär siffra. 

Men nu, hur vi får från koncept eller grafiken i dessa saker till en faktisk dator? Vi verkar vara att hoppa över ett steg här. Tja, den enda ingången i slutet av dagen, till min laptop här är detta flöde av elektricitet. Även om det har varit en lång tid eftersom du tänkt på eller aldrig tänkt på hur el fungerar, Det finns elektroner flyter i eller ut, och det är min typ av ingång. 

Så om det är allt som vi är få som indata här, Vad kan vi göra med den informationen? Tja, kanske vi tänker på en nolla som bara en frånvaro av elektricitet. Ingenting är flowinw, är ingenting flytta, ingenting händer. Det är bara den förvalda state-- noll. Men om det finns elektricitet flyter, varför gör vi inte bara godtyckligt, men globalt konsekvent, kalla det en etta. 

Så helt enkelt genom att ha någon makt, vi har en nolla, ja makt, vi har en en-- ingen makt, ja makt. Och på det sättet, med hjälp av något mer fysisk eller elektronisk vi börjar genomföra detta begreppet något som antingen är en eller en nolla. I själva verket kunde vi bara göra det här. Så här har jag inte tre utan åtta glödlampor, vilka var och en har sin egen brytare. 

Och så om jag ville representera siffran sju här, Jag kan slå på dessa tre glödlampor. Och faktiskt, insida min dator är miljoner, miljarder saker som är bara mindre än den, som kallas transistorer, växlar, att du bara sätta på och stänga. Så dessa big-- relativt big-- omkopplare inuti min laptop-- är många, många, många, många fler växlar. Men allt de gör är exakt that-- aktivera något på, slå något utanför. Och som sådan, kan en dator representera med de miljoner eller miljarder transistorer, partier och massor av ettor och nollor. Och det finns andra hårdvara fortfarande att kan du lagra information på lång sikt, så att när du drar plugga, att du inte förlorar det. Men det är en historia för en annan dag. 

Så vad kan vi göra med dessa bitar? Kan vi bara ta avlasta av mig-- kanske någon vill komma upp här och erbjuder upp en demo? Jag såg denna hand först. Vad heter du? Maday: Maday. DAVID MALAN: Maday, kom upp. Trevligt att träffas. Maday: Trevligt att träffas. 

DAVID MALAN: Kom det här sättet. Jag kommer inte att behöva läpp dig. Okej. Så här har vi, notice-- en, two-- vi redigera den out-- en, två, fyra, åtta, 16, 32, 64, 128. Detta är avsiktligt. Det finns åtta bitar här-- binär digits-- nollor och ettor. Och en bit är en användbar enhet av measure-- inte lika användbar en måttenhet på sig själv. Vanligtvis vill åtminstone åtta av dessa saker, alias en byte. Så vi har en byte bitar här. 

Så om vi ville utmana dig med, till exempel stava ut, binärt, detta värde här-- 42. Vill du ta en stab på det? 

Maday: [OHÖRBART]. DAVID MALAN: Ja, bara trycka på små vita växlar fram. Och du vill stava ut 42, och hänger i luften Detta CS50 stressen boll om du får detta. Okej. Så du har 32. Vi kommer att behöva 42. Så det är en åtta, så det är 40. Och excellent-- mycket snyggt gjort. Tack. 

[APPLÅDER] Okej. Så vi har en mer stress boll. Låt oss göra detta en gång om vi kan. En annan volontär? Fri stress boll, fri stress boll. OK. Hit i mitten, vill du komma ner? Okej. Jag vet. Det går vi. 

Så nummer kommer här-- ner. Vad heter du? 

DAVEY: Davey. 

DAVID MALAN: Davey. OK. Kom upp, Davey. Trevligt att träffas. Och vad vi kommer att ha dig spell-- om du kunde dröja för bara ett moment-- är antalet 50. Men, men, men men, men dessa är grundskola magneter för en anledning. Bara fick lite hårdare, okej? Det finns fortfarande åtta. Okej. Så vad har vi på det? Vi har 32. Trevlig. 32 plus 16 ger oss 48-- så nära. Och underbart. Grattis till Davey liksom. 

[APPLÅDER] 

Okej. Så vi kan göra detta hela dagen lång, och det kan inte bli så mycket mer intressant och mer utmanande. Men det är verkligen point-- är hur relativt enkelt det är, i slutet av dagen, vad en dator gör att lagra information, att lagra ingångar och slutligen lagra eller representera dessa utgångar. Men enbart siffror är inte så intressant. 

Så människor, för några år sedan, bestämt, vet du vad? Det skulle vara trevligt om datorer var inte bara räknare för aritmetik verksamhet, men i själva verket kunde göra saker som ordbehandling, eller e-post, eller mer moderna inkarnationer av dessa typer av tekniker. Och så världen bestämde godtyckligt, men allmänt, att om du vill spara kapital bokstaven A i en dator, vet du vad? Låt oss bara alla överens om att lagra vissa mönster av nollor och ones-- bits-- som i slutändan representerar decimaltalet 65. Vi ska bara alla överens om. 

66 skulle representera B, 67 skulle representera C, och det finns knippen av andra mönster av nollor och ettor, eller bakomliggande siffror, som skulle representera andra bokstäver fortfarande. Så om du slags mentalt absorbera detta för ett ögonblick, Jag medvetet sätta upp A genom Jag, där H 72 och jag är 73. Om en dator då, i samband med ett program för ordbehandling eller en e-post, avslöjade under huven för att ha dessa mönster av bits-- mönster bitar som representerar 72, därefter 73, då 33-- vad kan detta innebära att programmet? 

Så hej, och sedan något. Vi behöver inte nödvändigtvis vet, men i själva verket 33-- inte i diagrammet earlier-- var helt enkelt ett utropstecken. Så 72 var H, 73 är I, 33 händer att vara ett utropstecken fortfarande. Men det är alla fina och bra, och i själva verket numera, snarare än bara använda sju eller åtta bitar, tack vare något kallas Unicode i motsats ASCII tillbaka i dag, vi faktiskt kan representera ännu mer intressanta karaktärer än bara dessa ursprungliga engelska partisk bokstäver. Men vi kan också representera även nättare saker som färger. 

Om du någonsin har hört förkortningen RGB, röd, grön, blå, som bara innebär att en dator typiskt använder tre uppsättningar bits-- vissa antal bitar som representerar ett nummer för hur mycket rött du vill, en annan uppsättning bitar för hur mycket grönt du vill, och en annan uppsättning nummer för hur mycket blå du vill. Så ett stort antal betyder massor av rött, litet antal innebär ingen röd. Och så dessa är typ av mellanvärden här. 

Så ge mig lite rött, ge mig lite grön, och ge mig lite blå. Och om du blandar dessa tre nyanser av färg tillsammans, i detta fall, du får denna skumma skugga av gult eller brunt. Men det mönstret av åtta plus åtta plus eight-- så 24 bits-- vänster till höger, är hur en dator skulle innebära att viss färg. Nu är detta bara en prick på en skärm. Om man tittar riktigt nära på din TV din dator, ser du punkter eller pixlar. Och om du har en hel rutnät av pixlar, horisontellt och vertikalt, du har bilder. Och sedan om du tar en bild och sedan tvätta visa dig en annan bild, en annan bild, en annan bild, en annan bild, riktigt snabbt, du naturligtvis har filmer. 

Och så märker där vi började. Vi började med dessa nollor och ettor. Vi arbetade därifrån till decimal siffror, hur vi representerar dem. Nu har vi bokstäverna i alfabetet. Men i andra sammanhang vänta, kan vi använda några fler bitar och representerar färger. Så snart du har förmåga att representera färger, du har förmågan att representera fotografier och animerad gif och andra sådana tecken på skärmen. Och när du har en massa bilder som flyger av människo på en gång, det ser ut som rörliga bilder, och så får du video också. 

Så använder dessa mycket enkla primitiver gör vi ha sätt att representera i slutändan alla dessa former av media. Och vi har sammandrag igen och om och om igen, tills vi får från den lägsta nivån till denna högsta nivå. Så det ger oss detta allmän uppfattning om abstraktion. Men vi började här. 

Här nu, vi kanske representera i en dator våra ingångar med nollor och ettor, våra resultat i nollor och ettor, men vad som händer inne i lådan? Det är där datorn vetenskap blir intressant. Det är där du faktiskt ta med egna sinnen att stå ut med att lösa problem. Vi kan nu fastställa för resten av terminen, ja. Jag vet hur binära fungerar. Jag minns hur Ascii eller Unicode-- mappningen till letters-- verk. Och det verkligen står självklart att vi kan representera rött och grönt och blått, och representerar multimedia också. Men detta är den intressanta saker. Detta är vad som gör någon kapabel att lösa problem. 

Och ett sådant problem vi vill göra, ja, tar närvaro, eller gör detta algoritm. Och återigen, kan jag göra det. Jag kan göra en, två, tre, fyra fem, sex, sju, åtta nio. Och jag skulle kunna skriva det ner för att hålla reda på det. Men det är bara hur jag skulle representerar informationen. Eller jag kunde göra detta faster-- två, fyra, sex, åtta, tio, tolv, 14, 16, 18, 20, 22-- det känns som två gånger så fort men det är fortfarande kommer att ta en hel del tid. 

Men det visar sig, om vi utnyttja ännu annan resource-- och faktiskt datorer dessa dagar har flera processorer eller hjärna. Det visar sig datorer kan göra massor av saker på en gång, och faktiskt vi i det här rummet, kan representera just detta. 

Så det är lite socialt obekväma, men om du skulle humor mig för bara en process i tre steg, låt jag be alla på plats där bara att stå upp för ett ögonblick. Stå upp. Så tänk dig själv, antal en-- så att alla i det här rummet, utom de som inte gjorde det oblige, funderar nummer ett. Så det är ditt nummer just nu. Som är det första steget, eller som en dator vetenskapsman eller en programmerare typiskt göra, kommer vi att börja räkna på noll. Om det minsta antalet som vi kan representera dessa glödlampor är noll, genom att bara lämna dem allt utanför, jag kan lika gärna börja räkna från noll är i stället för en. Och så det är vad datavetare göra. Så steg noll, stå upp och tänk på nummer ett. Nästa steg är this-- par off med någon stående och lägg till dina siffror tillsammans. Underbar. 

Så vid denna tidpunkt, bokstavligen alla som deltar tänker på siffran 2, med undantag för en udda person om vi har ett udda antal personer i rummet. Och nu det tredje steget här kommer att vara this-- en av er ska sitta ner. En av er ska sitta ner, och om du fortfarande står, gå tillbaka till steg ett. Okej. Okej. Så fler och fler människor bör sitta ned. Lägg märke till att detta har inducerat en loop-- någon form av cykel. Några av er skulle vara olyckligt fastnat, gå fram och tillbaka mellan steg ett och två, ett och två, ett och två. Det är ok. Vår första felet. Vi tar hand om det. Okej. Låt mig försöka sporra saker tillsammans. 

I teorin är endast en person som står som alla fortsätter att para ut. Men låt mig påskynda saker med människor kvar. Vilket nummer är du tänker på? 46. OK. Gå vidare och sitta ner. Ni är fortfarande kvar. Vem kvar? Vilket nummer är du tänker på? OK. 

Så vi kommer tillbaka till dig. Där bak? Vad är det? 22. OK någon annan upp top-- ja? 34. OK. Hit på min right-- upp här? 132, mycket trevligt. 22? 

OK. Och vem är kvar? Här borta? 46, mycket trevligt. 72. Jag kan inte stanna mycket längre. Ja? 30, trevlig. Här borta? 23? 23. 

Och jag tror att det är alla utom ni, ingen press. Oh vänta. 28? Bara åtta. OK. Bara åtta. Här nere? 30. 23. 24. 18. Detta är den värsta genomförandet av denna algoritm någonsin. OK. Så någon annan? Någon annan? OK. En till. 16? OK. 16. Okej. Så om jag inte har missat någon i skenet här, när jag trycker på Retur, vi kommer att få se, algoritm den Antalet personer i Sanders. Eftersom igen, det är som om alla som du satt ner, passerade ditt nummer av till någon annan, till någon annan, till någon annan, så att i teorin, i slutändan bara en besvärlig person bör lämnas stående. Men det är bra. Vi accelererade saker manuellt. Det är särskilt svårt att se i detta utrymme. 

Och det totala antalet personer vi tror att det är här är 546. Det totala antalet jag överlämnades av undervisnings medmänniskor, som gjorde det gamla skola långsamt sätt, var 820. 

[SKRATTANDE] 

[APPLÅDER] 

Det är ok. Så säkert då, finns dessa buggar. Och det är bra. Och så tänker tillbaka på detta första gången något du skriver inte nödvändigtvis fungerar. Detta har hänt mig här. Men låt oss nu överväga hur vi kan tillämpa samma idé till något du kanske har sett tidigare, vilket Detta är old school teknik här-- en riktigt stor telefonbok. Och antar att denna telefonbok har 1000 sidor och 1000 namn och siffror i bokstavsordning inne i den. 

Jo, vi kunde slags tillämpa en liknande Tanken med detta mycket fysiska problem, bara använda mig. Jag bara typ av lurad genom att utnyttja alla er med massor av olika processorer eller hjärna utför någon algoritm. Men om det är bara lite gamla mig, kan jag fortfarande utnyttja samma väsen av en idé att dela upp och erövra det problemet om och om igen, där hälften av er, hälften av er, hälften av er, hälften av er, teoretiskt hålls sitta ned, tills vi kvar, teoretiskt, med bara en person. 

Så i denna gamla skola technology-- vi inte behöver detta map-- detta old school-teknik, vi kan börja leta efter någon gillar Mike Smith, en sida i taget. Och jag ser att ingen, inte Mike här. Jag är fortfarande i A-sektionen. Slutligen finner jag själv i B sektionen. Och detta är en algorithm-- steg-för-steg instruktioner. Börja från början och en sida vid en tidpunkt, leta efter Mike Smith. Är detta correct-- detta algoritm eller strategi? 

Ja, det är korrekt. Om Mike är här, så småningom Jag kommer till honom. Men det är inte effektiv. Det är naturligtvis mycket långsam. Så jag kan utnyttja Samma twosies närma. Jag kan göra slags två, fyra, sex, åtta, tio, tolv. Det är dubbelt så snabbt. Jag kommer att få Mike snabbare om han är där. Är det korrekt? Ja, men jag hörde en little-- nej. Nu hörde jag ett nej. Ja. Det finns en bugg potentiellt. Kanske Mike bara misstag blir inklämt mellan två sidor, eftersom jag flyger genom detta två åt gången. Så åtminstone vi behöver typ av villkorad fix. Jag måste säga, hej, om jag slog någon vars namn börjar med en T istället för en S, Jag bättre dubbelt tillbaka åtminstone en sida. Så buggy i början, men repareras. Men ingen av oss kommer att leta efter Mike Smith genom en 1000 sida telefon boka en sida i taget. Vad är en normal person ska göra? Du kommer att gå till S, om du visste var S. Du kan gå ungefär till mitten eller något skev mot slutet. Och jag ser här nere och Jag är i M avsnittet. Men vad vet du om detta problem nu, att vi inte nödvändigtvis visste innan med alla av oss bara räkna oss ekvivalent? Tja, Mike tydligt går att vara i denna halv av boken om han är här alls eftersom det är sortering. 

Och så kan du mycket dramatically-- 

[Kippar] 

Jag vet. 

[APPLÅDER] 

Det är faktiskt väldigt enkelt om du gör det ner ryggraden där. Men du kan kasta halv av problemet bort. Nu, jag är kvar med samma problem-- hitta Mike Smith i en telefon book-- men nu telefonboken börjar på M och går till Z, men det är hälften så stor. 

Men detta är vad som är imponerande. Precis som i teorin, ni, när ni alla satt bara hälften åt gången, problemet fick hälften så stor, hälften så stor, om och om igen. Så har detta problem blivit samma problem men hälften så stor. Nu är det en 250 sida problem. Så fort jag inser, åh, jag är i T avsnitt av misstag. Jag har gått för långt. Jag kan kasta att hälften av telefonboken bort. Nu är jag ner till en fjärdedel av problemet. 

Och du kan upprepa, upprepa, upprepa tills i teorin, är du vänster med bara en sida. Och om Mike är på den sidan, Jag kan nu lösa detta problem. Men hur snabbt jag lösa det? I det första fallet, det tog mig som kanske 1000 steg för att hitta Mike Smith. Det kan ha tagit mig-- Jag plockade upp telefonboken och jag började leta en sida i taget, och Mike kanske 1.000 sidor senare. 

Andra tillvägagångssätt kanske tar mig 500 steg, eftersom jag flyger genom två åt gången. Och det tredje tillvägagångssättet dock, det är särskilt kraftfull. Men låt oss fundera över vad vi faktiskt gjorde med denna tredje tillvägagångssätt. Jag har vad jag ska kalla just dessa uttalanden här, en i taget. Plocka upp en telefonbok. Öppna till mitten av telefonboken. Titta på namn. Och då det blir lite mer intellektuellt intressant, om det fortfarande enkelt. Om Smith är bland de namn på den aktuella sidan, sedan göra något villkorligt. Det är som en gaffel i vägen. Ringa Mike. Om Mike är bland namnen på den sidan, som kallas Mike. Men bara göra linje fyra om linjen träd, om man så vill, är sant. Svaret på den frågan är ja. 

Else om Smith är tidigare i book-- Med andra ord, om jag är i M avsnittet och jag letar efter någon att vänster, vad jag ska göra är något liknande. Då ska jag öppna till mitten av den vänstra halvan av boken. Så gå till vänster, och sedan gå tillbaka till steg två. Titta på namnen där. 

Så med andra ord, gör samma sak, men på ett problem som har halverats. Vet du vad? Om Smith är senare i boken baserad på sidan jag tittar på, öppen mot mitten av högra halvan av boken och sedan gå tillbaka igen till steg två, else-- det finns en fjärde möjlighet här. Mike är antingen här eller till vänster eller till höger eller inte där. Och här har vi bättre överväga detta. Och i själva verket, om du någonsin har haft datorn bara kraschar på dig, det är ibland, men inte alltid, resultat av bara en mänsklig programmerare inte inse, oh shoot, det finns faktiskt denna fjärde scenario. Och om du inte skriva kod att hantera detta scenario, ibland inte vet vad datorn kan göra. Och faktiskt ett program kan krascha. 

Men i detta fall, tänkte jag om det, och jag sa, annars sluta, eftersom det är den fjärde logiskt tänkbart scenario. Nu ska vi bara lägga några ordförråd så vi kan börja kasta runt termer som i övrigt är ganska intuitivt. Alla de saker som jag har bara gulmarkerad här, Jag bara gå till funktioner eller tillvägagångssätt. De är bara typ av åtgärder. Så plocka upp, öppen för, titta på, ring, öppna, öppna, quit-- dessa är bara åtgärder, eller vi ska kalla dem mer formellt, funktioner. 

Samtidigt nu i gult, Jag har markerat saker that-- låt oss bara börja ringa dem villkor eller grenar. Dessa är beslutspunkter där du kan gå på detta sätt, på detta sätt, eller någon annan riktning alltjämt. Så de kommer att vara villkor. Och nu detta är lite snyggare. Låt oss kalla dessa frågor Booleska uttryck, efter någon med ett efternamn Bool. 

Och ett booleskt uttryck är bara något det är antingen sant eller falskt, ja eller nej. Så det är frågan vars svar du bryr sig om, så att i ett tillstånd göra en decision-- få tillbaka ett svar, och sedan gå till vänster eller höger, eller något annars helt och hållet. 

Och sedan slutligen, dessa linjer här-- gå tillbaka till steg två, gå tillbaka till steg two-- vi kunde genomföra denna idé på olika sätt. Och då de av er med programmeringserfarenhet kan ha gjort eller kan tänka sig att göra detta på olika sätt. Men för dagens ändamål, är det bara tanken som räknas. Detta framkalla vad vi i allmänhet kallar en loop-- någon form av cykel, eftersom det gör mig att göra något nytt. 

Så nu, låt oss bara betrakta hur bra denna algoritm är. Det är rätt. Om Mike i boken, det är en av de fyra scenarios-- igen och igen och igen, ska vi hitta honom. Men hur bra är det? Tja, vi har inte att vara alltför formell här. Men låt oss bara rita något, x och y, för att få en känsla av formen på detta problem. 

På x-axeln här är storleken på mitt problem. Och de en y-axel här kommer att vara tid att lösa. Så kanske det finns flera sidor. Kanske är detta sekunder sida turns-- vad som helst. Men du vill räkna är vad den här bilden kommer att representera. Och det första algoritm, jag kommer att beskriva som bara en rak linje. Om det finns n sidor telefonboken, då det kan ta mig så många som n steg för att hitta Mike. Om Verizon eller telefonbolaget adderar ytterligare en sida nästa år, det kan ta mig en step-- en enhet av tid att hitta Mike. Så det finns bara denna 12:59 förhållande. Det är en rak linje lutning. 

Under tiden, för det andra att algorithm-- om jag kommer två vid en time-- två, fyra, sex, åtta eller double-- gå igenom sidorna två gånger åt gången, två åt gången, det är fortfarande rak linje. Det finns nu 01:59 förhållande, men bara en liten aning lägre. Så om det finns så många sidor i diagrammet här i gult, som kan ta mig här många steg eller sekunder, annars det kommer att ta mig dubbelt så många på den röda linjen. 

Men den gröna linjen är den verkliga takeaway. Detta är vad vi i allmänhet kallar en logorithm-- logg av n, där n är antalet sidor. Men det är formen som räknas i dag, eftersom vi inte har att ens tänka på att rita punkter. 

Tänk på en extrem situation. Antag Verizon morgon fördubblar antalet sidor i det telefonboken från 1000 till 2000. I den första algoritmen, I kan slösa bort en extra 1000 steg efter Mike, bara för att Verizon fördubblade boken. Den andra algorithm-- det kanske ta mig en extra 500 steg. 1000 fler sidor, jag gå två på en time-- 500 fler steg för att hitta Mike. 

Men det tredje algoritm är slags magisk. Verizon fördubblar antalet sidor från 1000 till 2000, men hur många fler steg gör det tar mig att leta efter Mike? Det är bara en, eftersom jag kan bara riva telefonboken en gång från en 2000 sida problem att en 1000 sida problem, och voila. Jag har tagit en massiv bit av det. 

Och om du går verkligen extrem, Anta att telefonboken Företaget hade något galet som en 4 miljarder sida telefonboken. Nå hur många steg kan det ta att hitta Mike Smith i en 4 miljarder sida telefonbok? Det är ett stort antal, men bara 4 miljarder 2000000000-1000000000 till 500 miljoner som 250 million-- fortfarande låter som stora siffror, men jag är mycket snabbt komma till mindre värden. 

Och faktiskt, om jag gör matten rätt, jag kan bara dela 4 miljarder med cirka 32 gånger innan Jag komma ner till bara en. Så om det telefonboken var 4 miljarder sidor lång, no big deal. Inom några sekunder, kanske 32 sekunder, jag kunde dela den i två halvor och så småningom hitta Mike eller dra slutsatsen att han inte är där. Och det är kärnan i en algorithm-- en bra algoritm. Och det är en av de målen för en klass som denna, försöker räkna ut hur gör jag lösa problemet inte bara på rätt sätt, som jag alltid visste hur man gör det en sida vid en time-- men korrekt och väl. Hur gör jag designar bra lösningar på problem? Så låt oss ta en stund här och ge dig en känsla nu av CS50 kursen itself-- introducerar några kursens anställda. Strax före 02:00, vi ska ta en kort paus så att de av er som handlar kan anka ut och ta en titta på några andra klass och se resten av detta online. Men nu, låt mig presentera CS50, klassen själv, och i synnerhet det som är nytt. 

Så våras vi tillbringade en hel del time-- kursens personal och Jag-- tänkande om vad det är vi vill CS50 att vara, och gå tillbaka till första principer, så att säga, att fundera över vad det är vi vill denna kurs för att se ut och vara som för sina studenter. Och så du ser i problem ange noll samt en inbjudan att ta en titt på det URL som sammanfattar några av motiven bakom följande egenskaper hösten 2016. 

Som du kanske har samlat från TL: DR allmosor, kursplanen i dag samt från kurskatalogen, i år i CS50, du bara förväntas delta today-- så bra jobb done-- och den sista föreläsning den 21 november. Och du är välkommen, men inte förväntas närvara vid dessa föreläsningar i mitten, eftersom det vi gör i år, skytte i realtid banans material. Så allt kommer att stanna ström och införlivas så gott vi can-- aktuella och samtal som folk kanske att ha inom industrin i värld, men att göra detta material tillgängliga, som ett resultat, även earlier-- komplett med fulltext transkriptioner och sökbarhet och länkar till andra källor. 

Och faktiskt, har vi varit anspråk på en viss tid och vi tror nu detta, att vi kan skapa, digitalt, en mer engagerande, en mer övertygande pedagogisk erfarenhet, i motsats att samla här cirka 23 gånger personligen, höra någon som mig helt enkelt tala om datavetenskap, i motsats till att engagera mer aktivt. Så du ser i kursens kursplan en skiss av terminen här, tillsammans med när Föreläsningarna filmas, som du är Välkommen men förväntas inte, och när de kommer släppas på kursens hemsida. 

Och vad vi ska göra här på Onsdagar som börjar nästa vecka, är mycket mer intimt, med endast de folk som vill delta, är ett så kallat promenad genom, där jag och kursens huvuden kommer faktiskt att göra det lite mer intim här nere i orkestern avsnitt, fortfarande har en del teknik och gå igenom aktuella veckan problem set, och erbjuder dig particularly-- om bland de mindre comfortable-- desto mer vägledning som du kanske vill eller behovet av veckans utmaning. Och på samma sätt, för dem som inte kan åtföljer dem personligen, no big deal. Det kommer att finnas på samma sätt leds av en av kursens högre tjänstemän, Zamalya, samma möjlighet inbäddade i problemet sätter sig. 

Problem skiljer detta år kommer att släppas på fredagar och inte längre göra sju dagar senare, men 10 dagar later-- medvetet överlappning med varje problem set, för att bättre kunna tillgodose, Vi hoppas, ebb och flod i student scheman, speciellt när midterms eller idrott eller akademiker eller extracurriculars tenderar att komma och gå särskilt i mitten av terminen. Det borde ge dig lite mer diskretion på om du front ladda din vecka med CS50 eller tillbaka last det på följande helgen i stället. Så se till kursens kursplan här för schemat därav. Och du kommer att märka också bland de förändringar i år, för de mer bekanta med programmering i det förflutna, vi börjar terminen som Vi kommer i dag i Scratch, fokusera särskilt på språket kallas C, och sedan övergången inte till PHP, men till ett språk som kallas Python mot slutet av terminen i samband med webbprogrammering, tillsammans med SQL och JavaScript HTML, CSS, och ännu mer. 

Och som svar på en FAQ, det är verkligen är fallet att CS är inte lika skrämmande som jag en gång trodde att det var, men det är så mycket arbete som jag hade hört att det kan vara. Men detta är att säga att här är några statistik från hösten 2015 studentkåren, varvid de horisontella blå linjerna representerar det genomsnittliga antalet timmar rapporterad. Och du ser ett genomsnitt av sex till tio till 12-- kanske 16 eller så och så vidare, men med hög varians att vara tydlig. Och så inse att det inte bara är studenter mer bekväm och mindre bekväm i kursen men en motsvarande stöd struktur för att få dessa studenter genom terminen framgångsrikt. 

I själva verket, som svar på en FAQ, bör du tar CS50 som ett första år? Absolut. Och faktiskt, jag ångrar inte har hittat min väg eller hittat ett nytt fält det första året också. Och skulle du ta CS50 med andra kurser, förvisso som well-- och allmänna råd vi kanske ge eleverna, det är CS50 förmodligen inte den typ av klass eller intro klass att du bör ta med tre andra eller fyra andra p-set klasser. Men om du tar två andra p-set klasser, något annat, och CS50, helt hanterbar. Jag har haft många elever i tidigare gjort det ganska framgångsrikt. 

Och för att få dig mot det mållinjen framgångsrikt, inte kursen har sections-- olika spår för studenter mindre bekväm, bekvämare, och någonstans däremellan, varvid i banans första problemet set, du kommer att bli ombedd att beskriva dig själv. Och om du är bland de mindre bekväm, det är sånt att du bara ganska vet. Och faktiskt, det har varit den växande demografiska i CS50 för ett par år. 

Från och med i höstas för Exempelvis 58% av klassen beskrev sig själva som bland de mindre bekväm, med 9% bland dem mer bekväm, och sedan de andra eleverna där i röd beskriver sig själva som någonstans däremellan. Och du ser här ämnena övergripande och schema av sektioner, som alla erbjuds personligen, i realtid, med banans fantastiska personal undervisningsassistenter och kursassistenter, vissa av dem möter du i ett ögonblick. 

Sektioner själva, som du ser, kommer vara måndagar och tisdagar och onsdagar, så att du kan dyka in efter engagerande, om du så välja, i banans föreläsa tidigare denna vecka. Och sedan kontorstid, som säkert, med varje år som går, har varit mindre av en utmana om kursen. Och i år, planerar vi inte bara för att hålla kontor hours-- en vid ett möjligheter till hjälp för studenter på onsdagar torsdagar och söndagar, den sista av de vara i eftermiddag vid utformningen att minska en del av den stress som alltid uppstår med sena p-settting med en tidsfrist looming-- men kontorstid kommer också att erbjudas på måndagar och tisdagar och Onsdagar och fredagar och lördagar, tack vare våra vänner på HSA. 

CS50 har nu sitt eget utrymme för studenter och CS50 personal, ovanpå 67 Mount Auburn Street, direkt i Harvard Square. Visionen som är att CS50: s TF och CA hela veckan, ganska mycket under större delen dagar, kommer att vara där för stöd. Så om du har några fråga om en p-set eller om du känner dig lite blockerade eller lite förvirrad, och fan, du har en timme eller en halvtimme mellan klasser, speciellt i square-- kan man pop i och har den frågan besvaras av har denna förvirring clarified-- mycket i anden, du är bekant, av matte avdelningens egna matematiska frågor centrum men ganska mycket dygnet per runt [? Gcal?] Som vi kommer att lägga upp på nätet. 

Handledning är också tillgängliga för dem studenter, fritt från banans egen personal om du vill mer intim en på en, eller bara två eller tre klasskamrater, som arbetar med en av kursens personal. Och faktiskt, dessa här är bara några av kursens personal, några av dem du kommer träffas på bara ett ögonblick. I själva verket, CS50: s egen huvud undervisning karl, och huvudet kurs assistent, och preceptor, kunde komma på upp, tillåta dem att säga hej. 

[APPLÅDER] TALARE 1: [OHÖRBART]. 

[APPLÅDER] TALARE 2: [OHÖRBART]. 

[APPLÅDER] TALARE 3: [OHÖRBART]. 

[APPLÅDER] 

DAVID MALAN: Och ge oss möjlighet att ta ombord två av CS50 mest högre tjänstemän, Rob och Zamayla också. 

[APPLÅDER] 

Faktum är att både Rob och Zamayla har varit med oss så länge, att jag kunde att gå in CS50: s arkiv och hitta denna mycket SD tagningar av dem deltar på scenen själva för några år sedan. ROB: [OHÖRBART]. 

[APPLÅDER] ZAMAYLA: [OHÖRBART] 

[APPLÅDER] DAVID MALAN: Tack. Så utöver dessa lagmedlemmar här, CS50 har ett team på nästan 100 anställda, som alla kommer att finnas tillgänglig för sektioner och kontorstid och så mycket mer. Och som Rob säger också, är detta den mest signifikanta översyn av CS50 i de 10 år som Jag har varit i [OHÖRBART]. [OHÖRBART] fokuserat speciellt i att tillhandahålla en stödstruktur, putsning bort en hel del huvuddelen som har varit ackumuleras i 10 år av iterativa utvecklingen på kursens problemsamlingar. 

Så detta år, inte bara i klassen men även i form av kursen s problem set, bör du hitta saker till vara mer strömlinjeformad, trimmer, mycket mer hanterbar än i år tidigare, som vi sprida lite av bagaget som är utvecklad av natur utvecklas år efter år och iteration. Så det nya och förbättrade börjar idag. 

Du kommer att träffa lite mer av den Naturligtvis personal i [OHÖRBART] vid 02:30, där vi tjänar, som en tradition, tårta. Det finns lite mer tårta än så, men du kommer Möt Erin och Tobias och andra fortfarande. Och låt mig ge dig en turné innan vi hör från några av de andra anställda i klassen, av vad som väntar också. Faktum är att vi alltid börjar CS50: s termin denna kommande lördag, med vad som kallas CS50 Puzzle dag. 

Det har ingenting att göra med datateknik per se, men med ca problem lösa mer generellt. Och om du så önskar att delta, per några av inbjudningarna, du kanske har sett dörr tappas eller på scenen här, Det är en möjlighet i team av två eller tre eller fyra, att delta för pussel och pizza och priser och more-- denna lördag, håll ögonen öppna för mer. 

Du hittar också att varje Fredag, på Fire and Ice, inte CS50 föra en massa studenter till lunch, för att göra en stor klass känner sig mer intim, och i allmänhet föra samman alumner och vänner från industrin att tala om vad de har varit upp till sedan examen. På samma sätt, i år kommer vi inviga den första någonsin CS50 50 kodning contest-- en mid-termin möjlighet att låta alla på en opt i grunden, att ha en utmaning av intelligens mot klasskamrater, igen i grupper om två eller tre eller fyra, med angivande av enbart programmering kunniga som du sedan har enligt bältet efter bara sex eller sju veckor för klassen och deltagande i denna typ av konkurrens online-- om du vill finslipa din egen färdigheter allt mer i denna utmaning. I slutet av terminen är den så kallade CS50 Hackathon-- en möjlighet som börjar vid 07:00 PM slutar vid 07:00, och längs vägen är 12 kväll timmar på sig att dyka i kursens sista project-- en möjlighet att utforma och genomföra de flesta något av intresse till dig med din undervisning karl vägledning. Omkring 09:00 gör vi vanligtvis servera pizza, 01:00, Philippes och några av oss som fortfarande är vaken på 5:00, är shuttle bussed ner vägen till IHOP för frukost. 

Och sedan ett par dagar senare är den så kallade CS50 fare-- ett slut på termin utställning i firandet av hur långt så många av CS50 studenter har kommit från vecka noll ända till vecka, och med tanke på att 73% av de klasskamrater och din i år har aldrig tagit en CS klass innan. I själva verket, att reemphasize så mycket, här är några fler ansikten från CS50 personal. SPEAKER 4: [OHÖRBART]. SPEAKER 5: [OHÖRBART]. SPEAKER 6: [OHÖRBART]. SPEAKER 7: [OHÖRBART]. SPEAKER 8: [OHÖRBART] SPEAKER 9: [OHÖRBART]. 

SPEAKER 4: [OHÖRBART]. 

SPEAKER 10: [OHÖRBART]. SPEAKER 11: [OHÖRBART]. SPEAKER 12: [OHÖRBART]. SPEAKER 13: [OHÖRBART] 

Högtalaren 14: [OHÖRBART]. 

SPEAKER 13: [OHÖRBART]. SPEAKER 15: [OHÖRBART] SPEAKER 16: [OHÖRBART]. 

SPEAKER 11: [OHÖRBART] SPEAKER 5: [OHÖRBART]. DAVID MALAN: En del av laget själva handlar klasser. Men om dessa medlemmar av CS50 personal är här, kunde komma på för bara ett ögonblick. CS50: s TF och CA och [? personal?] medlemmar här-- dessa är bara några av faces-- varav du bara såg, och några other-- och några andra fortfarande. Varför vi inte gå vidare och tillåta ni en fem minuters paus. Om du behöver ducka ut till butiks klasser, det är bra. Och i fem minuter, kommer vi att återuppta, ta en titt på Scratch-- den första av vår programmeringsspråk, träffa kursens personalen här lite mer, och fokusera ultimately på problem set noll. Så vi ska vara tillbaka i fem minuter. 

[APPLÅDER] 

Okej. Så vi är tillbaka. Och i våra återstående tid idag, målet är att jämna ut spelplanen i termer av vissa terminologi, i termer av några idéer. Eftersom faktiskt, enligt några av listorna tidigare, Det kommer att bli en rad erfarenhetsnivåer i klassen, några av vars elever har tagit del programmering innan, några av dem har inte. Och så med detta första problem set och med denna första språk har vi en möjlighet att starta att ta för givet efter idag några vanliga ordförråd och idé. 

Och vi kommer att göra detta med hjälp av kursens första languages-- Förutom C och Python och JavaScript och SQL och HTML och CSS, Vi kommer att fokusera initialt och bara för problem in noll på denna grafiska språket, kallas Scratch, utvecklad av MIT Media Lab väg, för att hjälpa studenter och barn i synnerhet uttrycka sig algorithmically-- på ett sätt mer i linje med vad vi kan kalla beräknings tänkande. 

Och det är ett användbart språk eftersom mycket snabbt nästa vecka i vecka ett, vi övergå till ett mer traditionell och svårbegripliga språk som kallas C, vilket är rent text. Du använder bara tangentbordet i För att skriva instruktioner som dessa på skärmen. Men även om du har aldrig sett ett programmeringsspråk före, på bara kasta en blick på detta, alla vara det kryptiskt, du kan nog gissa att förmodligen skriver Hello World. Men det finns en hel del syntaktisk overhead där. Det är konstigt hash symbol eller hash-taggen där uppe. Det finns vinkeljärnen, några parenteser, klamrar, halv colon-- det är bara så mycket visuell syntax som kommer i vägen. Vi börjar kursen med Skrapa för att få förbi alla dem intellektuellt ointressanta distraktioner, och i stället fokusera på idéer. 

I själva verket kan detta vara innan. Detta för detta, skall vecka vara efter. Detta i denna grafiska språk Scratch, är hur du skulle genomföra samma program-- ett program som när det körs, helt enkelt säger Hej världen. Och vad är trevligt om Scratch är att det är det här grafisk programmering miljö som använder pusselbitar eller block, som bara låsa ihop om det gör logisk mening att göra det. Och med Scratch kan du utveckla animeringar och interaktiva spel och konst, och ett antal saker som ni kan föreställa i ditt eget sinne, och genomföra dem genom att helt enkelt att dra och släppa pusselbitar. 

Och faktiskt, vi har förmågan att uttrycka några av samma idéer som jag nämnde bara ett ögonblick sedan inom ramen för Mike Smith och söka en telefon book-- saker liknande funktioner, bara åtgärder, saker som loopar som kan göra saker om och om igen, variabler, vilket är något som vi ska presentera, men det är bekant kanske från algebra-- bara någon form av platshållare att lagra ett visst värde som du kanske behöver later-- booleska uttryck, där de ja nej eller sant falska frågor från tidigare. Förutsättningarna är de gafflar i road-- dessa grenar så att säga. Och sedan finns det några finare funktioner som vi kommer att se även idag, kallade matriser och trådar och händelser, som vi sedan återkomma över tid på olika språk. Men Scratch tillåter oss att utforska alla dessa. Så här i Scratch, lila blocket är vad en funktion är typiskt kommer att se ut. Denna purpurfärgade pusselbit som har några ord som säg, som är den handling, och då kan det ha en argument eller ett parameter-- något sätt av typ av skräddarsy vad som blockerar gör så att det inte i förväg har fastställt MIT vad denna lila blocket säger. I själva verket kommer du se i en ögonblick som jag kan skriva ord som Hej världen, eller Hej David, eller hej Zamayla, eller vad jag vill, i argumentet till det pusslet piece-- den vita rutan det. Under tiden, om jag vill ha en slinga, vi ska se att det finns pusselbitar som ser en liten orange som denna. Och deras form slags antyder att något händer igen och igen i en cykel. 

Så om jag svepa en säga hej världen blocket med en evigt blockera i Scratch, det är bara kommer att fortsätta att säga hej världen för alltid, bokstavligt talat. Samtidigt finns det en annan typ av slinga i Scratch att vi kommer att see-- en upprepning block-- där, om du i förväg veta hur många gånger du vill att slingan för att verkställa ett begränsat antal gånger i fact-- dig kan ange att genom att skriva i ett antal eller ens koppla in en variabel, som x eller y som vi får se. 

I själva verket, variabler som Jag i detta fall, som är ett gemensamt namn för en heltalsvariabel som bara lagrar en number-- ett heltal kan vara, att använda denna orange blocket här ställa in en variabel som jag till noll. Här är ett exempel på gröna en Boolean uttryck i Scratch. Även om det ser ut som en matte formel, matematik ojämlikhet som detta verkligen är booleska uttryck. Detta är antingen sant eller falskt. I är mindre än 50. Det är antingen ett ja eller nej svar eller sant eller falskt svar. Och vi i allmänhet kallar de booleska uttryck. Och det behöver inte vara 50. Det kan vara x mindre än y, större än y, lika med y-- vilket som helst antal andra frågor kan ställas. 

Nu, vid en första anblick kan det se plötsligt ganska fet här, och det är. Men koncept klokt, det ganska bekant från förut. Om x är mindre än y, än att säga lika mycket. Annars om x är större än y, sedan säga så mycket. Else säga x är lika med y. Så vi har ett exempel det av en tredje scenario-- den enda tredje possibility-- x är antingen större än, mindre än, eller lika med. Så vi har en trevägs vägskäl. 

Och lägg märke till vad är hett här-- Scratch, det verkar, har bara ett pussel stycke, i det här fallet, i om annat block. Och ändå verkar innebära att du kan bara har en tvåvägs vägskäl. Du kan gå till vänster eller höger, men hur är det tredje scenariot? Vad händer om x är lika y? Ingen stor grej. Ta en pusselbit, sätta ytterligare en insida av det att skapa den semantiska motsvarande av om, annars om else-- och nu har dina tre sätt vägskäl. Och som vi ser, den Scratch pusselbitar kan sträckas och växa, så att klämma mer saker i dem. Du behöver inte passa allt i standardstorlek. 

Detta är något vi kommer Snart ser kallas en matris. Det är som en list-- något sätt av lagra flera bitar av information i en variabel, inte bara en siffra. Dessa kommer vi att se en representant för något som kallas multi-threading. I själva verket, alla dina Mac och PC i dessa dagar stödja multi-threading, vilket innebär att du kan bokstavligen göra flera saker samtidigt. Du kan ha Microsoft Word upp i förgrund, som arbetar på någon uppsats. Du kanske har en webbläsare i bakgrunden öppningen G-post eller Facebook eller liknande. Datorn kan göra flera saker idag eftersom det är flertrådade, och program som de är ii synnerhet är också multi-gängade. 

Det finns saker som kallas händelser som väl i en värld av Scratch, och sedan finns det en alldeles, att göra våra egna anpassade pusselbitar om saker och ting faktiskt inte existerar i förväg. Så låt oss motivera detta på följande sätt. För några år sedan, när jag först upptäckte Scratch, när jag var faktiskt en grad student vid MIT, vi oss fick i uppdrag att göra läxor. Och jag implemented-- som i efterhand, var ett mycket dåligt beslut eftersom det är den mest upprörande låt i världen att lyssna på under åtta timmar medan du arbetar med homework-- men något jag hade kallat Oscar tid, vilket kanske är en bekant sång. 

CS50s äger Jordan Hayashi, en av våra mer seniora medarbetare, har uppgraderat det för 2015 och nu 2016, sedan tillbaka i dag, Jag hade allt bara gå i Oscars papperskorgen. Nu stöder vi återvinning och kompostering. 

Men att måla bilden av vad vi kan göra här och för att motivera några av exemplen på lägre nivå, skulle vi kunna få en annan volontär att bara komma på upp och spela min första hemuppgift någonsin? Kom upp. Vad heter du? 

HENRY: Henry. 

DAVID MALAN: Henry, kom upp. Kom upp. Huvudet åt båda hållen, och du ser i ett ögonblick, Jag kommer att gå vidare och träffa gröna flaggan i övre högra hörn, vilket innebär att gå. Den lilla stoppskylt ikon kommer att säga stopp, och det är när du startar och stoppa programmet. Trevligt att träffas. Okej. Så vi kommer att se instruktionerna på skärmen i ett ögonblick. Och bara genom att spela detta spel för några seconds-- lita på mig, Vi kommer inte att vilja spela hela vägen till end-- du kommer få en känsla för vad programmet gör. Och mer än bara fokusera på Henry är bra eller dåligt på detta spel, fokus och hur var det genomförs av mig ursprungligen och sedan av Jordan. Med andra ord, där är de variabler? Var är slingorna? Var är funktionerna? Och vi får se om vi inte ser de under huven. 

Bara klicka och dra papperskorgen till lämpligt fack. 

[Musik spelar] Okej. Det är väldigt bra. Varför vi inte stoppa det där. Tack. Grattis till Henry. Tack. 

[APPLÅDER] 

Tänk felsökning programmet. Om det finns ett problem två minuter song-- men så vad som händer här egentligen? Så komplicerat som det kanske börja verkar komma över tiden, faktiskt mer och mer saker började falla, Vad som är intressant denna typ av example-- och vi kommer att se ett fåtal others-- är att om du titta förbi komplexitet eller förfining av spelet, Det finns en mycket enkel byggnad block som play-- som alla, Om du destillera dem till de byggstenar, är mycket lättillgängligt och genomförbara sig själva. Till exempel är det varit en tid, men jag är ganska säker på vad jag gjorde först när gör det här spelet för första gången var jag helt som procrastinated. Jag ville inte fokusera alls på logik eller pusselbitarna, Jag fokuserade på grafiken och fynd gatan post och papperskorgen och allt detta. Men de var nödvändiga ingredienser i början. Och när jag slutade förhala och om en ram övergripande, Jag bestämde Låt mig bara göra en bit skräp faller från himlen. Och vi får se Scratch stöder saker som kallas sprites-- tecken som kan har olika dräkter på så att de se annorlunda ut. 

Och så jag satte en papperskorg dräkt en sådan sprite. Och jag bara behövde det falla från himlen. Och så visar det sig, Scratch, som de flesta programmeringsspråk, stöder slumptal eller tekniskt pseudokod slumptal, så att genom att dra och släppa vissa pusselbitar, Jag kunde ha papperskorgen kommer från vänster först. Och sedan nästa gång den föll, från höger och sedan från mitten. Och alla djur gjorde var bara har skräp som faller från himlen. Du kan inte peka på den eller klicka på den. Du kunde inte öppna papperskorgen. Du kan inte göra någonting. Men det var en baby steg mot min ultimata vision. 

Och efter det, jag faktiskt genomfört någon form av avkänning så att om du har klickat och dra på bit skräp över papperskorgen, Oscar locket skulle öppna och stänga. Inget skulle hända till papperskorgen, men åtminstone locket skulle öppna och stänga. Så då kontrollera, steg två av två. Och detta är vad som kommer att vara nyckel i både problembild noll och programmering i allmänhet, är att ta dessa mycket medvetna baby steg. Eftersom den inte bara tillåter dig att känner ärligt åstadkommit mycket mer quickly-- det är värsta i världen att försöka genomföra alla Oscar tid, sedan timmar senare slog den gröna flaggan, och ingenting fungerar som förväntat eftersom där ni även börja felsöka eller felsöka programmet? Det är bara överväldigande. 

Och så äkta omslutande denna idé ta steps-- baby steg igen och igen-- bygga upp något som är i slutändan, verkligen imponerande och komplexa, men vid första, är inte alls lika mycket så. I själva verket, låt oss göra detta. Låt mig gå vidare och-- Scratch själv finns på webben på Scratch.MIT.edu, och du kommer att höra som mycket igen i problem ställa noll, specifikationen för som redan finns på CS50: s hemsida. 

Men detta är vad Scratch själv är. Och det är egentligen bara tre huvudområden. Längst upp till vänster där är den så kallade stadium. Detta är Scratch. Standard kostym är en katt. Och detta är den rektangulära världen som du kan move-- upp, ner, vänster, höger och några andra saker. I mitten här är våra kategorier eller våra lastpallar av pusselbitar, och olika färger betyda olika saker. Och om du rota runt, ser du saker som loopar och villkor och variabler och andra ingredienser. 

Och sedan över här är det skript området. Det är där jag kan dra och släppa dessa pusselbitar för att göra saker. Så låt oss göra en sådan sak. Låt mig gå vidare och-- och jag vet var det är. Så jag kommer att omedelbart klicka på där jag vet att saker är redo att bli, men att peka och klicka och peta runt är oundvikliga. Så när grön flagg klickade, Vad vill jag göra? Jag kommer att göra detta. Jag kommer att dra denna lila pussel bit, säga hej till två sekunder, och låt mig zooma in. 

Och jag kommer att ändra detta att vara vad jag vill att det ska be-- hallå världen i två sekunder är bra. Nu, jag kommer att klicka på gröna flaggan, eller om jag verkligen vill, Jag kan fullskärms det och sedan komma tillbaka. Det kommer bara att hålla allt i ett fönster. Grön flag-- hallå världen. Okej. Inte så intressant. Så låt mig gå vidare och göra det. Låt mig prova en annan. När grön flagga clicked-- låt oss göra något som ett ljud. Och märker att ur rutan för gratis får en katt ljud, som är standard spriten. Så låt mig nu gå vidare och träffa den gröna flaggan nu. 

[Meowing] 

Aw. Det är bedårande. Jag programmering. Så vad har jag gjort? Detta motsvarar ett program. Det är naturligtvis super enkelt. Det tog inte riktigt ta så mycket ansträngning och MIT gjorde det mesta av arbetet, men jag har kallat en funktion. Jag har använt en funktion. Jag har gjort vissa åtgärder, med bara att en lila pusselbit. 

Tja, om jag vill göra tre jamar i rad? Låt mig gå vidare och göra två och tre. Och märker att när du sväva i närheten en pusselbit, en liten vit linje visas sortera av magnetiskt, och det kommer att snäppa tillsammans när du släpper. Låt oss se vad som händer här. 

[Meowing] 

Det finns en bugg. Jag hör bara ett mjau. Varför skulle det vara? Ja? Ja. Vi vet inte riktigt höra det, men det är bra intuition. De är alla spelar på samma gång. Varför? Tja, är datorn bara kommer att göra vad du säger den att göra. Så om du säger, spela ljud, spela upp ljud, spela upp ljud, men du behöver inte berätta det att spela tills du är klar, spela tills du är klar, det kommer att blåsa igenom programmet riktigt snabbt och gör bara vad du säger den att göra. 

Så jag behöver faktiskt fixa detta på ett par olika sätt. Jag kunde bara göra detta, bli av med detta. Låt mig prova denna andra pussel piece-- spela upp ljud jama tills gjort, och sedan dra tre av dessa och klicka på Spela. 

[Meowing] 

Det är inte riktigt very-- tacka du-- mycket naturligt. Så varför inte Jag-- låt mig gå att kontrollera här. Trevlig. Vänta en sekund, och nu vill jag gå tillbaka till ljud och spela tills ljudet gjort, och sedan låta mig få vänta en sekund. Och låt mig gå och få en mer ljud, och här går vi. 

[Meowing] 

Lite mer naturlig, men detta är inte särskilt effektiv. Som jag började bli uttråkad, alla vara Kort sagt, klicka fram och tillbaka och verkligen duplicera min work-- ganska mycket kopiera och klistra in. Faktum är att om jag styra klickade eller högerklickar på den, Jag kunde bara kopieras och klistras. Vad skulle vara en bättre konstruktion att använda? Vad idé från tidigare? 

Ja, så en slinga. Och i själva verket, om vi stötas runt, vi kan hitta just det. Låt mig gå till händelser eller snarare Control. Så repeat-- jag inte vill att det ska vara 10 gånger. Det kommer att få irriterande snabbt. Men jag kommer att upprepa tre gånger. Låt mig gå tillbaka till ljud och spela upp ljudet tills det är gjort. Låt mig gå tillbaka till Kontroll och bara vänta en sekund. Och varsel, kanske du tror att det inte passar, men igen om magnetiskt du låter det snap på plats, kommer det att växa för att fylla. Vad det spelar nu? 

[Meowing] OK. Trevlig. Och detta är vad som skulle kunna kallas ett program som är också korrekt. Det jamade tre gånger ganska naturligtvis, men det är bättre utformade. Jag använder mindre redundans. Jag ville inte kopiera och klistra in något. Jag använde bara en bättre idé. 

Nu är det fortfarande inte så intressant med Scratch inte göra vad som helst. Så låt oss göra något annat istället. Låt oss göra något för evigt. Och vet du vad? Motion verkar intressant. Låt oss ha honom flytta 10 steg och slog spela nu. 

OK. Väl vi kan slags dra honom tillbaka, och han är fortfarande visas eftersom han gör detta för alltid. Så slingan gör vad det säger att göra, men det är inte så intressant. Nu gör vi det. Låt mig tillägga ett kontrollblock, och använda en av dessa villkor för första gången. 

Så det kommer att röra sig 10 steps-- 10 punkter, 10 pixlar på Screen-- då det kommer att ställa denna fråga. Om något är sant, då gör något i detta block. Så visar det sig avkänning har en hel gäng Boolean expressions-- frågor om ja nej eller sant false form-- låt mig göra detta. 

Om touching-- och sedan finns det denna lilla rullgardinsmenyn. Jag kan parametrisera den. Om vidröra edge-- låt oss göra något liknande. Så om att röra edge-- Låt mig gå tillbaka till rörelse. Och varför inte vi bara vända 180 grader? Okej. Så för evigt, flytta 10 steg. Om du vidrör kant, vänder 180 grader. Och det är inte slutet av programmet eftersom du är i en evigt blockera så det kommer att gå igen och igen och igen och igen. Så låt oss se vad som händer. OK. Lite buggy, men ganska häftigt. 

Och vi kan lägga till denna del dumma saker som är inte så intellektuellt intressant. Men om vi träffade denna lilla mikrofon button-- aj. Låt mig rensa upp detta. Låt mig förstärka denna som de skulle säga på TV. Rengör det upp, Spara, och nu gå upp till manus. 

Och nu, låt mig gå till ljud. Låt mig ge den ett namn. Jag kallar detta aj. Och nu spela upp ljud aj. Lägg märke till den visas i lite rullgardinsmenyn. Låt oss se. 

[AJ] 

[SKRATTANDE] Men vi kan ändra t hans i farten. Vi kan vara dubbelt så irriterande. 

[AJ] 

Eller om vi gör det som 1000 steg på en time-- 

OK. Så vi kommer att lämna den en ensam. Så återigen, att bygga blocks-- jag igång med något superenkel, och sedan jag lagt till en funktion, lagt till en funktion, lagt till en funktion. Och jag behöver inte längre oroa sig för hur den första av dessa funktioner genomfördes som jag fortsätter att lagret saker på toppen. Så i själva verket, låt mig göra en annan här. Låt mig gå vidare och öppna en fil som Jag tog i förväg, kallas Får. 

Så det har en något annorlunda karaktär som ser ut så här. Och låt mig se om jag kan inte göra något med en räknare i detta case-- en så kallad variabel. Jag kommer att gå vidare och under Events-- Låt mig få en grön flagga klickade. Låt mig gå till Data, som jag vet från bara spela runt innan, är där variablerna är. Och jag kommer att gå vidare och dra detta. 

Så en variabel som heter räknare, och Jag kommer att initiera den till noll. Jag kan kalla det anything-- x eller y eller z-- men i programmering, ringer något i en semantiskt användbart sätt, såsom räknare, som beskriver vad det är, det är en mycket lättare att läsa koden senare. Låt mig gå vidare och få en evigt blockerar här. Och låt mig gå till utseende sida och gör en Say block. Men vad är hett om variabler är jag behöver inte bara skriva in något som Hello World, som vi redan har gjort, kan jag i stället gå till Data och dra min variabel, och även även om formen inte riktigt ser ut som det skulle passa, det kommer att växa för att fylla. Och jag ska bara säga räknaren för en second-- spoiler-- han kommer att räkna. Vi säger det för en sekund. Då kommer jag att gå och har han vänta en sekund, så det räknas inte upp för fort. Och sedan slutligen ändra disk genom en-- med andra ord, öka räknaren med ett mervärde och göra det för evigt. 

Så fåren också, som en programmerare, räknar från 0. Och om vi väntar tillräckligt länge, han kommer att göra detta för alltid. Men det är inte riktigt sant, eftersom i själva verket, som vi kommer att upptäcka i veckan en, heltal och datorer mer allmänt, tekniskt har bara en finite-- väl, snarare datorer, när de representerar heltal, bara har ett ändligt antal bitar. Dessa lampor där kan bara räkna så högt innan du är ute på glödlampor. Och en dator också, endast har så mycket minne, endast har så många transistorer, så det kan bara räkna så högt. 

Så visar det sig att den får, Jag tror, ​​kan räkna till 2 miljarder eller något ganska stor. Så vi kommer inte att vänta för att detta ska ske. Men så småningom en del buggar som kommer att hända som kan ha några mycket verkliga världen förgreningar. Men bortom fåren, att bara introducerar en variabel. Låt oss gå vidare och öppna upp något som jag gjort i förväg här kallad pet Cat-- Klappa katten hit. Och märker här är det få block, men när grön flagg klickade, alltid göra följande. Om du röra musen pointer-- så markören på skärmen, den arrow-- play ljud jama och sedan vänta två sekunder. Och bara göra det för evigt. Bara ständigt vänta för att se om pointer-- om katten vidrör pekaren. 

Så jag slog spela. Ingenting händer. Men som jag flyttar markören över katten, 

[Meowing] 

Och om jag flyttar bort, inte petting katten längre. Så några villkorslogik kapslade i en slinga. Vad sägs om det här exemplet, medvetet heter inte klappa katten? Vad detta kommer att göra? 

[Meowing] 

Varför skulle du inte klappa katten? 

[Meowing] 

OK. Så det här är ett exempel på en om annat. Det är en beslutspunkt och eftersom det sitter i en slinga, de är båda få kontrolleras. Är detta sant? Är detta sant? Är detta sant? Är detta sant? Och så småningom, en av de som kommer att gälla och så hör du antingen mjau eller bruset av lejon i det fallet. 

Nåväl, låt oss göra en något mer fantasifullt en som jag gjorde i förväg too-- trådar. Så en tråd är bara en sak som en dator kan göra. Så en flertrådad program är ett program som kan göra flera saker samtidigt. Och alla dessa exempel hittills har haft bara ett manus, så att speak-- ett program som detta upp här. Men märker detta program har två sprites, två tecken. Den ena är en fågel. Den ena är en katt. 

Och märker när jag klickar på dessa ned vänster, de har alla sina egna skript eller program som är associerade med dem. Och båda av dem program, meddelande, start med när grön flagga clicked-- låt oss titta på cat-- när grön flagg klickade. Och så sannerligen, när jag slog spela nu, två saker kommer att hända på en gång. Katten och fågeln är båda kommer att arbeta samtidigt att skapa denna effekt. Och du kan föreställa sig vad som händer. Det finns en slinga och fågeln och katten finns i en slinga. Fågeln är bara studsar som Jag var innan när jag sa aj. Men katten har en klar fördel. Det finns en annan sensorblocket som pekar katten medvetet till fågeln i detta fallet här. Så vi kan retas isär, genom att titta genom dessa block, vad som händer. Men den viktigaste ingrediensen här är ett. Fågeln, så att detta spel är inte helt boring-- eller denna animation-- startar vid en slumpmässig riktning. Och datorn plockar ett tal mellan 90 och 180 i huvudsak, så att det är en aning annan animering varje gång. 

Och sedan märker här, om katt röra fågeln, då spela lejonet fyra sound-- bruset. Men under tiden i fågelns palett, har vi redan. Evigt, om inte vidröra katt, bara hålla rörliga tre steg. Och så här är en annan pusselbit. Om du är på kanten, studsa. Så fågeln är bara typ av skötte sin egen verksamhet, bara flyga runt och studsar, och det är verkligen katten som hade den villkorslogik för att avgöra om det hade fångat fågeln. Okej. Så låt oss göra en annan här, detta kallas hi hi hi. Och detta här bara gör detta i ett evigt slinga. Men notice-- hur vi slutar detta mycket irriterande program? Hit mellanslagstangenten. För om jag gör det, den vänstra program-- märker det ständigt listening-- är nyckeln utrymme press. Om mellanslagstangenten trycks in, och om så är fallet, vad gör det? Det gör en mycket vanlig teknik. Det sätter en variabel lika med ett visst värde. Men det växlar det värdet. [? Så utseende?] baserad på den shape-- I har en variabel som jag skrev i förväg kallas Avstängt, som bara säger ja eller nej. Är ljudet avstängt eller inte? Sant eller falskt? Och varsel, säger jag this-- om avstängt är noll, sedan byta till en, annars satt stum det till noll. Så bara vända värdet från noll till ett. Jag kunde ha done-- ändra det från två till tre och 3-2 eller 4-5 eller 4-6. Men det spelar ingen roll vilka nummer som jag använder, så länge jag håller ändra det tvärtom. 

Och de flesta någon programmerare skulle bara välja noll och en-- falskt och äkta, off och on-- att representera denna. Och detta är fortfarande igång. Om jag tryck på mellanslagstangenten igen 

[SEAL LJUD] 

Programmet är fortfarande igång. Eftersom det är det här andra script som säger, alltid göra följande. Om dämpad variabeln är lika med zero-- så om du inte är avstängt är logic-- om det är falskt eller ingen, sedan spela upp ljudet, eftersom du inte avstängt. Du borde spela upp ljudet och sedan tror hi hi hi i två sekunder och sedan vänta och göra det igen och igen och igen. 

Och så på detta sätt har vi ett sätt för människor att-- för program för att interagera. Och de behöver inte vara som dateras som andra. I själva verket, att peta around-- no pun intended-- någon tillbringade en stor mängd tid på internet genomförande PokemonGo i Scratch. Det geolocates även dig Cambridge eller Allston här. Så om du vill se också vad folk kan göra är this-- mycket fint meny. Klicka här. 

Detta är jag med mina piltangenterna nu. Jag kommer att gå efter detta. Klick. Och nu du klickar på pokeball. Jag menar, jag tror att du är tänkt att klicka på pokeball. Okej. Så jag gjorde det. Jag kan gå hit. Och denna person genomfört några mer PokeBalls över här-- tre PokeBalls. 

Vi kommer att lägga en länk till detta nätet så att du kan spela. Men meddelandet finns det bara vissa grundläggande byggstenar. Det ser mycket snyggare, och det är. Detta är imponerande och mer än vi skulle normalt förväntar, säkert för problem in noll. Jag har ingen aning om hur länge den här personen spenderas online. Men det är bara en slinga. Det finns en god spela. Det finns något slags slinga lyssna efter om jag är slå på uppåt- eller nedåt pil eller vänster och höger, och sedan om så är fallet, är det att flytta det ett visst antal bildpunkter. Och sedan om jag klickar på en annan sprite, det finns något slags om tillstånd där. Ja, detta blir för intensiv. Vi kommer att sluta. Det är alla dessa grundläggande byggstenar. Det finns inga andra andra ingredienser än de som vi har tittat på redan. 

Och ändå här, låt mig göra en slutlig uppsättning av exempel som målar en bild för av vad du kan göra här. Här är ett mycket enkelt program som bara gör this-- hosta, hosta, hosta. Och baserat enbart på vad Vi har tittat på hittills, där är det självklara möjlighet till förbättring. Detta program är korrekt. Det hostar tre gånger, vilket är vad jag tänkt. Men det är dåligt genomförs. Det är dåligt utformade. Varför? Ja. Det är inte en loop. Och det är inte så mycket att det inte är en slinga, det är att det finns en hel del redundans. Det kopieras och klistras kod, så att säga. Och lösningen troligen är verkligen en slinga. Så låt mig gå vidare och förbättra det. Och jag kommer att dra dessa över här. Låt mig gå vidare och få en rapport blocket, ändra detta till tre. Jag kommer att kasta bort vissa av dessa block. 

Och du kommer att märka att det är ganska intuitivt. Du dra och släpp och saker dyka upp och försvinna så småningom. Och jag kan bara dra detta i här, och Nu har jag en renare version fortfarande. Men vet du vad? Det finns denna möjlighet nu för abstraction-- att börja definiera nya ord att MIT inte förutse. Det finns vänta och upprepa och för evigt och om men vad händer om jag vill presentera ordet hosta som ett block? Vad händer om jag vill ha en pusselbit vars syfte i livet är att hosta? 

Nåväl, låt oss titta på den här versionen här, som jag gjort på följande sätt. Magiskt, har jag skapat denna pusselbit här, som Scratch låter dig göra. Och faktiskt C och Python och JavaScript är kommer att tillåta dig att göra detta. Du kan skapa dina egna bitar som du ringer vad du vill. I detta fall känns hosta som en rimlig definition. Och sedan med dessa bitar ner Här kan du definiera vad det innebär. 

Jag dras och släppas från denna palett här-- mer blocks-- denna stora lila kvarter, där jag skrev i hosta som namnet på mitt nya pusselbit. Och då jag säger varje gång en användare kallar denna nya hosta pusselbit, gör något att säga och en väntan. Och så här uppe i min upprepa blocket, Jag kan bara hosta tre gånger. 

Och jag vill hävda, i synnerhet om nu du dölja denna detalj. Vem bryr sig om hur hosta genomförs? Allt jag bryr mig om som en programmerare att jag kan hosta. Jag bryr mig inte hur säga genomförs. Jag bryr bara att katt kan säga något. Jag kan abstrakt bort den detaljen och bara fokusera på vad som finns på skärmen här. Men jag kan ta detta ett steg längre. 

Lägg märke till att här, jag har implementerat slingan tre gånger. Men vad händer om jag istället ta den här versionen? Och vad händer om istället i denna version här, Jag ändrar bara min pusselbit för att ta ett argument och input åt sig själv? Och den ingången kan vara ett antal som tre. Så nu, om jag skriver ett program och jag vill att katten att hosta, Jag kan faktiskt säga pusslet pussla hur många gånger att hosta, eftersom längst ner här, en snyggare versionen av dessa anpassade pusselbitar låter mig ange att hosta faktiskt tar en input-- tar ett argument som denna. Och vet du vad? Kanske jag inser, vänta en minut. Hosta är den same-- Det är fundamentalt samma idé som nysningar. Det är bara en annan ord på skärmen. Jag kan abstrakt bort vidare och genomföra Detta slutliga versionen av en hosta, som vid första anblicken är mycket mer komplex ser. Men lägg märke till vad jag har gjort. Jag har nu generalized-- genericized really-- denna pusselbit att kallas säga ordet n gånger. 

Och nu har jag två nya pusselbitar här nere definiera hosta n gånger. Och vad hosta funktionen gör? Vad gör min egen pusselbit göra? Det uppmanar bara säga blocket, passerar i ord jag vill säga, passerar i antalet gånger jag vill säga. För nu kan jag genomföra nysa genom att helt enkelt säga achoo, i detta fall, en del antal gånger. 

Och så jag skiktning och skiktning. Och återigen, är inte nyckeln här hur jag genomfört det, men faktum att om jag bara bokstavligen flytta dessa utanför skärmen, se hur enkelt om inte ganska mitt program ser nu. Eftersom det gör vad den säger, jag har sammandrag bort vad som finns i den svarta lådan. det råkar vara en lila rutan här, men jag har blockerat bort vad som finns inuti eftersom jag inte bryr sig om hur det fungerar. Jag bryr just nu att det fungerar. 

Och faktiskt, i problem set noll, är det exakt den typ av skiktning av idéer du kommer har möjlighet att utforska. Det är precis den möjlighet att tillämpa problemlösningstekniker, vad är förmodligen en obekant miljö. Och om du inte har programmerat före eller förprogrammerats, du kommer att upptäcka att det finns en liten sak i denna miljö för alla. Och med problem inställd en i en veckas tid, vi kommer att flyttas över till att fokusera på ett språk högre nivå kallas C- eller snarare en lägre nivå språk som kallas C- det är ännu mer kraftfull, även om det är lite mer kryptiskt vid första anblicken. 

Och du inser per dagens TL: DR, att detta problem set har en kortare tidsfönster än framtida sådana, helt enkelt eftersom du ska hitta det ganska tillgänglig. Och inte oroa dig om du lägger klassen sent. Vi kommer att ta itu med det inom kort. Och innan vi ajournera för tårta, låt oss avsluta med bara två minuters look på vad som väntar dig här i CS50. [Musik spelar] Okej. Det var allt för CS50. Vi kommer att se dig snart. Kaka serveras nu. [Musik spelar] TALARE 17: Har du hört av ett sabbatsår, Chief? TALARE 18: Kanske finns det mer under huven. 