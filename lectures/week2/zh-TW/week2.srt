1
00:00:00,000 --> 00:00:02,970
>> [音樂]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN：好的。

4
00:00:15,700 --> 00:00:18,832
這是CS50這
2週的開始。

5
00:00:18,832 --> 00:00:21,040
你會記得，在
在過去的幾個星期，

6
00:00:21,040 --> 00:00:24,490
我們已經引進電腦
科學和，反過來，編程。

7
00:00:24,490 --> 00:00:27,640
>> 我們依路開始的故事
從無到有，即圖形語言

8
00:00:27,640 --> 00:00:28,990
來自麻省理工學院媒體實驗室。

9
00:00:28,990 --> 00:00:30,780
然後最近一段時間，
上週，我們什麼

10
00:00:30,780 --> 00:00:34,450
引入higher--一
較低級別的語言已知

11
00:00:34,450 --> 00:00:36,770
如C，一些純粹的文字。

12
00:00:36,770 --> 00:00:39,440
而且，事實上，我們最後一次
該範圍內探討

13
00:00:39,440 --> 00:00:40,450
一些概念。

14
00:00:40,450 --> 00:00:43,010
>> 這一點，回憶，是非常
第一個節目，我們看著。

15
00:00:43,010 --> 00:00:45,710
而這個程序很簡單，
打印出來，“你好，世界”。

16
00:00:45,710 --> 00:00:47,730
但有這麼多
似乎魔術回事。

17
00:00:47,730 --> 00:00:51,460
有此#include
這些尖括號。

18
00:00:51,460 --> 00:00:52,170
有int類型。

19
00:00:52,170 --> 00:00:53,020
有（無效）。

20
00:00:53,020 --> 00:00:56,330
有括號，大括號，
分號，和這麼多。

21
00:00:56,330 --> 00:00:58,480
>> 所以，記得
我們推出划痕

22
00:00:58,480 --> 00:01:02,110
這樣我們就可以，理想情況下，看過去
該語法，那真的不是東西

23
00:01:02,110 --> 00:01:04,590
所有的理智
有趣的，但早

24
00:01:04,590 --> 00:01:07,700
是的，絕對的，有點棘手
來包裝你的頭腦周圍。

25
00:01:07,700 --> 00:01:10,860
而且，事實上，最常見的一種
事情早在編程類，

26
00:01:10,860 --> 00:01:13,443
特別是對於那些不太
舒適，是讓被挫敗

27
00:01:13,443 --> 00:01:17,460
並絆倒了某些語法
錯誤，更不用說邏輯錯誤。

28
00:01:17,460 --> 00:01:19,800
所以我們的目標之一
今天，居然會

29
00:01:19,800 --> 00:01:23,280
與某些裝備你
解決問題的技巧如何

30
00:01:23,280 --> 00:01:26,705
更好地解決自己的問題
在調試的形式。

31
00:01:26,705 --> 00:01:29,330
你會記得，這才明白，
我們引入了環境

32
00:01:29,330 --> 00:01:31,780
最後一次被稱為CS50 IDE。

33
00:01:31,780 --> 00:01:34,850
這是基於網絡的軟件是
讓你在雲中進行編程​​，

34
00:01:34,850 --> 00:01:38,450
可以這麼說，同時保持你的所有
文件一起，為我們再次將在今天。

35
00:01:38,450 --> 00:01:41,480
而記得，我們
在這裡重溫這些話題，

36
00:01:41,480 --> 00:01:44,480
其中的功能，以及環路，並
變量和布爾表達式，

37
00:01:44,480 --> 00:01:45,110
和條件。

38
00:01:45,110 --> 00:01:49,190
而實際上多了一些，我們
從頭開始的世界翻譯

39
00:01:49,190 --> 00:01:50,800
到C的世界

40
00:01:50,800 --> 00:01:53,220
>> 但根本建設
塊，可以這麼說，

41
00:01:53,220 --> 00:01:55,150
真的還是上週相同。

42
00:01:55,150 --> 00:01:57,900
實際上，我們真的只是有一個
不同的拼圖，如果你願意。

43
00:01:57,900 --> 00:02:00,300
而不是紫色的
保存塊，而不是我們

44
00:02:00,300 --> 00:02:02,940
已經printf的，這是
這個功能在C，它

45
00:02:02,940 --> 00:02:05,890
允許您打印的東西
並格式化在屏幕上。

46
00:02:05,890 --> 00:02:07,950
我們推出了CS50
圖書館，在那裡你

47
00:02:07,950 --> 00:02:11,420
現在在您的處置GET_CHAR，
和get_int和get_string，

48
00:02:11,420 --> 00:02:14,610
和其他一些功能
好了，通過它你可以輸入

49
00:02:14,610 --> 00:02:16,260
從用戶自己的鍵盤。

50
00:02:16,260 --> 00:02:20,640
我們也看了看東西
像these-布爾和char，

51
00:02:20,640 --> 00:02:22,490
和雙，浮法，
INT，long_long字符串。

52
00:02:22,490 --> 00:02:25,170
還有的在C.甚至其他數據類型

53
00:02:25,170 --> 00:02:28,560
>> 換句話說，當你聲明
一個變量來存儲一定的價值，

54
00:02:28,560 --> 00:02:32,600
或者當你實現一個功能
返回一定的價值，

55
00:02:32,600 --> 00:02:35,290
您可以指定哪些
類型的值即是。

56
00:02:35,290 --> 00:02:37,310
它是一個字符串，如
字符序列？

57
00:02:37,310 --> 00:02:39,490
它是一個數字，如一個整數？

58
00:02:39,490 --> 00:02:41,390
它是一個浮點
值，等等？

59
00:02:41,390 --> 00:02:46,180
因此，在C，不像劃傷，我們實際上
開始指定什麼樣的數據

60
00:02:46,180 --> 00:02:48,330
我們正在返回或使用。

61
00:02:48,330 --> 00:02:51,910
>> 但是，當然，我們也遇到了
計算的一些基本限制。

62
00:02:51,910 --> 00:02:54,100
並且特別地，
這種語言C，召回

63
00:02:54,100 --> 00:02:57,070
我們看一看在
整數溢出，現實

64
00:02:57,070 --> 00:03:00,460
如果你只有一個
內存數量有限

65
00:03:00,460 --> 00:03:04,600
或者，具體而言，有限數量的
位的，你只能算這麼高。

66
00:03:04,600 --> 00:03:08,460
因此，我們看這個例子在這裡
因此在飛機上的計數器，

67
00:03:08,460 --> 00:03:13,510
實際上，如果運行時間足夠長會
溢出，並導致一個軟件

68
00:03:13,510 --> 00:03:15,560
一個實際的物理潛在錯誤。

69
00:03:15,560 --> 00:03:18,600
>> 我們也看了浮動
點不精確，現實

70
00:03:18,600 --> 00:03:22,280
僅與有限數量的
位，無論是32還是64，

71
00:03:22,280 --> 00:03:27,330
你只能指定如此多的號碼
後一個小數點，之後你

72
00:03:27,330 --> 00:03:29,110
開始變得不精確。

73
00:03:29,110 --> 00:03:32,360
因此，例如，三分之一的
世界在這裡，在我們人類世界，

74
00:03:32,360 --> 00:03:35,360
我們知道僅僅是一個無限多
小數點後3秒。

75
00:03:35,360 --> 00:03:38,820
但一台電腦可不一定
表示數字無限數量

76
00:03:38,820 --> 00:03:42,590
如果只允許它的一些
有限數量的信息。

77
00:03:42,590 --> 00:03:45,900
>> 所以，我們不僅裝備你
在條款更大的權力

78
00:03:45,900 --> 00:03:49,280
你會如何表達自己的
鍵盤編程方面，

79
00:03:49,280 --> 00:03:51,430
我們還限制什麼
你實際上可以做。

80
00:03:51,430 --> 00:03:55,790
事實上，錯誤和錯誤會
從這些類型的問題的出現​​。

81
00:03:55,790 --> 00:03:59,900
事實上，在主題中今天
要像調試主題

82
00:03:59,900 --> 00:04:03,699
實際上看引擎蓋下
在上週的事情是如何介紹

83
00:04:03,699 --> 00:04:05,490
實際上實施
讓你更好

84
00:04:05,490 --> 00:04:10,530
了解兩者的能力和
如C語言的限制

85
00:04:10,530 --> 00:04:14,770
>> 而事實上，我們將剝開層層
最簡單的數據結構，

86
00:04:14,770 --> 00:04:17,756
一種叫做陣列，它
划痕發生所謂的“清單”。

87
00:04:17,756 --> 00:04:19,589
這是一個有點
在這方面有所不同。

88
00:04:19,589 --> 00:04:23,340
然後，我們還將介紹之一
首先我們特定領域的問題

89
00:04:23,340 --> 00:04:26,790
在CS50，世界
加密，加擾的藝術

90
00:04:26,790 --> 00:04:29,650
或加密信息，以便
您可以發送秘密信息

91
00:04:29,650 --> 00:04:34,520
和解碼秘密信息
兩個人，A和B之間

92
00:04:34,520 --> 00:04:37,490
>> 所以，我們之前的過渡
那個新的世界，

93
00:04:37,490 --> 00:04:42,059
讓我們嘗試一些裝備你
技術，使用它可以消除

94
00:04:42,059 --> 00:04:43,850
或減少至少一些
坎坷的

95
00:04:43,850 --> 00:04:46,630
你可能已經遇到過
僅在過去的一周。

96
00:04:46,630 --> 00:04:50,830
事實上，在你前面的such--一些
在C和賠率你的第一個問題是，

97
00:04:50,830 --> 00:04:54,010
如果你像我一樣，在第一時間
您嘗試鍵入一個方案，

98
00:04:54,010 --> 00:04:57,330
即使你認為邏輯
該方案是非常簡單的，

99
00:04:57,330 --> 00:05:01,200
你很可能會碰了壁，並
編譯器是不會合作。

100
00:05:01,200 --> 00:05:03,940
製作或鏘不會
真正做您的出價。

101
00:05:03,940 --> 00:05:05,450
>> 而為什麼會這樣呢？

102
00:05:05,450 --> 00:05:07,950
好吧，讓我們來看看，
也許，一個簡單的程序。

103
00:05:07,950 --> 00:05:11,190
我要繼續前進，它保存在
故意叫buggy0.c文件，

104
00:05:11,190 --> 00:05:13,590
因為我知道它要
提前缺陷。

105
00:05:13,590 --> 00:05:17,400
不過，我可能沒有意識到，如果這
是在第一或第二或第三程序

106
00:05:17,400 --> 00:05:18,830
這實際上，我讓自己。

107
00:05:18,830 --> 00:05:23,820
所以我要繼續前進，
打出來，主要INT（無效）。

108
00:05:23,820 --> 00:05:28,130
然後我裡面的花括號，
一個非常熟悉的（“你好，天下 - 

109
00:05:28,130 --> 00:05:30,980
反斜線，正“） - 和一個分號。

110
00:05:30,980 --> 00:05:32,360
>> 我保存的文件。

111
00:05:32,360 --> 00:05:34,850
現在，我要下去
我的終端窗口

112
00:05:34,850 --> 00:05:40,340
並輸入make buggy0，因為，同樣，
該文件的今天的名稱是buggy0.c。

113
00:05:40,340 --> 00:05:43,660
所以我鍵入make buggy0，回車。

114
00:05:43,660 --> 00:05:48,200
>> 而且，哦，天哪，從最後一次召回
沒有錯誤消息是一件好事。

115
00:05:48,200 --> 00:05:49,740
因此，沒有輸出是一件好事。

116
00:05:49,740 --> 00:05:52,920
但在這裡我必須清楚地
一些數字錯誤。

117
00:05:52,920 --> 00:05:56,470
>> 所以輸出的第一行
輸入make buggy0後，召回，

118
00:05:56,470 --> 00:05:59,540
是鏘的相當詳細的輸出。

119
00:05:59,540 --> 00:06:02,067
在底層，
CS50 IDE配置

120
00:06:02,067 --> 00:06:04,150
使用一大堆
與此編譯器選項

121
00:06:04,150 --> 00:06:05,941
讓您不必
想想他們。

122
00:06:05,941 --> 00:06:08,840
而這所有的第一線
裝置與鏘開始。

123
00:06:08,840 --> 00:06:11,720
>> 但在此之後，該問題
開始讓自己的外表。

124
00:06:11,720 --> 00:06:17,390
Buggy0.c上線3條，性格
5，有一個大的，紅色的錯誤。

125
00:06:17,390 --> 00:06:18,380
那是什麼？

126
00:06:18,380 --> 00:06:23,562
隱式聲明的庫函數
int型的（為const char *的printf，

127
00:06:23,562 --> 00:06:26,050
...）[-Werror。

128
00:06:26,050 --> 00:06:28,379
我的意思是，它非常快
變得很神秘。

129
00:06:28,379 --> 00:06:30,170
當然，在第一次
一目了然，我們不會

130
00:06:30,170 --> 00:06:32,380
希望你能理解
該消息的全部內容。

131
00:06:32,380 --> 00:06:34,213
和教訓，所以一
今天是怎麼回事

132
00:06:34,213 --> 00:06:36,919
要嘗試，以通知
圖案，或類似的事情，

133
00:06:36,919 --> 00:06:38,960
錯誤你可能有
在過去所遇到。

134
00:06:38,960 --> 00:06:41,335
因此，讓我們只能梳理出
這些話是很熟悉。

135
00:06:41,335 --> 00:06:44,290
大，紅色的錯誤顯然是
象徵性的東西是錯誤的。

136
00:06:44,290 --> 00:06:47,940
>> 隱式聲明
庫函數printf。

137
00:06:47,940 --> 00:06:51,680
所以，即使我不太明白什麼
隱式聲明的庫函數

138
00:06:51,680 --> 00:06:54,900
手段，肯定是問題
涉及到莫名其妙的printf。

139
00:06:54,900 --> 00:06:59,130
這問題的根源
有宣稱它做。

140
00:06:59,130 --> 00:07:02,440
>> 聲明一個函數
提到它的第一次。

141
00:07:02,440 --> 00:07:06,210
而我們所使用的術語上週
聲明一個函數的原型，

142
00:07:06,210 --> 00:07:11,860
無論是與在頂部的一行您的
自己的文件或在一個所謂的頭文件。

143
00:07:11,860 --> 00:07:15,300
在什麼文件做我們說
上週printf的是報價，

144
00:07:15,300 --> 00:07:17,080
引文結束，宣告？

145
00:07:17,080 --> 00:07:20,950
在哪些文件是它的原型？

146
00:07:20,950 --> 00:07:24,640
>> 所以，如果你還記得，第一件事我
類型化，幾乎每個節目最後時間 - 

147
00:07:24,640 --> 00:07:30,790
一不小心剛才開始
打字myself--是這一個這裡 - 

148
00:07:30,790 --> 00:07:38,630
hash--的#include <stio--為
輸入/ output--點H和事實上，

149
00:07:38,630 --> 00:07:41,860
如果我現在保存這個文件，我要去
先走，並清除我的屏幕，

150
00:07:41,860 --> 00:07:44,740
您可以通過鍵入做
清除，或者你可以按住控制L，

151
00:07:44,740 --> 00:07:47,680
只是清除終端窗口
只是為了消除一些混亂。

152
00:07:47,680 --> 00:07:51,370
>> 我要繼續前進，
再輸入make buggy0，回車。

153
00:07:51,370 --> 00:07:53,790
瞧，我仍然看到
從鐺長的命令，

154
00:07:53,790 --> 00:07:55,470
但沒有錯誤消息這一次。

155
00:07:55,470 --> 00:07:58,800
事實上，如果我這樣做./buggy0，
和上次一樣，

156
00:07:58,800 --> 00:08:01,860
其中，點指本
目錄，斜線只是手段，

157
00:08:01,860 --> 00:08:05,040
這裡談到的程序的名稱和
該方案的這個名字是buggy0，

158
00:08:05,040 --> 00:08:07,340
輸入“你好，世界”。

159
00:08:07,340 --> 00:08:09,440
>> 現在，你怎麼可能有
收集這一解決方案

160
00:08:09,440 --> 00:08:12,017
而不必
認識到盡可能多的話

161
00:08:12,017 --> 00:08:14,350
像我一樣，當然，有
這樣做了這麼多年？

162
00:08:14,350 --> 00:08:18,720
那麼，實現每一個問題
集，我們為您介紹一個命令

163
00:08:18,720 --> 00:08:21,175
這CS50自己的工作人員
編寫了一個名為help50。

164
00:08:21,175 --> 00:08:24,300
事實上，C不規範
問題設置至於如何使用它。

165
00:08:24,300 --> 00:08:27,210
>> 但help50本質
一個程序，CS50的工作人員

166
00:08:27,210 --> 00:08:30,850
寫道，允許您運行
一個命令或運行程序，

167
00:08:30,850 --> 00:08:36,169
如果你不明白它的
輸出，將其輸出傳遞到help50，

168
00:08:36,169 --> 00:08:38,890
在該點處的軟件
該課程的員工寫

169
00:08:38,890 --> 00:08:42,429
會看你的程序的輸出
一行行的，每個字符。

170
00:08:42,429 --> 00:08:46,000
如果我們的工作人員，承認
您所遇到的錯誤消息，

171
00:08:46,000 --> 00:08:50,580
我們將嘗試一些惹你
反問，有一些建議，

172
00:08:50,580 --> 00:08:54,890
就像一個TF或CA還是我自己
將在辦公時間做的人。

173
00:08:54,890 --> 00:08:58,320
>> 所以看help50如果你不
一定承認的問題。

174
00:08:58,320 --> 00:09:00,790
但不要依賴它
太多的拐杖。

175
00:09:00,790 --> 00:09:03,990
當然，試著去了解它的
輸出，然後從中吸取教訓

176
00:09:03,990 --> 00:09:07,571
使得僅一次或兩次你
以往運行help50特定錯誤

177
00:09:07,571 --> 00:09:08,070
信息。

178
00:09:08,070 --> 00:09:10,660
在這之後，你應該
更好的裝備自己

179
00:09:10,660 --> 00:09:13,180
要弄清楚它實際上是什麼。

180
00:09:13,180 --> 00:09:14,350
>> 讓我們做另外一個在這裡。

181
00:09:14,350 --> 00:09:20,410
讓我先走了，而在另一個
文件我們會打電話給這個buggy1.c。

182
00:09:20,410 --> 00:09:23,110
而在這個文件中，我
要deliberately--

183
00:09:23,110 --> 00:09:26,330
但假裝我不
明白我做了什麼樣的錯誤。

184
00:09:26,330 --> 00:09:31,420
>> 我要繼續前進，做this--
的#include，因為我已​​經

185
00:09:31,420 --> 00:09:33,660
吸取了教訓，從剛才的。

186
00:09:33,660 --> 00:09:36,220
詮釋主要（無效），如前。

187
00:09:36,220 --> 00:09:40,880
然後在這裡我會
做字符串s  -  get_string。

188
00:09:40,880 --> 00:09:43,770
而從上一次回顧
這意味著，哎，電腦，

189
00:09:43,770 --> 00:09:48,280
給我一個變量，稱之為s和
使該變量字符串的類型

190
00:09:48,280 --> 00:09:50,150
所以我可以存儲一個或多個字在裡面。

191
00:09:50,150 --> 00:09:52,191
>> 然後在右邊
等號的一面

192
00:09:52,191 --> 00:09:54,980
被get_string，這是一個
在CS50庫中的函數

193
00:09:54,980 --> 00:09:55,980
這正是這麼做的。

194
00:09:55,980 --> 00:09:59,740
它得到一個函數，然後
雙手從從右到左。

195
00:09:59,740 --> 00:10:02,670
所以這個等號並不意味著
“等於”象我們想像的數學。

196
00:10:02,670 --> 00:10:04,750
這意味著由右至左的分配。

197
00:10:04,750 --> 00:10:09,640
因此，這意味著，採取從字符串
在用戶和其存儲的S內部。

198
00:10:09,640 --> 00:10:10,460
>> 現在，讓我們使用它。

199
00:10:10,460 --> 00:10:13,820
現在讓我和繼續作為第二
行，讓我繼續前進，說“你好” - 

200
00:10:13,820 --> 00:10:19,330
不是“世界”，而是“你好，％S--
這是我們的佔位符，逗號S，

201
00:10:19,330 --> 00:10:22,030
這是我們的變量，
然後分號。

202
00:10:22,030 --> 00:10:26,070
所以，如果我沒有搞砸太多
在這裡，這看起來像正確的代碼。

203
00:10:26,070 --> 00:10:28,090
>> 而我的直覺現在進行編譯。

204
00:10:28,090 --> 00:10:30,400
該文件稱為buggy1.c。

205
00:10:30,400 --> 00:10:33,770
所以我打算做使buggy1，回車。

206
00:10:33,770 --> 00:10:36,377
和織補-它，如果沒有
甚至更多的錯誤比以前。

207
00:10:36,377 --> 00:10:38,210
我的意思是，還有更多
錯誤消息它會

208
00:10:38,210 --> 00:10:40,400
似乎比這個計劃的實際行。

209
00:10:40,400 --> 00:10:42,730
>> 但外賣這裡，
即使你不堪重負

210
00:10:42,730 --> 00:10:45,040
有兩個或三個或
四個錯誤信息，

211
00:10:45,040 --> 00:10:48,340
始終專注於非常
首先這些消息。

212
00:10:48,340 --> 00:10:52,220
看最頂部的之一，
滾動備份如需要的話。

213
00:10:52,220 --> 00:10:53,930
所以在這裡我輸入化妝buggy1。

214
00:10:53,930 --> 00:10:55,700
下面是按預期鏘輸出。

215
00:10:55,700 --> 00:10:57,290
>> 而這裡的第一個紅色錯誤。

216
00:10:57,290 --> 00:11:02,370
未聲明的標識符使用
字符串，沒有我的意思是標準？

217
00:11:02,370 --> 00:11:04,260
因此，標準是
其實別的東西。

218
00:11:04,260 --> 00:11:06,240
它指的是用戶的
鍵盤，本質上。

219
00:11:06,240 --> 00:11:08,080
>> 但是，這不是我的意思。

220
00:11:08,080 --> 00:11:11,770
我的意思是字符串，我的意思是get_string。

221
00:11:11,770 --> 00:11:16,200
那麼它是什麼，我
忘了這樣做的時候？

222
00:11:16,200 --> 00:11:20,230
什麼是缺少這個時間呢？

223
00:11:20,230 --> 00:11:23,600
我有我的#include，
所以我有機會對printf。

224
00:11:23,600 --> 00:11:26,090
>> 但我沒有
訪問只是還沒有？

225
00:11:26,090 --> 00:11:29,420
那麼，同上次一樣，
我需要告訴編譯器

226
00:11:29,420 --> 00:11:31,691
鐺一下這些功能。

227
00:11:31,691 --> 00:11:33,940
Get_string不來
與C並且特別地，它

228
00:11:33,940 --> 00:11:38,160
不來的
頭文件。

229
00:11:38,160 --> 00:11:40,770
相反，它進來
一些工作人員寫的，

230
00:11:40,770 --> 00:11:44,176
這是一個不同的文件
名字，但恰當地命名。

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> 所以，簡單地通過添加一行
從最後一次代碼 - 召回

233
00:11:50,861 --> 00:11:53,610
這鐺運行時，它會
來看看我的代碼從上到下，

234
00:11:53,610 --> 00:11:54,193
左到右。

235
00:11:54,193 --> 00:11:57,200
這將注意到，
哦，你想要的。

236
00:11:57,200 --> 00:11:59,900
讓我去發現，
無論它是在服務器上，

237
00:11:59,900 --> 00:12:03,090
複製和粘貼，從本質上講，
進入自己的文件的頂部

238
00:12:03,090 --> 00:12:06,820
以便在該故事這一點上，
線1中，程序的其餘部分

239
00:12:06,820 --> 00:12:11,651
可事實上，使用任何功能
在其中，其中get_string。

240
00:12:11,651 --> 00:12:13,650
所以我要忽視
這些錯誤的其餘部分，

241
00:12:13,650 --> 00:12:17,190
因為我確實懷疑，只有
第一個真正重要的。

242
00:12:17,190 --> 00:12:20,780
而且我要繼續前進並重新運行，
救了我的文件後作出buggy1。

243
00:12:20,780 --> 00:12:22,580
瞧，它的工作。

244
00:12:22,580 --> 00:12:29,200
而且，如果我做./buggy1和類型，為
例如，Zamyla，我現在會打招呼，

245
00:12:29,200 --> 00:12:32,000
Zamyla，而不是你好，世界。

246
00:12:32,000 --> 00:12:32,550
>> 好吧。

247
00:12:32,550 --> 00:12:35,890
因此，這裡的外賣店則是，
之一，盡量收集盡可能多的，你可以

248
00:12:35,890 --> 00:12:39,140
單從錯誤信息，尋找
在一些可識別的話。

249
00:12:39,140 --> 00:12:43,070
除了上述，使用每個help50
問題設置規範。

250
00:12:43,070 --> 00:12:46,500
但除此之外，也總是期待
在最嚴重的錯誤只，至少

251
00:12:46,500 --> 00:12:50,051
首先，看什麼信息
它實際上可能屈服。

252
00:12:50,051 --> 00:12:52,300
但事實證明，那裡的
甚至更多的功能內置

253
00:12:52,300 --> 00:12:55,030
進入CS50庫幫助
您在學期初上

254
00:12:55,030 --> 00:12:57,580
而早在節目
找出什麼地方出了錯。

255
00:12:57,580 --> 00:12:59,840
所以，讓我們做一個例子在這裡。

256
00:12:59,840 --> 00:13:04,350
我打算把這個buggy2，其中，
再次，將被有缺陷的出

257
00:13:04,350 --> 00:13:05,650
門口，由設計。

258
00:13:05,650 --> 00:13:09,980
>> 而且我要繼續前進
做的#include。

259
00:13:09,980 --> 00:13:12,580
然後我要做的主要INT（無效）。

260
00:13:12,580 --> 00:13:14,840
然後我會為循環做。

261
00:13:14,840 --> 00:13:16,690
對於（INT I _ 0。

262
00:13:16,690 --> 00:13:18,750
i小於或等於10。

263
00:13:18,750 --> 00:13:24,260
我++，然後在大括號，我要去
在這裡打印出來只是一種標籤符號

264
00:13:24,260 --> 00:13:25,920
和一個新行字符。

265
00:13:25,920 --> 00:13:29,220
>> 所以，我的意圖與此
程序是很簡單

266
00:13:29,220 --> 00:13:33,150
迭代10次
並在每個迭代

267
00:13:33,150 --> 00:13:35,260
每一次循環
通過循環，

268
00:13:35,260 --> 00:13:37,660
打印出井號標籤，
＃標籤，＃標籤。

269
00:13:37,660 --> 00:13:40,480
每行一個，因為我
有新的行那裡。

270
00:13:40,480 --> 00:13:42,787
並回顧，對
循環，每最後week--

271
00:13:42,787 --> 00:13:44,620
你會得到更多的
熟悉的語法

272
00:13:44,620 --> 00:13:47,170
通過使用它與實踐
long--前，這給了我

273
00:13:47,170 --> 00:13:49,740
一個變量叫我並將其設置為0。

274
00:13:49,740 --> 00:13:52,650
>> 這增加我對
每次迭代1。

275
00:13:52,650 --> 00:13:54,940
所以我變為1到2到3。

276
00:13:54,940 --> 00:13:57,690
然後該條件在
分號之間的中間

277
00:13:57,690 --> 00:14:03,010
被檢查的每一次迭代，使
確保我們仍然在範圍內。

278
00:14:03,010 --> 00:14:06,830
所以我想重複10次，所以我
有那種非常直觀地只是

279
00:14:06,830 --> 00:14:09,070
把10作為我的上限那裡。

280
00:14:09,070 --> 00:14:14,310
>> 然而，之後當我運行這一點，
用make編譯它buggy2--

281
00:14:14,310 --> 00:14:15,440
它並編譯確定。

282
00:14:15,440 --> 00:14:17,980
所以，我沒有
語法錯誤這一次。

283
00:14:17,980 --> 00:14:20,940
現在讓我繼續前進
並運行buggy2，回車。

284
00:14:20,940 --> 00:14:22,620
現在向上滾動。

285
00:14:22,620 --> 00:14:24,890
讓我增加
窗口的大小。

286
00:14:24,890 --> 00:14:33,720
>> 我似乎有1，2，3，
4，5，6，7，8，9，10，11。

287
00:14:33,720 --> 00:14:38,891
因此，有11＃標籤，即使
我明確提出10這個循環中。

288
00:14:38,891 --> 00:14:42,140
現在，有些人可能會立即看到
什麼錯誤是因為，實際上，這

289
00:14:42,140 --> 00:14:43,720
是不是一個很嚴重的錯誤，使。

290
00:14:43,720 --> 00:14:46,070
但它是非常普遍
在做很早。

291
00:14:46,070 --> 00:14:49,820
>> 我想指出的是，雖然，
是的，我怎麼可能算出這個？

292
00:14:49,820 --> 00:14:52,300
那麼，事實證明，
在CS50庫來

293
00:14:52,300 --> 00:14:55,380
不僅get_string和get_int
和get_float等功能。

294
00:14:55,380 --> 00:14:59,980
它還配備了一個特殊功能
所謂EPRINTF，或者錯誤的printf。

295
00:14:59,980 --> 00:15:03,270
它只是存在，使
它為您輕鬆一點點

296
00:15:03,270 --> 00:15:06,310
調試代碼，只是當
在屏幕上顯示一條錯誤消息

297
00:15:06,310 --> 00:15:07,850
並知道它是從哪裡來的。

298
00:15:07,850 --> 00:15:11,000
>> 因此，舉例來說，有一件事我可能
在這裡做的這個功能是this--

299
00:15:11,000 --> 00:15:20,230
EPRINTF，然後我要繼續前進
並說現在我是％I，反斜線，正。

300
00:15:20,230 --> 00:15:22,330
而且我要在我的價值堵塞。

301
00:15:22,330 --> 00:15:25,400
而向上頂，因為這
是CS50庫中，

302
00:15:25,400 --> 00:15:27,580
我要繼續前進
並包括

303
00:15:27,580 --> 00:15:29,169
所以我有機會獲得這一功能。

304
00:15:29,169 --> 00:15:31,460
但是，讓我們考慮一下線
9應該做的事情。

305
00:15:31,460 --> 00:15:32,670
我將最終刪除。

306
00:15:32,670 --> 00:15:34,670
這無關
我的首要目標。

307
00:15:34,670 --> 00:15:39,090
但是EPRINTF，錯誤的printf，只是意思
給我一些診斷信息。

308
00:15:39,090 --> 00:15:42,460
當我運行我的程序，我想
看到這個屏幕上暫時

309
00:15:42,460 --> 00:15:44,550
也僅僅理解
這是怎麼回事。

310
00:15:44,550 --> 00:15:47,330
>> 而且，事實上，在每個
這裡的迭代9號線

311
00:15:47,330 --> 00:15:49,260
我想看看，什麼是我的價值？

312
00:15:49,260 --> 00:15:50,290
什麼是我的價值？

313
00:15:50,290 --> 00:15:51,280
什麼是我的價值？

314
00:15:51,280 --> 00:15:55,650
並希望，我應該只
看到該消息，另外，10次。

315
00:15:55,650 --> 00:15:57,780
>> 因此，讓我繼續前進，
重新編譯我的程序，

316
00:15:57,780 --> 00:15:59,905
因為我做任何時間
我做出改變。 ./buggy2。

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
和now--確定。

319
00:16:03,640 --> 00:16:04,820
還有很多更多的事情。

320
00:16:04,820 --> 00:16:07,610
因此，讓我在向上滾動
一個更大的窗口。

321
00:16:07,610 --> 00:16:10,190
>> 你會看到，每個
該主題標籤仍然打印。

322
00:16:10,190 --> 00:16:15,270
但是，在與他們每個人是現在這個
診斷輸出格式如下。

323
00:16:15,270 --> 00:16:17,960
在這裡我的程序的名稱是buggy2。

324
00:16:17,960 --> 00:16:20,432
該文件的名稱是buggy2.c。

325
00:16:20,432 --> 00:16:24,080
行號從其中
此印為9號線。

326
00:16:24,080 --> 00:16:27,500
然後那右邊的是
我很期待的錯誤消息。

327
00:16:27,500 --> 00:16:30,701
>> 什麼是很好的關於這就是
現在我不必一定算

328
00:16:30,701 --> 00:16:32,200
在我的腦袋就是我的程序在做什麼。

329
00:16:32,200 --> 00:16:34,240
我可以看到，在
第一次迭代i是0，

330
00:16:34,240 --> 00:16:39,420
然後1，然後2，然後3，然後是4，那麼
5，然後6，則如圖7所示，然後如圖8所示，然後如圖9所示，然後

331
00:16:39,420 --> 00:16:40,980
10。

332
00:16:40,980 --> 00:16:42,050
所以等一下。

333
00:16:42,050 --> 00:16:43,740
這裡發生了什麼？

334
00:16:43,740 --> 00:16:48,190
我似乎仍然計數
如預期可達10。

335
00:16:48,190 --> 00:16:50,550
>> 但是，在沒有開始呢？

336
00:16:50,550 --> 00:16:53,240
0，1，2，3，4，5，6，7，8，9 10。

337
00:16:53,240 --> 00:16:58,040
因此0，1，2，3，4，5，6，7，
8，9，10--第11手指

338
00:16:58,040 --> 00:16:59,990
指示的問題。

339
00:16:59,990 --> 00:17:02,850
我似乎已經算
錯誤在我的循環。

340
00:17:02,850 --> 00:17:06,599
而不是去10次迭代，
我從0開始，

341
00:17:06,599 --> 00:17:09,550
我在，並通過10結束。

342
00:17:09,550 --> 00:17:12,030
但因為，像計算機，
我從0開始計數，

343
00:17:12,030 --> 00:17:15,250
我應該計數
到，但不通過，10。

344
00:17:15,250 --> 00:17:18,510
>> 這樣一來，修復，最終我
在這裡實現的，是兩件事情之一。

345
00:17:18,510 --> 00:17:22,430
我很可能簡單地說
數到小於10。

346
00:17:22,430 --> 00:17:27,260
因此0，1，2，3，4，5，6，7，8，
9，這的確是正確的，

347
00:17:27,260 --> 00:17:28,900
儘管這聽起來有點不對勁。

348
00:17:28,900 --> 00:17:35,070
或者，我可以做到小於或等於
9，只要我從0開始。

349
00:17:35,070 --> 00:17:40,056
或者，如果你真的不喜歡，你
可以計數到10，但是從1開始。

350
00:17:40,056 --> 00:17:41,680
但同樣，這恰恰是並不常見。

351
00:17:41,680 --> 00:17:43,977
在programming--儘管
與其說是在Scratch--

352
00:17:43,977 --> 00:17:45,810
但在編程
C和其他語言，

353
00:17:45,810 --> 00:17:47,670
如JavaScript和
Python和其他人，這是

354
00:17:47,670 --> 00:17:49,880
只是很常見的
我們的二元討論

355
00:17:49,880 --> 00:17:53,450
剛開始點票
最低的數字就可以了，這是0。

356
00:17:53,450 --> 00:17:53,950
好吧。

357
00:17:53,950 --> 00:17:55,160
所以這是EPRINTF。

358
00:17:55,160 --> 00:17:58,600
再次，現在我已經想通了我
的問題，我要回去0

359
00:17:58,600 --> 00:18:01,470
經過不到10，我要去
去和刪除EPRINTF。

360
00:18:01,470 --> 00:18:04,580
>> 它不應該，當我在那裡
我的船代碼或提交我的代碼

361
00:18:04,580 --> 00:18:05,800
或展示給其他人。

362
00:18:05,800 --> 00:18:07,980
它實際上只是意味著
要暫時使用。

363
00:18:07,980 --> 00:18:11,650
但現在我已經解決了這個問題
特別的問題也是如此。

364
00:18:11,650 --> 00:18:16,780
>> 好吧，讓我們做一個例子在這裡
我要去掀起如下。

365
00:18:16,780 --> 00:18:22,850
我要繼續前進，
的#include。 $ 50個

366
00:18:22,850 --> 00:18:25,580
而且我要繼續前進
和的#i​​nclude。

367
00:18:25,580 --> 00:18:29,030
>> 而且我要救
此文件buggy3.c。

368
00:18:29,030 --> 00:18:31,740
而且我要繼續前進
並宣布INT主要（無效）。

369
00:18:31,740 --> 00:18:34,186
然後裡面有
我該怎麼辦INT I _  - 

370
00:18:34,186 --> 00:18:36,435
我想要實現一個程序
用get_negative_int。

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
這是不存在又一個函數。

373
00:18:40,770 --> 00:18:42,870
因此，我們要實現
它在短短的時刻。

374
00:18:42,870 --> 00:18:45,541
但是，我們要明白為什麼
它在第一輪馬車。

375
00:18:45,541 --> 00:18:47,290
一旦我已經得到
來自用戶的INT，

376
00:18:47,290 --> 00:18:53,365
我只是要打印％我是一個負
整數，反斜線，正，逗號，我。

377
00:18:53,365 --> 00:18:55,240
換言之，所有我
希望這個程序做

378
00:18:55,240 --> 00:18:58,000
是從一個負INT
用戶，然後打印出

379
00:18:58,000 --> 00:18:59,980
某某是負中間體

380
00:18:59,980 --> 00:19:02,080
>> 現在我需要實現這個功能。

381
00:19:02,080 --> 00:19:05,740
所以在我的文件後，我要去
提前並聲明調用的函數

382
00:19:05,740 --> 00:19:10,670
get_negative_int（無效） - 我們將
回過頭來什麼該行又指

383
00:19:10,670 --> 00:19:18,790
在moment-- INT N;渡渡鳥
在fo​​llowing-- printf的n是：。

384
00:19:18,790 --> 00:19:26,210
然後我要做的N  -  get_int，
和為此而n是大於0。

385
00:19:26,210 --> 00:19:28,310
然後返回否;.

386
00:19:28,310 --> 00:19:31,730
>> 因此，有很多事情
這一點，但沒有一個我們沒有

387
00:19:31,730 --> 00:19:33,710
看看上週，至少簡要介紹。

388
00:19:33,710 --> 00:19:36,980
於是就在這裡10行，我宣布
函數調用get_negative_int，

389
00:19:36,980 --> 00:19:39,620
我已經把（無效），在
括號，原因是這

390
00:19:39,620 --> 00:19:40,950
不採取一個輸入。

391
00:19:40,950 --> 00:19:42,910
我不傳遞任何
此功能。

392
00:19:42,910 --> 00:19:44,690
我剛開始從東西回來。

393
00:19:44,690 --> 00:19:47,270
>> 而我很希望
回來是整數。

394
00:19:47,270 --> 00:19:50,040
有在任何數據類型
Ç稱為negative_int。

395
00:19:50,040 --> 00:19:52,880
這只是詮釋，所以這是怎麼回事
要對我們確保

396
00:19:52,880 --> 00:19:55,340
這實際上就​​是價值
返回的不僅是一個int

397
00:19:55,340 --> 00:19:56,380
但也為負。

398
00:19:56,380 --> 00:20:02,150
>> 第12行，我聲明一個變量
所謂n和使其int類型的。

399
00:20:02,150 --> 00:20:07,500
然後在第13行至18，我
做一些事情，而事情是真實的。

400
00:20:07,500 --> 00:20:11,040
我會繼續和印刷
N是，結腸，然後一個空間，

401
00:20:11,040 --> 00:20:12,800
像對用戶的提示。

402
00:20:12,800 --> 00:20:16,410
>> 然後我打電話get_int和
存儲其所謂的返回值

403
00:20:16,410 --> 00:20:18,130
在變量n。

404
00:20:18,130 --> 00:20:22,600
但我會繼續做
此而n是大於0。

405
00:20:22,600 --> 00:20:27,960
換句話說，如果用戶給我一個
int和該數量是大於0，

406
00:20:27,960 --> 00:20:31,180
ERGO的，積極的，我要去
只是不停的再次提示用戶，

407
00:20:31,180 --> 00:20:37,160
守時再次提示，以迫使他們到
合作，並給我一個負int值。

408
00:20:37,160 --> 00:20:41,640
>> 而一旦n是實際negative--
假設用戶終於類型-50，

409
00:20:41,640 --> 00:20:46,710
那麼這個while循環不再是真實的
因為-50不大於0。

410
00:20:46,710 --> 00:20:51,140
所以我們擺脫了
循環邏輯和返回否。

411
00:20:51,140 --> 00:20:53,520
>> 但是有一個其他
事情我必須做的。

412
00:20:53,520 --> 00:20:56,190
我可以簡單地這樣做
通過複製和粘貼

413
00:20:56,190 --> 00:20:58,540
在該文件的頂部的一行代碼。

414
00:20:58,540 --> 00:21:01,630
我需要教鐺，
或承諾鐺，

415
00:21:01,630 --> 00:21:04,630
明確地說我會的，
的確，去實現

416
00:21:04,630 --> 00:21:06,020
此功能get_negative_int。

417
00:21:06,020 --> 00:21:07,674
它可能只是文件中的低。

418
00:21:07,674 --> 00:21:09,840
再次，記得鏘
讀取事情從上到下，

419
00:21:09,840 --> 00:21:12,330
左到右，所以你不能
如果調用鏘功能

420
00:21:12,330 --> 00:21:15,330
不知道它會存在。

421
00:21:15,330 --> 00:21:18,430
>> 現在，不幸的是，這個程序，
因為有些人可能已經注意到了，

422
00:21:18,430 --> 00:21:19,590
已經是馬車。

423
00:21:19,590 --> 00:21:21,400
讓我繼續前進，使buggy3。

424
00:21:21,400 --> 00:21:26,904
它編譯，所以我現在的問題是不
語法錯誤，如文字錯誤，

425
00:21:26,904 --> 00:21:29,570
它實際上將是一個邏輯
錯誤，我已經刻意

426
00:21:29,570 --> 00:21:32,450
製成為契機
步是怎麼回事。

427
00:21:32,450 --> 00:21:35,540
>> 我要繼續前進
現在運行buggy3。

428
00:21:35,540 --> 00:21:37,490
我要去
未來，而不是合作。

429
00:21:37,490 --> 00:21:39,494
我要去給它1號。

430
00:21:39,494 --> 00:21:41,410
它不喜歡它，所以
它再次提示我。

431
00:21:41,410 --> 00:21:42,147
>> 2點怎麼樣？

432
00:21:42,147 --> 00:21:43,021
3？

433
00:21:43,021 --> 00:21:43,520
50？

434
00:21:43,520 --> 00:21:44,740
這些都不是工作。

435
00:21:44,740 --> 00:21:46,890
如何-50？

436
00:21:46,890 --> 00:21:48,560
和節目似乎工作。

437
00:21:48,560 --> 00:21:49,970
>> 讓我嘗試一次。

438
00:21:49,970 --> 00:21:53,400
讓我試試-1，似乎工作。

439
00:21:53,400 --> 00:21:56,380
讓我嘗試-2，似乎工作。

440
00:21:56,380 --> 00:21:59,640
讓我試試0。

441
00:21:59,640 --> 00:22:01,684
呵呵，這是不正確。

442
00:22:01,684 --> 00:22:03,350
現在，我們是一個小迂腐在這裡。

443
00:22:03,350 --> 00:22:07,090
但它確實的情況下滿足0
既不積極也不消極。

444
00:22:07,090 --> 00:22:11,150
這樣一來，事實證明我的計劃是
說0是負整數，

445
00:22:11,150 --> 00:22:12,820
這不是技術上是正確的。

446
00:22:12,820 --> 00:22:15,180
>> 現在，它為什麼這樣做呢？

447
00:22:15,180 --> 00:22:16,270
嗯，這可能是顯而易見的。

448
00:22:16,270 --> 00:22:18,110
而且，事實上，程序
意味著是相當簡單的

449
00:22:18,110 --> 00:22:19,670
所以我們有一些探索。

450
00:22:19,670 --> 00:22:25,870
>> 但是，讓我們引進第三調試
技術這裡叫做debug50。

451
00:22:25,870 --> 00:22:27,750
因此，這是一個程序
我們剛剛創建

452
00:22:27,750 --> 00:22:30,770
今年被稱為debug50
這將允許您

453
00:22:30,770 --> 00:22:34,130
使用什麼叫做內置
圖形化調試器在CS50 IDE。

454
00:22:34,130 --> 00:22:38,400
和調試器只是一個程序，
通常，您可以運行程序

455
00:22:38,400 --> 00:22:44,050
但一步一步一個腳印，行
由一行行，暫停，戳

456
00:22:44,050 --> 00:22:47,626
四周，看著變量，這樣
程序不只是吹過去，你

457
00:22:47,626 --> 00:22:49,750
和快速打印的東西
或不打印的東西。

458
00:22:49,750 --> 00:22:53,250
它給你一個機會，在
人類的速度，與它進行交互。

459
00:22:53,250 --> 00:22:55,470
>> 而要做到這一點，你
只需做到以下幾點。

460
00:22:55,470 --> 00:22:58,479
編譯代碼後，
我已經做了，buggy3，

461
00:22:58,479 --> 00:23:00,020
你繼續運行debug50 ./buggy。

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
那麼像help50有運行
help50然後命令，

464
00:23:06,760 --> 00:23:10,120
debug50有運行debug50和
然後命令的名稱。

465
00:23:10,120 --> 00:23:14,440
>> 現在看我的屏幕上會發生什麼，
上，特別是右側。

466
00:23:14,440 --> 00:23:19,400
當我打運行，所有的
這突如其來的右側面板

467
00:23:19,400 --> 00:23:20,419
在屏幕上打開。

468
00:23:20,419 --> 00:23:22,210
而且還有很多要去
在乍看之下。

469
00:23:22,210 --> 00:23:25,110
但是，也不是太
什麼可擔心的呢。

470
00:23:25,110 --> 00:23:28,570
>> 這正顯示出我的一切
這是怎麼回事我的計劃內

471
00:23:28,570 --> 00:23:31,130
現在和通過這些
按鈕向上頂然後

472
00:23:31,130 --> 00:23:35,910
讓我步我的代碼
最終一步一步一步。

473
00:23:35,910 --> 00:23:37,140
但不是現在。

474
00:23:37,140 --> 00:23:38,060
注意會發生什麼。

475
00:23:38,060 --> 00:23:40,600
在我的終端窗口
我被提示n個。

476
00:23:40,600 --> 00:23:44,560
而且我要繼續前進，
這種合作的時間和類型-1。

477
00:23:44,560 --> 00:23:48,770
雖然和一點點隱晦，-1
是一個負整數，符合市場預期。

478
00:23:48,770 --> 00:23:52,020
>> 然後孩子退出，
狀態0 GDBSERVER退出。

479
00:23:52,020 --> 00:23:55,180
GDB，GNU調試器，是名
底層軟件的

480
00:23:55,180 --> 00:23:56,620
實現這個調試器。

481
00:23:56,620 --> 00:24:00,500
但是這一切的真正含義，調試器
臨走的時候，因為我的程序退出

482
00:24:00,500 --> 00:24:01,710
和一切都很好。

483
00:24:01,710 --> 00:24:06,020
如果我想真正的調試我的程序，
我要告訴先發製人debug50，

484
00:24:06,020 --> 00:24:08,920
在哪裡我要開始
通過我的代碼加強？

485
00:24:08,920 --> 00:24:11,750
>> 也許最簡單的方法
要做到這一點是如下。

486
00:24:11,750 --> 00:24:15,300
如果我將鼠標懸停在
我的編輯的排水溝在這裡，

487
00:24:15,300 --> 00:24:19,090
所以真的只是這裡的側邊欄，
到行號的左側，

488
00:24:19,090 --> 00:24:21,870
請注意，如果我只是點擊
有一次，我把一個小紅點。

489
00:24:21,870 --> 00:24:24,460
這小紅點，
就像停止的跡象，這意味著，哎，

490
00:24:24,460 --> 00:24:29,430
debug50，我的代碼暫停執行
在那裡，當我運行這個程序。

491
00:24:29,430 --> 00:24:30,260
>> 因此，讓我們做到這一點。

492
00:24:30,260 --> 00:24:37,340
讓我繼續前進，運行我的程序
再次debug50 ./buggy3，回車。

493
00:24:37,340 --> 00:24:40,110
而現在，通知，東西
不同的事情發生了。

494
00:24:40,110 --> 00:24:42,440
我沒有被提示
但在我的終端窗口

495
00:24:42,440 --> 00:24:45,430
任何東西，因為我還沒有
在我的計劃變得那裡。

496
00:24:45,430 --> 00:24:47,950
請注意，在第8行
這是現在突出，

497
00:24:47,950 --> 00:24:51,720
並有一個小箭頭
左說，你是在這裡暫停。

498
00:24:51,720 --> 00:24:55,030
這行代碼，行
8，尚未執行。

499
00:24:55,030 --> 00:24:58,940
>> 這有什麼奇怪的，如果我期待
在這裡的右手邊，

500
00:24:58,940 --> 00:25:03,530
請注意，我是一個局部
可變的，在這個意義上本地

501
00:25:03,530 --> 00:25:05,450
這是當前函數內。

502
00:25:05,450 --> 00:25:08,920
和它的價值，顯然是在默認情況下，
和排序的便利，為0。

503
00:25:08,920 --> 00:25:10,260
但我沒有輸入0。

504
00:25:10,260 --> 00:25:13,410
這恰好是它的
此刻默認值。

505
00:25:13,410 --> 00:25:15,490
>> 因此，讓我繼續前進，現在做到這一點。

506
00:25:15,490 --> 00:25:18,680
讓我繼續前進，在
右上方這裡，我

507
00:25:18,680 --> 00:25:20,970
要繼續前進，
點擊這個第一個圖標其中

508
00:25:20,970 --> 00:25:25,360
指步過這意味著不要跳過
，但跨過這行代碼，

509
00:25:25,360 --> 00:25:27,770
執行它沿途。

510
00:25:27,770 --> 00:25:30,710
>> 現在，請注意，我
提示剛剛更改。

511
00:25:30,710 --> 00:25:31,380
這是為什麼？

512
00:25:31,380 --> 00:25:33,639
我告訴debug50，
運行此行代碼。

513
00:25:33,639 --> 00:25:34,930
這是什麼行代碼呢？

514
00:25:34,930 --> 00:25:35,960
提示我要一個int。

515
00:25:35,960 --> 00:25:36,460
好。

516
00:25:36,460 --> 00:25:37,400
讓我合作。

517
00:25:37,400 --> 00:25:41,340
現在讓我繼續前進，並鍵入-1，回車。

518
00:25:41,340 --> 00:25:42,920
而現在發現了什麼變化。

519
00:25:42,920 --> 00:25:46,060
在右手側，
我的本地變量i

520
00:25:46,060 --> 00:25:48,200
被指示為-1現在。

521
00:25:48,200 --> 00:25:49,810
而且它是int類型仍然。

522
00:25:49,810 --> 00:25:53,102
>> 和通知，也我所謂的
調用堆棧，在哪裡我停下？

523
00:25:53,102 --> 00:25:54,810
我們將詳細討論
這在未來。

524
00:25:54,810 --> 00:25:58,620
但調用堆棧只是指的是什麼
功能是當前在運動。

525
00:25:58,620 --> 00:26:00,040
現在，它只是主力。

526
00:26:00,040 --> 00:26:03,590
而現在唯一的地方
變量為i為1的值。

527
00:26:03,590 --> 00:26:09,840
>> 而當我終於跨過這條線
在這裡，與右上角的圖標相同，

528
00:26:09,840 --> 00:26:11,410
-1是一個負整數。

529
00:26:11,410 --> 00:26:13,580
現在，它在暫停的花括號。

530
00:26:13,580 --> 00:26:14,740
讓我們讓它做它的事。

531
00:26:14,740 --> 00:26:17,300
我跨過這道線，瞧。

532
00:26:17,300 --> 00:26:20,240
>> 所以，不是所有的可怕
啟發然而，

533
00:26:20,240 --> 00:26:23,550
但它確實讓我暫停
並認為通過邏輯

534
00:26:23,550 --> 00:26:24,870
這是什麼程序在做什麼。

535
00:26:24,870 --> 00:26:26,890
但是，這不是錯誤的情況。

536
00:26:26,890 --> 00:26:28,510
讓我們再次做到這一點如下。

537
00:26:28,510 --> 00:26:31,340
>> 我要離開這個斷點
上與紅色點線8。

538
00:26:31,340 --> 00:26:32,830
我要重新運行debug50。

539
00:26:32,830 --> 00:26:34,400
它會自動暫停在這裡。

540
00:26:34,400 --> 00:26:37,660
但這一次，而不是
跨過這條線，

541
00:26:37,660 --> 00:26:42,290
讓我真正去裡面
get_negative_int並找出，

542
00:26:42,290 --> 00:26:45,530
為什麼它接受0作為一個有效的答案？

543
00:26:45,530 --> 00:26:47,990
>> 因此，而不是點擊步過。

544
00:26:47,990 --> 00:26:50,630
我要繼續前進
單擊單步執行。

545
00:26:50,630 --> 00:26:54,030
並注意8號線這
現在現在突然突出

546
00:26:54,030 --> 00:26:56,900
變成17行。

547
00:26:56,900 --> 00:26:59,947
>> 現在，它不是調試器
已經跳過管線14和15和16。

548
00:26:59,947 --> 00:27:01,780
它只是沒有什麼
給你看那裡。

549
00:27:01,780 --> 00:27:04,050
那些只是聲明變量，
再有就是這個詞做

550
00:27:04,050 --> 00:27:05,390
然後一個開放的花括號。

551
00:27:05,390 --> 00:27:09,227
唯一的功能線這
多汁真的是這樣一個在這裡，17。

552
00:27:09,227 --> 00:27:11,060
而這也正是我們所
自動暫停。

553
00:27:11,060 --> 00:27:13,870
>> 所以輸出（“n.is：”）;,這樣
這還沒有發生。

554
00:27:13,870 --> 00:27:18,250
因此，讓我們繼續前進，並單擊步過。

555
00:27:18,250 --> 00:27:20,326
現在我的提示，的確，
變更為（「n為：“）。

556
00:27:20,326 --> 00:27:22,450
現在get_int，我不會去
打擾踏入，

557
00:27:22,450 --> 00:27:24,750
因為該功能是
對圖書館在CS50的。

558
00:27:24,750 --> 00:27:25,750
這大概是正確的。

559
00:27:25,750 --> 00:27:28,440
>> 所以我要繼續前進，
那種通過給予合作

560
00:27:28,440 --> 00:27:30,590
int，但不是消極的int值。

561
00:27:30,590 --> 00:27:32,870
因此，讓我繼續前進，命中0。

562
00:27:32,870 --> 00:27:39,460
現在，這裡是什麼情況
當我得到了第21行？

563
00:27:39,460 --> 00:27:40,890
我不會再重複。

564
00:27:40,890 --> 00:27:43,320
我似乎並沒有停留在這個循環。

565
00:27:43,320 --> 00:27:45,990
換句話說，這種黃色
酒吧沒有保住繞來繞去，

566
00:27:45,990 --> 00:27:47,130
又一圈，又一圈。

567
00:27:47,130 --> 00:27:48,340
>> 現在，這是為什麼？

568
00:27:48,340 --> 00:27:49,920
好了，正，什麼是現在N'

569
00:27:49,920 --> 00:27:53,280
我可以看看當地
在調試器變量。

570
00:27:53,280 --> 00:27:53,816
n為0。

571
00:27:53,816 --> 00:27:55,190
好吧，什麼是我的條件？

572
00:27:55,190 --> 00:27:58,700
>> 20--線20，好了，
0是大於0。

573
00:27:58,700 --> 00:27:59,500
這是不正確的。

574
00:27:59,500 --> 00:28:01,020
0不大於0。

575
00:28:01,020 --> 00:28:02,820
所以，我打破了這一點。

576
00:28:02,820 --> 00:28:06,370
>> 所以這就是為什麼上線
21，如果我真的繼續下去，

577
00:28:06,370 --> 00:28:10,370
我將返​​回0，即使
雖然我應該拒絕0

578
00:28:10,370 --> 00:28:12,484
因為實際上沒有被否定。

579
00:28:12,484 --> 00:28:14,650
所以，現在，我真的不連
關心的調試器。

580
00:28:14,650 --> 00:28:16,900
得到它，我不需要
了解更多的是怎麼回事。

581
00:28:16,900 --> 00:28:19,233
>> 所以我要繼續前進，
只需點擊播放按鈕，

582
00:28:19,233 --> 00:28:20,240
而讓這完成了。

583
00:28:20,240 --> 00:28:23,440
現在，我已經意識到我
錯誤顯然是在第20行。

584
00:28:23,440 --> 00:28:25,160
這是我的邏輯錯誤。

585
00:28:25,160 --> 00:28:28,100
>> 所以我想要什麼
做改變呢？

586
00:28:28,100 --> 00:28:32,500
如果問題是，我不
醒目0，它只是一個邏輯上的錯誤。

587
00:28:32,500 --> 00:28:35,910
我可以說，當n為
大於或等於0，

588
00:28:35,910 --> 00:28:38,330
保持一再提示用戶。

589
00:28:38,330 --> 00:28:41,050
>> 所以，再次，簡單的錯誤，也許
當你看到我，即使明顯

590
00:28:41,050 --> 00:28:42,410
寫只需幾分鐘前。

591
00:28:42,410 --> 00:28:44,570
但這裡的外賣
是，與調試50，

592
00:28:44,570 --> 00:28:46,850
與調試
軟件更一般地，

593
00:28:46,850 --> 00:28:51,370
你有這個新發現的力量
通過你自己的代碼走走，看看

594
00:28:51,370 --> 00:28:55,590
通過該右側面板是什麼
您的變量值。

595
00:28:55,590 --> 00:28:57,700
所以，你不一定
要使用的東西

596
00:28:57,700 --> 00:29:00,630
像你EPRINTF打印這些值。

597
00:29:00,630 --> 00:29:04,430
實際上，你可以看到他們
肉眼在屏幕上。

598
00:29:04,430 --> 00:29:08,920
>> 現在，除此之外，值得注意的
這還有另一種技術，它是

599
00:29:08,920 --> 00:29:09,890
其實超級常見。

600
00:29:09,890 --> 00:29:13,120
你可能想知道為什麼這個小
這裡的傢伙一直坐在台上。

601
00:29:13,120 --> 00:29:16,490
因此，有這樣的技術，一般
被稱為橡皮鴨調試，

602
00:29:16,490 --> 00:29:18,786
這真的只是一個
證明的事實

603
00:29:18,786 --> 00:29:20,660
經常當程序員
正在編寫代碼，

604
00:29:20,660 --> 00:29:22,650
他們不一定
與他人合作，

605
00:29:22,650 --> 00:29:24,030
或在共享的環境中工作。

606
00:29:24,030 --> 00:29:25,050
>> 他們在家裡是那種。

607
00:29:25,050 --> 00:29:25,910
也許這是在深夜。

608
00:29:25,910 --> 00:29:28,190
他們試圖圖
出在他們的代碼的一些bug。

609
00:29:28,190 --> 00:29:29,330
而他們只是沒有看到它。

610
00:29:29,330 --> 00:29:30,329
>> 而且也沒有室友。

611
00:29:30,329 --> 00:29:31,250
沒有的TF。

612
00:29:31,250 --> 00:29:32,680
周圍沒有CA。

613
00:29:32,680 --> 00:29:36,440
所有他們有他們的貨架上
就是這個小橡皮鴨。

614
00:29:36,440 --> 00:29:39,030
>> 所以橡皮鴨調試
只是這個邀請

615
00:29:39,030 --> 00:29:42,780
想愚蠢的東西
因為這是一個真正的生物，

616
00:29:42,780 --> 00:29:46,940
實際上走過你的代碼
口頭本無生命的物體。

617
00:29:46,940 --> 00:29:49,230
因此，例如，如果
這是我的例子這裡 - 

618
00:29:49,230 --> 00:29:52,470
而回顧過去，
問題是此，

619
00:29:52,470 --> 00:29:58,140
如果我刪除這個代碼的第一行，
我繼續前進並再次馬車0，

620
00:29:58,140 --> 00:30:01,220
記得我有這些
這裡的錯誤消息。

621
00:30:01,220 --> 00:30:05,997
這樣的想法在這裡，可笑雖然我
感覺此刻公開這樣做，

622
00:30:05,997 --> 00:30:06,580
就是錯誤。

623
00:30:06,580 --> 00:30:10,910
>> 好了，所以我的問題是，我已經
隱式聲明的庫函數。

624
00:30:10,910 --> 00:30:12,610
而該庫函數的printf。

625
00:30:12,610 --> 00:30:15,290
Declare-- OK，聲明
提醒原型的我。

626
00:30:15,290 --> 00:30:18,930
>> 這意味著我需要真正
告訴編譯器事先什麼

627
00:30:18,930 --> 00:30:19,980
該函數的模樣。

628
00:30:19,980 --> 00:30:20,930
等一下。

629
00:30:20,930 --> 00:30:23,580
我沒有標準io.h.

630
00:30:23,580 --> 00:30:24,530
非常感謝你。

631
00:30:24,530 --> 00:30:27,330
>> 因此，只要這個過程of--你
不需要居然有一隻鴨子。

632
00:30:27,330 --> 00:30:29,819
但是這種想法走
自己通過自己的代碼

633
00:30:29,819 --> 00:30:31,610
這樣你甚至可以聽到
你自己，讓你

634
00:30:31,610 --> 00:30:35,620
實現你自己的疏忽
言論，一般的想法。

635
00:30:35,620 --> 00:30:38,910
>> 而且，也許更合理，沒有那麼
多與人，但更多地參與

636
00:30:38,910 --> 00:30:44,220
例如，我們剛剛在車3.C那樣，
你可能會走自己通過它

637
00:30:44,220 --> 00:30:45,310
如下。

638
00:30:45,310 --> 00:30:49,190
這樣也好，橡膠
鴨子，DDB，如果你願意。

639
00:30:49,190 --> 00:30:52,350
在這裡，我們在我的主要功能，
我打電話讓負int值。

640
00:30:52,350 --> 00:30:54,660
>> 而我得到的返回值。

641
00:30:54,660 --> 00:31:00,410
我將其存儲在左手側
在一個變線8叫我。

642
00:31:00,410 --> 00:31:02,380
OK，而是等待，如何做
該得到的價值？

643
00:31:02,380 --> 00:31:04,130
讓我看一下功能線12。

644
00:31:04,130 --> 00:31:05,760
>> 在第12行，我們已接到負int類型。

645
00:31:05,760 --> 00:31:08,190
不帶任何投入，
並返回一個int，OK。

646
00:31:08,190 --> 00:31:10,929
我宣布第14行變量n。

647
00:31:10,929 --> 00:31:12,220
它要存儲的整數。

648
00:31:12,220 --> 00:31:13,760
這就是我想要的。

649
00:31:13,760 --> 00:31:18,480
>> 所以，做以下，而ñis--讓
我撤銷了什麼我修復已經作出。

650
00:31:18,480 --> 00:31:22,710
所以，當n大於
0，打印出n，則確定。

651
00:31:22,710 --> 00:31:25,170
然後調用INT得到存儲在n個。

652
00:31:25,170 --> 00:31:30,160
然後檢查是否n為0，
n是不是 - 它就在那裡。

653
00:31:30,160 --> 00:31:31,910
所以，再一次，你不
需要實際的鴨子。

654
00:31:31,910 --> 00:31:35,650
但只是走自己通過
你的代碼作為一種智力活動

655
00:31:35,650 --> 00:31:37,720
往往會幫你
意識到發生了什麼事情，

656
00:31:37,720 --> 00:31:41,170
而不是僅僅做一些
這樣，盯著屏幕，

657
00:31:41,170 --> 00:31:43,720
而不是說自己通過
它，這是實話不

658
00:31:43,720 --> 00:31:46,270
近作為有效的技術。

659
00:31:46,270 --> 00:31:48,620
所以你有它，一
不同的技術數

660
00:31:48,620 --> 00:31:52,102
其實對於調試代碼
和找茬，所有這一切

661
00:31:52,102 --> 00:31:54,810
應該在你的工具箱的工具
讓你不熬夜，

662
00:31:54,810 --> 00:31:57,660
尤其是，你在用餐
廳，或者在辦公時間內，

663
00:31:57,660 --> 00:32:00,368
撞你的頭靠在
牆，試圖解決一些問題。

664
00:32:00,368 --> 00:32:02,020
意識到有軟件工具。

665
00:32:02,020 --> 00:32:03,720
有橡皮鴨子的工具。

666
00:32:03,720 --> 00:32:09,630
而且還有的全體員工
支持等著伸出援助之手。

667
00:32:09,630 --> 00:32:13,120
>> 所以，現在的問題的詞
套，和以什麼我們希望您

668
00:32:13,120 --> 00:32:15,620
擺脫他們，怎麼樣
我們去評估。

669
00:32:15,620 --> 00:32:17,680
每個課程的教學大綱，
CS50的問題集

670
00:32:17,680 --> 00:32:22,320
在四個主坐標軸進行評估，因此，
到speak--範圍，正確性，設計，

671
00:32:22,320 --> 00:32:23,060
和風格。

672
00:32:23,060 --> 00:32:25,910
和範圍只是指的是多少
這塊你咬掉？

673
00:32:25,910 --> 00:32:28,080
如何太大的問題，你試過嗎？

674
00:32:28,080 --> 00:32:30,110
努力什麼級別
你表現？

675
00:32:30,110 --> 00:32:35,750
>> 正確性，確實該程序作為工作
它應該每CS50規格

676
00:32:35,750 --> 00:32:38,640
當你提供一定的投入
或某些輸出回來了嗎？

677
00:32:38,640 --> 00:32:41,130
設計是最主觀的人。

678
00:32:41,130 --> 00:32:43,360
而且它是一個將
時間最長學習

679
00:32:43,360 --> 00:32:47,220
最長任教，在
只要它歸結為，

680
00:32:47,220 --> 00:32:49,530
如何寫得好是你的代碼？

681
00:32:49,530 --> 00:32:52,920
>> 這是一件事，只是打印正確
輸出或返回正確的價值觀。

682
00:32:52,920 --> 00:32:55,400
但是你在做它作為
最有效的方式？

683
00:32:55,400 --> 00:32:58,210
你這樣做除法
與征服，或二進制

684
00:32:58,210 --> 00:33:01,500
搜索，因為我們很快就會看到，我們沒有
兩個星期前用手機書？

685
00:33:01,500 --> 00:33:04,670
有沒有更好的辦法來解決
問題比你現在有嗎？

686
00:33:04,670 --> 00:33:06,380
這對於更好的設計的機會。

687
00:33:06,380 --> 00:33:08,530
>> 然後style--如何
漂亮是你的代碼？

688
00:33:08,530 --> 00:33:12,370
你會發現，我敢
講究縮進我的代碼，

689
00:33:12,370 --> 00:33:15,300
並確保我的變量
合理地命名。 N，

690
00:33:15,300 --> 00:33:19,660
而總之，就是一個好名字
電話號碼，我為計數整數，

691
00:33:19,660 --> 00:33:20,727
S代表字符串。

692
00:33:20,727 --> 00:33:22,560
我們可以有更長
變量名風格。

693
00:33:22,560 --> 00:33:25,500
風格是多麼好
沒有你的代碼看？

694
00:33:25,500 --> 00:33:26,600
而且是怎麼讀？

695
00:33:26,600 --> 00:33:29,650
>> 隨著時間的推移，你的助教
和轉錄因子會在使用過程中做

696
00:33:29,650 --> 00:33:31,870
是為您提供與
一種定性反饋

697
00:33:31,870 --> 00:33:34,330
讓您獲得更好的
在這些不同的方面。

698
00:33:34,330 --> 00:33:37,510
而在我們如何計
評價每個這些軸，

699
00:33:37,510 --> 00:33:40,080
它通常非常少
水桶，讓你，一般來說，

700
00:33:40,080 --> 00:33:41,680
了解你正在做的有多好感。

701
00:33:41,680 --> 00:33:45,680
而且，事實上，如果你收到的分數
其中任何axes--正確性，設計

702
00:33:45,680 --> 00:33:49,659
和風格especially--這個數字
通常為1和5之間。

703
00:33:49,659 --> 00:33:52,450
而且，從字面上看，如果你得到
3公司在學期的開始，

704
00:33:52,450 --> 00:33:53,977
這是一個非常好的事情。

705
00:33:53,977 --> 00:33:55,810
這意味著仍然有
改進的餘地，

706
00:33:55,810 --> 00:33:58,490
你會希望在
服用類首次。

707
00:33:58,490 --> 00:34:01,820
有希望的天花板一些位
到你渴望深遠。

708
00:34:01,820 --> 00:34:03,970
並因此讓3對
最早的作品，

709
00:34:03,970 --> 00:34:06,550
如果不是一些2的和4的，
的確是一件好事。

710
00:34:06,550 --> 00:34:08,880
這是很有效範圍內，
在良好的預期。

711
00:34:08,880 --> 00:34:11,421
>> 如果你的心是賽車，等待
一分鐘，五分之三。

712
00:34:11,421 --> 00:34:12,620
這的確是一個6出10。

713
00:34:12,620 --> 00:34:13,560
這是60％。

714
00:34:13,560 --> 00:34:14,830
我的上帝，這是一個F.

715
00:34:14,830 --> 00:34:15,870
>> 不是。

716
00:34:15,870 --> 00:34:17,600
這不，其實這一點。

717
00:34:17,600 --> 00:34:22,710
相反，它是改善的機會
在這學期的課程。

718
00:34:22,710 --> 00:34:25,580
如果你得到一些
標準普爾，這些都是一個機會

719
00:34:25,580 --> 00:34:29,199
採取辦公時間的優勢，
當然部分和其他資源。

720
00:34:29,199 --> 00:34:32,840
>> 最好的是一個機會，真的，
是的你剛剛多遠驕傲

721
00:34:32,840 --> 00:34:34,520
過來學期的課程。

722
00:34:34,520 --> 00:34:38,199
所以一定要明白，如果沒有
否則，三是良好的。

723
00:34:38,199 --> 00:34:40,179
它允許增長空間隨著時間的推移。

724
00:34:40,179 --> 00:34:43,090
>> 至於這些軸如何
加權，實事求是你

725
00:34:43,090 --> 00:34:46,745
會花大部分的時間越來越
事情要工作，更談不上正常。

726
00:34:46,745 --> 00:34:49,120
因此正確性往往
進行加權的多數，與

727
00:34:49,120 --> 00:34:51,360
三這個乘法因素。

728
00:34:51,360 --> 00:34:54,659
設計也很重要，但
你不一定什麼

729
00:34:54,659 --> 00:34:58,220
花費所有這些小時
試圖讓事情剛參加工作。

730
00:34:58,220 --> 00:35:00,019
>> 所以，它的權重
多了幾分淡然。

731
00:35:00,019 --> 00:35:01,560
然後風格加權最少。

732
00:35:01,560 --> 00:35:03,710
儘管這是毫不遜色
重要的根本，

733
00:35:03,710 --> 00:35:05,990
它只是，也許，
最簡單的事情做對，

734
00:35:05,990 --> 00:35:08,440
模仿的例子，我們
做講座和部分，

735
00:35:08,440 --> 00:35:11,080
事情很好
縮進和評論，

736
00:35:11,080 --> 00:35:14,320
等是最簡單的中
要做的事情和得到的權利。

737
00:35:14,320 --> 00:35:16,960
從而這樣，實現
這些都是分

738
00:35:16,960 --> 00:35:19,000
是比較容易掌握。

739
00:35:19,000 --> 00:35:22,360
>> 而現在一個字上
this--學術誠信。

740
00:35:22,360 --> 00:35:25,150
所以每場的
教學大綱，你會看到

741
00:35:25,150 --> 00:35:27,630
該課程具有相當
解決此語位。

742
00:35:27,630 --> 00:35:31,380
而且課程需要的問題
學術誠信頗為重視。

743
00:35:31,380 --> 00:35:33,450
>> 我們有區別，
是好還是壞，

744
00:35:33,450 --> 00:35:36,570
具有發送的每一年
學生紀律處分

745
00:35:36,570 --> 00:35:39,670
比大多數其他任何
當然，我所知道的。

746
00:35:39,670 --> 00:35:42,580
這不一定
指示該事實

747
00:35:42,580 --> 00:35:46,340
即CS的學生，或學生CS50，是
任何低於你的同學誠實的。

748
00:35:46,340 --> 00:35:49,090
但現實的情況，在這
世界，電子，我們只是

749
00:35:49,090 --> 00:35:50,990
有技術
意味著檢測這一點。

750
00:35:50,990 --> 00:35:53,360
>> 重要的是要我們
跨類公平

751
00:35:53,360 --> 00:35:58,550
我們做這個檢測，提高
這個問題時，我們看到的東西。

752
00:35:58,550 --> 00:36:01,980
而剛剛畫一幅畫，真
幫助這樣的事情在下沉，

753
00:36:01,980 --> 00:36:04,600
這些都是數字
學生在過去的10年

754
00:36:04,600 --> 00:36:07,610
已經參與了一些
學術誠信等問題，

755
00:36:07,610 --> 00:36:10,990
與一些32名學生
從2015年秋天，這

756
00:36:10,990 --> 00:36:13,760
是說我們需要做
此事非常重視。

757
00:36:13,760 --> 00:36:18,380
而最終，這些數字組成，
最近，約3％，4％左右

758
00:36:18,380 --> 00:36:19,120
之類的。

759
00:36:19,120 --> 00:36:25,220
>> 因此，對於超級廣大學生
看來，線條清晰。

760
00:36:25,220 --> 00:36:27,940
但千萬記住這
介意，尤其是晚

761
00:36:27,940 --> 00:36:32,080
晚上用時掙扎
一些解決問題的方法集，

762
00:36:32,080 --> 00:36:34,830
有機制
為讓自己更好

763
00:36:34,830 --> 00:36:37,870
支持可能比你
想，即使在那個時刻。

764
00:36:37,870 --> 00:36:40,514
要知道，當我們收到
學生提交的作業，我們跨越

765
00:36:40,514 --> 00:36:43,430
今年比較各提交
較去年每提交，

766
00:36:43,430 --> 00:36:47,590
對從2007年的每提交，
既然，看著，還有，

767
00:36:47,590 --> 00:36:49,931
代碼庫在線，
論壇，招聘網站。

768
00:36:49,931 --> 00:36:51,806
我們提到這一點，
真的，所有著想

769
00:36:51,806 --> 00:36:56,040
充分披露，如果
別人可以在網上找到它，

770
00:36:56,040 --> 00:36:57,880
當然，我們也能做到的過程。

771
00:36:57,880 --> 00:37:00,100
但是，真的，精神
的過程歸結

772
00:37:00,100 --> 00:37:01,650
在教學大綱這一條款。

773
00:37:01,650 --> 00:37:03,670
這真的是正義的，是合理的。

774
00:37:03,670 --> 00:37:06,680
>> 如果我們要詳細說說
只有一個多一點的語言，

775
00:37:06,680 --> 00:37:09,770
意識到所有的實質
您提交給本課程的工作

776
00:37:09,770 --> 00:37:10,954
必須是你自己。

777
00:37:10,954 --> 00:37:13,870
但是內的，也肯定有
機會和鼓勵，

778
00:37:13,870 --> 00:37:17,300
在轉向和教學價值
others--自己的課題組，中科院，

779
00:37:17,300 --> 00:37:20,760
助教，和其他類，
支持，更不用說朋友

780
00:37:20,760 --> 00:37:23,547
和室友誰研究
CS和編程之前。

781
00:37:23,547 --> 00:37:25,130
等有該津貼。

782
00:37:25,130 --> 00:37:28,180
和拇指的一般規則
是this--尋求幫助的時候，

783
00:37:28,180 --> 00:37:31,470
你可能會顯示你的代碼給別人，
但你可能無法查看他們的。

784
00:37:31,470 --> 00:37:34,880
所以，即使你在辦公時間內，
或者在D廳，或其他地方

785
00:37:34,880 --> 00:37:37,450
一些件套的工作，
旁邊一個朋友，其工作

786
00:37:37,450 --> 00:37:40,160
是完全正常，在
一天的工作結束

787
00:37:40,160 --> 00:37:43,034
最終應屬於每個
你分別與不

788
00:37:43,034 --> 00:37:45,700
有一些協同努力，
除了最後的項目中，

789
00:37:45,700 --> 00:37:47,410
它允許和鼓勵。

790
00:37:47,410 --> 00:37:49,830
>> 要知道，如果你是
東西掙扎

791
00:37:49,830 --> 00:37:52,520
和你的朋友恰好
是在這個更好的，你，

792
00:37:52,520 --> 00:37:55,130
或者在這個問題比你強，
或者稍遠一點比你提前，

793
00:37:55,130 --> 00:37:57,330
這是完全合理的轉
你的朋友說，哎，

794
00:37:57,330 --> 00:38:00,480
你不介意看我的代碼在這裡，
幫我找出我的問題是什麼？

795
00:38:00,480 --> 00:38:03,760
並希望在
教學價值的興趣

796
00:38:03,760 --> 00:38:07,040
那位朋友不只是
說，哦，這樣做，而是

797
00:38:07,040 --> 00:38:09,917
什麼是你缺少行
6，或者類似的東西？

798
00:38:09,917 --> 00:38:12,000
但是該解決方案是不
為朋友在你身邊

799
00:38:12,000 --> 00:38:15,617
說，哦，這裡，讓我拉
這件事，並展示我的解決方案給你。

800
00:38:15,617 --> 00:38:16,450
所以這是該行。

801
00:38:16,450 --> 00:38:18,670
你看你的代碼
其他人，但你可能不

802
00:38:18,670 --> 00:38:22,350
查看他們的，受其他
在使用過程中的教學大綱約束。

803
00:38:22,350 --> 00:38:24,760
>> 所以，千萬記住這
所謂遺憾子句

804
00:38:24,760 --> 00:38:27,560
在使用過程中的教學大綱為好，
如果你犯了一些行為的

805
00:38:27,560 --> 00:38:30,476
是不是合理的，但它帶來
課程的負責人的注意

806
00:38:30,476 --> 00:38:34,240
在72小時內，該過程
可處以當地制裁措施

807
00:38:34,240 --> 00:38:37,380
可以包括不令人滿意的或
不及格提交的工作。

808
00:38:37,380 --> 00:38:41,410
但當然不會指的
此事作進一步的紀律處分，

809
00:38:41,410 --> 00:38:43,010
除了在行為屢禁不止的情況。

810
00:38:43,010 --> 00:38:46,632
換句話說，如果你做一些
愚蠢的，特別是深夜，決策

811
00:38:46,632 --> 00:38:49,340
該第二天早上，兩天
以後，你醒來時會發現，

812
00:38:49,340 --> 00:38:50,870
我在想什麼？

813
00:38:50,870 --> 00:38:53,890
你做CS50有一個出口
固定的問題

814
00:38:53,890 --> 00:38:57,170
和擁有了它，讓我們
會中途遇見你和處理

815
00:38:57,170 --> 00:39:01,500
與它在一個問題，既
教育和為貴有價值的，

816
00:39:01,500 --> 00:39:04,200
但在某些方面仍然懲罰。

817
00:39:04,200 --> 00:39:08,590
而現在，採取邊關閉，這一點。

818
00:39:08,590 --> 00:39:10,570
>> [視頻回放]

819
00:39:10,570 --> 00:39:13,540
>> [音樂]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [結束播放]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN：好吧，我們又回來了。

823
00:40:00,490 --> 00:40:03,680
現在我們來看看之一
首先我們的現實世界中域

824
00:40:03,680 --> 00:40:08,720
在CS50，藝術加密的，
發送和接收的技術

825
00:40:08,720 --> 00:40:11,840
秘密信息，加密
如果你願意的消息，

826
00:40:11,840 --> 00:40:17,060
如果你只能被破譯
發件人有一些關鍵因素

827
00:40:17,060 --> 00:40:18,030
為好。

828
00:40:18,030 --> 00:40:22,120
因此，要鼓勵這一點，我們將採取
一看這東西在這裡，

829
00:40:22,120 --> 00:40:26,750
這是一個示例
秘密的解碼器環的

830
00:40:26,750 --> 00:40:34,042
可為了搞清楚使用
什麼是秘密信息實際上是。

831
00:40:34,042 --> 00:40:35,750
其實，早在
當天在小學，

832
00:40:35,750 --> 00:40:38,787
如果你發送的秘密消息
一些朋友或在課堂上的一些好感，

833
00:40:38,787 --> 00:40:40,620
你可能認為
你被聰明

834
00:40:40,620 --> 00:40:46,530
在您的紙條變化的，
像，A到B和B到C和C至D，

835
00:40:46,530 --> 00:40:47,590
等等。

836
00:40:47,590 --> 00:40:50,300
但你實際上是加密
您的信息，甚至

837
00:40:50,300 --> 00:40:53,300
如果這是一個有點瑣碎，不
硬的教師來實現，

838
00:40:53,300 --> 00:40:55,675
好吧，如果你只是改變
B到A和C到B，

839
00:40:55,675 --> 00:40:57,550
你居然找出
什麼消息了，

840
00:40:57,550 --> 00:40:59,700
但你在加密信息。

841
00:40:59,700 --> 00:41:03,420
>> 你只是做
簡單地說，就像拉爾夫在這裡

842
00:41:03,420 --> 00:41:07,934
在一個著名的電影，播放
相當多廣告nauseum每年冬天。

843
00:41:07,934 --> 00:41:08,600
[視頻回放]

844
00:41:08,600 --> 00:41:11,180
-be它眾所周知，
拉爾夫·帕克特此

845
00:41:11,180 --> 00:41:14,070
任命小的一員
孤兒安妮秘密圈

846
00:41:14,070 --> 00:41:17,700
並有權所有榮譽
並與之發生利益。

847
00:41:17,700 --> 00:41:24,340
>> -Signed，小孤兒安妮，
會簽皮埃爾·安德烈，在墨水。

848
00:41:24,340 --> 00:41:27,160
榮譽和利益，
在已經九歲的時候。

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [他們咆哮]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-來吧。

853
00:41:34,250 --> 00:41:35,210
讓我們開始吧。

854
00:41:35,210 --> 00:41:39,530
我並不需要所有的爵士樂
關於走私和海盜。

855
00:41:39,530 --> 00:41:41,660
>>  - 聽明天晚上
結論冒險

856
00:41:41,660 --> 00:41:43,880
黑色的海盜船。

857
00:41:43,880 --> 00:41:46,650
現在，它的時間為
安妮的秘密信息

858
00:41:46,650 --> 00:41:49,840
為你秘社的成員。

859
00:41:49,840 --> 00:41:53,570
請記住，孩子，只有成員
安妮的秘密圈

860
00:41:53,570 --> 00:41:56,140
可以解碼安妮的秘密信息。

861
00:41:56,140 --> 00:42:00,340
>> 請記住，安妮取決於你。

862
00:42:00,340 --> 00:42:02,880
設置你的引腳B2。

863
00:42:02,880 --> 00:42:05,230
這裡是該消息。

864
00:42:05,230 --> 00:42:06,090
12，11--

865
00:42:06,090 --> 00:42:10,250
>> -I我在，我的第一次秘密會晤。

866
00:42:10,250 --> 00:42:13,890
>> -14，11，18，16。

867
00:42:13,890 --> 00:42:15,780
>> -Pierre在今晚的聲音很大。

868
00:42:15,780 --> 00:42:19,000
我可以告訴大家，今晚的
信息是非常重要的。

869
00:42:19,000 --> 00:42:22,694
>> -3，25日，這是一個消息
從安妮自己。

870
00:42:22,694 --> 00:42:23,860
記住，不要告訴任何人。

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90秒後，我的唯一
房間在房子裡一個男孩九

873
00:42:32,930 --> 00:42:37,040
可以坐在隱私和解碼。

874
00:42:37,040 --> 00:42:39,730
啊哈，B！

875
00:42:39,730 --> 00:42:42,360
我去了下，E.

876
00:42:42,360 --> 00:42:44,520
>> 第一個字是可以。

877
00:42:44,520 --> 00:42:49,032
S，它現在更容易到來，U，25--

878
00:42:49,032 --> 00:42:51,733
>> 哦，來吧，拉爾夫，我得走了！

879
00:42:51,733 --> 00:42:53,688
>> -I'll被降權，馬！

880
00:42:53,688 --> 00:42:54,188
嘖嘖颼颼！

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T，O，可以肯定的中場休息，一定要什麼呢？

883
00:43:04,060 --> 00:43:05,970
什麼是小孤兒
安妮想說什麼？

884
00:43:05,970 --> 00:43:07,264
一定要什麼呢？

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie，安迪已經得到了
走，請你出來？

886
00:43:09,634 --> 00:43:10,480
>> -All權，馬！

887
00:43:10,480 --> 00:43:12,880
我馬上就出來！

888
00:43:12,880 --> 00:43:14,550
>> -I接近現在是越來越。

889
00:43:14,550 --> 00:43:16,620
張力是可怕的。

890
00:43:16,620 --> 00:43:17,720
它以前如何？

891
00:43:17,720 --> 00:43:20,170
這個星球的命運
在資產負債可能會掛起。

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie！

893
00:43:20,670 --> 00:43:23,170
安迪的得走了！

894
00:43:23,170 --> 00:43:26,890
>> -I'll是正確的，對於哭出聲來！

895
00:43:26,890 --> 00:43:32,680
>> -Almost在那裡，我的手指飛去，我的腦海裡
是鋼陷阱，每一個毛孔振動。

896
00:43:32,680 --> 00:43:37,198
這幾乎是明確的，是的，是的，是的。

897
00:43:37,198 --> 00:43:43,091
>> -be一定要喝你的阿華田。

898
00:43:43,091 --> 00:43:43,590
阿華田？

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
一個最低級的商業？

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
王八蛋。

903
00:43:54,227 --> 00:43:54,810
[結束播放]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN：OK，所以
這是一個很長的路

905
00:43:57,390 --> 00:44:00,660
引入密碼學，
也阿華田。

906
00:44:00,660 --> 00:44:04,470
事實上，從這個古老的廣告
在這裡，為什麼阿華田這麼好？

907
00:44:04,470 --> 00:44:09,470
這是成熟的一種濃縮提取
大麥芽，純奶油牛奶，

908
00:44:09,470 --> 00:44:14,360
並特地準備了可可，一起
天然磷脂和維生素。

909
00:44:14,360 --> 00:44:18,240
它是與進一步強化
額外的維生素B和D，百勝。

910
00:44:18,240 --> 00:44:21,600
你仍然可以得到它，很顯然，
在亞馬遜，因為我們在這裡做。

911
00:44:21,600 --> 00:44:24,810
>> 但是，這裡的動機是為了
密碼學介紹，具體

912
00:44:24,810 --> 00:44:28,340
已知類型的加密的
作為密鑰加密。

913
00:44:28,340 --> 00:44:34,284
和顧名思義，整個
密鑰加密系統的安全性，

914
00:44:34,284 --> 00:44:36,200
如果你願意，一種方法
只是擾

915
00:44:36,200 --> 00:44:40,960
兩個人之間的信息是，
只有發​​件人和只有收件人

916
00:44:40,960 --> 00:44:46,980
知道一個秘密key--一定的價值，一些
秘密短語，一些秘密號碼，即

917
00:44:46,980 --> 00:44:50,660
讓他們來加密
和解密信息。

918
00:44:50,660 --> 00:44:53,470
和密碼，說真的，
只是這個0的一周。

919
00:44:53,470 --> 00:44:56,715
>> 這是一個問題，那裡的投入，
像英語的實際消息

920
00:44:56,715 --> 00:44:59,340
或任何語言，你
要發送給別人上課，

921
00:44:59,340 --> 00:45:00,580
或在互聯網上。

922
00:45:00,580 --> 00:45:03,840
有一些輸出，這是會
要被擾頻的信息，即你

923
00:45:03,840 --> 00:45:05,250
希望收件人接收。

924
00:45:05,250 --> 00:45:07,405
而且，即使有人在
中間接收它太，

925
00:45:07,405 --> 00:45:09,780
你不希望它們
一定能夠解密，

926
00:45:09,780 --> 00:45:12,840
因為這裡面
黑盒子，或算法，

927
00:45:12,840 --> 00:45:17,650
是某種機制，有的一步一步
指令，採取該輸入

928
00:45:17,650 --> 00:45:20,710
並將其轉換成
輸出，在希望以安全的方式。

929
00:45:20,710 --> 00:45:23,640
>> 並且，實際上，有一些
詞彙在這個世界上，如下所示。

930
00:45:23,640 --> 00:45:26,100
純文本是一個字
計算機科學家會

931
00:45:26,100 --> 00:45:28,449
用它來描述輸入
消息，喜歡英語

932
00:45:28,449 --> 00:45:31,240
或任何語言，你實際上
要發送到其他人。

933
00:45:31,240 --> 00:45:35,450
然後密文是加擾
給加密，或加密，

934
00:45:35,450 --> 00:45:36,520
其版本。

935
00:45:36,520 --> 00:45:38,750
>> 但是這裡有一種其它成分。

936
00:45:38,750 --> 00:45:43,200
還有另一個輸入
秘密密鑰加密。

937
00:45:43,200 --> 00:45:45,200
這就是密鑰本身，
這是，通常，

938
00:45:45,200 --> 00:45:48,930
正如我們所看到的，一數，或
字母或字，無論

939
00:45:48,930 --> 00:45:51,980
該算法它實際上是期待。

940
00:45:51,980 --> 00:45:53,870
>> 你如何解密信息？

941
00:45:53,870 --> 00:45:55,110
你怎麼解讀呢？

942
00:45:55,110 --> 00:45:57,950
嗯，你只是扭轉
輸出和輸入。

943
00:45:57,950 --> 00:46:00,900
>> 換句話說，一旦有人
收到加密郵件，

944
00:46:00,900 --> 00:46:03,740
他或她只是有
要知道，相​​同的密鑰。

945
00:46:03,740 --> 00:46:05,700
他們已經收到的密文。

946
00:46:05,700 --> 00:46:09,530
並通過封堵這兩個
輸入到加密系統，

947
00:46:09,530 --> 00:46:14,260
算法，這種黑匣子，出
應該原始明文。

948
00:46:14,260 --> 00:46:17,830
所以這是非常高的水平
鑑於什麼密碼實際上是

949
00:46:17,830 --> 00:46:18,590
所有關於。

950
00:46:18,590 --> 00:46:20,030
>> 因此，讓我們到達那裡。

951
00:46:20,030 --> 00:46:22,700
現在讓我們看看下面
東西引擎蓋

952
00:46:22,700 --> 00:46:26,000
我們一直理所當然的
過去的一周，而本次會議

953
00:46:26,000 --> 00:46:27,629
這裡 - 字符串。

954
00:46:27,629 --> 00:46:30,295
在一天結束的字符串
僅僅是一個字符序列。

955
00:46:30,295 --> 00:46:33,610
>> 這可能是世界您好，或
你好Zamyla，或什麼的。

956
00:46:33,610 --> 00:46:37,050
但是，這是什麼意思
是字符序列？

957
00:46:37,050 --> 00:46:41,520
事實上，CS50庫給出
我們稱為串的數據類型。

958
00:46:41,520 --> 00:46:45,140
>> 但實際上，沒有
這樣的事情在C.字符串

959
00:46:45,140 --> 00:46:49,450
這真的只是一個序列
人品，人品，性格，

960
00:46:49,450 --> 00:46:52,180
性格，背，背，
回來，回來，內頁

961
00:46:52,180 --> 00:46:54,650
您的計算機的內存或RAM。

962
00:46:54,650 --> 00:46:58,940
我們會更深入，在
當我們看內存本身的未來，

963
00:46:58,940 --> 00:47:02,030
與利用，並且
所涉及的威脅。

964
00:47:02,030 --> 00:47:04,100
>> 但是，讓我們考慮用字符串Zamyla。

965
00:47:04,100 --> 00:47:07,480
如此只是名字
這裡的人，Zamyla，

966
00:47:07,480 --> 00:47:12,030
即序列
字符，Z-A-M-Y-L-A。

967
00:47:12,030 --> 00:47:16,020
現在讓我們假設Zamyla的名字
正被存儲在計算機內的

968
00:47:16,020 --> 00:47:16,880
程序。

969
00:47:16,880 --> 00:47:20,830
>> 好了，按理說我們應該
可以看看那些字符

970
00:47:20,830 --> 00:47:21,590
個別。

971
00:47:21,590 --> 00:47:24,710
所以我只是要畫一個小
在這裡Zamyla的名稱框中。

972
00:47:24,710 --> 00:47:31,580
而且它是在C的情況下，當你
有一個字符串，如Zamyla--也許

973
00:47:31,580 --> 00:47:34,940
該字符串已經從回來
比如找到字符串的函數，

974
00:47:34,940 --> 00:47:38,540
實際上你可以操縱
通過它的性格特徵。

975
00:47:38,540 --> 00:47:42,070
>> 現在，這是有密切關係的
談話在另一方面，由於

976
00:47:42,070 --> 00:47:46,420
在密碼學，如果你想改變
A到B和B到C和C到D，

977
00:47:46,420 --> 00:47:49,650
等，則需要能夠
看單個字符

978
00:47:49,650 --> 00:47:50,190
在一個字符串。

979
00:47:50,190 --> 00:47:52,695
你需要能夠改變
在Z別的東西時，A

980
00:47:52,695 --> 00:47:55,280
別的東西，併購來
別的東西，等等。

981
00:47:55,280 --> 00:47:58,000
因此，我們需要一種方法，
編程，所以

982
00:47:58,000 --> 00:48:03,020
可以說，在C能夠改變
並期待在單個字母。

983
00:48:03,020 --> 00:48:05,690
我們可以做到這一點如下。

984
00:48:05,690 --> 00:48:08,340
>> 讓我去頭回CS50 IDE。

985
00:48:08,340 --> 00:48:11,130
讓我先走
並創建一個新的文件

986
00:48:11,130 --> 00:48:16,134
我會打電話給這次string0，
作為第一個這樣的例子，C點。

987
00:48:16,134 --> 00:48:18,300
而且我要繼續前進
鞭打它，如下所示。

988
00:48:18,300 --> 00:48:22,870
>> 所以包括CS50.h和
然後包括標準io.h，

989
00:48:22,870 --> 00:48:25,990
其中，我幾乎總是會
是使用在我的節目中，至少

990
00:48:25,990 --> 00:48:26,780
原來。

991
00:48:26,780 --> 00:48:32,180
詮釋主要作廢，然後在這裡我
要做得到的字符串得到的字符串。

992
00:48:32,180 --> 00:48:35,260
然後我要去
繼續前進，做到這一點。

993
00:48:35,260 --> 00:48:37,460
我要先走
並且，作為一個全面的檢查，

994
00:48:37,460 --> 00:48:43,607
只是說，你好，百分之S，
分號，使串0。

995
00:48:43,607 --> 00:48:44,690
嗯哦，我做了什麼嗎？

996
00:48:44,690 --> 00:48:45,930
哦，我沒有插上。

997
00:48:45,930 --> 00:48:48,120
所以，經驗教訓，即
不是故意的。

998
00:48:48,120 --> 00:48:52,480
>> 因此錯誤，百分之更多
轉換不是數據參數。

999
00:48:52,480 --> 00:48:54,940
這是哪裡，
線7-- OK，所以我有，

1000
00:48:54,940 --> 00:48:56,690
報價引文結束，這是
我的字符串的printf。

1001
00:48:56,690 --> 00:48:58,151
我有一個百分號。

1002
00:48:58,151 --> 00:48:59,650
但我錯過了第二個參數。

1003
00:48:59,650 --> 00:49:03,190
>> 我錯過了逗號s，這
我沒有在前面的例子。

1004
00:49:03,190 --> 00:49:06,650
因此，一個很好的機會來解決
多了一個錯誤，不慎。

1005
00:49:06,650 --> 00:49:09,950
現在讓我跑
string0，鍵入Zamyla。

1006
00:49:09,950 --> 00:49:10,970
OK，你好Zamyla。

1007
00:49:10,970 --> 00:49:14,144
>> 因此，我們運行該種方案
現在幾個不同的時間。

1008
00:49:14,144 --> 00:49:16,310
但是，讓我們做一個東西
有點不同這一次。

1009
00:49:16,310 --> 00:49:19,450
而不是僅僅打印Zamyla的
整個名稱用了printf的，

1010
00:49:19,450 --> 00:49:21,350
讓我們做吧逐個字符。

1011
00:49:21,350 --> 00:49:22,700
>> 我將使用一個for循環。

1012
00:49:22,700 --> 00:49:26,160
我要去給自己
計數變量，叫我。

1013
00:49:26,160 --> 00:49:33,530
而且我要保持迭代，所以
只要i小於s的長度。

1014
00:49:33,530 --> 00:49:35,930
>> 事實證明，我們沒
這樣做最後一次，

1015
00:49:35,930 --> 00:49:39,100
將c自帶
函數調用斯特林。

1016
00:49:39,100 --> 00:49:42,690
早在一天，並在一般
仍然實現功能的時候，

1017
00:49:42,690 --> 00:49:45,405
人們往往會選擇很
簡潔的名稱那種聲音

1018
00:49:45,405 --> 00:49:48,280
就像你想要什麼，即使它是
缺少了幾個元音字母或字母。

1019
00:49:48,280 --> 00:49:50,660
所以，斯特林是
一個函數的名稱，用以

1020
00:49:50,660 --> 00:49:53,880
需要之間的爭論
括號這應該是一個字符串。

1021
00:49:53,880 --> 00:49:56,910
它只是返回一個整數，
該字符串的長度。

1022
00:49:56,910 --> 00:50:00,580
>> 因此，這對7號線環是怎麼回事
開始計算在i等於0。

1023
00:50:00,580 --> 00:50:02,530
這將增加
我在每次迭代

1024
00:50:02,530 --> 00:50:04,350
1，因為我們已經做了幾次。

1025
00:50:04,350 --> 00:50:06,780
但它會只做
此直到點

1026
00:50:06,780 --> 00:50:09,660
當我是長度
的字符串本身。

1027
00:50:09,660 --> 00:50:14,520
>> 因此，這是一種方式，最終
遍歷字符

1028
00:50:14,520 --> 00:50:17,430
在字符串中原樣如下。

1029
00:50:17,430 --> 00:50:20,670
我要打印出不
整個字符串，但％的C，

1030
00:50:20,670 --> 00:50:22,860
單個字符
其次是一個新行。

1031
00:50:22,860 --> 00:50:24,880
然後我要去
繼續前進，我需要

1032
00:50:24,880 --> 00:50:29,080
說我要打印
的S i個字符。

1033
00:50:29,080 --> 00:50:33,450
>> 因此，如果i是指示可變
串，其中的索引

1034
00:50:33,450 --> 00:50:37,230
你在這，我需要能夠
說，給我S的第i個字符。

1035
00:50:37,230 --> 00:50:40,390
和c具有這樣的一種方式
這跟方括號。

1036
00:50:40,390 --> 00:50:43,679
您只需說出名字了
串，在此情況下為s。

1037
00:50:43,679 --> 00:50:46,970
然後你用方括號，這是
通常略高於您的返回鍵或回車

1038
00:50:46,970 --> 00:50:48,110
鍵在鍵盤上。

1039
00:50:48,110 --> 00:50:52,410
然後你放的索引
要打印的字符。

1040
00:50:52,410 --> 00:50:55,960
因此指數將是一個
number-- 0，或1，或2，或3，或點，

1041
00:50:55,960 --> 00:50:57,590
點，點，其他一些數字。

1042
00:50:57,590 --> 00:51:00,920
>> 而且我們要確保它會
是正確的號碼，因為我

1043
00:51:00,920 --> 00:51:02,360
從0開始計數。

1044
00:51:02,360 --> 00:51:07,020
而默認情況下，第一個字符
在一個字符串是按照慣例0。

1045
00:51:07,020 --> 00:51:09,230
而第二個字符是支架1。

1046
00:51:09,230 --> 00:51:11,120
和第三個字符是托架2。

1047
00:51:11,120 --> 00:51:13,630
而且你不想去過多
到目前為止，但我們不會因為我們

1048
00:51:13,630 --> 00:51:17,780
要增加只有我，直到
等於字符串的長度。

1049
00:51:17,780 --> 00:51:20,210
並在該點，
這個循環將停止。

1050
00:51:20,210 --> 00:51:25,550
>> 因此，讓我繼續前進，保存此
程序運行make串0。

1051
00:51:25,550 --> 00:51:28,400
但我搞砸了。

1052
00:51:28,400 --> 00:51:35,390
隱式聲明的庫函數
與類型，斯特靈和現在such--，

1053
00:51:35,390 --> 00:51:36,430
這聽起來很熟悉。

1054
00:51:36,430 --> 00:51:37,440
但它不是printf的。

1055
00:51:37,440 --> 00:51:38,540
而且它不能得到的字符串。

1056
00:51:38,540 --> 00:51:40,480
>> 我沒有搞砸的
以同樣的方式這一次。

1057
00:51:40,480 --> 00:51:45,100
但是請注意，到這裡一點點下降
此外，包含頭文件string.h，

1058
00:51:45,100 --> 00:51:47,210
明確規定了
聲明斯特林。

1059
00:51:47,210 --> 00:51:48,820
所以實際上是有一個線索。

1060
00:51:48,820 --> 00:51:51,670
>> 的確事實證明
還有另外一個頭文件

1061
00:51:51,670 --> 00:51:53,970
我們已經不習慣
在課堂上還沒有，但它是

1062
00:51:53,970 --> 00:51:56,480
在這些可用
給你，叫string.h中。

1063
00:51:56,480 --> 00:52:00,930
而在該文件中，文件string.h
是斯特林聲明。

1064
00:52:00,930 --> 00:52:05,220
因此，讓我繼續前進，
保存此，使串

1065
00:52:05,220 --> 00:52:08,040
0--不錯，沒有錯誤消息這一次。

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla和
我正要敲回車，

1067
00:52:12,290 --> 00:52:16,710
在這一點上的GetString是怎麼回事
返回字符串，把它放在秒。

1068
00:52:16,710 --> 00:52:21,890
然後，對於循環會遍歷
以上的s的人物之一的時間，

1069
00:52:21,890 --> 00:52:28,420
並打印，每行一個，因為
我在結束反斜杠ñ。

1070
00:52:28,420 --> 00:52:34,530
所以，我可以省略反斜線
N，然後只打印Zamyla所有

1071
00:52:34,530 --> 00:52:37,460
在同一條線上，
有效地重新實現

1072
00:52:37,460 --> 00:52:38,999
printf的，這是不是所有的有用。

1073
00:52:38,999 --> 00:52:40,540
但在這種情況下，我沒有做到這一點。

1074
00:52:40,540 --> 00:52:43,610
其實我已經打印在
字符的時間，每行一個，

1075
00:52:43,610 --> 00:52:45,400
讓我們實際看到的效果。

1076
00:52:45,400 --> 00:52:46,900
>> 但是，我在這裡要注意的一件事。

1077
00:52:46,900 --> 00:52:48,930
我們會回來的
這在未來的一周。

1078
00:52:48,930 --> 00:52:52,650
事實證明，這
代碼可能是馬車。

1079
00:52:52,650 --> 00:52:56,560
>> 原來，GET字符串
和生活中的一些其他功能

1080
00:52:56,560 --> 00:53:00,280
不一定總是
回到你期待什麼。

1081
00:53:00,280 --> 00:53:03,010
我們從去年一流知道
時間這一點，得到

1082
00:53:03,010 --> 00:53:04,960
串應該返回字符串。

1083
00:53:04,960 --> 00:53:09,900
但是，如果用戶鍵入了這樣的
一個長字或段落或文章

1084
00:53:09,900 --> 00:53:13,010
有只是沒有足夠的
內存在計算機中，以適應它。

1085
00:53:13,010 --> 00:53:15,410
>> 就像，如果出了什麼
不對引擎蓋底下？

1086
00:53:15,410 --> 00:53:18,400
它可能不會經常發生，
但它可能發生一次

1087
00:53:18,400 --> 00:53:21,520
在一段時間，非常罕見。

1088
00:53:21,520 --> 00:53:25,460
所以事實證明，GET字符串
喜歡它的功能並不一定

1089
00:53:25,460 --> 00:53:26,380
總是返回字符串。

1090
00:53:26,380 --> 00:53:30,680
他們可能會返回一些錯誤值，
一些哨兵值這麼說，

1091
00:53:30,680 --> 00:53:32,612
指示
出了問題。

1092
00:53:32,612 --> 00:53:35,320
而你只知道這個來自
在課堂上已經學會了，現在，

1093
00:53:35,320 --> 00:53:37,700
還是看了一些文檔。

1094
00:53:37,700 --> 00:53:43,120
原來，GET字符串
可以返回一個稱為空值。

1095
00:53:43,120 --> 00:53:46,220
null是一個特殊值，我們將
回來在未來的一周。

1096
00:53:46,220 --> 00:53:50,420
但現在，只知道如果我想
要在前進的真正合適

1097
00:53:50,420 --> 00:53:52,650
使用GET字符串，我
不應該只是調用它，

1098
00:53:52,650 --> 00:53:56,870
而盲目使用它的返回值，
相信這是一個字符串。

1099
00:53:56,870 --> 00:53:59,420
>> 我先說，
哎，等一下，只

1100
00:53:59,420 --> 00:54:03,380
繼續如果s不等於
空，空在那裡，再次

1101
00:54:03,380 --> 00:54:04,660
只是一些特殊的價值。

1102
00:54:04,660 --> 00:54:07,770
而且它是唯一的特別價值，你
需要擔心的GET字符串。

1103
00:54:07,770 --> 00:54:10,900
獲取字符串要么會
返回一個字符串或空。

1104
00:54:10,900 --> 00:54:17,219
>> 而這個感嘆號等號
你可能知道，也許從數學課

1105
00:54:17,219 --> 00:54:20,510
你可能劃上等號與
通過它的線，以指示不相等。

1106
00:54:20,510 --> 00:54:23,135
這不是一般的人物
你可以輸入你的鍵盤上。

1107
00:54:23,135 --> 00:54:26,480
因此在大多數編程語言，
當你想說不相等，

1108
00:54:26,480 --> 00:54:29,160
您使用感嘆號，
否則稱為爆炸。

1109
00:54:29,160 --> 00:54:33,180
所以你說一聲等於，這
表示不等於，邏輯上。

1110
00:54:33,180 --> 00:54:38,060
這就像有沒有一個更大的
大於或等於，或小於

1111
00:54:38,060 --> 00:54:41,270
等於你的鍵在鍵盤上
，做這一切在一個符號。

1112
00:54:41,270 --> 00:54:44,020
所以這就是為什麼，在過去的例子，
你做了一個開放的支架，然後

1113
00:54:44,020 --> 00:54:48,670
一個等號，為了做
大於或者說，不到。

1114
00:54:48,670 --> 00:54:49,910
>> 那麼，這裡的外賣？

1115
00:54:49,910 --> 00:54:53,880
這僅僅是現在的一種方式
引入這種語法，此功能，

1116
00:54:53,880 --> 00:54:57,390
遍歷各個
字符串中的字符。

1117
00:54:57,390 --> 00:55:00,260
而且就像那些方
支架讓你得到他們，

1118
00:55:00,260 --> 00:55:03,790
考慮這些方括號內
那種暗示在這個底層

1119
00:55:03,790 --> 00:55:06,040
設計，即每
字符串內字符

1120
00:55:06,040 --> 00:55:10,180
是種盒裝某處下方
罩在計算機的內存中。

1121
00:55:10,180 --> 00:55:12,340
>> 但是，讓我們的這個變體。

1122
00:55:12,340 --> 00:55:14,880
事實證明，這
程序是正確的。

1123
00:55:14,880 --> 00:55:18,810
所以，每CS50的軸評估
代碼，這現在是正確的。

1124
00:55:18,810 --> 00:55:22,959
尤其是現在，我檢查
空，這個程序應該永不死機。

1125
00:55:22,959 --> 00:55:24,500
而我只知道，從經驗。

1126
00:55:24,500 --> 00:55:28,040
但是沒有什麼別的了
我們真的可以去錯在這裡。

1127
00:55:28,040 --> 00:55:31,860
但它不是非常精心設計的，
因為讓我們回到基礎。

1128
00:55:31,860 --> 00:55:34,450
>> 首先，principles--
請問一個for循環嗎？

1129
00:55:34,450 --> 00:55:36,290
一個for循環做了三件事。

1130
00:55:36,290 --> 00:55:39,340
它初始化一些
值，如果你是問。

1131
00:55:39,340 --> 00:55:41,770
它檢查的條件。

1132
00:55:41,770 --> 00:55:45,380
再經過各
迭代中，每個循環後，

1133
00:55:45,380 --> 00:55:49,330
它增加了一些
值，或值，在這裡。

1134
00:55:49,330 --> 00:55:50,600
>> 那麼，是什麼意思呢？

1135
00:55:50,600 --> 00:55:52,940
我們初始化我為0。

1136
00:55:52,940 --> 00:55:58,610
我們檢查並確保i小於
s的長度，這是Z-A-M-Y-L-A，

1137
00:55:58,610 --> 00:55:59,900
所以其小於6。

1138
00:55:59,900 --> 00:56:02,590
而且，事實上，0小於6。

1139
00:56:02,590 --> 00:56:05,580
>> 我們從Zamyla的名字打印出來態。

1140
00:56:05,580 --> 00:56:08,080
然後我們增加我從0到1。

1141
00:56:08,080 --> 00:56:11,290
然後，我們檢查，是減少1
比S的長度是多少？

1142
00:56:11,290 --> 00:56:13,270
s的長度為6。

1143
00:56:13,270 --> 00:56:13,950
是的。

1144
00:56:13,950 --> 00:56:16,880
>> 因此，我們在Zamyla的名字，ZA打印。

1145
00:56:16,880 --> 00:56:20,090
我們增加i從0到1，2。

1146
00:56:20,090 --> 00:56:23,720
然後，我們檢查，是小於2
Zamyla的名稱的長度。

1147
00:56:23,720 --> 00:56:25,380
6-所以2小於6。

1148
00:56:25,380 --> 00:56:30,460
是的，讓我們打印出來，現在M在
Zamyla的姓名，第三個字符。

1149
00:56:30,460 --> 00:56:34,110
>> 這裡的關鍵是，在每個
故事的重複，我檢查，

1150
00:56:34,110 --> 00:56:37,810
為i小於Zamyla的長度？

1151
00:56:37,810 --> 00:56:40,350
但美中不足的是，
斯特林不是屬性。

1152
00:56:40,350 --> 00:56:43,100
那些你們誰編程
之前在Java或其他語言

1153
00:56:43,100 --> 00:56:46,310
可能知道長度的字符串
一個屬性，只是一些只讀值。

1154
00:56:46,310 --> 00:56:50,220
>> 在這種情況下，C中，如果這是
一個函數，從字面上

1155
00:56:50,220 --> 00:56:53,520
計數的數目
在Zamyla每次字符

1156
00:56:53,520 --> 00:56:54,740
我們調用該函數。

1157
00:56:54,740 --> 00:56:58,500
每次你讓計算機使用
斯特林，它採取一看Zamyla，

1158
00:56:58,500 --> 00:57:01,960
並說Z-A-M-Y-L-A，6。

1159
00:57:01,960 --> 00:57:02,962
和它返回6。

1160
00:57:02,962 --> 00:57:04,920
你叫下一次
它裡面的for循環，

1161
00:57:04,920 --> 00:57:08,610
它要去看看Zamyla
再次，說Z-A-M-Y-L-A，6。

1162
00:57:08,610 --> 00:57:10,320
而且它會返回6。

1163
00:57:10,320 --> 00:57:12,980
那麼什麼是愚蠢的這個設計？

1164
00:57:12,980 --> 00:57:17,700
>> 為什麼我的代碼不出來的5 5
設計現在，可以這麼說？

1165
00:57:17,700 --> 00:57:20,600
好吧，我問了
問題不必要的。

1166
00:57:20,600 --> 00:57:23,030
我做更多的工作比我需要。

1167
00:57:23,030 --> 00:57:25,370
>> 因此，即使
答案是正確的，我

1168
00:57:25,370 --> 00:57:29,560
問計算機，什麼是
Zamyla的長度再次

1169
00:57:29,560 --> 00:57:31,380
又一次，又一次，又一次？

1170
00:57:31,380 --> 00:57:33,980
那答案是
永遠不會改變。

1171
00:57:33,980 --> 00:57:35,900
它總是將是6。

1172
00:57:35,900 --> 00:57:39,730
>> 因此，比這更好的解決辦法
會是這樣一個版本。

1173
00:57:39,730 --> 00:57:43,390
讓我繼續前進，把它放在一個
所謂string1.c單獨的文件，

1174
00:57:43,390 --> 00:57:44,990
只是為了保持它分開。

1175
00:57:44,990 --> 00:57:47,260
而事實證明，在為
循環，你實際上可以

1176
00:57:47,260 --> 00:57:50,210
同時聲明多個變量。

1177
00:57:50,210 --> 00:57:53,460
>> 所以我要保持我並將其設置為0。

1178
00:57:53,460 --> 00:57:56,190
但我也要去
添加一個逗號，並說，

1179
00:57:56,190 --> 00:58:01,050
給我一個叫做變量n，其
值等於S的字符串長度。

1180
00:58:01,050 --> 00:58:09,410
現在，請讓我的狀態
我只要小​​於n。

1181
00:58:09,410 --> 00:58:14,140
>> 因此，在這種方式中，邏輯是
相同在一天結束。

1182
00:58:14,140 --> 00:58:18,280
但我想起了
值6，在這種情況下。

1183
00:58:18,280 --> 00:58:19,780
什麼是Zamyla的名字的長度？

1184
00:58:19,780 --> 00:58:20,860
而我把它以n。

1185
00:58:20,860 --> 00:58:23,050
>> 我還在檢查
每次的條件。

1186
00:58:23,050 --> 00:58:24,300
0小於6？

1187
00:58:24,300 --> 00:58:25,600
1小於6？

1188
00:58:25,600 --> 00:58:28,600
是小於6 2，等等？

1189
00:58:28,600 --> 00:58:31,914
>> 但我不要求計算機
又一次，又一次，什麼是

1190
00:58:31,914 --> 00:58:33,080
Zamyla的名字的長度？

1191
00:58:33,080 --> 00:58:34,320
什麼是Zamyla的名字的長度？

1192
00:58:34,320 --> 00:58:35,986
這是什麼Zamyla姓名的長度是多少？

1193
00:58:35,986 --> 00:58:40,440
我從字面上記住的是，第一，
只有回答第二個變量n。

1194
00:58:40,440 --> 00:58:45,280
所以這現在會是不僅
正確，而且精心設計的。

1195
00:58:45,280 --> 00:58:46,670
>> 那麼，如何風格？

1196
00:58:46,670 --> 00:58:48,866
我命名我的變量
不錯，我會說。

1197
00:58:48,866 --> 00:58:50,240
他們現在是超級簡潔。

1198
00:58:50,240 --> 00:58:52,090
這是完全的罰款。

1199
00:58:52,090 --> 00:58:55,120
>> 如果你只有一個
串中的程序，

1200
00:58:55,120 --> 00:58:56,860
你還不如叫它S代表字符串。

1201
00:58:56,860 --> 00:58:59,370
如果你只有一個變量
為程序中的計算，

1202
00:58:59,370 --> 00:59:00,710
你還不如把它叫做我。

1203
00:59:00,710 --> 00:59:03,500
如果你有一個長度，N
超級普遍。

1204
00:59:03,500 --> 00:59:05,800
但我還沒有評論我的任何代碼。

1205
00:59:05,800 --> 00:59:09,200
>> 我沒有通知rea​​der--
不管是我的TF，或TA，

1206
00:59:09,200 --> 00:59:12,460
或者只是colleague--什麼是應該
在這個程序中繼續。

1207
00:59:12,460 --> 00:59:15,760
因此獲得良好的作風，
我願意這樣做

1208
00:59:15,760 --> 00:59:24,580
是this--東西
輸入像詢問用戶。

1209
00:59:24,580 --> 00:59:26,670
而且我可以重寫
此任何數量的方式。

1210
00:59:26,670 --> 00:59:35,630
>> 確保S--確保GET
字符串返回的字符串。

1211
00:59:35,630 --> 00:59:40,280
然後在這裡 - 這或許
最重要的comment--迭代

1212
00:59:40,280 --> 00:59:44,450
過在一個時間s中一個字符。

1213
00:59:44,450 --> 00:59:47,060
我可以用任何
英語語言的選擇

1214
00:59:47,060 --> 00:59:49,650
這裡描述每個
的這些代碼塊。

1215
00:59:49,650 --> 00:59:52,740
>> 請注意，我沒有把
在每一行代碼註釋，

1216
00:59:52,740 --> 00:59:55,690
真的只是在有趣
偏多，那些

1217
00:59:55,690 --> 00:59:59,460
有一定的意義，我可能
想使超清晰的人

1218
00:59:59,460 --> 01:00:00,460
閱讀我的代碼。

1219
01:00:00,460 --> 01:00:02,920
而你為什麼調用get
字符串詢問用戶輸入？

1220
01:00:02,920 --> 01:00:05,450
甚至，一個是不一定
所有的描述。

1221
01:00:05,450 --> 01:00:09,340
但它有助於講一個故事，因為
在故事的第二行，確保

1222
01:00:09,340 --> 01:00:10,740
得到的字符串返回的字符串。

1223
01:00:10,740 --> 01:00:14,260
>> 而在故事中的第三行是，
遍歷s中一個人物

1224
01:00:14,260 --> 01:00:15,380
在一個時間。

1225
01:00:15,380 --> 01:00:17,920
而現在只是良好的措施，
我要繼續前進，並添加

1226
01:00:17,920 --> 01:00:24,560
多一條評論，只是
在S打印第i個字符表示。

1227
01:00:24,560 --> 01:00:26,520
現在，我做了什麼
在這一天結束了嗎？

1228
01:00:26,520 --> 01:00:29,190
>> 我增加了一些英語
詞語的註釋形式。

1229
01:00:29,190 --> 01:00:32,700
斜線斜線符號意味著，哎，
計算機，這是對人類，

1230
01:00:32,700 --> 01:00:33,820
不是你的，計算機。

1231
01:00:33,820 --> 01:00:35,119
所以他們在邏輯上被忽略。

1232
01:00:35,119 --> 01:00:35,910
他們只是在那裡。

1233
01:00:35,910 --> 01:00:39,830
>> 而且，事實上，CS50 IDE顯示他們作為
灰色，作為是有用的，但不是關鍵

1234
01:00:39,830 --> 01:00:41,000
到該程序。

1235
01:00:41,000 --> 01:00:42,570
請注意，你現在可以做的。

1236
01:00:42,570 --> 01:00:44,950
無論你懂C
編程或沒有，你

1237
01:00:44,950 --> 01:00:47,722
只需退後在這個
程序和脫脂的意見。

1238
01:00:47,722 --> 01:00:50,180
詢問用戶輸入，確保
得到的字符串返回一個字符串，

1239
01:00:50,180 --> 01:00:53,009
遍歷s中的字符
一次一個，打印字符

1240
01:00:53,009 --> 01:00:55,550
第i個字符S--你不
甚至有看代碼

1241
01:00:55,550 --> 01:00:57,270
要理解這個程序做什麼。

1242
01:00:57,270 --> 01:01:00,280
而且，更好的是，如果你自己看
這個節目在一兩個星期，

1243
01:01:00,280 --> 01:01:02,280
或一個月，或者一年，
你也不必

1244
01:01:02,280 --> 01:01:04,420
在代碼盯著，
試圖記住，

1245
01:01:04,420 --> 01:01:06,630
那我想這個代碼呢？

1246
01:01:06,630 --> 01:01:07,770
>> 你告訴自己。

1247
01:01:07,770 --> 01:01:11,660
你所描述它自己，
或者一些同事或助教，或TF。

1248
01:01:11,660 --> 01:01:14,860
所以這現在會是
正確的，良好的設計，

1249
01:01:14,860 --> 01:01:18,210
最終良好的作風為好。

1250
01:01:18,210 --> 01:01:19,990
所以，做記住這一點。

1251
01:01:19,990 --> 01:01:22,200
>> 因此，有一個其他
的事情，我要在這裡做

1252
01:01:22,200 --> 01:01:28,240
現在可以透露究竟是什麼
正在進行的發動機罩的下方。

1253
01:01:28,240 --> 01:01:30,390
因此，有此功能
在C和其他語言，

1254
01:01:30,390 --> 01:01:33,010
所謂的類型轉換
要么含蓄

1255
01:01:33,010 --> 01:01:37,250
或明確允許你轉換
從一種數據類型到另一種。

1256
01:01:37,250 --> 01:01:39,800
我們一直這樣處理
據今天的字符串。

1257
01:01:39,800 --> 01:01:41,250
>> 並且字符串的字符。

1258
01:01:41,250 --> 01:01:44,910
但是從本週召回
0，是什麼字？

1259
01:01:44,910 --> 01:01:49,334
人物只是一個抽象
上numbers--十進制數的頂部，

1260
01:01:49,334 --> 01:01:52,500
和小數真的只是一個
關於二進​​制數的頂部抽象，

1261
01:01:52,500 --> 01:01:53,720
因為我們定義它。

1262
01:01:53,720 --> 01:01:55,540
>> 因此，字符是數字。

1263
01:01:55,540 --> 01:01:58,410
和數字字符，
只是取決於上下文。

1264
01:01:58,410 --> 01:02:01,250
而事實證明，這裡面
的計算機程序的，

1265
01:02:01,250 --> 01:02:06,830
您可以指定你想怎麼看
在該節目內的位？

1266
01:02:06,830 --> 01:02:10,400
>> 從0本週我們不得不召回
ASCII，這僅僅是該代碼

1267
01:02:10,400 --> 01:02:11,620
映射字母數字。

1268
01:02:11,620 --> 01:02:13,660
和我們說，資本A是65。

1269
01:02:13,660 --> 01:02:15,860
資本B是66，等等。

1270
01:02:15,860 --> 01:02:20,500
>> 和通知，我們基本上是有字符上
這裡的最上面一行，為C會打電話給他們，

1271
01:02:20,500 --> 01:02:23,400
字符，然後
在第二排整數。

1272
01:02:23,400 --> 01:02:28,180
而事實證明，你可以轉換
無縫兩個，通常之間。

1273
01:02:28,180 --> 01:02:30,042
如果我們想要做的
這種刻意，我們

1274
01:02:30,042 --> 01:02:31,750
可能要處理
這樣的事情。

1275
01:02:31,750 --> 01:02:33,590
>> 我們可能要轉換
上殼體，以降低

1276
01:02:33,590 --> 01:02:35,330
的情況下，或小寫字母為大寫。

1277
01:02:35,330 --> 01:02:38,000
而事實證明那裡的
這裡實際上是一個模式

1278
01:02:38,000 --> 01:02:39,900
我們可以在短短的時刻擁抱。

1279
01:02:39,900 --> 01:02:44,120
但是讓我們先來看一個
例如明確地這樣做的。

1280
01:02:44,120 --> 01:02:46,340
>> 我要重新回到CS50 IDE。

1281
01:02:46,340 --> 01:02:50,640
我要去創造一個
文件調用的Ascii 0.C.

1282
01:02:50,640 --> 01:02:55,960
而且我要繼續前進，加我
標準io.h頂部，INT主要無效

1283
01:02:55,960 --> 01:02:57,370
在我的函數的頂部。

1284
01:02:57,370 --> 01:03:02,700
然後，我只是做
following-- for循環從i等於，

1285
01:03:02,700 --> 01:03:04,610
讓我們說，65。

1286
01:03:04,610 --> 01:03:10,460
>> 然後我將是小於
在字母表65，加上26個字母。

1287
01:03:10,460 --> 01:03:12,640
因此，我將讓電腦
做數學題對我來說。

1288
01:03:12,640 --> 01:03:15,100
然後該環內，
我該怎麼打印？

1289
01:03:15,100 --> 01:03:19,230
>> ％c是％I反斜線ñ。

1290
01:03:19,230 --> 01:03:21,290
現在，我想在兩個值堵塞。

1291
01:03:21,290 --> 01:03:24,530
我暫時把問題
標誌著有邀請的問題。

1292
01:03:24,530 --> 01:03:29,940
>> 我想從65迭代起
對於26個英文字母，

1293
01:03:29,940 --> 01:03:35,190
打印出在每個迭代該
人物的積分相同。

1294
01:03:35,190 --> 01:03:38,299
換句話說，我想
遍歷26號打印

1295
01:03:38,299 --> 01:03:41,590
ASCII字符是什麼，信，
和相應的數字is--什麼

1296
01:03:41,590 --> 01:03:44,650
真的只是重建
從幻燈片圖表。

1297
01:03:44,650 --> 01:03:47,010
那麼，應該將這些問號是什麼？

1298
01:03:47,010 --> 01:03:51,760
>> 那麼，事實證明，第二
應該僅僅是變量i。

1299
01:03:51,760 --> 01:03:53,860
我希望看到，作為一個數字。

1300
01:03:53,860 --> 01:03:58,920
而中間的說法
在這裡，我可以告訴電腦

1301
01:03:58,920 --> 01:04:03,470
對待該整數
i設定為一個字符，從而

1302
01:04:03,470 --> 01:04:05,880
在這裡用它替換％的C.

1303
01:04:05,880 --> 01:04:07,990
>> 換句話說，如果我的
人類的程序員，知道

1304
01:04:07,990 --> 01:04:09,865
這些都只是數字
在一天結束。

1305
01:04:09,865 --> 01:04:12,500
我知道，65應
映射到一些字符。

1306
01:04:12,500 --> 01:04:15,310
有了這個明確的轉換，
有一個括號，

1307
01:04:15,310 --> 01:04:18,840
要數據類型的名稱
轉換，和一個封閉的括號，

1308
01:04:18,840 --> 01:04:21,200
你可以告訴
計算機，嘿嘿，計算機，

1309
01:04:21,200 --> 01:04:24,130
這個整數轉換為char。

1310
01:04:24,130 --> 01:04:26,250
>> 所以，當我運行這個
程序編譯後，

1311
01:04:26,250 --> 01:04:29,740
讓我們看看我get--使ASCII 0。

1312
01:04:29,740 --> 01:04:33,020
該死，我做了什麼錯在這裡？

1313
01:04:33,020 --> 01:04:35,884
使用未聲明的標識符，
沒事的，不是故意的，

1314
01:04:35,884 --> 01:04:37,800
但讓​​我們看看如果我們不能
原因通過此。

1315
01:04:37,800 --> 01:04:41,220
>> 因此，行five--所以我沒有得到
很遠的事情搞砸了。

1316
01:04:41,220 --> 01:04:42,140
沒關係。

1317
01:04:42,140 --> 01:04:46,560
因此，對於我行5等於65--我明白了。

1318
01:04:46,560 --> 01:04:50,130
所以請記住，在C，不像有些
如果你有事先編程語言

1319
01:04:50,130 --> 01:04:52,190
經驗，你有
告訴計算機，

1320
01:04:52,190 --> 01:04:55,040
不像划痕，是什麼
變量的類型是。

1321
01:04:55,040 --> 01:04:56,860
>> 而我在這裡忘了關鍵短語。

1322
01:04:56,860 --> 01:04:59,200
在五號線，我用我開始。

1323
01:04:59,200 --> 01:05:01,560
但是，我還沒有告訴Ç
什麼樣的數據類型是。

1324
01:05:01,560 --> 01:05:04,570
所以我要在這裡進去
說啊，讓一個整數。

1325
01:05:04,570 --> 01:05:07,050
>> 現在我要繼續前進，並重新編譯。

1326
01:05:07,050 --> 01:05:08,080
這固定的。

1327
01:05:08,080 --> 01:05:12,660
./ascii0輸入，這很酷。

1328
01:05:12,660 --> 01:05:15,360
它不僅是超級快
讓計算機這個問題，

1329
01:05:15,360 --> 01:05:18,885
而不是看它在幻燈片上，
它打印出每行一個，A為65，

1330
01:05:18,885 --> 01:05:24,860
B是66，一路down--因為我
這樣做26 times--到字母Z，

1331
01:05:24,860 --> 01:05:25,630
這是90。

1332
01:05:25,630 --> 01:05:27,790
而且，事實上，稍
更智能的會

1333
01:05:27,790 --> 01:05:31,030
一直對我不依賴
在計算機上，以添加26。

1334
01:05:31,030 --> 01:05:34,060
我剛做
90為好，這樣長時間

1335
01:05:34,060 --> 01:05:37,390
因為我不犯​​同樣的錯誤兩次。

1336
01:05:37,390 --> 01:05:41,880
我想通過上去
Z，不僅僅是高達到y。

1337
01:05:41,880 --> 01:05:44,000
>> 所以這是一個明確的轉換。

1338
01:05:44,000 --> 01:05:47,860
事實證明，這
甚至沒有必要。

1339
01:05:47,860 --> 01:05:52,480
讓我繼續前進，重新運行此
編譯器，然後重新運行ASCII 0。

1340
01:05:52,480 --> 01:05:54,940
事實證明，C是非常聰明。

1341
01:05:54,940 --> 01:05:57,150
>> 和printf，特別
是相當聰明。

1342
01:05:57,150 --> 01:06:01,260
如果你只是傳遞一個我兩次
兩個佔位符的printf

1343
01:06:01,260 --> 01:06:04,510
會意識到，哦，我知道你
給了我一個integer--一些數字，

1344
01:06:04,510 --> 01:06:06,380
像65或90，或什麼的。

1345
01:06:06,380 --> 01:06:10,170
但是，我知道你要我
像格式化字符該號碼。

1346
01:06:10,170 --> 01:06:16,460
所以printf的可隱式轉換
在詮釋為你一個char為好。

1347
01:06:16,460 --> 01:06:19,360
所以，這不是一個問題都沒有。

1348
01:06:19,360 --> 01:06:23,100
>> 但是請注意，因為這等同，
我們實際上可以做到這一點。

1349
01:06:23,100 --> 01:06:26,520
讓我繼續前進，做一個
this-- 1.C.的Ascii其他版本

1350
01:06:26,520 --> 01:06:31,800
取而代之的迭代
整數，才能真正打擊你的心

1351
01:06:31,800 --> 01:06:33,610
通過遍歷字符。

1352
01:06:33,610 --> 01:06:37,660
如果一個charç獲得資本A，I
想先走，並做到這一點，

1353
01:06:37,660 --> 01:06:41,740
只要C小於或等於
資本Z.並在每個迭代

1354
01:06:41,740 --> 01:06:45,690
我想增加C，我可以
現在在我行的printf這裡

1355
01:06:45,690 --> 01:06:51,320
比如說，百分比C是
我百分之再次，逗號C.

1356
01:06:51,320 --> 01:06:57,200
>> 而現在，我可以去另一個方向，
鑄人品明確

1357
01:06:57,200 --> 01:06:58,500
為整數。

1358
01:06:58,500 --> 01:07:00,560
因此，再次，你為什麼會這麼做？

1359
01:07:00,560 --> 01:07:03,830
這是一個有點怪異排序的
計數的字符條款。

1360
01:07:03,830 --> 01:07:07,430
>> 但是，如果你明白什麼是
怎麼回事引擎蓋下，

1361
01:07:07,430 --> 01:07:08,430
真的沒有魔法。

1362
01:07:08,430 --> 01:07:13,060
你這麼說，哎，給電腦
我一個叫char類型的C變量。

1363
01:07:13,060 --> 01:07:16,520
它初始化為大寫的A和
注意單引號問題。

1364
01:07:16,520 --> 01:07:19,580
>> 在C字，從召回
上週，您可以使用單引號。

1365
01:07:19,580 --> 01:07:23,720
對於字符串，單詞，
詞組，使用雙引號。

1366
01:07:23,720 --> 01:07:27,210
OK，電腦，繼續做這個，所以
只要字符小於

1367
01:07:27,210 --> 01:07:28,050
或等於z。

1368
01:07:28,050 --> 01:07:32,640
而我從ASCII表知道，所有的
這些ASCII碼是連續的。

1369
01:07:32,640 --> 01:07:33,400
>> 有沒有差距。

1370
01:07:33,400 --> 01:07:36,737
所以，這只是A到Z，
通過每一個號碼分開。

1371
01:07:36,737 --> 01:07:38,820
然後，我可以遞增
一個char，如果我真正想要的。

1372
01:07:38,820 --> 01:07:40,390
在一天結束時，
它只是一個數字。

1373
01:07:40,390 --> 01:07:41,030
我知道這個。

1374
01:07:41,030 --> 01:07:43,670
所以，我只能推測到1添加到它。

1375
01:07:43,670 --> 01:07:46,940
>> 然後這個時候，我打印C，
然後積分當量。

1376
01:07:46,940 --> 01:07:50,170
我甚至不需要明確的轉換。

1377
01:07:50,170 --> 01:07:52,680
我可以讓printf和的
計算機理出頭緒，

1378
01:07:52,680 --> 01:07:57,300
所以，現在，如果我跑
使Ascii1./ascii1，

1379
01:07:57,300 --> 01:08:01,520
我得到同樣的事情為好。

1380
01:08:01,520 --> 01:08:04,530
>> 無用的程序，though--沒有人
是要實際編寫軟件

1381
01:08:04,530 --> 01:08:07,549
為了搞清楚，究竟是什麼
映射到一個數字，或B，或Z？

1382
01:08:07,549 --> 01:08:10,340
你只是去Google一下，或
網上查一查，或者看它

1383
01:08:10,340 --> 01:08:11,650
幻燈片上，或類似物。

1384
01:08:11,650 --> 01:08:13,520
那麼，這實際上得到有用嗎？

1385
01:08:13,520 --> 01:08:15,960
>> 好了，說那
滑，注意有

1386
01:08:15,960 --> 01:08:20,890
一個實際的模式在這裡大寫之間
和小寫，這是不是偶然的。

1387
01:08:20,890 --> 01:08:23,760
請注意，資本A是65。

1388
01:08:23,760 --> 01:08:25,830
小寫a是97。

1389
01:08:25,830 --> 01:08:29,649
並有多遠較低情況下？

1390
01:08:29,649 --> 01:08:32,649
>> 所以65是97多少步走呢？

1391
01:08:32,649 --> 01:08:36,210
所以97減65為32。

1392
01:08:36,210 --> 01:08:37,910
所以資本為65。

1393
01:08:37,910 --> 01:08:39,939
如果添加32到，
你會得到一個小寫。

1394
01:08:39,939 --> 01:08:43,729
而且，等效如果你減去32，
你回到資本A--同為B

1395
01:08:43,729 --> 01:08:46,380
以小B，大C到小℃。

1396
01:08:46,380 --> 01:08:50,670
>> 所有這些差距是32分開。

1397
01:08:50,670 --> 01:08:54,450
現在，這似乎讓我們
做類似微軟的Word，

1398
01:08:54,450 --> 01:08:57,729
或谷歌文檔功能，您
可以選擇一切，然後說，

1399
01:08:57,729 --> 01:09:00,520
改變這一切為小寫，或
全部改為大寫，

1400
01:09:00,520 --> 01:09:03,840
或僅改變第一個字
一個句子為大寫字母。

1401
01:09:03,840 --> 01:09:07,390
事實上，我們可以做一些事情
這樣的自己。

1402
01:09:07,390 --> 01:09:12,645
>> 讓我繼續前進，保存文件
這裡所說的利用0.C.

1403
01:09:12,645 --> 01:09:15,770
讓我們繼續前進，掀起程序
這正是這麼做的，如下所示。

1404
01:09:15,770 --> 01:09:18,460
因此，包括CS50庫。

1405
01:09:18,460 --> 01:09:21,430
而包括標準I / O。

1406
01:09:21,430 --> 01:09:22,787
>> 我知道這是即將到來。

1407
01:09:22,787 --> 01:09:24,870
所以，我打算把它放在
已經存在，string.h中，

1408
01:09:24,870 --> 01:09:26,960
所以我有機會獲得
之類的東西斯特林，

1409
01:09:26,960 --> 01:09:29,620
再詮釋主空，一如往常。

1410
01:09:29,620 --> 01:09:33,420
然後我要繼續前進
做琴弦得到得到的字符串，

1411
01:09:33,420 --> 01:09:35,032
只是為了獲得來自用戶的字符串。

1412
01:09:35,032 --> 01:09:36,740
然後我要去
做我的完整性檢查。

1413
01:09:36,740 --> 01:09:40,510
如果字符串不等於空，
那麼它的安全進行。

1414
01:09:40,510 --> 01:09:42,000
什麼做我想做的事？

1415
01:09:42,000 --> 01:09:48,700
我要遍歷從i等於0，
和n高達S的字符串長度。

1416
01:09:48,700 --> 01:09:51,899
>> 而且我要做到這一點，只要
i小於n，並且我加再加。

1417
01:09:51,899 --> 01:09:55,060
到目前為止，我真的只是
從之前借款的想法。

1418
01:09:55,060 --> 01:09:57,010
現在我要介紹一個分支。

1419
01:09:57,010 --> 01:09:59,635
>> 所以，回想著划痕，其中
我們在路上的叉，

1420
01:09:59,635 --> 01:10:05,110
上週在C.我要去
這麼一說，s中的第i個字符

1421
01:10:05,110 --> 01:10:09,250
大於或
等於降低情況下，

1422
01:10:09,250 --> 01:10:13,340
而且 - 在抓你會從字面上
說和，但在C你說符號，

1423
01:10:13,340 --> 01:10:19,830
ampersand--和s中​​的第i個字符
小於或等於小寫Z，

1424
01:10:19,830 --> 01:10:21,780
讓我們做一些有趣的事情。

1425
01:10:21,780 --> 01:10:27,020
讓我們來實際打印出來
性格沒有換行符

1426
01:10:27,020 --> 01:10:31,760
即在字符串中的字符，
第i個字符的字符串中。

1427
01:10:31,760 --> 01:10:37,420
>> 但是，讓我們繼續前進，
減去它32。

1428
01:10:37,420 --> 01:10:42,120
否則，如果在字符
字符串，我們正在尋找

1429
01:10:42,120 --> 01:10:45,950
是不是稍微之間
和小Z，繼續前進

1430
01:10:45,950 --> 01:10:48,610
和剛剛打印出來不變。

1431
01:10:48,610 --> 01:10:50,840
因此，我們已經介紹了
此括號表示法

1432
01:10:50,840 --> 01:10:53,560
我們的關係，想在
第i個字符的字符串中。

1433
01:10:53,560 --> 01:10:57,520
>> 我已經添加了一些條件邏輯，如
刮在上週的一周一物，何處

1434
01:10:57,520 --> 01:10:59,880
我只是用我的根本
一個什麼樣的了解

1435
01:10:59,880 --> 01:11:01,130
正在進行的發動機罩的下方。

1436
01:11:01,130 --> 01:11:04,190
為s的第i個字符
大於或等於一個？

1437
01:11:04,190 --> 01:11:08,290
像，它是97或98，
或99，等等？

1438
01:11:08,290 --> 01:11:11,940
>> 但是它也小於或等於
為小寫字母z的價值？

1439
01:11:11,940 --> 01:11:16,210
如果是這樣，這是什麼意思行？

1440
01:11:16,210 --> 01:11:20,250
14，這是排序的
整個想法的胚芽，

1441
01:11:20,250 --> 01:11:23,840
大寫字母
簡單地減去它32，

1442
01:11:23,840 --> 01:11:29,370
在這種情況下，因為我知道，這每
圖中，我的數字是如何表示。

1443
01:11:29,370 --> 01:11:33,925
因此，讓我們繼續前進，並運行此，
編譯利用0.c後，

1444
01:11:33,925 --> 01:11:36,210
和運行資本0。

1445
01:11:36,210 --> 01:11:40,300
>> 讓我們鍵入類似
Zamyla在全部小寫輸入。

1446
01:11:40,300 --> 01:11:42,780
現在我們有Zamyla全部大寫。

1447
01:11:42,780 --> 01:11:45,050
讓我們在所有小寫輸入羅布。

1448
01:11:45,050 --> 01:11:46,674
讓我們嘗試傑森全部小寫。

1449
01:11:46,674 --> 01:11:48,590
我們不斷收到
強制資本。

1450
01:11:48,590 --> 01:11:50,960
有一個小錯誤，我
那種沒有預料到的。

1451
01:11:50,960 --> 01:11:54,050
請注意我的新提示結束了
在同一行作為他們的名字，

1452
01:11:54,050 --> 01:11:55,520
這感覺有點凌亂。

1453
01:11:55,520 --> 01:11:59,170
>> 所以我要在這裡走，
其實在這個程序結束

1454
01:11:59,170 --> 01:12:02,110
打印出一個換行符。

1455
01:12:02,110 --> 01:12:03,160
就這樣。

1456
01:12:03,160 --> 01:12:06,120
但使用printf，你並不需要
傳遞變量或格式代碼。

1457
01:12:06,120 --> 01:12:08,460
你可以從字面上只是打印
像一個換行符。

1458
01:12:08,460 --> 01:12:13,529
>> 因此，讓我們繼續前進，使
再利用0，重新運行，Zamyla。

1459
01:12:13,529 --> 01:12:14,820
而現在這是一個有點漂亮。

1460
01:12:14,820 --> 01:12:17,274
現在，我的提示是對自己的新線。

1461
01:12:17,274 --> 01:12:18,440
所以這是一切優秀和良好。

1462
01:12:18,440 --> 01:12:19,910
所以這是一個很好的例子。

1463
01:12:19,910 --> 01:12:22,700
不過，我也不一定
需要硬編碼的32。

1464
01:12:22,700 --> 01:12:23,350
你知道嗎？

1465
01:12:23,350 --> 01:12:26,350
我可以say--我從來沒有
記住不同的是什麼。

1466
01:12:26,350 --> 01:12:29,330
>> 但我知道，如果我
有一個小寫字母，

1467
01:12:29,330 --> 01:12:34,430
我基本上是想減去關閉
任何的距離是小之間

1468
01:12:34,430 --> 01:12:39,160
一，大A，因為如果我假設
所有的其它字母的是相同的，

1469
01:12:39,160 --> 01:12:41,045
應該把工作做好。

1470
01:12:41,045 --> 01:12:42,670
但是，而不是這樣做，你知道嗎？

1471
01:12:42,670 --> 01:12:44,240
還有另一種方式。

1472
01:12:44,240 --> 01:12:48,090
>> 如果這是利用1.c--如果我是
以它放入一個單獨的文件。

1473
01:12:48,090 --> 01:12:51,030
讓我們做資本2.C如下。

1474
01:12:51,030 --> 01:12:53,060
我要真打掃一下這裡。

1475
01:12:53,060 --> 01:12:57,420
而不是甚至無需
知道也不關心那些低水平

1476
01:12:57,420 --> 01:13:01,090
實施細則，我代替
只是要打印的字符，

1477
01:13:01,090 --> 01:13:04,610
報價引文結束，百分比C和
然後調用另一個函數，

1478
01:13:04,610 --> 01:13:09,950
存在需要一個參數，
這是一個字符，像這樣。

1479
01:13:09,950 --> 01:13:12,630
>> 原來，在C，有
另一個函數調用

1480
01:13:12,630 --> 01:13:15,550
到上，這正如其名
建議需要的性格

1481
01:13:15,550 --> 01:13:19,350
它使得其上殼
等效，然後返回它

1482
01:13:19,350 --> 01:13:21,410
這樣的printf可以在那裡插上。

1483
01:13:21,410 --> 01:13:25,484
所以這樣做，雖然，我
需要引入另一個文件。

1484
01:13:25,484 --> 01:13:28,400
原來還有另一個文件
你只能從類知道，

1485
01:13:28,400 --> 01:13:33,020
或教材，或在線
引用，名為C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> 所以，如果我補充一點，我的頭之間
文件，現在重新編譯這個程序，

1487
01:13:38,570 --> 01:13:43,040
capitalize2，./capitalize2 Enter鍵。

1488
01:13:43,040 --> 01:13:46,690
讓我們在所有類型Zamyla
小寫，還是工作原理相同。

1489
01:13:46,690 --> 01:13:48,040
但是，你知道嗎？

1490
01:13:48,040 --> 01:13:55,590
事實證明，到上
有一些其它功能。

1491
01:13:55,590 --> 01:13:58,410
>> 讓我介紹這個
命令這裡，有點笨拙

1492
01:13:58,410 --> 01:14:00,250
命名，但男人使用說明書。

1493
01:14:00,250 --> 01:14:03,960
事實證明，大多數Linux計算機，
因為我們使用的是這裡 -  Linux的操作系統

1494
01:14:03,960 --> 01:14:06,270
系統 - 有一個命令
所謂的人，它說，

1495
01:14:06,270 --> 01:14:08,530
哎，電腦，給我
電腦的使用手冊。

1496
01:14:08,530 --> 01:14:10,680
你想做什麼
查找該手冊中？

1497
01:14:10,680 --> 01:14:13,840
>> 我想查找功能
叫上，回車。

1498
01:14:13,840 --> 01:14:16,070
這是一個有點神秘
有時閱讀。

1499
01:14:16,070 --> 01:14:18,780
但是請注意，我們是在
Linux的程序員手冊。

1500
01:14:18,780 --> 01:14:19,530
和它的所有文本。

1501
01:14:19,530 --> 01:14:21,905
並注意還有的
函數的名稱在這裡。

1502
01:14:21,905 --> 01:14:25,030
事實證明，它有一個表妹叫
降低，這則正好相反。

1503
01:14:25,030 --> 01:14:29,710
並根據大綱的通知，要使用這個
函數的手冊頁，可以這麼說，

1504
01:14:29,710 --> 01:14:32,220
告訴我，我
需要包括C type.h.

1505
01:14:32,220 --> 01:14:33,630
而且我知道，從實踐中。

1506
01:14:33,630 --> 01:14:36,210
>> 在這裡，它顯示了我兩
對於函數原型，

1507
01:14:36,210 --> 01:14:39,070
所以，如果我曾經想用這個
我知道他們採取什麼樣的作為輸入，

1508
01:14:39,070 --> 01:14:40,652
和他們返回作為輸出。

1509
01:14:40,652 --> 01:14:42,360
然後如果我讀
說明，我看

1510
01:14:42,360 --> 01:14:44,820
更詳細的功能做了什麼。

1511
01:14:44,820 --> 01:14:48,100
但是如果更重要的是，
我期待下返回值，

1512
01:14:48,100 --> 01:14:51,710
它說，返回的值是
轉換後的信，

1513
01:14:51,710 --> 01:14:57,880
或C，原來的輸入，如果
轉換是不可能的。

1514
01:14:57,880 --> 01:15:01,992
>> 換句話說，到上部會嘗試
到了一封信轉換為大寫。

1515
01:15:01,992 --> 01:15:03,450
如果是的話，它會返回。

1516
01:15:03,450 --> 01:15:07,010
但是，如果它不能為某些reason--
也許它已經大寫，

1517
01:15:07,010 --> 01:15:09,550
也許這是一個驚嘆號
或一些其它punctuation--

1518
01:15:09,550 --> 01:15:12,200
它只是要
返回原來的C，

1519
01:15:12,200 --> 01:15:17,340
這意味著我可以讓我的代碼
更好的設計如下。

1520
01:15:17,340 --> 01:15:20,580
>> 我並不需要所有的
這些代碼織補行。

1521
01:15:20,580 --> 01:15:22,610
我的一切的線路
只是強調能

1522
01:15:22,610 --> 01:15:28,700
被折疊成只是一個簡單的
線，這是this-- printf的百分之

1523
01:15:28,700 --> 01:15:33,510
C到上小號支架我。

1524
01:15:33,510 --> 01:15:36,090
並且這將是一個
例如更好的設計。

1525
01:15:36,090 --> 01:15:40,040
>> 為什麼在7或8條線路實施
代碼，不管是什麼我只是

1526
01:15:40,040 --> 01:15:44,960
刪除，當你可以代替崩潰
所有的邏輯和決策

1527
01:15:44,960 --> 01:15:49,620
成一個單一的線，13現在，這
依賴於一個庫function--

1528
01:15:49,620 --> 01:15:53,430
隨C中的函數，但
究竟你想要它做的事。

1529
01:15:53,430 --> 01:15:55,295
而且，坦率地說，即使
它沒有附帶C，

1530
01:15:55,295 --> 01:15:58,880
你可以自己實現它，
我們已經看到，與獲得負INT

1531
01:15:58,880 --> 01:16:01,700
並獲得上週積極INT為好。

1532
01:16:01,700 --> 01:16:03,470
>> 此代碼是現在更具可讀性。

1533
01:16:03,470 --> 01:16:06,670
而且，事實上，如果我們向上滾動，
怎麼看怎麼更加緊湊

1534
01:16:06,670 --> 01:16:08,360
這個版本我的程序是。

1535
01:16:08,360 --> 01:16:11,230
這是一個有點頭重腳輕了，
所有這些包含。

1536
01:16:11,230 --> 01:16:14,380
不過沒關係，因為現在我站在
程序員的肩膀上

1537
01:16:14,380 --> 01:16:15,300
在我面前。

1538
01:16:15,300 --> 01:16:18,440
而誰是誰
實施上真正

1539
01:16:18,440 --> 01:16:21,470
幫了我一個忙，就像誰
實施斯特林真

1540
01:16:21,470 --> 01:16:24,790
幫了我一個忙前一段時間。

1541
01:16:24,790 --> 01:16:26,970
所以現在我們有一個
更好的設計方案

1542
01:16:26,970 --> 01:16:31,680
實現精確相同的邏輯。

1543
01:16:31,680 --> 01:16:35,580
>> 斯特林說起，讓
我繼續前進，做到這一點。

1544
01:16:35,580 --> 01:16:38,320
讓我繼續前進，保存
此文件stirling.c。

1545
01:16:38,320 --> 01:16:43,255
而事實證明，我們可以剝開
另一層倒也乾脆，現在。

1546
01:16:43,255 --> 01:16:45,630
我要繼續前進，鞭
起來主要另一個程序

1547
01:16:45,630 --> 01:16:49,759
在這裡，只需重新器具
字符串長度如下。

1548
01:16:49,759 --> 01:16:52,300
因此，這裡的代碼行
讓我從用戶的字符串。

1549
01:16:52,300 --> 01:16:53,910
我們繼續一次又一次地用這個。

1550
01:16:53,910 --> 01:16:58,900
讓我給自己一個叫做變量
存儲一些類型為int n個。

1551
01:16:58,900 --> 01:17:02,490
>> 讓我繼續前進，
請執行下列操作邏輯。

1552
01:17:02,490 --> 01:17:15,610
而s中的第n個字符不
不等於0反斜杠，繼續前進

1553
01:17:15,610 --> 01:17:17,930
和幅度值。

1554
01:17:17,930 --> 01:17:23,506
然後打印出來的printf％的I N。

1555
01:17:23,506 --> 01:17:29,200
我要求，這個方案在這裡，
沒有調用字符串長度，

1556
01:17:29,200 --> 01:17:31,150
計算出的字符串的長度。

1557
01:17:31,150 --> 01:17:34,600
>> 而神奇的是完全
包封在管線8

1558
01:17:34,600 --> 01:17:39,830
這裡看起來像新的語法，
這反斜線0單引號。

1559
01:17:39,830 --> 01:17:41,360
但是，這是為什麼？

1560
01:17:41,360 --> 01:17:44,100
那麼，考慮一下一直
事情這麼長的時間。

1561
01:17:44,100 --> 01:17:47,990
>> 而作為一個拋開我忘記之前，實現
那就是，除了手冊頁

1562
01:17:47,990 --> 01:17:50,920
附帶一個典型
Linux系統一樣CS50 IDE，

1563
01:17:50,920 --> 01:17:53,770
認識到我們的
當然的工作人員，也有

1564
01:17:53,770 --> 01:17:56,030
做了一個網站改版
這個所謂的想法一樣

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net，其具有
所有這些同一個人網頁，

1566
01:17:59,940 --> 01:18:02,020
所有相同
文檔，以及

1567
01:18:02,020 --> 01:18:05,730
在允許頂部的小盒子
你把所有的相當

1568
01:18:05,730 --> 01:18:09,025
晦澀難懂的語言變成不舒服
模式，在我們的教學人員，

1569
01:18:09,025 --> 01:18:12,150
走過了，並試圖簡化
一些讓一切語言

1570
01:18:12,150 --> 01:18:14,830
集中在思想，而不是
一些技術性的。

1571
01:18:14,830 --> 01:18:20,070
所以記住，reference.cs50.net
作為另一資源為好。

1572
01:18:20,070 --> 01:18:23,800
>> 但是，為什麼在字符串長度工作
我提出剛才的方法是什麼？

1573
01:18:23,800 --> 01:18:25,160
下面是再次Zamyla的名字。

1574
01:18:25,160 --> 01:18:27,690
而這裡的Zamyla的名字
盒裝的，因為我一直做，

1575
01:18:27,690 --> 01:18:31,360
畫它是一個圖片，
真的，只是一個字符序列。

1576
01:18:31,360 --> 01:18:34,260
但Zamyla不存在
在程序中的隔離。

1577
01:18:34,260 --> 01:18:37,420
>> 當你編寫和運行程序，
你用你的Mac或PC機

1578
01:18:37,420 --> 01:18:40,010
存儲器，或RAM可以這麼說。

1579
01:18:40,010 --> 01:18:42,620
你能想到的
您的計算機具有

1580
01:18:42,620 --> 01:18:44,730
大量內存千兆字節的這些日子。

1581
01:18:44,730 --> 01:18:47,700
而演出意味著數十億美元，
所以十億字節。

1582
01:18:47,700 --> 01:18:48,910
>> 但是，讓我們在時間上後退。

1583
01:18:48,910 --> 01:18:51,530
並假設我們使用
一個很老的計算機

1584
01:18:51,530 --> 01:18:55,150
只有32字節的內存。

1585
01:18:55,150 --> 01:18:59,310
我可以，我的電腦屏幕上，
簡單地得出這樣如下。

1586
01:18:59,310 --> 01:19:05,240
>> 我可以簡單地說，我的
計算機有這一切的內存。

1587
01:19:05,240 --> 01:19:08,830
這就好比記憶棒，如果
你還記得我們上次的圖片。

1588
01:19:08,830 --> 01:19:11,670
如果我只是劃分
這足夠的時間，

1589
01:19:11,670 --> 01:19:15,040
我主張，我有32個字節
的屏幕上存儲器。

1590
01:19:15,040 --> 01:19:18,239
>> 現在，在現實中，我只能
到目前為止，得出這樣的畫面在這裡。

1591
01:19:18,239 --> 01:19:20,280
所以我要繼續前進，
，只是按照慣例，

1592
01:19:20,280 --> 01:19:24,050
吸取我的電腦的內存作為
格，而不是僅僅為一個直線。

1593
01:19:24,050 --> 01:19:28,190
具體來說，我現在聲稱
此網格，這8個4格，

1594
01:19:28,190 --> 01:19:31,800
剛剛代表所有32個字節
在我的Mac可用內存，

1595
01:19:31,800 --> 01:19:33,030
或在我的電腦使用。

1596
01:19:33,030 --> 01:19:34,780
他們正在包裝
上兩行，只是

1597
01:19:34,780 --> 01:19:38,030
因為它適合更多的屏幕上。

1598
01:19:38,030 --> 01:19:40,800
但是，這是第一個字節。

1599
01:19:40,800 --> 01:19:41,990
這是第二個字節。

1600
01:19:41,990 --> 01:19:43,300
這是第三個字節。

1601
01:19:43,300 --> 01:19:45,310
>> 這是第32個字節。

1602
01:19:45,310 --> 01:19:52,910
或者，如果我們認為像電腦
科學家，這是字節0，1，2，3，31。

1603
01:19:52,910 --> 01:19:55,950
所以，你必須為0〜31，如果
你從0開始計數。

1604
01:19:55,950 --> 01:19:59,830
>> 因此，如果我們使用某個程序
該調用get字符串，

1605
01:19:59,830 --> 01:20:05,280
而我們從人類的字符串
像我一樣叫Zamyla，Z-A-M-Y-L-A，

1606
01:20:05,280 --> 01:20:09,430
如何在世界上做的
計算機跟踪哪些字節，

1607
01:20:09,430 --> 01:20:12,230
其中的內存塊，
屬於哪個字符串？

1608
01:20:12,230 --> 01:20:16,270
換言之，如果我們繼續
鍵入另一個名字輸入電腦，

1609
01:20:16,270 --> 01:20:19,890
像這樣的岸堤，調用
獲得字符串的第二時間，

1610
01:20:19,890 --> 01:20:23,030
A-N-D-我已經在結束了
計算機的存儲器。

1611
01:20:23,030 --> 01:20:23,850
但如何？

1612
01:20:23,850 --> 01:20:29,700
>> 那麼，事實證明，下面的
油煙機，什麼C字符串存儲什麼時候

1613
01:20:29,700 --> 01:20:35,080
該人的類型，或該
來自其他來源，它是

1614
01:20:35,080 --> 01:20:39,190
描繪它們的與端
一個特殊的character--反斜杠

1615
01:20:39,190 --> 01:20:44,750
0，這僅僅是一種特殊的方式
的說法一排80位。

1616
01:20:44,750 --> 01:20:47,950
>> 所以A--這是97號召回。

1617
01:20:47,950 --> 01:20:51,770
因此，一些8位模式
代表十進制數97。

1618
01:20:51,770 --> 01:20:58,070
這反斜杠0字面上數
0，又名NUL，N-U-L，不像早期，

1619
01:20:58,070 --> 01:20:59,630
的N- U-L-L，這是我們津津樂道。

1620
01:20:59,630 --> 01:21:05,700
但現在，只知道這
反斜線0是一排只有80位。

1621
01:21:05,700 --> 01:21:09,810
>> 而這只是該線路
沙子，說什麼向左

1622
01:21:09,810 --> 01:21:12,610
屬於一個字符串或一個數據類型。

1623
01:21:12,610 --> 01:21:15,480
和任何向右
屬於別的東西。

1624
01:21:15,480 --> 01:21:17,440
岸堤的名稱，同時，
剛剛視覺

1625
01:21:17,440 --> 01:21:21,310
發生纏繞到其他線路，
但是這只是一個審美細節，

1626
01:21:21,310 --> 01:21:23,990
同樣是NUL終止。

1627
01:21:23,990 --> 01:21:29,290
>> 這是一個A-N-D-I字符的字符串，
加上第五秘密性質，

1628
01:21:29,290 --> 01:21:33,560
所有0位，只是標定
安迪的名字的結尾為好。

1629
01:21:33,560 --> 01:21:37,120
如果我們調用get字符串第三次
在電腦中得到這樣一個字符串

1630
01:21:37,120 --> 01:21:44,210
瑪麗亞，M-A-R-I-A，同樣是瑪麗亞的
名NUL終止反斜杠0。

1631
01:21:44,210 --> 01:21:47,170
>> 這是根本不同的
如何從一台計算機通常會

1632
01:21:47,170 --> 01:21:51,850
存儲的整數，或一個浮動，或其他
數據類型仍，因為回憶，

1633
01:21:51,850 --> 01:21:57,420
的整數，通常是32位，或
4個字節，或者甚至64位，

1634
01:21:57,420 --> 01:21:59,100
或八個字節。

1635
01:21:59,100 --> 01:22:02,620
但是，在計算機的許多基元
在一種編程語言

1636
01:22:02,620 --> 01:22:05,550
具有固定數目的
在hood--下字節

1637
01:22:05,550 --> 01:22:08,100
也許1，也許2，也許4，也許8。

1638
01:22:08,100 --> 01:22:13,250
>> 但字符串，在設計上，有一個
動態字符數。

1639
01:22:13,250 --> 01:22:16,980
你不知道在前進，直到
人的類型Z-A-M-Y-L-A，

1640
01:22:16,980 --> 01:22:21,400
或M-A-R-I-A或A-N-D-I。你不知道
多少次，用戶將要擊中

1641
01:22:21,400 --> 01:22:22,070
鍵盤。

1642
01:22:22,070 --> 01:22:26,490
因此，您不知道如何
提前多少字符

1643
01:22:26,490 --> 01:22:27,540
你將需要。

1644
01:22:27,540 --> 01:22:31,840
>> 而所以C只是一種葉子像
引擎蓋下的秘密痕跡

1645
01:22:31,840 --> 01:22:32,960
在字符串的末尾。

1646
01:22:32,960 --> 01:22:39,280
存儲Z-A-M-Y-L-A在內存中後，
它也只是把等價

1647
01:22:39,280 --> 01:22:40,210
經過一段時間。

1648
01:22:40,210 --> 01:22:45,060
在一個句子的末尾，
它把80位，從而

1649
01:22:45,060 --> 01:22:49,120
要記得在哪裡
Zamyla開始和結束。

1650
01:22:49,120 --> 01:22:51,490
>> 那麼，什麼是連接，
那麼，這個計劃？

1651
01:22:51,490 --> 01:22:55,190
這裡這個程序，斯特林，
僅僅是一個機制

1652
01:22:55,190 --> 01:22:57,970
獲取一個字符串
從用戶線6。

1653
01:22:57,970 --> 01:23:01,160
7號線，我聲明一個變量
所謂的N和其設置為0。

1654
01:23:01,160 --> 01:23:08,680
>> 然後在第8行，我只是問
問題，而第n個字符不

1655
01:23:08,680 --> 01:23:12,120
不等於所有0 bits--
換句話說，不

1656
01:23:12,120 --> 01:23:14,500
等於這個特殊
字符，反斜杠0，這

1657
01:23:14,500 --> 01:23:18,470
只是特別NUL character--
繼續前進，只是幅度值。

1658
01:23:18,470 --> 01:23:21,460
>> 並繼續做下去，並保持
這樣做，並繼續做下去。

1659
01:23:21,460 --> 01:23:23,430
因此，即使在
我們使用我過去，

1660
01:23:23,430 --> 01:23:25,181
這是完全正常的
語義使用N，

1661
01:23:25,181 --> 01:23:27,430
如果你只是想
故意算上這一次，

1662
01:23:27,430 --> 01:23:28,720
只想為n調用它。

1663
01:23:28,720 --> 01:23:34,720
因此，這只是不斷問這個問題，
是第全0第n個字符？

1664
01:23:34,720 --> 01:23:38,470
如果沒有，看看下看看，
期待下，期待下，

1665
01:23:38,470 --> 01:23:39,460
期待下。

1666
01:23:39,460 --> 01:23:45,540
>> 但只要你看到反斜杠0，
這loop-- line 9至11--停止。

1667
01:23:45,540 --> 01:23:49,640
您將跳出while循環，
離開該變量n的內部

1668
01:23:49,640 --> 01:23:54,530
所有的的總數
你看到的字符串中的字符，

1669
01:23:54,530 --> 01:23:55,660
因此打印出來。

1670
01:23:55,660 --> 01:23:56,760
因此，讓我們試試這個。

1671
01:23:56,760 --> 01:23:59,500
>> 讓我繼續前進，而不
使用斯特林功能，

1672
01:23:59,500 --> 01:24:04,240
只是用我自己的版本自產自銷
這裡所說的斯特林，讓我先走

1673
01:24:04,240 --> 01:24:07,700
和運行斯特林，類型的東西
像Zamyla，這是我事先知道

1674
01:24:07,700 --> 01:24:08,670
是六個字符。

1675
01:24:08,670 --> 01:24:10,080
讓我們來看看它是否工作。

1676
01:24:10,080 --> 01:24:10,920
事實上，這是六人。

1677
01:24:10,920 --> 01:24:15,257
讓我們嘗試與Rob，三字，
三個大字，以及等等。

1678
01:24:15,257 --> 01:24:17,340
所以，這一切是怎麼回事
上罩下方。

1679
01:24:17,340 --> 01:24:19,548
並注意連接，
然後，在第一週

1680
01:24:19,548 --> 01:24:22,370
一流的，在這裡我們談到
像抽象，

1681
01:24:22,370 --> 01:24:26,960
這僅僅是這個分層的想法，或者
複雜性，對基本原則之上。

1682
01:24:26,960 --> 01:24:30,710
在這裡，我們的排序看
斯特林發動機罩下方，

1683
01:24:30,710 --> 01:24:33,510
可以這麼說，要弄清楚，
將如何實施？

1684
01:24:33,510 --> 01:24:35,232
>> 我們可以重新實現它自己。

1685
01:24:35,232 --> 01:24:37,440
但我們再也沒有去
重新實現斯特林。

1686
01:24:37,440 --> 01:24:39,780
我們只是要
使用斯特林為了

1687
01:24:39,780 --> 01:24:42,100
真正得到一些字符串的長度。

1688
01:24:42,100 --> 01:24:44,200
>> 但有沒有神奇
引擎蓋下。

1689
01:24:44,200 --> 01:24:46,716
如果你知道下面
引擎蓋，一個字符串

1690
01:24:46,716 --> 01:24:48,090
僅僅是一個字符序列。

1691
01:24:48,090 --> 01:24:51,090
和人物該序列
一切都可以解決數字

1692
01:24:51,090 --> 01:24:53,330
帶支架0，支架
1，支架2，和你

1693
01:24:53,330 --> 01:24:57,420
知道，在一個字符串的末尾是一個
特殊字符，你可以計算出

1694
01:24:57,420 --> 01:25:01,710
如何做到在任何東西
程序，因為所有它歸結為

1695
01:25:01,710 --> 01:25:03,400
在讀取和寫入內存。

1696
01:25:03,400 --> 01:25:06,130
即，在改變和尋找
在內存或搬東西

1697
01:25:06,130 --> 01:25:10,940
在內存，打印的東西
屏幕等上。

1698
01:25:10,940 --> 01:25:14,800
>> 現在讓我們用這個新發現
究竟是什麼弦樂器的理解

1699
01:25:14,800 --> 01:25:17,910
在引擎蓋下，和
剝開另一層

1700
01:25:17,910 --> 01:25:20,080
至今為止，我們已經
被完全忽略。

1701
01:25:20,080 --> 01:25:22,650
特別是，任何時間
我們已經實施了一項計劃，

1702
01:25:22,650 --> 01:25:25,930
我們已經有這行代碼
靠近頂部聲明為主。

1703
01:25:25,930 --> 01:25:27,810
我們已經指定int主要無效。

1704
01:25:27,810 --> 01:25:31,240
>> 而括號內是無效
一直說這一切的時候了主

1705
01:25:31,240 --> 01:25:33,440
本身不帶任何參數。

1706
01:25:33,440 --> 01:25:36,210
任何輸入的主要是
打算從用戶得到

1707
01:25:36,210 --> 01:25:39,020
有來自其他一些
機制，以獲得更多INT，

1708
01:25:39,020 --> 01:25:42,040
或獲得浮動，或得到的字符串，
或一些其它功能。

1709
01:25:42,040 --> 01:25:44,710
但事實證明，
當你寫一個程序，

1710
01:25:44,710 --> 01:25:47,690
實際上你可以指定
這個計劃應該

1711
01:25:47,690 --> 01:25:51,730
採取輸入從人
在命令行本身。

1712
01:25:51,730 --> 01:25:56,310
>> 換言之，儘管我們迄今為止
一直只是運行./hello打招呼

1713
01:25:56,310 --> 01:26:00,312
或類似的程序，所有的
我們已經使用過其他方案，

1714
01:26:00,312 --> 01:26:02,770
我們自己沒有寫，
一直在服用，看來，

1715
01:26:02,770 --> 01:26:05,210
命令行arguments--
之類的東西作。

1716
01:26:05,210 --> 01:26:07,450
你這樣說時許，
然後第二個字。

1717
01:26:07,450 --> 01:26:10,950
或鏗鏘，你說鐺，然後
第二字，一個文件的名稱。

1718
01:26:10,950 --> 01:26:14,410
>> 甚至RM或CP，你可能
見過或已經使用

1719
01:26:14,410 --> 01:26:15,880
刪除或複製文件。

1720
01:26:15,880 --> 01:26:18,920
所有那些採取所謂的
命令行arguments--

1721
01:26:18,920 --> 01:26:21,130
在終端提示其他單詞。

1722
01:26:21,130 --> 01:26:23,260
但是到現在為止，我們
自己還沒有

1723
01:26:23,260 --> 01:26:27,080
這家豪華的同時從輸入
用戶在他或她實際運行

1724
01:26:27,080 --> 01:26:29,120
在命令行程序本身。

1725
01:26:29,120 --> 01:26:33,710
>> 但是，我們可以做到這一點通過重新申報
主要的前進，而不是有

1726
01:26:33,710 --> 01:26:36,750
無效括號中，
但是這兩種說法

1727
01:26:36,750 --> 01:26:40,600
instead--第一的整數，
和第二事

1728
01:26:40,600 --> 01:26:44,170
新的東西，我們要打電話
一個數組，在精神上類似的東西

1729
01:26:44,170 --> 01:26:49,220
什麼，我們在看到划痕作為一個列表，但
字符串數組，因為我們很快就會看到。

1730
01:26:49,220 --> 01:26:51,790
但是讓我們通過看到這個
舉例來說，以前我們

1731
01:26:51,790 --> 01:26:53,690
正是分辨是什麼意思。

1732
01:26:53,690 --> 01:26:56,520
>> 所以，如果我進入CS50 IDE
在這裡，我已經先行一步

1733
01:26:56,520 --> 01:27:01,840
而在一個名為文件中聲明
argv0.c以下模板。

1734
01:27:01,840 --> 01:27:04,120
並注意唯一
這是不同的，到目前為止

1735
01:27:04,120 --> 01:27:08,570
是，我已經改變了空為int
ARGC ARGV串開支架，接近

1736
01:27:08,570 --> 01:27:09,070
托架。

1737
01:27:09,070 --> 01:27:11,730
並注意現在，有
沒有這些括號內。

1738
01:27:11,730 --> 01:27:12,620
>> 有沒有數。

1739
01:27:12,620 --> 01:27:15,070
而且沒有我，或
n或任何其他字母。

1740
01:27:15,070 --> 01:27:17,010
我只是用
方括號現在，

1741
01:27:17,010 --> 01:27:19,510
對於原因，我們會來
回到一會兒就好了。

1742
01:27:19,510 --> 01:27:21,330
>> 而現在正是我要做的就是這一點。

1743
01:27:21,330 --> 01:27:26,680
如果ARGC等於等於2--
和召回等於等號

1744
01:27:26,680 --> 01:27:30,040
是平等的運營商比較
左和右的平等。

1745
01:27:30,040 --> 01:27:31,790
這不是分配
操作者，這是

1746
01:27:31,790 --> 01:27:36,510
單等號，這意味著副本
從右側向左側的一些值。

1747
01:27:36,510 --> 01:27:42,840
>> 如果ARGC等於等於2，我想
比如說，printf的，你好，百分數，新的生產線，

1748
01:27:42,840 --> 01:27:47,340
然後再插上in--和這裡的新
trick-- argv的支架1，其原因

1749
01:27:47,340 --> 01:27:48,840
我們再回過頭來在一個時刻。

1750
01:27:48,840 --> 01:27:52,110
如果ARGC沒有別的
等於2，你知道嗎？

1751
01:27:52,110 --> 01:27:57,400
就讓我們繼續前進，像往常一樣，打印
出打招呼，沒有替代的世界。

1752
01:27:57,400 --> 01:28:02,710
>> 所以它似乎如果ARGC，這
代表論點數，等於2，

1753
01:28:02,710 --> 01:28:04,740
我要打印出來
你好或其他東西。

1754
01:28:04,740 --> 01:28:07,560
否則，默認情況下，我
要打印的hello world。

1755
01:28:07,560 --> 01:28:08,770
所以，這是什麼意思？

1756
01:28:08,770 --> 01:28:15,550
>> 好吧，讓我繼續前進，保存
該文件，然後執行使argv0，

1757
01:28:15,550 --> 01:28:18,940
然後./argv0，回車。

1758
01:28:18,940 --> 01:28:20,300
它的世界問好。

1759
01:28:20,300 --> 01:28:21,260
現在，這是為什麼？

1760
01:28:21,260 --> 01:28:24,730
>> 那麼，事實證明，任何時候你
在命令行中運行一個程序，

1761
01:28:24,730 --> 01:28:29,570
你都盡顯我們會
通常調用的參數向量。

1762
01:28:29,570 --> 01:28:33,100
換句話說，自動
計算機，操作系統，

1763
01:28:33,100 --> 01:28:38,340
是要交給你的程序
本身所有的單詞列表

1764
01:28:38,340 --> 01:28:40,850
該人的類型在
提示，如果你

1765
01:28:40,850 --> 01:28:43,790
程序員想要做的
一些與該信息。

1766
01:28:43,790 --> 01:28:48,540
並且在這種情況下，唯一字
我在提示符下鍵入是./argv0。

1767
01:28:48,540 --> 01:28:55,420
>> 等參數的數目是
被傳遞到我的計劃是只有一個。

1768
01:28:55,420 --> 01:28:58,880
換言之，參數
算，也稱為ARGC

1769
01:28:58,880 --> 01:29:00,970
這裡為整數，只是其中的一個。

1770
01:29:00,970 --> 01:29:03,000
一，當然不相等的兩個。

1771
01:29:03,000 --> 01:29:05,980
所以這就是打印，世界你好。

1772
01:29:05,980 --> 01:29:08,170
>> 但讓​​我借這個地方。

1773
01:29:08,170 --> 01:29:09,930
讓我說，argv0。

1774
01:29:09,930 --> 01:29:12,740
然後怎麼樣瑪麗亞？

1775
01:29:12,740 --> 01:29:14,990
然後按Enter鍵。

1776
01:29:14,990 --> 01:29:18,020
>> 並注意什麼神奇地發生在這裡。

1777
01:29:18,020 --> 01:29:22,640
現在，而不是世界你好，我有
改變了這個程序的行為

1778
01:29:22,640 --> 01:29:26,310
由GET取輸入不
串或一些其它功能，

1779
01:29:26,310 --> 01:29:30,570
但很顯然，我的命令
本身，我在原來錄入。

1780
01:29:30,570 --> 01:29:35,720
我可以再次玩這個遊戲
它改變到斯泰利奧斯，例如。

1781
01:29:35,720 --> 01:29:38,400
>> 現在我看到另一名仍在。

1782
01:29:38,400 --> 01:29:40,540
而在這裡，我可以說安迪。

1783
01:29:40,540 --> 01:29:42,137
我可能會說Zamyla。

1784
01:29:42,137 --> 01:29:45,220
我們可以整天玩這個遊戲，
只是不同的價值觀堵漏，

1785
01:29:45,220 --> 01:29:49,550
只要我正好提供
兩個詞在提示符下，

1786
01:29:49,550 --> 01:29:52,260
這樣ARGC，我的說法算，為2。

1787
01:29:52,260 --> 01:29:57,240
>> 我看到這個名字插入
printf的，每個在這裡這種情況？

1788
01:29:57,240 --> 01:30:00,550
所以，我們現在似乎有
的表現力

1789
01:30:00,550 --> 01:30:04,410
採取從其他機構中的輸入，
從所謂的命令行

1790
01:30:04,410 --> 01:30:07,000
而不必等待
直到用戶運行該程序，

1791
01:30:07,000 --> 01:30:10,220
然後提示他或她的
使用類似的GET字符串。

1792
01:30:10,220 --> 01:30:11,230
>> 所以，這是什麼？

1793
01:30:11,230 --> 01:30:15,010
的argc，再次，僅僅是一個整數，
words-- arguments--數

1794
01:30:15,010 --> 01:30:18,540
，在所提供的用戶
提示時，在終端窗口，

1795
01:30:18,540 --> 01:30:20,110
包括程序的名字。

1796
01:30:20,110 --> 01:30:23,340
因此，我們./argv0是有效的，
該程序的名字，

1797
01:30:23,340 --> 01:30:24,520
或如何我運行程序。

1798
01:30:24,520 --> 01:30:25,810
>> 這算作一個字。

1799
01:30:25,810 --> 01:30:27,080
所以ARGC是1。

1800
01:30:27,080 --> 01:30:29,750
但是，當我寫斯泰利奧斯，或
岸堤，或Zamyla或瑪麗亞，

1801
01:30:29,750 --> 01:30:31,660
這意味著參數計數為兩個。

1802
01:30:31,660 --> 01:30:33,910
所以現在有兩個詞傳入。

1803
01:30:33,910 --> 01:30:36,070
>> 和通知，我們可以繼續這樣的邏輯。

1804
01:30:36,070 --> 01:30:39,050
如果我居然說
像陳Zamyla，

1805
01:30:39,050 --> 01:30:42,200
全名，從而把
三個參數共，

1806
01:30:42,200 --> 01:30:47,410
現在它再次表示默認，
因為，當然，3不等於2。

1807
01:30:47,410 --> 01:30:54,080
>> 所以這樣，我必須
通過argv的這個新說法訪問

1808
01:30:54,080 --> 01:30:56,080
我們可以在技術上
叫我們想要的東西。

1809
01:30:56,080 --> 01:30:58,940
但按照慣例，這是
的argv和ARGC，分別為。

1810
01:30:58,940 --> 01:31:04,470
ARGV，參數向量，是種
用於編程的代名詞

1811
01:31:04,470 --> 01:31:07,140
用C功能稱為數組。

1812
01:31:07,140 --> 01:31:14,410
>> 陣列是類似的值的列表
背，背，背，背到。

1813
01:31:14,410 --> 01:31:17,810
換句話說，如果一個是這裡在
RAM，下一個是它旁邊，

1814
01:31:17,810 --> 01:31:18,800
和它旁邊。

1815
01:31:18,800 --> 01:31:20,101
他們不是所有的地方。

1816
01:31:20,101 --> 01:31:23,100
而這後一種情況下，這裡的東西
遍布在內存中的位置，

1817
01:31:23,100 --> 01:31:25,082
實際上可以是一個強大的功能。

1818
01:31:25,082 --> 01:31:28,040
但我們會回來的，我們當
說說票友的數據結構。

1819
01:31:28,040 --> 01:31:32,260
現在，數組只是一個
連續內存塊，

1820
01:31:32,260 --> 01:31:36,520
每個其元素
背，背，背，背，

1821
01:31:36,520 --> 01:31:38,050
和大致相同的類型。

1822
01:31:38,050 --> 01:31:42,630
>> 所以，如果你仔細想想，從
剛才，什麼是字符串？

1823
01:31:42,630 --> 01:31:50,460
那麼，一個字符串，如Zamyla，
Z-A-M-Y-L-A，是，技術上，

1824
01:31:50,460 --> 01:31:51,400
只是陣列。

1825
01:31:51,400 --> 01:31:53,700
它是一個字符數組。

1826
01:31:53,700 --> 01:31:59,250
>> 所以，如果我們真的得出這樣的，因為我
先前做的，作為一個內存塊，

1827
01:31:59,250 --> 01:32:04,510
事實證明，每一種
字符佔用一個字節。

1828
01:32:04,510 --> 01:32:07,630
然後還有那個特別的
標記字符，反斜線0，

1829
01:32:07,630 --> 01:32:12,360
或全部八個0位，即
劃定該字符串的結尾。

1830
01:32:12,360 --> 01:32:15,090
因此，一個字符串，它變成
出，報價引文結束的字符串，

1831
01:32:15,090 --> 01:32:20,580
只是chara--的陣列
燒焦作為一個實際的數據類型。

1832
01:32:20,580 --> 01:32:24,560
>> 而現在的argv，meanwhile--
讓我們回到節目。

1833
01:32:24,560 --> 01:32:29,582
ARGV，儘管我們看到這個詞
這裡的字符串，是不是字符串本身。

1834
01:32:29,582 --> 01:32:33,640
ARGV，參數向量，
是一個字符串數組。

1835
01:32:33,640 --> 01:32:37,620
>> 因此，正如你可以有數組
字符，你可以有較高的水平，

1836
01:32:37,620 --> 01:32:46,279
的strings--陣列如此，例如，
當我輸入剛才./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0，空間Z-A-M-Y-L-A，我聲稱，
ARGV曾在它 -  ./argv0兩個字符串，

1838
01:33:00,150 --> 01:33:03,185
和Z-A-M-Y-L-A。在
換句話說，的argc為2。

1839
01:33:03,185 --> 01:33:03,980
這是為什麼？

1840
01:33:03,980 --> 01:33:08,370
>> 那麼，有效的，這是怎麼回事
上是每個這些字符串的

1841
01:33:08,370 --> 01:33:13,990
是，當然，字符數組
和以前一樣，它的每個字符

1842
01:33:13,990 --> 01:33:15,670
佔用一個字節。

1843
01:33:15,670 --> 01:33:19,720
不要混淆實際0
在節目的標有0名，

1844
01:33:19,720 --> 01:33:22,040
這意味著所有80位。

1845
01:33:22,040 --> 01:33:27,140
和Zamyla，同時，仍
也字符數組。

1846
01:33:27,140 --> 01:33:31,450
>> 這樣在一天結束時，它確實
看起來是這樣的引擎蓋下面。

1847
01:33:31,450 --> 01:33:38,800
但是ARGV，由大自然如何主力
作品，讓我來包裝這一切

1848
01:33:38,800 --> 01:33:44,810
成，如果你願意，一個更大的陣列
，如果我們稍稍高出簡化

1849
01:33:44,810 --> 01:33:48,180
什麼畫面看起來喜歡和不
相當繪製規模那裡，

1850
01:33:48,180 --> 01:33:56,720
這個陣列只有大小為2，第一次
元件，它的包含字符串，

1851
01:33:56,720 --> 01:33:59,230
的第二元件
其中包含的字符串。

1852
01:33:59,230 --> 01:34:01,687
並且，反過來，如果
一種放大每個

1853
01:34:01,687 --> 01:34:03,770
這些字符串的你
看到引擎蓋下

1854
01:34:03,770 --> 01:34:07,190
是，每串是僅僅
字符數組。

1855
01:34:07,190 --> 01:34:11,680
>> 現在，就如同用字符串，
我們能夠獲得訪問

1856
01:34:11,680 --> 01:34:15,260
在一個字符串的第i個字符
使用方括號。

1857
01:34:15,260 --> 01:34:17,320
同樣，陣列
一般來說，我們可以

1858
01:34:17,320 --> 01:34:22,700
用方括號來獲得
在陣列中的任何數量的字符串？

1859
01:34:22,700 --> 01:34:25,100
例如，讓我
繼續前進，做到這一點。

1860
01:34:25,100 --> 01:34:32,420
>> 讓我繼續前進，創造argv1.c，
這是一個有點不同，這一次。

1861
01:34:32,420 --> 01:34:35,635
相反，檢查argc2的，
我要代替做到這一點。

1862
01:34:35,635 --> 01:34:41,270
對於int我得到0，我是少
比ARGC，我加再加，

1863
01:34:41,270 --> 01:34:47,920
然後這裡面打印出來，
％的S，新的生產線，然後

1864
01:34:47,920 --> 01:34:50,740
argv的支架我。

1865
01:34:50,740 --> 01:34:55,220
>> 因此，換句話說，我不處理
此刻單個字符。

1866
01:34:55,220 --> 01:35:00,190
ARGV，所暗示這些空方
括號的名稱的argv的權利，

1867
01:35:00,190 --> 01:35:03,320
指的argv是一個字符串數組。

1868
01:35:03,320 --> 01:35:04,870
和ARGC只是一個int。

1869
01:35:04,870 --> 01:35:08,800
>> 在這裡這條線，6是
說一套i等於0。

1870
01:35:08,800 --> 01:35:11,980
計算所有達路，
但不包括的argc。

1871
01:35:11,980 --> 01:35:14,010
然後在每次迭代中，
打印出字符串。

1872
01:35:14,010 --> 01:35:14,800
什麼字符串？

1873
01:35:14,800 --> 01:35:17,270
>> 第i個字符串argv中。

1874
01:35:17,270 --> 01:35:19,530
所以，從前我是前
用方括號

1875
01:35:19,530 --> 01:35:22,180
方式就可以得到第i
字符的字符串，現在

1876
01:35:22,180 --> 01:35:27,240
我用方括號
獲得在一個數組的第i個字符串。

1877
01:35:27,240 --> 01:35:30,310
因此，它是一種一層
以上概念。

1878
01:35:30,310 --> 01:35:35,390
>> 還等什麼是整齊這個
現在的程序，如果我編譯argv1，

1879
01:35:35,390 --> 01:35:42,067
然後做./argv1，然後鍵入
在類似富酒吧巴茲，

1880
01:35:42,067 --> 01:35:45,400
這是三個默認的話，一個
計算機科學家到達任何時間

1881
01:35:45,400 --> 01:35:51,010
他或她需要一些佔位的話，
並按下回車鍵，每一個的這些話，

1882
01:35:51,010 --> 01:35:54,980
包括程序的名稱，
是argv中在第一位置，

1883
01:35:54,980 --> 01:35:58,320
最終被印刷一次一個。

1884
01:35:58,320 --> 01:36:05,290
如果我改變這一點，我說
像argv1 Zamyla陳，

1885
01:36:05,290 --> 01:36:08,800
我們得到了所有這三個的
也就是說，這是argv0，

1886
01:36:08,800 --> 01:36:14,400
argv1，argv2，因為在這種
ARGC的情況下，計數，為3。

1887
01:36:14,400 --> 01:36:20,020
>> 但是，什麼是整齊的是，如果你明白
那argv的只是一個字符串數組，

1888
01:36:20,020 --> 01:36:24,910
你明白一個字符串
是一個字符數組，

1889
01:36:24,910 --> 01:36:29,470
我們實際上可以種使用該
方括號多次

1890
01:36:29,470 --> 01:36:33,320
選擇一個字符串，然後選擇
字符串中的字符，

1891
01:36:33,320 --> 01:36:35,730
潛水更深如下。

1892
01:36:35,730 --> 01:36:40,100
在這個例子中，讓我去
前進，稱之為argv2.c。

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
而在這個例子中，讓我先走
並做following--對於int我得到0，

1895
01:36:50,180 --> 01:36:53,286
i小於的argc，我加
再加上，就像以前一樣。

1896
01:36:53,286 --> 01:36:55,910
因此，在其他words--現在這個
越來越複雜的足夠了。

1897
01:36:55,910 --> 01:36:59,940
然後我會說
遍歷argv中的字符串，

1898
01:36:59,940 --> 01:37:01,294
作為對自己的註釋。

1899
01:37:01,294 --> 01:37:03,960
然後我將有一個
嵌套的循環，你可能

1900
01:37:03,960 --> 01:37:06,290
這樣做，或認為
這樣做，在划痕，其中

1901
01:37:06,290 --> 01:37:08,600
我要說int--我
不會再使用我，

1902
01:37:08,600 --> 01:37:12,590
因為我不想影子，或
排序覆蓋現有的我。

1903
01:37:12,590 --> 01:37:15,780
>> 我打算，相反，J個，因為
這是我去到的變量後，我，

1904
01:37:15,780 --> 01:37:18,590
當我只是想
算簡單的數字。

1905
01:37:18,590 --> 01:37:28,850
對於j得到0--並且還，正，將要
得到的argv支架我的船尾長，

1906
01:37:28,850 --> 01:37:36,030
只要j是小於M，
Ĵ加再加，做到以下幾點。

1907
01:37:36,030 --> 01:37:37,500
而這裡的有趣的部分。

1908
01:37:37,500 --> 01:37:46,330
>> 打印出一個字符和一個新的生產線，
堵漏argv中我支架，支​​架學家

1909
01:37:46,330 --> 01:37:47,940
好了，讓我在這裡補充一些意見。

1910
01:37:47,940 --> 01:37:54,820
遍歷字符
在當前字符串，

1911
01:37:54,820 --> 01:38:02,290
在第i個字符串打印j個字符。

1912
01:38:02,290 --> 01:38:04,630
所以，現在，讓我們考慮
這是什麼意思的意見。

1913
01:38:04,630 --> 01:38:06,750
>> 遍歷字符串
在argv--多少

1914
01:38:06,750 --> 01:38:09,300
字符串的argv，它是一個數組？

1915
01:38:09,300 --> 01:38:13,420
ARGC很多，所以我遍歷
從i等於0到ARGC。

1916
01:38:13,420 --> 01:38:20,020
同時，多少個字符
是argv中的第i個字符串中？

1917
01:38:20,020 --> 01:38:22,880
>> 好了，得到的答案，
我只需要調用字符串長度

1918
01:38:22,880 --> 01:38:26,810
在當前字符串我照顧
對，這是argv的支架我。

1919
01:38:26,810 --> 01:38:30,090
我要去臨時存儲
值N，只是為了緩存目的，

1920
01:38:30,090 --> 01:38:31,590
記住它的效率。

1921
01:38:31,590 --> 01:38:36,330
然後，我會初始化J即可0，
繼續下去，只要j是小於n，

1922
01:38:36,330 --> 01:38:38,430
並在每次迭代增量學家

1923
01:38:38,430 --> 01:38:41,030
>> 然後在這裡，每
我的第12行評論，

1924
01:38:41,030 --> 01:38:43,390
打印出一個字符，
其次是一個新行，

1925
01:38:43,390 --> 01:38:48,140
具體的argv支架
我給我的第i個串

1926
01:38:48,140 --> 01:38:51,690
在argv--所以第一句話，
第二個字，第三字，等等。

1927
01:38:51,690 --> 01:38:57,370
和則J潛水更深，並獲得
我該單詞的第j個字符。

1928
01:38:57,370 --> 01:39:02,200
因此，實際上，你可以把
的argv作為多維的，

1929
01:39:02,200 --> 01:39:06,050
作為一個二維的，陣列
其中的每一個字那種長相

1930
01:39:06,050 --> 01:39:08,580
像這樣在你的心中的
眼，每一個人物

1931
01:39:08,580 --> 01:39:10,930
是種組成，在
一列，是否有幫助。

1932
01:39:10,930 --> 01:39:13,260
>> 在現實中，當我們逗
這除了在未來數週，

1933
01:39:13,260 --> 01:39:15,580
這將是一個小
比這更複雜。

1934
01:39:15,580 --> 01:39:17,800
但是，你可真
想不到的是，就目前而言，

1935
01:39:17,800 --> 01:39:22,110
因為眼前這個二維
它陣列，其中一個水平

1936
01:39:22,110 --> 01:39:23,260
是所有的字符串。

1937
01:39:23,260 --> 01:39:26,760
然後，如果你在更深，你潛水
可以得到在各個字符

1938
01:39:26,760 --> 01:39:29,600
這裡所使用這個符號在其中。

1939
01:39:29,600 --> 01:39:31,620
>> 那麼，什麼是實際效果？

1940
01:39:31,620 --> 01:39:34,970
讓我繼續前進，
使argv2--織補它。

1941
01:39:34,970 --> 01:39:36,210
我在這裡犯了一個錯誤。

1942
01:39:36,210 --> 01:39:40,160
隱含聲明
庫函數斯特林。

1943
01:39:40,160 --> 01:39:42,190
所以，這一切的時候，它的
也許是適當的

1944
01:39:42,190 --> 01:39:45,130
我們正在排序整理
正是我們開始的地方。

1945
01:39:45,130 --> 01:39:48,160
>> 我搞砸了，隱式聲明
庫函數斯特林。

1946
01:39:48,160 --> 01:39:48,987
OK，等一下。

1947
01:39:48,987 --> 01:39:51,070
我記得，尤其是
因為它是在這裡。

1948
01:39:51,070 --> 01:39:54,490
我需要包括string.h中的
這個版本的程序。

1949
01:39:54,490 --> 01:40:00,050
>> 讓我繼續前進，包括
string.h中，保存，勇往直前

1950
01:40:00,050 --> 01:40:04,460
並重新編譯argv2。

1951
01:40:04,460 --> 01:40:08,390
而現在，我們開始吧，讓argv2，回車。

1952
01:40:08,390 --> 01:40:10,590
雖然這是一個有點
神秘的第一眼，

1953
01:40:10,590 --> 01:40:15,690
公告稱，的確，
印刷是點argv2。

1954
01:40:15,690 --> 01:40:19,970
>> 但是，如果我輸入後有些字
提示，像argv2 Zamyla陳，

1955
01:40:19,970 --> 01:40:22,560
回車，也有點
神秘的第一眼。

1956
01:40:22,560 --> 01:40:30,540
但是，如果我們滾動回漲，
./argv2 Z-A-M-Y-L-A C-H-A-N。

1957
01:40:30,540 --> 01:40:32,190
因此，我們遍歷每一個字。

1958
01:40:32,190 --> 01:40:37,770
而反過來，我們遍歷
一個字中的每一個字符。

1959
01:40:37,770 --> 01:40:40,040
>> 現在，經過這一切，
意識到有

1960
01:40:40,040 --> 01:40:43,120
另外一個細節，我們已經種
中忽略這一整個時間。

1961
01:40:43,120 --> 01:40:46,180
我們只是挑開什麼
主要的投入可以嗎？

1962
01:40:46,180 --> 01:40:47,780
怎麼樣主要的輸出？

1963
01:40:47,780 --> 01:40:50,540
>> 所有這一切的時候，我們一直
只是複製和粘貼

1964
01:40:50,540 --> 01:40:53,870
在主陣地字INT，
雖然你可能在網上看到，

1965
01:40:53,870 --> 01:40:58,340
有時在舊版本不正確
C和編譯器的，他們說無效，

1966
01:40:58,340 --> 01:40:59,410
還是什麼都沒有。

1967
01:40:59,410 --> 01:41:01,580
但是，實際上，對於版本
的C我們使用，

1968
01:41:01,580 --> 01:41:06,180
C 11，或2011年，實現
它應該是int。

1969
01:41:06,180 --> 01:41:09,300
它應該要么是
無效或argc和argv在這裡。

1970
01:41:09,300 --> 01:41:10,790
>> 但是，為什麼INT主？

1971
01:41:10,790 --> 01:41:12,480
它是什麼實際上返回？

1972
01:41:12,480 --> 01:41:16,280
那麼，事實證明這一切的時候，
任何時候你已經寫了一個程序的主

1973
01:41:16,280 --> 01:41:18,440
總是返回的東西。

1974
01:41:18,440 --> 01:41:19,960
但它一直這樣做秘密。

1975
01:41:19,960 --> 01:41:23,350
>> 這東西是
INT，如第5行顯示。

1976
01:41:23,350 --> 01:41:24,225
但是什麼詮釋？

1977
01:41:24,225 --> 01:41:26,100
嗯，有這個
約定編程，

1978
01:41:26,100 --> 01:41:29,790
因此，如果沒有了
出了問題，一切都很好，

1979
01:41:29,790 --> 01:41:34,250
程序和一般功能
return--有些counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0。

1981
01:41:35,230 --> 01:41:38,070
0通常意味著一切都很好。

1982
01:41:38,070 --> 01:41:40,610
因此，即使你覺得
它在很多情況下是假的，

1983
01:41:40,610 --> 01:41:42,930
它實際上通常意味著一件好事

1984
01:41:42,930 --> 01:41:49,560
>> 同時，如果一個程序返回1，
或負1，或5，或負42

1985
01:41:49,560 --> 01:41:52,941
或任何非0的值，
這通常意味著

1986
01:41:52,941 --> 01:41:54,190
那出了問題。

1987
01:41:54,190 --> 01:41:56,700
事實上，在你自己的Mac或PC，
你可能已經看到實際

1988
01:41:56,700 --> 01:42:01,050
的錯誤消息，由此
說了什麼或其他錯誤

1989
01:42:01,050 --> 01:42:04,940
代碼負42，或錯誤代碼
23，或者類似的東西。

1990
01:42:04,940 --> 01:42:08,980
這個數字通常是只是一個提示
給程序員，或公司

1991
01:42:08,980 --> 01:42:11,174
該取得的軟件，
什麼地方出了錯，為什麼，

1992
01:42:11,174 --> 01:42:13,590
使他們可以通過看
他們的文檔或代碼，

1993
01:42:13,590 --> 01:42:15,465
並找出什麼
錯誤實際上意味著。

1994
01:42:15,465 --> 01:42:18,400
它一般不
對我們有用的最終用戶。

1995
01:42:18,400 --> 01:42:20,550
>> 但是，當主返回0，一切都很好。

1996
01:42:20,550 --> 01:42:23,770
如果你不指定
什麼主要應返回，

1997
01:42:23,770 --> 01:42:26,950
它只是會自動
你返回0。

1998
01:42:26,950 --> 01:42:30,870
但返回的東西
否則實際上是有用的。

1999
01:42:30,870 --> 01:42:34,660
>> 在這最後的節目，讓我
繼續前進，把這個exit.c中，

2000
01:42:34,660 --> 01:42:38,630
並介紹了去年今天的
主題，已知的作為錯誤代碼。

2001
01:42:38,630 --> 01:42:42,930
讓我繼續前進，包括我們
熟悉的文件往上頂，這樣做主要INT。

2002
01:42:42,930 --> 01:42:49,500
而這個時候，讓我們做INT ARGC，
字符串的argv，並與我的支架

2003
01:42:49,500 --> 01:42:50,836
暗示它的數組中為止。

2004
01:42:50,836 --> 01:42:52,460
然後讓我只是做一個全面的檢查。

2005
01:42:52,460 --> 01:42:56,640
這個時候，如果ARGC不
等於2，那麼你知道嗎？

2006
01:42:56,640 --> 01:42:57,520
算了吧。

2007
01:42:57,520 --> 01:43:03,170
我會說，嘿，用戶，
你缺少命令行參數

2008
01:43:03,170 --> 01:43:04,210
反斜杠ñ。

2009
01:43:04,210 --> 01:43:05,230
>> 然後就是這樣。

2010
01:43:05,230 --> 01:43:06,130
我想退出。

2011
01:43:06,130 --> 01:43:11,030
我要先發製人，
過早真的，回報

2012
01:43:11,030 --> 01:43:12,810
東西比1號等。

2013
01:43:12,810 --> 01:43:15,360
轉到價值第一
錯誤可能發生1。

2014
01:43:15,360 --> 01:43:17,860
如果你有一些其他錯誤
可能出現的情況，

2015
01:43:17,860 --> 01:43:21,390
你可能會說回報2或3回，或
甚至負1或負2。

2016
01:43:21,390 --> 01:43:23,750
>> 這些只是退出代碼
是，一般地，

2017
01:43:23,750 --> 01:43:27,770
唯一有用給程序員，或
公司認為航運該軟件。

2018
01:43:27,770 --> 01:43:30,500
但事實上，它是
不為0是非常重要的。

2019
01:43:30,500 --> 01:43:34,310
所以，如果在這個方案，我想
保證這個程序只

2020
01:43:34,310 --> 01:43:38,190
工作，如果用戶提供了我
有兩個參數計數，

2021
01:43:38,190 --> 01:43:42,880
程序的名字，以及其他一些
總之，我可以執行如下之多，

2022
01:43:42,880 --> 01:43:46,110
罵與printf的話說用戶，
缺少命令行參數，

2023
01:43:46,110 --> 01:43:46,970
返回1。

2024
01:43:46,970 --> 01:43:49,940
這只會立即
退出程序。

2025
01:43:49,940 --> 01:43:55,840
>> 只有當ARGC等於2，我們將踏踏實實
在這裡，在這一點上，我會說，

2026
01:43:55,840 --> 01:44:00,410
你好％的S，反斜線N，argv1。

2027
01:44:00,410 --> 01:44:03,827
換句話說，我
argv的0後不會去，

2028
01:44:03,827 --> 01:44:05,410
這是節目的只是名稱。

2029
01:44:05,410 --> 01:44:09,450
我想打印出來打招呼，逗號，
第二個字，人鍵入。

2030
01:44:09,450 --> 01:44:12,580
在這種情況下上
13號線，一切都很好。

2031
01:44:12,580 --> 01:44:15,920
>> 我知道的argc為2
邏輯上這個節目。

2032
01:44:15,920 --> 01:44:17,770
我要繼續前進，返回0。

2033
01:44:17,770 --> 01:44:21,230
順便說一句，請記住，
這是划痕也是如此。

2034
01:44:21,230 --> 01:44:24,760
>> 從邏輯上講，我可以這樣做
和封裝這些行

2035
01:44:24,760 --> 01:44:27,020
在這裡這個else子句的代碼。

2036
01:44:27,020 --> 01:44:29,420
但是，這樣的
不必要的縮進我的代碼。

2037
01:44:29,420 --> 01:44:31,800
我想使超
顯然，不管是什麼，

2038
01:44:31,800 --> 01:44:34,670
默認情況下，你好
事情會得到印，

2039
01:44:34,670 --> 01:44:36,050
只要用戶合作。

2040
01:44:36,050 --> 01:44:39,360
>> 所以這是很常見的使用
一個條件，只是一個如果，

2041
01:44:39,360 --> 01:44:41,870
捕捉一些錯誤
情況，然後退出。

2042
01:44:41,870 --> 01:44:45,690
然後，只要一切
好了，沒有一個東西，

2043
01:44:45,690 --> 01:44:48,060
只是有碼
外，如果，因為它是

2044
01:44:48,060 --> 01:44:51,060
相當於在這
特殊情況下，邏輯上。

2045
01:44:51,060 --> 01:44:54,480
所以我返回0，只是
明確表示一切都很好。

2046
01:44:54,480 --> 01:44:58,480
>> 如果我省略了返回0時，它會
自動假設我。

2047
01:44:58,480 --> 01:45:00,890
但現在，我要回
之一的至少這種情況下，

2048
01:45:00,890 --> 01:45:04,940
我要去，好措施和
清楚起見，在這種情況下返回0。

2049
01:45:04,940 --> 01:45:09,690
所以，現在讓我繼續前進，使退出，
這是一個完美的SEGUE見好就收。

2050
01:45:09,690 --> 01:45:14,401
>> 但要退出，讓我去
繼續做./exit，回車。

2051
01:45:14,401 --> 01:45:16,900
該程序大喊我，
缺少命令行參數。

2052
01:45:16,900 --> 01:45:18,120
OK，讓我配合。

2053
01:45:18,120 --> 01:45:23,810
>> 讓我來代替做./exit，大衛，回車。

2054
01:45:23,810 --> 01:45:25,190
而現在它說，你好大衛。

2055
01:45:25,190 --> 01:45:27,300
你通常不會看到這一點。

2056
01:45:27,300 --> 01:45:30,650
>> 但事實證明，有一個
在Linux中特殊的方式來實際看看

2057
01:45:30,650 --> 01:45:34,470
什麼退出代碼的程序退出。

2058
01:45:34,470 --> 01:45:37,184
有時在圖形
世界像的Mac OS或Windows，

2059
01:45:37,184 --> 01:45:40,100
你只看到這些數字時
錯誤消息在屏幕上彈出

2060
01:45:40,100 --> 01:45:41,940
和編程
顯示了該號碼。

2061
01:45:41,940 --> 01:45:44,773
但是，如果我們想看到什麼錯誤
消息是，我們可以做到這一點這裡 - 

2062
01:45:44,773 --> 01:45:48,100
所以./exit，輸入，打印
缺少命令行參數。

2063
01:45:48,100 --> 01:45:54,590
>> 如果我現在做的迴聲$？這是
可笑的神秘期待。

2064
01:45:54,590 --> 01:45:56,590
但是$？

2065
01:45:56,590 --> 01:45:59,220
是神奇的咒語
，說，哎，電腦，

2066
01:45:59,220 --> 01:46:01,900
告訴我以前的
程序的退出代碼了。

2067
01:46:01,900 --> 01:46:03,410
我敲回車。

2068
01:46:03,410 --> 01:46:07,520
我看到1，因為這是我
告訴我的主要功能返回。

2069
01:46:07,520 --> 01:46:12,310
>> 同時，如果我這樣做./exit大衛
並按下回車鍵，我明白了，你好大衛。

2070
01:46:12,310 --> 01:46:16,800
如果我現在做的迴聲$？我看你好0。

2071
01:46:16,800 --> 01:46:19,080
所以這實際上
是有價值的信息

2072
01:46:19,080 --> 01:46:23,420
在調試器的情況下，不那麼
多，你的人，會照顧。

2073
01:46:23,420 --> 01:46:26,060
但是，調試器和其他
程序，我們將利用這個學期

2074
01:46:26,060 --> 01:46:29,420
會經常看這個數字，
儘管這有點藏起來

2075
01:46:29,420 --> 01:46:32,780
除非你去找吧，
確定是否一個程序的

2076
01:46:32,780 --> 01:46:37,050
執行是正確或不正確的。

2077
01:46:37,050 --> 01:46:40,450
>> 所以說給我們帶來
此，在一天結束。

2078
01:46:40,450 --> 01:46:43,917
今天，我們開始通過查看
調試，並依次在課程

2079
01:46:43,917 --> 01:46:46,750
本身，然後更有趣的是，
技術上下方的引擎蓋

2080
01:46:46,750 --> 01:46:49,490
在什麼字符串，它持續
本週我們只是想當然，

2081
01:46:49,490 --> 01:46:51,900
當然把他們
理所當然的划痕。

2082
01:46:51,900 --> 01:46:56,040
>> 然後，我們看我們如何可以訪問
在一個字符串的各個字符，

2083
01:46:56,040 --> 01:47:00,310
然後又拿起一個較高的水平
看待事物，尋求如何well--

2084
01:47:00,310 --> 01:47:04,226
如果我們想獲得個別
在這樣的結構列表中的元素，

2085
01:47:04,226 --> 01:47:05,850
我們不能做到這一點與多個字符串？

2086
01:47:05,850 --> 01:47:08,050
我們可以用命令行參數。

2087
01:47:08,050 --> 01:47:12,800
但是，這幅畫在這裡只是盒
是示範這種總體思路

2088
01:47:12,800 --> 01:47:14,451
的陣列，或列表，或者一個矢量。

2089
01:47:14,451 --> 01:47:16,450
並根據
的背景下，所有的這些話

2090
01:47:16,450 --> 01:47:17,880
意思是略有不同的事情。

2091
01:47:17,880 --> 01:47:20,060
因此，在C，我們只打算
談論一個數組。

2092
01:47:20,060 --> 01:47:23,840
而一個數組是一大塊
內存，每個人的

2093
01:47:23,840 --> 01:47:27,720
元件是連續的，背部，
背，背，背到。

2094
01:47:27,720 --> 01:47:31,970
>> 與這些元素是，一般地，
相同的數據類型，字符，

2095
01:47:31,970 --> 01:47:35,966
人品，人品，性格，或
字符串，字符串，字符串，字符串或者int

2096
01:47:35,966 --> 01:47:38,600
INT，INT，不管它是什麼
我們試圖商店。

2097
01:47:38,600 --> 01:47:42,540
但在一天結束時，這是
它看起來像什麼概念。

2098
01:47:42,540 --> 01:47:44,530
你把你的
計算機的存儲器或RAM中。

2099
01:47:44,530 --> 01:47:48,590
而你刻出來成
相同尺寸的盒，所有這些都

2100
01:47:48,590 --> 01:47:50,920
回來了，要背，
背，背這個樣子。

2101
01:47:50,920 --> 01:47:53,200
>> 什麼是關於好的
這個想法和事實

2102
01:47:53,200 --> 01:47:58,580
我們能夠表達這樣的值
與第一我們的數據結構的

2103
01:47:58,580 --> 01:48:02,520
在課堂上，意味著我們可以開始
解決與代碼的問題

2104
01:48:02,520 --> 01:48:04,079
即0的一周裡那麼直觀。

2105
01:48:04,079 --> 01:48:05,870
你還記得手機
書實施例，其中

2106
01:48:05,870 --> 01:48:09,110
我們使用了分而治之，
或二進制搜索算法，

2107
01:48:09,110 --> 01:48:13,220
通過一個整體進行篩選
一堆的名稱和號碼。

2108
01:48:13,220 --> 01:48:18,220
但是，我們認為，召回，這是
電話本已經被排序，

2109
01:48:18,220 --> 01:48:21,630
別人已經
想通out--給出的名單

2110
01:48:21,630 --> 01:48:24,430
和numbers--如何按字母順序排列它們。

2111
01:48:24,430 --> 01:48:26,950
而現在，在C我們，
也有能力

2112
01:48:26,950 --> 01:48:30,290
打好東西出來，不
物理在電話簿

2113
01:48:30,290 --> 01:48:34,220
但幾乎​​在一台電腦的
記憶，我們將能夠在下週

2114
01:48:34,220 --> 01:48:38,470
到this--第一次推出
在一個array--我們的數據結構的

2115
01:48:38,470 --> 01:48:43,530
但更重要的是，實際的計算機
科學的算法實現

2116
01:48:43,530 --> 01:48:47,720
在代碼，與我們可以存儲
在這樣的結構數據，

2117
01:48:47,720 --> 01:48:50,730
然後開始操縱它，
真正解決問題呢，

2118
01:48:50,730 --> 01:48:53,570
並建立最重要的是，
最終，在C程序中，

2119
01:48:53,570 --> 01:48:56,730
在Python，JavaScript中，
查詢SQL數據庫？

2120
01:48:56,730 --> 01:48:59,980
>> 我們將看到所有這些
不同的想法互鎖。

2121
01:48:59,980 --> 01:49:04,100
但現在，記得
我們今天介紹域

2122
01:49:04,100 --> 01:49:06,920
是這個東西在這裡，和
世界加密的。

2123
01:49:06,920 --> 01:49:11,200
而接下來的問題，你自己之間
將解決是密碼學的藝術，

2124
01:49:11,200 --> 01:49:13,630
加擾和解擾
信息，和加密

2125
01:49:13,630 --> 01:49:15,930
和破譯的文字，
並假定最終

2126
01:49:15,930 --> 01:49:18,970
你現在知道什麼
是引擎蓋下

2127
01:49:18,970 --> 01:49:21,860
所以，當你看到或收到
這樣的消息，你

2128
01:49:21,860 --> 01:49:24,060
你自己可以破譯它。

2129
01:49:24,060 --> 01:49:26,740
所有這一切，以及更多下一次。

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [視頻回放]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover剛到。

2133
01:49:32,970 --> 01:49:35,146
我要去拜訪
他的大學教授。

2134
01:49:35,146 --> 01:49:37,611
是的。

2135
01:49:37,611 --> 01:49:40,080
你好。

2136
01:49:40,080 --> 01:49:40,660
是你。

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
等待！

2139
01:49:45,110 --> 01:49:45,610
大衛。

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
我只是想圖
出了什麼事給你。

2142
01:49:56,060 --> 01:49:58,130
請，什麼事情都可能幫助。

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
你是他的大學
室友，不是嗎？

2145
01:50:08,354 --> 01:50:10,770
你跟他的時候在那裡
他完成了CS50的項目？

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [音樂]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>>  - 那是CS50。

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> 我喜歡這個地方。

2152
01:50:44,770 --> 01:50:45,854
>> -Eat起來。

2153
01:50:45,854 --> 01:50:47,020
我們走出去的企業。

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [結束播放]

