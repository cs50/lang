1
00:00:00,000 --> 00:00:02,970
>> [MUZIK Bermain]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN: Baiklah.

4
00:00:15,700 --> 00:00:18,832
Ini adalah CS50 dan ini
adalah permulaan Minggu 2.

5
00:00:18,832 --> 00:00:21,040
Dan anda akan ingat bahawa lebih
pasangan yang lalu minggu,

6
00:00:21,040 --> 00:00:24,490
kita telah memperkenalkan komputer
sains dan, seterusnya, pengaturcaraan.

7
00:00:24,490 --> 00:00:27,640
>> Dan kami mula cerita dengan cara
Awal, bahawa bahasa grafik

8
00:00:27,640 --> 00:00:28,990
dari Media Lab MIT'S.

9
00:00:28,990 --> 00:00:30,780
Dan kemudian yang paling baru-baru ini,
minggu lepas, adakah kita

10
00:00:30,780 --> 00:00:34,450
memperkenalkan higher-- yang
bahasa peringkat rendah dikenali

11
00:00:34,450 --> 00:00:36,770
sebagai C, sesuatu yang semata-mata teks.

12
00:00:36,770 --> 00:00:39,440
Dan, sememangnya, kita masa lalu
diterokai dalam konteks yang

13
00:00:39,440 --> 00:00:40,450
beberapa konsep.

14
00:00:40,450 --> 00:00:43,010
>> Ini, ingat, adalah sangat
Program pertama kita melihat.

15
00:00:43,010 --> 00:00:45,710
Dan program ini, cukup mudah,
mencetak, "hello, dunia."

16
00:00:45,710 --> 00:00:47,730
Tetapi ada begitu banyak
seolah-olah ajaib berlaku.

17
00:00:47,730 --> 00:00:51,460
Ada #include ini
dengan kurungan sudut.

18
00:00:51,460 --> 00:00:52,170
Ada int.

19
00:00:52,170 --> 00:00:53,020
Ada (tidak sah).

20
00:00:53,020 --> 00:00:56,330
Ada kurungan, pendakap kerinting,
koma bertindih, dan banyak lagi.

21
00:00:56,330 --> 00:00:58,480
>> Dan sebagainya, ingat bahawa
kami memperkenalkan Scratch

22
00:00:58,480 --> 00:01:02,110
supaya kita boleh, ideal, melihat masa lalu
bahawa sintaks, barangan yang benar-benar tidak

23
00:01:02,110 --> 00:01:04,590
semua yang intelek
menarik tetapi awal

24
00:01:04,590 --> 00:01:07,700
adalah, benar-benar, agak sukar
untuk membalut fikiran anda di sekitar.

25
00:01:07,700 --> 00:01:10,860
Dan, sememangnya, salah satu yang paling biasa
perkara yang awal dalam kelas pengaturcaraan,

26
00:01:10,860 --> 00:01:13,443
terutama bagi mereka yang kurang
selesa, adalah untuk kecewa dengan

27
00:01:13,443 --> 00:01:17,460
dan tersandung oleh sintaksis tertentu
kesilapan, apatah lagi kesilapan logik.

28
00:01:17,460 --> 00:01:19,800
Dan demikian di antara matlamat kita
hari ini, sebenarnya, akan

29
00:01:19,800 --> 00:01:23,280
adalah untuk melengkapkan anda dengan beberapa
teknik penyelesaian masalah untuk bagaimana

30
00:01:23,280 --> 00:01:26,705
untuk lebih menyelesaikan masalah sendiri
dalam bentuk debugging.

31
00:01:26,705 --> 00:01:29,330
Dan anda akan ingat, terlalu, bahawa
persekitaran yang diperkenalkan

32
00:01:29,330 --> 00:01:31,780
Kali terakhir dipanggil CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Ini adalah perisian berasaskan web yang
membolehkan anda untuk program dalam awan,

34
00:01:34,850 --> 00:01:38,450
jadi untuk bercakap, sambil mengekalkan semua anda
fail bersama-sama, seperti yang kita akan sekali lagi hari ini.

35
00:01:38,450 --> 00:01:41,480
Dan ingat kita yang
semula topik ini di sini,

36
00:01:41,480 --> 00:01:44,480
antaranya fungsi, dan gelung, dan
pembolehubah, dan ungkapan Boolean,

37
00:01:44,480 --> 00:01:45,110
dan syarat-syarat.

38
00:01:45,110 --> 00:01:49,190
Dan sebenarnya beberapa lagi yang kita
diterjemahkan dari dunia Scratch

39
00:01:49,190 --> 00:01:50,800
ke dunia C.

40
00:01:50,800 --> 00:01:53,220
>> Tetapi bangunan asas
blok, boleh dikatakan,

41
00:01:53,220 --> 00:01:55,150
benar-benar masih minggu lepas yang sama.

42
00:01:55,150 --> 00:01:57,900
Malah, kita benar-benar hanya mempunyai
sekeping teka-teki yang berbeza, jika anda akan.

43
00:01:57,900 --> 00:02:00,300
Daripada yang ungu
menyimpan blok, kita bukannya

44
00:02:00,300 --> 00:02:02,940
telah printf, yang
fungsi ini dalam C yang

45
00:02:02,940 --> 00:02:05,890
membolehkan anda untuk mencetak sesuatu
dan format ia pada skrin.

46
00:02:05,890 --> 00:02:07,950
Kami memperkenalkan CS50
Perpustakaan, di mana anda

47
00:02:07,950 --> 00:02:11,420
ada sekarang di get_char pelupusan anda,
dan get_int dan get_string,

48
00:02:11,420 --> 00:02:14,610
dan beberapa fungsi lain yang
dengan baik, melalui mana anda boleh mendapatkan input

49
00:02:14,610 --> 00:02:16,260
dari papan kekunci pengguna sendiri.

50
00:02:16,260 --> 00:02:20,640
Dan kami juga mengambil melihat pada perkara
seperti bool these-, dan char,

51
00:02:20,640 --> 00:02:22,490
dan dua, float,
int, tali long_long.

52
00:02:22,490 --> 00:02:25,170
Dan ada juga jenis data lain dalam C.

53
00:02:25,170 --> 00:02:28,560
>> Dalam erti kata lain, apabila anda mengisytiharkan
pembolehubah untuk menyimpan beberapa nilai,

54
00:02:28,560 --> 00:02:32,600
atau apabila anda melaksanakan fungsi
yang mengembalikan beberapa nilai,

55
00:02:32,600 --> 00:02:35,290
anda boleh menentukan apa
jenis nilai iaitu.

56
00:02:35,290 --> 00:02:37,310
Adakah tali, seperti
jujukan aksara?

57
00:02:37,310 --> 00:02:39,490
Adakah nombor, seperti integer?

58
00:02:39,490 --> 00:02:41,390
Adakah ia satu titik terapung
nilai, atau sebagainya?

59
00:02:41,390 --> 00:02:46,180
Jadi dalam C, tidak seperti calar, kita sebenarnya
mula menentukan jenis data

60
00:02:46,180 --> 00:02:48,330
kami kembali atau menggunakan.

61
00:02:48,330 --> 00:02:51,910
>> Tetapi, sudah tentu, kita juga berlari ke
beberapa had asas pengkomputeran.

62
00:02:51,910 --> 00:02:54,100
Dan khususnya,
ini bahasa C, ingat

63
00:02:54,100 --> 00:02:57,070
bahawa kami mengambil lihat pada
limpahan integer, realiti

64
00:02:57,070 --> 00:03:00,460
bahawa jika anda hanya mempunyai
jumlah terhingga memori

65
00:03:00,460 --> 00:03:04,600
atau, khususnya, beberapa terhingga
bit, anda hanya boleh mengira begitu tinggi.

66
00:03:04,600 --> 00:03:08,460
Dan supaya kita melihat contoh ini di sini
mana kaunter dalam kapal terbang,

67
00:03:08,460 --> 00:03:13,510
sebenarnya, jika berjalan cukup lama akan
melimpah dan menyebabkan perisian

68
00:03:13,510 --> 00:03:15,560
kesilapan yang berpotensi fizikal sebenar.

69
00:03:15,560 --> 00:03:18,600
>> Kami juga melihat terapung
titik ketakpersisan, realitinya

70
00:03:18,600 --> 00:03:22,280
bahawa dengan hanya beberapa terhingga
bit, sama ada 32 atau 64,

71
00:03:22,280 --> 00:03:27,330
anda hanya boleh menentukan pelbagai nombor
selepas titik perpuluhan, selepas itu anda

72
00:03:27,330 --> 00:03:29,110
mula mendapat tidak tepat.

73
00:03:29,110 --> 00:03:32,360
Jadi misalnya, satu pertiga dalam
dunia di sini, dalam dunia manusia,

74
00:03:32,360 --> 00:03:35,360
kita tahu hanya nombor terhingga
daripada 3 yang selepas titik perpuluhan.

75
00:03:35,360 --> 00:03:38,820
Tetapi komputer tidak boleh semestinya
mewakili nombor terhingga nombor

76
00:03:38,820 --> 00:03:42,590
jika anda hanya membenarkan ia beberapa
jumlah terhingga maklumat.

77
00:03:42,590 --> 00:03:45,900
>> Jadi bukan sahaja kita melengkapkan anda
dengan kuasa yang lebih besar dari segi

78
00:03:45,900 --> 00:03:49,280
bagaimana anda boleh meluahkan diri anda
papan kekunci dari segi pengaturcaraan,

79
00:03:49,280 --> 00:03:51,430
kami juga terhad apa
anda sebenarnya boleh lakukan.

80
00:03:51,430 --> 00:03:55,790
Dan sesungguhnya, pepijat dan kesilapan boleh
timbul daripada orang-orang jenis isu.

81
00:03:55,790 --> 00:03:59,900
Dan sesungguhnya, antara topik hari ini
akan menjadi topik-topik seperti debugging

82
00:03:59,900 --> 00:04:03,699
dan sebenarnya mencari di bawah hood
bagaimana perkara yang telah diperkenalkan minggu lepas

83
00:04:03,699 --> 00:04:05,490
sebenarnya dilaksanakan
supaya anda lebih baik

84
00:04:05,490 --> 00:04:10,530
memahami kedua-dua keupayaan dan
batasan bahasa seperti C.

85
00:04:10,530 --> 00:04:14,770
>> Dan sebenarnya, kami akan mengupas kembali lapisan
yang paling mudah struktur data,

86
00:04:14,770 --> 00:04:17,756
sesuatu yang dinamakan array, yang
Scratch berlaku untuk memanggil "senarai."

87
00:04:17,756 --> 00:04:19,589
Ia adalah sedikit
yang berbeza dalam konteks itu.

88
00:04:19,589 --> 00:04:23,340
Dan kemudian kami juga akan memperkenalkan salah satu daripada
pertama masalah domain khusus kami

89
00:04:23,340 --> 00:04:26,790
dalam CS50, dunia
kriptografi, seni berebut

90
00:04:26,790 --> 00:04:29,650
atau dalam ciphering maklumat supaya
bahawa anda boleh menghantar mesej rahsia

91
00:04:29,650 --> 00:04:34,520
dan menyahkod mesej rahsia
antara dua orang, A dan B.

92
00:04:34,520 --> 00:04:37,490
>> Jadi sebelum peralihan kita
ke dunia baru,

93
00:04:37,490 --> 00:04:42,059
mari kita cuba untuk melengkapkan anda dengan beberapa
teknik yang anda boleh menghapuskan

94
00:04:42,059 --> 00:04:43,850
atau mengurangkan sekurang-kurangnya beberapa
daripada kekecewaan

95
00:04:43,850 --> 00:04:46,630
bahawa anda mungkin dihadapi
sepanjang minggu lepas sahaja.

96
00:04:46,630 --> 00:04:50,830
Malah, lebih awal daripada anda such-- beberapa
masalah pertama anda dalam C. Dan kemungkinan adalah,

97
00:04:50,830 --> 00:04:54,010
jika anda seperti saya, kali pertama
anda cuba untuk menaip program,

98
00:04:54,010 --> 00:04:57,330
walaupun anda berfikir secara logik
program ini adalah agak mudah,

99
00:04:57,330 --> 00:05:01,200
anda sangat baik mungkin melanda dinding, dan
pengkompil tidak akan bekerjasama.

100
00:05:01,200 --> 00:05:03,940
Membuat atau dilafaz tidak akan
untuk benar-benar melakukan bidaan anda.

101
00:05:03,940 --> 00:05:05,450
>> Dan mengapa yang mungkin?

102
00:05:05,450 --> 00:05:07,950
Nah, mari kita lihat pada,
mungkin, satu program yang mudah.

103
00:05:07,950 --> 00:05:11,190
Saya akan pergi ke hadapan dan menyimpan ini dalam
fail yang sengaja dipanggil buggy0.c,

104
00:05:11,190 --> 00:05:13,590
kerana saya tahu ia
dapat dipercayai sama sekali terlebih dahulu.

105
00:05:13,590 --> 00:05:17,400
Tetapi saya mungkin tidak sedar bahawa jika ini
merupakan program pertama atau kedua atau ketiga

106
00:05:17,400 --> 00:05:18,830
bahawa saya benar-benar membuat diri saya sendiri.

107
00:05:18,830 --> 00:05:23,820
Jadi, saya akan pergi ke hadapan dan
menaip, int utama (tidak sah).

108
00:05:23,820 --> 00:05:28,130
Dan kemudian di dalam pendakap kerinting saya,
yang sangat biasa ( "hello, world--

109
00:05:28,130 --> 00:05:30,980
garis sendeng terbalik, n ") - dan koma bertitik.

110
00:05:30,980 --> 00:05:32,360
>> Saya telah menyimpan fail.

111
00:05:32,360 --> 00:05:34,850
Sekarang saya akan turun ke bawah
ke tetingkap terminal saya

112
00:05:34,850 --> 00:05:40,340
dan jenis make buggy0, kerana, sekali lagi,
nama fail hari ini adalah buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Jadi saya menaip membuat buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Dan, oh, Astaga, ingat dari masa lalu
yang tiada mesej ralat adalah satu perkara yang baik.

115
00:05:48,200 --> 00:05:49,740
Jadi tiada output adalah satu perkara yang baik.

116
00:05:49,740 --> 00:05:52,920
Tetapi di sini saya mempunyai jelas
beberapa beberapa kesilapan.

117
00:05:52,920 --> 00:05:56,470
>> Jadi baris pertama output
selepas menaip membuat buggy0, ingat,

118
00:05:56,470 --> 00:05:59,540
output agak berjela-jela yang dilafaz itu.

119
00:05:59,540 --> 00:06:02,067
Di bawah hood,
CS50 IDE dikonfigurasi

120
00:06:02,067 --> 00:06:04,150
untuk menggunakan sejumlah besar
pilihan dengan pengkompil ini

121
00:06:04,150 --> 00:06:05,941
supaya anda tidak perlu
untuk berfikir tentang mereka.

122
00:06:05,941 --> 00:06:08,840
Dan itu semua yang baris pertama
cara yang bermula dengan dilafaz.

123
00:06:08,840 --> 00:06:11,720
>> Tetapi selepas itu, masalah
mula membuat penampilan mereka.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c pada baris 3, watak
5, ada yang besar, kesilapan merah.

125
00:06:17,390 --> 00:06:18,380
Apakah itu?

126
00:06:18,380 --> 00:06:23,562
Tersirat mengisytiharkan fungsi perpustakaan
printf dengan jenis int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Maksud saya, ia dengan cepat
mendapat sangat sukar difahami.

129
00:06:28,379 --> 00:06:30,170
Dan sesungguhnya, pada mulanya
sepintas lalu, kita tidak akan

130
00:06:30,170 --> 00:06:32,380
mengharapkan anda untuk memahami
keseluruhan daripada mesej itu.

131
00:06:32,380 --> 00:06:34,213
Dan sebagainya salah satu pelajaran
untuk hari ini akan

132
00:06:34,213 --> 00:06:36,919
untuk adalah untuk cuba untuk notis
corak, atau perkara yang sama,

133
00:06:36,919 --> 00:06:38,960
kepada kesilapan anda mungkin mempunyai
dihadapi pada masa lalu.

134
00:06:38,960 --> 00:06:41,335
Jadi mari kita mengusik selain hanya
kata-kata yang kelihatan biasa.

135
00:06:41,335 --> 00:06:44,290
Besar, ralat berwarna merah jelas
simbolik sesuatu yang salah.

136
00:06:44,290 --> 00:06:47,940
>> tersirat mengisytiharkan
perpustakaan fungsi printf.

137
00:06:47,940 --> 00:06:51,680
Jadi, walaupun saya tidak begitu faham apa
tersirat mengisytiharkan fungsi perpustakaan

138
00:06:51,680 --> 00:06:54,900
cara, masalah itu pasti
berkaitan dengan printf entah bagaimana.

139
00:06:54,900 --> 00:06:59,130
Dan sumber isu yang
mempunyai kaitan dengan mengisytiharkan ia.

140
00:06:59,130 --> 00:07:02,440
>> Mengisytiharkan fungsi adalah
menyebutkan itu buat kali pertama.

141
00:07:02,440 --> 00:07:06,210
Dan kami sentiasa istilah minggu lepas
mengisytiharkan prototaip fungsi ini,

142
00:07:06,210 --> 00:07:11,860
sama ada dengan satu baris di bahagian atas anda
fail sendiri atau dalam fail header dipanggil.

143
00:07:11,860 --> 00:07:15,300
Dan dalam apa fail lakukan kita katakan
minggu lepas bahawa printf adalah quote,

144
00:07:15,300 --> 00:07:17,080
unquote, diisytiharkan?

145
00:07:17,080 --> 00:07:20,950
Dalam apa fail adalah prototaip?

146
00:07:20,950 --> 00:07:24,640
>> Jadi, jika anda masih ingat, perkara yang pertama saya
ditaip, hampir setiap program time-- lalu

147
00:07:24,640 --> 00:07:30,790
dan secara tidak sengaja sebentar tadi bermula
menaip myself-- adalah salah sini-- ini

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- untuk
input / output-- dot h Dan sesungguhnya,

149
00:07:38,630 --> 00:07:41,860
jika saya kini menyimpan fail ini, saya akan
pergi ke hadapan dan mengosongkan skrin saya,

150
00:07:41,860 --> 00:07:44,740
mana anda boleh melakukan dengan menaip
Jelas, atau anda boleh memegang Kawalan L,

151
00:07:44,740 --> 00:07:47,680
hanya untuk membersihkan tetingkap terminal anda
hanya untuk menghapuskan beberapa kekusutan.

152
00:07:47,680 --> 00:07:51,370
>> Saya akan pergi ke hadapan dan
semula jenis make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Dan Voilà, saya masih melihat bahawa
arahan panjang dari dilafaz,

154
00:07:53,790 --> 00:07:55,470
tetapi tidak ada mesej ralat masa ini.

155
00:07:55,470 --> 00:07:58,800
Dan sesungguhnya, jika saya lakukan ./buggy0,
seperti masa lalu,

156
00:07:58,800 --> 00:08:01,860
mana dot bermakna ini
direktori, Slash hanya bermaksud,

157
00:08:01,860 --> 00:08:05,040
di sini datang nama program dan
bahawa nama program ini adalah buggy0,

158
00:08:05,040 --> 00:08:07,340
Enter, "hello, dunia."

159
00:08:07,340 --> 00:08:09,440
>> Sekarang, bagaimana anda mungkin mempunyai
dikumpulkan penyelesaian ini

160
00:08:09,440 --> 00:08:12,017
tanpa semestinya
mengiktiraf sebagai banyak perkataan

161
00:08:12,017 --> 00:08:14,350
seperti yang saya lakukan, sudah tentu, mempunyai
melakukan ini selama bertahun-tahun lamanya?

162
00:08:14,350 --> 00:08:18,720
Well, menyedari setiap masalah pertama
set, kita memperkenalkan anda kepada perintah

163
00:08:18,720 --> 00:08:21,175
bahawa kakitangan CS50 sendiri
menulis dipanggil help50.

164
00:08:21,175 --> 00:08:24,300
Dan sesungguhnya, C tidak spesifikasi untuk
masalah yang ditetapkan tentang bagaimana untuk menggunakan ini.

165
00:08:24,300 --> 00:08:27,210
>> Tetapi help50 asasnya
satu program yang kakitangan CS50

166
00:08:27,210 --> 00:08:30,850
menulis yang membolehkan anda untuk menjalankan
perintah atau menjalankan program,

167
00:08:30,850 --> 00:08:36,169
dan jika anda tidak memahami yang
output, meluluskan pengeluarannya ke help50,

168
00:08:36,169 --> 00:08:38,890
di mana titik perisian
bahawa kakitangan kursus ini menulis

169
00:08:38,890 --> 00:08:42,429
akan melihat output program anda
baris demi baris, watak oleh watak.

170
00:08:42,429 --> 00:08:46,000
Dan jika kita, kakitangan, mengiktiraf
mesej ralat yang anda alami,

171
00:08:46,000 --> 00:08:50,580
kami akan cuba untuk memprovokasi anda dengan beberapa
soalan retorik, dengan nasihat,

172
00:08:50,580 --> 00:08:54,890
sama seperti TF atau CA atau diri saya
akan melakukan sendiri di waktu pejabat.

173
00:08:54,890 --> 00:08:58,320
>> Oleh itu, mencari untuk help50 jika anda tidak
semestinya mengenali masalah.

174
00:08:58,320 --> 00:09:00,790
Tetapi jangan bergantung kepada ia
terlalu banyak sebagai topang.

175
00:09:00,790 --> 00:09:03,990
Sudah tentu cuba memahami yang
output dan kemudian belajar daripadanya

176
00:09:03,990 --> 00:09:07,571
supaya hanya sekali atau dua kali adakah anda
pernah menjalankan help50 untuk ralat tertentu

177
00:09:07,571 --> 00:09:08,070
mesej.

178
00:09:08,070 --> 00:09:10,660
Selepas itu, anda perlu
lebih bersedia diri

179
00:09:10,660 --> 00:09:13,180
untuk mencari tahu apa yang sebenarnya.

180
00:09:13,180 --> 00:09:14,350
>> Mari kita buat satu lain di sini.

181
00:09:14,350 --> 00:09:20,410
Biar saya pergi ke hadapan, dan lain
fail yang kita akan memanggil buggy1.c ini.

182
00:09:20,410 --> 00:09:23,110
Dan dalam fail ini Saya
akan deliberately--

183
00:09:23,110 --> 00:09:26,330
tetapi berpura-pura bahawa saya tidak
memahami apa kesilapan yang saya telah buat.

184
00:09:26,330 --> 00:09:31,420
>> Saya akan pergi ke hadapan dan melakukan this--
#include, kerana saya telah

185
00:09:31,420 --> 00:09:33,660
belajar pelajaran saya dari masa yang lalu.

186
00:09:33,660 --> 00:09:36,220
Int utama (tidak sah), seperti dahulu.

187
00:09:36,220 --> 00:09:40,880
Dan kemudian di sini saya akan
lakukan rentetan s - get_string.

188
00:09:40,880 --> 00:09:43,770
Dan ingat dari masa lalu yang
cara ini, hey, komputer,

189
00:09:43,770 --> 00:09:48,280
memberi saya berubah-ubah, memanggilnya s, dan
membuat jenis pembolehubah yang rentetan

190
00:09:48,280 --> 00:09:50,150
jadi saya boleh menyimpan satu atau lebih perkataan di dalamnya.

191
00:09:50,150 --> 00:09:52,191
>> Dan kemudian di kanan
sisi tanda 'sama

192
00:09:52,191 --> 00:09:54,980
adalah get_string, yang merupakan
fungsi di Perpustakaan CS50

193
00:09:54,980 --> 00:09:55,980
yang melakukan perkara tersebut.

194
00:09:55,980 --> 00:09:59,740
Ia mendapat fungsi dan kemudian
tangan dari kanan ke kiri.

195
00:09:59,740 --> 00:10:02,670
Jadi tanda sama ini tidak bermakna
"Sama" seperti yang kita mungkin berfikir dalam matematik.

196
00:10:02,670 --> 00:10:04,750
Ini bermakna tugasan dari kanan ke kiri.

197
00:10:04,750 --> 00:10:09,640
Jadi ini bermakna, mengambil tali dari
pengguna dan menyimpan ia di dalam s.

198
00:10:09,640 --> 00:10:10,460
>> Sekarang mari kita menggunakannya.

199
00:10:10,460 --> 00:10:13,820
Biar saya pergi ke hadapan sekarang dan sebagai satu saat
line, biarlah saya pergi ke hadapan dan berkata "hello" -

200
00:10:13,820 --> 00:10:19,330
tidak "dunia," tetapi "hello,% s--
yang merupakan pemegang tempat kami, koma s,

201
00:10:19,330 --> 00:10:22,030
yang berubah-ubah kita,
dan kemudian koma bertitik.

202
00:10:22,030 --> 00:10:26,070
Jadi, jika saya tidak skru sehingga terlalu banyak
di sini, ini kelihatan seperti kod yang betul.

203
00:10:26,070 --> 00:10:28,090
>> Dan naluri saya sekarang adalah untuk menyusun ia.

204
00:10:28,090 --> 00:10:30,400
fail ini dipanggil buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Jadi, saya akan melakukan make buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Dan darn-it, jika tidak ada
walaupun lebih banyak kesilapan daripada sebelum ini.

207
00:10:36,377 --> 00:10:38,210
Maksud saya, ada lagi
mesej ralat ia akan

208
00:10:38,210 --> 00:10:40,400
seolah-olah daripada garis sebenar dalam program ini.

209
00:10:40,400 --> 00:10:42,730
>> Tetapi bisa dibesarkan di sini adalah,
walaupun anda terharu

210
00:10:42,730 --> 00:10:45,040
dengan dua atau tiga atau
empat lagi mesej ralat,

211
00:10:45,040 --> 00:10:48,340
tumpuan sentiasa yang
pertama mesej tersebut.

212
00:10:48,340 --> 00:10:52,220
Melihat paling atas satu,
menatal kembali sebagai perlu.

213
00:10:52,220 --> 00:10:53,930
Jadi di sini saya menaip make buggy1.

214
00:10:53,930 --> 00:10:55,700
Berikut adalah yang output dilafaz seperti yang diharapkan.

215
00:10:55,700 --> 00:10:57,290
>> Dan di sini adalah ralat berwarna merah yang pertama.

216
00:10:57,290 --> 00:11:02,370
Penggunaan pengecam yang tidak diisytiharkan
tali, yang saya maksudkan standard dalam?

217
00:11:02,370 --> 00:11:04,260
Jadi dalam standard
sebenarnya sesuatu yang lain.

218
00:11:04,260 --> 00:11:06,240
Ia merujuk kepada ini pengguna
keyboard, pada asasnya.

219
00:11:06,240 --> 00:11:08,080
>> Tetapi itu bukan apa yang saya maksudkan.

220
00:11:08,080 --> 00:11:11,770
Saya maksudkan tali, dan saya maksudkan get_string.

221
00:11:11,770 --> 00:11:16,200
Jadi apa yang saya
terlupa untuk melakukan masa ini?

222
00:11:16,200 --> 00:11:20,230
Apa yang hilang masa ini?

223
00:11:20,230 --> 00:11:23,600
Saya mempunyai #include saya,
jadi saya mempunyai akses kepada printf.

224
00:11:23,600 --> 00:11:26,090
>> Tetapi apa yang saya tidak mempunyai
akses kepada hanya lagi?

225
00:11:26,090 --> 00:11:29,420
Well, seperti masa lalu,
Saya perlu memberitahu pengkompil

226
00:11:29,420 --> 00:11:31,691
Dilafaz apa fungsi-fungsi ini.

227
00:11:31,691 --> 00:11:33,940
Get_string tidak datang
dengan C. Dan khususnya, ia

228
00:11:33,940 --> 00:11:38,160
tidak datang dalam
header fail.

229
00:11:38,160 --> 00:11:40,770
Ia bukannya datang dalam
sesuatu kakitangan menulis,

230
00:11:40,770 --> 00:11:44,176
yang merupakan fail yang berbeza
menamakan tetapi dinamakan.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Jadi hanya dengan menambah bahawa satu baris
penarikan balik code-- dari masa lalu

233
00:11:50,861 --> 00:11:53,610
bahawa apabila dilafaz berjalan, ia akan
melihat bahagian kod saya ke bawah,

234
00:11:53,610 --> 00:11:54,193
kiri ke kanan.

235
00:11:54,193 --> 00:11:57,200
Ia akan notis,
oh, yang anda mahu.

236
00:11:57,200 --> 00:11:59,900
Biar saya pergi dan mendapati bahawa,
mana saja ia berada pada pelayan,

237
00:11:59,900 --> 00:12:03,090
copy dan paste, pada dasarnya,
ke bahagian atas fail anda sendiri

238
00:12:03,090 --> 00:12:06,820
supaya pada ketika ini dalam cerita,
baris 1, yang lain daripada program ini

239
00:12:06,820 --> 00:12:11,651
boleh, sesungguhnya, menggunakan mana-mana fungsi
di dalamnya, di antara mereka get_string.

240
00:12:11,651 --> 00:12:13,650
Jadi, saya akan mengabaikan
seluruh orang-orang kesilapan,

241
00:12:13,650 --> 00:12:17,190
kerana saya, sesungguhnya, mengesyaki bahawa hanya
yang pertama sebenarnya penting.

242
00:12:17,190 --> 00:12:20,780
Dan saya akan pergi ke hadapan dan jalankan lagi,
selepas menyimpan fail saya membuat buggy1.

243
00:12:20,780 --> 00:12:22,580
Dan Voilà, ia melakukan kerja-kerja.

244
00:12:22,580 --> 00:12:29,200
Dan jika saya melakukan ./buggy1 dan taip, untuk
contoh, Zamyla, saya kini akan mendapat hello,

245
00:12:29,200 --> 00:12:32,000
Zamyla, bukan hello, dunia.

246
00:12:32,000 --> 00:12:32,550
>> Baiklah.

247
00:12:32,550 --> 00:12:35,890
Jadi bawa pulang di sini maka adalah untuk,
satu, cuba untuk memungut seberapa banyak yang anda boleh

248
00:12:35,890 --> 00:12:39,140
daripada mesej ralat bersendirian, mencari
di beberapa perkataan yang dikenali.

249
00:12:39,140 --> 00:12:43,070
Jika tidak berlaku itu, gunakan help50 per
masalah yang ditetapkan spesifikasi.

250
00:12:43,070 --> 00:12:46,500
Tetapi sekatan itu juga, sentiasa kelihatan
di ralat bahagian sahaja, sekurang-kurangnya

251
00:12:46,500 --> 00:12:50,051
pada mulanya, untuk melihat apa maklumat
ia sebenarnya mungkin menghasilkan.

252
00:12:50,051 --> 00:12:52,300
Tetapi ternyata ada yang
lebih banyak fungsi yang dibina

253
00:12:52,300 --> 00:12:55,030
ke dalam Perpustakaan CS50 untuk membantu
anda pada awal semester

254
00:12:55,030 --> 00:12:57,580
dan awal di dalam pengaturcaraan
memikirkan apa yang berlaku salah.

255
00:12:57,580 --> 00:12:59,840
Jadi mari kita buat contoh yang lain di sini.

256
00:12:59,840 --> 00:13:04,350
Saya akan memanggil buggy2 ini, yang,
sekali lagi, akan menjadi cacat keluar

257
00:13:04,350 --> 00:13:05,650
pintu gerbang, dengan reka bentuk.

258
00:13:05,650 --> 00:13:09,980
>> Dan saya akan pergi ke hadapan
dan melakukan #include.

259
00:13:09,980 --> 00:13:12,580
Dan kemudian saya akan melakukan int utama (tidak sah).

260
00:13:12,580 --> 00:13:14,840
Dan kemudian saya akan lakukan untuk gelung.

261
00:13:14,840 --> 00:13:16,690
Untuk (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i adalah kurang daripada atau sama dengan 10.

263
00:13:18,750 --> 00:13:24,260
i ++, dan kemudian dalam pendakap kerinting, saya akan
untuk mencetak hanya satu simbol hashtag sini

264
00:13:24,260 --> 00:13:25,920
dan watak barisan baru.

265
00:13:25,920 --> 00:13:29,220
>> Jadi niat saya dengan ini
program cukup sekadar

266
00:13:29,220 --> 00:13:33,150
untuk melelar 10 kali
dan pada setiap lelaran

267
00:13:33,150 --> 00:13:35,260
gelung bahawa setiap kali
melalui kitaran,

268
00:13:35,260 --> 00:13:37,660
mencetak hashtag,
hashtag, hashtag a.

269
00:13:37,660 --> 00:13:40,480
Satu bagi setiap baris kerana saya
mempunyai garis baru di sana.

270
00:13:40,480 --> 00:13:42,787
Dan ingat bahawa untuk
gelung, setiap week-- lalu

271
00:13:42,787 --> 00:13:44,620
dan anda akan mendapat lebih
biasa dengan sintaks

272
00:13:44,620 --> 00:13:47,170
dengan menggunakannya dengan amalan
sebelum long-- ini memberikan saya

273
00:13:47,170 --> 00:13:49,740
pembolehubah yang dipanggil i dan menetapkan ia ke 0.

274
00:13:49,740 --> 00:13:52,650
>> Ini menokok i pada
setiap lelaran oleh 1.

275
00:13:52,650 --> 00:13:54,940
Jadi saya pergi ke 1 hingga 2 hingga 3.

276
00:13:54,940 --> 00:13:57,690
Dan kemudian keadaan ini dalam
tengah antara koma bertindih

277
00:13:57,690 --> 00:14:03,010
mendapat diperiksa pada setiap lelaran untuk membuat
memastikan bahawa kita masih dalam liputan.

278
00:14:03,010 --> 00:14:06,830
Jadi saya mahu melelar 10 kali, jadi saya
mempunyai jenis yang sangat intuitif hanya

279
00:14:06,830 --> 00:14:09,070
meletakkan 10 sebagai had atas saya di sana.

280
00:14:09,070 --> 00:14:14,310
>> Namun, apabila saya menjalankan ini, selepas
menyusun dengan make buggy2--

281
00:14:14,310 --> 00:14:15,440
dan ia menyusun OK.

282
00:14:15,440 --> 00:14:17,980
Jadi, saya tidak mempunyai
ralat sintaks masa ini.

283
00:14:17,980 --> 00:14:20,940
Biar saya pergi ke hadapan sekarang
dan menjalankan buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Dan sekarang tatal ke atas.

285
00:14:22,620 --> 00:14:24,890
Dan biarlah saya meningkatkan
saiz tetingkap.

286
00:14:24,890 --> 00:14:33,720
>> Saya seolah-olah ada 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Jadi ada 11 hashtags, walaupun
Saya dengan jelas meletakkan 10 dalam gelung ini.

288
00:14:38,891 --> 00:14:42,140
Sekarang, sebahagian daripada anda mungkin melihat dengan serta-merta
apa kesilapan adalah kerana, sesungguhnya, ini

289
00:14:42,140 --> 00:14:43,720
tidak adalah satu kesilapan yang sangat sukar untuk dilupakan.

290
00:14:43,720 --> 00:14:46,070
Tetapi ia adalah sangat biasa
dibuat sangat awal.

291
00:14:46,070 --> 00:14:49,820
>> Apa yang saya ingin menunjukkan, walaupun,
adalah, bagaimana saya boleh memikirkan ini?

292
00:14:49,820 --> 00:14:52,300
Nah, ternyata bahawa
Perpustakaan CS50 datang

293
00:14:52,300 --> 00:14:55,380
dengan bukan sahaja get_string dan get_int
dan get_float dan fungsi lain.

294
00:14:55,380 --> 00:14:59,980
Ia juga dilengkapi dengan fungsi khas
dipanggil eprintf, atau, ralat printf.

295
00:14:59,980 --> 00:15:03,270
Dan ia wujud semata-mata untuk membuat
ia sedikit lebih mudah untuk anda

296
00:15:03,270 --> 00:15:06,310
apabila debugging kod anda untuk hanya
mencetak mesej ralat pada skrin

297
00:15:06,310 --> 00:15:07,850
dan tahu di mana ia datang dari.

298
00:15:07,850 --> 00:15:11,000
>> Jadi misalnya, satu perkara yang saya mungkin
lakukan di sini dengan fungsi ini adalah this--

299
00:15:11,000 --> 00:15:20,230
eprintf, dan kemudian saya akan pergi ke hadapan
dan katakan sekarang i ialah% i, garis sendeng terbalik, n.

300
00:15:20,230 --> 00:15:22,330
Dan saya akan pasangkan nilai i.

301
00:15:22,330 --> 00:15:25,400
Dan sehingga atas, kerana ini
adalah di Perpustakaan CS50,

302
00:15:25,400 --> 00:15:27,580
Saya akan pergi ke hadapan
dan termasuk

303
00:15:27,580 --> 00:15:29,169
jadi saya mempunyai akses kepada fungsi ini.

304
00:15:29,169 --> 00:15:31,460
Tetapi mari kita mempertimbangkan apa talian
9 sepatutnya lakukan.

305
00:15:31,460 --> 00:15:32,670
Saya akan memadam ini akhirnya.

306
00:15:32,670 --> 00:15:34,670
Ini tidak ada kena mengena
dengan matlamat paling utama saya.

307
00:15:34,670 --> 00:15:39,090
Tetapi eprintf, kesilapan printf, hanya bertujuan
untuk memberi saya beberapa maklumat diagnostik.

308
00:15:39,090 --> 00:15:42,460
Apabila saya menjalankan program saya, saya mahu
melihat ini pada skrin sementara

309
00:15:42,460 --> 00:15:44,550
serta hanya untuk memahami
apa yang sedang berlaku.

310
00:15:44,550 --> 00:15:47,330
>> Dan, sememangnya, pada setiap
lelaran sini barisan 9

311
00:15:47,330 --> 00:15:49,260
Saya mahu melihat, apakah nilai i?

312
00:15:49,260 --> 00:15:50,290
Apakah nilai i?

313
00:15:50,290 --> 00:15:51,280
Apakah nilai i?

314
00:15:51,280 --> 00:15:55,650
Dan, mudah-mudahan, saya hanya perlu
melihat bahawa mesej, juga, 10 kali.

315
00:15:55,650 --> 00:15:57,780
>> Jadi biarlah saya pergi ke hadapan dan
susun semula program saya,

316
00:15:57,780 --> 00:15:59,905
seperti yang saya perlu lakukan bila-bila masa
Saya membuat perubahan. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Dan sekarang-- OK.

319
00:16:03,640 --> 00:16:04,820
Ada banyak lagi berlaku di.

320
00:16:04,820 --> 00:16:07,610
Jadi biarlah saya tatal ke atas dalam
tetingkap yang lebih besar.

321
00:16:07,610 --> 00:16:10,190
>> Dan anda akan melihat bahawa setiap
hashtags masih percetakan.

322
00:16:10,190 --> 00:16:15,270
Tetapi di antara setiap daripada mereka adalah sekarang ini
output diagnostik diformatkan sebagai berikut.

323
00:16:15,270 --> 00:16:17,960
Nama program saya di sini adalah buggy2.

324
00:16:17,960 --> 00:16:20,432
Nama fail adalah buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Nombor talian yang
ini telah dicetak adalah line 9.

326
00:16:24,080 --> 00:16:27,500
Dan kemudian di sebelah kanan itu adalah
mesej ralat yang saya menjangkakan.

327
00:16:27,500 --> 00:16:30,701
>> Dan apa yang baik tentang ini adalah bahawa
sekarang saya tidak perlu semestinya mengira

328
00:16:30,701 --> 00:16:32,200
dalam kepala saya apa program saya lakukan.

329
00:16:32,200 --> 00:16:34,240
Saya dapat melihat bahawa pada
lelaran pertama i adalah 0,

330
00:16:34,240 --> 00:16:39,420
maka 1, kemudian 2, kemudian 3, kemudian 4, kemudian
5, kemudian 6, kemudian 7, kemudian 8, kemudian 9, kemudian

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Jadi tunggu satu minit.

333
00:16:42,050 --> 00:16:43,740
Apa yang berlaku di sini?

334
00:16:43,740 --> 00:16:48,190
Saya masih seolah-olah dapat mengira
sebagaimana dimaksud sehingga 10.

335
00:16:48,190 --> 00:16:50,550
>> Tetapi di mana saya bermula?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Jadi 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- jari-11

338
00:16:58,040 --> 00:16:59,990
adalah menunjukkan masalah.

339
00:16:59,990 --> 00:17:02,850
Saya seolah-olah telah dikira
salah dalam gelung saya.

340
00:17:02,850 --> 00:17:06,599
Bukannya pergi 10 lelaran,
Saya bermula pada 0,

341
00:17:06,599 --> 00:17:09,550
Saya berakhir di dan melalui 10.

342
00:17:09,550 --> 00:17:12,030
Tetapi kerana, seperti komputer,
Saya mula mengira pada 0,

343
00:17:12,030 --> 00:17:15,250
Saya perlu mengira sehingga
, tetapi tidak melalui, 10.

344
00:17:15,250 --> 00:17:18,510
>> Dan sebagainya fix, saya akhirnya
sedar di sini, adalah salah satu daripada dua perkara.

345
00:17:18,510 --> 00:17:22,430
Saya sangat mudah boleh mengatakan
mengira sehingga kurang daripada 10.

346
00:17:22,430 --> 00:17:27,260
Jadi 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, yang, sememangnya, betul,

347
00:17:27,260 --> 00:17:28,900
walaupun ia kedengaran yang salah sedikit.

348
00:17:28,900 --> 00:17:35,070
Atau saya boleh melakukan kurang daripada atau sama
hingga 9, selagi aku bermula pada 0.

349
00:17:35,070 --> 00:17:40,056
Atau jika anda benar-benar tidak suka itu, anda
boleh mengira sehingga melalui 10 tetapi bermula 1.

350
00:17:40,056 --> 00:17:41,680
Tetapi sekali lagi, ini hanya tidak yang biasa.

351
00:17:41,680 --> 00:17:43,977
Dalam programming-- walaupun
tidak begitu banyak dalam Scratch--

352
00:17:43,977 --> 00:17:45,810
tetapi dalam pengaturcaraan
C dan bahasa lain,

353
00:17:45,810 --> 00:17:47,670
seperti JavaScript dan
Python dan lain-lain, ia adalah

354
00:17:47,670 --> 00:17:49,880
hanya sangat biasa bagi
perbincangan kita tentang binari

355
00:17:49,880 --> 00:17:53,450
hanya mula mengira pada
jumlah terendah yang anda boleh, yang adalah 0.

356
00:17:53,450 --> 00:17:53,950
Baiklah.

357
00:17:53,950 --> 00:17:55,160
Jadi itulah eprintf.

358
00:17:55,160 --> 00:17:58,600
Dan sekali lagi, sekarang bahawa saya telah anda ketahui saya
masalah, dan saya akan kembali ke 0

359
00:17:58,600 --> 00:18:01,470
melalui kurang daripada 10, saya akan
untuk masuk dan memadam eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Ia tidak sepatutnya berada di sana apabila saya
menghantar kod saya atau menyerahkan kod saya

361
00:18:04,580 --> 00:18:05,800
atau menunjukkan kepada orang lain.

362
00:18:05,800 --> 00:18:07,980
Ia benar-benar hanya bermakna
yang akan digunakan buat sementara waktu.

363
00:18:07,980 --> 00:18:11,650
Tetapi sekarang saya tetap ini
masalah tertentu juga.

364
00:18:11,650 --> 00:18:16,780
>> Nah, mari kita buat satu lagi contoh di sini
bahawa saya akan menyiapkan seperti berikut.

365
00:18:16,780 --> 00:18:22,850
Saya akan pergi ke hadapan dan
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
Dan saya akan pergi ke hadapan
dan #include.

367
00:18:25,580 --> 00:18:29,030
>> Dan saya akan menyelamatkan
fail ini sebagai buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Dan saya akan pergi ke hadapan
dan mengisytiharkan int utama (tidak sah).

369
00:18:31,740 --> 00:18:34,186
Dan kemudian di dalam sana
Saya akan melakukan int i _ -

370
00:18:34,186 --> 00:18:36,435
Saya mahu untuk melaksanakan program yang
dengan get_negative_int a.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Ini bukan satu fungsi yang wujud lagi.

373
00:18:40,770 --> 00:18:42,870
Jadi, kita akan melaksanakan
dalam hanya seketika.

374
00:18:42,870 --> 00:18:45,541
Tetapi kita akan melihat mengapa
ia kereta di pas pertama.

375
00:18:45,541 --> 00:18:47,290
Dan apabila saya telah mendapat
int dari pengguna,

376
00:18:47,290 --> 00:18:53,365
Saya hanya akan mencetak% i adalah negatif
integer, garis sendeng terbalik, n, koma, i.

377
00:18:53,365 --> 00:18:55,240
Dalam erti kata lain, apa yang saya
mahu program ini untuk melakukan

378
00:18:55,240 --> 00:18:58,000
adalah mendapat int negatif daripada
pengguna dan kemudian mencetak

379
00:18:58,000 --> 00:18:59,980
yang ini dan itu adalah int negatif.

380
00:18:59,980 --> 00:19:02,080
>> Sekarang saya perlu melaksanakan fungsi ini.

381
00:19:02,080 --> 00:19:05,740
Jadi kemudian dalam fail saya, saya akan pergi ke
hadapan dan mengisytiharkan fungsi yang dipanggil

382
00:19:05,740 --> 00:19:10,670
get_negative_int (tidak sah) - dan kami akan
kembali kepada apa garis yang bermakna lagi

383
00:19:10,670 --> 00:19:18,790
dalam moment-- int n; do-- do
yang following-- printf n adalah :.

384
00:19:18,790 --> 00:19:26,210
Dan kemudian saya akan lakukan n - get_int,
dan melakukan ini ketika n lebih besar daripada 0.

385
00:19:26,210 --> 00:19:28,310
Dan kemudian kembali n ;.

386
00:19:28,310 --> 00:19:31,730
>> Jadi ada banyak berlaku di
tiada ini tetapi yang mana kami tidak

387
00:19:31,730 --> 00:19:33,710
melihat minggu lalu, sekurang-kurangnya secara ringkas.

388
00:19:33,710 --> 00:19:36,980
Maka pada line 10 di sini saya telah mengisytiharkan
fungsi dipanggil get_negative_int,

389
00:19:36,980 --> 00:19:39,620
dan saya telah meletakkan (tidak sah), dalam
kurungan, sebab yang ini

390
00:19:39,620 --> 00:19:40,950
tidak mengambil input.

391
00:19:40,950 --> 00:19:42,910
Saya tidak melepasi
untuk fungsi ini.

392
00:19:42,910 --> 00:19:44,690
Saya hanya mendapat sesuatu kembali daripadanya.

393
00:19:44,690 --> 00:19:47,270
>> Dan apa yang saya berharap untuk
kembali adalah integer.

394
00:19:47,270 --> 00:19:50,040
Tiada jenis data dalam
C dipanggil negative_int.

395
00:19:50,040 --> 00:19:52,880
Ia hanya int, jadi ia akan
menjadi kepada kami untuk memastikan

396
00:19:52,880 --> 00:19:55,340
bahawa nilai yang sebenarnya
Dikembalikan bukan sahaja int

397
00:19:55,340 --> 00:19:56,380
tetapi juga negatif.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 saya mengisytiharkan pembolehubah yang
dipanggil n dan menjadikannya jenis int.

399
00:20:02,150 --> 00:20:07,500
Dan kemudian dalam talian 13 hingga 18 Saya
melakukan sesuatu ketika sesuatu itu benar.

400
00:20:07,500 --> 00:20:11,040
Saya pergi ke hadapan dan percetakan
n iaitu, kolon, dan kemudian ruang,

401
00:20:11,040 --> 00:20:12,800
seperti gesaan untuk pengguna.

402
00:20:12,800 --> 00:20:16,410
>> Saya kemudian memanggil get_int dan
menyimpan nilai yang dipanggil pulangan

403
00:20:16,410 --> 00:20:18,130
dalam pembolehubah n.

404
00:20:18,130 --> 00:20:22,600
Tetapi saya akan terus melakukan
ini manakala n adalah lebih besar daripada 0.

405
00:20:22,600 --> 00:20:27,960
Dalam erti kata lain, jika pengguna memberi saya
int dan jumlah itu adalah lebih besar daripada 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positif, saya akan
hanya menyimpan reprompting pengguna,

407
00:20:31,180 --> 00:20:37,160
menjaga reprompting, dengan memaksa mereka untuk
bekerjasama dan memberi saya int negatif.

408
00:20:37,160 --> 00:20:41,640
>> Dan sekali n sebenarnya negative--
andaikan pengguna akhirnya jenis -50,

409
00:20:41,640 --> 00:20:46,710
kemudian gelung sementara ini tidak lagi benar
kerana -50 tidak lebih besar daripada 0.

410
00:20:46,710 --> 00:20:51,140
Oleh itu, kita keluar daripada yang
gelung secara logik dan kembali n.

411
00:20:51,140 --> 00:20:53,520
>> Tetapi ada satu yang lain
Perkara yang saya perlu lakukan.

412
00:20:53,520 --> 00:20:56,190
Dan saya hanya boleh melakukan ini
dengan menyalin dan menampal

413
00:20:56,190 --> 00:20:58,540
satu baris kod di bahagian atas fail.

414
00:20:58,540 --> 00:21:01,630
Saya perlu mengajar dilafaz,
atau berjanji untuk dilafaz,

415
00:21:01,630 --> 00:21:04,630
jelas bahawa saya akan,
sesungguhnya, pergi dan melaksanakan

416
00:21:04,630 --> 00:21:06,020
ini get_negative_int fungsi.

417
00:21:06,020 --> 00:21:07,674
Ia hanya mungkin menjadi lebih rendah dalam fail.

418
00:21:07,674 --> 00:21:09,840
Sekali lagi, ingat bahawa dilafaz
membaca perkara yang atas ke bawah,

419
00:21:09,840 --> 00:21:12,330
kiri ke kanan, jadi anda tidak boleh
memanggil fungsi jika dilafaz

420
00:21:12,330 --> 00:21:15,330
tidak tahu ia akan wujud.

421
00:21:15,330 --> 00:21:18,430
>> Sekarang, malangnya, program ini,
sebagai sebahagian daripada anda mungkin akan melihat,

422
00:21:18,430 --> 00:21:19,590
sudah kereta.

423
00:21:19,590 --> 00:21:21,400
Biar saya pergi ke hadapan dan membuat buggy3.

424
00:21:21,400 --> 00:21:26,904
Ia menyusun, jadi masalah saya sekarang tidak
ralat sintaks, seperti ralat teks,

425
00:21:26,904 --> 00:21:29,570
ia sebenarnya akan menjadi logik
kesilapan yang saya telah sengaja

426
00:21:29,570 --> 00:21:32,450
dibuat sebagai satu peluang untuk
melangkah melalui apa yang sedang berlaku.

427
00:21:32,450 --> 00:21:35,540
>> Saya akan pergi ke hadapan
sekarang dan menjalankan buggy3.

428
00:21:35,540 --> 00:21:37,490
Dan saya akan pergi ke
ke hadapan dan tidak bekerjasama.

429
00:21:37,490 --> 00:21:39,494
Saya akan memberikan nombor 1.

430
00:21:39,494 --> 00:21:41,410
Ia tidak suka, jadi
ia menyebabkan saya lagi.

431
00:21:41,410 --> 00:21:42,147
>> Bagaimana kira-kira 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Tiada seorang pun daripada mereka yang bekerja.

435
00:21:44,740 --> 00:21:46,890
Bagaimana kira-kira -50?

436
00:21:46,890 --> 00:21:48,560
Dan program ini seolah-olah bekerja.

437
00:21:48,560 --> 00:21:49,970
>> Biar saya cuba sekali lagi.

438
00:21:49,970 --> 00:21:53,400
Biar saya cuba -1, seolah-olah bekerja.

439
00:21:53,400 --> 00:21:56,380
Biar saya cuba -2, seolah-olah bekerja.

440
00:21:56,380 --> 00:21:59,640
Biar saya cuba 0.

441
00:21:59,640 --> 00:22:01,684
Huh, itu tidak betul.

442
00:22:01,684 --> 00:22:03,350
Sekarang, kita menjadi sedikit bengah sini.

443
00:22:03,350 --> 00:22:07,090
Tetapi ia adalah, sesungguhnya, kes yang 0
adalah bukan positif mahupun negatif.

444
00:22:07,090 --> 00:22:11,150
Dan jadi hakikat bahawa program saya ialah
mengatakan bahawa 0 adalah integer negatif,

445
00:22:11,150 --> 00:22:12,820
itu bukan teknikal betul.

446
00:22:12,820 --> 00:22:15,180
>> Sekarang, mengapa ia berbuat demikian?

447
00:22:15,180 --> 00:22:16,270
Well, ia mungkin menjadi jelas.

448
00:22:16,270 --> 00:22:18,110
Dan sesungguhnya, program ini adalah
bertujuan untuk menjadi agak mudah

449
00:22:18,110 --> 00:22:19,670
jadi kami mempunyai sesuatu untuk meneroka.

450
00:22:19,670 --> 00:22:25,870
>> Tetapi mari kita memperkenalkan debugging ketiga
teknik sini dipanggil debug50.

451
00:22:25,870 --> 00:22:27,750
Jadi ini adalah program yang
bahawa kita baru sahaja dicipta

452
00:22:27,750 --> 00:22:30,770
tahun dipanggil ini debug50
yang akan membolehkan anda

453
00:22:30,770 --> 00:22:34,130
untuk menggunakan apa yang dipanggil terbina dalam
penyahpepijat grafik dalam CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Dan penyahpepijat hanya program yang
umumnya membolehkan anda menjalankan program anda

455
00:22:38,400 --> 00:22:44,050
tetapi langkah demi langkah demi langkah, talian
oleh baris demi baris, berhenti, poking

456
00:22:44,050 --> 00:22:47,626
sekitar, melihat pembolehubah supaya
program ini tidak hanya meniup melepasi anda

457
00:22:47,626 --> 00:22:49,750
dan cepat mencetak sesuatu
atau tidak mencetak sesuatu.

458
00:22:49,750 --> 00:22:53,250
Ia memberikan anda peluang, di
kelajuan manusia, untuk berinteraksi dengannya.

459
00:22:53,250 --> 00:22:55,470
>> Dan untuk melakukan ini, anda
hanya melakukan yang berikut.

460
00:22:55,470 --> 00:22:58,479
Selepas menyusun kod anda,
yang saya telah lakukan, buggy3,

461
00:22:58,479 --> 00:23:00,020
anda pergi ke hadapan dan menjalankan ./buggy debug50.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Begitu banyak seperti help50 mempunyai anda menjalankan
help50 dan kemudian arahan,

464
00:23:06,760 --> 00:23:10,120
debug50 mempunyai anda menjalankan debug50 dan
kemudian nama arahan.

465
00:23:10,120 --> 00:23:14,440
>> Sekarang menonton apa yang berlaku pada skrin saya,
di sebelah kanan khususnya.

466
00:23:14,440 --> 00:23:19,400
Apabila saya tekan Run, semua
tiba-tiba panel kanan ini

467
00:23:19,400 --> 00:23:20,419
membuka pada skrin.

468
00:23:20,419 --> 00:23:22,210
Dan ada banyak berlaku
pada pada pandangan pertama.

469
00:23:22,210 --> 00:23:25,110
Tetapi tidak terlalu
banyak bimbang tentang lagi.

470
00:23:25,110 --> 00:23:28,570
>> Ini menunjukkan saya segala-galanya
perkara yang berlaku di dalam program saya

471
00:23:28,570 --> 00:23:31,130
sekarang dan melalui ini
butang sehingga atas maka

472
00:23:31,130 --> 00:23:35,910
membenarkan saya untuk melangkah melalui kod saya
akhirnya langkah demi langkah demi langkah.

473
00:23:35,910 --> 00:23:37,140
Tetapi tidak lagi.

474
00:23:37,140 --> 00:23:38,060
Perhatikan apa yang berlaku.

475
00:23:38,060 --> 00:23:40,600
Pada tetingkap terminal saya
Saya diminta untuk n.

476
00:23:40,600 --> 00:23:44,560
Dan saya akan pergi ke hadapan dan
bekerjasama kali ini dan taip -1.

477
00:23:44,560 --> 00:23:48,770
Dan walaupun sedikit cryptically, -1
ialah integer negatif, seperti yang diharapkan.

478
00:23:48,770 --> 00:23:52,020
>> Dan kemudian anak keluar dengan
status 0 GDBserver keluar.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, adalah nama
perisian yang mendasari

480
00:23:55,180 --> 00:23:56,620
yang melaksanakan penyahpepijat ini.

481
00:23:56,620 --> 00:24:00,500
Tetapi semua ini benar-benar bermakna, penyahpepijat
pergi kerana program saya berhenti

482
00:24:00,500 --> 00:24:01,710
dan semua baik.

483
00:24:01,710 --> 00:24:06,020
Jika saya ingin benar-benar debug program saya,
Saya perlu preemptively memberitahu debug50,

484
00:24:06,020 --> 00:24:08,920
di mana saya ingin memulakan
melangkah melalui kod saya?

485
00:24:08,920 --> 00:24:11,750
>> Dan mungkin cara yang paling mudah
untuk berbuat demikian adalah seperti berikut.

486
00:24:11,750 --> 00:24:15,300
Jika saya pergi ke atas
longkang editor saya di sini,

487
00:24:15,300 --> 00:24:19,090
supaya benar-benar hanya dalam bar sisi sini,
sebelah kiri nombor talian,

488
00:24:19,090 --> 00:24:21,870
notis bahawa jika saya hanya klik
sekali, saya meletakkan satu titik merah kecil.

489
00:24:21,870 --> 00:24:24,460
Dan bahawa titik merah kecil,
seperti tanda berhenti, bermakna, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, pelaksanaan jeda kod saya
di sana apabila saya menjalankan program ini.

491
00:24:29,430 --> 00:24:30,260
>> Jadi mari kita buat itu.

492
00:24:30,260 --> 00:24:37,340
Biar saya pergi ke hadapan dan menjalankan program saya
lagi dengan debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Dan kini, notis, sesuatu
yang berbeza yang telah berlaku.

494
00:24:40,110 --> 00:24:42,440
Saya tidak diminta
namun dalam tetingkap terminal saya

495
00:24:42,440 --> 00:24:45,430
untuk apa-apa, kerana saya tidak mempunyai
mendapat ada lagi dalam program saya.

496
00:24:45,430 --> 00:24:47,950
Perhatikan bahawa pada baris 8
yang kini diserlahkan,

497
00:24:47,950 --> 00:24:51,720
dan ada anak panah kecil di
kata kiri, anda dijeda sini.

498
00:24:51,720 --> 00:24:55,030
Ini baris kod, garis
8, belum lagi dilaksanakan.

499
00:24:55,030 --> 00:24:58,940
>> Dan apa yang ingin tahu, jika saya melihat
di sini di sebelah kanan,

500
00:24:58,940 --> 00:25:03,530
notis bahawa saya merupakan anak tempatan
berubah-ubah, tempatan dalam erti kata

501
00:25:03,530 --> 00:25:05,450
bahawa itu dalam fungsi semasa.

502
00:25:05,450 --> 00:25:08,920
Dan nilai, nampaknya secara lalai,
dan jenis mudah, adalah 0.

503
00:25:08,920 --> 00:25:10,260
Tetapi saya tidak menaip 0.

504
00:25:10,260 --> 00:25:13,410
Yang hanya berlaku untuk menjadi yang
nilai lalai pada masa ini.

505
00:25:13,410 --> 00:25:15,490
>> Jadi biarlah saya pergi ke hadapan dan melakukan ini sekarang.

506
00:25:15,490 --> 00:25:18,680
Biar saya pergi ke hadapan dan ke atas
bahagian yang betul di sini, Saya

507
00:25:18,680 --> 00:25:20,970
akan pergi ke hadapan dan
klik ikon pertama ini yang

508
00:25:20,970 --> 00:25:25,360
bermakna langkah lebih yang bermaksud jangan skip
tetapi melangkah lebih garisan ini kod,

509
00:25:25,360 --> 00:25:27,770
menyempurnakannya di sepanjang jalan.

510
00:25:27,770 --> 00:25:30,710
>> Dan kini, notis, saya
segera baru sahaja berubah.

511
00:25:30,710 --> 00:25:31,380
Kenapa begitu?

512
00:25:31,380 --> 00:25:33,639
Saya telah diberitahu debug50,
menjalankan baris ini kod.

513
00:25:33,639 --> 00:25:34,930
Apa baris ini kod lakukan?

514
00:25:34,930 --> 00:25:35,960
Menggesa saya untuk int.

515
00:25:35,960 --> 00:25:36,460
OKEY.

516
00:25:36,460 --> 00:25:37,400
Biar saya bekerjasama.

517
00:25:37,400 --> 00:25:41,340
Biar saya pergi ke hadapan sekarang dan taip -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Dan kini melihat apa yang telah berubah.

519
00:25:42,920 --> 00:25:46,060
Pada sebelah kanan,
pembolehubah tempatan saya i

520
00:25:46,060 --> 00:25:48,200
ditunjukkan sebagai -1 sekarang.

521
00:25:48,200 --> 00:25:49,810
Dan ia masih jenis int.

522
00:25:49,810 --> 00:25:53,102
>> Dan notis, juga, saya dipanggil
memanggil timbunan, di mana saya berhenti seketika?

523
00:25:53,102 --> 00:25:54,810
Kami akan bercakap lebih lanjut mengenai
ini pada masa akan datang.

524
00:25:54,810 --> 00:25:58,620
Tetapi timbunan panggilan hanya merujuk kepada apa
Fungsi sedang berada di dalam gerakan.

525
00:25:58,620 --> 00:26:00,040
Buat masa ini ia hanya utama.

526
00:26:00,040 --> 00:26:03,590
Dan sekarang satu-satunya tempatan
pembolehubah adalah i dengan nilai 1.

527
00:26:03,590 --> 00:26:09,840
>> Dan apabila saya akhirnya melangkah lebih garisan ini
di sini, dengan icon yang sama di sebelah kanan atas,

528
00:26:09,840 --> 00:26:11,410
-1 Ialah integer negatif.

529
00:26:11,410 --> 00:26:13,580
Kini ia berhenti atas bahawa pendakap kerinting.

530
00:26:13,580 --> 00:26:14,740
Mari kita biarkan ia melakukan perkara.

531
00:26:14,740 --> 00:26:17,300
Saya melangkah bahawa garis, dan Voilà.

532
00:26:17,300 --> 00:26:20,240
>> Jadi tidak semua yang betul-betul
menyedarkan lagi,

533
00:26:20,240 --> 00:26:23,550
tetapi ia biarlah saya berhenti seketika
dan berfikir melalui logik

534
00:26:23,550 --> 00:26:24,870
apa yang program ini lakukan.

535
00:26:24,870 --> 00:26:26,890
Tetapi itu tidak berlaku salah.

536
00:26:26,890 --> 00:26:28,510
Mari kita buat ini lagi seperti berikut.

537
00:26:28,510 --> 00:26:31,340
>> Saya akan meninggalkan breakpoint yang
pada baris 8 dengan titik merah.

538
00:26:31,340 --> 00:26:32,830
Saya akan menjalankan semula debug50.

539
00:26:32,830 --> 00:26:34,400
Ia secara automatik berhenti di sini.

540
00:26:34,400 --> 00:26:37,660
Tetapi kali ini, bukan
melangkah lebih garisan ini,

541
00:26:37,660 --> 00:26:42,290
biarlah saya benar-benar pergi di dalam
get_negative_int dan memikirkan,

542
00:26:42,290 --> 00:26:45,530
mengapa ia menerima 0 sebagai jawapan yang sah?

543
00:26:45,530 --> 00:26:47,990
>> Jadi, daripada klik Step Over.

544
00:26:47,990 --> 00:26:50,630
Saya akan pergi ke hadapan
dan klik Step Into.

545
00:26:50,630 --> 00:26:54,030
Dan perhatikan bahawa garis 8 itulah
kini menekankan kini tiba-tiba

546
00:26:54,030 --> 00:26:56,900
menjadi garis 17.

547
00:26:56,900 --> 00:26:59,947
>> Kini, ia bukan yang penyahpepijat
telah dilangkau baris 14 dan 15 dan 16.

548
00:26:59,947 --> 00:27:01,780
Ia hanya tiada apa-apa
untuk menunjukkan kepada anda di sana.

549
00:27:01,780 --> 00:27:04,050
Mereka hanya mengisytiharkan pembolehubah,
Dan kemudian ada perkataan Adakah

550
00:27:04,050 --> 00:27:05,390
dan kemudian satu pendakap kerinting terbuka.

551
00:27:05,390 --> 00:27:09,227
Satu-satunya garis berfungsi itulah
berair benar-benar adalah salah satu ini di sini, 17.

552
00:27:09,227 --> 00:27:11,060
Dan itulah di mana kami telah
berhenti secara automatik.

553
00:27:11,060 --> 00:27:13,870
>> Jadi printf ( "n.is:") ;, supaya
yang tidak berlaku lagi.

554
00:27:13,870 --> 00:27:18,250
Jadi mari kita teruskan dan klik Datang.

555
00:27:18,250 --> 00:27:20,326
Sekarang segera saya, sesungguhnya,
ditukar kepada ( "n ialah:").

556
00:27:20,326 --> 00:27:22,450
Sekarang get_int, saya tidak akan
mengganggu melangkah ke dalam,

557
00:27:22,450 --> 00:27:24,750
kerana fungsi itu adalah
dibuat oleh CS50 di Perpustakaan.

558
00:27:24,750 --> 00:27:25,750
Ia mungkin betul.

559
00:27:25,750 --> 00:27:28,440
>> Jadi, saya akan pergi ke hadapan dan
jenis bekerjasama dengan memberi

560
00:27:28,440 --> 00:27:30,590
int, tetapi tidak int negatif.

561
00:27:30,590 --> 00:27:32,870
Jadi biarlah saya pergi ke hadapan dan tekan 0.

562
00:27:32,870 --> 00:27:39,460
Dan sekarang apa yang berlaku di sini
apabila saya turun ke beratur 21?

563
00:27:39,460 --> 00:27:40,890
Saya tidak terlelar lagi.

564
00:27:40,890 --> 00:27:43,320
Saya seolah-olah tidak terperangkap dalam gelung itu.

565
00:27:43,320 --> 00:27:45,990
Dalam erti kata lain, ini kuning
bar tidak terus pergi sekitar,

566
00:27:45,990 --> 00:27:47,130
dan di sekeliling, dan sekitar.

567
00:27:47,130 --> 00:27:48,340
>> Sekarang, mengapa?

568
00:27:48,340 --> 00:27:49,920
Well, n, apa yang adalah n sekarang?

569
00:27:49,920 --> 00:27:53,280
Saya boleh melihat tempatan
pembolehubah dalam penyahpepijat.

570
00:27:53,280 --> 00:27:53,816
n ialah 0.

571
00:27:53,816 --> 00:27:55,190
Baiklah, apa yang keadaan saya?

572
00:27:55,190 --> 00:27:58,700
>> 20-- talian 20 adalah, baik,
0 adalah lebih besar daripada 0.

573
00:27:58,700 --> 00:27:59,500
Itu tidak benar.

574
00:27:59,500 --> 00:28:01,020
0 tidak lebih besar daripada 0.

575
00:28:01,020 --> 00:28:02,820
Oleh itu, saya tercetus daripada ini.

576
00:28:02,820 --> 00:28:06,370
>> Dan itulah sebabnya mengapa di talian
21, jika saya benar-benar terus,

577
00:28:06,370 --> 00:28:10,370
Saya akan kembali 0, walaupun
walaupun saya sepatutnya ditolak 0

578
00:28:10,370 --> 00:28:12,484
tidak benar-benar berada negatif.

579
00:28:12,484 --> 00:28:14,650
Oleh sebab itu, saya tidak benar-benar walaupun
mengambil berat tentang penyahpepijat.

580
00:28:14,650 --> 00:28:16,900
Tidak perlu lagi, saya tidak perlu
tahu, apakah yang sedang berlaku.

581
00:28:16,900 --> 00:28:19,233
>> Jadi, saya akan pergi ke hadapan dan
hanya klik butang Main,

582
00:28:19,233 --> 00:28:20,240
dan membiarkan penamat ini sehingga.

583
00:28:20,240 --> 00:28:23,440
Sekarang, saya sedar bahawa saya
bug nampaknya pada baris 20.

584
00:28:23,440 --> 00:28:25,160
Itulah ralat logik saya.

585
00:28:25,160 --> 00:28:28,100
>> Dan supaya apa yang saya mahu
lakukan untuk mengubah ini?

586
00:28:28,100 --> 00:28:32,500
Jika masalahnya ialah bahawa saya tidak
menangkap 0, ia hanya satu ralat logik.

587
00:28:32,500 --> 00:28:35,910
Dan saya boleh katakan manakala n adalah
lebih besar daripada atau sama dengan 0,

588
00:28:35,910 --> 00:28:38,330
menjaga mendorong pengguna lagi dan lagi.

589
00:28:38,330 --> 00:28:41,050
>> Jadi, sekali lagi, kesilapan mudah, mungkin
walaupun jelas apabila anda melihat saya

590
00:28:41,050 --> 00:28:42,410
menulis hanya beberapa minit yang lalu.

591
00:28:42,410 --> 00:28:44,570
Tetapi bisa dibesarkan di sini
adalah bahawa dengan debug 50,

592
00:28:44,570 --> 00:28:46,850
dan dengan debugging
perisian lebih umum,

593
00:28:46,850 --> 00:28:51,370
anda mempunyai kuasa ini mendapati baru untuk
berjalan melalui kod anda sendiri, melihat

594
00:28:51,370 --> 00:28:55,590
melalui panel tangan kanan apa
nilai-nilai pembolehubah anda berada.

595
00:28:55,590 --> 00:28:57,700
Jadi, anda tidak semestinya
perlu menggunakan sesuatu

596
00:28:57,700 --> 00:29:00,630
seperti anda eprintf untuk mencetak nilai-nilai.

597
00:29:00,630 --> 00:29:04,430
Anda sebenarnya boleh melihat mereka
visual pada skrin.

598
00:29:04,430 --> 00:29:08,920
>> Sekarang, di luar ini, ia adalah diperhatikan
bahawa terdapat satu lagi teknik itulah

599
00:29:08,920 --> 00:29:09,890
sebenarnya super biasa.

600
00:29:09,890 --> 00:29:13,120
Dan anda mungkin tertanya-tanya mengapa ini sedikit
Lelaki sini telah duduk di atas pentas.

601
00:29:13,120 --> 00:29:16,490
Jadi ada teknik ini, secara amnya
dikenali sebagai getah itik debugging,

602
00:29:16,490 --> 00:29:18,786
yang benar-benar hanya
bukti kepada hakikat

603
00:29:18,786 --> 00:29:20,660
bahawa pengaturcara kerap apabila
menulis kod,

604
00:29:20,660 --> 00:29:22,650
mereka tidak semestinya
bekerjasama dengan orang lain,

605
00:29:22,650 --> 00:29:24,030
atau bekerja dalam persekitaran yang dikongsi.

606
00:29:24,030 --> 00:29:25,050
>> Mereka semacam di rumah.

607
00:29:25,050 --> 00:29:25,910
Mungkin ia adalah lewat malam.

608
00:29:25,910 --> 00:29:28,190
Mereka cuba untuk angka
beberapa bug dalam kod mereka.

609
00:29:28,190 --> 00:29:29,330
Dan mereka tidak melihatnya.

610
00:29:29,330 --> 00:29:30,329
>> Dan tidak ada rakan sebilik.

611
00:29:30,329 --> 00:29:31,250
Tiada TF.

612
00:29:31,250 --> 00:29:32,680
Tiada CA sekitar.

613
00:29:32,680 --> 00:29:36,440
Apa yang mereka ada di rak mereka
adalah bebek ini getah sedikit.

614
00:29:36,440 --> 00:29:39,030
>> Dan sebagainya itik getah debugging
hanya jemputan ini

615
00:29:39,030 --> 00:29:42,780
untuk memikirkan sesuatu yang bodoh
kerana ini sebagai makhluk sebenar,

616
00:29:42,780 --> 00:29:46,940
dan sebenarnya berjalan melalui kod anda
secara lisan kepada objek tidak bernyawa ini.

617
00:29:46,940 --> 00:29:49,230
Jadi, sebagai contoh, jika
ini adalah contoh saya sini--

618
00:29:49,230 --> 00:29:52,470
dan ingat bahawa sebelum ini
masalah itu ini,

619
00:29:52,470 --> 00:29:58,140
jika saya memadam baris pertama kod ini,
dan saya pergi ke hadapan dan membuat kereta 0 lagi,

620
00:29:58,140 --> 00:30:01,220
ingat bahawa saya mempunyai ini
mesej ralat di sini.

621
00:30:01,220 --> 00:30:05,997
Jadi idea di sini, tidak masuk akal walaupun saya
rasa pada masa ini melakukan ini secara terbuka,

622
00:30:05,997 --> 00:30:06,580
kesilapan itu.

623
00:30:06,580 --> 00:30:10,910
>> OK, jadi masalah saya adalah bahawa saya telah
tersirat mengisytiharkan fungsi perpustakaan.

624
00:30:10,910 --> 00:30:12,610
Dan fungsi perpustakaan adalah printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, mengisytiharkan
mengingatkan saya kepada prototaip.

626
00:30:15,290 --> 00:30:18,930
>> Ini bermakna saya perlu untuk benar-benar
memberitahu pengkompil terlebih dahulu apa

627
00:30:18,930 --> 00:30:19,980
majlis itu kelihatan seperti.

628
00:30:19,980 --> 00:30:20,930
Tunggu sebentar.

629
00:30:20,930 --> 00:30:23,580
Saya tidak mempunyai io.h. standard

630
00:30:23,580 --> 00:30:24,530
Terima kasih banyak - banyak.

631
00:30:24,530 --> 00:30:27,330
>> Jadi hanya proses ini daripada- anda
tidak perlu untuk benar-benar mempunyai itik.

632
00:30:27,330 --> 00:30:29,819
Tetapi idea ini berjalan
diri anda melalui kod anda sendiri

633
00:30:29,819 --> 00:30:31,610
supaya anda juga mendengar
diri sendiri, supaya kamu

634
00:30:31,610 --> 00:30:35,620
menyedari ketinggalan dalam anda sendiri
kata-kata, biasanya idea.

635
00:30:35,620 --> 00:30:38,910
>> Dan, mungkin lebih logik, tidak begitu
banyak dengan yang satu tetapi lebih terlibat

636
00:30:38,910 --> 00:30:44,220
contoh kita lakukan dalam 3.C kereta,
anda mungkin berjalan diri melaluinya

637
00:30:44,220 --> 00:30:45,310
seperti berikut.

638
00:30:45,310 --> 00:30:49,190
Jadi semua hak, getah
bebek, DDB, jika anda akan.

639
00:30:49,190 --> 00:30:52,350
Di sini kita mempunyai dalam fungsi utama saya,
Saya menyeru mendapatkan int negatif.

640
00:30:52,350 --> 00:30:54,660
>> Dan saya semakin nilai pulangan.

641
00:30:54,660 --> 00:31:00,410
Saya menyimpan ia di sebelah kiri
pada baris 8 dalam pembolehubah yang dipanggil i.

642
00:31:00,410 --> 00:31:02,380
OK, tetapi menunggu, bagaimana
yang mendapat nilai itu?

643
00:31:02,380 --> 00:31:04,130
Biar saya melihat fungsi dalam talian 12.

644
00:31:04,130 --> 00:31:05,760
>> Selaras 12, kita telah mendapatkan int negatif.

645
00:31:05,760 --> 00:31:08,190
Tidak mengambil apa-apa input,
tidak kembali int, OK.

646
00:31:08,190 --> 00:31:10,929
Saya mengaku pada baris 14 a n berubah-ubah.

647
00:31:10,929 --> 00:31:12,220
Ia akan menyimpan integer.

648
00:31:12,220 --> 00:31:13,760
Itulah yang saya mahu.

649
00:31:13,760 --> 00:31:18,480
>> Jadi lakukan perkara berikut manakala n is-- biarlah
saya membatalkan apa yang menetapkan saya sudah dibuat.

650
00:31:18,480 --> 00:31:22,710
Oleh itu, sambil n lebih besar daripada
0, mencetak n iaitu, OK.

651
00:31:22,710 --> 00:31:25,170
Dan kemudian memanggil mendapatkan int disimpan dalam n.

652
00:31:25,170 --> 00:31:30,160
Dan kemudian memeriksa jika n adalah 0,
n adalah tidak-- ada ia.

653
00:31:30,160 --> 00:31:31,910
Jadi, sekali lagi, anda tidak
perlu itik yang sebenar.

654
00:31:31,910 --> 00:31:35,650
Tetapi hanya berjalan diri anda melalui
kod anda sebagai latihan intelektual

655
00:31:35,650 --> 00:31:37,720
kerap akan membantu anda
sedar apa yang berlaku,

656
00:31:37,720 --> 00:31:41,170
berbanding dengan hanya melakukan sesuatu
seperti ini, merenung skrin,

657
00:31:41,170 --> 00:31:43,720
dan tidak bercakap diri anda melalui
ia, yang jujur ​​tidak

658
00:31:43,720 --> 00:31:46,270
hampir yang teknik yang berkesan.

659
00:31:46,270 --> 00:31:48,620
Jadi ada anda mempunyai ia,
beberapa teknik yang berbeza

660
00:31:48,620 --> 00:31:52,102
untuk benar-benar debugging kod anda
dan mencari kesalahan, semua yang

661
00:31:52,102 --> 00:31:54,810
harus menjadi alat dalam Kit anda
supaya anda tidak lewat malam,

662
00:31:54,810 --> 00:31:57,660
terutamanya, anda berada dalam makan
dewan, atau pada waktu pejabat,

663
00:31:57,660 --> 00:32:00,368
terhantuk kepala anda terhadap
dinding, cuba untuk menyelesaikan beberapa masalah.

664
00:32:00,368 --> 00:32:02,020
Sedar bahawa terdapat alat perisian.

665
00:32:02,020 --> 00:32:03,720
Terdapat alat itik getah.

666
00:32:03,720 --> 00:32:09,630
Dan ada kakitangan keseluruhan
menyokong menunggu untuk menghulurkan bantuan.

667
00:32:09,630 --> 00:32:13,120
>> Oleh sebab itu, satu perkataan pada masalah
set, dan kepada apa yang kami berharap anda

668
00:32:13,120 --> 00:32:15,620
keluar dari mereka, dan bagaimana
kita pergi tentang menilai.

669
00:32:15,620 --> 00:32:17,680
Setiap sukatan pelajaran kursus ini,
set masalah CS50

670
00:32:17,680 --> 00:32:22,320
dinilai pada empat paksi utama, jadi
untuk speak-- skop, ketepatan, reka bentuk,

671
00:32:22,320 --> 00:32:23,060
dan gaya.

672
00:32:23,060 --> 00:32:25,910
Dan skop hanya merujuk kepada berapa banyak
sekeping yang telah anda digigit?

673
00:32:25,910 --> 00:32:28,080
Berapa banyak masalah yang telah anda cuba?

674
00:32:28,080 --> 00:32:30,110
Apa tahap usaha
telah anda dijelmakan?

675
00:32:30,110 --> 00:32:35,750
>> Kebenaran adalah, adakah kerja program ini sebagai
ia sepatutnya mengikut spesifikasi CS50

676
00:32:35,750 --> 00:32:38,640
apabila anda memberikan input tertentu
atau output tertentu datang kembali?

677
00:32:38,640 --> 00:32:41,130
Design adalah yang paling subjektif mereka.

678
00:32:41,130 --> 00:32:43,360
Dan ia adalah salah satu yang akan
mengambil yang paling lama untuk belajar

679
00:32:43,360 --> 00:32:47,220
dan yang paling lama untuk mengajar, dalam
setakat yang disimpulkan di sini

680
00:32:47,220 --> 00:32:49,530
bagaimana yang ditulis dengan baik adalah kod anda?

681
00:32:49,530 --> 00:32:52,920
>> Ia satu perkara untuk hanya mencetak yang betul
output atau kembali nilai-nilai yang betul.

682
00:32:52,920 --> 00:32:55,400
Tetapi yang anda lakukan sebagai
cekap yang mungkin?

683
00:32:55,400 --> 00:32:58,210
Adakah anda melakukan ia jurang
dan menakluk, atau binari

684
00:32:58,210 --> 00:33:01,500
carian seperti yang kita tidak lama lagi akan melihat bahawa kita lakukan
dua minggu lalu dengan buku telefon?

685
00:33:01,500 --> 00:33:04,670
Adakah terdapat cara yang lebih baik untuk menyelesaikan
masalah daripada apa yang anda kini ada di sini?

686
00:33:04,670 --> 00:33:06,380
Itu satu peluang untuk reka bentuk yang lebih baik.

687
00:33:06,380 --> 00:33:08,530
>> Dan kemudian style-- bagaimana
cantik adalah kod anda?

688
00:33:08,530 --> 00:33:12,370
Anda akan melihat bahawa saya cukup
tertentu mengenai mengensotkannya kod saya,

689
00:33:12,370 --> 00:33:15,300
dan memastikan pembolehubah saya
dengan munasabah yang dinamakan. n,

690
00:33:15,300 --> 00:33:19,660
Tidak lama, adalah nama yang baik untuk
nombor, i untuk integer mengira,

691
00:33:19,660 --> 00:33:20,727
kerana rentetan.

692
00:33:20,727 --> 00:33:22,560
Dan kita boleh mempunyai lagi
gaya nama-nama pembolehubah.

693
00:33:22,560 --> 00:33:25,500
Style ialah betapa baik
fungsi kod anda kelihatan?

694
00:33:25,500 --> 00:33:26,600
Dan bagaimana boleh dibaca itu?

695
00:33:26,600 --> 00:33:29,650
>> Dan dari masa ke masa, apa TA anda
dan TFS akan lakukan dalam perjalanan

696
00:33:29,650 --> 00:33:31,870
adalah menyediakan anda dengan itu
jenis maklum balas kualitatif

697
00:33:31,870 --> 00:33:34,330
supaya anda menjadi lebih baik
pada mereka pelbagai aspek.

698
00:33:34,330 --> 00:33:37,510
Dan dari segi bagaimana kita
menilai setiap paksi ini,

699
00:33:37,510 --> 00:33:40,080
ia biasanya dengan sedikit
baldi supaya anda, secara amnya,

700
00:33:40,080 --> 00:33:41,680
mendapatkan rasa bagaimana yang anda lakukan.

701
00:33:41,680 --> 00:33:45,680
Dan, ya, jikalau engkau menerima skor pada
mana-mana kebenaran axes--, reka bentuk

702
00:33:45,680 --> 00:33:49,659
dan gaya especially-- jumlah itu
biasanya akan mengandungi antara 1 dan 5.

703
00:33:49,659 --> 00:33:52,450
Dan, secara literal, jika anda mendapat
3 pada permulaan semester,

704
00:33:52,450 --> 00:33:53,977
ini adalah satu perkara yang sangat baik.

705
00:33:53,977 --> 00:33:55,810
Ini bermakna masih ada
ruang untuk penambahbaikan,

706
00:33:55,810 --> 00:33:58,490
yang anda akan berharap dalam
mengambil kelas untuk kali pertama.

707
00:33:58,490 --> 00:34:01,820
Ada mudahan beberapa sedikit siling
yang anda bercita-cita untuk mencapai.

708
00:34:01,820 --> 00:34:03,970
Dan supaya mendapat pada 3 ini
keping terawal,

709
00:34:03,970 --> 00:34:06,550
jika tidak beberapa 2 dan 4 ini,
adalah, sememangnya, satu perkara yang baik.

710
00:34:06,550 --> 00:34:08,880
Ia cukup dalam liputan,
baik dalam jangkaan.

711
00:34:08,880 --> 00:34:11,421
>> Dan jika fikiran anda berlumba-lumba, tunggu
satu minit, tiga daripada lima.

712
00:34:11,421 --> 00:34:12,620
Itu benar-benar keluar 6 10.

713
00:34:12,620 --> 00:34:13,560
Itulah 60%.

714
00:34:13,560 --> 00:34:14,830
Allahku, itulah F.

715
00:34:14,830 --> 00:34:15,870
>> Ianya bukan.

716
00:34:15,870 --> 00:34:17,600
Tidak, sebenarnya, bahawa.

717
00:34:17,600 --> 00:34:22,710
Sebaliknya, ia adalah satu peluang untuk meningkatkan
sepanjang semester.

718
00:34:22,710 --> 00:34:25,580
Dan jika anda mendapat beberapa
Poors, ini adalah peluang

719
00:34:25,580 --> 00:34:29,199
untuk mengambil kesempatan daripada waktu pejabat,
pasti bahagian dan sumber-sumber lain.

720
00:34:29,199 --> 00:34:32,840
>> Best peluang, benar-benar,
yang boleh dibanggakan sejauh mana anda telah

721
00:34:32,840 --> 00:34:34,520
datang sepanjang semester.

722
00:34:34,520 --> 00:34:38,199
Jadi jangan sedar, jika apa-apa
lain, tiga adalah baik.

723
00:34:38,199 --> 00:34:40,179
Dan ia membolehkan ruang untuk pertumbuhan masa ke masa.

724
00:34:40,179 --> 00:34:43,090
>> Iaitu bagaimana paksi adalah
wajaran, realistik anda berada

725
00:34:43,090 --> 00:34:46,745
akan menghabiskan sebahagian besar masa anda mendapat
perkara yang perlu bekerja, apatah lagi dengan betul.

726
00:34:46,745 --> 00:34:49,120
Dan supaya kebenaran cenderung untuk
akan diberatkan yang paling, seperti

727
00:34:49,120 --> 00:34:51,360
faktor pendaraban ini tiga.

728
00:34:51,360 --> 00:34:54,659
Design juga penting, tetapi
sesuatu yang anda tidak semestinya

729
00:34:54,659 --> 00:34:58,220
menghabiskan semua waktu-waktu di
cuba untuk mendapatkan perkara yang hanya untuk bekerja.

730
00:34:58,220 --> 00:35:00,019
>> Dan jadi ia berwajaran
sedikit lebih ringan.

731
00:35:00,019 --> 00:35:01,560
Dan kemudian gaya wajaran sekurang-kurangnya.

732
00:35:01,560 --> 00:35:03,710
Walaupun ia tidak kurang
penting asasnya,

733
00:35:03,710 --> 00:35:05,990
ia hanya, mungkin,
Perkara yang paling mudah untuk berbuat baik,

734
00:35:05,990 --> 00:35:08,440
meniru contoh kita
lakukan dalam kuliah dan seksyen,

735
00:35:08,440 --> 00:35:11,080
dengan perkara-perkara baik
tersusun, dan berkata,

736
00:35:11,080 --> 00:35:14,320
dan sebagainya adalah antara yang paling mudah
perkara yang perlu dilakukan dan mendapatkan hak.

737
00:35:14,320 --> 00:35:16,960
Jadi oleh itu, menyedari
bahawa mereka adalah mata

738
00:35:16,960 --> 00:35:19,000
yang agak mudah untuk memahami.

739
00:35:19,000 --> 00:35:22,360
>> Dan kini satu perkataan pada
this-- kejujuran akademik.

740
00:35:22,360 --> 00:35:25,150
Jadi setiap kursus ini
sukatan pelajaran, anda akan melihat

741
00:35:25,150 --> 00:35:27,630
bahawa kursus ini mempunyai cukup
sedikit bahasa sekitar ini.

742
00:35:27,630 --> 00:35:31,380
Dan kursus ini mengambil isu
kejujuran akademik agak serius.

743
00:35:31,380 --> 00:35:33,450
>> Kami mempunyai perbezaan,
untuk lebih baik atau untuk lebih teruk,

744
00:35:33,450 --> 00:35:36,570
kerana telah dihantar setiap tahun lebih
pelajar untuk tindakan tatatertib

745
00:35:36,570 --> 00:35:39,670
daripada kebanyakan yang lain
Sudah tentu, bahawa saya sedar.

746
00:35:39,670 --> 00:35:42,580
Ini tidak semestinya
menunjukkan hakikat

747
00:35:42,580 --> 00:35:46,340
pelajar CS, atau pelajar CS50, adalah
apa-apa kurang jujur ​​daripada rakan sekelas anda.

748
00:35:46,340 --> 00:35:49,090
Tetapi realiti bahawa dalam ini
dunia, elektronik, kita hanya

749
00:35:49,090 --> 00:35:50,990
mempunyai teknologi
bermakna mengesan ini.

750
00:35:50,990 --> 00:35:53,360
>> Ia adalah penting kepada kami untuk
keadilan seluruh kelas

751
00:35:53,360 --> 00:35:58,550
yang kita lakukan mengesan ini, dan meningkatkan
isu ini apabila kita melihat sesuatu.

752
00:35:58,550 --> 00:36:01,980
Dan hanya untuk melukis sekeping gambar, dan benar-benar
untuk membantu sesuatu seperti sink ini,

753
00:36:01,980 --> 00:36:04,600
Inilah jumlah daripada
pelajar dalam tempoh 10 tahun yang lalu

754
00:36:04,600 --> 00:36:07,610
yang telah terlibat dalam beberapa
isu-isu seperti kejujuran akademik,

755
00:36:07,610 --> 00:36:10,990
dengan kira-kira 32 pelajar
daripada kejatuhan 2015, yang

756
00:36:10,990 --> 00:36:13,760
untuk mengatakan bahawa kita mengambil
perkara itu dengan serius.

757
00:36:13,760 --> 00:36:18,380
Dan, akhirnya, nombor-nombor mengarang,
Yang baru, kira-kira 3%, 4% atau lebih

758
00:36:18,380 --> 00:36:19,120
kelas.

759
00:36:19,120 --> 00:36:25,220
>> Jadi untuk super majoriti pelajar
ia seolah-olah bahawa garis-garis yang jelas.

760
00:36:25,220 --> 00:36:27,940
Tetapi jangan menyimpan ini dalam
keberatan, terutama lewat

761
00:36:27,940 --> 00:36:32,080
pada waktu malam apabila bergelut dengan
beberapa penyelesaian kepada masalah set,

762
00:36:32,080 --> 00:36:34,830
bahawa terdapat mekanisme
untuk mendapatkan diri anda lebih baik

763
00:36:34,830 --> 00:36:37,870
sokongan daripada anda mungkin
berfikir, walaupun pada ketika itu juga.

764
00:36:37,870 --> 00:36:40,514
Sedarlah bahawa apabila kita menerima
penyerahan pelajar, kita menyeberang

765
00:36:40,514 --> 00:36:43,430
membandingkan setiap penyerahan tahun ini
terhadap setiap penyerahan tahun lepas,

766
00:36:43,430 --> 00:36:47,590
terhadap setiap penyerahan dari tahun 2007,
dan sejak, melihat, dan juga,

767
00:36:47,590 --> 00:36:49,931
kod repositori dalam talian,
forum perbincangan, tapak kerja.

768
00:36:49,931 --> 00:36:51,806
Dan kita sebut ini,
benar-benar, semua demi kepentingan

769
00:36:51,806 --> 00:36:56,040
pendedahan sepenuhnya, bahawa jika
orang lain boleh mencari dalam talian,

770
00:36:56,040 --> 00:36:57,880
pasti, jadi boleh kita kursus.

771
00:36:57,880 --> 00:37:00,100
Tetapi, benar-benar, semangat
sudah tentu ini berkisar

772
00:37:00,100 --> 00:37:01,650
klausa ini dalam sukatan pelajaran.

773
00:37:01,650 --> 00:37:03,670
Ia benar-benar adil, munasabah.

774
00:37:03,670 --> 00:37:06,680
>> Dan jika kita terpaksa mengulas lanjut mengenai yang
dengan hanya satu bahasa yang agak lanjut,

775
00:37:06,680 --> 00:37:09,770
sedar bahawa intipati semua
kerja-kerja yang anda serahkan kepada kursus ini

776
00:37:09,770 --> 00:37:10,954
mesti anda sendiri.

777
00:37:10,954 --> 00:37:13,870
Tetapi dalam masa itu, tentunya ada
peluang dan galakan,

778
00:37:13,870 --> 00:37:17,300
dan nilai pedagogi dalam beralih kepada
others-- diri saya sendiri, yang TFS, CA yang,

779
00:37:17,300 --> 00:37:20,760
Tas, dan lain-lain di dalam kelas,
untuk sokongan, membiarkan rakan-rakan sahaja

780
00:37:20,760 --> 00:37:23,547
dan rakan sebilik yang mengkaji
CS manakala program sebelum ini.

781
00:37:23,547 --> 00:37:25,130
Dan sebagainya ada peruntukan untuk itu.

782
00:37:25,130 --> 00:37:28,180
Dan peraturan am ibu jari
adalah this-- ketika meminta bantuan,

783
00:37:28,180 --> 00:37:31,470
anda boleh menunjukkan kod anda kepada orang lain,
tetapi anda tidak boleh melihat mereka.

784
00:37:31,470 --> 00:37:34,880
Jadi, walaupun anda berada di waktu pejabat,
atau di dalam dewan D, atau di tempat lain

785
00:37:34,880 --> 00:37:37,450
bekerja di beberapa set piece,
bekerjasama dengan rakan, yang

786
00:37:37,450 --> 00:37:40,160
adalah betul-betul halus, pada
akhir hari kerja anda

787
00:37:40,160 --> 00:37:43,034
akhirnya harus dimiliki oleh setiap
di antara kamu masing-masing, dan tidak

788
00:37:43,034 --> 00:37:45,700
ada beberapa usaha sama,
kecuali projek akhir di mana

789
00:37:45,700 --> 00:37:47,410
ia dibenarkan dan digalakkan.

790
00:37:47,410 --> 00:37:49,830
>> Sedar bahawa jika anda
bergelut dengan sesuatu

791
00:37:49,830 --> 00:37:52,520
dan rakan anda hanya berlaku
untuk menjadi lebih baik pada ini maka anda,

792
00:37:52,520 --> 00:37:55,130
atau lebih baik pada masalah itu daripada kamu,
atau sedikit lebih jauh ke hadapan daripada kamu,

793
00:37:55,130 --> 00:37:57,330
ia benar-benar munasabah untuk menghidupkan
kepada rakan anda dan berkata, hey,

794
00:37:57,330 --> 00:38:00,480
adakah anda keberatan melihat kod saya di sini,
membantu saya mengesan apa isu saya adalah?

795
00:38:00,480 --> 00:38:03,760
Dan, mudah-mudahan, dalam
kepentingan nilai pedagogi

796
00:38:03,760 --> 00:38:07,040
rakan yang tidak hanya
berkata, oh, melakukan ini, tetapi sebaliknya,

797
00:38:07,040 --> 00:38:09,917
apa yang kau hilang di talian
6, atau sesuatu seperti itu?

798
00:38:09,917 --> 00:38:12,000
Tetapi penyelesaian tidak
untuk rakan di sebelah anda

799
00:38:12,000 --> 00:38:15,617
berkata, oh, baik, di sini, saya ingin menarik
ini, dan menunjukkan penyelesaian saya kepada anda.

800
00:38:15,617 --> 00:38:16,450
Jadi itulah garis.

801
00:38:16,450 --> 00:38:18,670
Anda menunjukkan kod anda untuk
orang lain, tetapi anda tidak boleh

802
00:38:18,670 --> 00:38:22,350
melihat mereka, tertakluk kepada yang lain
kekangan dalam sukatan pelajaran kursus ini.

803
00:38:22,350 --> 00:38:24,760
>> Jadi jangan ingat ini
apa yang dipanggil fasal penyesalan

804
00:38:24,760 --> 00:38:27,560
dalam sukatan pelajaran kursus ini juga,
bahawa jika anda melakukan beberapa perbuatan yang

805
00:38:27,560 --> 00:38:30,476
tidak munasabah, tetapi membawa kepada
perhatian ketua kursus ini

806
00:38:30,476 --> 00:38:34,240
dalam masa 72 jam, kursus ini
boleh mengenakan sekatan tempatan yang

807
00:38:34,240 --> 00:38:37,380
boleh termasuk yang tidak memuaskan atau
gagal gred untuk kerja-kerja yang dikemukakan.

808
00:38:37,380 --> 00:38:41,410
Tetapi tentu tidak akan merujuk
kira untuk tindakan tatatertib selanjutnya,

809
00:38:41,410 --> 00:38:43,010
kecuali dalam kes-kes tindakan berulang.

810
00:38:43,010 --> 00:38:46,632
Dalam erti kata lain, jika anda membuat beberapa
bodoh, terutama lewat malam, keputusan

811
00:38:46,632 --> 00:38:49,340
yang pagi esok atau dua hari
kemudian, anda bangun dan sedar,

812
00:38:49,340 --> 00:38:50,870
apa yang saya fikirkan?

813
00:38:50,870 --> 00:38:53,890
Anda lakukan dalam CS50 mempunyai jalan keluar
untuk menetapkan masalah yang

814
00:38:53,890 --> 00:38:57,170
dan memiliki sehingga ia, supaya kita
akan bertemu dengan kamu separuh ke bawah dan menangani

815
00:38:57,170 --> 00:39:01,500
dengannya dalam suatu perkara yang kedua-dua
pendidikan dan berharga untuk anda,

816
00:39:01,500 --> 00:39:04,200
tetapi masih punitif dalam beberapa cara.

817
00:39:04,200 --> 00:39:08,590
Dan kini, untuk menghilangkan kegembiraan, ini.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO MAIN SEMULA]

819
00:39:10,570 --> 00:39:13,540
>> [MUZIK Bermain]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [AKHIR MAIN SEMULA]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN: Baiklah, kita kembali.

823
00:40:00,490 --> 00:40:03,680
Dan sekarang kita melihat salah satu daripada
pertama domain dunia sebenar kita

824
00:40:03,680 --> 00:40:08,720
dalam CS50, seni kriptografi,
seni menghantar dan menerima

825
00:40:08,720 --> 00:40:11,840
mesej rahsia, disulitkan
mesej jika anda akan,

826
00:40:11,840 --> 00:40:17,060
yang hanya boleh ditafsirkan jika anda mempunyai
beberapa bahan utama bahawa pengirim mempunyai

827
00:40:17,060 --> 00:40:18,030
juga.

828
00:40:18,030 --> 00:40:22,120
Jadi untuk memberi motivasi ini kami akan mengambil
yang melihat perkara ini di sini,

829
00:40:22,120 --> 00:40:26,750
yang merupakan satu contoh
cincin penyahkod rahsia yang

830
00:40:26,750 --> 00:40:34,042
boleh digunakan untuk memikirkan
apa mesej rahsia sebenarnya.

831
00:40:34,042 --> 00:40:35,750
Malah, kembali dalam
hari di sekolah gred,

832
00:40:35,750 --> 00:40:38,787
jika anda pernah menghantar mesej rahsia kepada
beberapa rakan atau beberapa menghancurkan di dalam kelas,

833
00:40:38,787 --> 00:40:40,620
anda mungkin berfikir
anda pandai

834
00:40:40,620 --> 00:40:46,530
oleh pada sekeping anda berubah kertas,
seperti, A ke B, dan B kepada C, dan C untuk D,

835
00:40:46,530 --> 00:40:47,590
dan sebagainya.

836
00:40:47,590 --> 00:40:50,300
Tetapi anda sebenarnya menyulitkan
maklumat anda, walaupun

837
00:40:50,300 --> 00:40:53,300
jika ia adalah remeh sedikit, tidak
sukar bagi guru untuk sedar,

838
00:40:53,300 --> 00:40:55,675
baik, jika anda hanya menukar
B ke A dan C kepada B,

839
00:40:55,675 --> 00:40:57,550
anda sebenarnya memikirkan
apa mesej itu,

840
00:40:57,550 --> 00:40:59,700
tetapi anda berada dalam ciphering maklumat.

841
00:40:59,700 --> 00:41:03,420
>> Anda hanya melakukannya
semata-mata, sama seperti Ralphie sini

842
00:41:03,420 --> 00:41:07,934
dalam filem terkenal yang memainkan
cukup banyak iklan nauseum setiap musim sejuk.

843
00:41:07,934 --> 00:41:08,600
[VIDEO MAIN SEMULA]

844
00:41:08,600 --> 00:41:11,180
-Be Ia diketahui oleh semua bahawa
Ralph Parker adalah dengan ini

845
00:41:11,180 --> 00:41:14,070
dilantik sebagai ahli Little
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
dan adalah berhak kepada semua penghormatan
dan faedah yang berlaku kepadanya.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
ditandatangan balas Pierre Andre, dengan dakwat.

848
00:41:24,340 --> 00:41:27,160
Kepujian dan faedah,
sudah pada usia sembilan tahun.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Menjerit]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Ayuh.

853
00:41:34,250 --> 00:41:35,210
Mari kita pada dengannya.

854
00:41:35,210 --> 00:41:39,530
Saya tidak memerlukan semua jazz yang
mengenai penyeludup dan lanun.

855
00:41:39,530 --> 00:41:41,660
>> -Listen Malam esok
pengembaraan penutup

856
00:41:41,660 --> 00:41:43,880
kapal lanun hitam.

857
00:41:43,880 --> 00:41:46,650
Kini, sudah tiba masanya untuk
mesej rahsia Annie

858
00:41:46,650 --> 00:41:49,840
untuk anda ahli-ahli Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Ingat, kanak-kanak, hanya ahli
Annie rahsia Circle

860
00:41:53,570 --> 00:41:56,140
boleh decode mesej rahsia Annie.

861
00:41:56,140 --> 00:42:00,340
>> Ingat, Annie adalah bergantung kepada anda.

862
00:42:00,340 --> 00:42:02,880
Tetapkan PIN anda untuk B2.

863
00:42:02,880 --> 00:42:05,230
Berikut adalah mesej.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Saya Saya sedang dalam, mesyuarat rahsia pertama saya.

866
00:42:10,250 --> 00:42:13,890
>> 14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> Pierre adalah besar malam ini suara.

868
00:42:15,780 --> 00:42:19,000
Saya boleh memberitahu bahawa malam ini
mesej adalah benar-benar penting.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, itu mesej
dari Annie dirinya.

870
00:42:22,694 --> 00:42:23,860
Ingat, jangan beritahu sesiapa.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Saat kemudian, saya dalam satu-satunya
bilik di dalam rumah di mana seorang budak sembilan

873
00:42:32,930 --> 00:42:37,040
boleh duduk dalam privasi dan decode.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Saya pergi ke depan, E.

876
00:42:42,360 --> 00:42:44,520
>> Perkataan pertama adalah menjadi.

877
00:42:44,520 --> 00:42:49,032
S, ia akan datang lebih mudah sekarang, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -Oh, Datang, Ralphie, aku harus pergi!

879
00:42:51,733 --> 00:42:53,688
>> -I'll Betul ke bawah, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee jagoan!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, pastikan supaya- pastikan untuk apa?

883
00:43:04,060 --> 00:43:05,970
Apa Little Orphan
Annie cuba katakan?

884
00:43:05,970 --> 00:43:07,264
Pastikan anda apa?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy telah mendapat
pergi, akan anda sila keluar?

886
00:43:09,634 --> 00:43:10,480
>> hak -Semua, Ma!

887
00:43:10,480 --> 00:43:12,880
Saya akan keluar betul!

888
00:43:12,880 --> 00:43:14,550
>> -Saya Telah semakin hampir sekarang.

889
00:43:14,550 --> 00:43:16,620
ketegangan adalah dahsyat.

890
00:43:16,620 --> 00:43:17,720
Apakah maklumat itu?

891
00:43:17,720 --> 00:43:20,170
Nasib planet ini
boleh meragukan.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Harus Andy kita pergi!

894
00:43:23,170 --> 00:43:26,890
>> -I'll Betul keluarlah, menangis dengan kuat!

895
00:43:26,890 --> 00:43:32,680
>> -Almost Sana, jari saya terbang, fikiran saya
adalah perangkap keluli, setiap liang digetarkan.

896
00:43:32,680 --> 00:43:37,198
Ia adalah hampir jelas, ya, ya, ya.

897
00:43:37,198 --> 00:43:43,091
>> -Be Pastikan anda minum Ovaltine anda.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
A komersial yg tdk memuaskan?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Bedebah.

903
00:43:54,227 --> 00:43:54,810
[AKHIR MAIN SEMULA]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN: OK, jadi
itu adalah cara yang sangat panjang

905
00:43:57,390 --> 00:44:00,660
memperkenalkan kriptografi,
dan juga Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Malah, dari iklan lama ini
di sini, mengapa Ovaltine begitu baik?

907
00:44:04,470 --> 00:44:09,470
Ia adalah pengeluaran pekat masak
barli malt, susu lembu berkrim murni ini,

908
00:44:09,470 --> 00:44:14,360
dan khas disediakan koko, bersama-sama
dengan phosphatides semula jadi dan vitamin.

909
00:44:14,360 --> 00:44:18,240
Ia dikuatkan lagi dengan
vitamin tambahan B dan D, yum.

910
00:44:18,240 --> 00:44:21,600
Dan anda masih boleh mendapatkannya, nampaknya,
di Amazon, seperti yang kita lakukan di sini.

911
00:44:21,600 --> 00:44:24,810
>> Tetapi motivasi di sini adalah untuk
memperkenalkan kriptografi, khususnya

912
00:44:24,810 --> 00:44:28,340
sejenis kriptografi dikenali
sebagai kriptografi kunci rahsia.

913
00:44:28,340 --> 00:44:34,284
Dan seperti namanya, keseluruhan
keselamatan sistem kripto kunci rahsia,

914
00:44:34,284 --> 00:44:36,200
jika anda akan, kaedah yang
hanya berebut

915
00:44:36,200 --> 00:44:40,960
maklumat antara dua orang, ialah
hanya penghantar dan hanya penerima

916
00:44:40,960 --> 00:44:46,980
tahu key-- rahsia beberapa nilai, beberapa
frasa rahsia, beberapa nombor rahsia, yang

917
00:44:46,980 --> 00:44:50,660
membolehkan mereka untuk kedua-dua encrypt
dan menyahsulit maklumat.

918
00:44:50,660 --> 00:44:53,470
Dan kriptografi, benar-benar,
hanya ini dari minggu 0.

919
00:44:53,470 --> 00:44:56,715
>> Ia adalah satu masalah di mana ada input,
seperti mesej sebenar dalam bahasa Inggeris

920
00:44:56,715 --> 00:44:59,340
atau apa sahaja bahasa yang anda
ingin menghantar kepada seseorang di dalam kelas,

921
00:44:59,340 --> 00:45:00,580
atau seluruh internet.

922
00:45:00,580 --> 00:45:03,840
Terdapat beberapa output, yang akan
menjadi mesej yang hancur bahawa anda

923
00:45:03,840 --> 00:45:05,250
mahu penerima menerima.

924
00:45:05,250 --> 00:45:07,405
Dan jika seseorang di
pertengahan menerimanya juga,

925
00:45:07,405 --> 00:45:09,780
anda tidak mahu mereka
semestinya dapat menyahsulit,

926
00:45:09,780 --> 00:45:12,840
kerana di dalam ini
kotak hitam, atau algoritma,

927
00:45:12,840 --> 00:45:17,650
beberapa mekanisme, beberapa langkah demi langkah
arahan, untuk mengambil input yang

928
00:45:17,650 --> 00:45:20,710
dan ditukarkan ke dalam
output, dalam mudah-mudahan cara yang selamat.

929
00:45:20,710 --> 00:45:23,640
>> Dan, sebenarnya, terdapat beberapa
perbendaharaan kata dalam dunia ini seperti berikut.

930
00:45:23,640 --> 00:45:26,100
teks biasa adalah perkataan yang
saintis komputer akan

931
00:45:26,100 --> 00:45:28,449
gunakan untuk menggambarkan input
mesej, seperti Inggeris

932
00:45:28,449 --> 00:45:31,240
atau apa sahaja bahasa yang anda sebenarnya
ingin menghantar kepada beberapa manusia lain.

933
00:45:31,240 --> 00:45:35,450
Dan kemudian tulisan rahsia adalah perebutan
untuk enciphered, atau disulitkan,

934
00:45:35,450 --> 00:45:36,520
versinya.

935
00:45:36,520 --> 00:45:38,750
>> Tetapi ada satu ramuan lain di sini.

936
00:45:38,750 --> 00:45:43,200
Ada satu input lain untuk
kriptografi kunci rahsia.

937
00:45:43,200 --> 00:45:45,200
Dan itu adalah kunci itu sendiri,
yang, secara amnya,

938
00:45:45,200 --> 00:45:48,930
seperti yang kita akan lihat, nombor, atau
surat, atau perkataan, apa sahaja

939
00:45:48,930 --> 00:45:51,980
algoritma ia sebenarnya menjangka.

940
00:45:51,980 --> 00:45:53,870
>> Dan bagaimana anda menyahsulit maklumat?

941
00:45:53,870 --> 00:45:55,110
Bagaimana anda menguraikan ia?

942
00:45:55,110 --> 00:45:57,950
Nah, anda hanya membalikkan
output dan input.

943
00:45:57,950 --> 00:46:00,900
>> Dalam erti kata lain, apabila seseorang
menerima mesej disulitkan anda,

944
00:46:00,900 --> 00:46:03,740
dia hanya mempunyai
untuk mengetahui kunci yang sama.

945
00:46:03,740 --> 00:46:05,700
Mereka telah menerima tulisan rahsia.

946
00:46:05,700 --> 00:46:09,530
Dan dengan memasang kedua-dua
input ke dalam sistem kripto itu,

947
00:46:09,530 --> 00:46:14,260
algoritma, kotak ini hitam, keluar
harus datang plaintext asal.

948
00:46:14,260 --> 00:46:17,830
Dan supaya tahap yang sangat tinggi
memandangkan apa kriptografi sebenarnya

949
00:46:17,830 --> 00:46:18,590
semua tentang.

950
00:46:18,590 --> 00:46:20,030
>> Jadi mari kita sampai ke sana.

951
00:46:20,030 --> 00:46:22,700
Sekarang mari kita lihat di bawah
bonet sesuatu

952
00:46:22,700 --> 00:46:26,000
kita telah mengambil untuk diberikan untuk
minggu lalu, dan untuk sesi ini

953
00:46:26,000 --> 00:46:27,629
sini-- tali.

954
00:46:27,629 --> 00:46:30,295
Rentetan pada akhir hari
hanya jujukan aksara.

955
00:46:30,295 --> 00:46:33,610
>> Ia mungkin menjadi dunia hello, atau
hello Zamyla, atau apa sahaja.

956
00:46:33,610 --> 00:46:37,050
Tetapi apa maksudnya untuk
menjadi jujukan aksara?

957
00:46:37,050 --> 00:46:41,520
Malah, perpustakaan CS50 memberikan
kita satu jenis data yang dipanggil tali.

958
00:46:41,520 --> 00:46:45,140
>> Tetapi ada sebenarnya tidak
perkara seperti rentetan dalam C.

959
00:46:45,140 --> 00:46:49,450
Ia benar-benar hanya satu urutan
watak, watak, watak,

960
00:46:49,450 --> 00:46:52,180
watak, belakang, ke belakang, ke
belakang, ke belakang, ke belakang dalam

961
00:46:52,180 --> 00:46:54,650
memori komputer anda, atau RAM.

962
00:46:54,650 --> 00:46:58,940
Dan kita akan melihat secara lebih mendalam bahawa dalam
masa depan apabila kita melihat memori sendiri,

963
00:46:58,940 --> 00:47:02,030
dan penggunaan, dan
ancaman yang terlibat.

964
00:47:02,030 --> 00:47:04,100
>> Tetapi mari kita mempertimbangkan rentetan Zamyla itu.

965
00:47:04,100 --> 00:47:07,480
Jadi hanya nama
manusia di sini, Zamyla,

966
00:47:07,480 --> 00:47:12,030
yang merupakan urutan
watak-watak, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Dan sekarang mari kita andaikan bahawa nama Zamyla ini
sedang disimpan di dalam komputer

968
00:47:16,020 --> 00:47:16,880
program.

969
00:47:16,880 --> 00:47:20,830
>> Nah, dengan alasan bahawa kita harus
dapat melihat mereka watak-watak

970
00:47:20,830 --> 00:47:21,590
secara individu.

971
00:47:21,590 --> 00:47:24,710
Jadi saya hanya akan menarik sedikit
kotak sekitar nama Zamyla di sini.

972
00:47:24,710 --> 00:47:31,580
Dan ia adalah kes dalam C yang apabila anda
mempunyai tali, seperti Zamyla-- dan mungkin

973
00:47:31,580 --> 00:47:34,940
rentetan yang telah kembali dari
fungsi seperti mendapatkan tali,

974
00:47:34,940 --> 00:47:38,540
anda sebenarnya boleh memanipulasi
ia watak oleh watak.

975
00:47:38,540 --> 00:47:42,070
>> Sekarang, ini adalah germane untuk
perbualan di tangan, kerana

976
00:47:42,070 --> 00:47:46,420
dalam bidang kriptografi jika anda mahu menukar
A ke B, dan B kepada C, dan C untuk D,

977
00:47:46,420 --> 00:47:49,650
dan sebagainya, anda perlu berupaya
untuk melihat watak-watak individu

978
00:47:49,650 --> 00:47:50,190
dalam rentetan.

979
00:47:50,190 --> 00:47:52,695
Anda perlu berupaya untuk mengubah
Z untuk sesuatu yang lain, A

980
00:47:52,695 --> 00:47:55,280
kepada sesuatu yang lain, M untuk
sesuatu yang lain, dan sebagainya.

981
00:47:55,280 --> 00:47:58,000
Dan dengan itu kita memerlukan satu cara,
pengaturcaraan, jadi

982
00:47:58,000 --> 00:48:03,020
dikatakan, dalam C dapat mengubah
dan melihat huruf individu.

983
00:48:03,020 --> 00:48:05,690
Dan yang boleh kita lakukan ini seperti berikut.

984
00:48:05,690 --> 00:48:08,340
>> Biar saya pergi pulang dalam CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Dan biarlah saya pergi ke hadapan
dan mencipta fail baru

986
00:48:11,130 --> 00:48:16,134
bahawa saya akan memanggil masa string0 ini,
sebagai contoh seperti kita yang pertama, dot c.

987
00:48:16,134 --> 00:48:18,300
Dan saya akan pergi ke hadapan
dan cambuk sebagai berikut.

988
00:48:18,300 --> 00:48:22,870
>> Jadi termasuk CS50.h, dan
kemudian termasuk io.h standard,

989
00:48:22,870 --> 00:48:25,990
yang saya hampir sentiasa akan
akan menggunakan dalam program saya, sekurang-kurangnya

990
00:48:25,990 --> 00:48:26,780
pada mulanya.

991
00:48:26,780 --> 00:48:32,180
int tidak sah utama, dan kemudian di sini Saya
akan melakukan tali mendapat mendapatkan tali.

992
00:48:32,180 --> 00:48:35,260
Dan kemudian saya akan
teruskan niat ini.

993
00:48:35,260 --> 00:48:37,460
Saya mahu pergi ke depan
dan, seperti cek kewarasan,

994
00:48:37,460 --> 00:48:43,607
hanya mengatakan, hello, peratus s,
koma bertitik, membuat tali 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, apa yang saya lakukan di sini?

996
00:48:44,690 --> 00:48:45,930
Oh, saya tidak palamkan ia.

997
00:48:45,930 --> 00:48:48,120
Jadi pengajaran belajar, bahawa
tidak disengajakan.

998
00:48:48,120 --> 00:48:52,480
>> Jadi kesilapan, lebih peratus
penukaran daripada hujah-hujah data.

999
00:48:52,480 --> 00:48:54,940
Dan ini adalah di mana, dalam
garis 7-- OK, jadi saya perlu,

1000
00:48:54,940 --> 00:48:56,690
quote unquote, itu
rentetan saya untuk printf.

1001
00:48:56,690 --> 00:48:58,151
Saya telah mendapat tanda peratus.

1002
00:48:58,151 --> 00:48:59,650
Tetapi saya tiada argumen kedua.

1003
00:48:59,650 --> 00:49:03,190
>> Saya hilang s koma, yang
Aku ada dalam contoh sebelumnya.

1004
00:49:03,190 --> 00:49:06,650
Jadi peluang yang baik untuk menetapkan
satu lagi kesilapan, tidak sengaja.

1005
00:49:06,650 --> 00:49:09,950
Dan sekarang mari aku berlari
string0, taip Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, hello Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Oleh itu, kita telah menjalankan jenis ini program
beberapa kali berbeza sekarang.

1008
00:49:14,144 --> 00:49:16,310
Tetapi mari kita buat sesuatu yang
sedikit berbeza kali ini.

1009
00:49:16,310 --> 00:49:19,450
Bukan hanya mencetak Zamyla ini
nama keseluruhan dengan printf,

1010
00:49:19,450 --> 00:49:21,350
mari kita melakukannya watak oleh watak.

1011
00:49:21,350 --> 00:49:22,700
>> Saya akan menggunakan untuk gelung.

1012
00:49:22,700 --> 00:49:26,160
Dan saya akan memberikan diri saya
pembolehubah kiraan, yang dipanggil i.

1013
00:49:26,160 --> 00:49:33,530
Dan saya akan terus mengulanginya, jadi
selagi i adalah kurang daripada panjang s.

1014
00:49:33,530 --> 00:49:35,930
>> Ternyata, kita tidak
melakukan masa terakhir ini,

1015
00:49:35,930 --> 00:49:39,100
yang c dilengkapi dengan
fungsi dipanggil Stirling.

1016
00:49:39,100 --> 00:49:42,690
Kembali pada hari itu, dan secara umum
masih dalam melaksanakan fungsi,

1017
00:49:42,690 --> 00:49:45,405
manusia sering akan memilih sangat
nama ringkas yang jenis bunyi

1018
00:49:45,405 --> 00:49:48,280
seperti apa yang anda mahu, walaupun ia
hilang satu vokal atau beberapa huruf.

1019
00:49:48,280 --> 00:49:50,660
Jadi Stirling adalah
menamakan fungsi yang

1020
00:49:50,660 --> 00:49:53,880
mengambil hujah antara
kurungan yang perlu rentetan.

1021
00:49:53,880 --> 00:49:56,910
Dan ia hanya mengembalikan integer,
panjang tali itu.

1022
00:49:56,910 --> 00:50:00,580
>> Jadi ini untuk gelung pada baris 7 akan
untuk mula mengira pada i sama dengan 0.

1023
00:50:00,580 --> 00:50:02,530
Ia akan kenaikan
i pada setiap lelaran

1024
00:50:02,530 --> 00:50:04,350
sebanyak 1, seperti yang kita telah melakukan beberapa kali.

1025
00:50:04,350 --> 00:50:06,780
Tetapi ia akan hanya melakukan
sehingga ini sehingga titik

1026
00:50:06,780 --> 00:50:09,660
ketika saya ialah panjang
tali itu sendiri.

1027
00:50:09,660 --> 00:50:14,520
>> Jadi ini adalah satu cara, akhirnya,
iterating atas watak-watak

1028
00:50:14,520 --> 00:50:17,430
dalam rentetan sebagai adalah berikut.

1029
00:50:17,430 --> 00:50:20,670
Saya akan mencetak bukan
seluruh tali, tetapi peratus c,

1030
00:50:20,670 --> 00:50:22,860
yang bersifat tunggal
diikuti oleh barisan baru.

1031
00:50:22,860 --> 00:50:24,880
Dan kemudian saya akan
pergi ke hadapan, dan saya perlu

1032
00:50:24,880 --> 00:50:29,080
untuk mengatakan saya ingin mencetak
engan watak s.

1033
00:50:29,080 --> 00:50:33,450
>> Jadi, jika i adalah pembolehubah yang menunjukkan
indeks tali, di mana

1034
00:50:33,450 --> 00:50:37,230
anda sedang di dalamnya, saya perlu dapat
berkata, memberi saya watak-i s.

1035
00:50:37,230 --> 00:50:40,390
Dan c mempunyai cara melakukan
ini dengan tanda kurung siku.

1036
00:50:40,390 --> 00:50:43,679
Anda hanya mengatakan nama
tali, yang dalam kes ini adalah s.

1037
00:50:43,679 --> 00:50:46,970
Kemudian anda menggunakan kurungan persegi, yang
biasanya di atas Kembali atau Enter anda

1038
00:50:46,970 --> 00:50:48,110
kekunci pada papan kekunci.

1039
00:50:48,110 --> 00:50:52,410
Dan kemudian anda meletakkan indeks daripada
watak yang anda ingin cetak.

1040
00:50:52,410 --> 00:50:55,960
Jadi indeks akan menjadi
number-- 0, atau 1, atau 2, atau 3, atau dot,

1041
00:50:55,960 --> 00:50:57,590
dot, dot, beberapa nombor lain.

1042
00:50:57,590 --> 00:51:00,920
>> Dan kita memastikan bahawa ia akan
menjadi nombor yang betul, kerana saya

1043
00:51:00,920 --> 00:51:02,360
mula mengira pada 0.

1044
00:51:02,360 --> 00:51:07,020
Dan secara lalai, watak pertama
dalam rentetan adalah dengan konvensyen 0.

1045
00:51:07,020 --> 00:51:09,230
Dan watak kedua kurungan 1.

1046
00:51:09,230 --> 00:51:11,120
Dan watak ketiga kurungan 2.

1047
00:51:11,120 --> 00:51:13,630
Dan anda tidak mahu pergi terlalu
ini, tetapi kita tidak akan kerana kami

1048
00:51:13,630 --> 00:51:17,780
akan hanya kenaikan i sehingga ia
sama dengan panjang tali.

1049
00:51:17,780 --> 00:51:20,210
Dan di mana titik,
ini untuk gelung akan berhenti.

1050
00:51:20,210 --> 00:51:25,550
>> Jadi biarlah saya pergi ke hadapan dan menyimpan ini
program, dan jangka membuat rentetan 0.

1051
00:51:25,550 --> 00:51:28,400
Tetapi saya kacau sehingga.

1052
00:51:28,400 --> 00:51:35,390
Tersirat mengisytiharkan fungsi perpustakaan
Stirling dengan apa-apa jenis dan such-- sekarang,

1053
00:51:35,390 --> 00:51:36,430
ini bunyi biasa.

1054
00:51:36,430 --> 00:51:37,440
Tetapi ia tidak printf.

1055
00:51:37,440 --> 00:51:38,540
Dan ia tidak mendapatkan tali.

1056
00:51:38,540 --> 00:51:40,480
>> Saya tidak skru sehingga dalam
cara yang sama kali ini.

1057
00:51:40,480 --> 00:51:45,100
Tetapi melihat ke bawah di sini sedikit ke bawah
lanjut, termasuk string.h kepala,

1058
00:51:45,100 --> 00:51:47,210
jelas memberikan
deklarasi untuk Stirling.

1059
00:51:47,210 --> 00:51:48,820
Jadi sebenarnya ada petunjuk di sana.

1060
00:51:48,820 --> 00:51:51,670
>> Dan sesungguhnya ia ternyata
terdapat satu lagi fail header

1061
00:51:51,670 --> 00:51:53,970
bahawa kita telah tidak digunakan
di dalam kelas lagi, tetapi ia

1062
00:51:53,970 --> 00:51:56,480
kalangan orang yang ada
kepada anda, yang dipanggil string.h.

1063
00:51:56,480 --> 00:52:00,930
Dan dalam fail, string.h
adalah Stirling diisytiharkan.

1064
00:52:00,930 --> 00:52:05,220
Jadi biarlah saya pergi ke hadapan dan
menyelamatkan ini, membuat tali

1065
00:52:05,220 --> 00:52:08,040
0-- bagus, tiada mesej ralat masa ini.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, dan
Saya akan tekan Enter,

1067
00:52:12,290 --> 00:52:16,710
di mana titik getstring akan
untuk kembali tali, memasukkannya ke dalam s.

1068
00:52:16,710 --> 00:52:21,890
Maka itu untuk gelung akan melelar
terhadap watak-watak S satu demi satu,

1069
00:52:21,890 --> 00:52:28,420
dan mencetak mereka satu per baris, kerana
Saya mempunyai bahawa garis sendeng terbalik n pada akhir.

1070
00:52:28,420 --> 00:52:34,530
Jadi saya boleh meninggalkan garis sendeng terbalik yang
n, dan kemudian hanya mencetak Zamyla semua

1071
00:52:34,530 --> 00:52:37,460
dalam baris yang sama,
berkesan reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, yang tidak semua yang berguna.

1073
00:52:38,999 --> 00:52:40,540
Tetapi dalam kes ini, saya tidak melakukannya.

1074
00:52:40,540 --> 00:52:43,610
Saya sebenarnya dicetak satu
aksara pada satu masa, satu setiap baris,

1075
00:52:43,610 --> 00:52:45,400
supaya kita sebenarnya melihat kesan.

1076
00:52:45,400 --> 00:52:46,900
>> Tetapi saya perlu ambil perhatian satu perkara di sini.

1077
00:52:46,900 --> 00:52:48,930
Dan kita akan kembali kepada
ini dalam minggu akan datang.

1078
00:52:48,930 --> 00:52:52,650
Ia ternyata bahawa ini
kod berpotensi kereta.

1079
00:52:52,650 --> 00:52:56,560
>> Ia ternyata bahawa mendapatkan tali
dan beberapa fungsi lain dalam kehidupan

1080
00:52:56,560 --> 00:53:00,280
tidak semestinya sentiasa
kembali apa yang anda jangkakan.

1081
00:53:00,280 --> 00:53:03,010
Kita tahu dari kelas lepas
masa ini yang mendapat

1082
00:53:03,010 --> 00:53:04,960
rentetan sepatutnya kembali rentetan.

1083
00:53:04,960 --> 00:53:09,900
Tetapi bagaimana jika jenis pengguna menyatakan apa-apa
perkataan yang panjang, atau perenggan, atau esei

1084
00:53:09,900 --> 00:53:13,010
bahawa terdapat hanya tidak cukup
memori dalam komputer untuk memasukkannya.

1085
00:53:13,010 --> 00:53:15,410
>> Seperti, bagaimana jika ada masalah
salah di bawah hood?

1086
00:53:15,410 --> 00:53:18,400
Ia mungkin tidak berlaku sering,
tetapi ia boleh berlaku sekali

1087
00:53:18,400 --> 00:53:21,520
pada masa ini, sangat jarang.

1088
00:53:21,520 --> 00:53:25,460
Dan maka ia ternyata bahawa mendapatkan tali
dan fungsi seperti itu tidak semestinya

1089
00:53:25,460 --> 00:53:26,380
sentiasa kembali tali.

1090
00:53:26,380 --> 00:53:30,680
Mereka kembali beberapa nilai ralat,
beberapa nilai sentinel boleh dikatakan,

1091
00:53:30,680 --> 00:53:32,612
yang menunjukkan bahawa
sesuatu yang telah berlaku.

1092
00:53:32,612 --> 00:53:35,320
Dan anda hanya akan tahu ini dari
telah belajar di dalam kelas sekarang,

1093
00:53:35,320 --> 00:53:37,700
atau setelah membaca beberapa dokumentasi lanjut.

1094
00:53:37,700 --> 00:53:43,120
Ia ternyata bahawa mendapatkan tali
boleh kembali nilai yang dipanggil null.

1095
00:53:43,120 --> 00:53:46,220
Null ialah nilai khas yang kita akan
kembali ke dalam seminggu akan datang.

1096
00:53:46,220 --> 00:53:50,420
Tetapi untuk sekarang, hanya tahu bahawa jika saya mahu
menjadi benar-benar betul dalam bergerak ke hadapan

1097
00:53:50,420 --> 00:53:52,650
menggunakan mendapatkan tali, saya
tidak seharusnya hanya memanggilnya,

1098
00:53:52,650 --> 00:53:56,870
dan secara membuta tuli menggunakan nilai pulangan,
mempercayai bahawa itu rentetan.

1099
00:53:56,870 --> 00:53:59,420
>> Saya mula-mula boleh berkata:
hey, tunggu satu minit, hanya

1100
00:53:59,420 --> 00:54:03,380
diteruskan jika s tidak sama
null, di mana null, sekali lagi,

1101
00:54:03,380 --> 00:54:04,660
hanya beberapa nilai khas.

1102
00:54:04,660 --> 00:54:07,770
Dan ia adalah satu-satunya nilai istimewa anda
perlu bimbang tentang untuk mendapatkan tali.

1103
00:54:07,770 --> 00:54:10,900
Mendapatkan tali sama ada akan
untuk kembali rentetan atau null.

1104
00:54:10,900 --> 00:54:17,219
>> Dan tanda seru ini tanda sama dengan
anda mungkin tahu dari mungkin kelas matematik

1105
00:54:17,219 --> 00:54:20,510
bahawa anda mungkin menarik tanda sama dengan
garis melaluinya untuk menunjukkan tidak sama.

1106
00:54:20,510 --> 00:54:23,135
Bukan itu umumnya watak
anda boleh menaip pada papan kekunci anda.

1107
00:54:23,135 --> 00:54:26,480
Dan sebagainya dalam kebanyakan bahasa pengaturcaraan,
apabila anda mahu untuk mengatakan tidak sama,

1108
00:54:26,480 --> 00:54:29,160
anda menggunakan tanda seru,
atau dikenali sebagai bang.

1109
00:54:29,160 --> 00:54:33,180
Jadi anda mengatakan bang sama, yang
bermakna tidak sama, secara logik.

1110
00:54:33,180 --> 00:54:38,060
Ia seperti tidak ada yang lebih besar
daripada, atau sama dengan, atau kurang daripada

1111
00:54:38,060 --> 00:54:41,270
atau sama dengan memasukkan pada papan kekunci anda
yang melakukan semuanya dalam satu simbol.

1112
00:54:41,270 --> 00:54:44,020
Jadi sebab itu, dalam contoh-contoh yang lalu,
anda melakukan satu kurungan terbuka, dan kemudian

1113
00:54:44,020 --> 00:54:48,670
tanda sama, untuk melakukan
lebih besar daripada atau, berkata, kurang daripada.

1114
00:54:48,670 --> 00:54:49,910
>> Jadi apa yang bisa dibesarkan di sini?

1115
00:54:49,910 --> 00:54:53,880
Ini adalah hanya satu cara sekarang daripada
memperkenalkan sintaks ini, ciri-ciri ini,

1116
00:54:53,880 --> 00:54:57,390
iterating ke atas individu
watak-watak dalam rentetan.

1117
00:54:57,390 --> 00:55:00,260
Dan seperti persegi mereka
kurungan membolehkan anda untuk mendapatkan mereka,

1118
00:55:00,260 --> 00:55:03,790
menganggap mereka kurungan persegi sebagai
jenis mengisyaratkan pada ini mendasari

1119
00:55:03,790 --> 00:55:06,040
reka bentuk, di mana setiap
watak dalam rentetan

1120
00:55:06,040 --> 00:55:10,180
adalah jenis berkotak di suatu tempat di bawah
hud dalam ingatan komputer anda.

1121
00:55:10,180 --> 00:55:12,340
>> Tetapi mari kita membuat varian ini.

1122
00:55:12,340 --> 00:55:14,880
Ia ternyata bahawa ini
program adalah betul.

1123
00:55:14,880 --> 00:55:18,810
Jadi setiap paksi CS50 untuk menilai
kod, ini betul sekarang.

1124
00:55:18,810 --> 00:55:22,959
Terutama sekarang bahawa saya memeriksa untuk
null, program ini tidak boleh crash.

1125
00:55:22,959 --> 00:55:24,500
Dan saya tahu bahawa dari pengalaman.

1126
00:55:24,500 --> 00:55:28,040
Tetapi tiada apa-apa yang lain yang
kita benar-benar boleh berlaku di sini.

1127
00:55:28,040 --> 00:55:31,860
Tetapi ia tidak sangat direka dengan baik,
kerana mari kita kembali kepada asas.

1128
00:55:31,860 --> 00:55:34,450
>> Pertama, principles--
apakah untuk gelung lakukan?

1129
00:55:34,450 --> 00:55:36,290
A untuk gelung melakukan tiga perkara.

1130
00:55:36,290 --> 00:55:39,340
Ia initializes beberapa
nilai, jika anda bertanya kepada.

1131
00:55:39,340 --> 00:55:41,770
Ia memeriksa syarat.

1132
00:55:41,770 --> 00:55:45,380
Dan kemudian selepas setiap
lelaran, selepas setiap kitaran,

1133
00:55:45,380 --> 00:55:49,330
ia menokok beberapa
nilai, atau nilai-nilai, di sini.

1134
00:55:49,330 --> 00:55:50,600
>> Jadi apa maksudnya?

1135
00:55:50,600 --> 00:55:52,940
Kita memulakan i kepada 0.

1136
00:55:52,940 --> 00:55:58,610
Kami memeriksa dan memastikan i adalah kurang daripada
panjang s, yang Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
supaya yang kurang daripada 6.

1138
00:55:59,900 --> 00:56:02,590
Dan, sememangnya, 0 sebagai kurang daripada 6.

1139
00:56:02,590 --> 00:56:05,580
>> Kami mencetak Z dari nama Zamyla ini.

1140
00:56:05,580 --> 00:56:08,080
Kemudian kita kenaikan i 0-1.

1141
00:56:08,080 --> 00:56:11,290
Kami kemudian memeriksa, adalah 1 kurang
daripada panjang s?

1142
00:56:11,290 --> 00:56:13,270
Panjang s adalah 6.

1143
00:56:13,270 --> 00:56:13,950
Ya, itulah.

1144
00:56:13,950 --> 00:56:16,880
>> Oleh itu, kita mencetak nama Zamyla ini, ZA.

1145
00:56:16,880 --> 00:56:20,090
Kita kenaikan i dari 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Kami kemudian memeriksa, adalah kurang daripada 2
panjang nama Zamyla ini.

1147
00:56:23,720 --> 00:56:25,380
6- jadi 2 adalah kurang daripada 6.

1148
00:56:25,380 --> 00:56:30,460
Ya, mari kita mencetak sekarang M dalam
nama Zamyla ini, watak ketiga.

1149
00:56:30,460 --> 00:56:34,110
>> Kunci di sini adalah bahawa pada setiap
lelaran cerita, saya memeriksa,

1150
00:56:34,110 --> 00:56:37,810
adalah i kurang daripada panjang Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Tetapi tangkapan adalah bahawa
Stirling bukan harta.

1152
00:56:40,350 --> 00:56:43,100
Orang-orang yang telah diprogramkan
sebelum di Jawa atau bahasa-bahasa lain

1153
00:56:43,100 --> 00:56:46,310
mengetahui panjang tali adalah
harta, hanya beberapa bacaan sahaja nilai.

1154
00:56:46,310 --> 00:56:50,220
>> Dalam C dalam kes ini, jika ini adalah
satu fungsi yang secara literal

1155
00:56:50,220 --> 00:56:53,520
mengira bilangan
watak-watak dalam Zamyla setiap kali

1156
00:56:53,520 --> 00:56:54,740
kita panggil fungsi itu.

1157
00:56:54,740 --> 00:56:58,500
Setiap kali anda bertanya kepada komputer menggunakan
Stirling, ia mengambil melihat Zamyla,

1158
00:56:58,500 --> 00:57:01,960
dan berkata Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Dan ia mengembalikan 6.

1160
00:57:02,962 --> 00:57:04,920
Lain kali anda memanggil
ia di dalam bahawa untuk gelung,

1161
00:57:04,920 --> 00:57:08,610
ia akan melihat Zamyla
sekali lagi, mengatakan Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Dan ia akan kembali 6.

1163
00:57:10,320 --> 00:57:12,980
Jadi apa yang bodoh tentang reka bentuk ini?

1164
00:57:12,980 --> 00:57:17,700
>> Mengapa kod saya bukan 5 daripada 5
untuk reka bentuk sekarang, jadi untuk bercakap?

1165
00:57:17,700 --> 00:57:20,600
Well, saya meminta seorang
soalan tidak perlu.

1166
00:57:20,600 --> 00:57:23,030
Saya melakukan kerja yang lebih daripada apa yang saya perlu.

1167
00:57:23,030 --> 00:57:25,370
>> Jadi walaupun
jawapan adalah betul, saya

1168
00:57:25,370 --> 00:57:29,560
meminta komputer, apa yang
panjang Zamyla lagi,

1169
00:57:29,560 --> 00:57:31,380
dan lagi, dan lagi, dan lagi?

1170
00:57:31,380 --> 00:57:33,980
Dan jawapan yang
tidak akan berubah.

1171
00:57:33,980 --> 00:57:35,900
Ia sentiasa akan menjadi 6.

1172
00:57:35,900 --> 00:57:39,730
>> Jadi penyelesaian yang lebih baik daripada ini
akan menjadi versi ini akan datang.

1173
00:57:39,730 --> 00:57:43,390
Biar saya pergi ke hadapan dan memasukkannya ke dalam
fail berasingan yang dipanggil string1.c,

1174
00:57:43,390 --> 00:57:44,990
hanya untuk memastikan ia memisahkan.

1175
00:57:44,990 --> 00:57:47,260
Dan ternyata in untuk
gelung, anda boleh sebenarnya

1176
00:57:47,260 --> 00:57:50,210
mengisytiharkan beberapa pembolehubah sekaligus.

1177
00:57:50,210 --> 00:57:53,460
>> Jadi, saya akan terus i dan menetapkannya untuk 0.

1178
00:57:53,460 --> 00:57:56,190
Tetapi saya juga akan
menambah koma, dan berkata,

1179
00:57:56,190 --> 00:58:01,050
memberi saya pembolehubah yang dipanggil n, yang
nilai sama panjang tali s.

1180
00:58:01,050 --> 00:58:09,410
Dan sekarang, sila membuat keadaan saya
selagi i adalah kurang daripada n.

1181
00:58:09,410 --> 00:58:14,140
>> Jadi dengan cara ini, logik adalah
sama pada akhir hari.

1182
00:58:14,140 --> 00:58:18,280
Tetapi saya mengingati
nilai 6, dalam kes ini.

1183
00:58:18,280 --> 00:58:19,780
Apakah Panjang nama Zamyla ini?

1184
00:58:19,780 --> 00:58:20,860
Dan saya meletakkan ia di n.

1185
00:58:20,860 --> 00:58:23,050
>> Dan saya masih memeriksa
syarat setiap kali.

1186
00:58:23,050 --> 00:58:24,300
0 kurang daripada 6?

1187
00:58:24,300 --> 00:58:25,600
1 kurang daripada 6?

1188
00:58:25,600 --> 00:58:28,600
2 kurang daripada 6, dan sebagainya?

1189
00:58:28,600 --> 00:58:31,914
>> Tetapi saya tidak meminta komputer
sekali lagi, dan sekali lagi, apa yang

1190
00:58:31,914 --> 00:58:33,080
panjang nama Zamyla ini?

1191
00:58:33,080 --> 00:58:34,320
Apa yang panjang nama Zamyla ini?

1192
00:58:34,320 --> 00:58:35,986
Apa yang panjang nama ini Zamyla ini?

1193
00:58:35,986 --> 00:58:40,440
Saya betul-betul mengingati bahawa pertama dan
hanya menjawab dalam n pembolehubah kedua ini.

1194
00:58:40,440 --> 00:58:45,280
Jadi ini kini akan bukan sahaja
betul, tetapi juga direka dengan baik.

1195
00:58:45,280 --> 00:58:46,670
>> Sekarang, bagaimana pula dengan gaya?

1196
00:58:46,670 --> 00:58:48,866
Saya telah dinamakan pembolehubah saya
dengan baik, saya akan berkata.

1197
00:58:48,866 --> 00:58:50,240
Mereka super ringkas sekarang.

1198
00:58:50,240 --> 00:58:52,090
Dan itu betul-betul halus.

1199
00:58:52,090 --> 00:58:55,120
>> Jika anda hanya mempunyai satu
rentetan dalam program,

1200
00:58:55,120 --> 00:58:56,860
anda juga mungkin memanggilnya s untuk tali.

1201
00:58:56,860 --> 00:58:59,370
Jika anda hanya mempunyai satu pembolehubah
untuk mengira dalam program,

1202
00:58:59,370 --> 00:59:00,710
anda juga mungkin memanggilnya i.

1203
00:59:00,710 --> 00:59:03,500
Jika anda mempunyai panjang, n
adalah super biasa juga.

1204
00:59:03,500 --> 00:59:05,800
Tetapi saya tidak mengulas apa-apa kod saya.

1205
00:59:05,800 --> 00:59:09,200
>> Saya tidak memaklumkan kepada reader--
sama ada itu TF saya, atau TA,

1206
00:59:09,200 --> 00:59:12,460
atau hanya colleague-- apa yang sepatutnya
yang akan berlaku dalam program ini.

1207
00:59:12,460 --> 00:59:15,760
Dan sebagainya untuk mendapatkan gaya yang baik,
apa yang saya mahu lakukan

1208
00:59:15,760 --> 00:59:24,580
adalah sesuatu this--
seperti meminta pengguna untuk input.

1209
00:59:24,580 --> 00:59:26,670
Dan saya boleh menulis semula
ini apa-apa bilangan kali.

1210
00:59:26,670 --> 00:59:35,630
>> Pastikan s-- membuat get pasti
rentetan kembali rentetan.

1211
00:59:35,630 --> 00:59:40,280
Dan kemudian di sini-- dan ini mungkin
Itekadar comment-- yang paling penting

1212
00:59:40,280 --> 00:59:44,450
atas watak-watak dalam s satu demi satu.

1213
00:59:44,450 --> 00:59:47,060
Dan saya boleh menggunakan mana-mana
pilihan bahasa Inggeris

1214
00:59:47,060 --> 00:59:49,650
di sini untuk menerangkan setiap
daripada ketulan kod.

1215
00:59:49,650 --> 00:59:52,740
>> Perhatikan bahawa saya tidak meletakkan
komen pada setiap baris kod,

1216
00:59:52,740 --> 00:59:55,690
benar-benar hanya pada yang menarik
orang-orang, orang-orang yang

1217
00:59:55,690 --> 00:59:59,460
mempunyai beberapa makna, sehingga aku dapat
ingin super jelas kepada seseorang

1218
00:59:59,460 --> 01:00:00,460
membaca kod saya.

1219
01:00:00,460 --> 01:00:02,920
Dan mengapa kamu memanggil mendapatkan
rentetan meminta pengguna untuk input?

1220
01:00:02,920 --> 01:00:05,450
Walaupun satu yang tidak semestinya
semua deskriptif itu.

1221
01:00:05,450 --> 01:00:09,340
Tetapi ia membantu bercerita, kerana
Barisan kedua dalam cerita itu, pastikan

1222
01:00:09,340 --> 01:00:10,740
mendapatkan tali kembali rentetan.

1223
01:00:10,740 --> 01:00:14,260
>> Dan garis ketiga dalam cerita ini adalah,
melelar atas watak-watak dalam s satu

1224
01:00:14,260 --> 01:00:15,380
pada satu masa.

1225
01:00:15,380 --> 01:00:17,920
Dan kini hanya untuk langkah yang baik,
Saya akan pergi ke hadapan dan menambah

1226
01:00:17,920 --> 01:00:24,560
satu lagi komen yang hanya
kata cetak watak i-ke dalam s.

1227
01:00:24,560 --> 01:00:26,520
Kini, apa yang telah kuperbuat
pada akhir hari?

1228
01:00:26,520 --> 01:00:29,190
>> Saya telah menambah beberapa English
kata-kata dalam bentuk komen.

1229
01:00:29,190 --> 01:00:32,700
Simbol slash slash bermakna, hey,
komputer ini adalah untuk manusia,

1230
01:00:32,700 --> 01:00:33,820
bukan kerana anda, komputer.

1231
01:00:33,820 --> 01:00:35,119
Jadi mereka diabaikan secara logik.

1232
01:00:35,119 --> 01:00:35,910
Mereka hanya ada di sana.

1233
01:00:35,910 --> 01:00:39,830
>> Dan, sememangnya, CS50 IDE menunjukkan mereka sebagai
kelabu, kerana menjadi seorang yang berguna, tetapi tidak utama

1234
01:00:39,830 --> 01:00:41,000
kepada program ini.

1235
01:00:41,000 --> 01:00:42,570
Perhatikan apa yang anda kini boleh dilakukan.

1236
01:00:42,570 --> 01:00:44,950
Sama ada anda tahu C
pengaturcaraan atau tidak, anda

1237
01:00:44,950 --> 01:00:47,722
hanya boleh berdiri kembali pada ini
program, dan mengimbas komen.

1238
01:00:47,722 --> 01:00:50,180
Minta pengguna untuk input, pastikan
mendapatkan tali kembali rentetan,

1239
01:00:50,180 --> 01:00:53,009
melelar atas watak-watak dalam s
satu demi satu, mencetak watak

1240
01:00:53,009 --> 01:00:55,550
watak i-ke-dalam s-- anda tidak
walaupun perlu melihat kod di

1241
01:00:55,550 --> 01:00:57,270
untuk memahami apa yang program ini tidak.

1242
01:00:57,270 --> 01:01:00,280
Dan, lebih baik lagi, jika anda sendiri melihat
di program ini dalam satu atau dua minggu,

1243
01:01:00,280 --> 01:01:02,280
atau sebulan, atau setahun,
anda juga tidak mempunyai

1244
01:01:02,280 --> 01:01:04,420
merenung kod,
cuba ingat,

1245
01:01:04,420 --> 01:01:06,630
apa yang saya cuba lakukan dengan kod ini?

1246
01:01:06,630 --> 01:01:07,770
>> Anda telah memberitahu diri sendiri.

1247
01:01:07,770 --> 01:01:11,660
Anda telah diterangkan untuk diri sendiri,
atau beberapa rakan sekerja, atau TA, atau TF.

1248
01:01:11,660 --> 01:01:14,860
Dan sebagainya ini kini akan
betul, dan reka bentuk yang baik,

1249
01:01:14,860 --> 01:01:18,210
dan akhirnya baik gaya juga.

1250
01:01:18,210 --> 01:01:19,990
Begitu menyimpan bahawa dalam fikiran.

1251
01:01:19,990 --> 01:01:22,200
>> Jadi ada satu yang lain
Perkara yang saya akan lakukan di sini

1252
01:01:22,200 --> 01:01:28,240
yang kini boleh mendedahkan dengan tepat apa yang
berlaku di bawah hood.

1253
01:01:28,240 --> 01:01:30,390
Jadi ada ciri-ciri ini
dalam C, dan bahasa-bahasa lain,

1254
01:01:30,390 --> 01:01:33,010
dipanggil typecasting
yang sama ada secara tersirat

1255
01:01:33,010 --> 01:01:37,250
atau jelas membolehkan anda untuk menukar
dari satu jenis data yang lain.

1256
01:01:37,250 --> 01:01:39,800
Kami telah berurusan supaya
jauh hari ini dengan tali.

1257
01:01:39,800 --> 01:01:41,250
>> Dan rentetan aksara.

1258
01:01:41,250 --> 01:01:44,910
Tetapi ingat dari minggu
0, apakah watak-watak?

1259
01:01:44,910 --> 01:01:49,334
Watak-watak yang hanya abstraksi yang
di atas nombor perpuluhan numbers--,

1260
01:01:49,334 --> 01:01:52,500
dan nombor perpuluhan adalah benar-benar hanya satu
abstraksi di atas nombor perduaan,

1261
01:01:52,500 --> 01:01:53,720
seperti yang kita ditakrifkan ia.

1262
01:01:53,720 --> 01:01:55,540
>> Jadi watak-watak yang nombor.

1263
01:01:55,540 --> 01:01:58,410
Dan nombor adalah watak-watak,
hanya bergantung kepada konteks.

1264
01:01:58,410 --> 01:02:01,250
Dan ternyata bahawa dalam
program komputer,

1265
01:02:01,250 --> 01:02:06,830
anda boleh menentukan bagaimana anda mahu melihat
di bit bahagian dalam program itu?

1266
01:02:06,830 --> 01:02:10,400
>> Ingat dari 0 minggu bahawa kita mempunyai
Ascii, yang hanya kod ini

1267
01:02:10,400 --> 01:02:11,620
surat pemetaan untuk nombor.

1268
01:02:11,620 --> 01:02:13,660
Dan kita berkata, modal adalah 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B adalah 66, dan sebagainya.

1270
01:02:15,860 --> 01:02:20,500
>> Dan notis, kita pada dasarnya mempunyai aksara pada
baris atas di sini, kerana C akan memanggil mereka,

1271
01:02:20,500 --> 01:02:23,400
watak-watak, dan kemudian
ints di barisan kedua.

1272
01:02:23,400 --> 01:02:28,180
Dan ternyata anda boleh menukar
dengan lancar di antara kedua-dua, biasanya.

1273
01:02:28,180 --> 01:02:30,042
Dan jika kita mahu lakukan
ini sengaja, kita

1274
01:02:30,042 --> 01:02:31,750
mungkin mahu untuk menangani
sesuatu seperti ini.

1275
01:02:31,750 --> 01:02:33,590
>> Kita mungkin mahu untuk menukar
huruf besar yang lebih rendah

1276
01:02:33,590 --> 01:02:35,330
kes atau kes yang lebih rendah kepada huruf besar.

1277
01:02:35,330 --> 01:02:38,000
Dan ternyata di luar sana yang
sebenarnya corak di sini

1278
01:02:38,000 --> 01:02:39,900
kita boleh menerima dalam hanya seketika.

1279
01:02:39,900 --> 01:02:44,120
Tetapi mari kita lihat pertama pada
contoh untuk melakukan ini dengan jelas.

1280
01:02:44,120 --> 01:02:46,340
>> Saya akan kembali ke dalam CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Saya akan membuat
file dipanggil Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Dan saya akan pergi ke hadapan dan menambah saya
io.h standard di bahagian atas, int tidak sah utama

1283
01:02:55,960 --> 01:02:57,370
di bahagian atas fungsi saya.

1284
01:02:57,370 --> 01:03:02,700
Dan kemudian saya hanya akan melakukan perkara yang
following-- untuk gelung dari i sama,

1285
01:03:02,700 --> 01:03:04,610
katakan, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Dan kemudian saya akan menjadi kurang daripada
65, ditambah 26 huruf dalam abjad.

1287
01:03:10,460 --> 01:03:12,640
Jadi saya akan membiarkan komputer
matematik aku di sana.

1288
01:03:12,640 --> 01:03:15,100
Dan kemudian di dalam gelung ini,
apa yang saya akan mencetak?

1289
01:03:15,100 --> 01:03:19,230
>> % C% i garis sendeng terbalik n.

1290
01:03:19,230 --> 01:03:21,290
Dan sekarang saya mahu pasangkan dua nilai.

1291
01:03:21,290 --> 01:03:24,530
Saya telah meletakkan soalan buat sementara waktu
menandakan sana untuk menjemput soalan.

1292
01:03:24,530 --> 01:03:29,940
>> Saya hendak melelar dari 65 seterusnya
untuk 26 huruf abjad,

1293
01:03:29,940 --> 01:03:35,190
mencetak pada setiap lelaran yang
bersamaan penting watak itu.

1294
01:03:35,190 --> 01:03:38,299
Dalam erti kata lain, saya mahu
melelar lebih 26 nombor percetakan

1295
01:03:38,299 --> 01:03:41,590
apa watak Ascii adalah, surat itu,
dan apa nombor yang sepadan is--

1296
01:03:41,590 --> 01:03:44,650
benar-benar hanya mencipta
carta daripada penurunan itu.

1297
01:03:44,650 --> 01:03:47,010
Jadi apa yang perlu ini tanda tanya boleh?

1298
01:03:47,010 --> 01:03:51,760
>> Nah, ternyata bahawa kedua
satu hanya perlu i yang berubah-ubah.

1299
01:03:51,760 --> 01:03:53,860
Saya mahu melihat bahawa sebagai nombor.

1300
01:03:53,860 --> 01:03:58,920
Dan hujah pertengahan
di sini, saya boleh memberitahu komputer

1301
01:03:58,920 --> 01:04:03,470
untuk merawat integer yang
i sebagai watak, supaya

1302
01:04:03,470 --> 01:04:05,880
untuk menggantikan sini untuk peratus C.

1303
01:04:05,880 --> 01:04:07,990
>> Dalam erti kata lain, jika saya, yang
programmer manusia, tahu

1304
01:04:07,990 --> 01:04:09,865
ini adalah hanya nombor
pada akhir hari.

1305
01:04:09,865 --> 01:04:12,500
Dan saya tahu bahawa 65 perlu
peta untuk beberapa watak.

1306
01:04:12,500 --> 01:04:15,310
Dengan pelakon yang jelas ini,
dengan kurungan,

1307
01:04:15,310 --> 01:04:18,840
nama jenis data yang anda hendak
memeluk dan kurungan tertutup,

1308
01:04:18,840 --> 01:04:21,200
anda boleh memberitahu
komputer, hey, komputer,

1309
01:04:21,200 --> 01:04:24,130
menukar integer ini kepada char.

1310
01:04:24,130 --> 01:04:26,250
>> Oleh itu, apabila saya menjalankan ini
program selepas menyusun,

1311
01:04:26,250 --> 01:04:29,740
mari kita lihat apa yang saya get-- membuat Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Darn ia, apa yang saya lakukan salah di sini?

1313
01:04:33,020 --> 01:04:35,884
Gunakan pengecam tidak diisytiharkan,
semua hak, tidak sengaja,

1314
01:04:35,884 --> 01:04:37,800
tetapi mari kita lihat jika kita tidak boleh
sebab melalui ini.

1315
01:04:37,800 --> 01:04:41,220
>> Jadi garis five-- jadi saya tidak mendapat
jauh sebelum merenyukkan.

1316
01:04:41,220 --> 01:04:42,140
Tidak mengapa.

1317
01:04:42,140 --> 01:04:46,560
Jadi garis 5 untuk i sama 65-- saya lihat.

1318
01:04:46,560 --> 01:04:50,130
Jadi ingat bahawa dalam C, tidak seperti beberapa
bahasa jika anda mempunyai pengaturcaraan terlebih dahulu

1319
01:04:50,130 --> 01:04:52,190
pengalaman, anda perlu
untuk memberitahu komputer,

1320
01:04:52,190 --> 01:04:55,040
tidak seperti calar, apa
jenis pembolehubah itu.

1321
01:04:55,040 --> 01:04:56,860
>> Dan saya terlupa frasa utama di sini.

1322
01:04:56,860 --> 01:04:59,200
Selaras lima, saya telah mula menggunakan i.

1323
01:04:59,200 --> 01:05:01,560
Tetapi saya tidak memberitahu C
apa data jenis itu.

1324
01:05:01,560 --> 01:05:04,570
Jadi, saya akan pergi di sini dan
berkata, ah, membuat ia integer.

1325
01:05:04,570 --> 01:05:07,050
>> Sekarang saya akan pergi ke hadapan dan susun semula.

1326
01:05:07,050 --> 01:05:08,080
Yang tetap itu.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, itulah jenis sejuk.

1328
01:05:12,660 --> 01:05:15,360
Bukan sahaja ia super cepat untuk
meminta komputer soalan ini,

1329
01:05:15,360 --> 01:05:18,885
bukannya mencari ia di atas slaid,
ia dicetak satu setiap baris, A ialah 65,

1330
01:05:18,885 --> 01:05:24,860
B 66, sepanjang jalan down-- sejak saya
melakukan ini 26 times-- untuk huruf z,

1331
01:05:24,860 --> 01:05:25,630
iaitu 90.

1332
01:05:25,630 --> 01:05:27,790
Dan, sebenarnya, sedikit
lebih bijak akan

1333
01:05:27,790 --> 01:05:31,030
telah bagi saya tidak bergantung
pada komputer untuk menambah 26.

1334
01:05:31,030 --> 01:05:34,060
Saya boleh sahaja dilakukan
90 juga, selagi

1335
01:05:34,060 --> 01:05:37,390
kerana saya tidak membuat kesilapan yang sama dua kali.

1336
01:05:37,390 --> 01:05:41,880
Saya hendak pergi melalui
z, bukan sahaja menerusi y.

1337
01:05:41,880 --> 01:05:44,000
>> Jadi itulah pelakon yang jelas.

1338
01:05:44,000 --> 01:05:47,860
Ia ternyata bahawa ini
tidak walaupun perlu.

1339
01:05:47,860 --> 01:05:52,480
Biar saya pergi ke hadapan dan menjalankan semula ini
pengkompil, dan jalankan lagi Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Ia ternyata bahawa C adalah cukup bijak.

1341
01:05:54,940 --> 01:05:57,150
>> Dan printf, khususnya,
agak pintar.

1342
01:05:57,150 --> 01:06:01,260
Jika anda hanya lulus i dua kali
untuk kedua-dua ruang letak, printf

1343
01:06:01,260 --> 01:06:04,510
akan sedar, oh, baik saya tahu anda
memberikan saya integer-- beberapa nombor,

1344
01:06:04,510 --> 01:06:06,380
seperti 65 atau 90, atau apa sahaja.

1345
01:06:06,380 --> 01:06:10,170
Tetapi saya melihat bahawa anda mahu saya
memformatkan nombor yang seperti watak.

1346
01:06:10,170 --> 01:06:16,460
Dan sebagainya printf tersirat boleh membuang
yang int kepada char untuk anda juga.

1347
01:06:16,460 --> 01:06:19,360
Jadi itu bukan masalah sama sekali.

1348
01:06:19,360 --> 01:06:23,100
>> Tetapi notis, kerana kesetaraan ini
kita sebenarnya boleh melakukan ini juga.

1349
01:06:23,100 --> 01:06:26,520
Biar saya pergi ke hadapan dan membuat satu
versi lain this-- 1.c. Ascii

1350
01:06:26,520 --> 01:06:31,800
Dan bukannya iterating lebih
integer, benar-benar boleh meniup fikiran anda

1351
01:06:31,800 --> 01:06:33,610
oleh iterating lebih watak-watak.

1352
01:06:33,610 --> 01:06:37,660
Jika char c mendapat modal A, saya
mahu pergi ke depan dan melakukan ini,

1353
01:06:37,660 --> 01:06:41,740
selagi C adalah kurang daripada atau sama
ke Z. modal Dan pada setiap lelaran

1354
01:06:41,740 --> 01:06:45,690
Saya mahu untuk kenaikan C, saya boleh
kini dalam talian printf saya di sini

1355
01:06:45,690 --> 01:06:51,320
berkata, peratus C
peratus i lagi, koma C.

1356
01:06:51,320 --> 01:06:57,200
>> Dan sekarang, saya boleh pergi ke arah yang lain,
pemutus watak jelas

1357
01:06:57,200 --> 01:06:58,500
kepada integer.

1358
01:06:58,500 --> 01:07:00,560
Jadi, sekali lagi, mengapa anda melakukan ini?

1359
01:07:00,560 --> 01:07:03,830
Ia adalah pelik sedikit untuk menyusun
mengira dari segi watak.

1360
01:07:03,830 --> 01:07:07,430
>> Tetapi jika anda memahami apa yang
berlaku di bawah hood,

1361
01:07:07,430 --> 01:07:08,430
ada benar-benar ada sihir.

1362
01:07:08,430 --> 01:07:13,060
Anda hanya berkata, hey, komputer memberi
saya pembolehubah yang dipanggil C jenis char.

1363
01:07:13,060 --> 01:07:16,520
Memulakan ia ke ibu A. Dan
melihat perkara petikan tunggal.

1364
01:07:16,520 --> 01:07:19,580
>> Untuk watak-watak dalam C, ingat dari
minggu lepas, anda menggunakan petikan tunggal.

1365
01:07:19,580 --> 01:07:23,720
Untuk tali, kata-kata,
frasa, anda menggunakan tanda petikan berganda.

1366
01:07:23,720 --> 01:07:27,210
OK, komputer, terus melakukan ini, jadi
selagi watak adalah kurang daripada

1367
01:07:27,210 --> 01:07:28,050
atau sama dengan z.

1368
01:07:28,050 --> 01:07:32,640
Dan saya tahu dari meja Ascii saya bahawa semua
ini Kod Ascii yang berdampingan.

1369
01:07:32,640 --> 01:07:33,400
>> Tidak ada jurang.

1370
01:07:33,400 --> 01:07:36,737
Jadi ia hanya A hingga Z,
dipisahkan oleh satu nombor setiap satu.

1371
01:07:36,737 --> 01:07:38,820
Dan kemudian saya boleh kenaikan
char, jika saya benar-benar mahu.

1372
01:07:38,820 --> 01:07:40,390
Pada akhir hari,
ia hanya nombor.

1373
01:07:40,390 --> 01:07:41,030
Saya tahu ini.

1374
01:07:41,030 --> 01:07:43,670
Jadi saya hanya boleh menganggap untuk menambah 1 kepadanya.

1375
01:07:43,670 --> 01:07:46,940
>> Dan kemudian masa ini, saya mencetak c,
dan kemudian bersamaan kamiran.

1376
01:07:46,940 --> 01:07:50,170
Dan saya tidak perlu cast yang jelas.

1377
01:07:50,170 --> 01:07:52,680
Saya boleh membiarkan printf dan
angka komputer perkara keluar,

1378
01:07:52,680 --> 01:07:57,300
supaya sekarang sekiranya saya
membuat Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Saya mendapat perkara yang sama juga.

1380
01:08:01,520 --> 01:08:04,530
>> program yang tidak berguna, tidak ada yang though--
akan sebenarnya menulis perisian

1381
01:08:04,530 --> 01:08:07,549
untuk memikirkan, apa yang
nombor yang memetakan kepada A, atau B, atau Z?

1382
01:08:07,549 --> 01:08:10,340
Anda hanya akan di Google, atau
melihat ia dalam talian, atau melihat ia

1383
01:08:10,340 --> 01:08:11,650
pada slaid, atau sebagainya.

1384
01:08:11,650 --> 01:08:13,520
Oleh itu, bagaimana ini benar-benar mendapatkan berguna kepada anda?

1385
01:08:13,520 --> 01:08:15,960
>> Well, bercakap tentang yang
slaid, perasan ada

1386
01:08:15,960 --> 01:08:20,890
corak yang sebenar di sini antara huruf besar
dan huruf kecil yang tidak sengaja.

1387
01:08:20,890 --> 01:08:23,760
Perhatikan bahawa modal adalah 65.

1388
01:08:23,760 --> 01:08:25,830
Huruf kecil 97.

1389
01:08:25,830 --> 01:08:29,649
Dan berapa jauh adalah kes yang lebih rendah yang?

1390
01:08:29,649 --> 01:08:32,649
>> Jadi 65 adalah berapa banyak langkah dari 97?

1391
01:08:32,649 --> 01:08:36,210
Jadi 97 tolak 65 adalah 32.

1392
01:08:36,210 --> 01:08:37,910
Jadi modal ialah 65.

1393
01:08:37,910 --> 01:08:39,939
Jika anda menambah 32 itu,
anda huruf kecil a.

1394
01:08:39,939 --> 01:08:43,729
Dan, setara, jika anda tolak 32,
anda kembali ke ibu A-- sama dengan B

1395
01:08:43,729 --> 01:08:46,380
untuk sedikit b, C besar untuk sedikit c.

1396
01:08:46,380 --> 01:08:50,670
>> Semua jurang ini adalah 32 selain.

1397
01:08:50,670 --> 01:08:54,450
Sekarang, ini seolah-olah untuk membolehkan kita untuk
melakukan sesuatu seperti Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
atau Google Docs menampilkan, di mana anda
boleh memilih segala-galanya dan kemudian berkata,

1399
01:08:57,729 --> 01:09:00,520
menukar semua kepada huruf kecil, atau
menukar semua ke huruf besar,

1400
01:09:00,520 --> 01:09:03,840
atau menukar hanya perkataan pertama
sesuatu hukuman kepada huruf besar.

1401
01:09:03,840 --> 01:09:07,390
Kami benar-benar boleh melakukan sesuatu
seperti itu diri kita sendiri.

1402
01:09:07,390 --> 01:09:12,645
>> Biar saya pergi ke hadapan dan menyimpan fail
di sini dipanggil kesempatan 0.c.

1403
01:09:12,645 --> 01:09:15,770
Dan mari kita pergi ke depan dan menyiapkan program
yang tidak tepat itu seperti berikut.

1404
01:09:15,770 --> 01:09:18,460
Jadi termasuk perpustakaan CS50.

1405
01:09:18,460 --> 01:09:21,430
Dan termasuk standard I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Dan saya tahu ini akan datang tidak lama lagi.

1407
01:09:22,787 --> 01:09:24,870
Jadi saya akan memasukkannya ke dalam
ada sudah, string.h,

1408
01:09:24,870 --> 01:09:26,960
jadi saya mempunyai akses kepada
perkara seperti Stirling,

1409
01:09:26,960 --> 01:09:29,620
dan kemudian int tidak sah utama, seperti biasa.

1410
01:09:29,620 --> 01:09:33,420
Dan kemudian saya akan pergi ke hadapan
dan melakukan tali mendapat mendapatkan tali,

1411
01:09:33,420 --> 01:09:35,032
hanya untuk mendapatkan rentetan daripada pengguna.

1412
01:09:35,032 --> 01:09:36,740
Dan kemudian saya akan
melakukan cek kewarasan saya.

1413
01:09:36,740 --> 01:09:40,510
Jika rentetan tidak null sama,
maka ia adalah selamat untuk meneruskan.

1414
01:09:40,510 --> 01:09:42,000
Dan apa yang saya mahu lakukan?

1415
01:09:42,000 --> 01:09:48,700
Saya akan melelar dari i sama dengan 0,
dan n sehingga panjang tali s.

1416
01:09:48,700 --> 01:09:51,899
>> Dan saya akan melakukan ini selagi
i adalah kurang daripada n, dan i plus plus.

1417
01:09:51,899 --> 01:09:55,060
Setakat ini, saya benar-benar hanya
meminjam idea daripada sebelum ini.

1418
01:09:55,060 --> 01:09:57,010
Dan sekarang saya akan memperkenalkan cawangan.

1419
01:09:57,010 --> 01:09:59,635
>> Jadi berfikir kembali kepada calar, di mana
kita mempunyai orang-orang garpu di jalan raya,

1420
01:09:59,635 --> 01:10:05,110
dan minggu terakhir di dalam C. saya akan
mengatakan ini, jika watak i-ke-dalam s

1421
01:10:05,110 --> 01:10:09,250
adalah lebih besar daripada atau
sama dengan huruf kecil a,

1422
01:10:09,250 --> 01:10:13,340
dan- dalam Scratch yang anda lakukan betul-betul
katakan dan, tetapi dalam C anda mengatakan ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- dan watak i-ke-dalam s
adalah kurang daripada atau sama dengan huruf kecil z,

1424
01:10:19,830 --> 01:10:21,780
mari kita buat sesuatu yang menarik.

1425
01:10:21,780 --> 01:10:27,020
Mari kita sebenarnya mencetak
watak tanpa newline

1426
01:10:27,020 --> 01:10:31,760
iaitu watak dalam tali,
watak i-ke-dalam rentetan.

1427
01:10:31,760 --> 01:10:37,420
>> Tetapi mari kita pergi ke hadapan dan
tolak 32 daripadanya.

1428
01:10:37,420 --> 01:10:42,120
Lain jika watak dalam
rentetan kita mencari yang sedang

1429
01:10:42,120 --> 01:10:45,950
bukan antara sedikit yang
dan sedikit z, teruskan

1430
01:10:45,950 --> 01:10:48,610
dan hanya dicetak keluar tidak berubah.

1431
01:10:48,610 --> 01:10:50,840
Oleh itu, kita telah memperkenalkan
notasi kurungan ini

1432
01:10:50,840 --> 01:10:53,560
untuk tali kami untuk mendapatkan di
i-ke-watak dalam rentetan.

1433
01:10:53,560 --> 01:10:57,520
>> Saya telah menambah beberapa logik bersyarat, seperti
Scratch pada minggu satu minggu lepas, di mana

1434
01:10:57,520 --> 01:10:59,880
Saya hanya menggunakan asas saya
memahami apa yang

1435
01:10:59,880 --> 01:11:01,130
berlaku di bawah hood.

1436
01:11:01,130 --> 01:11:04,190
Adalah watak i-ke-s
lebih besar daripada atau sama dengan yang?

1437
01:11:04,190 --> 01:11:08,290
Seperti, ia 97, atau 98,
atau 99, dan sebagainya?

1438
01:11:08,290 --> 01:11:11,940
>> Tetapi adakah ia juga kurang daripada atau sama
dengan nilai z huruf kecil?

1439
01:11:11,940 --> 01:11:16,210
Dan jika ya, apakah garis ini bermakna?

1440
01:11:16,210 --> 01:11:20,250
14, ini adalah jenis yang
kuman keseluruhan idea,

1441
01:11:20,250 --> 01:11:23,840
mengambil kesempatan surat oleh
hanya menolak 32 daripadanya,

1442
01:11:23,840 --> 01:11:29,370
dalam kes ini, kerana saya tahu, setiap yang
carta, bagaimana nombor saya diwakili.

1443
01:11:29,370 --> 01:11:33,925
Jadi mari kita pergi ke hadapan dan menjalankan ini,
selepas menyusun kesempatan 0.c,

1444
01:11:33,925 --> 01:11:36,210
dan jangka kesempatan 0.

1445
01:11:36,210 --> 01:11:40,300
>> Mari menaip sesuatu seperti
Zamyla dalam semua huruf kecil masuk.

1446
01:11:40,300 --> 01:11:42,780
Dan sekarang kita mempunyai Zamyla dalam semua huruf besar.

1447
01:11:42,780 --> 01:11:45,050
Mari kita menaip Rob dalam semua huruf kecil.

1448
01:11:45,050 --> 01:11:46,674
Mari kita cuba Jason dalam semua huruf kecil.

1449
01:11:46,674 --> 01:11:48,590
Dan kita terus mendapat
permodalan paksa.

1450
01:11:48,590 --> 01:11:50,960
Ada bug kecil yang saya
jenis tidak menjangka.

1451
01:11:50,960 --> 01:11:54,050
Perhatikan segera baru saya berakhir
pada baris yang sama sebagai nama-nama mereka,

1452
01:11:54,050 --> 01:11:55,520
yang berasa tidak kemas sedikit.

1453
01:11:55,520 --> 01:11:59,170
>> Jadi saya akan pergi ke sini, dan
sebenarnya pada akhir program ini

1454
01:11:59,170 --> 01:12:02,110
mencetak watak newline.

1455
01:12:02,110 --> 01:12:03,160
Itu sahaja.

1456
01:12:03,160 --> 01:12:06,120
Dengan printf, anda tidak perlu
lulus dalam pembolehubah atau kod format.

1457
01:12:06,120 --> 01:12:08,460
Anda benar-benar boleh hanya mencetak
sesuatu seperti newline a.

1458
01:12:08,460 --> 01:12:13,529
>> Jadi mari kita pergi ke hadapan dan membuat
mengambil kesempatan 0 lagi, jalankan ia, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Dan kini ia adalah yang lebih cantik sedikit.

1460
01:12:14,820 --> 01:12:17,274
Sekarang, segera saya ialah pada baris sendiri baru.

1461
01:12:17,274 --> 01:12:18,440
Jadi itu semua baik dan baik.

1462
01:12:18,440 --> 01:12:19,910
Jadi itulah contoh yang baik.

1463
01:12:19,910 --> 01:12:22,700
Tetapi saya tidak walaupun semestinya
perlu kod keras 32.

1464
01:12:22,700 --> 01:12:23,350
Awak tahu tak?

1465
01:12:23,350 --> 01:12:26,350
Saya boleh iaitu- saya tidak pernah
ingat apa perbezaan.

1466
01:12:26,350 --> 01:12:29,330
>> Tetapi saya tahu bahawa jika saya
mempunyai surat kes yang lebih rendah,

1467
01:12:29,330 --> 01:12:34,430
Saya pada dasarnya mahu tolak off
apa sahaja jarak adalah antara sedikit

1468
01:12:34,430 --> 01:12:39,160
dan besar A, kerana jika saya menganggap bahawa
semua huruf lain adalah sama,

1469
01:12:39,160 --> 01:12:41,045
yang perlu mendapatkan pekerjaan yang dilakukan.

1470
01:12:41,045 --> 01:12:42,670
Tetapi bukannya berbuat demikian, anda tahu apa?

1471
01:12:42,670 --> 01:12:44,240
Ada cara lain masih.

1472
01:12:44,240 --> 01:12:48,090
>> Jika itu mengambil kesempatan 1.c-- jika saya
untuk meletakkan itu ke dalam fail yang berasingan.

1473
01:12:48,090 --> 01:12:51,030
mari kita jangan mengambil kesempatan 2.c seperti berikut.

1474
01:12:51,030 --> 01:12:53,060
Saya akan benar-benar membersihkan ini di sini.

1475
01:12:53,060 --> 01:12:57,420
Dan bukannya juga perlu
tahu atau mengambil berat tentang tahap yang rendah

1476
01:12:57,420 --> 01:13:01,090
butir-butir pelaksanaan, Saya bukannya
hanya akan mencetak watak,

1477
01:13:01,090 --> 01:13:04,610
quote unquote, peratus C, dan
kemudian memanggil fungsi lain yang

1478
01:13:04,610 --> 01:13:09,950
wujud yang mengambil hujah,
yang merupakan watak, seperti ini.

1479
01:13:09,950 --> 01:13:12,630
>> Ternyata dalam C, ada
satu lagi panggilan fungsi

1480
01:13:12,630 --> 01:13:15,550
ke atas, yang seperti namanya
mencadangkan mengambil watak

1481
01:13:15,550 --> 01:13:19,350
dan menjadikannya untuk kes atasnya
setara, dan kemudian kembali ia

1482
01:13:19,350 --> 01:13:21,410
supaya printf yang boleh palamkan ia di sana.

1483
01:13:21,410 --> 01:13:25,484
Dan sebagainya untuk melakukan ini, walaupun, saya
perlu memperkenalkan satu fail lain.

1484
01:13:25,484 --> 01:13:28,400
Ia ternyata ada fail lain
bahawa anda hanya akan tahu dari kelas,

1485
01:13:28,400 --> 01:13:33,020
atau buku teks, atau dalam talian yang
rujukan, yang dipanggil C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Jadi, jika saya menambah bahawa di kalangan header saya
fail, dan kini semula menyusun program ini,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Mari kita menaip Zamyla dalam semua
huruf kecil, masih bekerja yang sama.

1489
01:13:46,690 --> 01:13:48,040
Tetapi anda tahu apa?

1490
01:13:48,040 --> 01:13:55,590
Ia ternyata bahawa untuk atas
mempunyai beberapa fungsi lain.

1491
01:13:55,590 --> 01:13:58,410
>> Dan biarlah saya memperkenalkan ini
perintah di sini, jenis canggung

1492
01:13:58,410 --> 01:14:00,250
dinamakan, tetapi manusia untuk manual.

1493
01:14:00,250 --> 01:14:03,960
Ia ternyata bahawa kebanyakan komputer Linux,
kerana kami menggunakan sini-- operasi Linux

1494
01:14:03,960 --> 01:14:06,270
system-- mempunyai arahan yang
memanggil orang, yang berkata,

1495
01:14:06,270 --> 01:14:08,530
hey, komputer, memberi saya
manual komputer.

1496
01:14:08,530 --> 01:14:10,680
apa yang awak mahu
melihat dalam manual itu?

1497
01:14:10,680 --> 01:14:13,840
>> Saya mahu melihat ke atas fungsi
dipanggil untuk atas, Enter.

1498
01:14:13,840 --> 01:14:16,070
Dan ia sedikit samar
untuk membaca kadang-kadang.

1499
01:14:16,070 --> 01:14:18,780
Tetapi melihat kita berada dalam
manual Linux pengaturcara.

1500
01:14:18,780 --> 01:14:19,530
Dan itu semua teks.

1501
01:14:19,530 --> 01:14:21,905
Dan perhatikan bahawa ada yang
menamakan fungsi di sini.

1502
01:14:21,905 --> 01:14:25,030
Ternyata ia mempunyai sepupu yang dipanggil
yang lebih rendah, yang tidak sebaliknya.

1503
01:14:25,030 --> 01:14:29,710
Dan notis di bawah sinopsis, untuk menggunakan ini
berfungsi halaman lelaki itu, boleh dikatakan,

1504
01:14:29,710 --> 01:14:32,220
memberitahu saya bahawa saya
perlu untuk memasukkan c type.h.

1505
01:14:32,220 --> 01:14:33,630
Dan saya tahu bahawa daripada amalan.

1506
01:14:33,630 --> 01:14:36,210
>> Di sini, ia menunjukkan kepadaku kedua
prototaip untuk fungsi,

1507
01:14:36,210 --> 01:14:39,070
supaya jika saya mahu menggunakan ini
Saya tahu apa yang mereka ambil input,

1508
01:14:39,070 --> 01:14:40,652
dan apa yang mereka kembali sebagai output.

1509
01:14:40,652 --> 01:14:42,360
Dan kemudian jika saya membaca
keterangan, saya melihat

1510
01:14:42,360 --> 01:14:44,820
dengan lebih terperinci apa fungsi tidak.

1511
01:14:44,820 --> 01:14:48,100
Tetapi yang lebih penting, jika
Saya lihat di bawah nilai pulangan,

1512
01:14:48,100 --> 01:14:51,710
ia berkata nilai yang dikembalikan adalah
bahawa surat yang ditukar,

1513
01:14:51,710 --> 01:14:57,880
atau C, input asal, jika
penukaran tidak mungkin.

1514
01:14:57,880 --> 01:15:01,992
>> Dalam erti kata lain, untuk atas akan cuba
untuk menukar surat kepada huruf besar.

1515
01:15:01,992 --> 01:15:03,450
Dan jika demikian, ia akan mengembalikannya.

1516
01:15:03,450 --> 01:15:07,010
Tetapi jika ia tidak boleh untuk beberapa reason--
mungkin ia kes sudah atas,

1517
01:15:07,010 --> 01:15:09,550
mungkin ia tanda seru
atau beberapa punctuation-- lain

1518
01:15:09,550 --> 01:15:12,200
ia hanya akan
kembali C asal,

1519
01:15:12,200 --> 01:15:17,340
yang bermakna saya boleh membuat kod saya
direka lebih baik seperti berikut.

1520
01:15:17,340 --> 01:15:20,580
>> Saya tidak memerlukan semua
ayat-ayat ini darn kod.

1521
01:15:20,580 --> 01:15:22,610
Semua garisan saya telah
hanya menekankan boleh

1522
01:15:22,610 --> 01:15:28,700
runtuh ke dalam hanya satu yang mudah
line, yang this-- printf peratus

1523
01:15:28,700 --> 01:15:33,510
c pendakap S atas i.

1524
01:15:33,510 --> 01:15:36,090
Dan ini akan menjadi satu
contoh reka bentuk yang lebih baik.

1525
01:15:36,090 --> 01:15:40,040
>> Mengapa melaksanakan dalam 7 atau 8 baris
kod, walau apa pun ia saya

1526
01:15:40,040 --> 01:15:44,960
dipadam, apabila anda sebaliknya boleh runtuh
semua itu logik dan membuat keputusan

1527
01:15:44,960 --> 01:15:49,620
ke dalam satu baris tunggal, 13, supaya
bergantung kepada perpustakaan function--

1528
01:15:49,620 --> 01:15:53,430
fungsi yang datang dengan C, tetapi itu
tidak betul-betul apa yang anda mahu ia lakukan.

1529
01:15:53,430 --> 01:15:55,295
Dan, terus terang, walaupun
ia tidak datang dengan C,

1530
01:15:55,295 --> 01:15:58,880
anda boleh melaksanakan sendiri, kerana
kita lihat, dengan mendapatkan int negatif

1531
01:15:58,880 --> 01:16:01,700
dan mendapatkan positif int minggu lepas juga.

1532
01:16:01,700 --> 01:16:03,470
>> Kod ini sekarang jauh lebih mudah dibaca.

1533
01:16:03,470 --> 01:16:06,670
Dan, sememangnya, jika kita tatal ke atas,
melihat berapa banyak yang lebih padat

1534
01:16:06,670 --> 01:16:08,360
versi program saya.

1535
01:16:08,360 --> 01:16:11,230
Ia adalah satu berat atas sedikit sekarang,
dengan semua ini termasuk.

1536
01:16:11,230 --> 01:16:14,380
Tetapi itu OK, kerana sekarang saya berdiri
di bahu pengaturcara

1537
01:16:14,380 --> 01:16:15,300
sebelum saya.

1538
01:16:15,300 --> 01:16:18,440
Dan sesiapa yang ia yang
dilaksanakan untuk atas benar-benar

1539
01:16:18,440 --> 01:16:21,470
tidak membantu aku, sama seperti orang yang
dilaksanakan Stirling benar-benar

1540
01:16:21,470 --> 01:16:24,790
tidak membantu aku sedikit masa lalu.

1541
01:16:24,790 --> 01:16:26,970
Dan sekarang kita mempunyai
program reka bentuk yang lebih baik

1542
01:16:26,970 --> 01:16:31,680
yang melaksanakan logik yang sama.

1543
01:16:31,680 --> 01:16:35,580
>> Bercakap stirling, mari
saya pergi ke hadapan dan melakukan ini.

1544
01:16:35,580 --> 01:16:38,320
Biar saya pergi ke hadapan dan menyimpan
fail ini sebagai stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Dan ternyata, kita boleh mengupas kembali
satu lapisan lain cukup hanya sekarang.

1546
01:16:43,255 --> 01:16:45,630
Saya akan pergi ke hadapan dan cambuk
program lain di utama

1547
01:16:45,630 --> 01:16:49,759
di sini bahawa hanya semula alat
panjang tali seperti berikut.

1548
01:16:49,759 --> 01:16:52,300
Jadi di sini adalah satu baris kod yang
mendapat saya rentetan daripada pengguna.

1549
01:16:52,300 --> 01:16:53,910
Kami terus menggunakan ini lagi dan lagi.

1550
01:16:53,910 --> 01:16:58,900
Biar saya memberikan diri saya pembolehubah yang dipanggil
n jenis int yang menyimpan nombor.

1551
01:16:58,900 --> 01:17:02,490
>> Dan biarlah saya pergi ke hadapan dan
melakukan logik berikut.

1552
01:17:02,490 --> 01:17:15,610
Walaupun watak n-ke-dalam s tidak
tidak sama garis sendeng terbalik 0, teruskan

1553
01:17:15,610 --> 01:17:17,930
dan kenaikan n.

1554
01:17:17,930 --> 01:17:23,506
Dan kemudian mencetak printf peratus i n.

1555
01:17:23,506 --> 01:17:29,200
Saya mendakwa bahawa program ini di sini,
tanpa dipanggil panjang tali,

1556
01:17:29,200 --> 01:17:31,150
angka panjang rentetan.

1557
01:17:31,150 --> 01:17:34,600
>> Dan sihir sepenuhnya
terkandung dalam talian 8

1558
01:17:34,600 --> 01:17:39,830
di sini dengan apa yang kelihatan seperti sintaks baru,
garis sendeng terbalik ini 0 dalam petikan tunggal.

1559
01:17:39,830 --> 01:17:41,360
Tetapi mengapa itu?

1560
01:17:41,360 --> 01:17:44,100
Well, pertimbangkan apa yang telah
berlaku selama ini.

1561
01:17:44,100 --> 01:17:47,990
>> Dan sebagai diketepikan sebelum saya lupa, menyedari
juga, bahawa sebagai tambahan kepada halaman man

1562
01:17:47,990 --> 01:17:50,920
yang datang dengan yang biasa
sistem Linux seperti CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
menyedari bahawa kita,
kakitangan kursus ini, mempunyai juga

1564
01:17:53,770 --> 01:17:56,030
membuat versi laman web
idea ini sama dipanggil

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, yang mempunyai
semua orang-orang halaman man sama,

1566
01:17:59,940 --> 01:18:02,020
semua yang sama
dokumentasi, serta

1567
01:18:02,020 --> 01:18:05,730
kotak kecil di bahagian atas yang membolehkan
anda untuk menukar semua agak

1568
01:18:05,730 --> 01:18:09,025
bahasa yang sukar difahami menjadi kurang selesa
mod, di mana kita, tenaga pengajar,

1569
01:18:09,025 --> 01:18:12,150
telah melalui dan cuba untuk memudahkan
beberapa bahasa untuk menjaga perkara-perkara

1570
01:18:12,150 --> 01:18:14,830
memberi tumpuan kepada idea-idea, dan tidak
beberapa perkara teknikal.

1571
01:18:14,830 --> 01:18:20,070
Jadi ingat, reference.cs50.net
sebagai sumber lain juga.

1572
01:18:20,070 --> 01:18:23,800
>> Tetapi mengapa kerja panjang rentetan dalam
cara saya mencadangkan masa lalu?

1573
01:18:23,800 --> 01:18:25,160
Berikut adalah nama Zamyla sekali lagi.

1574
01:18:25,160 --> 01:18:27,690
Dan di sini adalah nama Zamyla ini
berkotak dalam, kerana saya terus melakukan,

1575
01:18:27,690 --> 01:18:31,360
untuk memberi gambaran yang ia menjadi,
benar-benar, hanya jujukan aksara.

1576
01:18:31,360 --> 01:18:34,260
Tetapi Zamyla tidak wujud
secara berasingan dalam program.

1577
01:18:34,260 --> 01:18:37,420
>> Apabila anda menulis dan menjalankan program,
anda menggunakan Mac atau PC anda

1578
01:18:37,420 --> 01:18:40,010
sebagai ingatan, atau RAM jadi untuk bercakap.

1579
01:18:40,010 --> 01:18:42,620
Dan anda boleh berfikir
komputer anda sebagai mempunyai

1580
01:18:42,620 --> 01:18:44,730
banyak gigabait memori hari ini.

1581
01:18:44,730 --> 01:18:47,700
Dan gig yang bermakna berbilion-bilion,
jadi berbilion bait.

1582
01:18:47,700 --> 01:18:48,910
>> Tetapi mari kita putar balik dalam masa.

1583
01:18:48,910 --> 01:18:51,530
Dan andaikan bahawa kita menggunakan
komputer benar-benar lama yang

1584
01:18:51,530 --> 01:18:55,150
hanya mempunyai 32 bait memori.

1585
01:18:55,150 --> 01:18:59,310
Saya boleh, pada skrin komputer saya,
hanya menarik ini seperti berikut.

1586
01:18:59,310 --> 01:19:05,240
>> Saya hanya boleh mengatakan bahawa saya
komputer mempunyai kesemua memori ini.

1587
01:19:05,240 --> 01:19:08,830
Dan ini adalah seperti batang memori, jika
anda masih ingat gambar kami dari masa lalu.

1588
01:19:08,830 --> 01:19:11,670
Dan jika saya bahagikan
ini pada masa-masa yang cukup,

1589
01:19:11,670 --> 01:19:15,040
Saya menuntut bahawa saya mempunyai 32 bytes
memori pada skrin.

1590
01:19:15,040 --> 01:19:18,239
>> Sekarang, pada hakikatnya, saya hanya boleh
menarik setakat ini pada skrin ini di sini.

1591
01:19:18,239 --> 01:19:20,280
Jadi, saya akan pergi ke hadapan,
dan hanya dengan konvensyen,

1592
01:19:20,280 --> 01:19:24,050
menarik memori komputer saya sebagai
grid, bukan sahaja sebagai satu garis lurus.

1593
01:19:24,050 --> 01:19:28,190
Secara khusus, saya menuntut sekarang bahawa
grid ini, ini 8 oleh 4 grid,

1594
01:19:28,190 --> 01:19:31,800
hanya mewakili semua 32 bytes
memori yang terdapat dalam Mac saya,

1595
01:19:31,800 --> 01:19:33,030
atau terdapat di PC saya.

1596
01:19:33,030 --> 01:19:34,780
Dan mereka membungkus
ke dua baris, hanya

1597
01:19:34,780 --> 01:19:38,030
kerana sesuai lebih pada skrin.

1598
01:19:38,030 --> 01:19:40,800
Tetapi ini adalah bait pertama.

1599
01:19:40,800 --> 01:19:41,990
Ini adalah bait kedua.

1600
01:19:41,990 --> 01:19:43,300
Ini adalah bait ketiga.

1601
01:19:43,300 --> 01:19:45,310
>> Dan ini adalah bait-32.

1602
01:19:45,310 --> 01:19:52,910
Atau, jika kita berfikir seperti komputer
saintis, ini adalah bait 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Jadi, anda perlu 0-31, jika
anda mula mengira pada 0.

1604
01:19:55,950 --> 01:19:59,830
>> Jadi, jika kita menggunakan program
bahawa panggilan mendapatkan tali,

1605
01:19:59,830 --> 01:20:05,280
dan kami mendapatkan rentetan daripada manusia
seperti aku dipanggil Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
bagaimana di dunia melakukan
trek komputer keep yang bait,

1607
01:20:09,430 --> 01:20:12,230
yang sebahagian memori,
tergolong dalam rentetan?

1608
01:20:12,230 --> 01:20:16,270
Dalam erti kata lain, jika kita teruskan untuk
menaip nama lain ke dalam komputer,

1609
01:20:16,270 --> 01:20:19,890
seperti Andi ini, menyeru
mendapatkan tali kali kedua,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I telah berakhir di
memori komputer juga.

1611
01:20:23,030 --> 01:20:23,850
Tetapi bagaimana?

1612
01:20:23,850 --> 01:20:29,700
>> Nah, ternyata bahawa di bawah yang
hud, apa yang C tidak apabila menyimpan rentetan

1613
01:20:29,700 --> 01:20:35,080
bahawa jenis manusia dalam, atau yang
datang dari beberapa sumber lain, adakah

1614
01:20:35,080 --> 01:20:39,190
menggariskan akhir mereka dengan
satu garis sendeng terbalik character-- khas

1615
01:20:39,190 --> 01:20:44,750
0, yang hanya cara yang khas
untuk mengatakan 80 bit berturut-turut.

1616
01:20:44,750 --> 01:20:47,950
>> Jadi A-- ini adalah nombor 97 ingat.

1617
01:20:47,950 --> 01:20:51,770
Jadi beberapa corak 8 bit
mewakili nombor perpuluhan 97.

1618
01:20:51,770 --> 01:20:58,070
garis sendeng terbalik ini 0 literal bilangan
0, nul turut dikenali sebagai, N-U-L, tidak seperti sebelum ini,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, yang kita bercakap tentang.

1620
01:20:59,630 --> 01:21:05,700
Tetapi untuk sekarang, hanya tahu bahawa ini
garis sendeng terbalik 0 hanya 80 bit berturut-turut.

1621
01:21:05,700 --> 01:21:09,810
>> Dan ia hanya garis ini dalam
pasir yang menegor kiri

1622
01:21:09,810 --> 01:21:12,610
tergolong dalam salah satu tali, atau satu jenis data.

1623
01:21:12,610 --> 01:21:15,480
Dan apa-apa ke kanan
tergolong dalam sesuatu yang lain.

1624
01:21:15,480 --> 01:21:17,440
Andi nama, sementara itu,
yang hanya visual

1625
01:21:17,440 --> 01:21:21,310
berlaku untuk membalut ke baris lain,
tetapi itu hanya satu perincian yang estetik,

1626
01:21:21,310 --> 01:21:23,990
sama adalah nul ditamatkan.

1627
01:21:23,990 --> 01:21:29,290
>> Ia adalah rentetan daripada watak-watak A-N-D-I,
ditambah dengan watak rahsia kelima,

1628
01:21:29,290 --> 01:21:33,560
semua 0 bit, yang hanya demarcates
akhir nama Andi juga.

1629
01:21:33,560 --> 01:21:37,120
Dan jika kita memanggil mendapatkan tali kali ketiga
dalam komputer untuk mendapatkan rentetan seperti

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, begitu juga adalah Maria
nama nul ditamatkan dengan garis sendeng terbalik 0.

1631
01:21:44,210 --> 01:21:47,170
>> Ini adalah berbeza
dari bagaimana komputer akan biasanya

1632
01:21:47,170 --> 01:21:51,850
menyimpan integer, atau apungan, atau lain-lain
jenis data masih, kerana ingat,

1633
01:21:51,850 --> 01:21:57,420
integer biasanya 32 bit, atau
4 bait, atau mungkin juga 64 bit,

1634
01:21:57,420 --> 01:21:59,100
atau lapan bait.

1635
01:21:59,100 --> 01:22:02,620
Tetapi ramai primitif dalam komputer
dalam bahasa pengaturcaraan

1636
01:22:02,620 --> 01:22:05,550
mempunyai nombor tetap
bait di bawah hood-- yang

1637
01:22:05,550 --> 01:22:08,100
mungkin 1, mungkin 2, mungkin 4, mungkin 8.

1638
01:22:08,100 --> 01:22:13,250
>> Tetapi tali, dengan reka bentuk, mempunyai
nombor dinamik watak-watak.

1639
01:22:13,250 --> 01:22:16,980
Anda tidak tahu terlebih dahulu, sehingga
jenis-jenis manusia dalam Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
atau M-A-R-I-A atau A-N-D-I. Anda tidak tahu
berapa kali pengguna akan melanda

1641
01:22:21,400 --> 01:22:22,070
papan kekunci.

1642
01:22:22,070 --> 01:22:26,490
Oleh itu, anda tidak tahu bagaimana
banyak watak terlebih dahulu

1643
01:22:26,490 --> 01:22:27,540
anda akan perlukan.

1644
01:22:27,540 --> 01:22:31,840
>> Dan sebagainya C hanya jenis daun seperti
breadcrumb rahsia di bawah hood

1645
01:22:31,840 --> 01:22:32,960
pada akhir tali.

1646
01:22:32,960 --> 01:22:39,280
Selepas menyimpan Z-A-M-Y-L-A dalam ingatan,
ia juga hanya meletakkan bersamaan

1647
01:22:39,280 --> 01:22:40,210
tempoh.

1648
01:22:40,210 --> 01:22:45,060
Pada akhir ayat,
ia meletakkan 80 bit, supaya

1649
01:22:45,060 --> 01:22:49,120
ingat di mana
Zamyla bermula dan berakhir.

1650
01:22:49,120 --> 01:22:51,490
>> Jadi apa sambungan,
maka, untuk program ini?

1651
01:22:51,490 --> 01:22:55,190
program ini di sini, Stirling,
adalah semata-mata satu mekanisme

1652
01:22:55,190 --> 01:22:57,970
untuk mendapatkan rentetan
daripada pengguna, line 6.

1653
01:22:57,970 --> 01:23:01,160
Line 7, saya mengisytiharkan pembolehubah
dipanggil n dan menetapkan ia sama dengan 0.

1654
01:23:01,160 --> 01:23:08,680
>> Dan kemudian dalam talian 8, saya hanya bertanya kepada
soalan, manakala watak n-ke-tidak

1655
01:23:08,680 --> 01:23:12,120
tidak sama semua 0 bits--
dalam erti kata lain, tidak

1656
01:23:12,120 --> 01:23:14,500
sama istimewa ini
watak, garis sendeng terbalik 0, yang

1657
01:23:14,500 --> 01:23:18,470
adalah hanya itu character-- nul khas
pergi ke depan dan hanya kenaikan n.

1658
01:23:18,470 --> 01:23:21,460
>> Dan perlu melakukannya, dan menjaga
melakukannya, dan terus melakukannya.

1659
01:23:21,460 --> 01:23:23,430
Dan sebagainya walaupun dalam
Sebelum ini, kami telah menggunakan i,

1660
01:23:23,430 --> 01:23:25,181
ia adalah betul-betul halus
semantik untuk menggunakan n,

1661
01:23:25,181 --> 01:23:27,430
jika anda hanya cuba untuk
mengira masa ini sengaja,

1662
01:23:27,430 --> 01:23:28,720
dan hanya mahu memanggilnya n.

1663
01:23:28,720 --> 01:23:34,720
Jadi ini hanya menyimpan bertanya soalan,
adalah watak n-ke-s semua 0-an?

1664
01:23:34,720 --> 01:23:38,470
Jika tidak, melihat kepada wajah yang akan datang,
melihat ke depan, melihat ke depan,

1665
01:23:38,470 --> 01:23:39,460
melihat ke depan.

1666
01:23:39,460 --> 01:23:45,540
>> Tetapi sebaik sahaja anda melihat garis sendeng terbalik 0,
garis ini loop-- 9 melalui 11-- berhenti.

1667
01:23:45,540 --> 01:23:49,640
Anda keluar daripada gelung sementara,
meninggalkan bahagian dalam yang n pembolehubah

1668
01:23:49,640 --> 01:23:54,530
jumlah kiraan semua
watak-watak dalam rentetan yang anda lihat,

1669
01:23:54,530 --> 01:23:55,660
dengan itu mencetak ia keluar.

1670
01:23:55,660 --> 01:23:56,760
Jadi mari kita cuba ini.

1671
01:23:56,760 --> 01:23:59,500
>> Biar saya pergi ke hadapan dan, tanpa
menggunakan fungsi stirling itu,

1672
01:23:59,500 --> 01:24:04,240
tetapi hanya menggunakan versi tempatan saya sendiri
di sini dipanggil stirling, biarlah saya pergi ke hadapan

1673
01:24:04,240 --> 01:24:07,700
dan jangka stirling, jenis dalam sesuatu
seperti Zamyla, yang saya tahu terlebih dahulu

1674
01:24:07,700 --> 01:24:08,670
enam aksara.

1675
01:24:08,670 --> 01:24:10,080
Mari kita lihat jika ia berfungsi.

1676
01:24:10,080 --> 01:24:10,920
Sesungguhnya, ia adalah enam.

1677
01:24:10,920 --> 01:24:15,257
Mari kita cuba dengan Rob, tiga watak,
tiga watak juga, dan sebagainya.

1678
01:24:15,257 --> 01:24:17,340
Jadi itu sahaja yang akan
di bawah hood.

1679
01:24:17,340 --> 01:24:19,548
Dan notis sambungan,
kemudian, dengan minggu pertama

1680
01:24:19,548 --> 01:24:22,370
kelas, di mana kita bercakap tentang
sesuatu seperti pengambilan,

1681
01:24:22,370 --> 01:24:26,960
yang hanya lapisan ini idea, atau
kerumitan, di atas prinsip-prinsip asas.

1682
01:24:26,960 --> 01:24:30,710
Di sini, kita semacam mencari
di bawah bonet stirling,

1683
01:24:30,710 --> 01:24:33,510
jadi untuk bercakap, untuk memikirkan,
bagaimana akan ia akan dilaksanakan?

1684
01:24:33,510 --> 01:24:35,232
>> Dan kita boleh melaksanakan semula diri kita sendiri.

1685
01:24:35,232 --> 01:24:37,440
Tetapi kita tidak lagi akan
semula melaksanakan stirling.

1686
01:24:37,440 --> 01:24:39,780
Kami hanya akan
menggunakan stirling agar

1687
01:24:39,780 --> 01:24:42,100
untuk benar-benar mendapatkan beberapa panjang tali.

1688
01:24:42,100 --> 01:24:44,200
>> Tetapi tidak ada sihir
bawah hood.

1689
01:24:44,200 --> 01:24:46,716
Jika anda tahu bahawa di bawah
hood, rentetan

1690
01:24:46,716 --> 01:24:48,090
hanya jujukan aksara.

1691
01:24:48,090 --> 01:24:51,090
Dan bahawa jujukan aksara
semua boleh berangka ditangani

1692
01:24:51,090 --> 01:24:53,330
dengan pendakap 0, kurungan
1, kurungan 2, dan anda

1693
01:24:53,330 --> 01:24:57,420
tahu bahawa pada akhir rentetan ialah
aksara khas, anda boleh memikirkan

1694
01:24:57,420 --> 01:25:01,710
bagaimana untuk melakukan sebahagian apa-apa dalam
program, kerana semua itu bermuara pada

1695
01:25:01,710 --> 01:25:03,400
membaca dan menulis ingatan.

1696
01:25:03,400 --> 01:25:06,130
Iaitu, berubah dan mencari
di ingatan, atau sesuatu yang bergerak

1697
01:25:06,130 --> 01:25:10,940
sekitar dalam ingatan, perkara percetakan
pada skrin, dan sebagainya.

1698
01:25:10,940 --> 01:25:14,800
>> Jadi mari kita kini menggunakan baru ditemui ini
memahami apa yang sebenarnya tali

1699
01:25:14,800 --> 01:25:17,910
adalah di bawah hood, dan
mengupas kembali satu lapisan lain

1700
01:25:17,910 --> 01:25:20,080
yang sehingga kini kami telah
telah mengabaikan sama sekali.

1701
01:25:20,080 --> 01:25:22,650
Khususnya masa, mana-mana
kami telah melaksanakan program,

1702
01:25:22,650 --> 01:25:25,930
kita mempunyai baris ini kod
berhampiran mengisytiharkan utama.

1703
01:25:25,930 --> 01:25:27,810
Dan kami telah dinyatakan tidak sah utama int.

1704
01:25:27,810 --> 01:25:31,240
>> Dan itu tidak sah di dalam kurungan
mempunyai telah berkata selama ini yang utama

1705
01:25:31,240 --> 01:25:33,440
itu sendiri tidak mengambil apa-apa hujah.

1706
01:25:33,440 --> 01:25:36,210
Mana-mana input yang utama adalah
akan dapat daripada pengguna

1707
01:25:36,210 --> 01:25:39,020
perlu datang dari beberapa yang lain
mekanisme, seperti mendapatkan int,

1708
01:25:39,020 --> 01:25:42,040
atau mendapatkan apungan, atau mendapatkan tali,
atau beberapa fungsi lain.

1709
01:25:42,040 --> 01:25:44,710
Tetapi ternyata bahawa
apabila anda menulis program,

1710
01:25:44,710 --> 01:25:47,690
anda sebenarnya boleh menentukan
bahawa program ini hendaklah

1711
01:25:47,690 --> 01:25:51,730
mengambil input daripada manusia
pada baris arahan itu sendiri.

1712
01:25:51,730 --> 01:25:56,310
>> Dengan kata lain, walaupun kita setakat ini
mempunyai telah berjalan hanya ./hello hello

1713
01:25:56,310 --> 01:26:00,312
atau program yang sama, semua
program lain yang kita telah gunakan,

1714
01:26:00,312 --> 01:26:02,770
yang kita sendiri tidak menulis,
mempunyai telah mengambil, ia seolah-olah,

1715
01:26:02,770 --> 01:26:05,210
baris arahan arguments--
perkara seperti make.

1716
01:26:05,210 --> 01:26:07,450
Anda mengatakan sesuatu seperti membuat,
dan kemudian perkataan kedua.

1717
01:26:07,450 --> 01:26:10,950
Atau dilafaz, anda mengatakan dilafaz, dan kemudian
perkataan kedua, nama fail.

1718
01:26:10,950 --> 01:26:14,410
>> Atau RM atau CP, kerana anda mungkin
telah melihat atau digunakan sudah

1719
01:26:14,410 --> 01:26:15,880
untuk menghapuskan atau menyalin fail.

1720
01:26:15,880 --> 01:26:18,920
Semua mereka mengambil apa yang dipanggil
baris arahan arguments--

1721
01:26:18,920 --> 01:26:21,130
perkataan tambahan di prompt terminal.

1722
01:26:21,130 --> 01:26:23,260
Tetapi sehingga kini, kita
diri kita tidak mempunyai

1723
01:26:23,260 --> 01:26:27,080
ini mewah mengambil input daripada
pengguna apabila dia sebenarnya berjalan

1724
01:26:27,080 --> 01:26:29,120
program itu sendiri pada baris arahan.

1725
01:26:29,120 --> 01:26:33,710
>> Tetapi kita boleh melakukannya dengan semula mengisytiharkan
utama dan seterusnya, bukan sebagai mempunyai

1726
01:26:33,710 --> 01:26:36,750
tidak sah dalam kurungan,
tetapi kedua-dua hujah

1727
01:26:36,750 --> 01:26:40,600
instead-- pertama integer yang,
dan sesuatu yang kedua

1728
01:26:40,600 --> 01:26:44,170
baru, sesuatu yang kita akan memanggil
pelbagai, sesuatu yang sama dalam semangat

1729
01:26:44,170 --> 01:26:49,220
dengan apa yang kita lihat dalam Scratch sebagai satu senarai, tetapi
pelbagai rentetan, kerana kita tidak lama lagi akan melihat.

1730
01:26:49,220 --> 01:26:51,790
Tetapi mari kita lihat ini dengan
Sebagai contoh, sebelum kita

1731
01:26:51,790 --> 01:26:53,690
membezakan dengan tepat apa yang bermakna.

1732
01:26:53,690 --> 01:26:56,520
>> Jadi, jika saya pergi ke CS50 IDE
di sini, saya telah pergi ke hadapan

1733
01:26:56,520 --> 01:27:01,840
dan diisytiharkan dalam fail yang dipanggil
argv0.c template berikut.

1734
01:27:01,840 --> 01:27:04,120
Dan perhatikan satu-satunya perkara
itu berbeza setakat ini

1735
01:27:04,120 --> 01:27:08,570
adalah bahawa saya telah mengubah terbatal int
argc tali argv kurungan terbuka, berhampiran

1736
01:27:08,570 --> 01:27:09,070
kurungan.

1737
01:27:09,070 --> 01:27:11,730
Dan notis buat masa ini, ada
apa-apa dalam orang-orang kurungan.

1738
01:27:11,730 --> 01:27:12,620
>> Tidak ada nombor.

1739
01:27:12,620 --> 01:27:15,070
Dan tidak ada i, atau
n, atau apa-apa surat yang lain.

1740
01:27:15,070 --> 01:27:17,010
Saya hanya menggunakan
tanda kurung siku buat masa ini,

1741
01:27:17,010 --> 01:27:19,510
atas sebab-sebab kami akan datang
kembali ke dalam hanya seketika.

1742
01:27:19,510 --> 01:27:21,330
>> Dan sekarang apa yang saya akan lakukan ialah ini.

1743
01:27:21,330 --> 01:27:26,680
Jika argc sama sama 2--
dan ingat bahawa sama sama

1744
01:27:26,680 --> 01:27:30,040
adalah pengendali kesamaan membandingkan
kiri dan kanan untuk kesaksamaan.

1745
01:27:30,040 --> 01:27:31,790
Ia bukan tugasan
pengendali, yang

1746
01:27:31,790 --> 01:27:36,510
tanda sama tunggal, yang bermaksud salinan
dari kanan ke kiri beberapa nilai.

1747
01:27:36,510 --> 01:27:42,840
>> Jika argc bersamaan bersamaan 2, saya mahu
berkata, printf, hello, peratus, barisan baru,

1748
01:27:42,840 --> 01:27:47,340
dan kemudian palam dalam- dan di sini baru
trick-- argv kurungan 1, atas alasan

1749
01:27:47,340 --> 01:27:48,840
bahawa kita akan kembali ke dalam seketika.

1750
01:27:48,840 --> 01:27:52,110
Lain jika argc tidak
sama 2, anda tahu apa?

1751
01:27:52,110 --> 01:27:57,400
Mari kita pergi ke hadapan dan, seperti biasa, cetak
keluar hello dunia tanpa penggantian.

1752
01:27:57,400 --> 01:28:02,710
>> Jadi ia akan kelihatan seolah-olah jika argc, yang
bermaksud kiraan hujah, bersamaan 2,

1753
01:28:02,710 --> 01:28:04,740
Saya akan mencetak
hello sesuatu atau lain-lain.

1754
01:28:04,740 --> 01:28:07,560
Jika tidak, secara lalai, Saya
akan mencetak hello dunia.

1755
01:28:07,560 --> 01:28:08,770
Jadi apa maknanya?

1756
01:28:08,770 --> 01:28:15,550
>> Baiklah, biar saya pergi ke hadapan dan menyimpan
fail ini, dan kemudian melakukan make argv0,

1757
01:28:15,550 --> 01:28:18,940
dan kemudian ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Dan ia berkata hello dunia.

1759
01:28:20,300 --> 01:28:21,260
Sekarang, mengapa?

1760
01:28:21,260 --> 01:28:24,730
>> Nah, ternyata bila-bila masa anda
menjalankan program pada baris arahan,

1761
01:28:24,730 --> 01:28:29,570
anda mengisi dalam apa yang kita akan
umumnya panggil vektor hujah.

1762
01:28:29,570 --> 01:28:33,100
Dengan kata lain, secara automatik
komputer, sistem operasi,

1763
01:28:33,100 --> 01:28:38,340
akan menyerahkan kepada program anda
sendiri senarai semua perkataan

1764
01:28:38,340 --> 01:28:40,850
bahawa manusia yang ditaip di
segera, dalam kes anda

1765
01:28:40,850 --> 01:28:43,790
programmer menghendaki hal
sesuatu dengan maklumat tersebut.

1766
01:28:43,790 --> 01:28:48,540
Dan dalam kes ini, satu-satunya perkataan
Saya telah ditaip di prompt adalah ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Dan supaya bilangan hujah yang
yang diluluskan untuk program saya adalah hanya satu.

1768
01:28:55,420 --> 01:28:58,880
Dalam erti kata lain, hujah
mengira, atau dikenali sebagai argc

1769
01:28:58,880 --> 01:29:00,970
di sini sebagai integer, adalah hanya satu.

1770
01:29:00,970 --> 01:29:03,000
Satu, sudah tentu, tidak sama dua.

1771
01:29:03,000 --> 01:29:05,980
Dan hal ini adalah apa yang mencetak, hello dunia.

1772
01:29:05,980 --> 01:29:08,170
>> Tetapi biarlah saya mengambil tempat ini.

1773
01:29:08,170 --> 01:29:09,930
Biar saya katakan, argv0.

1774
01:29:09,930 --> 01:29:12,740
Dan maka bagaimana dengan Maria?

1775
01:29:12,740 --> 01:29:14,990
Dan kemudian tekan Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Dan perhatikan apa yang ajaib berlaku di sini.

1777
01:29:18,020 --> 01:29:22,640
Sekarang, bukan dunia hello, saya mempunyai
mengubah tingkah laku program ini

1778
01:29:22,640 --> 01:29:26,310
dengan mengambil input yang bukan dari get
tali atau beberapa fungsi lain,

1779
01:29:26,310 --> 01:29:30,570
tetapi dari, nampaknya, arahan saya
sendiri, apa yang saya asalnya ditaip.

1780
01:29:30,570 --> 01:29:35,720
Dan saya boleh bermain permainan ini sekali lagi dengan
menukar kepada Stelios, misalnya.

1781
01:29:35,720 --> 01:29:38,400
>> Dan sekarang saya dapat melihat nama lagi yang masih.

1782
01:29:38,400 --> 01:29:40,540
Dan di sini, saya mungkin berkata Andi.

1783
01:29:40,540 --> 01:29:42,137
Dan saya mungkin berkata Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Dan kita boleh bermain permainan ini sepanjang hari,
hanya memasang dalam nilai-nilai yang berbeza,

1785
01:29:45,220 --> 01:29:49,550
selagi aku menyediakan tepat
dua perkataan di segera,

1786
01:29:49,550 --> 01:29:52,260
seperti yang argc, hujah saya mengira, ialah 2.

1787
01:29:52,260 --> 01:29:57,240
>> Adakah saya melihat bahawa nama dipasang ke dalam
printf, setiap keadaan ini di sini?

1788
01:29:57,240 --> 01:30:00,550
Oleh itu, kita seolah-olah mempunyai sekarang
keupayaan ekspresif

1789
01:30:00,550 --> 01:30:04,410
mengambil input daripada mekanisme lain,
daripada baris arahan yang dipanggil,

1790
01:30:04,410 --> 01:30:07,000
bukannya perlu menunggu
sehingga pengguna menjalankan program ini,

1791
01:30:07,000 --> 01:30:10,220
dan kemudian meminta dia atau dia
menggunakan sesuatu seperti mendapatkan tali.

1792
01:30:10,220 --> 01:30:11,230
>> Jadi apa ini?

1793
01:30:11,230 --> 01:30:15,010
Argc, sekali lagi, hanya integer,
bilangan words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
bahawa pengguna disediakan di
segera, di tingkap terminal,

1795
01:30:18,540 --> 01:30:20,110
termasuk nama program.

1796
01:30:20,110 --> 01:30:23,340
Jadi ./argv0 kita, berkesan,
nama program ini,

1797
01:30:23,340 --> 01:30:24,520
atau bagaimana saya menjalankan program ini.

1798
01:30:24,520 --> 01:30:25,810
>> Yang dikira sebagai satu perkataan.

1799
01:30:25,810 --> 01:30:27,080
Jadi argc akan menjadi 1.

1800
01:30:27,080 --> 01:30:29,750
Tetapi apabila saya menulis Stelios, atau
Andi, atau Zamyla, atau Maria,

1801
01:30:29,750 --> 01:30:31,660
yang bermaksud kiraan hujah adalah dua.

1802
01:30:31,660 --> 01:30:33,910
Dan sekarang ada dua perkataan yang diluluskan pada.

1803
01:30:33,910 --> 01:30:36,070
>> Dan notis, kita boleh terus logik ini.

1804
01:30:36,070 --> 01:30:39,050
Jika saya benar-benar mengatakan
sesuatu seperti Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
nama penuh, sekali gus lulus
tiga hujah dalam jumlah,

1806
01:30:42,200 --> 01:30:47,410
kini ia berkata lalai lagi,
kerana, sudah tentu, 3 tidak sama 2.

1807
01:30:47,410 --> 01:30:54,080
>> Jadi dengan cara ini, adakah saya perlu
akses melalui argv hujah baru ini

1808
01:30:54,080 --> 01:30:56,080
yang kita dapat dari segi teknikal
memanggil apa-apa yang kita mahu.

1809
01:30:56,080 --> 01:30:58,940
Tetapi oleh konvensyen, ia
argv dan argc, masing-masing.

1810
01:30:58,940 --> 01:31:04,470
Argv, hujah vektor, adalah jenis
satu sinonim untuk pengaturcaraan

1811
01:31:04,470 --> 01:31:07,140
ciri dalam C dipanggil array.

1812
01:31:07,140 --> 01:31:14,410
>> Pelbagai adalah senarai nilai sama
belakang, ke belakang, ke belakang, ke belakang.

1813
01:31:14,410 --> 01:31:17,810
Dalam erti kata lain, jika seseorang adalah di sini di
RAM, yang seterusnya adalah betul-betul bersebelahan kepadanya,

1814
01:31:17,810 --> 01:31:18,800
dan kanan sebelahnya.

1815
01:31:18,800 --> 01:31:20,101
Mereka tidak di seluruh tempat.

1816
01:31:20,101 --> 01:31:23,100
Dan bahawa senario kedua, mana perkara-perkara
berada di seluruh tempat dalam ingatan,

1817
01:31:23,100 --> 01:31:25,082
sebenarnya boleh menjadi ciri yang kuat.

1818
01:31:25,082 --> 01:31:28,040
Tetapi kita akan kembali kepada itu apabila kita
bercakap mengenai struktur data pelamun.

1819
01:31:28,040 --> 01:31:32,260
Buat masa ini, array hanya
sebahagian memori berdampingan,

1820
01:31:32,260 --> 01:31:36,520
setiap yang unsur-unsur yang
belakang, ke belakang, ke belakang, ke belakang,

1821
01:31:36,520 --> 01:31:38,050
dan secara amnya jenis yang sama.

1822
01:31:38,050 --> 01:31:42,630
>> Jadi, jika anda berfikir tentang, dari
masa lalu, apa yang rentetan?

1823
01:31:42,630 --> 01:31:50,460
Well, tali, seperti Zamyla,
Z-A-M-Y-L-A, adalah, dari segi teknikal,

1824
01:31:50,460 --> 01:31:51,400
hanya pelbagai.

1825
01:31:51,400 --> 01:31:53,700
Ia adalah pelbagai watak.

1826
01:31:53,700 --> 01:31:59,250
>> Dan jadi jika kita benar-benar menarik, kerana saya
lakukan sebelum ini, sebagai sebahagian memori,

1827
01:31:59,250 --> 01:32:04,510
ternyata bahawa setiap
Watak mengambil satu bait.

1828
01:32:04,510 --> 01:32:07,630
Dan kemudian ada yang istimewa
sentinel watak, garis sendeng terbalik 0,

1829
01:32:07,630 --> 01:32:12,360
atau lapan 0 bit, yang
demarcates akhir tali itu.

1830
01:32:12,360 --> 01:32:15,090
Jadi rentetan, ternyata
keluar, memetik tali unquote,

1831
01:32:15,090 --> 01:32:20,580
adalah hanya pelbagai chara--
char yang jenis data yang sebenar.

1832
01:32:20,580 --> 01:32:24,560
>> Dan sekarang argv, meanwhile--
mari kita kembali kepada program ini.

1833
01:32:24,560 --> 01:32:29,582
Argv, walaupun kita melihat perkataan
string di sini, tidak adalah rentetan sendiri.

1834
01:32:29,582 --> 01:32:33,640
Argv, hujah vektor,
adalah pelbagai tali.

1835
01:32:33,640 --> 01:32:37,620
>> Jadi hanya kerana anda boleh mempunyai pelbagai
aksara, anda boleh mempunyai tahap yang lebih tinggi,

1836
01:32:37,620 --> 01:32:46,279
pelbagai strings-- jadi, misalnya,
apabila saya menaip sebentar tadi ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, ruang Z-A-M-Y-L-A, saya mendakwa
argv mempunyai dua tali di ./argv0 it--,

1838
01:33:00,150 --> 01:33:03,185
dan Z-A-M-Y-L-A. dalam
erti kata lain, argc adalah 2.

1839
01:33:03,185 --> 01:33:03,980
Kenapa begitu?

1840
01:33:03,980 --> 01:33:08,370
>> Well, berkesan, apa yang berlaku
pada adalah bahawa setiap rentetan ini

1841
01:33:08,370 --> 01:33:13,990
adalah, sudah tentu, pelbagai watak
seperti sebelum ini, setiap yang watak-watak

1842
01:33:13,990 --> 01:33:15,670
mengambil satu bait.

1843
01:33:15,670 --> 01:33:19,720
Dan tidak mengelirukan 0 sebenar
nama program ini dengan 0,

1844
01:33:19,720 --> 01:33:22,040
yang bermaksud semua 80 bit.

1845
01:33:22,040 --> 01:33:27,140
Dan Zamyla, sementara itu, masih
juga pelbagai watak.

1846
01:33:27,140 --> 01:33:31,450
>> Jadi, pada akhir hari, ia benar-benar
kelihatan seperti ini di bawah hood.

1847
01:33:31,450 --> 01:33:38,800
Tetapi argv, dengan sifat bagaimana utama
kerja-kerja, membolehkan saya untuk membalut semua ini

1848
01:33:38,800 --> 01:33:44,810
ke dalam, jika anda akan, pelbagai yang lebih besar
bahawa, jika kita sedikit lebih memudahkan

1849
01:33:44,810 --> 01:33:48,180
apa gambar kelihatan seperti dan tidak
agak menarik ia untuk meningkatkan sana,

1850
01:33:48,180 --> 01:33:56,720
pelbagai ini hanya saiz 2, yang pertama
unsur yang mengandungi rentetan,

1851
01:33:56,720 --> 01:33:59,230
elemen kedua
yang mengandungi rentetan.

1852
01:33:59,230 --> 01:34:01,687
Dan, seterusnya, jika anda
jenis mengezum masuk pada setiap

1853
01:34:01,687 --> 01:34:03,770
mereka tali, apa yang anda
melihat di bawah hood

1854
01:34:03,770 --> 01:34:07,190
adalah bahawa setiap rentetan hanya
pelbagai watak.

1855
01:34:07,190 --> 01:34:11,680
>> Sekarang, sama seperti dengan tali,
kita mampu untuk mendapatkan akses

1856
01:34:11,680 --> 01:34:15,260
kepada watak i-ke-dalam rentetan
menggunakan bahawa notasi kurungan persegi.

1857
01:34:15,260 --> 01:34:17,320
Begitu juga, dengan pameran
secara umum, boleh kita

1858
01:34:17,320 --> 01:34:22,700
menggunakan persegi notasi kurungan untuk mendapatkan
di mana-mana beberapa rentetan dalam array?

1859
01:34:22,700 --> 01:34:25,100
Sebagai contoh, mari saya
teruskan niat ini.

1860
01:34:25,100 --> 01:34:32,420
>> Biar saya pergi ke hadapan dan mencipta argv1.c,
yang sedikit berbeza kali ini.

1861
01:34:32,420 --> 01:34:35,635
Daripada memeriksa argc2,
Saya akan sebaliknya melakukan ini.

1862
01:34:35,635 --> 01:34:41,270
Untuk int saya mendapat 0, saya kurang
daripada argc, saya plus plus,

1863
01:34:41,270 --> 01:34:47,920
dan kemudian mencetak di dalam ini,
peratus s, barisan baru, dan kemudian

1864
01:34:47,920 --> 01:34:50,740
argv kurungan i.

1865
01:34:50,740 --> 01:34:55,220
>> Jadi dalam erti kata lain, saya tidak berurusan dengan
watak individu pada masa ini.

1866
01:34:55,220 --> 01:35:00,190
Argv, seperti yang dibayangkan oleh ini persegi kosong
pendakap di sebelah kanan argv nama,

1867
01:35:00,190 --> 01:35:03,320
bermakna argv adalah pelbagai tali.

1868
01:35:03,320 --> 01:35:04,870
Dan argc hanya int.

1869
01:35:04,870 --> 01:35:08,800
>> garis ini di sini, 6,
berkata set i sama dengan 0.

1870
01:35:08,800 --> 01:35:11,980
Kira semua jalan sehingga,
tetapi tidak termasuk, argc.

1871
01:35:11,980 --> 01:35:14,010
Dan kemudian pada setiap lelaran,
mencetak rentetan.

1872
01:35:14,010 --> 01:35:14,800
Apa rentetan?

1873
01:35:14,800 --> 01:35:17,270
>> Rentetan i-ke-dalam argv.

1874
01:35:17,270 --> 01:35:19,530
Jadi sedangkan sebelum saya
menggunakan kurungan persegi

1875
01:35:19,530 --> 01:35:22,180
notasi untuk mendapatkan sekurang-i
watak dalam rentetan, sekarang

1876
01:35:22,180 --> 01:35:27,240
Saya menggunakan notasi persegi kurungan
untuk mendapatkan sekurang-string engan dalam array.

1877
01:35:27,240 --> 01:35:30,310
Jadi ia adalah jenis satu lapisan
di atas, dari segi konsep.

1878
01:35:30,310 --> 01:35:35,390
>> Dan supaya apa yang kemas mengenai ini
program sekarang, jika saya menyusun argv1,

1879
01:35:35,390 --> 01:35:42,067
dan kemudian melakukan ./argv1, dan kemudian taip
dalam sesuatu seperti foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
yang merupakan tiga perkataan lalai bahawa
saintis komputer sampai untuk bila-bila masa

1881
01:35:45,400 --> 01:35:51,010
dia perlu beberapa perkataan pemegang tempat,
dan tekan Enter, setiap kata-kata,

1882
01:35:51,010 --> 01:35:54,980
termasuk nama program, yang
di argv di lokasi pertama,

1883
01:35:54,980 --> 01:35:58,320
berakhir yang dicetak satu demi satu.

1884
01:35:58,320 --> 01:36:05,290
Dan jika saya menukar ini, dan saya katakan
sesuatu seperti argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
kita akan mendapat semua tiga daripada
kata-kata, yang argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, kerana dalam ini
kes argc, kiraan, ialah 3.

1887
01:36:14,400 --> 01:36:20,020
>> Tetapi apa yang kemas jika anda memahami
argv yang hanya pelbagai rentetan,

1888
01:36:20,020 --> 01:36:24,910
dan anda memahami bahawa rentetan
adalah pelbagai watak-watak,

1889
01:36:24,910 --> 01:36:29,470
kita boleh sebenarnya jenis menggunakan ini
persegi notasi kurungan beberapa kali

1890
01:36:29,470 --> 01:36:33,320
untuk memilih tali, dan kemudian pilih
watak dalam tali,

1891
01:36:33,320 --> 01:36:35,730
menyelam di lebih mendalam seperti berikut.

1892
01:36:35,730 --> 01:36:40,100
Dalam contoh ini, saya pergi
hadapan dan memanggil argv2.c ini.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Dan dalam contoh ini, biarlah saya pergi ke hadapan
dan melakukan following-- untuk int i mendapatkan 0,

1895
01:36:50,180 --> 01:36:53,286
i adalah kurang daripada argc, i plus
plus, sama seperti sebelum ini.

1896
01:36:53,286 --> 01:36:55,910
Jadi dalam words-- lain dan sekarang ini
mendapat susu yang cukup rumit.

1897
01:36:55,910 --> 01:36:59,940
Kemudian saya akan berkata
melelar atas tali dalam argv,

1898
01:36:59,940 --> 01:37:01,294
sebagai komen kepada diri saya sendiri.

1899
01:37:01,294 --> 01:37:03,960
Dan kemudian saya akan mempunyai
bersarang untuk gelung, yang anda mungkin

1900
01:37:03,960 --> 01:37:06,290
telah dilakukan, atau dianggap
lakukan, dalam Scratch, di mana

1901
01:37:06,290 --> 01:37:08,600
Saya akan mengatakan int-- Saya
tidak akan menggunakan i lagi,

1902
01:37:08,600 --> 01:37:12,590
kerana saya tidak mahu bayangan, atau
semacam menimpa i yang sedia ada.

1903
01:37:12,590 --> 01:37:15,780
>> Saya akan, sebaliknya, berkata j, kerana
itulah go saya untuk berubah selepas i,

1904
01:37:15,780 --> 01:37:18,590
apabila saya hanya cuba untuk
mengira nombor mudah.

1905
01:37:18,590 --> 01:37:28,850
Untuk j mendapat 0-- dan juga, n, akan
mendapatkan panjang buritan kurungan argv i,

1906
01:37:28,850 --> 01:37:36,030
selagi j kurang daripada m,
j plus plus, lakukan yang berikut.

1907
01:37:36,030 --> 01:37:37,500
Dan di sini adalah bahagian yang menarik.

1908
01:37:37,500 --> 01:37:46,330
>> Mencetak watak dan barisan baru,
memasang pendakap argv i, kurungan j.

1909
01:37:46,330 --> 01:37:47,940
OK, jadi biarlah saya menambah beberapa komen di sini.

1910
01:37:47,940 --> 01:37:54,820
Melelar aksara
dalam rentetan semasa,

1911
01:37:54,820 --> 01:38:02,290
cetak watak j-ke dalam rentetan i-ke.

1912
01:38:02,290 --> 01:38:04,630
Oleh sebab itu, mari kita mempertimbangkan
apa komen-komen ini maksudkan.

1913
01:38:04,630 --> 01:38:06,750
>> Melelar atas tali
dalam argv-- berapa banyak

1914
01:38:06,750 --> 01:38:09,300
rentetan dalam argv, yang array?

1915
01:38:09,300 --> 01:38:13,420
Argc banyak, jadi saya iterating
dari i menyamai 0 sehingga argc.

1916
01:38:13,420 --> 01:38:20,020
Sementara itu, berapa banyak aksara
adalah dalam rentetan i-ke-dalam argv?

1917
01:38:20,020 --> 01:38:22,880
>> Nah, untuk mendapatkan jawapan itu,
Saya hanya memanggil panjang tali

1918
01:38:22,880 --> 01:38:26,810
pada penjagaan saya rentetan semasa
kira-kira, yang kurungan argv i.

1919
01:38:26,810 --> 01:38:30,090
Dan saya akan menyimpan buat sementara waktu yang
menghargai dalam n, hanya untuk tujuan caching,

1920
01:38:30,090 --> 01:38:31,590
ingat untuk kecekapan.

1921
01:38:31,590 --> 01:38:36,330
Dan kemudian saya akan memulakan j kepada 0,
terus pergi selagi j kurang daripada n,

1922
01:38:36,330 --> 01:38:38,430
dan pada setiap lelaran j kenaikan.

1923
01:38:38,430 --> 01:38:41,030
>> Dan kemudian di sini, semalam
komen saya pada baris 12,

1924
01:38:41,030 --> 01:38:43,390
mencetak watak,
diikuti oleh barisan baru,

1925
01:38:43,390 --> 01:38:48,140
pendakap khusus argv
i memberikan saya rentetan i-ke-

1926
01:38:48,140 --> 01:38:51,690
dalam argv-- jadi perkataan yang pertama,
Perkataan kedua, perkataan ketiga, apa sahaja.

1927
01:38:51,690 --> 01:38:57,370
Dan kemudian selaman j dalam lebih mendalam, dan mendapat
saya watak j-ke-perkataan itu.

1928
01:38:57,370 --> 01:39:02,200
Dan sebagainya, pada hakikatnya, anda boleh merawat
argv sebagai pelbagai dimensi,

1929
01:39:02,200 --> 01:39:06,050
sebagai dua dimensi, pelbagai,
di mana setiap jenis perkataan kelihatan

1930
01:39:06,050 --> 01:39:08,580
seperti ini dalam fikiran anda
mata, dan setiap watak

1931
01:39:08,580 --> 01:39:10,930
adalah jenis terdiri dalam
lajur, jika yang membantu.

1932
01:39:10,930 --> 01:39:13,260
>> Pada hakikatnya, apabila kita mengusik
ini selain dalam beberapa minggu akan datang,

1933
01:39:13,260 --> 01:39:15,580
ia akan menjadi sedikit
lebih canggih daripada itu.

1934
01:39:15,580 --> 01:39:17,800
Tetapi anda boleh benar-benar
berfikir itu, buat masa ini,

1935
01:39:17,800 --> 01:39:22,110
kerana hanya ini dua dimensi
pelbagai, di mana satu tahap ia

1936
01:39:22,110 --> 01:39:23,260
adalah semua daripada tali-tali.

1937
01:39:23,260 --> 01:39:26,760
Dan kemudian jika anda menyelam lebih mendalam, anda
boleh mendapatkan pada watak-watak individu

1938
01:39:26,760 --> 01:39:29,600
Di surga itu dengan menggunakan notasi ini di sini.

1939
01:39:29,600 --> 01:39:31,620
>> Jadi apa kesan bersih?

1940
01:39:31,620 --> 01:39:34,970
Biar saya pergi ke hadapan dan
membuat darn argv2-- ia.

1941
01:39:34,970 --> 01:39:36,210
Saya telah membuat kesilapan di sini.

1942
01:39:36,210 --> 01:39:40,160
Tersirat mengisytiharkan
perpustakaan fungsi stirling.

1943
01:39:40,160 --> 01:39:42,190
Jadi selama ini, ia
mungkin sesuai

1944
01:39:42,190 --> 01:39:45,130
bahawa kita jenis kemasan
tepat di mana kita bermula.

1945
01:39:45,130 --> 01:39:48,160
>> Saya diskru, tersirat mengisytiharkan
perpustakaan fungsi stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, tunggu satu minit.

1947
01:39:48,987 --> 01:39:51,070
Saya masih ingat bahawa, terutama
kerana ia adalah di sini.

1948
01:39:51,070 --> 01:39:54,490
Saya perlu untuk memasukkan string.h dalam
versi program ini.

1949
01:39:54,490 --> 01:40:00,050
>> Biar saya pergi ke hadapan dan termasuk
string.h, kecuali bahawa, teruskan

1950
01:40:00,050 --> 01:40:04,460
dan susun semula argv2.

1951
01:40:04,460 --> 01:40:08,390
Dan sekarang, di sini kita pergi, membuat argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Dan walaupun ia sedikit
samar pada pandangan pertama,

1953
01:40:10,590 --> 01:40:15,690
perhatian bahawa, sesungguhnya, apa yang
dicetak adalah argv2 dot.

1954
01:40:15,690 --> 01:40:19,970
>> Tetapi jika saya menaip beberapa perkataan selepas
segera, seperti argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Enter, juga sedikit
samar pada pandangan pertama.

1956
01:40:22,560 --> 01:40:30,540
Tetapi jika kita tatal kembali ke atas,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Oleh itu, kita telah terlelar atas setiap perkataan.

1958
01:40:32,190 --> 01:40:37,770
Dan, seterusnya, kami telah terlelar lebih
setiap watak dalam perkataan.

1959
01:40:37,770 --> 01:40:40,040
>> Kini, selepas semua ini,
sedar bahawa ada

1960
01:40:40,040 --> 01:40:43,120
satu terperinci lain yang kami telah jenis
mengabaikan masa ini keseluruhan.

1961
01:40:43,120 --> 01:40:46,180
Kami hanya mengusik selain apa
input utama yang boleh?

1962
01:40:46,180 --> 01:40:47,780
Bagaimana pula dengan output utama ini?

1963
01:40:47,780 --> 01:40:50,540
>> Semua masa ini, kami telah
hanya menyalin dan menampal

1964
01:40:50,540 --> 01:40:53,870
int perkataan di hadapan utama,
walaupun anda boleh melihat dalam talian,

1965
01:40:53,870 --> 01:40:58,340
kadang-kadang salah dalam versi yang lebih lama
C dan penyusun, bahawa mereka mengatakan tidak sah,

1966
01:40:58,340 --> 01:40:59,410
atau apa-apa.

1967
01:40:59,410 --> 01:41:01,580
Tetapi, sesungguhnya, untuk versi
C yang kita gunakan,

1968
01:41:01,580 --> 01:41:06,180
C 11, atau 2011, menyedari
bahawa ia harus int.

1969
01:41:06,180 --> 01:41:09,300
Dan sama ada perlu
tidak sah atau argc dan argv sini.

1970
01:41:09,300 --> 01:41:10,790
>> Tetapi mengapa int utama?

1971
01:41:10,790 --> 01:41:12,480
Apa yang ia benar-benar kembali?

1972
01:41:12,480 --> 01:41:16,280
Nah, ternyata semua masa ini,
bila-bila masa anda menulis utama program

1973
01:41:16,280 --> 01:41:18,440
sentiasa kembali sesuatu.

1974
01:41:18,440 --> 01:41:19,960
Tetapi ada pihak yang berbuat demikian secara rahsia.

1975
01:41:19,960 --> 01:41:23,350
>> sesuatu yang merupakan
int, sebagai garis 5 mencadangkan.

1976
01:41:23,350 --> 01:41:24,225
Tetapi apa int?

1977
01:41:24,225 --> 01:41:26,100
Nah, ada ini
konvensyen dalam pengaturcaraan,

1978
01:41:26,100 --> 01:41:29,790
di mana jika tiada mempunyai
silapnya dan semuanya berjalan dengan lancar,

1979
01:41:29,790 --> 01:41:34,250
program dan fungsi umumnya
return-- agak counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 umumnya menandakan semuanya berjalan dengan lancar.

1982
01:41:38,070 --> 01:41:40,610
Jadi, walaupun anda fikirkan
sebagai salah di dalam berbagai konteks,

1983
01:41:40,610 --> 01:41:42,930
ia sebenarnya secara amnya bermaksud satu perkara yang baik

1984
01:41:42,930 --> 01:41:49,560
>> Sementara itu, jika program kembali 1,
atau negatif 1, atau 5, atau negatif 42,

1985
01:41:49,560 --> 01:41:52,941
atau mana-mana bukan 0 nilai,
yang biasanya melambangkan

1986
01:41:52,941 --> 01:41:54,190
sesuatu yang telah berlaku.

1987
01:41:54,190 --> 01:41:56,700
Malah, pada Mac anda sendiri atau PC,
anda telah benar-benar melihat

1988
01:41:56,700 --> 01:42:01,050
mesej ralat, di mana ia
mengatakan sesuatu atau lain-lain, kesilapan

1989
01:42:01,050 --> 01:42:04,940
kod negatif 42, atau kod ralat
23, atau sesuatu seperti itu.

1990
01:42:04,940 --> 01:42:08,980
Jumlah itu biasanya hanya petunjuk
kepada pengaturcara, atau syarikat

1991
01:42:08,980 --> 01:42:11,174
yang membuat perisian,
apa yang salah dan mengapa,

1992
01:42:11,174 --> 01:42:13,590
supaya mereka dapat melihat melalui
dokumentasi atau kod mereka,

1993
01:42:13,590 --> 01:42:15,465
dan memikirkan apa yang
ralat sebenarnya bermaksud.

1994
01:42:15,465 --> 01:42:18,400
Ia biasanya tidak
berguna kepada kita pengguna akhir.

1995
01:42:18,400 --> 01:42:20,550
>> Tetapi apabila pulangan utama 0, semuanya berjalan dengan lancar.

1996
01:42:20,550 --> 01:42:23,770
Dan jika anda tidak menentukan
apa yang utama perlu kembali,

1997
01:42:23,770 --> 01:42:26,950
ia akan hanya secara automatik
kembali 0 untuk anda.

1998
01:42:26,950 --> 01:42:30,870
Tetapi dengan kembali sesuatu
lagi yang sebenarnya berguna.

1999
01:42:30,870 --> 01:42:34,660
>> Dalam program akhir ini, biarlah saya
pergi ke depan dan memanggil exit.c ini,

2000
01:42:34,660 --> 01:42:38,630
dan memperkenalkan terakhir hari ini
topik, yang dikenali sebagai kod ralat.

2001
01:42:38,630 --> 01:42:42,930
Biar saya pergi ke hadapan dan memasukkan kami
fail biasa sehingga atas, melakukan int utama.

2002
01:42:42,930 --> 01:42:49,500
Dan kali ini, mari kita buat int argc,
tali argv, dan dengan kurungan saya

2003
01:42:49,500 --> 01:42:50,836
membayangkan bahawa itu dalam array.

2004
01:42:50,836 --> 01:42:52,460
Dan kemudian biar saya buat cek kewarasan.

2005
01:42:52,460 --> 01:42:56,640
Kali ini, jika argc tidak
sama 2, maka anda tahu apa?

2006
01:42:56,640 --> 01:42:57,520
Lupakan ia.

2007
01:42:57,520 --> 01:43:03,170
Saya akan mengatakan bahawa, hey, pengguna,
anda telah hilang baris arahan hujah

2008
01:43:03,170 --> 01:43:04,210
n garis sendeng terbalik.

2009
01:43:04,210 --> 01:43:05,230
>> Dan kemudian itu sahaja.

2010
01:43:05,230 --> 01:43:06,130
Saya mahu keluar.

2011
01:43:06,130 --> 01:43:11,030
Saya akan preemptively,
dan awal benar-benar, pulangan

2012
01:43:11,030 --> 01:43:12,810
sesuatu yang lain daripada nombor 1.

2013
01:43:12,810 --> 01:43:15,360
Go untuk nilai untuk pertama
ralat yang boleh berlaku ialah 1.

2014
01:43:15,360 --> 01:43:17,860
Jika anda mempunyai beberapa lain yang salah
keadaan yang mungkin berlaku,

2015
01:43:17,860 --> 01:43:21,390
anda mungkin berkata pulangan 2 atau kembali 3, atau
mungkin juga negatif 1 atau negatif 2.

2016
01:43:21,390 --> 01:43:23,750
>> Ini hanya kod keluar
yang, secara amnya,

2017
01:43:23,750 --> 01:43:27,770
hanya berguna untuk pengaturcara, atau
syarikat yang yang penghantaran perisian.

2018
01:43:27,770 --> 01:43:30,500
Tetapi hakikat bahawa ia
tidak 0 adalah apa yang penting.

2019
01:43:30,500 --> 01:43:34,310
Jadi, jika program ini, saya mahu
menjamin bahawa program ini hanya

2020
01:43:34,310 --> 01:43:38,190
berfungsi jika pengguna menyediakan saya
dengan kiraan hujah dua,

2021
01:43:38,190 --> 01:43:42,880
nama program ini, dan beberapa yang lain
perkataan, saya boleh menguatkuasakan sebanyak berikut,

2022
01:43:42,880 --> 01:43:46,110
menjerit pada pengguna dengan printf pepatah,
hilang baris arahan hujah,

2023
01:43:46,110 --> 01:43:46,970
kembali 1.

2024
01:43:46,970 --> 01:43:49,940
Yang akan hanya segera
berhenti program.

2025
01:43:49,940 --> 01:43:55,840
>> Hanya jika argc bersamaan 2 kita akan turun
di sini, di mana titik saya akan berkata,

2026
01:43:55,840 --> 01:44:00,410
hello peratus s, garis sendeng terbalik n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Dalam erti kata lain, saya
tidak akan selepas argv 0,

2028
01:44:03,827 --> 01:44:05,410
yang hanya nama program.

2029
01:44:05,410 --> 01:44:09,450
Saya hendak mencetak hello, koma,
perkataan kedua yang manusia ditaip.

2030
01:44:09,450 --> 01:44:12,580
Dan dalam kes ini di
line 13, semuanya berjalan dengan lancar.

2031
01:44:12,580 --> 01:44:15,920
>> Saya tahu bahawa argc adalah 2
secara logik dari program ini.

2032
01:44:15,920 --> 01:44:17,770
Saya akan pergi ke hadapan dan kembali 0.

2033
01:44:17,770 --> 01:44:21,230
Sebagai mengetepikan, perlu diingat bahawa
ini adalah benar dalam Scratch juga.

2034
01:44:21,230 --> 01:44:24,760
>> Secara logiknya, saya boleh melakukan ini
dan merangkumi ayat-ayat ini

2035
01:44:24,760 --> 01:44:27,020
kod dalam klausa pun ini di sini.

2036
01:44:27,020 --> 01:44:29,420
Tetapi itulah jenis
tidak perlu mengensotkannya kod saya.

2037
01:44:29,420 --> 01:44:31,800
Dan saya ingin super
jelas bahawa tidak kira apa,

2038
01:44:31,800 --> 01:44:34,670
secara lalai, hello
sesuatu yang akan mendapat dicetak,

2039
01:44:34,670 --> 01:44:36,050
selagi pengguna bekerjasama.

2040
01:44:36,050 --> 01:44:39,360
>> Jadi ia amat biasa untuk menggunakan
keadaan, hanya jika,

2041
01:44:39,360 --> 01:44:41,870
untuk menangkap beberapa salah
keadaan, dan kemudian keluar.

2042
01:44:41,870 --> 01:44:45,690
Dan kemudian, selagi semua adalah
baik, tidak mempunyai lagi,

2043
01:44:45,690 --> 01:44:48,060
tetapi hanya mempunyai kod
luar bahawa jika, kerana ia adalah

2044
01:44:48,060 --> 01:44:51,060
setara dalam ini
hal tertentu, secara logik.

2045
01:44:51,060 --> 01:44:54,480
Jadi saya kembali 0, hanya untuk
jelas menandakan semuanya berjalan dengan lancar.

2046
01:44:54,480 --> 01:44:58,480
>> Jika saya ditinggalkan pulangan 0, ia akan
secara automatik diandaikan untuk saya.

2047
01:44:58,480 --> 01:45:00,890
Tetapi sekarang bahawa saya kembali
satu dalam sekurang-kurangnya kes ini,

2048
01:45:00,890 --> 01:45:04,940
Saya akan, untuk menjadikannya lebih menarik dan
kejelasan, kembali 0 dalam kes ini.

2049
01:45:04,940 --> 01:45:09,690
Jadi sekarang mari saya pergi ke hadapan dan membuat keluar,
yang segue yang sempurna untuk hanya meninggalkan.

2050
01:45:09,690 --> 01:45:14,401
>> Tetapi membuat keluar, dan biarlah saya pergi
hadapan dan melakukan ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Dan program ini menjerit kepada saya,
hilang baris arahan hujah.

2052
01:45:16,900 --> 01:45:18,120
OK, saya bekerjasama.

2053
01:45:18,120 --> 01:45:23,810
>> Biar saya bukannya melakukan ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Dan kini ia berkata, hello David.

2055
01:45:25,190 --> 01:45:27,300
Dan anda biasanya tidak akan melihat ini.

2056
01:45:27,300 --> 01:45:30,650
>> Tetapi ternyata bahawa ada
cara yang khas dalam Linux untuk benar-benar melihat

2057
01:45:30,650 --> 01:45:34,470
dengan apa yang keluar kod program yang keluar.

2058
01:45:34,470 --> 01:45:37,184
Kadang-kadang dalam grafik yang
dunia seperti Mac OS atau Windows,

2059
01:45:37,184 --> 01:45:40,100
anda hanya melihat nombor-nombor ini apabila
mesej ralat muncul pada skrin

2060
01:45:40,100 --> 01:45:41,940
dan pengaturcara
menunjukkan anda nombor itu.

2061
01:45:41,940 --> 01:45:44,773
Tetapi jika kita mahu melihat apa kesilapan
mesej, kita boleh melakukannya sini--

2062
01:45:44,773 --> 01:45:48,100
supaya ./exit, Masukkan, cetak
hilang baris arahan hujah.

2063
01:45:48,100 --> 01:45:54,590
>> Jika saya kini melakukan $ echo ?, yang
sungguh samar mencari.

2064
01:45:54,590 --> 01:45:56,590
Tetapi $?

2065
01:45:56,590 --> 01:45:59,220
adalah mantera ajaib
yang mengatakan, hey, komputer,

2066
01:45:59,220 --> 01:46:01,900
beritahu saya apa yang sebelumnya
kod keluar program ini adalah.

2067
01:46:01,900 --> 01:46:03,410
Dan saya tekan Enter.

2068
01:46:03,410 --> 01:46:07,520
Saya lihat 1, kerana itulah yang saya
kepada fungsi utama saya untuk kembali.

2069
01:46:07,520 --> 01:46:12,310
>> Sementara itu, jika saya lakukan ./exit David,
dan tekan Enter, saya lihat, hello David.

2070
01:46:12,310 --> 01:46:16,800
Dan jika saya kini melakukan $ echo ?, saya melihat hello 0.

2071
01:46:16,800 --> 01:46:19,080
Dan sebagainya ini akan sebenarnya
menjadi maklumat berharga

2072
01:46:19,080 --> 01:46:23,420
dalam konteks penyahpepijat, tidak begitu
banyak yang anda, manusia, akan menjaga.

2073
01:46:23,420 --> 01:46:26,060
Tetapi penyahpepijat dan lain-lain
program kami akan menggunakan semester ini

2074
01:46:26,060 --> 01:46:29,420
sering akan melihat jumlah itu,
walaupun ia semacam disembunyikan

2075
01:46:29,420 --> 01:46:32,780
melainkan jika anda mencarinya, untuk
menentukan sama ada atau tidak program ini

2076
01:46:32,780 --> 01:46:37,050
pelaksanaan adalah betul atau tidak betul.

2077
01:46:37,050 --> 01:46:40,450
>> Dan supaya membawa kita kepada
ini, pada akhir hari.

2078
01:46:40,450 --> 01:46:43,917
Kami memulakan hari ini dengan melihat
debugging, dan seterusnya di padang

2079
01:46:43,917 --> 01:46:46,750
sendiri, dan kemudian lebih menarik lagi,
teknikal di bawah hood

2080
01:46:46,750 --> 01:46:49,490
apa rentetan, yang bertahan
minggu kita hanya mengambil untuk diberikan,

2081
01:46:49,490 --> 01:46:51,900
dan sudah tentu membawa mereka
untuk diberikan dalam Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Kami kemudian melihat bagaimana kita boleh mengakses
watak individu dalam rentetan,

2083
01:46:56,040 --> 01:47:00,310
dan kemudian sekali lagi mengambil tahap yang lebih tinggi
melihat perkara-perkara, melihat bagaimana well--

2084
01:47:00,310 --> 01:47:04,226
jika kita mahu untuk mendapatkan sekurang-individu
elemen dalam senarai seperti struktur,

2085
01:47:04,226 --> 01:47:05,850
kita tidak boleh berbuat demikian dengan pelbagai rentetan?

2086
01:47:05,850 --> 01:47:08,050
Dan kita boleh dengan hujah baris arahan.

2087
01:47:08,050 --> 01:47:12,800
Tetapi gambar ini di sini hanya kotak
demikian menggambarkan idea umum ini

2088
01:47:12,800 --> 01:47:14,451
daripada pelbagai, atau senarai, atau vektor.

2089
01:47:14,451 --> 01:47:16,450
Dan bergantung kepada
konteks, semua kata-kata ini

2090
01:47:16,450 --> 01:47:17,880
membawa maksud yang sedikit berbeza.

2091
01:47:17,880 --> 01:47:20,060
Jadi dalam C, kita hanya akan
untuk bercakap tentang array.

2092
01:47:20,060 --> 01:47:23,840
Dan array adalah sebahagian yang
memori, yang masing-masing yang

2093
01:47:23,840 --> 01:47:27,720
unsur-unsur yang berdampingan, belakang,
ke belakang, ke belakang, ke belakang.

2094
01:47:27,720 --> 01:47:31,970
>> Dan orang-elemen ini, secara amnya,
jenis data yang sama, watak,

2095
01:47:31,970 --> 01:47:35,966
watak, watak, watak, atau
tali, tali, tali, tali, atau int,

2096
01:47:35,966 --> 01:47:38,600
int, int, apa sahaja
kami cuba untuk menyimpan.

2097
01:47:38,600 --> 01:47:42,540
Tetapi pada akhir hari, ini adalah
apa yang kelihatan seperti konsep.

2098
01:47:42,540 --> 01:47:44,530
Anda mengambil anda
memori atau RAM komputer.

2099
01:47:44,530 --> 01:47:48,590
Dan anda ukiran ia keluar ke
peti sepercaman bersaiz, semua yang

2100
01:47:48,590 --> 01:47:50,920
kembali, ke belakang, ke
belakang, ke belakang dengan cara ini.

2101
01:47:50,920 --> 01:47:53,200
>> Dan apa yang baik tentang
idea ini, dan hakikat

2102
01:47:53,200 --> 01:47:58,580
yang kita boleh meluahkan nilai-nilai dengan cara ini
dengan yang pertama struktur data kami

2103
01:47:58,580 --> 01:48:02,520
dalam kelas, ertinya kita boleh mula
untuk menyelesaikan masalah dengan kod

2104
01:48:02,520 --> 01:48:04,079
yang datang begitu intuitif pada minggu 0.

2105
01:48:04,079 --> 01:48:05,870
Anda akan ingat telefon
contoh buku, di mana

2106
01:48:05,870 --> 01:48:09,110
kami menggunakan jurang dan menakluk,
atau algoritma carian binari,

2107
01:48:09,110 --> 01:48:13,220
untuk menapis melalui keseluruhannya
sekumpulan nama dan nombor.

2108
01:48:13,220 --> 01:48:18,220
Tetapi kita mengandaikan, ingat, bahawa
buku telefon telah sudah disusun,

2109
01:48:18,220 --> 01:48:21,630
bahawa orang lain telah pun
bercorak out-- diberikan satu senarai nama-nama

2110
01:48:21,630 --> 01:48:24,430
dan numbers-- bagaimana untuk mengikut abjad mereka.

2111
01:48:24,430 --> 01:48:26,950
Dan kini bahawa dalam C kita,
juga, mempunyai keupayaan

2112
01:48:26,950 --> 01:48:30,290
untuk meletakkan perkara keluar, tidak
fizikal dalam buku telefon

2113
01:48:30,290 --> 01:48:34,220
tetapi hampir dalam ini komputer
memori, kita akan dapat minggu depan

2114
01:48:34,220 --> 01:48:38,470
untuk memperkenalkan lagi this-- pertama
struktur data kami di array-- yang

2115
01:48:38,470 --> 01:48:43,530
tetapi yang lebih penting, komputer yang sebenar
algoritma sains dilaksanakan

2116
01:48:43,530 --> 01:48:47,720
kod, yang kita boleh menyimpan
data dalam struktur seperti ini,

2117
01:48:47,720 --> 01:48:50,730
dan kemudian mula untuk memanipulasi, dan
untuk benar-benar menyelesaikan masalah dengan itu,

2118
01:48:50,730 --> 01:48:53,570
dan untuk membina di atas itu,
akhirnya, program dalam C,

2119
01:48:53,570 --> 01:48:56,730
dalam Python, dalam JavaScript,
pertanyaan pangkalan data dengan SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Dan kita akan melihat bahawa semua ini
idea-idea yang berbeza interlock.

2121
01:48:59,980 --> 01:49:04,100
Tetapi untuk sekarang, ingat bahawa
domain yang diperkenalkan hari ini

2122
01:49:04,100 --> 01:49:06,920
adalah perkara ini di sini, dan
dunia kriptografi.

2123
01:49:06,920 --> 01:49:11,200
Dan antara masalah yang akan datang anda sendiri
akan menyelesaikan adalah seni kriptografi,

2124
01:49:11,200 --> 01:49:13,630
berebut dan de-berebut
maklumat, dan ciphering

2125
01:49:13,630 --> 01:49:15,930
dan mentafsir teks,
dan menganggap akhirnya

2126
01:49:15,930 --> 01:49:18,970
bahawa anda kini tahu apa yang
adalah di bawah hood

2127
01:49:18,970 --> 01:49:21,860
supaya apabila anda melihat atau menerima
mesej seperti ini, anda

2128
01:49:21,860 --> 01:49:24,060
sendiri boleh mentafsirkan ia.

2129
01:49:24,060 --> 01:49:26,740
Semua ini, dan lebih banyak masa akan datang.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO MAIN SEMULA]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Sahaja tiba.

2133
01:49:32,970 --> 01:49:35,146
Saya akan pergi ke lawatan
profesor kolej.

2134
01:49:35,146 --> 01:49:37,611
Yep.

2135
01:49:37,611 --> 01:49:40,080
Hi.

2136
01:49:40,080 --> 01:49:40,660
Ia anda.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Tunggu!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Saya hanya cuba untuk memikirkan
mengetahui apa yang berlaku kepada anda.

2142
01:49:56,060 --> 01:49:58,130
Sila, apa sahaja boleh membantu.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Anda berada di kolej
rakan sebilik, tidak anda?

2145
01:50:08,354 --> 01:50:10,770
Anda berada di sana dengan dia apabila
dia selesai projek CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUZIK Bermain]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Itu Adalah CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Saya suka tempat ini.

2152
01:50:44,770 --> 01:50:45,854
>> -Memakan.

2153
01:50:45,854 --> 01:50:47,020
Kami akan keluar dari perniagaan.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [AKHIR MAIN SEMULA]

