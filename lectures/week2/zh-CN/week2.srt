1
00:00:00,000 --> 00:00:02,970
>> [音乐]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN：好的。

4
00:00:15,700 --> 00:00:18,832
这是CS50这
2周的开始。

5
00:00:18,832 --> 00:00:21,040
你会记得，在
在过去的几个星期，

6
00:00:21,040 --> 00:00:24,490
我们已经引进电脑
科学和，反过来，编程。

7
00:00:24,490 --> 00:00:27,640
>> 我们依路开始的故事
从无到有，即图形语言

8
00:00:27,640 --> 00:00:28,990
来自麻省理工学院媒体实验室。

9
00:00:28,990 --> 00:00:30,780
然后最近一段时间，
上周，我们什么

10
00:00:30,780 --> 00:00:34,450
引入higher--一
较低级别的语言已知

11
00:00:34,450 --> 00:00:36,770
如C，一些纯粹的文字。

12
00:00:36,770 --> 00:00:39,440
而且，事实上，我们最后一次
该范围内探讨

13
00:00:39,440 --> 00:00:40,450
一些概念。

14
00:00:40,450 --> 00:00:43,010
>> 这一点，回忆，是非常
第一个节目，我们看着。

15
00:00:43,010 --> 00:00:45,710
而这个程序很简单，
打印出来，“你好，世界”。

16
00:00:45,710 --> 00:00:47,730
但有这么多
似乎魔术回事。

17
00:00:47,730 --> 00:00:51,460
有此#include
这些尖括号。

18
00:00:51,460 --> 00:00:52,170
有int类型。

19
00:00:52,170 --> 00:00:53,020
有（无效）。

20
00:00:53,020 --> 00:00:56,330
有括号，大括号，
分号，和这么多。

21
00:00:56,330 --> 00:00:58,480
>> 所以，记得
我们推出划痕

22
00:00:58,480 --> 00:01:02,110
这样我们就可以，理想情况下，看过去
该语法，那真的不是东西

23
00:01:02,110 --> 00:01:04,590
所有的理智
有趣的，但早

24
00:01:04,590 --> 00:01:07,700
是的，绝对的，有点棘手
来包装你的头脑周围。

25
00:01:07,700 --> 00:01:10,860
而且，事实上，最常见的一种
事情早在编程类，

26
00:01:10,860 --> 00:01:13,443
特别是对于那些不太
舒适，是让被挫败

27
00:01:13,443 --> 00:01:17,460
并绊倒了某些语法
错误，更不用说逻辑错误。

28
00:01:17,460 --> 00:01:19,800
所以我们的目标之一
今天，居然会

29
00:01:19,800 --> 00:01:23,280
与某些装备你
解决问题的技巧如何

30
00:01:23,280 --> 00:01:26,705
更好地解决自己的问题
在调试的形式。

31
00:01:26,705 --> 00:01:29,330
你会记得，这才明白，
我们引入了环境

32
00:01:29,330 --> 00:01:31,780
最后一次被称为CS50 IDE。

33
00:01:31,780 --> 00:01:34,850
这是基于网络的软件是
让你在云中进行编程，

34
00:01:34,850 --> 00:01:38,450
可以这么说，同时保持你的所有
文件一起，为我们再次将在今天。

35
00:01:38,450 --> 00:01:41,480
而记得，我们
在这里重温这些话题，

36
00:01:41,480 --> 00:01:44,480
其中的功能，以及环路，并
变量和布尔表达式，

37
00:01:44,480 --> 00:01:45,110
和条件。

38
00:01:45,110 --> 00:01:49,190
而实际上多了一些，我们
从头开始的世界翻译

39
00:01:49,190 --> 00:01:50,800
到C的世界

40
00:01:50,800 --> 00:01:53,220
>> 但根本建设
块，可以这么说，

41
00:01:53,220 --> 00:01:55,150
真的还是上周相同。

42
00:01:55,150 --> 00:01:57,900
实际上，我们真的只是有一个
不同的拼图，如果你愿意。

43
00:01:57,900 --> 00:02:00,300
而不是紫色的
保存块，而不是我们

44
00:02:00,300 --> 00:02:02,940
已经printf的，这是
这个功能在C，它

45
00:02:02,940 --> 00:02:05,890
允许您打印的东西
并格式化在屏幕上。

46
00:02:05,890 --> 00:02:07,950
我们推出了CS50
图书馆，在那里你

47
00:02:07,950 --> 00:02:11,420
现在在您的处置GET_CHAR，
和get_int和get_string，

48
00:02:11,420 --> 00:02:14,610
和其他一些功能
好了，通过它你可以输入

49
00:02:14,610 --> 00:02:16,260
从用户自己的键盘。

50
00:02:16,260 --> 00:02:20,640
我们也看了看东西
像these-布尔和char，

51
00:02:20,640 --> 00:02:22,490
和双，浮法，
INT，long_long字符串。

52
00:02:22,490 --> 00:02:25,170
还有的在C.甚至其他数据类型

53
00:02:25,170 --> 00:02:28,560
>> 换句话说，当你声明
一个变量来存储一定的价值，

54
00:02:28,560 --> 00:02:32,600
或者当你实现一个功能
返回一定的价值，

55
00:02:32,600 --> 00:02:35,290
您可以指定哪些
类型的值即是。

56
00:02:35,290 --> 00:02:37,310
它是一个字符串，如
字符序列？

57
00:02:37,310 --> 00:02:39,490
它是一个数字，如一个整数？

58
00:02:39,490 --> 00:02:41,390
它是一个浮点
值，等等？

59
00:02:41,390 --> 00:02:46,180
因此，在C，不像划伤，我们实际上
开始指定什么样的数据

60
00:02:46,180 --> 00:02:48,330
我们正在返回或使用。

61
00:02:48,330 --> 00:02:51,910
>> 但是，当然，我们也遇到了
计算的一些基本限制。

62
00:02:51,910 --> 00:02:54,100
并且特别地，
这种语言C，召回

63
00:02:54,100 --> 00:02:57,070
我们看一看在
整数溢出，现实

64
00:02:57,070 --> 00:03:00,460
如果你只有一个
内存数量有限

65
00:03:00,460 --> 00:03:04,600
或者，具体而言，有限数量的
位的，你只能算这么高。

66
00:03:04,600 --> 00:03:08,460
因此，我们看这个例子在这里
因此在飞机上的计数器，

67
00:03:08,460 --> 00:03:13,510
实际上，如果运行时间足够长会
溢出，并导致一个软件

68
00:03:13,510 --> 00:03:15,560
一个实际的物理潜在错误。

69
00:03:15,560 --> 00:03:18,600
>> 我们也看了浮动
点不精确，现实

70
00:03:18,600 --> 00:03:22,280
仅与有限数量的
位，无论是32还是64，

71
00:03:22,280 --> 00:03:27,330
你只能指定如此多的号码
后一个小数点，之后你

72
00:03:27,330 --> 00:03:29,110
开始变得不精确。

73
00:03:29,110 --> 00:03:32,360
因此，例如，三分之一的
世界在这里，在我们人类世界，

74
00:03:32,360 --> 00:03:35,360
我们知道仅仅是一个无限多
小数点后3秒。

75
00:03:35,360 --> 00:03:38,820
但一台电脑可不一定
表示数字无限数量

76
00:03:38,820 --> 00:03:42,590
如果只允许它的一些
有限数量的信息。

77
00:03:42,590 --> 00:03:45,900
>> 所以，我们不仅装备你
在条款更大的权力

78
00:03:45,900 --> 00:03:49,280
你会如何​​表达自己的
键盘编程方面，

79
00:03:49,280 --> 00:03:51,430
我们还限制什么
你实际上可以做。

80
00:03:51,430 --> 00:03:55,790
事实上，错误和错误会
从这些类型的问题的出现。

81
00:03:55,790 --> 00:03:59,900
事实上，在主题中今天
要像调试主题

82
00:03:59,900 --> 00:04:03,699
实际上看引擎盖下
在上周的事情是如何介绍

83
00:04:03,699 --> 00:04:05,490
实际上实施
让你更好

84
00:04:05,490 --> 00:04:10,530
了解两者的能力和
如C语言的限制

85
00:04:10,530 --> 00:04:14,770
>> 而事实上，我们将剥开层层
最简单的数据结构，

86
00:04:14,770 --> 00:04:17,756
一种叫做阵列，它
划痕发生所谓的“清单”。

87
00:04:17,756 --> 00:04:19,589
这是一个有点
在这方面有所不同。

88
00:04:19,589 --> 00:04:23,340
然后，我们还将介绍之一
首先我们特定领域的问题

89
00:04:23,340 --> 00:04:26,790
在CS50，世界
加密，加扰的艺术

90
00:04:26,790 --> 00:04:29,650
或加密信息，以便
您可以发送秘密信息

91
00:04:29,650 --> 00:04:34,520
和解码秘密信息
两个人，A和B之间

92
00:04:34,520 --> 00:04:37,490
>> 所以，我们之前的过渡
那个新的世界，

93
00:04:37,490 --> 00:04:42,059
让我们尝试一些装备你
技术，使用它可以消除

94
00:04:42,059 --> 00:04:43,850
或减少至少一些
坎坷的

95
00:04:43,850 --> 00:04:46,630
你可能已经遇到过
仅在过去的一周。

96
00:04:46,630 --> 00:04:50,830
事实上，在你前面的such--一些
在C和赔率你的第一个问题是，

97
00:04:50,830 --> 00:04:54,010
如果你像我一样，在第一时间
您尝试键入一个方案，

98
00:04:54,010 --> 00:04:57,330
即使你认为逻辑
该方案是非常简单的，

99
00:04:57,330 --> 00:05:01,200
你很可能会碰了壁，并
编译器是不会合作。

100
00:05:01,200 --> 00:05:03,940
制作或锵不会
真正做您的出价。

101
00:05:03,940 --> 00:05:05,450
>> 而为什么会这样呢？

102
00:05:05,450 --> 00:05:07,950
好吧，让我们来看看，
也许，一个简单的程序。

103
00:05:07,950 --> 00:05:11,190
我要继续前进，它保存在
故意叫buggy0.c文件，

104
00:05:11,190 --> 00:05:13,590
因为我知道它要
提前缺陷。

105
00:05:13,590 --> 00:05:17,400
不过，我可能没有意识到，如果这
是在第一或第二或第三程序

106
00:05:17,400 --> 00:05:18,830
这实际上，我让自己。

107
00:05:18,830 --> 00:05:23,820
所以我要继续前进，
打出来，主要INT（无效）。

108
00:05:23,820 --> 00:05:28,130
然后我里面的花括号，
一个非常熟悉的（“你好，天下 - 

109
00:05:28,130 --> 00:05:30,980
反斜线，正“） - 和一个分号。

110
00:05:30,980 --> 00:05:32,360
>> 我保存的文件。

111
00:05:32,360 --> 00:05:34,850
现在，我要下去
我的终端窗口

112
00:05:34,850 --> 00:05:40,340
并输入make buggy0，因为，同样，
该文件的今天的名称是buggy0.c。

113
00:05:40,340 --> 00:05:43,660
所以我键入make buggy0，回车。

114
00:05:43,660 --> 00:05:48,200
>> 而且，哦，天哪，从最后一次召回
没有错误消息是一件好事。

115
00:05:48,200 --> 00:05:49,740
因此，没有输出是一件好事。

116
00:05:49,740 --> 00:05:52,920
但在这里我必须清楚地
一些数字错误。

117
00:05:52,920 --> 00:05:56,470
>> 所以输出的第一行
输入make buggy0后，召回，

118
00:05:56,470 --> 00:05:59,540
是锵的相当详细的输出。

119
00:05:59,540 --> 00:06:02,067
在底层，
CS50 IDE配置

120
00:06:02,067 --> 00:06:04,150
使用一大堆
与此编译器选项

121
00:06:04,150 --> 00:06:05,941
让您不必
想想他们。

122
00:06:05,941 --> 00:06:08,840
而这所有的第一线
装置与锵开始。

123
00:06:08,840 --> 00:06:11,720
>> 但在此之后，该问题
开始让自己的外表。

124
00:06:11,720 --> 00:06:17,390
Buggy0.c上线3条，性格
5，有一个大的，红色的错误。

125
00:06:17,390 --> 00:06:18,380
那是什么？

126
00:06:18,380 --> 00:06:23,562
隐式声明的库函数
int型的（为const char *的printf，

127
00:06:23,562 --> 00:06:26,050
...）[-Werror。

128
00:06:26,050 --> 00:06:28,379
我的意思是，它非常快
变得很神秘。

129
00:06:28,379 --> 00:06:30,170
当然，在第一次
一目了然，我们不会

130
00:06:30,170 --> 00:06:32,380
希望你能理解
该消息的全部内容。

131
00:06:32,380 --> 00:06:34,213
和教训，所以一
今天是怎么回事

132
00:06:34,213 --> 00:06:36,919
要尝试，以通知
图案，或类似的事情，

133
00:06:36,919 --> 00:06:38,960
错误你可能有
在过去所遇到。

134
00:06:38,960 --> 00:06:41,335
因此，让我们只能梳理出
这些话是很熟悉。

135
00:06:41,335 --> 00:06:44,290
大，红色的错误显然是
象征性的东西是错误的。

136
00:06:44,290 --> 00:06:47,940
>> 隐式声明
库函数printf。

137
00:06:47,940 --> 00:06:51,680
所以，即使我不太明白什么
隐式声明的库函数

138
00:06:51,680 --> 00:06:54,900
手段，肯定是问题
涉及到莫名其妙的printf。

139
00:06:54,900 --> 00:06:59,130
这问题的根源
有宣称它做。

140
00:06:59,130 --> 00:07:02,440
>> 声明一个函数
提到它的第一次。

141
00:07:02,440 --> 00:07:06,210
而我们所使用的术语上周
声明一个函数的原型，

142
00:07:06,210 --> 00:07:11,860
无论是与在顶部的一行您的
自己的文件或在一个所谓的头文件。

143
00:07:11,860 --> 00:07:15,300
在什么文件做我们说
上周printf的是报价，

144
00:07:15,300 --> 00:07:17,080
引文结束，宣告？

145
00:07:17,080 --> 00:07:20,950
在哪些文件是它的原型？

146
00:07:20,950 --> 00:07:24,640
>> 所以，如果你还记得，第一件事我
类型化，几乎每个节目最后时间 - 

147
00:07:24,640 --> 00:07:30,790
一不小心刚才开始
打字myself--是这一个这里 - 

148
00:07:30,790 --> 00:07:38,630
hash--的#include <stio--为
输入/ output--点H和事实上，

149
00:07:38,630 --> 00:07:41,860
如果我现在保存这个文件，我要去
先走，并清除我的屏幕，

150
00:07:41,860 --> 00:07:44,740
您可以通过键入做
清除，或者你可以按住控制L，

151
00:07:44,740 --> 00:07:47,680
只是清除终端窗口
只是为了消除一些混乱。

152
00:07:47,680 --> 00:07:51,370
>> 我要继续前进，
再输入make buggy0，回车。

153
00:07:51,370 --> 00:07:53,790
瞧，我仍然看到
从铛长的命令，

154
00:07:53,790 --> 00:07:55,470
但没有错误消息这一次。

155
00:07:55,470 --> 00:07:58,800
事实上，如果我这样做./buggy0，
和上次一样，

156
00:07:58,800 --> 00:08:01,860
其中，点指本
目录，斜线只是手段，

157
00:08:01,860 --> 00:08:05,040
这里谈到的程序的名称和
该方案的这个名字是buggy0，

158
00:08:05,040 --> 00:08:07,340
输入“你好，世界”。

159
00:08:07,340 --> 00:08:09,440
>> 现在，你怎么可能有
收集这一解决方案

160
00:08:09,440 --> 00:08:12,017
而不必
认识到尽可能多的话

161
00:08:12,017 --> 00:08:14,350
像我一样，当然，有
这样做了这么多年？

162
00:08:14,350 --> 00:08:18,720
那么，实现每一个问题
集，我们为您介绍一个命令

163
00:08:18,720 --> 00:08:21,175
这CS50自己的工作人员
编写了一个名为help50。

164
00:08:21,175 --> 00:08:24,300
事实上，C不规范
问题设置至于如何使用它。

165
00:08:24,300 --> 00:08:27,210
>> 但help50本质
一个程序，CS50的工作人员

166
00:08:27,210 --> 00:08:30,850
写道，允许您运行
一个命令或运行程序，

167
00:08:30,850 --> 00:08:36,169
如果你不明白它的
输出，将其输出传递到help50，

168
00:08:36,169 --> 00:08:38,890
在该点处的软件
该课程的员工写

169
00:08:38,890 --> 00:08:42,429
会看你的程序的输出
一行行的，每个字符。

170
00:08:42,429 --> 00:08:46,000
如果我们的工作人员，承认
您所遇到的错误消息，

171
00:08:46,000 --> 00:08:50,580
我们将尝试一些惹你
反问，有一些建议，

172
00:08:50,580 --> 00:08:54,890
就像一个TF或CA还是我自己
将在办公时间做的人。

173
00:08:54,890 --> 00:08:58,320
>> 所以看help50如果你不
一定承认的问题。

174
00:08:58,320 --> 00:09:00,790
但不要依赖它
太多的拐杖。

175
00:09:00,790 --> 00:09:03,990
当然，试着去了解它的
输出，然后从中吸取教训

176
00:09:03,990 --> 00:09:07,571
使得仅一次或两次你
以往运行help50特定错误

177
00:09:07,571 --> 00:09:08,070
信息。

178
00:09:08,070 --> 00:09:10,660
在这之后，你应该
更好的装备自己

179
00:09:10,660 --> 00:09:13,180
要弄清楚它实际上是什么。

180
00:09:13,180 --> 00:09:14,350
>> 让我们做另外一个在这里。

181
00:09:14,350 --> 00:09:20,410
让我先走了，而在另一个
文件我们会打电话给这个buggy1.c。

182
00:09:20,410 --> 00:09:23,110
而在这个文件中，我
要deliberately--

183
00:09:23,110 --> 00:09:26,330
但假装我不
明白我做了什么样的错误。

184
00:09:26,330 --> 00:09:31,420
>> 我要继续前进，做this--
的#include，因为我已经

185
00:09:31,420 --> 00:09:33,660
吸取了教训，从刚才的。

186
00:09:33,660 --> 00:09:36,220
诠释主要（无效），如前。

187
00:09:36,220 --> 00:09:40,880
然后在这里我会
做字符串s  -  get_string。

188
00:09:40,880 --> 00:09:43,770
而从上一次回顾
这意味着，哎，电脑，

189
00:09:43,770 --> 00:09:48,280
给我一个变量，称之为s和
使该变量字符串的类型

190
00:09:48,280 --> 00:09:50,150
所以我可以存储一个或多个字在里面。

191
00:09:50,150 --> 00:09:52,191
>> 然后在右边
等号的一面

192
00:09:52,191 --> 00:09:54,980
被get_string，这是一个
在CS50库中的函数

193
00:09:54,980 --> 00:09:55,980
这正是这么做的。

194
00:09:55,980 --> 00:09:59,740
它得到一个函数，然后
双手从从右到左。

195
00:09:59,740 --> 00:10:02,670
所以这个等号并不意味着
“等于”象我们想象的数学。

196
00:10:02,670 --> 00:10:04,750
这意味着由右至左的分配。

197
00:10:04,750 --> 00:10:09,640
因此，这意味着，采取从字符串
在用户和其存储的S内部。

198
00:10:09,640 --> 00:10:10,460
>> 现在，让我们使用它。

199
00:10:10,460 --> 00:10:13,820
现在让我和继续作为第二
行，让我继续前进，说“你好” - 

200
00:10:13,820 --> 00:10:19,330
不是“世界”，而是“你好，％S--
这是我们的占位符，逗号S，

201
00:10:19,330 --> 00:10:22,030
这是我们的变量，
然后分号。

202
00:10:22,030 --> 00:10:26,070
所以，如果我没有搞砸太多
在这里，这看起来像正确的代码。

203
00:10:26,070 --> 00:10:28,090
>> 而我的直觉现在进行编译。

204
00:10:28,090 --> 00:10:30,400
该文件称为buggy1.c。

205
00:10:30,400 --> 00:10:33,770
所以我打算做使buggy1，回车。

206
00:10:33,770 --> 00:10:36,377
和织补-它，如果没有
甚至更多的错误比以前。

207
00:10:36,377 --> 00:10:38,210
我的意思是，还有更多
错误消息它会

208
00:10:38,210 --> 00:10:40,400
似乎比这个计划的实际行。

209
00:10:40,400 --> 00:10:42,730
>> 但外卖这里，
即使你不堪重负

210
00:10:42,730 --> 00:10:45,040
有两个或三个或
四个错误信息，

211
00:10:45,040 --> 00:10:48,340
始终专注于非常
首先这些消息。

212
00:10:48,340 --> 00:10:52,220
看最顶部的之一，
滚动备份如需要的话。

213
00:10:52,220 --> 00:10:53,930
所以在这里我输入化妆buggy1。

214
00:10:53,930 --> 00:10:55,700
下面是按预期锵输出。

215
00:10:55,700 --> 00:10:57,290
>> 而这里的第一个红色错误。

216
00:10:57,290 --> 00:11:02,370
未声明的标识符使用
字符串，没有我的意思是标准？

217
00:11:02,370 --> 00:11:04,260
因此，标准是
其实别的东西。

218
00:11:04,260 --> 00:11:06,240
它指的是用户的
键盘，本质上。

219
00:11:06,240 --> 00:11:08,080
>> 但是，这不是我的意思。

220
00:11:08,080 --> 00:11:11,770
我的意思是字符串，我的意思是get_string。

221
00:11:11,770 --> 00:11:16,200
那么它是什么，我
忘了这样做的时候？

222
00:11:16,200 --> 00:11:20,230
什么是缺少这个时间呢？

223
00:11:20,230 --> 00:11:23,600
我有我的#include，
所以我有机会对printf。

224
00:11:23,600 --> 00:11:26,090
>> 但我没有
访问只是还没有？

225
00:11:26,090 --> 00:11:29,420
那么，同上次一样，
我需要告诉编译器

226
00:11:29,420 --> 00:11:31,691
铛一下这些功能。

227
00:11:31,691 --> 00:11:33,940
Get_string不来
与C并且特别地，它

228
00:11:33,940 --> 00:11:38,160
不来的
头文件。

229
00:11:38,160 --> 00:11:40,770
相反，它进来
一些工作人员写的，

230
00:11:40,770 --> 00:11:44,176
这是一个不同的文件
名字，但恰当地命名。

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> 所以，简单地通过添加一行
从最后一次代码 - 召回

233
00:11:50,861 --> 00:11:53,610
这铛运行时，它会
来看看我的代码从上到下，

234
00:11:53,610 --> 00:11:54,193
左到右。

235
00:11:54,193 --> 00:11:57,200
这将注意到，
哦，你想要的。

236
00:11:57,200 --> 00:11:59,900
让我去发现，
无论它是在服务器上，

237
00:11:59,900 --> 00:12:03,090
复制和粘贴，从本质上讲，
进入自己的文件的顶部

238
00:12:03,090 --> 00:12:06,820
以便在该故事这一点上，
线1中，程序的其余部分

239
00:12:06,820 --> 00:12:11,651
可事实上，使用任何功能
在其中，其中get_string。

240
00:12:11,651 --> 00:12:13,650
所以我要忽视
这些错误的其余部分，

241
00:12:13,650 --> 00:12:17,190
因为我确实怀疑，只有
第一个真正重要的。

242
00:12:17,190 --> 00:12:20,780
而且我要继续前进并重新运行，
救了我的文件后作出buggy1。

243
00:12:20,780 --> 00:12:22,580
瞧，它的工作。

244
00:12:22,580 --> 00:12:29,200
而且，如果我做./buggy1和类型，为
例如，Zamyla，我现在会打招呼，

245
00:12:29,200 --> 00:12:32,000
Zamyla，而不是你好，世界。

246
00:12:32,000 --> 00:12:32,550
>> 好吧。

247
00:12:32,550 --> 00:12:35,890
因此，这里的外卖店则是，
之一，尽量收集尽可能多的，你可以

248
00:12:35,890 --> 00:12:39,140
单从错误信息，寻找
在一些可识别的话。

249
00:12:39,140 --> 00:12:43,070
除了上述，使用每个help50
问题设置规范。

250
00:12:43,070 --> 00:12:46,500
但除此之外，也总是期待
在最严重的错误只，至少

251
00:12:46,500 --> 00:12:50,051
首先，看什么信息
它实际上可能屈服。

252
00:12:50,051 --> 00:12:52,300
但事实证明，那里的
甚至更多的功能内置

253
00:12:52,300 --> 00:12:55,030
进入CS50库帮助
您在学期初上

254
00:12:55,030 --> 00:12:57,580
而早在节目
找出什么地方出了错。

255
00:12:57,580 --> 00:12:59,840
所以，让我们做一个例子在这里。

256
00:12:59,840 --> 00:13:04,350
我打算把这个buggy2，其中，
再次，将被有缺陷的出

257
00:13:04,350 --> 00:13:05,650
门口，由设计。

258
00:13:05,650 --> 00:13:09,980
>> 而且我要继续前进
做的#include。

259
00:13:09,980 --> 00:13:12,580
然后我要做的主要INT（无效）。

260
00:13:12,580 --> 00:13:14,840
然后我会为循环做。

261
00:13:14,840 --> 00:13:16,690
对于（INT I _ 0。

262
00:13:16,690 --> 00:13:18,750
i小于或等于10。

263
00:13:18,750 --> 00:13:24,260
我++，然后在大括号，我要去
在这里打印出来只是一种标签符号

264
00:13:24,260 --> 00:13:25,920
和一个新行字符。

265
00:13:25,920 --> 00:13:29,220
>> 所以，我的意图与此
程序是很简单

266
00:13:29,220 --> 00:13:33,150
迭代10次
并在每个迭代

267
00:13:33,150 --> 00:13:35,260
每一次循环
通过循环，

268
00:13:35,260 --> 00:13:37,660
打印出井号标签，
＃标签，＃标签。

269
00:13:37,660 --> 00:13:40,480
每行一个，因为我
有新的行那里。

270
00:13:40,480 --> 00:13:42,787
并回顾，对
循环，每最后week--

271
00:13:42,787 --> 00:13:44,620
你会得到更多的
熟悉的语法

272
00:13:44,620 --> 00:13:47,170
通过使用它与实践
long--前，这给了我

273
00:13:47,170 --> 00:13:49,740
一个变量叫我并将其设置为0。

274
00:13:49,740 --> 00:13:52,650
>> 这增加我对
每次迭代1。

275
00:13:52,650 --> 00:13:54,940
所以我变为1到2到3。

276
00:13:54,940 --> 00:13:57,690
然后该条件在
分号之间的中间

277
00:13:57,690 --> 00:14:03,010
被检查的每一次迭代，使
确保我们仍然在范围内。

278
00:14:03,010 --> 00:14:06,830
所以我想重复10次，所以我
有那种非常直观地只是

279
00:14:06,830 --> 00:14:09,070
把10作为我的上限那里。

280
00:14:09,070 --> 00:14:14,310
>> 然而，之后当我运行这一点，
用make编译它buggy2--

281
00:14:14,310 --> 00:14:15,440
它并编译确定。

282
00:14:15,440 --> 00:14:17,980
所以，我没有
语法错误这一次。

283
00:14:17,980 --> 00:14:20,940
现在让我继续前进
并运行buggy2，回车。

284
00:14:20,940 --> 00:14:22,620
现在向上滚动。

285
00:14:22,620 --> 00:14:24,890
让我增加
窗口的大小。

286
00:14:24,890 --> 00:14:33,720
>> 我似乎有1，2，3，
4，5，6，7，8，9，10，11。

287
00:14:33,720 --> 00:14:38,891
因此，有11＃标签，即使
我明确提出10这个循环中。

288
00:14:38,891 --> 00:14:42,140
现在，有些人可能会立即看到
什么错误是因为，实际上，这

289
00:14:42,140 --> 00:14:43,720
是不是一个很严重的错误，使。

290
00:14:43,720 --> 00:14:46,070
但它是非常普遍
在做很早。

291
00:14:46,070 --> 00:14:49,820
>> 我想指出的是，虽然，
是的，我怎么可能算出这个？

292
00:14:49,820 --> 00:14:52,300
那么，事实证明，
在CS50库来

293
00:14:52,300 --> 00:14:55,380
不仅get_string和get_int
和get_float等功能。

294
00:14:55,380 --> 00:14:59,980
它还配备了一个特殊功能
所谓EPRINTF，或者错误的printf。

295
00:14:59,980 --> 00:15:03,270
它只是存在，使
它为您轻松一点点

296
00:15:03,270 --> 00:15:06,310
调试代码，只是当
在屏幕上显示一条错误消息

297
00:15:06,310 --> 00:15:07,850
并知道它是从哪里来的。

298
00:15:07,850 --> 00:15:11,000
>> 因此，举例来说，有一件事我可能
在这里做的这个功能是this--

299
00:15:11,000 --> 00:15:20,230
EPRINTF，然后我要继续前进
并说现在我是％I，反斜线，正。

300
00:15:20,230 --> 00:15:22,330
而且我要在我的价值堵塞。

301
00:15:22,330 --> 00:15:25,400
而向上顶，因为这
是CS50库中，

302
00:15:25,400 --> 00:15:27,580
我要继续前进
并包括

303
00:15:27,580 --> 00:15:29,169
所以我有机会获得这一功能。

304
00:15:29,169 --> 00:15:31,460
但是，让我们考虑一下线
9应该做的事情。

305
00:15:31,460 --> 00:15:32,670
我将最终删除。

306
00:15:32,670 --> 00:15:34,670
这无关
我的首要目标。

307
00:15:34,670 --> 00:15:39,090
但是EPRINTF，错误的printf，只是意思
给我一些诊断信息。

308
00:15:39,090 --> 00:15:42,460
当我运行我的程序，我想
看到这个屏幕上暂时

309
00:15:42,460 --> 00:15:44,550
也仅仅理解
这是怎么回事。

310
00:15:44,550 --> 00:15:47,330
>> 而且，事实上，在每个
这里的迭代9号线

311
00:15:47,330 --> 00:15:49,260
我想看看，什么是我的价值？

312
00:15:49,260 --> 00:15:50,290
什么是我的价值？

313
00:15:50,290 --> 00:15:51,280
什么是我的价值？

314
00:15:51,280 --> 00:15:55,650
并希望，我应该只
看到该消息，另外，10次。

315
00:15:55,650 --> 00:15:57,780
>> 因此，让我继续前进，
重新编译我的程序，

316
00:15:57,780 --> 00:15:59,905
因为我做任何时间
我做出改变。 ./buggy2。

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
和now--确定。

319
00:16:03,640 --> 00:16:04,820
还有很多更多的事情。

320
00:16:04,820 --> 00:16:07,610
因此，让我在向上滚动
一个更大的窗口。

321
00:16:07,610 --> 00:16:10,190
>> 你会看到，每个
该主题标签仍然打印。

322
00:16:10,190 --> 00:16:15,270
但是，在与他们每个人是现在这个
诊断输出格式如下。

323
00:16:15,270 --> 00:16:17,960
在这里我的程序的名称是buggy2。

324
00:16:17,960 --> 00:16:20,432
该文件的名称是buggy2.c。

325
00:16:20,432 --> 00:16:24,080
行号从其中
此印为9号线。

326
00:16:24,080 --> 00:16:27,500
然后那右边的是
我很期待的错误消息。

327
00:16:27,500 --> 00:16:30,701
>> 什么是很好的关于这就是
现在我不必一定算

328
00:16:30,701 --> 00:16:32,200
在我的脑袋就是我的程序在做什么。

329
00:16:32,200 --> 00:16:34,240
我可以看到，在
第一次迭代i是0，

330
00:16:34,240 --> 00:16:39,420
然后1，然后2，然后3，然后是4，那么
5，然后6，则如图7所示，然后如图8所示，然后如图9所示，然后

331
00:16:39,420 --> 00:16:40,980
10。

332
00:16:40,980 --> 00:16:42,050
所以等一下。

333
00:16:42,050 --> 00:16:43,740
这里发生了什么？

334
00:16:43,740 --> 00:16:48,190
我似乎仍然计数
如预期可达10。

335
00:16:48,190 --> 00:16:50,550
>> 但是，在没有开始呢？

336
00:16:50,550 --> 00:16:53,240
0，1，2，3，4，5，6，7，8，9 10。

337
00:16:53,240 --> 00:16:58,040
因此0，1，2，3，4，5，6，7，
8，9，10--第11手指

338
00:16:58,040 --> 00:16:59,990
指示的问题。

339
00:16:59,990 --> 00:17:02,850
我似乎已经算
错误在我的循环。

340
00:17:02,850 --> 00:17:06,599
而不是去10次迭代，
我从0开始，

341
00:17:06,599 --> 00:17:09,550
我在，并通过10结束。

342
00:17:09,550 --> 00:17:12,030
但因为，像计算机，
我从0开始计数，

343
00:17:12,030 --> 00:17:15,250
我应该计数
到，但不通过，10。

344
00:17:15,250 --> 00:17:18,510
>> 这样一来，修复，最终我
在这里实现的，是两件事情之一。

345
00:17:18,510 --> 00:17:22,430
我很可能简单地说
数到小于10。

346
00:17:22,430 --> 00:17:27,260
因此0，1，2，3，4，5，6，7，8，
9，这的确是正确的，

347
00:17:27,260 --> 00:17:28,900
尽管这听起来有点不对劲。

348
00:17:28,900 --> 00:17:35,070
或者，我可以做到小于或等于
9，只要我从0开始。

349
00:17:35,070 --> 00:17:40,056
或者，如果你真的不喜欢，你
可以计数到10，但是从1开始。

350
00:17:40,056 --> 00:17:41,680
但同样，这恰恰是并不常见。

351
00:17:41,680 --> 00:17:43,977
在programming--尽管
与其说是在Scratch--

352
00:17:43,977 --> 00:17:45,810
但在编程
C和其他语言，

353
00:17:45,810 --> 00:17:47,670
如JavaScript和
Python和其他人，这是

354
00:17:47,670 --> 00:17:49,880
只是很常见的
我们的二元讨论

355
00:17:49,880 --> 00:17:53,450
刚开始点票
最低的数字就可以了，这是0。

356
00:17:53,450 --> 00:17:53,950
好吧。

357
00:17:53,950 --> 00:17:55,160
所以这是EPRINTF。

358
00:17:55,160 --> 00:17:58,600
再次，现在我已经想通了我
的问题，我要回去0

359
00:17:58,600 --> 00:18:01,470
经过不到10，我要去
去和删除EPRINTF。

360
00:18:01,470 --> 00:18:04,580
>> 它不应该，当我在那里
我的船代码或提交我的代码

361
00:18:04,580 --> 00:18:05,800
或展示给其他人。

362
00:18:05,800 --> 00:18:07,980
它实际上只是意味着
要暂时使用。

363
00:18:07,980 --> 00:18:11,650
但现在我已经解决了这个问题
特别的问题也是如此。

364
00:18:11,650 --> 00:18:16,780
>> 好吧，让我们做一个例子在这里
我要去掀起如下。

365
00:18:16,780 --> 00:18:22,850
我要继续前进，
的#include。 $ 50个

366
00:18:22,850 --> 00:18:25,580
而且我要继续前进
和的#i​​nclude。

367
00:18:25,580 --> 00:18:29,030
>> 而且我要救
此文件buggy3.c。

368
00:18:29,030 --> 00:18:31,740
而且我要继续前进
并宣布INT主要（无效）。

369
00:18:31,740 --> 00:18:34,186
然后里面有
我该怎么办INT I _  - 

370
00:18:34,186 --> 00:18:36,435
我想要实现一个程序
用get_negative_int。

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
这是不存在又一个函数。

373
00:18:40,770 --> 00:18:42,870
因此，我们要实现
它在短短的时刻。

374
00:18:42,870 --> 00:18:45,541
但是，我们要明白为什么
它在第一轮马车。

375
00:18:45,541 --> 00:18:47,290
一旦我已经得到
来自用户的INT，

376
00:18:47,290 --> 00:18:53,365
我只是要打印％我是一个负
整数，反斜线，正，逗号，我。

377
00:18:53,365 --> 00:18:55,240
换言之，所有我
希望这个程序做

378
00:18:55,240 --> 00:18:58,000
是从一个负INT
用户，然后打印出

379
00:18:58,000 --> 00:18:59,980
某某是负中间体

380
00:18:59,980 --> 00:19:02,080
>> 现在我需要实现这个功能。

381
00:19:02,080 --> 00:19:05,740
所以在我的文件后，我要去
提前并声明调用的函数

382
00:19:05,740 --> 00:19:10,670
get_negative_int（无效） - 我们将
回过头来什么该行又指

383
00:19:10,670 --> 00:19:18,790
在moment-- INT N;渡渡鸟
在fo​​llowing-- printf的n是：。

384
00:19:18,790 --> 00:19:26,210
然后我要做的N  -  get_int，
和为此而n是大于0。

385
00:19:26,210 --> 00:19:28,310
然后返回否;.

386
00:19:28,310 --> 00:19:31,730
>> 因此，有很多事情
这一点，但没有一个我们没有

387
00:19:31,730 --> 00:19:33,710
看看上周，至少简要介绍。

388
00:19:33,710 --> 00:19:36,980
于是就在这里10行，我宣布
函数调用get_negative_int，

389
00:19:36,980 --> 00:19:39,620
我已经把（无效），在
括号，原因是这

390
00:19:39,620 --> 00:19:40,950
不采取一个输入。

391
00:19:40,950 --> 00:19:42,910
我不传递任何
此功能。

392
00:19:42,910 --> 00:19:44,690
我刚开始从东西回来。

393
00:19:44,690 --> 00:19:47,270
>> 而我很希望
回来是整数。

394
00:19:47,270 --> 00:19:50,040
有在任何数据类型
Ç称为negative_int。

395
00:19:50,040 --> 00:19:52,880
这只是诠释，所以这是怎么回事
要对我们确保

396
00:19:52,880 --> 00:19:55,340
这实际上就是价值
返回的不仅是一个int

397
00:19:55,340 --> 00:19:56,380
但也为负。

398
00:19:56,380 --> 00:20:02,150
>> 第12行，我声明一个变量
所谓n和使其int类型的。

399
00:20:02,150 --> 00:20:07,500
然后在第13行至18，我
做一些事情，而事情是真实的。

400
00:20:07,500 --> 00:20:11,040
我会继续和印刷
N是，结肠，然后一个空间，

401
00:20:11,040 --> 00:20:12,800
像对用户的提示。

402
00:20:12,800 --> 00:20:16,410
>> 然后我打电话get_int和
存储其所谓的返回值

403
00:20:16,410 --> 00:20:18,130
在变量n。

404
00:20:18,130 --> 00:20:22,600
但我会继续做
此而n是大于0。

405
00:20:22,600 --> 00:20:27,960
换句话说，如果用户给我一个
int和该数量是大于0，

406
00:20:27,960 --> 00:20:31,180
ERGO的，积极的，我要去
只是不停的再次提示用户，

407
00:20:31,180 --> 00:20:37,160
守时再次提示，以迫使他们到
合作，并给我一个负int值。

408
00:20:37,160 --> 00:20:41,640
>> 而一旦n是实际negative--
假设用户终于类型-50，

409
00:20:41,640 --> 00:20:46,710
那么这个while循环不再是真实的
因为-50不大于0。

410
00:20:46,710 --> 00:20:51,140
所以我们摆脱了
循环逻辑和返回否。

411
00:20:51,140 --> 00:20:53,520
>> 但是有一个其他
事情我必须做的。

412
00:20:53,520 --> 00:20:56,190
我可以简单地这样做
通过复制和粘贴

413
00:20:56,190 --> 00:20:58,540
在该文件的顶部的一行代码。

414
00:20:58,540 --> 00:21:01,630
我需要教铛，
或承诺铛，

415
00:21:01,630 --> 00:21:04,630
明确地说我会的，
的确，去实现

416
00:21:04,630 --> 00:21:06,020
此功能get_negative_int。

417
00:21:06,020 --> 00:21:07,674
它可能只是文件中的低。

418
00:21:07,674 --> 00:21:09,840
再次，记得锵
读取事情从上到下，

419
00:21:09,840 --> 00:21:12,330
左到右，所以你不能
如果调用锵功能

420
00:21:12,330 --> 00:21:15,330
不知道它会存在。

421
00:21:15,330 --> 00:21:18,430
>> 现在，不幸的是，这个程序，
因为有些人可能已经注意到了，

422
00:21:18,430 --> 00:21:19,590
已经是马车。

423
00:21:19,590 --> 00:21:21,400
让我继续前进，使buggy3。

424
00:21:21,400 --> 00:21:26,904
它编译，所以我现在的问题是不
语法错误，如文字错误，

425
00:21:26,904 --> 00:21:29,570
它实际上将是一个逻辑
错误，我已经刻意

426
00:21:29,570 --> 00:21:32,450
制成为契机
步是怎么回事。

427
00:21:32,450 --> 00:21:35,540
>> 我要继续前进
现在运行buggy3。

428
00:21:35,540 --> 00:21:37,490
我要去
未来，而不是合作。

429
00:21:37,490 --> 00:21:39,494
我要去给它1号。

430
00:21:39,494 --> 00:21:41,410
它不喜欢它，所以
它再次提示我。

431
00:21:41,410 --> 00:21:42,147
>> 2点怎么样？

432
00:21:42,147 --> 00:21:43,021
3？

433
00:21:43,021 --> 00:21:43,520
50？

434
00:21:43,520 --> 00:21:44,740
这些都不是工作。

435
00:21:44,740 --> 00:21:46,890
如何-50？

436
00:21:46,890 --> 00:21:48,560
和节目似乎工作。

437
00:21:48,560 --> 00:21:49,970
>> 让我尝试一次。

438
00:21:49,970 --> 00:21:53,400
让我试试-1，似乎工作。

439
00:21:53,400 --> 00:21:56,380
让我尝试-2，似乎工作。

440
00:21:56,380 --> 00:21:59,640
让我试试0。

441
00:21:59,640 --> 00:22:01,684
呵呵，这是不正确。

442
00:22:01,684 --> 00:22:03,350
现在，我们是一个小迂腐在这里。

443
00:22:03,350 --> 00:22:07,090
但它确实的情况下满足0
既不积极也不消极。

444
00:22:07,090 --> 00:22:11,150
这样一来，事实证明我的计划是
说0是负整数，

445
00:22:11,150 --> 00:22:12,820
这不是技术上是正确的。

446
00:22:12,820 --> 00:22:15,180
>> 现在，它为什么这样做呢？

447
00:22:15,180 --> 00:22:16,270
嗯，这可能是显而易见的。

448
00:22:16,270 --> 00:22:18,110
而且，事实上，程序
意味着是相当简单的

449
00:22:18,110 --> 00:22:19,670
所以我们有一些探索。

450
00:22:19,670 --> 00:22:25,870
>> 但是，让我们引进第三调试
技术这里叫做debug50。

451
00:22:25,870 --> 00:22:27,750
因此，这是一个程序
我们刚刚创建

452
00:22:27,750 --> 00:22:30,770
今年被称为debug50
这将允许您

453
00:22:30,770 --> 00:22:34,130
使用什么叫做内置
图形化调试器在CS50 IDE。

454
00:22:34,130 --> 00:22:38,400
和调试器只是一个程序，
通常，您可以运行程序

455
00:22:38,400 --> 00:22:44,050
但一步一步一个脚印，行
由一行行，暂停，戳

456
00:22:44,050 --> 00:22:47,626
四周，看着变量，这样
程序不只是吹过去，你

457
00:22:47,626 --> 00:22:49,750
和快速打印的东西
或不打印的东西。

458
00:22:49,750 --> 00:22:53,250
它给你一个机会，在
人类的速度，与它进行交互。

459
00:22:53,250 --> 00:22:55,470
>> 而要做到这一点，你
只需做到以下几点。

460
00:22:55,470 --> 00:22:58,479
编译代码后，
我已经做了，buggy3，

461
00:22:58,479 --> 00:23:00,020
你继续运行debug50 ./buggy。

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
那么像help50有运行
help50然后命令，

464
00:23:06,760 --> 00:23:10,120
debug50有运行debug50和
然后命令的名称。

465
00:23:10,120 --> 00:23:14,440
>> 现在看我的屏幕上会发生什么，
上，特别是右侧。

466
00:23:14,440 --> 00:23:19,400
当我打运行，所有的
这突如其来的右侧面板

467
00:23:19,400 --> 00:23:20,419
在屏幕上打开。

468
00:23:20,419 --> 00:23:22,210
而且还有很多要去
在乍看之下。

469
00:23:22,210 --> 00:23:25,110
但是，也不是太
什么可担心的呢。

470
00:23:25,110 --> 00:23:28,570
>> 这正显示出我的一切
这是怎么回事我的计划内

471
00:23:28,570 --> 00:23:31,130
现在和通过这些
按钮向上顶然后

472
00:23:31,130 --> 00:23:35,910
让我步我的代码
最终一步一步一步。

473
00:23:35,910 --> 00:23:37,140
但不是现在。

474
00:23:37,140 --> 00:23:38,060
注意会发生什么。

475
00:23:38,060 --> 00:23:40,600
在我的终端窗口
我被提示n个。

476
00:23:40,600 --> 00:23:44,560
而且我要继续前进，
这种合作的时间和类型-1。

477
00:23:44,560 --> 00:23:48,770
虽然和一点点隐晦，-1
是一个负整数，符合市场预期。

478
00:23:48,770 --> 00:23:52,020
>> 然后孩子退出，
状态0 GDBSERVER退出。

479
00:23:52,020 --> 00:23:55,180
GDB，GNU调试器，是名
底层软件的

480
00:23:55,180 --> 00:23:56,620
实现这个调试器。

481
00:23:56,620 --> 00:24:00,500
但是这一切的真正含义，调试器
临走的时候，因为我的程序退出

482
00:24:00,500 --> 00:24:01,710
和一切都很好。

483
00:24:01,710 --> 00:24:06,020
如果我想真正的调试我的程序，
我要告诉先发制人debug50，

484
00:24:06,020 --> 00:24:08,920
在哪里我要开始
通过我的代码加强？

485
00:24:08,920 --> 00:24:11,750
>> 也许最简单的方法
要做到这一点是如下。

486
00:24:11,750 --> 00:24:15,300
如果我将鼠标悬停在
我的编辑的排水沟在这里，

487
00:24:15,300 --> 00:24:19,090
所以真的只是这里的侧边栏，
到行号的左侧，

488
00:24:19,090 --> 00:24:21,870
请注意，如果我只是点击
有一次，我把一个小红点。

489
00:24:21,870 --> 00:24:24,460
这小红点，
就像停止的迹象，这意味着，哎，

490
00:24:24,460 --> 00:24:29,430
debug50，我的代码暂停执行
在那里，当我运行这个程序。

491
00:24:29,430 --> 00:24:30,260
>> 因此，让我们做到这一点。

492
00:24:30,260 --> 00:24:37,340
让我继续前进，运行我的程序
再次debug50 ./buggy3，回车。

493
00:24:37,340 --> 00:24:40,110
而现在，通知，东西
不同的事情发生了。

494
00:24:40,110 --> 00:24:42,440
我没有被提示
但在我的终端窗口

495
00:24:42,440 --> 00:24:45,430
任何东西，因为我还没有
在我的计划变得那里。

496
00:24:45,430 --> 00:24:47,950
请注意，在第8行
这是现在突出，

497
00:24:47,950 --> 00:24:51,720
并有一个小箭头
左说，你是在这里暂停。

498
00:24:51,720 --> 00:24:55,030
这行代码，行
8，尚未执行。

499
00:24:55,030 --> 00:24:58,940
>> 这有什么奇怪的，如果我期待
在这里的右手边，

500
00:24:58,940 --> 00:25:03,530
请注意，我是一个局部
可变的，在这个意义上本地

501
00:25:03,530 --> 00:25:05,450
这是当前函数内。

502
00:25:05,450 --> 00:25:08,920
和它的价值，显然是在默认情况下，
和排序的便利，为0。

503
00:25:08,920 --> 00:25:10,260
但我没有输入0。

504
00:25:10,260 --> 00:25:13,410
这恰好是它的
此刻默认值。

505
00:25:13,410 --> 00:25:15,490
>> 因此，让我继续前进，现在做到这一点。

506
00:25:15,490 --> 00:25:18,680
让我继续前进，在
右上方这里，我

507
00:25:18,680 --> 00:25:20,970
要继续前进，
点击这个第一个图标其中

508
00:25:20,970 --> 00:25:25,360
指步过这意味着不要跳过
，但跨过这行代码，

509
00:25:25,360 --> 00:25:27,770
执行它沿途。

510
00:25:27,770 --> 00:25:30,710
>> 现在，请注意，我
提示刚刚更改。

511
00:25:30,710 --> 00:25:31,380
这是为什么？

512
00:25:31,380 --> 00:25:33,639
我告诉debug50，
运行此行代码。

513
00:25:33,639 --> 00:25:34,930
这是什么行代码呢？

514
00:25:34,930 --> 00:25:35,960
提示我要一个int。

515
00:25:35,960 --> 00:25:36,460
好。

516
00:25:36,460 --> 00:25:37,400
让我合作。

517
00:25:37,400 --> 00:25:41,340
现在让我继续前进，并键入-1，回车。

518
00:25:41,340 --> 00:25:42,920
而现在发现了什么变化。

519
00:25:42,920 --> 00:25:46,060
在右手侧，
我的本地变量i

520
00:25:46,060 --> 00:25:48,200
被指示为-1现在。

521
00:25:48,200 --> 00:25:49,810
而且它是int类型仍然。

522
00:25:49,810 --> 00:25:53,102
>> 和通知，也我所谓的
调用堆栈，在哪里我停下？

523
00:25:53,102 --> 00:25:54,810
我们将详细讨论
这在未来。

524
00:25:54,810 --> 00:25:58,620
但调用堆栈只是指的是什么
功能是当前在运动。

525
00:25:58,620 --> 00:26:00,040
现在，它只是主力。

526
00:26:00,040 --> 00:26:03,590
而现在唯一的地方
变量为i为1的值。

527
00:26:03,590 --> 00:26:09,840
>> 而当我终于跨过这条线
在这里，与右上角的图标相同，

528
00:26:09,840 --> 00:26:11,410
-1是一个负整数。

529
00:26:11,410 --> 00:26:13,580
现在，它在暂停的花括号。

530
00:26:13,580 --> 00:26:14,740
让我们让它做它的事。

531
00:26:14,740 --> 00:26:17,300
我跨过这道线，瞧。

532
00:26:17,300 --> 00:26:20,240
>> 所以，不是所有的可怕
启发然而，

533
00:26:20,240 --> 00:26:23,550
但它确实让我暂停
并认为通过逻辑

534
00:26:23,550 --> 00:26:24,870
这是什么程序在做什么。

535
00:26:24,870 --> 00:26:26,890
但是，这不是错误的情况。

536
00:26:26,890 --> 00:26:28,510
让我们再次做到这一点如下。

537
00:26:28,510 --> 00:26:31,340
>> 我要离开这个断点
上与红色点线8。

538
00:26:31,340 --> 00:26:32,830
我要重新运行debug50。

539
00:26:32,830 --> 00:26:34,400
它会自动暂停在这里。

540
00:26:34,400 --> 00:26:37,660
但这一次，而不是
跨过这条线，

541
00:26:37,660 --> 00:26:42,290
让我真正去里面
get_negative_int并找出，

542
00:26:42,290 --> 00:26:45,530
为什么它接受0作为一个有效的答案？

543
00:26:45,530 --> 00:26:47,990
>> 因此，而不是点击步过。

544
00:26:47,990 --> 00:26:50,630
我要继续前进
单击单步执行。

545
00:26:50,630 --> 00:26:54,030
并注意8号线这
现在现在突然突出

546
00:26:54,030 --> 00:26:56,900
变成17行。

547
00:26:56,900 --> 00:26:59,947
>> 现在，它不是调试器
已经跳过管线14和15和16。

548
00:26:59,947 --> 00:27:01,780
它只是没有什么
给你看那里。

549
00:27:01,780 --> 00:27:04,050
那些只是声明变量，
再有就是这个词做

550
00:27:04,050 --> 00:27:05,390
然后一个开放的花括号。

551
00:27:05,390 --> 00:27:09,227
唯一的功能线这
多汁真的是这样一个在这里，17。

552
00:27:09,227 --> 00:27:11,060
而这也正是我们所
自动暂停。

553
00:27:11,060 --> 00:27:13,870
>> 所以输出（“n.is：”）;,这样
这还没有发生。

554
00:27:13,870 --> 00:27:18,250
因此，让我们继续前进，并单击步过。

555
00:27:18,250 --> 00:27:20,326
现在我的提示，的确，
变更为（「n为：“）。

556
00:27:20,326 --> 00:27:22,450
现在get_int，我不会去
打扰踏入，

557
00:27:22,450 --> 00:27:24,750
因为该功能是
对图书馆在CS50的。

558
00:27:24,750 --> 00:27:25,750
这大概是正确的。

559
00:27:25,750 --> 00:27:28,440
>> 所以我要继续前进，
那种通过给予合作

560
00:27:28,440 --> 00:27:30,590
int，但不是消极的int值。

561
00:27:30,590 --> 00:27:32,870
因此，让我继续前进，命中0。

562
00:27:32,870 --> 00:27:39,460
现在，这里是什么情况
当我得到了第21行？

563
00:27:39,460 --> 00:27:40,890
我不会再重复。

564
00:27:40,890 --> 00:27:43,320
我似乎并没有停留在这个循环。

565
00:27:43,320 --> 00:27:45,990
换句话说，这种黄色
酒吧没有保住绕来绕去，

566
00:27:45,990 --> 00:27:47,130
又一圈，又一圈。

567
00:27:47,130 --> 00:27:48,340
>> 现在，这是为什么？

568
00:27:48,340 --> 00:27:49,920
好了，正，什么是现在N'

569
00:27:49,920 --> 00:27:53,280
我可以看看当地
在调试器变量。

570
00:27:53,280 --> 00:27:53,816
n为0。

571
00:27:53,816 --> 00:27:55,190
好吧，什么是我的条件？

572
00:27:55,190 --> 00:27:58,700
>> 20--线20，好了，
0是大于0。

573
00:27:58,700 --> 00:27:59,500
这是不正确的。

574
00:27:59,500 --> 00:28:01,020
0不大于0。

575
00:28:01,020 --> 00:28:02,820
所以，我打破了这一点。

576
00:28:02,820 --> 00:28:06,370
>> 所以这就是为什么上线
21，如果我真的继续下去，

577
00:28:06,370 --> 00:28:10,370
我将返回0，即使
虽然我应该拒绝0

578
00:28:10,370 --> 00:28:12,484
因为实际上没有被否定。

579
00:28:12,484 --> 00:28:14,650
所以，现在，我真的不连
关心的调试器。

580
00:28:14,650 --> 00:28:16,900
得到它，我不需要
了解更多的是怎么回事。

581
00:28:16,900 --> 00:28:19,233
>> 所以我要继续前进，
只需点击播放按钮，

582
00:28:19,233 --> 00:28:20,240
而让这完成了。

583
00:28:20,240 --> 00:28:23,440
现在，我已经意识到我
错误显然是在第20行。

584
00:28:23,440 --> 00:28:25,160
这是我的逻辑错误。

585
00:28:25,160 --> 00:28:28,100
>> 所以我想要什么
做改变呢？

586
00:28:28,100 --> 00:28:32,500
如果问题是，我不
醒目0，它只是一个逻辑上的错误。

587
00:28:32,500 --> 00:28:35,910
我可以说，当n为
大于或等于0，

588
00:28:35,910 --> 00:28:38,330
保持一再提示用户。

589
00:28:38,330 --> 00:28:41,050
>> 所以，再次，简单的错误，也许
当你看到我，即使明显

590
00:28:41,050 --> 00:28:42,410
写只需几分钟前。

591
00:28:42,410 --> 00:28:44,570
但这里的外卖
是，与调试50，

592
00:28:44,570 --> 00:28:46,850
与调试
软件更一般地，

593
00:28:46,850 --> 00:28:51,370
你有这个新发现的力量
通过你自己的代码走走，看看

594
00:28:51,370 --> 00:28:55,590
通过该右侧面板是什么
您的变量值。

595
00:28:55,590 --> 00:28:57,700
所以，你不一定
要使用的东西

596
00:28:57,700 --> 00:29:00,630
像你EPRINTF打印这些值。

597
00:29:00,630 --> 00:29:04,430
实际上，你可以看到他们
肉眼在屏幕上。

598
00:29:04,430 --> 00:29:08,920
>> 现在，除此之外，值得注意的
这还有另一种技术，它是

599
00:29:08,920 --> 00:29:09,890
其实超级常见。

600
00:29:09,890 --> 00:29:13,120
你可能想知道为什么这个小
这里的家伙一直坐在台上。

601
00:29:13,120 --> 00:29:16,490
因此，有这样的技术，一般
被称为橡皮鸭调试，

602
00:29:16,490 --> 00:29:18,786
这真的只是一个
证明的事实

603
00:29:18,786 --> 00:29:20,660
经常当程序员
正在编写代码，

604
00:29:20,660 --> 00:29:22,650
他们不一定
与他人合作，

605
00:29:22,650 --> 00:29:24,030
或在共享的环境中工作。

606
00:29:24,030 --> 00:29:25,050
>> 他们在家里是那种。

607
00:29:25,050 --> 00:29:25,910
也许这是在深夜。

608
00:29:25,910 --> 00:29:28,190
他们试图图
出在他们的代码的一些bug。

609
00:29:28,190 --> 00:29:29,330
而他们只是没有看到它。

610
00:29:29,330 --> 00:29:30,329
>> 而且也没有室友。

611
00:29:30,329 --> 00:29:31,250
没有的TF。

612
00:29:31,250 --> 00:29:32,680
周围没有CA。

613
00:29:32,680 --> 00:29:36,440
所有他们有他们的货架上
就是这个小橡皮鸭。

614
00:29:36,440 --> 00:29:39,030
>> 所以橡皮鸭调试
只是这个邀请

615
00:29:39,030 --> 00:29:42,780
想愚蠢的东西
因为这是一个真正的生物，

616
00:29:42,780 --> 00:29:46,940
实际上走过你的代码
口头本无生命的物体。

617
00:29:46,940 --> 00:29:49,230
因此，例如，如果
这是我的例子这里 - 

618
00:29:49,230 --> 00:29:52,470
而回顾过去，
问题是此，

619
00:29:52,470 --> 00:29:58,140
如果我删除这个代码的第一行，
我继续前进并再次马车0，

620
00:29:58,140 --> 00:30:01,220
记得我有这些
这里的错误消息。

621
00:30:01,220 --> 00:30:05,997
这样的想法在这里，可笑虽然我
感觉此刻公开这样做，

622
00:30:05,997 --> 00:30:06,580
就是错误。

623
00:30:06,580 --> 00:30:10,910
>> 好了，所以我的问题是，我已经
隐式声明的库函数。

624
00:30:10,910 --> 00:30:12,610
而该库函数的printf。

625
00:30:12,610 --> 00:30:15,290
Declare-- OK，声明
提醒原型的我。

626
00:30:15,290 --> 00:30:18,930
>> 这意味着我需要真正
告诉编译器事先什么

627
00:30:18,930 --> 00:30:19,980
该函数的模样。

628
00:30:19,980 --> 00:30:20,930
等一下。

629
00:30:20,930 --> 00:30:23,580
我没有标准io.h.

630
00:30:23,580 --> 00:30:24,530
非常感谢你。

631
00:30:24,530 --> 00:30:27,330
>> 因此，只要这个过程of--你
不需要居然有一只鸭子。

632
00:30:27,330 --> 00:30:29,819
但是这种想法走
自己通过自己的代码

633
00:30:29,819 --> 00:30:31,610
这样你甚至可以听到
你自己，让你

634
00:30:31,610 --> 00:30:35,620
实现你自己的疏忽
言论，一般的想法。

635
00:30:35,620 --> 00:30:38,910
>> 而且，也许更合理，没有那么
多与人，但更多地参与

636
00:30:38,910 --> 00:30:44,220
例如，我们刚刚在车3.C那样，
你可能会走自己通过它

637
00:30:44,220 --> 00:30:45,310
如下。

638
00:30:45,310 --> 00:30:49,190
这样也好，橡胶
鸭子，DDB，如果你愿意。

639
00:30:49,190 --> 00:30:52,350
在这里，我们在我的主要功能，
我打电话让负int值。

640
00:30:52,350 --> 00:30:54,660
>> 而我得到的返回值。

641
00:30:54,660 --> 00:31:00,410
我将其存储在左手侧
在一个变线8叫我。

642
00:31:00,410 --> 00:31:02,380
OK，而是等待，如何做
该得到的价值？

643
00:31:02,380 --> 00:31:04,130
让我看一下功能线12。

644
00:31:04,130 --> 00:31:05,760
>> 在第12行，我们已接到负int类型。

645
00:31:05,760 --> 00:31:08,190
不带任何投入，
并返回一个int，OK。

646
00:31:08,190 --> 00:31:10,929
我宣布第14行变量n。

647
00:31:10,929 --> 00:31:12,220
它要存储的整数。

648
00:31:12,220 --> 00:31:13,760
这就是我想要的。

649
00:31:13,760 --> 00:31:18,480
>> 所以，做以下，而ñis--让
我撤销了什么我修复已经作出。

650
00:31:18,480 --> 00:31:22,710
所以，当n大于
0，打印出n，则确定。

651
00:31:22,710 --> 00:31:25,170
然后调用INT得到存储在n个。

652
00:31:25,170 --> 00:31:30,160
然后检查是否n为0，
n是不是 - 它就在那里。

653
00:31:30,160 --> 00:31:31,910
所以，再一次，你不
需要实际的鸭子。

654
00:31:31,910 --> 00:31:35,650
但只是走自己通过
你的代码作为一种智力活动

655
00:31:35,650 --> 00:31:37,720
往往会帮你
意识到发生了什么事情，

656
00:31:37,720 --> 00:31:41,170
而不是仅仅做一些
这样，盯着屏幕，

657
00:31:41,170 --> 00:31:43,720
而不是说自己通过
它，这是实话不

658
00:31:43,720 --> 00:31:46,270
近作为有效的技术。

659
00:31:46,270 --> 00:31:48,620
所以你有它，一
不同的技术数

660
00:31:48,620 --> 00:31:52,102
其实对于调试代码
和找茬，所有这一切

661
00:31:52,102 --> 00:31:54,810
应该在你的工具箱的工具
让你不熬夜，

662
00:31:54,810 --> 00:31:57,660
尤其是，你在用餐
厅，或者在办公时间内，

663
00:31:57,660 --> 00:32:00,368
撞你的头靠在
墙，试图解决一些问题。

664
00:32:00,368 --> 00:32:02,020
意识到有软件工具。

665
00:32:02,020 --> 00:32:03,720
有橡皮鸭子的工具。

666
00:32:03,720 --> 00:32:09,630
而且还有的全体员工
支持等着伸出援助之手。

667
00:32:09,630 --> 00:32:13,120
>> 所以，现在的问题的词
套，和以什么我们希望您

668
00:32:13,120 --> 00:32:15,620
摆脱他们，怎么样
我们去评估。

669
00:32:15,620 --> 00:32:17,680
每个课程的教学大纲，
CS50的问题集

670
00:32:17,680 --> 00:32:22,320
在四个主坐标轴进行评估，因此，
到speak--范围，正确性，设计，

671
00:32:22,320 --> 00:32:23,060
和风格。

672
00:32:23,060 --> 00:32:25,910
和范围只是指的是多少
这块你咬掉？

673
00:32:25,910 --> 00:32:28,080
如何太大的问题，你试过吗？

674
00:32:28,080 --> 00:32:30,110
努力什么级别
你表现？

675
00:32:30,110 --> 00:32:35,750
>> 正确性，确实该程序作为工作
它应该每CS50规格

676
00:32:35,750 --> 00:32:38,640
当你提供一定的投入
或某些输出回来了吗？

677
00:32:38,640 --> 00:32:41,130
设计是最主观的人。

678
00:32:41,130 --> 00:32:43,360
而且它是一个将
时间最长学习

679
00:32:43,360 --> 00:32:47,220
最长任教，在
只要它归结为，

680
00:32:47,220 --> 00:32:49,530
如何写得好是你的代码？

681
00:32:49,530 --> 00:32:52,920
>> 这是一件事，只是打印正确
输出或返回正确的价值观。

682
00:32:52,920 --> 00:32:55,400
但是你在做它作为
最有效的方式？

683
00:32:55,400 --> 00:32:58,210
你这样做除法
与征服，或二进制

684
00:32:58,210 --> 00:33:01,500
搜索，因为我们很快就会看到，我们没有
两个星期前用手机书？

685
00:33:01,500 --> 00:33:04,670
有没有更好的办法来解决
问题比你现在有吗？

686
00:33:04,670 --> 00:33:06,380
这对于更好的设计的机会。

687
00:33:06,380 --> 00:33:08,530
>> 然后style--如何
漂亮是你的代码？

688
00:33:08,530 --> 00:33:12,370
你会发现，我敢
讲究缩进我的代码，

689
00:33:12,370 --> 00:33:15,300
并确保我的变量
合理地命名。 N，

690
00:33:15,300 --> 00:33:19,660
而总之，就是一个好名字
电话号码，我为计数整数，

691
00:33:19,660 --> 00:33:20,727
S代表字符串。

692
00:33:20,727 --> 00:33:22,560
我们可以有更长
变量名风格。

693
00:33:22,560 --> 00:33:25,500
风格是多么好
没有你的代码看？

694
00:33:25,500 --> 00:33:26,600
而且是怎么读？

695
00:33:26,600 --> 00:33:29,650
>> 随着时间的推移，你的助教
和转录因子会在使用过程中做

696
00:33:29,650 --> 00:33:31,870
是为您提供与
一种定性反馈

697
00:33:31,870 --> 00:33:34,330
让您获得更好的
在这些不同的方面。

698
00:33:34,330 --> 00:33:37,510
而在我们如何计
评价每个这些轴，

699
00:33:37,510 --> 00:33:40,080
它通常非常少
水桶，让你，一般来说，

700
00:33:40,080 --> 00:33:41,680
了解你正在做的有多好感。

701
00:33:41,680 --> 00:33:45,680
而且，事实上，如果你收到的分数
其中任何axes--正确性，设计

702
00:33:45,680 --> 00:33:49,659
和风格especially--这个数字
通常为1和5之间。

703
00:33:49,659 --> 00:33:52,450
而且，从字面上看，如果你得到
3公司在学期的开始，

704
00:33:52,450 --> 00:33:53,977
这是一个非常好的事情。

705
00:33:53,977 --> 00:33:55,810
这意味着仍然有
改进的余地，

706
00:33:55,810 --> 00:33:58,490
你会希望在
服用类首次。

707
00:33:58,490 --> 00:34:01,820
有希望的天花板一些位
到你渴望深远。

708
00:34:01,820 --> 00:34:03,970
并因此让3对
最早的作品，

709
00:34:03,970 --> 00:34:06,550
如果不是一些2的和4的，
的确是一件好事。

710
00:34:06,550 --> 00:34:08,880
这是很有效范围内，
在良好的预期。

711
00:34:08,880 --> 00:34:11,421
>> 如果你的心是赛车，等待
一分钟，五分之三。

712
00:34:11,421 --> 00:34:12,620
这的确是一个6出10。

713
00:34:12,620 --> 00:34:13,560
这是60％。

714
00:34:13,560 --> 00:34:14,830
我的上帝，这是一个F.

715
00:34:14,830 --> 00:34:15,870
>> 不是。

716
00:34:15,870 --> 00:34:17,600
这不，其实这一点。

717
00:34:17,600 --> 00:34:22,710
相反，它是改善的机会
在这学期的课程。

718
00:34:22,710 --> 00:34:25,580
如果你得到一些
标准普尔，这些都是一个机会

719
00:34:25,580 --> 00:34:29,199
采取办公时间的优势，
当然部分和其他资源。

720
00:34:29,199 --> 00:34:32,840
>> 最好的是一个机会，真的，
是的你刚刚多远骄傲

721
00:34:32,840 --> 00:34:34,520
过来学期的课程。

722
00:34:34,520 --> 00:34:38,199
所以一定要明白，如果没有
否则，三是良好的。

723
00:34:38,199 --> 00:34:40,179
它允许增长空间随着时间的推移。

724
00:34:40,179 --> 00:34:43,090
>> 至于这些轴如何
加权，实事求是你

725
00:34:43,090 --> 00:34:46,745
会花大部分的时间越来越
事情要工作，更谈不上正常。

726
00:34:46,745 --> 00:34:49,120
因此正确性往往
进行加权的多数，与

727
00:34:49,120 --> 00:34:51,360
三这个乘法因素。

728
00:34:51,360 --> 00:34:54,659
设计也很重要，但
你不一定什么

729
00:34:54,659 --> 00:34:58,220
花费所有这些小时
试图让事情刚参加工作。

730
00:34:58,220 --> 00:35:00,019
>> 所以，它的权重
多了几分淡然。

731
00:35:00,019 --> 00:35:01,560
然后风格加权最少。

732
00:35:01,560 --> 00:35:03,710
尽管这是毫不逊色
重要的根本，

733
00:35:03,710 --> 00:35:05,990
它只是，也许，
最简单的事情做对，

734
00:35:05,990 --> 00:35:08,440
模仿的例子，我们
做讲座和部分，

735
00:35:08,440 --> 00:35:11,080
事情很好
缩进和评论，

736
00:35:11,080 --> 00:35:14,320
等是最简单的中
要做的事情和得到的权利。

737
00:35:14,320 --> 00:35:16,960
从而这样，实现
这些都是分

738
00:35:16,960 --> 00:35:19,000
是比较容易掌握。

739
00:35:19,000 --> 00:35:22,360
>> 而现在一个字上
this--学术诚信。

740
00:35:22,360 --> 00:35:25,150
所以每场的
教学大纲，你会看到

741
00:35:25,150 --> 00:35:27,630
该课程具有相当
解决此语位。

742
00:35:27,630 --> 00:35:31,380
而且课程需要的问​​题
学术诚信颇为重视。

743
00:35:31,380 --> 00:35:33,450
>> 我们有区别，
是好还是坏，

744
00:35:33,450 --> 00:35:36,570
具有发送的每一年
学生纪律处分

745
00:35:36,570 --> 00:35:39,670
比大多数其他任何
当然，我所知道的。

746
00:35:39,670 --> 00:35:42,580
这不一定
指示该事实

747
00:35:42,580 --> 00:35:46,340
即CS的学生，或学生CS50，是
任何低于你的同学诚实的。

748
00:35:46,340 --> 00:35:49,090
但现实的情况，在这
世界，电子，我们只是

749
00:35:49,090 --> 00:35:50,990
有技术
意味着检测这一点。

750
00:35:50,990 --> 00:35:53,360
>> 重要的是要我们
跨类公平

751
00:35:53,360 --> 00:35:58,550
我们做这个检测，提高
这个问题时，我们看到的东西。

752
00:35:58,550 --> 00:36:01,980
而刚刚画一幅画，真
帮助这样的事情在下沉，

753
00:36:01,980 --> 00:36:04,600
这些都是数字
学生在过去的10年

754
00:36:04,600 --> 00:36:07,610
已经参与了一些
学术诚信等问题，

755
00:36:07,610 --> 00:36:10,990
与一些32名学生
从2015年秋天，这

756
00:36:10,990 --> 00:36:13,760
是说我们需要做
此事非常重视。

757
00:36:13,760 --> 00:36:18,380
而最终，这些数字组成，
最近，约3％，4％左右

758
00:36:18,380 --> 00:36:19,120
之类的。

759
00:36:19,120 --> 00:36:25,220
>> 因此，对于超级广大学生
看来，线条清晰。

760
00:36:25,220 --> 00:36:27,940
但千万记住这
介意，尤其是晚

761
00:36:27,940 --> 00:36:32,080
晚上用时挣扎
一些解决问题的方法集，

762
00:36:32,080 --> 00:36:34,830
有机制
为让自己更好

763
00:36:34,830 --> 00:36:37,870
支持可能比你
想，即使在那个时刻。

764
00:36:37,870 --> 00:36:40,514
要知道，当我们收到
学生提交的作业，我们跨越

765
00:36:40,514 --> 00:36:43,430
今年比较各提交
较去年每提交，

766
00:36:43,430 --> 00:36:47,590
对从2007年的每提交，
既然，看着，还有，

767
00:36:47,590 --> 00:36:49,931
代码库在线，
论坛，招聘网站。

768
00:36:49,931 --> 00:36:51,806
我们提到这一点，
真的，所有着想

769
00:36:51,806 --> 00:36:56,040
充分披露，如果
别人可以在网上找到它，

770
00:36:56,040 --> 00:36:57,880
当然，我们也能做到的过程。

771
00:36:57,880 --> 00:37:00,100
但是，真的，精神
的过程归结

772
00:37:00,100 --> 00:37:01,650
在教学大纲这一条款。

773
00:37:01,650 --> 00:37:03,670
这真的是正义的，是合理的。

774
00:37:03,670 --> 00:37:06,680
>> 如果我们要详细说说
只有一个多一点的语言，

775
00:37:06,680 --> 00:37:09,770
意识到所有的实质
您提交给本课程的工作

776
00:37:09,770 --> 00:37:10,954
必须是你自己。

777
00:37:10,954 --> 00:37:13,870
但是内的，也肯定有
机会和鼓励，

778
00:37:13,870 --> 00:37:17,300
在转向和教学价值
others--自己的课题组，中科院，

779
00:37:17,300 --> 00:37:20,760
助教，和其他类，
支持，更不用说朋友

780
00:37:20,760 --> 00:37:23,547
和室友谁研究
CS和编程之前。

781
00:37:23,547 --> 00:37:25,130
等有该津贴。

782
00:37:25,130 --> 00:37:28,180
和拇指的一般规则
是this--寻求帮助的时候，

783
00:37:28,180 --> 00:37:31,470
你可能会显示你的代码给别人，
但你可能无法查看他们的。

784
00:37:31,470 --> 00:37:34,880
所以，即使你在办公时间内，
或者在D厅，或其他地方

785
00:37:34,880 --> 00:37:37,450
一些件套的工作，
旁边一个朋友，其工作

786
00:37:37,450 --> 00:37:40,160
是完全正常，在
一天的工作结束

787
00:37:40,160 --> 00:37:43,034
最终应属于每个
你分别与不

788
00:37:43,034 --> 00:37:45,700
有一些协同努力，
除了最后的项目中，

789
00:37:45,700 --> 00:37:47,410
它允许和鼓励。

790
00:37:47,410 --> 00:37:49,830
>> 要知道，如果你是
东西挣扎

791
00:37:49,830 --> 00:37:52,520
和你的朋友恰好
是在这个更好的，你，

792
00:37:52,520 --> 00:37:55,130
或者在这个问题比你强，
或者稍远一点比你提前，

793
00:37:55,130 --> 00:37:57,330
这是完全合理的转
你的朋友说，哎，

794
00:37:57,330 --> 00:38:00,480
你不介意看我的代码在这里，
帮我找出我的问题是什么？

795
00:38:00,480 --> 00:38:03,760
并希望在
教学价值的兴趣

796
00:38:03,760 --> 00:38:07,040
那位朋友不只是
说，哦，这样做，而是

797
00:38:07,040 --> 00:38:09,917
什么是你缺少行
6，或者类似的东西？

798
00:38:09,917 --> 00:38:12,000
但是该解决方案是不
为朋友在你身边

799
00:38:12,000 --> 00:38:15,617
说，哦，这里，让我拉
这件事，并展示我的解决方案给你。

800
00:38:15,617 --> 00:38:16,450
所以这是该行。

801
00:38:16,450 --> 00:38:18,670
你看你的代码
其他人，但你可能不

802
00:38:18,670 --> 00:38:22,350
查看他们的，受其他
在使用过程中的教学大纲约束。

803
00:38:22,350 --> 00:38:24,760
>> 所以，千万记住这
所谓遗憾子句

804
00:38:24,760 --> 00:38:27,560
在使用过程中的教学大纲为好，
如果你犯了一些行为的

805
00:38:27,560 --> 00:38:30,476
是不是合理的，但它带来
课程的负责人的注意

806
00:38:30,476 --> 00:38:34,240
在72小时内，该过程
可处以当地制裁措施

807
00:38:34,240 --> 00:38:37,380
可以包括不令人满意的或
不及格提交的工作。

808
00:38:37,380 --> 00:38:41,410
但当然不会指的
此事作进一步的纪律处分，

809
00:38:41,410 --> 00:38:43,010
除了在行为屡禁不止的情况。

810
00:38:43,010 --> 00:38:46,632
换句话说，如果你做一些
愚蠢的，特别是深夜，决策

811
00:38:46,632 --> 00:38:49,340
该第二天早上，两天
以后，你醒来时会发现，

812
00:38:49,340 --> 00:38:50,870
我在想什么？

813
00:38:50,870 --> 00:38:53,890
你做CS50有一个出口
固定的问题

814
00:38:53,890 --> 00:38:57,170
和拥有了它，让我们
会中途遇见你和处理

815
00:38:57,170 --> 00:39:01,500
与它在一个问题，既
教育和为贵有价值的，

816
00:39:01,500 --> 00:39:04,200
但在某些方面仍然惩罚。

817
00:39:04,200 --> 00:39:08,590
而现在，采取边关闭，这一点。

818
00:39:08,590 --> 00:39:10,570
>> [视频回放]

819
00:39:10,570 --> 00:39:13,540
>> [音乐]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [结束播放]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN：好吧，我们又回来了。

823
00:40:00,490 --> 00:40:03,680
现在我们来看看之一
首先我们的现实世界中域

824
00:40:03,680 --> 00:40:08,720
在CS50，艺术加密的，
发送和接收的技术

825
00:40:08,720 --> 00:40:11,840
秘密信息，加密
如果你愿意的消息，

826
00:40:11,840 --> 00:40:17,060
如果你只能被破译
发件人有一些关键因素

827
00:40:17,060 --> 00:40:18,030
为好。

828
00:40:18,030 --> 00:40:22,120
因此，要鼓励这一点，我们将采取
一看这东西在这里，

829
00:40:22,120 --> 00:40:26,750
这是一个示例
秘密的解码器环的

830
00:40:26,750 --> 00:40:34,042
可为了搞清楚使用
什么是秘密信息实际上是。

831
00:40:34,042 --> 00:40:35,750
其实，早在
当天在小学，

832
00:40:35,750 --> 00:40:38,787
如果你发送的秘密消息
一些朋友或在课堂上的一些好感，

833
00:40:38,787 --> 00:40:40,620
你可能认为
你被聪明

834
00:40:40,620 --> 00:40:46,530
在您的纸条变化的，
像，A到B和B到C和C至D，

835
00:40:46,530 --> 00:40:47,590
等等。

836
00:40:47,590 --> 00:40:50,300
但你实际上是加密
您的信息，甚至

837
00:40:50,300 --> 00:40:53,300
如果这是一个有点琐碎，不
硬的教师来实现，

838
00:40:53,300 --> 00:40:55,675
好吧，如果你只是改变
B到A和C到B，

839
00:40:55,675 --> 00:40:57,550
你居然找出
什么消息了，

840
00:40:57,550 --> 00:40:59,700
但你在加密信息。

841
00:40:59,700 --> 00:41:03,420
>> 你只是做
简单地说，就像拉尔夫在这里

842
00:41:03,420 --> 00:41:07,934
在一个著名的电影，播放
相当多广告nauseum每年冬天。

843
00:41:07,934 --> 00:41:08,600
[视频回放]

844
00:41:08,600 --> 00:41:11,180
-be它众所周知，
拉尔夫·帕克特此

845
00:41:11,180 --> 00:41:14,070
任命小的一员
孤儿安妮秘密圈

846
00:41:14,070 --> 00:41:17,700
并有权所有荣誉
并与之发生利益。

847
00:41:17,700 --> 00:41:24,340
>> -Signed，小孤儿安妮，
会签皮埃尔·安德烈，在墨水。

848
00:41:24,340 --> 00:41:27,160
荣誉和利益，
在已经九岁的时候。

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [他们咆哮]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-来吧。

853
00:41:34,250 --> 00:41:35,210
让我们开始吧。

854
00:41:35,210 --> 00:41:39,530
我并不需要所有的爵士乐
关于走私和海盗。

855
00:41:39,530 --> 00:41:41,660
>>  - 听明天晚上
结论冒险

856
00:41:41,660 --> 00:41:43,880
黑色的海盗船。

857
00:41:43,880 --> 00:41:46,650
现在，它的时间为
安妮的秘密信息

858
00:41:46,650 --> 00:41:49,840
为你秘社的成员。

859
00:41:49,840 --> 00:41:53,570
请记住，孩子，只有成员
安妮的秘密圈

860
00:41:53,570 --> 00:41:56,140
可以解码安妮的秘密信息。

861
00:41:56,140 --> 00:42:00,340
>> 请记住，安妮取决于你。

862
00:42:00,340 --> 00:42:02,880
设置你的引脚B2。

863
00:42:02,880 --> 00:42:05,230
这里是该消息。

864
00:42:05,230 --> 00:42:06,090
12，11--

865
00:42:06,090 --> 00:42:10,250
>> -I我在，我的第一次秘密会晤。

866
00:42:10,250 --> 00:42:13,890
>> -14，11，18，16。

867
00:42:13,890 --> 00:42:15,780
>> -Pierre在今晚的声音很大。

868
00:42:15,780 --> 00:42:19,000
我可以告诉大家，今晚的
信息是非常重要的。

869
00:42:19,000 --> 00:42:22,694
>> -3，25日，这是一个消息
从安妮自己。

870
00:42:22,694 --> 00:42:23,860
记住，不要告诉任何人。

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90秒后，我的唯一
房间在房子里一个男孩九

873
00:42:32,930 --> 00:42:37,040
可以坐在隐私和解码。

874
00:42:37,040 --> 00:42:39,730
啊哈，B！

875
00:42:39,730 --> 00:42:42,360
我去了下，E.

876
00:42:42,360 --> 00:42:44,520
>> 第一个字是可以。

877
00:42:44,520 --> 00:42:49,032
S，它现在更容易到来，U，25--

878
00:42:49,032 --> 00:42:51,733
>> 哦，来吧，拉尔夫，我得走了！

879
00:42:51,733 --> 00:42:53,688
>> -I'll被降权，马！

880
00:42:53,688 --> 00:42:54,188
啧啧飕飕！

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T，O，可以肯定的中场休息，一定要什么呢？

883
00:43:04,060 --> 00:43:05,970
什么是小孤儿
安妮想说什么？

884
00:43:05,970 --> 00:43:07,264
一定要什么呢？

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie，安迪已经得​​到了
走，请你出来？

886
00:43:09,634 --> 00:43:10,480
>> -All权，马！

887
00:43:10,480 --> 00:43:12,880
我马上就出来！

888
00:43:12,880 --> 00:43:14,550
>> -I接近现在是越来越。

889
00:43:14,550 --> 00:43:16,620
张力是可怕的。

890
00:43:16,620 --> 00:43:17,720
它以前如何？

891
00:43:17,720 --> 00:43:20,170
这个星球的命运
在资产负债可能会挂起。

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie！

893
00:43:20,670 --> 00:43:23,170
安迪的得走了！

894
00:43:23,170 --> 00:43:26,890
>> -I'll是正确的，对于哭出声来！

895
00:43:26,890 --> 00:43:32,680
>> -Almost在那里，我的手指飞去，我的脑海里
是钢陷阱，每一个毛孔振动。

896
00:43:32,680 --> 00:43:37,198
这几乎是明确的，是的，是的，是的。

897
00:43:37,198 --> 00:43:43,091
>> -be一定要喝你的阿华田。

898
00:43:43,091 --> 00:43:43,590
阿华田？

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
一个最低级的商业？

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
王八蛋。

903
00:43:54,227 --> 00:43:54,810
[结束播放]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN：OK，所以
这是一个很长的路

905
00:43:57,390 --> 00:44:00,660
引入密码学，
也阿华田。

906
00:44:00,660 --> 00:44:04,470
事实上，从这个古老的广告
在这里，为什么阿华田这么好？

907
00:44:04,470 --> 00:44:09,470
这是成熟的一种浓缩提取
大麦芽，纯奶油牛奶，

908
00:44:09,470 --> 00:44:14,360
并特地准备了可可，一起
天然磷脂和维生素。

909
00:44:14,360 --> 00:44:18,240
它是与进一步强化
额外的维生素B和D，百胜。

910
00:44:18,240 --> 00:44:21,600
你仍然可以得到它，很显然，
在亚马逊，因为我们在这里做。

911
00:44:21,600 --> 00:44:24,810
>> 但是，这里的动机是为了
密码学介绍，具体

912
00:44:24,810 --> 00:44:28,340
已知类型的加密的
作为密钥加密。

913
00:44:28,340 --> 00:44:34,284
和顾名思义，整个
密钥加密系统的安全性，

914
00:44:34,284 --> 00:44:36,200
如果你愿意，一种方法
只是扰

915
00:44:36,200 --> 00:44:40,960
两个人之间的信息是，
只有发件人和只有收件人

916
00:44:40,960 --> 00:44:46,980
知道一个秘密key--一定的价值，一些
秘密短语，一些秘密号码，即

917
00:44:46,980 --> 00:44:50,660
让他们来加密
和解密信息。

918
00:44:50,660 --> 00:44:53,470
和密码，说真的，
只是这个0的一周。

919
00:44:53,470 --> 00:44:56,715
>> 这是一个问题，那里的投入，
像英语的实际消息

920
00:44:56,715 --> 00:44:59,340
或任何语言，你
要发送给别人上课，

921
00:44:59,340 --> 00:45:00,580
或在互联网上。

922
00:45:00,580 --> 00:45:03,840
有一些输出，这是会
要被扰频的信息，即你

923
00:45:03,840 --> 00:45:05,250
希望收件人接收。

924
00:45:05,250 --> 00:45:07,405
而且，即使有人在
中间接收它太，

925
00:45:07,405 --> 00:45:09,780
你不希望它们
一定能够解密，

926
00:45:09,780 --> 00:45:12,840
因为这里面
黑盒子，或算法，

927
00:45:12,840 --> 00:45:17,650
是某种机制，有的一步一步
指令，采取该输入

928
00:45:17,650 --> 00:45:20,710
并将其转换成
输出，在希望以安全的方式。

929
00:45:20,710 --> 00:45:23,640
>> 并且，实际上，有一些
词汇在这个世界上，如下所示。

930
00:45:23,640 --> 00:45:26,100
纯文本是一个字
计算机科学家会

931
00:45:26,100 --> 00:45:28,449
用它来描述输入
消息，喜欢英语

932
00:45:28,449 --> 00:45:31,240
或任何语言，你实际上
要发送到其他人。

933
00:45:31,240 --> 00:45:35,450
然后密文是加扰
给加密，或加密，

934
00:45:35,450 --> 00:45:36,520
其版本。

935
00:45:36,520 --> 00:45:38,750
>> 但是这里有一种其它成分。

936
00:45:38,750 --> 00:45:43,200
还有另一个输入
秘密密钥加密。

937
00:45:43,200 --> 00:45:45,200
这就是密钥本身，
这是，通常，

938
00:45:45,200 --> 00:45:48,930
正如我们所看到的，一数，或
字母或字，无论

939
00:45:48,930 --> 00:45:51,980
该算法它实际上是期待。

940
00:45:51,980 --> 00:45:53,870
>> 你如何解密信息？

941
00:45:53,870 --> 00:45:55,110
你怎么解读呢？

942
00:45:55,110 --> 00:45:57,950
嗯，你只是扭转
输出和输入。

943
00:45:57,950 --> 00:46:00,900
>> 换句话说，一旦有人
收到加密邮件，

944
00:46:00,900 --> 00:46:03,740
他或她只是有
要知道，相​​同的密钥。

945
00:46:03,740 --> 00:46:05,700
他们已经收到的密文。

946
00:46:05,700 --> 00:46:09,530
并通过封堵这两个
输入到加密系统，

947
00:46:09,530 --> 00:46:14,260
算法，这种黑匣子，出
应该原始明文。

948
00:46:14,260 --> 00:46:17,830
所以这是非常高的水平
鉴于什么密码实际上是

949
00:46:17,830 --> 00:46:18,590
所有关于。

950
00:46:18,590 --> 00:46:20,030
>> 因此，让我们到达那里。

951
00:46:20,030 --> 00:46:22,700
现在让我们看看下面
东西引擎盖

952
00:46:22,700 --> 00:46:26,000
我们一直理所当然的
过去的一周，而本次会议

953
00:46:26,000 --> 00:46:27,629
这里 - 字符串。

954
00:46:27,629 --> 00:46:30,295
在一天结束的字符串
仅仅是一个字符序列。

955
00:46:30,295 --> 00:46:33,610
>> 这可能是世界您好，或
你好Zamyla，或什么的。

956
00:46:33,610 --> 00:46:37,050
但是，这是什么意思
是字符序列？

957
00:46:37,050 --> 00:46:41,520
事实上，CS50库给出
我们称为串的数据类型。

958
00:46:41,520 --> 00:46:45,140
>> 但实际上，没有
这样的事情在C.字符串

959
00:46:45,140 --> 00:46:49,450
这真的只是一个序列
人品，人品，性格，

960
00:46:49,450 --> 00:46:52,180
性格，背，背，
回来，回来，内页

961
00:46:52,180 --> 00:46:54,650
您的计算机的内存或RAM。

962
00:46:54,650 --> 00:46:58,940
我们会更深入，在
当我们看内存本身的未来，

963
00:46:58,940 --> 00:47:02,030
与利用，并且
所涉及的威胁。

964
00:47:02,030 --> 00:47:04,100
>> 但是，让我们考虑用字符串Zamyla。

965
00:47:04,100 --> 00:47:07,480
如此只是名字
这里的人，Zamyla，

966
00:47:07,480 --> 00:47:12,030
即序列
字符，Z-A-M-Y-L-A。

967
00:47:12,030 --> 00:47:16,020
现在让我们假设Zamyla的名字
正被存储在计算机内的

968
00:47:16,020 --> 00:47:16,880
程序。

969
00:47:16,880 --> 00:47:20,830
>> 好了，按理说我们应该
可以看看那些字符

970
00:47:20,830 --> 00:47:21,590
个别。

971
00:47:21,590 --> 00:47:24,710
所以我只是要画一个小
在这里Zamyla的名称框中。

972
00:47:24,710 --> 00:47:31,580
而且它是在C的情况下，当你
有一个字符串，如Zamyla--也许

973
00:47:31,580 --> 00:47:34,940
该字符串已经从回来
比如找到字符串的函数，

974
00:47:34,940 --> 00:47:38,540
实际上你可以操纵
通过它的性格特征。

975
00:47:38,540 --> 00:47:42,070
>> 现在，这是有密切关系的
谈话在另一方面，由于

976
00:47:42,070 --> 00:47:46,420
在密码学，如果你想改变
A到B和B到C和C到D，

977
00:47:46,420 --> 00:47:49,650
等，则需要能够
看单个字符

978
00:47:49,650 --> 00:47:50,190
在一个字符串。

979
00:47:50,190 --> 00:47:52,695
你需要能够改变
在Z别的东西时，A

980
00:47:52,695 --> 00:47:55,280
别的东西，并购来
别的东西，等等。

981
00:47:55,280 --> 00:47:58,000
因此，我们需要一种方法，
编程，所以

982
00:47:58,000 --> 00:48:03,020
可以说，在C能够改变
并期待在单个字母。

983
00:48:03,020 --> 00:48:05,690
我们可以做到这一点如下。

984
00:48:05,690 --> 00:48:08,340
>> 让我去头回CS50 IDE。

985
00:48:08,340 --> 00:48:11,130
让我先走
并创建一个新的文件

986
00:48:11,130 --> 00:48:16,134
我会打电话给这次string0，
作为第一个这样的例子，C点。

987
00:48:16,134 --> 00:48:18,300
而且我要继续前进
鞭打它，如下所示。

988
00:48:18,300 --> 00:48:22,870
>> 所以包括CS50.h和
然后包括标准io.h，

989
00:48:22,870 --> 00:48:25,990
其中，我几乎总是会
是使用在我的节目中，至少

990
00:48:25,990 --> 00:48:26,780
原来。

991
00:48:26,780 --> 00:48:32,180
诠释主要作废，然后在这里我
要做得到的字符串得到的字符串。

992
00:48:32,180 --> 00:48:35,260
然后我要去
继续前进，做到这一点。

993
00:48:35,260 --> 00:48:37,460
我要先走
并且，作为一个全面的检查，

994
00:48:37,460 --> 00:48:43,607
只是说，你好，百分之S，
分号，使串0。

995
00:48:43,607 --> 00:48:44,690
嗯哦，我做了什么吗？

996
00:48:44,690 --> 00:48:45,930
哦，我没有插上。

997
00:48:45,930 --> 00:48:48,120
所以，经验教训，即
不是故意的。

998
00:48:48,120 --> 00:48:52,480
>> 因此错误，百分之更多
转换不是数据参数。

999
00:48:52,480 --> 00:48:54,940
这是哪里，
线7-- OK，所以我有，

1000
00:48:54,940 --> 00:48:56,690
报价引文结束，这是
我的字符串的printf。

1001
00:48:56,690 --> 00:48:58,151
我有一个百分号。

1002
00:48:58,151 --> 00:48:59,650
但我错过了第二个参数。

1003
00:48:59,650 --> 00:49:03,190
>> 我错过了逗号s，这
我没有在前面的例子。

1004
00:49:03,190 --> 00:49:06,650
因此，一个很好的机会来解决
多了一个错误，不慎。

1005
00:49:06,650 --> 00:49:09,950
现在让我跑
string0，键入Zamyla。

1006
00:49:09,950 --> 00:49:10,970
OK，你好Zamyla。

1007
00:49:10,970 --> 00:49:14,144
>> 因此，我们运行该种方案
现在几个不同的时间。

1008
00:49:14,144 --> 00:49:16,310
但是，让我们做一个东西
有点不同这一次。

1009
00:49:16,310 --> 00:49:19,450
而不是仅仅打印Zamyla的
整个名称用了printf的，

1010
00:49:19,450 --> 00:49:21,350
让我们做吧逐个字符。

1011
00:49:21,350 --> 00:49:22,700
>> 我将使用一个for循环。

1012
00:49:22,700 --> 00:49:26,160
我要去给自己
计数变量，叫我。

1013
00:49:26,160 --> 00:49:33,530
而且我要保持迭代，所以
只要i小于s的长度。

1014
00:49:33,530 --> 00:49:35,930
>> 事实证明，我们没
这样做最后一次，

1015
00:49:35,930 --> 00:49:39,100
将c自带
函数调用斯特林。

1016
00:49:39,100 --> 00:49:42,690
早在一天，并在一般
仍然实现功能的时候，

1017
00:49:42,690 --> 00:49:45,405
人们往往会选择很
简洁的名称那种声音

1018
00:49:45,405 --> 00:49:48,280
就像你想要什么，即使它是
缺少了几个元音字母或字母。

1019
00:49:48,280 --> 00:49:50,660
所以，斯特林是
一个函数的名称，用以

1020
00:49:50,660 --> 00:49:53,880
需要之间的争论
括号这应该是一个字符串。

1021
00:49:53,880 --> 00:49:56,910
它只是返回一个整数，
该字符串的长度。

1022
00:49:56,910 --> 00:50:00,580
>> 因此，这对7号线环是怎么回事
开始计算在i等于0。

1023
00:50:00,580 --> 00:50:02,530
这将增加
我在每次迭代

1024
00:50:02,530 --> 00:50:04,350
1，因为我们已经做了几次。

1025
00:50:04,350 --> 00:50:06,780
但它会只做
此直到点

1026
00:50:06,780 --> 00:50:09,660
当我是长度
的字符串本身。

1027
00:50:09,660 --> 00:50:14,520
>> 因此，这是一种方式，最终
遍历字符

1028
00:50:14,520 --> 00:50:17,430
在字符串中原样如下。

1029
00:50:17,430 --> 00:50:20,670
我要打印出不
整个字符串，但％的C，

1030
00:50:20,670 --> 00:50:22,860
单个字符
其次是一个新行。

1031
00:50:22,860 --> 00:50:24,880
然后我要去
继续前进，我需要

1032
00:50:24,880 --> 00:50:29,080
说我要打印
的S i个字符。

1033
00:50:29,080 --> 00:50:33,450
>> 因此，如果i是指示可变
串，其中的索引

1034
00:50:33,450 --> 00:50:37,230
你在这，我需要能够
说，给我S的第i个字符。

1035
00:50:37,230 --> 00:50:40,390
和c具有这样的一种方式
这跟方括号。

1036
00:50:40,390 --> 00:50:43,679
您只需说出名字了
串，在此情况下为s。

1037
00:50:43,679 --> 00:50:46,970
然后你用方括号，这是
通常略高于您的返回键或回车

1038
00:50:46,970 --> 00:50:48,110
键在键盘上。

1039
00:50:48,110 --> 00:50:52,410
然后你放的索引
要打印的字符。

1040
00:50:52,410 --> 00:50:55,960
因此指数将是一个
number-- 0，或1，或2，或3，或点，

1041
00:50:55,960 --> 00:50:57,590
点，点，其他一些数字。

1042
00:50:57,590 --> 00:51:00,920
>> 而且我们要确保它会
是正确的号码，因为我

1043
00:51:00,920 --> 00:51:02,360
从0开始计数。

1044
00:51:02,360 --> 00:51:07,020
而默认情况下，第一个字符
在一个字符串是按照惯例0。

1045
00:51:07,020 --> 00:51:09,230
而第二个字符是支架1。

1046
00:51:09,230 --> 00:51:11,120
和第三个字符是托架2。

1047
00:51:11,120 --> 00:51:13,630
而且你不想去过多
到目前为止，但我们不会因为我们

1048
00:51:13,630 --> 00:51:17,780
要增加只有我，直到
等于字符串的长度。

1049
00:51:17,780 --> 00:51:20,210
并在该点，
这个循环将停止。

1050
00:51:20,210 --> 00:51:25,550
>> 因此，让我继续前进，保存此
程序运行make串0。

1051
00:51:25,550 --> 00:51:28,400
但我搞砸了。

1052
00:51:28,400 --> 00:51:35,390
隐式声明的库函数
与类型，斯特灵和现在such--，

1053
00:51:35,390 --> 00:51:36,430
这听起来很熟悉。

1054
00:51:36,430 --> 00:51:37,440
但它不是printf的。

1055
00:51:37,440 --> 00:51:38,540
而且它不能得到的字符串。

1056
00:51:38,540 --> 00:51:40,480
>> 我没有搞砸的
以同样的方式这一次。

1057
00:51:40,480 --> 00:51:45,100
但是请注意，到这里一点点下降
此外，包含头文件string.h，

1058
00:51:45,100 --> 00:51:47,210
明确规定了
声明斯特林。

1059
00:51:47,210 --> 00:51:48,820
所以实际上是有一个线索。

1060
00:51:48,820 --> 00:51:51,670
>> 的确事实证明
还有另外一个头文件

1061
00:51:51,670 --> 00:51:53,970
我们已经不习惯
在课堂上还没有，但它是

1062
00:51:53,970 --> 00:51:56,480
在这些可用
给你，叫string.h中。

1063
00:51:56,480 --> 00:52:00,930
而在该文件中，文件string.h
是斯特林声明。

1064
00:52:00,930 --> 00:52:05,220
因此，让我继续前进，
保存此，使串

1065
00:52:05,220 --> 00:52:08,040
0--不错，没有错误消息这一次。

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla和
我正要敲回车，

1067
00:52:12,290 --> 00:52:16,710
在这一点上的GetString是怎么回事
返回字符串，把它放在秒。

1068
00:52:16,710 --> 00:52:21,890
然后，对于循环会遍历
以上的s的人物之一的时间，

1069
00:52:21,890 --> 00:52:28,420
并打印，每行一个，因为
我在结束反斜杠ñ。

1070
00:52:28,420 --> 00:52:34,530
所以，我可以省略反斜线
N，然后只打印Zamyla所有

1071
00:52:34,530 --> 00:52:37,460
在同一条线上，
有效地重新实现

1072
00:52:37,460 --> 00:52:38,999
printf的，这是不是所有的有用。

1073
00:52:38,999 --> 00:52:40,540
但在这种情况下，我没有做到这一点。

1074
00:52:40,540 --> 00:52:43,610
其实我已经打印在
字符的时间，每行一个，

1075
00:52:43,610 --> 00:52:45,400
让我们实际看到的效果。

1076
00:52:45,400 --> 00:52:46,900
>> 但是，我在这里要注意的一件事。

1077
00:52:46,900 --> 00:52:48,930
我们会回来的
这在未来的一周。

1078
00:52:48,930 --> 00:52:52,650
事实证明，这
代码可能是马车。

1079
00:52:52,650 --> 00:52:56,560
>> 原来，GET字符串
和生活中的一些其他功能

1080
00:52:56,560 --> 00:53:00,280
不一定总是
回到你期待什么。

1081
00:53:00,280 --> 00:53:03,010
我们从去年一流知道
时间这一点，得到

1082
00:53:03,010 --> 00:53:04,960
串应该返回字符串。

1083
00:53:04,960 --> 00:53:09,900
但是，如果用户键入了这样的
一个长字或段落或文章

1084
00:53:09,900 --> 00:53:13,010
有只是没有足够的
内存在计算机中，以适应它。

1085
00:53:13,010 --> 00:53:15,410
>> 就像，如果出了什么
不对引擎盖底下？

1086
00:53:15,410 --> 00:53:18,400
它可能不会经常发生，
但它可能发生一次

1087
00:53:18,400 --> 00:53:21,520
在一段时间，非常罕见。

1088
00:53:21,520 --> 00:53:25,460
所以事实证明，GET字符串
喜欢它的功能并不一定

1089
00:53:25,460 --> 00:53:26,380
总是返回字符串。

1090
00:53:26,380 --> 00:53:30,680
他们可能会返回一些错误值，
一些哨兵值这么说，

1091
00:53:30,680 --> 00:53:32,612
指示
出了问题。

1092
00:53:32,612 --> 00:53:35,320
而你只知道这个来自
在课堂上已经学会了，现在，

1093
00:53:35,320 --> 00:53:37,700
还是看了一些文档。

1094
00:53:37,700 --> 00:53:43,120
原来，GET字符串
可以返回一个称为空值。

1095
00:53:43,120 --> 00:53:46,220
null是一个特殊值，我们将
回来在未来的一周。

1096
00:53:46,220 --> 00:53:50,420
但现在，只知道如果我想
要在前进的真正合适

1097
00:53:50,420 --> 00:53:52,650
使用GET字符串，我
不应该只是调用它，

1098
00:53:52,650 --> 00:53:56,870
而盲目使用它的返回值，
相信这是一个字符串。

1099
00:53:56,870 --> 00:53:59,420
>> 我先说，
哎，等一下，只

1100
00:53:59,420 --> 00:54:03,380
继续如果s不等于
空，空在那里，再次

1101
00:54:03,380 --> 00:54:04,660
只是一些特殊的价值。

1102
00:54:04,660 --> 00:54:07,770
而且它是唯一的特别价值，你
需要担心的GET字符串。

1103
00:54:07,770 --> 00:54:10,900
获取字符串要么会
返回一个字符串或空。

1104
00:54:10,900 --> 00:54:17,219
>> 而这个感叹号等号
你可能知道，也许从数学课

1105
00:54:17,219 --> 00:54:20,510
你可能划上等号与
通过它的线，以指示不相等。

1106
00:54:20,510 --> 00:54:23,135
这不是一般的人物
你可以输入你的键盘上。

1107
00:54:23,135 --> 00:54:26,480
因此在大多数编程语言，
当你想说不相等，

1108
00:54:26,480 --> 00:54:29,160
您使用感叹号，
否则称为爆炸。

1109
00:54:29,160 --> 00:54:33,180
所以你说一声等于，这
表示不等于，逻辑上。

1110
00:54:33,180 --> 00:54:38,060
这就像有没有一个更大的
大于或等于，或小于

1111
00:54:38,060 --> 00:54:41,270
等于你的键在键盘上
，做这一切在一个符号。

1112
00:54:41,270 --> 00:54:44,020
所以这就是为什么，在过去的例子，
你做了一个开放的支架，然后

1113
00:54:44,020 --> 00:54:48,670
一个等号，为了做
大于或者说，不到。

1114
00:54:48,670 --> 00:54:49,910
>> 那么，这里的外卖？

1115
00:54:49,910 --> 00:54:53,880
这仅仅是现在的一种方式
引入这种语法，此功能，

1116
00:54:53,880 --> 00:54:57,390
遍历各个
字符串中的字符。

1117
00:54:57,390 --> 00:55:00,260
而且就像那些方
支架让你得到他们，

1118
00:55:00,260 --> 00:55:03,790
考虑这些方括号内
那种暗示在这个底层

1119
00:55:03,790 --> 00:55:06,040
设计，即每
字符串内字符

1120
00:55:06,040 --> 00:55:10,180
是种盒装某处下方
罩在计算机的内存中。

1121
00:55:10,180 --> 00:55:12,340
>> 但是，让我们的这个变体。

1122
00:55:12,340 --> 00:55:14,880
事实证明，这
程序是正确的。

1123
00:55:14,880 --> 00:55:18,810
所以，每CS50的轴评估
代码，这现在是正确的。

1124
00:55:18,810 --> 00:55:22,959
尤其是现在，我检查
空，这个程序应该永不死机。

1125
00:55:22,959 --> 00:55:24,500
而我只知道，从经验。

1126
00:55:24,500 --> 00:55:28,040
但是没有什么别的了
我们真的可以去错在这里。

1127
00:55:28,040 --> 00:55:31,860
但它不是非常精心设计的，
因为让我们回到基础。

1128
00:55:31,860 --> 00:55:34,450
>> 首先，principles--
请问一个for循环吗？

1129
00:55:34,450 --> 00:55:36,290
一个for循环做了三件事。

1130
00:55:36,290 --> 00:55:39,340
它初始化一些
值，如果你是问。

1131
00:55:39,340 --> 00:55:41,770
它检查的条件。

1132
00:55:41,770 --> 00:55:45,380
再经过各
迭代中，每个循环后，

1133
00:55:45,380 --> 00:55:49,330
它增加了一些
值，或值，在这里。

1134
00:55:49,330 --> 00:55:50,600
>> 那么，是什么意思呢？

1135
00:55:50,600 --> 00:55:52,940
我们初始化我为0。

1136
00:55:52,940 --> 00:55:58,610
我们检查并确保i小于
s的长度，这是Z-A-M-Y-L-A，

1137
00:55:58,610 --> 00:55:59,900
所以其小于6。

1138
00:55:59,900 --> 00:56:02,590
而且，事实上，0小于6。

1139
00:56:02,590 --> 00:56:05,580
>> 我们从Zamyla的名字打印出来态。

1140
00:56:05,580 --> 00:56:08,080
然后我们增加我从0到1。

1141
00:56:08,080 --> 00:56:11,290
然后，我们检查，是减少1
比S的长度是多少？

1142
00:56:11,290 --> 00:56:13,270
s的长度为6。

1143
00:56:13,270 --> 00:56:13,950
是的。

1144
00:56:13,950 --> 00:56:16,880
>> 因此，我们在Zamyla的名字，ZA打印。

1145
00:56:16,880 --> 00:56:20,090
我们增加i从0到1，2。

1146
00:56:20,090 --> 00:56:23,720
然后，我们检查，是小于2
Zamyla的名称的长度。

1147
00:56:23,720 --> 00:56:25,380
6-所以2小于6。

1148
00:56:25,380 --> 00:56:30,460
是的，让我们打印出来，现在M在
Zamyla的姓名，第三个字符。

1149
00:56:30,460 --> 00:56:34,110
>> 这里的关键是，在每个
故事的重复，我检查，

1150
00:56:34,110 --> 00:56:37,810
为i小于Zamyla的长度？

1151
00:56:37,810 --> 00:56:40,350
但美中不足的是，
斯特林不是属性。

1152
00:56:40,350 --> 00:56:43,100
那些你们谁编程
之前在Java或其他语言

1153
00:56:43,100 --> 00:56:46,310
可能知道长度的字符串
一个属性，只是一些只读值。

1154
00:56:46,310 --> 00:56:50,220
>> 在这种情况下，C中，如果这是
一个函数，从字面上

1155
00:56:50,220 --> 00:56:53,520
计数的数目
在Zamyla每次字符

1156
00:56:53,520 --> 00:56:54,740
我们调用该函数。

1157
00:56:54,740 --> 00:56:58,500
每次你让计算机使用
斯特林，它采取一看Zamyla，

1158
00:56:58,500 --> 00:57:01,960
并说Z-A-M-Y-L-A，6。

1159
00:57:01,960 --> 00:57:02,962
和它返回6。

1160
00:57:02,962 --> 00:57:04,920
你叫下一次
它里面的for循环，

1161
00:57:04,920 --> 00:57:08,610
它要去看看Zamyla
再次，说Z-A-M-Y-L-A，6。

1162
00:57:08,610 --> 00:57:10,320
而且它会返回6。

1163
00:57:10,320 --> 00:57:12,980
那么什么是愚蠢的这个设计？

1164
00:57:12,980 --> 00:57:17,700
>> 为什么我的代码不出来的5 5
设计现在，可以这么说？

1165
00:57:17,700 --> 00:57:20,600
好吧，我问了
问题不必要的。

1166
00:57:20,600 --> 00:57:23,030
我做更多的工作比我需要。

1167
00:57:23,030 --> 00:57:25,370
>> 因此，即使
答案是正确的，我

1168
00:57:25,370 --> 00:57:29,560
问计算机，什么是
Zamyla的长度再次

1169
00:57:29,560 --> 00:57:31,380
又一次，又一次，又一次？

1170
00:57:31,380 --> 00:57:33,980
那答案是
永远不会改变。

1171
00:57:33,980 --> 00:57:35,900
它总是将是6。

1172
00:57:35,900 --> 00:57:39,730
>> 因此，比这更好的解决办法
会是这样一个版本。

1173
00:57:39,730 --> 00:57:43,390
让我继续前进，把它放在一个
所谓string1.c单独的文件，

1174
00:57:43,390 --> 00:57:44,990
只是为了保持它分开。

1175
00:57:44,990 --> 00:57:47,260
而事实证明，在为
循环，你实际上可以

1176
00:57:47,260 --> 00:57:50,210
同时声明多个变量。

1177
00:57:50,210 --> 00:57:53,460
>> 所以我要保持我并将其设置为0。

1178
00:57:53,460 --> 00:57:56,190
但我也要去
添加一个逗号，并说，

1179
00:57:56,190 --> 00:58:01,050
给我一个叫做变量n，其
值等于S的字符串长度。

1180
00:58:01,050 --> 00:58:09,410
现在，请让我的状态
我只要小​​于n。

1181
00:58:09,410 --> 00:58:14,140
>> 因此，在这种方式中，逻辑是
相同在一天结束。

1182
00:58:14,140 --> 00:58:18,280
但我想起了
值6，在这种情况下。

1183
00:58:18,280 --> 00:58:19,780
什么是Zamyla的名字的长度？

1184
00:58:19,780 --> 00:58:20,860
而我把它以n。

1185
00:58:20,860 --> 00:58:23,050
>> 我还在检查
每次的条件。

1186
00:58:23,050 --> 00:58:24,300
0小于6？

1187
00:58:24,300 --> 00:58:25,600
1小于6？

1188
00:58:25,600 --> 00:58:28,600
是小于6 2，等等？

1189
00:58:28,600 --> 00:58:31,914
>> 但我不要求计算机
又一次，又一次，什么是

1190
00:58:31,914 --> 00:58:33,080
Zamyla的名字的长度？

1191
00:58:33,080 --> 00:58:34,320
什么是Zamyla的名字的长度？

1192
00:58:34,320 --> 00:58:35,986
这是什么Zamyla姓名的长度是多少？

1193
00:58:35,986 --> 00:58:40,440
我从字面上记住的是，第一，
只有回答第二个变量n。

1194
00:58:40,440 --> 00:58:45,280
所以这现在会是不仅
正确，而且精心设计的。

1195
00:58:45,280 --> 00:58:46,670
>> 那么，如何风格？

1196
00:58:46,670 --> 00:58:48,866
我命名我的变量
不错，我会说。

1197
00:58:48,866 --> 00:58:50,240
他们现在是超级简洁。

1198
00:58:50,240 --> 00:58:52,090
这是完全的罚款。

1199
00:58:52,090 --> 00:58:55,120
>> 如果你只有一个
串中的程序，

1200
00:58:55,120 --> 00:58:56,860
你还不如叫它S代表字符串。

1201
00:58:56,860 --> 00:58:59,370
如果你只有一个变量
为程序中的计算，

1202
00:58:59,370 --> 00:59:00,710
你还不如把它叫做我。

1203
00:59:00,710 --> 00:59:03,500
如果你有一个长度，N
超级普遍。

1204
00:59:03,500 --> 00:59:05,800
但我还没有评论我的任何代码。

1205
00:59:05,800 --> 00:59:09,200
>> 我没有通知rea​​der--
不管是我的TF，或TA，

1206
00:59:09,200 --> 00:59:12,460
或者只是colleague--什么是应该
在这个程序中继续。

1207
00:59:12,460 --> 00:59:15,760
因此获得良好的作风，
我愿意这样做

1208
00:59:15,760 --> 00:59:24,580
是this--东西
输入像询问用户。

1209
00:59:24,580 --> 00:59:26,670
而且我可以重写
此任何数量的方式。

1210
00:59:26,670 --> 00:59:35,630
>> 确保S--确保GET
字符串返回的字符串。

1211
00:59:35,630 --> 00:59:40,280
然后在这里 - 这或许
最重要的comment--迭代

1212
00:59:40,280 --> 00:59:44,450
过在一个时间s中一个字符。

1213
00:59:44,450 --> 00:59:47,060
我可以用任何
英语语言的选择

1214
00:59:47,060 --> 00:59:49,650
这里描述每个
的这些代码块。

1215
00:59:49,650 --> 00:59:52,740
>> 请注意，我没有把
在每一行代码注释，

1216
00:59:52,740 --> 00:59:55,690
真的只是在有趣
偏多，那些

1217
00:59:55,690 --> 00:59:59,460
有一定的意义，我可能
想使超清晰的人

1218
00:59:59,460 --> 01:00:00,460
阅读我的代码。

1219
01:00:00,460 --> 01:00:02,920
而你为什么调用get
字符串询问用户输入？

1220
01:00:02,920 --> 01:00:05,450
甚至，一个是不一定
所有的描述。

1221
01:00:05,450 --> 01:00:09,340
但它有助于讲一个故事，因为
在故事的第二行，确保

1222
01:00:09,340 --> 01:00:10,740
得到的字符串返回的字符串。

1223
01:00:10,740 --> 01:00:14,260
>> 而在故事中的第三行是，
遍历s中一个人物

1224
01:00:14,260 --> 01:00:15,380
在一个时间。

1225
01:00:15,380 --> 01:00:17,920
而现在只是良好的措施，
我要继续前进，并添加

1226
01:00:17,920 --> 01:00:24,560
多一条评论，只是
在S打印第i个字符表示。

1227
01:00:24,560 --> 01:00:26,520
现在，我做了什么
在这一天结束了吗？

1228
01:00:26,520 --> 01:00:29,190
>> 我增加了一些英语
词语的注释形式。

1229
01:00:29,190 --> 01:00:32,700
斜线斜线符号意味着，哎，
计算机，这是对人类，

1230
01:00:32,700 --> 01:00:33,820
不是你的，计算机。

1231
01:00:33,820 --> 01:00:35,119
所以他们在逻辑上被忽略。

1232
01:00:35,119 --> 01:00:35,910
他们只是在那里。

1233
01:00:35,910 --> 01:00:39,830
>> 而且，事实上，CS50 IDE显示他们作为
灰色，作为是有用的，但不是关键

1234
01:00:39,830 --> 01:00:41,000
到该程序。

1235
01:00:41,000 --> 01:00:42,570
请注意，你现在可以做的。

1236
01:00:42,570 --> 01:00:44,950
无论你懂C
编程或没有，你

1237
01:00:44,950 --> 01:00:47,722
只需退后在这个
程序和脱脂的意见。

1238
01:00:47,722 --> 01:00:50,180
询问用户输入，确保
得到的字符串返回一个字符串，

1239
01:00:50,180 --> 01:00:53,009
遍历s中的字符
一次一个，打印字符

1240
01:00:53,009 --> 01:00:55,550
第i个字符S--你不
甚至有看代码

1241
01:00:55,550 --> 01:00:57,270
要理解这个程序做什么。

1242
01:00:57,270 --> 01:01:00,280
而且，更好的是，如果你自己看
这个节目在一两个星期，

1243
01:01:00,280 --> 01:01:02,280
或一个月，或者一年，
你也不必

1244
01:01:02,280 --> 01:01:04,420
在代码盯着，
试图记住，

1245
01:01:04,420 --> 01:01:06,630
那我想这个代码呢？

1246
01:01:06,630 --> 01:01:07,770
>> 你告诉自己。

1247
01:01:07,770 --> 01:01:11,660
你所描述它自己，
或者一些同事或助教，或TF。

1248
01:01:11,660 --> 01:01:14,860
所以这现在会是
正确的，良好的设计，

1249
01:01:14,860 --> 01:01:18,210
最终良好的作风为好。

1250
01:01:18,210 --> 01:01:19,990
所以，做记住这一点。

1251
01:01:19,990 --> 01:01:22,200
>> 因此，有一个其他
的事情，我要在这里做

1252
01:01:22,200 --> 01:01:28,240
现在可以透露究竟是什么
正在进行的发动机罩的下方。

1253
01:01:28,240 --> 01:01:30,390
因此，有此功能
在C和其他语言，

1254
01:01:30,390 --> 01:01:33,010
所谓的类型转换
要么含蓄

1255
01:01:33,010 --> 01:01:37,250
或明确允许你转换
从一种数据类型到另一种。

1256
01:01:37,250 --> 01:01:39,800
我们一直这样处理
据今天的字符串。

1257
01:01:39,800 --> 01:01:41,250
>> 并且字符串的字符。

1258
01:01:41,250 --> 01:01:44,910
但是从本周召回
0，是什么字？

1259
01:01:44,910 --> 01:01:49,334
人物只是一个抽象
上numbers--十进制数的顶部，

1260
01:01:49,334 --> 01:01:52,500
和小数真的只是一个
关于二进制数的顶部抽象，

1261
01:01:52,500 --> 01:01:53,720
因为我们定义它。

1262
01:01:53,720 --> 01:01:55,540
>> 因此，字符是数字。

1263
01:01:55,540 --> 01:01:58,410
和数字字符，
只是取决于上下文。

1264
01:01:58,410 --> 01:02:01,250
而事实证明，这里面
的计算机程序的，

1265
01:02:01,250 --> 01:02:06,830
您可以指定你想怎么看
在该节目内的位？

1266
01:02:06,830 --> 01:02:10,400
>> 从0本周我们不得不召回
ASCII，这仅仅是该代码

1267
01:02:10,400 --> 01:02:11,620
映射字母数字。

1268
01:02:11,620 --> 01:02:13,660
和我们说，资本A是65。

1269
01:02:13,660 --> 01:02:15,860
资本B是66，等等。

1270
01:02:15,860 --> 01:02:20,500
>> 和通知，我们基本上是有字符上
这里的最上面一行，为C会打电话给他们，

1271
01:02:20,500 --> 01:02:23,400
字符，然后
在第二排整数。

1272
01:02:23,400 --> 01:02:28,180
而事实证明，你可以转换
无缝两个，通常之间。

1273
01:02:28,180 --> 01:02:30,042
如果我们想要做的
这种刻意，我们

1274
01:02:30,042 --> 01:02:31,750
可能要处理
这样的事情。

1275
01:02:31,750 --> 01:02:33,590
>> 我们可能要转换
上壳体，以降低

1276
01:02:33,590 --> 01:02:35,330
的情况下，或小写字母为大写。

1277
01:02:35,330 --> 01:02:38,000
而事实证明那里的
这里实际上是一个模式

1278
01:02:38,000 --> 01:02:39,900
我们可以在短短的时刻拥抱。

1279
01:02:39,900 --> 01:02:44,120
但是让我们先来看一个
例如明确地这样做的。

1280
01:02:44,120 --> 01:02:46,340
>> 我要重新回到CS50 IDE。

1281
01:02:46,340 --> 01:02:50,640
我要去创造一个
文件调用的Ascii 0.C.

1282
01:02:50,640 --> 01:02:55,960
而且我要继续前进，加我
标准io.h顶部，INT主要无效

1283
01:02:55,960 --> 01:02:57,370
在我的函数的顶部。

1284
01:02:57,370 --> 01:03:02,700
然后，我只是做
following-- for循环从i等于，

1285
01:03:02,700 --> 01:03:04,610
让我们说，65。

1286
01:03:04,610 --> 01:03:10,460
>> 然后我将是小于
在字母表65，加上26个字母。

1287
01:03:10,460 --> 01:03:12,640
因此，我将让电脑
做数学题对我来说。

1288
01:03:12,640 --> 01:03:15,100
然后该环内，
我该怎么打印？

1289
01:03:15,100 --> 01:03:19,230
>> ％c是％I反斜线ñ。

1290
01:03:19,230 --> 01:03:21,290
现在，我想在两个值堵塞。

1291
01:03:21,290 --> 01:03:24,530
我暂时把问题
标志着有邀请的问题。

1292
01:03:24,530 --> 01:03:29,940
>> 我想从65迭代起
对于26个英文字母，

1293
01:03:29,940 --> 01:03:35,190
打印出在每个迭代该
人物的积分相同。

1294
01:03:35,190 --> 01:03:38,299
换句话说，我想
遍历26号打印

1295
01:03:38,299 --> 01:03:41,590
ASCII字符是什么，信，
和相应的数字is--什么

1296
01:03:41,590 --> 01:03:44,650
真的只是重建
从幻灯片图表。

1297
01:03:44,650 --> 01:03:47,010
那么，应该将这些问号是什么？

1298
01:03:47,010 --> 01:03:51,760
>> 那么，事实证明，第二
应该仅仅是变量i。

1299
01:03:51,760 --> 01:03:53,860
我希望看到，作为一个数字。

1300
01:03:53,860 --> 01:03:58,920
而中间的说法
在这里，我可以告诉电脑

1301
01:03:58,920 --> 01:04:03,470
对待该整数
i设定为一个字符，从而

1302
01:04:03,470 --> 01:04:05,880
在这里用它替换％的C.

1303
01:04:05,880 --> 01:04:07,990
>> 换句话说，如果我的
人类的程序员，知道

1304
01:04:07,990 --> 01:04:09,865
这些都只是数字
在一天结束。

1305
01:04:09,865 --> 01:04:12,500
我知道，65应
映射到一些字符。

1306
01:04:12,500 --> 01:04:15,310
有了这个明确的转换，
有一个括号，

1307
01:04:15,310 --> 01:04:18,840
要数据类型的名称
转换，和一个封闭的括号，

1308
01:04:18,840 --> 01:04:21,200
你可以告诉
计算机，嘿嘿，计算机，

1309
01:04:21,200 --> 01:04:24,130
这个整数转换为char。

1310
01:04:24,130 --> 01:04:26,250
>> 所以，当我运行这个
程序编译后，

1311
01:04:26,250 --> 01:04:29,740
让我们看看我get--使ASCII 0。

1312
01:04:29,740 --> 01:04:33,020
该死，我做了什么错在这里？

1313
01:04:33,020 --> 01:04:35,884
使用未声明的标识符，
没事的，不是故意的，

1314
01:04:35,884 --> 01:04:37,800
但让我们看看如果我们不能
原因通过此。

1315
01:04:37,800 --> 01:04:41,220
>> 因此，行five--所以我没有得到
很远的事情搞砸了。

1316
01:04:41,220 --> 01:04:42,140
没关系。

1317
01:04:42,140 --> 01:04:46,560
因此，对于我行5等于65--我明白了。

1318
01:04:46,560 --> 01:04:50,130
所以请记住，在C，不像有些
如果你有事先编程语言

1319
01:04:50,130 --> 01:04:52,190
经验，你有
告诉计算机，

1320
01:04:52,190 --> 01:04:55,040
不像划痕，是什么
变量的类型是。

1321
01:04:55,040 --> 01:04:56,860
>> 而我在这里忘了关键短语。

1322
01:04:56,860 --> 01:04:59,200
在五号线，我用我开始。

1323
01:04:59,200 --> 01:05:01,560
但是，我还没有告诉Ç
什么样的数据类型是。

1324
01:05:01,560 --> 01:05:04,570
所以我要在这里进去
说啊，让一个整数。

1325
01:05:04,570 --> 01:05:07,050
>> 现在我要继续前进，并重新编译。

1326
01:05:07,050 --> 01:05:08,080
这固定的。

1327
01:05:08,080 --> 01:05:12,660
./ascii0输入，这很酷。

1328
01:05:12,660 --> 01:05:15,360
它不仅是超级快
让计算机这个问题，

1329
01:05:15,360 --> 01:05:18,885
而不是看它在幻灯片上，
它打印出每行一个，A为65，

1330
01:05:18,885 --> 01:05:24,860
B是66，一路down--因为我
这样做26 times--到字母Z，

1331
01:05:24,860 --> 01:05:25,630
这是90。

1332
01:05:25,630 --> 01:05:27,790
而且，事实上，稍
更智能的会

1333
01:05:27,790 --> 01:05:31,030
一直对我不依赖
在计算机上，以添加26。

1334
01:05:31,030 --> 01:05:34,060
我刚做
90为好，这样长时间

1335
01:05:34,060 --> 01:05:37,390
因为我不犯同样的错误两次。

1336
01:05:37,390 --> 01:05:41,880
我想通过上去
Z，不仅仅是高达到y。

1337
01:05:41,880 --> 01:05:44,000
>> 所以这是一个明确的转换。

1338
01:05:44,000 --> 01:05:47,860
事实证明，这
甚至没有必要。

1339
01:05:47,860 --> 01:05:52,480
让我继续前进，重新运行此
编译器，然后重新运行ASCII 0。

1340
01:05:52,480 --> 01:05:54,940
事实证明，C是非常聪明。

1341
01:05:54,940 --> 01:05:57,150
>> 和printf，特别
是相当聪明。

1342
01:05:57,150 --> 01:06:01,260
如果你只是传递一个我两次
两个占位符的printf

1343
01:06:01,260 --> 01:06:04,510
会意识到，哦，我知道你
给了我一个integer--一些数字，

1344
01:06:04,510 --> 01:06:06,380
像65或90，或什么的。

1345
01:06:06,380 --> 01:06:10,170
但是，我知道你要我
像格式化字符该号码。

1346
01:06:10,170 --> 01:06:16,460
所以printf的可隐式转换
在诠释为你一个char为好。

1347
01:06:16,460 --> 01:06:19,360
所以，这不是一个问题都没有。

1348
01:06:19,360 --> 01:06:23,100
>> 但是请注意，因为这等同，
我们实际上可以做到这一点。

1349
01:06:23,100 --> 01:06:26,520
让我继续前进，做一个
this-- 1.C.的Ascii其他版本

1350
01:06:26,520 --> 01:06:31,800
取而代之的迭代
整数，才能真正打击你的心

1351
01:06:31,800 --> 01:06:33,610
通过遍历字符。

1352
01:06:33,610 --> 01:06:37,660
如果一个charç获得资本A，I
想先走，并做到这一点，

1353
01:06:37,660 --> 01:06:41,740
只要C小于或等于
资本Z.并在每个迭代

1354
01:06:41,740 --> 01:06:45,690
我想增加C，我可以
现在在我行的printf这里

1355
01:06:45,690 --> 01:06:51,320
比如说，百分比C是
我百分之再次，逗号C.

1356
01:06:51,320 --> 01:06:57,200
>> 而现在，我可以去另一个方向，
铸人品明确

1357
01:06:57,200 --> 01:06:58,500
为整数。

1358
01:06:58,500 --> 01:07:00,560
因此，再次，你为什么会这么做？

1359
01:07:00,560 --> 01:07:03,830
这是一个有点怪异排序的
计数的字符条款。

1360
01:07:03,830 --> 01:07:07,430
>> 但是，如果你明白什么是
怎么回事引擎盖下，

1361
01:07:07,430 --> 01:07:08,430
真的没有魔法。

1362
01:07:08,430 --> 01:07:13,060
你这么说，哎，给电脑
我一个叫char类型的C变量。

1363
01:07:13,060 --> 01:07:16,520
它初始化为大写的A和
注意单引号问题。

1364
01:07:16,520 --> 01:07:19,580
>> 在C字，从召回
上周，您可以使用单引号。

1365
01:07:19,580 --> 01:07:23,720
对于字符串，单词，
词组，使用双引号。

1366
01:07:23,720 --> 01:07:27,210
OK，电脑，继续做这个，所以
只要字符小于

1367
01:07:27,210 --> 01:07:28,050
或等于z。

1368
01:07:28,050 --> 01:07:32,640
而我从ASCII表知道，所有的
这些ASCII码是连续的。

1369
01:07:32,640 --> 01:07:33,400
>> 有没有差距。

1370
01:07:33,400 --> 01:07:36,737
所以，这只是A到Z，
通过每一个号码分开。

1371
01:07:36,737 --> 01:07:38,820
然后，我可以递增
一个char，如果我真正想要的。

1372
01:07:38,820 --> 01:07:40,390
在一天结束时，
它只是一个数字。

1373
01:07:40,390 --> 01:07:41,030
我知道这个。

1374
01:07:41,030 --> 01:07:43,670
所以，我只能推测到1添加到它。

1375
01:07:43,670 --> 01:07:46,940
>> 然后这个时候，我打印C，
然后积分当量。

1376
01:07:46,940 --> 01:07:50,170
我甚至不需要明确的转换。

1377
01:07:50,170 --> 01:07:52,680
我可以让printf和的
计算机理出头绪，

1378
01:07:52,680 --> 01:07:57,300
所以，现在，如果我跑
使Ascii1./ascii1，

1379
01:07:57,300 --> 01:08:01,520
我得到同样的事情为好。

1380
01:08:01,520 --> 01:08:04,530
>> 无用的程序，though--没有人
是要实际编写软件

1381
01:08:04,530 --> 01:08:07,549
为了搞清楚，究竟是什么
映射到一个数字，或B，或Z？

1382
01:08:07,549 --> 01:08:10,340
你只是去Google一下，或
网上查一查，或者看它

1383
01:08:10,340 --> 01:08:11,650
幻灯片上，或类似物。

1384
01:08:11,650 --> 01:08:13,520
那么，这实际上得到有用吗？

1385
01:08:13,520 --> 01:08:15,960
>> 好了，说那
滑，注意有

1386
01:08:15,960 --> 01:08:20,890
一个实际的模式在这里大写之间
和小写，这是不是偶然的。

1387
01:08:20,890 --> 01:08:23,760
请注意，资本A是65。

1388
01:08:23,760 --> 01:08:25,830
小写a是97。

1389
01:08:25,830 --> 01:08:29,649
并有多远较低情况下？

1390
01:08:29,649 --> 01:08:32,649
>> 所以65是97多少步走呢？

1391
01:08:32,649 --> 01:08:36,210
所以97减65为32。

1392
01:08:36,210 --> 01:08:37,910
所以资本为65。

1393
01:08:37,910 --> 01:08:39,939
如果添加32到，
你会得到一个小写。

1394
01:08:39,939 --> 01:08:43,729
而且，等效如果你减去32，
你回到资本A--同为B

1395
01:08:43,729 --> 01:08:46,380
以小B，大C到小℃。

1396
01:08:46,380 --> 01:08:50,670
>> 所有这些差距是32分开。

1397
01:08:50,670 --> 01:08:54,450
现在，这似乎让我们
做类似微软的Word，

1398
01:08:54,450 --> 01:08:57,729
或谷歌文档功能，您
可以选择一切，然后说，

1399
01:08:57,729 --> 01:09:00,520
改变这一切为小写，或
全部改为大写，

1400
01:09:00,520 --> 01:09:03,840
或仅改变第一个字
一个句子为大写字母。

1401
01:09:03,840 --> 01:09:07,390
事实上，我们可以做一些事情
这样的自己。

1402
01:09:07,390 --> 01:09:12,645
>> 让我继续前进，保存文件
这里所说的利用0.C.

1403
01:09:12,645 --> 01:09:15,770
让我们继续前进，掀起程序
这正是这么做的，如下所示。

1404
01:09:15,770 --> 01:09:18,460
因此，包括CS50库。

1405
01:09:18,460 --> 01:09:21,430
而包括标准I / O。

1406
01:09:21,430 --> 01:09:22,787
>> 我知道这是即将到来。

1407
01:09:22,787 --> 01:09:24,870
所以，我打算把它放在
已经存在，string.h中，

1408
01:09:24,870 --> 01:09:26,960
所以我有机会获得
之类的东西斯特林，

1409
01:09:26,960 --> 01:09:29,620
再诠释主空，一如往常。

1410
01:09:29,620 --> 01:09:33,420
然后我要继续前进
做琴弦得到得到的字符串，

1411
01:09:33,420 --> 01:09:35,032
只是为了获得来自用户的字符串。

1412
01:09:35,032 --> 01:09:36,740
然后我要去
做我的完整性检查。

1413
01:09:36,740 --> 01:09:40,510
如果字符串不等于空，
那么它的安全进行。

1414
01:09:40,510 --> 01:09:42,000
什么做我想做的事？

1415
01:09:42,000 --> 01:09:48,700
我要遍历从i等于0，
和n高达S的字符串长度。

1416
01:09:48,700 --> 01:09:51,899
>> 而且我要做到这一点，只要
i小于n，并且我加再加。

1417
01:09:51,899 --> 01:09:55,060
到目前为止，我真的只是
从之前借款的想法。

1418
01:09:55,060 --> 01:09:57,010
现在我要介绍一个分支。

1419
01:09:57,010 --> 01:09:59,635
>> 所以，回想着划痕，其中
我们在路上的叉，

1420
01:09:59,635 --> 01:10:05,110
上周在C.我要去
这么一说，s中的第i个字符

1421
01:10:05,110 --> 01:10:09,250
大于或
等于降低情况下，

1422
01:10:09,250 --> 01:10:13,340
而且 - 在抓你会从字面上
说和，但在C你说符号，

1423
01:10:13,340 --> 01:10:19,830
ampersand--和s中​​的第i个字符
小于或等于小写Z，

1424
01:10:19,830 --> 01:10:21,780
让我们做一些有趣的事情。

1425
01:10:21,780 --> 01:10:27,020
让我们来实际打印出来
性格没有换行符

1426
01:10:27,020 --> 01:10:31,760
即在字符串中的字符，
第i个字符的字符串中。

1427
01:10:31,760 --> 01:10:37,420
>> 但是，让我们继续前进，
减去它32。

1428
01:10:37,420 --> 01:10:42,120
否则，如果在字符
字符串，我们正在寻找

1429
01:10:42,120 --> 01:10:45,950
是不是稍微之间
和小Z，继续前进

1430
01:10:45,950 --> 01:10:48,610
和刚刚打印出来不变。

1431
01:10:48,610 --> 01:10:50,840
因此，我们已经介绍了
此括号表示法

1432
01:10:50,840 --> 01:10:53,560
我们的关系，想在
第i个字符的字符串中。

1433
01:10:53,560 --> 01:10:57,520
>> 我已经添加了一些条件逻辑，如
刮在上周的一周一物，何处

1434
01:10:57,520 --> 01:10:59,880
我只是用我的根本
一个什么样的了解

1435
01:10:59,880 --> 01:11:01,130
正在进行的发动机罩的下方。

1436
01:11:01,130 --> 01:11:04,190
为s的第i个字符
大于或等于一个？

1437
01:11:04,190 --> 01:11:08,290
像，它是97或98，
或99，等等？

1438
01:11:08,290 --> 01:11:11,940
>> 但是它也小于或等于
为小写字母z的价值？

1439
01:11:11,940 --> 01:11:16,210
如果是这样，这是什么意思行？

1440
01:11:16,210 --> 01:11:20,250
14，这是排序的
整个想法的胚芽，

1441
01:11:20,250 --> 01:11:23,840
大写字母
简单地减去它32，

1442
01:11:23,840 --> 01:11:29,370
在这种情况下，因为我知道，这每
图中，我的数字是如何表示。

1443
01:11:29,370 --> 01:11:33,925
因此，让我们继续前进，并运行此，
编译利用0.c后，

1444
01:11:33,925 --> 01:11:36,210
和运行资本0。

1445
01:11:36,210 --> 01:11:40,300
>> 让我们键入类似
Zamyla在全部小写输入。

1446
01:11:40,300 --> 01:11:42,780
现在我们有Zamyla全部大写。

1447
01:11:42,780 --> 01:11:45,050
让我们在所有小写输入罗布。

1448
01:11:45,050 --> 01:11:46,674
让我们尝试杰森全部小写。

1449
01:11:46,674 --> 01:11:48,590
我们不断收到
强制资本。

1450
01:11:48,590 --> 01:11:50,960
有一个小错误，我
那种没有预料到的。

1451
01:11:50,960 --> 01:11:54,050
请注意我的新提示结束了
在同一行作为他们的名字，

1452
01:11:54,050 --> 01:11:55,520
这感觉有点凌乱。

1453
01:11:55,520 --> 01:11:59,170
>> 所以我要在这里走，
其实在这个程序结束

1454
01:11:59,170 --> 01:12:02,110
打印出一个换行符。

1455
01:12:02,110 --> 01:12:03,160
就这样。

1456
01:12:03,160 --> 01:12:06,120
但使用printf，你并不需要
传递变量或格式代码。

1457
01:12:06,120 --> 01:12:08,460
你可以从字面上只是打印
像一个换行符。

1458
01:12:08,460 --> 01:12:13,529
>> 因此，让我们继续前进，使
再利用0，重新运行，Zamyla。

1459
01:12:13,529 --> 01:12:14,820
而现在这是一个有点漂亮。

1460
01:12:14,820 --> 01:12:17,274
现在，我的提示是对自己的新线。

1461
01:12:17,274 --> 01:12:18,440
所以这是一切优秀和良好。

1462
01:12:18,440 --> 01:12:19,910
所以这是一个很好的例子。

1463
01:12:19,910 --> 01:12:22,700
不过，我也不一定
需要硬编码的32。

1464
01:12:22,700 --> 01:12:23,350
你知道吗？

1465
01:12:23,350 --> 01:12:26,350
我可以say--我从来没有
记住不同的是什么。

1466
01:12:26,350 --> 01:12:29,330
>> 但我知道，如果我
有一个小写字母，

1467
01:12:29,330 --> 01:12:34,430
我基本上是想减去关闭
任何的距离是小之间

1468
01:12:34,430 --> 01:12:39,160
一，大A，因为如果我假设
所有的其它字母的是相同的，

1469
01:12:39,160 --> 01:12:41,045
应该把工作做好。

1470
01:12:41,045 --> 01:12:42,670
但是，而不是这样做，你知道吗？

1471
01:12:42,670 --> 01:12:44,240
还有另一种方式。

1472
01:12:44,240 --> 01:12:48,090
>> 如果这是利用1.c--如果我是
以它放入一个单独的文件。

1473
01:12:48,090 --> 01:12:51,030
让我们做资本2.C如下。

1474
01:12:51,030 --> 01:12:53,060
我要真打扫一下这里。

1475
01:12:53,060 --> 01:12:57,420
而不是甚至无需
知道也不关心那些低水平

1476
01:12:57,420 --> 01:13:01,090
实施细则，我代替
只是要打印的字符，

1477
01:13:01,090 --> 01:13:04,610
报价引文结束，百分比C和
然后调用另一个函数，

1478
01:13:04,610 --> 01:13:09,950
存在需要一个参数，
这是一个字符，像这样。

1479
01:13:09,950 --> 01:13:12,630
>> 原来，在C，有
另一个函数调用

1480
01:13:12,630 --> 01:13:15,550
到上，这正如其名
建议需要的性格

1481
01:13:15,550 --> 01:13:19,350
它使得其上壳
等效，然后返回它

1482
01:13:19,350 --> 01:13:21,410
这样的printf可以在那里插上。

1483
01:13:21,410 --> 01:13:25,484
所以这样做，虽然，我
需要引入另一个文件。

1484
01:13:25,484 --> 01:13:28,400
原来还有另一个文件
你只能从类知道，

1485
01:13:28,400 --> 01:13:33,020
或教材，或在线
引用，名为C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> 所以，如果我补充一点，我的头之间
文件，现在重新编译这个程序，

1487
01:13:38,570 --> 01:13:43,040
capitalize2，./capitalize2 Enter键。

1488
01:13:43,040 --> 01:13:46,690
让我们在所有类型Zamyla
小写，还是工作原理相同。

1489
01:13:46,690 --> 01:13:48,040
但是，你知道吗？

1490
01:13:48,040 --> 01:13:55,590
事实证明，到上
有一些其它功能。

1491
01:13:55,590 --> 01:13:58,410
>> 让我介绍这个
命令这里，有点笨拙

1492
01:13:58,410 --> 01:14:00,250
命名，但男人使用说明书。

1493
01:14:00,250 --> 01:14:03,960
事实证明，大多数Linux计算机，
因为我们使用的是这里 -  Linux的操作系统

1494
01:14:03,960 --> 01:14:06,270
系统 - 有一个命令
所谓的人，它说，

1495
01:14:06,270 --> 01:14:08,530
哎，电脑，给我
电脑的使用手册。

1496
01:14:08,530 --> 01:14:10,680
你想做什么
查找该手册中？

1497
01:14:10,680 --> 01:14:13,840
>> 我想查找功能
叫上，回车。

1498
01:14:13,840 --> 01:14:16,070
这是一个有点神秘
有时阅读。

1499
01:14:16,070 --> 01:14:18,780
但是请注意，我们是在
Linux的程序员手册。

1500
01:14:18,780 --> 01:14:19,530
和它的所有文本。

1501
01:14:19,530 --> 01:14:21,905
并注意还有的
函数的名称在这里。

1502
01:14:21,905 --> 01:14:25,030
事实证明，它有一个表妹叫
降低，这则正好相反。

1503
01:14:25,030 --> 01:14:29,710
并根据大纲的通知，要使用这个
函数的手册页，可以这么说，

1504
01:14:29,710 --> 01:14:32,220
告诉我，我
需要包括C type.h.

1505
01:14:32,220 --> 01:14:33,630
而且我知道，从实践中。

1506
01:14:33,630 --> 01:14:36,210
>> 在这里，它显示了我两
对于函数原型，

1507
01:14:36,210 --> 01:14:39,070
所以，如果我曾经想用这个
我知道他们采取什么样的作为输入，

1508
01:14:39,070 --> 01:14:40,652
和他们返回作为输出。

1509
01:14:40,652 --> 01:14:42,360
然后如果我读
说明，我看

1510
01:14:42,360 --> 01:14:44,820
更详细的功能做了什么。

1511
01:14:44,820 --> 01:14:48,100
但是如果更重要的是，
我期待下返回值，

1512
01:14:48,100 --> 01:14:51,710
它说，返回的值是
转换后的信，

1513
01:14:51,710 --> 01:14:57,880
或C，原来的输入，如果
转换是不可能的。

1514
01:14:57,880 --> 01:15:01,992
>> 换句话说，到上部会尝试
到了一封信转换为大写。

1515
01:15:01,992 --> 01:15:03,450
如果是的话，它会返回。

1516
01:15:03,450 --> 01:15:07,010
但是，如果它不能为某些reason--
也许它已经大写，

1517
01:15:07,010 --> 01:15:09,550
也许这是一个惊叹号
或一些其它punctuation--

1518
01:15:09,550 --> 01:15:12,200
它只是要
返回原来的C，

1519
01:15:12,200 --> 01:15:17,340
这意味着我可以让我的代码
更好的设计如下。

1520
01:15:17,340 --> 01:15:20,580
>> 我并不需要所有的
这些代码织补行。

1521
01:15:20,580 --> 01:15:22,610
我的一切的线路
只是强调能

1522
01:15:22,610 --> 01:15:28,700
被折叠成只是一个简单的
线，这是this-- printf的百分之

1523
01:15:28,700 --> 01:15:33,510
C到上小号支架我。

1524
01:15:33,510 --> 01:15:36,090
并且这将是一个
例如更好的设计。

1525
01:15:36,090 --> 01:15:40,040
>> 为什么在7或8条线路实施
代码，不管是什么我只是

1526
01:15:40,040 --> 01:15:44,960
删除，当你可以代替崩溃
所有的逻辑和决策

1527
01:15:44,960 --> 01:15:49,620
成一个单一的线，13现在，这
依赖于一个库function--

1528
01:15:49,620 --> 01:15:53,430
随C中的函数，但
究竟你想要它做的事。

1529
01:15:53,430 --> 01:15:55,295
而且，坦率地说，即使
它没有附带C，

1530
01:15:55,295 --> 01:15:58,880
你可以自己实现它，
我们已经看到，与获得负INT

1531
01:15:58,880 --> 01:16:01,700
并获得上周积极INT为好。

1532
01:16:01,700 --> 01:16:03,470
>> 此代码是现在更具可读性。

1533
01:16:03,470 --> 01:16:06,670
而且，事实上，如果我们向上滚动，
怎么看怎么更加紧凑

1534
01:16:06,670 --> 01:16:08,360
这个版本我的程序是。

1535
01:16:08,360 --> 01:16:11,230
这是一个有点头重脚轻了，
所有这些包含。

1536
01:16:11,230 --> 01:16:14,380
不过没关系，因为现在我站在
程序员的肩膀上

1537
01:16:14,380 --> 01:16:15,300
在我面前。

1538
01:16:15,300 --> 01:16:18,440
而谁是谁
实施上真正

1539
01:16:18,440 --> 01:16:21,470
帮了我一个忙，就像谁
实施斯特林真

1540
01:16:21,470 --> 01:16:24,790
帮了我一个忙前一段时间。

1541
01:16:24,790 --> 01:16:26,970
所以现在我们有一个
更好的设计方案

1542
01:16:26,970 --> 01:16:31,680
实现精确相同的逻辑。

1543
01:16:31,680 --> 01:16:35,580
>> 斯特林说起，让
我继续前进，做到这一点。

1544
01:16:35,580 --> 01:16:38,320
让我继续前进，保存
此文件stirling.c。

1545
01:16:38,320 --> 01:16:43,255
而事实证明，我们可以剥开
另一层倒也干脆，现在。

1546
01:16:43,255 --> 01:16:45,630
我要继续前进，鞭
起来主要另一个程序

1547
01:16:45,630 --> 01:16:49,759
在这里，只需重新器具
字符串长度如下。

1548
01:16:49,759 --> 01:16:52,300
因此，这里的代码行
让我从用户的字符串。

1549
01:16:52,300 --> 01:16:53,910
我们继续一次又一次地用这个。

1550
01:16:53,910 --> 01:16:58,900
让我给自己一个叫做变量
存储一些类型为int n个。

1551
01:16:58,900 --> 01:17:02,490
>> 让我继续前进，
请执行下列操作逻辑。

1552
01:17:02,490 --> 01:17:15,610
而s中的第n个字符不
不等于0反斜杠，继​​续前进

1553
01:17:15,610 --> 01:17:17,930
和幅度值。

1554
01:17:17,930 --> 01:17:23,506
然后打印出来的printf％的I N。

1555
01:17:23,506 --> 01:17:29,200
我要求，这个方案在这里，
没有调用字符串长度，

1556
01:17:29,200 --> 01:17:31,150
计算出的字符串的长度。

1557
01:17:31,150 --> 01:17:34,600
>> 而神奇的是完全
包封在管线8

1558
01:17:34,600 --> 01:17:39,830
这里看起来像新的语法，
这反斜线0单引号。

1559
01:17:39,830 --> 01:17:41,360
但是，这是为什么？

1560
01:17:41,360 --> 01:17:44,100
那么，考虑一下一直
事情这么长的时间。

1561
01:17:44,100 --> 01:17:47,990
>> 而作为一个抛开我忘记之前，实现
那就是，除了手册页

1562
01:17:47,990 --> 01:17:50,920
附带一个典型
Linux系统一样CS50 IDE，

1563
01:17:50,920 --> 01:17:53,770
认识到我们的
当然的工作人员，也有

1564
01:17:53,770 --> 01:17:56,030
做了一个网站改版
这个所谓的想法一样

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net，其具有
所有这些同一个人网页，

1566
01:17:59,940 --> 01:18:02,020
所有相同
文档，以及

1567
01:18:02,020 --> 01:18:05,730
在允许顶部的小盒子
你把所有的相当

1568
01:18:05,730 --> 01:18:09,025
晦涩难懂的语言变成不舒服
模式，在我们的教学人员，

1569
01:18:09,025 --> 01:18:12,150
走过了，并试图简化
一些让一切语言

1570
01:18:12,150 --> 01:18:14,830
集中在思想，而不是
一些技术性的。

1571
01:18:14,830 --> 01:18:20,070
所以记住，reference.cs50.net
作为另一资源为好。

1572
01:18:20,070 --> 01:18:23,800
>> 但是，为什么在字符串长度工作
我提出刚才的方法是什么？

1573
01:18:23,800 --> 01:18:25,160
下面是再次Zamyla的名字。

1574
01:18:25,160 --> 01:18:27,690
而这里的Zamyla的名字
盒装的，因为我一直做，

1575
01:18:27,690 --> 01:18:31,360
画它是一个图片，
真的，只是一个字符序列。

1576
01:18:31,360 --> 01:18:34,260
但Zamyla不存在
在程序中的隔离。

1577
01:18:34,260 --> 01:18:37,420
>> 当你编写和运行程序，
你用你的Mac或PC机

1578
01:18:37,420 --> 01:18:40,010
存储器，或RAM可以这么说。

1579
01:18:40,010 --> 01:18:42,620
你能想到的
您的计算机具有

1580
01:18:42,620 --> 01:18:44,730
大量内存千兆字节的这些日子。

1581
01:18:44,730 --> 01:18:47,700
而演出意味着数十亿美元，
所以十亿字节。

1582
01:18:47,700 --> 01:18:48,910
>> 但是，让我们在时间上后退。

1583
01:18:48,910 --> 01:18:51,530
并假设我们使用
一个很老的计算机

1584
01:18:51,530 --> 01:18:55,150
只有32字节的内存。

1585
01:18:55,150 --> 01:18:59,310
我可以，我的电脑屏幕上，
简单地得出这样如下。

1586
01:18:59,310 --> 01:19:05,240
>> 我可以简单地说，我的
计算机有这一切的内存。

1587
01:19:05,240 --> 01:19:08,830
这就好比记忆棒，如果
你还记得我们上次的图片。

1588
01:19:08,830 --> 01:19:11,670
如果我只是划分
这足够的时间，

1589
01:19:11,670 --> 01:19:15,040
我主张，我有32个字节
的屏幕上存储器。

1590
01:19:15,040 --> 01:19:18,239
>> 现在，在现实中，我只能
到目前为止，得出这样的画面在这里。

1591
01:19:18,239 --> 01:19:20,280
所以我要继续前进，
，只是按照惯例，

1592
01:19:20,280 --> 01:19:24,050
吸取我的电脑的内存作为
格，而不是仅仅为一个直线。

1593
01:19:24,050 --> 01:19:28,190
具体来说，我现在声称
此网格，这8个4格，

1594
01:19:28,190 --> 01:19:31,800
刚刚代表所有32个字节
在我的Mac可用内存，

1595
01:19:31,800 --> 01:19:33,030
或在我的电脑使用。

1596
01:19:33,030 --> 01:19:34,780
他们正在包装
上两行，只是

1597
01:19:34,780 --> 01:19:38,030
因为它适合更多的屏幕上。

1598
01:19:38,030 --> 01:19:40,800
但是，这是第一个字节。

1599
01:19:40,800 --> 01:19:41,990
这是第二个字节。

1600
01:19:41,990 --> 01:19:43,300
这是第三个字节。

1601
01:19:43,300 --> 01:19:45,310
>> 这是第32个字节。

1602
01:19:45,310 --> 01:19:52,910
或者，如果我们认为像电脑
科学家，这是字节0，1，2，3，31。

1603
01:19:52,910 --> 01:19:55,950
所以，你必须为0〜31，如果
你从0开始计数。

1604
01:19:55,950 --> 01:19:59,830
>> 因此，如果我们使用某个程序
该调用get字符串，

1605
01:19:59,830 --> 01:20:05,280
而我们从人类的字符串
像我一样叫Zamyla，Z-A-M-Y-L-A，

1606
01:20:05,280 --> 01:20:09,430
如何在世界上做的
计算机跟踪哪些字节，

1607
01:20:09,430 --> 01:20:12,230
其中的内存块，
属于哪个字符串？

1608
01:20:12,230 --> 01:20:16,270
换言之，如果我们继续
键入另一个名字输入电脑，

1609
01:20:16,270 --> 01:20:19,890
像这样的岸堤，调用
获得字符串的第二时间，

1610
01:20:19,890 --> 01:20:23,030
A-N-D-我已经在结束了
计算机的存储器。

1611
01:20:23,030 --> 01:20:23,850
但如何？

1612
01:20:23,850 --> 01:20:29,700
>> 那么，事实证明，下面的
油烟机，什么C字符串存储什么时候

1613
01:20:29,700 --> 01:20:35,080
该人的类型，或该
来自其他来源，它是

1614
01:20:35,080 --> 01:20:39,190
描绘它们的与端
一个特殊的character--反斜杠

1615
01:20:39,190 --> 01:20:44,750
0，这仅仅是一种特殊的方式
的说法一排80位。

1616
01:20:44,750 --> 01:20:47,950
>> 所以A--这是97号召回。

1617
01:20:47,950 --> 01:20:51,770
因此，一些8位模式
代表十进制数97。

1618
01:20:51,770 --> 01:20:58,070
这反斜杠0字面上数
0，又名NUL，N-U-L，不像早期，

1619
01:20:58,070 --> 01:20:59,630
的N- U-L-L，这是我们津津乐道。

1620
01:20:59,630 --> 01:21:05,700
但现在，只知道这
反斜线0是一排只有80位。

1621
01:21:05,700 --> 01:21:09,810
>> 而这只是该线路
沙子，说什么向左

1622
01:21:09,810 --> 01:21:12,610
属于一个字符串或一个数据类型。

1623
01:21:12,610 --> 01:21:15,480
和任何向右
属于别的东西。

1624
01:21:15,480 --> 01:21:17,440
岸堤的名称，同时，
刚刚视觉

1625
01:21:17,440 --> 01:21:21,310
发生缠绕到其他线路，
但是这只是一个审美细节，

1626
01:21:21,310 --> 01:21:23,990
同样是NUL终止。

1627
01:21:23,990 --> 01:21:29,290
>> 这是一个A-N-D-I字符的字符串，
加上第五秘密性质，

1628
01:21:29,290 --> 01:21:33,560
所有0位，只是标定
安迪的名字的结尾为好。

1629
01:21:33,560 --> 01:21:37,120
如果我们调用get字符串第三次
在电脑中得到这样一个字符串

1630
01:21:37,120 --> 01:21:44,210
玛丽亚，M-A-R-I-A，同样是玛丽亚的
名NUL终止反斜杠0。

1631
01:21:44,210 --> 01:21:47,170
>> 这是根本不同的
如何从一台计算机通常会

1632
01:21:47,170 --> 01:21:51,850
存储的整数，或一个浮动，或其他
数据类型仍，因为回忆，

1633
01:21:51,850 --> 01:21:57,420
的整数，通常是32位，或
4个字节，或者甚至64位，

1634
01:21:57,420 --> 01:21:59,100
或八个字节。

1635
01:21:59,100 --> 01:22:02,620
但是，在计算机的许多基元
在一种编程语言

1636
01:22:02,620 --> 01:22:05,550
具有固定数目的
在hood--下字节

1637
01:22:05,550 --> 01:22:08,100
也许1，也许2，也许4，也许8。

1638
01:22:08,100 --> 01:22:13,250
>> 但字符串，在设计上，有一个
动态字符数。

1639
01:22:13,250 --> 01:22:16,980
你不知道在前进，直到
人的类型Z-A-M-Y-L-A，

1640
01:22:16,980 --> 01:22:21,400
或M-A-R-I-A或A-N-D-I。你不知道
多少次，用户将要击中

1641
01:22:21,400 --> 01:22:22,070
键盘。

1642
01:22:22,070 --> 01:22:26,490
因此，您不知道如何
提前多少字符

1643
01:22:26,490 --> 01:22:27,540
你将需要。

1644
01:22:27,540 --> 01:22:31,840
>> 而所以C只是一种叶子像
引擎盖下的秘密痕迹

1645
01:22:31,840 --> 01:22:32,960
在字符串的末尾。

1646
01:22:32,960 --> 01:22:39,280
存储Z-A-M-Y-L-A在内存中后，
它也只是把等价

1647
01:22:39,280 --> 01:22:40,210
经过一段时间。

1648
01:22:40,210 --> 01:22:45,060
在一个句子的末尾，
它把80位，从而

1649
01:22:45,060 --> 01:22:49,120
要记得在哪里
Zamyla开始和结束。

1650
01:22:49,120 --> 01:22:51,490
>> 那么，什么是连接，
那么，这个计划？

1651
01:22:51,490 --> 01:22:55,190
这里这个程序，斯特林，
仅仅是一个机制

1652
01:22:55,190 --> 01:22:57,970
获取一个字符串
从用户线6。

1653
01:22:57,970 --> 01:23:01,160
7号线，我声明一个变量
所谓的N和其设置为0。

1654
01:23:01,160 --> 01:23:08,680
>> 然后在第8行，我只是问
问题，而第n个字符不

1655
01:23:08,680 --> 01:23:12,120
不等于所有0 bits--
换句话说，不

1656
01:23:12,120 --> 01:23:14,500
等于这个特殊
字符，反斜杠0，这

1657
01:23:14,500 --> 01:23:18,470
只是特别NUL character--
继续前进，只是幅度值。

1658
01:23:18,470 --> 01:23:21,460
>> 并继续做下去，并保持
这样做，并继续做下去。

1659
01:23:21,460 --> 01:23:23,430
因此，即使在
我们使用我过去，

1660
01:23:23,430 --> 01:23:25,181
这是完全正常的
语义使用N，

1661
01:23:25,181 --> 01:23:27,430
如果你只是想
故意算上这一次，

1662
01:23:27,430 --> 01:23:28,720
只想为n调用它。

1663
01:23:28,720 --> 01:23:34,720
因此，这只是不断问这个问题，
是第全0第n个字符？

1664
01:23:34,720 --> 01:23:38,470
如果没有，看看下看看，
期待下，期待下，

1665
01:23:38,470 --> 01:23:39,460
期待下。

1666
01:23:39,460 --> 01:23:45,540
>> 但只要你看到反斜杠0，
这loop-- line 9至11--停止。

1667
01:23:45,540 --> 01:23:49,640
您将跳出while循环，
离开该变量n的内部

1668
01:23:49,640 --> 01:23:54,530
所有的的总数
你看到的字符串中的字符，

1669
01:23:54,530 --> 01:23:55,660
因此打印出来。

1670
01:23:55,660 --> 01:23:56,760
因此，让我们试试这个。

1671
01:23:56,760 --> 01:23:59,500
>> 让我继续前进，而不
使用斯特林功能，

1672
01:23:59,500 --> 01:24:04,240
只是用我自己的版本自产自销
这里所说的斯特林，让我先走

1673
01:24:04,240 --> 01:24:07,700
和运行斯特林，类型的东西
像Zamyla，这是我事先知道

1674
01:24:07,700 --> 01:24:08,670
是六个字符。

1675
01:24:08,670 --> 01:24:10,080
让我们来看看它是否工作。

1676
01:24:10,080 --> 01:24:10,920
事实上，这是六人。

1677
01:24:10,920 --> 01:24:15,257
让我们尝试与Rob，三字，
三个大字，以及等等。

1678
01:24:15,257 --> 01:24:17,340
所以，这一切是怎么回事
上罩下方。

1679
01:24:17,340 --> 01:24:19,548
并注意连接，
然后，在第一周

1680
01:24:19,548 --> 01:24:22,370
一流的，在这里我们谈到
像抽象，

1681
01:24:22,370 --> 01:24:26,960
这仅仅是这个分层的想法，或者
复杂性，对基本原则之上。

1682
01:24:26,960 --> 01:24:30,710
在这里，我们的排序看
斯特林发动机罩下方，

1683
01:24:30,710 --> 01:24:33,510
可以这么说，要弄清楚，
将如何实施？

1684
01:24:33,510 --> 01:24:35,232
>> 我们可以重新实现它自己。

1685
01:24:35,232 --> 01:24:37,440
但我们再也没有去
重新实现斯特林。

1686
01:24:37,440 --> 01:24:39,780
我们只是要
使用斯特林为了

1687
01:24:39,780 --> 01:24:42,100
真正得到一些字符串的长度。

1688
01:24:42,100 --> 01:24:44,200
>> 但有没有神奇
引擎盖下。

1689
01:24:44,200 --> 01:24:46,716
如果你知道下面
引擎盖，一个字符串

1690
01:24:46,716 --> 01:24:48,090
仅仅是一个字符序列。

1691
01:24:48,090 --> 01:24:51,090
和人物该序列
一切都可以解决数字

1692
01:24:51,090 --> 01:24:53,330
带支架0，支架
1，支架2，和你

1693
01:24:53,330 --> 01:24:57,420
知道，在一个字符串的末尾是一个
特殊字符，你可以计算出

1694
01:24:57,420 --> 01:25:01,710
如何做到在任何东西
程序，因为所有它归结为

1695
01:25:01,710 --> 01:25:03,400
在读取和写入内存。

1696
01:25:03,400 --> 01:25:06,130
即，在改变和寻找
在内存或搬东西

1697
01:25:06,130 --> 01:25:10,940
在内存，打印的东西
屏幕等上。

1698
01:25:10,940 --> 01:25:14,800
>> 现在让我们用这个新发现
究竟是什么弦乐器的理解

1699
01:25:14,800 --> 01:25:17,910
在引擎盖下，和
剥开另一层

1700
01:25:17,910 --> 01:25:20,080
至今为止，我们已经
被完全忽略。

1701
01:25:20,080 --> 01:25:22,650
特别是，任何时间
我们已经实施了一项计划，

1702
01:25:22,650 --> 01:25:25,930
我们已经有这行代码
靠近顶部声明为主。

1703
01:25:25,930 --> 01:25:27,810
我们已经指定int主要无效。

1704
01:25:27,810 --> 01:25:31,240
>> 而括号内是无效
一直说这一切的时候了主

1705
01:25:31,240 --> 01:25:33,440
本身不带任何参数。

1706
01:25:33,440 --> 01:25:36,210
任何输入的主要是
打算从用户得到

1707
01:25:36,210 --> 01:25:39,020
有来自其他一些
机制，以获得更多INT，

1708
01:25:39,020 --> 01:25:42,040
或获得浮动，或得到的字符串，
或一些其它功能。

1709
01:25:42,040 --> 01:25:44,710
但事实证明，
当你写一个程序，

1710
01:25:44,710 --> 01:25:47,690
实际上你可以指定
这个计划应该

1711
01:25:47,690 --> 01:25:51,730
采取输入从人
在命令行本身。

1712
01:25:51,730 --> 01:25:56,310
>> 换言之，尽管我们迄今为止
一直只是运行./hello打招呼

1713
01:25:56,310 --> 01:26:00,312
或类似的程序，所有的
我们已经使用过其他方案，

1714
01:26:00,312 --> 01:26:02,770
我们自己没有写，
一直在服用，看来，

1715
01:26:02,770 --> 01:26:05,210
命令行arguments--
之类的东西作。

1716
01:26:05,210 --> 01:26:07,450
你这样说时许，
然后第二个字。

1717
01:26:07,450 --> 01:26:10,950
或铿锵，你说铛，然后
第二字，一个文件的名称。

1718
01:26:10,950 --> 01:26:14,410
>> 甚至RM或CP，你可能
见过或已经使用

1719
01:26:14,410 --> 01:26:15,880
删除或复制文件。

1720
01:26:15,880 --> 01:26:18,920
所有那些采取所谓的
命令行arguments--

1721
01:26:18,920 --> 01:26:21,130
在终端提示其他单词。

1722
01:26:21,130 --> 01:26:23,260
但是到现在为止，我们
自己还没有

1723
01:26:23,260 --> 01:26:27,080
这家豪华的同时从输入
用户在他或她实际运行

1724
01:26:27,080 --> 01:26:29,120
在命令行程序本身。

1725
01:26:29,120 --> 01:26:33,710
>> 但是，我们可以做到这一点通过重新申报
主要的前进，而不是有

1726
01:26:33,710 --> 01:26:36,750
无效括号中，
但是这两种说法

1727
01:26:36,750 --> 01:26:40,600
instead--第一的整数，
和第二事

1728
01:26:40,600 --> 01:26:44,170
新的东西，我们要打电话
一个数组，在精神上类似的东西

1729
01:26:44,170 --> 01:26:49,220
什么，我们在看到划痕作为一个列表，但
字符串数组，因为我们很快就会看到。

1730
01:26:49,220 --> 01:26:51,790
但是让我们通过看到这个
举例来说，以前我们

1731
01:26:51,790 --> 01:26:53,690
正是分辨是什么意思。

1732
01:26:53,690 --> 01:26:56,520
>> 所以，如果我进入CS50 IDE
在这里，我已经先行一步

1733
01:26:56,520 --> 01:27:01,840
而在一个名为文件中声明
argv0.c以下模板。

1734
01:27:01,840 --> 01:27:04,120
并注意唯一
这是不同的，到目前为止

1735
01:27:04,120 --> 01:27:08,570
是，我已经改变了空为int
ARGC ARGV串开支架，接近

1736
01:27:08,570 --> 01:27:09,070
托架。

1737
01:27:09,070 --> 01:27:11,730
并注意现在，有
没有这些括号内。

1738
01:27:11,730 --> 01:27:12,620
>> 有没有数。

1739
01:27:12,620 --> 01:27:15,070
而且没有我，或
n或任何其他字母。

1740
01:27:15,070 --> 01:27:17,010
我只是用
方括号现在，

1741
01:27:17,010 --> 01:27:19,510
对于原因，我们会来
回到一会儿就好了。

1742
01:27:19,510 --> 01:27:21,330
>> 而现在正是我要做的就是这一点。

1743
01:27:21,330 --> 01:27:26,680
如果ARGC等于等于2--
和召回等于等号

1744
01:27:26,680 --> 01:27:30,040
是平等的运营商比较
左和右的平等。

1745
01:27:30,040 --> 01:27:31,790
这不是分配
操作者，这是

1746
01:27:31,790 --> 01:27:36,510
单等号，这意味着副本
从右侧向左侧的一些值。

1747
01:27:36,510 --> 01:27:42,840
>> 如果ARGC等于等于2，我想
比如说，printf的，你好，百分数，新的生产线，

1748
01:27:42,840 --> 01:27:47,340
然后再插上in--和这里的新
trick-- argv的支架1，其原因

1749
01:27:47,340 --> 01:27:48,840
我们再回过头来在一个时刻。

1750
01:27:48,840 --> 01:27:52,110
如果ARGC没有别的
等于2，你知道吗？

1751
01:27:52,110 --> 01:27:57,400
就让我们继续前进，像往常一样，打印
出打招呼，没有替代的世界。

1752
01:27:57,400 --> 01:28:02,710
>> 所以它似乎如果ARGC，这
代表论点数，等于2，

1753
01:28:02,710 --> 01:28:04,740
我要打印出来
你好或其他东西。

1754
01:28:04,740 --> 01:28:07,560
否则，默认情况下，我
要打印的hello world。

1755
01:28:07,560 --> 01:28:08,770
所以，这是什么意思？

1756
01:28:08,770 --> 01:28:15,550
>> 好吧，让我继续前进，保存
该文件，然后执行使argv0，

1757
01:28:15,550 --> 01:28:18,940
然后./argv0，回车。

1758
01:28:18,940 --> 01:28:20,300
它的世界问好。

1759
01:28:20,300 --> 01:28:21,260
现在，这是为什么？

1760
01:28:21,260 --> 01:28:24,730
>> 那么，事实证明，任何时候你
在命令行中运行一个程序，

1761
01:28:24,730 --> 01:28:29,570
你都尽显我们会
通常调用的参数向量。

1762
01:28:29,570 --> 01:28:33,100
换句话说，自动
计算机，操作系统，

1763
01:28:33,100 --> 01:28:38,340
是要交给你的程序
本身所有的单词列表

1764
01:28:38,340 --> 01:28:40,850
该人的类型在
提示，如果你

1765
01:28:40,850 --> 01:28:43,790
程序员想要做的
一些与该信息。

1766
01:28:43,790 --> 01:28:48,540
并且在这种情况下，唯一字
我在提示符下键入是./argv0。

1767
01:28:48,540 --> 01:28:55,420
>> 等参数的数目是
被传递到我的计划是只有一个。

1768
01:28:55,420 --> 01:28:58,880
换言之，参数
算，也称为ARGC

1769
01:28:58,880 --> 01:29:00,970
这里为整数，只是其中的一个。

1770
01:29:00,970 --> 01:29:03,000
一，当然不相等的两个。

1771
01:29:03,000 --> 01:29:05,980
所以这就是打印，世界你好。

1772
01:29:05,980 --> 01:29:08,170
>> 但让我借这个地方。

1773
01:29:08,170 --> 01:29:09,930
让我说，argv0。

1774
01:29:09,930 --> 01:29:12,740
然后怎么样玛丽亚？

1775
01:29:12,740 --> 01:29:14,990
然后按Enter键。

1776
01:29:14,990 --> 01:29:18,020
>> 并注意什么神奇地发生在这里。

1777
01:29:18,020 --> 01:29:22,640
现在，而不是世界你好，我有
改变了这个程序的行为

1778
01:29:22,640 --> 01:29:26,310
由GET取输入不
串或一些其它功能，

1779
01:29:26,310 --> 01:29:30,570
但很显然，我的命令
本身，我在原来录入。

1780
01:29:30,570 --> 01:29:35,720
我可以再次玩这个游戏
它改变到斯泰利奥斯，例如。

1781
01:29:35,720 --> 01:29:38,400
>> 现在我看到另一名仍在。

1782
01:29:38,400 --> 01:29:40,540
而在这里，我可以说安迪。

1783
01:29:40,540 --> 01:29:42,137
我可能会说Zamyla。

1784
01:29:42,137 --> 01:29:45,220
我们可以整天玩这个游戏，
只是不同的价值观堵漏，

1785
01:29:45,220 --> 01:29:49,550
只要我正好提供
两个词在提示符下，

1786
01:29:49,550 --> 01:29:52,260
这样ARGC，我的说法算，为2。

1787
01:29:52,260 --> 01:29:57,240
>> 我看到这个名字插入
printf的，每个在这里这种情况？

1788
01:29:57,240 --> 01:30:00,550
所以，我们现在似乎有
的表现力

1789
01:30:00,550 --> 01:30:04,410
采取从其他机构中的输入，
从所谓的命令行

1790
01:30:04,410 --> 01:30:07,000
而不必等待
直到用户运行该程序，

1791
01:30:07,000 --> 01:30:10,220
然后提示他或她的
使用类似的GET字符串。

1792
01:30:10,220 --> 01:30:11,230
>> 所以，这是什么？

1793
01:30:11,230 --> 01:30:15,010
的argc，再次，仅仅是一个整数，
words-- arguments--数

1794
01:30:15,010 --> 01:30:18,540
，在所提供的用户
提示时，在终端窗口，

1795
01:30:18,540 --> 01:30:20,110
包括程序的名字。

1796
01:30:20,110 --> 01:30:23,340
因此，我们./argv0是有效的，
该程序的名字，

1797
01:30:23,340 --> 01:30:24,520
或如何我运行程序。

1798
01:30:24,520 --> 01:30:25,810
>> 这算作一个字。

1799
01:30:25,810 --> 01:30:27,080
所以ARGC是1。

1800
01:30:27,080 --> 01:30:29,750
但是，当我写斯泰利奥斯，或
岸堤，或Zamyla或玛丽亚，

1801
01:30:29,750 --> 01:30:31,660
这意味着参数计数为两个。

1802
01:30:31,660 --> 01:30:33,910
所以现在有两个词传入。

1803
01:30:33,910 --> 01:30:36,070
>> 和通知，我们可以继续这样的逻辑。

1804
01:30:36,070 --> 01:30:39,050
如果我居然说
像陈Zamyla，

1805
01:30:39,050 --> 01:30:42,200
全名，从而把
三个参数共，

1806
01:30:42,200 --> 01:30:47,410
现在它再次表示默认，
因为，当然，3不等于2。

1807
01:30:47,410 --> 01:30:54,080
>> 所以这样，我必须
通过argv的这个新说法访问

1808
01:30:54,080 --> 01:30:56,080
我们可以在技术上
叫我们想要的东西。

1809
01:30:56,080 --> 01:30:58,940
但按照惯例，这是
的argv和ARGC，分别为。

1810
01:30:58,940 --> 01:31:04,470
ARGV，参数向量，是种
用于编程的代名词

1811
01:31:04,470 --> 01:31:07,140
用C功能称为数组。

1812
01:31:07,140 --> 01:31:14,410
>> 阵列是类似的值的列表
背，背，背，背到。

1813
01:31:14,410 --> 01:31:17,810
换句话说，如果一个是这里在
RAM，下一个是它旁边，

1814
01:31:17,810 --> 01:31:18,800
和它旁边。

1815
01:31:18,800 --> 01:31:20,101
他们不是所有的地方。

1816
01:31:20,101 --> 01:31:23,100
而这后一种情况下，这里的东西
遍布在内存中的位置，

1817
01:31:23,100 --> 01:31:25,082
实际上可以是一个强大的功能。

1818
01:31:25,082 --> 01:31:28,040
但我们会回来的，我们当
说说票友的数据结构。

1819
01:31:28,040 --> 01:31:32,260
现在，数组只是一个
连续内存块，

1820
01:31:32,260 --> 01:31:36,520
每个其元素
背，背，背，背，

1821
01:31:36,520 --> 01:31:38,050
和大致相同的类型。

1822
01:31:38,050 --> 01:31:42,630
>> 所以，如果你仔细想想，从
刚才，什么是字符串？

1823
01:31:42,630 --> 01:31:50,460
那么，一个字符串，如Zamyla，
Z-A-M-Y-L-A，是，技术上，

1824
01:31:50,460 --> 01:31:51,400
只是阵列。

1825
01:31:51,400 --> 01:31:53,700
它是一个字符数组。

1826
01:31:53,700 --> 01:31:59,250
>> 所以，如果我们真的得出这样的，因为我
先前做的，作为一个内存块，

1827
01:31:59,250 --> 01:32:04,510
事实证明，每一种
字符占用一个字节。

1828
01:32:04,510 --> 01:32:07,630
然后还有那个特别的
标记字符，反斜线0，

1829
01:32:07,630 --> 01:32:12,360
或全部八个0位，即
划定该字符串的结尾。

1830
01:32:12,360 --> 01:32:15,090
因此，一个字符串，它变成
出，报价引文结束的字符串，

1831
01:32:15,090 --> 01:32:20,580
只是chara--的阵列
烧焦作为一个实际的数据类型。

1832
01:32:20,580 --> 01:32:24,560
>> 而现在的argv，meanwhile--
让我们回到节目。

1833
01:32:24,560 --> 01:32:29,582
ARGV，尽管我们看到这个词
这里的字符串，是不是字符串本身。

1834
01:32:29,582 --> 01:32:33,640
ARGV，参数向量，
是一个字符串数组。

1835
01:32:33,640 --> 01:32:37,620
>> 因此，正如你可以有数组
字符，你可以有较高的水平，

1836
01:32:37,620 --> 01:32:46,279
的strings--阵列如此，例如，
当我输入刚才./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0，空间Z-A-M-Y-L-A，我声称，
ARGV曾在它 -  ./argv0两个字符串，

1838
01:33:00,150 --> 01:33:03,185
和Z-A-M-Y-L-A。在
换句话说，的argc为2。

1839
01:33:03,185 --> 01:33:03,980
这是为什么？

1840
01:33:03,980 --> 01:33:08,370
>> 那么，有效的，这是怎么回事
上是每个这些字符串的

1841
01:33:08,370 --> 01:33:13,990
是，当然，字符数组
和以前一样，它的每个字符

1842
01:33:13,990 --> 01:33:15,670
占用一个字节。

1843
01:33:15,670 --> 01:33:19,720
不要混淆实际0
在节目的标有0名，

1844
01:33:19,720 --> 01:33:22,040
这意味着所有80位。

1845
01:33:22,040 --> 01:33:27,140
和Zamyla，同时，仍
也字符数组。

1846
01:33:27,140 --> 01:33:31,450
>> 这样在一天结束时，它确实
看起来是这样的引擎盖下面。

1847
01:33:31,450 --> 01:33:38,800
但是ARGV，由大自然如何主力
作品，让我来包装这一切

1848
01:33:38,800 --> 01:33:44,810
成，如果你愿意，一个更大的阵列
，如果我们稍稍高出简化

1849
01:33:44,810 --> 01:33:48,180
什么画面看起来喜欢和不
相当绘制规模那里，

1850
01:33:48,180 --> 01:33:56,720
这个阵列只有大小为2，第一次
元件，它的包含字符串，

1851
01:33:56,720 --> 01:33:59,230
的第二元件
其中包含的字符串。

1852
01:33:59,230 --> 01:34:01,687
并且，反过来，如果
一种放大每个

1853
01:34:01,687 --> 01:34:03,770
这些字符串的你
看到引擎盖下

1854
01:34:03,770 --> 01:34:07,190
是，每串是仅仅
字符数组。

1855
01:34:07,190 --> 01:34:11,680
>> 现在，就如同用字符串，
我们能够获得访问

1856
01:34:11,680 --> 01:34:15,260
在一个字符串的第i个字符
使用方括号。

1857
01:34:15,260 --> 01:34:17,320
同样，阵列
一般来说，我们可以

1858
01:34:17,320 --> 01:34:22,700
用方括号来获得
在阵列中的任何数量的字符串？

1859
01:34:22,700 --> 01:34:25,100
例如，让我
继续前进，做到这一点。

1860
01:34:25,100 --> 01:34:32,420
>> 让我继续前进，创造argv1.c，
这是一个有点不同，这一次。

1861
01:34:32,420 --> 01:34:35,635
相反，检查argc2的，
我要代替做到这一点。

1862
01:34:35,635 --> 01:34:41,270
对于int我得到0，我是少
比ARGC，我加再加，

1863
01:34:41,270 --> 01:34:47,920
然后这里面打印出来，
％的S，新的生产线，然后

1864
01:34:47,920 --> 01:34:50,740
argv的支架我。

1865
01:34:50,740 --> 01:34:55,220
>> 因此，换句话说，我不处理
此刻单个字符。

1866
01:34:55,220 --> 01:35:00,190
ARGV，所暗示这些空方
括号的名称的argv的权利，

1867
01:35:00,190 --> 01:35:03,320
指的argv是一个字符串数组。

1868
01:35:03,320 --> 01:35:04,870
和ARGC只是一个int。

1869
01:35:04,870 --> 01:35:08,800
>> 在这里这条线，6是
说一套i等于0。

1870
01:35:08,800 --> 01:35:11,980
计算所有达路，
但不包括的argc。

1871
01:35:11,980 --> 01:35:14,010
然后在每次迭代中，
打印出字符串。

1872
01:35:14,010 --> 01:35:14,800
什么字符串？

1873
01:35:14,800 --> 01:35:17,270
>> 第i个字符串argv中。

1874
01:35:17,270 --> 01:35:19,530
所以，从前我是前
用方括号

1875
01:35:19,530 --> 01:35:22,180
方式就可以得到第i
字符的字符串，现在

1876
01:35:22,180 --> 01:35:27,240
我用方括号
获得在一个数组的第i个字符串。

1877
01:35:27,240 --> 01:35:30,310
因此，它是一种一层
以上概念。

1878
01:35:30,310 --> 01:35:35,390
>> 还等什么是整齐这个
现在的程序，如果我编译argv1，

1879
01:35:35,390 --> 01:35:42,067
然后做./argv1，然后键入
在类似富酒吧巴兹，

1880
01:35:42,067 --> 01:35:45,400
这是三个默认的话，一个
计算机科学家到达任何时间

1881
01:35:45,400 --> 01:35:51,010
他或她需要一些占位的话，
并按下回车键，每一个的这些话，

1882
01:35:51,010 --> 01:35:54,980
包括程序的名称，
是argv中在第一位置，

1883
01:35:54,980 --> 01:35:58,320
最终被印刷一次一个。

1884
01:35:58,320 --> 01:36:05,290
如果我改变这一点，我说
像argv1 Zamyla陈，

1885
01:36:05,290 --> 01:36:08,800
我们得到了所有这三个的
也就是说，这是argv0，

1886
01:36:08,800 --> 01:36:14,400
argv1，argv2，因为在这种
ARGC的情况下，计数，为3。

1887
01:36:14,400 --> 01:36:20,020
>> 但是，什么是整齐的是，如果你明白
那argv的只是一个字符串数组，

1888
01:36:20,020 --> 01:36:24,910
你明白一个字符串
是一个字符数组，

1889
01:36:24,910 --> 01:36:29,470
我们实际上可以种使用该
方括号多次

1890
01:36:29,470 --> 01:36:33,320
选择一个字符串，然后选择
字符串中的字符，

1891
01:36:33,320 --> 01:36:35,730
潜水更深如下。

1892
01:36:35,730 --> 01:36:40,100
在这个例子中，让我去
前进，称之为argv2.c。

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
而在这个例子中，让我先走
并做following--对于int我得到0，

1895
01:36:50,180 --> 01:36:53,286
i小于的argc，我加
再加上，就像以前一样。

1896
01:36:53,286 --> 01:36:55,910
因此，在其他words--现在这个
越来越复杂的足够了。

1897
01:36:55,910 --> 01:36:59,940
然后我会说
遍历argv中的字符串，

1898
01:36:59,940 --> 01:37:01,294
作为对自己的注释。

1899
01:37:01,294 --> 01:37:03,960
然后我将有一个
嵌套的循环，你可能

1900
01:37:03,960 --> 01:37:06,290
这样做，或认为
这样做，在划痕，其中

1901
01:37:06,290 --> 01:37:08,600
我要说int--我
不会再使用我，

1902
01:37:08,600 --> 01:37:12,590
因为我不想影子，或
排序覆盖现有的我。

1903
01:37:12,590 --> 01:37:15,780
>> 我打算，相反，J个，因为
这是我去到的变量后，我，

1904
01:37:15,780 --> 01:37:18,590
当我只是想
算简单的数字。

1905
01:37:18,590 --> 01:37:28,850
对于j得到0--并且还，正，将要
得到的argv支架我的船尾长，

1906
01:37:28,850 --> 01:37:36,030
只要j是小于M，
Ĵ加再加，做到以下几点。

1907
01:37:36,030 --> 01:37:37,500
而这里的有趣的部分。

1908
01:37:37,500 --> 01:37:46,330
>> 打印出一个字符和一个新的生产线，
堵漏argv中我支架，支​​架学家

1909
01:37:46,330 --> 01:37:47,940
好了，让我在这里补充一些意见。

1910
01:37:47,940 --> 01:37:54,820
遍历字符
在当前字符串，

1911
01:37:54,820 --> 01:38:02,290
在第i个字符串打印j个字符。

1912
01:38:02,290 --> 01:38:04,630
所以，现在，让我们考虑
这是什么意思的意见。

1913
01:38:04,630 --> 01:38:06,750
>> 遍历字符串
在argv--多少

1914
01:38:06,750 --> 01:38:09,300
字符串的argv，它是一个数组？

1915
01:38:09,300 --> 01:38:13,420
ARGC很多，所以我遍历
从i等于0到ARGC。

1916
01:38:13,420 --> 01:38:20,020
同时，多少个字符
是argv中的第i个字符串中？

1917
01:38:20,020 --> 01:38:22,880
>> 好了，得到的答案，
我只需要调用字符串长度

1918
01:38:22,880 --> 01:38:26,810
在当前字符串我照顾
对，这是argv的支架我。

1919
01:38:26,810 --> 01:38:30,090
我要去临时存储
值N，只是为了缓存目的，

1920
01:38:30,090 --> 01:38:31,590
记住它的效率。

1921
01:38:31,590 --> 01:38:36,330
然后，我会初始化J即可0，
继续下去，只要j是小于n，

1922
01:38:36,330 --> 01:38:38,430
并在每次迭代增量学家

1923
01:38:38,430 --> 01:38:41,030
>> 然后在这里，每
我的第12行评论，

1924
01:38:41,030 --> 01:38:43,390
打印出一个字符，
其次是一个新行，

1925
01:38:43,390 --> 01:38:48,140
具体的argv支架
我给我的第i个串

1926
01:38:48,140 --> 01:38:51,690
在argv--所以第一句话，
第二个字，第三字，等等。

1927
01:38:51,690 --> 01:38:57,370
和则J潜水更深，并获得
我该单词的第j个字符。

1928
01:38:57,370 --> 01:39:02,200
因此，实际上，你可以把
的argv作为多维的，

1929
01:39:02,200 --> 01:39:06,050
作为一个二维的，阵列
其中的每一个字那种长相

1930
01:39:06,050 --> 01:39:08,580
像这样在你的心中的
眼，每一个人物

1931
01:39:08,580 --> 01:39:10,930
是种组成，在
一列，是否有帮助。

1932
01:39:10,930 --> 01:39:13,260
>> 在现实中，当我们逗
这除了在未来数周，

1933
01:39:13,260 --> 01:39:15,580
这将是一个小
比这更复杂。

1934
01:39:15,580 --> 01:39:17,800
但是，你可真
想不到的是，就目前而言，

1935
01:39:17,800 --> 01:39:22,110
因为眼前这个二维
它阵列，其中一个水平

1936
01:39:22,110 --> 01:39:23,260
是所有的字符串。

1937
01:39:23,260 --> 01:39:26,760
然后，如果你在更深，你潜水
可以得到在各个字符

1938
01:39:26,760 --> 01:39:29,600
这里所使用这个符号在其中。

1939
01:39:29,600 --> 01:39:31,620
>> 那么，什么是实际效果？

1940
01:39:31,620 --> 01:39:34,970
让我继续前进，
使argv2--织补它。

1941
01:39:34,970 --> 01:39:36,210
我在这里犯了一个错误。

1942
01:39:36,210 --> 01:39:40,160
隐含声明
库函数斯特林。

1943
01:39:40,160 --> 01:39:42,190
所以，这一切的时候，它的
也许是适当的

1944
01:39:42,190 --> 01:39:45,130
我们正在排序整理
正是我们开始的地方。

1945
01:39:45,130 --> 01:39:48,160
>> 我搞砸了，隐式声明
库函数斯特林。

1946
01:39:48,160 --> 01:39:48,987
OK，等一下。

1947
01:39:48,987 --> 01:39:51,070
我记得，尤其是
因为它是在这里。

1948
01:39:51,070 --> 01:39:54,490
我需要包括string.h中的
这个版本的程序。

1949
01:39:54,490 --> 01:40:00,050
>> 让我继续前进，包括
string.h中，保存，勇往直前

1950
01:40:00,050 --> 01:40:04,460
并重新编译argv2。

1951
01:40:04,460 --> 01:40:08,390
而现在，我们开始吧，让argv2，回车。

1952
01:40:08,390 --> 01:40:10,590
虽然这是一个有点
神秘的第一眼，

1953
01:40:10,590 --> 01:40:15,690
公告称，的确，
印刷是点argv2。

1954
01:40:15,690 --> 01:40:19,970
>> 但是，如果我输入后有些字
提示，像argv2 Zamyla陈，

1955
01:40:19,970 --> 01:40:22,560
回车，也有点
神秘的第一眼。

1956
01:40:22,560 --> 01:40:30,540
但是，如果我们滚动回涨，
./argv2 Z-A-M-Y-L-A C-H-A-N。

1957
01:40:30,540 --> 01:40:32,190
因此，我们遍历每一个字。

1958
01:40:32,190 --> 01:40:37,770
而反过来，我们遍历
一个字中的每一个字符。

1959
01:40:37,770 --> 01:40:40,040
>> 现在，经过这一切，
意识到有

1960
01:40:40,040 --> 01:40:43,120
另外一个细节，我们已经种
中忽略这一整个时间。

1961
01:40:43,120 --> 01:40:46,180
我们只是挑开什么
主要的投入可以吗？

1962
01:40:46,180 --> 01:40:47,780
怎么样主要的输出？

1963
01:40:47,780 --> 01:40:50,540
>> 所有这一切的时候，我们一直
只是复制和粘贴

1964
01:40:50,540 --> 01:40:53,870
在主阵地字INT，
虽然你可能在网上看到，

1965
01:40:53,870 --> 01:40:58,340
有时在旧版本不正确
C和编译器的，他们说无效，

1966
01:40:58,340 --> 01:40:59,410
还是什么都没有。

1967
01:40:59,410 --> 01:41:01,580
但是，实际上，对于版本
的C我们使用，

1968
01:41:01,580 --> 01:41:06,180
C 11，或2011年，实现
它应该是i​​nt。

1969
01:41:06,180 --> 01:41:09,300
它应该要么是
无效或argc和argv在这里。

1970
01:41:09,300 --> 01:41:10,790
>> 但是，为什么INT主？

1971
01:41:10,790 --> 01:41:12,480
它是什么实际上返回？

1972
01:41:12,480 --> 01:41:16,280
那么，事实证明这一切的时候，
任何时候你已经写了一个程序的主

1973
01:41:16,280 --> 01:41:18,440
总是返回的东西。

1974
01:41:18,440 --> 01:41:19,960
但它一直这样做秘密。

1975
01:41:19,960 --> 01:41:23,350
>> 这东西是
INT，如第5行显示。

1976
01:41:23,350 --> 01:41:24,225
但是什么诠释？

1977
01:41:24,225 --> 01:41:26,100
嗯，有这个
约定编程，

1978
01:41:26,100 --> 01:41:29,790
因此，如果没有了
出了问题，一切都很好，

1979
01:41:29,790 --> 01:41:34,250
程序和一般功能
return--有些counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0。

1981
01:41:35,230 --> 01:41:38,070
0通常意味着一切都很好。

1982
01:41:38,070 --> 01:41:40,610
因此，即使你觉得
它在很多情况下是假的，

1983
01:41:40,610 --> 01:41:42,930
它实际上通常意味着一件好事

1984
01:41:42,930 --> 01:41:49,560
>> 同时，如果一个程序返回1，
或负1，或5，或负42

1985
01:41:49,560 --> 01:41:52,941
或任何非0的值，
这通常意味着

1986
01:41:52,941 --> 01:41:54,190
那出了问题。

1987
01:41:54,190 --> 01:41:56,700
事实上，在你自己的Mac或PC，
你可能已经看到实际

1988
01:41:56,700 --> 01:42:01,050
的错误消息，由此
说了什么或其他错误

1989
01:42:01,050 --> 01:42:04,940
代码负42，或错误代码
23，或者类似的东西。

1990
01:42:04,940 --> 01:42:08,980
这个数字通常是只是一个提示
给程序员，或公司

1991
01:42:08,980 --> 01:42:11,174
该取得的软件，
什么地方出了错，为什么，

1992
01:42:11,174 --> 01:42:13,590
使他们可以通过看
他们的文档或代码，

1993
01:42:13,590 --> 01:42:15,465
并找出什么
错误实际上意味着。

1994
01:42:15,465 --> 01:42:18,400
它一般不
对我们有用的最终用户。

1995
01:42:18,400 --> 01:42:20,550
>> 但是，当主返回0，一切都很好。

1996
01:42:20,550 --> 01:42:23,770
如果你不指定
什么主要应返回，

1997
01:42:23,770 --> 01:42:26,950
它只是会自动
你返回0。

1998
01:42:26,950 --> 01:42:30,870
但返回的东西
否则实际上是有用的。

1999
01:42:30,870 --> 01:42:34,660
>> 在这最后的节目，让我
继续前进，把这个exit.c中，

2000
01:42:34,660 --> 01:42:38,630
并介绍了去年今天的
主题，已知的作为错误代码。

2001
01:42:38,630 --> 01:42:42,930
让我继续前进，包括我们
熟悉的文件往上顶，这样做主要INT。

2002
01:42:42,930 --> 01:42:49,500
而这个时候，让我们做INT ARGC，
字符串的argv，并与我的支架

2003
01:42:49,500 --> 01:42:50,836
暗示它的数组中为止。

2004
01:42:50,836 --> 01:42:52,460
然后让我只是做一个全面的检查。

2005
01:42:52,460 --> 01:42:56,640
这个时候，如果ARGC不
等于2，那么你知道吗？

2006
01:42:56,640 --> 01:42:57,520
算了吧。

2007
01:42:57,520 --> 01:43:03,170
我会说，嘿，用户，
你缺少命令行参数

2008
01:43:03,170 --> 01:43:04,210
反斜杠ñ。

2009
01:43:04,210 --> 01:43:05,230
>> 然后就是这样。

2010
01:43:05,230 --> 01:43:06,130
我想退出。

2011
01:43:06,130 --> 01:43:11,030
我要先发制人，
过早真的，回报

2012
01:43:11,030 --> 01:43:12,810
东西比1号等。

2013
01:43:12,810 --> 01:43:15,360
转到价值第一
错误可能发生1。

2014
01:43:15,360 --> 01:43:17,860
如果你有一些其他错误
可能出现的情况，

2015
01:43:17,860 --> 01:43:21,390
你可能会说回报2或3回，或
甚至负1或负2。

2016
01:43:21,390 --> 01:43:23,750
>> 这些只是退出代码
是，一般地，

2017
01:43:23,750 --> 01:43:27,770
唯一有用给程序员，或
公司认为航运该软件。

2018
01:43:27,770 --> 01:43:30,500
但事实上，它是
不为0是非常重要的。

2019
01:43:30,500 --> 01:43:34,310
所以，如果在这个方案，我想
保证这个程序只

2020
01:43:34,310 --> 01:43:38,190
工作，如果用户提供了我
有两个参数计数，

2021
01:43:38,190 --> 01:43:42,880
程序的名字，以及其他一些
总之，我可以执行如下之多，

2022
01:43:42,880 --> 01:43:46,110
骂与printf的话说用户，
缺少命令行参数，

2023
01:43:46,110 --> 01:43:46,970
返回1。

2024
01:43:46,970 --> 01:43:49,940
这只会立即
退出程序。

2025
01:43:49,940 --> 01:43:55,840
>> 只有当ARGC等于2，我们将踏踏实实
在这里，在这一点上，我会说，

2026
01:43:55,840 --> 01:44:00,410
你好％的S，反斜线N，argv1。

2027
01:44:00,410 --> 01:44:03,827
换句话说，我
argv的0后不会去，

2028
01:44:03,827 --> 01:44:05,410
这是节目的只是名称。

2029
01:44:05,410 --> 01:44:09,450
我想打印出来打招呼，逗号，
第二个字，人键入。

2030
01:44:09,450 --> 01:44:12,580
在这种情况下上
13号线，一切都很好。

2031
01:44:12,580 --> 01:44:15,920
>> 我知道的argc为2
逻辑上这个节目。

2032
01:44:15,920 --> 01:44:17,770
我要继续前进，返回0。

2033
01:44:17,770 --> 01:44:21,230
顺便说一句，请记住，
这是划痕也是如此。

2034
01:44:21,230 --> 01:44:24,760
>> 从逻辑上讲，我可以这样做
和封装这些行

2035
01:44:24,760 --> 01:44:27,020
在这里这个else子句的代码。

2036
01:44:27,020 --> 01:44:29,420
但是，这样的
不必要的缩进我的代码。

2037
01:44:29,420 --> 01:44:31,800
我想使超
显然，不管是什么，

2038
01:44:31,800 --> 01:44:34,670
默认情况下，你好
事情会得到印，

2039
01:44:34,670 --> 01:44:36,050
只要用户合作。

2040
01:44:36,050 --> 01:44:39,360
>> 所以这是很常见的使用
一个条件，只是一个如果，

2041
01:44:39,360 --> 01:44:41,870
捕捉一些错误
情况，然后退出。

2042
01:44:41,870 --> 01:44:45,690
然后，只要一切
好了，没有一个东西，

2043
01:44:45,690 --> 01:44:48,060
只是有码
外，如果，因为它是

2044
01:44:48,060 --> 01:44:51,060
相当于在这
特殊情况下，逻辑上。

2045
01:44:51,060 --> 01:44:54,480
所以我返回0，只是
明确表示一切都很好。

2046
01:44:54,480 --> 01:44:58,480
>> 如果我省略了返回0时，它会
自动假设我。

2047
01:44:58,480 --> 01:45:00,890
但现在，我要回
之一的至少这种情况下，

2048
01:45:00,890 --> 01:45:04,940
我要去，好措施和
清楚起见，在这种情况下返回0。

2049
01:45:04,940 --> 01:45:09,690
所以，现在让我继续前进，使退出，
这是一个完美的SEGUE见好就收。

2050
01:45:09,690 --> 01:45:14,401
>> 但要退出，让我去
继续做./exit，回车。

2051
01:45:14,401 --> 01:45:16,900
该程序大喊我，
缺少命令行参数。

2052
01:45:16,900 --> 01:45:18,120
OK，让我配合。

2053
01:45:18,120 --> 01:45:23,810
>> 让我来代替做./exit，大卫，回车。

2054
01:45:23,810 --> 01:45:25,190
而现在它说，你好大卫。

2055
01:45:25,190 --> 01:45:27,300
你通常不会看到这一点。

2056
01:45:27,300 --> 01:45:30,650
>> 但事实证明，有一个
在Linux中特殊的方式来实际看看

2057
01:45:30,650 --> 01:45:34,470
什么退出代码的程序退出。

2058
01:45:34,470 --> 01:45:37,184
有时在图形
世界像的Mac OS或Windows，

2059
01:45:37,184 --> 01:45:40,100
你只看到这些数字时
错误消息在屏幕上弹出

2060
01:45:40,100 --> 01:45:41,940
和编程
显示了该号码。

2061
01:45:41,940 --> 01:45:44,773
但是，如果我们想看到什么错误
消息是，我们可以做到这一点这里 - 

2062
01:45:44,773 --> 01:45:48,100
所以./exit，输入，打印
缺少命令行参数。

2063
01:45:48,100 --> 01:45:54,590
>> 如果我现在做的回声$？这是
可笑的神秘期待。

2064
01:45:54,590 --> 01:45:56,590
但是$？

2065
01:45:56,590 --> 01:45:59,220
是神奇的咒语
，说，哎，电脑，

2066
01:45:59,220 --> 01:46:01,900
告诉我以前的
程序的退出代码了。

2067
01:46:01,900 --> 01:46:03,410
我敲回车。

2068
01:46:03,410 --> 01:46:07,520
我看到1，因为这是我
告诉我的主要功能返回。

2069
01:46:07,520 --> 01:46:12,310
>> 同时，如果我这样做./exit大卫
并按下回车键，我明白了，你好大卫。

2070
01:46:12,310 --> 01:46:16,800
如果我现在做的回声$？我看你好0。

2071
01:46:16,800 --> 01:46:19,080
所以这实际上
是有价值的信息

2072
01:46:19,080 --> 01:46:23,420
在调试器的情况下，不那么
多，你的人，会照顾。

2073
01:46:23,420 --> 01:46:26,060
但是，调试器和其他
程序，我们将利用这个学期

2074
01:46:26,060 --> 01:46:29,420
会经常看这个数字，
尽管这有点藏起来

2075
01:46:29,420 --> 01:46:32,780
除非你去找吧，
确定是否一个程序的

2076
01:46:32,780 --> 01:46:37,050
执行是正确或不正确的。

2077
01:46:37,050 --> 01:46:40,450
>> 所以说给我们带来
此，在一天结束。

2078
01:46:40,450 --> 01:46:43,917
今天，我们开始通过查看
调试，并依次在课程

2079
01:46:43,917 --> 01:46:46,750
本身，然后更有趣的是，
技术上下方的引擎盖

2080
01:46:46,750 --> 01:46:49,490
在什么字符串，它持续
本周我们只是想当然，

2081
01:46:49,490 --> 01:46:51,900
当然把他们
理所当然的划痕。

2082
01:46:51,900 --> 01:46:56,040
>> 然后，我们看我们如何可以访问
在一个字符串的各个字符，

2083
01:46:56,040 --> 01:47:00,310
然后又拿起一个较高的水平
看待事物，寻求如何well--

2084
01:47:00,310 --> 01:47:04,226
如果我们想获得个别
在这样的结构列表中的元素，

2085
01:47:04,226 --> 01:47:05,850
我们不能做到这一点与多个字符串？

2086
01:47:05,850 --> 01:47:08,050
我们可以用命令行参数。

2087
01:47:08,050 --> 01:47:12,800
但是，这幅画在这里只是盒
是示范这种总体思路

2088
01:47:12,800 --> 01:47:14,451
的阵列，或列表，或者一个矢量。

2089
01:47:14,451 --> 01:47:16,450
并根据
的背景下，所有的这些话

2090
01:47:16,450 --> 01:47:17,880
意思是略有不同的事情。

2091
01:47:17,880 --> 01:47:20,060
因此，在C，我们只打算
谈论一个数组。

2092
01:47:20,060 --> 01:47:23,840
而一个数组是一大块
内存，每个人的

2093
01:47:23,840 --> 01:47:27,720
元件是连续的，背部，
背，背，背到。

2094
01:47:27,720 --> 01:47:31,970
>> 与这些元素是，一般地，
相同的数据类型，字符，

2095
01:47:31,970 --> 01:47:35,966
人品，人品，性格，或
字符串，字符串，字符串，字符串或者int

2096
01:47:35,966 --> 01:47:38,600
INT，INT，不管它是什么
我们试图商店。

2097
01:47:38,600 --> 01:47:42,540
但在一天结束时，这是
它看起来像什么概念。

2098
01:47:42,540 --> 01:47:44,530
你把你的
计算机的存储器或RAM中。

2099
01:47:44,530 --> 01:47:48,590
而你刻出来成
相同尺寸的盒，所有这些都

2100
01:47:48,590 --> 01:47:50,920
回来了，要背，
背，背这个样子。

2101
01:47:50,920 --> 01:47:53,200
>> 什么是关于好的
这个想法和事实

2102
01:47:53,200 --> 01:47:58,580
我们能够表达这样的值
与第一我们的数据结构的

2103
01:47:58,580 --> 01:48:02,520
在课堂上，意味着我们可以开始
解决与代码的问题

2104
01:48:02,520 --> 01:48:04,079
即0的一周里那么直观。

2105
01:48:04,079 --> 01:48:05,870
你还记得手机
书实施例，其中

2106
01:48:05,870 --> 01:48:09,110
我们使用了分而治之，
或二进制搜索算法，

2107
01:48:09,110 --> 01:48:13,220
通过一个整体进行筛选
一堆的名称和号码。

2108
01:48:13,220 --> 01:48:18,220
但是，我们认为，召回，这是
电话本已经被排序，

2109
01:48:18,220 --> 01:48:21,630
别人已经
想通out--给出的名单

2110
01:48:21,630 --> 01:48:24,430
和numbers--如何按字母顺序排列它们。

2111
01:48:24,430 --> 01:48:26,950
而现在，在C我们，
也有能力

2112
01:48:26,950 --> 01:48:30,290
打好东西出来，不
物理在电话簿

2113
01:48:30,290 --> 01:48:34,220
但几乎在一台电脑的
记忆，我们将能够在下周

2114
01:48:34,220 --> 01:48:38,470
到this--第一次推出
在一个array--我们的数据结构的

2115
01:48:38,470 --> 01:48:43,530
但更重要的是，实际的计算机
科学的算法实现

2116
01:48:43,530 --> 01:48:47,720
在代码，与我们可以存储
在这样的结构数据，

2117
01:48:47,720 --> 01:48:50,730
然后开始操纵它，
真正解决问题呢，

2118
01:48:50,730 --> 01:48:53,570
并建立最重要的是，
最终，在C程序中，

2119
01:48:53,570 --> 01:48:56,730
在Python，JavaScript中，
查询SQL数据库？

2120
01:48:56,730 --> 01:48:59,980
>> 我们将看到所有这些
不同的想法互锁。

2121
01:48:59,980 --> 01:49:04,100
但现在，记得
我们今天介绍域

2122
01:49:04,100 --> 01:49:06,920
是这个东西在这里，和
世界加密的。

2123
01:49:06,920 --> 01:49:11,200
而接下来的问题，你自己之间
将解决是密码学的艺术，

2124
01:49:11,200 --> 01:49:13,630
加扰和解扰
信息，和加密

2125
01:49:13,630 --> 01:49:15,930
和破译的文字，
并假定最终

2126
01:49:15,930 --> 01:49:18,970
你现在知道什么
是引擎盖下

2127
01:49:18,970 --> 01:49:21,860
所以，当你看到或收到
这样的消息，你

2128
01:49:21,860 --> 01:49:24,060
你自己可以破译它。

2129
01:49:24,060 --> 01:49:26,740
所有这一切，以及更多下一次。

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [视频回放]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover刚到。

2133
01:49:32,970 --> 01:49:35,146
我要去拜访
他的大学教授。

2134
01:49:35,146 --> 01:49:37,611
是的。

2135
01:49:37,611 --> 01:49:40,080
你好。

2136
01:49:40,080 --> 01:49:40,660
是你。

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
等待！

2139
01:49:45,110 --> 01:49:45,610
大卫。

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
我只是想图
出了什么事给你。

2142
01:49:56,060 --> 01:49:58,130
请，什么事情都可能帮助。

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
你是他的大学
室友，不是吗？

2145
01:50:08,354 --> 01:50:10,770
你跟他的时候在那里
他完成了CS50的项目？

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [音乐]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>>  - 那是CS50。

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> 我喜欢这个地方。

2152
01:50:44,770 --> 01:50:45,854
>> -Eat起来。

2153
01:50:45,854 --> 01:50:47,020
我们走出去的企业。

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [结束播放]

