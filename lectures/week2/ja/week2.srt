1
00:00:00,000 --> 00:00:02,970
>> [MUSICのPLAYING]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J.マラン：すべての権利。

4
00:00:15,700 --> 00:00:18,832
これはCS50およびこれです
2週目の開始です。

5
00:00:18,832 --> 00:00:21,040
そして、あなたはそれを超える思い出し
過去数週間、

6
00:00:21,040 --> 00:00:24,490
我々は、コンピュータを導入してきました
科学とは、順番に、プログラミング。

7
00:00:24,490 --> 00:00:27,640
>> そして、我々は、を介して話を始めました
スクラッチ、そのグラフィカル言語

8
00:00:27,640 --> 00:00:28,990
MITのメディアラボから。

9
00:00:28,990 --> 00:00:30,780
そして、最近、
先週、私たちはやりました

10
00:00:30,780 --> 00:00:34,450
higher-- aを導入します
下位レベルの言語は、既知の

11
00:00:34,450 --> 00:00:36,770
C、純粋にテキスト何かとして。

12
00:00:36,770 --> 00:00:39,440
そして、確かに、最後の時間、私たち
その文脈の中で模索

13
00:00:39,440 --> 00:00:40,450
概念の数。

14
00:00:40,450 --> 00:00:43,010
>> これ、リコール、非常にでした
私たちが見た最初のプログラム。

15
00:00:43,010 --> 00:00:45,710
そして、このプログラムは、非常に単純に、
プリントアウトし、 "こんにちは、世界。」

16
00:00:45,710 --> 00:00:47,730
しかし、そんなにあります
見せかけの魔法が起こっています。

17
00:00:47,730 --> 00:00:51,460
これの#includeがあります
これらの角括弧付き。

18
00:00:51,460 --> 00:00:52,170
int型があります。

19
00:00:52,170 --> 00:00:53,020
（ボイド）があります。

20
00:00:53,020 --> 00:00:56,330
括弧、中括弧があります、
セミコロン、およびそんなに多く。

21
00:00:56,330 --> 00:00:58,480
>> そしてそう、ということを思い出します
我々はスクラッチを導入しました

22
00:00:58,480 --> 00:01:02,110
私たちは、理想的には、過去を見ることができるように、
その構文、本当にないですもの

23
00:01:02,110 --> 00:01:04,590
知的すべてのこと
早い段階で興味深いが、

24
00:01:04,590 --> 00:01:07,700
、絶対に、少しトリッキーです
あなたの心をラップアラウンドします。

25
00:01:07,700 --> 00:01:10,860
そして、確かに、最も一般的なの一つ
早い段階でのプログラミングクラスのもの、

26
00:01:10,860 --> 00:01:13,443
特に以下のもののために
快適でイライラすることです

27
00:01:13,443 --> 00:01:17,460
および特定の統語によってアップトリップ
エラーは、論理エラーは言うまでもありません。

28
00:01:17,460 --> 00:01:19,800
だから我々の目標のうち、
今日、実際には、意志

29
00:01:19,800 --> 00:01:23,280
いくつかであなたを装備すること
どのようにするための問題解決技法

30
00:01:23,280 --> 00:01:26,705
より良い問題そのものを解決するために
デバッグの形態です。

31
00:01:26,705 --> 00:01:29,330
そして、あなたは、あまりにも、思い出すことでしょう
我々は導入環境

32
00:01:29,330 --> 00:01:31,780
前回は、CS50 IDEと呼ばれていました。

33
00:01:31,780 --> 00:01:34,850
これは、ウェブベースのソフトウェアです
あなたは雲の中にプログラムすることができ、

34
00:01:34,850 --> 00:01:38,450
ので、あなたのすべてを維持しながら、話すこと
我々は再び今日れるように、ファイルを一緒。

35
00:01:38,450 --> 00:01:41,480
そして、その私たちを思い出します
ここではこれらのトピックを再訪し、

36
00:01:41,480 --> 00:01:44,480
その中で機能し、ループ、
変数、ブール式、

37
00:01:44,480 --> 00:01:45,110
そして、条件。

38
00:01:45,110 --> 00:01:49,190
そして、我々その実際にいくつかのより多くの
スクラッチの世界から翻訳

39
00:01:49,190 --> 00:01:50,800
Cの世界へ

40
00:01:50,800 --> 00:01:53,220
>> しかし、基本的なビルディング
いわばブロック、

41
00:01:53,220 --> 00:01:55,150
本当にまだ同じ先週でした。

42
00:01:55,150 --> 00:01:57,900
実際に、私たちは本当にちょうど持っていました
異なるパズルのピース、可能ならば。

43
00:01:57,900 --> 00:02:00,300
その代わりに紫の
ブロックを保存し、私たちの代わりに

44
00:02:00,300 --> 00:02:02,940
である、のprintfました
Cでこの関数こと

45
00:02:02,940 --> 00:02:05,890
あなたが何かを印刷することができます
そして、、画面上でフォーマットします。

46
00:02:05,890 --> 00:02:07,950
私たちは、CS50を導入しました
図書館、あなた

47
00:02:07,950 --> 00:02:11,420
あなたの処分のget_charで今持っています、
そして、get_int、およびget_string、

48
00:02:11,420 --> 00:02:14,610
そして、いくつかの他の機能として、
よく、それを介してあなたが入力を取得することができます

49
00:02:14,610 --> 00:02:16,260
ユーザー自身のキーボードから。

50
00:02:16,260 --> 00:02:20,640
そして、我々はまた、物事を見ていました
these-ブール値、お​​よび文字など、

51
00:02:20,640 --> 00:02:22,490
ダブル、フロート、
int型、long_long文字列。

52
00:02:22,490 --> 00:02:25,170
そして、Cのさえ他のデータ型があります

53
00:02:25,170 --> 00:02:28,560
>> あなたが宣言し換言すれば、
いくつかの値を格納する変数、

54
00:02:28,560 --> 00:02:32,600
または、機能を実装する場合
それはいくつかの値を返し、

55
00:02:32,600 --> 00:02:35,290
あなたは何を指定することができます
ある値の型。

56
00:02:35,290 --> 00:02:37,310
それは、文字列は次のように、あります
文字のシーケンス？

57
00:02:37,310 --> 00:02:39,490
それは、整数のように、番号はありますか？

58
00:02:39,490 --> 00:02:41,390
それは浮動小数点です
値、など？

59
00:02:41,390 --> 00:02:46,180
だからCで、スクラッチとは異なり、私たちは実際に
データの種類を指定するようになりました

60
00:02:46,180 --> 00:02:48,330
我々は戻ってまたは使用していました。

61
00:02:48,330 --> 00:02:51,910
>> しかし、もちろん、我々はまた、に走りました
コンピューティングのいくつかの基本的な限界。

62
00:02:51,910 --> 00:02:54,100
特に、
この言語C、リコール

63
00:02:54,100 --> 00:02:57,070
私たちが見ていたこと
整数オーバーフロー、現実

64
00:02:57,070 --> 00:03:00,460
あなたが唯一持っている場合に
メモリの有限量

65
00:03:00,460 --> 00:03:04,600
または、具体的には、有限数
ビットで、あなただけの非常に高いカウントすることができます。

66
00:03:04,600 --> 00:03:08,460
そして、私たちはここで、この例を見て
これにより、飛行機内のカウンタ、

67
00:03:08,460 --> 00:03:13,510
実際には、十分な長さで実行されている場合、希望
ソフトウェアのオーバフローと結果

68
00:03:13,510 --> 00:03:15,560
実際の物理的な潜在的なエラー。

69
00:03:15,560 --> 00:03:18,600
>> また、フローティング見
ポイントの不正確、現実

70
00:03:18,600 --> 00:03:22,280
その唯一の有限数で
ビットの、それは32か64だかどうか、

71
00:03:22,280 --> 00:03:27,330
あなただけの非常に多くの数を指定することができます
小数点の後、これを使用した後、

72
00:03:27,330 --> 00:03:29,110
不正確な取得を開始します。

73
00:03:29,110 --> 00:03:32,360
で三分の一は、例えば、そのように
ここでは、私たち人間の世界では、世界、

74
00:03:32,360 --> 00:03:35,360
私たちは無限の数を知っています
小数点以下3秒の。

75
00:03:35,360 --> 00:03:38,820
しかし、コンピュータが必ずしもできません
数字の数が無限であることを表します

76
00:03:38,820 --> 00:03:42,590
あなたが唯一許可されている場合、それいくつかの
情報の有限量。

77
00:03:42,590 --> 00:03:45,900
>> だから私たちはあなたを装備しただけでなく、
面で大きな力を持ちます

78
00:03:45,900 --> 00:03:49,280
あなたがで自分を表現する方法の
プログラミングの観点から、キーボード、

79
00:03:49,280 --> 00:03:51,430
我々はまた、どのような制限され
あなたが実際に行うことができます。

80
00:03:51,430 --> 00:03:55,790
そして実際、バグやミスができます
問題のこれらの種類の中から生じます。

81
00:03:55,790 --> 00:03:59,900
そして実際、トピックの中で今日
デバッグのようなトピックであることを行っています

82
00:03:59,900 --> 00:04:03,699
そして実際にボンネットの下に見て
物事は先週紹介した方法で、

83
00:04:03,699 --> 00:04:05,490
実際に実装されています
あなたより良いように

84
00:04:05,490 --> 00:04:10,530
両方の機能を理解し、
C.のような言語の制限

85
00:04:10,530 --> 00:04:14,770
>> そして実際に、我々は層をバックはがします
データ構造の最も単純なの、

86
00:04:14,770 --> 00:04:17,756
配列と呼ばれるもの、その
スクラッチは、呼び出すために起こる」リストを。」

87
00:04:17,756 --> 00:04:19,589
それは少しです
そのコンテキストで異なります。

88
00:04:19,589 --> 00:04:23,340
そして、我々はまた、のいずれかを紹介します
私たちのドメイン固有の問題の最初の

89
00:04:23,340 --> 00:04:26,790
CS50、の世界では
暗号化、スクランブルの芸術

90
00:04:26,790 --> 00:04:29,650
または情報を暗号でそう
あなたは秘密のメッセージを送ることができます

91
00:04:29,650 --> 00:04:34,520
そして、秘密のメッセージを解読
二人、AとBの間

92
00:04:34,520 --> 00:04:37,490
>> そこで、遷移前
その新しい世界へ、

93
00:04:37,490 --> 00:04:42,059
それでは、いくつかであなたを装備してみましょう
あなたは排除することが可能な技術

94
00:04:42,059 --> 00:04:43,850
または少なくともいくつかを軽減
欲求不満の

95
00:04:43,850 --> 00:04:46,630
あなたはおそらく発生していること
一人で、過去一週間以上。

96
00:04:46,630 --> 00:04:50,830
実際には、あなたの前のいくつかをsuch--されています
C.そしてオッズであなたの最初の問題があり、

97
00:04:50,830 --> 00:04:54,010
あなたが私に似ている場合は、初めて
あなたがプログラムを入力しようと、

98
00:04:54,010 --> 00:04:57,330
あなたは論理的に考える場合でも、
プログラムは非常に簡単です、

99
00:04:57,330 --> 00:05:01,200
あなたは非常によく壁にぶつかる可能性があり、
コンパイラは、協力するつもりはありません。

100
00:05:01,200 --> 00:05:03,940
メイクやクランは行っていません
実際にあなたの入札を行います。

101
00:05:03,940 --> 00:05:05,450
>> そして、なぜそれがあるかもしれませんか？

102
00:05:05,450 --> 00:05:07,950
さて、見てみましょう、
おそらく、簡単なプログラム。

103
00:05:07,950 --> 00:05:11,190
私は先に行くと、これを保存するつもりです
故意にbuggy0.cと呼ばれるファイル、

104
00:05:11,190 --> 00:05:13,590
私はそれを知っているので、
事前に欠陥があります。

105
00:05:13,590 --> 00:05:17,400
しかし、私はこの場合ことを認識しない場合があります
第一又は第二又は第三のプログラムであります

106
00:05:17,400 --> 00:05:18,830
私は実際に自分自身を作ってるんだということ。

107
00:05:18,830 --> 00:05:23,820
だから私は先に行くつもりだと
、int型メイン（ボイド）を入力します。

108
00:05:23,820 --> 00:05:28,130
そして、私の中括弧の内側に、
こんにちは、world--（「非常に精通して

109
00:05:28,130 --> 00:05:30,980
バックスラッシュ、n個 "） - およびセミコロン。

110
00:05:30,980 --> 00:05:32,360
>> 私は、ファイルを保存しました。

111
00:05:32,360 --> 00:05:34,850
今、私がダウンして行くつもりです
私の端末ウィンドウに

112
00:05:34,850 --> 00:05:40,340
タイプメイクbuggy0、なぜなら、再び、
ファイルの名前、今日はbuggy0.cです。

113
00:05:40,340 --> 00:05:43,660
だから私は入力して、buggy0を作る入力します。

114
00:05:43,660 --> 00:05:48,200
>> そして、ああ、まあ、前回からリコール
エラーメッセージが表示されないことは良いことです。

115
00:05:48,200 --> 00:05:49,740
だから、何も出力は良いことではありません。

116
00:05:49,740 --> 00:05:52,920
しかし、ここで私が明確に持っています
ミスをいくつか。

117
00:05:52,920 --> 00:05:56,470
>> 出力の最初の行だから
buggy0を作る入力した後、リコール、

118
00:05:56,470 --> 00:05:59,540
クランのかなり詳細な出力です。

119
00:05:59,540 --> 00:06:02,067
ボンネットの下に、
CS50 IDEが構成されています

120
00:06:02,067 --> 00:06:04,150
の全体の束を使用するには
このコンパイラでのオプション

121
00:06:04,150 --> 00:06:05,941
あなたが持っていないように、
それらについて考えて。

122
00:06:05,941 --> 00:06:08,840
そしてそれはすべてのこと最初の行です
クランで始まる手段。

123
00:06:08,840 --> 00:06:11,720
>> しかし、その後、問題
その外観を作るために始めます。

124
00:06:11,720 --> 00:06:17,390
3行目のBuggy0.c、文字
図5は、大きな、赤いエラーがあります。

125
00:06:17,390 --> 00:06:18,380
それは何ですか？

126
00:06:18,380 --> 00:06:23,562
暗黙的にライブラリ関数を宣言
int型（のconst char型*とのprintf、

127
00:06:23,562 --> 00:06:26,050
...）[-Werror]。

128
00:06:26,050 --> 00:06:28,379
私は非常に迅速に、それを意味します
非常に難解な取得します。

129
00:06:28,379 --> 00:06:30,170
そして確かに、最初は
一見、我々はないでしょう

130
00:06:30,170 --> 00:06:32,380
あなたが理解することを期待
そのメッセージの全体。

131
00:06:32,380 --> 00:06:34,213
レッスンのだから1
今日のために起こっています

132
00:06:34,213 --> 00:06:36,919
気づくしようとすることにします
パターン、または類似のもの、

133
00:06:36,919 --> 00:06:38,960
あなたが持つかもしれないエラーに
過去に発生しました。

134
00:06:38,960 --> 00:06:41,335
これだけ離れていじめるしましょう
見覚えがそれらの言葉。

135
00:06:41,335 --> 00:06:44,290
大きな、赤いエラーが明らかに
間違っている何かの象徴。

136
00:06:44,290 --> 00:06:47,940
>> 暗黙的に宣言
ライブラリ関数のprintf。

137
00:06:47,940 --> 00:06:51,680
だから私は非常に何を理解していない場合でも、
暗黙的にライブラリ関数を宣言

138
00:06:51,680 --> 00:06:54,900
手段、きっと問題
何とかprintfのためにも関します。

139
00:06:54,900 --> 00:06:59,130
そして、その問題の原因
それを宣言するに関係しています。

140
00:06:59,130 --> 00:07:02,440
>> 関数である宣言
最初にそれを言及。

141
00:07:02,440 --> 00:07:06,210
そして、我々は先週の用語を使用しました
関数のプロトタイプを宣言する、

142
00:07:06,210 --> 00:07:11,860
いずれかの上部に1行を使用して
自分のファイルやいわゆるヘッダファイルインチ

143
00:07:11,860 --> 00:07:15,300
そして、何のファイルに私たちは言っていました
先週のprintfが引用であることを、

144
00:07:15,300 --> 00:07:17,080
引用終わり、宣言？

145
00:07:17,080 --> 00:07:20,950
どのようなファイルでは、そのプロトタイプはありますか？

146
00:07:20,950 --> 00:07:24,640
>> 私は非常に最初の事、あなたが思い出すのであれば
入力された、ほぼすべてのプログラム最後time--

147
00:07:24,640 --> 00:07:30,790
そして、誤って一瞬前に開始
myself--を入力すると、この1 here--ました

148
00:07:30,790 --> 00:07:38,630
hash--する#include <stio--用
入力/ output--ドット時間そして実際、

149
00:07:38,630 --> 00:07:41,860
私は今、このファイルを保存した場合、私は行きますよ
先に行くと私の画面をクリアするには、

150
00:07:41,860 --> 00:07:44,740
あなたは次のように入力して行うことができます
クリア、またはあなたは、コントロールLを保持することができます

151
00:07:44,740 --> 00:07:47,680
ちょうどあなたのターミナルウィンドウをクリアします
ただ、いくつかの混乱を排除します。

152
00:07:47,680 --> 00:07:51,370
>> 私は先に行くつもりだと
再タイプ入力し、buggy0を作ります。

153
00:07:51,370 --> 00:07:53,790
出来上がり、私はまだことを確認します
クランからの長いコマンド、

154
00:07:53,790 --> 00:07:55,470
しかし、エラー・メッセージは、この時間ありま​​せん。

155
00:07:55,470 --> 00:07:58,800
そして実際、私は./buggy0をすれば、
ちょうど最後の時間のように、

156
00:07:58,800 --> 00:08:01,860
ドットは、このことを意味します
ディレクトリは、スラッシュだけで、意味します

157
00:08:01,860 --> 00:08:05,040
ここでは、プログラムの名前が来て、
プログラムの名前は、buggy0です

158
00:08:05,040 --> 00:08:07,340
「こんにちは、世界。」、入力してください

159
00:08:07,340 --> 00:08:09,440
>> さて、どのようにあなたが持っているかもしれません
このソリューションを収集

160
00:08:09,440 --> 00:08:12,017
必ずしもなし
多くの単語を認識

161
00:08:12,017 --> 00:08:14,350
私がしたように、確かに、持ちます
非常に多くの年のためにこれを行って？

162
00:08:14,350 --> 00:08:18,720
さて、最初の問題ごとに実現
設定し、我々はコマンドを紹介します

163
00:08:18,720 --> 00:08:21,175
そのCS50自身のスタッフ
呼ばれるhelp50を書きました。

164
00:08:21,175 --> 00:08:24,300
そして実際、Cはの仕様を行います
問題は、これを使用する方法のように設定します。

165
00:08:24,300 --> 00:08:27,210
>> しかし、本質的help50です
プログラムCS50のスタッフ

166
00:08:27,210 --> 00:08:30,850
それはあなたが実行することができます書きました
コマンドまたはプログラムを実行し、

167
00:08:30,850 --> 00:08:36,169
あなたは理解していない場合は、その
出力は、help50に出力を渡します

168
00:08:36,169 --> 00:08:38,890
その時点でのソフトウェア
コー​​スのスタッフが書きました

169
00:08:38,890 --> 00:08:42,429
あなたのプログラムの出力を見ていきます
行単位、文字単位。

170
00:08:42,429 --> 00:08:46,000
そして、私たちは、スタッフが、認識している場合
あなたが経験しているエラーメッセージ、

171
00:08:46,000 --> 00:08:50,580
我々はいくつかであなたを挑発しようとします
いくつかのアドバイスと反語、

172
00:08:50,580 --> 00:08:54,890
TFまたはCAや私のような多くの
営業時間で一人で行うだろう。

173
00:08:54,890 --> 00:08:58,320
>> そうしないのであればhelp50に見えます
必ずしも問題を認識しています。

174
00:08:58,320 --> 00:09:00,790
しかし、それに依存しません
松葉杖としてあまり。

175
00:09:00,790 --> 00:09:03,990
確かに理解しようと、その
出力し、それから学びます

176
00:09:03,990 --> 00:09:07,571
これだけ一度か二度あなたが行うこと
これまで、特定のエラーのためにhelp50実行

177
00:09:07,571 --> 00:09:08,070
メッセージ。

178
00:09:08,070 --> 00:09:10,660
その後、あなたはする必要があります
より良い自分自身を装備

179
00:09:10,660 --> 00:09:13,180
それは実際にあるかを把握します。

180
00:09:13,180 --> 00:09:14,350
>> それでは、ここで他のいずれかの操作を実行してみましょう。

181
00:09:14,350 --> 00:09:20,410
私は先に行ってみよう、と別で
ファイル我々はこのbuggy1.cと呼ぶことにします。

182
00:09:20,410 --> 00:09:23,110
そして、このファイルには、私はよ
deliberately--に行きます

183
00:09:23,110 --> 00:09:26,330
しかし、私にはないふりをします
私が作ったものの間違いを理解しています。

184
00:09:26,330 --> 00:09:31,420
>> 私は先に行くとthis--するつもりです
#include、私がしたので

185
00:09:31,420 --> 00:09:33,660
少し前から私の教訓を学びました。

186
00:09:33,660 --> 00:09:36,220
int型メイン（ボイド）、前と同じように。

187
00:09:36,220 --> 00:09:40,880
そして、ここで私は行きますよ
get_string  - 文字列sを行います。

188
00:09:40,880 --> 00:09:43,770
そして、その最後の時間からリコール
これは、ちょっと、コンピュータを意味し、

189
00:09:43,770 --> 00:09:48,280
私に変数を与え、よそれを呼び出すと、
その変数の型文字列を作ります

190
00:09:48,280 --> 00:09:50,150
私はそれで1つまたは複数の単語を保存することができます。

191
00:09:50,150 --> 00:09:52,191
>> そして、右側の上
等号の側

192
00:09:52,191 --> 00:09:54,980
である、get_stringされます
CS50ライブラリの機能

193
00:09:54,980 --> 00:09:55,980
それはまさにそれを行います。

194
00:09:55,980 --> 00:09:59,740
これは、その関数を取得し、
右から左に手を。

195
00:09:59,740 --> 00:10:02,670
したがって、この等号は意味するものではありません
私たちは数学に思うかもしれないとして、「等しいです」。

196
00:10:02,670 --> 00:10:04,750
これは、右から左への割り当てを意味します。

197
00:10:04,750 --> 00:10:09,640
だからこの意味から、文字列を取ります
ユーザーおよびsの中に保管してください。

198
00:10:09,640 --> 00:10:10,460
>> 今度はそれを使用してみましょう。

199
00:10:10,460 --> 00:10:13,820
私は今、第二のように先に行ってみよう
ラインは、私が先に行くと、「こんにちは」と言ってみましょう - 

200
00:10:13,820 --> 00:10:19,330
ない "世界"が、 "こんにちは、％-S-
これは私たちのプレースホルダ、コンマsは、

201
00:10:19,330 --> 00:10:22,030
これは私たちの変数であり、
した後、セミコロン。

202
00:10:22,030 --> 00:10:26,070
だから私はあまり台無しにしなかった場合
ここでは、これは正しいコードのように見えます。

203
00:10:26,070 --> 00:10:28,090
>> そして、私の本能は今それをコンパイルしようとしています。

204
00:10:28,090 --> 00:10:30,400
ファイルはbuggy1.cと呼ばれています。

205
00:10:30,400 --> 00:10:33,770
だから私は、buggy1を作るのですか入力するつもりです。

206
00:10:33,770 --> 00:10:36,377
そして、くそ-それを、存在しない場合
以前よりさらに多くのエラー。

207
00:10:36,377 --> 00:10:38,210
私が意味する、より多くのがあります
エラーメッセージには、希望

208
00:10:38,210 --> 00:10:40,400
このプログラムで実際のラインよりも見えます。

209
00:10:40,400 --> 00:10:42,730
>> しかし、ここでお持ち帰りは、
あなたが圧倒している場合でも、

210
00:10:42,730 --> 00:10:45,040
2または3で
4つのエラーメッセージ

211
00:10:45,040 --> 00:10:48,340
非常に常に焦点を合わせます
これらのメッセージの最初の。

212
00:10:48,340 --> 00:10:52,220
最上位の1を見てみると、
である必要があるとして、バックアップスクロールします。

213
00:10:52,220 --> 00:10:53,930
だからここに私はメイクbuggy1を入力しました。

214
00:10:53,930 --> 00:10:55,700
ここではクラン出力が期待通りにことです。

215
00:10:55,700 --> 00:10:57,290
>> そして、ここで最初の赤色のエラーです。

216
00:10:57,290 --> 00:11:02,370
宣言されていない識別子の使用
文字列は、私は標準を意味するのですか？

217
00:11:02,370 --> 00:11:04,260
だから、標準では、
実際に何か他のもの。

218
00:11:04,260 --> 00:11:06,240
これは、ユーザを指し
キーボード、本質的に。

219
00:11:06,240 --> 00:11:08,080
>> しかし、それは何を意味しません。

220
00:11:08,080 --> 00:11:11,770
私は文字列を意味し、私はget_stringを意味していました。

221
00:11:11,770 --> 00:11:16,200
だから、私こと何です
この時間を行うのを忘れましたか？

222
00:11:16,200 --> 00:11:20,230
何がこの時間を欠けていますか？

223
00:11:20,230 --> 00:11:23,600
私は自分の#includeを持っています、
私はprintfのへのアクセス権を持っています。

224
00:11:23,600 --> 00:11:26,090
>> しかし、私は何を持っていません
まだへのアクセス？

225
00:11:26,090 --> 00:11:29,420
まあ、ちょうど最後の時間のように、
私は、コンパイラに指示する必要があり

226
00:11:29,420 --> 00:11:31,691
これらの機能が何であるかを打ち鳴らします。

227
00:11:31,691 --> 00:11:33,940
Get_stringは付属していません。
C.と、特に、それを

228
00:11:33,940 --> 00:11:38,160
に付属していません。
、ヘッダ・ファイル。

229
00:11:38,160 --> 00:11:40,770
それは、代わりに来ます
スタッフが書いたもの、

230
00:11:40,770 --> 00:11:44,176
これは異なるファイルであります
名前ではなく、適切な名前。

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> だから、単純に1行を追加して
前回からcode--リコール

233
00:11:50,861 --> 00:11:53,610
クランの実行時に、それが起こっていること
下に私のコードの上部を見て、

234
00:11:53,610 --> 00:11:54,193
左から右へ。

235
00:11:54,193 --> 00:11:57,200
気づくことだろう
ああ、あなたがしたいです。

236
00:11:57,200 --> 00:11:59,900
私が行くとそれを見つけてみましょう、
どこそれがサーバー上にあります、

237
00:11:59,900 --> 00:12:03,090
基本的に、コピーして貼り付け、
独自のファイルの先頭に

238
00:12:03,090 --> 00:12:06,820
その結果、物語の中で、この時点では、
ライン1、プログラムの残りの部分

239
00:12:06,820 --> 00:12:11,651
、確かに、関数のいずれかを使用することができます
その中で、それらの間get_string。

240
00:12:11,651 --> 00:12:13,650
だから私は無視するつもりです
これらのエラーの残りの部分、

241
00:12:13,650 --> 00:12:17,190
私は、確かに、それだけで疑われる理由
最初のものは、実際に大事。

242
00:12:17,190 --> 00:12:20,780
そして、私は先に行くと、再実行するつもりです、
私のファイルを保存した後buggy1を作ります。

243
00:12:20,780 --> 00:12:22,580
出来上がり、それは仕事をしてくれました。

244
00:12:22,580 --> 00:12:29,200
そして、私は./buggy1を行うと、ために、入力した場合
インスタンスは、Zamylaは、私は今、こんにちは取得します

245
00:12:29,200 --> 00:12:32,000
Zamyla、代わりのこんにちは、世界。

246
00:12:32,000 --> 00:12:32,550
>> 大丈夫。

247
00:12:32,550 --> 00:12:35,890
だからここに持ち帰り、その後にされ、
1、あなたはできる限りを収集してみてください

248
00:12:35,890 --> 00:12:39,140
単独でのエラーメッセージから、見て
認識可能な単語の一部で。

249
00:12:39,140 --> 00:12:43,070
あたりをhelp50使用することを除けば
問題は、仕様を設定します。

250
00:12:43,070 --> 00:12:46,500
しかし、あまりにも、常に見て、ことを除けば
トップエラー時のみ、少なくとも

251
00:12:46,500 --> 00:12:50,051
最初に、どのような情報を表示するには
それが実際に得られるかもしれません。

252
00:12:50,051 --> 00:12:52,300
しかし、それはそこのが判明します
さらに多くの機能が組み込まれて

253
00:12:52,300 --> 00:12:55,030
CS50ライブラリに支援します
学期中の早い段階であなた

254
00:12:55,030 --> 00:12:57,580
早期でのプログラミングで
間違って何が起こっているのかを把握します。

255
00:12:57,580 --> 00:12:59,840
それでは、ここでは別の例を実行してみましょう。

256
00:12:59,840 --> 00:13:04,350
私は、このbuggy2を呼ぶつもりです、
再び、アウト欠陥があるとしています

257
00:13:04,350 --> 00:13:05,650
設計により、ゲートの。

258
00:13:05,650 --> 00:13:09,980
>> そして、私は先に行くつもりです
そして、の#includeを行います。

259
00:13:09,980 --> 00:13:12,580
そして私はint型メイン（ボイド）をするつもりです。

260
00:13:12,580 --> 00:13:14,840
そして私は、forループをするつもりです。

261
00:13:14,840 --> 00:13:16,690
（iは0 _ int型のため。

262
00:13:16,690 --> 00:13:18,750
iが10以下です。

263
00:13:18,750 --> 00:13:24,260
私は++、その後、中括弧で、私が行きますよ
ここだけのハッシュタグのシンボルをプリントアウトします

264
00:13:24,260 --> 00:13:25,920
そして、改行文字。

265
00:13:25,920 --> 00:13:29,220
>> これにだから私の意図
プログラムは非常に単純です

266
00:13:29,220 --> 00:13:33,150
10回反復します
各繰り返しで

267
00:13:33,150 --> 00:13:35,260
そのループ毎回の
サイクルを通じて、

268
00:13:35,260 --> 00:13:37,660
ハッシュタグをプリントアウトし、
ハッシュタグ、ハッシュタグ。

269
00:13:37,660 --> 00:13:40,480
1行に1つのI理由
そこに新しい行を持っています。

270
00:13:40,480 --> 00:13:42,787
そして、するためのことを思い出してください
最後week--あたりのループ、

271
00:13:42,787 --> 00:13:44,620
あなたはより多くを得るでしょう
構文に精通しています

272
00:13:44,620 --> 00:13:47,170
練習でそれを使用して、
long--これは私を与える前に、

273
00:13:47,170 --> 00:13:49,740
変数iと呼ばれ、0に設定します。

274
00:13:49,740 --> 00:13:52,650
>> これは私の上のインクリメント
1によって反復ごと。

275
00:13:52,650 --> 00:13:54,940
だから私は2〜3に1になります。

276
00:13:54,940 --> 00:13:57,690
そして、この状態で
セミコロンの間の中間

277
00:13:57,690 --> 00:14:03,010
作るために反復ごとにチェックします
我々は範囲内であることを確認してください。

278
00:14:03,010 --> 00:14:06,830
だから私は10回を反復処理したいので、私
ちょうど種類の非常に直感的に持っています

279
00:14:06,830 --> 00:14:09,070
そこに私の上限として10を置きます。

280
00:14:09,070 --> 00:14:14,310
>> そして、まだ、私はこれを実行すると、後
メイクでそれをコンパイルしbuggy2--

281
00:14:14,310 --> 00:14:15,440
そして、それはOKコンパイルありません。

282
00:14:15,440 --> 00:14:17,980
だから私は持っていません
構文エラーこの時間。

283
00:14:17,980 --> 00:14:20,940
私は今、先に行ってみましょう
そして、入力し、buggy2を実行します。

284
00:14:20,940 --> 00:14:22,620
そして今までスクロールします。

285
00:14:22,620 --> 00:14:24,890
そして、私は増加してみましょう
ウィンドウのサイズ。

286
00:14:24,890 --> 00:14:33,720
>> I 1、2、3を持っているように見えます、
4、5、6、7、8、9、10、11。

287
00:14:33,720 --> 00:14:38,891
だからにもかかわらず、11ハッシュタグをあります
私は明らかにこのループの内側に10を置きます。

288
00:14:38,891 --> 00:14:42,140
今、あなたのいくつかは、すぐに表示される場合があります
エラーは、実際に、これはどのような

289
00:14:42,140 --> 00:14:43,720
作るために非常にハードエラーではありません。

290
00:14:43,720 --> 00:14:46,070
しかし、それは非常に一般的です
非常に早い段階で作られました。

291
00:14:46,070 --> 00:14:49,820
>> 私が指摘したい、しかし、
私はこれを理解する方法、ありますか？

292
00:14:49,820 --> 00:14:52,300
まあ、それはことが判明します
CS50ライブラリが付属してい

293
00:14:52,300 --> 00:14:55,380
get_stringとget_intないだけで
get_floatおよびその他の機能と。

294
00:14:55,380 --> 00:14:59,980
また、特別な機能が付属しています
呼ばれるeprintf、または、エラーのprintf。

295
00:14:59,980 --> 00:15:03,270
そして、それは作るためだけに存在しています
それあなたのために少し簡単に

296
00:15:03,270 --> 00:15:06,310
ちょうどにあなたのコードをデバッグするとき
画面にエラーメッセージを出力

297
00:15:06,310 --> 00:15:07,850
それがどこから来たと知っています。

298
00:15:07,850 --> 00:15:11,000
>> だから例えば、一つのことは私がかもしれません
この関数はthis--であるとここで行います

299
00:15:11,000 --> 00:15:20,230
eprintf、その後、私は先に行くつもりです
そしてiは、バックスラッシュ、nは今％であると言います。

300
00:15:20,230 --> 00:15:22,330
そして、私はiの値をプラグインするつもりです。

301
00:15:22,330 --> 00:15:25,400
そして、トップアップ、このため、
CS50ライブラリであり、

302
00:15:25,400 --> 00:15:27,580
私は先に行くつもりです
とが含ま

303
00:15:27,580 --> 00:15:29,169
私は、この機能にアクセスすることができます。

304
00:15:29,169 --> 00:15:31,460
しかし、それでは、どのような行を検討してみましょう
9がやっていることになっています。

305
00:15:31,460 --> 00:15:32,670
私は最終的にこれを削除するつもりです。

306
00:15:32,670 --> 00:15:34,670
これは何の関係もありません
私の包括的な目標を持ちます。

307
00:15:34,670 --> 00:15:39,090
しかしeprintf、エラーのprintfは、単に意味します
私にいくつかの診断情報を得ることができます。

308
00:15:39,090 --> 00:15:42,460
私は私のプログラムを実行すると、私がしたいです
一時的に画面上でこれを参照してください。

309
00:15:42,460 --> 00:15:44,550
同様に、単に理解します
どうしたの。

310
00:15:44,550 --> 00:15:47,330
>> そして、確かに、上の各
ここでは9行目の反復

311
00:15:47,330 --> 00:15:49,260
私が見たいと思って、iの値は何ですか？

312
00:15:49,260 --> 00:15:50,290
iの値は何ですか？

313
00:15:50,290 --> 00:15:51,280
iの値は何ですか？

314
00:15:51,280 --> 00:15:55,650
そして、うまくいけば、私はすべき
そのメッセージ、また、10回を参照してください。

315
00:15:55,650 --> 00:15:57,780
>> だから私は先に行くとしましょう
私のプログラムを再コンパイルし、

316
00:15:57,780 --> 00:15:59,905
私はいつでもしなければならないとして、
私は変更を行います。 ./buggy2。

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
そしてnow-- OK。

319
00:16:03,640 --> 00:16:04,820
より起こっがたくさんあり​​ます。

320
00:16:04,820 --> 00:16:07,610
だから、私が上にスクロールさせます
さらに大きな窓。

321
00:16:07,610 --> 00:16:10,190
>> そして、あなたは、そのそれぞれが表示されます
ハッシュタグはまだ印刷されています。

322
00:16:10,190 --> 00:16:15,270
しかし、それらのそれぞれの間で今、このです
次のように診断出力がフォーマットされています。

323
00:16:15,270 --> 00:16:17,960
ここに私のプログラムの名前はbuggy2です。

324
00:16:17,960 --> 00:16:20,432
ファイルの名前はbuggy2.cです。

325
00:16:20,432 --> 00:16:24,080
そこから行番号
これは、9行目で印刷しました。

326
00:16:24,080 --> 00:16:27,500
そして、その右にあります
私は期待していたエラーメッセージ。

327
00:16:27,500 --> 00:16:30,701
>> そして、何これについての素晴らしいのは、ということです
今私は必ずしもカウントする必要はありません

328
00:16:30,701 --> 00:16:32,200
私の頭の中で私のプログラムは何をやっています。

329
00:16:32,200 --> 00:16:34,240
私が上でそれを見ることができます
最初の反復は、iが0です、

330
00:16:34,240 --> 00:16:39,420
その後1、次に2、その後3、その後4、その後、
5、その後6、その後7、その後8、その後9、その後、

331
00:16:39,420 --> 00:16:40,980
10。

332
00:16:40,980 --> 00:16:42,050
だから、ちょっと待って。

333
00:16:42,050 --> 00:16:43,740
何が起きてる？

334
00:16:43,740 --> 00:16:48,190
私はまだカウントしているように見えます
10までの意図したとおり。

335
00:16:48,190 --> 00:16:50,550
>> しかし、ここで私が始めたのですか？

336
00:16:50,550 --> 00:16:53,240
0、1、2、3、4、5、6、7、8、9 10。

337
00:16:53,240 --> 00:16:58,040
そう0、1、2、3、4、5、6、7、
8、9、10--第11回指

338
00:16:58,040 --> 00:16:59,990
問題を示しています。

339
00:16:59,990 --> 00:17:02,850
私が数えているように見えます
間違って私のループインチ

340
00:17:02,850 --> 00:17:06,599
10回の反復を行くのではなく、
私は、0から始まりますよ

341
00:17:06,599 --> 00:17:09,550
私は時と10を介して終了しています。

342
00:17:09,550 --> 00:17:12,030
しかしため、コンピュータのような、
私は、0でカウントを始めています

343
00:17:12,030 --> 00:17:15,250
私がカウントアップされるべきです
のではなく、10を介して。

344
00:17:15,250 --> 00:17:18,510
>> そしてそのように修正、私は最終的に
ここで実現し、2つのいずれかです。

345
00:17:18,510 --> 00:17:22,430
私は非常に簡単に言うことができます
10未満までカウント。

346
00:17:22,430 --> 00:17:27,260
そう0、1、2、3、4、5、6、7、8、
、確かに、正しい9、

347
00:17:27,260 --> 00:17:28,900
それは少し間違って聞こえるにもかかわらず。

348
00:17:28,900 --> 00:17:35,070
または私は以下を行うことができます
9に、あまりにも長い間、私は0から始まりとして。

349
00:17:35,070 --> 00:17:40,056
それとも、本当にそれを好きではない場合は、あなたを
10を介してカウントアップが、1で開始することができます。

350
00:17:40,056 --> 00:17:41,680
しかし、再び、これだけでは一般的ではありません。

351
00:17:41,680 --> 00:17:43,977
programming--ではあるが
Scratch--であまりありません

352
00:17:43,977 --> 00:17:45,810
しかし、プログラミングの中で
Cと他の言語、

353
00:17:45,810 --> 00:17:47,670
JavaScriptと同様の
Pythonと他の人、それはです

354
00:17:47,670 --> 00:17:49,880
以下のためだけの非常に一般的な
バイナリの議論

355
00:17:49,880 --> 00:17:53,450
ただでカウントを開始します
0であることができます最も低い番号、。

356
00:17:53,450 --> 00:17:53,950
大丈夫。

357
00:17:53,950 --> 00:17:55,160
だから、eprintfです。

358
00:17:55,160 --> 00:17:58,600
そして再び、今、私は私を考え出したこと
問題は、私は0に戻って行くつもりです

359
00:17:58,600 --> 00:18:01,470
10未満を通じて、私は行きますよ
行くとeprintfを削除します。

360
00:18:01,470 --> 00:18:04,580
>> とき、私にはあってはなりません
私のコードを出荷するか、私のコードを提出

361
00:18:04,580 --> 00:18:05,800
または他の誰に見せます。

362
00:18:05,800 --> 00:18:07,980
それは本当にただ意味しています
一時的に使用されます。

363
00:18:07,980 --> 00:18:11,650
しかし、今私はこれを修正しました
同様に特定の問題。

364
00:18:11,650 --> 00:18:16,780
>> さて、ここでもう一つの例をやらせます
私は次のようにかき立てるするつもりだということ。

365
00:18:16,780 --> 00:18:22,850
私は先に行くつもりだと
#include。 $ 50

366
00:18:22,850 --> 00:18:25,580
そして、私は先に行くつもりです
そして、の#include。

367
00:18:25,580 --> 00:18:29,030
>> そして、私は保存するつもりです
buggy3.cとしてこのファイル。

368
00:18:29,030 --> 00:18:31,740
そして、私は先に行くつもりです
そして、int型メイン（ボイド）を宣言。

369
00:18:31,740 --> 00:18:34,186
そして、そこの内側
私は私_ intをするつもりです - 

370
00:18:34,186 --> 00:18:36,435
私はプログラムを実装したいです
get_negative_intと。

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
これはまだ存在して関数ではありません。

373
00:18:40,770 --> 00:18:42,870
だから我々は、実装するつもりです
それだけで一瞬インチ

374
00:18:42,870 --> 00:18:45,541
しかし、我々は理由を確認するつもりです
それは最初のパスでバギーです。

375
00:18:45,541 --> 00:18:47,290
そして、私は得ている一度
ユーザーからint型、

376
00:18:47,290 --> 00:18:53,365
私はちょうど私が否定的である％を印刷するつもりです
整数、バックスラッシュ、nは、カンマ、私。

377
00:18:53,365 --> 00:18:55,240
換言すれば、全てのI
このプログラムはやってみたいです

378
00:18:55,240 --> 00:18:58,000
からの負のintを取得され、
ユーザーは、その後、プリントアウト

379
00:18:58,000 --> 00:18:59,980
そのような、そのような負のintです。

380
00:18:59,980 --> 00:19:02,080
>> 今、私はこの機能を実装する必要があります。

381
00:19:02,080 --> 00:19:05,740
だから、後で私のファイルで、私は行くつもりです
先にと呼ばれる関数を宣言

382
00:19:05,740 --> 00:19:10,670
get_negative_int（ボイド） - そして我々ます
その行が再び何を意味するのかに戻ってきます

383
00:19:10,670 --> 00:19:18,790
moment-- int型ではn; do-- DO
following--のprintf nは：です。

384
00:19:18,790 --> 00:19:26,210
そして私は、nをするつもりです -  get_intを、
この一方、nが0よりも大きいですか。

385
00:19:26,210 --> 00:19:28,310
そしてnは返す;.

386
00:19:28,310 --> 00:19:31,730
>> だからで起こっている多くがあります
これが、私たちはしなかったそのうちのどれも

387
00:19:31,730 --> 00:19:33,710
少なくとも簡単に、先週見てください。

388
00:19:33,710 --> 00:19:36,980
そこでここでは10行目に、私は宣言しました
get_negative_int呼び出された関数、

389
00:19:36,980 --> 00:19:39,620
そして、私はで、（ボイド）を入れています
括弧、その理由は、このされます

390
00:19:39,620 --> 00:19:40,950
入力を取ることはありません。

391
00:19:40,950 --> 00:19:42,910
私は何を渡していませんよ
この関数へ。

392
00:19:42,910 --> 00:19:44,690
私はちょうど戻って、そこから何かを取得しています。

393
00:19:44,690 --> 00:19:47,270
>> そして、私はに何を望んでいます
取り戻すの整数です。

394
00:19:47,270 --> 00:19:50,040
にデータ型が存在しません
Cはnegative_intと呼ばれます。

395
00:19:50,040 --> 00:19:52,880
それはちょうどint型ですので、それは起こっています
私たちの上にあることを確認します

396
00:19:52,880 --> 00:19:55,340
その実際の価値
返されるだけint型ではありません

397
00:19:55,340 --> 00:19:56,380
負です。

398
00:19:56,380 --> 00:20:02,150
>> 12行目では、私は変数を宣言しています
nおよびint型のそれを作ると呼ばれます。

399
00:20:02,150 --> 00:20:07,500
そして、18を通る線13で私はよ
何かが真である間、何かをやって。

400
00:20:07,500 --> 00:20:11,040
私は先に、印刷つもりです
nは、コロン、次にスペース、

401
00:20:11,040 --> 00:20:12,800
ユーザのプロンプトのような。

402
00:20:12,800 --> 00:20:16,410
>> 私は、get_intを呼んだし、
そのいわゆる戻り値を格納します

403
00:20:16,410 --> 00:20:18,130
その変数nインチ

404
00:20:18,130 --> 00:20:22,600
しかし、私はやり続けるつもりです
この一方、nは0より大きい。

405
00:20:22,600 --> 00:20:27,960
言い換えれば、ユーザが私与える場合
INTとその数は、0より大きい

406
00:20:27,960 --> 00:20:31,180
エルゴは、肯定的な、私はするつもりです
ただユーザーをreprompting保ちます、

407
00:20:31,180 --> 00:20:37,160
それらを強制することにより、repromptingを保ちます
協力してくれ負のintを与えます。

408
00:20:37,160 --> 00:20:41,640
>> そして、一度nは実際にnegative--
、最終的にはタイプ-50ユーザーを想定

409
00:20:41,640 --> 00:20:46,710
このwhileループはもはや真実ではありません
-50が0より大きくないからです。

410
00:20:46,710 --> 00:20:51,140
だから我々はそれから抜け出します
ループは、論理的かつn返します。

411
00:20:51,140 --> 00:20:53,520
>> しかし、他の1があります
事は私がしなければなりません。

412
00:20:53,520 --> 00:20:56,190
そして、私は単純にこれを行うことができます
コピーと貼り付けによって、

413
00:20:56,190 --> 00:20:58,540
ファイルの先頭に1行のコード。

414
00:20:58,540 --> 00:21:01,630
私は、クランを教える必要があります
または、打ち鳴らすことを約束

415
00:21:01,630 --> 00:21:04,630
明示的に私がすること、
確かに、行くと実装

416
00:21:04,630 --> 00:21:06,020
この関数get_negative_int。

417
00:21:06,020 --> 00:21:07,674
それはちょうどファイルに低くなる可能性があります。

418
00:21:07,674 --> 00:21:09,840
ここでも、そのクランを思い出します
上から下に物事を読み込み、

419
00:21:09,840 --> 00:21:12,330
左から右へ、そうあなたがすることはできません
クラン場合、関数を呼び出します

420
00:21:12,330 --> 00:21:15,330
存在することが起こっているのを知りません。

421
00:21:15,330 --> 00:21:18,430
>> さて、残念ながら、このプログラム、
あなたのいくつかは気づいたかもしれませんとして、

422
00:21:18,430 --> 00:21:19,590
すでにバグがあります。

423
00:21:19,590 --> 00:21:21,400
私が先に行くとbuggy3を作ってみましょう。

424
00:21:21,400 --> 00:21:26,904
私の問題は今ではないので、それは、コンパイル
構文エラー、テキスト形式のエラーのような、

425
00:21:26,904 --> 00:21:29,570
実際には論理的なことになるだろう
私は意図的にしましたエラー

426
00:21:29,570 --> 00:21:32,450
への機会として作られました
何が起こっているのかをステップ。

427
00:21:32,450 --> 00:21:35,540
>> 私は先に行くつもりです
今とbuggy3を実行します。

428
00:21:35,540 --> 00:21:37,490
そして、私は行くつもりです
先にではなく、協力しています。

429
00:21:37,490 --> 00:21:39,494
私はそれを数1を与えるつもりです。

430
00:21:39,494 --> 00:21:41,410
それはそう、それを好きではなかったです
それが再び私を促すです。

431
00:21:41,410 --> 00:21:42,147
>> どのように約2？

432
00:21:42,147 --> 00:21:43,021
3？

433
00:21:43,021 --> 00:21:43,520
50？

434
00:21:43,520 --> 00:21:44,740
それらのどれも機能していません。

435
00:21:44,740 --> 00:21:46,890
どのように約-50？

436
00:21:46,890 --> 00:21:48,560
そして、プログラムが動作するようです。

437
00:21:48,560 --> 00:21:49,970
>> 私はもう一度それを試してみましょう。

438
00:21:49,970 --> 00:21:53,400
私は-1を試してみましょう、動作するように思われます。

439
00:21:53,400 --> 00:21:56,380
私は-2を試してみましょう、動作するように思われます。

440
00:21:56,380 --> 00:21:59,640
私は0を試してみましょう。

441
00:21:59,640 --> 00:22:01,684
ハァッ、それは正しくないのです。

442
00:22:01,684 --> 00:22:03,350
今、私たちはここで少し知識をひけらかすされています。

443
00:22:03,350 --> 00:22:07,090
しかし、それは、確かに、0の場合です
正でも負でもありません。

444
00:22:07,090 --> 00:22:11,150
それで、私のプログラムは、事実であること
0が負の整数であることを言って、

445
00:22:11,150 --> 00:22:12,820
それは技術的に正しくないです。

446
00:22:12,820 --> 00:22:15,180
>> 今、なぜそれがこれをやっているのですか？

447
00:22:15,180 --> 00:22:16,270
まあ、それは明白であるかもしれません。

448
00:22:16,270 --> 00:22:18,110
そして、確かに、プログラムがあります
かなり単純であることを意味し

449
00:22:18,110 --> 00:22:19,670
私たちは探検するために何かを持っています。

450
00:22:19,670 --> 00:22:25,870
>> しかし、それでは、第三のデバッグを紹介しましょう
ここdebug50と呼ばれる技術。

451
00:22:25,870 --> 00:22:27,750
だから、これはプログラムであり、
私達はちょうど作成したことを

452
00:22:27,750 --> 00:22:30,770
今年呼ばdebug50
それはあなたをできるようになります

453
00:22:30,770 --> 00:22:34,130
ビルトインと呼ばれるものを使用します
CS50 IDEでグラフィカルなデバッガ。

454
00:22:34,130 --> 00:22:38,400
そして、デバッガはそのちょうどプログラムです
一般的に、あなたのプログラムを実行することができます

455
00:22:38,400 --> 00:22:44,050
しかし、ステップ、ラインバイステップバイステップ
行単位により、突っつい、一時停止

456
00:22:44,050 --> 00:22:47,626
周りに、変数を見ているので、
プログラムはあなたを越えて吹きません

457
00:22:47,626 --> 00:22:49,750
かつ迅速に何かを印刷
か何かを印刷しません。

458
00:22:49,750 --> 00:22:53,250
それはで、あなたにチャンスを与えます
人間の速度は、それと相互作用します。

459
00:22:53,250 --> 00:22:55,470
>> そして、これを行うには、
単純に次の操作を行います。

460
00:22:55,470 --> 00:22:58,479
あなたのコードをコンパイルした後、
これは私はすでにやった、buggy3、

461
00:22:58,479 --> 00:23:00,020
あなたが先に行くとdebug50 ./buggyを実行します。

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
help50のようなので、多くのあなたが実行されました
help50してから、コマンド、

464
00:23:06,760 --> 00:23:10,120
debug50あなたはdebug50を実行しており、
その後、コマンドの名前。

465
00:23:10,120 --> 00:23:14,440
>> 今私の画面上に何が起こるか見て、
特に右側の。

466
00:23:14,440 --> 00:23:19,400
私は、すべてを実行]を押すと
突然この右側のパネル

467
00:23:19,400 --> 00:23:20,419
画面上に表示されます。

468
00:23:20,419 --> 00:23:22,210
そして、行くたくさんあり​​ます
一見に。

469
00:23:22,210 --> 00:23:25,110
しかし、あまりにもそこにはありません
まだ心配するくらい。

470
00:23:25,110 --> 00:23:28,570
>> これは私にすべてを見せています
それは私のプログラムの内部で起こっています

471
00:23:28,570 --> 00:23:31,130
今、これらを介して、
トップアップボタンはその後です

472
00:23:31,130 --> 00:23:35,910
私は私のコードをステップ実行することを可能にします
最終的にステップバイステップバイステップ。

473
00:23:35,910 --> 00:23:37,140
それだけではない、まだ。

474
00:23:37,140 --> 00:23:38,060
何が起こるかに注目してください。

475
00:23:38,060 --> 00:23:40,600
私の端末ウィンドウで、
私はn個の入力を求められています。

476
00:23:40,600 --> 00:23:44,560
そして、私は先に行くつもりだし、
-1にこの時間と種類を協力しています。

477
00:23:44,560 --> 00:23:48,770
そして、はいえ少しひそかに、-1
予想されるように、負の整数です。

478
00:23:48,770 --> 00:23:52,020
>> そして、子供はで終了しました
出ステータス0 GDBSERVER。

479
00:23:52,020 --> 00:23:55,180
GDB、GNUデバッガは、名前です。
基盤となるソフトウェアの

480
00:23:55,180 --> 00:23:56,620
それは、このデバッガを実装しています。

481
00:23:56,620 --> 00:24:00,500
しかし、すべてこれは本当に、デバッガを意味します
私のプログラムが終了したために去っていきました

482
00:24:00,500 --> 00:24:01,710
そしてすべてが順調でした。

483
00:24:01,710 --> 00:24:06,020
私は本当に私のプログラムをデバッグしたい場合は、
私は先制debug50を伝える必要があり、

484
00:24:06,020 --> 00:24:08,920
ここで私は開始したいです
私のコードをステップ？

485
00:24:08,920 --> 00:24:11,750
>> そしておそらく最も簡単な方法
次のようにそれを行うことです。

486
00:24:11,750 --> 00:24:15,300
私は上にカーソルを移動した場合
ここに私のエディタのガター、

487
00:24:15,300 --> 00:24:19,090
だから本当にちょうどここのサイドバーで、
行番号の左に、

488
00:24:19,090 --> 00:24:21,870
私はちょうどクリックするとことがわかり
かつて、私は少し赤い点を置きます。

489
00:24:21,870 --> 00:24:24,460
そして、その小さな赤い点、
一時停止の標識のような、ちょっと、意味、

490
00:24:24,460 --> 00:24:29,430
debug50、私のコードの一時停止の実行
右が、私はこのプログラムを実行するとき。

491
00:24:29,430 --> 00:24:30,260
>> それでは、それをやらせます。

492
00:24:30,260 --> 00:24:37,340
私が先に行くと私のプログラムを実行してみましょう
再びdebug50 ./buggy3と、入力してください。

493
00:24:37,340 --> 00:24:40,110
そして今、何かに気付きます
異なるが起こっています。

494
00:24:40,110 --> 00:24:42,440
私は、プロンプトが表示されていませんよ
まだ私の端末ウィンドウで

495
00:24:42,440 --> 00:24:45,430
何のために、ので、私はそうではありません
私のプログラムではまだ頂いております。

496
00:24:45,430 --> 00:24:47,950
8行目のことに注意してください
今強調表示され、

497
00:24:47,950 --> 00:24:51,720
そして、で小さな矢印があります
左のことわざは、あなたはここで一時停止されています。

498
00:24:51,720 --> 00:24:55,030
このコード行、行
8は、まだ実行されていません。

499
00:24:55,030 --> 00:24:58,940
>> 私が見た場合と、好奇心が強いものです
右側にこっち、

500
00:24:58,940 --> 00:25:03,530
私はローカルであることに気付きます
意味でのローカル変数、

501
00:25:03,530 --> 00:25:05,450
ことは、現在の関数内です。

502
00:25:05,450 --> 00:25:08,920
その値、どうやらデフォルトでは、
ソートの便利な、0です。

503
00:25:08,920 --> 00:25:10,260
しかし、私は0を入力しませんでした。

504
00:25:10,260 --> 00:25:13,410
それはちょうど、そのことを起こります
現時点ではデフォルト値。

505
00:25:13,410 --> 00:25:15,490
>> だから私は先に行くと、今これを実行しましょう​​。

506
00:25:15,490 --> 00:25:18,680
私は先にと上に行こう
右ここでトップ、私はよ

507
00:25:18,680 --> 00:25:20,970
先に行くつもりと
この最初のアイコンをクリックします

508
00:25:20,970 --> 00:25:25,360
以上のステップは省略しない手段
それが、このコード行をステップオーバー、

509
00:25:25,360 --> 00:25:27,770
道に沿って、それを実行します。

510
00:25:27,770 --> 00:25:30,710
>> そして今、私の、気付きます
プロンプトがちょうど変更されました。

511
00:25:30,710 --> 00:25:31,380
何故ですか？

512
00:25:31,380 --> 00:25:33,639
私はdebug50を言いました、
このコード行を実行します。

513
00:25:33,639 --> 00:25:34,930
このコード行は何をするのでしょうか？

514
00:25:34,930 --> 00:25:35,960
int型のために私を求められます。

515
00:25:35,960 --> 00:25:36,460
OK。

516
00:25:36,460 --> 00:25:37,400
私は協力しましょう​​。

517
00:25:37,400 --> 00:25:41,340
私は今、先に行くと、-1を入力し、入力してみましょう。

518
00:25:41,340 --> 00:25:42,920
そして今、何が変更されたかがわかります。

519
00:25:42,920 --> 00:25:46,060
右側に、
私の地元の変数i

520
00:25:46,060 --> 00:25:48,200
ある-1今として示されています。

521
00:25:48,200 --> 00:25:49,810
そして、それはint型はまだです。

522
00:25:49,810 --> 00:25:53,102
>> そして通知は、あまりにも、私のいわゆる
私は一時停止しなかったコールスタック、？

523
00:25:53,102 --> 00:25:54,810
私たちはについての詳細を説明します
将来的にこの。

524
00:25:54,810 --> 00:25:58,620
しかし、コールスタックは、単に何を指し
機能は、運動に現在あります。

525
00:25:58,620 --> 00:26:00,040
今それはちょうどメインです。

526
00:26:00,040 --> 00:26:03,590
そして今だけのローカル
変数が1の値を持つ私です。

527
00:26:03,590 --> 00:26:09,840
>> そして、私は最終的にこの行をステップオーバー時
ここでは、右上の同じアイコンで、

528
00:26:09,840 --> 00:26:11,410
-1負の整数です。

529
00:26:11,410 --> 00:26:13,580
今では、その中括弧の上に一時停止しています。

530
00:26:13,580 --> 00:26:14,740
のは、そのことをやらせるましょう。

531
00:26:14,740 --> 00:26:17,300
私は、その行をステップオーバー、出来上がり。

532
00:26:17,300 --> 00:26:20,240
>> そうではないすべてのことひどく
、啓発まだ

533
00:26:20,240 --> 00:26:23,550
しかし、それは私が一時停止させました
そして論理的に考え抜きます

534
00:26:23,550 --> 00:26:24,870
このプログラムは何をやっています。

535
00:26:24,870 --> 00:26:26,890
しかし、それは誤ったケースはなかったです。

536
00:26:26,890 --> 00:26:28,510
次のようにのは、再びこれをやってみましょう。

537
00:26:28,510 --> 00:26:31,340
>> 私はそのブレークポイントを残すつもりです
赤い点と8行目。

538
00:26:31,340 --> 00:26:32,830
私はdebug50を再実行するつもりです。

539
00:26:32,830 --> 00:26:34,400
それは自動的にここに一時停止しています。

540
00:26:34,400 --> 00:26:37,660
しかし、この時、代わりに
この行をステップオーバー、

541
00:26:37,660 --> 00:26:42,290
私は実際の内側に行こう
get_negative_intと把握、

542
00:26:42,290 --> 00:26:45,530
なぜそれが有効な回答として0を受け付けていますか？

543
00:26:45,530 --> 00:26:47,990
>> だから、代わりにステップオーバーをクリックします。

544
00:26:47,990 --> 00:26:50,630
私は先に行くつもりです
そしてステップイン]をクリックします。

545
00:26:50,630 --> 00:26:54,030
そして、8行目だということに気づきます
今突然今強調表示

546
00:26:54,030 --> 00:26:56,900
17行になります。

547
00:26:56,900 --> 00:26:59,947
>> 今、それはデバッガことはありません
ライン14,15および16をスキップしています。

548
00:26:59,947 --> 00:27:01,780
それだけでは何もありませんです
そこにあなたが表示されます。

549
00:27:01,780 --> 00:27:04,050
それらは単に変数を宣言しています、
そして、その単語があるんです

550
00:27:04,050 --> 00:27:05,390
そしてその後、左中括弧。

551
00:27:05,390 --> 00:27:09,227
唯一の機能ライン
ジューシーは本当にここにこの1、17です。

552
00:27:09,227 --> 00:27:11,060
そして、私たちがきた場所なのです
自動的に一時停止。

553
00:27:11,060 --> 00:27:13,870
>> だからのprintf（ "n.is："）;,そう
それはまだ起きていません。

554
00:27:13,870 --> 00:27:18,250
それでは、先に行くとステップオーバー]をクリックしてみましょう。

555
00:27:18,250 --> 00:27:20,326
今私のプロンプト、確かに、
（ "nは次のとおりです。"）に変更。

556
00:27:20,326 --> 00:27:22,450
今、私はつもりはない、get_int
足を踏み入れる邪魔して、

557
00:27:22,450 --> 00:27:24,750
その関数があったので、
図書館にCS50によって行われました。

558
00:27:24,750 --> 00:27:25,750
それはおそらく正しいです。

559
00:27:25,750 --> 00:27:28,440
>> だから私は先に行くつもりだと
ソートのそれを与えることで協力

560
00:27:28,440 --> 00:27:30,590
int型ではなく、負のint型。

561
00:27:30,590 --> 00:27:32,870
だから私は先に行くと0を打ってみましょう。

562
00:27:32,870 --> 00:27:39,460
そして今、何がここで起こります
私はダウンライン21に到達したとき？

563
00:27:39,460 --> 00:27:40,890
私は再び繰り返されていませんでした。

564
00:27:40,890 --> 00:27:43,320
私はそのループ内で立ち往生していないようです。

565
00:27:43,320 --> 00:27:45,990
換言すれば、この黄色
バーは、周り続けるありませんでした

566
00:27:45,990 --> 00:27:47,130
そして、その周辺、そして周り。

567
00:27:47,130 --> 00:27:48,340
>> さて、それはなぜですか？

568
00:27:48,340 --> 00:27:49,920
まあ、nは、今何をnとしますか？

569
00:27:49,920 --> 00:27:53,280
私は地元で見ることができます
デバッガの変数。

570
00:27:53,280 --> 00:27:53,816
nが0です。

571
00:27:53,816 --> 00:27:55,190
すべての権利、私の条件は何だったのでしょうか？

572
00:27:55,190 --> 00:27:58,700
>> 20--ライン20は、十分にあり、
0は0より大きい。

573
00:27:58,700 --> 00:27:59,500
それは事実ではありません。

574
00:27:59,500 --> 00:28:01,020
0は、0よりも大きくありません。

575
00:28:01,020 --> 00:28:02,820
そして、私はこのうち破りました。

576
00:28:02,820 --> 00:28:06,370
>> そして、そのためには、理由のライン上にあります
21、私は実際に続けば、

577
00:28:06,370 --> 00:28:10,370
私も、0を返すつもりです
私は0を拒否している必要がありますけれども

578
00:28:10,370 --> 00:28:12,484
実際に否定的ではありません。

579
00:28:12,484 --> 00:28:14,650
だから今、私は本当にさえません
デバッガを気に。

580
00:28:14,650 --> 00:28:16,900
それを得た、私はする必要はありません
何が起こっているかをより知っています。

581
00:28:16,900 --> 00:28:19,233
>> だから私は先に行くつもりだと
単に再生ボタンをクリックし、

582
00:28:19,233 --> 00:28:20,240
この仕上げアップをしましょう​​。

583
00:28:20,240 --> 00:28:23,440
今、私は私の気付きました
バグがライン20上明らかです。

584
00:28:23,440 --> 00:28:25,160
それは私の論理エラーです。

585
00:28:25,160 --> 00:28:28,100
>> だから、私は何をしたいです
これを変更するために行うには？

586
00:28:28,100 --> 00:28:32,500
問題は、私はないよということであれば
0をキャッチ、それだけで論理エラーです。

587
00:28:32,500 --> 00:28:35,910
nがある一方で、私は言うことができます
0以上、

588
00:28:35,910 --> 00:28:38,330
何度も何度もユーザに促す保ちます。

589
00:28:38,330 --> 00:28:41,050
>> だから、再び、単純なミス、おそらく
あなたが私を見たときであっても明白

590
00:28:41,050 --> 00:28:42,410
ほんの数分前にそれを書きます。

591
00:28:42,410 --> 00:28:44,570
しかし、ここでお持ち帰り
それは、デバッグ50であります

592
00:28:44,570 --> 00:28:46,850
そして、デバッグと
ソフトウェアより一般的には、

593
00:28:46,850 --> 00:28:51,370
あなたは、この新しい発見力を持っています
見て、独自のコードを歩きます

594
00:28:51,370 --> 00:28:55,590
その右側のパネルを介したもの
あなたの変数の値です。

595
00:28:55,590 --> 00:28:57,700
だから、必ずしもありません
何かを使用する必要があります

596
00:28:57,700 --> 00:29:00,630
あなたはそれらの値を印刷するeprintfなど。

597
00:29:00,630 --> 00:29:04,430
あなたが実際にそれらを見ることができます
視覚的に画面上に。

598
00:29:04,430 --> 00:29:08,920
>> さて、これ以上、それは注目に値します
だ別の技術がありますことを

599
00:29:08,920 --> 00:29:09,890
実際にスーパー共通。

600
00:29:09,890 --> 00:29:13,120
そして、あなたは、なぜ、この少し不思議に思うかもしれません
ここで男は、ステージの上に座ってきました。

601
00:29:13,120 --> 00:29:16,490
したがって、この技術は、一般的に、あります
ゴム製のアヒルのデバッグとして知られ、

602
00:29:16,490 --> 00:29:18,786
これは本当にただです
事実を証明するもの

603
00:29:18,786 --> 00:29:20,660
その多くの場合、プログラマ
コー​​ドを書いています、

604
00:29:20,660 --> 00:29:22,650
彼らは必ずしもないです
他の人と協力し、

605
00:29:22,650 --> 00:29:24,030
または共有環境での作業。

606
00:29:24,030 --> 00:29:25,050
>> 彼らは自宅でのソートのです。

607
00:29:25,050 --> 00:29:25,910
多分それは夜遅くです。

608
00:29:25,910 --> 00:29:28,190
彼らは図にしようとしています
自分のコード内のいくつかのバグアウト。

609
00:29:28,190 --> 00:29:29,330
そして、彼らはそれを見ていません。

610
00:29:29,330 --> 00:29:30,329
>> そして、何のルームメイトはありません。

611
00:29:30,329 --> 00:29:31,250
何のTFはありません。

612
00:29:31,250 --> 00:29:32,680
周辺にCAはありません。

613
00:29:32,680 --> 00:29:36,440
彼らは棚の上に持っているすべての
この小さなゴム製のアヒルです。

614
00:29:36,440 --> 00:29:39,030
>> そしてそうゴム製のアヒルのデバッグ
ちょうどこの招待状です

615
00:29:39,030 --> 00:29:42,780
愚かな何かを考えて
本物の生き物のように、このよう、

616
00:29:42,780 --> 00:29:46,940
実際にあなたのコードを歩きます
口頭この無生物へ。

617
00:29:46,940 --> 00:29:49,230
したがって、例えば、もし
これは私の例でありますhere--

618
00:29:49,230 --> 00:29:52,470
そしてその先にリコール
問題は、このました

619
00:29:52,470 --> 00:29:58,140
私はこのコードの最初の行を削除した場合、
そして、私は先に行くと、再びバギー0を行い、

620
00:29:58,140 --> 00:30:01,220
私はこれらを持っていたことを思い出して
ここでエラーメッセージ。

621
00:30:01,220 --> 00:30:05,997
だから私しかしばかげここでの考え方、
公にこれを行う瞬間に感じます、

622
00:30:05,997 --> 00:30:06,580
そのエラーです。

623
00:30:06,580 --> 00:30:10,910
>> [OK]を、ので、私の問題は、私がしたことです
暗黙的にライブラリ関数を宣言しました。

624
00:30:10,910 --> 00:30:12,610
そして、そのライブラリ関数はprintf関数です。

625
00:30:12,610 --> 00:30:15,290
OK Declare--、宣言
プロトタイプのことを思い出します。

626
00:30:15,290 --> 00:30:18,930
>> それは私が実際にする必要があることを意味します
事前にコンパイラに伝えるもの

627
00:30:18,930 --> 00:30:19,980
関数は次のようになります。

628
00:30:19,980 --> 00:30:20,930
ちょっと待って。

629
00:30:20,930 --> 00:30:23,580
私は標準io.h.を持っていませんでした

630
00:30:23,580 --> 00:30:24,530
どうもありがとうございました。

631
00:30:24,530 --> 00:30:27,330
>> あなたof--だから、このプロセス
実際にアヒルを持っている必要はありません。

632
00:30:27,330 --> 00:30:29,819
しかし、歩行のこのアイデア
自分独自のコードを介して、

633
00:30:29,819 --> 00:30:31,610
あなたも聞くように
あなた自身、あなたのように

634
00:30:31,610 --> 00:30:35,620
あなた自身で脱落を実現
発言は、一般的に考えです。

635
00:30:35,620 --> 00:30:38,910
>> そして、おそらくもっと論理的ではないので、
その1が、より複雑で多くの

636
00:30:38,910 --> 00:30:44,220
例えば私たちは、バギー3.Cで行いました
あなたはそれを介して自分自身を歩くことがあります

637
00:30:44,220 --> 00:30:45,310
次のように。

638
00:30:45,310 --> 00:30:49,190
したがって、すべての権利、ゴム
ダッキー、DDB、可能ならば。

639
00:30:49,190 --> 00:30:52,350
ここでは、私のメインの機能を持っています、
私は負のintを取得呼んでいます。

640
00:30:52,350 --> 00:30:54,660
>> そして、私は戻り値を取得しています。

641
00:30:54,660 --> 00:31:00,410
私は左側にそれを格納しています
私と呼ばれる変数で8行目。

642
00:31:00,410 --> 00:31:02,380
[OK]を、しかし、待って、どのようにしました
それは、その値を取得しますか？

643
00:31:02,380 --> 00:31:04,130
私は12行目で関数を見てみましょう。

644
00:31:04,130 --> 00:31:05,760
>> 12行目では、我々は負のintを取得しています。

645
00:31:05,760 --> 00:31:08,190
任意の入力を取りません、
[OK]、int型を返すん。

646
00:31:08,190 --> 00:31:10,929
私はライン14、変数nに宣言します。

647
00:31:10,929 --> 00:31:12,220
整数を格納するために起こっています。

648
00:31:12,220 --> 00:31:13,760
それは私が欲しいものです。

649
00:31:13,760 --> 00:31:18,480
>> nはせis--ながらだから、次の操作を行います
私は、修正プログラムが私はすでに作ったもの元に戻します。

650
00:31:18,480 --> 00:31:22,710
nがより大きいつつ
0は、[OK]を、Nでプリントアウト。

651
00:31:22,710 --> 00:31:25,170
そして、int型のnに格納されます呼び出します。

652
00:31:25,170 --> 00:31:30,160
nが0である場合、次に、チェック
nがnot--そこにそれがあります。

653
00:31:30,160 --> 00:31:31,910
だから、もう一度、あなたはしないでください
実際のアヒルが必要です。

654
00:31:31,910 --> 00:31:35,650
しかし、単に自分自身を歩きます
知的運動としてあなたのコード

655
00:31:35,650 --> 00:31:37,720
多くの場合、あなたを助けます
何が起こっているの実現、

656
00:31:37,720 --> 00:31:41,170
ちょうど何かをするのではなく、
このように、画面を見つめ、

657
00:31:41,170 --> 00:31:43,720
そして、自分自身を介した話ではありません
正直なところではないこと、

658
00:31:43,720 --> 00:31:46,270
ほぼ有効な手法として。

659
00:31:46,270 --> 00:31:48,620
だから、あなたが持っていること、
多数の異なる技術

660
00:31:48,620 --> 00:31:52,102
実際にあなたのコードをデバッグするための
そして、それらのすべてを、障害を見つけます

661
00:31:52,102 --> 00:31:54,810
あなたのツールキットのツールであるべきです
あなたが夜遅くじゃないように、

662
00:31:54,810 --> 00:31:57,660
特に、あなたはダイニングにいます
ホール、またはオフィスの時間で、

663
00:31:57,660 --> 00:32:00,368
頭を強打
壁は、いくつかの問題を解決しようとします。

664
00:32:00,368 --> 00:32:02,020
ソフトウェアツールが存在することを理解。

665
00:32:02,020 --> 00:32:03,720
ゴム製のアヒルのツールがあります。

666
00:32:03,720 --> 00:32:09,630
そして、全体のスタッフがあります
手を貸すのを待ってサポートしています。

667
00:32:09,630 --> 00:32:13,120
>> だから今、問題に単語は
セット、私たちはあなたを期待しているものに

668
00:32:13,120 --> 00:32:15,620
それらの外に出て、どのように
我々は評価に取り掛かります。

669
00:32:15,620 --> 00:32:17,680
コー​​スのシラバスあたり、
CS50の問題セット

670
00:32:17,680 --> 00:32:22,320
そう、4つの主要な軸で評価されています
スコープをspeak--するために、正確性、デザイン、

671
00:32:22,320 --> 00:32:23,060
そして、スタイル。

672
00:32:23,060 --> 00:32:25,910
そして、範囲は、どれだけのことをいいます
作品のあなたはオフにかましていますか？

673
00:32:25,910 --> 00:32:28,080
あなたはどのように問題の多くを試してみましたか？

674
00:32:28,080 --> 00:32:30,110
努力のどのレベル
あなたは明らかにしていますか？

675
00:32:30,110 --> 00:32:35,750
>> 正しさは、そのままプログラムの作業を行います
それは、CS50の仕様あたりになっています

676
00:32:35,750 --> 00:32:38,640
あなたは、特定の入力を提供するとき
または特定の出力が戻ってきますか？

677
00:32:38,640 --> 00:32:41,130
デザインは、それらのほとんど主観的なものです。

678
00:32:41,130 --> 00:32:43,360
そして、それはその意志一つです
学ぶために最長を取ります

679
00:32:43,360 --> 00:32:47,220
で、教えることと最長
これまでのところ、それはつまるところとして、

680
00:32:47,220 --> 00:32:49,530
あなたのコードは、どのようによく書かれていますか？

681
00:32:49,530 --> 00:32:52,920
>> それはちょうど、正しいを印刷するために一つのことです
出力または正しい値を返します。

682
00:32:52,920 --> 00:32:55,400
しかし、あなたはのようにそれをやっています
効率的に可能な限り？

683
00:32:55,400 --> 00:32:58,210
あなたはそれを除算を行っています
そして征服、またはバイナリ

684
00:32:58,210 --> 00:33:01,500
我々はすぐに我々がやったことがわかりますように、検索
2週間前の電話帳と？

685
00:33:01,500 --> 00:33:04,670
解決するためのより良い方法があります
あなたが現在ここに持っているより問題？

686
00:33:04,670 --> 00:33:06,380
それはよりよい設計のための機会です。

687
00:33:06,380 --> 00:33:08,530
>> そして、どのようにstyle--
かなりあなたのコードはありますか？

688
00:33:08,530 --> 00:33:12,370
あなたは、私はかなりだと気づくでしょう
私のコードをインデントについて特に、

689
00:33:12,370 --> 00:33:15,300
そして、確信して私の変数を作ります
合理的に命名されます。 nは、

690
00:33:15,300 --> 00:33:19,660
短いながら、ために良い名前です
番号、計数整数iについて、

691
00:33:19,660 --> 00:33:20,727
文字列sの。

692
00:33:20,727 --> 00:33:22,560
そして、我々は長く持つことができます
変数名のスタイル。

693
00:33:22,560 --> 00:33:25,500
スタイルはどれだけ良いです
あなたのコードが見えますか？

694
00:33:25,500 --> 00:33:26,600
そして、それはどのように読み取り可能ですか？

695
00:33:26,600 --> 00:33:29,650
>> そして時間をかけて、何あなたのTA
そして、のTFは、コースで行います

696
00:33:29,650 --> 00:33:31,870
それをあなたに提供されています
質的なフィードバックの種類

697
00:33:31,870 --> 00:33:34,330
あなたが良くなるように、
これらのさまざまな側面で。

698
00:33:34,330 --> 00:33:37,510
そして、どのように我々の観点から
これらの軸の各々を評価し、

699
00:33:37,510 --> 00:33:40,080
それは非常に少数で、一般的です
バケツ一般的に、あなたがそのように、

700
00:33:40,080 --> 00:33:41,680
あなたがやっているどれだけの感覚を得ます。

701
00:33:41,680 --> 00:33:45,680
そして、確かに、あなたはスコアを受信した場合に
これらのaxes--正しさ、デザインのいずれか

702
00:33:45,680 --> 00:33:49,659
そして、スタイルがその数をespecially--
一般的には1と5の間であろう。

703
00:33:49,659 --> 00:33:52,450
そして、文字通り、あなたが取得している場合
学期の開始時に3の、

704
00:33:52,450 --> 00:33:53,977
これは非常に良いことです。

705
00:33:53,977 --> 00:33:55,810
それはまだあります意味します
改善の余地、

706
00:33:55,810 --> 00:33:58,490
あなたは内の希望であろう
初めてのクラスを取ります。

707
00:33:58,490 --> 00:34:01,820
天井の一部のビットがうまくいけばあります
これにあなたが到達する志望しています。

708
00:34:01,820 --> 00:34:03,970
そしてそう3の上を取得
最も初期の作品、

709
00:34:03,970 --> 00:34:06,550
そうでない場合は、いくつかの2者と4の、
、確かに、良いことです。

710
00:34:06,550 --> 00:34:08,880
これはよく範囲内ですが、
よく予想内。

711
00:34:08,880 --> 00:34:11,421
>> あなたの心はレースをされている場合や、待ちます
分、5のうち3。

712
00:34:11,421 --> 00:34:12,620
それは本当に10のうち6です。

713
00:34:12,620 --> 00:34:13,560
それは60％です。

714
00:34:13,560 --> 00:34:14,830
F.だ私の神、

715
00:34:14,830 --> 00:34:15,870
>> そうではありません。

716
00:34:15,870 --> 00:34:17,600
それは、実際には、それはありません。

717
00:34:17,600 --> 00:34:22,710
むしろ、それは改善する機会です
学期の経過。

718
00:34:22,710 --> 00:34:25,580
そして、あなたはいくつかを取得している場合
プアーズ、これらの機会です

719
00:34:25,580 --> 00:34:29,199
オフィスアワーを活用するために、
確かセクションおよびその他のリソース。

720
00:34:29,199 --> 00:34:32,840
>> ベストは、本当に、機会です
あなたがきたどれだけ遠くの誇りにします

721
00:34:32,840 --> 00:34:34,520
学期かけてきます。

722
00:34:34,520 --> 00:34:38,199
何もないのであれば、実現しますか
他に、3人は良いです。

723
00:34:38,199 --> 00:34:40,179
そして、それは時間をかけて成長の余地を可能にします。

724
00:34:40,179 --> 00:34:43,090
>> これらの軸があるかについては
加重、現実的にあなたがしています

725
00:34:43,090 --> 00:34:46,745
取得あなたの時間の大半を過ごすつもり
正常に動作し、ましてやするもの。

726
00:34:46,745 --> 00:34:49,120
だから正確にする傾向があります
と同様に、最も重み付けされて

727
00:34:49,120 --> 00:34:51,360
3のこの乗算係数。

728
00:34:51,360 --> 00:34:54,659
デザインも重要ですが、
あなたは必ずしもない何か

729
00:34:54,659 --> 00:34:58,220
上のもの時間のすべてを費やします
物事がうまく動作するように取得しようとしています。

730
00:34:58,220 --> 00:35:00,019
>> そしてそれは、加重ています
もう少し軽く。

731
00:35:00,019 --> 00:35:01,560
そしてスタイルは、少なくともを加重されます。

732
00:35:01,560 --> 00:35:03,710
それはあまりないですにもかかわらず
根本的に重要な、

733
00:35:03,710 --> 00:35:05,990
それは、多分、ちょうどです
右の一番簡単な方法、

734
00:35:05,990 --> 00:35:08,440
例私たちを模倣します
講義やセクションで行い、

735
00:35:08,440 --> 00:35:11,080
きれいなものと
インデント、およびコメントし、

736
00:35:11,080 --> 00:35:14,320
などの最も簡単なの一つであります
行うと、権利を取得するためのもの。

737
00:35:14,320 --> 00:35:16,960
以下のようなので、実現
それらのポイントであることを

738
00:35:16,960 --> 00:35:19,000
把握することは比較的容易であること。

739
00:35:19,000 --> 00:35:22,360
>> そして今単語で
学術正直this--。

740
00:35:22,360 --> 00:35:25,150
コー​​スのあたりだから
シラバス、あなたが表示されます

741
00:35:25,150 --> 00:35:27,630
コー​​スは持っていることを非常に
この周りの言語のビット。

742
00:35:27,630 --> 00:35:31,380
そしてもちろんはの問題を取り
学術正直かなり真剣に。

743
00:35:31,380 --> 00:35:33,450
>> 私たちは、区別を持っています、
良くも悪くもため、

744
00:35:33,450 --> 00:35:36,570
より毎年送ったの
懲戒処分のための学生

745
00:35:36,570 --> 00:35:39,670
ほとんどの他のどのより
私が知っていることを、もちろん、。

746
00:35:39,670 --> 00:35:42,580
これは、必ずしもではありません
事実を示します

747
00:35:42,580 --> 00:35:46,340
CSの学生、またはCS50学生が、あること
任意の少ないクラスメートよ​​りも正直。

748
00:35:46,340 --> 00:35:49,090
しかし、現実という点で、この
電子的に、私たちだけの世界、

749
00:35:49,090 --> 00:35:50,990
技術持っています
これを検出する手段。

750
00:35:50,990 --> 00:35:53,360
>> それはのために私たちに重要です
クラス全体の公平性

751
00:35:53,360 --> 00:35:58,550
私たちが行うことがこれを検出し、上げます
私たちは物事を見る問題。

752
00:35:58,550 --> 00:36:01,980
そして、ちょうど絵を描くと、本当にします
このシンクのようなものを助けるために、

753
00:36:01,980 --> 00:36:04,600
これらは、数あります
過去10年以上の学生

754
00:36:04,600 --> 00:36:07,610
一部に関与していること
学術正直のような問題、

755
00:36:07,610 --> 00:36:10,990
いくつかの32の学生と
秋2015から、その

756
00:36:10,990 --> 00:36:13,760
我々が取るかということです
問題は非常に真剣に。

757
00:36:13,760 --> 00:36:18,380
そして、最終的には、これらの数字は構成し、
最近、約3％、4％程度

758
00:36:18,380 --> 00:36:19,120
クラスの。

759
00:36:19,120 --> 00:36:25,220
>> 学生のマジョリティのためだから
ラインが​​明確であるようです。

760
00:36:25,220 --> 00:36:27,940
しかし、これを維持します
特に後半、気に

761
00:36:27,940 --> 00:36:32,080
夜に苦労するとき
問題セットにいくつかの解決策、

762
00:36:32,080 --> 00:36:34,830
メカニズムが存在すること
より良い自分自身を取得するための

763
00:36:34,830 --> 00:36:37,870
あなたよりサポートがかもしれません
でも、その時間に、と思います。

764
00:36:37,870 --> 00:36:40,514
私たちが受けたときにすることを実現します
学生の提出、我々が交差

765
00:36:40,514 --> 00:36:43,430
今年、すべての提出を比較
すべての提出昨年に対して、

766
00:36:43,430 --> 00:36:47,590
2007年からのすべての提出に対して、
そして同様に、見て、以来、

767
00:36:47,590 --> 00:36:49,931
コー​​ドは、オンラインレポジトリ
ディスカッションフォーラム、求人サイト。

768
00:36:49,931 --> 00:36:51,806
そして、我々はこれを言及し、
本当にために、すべての

769
00:36:51,806 --> 00:36:56,040
た場合に、完全な情報開示の
他の誰かが、それをオンラインで見つけることができます

770
00:36:56,040 --> 00:36:57,880
確かに、私たちのコースすることができます。

771
00:36:57,880 --> 00:37:00,100
しかし、本当に、精神
もちろん沸きます

772
00:37:00,100 --> 00:37:01,650
シラバスでこの句に。

773
00:37:01,650 --> 00:37:03,670
それは本当にただ、合理的です。

774
00:37:03,670 --> 00:37:06,680
>> そして、我々はそれについて詳しく説明していた場合
ただもう少し言語で、

775
00:37:06,680 --> 00:37:09,770
ことをすべてのエッセンスを実現
あなたはこのコースに提出する作業

776
00:37:09,770 --> 00:37:10,954
あなた自身でなければなりません。

777
00:37:10,954 --> 00:37:13,870
しかし、その内、確かにありま​​す
機会、と励まし、

778
00:37:13,870 --> 00:37:17,300
に目を向けおよび教育的価値
自分自身をothers--、TFを、CAは、

779
00:37:17,300 --> 00:37:20,760
クラス内のTA、およびその他、
サポートのために、一人で友人を聞かせて

780
00:37:20,760 --> 00:37:23,547
研究しているとルームメイト
前CSとプログラミング。

781
00:37:23,547 --> 00:37:25,130
だからそのための余裕があります。

782
00:37:25,130 --> 00:37:28,180
そして、一般的な経験則
助けを求めるとき、this--です

783
00:37:28,180 --> 00:37:31,470
あなたが他の人にあなたのコードが表示されることがあり、
しかし、あなたは彼らが表示されない場合があります。

784
00:37:31,470 --> 00:37:34,880
だから、あなたはオフィスの時間にいる場合であっても、
Dホールで、またはどこか他の場所または

785
00:37:34,880 --> 00:37:37,450
いくつかの点セットに取り組んで、
友人と一緒に働いて、その

786
00:37:37,450 --> 00:37:40,160
で、完全に罰金です
一日の終わりにあなたの仕事

787
00:37:40,160 --> 00:37:43,034
最終的にはそれぞれに属している必要があります
あなたのそれぞれはなく、

788
00:37:43,034 --> 00:37:45,700
いくつかの共同作業であること、
最終的なプロジェクト場所を除いて

789
00:37:45,700 --> 00:37:47,410
それは許可し、奨励しています。

790
00:37:47,410 --> 00:37:49,830
>> あなたがしている場合ことを実感
何かに苦しんで

791
00:37:49,830 --> 00:37:52,520
そして、あなたの友人はちょうど起こります
そして、この面で優れているあなた、

792
00:37:52,520 --> 00:37:55,130
またはあなたよりもその問題でより良いです、
または少し遠く前方にあなたよりも、

793
00:37:55,130 --> 00:37:57,330
それが有効に完全に合理的です
お友達へと言う、ちょっと、

794
00:37:57,330 --> 00:38:00,480
あなたがここに私のコードを見て気にしません、
私は私の問題が何であるかを見つける手助け？

795
00:38:00,480 --> 00:38:03,760
そして、うまくいけば、中
教育的価値の関心

796
00:38:03,760 --> 00:38:07,040
その友人はちょうどありません
、ああ、これを行う、と言うのではなく、

797
00:38:07,040 --> 00:38:09,917
あなたが行に何が欠けています
6、またはそのような何か？

798
00:38:09,917 --> 00:38:12,000
しかし、解決策はありません
あなたの隣の友人のため

799
00:38:12,000 --> 00:38:15,617
言って、ああ、よく、ここで、私が引っ張ってみましょう
これまでの、そしてあなたに私の解決策を示しています。

800
00:38:15,617 --> 00:38:16,450
だからラインです。

801
00:38:16,450 --> 00:38:18,670
あなたは、あなたのコードに示します
他の人が、あなたはないかもしれません

802
00:38:18,670 --> 00:38:22,350
他の対象に、彼らを見ます
コー​​スのシラバスで制約。

803
00:38:22,350 --> 00:38:24,760
>> だから、このことを覚えておいてください
いわゆる後悔句

804
00:38:24,760 --> 00:38:27,560
コー​​スのシラバスにおいても、
あなたには、いくつかの行為をした場合、そのこと

805
00:38:27,560 --> 00:38:30,476
合理的ではありませんが、それを持って来ます
当然の頭の注意

806
00:38:30,476 --> 00:38:34,240
72時間以内に、コース
地元の制裁を課すことができること

807
00:38:34,240 --> 00:38:37,380
不満足を含んでもよく、または
送信される作業のための失敗グレード。

808
00:38:37,380 --> 00:38:41,410
しかし、コースは参照しています
さらに懲戒処分の問題で、

809
00:38:41,410 --> 00:38:43,010
繰り返される行為の場合を除いて。

810
00:38:43,010 --> 00:38:46,632
言い換えれば、あなたが行う場合は、いくつかを作ります
愚かな、特に夜遅く、意思決定

811
00:38:46,632 --> 00:38:49,340
その次の日の朝、2日
後で、あなたが目を覚ますと実現、

812
00:38:49,340 --> 00:38:50,870
私は何を考えていましたか？

813
00:38:50,870 --> 00:38:53,890
あなたはCS50にコンセントがありますか
その問題を修正するための

814
00:38:53,890 --> 00:38:57,170
そして、なるように、それまで所有している私たち
途中でお会いし、対処します

815
00:38:57,170 --> 00:39:01,500
それにもある問題で
教育とあなたのために貴重な、

816
00:39:01,500 --> 00:39:04,200
しかし、何らかの方法で、まだ懲罰的。

817
00:39:04,200 --> 00:39:08,590
そして今、これをエッジを脱いで。

818
00:39:08,590 --> 00:39:10,570
>> [ビデオ再生]

819
00:39:10,570 --> 00:39:13,540
>> [MUSICのPLAYING]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END PLAYBACK]

822
00:39:58,866 --> 00:40:00,490
DAVID J.マラン：すべての権利、我々は戻ってきました。

823
00:40:00,490 --> 00:40:03,680
そして今、我々はの1を見て
私たちの現実世界のドメインの最初の

824
00:40:03,680 --> 00:40:08,720
CS50で、暗号の芸術、
送信側と受信側の芸術

825
00:40:08,720 --> 00:40:11,840
暗号化された秘密のメッセージ、
メッセージ可能ならば、

826
00:40:11,840 --> 00:40:17,060
あなたが持っている場合にのみ解読することができます
送信者が持っているいくつかの重要な成分

827
00:40:17,060 --> 00:40:18,030
同じように。

828
00:40:18,030 --> 00:40:22,120
だから私たちは取るよ、これをやる気に
ここでこの事を見て、

829
00:40:22,120 --> 00:40:26,750
そのうちの一例であり、
秘密デコーダリングその

830
00:40:26,750 --> 00:40:34,042
把握するために使用することができます
秘密のメッセージは、実際には何ですか。

831
00:40:34,042 --> 00:40:35,750
実際には、後ろに
小学校で一日、

832
00:40:35,750 --> 00:40:38,787
あなたは今までに秘密のメッセージを送信した場合
いくつかの友人やクラスのいくつかのクラッシュ、

833
00:40:38,787 --> 00:40:40,620
あなたが考えている可能性があります
あなたは賢いされていました

834
00:40:40,620 --> 00:40:46,530
紙変更のあなたの部分にすることにより、
以下のような、BにA、およびDからC、およびCにB、

835
00:40:46,530 --> 00:40:47,590
など。

836
00:40:47,590 --> 00:40:50,300
しかし、あなたが実際に暗号化されました
でもあなたの情報、

837
00:40:50,300 --> 00:40:53,300
それは少し些細だった場合、ありませんでした
そのハード先生が実現するために、

838
00:40:53,300 --> 00:40:55,675
よく、あなただけ変更した場合
BにAとCにB、

839
00:40:55,675 --> 00:40:57,550
あなたが実際に把握します
メッセージは何でした、

840
00:40:57,550 --> 00:40:59,700
しかし、あなたは情報を暗号でした。

841
00:40:59,700 --> 00:41:03,420
>> あなたはそれをやっていました
単に、はるかにRalphieのように、ここで

842
00:41:03,420 --> 00:41:07,934
演じている有名な映画の中で
ほとんどの広告nauseum各冬。

843
00:41:07,934 --> 00:41:08,600
[ビデオ再生]

844
00:41:08,600 --> 00:41:11,180
それはすべてのことに知られて-bE
ラルフ・パーカーはここにあります

845
00:41:11,180 --> 00:41:14,070
リトルのメンバーを任命
孤児アニー秘密のサークル

846
00:41:14,070 --> 00:41:17,700
そして、すべての栄誉を受ける権利があります
および利点は、そこに発生します。

847
00:41:17,700 --> 00:41:24,340
>> -Signed、台所戦争アニー、
カウンター署名インクで、ピエール・アンドレ。

848
00:41:24,340 --> 00:41:27,160
栄誉とメリット、
すでに9歳で。

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [叫び]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-いい加減にして。

853
00:41:34,250 --> 00:41:35,210
のは、それを上に取得してみましょう。

854
00:41:35,210 --> 00:41:39,530
私はすべてのことジャズを必要としません
密輸と海賊について。

855
00:41:39,530 --> 00:41:41,660
>> 用-listen明日の夜
結びの冒険

856
00:41:41,660 --> 00:41:43,880
黒海賊船の。

857
00:41:43,880 --> 00:41:46,650
今、それはのための時間です
アニーの秘密のメッセージ

858
00:41:46,650 --> 00:41:49,840
秘密のサークルのあなたのメンバーのために。

859
00:41:49,840 --> 00:41:53,570
覚えておいて、子供たち、メンバーのみ
アニーの秘密サークルの

860
00:41:53,570 --> 00:41:56,140
アニーの秘密のメッセージを復号することができます。

861
00:41:56,140 --> 00:42:00,340
>> アニーはあなたに依存されている、覚えておいてください。

862
00:42:00,340 --> 00:42:02,880
B2にあなたのピンを設定します。

863
00:42:02,880 --> 00:42:05,230
ここにメッセージがあります。

864
00:42:05,230 --> 00:42:06,090
12、11--

865
00:42:06,090 --> 00:42:10,250
>> -Iは、中に私の最初の秘密会議をしています。

866
00:42:10,250 --> 00:42:13,890
>> -14、11、18、16。

867
00:42:13,890 --> 00:42:15,780
>> -Pierreは素晴らしい声で今夜でした。

868
00:42:15,780 --> 00:42:19,000
私は今夜​​のことを言うことができます
メッセージが本当に重要でした。

869
00:42:19,000 --> 00:42:22,694
>> -3、25は、それが、メッセージの
アニー自身から。

870
00:42:22,694 --> 00:42:23,860
誰にも言わないでください、覚えておいてください。

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90秒後、私はのみによ
9の少年の家の部屋

873
00:42:32,930 --> 00:42:37,040
プライバシーとデコードに座ることができました。

874
00:42:37,040 --> 00:42:39,730
なるほど、B！

875
00:42:39,730 --> 00:42:42,360
私は次の、Eに行ってきました

876
00:42:42,360 --> 00:42:44,520
>> 最初の単語があることです。

877
00:42:44,520 --> 00:42:49,032
Sは、それは、現在Uを容易に来ました25--

878
00:42:49,032 --> 00:42:51,733
>> -OH、是非、Ralphieは、私が行くなきゃ！

879
00:42:51,733 --> 00:42:53,688
>> 右ダウンして-I'll、馬！

880
00:42:53,688 --> 00:42:54,188
ジーの達人！

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -Tは、O、何に必ずto--確認してください？

883
00:43:04,060 --> 00:43:05,970
台所戦争何でした
アニー言いたいの？

884
00:43:05,970 --> 00:43:07,264
何に必ず？

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie、アンディはに持っています
行く、あなたが出て来てくださいだろうか？

886
00:43:09,634 --> 00:43:10,480
>> -All右、馬！

887
00:43:10,480 --> 00:43:12,880
私は右のアウトになるだろう！

888
00:43:12,880 --> 00:43:14,550
>> -Iは近い今なっていました。

889
00:43:14,550 --> 00:43:16,620
張力はひどいものでした。

890
00:43:16,620 --> 00:43:17,720
それが何だった？

891
00:43:17,720 --> 00:43:20,170
惑星の運命
バランスでハングすることがあります。

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie！

893
00:43:20,670 --> 00:43:23,170
アンディのお奨めは行きます！

894
00:43:23,170 --> 00:43:26,890
>> 大声で泣くのために、右アウトすることが-I'll！

895
00:43:26,890 --> 00:43:32,680
>> そこ-Almost、私の指は、私の心を飛びました
鋼トラップだった、すべての細孔が振動しました。

896
00:43:32,680 --> 00:43:37,198
これは、はい、はい、はい、ほとんど透明でした。

897
00:43:37,198 --> 00:43:43,091
>> あなたのオヴァルティンを飲むようにしてください-bE。

898
00:43:43,091 --> 00:43:43,590
オヴァルティン？

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
安っぽい商業？

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
クソ野郎。

903
00:43:54,227 --> 00:43:54,810
[END PLAYBACK]

904
00:43:54,810 --> 00:43:57,390
DAVID J.マラン：OK、そう
それは非常に長い道のりでした

905
00:43:57,390 --> 00:44:00,660
暗号化を導入します、
また、オヴァルティン。

906
00:44:00,660 --> 00:44:04,470
実際には、この古い広告から
ここで、なぜオヴァルティンはとても良いのですか？

907
00:44:04,470 --> 00:44:09,470
それは熟したの濃縮抽出であります
大麦麦芽、純粋なクリーミー牛乳、

908
00:44:09,470 --> 00:44:14,360
そして特別に一緒に、ココアを用意
天然ホスファチドやビタミンと。

909
00:44:14,360 --> 00:44:18,240
これは、さらにで強化されています
追加のビタミンBとD、yumを。

910
00:44:18,240 --> 00:44:21,600
そして、あなたはまだ明らかに、それを得ることができ、
Amazonで、私たちはここで行ったように。

911
00:44:21,600 --> 00:44:24,810
>> しかし、動機はここにありました
具体的には、暗号化を導入

912
00:44:24,810 --> 00:44:28,340
知られている暗号化の種類
秘密鍵暗号方式として。

913
00:44:28,340 --> 00:44:34,284
そして名前は、全体を示唆するように
秘密鍵暗号システムのセキュリティ、

914
00:44:34,284 --> 00:44:36,200
可能ならば、方法論
ちょうどスクランブルします

915
00:44:36,200 --> 00:44:40,960
2人の間の情報、すなわち
送信者と受信者だけのみ

916
00:44:40,960 --> 00:44:46,980
いくつかの値key--秘密を知っている、いくつかの
その秘密フレーズ、いくつかの暗証番号、

917
00:44:46,980 --> 00:44:50,660
両方の暗号化にそれらを可能にします
情報を解読します。

918
00:44:50,660 --> 00:44:53,470
そして、暗号化、本当に、
ちょうど今週0からです。

919
00:44:53,470 --> 00:44:56,715
>> これは、入力があります問題です
英語での実際のメッセージのような

920
00:44:56,715 --> 00:44:59,340
または任意の言語そのあなた
クラスで誰かに送信します、

921
00:44:59,340 --> 00:45:00,580
またはインターネット上で。

922
00:45:00,580 --> 00:45:03,840
起こっているいくつかの出力があり、
あなたスクランブルメッセージであることを

923
00:45:03,840 --> 00:45:05,250
受信者が受信したいです。

924
00:45:05,250 --> 00:45:07,405
そして、たとえの誰か
真ん中はあまりにもそれを受けて、

925
00:45:07,405 --> 00:45:09,780
あなたがそれらをしたくありません
必ずしもそれを解読することができ、

926
00:45:09,780 --> 00:45:12,840
この内部の理由
ブラックボックス、またはアルゴリズム、

927
00:45:12,840 --> 00:45:17,650
いくつかのメカニズム、ステップバイいくつかのステップであります
その入力を取るための命令、

928
00:45:17,650 --> 00:45:20,710
とに変換します
うまくいけば安全な方法で出力、。

929
00:45:20,710 --> 00:45:23,640
>> そして、実際には、あるいくつかの
この世界では語彙次のように。

930
00:45:23,640 --> 00:45:26,100
プレーンテキストは、単語aは
コンピュータ科学者だろう

931
00:45:26,100 --> 00:45:28,449
入力を説明するために使用
英語のようなメッセージ、

932
00:45:28,449 --> 00:45:31,240
実際にまたは任意の言語を使用します
いくつかの他のヒトに送信します。

933
00:45:31,240 --> 00:45:35,450
そして、暗号文がスクランブルです
、暗号化、または暗号化へ

934
00:45:35,450 --> 00:45:36,520
そのバージョン。

935
00:45:36,520 --> 00:45:38,750
>> しかし、ここで一つの他の成分があります。

936
00:45:38,750 --> 00:45:43,200
1つの他の入力があります
秘密鍵暗号方式。

937
00:45:43,200 --> 00:45:45,200
そして、それはキー自体です、
これは、一般に、あります

938
00:45:45,200 --> 00:45:48,930
我々は、番号が表示されますよう、または
文字、または単語、何でも

939
00:45:48,930 --> 00:45:51,980
このアルゴリズムは、それが実際に期待されます。

940
00:45:51,980 --> 00:45:53,870
>> そして、どのように情報を復号化するのですか？

941
00:45:53,870 --> 00:45:55,110
どのようにそれを解読できますか？

942
00:45:55,110 --> 00:45:57,950
さて、あなただけのリバース
出力と入力。

943
00:45:57,950 --> 00:46:00,900
>> つまり、誰かが一度
あなたの暗号化されたメッセージは、受信します

944
00:46:00,900 --> 00:46:03,740
彼または彼女は単に持っています
その同じキーを知っています。

945
00:46:03,740 --> 00:46:05,700
彼らは、暗号文を受けています。

946
00:46:05,700 --> 00:46:09,530
そして、それらの2を差し込むことにより、
暗号システムへの入力、

947
00:46:09,530 --> 00:46:14,260
アウトアルゴリズム、このブラックボックス、
元の平文を来る必要があります。

948
00:46:14,260 --> 00:46:17,830
そして、そのためには、非常に高いレベルです
暗号が実際に何であるかの見解

949
00:46:17,830 --> 00:46:18,590
の全て。

950
00:46:18,590 --> 00:46:20,030
>> それでは、そこに取得してみましょう。

951
00:46:20,030 --> 00:46:22,700
今度は下に見てみましょう
何かのフード

952
00:46:22,700 --> 00:46:26,000
以下のために付与されたために、私たちは取ってきました
先週、このセッションのために

953
00:46:26,000 --> 00:46:27,629
文字列をhere--。

954
00:46:27,629 --> 00:46:30,295
一日の終わりに文字列
文字だけのシーケンスです。

955
00:46:30,295 --> 00:46:33,610
>> これはハロー世界であること、または可能性があります
こんにちはZamyla、または何でも。

956
00:46:33,610 --> 00:46:37,050
しかし、それはに何を意味するのでしょ
文字の配列であること？

957
00:46:37,050 --> 00:46:41,520
実際には、CS50ライブラリが提供します
私たちの文字列と呼ばれるデータ型。

958
00:46:41,520 --> 00:46:45,140
>> しかし、ノー実際にそこにあります
Cの文字列のようなもの

959
00:46:45,140 --> 00:46:49,450
それは実際のちょうど配列であり、
文字、文字、文字、

960
00:46:49,450 --> 00:46:52,180
背中合わせの文字、、、へ
背中、内部バックアップする、バックアップします

961
00:46:52,180 --> 00:46:54,650
コンピュータのメモリ、またはRAMの。

962
00:46:54,650 --> 00:46:58,940
そして、我々は中にその中に深く見ていきます
我々はメモリ自体を見て、将来、

963
00:46:58,940 --> 00:47:02,030
そして、使用率、および
関与している脅威。

964
00:47:02,030 --> 00:47:04,100
>> しかし、ここでは、文字列Zamylaを考えてみましょう。

965
00:47:04,100 --> 00:47:07,480
のだから名前
ここでは、人間、Zamyla、

966
00:47:07,480 --> 00:47:12,030
それは、一連のです
文字、Z-A-M-Y-L-A。

967
00:47:12,030 --> 00:47:16,020
そして今のはそのZamylaの名前を仮定しましょう
コンピュータの内部に格納されています

968
00:47:16,020 --> 00:47:16,880
プログラム。

969
00:47:16,880 --> 00:47:20,830
>> まあ、それは我々がすべきことは理にかなって
それらの文字を見てすることができます

970
00:47:20,830 --> 00:47:21,590
個別に。

971
00:47:21,590 --> 00:47:24,710
だから、僕は少しを描くつもりです
ここZamylaの名前の周りにボックス。

972
00:47:24,710 --> 00:47:31,580
そして、それはそのとき、Cの場合であります
多分Zamyla--と同様に、文字列を持っています

973
00:47:31,580 --> 00:47:34,940
その文字列から帰ってきました
GET文字列のような機能、

974
00:47:34,940 --> 00:47:38,540
あなたが実際に操作することができます
文字によってその文字。

975
00:47:38,540 --> 00:47:42,070
>> さて、これがためにゲルマンです
手元の会話、理由

976
00:47:42,070 --> 00:47:46,420
暗号であなたが変更したい場合
DのB、およびB、C、およびC、

977
00:47:46,420 --> 00:47:49,650
など、あなたができるようにする必要があります
個々の文字を見て

978
00:47:49,650 --> 00:47:50,190
文字列インチ

979
00:47:50,190 --> 00:47:52,695
あなたが変更できるようにする必要があります
何か他のもの、AからZ

980
00:47:52,695 --> 00:47:55,280
何か他のものへの、Mは
ように何か他のもの、と。

981
00:47:55,280 --> 00:47:58,000
そして、私たちは方法が必要になり、
プログラムで、そう

982
00:47:58,000 --> 00:48:03,020
Cに、話すためには、変更することができるようにします
そして個々の文字を見てください。

983
00:48:03,020 --> 00:48:05,690
次のようにそして、我々はこれを行うことができます。

984
00:48:05,690 --> 00:48:08,340
>> 私はCS50 IDEに引き返す行きましょう。

985
00:48:08,340 --> 00:48:11,130
そして、私は先に行ってみましょう
新しいファイルを作成します

986
00:48:11,130 --> 00:48:16,134
私はこの時間string0と呼ぶことにしますことを、
私たちの最初のそのような例として、Cに点在しています。

987
00:48:16,134 --> 00:48:18,300
そして、私は先に行くつもりです
次のようにして、それをかき立てます。

988
00:48:18,300 --> 00:48:22,870
>> だからCS50.hが挙げられ、
その後、標準io.hを含み、

989
00:48:22,870 --> 00:48:25,990
これは、私はほとんど常にに行きますよ
少なくとも、私のプログラムで使用しています

990
00:48:25,990 --> 00:48:26,780
最初は。

991
00:48:26,780 --> 00:48:32,180
int型メインボイド、その後、ここで私がよ
文字列をするつもりは、文字列を取得します。

992
00:48:32,180 --> 00:48:35,260
そして、私はするつもりです
先に行くと、これを行います。

993
00:48:35,260 --> 00:48:37,460
私は先に行きたいです
そして、健全性チェックとして、

994
00:48:37,460 --> 00:48:43,607
ちょうど言う、こんにちは、パーセントの、
セミコロンは、文字列0になります。

995
00:48:43,607 --> 00:48:44,690
Uhオハイオ州、私はここで何をしましたか？

996
00:48:44,690 --> 00:48:45,930
ああ、私はそれをプラグインしませんでした。

997
00:48:45,930 --> 00:48:48,120
それでレッスンは、学んだこと
意図的ではなかったです。

998
00:48:48,120 --> 00:48:52,480
>> だからエラー、より多くのパーセント
データ引数よりも変換。

999
00:48:52,480 --> 00:48:54,940
そして、これはどこにあります
ライン7-- OK、私は持っています、

1000
00:48:54,940 --> 00:48:56,690
引用終わりの引用、それはです
printf関数に私の文字列。

1001
00:48:56,690 --> 00:48:58,151
私は、パーセント記号を持っています。

1002
00:48:58,151 --> 00:48:59,650
しかし、私は第二引数が不足しています。

1003
00:48:59,650 --> 00:49:03,190
>> 私は、コンマ秒が欠落していますよ
私は、先の例で持っていました。

1004
00:49:03,190 --> 00:49:06,650
修正するので、良い機会
もう一つのミス、誤って。

1005
00:49:06,650 --> 00:49:09,950
そして今、私が実行してみましょう
string0、Zamylaを入力します。

1006
00:49:09,950 --> 00:49:10,970
Zamylaこんにちは、[OK]をクリックします。

1007
00:49:10,970 --> 00:49:14,144
>> だから我々はこの種のプログラムを実行しようとしました
今、いくつかの異なる回。

1008
00:49:14,144 --> 00:49:16,310
しかし、それでは、何かaをやらせます
今回は少し異なります。

1009
00:49:16,310 --> 00:49:19,450
代わりにちょうどZamylaのを印刷します
printf関数と名前全体うち、

1010
00:49:19,450 --> 00:49:21,350
のは、文字でそれを文字にしましょう​​。

1011
00:49:21,350 --> 00:49:22,700
>> 私は、forループを使用するつもりです。

1012
00:49:22,700 --> 00:49:26,160
そして、私は自分自身を与えるつもりです
カウント変数は、私と呼ばれます。

1013
00:49:26,160 --> 00:49:33,530
そして、私はそのように、反復を維持するつもりです
iがSの長さ未満である限り。

1014
00:49:33,530 --> 00:49:35,930
>> それは結局のところ、我々はしませんでした
この最後の時間を行います、

1015
00:49:35,930 --> 00:49:39,100
そのcが付属しています
スターリング、呼び出される関数です。

1016
00:49:39,100 --> 00:49:42,690
戻る日に、と一般的には
まだ機能を実装する場合、

1017
00:49:42,690 --> 00:49:45,405
人間はしばしば非常に選択されます
簡潔な名前の音の種類

1018
00:49:45,405 --> 00:49:48,280
あなたはそれがだとしても、何をしたいのような
いくつかの母音や文字欠落しています。

1019
00:49:48,280 --> 00:49:50,660
だから、スターリングは、
その関数の名前

1020
00:49:50,660 --> 00:49:53,880
間の引数を取ります
文字列でなければなりません括弧。

1021
00:49:53,880 --> 00:49:56,910
そして、それはちょうど整数を返し、
その文字列の長さ。

1022
00:49:56,910 --> 00:50:00,580
>> 7行目のループのためにこのように起こっています
iが0に等しいからカウントを開始します。

1023
00:50:00,580 --> 00:50:02,530
インクリメントするために起こっています
各反復のI

1024
00:50:02,530 --> 00:50:04,350
1によって、私たちは何度か行ってきたよう。

1025
00:50:04,350 --> 00:50:06,780
しかし、それだけでやろうとしています
このアップ時点まで

1026
00:50:06,780 --> 00:50:09,660
私は長さである場合
文字列自体の。

1027
00:50:09,660 --> 00:50:14,520
>> だから、これは最終的に、の方法です、
文字を反復処理

1028
00:50:14,520 --> 00:50:17,430
文字列に以下の通りです。

1029
00:50:17,430 --> 00:50:20,670
私はしませんプリントアウトするつもりです
文字列全体が、％のC、

1030
00:50:20,670 --> 00:50:22,860
単一文字
新しい行が続きます。

1031
00:50:22,860 --> 00:50:24,880
そして、私はするつもりです
先に行く、と私は必要があります

1032
00:50:24,880 --> 00:50:29,080
私は印刷したいと言って
Sのi番目の文字。

1033
00:50:29,080 --> 00:50:33,450
>> だから私が示す変数の場合
文字列のインデックス

1034
00:50:33,450 --> 00:50:37,230
あなたはそれで、私のことができるようにする必要があります
私は秒のi番目の文字を与える、と言います。

1035
00:50:37,230 --> 00:50:40,390
そして、cが行う方法があります
角括弧でこの。

1036
00:50:40,390 --> 00:50:43,679
あなたは、単にの名前を言います
この場合にはsである文字列。

1037
00:50:43,679 --> 00:50:46,970
そして、あなたは角括弧を使用します
通常はちょうどあなたのリターン上または入力してください

1038
00:50:46,970 --> 00:50:48,110
キーボード上のキー。

1039
00:50:48,110 --> 00:50:52,410
そして、あなたはのインデックスを置きます
印刷したい文字。

1040
00:50:52,410 --> 00:50:55,960
だから、インデックスがあることを行っています
number-- 0、又は1、又は2、又は3、又はドット、

1041
00:50:55,960 --> 00:50:57,590
ドット、ドット、他のいくつかの数。

1042
00:50:57,590 --> 00:51:00,920
>> そして、我々はそれが起こっていることを確認してください
私ので、右の数であります

1043
00:51:00,920 --> 00:51:02,360
0からカウントを開始します。

1044
00:51:02,360 --> 00:51:07,020
そしてデフォルトでは、最初の文字
文字列内の慣例0によるものです。

1045
00:51:07,020 --> 00:51:09,230
2番目の文字は、ブラケット1です。

1046
00:51:09,230 --> 00:51:11,120
そして、3番目の文字は、ブラケット2です。

1047
00:51:11,120 --> 00:51:13,630
そして、あなたはあまりにも行きたくありません
これまで、我々は我々がしているしませんので、

1048
00:51:13,630 --> 00:51:17,780
それだけまで私をインクリメントする予定
文字列の長さに等しいです。

1049
00:51:17,780 --> 00:51:20,210
そしてその時点で、
このforループは停止します。

1050
00:51:20,210 --> 00:51:25,550
>> だから私は先に行くと、これを保存してみましょう
プログラム、および実行は、文字列0を作ります。

1051
00:51:25,550 --> 00:51:28,400
しかし、私はめちゃくちゃ。

1052
00:51:28,400 --> 00:51:35,390
暗黙的にライブラリ関数を宣言
タイプなどでスターリング、今such--、

1053
00:51:35,390 --> 00:51:36,430
これは聞き覚え。

1054
00:51:36,430 --> 00:51:37,440
しかし、それはprintf関数ではありません。

1055
00:51:37,440 --> 00:51:38,540
そして、それは文字列を取得していません。

1056
00:51:38,540 --> 00:51:40,480
>> 私はで台無しにしませんでした
同じように、この時間。

1057
00:51:40,480 --> 00:51:45,100
しかし、ここで少しダウンダウンに気付きます
さらに、ヘッダーstring.hのを含んで、

1058
00:51:45,100 --> 00:51:47,210
明示的に提供
スターリングの宣言。

1059
00:51:47,210 --> 00:51:48,820
だから、実際にそこに手がかりがあります。

1060
00:51:48,820 --> 00:51:51,670
>> そして実際それが判明します
別のヘッダファイルがあります

1061
00:51:51,670 --> 00:51:53,970
我々が使用されていませんでしたことを
まだクラスで、それはです

1062
00:51:53,970 --> 00:51:56,480
利用可能なもののうち、
あなたに、string.hのと呼ばれます。

1063
00:51:56,480 --> 00:52:00,930
そして、そのファイルで、string.hの
スターリングが宣言されます。

1064
00:52:00,930 --> 00:52:05,220
だから私は先に行くとしましょう
これを保存し、文字列を作ります

1065
00:52:05,220 --> 00:52:08,040
0--素敵な、エラーメッセージなしこの時間。

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla、および
私は、Enterキーを押ししようよ

1067
00:52:12,290 --> 00:52:16,710
その時点でのGetStringが起こっています
文字列を返すように、sの中でそれを置きます。

1068
00:52:16,710 --> 00:52:21,890
次にためのループが反復処理しようとしていること
一度に1つのSの文字の上に、

1069
00:52:21,890 --> 00:52:28,420
そして、するので、それらを1行に1つずつを印刷
私が最後でそのバックスラッシュnを持っていました。

1070
00:52:28,420 --> 00:52:34,530
だから私は、そのバックスラッシュを省略することができ
nは、その後、ちょうどすべてZamylaを印刷

1071
00:52:34,530 --> 00:52:37,460
同じラインで、
効果的に再実装

1072
00:52:37,460 --> 00:52:38,999
すべてのことは有用ではないのprintf、。

1073
00:52:38,999 --> 00:52:40,540
しかしこの場合、私はそれをやっていませんでした。

1074
00:52:40,540 --> 00:52:43,610
私は実際に1をプリントしました
当時の文字、1行に1つずつ、

1075
00:52:43,610 --> 00:52:45,400
私たちは、実際に効果を見ること。

1076
00:52:45,400 --> 00:52:46,900
>> しかし、私はここに一つのことに注意してください。

1077
00:52:46,900 --> 00:52:48,930
そして、我々は戻ってくるだろう
今後一週間でこの。

1078
00:52:48,930 --> 00:52:52,650
これは、このことが判明します
コー​​ドは、潜在的にバグがあります。

1079
00:52:52,650 --> 00:52:56,560
>> これは、文字列を取得することが判明します
生活の中で、いくつかの他の機能

1080
00:52:56,560 --> 00:53:00,280
必ずしもいつも
あなたが期待しているものを返します。

1081
00:53:00,280 --> 00:53:03,010
我々は最後のクラスから知っています
取得このの時間

1082
00:53:03,010 --> 00:53:04,960
文字列は、文字列を返すことになっています。

1083
00:53:04,960 --> 00:53:09,900
しかし、このようなアウトユーザータイプの場合
ロングワード、または段落、またはエッセイ

1084
00:53:09,900 --> 00:53:13,010
ちょうど十分ではないがあること
それに合わせて、コンピュータのメモリ。

1085
00:53:13,010 --> 00:53:15,410
>> 同様に、何かがどのようになった場合
フードの下に間違っていますか？

1086
00:53:15,410 --> 00:53:18,400
それは頻繁に起こらないかもしれないが、
それは、一度発生する可能性があります

1087
00:53:18,400 --> 00:53:21,520
一方で、非常にまれに。

1088
00:53:21,520 --> 00:53:25,460
そしてそれは、文字列を取得ことが判明します
そのような機能は必ずしもん

1089
00:53:25,460 --> 00:53:26,380
常に文字列を返します。

1090
00:53:26,380 --> 00:53:30,680
彼らはいくつかのエラー値を返す可能性があり、
いわば、いくつかのセンチネル値、

1091
00:53:30,680 --> 00:53:32,612
それがあることを示し
何かが間違っています。

1092
00:53:32,612 --> 00:53:35,320
そして、あなただけからこれを知っているだろう
今クラスでそれを学んだました、

1093
00:53:35,320 --> 00:53:37,700
またはいくつかのより多くのドキュメントを読みました。

1094
00:53:37,700 --> 00:53:43,120
これは、文字列を取得することが判明します
ヌルと呼ばれる値を返すことができます。

1095
00:53:43,120 --> 00:53:46,220
ヌルは、私たちがよ特別な値であります
将来の週に戻ってきます。

1096
00:53:46,220 --> 00:53:50,420
しかし、今のところ、ちょうど私がしたい場合ことを知っています
前進で本当に適切であることを

1097
00:53:50,420 --> 00:53:52,650
GET文字列を使用して、I
ちょうどそれを呼び出すべきではありません、

1098
00:53:52,650 --> 00:53:56,870
そして、盲目的にその戻り値を使用し、
それは文字列だと信頼します。

1099
00:53:56,870 --> 00:53:59,420
>> 私が最初に言うべきです、
ちょっとだけ、ちょっと待って

1100
00:53:59,420 --> 00:54:03,380
sが等しくない場合に進行
ヌル、再びヌル、

1101
00:54:03,380 --> 00:54:04,660
ただ、いくつかの特別な値です。

1102
00:54:04,660 --> 00:54:07,770
そして、それはあなただけの特別な値です
GET文字列を心配する必要があります。

1103
00:54:07,770 --> 00:54:10,900
文字列を取得するのいずれかであるだろう
文字列またはnullを返します。

1104
00:54:10,900 --> 00:54:17,219
>> そして、この感嘆符は、等号
あなたは多分数学のクラスから知っているかもしれません

1105
00:54:17,219 --> 00:54:20,510
あなたが等号を引くかもしれません
それを通る線は等しくないことを示します。

1106
00:54:20,510 --> 00:54:23,135
それは、一般的な文字ではありません
あなたのキーボードで入力することができます。

1107
00:54:23,135 --> 00:54:26,480
だからほとんどのプログラミング言語で、
あなたが等しくないと言いたいとき、

1108
00:54:26,480 --> 00:54:29,160
あなたは感嘆符を使用し、
そうでなければビッグバンとして知られています。

1109
00:54:29,160 --> 00:54:33,180
だから、ビッグバンは、等しいと言っています
論理的に、等しくないことを意味します。

1110
00:54:33,180 --> 00:54:38,060
それは大きくありませんだけのようです
より、または等しい、または未満

1111
00:54:38,060 --> 00:54:41,270
または同等のキーボードのキーにします
それは、一つのシンボルですべての作業を実行します。

1112
00:54:41,270 --> 00:54:44,020
だから、だからこそ、過去の例では、
あなたは開き括弧をした、その後、

1113
00:54:44,020 --> 00:54:48,670
行うためには、等号、
未満、たとえば、以上。

1114
00:54:48,670 --> 00:54:49,910
>> だからここに持ち帰りは何ですか？

1115
00:54:49,910 --> 00:54:53,880
これは、単に今の方法であります
、この機能をこの構文を導入し、

1116
00:54:53,880 --> 00:54:57,390
個々の繰り返し処理
文字列内の文字。

1117
00:54:57,390 --> 00:55:00,260
そして、ちょうどそれらの正方形のような
ブラケットは、あなたがそれらを取得することを可能にします

1118
00:55:00,260 --> 00:55:03,790
これらの角括弧を考えます
種類のこの根底にあるを示唆

1119
00:55:03,790 --> 00:55:06,040
デザイン、それによってすべての
文字列の内側の文字

1120
00:55:06,040 --> 00:55:10,180
種類の下にどこかに箱詰めされ、
コンピュータのメモリ内のフード。

1121
00:55:10,180 --> 00:55:12,340
>> しかし、ここでは、この変異体を作ってみましょう。

1122
00:55:12,340 --> 00:55:14,880
これは、このことが判明します
プログラムは正しいです。

1123
00:55:14,880 --> 00:55:18,810
CS50の軸あたりだから評価します
コー​​ドは、これは正しくなりました。

1124
00:55:18,810 --> 00:55:22,959
特に今私がチェックしていること
nullの場合、このプログラムがクラッシュすることはありません。

1125
00:55:22,959 --> 00:55:24,500
そして、私はただの経験からそれを知っています。

1126
00:55:24,500 --> 00:55:28,040
しかし、そのほかには何もありません
私たちは本当に間違ってここに行くことができます。

1127
00:55:28,040 --> 00:55:31,860
しかし、それは非常によく設計されていないのです、
のが基本に戻ってみましょうので。

1128
00:55:31,860 --> 00:55:34,450
>> まず、principles--
ループのため何をするのでしょうか？

1129
00:55:34,450 --> 00:55:36,290
forループAは、3つのことを行います。

1130
00:55:36,290 --> 00:55:39,340
これは、いくつかの初期化を行います
値、あなたがそれを求めるなら。

1131
00:55:39,340 --> 00:55:41,770
これは、条件をチェック。

1132
00:55:41,770 --> 00:55:45,380
そして、後の各
反復、各サイクルの後、

1133
00:55:45,380 --> 00:55:49,330
それはいくつかの増分
値、または値、ここに。

1134
00:55:49,330 --> 00:55:50,600
>> だから、それは何を意味するのでしょうか？

1135
00:55:50,600 --> 00:55:52,940
私たちは、私が0に初期化します。

1136
00:55:52,940 --> 00:55:58,610
我々はチェックし、私が以下であることを確認してください
Z-A-M-Y-L-Aであるsの長、

1137
00:55:58,610 --> 00:55:59,900
そのように6未満です。

1138
00:55:59,900 --> 00:56:02,590
そして、確かに、6未満として0。

1139
00:56:02,590 --> 00:56:05,580
>> 私たちは、Zamylaの名前からZをプリントアウト。

1140
00:56:05,580 --> 00:56:08,080
その後、我々は0から1に私をインクリメントします。

1141
00:56:08,080 --> 00:56:11,290
私たちはその後、チェック、1以下であります
Sの長さよりも？

1142
00:56:11,290 --> 00:56:13,270
Sの長さは6です。

1143
00:56:13,270 --> 00:56:13,950
はい、そうです。

1144
00:56:13,950 --> 00:56:16,880
>> だから我々はZamylaの名前、ZAで印刷します。

1145
00:56:16,880 --> 00:56:20,090
私たちは2に、1に、0から私をインクリメントします。

1146
00:56:20,090 --> 00:56:23,720
私たちは、その後より2小さい、チェック
Zamylaの名前の長さ。

1147
00:56:23,720 --> 00:56:25,380
6-ので2は6未満です。

1148
00:56:25,380 --> 00:56:30,460
はい、それでは、M中をプリントアウトしてみましょう
Zamylaの名前、3番目の文字。

1149
00:56:30,460 --> 00:56:34,110
>> ここで重要なのは、それはそれぞれの上にあります
物語の反復は、私がチェックしています、

1150
00:56:34,110 --> 00:56:37,810
私はZamylaの長さよりも小さいですか？

1151
00:56:37,810 --> 00:56:40,350
しかし、キャッチということです
スターリングはプロパティではありません。

1152
00:56:40,350 --> 00:56:43,100
プログラムされているあなたの人々の
Javaや他の言語の前に

1153
00:56:43,100 --> 00:56:46,310
文字列の長さを知っているかもしれません
プロパティ、単にいくつかの読み取り専用の値。

1154
00:56:46,310 --> 00:56:50,220
>> この場合にはCで、これがある場合
文字通り機能

1155
00:56:50,220 --> 00:56:53,520
の数を数えます
毎回Zamylaの文字

1156
00:56:53,520 --> 00:56:54,740
私たちは、その関数を呼び出します。

1157
00:56:54,740 --> 00:56:58,500
使用するコンピュータを頼むたびに
スターリングは、それがZamylaを見て取って、

1158
00:56:58,500 --> 00:57:01,960
そして、言ってZ-A-M-Y-L-A、6。

1159
00:57:01,960 --> 00:57:02,962
そして、それは6を返します。

1160
00:57:02,962 --> 00:57:04,920
あなたが呼び出す次回
ループのためにその内部にそれ、

1161
00:57:04,920 --> 00:57:08,610
Zamylaを見に起こっています
再び、Z-A-M-Y-L-A、6言います。

1162
00:57:08,610 --> 00:57:10,320
そして、6を返すために起こっています。

1163
00:57:10,320 --> 00:57:12,980
したがって、この設計についての愚かな何ですか？

1164
00:57:12,980 --> 00:57:17,700
>> なぜ私のコードではありません5つ星のうち5です
今のデザインのために、いわばするには？

1165
00:57:17,700 --> 00:57:20,600
まあ、私が求めています
不必要に質問。

1166
00:57:20,600 --> 00:57:23,030
私は私が必要以上の仕事をやっています。

1167
00:57:23,030 --> 00:57:25,370
>> だから、たとえ
答えは、私は、正しいです

1168
00:57:25,370 --> 00:57:29,560
コンピュータを求めて、何です
再びZamylaの長さは、

1169
00:57:29,560 --> 00:57:31,380
そして再び、そして再び、そして再び？

1170
00:57:31,380 --> 00:57:33,980
そして、その答えは
変更するつもりはありません。

1171
00:57:33,980 --> 00:57:35,900
常に6になるだろう。

1172
00:57:35,900 --> 00:57:39,730
>> これよりだから、よりよい解決策
この次のバージョンになります。

1173
00:57:39,730 --> 00:57:43,390
私は先に行ってみようと、それを置きます
string1.cと呼ばれる別のファイル、

1174
00:57:43,390 --> 00:57:44,990
ちょうどそれが別々に保管します。

1175
00:57:44,990 --> 00:57:47,260
そして、それはのために判明します
ループ、あなたが実際にすることができます

1176
00:57:47,260 --> 00:57:50,210
一度に複数の変数を宣言します。

1177
00:57:50,210 --> 00:57:53,460
>> だから私は、私を維持し、0に設定するつもりです。

1178
00:57:53,460 --> 00:57:56,190
しかし、私はまたに行きますよ
カンマを追加し、言います、

1179
00:57:56,190 --> 00:58:01,050
私のnという変数を与え、その
値は、sの文字列の長さに等しいです。

1180
00:58:01,050 --> 00:58:09,410
そして今、私の条件を行ってください
限りiがn未満であるように。

1181
00:58:09,410 --> 00:58:14,140
>> したがって、このように、論理は
一日の終わりに同一。

1182
00:58:14,140 --> 00:58:18,280
しかし、私は覚えています
この場合の値6、。

1183
00:58:18,280 --> 00:58:19,780
Zamylaの名前の長さは何ですか？

1184
00:58:19,780 --> 00:58:20,860
そして、私はn個でそれを入れています。

1185
00:58:20,860 --> 00:58:23,050
>> そして、私はまだチェックしています
条件たびに。

1186
00:58:23,050 --> 00:58:24,300
6 0より少ないですか？

1187
00:58:24,300 --> 00:58:25,600
6より1少ないですか？

1188
00:58:25,600 --> 00:58:28,600
等々6以上2以下であり、？

1189
00:58:28,600 --> 00:58:31,914
>> しかし、私はコンピュータを求めていませんよ
再び、そして再び、何

1190
00:58:31,914 --> 00:58:33,080
Zamylaの名前の長さは？

1191
00:58:33,080 --> 00:58:34,320
Zamylaの名前の長さは何ですか？

1192
00:58:34,320 --> 00:58:35,986
このZamylaの名前の長さは何ですか？

1193
00:58:35,986 --> 00:58:40,440
私は、文字通り、その最初を覚えることだし、
この第二の変数nにだけ答えます。

1194
00:58:40,440 --> 00:58:45,280
だから、これは今だけではなくなるだろう
正しいだけでなく、うまく設計されました。

1195
00:58:45,280 --> 00:58:46,670
>> さて、どのようなスタイルはどうですか？

1196
00:58:46,670 --> 00:58:48,866
私は私の変数を命名しました
かなりよく、私は言うでしょう。

1197
00:58:48,866 --> 00:58:50,240
彼らは今、超簡潔です。

1198
00:58:50,240 --> 00:58:52,090
そして、それは完全に罰金です。

1199
00:58:52,090 --> 00:58:55,120
>> あなたが1つしかない場合
プログラム内の文字列、

1200
00:58:55,120 --> 00:58:56,860
あなたにも、それが文字列の場合はsと呼ぶかもしれません。

1201
00:58:56,860 --> 00:58:59,370
あなたは、1つの変数だけを持っている場合
プログラムでカウントするための、

1202
00:58:59,370 --> 00:59:00,710
あなたにも私にそれを呼び出すことがあります。

1203
00:59:00,710 --> 00:59:03,500
あなたは長さを持っている場合は、n個
同様にスーパーが一般的です。

1204
00:59:03,500 --> 00:59:05,800
しかし、私は私のコードのいずれかをコメントしていません。

1205
00:59:05,800 --> 00:59:09,200
>> 私はreader--を知らされていなかっました
それは私のTF、またはTAのかどうか、

1206
00:59:09,200 --> 00:59:12,460
または単に想定される内容colleague--
このプログラムで起こっします。

1207
00:59:12,460 --> 00:59:15,760
それで良いスタイルを取得します、
私がしたいと思います

1208
00:59:15,760 --> 00:59:24,580
this--ものです
以下のような入力をユーザーに尋ねます。

1209
00:59:24,580 --> 00:59:26,670
そして、私は書き換えることができ
この任意の数の方法。

1210
00:59:26,670 --> 00:59:35,630
>> 得ることを確認-S-ことを確認してください
文字列は、文字列を返しました。

1211
00:59:35,630 --> 00:59:40,280
そしてhere--で、これはおそらくです
最も重要なcomment--反復

1212
00:59:40,280 --> 00:59:44,450
sの1の中の文字を超える時。

1213
00:59:44,450 --> 00:59:47,060
そして、私はいずれかを使用することができます
英語の選択

1214
00:59:47,060 --> 00:59:49,650
ここではそれぞれを記述するために
コー​​ドのこれらのチャンクの。

1215
00:59:49,650 --> 00:59:52,740
>> 私は入れていないことに注意してください
コー​​ドのすべての行にコメント、

1216
00:59:52,740 --> 00:59:55,690
本当にただ面白い上
もの、もの

1217
00:59:55,690 --> 00:59:59,460
いくつかの意味を持っている私がかもしれません
誰かに超明確にしたいです

1218
00:59:59,460 --> 01:00:00,460
私のコードを読んで。

1219
01:00:00,460 --> 01:00:02,920
そして、なぜあなたが得る呼んでいます
文字列は、入力をユーザーに尋ねますか？

1220
01:00:02,920 --> 01:00:05,450
でもその1は、必ずしもではありません
すべてのことの記述。

1221
01:00:05,450 --> 01:00:09,340
しかし、それは、話をすることができますので、
物語の中で2行目は、確認してくださいされ、

1222
01:00:09,340 --> 01:00:10,740
文字列は、文字列を返されます。

1223
01:00:10,740 --> 01:00:14,260
>> そして、物語の3行目は、
秒の1の中の文字を反復処理

1224
01:00:14,260 --> 01:00:15,380
一度に。

1225
01:00:15,380 --> 01:00:17,920
そして今、ちょうど良い対策のため、
私は先に行くと、追加するつもりです

1226
01:00:17,920 --> 01:00:24,560
そのちょうど1より多くのコメント
s内の印刷i番目の文字は述べています。

1227
01:00:24,560 --> 01:00:26,520
今、私が何をしました
一日の終わりに？

1228
01:00:26,520 --> 01:00:29,190
>> 私はいくつかの英語を追加しました
コメントの形で言葉。

1229
01:00:29,190 --> 01:00:32,700
スラッシュスラッシュ記号はちょっと、意味します、
コンピュータこれは、人間のためのものです、

1230
01:00:32,700 --> 01:00:33,820
ないあなたのために、コンピュータ。

1231
01:00:33,820 --> 01:00:35,119
そこで、彼らは論理的に無視しています。

1232
01:00:35,119 --> 01:00:35,910
彼らはただそこにいます。

1233
01:00:35,910 --> 01:00:39,830
>> そして、確かに、CS50 IDEは、それらを示しています
有用であるとして、グレー、しかしキーではありません

1234
01:00:39,830 --> 01:00:41,000
プログラムへ。

1235
01:00:41,000 --> 01:00:42,570
あなたは今何ができるか注目してください。

1236
01:00:42,570 --> 01:00:44,950
あなたがCを知っているかどうか
プログラミングやない、あなたが

1237
01:00:44,950 --> 01:00:47,722
ちょうどこの時に戻って立つことができます
プログラムは、コメントをすくい取ります。

1238
01:00:47,722 --> 01:00:50,180
確認して、入力のためにユーザーに依頼
文字列に文字列が返さ取得し、

1239
01:00:50,180 --> 01:00:53,009
sの中の文字を反復処理
一度に一つが、文字を印刷します

1240
01:00:53,009 --> 01:00:55,550
そうしない-S-のi番目の文字
でも、コードを見ています

1241
01:00:55,550 --> 01:00:57,270
このプログラムが何をするのか理解します。

1242
01:00:57,270 --> 01:01:00,280
そして、より良いまだ、自分で見てみると
週または2でこのプログラムでは、

1243
01:01:00,280 --> 01:01:02,280
または月、または年、
あなたも持っていません

1244
01:01:02,280 --> 01:01:04,420
コー​​ドを凝視するために、
思い出そうと、

1245
01:01:04,420 --> 01:01:06,630
どのような私は、このコードをどうしようとしていましたか？

1246
01:01:06,630 --> 01:01:07,770
>> あなたは自分自身を指示しました。

1247
01:01:07,770 --> 01:01:11,660
あなたは自分自身でそれを説明しましたが、
またはいくつかの同僚、もしくはTA、またはTF。

1248
01:01:11,660 --> 01:01:14,860
そして、これは今になります
正しい、と優れたデザイン、

1249
01:01:14,860 --> 01:01:18,210
そして最終的にスタイル良いとしても。

1250
01:01:18,210 --> 01:01:19,990
だから、心に留めておくん。

1251
01:01:19,990 --> 01:01:22,200
>> だから、他の1があります
事は私がここにするつもりです

1252
01:01:22,200 --> 01:01:28,240
それが今まさに何明らかにすることができます
ボンネットの下に起こっています。

1253
01:01:28,240 --> 01:01:30,390
だから、この機能があります
C、および他の言語で、

1254
01:01:30,390 --> 01:01:33,010
呼ばれる型キャスト
その暗黙

1255
01:01:33,010 --> 01:01:37,250
または明示的に変換することができます
別のデータ型から。

1256
01:01:37,250 --> 01:01:39,800
私たちはそのように扱ってきました
文字列とはるかに今日。

1257
01:01:39,800 --> 01:01:41,250
>> そして、文字列は文字です。

1258
01:01:41,250 --> 01:01:44,910
しかし、週からリコール
0、文字は何ですか？

1259
01:01:44,910 --> 01:01:49,334
文字だけで抽象化されています
numbers--小数の上に、

1260
01:01:49,334 --> 01:01:52,500
そして、小数は本当にただです
2進数の上に抽象化し、

1261
01:01:52,500 --> 01:01:53,720
我々はそれを定義したとおり。

1262
01:01:53,720 --> 01:01:55,540
>> だから、文字は数字です。

1263
01:01:55,540 --> 01:01:58,410
そして、数字は文字です、
ただ文脈に応じて。

1264
01:01:58,410 --> 01:02:01,250
そして、それは内部ことが判明します
コンピュータプログラムの、

1265
01:02:01,250 --> 01:02:06,830
あなたが見てみたい方法を指定することができます
そのプログラムの内部ビットで？

1266
01:02:06,830 --> 01:02:10,400
>> 私たちが持っていた0週からリコール
ちょうどこのコードであるアスキー、

1267
01:02:10,400 --> 01:02:11,620
数字へのマッピングの手紙。

1268
01:02:11,620 --> 01:02:13,660
そして、我々は資本Aが65である、と述べました。

1269
01:02:13,660 --> 01:02:15,860
資本Bは、等66である、と。

1270
01:02:15,860 --> 01:02:20,500
>> 予告、私たちは本質的に文字を持っています
ここでは一番上の行、Cはそれらを呼び出すことになるとして、

1271
01:02:20,500 --> 01:02:23,400
文字、その後
2行目のint型。

1272
01:02:23,400 --> 01:02:28,180
そして、それはあなたが変換することができ判明します
シームレス典型的には二つの間。

1273
01:02:28,180 --> 01:02:30,042
そして、私たちは何をしたい場合
この意図的に、我々

1274
01:02:30,042 --> 01:02:31,750
タックルしたい場合があります
このようなもの。

1275
01:02:31,750 --> 01:02:33,590
>> 私たちは、変換したい場合があります
下げるために大文字

1276
01:02:33,590 --> 01:02:35,330
場合、または大文字と小文字。

1277
01:02:35,330 --> 01:02:38,000
そして、それはそこのが判明します
ここでは、実際のパターン

1278
01:02:38,000 --> 01:02:39,900
私たちは一瞬で受け入れることができます。

1279
01:02:39,900 --> 01:02:44,120
しかし、それでは、で最初に見てみましょう
明示的にこれを行うの一例。

1280
01:02:44,120 --> 01:02:46,340
>> 私は、CS50のIDEに戻って行くつもりです。

1281
01:02:46,340 --> 01:02:50,640
私は作成するつもりです
アスキー0.c.と呼ばれるファイル

1282
01:02:50,640 --> 01:02:55,960
そして、私は先に行くと、私を追加するつもりです
上部の標準io.h、int型メインボイド

1283
01:02:55,960 --> 01:02:57,370
私の関数の上部にあります。

1284
01:02:57,370 --> 01:03:02,700
そして、私はするつもりです
私は等しいからforループfollowing--、

1285
01:03:02,700 --> 01:03:04,610
のは、65をしましょう​​。

1286
01:03:04,610 --> 01:03:10,460
>> そして、私はより少なくなるだろう
65、プラスアルファベットで26文字。

1287
01:03:10,460 --> 01:03:12,640
だから私は、コンピュータをもらおう
そこに私のために計算を行います。

1288
01:03:12,640 --> 01:03:15,100
そして、このループ内で、
どのような私は印刷するつもり？

1289
01:03:15,100 --> 01:03:19,230
>> ％cは、iがnバックスラッシュ％です。

1290
01:03:19,230 --> 01:03:21,290
そして今、私は2つの値をプラグインします。

1291
01:03:21,290 --> 01:03:24,530
私は一時的に質問を入れています
質問を招待しそこにマークします。

1292
01:03:24,530 --> 01:03:29,940
>> 私は、以降65から反復処理したいです
アルファベットの26文字のため、

1293
01:03:29,940 --> 01:03:35,190
各反復でプリントアウトすること
キャラクターの一体的な同等。

1294
01:03:35,190 --> 01:03:38,299
言い換えれば、私がしたいです
26の数字の印刷を反復処理

1295
01:03:38,299 --> 01:03:41,590
アスキー文字が何であるか、手紙、
そして、どのような対応する番号is--

1296
01:03:41,590 --> 01:03:44,650
本当にただの再作成
そのスライドからグラフ。

1297
01:03:44,650 --> 01:03:47,010
したがって、これらの疑問符が何をすべきですか？

1298
01:03:47,010 --> 01:03:51,760
>> まあ、それは第二のことが判明します
1は、単に変数iでなければなりません。

1299
01:03:51,760 --> 01:03:53,860
私は数としてそれを見てみたいです。

1300
01:03:53,860 --> 01:03:58,920
そして、中央の引数
ここでは、私はコンピュータを伝えることができます

1301
01:03:58,920 --> 01:04:03,470
その整数を治療します
私の文字として、ように

1302
01:04:03,470 --> 01:04:05,880
パーセントC.のためにここにそれを置換します

1303
01:04:05,880 --> 01:04:07,990
>> 換言すれば、Iの場合、
人間のプログラマー、知っています

1304
01:04:07,990 --> 01:04:09,865
これらは数字だけです
一日の終わりに。

1305
01:04:09,865 --> 01:04:12,500
そして、私は65がすべきことを知っています
いくつかの文字にマップします。

1306
01:04:12,500 --> 01:04:15,310
この明示的なキャストでは、
括弧と、

1307
01:04:15,310 --> 01:04:18,840
あなたがしたいデータ型の名前
変換し、閉じ括弧、

1308
01:04:18,840 --> 01:04:21,200
あなたが言うことができます
コンピュータ、ちょっと、コンピュータ、

1309
01:04:21,200 --> 01:04:24,130
この整数はchar型に変換します。

1310
01:04:24,130 --> 01:04:26,250
>> だから私はこれを実行すると、
コンパイル後のプログラム、

1311
01:04:26,250 --> 01:04:29,740
のは、私はアスキー0を作るget--かを見てみましょう。

1312
01:04:29,740 --> 01:04:33,020
それくそ、私が間違ってここで何をしましたか？

1313
01:04:33,020 --> 01:04:35,884
宣言されていない識別子の使用、
すべての権利、意図的な、

1314
01:04:35,884 --> 01:04:37,800
私たちができない場合を見てみましょう
このを通して理由。

1315
01:04:37,800 --> 01:04:41,220
>> だからラインはので、私は取得できませんでしたfive--
非常に遠くまでねじ込む前に。

1316
01:04:41,220 --> 01:04:42,140
それで大丈夫です。

1317
01:04:42,140 --> 01:04:46,560
だから私のためのライン5に等しい65--私が参照してください。

1318
01:04:46,560 --> 01:04:50,130
だから、いくつかのとは異なり、Cであることを覚えています
あなたは前にプログラミングを持っている場合の言語

1319
01:04:50,130 --> 01:04:52,190
経験、あなたが持っています
コンピュータを伝えるために、

1320
01:04:52,190 --> 01:04:55,040
スクラッチとは異なり、どのような
変数の型はそれがあります。

1321
01:04:55,040 --> 01:04:56,860
>> そして、私はここにキーフレーズを忘れてしまいました。

1322
01:04:56,860 --> 01:04:59,200
行5で、私は私の使用を開始しました。

1323
01:04:59,200 --> 01:05:01,560
しかし、私はCに語っていません
それはどのようなデータ型です。

1324
01:05:01,560 --> 01:05:04,570
だから私はここに行くつもりですし、
ああ、それは整数にする、と言います。

1325
01:05:04,570 --> 01:05:07,050
>> 今、私は先に行くと、再コンパイルするつもりです。

1326
01:05:07,050 --> 01:05:08,080
それはそれを修正しました。

1327
01:05:08,080 --> 01:05:12,660
入力./ascii0、それは一種のクールです。

1328
01:05:12,660 --> 01:05:15,360
だけでなく、それはに超高速であります
コンピュータにこの質問をし、

1329
01:05:15,360 --> 01:05:18,885
むしろスライド上にそれを見てより、
それは、Aは65で、1行に1つずつをプリントアウト

1330
01:05:18,885 --> 01:05:24,860
Bは、I以来down-- 66、すべての方法です
、手紙zにこの26 times--をしました

1331
01:05:24,860 --> 01:05:25,630
これは90です。

1332
01:05:25,630 --> 01:05:27,790
そして、実際には、わずかに
よりインテリジェントだろう

1333
01:05:27,790 --> 01:05:31,030
依存しない私のためにされています
コンピュータに26を追加します。

1334
01:05:31,030 --> 01:05:34,060
私は行っている可能性が
90だけでなく、あまりにも長い間

1335
01:05:34,060 --> 01:05:37,390
私は二度同じ過ちをしないように。

1336
01:05:37,390 --> 01:05:41,880
私が通って行きたいです
Zだけでなく、Y​​を介してアップ。

1337
01:05:41,880 --> 01:05:44,000
>> だから、明示的なキャストです。

1338
01:05:44,000 --> 01:05:47,860
これは、このことが判明します
さえ必要ありません。

1339
01:05:47,860 --> 01:05:52,480
私が先に行くと、これを再実行してみましょう
コンパイラ、および再実行アスキー0。

1340
01:05:52,480 --> 01:05:54,940
これは、Cはかなりスマートであることが判明しました。

1341
01:05:54,940 --> 01:05:57,150
>> そして、printf関数、特に、
かなりスマートです。

1342
01:05:57,150 --> 01:06:01,260
あなたは2回だけ私を渡した場合
両方のプレースホルダのため、printfの

1343
01:06:01,260 --> 01:06:04,510
よく私はあなたを知って、ああ、実現されます
私はいくつかの番号をinteger--与えました、

1344
01:06:04,510 --> 01:06:06,380
65、または90、または何のような。

1345
01:06:06,380 --> 01:06:10,170
しかし、私はあなたが私がしたいことを参照してください。
文字のようなその番号をフォーマットします。

1346
01:06:10,170 --> 01:06:16,460
そしてそうprintfの暗黙的にキャストすることができます
あなたのためのcharへのint型としても。

1347
01:06:16,460 --> 01:06:19,360
だから、まったく問題ありません。

1348
01:06:19,360 --> 01:06:23,100
>> しかし、このため同等の、気付きます
私たちは、実際には同様にこれを行うことができます。

1349
01:06:23,100 --> 01:06:26,520
私が先に行くと1を作ってみましょう
this--アスキー1.C.の他のバージョン

1350
01:06:26,520 --> 01:06:31,800
そして、の代わりに、繰り返し処理
整数は、本当にあなたの心を爆破することができます

1351
01:06:31,800 --> 01:06:33,610
文字を反復することもできます。

1352
01:06:33,610 --> 01:06:37,660
文字cが大文字のAを取得した場合、I
先に行くと、これをやってみたいです、

1353
01:06:37,660 --> 01:06:41,740
あれば、Cは以下のように
資本Zにし、反復のたびに

1354
01:06:41,740 --> 01:06:45,690
私は私ができる、Cをインクリメントしたいです
今ここに私のprintfのラインで

1355
01:06:45,690 --> 01:06:51,320
％のCである、と言います
パーセント私は再び、コンマC.

1356
01:06:51,320 --> 01:06:57,200
>> そして今、私は他の方向に行くことができ、
明示的に文字をキャスト

1357
01:06:57,200 --> 01:06:58,500
整数に。

1358
01:06:58,500 --> 01:07:00,560
だから、もう一度、なぜあなたがこれを行うのでしょうか？

1359
01:07:00,560 --> 01:07:03,830
それは一種のには少し奇妙なことです
文字単位でカウントされます。

1360
01:07:03,830 --> 01:07:07,430
>> しかし、あなたが何を理解していれば
ボンネットの下に起こって、

1361
01:07:07,430 --> 01:07:08,430
魔法は本当にありません。

1362
01:07:08,430 --> 01:07:13,060
あなただけのちょっと、コンピュータが与える、と言っています
私char型のCと呼ばれる変数。

1363
01:07:13,060 --> 01:07:16,520
資本Aにそれを初期化し、
単一引用符の問題に気づきます。

1364
01:07:16,520 --> 01:07:19,580
>> Cの文字については、からリコール
先週は、一重引用符を使用します。

1365
01:07:19,580 --> 01:07:23,720
文字列の場合、言葉に、
フレーズは、二重引用符を使用します。

1366
01:07:23,720 --> 01:07:27,210
[OK]を、コンピュータ、これをやり続けるので、
文字の長未満であります

1367
01:07:27,210 --> 01:07:28,050
またはzに等しいです。

1368
01:07:28,050 --> 01:07:32,640
そして、私はそのすべての私のアスキーテーブルから知っています
これらのASCIIコードの連続しています。

1369
01:07:32,640 --> 01:07:33,400
>> ギャップはありません。

1370
01:07:33,400 --> 01:07:36,737
だから、ちょうどZまでです
1番号ごとで区切られています。

1371
01:07:36,737 --> 01:07:38,820
そして、私は増加することができます
char型、私が本当にしたい場合。

1372
01:07:38,820 --> 01:07:40,390
一日の終わりに、
それだけの数です。

1373
01:07:40,390 --> 01:07:41,030
私はこれを知っている。

1374
01:07:41,030 --> 01:07:43,670
だから、僕はそれに1を追加するために推定することができます。

1375
01:07:43,670 --> 01:07:46,940
>> そしてこの時、私は、cを印刷し、
そしてその後、積分等価。

1376
01:07:46,940 --> 01:07:50,170
そして、私も明示的なキャストを必要としません。

1377
01:07:50,170 --> 01:07:52,680
私はprintfのとさせることができます
コンピュータフィギュア物事うち、

1378
01:07:52,680 --> 01:07:57,300
その結果、今、私は実行する場合
Ascii1./ascii1を行い、

1379
01:07:57,300 --> 01:08:01,520
私もまったく同じことを得ます。

1380
01:08:01,520 --> 01:08:04,530
>> 無駄なプログラムは、誰もthough--ありません
実際にソフトウェアを書くことが起こっています

1381
01:08:04,530 --> 01:08:07,549
把握するためには、何でした
A、またはB、またはZにマップ数？

1382
01:08:07,549 --> 01:08:10,340
あなたはそれをGoogleに行く、またはしています
オンラインそれを見て、またはそれをルックアップ

1383
01:08:10,340 --> 01:08:11,650
スライド、等に。

1384
01:08:11,650 --> 01:08:13,520
そこでここでは、これは実際に有用な取得のでしょうか？

1385
01:08:13,520 --> 01:08:15,960
>> まあ、そのことを話します
スライド、があります注意してください

1386
01:08:15,960 --> 01:08:20,890
大文字の間、ここで実際のパターン
偶発的ではなかった小文字。

1387
01:08:20,890 --> 01:08:23,760
大文字のAが65であることに注意してください。

1388
01:08:23,760 --> 01:08:25,830
小文字aは97です。

1389
01:08:25,830 --> 01:08:29,649
そして、どのように遠くに小文字のですか？

1390
01:08:29,649 --> 01:08:32,649
>> だから65は、どのように多くの手順離れて97からでしょうか？

1391
01:08:32,649 --> 01:08:36,210
だから、97のマイナス65は32です。

1392
01:08:36,210 --> 01:08:37,910
だから、資本aは65です。

1393
01:08:37,910 --> 01:08:39,939
あなたはそれに32を追加した場合、
あなたは小文字得ます。

1394
01:08:39,939 --> 01:08:43,729
そして、等価的に、あなたは32を引く場合、
あなたが首都に戻っA-- Bと同じ

1395
01:08:43,729 --> 01:08:46,380
少しCにはほとんどBへ、ビッグC。

1396
01:08:46,380 --> 01:08:50,670
>> これらのギャップのすべてが離れて32です。

1397
01:08:50,670 --> 01:08:54,450
さて、これは私たちがすることを可能にするように思われます
Microsoft Wordのような何かを、

1398
01:08:54,450 --> 01:08:57,729
またはGoogleドキュメント機能、あなた
すべてを選択し、言うことができ、

1399
01:08:57,729 --> 01:09:00,520
小文字にすべてを変更、または
大文字にすべてを変更、

1400
01:09:00,520 --> 01:09:03,840
または最初の単語だけを変更
大文字に文の。

1401
01:09:03,840 --> 01:09:07,390
私たちは、実際に何かを行うことができます
自分自身そのような。

1402
01:09:07,390 --> 01:09:12,645
>> 私が先に行くと、ファイルを保存してみましょう
ここ0.c.を大文字と呼ばれます

1403
01:09:12,645 --> 01:09:15,770
とのは、先に行くと、プログラムをかき立てるてみましょう
それは、まったく同じように、以下のことを行います。

1404
01:09:15,770 --> 01:09:18,460
だからCS50ライブラリが含まれています。

1405
01:09:18,460 --> 01:09:21,430
標準I / Oが含まれます。

1406
01:09:21,430 --> 01:09:22,787
>> そして、私はこれがすぐに来ている知っています。

1407
01:09:22,787 --> 01:09:24,870
だから私はそれを置くつもりです
そこにすでに、string.hの、

1408
01:09:24,870 --> 01:09:26,960
私はへのアクセス権を持っています
スターリングのようなもの、

1409
01:09:26,960 --> 01:09:29,620
そしてその後、いつものように、メインの空隙をint型。

1410
01:09:29,620 --> 01:09:33,420
そして、私は先に行くつもりです
そして、文字列操作を行うと、文字列を取得します、

1411
01:09:33,420 --> 01:09:35,032
ただ、ユーザーから文字列を取得します。

1412
01:09:35,032 --> 01:09:36,740
そして、私はするつもりです
私の健全性チェックを行います。

1413
01:09:36,740 --> 01:09:40,510
文字列が等しいnullでない場合は、
それは続行しても安全です。

1414
01:09:40,510 --> 01:09:42,000
そして、私は何をしたいですか？

1415
01:09:42,000 --> 01:09:48,700
私は、私が0に等しいから反復するつもりです
そしてn秒の文字列の長さまで。

1416
01:09:48,700 --> 01:09:51,899
>> そして、私は限りこれを行うつもりです
私はプラスプラスnよりも小さい、と。

1417
01:09:51,899 --> 01:09:55,060
これまでのところ、私は本当によ
以前からアイデアを借りて。

1418
01:09:55,060 --> 01:09:57,010
そして今、私はブランチを紹介するつもりです。

1419
01:09:57,010 --> 01:09:59,635
>> だから、スクラッチ、に戻って考えます
私たちは、道路のそれらのフォークを持っていました

1420
01:09:59,635 --> 01:10:05,110
そして先週はCで、私はするつもりです
s内のi番目の文字場合は、これを言います

1421
01:10:05,110 --> 01:10:09,250
以上であります
小文字に等しく、

1422
01:10:09,250 --> 01:10:13,340
and--スクラッチでは、文字通りだろう
言うと、しかし、C言語で、あなたはアンパサンドを言います、

1423
01:10:13,340 --> 01:10:19,830
ampersand--とsのi番目の文字
未満または小文字zに等しく、

1424
01:10:19,830 --> 01:10:21,780
のは、何か面白いことをしましょう​​。

1425
01:10:21,780 --> 01:10:27,020
それでは、実際にプリントアウトしてみましょう
改行なしの文字

1426
01:10:27,020 --> 01:10:31,760
それは、文字列内の文字で、
文字列内のi番目の文字。

1427
01:10:31,760 --> 01:10:37,420
>> しかし、ここでは先に行くとしましょう
それから32を引きます。

1428
01:10:37,420 --> 01:10:42,120
そうであればの文字
我々が探している文字列

1429
01:10:42,120 --> 01:10:45,950
少しAの間ではありません
少しzの、先に行きます

1430
01:10:45,950 --> 01:10:48,610
ちょうど変わらず、それをプリントアウト。

1431
01:10:48,610 --> 01:10:50,840
そこで、導入しました
この角カッコ

1432
01:10:50,840 --> 01:10:53,560
私たちの文字列がで取得するために
i番目の文字列内の文字。

1433
01:10:53,560 --> 01:10:57,520
>> 私のような、いくつかの条件付きロジックを追加しました
先週の週の1つにスクラッチ

1434
01:10:57,520 --> 01:10:59,880
私はちょうど私の基本を使用しています
何の理解

1435
01:10:59,880 --> 01:11:01,130
ボンネットの下に起こっています。

1436
01:11:01,130 --> 01:11:04,190
Sのi番目の文字があります
以上？

1437
01:11:04,190 --> 01:11:08,290
同様に、それは、97、または98であり、
または99など？

1438
01:11:08,290 --> 01:11:11,940
>> それはまた、以下で
小文字のzの値に？

1439
01:11:11,940 --> 01:11:16,210
そうであれば、この行が何を意味するのでしょうか？

1440
01:11:16,210 --> 01:11:20,250
図14に示すように、これはの一種であります
全体的なアイデアの胚芽、

1441
01:11:20,250 --> 01:11:23,840
によって文字を大文字
単に、それから32を差し引きます

1442
01:11:23,840 --> 01:11:29,370
この場合、私が知っているので、そのあたり
私の番号がどのように表現されるか、チャート、。

1443
01:11:29,370 --> 01:11:33,925
それでは、先に行くと、これを実行してみましょう、
0.cを大文字にコンパイルした後、

1444
01:11:33,925 --> 01:11:36,210
そして、0を大文字に実行します。

1445
01:11:36,210 --> 01:11:40,300
>> 以下のようなものを入力してみましょう
すべて小文字でZamylaを入力します。

1446
01:11:40,300 --> 01:11:42,780
そして今、我々はすべて大文字でZamylaを持っています。

1447
01:11:42,780 --> 01:11:45,050
のは、すべて小文字でロブを入力してみましょう。

1448
01:11:45,050 --> 01:11:46,674
のは、すべて小文字でジェイソンを試してみましょう。

1449
01:11:46,674 --> 01:11:48,590
そして、我々は入れません
大文字を余儀なくされました。

1450
01:11:48,590 --> 01:11:50,960
その私のマイナーなバグがあります
種類の予想していませんでした。

1451
01:11:50,960 --> 01:11:54,050
私の新しいプロンプトが終わるされることに注意してください
自分の名前と同じ行に、

1452
01:11:54,050 --> 01:11:55,520
これは少し厄介に感じています。

1453
01:11:55,520 --> 01:11:59,170
>> だから私はここに行くつもりだ、と
実際にこのプログラムの終わりに

1454
01:11:59,170 --> 01:12:02,110
改行文字をプリントアウトします。

1455
01:12:02,110 --> 01:12:03,160
それで全部です。

1456
01:12:03,160 --> 01:12:06,120
printf関数を使用すると、する必要はありません
変数または書式コードに渡します。

1457
01:12:06,120 --> 01:12:08,460
あなたは文字通り印刷することができます
改行のようなもの。

1458
01:12:08,460 --> 01:12:13,529
>> それでは、先に行くと作ってみましょう
再び0を大文字に、それを再実行し、Zamyla。

1459
01:12:13,529 --> 01:12:14,820
そして今、それは少しきれいです。

1460
01:12:14,820 --> 01:12:17,274
さて、私のプロンプトは、独自の新しい行にあります。

1461
01:12:17,274 --> 01:12:18,440
だから、すべての罰金と良いです。

1462
01:12:18,440 --> 01:12:19,910
だから、良い例です。

1463
01:12:19,910 --> 01:12:22,700
しかし、私も必ずしもありません
ハードコード32にする必要があります。

1464
01:12:22,700 --> 01:12:23,350
あのね？

1465
01:12:23,350 --> 01:12:26,350
私は私が今までにないsay--でした
違いが何であるかを覚えています。

1466
01:12:26,350 --> 01:12:29,330
>> しかし、私は、私の場合ことを知っています
小文字を持って、

1467
01:12:29,330 --> 01:12:34,430
私は基本的にオフに減算したいです
距離は少しの間にあるものは何でも

1468
01:12:34,430 --> 01:12:39,160
大きなA、私は仮定した場合、その理由
他のすべての文字が同じです、

1469
01:12:39,160 --> 01:12:41,045
それは仕事を得る必要があります。

1470
01:12:41,045 --> 01:12:42,670
しかし、それを行うのではなく、あなたは何を知っていますか？

1471
01:12:42,670 --> 01:12:44,240
さらに別の方法があります。

1472
01:12:44,240 --> 01:12:48,090
>> それは私がいた場合1.c--を生かすなら
別のファイルにそれを置くために。

1473
01:12:48,090 --> 01:12:51,030
それでは、次のように2.Cを大文字にしましょう​​。

1474
01:12:51,030 --> 01:12:53,060
私は本当にここにこれをクリーンアップするつもりです。

1475
01:12:53,060 --> 01:12:57,420
その代わりにさえしたの
知っているか、またはそれらの低レベルを気に

1476
01:12:57,420 --> 01:13:01,090
実装の詳細は、私の代わりによ
ただ文字を印刷しようとして、

1477
01:13:01,090 --> 01:13:04,610
引用引用終わり、パーセントのC、および
その後、別の関数を呼び出すこと

1478
01:13:04,610 --> 01:13:09,950
それは引数を取る存在し、
これは、このように、文字です。

1479
01:13:09,950 --> 01:13:12,630
>> それはそこにあります、Cで判明します
別の関数の呼び出し

1480
01:13:12,630 --> 01:13:15,550
上部に、どのその名の通り
示唆している文字を取ります

1481
01:13:15,550 --> 01:13:19,350
その大文字にします
同等、それを返します。

1482
01:13:19,350 --> 01:13:21,410
その結果、printf関数はそこにそれをプラグインすることができます。

1483
01:13:21,410 --> 01:13:25,484
そして私は、しかし、これを行うには
1他のファイルを導入する必要があります。

1484
01:13:25,484 --> 01:13:28,400
これは、別のファイルがあると判明します
あなたが唯一のクラスから知っているだろうと、

1485
01:13:28,400 --> 01:13:33,020
または教科書、またはオンライン
C type.h.と呼ばれる基準、

1486
01:13:33,020 --> 01:13:38,570
>> だから私は、私のヘッダの中でそれをアップ追加した場合
ファイルは、今再コンパイルこのプログラムは、

1487
01:13:38,570 --> 01:13:43,040
capitalize2は、入力します./capitalize2。

1488
01:13:43,040 --> 01:13:46,690
のはすべてでZamylaを入力してみましょう
小文字は、まだ同じように動作します。

1489
01:13:46,690 --> 01:13:48,040
しかし、あなたは何を知っていますか？

1490
01:13:48,040 --> 01:13:55,590
それは、上部にそれを判明します
他のいくつかの機能を備えています。

1491
01:13:55,590 --> 01:13:58,410
>> そして、私はこれを紹介しましょう
ここでは、コマンド、ソートのぎこちなく

1492
01:13:58,410 --> 01:14:00,250
名前が、マニュアルのマニュアル。

1493
01:14:00,250 --> 01:14:03,960
それは、そのほとんどのLinuxコンピュータが判明します
我々は、Linuxオペレーティングをhere--使用しているとして、

1494
01:14:03,960 --> 01:14:06,270
コマンドを持っていますsystem--
呼ばれる男、と言い、

1495
01:14:06,270 --> 01:14:08,530
ちょっと、コンピュータ、私を与えます
コンピュータのマニュアル。

1496
01:14:08,530 --> 01:14:10,680
あなたがする何をしたいですか
そのマニュアルにルックアップ？

1497
01:14:10,680 --> 01:14:13,840
>> 私は、機能を見てみたいです
上部に呼ばれ、入力します。

1498
01:14:13,840 --> 01:14:16,070
そして、それは少し不可解です
時々読み取ります。

1499
01:14:16,070 --> 01:14:18,780
しかし、私たちがしているに気付きます
Linuxのプログラマのマニュアル。

1500
01:14:18,780 --> 01:14:19,530
そして、それはすべてのテキストです。

1501
01:14:19,530 --> 01:14:21,905
そして、そこだと気付きます
ここで機能アップの名前。

1502
01:14:21,905 --> 01:14:25,030
それが呼ばれるのいとこを持ってい判明します
反対の動作をしている、低下させます。

1503
01:14:25,030 --> 01:14:29,710
そして、これを使用するには、概要の下に気付きます
manページを機能する、いわば、

1504
01:14:29,710 --> 01:14:32,220
私はことを私に語っています
type.h. cを含める必要があります

1505
01:14:32,220 --> 01:14:33,630
そして、私は練習からのことを知っていました。

1506
01:14:33,630 --> 01:14:36,210
>> ここでは、それは私に2を見せています
関数のプロトタイプ、

1507
01:14:36,210 --> 01:14:39,070
そのため、私は今まで、これを使用したい場合
私は、彼らが入力として取るか知っています、

1508
01:14:39,070 --> 01:14:40,652
彼らは出力として返すもの。

1509
01:14:40,652 --> 01:14:42,360
そして、私が読んだ場合
説明、私が参照してください。

1510
01:14:42,360 --> 01:14:44,820
関数が何をするかをより詳細に示します。

1511
01:14:44,820 --> 01:14:48,100
しかし、もっと重要なのは、もし
私は、戻り値の下に見えます

1512
01:14:48,100 --> 01:14:51,710
それは、戻り値があると言います
変換された文字のこと、

1513
01:14:51,710 --> 01:14:57,880
またはC、元の入力、場合
変換は不可能でした。

1514
01:14:57,880 --> 01:15:01,992
>> 言い換えれば、上位にしようとします
大文字に文字を変換します。

1515
01:15:01,992 --> 01:15:03,450
そうであれば、それを返すために起こっています。

1516
01:15:03,450 --> 01:15:07,010
しかし、それはいくつかのreason--ためにすることができない場合
多分それは既に大文字です、

1517
01:15:07,010 --> 01:15:09,550
多分それは感嘆符です
またはいくつかの他のpunctuation--

1518
01:15:09,550 --> 01:15:12,200
それだけに起こっています
元のCを返し、

1519
01:15:12,200 --> 01:15:17,340
私は私のコードを作ることができることを意味します
より良い次のように設計されています。

1520
01:15:17,340 --> 01:15:20,580
>> 私はすべてを必要としません
コー​​ドのこれらのくそライン。

1521
01:15:20,580 --> 01:15:22,610
私はしましたラインのすべて
ちょうど強調表示することができます

1522
01:15:22,610 --> 01:15:28,700
ただ1つの単純に崩壊します
this-- printfの％であるライン、

1523
01:15:28,700 --> 01:15:33,510
アッパーSブラケットにC iが。

1524
01:15:33,510 --> 01:15:36,090
そして、これは次のようになります
より良い設計の例。

1525
01:15:36,090 --> 01:15:40,040
>> なぜ7または8行で実装
コー​​ドの、何でもそれはちょうど私でした

1526
01:15:40,040 --> 01:15:44,960
あなたが代わりに折りたたむことができたときに、削除
そのロジックのすべてと意思決定

1527
01:15:44,960 --> 01:15:49,620
一つのラインに、13今、その
ライブラリに依存していますfunction--

1528
01:15:49,620 --> 01:15:53,430
Cに付属している機能が、その
あなたはそれが何をしたいのかを正確に行います。

1529
01:15:53,430 --> 01:15:55,295
そして、率直に言って、たとえ
それは、Cが付属していません、

1530
01:15:55,295 --> 01:15:58,880
あなたが通り、それを自分で実装することができ
我々は負のintを取得すると、見てきました

1531
01:15:58,880 --> 01:16:01,700
そして、同様に正の整数先週得ます。

1532
01:16:01,700 --> 01:16:03,470
>> このコードは今より読みやすくなります。

1533
01:16:03,470 --> 01:16:06,670
そして、確かに、私たちは上にスクロールすると、
どのくらいのよりコンパクトに見えます

1534
01:16:06,670 --> 01:16:08,360
私のプログラムのこのバージョンです。

1535
01:16:08,360 --> 01:16:11,230
それは、今少しトップヘビーです
で、これらすべてが含まれています。

1536
01:16:11,230 --> 01:16:14,380
今私が立っているので、しかし、それは、OKです
プログラマーの肩の上に

1537
01:16:14,380 --> 01:16:15,300
私の前に。

1538
01:16:15,300 --> 01:16:18,440
そして、それは誰でも誰でした
本当に上部に実装

1539
01:16:18,440 --> 01:16:21,470
多くの人は誰でも同じように、私に好意をやりました
本当にスターリングを実装

1540
01:16:21,470 --> 01:16:24,790
いくつかの時間前に私に好意をしました。

1541
01:16:24,790 --> 01:16:26,970
そして今、我々は持っています
より良い設計プログラム

1542
01:16:26,970 --> 01:16:31,680
それはまったく同じロジックを実装しています。

1543
01:16:31,680 --> 01:16:35,580
>> スターリングといえば、聞かせ
私は先に行くとこれを行います。

1544
01:16:35,580 --> 01:16:38,320
私が先に行くと、保存してみましょう
stirling.cとしてこのファイル。

1545
01:16:38,320 --> 01:16:43,255
そして、それは結局のところ、我々は戻って皮をむくことができます
かなり簡単になりました1他の層。

1546
01:16:43,255 --> 01:16:45,630
私は先と鞭行くつもりです
メイン内の別のプログラムアップ

1547
01:16:45,630 --> 01:16:49,759
ここではその単純再実装
文字列の長さ以下のように。

1548
01:16:49,759 --> 01:16:52,300
だからここのコードの行は、ということです
私は、ユーザから文字列を取得します。

1549
01:16:52,300 --> 01:16:53,910
私たちは何度も何度もこれを使用し続けます。

1550
01:16:53,910 --> 01:16:58,900
私は自分自身と呼ばれる変数を挙げてみましょう
番号を格納するint型のn個。

1551
01:16:58,900 --> 01:17:02,490
>> そして、私が先に行くとしましょう
次のロジックを実行します。

1552
01:17:02,490 --> 01:17:15,610
s内のn番目の文字がしますが
等しくないバックスラッシュ0、先に行きます

1553
01:17:15,610 --> 01:17:17,930
そしてnをインクリメントします。

1554
01:17:17,930 --> 01:17:23,506
そして私は、n printfのパーセントをプリントアウト。

1555
01:17:23,506 --> 01:17:29,200
私はここで、このプログラムと主張し、
文字列の長さを呼び出さずに、

1556
01:17:29,200 --> 01:17:31,150
文字列の長さを割り出し。

1557
01:17:31,150 --> 01:17:34,600
>> そして、魔法は完全です
8行目にカプセル化

1558
01:17:34,600 --> 01:17:39,830
ここでは、新しい構文のように見えるもので、
一重引用符で、このバックスラッシュ0。

1559
01:17:39,830 --> 01:17:41,360
しかし、なぜそのようになるのですか？

1560
01:17:41,360 --> 01:17:44,100
まあ、されているものを検討
すべてのこの時間に行きます。

1561
01:17:44,100 --> 01:17:47,990
>> 私は忘れる前に、脇やなど、実現
あまりにも、そのmanページに加えて、

1562
01:17:47,990 --> 01:17:50,920
それは、典型的に来ます
CS50 IDEのようなLinuxシステム、

1563
01:17:50,920 --> 01:17:53,770
実感して私たちは、
もちろんのスタッフ、また持っています

1564
01:17:53,770 --> 01:17:56,030
ウェブサイトのバージョンを作りました
呼ばれるこの同じ考えの

1565
01:17:56,030 --> 01:17:59,940
持ってreference.cs50.net、
それらの同じmanページのすべて、

1566
01:17:59,940 --> 01:18:02,020
その同じのすべて
ドキュメントだけでなく、

1567
01:18:02,020 --> 01:18:05,730
ことができます上部にある小箱
あなたはかなりのすべてを変換します

1568
01:18:05,730 --> 01:18:09,025
あまり快適に難解な言語
モード、我々、教員、

1569
01:18:09,025 --> 01:18:12,150
経および簡素化しようとしています
物事を保つために、言語の一部

1570
01:18:12,150 --> 01:18:14,830
アイデアに焦点を当てた、とされません
専門的の一部。

1571
01:18:14,830 --> 01:18:20,070
だから、心に留めておく、reference.cs50.net
別のリソースとしてだけでなく。

1572
01:18:20,070 --> 01:18:23,800
>> しかし、なぜ文字列の長さはで動作しません
私は前の瞬間を提案した方法はありますか？

1573
01:18:23,800 --> 01:18:25,160
ここZamylaの名前が再びです。

1574
01:18:25,160 --> 01:18:27,690
そして、ここでZamylaの名前です
私がやり続けるよう、で箱入り、

1575
01:18:27,690 --> 01:18:31,360
それがあることの絵を描くために、
本当に、文字だけのシーケンス。

1576
01:18:31,360 --> 01:18:34,260
しかしZamylaは存在しません。
プログラムで分離インチ

1577
01:18:34,260 --> 01:18:37,420
>> あなたが書いたプログラムを実行すると、
あなたがお使いのMacまたはPCを使用しています

1578
01:18:37,420 --> 01:18:40,010
メモリ、またはRAMとしていわば。

1579
01:18:40,010 --> 01:18:42,620
そして、あなたが考えることができます
持つものとして、コンピュータ

1580
01:18:42,620 --> 01:18:44,730
メモリのギガバイトの多く、これらの日。

1581
01:18:44,730 --> 01:18:47,700
そしてギグは十億を意味し、
バイトのように数十億。

1582
01:18:47,700 --> 01:18:48,910
>> しかし、それでは、時間に巻き戻してみましょう。

1583
01:18:48,910 --> 01:18:51,530
そして、私たちが使用していると仮定
本当に古いコンピュータこと

1584
01:18:51,530 --> 01:18:55,150
専用メモ​​リの32バイトを持っています。

1585
01:18:55,150 --> 01:18:59,310
私できた、私のコンピュータの画面上で、
次のように単純にこれを引き出します。

1586
01:18:59,310 --> 01:19:05,240
>> 私は単に私のことを言うことができます
コンピュータは、このメモリのすべてを持っています。

1587
01:19:05,240 --> 01:19:08,830
そして、これがあれば、メモリスティックのようなものです
あなたは最後の時間から私たちの絵を思い出します。

1588
01:19:08,830 --> 01:19:11,670
そして、私はちょうど分割した場合
この十分な回数で、

1589
01:19:11,670 --> 01:19:15,040
私は32バイトを持っていると主張しています
画面上のメモリ。

1590
01:19:15,040 --> 01:19:18,239
>> さて、実際には、私ができる唯一の
ここでは、この画面上でこれまでに描画します。

1591
01:19:18,239 --> 01:19:20,280
だから私は、先に行くつもりです
ちょうど慣例により、

1592
01:19:20,280 --> 01:19:24,050
私のコンピュータのメモリを描きます
グリッドだけではなく、一直線として。

1593
01:19:24,050 --> 01:19:28,190
具体的には、私は今と主張しています
このグリッドは、この8×4のグリッド、

1594
01:19:28,190 --> 01:19:31,800
ただ、すべての32バイトを表し、
私のMacで利用可能なメモリの、

1595
01:19:31,800 --> 01:19:33,030
または自分のPCで利用できます。

1596
01:19:33,030 --> 01:19:34,780
そして、彼らはラップしています
上の2行だけ

1597
01:19:34,780 --> 01:19:38,030
それは、画面上よりフィットするので。

1598
01:19:38,030 --> 01:19:40,800
しかし、これは最初のバイトです。

1599
01:19:40,800 --> 01:19:41,990
これが第二のバイトです。

1600
01:19:41,990 --> 01:19:43,300
これは、第3バイトです。

1601
01:19:43,300 --> 01:19:45,310
>> そして、これは第32バイトです。

1602
01:19:45,310 --> 01:19:52,910
または、我々はコンピュータのように思われる場合
科学者は、これは、バイト0、1、2、3、31です。

1603
01:19:52,910 --> 01:19:55,950
だから場合は、0〜31を持っています
あなたは、0からカウントを開始します。

1604
01:19:55,950 --> 01:19:59,830
>> だから我々はプログラムを使用する場合
呼び出しは、文字列を取得すること、

1605
01:19:59,830 --> 01:20:05,280
私たちは、人間から文字列を取得します
私はZamyla、Z-A-M-Y-L-Aと呼ばなかったような、

1606
01:20:05,280 --> 01:20:09,430
どのように世界ではありません
コンピュータは、どのバイトを追跡し、

1607
01:20:09,430 --> 01:20:12,230
メモリのどのチャンク、
これは文字列に属していますか？

1608
01:20:12,230 --> 01:20:16,270
言い換えれば、我々はに進む場合
コンピュータに別の名前を入力し、

1609
01:20:16,270 --> 01:20:19,890
このアンディのように、呼び出し
文字列二度目を取得し、

1610
01:20:19,890 --> 01:20:23,030
-N-D-Iは、で終わる必要があります
コンピュータのメモリも同様に。

1611
01:20:23,030 --> 01:20:23,850
しかし、どのように？

1612
01:20:23,850 --> 01:20:29,700
>> まあ、それは下にいることが判明します
フード、どのようなCは、文字列を格納しない場合

1613
01:20:29,700 --> 01:20:35,080
人間のタイプで、またはそのこと
それは、いくつかの他のソースから来て

1614
01:20:35,080 --> 01:20:39,190
それらの端部との輪郭を描きます
特別character--バックスラッシュ

1615
01:20:39,190 --> 01:20:44,750
ただ特別な方法である0、
行の80ビットを言って。

1616
01:20:44,750 --> 01:20:47,950
>> だからA--これは数97リコールです。

1617
01:20:47,950 --> 01:20:51,770
8ビットのため、一部のパターン
進数97を表します。

1618
01:20:51,770 --> 01:20:58,070
このバックスラッシュ0は、文字通り数です
0、別名ヌル、N-U-L、以前とは違って、

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L、我々はについて話しました。

1620
01:20:59,630 --> 01:21:05,700
しかし今のところ、ちょうどこのことを知っています
バックスラッシュ0は、行でちょうど80ビットです。

1621
01:21:05,700 --> 01:21:09,810
>> そして、それはでちょうどこのラインです
左側には、何も言う砂

1622
01:21:09,810 --> 01:21:12,610
1つの文字列、または1つのデータ・タイプに属します。

1623
01:21:12,610 --> 01:21:15,480
そして、何も右に
何か他のものに属します。

1624
01:21:15,480 --> 01:21:17,440
アンディの名前、一方、
これは単に視覚的に

1625
01:21:17,440 --> 01:21:21,310
他のラインへ折り返すことを起こります、
それは、ちょうど審美的なディテールです

1626
01:21:21,310 --> 01:21:23,990
同様にNULが終了されます。

1627
01:21:23,990 --> 01:21:29,290
>> これは、A-N-D-Iの文字の文字列です
プラス五秘密の文字、

1628
01:21:29,290 --> 01:21:33,560
ただ画定全て0ビット、
アンディの名前の末尾にも。

1629
01:21:33,560 --> 01:21:37,120
そして、我々が呼び出した場合、文字列3回目を取得
コンピュータ内のような文字列を取得します

1630
01:21:37,120 --> 01:21:44,210
マリア、M-A-R-I-Aは、同様にマリアのです
名前NULは、バックスラッシュ0で終了します。

1631
01:21:44,210 --> 01:21:47,170
>> これは根本的に異なっています
どのようにコンピュータが通常とから

1632
01:21:47,170 --> 01:21:51,850
整数、または浮動小数点数、または他の格納
まだデータ型、リコールので、

1633
01:21:51,850 --> 01:21:57,420
整数は、通常、32ビットであり、または
4バイト、または多分64ビット、

1634
01:21:57,420 --> 01:21:59,100
または8バイト。

1635
01:21:59,100 --> 01:22:02,620
しかし、コンピュータの多くのプリミティブ
プログラミング言語の

1636
01:22:02,620 --> 01:22:05,550
固定数を有します
hood--の下にバイト

1637
01:22:05,550 --> 01:22:08,100
多分1、多分2、多分4、多分8。

1638
01:22:08,100 --> 01:22:13,250
>> しかし、文字列は、設計によって、持っています
文字の動的な数。

1639
01:22:13,250 --> 01:22:16,980
あなたがされるまで、事前に知っていません
Z-A-M-Y-L-Aでのヒト型、

1640
01:22:16,980 --> 01:22:21,400
またはM-A-R-I-A、またはA-N-D-I。あなたは知りません
何回ユーザーがヒットしようとしています

1641
01:22:21,400 --> 01:22:22,070
キーボード。

1642
01:22:22,070 --> 01:22:26,490
したがって、あなたが方法がわかりません
事前に多くの文字

1643
01:22:26,490 --> 01:22:27,540
あなたが必要になるだろう。

1644
01:22:27,540 --> 01:22:31,840
>> だからCはちょうど一種のように葉
フードの下に秘密のブレッドクラム

1645
01:22:31,840 --> 01:22:32,960
文字列の末尾に。

1646
01:22:32,960 --> 01:22:39,280
メモリ内のZ-A-M-Y-L-Aを格納した後、
それはまた、単に同等のものを置きます

1647
01:22:39,280 --> 01:22:40,210
期間の。

1648
01:22:40,210 --> 01:22:45,060
文の終わりに、
それはように、80ビットを置きます

1649
01:22:45,060 --> 01:22:49,120
ここで覚えておくべき
Zamylaが開始され、終了します。

1650
01:22:49,120 --> 01:22:51,490
>> だから、接続は何ですか、
その後、このプログラムに？

1651
01:22:51,490 --> 01:22:55,190
ここでこのプログラム、スターリング、
機構は、単に

1652
01:22:55,190 --> 01:22:57,970
文字列を取得するための
ユーザーから、6行目。

1653
01:22:57,970 --> 01:23:01,160
7行目、私は変数を宣言します
nと呼ばれ、それが0に等しく設定。

1654
01:23:01,160 --> 01:23:08,680
>> そして、8行目では、私は単純に尋ねました
質問、n番目の文字がない間

1655
01:23:08,680 --> 01:23:12,120
等しくないすべて0 bits--
言い換えれば、しません

1656
01:23:12,120 --> 01:23:14,500
同じこの特別な
文字、バックスラッシュ0、どの

1657
01:23:14,500 --> 01:23:18,470
ちょうどその特別なヌルcharacter--ました
先に行くと、ちょうどn個をインクリメントします。

1658
01:23:18,470 --> 01:23:21,460
>> そして、それをやり続けると、キープ
それをやって、それをやり続けます。

1659
01:23:21,460 --> 01:23:23,430
そしてそうであっても中にかかわらず、
私たちは私を使用した過去、

1660
01:23:23,430 --> 01:23:25,181
それは完全に罰金です
意味的にn個使用します、

1661
01:23:25,181 --> 01:23:27,430
あなただけにしようとしている場合
意図的にこの時間をカウント、

1662
01:23:27,430 --> 01:23:28,720
ちょうどnはそれを呼び出すようにしたいです。

1663
01:23:28,720 --> 01:23:34,720
だから、これはただ質問を保ち、
すべて0秒のn番目の文字はありますか？

1664
01:23:34,720 --> 01:23:38,470
ない場合は、次の外観に見て、
、次に見て、次に目を向けます

1665
01:23:38,470 --> 01:23:39,460
次に目を向けます。

1666
01:23:39,460 --> 01:23:45,540
>> しかし、すぐにあなたがバックスラッシュ0を見るように、
11--を通じてこのloop--線9が停止します。

1667
01:23:45,540 --> 01:23:49,640
あなたは、whileループから抜け出します
その変数nの内側に残します

1668
01:23:49,640 --> 01:23:54,530
のすべての合計数
あなたが見た文字列の文字、

1669
01:23:54,530 --> 01:23:55,660
それによって、それをプリントアウト。

1670
01:23:55,660 --> 01:23:56,760
それでは、これを試してみましょう。

1671
01:23:56,760 --> 01:23:59,500
>> 私は先に行ってみようと、なし
スターリング関数を使用して、

1672
01:23:59,500 --> 01:24:04,240
しかし、ちょうど私の自身の自家製のバージョンを使用して
ここでは、スターリングと呼ばれる、私は先に行ってみましょう

1673
01:24:04,240 --> 01:24:07,700
そして、何かにスターリング、タイプを​​実行します
私は事前に知ってZamyla、など

1674
01:24:07,700 --> 01:24:08,670
6文字です。

1675
01:24:08,670 --> 01:24:10,080
それが動作するかどうかを見てみましょう。

1676
01:24:10,080 --> 01:24:10,920
確かに、それは6です。

1677
01:24:10,920 --> 01:24:15,257
それでは、ロブ、3文字で試してみましょう、
3文字だけでなく、など。

1678
01:24:15,257 --> 01:24:17,340
だから、起こっていることすべてです
フード真下に。

1679
01:24:17,340 --> 01:24:19,548
そして、の接続に気付きます、
その後、最初の週で

1680
01:24:19,548 --> 01:24:22,370
クラスの、どこに我々はについて話しました
抽象化のようなもの、

1681
01:24:22,370 --> 01:24:26,960
そのアイデアのちょうどこの階層化され、または
複雑さ、基本的な原則の上に。

1682
01:24:26,960 --> 01:24:30,710
ここでは、ソートの探しています
スターリングのボンネットの下に、

1683
01:24:30,710 --> 01:24:33,510
そう把握するために、話すこと、
それがどのように実装されるでしょうか？

1684
01:24:33,510 --> 01:24:35,232
>> そして、我々はそれを自分自身を再実装可能性があります。

1685
01:24:35,232 --> 01:24:37,440
しかし、我々は決して再びつもりです
再実装スターリングへ。

1686
01:24:37,440 --> 01:24:39,780
私達はちょうどになるだろう
順番にスターリングを使用

1687
01:24:39,780 --> 01:24:42,100
実際にいくつかの文字列の長さを取得します。

1688
01:24:42,100 --> 01:24:44,200
>> しかし、魔法はありません
ボンネットの下に。

1689
01:24:44,200 --> 01:24:46,716
あなたはその下に知っていれば
フード、文字列

1690
01:24:46,716 --> 01:24:48,090
文字だけのシーケンスです。

1691
01:24:48,090 --> 01:24:51,090
そして、その文字列
すべての数値的に対処することができます

1692
01:24:51,090 --> 01:24:53,330
ブラケット0、ブラケット付き
1、ブラケット2、そしてあなた

1693
01:24:53,330 --> 01:24:57,420
文字列の末尾にあることを知っています
特殊文字、あなたが把握することができます

1694
01:24:57,420 --> 01:25:01,710
の中で最も何かをする方法
プログラムは、すべてのためにそれはつまるところ

1695
01:25:01,710 --> 01:25:03,400
読み取り、メモリを書いています。

1696
01:25:03,400 --> 01:25:06,130
それが変化すると見て、あります
メモリで、または物事を動かします

1697
01:25:06,130 --> 01:25:10,940
周りのメモリで、印刷物事
画面上など。

1698
01:25:10,940 --> 01:25:14,800
>> それでは、今、この新たにを使用してみましょう
実際にストリングス何の理解

1699
01:25:14,800 --> 01:25:17,910
ボンネットの下にあり、
一つの他の層をバック剥離

1700
01:25:17,910 --> 01:25:20,080
それまで今まで私たちがきました
完全に無視されて。

1701
01:25:20,080 --> 01:25:22,650
具体的には、任意の時間
我々はプログラムを実装しました、

1702
01:25:22,650 --> 01:25:25,930
次のコード行を持っていました
上部付近にメイン宣言する。

1703
01:25:25,930 --> 01:25:27,810
そして、我々はint型の主な空隙を指定しました。

1704
01:25:27,810 --> 01:25:31,240
>> 括弧内とその空隙
すべてのこの時間、メインと言ってきました

1705
01:25:31,240 --> 01:25:33,440
それ自体は引数をとりません。

1706
01:25:33,440 --> 01:25:36,210
主であることを任意の入力
ユーザーから取得するつもり

1707
01:25:36,210 --> 01:25:39,020
いくつかの他から来るように持っています
メカニズム、などの取得int型、

1708
01:25:39,020 --> 01:25:42,040
またはフロートを取得、または文字列を取得し、
またはいくつかの他の機能。

1709
01:25:42,040 --> 01:25:44,710
しかし、それはことが判明します
あなたがプログラムを書くとき、

1710
01:25:44,710 --> 01:25:47,690
あなたが実際に指定することができます
このプログラムはものと

1711
01:25:47,690 --> 01:25:51,730
人間からの入力を取ります
コマンドライン自体に。

1712
01:25:51,730 --> 01:25:56,310
>> 言い換えれば、たとえ我々これまで
こんにちはちょうど./helloを実行してきました

1713
01:25:56,310 --> 01:26:00,312
または類似のプログラムのすべて
私たちが使ってきた他のプログラム、

1714
01:26:00,312 --> 01:26:02,770
私たち自身が書いていないこと、
取っている、それはそうです、

1715
01:26:02,770 --> 01:26:05,210
コマンドラインarguments--
メイクのようなもの。

1716
01:26:05,210 --> 01:26:07,450
あなたはmakeに似た何かを言います、
し、2番目の単語。

1717
01:26:07,450 --> 01:26:10,950
または打ち鳴らす、あなたがして打ち鳴らすと言うと、
第2ワード、ファイルの名前。

1718
01:26:10,950 --> 01:26:14,410
>> あなたがかもしれないとして、あるいはRMまたはCP
見たか、既に使用しています

1719
01:26:14,410 --> 01:26:15,880
削除するか、ファイルをコピーします。

1720
01:26:15,880 --> 01:26:18,920
それらのすべては、いわゆる取ります
コマンドラインarguments--

1721
01:26:18,920 --> 01:26:21,130
ターミナルプロンプトで追加の言葉。

1722
01:26:21,130 --> 01:26:23,260
しかし、今まで、我々
自分は持っていませんでした

1723
01:26:23,260 --> 01:26:27,080
からの入力を取るこの贅沢
ユーザー彼または彼女が実際に実行されます

1724
01:26:27,080 --> 01:26:29,120
コマンドラインでプログラムそのもの。

1725
01:26:29,120 --> 01:26:33,710
>> しかし、我々は再宣言することでそれを行うことができます
メインはないものとして、前進します

1726
01:26:33,710 --> 01:26:36,750
括弧内に無効、
しかし、これら二つの引数

1727
01:26:36,750 --> 01:26:40,600
最初の整数instead--、
第二何か

1728
01:26:40,600 --> 01:26:44,170
私たちはコールするつもりだ新しい、何か
アレイ、精神において似たような

1729
01:26:44,170 --> 01:26:49,220
我々はリストとしてスクラッチで見たものに、しかし、
文字列の配列は、我々はすぐに表示されますよう。

1730
01:26:49,220 --> 01:26:51,790
しかし、ここでは、することによって、これを見てみましょう
一例として、私たちの前に

1731
01:26:51,790 --> 01:26:53,690
それが意味を正確に区別しています。

1732
01:26:53,690 --> 01:26:56,520
>> だから私はCS50 IDEに行けば
ここで、私は先に行ってきました

1733
01:26:56,520 --> 01:27:01,840
そして、呼ばれるファイルで宣言
次のテンプレートをargv0.c。

1734
01:27:01,840 --> 01:27:04,120
そして、唯一の事に気付きます
それは、これまでに違います

1735
01:27:04,120 --> 01:27:08,570
私はintに空隙変更したということです
近くのargc文字列argvのオープンブラケット、

1736
01:27:08,570 --> 01:27:09,070
ブラケット。

1737
01:27:09,070 --> 01:27:11,730
そして、あり、今のところ気付きます
これらのブラケットの内側には何もありません。

1738
01:27:11,730 --> 01:27:12,620
>> 何の数はありません。

1739
01:27:12,620 --> 01:27:15,070
そして、そこには私がいない、または
N、または他の任意の文字。

1740
01:27:15,070 --> 01:27:17,010
私は使用しています
今の角括弧、

1741
01:27:17,010 --> 01:27:19,510
私たちが来るの理由で
バックに一瞬インチ

1742
01:27:19,510 --> 01:27:21,330
>> そして今、私は何するつもりだことはこれです。

1743
01:27:21,330 --> 01:27:26,680
ARGCが等しい場合に等しいです2--
そして、equalsに等しいリコール

1744
01:27:26,680 --> 01:27:30,040
等価演算子を比較しています
平等のための左右。

1745
01:27:30,040 --> 01:27:31,790
それは割り当てではありません
あるオペレータ、

1746
01:27:31,790 --> 01:27:36,510
コピーを意味し、単一の等号、
右からいくつかの値を左に。

1747
01:27:36,510 --> 01:27:42,840
>> ARGCが2に等しい等しい場合、私がしたいです
たとえば、printf関数、こんにちは、パーセント、新しいライン、

1748
01:27:42,840 --> 01:27:47,340
そしてその後in--プラグ、ここで新機能
理由のために、argvのブラケット1をtrick--

1749
01:27:47,340 --> 01:27:48,840
私たちはその瞬間に戻って来ること。

1750
01:27:48,840 --> 01:27:52,110
他にargcがない場合
2等しく、あなたは何を知っていますか？

1751
01:27:52,110 --> 01:27:57,400
ちょうど先に行くと、いつものように、印刷してみましょう
無置換でアウトこんにちは世界。

1752
01:27:57,400 --> 01:28:02,710
>> だから、ARGC場合、どのように思われます
、2に等しい、引数の数を表し

1753
01:28:02,710 --> 01:28:04,740
私はプリントアウトするつもりです
こんにちは、何かまたは他。

1754
01:28:04,740 --> 01:28:07,560
そうでない場合は、デフォルトでは、私はよ
こんにちは、世界を印刷しよう。

1755
01:28:07,560 --> 01:28:08,770
だから、これは何を意味するのでしょうか？

1756
01:28:08,770 --> 01:28:15,550
>> まあ、私が先に行くと、保存してみましょう
このファイル、およびその後argv0を作るのですか、

1757
01:28:15,550 --> 01:28:18,940
そしてその後./argv0、入力します。

1758
01:28:18,940 --> 01:28:20,300
そして、それは世界が挨拶します。

1759
01:28:20,300 --> 01:28:21,260
さて、それはなぜですか？

1760
01:28:21,260 --> 01:28:24,730
>> まあ、それはいつでもあなたが判明します
コマンドラインでプログラムを実行し、

1761
01:28:24,730 --> 01:28:29,570
あなたは私たちがよに充填されています
一般的に引数ベクトルを呼び出します。

1762
01:28:29,570 --> 01:28:33,100
換言すれば、自動的に
コンピュータ、オペレーティングシステム、

1763
01:28:33,100 --> 01:28:38,340
あなたのプログラムに手しようとしています
自身の言葉のすべてのリスト

1764
01:28:38,340 --> 01:28:40,850
人間は時に入力したこと
場合のプロンプトで、

1765
01:28:40,850 --> 01:28:43,790
プログラマはやってみたいです
その情報を使って何か。

1766
01:28:43,790 --> 01:28:48,540
そして、この場合には、単語のみ
私は./argv0でプロンプトに入力しました。

1767
01:28:48,540 --> 01:28:55,420
>> だから引数の数であります
私のプログラムに渡されることはただ一つです。

1768
01:28:55,420 --> 01:28:58,880
言い換えれば、引数
そうでない場合のargcとして知られ、カウント

1769
01:28:58,880 --> 01:29:00,970
ここでは整数として、一つだけです。

1770
01:29:00,970 --> 01:29:03,000
一つは、もちろん、二つ等しくありません。

1771
01:29:03,000 --> 01:29:05,980
そして、これはこんにちは、世界を印刷するものです。

1772
01:29:05,980 --> 01:29:08,170
>> しかし、私はこのどこかを見てみましょう。

1773
01:29:08,170 --> 01:29:09,930
私が言ってみましょう、argv0。

1774
01:29:09,930 --> 01:29:12,740
そして、どのようにマリアはどうですか？

1775
01:29:12,740 --> 01:29:14,990
そして、入力し、Enterを押します。

1776
01:29:14,990 --> 01:29:18,020
>> そして魔法ここに何が起こるかわかります。

1777
01:29:18,020 --> 01:29:22,640
今、代わりにハロー世界の、私が持っています
このプログラムの動作を変更

1778
01:29:22,640 --> 01:29:26,310
ない取得からの入力を取ることによって、
文字列または他​​のいくつかの機能、

1779
01:29:26,310 --> 01:29:30,570
しかし、どうやら、私のコマンドから
それ自体、私はもともとで入力した内容。

1780
01:29:30,570 --> 01:29:35,720
そして私は、再びこのゲームをプレイすることができます
例えば、ステリオスに変えます。

1781
01:29:35,720 --> 01:29:38,400
>> そして今、私はまだ別の名前を参照してください。

1782
01:29:38,400 --> 01:29:40,540
そしてここで、私はアンディが言うかもしれません。

1783
01:29:40,540 --> 01:29:42,137
そして、私はZamylaを言うかもしれません。

1784
01:29:42,137 --> 01:29:45,220
そして、私たちは一日中、このゲームをプレイすることができ、
わずかに異なる値をプラグイン、

1785
01:29:45,220 --> 01:29:49,550
あまりにも長い間、私は正確に提供するように
プロンプトで二つの言葉、

1786
01:29:49,550 --> 01:29:52,260
その結果、argcが、私の引数の数は、2です。

1787
01:29:52,260 --> 01:29:57,240
>> 私は名前が差し込まことを参照しています
printf関数、ここでこの条件ごとに？

1788
01:29:57,240 --> 01:30:00,550
だから我々は今持っているように見えます
表現力

1789
01:30:00,550 --> 01:30:04,410
別のメカニズムからの入​​力を取ります、
いわゆるコマンドラインから、

1790
01:30:04,410 --> 01:30:07,000
むしろ待つことよりも
ユーザーがプログラムを実行するまで、

1791
01:30:07,000 --> 01:30:10,220
そしてその後、彼または彼女を促します
GET文字列のようなものを使用。

1792
01:30:10,220 --> 01:30:11,230
>> だから、これは何ですか？

1793
01:30:11,230 --> 01:30:15,010
argcが、再び、ちょうど整数であり、
words-- arguments--数

1794
01:30:15,010 --> 01:30:18,540
その時に提供されたユーザー
ターミナルウィンドウで、プロンプト、

1795
01:30:18,540 --> 01:30:20,110
プログラムの名前を含みます。

1796
01:30:20,110 --> 01:30:23,340
だから、私たちの./argv0は、効果的であり、
プログラムの名前、

1797
01:30:23,340 --> 01:30:24,520
またはどのように私はプログラムを実行します。

1798
01:30:24,520 --> 01:30:25,810
>> それは単語とし​​てカウントされます。

1799
01:30:25,810 --> 01:30:27,080
だから、argcが1になります。

1800
01:30:27,080 --> 01:30:29,750
しかし、私はステリオスを書くとき、または
アンディ、またはZamyla、またはマリア、

1801
01:30:29,750 --> 01:30:31,660
それは、引数の個数が2であることを意味します。

1802
01:30:31,660 --> 01:30:33,910
そして今で渡された2つの単語があります。

1803
01:30:33,910 --> 01:30:36,070
>> 予告、私たちは、このロジックを続けることができます。

1804
01:30:36,070 --> 01:30:39,050
私が実際に言っている場合
Zamylaチャンのようなもの、

1805
01:30:39,050 --> 01:30:42,200
フルネーム、それによって渡します
合計3引数、

1806
01:30:42,200 --> 01:30:47,410
今では再びデフォルトを言い、
もちろん、3が2に等しくないからです。

1807
01:30:47,410 --> 01:30:54,080
>> だから、このように、私が持っています
この新しい引数のargvを介したアクセス

1808
01:30:54,080 --> 01:30:56,080
我々は技術的にできること
私たちが望むものを呼び出します。

1809
01:30:56,080 --> 01:30:58,940
しかし、慣例により、それはです
それぞれARGVとARGC、。

1810
01:30:58,940 --> 01:31:04,470
ARGV、引数ベクトルは、一種であります
プログラミングのための同義語の

1811
01:31:04,470 --> 01:31:07,140
Cでの特徴は、配列と呼ばれます。

1812
01:31:07,140 --> 01:31:14,410
>> アレイは、類似した値のリストです
バック、背中合わせにするために、バックアップします。

1813
01:31:14,410 --> 01:31:17,810
換言すれば、一方が右ここにある場合
RAMは、次の1が右隣にあります、

1814
01:31:17,810 --> 01:31:18,800
そして右隣に。

1815
01:31:18,800 --> 01:31:20,101
彼らはあらゆる場所にはありません。

1816
01:31:20,101 --> 01:31:23,100
そして、後者のシナリオでは、物事
すべてのメモリ内の場所にあり、

1817
01:31:23,100 --> 01:31:25,082
実際に強力な機能することができます。

1818
01:31:25,082 --> 01:31:28,040
ときに我々が、我々はそれに戻ってきます
手の込んだデータ構造について話しています。

1819
01:31:28,040 --> 01:31:32,260
今のところ、配列だけです
連続したメモリのチャンク、

1820
01:31:32,260 --> 01:31:36,520
その要素のそれぞれ
バック、背中合わせにするために、バックアップするために、

1821
01:31:36,520 --> 01:31:38,050
そして、一般的に同じタイプ。

1822
01:31:38,050 --> 01:31:42,630
>> だから、から、考えてみれば
一瞬前に、文字列は何ですか？

1823
01:31:42,630 --> 01:31:50,460
さて、文字列、Zamylaのような、
Z-A-M-Y-L-Aは、技術的には、あります

1824
01:31:50,460 --> 01:31:51,400
配列だけ。

1825
01:31:51,400 --> 01:31:53,700
これは、文字の配列です。

1826
01:31:53,700 --> 01:31:59,250
>> だから私たちは本当に私のように、これを描く場合
メモリのチャンクとして、以前行いました、

1827
01:31:59,250 --> 01:32:04,510
これらのそれぞれが判明します
文字バイトを占めます。

1828
01:32:04,510 --> 01:32:07,630
そして、その特別があります
センチネル文字、バックスラッシュ0、

1829
01:32:07,630 --> 01:32:12,360
またはすべての8 0ビット、その
その文字列の終わりを画定します。

1830
01:32:12,360 --> 01:32:15,090
だから文字列は、それが変わります
アウト、引用終わりの文字列を引用

1831
01:32:15,090 --> 01:32:20,580
chara--の配列だけです
実際のデータ型であるchar型。

1832
01:32:20,580 --> 01:32:24,560
>> そして今のargv、meanwhile--
プログラムに戻ってみましょう。

1833
01:32:24,560 --> 01:32:29,582
私たちは言葉を見ていてもARGV、
ここで文字列は、文字列自体ではありません。

1834
01:32:29,582 --> 01:32:33,640
ARGV、引数ベクトル、
文字列の配列です。

1835
01:32:33,640 --> 01:32:37,620
>> だから、の配列を持つことができると同じように
文字は、あなたがより高いレベルを持つことができ、

1836
01:32:37,620 --> 01:32:46,279
strings--の配列ので、例えば、
私は先ほど入力したとき./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0、空間Z-A-M-Y-L-A、私がいると主張
argvが、it-- ./argv0内の2つの文字列を持っていました

1838
01:33:00,150 --> 01:33:03,185
およびZ-A-M-Y-L-A。に
つまり、argcが2でした。

1839
01:33:03,185 --> 01:33:03,980
何故ですか？

1840
01:33:03,980 --> 01:33:08,370
>> まあ、効果的に、何が起こっています
これらの文字列のそれぞれである上

1841
01:33:08,370 --> 01:33:13,990
もちろん、文字の配列であります
前のように、各そのの文字

1842
01:33:13,990 --> 01:33:15,670
1バイトを占めます。

1843
01:33:15,670 --> 01:33:19,720
そして、実際の0を混同しないでください
0でプログラムの名前で、

1844
01:33:19,720 --> 01:33:22,040
これはすべて80ビットを意味します。

1845
01:33:22,040 --> 01:33:27,140
そしてZamylaは、一方、まだです
また、文字の配列。

1846
01:33:27,140 --> 01:33:31,450
>> 一日の終わりにそう、それは本当に
ボンネットの下に、次のようになります。

1847
01:33:31,450 --> 01:33:38,800
しかし、どのように主の性質によって、argvを
作品は、私はこのすべてをラップすることができます

1848
01:33:38,800 --> 01:33:44,810
、可能ならば、より大きな配列にアップ
私たちは少しオーバー簡素化する場合には、その

1849
01:33:44,810 --> 01:33:48,180
絵は次のようになりますとそうでないもの
かなりそこにスケールアップするためにそれを描きます、

1850
01:33:48,180 --> 01:33:56,720
この配列は、サイズのみ2の最初のものです
文字列が含まれているの要素、

1851
01:33:56,720 --> 01:33:59,230
の2番目の要素
その文字列が含まれています。

1852
01:33:59,230 --> 01:34:01,687
そして、今度は、あなたの場合
種類ごとにズームイン

1853
01:34:01,687 --> 01:34:03,770
これらの文字列の何
ボンネットの下を参照してください。

1854
01:34:03,770 --> 01:34:07,190
各文字列はちょうどであるということです
文字の配列。

1855
01:34:07,190 --> 01:34:11,680
>> さて、文字列だけの場合と同様に、
我々はアクセスを得ることができました

1856
01:34:11,680 --> 01:34:15,260
文字列内のi番目の文字へ
その角括弧表記を使用。

1857
01:34:15,260 --> 01:34:17,320
同様に、配列で
一般的には、私たちすることができます

1858
01:34:17,320 --> 01:34:22,700
取得するために角括弧表記法を使用
配列内の文字列の任意の数で？

1859
01:34:22,700 --> 01:34:25,100
例えば、私を聞かせて
先に行くと、これを行います。

1860
01:34:25,100 --> 01:34:32,420
>> 私が先に行くとargv1.cを作成してみましょう、
これは少し異なるこの時間です。

1861
01:34:32,420 --> 01:34:35,635
代わりにargc2をチェックします、
私の代わりにこれを行うつもりです。

1862
01:34:35,635 --> 01:34:41,270
int型のために私は0を取得し、私が小さいです
ARGCより、Iプラスプラス、

1863
01:34:41,270 --> 01:34:47,920
そしてその後、この内部のプリントアウト
パーセントの、改行してから、

1864
01:34:47,920 --> 01:34:50,740
argvのブラケット私。

1865
01:34:50,740 --> 01:34:55,220
>> だから、他の言葉で、私は扱っていませんよ
現時点では個々の文字。

1866
01:34:55,220 --> 01:35:00,190
これらの空の角によって暗示としてARGV、
名前ARGVの右にあるブレース、

1867
01:35:00,190 --> 01:35:03,320
文字列の配列ですARGVを意味します。

1868
01:35:03,320 --> 01:35:04,870
そして、argcがちょうどintです。

1869
01:35:04,870 --> 01:35:08,800
>> ここでこの行、6、さ
セットを言って、私は0に等しいです。

1870
01:35:08,800 --> 01:35:11,980
、までのすべての方法を数えます
しかしARGC、含みません。

1871
01:35:11,980 --> 01:35:14,010
そして、それぞれの繰り返しで、
文字列を出力します。

1872
01:35:14,010 --> 01:35:14,800
どのような文字列？

1873
01:35:14,800 --> 01:35:17,270
>> ARGVのi番目の文字列。

1874
01:35:17,270 --> 01:35:19,530
私がいた前のに対し、だから
角括弧を使用して、

1875
01:35:19,530 --> 01:35:22,180
i番目に取得するための表記法
今、文字列内の文字、

1876
01:35:22,180 --> 01:35:27,240
私は、角括弧表記を使用しています
配列内のi番目の文字列で取得します。

1877
01:35:27,240 --> 01:35:30,310
だから、一つの層のようなものです
概念的には、上記の。

1878
01:35:30,310 --> 01:35:35,390
>> だからこのことについてきちんとしたものです
今プログラム、私はargv1コンパイルした場合、

1879
01:35:35,390 --> 01:35:42,067
そしてその後./argv1を行い、その後、入力
fooのバーbazのようなもので、

1880
01:35:42,067 --> 01:35:45,400
3デフォルトの単語れています
コンピュータ科学者は、任意の時間のために達します

1881
01:35:45,400 --> 01:35:51,010
彼または彼女は、いくつかのプレースホルダのワードを必要とします、
そして、入力し、Enterキーを押し、それらの単語のそれぞれ、

1882
01:35:51,010 --> 01:35:54,980
これは、プログラムの名前を含みます
最初の場所でのargvであり、

1883
01:35:54,980 --> 01:35:58,320
一度に一つの印刷されてしまいます。

1884
01:35:58,320 --> 01:36:05,290
そして、私はこれを変更し、私はと言えば
argv1 Zamylaチャンのようなもの、

1885
01:36:05,290 --> 01:36:08,800
我々は、これらの3つのすべてを取得します
argv0ある言葉、

1886
01:36:08,800 --> 01:36:14,400
argv1、argv2、この中のため、
ケースargcが、カウントは、3です。

1887
01:36:14,400 --> 01:36:20,020
>> しかし、どのようなきちんとしたのは、あなたが理解している場合であります
そのargvが文字列の配列だけであり、

1888
01:36:20,020 --> 01:36:24,910
あなたは文字列があることを理解します
文字の配列です、

1889
01:36:24,910 --> 01:36:29,470
私たちは、実際には一種のこれを使用することができます
角括弧表記法を複数回

1890
01:36:29,470 --> 01:36:33,320
文字列を選択し、選択します
文字列内の文字、

1891
01:36:33,320 --> 01:36:35,730
次のように深いダイビング。

1892
01:36:35,730 --> 01:36:40,100
この例では、私は手放します
先にこのargv2.cを呼び出します。

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
そして、この例では、私は先に行ってみましょう
そして、私は0を取得するint型のためfollowing--を行います

1895
01:36:50,180 --> 01:36:53,286
私は、私のargc未満のプラス
プラス、直前に好きです。

1896
01:36:53,286 --> 01:36:55,910
だから今この他words--とで
十分に複雑なっています。

1897
01:36:55,910 --> 01:36:59,940
それから私は言うつもりです
ARGV内の文字列を反復処理、

1898
01:36:59,940 --> 01:37:01,294
自分自身へのコメントとして。

1899
01:37:01,294 --> 01:37:03,960
そして、私が持っているつもりです
おそらくあなたのループのためにネストされました

1900
01:37:03,960 --> 01:37:06,290
行われ、または検討しています
スクラッチで、やって、どこで

1901
01:37:06,290 --> 01:37:08,600
私はint--私は言うつもりです
再び私を使用するつもりはありません、

1902
01:37:08,600 --> 01:37:12,590
私はシャドウしたくないので、または
ソートの既存私を上書きします。

1903
01:37:12,590 --> 01:37:15,780
>> 私はので、代わりに、Jを言うつもりです
それは、私の後に変数に私の外出です

1904
01:37:15,780 --> 01:37:18,590
私はちょうどにしようとしているとき
単純な数を数えます。

1905
01:37:18,590 --> 01:37:28,850
jについて0--を取得し、また、nは、しようとしています
argvのブラケット私の船尾長さを取得し、

1906
01:37:28,850 --> 01:37:36,030
限りjがメートル未満であるように、
Jプラスプラス、次の操作を行います。

1907
01:37:36,030 --> 01:37:37,500
そして、ここで興味深い部分です。

1908
01:37:37,500 --> 01:37:46,330
>> 文字や改行をプリントアウトし、
私は、argvのブラケットにブラケットJを差し込みます。

1909
01:37:46,330 --> 01:37:47,940
[OK]を、ので、私はここにいくつかのコメントを追加してみましょう。

1910
01:37:47,940 --> 01:37:54,820
文字を反復処理
現在の文字列で、

1911
01:37:54,820 --> 01:38:02,290
i番目の文字列に印刷j番目の文字。

1912
01:38:02,290 --> 01:38:04,630
だから今、のは、考えてみましょう
これらのコメントは何を意味します。

1913
01:38:04,630 --> 01:38:06,750
>> 文字列を反復処理
argv--でどのように多くの

1914
01:38:06,750 --> 01:38:09,300
文字列は配列である、ARGVにありますか？

1915
01:38:09,300 --> 01:38:13,420
ARGC多く、私は反復よ
私はARGCまで0に等しいから。

1916
01:38:13,420 --> 01:38:20,020
一方、どのように多くの文字
ARGVのi番目の文字列にありますか？

1917
01:38:20,020 --> 01:38:22,880
>> まあ、その答えを得るために、
私は文字列の長さを呼び出します

1918
01:38:22,880 --> 01:38:26,810
現在の文字列に私は気に
私argvのブラケットである、およそ。

1919
01:38:26,810 --> 01:38:30,090
そして、私は一時的にそれを保存するつもりです
値nは、単にキャッシュのために、

1920
01:38:30,090 --> 01:38:31,590
効率のためにそれを覚えています。

1921
01:38:31,590 --> 01:38:36,330
そして私は、0にJを初期化するつもりです
jがn未満である限り、続けます、

1922
01:38:36,330 --> 01:38:38,430
そして、各反復増分j上。

1923
01:38:38,430 --> 01:38:41,030
>> そして、ここで、あたり
ライン12上の私のコメント、

1924
01:38:41,030 --> 01:38:43,390
文字をプリントアウトし、
新しい行が続き、

1925
01:38:43,390 --> 01:38:48,140
具体的にはargvのブラケット
私は私にi番目の文字列を与えます

1926
01:38:48,140 --> 01:38:51,690
そうargv--の最初の単語、
2ワード、3ワード目、何でも。

1927
01:38:51,690 --> 01:38:57,370
そして、jが深くにダイブし、取得します
私、その単語のj番目の文字。

1928
01:38:57,370 --> 01:39:02,200
だから、実際には、あなたが扱うことができます
argvの多次元として、

1929
01:39:02,200 --> 01:39:06,050
2次元、配列として、
これによりルックスのすべての単語の種類

1930
01:39:06,050 --> 01:39:08,580
あなたの心の中でこのような
目、およびすべての文字

1931
01:39:08,580 --> 01:39:10,930
種類の中で構成され、
列は、それが役立ちます。

1932
01:39:10,930 --> 01:39:13,260
>> 実際には、ときに我々はいじめます
今後数週間で、この離れて、

1933
01:39:13,260 --> 01:39:15,580
少しになるだろう
それよりも、より洗練されました。

1934
01:39:15,580 --> 01:39:17,800
しかし、あなたは本当にすることができます
今のところ、そのことを考えて、

1935
01:39:17,800 --> 01:39:22,110
ちょうどこの2次元として
それの配列、それによって1レベル

1936
01:39:22,110 --> 01:39:23,260
すべての文字列です。

1937
01:39:23,260 --> 01:39:26,760
そして、あなたは深く、あなたの中に潜っている場合
個々の文字を取得することができます

1938
01:39:26,760 --> 01:39:29,600
ここではこの表記法を使用して、その中に。

1939
01:39:29,600 --> 01:39:31,620
>> だから、正味の効果は何ですか？

1940
01:39:31,620 --> 01:39:34,970
私は先に行ってみようと
argv2--くそにそれを作ります。

1941
01:39:34,970 --> 01:39:36,210
私はここでミスを犯しました。

1942
01:39:36,210 --> 01:39:40,160
暗黙的に宣言
ライブラリ関数スターリング。

1943
01:39:40,160 --> 01:39:42,190
だから、すべてのこの時間は、それはです
おそらく適切な

1944
01:39:42,190 --> 01:39:45,130
私たちは、ソートの仕上げていること
場所を正​​確に我々が始まりました。

1945
01:39:45,130 --> 01:39:48,160
>> 私は暗黙的に宣言し、めちゃくちゃ
ライブラリ関数スターリング。

1946
01:39:48,160 --> 01:39:48,987
OK、ちょっと待って。

1947
01:39:48,987 --> 01:39:51,070
私は特に、それを覚えています
それはここだから。

1948
01:39:51,070 --> 01:39:54,490
私は中string.hのを含める必要があります
このバージョンのプログラム。

1949
01:39:54,490 --> 01:40:00,050
>> 私は先に行ってみようと含み
string.hの、それを保存し、先に行きます

1950
01:40:00,050 --> 01:40:04,460
そして、argv2を再コンパイルします。

1951
01:40:04,460 --> 01:40:08,390
そして今、ここでは入力して、argv2作る、行きます。

1952
01:40:08,390 --> 01:40:10,590
そして、それは少しだけれども
一見不可解な、

1953
01:40:10,590 --> 01:40:15,690
何、確かに、それに気付きます
ドットargv2で印刷されます。

1954
01:40:15,690 --> 01:40:19,970
>> しかし、私は後にいくつかの単語を入力した場合
プロンプト、argv2 Zamylaチャンのように、

1955
01:40:19,970 --> 01:40:22,560
また、少しを入力してください
一見不可解。

1956
01:40:22,560 --> 01:40:30,540
しかし、我々はバックアップにスクロールすると、
./argv2 Z-A-M-Y-L-C-H-A-N。

1957
01:40:30,540 --> 01:40:32,190
だから我々はすべての単語を反復処理しました。

1958
01:40:32,190 --> 01:40:37,770
そして、今度は、私たちは反復処理しました
ワード内のすべての文字。

1959
01:40:37,770 --> 01:40:40,040
>> さて、このすべての後、
あることを実感

1960
01:40:40,040 --> 01:40:43,120
私たちは親切してきた一つの他の詳細
この全体の時間を無視します。

1961
01:40:43,120 --> 01:40:46,180
私達はちょうど離れてからかったもの
メインの入力はできますか？

1962
01:40:46,180 --> 01:40:47,780
どのようなメインの出力は？

1963
01:40:47,780 --> 01:40:50,540
>> この時間のすべて、我々がしてきました
単にコピー＆ペースト

1964
01:40:50,540 --> 01:40:53,870
メインの前の単語はint、
あなたがオンラインで表示されることがありますが、

1965
01:40:53,870 --> 01:40:58,340
時々間違って古いバージョンで
Cとコンパイラの、彼らは、無効と言うこと

1966
01:40:58,340 --> 01:40:59,410
またはまったく何もありません。

1967
01:40:59,410 --> 01:41:01,580
しかし、確かに、のバージョン
私たちが使用しているCの、

1968
01:41:01,580 --> 01:41:06,180
C 11、または2011、実現
それはint型でなければならないこと。

1969
01:41:06,180 --> 01:41:09,300
そして、それはどちらかでなければなりません
ボイドやargcとargvをここに。

1970
01:41:09,300 --> 01:41:10,790
>> しかし、なぜint型メイン？

1971
01:41:10,790 --> 01:41:12,480
それは実際に戻って何ですか？

1972
01:41:12,480 --> 01:41:16,280
まあ、それは、この時間のすべてが判明します
あなたがプログラムのメインを書いている任意の時間

1973
01:41:16,280 --> 01:41:18,440
常に何かを返しています。

1974
01:41:18,440 --> 01:41:19,960
しかし、それはそう密かにやっています。

1975
01:41:19,960 --> 01:41:23,350
>> その何かがあります
int型、ライン5が示すように。

1976
01:41:23,350 --> 01:41:24,225
しかし、どのようなint型？

1977
01:41:24,225 --> 01:41:26,100
まあ、これがあります
プログラミングのコンベンション、

1978
01:41:26,100 --> 01:41:29,790
それによって何も持っていない場合
間違って、すべてが順調です、

1979
01:41:29,790 --> 01:41:34,250
一般的なプログラムと機能
ややcounterintuitively-- return--

1980
01:41:34,250 --> 01:41:35,230
0。

1981
01:41:35,230 --> 01:41:38,070
0は、一般的にすべてが順調である意味します。

1982
01:41:38,070 --> 01:41:40,610
だから、あなたが考えるにもかかわらず、
多くの状況ではfalse、それ、

1983
01:41:40,610 --> 01:41:42,930
それは実際に一般的に良いことを意味します

1984
01:41:42,930 --> 01:41:49,560
>> 一方、プログラムが1を返す場合、
または負の1、または5、または負の42、

1985
01:41:49,560 --> 01:41:52,941
または任意の非0値、
それは一般的意味します

1986
01:41:52,941 --> 01:41:54,190
その何かが間違っています。

1987
01:41:54,190 --> 01:41:56,700
実際には、あなた自身のMacやPC上で、
あなたが実際に見たことがあるかもしれません

1988
01:41:56,700 --> 01:42:01,050
エラーメッセージ、それによってそれを
何かまたは他の、エラーが語ります

1989
01:42:01,050 --> 01:42:04,940
コー​​ド負の42、またはエラーコード
23、またはそのような何か。

1990
01:42:04,940 --> 01:42:08,980
その数は、一般的にだけヒントです
プログラマー、または会社へ

1991
01:42:08,980 --> 01:42:11,174
それは、ソフトウェアを作りました、
何がなぜ間違っているといいました、

1992
01:42:11,174 --> 01:42:13,590
彼らはを通して見ることができるように、
自分のドキュメントやコード、

1993
01:42:13,590 --> 01:42:15,465
とものを把握
エラーが実際に意味します。

1994
01:42:15,465 --> 01:42:18,400
それは一般的ではありません
私たちに有用なのは、エンドユーザー。

1995
01:42:18,400 --> 01:42:20,550
>> しかし、ときに主は0を返し、すべてが順調です。

1996
01:42:20,550 --> 01:42:23,770
そして、あなたが指定していない場合
返す必要があります主なものを、

1997
01:42:23,770 --> 01:42:26,950
それだけで自動的になります
あなたのための0を返します。

1998
01:42:26,950 --> 01:42:30,870
しかし、何かを返します
他には、実際に有用です。

1999
01:42:30,870 --> 01:42:34,660
>> この最終的なプログラムでは、私を聞かせて
先に行くと、このexit.cを呼び出し、

2000
01:42:34,660 --> 01:42:38,630
今日の最後を紹介
エラーコードとして知られているトピック、。

2001
01:42:38,630 --> 01:42:42,930
私が先に行くと、私たちが含まれてみましょう
おなじみのファイルをバックアップし、トップには、int型のメインを行います。

2002
01:42:42,930 --> 01:42:49,500
そして、この時間は、のは、int型のargcをさせ、
文字列ARGV、と私のブラケット付き

2003
01:42:49,500 --> 01:42:50,836
それは、アレイ内のだということを意味します。

2004
01:42:50,836 --> 01:42:52,460
そして、私はちょうど健全性チェックをしましょう​​。

2005
01:42:52,460 --> 01:42:56,640
今回、ARGCがない場合
2等しく、その後、あなたは何を知っていますか？

2006
01:42:56,640 --> 01:42:57,520
忘れてください。

2007
01:42:57,520 --> 01:43:03,170
私はそれを言うつもりです、ねえ、ユーザー、
あなたは、コマンドライン引数が不足しています

2008
01:43:03,170 --> 01:43:04,210
バックスラッシュn個。

2009
01:43:04,210 --> 01:43:05,230
>> そして、それはそれです。

2010
01:43:05,230 --> 01:43:06,130
私は終了します。

2011
01:43:06,130 --> 01:43:11,030
私は、先制するつもりです
そして途中で本当に、リターン

2012
01:43:11,030 --> 01:43:12,810
番号1以外の何か。

2013
01:43:12,810 --> 01:43:15,360
最初の値にアクセスしてください
起こることができるエラーが1です。

2014
01:43:15,360 --> 01:43:17,860
あなたはいくつかの他の誤ったを持っている場合
発生する可能性がある状況では、

2015
01:43:17,860 --> 01:43:21,390
あなたはリターン2言うか3を返す、または可能性があります
多分負の1または負の2。

2016
01:43:21,390 --> 01:43:23,750
>> これらは、ちょうど終了コードです
それは、一般的には、

2017
01:43:23,750 --> 01:43:27,770
プログラマにとって有用な、またはのみ
ソフトウェアを出荷しています会社。

2018
01:43:27,770 --> 01:43:30,500
しかし、実際にはそれがだと
0ではないが重要なのものです。

2019
01:43:30,500 --> 01:43:34,310
そのため、このプログラムでは、私はしたい場合は、
保証、このプログラムのみ

2020
01:43:34,310 --> 01:43:38,190
ユーザーが私を提供する場合に動作
2の引数の数と、

2021
01:43:38,190 --> 01:43:42,880
プログラムの名前、および他のいくつかの
単語、私は次のように多くを強制することができ、

2022
01:43:42,880 --> 01:43:46,110
printf関数の格言を持つユーザーで叫びます、
コマンドライン引数が不足し、

2023
01:43:46,110 --> 01:43:46,970
1を返します。

2024
01:43:46,970 --> 01:43:49,940
それはちょうど、すぐになります
プログラムを終了します。

2025
01:43:49,940 --> 01:43:55,840
>> ARGCが等しい場合にのみ、2は、我々が降ります
ここでは、その時点で私は言うつもりです、

2026
01:43:55,840 --> 01:44:00,410
こんにちはパーセント秒、バックスラッシュnは、argv1。

2027
01:44:00,410 --> 01:44:03,827
言い換えれば、私はよ
argvの0の後つもりはありません、

2028
01:44:03,827 --> 01:44:05,410
どのプログラムの名前だけです。

2029
01:44:05,410 --> 01:44:09,450
私は、ハロー、カンマを印刷したいです
人間が入力された第2ワード。

2030
01:44:09,450 --> 01:44:12,580
そして、この場合に
ライン13は、すべてが順調です。

2031
01:44:12,580 --> 01:44:15,920
>> 私はARGCが2であることを知っています
論理的に、このプログラムから。

2032
01:44:15,920 --> 01:44:17,770
私は先に行くと、0を返すつもりです。

2033
01:44:17,770 --> 01:44:21,230
余談として、心に留めておくこと
これは、同様にスクラッチも同様です。

2034
01:44:21,230 --> 01:44:24,760
>> 論理的には、私はこれを行うことができます
そしてこれらの行をカプセル化

2035
01:44:24,760 --> 01:44:27,020
ここでは、このelse節内のコードの。

2036
01:44:27,020 --> 01:44:29,420
しかし、それは一種のです
不必要に自分のコードをインデント。

2037
01:44:29,420 --> 01:44:31,800
そして、私はスーパーを作りたいです
明確な何があっています、

2038
01:44:31,800 --> 01:44:34,670
デフォルトでは、ハロー
何かは、印刷されてしまいます

2039
01:44:34,670 --> 01:44:36,050
ユーザーが協力している限り。

2040
01:44:36,050 --> 01:44:39,360
>> だから、使用することは非常に一般的です
条件、ちょうどあれば、

2041
01:44:39,360 --> 01:44:41,870
いくつかの誤ったをキャッチします
状況、および、終了します。

2042
01:44:41,870 --> 01:44:45,690
そして、あまりにも長い間すべてであります
よく、他に持っていません、

2043
01:44:45,690 --> 01:44:48,060
しかし、単にコードを持って
その外、それはだから場合

2044
01:44:48,060 --> 01:44:51,060
この中で同等
特定の場合、論理的に。

2045
01:44:51,060 --> 01:44:54,480
だから私はちょうどに、0を返しますよ
明示的にすべてが順調である意味。

2046
01:44:54,480 --> 01:44:58,480
>> 私はリターン0を省略した場合、それは希望
自動的に私のために想定されます。

2047
01:44:58,480 --> 01:45:00,890
しかし、今、私は戻っていること
少なくともこの場合には1、

2048
01:45:00,890 --> 01:45:04,940
私は良い測定のために、するつもりだし、
透明度は、この場合には0を返します。

2049
01:45:04,940 --> 01:45:09,690
だから今私が先に行くと出口を作ってみましょう、
これだけ残すのに最適なセグエです。

2050
01:45:09,690 --> 01:45:14,401
>> しかし、出口を作り、私は手放します
前方と./exitを行い、入力します。

2051
01:45:14,401 --> 01:45:16,900
プログラムは、私怒鳴ら
コマンドライン引数が欠落。

2052
01:45:16,900 --> 01:45:18,120
[OK]を、私が協力しましょう​​。

2053
01:45:18,120 --> 01:45:23,810
>> 入力し、デビッド、私が代わりに./exitをやってみましょう。

2054
01:45:23,810 --> 01:45:25,190
そして今、それはデビッドこんにちは、と言います。

2055
01:45:25,190 --> 01:45:27,300
そして、あなたは通常、これを見ないであろう。

2056
01:45:27,300 --> 01:45:30,650
>> しかし、それはそこだと判明します
実際に参照するには、Linuxで特別な方法

2057
01:45:30,650 --> 01:45:34,470
どのような終了コードでプログラムが終了しました。

2058
01:45:34,470 --> 01:45:37,184
時には、グラフィカルで
MacのOSやWindowsのような世界、

2059
01:45:37,184 --> 01:45:40,100
あなただけのこれらの数字を参照してください。
エラーメッセージが画面上にポップアップ表示します

2060
01:45:40,100 --> 01:45:41,940
プログラマ
あなたにその番号を示しています。

2061
01:45:41,940 --> 01:45:44,773
しかし、我々はどのようなエラーが表示する場合
メッセージは、我々はそれを行うことができ、ありますhere--

2062
01:45:44,773 --> 01:45:48,100
そう./exit、入力し、印刷
コマンドライン引数が欠落。

2063
01:45:48,100 --> 01:45:54,590
>> 私は今ある$？をエコーない場合
探して途方もなく不可解な。

2064
01:45:54,590 --> 01:45:56,590
しかし、$？

2065
01:45:56,590 --> 01:45:59,220
魔法の呪文です
それは、言うねえ、コンピュータ、

2066
01:45:59,220 --> 01:46:01,900
何以前教えてください
プログラムの終了コードがありました。

2067
01:46:01,900 --> 01:46:03,410
そして、私はEnterキーを押します。

2068
01:46:03,410 --> 01:46:07,520
それはどのような私だ​​から、私は、1を参照してください
返すために私の主な機能に語りました。

2069
01:46:07,520 --> 01:46:12,310
>> 一方、私はダビデを./exit行う場合には、
そして、入力し、Enterキーを押し、私はデビッドこんにちは、参照してください。

2070
01:46:12,310 --> 01:46:16,800
そして場合、私は今、$？、私はハロー0を参照してくださいエコーありません。

2071
01:46:16,800 --> 01:46:19,080
そして、これは実際になります
貴重な情報であること

2072
01:46:19,080 --> 01:46:23,420
デバッガの文脈では、ないので、
あなたは、人間が、気になることくらい。

2073
01:46:23,420 --> 01:46:26,060
しかし、デバッガと他の
プログラムでは、我々はこの学期を使用します

2074
01:46:26,060 --> 01:46:29,420
多くの場合、その番号を見ていきます、
それは一種の隠さだにもかかわらず、

2075
01:46:29,420 --> 01:46:32,780
あなたは、にそれを見ていない限り
決定プログラムのかどうか

2076
01:46:32,780 --> 01:46:37,050
実行が正しいか間違っていました。

2077
01:46:37,050 --> 01:46:40,450
>> そして、そのためには、に私たちをもたらします
この、一日の終わりに。

2078
01:46:40,450 --> 01:46:43,917
私たちは、を見て、今日開始しました
デバッグ、およびコースで順番に

2079
01:46:43,917 --> 01:46:46,750
自分自身、そしてその後、より興味深いのは、
技術的にはボンネットの下に

2080
01:46:46,750 --> 01:46:49,490
どのような文字列で最後に、これです
週私たちは当たり前のかかりました、

2081
01:46:49,490 --> 01:46:51,900
確かにそれらを取りました
スクラッチに付与されたため。

2082
01:46:51,900 --> 01:46:56,040
>> 我々は、我々はどのようにアクセスできるかを見て
文字列内の個々の文字、

2083
01:46:56,040 --> 01:47:00,310
そして再び、より高いレベルを取りました
well--どのように見て、物事を見て

2084
01:47:00,310 --> 01:47:04,226
私たちは、個々に取得したい場合
構造のようなリストの要素、

2085
01:47:04,226 --> 01:47:05,850
我々は、複数の文字列でそれを行うことができないのですか？

2086
01:47:05,850 --> 01:47:08,050
そして、我々は、コマンドライン引数を持つことができます。

2087
01:47:08,050 --> 01:47:12,800
しかし、ここだけのボックスのこの絵
この一般的なアイデアの実証であります

2088
01:47:12,800 --> 01:47:14,451
配列、またはリスト、またはベクトルの。

2089
01:47:14,451 --> 01:47:16,450
とに応じて、
コンテキスト、これらの単語のすべて

2090
01:47:16,450 --> 01:47:17,880
わずかに異なるものを意味します。

2091
01:47:17,880 --> 01:47:20,060
だからCで、我々は唯一のつもりです
配列について話をします。

2092
01:47:20,060 --> 01:47:23,840
そして、アレイは、塊です
人の記憶の、それぞれのです

2093
01:47:23,840 --> 01:47:27,720
要素は、戻って、連続しています
、背中合わせにするために、バックアップします。

2094
01:47:27,720 --> 01:47:31,970
>> そして、これらの要素は、一般に、あります
同じデータ型、文字、

2095
01:47:31,970 --> 01:47:35,966
文字、文字、文字、または
文字列、文字列、文字列、文字列、またはint型、

2096
01:47:35,966 --> 01:47:38,600
int型、int型、それが何であれ
我々は店にしようとしています。

2097
01:47:38,600 --> 01:47:42,540
しかし、一日の終わりに、これは
何それは概念的ように見えます。

2098
01:47:42,540 --> 01:47:44,530
あなたは、あなたを取っています
コンピュータのメモリやRAM。

2099
01:47:44,530 --> 01:47:48,590
そして、あなたはにそれを切り開くています
同じサイズの箱、そのすべての

2100
01:47:48,590 --> 01:47:50,920
に、バックアップする、戻ってきました
バック、この方法でバックアップします。

2101
01:47:50,920 --> 01:47:53,200
>> 約素敵なものです
このアイデア、事実

2102
01:47:53,200 --> 01:47:58,580
我々はこの方法で値を表現することができます
当社のデータ構造の最初と

2103
01:47:58,580 --> 01:48:02,520
クラスでは、我々が開始できることを意味します
コー​​ドの問題を解決するために

2104
01:48:02,520 --> 01:48:04,079
それは、週0でそう直感的になりました。

2105
01:48:04,079 --> 01:48:05,870
あなたは携帯電話を思い出し
本例で、ここで

2106
01:48:05,870 --> 01:48:09,110
我々は、除算を使用し、征服します
またはバイナリ検索アルゴリズム、

2107
01:48:09,110 --> 01:48:13,220
全体を取捨選択します
名前と番号の束。

2108
01:48:13,220 --> 01:48:18,220
しかし、我々はそのことを、リコールを想定しました
電話帳は、すでにソートされました

2109
01:48:18,220 --> 01:48:21,630
他の誰かがすでに持っていたこと
out--名のリストを与えられた考え出し

2110
01:48:21,630 --> 01:48:24,430
それらをアルファベット順にする方法numbers--。

2111
01:48:24,430 --> 01:48:26,950
そして今、そのCで、私たち、
あまりにも、能力を持っています

2112
01:48:26,950 --> 01:48:30,290
、物事をないレイアウトします
物理的に電話帳で

2113
01:48:30,290 --> 01:48:34,220
しかし、事実上、コンピュータの中で
メモリは、我々は来週ことができるようになります

2114
01:48:34,220 --> 01:48:38,470
最初this--再び導入します
array--における当社のデータ構造の

2115
01:48:38,470 --> 01:48:43,530
しかしもっと重要なのは、実際のコンピュータ
科学アルゴリズムが実装さ

2116
01:48:43,530 --> 01:48:47,720
コー​​ド内で、我々は保存できると
このような構造のデータを、

2117
01:48:47,720 --> 01:48:50,730
その後、それを操作するために開始し、かつ
実際の問題を解決するために、

2118
01:48:50,730 --> 01:48:53,570
そしてその上に構築するため、
最終的には、C言語でプログラム、

2119
01:48:53,570 --> 01:48:56,730
Pythonで、JavaScriptで、
SQLでデータベースを照会しますか？

2120
01:48:56,730 --> 01:48:59,980
>> そして、我々はこれらのすべてが表示されます
インターロックさまざまなアイデア。

2121
01:48:59,980 --> 01:49:04,100
しかし、今のところ、ということを思い出します
我々が今日導入ドメイン

2122
01:49:04,100 --> 01:49:06,920
この事はここにあった、と
暗号の世界。

2123
01:49:06,920 --> 01:49:11,200
そして、次の問題、あなたを自分の中で
解決します暗号の芸術です、

2124
01:49:11,200 --> 01:49:13,630
スクランブルとデスクランブル
情報、および暗号化

2125
01:49:13,630 --> 01:49:15,930
そして、テキストを解読、
そして最終的に仮定

2126
01:49:15,930 --> 01:49:18,970
あなたは今何を知っていること
ボンネットの下にあります

2127
01:49:18,970 --> 01:49:21,860
そのため、あなたが参照するか、または受信したとき
このようなメッセージ、あなた

2128
01:49:21,860 --> 01:49:24,060
自分はそれを解読することができます。

2129
01:49:24,060 --> 01:49:26,740
このすべて、そしてより多くの次の時間。

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [ビデオ再生]

2132
01:49:30,790 --> 01:49:32,970
>> -Moverはちょうど到着します。

2133
01:49:32,970 --> 01:49:35,146
私は訪問を行くつもりです
彼の大学教授。

2134
01:49:35,146 --> 01:49:37,611
うん。

2135
01:49:37,611 --> 01:49:40,080
こんにちは。

2136
01:49:40,080 --> 01:49:40,660
それはあなたです。

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
待つ！

2139
01:49:45,110 --> 01:49:45,610
デビッド。

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
私は理解しようとしています
あなたに何が起こったのか。

2142
01:49:56,060 --> 01:49:58,130
、何でも助けることができるしてください。

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
あなたは彼の大学でした
ルームメイト、あなたはありませんでしたか？

2145
01:50:08,354 --> 01:50:10,770
あなたは、ときに彼と一緒にいました
彼はCS50プロジェクトを終えましたか？

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUSICのPLAYING]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>>  - つまりはCS50ました。

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> 私はこの場所が大好きです。

2152
01:50:44,770 --> 01:50:45,854
>> -平らげる。

2153
01:50:45,854 --> 01:50:47,020
私たちは廃業しています。

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END PLAYBACK]

