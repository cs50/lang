[MUSICのPLAYING] 

DAVID J.マラン：すべての権利。 これはCS50およびこれです 2週目の開始です。 そして、あなたはそれを超える思い出し 過去数週間、 我々は、コンピュータを導入してきました 科学とは、順番に、プログラミング。 

そして、我々は、を介して話を始めました スクラッチ、そのグラフィカル言語 MITのメディアラボから。 そして、最近、 先週、私たちはやりました higher-- aを導入します 下位レベルの言語は、既知の C、純粋にテキスト何かとして。 そして、確かに、最後の時間、私たち その文脈の中で模索 概念の数。 

これ、リコール、非常にでした 私たちが見た最初のプログラム。 そして、このプログラムは、非常に単純に、 プリントアウトし、 "こんにちは、世界。」 しかし、そんなにあります 見せかけの魔法が起こっています。 これの#includeがあります これらの角括弧付き。 int型があります。 （ボイド）があります。 括弧、中括弧があります、 セミコロン、およびそんなに多く。 

そしてそう、ということを思い出します 我々はスクラッチを導入しました 私たちは、理想的には、過去を見ることができるように、 その構文、本当にないですもの 知的すべてのこと 早い段階で興味深いが、 、絶対に、少しトリッキーです あなたの心をラップアラウンドします。 そして、確かに、最も一般的なの一つ 早い段階でのプログラミングクラスのもの、 特に以下のもののために 快適でイライラすることです および特定の統語によってアップトリップ エラーは、論理エラーは言うまでもありません。 だから我々の目標のうち、 今日、実際には、意志 いくつかであなたを装備すること どのようにするための問題解決技法 より良い問題そのものを解決するために デバッグの形態です。 そして、あなたは、あまりにも、思い出すことでしょう 我々は導入環境 前回は、CS50 IDEと呼ばれていました。 これは、ウェブベースのソフトウェアです あなたは雲の中にプログラムすることができ、 ので、あなたのすべてを維持しながら、話すこと 我々は再び今日れるように、ファイルを一緒。 そして、その私たちを思い出します ここではこれらのトピックを再訪し、 その中で機能し、ループ、 変数、ブール式、 そして、条件。 そして、我々その実際にいくつかのより多くの スクラッチの世界から翻訳 Cの世界へ 

しかし、基本的なビルディング いわばブロック、 本当にまだ同じ先週でした。 実際に、私たちは本当にちょうど持っていました 異なるパズルのピース、可能ならば。 その代わりに紫の ブロックを保存し、私たちの代わりに である、のprintfました Cでこの関数こと あなたが何かを印刷することができます そして、、画面上でフォーマットします。 私たちは、CS50を導入しました 図書館、あなた あなたの処分のget_charで今持っています、 そして、get_int、およびget_string、 そして、いくつかの他の機能として、 よく、それを介してあなたが入力を取得することができます ユーザー自身のキーボードから。 そして、我々はまた、物事を見ていました these-ブール値、お​​よび文字など、 ダブル、フロート、 int型、long_long文字列。 そして、Cのさえ他のデータ型があります 

あなたが宣言し換言すれば、 いくつかの値を格納する変数、 または、機能を実装する場合 それはいくつかの値を返し、 あなたは何を指定することができます ある値の型。 それは、文字列は次のように、あります 文字のシーケンス？ それは、整数のように、番号はありますか？ それは浮動小数点です 値、など？ だからCで、スクラッチとは異なり、私たちは実際に データの種類を指定するようになりました 我々は戻ってまたは使用していました。 

しかし、もちろん、我々はまた、に走りました コンピューティングのいくつかの基本的な限界。 特に、 この言語C、リコール 私たちが見ていたこと 整数オーバーフロー、現実 あなたが唯一持っている場合に メモリの有限量 または、具体的には、有限数 ビットで、あなただけの非常に高いカウントすることができます。 そして、私たちはここで、この例を見て これにより、飛行機内のカウンタ、 実際には、十分な長さで実行されている場合、希望 ソフトウェアのオーバフローと結果 実際の物理的な潜在的なエラー。 

また、フローティング見 ポイントの不正確、現実 その唯一の有限数で ビットの、それは32か64だかどうか、 あなただけの非常に多くの数を指定することができます 小数点の後、これを使用した後、 不正確な取得を開始します。 で三分の一は、例えば、そのように ここでは、私たち人間の世界では、世界、 私たちは無限の数を知っています 小数点以下3秒の。 しかし、コンピュータが必ずしもできません 数字の数が無限であることを表します あなたが唯一許可されている場合、それいくつかの 情報の有限量。 

だから私たちはあなたを装備しただけでなく、 面で大きな力を持ちます あなたがで自分を表現する方法の プログラミングの観点から、キーボード、 我々はまた、どのような制限され あなたが実際に行うことができます。 そして実際、バグやミスができます 問題のこれらの種類の中から生じます。 そして実際、トピックの中で今日 デバッグのようなトピックであることを行っています そして実際にボンネットの下に見て 物事は先週紹介した方法で、 実際に実装されています あなたより良いように 両方の機能を理解し、 C.のような言語の制限 

そして実際に、我々は層をバックはがします データ構造の最も単純なの、 配列と呼ばれるもの、その スクラッチは、呼び出すために起こる」リストを。」 それは少しです そのコンテキストで異なります。 そして、我々はまた、のいずれかを紹介します 私たちのドメイン固有の問題の最初の CS50、の世界では 暗号化、スクランブルの芸術 または情報を暗号でそう あなたは秘密のメッセージを送ることができます そして、秘密のメッセージを解読 二人、AとBの間 

そこで、遷移前 その新しい世界へ、 それでは、いくつかであなたを装備してみましょう あなたは排除することが可能な技術 または少なくともいくつかを軽減 欲求不満の あなたはおそらく発生していること 一人で、過去一週間以上。 実際には、あなたの前のいくつかをsuch--されています C.そしてオッズであなたの最初の問題があり、 あなたが私に似ている場合は、初めて あなたがプログラムを入力しようと、 あなたは論理的に考える場合でも、 プログラムは非常に簡単です、 あなたは非常によく壁にぶつかる可能性があり、 コンパイラは、協力するつもりはありません。 メイクやクランは行っていません 実際にあなたの入札を行います。 

そして、なぜそれがあるかもしれませんか？ さて、見てみましょう、 おそらく、簡単なプログラム。 私は先に行くと、これを保存するつもりです 故意にbuggy0.cと呼ばれるファイル、 私はそれを知っているので、 事前に欠陥があります。 しかし、私はこの場合ことを認識しない場合があります 第一又は第二又は第三のプログラムであります 私は実際に自分自身を作ってるんだということ。 だから私は先に行くつもりだと 、int型メイン（ボイド）を入力します。 そして、私の中括弧の内側に、 こんにちは、world--（「非常に精通して バックスラッシュ、n個 "） - およびセミコロン。 

私は、ファイルを保存しました。 今、私がダウンして行くつもりです 私の端末ウィンドウに タイプメイクbuggy0、なぜなら、再び、 ファイルの名前、今日はbuggy0.cです。 だから私は入力して、buggy0を作る入力します。 

そして、ああ、まあ、前回からリコール エラーメッセージが表示されないことは良いことです。 だから、何も出力は良いことではありません。 しかし、ここで私が明確に持っています ミスをいくつか。 

出力の最初の行だから buggy0を作る入力した後、リコール、 クランのかなり詳細な出力です。 ボンネットの下に、 CS50 IDEが構成されています の全体の束を使用するには このコンパイラでのオプション あなたが持っていないように、 それらについて考えて。 そしてそれはすべてのこと最初の行です クランで始まる手段。 

しかし、その後、問題 その外観を作るために始めます。 3行目のBuggy0.c、文字 図5は、大きな、赤いエラーがあります。 それは何ですか？ 暗黙的にライブラリ関数を宣言 int型（のconst char型*とのprintf、 ...）[-Werror]。 私は非常に迅速に、それを意味します 非常に難解な取得します。 そして確かに、最初は 一見、我々はないでしょう あなたが理解することを期待 そのメッセージの全体。 レッスンのだから1 今日のために起こっています 気づくしようとすることにします パターン、または類似のもの、 あなたが持つかもしれないエラーに 過去に発生しました。 これだけ離れていじめるしましょう 見覚えがそれらの言葉。 大きな、赤いエラーが明らかに 間違っている何かの象徴。 

暗黙的に宣言 ライブラリ関数のprintf。 だから私は非常に何を理解していない場合でも、 暗黙的にライブラリ関数を宣言 手段、きっと問題 何とかprintfのためにも関します。 そして、その問題の原因 それを宣言するに関係しています。 

関数である宣言 最初にそれを言及。 そして、我々は先週の用語を使用しました 関数のプロトタイプを宣言する、 いずれかの上部に1行を使用して 自分のファイルやいわゆるヘッダファイルインチ そして、何のファイルに私たちは言っていました 先週のprintfが引用であることを、 引用終わり、宣言？ どのようなファイルでは、そのプロトタイプはありますか？ 

私は非常に最初の事、あなたが思い出すのであれば 入力された、ほぼすべてのプログラム最後time-- そして、誤って一瞬前に開始 myself--を入力すると、この1 here--ました hash--する#include <stio--用 入力/ output--ドット時間そして実際、 私は今、このファイルを保存した場合、私は行きますよ 先に行くと私の画面をクリアするには、 あなたは次のように入力して行うことができます クリア、またはあなたは、コントロールLを保持することができます ちょうどあなたのターミナルウィンドウをクリアします ただ、いくつかの混乱を排除します。 

私は先に行くつもりだと 再タイプ入力し、buggy0を作ります。 出来上がり、私はまだことを確認します クランからの長いコマンド、 しかし、エラー・メッセージは、この時間ありま​​せん。 そして実際、私は./buggy0をすれば、 ちょうど最後の時間のように、 ドットは、このことを意味します ディレクトリは、スラッシュだけで、意味します ここでは、プログラムの名前が来て、 プログラムの名前は、buggy0です 「こんにちは、世界。」、入力してください 

さて、どのようにあなたが持っているかもしれません このソリューションを収集 必ずしもなし 多くの単語を認識 私がしたように、確かに、持ちます 非常に多くの年のためにこれを行って？ さて、最初の問題ごとに実現 設定し、我々はコマンドを紹介します そのCS50自身のスタッフ 呼ばれるhelp50を書きました。 そして実際、Cはの仕様を行います 問題は、これを使用する方法のように設定します。 

しかし、本質的help50です プログラムCS50のスタッフ それはあなたが実行することができます書きました コマンドまたはプログラムを実行し、 あなたは理解していない場合は、その 出力は、help50に出力を渡します その時点でのソフトウェア コー​​スのスタッフが書きました あなたのプログラムの出力を見ていきます 行単位、文字単位。 そして、私たちは、スタッフが、認識している場合 あなたが経験しているエラーメッセージ、 我々はいくつかであなたを挑発しようとします いくつかのアドバイスと反語、 TFまたはCAや私のような多くの 営業時間で一人で行うだろう。 

そうしないのであればhelp50に見えます 必ずしも問題を認識しています。 しかし、それに依存しません 松葉杖としてあまり。 確かに理解しようと、その 出力し、それから学びます これだけ一度か二度あなたが行うこと これまで、特定のエラーのためにhelp50実行 メッセージ。 その後、あなたはする必要があります より良い自分自身を装備 それは実際にあるかを把握します。 

それでは、ここで他のいずれかの操作を実行してみましょう。 私は先に行ってみよう、と別で ファイル我々はこのbuggy1.cと呼ぶことにします。 そして、このファイルには、私はよ deliberately--に行きます しかし、私にはないふりをします 私が作ったものの間違いを理解しています。 

私は先に行くとthis--するつもりです #include、私がしたので 少し前から私の教訓を学びました。 int型メイン（ボイド）、前と同じように。 そして、ここで私は行きますよ get_string  - 文字列sを行います。 そして、その最後の時間からリコール これは、ちょっと、コンピュータを意味し、 私に変数を与え、よそれを呼び出すと、 その変数の型文字列を作ります 私はそれで1つまたは複数の単語を保存することができます。 

そして、右側の上 等号の側 である、get_stringされます CS50ライブラリの機能 それはまさにそれを行います。 これは、その関数を取得し、 右から左に手を。 したがって、この等号は意味するものではありません 私たちは数学に思うかもしれないとして、「等しいです」。 これは、右から左への割り当てを意味します。 だからこの意味から、文字列を取ります ユーザーおよびsの中に保管してください。 

今度はそれを使用してみましょう。 私は今、第二のように先に行ってみよう ラインは、私が先に行くと、「こんにちは」と言ってみましょう -  ない "世界"が、 "こんにちは、％-S- これは私たちのプレースホルダ、コンマsは、 これは私たちの変数であり、 した後、セミコロン。 だから私はあまり台無しにしなかった場合 ここでは、これは正しいコードのように見えます。 

そして、私の本能は今それをコンパイルしようとしています。 ファイルはbuggy1.cと呼ばれています。 だから私は、buggy1を作るのですか入力するつもりです。 そして、くそ-それを、存在しない場合 以前よりさらに多くのエラー。 私が意味する、より多くのがあります エラーメッセージには、希望 このプログラムで実際のラインよりも見えます。 

しかし、ここでお持ち帰りは、 あなたが圧倒している場合でも、 2または3で 4つのエラーメッセージ 非常に常に焦点を合わせます これらのメッセージの最初の。 最上位の1を見てみると、 である必要があるとして、バックアップスクロールします。 だからここに私はメイクbuggy1を入力しました。 ここではクラン出力が期待通りにことです。 

そして、ここで最初の赤色のエラーです。 宣言されていない識別子の使用 文字列は、私は標準を意味するのですか？ だから、標準では、 実際に何か他のもの。 これは、ユーザを指し キーボード、本質的に。 

しかし、それは何を意味しません。 私は文字列を意味し、私はget_stringを意味していました。 だから、私こと何です この時間を行うのを忘れましたか？ 何がこの時間を欠けていますか？ 私は自分の#includeを持っています、 私はprintfのへのアクセス権を持っています。 

しかし、私は何を持っていません まだへのアクセス？ まあ、ちょうど最後の時間のように、 私は、コンパイラに指示する必要があり これらの機能が何であるかを打ち鳴らします。 Get_stringは付属していません。 C.と、特に、それを に付属していません。 、ヘッダ・ファイル。 それは、代わりに来ます スタッフが書いたもの、 これは異なるファイルであります 名前ではなく、適切な名前。 

だから、単純に1行を追加して 前回からcode--リコール クランの実行時に、それが起こっていること 下に私のコードの上部を見て、 左から右へ。 気づくことだろう ああ、あなたがしたいです。 私が行くとそれを見つけてみましょう、 どこそれがサーバー上にあります、 基本的に、コピーして貼り付け、 独自のファイルの先頭に その結果、物語の中で、この時点では、 ライン1、プログラムの残りの部分 、確かに、関数のいずれかを使用することができます その中で、それらの間get_string。 だから私は無視するつもりです これらのエラーの残りの部分、 私は、確かに、それだけで疑われる理由 最初のものは、実際に大事。 そして、私は先に行くと、再実行するつもりです、 私のファイルを保存した後buggy1を作ります。 出来上がり、それは仕事をしてくれました。 そして、私は./buggy1を行うと、ために、入力した場合 インスタンスは、Zamylaは、私は今、こんにちは取得します Zamyla、代わりのこんにちは、世界。 

大丈夫。 だからここに持ち帰り、その後にされ、 1、あなたはできる限りを収集してみてください 単独でのエラーメッセージから、見て 認識可能な単語の一部で。 あたりをhelp50使用することを除けば 問題は、仕様を設定します。 しかし、あまりにも、常に見て、ことを除けば トップエラー時のみ、少なくとも 最初に、どのような情報を表示するには それが実際に得られるかもしれません。 しかし、それはそこのが判明します さらに多くの機能が組み込まれて CS50ライブラリに支援します 学期中の早い段階であなた 早期でのプログラミングで 間違って何が起こっているのかを把握します。 それでは、ここでは別の例を実行してみましょう。 私は、このbuggy2を呼ぶつもりです、 再び、アウト欠陥があるとしています 設計により、ゲートの。 

そして、私は先に行くつもりです そして、の#includeを行います。 そして私はint型メイン（ボイド）をするつもりです。 そして私は、forループをするつもりです。 （iは0 _ int型のため。 iが10以下です。 私は++、その後、中括弧で、私が行きますよ ここだけのハッシュタグのシンボルをプリントアウトします そして、改行文字。 

これにだから私の意図 プログラムは非常に単純です 10回反復します 各繰り返しで そのループ毎回の サイクルを通じて、 ハッシュタグをプリントアウトし、 ハッシュタグ、ハッシュタグ。 1行に1つのI理由 そこに新しい行を持っています。 そして、するためのことを思い出してください 最後week--あたりのループ、 あなたはより多くを得るでしょう 構文に精通しています 練習でそれを使用して、 long--これは私を与える前に、 変数iと呼ばれ、0に設定します。 

これは私の上のインクリメント 1によって反復ごと。 だから私は2〜3に1になります。 そして、この状態で セミコロンの間の中間 作るために反復ごとにチェックします 我々は範囲内であることを確認してください。 だから私は10回を反復処理したいので、私 ちょうど種類の非常に直感的に持っています そこに私の上限として10を置きます。 

そして、まだ、私はこれを実行すると、後 メイクでそれをコンパイルしbuggy2-- そして、それはOKコンパイルありません。 だから私は持っていません 構文エラーこの時間。 私は今、先に行ってみましょう そして、入力し、buggy2を実行します。 そして今までスクロールします。 そして、私は増加してみましょう ウィンドウのサイズ。 

I 1、2、3を持っているように見えます、 4、5、6、7、8、9、10、11。 だからにもかかわらず、11ハッシュタグをあります 私は明らかにこのループの内側に10を置きます。 今、あなたのいくつかは、すぐに表示される場合があります エラーは、実際に、これはどのような 作るために非常にハードエラーではありません。 しかし、それは非常に一般的です 非常に早い段階で作られました。 

私が指摘したい、しかし、 私はこれを理解する方法、ありますか？ まあ、それはことが判明します CS50ライブラリが付属してい get_stringとget_intないだけで get_floatおよびその他の機能と。 また、特別な機能が付属しています 呼ばれるeprintf、または、エラーのprintf。 そして、それは作るためだけに存在しています それあなたのために少し簡単に ちょうどにあなたのコードをデバッグするとき 画面にエラーメッセージを出力 それがどこから来たと知っています。 

だから例えば、一つのことは私がかもしれません この関数はthis--であるとここで行います eprintf、その後、私は先に行くつもりです そしてiは、バックスラッシュ、nは今％であると言います。 そして、私はiの値をプラグインするつもりです。 そして、トップアップ、このため、 CS50ライブラリであり、 私は先に行くつもりです とが含ま 私は、この機能にアクセスすることができます。 しかし、それでは、どのような行を検討してみましょう 9がやっていることになっています。 私は最終的にこれを削除するつもりです。 これは何の関係もありません 私の包括的な目標を持ちます。 しかしeprintf、エラーのprintfは、単に意味します 私にいくつかの診断情報を得ることができます。 私は私のプログラムを実行すると、私がしたいです 一時的に画面上でこれを参照してください。 同様に、単に理解します どうしたの。 

そして、確かに、上の各 ここでは9行目の反復 私が見たいと思って、iの値は何ですか？ iの値は何ですか？ iの値は何ですか？ そして、うまくいけば、私はすべき そのメッセージ、また、10回を参照してください。 

だから私は先に行くとしましょう 私のプログラムを再コンパイルし、 私はいつでもしなければならないとして、 私は変更を行います。 ./buggy2。 そしてnow-- OK。 より起こっがたくさんあり​​ます。 だから、私が上にスクロールさせます さらに大きな窓。 

そして、あなたは、そのそれぞれが表示されます ハッシュタグはまだ印刷されています。 しかし、それらのそれぞれの間で今、このです 次のように診断出力がフォーマットされています。 ここに私のプログラムの名前はbuggy2です。 ファイルの名前はbuggy2.cです。 そこから行番号 これは、9行目で印刷しました。 そして、その右にあります 私は期待していたエラーメッセージ。 

そして、何これについての素晴らしいのは、ということです 今私は必ずしもカウントする必要はありません 私の頭の中で私のプログラムは何をやっています。 私が上でそれを見ることができます 最初の反復は、iが0です、 その後1、次に2、その後3、その後4、その後、 5、その後6、その後7、その後8、その後9、その後、 10。 だから、ちょっと待って。 何が起きてる？ 私はまだカウントしているように見えます 10までの意図したとおり。 

しかし、ここで私が始めたのですか？ 0、1、2、3、4、5、6、7、8、9 10。 そう0、1、2、3、4、5、6、7、 8、9、10--第11回指 問題を示しています。 私が数えているように見えます 間違って私のループインチ 10回の反復を行くのではなく、 私は、0から始まりますよ 私は時と10を介して終了しています。 しかしため、コンピュータのような、 私は、0でカウントを始めています 私がカウントアップされるべきです のではなく、10を介して。 

そしてそのように修正、私は最終的に ここで実現し、2つのいずれかです。 私は非常に簡単に言うことができます 10未満までカウント。 そう0、1、2、3、4、5、6、7、8、 、確かに、正しい9、 それは少し間違って聞こえるにもかかわらず。 または私は以下を行うことができます 9に、あまりにも長い間、私は0から始まりとして。 それとも、本当にそれを好きではない場合は、あなたを 10を介してカウントアップが、1で開始することができます。 しかし、再び、これだけでは一般的ではありません。 programming--ではあるが Scratch--であまりありません しかし、プログラミングの中で Cと他の言語、 JavaScriptと同様の Pythonと他の人、それはです 以下のためだけの非常に一般的な バイナリの議論 ただでカウントを開始します 0であることができます最も低い番号、。 大丈夫。 だから、eprintfです。 そして再び、今、私は私を考え出したこと 問題は、私は0に戻って行くつもりです 10未満を通じて、私は行きますよ 行くとeprintfを削除します。 

とき、私にはあってはなりません 私のコードを出荷するか、私のコードを提出 または他の誰に見せます。 それは本当にただ意味しています 一時的に使用されます。 しかし、今私はこれを修正しました 同様に特定の問題。 

さて、ここでもう一つの例をやらせます 私は次のようにかき立てるするつもりだということ。 私は先に行くつもりだと #include。 $ 50 そして、私は先に行くつもりです そして、の#include。 

そして、私は保存するつもりです buggy3.cとしてこのファイル。 そして、私は先に行くつもりです そして、int型メイン（ボイド）を宣言。 そして、そこの内側 私は私_ intをするつもりです -  私はプログラムを実装したいです get_negative_intと。 これはまだ存在して関数ではありません。 だから我々は、実装するつもりです それだけで一瞬インチ しかし、我々は理由を確認するつもりです それは最初のパスでバギーです。 そして、私は得ている一度 ユーザーからint型、 私はちょうど私が否定的である％を印刷するつもりです 整数、バックスラッシュ、nは、カンマ、私。 換言すれば、全てのI このプログラムはやってみたいです からの負のintを取得され、 ユーザーは、その後、プリントアウト そのような、そのような負のintです。 

今、私はこの機能を実装する必要があります。 だから、後で私のファイルで、私は行くつもりです 先にと呼ばれる関数を宣言 get_negative_int（ボイド） - そして我々ます その行が再び何を意味するのかに戻ってきます moment-- int型ではn; do-- DO following--のprintf nは：です。 そして私は、nをするつもりです -  get_intを、 この一方、nが0よりも大きいですか。 そしてnは返す;. 

だからで起こっている多くがあります これが、私たちはしなかったそのうちのどれも 少なくとも簡単に、先週見てください。 そこでここでは10行目に、私は宣言しました get_negative_int呼び出された関数、 そして、私はで、（ボイド）を入れています 括弧、その理由は、このされます 入力を取ることはありません。 私は何を渡していませんよ この関数へ。 私はちょうど戻って、そこから何かを取得しています。 

そして、私はに何を望んでいます 取り戻すの整数です。 にデータ型が存在しません Cはnegative_intと呼ばれます。 それはちょうどint型ですので、それは起こっています 私たちの上にあることを確認します その実際の価値 返されるだけint型ではありません 負です。 

12行目では、私は変数を宣言しています nおよびint型のそれを作ると呼ばれます。 そして、18を通る線13で私はよ 何かが真である間、何かをやって。 私は先に、印刷つもりです nは、コロン、次にスペース、 ユーザのプロンプトのような。 

私は、get_intを呼んだし、 そのいわゆる戻り値を格納します その変数nインチ しかし、私はやり続けるつもりです この一方、nは0より大きい。 言い換えれば、ユーザが私与える場合 INTとその数は、0より大きい エルゴは、肯定的な、私はするつもりです ただユーザーをreprompting保ちます、 それらを強制することにより、repromptingを保ちます 協力してくれ負のintを与えます。 

そして、一度nは実際にnegative-- 、最終的にはタイプ-50ユーザーを想定 このwhileループはもはや真実ではありません -50が0より大きくないからです。 だから我々はそれから抜け出します ループは、論理的かつn返します。 

しかし、他の1があります 事は私がしなければなりません。 そして、私は単純にこれを行うことができます コピーと貼り付けによって、 ファイルの先頭に1行のコード。 私は、クランを教える必要があります または、打ち鳴らすことを約束 明示的に私がすること、 確かに、行くと実装 この関数get_negative_int。 それはちょうどファイルに低くなる可能性があります。 ここでも、そのクランを思い出します 上から下に物事を読み込み、 左から右へ、そうあなたがすることはできません クラン場合、関数を呼び出します 存在することが起こっているのを知りません。 

さて、残念ながら、このプログラム、 あなたのいくつかは気づいたかもしれませんとして、 すでにバグがあります。 私が先に行くとbuggy3を作ってみましょう。 私の問題は今ではないので、それは、コンパイル 構文エラー、テキスト形式のエラーのような、 実際には論理的なことになるだろう 私は意図的にしましたエラー への機会として作られました 何が起こっているのかをステップ。 

私は先に行くつもりです 今とbuggy3を実行します。 そして、私は行くつもりです 先にではなく、協力しています。 私はそれを数1を与えるつもりです。 それはそう、それを好きではなかったです それが再び私を促すです。 

どのように約2？ 3？ 50？ それらのどれも機能していません。 どのように約-50？ そして、プログラムが動作するようです。 

私はもう一度それを試してみましょう。 私は-1を試してみましょう、動作するように思われます。 私は-2を試してみましょう、動作するように思われます。 私は0を試してみましょう。 ハァッ、それは正しくないのです。 今、私たちはここで少し知識をひけらかすされています。 しかし、それは、確かに、0の場合です 正でも負でもありません。 それで、私のプログラムは、事実であること 0が負の整数であることを言って、 それは技術的に正しくないです。 

今、なぜそれがこれをやっているのですか？ まあ、それは明白であるかもしれません。 そして、確かに、プログラムがあります かなり単純であることを意味し 私たちは探検するために何かを持っています。 

しかし、それでは、第三のデバッグを紹介しましょう ここdebug50と呼ばれる技術。 だから、これはプログラムであり、 私達はちょうど作成したことを 今年呼ばdebug50 それはあなたをできるようになります ビルトインと呼ばれるものを使用します CS50 IDEでグラフィカルなデバッガ。 そして、デバッガはそのちょうどプログラムです 一般的に、あなたのプログラムを実行することができます しかし、ステップ、ラインバイステップバイステップ 行単位により、突っつい、一時停止 周りに、変数を見ているので、 プログラムはあなたを越えて吹きません かつ迅速に何かを印刷 か何かを印刷しません。 それはで、あなたにチャンスを与えます 人間の速度は、それと相互作用します。 

そして、これを行うには、 単純に次の操作を行います。 あなたのコードをコンパイルした後、 これは私はすでにやった、buggy3、 あなたが先に行くとdebug50 ./buggyを実行します。 help50のようなので、多くのあなたが実行されました help50してから、コマンド、 debug50あなたはdebug50を実行しており、 その後、コマンドの名前。 

今私の画面上に何が起こるか見て、 特に右側の。 私は、すべてを実行]を押すと 突然この右側のパネル 画面上に表示されます。 そして、行くたくさんあり​​ます 一見に。 しかし、あまりにもそこにはありません まだ心配するくらい。 

これは私にすべてを見せています それは私のプログラムの内部で起こっています 今、これらを介して、 トップアップボタンはその後です 私は私のコードをステップ実行することを可能にします 最終的にステップバイステップバイステップ。 それだけではない、まだ。 何が起こるかに注目してください。 私の端末ウィンドウで、 私はn個の入力を求められています。 そして、私は先に行くつもりだし、 -1にこの時間と種類を協力しています。 そして、はいえ少しひそかに、-1 予想されるように、負の整数です。 

そして、子供はで終了しました 出ステータス0 GDBSERVER。 GDB、GNUデバッガは、名前です。 基盤となるソフトウェアの それは、このデバッガを実装しています。 しかし、すべてこれは本当に、デバッガを意味します 私のプログラムが終了したために去っていきました そしてすべてが順調でした。 私は本当に私のプログラムをデバッグしたい場合は、 私は先制debug50を伝える必要があり、 ここで私は開始したいです 私のコードをステップ？ 

そしておそらく最も簡単な方法 次のようにそれを行うことです。 私は上にカーソルを移動した場合 ここに私のエディタのガター、 だから本当にちょうどここのサイドバーで、 行番号の左に、 私はちょうどクリックするとことがわかり かつて、私は少し赤い点を置きます。 そして、その小さな赤い点、 一時停止の標識のような、ちょっと、意味、 debug50、私のコードの一時停止の実行 右が、私はこのプログラムを実行するとき。 

それでは、それをやらせます。 私が先に行くと私のプログラムを実行してみましょう 再びdebug50 ./buggy3と、入力してください。 そして今、何かに気付きます 異なるが起こっています。 私は、プロンプトが表示されていませんよ まだ私の端末ウィンドウで 何のために、ので、私はそうではありません 私のプログラムではまだ頂いております。 8行目のことに注意してください 今強調表示され、 そして、で小さな矢印があります 左のことわざは、あなたはここで一時停止されています。 このコード行、行 8は、まだ実行されていません。 

私が見た場合と、好奇心が強いものです 右側にこっち、 私はローカルであることに気付きます 意味でのローカル変数、 ことは、現在の関数内です。 その値、どうやらデフォルトでは、 ソートの便利な、0です。 しかし、私は0を入力しませんでした。 それはちょうど、そのことを起こります 現時点ではデフォルト値。 

だから私は先に行くと、今これを実行しましょう​​。 私は先にと上に行こう 右ここでトップ、私はよ 先に行くつもりと この最初のアイコンをクリックします 以上のステップは省略しない手段 それが、このコード行をステップオーバー、 道に沿って、それを実行します。 

そして今、私の、気付きます プロンプトがちょうど変更されました。 何故ですか？ 私はdebug50を言いました、 このコード行を実行します。 このコード行は何をするのでしょうか？ int型のために私を求められます。 OK。 私は協力しましょう​​。 私は今、先に行くと、-1を入力し、入力してみましょう。 そして今、何が変更されたかがわかります。 右側に、 私の地元の変数i ある-1今として示されています。 そして、それはint型はまだです。 

そして通知は、あまりにも、私のいわゆる 私は一時停止しなかったコールスタック、？ 私たちはについての詳細を説明します 将来的にこの。 しかし、コールスタックは、単に何を指し 機能は、運動に現在あります。 今それはちょうどメインです。 そして今だけのローカル 変数が1の値を持つ私です。 

そして、私は最終的にこの行をステップオーバー時 ここでは、右上の同じアイコンで、 -1負の整数です。 今では、その中括弧の上に一時停止しています。 のは、そのことをやらせるましょう。 私は、その行をステップオーバー、出来上がり。 

そうではないすべてのことひどく 、啓発まだ しかし、それは私が一時停止させました そして論理的に考え抜きます このプログラムは何をやっています。 しかし、それは誤ったケースはなかったです。 次のようにのは、再びこれをやってみましょう。 

私はそのブレークポイントを残すつもりです 赤い点と8行目。 私はdebug50を再実行するつもりです。 それは自動的にここに一時停止しています。 しかし、この時、代わりに この行をステップオーバー、 私は実際の内側に行こう get_negative_intと把握、 なぜそれが有効な回答として0を受け付けていますか？ 

だから、代わりにステップオーバーをクリックします。 私は先に行くつもりです そしてステップイン]をクリックします。 そして、8行目だということに気づきます 今突然今強調表示 17行になります。 

今、それはデバッガことはありません ライン14,15および16をスキップしています。 それだけでは何もありませんです そこにあなたが表示されます。 それらは単に変数を宣言しています、 そして、その単語があるんです そしてその後、左中括弧。 唯一の機能ライン ジューシーは本当にここにこの1、17です。 そして、私たちがきた場所なのです 自動的に一時停止。 

だからのprintf（ "n.is："）;,そう それはまだ起きていません。 それでは、先に行くとステップオーバー]をクリックしてみましょう。 今私のプロンプト、確かに、 （ "nは次のとおりです。"）に変更。 今、私はつもりはない、get_int 足を踏み入れる邪魔して、 その関数があったので、 図書館にCS50によって行われました。 それはおそらく正しいです。 

だから私は先に行くつもりだと ソートのそれを与えることで協力 int型ではなく、負のint型。 だから私は先に行くと0を打ってみましょう。 そして今、何がここで起こります 私はダウンライン21に到達したとき？ 私は再び繰り返されていませんでした。 私はそのループ内で立ち往生していないようです。 換言すれば、この黄色 バーは、周り続けるありませんでした そして、その周辺、そして周り。 

さて、それはなぜですか？ まあ、nは、今何をnとしますか？ 私は地元で見ることができます デバッガの変数。 nが0です。 すべての権利、私の条件は何だったのでしょうか？ 

20--ライン20は、十分にあり、 0は0より大きい。 それは事実ではありません。 0は、0よりも大きくありません。 そして、私はこのうち破りました。 

そして、そのためには、理由のライン上にあります 21、私は実際に続けば、 私も、0を返すつもりです 私は0を拒否している必要がありますけれども 実際に否定的ではありません。 だから今、私は本当にさえません デバッガを気に。 それを得た、私はする必要はありません 何が起こっているかをより知っています。 

だから私は先に行くつもりだと 単に再生ボタンをクリックし、 この仕上げアップをしましょう​​。 今、私は私の気付きました バグがライン20上明らかです。 それは私の論理エラーです。 

だから、私は何をしたいです これを変更するために行うには？ 問題は、私はないよということであれば 0をキャッチ、それだけで論理エラーです。 nがある一方で、私は言うことができます 0以上、 何度も何度もユーザに促す保ちます。 

だから、再び、単純なミス、おそらく あなたが私を見たときであっても明白 ほんの数分前にそれを書きます。 しかし、ここでお持ち帰り それは、デバッグ50であります そして、デバッグと ソフトウェアより一般的には、 あなたは、この新しい発見力を持っています 見て、独自のコードを歩きます その右側のパネルを介したもの あなたの変数の値です。 だから、必ずしもありません 何かを使用する必要があります あなたはそれらの値を印刷するeprintfなど。 あなたが実際にそれらを見ることができます 視覚的に画面上に。 

さて、これ以上、それは注目に値します だ別の技術がありますことを 実際にスーパー共通。 そして、あなたは、なぜ、この少し不思議に思うかもしれません ここで男は、ステージの上に座ってきました。 したがって、この技術は、一般的に、あります ゴム製のアヒルのデバッグとして知られ、 これは本当にただです 事実を証明するもの その多くの場合、プログラマ コー​​ドを書いています、 彼らは必ずしもないです 他の人と協力し、 または共有環境での作業。 

彼らは自宅でのソートのです。 多分それは夜遅くです。 彼らは図にしようとしています 自分のコード内のいくつかのバグアウト。 そして、彼らはそれを見ていません。 

そして、何のルームメイトはありません。 何のTFはありません。 周辺にCAはありません。 彼らは棚の上に持っているすべての この小さなゴム製のアヒルです。 

そしてそうゴム製のアヒルのデバッグ ちょうどこの招待状です 愚かな何かを考えて 本物の生き物のように、このよう、 実際にあなたのコードを歩きます 口頭この無生物へ。 したがって、例えば、もし これは私の例でありますhere-- そしてその先にリコール 問題は、このました 私はこのコードの最初の行を削除した場合、 そして、私は先に行くと、再びバギー0を行い、 私はこれらを持っていたことを思い出して ここでエラーメッセージ。 だから私しかしばかげここでの考え方、 公にこれを行う瞬間に感じます、 そのエラーです。 

[OK]を、ので、私の問題は、私がしたことです 暗黙的にライブラリ関数を宣言しました。 そして、そのライブラリ関数はprintf関数です。 OK Declare--、宣言 プロトタイプのことを思い出します。 

それは私が実際にする必要があることを意味します 事前にコンパイラに伝えるもの 関数は次のようになります。 ちょっと待って。 私は標準io.h.を持っていませんでした どうもありがとうございました。 

あなたof--だから、このプロセス 実際にアヒルを持っている必要はありません。 しかし、歩行のこのアイデア 自分独自のコードを介して、 あなたも聞くように あなた自身、あなたのように あなた自身で脱落を実現 発言は、一般的に考えです。 

そして、おそらくもっと論理的ではないので、 その1が、より複雑で多くの 例えば私たちは、バギー3.Cで行いました あなたはそれを介して自分自身を歩くことがあります 次のように。 したがって、すべての権利、ゴム ダッキー、DDB、可能ならば。 ここでは、私のメインの機能を持っています、 私は負のintを取得呼んでいます。 

そして、私は戻り値を取得しています。 私は左側にそれを格納しています 私と呼ばれる変数で8行目。 [OK]を、しかし、待って、どのようにしました それは、その値を取得しますか？ 私は12行目で関数を見てみましょう。 

12行目では、我々は負のintを取得しています。 任意の入力を取りません、 [OK]、int型を返すん。 私はライン14、変数nに宣言します。 整数を格納するために起こっています。 それは私が欲しいものです。 

nはせis--ながらだから、次の操作を行います 私は、修正プログラムが私はすでに作ったもの元に戻します。 nがより大きいつつ 0は、[OK]を、Nでプリントアウト。 そして、int型のnに格納されます呼び出します。 nが0である場合、次に、チェック nがnot--そこにそれがあります。 だから、もう一度、あなたはしないでください 実際のアヒルが必要です。 しかし、単に自分自身を歩きます 知的運動としてあなたのコード 多くの場合、あなたを助けます 何が起こっているの実現、 ちょうど何かをするのではなく、 このように、画面を見つめ、 そして、自分自身を介した話ではありません 正直なところではないこと、 ほぼ有効な手法として。 だから、あなたが持っていること、 多数の異なる技術 実際にあなたのコードをデバッグするための そして、それらのすべてを、障害を見つけます あなたのツールキットのツールであるべきです あなたが夜遅くじゃないように、 特に、あなたはダイニングにいます ホール、またはオフィスの時間で、 頭を強打 壁は、いくつかの問題を解決しようとします。 ソフトウェアツールが存在することを理解。 ゴム製のアヒルのツールがあります。 そして、全体のスタッフがあります 手を貸すのを待ってサポートしています。 

だから今、問題に単語は セット、私たちはあなたを期待しているものに それらの外に出て、どのように 我々は評価に取り掛かります。 コー​​スのシラバスあたり、 CS50の問題セット そう、4つの主要な軸で評価されています スコープをspeak--するために、正確性、デザイン、 そして、スタイル。 そして、範囲は、どれだけのことをいいます 作品のあなたはオフにかましていますか？ あなたはどのように問題の多くを試してみましたか？ 努力のどのレベル あなたは明らかにしていますか？ 

正しさは、そのままプログラムの作業を行います それは、CS50の仕様あたりになっています あなたは、特定の入力を提供するとき または特定の出力が戻ってきますか？ デザインは、それらのほとんど主観的なものです。 そして、それはその意志一つです 学ぶために最長を取ります で、教えることと最長 これまでのところ、それはつまるところとして、 あなたのコードは、どのようによく書かれていますか？ 

それはちょうど、正しいを印刷するために一つのことです 出力または正しい値を返します。 しかし、あなたはのようにそれをやっています 効率的に可能な限り？ あなたはそれを除算を行っています そして征服、またはバイナリ 我々はすぐに我々がやったことがわかりますように、検索 2週間前の電話帳と？ 解決するためのより良い方法があります あなたが現在ここに持っているより問題？ それはよりよい設計のための機会です。 

そして、どのようにstyle-- かなりあなたのコードはありますか？ あなたは、私はかなりだと気づくでしょう 私のコードをインデントについて特に、 そして、確信して私の変数を作ります 合理的に命名されます。 nは、 短いながら、ために良い名前です 番号、計数整数iについて、 文字列sの。 そして、我々は長く持つことができます 変数名のスタイル。 スタイルはどれだけ良いです あなたのコードが見えますか？ そして、それはどのように読み取り可能ですか？ 

そして時間をかけて、何あなたのTA そして、のTFは、コースで行います それをあなたに提供されています 質的なフィードバックの種類 あなたが良くなるように、 これらのさまざまな側面で。 そして、どのように我々の観点から これらの軸の各々を評価し、 それは非常に少数で、一般的です バケツ一般的に、あなたがそのように、 あなたがやっているどれだけの感覚を得ます。 そして、確かに、あなたはスコアを受信した場合に これらのaxes--正しさ、デザインのいずれか そして、スタイルがその数をespecially-- 一般的には1と5の間であろう。 そして、文字通り、あなたが取得している場合 学期の開始時に3の、 これは非常に良いことです。 それはまだあります意味します 改善の余地、 あなたは内の希望であろう 初めてのクラスを取ります。 天井の一部のビットがうまくいけばあります これにあなたが到達する志望しています。 そしてそう3の上を取得 最も初期の作品、 そうでない場合は、いくつかの2者と4の、 、確かに、良いことです。 これはよく範囲内ですが、 よく予想内。 

あなたの心はレースをされている場合や、待ちます 分、5のうち3。 それは本当に10のうち6です。 それは60％です。 F.だ私の神、 

そうではありません。 それは、実際には、それはありません。 むしろ、それは改善する機会です 学期の経過。 そして、あなたはいくつかを取得している場合 プアーズ、これらの機会です オフィスアワーを活用するために、 確かセクションおよびその他のリソース。 

ベストは、本当に、機会です あなたがきたどれだけ遠くの誇りにします 学期かけてきます。 何もないのであれば、実現しますか 他に、3人は良いです。 そして、それは時間をかけて成長の余地を可能にします。 

これらの軸があるかについては 加重、現実的にあなたがしています 取得あなたの時間の大半を過ごすつもり 正常に動作し、ましてやするもの。 だから正確にする傾向があります と同様に、最も重み付けされて 3のこの乗算係数。 デザインも重要ですが、 あなたは必ずしもない何か 上のもの時間のすべてを費やします 物事がうまく動作するように取得しようとしています。 

そしてそれは、加重ています もう少し軽く。 そしてスタイルは、少なくともを加重されます。 それはあまりないですにもかかわらず 根本的に重要な、 それは、多分、ちょうどです 右の一番簡単な方法、 例私たちを模倣します 講義やセクションで行い、 きれいなものと インデント、およびコメントし、 などの最も簡単なの一つであります 行うと、権利を取得するためのもの。 以下のようなので、実現 それらのポイントであることを 把握することは比較的容易であること。 

そして今単語で 学術正直this--。 コー​​スのあたりだから シラバス、あなたが表示されます コー​​スは持っていることを非常に この周りの言語のビット。 そしてもちろんはの問題を取り 学術正直かなり真剣に。 

私たちは、区別を持っています、 良くも悪くもため、 より毎年送ったの 懲戒処分のための学生 ほとんどの他のどのより 私が知っていることを、もちろん、。 これは、必ずしもではありません 事実を示します CSの学生、またはCS50学生が、あること 任意の少ないクラスメートよ​​りも正直。 しかし、現実という点で、この 電子的に、私たちだけの世界、 技術持っています これを検出する手段。 

それはのために私たちに重要です クラス全体の公平性 私たちが行うことがこれを検出し、上げます 私たちは物事を見る問題。 そして、ちょうど絵を描くと、本当にします このシンクのようなものを助けるために、 これらは、数あります 過去10年以上の学生 一部に関与していること 学術正直のような問題、 いくつかの32の学生と 秋2015から、その 我々が取るかということです 問題は非常に真剣に。 そして、最終的には、これらの数字は構成し、 最近、約3％、4％程度 クラスの。 

学生のマジョリティのためだから ラインが​​明確であるようです。 しかし、これを維持します 特に後半、気に 夜に苦労するとき 問題セットにいくつかの解決策、 メカニズムが存在すること より良い自分自身を取得するための あなたよりサポートがかもしれません でも、その時間に、と思います。 私たちが受けたときにすることを実現します 学生の提出、我々が交差 今年、すべての提出を比較 すべての提出昨年に対して、 2007年からのすべての提出に対して、 そして同様に、見て、以来、 コー​​ドは、オンラインレポジトリ ディスカッションフォーラム、求人サイト。 そして、我々はこれを言及し、 本当にために、すべての た場合に、完全な情報開示の 他の誰かが、それをオンラインで見つけることができます 確かに、私たちのコースすることができます。 しかし、本当に、精神 もちろん沸きます シラバスでこの句に。 それは本当にただ、合理的です。 

そして、我々はそれについて詳しく説明していた場合 ただもう少し言語で、 ことをすべてのエッセンスを実現 あなたはこのコースに提出する作業 あなた自身でなければなりません。 しかし、その内、確かにありま​​す 機会、と励まし、 に目を向けおよび教育的価値 自分自身をothers--、TFを、CAは、 クラス内のTA、およびその他、 サポートのために、一人で友人を聞かせて 研究しているとルームメイト 前CSとプログラミング。 だからそのための余裕があります。 そして、一般的な経験則 助けを求めるとき、this--です あなたが他の人にあなたのコードが表示されることがあり、 しかし、あなたは彼らが表示されない場合があります。 だから、あなたはオフィスの時間にいる場合であっても、 Dホールで、またはどこか他の場所または いくつかの点セットに取り組んで、 友人と一緒に働いて、その で、完全に罰金です 一日の終わりにあなたの仕事 最終的にはそれぞれに属している必要があります あなたのそれぞれはなく、 いくつかの共同作業であること、 最終的なプロジェクト場所を除いて それは許可し、奨励しています。 

あなたがしている場合ことを実感 何かに苦しんで そして、あなたの友人はちょうど起こります そして、この面で優れているあなた、 またはあなたよりもその問題でより良いです、 または少し遠く前方にあなたよりも、 それが有効に完全に合理的です お友達へと言う、ちょっと、 あなたがここに私のコードを見て気にしません、 私は私の問題が何であるかを見つける手助け？ そして、うまくいけば、中 教育的価値の関心 その友人はちょうどありません 、ああ、これを行う、と言うのではなく、 あなたが行に何が欠けています 6、またはそのような何か？ しかし、解決策はありません あなたの隣の友人のため 言って、ああ、よく、ここで、私が引っ張ってみましょう これまでの、そしてあなたに私の解決策を示しています。 だからラインです。 あなたは、あなたのコードに示します 他の人が、あなたはないかもしれません 他の対象に、彼らを見ます コー​​スのシラバスで制約。 

だから、このことを覚えておいてください いわゆる後悔句 コー​​スのシラバスにおいても、 あなたには、いくつかの行為をした場合、そのこと 合理的ではありませんが、それを持って来ます 当然の頭の注意 72時間以内に、コース 地元の制裁を課すことができること 不満足を含んでもよく、または 送信される作業のための失敗グレード。 しかし、コースは参照しています さらに懲戒処分の問題で、 繰り返される行為の場合を除いて。 言い換えれば、あなたが行う場合は、いくつかを作ります 愚かな、特に夜遅く、意思決定 その次の日の朝、2日 後で、あなたが目を覚ますと実現、 私は何を考えていましたか？ あなたはCS50にコンセントがありますか その問題を修正するための そして、なるように、それまで所有している私たち 途中でお会いし、対処します それにもある問題で 教育とあなたのために貴重な、 しかし、何らかの方法で、まだ懲罰的。 そして今、これをエッジを脱いで。 

[ビデオ再生] 

[MUSICのPLAYING] 

[END PLAYBACK] DAVID J.マラン：すべての権利、我々は戻ってきました。 そして今、我々はの1を見て 私たちの現実世界のドメインの最初の CS50で、暗号の芸術、 送信側と受信側の芸術 暗号化された秘密のメッセージ、 メッセージ可能ならば、 あなたが持っている場合にのみ解読することができます 送信者が持っているいくつかの重要な成分 同じように。 だから私たちは取るよ、これをやる気に ここでこの事を見て、 そのうちの一例であり、 秘密デコーダリングその 把握するために使用することができます 秘密のメッセージは、実際には何ですか。 実際には、後ろに 小学校で一日、 あなたは今までに秘密のメッセージを送信した場合 いくつかの友人やクラスのいくつかのクラッシュ、 あなたが考えている可能性があります あなたは賢いされていました 紙変更のあなたの部分にすることにより、 以下のような、BにA、およびDからC、およびCにB、 など。 しかし、あなたが実際に暗号化されました でもあなたの情報、 それは少し些細だった場合、ありませんでした そのハード先生が実現するために、 よく、あなただけ変更した場合 BにAとCにB、 あなたが実際に把握します メッセージは何でした、 しかし、あなたは情報を暗号でした。 

あなたはそれをやっていました 単に、はるかにRalphieのように、ここで 演じている有名な映画の中で ほとんどの広告nauseum各冬。 [ビデオ再生] それはすべてのことに知られて-bE ラルフ・パーカーはここにあります リトルのメンバーを任命 孤児アニー秘密のサークル そして、すべての栄誉を受ける権利があります および利点は、そこに発生します。 

-Signed、台所戦争アニー、 カウンター署名インクで、ピエール・アンドレ。 栄誉とメリット、 すでに9歳で。 

[叫び] -いい加減にして。 のは、それを上に取得してみましょう。 私はすべてのことジャズを必要としません 密輸と海賊について。 

用-listen明日の夜 結びの冒険 黒海賊船の。 今、それはのための時間です アニーの秘密のメッセージ 秘密のサークルのあなたのメンバーのために。 覚えておいて、子供たち、メンバーのみ アニーの秘密サークルの アニーの秘密のメッセージを復号することができます。 

アニーはあなたに依存されている、覚えておいてください。 B2にあなたのピンを設定します。 ここにメッセージがあります。 12、11-- 

-Iは、中に私の最初の秘密会議をしています。 

-14、11、18、16。 

-Pierreは素晴らしい声で今夜でした。 私は今夜​​のことを言うことができます メッセージが本当に重要でした。 

-3、25は、それが、メッセージの アニー自身から。 誰にも言わないでください、覚えておいてください。 

-90秒後、私はのみによ 9の少年の家の部屋 プライバシーとデコードに座ることができました。 なるほど、B！ 私は次の、Eに行ってきました 

最初の単語があることです。 Sは、それは、現在Uを容易に来ました25-- 

-OH、是非、Ralphieは、私が行くなきゃ！ 

右ダウンして-I'll、馬！ ジーの達人！ 

-Tは、O、何に必ずto--確認してください？ 台所戦争何でした アニー言いたいの？ 何に必ず？ 

-Ralphie、アンディはに持っています 行く、あなたが出て来てくださいだろうか？ 

-All右、馬！ 私は右のアウトになるだろう！ 

-Iは近い今なっていました。 張力はひどいものでした。 それが何だった？ 惑星の運命 バランスでハングすることがあります。 

-Ralphie！ アンディのお奨めは行きます！ 

大声で泣くのために、右アウトすることが-I'll！ 

そこ-Almost、私の指は、私の心を飛びました 鋼トラップだった、すべての細孔が振動しました。 これは、はい、はい、はい、ほとんど透明でした。 

あなたのオヴァルティンを飲むようにしてください-bE。 オヴァルティン？ 安っぽい商業？ クソ野郎。 [END PLAYBACK] DAVID J.マラン：OK、そう それは非常に長い道のりでした 暗号化を導入します、 また、オヴァルティン。 実際には、この古い広告から ここで、なぜオヴァルティンはとても良いのですか？ それは熟したの濃縮抽出であります 大麦麦芽、純粋なクリーミー牛乳、 そして特別に一緒に、ココアを用意 天然ホスファチドやビタミンと。 これは、さらにで強化されています 追加のビタミンBとD、yumを。 そして、あなたはまだ明らかに、それを得ることができ、 Amazonで、私たちはここで行ったように。 

しかし、動機はここにありました 具体的には、暗号化を導入 知られている暗号化の種類 秘密鍵暗号方式として。 そして名前は、全体を示唆するように 秘密鍵暗号システムのセキュリティ、 可能ならば、方法論 ちょうどスクランブルします 2人の間の情報、すなわち 送信者と受信者だけのみ いくつかの値key--秘密を知っている、いくつかの その秘密フレーズ、いくつかの暗証番号、 両方の暗号化にそれらを可能にします 情報を解読します。 そして、暗号化、本当に、 ちょうど今週0からです。 

これは、入力があります問題です 英語での実際のメッセージのような または任意の言語そのあなた クラスで誰かに送信します、 またはインターネット上で。 起こっているいくつかの出力があり、 あなたスクランブルメッセージであることを 受信者が受信したいです。 そして、たとえの誰か 真ん中はあまりにもそれを受けて、 あなたがそれらをしたくありません 必ずしもそれを解読することができ、 この内部の理由 ブラックボックス、またはアルゴリズム、 いくつかのメカニズム、ステップバイいくつかのステップであります その入力を取るための命令、 とに変換します うまくいけば安全な方法で出力、。 

そして、実際には、あるいくつかの この世界では語彙次のように。 プレーンテキストは、単語aは コンピュータ科学者だろう 入力を説明するために使用 英語のようなメッセージ、 実際にまたは任意の言語を使用します いくつかの他のヒトに送信します。 そして、暗号文がスクランブルです 、暗号化、または暗号化へ そのバージョン。 

しかし、ここで一つの他の成分があります。 1つの他の入力があります 秘密鍵暗号方式。 そして、それはキー自体です、 これは、一般に、あります 我々は、番号が表示されますよう、または 文字、または単語、何でも このアルゴリズムは、それが実際に期待されます。 

そして、どのように情報を復号化するのですか？ どのようにそれを解読できますか？ さて、あなただけのリバース 出力と入力。 

つまり、誰かが一度 あなたの暗号化されたメッセージは、受信します 彼または彼女は単に持っています その同じキーを知っています。 彼らは、暗号文を受けています。 そして、それらの2を差し込むことにより、 暗号システムへの入力、 アウトアルゴリズム、このブラックボックス、 元の平文を来る必要があります。 そして、そのためには、非常に高いレベルです 暗号が実際に何であるかの見解 の全て。 

それでは、そこに取得してみましょう。 今度は下に見てみましょう 何かのフード 以下のために付与されたために、私たちは取ってきました 先週、このセッションのために 文字列をhere--。 一日の終わりに文字列 文字だけのシーケンスです。 

これはハロー世界であること、または可能性があります こんにちはZamyla、または何でも。 しかし、それはに何を意味するのでしょ 文字の配列であること？ 実際には、CS50ライブラリが提供します 私たちの文字列と呼ばれるデータ型。 

しかし、ノー実際にそこにあります Cの文字列のようなもの それは実際のちょうど配列であり、 文字、文字、文字、 背中合わせの文字、、、へ 背中、内部バックアップする、バックアップします コンピュータのメモリ、またはRAMの。 そして、我々は中にその中に深く見ていきます 我々はメモリ自体を見て、将来、 そして、使用率、および 関与している脅威。 

しかし、ここでは、文字列Zamylaを考えてみましょう。 のだから名前 ここでは、人間、Zamyla、 それは、一連のです 文字、Z-A-M-Y-L-A。 そして今のはそのZamylaの名前を仮定しましょう コンピュータの内部に格納されています プログラム。 

まあ、それは我々がすべきことは理にかなって それらの文字を見てすることができます 個別に。 だから、僕は少しを描くつもりです ここZamylaの名前の周りにボックス。 そして、それはそのとき、Cの場合であります 多分Zamyla--と同様に、文字列を持っています その文字列から帰ってきました GET文字列のような機能、 あなたが実際に操作することができます 文字によってその文字。 

さて、これがためにゲルマンです 手元の会話、理由 暗号であなたが変更したい場合 DのB、およびB、C、およびC、 など、あなたができるようにする必要があります 個々の文字を見て 文字列インチ あなたが変更できるようにする必要があります 何か他のもの、AからZ 何か他のものへの、Mは ように何か他のもの、と。 そして、私たちは方法が必要になり、 プログラムで、そう Cに、話すためには、変更することができるようにします そして個々の文字を見てください。 次のようにそして、我々はこれを行うことができます。 

私はCS50 IDEに引き返す行きましょう。 そして、私は先に行ってみましょう 新しいファイルを作成します 私はこの時間string0と呼ぶことにしますことを、 私たちの最初のそのような例として、Cに点在しています。 そして、私は先に行くつもりです 次のようにして、それをかき立てます。 

だからCS50.hが挙げられ、 その後、標準io.hを含み、 これは、私はほとんど常にに行きますよ 少なくとも、私のプログラムで使用しています 最初は。 int型メインボイド、その後、ここで私がよ 文字列をするつもりは、文字列を取得します。 そして、私はするつもりです 先に行くと、これを行います。 私は先に行きたいです そして、健全性チェックとして、 ちょうど言う、こんにちは、パーセントの、 セミコロンは、文字列0になります。 Uhオハイオ州、私はここで何をしましたか？ ああ、私はそれをプラグインしませんでした。 それでレッスンは、学んだこと 意図的ではなかったです。 

だからエラー、より多くのパーセント データ引数よりも変換。 そして、これはどこにあります ライン7-- OK、私は持っています、 引用終わりの引用、それはです printf関数に私の文字列。 私は、パーセント記号を持っています。 しかし、私は第二引数が不足しています。 

私は、コンマ秒が欠落していますよ 私は、先の例で持っていました。 修正するので、良い機会 もう一つのミス、誤って。 そして今、私が実行してみましょう string0、Zamylaを入力します。 Zamylaこんにちは、[OK]をクリックします。 

だから我々はこの種のプログラムを実行しようとしました 今、いくつかの異なる回。 しかし、それでは、何かaをやらせます 今回は少し異なります。 代わりにちょうどZamylaのを印刷します printf関数と名前全体うち、 のは、文字でそれを文字にしましょう​​。 

私は、forループを使用するつもりです。 そして、私は自分自身を与えるつもりです カウント変数は、私と呼ばれます。 そして、私はそのように、反復を維持するつもりです iがSの長さ未満である限り。 

それは結局のところ、我々はしませんでした この最後の時間を行います、 そのcが付属しています スターリング、呼び出される関数です。 戻る日に、と一般的には まだ機能を実装する場合、 人間はしばしば非常に選択されます 簡潔な名前の音の種類 あなたはそれがだとしても、何をしたいのような いくつかの母音や文字欠落しています。 だから、スターリングは、 その関数の名前 間の引数を取ります 文字列でなければなりません括弧。 そして、それはちょうど整数を返し、 その文字列の長さ。 

7行目のループのためにこのように起こっています iが0に等しいからカウントを開始します。 インクリメントするために起こっています 各反復のI 1によって、私たちは何度か行ってきたよう。 しかし、それだけでやろうとしています このアップ時点まで 私は長さである場合 文字列自体の。 

だから、これは最終的に、の方法です、 文字を反復処理 文字列に以下の通りです。 私はしませんプリントアウトするつもりです 文字列全体が、％のC、 単一文字 新しい行が続きます。 そして、私はするつもりです 先に行く、と私は必要があります 私は印刷したいと言って Sのi番目の文字。 

だから私が示す変数の場合 文字列のインデックス あなたはそれで、私のことができるようにする必要があります 私は秒のi番目の文字を与える、と言います。 そして、cが行う方法があります 角括弧でこの。 あなたは、単にの名前を言います この場合にはsである文字列。 そして、あなたは角括弧を使用します 通常はちょうどあなたのリターン上または入力してください キーボード上のキー。 そして、あなたはのインデックスを置きます 印刷したい文字。 だから、インデックスがあることを行っています number-- 0、又は1、又は2、又は3、又はドット、 ドット、ドット、他のいくつかの数。 

そして、我々はそれが起こっていることを確認してください 私ので、右の数であります 0からカウントを開始します。 そしてデフォルトでは、最初の文字 文字列内の慣例0によるものです。 2番目の文字は、ブラケット1です。 そして、3番目の文字は、ブラケット2です。 そして、あなたはあまりにも行きたくありません これまで、我々は我々がしているしませんので、 それだけまで私をインクリメントする予定 文字列の長さに等しいです。 そしてその時点で、 このforループは停止します。 

だから私は先に行くと、これを保存してみましょう プログラム、および実行は、文字列0を作ります。 しかし、私はめちゃくちゃ。 暗黙的にライブラリ関数を宣言 タイプなどでスターリング、今such--、 これは聞き覚え。 しかし、それはprintf関数ではありません。 そして、それは文字列を取得していません。 

私はで台無しにしませんでした 同じように、この時間。 しかし、ここで少しダウンダウンに気付きます さらに、ヘッダーstring.hのを含んで、 明示的に提供 スターリングの宣言。 だから、実際にそこに手がかりがあります。 

そして実際それが判明します 別のヘッダファイルがあります 我々が使用されていませんでしたことを まだクラスで、それはです 利用可能なもののうち、 あなたに、string.hのと呼ばれます。 そして、そのファイルで、string.hの スターリングが宣言されます。 だから私は先に行くとしましょう これを保存し、文字列を作ります 0--素敵な、エラーメッセージなしこの時間。 

./string0 Zamyla、および 私は、Enterキーを押ししようよ その時点でのGetStringが起こっています 文字列を返すように、sの中でそれを置きます。 次にためのループが反復処理しようとしていること 一度に1つのSの文字の上に、 そして、するので、それらを1行に1つずつを印刷 私が最後でそのバックスラッシュnを持っていました。 だから私は、そのバックスラッシュを省略することができ nは、その後、ちょうどすべてZamylaを印刷 同じラインで、 効果的に再実装 すべてのことは有用ではないのprintf、。 しかしこの場合、私はそれをやっていませんでした。 私は実際に1をプリントしました 当時の文字、1行に1つずつ、 私たちは、実際に効果を見ること。 

しかし、私はここに一つのことに注意してください。 そして、我々は戻ってくるだろう 今後一週間でこの。 これは、このことが判明します コー​​ドは、潜在的にバグがあります。 

これは、文字列を取得することが判明します 生活の中で、いくつかの他の機能 必ずしもいつも あなたが期待しているものを返します。 我々は最後のクラスから知っています 取得このの時間 文字列は、文字列を返すことになっています。 しかし、このようなアウトユーザータイプの場合 ロングワード、または段落、またはエッセイ ちょうど十分ではないがあること それに合わせて、コンピュータのメモリ。 

同様に、何かがどのようになった場合 フードの下に間違っていますか？ それは頻繁に起こらないかもしれないが、 それは、一度発生する可能性があります 一方で、非常にまれに。 そしてそれは、文字列を取得ことが判明します そのような機能は必ずしもん 常に文字列を返します。 彼らはいくつかのエラー値を返す可能性があり、 いわば、いくつかのセンチネル値、 それがあることを示し 何かが間違っています。 そして、あなただけからこれを知っているだろう 今クラスでそれを学んだました、 またはいくつかのより多くのドキュメントを読みました。 これは、文字列を取得することが判明します ヌルと呼ばれる値を返すことができます。 ヌルは、私たちがよ特別な値であります 将来の週に戻ってきます。 しかし、今のところ、ちょうど私がしたい場合ことを知っています 前進で本当に適切であることを GET文字列を使用して、I ちょうどそれを呼び出すべきではありません、 そして、盲目的にその戻り値を使用し、 それは文字列だと信頼します。 

私が最初に言うべきです、 ちょっとだけ、ちょっと待って sが等しくない場合に進行 ヌル、再びヌル、 ただ、いくつかの特別な値です。 そして、それはあなただけの特別な値です GET文字列を心配する必要があります。 文字列を取得するのいずれかであるだろう 文字列またはnullを返します。 

そして、この感嘆符は、等号 あなたは多分数学のクラスから知っているかもしれません あなたが等号を引くかもしれません それを通る線は等しくないことを示します。 それは、一般的な文字ではありません あなたのキーボードで入力することができます。 だからほとんどのプログラミング言語で、 あなたが等しくないと言いたいとき、 あなたは感嘆符を使用し、 そうでなければビッグバンとして知られています。 だから、ビッグバンは、等しいと言っています 論理的に、等しくないことを意味します。 それは大きくありませんだけのようです より、または等しい、または未満 または同等のキーボードのキーにします それは、一つのシンボルですべての作業を実行します。 だから、だからこそ、過去の例では、 あなたは開き括弧をした、その後、 行うためには、等号、 未満、たとえば、以上。 

だからここに持ち帰りは何ですか？ これは、単に今の方法であります 、この機能をこの構文を導入し、 個々の繰り返し処理 文字列内の文字。 そして、ちょうどそれらの正方形のような ブラケットは、あなたがそれらを取得することを可能にします これらの角括弧を考えます 種類のこの根底にあるを示唆 デザイン、それによってすべての 文字列の内側の文字 種類の下にどこかに箱詰めされ、 コンピュータのメモリ内のフード。 

しかし、ここでは、この変異体を作ってみましょう。 これは、このことが判明します プログラムは正しいです。 CS50の軸あたりだから評価します コー​​ドは、これは正しくなりました。 特に今私がチェックしていること nullの場合、このプログラムがクラッシュすることはありません。 そして、私はただの経験からそれを知っています。 しかし、そのほかには何もありません 私たちは本当に間違ってここに行くことができます。 しかし、それは非常によく設計されていないのです、 のが基本に戻ってみましょうので。 

まず、principles-- ループのため何をするのでしょうか？ forループAは、3つのことを行います。 これは、いくつかの初期化を行います 値、あなたがそれを求めるなら。 これは、条件をチェック。 そして、後の各 反復、各サイクルの後、 それはいくつかの増分 値、または値、ここに。 

だから、それは何を意味するのでしょうか？ 私たちは、私が0に初期化します。 我々はチェックし、私が以下であることを確認してください Z-A-M-Y-L-Aであるsの長、 そのように6未満です。 そして、確かに、6未満として0。 

私たちは、Zamylaの名前からZをプリントアウト。 その後、我々は0から1に私をインクリメントします。 私たちはその後、チェック、1以下であります Sの長さよりも？ Sの長さは6です。 はい、そうです。 

だから我々はZamylaの名前、ZAで印刷します。 私たちは2に、1に、0から私をインクリメントします。 私たちは、その後より2小さい、チェック Zamylaの名前の長さ。 6-ので2は6未満です。 はい、それでは、M中をプリントアウトしてみましょう Zamylaの名前、3番目の文字。 

ここで重要なのは、それはそれぞれの上にあります 物語の反復は、私がチェックしています、 私はZamylaの長さよりも小さいですか？ しかし、キャッチということです スターリングはプロパティではありません。 プログラムされているあなたの人々の Javaや他の言語の前に 文字列の長さを知っているかもしれません プロパティ、単にいくつかの読み取り専用の値。 

この場合にはCで、これがある場合 文字通り機能 の数を数えます 毎回Zamylaの文字 私たちは、その関数を呼び出します。 使用するコンピュータを頼むたびに スターリングは、それがZamylaを見て取って、 そして、言ってZ-A-M-Y-L-A、6。 そして、それは6を返します。 あなたが呼び出す次回 ループのためにその内部にそれ、 Zamylaを見に起こっています 再び、Z-A-M-Y-L-A、6言います。 そして、6を返すために起こっています。 したがって、この設計についての愚かな何ですか？ 

なぜ私のコードではありません5つ星のうち5です 今のデザインのために、いわばするには？ まあ、私が求めています 不必要に質問。 私は私が必要以上の仕事をやっています。 

だから、たとえ 答えは、私は、正しいです コンピュータを求めて、何です 再びZamylaの長さは、 そして再び、そして再び、そして再び？ そして、その答えは 変更するつもりはありません。 常に6になるだろう。 

これよりだから、よりよい解決策 この次のバージョンになります。 私は先に行ってみようと、それを置きます string1.cと呼ばれる別のファイル、 ちょうどそれが別々に保管します。 そして、それはのために判明します ループ、あなたが実際にすることができます 一度に複数の変数を宣言します。 

だから私は、私を維持し、0に設定するつもりです。 しかし、私はまたに行きますよ カンマを追加し、言います、 私のnという変数を与え、その 値は、sの文字列の長さに等しいです。 そして今、私の条件を行ってください 限りiがn未満であるように。 

したがって、このように、論理は 一日の終わりに同一。 しかし、私は覚えています この場合の値6、。 Zamylaの名前の長さは何ですか？ そして、私はn個でそれを入れています。 

そして、私はまだチェックしています 条件たびに。 6 0より少ないですか？ 6より1少ないですか？ 等々6以上2以下であり、？ 

しかし、私はコンピュータを求めていませんよ 再び、そして再び、何 Zamylaの名前の長さは？ Zamylaの名前の長さは何ですか？ このZamylaの名前の長さは何ですか？ 私は、文字通り、その最初を覚えることだし、 この第二の変数nにだけ答えます。 だから、これは今だけではなくなるだろう 正しいだけでなく、うまく設計されました。 

さて、どのようなスタイルはどうですか？ 私は私の変数を命名しました かなりよく、私は言うでしょう。 彼らは今、超簡潔です。 そして、それは完全に罰金です。 

あなたが1つしかない場合 プログラム内の文字列、 あなたにも、それが文字列の場合はsと呼ぶかもしれません。 あなたは、1つの変数だけを持っている場合 プログラムでカウントするための、 あなたにも私にそれを呼び出すことがあります。 あなたは長さを持っている場合は、n個 同様にスーパーが一般的です。 しかし、私は私のコードのいずれかをコメントしていません。 

私はreader--を知らされていなかっました それは私のTF、またはTAのかどうか、 または単に想定される内容colleague-- このプログラムで起こっします。 それで良いスタイルを取得します、 私がしたいと思います this--ものです 以下のような入力をユーザーに尋ねます。 そして、私は書き換えることができ この任意の数の方法。 

得ることを確認-S-ことを確認してください 文字列は、文字列を返しました。 そしてhere--で、これはおそらくです 最も重要なcomment--反復 sの1の中の文字を超える時。 そして、私はいずれかを使用することができます 英語の選択 ここではそれぞれを記述するために コー​​ドのこれらのチャンクの。 

私は入れていないことに注意してください コー​​ドのすべての行にコメント、 本当にただ面白い上 もの、もの いくつかの意味を持っている私がかもしれません 誰かに超明確にしたいです 私のコードを読んで。 そして、なぜあなたが得る呼んでいます 文字列は、入力をユーザーに尋ねますか？ でもその1は、必ずしもではありません すべてのことの記述。 しかし、それは、話をすることができますので、 物語の中で2行目は、確認してくださいされ、 文字列は、文字列を返されます。 

そして、物語の3行目は、 秒の1の中の文字を反復処理 一度に。 そして今、ちょうど良い対策のため、 私は先に行くと、追加するつもりです そのちょうど1より多くのコメント s内の印刷i番目の文字は述べています。 今、私が何をしました 一日の終わりに？ 

私はいくつかの英語を追加しました コメントの形で言葉。 スラッシュスラッシュ記号はちょっと、意味します、 コンピュータこれは、人間のためのものです、 ないあなたのために、コンピュータ。 そこで、彼らは論理的に無視しています。 彼らはただそこにいます。 

そして、確かに、CS50 IDEは、それらを示しています 有用であるとして、グレー、しかしキーではありません プログラムへ。 あなたは今何ができるか注目してください。 あなたがCを知っているかどうか プログラミングやない、あなたが ちょうどこの時に戻って立つことができます プログラムは、コメントをすくい取ります。 確認して、入力のためにユーザーに依頼 文字列に文字列が返さ取得し、 sの中の文字を反復処理 一度に一つが、文字を印刷します そうしない-S-のi番目の文字 でも、コードを見ています このプログラムが何をするのか理解します。 そして、より良いまだ、自分で見てみると 週または2でこのプログラムでは、 または月、または年、 あなたも持っていません コー​​ドを凝視するために、 思い出そうと、 どのような私は、このコードをどうしようとしていましたか？ 

あなたは自分自身を指示しました。 あなたは自分自身でそれを説明しましたが、 またはいくつかの同僚、もしくはTA、またはTF。 そして、これは今になります 正しい、と優れたデザイン、 そして最終的にスタイル良いとしても。 だから、心に留めておくん。 

だから、他の1があります 事は私がここにするつもりです それが今まさに何明らかにすることができます ボンネットの下に起こっています。 だから、この機能があります C、および他の言語で、 呼ばれる型キャスト その暗黙 または明示的に変換することができます 別のデータ型から。 私たちはそのように扱ってきました 文字列とはるかに今日。 

そして、文字列は文字です。 しかし、週からリコール 0、文字は何ですか？ 文字だけで抽象化されています numbers--小数の上に、 そして、小数は本当にただです 2進数の上に抽象化し、 我々はそれを定義したとおり。 

だから、文字は数字です。 そして、数字は文字です、 ただ文脈に応じて。 そして、それは内部ことが判明します コンピュータプログラムの、 あなたが見てみたい方法を指定することができます そのプログラムの内部ビットで？ 

私たちが持っていた0週からリコール ちょうどこのコードであるアスキー、 数字へのマッピングの手紙。 そして、我々は資本Aが65である、と述べました。 資本Bは、等66である、と。 

予告、私たちは本質的に文字を持っています ここでは一番上の行、Cはそれらを呼び出すことになるとして、 文字、その後 2行目のint型。 そして、それはあなたが変換することができ判明します シームレス典型的には二つの間。 そして、私たちは何をしたい場合 この意図的に、我々 タックルしたい場合があります このようなもの。 

私たちは、変換したい場合があります 下げるために大文字 場合、または大文字と小文字。 そして、それはそこのが判明します ここでは、実際のパターン 私たちは一瞬で受け入れることができます。 しかし、それでは、で最初に見てみましょう 明示的にこれを行うの一例。 

私は、CS50のIDEに戻って行くつもりです。 私は作成するつもりです アスキー0.c.と呼ばれるファイル そして、私は先に行くと、私を追加するつもりです 上部の標準io.h、int型メインボイド 私の関数の上部にあります。 そして、私はするつもりです 私は等しいからforループfollowing--、 のは、65をしましょう​​。 

そして、私はより少なくなるだろう 65、プラスアルファベットで26文字。 だから私は、コンピュータをもらおう そこに私のために計算を行います。 そして、このループ内で、 どのような私は印刷するつもり？ 

％cは、iがnバックスラッシュ％です。 そして今、私は2つの値をプラグインします。 私は一時的に質問を入れています 質問を招待しそこにマークします。 

私は、以降65から反復処理したいです アルファベットの26文字のため、 各反復でプリントアウトすること キャラクターの一体的な同等。 言い換えれば、私がしたいです 26の数字の印刷を反復処理 アスキー文字が何であるか、手紙、 そして、どのような対応する番号is-- 本当にただの再作成 そのスライドからグラフ。 したがって、これらの疑問符が何をすべきですか？ 

まあ、それは第二のことが判明します 1は、単に変数iでなければなりません。 私は数としてそれを見てみたいです。 そして、中央の引数 ここでは、私はコンピュータを伝えることができます その整数を治療します 私の文字として、ように パーセントC.のためにここにそれを置換します 

換言すれば、Iの場合、 人間のプログラマー、知っています これらは数字だけです 一日の終わりに。 そして、私は65がすべきことを知っています いくつかの文字にマップします。 この明示的なキャストでは、 括弧と、 あなたがしたいデータ型の名前 変換し、閉じ括弧、 あなたが言うことができます コンピュータ、ちょっと、コンピュータ、 この整数はchar型に変換します。 

だから私はこれを実行すると、 コンパイル後のプログラム、 のは、私はアスキー0を作るget--かを見てみましょう。 それくそ、私が間違ってここで何をしましたか？ 宣言されていない識別子の使用、 すべての権利、意図的な、 私たちができない場合を見てみましょう このを通して理由。 

だからラインはので、私は取得できませんでしたfive-- 非常に遠くまでねじ込む前に。 それで大丈夫です。 だから私のためのライン5に等しい65--私が参照してください。 だから、いくつかのとは異なり、Cであることを覚えています あなたは前にプログラミングを持っている場合の言語 経験、あなたが持っています コンピュータを伝えるために、 スクラッチとは異なり、どのような 変数の型はそれがあります。 

そして、私はここにキーフレーズを忘れてしまいました。 行5で、私は私の使用を開始しました。 しかし、私はCに語っていません それはどのようなデータ型です。 だから私はここに行くつもりですし、 ああ、それは整数にする、と言います。 

今、私は先に行くと、再コンパイルするつもりです。 それはそれを修正しました。 入力./ascii0、それは一種のクールです。 だけでなく、それはに超高速であります コンピュータにこの質問をし、 むしろスライド上にそれを見てより、 それは、Aは65で、1行に1つずつをプリントアウト Bは、I以来down-- 66、すべての方法です 、手紙zにこの26 times--をしました これは90です。 そして、実際には、わずかに よりインテリジェントだろう 依存しない私のためにされています コンピュータに26を追加します。 私は行っている可能性が 90だけでなく、あまりにも長い間 私は二度同じ過ちをしないように。 私が通って行きたいです Zだけでなく、Y​​を介してアップ。 

だから、明示的なキャストです。 これは、このことが判明します さえ必要ありません。 私が先に行くと、これを再実行してみましょう コンパイラ、および再実行アスキー0。 これは、Cはかなりスマートであることが判明しました。 

そして、printf関数、特に、 かなりスマートです。 あなたは2回だけ私を渡した場合 両方のプレースホルダのため、printfの よく私はあなたを知って、ああ、実現されます 私はいくつかの番号をinteger--与えました、 65、または90、または何のような。 しかし、私はあなたが私がしたいことを参照してください。 文字のようなその番号をフォーマットします。 そしてそうprintfの暗黙的にキャストすることができます あなたのためのcharへのint型としても。 だから、まったく問題ありません。 

しかし、このため同等の、気付きます 私たちは、実際には同様にこれを行うことができます。 私が先に行くと1を作ってみましょう this--アスキー1.C.の他のバージョン そして、の代わりに、繰り返し処理 整数は、本当にあなたの心を爆破することができます 文字を反復することもできます。 文字cが大文字のAを取得した場合、I 先に行くと、これをやってみたいです、 あれば、Cは以下のように 資本Zにし、反復のたびに 私は私ができる、Cをインクリメントしたいです 今ここに私のprintfのラインで ％のCである、と言います パーセント私は再び、コンマC. 

そして今、私は他の方向に行くことができ、 明示的に文字をキャスト 整数に。 だから、もう一度、なぜあなたがこれを行うのでしょうか？ それは一種のには少し奇妙なことです 文字単位でカウントされます。 

しかし、あなたが何を理解していれば ボンネットの下に起こって、 魔法は本当にありません。 あなただけのちょっと、コンピュータが与える、と言っています 私char型のCと呼ばれる変数。 資本Aにそれを初期化し、 単一引用符の問題に気づきます。 

Cの文字については、からリコール 先週は、一重引用符を使用します。 文字列の場合、言葉に、 フレーズは、二重引用符を使用します。 [OK]を、コンピュータ、これをやり続けるので、 文字の長未満であります またはzに等しいです。 そして、私はそのすべての私のアスキーテーブルから知っています これらのASCIIコードの連続しています。 

ギャップはありません。 だから、ちょうどZまでです 1番号ごとで区切られています。 そして、私は増加することができます char型、私が本当にしたい場合。 一日の終わりに、 それだけの数です。 私はこれを知っている。 だから、僕はそれに1を追加するために推定することができます。 

そしてこの時、私は、cを印刷し、 そしてその後、積分等価。 そして、私も明示的なキャストを必要としません。 私はprintfのとさせることができます コンピュータフィギュア物事うち、 その結果、今、私は実行する場合 Ascii1./ascii1を行い、 私もまったく同じことを得ます。 

無駄なプログラムは、誰もthough--ありません 実際にソフトウェアを書くことが起こっています 把握するためには、何でした A、またはB、またはZにマップ数？ あなたはそれをGoogleに行く、またはしています オンラインそれを見て、またはそれをルックアップ スライド、等に。 そこでここでは、これは実際に有用な取得のでしょうか？ 

まあ、そのことを話します スライド、があります注意してください 大文字の間、ここで実際のパターン 偶発的ではなかった小文字。 大文字のAが65であることに注意してください。 小文字aは97です。 そして、どのように遠くに小文字のですか？ 

だから65は、どのように多くの手順離れて97からでしょうか？ だから、97のマイナス65は32です。 だから、資本aは65です。 あなたはそれに32を追加した場合、 あなたは小文字得ます。 そして、等価的に、あなたは32を引く場合、 あなたが首都に戻っA-- Bと同じ 少しCにはほとんどBへ、ビッグC。 

これらのギャップのすべてが離れて32です。 さて、これは私たちがすることを可能にするように思われます Microsoft Wordのような何かを、 またはGoogleドキュメント機能、あなた すべてを選択し、言うことができ、 小文字にすべてを変更、または 大文字にすべてを変更、 または最初の単語だけを変更 大文字に文の。 私たちは、実際に何かを行うことができます 自分自身そのような。 

私が先に行くと、ファイルを保存してみましょう ここ0.c.を大文字と呼ばれます とのは、先に行くと、プログラムをかき立てるてみましょう それは、まったく同じように、以下のことを行います。 だからCS50ライブラリが含まれています。 標準I / Oが含まれます。 

そして、私はこれがすぐに来ている知っています。 だから私はそれを置くつもりです そこにすでに、string.hの、 私はへのアクセス権を持っています スターリングのようなもの、 そしてその後、いつものように、メインの空隙をint型。 そして、私は先に行くつもりです そして、文字列操作を行うと、文字列を取得します、 ただ、ユーザーから文字列を取得します。 そして、私はするつもりです 私の健全性チェックを行います。 文字列が等しいnullでない場合は、 それは続行しても安全です。 そして、私は何をしたいですか？ 私は、私が0に等しいから反復するつもりです そしてn秒の文字列の長さまで。 

そして、私は限りこれを行うつもりです 私はプラスプラスnよりも小さい、と。 これまでのところ、私は本当によ 以前からアイデアを借りて。 そして今、私はブランチを紹介するつもりです。 

だから、スクラッチ、に戻って考えます 私たちは、道路のそれらのフォークを持っていました そして先週はCで、私はするつもりです s内のi番目の文字場合は、これを言います 以上であります 小文字に等しく、 and--スクラッチでは、文字通りだろう 言うと、しかし、C言語で、あなたはアンパサンドを言います、 ampersand--とsのi番目の文字 未満または小文字zに等しく、 のは、何か面白いことをしましょう​​。 それでは、実際にプリントアウトしてみましょう 改行なしの文字 それは、文字列内の文字で、 文字列内のi番目の文字。 

しかし、ここでは先に行くとしましょう それから32を引きます。 そうであればの文字 我々が探している文字列 少しAの間ではありません 少しzの、先に行きます ちょうど変わらず、それをプリントアウト。 そこで、導入しました この角カッコ 私たちの文字列がで取得するために i番目の文字列内の文字。 

私のような、いくつかの条件付きロジックを追加しました 先週の週の1つにスクラッチ 私はちょうど私の基本を使用しています 何の理解 ボンネットの下に起こっています。 Sのi番目の文字があります 以上？ 同様に、それは、97、または98であり、 または99など？ 

それはまた、以下で 小文字のzの値に？ そうであれば、この行が何を意味するのでしょうか？ 図14に示すように、これはの一種であります 全体的なアイデアの胚芽、 によって文字を大文字 単に、それから32を差し引きます この場合、私が知っているので、そのあたり 私の番号がどのように表現されるか、チャート、。 それでは、先に行くと、これを実行してみましょう、 0.cを大文字にコンパイルした後、 そして、0を大文字に実行します。 

以下のようなものを入力してみましょう すべて小文字でZamylaを入力します。 そして今、我々はすべて大文字でZamylaを持っています。 のは、すべて小文字でロブを入力してみましょう。 のは、すべて小文字でジェイソンを試してみましょう。 そして、我々は入れません 大文字を余儀なくされました。 その私のマイナーなバグがあります 種類の予想していませんでした。 私の新しいプロンプトが終わるされることに注意してください 自分の名前と同じ行に、 これは少し厄介に感じています。 

だから私はここに行くつもりだ、と 実際にこのプログラムの終わりに 改行文字をプリントアウトします。 それで全部です。 printf関数を使用すると、する必要はありません 変数または書式コードに渡します。 あなたは文字通り印刷することができます 改行のようなもの。 

それでは、先に行くと作ってみましょう 再び0を大文字に、それを再実行し、Zamyla。 そして今、それは少しきれいです。 さて、私のプロンプトは、独自の新しい行にあります。 だから、すべての罰金と良いです。 だから、良い例です。 しかし、私も必ずしもありません ハードコード32にする必要があります。 あのね？ 私は私が今までにないsay--でした 違いが何であるかを覚えています。 

しかし、私は、私の場合ことを知っています 小文字を持って、 私は基本的にオフに減算したいです 距離は少しの間にあるものは何でも 大きなA、私は仮定した場合、その理由 他のすべての文字が同じです、 それは仕事を得る必要があります。 しかし、それを行うのではなく、あなたは何を知っていますか？ さらに別の方法があります。 

それは私がいた場合1.c--を生かすなら 別のファイルにそれを置くために。 それでは、次のように2.Cを大文字にしましょう​​。 私は本当にここにこれをクリーンアップするつもりです。 その代わりにさえしたの 知っているか、またはそれらの低レベルを気に 実装の詳細は、私の代わりによ ただ文字を印刷しようとして、 引用引用終わり、パーセントのC、および その後、別の関数を呼び出すこと それは引数を取る存在し、 これは、このように、文字です。 

それはそこにあります、Cで判明します 別の関数の呼び出し 上部に、どのその名の通り 示唆している文字を取ります その大文字にします 同等、それを返します。 その結果、printf関数はそこにそれをプラグインすることができます。 そして私は、しかし、これを行うには 1他のファイルを導入する必要があります。 これは、別のファイルがあると判明します あなたが唯一のクラスから知っているだろうと、 または教科書、またはオンライン C type.h.と呼ばれる基準、 

だから私は、私のヘッダの中でそれをアップ追加した場合 ファイルは、今再コンパイルこのプログラムは、 capitalize2は、入力します./capitalize2。 のはすべてでZamylaを入力してみましょう 小文字は、まだ同じように動作します。 しかし、あなたは何を知っていますか？ それは、上部にそれを判明します 他のいくつかの機能を備えています。 

そして、私はこれを紹介しましょう ここでは、コマンド、ソートのぎこちなく 名前が、マニュアルのマニュアル。 それは、そのほとんどのLinuxコンピュータが判明します 我々は、Linuxオペレーティングをhere--使用しているとして、 コマンドを持っていますsystem-- 呼ばれる男、と言い、 ちょっと、コンピュータ、私を与えます コンピュータのマニュアル。 あなたがする何をしたいですか そのマニュアルにルックアップ？ 

私は、機能を見てみたいです 上部に呼ばれ、入力します。 そして、それは少し不可解です 時々読み取ります。 しかし、私たちがしているに気付きます Linuxのプログラマのマニュアル。 そして、それはすべてのテキストです。 そして、そこだと気付きます ここで機能アップの名前。 それが呼ばれるのいとこを持ってい判明します 反対の動作をしている、低下させます。 そして、これを使用するには、概要の下に気付きます manページを機能する、いわば、 私はことを私に語っています type.h. cを含める必要があります そして、私は練習からのことを知っていました。 

ここでは、それは私に2を見せています 関数のプロトタイプ、 そのため、私は今まで、これを使用したい場合 私は、彼らが入力として取るか知っています、 彼らは出力として返すもの。 そして、私が読んだ場合 説明、私が参照してください。 関数が何をするかをより詳細に示します。 しかし、もっと重要なのは、もし 私は、戻り値の下に見えます それは、戻り値があると言います 変換された文字のこと、 またはC、元の入力、場合 変換は不可能でした。 

言い換えれば、上位にしようとします 大文字に文字を変換します。 そうであれば、それを返すために起こっています。 しかし、それはいくつかのreason--ためにすることができない場合 多分それは既に大文字です、 多分それは感嘆符です またはいくつかの他のpunctuation-- それだけに起こっています 元のCを返し、 私は私のコードを作ることができることを意味します より良い次のように設計されています。 

私はすべてを必要としません コー​​ドのこれらのくそライン。 私はしましたラインのすべて ちょうど強調表示することができます ただ1つの単純に崩壊します this-- printfの％であるライン、 アッパーSブラケットにC iが。 そして、これは次のようになります より良い設計の例。 

なぜ7または8行で実装 コー​​ドの、何でもそれはちょうど私でした あなたが代わりに折りたたむことができたときに、削除 そのロジックのすべてと意思決定 一つのラインに、13今、その ライブラリに依存していますfunction-- Cに付属している機能が、その あなたはそれが何をしたいのかを正確に行います。 そして、率直に言って、たとえ それは、Cが付属していません、 あなたが通り、それを自分で実装することができ 我々は負のintを取得すると、見てきました そして、同様に正の整数先週得ます。 

このコードは今より読みやすくなります。 そして、確かに、私たちは上にスクロールすると、 どのくらいのよりコンパクトに見えます 私のプログラムのこのバージョンです。 それは、今少しトップヘビーです で、これらすべてが含まれています。 今私が立っているので、しかし、それは、OKです プログラマーの肩の上に 私の前に。 そして、それは誰でも誰でした 本当に上部に実装 多くの人は誰でも同じように、私に好意をやりました 本当にスターリングを実装 いくつかの時間前に私に好意をしました。 そして今、我々は持っています より良い設計プログラム それはまったく同じロジックを実装しています。 

スターリングといえば、聞かせ 私は先に行くとこれを行います。 私が先に行くと、保存してみましょう stirling.cとしてこのファイル。 そして、それは結局のところ、我々は戻って皮をむくことができます かなり簡単になりました1他の層。 私は先と鞭行くつもりです メイン内の別のプログラムアップ ここではその単純再実装 文字列の長さ以下のように。 だからここのコードの行は、ということです 私は、ユーザから文字列を取得します。 私たちは何度も何度もこれを使用し続けます。 私は自分自身と呼ばれる変数を挙げてみましょう 番号を格納するint型のn個。 

そして、私が先に行くとしましょう 次のロジックを実行します。 s内のn番目の文字がしますが 等しくないバックスラッシュ0、先に行きます そしてnをインクリメントします。 そして私は、n printfのパーセントをプリントアウト。 私はここで、このプログラムと主張し、 文字列の長さを呼び出さずに、 文字列の長さを割り出し。 

そして、魔法は完全です 8行目にカプセル化 ここでは、新しい構文のように見えるもので、 一重引用符で、このバックスラッシュ0。 しかし、なぜそのようになるのですか？ まあ、されているものを検討 すべてのこの時間に行きます。 

私は忘れる前に、脇やなど、実現 あまりにも、そのmanページに加えて、 それは、典型的に来ます CS50 IDEのようなLinuxシステム、 実感して私たちは、 もちろんのスタッフ、また持っています ウェブサイトのバージョンを作りました 呼ばれるこの同じ考えの 持ってreference.cs50.net、 それらの同じmanページのすべて、 その同じのすべて ドキュメントだけでなく、 ことができます上部にある小箱 あなたはかなりのすべてを変換します あまり快適に難解な言語 モード、我々、教員、 経および簡素化しようとしています 物事を保つために、言語の一部 アイデアに焦点を当てた、とされません 専門的の一部。 だから、心に留めておく、reference.cs50.net 別のリソースとしてだけでなく。 

しかし、なぜ文字列の長さはで動作しません 私は前の瞬間を提案した方法はありますか？ ここZamylaの名前が再びです。 そして、ここでZamylaの名前です 私がやり続けるよう、で箱入り、 それがあることの絵を描くために、 本当に、文字だけのシーケンス。 しかしZamylaは存在しません。 プログラムで分離インチ 

あなたが書いたプログラムを実行すると、 あなたがお使いのMacまたはPCを使用しています メモリ、またはRAMとしていわば。 そして、あなたが考えることができます 持つものとして、コンピュータ メモリのギガバイトの多く、これらの日。 そしてギグは十億を意味し、 バイトのように数十億。 

しかし、それでは、時間に巻き戻してみましょう。 そして、私たちが使用していると仮定 本当に古いコンピュータこと 専用メモ​​リの32バイトを持っています。 私できた、私のコンピュータの画面上で、 次のように単純にこれを引き出します。 

私は単に私のことを言うことができます コンピュータは、このメモリのすべてを持っています。 そして、これがあれば、メモリスティックのようなものです あなたは最後の時間から私たちの絵を思い出します。 そして、私はちょうど分割した場合 この十分な回数で、 私は32バイトを持っていると主張しています 画面上のメモリ。 

さて、実際には、私ができる唯一の ここでは、この画面上でこれまでに描画します。 だから私は、先に行くつもりです ちょうど慣例により、 私のコンピュータのメモリを描きます グリッドだけではなく、一直線として。 具体的には、私は今と主張しています このグリッドは、この8×4のグリッド、 ただ、すべての32バイトを表し、 私のMacで利用可能なメモリの、 または自分のPCで利用できます。 そして、彼らはラップしています 上の2行だけ それは、画面上よりフィットするので。 しかし、これは最初のバイトです。 これが第二のバイトです。 これは、第3バイトです。 

そして、これは第32バイトです。 または、我々はコンピュータのように思われる場合 科学者は、これは、バイト0、1、2、3、31です。 だから場合は、0〜31を持っています あなたは、0からカウントを開始します。 

だから我々はプログラムを使用する場合 呼び出しは、文字列を取得すること、 私たちは、人間から文字列を取得します 私はZamyla、Z-A-M-Y-L-Aと呼ばなかったような、 どのように世界ではありません コンピュータは、どのバイトを追跡し、 メモリのどのチャンク、 これは文字列に属していますか？ 言い換えれば、我々はに進む場合 コンピュータに別の名前を入力し、 このアンディのように、呼び出し 文字列二度目を取得し、 -N-D-Iは、で終わる必要があります コンピュータのメモリも同様に。 しかし、どのように？ 

まあ、それは下にいることが判明します フード、どのようなCは、文字列を格納しない場合 人間のタイプで、またはそのこと それは、いくつかの他のソースから来て それらの端部との輪郭を描きます 特別character--バックスラッシュ ただ特別な方法である0、 行の80ビットを言って。 

だからA--これは数97リコールです。 8ビットのため、一部のパターン 進数97を表します。 このバックスラッシュ0は、文字通り数です 0、別名ヌル、N-U-L、以前とは違って、 N-U-L-L、我々はについて話しました。 しかし今のところ、ちょうどこのことを知っています バックスラッシュ0は、行でちょうど80ビットです。 

そして、それはでちょうどこのラインです 左側には、何も言う砂 1つの文字列、または1つのデータ・タイプに属します。 そして、何も右に 何か他のものに属します。 アンディの名前、一方、 これは単に視覚的に 他のラインへ折り返すことを起こります、 それは、ちょうど審美的なディテールです 同様にNULが終了されます。 

これは、A-N-D-Iの文字の文字列です プラス五秘密の文字、 ただ画定全て0ビット、 アンディの名前の末尾にも。 そして、我々が呼び出した場合、文字列3回目を取得 コンピュータ内のような文字列を取得します マリア、M-A-R-I-Aは、同様にマリアのです 名前NULは、バックスラッシュ0で終了します。 

これは根本的に異なっています どのようにコンピュータが通常とから 整数、または浮動小数点数、または他の格納 まだデータ型、リコールので、 整数は、通常、32ビットであり、または 4バイト、または多分64ビット、 または8バイト。 しかし、コンピュータの多くのプリミティブ プログラミング言語の 固定数を有します hood--の下にバイト 多分1、多分2、多分4、多分8。 

しかし、文字列は、設計によって、持っています 文字の動的な数。 あなたがされるまで、事前に知っていません Z-A-M-Y-L-Aでのヒト型、 またはM-A-R-I-A、またはA-N-D-I。あなたは知りません 何回ユーザーがヒットしようとしています キーボード。 したがって、あなたが方法がわかりません 事前に多くの文字 あなたが必要になるだろう。 

だからCはちょうど一種のように葉 フードの下に秘密のブレッドクラム 文字列の末尾に。 メモリ内のZ-A-M-Y-L-Aを格納した後、 それはまた、単に同等のものを置きます 期間の。 文の終わりに、 それはように、80ビットを置きます ここで覚えておくべき Zamylaが開始され、終了します。 

だから、接続は何ですか、 その後、このプログラムに？ ここでこのプログラム、スターリング、 機構は、単に 文字列を取得するための ユーザーから、6行目。 7行目、私は変数を宣言します nと呼ばれ、それが0に等しく設定。 

そして、8行目では、私は単純に尋ねました 質問、n番目の文字がない間 等しくないすべて0 bits-- 言い換えれば、しません 同じこの特別な 文字、バックスラッシュ0、どの ちょうどその特別なヌルcharacter--ました 先に行くと、ちょうどn個をインクリメントします。 

そして、それをやり続けると、キープ それをやって、それをやり続けます。 そしてそうであっても中にかかわらず、 私たちは私を使用した過去、 それは完全に罰金です 意味的にn個使用します、 あなただけにしようとしている場合 意図的にこの時間をカウント、 ちょうどnはそれを呼び出すようにしたいです。 だから、これはただ質問を保ち、 すべて0秒のn番目の文字はありますか？ ない場合は、次の外観に見て、 、次に見て、次に目を向けます 次に目を向けます。 

しかし、すぐにあなたがバックスラッシュ0を見るように、 11--を通じてこのloop--線9が停止します。 あなたは、whileループから抜け出します その変数nの内側に残します のすべての合計数 あなたが見た文字列の文字、 それによって、それをプリントアウト。 それでは、これを試してみましょう。 

私は先に行ってみようと、なし スターリング関数を使用して、 しかし、ちょうど私の自身の自家製のバージョンを使用して ここでは、スターリングと呼ばれる、私は先に行ってみましょう そして、何かにスターリング、タイプを​​実行します 私は事前に知ってZamyla、など 6文字です。 それが動作するかどうかを見てみましょう。 確かに、それは6です。 それでは、ロブ、3文字で試してみましょう、 3文字だけでなく、など。 だから、起こっていることすべてです フード真下に。 そして、の接続に気付きます、 その後、最初の週で クラスの、どこに我々はについて話しました 抽象化のようなもの、 そのアイデアのちょうどこの階層化され、または 複雑さ、基本的な原則の上に。 ここでは、ソートの探しています スターリングのボンネットの下に、 そう把握するために、話すこと、 それがどのように実装されるでしょうか？ 

そして、我々はそれを自分自身を再実装可能性があります。 しかし、我々は決して再びつもりです 再実装スターリングへ。 私達はちょうどになるだろう 順番にスターリングを使用 実際にいくつかの文字列の長さを取得します。 

しかし、魔法はありません ボンネットの下に。 あなたはその下に知っていれば フード、文字列 文字だけのシーケンスです。 そして、その文字列 すべての数値的に対処することができます ブラケット0、ブラケット付き 1、ブラケット2、そしてあなた 文字列の末尾にあることを知っています 特殊文字、あなたが把握することができます の中で最も何かをする方法 プログラムは、すべてのためにそれはつまるところ 読み取り、メモリを書いています。 それが変化すると見て、あります メモリで、または物事を動かします 周りのメモリで、印刷物事 画面上など。 

それでは、今、この新たにを使用してみましょう 実際にストリングス何の理解 ボンネットの下にあり、 一つの他の層をバック剥離 それまで今まで私たちがきました 完全に無視されて。 具体的には、任意の時間 我々はプログラムを実装しました、 次のコード行を持っていました 上部付近にメイン宣言する。 そして、我々はint型の主な空隙を指定しました。 

括弧内とその空隙 すべてのこの時間、メインと言ってきました それ自体は引数をとりません。 主であることを任意の入力 ユーザーから取得するつもり いくつかの他から来るように持っています メカニズム、などの取得int型、 またはフロートを取得、または文字列を取得し、 またはいくつかの他の機能。 しかし、それはことが判明します あなたがプログラムを書くとき、 あなたが実際に指定することができます このプログラムはものと 人間からの入力を取ります コマンドライン自体に。 

言い換えれば、たとえ我々これまで こんにちはちょうど./helloを実行してきました または類似のプログラムのすべて 私たちが使ってきた他のプログラム、 私たち自身が書いていないこと、 取っている、それはそうです、 コマンドラインarguments-- メイクのようなもの。 あなたはmakeに似た何かを言います、 し、2番目の単語。 または打ち鳴らす、あなたがして打ち鳴らすと言うと、 第2ワード、ファイルの名前。 

あなたがかもしれないとして、あるいはRMまたはCP 見たか、既に使用しています 削除するか、ファイルをコピーします。 それらのすべては、いわゆる取ります コマンドラインarguments-- ターミナルプロンプトで追加の言葉。 しかし、今まで、我々 自分は持っていませんでした からの入力を取るこの贅沢 ユーザー彼または彼女が実際に実行されます コマンドラインでプログラムそのもの。 

しかし、我々は再宣言することでそれを行うことができます メインはないものとして、前進します 括弧内に無効、 しかし、これら二つの引数 最初の整数instead--、 第二何か 私たちはコールするつもりだ新しい、何か アレイ、精神において似たような 我々はリストとしてスクラッチで見たものに、しかし、 文字列の配列は、我々はすぐに表示されますよう。 しかし、ここでは、することによって、これを見てみましょう 一例として、私たちの前に それが意味を正確に区別しています。 

だから私はCS50 IDEに行けば ここで、私は先に行ってきました そして、呼ばれるファイルで宣言 次のテンプレートをargv0.c。 そして、唯一の事に気付きます それは、これまでに違います 私はintに空隙変更したということです 近くのargc文字列argvのオープンブラケット、 ブラケット。 そして、あり、今のところ気付きます これらのブラケットの内側には何もありません。 

何の数はありません。 そして、そこには私がいない、または N、または他の任意の文字。 私は使用しています 今の角括弧、 私たちが来るの理由で バックに一瞬インチ 

そして今、私は何するつもりだことはこれです。 ARGCが等しい場合に等しいです2-- そして、equalsに等しいリコール 等価演算子を比較しています 平等のための左右。 それは割り当てではありません あるオペレータ、 コピーを意味し、単一の等号、 右からいくつかの値を左に。 

ARGCが2に等しい等しい場合、私がしたいです たとえば、printf関数、こんにちは、パーセント、新しいライン、 そしてその後in--プラグ、ここで新機能 理由のために、argvのブラケット1をtrick-- 私たちはその瞬間に戻って来ること。 他にargcがない場合 2等しく、あなたは何を知っていますか？ ちょうど先に行くと、いつものように、印刷してみましょう 無置換でアウトこんにちは世界。 

だから、ARGC場合、どのように思われます 、2に等しい、引数の数を表し 私はプリントアウトするつもりです こんにちは、何かまたは他。 そうでない場合は、デフォルトでは、私はよ こんにちは、世界を印刷しよう。 だから、これは何を意味するのでしょうか？ 

まあ、私が先に行くと、保存してみましょう このファイル、およびその後argv0を作るのですか、 そしてその後./argv0、入力します。 そして、それは世界が挨拶します。 さて、それはなぜですか？ 

まあ、それはいつでもあなたが判明します コマンドラインでプログラムを実行し、 あなたは私たちがよに充填されています 一般的に引数ベクトルを呼び出します。 換言すれば、自動的に コンピュータ、オペレーティングシステム、 あなたのプログラムに手しようとしています 自身の言葉のすべてのリスト 人間は時に入力したこと 場合のプロンプトで、 プログラマはやってみたいです その情報を使って何か。 そして、この場合には、単語のみ 私は./argv0でプロンプトに入力しました。 

だから引数の数であります 私のプログラムに渡されることはただ一つです。 言い換えれば、引数 そうでない場合のargcとして知られ、カウント ここでは整数として、一つだけです。 一つは、もちろん、二つ等しくありません。 そして、これはこんにちは、世界を印刷するものです。 

しかし、私はこのどこかを見てみましょう。 私が言ってみましょう、argv0。 そして、どのようにマリアはどうですか？ そして、入力し、Enterを押します。 

そして魔法ここに何が起こるかわかります。 今、代わりにハロー世界の、私が持っています このプログラムの動作を変更 ない取得からの入力を取ることによって、 文字列または他​​のいくつかの機能、 しかし、どうやら、私のコマンドから それ自体、私はもともとで入力した内容。 そして私は、再びこのゲームをプレイすることができます 例えば、ステリオスに変えます。 

そして今、私はまだ別の名前を参照してください。 そしてここで、私はアンディが言うかもしれません。 そして、私はZamylaを言うかもしれません。 そして、私たちは一日中、このゲームをプレイすることができ、 わずかに異なる値をプラグイン、 あまりにも長い間、私は正確に提供するように プロンプトで二つの言葉、 その結果、argcが、私の引数の数は、2です。 

私は名前が差し込まことを参照しています printf関数、ここでこの条件ごとに？ だから我々は今持っているように見えます 表現力 別のメカニズムからの入​​力を取ります、 いわゆるコマンドラインから、 むしろ待つことよりも ユーザーがプログラムを実行するまで、 そしてその後、彼または彼女を促します GET文字列のようなものを使用。 

だから、これは何ですか？ argcが、再び、ちょうど整数であり、 words-- arguments--数 その時に提供されたユーザー ターミナルウィンドウで、プロンプト、 プログラムの名前を含みます。 だから、私たちの./argv0は、効果的であり、 プログラムの名前、 またはどのように私はプログラムを実行します。 

それは単語とし​​てカウントされます。 だから、argcが1になります。 しかし、私はステリオスを書くとき、または アンディ、またはZamyla、またはマリア、 それは、引数の個数が2であることを意味します。 そして今で渡された2つの単語があります。 

予告、私たちは、このロジックを続けることができます。 私が実際に言っている場合 Zamylaチャンのようなもの、 フルネーム、それによって渡します 合計3引数、 今では再びデフォルトを言い、 もちろん、3が2に等しくないからです。 

だから、このように、私が持っています この新しい引数のargvを介したアクセス 我々は技術的にできること 私たちが望むものを呼び出します。 しかし、慣例により、それはです それぞれARGVとARGC、。 ARGV、引数ベクトルは、一種であります プログラミングのための同義語の Cでの特徴は、配列と呼ばれます。 

アレイは、類似した値のリストです バック、背中合わせにするために、バックアップします。 換言すれば、一方が右ここにある場合 RAMは、次の1が右隣にあります、 そして右隣に。 彼らはあらゆる場所にはありません。 そして、後者のシナリオでは、物事 すべてのメモリ内の場所にあり、 実際に強力な機能することができます。 ときに我々が、我々はそれに戻ってきます 手の込んだデータ構造について話しています。 今のところ、配列だけです 連続したメモリのチャンク、 その要素のそれぞれ バック、背中合わせにするために、バックアップするために、 そして、一般的に同じタイプ。 

だから、から、考えてみれば 一瞬前に、文字列は何ですか？ さて、文字列、Zamylaのような、 Z-A-M-Y-L-Aは、技術的には、あります 配列だけ。 これは、文字の配列です。 

だから私たちは本当に私のように、これを描く場合 メモリのチャンクとして、以前行いました、 これらのそれぞれが判明します 文字バイトを占めます。 そして、その特別があります センチネル文字、バックスラッシュ0、 またはすべての8 0ビット、その その文字列の終わりを画定します。 だから文字列は、それが変わります アウト、引用終わりの文字列を引用 chara--の配列だけです 実際のデータ型であるchar型。 

そして今のargv、meanwhile-- プログラムに戻ってみましょう。 私たちは言葉を見ていてもARGV、 ここで文字列は、文字列自体ではありません。 ARGV、引数ベクトル、 文字列の配列です。 

だから、の配列を持つことができると同じように 文字は、あなたがより高いレベルを持つことができ、 strings--の配列ので、例えば、 私は先ほど入力したとき./argv0 argv0、空間Z-A-M-Y-L-A、私がいると主張 argvが、it-- ./argv0内の2つの文字列を持っていました およびZ-A-M-Y-L-A。に つまり、argcが2でした。 何故ですか？ 

まあ、効果的に、何が起こっています これらの文字列のそれぞれである上 もちろん、文字の配列であります 前のように、各そのの文字 1バイトを占めます。 そして、実際の0を混同しないでください 0でプログラムの名前で、 これはすべて80ビットを意味します。 そしてZamylaは、一方、まだです また、文字の配列。 

一日の終わりにそう、それは本当に ボンネットの下に、次のようになります。 しかし、どのように主の性質によって、argvを 作品は、私はこのすべてをラップすることができます 、可能ならば、より大きな配列にアップ 私たちは少しオーバー簡素化する場合には、その 絵は次のようになりますとそうでないもの かなりそこにスケールアップするためにそれを描きます、 この配列は、サイズのみ2の最初のものです 文字列が含まれているの要素、 の2番目の要素 その文字列が含まれています。 そして、今度は、あなたの場合 種類ごとにズームイン これらの文字列の何 ボンネットの下を参照してください。 各文字列はちょうどであるということです 文字の配列。 

さて、文字列だけの場合と同様に、 我々はアクセスを得ることができました 文字列内のi番目の文字へ その角括弧表記を使用。 同様に、配列で 一般的には、私たちすることができます 取得するために角括弧表記法を使用 配列内の文字列の任意の数で？ 例えば、私を聞かせて 先に行くと、これを行います。 

私が先に行くとargv1.cを作成してみましょう、 これは少し異なるこの時間です。 代わりにargc2をチェックします、 私の代わりにこれを行うつもりです。 int型のために私は0を取得し、私が小さいです ARGCより、Iプラスプラス、 そしてその後、この内部のプリントアウト パーセントの、改行してから、 argvのブラケット私。 

だから、他の言葉で、私は扱っていませんよ 現時点では個々の文字。 これらの空の角によって暗示としてARGV、 名前ARGVの右にあるブレース、 文字列の配列ですARGVを意味します。 そして、argcがちょうどintです。 

ここでこの行、6、さ セットを言って、私は0に等しいです。 、までのすべての方法を数えます しかしARGC、含みません。 そして、それぞれの繰り返しで、 文字列を出力します。 どのような文字列？ 

ARGVのi番目の文字列。 私がいた前のに対し、だから 角括弧を使用して、 i番目に取得するための表記法 今、文字列内の文字、 私は、角括弧表記を使用しています 配列内のi番目の文字列で取得します。 だから、一つの層のようなものです 概念的には、上記の。 

だからこのことについてきちんとしたものです 今プログラム、私はargv1コンパイルした場合、 そしてその後./argv1を行い、その後、入力 fooのバーbazのようなもので、 3デフォルトの単語れています コンピュータ科学者は、任意の時間のために達します 彼または彼女は、いくつかのプレースホルダのワードを必要とします、 そして、入力し、Enterキーを押し、それらの単語のそれぞれ、 これは、プログラムの名前を含みます 最初の場所でのargvであり、 一度に一つの印刷されてしまいます。 そして、私はこれを変更し、私はと言えば argv1 Zamylaチャンのようなもの、 我々は、これらの3つのすべてを取得します argv0ある言葉、 argv1、argv2、この中のため、 ケースargcが、カウントは、3です。 

しかし、どのようなきちんとしたのは、あなたが理解している場合であります そのargvが文字列の配列だけであり、 あなたは文字列があることを理解します 文字の配列です、 私たちは、実際には一種のこれを使用することができます 角括弧表記法を複数回 文字列を選択し、選択します 文字列内の文字、 次のように深いダイビング。 この例では、私は手放します 先にこのargv2.cを呼び出します。 そして、この例では、私は先に行ってみましょう そして、私は0を取得するint型のためfollowing--を行います 私は、私のargc未満のプラス プラス、直前に好きです。 だから今この他words--とで 十分に複雑なっています。 それから私は言うつもりです ARGV内の文字列を反復処理、 自分自身へのコメントとして。 そして、私が持っているつもりです おそらくあなたのループのためにネストされました 行われ、または検討しています スクラッチで、やって、どこで 私はint--私は言うつもりです 再び私を使用するつもりはありません、 私はシャドウしたくないので、または ソートの既存私を上書きします。 

私はので、代わりに、Jを言うつもりです それは、私の後に変数に私の外出です 私はちょうどにしようとしているとき 単純な数を数えます。 jについて0--を取得し、また、nは、しようとしています argvのブラケット私の船尾長さを取得し、 限りjがメートル未満であるように、 Jプラスプラス、次の操作を行います。 そして、ここで興味深い部分です。 

文字や改行をプリントアウトし、 私は、argvのブラケットにブラケットJを差し込みます。 [OK]を、ので、私はここにいくつかのコメントを追加してみましょう。 文字を反復処理 現在の文字列で、 i番目の文字列に印刷j番目の文字。 だから今、のは、考えてみましょう これらのコメントは何を意味します。 

文字列を反復処理 argv--でどのように多くの 文字列は配列である、ARGVにありますか？ ARGC多く、私は反復よ 私はARGCまで0に等しいから。 一方、どのように多くの文字 ARGVのi番目の文字列にありますか？ 

まあ、その答えを得るために、 私は文字列の長さを呼び出します 現在の文字列に私は気に 私argvのブラケットである、およそ。 そして、私は一時的にそれを保存するつもりです 値nは、単にキャッシュのために、 効率のためにそれを覚えています。 そして私は、0にJを初期化するつもりです jがn未満である限り、続けます、 そして、各反復増分j上。 

そして、ここで、あたり ライン12上の私のコメント、 文字をプリントアウトし、 新しい行が続き、 具体的にはargvのブラケット 私は私にi番目の文字列を与えます そうargv--の最初の単語、 2ワード、3ワード目、何でも。 そして、jが深くにダイブし、取得します 私、その単語のj番目の文字。 だから、実際には、あなたが扱うことができます argvの多次元として、 2次元、配列として、 これによりルックスのすべての単語の種類 あなたの心の中でこのような 目、およびすべての文字 種類の中で構成され、 列は、それが役立ちます。 

実際には、ときに我々はいじめます 今後数週間で、この離れて、 少しになるだろう それよりも、より洗練されました。 しかし、あなたは本当にすることができます 今のところ、そのことを考えて、 ちょうどこの2次元として それの配列、それによって1レベル すべての文字列です。 そして、あなたは深く、あなたの中に潜っている場合 個々の文字を取得することができます ここではこの表記法を使用して、その中に。 

だから、正味の効果は何ですか？ 私は先に行ってみようと argv2--くそにそれを作ります。 私はここでミスを犯しました。 暗黙的に宣言 ライブラリ関数スターリング。 だから、すべてのこの時間は、それはです おそらく適切な 私たちは、ソートの仕上げていること 場所を正​​確に我々が始まりました。 

私は暗黙的に宣言し、めちゃくちゃ ライブラリ関数スターリング。 OK、ちょっと待って。 私は特に、それを覚えています それはここだから。 私は中string.hのを含める必要があります このバージョンのプログラム。 

私は先に行ってみようと含み string.hの、それを保存し、先に行きます そして、argv2を再コンパイルします。 そして今、ここでは入力して、argv2作る、行きます。 そして、それは少しだけれども 一見不可解な、 何、確かに、それに気付きます ドットargv2で印刷されます。 

しかし、私は後にいくつかの単語を入力した場合 プロンプト、argv2 Zamylaチャンのように、 また、少しを入力してください 一見不可解。 しかし、我々はバックアップにスクロールすると、 ./argv2 Z-A-M-Y-L-C-H-A-N。 だから我々はすべての単語を反復処理しました。 そして、今度は、私たちは反復処理しました ワード内のすべての文字。 

さて、このすべての後、 あることを実感 私たちは親切してきた一つの他の詳細 この全体の時間を無視します。 私達はちょうど離れてからかったもの メインの入力はできますか？ どのようなメインの出力は？ 

この時間のすべて、我々がしてきました 単にコピー＆ペースト メインの前の単語はint、 あなたがオンラインで表示されることがありますが、 時々間違って古いバージョンで Cとコンパイラの、彼らは、無効と言うこと またはまったく何もありません。 しかし、確かに、のバージョン 私たちが使用しているCの、 C 11、または2011、実現 それはint型でなければならないこと。 そして、それはどちらかでなければなりません ボイドやargcとargvをここに。 

しかし、なぜint型メイン？ それは実際に戻って何ですか？ まあ、それは、この時間のすべてが判明します あなたがプログラムのメインを書いている任意の時間 常に何かを返しています。 しかし、それはそう密かにやっています。 

その何かがあります int型、ライン5が示すように。 しかし、どのようなint型？ まあ、これがあります プログラミングのコンベンション、 それによって何も持っていない場合 間違って、すべてが順調です、 一般的なプログラムと機能 ややcounterintuitively-- return-- 0。 0は、一般的にすべてが順調である意味します。 だから、あなたが考えるにもかかわらず、 多くの状況ではfalse、それ、 それは実際に一般的に良いことを意味します 

一方、プログラムが1を返す場合、 または負の1、または5、または負の42、 または任意の非0値、 それは一般的意味します その何かが間違っています。 実際には、あなた自身のMacやPC上で、 あなたが実際に見たことがあるかもしれません エラーメッセージ、それによってそれを 何かまたは他の、エラーが語ります コー​​ド負の42、またはエラーコード 23、またはそのような何か。 その数は、一般的にだけヒントです プログラマー、または会社へ それは、ソフトウェアを作りました、 何がなぜ間違っているといいました、 彼らはを通して見ることができるように、 自分のドキュメントやコード、 とものを把握 エラーが実際に意味します。 それは一般的ではありません 私たちに有用なのは、エンドユーザー。 

しかし、ときに主は0を返し、すべてが順調です。 そして、あなたが指定していない場合 返す必要があります主なものを、 それだけで自動的になります あなたのための0を返します。 しかし、何かを返します 他には、実際に有用です。 

この最終的なプログラムでは、私を聞かせて 先に行くと、このexit.cを呼び出し、 今日の最後を紹介 エラーコードとして知られているトピック、。 私が先に行くと、私たちが含まれてみましょう おなじみのファイルをバックアップし、トップには、int型のメインを行います。 そして、この時間は、のは、int型のargcをさせ、 文字列ARGV、と私のブラケット付き それは、アレイ内のだということを意味します。 そして、私はちょうど健全性チェックをしましょう​​。 今回、ARGCがない場合 2等しく、その後、あなたは何を知っていますか？ 忘れてください。 私はそれを言うつもりです、ねえ、ユーザー、 あなたは、コマンドライン引数が不足しています バックスラッシュn個。 

そして、それはそれです。 私は終了します。 私は、先制するつもりです そして途中で本当に、リターン 番号1以外の何か。 最初の値にアクセスしてください 起こることができるエラーが1です。 あなたはいくつかの他の誤ったを持っている場合 発生する可能性がある状況では、 あなたはリターン2言うか3を返す、または可能性があります 多分負の1または負の2。 

これらは、ちょうど終了コードです それは、一般的には、 プログラマにとって有用な、またはのみ ソフトウェアを出荷しています会社。 しかし、実際にはそれがだと 0ではないが重要なのものです。 そのため、このプログラムでは、私はしたい場合は、 保証、このプログラムのみ ユーザーが私を提供する場合に動作 2の引数の数と、 プログラムの名前、および他のいくつかの 単語、私は次のように多くを強制することができ、 printf関数の格言を持つユーザーで叫びます、 コマンドライン引数が不足し、 1を返します。 それはちょうど、すぐになります プログラムを終了します。 

ARGCが等しい場合にのみ、2は、我々が降ります ここでは、その時点で私は言うつもりです、 こんにちはパーセント秒、バックスラッシュnは、argv1。 言い換えれば、私はよ argvの0の後つもりはありません、 どのプログラムの名前だけです。 私は、ハロー、カンマを印刷したいです 人間が入力された第2ワード。 そして、この場合に ライン13は、すべてが順調です。 

私はARGCが2であることを知っています 論理的に、このプログラムから。 私は先に行くと、0を返すつもりです。 余談として、心に留めておくこと これは、同様にスクラッチも同様です。 

論理的には、私はこれを行うことができます そしてこれらの行をカプセル化 ここでは、このelse節内のコードの。 しかし、それは一種のです 不必要に自分のコードをインデント。 そして、私はスーパーを作りたいです 明確な何があっています、 デフォルトでは、ハロー 何かは、印刷されてしまいます ユーザーが協力している限り。 

だから、使用することは非常に一般的です 条件、ちょうどあれば、 いくつかの誤ったをキャッチします 状況、および、終了します。 そして、あまりにも長い間すべてであります よく、他に持っていません、 しかし、単にコードを持って その外、それはだから場合 この中で同等 特定の場合、論理的に。 だから私はちょうどに、0を返しますよ 明示的にすべてが順調である意味。 

私はリターン0を省略した場合、それは希望 自動的に私のために想定されます。 しかし、今、私は戻っていること 少なくともこの場合には1、 私は良い測定のために、するつもりだし、 透明度は、この場合には0を返します。 だから今私が先に行くと出口を作ってみましょう、 これだけ残すのに最適なセグエです。 

しかし、出口を作り、私は手放します 前方と./exitを行い、入力します。 プログラムは、私怒鳴ら コマンドライン引数が欠落。 [OK]を、私が協力しましょう​​。 

入力し、デビッド、私が代わりに./exitをやってみましょう。 そして今、それはデビッドこんにちは、と言います。 そして、あなたは通常、これを見ないであろう。 

しかし、それはそこだと判明します 実際に参照するには、Linuxで特別な方法 どのような終了コードでプログラムが終了しました。 時には、グラフィカルで MacのOSやWindowsのような世界、 あなただけのこれらの数字を参照してください。 エラーメッセージが画面上にポップアップ表示します プログラマ あなたにその番号を示しています。 しかし、我々はどのようなエラーが表示する場合 メッセージは、我々はそれを行うことができ、ありますhere-- そう./exit、入力し、印刷 コマンドライン引数が欠落。 

私は今ある$？をエコーない場合 探して途方もなく不可解な。 しかし、$？ 魔法の呪文です それは、言うねえ、コンピュータ、 何以前教えてください プログラムの終了コードがありました。 そして、私はEnterキーを押します。 それはどのような私だ​​から、私は、1を参照してください 返すために私の主な機能に語りました。 

一方、私はダビデを./exit行う場合には、 そして、入力し、Enterキーを押し、私はデビッドこんにちは、参照してください。 そして場合、私は今、$？、私はハロー0を参照してくださいエコーありません。 そして、これは実際になります 貴重な情報であること デバッガの文脈では、ないので、 あなたは、人間が、気になることくらい。 しかし、デバッガと他の プログラムでは、我々はこの学期を使用します 多くの場合、その番号を見ていきます、 それは一種の隠さだにもかかわらず、 あなたは、にそれを見ていない限り 決定プログラムのかどうか 実行が正しいか間違っていました。 

そして、そのためには、に私たちをもたらします この、一日の終わりに。 私たちは、を見て、今日開始しました デバッグ、およびコースで順番に 自分自身、そしてその後、より興味深いのは、 技術的にはボンネットの下に どのような文字列で最後に、これです 週私たちは当たり前のかかりました、 確かにそれらを取りました スクラッチに付与されたため。 

我々は、我々はどのようにアクセスできるかを見て 文字列内の個々の文字、 そして再び、より高いレベルを取りました well--どのように見て、物事を見て 私たちは、個々に取得したい場合 構造のようなリストの要素、 我々は、複数の文字列でそれを行うことができないのですか？ そして、我々は、コマンドライン引数を持つことができます。 しかし、ここだけのボックスのこの絵 この一般的なアイデアの実証であります 配列、またはリスト、またはベクトルの。 とに応じて、 コンテキスト、これらの単語のすべて わずかに異なるものを意味します。 だからCで、我々は唯一のつもりです 配列について話をします。 そして、アレイは、塊です 人の記憶の、それぞれのです 要素は、戻って、連続しています 、背中合わせにするために、バックアップします。 

そして、これらの要素は、一般に、あります 同じデータ型、文字、 文字、文字、文字、または 文字列、文字列、文字列、文字列、またはint型、 int型、int型、それが何であれ 我々は店にしようとしています。 しかし、一日の終わりに、これは 何それは概念的ように見えます。 あなたは、あなたを取っています コンピュータのメモリやRAM。 そして、あなたはにそれを切り開くています 同じサイズの箱、そのすべての に、バックアップする、戻ってきました バック、この方法でバックアップします。 

約素敵なものです このアイデア、事実 我々はこの方法で値を表現することができます 当社のデータ構造の最初と クラスでは、我々が開始できることを意味します コー​​ドの問題を解決するために それは、週0でそう直感的になりました。 あなたは携帯電話を思い出し 本例で、ここで 我々は、除算を使用し、征服します またはバイナリ検索アルゴリズム、 全体を取捨選択します 名前と番号の束。 しかし、我々はそのことを、リコールを想定しました 電話帳は、すでにソートされました 他の誰かがすでに持っていたこと out--名のリストを与えられた考え出し それらをアルファベット順にする方法numbers--。 そして今、そのCで、私たち、 あまりにも、能力を持っています 、物事をないレイアウトします 物理的に電話帳で しかし、事実上、コンピュータの中で メモリは、我々は来週ことができるようになります 最初this--再び導入します array--における当社のデータ構造の しかしもっと重要なのは、実際のコンピュータ 科学アルゴリズムが実装さ コー​​ド内で、我々は保存できると このような構造のデータを、 その後、それを操作するために開始し、かつ 実際の問題を解決するために、 そしてその上に構築するため、 最終的には、C言語でプログラム、 Pythonで、JavaScriptで、 SQLでデータベースを照会しますか？ 

そして、我々はこれらのすべてが表示されます インターロックさまざまなアイデア。 しかし、今のところ、ということを思い出します 我々が今日導入ドメイン この事はここにあった、と 暗号の世界。 そして、次の問題、あなたを自分の中で 解決します暗号の芸術です、 スクランブルとデスクランブル 情報、および暗号化 そして、テキストを解読、 そして最終的に仮定 あなたは今何を知っていること ボンネットの下にあります そのため、あなたが参照するか、または受信したとき このようなメッセージ、あなた 自分はそれを解読することができます。 このすべて、そしてより多くの次の時間。 

[ビデオ再生] 

-Moverはちょうど到着します。 私は訪問を行くつもりです 彼の大学教授。 うん。 こんにちは。 それはあなたです。 待つ！ デビッド。 私は理解しようとしています あなたに何が起こったのか。 、何でも助けることができるしてください。 あなたは彼の大学でした ルームメイト、あなたはありませんでしたか？ あなたは、ときに彼と一緒にいました 彼はCS50プロジェクトを終えましたか？ 

[MUSICのPLAYING] 

 - つまりはCS50ました。 

私はこの場所が大好きです。 

-平らげる。 私たちは廃業しています。 

[END PLAYBACK] 