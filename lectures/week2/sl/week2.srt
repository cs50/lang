1
00:00:00,000 --> 00:00:02,970
>> [GLASBA]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Malan: V redu.

4
00:00:15,700 --> 00:00:18,832
To je CS50 in to
je začetek 2 tedna.

5
00:00:18,832 --> 00:00:21,040
In se spomnite, da se je
zadnjih nekaj tednov,

6
00:00:21,040 --> 00:00:24,490
smo jih uvaja računalnik
znanosti in, po drugi strani, programiranje.

7
00:00:24,490 --> 00:00:27,640
>> In smo začeli zgodbo s pomočjo
Scratch, da grafični jezik

8
00:00:27,640 --> 00:00:28,990
iz Media Lab MIT.

9
00:00:28,990 --> 00:00:30,780
In potem nazadnje,
prejšnji teden, si mi

10
00:00:30,780 --> 00:00:34,450
uvesti higher-- a
jezika na nižji ravni znana

11
00:00:34,450 --> 00:00:36,770
kot C, nekaj, kar je zgolj tekstovno.

12
00:00:36,770 --> 00:00:39,440
In res, zadnjič, ko smo
raziskati v tem kontekstu

13
00:00:39,440 --> 00:00:40,450
več konceptov.

14
00:00:40,450 --> 00:00:43,010
>> To, odpoklic, je bil zelo
Prvi program smo iskali.

15
00:00:43,010 --> 00:00:45,710
In ta program, preprosto,
natisne, "Zdravo, svet."

16
00:00:45,710 --> 00:00:47,730
Ampak tam je tudi veliko
Navidezna magic dogaja.

17
00:00:47,730 --> 00:00:51,460
Tam je to #include
s temi kotnih oklepajih.

18
00:00:51,460 --> 00:00:52,170
Tam je int.

19
00:00:52,170 --> 00:00:53,020
Tam je (ničen).

20
00:00:53,020 --> 00:00:56,330
Tam je oklepaji, zaviti oklepaji,
podpičji, in še veliko več.

21
00:00:56,330 --> 00:00:58,480
>> In tako opozarjajo, da
smo uvedli praske

22
00:00:58,480 --> 00:01:02,110
tako da bi lahko v idealnem primeru, glej preteklost
da skladnja, stvari, ki v resnici ni

23
00:01:02,110 --> 00:01:04,590
vse to razumsko
zanimivo, vendar že na začetku

24
00:01:04,590 --> 00:01:07,700
je nujno, malce zapleteno
zaviti vaš um okoli.

25
00:01:07,700 --> 00:01:10,860
In seveda eden izmed najpogostejših
stvari že na začetku v programskem razredu,

26
00:01:10,860 --> 00:01:13,443
predvsem za tiste manj
udobno, je, da se razočarane

27
00:01:13,443 --> 00:01:17,460
in spotaknil jih nekatere skladenjskopomenske
napake, da ne omenjam logičnih napak.

28
00:01:17,460 --> 00:01:19,800
In tako med našimi cilji
Danes, v resnici, bo

29
00:01:19,800 --> 00:01:23,280
je, da vas opremili z nekaterimi
reševanje težav tehnike, kako

30
00:01:23,280 --> 00:01:26,705
za boljše reševanje težav sami
v obliki odpravljanje napak.

31
00:01:26,705 --> 00:01:29,330
In se spomnite tudi, da je
okolje, ki smo uvedli

32
00:01:29,330 --> 00:01:31,780
Zadnjič, ko je bil imenovan CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
To je spletno programsko opremo, ki
vam omogoča, da program v oblaku,

34
00:01:34,850 --> 00:01:38,450
tako rekoč, držeč vse vaše
datotek skupaj, saj smo spet bo danes.

35
00:01:38,450 --> 00:01:41,480
In spomnim, da smo
revisited te teme tukaj,

36
00:01:41,480 --> 00:01:44,480
med njimi funkcije in zank, in
spremenljivke, in Boolove izrazi,

37
00:01:44,480 --> 00:01:45,110
in pogoji.

38
00:01:45,110 --> 00:01:49,190
In dejansko nekaj več, da smo
prevedena iz sveta Scratch

39
00:01:49,190 --> 00:01:50,800
v svet C.

40
00:01:50,800 --> 00:01:53,220
>> Toda temeljna zgradba
bloki, tako rekoč,

41
00:01:53,220 --> 00:01:55,150
so bili res še vedno isto prejšnji teden.

42
00:01:55,150 --> 00:01:57,900
Dejansko smo res samo imeli
drugačna puzzle kos, če hočete.

43
00:01:57,900 --> 00:02:00,300
Namesto tega vijolično
shrani blok, smo namesto

44
00:02:00,300 --> 00:02:02,940
je printf, ki je
ta funkcija v C, ki

45
00:02:02,940 --> 00:02:05,890
vam omogoča, da natisnete nekaj
in ga oblikujte na zaslonu.

46
00:02:05,890 --> 00:02:07,950
Smo uvedli CS50
Knjižnica, kjer vas

47
00:02:07,950 --> 00:02:11,420
imajo zdaj na vaši get_char odstranjevanje,
in get_int in get_string,

48
00:02:11,420 --> 00:02:14,610
in še nekaj drugih funkcij, kot
dobro, prek katerega lahko dobite vhod

49
00:02:14,610 --> 00:02:16,260
od uporabnika lastno tipkovnico.

50
00:02:16,260 --> 00:02:20,640
In smo tudi pogled na stvari
kot these- bool in char,

51
00:02:20,640 --> 00:02:22,490
in double, float,
int, long_long niz.

52
00:02:22,490 --> 00:02:25,170
In tam je tudi druge vrste podatkov v C.

53
00:02:25,170 --> 00:02:28,560
>> Z drugimi besedami, ko se prijavijo
spremenljivka za shranjevanje določeno vrednost,

54
00:02:28,560 --> 00:02:32,600
ali ko izvajajo funkcijo
da vrne neko vrednost,

55
00:02:32,600 --> 00:02:35,290
lahko določite, kaj
tip vrednosti, ki je.

56
00:02:35,290 --> 00:02:37,310
Je niz, kot je
zaporedje znakov?

57
00:02:37,310 --> 00:02:39,490
Ali je to število, kot celo število?

58
00:02:39,490 --> 00:02:41,390
Je to plavajočo vejico
Vrednost ali podobno?

59
00:02:41,390 --> 00:02:46,180
Torej, v C, za razliko od nič, smo dejansko
začel navesti kakšne podatkov

60
00:02:46,180 --> 00:02:48,330
smo se vračajo ali uporabo.

61
00:02:48,330 --> 00:02:51,910
>> Ampak, seveda, smo naleteli tudi na
nekatere temeljne meje računalništva.

62
00:02:51,910 --> 00:02:54,100
In predvsem,
ta jezik C, odpoklic

63
00:02:54,100 --> 00:02:57,070
da smo si na
celo preliv, realnost

64
00:02:57,070 --> 00:03:00,460
da, če imate le
končna količina pomnilnika

65
00:03:00,460 --> 00:03:04,600
ali, natančneje, končna številka
bitov, lahko računate tako visoko samo.

66
00:03:04,600 --> 00:03:08,460
In tako smo iskali v tem primeru tukaj
pri čemer števec na letalu,

67
00:03:08,460 --> 00:03:13,510
pravzaprav, če deluje dovolj dolgo bi
preliva in povzroči programske opreme

68
00:03:13,510 --> 00:03:15,560
dejansko fizično možna napaka.

69
00:03:15,560 --> 00:03:18,600
>> Ogledali smo si tudi plavajoče
točka nenatančnost, realnost

70
00:03:18,600 --> 00:03:22,280
da le končno število
bitov, ali je to 32 ali 64,

71
00:03:22,280 --> 00:03:27,330
lahko določite le toliko številk
Po decimalno vejico, po katerem

72
00:03:27,330 --> 00:03:29,110
začeli, da bi dobili nenatančno.

73
00:03:29,110 --> 00:03:32,360
Tako, na primer, ena tretjina v
svet tukaj, v našem človeškem svetu,

74
00:03:32,360 --> 00:03:35,360
vemo, je samo neskončno število
od 3 let vejico.

75
00:03:35,360 --> 00:03:38,820
Vendar računalnik ne more nujno
predstavljajo neskončno število številk

76
00:03:38,820 --> 00:03:42,590
če le dovolite, da nekateri
končna količina informacij.

77
00:03:42,590 --> 00:03:45,900
>> Torej, ne le, da smo vas opremili
z večjo močjo v smislu

78
00:03:45,900 --> 00:03:49,280
o tem, kako bi lahko izraziti sebe na
tipkovnice v smislu načrtovanja,

79
00:03:49,280 --> 00:03:51,430
smo omejeni tudi kaj
lahko dejansko narediti.

80
00:03:51,430 --> 00:03:55,790
In res, lahko hroščev in napak
izhajajo iz teh vrst vprašanj.

81
00:03:55,790 --> 00:03:59,900
In res, med tem danes
se bodo teme, kot so odpravljanje napak

82
00:03:59,900 --> 00:04:03,699
in dejansko je videti pod pokrovom
kako so bile uvedene stvari zadnjem tednu

83
00:04:03,699 --> 00:04:05,490
dejansko izvajajo
tako da boste bolje

84
00:04:05,490 --> 00:04:10,530
razumeti obe zmogljivosti in
omejitve jeziku, kot je C.

85
00:04:10,530 --> 00:04:14,770
>> In v resnici, bomo lupine nazaj plasti
od najpreprostejših strukture podatkov,

86
00:04:14,770 --> 00:04:17,756
nekaj, kar se imenuje matrika, ki
Scratch se zgodi, da klic "seznam".

87
00:04:17,756 --> 00:04:19,589
To je malo
razlikuje v tem kontekstu.

88
00:04:19,589 --> 00:04:23,340
In potem bomo uvesti tudi eno izmed
Prvi od naših domensko specifičnih problemov

89
00:04:23,340 --> 00:04:26,790
v CS50, svet
kriptografija, umetnost kodiranja

90
00:04:26,790 --> 00:04:29,650
ali šifriranje podatkov tako
ki ga lahko pošljete skrivna sporočila

91
00:04:29,650 --> 00:04:34,520
in dekodiranje skrivna sporočila
med dvema osebama, A in B.

92
00:04:34,520 --> 00:04:37,490
>> Torej, preden smo prehodom
v tem novem svetu,

93
00:04:37,490 --> 00:04:42,059
poskusimo vas opremili z nekaterimi
tehnike, s katerimi boste lahko odpravili

94
00:04:42,059 --> 00:04:43,850
ali zmanjšanje vsaj nekaj
od frustracij

95
00:04:43,850 --> 00:04:46,630
da ste verjetno naleteli
več kot samo v zadnjem tednu.

96
00:04:46,630 --> 00:04:50,830
Dejstvo je, pred vami so such-- nekaj
svoje prve težave v C. In kvote so,

97
00:04:50,830 --> 00:04:54,010
Če ste kot jaz, prvič
poskusite vnesti iz programa,

98
00:04:54,010 --> 00:04:57,330
tudi če logično razmišljati
Program je zelo preprosta,

99
00:04:57,330 --> 00:05:01,200
bi lahko zelo dobro zadel zid, in
prevajalnik ne bo sodelovala.

100
00:05:01,200 --> 00:05:03,940
Znamka ali Zvoka ne bo
dejansko opravljate svoje ponudbe.

101
00:05:03,940 --> 00:05:05,450
>> In zakaj bi to lahko bilo?

102
00:05:05,450 --> 00:05:07,950
No, pa si oglejte,
morda preprost program.

103
00:05:07,950 --> 00:05:11,190
Bom, da gredo naprej in shranite to
datoteka namenoma imenuje buggy0.c,

104
00:05:11,190 --> 00:05:13,590
ker vem, da
pomanjkljiva vnaprej.

105
00:05:13,590 --> 00:05:17,400
Ampak jaz ne bi spoznala, da če je to
je prvi ali drugi ali tretji program

106
00:05:17,400 --> 00:05:18,830
da sem pravzaprav kar sam.

107
00:05:18,830 --> 00:05:23,820
Tako da sem šel naprej in
tip ven, int main (praznino).

108
00:05:23,820 --> 00:05:28,130
In potem znotraj mojih zavitih oklepajev,
zelo pozna ( "zdravo, world--

109
00:05:28,130 --> 00:05:30,980
Nagibnica, n ') - in podpičjem.

110
00:05:30,980 --> 00:05:32,360
>> Sem shranili datoteko.

111
00:05:32,360 --> 00:05:34,850
Zdaj bom šel dol
na mojo terminalsko okno

112
00:05:34,850 --> 00:05:40,340
in vrsta make buggy0, ker, še enkrat,
ime datoteke je danes buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Torej, sem tip, da buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> In, oh, bog, odpoklic od zadnjega obiska
da ni sporočil o napakah, je dobra stvar.

115
00:05:48,200 --> 00:05:49,740
Tako da ni izhoda, je dobra stvar.

116
00:05:49,740 --> 00:05:52,920
Ampak tukaj imam jasno
nekateri število napak.

117
00:05:52,920 --> 00:05:56,470
>> Torej, v prvi vrstici proizvodnje
Ko vtipkate da buggy0, odpoklic,

118
00:05:56,470 --> 00:05:59,540
je precej verbose Jek je.

119
00:05:59,540 --> 00:06:02,067
Pod pokrovom,
CS50 IDE je nastavljen

120
00:06:02,067 --> 00:06:04,150
uporabiti cel kup
možnosti s tem prevajalnik

121
00:06:04,150 --> 00:06:05,941
tako da nimate
da razmišljajo o njih.

122
00:06:05,941 --> 00:06:08,840
In to je vse, kar v prvi vrstici
pomeni, da se začne s Jek.

123
00:06:08,840 --> 00:06:11,720
>> Vendar po tem, težave
začeli, da bi njihov videz.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c na progi 3, značaj
5, je velika, rdeča napake.

125
00:06:17,390 --> 00:06:18,380
Kaj je to?

126
00:06:18,380 --> 00:06:23,562
Implicitno razglasitvi knjižnica funkcijo
printf s tipa int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Mislim, da zelo hitro
postane zelo Skrivnosten.

129
00:06:28,379 --> 00:06:30,170
In seveda, v prvi
pogled, da ne bi

130
00:06:30,170 --> 00:06:32,380
Pričakujemo, da boste razumeli
celota tega sporočila.

131
00:06:32,380 --> 00:06:34,213
In tako ena od lekcij
Za danes se dogaja

132
00:06:34,213 --> 00:06:36,919
da je, da bi poskušali obvestilo
vzorci ali podobne stvari,

133
00:06:36,919 --> 00:06:38,960
za napake, boste morda morali
s katerimi se srečujejo v preteklosti.

134
00:06:38,960 --> 00:06:41,335
Torej, kaj je draži samo narazen
te besede, ki so videti poznajo.

135
00:06:41,335 --> 00:06:44,290
Velika, rdeča napaka je jasno
simbol nečesa pa narobe.

136
00:06:44,290 --> 00:06:47,940
>> implicitno razglasi
knjižnica funkcijo printf.

137
00:06:47,940 --> 00:06:51,680
Torej, tudi če ne razumem povsem, kaj
implicitno razglasitvi knjižnica funkcijo

138
00:06:51,680 --> 00:06:54,900
sredstva, problem zagotovo
nanaša na nekako printf.

139
00:06:54,900 --> 00:06:59,130
In vir tega vprašanja
ima opraviti z razglasitev.

140
00:06:59,130 --> 00:07:02,440
>> Razglasitev funkcija je
jo omenjajo prvič.

141
00:07:02,440 --> 00:07:06,210
In smo uporabili terminologijo prejšnji teden
o razglasitvi funkcija je prototip,

142
00:07:06,210 --> 00:07:11,860
bodisi z eno vrstico na vrhu
lastne datoteke ali v tako imenovanem glavi datoteki.

143
00:07:11,860 --> 00:07:15,300
In v kakšnem datoteke naredil rečemo
prejšnji teden, da je printf citat,

144
00:07:15,300 --> 00:07:17,080
konec citata, je izjavil?

145
00:07:17,080 --> 00:07:20,950
V kakšnem datoteka je njegov prototip?

146
00:07:20,950 --> 00:07:24,640
>> Torej, če se spomnimo, zelo prva stvar, ki sem
vnesenih, skoraj vsak program za zadnji time--

147
00:07:24,640 --> 00:07:30,790
in po nesreči pred nekaj trenutki se je začela
myself-- tipkanje je bil to eden here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- za
vhodno / output-- dot h In res,

149
00:07:38,630 --> 00:07:41,860
če sem sedaj shranite to datoteko, da bom
da gredo naprej in jasno mi zaslon,

150
00:07:41,860 --> 00:07:44,740
ki jih lahko naredite z vnosom
Jasno, ali lahko držite Control L,

151
00:07:44,740 --> 00:07:47,680
samo, da počistite terminalsko okno
Samo za odpravo nekaj nereda.

152
00:07:47,680 --> 00:07:51,370
>> Bom, da gredo naprej in
re-vrste make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
In voila, še vedno vidim, da
Dokler ukaz iz Jek,

154
00:07:53,790 --> 00:07:55,470
vendar ni sporočilo o napaki tokrat.

155
00:07:55,470 --> 00:07:58,800
In res, če to storim ./buggy0,
tako kot zadnjič,

156
00:07:58,800 --> 00:08:01,860
kjer je pika pomeni, da ta
imenik, Slash samo pomeni,

157
00:08:01,860 --> 00:08:05,040
tukaj prihaja ime programa in
to ime programa je buggy0,

158
00:08:05,040 --> 00:08:07,340
Vstopi, "Zdravo, svet."

159
00:08:07,340 --> 00:08:09,440
>> Zdaj, kako bi si morali
naberejo to rešitev

160
00:08:09,440 --> 00:08:12,017
ni nujno
priznava, toliko besed,

161
00:08:12,017 --> 00:08:14,350
kot sem storil, seveda ob
to naredil toliko let?

162
00:08:14,350 --> 00:08:18,720
No, spoznali na prvi problem
set, vam predstavil ukaz

163
00:08:18,720 --> 00:08:21,175
da lastno osebje CS50 je
napisal imenovano help50.

164
00:08:21,175 --> 00:08:24,300
In res, C pa specifikacije
problem določiti, kako to uporabiti.

165
00:08:24,300 --> 00:08:27,210
>> Toda help50 je v bistvu
program, ki osebje CS50 je

166
00:08:27,210 --> 00:08:30,850
si napisal, ki omogoča, da delujejo
ukaz ali zaženete program,

167
00:08:30,850 --> 00:08:36,169
in če ne razumejo svoje
izhod, da prenese svoj izhod na help50,

168
00:08:36,169 --> 00:08:38,890
na kateri točki programsko opremo
da osebje Tečaj je napisal

169
00:08:38,890 --> 00:08:42,429
se bo osredotočil na proizvodnjo svojega programa
vrstico za vrstico, znak za znakom.

170
00:08:42,429 --> 00:08:46,000
In če mi, osebje, priznavajo
sporočilo o napaki, ki ste doživlja,

171
00:08:46,000 --> 00:08:50,580
bomo poskušali izzvati z nekaterimi
retoričnih vprašanj, z nekaj nasvetov,

172
00:08:50,580 --> 00:08:54,890
podobno kot TF ali CA ali sam
bi naredil osebno ob uradnih ur.

173
00:08:54,890 --> 00:08:58,320
>> Torej, poglej help50 če ne
nujno prepoznati težavo.

174
00:08:58,320 --> 00:09:00,790
Vendar se ne zanašajte na to
Preveč kot bergle.

175
00:09:00,790 --> 00:09:03,990
Vsekakor poskušali razumeti svoje
proizvodnja in potem učijo od njega

176
00:09:03,990 --> 00:09:07,571
tako da ti le enkrat ali dvakrat storiti
kdaj teči help50 za določeno napako

177
00:09:07,571 --> 00:09:08,070
sporočilo.

178
00:09:08,070 --> 00:09:10,660
Po tem, bi morali biti
bolje opremljeni sami

179
00:09:10,660 --> 00:09:13,180
ugotoviti, kaj je v resnici.

180
00:09:13,180 --> 00:09:14,350
>> Naredimo eno drugo tukaj.

181
00:09:14,350 --> 00:09:20,410
Naj gredo naprej, in v drugi
datoteka bomo to imenujemo buggy1.c.

182
00:09:20,410 --> 00:09:23,110
In v tej datoteki sem
bo deliberately--

183
00:09:23,110 --> 00:09:26,330
ampak se pretvarjamo, da jaz ne
razumeti, kaj napako sem naredil.

184
00:09:26,330 --> 00:09:31,420
>> Bom, da gredo naprej in ne this--
#include, odkar sem

185
00:09:31,420 --> 00:09:33,660
naučil moj nauk od pred nekaj trenutki.

186
00:09:33,660 --> 00:09:36,220
Int main (void), kot prej.

187
00:09:36,220 --> 00:09:40,880
In potem sem jaz grem
narediti niz s - get_string.

188
00:09:40,880 --> 00:09:43,770
In spomnim iz zadnjega časa, ki
To pomeni, hej, računalnik,

189
00:09:43,770 --> 00:09:48,280
daj mi spremenljivko, imenujemo to je to, in
da tip te spremenljivke niza

190
00:09:48,280 --> 00:09:50,150
tako da lahko shranite eno ali več besed v njem.

191
00:09:50,150 --> 00:09:52,191
>> In nato na desni strani
strani enačaja

192
00:09:52,191 --> 00:09:54,980
je get_string, ki je
Funkcija v CS50 knjižnici

193
00:09:54,980 --> 00:09:55,980
da ne točno to.

194
00:09:55,980 --> 00:09:59,740
To postane funkcijo in nato
IT roke od desne proti levi.

195
00:09:59,740 --> 00:10:02,670
Torej, to enačaj ne pomeni,
"Enaka", kot bi si lahko mislili v matematiki.

196
00:10:02,670 --> 00:10:04,750
To pomeni odstop od desne proti levi.

197
00:10:04,750 --> 00:10:09,640
Torej to pomeni, da niz iz
uporabnik in ga shranite znotraj s.

198
00:10:09,640 --> 00:10:10,460
>> Sedaj pa ga uporabljajo.

199
00:10:10,460 --> 00:10:13,820
Naj gredo naprej zdaj in kot drugi
linija, naj gredo naprej in reči "zdravo" -

200
00:10:13,820 --> 00:10:19,330
ni "svet", ampak "Pozdravljeni,% S-
ki je naša ogrado, vejica s,

201
00:10:19,330 --> 00:10:22,030
ki je naša spremenljivka,
in nato podpičjem.

202
00:10:22,030 --> 00:10:26,070
Torej, če nisem zamočil preveč
tukaj, to izgleda pravilno kodo.

203
00:10:26,070 --> 00:10:28,090
>> In moj instinkt zdaj so za njihovo zbiranje.

204
00:10:28,090 --> 00:10:30,400
Datoteka se imenuje buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Tako bom naredil, da buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
In darn-it, če ni
celo več napak kot prej.

207
00:10:36,377 --> 00:10:38,210
Mislim, da je več
sporočila o napakah, da bi

208
00:10:38,210 --> 00:10:40,400
Zdi se od dejanskih vrstic v tem programu.

209
00:10:40,400 --> 00:10:42,730
>> Toda takeaway tukaj je,
tudi če ste preobremenjeni

210
00:10:42,730 --> 00:10:45,040
z dvema ali tremi ali
štiri več sporočil o napakah,

211
00:10:45,040 --> 00:10:48,340
osredotočajo vedno na zelo
Prvi od teh sporočil.

212
00:10:48,340 --> 00:10:52,220
Če pogledamo na zgornjem najbolj eno,
pomikati nazaj, kot je to potrebno.

213
00:10:52,220 --> 00:10:53,930
Torej, tukaj sem tipkal make buggy1.

214
00:10:53,930 --> 00:10:55,700
Tukaj je, da je Jek izhod, kot je bilo pričakovano.

215
00:10:55,700 --> 00:10:57,290
>> In tukaj je prvi red do napake.

216
00:10:57,290 --> 00:11:02,370
Uporaba črno identifikatorja
niz, si mislim standarda v?

217
00:11:02,370 --> 00:11:04,260
Torej, standardna je
dejansko nekaj drugega.

218
00:11:04,260 --> 00:11:06,240
To se nanaša na uporabnikov
tipkovnica, v bistvu.

219
00:11:06,240 --> 00:11:08,080
>> Ampak to ni tisto, kar sem mislil.

220
00:11:08,080 --> 00:11:11,770
Mislil sem vrvico, in sem mislil get_string.

221
00:11:11,770 --> 00:11:16,200
Torej, kaj je to, da sem
pozabil narediti ta čas?

222
00:11:16,200 --> 00:11:20,230
Kaj manjka tokrat?

223
00:11:20,230 --> 00:11:23,600
Imam #include,
tako da imam dostop do printf.

224
00:11:23,600 --> 00:11:26,090
>> Toda kaj mi ni treba
dostop do samo še?

225
00:11:26,090 --> 00:11:29,420
No, tako kot zadnjič,
Moram povedati prevajalniku

226
00:11:29,420 --> 00:11:31,691
Jek kaj te funkcije.

227
00:11:31,691 --> 00:11:33,940
Get_string ne pride
s C. In predvsem to

228
00:11:33,940 --> 00:11:38,160
ne pride v
Glava datoteke.

229
00:11:38,160 --> 00:11:40,770
Namesto tega je na voljo v
Nekaj ​​osebje zapisal,

230
00:11:40,770 --> 00:11:44,176
ki je drugačna datoteka
ime, ampak primerno ime.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Torej, preprosto tako, da doda eno vrstico
od code-- odpoklica zdravila iz zadnjega časa

233
00:11:50,861 --> 00:11:53,610
da ko Jek teče, da se dogaja
pogled na mojo kodo vrha do dna,

234
00:11:53,610 --> 00:11:54,193
od leve proti desni.

235
00:11:54,193 --> 00:11:57,200
To se dogaja, da obvestilo,
oh, hočeš.

236
00:11:57,200 --> 00:11:59,900
Naj gredo in ugotovili, da je
povsod, kjer je na strežniku,

237
00:11:59,900 --> 00:12:03,090
kopirajte in prilepite v bistvu
v vrhu svojega datoteke

238
00:12:03,090 --> 00:12:06,820
tako da na tej točki v zgodbo,
linijo 1, preostali del programa

239
00:12:06,820 --> 00:12:11,651
Lahko, seveda, uporabite katero koli od funkcij
tam, med njimi get_string.

240
00:12:11,651 --> 00:12:13,650
Torej bom prezreti
preostanek teh napak

241
00:12:13,650 --> 00:12:17,190
ker I, seveda, sumijo, da je le
prva dejansko pomembno.

242
00:12:17,190 --> 00:12:20,780
In bom, da gredo naprej in ponovitev,
po shranjevanju mojo kartoteko da buggy1.

243
00:12:20,780 --> 00:12:22,580
In voila, je to storila delo.

244
00:12:22,580 --> 00:12:29,200
In če jaz ./buggy1 in vpišite, za
primer, Zamyla, zdaj bo dobil zdravo,

245
00:12:29,200 --> 00:12:32,000
Zamyla, namesto zdravo, svet.

246
00:12:32,000 --> 00:12:32,550
>> V redu.

247
00:12:32,550 --> 00:12:35,890
Torej takeaways tukaj pa so,
ena, poskusite toliko, kot si lahko naberete

248
00:12:35,890 --> 00:12:39,140
samo iz sporočila o napakah, ki iščejo
na nekaj prepoznavnih besed.

249
00:12:39,140 --> 00:12:43,070
Zapore, da uporabite help50 na
problem je določeno specifikacijo.

250
00:12:43,070 --> 00:12:46,500
Ampak zapore, da je tudi vedno videti
V zgornjem napake samo, vsaj

251
00:12:46,500 --> 00:12:50,051
najprej, da bi videli, katere informacije
da bi dejansko dobili.

252
00:12:50,051 --> 00:12:52,300
Vendar se izkaže, tam je
še več funkcionalnosti zgrajena

253
00:12:52,300 --> 00:12:55,030
v CS50 knjižnico za pomoč
si že na začetku v semestru

254
00:12:55,030 --> 00:12:57,580
in zgodaj v programiranju
ugotoviti, kaj je šlo narobe.

255
00:12:57,580 --> 00:12:59,840
Torej, naredimo še en primer tukaj.

256
00:12:59,840 --> 00:13:04,350
Bom poklical ta buggy2, ki
spet se bo pomanjkljiva ven

257
00:13:04,350 --> 00:13:05,650
skozi vrata, pri načrtovanju.

258
00:13:05,650 --> 00:13:09,980
>> In bom, da gredo naprej
in ne #include.

259
00:13:09,980 --> 00:13:12,580
In potem bom naredil int main (praznino).

260
00:13:12,580 --> 00:13:14,840
In potem bom naredil za zanke.

261
00:13:14,840 --> 00:13:16,690
Za (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i je manjša ali enaka 10.

263
00:13:18,750 --> 00:13:24,260
i ++, nato pa v zavitih oklepajih, jaz grem
natisniti samo simbol hashtag tukaj

264
00:13:24,260 --> 00:13:25,920
in nova linija znak.

265
00:13:25,920 --> 00:13:29,220
>> Torej, moje namere s tem
Program je preprosto

266
00:13:29,220 --> 00:13:33,150
Ponovil 10-krat
in na vsaki ponovitvi

267
00:13:33,150 --> 00:13:35,260
te zanke vsakokrat
skozi cikel,

268
00:13:35,260 --> 00:13:37,660
natisniti oznako teme,
hashtag, hashtag.

269
00:13:37,660 --> 00:13:40,480
Ena na linijo, ker I
imajo novo linijo tam.

270
00:13:40,480 --> 00:13:42,787
In opozarjajo, da je za
zanke, na zadnjem week--

271
00:13:42,787 --> 00:13:44,620
in boste dobili več
seznanjeni s sintakso

272
00:13:44,620 --> 00:13:47,170
z njegovo uporabo v praksi
Pred long-- mi to daje

273
00:13:47,170 --> 00:13:49,740
spremenljivka se imenuje i in ga nastavi na 0.

274
00:13:49,740 --> 00:13:52,650
>> Ta korakih i na
vsako ponovitev do 1.

275
00:13:52,650 --> 00:13:54,940
Tako i gre za 1 do 2 do 3.

276
00:13:54,940 --> 00:13:57,690
In potem ta pogoj v
sredina med podpičji

277
00:13:57,690 --> 00:14:03,010
dobi preverja na vsaki ponovitvi, da bi
prepričani, da smo še vedno v dosegu.

278
00:14:03,010 --> 00:14:06,830
Torej, želim Ponovil 10-krat, tako da sem
imajo neke vrste zelo intuitivno samo

279
00:14:06,830 --> 00:14:09,070
dal 10, kot je moja zgornja meja tam.

280
00:14:09,070 --> 00:14:14,310
>> In vendar, ko sem to teči, ko
je sestavljanje z znamko buggy2--

281
00:14:14,310 --> 00:14:15,440
in to ne pripravijo OK.

282
00:14:15,440 --> 00:14:17,980
Zato sem nimajo
skladenjske napake tokrat.

283
00:14:17,980 --> 00:14:20,940
Naj gredo naprej zdaj
in vodijo buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
In zdaj se pomaknite navzgor.

285
00:14:22,620 --> 00:14:24,890
In mi povečanje
velikost okna.

286
00:14:24,890 --> 00:14:33,720
>> Mi zdi, da imajo 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Torej je 11 oznake tem, čeprav
Jasno sem dal 10 znotraj te zanke.

288
00:14:38,891 --> 00:14:42,140
Zdaj, nekateri od vas bi lahko takoj videli
kaj je napaka, saj res, to

289
00:14:42,140 --> 00:14:43,720
ni zelo težko napaka narediti.

290
00:14:43,720 --> 00:14:46,070
Ampak to je zelo pogosto
je zelo zgodaj.

291
00:14:46,070 --> 00:14:49,820
>> Kaj želim poudariti, čeprav,
se, kako sem lahko to ugotovite?

292
00:14:49,820 --> 00:14:52,300
No, se izkaže, da
CS50 knjižnica prihaja

293
00:14:52,300 --> 00:14:55,380
z ne samo get_string in get_int
in get_float in druge funkcije.

294
00:14:55,380 --> 00:14:59,980
Prav tako prihaja s posebno funkcijo
imenuje eprintf, ali napake printf.

295
00:14:59,980 --> 00:15:03,270
In obstaja le, da bi
je malo lažje za vas

296
00:15:03,270 --> 00:15:06,310
ko debugging kodo samo
natisniti sporočilo o napaki na zaslonu

297
00:15:06,310 --> 00:15:07,850
in vedo, od kod prihaja.

298
00:15:07,850 --> 00:15:11,000
>> Tako, na primer, da bi lahko ena stvar
storiti tukaj s to funkcijo this--

299
00:15:11,000 --> 00:15:20,230
eprintf, nato pa bom šel naprej
in rekel, da sem zdaj% i, poševnica nazaj, n.

300
00:15:20,230 --> 00:15:22,330
In bom priključite v vrednosti i.

301
00:15:22,330 --> 00:15:25,400
In do vrha, ker je to
je v CS50 knjižnici,

302
00:15:25,400 --> 00:15:27,580
Bom, da gredo naprej
in vključujejo

303
00:15:27,580 --> 00:15:29,169
tako da imam dostop do te funkcije.

304
00:15:29,169 --> 00:15:31,460
Ampak kaj je razmisliti, kaj vrstica
9 naj bi počel.

305
00:15:31,460 --> 00:15:32,670
Bom to izbrisati sčasoma.

306
00:15:32,670 --> 00:15:34,670
To nima nič opraviti
s svojim glavnim ciljem.

307
00:15:34,670 --> 00:15:39,090
Ampak eprintf, napaka printf, je samo mišljeno
da bi mi nekaj diagnostične informacije.

308
00:15:39,090 --> 00:15:42,460
Ko sem teči svoj program, želim
videti na zaslonu začasno

309
00:15:42,460 --> 00:15:44,550
kakor tudi samo za razumevanje
kaj se dogaja.

310
00:15:44,550 --> 00:15:47,330
>> In seveda na vsakem
ponovitev tukaj linije 9

311
00:15:47,330 --> 00:15:49,260
Rad bi videl, kaj je vrednost i?

312
00:15:49,260 --> 00:15:50,290
Kakšna je vrednost i?

313
00:15:50,290 --> 00:15:51,280
Kakšna je vrednost i?

314
00:15:51,280 --> 00:15:55,650
In upam, da sem samo naj
glej to sporočilo, prav tako 10-krat.

315
00:15:55,650 --> 00:15:57,780
>> Zato naj gredo naprej in
prevedem program

316
00:15:57,780 --> 00:15:59,905
saj moram narediti kadarkoli
Naredim spremembo. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
In now-- OK.

319
00:16:03,640 --> 00:16:04,820
Tam je veliko več dogaja.

320
00:16:04,820 --> 00:16:07,610
Zato mi dovolite, da se pomaknete v
še večja okna.

321
00:16:07,610 --> 00:16:10,190
>> In videli boste, da je vsak od
Oznake teme je še vedno tiska.

322
00:16:10,190 --> 00:16:15,270
Vmes pa je vsak od njih je sedaj to
diagnostični izhod oblikovano kot sledi.

323
00:16:15,270 --> 00:16:17,960
Ime mojega programa tukaj je buggy2.

324
00:16:17,960 --> 00:16:20,432
Ime datoteke je buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Številka vrstice, iz katere
To je bila natisnjena vrstica 9.

326
00:16:24,080 --> 00:16:27,500
In nato na desni strani, ki je
sporočilo o napaki, da sem pričakoval.

327
00:16:27,500 --> 00:16:30,701
>> In kaj je lepo, o tem, je, da
Zdaj mi ne bi bilo treba nujno računati

328
00:16:30,701 --> 00:16:32,200
v moji glavi, kaj je moj program dela.

329
00:16:32,200 --> 00:16:34,240
Vidim, da na
Prva ponovitev i 0,

330
00:16:34,240 --> 00:16:39,420
nato 1, nato 2, nato 3, nato 4, nato
5, nato pa 6, nato 7, potem 8, nato 9, nato

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Torej, počakaj malo.

333
00:16:42,050 --> 00:16:43,740
Kaj se tukaj dogaja?

334
00:16:43,740 --> 00:16:48,190
Še vedno se zdi, da se štetje
kot je bilo predvideno do 10.

335
00:16:48,190 --> 00:16:50,550
>> Toda, kje naj začnem?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Torej 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11. prst

338
00:16:58,040 --> 00:16:59,990
indikativna problema.

339
00:16:59,990 --> 00:17:02,850
Zdi se mi, da so prešteti
napačno v moji zanki.

340
00:17:02,850 --> 00:17:06,599
Namesto da bi šel 10 iteracij,
Začenjam na 0,

341
00:17:06,599 --> 00:17:09,550
Sem se konča na in do 10.

342
00:17:09,550 --> 00:17:12,030
Ampak ker, kot je računalnik,
Jaz sem z začetkom štetja na 0,

343
00:17:12,030 --> 00:17:15,250
I je treba štetje navzgor
, vendar ne skozi, 10.

344
00:17:15,250 --> 00:17:18,510
>> In tako pritrditi, sem na koncu
spoznal tu, je ena od dveh stvari.

345
00:17:18,510 --> 00:17:22,430
I bi bilo zelo preprosto reči
štetje do manj kot 10.

346
00:17:22,430 --> 00:17:27,260
Torej 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, ki je, seveda, pravilna,

347
00:17:27,260 --> 00:17:28,900
čeprav se sliši malo narobe.

348
00:17:28,900 --> 00:17:35,070
Ali sem lahko naredil je manjša ali enaka
do 9, dokler začnem pri 0.

349
00:17:35,070 --> 00:17:40,056
Ali pa, če res ni všeč, da vas
mogoče prešteti do 10, vendar začnejo pri 1.

350
00:17:40,056 --> 00:17:41,680
Ampak spet, to le ni tako pogosta.

351
00:17:41,680 --> 00:17:43,977
V programming-- pa čeprav
ne toliko v Scratch--

352
00:17:43,977 --> 00:17:45,810
ampak v programiranje v
C in drugih jezikih,

353
00:17:45,810 --> 00:17:47,670
kot JavaScript in
Python in druge, to je

354
00:17:47,670 --> 00:17:49,880
samo zelo pogosto za
Naša razprava o binarni

355
00:17:49,880 --> 00:17:53,450
samo začetek štetja Na
Najmanj si lahko, kar je 0.

356
00:17:53,450 --> 00:17:53,950
V redu.

357
00:17:53,950 --> 00:17:55,160
Tako da je eprintf.

358
00:17:55,160 --> 00:17:58,600
In še enkrat, zdaj sem pogruntal moj
problem, in sem šel nazaj na 0

359
00:17:58,600 --> 00:18:01,470
z manj kot 10, se bom
da gredo v in brisanje eprintf.

360
00:18:01,470 --> 00:18:04,580
>> To ne bi smelo biti tam, ko sem
ladja svojo kodo ali pošljete svojo kodo

361
00:18:04,580 --> 00:18:05,800
ali pokazati nikomur.

362
00:18:05,800 --> 00:18:07,980
To je res samo mišljeno
ki se začasno uporablja.

363
00:18:07,980 --> 00:18:11,650
Zdaj pa sem to določen
Poseben problem, kot dobro.

364
00:18:11,650 --> 00:18:16,780
>> No, naredimo še en primer tukaj
da bom bič, kot sledi.

365
00:18:16,780 --> 00:18:22,850
Bom, da gredo naprej in
#include. 50 $

366
00:18:22,850 --> 00:18:25,580
In bom, da gredo naprej
in #include.

367
00:18:25,580 --> 00:18:29,030
>> In bom rešil
sliko kot buggy3.c.

368
00:18:29,030 --> 00:18:31,740
In bom, da gredo naprej
in ugotovi, int main (praznino).

369
00:18:31,740 --> 00:18:34,186
In potem v notranjosti pa
Bom naredil int i _ -

370
00:18:34,186 --> 00:18:36,435
Želim izvajati program
z get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
To ni funkcija, ki obstaja še.

373
00:18:40,770 --> 00:18:42,870
Tako bomo za izvajanje
je vsak trenutek.

374
00:18:42,870 --> 00:18:45,541
Ampak bomo videli, zakaj
je buggy na prvi priložnost.

375
00:18:45,541 --> 00:18:47,290
In ko sem prišel
int od uporabnika,

376
00:18:47,290 --> 00:18:53,365
Jaz sem le, da bo tiskanje% i negativna
celo, poševnica nazaj, n, vejica, i.

377
00:18:53,365 --> 00:18:55,240
Z drugimi besedami, vsi I
želijo ta program storiti

378
00:18:55,240 --> 00:18:58,000
je dobil negativen int iz
uporabnik in nato natisnete

379
00:18:58,000 --> 00:18:59,980
da je ta in ta negativna int.

380
00:18:59,980 --> 00:19:02,080
>> Zdaj moram za izvajanje te funkcije.

381
00:19:02,080 --> 00:19:05,740
Torej, kasneje v svojem spisu, bom šel
naprej in razglasi funkcijo imenovano

382
00:19:05,740 --> 00:19:10,670
get_negative_int (ničen) - in bomo
pridejo nazaj na tisto, da je linija spet pomeni

383
00:19:10,670 --> 00:19:18,790
v moment-- int n; do-- naredi
following-- printf n :.

384
00:19:18,790 --> 00:19:26,210
In potem bom naredil n - get_int,
in to stori, medtem ko je n večji kot 0.

385
00:19:26,210 --> 00:19:28,310
In se nato vrnite n ;.

386
00:19:28,310 --> 00:19:31,730
>> Torej obstaja veliko dogaja v
to, ampak nobeden od katerih nismo

387
00:19:31,730 --> 00:19:33,710
poglej prejšnji teden, vsaj na kratko.

388
00:19:33,710 --> 00:19:36,980
Torej on line 10 tukaj sem razglašena za
Funkcija se imenuje get_negative_int,

389
00:19:36,980 --> 00:19:39,620
in sem dal (ničen), v
oklepajev, razlog pa je ta

390
00:19:39,620 --> 00:19:40,950
ne bo vhod.

391
00:19:40,950 --> 00:19:42,910
Jaz ne gre nič
te funkcije.

392
00:19:42,910 --> 00:19:44,690
Jaz sem ravno nekaj nazaj od njega.

393
00:19:44,690 --> 00:19:47,270
>> In kaj sem v upanju, da
dobili nazaj, je celo število.

394
00:19:47,270 --> 00:19:50,040
Ni podatkovni tip v
C se imenuje negative_int.

395
00:19:50,040 --> 00:19:52,880
To je samo int, tako da bo
da je na nas, da se prepričajte,

396
00:19:52,880 --> 00:19:55,340
da je vrednost, ki je dejansko
vrnjeno ne samo int

397
00:19:55,340 --> 00:19:56,380
ampak je tudi negativen.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 sem razglasitvi spremenljivko
imenuje n in zaradi česar je tipa int.

399
00:20:02,150 --> 00:20:07,500
In potem v vrstice 13 do 18 let, da sem
delaš nekaj, medtem ko je nekaj res.

400
00:20:07,500 --> 00:20:11,040
Grem naprej in tiskanje
n je, debelega črevesa in nato prostor,

401
00:20:11,040 --> 00:20:12,800
kot poziv za uporabnika.

402
00:20:12,800 --> 00:20:16,410
>> Jaz sem potem kliče get_int in
shranjevanje svojo tako imenovano vrednost donosa

403
00:20:16,410 --> 00:20:18,130
V tem spremenljivo n.

404
00:20:18,130 --> 00:20:22,600
Ampak bom vztrajati početje
To medtem ko je n večji kot 0.

405
00:20:22,600 --> 00:20:27,960
Z drugimi besedami, če uporabnik mi je daje
int in to število je večje od 0,

406
00:20:27,960 --> 00:20:31,180
ergo, pozitivno, bom
kar naprej reprompting uporabnika,

407
00:20:31,180 --> 00:20:37,160
da reprompting, da jih prisili, da
sodelovati in mi negativno int.

408
00:20:37,160 --> 00:20:41,640
>> In ko je n dejansko negative--
Predvidevam, da uporabnik na koncu vrste -50,

409
00:20:41,640 --> 00:20:46,710
potem je to, ko zanka ni več res
ker -50 ni večja od 0.

410
00:20:46,710 --> 00:20:51,140
Tako smo iztrgajo iz da
zanka logično in vrne n.

411
00:20:51,140 --> 00:20:53,520
>> Toda obstaja še ena
kar moram narediti.

412
00:20:53,520 --> 00:20:56,190
In lahko samo to storiti
s kopiranjem in lepljenjem

413
00:20:56,190 --> 00:20:58,540
ena vrstica kode na vrhu datoteke.

414
00:20:58,540 --> 00:21:01,630
Moram naučiti Jek,
ali obljubo, da Jek,

415
00:21:01,630 --> 00:21:04,630
izrecno, da bom,
res, pojdi in izvajati

416
00:21:04,630 --> 00:21:06,020
ta funkcija get_negative_int.

417
00:21:06,020 --> 00:21:07,674
To je lahko samo nižje v datoteki.

418
00:21:07,674 --> 00:21:09,840
Spet opozarjajo, da Jek
bere stvari od zgoraj navzdol,

419
00:21:09,840 --> 00:21:12,330
od leve proti desni, tako da ne more
klic funkcije, če Jek

420
00:21:12,330 --> 00:21:15,330
ne ve, da se dogaja, da obstaja.

421
00:21:15,330 --> 00:21:18,430
>> Zdaj pa, žal, ta program,
kot bi nekateri ste opazili,

422
00:21:18,430 --> 00:21:19,590
je že buggy.

423
00:21:19,590 --> 00:21:21,400
Naj gredo naprej in da buggy3.

424
00:21:21,400 --> 00:21:26,904
Sestavlja, tako da moj problem sedaj ni
napaka sintakso, kot napak tekstovnih,

425
00:21:26,904 --> 00:21:29,570
to je dejansko dogaja, da je logična
napake, ki sem jih namenoma

426
00:21:29,570 --> 00:21:32,450
ki kot priložnost za
korak skozi kaj se dogaja.

427
00:21:32,450 --> 00:21:35,540
>> Bom, da gredo naprej
zdaj in vodijo buggy3.

428
00:21:35,540 --> 00:21:37,490
In sem šel
naprej in ne sodelujejo.

429
00:21:37,490 --> 00:21:39,494
Bom dal to številko 1.

430
00:21:39,494 --> 00:21:41,410
To ni bilo všeč, zato
pa me je spet spodbudilo.

431
00:21:41,410 --> 00:21:42,147
>> Kako približno 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Nihče od tistih, ki delajo.

435
00:21:44,740 --> 00:21:46,890
Kako približno -50?

436
00:21:46,890 --> 00:21:48,560
In program zdi, da dela.

437
00:21:48,560 --> 00:21:49,970
>> Naj poskusi še enkrat.

438
00:21:49,970 --> 00:21:53,400
Naj poskusim -1, se zdi, da deluje.

439
00:21:53,400 --> 00:21:56,380
Naj poskusim -2, se zdi, da deluje.

440
00:21:56,380 --> 00:21:59,640
Naj poskusim 0.

441
00:21:59,640 --> 00:22:01,684
Huh, to je napačna.

442
00:22:01,684 --> 00:22:03,350
Zdaj smo pa malo občutljiv tukaj.

443
00:22:03,350 --> 00:22:07,090
Ampak to je, seveda, v primeru, da 0
niti pozitivno niti negativno.

444
00:22:07,090 --> 00:22:11,150
In tako je dejstvo, da je moj program,
pravi, da je 0 negativno celo število,

445
00:22:11,150 --> 00:22:12,820
to ni tehnično pravilno.

446
00:22:12,820 --> 00:22:15,180
>> Zdaj, zakaj je ta način?

447
00:22:15,180 --> 00:22:16,270
No, bi bilo očitno.

448
00:22:16,270 --> 00:22:18,110
In res, da je program
usojeno dokaj preprost

449
00:22:18,110 --> 00:22:19,670
tako da imamo nekaj za raziskovanje.

450
00:22:19,670 --> 00:22:25,870
>> Ampak kaj je uvesti tretjo razhroščevanje
Tehnika tukaj imenujejo debug50.

451
00:22:25,870 --> 00:22:27,750
Torej to je program
ki smo ga pravkar ustvarili

452
00:22:27,750 --> 00:22:30,770
letos imenuje debug50
ki vam bo omogočilo

453
00:22:30,770 --> 00:22:34,130
za uporabo, kar se imenuje vgrajen
grafični razhroščevalnik v CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
In razhroščevalnik je le program, ki
na splošno vam omogoča poganjanje svoj program

455
00:22:38,400 --> 00:22:44,050
ampak korak za korakom za korakom, skladno
po liniji s strani linije, premori, pikal

456
00:22:44,050 --> 00:22:47,626
okrog, gledamo na spremenljivke, tako da
program ne samo udarec mimo tebe

457
00:22:47,626 --> 00:22:49,750
in hitro natisniti nekaj
ali ne natisne nekaj.

458
00:22:49,750 --> 00:22:53,250
To vam daje priložnost, na
človeški hitrosti, za interakcijo z njim.

459
00:22:53,250 --> 00:22:55,470
>> In za to si
preprosto naredite naslednje.

460
00:22:55,470 --> 00:22:58,479
Po zbiranju kodo,
ki sem ga že naredil, buggy3,

461
00:22:58,479 --> 00:23:00,020
greš naprej in zagon debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Toliko kot help50 ima zaženete
help50 in nato ukaz,

464
00:23:06,760 --> 00:23:10,120
debug50 ima zaženete debug50 in
Nato ime ukaza.

465
00:23:10,120 --> 00:23:14,440
>> Zdaj pa glej, kaj se dogaja na mojem zaslonu,
na desni strani še posebej.

466
00:23:14,440 --> 00:23:19,400
Ko sem udaril Run, vse
nenadno ta desna plošča

467
00:23:19,400 --> 00:23:20,419
odpira na zaslonu.

468
00:23:20,419 --> 00:23:22,210
In tam je veliko dogaja
na na prvi pogled.

469
00:23:22,210 --> 00:23:25,110
Vendar pa ni preveč
veliko skrbeti še.

470
00:23:25,110 --> 00:23:28,570
>> To se mi je pokazal vse
ki se dogaja znotraj mojega programa

471
00:23:28,570 --> 00:23:31,130
prav zdaj, in prek njih
Gumbi up top je potem

472
00:23:31,130 --> 00:23:35,910
mi omogoča, da stopite skozi moje kodo
končno korak po korak za korakom.

473
00:23:35,910 --> 00:23:37,140
Ampak ne še zdaj.

474
00:23:37,140 --> 00:23:38,060
Opazili, kaj se dogaja.

475
00:23:38,060 --> 00:23:40,600
Na mojo terminalsko okno
Jaz pa sem poziv za n.

476
00:23:40,600 --> 00:23:44,560
In bom, da gredo naprej in
sodeluje ta čas in tip v -1.

477
00:23:44,560 --> 00:23:48,770
In čeprav malo cryptically, -1
je negativno celo število, kot je bilo pričakovano.

478
00:23:48,770 --> 00:23:52,020
>> In potem otrok izstopilo z
Stanje 0 GDBserver izhodu.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, je ime
od osnovnega opreme

480
00:23:55,180 --> 00:23:56,620
da izvaja to iskanje in odpravljanje napak.

481
00:23:56,620 --> 00:24:00,500
Ampak vse to v resnici pomeni, razhroščevalnik
odšel, ker je moj program, prenehati

482
00:24:00,500 --> 00:24:01,710
in vse je bilo dobro.

483
00:24:01,710 --> 00:24:06,020
Če hočem resnično debug moj program,
Moram preemptively povedati debug50,

484
00:24:06,020 --> 00:24:08,920
kadar ne želim, da začnete
poglobitvi skozi mojo kodo?

485
00:24:08,920 --> 00:24:11,750
>> In morda najpreprostejši način
za to je, kot sledi.

486
00:24:11,750 --> 00:24:15,300
Če sem hover nad
žleb mojega urednika tukaj,

487
00:24:15,300 --> 00:24:19,090
tako da res samo v stranski vrstici tukaj,
levo števila linije,

488
00:24:19,090 --> 00:24:21,870
opazijo, da če sem samo kliknite
ko sem dal malo rdečo piko.

489
00:24:21,870 --> 00:24:24,460
In da malo red dot,
kot znak stop, pomeni, hej,

490
00:24:24,460 --> 00:24:29,430
debug50, izvedba premor moje kode
tam, ko sem teči ta program.

491
00:24:29,430 --> 00:24:30,260
>> Torej, kaj je to.

492
00:24:30,260 --> 00:24:37,340
Naj gredo naprej in vodijo svoj program
spet z debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
In zdaj, obvestilo, kaj
razlikuje se je zgodilo.

494
00:24:40,110 --> 00:24:42,440
Jaz se ne pozove
Še v mojem terminalskem oknu

495
00:24:42,440 --> 00:24:45,430
za nič, ker nisem
je prišel še v mojem programu.

496
00:24:45,430 --> 00:24:47,950
Obvestilo, da je na liniji 8
ki je danes poudaril,

497
00:24:47,950 --> 00:24:51,720
in tam je malo puščico na
levo pregovor, ki ga tukaj zaustavili.

498
00:24:51,720 --> 00:24:55,030
Ta linija kode, linije
8, še ni izveden.

499
00:24:55,030 --> 00:24:58,940
>> In kaj je radoveden, če gledam
tu čez na desni strani,

500
00:24:58,940 --> 00:25:03,530
opazili, da je i lokalna
spremenljivka, lokalno v smislu

501
00:25:03,530 --> 00:25:05,450
da je znotraj trenutnega delovanja.

502
00:25:05,450 --> 00:25:08,920
In njegova vrednost, očitno privzeto,
in nekako prikladno, je 0.

503
00:25:08,920 --> 00:25:10,260
Ampak nisem tip 0.

504
00:25:10,260 --> 00:25:13,410
Da samo zgodi, da bo svoje
Privzeta vrednost v tem trenutku.

505
00:25:13,410 --> 00:25:15,490
>> Zato naj gredo naprej in to storite zdaj.

506
00:25:15,490 --> 00:25:18,680
Naj gredo naprej in na
top tukaj, sem

507
00:25:18,680 --> 00:25:20,970
dogaja, da gredo naprej in
kliknite to prvo ikono, ki

508
00:25:20,970 --> 00:25:25,360
pomeni korak več, kar pomeni, ne preskočite
pa vendar korak nad to vrstico kode,

509
00:25:25,360 --> 00:25:27,770
bi mogla na poti.

510
00:25:27,770 --> 00:25:30,710
>> In sedaj opazili, moj
hitro se je pravkar spremenili.

511
00:25:30,710 --> 00:25:31,380
Zakaj je tako?

512
00:25:31,380 --> 00:25:33,639
Povedal sem debug50,
zagnati to vrstico kode.

513
00:25:33,639 --> 00:25:34,930
Kaj to vrstico kode storiti?

514
00:25:34,930 --> 00:25:35,960
me vpraša za notr.

515
00:25:35,960 --> 00:25:36,460
V REDU.

516
00:25:36,460 --> 00:25:37,400
Naj sodelujejo.

517
00:25:37,400 --> 00:25:41,340
Naj gredo naprej zdaj in tip -1, Enter.

518
00:25:41,340 --> 00:25:42,920
In sedaj opazili, kaj se je spremenilo.

519
00:25:42,920 --> 00:25:46,060
Na desni strani,
moja lokalna spremenljivka i

520
00:25:46,060 --> 00:25:48,200
je označen kot -1 zdaj.

521
00:25:48,200 --> 00:25:49,810
In to je še vedno tipa int.

522
00:25:49,810 --> 00:25:53,102
>> In obvestilo, tudi moj tako imenovani
klic kup, kjer sem premor?

523
00:25:53,102 --> 00:25:54,810
Bomo govorili več o tem
To v prihodnosti.

524
00:25:54,810 --> 00:25:58,620
Vendar sklad tik nanaša na to, kar
funkcije so trenutno v gibanju.

525
00:25:58,620 --> 00:26:00,040
Zdaj je samo glavni.

526
00:26:00,040 --> 00:26:03,590
In zdaj samo lokalna
spremenljivka je i z vrednostjo 1.

527
00:26:03,590 --> 00:26:09,840
>> In ko sem končno stopiti čez to črto
tukaj z enako ikono v zgornjem desnem kotu,

528
00:26:09,840 --> 00:26:11,410
-1 Je negativno število.

529
00:26:11,410 --> 00:26:13,580
Zdaj je premori nad tem kodraste opornico.

530
00:26:13,580 --> 00:26:14,740
Poglejmo kaj to naredil svoje stvari.

531
00:26:14,740 --> 00:26:17,300
Stopim nad to linijo, in voila.

532
00:26:17,300 --> 00:26:20,240
>> Torej ni vse tako strašno
prosveti še,

533
00:26:20,240 --> 00:26:23,550
vendar pa se mi premor
in mislim skozi logično

534
00:26:23,550 --> 00:26:24,870
kaj ta program počne.

535
00:26:24,870 --> 00:26:26,890
Toda to ni bila napačna zadeva.

536
00:26:26,890 --> 00:26:28,510
Naredimo to še enkrat, kot sledi.

537
00:26:28,510 --> 00:26:31,340
>> Bom zapustil ta odmerka
v 8. vrstici z rdečo piko.

538
00:26:31,340 --> 00:26:32,830
Bom ponovila debug50.

539
00:26:32,830 --> 00:26:34,400
To je samodejno zaustavljen tukaj.

540
00:26:34,400 --> 00:26:37,660
Vendar tokrat namesto
prestopanja v tej vrstici,

541
00:26:37,660 --> 00:26:42,290
Naj dejansko šel notranjost
get_negative_int in ugotoviti,

542
00:26:42,290 --> 00:26:45,530
zakaj je sprejemanje 0 kot veljaven odgovor?

543
00:26:45,530 --> 00:26:47,990
>> Torej, namesto da kliknete Step Over.

544
00:26:47,990 --> 00:26:50,630
Bom, da gredo naprej
in kliknite Step Into.

545
00:26:50,630 --> 00:26:54,030
In opazil, da je linija 8, ki je
zdaj izpostavil zdaj nenadoma

546
00:26:54,030 --> 00:26:56,900
postane linija 17.

547
00:26:56,900 --> 00:26:59,947
>> Zdaj, to ni tako razhroščevalnik
je preskočila linije 14 in 15 in 16.

548
00:26:59,947 --> 00:27:01,780
To je samo ni nič
da vas ni pokazal.

549
00:27:01,780 --> 00:27:04,050
Tisti, ki so samo razglasitvi spremenljivke,
in potem je beseda Ali

550
00:27:04,050 --> 00:27:05,390
in nato odprto kodrasti brace.

551
00:27:05,390 --> 00:27:09,227
Edina funkcionalna linija, ki je
sočno je to res ena tu, 17.

552
00:27:09,227 --> 00:27:11,060
In to je, če smo jih
samodejno zaustavljen.

553
00:27:11,060 --> 00:27:13,870
>> Torej printf ( "n.is:") ;, tako
da se še ni zgodilo.

554
00:27:13,870 --> 00:27:18,250
Torej, gremo naprej in kliknite Step Over.

555
00:27:18,250 --> 00:27:20,326
Zdaj moj poziv, v resnici,
spremenila ( "n:").

556
00:27:20,326 --> 00:27:22,450
Zdaj get_int, ne bom
moti stopil,

557
00:27:22,450 --> 00:27:24,750
ker je ta funkcija je bila
ki jo CS50 v knjižnici.

558
00:27:24,750 --> 00:27:25,750
To je verjetno pravilna.

559
00:27:25,750 --> 00:27:28,440
>> Tako da sem šel naprej in
nekako sodelujejo tako, da ga daje

560
00:27:28,440 --> 00:27:30,590
int, ne pa negativno int.

561
00:27:30,590 --> 00:27:32,870
Zato naj gredo naprej in udaril 0.

562
00:27:32,870 --> 00:27:39,460
In zdaj, kaj se dogaja tukaj
ko pridem dol na linijo 21?

563
00:27:39,460 --> 00:27:40,890
Nisem več ponovitvami.

564
00:27:40,890 --> 00:27:43,320
Mi ne zdi, da je zaljubljen v to zanko.

565
00:27:43,320 --> 00:27:45,990
Z drugimi besedami, ta rumeni
bar ni nadaljuj okoli,

566
00:27:45,990 --> 00:27:47,130
in okrog in okrog.

567
00:27:47,130 --> 00:27:48,340
>> Zdaj, zakaj je to?

568
00:27:48,340 --> 00:27:49,920
No, n, kaj je n prav zdaj?

569
00:27:49,920 --> 00:27:53,280
Jaz lahko ogledate na lokalni
spremenljivke v iskanje in odpravljanje napak.

570
00:27:53,280 --> 00:27:53,816
n je 0.

571
00:27:53,816 --> 00:27:55,190
V redu, kaj je bil moj pogoj?

572
00:27:55,190 --> 00:27:58,700
>> 20-- linija 20 je dobro,
0 večja od 0.

573
00:27:58,700 --> 00:27:59,500
To ni res.

574
00:27:59,500 --> 00:28:01,020
0 ni večja od 0.

575
00:28:01,020 --> 00:28:02,820
In zato sem izbruhnila tega.

576
00:28:02,820 --> 00:28:06,370
>> In da je, zakaj na spletu
21, če sem dejansko še naprej,

577
00:28:06,370 --> 00:28:10,370
Bom vrnil 0, čeprav
čeprav bi moral sem zavrnila 0

578
00:28:10,370 --> 00:28:12,484
saj dejansko ni negativna.

579
00:28:12,484 --> 00:28:14,650
Zdaj sem v resnici ne celo
skrbi razhroščevalnik.

580
00:28:14,650 --> 00:28:16,900
Got it, mi ni treba
vedeti, kaj več se dogaja.

581
00:28:16,900 --> 00:28:19,233
>> Tako da sem šel naprej in
kliknite gumb Predvajaj,

582
00:28:19,233 --> 00:28:20,240
in naj gre ta končal.

583
00:28:20,240 --> 00:28:23,440
Zdaj pa sem spoznal, da je moj
bug je očitno na liniji 20.

584
00:28:23,440 --> 00:28:25,160
To je moja logična napaka.

585
00:28:25,160 --> 00:28:28,100
>> In kaj storiti, hočem
storiti, da bi to spremenili?

586
00:28:28,100 --> 00:28:32,500
Če problem je, da nisem
lov 0, to je samo logična napaka.

587
00:28:32,500 --> 00:28:35,910
In lahko rečem, medtem ko je n
večja ali enaka 0,

588
00:28:35,910 --> 00:28:38,330
da znova in znova poziva uporabniku.

589
00:28:38,330 --> 00:28:41,050
>> Torej, še enkrat, preprosta napaka, morda
tudi očitno, ko si me videl

590
00:28:41,050 --> 00:28:42,410
napisati le nekaj minut nazaj.

591
00:28:42,410 --> 00:28:44,570
Toda takeaway tukaj
je, da z razhroščevanje 50

592
00:28:44,570 --> 00:28:46,850
in odpravljanje napak
Programska oprema bolj splošno,

593
00:28:46,850 --> 00:28:51,370
imate to novo najti moč, da
sprehod skozi svoje kode, poglej

594
00:28:51,370 --> 00:28:55,590
prek tega desnem oknu, kaj
vaše spremenljivke vrednosti.

595
00:28:55,590 --> 00:28:57,700
Torej vam ni nujno
morali uporabiti nekaj

596
00:28:57,700 --> 00:29:00,630
kot si eprintf natisniti te vrednote.

597
00:29:00,630 --> 00:29:04,430
Lahko jih dejansko videli
vizualno na zaslonu.

598
00:29:04,430 --> 00:29:08,920
>> Zdaj, poleg tega pa je treba omeniti,
da obstaja še en tehniko, ki je

599
00:29:08,920 --> 00:29:09,890
dejansko zelo pogosti.

600
00:29:09,890 --> 00:29:13,120
In morda, zakaj je to malo sprašujem
fant tukaj je sedel na odru.

601
00:29:13,120 --> 00:29:16,490
Tako da je ta tehnika, splošno
znan kot gume raca odpravljanje napak,

602
00:29:16,490 --> 00:29:18,786
ki je res samo
dokaz, da je dejstvo,

603
00:29:18,786 --> 00:29:20,660
da pogosto, ko programerji
se pisanje kode,

604
00:29:20,660 --> 00:29:22,650
oni niso nujno
sodelovanje z drugimi,

605
00:29:22,650 --> 00:29:24,030
ali delajo v skupnem okolju.

606
00:29:24,030 --> 00:29:25,050
>> Oni so nekako doma.

607
00:29:25,050 --> 00:29:25,910
Mogoče je pozno ponoči.

608
00:29:25,910 --> 00:29:28,190
Poskušajo sliki
iz neke napake v njihove kode.

609
00:29:28,190 --> 00:29:29,330
In oni enostavno ne vidim.

610
00:29:29,330 --> 00:29:30,329
>> In ni sostanovalka.

611
00:29:30,329 --> 00:29:31,250
Ni TF.

612
00:29:31,250 --> 00:29:32,680
Ni CA okoli.

613
00:29:32,680 --> 00:29:36,440
Vse, kar imajo na svojem pasu
je to malo gume ducky.

614
00:29:36,440 --> 00:29:39,030
>> In tako gumijasta račka debugging
je prav to povabilo

615
00:29:39,030 --> 00:29:42,780
razmišljati o nečem, kot je neumno
saj kot pravi bitje,

616
00:29:42,780 --> 00:29:46,940
in dejansko hodi po kodi
verbalna tem nežive predmeta.

617
00:29:46,940 --> 00:29:49,230
Tako, na primer, če
to je moj primer here--

618
00:29:49,230 --> 00:29:52,470
in opozarjajo, da prej
problem je bil ta,

619
00:29:52,470 --> 00:29:58,140
Če sem izbrisati to prvo vrstico kode,
in sem šel naprej in da vozičkom 0 spet,

620
00:29:58,140 --> 00:30:01,220
spomnil, da sem imel to
sporočila o napakah tukaj.

621
00:30:01,220 --> 00:30:05,997
Torej ideja tukaj, smešno, čeprav I
občutek v trenutku tem javno,

622
00:30:05,997 --> 00:30:06,580
je, da je prišlo do napake.

623
00:30:06,580 --> 00:30:10,910
>> OK, tako da moj problem je, da nimam
implicitno razglasi funkcijo knjižnice.

624
00:30:10,910 --> 00:30:12,610
In to funkcijo knjižnice printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, razglasi
me spominja na prototipov.

626
00:30:15,290 --> 00:30:18,930
>> To pomeni, da je treba dejansko
povej prevajalnik vnaprej, kaj

627
00:30:18,930 --> 00:30:19,980
funkcija izgleda.

628
00:30:19,980 --> 00:30:20,930
Počakaj minuto.

629
00:30:20,930 --> 00:30:23,580
Nisem imel standardno io.h.

630
00:30:23,580 --> 00:30:24,530
Najlepša hvala.

631
00:30:24,530 --> 00:30:27,330
>> Torej samo ta proces of-- vas
ni treba, da dejansko imajo raca.

632
00:30:27,330 --> 00:30:29,819
Toda ta ideja hoje
sami s svojo lastno kodo

633
00:30:29,819 --> 00:30:31,610
tako da boste tudi slišali
sami, tako da vas

634
00:30:31,610 --> 00:30:35,620
uresničiti opustitve v svoje
pripombe, je na splošno ideja.

635
00:30:35,620 --> 00:30:38,910
>> In, morda bolj logično, ni tako
veliko s to eno, vendar je bolj vključen

636
00:30:38,910 --> 00:30:44,220
Primer smo pravkar storili v Otroški voziček 3.c,
morda hodite sami skozi njo

637
00:30:44,220 --> 00:30:45,310
kot sledi.

638
00:30:45,310 --> 00:30:49,190
Torej vse v redu, gume
ducky, DDB, če hočete.

639
00:30:49,190 --> 00:30:52,350
Tukaj imamo v moji glavno funkcijo,
Kličem dobil negativno int.

640
00:30:52,350 --> 00:30:54,660
>> In sem že vrne vrednost.

641
00:30:54,660 --> 00:31:00,410
Jaz shranjevanje na levi strani
na liniji 8 v spremenljivko imenovano i.

642
00:31:00,410 --> 00:31:02,380
OK, vendar počakajte, kako se je
da je dobil to vrednost?

643
00:31:02,380 --> 00:31:04,130
Naj pogled na funkcijo v skladu 12.

644
00:31:04,130 --> 00:31:05,760
>> V skladu 12., smo dobili negativno int.

645
00:31:05,760 --> 00:31:08,190
Ne sprejme nobenih vložkov,
ne vrne int, OK.

646
00:31:08,190 --> 00:31:10,929
on line 14 spremenljivka n izjavljam.

647
00:31:10,929 --> 00:31:12,220
To se dogaja, da shranite celo število.

648
00:31:12,220 --> 00:31:13,760
To je tisto, kar hočem.

649
00:31:13,760 --> 00:31:18,480
>> Torej, naredite naslednje medtem ko n is-- naj
me razveljaviti kaj popraviti sem že.

650
00:31:18,480 --> 00:31:22,710
Torej, medtem ko je n večji kot
0 izpiše n je, OK.

651
00:31:22,710 --> 00:31:25,170
In potem klic se int shranjeni v n.

652
00:31:25,170 --> 00:31:30,160
In nato preveri, če je n 0,
n not-- tam je.

653
00:31:30,160 --> 00:31:31,910
Torej, še enkrat, ne boste
Potrebujemo dejansko raco.

654
00:31:31,910 --> 00:31:35,650
Ampak samo hojo sebe skozi
kodo kot intelektualni vaje

655
00:31:35,650 --> 00:31:37,720
vam bo pogosto pomaga
zavedajo, kaj se dogaja,

656
00:31:37,720 --> 00:31:41,170
v nasprotju s samo delaš nekaj
kot je ta, strmel v zaslon,

657
00:31:41,170 --> 00:31:43,720
in ne govorimo sami s pomočjo
to, kar pošteno ni

658
00:31:43,720 --> 00:31:46,270
Skoraj kot učinkovito tehniko.

659
00:31:46,270 --> 00:31:48,620
Torej, tam ga imate, A
število različnih tehnik

660
00:31:48,620 --> 00:31:52,102
za dejansko debugging kodo
in ugotavljanje motenj, ki so vse

661
00:31:52,102 --> 00:31:54,810
mora biti orodje v vaši orodij
tako da nisi pozno v noč,

662
00:31:54,810 --> 00:31:57,660
še posebej, ko ste v jedilnico
dvorane, ali na uradnih ur,

663
00:31:57,660 --> 00:32:00,368
tolkel glavo proti
zid, ki poskušajo rešiti nekaj težav.

664
00:32:00,368 --> 00:32:02,020
Zavedam se, da je programska orodja.

665
00:32:02,020 --> 00:32:03,720
Obstajajo gume raca orodja.

666
00:32:03,720 --> 00:32:09,630
In tam je celotno osebje
podpira čakajo na pomoč.

667
00:32:09,630 --> 00:32:13,120
>> Zdaj, beseda na problemu
sklopov, in o tem, kaj smo vam v upanju,

668
00:32:13,120 --> 00:32:15,620
ven iz njih, in kako
gremo o ocenjevanju.

669
00:32:15,620 --> 00:32:17,680
Po učnem načrtu predmeta je,
problem kompleti CS50 je

670
00:32:17,680 --> 00:32:22,320
se ocenjujejo na štirih glavnih osi, tako
da speak-- področje, pravilnost, design,

671
00:32:22,320 --> 00:32:23,060
in slog.

672
00:32:23,060 --> 00:32:25,910
In obseg le nanaša na to, koliko
kosa ste odgrizne?

673
00:32:25,910 --> 00:32:28,080
Koliko problem ste že poskusili?

674
00:32:28,080 --> 00:32:30,110
Kaj je stopnja napora
ste se kaže?

675
00:32:30,110 --> 00:32:35,750
>> Pravilnost je, ali delovanje programa, kot
To naj bi po specifikaciji CS50

676
00:32:35,750 --> 00:32:38,640
ko zagotoviti določene inpute
ali določene izhode prihaja nazaj?

677
00:32:38,640 --> 00:32:41,130
Zasnova je najbolj subjektiven izmed njih.

678
00:32:41,130 --> 00:32:43,360
In to je tisti, ki bo
bo najdlje za učenje

679
00:32:43,360 --> 00:32:47,220
in najdlje za poučevanje, v
kolikor izvira na,

680
00:32:47,220 --> 00:32:49,530
kako dobro napisana, je svojo kodo?

681
00:32:49,530 --> 00:32:52,920
>> To je ena stvar, da samo tiskanje pravilno
izhoda ali vrniti prave vrednote.

682
00:32:52,920 --> 00:32:55,400
Vendar so jo počne, ko
čim bolj učinkovito?

683
00:32:55,400 --> 00:32:58,210
Ali ste početje razkoraka
in vladaj, ali binarni

684
00:32:58,210 --> 00:33:01,500
Iskanje saj bomo kmalu videli, da smo naredili
pred dvema tednoma v telefonskem imeniku?

685
00:33:01,500 --> 00:33:04,670
Ali obstajajo boljši načini za reševanje
Problem, kot ga trenutno imamo tukaj?

686
00:33:04,670 --> 00:33:06,380
To je priložnost za boljše načrtovanje.

687
00:33:06,380 --> 00:33:08,530
>> In potem style-- kako
Precej je svojo kodo?

688
00:33:08,530 --> 00:33:12,370
Opazili boste, da sem precej
zlasti o Feed svojo kodo,

689
00:33:12,370 --> 00:33:15,300
in pazite, moje spremenljivke
so upravičeno poimenovali. n,

690
00:33:15,300 --> 00:33:19,660
medtem ko je kratko, je dobro ime za
število, i za štetje celo število,

691
00:33:19,660 --> 00:33:20,727
i za niz.

692
00:33:20,727 --> 00:33:22,560
In bomo lahko imeli več
spremenljivka imena slog.

693
00:33:22,560 --> 00:33:25,500
Style je le, kako dobro
vaša koda videti?

694
00:33:25,500 --> 00:33:26,600
In kako berljiv je to?

695
00:33:26,600 --> 00:33:29,650
>> In več časa, kaj vaši TAS
in TFS bo naredil v letu

696
00:33:29,650 --> 00:33:31,870
se vam s tem
vrsta kvalitativne povratne informacije

697
00:33:31,870 --> 00:33:34,330
tako da ti ne bo bolje
na teh različnih vidikov.

698
00:33:34,330 --> 00:33:37,510
In glede na to, kako mi
ovrednoti vsak od teh oseh

699
00:33:37,510 --> 00:33:40,080
to je običajno z zelo malo
žlice, tako da ti na splošno,

700
00:33:40,080 --> 00:33:41,680
dobili občutek, kako dobro delaš.

701
00:33:41,680 --> 00:33:45,680
In, seveda, če ste prejeli oceno o
vsaka od teh axes-- pravilnost, oblikovanje

702
00:33:45,680 --> 00:33:49,659
in slog especially-- to število
bo praviloma med 1 in 5.

703
00:33:49,659 --> 00:33:52,450
In, dobesedno, če ste dobili
3 je na začetku semestra,

704
00:33:52,450 --> 00:33:53,977
To je zelo dobra stvar.

705
00:33:53,977 --> 00:33:55,810
To pomeni, da je še vedno
prostora za izboljšave,

706
00:33:55,810 --> 00:33:58,490
ki bi upanje v
ob razreda prvič.

707
00:33:58,490 --> 00:34:01,820
Tam je, upajmo, nekaj malo stropa
na katerega si prizadevajo, da bi dosegli.

708
00:34:01,820 --> 00:34:03,970
In tako dobili 3 na
najzgodnejši kosov,

709
00:34:03,970 --> 00:34:06,550
če ni nekaj 2 in 4-ih,
je pravzaprav dobra stvar.

710
00:34:06,550 --> 00:34:08,880
To je tudi v območju,
tudi v okviru pričakovanj.

711
00:34:08,880 --> 00:34:11,421
>> In če je vaš um dirke, počakajte
minuto, tri od petih.

712
00:34:11,421 --> 00:34:12,620
To je res 6 od 10.

713
00:34:12,620 --> 00:34:13,560
To je 60%.

714
00:34:13,560 --> 00:34:14,830
Moj Bog, To pa je v F.

715
00:34:14,830 --> 00:34:15,870
>> Ni.

716
00:34:15,870 --> 00:34:17,600
To ni, v resnici, da je.

717
00:34:17,600 --> 00:34:22,710
Nasprotno, to je priložnost za izboljšanje
tekom semestra.

718
00:34:22,710 --> 00:34:25,580
In če ste dobili nekaj
Poors, to so priložnost

719
00:34:25,580 --> 00:34:29,199
izkoristiti uradnih ur,
zagotovo profili in drugih virov.

720
00:34:29,199 --> 00:34:32,840
>> Najboljše je priložnost, res,
lahko ponosni, kako daleč ste

721
00:34:32,840 --> 00:34:34,520
pridi teku polovice.

722
00:34:34,520 --> 00:34:38,199
Torej se zavedaš, če nič
ostali trije so dobra.

723
00:34:38,199 --> 00:34:40,179
In omogoča prostor za rast v daljšem časovnem obdobju.

724
00:34:40,179 --> 00:34:43,090
>> O tem, kako so ti osi
ponderirana, realno si

725
00:34:43,090 --> 00:34:46,745
dogaja, da preživijo večino svojega časa pridobivanje
stvari za delo, kaj šele pravilno.

726
00:34:46,745 --> 00:34:49,120
In tako pravilnost nagiba k temu
ponderirajo najbolj, tako kot pri

727
00:34:49,120 --> 00:34:51,360
To multiplikativni faktor tri.

728
00:34:51,360 --> 00:34:54,659
Zasnova je tudi pomembna, vendar
nekaj, kar ne nujno

729
00:34:54,659 --> 00:34:58,220
preživeli vse te ure na
poskuša priti stvari samo na delo.

730
00:34:58,220 --> 00:35:00,019
>> In tako je to prilagojenih
malo bolj rahlo.

731
00:35:00,019 --> 00:35:01,560
In potem je slog tehtajo najmanj.

732
00:35:01,560 --> 00:35:03,710
Čeprav to ni nič manj
Pomembno bistveno,

733
00:35:03,710 --> 00:35:05,990
to je samo, morda,
Najlažje prav,

734
00:35:05,990 --> 00:35:08,440
posnemanjem primere smo
storiti v predavanju in oddelku,

735
00:35:08,440 --> 00:35:11,080
s stvarmi, se lepo
zamaknjen, in pripomnil,

736
00:35:11,080 --> 00:35:14,320
in tako naprej, je med najlažje
stvari za početi in dobili pravico.

737
00:35:14,320 --> 00:35:16,960
Tako kot tak, realizirati
da so tiste točke

738
00:35:16,960 --> 00:35:19,000
da so relativno enostavno za razumevanje.

739
00:35:19,000 --> 00:35:22,360
>> In sedaj beseda o
this-- akademsko poštenost.

740
00:35:22,360 --> 00:35:25,150
Torej na tečaj je
učni načrt, boste videli

741
00:35:25,150 --> 00:35:27,630
da je seveda zelo
bit jezika okrog tega.

742
00:35:27,630 --> 00:35:31,380
In seveda je vprašanje
akademsko poštenost zelo resno.

743
00:35:31,380 --> 00:35:33,450
>> Imamo razliko,
za boljše ali slabše,

744
00:35:33,450 --> 00:35:36,570
o poslanem vsako leto več
študentov za disciplinsko

745
00:35:36,570 --> 00:35:39,670
kot večina katera koli druga
Seveda, da sem seznanjen.

746
00:35:39,670 --> 00:35:42,580
To ni nujno
kažejo na dejstvo

747
00:35:42,580 --> 00:35:46,340
da so CS študenti ali CS50 študentov,
nič manj pošten od svojih sošolcev.

748
00:35:46,340 --> 00:35:49,090
Ampak dejstvo, da je v tem
svet, v elektronski obliki, smo samo

749
00:35:49,090 --> 00:35:50,990
imajo tehnološko
sredstvo za odkrivanje te.

750
00:35:50,990 --> 00:35:53,360
>> Pomembno je, da nas
pravičnosti po razredu

751
00:35:53,360 --> 00:35:58,550
da bomo odkriti to, in dvig
vprašanje, ko vidimo stvari.

752
00:35:58,550 --> 00:36:01,980
In samo slikati sliko, in res
da bi nekaj podobnega temu potonejo v,

753
00:36:01,980 --> 00:36:04,600
To so številke
študentov v zadnjih 10 letih

754
00:36:04,600 --> 00:36:07,610
ki so bili vključeni v nekatere
takšna vprašanja akademske poštenosti,

755
00:36:07,610 --> 00:36:10,990
z nekaj 32 študentov
od jeseni 2015, ki

756
00:36:10,990 --> 00:36:13,760
se pravi, da nam bo
zadeva zelo resno.

757
00:36:13,760 --> 00:36:18,380
In, konec koncev, te številke sestaviti,
nazadnje, približno 3%, 4% ali

758
00:36:18,380 --> 00:36:19,120
razreda.

759
00:36:19,120 --> 00:36:25,220
>> Torej za super večino študentov
se zdi, da so črte jasne.

760
00:36:25,220 --> 00:36:27,940
Ampak, da to v
moti, še posebej pozno

761
00:36:27,940 --> 00:36:32,080
ponoči, ko borijo z
nekaj rešitev problema nizu,

762
00:36:32,080 --> 00:36:34,830
da obstajajo mehanizmi
za pridobivanje sebe bolje

763
00:36:34,830 --> 00:36:37,870
podpore, kot si morda
mislim, tudi pri tej uri.

764
00:36:37,870 --> 00:36:40,514
Zavedaj se, da ko bomo prejeli
študent stališča, prečkamo

765
00:36:40,514 --> 00:36:43,430
letos pa jih primerjati med vsako oddajo
pred vsako oddajo lani,

766
00:36:43,430 --> 00:36:47,590
pred vsako oddajo od leta 2007,
in ker gledaš, kot tudi,

767
00:36:47,590 --> 00:36:49,931
koda sklenjenih poslov na spletu,
forumi, delovnih mestih.

768
00:36:49,931 --> 00:36:51,806
In omenimo to,
Res, vse zavoljo

769
00:36:51,806 --> 00:36:56,040
za popolno razkritje, da če
nekdo drug lahko najdete na spletu,

770
00:36:56,040 --> 00:36:57,880
Vsekakor, tako da lahko tudi mi seveda.

771
00:36:57,880 --> 00:37:00,100
Ampak, res, duh
od seveda izvira

772
00:37:00,100 --> 00:37:01,650
te klavzule v učni načrt.

773
00:37:01,650 --> 00:37:03,670
Res je le, da so smiselne.

774
00:37:03,670 --> 00:37:06,680
>> In če smo morali pripraviti na to
z le malo več jezikov,

775
00:37:06,680 --> 00:37:09,770
Zavedam se, da je bistvo vsega
Delo, ki ga predloži v ta tečaj

776
00:37:09,770 --> 00:37:10,954
morajo biti sami.

777
00:37:10,954 --> 00:37:13,870
Ampak od tega, gotovo obstajajo
priložnosti in spodbude,

778
00:37:13,870 --> 00:37:17,300
in pedagoško vrednost obrača
others-- sam je TFS se CA,

779
00:37:17,300 --> 00:37:20,760
TAS, in drugi v razredu,
podpore, kaj šele prijateljev

780
00:37:20,760 --> 00:37:23,547
in sostanovalci, ki so študirali
CS in programiranje prej.

781
00:37:23,547 --> 00:37:25,130
In tako je nadomestilo za to.

782
00:37:25,130 --> 00:37:28,180
In splošno pravilo
je this-- ko prosi za pomoč,

783
00:37:28,180 --> 00:37:31,470
lahko pokažejo svojo kodo za drugim,
vendar pa ne sme videti svoje.

784
00:37:31,470 --> 00:37:34,880
Torej, tudi če ste na uradnih ur,
ali v D dvorani, ali nekje drugje

785
00:37:34,880 --> 00:37:37,450
delajo na neki kos set,
deluje skupaj s prijateljem, ki

786
00:37:37,450 --> 00:37:40,160
je popolnoma v redu v spodnjem
konec dneva vašega dela

787
00:37:40,160 --> 00:37:43,034
naj bi na koncu pripada vsakemu
vas v tem zaporedju, in ne

788
00:37:43,034 --> 00:37:45,700
neka skupno prizadevanje,
razen za končni projekt, kjer je

789
00:37:45,700 --> 00:37:47,410
to je dovoljeno in spodbujati.

790
00:37:47,410 --> 00:37:49,830
>> Zavedaj se, da si, če
bori z nečim

791
00:37:49,830 --> 00:37:52,520
in tvoj prijatelj samo zgodi
bolje na to potem,

792
00:37:52,520 --> 00:37:55,130
ali še bolje na ta problem kot ti,
ali malo dlje naprej od tebe,

793
00:37:55,130 --> 00:37:57,330
to je popolnoma smiselno, da se obrnejo
svojemu prijatelju in rekel, hej,

794
00:37:57,330 --> 00:38:00,480
Vas moti gledaš moje kodo tukaj,
mi pomagali prepoznati, kaj je moja težava je?

795
00:38:00,480 --> 00:38:03,760
In upam, da v
Interes pedagoški vrednosti

796
00:38:03,760 --> 00:38:07,040
da prijatelj ne samo
pravijo, oh, to storiti, temveč,

797
00:38:07,040 --> 00:38:09,917
kaj še manjka na spletu
6, ali kaj podobnega?

798
00:38:09,917 --> 00:38:12,000
Vendar pa rešitev ni
za prijatelja, poleg vas

799
00:38:12,000 --> 00:38:15,617
reči, oh, no, tukaj, mi potegnite
to gor, in kažejo svojo rešitev za vas.

800
00:38:15,617 --> 00:38:16,450
Tako, da je linija.

801
00:38:16,450 --> 00:38:18,670
Pokažete svojo kodo
drugi, vendar pa ne sme

802
00:38:18,670 --> 00:38:22,350
ogled njihovih pristojnosti, ob upoštevanju drugih
omejitve v učnem načrtu predmeta je.

803
00:38:22,350 --> 00:38:24,760
>> Torej, ne pozabite, to
tako imenovana klavzula obžalovanje

804
00:38:24,760 --> 00:38:27,560
V učnem načrtu predmeta, kot tudi,
da če stori nekaj dejanje,

805
00:38:27,560 --> 00:38:30,476
ni smiselno, ampak da bi jo
pozornost vodij tečaja je

806
00:38:30,476 --> 00:38:34,240
v 72 urah, potek
lahko naloži lokalne sankcije, ki jih

807
00:38:34,240 --> 00:38:37,380
lahko vključujejo nezadovoljiva ali
ni razred za delo predložil.

808
00:38:37,380 --> 00:38:41,410
Ampak seveda ne preda
pomembno za nadaljnji disciplinski ukrep,

809
00:38:41,410 --> 00:38:43,010
razen v primerih ponavljajočih se dejanj.

810
00:38:43,010 --> 00:38:46,632
Z drugimi besedami, če ne bi nekaj
neumno, še posebej pozno ponoči, odločitev

811
00:38:46,632 --> 00:38:49,340
da naslednje jutro ali dva dni
kasneje, se zbudiš in zavedaš,

812
00:38:49,340 --> 00:38:50,870
kaj sem mislil?

813
00:38:50,870 --> 00:38:53,890
Vam v CS50 ima izhod
za določitev, da je problem

814
00:38:53,890 --> 00:38:57,170
in ima v lasti do tega, da bomo
boste srečali na pol poti in se ukvarjajo

815
00:38:57,170 --> 00:39:01,500
z njo v zadevi, ki je tako
izobraževalne in dragoceno za vas,

816
00:39:01,500 --> 00:39:04,200
vendar še vedno kaznovalna na nek način.

817
00:39:04,200 --> 00:39:08,590
In zdaj, da bo rob off to.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO PREDVAJANJE]

819
00:39:10,570 --> 00:39:13,540
>> [GLASBA]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END PREDVAJANJE]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Malan: Dobro, mi smo nazaj.

823
00:40:00,490 --> 00:40:03,680
In zdaj gledamo na enem od
Prvi od naših realnih domen

824
00:40:03,680 --> 00:40:08,720
v CS50, umetnost kriptografiji
umetnost pošiljanje in prejemanje

825
00:40:08,720 --> 00:40:11,840
tajna sporočila, šifrirana
sporočila, če hočete,

826
00:40:11,840 --> 00:40:17,060
ki jih je mogoče dešifrirati samo, če imate
nekatera ključna sestavina, da je pošiljatelj

827
00:40:17,060 --> 00:40:18,030
kot dobro.

828
00:40:18,030 --> 00:40:22,120
Torej, to motivira, da bomo sprejeti
poglej na te stvari tukaj,

829
00:40:22,120 --> 00:40:26,750
kar je primer
skrivnost dekoder obroč, ki

830
00:40:26,750 --> 00:40:34,042
lahko uporabimo, da ugotovimo
kaj je pravzaprav skrivnost sporočilo.

831
00:40:34,042 --> 00:40:35,750
V bistvu, nazaj v
dan v osnovni šoli,

832
00:40:35,750 --> 00:40:38,787
če si kdaj poslal skrivna sporočila
nekateri prijatelj ali nekaj simpatij v razredu,

833
00:40:38,787 --> 00:40:40,620
ste morda mislili
si pa pameten

834
00:40:40,620 --> 00:40:46,530
ki ga na svojem kosu menjava papirja,
podobno A do B in B do C in C D,

835
00:40:46,530 --> 00:40:47,590
in tako naprej.

836
00:40:47,590 --> 00:40:50,300
Ampak ti so bili dejansko šifriranje
vaše podatke, čeprav

837
00:40:50,300 --> 00:40:53,300
če je bilo malo nepomembna, ni bilo
da težko učitelj zavedati,

838
00:40:53,300 --> 00:40:55,675
tudi, če si spremeniti
B A in C, B,

839
00:40:55,675 --> 00:40:57,550
ste dejansko ugotovimo,
kaj je sporočilo je bilo,

840
00:40:57,550 --> 00:40:59,700
vendar pa so v šifriranje podatkov.

841
00:40:59,700 --> 00:41:03,420
>> Pravkar ste to počeli
preprosto, podobno kot Ralphie tukaj

842
00:41:03,420 --> 00:41:07,934
v znameniti film, ki igra
precej ad nauseum vsako zimo.

843
00:41:07,934 --> 00:41:08,600
[VIDEO PREDVAJANJE]

844
00:41:08,600 --> 00:41:11,180
Bodi znano vsem, ki
Ralph Parker je s tem

845
00:41:11,180 --> 00:41:14,070
imenovan za člana Mali
Orphan Annie Secret krog

846
00:41:14,070 --> 00:41:17,700
in je upravičen do uživanja vseh časti
in koristi, ki se pojavljajo z njo.

847
00:41:17,700 --> 00:41:24,340
>> -Signed Little Orphan Annie,
-Števec podpisal Pierre Andre, s črnilom.

848
00:41:24,340 --> 00:41:27,160
Priznanja in koristi,
že pri devetih letih.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Kričanje]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Daj no.

853
00:41:34,250 --> 00:41:35,210
Pojdimo na z njim.

854
00:41:35,210 --> 00:41:39,530
Ne potrebujem vse, da jazz
o tihotapcev in pirati.

855
00:41:39,530 --> 00:41:41,660
>> Poslušajte jutri zvečer za
zaključni pustolovščina

856
00:41:41,660 --> 00:41:43,880
črne piratske ladje.

857
00:41:43,880 --> 00:41:46,650
Zdaj je čas za
Annie je skrivnost sporočilo

858
00:41:46,650 --> 00:41:49,840
za vas člani tajne kroga.

859
00:41:49,840 --> 00:41:53,570
Ne pozabite, otroci, samo člani
od Secret Circle, Annie je

860
00:41:53,570 --> 00:41:56,140
mogoče dekodirati Annie je skrivno sporočilo.

861
00:41:56,140 --> 00:42:00,340
>> Ne pozabite, Annie je odvisno od vas.

862
00:42:00,340 --> 00:42:02,880
Nastavite zatiči za B2.

863
00:42:02,880 --> 00:42:05,230
Tu je sporočilo.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Jaz Sem v, moj prvi skrivni sestanek.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Je bil v veliki glasovno nocoj.

868
00:42:15,780 --> 00:42:19,000
Videl sem, da je nocoj je
Sporočilo je bilo zelo pomembno.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, da je sporočilo
od Annie sama.

870
00:42:22,694 --> 00:42:23,860
Ne pozabite, ne povej nikomur.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekund kasneje, sem v edini
soba v hiši, kjer je fant devet

873
00:42:32,930 --> 00:42:37,040
bi sedel v zasebnost in dekodiranje.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Šla sem na naslednjo, E.

876
00:42:42,360 --> 00:42:44,520
>> Prva beseda je lahko.

877
00:42:44,520 --> 00:42:49,032
S, da prihaja lažje zdaj, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Oh, daj no, Ralphie, moram iti!

879
00:42:51,733 --> 00:42:53,688
>> Bom takoj dol, mama!

880
00:42:53,688 --> 00:42:54,188
Gee čarovnik!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, se prepričajte, to-- se prepričajte, kaj?

883
00:43:04,060 --> 00:43:05,970
Kaj je bilo malo Orphan
Annie povedati?

884
00:43:05,970 --> 00:43:07,264
Bodite prepričani, da kaj?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie Je Andy dobil
go, prosim pridi ven?

886
00:43:09,634 --> 00:43:10,480
>> V redu, mama!

887
00:43:10,480 --> 00:43:12,880
Takoj bom ven!

888
00:43:12,880 --> 00:43:14,550
>> -I Je vse bližje zdaj.

889
00:43:14,550 --> 00:43:16,620
Napetost je bilo grozno.

890
00:43:16,620 --> 00:43:17,720
Kaj je bilo?

891
00:43:17,720 --> 00:43:20,170
Usoda planeta
lahko visi na nitki.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy moram iti!

894
00:43:23,170 --> 00:43:26,890
>> Bom takoj ven, za zjokat!

895
00:43:26,890 --> 00:43:32,680
>> -Almost Tam, moji prsti letel, moj um
je jeklena past, vse pore vibrira.

896
00:43:32,680 --> 00:43:37,198
Bilo je jasno, ja, ja, ja.

897
00:43:37,198 --> 00:43:43,091
>> Bodi prepričan, da popij Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Crummy komercialno?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Kurbin sin.

903
00:43:54,227 --> 00:43:54,810
[END PREDVAJANJE]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Malan: OK, tako
da je to zelo daleč

905
00:43:57,390 --> 00:44:00,660
uvajanja kriptografijo,
in tudi Ovaltine.

906
00:44:00,660 --> 00:44:04,470
V bistvu, od tega starega oglasa
tukaj, zakaj je Ovaltine tako dobro?

907
00:44:04,470 --> 00:44:09,470
Je koncentrirana ekstrakcijo zrelih
ječmenov slad, Pure kremna kravjega mleka,

908
00:44:09,470 --> 00:44:14,360
in posebej pripravljen kakav, skupaj
z naravnimi fosfatidov in vitaminov.

909
00:44:14,360 --> 00:44:18,240
To je dodatno utrjeno z
dodatne vitamine B in D, yum.

910
00:44:18,240 --> 00:44:21,600
In še vedno lahko dobite, je očitno,
na Amazon, kot smo tukaj.

911
00:44:21,600 --> 00:44:24,810
>> Ampak motivacija tukaj je bil
uvede kriptografijo, natančneje

912
00:44:24,810 --> 00:44:28,340
tip šifriranja znan
kot tajni kriptografiji.

913
00:44:28,340 --> 00:44:34,284
In kot že ime pove, celotno
varnost tajnega ključa sistema šifrirnega,

914
00:44:34,284 --> 00:44:36,200
če hočete, metodologija
za samo kodiranja

915
00:44:36,200 --> 00:44:40,960
Podatki med dve osebi, je to
le pošiljatelj in edini prejemnik

916
00:44:40,960 --> 00:44:46,980
vedeti skrivnost key-- nekaj vrednosti, nekateri
skrivnost stavek, nekateri skrivnost številka, ki

917
00:44:46,980 --> 00:44:50,660
jim omogoča, da tako šifriranje
in dešifriranje podatkov.

918
00:44:50,660 --> 00:44:53,470
In kriptografija, res,
je le ta od 0 tedna.

919
00:44:53,470 --> 00:44:56,715
>> To je problem, kjer je vložkov,
kot dejanski sporočilo v angleščini

920
00:44:56,715 --> 00:44:59,340
ali katerem koli jeziku, ki vas
želite poslati nekoga v razredu,

921
00:44:59,340 --> 00:45:00,580
ali preko interneta.

922
00:45:00,580 --> 00:45:03,840
Obstaja nekaj izhod, ki se dogaja
da so kodirani sporočilo, ki vas

923
00:45:03,840 --> 00:45:05,250
želijo prejemnik prejemati.

924
00:45:05,250 --> 00:45:07,405
In tudi če je nekdo v
srednji prejme tudi

925
00:45:07,405 --> 00:45:09,780
jih ne želijo
nujno mogli dešifrirati,

926
00:45:09,780 --> 00:45:12,840
ker notranjosti tega
črna skrinjica, ali algoritem,

927
00:45:12,840 --> 00:45:17,650
nekateri mehanizem, nekateri korak za korakom
navodila, ki so pri tem, da je vhod

928
00:45:17,650 --> 00:45:20,710
in ga pretvorijo v
izhod, v upajmo na varen način.

929
00:45:20,710 --> 00:45:23,640
>> In, v resnici obstaja
besednjak na tem svetu, kot sledi.

930
00:45:23,640 --> 00:45:26,100
Navadno besedilo je beseda
računalniški znanstvenik bi

931
00:45:26,100 --> 00:45:28,449
opisale vhod
Sporočilo, kot angleški

932
00:45:28,449 --> 00:45:31,240
ali katerem koli jeziku vas dejansko
želite poslati na drug človek.

933
00:45:31,240 --> 00:45:35,450
In potem šifropisom je Izokrenuti
na šifrirane ali šifrirana,

934
00:45:35,450 --> 00:45:36,520
njegovo različico.

935
00:45:36,520 --> 00:45:38,750
>> Ampak tam je ena sestavina tukaj.

936
00:45:38,750 --> 00:45:43,200
Tam je ena prispevek k
skrivni ključ kriptografija.

937
00:45:43,200 --> 00:45:45,200
In da je ključ sam
ki je na splošno

938
00:45:45,200 --> 00:45:48,930
kot bomo videli, je več, ali
črko ali besedo, karkoli

939
00:45:48,930 --> 00:45:51,980
algoritem je dejansko pričakuje.

940
00:45:51,980 --> 00:45:53,870
>> In kako dešifrirati podatke?

941
00:45:53,870 --> 00:45:55,110
Kako ga Razmrsiti?

942
00:45:55,110 --> 00:45:57,950
No, si pola
izhodi in vhodi.

943
00:45:57,950 --> 00:46:00,900
>> Z drugimi besedami, ko nekomu
prejme šifrirano sporočilo,

944
00:46:00,900 --> 00:46:03,740
on ali ona je preprosto
vedeti, da isti ključ.

945
00:46:03,740 --> 00:46:05,700
So prejeli šifropisom.

946
00:46:05,700 --> 00:46:09,530
In s priklopom ti dve
vhodi v sistem šifrirnega,

947
00:46:09,530 --> 00:46:14,260
algoritem, to black box, od
mora priti prvotno čistim.

948
00:46:14,260 --> 00:46:17,830
In tako, da je visoka raven
pogled na to, kaj kriptografija je dejansko

949
00:46:17,830 --> 00:46:18,590
vse o.

950
00:46:18,590 --> 00:46:20,030
>> Torej, kaj je tja.

951
00:46:20,030 --> 00:46:22,700
Zdaj pa poglej pod
pokrov nečesa

952
00:46:22,700 --> 00:46:26,000
smo bili ob samoumevnega za
pretekli teden, in za to sejo

953
00:46:26,000 --> 00:46:27,629
here-- niz.

954
00:46:27,629 --> 00:46:30,295
Niz ob koncu dneva
je samo zaporedje znakov.

955
00:46:30,295 --> 00:46:33,610
>> Morda bi bilo zdravo svet, ali
zdravo Zamyla, ali karkoli.

956
00:46:33,610 --> 00:46:37,050
Kaj pa to pomeni, da
je zaporedje znakov?

957
00:46:37,050 --> 00:46:41,520
Dejstvo je, knjižnica CS50 daje
nam podatkovni tip se imenuje niz.

958
00:46:41,520 --> 00:46:45,140
>> Vendar pravzaprav ni
taka stvar kot niz v C.

959
00:46:45,140 --> 00:46:49,450
Res je samo zaporedje
znak, znak, znak,

960
00:46:49,450 --> 00:46:52,180
značaj, nazaj, nazaj, da
nazaj, nazaj, nazaj v notranjosti

961
00:46:52,180 --> 00:46:54,650
pomnilnika računalnika ali RAM.

962
00:46:54,650 --> 00:46:58,940
In bomo pogledati globlje, da je v
prihodnosti, če pogledamo samo spomin,

963
00:46:58,940 --> 00:47:02,030
in uporaba ter
grožnje, ki so udeležene.

964
00:47:02,030 --> 00:47:04,100
>> Ampak kaj menijo niz Zamyla.

965
00:47:04,100 --> 00:47:07,480
Torej samo ime
človek tukaj, Zamyla,

966
00:47:07,480 --> 00:47:12,030
da je zaporedje
znaki, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
In zdaj recimo, da je ime Zamyla je
se shranijo v notranjosti računalnika

968
00:47:16,020 --> 00:47:16,880
Program.

969
00:47:16,880 --> 00:47:20,830
>> No, je razumljivo, da bi morali
biti sposoben gledati teh znakov

970
00:47:20,830 --> 00:47:21,590
posamično.

971
00:47:21,590 --> 00:47:24,710
Tako da sem šele tekoč, da pripravi malo
polje okrog imena Zamyla je tukaj.

972
00:47:24,710 --> 00:47:31,580
In to velja za C, ko vas
imajo niz, kot Zamyla-- in morda

973
00:47:31,580 --> 00:47:34,940
da niz se je vrnil iz
funkcija kot get niz,

974
00:47:34,940 --> 00:47:38,540
lahko dejansko manipulira
je znak za znakom.

975
00:47:38,540 --> 00:47:42,070
>> Zdaj, to je germane za
pogovor na roki, ker

976
00:47:42,070 --> 00:47:46,420
V kriptografiji, če želite spremeniti
A B in B do C in C D,

977
00:47:46,420 --> 00:47:49,650
in tako naprej, morate biti sposobni
pogled na posameznih znakov

978
00:47:49,650 --> 00:47:50,190
V nizu.

979
00:47:50,190 --> 00:47:52,695
Morate biti sposobni spremeniti
Z nekaj drugega je A

980
00:47:52,695 --> 00:47:55,280
nekaj drugega je M za
nekaj drugega, in tako naprej.

981
00:47:55,280 --> 00:47:58,000
In zato moramo način,
programsko, zato

982
00:47:58,000 --> 00:48:03,020
rekoč v C, da se lahko spremenijo
in pogled na posameznih črk.

983
00:48:03,020 --> 00:48:05,690
In to lahko naredimo na naslednji način.

984
00:48:05,690 --> 00:48:08,340
>> Naj grem pa nazaj v CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
In mi gredo naprej
in ustvariti novo datoteko

986
00:48:11,130 --> 00:48:16,134
da bom poklical ta časovni string0,
kot je naš prvi tak primer, pika c.

987
00:48:16,134 --> 00:48:18,300
In bom, da gredo naprej
in bič, kot sledi.

988
00:48:18,300 --> 00:48:22,870
>> Torej vključujejo CS50.h, in
potem vsebuje standardne io.h,

989
00:48:22,870 --> 00:48:25,990
ki sem skoraj vedno dogaja, da
uporabljali v svojih programih, vsaj

990
00:48:25,990 --> 00:48:26,780
na začetku.

991
00:48:26,780 --> 00:48:32,180
int glavni praznino, in potem tukaj sem
naredili strune dobi dobili niz.

992
00:48:32,180 --> 00:48:35,260
In potem bom
gredo naprej in to.

993
00:48:35,260 --> 00:48:37,460
Rad bi šel naprej
in kot kontrola razumnosti,

994
00:48:37,460 --> 00:48:43,607
samo reči, zdravo, odstotek je,
podpičje, naredi niz 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, kaj sem naredil tukaj?

996
00:48:44,690 --> 00:48:45,930
Oh, nisem ga priključite.

997
00:48:45,930 --> 00:48:48,120
Torej izkušnja, ki
ni bilo namerno.

998
00:48:48,120 --> 00:48:52,480
>> Torej napaka, več odstotkov
pretvorbe od argumentov podatkov.

999
00:48:52,480 --> 00:48:54,940
In to je, če je v
linija 7-- OK, tako da imam,

1000
00:48:54,940 --> 00:48:56,690
quote citata, ki je
moj niz do printf.

1001
00:48:56,690 --> 00:48:58,151
Imam znak za odstotek.

1002
00:48:58,151 --> 00:48:59,650
Ampak mi manjka drugo trditev.

1003
00:48:59,650 --> 00:49:03,190
>> Mi manjka vejico s, ki
Sem imel v prejšnjih primerih.

1004
00:49:03,190 --> 00:49:06,650
Torej dobra priložnost, da se določi
še ena napaka, po naključju.

1005
00:49:06,650 --> 00:49:09,950
In zdaj mi teče
string0, tip v Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, zdravo Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Tako smo teči to vrsto programa
nekaj različnih časih zdaj.

1008
00:49:14,144 --> 00:49:16,310
Ampak kaj je naredil nekaj, kar
malo tokrat drugače.

1009
00:49:16,310 --> 00:49:19,450
Namesto samo tiskanje Zamyla je
Celoten naziv ven z printf,

1010
00:49:19,450 --> 00:49:21,350
naredimo to znak za znakom.

1011
00:49:21,350 --> 00:49:22,700
>> Bom uporabiti za zanke.

1012
00:49:22,700 --> 00:49:26,160
In bom dal sam
štetje spremenljivka, ki se imenuje i.

1013
00:49:26,160 --> 00:49:33,530
In bom, da ponavljanjem, tako
Dokler i manjša od dolžine s.

1014
00:49:33,530 --> 00:49:35,930
>> Izkazalo se je, nismo
storiti to zadnjič,

1015
00:49:35,930 --> 00:49:39,100
da c prihaja z
Funkcija se imenuje Stirling.

1016
00:49:39,100 --> 00:49:42,690
Nazaj v dan, in na splošno
Še vedno pri izvajanju nalog,

1017
00:49:42,690 --> 00:49:45,405
ljudje pogosto izberejo zelo
jedrnato imena te vrste zvoka

1018
00:49:45,405 --> 00:49:48,280
kot tisto, kar želite, čeprav je
manjka nekaj samoglasnike ali pisma.

1019
00:49:48,280 --> 00:49:50,660
Tako Stirling je
ime funkcije, ki

1020
00:49:50,660 --> 00:49:53,880
traja prepir med
oklepaje, da bi moral biti niz.

1021
00:49:53,880 --> 00:49:56,910
In to samo vrne celo število,
dolžina tega niza.

1022
00:49:56,910 --> 00:50:00,580
>> Torej, to zanko na liniji 7 se dogaja
da začnemo na i enak 0.

1023
00:50:00,580 --> 00:50:02,530
To se dogaja, da prirastek
i na vsaki ponovitvi

1024
00:50:02,530 --> 00:50:04,350
z 1, kot smo počeli nekajkrat.

1025
00:50:04,350 --> 00:50:06,780
Ampak to se dogaja, da samo, da
to do točke

1026
00:50:06,780 --> 00:50:09,660
kadar je i dolžina
samega niza.

1027
00:50:09,660 --> 00:50:14,520
>> Torej, to je način, na koncu,
ponavljanjem preko znake

1028
00:50:14,520 --> 00:50:17,430
v nizu, kot se pravi sledi.

1029
00:50:17,430 --> 00:50:20,670
Bom natisniti ni
cel niz, vendar odstotkov c

1030
00:50:20,670 --> 00:50:22,860
en sam znak
čemur sledi novo vrstico.

1031
00:50:22,860 --> 00:50:24,880
In potem bom
pojdi naprej, in moram

1032
00:50:24,880 --> 00:50:29,080
reči hočem natisniti
i-značaj s.

1033
00:50:29,080 --> 00:50:33,450
>> Torej, če i je spremenljivka, ki označuje
indeks vrvice, kjer

1034
00:50:33,450 --> 00:50:37,230
ste v njem, moram biti sposoben
reči, da mi i-značaj s.

1035
00:50:37,230 --> 00:50:40,390
In c je način dela
to z oglatimi oklepaji.

1036
00:50:40,390 --> 00:50:43,679
Vi preprosto izgovorite ime
niz, ki je v tem primeru pobrati.

1037
00:50:43,679 --> 00:50:46,970
Nato uporabite oglate oklepaje, ki so
ponavadi samo nad Return ali Enter

1038
00:50:46,970 --> 00:50:48,110
tipko na tipkovnici.

1039
00:50:48,110 --> 00:50:52,410
In potem si dal indeks
znak, ki ga želite natisniti.

1040
00:50:52,410 --> 00:50:55,960
Tako da je indeks dogaja, da se
number-- 0 ali 1 ali 2 ali 3, ali pika,

1041
00:50:55,960 --> 00:50:57,590
dot, dot, kakšno drugo številko.

1042
00:50:57,590 --> 00:51:00,920
>> In smo zagotovili, da se bo
je pravo število, ker I

1043
00:51:00,920 --> 00:51:02,360
začnemo na 0.

1044
00:51:02,360 --> 00:51:07,020
In privzeto, prvi znak
v nizu po dogovoru 0.

1045
00:51:07,020 --> 00:51:09,230
In drugi znak je nosilec 1.

1046
00:51:09,230 --> 00:51:11,120
In tretji znak je nosilec 2.

1047
00:51:11,120 --> 00:51:13,630
In ne želite iti preveč
daleč, vendar pa ne bo, ker smo

1048
00:51:13,630 --> 00:51:17,780
bo le prirastek i do njega
enako dolžino niza.

1049
00:51:17,780 --> 00:51:20,210
In na kateri točki,
to zanko se bo ustavil.

1050
00:51:20,210 --> 00:51:25,550
>> Zato naj gredo naprej in shranite to
Program in tek se niz 0.

1051
00:51:25,550 --> 00:51:28,400
Ampak sem zamočil.

1052
00:51:28,400 --> 00:51:35,390
Implicitno razglasitvi knjižnica funkcijo
Stirling z vrsto takšne in such-- zdaj,

1053
00:51:35,390 --> 00:51:36,430
to zveni znano.

1054
00:51:36,430 --> 00:51:37,440
Ampak to ni printf.

1055
00:51:37,440 --> 00:51:38,540
In to ni dobil niz.

1056
00:51:38,540 --> 00:51:40,480
>> Nisem zamočil v
na enak način tokrat.

1057
00:51:40,480 --> 00:51:45,100
Ampak obvestilo tukaj malo dol
poleg tega vključujejo glave string.h,

1058
00:51:45,100 --> 00:51:47,210
izrecno navedena
Izjava za Stirling.

1059
00:51:47,210 --> 00:51:48,820
Torej je dejansko namig tam.

1060
00:51:48,820 --> 00:51:51,670
>> In res se je izkazalo
tam je ena datoteka z glavo

1061
00:51:51,670 --> 00:51:53,970
da smo ne uporablja
v razredu še ni, vendar je

1062
00:51:53,970 --> 00:51:56,480
Med tistimi, ki so
za vas, ki se imenuje string.h.

1063
00:51:56,480 --> 00:52:00,930
In v tej datoteki, string.h
je Stirling razglašena.

1064
00:52:00,930 --> 00:52:05,220
Zato naj gredo naprej in
shranite to, da niz

1065
00:52:05,220 --> 00:52:08,040
0-- lepo, nobenih sporočil o napakah tokrat.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, in
Jaz sem na tem, da zadeti nastopiti,

1067
00:52:12,290 --> 00:52:16,710
na kateri točki getstring se dogaja
da se vrne niz, ga v s.

1068
00:52:16,710 --> 00:52:21,890
Potem je za zanke bo ponovitev
več znakov podjetja S je eden naenkrat,

1069
00:52:21,890 --> 00:52:28,420
in jih natisnete eno v vsako vrstico, saj
Sem imel, da poševnica nazaj n na koncu.

1070
00:52:28,420 --> 00:52:34,530
Tako sem lahko izpustijo, da poševnico
n, nato pa samo tiskanje Zamyla vse

1071
00:52:34,530 --> 00:52:37,460
v isti liniji,
učinkovito reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, ki ni tako uporabna.

1073
00:52:38,999 --> 00:52:40,540
Toda v tem primeru nisem storil.

1074
00:52:40,540 --> 00:52:43,610
Sem dejansko natisnejo
lik hkrati, eno na vrstico,

1075
00:52:43,610 --> 00:52:45,400
tako da smo dejansko videli učinek.

1076
00:52:45,400 --> 00:52:46,900
>> Vendar naj navedem eno stvar tukaj.

1077
00:52:46,900 --> 00:52:48,930
In se bomo vrnili k
to v prihodnjem tednu.

1078
00:52:48,930 --> 00:52:52,650
Izkaže se, da je to
koda je potencialno buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Izkazalo se je, da je dobil niz
in nekatere druge funkcije v življenju

1080
00:52:56,560 --> 00:53:00,280
ne nujno vedno
vrniti, kar ste pričakovali.

1081
00:53:00,280 --> 00:53:03,010
Vemo iz razreda zadnje
čas, v tem, da je dobil

1082
00:53:03,010 --> 00:53:04,960
Niz se naj bi vrnil niz.

1083
00:53:04,960 --> 00:53:09,900
Kaj pa, če uporabnik vnese takšno
dolgo besedo, ali odstavka, ali esej

1084
00:53:09,900 --> 00:53:13,010
da je samo ni dovolj
pomnilnika v računalniku, tako da bo.

1085
00:53:13,010 --> 00:53:15,410
>> Kot, kaj če gre kaj
Napačna pod pokrovom?

1086
00:53:15,410 --> 00:53:18,400
Morda ne zgodi pogosto,
vendar pa bi se lahko zgodilo, ko

1087
00:53:18,400 --> 00:53:21,520
v nekaj časa, zelo redko.

1088
00:53:21,520 --> 00:53:25,460
In tako se je izkazalo, da je dobil niz
in funkcije, kot so to storili, ne nujno

1089
00:53:25,460 --> 00:53:26,380
vedno vrne nize.

1090
00:53:26,380 --> 00:53:30,680
Morda vrne neko vrednost napake,
nekaj kontrolnih vrednost tako rekoč

1091
00:53:30,680 --> 00:53:32,612
ki nakazuje, da
kaj je šlo narobe.

1092
00:53:32,612 --> 00:53:35,320
In bi vedel samo to iz
ko ga je naučil v razredu zdaj,

1093
00:53:35,320 --> 00:53:37,700
ali so prebrali nekaj več dokumentacije.

1094
00:53:37,700 --> 00:53:43,120
Izkazalo se je, da je dobil niz
lahko vrne vrednost, imenovano null.

1095
00:53:43,120 --> 00:53:46,220
Null je posebna vrednota, ki jo bom
pridejo nazaj v prihodnjem tednu.

1096
00:53:46,220 --> 00:53:50,420
Ampak za zdaj, samo vem, da če želim
biti res pravilno pri napredovanju

1097
00:53:50,420 --> 00:53:52,650
uporabo get niz, sem
ne bi samo poklicati,

1098
00:53:52,650 --> 00:53:56,870
in slepo uporabi svoj vrne vrednost,
zaupamo, da je niz.

1099
00:53:56,870 --> 00:53:59,420
>> Naj najprej povem,
hej, počakaj malo, le

1100
00:53:59,420 --> 00:54:03,380
nadaljuje, kadar je ni enaka
null, kjer null, še enkrat,

1101
00:54:03,380 --> 00:54:04,660
je le nekaj posebno vrednost.

1102
00:54:04,660 --> 00:54:07,770
In to je edina posebno vrednost, ki jo
treba skrbeti za get niz.

1103
00:54:07,770 --> 00:54:10,900
Get niz je prenehalo,
da se vrnejo niz ali null.

1104
00:54:10,900 --> 00:54:17,219
>> In to klicaj enačaj
morda veste iz morda matematičnem razredu

1105
00:54:17,219 --> 00:54:20,510
ki jih lahko pripravi enačaj z
črto skozi to navesti ni enaka.

1106
00:54:20,510 --> 00:54:23,135
To običajno ni znak
lahko vnesete na tipkovnici.

1107
00:54:23,135 --> 00:54:26,480
In tako je v večini programskih jezikov,
če hočeš povedati ni enako,

1108
00:54:26,480 --> 00:54:29,160
uporabljate klicaj,
sicer znan kot pok.

1109
00:54:29,160 --> 00:54:33,180
Torej praviš bang enaka, kar
ne pomeni enako, logično.

1110
00:54:33,180 --> 00:54:38,060
To je tako kot da ni večje
kot ali enaka ali manjša od

1111
00:54:38,060 --> 00:54:41,270
ali enake tipke na tipkovnici
da ne vse v en simbol.

1112
00:54:41,270 --> 00:54:44,020
Torej, to je, zakaj je v zadnjih primerov,
si odprt nosilec, nato pa

1113
00:54:44,020 --> 00:54:48,670
enako znamenje, da se stori
večja ali, recimo, manj kot.

1114
00:54:48,670 --> 00:54:49,910
>> Torej, kaj je takeaway tukaj?

1115
00:54:49,910 --> 00:54:53,880
To je preprosto tako zdaj za
uvedbo te skladnje, ta funkcija,

1116
00:54:53,880 --> 00:54:57,390
ponavljanjem kot posameznik
znakov v nizu.

1117
00:54:57,390 --> 00:55:00,260
In tako kot tiste kvadrat
nosilci vam omogočajo, da se na njih,

1118
00:55:00,260 --> 00:55:03,790
upoštevati tistih oklepajev kot
nekako namiguje na to osnovno

1119
00:55:03,790 --> 00:55:06,040
Zasnova, pri čemer vsak
karakter znotraj niza

1120
00:55:06,040 --> 00:55:10,180
je vrsta boxed nekje pod
napa v spomin računalnika.

1121
00:55:10,180 --> 00:55:12,340
>> Ampak kaj je narediti različico tega.

1122
00:55:12,340 --> 00:55:14,880
Izkaže se, da je to
Program je pravilen.

1123
00:55:14,880 --> 00:55:18,810
Torej na osi CS50 za ocenjevanje
kodo, to je prav zdaj.

1124
00:55:18,810 --> 00:55:22,959
Še posebej zdaj, ko sem iskal
null, ta program ne bi bilo nesreče.

1125
00:55:22,959 --> 00:55:24,500
In sem vedel, da iz izkušenj.

1126
00:55:24,500 --> 00:55:28,040
Vendar pa ni nič drugega,
res lahko gre tukaj narobe.

1127
00:55:28,040 --> 00:55:31,860
Vendar to ni zelo dobro zasnovan,
ker gremo nazaj k osnovam.

1128
00:55:31,860 --> 00:55:34,450
>> Prvič, principles--
kaj za zanke storiti?

1129
00:55:34,450 --> 00:55:36,290
A za zanke pa tri stvari.

1130
00:55:36,290 --> 00:55:39,340
To inicializira nekaj
vrednost, če ga prosim, da.

1131
00:55:39,340 --> 00:55:41,770
Preveri stanje.

1132
00:55:41,770 --> 00:55:45,380
In potem po vsakem
ponovitev, po vsakem ciklu

1133
00:55:45,380 --> 00:55:49,330
da korakih nekaj
vrednost ali vrednosti, tukaj.

1134
00:55:49,330 --> 00:55:50,600
>> Torej, kaj naj bi to pomenilo?

1135
00:55:50,600 --> 00:55:52,940
Mi inicializacijo i na 0.

1136
00:55:52,940 --> 00:55:58,610
Mi preverite in se prepričajte, i je manj kot
dolžina s, kjer je Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
tako, ki je manjša od 6.

1138
00:55:59,900 --> 00:56:02,590
In, seveda, 0, kot je manj kot 6.

1139
00:56:02,590 --> 00:56:05,580
>> Tiskamo iz Z. iz imena Zamyla je.

1140
00:56:05,580 --> 00:56:08,080
Potem smo prirastek i od 0 do 1.

1141
00:56:08,080 --> 00:56:11,290
Nato smo preveriti, je 1 manj
od dolžine s?

1142
00:56:11,290 --> 00:56:13,270
Dolžina s 6.

1143
00:56:13,270 --> 00:56:13,950
Ja, res je.

1144
00:56:13,950 --> 00:56:16,880
>> Tako smo natisniti v imenu Zamyla je, ZA.

1145
00:56:16,880 --> 00:56:20,090
Smo prirastek i od 0 do 1 do 2.

1146
00:56:20,090 --> 00:56:23,720
Nato smo preveriti, je 2 manj kot
dolžina imena Zamyla je.

1147
00:56:23,720 --> 00:56:25,380
6- do 2, je manjša od 6.

1148
00:56:25,380 --> 00:56:30,460
Ja, kaj je natisnete zdaj M v
Zamyla ime, tretji znak.

1149
00:56:30,460 --> 00:56:34,110
>> Ključno je, da na vsaki
ponovitev zgodbe, sem preverjanje,

1150
00:56:34,110 --> 00:56:37,810
je i manjša od dolžine Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Ampak ulov je, da
Stirling ni lastnina.

1152
00:56:40,350 --> 00:56:43,100
Tisti, ki so programirani
prej v Java ali drugih jezikih

1153
00:56:43,100 --> 00:56:46,310
Morda veš, katerih dolžina je niz
lastnost, le nekaj samo za branje vrednosti.

1154
00:56:46,310 --> 00:56:50,220
>> V C v tem primeru, če je to
funkcija, ki je dobesedno

1155
00:56:50,220 --> 00:56:53,520
štetje števila
znaki v Zamyla vsakič

1156
00:56:53,520 --> 00:56:54,740
pravimo, da je funkcija.

1157
00:56:54,740 --> 00:56:58,500
Vsakič, ko zahteva od računalnika za uporabo
Stirling, to je ob pogled na Zamyla,

1158
00:56:58,500 --> 00:57:01,960
in pravijo, Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
In se vrne 6.

1160
00:57:02,962 --> 00:57:04,920
Naslednjič, ko vas pokliče
je notri, da je za zanke,

1161
00:57:04,920 --> 00:57:08,610
to se dogaja, poglej Zamyla
spet pravijo Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
In to se dogaja, da se vrnete 6.

1163
00:57:10,320 --> 00:57:12,980
Torej, kaj je neumen glede tega modela?

1164
00:57:12,980 --> 00:57:17,700
>> Zakaj je moja koda ni na 5 od 5
za načrtovanje zdaj, tako rekoč?

1165
00:57:17,700 --> 00:57:20,600
No, jaz sem prosi
vprašanje po nepotrebnem.

1166
00:57:20,600 --> 00:57:23,030
Delam več dela, kot moram.

1167
00:57:23,030 --> 00:57:25,370
>> Torej, čeprav
Odgovor je pravilen, sem

1168
00:57:25,370 --> 00:57:29,560
prosi računalnik, kaj je
dolžina Zamyla spet,

1169
00:57:29,560 --> 00:57:31,380
znova in znova in znova?

1170
00:57:31,380 --> 00:57:33,980
In ta odgovor je
nikoli ne bo spremenilo.

1171
00:57:33,980 --> 00:57:35,900
To je vedno bo 6.

1172
00:57:35,900 --> 00:57:39,730
>> Torej, boljša rešitev od tega
bo to naslednja različica.

1173
00:57:39,730 --> 00:57:43,390
Naj gredo naprej in prenesemo v
ločena datoteka z imenom string1.c,

1174
00:57:43,390 --> 00:57:44,990
samo, da se ločita.

1175
00:57:44,990 --> 00:57:47,260
In se izkaže, je z za
zanka, lahko dejansko

1176
00:57:47,260 --> 00:57:50,210
razglasi več spremenljivk hkrati.

1177
00:57:50,210 --> 00:57:53,460
>> Tako bom, da bo i in jo nastavite na 0.

1178
00:57:53,460 --> 00:57:56,190
Vendar sem tudi dogaja, da
dodamo vejico, in pravijo,

1179
00:57:56,190 --> 00:58:01,050
daj mi spremenljivko n, katerega
vrednost je enaka dolžini niza s.

1180
00:58:01,050 --> 00:58:09,410
In zdaj, prosim, da moje stanje
dokler i manj kot n.

1181
00:58:09,410 --> 00:58:14,140
>> Tako da na ta način, je logika
identična ob koncu dneva.

1182
00:58:14,140 --> 00:58:18,280
Vendar sem spominjajo
vrednost 6, v tem primeru.

1183
00:58:18,280 --> 00:58:19,780
Kakšna je dolžina imena Zamyla je?

1184
00:58:19,780 --> 00:58:20,860
In jo bom na n.

1185
00:58:20,860 --> 00:58:23,050
>> In sem še vedno preverjanje
pogoj vsakič.

1186
00:58:23,050 --> 00:58:24,300
0 manj kot 6?

1187
00:58:24,300 --> 00:58:25,600
1 manj kot 6?

1188
00:58:25,600 --> 00:58:28,600
Je 2 manj kot 6, in tako naprej?

1189
00:58:28,600 --> 00:58:31,914
>> Ampak jaz ne sprašuje računalnika
še enkrat in še enkrat, kaj je

1190
00:58:31,914 --> 00:58:33,080
dolžina imena Zamyla je?

1191
00:58:33,080 --> 00:58:34,320
Kakšna je dolžina imena Zamyla je?

1192
00:58:34,320 --> 00:58:35,986
Kakšna je dolžina imena tega Zamyla je?

1193
00:58:35,986 --> 00:58:40,440
Sem dobesedno spomniti, da je prva in
Samo odgovoriti na tem drugem spremenljivo n.

1194
00:58:40,440 --> 00:58:45,280
Torej, to zdaj ne bi bila le
pravilna, ampak tudi dobro zasnovan.

1195
00:58:45,280 --> 00:58:46,670
>> Zdaj, kaj je stil?

1196
00:58:46,670 --> 00:58:48,866
Sem poimenoval moje spremenljivke
zelo dobro, bi rekel.

1197
00:58:48,866 --> 00:58:50,240
Oni so super jedrnato zdaj.

1198
00:58:50,240 --> 00:58:52,090
In to je povsem v redu.

1199
00:58:52,090 --> 00:58:55,120
>> Če imate le eno
niz v programu

1200
00:58:55,120 --> 00:58:56,860
si lahko tudi imenujemo to je to za niz.

1201
00:58:56,860 --> 00:58:59,370
Če imate le eno spremenljivko
za štetje v programu,

1202
00:58:59,370 --> 00:59:00,710
si lahko tudi to imenujemo i.

1203
00:59:00,710 --> 00:59:03,500
Če imate dolžino, n
je zelo pogosta, kot dobro.

1204
00:59:03,500 --> 00:59:05,800
Ampak nisem komentiral katerokoli moje kode.

1205
00:59:05,800 --> 00:59:09,200
>> Nisem obvestila reader--
ali da je moj TF, ali TA,

1206
00:59:09,200 --> 00:59:12,460
ali pa samo colleague-- kaj naj
ki se dogaja v tem programu.

1207
00:59:12,460 --> 00:59:15,760
In zato, da bi dobili dober slog,
kaj bi želeli delati

1208
00:59:15,760 --> 00:59:24,580
je this-- nekaj
kot vprašati uporabnika za vnos.

1209
00:59:24,580 --> 00:59:26,670
In sem lahko znova
To poljubno število načinov.

1210
00:59:26,670 --> 00:59:35,630
>> Poskrbite, S- prepričajte get
Niz je vrnil niz.

1211
00:59:35,630 --> 00:59:40,280
In potem v here-- in to je morda
najpomembnejši comment-- ponovitev

1212
00:59:40,280 --> 00:59:44,450
več znakov v ih eno naenkrat.

1213
00:59:44,450 --> 00:59:47,060
In sem lahko uporabite katero koli
Izbira angleškem jeziku

1214
00:59:47,060 --> 00:59:49,650
tukaj opisati vsako
teh koščkih kode.

1215
00:59:49,650 --> 00:59:52,740
>> Obvestilo, da nisem dal
pripombe na vsako vrstico kode,

1216
00:59:52,740 --> 00:59:55,690
res samo na zanimiv
tisti, tisti, ki

1217
00:59:55,690 --> 00:59:59,460
imajo nek smisel, da sem morda
želite super jasno, da nekdo

1218
00:59:59,460 --> 01:00:00,460
branje svojo kodo.

1219
01:00:00,460 --> 01:00:02,920
In zakaj kličeš dobili
Niz vprašati uporabnika za vnos?

1220
01:00:02,920 --> 01:00:05,450
Tudi to ena ni nujno
vse to opisna.

1221
01:00:05,450 --> 01:00:09,340
Ampak to pomaga povedati zgodbo, saj je
Druga vrstica v zgodbi je, se prepričajte,

1222
01:00:09,340 --> 01:00:10,740
dobili niz vrnil niz.

1223
01:00:10,740 --> 01:00:14,260
>> In tretja vrstica v zgodbi je,
Ponovil več znakov v e eno

1224
01:00:14,260 --> 01:00:15,380
ob času.

1225
01:00:15,380 --> 01:00:17,920
In zdaj samo za dober ukrep,
Bom, da gredo naprej in dodamo

1226
01:00:17,920 --> 01:00:24,560
še en komentar, da je le
pravi print i-ti znak v s.

1227
01:00:24,560 --> 01:00:26,520
Zdaj, kaj sem naredil
Na koncu dneva?

1228
01:00:26,520 --> 01:00:29,190
>> sem dodal nekaj angleški
besede v obliki pripomb.

1229
01:00:29,190 --> 01:00:32,700
Simbol slash slash pomeni, hej,
Računalnik je to za človeka,

1230
01:00:32,700 --> 01:00:33,820
ni za vas, računalnik.

1231
01:00:33,820 --> 01:00:35,119
Torej oni logično prezreti.

1232
01:00:35,119 --> 01:00:35,910
Oni so samo tam.

1233
01:00:35,910 --> 01:00:39,830
>> In, seveda, CS50 IDE jih prikazuje kot
siva, kot koristno, vendar ne ključ

1234
01:00:39,830 --> 01:00:41,000
s programom.

1235
01:00:41,000 --> 01:00:42,570
Obvestilo, kaj lahko sedaj storite.

1236
01:00:42,570 --> 01:00:44,950
Ali ste vedeli, C
programiranje ali ne,

1237
01:00:44,950 --> 01:00:47,722
lahko samo stati nazaj na to
programa, in posneto pripombe.

1238
01:00:47,722 --> 01:00:50,180
Vprašaj uporabnika za vnos, se prepričajte,
dobili niz vrnil niz,

1239
01:00:50,180 --> 01:00:53,009
Ponovil nad znakov s
enega po enega, tiskanje značaja

1240
01:00:53,009 --> 01:00:55,550
i-ti znak v S- jih ne
celo gledati kodo

1241
01:00:55,550 --> 01:00:57,270
razumeti, kaj ta program počne.

1242
01:00:57,270 --> 01:01:00,280
In, še bolje, če si videti
v tem programu v tednu ali dveh,

1243
01:01:00,280 --> 01:01:02,280
ali mesec ali leto,
tudi vi nimate

1244
01:01:02,280 --> 01:01:04,420
strmeti na kodo,
poskuša spomniti,

1245
01:01:04,420 --> 01:01:06,630
kaj sem poskušal narediti s to kodo?

1246
01:01:06,630 --> 01:01:07,770
>> Vi ste povedali sami.

1247
01:01:07,770 --> 01:01:11,660
Ste ga opisali sami,
ali kakšen kolega, ali TA, ali TF.

1248
01:01:11,660 --> 01:01:14,860
In tako bi to zdaj
pravilen in dober design,

1249
01:01:14,860 --> 01:01:18,210
in na koncu dober slog, kot dobro.

1250
01:01:18,210 --> 01:01:19,990
Torej, ali da se vodijo v mislih.

1251
01:01:19,990 --> 01:01:22,200
>> Tako da je ena
stvar, bom na tem mestu

1252
01:01:22,200 --> 01:01:28,240
da lahko zdaj pokažejo, kaj je
dogaja pod pokrovom.

1253
01:01:28,240 --> 01:01:30,390
Torej je ta funkcija
v C, in drugih jezikih,

1254
01:01:30,390 --> 01:01:33,010
imenuje Typecasting
da implicitno

1255
01:01:33,010 --> 01:01:37,250
ali eksplicitno vam omogoča pretvorbo
iz ene vrste podatkov v drugo.

1256
01:01:37,250 --> 01:01:39,800
Smo bili, ki se ukvarjajo tako
če danes s strunami.

1257
01:01:39,800 --> 01:01:41,250
>> In so nizi znakov.

1258
01:01:41,250 --> 01:01:44,910
Toda spomnite iz tedna
0, kakšni so znaki?

1259
01:01:44,910 --> 01:01:49,334
Znaki so samo abstrakcija
na vrhu numbers-- decimalnih števil,

1260
01:01:49,334 --> 01:01:52,500
in decimalna številke so res samo
abstrakcija na vrhu binarnih števil,

1261
01:01:52,500 --> 01:01:53,720
kot smo ga opredeljuje.

1262
01:01:53,720 --> 01:01:55,540
>> Torej znaki so številke.

1263
01:01:55,540 --> 01:01:58,410
In številke so znaki,
Samo odvisno od konteksta.

1264
01:01:58,410 --> 01:02:01,250
In se izkaže, da je v notranjosti
računalniškega programa,

1265
01:02:01,250 --> 01:02:06,830
lahko določite, kako želite videti
na bitov znotraj tega programa?

1266
01:02:06,830 --> 01:02:10,400
>> Spomnimo od 0 tednu, ki smo ga imeli
Ascii, ki je le ta oznaka

1267
01:02:10,400 --> 01:02:11,620
kartiranje pisma številke.

1268
01:02:11,620 --> 01:02:13,660
In smo rekli, kapital A je 65.

1269
01:02:13,660 --> 01:02:15,860
Kapitalsko B je 66, in tako naprej.

1270
01:02:15,860 --> 01:02:20,500
>> In obvestilo, smo v bistvu imeli znakov na
V prvi vrstici tukaj, saj bi C jim pravimo,

1271
01:02:20,500 --> 01:02:23,400
znakov, in nato
Ints na drugi vrsti.

1272
01:02:23,400 --> 01:02:28,180
In se izkaže, lahko pretvorite
neopazno med njima, običajno.

1273
01:02:28,180 --> 01:02:30,042
In če želimo narediti
to namerno, smo

1274
01:02:30,042 --> 01:02:31,750
morda želeli obravnavati
nekaj podobnega.

1275
01:02:31,750 --> 01:02:33,590
>> Mi morda želeli spremeniti
Zgornji primer nižje

1276
01:02:33,590 --> 01:02:35,330
primer, ali male črke v velike.

1277
01:02:35,330 --> 01:02:38,000
In se izkaže, tam je
pravzaprav vzorec tukaj

1278
01:02:38,000 --> 01:02:39,900
moremo sprejeti vsak trenutek.

1279
01:02:39,900 --> 01:02:44,120
Toda poglejmo najprej na
Primer za to izrecno.

1280
01:02:44,120 --> 01:02:46,340
>> Bom šel nazaj v CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Bom ustvariti
datoteka z imenom ASCII 0.c.

1282
01:02:50,640 --> 01:02:55,960
In bom, da gredo naprej in dodamo moj
Standard io.h na vrhu, int main nična

1283
01:02:55,960 --> 01:02:57,370
Na vrhu mojega delovanja.

1284
01:02:57,370 --> 01:03:02,700
In potem sem šele tekoč, da storijo
following-- za zanke iz i je enak,

1285
01:03:02,700 --> 01:03:04,610
recimo, 65.

1286
01:03:04,610 --> 01:03:10,460
>> In potem sem se bo manj kot
65, plus 26 črk v abecedi.

1287
01:03:10,460 --> 01:03:12,640
Torej bom pustil računalnik
math me tam.

1288
01:03:12,640 --> 01:03:15,100
In potem znotraj tega zanke,
kaj bom za tiskanje?

1289
01:03:15,100 --> 01:03:19,230
>> % C% i poševnice nazaj n.

1290
01:03:19,230 --> 01:03:21,290
In zdaj bi rad, da bi zapolnili v dveh vrednosti.

1291
01:03:21,290 --> 01:03:24,530
Sem začasno postaviti vprašanje
označuje pa povabiti na vprašanje.

1292
01:03:24,530 --> 01:03:29,940
>> Želim Ponovil od 65 dalje
za 26 črk abecede,

1293
01:03:29,940 --> 01:03:35,190
tiskanje na vsaki ponovitvi, ki
lik integral enakovredni.

1294
01:03:35,190 --> 01:03:38,299
Z drugimi besedami, želim
Ponovil več kot 26 številk tiskanje

1295
01:03:38,299 --> 01:03:41,590
kaj je ASCII znak je črka,
in kaj ustreznega števila is--

1296
01:03:41,590 --> 01:03:44,650
res samo vnovično
grafikon iz tega diapozitiva.

1297
01:03:44,650 --> 01:03:47,010
Torej, kaj naj ti vprašaji biti?

1298
01:03:47,010 --> 01:03:51,760
>> No, se izkaže, da drugi
eden bi smela biti zgolj spremenljivka i.

1299
01:03:51,760 --> 01:03:53,860
Rad bi videl, da je kot številka.

1300
01:03:53,860 --> 01:03:58,920
In srednji argument
tukaj, lahko povem računalnik

1301
01:03:58,920 --> 01:04:03,470
za zdravljenje te celo
i kot znak, da se

1302
01:04:03,470 --> 01:04:05,880
jo nadomestiti tukaj odstotkov C.

1303
01:04:05,880 --> 01:04:07,990
>> Z drugimi besedami, če je
človeški programer, veš

1304
01:04:07,990 --> 01:04:09,865
to so le številke
Na koncu dneva.

1305
01:04:09,865 --> 01:04:12,500
In vem, da 65 naj
karto do neke značaja.

1306
01:04:12,500 --> 01:04:15,310
S tem eksplicitno cast,
z oklepaju,

1307
01:04:15,310 --> 01:04:18,840
ime podatkovnega tipa, ki ga želite
pretvoriti, in zaprt oklepaj,

1308
01:04:18,840 --> 01:04:21,200
lahko povedal
računalnik, hej, računalnik,

1309
01:04:21,200 --> 01:04:24,130
pretvoriti to celo v char.

1310
01:04:24,130 --> 01:04:26,250
>> Torej, ko sem to v
Program po zbiranju,

1311
01:04:26,250 --> 01:04:29,740
da vidimo, kaj sem get-- da ASCII 0.

1312
01:04:29,740 --> 01:04:33,020
Darn to, kaj sem naredil narobe?

1313
01:04:33,020 --> 01:04:35,884
Uporabite črno identifikatorja,
Vse je v redu, ne namerno,

1314
01:04:35,884 --> 01:04:37,800
ampak da vidimo, če ne moremo
Razlog skozi to.

1315
01:04:37,800 --> 01:04:41,220
>> Torej linija five-- tako da nisem dobil
zelo daleč pred vijačenje gor.

1316
01:04:41,220 --> 01:04:42,140
V redu je.

1317
01:04:42,140 --> 01:04:46,560
Torej enaka linija 5 za i 65-- vidim.

1318
01:04:46,560 --> 01:04:50,130
Torej, ne pozabite, da je v C, za razliko od nekaterih
jeziki, če imajo predhodno načrtovanje

1319
01:04:50,130 --> 01:04:52,190
izkušnje, ki jih imajo
povedati računalnik,

1320
01:04:52,190 --> 01:04:55,040
za razliko od nič, kar
tip spremenljivke je.

1321
01:04:55,040 --> 01:04:56,860
>> In sem pozabil ključni stavek tukaj.

1322
01:04:56,860 --> 01:04:59,200
V skladu pet, sem začel uporabljati i.

1323
01:04:59,200 --> 01:05:01,560
Ampak nisem povedal C
kateri podatki tip je.

1324
01:05:01,560 --> 01:05:04,570
Torej bom šel noter in
pravijo, ah, da je celo število.

1325
01:05:04,570 --> 01:05:07,050
>> Zdaj bom šel naprej in prevedem.

1326
01:05:07,050 --> 01:05:08,080
Ki je določena, da.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, da je nekako kul.

1328
01:05:12,660 --> 01:05:15,360
Ne samo, da je to super hitro
zaprosi računalnik to vprašanje,

1329
01:05:15,360 --> 01:05:18,885
namesto da bi gledal na stekelce
se natisne eno na vrstico, A 65,

1330
01:05:18,885 --> 01:05:24,860
B je 66, vse tja down-- od I
Ta 26 times-- naredil črkami z,

1331
01:05:24,860 --> 01:05:25,630
kar je 90.

1332
01:05:25,630 --> 01:05:27,790
In dejansko rahlo
bolj inteligentni bi

1333
01:05:27,790 --> 01:05:31,030
so bili za mene ne zanašajo
na računalniku dodati 26.

1334
01:05:31,030 --> 01:05:34,060
Lahko bi preprosto naredili
90 kot tudi, tako dolgo

1335
01:05:34,060 --> 01:05:37,390
saj jaz ne bi iste napake dvakrat.

1336
01:05:37,390 --> 01:05:41,880
Rad bi šel skozi
z, ne samo skozi y.

1337
01:05:41,880 --> 01:05:44,000
>> Torej, to je izrecno cast.

1338
01:05:44,000 --> 01:05:47,860
Izkaže se, da je to
sploh ni potrebna.

1339
01:05:47,860 --> 01:05:52,480
Naj gredo naprej in ponovite to
prevajalnik, in ponovitev ASCII 0.

1340
01:05:52,480 --> 01:05:54,940
Izkazalo se je, da je C zelo pameten.

1341
01:05:54,940 --> 01:05:57,150
>> In printf, zlasti
je zelo pameten.

1342
01:05:57,150 --> 01:06:01,260
Če ste pravkar opraviti i dvakrat
tako za ogradami, printf

1343
01:06:01,260 --> 01:06:04,510
bodo spoznali, oh, tudi jaz poznam
dal mi integer-- določeno število,

1344
01:06:04,510 --> 01:06:06,380
kot 65, ali 90, ali karkoli.

1345
01:06:06,380 --> 01:06:10,170
Ampak vidim, da si me želiš
format to število, kot znak.

1346
01:06:10,170 --> 01:06:16,460
In tako printf lahko implicitno odda
int v char za vas, kot tudi.

1347
01:06:16,460 --> 01:06:19,360
Tako, da to ni problem sploh.

1348
01:06:19,360 --> 01:06:23,100
>> Ampak obvestilo, ker te enakovrednosti
lahko dejansko to storite tudi.

1349
01:06:23,100 --> 01:06:26,520
Naj gredo naprej in narediti eno
druga različica this-- Ascii 1.C.

1350
01:06:26,520 --> 01:06:31,800
In namesto ponavljanjem preko
cela števila, lahko res blow your mind

1351
01:06:31,800 --> 01:06:33,610
s ponavljanjem več znakov.

1352
01:06:33,610 --> 01:06:37,660
Če char c dobi kapitala A, I
želijo, da gredo naprej in to,

1353
01:06:37,660 --> 01:06:41,740
dokler C manjše ali enako
kapitalske Z. In na vsaki ponovitvi

1354
01:06:41,740 --> 01:06:45,690
Rad bi prirastek C, sem lahko
zdaj v moji printf skladu tukaj

1355
01:06:45,690 --> 01:06:51,320
recimo odstotkov C
odstotkov i spet vejica C.

1356
01:06:51,320 --> 01:06:57,200
>> In zdaj lahko grem v drugo smer,
litje značaj izrecno

1357
01:06:57,200 --> 01:06:58,500
k celo število.

1358
01:06:58,500 --> 01:07:00,560
Torej, še enkrat, zakaj bi to naredili?

1359
01:07:00,560 --> 01:07:03,830
To je malo čudno, da nekako
računajo glede znakov.

1360
01:07:03,830 --> 01:07:07,430
>> Ampak, če boste razumeli, kaj je
dogaja pod pokrovom,

1361
01:07:07,430 --> 01:07:08,430
pa je res ni magija.

1362
01:07:08,430 --> 01:07:13,060
Ti si samo rekel, hej, računalnik daje
mi spremenljivka imenovan C tipa char.

1363
01:07:13,060 --> 01:07:16,520
inicializacijo kapitalske A. In
Opazili enojnih narekovajih zadevo.

1364
01:07:16,520 --> 01:07:19,580
>> Za znakov v C, prikličite iz
prejšnji teden, uporabite enojne narekovaje.

1365
01:07:19,580 --> 01:07:23,720
Za godala, besede,
fraze, uporabite dvojne narekovaje.

1366
01:07:23,720 --> 01:07:27,210
OK, računalnik, vedno tem, da
Dokler znak manj kot

1367
01:07:27,210 --> 01:07:28,050
ali enako z.

1368
01:07:28,050 --> 01:07:32,640
In vem iz mojega Ascii tabele, da so vsi
te kode ASCII so stikata.

1369
01:07:32,640 --> 01:07:33,400
>> Tukaj ni vrzeli.

1370
01:07:33,400 --> 01:07:36,737
Torej, to je samo od A do Ž,
ločeni z eno številko vsakega.

1371
01:07:36,737 --> 01:07:38,820
In potem sem lahko prirastek
char, če res želim.

1372
01:07:38,820 --> 01:07:40,390
Na koncu dneva,
to je samo številka.

1373
01:07:40,390 --> 01:07:41,030
To vem.

1374
01:07:41,030 --> 01:07:43,670
Tako da sem lahko samo predvidevam, da dodate 1 do nje.

1375
01:07:43,670 --> 01:07:46,940
>> In potem je to čas, tiskam c,
in nato integral enakovredni.

1376
01:07:46,940 --> 01:07:50,170
In sploh ne potrebujete izrecno zasedbo.

1377
01:07:50,170 --> 01:07:52,680
Lahko pustite printf in
Računalnik ugotoviti nekatere stvari,

1378
01:07:52,680 --> 01:07:57,300
tako da zdaj, če sem teči
da Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Dobim točno isto stvar kot dobro.

1380
01:08:01,520 --> 01:08:04,530
>> Neuporaben program though-- nihče
se dogaja, da dejansko napisati programsko opremo

1381
01:08:04,530 --> 01:08:07,549
da ugotovimo, kaj je bilo
številka, ki se preslika v A ali B, ali Z?

1382
01:08:07,549 --> 01:08:10,340
Ste šele tekoč, da ga Google, ali
poglej na spletu, ali da si jo gor

1383
01:08:10,340 --> 01:08:11,650
na stekelce ali podobno.

1384
01:08:11,650 --> 01:08:13,520
Torej, če to dejansko dobili koristno?

1385
01:08:13,520 --> 01:08:15,960
>> No, ko govorimo o da
slide, opazili, da je

1386
01:08:15,960 --> 01:08:20,890
dejanski vzorec tukaj med velikimi
in male črke, ki ni bila naključna.

1387
01:08:20,890 --> 01:08:23,760
Opazimo, da kapital A je 65.

1388
01:08:23,760 --> 01:08:25,830
Male črke a = 97.

1389
01:08:25,830 --> 01:08:29,649
In kako daleč je nižja primer primeren?

1390
01:08:29,649 --> 01:08:32,649
>> Torej, 65 je, koliko korakov od 97?

1391
01:08:32,649 --> 01:08:36,210
Torej 97 minus 65 je 32.

1392
01:08:36,210 --> 01:08:37,910
Torej kapital je a 65.

1393
01:08:37,910 --> 01:08:39,939
Če dodate 32 na to,
dobiš male črke a.

1394
01:08:39,939 --> 01:08:43,729
In enakovredno, če odštejemo 32,
dobiš nazaj kapitala A-- isto s B

1395
01:08:43,729 --> 01:08:46,380
za malo b, big C do malo c.

1396
01:08:46,380 --> 01:08:50,670
>> Vse te vrzeli so 32 narazen.

1397
01:08:50,670 --> 01:08:54,450
Zdaj, bi to se zdi, da nam omogočajo, da
narediti nekaj podobnega Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
ali Google Docs funkcija, kjer vas
lahko izberete vse in nato reči,

1399
01:08:57,729 --> 01:09:00,520
spremeniti vse v male črke, ali
spremeniti vse na velike črke,

1400
01:09:00,520 --> 01:09:03,840
ali spremeniti le prvo besedo
iz stavka v zgornjem primeru.

1401
01:09:03,840 --> 01:09:07,390
Mi lahko dejansko nekaj storiti
kot da sami.

1402
01:09:07,390 --> 01:09:12,645
>> Naj gredo naprej in shranite datoteko
tukaj se imenuje izkoristiti 0.c.

1403
01:09:12,645 --> 01:09:15,770
In gremo naprej in bič gor program
da ne točno, da je, kot sledi.

1404
01:09:15,770 --> 01:09:18,460
Tako vključuje knjižnico CS50.

1405
01:09:18,460 --> 01:09:21,430
In vsebuje standardne I / O.

1406
01:09:21,430 --> 01:09:22,787
>> In vem, da bo kmalu.

1407
01:09:22,787 --> 01:09:24,870
Tako bom, da ga v
že tam, string.h,

1408
01:09:24,870 --> 01:09:26,960
tako da imajo dostop do
stvari, kot so Stirling,

1409
01:09:26,960 --> 01:09:29,620
in nato int glavni praznino, kot ponavadi.

1410
01:09:29,620 --> 01:09:33,420
In potem bom šel naprej
in ne nize dobi dobili niz,

1411
01:09:33,420 --> 01:09:35,032
samo da bi dobili niz s strani uporabnika.

1412
01:09:35,032 --> 01:09:36,740
In potem bom
opravljam svoje preverjanje razumnosti.

1413
01:09:36,740 --> 01:09:40,510
Če niz ni enak null,
potem je varno nadaljevati.

1414
01:09:40,510 --> 01:09:42,000
In kaj bi rad naredil?

1415
01:09:42,000 --> 01:09:48,700
Bom Ponovil je i enak 0,
in n do dolžine niza na s.

1416
01:09:48,700 --> 01:09:51,899
>> In bom, da to storijo, dokler
i je manj kot n in i plus plus.

1417
01:09:51,899 --> 01:09:55,060
Do sedaj sem res samo
zadolževanje ideje od prej.

1418
01:09:55,060 --> 01:09:57,010
In zdaj bom uvesti vejo.

1419
01:09:57,010 --> 01:09:59,635
>> Torej, mislim nazaj na nič, kjer
smo imeli te vilice v cestnem prometu,

1420
01:09:59,635 --> 01:10:05,110
in prejšnji teden v C. vam bom
pravim, če i-znakov vs

1421
01:10:05,110 --> 01:10:09,250
je večje ali
enako male črke a,

1422
01:10:09,250 --> 01:10:13,340
in-- v Scratch bi jih dobesedno
pravijo, in vendar v C rečeš ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- in i-ti znak vs
je manjša ali enaka znižati primeru Z,

1424
01:10:19,830 --> 01:10:21,780
naredimo nekaj zanimivega.

1425
01:10:21,780 --> 01:10:27,020
Poglejmo dejansko natisnete ven
znakov brez nove vrstice

1426
01:10:27,020 --> 01:10:31,760
da je znak v nizu,
i-ti znak v nizu.

1427
01:10:31,760 --> 01:10:37,420
>> Ampak gremo naprej in
odštejemo 32 od njega.

1428
01:10:37,420 --> 01:10:42,120
Else, če je znak v
Niz, ki ga iščemo

1429
01:10:42,120 --> 01:10:45,950
ni med malo a
in malo z, gremo naprej

1430
01:10:45,950 --> 01:10:48,610
in šele natisne nespremenjena.

1431
01:10:48,610 --> 01:10:50,840
Tako smo uvedli
to oklepajih zapis

1432
01:10:50,840 --> 01:10:53,560
za naše strune, da bi dobili na
i-znak v nizu.

1433
01:10:53,560 --> 01:10:57,520
>> Sem dodal nekaj pogojno logiko, kot
Praske na prejšnji teden teden enega, kjer

1434
01:10:57,520 --> 01:10:59,880
Jaz sem samo s pomočjo moje temeljno
razumevanje tega, kaj je

1435
01:10:59,880 --> 01:11:01,130
dogaja pod pokrovom.

1436
01:11:01,130 --> 01:11:04,190
Je i-ti značaj s
večja ali enaka k?

1437
01:11:04,190 --> 01:11:08,290
Kot je bilo 97 ali 98,
ali 99, in tako naprej?

1438
01:11:08,290 --> 01:11:11,940
>> Vendar pa je tudi manjša ali enaka
vrednosti malimi zv?

1439
01:11:11,940 --> 01:11:16,210
In če je tako, kaj pomeni ta vrstica?

1440
01:11:16,210 --> 01:11:20,250
14, to je nekako od
kalčki celotne ideje,

1441
01:11:20,250 --> 01:11:23,840
začetnico pismo
preprosto odšteje 32 iz njega,

1442
01:11:23,840 --> 01:11:29,370
v tem primeru, ker vem, na da
grafikon, kako so zastopani moje številke.

1443
01:11:29,370 --> 01:11:33,925
Torej, gremo naprej in vodijo to,
Po zbiranju izkoristiti 0.c,

1444
01:11:33,925 --> 01:11:36,210
in tek izkoristiti 0.

1445
01:11:36,210 --> 01:11:40,300
>> Naj je tip v nekaj podobnega
Zamyla v vseh male enter.

1446
01:11:40,300 --> 01:11:42,780
In zdaj imamo Zamyla v vseh velikimi črkami.

1447
01:11:42,780 --> 01:11:45,050
Kaj je tip v Robu v vseh malimi črkami.

1448
01:11:45,050 --> 01:11:46,674
Poskusimo Jasona v vseh malimi črkami.

1449
01:11:46,674 --> 01:11:48,590
In smo dobili
prisilno kapitalizacije.

1450
01:11:48,590 --> 01:11:50,960
Tam je majhen hrošč, ki sem
nekako ni predvidel.

1451
01:11:50,960 --> 01:11:54,050
Obvestilo moj novi hitro se konča
na isti liniji kot njihova imena,

1452
01:11:54,050 --> 01:11:55,520
ki se počuti malo grdo.

1453
01:11:55,520 --> 01:11:59,170
>> Tako da sem šel tu, in
dejansko na koncu tega programa

1454
01:11:59,170 --> 01:12:02,110
izpisal znak za novo vrstico.

1455
01:12:02,110 --> 01:12:03,160
To je vse.

1456
01:12:03,160 --> 01:12:06,120
Z printf, ki jih ne potrebujete
prenese v spremenljivk ali formatu kodo.

1457
01:12:06,120 --> 01:12:08,460
Lahko dobesedno samo tiskanje
nekaj podobnega nove vrstice.

1458
01:12:08,460 --> 01:12:13,529
>> Torej, gremo naprej in da
izkoristiti 0 znova, ga ponovite, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
In zdaj je malo lepši.

1460
01:12:14,820 --> 01:12:17,274
Zdaj, moj poziv je na svojo novo linijo.

1461
01:12:17,274 --> 01:12:18,440
Tako, da je vse v redu in prav.

1462
01:12:18,440 --> 01:12:19,910
Torej, to je dober primer.

1463
01:12:19,910 --> 01:12:22,700
Ampak jaz ne celo nujno
morali trdo kodo 32.

1464
01:12:22,700 --> 01:12:23,350
Veš kaj?

1465
01:12:23,350 --> 01:12:26,350
Lahko bi say-- ne vem kdaj
se spomnite, kakšna je razlika.

1466
01:12:26,350 --> 01:12:29,330
>> Ampak vem, da če bom
imajo malo črko,

1467
01:12:29,330 --> 01:12:34,430
Sem v bistvu želijo odšteti off
kar je razdalja med malo

1468
01:12:34,430 --> 01:12:39,160
A in velik A, ker če predpostavimo, da
vsi drugi pisem sta enaka,

1469
01:12:39,160 --> 01:12:41,045
da naj bi dobili delo opravljeno.

1470
01:12:41,045 --> 01:12:42,670
Toda namesto da bi to naredil, veš kaj?

1471
01:12:42,670 --> 01:12:44,240
Obstaja še en način še vedno.

1472
01:12:44,240 --> 01:12:48,090
>> Če to je izkoriščanja 1.c--, če bi bil
naj da v ločeno datoteko.

1473
01:12:48,090 --> 01:12:51,030
Naredimo izkoristiti 2.c, kot sledi.

1474
01:12:51,030 --> 01:12:53,060
Bom res čist ta tukaj.

1475
01:12:53,060 --> 01:12:57,420
In namesto da bi morali
vedeti, ali skrbi tistih nizki ravni

1476
01:12:57,420 --> 01:13:01,090
Podrobnosti o izvajanju, sem namesto
le, da bo tiskanje znak,

1477
01:13:01,090 --> 01:13:04,610
quote citata, odstotka C, in
potem klic drugo funkcijo, ki

1478
01:13:04,610 --> 01:13:09,950
obstaja, da je argument,
kar je znak, kot je ta.

1479
01:13:09,950 --> 01:13:12,630
>> Izkazalo se je v C, tam je
en klic funkcije

1480
01:13:12,630 --> 01:13:15,550
na zgornji, ki je kot njegovo ime
kaže, je znak

1481
01:13:15,550 --> 01:13:19,350
in omogoča, da svojem zgornjem primeru
enakovredni, nato pa ga vrne

1482
01:13:19,350 --> 01:13:21,410
tako da se lahko printf priključite tam.

1483
01:13:21,410 --> 01:13:25,484
Tako, da to stori, čeprav sem
treba uvesti še eno datoteko.

1484
01:13:25,484 --> 01:13:28,400
Izkazalo se je, da je ena datoteka
da bi vedel le iz razreda,

1485
01:13:28,400 --> 01:13:33,020
ali učbenik, ali na spletu
reference, ki se imenuje C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Torej, če dodam, da se med moji glavi
datotek, in zdaj ponovno zbere ta program,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Kaj je tip v Zamyla v vseh
male, še vedno deluje enako.

1489
01:13:46,690 --> 01:13:48,040
Ampak veš kaj?

1490
01:13:48,040 --> 01:13:55,590
Izkazalo se je, da zgornja
ima nekatere druge funkcije.

1491
01:13:55,590 --> 01:13:58,410
>> In naj vam predstavim to
ukaz tukaj, nekako nerodno

1492
01:13:58,410 --> 01:14:00,250
poimenujejo, toda človek za priročnik.

1493
01:14:00,250 --> 01:14:03,960
Izkazalo se je, da je večina računalnikov Linux,
saj smo z here-- delovati Linux

1494
01:14:03,960 --> 01:14:06,270
system-- imajo ukaz
imenuje človek, ki pravi,

1495
01:14:06,270 --> 01:14:08,530
hej, računalnik, daj mi
uporabo računalnika.

1496
01:14:08,530 --> 01:14:10,680
Kaj želite
poglej v tem priročniku?

1497
01:14:10,680 --> 01:14:13,840
>> Želim poiskati funkcijo
poklicani, da zgornji del, Enter.

1498
01:14:13,840 --> 01:14:16,070
In to je malo skrivnosten
včasih brati.

1499
01:14:16,070 --> 01:14:18,780
Ampak obvestilo, da smo v
Navodilo za Linux programer je.

1500
01:14:18,780 --> 01:14:19,530
In to je vse besedilo.

1501
01:14:19,530 --> 01:14:21,905
In opazil, da je
ime funkcije tukaj.

1502
01:14:21,905 --> 01:14:25,030
Izkazalo se je, da ima bratranca, ki se imenuje
nižje, kar pa nasprotno.

1503
01:14:25,030 --> 01:14:29,710
In obvestilo na podlagi sinopsisa, za uporabo tega
delovanje strani man, tako rekoč,

1504
01:14:29,710 --> 01:14:32,220
se mi je povedal, da sem
morajo vključevati c type.h.

1505
01:14:32,220 --> 01:14:33,630
In vedel sem, da iz prakse.

1506
01:14:33,630 --> 01:14:36,210
>> Tukaj pa je mi pokazala dva
prototipi za funkcijo,

1507
01:14:36,210 --> 01:14:39,070
tako da če bom kdaj želite uporabiti to
Vem, kaj vzeti kot vhod,

1508
01:14:39,070 --> 01:14:40,652
in kaj se vrnejo kot proizvodnja.

1509
01:14:40,652 --> 01:14:42,360
In potem, če sem prebral
opis, vidim

1510
01:14:42,360 --> 01:14:44,820
podrobneje, kaj funkcija počne.

1511
01:14:44,820 --> 01:14:48,100
Toda še bolj pomembno, če
Gledam na podlagi vrednosti donosa,

1512
01:14:48,100 --> 01:14:51,710
se pravi, da je vrednost vrnjeno
da pretvorjene pisma,

1513
01:14:51,710 --> 01:14:57,880
ali C, prvotni vhod, če
pretvorba ni bilo mogoče.

1514
01:14:57,880 --> 01:15:01,992
>> Z drugimi besedami, na zgornji bodo poskušali
pretvoriti pismo zgornjem primeru.

1515
01:15:01,992 --> 01:15:03,450
In če je tako, gre za njegovo vrnitev.

1516
01:15:03,450 --> 01:15:07,010
Če pa ne more za nekatere reason--
Mogoče je že z velikimi črkami,

1517
01:15:07,010 --> 01:15:09,550
Mogoče je klicaj
ali kakšno drugo punctuation--

1518
01:15:09,550 --> 01:15:12,200
to je le, da bo
vrne izvirnik C,

1519
01:15:12,200 --> 01:15:17,340
kar pomeni, da lahko svojo kodo
Bolje zasnovan kot sledi.

1520
01:15:17,340 --> 01:15:20,580
>> Ne potrebujem vseh
Ti darn vrstic kode.

1521
01:15:20,580 --> 01:15:22,610
Vse proge sem
Samo izpostavil lahko

1522
01:15:22,610 --> 01:15:28,700
se zgrudil v samo enim samim
linija, ki je this-- printf odstotkov

1523
01:15:28,700 --> 01:15:33,510
c na zgornjem S nosilec i.

1524
01:15:33,510 --> 01:15:36,090
In to bi bilo
Primer boljše zasnove.

1525
01:15:36,090 --> 01:15:40,040
>> Zakaj izvajati v 7 ali 8 vrstic
kode, kar je bilo sem

1526
01:15:40,040 --> 01:15:44,960
izbrisani, ko lahko namesto propad
vse te logike in odločanje

1527
01:15:44,960 --> 01:15:49,620
v eno samo linijo, 13 zdaj, da
temelji na knjižnici function--

1528
01:15:49,620 --> 01:15:53,430
funkcija, ki prihaja s C, vendar
počne točno tisto, kar želite, da narediti.

1529
01:15:53,430 --> 01:15:55,295
In, odkrito povedano, tudi če
ni prišel s C,

1530
01:15:55,295 --> 01:15:58,880
bi lahko to izvedete sami, saj
smo videli, s dobili negativno int

1531
01:15:58,880 --> 01:16:01,700
in dobili pozitiven int prejšnji teden, kot tudi.

1532
01:16:01,700 --> 01:16:03,470
>> Ta koda je zdaj veliko bolj berljiva.

1533
01:16:03,470 --> 01:16:06,670
In, seveda, če se premikate navzgor,
poglej koliko bolj kompakten

1534
01:16:06,670 --> 01:16:08,360
ta različica mojega programa.

1535
01:16:08,360 --> 01:16:11,230
To je malo top težko zdaj,
z vsemi temi vključuje.

1536
01:16:11,230 --> 01:16:14,380
Ampak to je v redu, ker zdaj stojim
na ramenih programerjev

1537
01:16:14,380 --> 01:16:15,300
pred mano.

1538
01:16:15,300 --> 01:16:18,440
In kdo je bil kdo
izvajajo na zgornji res

1539
01:16:18,440 --> 01:16:21,470
si mi uslugo, podobno kot tisti,
izvaja Stirling res

1540
01:16:21,470 --> 01:16:24,790
si mi uslugo nekaj časa nazaj.

1541
01:16:24,790 --> 01:16:26,970
In zdaj imamo
boljše oblikovanje programa

1542
01:16:26,970 --> 01:16:31,680
da izvaja točno isto logiko.

1543
01:16:31,680 --> 01:16:35,580
>> Ko že govorimo o Stirling, naj
grem naprej in to.

1544
01:16:35,580 --> 01:16:38,320
Naj gredo naprej in shranite
sliko kot stirling.c.

1545
01:16:38,320 --> 01:16:43,255
In se je izkazalo, da lahko lupine nazaj
eno drugo plast zelo enostavno zdaj.

1546
01:16:43,255 --> 01:16:45,630
Bom, da gredo naprej in bič
do drug program v glavnem

1547
01:16:45,630 --> 01:16:49,759
tu se preprosto ponovni orodij
Dolžina niz kot sledi.

1548
01:16:49,759 --> 01:16:52,300
Torej, tukaj je vrstica kode, ki
me dobi niz od uporabnika.

1549
01:16:52,300 --> 01:16:53,910
Hranimo to z uporabo znova in znova.

1550
01:16:53,910 --> 01:16:58,900
Naj dam spremenljivko
n tipa int, ki shranjuje številko.

1551
01:16:58,900 --> 01:17:02,490
>> In mi gredo naprej in
naredite naslednje logiko.

1552
01:17:02,490 --> 01:17:15,610
Medtem ko n-karakter vs ne
ni enako poševnica nazaj 0, gredo naprej

1553
01:17:15,610 --> 01:17:17,930
in prirastek n.

1554
01:17:17,930 --> 01:17:23,506
In potem izpisal printf odstotkov i n.

1555
01:17:23,506 --> 01:17:29,200
Trdim, da ta program tukaj
ne pristanejo dolžine niza,

1556
01:17:29,200 --> 01:17:31,150
številke od dolžine niza.

1557
01:17:31,150 --> 01:17:34,600
>> In čarovnija je v celoti
vdelane v 8. vrstici

1558
01:17:34,600 --> 01:17:39,830
tukaj z Izgleda novo sintakso,
To poševnica nazaj 0 v enojnih narekovajih.

1559
01:17:39,830 --> 01:17:41,360
Toda zakaj je to?

1560
01:17:41,360 --> 01:17:44,100
No, razmisli, kaj je bilo
dogaja vsem tem času.

1561
01:17:44,100 --> 01:17:47,990
>> In kot stran, preden pozabim, zavedati
tudi, da poleg man strani

1562
01:17:47,990 --> 01:17:50,920
ki prihajajo s tipično
Linux sistem, kot CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
Zavedam se, da mi je
Osebje Seveda je, tudi

1564
01:17:53,770 --> 01:17:56,030
je različico spletnega mesta
te iste ideje imenovano

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, ki ima
vse te iste strani man,

1566
01:17:59,940 --> 01:18:02,020
vse to isto
dokumentacije, kakor tudi

1567
01:18:02,020 --> 01:18:05,730
malo polje na vrhu, ki omogoča
vi v spremeniti vse dokaj

1568
01:18:05,730 --> 01:18:09,025
Skrivnosten jezik v manj udoben
Način, kjer smo, učno osebje,

1569
01:18:09,025 --> 01:18:12,150
so šli skozi in poskušala poenostaviti
nekaj jezika, da se stvari

1570
01:18:12,150 --> 01:18:14,830
osredotočila na ideje, in ne
nekaj tehničnih podrobnosti.

1571
01:18:14,830 --> 01:18:20,070
Torej, imejte v mislih, reference.cs50.net
kot drugi vir, kot tudi.

1572
01:18:20,070 --> 01:18:23,800
>> Toda zakaj ne dolžine nizov delo
tako, kot sem predlagal trenutek nazaj?

1573
01:18:23,800 --> 01:18:25,160
Tukaj je spet ime Zamyla je.

1574
01:18:25,160 --> 01:18:27,690
In tukaj je ime Zamyla je
boxed, ko sem vztrajati početje,

1575
01:18:27,690 --> 01:18:31,360
slikati sliko, da bi jo,
Res, le zaporedje znakov.

1576
01:18:31,360 --> 01:18:34,260
Toda Zamyla ne obstaja
ločeno v programu.

1577
01:18:34,260 --> 01:18:37,420
>> Ko pišete in zaženete program,
boste uporabljali Mac ali računalnik

1578
01:18:37,420 --> 01:18:40,010
kot spomin ali RAM tako rekoč.

1579
01:18:40,010 --> 01:18:42,620
In si lahko zamislite
računalnik, da imajo

1580
01:18:42,620 --> 01:18:44,730
veliko gigabajtov spomina v teh dneh.

1581
01:18:44,730 --> 01:18:47,700
In koncert pomeni milijarde,
tako milijard bajtov.

1582
01:18:47,700 --> 01:18:48,910
>> Ampak kaj je previjanje v času.

1583
01:18:48,910 --> 01:18:51,530
In domnevam, da smo s pomočjo
res star računalnik, ki

1584
01:18:51,530 --> 01:18:55,150
Ima le 32 bajtov pomnilnika.

1585
01:18:55,150 --> 01:18:59,310
Lahko bi, na mojem računalniškem zaslonu,
preprosto sestaviti to takole.

1586
01:18:59,310 --> 01:19:05,240
>> Lahko bi preprosto rekel, da moj
Računalnik ima vse to spomin.

1587
01:19:05,240 --> 01:19:08,830
In to kot palico spomina, če
se spomnite naše slike iz zadnjega časa.

1588
01:19:08,830 --> 01:19:11,670
In če sem razdeliti
to dovolj časa,

1589
01:19:11,670 --> 01:19:15,040
Trdim, da imam 32 bajtov
spomina na zaslonu.

1590
01:19:15,040 --> 01:19:18,239
>> Zdaj, v resnici, sem lahko samo
pripraviti doslej na tem zaslonu tukaj.

1591
01:19:18,239 --> 01:19:20,280
Tako da sem šel naprej,
in samo po dogovoru,

1592
01:19:20,280 --> 01:19:24,050
pripraviti spomin mojega računalnika kot
omrežje, ne le kot ena premica.

1593
01:19:24,050 --> 01:19:28,190
Natančneje, Trdim zdaj,
ta mreža, to 8 s 4 omrežje,

1594
01:19:28,190 --> 01:19:31,800
samo predstavlja vseh 32 bajtov
pomnilnika na voljo na mojem Mac,

1595
01:19:31,800 --> 01:19:33,030
ali na voljo v mojem računalniku.

1596
01:19:33,030 --> 01:19:34,780
In oni zavijanje
na dve vrstici, samo

1597
01:19:34,780 --> 01:19:38,030
ker se prilega bolj na zaslonu.

1598
01:19:38,030 --> 01:19:40,800
Toda to je prvi bajt.

1599
01:19:40,800 --> 01:19:41,990
To je drugi bajt.

1600
01:19:41,990 --> 01:19:43,300
To je tretji bajt.

1601
01:19:43,300 --> 01:19:45,310
>> In to je 32. bajt.

1602
01:19:45,310 --> 01:19:52,910
Ali pa, če mislimo kot računalnik
znanstvenik, to je bajt 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Torej imate 0 do 31, če
začnete štetje na 0.

1604
01:19:55,950 --> 01:19:59,830
>> Torej, če bomo uporabili program
da se pri pozivih dobili niz,

1605
01:19:59,830 --> 01:20:05,280
in smo dobili niz s človeka
kot sem poklical Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
kako je v svetu počne
Računalnik Spremljajte ki bajt,

1607
01:20:09,430 --> 01:20:12,230
ki je kos pomnilnika,
pripada kateri niz?

1608
01:20:12,230 --> 01:20:16,270
Z drugimi besedami, če bomo nadaljevali
vnesite drugo ime v računalnik,

1609
01:20:16,270 --> 01:20:19,890
kot je ta Andi, kliče
dobili niz drugič,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I je na koncu v
pomnilnik računalnika, kot tudi.

1611
01:20:23,030 --> 01:20:23,850
Ampak kako?

1612
01:20:23,850 --> 01:20:29,700
>> No, se izkaže, da pod
napa, kaj C pa pri skladiščenju nize

1613
01:20:29,700 --> 01:20:35,080
da človeške vrste v, ali da
prihajajo iz nekega drugega vira, je

1614
01:20:35,080 --> 01:20:39,190
zarisuje konec njih s
posebna character-- poševnica nazaj

1615
01:20:39,190 --> 01:20:44,750
0, ki je prav poseben način
rekel 80 bitov v vrsti.

1616
01:20:44,750 --> 01:20:47,950
>> Torej A-- je to odpoklic številka 97.

1617
01:20:47,950 --> 01:20:51,770
Torej nekaj vzorec 8 bitov
predstavlja decimalno številko 97.

1618
01:20:51,770 --> 01:20:58,070
To poševnica nazaj 0 dobesedno številka
0, alias nul, N-U-L, za razliko od prej,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, ki smo se pogovarjali o tem.

1620
01:20:59,630 --> 01:21:05,700
Ampak za zdaj, samo vem, da je to
poševnica nazaj 0 je le 80 bitov v vrsti.

1621
01:21:05,700 --> 01:21:09,810
>> In to je samo ta vrstica v
pesek, ki pravi, da nič v levo

1622
01:21:09,810 --> 01:21:12,610
pripada en niz, ali eno vrsto podatkov.

1623
01:21:12,610 --> 01:21:15,480
In kaj na desno
pripada nekaj drugega.

1624
01:21:15,480 --> 01:21:17,440
Andi je ime, medtem,
ki samo vizualno

1625
01:21:17,440 --> 01:21:21,310
zgodi, da zaviti na drugi strani linije,
ampak to je samo estetska podrobnosti,

1626
01:21:21,310 --> 01:21:23,990
Podobno je zaključen.

1627
01:21:23,990 --> 01:21:29,290
>> Je niz a znakov A-N-D-I,
plus petina skrivnost character,

1628
01:21:29,290 --> 01:21:33,560
vsi 0 bitov, ki so pravkar razmejuje
konec imena Andi, kot tudi.

1629
01:21:33,560 --> 01:21:37,120
In če pravimo dobili niza tretjič
v računalnik, da bi dobili niz, kot je

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, podobno je maria je
Ime zaključen s poševnico 0.

1631
01:21:44,210 --> 01:21:47,170
>> To je bistveno drugačna
od tega, kako bi računalnik običajno

1632
01:21:47,170 --> 01:21:51,850
shranjevanje celo število ali plovec, ali druga
podatkovni tipi še vedno, saj odpoklic,

1633
01:21:51,850 --> 01:21:57,420
celo običajno 32 bitov ali
4 bajte, ali morda celo 64 bitov,

1634
01:21:57,420 --> 01:21:59,100
ali osem bajtov.

1635
01:21:59,100 --> 01:22:02,620
Toda mnogi primitivnih v računalniku
v programskem jeziku

1636
01:22:02,620 --> 01:22:05,550
imajo določeno število
bajti pod hood--

1637
01:22:05,550 --> 01:22:08,100
Mogoče 1, morda 2, mogoče 4, mogoče 8.

1638
01:22:08,100 --> 01:22:13,250
>> Ampak strune, z zasnovo, imajo
dinamično število znakov.

1639
01:22:13,250 --> 01:22:16,980
Ti ne veš vnaprej, dokler
človekovih vrste v Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
ali M-A-R-I-A ali A-N-D-I. Ti ne veš
kolikokrat je uporabnik bo hit

1641
01:22:21,400 --> 01:22:22,070
tipkovnico.

1642
01:22:22,070 --> 01:22:26,490
Torej, ne veš, kako
veliko znakov vnaprej

1643
01:22:26,490 --> 01:22:27,540
boste potrebovali.

1644
01:22:27,540 --> 01:22:31,840
>> In tako C le nekako pušča Like
Skrivnost Pasica pod pokrovom

1645
01:22:31,840 --> 01:22:32,960
Na koncu niza.

1646
01:22:32,960 --> 01:22:39,280
Po shranjevanju Z-A-M-Y-L-A v spominu,
pa tudi samo postavlja enakovredno

1647
01:22:39,280 --> 01:22:40,210
iz obdobja.

1648
01:22:40,210 --> 01:22:45,060
Na koncu stavka,
postavlja 80 bitov, tako

1649
01:22:45,060 --> 01:22:49,120
da se spomnimo, kjer
Zamyla začne in konča.

1650
01:22:49,120 --> 01:22:51,490
>> Torej, kaj je povezava,
potem, da ta program?

1651
01:22:51,490 --> 01:22:55,190
Ta program je tukaj, Stirling,
je le mehanizem

1652
01:22:55,190 --> 01:22:57,970
za pridobivanje niz
od uporabnika, linija 6.

1653
01:22:57,970 --> 01:23:01,160
Line 7, izjavljam spremenljivko
imenuje n in ga postavi na 0.

1654
01:23:01,160 --> 01:23:08,680
>> In potem v 8. vrstici, sem samo vprašal
Vprašanje, medtem ko n-karakter ne

1655
01:23:08,680 --> 01:23:12,120
ni enaka vse 0 bits--
z drugimi besedami, ne

1656
01:23:12,120 --> 01:23:14,500
enako ta posebna
značaj, poševnica nazaj 0, kar

1657
01:23:14,500 --> 01:23:18,470
je samo, da je posebna nul character--
iti naprej in samo prirastek n.

1658
01:23:18,470 --> 01:23:21,460
>> In ne delam, in obdržati
to počne, in da to počne.

1659
01:23:21,460 --> 01:23:23,430
In to čeprav je v
preteklosti smo i uporabljajo,

1660
01:23:23,430 --> 01:23:25,181
to je popolnoma v redu
pomensko uporabiti n,

1661
01:23:25,181 --> 01:23:27,430
Če ste samo poskušam
šteje tokrat namenoma,

1662
01:23:27,430 --> 01:23:28,720
in samo želim, da ga pokličete n.

1663
01:23:28,720 --> 01:23:34,720
Torej to kar naprej spraševali,
je n-ti značaj s vsi 0s?

1664
01:23:34,720 --> 01:23:38,470
Če ne, poglej na naslednjo videz,
poglej na naslednjo, poglej v drugo,

1665
01:23:38,470 --> 01:23:39,460
poglej na naslednjo.

1666
01:23:39,460 --> 01:23:45,540
>> Toda takoj, ko vidite poševnico 0,
ustavi ta loop-- linija 9 do 11--.

1667
01:23:45,540 --> 01:23:49,640
Zlomil si iz while,
zaustavi znotraj navedene variabilne n

1668
01:23:49,640 --> 01:23:54,530
skupno število vseh izmed
znakov v nizu, ki ga je videl,

1669
01:23:54,530 --> 01:23:55,660
s čimer je tiskanje.

1670
01:23:55,660 --> 01:23:56,760
Torej, poskusimo to.

1671
01:23:56,760 --> 01:23:59,500
>> Naj gredo naprej in brez
uporabo funkcije Stirling,

1672
01:23:59,500 --> 01:24:04,240
ampak z mojo lastno domač različico
tukaj se imenuje stirling, naj gredo naprej

1673
01:24:04,240 --> 01:24:07,700
in tek stirling, tip v nekaj
kot Zamyla, kar vem vnaprej

1674
01:24:07,700 --> 01:24:08,670
je šest znakov.

1675
01:24:08,670 --> 01:24:10,080
Poglejmo, če deluje.

1676
01:24:10,080 --> 01:24:10,920
Pravzaprav, to je šest.

1677
01:24:10,920 --> 01:24:15,257
Poskusimo z Rob, trije znaki,
trije znaki, kot tudi, in tako naprej.

1678
01:24:15,257 --> 01:24:17,340
Tako, da je vse, kar se dogaja
na pod pokrovom.

1679
01:24:17,340 --> 01:24:19,548
In opazili povezave,
nato pa s prvim tednom

1680
01:24:19,548 --> 01:24:22,370
razreda, kjer smo se pogovarjali o
nekaj podobnega abstrakcije,

1681
01:24:22,370 --> 01:24:26,960
ki je le ta Plastenje idej, ali
kompleksnosti, na vrhu temeljnih načel.

1682
01:24:26,960 --> 01:24:30,710
Tukaj smo nekako iščejo
Pod pokrovom Stirling,

1683
01:24:30,710 --> 01:24:33,510
tako rekoč, da ugotovimo,
kako bi se to izvaja?

1684
01:24:33,510 --> 01:24:35,232
>> In lahko bi ga ponovno izvesti sami.

1685
01:24:35,232 --> 01:24:37,440
Ampak mi nikoli ne bo spet
ponovno izvesti Stirling.

1686
01:24:37,440 --> 01:24:39,780
Mi smo le, da bo
uporabo Stirling da

1687
01:24:39,780 --> 01:24:42,100
dejansko dobil nekaj nizov dolžine.

1688
01:24:42,100 --> 01:24:44,200
>> Vendar ni magic
pod pokrovom.

1689
01:24:44,200 --> 01:24:46,716
Če veste, da pod
pokrov, niz

1690
01:24:46,716 --> 01:24:48,090
je samo zaporedje znakov.

1691
01:24:48,090 --> 01:24:51,090
In to zaporedje znakov
Vse lahko številčno obravnavati

1692
01:24:51,090 --> 01:24:53,330
z nosilcem 0, nosilec
1, nosilec 2, in si

1693
01:24:53,330 --> 01:24:57,420
vedo, da je na koncu niza
posebni znak, lahko ugotovimo,

1694
01:24:57,420 --> 01:25:01,710
kako narediti najbolj ničesar v
Program, saj vse to izvira na

1695
01:25:01,710 --> 01:25:03,400
je branje in pisanje spomin.

1696
01:25:03,400 --> 01:25:06,130
To pomeni, da se spreminja in išče
v spomin, ali se premika stvari

1697
01:25:06,130 --> 01:25:10,940
okrog v spomin, tiskanje stvari
na zaslonu, in tako naprej.

1698
01:25:10,940 --> 01:25:14,800
>> Torej, kaj je zdaj uporabljajo to novo pridobljeno
razumevanje tega, kaj Strune dejansko

1699
01:25:14,800 --> 01:25:17,910
so pod pokrovom, in
lupino nazaj eno drugo plast

1700
01:25:17,910 --> 01:25:20,080
da do sedaj smo jih
je ignoriranje v celoti.

1701
01:25:20,080 --> 01:25:22,650
Še posebej, kadar koli
smo izvajali program,

1702
01:25:22,650 --> 01:25:25,930
smo imeli to vrstico kode
Na vrhu razglasitvi glavni.

1703
01:25:25,930 --> 01:25:27,810
In smo določeno int glavni praznino.

1704
01:25:27,810 --> 01:25:31,240
>> In ta praznina znotraj oklepajev
bil je pravi, ves ta čas, da je glavna

1705
01:25:31,240 --> 01:25:33,440
sama po sebi ne bo nobenih argumentov.

1706
01:25:33,440 --> 01:25:36,210
Vsako vhod, ki je glavni
bo dobil od uporabnika

1707
01:25:36,210 --> 01:25:39,020
mora priti iz nekaterih drugih
mehanizem, kot get int

1708
01:25:39,020 --> 01:25:42,040
ali pa plovec, ali pa niz,
ali kakšno drugo funkcijo.

1709
01:25:42,040 --> 01:25:44,710
Vendar se je izkazalo, da je
ko pišete program,

1710
01:25:44,710 --> 01:25:47,690
lahko dejansko določite
da je ta program se

1711
01:25:47,690 --> 01:25:51,730
sprejme prispevke iz človeka
Na samem ukazno vrstico.

1712
01:25:51,730 --> 01:25:56,310
>> Z drugimi besedami, čeprav smo doslej
še poteka samo ./hello zdravo

1713
01:25:56,310 --> 01:26:00,312
ali podobni programi, vse od
druge programe, ki smo jih uporabljali,

1714
01:26:00,312 --> 01:26:02,770
da sami ne pisati,
so imeli pri tem, se zdi,

1715
01:26:02,770 --> 01:26:05,210
ukazni vrstici arguments--
stvari, kot narediti.

1716
01:26:05,210 --> 01:26:07,450
Pravite, da nekaj podobnega narediti,
in nato druga beseda.

1717
01:26:07,450 --> 01:26:10,950
Ali Jek, da ste Jek, nato pa
druga beseda, ime datoteke.

1718
01:26:10,950 --> 01:26:14,410
>> Ali celo RM ali CP, kot si morda
Videli ali uporabljati že

1719
01:26:14,410 --> 01:26:15,880
odstraniti ali kopirati datoteko.

1720
01:26:15,880 --> 01:26:18,920
Vse tiste sprejme tako imenovani
ukazni vrstici arguments--

1721
01:26:18,920 --> 01:26:21,130
dodatna stavka terminala poziv.

1722
01:26:21,130 --> 01:26:23,260
Toda do sedaj, smo
sami niso imeli

1723
01:26:23,260 --> 01:26:27,080
to razkošje ob vhod iz
Uporabnik, ko on ali ona dejansko deluje

1724
01:26:27,080 --> 01:26:29,120
sam program v ukazni vrstici.

1725
01:26:29,120 --> 01:26:33,710
>> Vendar pa lahko storimo, da jo ponovno izjavlja,
Glavni napreduje, ne da imajo

1726
01:26:33,710 --> 01:26:36,750
razveljavi v oklepaju,
razen teh dveh argumentov

1727
01:26:36,750 --> 01:26:40,600
instead-- prvo celo število,
in drugi nekaj

1728
01:26:40,600 --> 01:26:44,170
novo, nekaj, kar bomo klic
niz, nekaj podobnega v duhu

1729
01:26:44,170 --> 01:26:49,220
s tem, kar smo videli v Scratch kot seznam, vendar
niz nizov, kot bomo kmalu videli.

1730
01:26:49,220 --> 01:26:51,790
Toda poglejmo to z
Na primer, preden smo

1731
01:26:51,790 --> 01:26:53,690
razlikovati, kaj to pomeni.

1732
01:26:53,690 --> 01:26:56,520
>> Torej, če sem šel v CS50 IDE
Tukaj sem šel naprej

1733
01:26:56,520 --> 01:27:01,840
in prijavljeni v datoteki
argv0.c naslednjo predlogo.

1734
01:27:01,840 --> 01:27:04,120
In opazil, edina stvar,
da je drugačen doslej

1735
01:27:04,120 --> 01:27:08,570
je, da sem se spremenila nična int
argc niz argv odprt nosilec, blizu

1736
01:27:08,570 --> 01:27:09,070
nosilec.

1737
01:27:09,070 --> 01:27:11,730
In opazil, za zdaj pa je
nič znotraj teh razredov.

1738
01:27:11,730 --> 01:27:12,620
>> Ni številka.

1739
01:27:12,620 --> 01:27:15,070
In ni i, ali
n, ali katerokoli drugo črko.

1740
01:27:15,070 --> 01:27:17,010
Jaz sem samo z uporabo
oglati oklepaji za zdaj,

1741
01:27:17,010 --> 01:27:19,510
zaradi bomo prišli
nazaj čez nekaj trenutkov.

1742
01:27:19,510 --> 01:27:21,330
>> In zdaj, kaj bom storiti, je to.

1743
01:27:21,330 --> 01:27:26,680
Če argc enaka enaka 2--
in opozarjajo, da je enaka pogoja je enako

1744
01:27:26,680 --> 01:27:30,040
je upravljavec enakost primerjavo
levo in desno za enakost.

1745
01:27:30,040 --> 01:27:31,790
To ni naloga
subjekt, ki je

1746
01:27:31,790 --> 01:27:36,510
enotni enačaj, kar pomeni kopijo
z desne na levo neko vrednost.

1747
01:27:36,510 --> 01:27:42,840
>> Če argc enak enak 2, hočem
recimo, printf, zdravo, procenti, nova vrstica,

1748
01:27:42,840 --> 01:27:47,340
in nato priključite in-- in tukaj je nova
trick-- argv nosilec 1, iz razlogov,

1749
01:27:47,340 --> 01:27:48,840
da se bomo vrnili v trenutku.

1750
01:27:48,840 --> 01:27:52,110
Sicer če argc ne
enako 2, veš kaj?

1751
01:27:52,110 --> 01:27:57,400
Kaj je samo iti naprej in, kot ponavadi, tiskanje
ven zdravo svet brez zamenjave.

1752
01:27:57,400 --> 01:28:02,710
>> Tako se zdi, da če argc, ki
stojala za štetje argument, enaka 2,

1753
01:28:02,710 --> 01:28:04,740
Bom natisniti
zdravo nekaj ali drugi.

1754
01:28:04,740 --> 01:28:07,560
V nasprotnem primeru, ki ga privzeto, da sem
tiskanjem zdravo svet.

1755
01:28:07,560 --> 01:28:08,770
Torej, kaj to pomeni?

1756
01:28:08,770 --> 01:28:15,550
>> No, naj gredo naprej in shranite
ta datoteka, nato pa naredite, da argv0,

1757
01:28:15,550 --> 01:28:18,940
in potem ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
In pravi, zdravo svet.

1759
01:28:20,300 --> 01:28:21,260
Zdaj, zakaj je to?

1760
01:28:21,260 --> 01:28:24,730
>> No, se izkaže, kadarkoli
zagnati program v ukazni vrstici,

1761
01:28:24,730 --> 01:28:29,570
ste polnjenje, kaj bomo
običajno zahtevajo argumenta vektor.

1762
01:28:29,570 --> 01:28:33,100
Z drugimi besedami, se samodejno
računalnik, operacijski sistem,

1763
01:28:33,100 --> 01:28:38,340
se bo pri roki, da vaš program
Sam seznam vseh besed

1764
01:28:38,340 --> 01:28:40,850
da človeško vpisali
poziv, v primeru, da

1765
01:28:40,850 --> 01:28:43,790
programer želite storiti
nekaj s teh informacij.

1766
01:28:43,790 --> 01:28:48,540
In v tem primeru, le beseda
Sem tipkal na poziv je ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> In tako se je število argumentov, da je
prevalili na mojem programu je samo eden.

1768
01:28:55,420 --> 01:28:58,880
Z drugimi besedami, argument
računajo, sicer znan kot argc

1769
01:28:58,880 --> 01:29:00,970
Tukaj kot celo število, je le ena.

1770
01:29:00,970 --> 01:29:03,000
Ena, seveda, ne enako dve.

1771
01:29:03,000 --> 01:29:05,980
In zato je to tisto, kar natisne, zdravo svet.

1772
01:29:05,980 --> 01:29:08,170
>> Ampak naj bo to nekje.

1773
01:29:08,170 --> 01:29:09,930
Naj povem, argv0.

1774
01:29:09,930 --> 01:29:12,740
In potem kako približno Maria?

1775
01:29:12,740 --> 01:29:14,990
In nato pritisnite tipko Enter.

1776
01:29:14,990 --> 01:29:18,020
>> In opazil, kaj se čudežno zgodi tukaj.

1777
01:29:18,020 --> 01:29:22,640
Zdaj, namesto Hello World, imam
spremenili obnašanje programa

1778
01:29:22,640 --> 01:29:26,310
tako, da se vložek ne od get
niz ali kakšno drugo funkcijo,

1779
01:29:26,310 --> 01:29:30,570
ampak, očitno, moj ukaz
sama, kar sem prvotno vnesli.

1780
01:29:30,570 --> 01:29:35,720
In lahko igram to igro znova
jo spremeniti na Stelios, na primer.

1781
01:29:35,720 --> 01:29:38,400
>> In zdaj vidim še drugo ime.

1782
01:29:38,400 --> 01:29:40,540
In tukaj, lahko rečem Andi.

1783
01:29:40,540 --> 01:29:42,137
In lahko rečem Zamyla.

1784
01:29:42,137 --> 01:29:45,220
In lahko igra to igro ves dan,
le priključiti v različnih vrednostih,

1785
01:29:45,220 --> 01:29:49,550
tako dolgo, kot sem zagotavlja natančno
dve besedi na poziv,

1786
01:29:49,550 --> 01:29:52,260
tako da argc, štetje moj argument, je 2.

1787
01:29:52,260 --> 01:29:57,240
>> Vidim, da je ime priključen v
printf, na ta pogoj tukaj?

1788
01:29:57,240 --> 01:30:00,550
Tako se zdi, da imajo sedaj
izrazna sposobnost

1789
01:30:00,550 --> 01:30:04,410
sprejemanja vhod iz drugega mehanizma,
Iz tako imenovanega ukazno vrstico,

1790
01:30:04,410 --> 01:30:07,000
namesto da bi morali čakati
dokler uporabnik zažene program,

1791
01:30:07,000 --> 01:30:10,220
in potem mu poziv
nekako takole: get niz.

1792
01:30:10,220 --> 01:30:11,230
>> Torej, kaj je to?

1793
01:30:11,230 --> 01:30:15,010
Argc, še enkrat, je samo celo število,
število words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
da uporabnik predložijo na
hitro, na oknu terminala,

1795
01:30:18,540 --> 01:30:20,110
vključno z imenom programa.

1796
01:30:20,110 --> 01:30:23,340
Torej naš ./argv0 je učinkovito,
ime programa,

1797
01:30:23,340 --> 01:30:24,520
ali kako zagnati program.

1798
01:30:24,520 --> 01:30:25,810
>> To šteje kot beseda.

1799
01:30:25,810 --> 01:30:27,080
Zato bi argc bilo 1.

1800
01:30:27,080 --> 01:30:29,750
Toda, ko pišem Stelios, ali
Andi, ali Zamyla ali Maria,

1801
01:30:29,750 --> 01:30:31,660
to pomeni, da je število argument je dva.

1802
01:30:31,660 --> 01:30:33,910
In tako zdaj je dve besedi minilo v.

1803
01:30:33,910 --> 01:30:36,070
>> In obvestilo, lahko nadaljujemo to logiko.

1804
01:30:36,070 --> 01:30:39,050
Če dejansko rečem
nekaj podobnega Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
polno ime, s tem pa poteka
tri argumente v celoti,

1806
01:30:42,200 --> 01:30:47,410
Zdaj pa pravi, privzeti še enkrat,
ker je seveda 3 ni enaka 2.

1807
01:30:47,410 --> 01:30:54,080
>> In to na ta način, moram
dostop preko argv ta nov argument

1808
01:30:54,080 --> 01:30:56,080
da smo lahko tehnično
kaj želimo poklicati.

1809
01:30:56,080 --> 01:30:58,940
Toda po dogovoru, da je
argv in argc oz.

1810
01:30:58,940 --> 01:31:04,470
Argv, argument vector, je nekako
za sinonim za programiranje

1811
01:31:04,470 --> 01:31:07,140
funkcija v C se imenuje niz.

1812
01:31:07,140 --> 01:31:14,410
>> Množica je seznam podobnih vrednot
nazaj, nazaj, nazaj, na hrbet.

1813
01:31:14,410 --> 01:31:17,810
Z drugimi besedami, če je tukaj v
RAM, naslednjič je tik ob njem,

1814
01:31:17,810 --> 01:31:18,800
in zraven njega.

1815
01:31:18,800 --> 01:31:20,101
Oni niso povsod.

1816
01:31:20,101 --> 01:31:23,100
In da ta scenarij, kjer se stvari
so po vsem mestu v spomin,

1817
01:31:23,100 --> 01:31:25,082
lahko dejansko močna funkcija.

1818
01:31:25,082 --> 01:31:28,040
Vendar se bomo vrnili na to, ko smo
govorimo o luksuznih podatkovnih struktur.

1819
01:31:28,040 --> 01:31:32,260
Za zdaj, niz je le
kos zveznega pomnilnika,

1820
01:31:32,260 --> 01:31:36,520
vsak od katerih elementi
nazaj, nazaj, nazaj, nazaj,

1821
01:31:36,520 --> 01:31:38,050
in na splošno istega tipa.

1822
01:31:38,050 --> 01:31:42,630
>> Torej, če pomislite, od A
Malo prej, kar je niz?

1823
01:31:42,630 --> 01:31:50,460
No, niz, kot Zamyla,
Z-A-M-Y-L-A, je tehnično,

1824
01:31:50,460 --> 01:31:51,400
samo polje.

1825
01:31:51,400 --> 01:31:53,700
To je niz znakov.

1826
01:31:53,700 --> 01:31:59,250
>> In zato, če res pripraviti to, kot sem
niti prej kot kos spomina,

1827
01:31:59,250 --> 01:32:04,510
se izkaže, da je vsak od teh
znaki zavzema bajt.

1828
01:32:04,510 --> 01:32:07,630
In potem je tukaj še, da posebni
sentinel lik je poševnica nazaj 0,

1829
01:32:07,630 --> 01:32:12,360
ali vseh osem 0 bitov, da
razmejuje konec tega niza.

1830
01:32:12,360 --> 01:32:15,090
Torej niz, se je izkazalo
ven, citiram konec citata niz,

1831
01:32:15,090 --> 01:32:20,580
je samo niz chara--
char pa dejansko tip podatkov.

1832
01:32:20,580 --> 01:32:24,560
>> In zdaj argv, meanwhile--
vrnimo k programu.

1833
01:32:24,560 --> 01:32:29,582
Argv, čeprav smo videli besedo
Niz tu ni niz sama.

1834
01:32:29,582 --> 01:32:33,640
Argv, argument vektor,
je niz nizov.

1835
01:32:33,640 --> 01:32:37,620
>> Torej, tako kot lahko imate niz
znakov, ki jih lahko imajo višjo stopnjo,

1836
01:32:37,620 --> 01:32:46,279
niz strings-- tako, na primer,
ko sem tipkal trenutek pred ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, prostor Z-A-M-Y-L-A, sem trdil, da
argv dve nizov v it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
in Z-A-M-Y-L-A. v
Z drugimi besedami, argc: 2.

1839
01:33:03,185 --> 01:33:03,980
Zakaj je tako?

1840
01:33:03,980 --> 01:33:08,370
>> No, dejansko, kaj se dogaja
o je, da je vsak od teh nizov

1841
01:33:08,370 --> 01:33:13,990
je seveda niz znakov
kot prej, vsak od katerih znakov

1842
01:33:13,990 --> 01:33:15,670
prevzame enega bita.

1843
01:33:15,670 --> 01:33:19,720
In ne mešaj dejanskega 0
v imenu programa z 0,

1844
01:33:19,720 --> 01:33:22,040
kar pomeni, da vse 80 bitov.

1845
01:33:22,040 --> 01:33:27,140
In Zamyla, medtem, je še vedno
tudi niz znakov.

1846
01:33:27,140 --> 01:33:31,450
>> Tako da ob koncu dneva, res
Izgleda da je ta pod pokrovom.

1847
01:33:31,450 --> 01:33:38,800
Ampak argv, po svoji naravi, kako glavni
dela, mi omogoča, da se ovije vse to

1848
01:33:38,800 --> 01:33:44,810
pripravo, če hočete, večji niz
da če smo nekoliko nad poenostaviti

1849
01:33:44,810 --> 01:33:48,180
kakšna slika izgleda in ne
prav tako pripravi na lestvici tam,

1850
01:33:48,180 --> 01:33:56,720
To zaporedje je le velikosti 2, prvi
element, ki vsebuje niz,

1851
01:33:56,720 --> 01:33:59,230
Drugi element
ki vsebuje niz.

1852
01:33:59,230 --> 01:34:01,687
In po drugi strani, če vas
nekako povečati na vsaki

1853
01:34:01,687 --> 01:34:03,770
od teh nizov, kar si
glej pod pokrovom

1854
01:34:03,770 --> 01:34:07,190
je, da je vsak niz pravkar
niz znakov.

1855
01:34:07,190 --> 01:34:11,680
>> Zdaj pa, tako kot pri strune,
smo lahko, da bi dobili dostop

1856
01:34:11,680 --> 01:34:15,260
za i-ti znak v nizu
uporabo tega oglati oklepaj zapis.

1857
01:34:15,260 --> 01:34:17,320
Podobno z nizi
na splošno, lahko

1858
01:34:17,320 --> 01:34:22,700
uporabiti kvadratni nosilec zapisa, da bi dobili
na poljubnem številu nizov v matrike?

1859
01:34:22,700 --> 01:34:25,100
Na primer, kaj me
gredo naprej in to.

1860
01:34:25,100 --> 01:34:32,420
>> Naj gredo naprej in ustvariti argv1.c,
ki je malo drugačna tokrat.

1861
01:34:32,420 --> 01:34:35,635
Namesto preverjanje argc2,
Bom to namesto tega narediti.

1862
01:34:35,635 --> 01:34:41,270
Za int dobim 0, mi je manj
kot argc sem plus plus,

1863
01:34:41,270 --> 01:34:47,920
in nato natisnete znotraj tega,
odstotkov s, nova vrstica, in nato

1864
01:34:47,920 --> 01:34:50,740
argv nosilec i.

1865
01:34:50,740 --> 01:34:55,220
>> Torej, z drugimi besedami, ne bom se ukvarjajo s
Posamezni liki v tem trenutku.

1866
01:34:55,220 --> 01:35:00,190
Argv, kot je predvideno s temi praznega kvadrata
naramnice na desni strani imena argv,

1867
01:35:00,190 --> 01:35:03,320
pomeni argv je niz nizov.

1868
01:35:03,320 --> 01:35:04,870
In argc je samo int.

1869
01:35:04,870 --> 01:35:08,800
>> Ta linija tukaj, 6, je
rekoč niz i, enako 0.

1870
01:35:08,800 --> 01:35:11,980
Preštejte vse do,
vendar ne vključno s, argc.

1871
01:35:11,980 --> 01:35:14,010
In potem na vsaki ponovitvi
izpisal niz.

1872
01:35:14,010 --> 01:35:14,800
Kaj niz?

1873
01:35:14,800 --> 01:35:17,270
>> Niz i-ti v argv.

1874
01:35:17,270 --> 01:35:19,530
Torej, ker je, preden sem bil
uporabo kvadratni nosilec

1875
01:35:19,530 --> 01:35:22,180
Zapis, da bi dobili na i-
znak v nizu, ki je zdaj

1876
01:35:22,180 --> 01:35:27,240
Jaz sem z uporabo kvadratni nosilec zapisa v
priti na i-niza v niz.

1877
01:35:27,240 --> 01:35:30,310
Torej, to je nekako eno plast
zgoraj, konceptualno.

1878
01:35:30,310 --> 01:35:35,390
>> In kaj je gladka o tem
Program sedaj, če sem sestaviti argv1,

1879
01:35:35,390 --> 01:35:42,067
in naredite ./argv1 in nato vnesite
nekaj podobnega foo bar Baz,

1880
01:35:42,067 --> 01:35:45,400
ki so tri privzete besede, a
računalniški znanstvenik doseže v vsakem trenutku

1881
01:35:45,400 --> 01:35:51,010
on ali ona potrebuje nekaj ogradami besed,
in pritisnite tipko Enter, vsaka od teh besed,

1882
01:35:51,010 --> 01:35:54,980
vključno z imenom programa, ki
V argv na prvem mestu,

1883
01:35:54,980 --> 01:35:58,320
konča se natisne ena naenkrat.

1884
01:35:58,320 --> 01:36:05,290
In če se to spremeni, in pravim
nekaj podobnega argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
smo dobili vsi trije tistih
besede, ki je argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, saj v tem
Primer argc, število, je 3.

1887
01:36:14,400 --> 01:36:20,020
>> Toda kaj je lepo je, če ste razumeli
da argv je le niz nizov,

1888
01:36:20,020 --> 01:36:24,910
in boste razumeli, da niz
je niz znakov,

1889
01:36:24,910 --> 01:36:29,470
lahko dejansko nekako uporabiti to
oglati oklepaj za zapis večkrat

1890
01:36:29,470 --> 01:36:33,320
izbrati niz, nato pa izberite
znak v nizu,

1891
01:36:33,320 --> 01:36:35,730
potapljanje globlje, kot sledi.

1892
01:36:35,730 --> 01:36:40,100
V tem primeru, naj grem
naprej in to imenujemo argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
In v tem primeru, naj gredo naprej
in narediti following-- za int dobim 0,

1895
01:36:50,180 --> 01:36:53,286
i manj kot argc, i plus
plus, tako kot prej.

1896
01:36:53,286 --> 01:36:55,910
Torej, v drugih words-- in zdaj to
je že dovolj zapleteno.

1897
01:36:55,910 --> 01:36:59,940
Potem bom povedal
Ponovil več nizov v argv,

1898
01:36:59,940 --> 01:37:01,294
kot komentar k sebi.

1899
01:37:01,294 --> 01:37:03,960
In potem bom imela
ugnezdeni zanko, ki vas verjetno

1900
01:37:03,960 --> 01:37:06,290
naredili, ali velja
tem, v Scratch, kjer

1901
01:37:06,290 --> 01:37:08,600
Bom povedal int-- sem
ne bo i ponovno uporabiti,

1902
01:37:08,600 --> 01:37:12,590
zato, ker ne želim, da v senci, ali
nekako prepisati obstoječo i.

1903
01:37:12,590 --> 01:37:15,780
>> Bom, namesto da bi, recimo j, ker
to je moj pojdite na spremenljivko po i,

1904
01:37:15,780 --> 01:37:18,590
ko sem samo poskušam
štejejo preproste številke.

1905
01:37:18,590 --> 01:37:28,850
Za j dobi 0-- in tudi, n, se bo
dobili krmno dolžino argv nosilca i,

1906
01:37:28,850 --> 01:37:36,030
dokler jje manj kot m,
j plus plus, naredite naslednje.

1907
01:37:36,030 --> 01:37:37,500
In tukaj je zanimiv del.

1908
01:37:37,500 --> 01:37:46,330
>> Natisnite znak in novo linijo,
priklopom v argv nosilec i, nosilec j.

1909
01:37:46,330 --> 01:37:47,940
OK, tako da naj dodam nekaj pripomb tukaj.

1910
01:37:47,940 --> 01:37:54,820
Ponovil več znakov
V sedanjem nizu,

1911
01:37:54,820 --> 01:38:02,290
print j-ti znak v i-niz.

1912
01:38:02,290 --> 01:38:04,630
Torej sedaj, kaj menijo
kaj te pripombe pomeni.

1913
01:38:04,630 --> 01:38:06,750
>> Ponovil čez strune
V argv-- koliko

1914
01:38:06,750 --> 01:38:09,300
strune so v argv, ki je matrika?

1915
01:38:09,300 --> 01:38:13,420
Argc veliko, tako da sem sem ponavljanjem
od i enaka 0 do argc.

1916
01:38:13,420 --> 01:38:20,020
Medtem, koliko znakov
so v nizu i-tega v argv?

1917
01:38:20,020 --> 01:38:22,880
>> No, da bi dobili ta odgovor,
Pravkar sem poklical dolžino niza

1918
01:38:22,880 --> 01:38:26,810
o negi I trenutni niz
o tem, kar je argv nosilec i.

1919
01:38:26,810 --> 01:38:30,090
In bom za začasno shranjevanje, ki
vrednost n, samo za namene, za predpomnjenje,

1920
01:38:30,090 --> 01:38:31,590
da jo shranimo za učinkovitost.

1921
01:38:31,590 --> 01:38:36,330
In potem bom inicializacijo j 0,
nadaljuj dokler jje manj kot n,

1922
01:38:36,330 --> 01:38:38,430
in na vsako ponovitev prirastek j.

1923
01:38:38,430 --> 01:38:41,030
>> In potem je tukaj, na
moj komentar na liniji 12,

1924
01:38:41,030 --> 01:38:43,390
izpisal znak,
čemur sledi novo vrstico,

1925
01:38:43,390 --> 01:38:48,140
posebej argv nosilec
i mi daje niz i-ti

1926
01:38:48,140 --> 01:38:51,690
V argv-- tako prvo besedo,
druga beseda, tretja beseda, karkoli.

1927
01:38:51,690 --> 01:38:57,370
In potem j potopi v globlje, in dobi
me j-ti značaj te besede.

1928
01:38:57,370 --> 01:39:02,200
In tako, v smislu, da lahko zdravljenje
argv kot večdimenzionalni,

1929
01:39:02,200 --> 01:39:06,050
kot dvodimenzionalno, matrike,
pri čemer vsaka beseda nekako izgleda

1930
01:39:06,050 --> 01:39:08,580
kot je to v vaš um je
oči, in vsak lik

1931
01:39:08,580 --> 01:39:10,930
je nekako sestavljen
stolpec, če to pomaga.

1932
01:39:10,930 --> 01:39:13,260
>> V resnici, ko se draži
To narazen v prihodnjih tednih,

1933
01:39:13,260 --> 01:39:15,580
to se dogaja, da se malo
bolj zapletena kot.

1934
01:39:15,580 --> 01:39:17,800
Ampak lahko res
pomislite, da je za zdaj,

1935
01:39:17,800 --> 01:39:22,110
kot samo to dvodimenzionalna
matrika, ena stopnja njej, pri čemer

1936
01:39:22,110 --> 01:39:23,260
je vse strune.

1937
01:39:23,260 --> 01:39:26,760
In potem, če se potopite v globljem, vas
lahko dobite na posameznih znakov

1938
01:39:26,760 --> 01:39:29,600
v njej z uporabo te zapis tukaj.

1939
01:39:29,600 --> 01:39:31,620
>> Torej, kaj je neto učinek?

1940
01:39:31,620 --> 01:39:34,970
Naj gredo naprej in
da argv2-- darn ga.

1941
01:39:34,970 --> 01:39:36,210
Naredil sem napako tukaj.

1942
01:39:36,210 --> 01:39:40,160
Implicitno razglasitvi
Knjižnica funkcija stirling.

1943
01:39:40,160 --> 01:39:42,190
Torej, ves ta čas, to je
morda je to primerno

1944
01:39:42,190 --> 01:39:45,130
da smo nekako dodelavo
točno tam, kjer smo začeli.

1945
01:39:45,130 --> 01:39:48,160
>> Zajebal sem, implicitno razglasi
Knjižnica funkcija stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, počakaj malo.

1947
01:39:48,987 --> 01:39:51,070
Spomnim se, da so zlasti
saj je prav tukaj.

1948
01:39:51,070 --> 01:39:54,490
Moram vključiti string.h v
Ta različica programa.

1949
01:39:54,490 --> 01:40:00,050
>> Naj gredo naprej in vključujejo
string.h, razen, da gredo naprej

1950
01:40:00,050 --> 01:40:04,460
in prevesti argv2.

1951
01:40:04,460 --> 01:40:08,390
In zdaj, gremo, da argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
In čeprav je malo
Grobni na prvi pogled,

1953
01:40:10,590 --> 01:40:15,690
opazili, da je res, kar
natisnjena je pika argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Ampak, če sem tip nekaj besed po
hitro, kot argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Vnesite tudi malo
Grobni na prvi pogled.

1956
01:40:22,560 --> 01:40:30,540
Ampak, če se pomaknete nazaj gor,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Tako smo poudarili, nad vsako besedo.

1958
01:40:32,190 --> 01:40:37,770
In po drugi strani, smo poudarili, preko
vsak znak v besedi.

1959
01:40:37,770 --> 01:40:40,040
>> Zdaj, po vsem tem,
Zavedam se, da obstaja

1960
01:40:40,040 --> 01:40:43,120
še ena podrobnost smo bili nekako
ignorirali to ves čas.

1961
01:40:43,120 --> 01:40:46,180
Pravkar smo smo ga raztrgali, kar
Glavna je vhodi so lahko?

1962
01:40:46,180 --> 01:40:47,780
Kaj pa izhod glavne stranke?

1963
01:40:47,780 --> 01:40:50,540
>> Vsi tem času smo bili
samo s kopiranjem in lepljenjem

1964
01:40:50,540 --> 01:40:53,870
beseda int pred glavno,
čeprav lahko vidite na spletu,

1965
01:40:53,870 --> 01:40:58,340
včasih napačno v starejših različicah
C in prevajalniki, ki pravijo nična,

1966
01:40:58,340 --> 01:40:59,410
ali pa sploh nič.

1967
01:40:59,410 --> 01:41:01,580
Ampak, seveda, za različico
C, ki jih uporabljate,

1968
01:41:01,580 --> 01:41:06,180
C 11 ali 2011, uresničiti
da mora biti int.

1969
01:41:06,180 --> 01:41:09,300
In bi moralo bodisi
ničen ali argc in argv tukaj.

1970
01:41:09,300 --> 01:41:10,790
>> Ampak zakaj int main?

1971
01:41:10,790 --> 01:41:12,480
Kaj je pravzaprav vrača?

1972
01:41:12,480 --> 01:41:16,280
No, se izkaže, vse od takrat,
koli ste napisali programski main

1973
01:41:16,280 --> 01:41:18,440
se vedno vrača nekaj.

1974
01:41:18,440 --> 01:41:19,960
Toda to je bilo to na skrivaj.

1975
01:41:19,960 --> 01:41:23,350
>> To nekaj je
int, kot črte 5 kaže.

1976
01:41:23,350 --> 01:41:24,225
Toda kaj int?

1977
01:41:24,225 --> 01:41:26,100
No, tam je to
konvencija v programiranju,

1978
01:41:26,100 --> 01:41:29,790
čemer se, če je nič
narobe in je vse v redu,

1979
01:41:29,790 --> 01:41:34,250
Programi in funkcije na splošno
return-- nekoliko counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 na splošno pomeni, da je vse dobro.

1982
01:41:38,070 --> 01:41:40,610
Torej, čeprav misliš
je kot napačna v številnih kontekstih,

1983
01:41:40,610 --> 01:41:42,930
pravzaprav na splošno pomeni dobra stvar

1984
01:41:42,930 --> 01:41:49,560
>> Medtem, če program vrne 1,
ali negativno 1 ali 5, ali negativen 42,

1985
01:41:49,560 --> 01:41:52,941
ali ne-0 vrednost,
ki na splošno označuje

1986
01:41:52,941 --> 01:41:54,190
da nekaj je narobe.

1987
01:41:54,190 --> 01:41:56,700
Dejstvo je, na svoj Mac ali PC,
ste morda dejansko videli

1988
01:41:56,700 --> 01:42:01,050
sporočilo o napaki, jo katerim
kaj reče ali drugo, napaka

1989
01:42:01,050 --> 01:42:04,940
koda negativen 42 ali koda napake
23, ali nekaj takega.

1990
01:42:04,940 --> 01:42:08,980
To število je običajno le namig
programer ali družba

1991
01:42:08,980 --> 01:42:11,174
da je programsko opremo,
kaj je šlo narobe in zakaj,

1992
01:42:11,174 --> 01:42:13,590
tako da lahko odmisliti
njihovo dokumentacijo ali koda,

1993
01:42:13,590 --> 01:42:15,465
in ugotoviti, kaj je
Napaka pravzaprav pomeni.

1994
01:42:15,465 --> 01:42:18,400
To običajno ni
koristno za nas končne uporabnike.

1995
01:42:18,400 --> 01:42:20,550
>> Toda, ko je vse v redu glavni vrne 0.

1996
01:42:20,550 --> 01:42:23,770
In če ne podate
kaj glavna mora vrniti,

1997
01:42:23,770 --> 01:42:26,950
To bo šele samodejno
vrne 0 za vas.

1998
01:42:26,950 --> 01:42:30,870
Ampak vrača nekaj
ostalo je dejansko uporaben.

1999
01:42:30,870 --> 01:42:34,660
>> V tem zadnjem programu, naj me
gredo naprej in to imenujemo exit.c,

2000
01:42:34,660 --> 01:42:38,630
in uvesti zadnji današnji
teme, znane kot kodo napake.

2001
01:42:38,630 --> 01:42:42,930
Naj gredo naprej in vključujejo naše
znane datoteke up top, delati int main.

2002
01:42:42,930 --> 01:42:49,500
In ta čas, naredimo int argc,
niz argv, in s svojimi nosilci

2003
01:42:49,500 --> 01:42:50,836
bi pomenilo, da je v matriki.

2004
01:42:50,836 --> 01:42:52,460
In potem mi pač preverjanje razumnosti.

2005
01:42:52,460 --> 01:42:56,640
Tokrat, če argc ne
enako 2, potem veš kaj?

2006
01:42:56,640 --> 01:42:57,520
Pozabi.

2007
01:42:57,520 --> 01:43:03,170
Bom rekel, da, hej, uporabnik,
ste manjka argument ukazne vrstice

2008
01:43:03,170 --> 01:43:04,210
poševnica nazaj n.

2009
01:43:04,210 --> 01:43:05,230
>> In potem to je to.

2010
01:43:05,230 --> 01:43:06,130
Hočem, da zaprete.

2011
01:43:06,130 --> 01:43:11,030
Bom preemptively,
in prezgodaj res, vrnitev

2012
01:43:11,030 --> 01:43:12,810
nekaj drugega kot število 1.

2013
01:43:12,810 --> 01:43:15,360
Go, da vrednosti za prvo
napaka, ki se lahko zgodi je 1.

2014
01:43:15,360 --> 01:43:17,860
Če imate kakšna druga napačna
stanje, ki se lahko pojavijo,

2015
01:43:17,860 --> 01:43:21,390
bi lahko rekli vrnitev 2 ali vrne 3, ali
morda celo negativna 1 ali negativno 2.

2016
01:43:21,390 --> 01:43:23,750
>> To so le izhodne kode
da so na splošno

2017
01:43:23,750 --> 01:43:27,770
uporaben le za programer ali
Podjetje, ki je plovba programsko opremo.

2018
01:43:27,770 --> 01:43:30,500
Toda dejstvo, da je
ne 0 je tisto, kar je pomembno.

2019
01:43:30,500 --> 01:43:34,310
Torej, če je v tem programu, želim
zagotoviti, da ta program le

2020
01:43:34,310 --> 01:43:38,190
deluje, če me uporabnik vnese
s štetjem argument dveh,

2021
01:43:38,190 --> 01:43:42,880
ime programa, in nekatere druge
beseda, lahko uveljavljajo toliko, kot sledi,

2022
01:43:42,880 --> 01:43:46,110
kričati na uporabnika z printf pregovor,
manjka argument ukazne vrstice,

2023
01:43:46,110 --> 01:43:46,970
vrne 1.

2024
01:43:46,970 --> 01:43:49,940
To bo samo takoj
zaprete program.

2025
01:43:49,940 --> 01:43:55,840
>> Samo če argc enak 2 bomo dol
Tukaj, na kateri točki bom povedal,

2026
01:43:55,840 --> 01:44:00,410
zdravo odstotkov s, poševnica nazaj n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Z drugimi besedami, sem
ne bo po argv 0,

2028
01:44:03,827 --> 01:44:05,410
ki je samo ime programa.

2029
01:44:05,410 --> 01:44:09,450
Želim natisniti zdravo, vejica,
druga beseda, da človek vnesli.

2030
01:44:09,450 --> 01:44:12,580
In v tem primeru odvisna
linija 13, vse je dobro.

2031
01:44:12,580 --> 01:44:15,920
>> Vem, da je argc 2
logično iz tega programa.

2032
01:44:15,920 --> 01:44:17,770
Bom, da gredo naprej in vrne 0.

2033
01:44:17,770 --> 01:44:21,230
Naj omenim, da ne pozabite, da
to velja Scratch kot dobro.

2034
01:44:21,230 --> 01:44:24,760
>> Logično je, da lahko to storite
in zajame te vrstice

2035
01:44:24,760 --> 01:44:27,020
kode v tej določbi drugega tukaj.

2036
01:44:27,020 --> 01:44:29,420
Ampak to je nekako
nepotrebnem Feed svojo kodo.

2037
01:44:29,420 --> 01:44:31,800
In želim, da bi super
jasno, da ni važno kaj,

2038
01:44:31,800 --> 01:44:34,670
privzeto, zdravo
kaj bo dobil natisnjen,

2039
01:44:34,670 --> 01:44:36,050
dokler uporabnik sodeluje.

2040
01:44:36,050 --> 01:44:39,360
>> Torej, to je zelo pogosta uporaba
pogoj, samo če

2041
01:44:39,360 --> 01:44:41,870
ujeti nekaj napačna
stanje, nato pa izhod.

2042
01:44:41,870 --> 01:44:45,690
In potem, tako dolgo je vse
dobro, ne imeti drugega,

2043
01:44:45,690 --> 01:44:48,060
ampak samo še kodo
zunaj, da če, ker je to

2044
01:44:48,060 --> 01:44:51,060
enakovredni v tem
poseben primer, logično.

2045
01:44:51,060 --> 01:44:54,480
Tako da sem se vračajo 0, samo da bi
izrecno pomeni, je vse v redu.

2046
01:44:54,480 --> 01:44:58,480
>> Če bi izpusti vrnitev 0, bi bilo
samodejno domneva zame.

2047
01:44:58,480 --> 01:45:00,890
Toda zdaj, ko sem sem se vračajo
ena vsaj tem primeru

2048
01:45:00,890 --> 01:45:04,940
Bom, za dobro mero in
jasnost, vrne 0 v tem primeru.

2049
01:45:04,940 --> 01:45:09,690
Torej, zdaj pa grem naprej in da izhod,
ki je odlična segue samo oditi.

2050
01:45:09,690 --> 01:45:14,401
>> Vendar se izhod, in pusti me
naprej in to ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
In program vpil name,
manjka ukazno vrstico argumenta.

2052
01:45:16,900 --> 01:45:18,120
OK, naj sodelujejo.

2053
01:45:18,120 --> 01:45:23,810
>> Naj mi namesto storiti ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
In zdaj pravi, zdravo David.

2055
01:45:25,190 --> 01:45:27,300
In ti običajno ne bi videli tega.

2056
01:45:27,300 --> 01:45:30,650
>> Vendar se izkaže, da obstaja
poseben način v Linux dejansko videli

2057
01:45:30,650 --> 01:45:34,470
s tem, kar izhodna koda program izstopilo.

2058
01:45:34,470 --> 01:45:37,184
Včasih v grafični
svet kot Mac OS ali Windows,

2059
01:45:37,184 --> 01:45:40,100
vidiš samo te številke, ko an
pojavi sporočilo o napaki na zaslonu

2060
01:45:40,100 --> 01:45:41,940
in programer
prikazuje to številko.

2061
01:45:41,940 --> 01:45:44,773
Toda, če želite videti, kaj je napaka
Sporočilo je, da lahko to storite here--

2062
01:45:44,773 --> 01:45:48,100
tako ./exit, Enter, print
manjka ukazno vrstico argumenta.

2063
01:45:48,100 --> 01:45:54,590
>> Če bi sedaj naredil echo $ ?, ki je
smešno Grobni videti.

2064
01:45:54,590 --> 01:45:56,590
Toda $?

2065
01:45:56,590 --> 01:45:59,220
je čarobno zaklinjanje
ki pravi, hej, računalnik,

2066
01:45:59,220 --> 01:46:01,900
povej mi, kaj je prejšnji
izhodna koda programa je bilo.

2067
01:46:01,900 --> 01:46:03,410
In sem zadeti nastopiti.

2068
01:46:03,410 --> 01:46:07,520
Vidim 1, ker to je tisto, kar sem
povedal svojo glavno funkcijo, da se vrnejo.

2069
01:46:07,520 --> 01:46:12,310
>> Medtem, če naredim ./exit Davida,
in pritisnite tipko Enter, vidim, zdravo Davida.

2070
01:46:12,310 --> 01:46:16,800
In če bi zdaj naredil echo $ ?, vidim zdravo 0.

2071
01:46:16,800 --> 01:46:19,080
In tako bo to dejansko
biti dragocene informacije

2072
01:46:19,080 --> 01:46:23,420
V okviru razhroščevalniku, ni tako
toliko, da si je človek, bi skrbi.

2073
01:46:23,420 --> 01:46:26,060
Toda razhroščevalnik in drugi
Programi bomo uporabili ta semester

2074
01:46:26,060 --> 01:46:29,420
pogosto pogled na to številko,
čeprav je to nekako skrit

2075
01:46:29,420 --> 01:46:32,780
razen če si za to, da se
ugotoviti, ali program je ali ni

2076
01:46:32,780 --> 01:46:37,050
izvedba je bila pravilna ali napačna.

2077
01:46:37,050 --> 01:46:40,450
>> In zato, da nas pripelje do
To ob koncu dneva.

2078
01:46:40,450 --> 01:46:43,917
Danes smo začeli z opazovanjem
odpravljanje napak, in posledično pri teku

2079
01:46:43,917 --> 01:46:46,750
Sam in nato bolj zanimivo,
tehnično pod pokrovom

2080
01:46:46,750 --> 01:46:49,490
kaj so strune, ki je trajala
teden smo pravkar vzel za samoumevno,

2081
01:46:49,490 --> 01:46:51,900
in jih prav gotovo vzel
za samoumevno v Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Nato smo pogledali, kako lahko dostopate
posameznih znakov v nizu,

2083
01:46:56,040 --> 01:47:00,310
in potem spet vzel višjo raven
pogled na stvari, ki je videti, kako well--

2084
01:47:00,310 --> 01:47:04,226
Če želimo, da se na individualni
Elementi v seznamu podobno strukturo,

2085
01:47:04,226 --> 01:47:05,850
ne moremo narediti s številnimi strune?

2086
01:47:05,850 --> 01:47:08,050
In bomo lahko z argumenti ukazne vrstice.

2087
01:47:08,050 --> 01:47:12,800
Toda ta slika tu le iz škatle
je demonstrativen tega splošnega ideje

2088
01:47:12,800 --> 01:47:14,451
za array, ali na seznamu, ali vektor.

2089
01:47:14,451 --> 01:47:16,450
In glede na
kontekst, vse te besede

2090
01:47:16,450 --> 01:47:17,880
pomeni nekoliko drugačne stvari.

2091
01:47:17,880 --> 01:47:20,060
Torej, v C, bomo le
govoriti o matrike.

2092
01:47:20,060 --> 01:47:23,840
In množica je kos
spomina, vsak od njih pa je

2093
01:47:23,840 --> 01:47:27,720
elementi so sosednje, nazaj,
nazaj, nazaj, na hrbet.

2094
01:47:27,720 --> 01:47:31,970
>> In ti elementi so, na splošno,
istega tipa podatkov, karakter,

2095
01:47:31,970 --> 01:47:35,966
znak, znak, znak, ali
niz, niz, niz, niz, ali int

2096
01:47:35,966 --> 01:47:38,600
int, int, karkoli že je
poskušamo trgovini.

2097
01:47:38,600 --> 01:47:42,540
Vendar ob koncu dneva, to je
kako izgleda konceptualno.

2098
01:47:42,540 --> 01:47:44,530
Ste ob vašem
pomnilnik ali RAM računalnika.

2099
01:47:44,530 --> 01:47:48,590
In ste ga izločijo v
enako velika polja, ki so vse

2100
01:47:48,590 --> 01:47:50,920
so nazaj, nazaj, da
nazaj, nazaj na ta način.

2101
01:47:50,920 --> 01:47:53,200
>> In kaj je lepo o
ta ideja, in dejstvo,

2102
01:47:53,200 --> 01:47:58,580
da lahko izrazimo vrednosti na ta način
s prvim naših podatkovnih struktur

2103
01:47:58,580 --> 01:48:02,520
v razredu, pomeni, da lahko začnemo
za reševanje problemov s kodo

2104
01:48:02,520 --> 01:48:04,079
ki je prišel tako intuitivno v 0. tednu.

2105
01:48:04,079 --> 01:48:05,870
Boste opozarjajo na telefon
Knjiga primer, kjer

2106
01:48:05,870 --> 01:48:09,110
smo uporabili deli in vladaj,
ali binarno iskanje,

2107
01:48:09,110 --> 01:48:13,220
odbirati skozi celotno
kup imen in številk.

2108
01:48:13,220 --> 01:48:18,220
Vendar smo predpostavili, odpoklic, da je ta
imenik je že razporejene,

2109
01:48:18,220 --> 01:48:21,630
da drug ni nekdo že
Mislil out-- dal seznam imen

2110
01:48:21,630 --> 01:48:24,430
in numbers-- kako jih po abecedi.

2111
01:48:24,430 --> 01:48:26,950
In zdaj, v C smo,
Tudi imajo sposobnost

2112
01:48:26,950 --> 01:48:30,290
postaviti stvari, ne
fizično v imeniku

2113
01:48:30,290 --> 01:48:34,220
vendar praktično v računalnik je
spomin, bomo naslednji teden

2114
01:48:34,220 --> 01:48:38,470
spet uvesti this-- prvi
naših podatkovnih struktur v za array--

2115
01:48:38,470 --> 01:48:43,530
vendar je še pomembneje, dejansko računalnik
znanost algoritmi izvajajo

2116
01:48:43,530 --> 01:48:47,720
kodo, s katero lahko shranite
Podatki v strukturah, kot je ta,

2117
01:48:47,720 --> 01:48:50,730
in nato začne manipulirati, in
dejansko reševanje problemov z njim,

2118
01:48:50,730 --> 01:48:53,570
in graditi na vrhu, da,
na koncu, programi v C,

2119
01:48:53,570 --> 01:48:56,730
v Python, v JavaScript,
poizvedovanju po podatkovnih zbirkah z SQL?

2120
01:48:56,730 --> 01:48:59,980
>> In bomo videli, da je vse to
različne ideje povezujejo.

2121
01:48:59,980 --> 01:49:04,100
Ampak za zdaj, se spomni, da je
domene, ki smo uvedli danes

2122
01:49:04,100 --> 01:49:06,920
je to stvar tukaj, in
svet kriptografije.

2123
01:49:06,920 --> 01:49:11,200
In med vas se naslednjih težav
bo rešilo je umetnost kriptografiji

2124
01:49:11,200 --> 01:49:13,630
kodiranja in de-kodiranja
Informacije in šifriranje

2125
01:49:13,630 --> 01:49:15,930
in dešifriranja besedilo,
in ob predpostavki, da na koncu

2126
01:49:15,930 --> 01:49:18,970
da zdaj veš, kaj
je pod pokrovom

2127
01:49:18,970 --> 01:49:21,860
tako da, ko boste videli, ali prejmete
sporočilo, kot je ta, vas

2128
01:49:21,860 --> 01:49:24,060
sami lahko dešifrirati.

2129
01:49:24,060 --> 01:49:26,740
Vse to in še več naslednjič.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO PREDVAJANJE]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Pravkar prispel.

2133
01:49:32,970 --> 01:49:35,146
Bom šel obisk
njegov kolegij profesor.

2134
01:49:35,146 --> 01:49:37,611
Ja.

2135
01:49:37,611 --> 01:49:40,080
Hi.

2136
01:49:40,080 --> 01:49:40,660
To je ti.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Počakajte!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Poskušam ugotoviti
kaj se je zgodilo s tabo.

2142
01:49:56,060 --> 01:49:58,130
Prosimo, bi kaj pomagalo.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Bili ste njegov kolegij
cimra, niso bili vi?

2145
01:50:08,354 --> 01:50:10,770
Tam ste bili z njim, ko
je končal projekt CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [GLASBA]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -To Je CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Obožujem ta kraj.

2152
01:50:44,770 --> 01:50:45,854
>> -Pojej.

2153
01:50:45,854 --> 01:50:47,020
Gremo iz poslovanja.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END PREDVAJANJE]

