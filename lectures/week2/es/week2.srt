1
00:00:00,000 --> 00:00:02,970
>> [REPRODUCIENDO MÚSICA]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN: Está bien.

4
00:00:15,700 --> 00:00:18,832
Esto es CS50 y esto
es el inicio de la Semana 2.

5
00:00:18,832 --> 00:00:21,040
Y te recuerdo que durante
el último par de semanas,

6
00:00:21,040 --> 00:00:24,490
hemos sido la introducción de la computadora
la ciencia y, a su vez, la programación.

7
00:00:24,490 --> 00:00:27,640
>> Y empezamos la historia por medio de
Scratch, que lenguaje gráfico

8
00:00:27,640 --> 00:00:28,990
del Laboratorio de Medios del MIT.

9
00:00:28,990 --> 00:00:30,780
Y luego, más recientemente,
la semana pasada, ¿verdad

10
00:00:30,780 --> 00:00:34,450
introducir un higher-- una
lenguaje de bajo nivel conocido

11
00:00:34,450 --> 00:00:36,770
como C, algo que es puramente textual.

12
00:00:36,770 --> 00:00:39,440
Y, de hecho, la última vez que
explorado dentro de ese contexto

13
00:00:39,440 --> 00:00:40,450
una serie de conceptos.

14
00:00:40,450 --> 00:00:43,010
>> Esto, recuerdo, fue el
primer programa miramos.

15
00:00:43,010 --> 00:00:45,710
Y este programa, simplemente,
imprime, "hola, mundo".

16
00:00:45,710 --> 00:00:47,730
Pero hay tanto
magia aparente pasando.

17
00:00:47,730 --> 00:00:51,460
Hay esta #include
con estos soportes de ángulo.

18
00:00:51,460 --> 00:00:52,170
Hay int.

19
00:00:52,170 --> 00:00:53,020
Hay (void).

20
00:00:53,020 --> 00:00:56,330
Hay paréntesis, corchetes,
punto y coma, y ​​mucho más.

21
00:00:56,330 --> 00:00:58,480
>> Y así, recordar que
introdujimos los arañazos

22
00:00:58,480 --> 00:01:02,110
para que pudiéramos, a ser posible, ver más allá
que la sintaxis, las cosas que en realidad no es

23
00:01:02,110 --> 00:01:04,590
todo lo que intelectualmente
interesante, pero desde el principio

24
00:01:04,590 --> 00:01:07,700
es, en absoluto, un poco complicado
para envolver su mente alrededor.

25
00:01:07,700 --> 00:01:10,860
Y, de hecho, uno de los más comunes
las cosas desde el principio en una clase de programación,

26
00:01:10,860 --> 00:01:13,443
especialmente para los menos
cómodo y sentirse frustrado por

27
00:01:13,443 --> 00:01:17,460
y disparado por cierto sintáctica
errores, por no hablar de los errores lógicos.

28
00:01:17,460 --> 00:01:19,800
Y así entre nuestros objetivos
hoy en día, de hecho, la voluntad

29
00:01:19,800 --> 00:01:23,280
ser para equiparlo con un poco
técnicas de resolución de problemas para saber cómo

30
00:01:23,280 --> 00:01:26,705
para resolver mejor los problemas propios
en forma de depuración.

31
00:01:26,705 --> 00:01:29,330
Y como se recordará, también, que el
ambiente que introdujimos

32
00:01:29,330 --> 00:01:31,780
última vez que se llama CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Este es un software basado en web que
Le permite programar en la nube,

34
00:01:34,850 --> 00:01:38,450
por así decirlo, mientras se mantiene la totalidad de su
archivos juntos, ya que nuevamente será hoy.

35
00:01:38,450 --> 00:01:41,480
Y recordar que nos
revisited estos temas aquí,

36
00:01:41,480 --> 00:01:44,480
entre ellos, las funciones y bucles, y
variables y expresiones booleanas,

37
00:01:44,480 --> 00:01:45,110
y condiciones.

38
00:01:45,110 --> 00:01:49,190
Y en realidad un poco más que nosotros
traducido del mundo de los arañazos

39
00:01:49,190 --> 00:01:50,800
al mundo de la C.

40
00:01:50,800 --> 00:01:53,220
>> Pero la construcción fundamental
bloques, por así decirlo,

41
00:01:53,220 --> 00:01:55,150
eran realmente sigue siendo el mismo la semana pasada.

42
00:01:55,150 --> 00:01:57,900
De hecho, en realidad sólo tuvimos una
diferentes pieza del rompecabezas, si se quiere.

43
00:01:57,900 --> 00:02:00,300
En lugar de que púrpura
guardar bloque, que en vez

44
00:02:00,300 --> 00:02:02,940
había printf, que es
esta función en C que

45
00:02:02,940 --> 00:02:05,890
le permite imprimir algo
y el formato de la pantalla.

46
00:02:05,890 --> 00:02:07,950
Introdujimos el CS50
Biblioteca, donde se

47
00:02:07,950 --> 00:02:11,420
tienen ahora a su disposición get_char,
y get_int, y get_string,

48
00:02:11,420 --> 00:02:14,610
y algunas otras funciones como
así, a través del cual se puede obtener de entrada

49
00:02:14,610 --> 00:02:16,260
de propio teclado del usuario.

50
00:02:16,260 --> 00:02:20,640
Y también echamos un vistazo a las cosas
como estas: bool, y la carbonilla,

51
00:02:20,640 --> 00:02:22,490
y el doble, flotador,
int, string LONG_LONG.

52
00:02:22,490 --> 00:02:25,170
Y hay incluso otros tipos de datos en C.

53
00:02:25,170 --> 00:02:28,560
>> En otras palabras, cuando se declara
una variable para almacenar algún valor,

54
00:02:28,560 --> 00:02:32,600
o cuando se implementa una función
que devuelve algún valor,

55
00:02:32,600 --> 00:02:35,290
puede especificar qué
tipo de valor que es.

56
00:02:35,290 --> 00:02:37,310
Es una cadena, como una
secuencia de caracteres?

57
00:02:37,310 --> 00:02:39,490
¿Es un número, como un entero?

58
00:02:39,490 --> 00:02:41,390
¿Es un punto flotante
valor, o similar?

59
00:02:41,390 --> 00:02:46,180
Así que en C, a diferencia de los arañazos, que en realidad
comenzó a especificar qué tipo de datos

60
00:02:46,180 --> 00:02:48,330
estábamos regresando o el uso.

61
00:02:48,330 --> 00:02:51,910
>> Pero, por supuesto, también nos encontramos con
algunos límites fundamentales de la computación.

62
00:02:51,910 --> 00:02:54,100
Y en particular,
este lenguaje C, el recuerdo

63
00:02:54,100 --> 00:02:57,070
que nos dimos un vistazo a
desbordamiento de enteros, la realidad

64
00:02:57,070 --> 00:03:00,460
que si sólo tiene una
cantidad finita de memoria

65
00:03:00,460 --> 00:03:04,600
o, específicamente, un número finito
de bits, sólo se puede contar tan alto.

66
00:03:04,600 --> 00:03:08,460
Y así nos fijamos en este ejemplo aquí
por el que un contador en un avión,,

67
00:03:08,460 --> 00:03:13,510
En realidad, si se ejecuta el tiempo suficiente se
desbordarse y resultar en un software

68
00:03:13,510 --> 00:03:15,560
un error potencial físico real.

69
00:03:15,560 --> 00:03:18,600
>> También nos fijamos en flotante
punto de imprecisión, la realidad

70
00:03:18,600 --> 00:03:22,280
que con sólo un número finito
de bits, ya sea 32 o 64,

71
00:03:22,280 --> 00:03:27,330
sólo puede especificar tantos números
después de un punto decimal, tras lo cual se

72
00:03:27,330 --> 00:03:29,110
comenzar a tener imprecisa.

73
00:03:29,110 --> 00:03:32,360
Así, por ejemplo, un tercio en el
mundo aquí, en nuestro mundo humano,

74
00:03:32,360 --> 00:03:35,360
sabemos que es sólo un número infinito
de 3s después del punto decimal.

75
00:03:35,360 --> 00:03:38,820
Sin embargo, un equipo no puede necesariamente
representar un número infinito de números

76
00:03:38,820 --> 00:03:42,590
si únicamente permite que algunos
cantidad finita de información.

77
00:03:42,590 --> 00:03:45,900
>> Así que no sólo tenemos que equipar
con mayor poder en términos

78
00:03:45,900 --> 00:03:49,280
de cómo puede expresarse en
un teclado en términos de programación,

79
00:03:49,280 --> 00:03:51,430
También nos limitamos lo
en realidad se puede hacer.

80
00:03:51,430 --> 00:03:55,790
Y de hecho, los errores y los errores pueden
surgir de este tipo de cuestiones.

81
00:03:55,790 --> 00:03:59,900
Y, en efecto, uno de los temas de hoy
van a ser temas como la depuración

82
00:03:59,900 --> 00:04:03,699
y en realidad mirando debajo del capó
la forma en que se introdujeron las cosas la semana pasada

83
00:04:03,699 --> 00:04:05,490
están efectivamente en práctica
de manera que es mejor

84
00:04:05,490 --> 00:04:10,530
entender tanto las capacidades de las y
las limitaciones de un lenguaje como C

85
00:04:10,530 --> 00:04:14,770
>> Y de hecho, vamos a pelar las capas
de la más simple de estructura de datos,

86
00:04:14,770 --> 00:04:17,756
algo que se llama una matriz, la cual
De cero pasa a llamar una "lista".

87
00:04:17,756 --> 00:04:19,589
Es un poco
diferente en ese contexto.

88
00:04:19,589 --> 00:04:23,340
Y entonces también introduciremos una de las
primero de nuestros problemas específicos de dominio

89
00:04:23,340 --> 00:04:26,790
en CS50, el mundo de
criptografía, el arte de la aleatorización

90
00:04:26,790 --> 00:04:29,650
o en la información de cifrado por lo
que puede enviar mensajes secretos

91
00:04:29,650 --> 00:04:34,520
y decodificar mensajes secretos
entre dos personas, A y B.

92
00:04:34,520 --> 00:04:37,490
>> Así que antes de que la transición
a ese nuevo mundo,

93
00:04:37,490 --> 00:04:42,059
vamos a tratar de equiparlo con un poco
técnicas con las que se pueden eliminar

94
00:04:42,059 --> 00:04:43,850
o reducir al menos algunos
de las frustraciones

95
00:04:43,850 --> 00:04:46,630
que es probable que haya encontrado
durante la última semana solamente.

96
00:04:46,630 --> 00:04:50,830
De hecho, antes de que se tal-- algunos de
sus primeros problemas en C. Y las probabilidades son,

97
00:04:50,830 --> 00:04:54,010
Si eres como yo, la primera vez
intenta escribir un programa,

98
00:04:54,010 --> 00:04:57,330
incluso si usted piensa lógicamente
el programa es bastante simple,

99
00:04:57,330 --> 00:05:01,200
Es muy posible que golpear una pared, y
el compilador no va a cooperar.

100
00:05:01,200 --> 00:05:03,940
Hacer o no va Clang
para hacer realidad su hacer una oferta.

101
00:05:03,940 --> 00:05:05,450
>> Y por qué podría ser?

102
00:05:05,450 --> 00:05:07,950
Bueno, vamos a echar un vistazo a,
tal vez, un programa sencillo.

103
00:05:07,950 --> 00:05:11,190
Voy a seguir adelante y guardar esto en
un archivo llamado deliberadamente buggy0.c,

104
00:05:11,190 --> 00:05:13,590
porque sé que a
viciado de antemano.

105
00:05:13,590 --> 00:05:17,400
Pero podría no darse cuenta de que si esto
es la primera o segunda o tercera programa

106
00:05:17,400 --> 00:05:18,830
que en realidad estoy haciendo a mí mismo.

107
00:05:18,830 --> 00:05:23,820
Así que voy a seguir adelante y
escribir a máquina, int main (void).

108
00:05:23,820 --> 00:05:28,130
Y luego dentro de mis llaves,
una muy familiar ( "hola, mundo--

109
00:05:28,130 --> 00:05:30,980
barra invertida, n ") - y un punto y coma.

110
00:05:30,980 --> 00:05:32,360
>> He guardado el archivo.

111
00:05:32,360 --> 00:05:34,850
Ahora voy a bajar
a mi ventana de terminal

112
00:05:34,850 --> 00:05:40,340
y el tipo de maquillaje buggy0, porque, de nuevo,
el nombre del archivo de hoy es buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Así que escribo hacer buggy0, Intro.

114
00:05:43,660 --> 00:05:48,200
>> Y, oh, Dios, recordar de la última vez
que no hay mensajes de error es una buena cosa.

115
00:05:48,200 --> 00:05:49,740
Así que no hay salida es una buena cosa.

116
00:05:49,740 --> 00:05:52,920
Pero aquí tengo claramente
cierto número de errores.

117
00:05:52,920 --> 00:05:56,470
>> Así que la primera línea de salida
después de escribir hace buggy0, recuerdo,

118
00:05:56,470 --> 00:05:59,540
se emite bastante detallado de Sonido metálico.

119
00:05:59,540 --> 00:06:02,067
Debajo del capó,
IDE CS50 está configurado

120
00:06:02,067 --> 00:06:04,150
utilizar un montón de
opciones con este compilador

121
00:06:04,150 --> 00:06:05,941
de modo que usted no tiene
pensar en ellos.

122
00:06:05,941 --> 00:06:08,840
Y eso es todo lo que la primera línea de
medios que se inicia con Clang.

123
00:06:08,840 --> 00:06:11,720
>> Pero después de eso, los problemas
comienzan a hacer su aparición.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c en la línea 3, carácter
5, hay un gran error, rojo.

125
00:06:17,390 --> 00:06:18,380
¿Que es eso?

126
00:06:18,380 --> 00:06:23,562
Declarando implícitamente función de biblioteca
printf con el tipo int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Es decir, es muy rápido
se pone muy arcano.

129
00:06:28,379 --> 00:06:30,170
Y, desde luego, en un primer momento
vista, que no lo haría

130
00:06:30,170 --> 00:06:32,380
espero que lo entienda el
totalidad de ese mensaje.

131
00:06:32,380 --> 00:06:34,213
Y lo que una de las lecciones
hoy va

132
00:06:34,213 --> 00:06:36,919
a ser tratar de notar
patrones, o cosas similares,

133
00:06:36,919 --> 00:06:38,960
a los errores que pueda tener
encontrado en el pasado.

134
00:06:38,960 --> 00:06:41,335
Así que vamos a desmenuzar solamente
esas palabras que parecen familiares.

135
00:06:41,335 --> 00:06:44,290
El grande, rojo de error es claramente
simbólico de que algo anda mal.

136
00:06:44,290 --> 00:06:47,940
>> declarando implícitamente
printf función de biblioteca.

137
00:06:47,940 --> 00:06:51,680
Así que incluso si yo no entiendo muy bien lo
declarando implícitamente función de biblioteca

138
00:06:51,680 --> 00:06:54,900
medios, el problema seguramente
se refiere a printf de alguna manera.

139
00:06:54,900 --> 00:06:59,130
Y la fuente de esa cuestión
tiene que ver con lo que se declara.

140
00:06:59,130 --> 00:07:02,440
>> La declaración de una función es
mencionar que para la primera vez.

141
00:07:02,440 --> 00:07:06,210
Y se utilizó la terminología de la semana pasada
de declarar el prototipo de una función,

142
00:07:06,210 --> 00:07:11,860
ya sea con una línea en la parte superior de su
archivo o incorporada a un fichero de cabecera llamada.

143
00:07:11,860 --> 00:07:15,300
Y en lo que hizo que decimos archivo
la semana pasada que printf es cita,

144
00:07:15,300 --> 00:07:17,080
Fin de la cita, declarada?

145
00:07:17,080 --> 00:07:20,950
¿En qué archivo es su prototipo?

146
00:07:20,950 --> 00:07:24,640
>> Así que si usted recuerda, la primera cosa que me
con tipo, casi todos los programas última vez--

147
00:07:24,640 --> 00:07:30,790
y accidentalmente hace un momento comenzó
escribiendo myself-- era éste aquí--

148
00:07:30,790 --> 00:07:38,630
hash-- # include <stio-- de
entrada / h output-- punto Y, en efecto,

149
00:07:38,630 --> 00:07:41,860
si ahora puedo guardar este archivo, voy
para seguir adelante y limpiar mi pantalla,

150
00:07:41,860 --> 00:07:44,740
que se puede hacer escribiendo
Claro, o puede mantener control L,

151
00:07:44,740 --> 00:07:47,680
sólo para aclarar la ventana de terminal
sólo para eliminar algunos obstáculos.

152
00:07:47,680 --> 00:07:51,370
>> Voy a seguir adelante y
Tipo de re-make buggy0, Intro.

153
00:07:51,370 --> 00:07:53,790
Y listo, todavía veo que
comando largo de Sonido metálico,

154
00:07:53,790 --> 00:07:55,470
pero no hay ningún mensaje de error esta vez.

155
00:07:55,470 --> 00:07:58,800
Y de hecho, si lo hago ./buggy0,
como la última vez,

156
00:07:58,800 --> 00:08:01,860
donde los puntos que esto significa
directorio, Slash sólo significa,

157
00:08:01,860 --> 00:08:05,040
aquí viene el nombre del programa y
que el nombre del programa es buggy0,

158
00:08:05,040 --> 00:08:07,340
Introducir, "hola, mundo".

159
00:08:07,340 --> 00:08:09,440
>> Ahora, ¿cómo podría tener
esta solución obtenida

160
00:08:09,440 --> 00:08:12,017
sin necesariamente
reconociendo tantas palabras

161
00:08:12,017 --> 00:08:14,350
como lo hice, sin duda, tener
este hecho durante tantos años?

162
00:08:14,350 --> 00:08:18,720
Bueno, darse cuenta por el primer problema
conjunto, le presentamos un comando

163
00:08:18,720 --> 00:08:21,175
que el propio personal del CS50
escribió llamada help50.

164
00:08:21,175 --> 00:08:24,300
Y de hecho, lo hace C pliego de condiciones de
el problema establecido en cuanto a cómo usar esto.

165
00:08:24,300 --> 00:08:27,210
>> Pero help50 es esencialmente
un programa que el personal del CS50

166
00:08:27,210 --> 00:08:30,850
escribió que le permite ejecutar
un comando o ejecutar un programa,

167
00:08:30,850 --> 00:08:36,169
y si usted no entiende su
de salida, pase a su salida a help50,

168
00:08:36,169 --> 00:08:38,890
en cuyo punto el software
que el personal del supuesto escribió

169
00:08:38,890 --> 00:08:42,429
se verá en la salida de su programa
línea por línea, carácter por carácter.

170
00:08:42,429 --> 00:08:46,000
Y si nosotros, el personal, reconoce el
mensaje de error que está experimentando,

171
00:08:46,000 --> 00:08:50,580
vamos a tratar de provocarlo con alguna
preguntas retóricas, con algunos consejos,

172
00:08:50,580 --> 00:08:54,890
al igual que un TF o una CA o yo
haría en persona en horario de oficina.

173
00:08:54,890 --> 00:08:58,320
>> Así que mira a help50 si no lo hace
necesariamente reconocer un problema.

174
00:08:58,320 --> 00:09:00,790
Pero no confíe en él
demasiado como una muleta.

175
00:09:00,790 --> 00:09:03,990
Desde luego tratar de comprender su
de salida y luego aprender de ella

176
00:09:03,990 --> 00:09:07,571
de modo que lo hacen sólo una vez o dos veces
help50 vez se ha quedado a un error particular

177
00:09:07,571 --> 00:09:08,070
mensaje.

178
00:09:08,070 --> 00:09:10,660
Después de eso, usted debe estar
mejor a ti mismo equipado

179
00:09:10,660 --> 00:09:13,180
para averiguar lo que realmente es.

180
00:09:13,180 --> 00:09:14,350
>> Vamos a hacer otra aquí.

181
00:09:14,350 --> 00:09:20,410
Déjame ir por delante, y en otro
archivo que llamaremos este buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Y en este archivo que soy
ir a deliberately--

183
00:09:23,110 --> 00:09:26,330
pero pretender que no lo hago
entiendo lo error que he cometido.

184
00:09:26,330 --> 00:09:31,420
>> Voy a seguir adelante y hacer esto-
# include, ya que he

185
00:09:31,420 --> 00:09:33,660
aprendido la lección de hace un momento.

186
00:09:33,660 --> 00:09:36,220
Int principal (void), como antes.

187
00:09:36,220 --> 00:09:40,880
Y entonces aquí voy
hacer cuerdas s - get_string.

188
00:09:40,880 --> 00:09:43,770
Y recordar la última vez que
este medio, bueno, equipo,

189
00:09:43,770 --> 00:09:48,280
dame una variable, lo llaman S y
hacer que el tipo de esa variable de una cadena

190
00:09:48,280 --> 00:09:50,150
por lo que puede almacenar una o más palabras en el mismo.

191
00:09:50,150 --> 00:09:52,191
>> Y luego en el de la derecha
lado del signo igual

192
00:09:52,191 --> 00:09:54,980
se get_string, que es una
función en la biblioteca CS50

193
00:09:54,980 --> 00:09:55,980
que hace exactamente eso.

194
00:09:55,980 --> 00:09:59,740
Se pone una función y luego
manos de derecha a izquierda.

195
00:09:59,740 --> 00:10:02,670
Por lo que este signo igual no significa
"Iguales" como podríamos pensar en matemáticas.

196
00:10:02,670 --> 00:10:04,750
Esto significa que la asignación de derecha a izquierda.

197
00:10:04,750 --> 00:10:09,640
Así que esto significa, tomar la cadena de
el usuario y la almacena en el interior del s.

198
00:10:09,640 --> 00:10:10,460
>> Ahora vamos a utilizar la misma.

199
00:10:10,460 --> 00:10:13,820
Déjame ir adelante ahora y como segundo
línea, déjame ir por delante y decir "hola" -

200
00:10:13,820 --> 00:10:19,330
No "mundo", pero "Hola,% s--
que es nuestro marcador de posición, coma s,

201
00:10:19,330 --> 00:10:22,030
que es nuestra variable,
y luego un punto y coma.

202
00:10:22,030 --> 00:10:26,070
Así que si no me equivoco demasiado
aquí, esto se ve como código correcto.

203
00:10:26,070 --> 00:10:28,090
>> Y mis instintos son ahora para compilarlo.

204
00:10:28,090 --> 00:10:30,400
El archivo se llama buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Así que voy a hacer que buggy1, Intro.

206
00:10:33,770 --> 00:10:36,377
Y darn-it, si no hay
incluso más errores que antes.

207
00:10:36,377 --> 00:10:38,210
Es decir, hay más
Sería mensajes de error

208
00:10:38,210 --> 00:10:40,400
Parece que las líneas reales en este programa.

209
00:10:40,400 --> 00:10:42,730
>> Pero la comida para llevar es aquí,
incluso si usted está abrumado

210
00:10:42,730 --> 00:10:45,040
con dos o tres o
cuatro más mensajes de error,

211
00:10:45,040 --> 00:10:48,340
centrarse siempre en el mismo
primero de esos mensajes.

212
00:10:48,340 --> 00:10:52,220
En cuanto a la parte superior más uno,
desplazándose hacia atrás hasta que es necesario.

213
00:10:52,220 --> 00:10:53,930
Así que aquí he escrito maquillaje buggy1.

214
00:10:53,930 --> 00:10:55,700
Así es que la producción Clang como se esperaba.

215
00:10:55,700 --> 00:10:57,290
>> Y aquí está el primer error rojo.

216
00:10:57,290 --> 00:11:02,370
El uso del identificador no declarado
cadena, lo que quiero decir estándar en?

217
00:11:02,370 --> 00:11:04,260
Así que en estándar es de
en realidad otra cosa.

218
00:11:04,260 --> 00:11:06,240
Se refiere al usuario de
teclado, esencialmente.

219
00:11:06,240 --> 00:11:08,080
>> Pero eso no es lo que quería decir.

220
00:11:08,080 --> 00:11:11,770
Me refiero a la secuencia, y lo decía get_string.

221
00:11:11,770 --> 00:11:16,200
Entonces, ¿qué es lo que me
se olvidó de hacer esta vez?

222
00:11:16,200 --> 00:11:20,230
Lo que falta en esta ocasión?

223
00:11:20,230 --> 00:11:23,600
Tengo mi # include,
así que no tengo acceso a printf.

224
00:11:23,600 --> 00:11:26,090
>> Pero qué es lo que no tengo
el acceso a por el momento?

225
00:11:26,090 --> 00:11:29,420
Pues bien, al igual que la última vez,
Tengo que decirle al compilador

226
00:11:29,420 --> 00:11:31,691
CLANG lo que estas funciones son.

227
00:11:31,691 --> 00:11:33,940
Get_string no viene
con C. Y en particular, se

228
00:11:33,940 --> 00:11:38,160
no entra en el
archivo de cabecera, .

229
00:11:38,160 --> 00:11:40,770
En su lugar, se presenta en
algo que el personal escribió,

230
00:11:40,770 --> 00:11:44,176
que es un archivo diferente
nombrar pero bien llamado.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Así que simplemente añadiendo una línea
code-- de recuerdo de la última vez

233
00:11:50,861 --> 00:11:53,610
Clang que cuando se ejecuta, se va
para mirar mi parte superior de código a abajo,

234
00:11:53,610 --> 00:11:54,193
de izquierda a derecha.

235
00:11:54,193 --> 00:11:57,200
Se va a notar,
oh, que desea.

236
00:11:57,200 --> 00:11:59,900
Déjame ir y encontrar que,
siempre que sea en el servidor,

237
00:11:59,900 --> 00:12:03,090
copiar y pegar, en esencia,
en la parte superior de su propio archivo

238
00:12:03,090 --> 00:12:06,820
de manera que en este momento de la historia,
línea 1, el resto del programa

239
00:12:06,820 --> 00:12:11,651
puede, de hecho, utilizar cualquiera de las funciones
en la misma, entre ellos get_string.

240
00:12:11,651 --> 00:12:13,650
Así que voy a ignorar
el resto de los errores,

241
00:12:13,650 --> 00:12:17,190
porque, de hecho, sospecho que sólo
el primero de ellos en realidad importaba.

242
00:12:17,190 --> 00:12:20,780
Y voy a seguir adelante y volver a ejecutar,
después de guardar mi archivo que buggy1.

243
00:12:20,780 --> 00:12:22,580
Y listo, lo hizo el trabajo.

244
00:12:22,580 --> 00:12:29,200
Y si lo hago ./buggy1 y escriba, por
ejemplo, Zamyla, ahora obtendrá hola,

245
00:12:29,200 --> 00:12:32,000
Zamyla, en lugar de hola, mundo.

246
00:12:32,000 --> 00:12:32,550
>> Todo bien.

247
00:12:32,550 --> 00:12:35,890
Así que la comida para llevar aquí a continuación son para,
uno, tratar de recoger tanto como sea posible

248
00:12:35,890 --> 00:12:39,140
a partir de los mensajes de error por sí solas, mirando
En algunas de las palabras reconocibles.

249
00:12:39,140 --> 00:12:43,070
Aparte de eso, utilice por help50
el problema conjunto de especificaciones.

250
00:12:43,070 --> 00:12:46,500
Pero salvo eso, también, siempre se ven
en la parte superior de error solamente, al menos

251
00:12:46,500 --> 00:12:50,051
inicialmente, para ver qué información
que en realidad podría ceder.

252
00:12:50,051 --> 00:12:52,300
Pero resulta que hay
aún más funcionalidad integrada

253
00:12:52,300 --> 00:12:55,030
en la Biblioteca CS50 para ayudar
que desde el principio en el semestre

254
00:12:55,030 --> 00:12:57,580
y al comienzo de la programación
averiguar lo que va mal.

255
00:12:57,580 --> 00:12:59,840
Así que vamos a hacer aquí otro ejemplo.

256
00:12:59,840 --> 00:13:04,350
Voy a llamar a este buggy2, que,
de nuevo, va a ser defectuoso a cabo

257
00:13:04,350 --> 00:13:05,650
de la puerta, por diseño.

258
00:13:05,650 --> 00:13:09,980
>> Y voy a seguir adelante
y hacer # include.

259
00:13:09,980 --> 00:13:12,580
Y luego voy a hacer int main (void).

260
00:13:12,580 --> 00:13:14,840
Y entonces me voy a hacer un bucle.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i es menor que o igual a 10.

263
00:13:18,750 --> 00:13:24,260
i ++, y luego entre llaves, voy
imprimir sólo un símbolo hashtag aquí

264
00:13:24,260 --> 00:13:25,920
y un carácter de nueva línea.

265
00:13:25,920 --> 00:13:29,220
>> Así que mi intención con este
programa es, sencillamente,

266
00:13:29,220 --> 00:13:33,150
para repetir 10 veces
y en cada iteración

267
00:13:33,150 --> 00:13:35,260
de ese bucle cada vez
a través del ciclo,

268
00:13:35,260 --> 00:13:37,660
imprimir un hashtag,
un hashtag, un hashtag.

269
00:13:37,660 --> 00:13:40,480
Una línea por porque
tener la nueva línea allí.

270
00:13:40,480 --> 00:13:42,787
Y para recordar que la
lazo, por última semana--

271
00:13:42,787 --> 00:13:44,620
y obtendrá más
familiarizado con la sintaxis

272
00:13:44,620 --> 00:13:47,170
usándolo con la práctica
antes de esto me da long--

273
00:13:47,170 --> 00:13:49,740
una variable que se llama y lo establece en 0.

274
00:13:49,740 --> 00:13:52,650
>> Esto incrementa i en
cada iteración por 1.

275
00:13:52,650 --> 00:13:54,940
Así que va a 1 a 2 a 3.

276
00:13:54,940 --> 00:13:57,690
Y entonces esta condición en el
medio entre los puntos y comas

277
00:13:57,690 --> 00:14:03,010
consigue comprobado en cada iteración para hacer
Seguro que todavía estamos dentro del alcance.

278
00:14:03,010 --> 00:14:06,830
Por eso quiero repetir 10 veces, por lo que
tienen una especie de manera muy intuitiva solo

279
00:14:06,830 --> 00:14:09,070
puesto 10 como mi límite superior allí.

280
00:14:09,070 --> 00:14:14,310
>> Y, sin embargo, cuando ejecuto esto, después de
compilarlo con maquillaje buggy2--

281
00:14:14,310 --> 00:14:15,440
y se compila en Aceptar.

282
00:14:15,440 --> 00:14:17,980
Así que no tengo una
error de sintaxis en esta ocasión.

283
00:14:17,980 --> 00:14:20,940
Déjame ir por delante ahora
y ejecutar buggy2, Intro.

284
00:14:20,940 --> 00:14:22,620
Y ahora desplazarse hacia arriba.

285
00:14:22,620 --> 00:14:24,890
Y permítanme aumento
el tamaño de la ventana.

286
00:14:24,890 --> 00:14:33,720
>> Me parece que tienen 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Así que hay 11 hashtags, aunque
Pongo claramente 10 en el interior de este bucle.

288
00:14:38,891 --> 00:14:42,140
Ahora, algunos de ustedes podrían ver inmediatamente
lo que el error es debido a que, de hecho, esta

289
00:14:42,140 --> 00:14:43,720
No es un error muy difícil de hacer.

290
00:14:43,720 --> 00:14:46,070
Pero es muy comúnmente
hecho muy temprano.

291
00:14:46,070 --> 00:14:49,820
>> Lo que quiero señalar, sin embargo,
Es decir, cómo podría yo a resolver esto?

292
00:14:49,820 --> 00:14:52,300
Pues bien, resulta que
la Biblioteca CS50 viene

293
00:14:52,300 --> 00:14:55,380
no sólo con get_string y get_int
y get_float y otras funciones.

294
00:14:55,380 --> 00:14:59,980
También viene con una función especial
EPRINTF llamada, o, printf error.

295
00:14:59,980 --> 00:15:03,270
Y es que existe solamente para hacer
es un poco más fácil para usted

296
00:15:03,270 --> 00:15:06,310
al depurar el código para simplemente
imprimir un mensaje de error en la pantalla

297
00:15:06,310 --> 00:15:07,850
y saber de dónde vino.

298
00:15:07,850 --> 00:15:11,000
>> Así, por ejemplo, una cosa que podría
hacer aquí con esta función es esto-

299
00:15:11,000 --> 00:15:20,230
EPRINTF, y luego voy a seguir adelante
y decir que ahora es de% i, la barra invertida, n.

300
00:15:20,230 --> 00:15:22,330
Y voy a enchufar en el valor de i.

301
00:15:22,330 --> 00:15:25,400
Y en lo alto, ya que este
está en la Biblioteca CS50,

302
00:15:25,400 --> 00:15:27,580
Voy a seguir adelante
e incluir

303
00:15:27,580 --> 00:15:29,169
así que no tengo acceso a esta función.

304
00:15:29,169 --> 00:15:31,460
Pero vamos a considerar qué línea
9 se supone que deben hacer.

305
00:15:31,460 --> 00:15:32,670
Voy a borrar este tiempo.

306
00:15:32,670 --> 00:15:34,670
Esto no tiene nada que ver
con mi objetivo primordial.

307
00:15:34,670 --> 00:15:39,090
Pero EPRINTF, printf error, es sólo la intención
darme alguna información de diagnóstico.

308
00:15:39,090 --> 00:15:42,460
Cuando ejecuto mi programa, quiero
ver esto en la pantalla temporalmente

309
00:15:42,460 --> 00:15:44,550
que también acaba de entender
que esta pasando.

310
00:15:44,550 --> 00:15:47,330
>> Y, de hecho, en cada
iteración aquí de la línea 9

311
00:15:47,330 --> 00:15:49,260
Quiero ver, ¿cuál es el valor de i?

312
00:15:49,260 --> 00:15:50,290
¿Cuál es el valor de i?

313
00:15:50,290 --> 00:15:51,280
¿Cuál es el valor de i?

314
00:15:51,280 --> 00:15:55,650
Y, con suerte, sólo debe
ver ese mensaje, también, 10 veces.

315
00:15:55,650 --> 00:15:57,780
>> Así que permítanme seguir adelante y
recompilar mi programa,

316
00:15:57,780 --> 00:15:59,905
ya que tengo que hacer en cualquier momento
Hago un cambio. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Y ahora-- OK.

319
00:16:03,640 --> 00:16:04,820
Hay mucho más en juego.

320
00:16:04,820 --> 00:16:07,610
Así que permítanme desplazarse hacia arriba en
una ventana aún más grande.

321
00:16:07,610 --> 00:16:10,190
>> Y verá que cada uno de
la hashtags está imprimiendo.

322
00:16:10,190 --> 00:16:15,270
Pero entre cada uno de ellos es ahora esto
salida de diagnóstico el siguiente formato.

323
00:16:15,270 --> 00:16:17,960
El nombre de mi programa aquí es buggy2.

324
00:16:17,960 --> 00:16:20,432
El nombre del archivo es buggy2.c.

325
00:16:20,432 --> 00:16:24,080
El número de línea de la que
este fue impreso es la línea 9.

326
00:16:24,080 --> 00:16:27,500
Y luego a la derecha que es la
mensaje de error que estoy esperando.

327
00:16:27,500 --> 00:16:30,701
>> Y lo bueno de esto es que
Ahora no tengo que contar necesariamente

328
00:16:30,701 --> 00:16:32,200
en mi cabeza lo que mi programa está haciendo.

329
00:16:32,200 --> 00:16:34,240
Puedo ver que en el
primera iteración i es 0,

330
00:16:34,240 --> 00:16:39,420
luego 1, luego 2, luego 3, luego 4, a continuación,
5, a continuación, 6, a continuación, 7, a continuación, 8, 9 a continuación, a continuación,

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Así que espere un minuto.

333
00:16:42,050 --> 00:16:43,740
¿Que está pasando aqui?

334
00:16:43,740 --> 00:16:48,190
Todavía me parece estar contando
según lo previsto hasta 10.

335
00:16:48,190 --> 00:16:50,550
>> Pero ¿de dónde empiezo?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Así 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- el dedo 11

338
00:16:58,040 --> 00:16:59,990
es indicativo del problema.

339
00:16:59,990 --> 00:17:02,850
Me parece que han contado
incorrectamente en mi bucle.

340
00:17:02,850 --> 00:17:06,599
En lugar de ir 10 iteraciones,
Estoy empezando a 0,

341
00:17:06,599 --> 00:17:09,550
Estoy terminando en ya través de 10.

342
00:17:09,550 --> 00:17:12,030
Pero debido a que, como una computadora,
Estoy empezando a contar a 0,

343
00:17:12,030 --> 00:17:15,250
Debería estar contando hasta
a, pero no a través de, 10.

344
00:17:15,250 --> 00:17:18,510
>> Y así, la solución, que finalmente
dado cuenta de que aquí, es una de dos cosas.

345
00:17:18,510 --> 00:17:22,430
Podría decir simplemente muy
contar hasta menos de 10.

346
00:17:22,430 --> 00:17:27,260
Así 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, que es, de hecho, correcta,

347
00:17:27,260 --> 00:17:28,900
aunque suene un poco mal.

348
00:17:28,900 --> 00:17:35,070
O podría hacer menos que o igual
a 9, siempre y cuando empiezo a 0.

349
00:17:35,070 --> 00:17:40,056
O si realmente no le gusta eso,
puede contar hacia arriba a través de 10 pero empiezan en 1.

350
00:17:40,056 --> 00:17:41,680
Pero, de nuevo, esto no es tan común.

351
00:17:41,680 --> 00:17:43,977
En programming-- aunque
no tanto en Scratch--

352
00:17:43,977 --> 00:17:45,810
pero en la programación en
C y otros idiomas,

353
00:17:45,810 --> 00:17:47,670
como JavaScript y
Python y otros, es

354
00:17:47,670 --> 00:17:49,880
simplemente muy común para
nuestra discusión sobre binaria

355
00:17:49,880 --> 00:17:53,450
que acaba de empezar a contar en el
número más bajo que pueda, que es 0.

356
00:17:53,450 --> 00:17:53,950
Todo bien.

357
00:17:53,950 --> 00:17:55,160
Así que eso es EPRINTF.

358
00:17:55,160 --> 00:17:58,600
Y de nuevo, ahora que he descubierto mi
problema, y ​​lo voy a volver a 0

359
00:17:58,600 --> 00:18:01,470
a través de menos de 10, voy
para entrar y eliminar EPRINTF.

360
00:18:01,470 --> 00:18:04,580
>> No debería ser allí cuando
enviar mi código o enviar mi código

361
00:18:04,580 --> 00:18:05,800
o mostrarla a nadie más.

362
00:18:05,800 --> 00:18:07,980
Es realmente sólo la intención
para ser utilizadas temporalmente.

363
00:18:07,980 --> 00:18:11,650
Pero ahora me he fijado este
en particular problema también.

364
00:18:11,650 --> 00:18:16,780
>> Bueno, vamos a hacer un ejemplo más aquí
que voy a azotar encima de la siguiente manera.

365
00:18:16,780 --> 00:18:22,850
Voy a seguir adelante y
# include. $ 50

366
00:18:22,850 --> 00:18:25,580
Y voy a seguir adelante
y # include.

367
00:18:25,580 --> 00:18:29,030
>> Y voy a ahorrar
este archivo como buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Y voy a seguir adelante
y declarar int main (void).

369
00:18:31,740 --> 00:18:34,186
Y luego dentro de allí
Voy a hacer int i _ -

370
00:18:34,186 --> 00:18:36,435
Quiero poner en práctica un programa de
con un get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Esto no es una función que existe todavía.

373
00:18:40,770 --> 00:18:42,870
Así que vamos a poner en práctica
en un momento.

374
00:18:42,870 --> 00:18:45,541
Pero vamos a ver por qué
es con errores en la primera pasada.

375
00:18:45,541 --> 00:18:47,290
Y una vez que he recibido
un int del usuario,

376
00:18:47,290 --> 00:18:53,365
Yo sólo voy a imprimir% i es un negativo
número entero, la barra invertida, n, coma, i.

377
00:18:53,365 --> 00:18:55,240
En otras palabras, todo lo
desea que este programa para hacer

378
00:18:55,240 --> 00:18:58,000
se obtendrá una int negativa de
el usuario y luego imprima

379
00:18:58,000 --> 00:18:59,980
que tal y tal es un int negativo.

380
00:18:59,980 --> 00:19:02,080
>> Ahora necesito para implementar esta función.

381
00:19:02,080 --> 00:19:05,740
Así que más adelante en mi archivo, voy a ir
adelante y declarar una función llamada

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - y vamos a
volver a lo que significa una vez más que la línea

383
00:19:10,670 --> 00:19:18,790
en un moment-- int n; hacer-- do
la following-- printf n es :.

384
00:19:18,790 --> 00:19:26,210
Y luego voy a hacer n - get_int,
y hacer esto mientras que n es mayor que 0.

385
00:19:26,210 --> 00:19:28,310
Y luego regresar n ;.

386
00:19:28,310 --> 00:19:31,730
>> Así que hay mucho que hacer en
esto, pero ninguno de los cuales no lo hicimos

387
00:19:31,730 --> 00:19:33,710
mirar a la semana pasada, al menos brevemente.

388
00:19:33,710 --> 00:19:36,980
Así que en la línea 10 aquí he declarado una
función llamada get_negative_int,

389
00:19:36,980 --> 00:19:39,620
y yo he puesto (void), en
paréntesis, la razón de ser de este

390
00:19:39,620 --> 00:19:40,950
no tiene una entrada.

391
00:19:40,950 --> 00:19:42,910
No estoy pasando nada
a esta función.

392
00:19:42,910 --> 00:19:44,690
Me estoy haciendo algo a cambio de ella.

393
00:19:44,690 --> 00:19:47,270
>> Y lo que estoy esperando
volver es un número entero.

394
00:19:47,270 --> 00:19:50,040
No hay ningún tipo de datos en
C llama negative_int.

395
00:19:50,040 --> 00:19:52,880
Es sólo int, así que va
para estar en nosotros para asegurarse

396
00:19:52,880 --> 00:19:55,340
que el valor que en realidad
devuelta es no sólo un int

397
00:19:55,340 --> 00:19:56,380
pero también es negativo.

398
00:19:56,380 --> 00:20:02,150
>> En la línea 12 que estoy declarando una variable
n llamada y lo que es de tipo int.

399
00:20:02,150 --> 00:20:07,500
Y luego, en la línea 13 hasta el 18 de Soy
hacer algo, mientras que algo es verdad.

400
00:20:07,500 --> 00:20:11,040
Voy por delante e impresión
n es decir, colon, y luego un espacio,

401
00:20:11,040 --> 00:20:12,800
como un indicador para el usuario.

402
00:20:12,800 --> 00:20:16,410
>> entonces yo estoy llamando y get_int
almacenar su denominado valor de retorno

403
00:20:16,410 --> 00:20:18,130
en esa variable n.

404
00:20:18,130 --> 00:20:22,600
Pero voy a seguir haciendo
esto mientras que n es mayor que 0.

405
00:20:22,600 --> 00:20:27,960
En otras palabras, si el usuario da una me
int y ese número es mayor que 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positivo, voy a
sólo mantener reprompting el usuario,

407
00:20:31,180 --> 00:20:37,160
mantener reprompting, obligándoles a
cooperar y dame un int negativo.

408
00:20:37,160 --> 00:20:41,640
>> Y una vez que n es en realidad negative--
Supongamos que el usuario finalmente tipos -50,

409
00:20:41,640 --> 00:20:46,710
entonces este bucle while ya no es cierto
porque -50 no es mayor que 0.

410
00:20:46,710 --> 00:20:51,140
Así que salir de ese
lógicamente bucle y volver n.

411
00:20:51,140 --> 00:20:53,520
>> Pero hay otra
Lo que tengo que hacer.

412
00:20:53,520 --> 00:20:56,190
Y yo simplemente puedo hacer esto
por copiar y pegar

413
00:20:56,190 --> 00:20:58,540
una línea de código en la parte superior del archivo.

414
00:20:58,540 --> 00:21:01,630
Tengo que enseñar a Clang,
o promesa de sonido metálico,

415
00:21:01,630 --> 00:21:04,630
explícitamente que yo quiero,
de hecho, ir y poner en práctica

416
00:21:04,630 --> 00:21:06,020
esta función get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Tal vez sólo sea inferior en el archivo.

418
00:21:07,674 --> 00:21:09,840
Una vez más, recordar que Clang
lee cosas de arriba a abajo,

419
00:21:09,840 --> 00:21:12,330
de izquierda a derecha, por lo que no puede
llamar a una función si Clang

420
00:21:12,330 --> 00:21:15,330
no sabe que va a existir.

421
00:21:15,330 --> 00:21:18,430
>> Ahora, por desgracia, este programa,
como algunos de ustedes se habrán dado cuenta,

422
00:21:18,430 --> 00:21:19,590
Ya es buggy.

423
00:21:19,590 --> 00:21:21,400
Déjame seguir adelante y hacer buggy3.

424
00:21:21,400 --> 00:21:26,904
Compila, por lo que mi problema ahora no es
un error de sintaxis, como un error textual,

425
00:21:26,904 --> 00:21:29,570
que es en realidad va a ser una lógica
error que he deliberadamente

426
00:21:29,570 --> 00:21:32,450
hecho como una oportunidad para
paso a través de lo que está pasando.

427
00:21:32,450 --> 00:21:35,540
>> Voy a seguir adelante
ahora y funcionamiento buggy3.

428
00:21:35,540 --> 00:21:37,490
Y voy a ir
delante y no cooperar.

429
00:21:37,490 --> 00:21:39,494
Voy a darle el número 1.

430
00:21:39,494 --> 00:21:41,410
Que no le gustó, por lo
me está provocando de nuevo.

431
00:21:41,410 --> 00:21:42,147
>> ¿Qué hay de 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Ninguno de los que están trabajando.

435
00:21:44,740 --> 00:21:46,890
¿Qué hay de -50?

436
00:21:46,890 --> 00:21:48,560
Y el programa parece funcionar.

437
00:21:48,560 --> 00:21:49,970
>> Déjame intentarlo una vez más.

438
00:21:49,970 --> 00:21:53,400
Permítanme tratar -1, parece que funciona.

439
00:21:53,400 --> 00:21:56,380
Permítanme tratar -2, parece que funciona.

440
00:21:56,380 --> 00:21:59,640
Permítanme tratar de 0.

441
00:21:59,640 --> 00:22:01,684
Eh, eso es incorrecto.

442
00:22:01,684 --> 00:22:03,350
Ahora, estamos siendo un poco pedante aquí.

443
00:22:03,350 --> 00:22:07,090
Pero es, de hecho, el caso de que 0
no es ni positivo ni negativo.

444
00:22:07,090 --> 00:22:11,150
Y así, el hecho de que mi programa es
diciendo que 0 es un entero negativo,

445
00:22:11,150 --> 00:22:12,820
eso no es técnicamente correcto.

446
00:22:12,820 --> 00:22:15,180
>> Ahora, ¿por qué está haciendo esto?

447
00:22:15,180 --> 00:22:16,270
Bueno, puede ser que sea obvio.

448
00:22:16,270 --> 00:22:18,110
Y, de hecho, el programa es
destinado a ser bastante sencillo

449
00:22:18,110 --> 00:22:19,670
así que tenemos algo para explorar.

450
00:22:19,670 --> 00:22:25,870
>> Pero vamos a introducir un tercer depuración
aquí se llama técnica de debug50.

451
00:22:25,870 --> 00:22:27,750
Así que este es un programa
que simplemente hemos creado

452
00:22:27,750 --> 00:22:30,770
este año se llama debug50
que le permitirá

453
00:22:30,770 --> 00:22:34,130
utilizar lo que se llama un built-in
depurador gráfico en IDE CS50.

454
00:22:34,130 --> 00:22:38,400
Y un depurador es simplemente un programa que
en general, le permite ejecutar su programa

455
00:22:38,400 --> 00:22:44,050
pero paso a paso a paso, la línea
por línea por línea, haciendo una pausa, hurgando

456
00:22:44,050 --> 00:22:47,626
alrededor, mirando a las variables de manera que
el programa no se limita a soplar más allá de usted

457
00:22:47,626 --> 00:22:49,750
e imprimir rápidamente algo
o no imprimir algo.

458
00:22:49,750 --> 00:22:53,250
Se le da una oportunidad, por lo
la velocidad humana, para interactuar con él.

459
00:22:53,250 --> 00:22:55,470
>> Y para ello,
simplemente hacer lo siguiente.

460
00:22:55,470 --> 00:22:58,479
Después de compilar el código,
que ya hice, buggy3,

461
00:22:58,479 --> 00:23:00,020
seguir adelante y ejecutar debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Tanto como help50 tiene que ejecutar
help50 y entonces el comando,

464
00:23:06,760 --> 00:23:10,120
debug50 tiene que ejecutar y debug50
entonces el nombre del comando.

465
00:23:10,120 --> 00:23:14,440
>> Ahora observen lo que sucede en mi pantalla,
en el lado derecho en particular.

466
00:23:14,440 --> 00:23:19,400
Cuando golpeo Ejecutar, toda la
panel de repente este derecho

467
00:23:19,400 --> 00:23:20,419
se abre en la pantalla.

468
00:23:20,419 --> 00:23:22,210
Y hay mucho que hacer
en a primera vista.

469
00:23:22,210 --> 00:23:25,110
Pero no hay demasiado
mucho de qué preocuparse todavía.

470
00:23:25,110 --> 00:23:28,570
>> Esto me está mostrando todo
que está pasando dentro de mi programa

471
00:23:28,570 --> 00:23:31,130
en este momento ya través de éstos
botones encima de la tapa es entonces

472
00:23:31,130 --> 00:23:35,910
lo que me permite el paso a través de mi código
en última instancia, paso a paso a paso.

473
00:23:35,910 --> 00:23:37,140
Pero no por el momento.

474
00:23:37,140 --> 00:23:38,060
Observe lo que ocurre.

475
00:23:38,060 --> 00:23:40,600
En mi ventana de terminal
Yo estoy siendo incitado para n.

476
00:23:40,600 --> 00:23:44,560
Y voy a seguir adelante y
cooperar en esta ocasión y tipo de -1.

477
00:23:44,560 --> 00:23:48,770
Y aunque un poco crípticamente, -1
es un entero negativo, como se esperaba.

478
00:23:48,770 --> 00:23:52,020
>> Y entonces hijo terminó con
estado 0 gdbserver salir.

479
00:23:52,020 --> 00:23:55,180
BGF, depurador de GNU, es el nombre
del software subyacente

480
00:23:55,180 --> 00:23:56,620
que implementa este depurador.

481
00:23:56,620 --> 00:24:00,500
Pero todo esto significa en realidad, el depurador
se fue porque mi programa de dejar de fumar

482
00:24:00,500 --> 00:24:01,710
y todo estaba bien.

483
00:24:01,710 --> 00:24:06,020
Si quiero depurar realmente mi programa,
Tengo que decirle preventivamente debug50,

484
00:24:06,020 --> 00:24:08,920
dónde quiero para empezar
pasando a través de mi código?

485
00:24:08,920 --> 00:24:11,750
>> Y tal vez la forma más sencilla
hacer esto es como sigue.

486
00:24:11,750 --> 00:24:15,300
Si se ciernen sobre el
canaleta de mi editor de aquí,

487
00:24:15,300 --> 00:24:19,090
por lo que en realidad sólo en la barra lateral aquí,
a la izquierda del número de línea,

488
00:24:19,090 --> 00:24:21,870
Tenga en cuenta que si sólo clic
una vez, puse un pequeño punto rojo.

489
00:24:21,870 --> 00:24:24,460
Y ese pequeño punto rojo,
como una señal de alto, medio, bueno,

490
00:24:24,460 --> 00:24:29,430
debug50, pausa en la ejecución de mi código
justo allí cuando ejecuto este programa.

491
00:24:29,430 --> 00:24:30,260
>> Así que vamos a hacer eso.

492
00:24:30,260 --> 00:24:37,340
Déjame ir por delante y correr mi programa
de nuevo con debug50 ./buggy3, Intro.

493
00:24:37,340 --> 00:24:40,110
Y ahora, aviso, algo
diferente ha sucedido.

494
00:24:40,110 --> 00:24:42,440
No estoy que se le pida
sin embargo, en mi ventana de terminal

495
00:24:42,440 --> 00:24:45,430
para nada, porque yo no tengo
llegado allí todavía en mi programa.

496
00:24:45,430 --> 00:24:47,950
Nótese que en la línea 8
que ahora se pone de relieve,

497
00:24:47,950 --> 00:24:51,720
y hay una pequeña flecha en
dicho izquierda, que se detuvo aquí.

498
00:24:51,720 --> 00:24:55,030
Esta línea de código, la línea
8, aún no se ha ejecutado.

499
00:24:55,030 --> 00:24:58,940
>> Y lo que es curioso, si miro
aquí en el lado derecho,

500
00:24:58,940 --> 00:25:03,530
cuenta de que i es un local de
variable local en el sentido

501
00:25:03,530 --> 00:25:05,450
que hay dentro de la función actual.

502
00:25:05,450 --> 00:25:08,920
Y su valor, al parecer, de forma predeterminada,
y en cierto modo convenientemente, es 0.

503
00:25:08,920 --> 00:25:10,260
Pero no me escriba 0.

504
00:25:10,260 --> 00:25:13,410
Eso sólo pasa a ser su
valor por defecto en el momento.

505
00:25:13,410 --> 00:25:15,490
>> Así que permítanme seguir adelante y hacer esto ahora.

506
00:25:15,490 --> 00:25:18,680
Déjame ir adelante y en
la parte superior derecha aquí, estoy

507
00:25:18,680 --> 00:25:20,970
va a seguir adelante y
haga clic en este icono de los primeros cuales

508
00:25:20,970 --> 00:25:25,360
significa pasar por encima de lo que significa no se salte
pero pasar por encima de esta línea de código,

509
00:25:25,360 --> 00:25:27,770
ejecutarlo en el camino.

510
00:25:27,770 --> 00:25:30,710
>> Y ahora, cuenta, mi
pronta acaba de cambiar.

511
00:25:30,710 --> 00:25:31,380
¿Porqué es eso?

512
00:25:31,380 --> 00:25:33,639
Le he dicho a debug50,
ejecutar esta línea de código.

513
00:25:33,639 --> 00:25:34,930
¿Qué hace esta línea de código hace?

514
00:25:34,930 --> 00:25:35,960
me lleva a un int.

515
00:25:35,960 --> 00:25:36,460
DE ACUERDO.

516
00:25:36,460 --> 00:25:37,400
Permítanme cooperar.

517
00:25:37,400 --> 00:25:41,340
Déjame ir adelante ahora y escriba -1, ENTER.

518
00:25:41,340 --> 00:25:42,920
Y ahora cuenta de lo que ha cambiado.

519
00:25:42,920 --> 00:25:46,060
Al lado derecho,
mi variable local i

520
00:25:46,060 --> 00:25:48,200
se indica como -1 ahora.

521
00:25:48,200 --> 00:25:49,810
Y sigue siendo de tipo int.

522
00:25:49,810 --> 00:25:53,102
>> Y aviso, también, mi llamado
la pila de llamadas, donde hice una pausa?

523
00:25:53,102 --> 00:25:54,810
Hablaremos más sobre
esto en el futuro.

524
00:25:54,810 --> 00:25:58,620
Pero la pila de llamadas simplemente se refiere a lo
funciones están actualmente en movimiento.

525
00:25:58,620 --> 00:26:00,040
En este momento es simplemente principal.

526
00:26:00,040 --> 00:26:03,590
Y en este momento el único local de
variable es i con un valor de 1.

527
00:26:03,590 --> 00:26:09,840
>> Y cuando finalmente pasar por encima de esta línea
aquí, con ese mismo icono en la parte superior derecha,

528
00:26:09,840 --> 00:26:11,410
-1 Es un entero negativo.

529
00:26:11,410 --> 00:26:13,580
Ahora se está haciendo una pausa durante ese corchete.

530
00:26:13,580 --> 00:26:14,740
Vamos a dejar que haga su cosa.

531
00:26:14,740 --> 00:26:17,300
Doy un paso más de esa línea, y listo.

532
00:26:17,300 --> 00:26:20,240
>> Así que no todo lo que terriblemente
esclarecedor sin embargo,

533
00:26:20,240 --> 00:26:23,550
pero me dejó una pausa
y pensar con lógica

534
00:26:23,550 --> 00:26:24,870
lo que este programa está haciendo.

535
00:26:24,870 --> 00:26:26,890
Pero ese no fue el caso errónea.

536
00:26:26,890 --> 00:26:28,510
Vamos a hacer esto de nuevo de la siguiente manera.

537
00:26:28,510 --> 00:26:31,340
>> Voy a salir de ese punto de interrupción
en la línea 8 con el punto rojo.

538
00:26:31,340 --> 00:26:32,830
Voy a volver a ejecutar debug50.

539
00:26:32,830 --> 00:26:34,400
Se hizo una pausa automáticamente aquí.

540
00:26:34,400 --> 00:26:37,660
Pero esta vez, en lugar de
pasando por encima de esta línea,

541
00:26:37,660 --> 00:26:42,290
déjame ir en realidad dentro de
get_negative_int y averiguar,

542
00:26:42,290 --> 00:26:45,530
¿por qué está aceptando 0 como una respuesta válida?

543
00:26:45,530 --> 00:26:47,990
>> Así que en lugar de hacer clic en Paso a paso por.

544
00:26:47,990 --> 00:26:50,630
Voy a seguir adelante
y haga clic en Paso a paso.

545
00:26:50,630 --> 00:26:54,030
Y observe que la línea 8 que es
Ahora resaltado ahora de repente

546
00:26:54,030 --> 00:26:56,900
se convierte en la línea 17.

547
00:26:56,900 --> 00:26:59,947
>> Ahora, no es que el depurador
ha saltado las líneas 14 y 15 y 16.

548
00:26:59,947 --> 00:27:01,780
Es que no hay nada
para mostrarle allí.

549
00:27:01,780 --> 00:27:04,050
Estas son sólo la declaración de variables,
Y luego está la palabra hacer

550
00:27:04,050 --> 00:27:05,390
y luego una llave de apertura.

551
00:27:05,390 --> 00:27:09,227
La única línea que es funcional
jugosa realmente es este de aquí, 17.

552
00:27:09,227 --> 00:27:11,060
Y ahí es donde nos hemos
una pausa automáticamente.

553
00:27:11,060 --> 00:27:13,870
>> Así printf ( "n.is:") ;, por lo
que aún no ha sucedido.

554
00:27:13,870 --> 00:27:18,250
Así que vamos a seguir adelante y haga clic en Paso a paso por.

555
00:27:18,250 --> 00:27:20,326
Ahora mi sistema, de hecho,
cambiado a ( "n es:").

556
00:27:20,326 --> 00:27:22,450
Ahora get_int, no voy
molestar a entrar en,

557
00:27:22,450 --> 00:27:24,750
porque que la función era
hecha por CS50 en la Biblioteca.

558
00:27:24,750 --> 00:27:25,750
Es presumiblemente correcta.

559
00:27:25,750 --> 00:27:28,440
>> Así que voy a seguir adelante y
tipo de cooperar dándole

560
00:27:28,440 --> 00:27:30,590
un int, pero no es un int negativo.

561
00:27:30,590 --> 00:27:32,870
Así que déjame ir por delante y golpeó 0.

562
00:27:32,870 --> 00:27:39,460
Y ahora lo que sucede aquí
cuando llegue hasta la línea 21?

563
00:27:39,460 --> 00:27:40,890
No he iterado de nuevo.

564
00:27:40,890 --> 00:27:43,320
No parece que haya atascado en este bucle.

565
00:27:43,320 --> 00:27:45,990
En otras palabras, este amarillo
bar no seguir adelante alrededor,

566
00:27:45,990 --> 00:27:47,130
y alrededor y alrededor.

567
00:27:47,130 --> 00:27:48,340
>> Ahora, ¿por qué?

568
00:27:48,340 --> 00:27:49,920
Bueno, n, lo que está n en este momento?

569
00:27:49,920 --> 00:27:53,280
Puedo mirar a nivel local
variables en el depurador.

570
00:27:53,280 --> 00:27:53,816
n es 0.

571
00:27:53,816 --> 00:27:55,190
Muy bien, ¿cuál era mi condición?

572
00:27:55,190 --> 00:27:58,700
>> 20-- línea 20 es, así,
0 es mayor que 0.

573
00:27:58,700 --> 00:27:59,500
Eso no es verdad.

574
00:27:59,500 --> 00:28:01,020
0 no es mayor que 0.

575
00:28:01,020 --> 00:28:02,820
Y por lo que salió de esto.

576
00:28:02,820 --> 00:28:06,370
>> Y por eso es que en la línea
21, si realmente continúo,

577
00:28:06,370 --> 00:28:10,370
Voy a devolver 0, incluso
a pesar de que debería haber rechazado 0

578
00:28:10,370 --> 00:28:12,484
que no sea negativo.

579
00:28:12,484 --> 00:28:14,650
Así que ahora, realmente no tiene ni
se preocupan por el depurador.

580
00:28:14,650 --> 00:28:16,900
Tengo, lo que no es necesario
saber qué más está pasando.

581
00:28:16,900 --> 00:28:19,233
>> Así que voy a seguir adelante y
basta con hacer clic en el botón Reproducir,

582
00:28:19,233 --> 00:28:20,240
y dejar que este acabado para arriba.

583
00:28:20,240 --> 00:28:23,440
Ahora, me he dado cuenta de que mi
insecto es al parecer en la línea 20.

584
00:28:23,440 --> 00:28:25,160
Esa es mi error lógico.

585
00:28:25,160 --> 00:28:28,100
>> Y así lo quiero
que hacer para cambiar esto?

586
00:28:28,100 --> 00:28:32,500
Si el problema es que no estoy
la captura de 0, que es sólo un error lógico.

587
00:28:32,500 --> 00:28:35,910
Y puedo decir, mientras que n es
mayor que o igual a 0,

588
00:28:35,910 --> 00:28:38,330
mantener a preguntar al usuario una y otra vez.

589
00:28:38,330 --> 00:28:41,050
>> Así, de nuevo, simple error, tal vez
incluso obvia cuando me viste

590
00:28:41,050 --> 00:28:42,410
escribirlo hace tan sólo unos minutos.

591
00:28:42,410 --> 00:28:44,570
Pero aquí la comida para llevar
es que con depuración 50,

592
00:28:44,570 --> 00:28:46,850
y con la depuración
software de manera más general,

593
00:28:46,850 --> 00:28:51,370
usted tiene este nuevo poder de
caminar a través de su propio código, mira

594
00:28:51,370 --> 00:28:55,590
a través de ese panel de la derecha lo
los valores de las variables son.

595
00:28:55,590 --> 00:28:57,700
Por lo que no necesariamente
tener que usar algo

596
00:28:57,700 --> 00:29:00,630
como si EPRINTF para imprimir esos valores.

597
00:29:00,630 --> 00:29:04,430
En realidad se puede verlos
visualmente en la pantalla.

598
00:29:04,430 --> 00:29:08,920
>> Ahora, más allá de esto, vale la pena señalar
que no es otra técnica que es

599
00:29:08,920 --> 00:29:09,890
en realidad muy común.

600
00:29:09,890 --> 00:29:13,120
Y uno se pregunta por qué esta pequeña
tipo aquí se ha sentado en el escenario.

601
00:29:13,120 --> 00:29:16,490
Así que hay esta técnica, en general,
conocido como caucho depuración de pato,

602
00:29:16,490 --> 00:29:18,786
que en realidad es sólo una
testimonio del hecho de

603
00:29:18,786 --> 00:29:20,660
que a menudo cuando los programadores
está escribiendo código,

604
00:29:20,660 --> 00:29:22,650
que no son necesariamente
colaborar con los demás,

605
00:29:22,650 --> 00:29:24,030
o trabajar en un entorno compartido.

606
00:29:24,030 --> 00:29:25,050
>> Son una especie de en casa.

607
00:29:25,050 --> 00:29:25,910
Tal vez sea tarde por la noche.

608
00:29:25,910 --> 00:29:28,190
Están tratando de figura
a cabo algunos errores en su código.

609
00:29:28,190 --> 00:29:29,330
Y no sólo están viendo.

610
00:29:29,330 --> 00:29:30,329
>> Y no hay ningún compañero de cuarto.

611
00:29:30,329 --> 00:29:31,250
No hay TF.

612
00:29:31,250 --> 00:29:32,680
No hay CA alrededor.

613
00:29:32,680 --> 00:29:36,440
Todo lo que tienen en su plataforma
es este pequeño patito de goma.

614
00:29:36,440 --> 00:29:39,030
>> Y así depuración pato de goma
es sólo esta invitación

615
00:29:39,030 --> 00:29:42,780
pensar en algo tan tonto
ya que esto como una criatura real

616
00:29:42,780 --> 00:29:46,940
y, de hecho caminar a través de su código
verbalmente a este objeto inanimado.

617
00:29:46,940 --> 00:29:49,230
Así, por ejemplo, si
este es mi ejemplo aquí--

618
00:29:49,230 --> 00:29:52,470
y recordar que antes
el problema era esto,

619
00:29:52,470 --> 00:29:58,140
si elimino esta primera línea de código,
y yo seguir adelante y hacer buggy de 0 de nuevo,

620
00:29:58,140 --> 00:30:01,220
recordar que tenía estos
mensajes de error aquí.

621
00:30:01,220 --> 00:30:05,997
Así que la idea aquí, aunque ridícula
sentir en el momento de hacer esto públicamente,

622
00:30:05,997 --> 00:30:06,580
es que el error.

623
00:30:06,580 --> 00:30:10,910
>> Aceptar, por lo que mi problema es que tengo
declarado implícitamente una función de biblioteca.

624
00:30:10,910 --> 00:30:12,610
Y que la función de biblioteca es printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- bien, declarar
me recuerda de prototipos.

626
00:30:15,290 --> 00:30:18,930
>> Eso significa que necesito en realidad
indicar al compilador de antemano lo

627
00:30:18,930 --> 00:30:19,980
la función se parece.

628
00:30:19,980 --> 00:30:20,930
Espera un minuto.

629
00:30:20,930 --> 00:30:23,580
No tenía io.h. norma

630
00:30:23,580 --> 00:30:24,530
Muchas gracias.

631
00:30:24,530 --> 00:30:27,330
>> Por lo que sólo este proceso se de--
no es necesario tener en realidad un pato.

632
00:30:27,330 --> 00:30:29,819
Pero esta idea de caminar
a sí mismo a través de su propio código

633
00:30:29,819 --> 00:30:31,610
por lo que incluso se oye
usted mismo, de modo que usted

634
00:30:31,610 --> 00:30:35,620
darse cuenta omisiones en su propio
observaciones, es en general la idea.

635
00:30:35,620 --> 00:30:38,910
>> Y, quizá más lógicamente, no tan
con mucho que uno, pero el más implicado

636
00:30:38,910 --> 00:30:44,220
ejemplo que acabamos de hacer en 3.c con errores,
puede caminar a sí mismo a través de él

637
00:30:44,220 --> 00:30:45,310
como sigue.

638
00:30:45,310 --> 00:30:49,190
Así bien, el caucho
patito, DDB, si se quiere.

639
00:30:49,190 --> 00:30:52,350
Aquí tenemos en mi función principal,
Voy a llamar a conseguir int negativo.

640
00:30:52,350 --> 00:30:54,660
>> Y estoy consiguiendo el valor de retorno.

641
00:30:54,660 --> 00:31:00,410
Estoy almacenando en el lado izquierdo
en la línea 8 en una variable llamada i.

642
00:31:00,410 --> 00:31:02,380
OK, pero espera, ¿cómo
que reciben ese valor?

643
00:31:02,380 --> 00:31:04,130
Deja que te mire la función en la línea 12.

644
00:31:04,130 --> 00:31:05,760
>> En la línea 12, tenemos que conseguir int negativo.

645
00:31:05,760 --> 00:31:08,190
No se necesita ningún insumo,
no devolver un int, OK.

646
00:31:08,190 --> 00:31:10,929
Declaro en la línea 14 una variable n.

647
00:31:10,929 --> 00:31:12,220
Se va a almacenar un número entero.

648
00:31:12,220 --> 00:31:13,760
Eso es lo que quiero.

649
00:31:13,760 --> 00:31:18,480
>> Lo mismo ocurre con la siguiente, mientras que n es-- dejó
Me deshacer lo que el punto de referencia que ya hizo.

650
00:31:18,480 --> 00:31:22,710
Así, mientras que n es mayor que
0, imprima n es, en Aceptar.

651
00:31:22,710 --> 00:31:25,170
Y luego llamar a quedar almacenado int n.

652
00:31:25,170 --> 00:31:30,160
Y a continuación, comprobar si n es 0,
n es no-- ahí está.

653
00:31:30,160 --> 00:31:31,910
Así, de nuevo, no lo hace
necesitará el pato real.

654
00:31:31,910 --> 00:31:35,650
Pero sólo caminar usted mismo a través
su código como un ejercicio intelectual

655
00:31:35,650 --> 00:31:37,720
a menudo le ayudará
darse cuenta de lo que está pasando,

656
00:31:37,720 --> 00:31:41,170
en lugar de sólo hacer algo
así, mirando a la pantalla,

657
00:31:41,170 --> 00:31:43,720
y no hablar a sí mismo a través
él, que sinceramente no es

658
00:31:43,720 --> 00:31:46,270
casi como una técnica eficaz.

659
00:31:46,270 --> 00:31:48,620
Así que ahí lo tienen, una
número de diferentes técnicas

660
00:31:48,620 --> 00:31:52,102
de hecho la depuración de su código
y la búsqueda de fallos, todos los cuales

661
00:31:52,102 --> 00:31:54,810
deben ser herramientas en su caja de herramientas
de modo que usted no es tarde en la noche,

662
00:31:54,810 --> 00:31:57,660
sobre todo, que estás en el comedor
pasillos, o en horario de oficina,

663
00:31:57,660 --> 00:32:00,368
golpearse la cabeza contra la
pared, tratando de resolver algún problema.

664
00:32:00,368 --> 00:32:02,020
Se dan cuenta de que existen herramientas de software.

665
00:32:02,020 --> 00:32:03,720
Existen herramientas de pato de goma.

666
00:32:03,720 --> 00:32:09,630
Y hay toda una plantilla de
apoyar a la espera de dar una mano.

667
00:32:09,630 --> 00:32:13,120
>> Así que ahora, unas palabras sobre el problema
conjuntos, y en lo que usted está esperando

668
00:32:13,120 --> 00:32:15,620
salir de ellos, y cómo
nos ocupamos de la evaluación.

669
00:32:15,620 --> 00:32:17,680
Por programa del curso,
boletines de problemas de CS50

670
00:32:17,680 --> 00:32:22,320
son evaluados en cuatro ejes primarios, por lo
speak-- al ámbito de aplicación, corrección, diseño,

671
00:32:22,320 --> 00:32:23,060
y el estilo.

672
00:32:23,060 --> 00:32:25,910
Y alcance solo se refiere a la cantidad de
de la pieza que ha mordido?

673
00:32:25,910 --> 00:32:28,080
¿Cuánto de un problema ha intentado?

674
00:32:28,080 --> 00:32:30,110
¿Qué nivel de esfuerzo
¿ha manifestado?

675
00:32:30,110 --> 00:32:35,750
>> La corrección es, funciona el programa como
se supone que según la especificación CS50

676
00:32:35,750 --> 00:32:38,640
cuando se proporciona ciertas entradas
o ciertas salidas a volver?

677
00:32:38,640 --> 00:32:41,130
El diseño es el más subjetivo de ellos.

678
00:32:41,130 --> 00:32:43,360
Y es el que se
que más tardan en aprender

679
00:32:43,360 --> 00:32:47,220
y el más largo para enseñar, en
la medida en que se reduce a,

680
00:32:47,220 --> 00:32:49,530
lo bien escrito es el código?

681
00:32:49,530 --> 00:32:52,920
>> Es una cosa que acaba de imprimir la correcta
salidas o devuelven los valores correctos.

682
00:32:52,920 --> 00:32:55,400
Pero lo haces como
eficientemente como sea posible?

683
00:32:55,400 --> 00:32:58,210
¿Lo está haciendo brecha
y conquistar, o binario

684
00:32:58,210 --> 00:33:01,500
búsqueda como pronto veremos que hicimos
Hace dos semanas, con la guía telefónica?

685
00:33:01,500 --> 00:33:04,670
¿Hay mejores maneras de resolver el
problema que actualmente tiene aquí?

686
00:33:04,670 --> 00:33:06,380
Eso es una oportunidad para un mejor diseño.

687
00:33:06,380 --> 00:33:08,530
>> Y entonces style-- cómo
bonito es el código?

688
00:33:08,530 --> 00:33:12,370
Se dará cuenta de que estoy bastante
en particular sobre la sangría mi código,

689
00:33:12,370 --> 00:33:15,300
y asegurándose de que mi variables
se nombran razonable. norte,

690
00:33:15,300 --> 00:33:19,660
mientras resumen, es un buen nombre para una
número, i por un número entero de conteo,

691
00:33:19,660 --> 00:33:20,727
s para una cadena.

692
00:33:20,727 --> 00:33:22,560
Y podemos tener más largo
estilo de los nombres de variables.

693
00:33:22,560 --> 00:33:25,500
El estilo es lo bueno
Cómo se ve el código?

694
00:33:25,500 --> 00:33:26,600
Y cómo legible es?

695
00:33:26,600 --> 00:33:29,650
>> Y con el tiempo, cuál es su TA
y TFS van a hacer en el curso

696
00:33:29,650 --> 00:33:31,870
que se proporcionará con ese
tipo de retroalimentación cualitativa

697
00:33:31,870 --> 00:33:34,330
de manera que se obtiene una mejor
en esos diversos aspectos.

698
00:33:34,330 --> 00:33:37,510
Y en cuanto a la forma en que
evaluar cada uno de estos ejes,

699
00:33:37,510 --> 00:33:40,080
que es típicamente con muy pocos
cubos para que, en general,

700
00:33:40,080 --> 00:33:41,680
tener una idea de lo bien que está haciendo.

701
00:33:41,680 --> 00:33:45,680
Y, de hecho, si recibe una puntuación en
cualquiera de los axes-- corrección, diseño

702
00:33:45,680 --> 00:33:49,659
y el estilo especially-- ese número
generalmente será de entre 1 y 5.

703
00:33:49,659 --> 00:33:52,450
Y, literalmente, si usted está recibiendo
3 de al inicio del semestre,

704
00:33:52,450 --> 00:33:53,977
Esta es una cosa muy buena.

705
00:33:53,977 --> 00:33:55,810
Esto significa que todavía hay
margen de mejora,

706
00:33:55,810 --> 00:33:58,490
la cual es de esperar en el
tomar una clase por primera vez.

707
00:33:58,490 --> 00:34:01,820
No es de esperar algún fragmento de techo
a la que está aspirando a alcanzar.

708
00:34:01,820 --> 00:34:03,970
Y así conseguir el de 3
las primeras piezas,

709
00:34:03,970 --> 00:34:06,550
si no un 2 y de 4 de,
es, de hecho, una buena cosa.

710
00:34:06,550 --> 00:34:08,880
Es también dentro del alcance,
bien dentro de lo esperado.

711
00:34:08,880 --> 00:34:11,421
>> Y si su mente está corriendo, espere
un minuto, tres de cada cinco.

712
00:34:11,421 --> 00:34:12,620
Eso es realmente una salida 6 de 10.

713
00:34:12,620 --> 00:34:13,560
Eso es 60%.

714
00:34:13,560 --> 00:34:14,830
Dios mío, que es una F.

715
00:34:14,830 --> 00:34:15,870
>> No es.

716
00:34:15,870 --> 00:34:17,600
No es, de hecho, que.

717
00:34:17,600 --> 00:34:22,710
Más bien, es una oportunidad para mejorar
en el transcurso del semestre.

718
00:34:22,710 --> 00:34:25,580
Y si usted está recibiendo alguna
Poors, se trata de una oportunidad

719
00:34:25,580 --> 00:34:29,199
para aprovechar las horas de oficina,
ciertamente, secciones y otros recursos.

720
00:34:29,199 --> 00:34:32,840
>> Lo mejor es la oportunidad, de verdad,
para estar orgullosos de lo lejos que ha

721
00:34:32,840 --> 00:34:34,520
llegado en el transcurso del semestre.

722
00:34:34,520 --> 00:34:38,199
Así que darse cuenta, si nada
lo demás, tres es buena.

723
00:34:38,199 --> 00:34:40,179
Y permite espacio para el crecimiento en el tiempo.

724
00:34:40,179 --> 00:34:43,090
>> En cuanto a la forma en que esos ejes son
ponderada, de manera realista que estés

725
00:34:43,090 --> 00:34:46,745
va a pasar la mayor parte de su tiempo conseguir
cosas para trabajar, por no hablar correctamente.

726
00:34:46,745 --> 00:34:49,120
Y así tiende a la corrección
ponderar el más, como con

727
00:34:49,120 --> 00:34:51,360
este factor multiplicativo de tres.

728
00:34:51,360 --> 00:34:54,659
El diseño también es importante, pero
algo que no necesariamente

729
00:34:54,659 --> 00:34:58,220
pasar todas esas horas en
tratando de conseguir cosas para trabajar.

730
00:34:58,220 --> 00:35:00,019
>> Y así se pondera
un poco más ligera.

731
00:35:00,019 --> 00:35:01,560
Y a continuación, el estilo se pondera lo menos.

732
00:35:01,560 --> 00:35:03,710
A pesar de que no es menos
fundamentalmente importante,

733
00:35:03,710 --> 00:35:05,990
Es que, tal vez, el
Lo más fácil de hacer el bien,

734
00:35:05,990 --> 00:35:08,440
imitando los ejemplos que
hacer en la conferencia y la sección,

735
00:35:08,440 --> 00:35:11,080
con las cosas Nicely
sangría, y comentó:

736
00:35:11,080 --> 00:35:14,320
y así sucesivamente está entre los más fáciles
cosas que hacer y hacerlo bien.

737
00:35:14,320 --> 00:35:16,960
Así que, como tal, se dan cuenta
que esas son puntos

738
00:35:16,960 --> 00:35:19,000
que son relativamente fáciles de entender.

739
00:35:19,000 --> 00:35:22,360
>> Y ahora una palabra de
esto-- honestidad académica.

740
00:35:22,360 --> 00:35:25,150
Así por el curso de
programa, verá

741
00:35:25,150 --> 00:35:27,630
que el curso tiene un buen
poco de lenguaje de evitar esto.

742
00:35:27,630 --> 00:35:31,380
Y el curso se lleva a la cuestión de la
honestidad académica muy en serio.

743
00:35:31,380 --> 00:35:33,450
>> Tenemos la distinción,
Para bien o para mal,

744
00:35:33,450 --> 00:35:36,570
de haber enviado cada año más
estudiantes para tomar medidas disciplinarias

745
00:35:36,570 --> 00:35:39,670
que la mayoría de cualquier otro
Por supuesto, que yo sepa.

746
00:35:39,670 --> 00:35:42,580
Esto no es necesariamente
indicativo del hecho

747
00:35:42,580 --> 00:35:46,340
que los estudiantes CS, o los estudiantes, son CS50
menos honesto que sus compañeros de clase.

748
00:35:46,340 --> 00:35:49,090
Pero la realidad de que en este
mundo, por vía electrónica, sólo

749
00:35:49,090 --> 00:35:50,990
tienen tecnológica
medios de detección de este.

750
00:35:50,990 --> 00:35:53,360
>> Es importante para nosotros para
equidad a través de la clase

751
00:35:53,360 --> 00:35:58,550
lo que hacemos detectar esto, y elevar
la cuestión cuando vemos cosas.

752
00:35:58,550 --> 00:36:01,980
Y sólo para pintar un cuadro, y realmente
para ayudar a algo como esto en el fregadero,

753
00:36:01,980 --> 00:36:04,600
estos son los números de
estudiantes en los últimos 10 años

754
00:36:04,600 --> 00:36:07,610
que han estado involucrados en algunos
estas cuestiones de honestidad académica,

755
00:36:07,610 --> 00:36:10,990
con unos 32 estudiantes
desde el otoño de 2015, que

756
00:36:10,990 --> 00:36:13,760
es decir que nosotros tomamos
el asunto muy en serio.

757
00:36:13,760 --> 00:36:18,380
Y, en última instancia, estos números componen,
más recientemente, alrededor de 3%, 4% o menos

758
00:36:18,380 --> 00:36:19,120
de la clase.

759
00:36:19,120 --> 00:36:25,220
>> Así que para la mayoría absoluta de los estudiantes
parece que las líneas están claras.

760
00:36:25,220 --> 00:36:27,940
Pero tenga esto en
mente, particularmente tarde

761
00:36:27,940 --> 00:36:32,080
por la noche cuando lucha con
alguna solución a un conjunto de problemas,

762
00:36:32,080 --> 00:36:34,830
la existencia de mecanismos
para llegar mejor a sí mismo

763
00:36:34,830 --> 00:36:37,870
el apoyo de lo que se
pensar, incluso a esa hora.

764
00:36:37,870 --> 00:36:40,514
Darse cuenta de que cuando recibimos
envíos de los estudiantes, que se cruzan

765
00:36:40,514 --> 00:36:43,430
comparar cada presentación este año
en contra de cada presentación el año pasado,

766
00:36:43,430 --> 00:36:47,590
contra todos los envíos a partir de 2007,
y desde, mirando, así,

767
00:36:47,590 --> 00:36:49,931
código de los repositorios en línea,
foros de discusión, sitios de trabajo.

768
00:36:49,931 --> 00:36:51,806
Y mencionamos esto,
Realmente, todo en aras

769
00:36:51,806 --> 00:36:56,040
de la divulgación completa, que si
otra persona puede encontrar en línea,

770
00:36:56,040 --> 00:36:57,880
sin duda, por lo que puede que el curso.

771
00:36:57,880 --> 00:37:00,100
Pero, en realidad, el espíritu
del curso se reduce

772
00:37:00,100 --> 00:37:01,650
a esta cláusula en el programa de estudios.

773
00:37:01,650 --> 00:37:03,670
Realmente es justo, sea razonable.

774
00:37:03,670 --> 00:37:06,680
>> Y si tuviéramos que elaborar en eso
con sólo un poco más la lengua,

775
00:37:06,680 --> 00:37:09,770
darse cuenta de que la esencia de todo
el trabajo que envíe a este curso

776
00:37:09,770 --> 00:37:10,954
debe ser la suya.

777
00:37:10,954 --> 00:37:13,870
Pero dentro de eso, sin duda hay
oportunidades y el estímulo,

778
00:37:13,870 --> 00:37:17,300
y el valor pedagógico en la transformación de
otros-- mí mismo, el TFS, las entidades emisoras,

779
00:37:17,300 --> 00:37:20,760
las AT, y otros en la clase,
para el apoyo, que sus amigos solos

780
00:37:20,760 --> 00:37:23,547
y compañeros que han estudiado
CS y programación antes.

781
00:37:23,547 --> 00:37:25,130
Y por lo que hay un margen para eso.

782
00:37:25,130 --> 00:37:28,180
Y la regla general del pulgar
se esto- cuando se pide ayuda,

783
00:37:28,180 --> 00:37:31,470
usted puede mostrar su código a los demás,
pero usted no puede ver la suya.

784
00:37:31,470 --> 00:37:34,880
Así que incluso si usted está en horario de oficina,
o en la sala D, o en otro lugar

785
00:37:34,880 --> 00:37:37,450
trabajando en algún conjunto pieza,
trabajando junto a un amigo, que

786
00:37:37,450 --> 00:37:40,160
es totalmente bien, en el
final del día su trabajo

787
00:37:40,160 --> 00:37:43,034
en última instancia, deben pertenecer a cada
de que, respectivamente, y no

788
00:37:43,034 --> 00:37:45,700
haber algún esfuerzo de colaboración,
excepto para el proyecto final donde

789
00:37:45,700 --> 00:37:47,410
se permite y se anima.

790
00:37:47,410 --> 00:37:49,830
>> Darse cuenta de que si estás
luchando con algo

791
00:37:49,830 --> 00:37:52,520
y su amigo sólo pasa
para ser mejor en esto, entonces,

792
00:37:52,520 --> 00:37:55,130
o mejor en ese problema que tú,
o un poco más adelante que usted,

793
00:37:55,130 --> 00:37:57,330
que es totalmente razonable para activar
a su amigo y decir, hey,

794
00:37:57,330 --> 00:38:00,480
¿Le importa mirando mi código aquí,
ayudarme diviso lo que mi problema es?

795
00:38:00,480 --> 00:38:03,760
Y, con suerte, en el
interés del valor pedagógico

796
00:38:03,760 --> 00:38:07,040
ese amigo lo hace no sólo
decir, oh, hacer esto, sino más bien,

797
00:38:07,040 --> 00:38:09,917
lo que le falta en la línea
6, o algo por el estilo?

798
00:38:09,917 --> 00:38:12,000
Sin embargo, la solución no es
para el amigo a tu lado

799
00:38:12,000 --> 00:38:15,617
decir, oh, bueno, aquí, deja, echaré
esto, y mostrar mi solución para usted.

800
00:38:15,617 --> 00:38:16,450
Así que esa es la línea.

801
00:38:16,450 --> 00:38:18,670
Usted muestra su código de
otros, pero no se puede

802
00:38:18,670 --> 00:38:22,350
ver los suyos, sin perjuicio de la otra
restricciones en el curso del programa.

803
00:38:22,350 --> 00:38:24,760
>> Así que tener en cuenta esta
así llamada cláusula de arrepentimiento

804
00:38:24,760 --> 00:38:27,560
en el programa del curso, así,
que si comete algún acto que

805
00:38:27,560 --> 00:38:30,476
No es razonable, pero llevarlo a
la atención de los jefes del curso

806
00:38:30,476 --> 00:38:34,240
dentro de las 72 horas, el curso
puede imponer sanciones locales que

807
00:38:34,240 --> 00:38:37,380
puede incluir un insatisfactorio o
el grado de fall para el trabajo presentado.

808
00:38:37,380 --> 00:38:41,410
Pero el curso no se referirá al
materia de nuevas medidas disciplinarias,

809
00:38:41,410 --> 00:38:43,010
excepto en los casos de actos repetidos.

810
00:38:43,010 --> 00:38:46,632
En otras palabras, si usted hace algunos
estúpida, noche especialmente al final, la decisión

811
00:38:46,632 --> 00:38:49,340
que a la mañana siguiente o dos días
más tarde, se despierta y se da cuenta,

812
00:38:49,340 --> 00:38:50,870
¿Qué estaba pensando?

813
00:38:50,870 --> 00:38:53,890
Usted puede hacer en CS50 tener una salida
para la fijación de ese problema

814
00:38:53,890 --> 00:38:57,170
y ser dueño de la altura, de modo que
le esperará hasta la mitad y tratar

815
00:38:57,170 --> 00:39:01,500
con él en un asunto que es a la vez
educativo y valioso para usted,

816
00:39:01,500 --> 00:39:04,200
pero todavía punitivo de alguna manera.

817
00:39:04,200 --> 00:39:08,590
Y ahora, al llegar al límite, esto.

818
00:39:08,590 --> 00:39:10,570
>> [REPRODUCCIÓN DE VÍDEO]

819
00:39:10,570 --> 00:39:13,540
>> [REPRODUCIENDO MÚSICA]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [FIN DE REPRODUCCIÓN]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN: Muy bien, estamos de vuelta.

823
00:40:00,490 --> 00:40:03,680
Y ahora nos fijamos en una de las
primero de nuestros dominios del mundo real

824
00:40:03,680 --> 00:40:08,720
en CS50, el arte de la criptografía,
el arte de enviar y recibir

825
00:40:08,720 --> 00:40:11,840
mensajes secretos, cifrada
mensajes si se quiere,

826
00:40:11,840 --> 00:40:17,060
que sólo puede ser descifrado si tiene
algunos ingrediente clave que el remitente tiene

827
00:40:17,060 --> 00:40:18,030
así como.

828
00:40:18,030 --> 00:40:22,120
Así que para motivar a esto vamos a tomar
Un vistazo a esta cosa aquí,

829
00:40:22,120 --> 00:40:26,750
que es un ejemplo de una
anillo decodificador que secreta

830
00:40:26,750 --> 00:40:34,042
se puede utilizar con el fin de averiguar
lo que es un mensaje secreto en realidad es.

831
00:40:34,042 --> 00:40:35,750
De hecho, de vuelta en el
día en la escuela primaria,

832
00:40:35,750 --> 00:40:38,787
si alguna vez has enviado mensajes secretos a
algún amigo o algún aplastamiento en clase,

833
00:40:38,787 --> 00:40:40,620
que podría haber pensado
estabas siendo inteligente

834
00:40:40,620 --> 00:40:46,530
por el cambio de su pedazo de papel,
al igual que, de A a B y de B a C y C a D,

835
00:40:46,530 --> 00:40:47,590
Etcétera.

836
00:40:47,590 --> 00:40:50,300
Pero ya han sido realmente cifrando
su información, incluso

837
00:40:50,300 --> 00:40:53,300
si era un poco trivial, no era
que dura para que el profesor se da cuenta,

838
00:40:53,300 --> 00:40:55,675
así, si usted acaba de cambiar
B a A y C a B,

839
00:40:55,675 --> 00:40:57,550
que en realidad averiguar
lo que el mensaje era,

840
00:40:57,550 --> 00:40:59,700
pero estabas en la información de cifrado.

841
00:40:59,700 --> 00:41:03,420
>> Sólo estabas haciendo
Simplemente, al igual que Ralphie aquí

842
00:41:03,420 --> 00:41:07,934
en una famosa película que juega
más o menos hasta la saciedad cada invierno.

843
00:41:07,934 --> 00:41:08,600
[REPRODUCCIÓN DE VÍDEO]

844
00:41:08,600 --> 00:41:11,180
-ya Sea sabido por todos que
Ralph Parker está presente

845
00:41:11,180 --> 00:41:14,070
nombrado miembro de la Pequeña
Orphan Annie círculo secreto

846
00:41:14,070 --> 00:41:17,700
y tiene derecho a todos los honores
y beneficios se producen a la misma.

847
00:41:17,700 --> 00:41:24,340
>> -firmado, Little Orphan Annie,
refrendado Pierre Andre, en tinta.

848
00:41:24,340 --> 00:41:27,160
Honores y beneficios,
Ya a la edad de nueve años.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [GRITOS]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Venga.

853
00:41:34,250 --> 00:41:35,210
Vamos a seguir adelante con ella.

854
00:41:35,210 --> 00:41:39,530
No necesito todo ese jazz
sobre contrabandistas y piratas.

855
00:41:39,530 --> 00:41:41,660
>> mañana por la noche para -listen
la aventura de conclusión

856
00:41:41,660 --> 00:41:43,880
del barco pirata negro.

857
00:41:43,880 --> 00:41:46,650
Ahora, es el momento de
mensaje secreto de Annie

858
00:41:46,650 --> 00:41:49,840
para vosotros, los miembros del Círculo Secreto.

859
00:41:49,840 --> 00:41:53,570
Recuerde, los niños, los únicos miembros
del círculo secreto de Annie

860
00:41:53,570 --> 00:41:56,140
puede decodificar el mensaje secreto de Annie.

861
00:41:56,140 --> 00:42:00,340
>> Recuerde, Annie depende de ti.

862
00:42:00,340 --> 00:42:02,880
Establecer sus pasadores a B2.

863
00:42:02,880 --> 00:42:05,230
Aquí está el mensaje.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Estoy En mi primera reunión secreta.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Fue en gran voz esta noche.

868
00:42:15,780 --> 00:42:19,000
Podría decir que esta noche
mensaje era realmente importante.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, eso es un mensaje
Annie de sí misma.

870
00:42:22,694 --> 00:42:23,860
Recuerde, no decirle a nadie.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Segundos más tarde, estoy en el único
habitación de la casa donde un niño de nueve años

873
00:42:32,930 --> 00:42:37,040
podría sentarse en la privacidad y la decodificación.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Fui a la siguiente, E.

876
00:42:42,360 --> 00:42:44,520
>> La primera palabra es ser.

877
00:42:44,520 --> 00:42:49,032
S, que iba a venir más fácil ahora, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Oh, vamos, Ralphie, me tengo que ir!

879
00:42:51,733 --> 00:42:53,688
>> -Voy A estar bien abajo, Ma!

880
00:42:53,688 --> 00:42:54,188
¡Caramba!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, asegúrese a-- estar seguro de qué?

883
00:43:04,060 --> 00:43:05,970
¿Cuál fue la huerfanita
Annie tratando de decir?

884
00:43:05,970 --> 00:43:07,264
Asegúrese de que?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy tiene que
GO, haga el favor de salir?

886
00:43:09,634 --> 00:43:10,480
>> -Todos derecha, Ma!

887
00:43:10,480 --> 00:43:12,880
Voy a estar bien!

888
00:43:12,880 --> 00:43:14,550
>> -I Estaba más cerca ahora.

889
00:43:14,550 --> 00:43:16,620
La tensión era terrible.

890
00:43:16,620 --> 00:43:17,720
¿Qué era?

891
00:43:17,720 --> 00:43:20,170
El destino del planeta
puede colgar de un hilo.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Tiene que ir de Andy!

894
00:43:23,170 --> 00:43:26,890
>> -Voy A estar a la derecha, por amor de Dios!

895
00:43:26,890 --> 00:43:32,680
>> -casi Allí, mis dedos volaban, mi mente
Era una trampa de acero, cada poro vibró.

896
00:43:32,680 --> 00:43:37,198
Era casi clara, sí, sí, sí.

897
00:43:37,198 --> 00:43:43,091
>> -Asegúrese de tomar su Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Un comercial de mala muerte?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Hijo de puta.

903
00:43:54,227 --> 00:43:54,810
[FIN DE REPRODUCCIÓN]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN: OK, entonces
que era un camino muy largo

905
00:43:57,390 --> 00:44:00,660
de la introducción de la criptografía,
y también ovaltine.

906
00:44:00,660 --> 00:44:04,470
De hecho, a partir de este anuncio de edad
aquí, ¿por qué es tan bueno ovaltine?

907
00:44:04,470 --> 00:44:09,470
Es una extracción concentrada de maduro
malta de cebada, leche pura de vaca cremoso,

908
00:44:09,470 --> 00:44:14,360
y especialmente preparado de cacao, junto
con fosfátidos naturales y vitaminas.

909
00:44:14,360 --> 00:44:18,240
Está fortificada con mayor
vitaminas adicionales B y D, ñam.

910
00:44:18,240 --> 00:44:21,600
Y todavía se puede conseguir que, al parecer,
en Amazon, como lo hicimos aquí.

911
00:44:21,600 --> 00:44:24,810
>> Pero la motivación aquí era
introducir la criptografía, en concreto

912
00:44:24,810 --> 00:44:28,340
un tipo de criptografía conocida
como criptografía de clave secreta.

913
00:44:28,340 --> 00:44:34,284
Y como su nombre indica, el conjunto
la seguridad de un sistema de criptografía de clave secreta,

914
00:44:34,284 --> 00:44:36,200
si se quiere, una metodología
por sólo aleatorización

915
00:44:36,200 --> 00:44:40,960
información entre dos personas, es que
sólo el remitente y sólo el destinatario

916
00:44:40,960 --> 00:44:46,980
saber un secreto key-- algún valor, algunos
frase secreta, un número secreto, que

917
00:44:46,980 --> 00:44:50,660
les permite cifrar
y descifrar la información.

918
00:44:50,660 --> 00:44:53,470
Y la criptografía, en realidad,
es sólo esto desde la semana 0.

919
00:44:53,470 --> 00:44:56,715
>> Es un problema donde no hay entradas,
al igual que el mensaje real en Inglés

920
00:44:56,715 --> 00:44:59,340
o cualquier otro idioma que se
desee enviar a alguien de la clase,

921
00:44:59,340 --> 00:45:00,580
oa través de internet.

922
00:45:00,580 --> 00:45:03,840
Hay un poco de salida, que se va
siendo el mensaje codificado que

923
00:45:03,840 --> 00:45:05,250
quiere que el destinatario recibir.

924
00:45:05,250 --> 00:45:07,405
E incluso si alguien en el
medio recibe también,

925
00:45:07,405 --> 00:45:09,780
usted no quiere que se
necesariamente será capaz de descifrarlo,

926
00:45:09,780 --> 00:45:12,840
porque dentro de este
cuadro negro, o algoritmo,

927
00:45:12,840 --> 00:45:17,650
es algún mecanismo, algunos paso a paso
instrucciones, para tomar esa entrada

928
00:45:17,650 --> 00:45:20,710
y convertirlo en el
de salida, es de esperar en una forma segura.

929
00:45:20,710 --> 00:45:23,640
>> Y, de hecho, hay una cierta
Vocabulario en este mundo de la siguiente manera.

930
00:45:23,640 --> 00:45:26,100
El texto plano es la palabra de una
Informático haría

931
00:45:26,100 --> 00:45:28,449
utilizar para describir la entrada
mensaje, como el Inglés

932
00:45:28,449 --> 00:45:31,240
o cualquier idioma que en realidad
querer enviar a algún otro ser humano.

933
00:45:31,240 --> 00:45:35,450
Y a continuación, el texto cifrado es la lucha
al cifrada o encriptada,

934
00:45:35,450 --> 00:45:36,520
versión de la misma.

935
00:45:36,520 --> 00:45:38,750
>> Pero hay otro ingrediente aquí.

936
00:45:38,750 --> 00:45:43,200
Hay otra entrada al
La criptografía de clave secreta.

937
00:45:43,200 --> 00:45:45,200
Y esa es la clave,
que es, en general,

938
00:45:45,200 --> 00:45:48,930
como veremos, un número, o
letra o palabra, cualquiera que sea

939
00:45:48,930 --> 00:45:51,980
el algoritmo que es en realidad espera.

940
00:45:51,980 --> 00:45:53,870
>> Y ¿cómo descifrar la información?

941
00:45:53,870 --> 00:45:55,110
¿Cómo se puede descifrarlo?

942
00:45:55,110 --> 00:45:57,950
Bueno, sólo invierte el
las salidas y las entradas.

943
00:45:57,950 --> 00:46:00,900
>> En otras palabras, una vez que alguien
recibe el mensaje cifrado,

944
00:46:00,900 --> 00:46:03,740
él o ella simplemente tiene
conocer la misma clave.

945
00:46:03,740 --> 00:46:05,700
Han recibido el texto cifrado.

946
00:46:05,700 --> 00:46:09,530
Y conectando los dos
entradas en el sistema de cifrado,

947
00:46:09,530 --> 00:46:14,260
el algoritmo, esta caja de negro, fuera
debe venir del texto claro original.

948
00:46:14,260 --> 00:46:17,830
Y eso es el muy alto nivel
Habida cuenta de lo que es en realidad la criptografía

949
00:46:17,830 --> 00:46:18,590
todo sobre.

950
00:46:18,590 --> 00:46:20,030
>> Así que vamos a llegar allí.

951
00:46:20,030 --> 00:46:22,700
Veamos ahora por debajo
el capó de algo

952
00:46:22,700 --> 00:46:26,000
nos hemos dado por hecho de
la semana pasada, y para esta sesión

953
00:46:26,000 --> 00:46:27,629
aquí-- la cadena.

954
00:46:27,629 --> 00:46:30,295
Una cadena en el extremo del día
es simplemente una secuencia de caracteres.

955
00:46:30,295 --> 00:46:33,610
>> Puede ser que sea hola mundo, o
hola Zamyla, o lo que sea.

956
00:46:33,610 --> 00:46:37,050
Pero, ¿qué significa eso para
ser una secuencia de caracteres?

957
00:46:37,050 --> 00:46:41,520
De hecho, la biblioteca CS50 da
nosotros un tipo de datos llamado cadena.

958
00:46:41,520 --> 00:46:45,140
>> Pero en realidad no hay
tal cosa como una cadena en C.

959
00:46:45,140 --> 00:46:49,450
Realmente es una secuencia de
carácter, caracteres, carácter,

960
00:46:49,450 --> 00:46:52,180
carácter, hacia atrás, hacia atrás, a
hacia atrás, hacia atrás, hacia atrás en el interior

961
00:46:52,180 --> 00:46:54,650
de la memoria del ordenador, o RAM.

962
00:46:54,650 --> 00:46:58,940
Y vamos a ver más en que en el
futuro, cuando nos fijamos en la memoria misma,

963
00:46:58,940 --> 00:47:02,030
y la utilización, y el
amenazas que están involucrados.

964
00:47:02,030 --> 00:47:04,100
>> Pero vamos a considerar la cadena Zamyla.

965
00:47:04,100 --> 00:47:07,480
Por lo que sólo el nombre de
el ser humano aquí, Zamyla,

966
00:47:07,480 --> 00:47:12,030
que es una secuencia de
caracteres, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Y ahora vamos a suponer que el nombre de Zamyla
está siendo almacenado en el interior de un ordenador

968
00:47:16,020 --> 00:47:16,880
programa.

969
00:47:16,880 --> 00:47:20,830
>> Bueno, es lógico pensar que deberíamos
ser capaz de mirar a esos personajes

970
00:47:20,830 --> 00:47:21,590
individualmente.

971
00:47:21,590 --> 00:47:24,710
Así que sólo voy a dibujar un poco
caja alrededor el nombre de Zamyla aquí.

972
00:47:24,710 --> 00:47:31,580
Y es el caso en C que cuando se
tener una cadena, como Zamyla-- y tal vez

973
00:47:31,580 --> 00:47:34,940
esa cadena ha vuelto de
una función como cadena GET,

974
00:47:34,940 --> 00:47:38,540
en realidad se puede manipular
que carácter por carácter.

975
00:47:38,540 --> 00:47:42,070
>> Ahora, esto es pertinente para la
conversación en parte, porque

976
00:47:42,070 --> 00:47:46,420
en la criptografía si desea cambiar
De A a B y de B a C y C a D,

977
00:47:46,420 --> 00:47:49,650
y así sucesivamente, lo que necesita para poder
mirar los caracteres individuales

978
00:47:49,650 --> 00:47:50,190
en una cadena.

979
00:47:50,190 --> 00:47:52,695
Tienes que ser capaz de cambiar
la Z a otra cosa, la A

980
00:47:52,695 --> 00:47:55,280
a otra cosa, el M de
otra cosa, y así sucesivamente.

981
00:47:55,280 --> 00:47:58,000
Y por lo que necesitamos una manera,
programación, por lo

982
00:47:58,000 --> 00:48:03,020
para hablar, en C para ser capaz de cambiar
y mirar las letras individuales.

983
00:48:03,020 --> 00:48:05,690
Y podemos hacer esto de la siguiente manera.

984
00:48:05,690 --> 00:48:08,340
>> Déjame ir la cabeza hacia atrás en el IDE CS50.

985
00:48:08,340 --> 00:48:11,130
Y déjame ir por delante
y crear un nuevo archivo

986
00:48:11,130 --> 00:48:16,134
que voy a llamar a este tiempo string0,
como nuestro primer ejemplo de ello, punto c.

987
00:48:16,134 --> 00:48:18,300
Y voy a seguir adelante
y el látigo de la siguiente manera.

988
00:48:18,300 --> 00:48:22,870
>> Por lo que incluyen CS50.h, y
a continuación, incluir io.h estándar,

989
00:48:22,870 --> 00:48:25,990
el cual casi siempre voy a
a utilizar en mis programas, al menos

990
00:48:25,990 --> 00:48:26,780
inicialmente.

991
00:48:26,780 --> 00:48:32,180
int vacío principal, y luego aquí estoy
va a hacer cuerdas consigue llegar cadena.

992
00:48:32,180 --> 00:48:35,260
Y luego voy a
seguir adelante y hacerlo.

993
00:48:35,260 --> 00:48:37,460
Quiero ir por delante
y, como una comprobación de validez,

994
00:48:37,460 --> 00:48:43,607
acaba de decir, hola, s por ciento,
punto y coma, hace que la cadena 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, ¿qué he hecho aquí?

996
00:48:44,690 --> 00:48:45,930
Oh, no me conecto.

997
00:48:45,930 --> 00:48:48,120
Así lección aprendida, que
No fue intencional.

998
00:48:48,120 --> 00:48:52,480
>> Así error, más ciento
conversiones que los argumentos de datos.

999
00:48:52,480 --> 00:48:54,940
Y aquí es donde, en
7-- línea OK, por lo que tengo,

1000
00:48:54,940 --> 00:48:56,690
entre comillas, eso es
mi cadena de printf.

1001
00:48:56,690 --> 00:48:58,151
Tengo un signo de porcentaje.

1002
00:48:58,151 --> 00:48:59,650
Pero me falta el segundo argumento.

1003
00:48:59,650 --> 00:49:03,190
>> Me falta la coma s, que
Yo tenía en los ejemplos anteriores.

1004
00:49:03,190 --> 00:49:06,650
Así que una buena oportunidad de corregir
una más error, por accidente.

1005
00:49:06,650 --> 00:49:09,950
Y ahora me deja correr
string0, el tipo de Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, hola Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Así que nos hemos quedado este tipo de programa
un par de veces diferentes ahora.

1008
00:49:14,144 --> 00:49:16,310
Pero vamos a hacer algo una
poco diferente esta vez.

1009
00:49:16,310 --> 00:49:19,450
En lugar de sólo la impresión de Zamyla
Nombre del conjunto con printf,

1010
00:49:19,450 --> 00:49:21,350
vamos a hacerlo carácter por carácter.

1011
00:49:21,350 --> 00:49:22,700
>> Voy a utilizar un bucle.

1012
00:49:22,700 --> 00:49:26,160
Y voy a entregarme
una variable de conteo, llamado i.

1013
00:49:26,160 --> 00:49:33,530
Y voy a mantener la iteración, por lo
siempre y cuando i es menor que la longitud de s.

1014
00:49:33,530 --> 00:49:35,930
>> Resulta, no lo hicimos
hacer esta última vez,

1015
00:49:35,930 --> 00:49:39,100
que c viene con una
función llamada Stirling.

1016
00:49:39,100 --> 00:49:42,690
De vuelta en el día, y en general
aún cuando la aplicación de funciones,

1017
00:49:42,690 --> 00:49:45,405
los seres humanos a menudo se elige muy
nombres sucintas ese tipo de sonido

1018
00:49:45,405 --> 00:49:48,280
al igual que lo que quiere, aunque es
faltan algunas vocales o letras.

1019
00:49:48,280 --> 00:49:50,660
Así Stirling es el
el nombre de una función que

1020
00:49:50,660 --> 00:49:53,880
toma una discusión entre
paréntesis que debe ser una cadena.

1021
00:49:53,880 --> 00:49:56,910
Y que sólo se devuelve un entero,
la longitud de esa cadena.

1022
00:49:56,910 --> 00:50:00,580
>> Por lo que este bucle en la línea 7 que está pasando
para empezar a contar a i es igual a 0.

1023
00:50:00,580 --> 00:50:02,530
Se va a incrementar
i en cada iteración

1024
00:50:02,530 --> 00:50:04,350
por 1, tal como lo hemos estado haciendo un par de veces.

1025
00:50:04,350 --> 00:50:06,780
Pero va a hacer solamente
esto hasta el punto

1026
00:50:06,780 --> 00:50:09,660
cuando i es la longitud
de la propia cadena.

1027
00:50:09,660 --> 00:50:14,520
>> Así que este es un modo de, en última instancia,
iterar sobre los caracteres

1028
00:50:14,520 --> 00:50:17,430
en la cadena como es la siguiente.

1029
00:50:17,430 --> 00:50:20,670
Voy a imprimir no es una
cadena entera, pero por ciento c,

1030
00:50:20,670 --> 00:50:22,860
un solo carácter
seguido de una nueva línea.

1031
00:50:22,860 --> 00:50:24,880
Y luego voy a
vaya por delante, y necesito

1032
00:50:24,880 --> 00:50:29,080
decir Quiero imprimir
carácter de orden i del s.

1033
00:50:29,080 --> 00:50:33,450
>> Así que si i es la variable que indica
el índice de la cadena, donde

1034
00:50:33,450 --> 00:50:37,230
que está en ella, necesita ser capaz de
decir, dame el carácter de orden i del s.

1035
00:50:37,230 --> 00:50:40,390
Y c tiene una forma de hacer
esto con corchetes.

1036
00:50:40,390 --> 00:50:43,679
Basta con que diga el nombre de la
cadena, que en este caso es s.

1037
00:50:43,679 --> 00:50:46,970
A continuación, utilice corchetes, que son
por lo general justo por encima del Retorno o Intro

1038
00:50:46,970 --> 00:50:48,110
tecla en el teclado.

1039
00:50:48,110 --> 00:50:52,410
Y a continuación, poner el índice de la
carácter que desea imprimir.

1040
00:50:52,410 --> 00:50:55,960
Así que el índice se va a ser una
number-- 0, o 1, o 2, o 3, o de punto,

1041
00:50:55,960 --> 00:50:57,590
punto, punto, algún otro número.

1042
00:50:57,590 --> 00:51:00,920
>> Y nos aseguramos de que se va a
ser el número correcto, porque yo

1043
00:51:00,920 --> 00:51:02,360
empezará a contar a 0.

1044
00:51:02,360 --> 00:51:07,020
Y por defecto, el primer carácter
en una cadena es por convención 0.

1045
00:51:07,020 --> 00:51:09,230
Y el segundo carácter es el soporte 1.

1046
00:51:09,230 --> 00:51:11,120
Y el tercero es el soporte 2.

1047
00:51:11,120 --> 00:51:13,630
Y usted no quiere ir demasiado
ahora, pero no vamos porque somos

1048
00:51:13,630 --> 00:51:17,780
ir sólo para incrementar i hasta que se
es igual a la longitud de la cadena.

1049
00:51:17,780 --> 00:51:20,210
Y en ese momento,
Este bucle se detendrá.

1050
00:51:20,210 --> 00:51:25,550
>> Así que déjame ir adelante y guardar esta
programa y ejecuta make cadena de 0.

1051
00:51:25,550 --> 00:51:28,400
Pero la he cagado.

1052
00:51:28,400 --> 00:51:35,390
Declarando implícitamente función de biblioteca
Stirling con tal tipo y tal-- ahora,

1053
00:51:35,390 --> 00:51:36,430
esto suena familiar.

1054
00:51:36,430 --> 00:51:37,440
Pero no es printf.

1055
00:51:37,440 --> 00:51:38,540
Y no es llegar cadena.

1056
00:51:38,540 --> 00:51:40,480
>> No me equivoco en
de la misma manera este tiempo.

1057
00:51:40,480 --> 00:51:45,100
Pero notar aquí un poco más abajo
además, incluir la cabecera string.h,

1058
00:51:45,100 --> 00:51:47,210
proporcionar explícitamente el
declaración de Stirling.

1059
00:51:47,210 --> 00:51:48,820
Así que en realidad hay una pista en ese país.

1060
00:51:48,820 --> 00:51:51,670
>> Y de hecho resulta
hay otro archivo de cabecera

1061
00:51:51,670 --> 00:51:53,970
que nosotros no hemos usado
sin embargo, en la clase, pero es

1062
00:51:53,970 --> 00:51:56,480
entre los disponibles
a usted, llamada string.h.

1063
00:51:56,480 --> 00:52:00,930
Y en ese archivo, string.h
Stirling es declarada.

1064
00:52:00,930 --> 00:52:05,220
Así que permítanme seguir adelante y
guardar esta, hacer cuerdas

1065
00:52:05,220 --> 00:52:08,040
0-- agradable, no hay mensajes de error esta vez.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, y
Estoy a punto de golpear Enter,

1067
00:52:12,290 --> 00:52:16,710
momento en el cual se va getString
para devolver la cadena, lo puso en s.

1068
00:52:16,710 --> 00:52:21,890
Luego de que para el bucle se va a repetir
sobre los personajes de S de una en una,

1069
00:52:21,890 --> 00:52:28,420
y les imprima una por línea, porque
Tenía que n barra invertida al final.

1070
00:52:28,420 --> 00:52:34,530
Así que podría omitir que la barra invertida
n, y luego simplemente imprimir toda Zamyla

1071
00:52:34,530 --> 00:52:37,460
en la misma línea,
reimplementar con eficacia

1072
00:52:37,460 --> 00:52:38,999
printf, que no es del todo útil.

1073
00:52:38,999 --> 00:52:40,540
Pero en este caso, yo no he hecho eso.

1074
00:52:40,540 --> 00:52:43,610
De hecho, he impreso una
carácter a la vez, uno por línea,

1075
00:52:43,610 --> 00:52:45,400
por lo que vemos en realidad el efecto.

1076
00:52:45,400 --> 00:52:46,900
>> Sin embargo, debo señalar una cosa aquí.

1077
00:52:46,900 --> 00:52:48,930
Y vamos a volver a
esto en una semana futuro.

1078
00:52:48,930 --> 00:52:52,650
Resulta que este
código es potencialmente defectuoso.

1079
00:52:52,650 --> 00:52:56,560
>> Resulta que la cadena get
y algunas otras funciones en la vida

1080
00:52:56,560 --> 00:53:00,280
no necesariamente siempre
regrese lo que estás esperando.

1081
00:53:00,280 --> 00:53:03,010
Sabemos por última clase
en este momento que llegar

1082
00:53:03,010 --> 00:53:04,960
cadena se supone que debe devolver una cadena.

1083
00:53:04,960 --> 00:53:09,900
Pero lo que si el usuario escribe a cabo tales
una palabra larga, o un párrafo, o un ensayo

1084
00:53:09,900 --> 00:53:13,010
que simplemente no hay suficiente
memoria en el ordenador para adaptarse a ella.

1085
00:53:13,010 --> 00:53:15,410
>> Al igual, ¿y si algo va
mal debajo de la campana?

1086
00:53:15,410 --> 00:53:18,400
Puede que no sucede a menudo,
pero podría suceder una vez

1087
00:53:18,400 --> 00:53:21,520
desde hace tiempo, con muy poca frecuencia.

1088
00:53:21,520 --> 00:53:25,460
Y así resulta que la cadena get
y funciona como lo hacen no necesariamente

1089
00:53:25,460 --> 00:53:26,380
siempre devuelven cadenas.

1090
00:53:26,380 --> 00:53:30,680
Podrían volver algún valor de error,
algún valor centinela por así decirlo,

1091
00:53:30,680 --> 00:53:32,612
que indica que
algo ha ido mal.

1092
00:53:32,612 --> 00:53:35,320
Y sólo se sabría esto desde
después de haber aprendido en clase ahora,

1093
00:53:35,320 --> 00:53:37,700
o de haber leído algunas más documentación.

1094
00:53:37,700 --> 00:53:43,120
Resulta que la cadena get
puede devolver un valor llamado nulo.

1095
00:53:43,120 --> 00:53:46,220
Nulo es un valor especial que vamos a
volver en una semana futuro.

1096
00:53:46,220 --> 00:53:50,420
Pero por ahora, sólo sé que si quiero
a ser muy adecuado para avanzar

1097
00:53:50,420 --> 00:53:52,650
utilizando cadena GET, me
No sólo debe llamarlo,

1098
00:53:52,650 --> 00:53:56,870
y ciegamente utilizar su valor de retorno,
confiando en que se trata de una cadena.

1099
00:53:56,870 --> 00:53:59,420
>> Debo decir en primer lugar,
Hey, espera un minuto, sólo se

1100
00:53:59,420 --> 00:54:03,380
proceder si s no es igual
null, donde null, de nuevo,

1101
00:54:03,380 --> 00:54:04,660
es sólo un valor especial.

1102
00:54:04,660 --> 00:54:07,770
Y es el único valor especial
tiene que preocuparse de conseguir para la cadena.

1103
00:54:07,770 --> 00:54:10,900
Obtener cadena es bien va
para devolver una cadena o nula.

1104
00:54:10,900 --> 00:54:17,219
>> Y este punto de exclamación signo de igual
es posible saber de tal clase de matemáticas

1105
00:54:17,219 --> 00:54:20,510
que puede dibujar con un signo igual
una línea a través de él para indicar no es igual.

1106
00:54:20,510 --> 00:54:23,135
Eso no es por lo general un carácter
puede escribir en su teclado.

1107
00:54:23,135 --> 00:54:26,480
Y así, en la mayoría de los lenguajes de programación,
cuando se quiere decir que no es igual,

1108
00:54:26,480 --> 00:54:29,160
se utiliza un signo de exclamación,
también conocido como explosión.

1109
00:54:29,160 --> 00:54:33,180
Así que usted dice es igual a la explosión, la cual
significa que no es igual, lógicamente.

1110
00:54:33,180 --> 00:54:38,060
Es igual que no hay un mayor
que, o igual a, o menos de

1111
00:54:38,060 --> 00:54:41,270
o igual a la clave en el teclado
que lo hace todo en un solo símbolo.

1112
00:54:41,270 --> 00:54:44,020
Por eso es que, en los ejemplos anteriores,
que hizo un paréntesis abierto, y luego

1113
00:54:44,020 --> 00:54:48,670
un signo de igualdad, con el fin de hacer
mayor que o, por ejemplo, menos de.

1114
00:54:48,670 --> 00:54:49,910
>> ¿Cuál es la comida para llevar en esta lista?

1115
00:54:49,910 --> 00:54:53,880
Esto es simplemente una manera de ahora
la introducción de esta sintaxis, esta característica,

1116
00:54:53,880 --> 00:54:57,390
iteración en persona
caracteres de una cadena.

1117
00:54:57,390 --> 00:55:00,260
Y al igual que los cuadrados
soportes le permiten obtener en ellos,

1118
00:55:00,260 --> 00:55:03,790
considerar los corchetes de la manera
tipo de alusión a este subyacente

1119
00:55:03,790 --> 00:55:06,040
diseño, de modo que cada
carácter dentro de una cadena

1120
00:55:06,040 --> 00:55:10,180
es una especie de caja en algún lugar debajo
la campana en la memoria del equipo.

1121
00:55:10,180 --> 00:55:12,340
>> Pero vamos a hacer una variante de este.

1122
00:55:12,340 --> 00:55:14,880
Resulta que este
programa es correcto.

1123
00:55:14,880 --> 00:55:18,810
Así por ejes de CS50 para evaluar
código, esto es correcto ahora.

1124
00:55:18,810 --> 00:55:22,959
Sobre todo ahora que estoy comprobando
null, este programa nunca debe bloquearse.

1125
00:55:22,959 --> 00:55:24,500
Y yo sólo sé que a partir de la experiencia.

1126
00:55:24,500 --> 00:55:28,040
Pero no hay nada más que
realmente podemos equivocar aquí.

1127
00:55:28,040 --> 00:55:31,860
Pero no es muy bien diseñado,
porque vamos a volver a lo básico.

1128
00:55:31,860 --> 00:55:34,450
>> Primeros principios--
lo que hace un bucle for hacer?

1129
00:55:34,450 --> 00:55:36,290
Un bucle hace tres cosas.

1130
00:55:36,290 --> 00:55:39,340
Se inicializa algunos
valor, si se le pregunta a.

1131
00:55:39,340 --> 00:55:41,770
Se comprueba una condición.

1132
00:55:41,770 --> 00:55:45,380
Y a continuación, después de cada
iteración, después de cada ciclo,

1133
00:55:45,380 --> 00:55:49,330
se incrementa algunos
valor o valores, aquí.

1134
00:55:49,330 --> 00:55:50,600
>> ¿Así que qué significa eso?

1135
00:55:50,600 --> 00:55:52,940
Inicializamos i a 0.

1136
00:55:52,940 --> 00:55:58,610
Comprobamos y nos aseguramos i es menor que
la longitud de s, que es Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
por lo que es menos de 6.

1138
00:55:59,900 --> 00:56:02,590
Y, de hecho, 0 cuando menos de 6.

1139
00:56:02,590 --> 00:56:05,580
>> Imprimimos Z del nombre de Zamyla.

1140
00:56:05,580 --> 00:56:08,080
Entonces incrementamos i 0-1.

1141
00:56:08,080 --> 00:56:11,290
A continuación, comprobar, es menos 1
que la longitud de s?

1142
00:56:11,290 --> 00:56:13,270
La longitud de s es 6.

1143
00:56:13,270 --> 00:56:13,950
Sí lo es.

1144
00:56:13,950 --> 00:56:16,880
>> Así es la impresión de una a nombre de Zamyla, ZA.

1145
00:56:16,880 --> 00:56:20,090
Incrementamos i desde 0, a 1, a 2.

1146
00:56:20,090 --> 00:56:23,720
A continuación, comprobar, es inferior a 2
la longitud del nombre de Zamyla.

1147
00:56:23,720 --> 00:56:25,380
6- 2 es por lo menos de 6.

1148
00:56:25,380 --> 00:56:30,460
Sí, vamos a imprimir ahora en M
El nombre de Zamyla, el tercer personaje.

1149
00:56:30,460 --> 00:56:34,110
>> La clave aquí es que en cada
iteración de la historia, estoy comprobando,

1150
00:56:34,110 --> 00:56:37,810
es i menor que la longitud de Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Pero el problema es que
Stirling no es una propiedad.

1152
00:56:40,350 --> 00:56:43,100
Aquellos de ustedes que han programado
antes en Java o en otros idiomas

1153
00:56:43,100 --> 00:56:46,310
puede conocer la longitud de una cadena es
una propiedad, sólo algunas de sólo lectura valor.

1154
00:56:46,310 --> 00:56:50,220
>> En C, en este caso, si esto es
una función que es, literalmente,

1155
00:56:50,220 --> 00:56:53,520
contando el número de
personajes de Zamyla cada vez

1156
00:56:53,520 --> 00:56:54,740
llamamos a esa función.

1157
00:56:54,740 --> 00:56:58,500
Cada vez que se pida el equipo para utilizar
Stirling, que es echar un vistazo a Zamyla,

1158
00:56:58,500 --> 00:57:01,960
y diciendo Z-A-H-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Y devuelve 6.

1160
00:57:02,962 --> 00:57:04,920
La próxima vez que llame
que dentro de ese bucle,

1161
00:57:04,920 --> 00:57:08,610
que va a mirar a Zamyla
de nuevo, por ejemplo Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Y se va a volver 6.

1163
00:57:10,320 --> 00:57:12,980
¿Cuál es tan estúpida acerca de este diseño?

1164
00:57:12,980 --> 00:57:17,700
>> ¿Por qué mi código no un 5 sobre 5
para el diseño en este momento, por así decirlo?

1165
00:57:17,700 --> 00:57:20,600
Bueno, yo estoy haciendo una
pregunta innecesariamente.

1166
00:57:20,600 --> 00:57:23,030
Estoy haciendo más trabajo de lo que necesito.

1167
00:57:23,030 --> 00:57:25,370
>> Así que, aunque la
respuesta es correcta, estoy

1168
00:57:25,370 --> 00:57:29,560
pidiendo a la computadora, lo que es
la longitud de Zamyla de nuevo,

1169
00:57:29,560 --> 00:57:31,380
y otra vez, y otra vez, y otra vez?

1170
00:57:31,380 --> 00:57:33,980
Y la respuesta es
nunca va a cambiar.

1171
00:57:33,980 --> 00:57:35,900
Siempre va a ser 6.

1172
00:57:35,900 --> 00:57:39,730
>> Así que una solución mejor que esto
sería esta próxima versión.

1173
00:57:39,730 --> 00:57:43,390
Déjame ir por delante y lo puso en una
archivo separado llamado string1.c,

1174
00:57:43,390 --> 00:57:44,990
sólo para mantenerlo separado.

1175
00:57:44,990 --> 00:57:47,260
Y resulta que en una de
lazo, en realidad se puede

1176
00:57:47,260 --> 00:57:50,210
declarar múltiples variables a la vez.

1177
00:57:50,210 --> 00:57:53,460
>> Así que voy a seguir I y ponerlo a 0.

1178
00:57:53,460 --> 00:57:56,190
Pero también voy a
añadir una coma, y ​​decir:

1179
00:57:56,190 --> 00:58:01,050
dame una variable llamada n, cuya
valor es igual a la longitud de la cadena del s.

1180
00:58:01,050 --> 00:58:09,410
Y ahora, por favor haga mi condición
siempre que i es menor que n.

1181
00:58:09,410 --> 00:58:14,140
>> Así de esta manera, la lógica es
idénticos al final del día.

1182
00:58:14,140 --> 00:58:18,280
Pero estoy recordando la
valor 6, en este caso.

1183
00:58:18,280 --> 00:58:19,780
¿Cuál es la longitud del nombre de Zamyla?

1184
00:58:19,780 --> 00:58:20,860
Y lo estoy poniendo en el n.

1185
00:58:20,860 --> 00:58:23,050
>> Y todavía estoy comprobando
la condición cada vez.

1186
00:58:23,050 --> 00:58:24,300
Es de 0 a menos de 6?

1187
00:58:24,300 --> 00:58:25,600
1 es inferior a 6?

1188
00:58:25,600 --> 00:58:28,600
Es de 2 a menos de 6, y así sucesivamente?

1189
00:58:28,600 --> 00:58:31,914
>> Pero yo no estoy pidiendo al equipo
de nuevo, y otra vez, lo que es

1190
00:58:31,914 --> 00:58:33,080
la longitud del nombre de Zamyla?

1191
00:58:33,080 --> 00:58:34,320
¿Cuál es la longitud del nombre de Zamyla?

1192
00:58:34,320 --> 00:58:35,986
¿Cuál es la longitud del nombre de esta Zamyla?

1193
00:58:35,986 --> 00:58:40,440
Estoy literalmente, recordando que el primero y
Sólo responder en esta segunda variable n.

1194
00:58:40,440 --> 00:58:45,280
Así que esto ahora sería no sólo
correcta, sino también bien diseñado.

1195
00:58:45,280 --> 00:58:46,670
>> Ahora, ¿qué pasa con el estilo?

1196
00:58:46,670 --> 00:58:48,866
He nombrado mi variables
bastante bien, diría yo.

1197
00:58:48,866 --> 00:58:50,240
Son súper sucinta en este momento.

1198
00:58:50,240 --> 00:58:52,090
Y eso es totalmente bien.

1199
00:58:52,090 --> 00:58:55,120
>> Si sólo tiene una
cadena en un programa,

1200
00:58:55,120 --> 00:58:56,860
que también podría llamarlo s para cadenas.

1201
00:58:56,860 --> 00:58:59,370
Si sólo tiene una variable
para contar en un programa,

1202
00:58:59,370 --> 00:59:00,710
que también podría llamarlo i.

1203
00:59:00,710 --> 00:59:03,500
Si usted tiene una longitud, n
es super comunes también.

1204
00:59:03,500 --> 00:59:05,800
Pero no he comentado nada de mi código.

1205
00:59:05,800 --> 00:59:09,200
>> No he informado a la reader--
si ese es mi TF, o TA,

1206
00:59:09,200 --> 00:59:12,460
o simplemente colleague-- lo que se supone
a estar pasando en este programa.

1207
00:59:12,460 --> 00:59:15,760
Y así conseguir un buen estilo,
lo que yo quiero hacer

1208
00:59:15,760 --> 00:59:24,580
es algo esto-
como pedir usuario para la entrada.

1209
00:59:24,580 --> 00:59:26,670
Y podría reescribir
esta cualquier número de maneras.

1210
00:59:26,670 --> 00:59:35,630
>> Asegúrese de s-- asegurarse get
string devuelve una cadena.

1211
00:59:35,630 --> 00:59:40,280
Y luego, en aquí-- y esto es quizás
la iterate comment-- más importante

1212
00:59:40,280 --> 00:59:44,450
sobre los personajes de s uno a la vez.

1213
00:59:44,450 --> 00:59:47,060
Y podría utilizar cualquier
elección del idioma Inglés

1214
00:59:47,060 --> 00:59:49,650
aquí para describir cada
de estos trozos de código.

1215
00:59:49,650 --> 00:59:52,740
>> Nótese que no he puesto una
observaciones sobre cada línea de código,

1216
00:59:52,740 --> 00:59:55,690
en realidad sólo en la interesante
unos, los que

1217
00:59:55,690 --> 00:59:59,460
tener algún sentido de que podría
querer hacer muy claro para alguien

1218
00:59:59,460 --> 01:00:00,460
la lectura de mi código.

1219
01:00:00,460 --> 01:00:02,920
Y ¿por qué llama llegar
pregunta al usuario por la cadena de entrada?

1220
01:00:02,920 --> 01:00:05,450
Incluso que uno no es necesariamente
todo lo que descriptivo.

1221
01:00:05,450 --> 01:00:09,340
Pero ayuda a contar una historia, porque el
segunda línea de la historia es, asegúrese

1222
01:00:09,340 --> 01:00:10,740
obtener una cadena de devuelve una cadena.

1223
01:00:10,740 --> 01:00:14,260
>> Y la tercera línea de la historia es,
iterar sobre los personajes de uno s

1224
01:00:14,260 --> 01:00:15,380
a la vez.

1225
01:00:15,380 --> 01:00:17,920
Y ahora sólo por si acaso,
Voy a seguir adelante y añadir

1226
01:00:17,920 --> 01:00:24,560
un comentario más que simplemente
dice impresión carácter i-ésimo en el s.

1227
01:00:24,560 --> 01:00:26,520
Ahora, ¿qué he hecho
¿al final del día?

1228
01:00:26,520 --> 01:00:29,190
>> He añadido un poco de Inglés
palabras en forma de comentarios.

1229
01:00:29,190 --> 01:00:32,700
significa el símbolo de barra barra, hey,
ordenador es para el ser humano,

1230
01:00:32,700 --> 01:00:33,820
no para usted, su equipo.

1231
01:00:33,820 --> 01:00:35,119
Así que, lógicamente, son ignorados.

1232
01:00:35,119 --> 01:00:35,910
Ellos están ahí.

1233
01:00:35,910 --> 01:00:39,830
>> Y, de hecho, CS50 IDE los muestra como
gris, que son útiles, pero no clave

1234
01:00:39,830 --> 01:00:41,000
al programa.

1235
01:00:41,000 --> 01:00:42,570
Observe lo que puede hacer ahora.

1236
01:00:42,570 --> 01:00:44,950
Si usted sabe C
programación o no,

1237
01:00:44,950 --> 01:00:47,722
simplemente se ponen de espalda en este
programa y descremada los comentarios.

1238
01:00:47,722 --> 01:00:50,180
Preguntar al usuario para la entrada, asegúrese
llegar cadena devuelve una cadena,

1239
01:00:50,180 --> 01:00:53,009
iterar sobre los personajes de s
uno a la vez, imprimir el carácter

1240
01:00:53,009 --> 01:00:55,550
i-ésimo carácter en s-- no lo hace
incluso tener que mirar el código

1241
01:00:55,550 --> 01:00:57,270
para entender lo que hace este programa.

1242
01:00:57,270 --> 01:01:00,280
Y, mejor aún, si usted mira
en este programa de una semana o dos,

1243
01:01:00,280 --> 01:01:02,280
o un mes, o un año,
usted también no tiene

1244
01:01:02,280 --> 01:01:04,420
para mirar al código,
tratando de recordar,

1245
01:01:04,420 --> 01:01:06,630
¿Qué estaba tratando de hacer con este código?

1246
01:01:06,630 --> 01:01:07,770
>> Usted mismo ha dicho.

1247
01:01:07,770 --> 01:01:11,660
Lo has descrito por sí mismo,
o algún colega, o TA, o TF.

1248
01:01:11,660 --> 01:01:14,860
Y así, este sería ahora
correcta, y el buen diseño,

1249
01:01:14,860 --> 01:01:18,210
y, finalmente, un buen estilo también.

1250
01:01:18,210 --> 01:01:19,990
Lo mismo ocurre con tener eso en mente.

1251
01:01:19,990 --> 01:01:22,200
>> Así que hay otra
Lo que voy a hacer aquí

1252
01:01:22,200 --> 01:01:28,240
que ahora pueden revelar exactamente lo que está
pasando por debajo del capó.

1253
01:01:28,240 --> 01:01:30,390
Así que hay esta característica
en C, y otros idiomas,

1254
01:01:30,390 --> 01:01:33,010
llamada encasillamiento
que, o bien implícitamente

1255
01:01:33,010 --> 01:01:37,250
o explícitamente permite convertir
de un tipo de datos a otro.

1256
01:01:37,250 --> 01:01:39,800
Hemos estado tratando por lo
la fecha de hoy con cuerdas.

1257
01:01:39,800 --> 01:01:41,250
>> Y las secuencias son caracteres.

1258
01:01:41,250 --> 01:01:44,910
Pero recordar desde la semana
0, ¿cuáles son los caracteres?

1259
01:01:44,910 --> 01:01:49,334
Los personajes son simplemente una abstracción
en la parte superior de los números decimales numbers--,

1260
01:01:49,334 --> 01:01:52,500
y los números decimales son en realidad una
la abstracción en la parte superior de los números binarios,

1261
01:01:52,500 --> 01:01:53,720
como lo definimos.

1262
01:01:53,720 --> 01:01:55,540
>> Así caracteres son números.

1263
01:01:55,540 --> 01:01:58,410
Y los números son caracteres,
simplemente en función del contexto.

1264
01:01:58,410 --> 01:02:01,250
Y resulta que en el interior
de un programa de ordenador,

1265
01:02:01,250 --> 01:02:06,830
se puede especificar la forma en que desea buscar
en los bits dentro de ese programa?

1266
01:02:06,830 --> 01:02:10,400
>> Recuerde que en la semana 0 que teníamos
Ascii, que es sólo el código

1267
01:02:10,400 --> 01:02:11,620
cartas de asignación a los números.

1268
01:02:11,620 --> 01:02:13,660
Y dijimos, el capital A es 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B es 66, y así sucesivamente.

1270
01:02:15,860 --> 01:02:20,500
>> Y aviso, que esencialmente tenemos en caracteres
la fila superior aquí, como los llamaría C,

1271
01:02:20,500 --> 01:02:23,400
caracteres, y luego
enteros en la segunda fila.

1272
01:02:23,400 --> 01:02:28,180
Y resulta que se puede convertir
sin problemas entre los dos, por lo general.

1273
01:02:28,180 --> 01:02:30,042
Y si queremos hacer
esto deliberadamente, se

1274
01:02:30,042 --> 01:02:31,750
puede ser que desee para hacer frente
algo como esto.

1275
01:02:31,750 --> 01:02:33,590
>> Lo que se quiere convertir
mayúscula para bajar

1276
01:02:33,590 --> 01:02:35,330
caso, o minúsculas a mayúsculas.

1277
01:02:35,330 --> 01:02:38,000
Y resulta que no hay
en realidad un patrón aquí

1278
01:02:38,000 --> 01:02:39,900
podemos abarcar en un momento.

1279
01:02:39,900 --> 01:02:44,120
Pero vamos a ver por primera vez en una
ejemplo de hacer esto explícitamente.

1280
01:02:44,120 --> 01:02:46,340
>> Voy a volver al IDE CS50.

1281
01:02:46,340 --> 01:02:50,640
Voy a crear una
archivo llamado ASCII 0.c.

1282
01:02:50,640 --> 01:02:55,960
Y voy a seguir adelante y añadir mi
io.h estándar en la parte superior, nula principal int

1283
01:02:55,960 --> 01:02:57,370
en la parte superior de mi función.

1284
01:02:57,370 --> 01:03:02,700
Y a continuación, sólo voy a hacer lo
following-- un bucle de i es igual,

1285
01:03:02,700 --> 01:03:04,610
digamos, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Y entonces va a ser inferior a
65, además de 26 letras en el alfabeto.

1287
01:03:10,460 --> 01:03:12,640
Así que voy a dejar que el ordenador
hacer los cálculos para mí no.

1288
01:03:12,640 --> 01:03:15,100
Y luego dentro de este bucle,
lo voy a imprimir?

1289
01:03:15,100 --> 01:03:19,230
>> % C es n% i barra invertida.

1290
01:03:19,230 --> 01:03:21,290
Y ahora quiero enchufar dos valores.

1291
01:03:21,290 --> 01:03:24,530
He puesto temporalmente pregunta
marca allí para invitar a la pregunta.

1292
01:03:24,530 --> 01:03:29,940
>> Quiero repetir desde el 65 en adelante
durante 26 letras del alfabeto,

1293
01:03:29,940 --> 01:03:35,190
impresión de que en cada iteración
equivalente integrante del carácter.

1294
01:03:35,190 --> 01:03:38,299
En otras palabras, quiero
iterar impresión de más de 26 números

1295
01:03:38,299 --> 01:03:41,590
lo que es el carácter ASCII, la carta,
y lo es-- el número correspondiente

1296
01:03:41,590 --> 01:03:44,650
en realidad sólo recreando
el gráfico de esa diapositiva.

1297
01:03:44,650 --> 01:03:47,010
Entonces, ¿qué deberían ser estos signos de interrogación?

1298
01:03:47,010 --> 01:03:51,760
>> Pues bien, resulta que el segundo
uno solo debe ser la variable i.

1299
01:03:51,760 --> 01:03:53,860
Quiero ver que a medida que un número.

1300
01:03:53,860 --> 01:03:58,920
Y el argumento de media
aquí, puedo decirle a la computadora

1301
01:03:58,920 --> 01:04:03,470
para tratar ese entero
i como un carácter, de modo que

1302
01:04:03,470 --> 01:04:05,880
para sustituirlo aquí por ciento C.

1303
01:04:05,880 --> 01:04:07,990
>> En otras palabras, si yo, el
programador humano, saber

1304
01:04:07,990 --> 01:04:09,865
estos son sólo números
al final del día.

1305
01:04:09,865 --> 01:04:12,500
Y sé que el 65 debe
asignar a un poco de carácter.

1306
01:04:12,500 --> 01:04:15,310
Con esta conversión explícita,
con un paréntesis,

1307
01:04:15,310 --> 01:04:18,840
el nombre del tipo de datos que desea
convertir a, y un paréntesis cerrado,

1308
01:04:18,840 --> 01:04:21,200
usted puede decir la
equipo, hey, ordenador,

1309
01:04:21,200 --> 01:04:24,130
convertir este entero en un char.

1310
01:04:24,130 --> 01:04:26,250
>> Así que cuando corro esta
programa después de compilar,

1311
01:04:26,250 --> 01:04:29,740
vamos a ver lo que hago get-- ASCII 0.

1312
01:04:29,740 --> 01:04:33,020
Maldita sea, ¿qué he hecho mal?

1313
01:04:33,020 --> 01:04:35,884
Utilice de identificador no declarado,
bien, no intencional,

1314
01:04:35,884 --> 01:04:37,800
pero vamos a ver si no podemos
razón por esto.

1315
01:04:37,800 --> 01:04:41,220
>> Así five-- línea, así que no entiendo
muy lejos antes de meter la pata.

1316
01:04:41,220 --> 01:04:42,140
Está bien.

1317
01:04:42,140 --> 01:04:46,560
Así la línea 5 para i es igual a 65-- veo.

1318
01:04:46,560 --> 01:04:50,130
Así que recuerda que en C, a diferencia de algunos
idiomas si usted tiene la programación previa

1319
01:04:50,130 --> 01:04:52,190
experiencia, usted tiene
para indicar al ordenador,

1320
01:04:52,190 --> 01:04:55,040
a diferencia de los arañazos, lo
tipo de variable que es.

1321
01:04:55,040 --> 01:04:56,860
>> Y se me olvidó una frase clave aquí.

1322
01:04:56,860 --> 01:04:59,200
En la línea cinco, He empezado a utilizar i.

1323
01:04:59,200 --> 01:05:01,560
Pero no le he dicho C
los datos que tipo es.

1324
01:05:01,560 --> 01:05:04,570
Así que me voy a ir de aquí y
decir, ah, hacen que sea un número entero.

1325
01:05:04,570 --> 01:05:07,050
>> Ahora voy a seguir adelante y volver a compilar.

1326
01:05:07,050 --> 01:05:08,080
Que fija que.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, sería una especie de fresco.

1328
01:05:12,660 --> 01:05:15,360
No sólo es súper rápido a
pedirle a la computadora esta pregunta,

1329
01:05:15,360 --> 01:05:18,885
en lugar de mirar hacia arriba sobre un portaobjetos,
se imprime una por línea, A es 65,

1330
01:05:18,885 --> 01:05:24,860
B es 66, todo el camino desde que down--
hizo esto 26 veces-- de las letras Z,

1331
01:05:24,860 --> 01:05:25,630
que es 90.

1332
01:05:25,630 --> 01:05:27,790
Y, de hecho, ligeramente
más inteligente haría

1333
01:05:27,790 --> 01:05:31,030
han sido para mí no confiar
en el ordenador para añadir 26.

1334
01:05:31,030 --> 01:05:34,060
Me podría haber hecho
90, así, siempre

1335
01:05:34,060 --> 01:05:37,390
ya que no cometer el mismo error dos veces.

1336
01:05:37,390 --> 01:05:41,880
Quiero ir hacia arriba a través
z, no sólo a través de y.

1337
01:05:41,880 --> 01:05:44,000
>> Así que esa es una conversión explícita.

1338
01:05:44,000 --> 01:05:47,860
Resulta que este
Ni siquiera es necesario.

1339
01:05:47,860 --> 01:05:52,480
Déjame ir por delante y volver a ejecutar este
compilador, y vuelva a ejecutar ASCII 0.

1340
01:05:52,480 --> 01:05:54,940
Resulta que C es muy inteligente.

1341
01:05:54,940 --> 01:05:57,150
>> Y printf, en particular,
es muy inteligente.

1342
01:05:57,150 --> 01:06:01,260
Si usted sólo tiene que pasar un i dos veces
para ambos marcadores de posición, printf

1343
01:06:01,260 --> 01:06:04,510
se dará cuenta, oh, así que te conozco
me dio un integer-- algún número,

1344
01:06:04,510 --> 01:06:06,380
al igual que 65, o 90, o lo que sea.

1345
01:06:06,380 --> 01:06:10,170
Pero veo que usted me quiere
dar formato a ese número como un personaje.

1346
01:06:10,170 --> 01:06:16,460
Y así implícitamente printf puede lanzar
el int a char para usted también.

1347
01:06:16,460 --> 01:06:19,360
Así que eso no es un problema en absoluto.

1348
01:06:19,360 --> 01:06:23,100
>> Pero note, debido a esta equivalencia
que realmente podemos hacer esto también.

1349
01:06:23,100 --> 01:06:26,520
Déjame seguir adelante y hacer una
otra versión de esto- 1.c ASCII

1350
01:06:26,520 --> 01:06:31,800
Y en vez de una iteración
enteros, realmente puede volar tu mente

1351
01:06:31,800 --> 01:06:33,610
iterando sobre los personajes.

1352
01:06:33,610 --> 01:06:37,660
Si un char c consigue el capital A, I
desee seguir adelante y hacer esto,

1353
01:06:37,660 --> 01:06:41,740
siempre y cuando C es menor que o igual
A a la Z. capital y en cada iteración

1354
01:06:41,740 --> 01:06:45,690
Quiero incrementar C, que pueda
Ahora en mi línea printf aquí

1355
01:06:45,690 --> 01:06:51,320
por ejemplo, el porcentaje de C es
i por ciento más, coma C.

1356
01:06:51,320 --> 01:06:57,200
>> Y ahora, puedo ir a la otra dirección,
fundición el carácter explícitamente

1357
01:06:57,200 --> 01:06:58,500
a un entero.

1358
01:06:58,500 --> 01:07:00,560
Así, de nuevo, ¿por qué haces esto?

1359
01:07:00,560 --> 01:07:03,830
Es un poco raro para ordenar de
contar en términos de caracteres.

1360
01:07:03,830 --> 01:07:07,430
>> Pero si usted entiende lo que está
pasando por debajo de la campana,

1361
01:07:07,430 --> 01:07:08,430
en realidad no hay magia.

1362
01:07:08,430 --> 01:07:13,060
Sólo lo dices, bueno, equipo dan
me una variable llamada C de tipo char.

1363
01:07:13,060 --> 01:07:16,520
Inicializarlo al capital A. Y
notar única cuestión comillas.

1364
01:07:16,520 --> 01:07:19,580
>> Para los caracteres en C, retirar de la
la semana pasada, se utilizan comillas simples.

1365
01:07:19,580 --> 01:07:23,720
Para cadenas, para las palabras,
frases, se utilizan comillas dobles.

1366
01:07:23,720 --> 01:07:27,210
OK, ordenador, seguir haciendo esto, por lo
siempre y cuando el personaje es menor que

1367
01:07:27,210 --> 01:07:28,050
o igual a z.

1368
01:07:28,050 --> 01:07:32,640
Y sé de mi tabla ASCII que todos
de estos códigos ASCII son contiguas.

1369
01:07:32,640 --> 01:07:33,400
>> No hay ningún hueco.

1370
01:07:33,400 --> 01:07:36,737
Así que es sólo la A a la Z,
separados por un número cada uno.

1371
01:07:36,737 --> 01:07:38,820
Y entonces puedo incrementar
un char, si realmente quiero.

1372
01:07:38,820 --> 01:07:40,390
Al final del día,
es sólo un número.

1373
01:07:40,390 --> 01:07:41,030
Yo se esto.

1374
01:07:41,030 --> 01:07:43,670
Así que sólo puedo suponer añadir 1 a la misma.

1375
01:07:43,670 --> 01:07:46,940
>> Y después de este tiempo, puedo imprimir c,
y luego el equivalente integral.

1376
01:07:46,940 --> 01:07:50,170
Y ni siquiera necesita la conversión explícita.

1377
01:07:50,170 --> 01:07:52,680
Puedo dejar printf y la
Figura ordenador las cosas,

1378
01:07:52,680 --> 01:07:57,300
de modo que ahora si me quedo
hacer Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Me sale exactamente lo mismo también.

1380
01:08:01,520 --> 01:08:04,530
>> programa inútil, nadie aunque--
en realidad se va a escribir software

1381
01:08:04,530 --> 01:08:07,549
con el fin de averiguar, lo que fue el
número que se asigna a A, o B, o Z?

1382
01:08:07,549 --> 01:08:10,340
Sólo vas a Google, o
buscarla en línea, o búsquelo

1383
01:08:10,340 --> 01:08:11,650
en una diapositiva, o similares.

1384
01:08:11,650 --> 01:08:13,520
Entonces, ¿dónde esta realidad obtener útil?

1385
01:08:13,520 --> 01:08:15,960
>> Bueno, hablando de ese
diapositiva, observe que hay

1386
01:08:15,960 --> 01:08:20,890
un patrón real aquí entre mayúsculas
y minúsculas que no fue accidental.

1387
01:08:20,890 --> 01:08:23,760
Observe que el capital A es 65.

1388
01:08:23,760 --> 01:08:25,830
A minúscula es 97.

1389
01:08:25,830 --> 01:08:29,649
Y a qué distancia es menor caso una?

1390
01:08:29,649 --> 01:08:32,649
>> Así que 65 es el número de pasos de 97?

1391
01:08:32,649 --> 01:08:36,210
Por lo menos el 97 65 es 32.

1392
01:08:36,210 --> 01:08:37,910
Así que el capital es un 65.

1393
01:08:37,910 --> 01:08:39,939
Si se agrega 32 a que,
se obtiene a minúscula.

1394
01:08:39,939 --> 01:08:43,729
Y, lo que es equivalente, si se resta 32,
a volver al capital A-- mismo con B

1395
01:08:43,729 --> 01:08:46,380
a poco B, C grande a poco c.

1396
01:08:46,380 --> 01:08:50,670
>> Todas estas deficiencias son 32 aparte.

1397
01:08:50,670 --> 01:08:54,450
Ahora, esto parecería que nos permita
hacer algo como Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
o Google Docs cuentan, donde
puede seleccionar todo y luego decir,

1399
01:08:57,729 --> 01:09:00,520
cambiar todo en minúsculas, o
cambiar todo en mayúsculas,

1400
01:09:00,520 --> 01:09:03,840
o cambiar sólo la primera palabra
de una oración a mayúsculas.

1401
01:09:03,840 --> 01:09:07,390
De hecho, podemos hacer algo
al igual que a nosotros mismos.

1402
01:09:07,390 --> 01:09:12,645
>> Déjame ir por delante y guardar un archivo
aquí se llama capitalizar 0.c.

1403
01:09:12,645 --> 01:09:15,770
Y vamos a seguir adelante y preparar rápidamente un programa
que hace exactamente eso de la siguiente manera.

1404
01:09:15,770 --> 01:09:18,460
Por lo que incluyen la biblioteca CS50.

1405
01:09:18,460 --> 01:09:21,430
E incluyen E / S estándar.

1406
01:09:21,430 --> 01:09:22,787
>> Y sé que esto es muy pronto.

1407
01:09:22,787 --> 01:09:24,870
Así que voy a ponerlo en
ya, string.h,

1408
01:09:24,870 --> 01:09:26,960
así que no tengo acceso a
cosas como Stirling,

1409
01:09:26,960 --> 01:09:29,620
y luego int vacío principal, como de costumbre.

1410
01:09:29,620 --> 01:09:33,420
Y luego voy a seguir adelante
y hacer cuerdas consigue obtener la secuencia,

1411
01:09:33,420 --> 01:09:35,032
sólo para obtener una cadena del usuario.

1412
01:09:35,032 --> 01:09:36,740
Y luego voy a
hacer mi comprobación de validez.

1413
01:09:36,740 --> 01:09:40,510
Si cadena no es igual a un valor nulo,
entonces es seguro proceder.

1414
01:09:40,510 --> 01:09:42,000
Y qué es lo que quiero hacer?

1415
01:09:42,000 --> 01:09:48,700
Voy a repetir desde i es igual a 0,
y n hasta la longitud de cadena del s.

1416
01:09:48,700 --> 01:09:51,899
>> Y voy a hacer esto, siempre y cuando
i es menor que n, y yo y más.

1417
01:09:51,899 --> 01:09:55,060
Hasta el momento, estoy realmente sólo
préstamos ideas de antes.

1418
01:09:55,060 --> 01:09:57,010
Y ahora voy a introducir una rama.

1419
01:09:57,010 --> 01:09:59,635
>> Así que pensar en volver a los arañazos, donde
tuvimos esas bifurcaciones en el camino,

1420
01:09:59,635 --> 01:10:05,110
y la semana pasada en C. voy a
decir esto, si el carácter i-ésimo en s

1421
01:10:05,110 --> 01:10:09,250
es mayor o
igual a minúsculas a,

1422
01:10:09,250 --> 01:10:13,340
y- en Scratch que, literalmente, lo haría
dice y, pero en C dices signo,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- y el carácter i-ésimo en s
es menor que o igual a minúsculas z,

1424
01:10:19,830 --> 01:10:21,780
vamos a hacer algo interesante.

1425
01:10:21,780 --> 01:10:27,020
Vamos a imprimir una realidad
carácter de nueva línea sin

1426
01:10:27,020 --> 01:10:31,760
ese es el carácter de la cadena,
el carácter i-ésimo en la cadena.

1427
01:10:31,760 --> 01:10:37,420
>> Pero vamos a seguir adelante y
restar 32 de ella.

1428
01:10:37,420 --> 01:10:42,120
Porque si el personaje de la
cadena que estamos buscando

1429
01:10:42,120 --> 01:10:45,950
No está entre un poco
y poco z, adelante

1430
01:10:45,950 --> 01:10:48,610
y acaba de imprimir a cabo sin cambios.

1431
01:10:48,610 --> 01:10:50,840
Así que hemos introducido
esta notación entre corchetes

1432
01:10:50,840 --> 01:10:53,560
para nuestros hilos para que en el
i-ésimo carácter de la cadena.

1433
01:10:53,560 --> 01:10:57,520
>> He añadido un poco de lógica condicional, al igual
Cero en la primera semana de la semana pasada, donde

1434
01:10:57,520 --> 01:10:59,880
Sólo estoy usando mi fundamental
comprensión de lo que es

1435
01:10:59,880 --> 01:11:01,130
pasando por debajo del capó.

1436
01:11:01,130 --> 01:11:04,190
Es el carácter i de s
mayor o igual a un?

1437
01:11:04,190 --> 01:11:08,290
Al igual, que es 97 o 98,
o 99, y así sucesivamente?

1438
01:11:08,290 --> 01:11:11,940
>> Pero es también menor que o igual
al valor de z en minúsculas?

1439
01:11:11,940 --> 01:11:16,210
Y si es así, ¿qué significa esta línea?

1440
01:11:16,210 --> 01:11:20,250
14, esto es una especie de la
germen de la idea,

1441
01:11:20,250 --> 01:11:23,840
capitalizar la carta
simplemente restando 32 de ella,

1442
01:11:23,840 --> 01:11:29,370
en este caso, porque sé, por eso
carta, cómo se representan mis números.

1443
01:11:29,370 --> 01:11:33,925
Así que vamos a seguir adelante y ejecutar este,
después de compilar capitalizar 0.c,

1444
01:11:33,925 --> 01:11:36,210
y correr capitalizar 0.

1445
01:11:36,210 --> 01:11:40,300
>> Vamos a escribir algo así como
Zamyla entrar en minúsculas.

1446
01:11:40,300 --> 01:11:42,780
Y ahora tenemos Zamyla en mayúsculas.

1447
01:11:42,780 --> 01:11:45,050
Vamos escriba en Rob en minúsculas.

1448
01:11:45,050 --> 01:11:46,674
Vamos a tratar de Jason en minúsculas.

1449
01:11:46,674 --> 01:11:48,590
Y seguimos conseguir el
capitalización forzada.

1450
01:11:48,590 --> 01:11:50,960
Hay un error menor que yo
tipo de no anticipar.

1451
01:11:50,960 --> 01:11:54,050
Observe mi nuevo símbolo es terminar
en la misma línea que sus nombres,

1452
01:11:54,050 --> 01:11:55,520
que se siente un poco desordenado.

1453
01:11:55,520 --> 01:11:59,170
>> Así que voy a ir allí, y
en realidad al final de este programa

1454
01:11:59,170 --> 01:12:02,110
imprimir un carácter de nueva línea.

1455
01:12:02,110 --> 01:12:03,160
Eso es todo.

1456
01:12:03,160 --> 01:12:06,120
Con printf, que no es necesario
pasar variables o código de formato.

1457
01:12:06,120 --> 01:12:08,460
Usted puede, literalmente, sólo imprimir
algo así como una nueva línea.

1458
01:12:08,460 --> 01:12:13,529
>> Así que vamos a seguir adelante y hacer
0 capitalizar de nuevo, volver a ejecutarlo, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Y ahora es un poco más bonito.

1460
01:12:14,820 --> 01:12:17,274
Ahora, mi indicador está en su propia línea nueva.

1461
01:12:17,274 --> 01:12:18,440
Así que eso es todo fino y bueno.

1462
01:12:18,440 --> 01:12:19,910
Así que es un buen ejemplo.

1463
01:12:19,910 --> 01:12:22,700
Pero no lo sé siquiera necesariamente
necesitará codificar el 32.

1464
01:12:22,700 --> 01:12:23,350
¿Sabes que?

1465
01:12:23,350 --> 01:12:26,350
Podría decir-- no lo hago nunca
recuerde cuál es la diferencia.

1466
01:12:26,350 --> 01:12:29,330
>> Pero sé que si yo
tener una letra minúscula,

1467
01:12:29,330 --> 01:12:34,430
Yo quiero restar esencialmente fuera
cualquiera que sea la distancia es de entre poco

1468
01:12:34,430 --> 01:12:39,160
una grande y A, porque si yo supongo que
todas las otras cartas son los mismos,

1469
01:12:39,160 --> 01:12:41,045
que debe hacer el trabajo.

1470
01:12:41,045 --> 01:12:42,670
Pero en lugar de hacer eso, ¿sabes qué?

1471
01:12:42,670 --> 01:12:44,240
Hay otra manera aún.

1472
01:12:44,240 --> 01:12:48,090
>> Si eso es capitalizar 1.c-- si fuera
para poner esto en un archivo separado.

1473
01:12:48,090 --> 01:12:51,030
Vamos a hacer capitalizar 2.c de la siguiente manera.

1474
01:12:51,030 --> 01:12:53,060
Voy a limpiar realmente esta aquí.

1475
01:12:53,060 --> 01:12:57,420
Y en vez de tener que
sabe ni le importa acerca de aquellos bajo nivel

1476
01:12:57,420 --> 01:13:01,090
detalles de implementación, soy vez
sólo va a imprimir un carácter,

1477
01:13:01,090 --> 01:13:04,610
entre comillas, C ciento, y
a continuación, llamar a otra función que

1478
01:13:04,610 --> 01:13:09,950
existen de que toma un argumento,
que es un personaje, como este.

1479
01:13:09,950 --> 01:13:12,630
>> Resulta que en C, hay
otra llamada a la función

1480
01:13:12,630 --> 01:13:15,550
a superior, que como su nombre
sugiere toma un carácter

1481
01:13:15,550 --> 01:13:19,350
y lo hace a su mayúsculas
equivalente, y luego lo devuelve

1482
01:13:19,350 --> 01:13:21,410
de manera que printf puede conectarlo allí.

1483
01:13:21,410 --> 01:13:25,484
Y así, para hacer esto, sin embargo, me
que tenga que introducir otro archivo.

1484
01:13:25,484 --> 01:13:28,400
Resulta que hay otro archivo
que sólo se sabría de la clase,

1485
01:13:28,400 --> 01:13:33,020
o un libro de texto o una línea
referencia, llamado type.h. C

1486
01:13:33,020 --> 01:13:38,570
>> Así que si añado que hasta entre los de mi cabecera
archivos, y ahora volver a compilar este programa,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Intro.

1488
01:13:43,040 --> 01:13:46,690
Vamos escriba en Zamyla en todo
minúscula, sigue funcionando de la misma.

1489
01:13:46,690 --> 01:13:48,040
¿Pero sabes que?

1490
01:13:48,040 --> 01:13:55,590
Resulta que a la parte superior
tiene alguna otra funcionalidad.

1491
01:13:55,590 --> 01:13:58,410
>> Y voy a presentar esta
comandar aquí, una especie de torpeza

1492
01:13:58,410 --> 01:14:00,250
llamado, pero el hombre para el manual.

1493
01:14:00,250 --> 01:14:03,960
Resulta que la mayoría de los sistemas Linux,
como estamos utilizando aquí-- operativo Linux

1494
01:14:03,960 --> 01:14:06,270
system-- tener un dominio
llamado hombre, que dice:

1495
01:14:06,270 --> 01:14:08,530
Hey, ordenador, dame
el manual del equipo.

1496
01:14:08,530 --> 01:14:10,680
¿Qué es lo que desea
mirar hacia arriba en ese manual?

1497
01:14:10,680 --> 01:14:13,840
>> Quiero ver la función
llamados a superior, Intro.

1498
01:14:13,840 --> 01:14:16,070
Y es un poco críptico
leer a veces.

1499
01:14:16,070 --> 01:14:18,780
Pero Tenga en cuenta que estamos en el
Manual del Programador de Linux.

1500
01:14:18,780 --> 01:14:19,530
Y es todo el texto.

1501
01:14:19,530 --> 01:14:21,905
Y el aviso de que existe la
nombre de la función aquí.

1502
01:14:21,905 --> 01:14:25,030
Resulta que tiene un primo llamado
para bajar, lo que hace lo contrario.

1503
01:14:25,030 --> 01:14:29,710
Y la notificación mencionada en resumen, para utilizar esta
funcionar la página del manual, por así decirlo,

1504
01:14:29,710 --> 01:14:32,220
Me está diciendo que yo
que incluir c type.h.

1505
01:14:32,220 --> 01:14:33,630
Y sabía que a partir de la práctica.

1506
01:14:33,630 --> 01:14:36,210
>> Aquí, me está mostrando los dos
prototipos para la función,

1507
01:14:36,210 --> 01:14:39,070
por lo que si alguna vez quiero utilizar este
Yo sé lo que toman como entrada,

1508
01:14:39,070 --> 01:14:40,652
y lo regresan como salida.

1509
01:14:40,652 --> 01:14:42,360
Y entonces si leo
la descripción, veo

1510
01:14:42,360 --> 01:14:44,820
con más detalle lo que hace la función.

1511
01:14:44,820 --> 01:14:48,100
Pero lo más importante, si
Miro bajo valor de retorno,

1512
01:14:48,100 --> 01:14:51,710
se dice que el valor devuelto es
la de la letra convertido,

1513
01:14:51,710 --> 01:14:57,880
o C, la entrada original, si
la conversión no era posible.

1514
01:14:57,880 --> 01:15:01,992
>> En otras palabras, a superior a tratar
para convertir una letra en mayúsculas.

1515
01:15:01,992 --> 01:15:03,450
Y si es así, que va a devolverlo.

1516
01:15:03,450 --> 01:15:07,010
Pero si no puede por alguna reason--
tal vez es el caso ya superior,

1517
01:15:07,010 --> 01:15:09,550
tal vez es un signo de exclamación
o alguna otra punctuation--

1518
01:15:09,550 --> 01:15:12,200
que sólo va a
devolver el C original,

1519
01:15:12,200 --> 01:15:17,340
que significa que puedo hacer que mi código
mejor diseñado de la siguiente manera.

1520
01:15:17,340 --> 01:15:20,580
>> No necesito todos
estas líneas de código maldito.

1521
01:15:20,580 --> 01:15:22,610
Todas las líneas que he
Sólo puede resaltado

1522
01:15:22,610 --> 01:15:28,700
colapsarse en un sencillo
línea, que es esto- ciento printf

1523
01:15:28,700 --> 01:15:33,510
c para soporte superior S i.

1524
01:15:33,510 --> 01:15:36,090
Y esto sería una
ejemplo de un mejor diseño.

1525
01:15:36,090 --> 01:15:40,040
>> ¿Por qué implementar en 7 u 8 líneas
de código, lo que fuera que acabo

1526
01:15:40,040 --> 01:15:44,960
suprimido, cuando en su lugar puede colapsar
todos los que la lógica y la toma de decisiones

1527
01:15:44,960 --> 01:15:49,620
en una sola línea, ahora 13, que
se basa en una biblioteca function--

1528
01:15:49,620 --> 01:15:53,430
una función que viene con C, pero que
hace exactamente lo que quiere que haga.

1529
01:15:53,430 --> 01:15:55,295
Y, francamente, incluso si
que no vino con C,

1530
01:15:55,295 --> 01:15:58,880
se podría aplicar a mano como se
que hemos visto, con llegar int negativo

1531
01:15:58,880 --> 01:16:01,700
y obtener positivos int la semana pasada también.

1532
01:16:01,700 --> 01:16:03,470
>> Este código ahora es mucho más fácil de leer.

1533
01:16:03,470 --> 01:16:06,670
Y, de hecho, si nos desplazamos hacia arriba,
mira cómo mucho más compacto

1534
01:16:06,670 --> 01:16:08,360
esta versión de mi programa es.

1535
01:16:08,360 --> 01:16:11,230
Es un poco pesado encima ahora,
Con todo esto incluye.

1536
01:16:11,230 --> 01:16:14,380
Pero eso está bien, porque ahora estoy de pie
sobre los hombros de los programadores

1537
01:16:14,380 --> 01:16:15,300
antes de mí.

1538
01:16:15,300 --> 01:16:18,440
Y quienquiera que
implementado para realmente superior

1539
01:16:18,440 --> 01:16:21,470
me hizo un favor, al igual que cualquiera
implementado realmente Stirling

1540
01:16:21,470 --> 01:16:24,790
me hizo un favor hace algún tiempo.

1541
01:16:24,790 --> 01:16:26,970
Y por lo que ahora tenemos una
mejor programa de diseño

1542
01:16:26,970 --> 01:16:31,680
que implementa exactamente la misma lógica.

1543
01:16:31,680 --> 01:16:35,580
>> Hablando de Stirling, dejó
Me seguir adelante y hacer esto.

1544
01:16:35,580 --> 01:16:38,320
Déjame ir por delante y guardar
este archivo como stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Y resulta que, podemos pelar
otra capa bastante simple ahora.

1546
01:16:43,255 --> 01:16:45,630
Voy a seguir adelante y látigo
otro programa en el principal

1547
01:16:45,630 --> 01:16:49,759
aquí que simplemente re-aperos
longitud de la cadena de la siguiente manera.

1548
01:16:49,759 --> 01:16:52,300
Así que aquí hay una línea de código que
Me para crear una cadena del usuario.

1549
01:16:52,300 --> 01:16:53,910
Seguimos usando una y otra vez.

1550
01:16:53,910 --> 01:16:58,900
Déjame ponerme una variable llamada
n de tipo int que almacena un número.

1551
01:16:58,900 --> 01:17:02,490
>> Y me dejó ir adelante y
hacer lo siguiente lógica.

1552
01:17:02,490 --> 01:17:15,610
Mientras que el personaje hace enésimo en s
es igual a 0 barra invertida, adelante

1553
01:17:15,610 --> 01:17:17,930
e incrementar n.

1554
01:17:17,930 --> 01:17:23,506
Y luego imprimir printf ciento i n.

1555
01:17:23,506 --> 01:17:29,200
Yo reclamo que este programa aquí,
sin llamar la longitud de la cadena,

1556
01:17:29,200 --> 01:17:31,150
se da cuenta de la longitud de una cadena.

1557
01:17:31,150 --> 01:17:34,600
>> Y la magia es enteramente
encapsulado en la línea 8

1558
01:17:34,600 --> 01:17:39,830
aquí con lo que parece ser una nueva sintaxis,
esta barra invertida 0 comillas simples.

1559
01:17:39,830 --> 01:17:41,360
Pero ¿por qué es eso?

1560
01:17:41,360 --> 01:17:44,100
Bueno, tenga en cuenta lo que ha sido
pasando todo este tiempo.

1561
01:17:44,100 --> 01:17:47,990
>> Y como un lado antes de que me olvide, se dan cuenta
también, que, además de las páginas man

1562
01:17:47,990 --> 01:17:50,920
que vienen con un típico
sistema Linux como CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
darse cuenta de que nosotros, los
El personal del supuesto, también

1564
01:17:53,770 --> 01:17:56,030
hecho un sitio Versión
de esta misma idea llamada

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, que tiene
todas esas mismas páginas del manual,

1566
01:17:59,940 --> 01:18:02,020
todo de ese mismo
documentación, así como

1567
01:18:02,020 --> 01:18:05,730
una pequeña caja en la parte superior que permite
a convertir toda la justa

1568
01:18:05,730 --> 01:18:09,025
lenguaje arcano en menos cómodo
el modo, en el que, el profesorado,

1569
01:18:09,025 --> 01:18:12,150
han pasado por y tratado de simplificar
algo de la lengua para mantener las cosas

1570
01:18:12,150 --> 01:18:14,830
centrado en las ideas, y no
algunos de los aspectos técnicos.

1571
01:18:14,830 --> 01:18:20,070
Así que tener en cuenta, reference.cs50.net
como otro recurso también.

1572
01:18:20,070 --> 01:18:23,800
>> Pero ¿por qué funciona la longitud de la cadena de
la forma en que propuse hace un momento?

1573
01:18:23,800 --> 01:18:25,160
Aquí está el nombre de Zamyla nuevo.

1574
01:18:25,160 --> 01:18:27,690
Y aquí está el nombre de Zamyla
encajonado, como sigo haciendo,

1575
01:18:27,690 --> 01:18:31,360
para pintar un cuadro de él que es,
en realidad, sólo una secuencia de caracteres.

1576
01:18:31,360 --> 01:18:34,260
Pero Zamyla no existe
en el aislamiento en un programa.

1577
01:18:34,260 --> 01:18:37,420
>> Cuando se escribe y ejecuta un programa,
usted está utilizando su Mac o PC

1578
01:18:37,420 --> 01:18:40,010
como la memoria, o RAM por así decirlo.

1579
01:18:40,010 --> 01:18:42,620
Y que se pueda imaginar
el ordenador como tener

1580
01:18:42,620 --> 01:18:44,730
una gran cantidad de gigabytes de memoria en estos días.

1581
01:18:44,730 --> 01:18:47,700
Y un concierto significa miles de millones,
por lo que miles de millones de bytes.

1582
01:18:47,700 --> 01:18:48,910
>> Pero vamos a retroceder en el tiempo.

1583
01:18:48,910 --> 01:18:51,530
Y supongamos que estamos utilizando
un equipo muy viejo que

1584
01:18:51,530 --> 01:18:55,150
sólo tiene 32 bytes de memoria.

1585
01:18:55,150 --> 01:18:59,310
Pude, en mi pantalla de ordenador,
simplemente dibujar esto de la siguiente manera.

1586
01:18:59,310 --> 01:19:05,240
>> Yo podría simplemente decir que mi
equipo tiene toda esta memoria.

1587
01:19:05,240 --> 01:19:08,830
Y esto es como un palo de memoria, si
Recuerdas nuestra imagen de la última vez.

1588
01:19:08,830 --> 01:19:11,670
Y si me divido
en este número suficiente de veces,

1589
01:19:11,670 --> 01:19:15,040
Puedo reclamar que tengo 32 bytes
de la memoria en la pantalla.

1590
01:19:15,040 --> 01:19:18,239
>> Ahora, en realidad, sólo puedo
dibujar hasta el momento en esta pantalla aquí.

1591
01:19:18,239 --> 01:19:20,280
Así que voy a seguir adelante,
y justo por convención,

1592
01:19:20,280 --> 01:19:24,050
llamar la memoria del ordenador como
rejilla, no sólo como una línea recta.

1593
01:19:24,050 --> 01:19:28,190
En concreto, reclamo ahora que
esta rejilla, este 8 por 4 rejilla,

1594
01:19:28,190 --> 01:19:31,800
simplemente representa los 32 bytes
de memoria disponible en mi Mac,

1595
01:19:31,800 --> 01:19:33,030
o disponer de un PC.

1596
01:19:33,030 --> 01:19:34,780
Y están envolviendo
en dos líneas, justo

1597
01:19:34,780 --> 01:19:38,030
porque se ajusta más en la pantalla.

1598
01:19:38,030 --> 01:19:40,800
Pero este es el primer byte.

1599
01:19:40,800 --> 01:19:41,990
Este es el segundo byte.

1600
01:19:41,990 --> 01:19:43,300
Esta es la tercera byte.

1601
01:19:43,300 --> 01:19:45,310
>> Y este es el byte número 32.

1602
01:19:45,310 --> 01:19:52,910
O bien, si pensamos como una computadora
científico, esto es byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Por lo que tiene de 0 a 31, si
se empieza a contar a 0.

1604
01:19:55,950 --> 01:19:59,830
>> Así que si usamos un programa
que las llamadas quedan cadena,

1605
01:19:59,830 --> 01:20:05,280
y obtenemos una cadena humana desde la
como yo lo hice llamado Zamyla, Z-A-H-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
cómo en el mundo hace lo
no perder la computadora de los cuales bytes,

1607
01:20:09,430 --> 01:20:12,230
el cual trozo de memoria,
pertenece a qué secuencia?

1608
01:20:12,230 --> 01:20:16,270
En otras palabras, si se procede a
escribir otro nombre en el ordenador,

1609
01:20:16,270 --> 01:20:19,890
como esto Andi, llamando
obtener una cadena de una segunda vez,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I tiene que terminar en el
la memoria de la computadora también.

1611
01:20:23,030 --> 01:20:23,850
¿Pero cómo?

1612
01:20:23,850 --> 01:20:29,700
>> Pues bien, resulta que por debajo de la
capó, lo que hace C al almacenar cadenas

1613
01:20:29,700 --> 01:20:35,080
que los tipos humanos en, o que
provienen de alguna otra fuente, que es

1614
01:20:35,080 --> 01:20:39,190
delinea el fin de ellos con
una barra invertida character-- especial

1615
01:20:39,190 --> 01:20:44,750
0, que es sólo una forma especial
de decir 80 bits en una fila.

1616
01:20:44,750 --> 01:20:47,950
>> Así A-- este es el recuerdo el número 97.

1617
01:20:47,950 --> 01:20:51,770
Así algún patrón de 8 bits
representa el número decimal 97.

1618
01:20:51,770 --> 01:20:58,070
Esta barra invertida 0 es, literalmente, el número
0, nul alias, N-U-L, a diferencia de antes,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, que hemos hablado.

1620
01:20:59,630 --> 01:21:05,700
Pero por ahora, sólo sé que este
0 barra invertida se halla a 80 bits en una fila.

1621
01:21:05,700 --> 01:21:09,810
>> Y es sólo esta línea en el
arena que se dice nada a la izquierda

1622
01:21:09,810 --> 01:21:12,610
pertenece a una cadena, o un tipo de datos.

1623
01:21:12,610 --> 01:21:15,480
Y cualquier cosa a la derecha
pertenece a otra cosa.

1624
01:21:15,480 --> 01:21:17,440
Nombre de Andi, por su parte,
que acaba visualmente

1625
01:21:17,440 --> 01:21:21,310
sucede para envolver a la otra línea,
pero eso es sólo un detalle estético,

1626
01:21:21,310 --> 01:21:23,990
Del mismo modo se termina nul.

1627
01:21:23,990 --> 01:21:29,290
>> Es una cadena de caracteres de un A-N-D-I,
además de un quinto carácter secreto,

1628
01:21:29,290 --> 01:21:33,560
todos los bits 0, que simplemente demarca
al final del nombre de Andi también.

1629
01:21:33,560 --> 01:21:37,120
Y si llamamos a obtener una cadena de una tercera vez
en el ordenador para obtener una cadena como

1630
01:21:37,120 --> 01:21:44,210
Maria, H-A-R-I-A, de manera similar es María de
nul nombre termina con una barra invertida 0.

1631
01:21:44,210 --> 01:21:47,170
>> Esta es fundamentalmente diferente
desde cómo un ordenador haría normalmente

1632
01:21:47,170 --> 01:21:51,850
almacenar un número entero o un flotador u otro
tipos de datos tranquilos, en el recuerdo,

1633
01:21:51,850 --> 01:21:57,420
un entero es por lo general de 32 bits, o
4 bytes, o tal vez incluso 64 bits,

1634
01:21:57,420 --> 01:21:59,100
u ocho bytes.

1635
01:21:59,100 --> 01:22:02,620
Sin embargo, muchos primitivas en un ordenador
en un lenguaje de programación

1636
01:22:02,620 --> 01:22:05,550
tener un número fijo de
bytes debajo de la hood--

1637
01:22:05,550 --> 01:22:08,100
quizás 1, 2 tal vez, quizás 4, tal vez 8.

1638
01:22:08,100 --> 01:22:13,250
>> Pero las cadenas, por diseño, tienen una
Número dinámica de caracteres.

1639
01:22:13,250 --> 01:22:16,980
Usted no sabe de antemano, hasta
los tipos humanos en Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
o M-A-R-I-A, o A-N-D-I. Usted no sabe
el número de veces que el usuario va a golpear

1641
01:22:21,400 --> 01:22:22,070
el teclado.

1642
01:22:22,070 --> 01:22:26,490
Por lo tanto, usted no sabe cómo
muchos personajes de antelación

1643
01:22:26,490 --> 01:22:27,540
vas a necesitar.

1644
01:22:27,540 --> 01:22:31,840
>> Y lo que C sólo tipo de hojas como una
miga de pan secreta debajo de la campana

1645
01:22:31,840 --> 01:22:32,960
al final de la cadena.

1646
01:22:32,960 --> 01:22:39,280
Después de almacenar Z-A-M-Y-L-A en la memoria,
también sólo pone el equivalente

1647
01:22:39,280 --> 01:22:40,210
de un período.

1648
01:22:40,210 --> 01:22:45,060
Al final de una frase,
que pone 80 bits, con el fin

1649
01:22:45,060 --> 01:22:49,120
de recordar dónde
Zamyla comienza y termina.

1650
01:22:49,120 --> 01:22:51,490
>> Entonces, ¿cuál es la conexión,
entonces, para este programa?

1651
01:22:51,490 --> 01:22:55,190
Este programa aquí, Stirling,
es simplemente un mecanismo

1652
01:22:55,190 --> 01:22:57,970
para conseguir una cadena
por parte del usuario, la línea 6.

1653
01:22:57,970 --> 01:23:01,160
Línea 7, declaro una variable
n llamada y la puso igual a 0.

1654
01:23:01,160 --> 01:23:08,680
>> Y luego, en la línea 8, simplemente le pregunté la
cuestión, mientras que el carácter n-ésimo hace

1655
01:23:08,680 --> 01:23:12,120
no es igual todo 0 bits--
en otras palabras, no hace

1656
01:23:12,120 --> 01:23:14,500
igualdad de este especial
carácter, la barra invertida 0, que

1657
01:23:14,500 --> 01:23:18,470
era sólo que character-- nul especial
seguir adelante y sólo se incrementa n.

1658
01:23:18,470 --> 01:23:21,460
>> Y seguir haciéndolo, y mantener
haciéndolo, y seguir haciéndolo.

1659
01:23:21,460 --> 01:23:23,430
Y así, a pesar de que en
el pasado hemos utilizado i,

1660
01:23:23,430 --> 01:23:25,181
que está perfectamente bien
semánticamente utilizar n,

1661
01:23:25,181 --> 01:23:27,430
si usted está tratando de
contar este tiempo deliberadamente,

1662
01:23:27,430 --> 01:23:28,720
y sólo quieren llamarlo n.

1663
01:23:28,720 --> 01:23:34,720
Así que esto sólo sigue haciendo la pregunta,
es el carácter de orden n de s todos 0s?

1664
01:23:34,720 --> 01:23:38,470
Si no es así, busque en el aspecto,
mirar hacia el lado, mira a la siguiente,

1665
01:23:38,470 --> 01:23:39,460
mirar a la siguiente.

1666
01:23:39,460 --> 01:23:45,540
>> Pero tan pronto como usted ve barra invertida 0,
esta línea loop-- 9 a 11-- se detiene.

1667
01:23:45,540 --> 01:23:49,640
Se rompe fuera del bucle while,
dejando en el interior de esa variable n

1668
01:23:49,640 --> 01:23:54,530
un recuento total de toda la
caracteres de la cadena que lo vio,

1669
01:23:54,530 --> 01:23:55,660
de esta manera la impresión hacia fuera.

1670
01:23:55,660 --> 01:23:56,760
Así que vamos a probar esto.

1671
01:23:56,760 --> 01:23:59,500
>> Déjame ir por delante y, sin
utilizando la función de stirling,

1672
01:23:59,500 --> 01:24:04,240
pero sólo usando mi propia versión de cosecha propia
aquí se llama stirling, déjame ir por delante

1673
01:24:04,240 --> 01:24:07,700
y correr stirling, escriba algo
como Zamyla, que sé de antemano

1674
01:24:07,700 --> 01:24:08,670
es de seis caracteres.

1675
01:24:08,670 --> 01:24:10,080
Vamos a ver si funciona.

1676
01:24:10,080 --> 01:24:10,920
De hecho, son las seis.

1677
01:24:10,920 --> 01:24:15,257
Vamos a probar con Rob, tres personajes,
tres caracteres, así, y así sucesivamente.

1678
01:24:15,257 --> 01:24:17,340
Así que eso es todo lo que está pasando
de debajo del capó.

1679
01:24:17,340 --> 01:24:19,548
Y notar las conexiones,
Luego, con la primera semana

1680
01:24:19,548 --> 01:24:22,370
de la clase, donde hablamos sobre
algo así como la abstracción,

1681
01:24:22,370 --> 01:24:26,960
el cual es sólo esta estratificación de las ideas, o
complejidad, en la parte superior de los principios básicos.

1682
01:24:26,960 --> 01:24:30,710
En este caso, estamos buscando una especie de
debajo del capó de Stirling,

1683
01:24:30,710 --> 01:24:33,510
por así decirlo, de averiguar,
cómo sería puesto en práctica?

1684
01:24:33,510 --> 01:24:35,232
>> Y podríamos ejecutarla de nuevo nosotros mismos.

1685
01:24:35,232 --> 01:24:37,440
Pero estamos nunca más va
para volver a poner en práctica Stirling.

1686
01:24:37,440 --> 01:24:39,780
Sólo vamos a
stirling utilizar con el fin

1687
01:24:39,780 --> 01:24:42,100
para conseguir realmente cierta extensión cuerdas.

1688
01:24:42,100 --> 01:24:44,200
>> Pero no hay magia
debajo de la campana.

1689
01:24:44,200 --> 01:24:46,716
Si sabe que debajo
el capó, una cadena

1690
01:24:46,716 --> 01:24:48,090
es simplemente una secuencia de caracteres.

1691
01:24:48,090 --> 01:24:51,090
Y esa secuencia de caracteres
todos pueden ser tratados numéricamente

1692
01:24:51,090 --> 01:24:53,330
0 con el soporte, soporte
1, soporte 2, y

1693
01:24:53,330 --> 01:24:57,420
saber que al final de una cadena es una
carácter especial, se puede averiguar

1694
01:24:57,420 --> 01:25:01,710
cómo hacer casi cualquier cosa en una
programa, porque todo se reduce a

1695
01:25:01,710 --> 01:25:03,400
es la lectura y escritura de la memoria.

1696
01:25:03,400 --> 01:25:06,130
Es decir, el cambio y mirando
en la memoria, o mover cosas

1697
01:25:06,130 --> 01:25:10,940
alrededor de la memoria, cosas de impresión
en la pantalla, y así sucesivamente.

1698
01:25:10,940 --> 01:25:14,800
>> Así que ahora vamos a utilizar esta recién descubierta
comprensión de lo que en realidad cuerdas

1699
01:25:14,800 --> 01:25:17,910
están debajo de la campana, y
pelar otra capa

1700
01:25:17,910 --> 01:25:20,080
que hasta ahora hemos
estado ignorando por completo.

1701
01:25:20,080 --> 01:25:22,650
En particular, cualquier momento
hemos implementado un programa,

1702
01:25:22,650 --> 01:25:25,930
que hemos tenido esta línea de código
cerca de la parte superior declarando principal.

1703
01:25:25,930 --> 01:25:27,810
Y hemos especificado int void main.

1704
01:25:27,810 --> 01:25:31,240
>> Y ese vacío dentro de los paréntesis
ha estado diciendo todo este tiempo que la principal

1705
01:25:31,240 --> 01:25:33,440
por sí mismo no tiene ningún argumento.

1706
01:25:33,440 --> 01:25:36,210
Cualquier entrada que el principal es
va a obtener de los usuarios

1707
01:25:36,210 --> 01:25:39,020
tiene que venir de alguna otra
mecanismo, como get int,

1708
01:25:39,020 --> 01:25:42,040
o conseguir flotador, u obtener la secuencia,
o alguna otra función.

1709
01:25:42,040 --> 01:25:44,710
Pero resulta que
cuando se escribe un programa,

1710
01:25:44,710 --> 01:25:47,690
en realidad se puede especificar
que este programa está

1711
01:25:47,690 --> 01:25:51,730
tomar las entradas de la humana
en la propia línea de comandos.

1712
01:25:51,730 --> 01:25:56,310
>> En otras palabras, a pesar de que hasta el momento
han estado funcionando solo ./hola hola

1713
01:25:56,310 --> 01:26:00,312
o programas similares, todos de la
otros programas que hemos estado usando,

1714
01:26:00,312 --> 01:26:02,770
que nosotros mismos no escribimos,
ha estado tomando, al parecer,

1715
01:26:02,770 --> 01:26:05,210
arguments-- línea de comandos
cosas como el maquillaje.

1716
01:26:05,210 --> 01:26:07,450
Usted dice algo así como maquillaje,
y luego una segunda palabra.

1717
01:26:07,450 --> 01:26:10,950
O sonido metálico, dices sonido metálico, y luego
una segunda palabra, el nombre de un archivo.

1718
01:26:10,950 --> 01:26:14,410
>> O incluso RM o CP, como se puede
han visto o ya utilizado

1719
01:26:14,410 --> 01:26:15,880
para eliminar o copiar archivos.

1720
01:26:15,880 --> 01:26:18,920
Todos los que toman los llamados
arguments-- línea de comandos

1721
01:26:18,920 --> 01:26:21,130
palabras adicionales en la línea de órdenes.

1722
01:26:21,130 --> 01:26:23,260
Pero hasta ahora, nos
nosotros mismos no han tenido

1723
01:26:23,260 --> 01:26:27,080
este lujo de tomar la entrada de la
usuario cuando él o ella realmente funciona

1724
01:26:27,080 --> 01:26:29,120
el propio programa en la línea de comandos.

1725
01:26:29,120 --> 01:26:33,710
>> Pero podemos hacer que al volver a declarar
principal hacia adelante, no como tener

1726
01:26:33,710 --> 01:26:36,750
anular entre paréntesis,
pero estos dos argumentos

1727
01:26:36,750 --> 01:26:40,600
instead-- el primero un número entero,
y la segunda algo

1728
01:26:40,600 --> 01:26:44,170
nuevo, algo que vamos a llamar
una matriz, algo similar en espíritu

1729
01:26:44,170 --> 01:26:49,220
a lo que vimos en Scratch como una lista, pero
una matriz de cadenas, como pronto veremos.

1730
01:26:49,220 --> 01:26:51,790
Pero vamos a ver esto
A modo de ejemplo, antes de que

1731
01:26:51,790 --> 01:26:53,690
distinguir exactamente lo que eso significa.

1732
01:26:53,690 --> 01:26:56,520
>> Así que si entro en CS50 IDE
aquí, me he ido por delante

1733
01:26:56,520 --> 01:27:01,840
y declaró en un archivo llamado
argv0.c la siguiente plantilla.

1734
01:27:01,840 --> 01:27:04,120
Y note lo único
eso es diferente en lo que va

1735
01:27:04,120 --> 01:27:08,570
es que he cambiado vacío a int
argc cadena argv soporte de abrir, cerrar

1736
01:27:08,570 --> 01:27:09,070
soporte.

1737
01:27:09,070 --> 01:27:11,730
Y el aviso por ahora, no hay
nada dentro de esos soportes.

1738
01:27:11,730 --> 01:27:12,620
>> No hay un número.

1739
01:27:12,620 --> 01:27:15,070
Y no hay i, o
n, o cualquier otra letra.

1740
01:27:15,070 --> 01:27:17,010
Sólo estoy usando el
corchetes, por ahora,

1741
01:27:17,010 --> 01:27:19,510
por razones vamos a venir
volver en un momento.

1742
01:27:19,510 --> 01:27:21,330
>> Y ahora lo que voy a hacer es lo siguiente.

1743
01:27:21,330 --> 01:27:26,680
Si argc es igual a igual 2--
y recuerdan que es igual a los iguales

1744
01:27:26,680 --> 01:27:30,040
es el operador de igualdad comparar
la izquierda y la derecha por la igualdad.

1745
01:27:30,040 --> 01:27:31,790
No es la asignación
operador, que es

1746
01:27:31,790 --> 01:27:36,510
el signo igual única, lo que significa que la copia
desde la derecha a la izquierda un cierto valor.

1747
01:27:36,510 --> 01:27:42,840
>> Si argc es igual a igual a 2, quiero
por ejemplo, printf, hola, porcentajes, nueva línea,

1748
01:27:42,840 --> 01:27:47,340
y luego conecte en-- y aquí está la nueva
soporte de argv trick-- 1, por razones

1749
01:27:47,340 --> 01:27:48,840
que vamos a volver en un momento.

1750
01:27:48,840 --> 01:27:52,110
Porque si no lo hace argc
igual a 2, ¿sabes qué?

1751
01:27:52,110 --> 01:27:57,400
Vamos a seguir adelante y, como de costumbre, imprimir
cabo hola mundo sin sustitución.

1752
01:27:57,400 --> 01:28:02,710
>> Por lo tanto, parecería que si argc, que
representa el número de argumentos, es igual a 2,

1753
01:28:02,710 --> 01:28:04,740
Voy a imprimir
hola una cosa u otra.

1754
01:28:04,740 --> 01:28:07,560
De lo contrario, por defecto, estoy
va a imprimir hola mundo.

1755
01:28:07,560 --> 01:28:08,770
Entonces, ¿qué significa esto?

1756
01:28:08,770 --> 01:28:15,550
>> Bueno, déjame ir por delante y guardar
este archivo y, a continuación, hacer que argv0,

1757
01:28:15,550 --> 01:28:18,940
y luego ./argv0, Intro.

1758
01:28:18,940 --> 01:28:20,300
Y dice hola mundo.

1759
01:28:20,300 --> 01:28:21,260
Ahora, ¿por qué?

1760
01:28:21,260 --> 01:28:24,730
>> Pues bien, resulta que en cualquier momento que
ejecutar un programa en la línea de comandos,

1761
01:28:24,730 --> 01:28:29,570
se está llenando en lo que vamos a
en general, llamar a un vector de argumento.

1762
01:28:29,570 --> 01:28:33,100
En otras palabras, de forma automática la
ordenador, el sistema operativo,

1763
01:28:33,100 --> 01:28:38,340
se va a entregar a su programa
sí mismo una lista de todas las palabras

1764
01:28:38,340 --> 01:28:40,850
que el ser humano ha tecleado en
el símbolo, en caso de que

1765
01:28:40,850 --> 01:28:43,790
el programador quiere hacer
algo con esa información.

1766
01:28:43,790 --> 01:28:48,540
Y en este caso, la única palabra
Me he tecleado en el indicador es ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Y por lo que el número de argumentos que se
se pasa a mi programa es sólo uno.

1768
01:28:55,420 --> 01:28:58,880
En otras palabras, el argumento
contar, también conocido como argc

1769
01:28:58,880 --> 01:29:00,970
aquí como un entero, es sólo uno.

1770
01:29:00,970 --> 01:29:03,000
Uno, por supuesto, no es igual a dos.

1771
01:29:03,000 --> 01:29:05,980
Y así que esto es lo que imprime, hola mundo.

1772
01:29:05,980 --> 01:29:08,170
>> Pero déjame tomar esto en alguna parte.

1773
01:29:08,170 --> 01:29:09,930
Permítanme decir, argv0.

1774
01:29:09,930 --> 01:29:12,740
Y entonces ¿qué hay de María?

1775
01:29:12,740 --> 01:29:14,990
Y a continuación, pulse la tecla Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Y darse cuenta de lo que ocurre aquí mágicamente.

1777
01:29:18,020 --> 01:29:22,640
Ahora, en vez de hola mundo, no tengo
cambiado el comportamiento de este programa

1778
01:29:22,640 --> 01:29:26,310
mediante la adopción de la entrada no desde get
cadena o alguna otra función,

1779
01:29:26,310 --> 01:29:30,570
pero a partir de, al parecer, mi mando
en sí, lo que originalmente escrito en.

1780
01:29:30,570 --> 01:29:35,720
Y puedo jugar a este juego de nuevo por el
cambiándola a Stelios, por ejemplo.

1781
01:29:35,720 --> 01:29:38,400
>> Y ahora veo otro nombre todavía.

1782
01:29:38,400 --> 01:29:40,540
Y aquí, podría decir Andi.

1783
01:29:40,540 --> 01:29:42,137
Y podría decir Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Y podemos jugar a este juego durante todo el día,
acaba de conectar diferentes valores,

1785
01:29:45,220 --> 01:29:49,550
siempre que proporciono exactamente
dos palabras en el indicador,

1786
01:29:49,550 --> 01:29:52,260
de tal manera que argc, cuente mi argumento, es 2.

1787
01:29:52,260 --> 01:29:57,240
>> ¿Veo que el nombre enchufado en
printf, por esta condición en esta lista?

1788
01:29:57,240 --> 01:30:00,550
Por lo tanto, parece que tenemos ahora
la capacidad expresiva

1789
01:30:00,550 --> 01:30:04,410
de tomar el aporte de otro mecanismo,
desde la línea de comandos llamada,

1790
01:30:04,410 --> 01:30:07,000
en lugar de tener que esperar
hasta que el usuario ejecuta el programa,

1791
01:30:07,000 --> 01:30:10,220
y luego le pedirá
usando algo como cadena GET.

1792
01:30:10,220 --> 01:30:11,230
>> Así que ¿qué es esto?

1793
01:30:11,230 --> 01:30:15,010
Argc, de nuevo, es sólo un número entero,
el número de palabras- arguments--

1794
01:30:15,010 --> 01:30:18,540
que el usuario proporcionada en el
símbolo, en la ventana de terminal,

1795
01:30:18,540 --> 01:30:20,110
incluyendo el nombre del programa.

1796
01:30:20,110 --> 01:30:23,340
Así que nuestra ./argv0 es, efectivamente,
el nombre del programa,

1797
01:30:23,340 --> 01:30:24,520
o cómo ejecutar el programa.

1798
01:30:24,520 --> 01:30:25,810
>> Eso cuenta como una palabra.

1799
01:30:25,810 --> 01:30:27,080
Así argc sería 1.

1800
01:30:27,080 --> 01:30:29,750
Pero cuando escribo Stelios, o
Andi, o Zamyla, o María,

1801
01:30:29,750 --> 01:30:31,660
eso significa que el número de argumentos es de dos.

1802
01:30:31,660 --> 01:30:33,910
Y por lo que ahora hay dos palabras se ha pasado.

1803
01:30:33,910 --> 01:30:36,070
>> Y aviso, podemos continuar con esta lógica.

1804
01:30:36,070 --> 01:30:39,050
Si en realidad digo
algo así como Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
un nombre completo, pasando de ese modo
tres argumentos en total,

1806
01:30:42,200 --> 01:30:47,410
Ahora se dice que el defecto de nuevo,
porque, por supuesto, 3 no es igual a 2.

1807
01:30:47,410 --> 01:30:54,080
>> Y así, de esta manera, ¿tengo
acceso a través de este nuevo argumento argv

1808
01:30:54,080 --> 01:30:56,080
que técnicamente podría
llamar a cualquier cosa que queramos.

1809
01:30:56,080 --> 01:30:58,940
Sin embargo, por convención, es
argv y argc, respectivamente.

1810
01:30:58,940 --> 01:31:04,470
Argv, vector argumento, es una especie
de un sinónimo de una programación

1811
01:31:04,470 --> 01:31:07,140
característica de C llama una matriz.

1812
01:31:07,140 --> 01:31:14,410
>> Una matriz es una lista de valores similares
hacia atrás, hacia atrás, hacia atrás, hacia atrás.

1813
01:31:14,410 --> 01:31:17,810
En otras palabras, si uno es justo aquí, en
RAM, el siguiente es justo al lado de ella,

1814
01:31:17,810 --> 01:31:18,800
y justo al lado de ella.

1815
01:31:18,800 --> 01:31:20,101
No son por todo el lugar.

1816
01:31:20,101 --> 01:31:23,100
Y que este último escenario, donde las cosas
son por todo el lugar en la memoria,

1817
01:31:23,100 --> 01:31:25,082
en realidad puede ser una característica de gran alcance.

1818
01:31:25,082 --> 01:31:28,040
Pero vamos a volver a eso cuando nos
hablar de estructuras de datos más elegantes.

1819
01:31:28,040 --> 01:31:32,260
Por ahora, una matriz es sólo una
trozo de memoria contigua,

1820
01:31:32,260 --> 01:31:36,520
cada uno de cuyos elementos son
hacia atrás, hacia atrás, hacia atrás, hacia atrás,

1821
01:31:36,520 --> 01:31:38,050
y generalmente del mismo tipo.

1822
01:31:38,050 --> 01:31:42,630
>> Así que si se piensa, a partir de una
Hace momento, lo que es una cadena?

1823
01:31:42,630 --> 01:31:50,460
Bueno, una cadena, como Zamyla,
Z-A-H-Y-L-A, es, técnicamente,

1824
01:31:50,460 --> 01:31:51,400
simplemente una matriz.

1825
01:31:51,400 --> 01:31:53,700
Es un conjunto de caracteres.

1826
01:31:53,700 --> 01:31:59,250
>> Y así, si es que realmente sacamos esto, como he
lo hizo antes, como un trozo de memoria,

1827
01:31:59,250 --> 01:32:04,510
resulta que cada uno de estos
personajes retoma un byte.

1828
01:32:04,510 --> 01:32:07,630
Y luego está ese especial
carácter centinela, la barra invertida 0,

1829
01:32:07,630 --> 01:32:12,360
o los ocho bits de 0, que se
demarca el final de esa cadena.

1830
01:32:12,360 --> 01:32:15,090
Así que una cadena, se convierte
cabo, citar cadena de cierre de comillas,

1831
01:32:15,090 --> 01:32:20,580
es simplemente un conjunto de chara--
charla ser un tipo de datos real.

1832
01:32:20,580 --> 01:32:24,560
>> Y ahora argv, meanwhile--
vamos a ir de nuevo al programa.

1833
01:32:24,560 --> 01:32:29,582
Argv, a pesar de que vemos la palabra
cadena aquí, no es una cadena en sí.

1834
01:32:29,582 --> 01:32:33,640
Argv, el argumento del vector,
es una matriz de cadenas.

1835
01:32:33,640 --> 01:32:37,620
>> Así mismo modo que puede tener una gran variedad de
caracteres, que pueden tener un nivel más alto,

1836
01:32:37,620 --> 01:32:46,279
una matriz de strings-- así, por ejemplo,
cuando escribí hace un momento ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, el espacio Z-A-H-Y-L-A, que afirmó que
argv tenía dos cadenas en ./argv0 it--,

1838
01:33:00,150 --> 01:33:03,185
y Z-A-M-Y-L-A. En
otras palabras, argc era 2.

1839
01:33:03,185 --> 01:33:03,980
¿Porqué es eso?

1840
01:33:03,980 --> 01:33:08,370
>> Bueno, efectivamente, lo que está pasando
es en que cada una de estas cadenas

1841
01:33:08,370 --> 01:33:13,990
es, por supuesto, una matriz de caracteres
Como antes, cada uno de cuyos personajes

1842
01:33:13,990 --> 01:33:15,670
ocupa un byte.

1843
01:33:15,670 --> 01:33:19,720
Y no hay que confundir el 0 real
en el nombre del programa con el 0,

1844
01:33:19,720 --> 01:33:22,040
lo que significa que los 80 bits.

1845
01:33:22,040 --> 01:33:27,140
Y Zamyla, por su parte, sigue siendo
También una serie de caracteres.

1846
01:33:27,140 --> 01:33:31,450
>> Así que al final del día, lo que realmente
parece que esta debajo de la campana.

1847
01:33:31,450 --> 01:33:38,800
Pero argv, por la naturaleza de la forma principal
obras, me permite envolver todo esto

1848
01:33:38,800 --> 01:33:44,810
por obtener, si se quiere, un arreglo más grande
que, si un poco más de simplificar

1849
01:33:44,810 --> 01:33:48,180
lo que la imagen se parece y no hacer
bastante dibujar a escala allí,

1850
01:33:48,180 --> 01:33:56,720
esta matriz es solamente de tamaño 2, la primera
elemento de los cuales contiene una cadena,

1851
01:33:56,720 --> 01:33:59,230
el segundo elemento de
que contiene una cadena.

1852
01:33:59,230 --> 01:34:01,687
Y, a su vez, si
tipo de zoom en cada

1853
01:34:01,687 --> 01:34:03,770
de esas cadenas, lo que
ver debajo de la campana

1854
01:34:03,770 --> 01:34:07,190
es que cada cadena es sólo
una matriz de caracteres.

1855
01:34:07,190 --> 01:34:11,680
>> Ahora, al igual que con las cadenas,
hemos sido capaces de conseguir el acceso

1856
01:34:11,680 --> 01:34:15,260
al carácter i-ésimo de una serie
usando esa notación de corchetes.

1857
01:34:15,260 --> 01:34:17,320
Del mismo modo, con matrices
en general, podemos

1858
01:34:17,320 --> 01:34:22,700
utilizar notación de corchetes para obtener
en cualquier número de cadenas en una matriz?

1859
01:34:22,700 --> 01:34:25,100
Por ejemplo, me dejó
seguir adelante y hacerlo.

1860
01:34:25,100 --> 01:34:32,420
>> Déjame seguir adelante y crear argv1.c,
que es un poco diferente esta vez.

1861
01:34:32,420 --> 01:34:35,635
En lugar de la comprobación de argc2,
Voy a hacer esto en su lugar.

1862
01:34:35,635 --> 01:34:41,270
Para int consigo 0, i es menor
que argc, yo y además,

1863
01:34:41,270 --> 01:34:47,920
y luego imprimir en el interior de esta,
ciento s, nueva línea, y luego

1864
01:34:47,920 --> 01:34:50,740
argv soporte de i.

1865
01:34:50,740 --> 01:34:55,220
>> Así, en otras palabras, no estoy tratando con
caracteres individuales en el momento.

1866
01:34:55,220 --> 01:35:00,190
Argv, como se deduce de estos casilla vacía
los apoyos a la derecha del nombre de argv,

1867
01:35:00,190 --> 01:35:03,320
significa argv es una matriz de cadenas.

1868
01:35:03,320 --> 01:35:04,870
Y argc es sólo un int.

1869
01:35:04,870 --> 01:35:08,800
>> Esta línea aquí, 6, es
diciendo conjunto i igual a 0.

1870
01:35:08,800 --> 01:35:11,980
Contar todo el camino hasta,
pero no incluyendo, argc.

1871
01:35:11,980 --> 01:35:14,010
Y a continuación, en cada iteración,
imprimir una cadena.

1872
01:35:14,010 --> 01:35:14,800
Lo cuerda?

1873
01:35:14,800 --> 01:35:17,270
>> La cadena de orden i en argv.

1874
01:35:17,270 --> 01:35:19,530
Así que, antes de que fuera
utilizando el corchete

1875
01:35:19,530 --> 01:35:22,180
notación para llegar a la i-ésima
carácter de una cadena, ahora

1876
01:35:22,180 --> 01:35:27,240
Estoy usando la notación de corchetes
para llegar a la cadena i-ésima de una matriz.

1877
01:35:27,240 --> 01:35:30,310
Así que es algo de una capa
anteriormente, conceptualmente.

1878
01:35:30,310 --> 01:35:35,390
>> Y así, lo que es bueno de este
programa de ahora, si puedo compilar argv1,

1879
01:35:35,390 --> 01:35:42,067
y luego hacer ./argv1 y escriba
en algo así como foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
que son las tres palabras que un defecto
Informático alcanza para cualquier momento

1881
01:35:45,400 --> 01:35:51,010
él o ella necesita algunas palabras de marcador de posición,
y pulse la tecla Enter, cada una de esas palabras,

1882
01:35:51,010 --> 01:35:54,980
incluyendo el nombre del programa, el cual
está en argv en la primera ubicación,

1883
01:35:54,980 --> 01:35:58,320
termina siendo impresas de una en una.

1884
01:35:58,320 --> 01:36:05,290
Y si cambio de esto, y digo
algo así como argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
obtenemos los tres de los
palabras, que es argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, ya que en este
argc caso, el recuento, es 3.

1887
01:36:14,400 --> 01:36:20,020
>> Pero lo que es interesante es si se entiende
argv que es sólo una matriz de cadenas,

1888
01:36:20,020 --> 01:36:24,910
y usted entiende que una cadena
es un conjunto de caracteres,

1889
01:36:24,910 --> 01:36:29,470
en realidad podemos utilizar este tipo de
notación de corchetes varias veces

1890
01:36:29,470 --> 01:36:33,320
para elegir una cadena, y luego elegir
un carácter dentro de la cadena,

1891
01:36:33,320 --> 01:36:35,730
buceo en el más profundo de la siguiente manera.

1892
01:36:35,730 --> 01:36:40,100
En este ejemplo, me dejó ir
adelante y llamar a este argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Y en este ejemplo, déjame ir por delante
y hacer lo following-- para int i obtener 0,

1895
01:36:50,180 --> 01:36:53,286
i es menor que argc, i plus
además, al igual que antes.

1896
01:36:53,286 --> 01:36:55,910
Así, en otra palabras-- y ahora esto
está consiguiendo bastante complicado.

1897
01:36:55,910 --> 01:36:59,940
A continuación voy a decir
iterar sobre cadenas en argv,

1898
01:36:59,940 --> 01:37:01,294
como un comentario a mí mismo.

1899
01:37:01,294 --> 01:37:03,960
Y luego voy a tener una
anidado para el lazo, que es probable

1900
01:37:03,960 --> 01:37:06,290
lo han hecho, o se considera
haciendo, en Scratch, donde

1901
01:37:06,290 --> 01:37:08,600
Voy a decir que soy int--
no se va a utilizar de nuevo i,

1902
01:37:08,600 --> 01:37:12,590
porque yo no quiero a la sombra, o
tipo de sobrescribir el i existente.

1903
01:37:12,590 --> 01:37:15,780
>> Voy a, en lugar de, digamos j, porque
eso es mi ir a la variable después de que,

1904
01:37:15,780 --> 01:37:18,590
cuando yo sólo trato de
contar números simples.

1905
01:37:18,590 --> 01:37:28,850
Para j consigue 0-- y también, n, va a
obtener la longitud de popa del soporte de argv i,

1906
01:37:28,850 --> 01:37:36,030
siempre y cuando j es inferior a m,
j plus plus, haga lo siguiente.

1907
01:37:36,030 --> 01:37:37,500
Y aquí está la parte interesante.

1908
01:37:37,500 --> 01:37:46,330
>> Imprimir un carácter y una nueva línea,
enchufar el soporte argv i, j soporte.

1909
01:37:46,330 --> 01:37:47,940
OK, así que permítanme añadir algunos comentarios aquí.

1910
01:37:47,940 --> 01:37:54,820
Iterar sobre personajes
en la cadena actual,

1911
01:37:54,820 --> 01:38:02,290
impresión de caracteres j-ésimo en la cadena de orden i.

1912
01:38:02,290 --> 01:38:04,630
Así que ahora, vamos a considerar
lo que significan estos comentarios.

1913
01:38:04,630 --> 01:38:06,750
>> Iterar sobre las cuerdas
en argv-- cuántos

1914
01:38:06,750 --> 01:38:09,300
cadenas están en argv, que es una matriz?

1915
01:38:09,300 --> 01:38:13,420
Argc muchos, así que estoy iterando
desde i es igual a 0 hasta argc.

1916
01:38:13,420 --> 01:38:20,020
Mientras tanto, el número de caracteres
se encuentran en la cadena de orden i en argv?

1917
01:38:20,020 --> 01:38:22,880
>> Pues bien, para obtener esa respuesta,
Acabo de llamar longitud de la cadena

1918
01:38:22,880 --> 01:38:26,810
en el cuidado de cadena actual I
aproximadamente, que es argv soporte de i.

1919
01:38:26,810 --> 01:38:30,090
Y voy a almacenar temporalmente que
valor de n, sólo para fines de almacenamiento en caché,

1920
01:38:30,090 --> 01:38:31,590
recordar que para la eficiencia.

1921
01:38:31,590 --> 01:38:36,330
Y luego voy inicializar j a 0,
seguir adelante, siempre y cuando j es menor que n,

1922
01:38:36,330 --> 01:38:38,430
y en cada incremento iteración j.

1923
01:38:38,430 --> 01:38:41,030
>> Y entonces aquí, por
mi comentario en la línea 12,

1924
01:38:41,030 --> 01:38:43,390
imprimir un carácter,
seguido de una nueva línea,

1925
01:38:43,390 --> 01:38:48,140
soporte específicamente argv
i me da la cadena i-ésimo

1926
01:38:48,140 --> 01:38:51,690
en argv-- por lo que la primera palabra, la
segunda palabra, la tercera palabra, lo que sea.

1927
01:38:51,690 --> 01:38:57,370
Y cae en picado en j más profundo, y obtiene
yo el carácter j-ésimo de la palabra.

1928
01:38:57,370 --> 01:39:02,200
Y así, en efecto, se puede tratar
argv como un multi-dimensional,

1929
01:39:02,200 --> 01:39:06,050
como una de dos dimensiones, matriz,
de modo que cada palabra amable de miradas

1930
01:39:06,050 --> 01:39:08,580
como este en su mente de
ojo, y cada personaje

1931
01:39:08,580 --> 01:39:10,930
es una especie de compuesto en
una columna, si eso ayuda.

1932
01:39:10,930 --> 01:39:13,260
>> En realidad, cuando nos burlamos
esta separación, en las semanas siguientes,

1933
01:39:13,260 --> 01:39:15,580
que va a ser un poco
más sofisticado que eso.

1934
01:39:15,580 --> 01:39:17,800
Pero lo que realmente puede
pensar en que, por ahora,

1935
01:39:17,800 --> 01:39:22,110
tan sólo por esta bidimensional
matriz, por lo que un nivel de ella

1936
01:39:22,110 --> 01:39:23,260
es todo de las cuerdas.

1937
01:39:23,260 --> 01:39:26,760
Y entonces si buceo en el más profundo,
puede llegar a los caracteres individuales

1938
01:39:26,760 --> 01:39:29,600
en ella mediante el uso de esta notación aquí.

1939
01:39:29,600 --> 01:39:31,620
>> Entonces, ¿cuál es el efecto neto?

1940
01:39:31,620 --> 01:39:34,970
Déjame ir adelante y
hacer rematadamente argv2-- ella.

1941
01:39:34,970 --> 01:39:36,210
He cometido un error aquí.

1942
01:39:36,210 --> 01:39:40,160
Declarando implícitamente la
stirling función de biblioteca.

1943
01:39:40,160 --> 01:39:42,190
Así que todo este tiempo, es
quizá apropiada

1944
01:39:42,190 --> 01:39:45,130
que estamos tipo de acabado
exactamente donde empezamos.

1945
01:39:45,130 --> 01:39:48,160
>> Cometí un error, declarando implícitamente
stirling función de biblioteca.

1946
01:39:48,160 --> 01:39:48,987
OK, espera un minuto.

1947
01:39:48,987 --> 01:39:51,070
Recuerdo que, sobre todo
ya que está justo aquí.

1948
01:39:51,070 --> 01:39:54,490
Necesito incluir en string.h
esta versión del programa.

1949
01:39:54,490 --> 01:40:00,050
>> Déjame ir adelante y incluyo
string.h, salvo que, adelante

1950
01:40:00,050 --> 01:40:04,460
y recompilar argv2.

1951
01:40:04,460 --> 01:40:08,390
Y ahora, aquí vamos, que argv2, Intro.

1952
01:40:08,390 --> 01:40:10,590
Y aunque es un poco
críptica a primera vista,

1953
01:40:10,590 --> 01:40:15,690
notar que, en efecto, lo
se imprime es argv2 punto.

1954
01:40:15,690 --> 01:40:19,970
>> Pero si escribo algunas palabras después de la
símbolo, como argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Introduce, también un poco
críptica a primera vista.

1956
01:40:22,560 --> 01:40:30,540
Pero si nos desplazamos hacia arriba,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Para ello hemos repiten a lo largo de cada palabra.

1958
01:40:32,190 --> 01:40:37,770
Y, a su vez, hemos repiten a lo largo
todos los personajes dentro de una palabra.

1959
01:40:37,770 --> 01:40:40,040
>> Ahora, después de todo esto,
se dan cuenta de que hay

1960
01:40:40,040 --> 01:40:43,120
otro detalle que hemos estado especie
haciendo caso omiso de todo este tiempo.

1961
01:40:43,120 --> 01:40:46,180
Simplemente, se separan lo
las entradas del principal puede ser?

1962
01:40:46,180 --> 01:40:47,780
¿Qué pasa con la producción del principal?

1963
01:40:47,780 --> 01:40:50,540
>> Todo este tiempo, hemos sido
sólo copiar y pegar

1964
01:40:50,540 --> 01:40:53,870
la palabra int frente principal,
aunque es posible ver en línea,

1965
01:40:53,870 --> 01:40:58,340
a veces incorrectamente en las versiones anteriores
de C y compiladores, que dicen vacío,

1966
01:40:58,340 --> 01:40:59,410
o nada en absoluto.

1967
01:40:59,410 --> 01:41:01,580
Pero, de hecho, para la versión
de C que estamos utilizando,

1968
01:41:01,580 --> 01:41:06,180
C 11, o 2011, cuenta
que debe ser int.

1969
01:41:06,180 --> 01:41:09,300
Y debe ser o bien
nula o argc y argv aquí.

1970
01:41:09,300 --> 01:41:10,790
>> Pero ¿por qué int main?

1971
01:41:10,790 --> 01:41:12,480
¿Cómo es en realidad regresando?

1972
01:41:12,480 --> 01:41:16,280
Pues bien, resulta que todo este tiempo,
cualquier momento usted ha escrito un programa principal

1973
01:41:16,280 --> 01:41:18,440
Siempre está volviendo algo.

1974
01:41:18,440 --> 01:41:19,960
Pero ha estado haciendo en secreto.

1975
01:41:19,960 --> 01:41:23,350
>> Ese algo es una
int, como sugiere la línea 5.

1976
01:41:23,350 --> 01:41:24,225
Pero lo int?

1977
01:41:24,225 --> 01:41:26,100
Bueno, hay una
convención en la programación,

1978
01:41:26,100 --> 01:41:29,790
por lo que si no tiene
salido mal y todo está bien,

1979
01:41:29,790 --> 01:41:34,250
programas y funciones en general
return-- algo counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 significa generalmente que todo está bien.

1982
01:41:38,070 --> 01:41:40,610
Así que, aunque se piensa en
como falsa en muchos contextos,

1983
01:41:40,610 --> 01:41:42,930
que en realidad significa generalmente una buena cosa

1984
01:41:42,930 --> 01:41:49,560
>> Mientras tanto, si un programa vuelve 1,
o negativo 1, o 5, o negativo 42,

1985
01:41:49,560 --> 01:41:52,941
o cualquier valor que no sea 0,
eso significa generalmente

1986
01:41:52,941 --> 01:41:54,190
que algo ha ido mal.

1987
01:41:54,190 --> 01:41:56,700
De hecho, en su propio Mac o PC,
es posible que haya visto realmente

1988
01:41:56,700 --> 01:42:01,050
un mensaje de error, mediante la cual
dice una cosa u otra, el error

1989
01:42:01,050 --> 01:42:04,940
código negativo 42, o código de error
23, o algo por el estilo.

1990
01:42:04,940 --> 01:42:08,980
Ese número es por lo general sólo un toque
para el programador, o la empresa

1991
01:42:08,980 --> 01:42:11,174
Eso hizo que el software,
lo que salió mal y por qué,

1992
01:42:11,174 --> 01:42:13,590
de modo que puedan mirar a través
su documentación o código,

1993
01:42:13,590 --> 01:42:15,465
y averiguar cuál es el
de error realmente significa.

1994
01:42:15,465 --> 01:42:18,400
Por lo general, no es
útil para nosotros los usuarios finales.

1995
01:42:18,400 --> 01:42:20,550
>> Pero cuando principales devuelve 0, todo está bien.

1996
01:42:20,550 --> 01:42:23,770
Y si no se especifica
lo principal debe devolver,

1997
01:42:23,770 --> 01:42:26,950
se acaba de forma automática
devolver 0 para usted.

1998
01:42:26,950 --> 01:42:30,870
Pero volviendo algo
lo demás es realmente útil.

1999
01:42:30,870 --> 01:42:34,660
>> En este programa final, me dejó
seguir adelante y llamar a este exit.c,

2000
01:42:34,660 --> 01:42:38,630
e introducir el último de hoy
temas, conocido como un código de error.

2001
01:42:38,630 --> 01:42:42,930
Déjame ir por delante e incluye nuestra
archivos conocidos hasta la parte superior, hacen int principal.

2002
01:42:42,930 --> 01:42:49,500
Y esta vez, vamos a hacer int argc,
argv cadena, y con mis soportes

2003
01:42:49,500 --> 01:42:50,836
dar a entender que está en la matriz.

2004
01:42:50,836 --> 01:42:52,460
Y entonces me dejaron de hacer una comprobación de validez.

2005
01:42:52,460 --> 01:42:56,640
Esta vez, si no lo hace argc
igual a 2, entonces sabes qué?

2006
01:42:56,640 --> 01:42:57,520
Olvídalo.

2007
01:42:57,520 --> 01:43:03,170
Voy a decir que, bueno, usuario,
se echa en falta el argumento de línea de comandos

2008
01:43:03,170 --> 01:43:04,210
n barra invertida.

2009
01:43:04,210 --> 01:43:05,230
>> Y entonces eso es todo.

2010
01:43:05,230 --> 01:43:06,130
Deseo salir.

2011
01:43:06,130 --> 01:43:11,030
Voy a manera preventiva,
y prematuramente realmente, el regreso

2012
01:43:11,030 --> 01:43:12,810
algo que no sea el número 1.

2013
01:43:12,810 --> 01:43:15,360
El sitio al que ir para el primer valor
error que puede ocurrir es 1.

2014
01:43:15,360 --> 01:43:17,860
Si tiene alguna otra errónea
situación que pueda producirse,

2015
01:43:17,860 --> 01:43:21,390
se podría decir de retorno de 2 o devolver 3, o
tal vez incluso negativo o negativo 1 2.

2016
01:43:21,390 --> 01:43:23,750
>> Estos son sólo los códigos de salida
que son, en general,

2017
01:43:23,750 --> 01:43:27,770
sólo es útil para el programador, o el
compañía que ha de enviar el software.

2018
01:43:27,770 --> 01:43:30,500
Pero el hecho de que es
No 0 es lo importante.

2019
01:43:30,500 --> 01:43:34,310
Así que si en este programa, quiero
garantizar que este programa sólo

2020
01:43:34,310 --> 01:43:38,190
funciona si el usuario me ofrece
con un número de argumentos de dos,

2021
01:43:38,190 --> 01:43:42,880
el nombre del programa, y ​​algún otro
palabra, que puede valer tanto como sigue,

2022
01:43:42,880 --> 01:43:46,110
gritar al usuario con dicho printf,
faltan argumentos de línea de comandos,

2023
01:43:46,110 --> 01:43:46,970
volver 1.

2024
01:43:46,970 --> 01:43:49,940
Que se acaba de inmediato
salir del programa.

2025
01:43:49,940 --> 01:43:55,840
>> Sólo si argc es igual a 2 habrá que bajar
aquí, en ese momento me voy a decir,

2026
01:43:55,840 --> 01:44:00,410
hola ciento s, la barra invertida n, argv1.

2027
01:44:00,410 --> 01:44:03,827
En otras palabras, estoy
No va después de argv 0,

2028
01:44:03,827 --> 01:44:05,410
que es sólo el nombre del programa.

2029
01:44:05,410 --> 01:44:09,450
Quiero imprimir hola, coma,
la segunda palabra que escribió el ser humano.

2030
01:44:09,450 --> 01:44:12,580
Y en este caso en
línea 13, todo está bien.

2031
01:44:12,580 --> 01:44:15,920
>> Sé que argc es 2
lógicamente de este programa.

2032
01:44:15,920 --> 01:44:17,770
Voy a seguir adelante y volver 0.

2033
01:44:17,770 --> 01:44:21,230
Dicho sea de paso, tener en cuenta que
esto es cierto en Scratch también.

2034
01:44:21,230 --> 01:44:24,760
>> Lógicamente, podría hacer esto
y encapsular estas líneas

2035
01:44:24,760 --> 01:44:27,020
del código de esta otra cláusula aquí.

2036
01:44:27,020 --> 01:44:29,420
Pero eso es una especie de
innecesariamente sangría mi código.

2037
01:44:29,420 --> 01:44:31,800
Y quiero hacer súper
claro que no importa qué,

2038
01:44:31,800 --> 01:44:34,670
de forma predeterminada, hola
algo va a conseguir impreso,

2039
01:44:34,670 --> 01:44:36,050
siempre que el usuario coopera.

2040
01:44:36,050 --> 01:44:39,360
>> Así que es muy común el uso de
una condición, sólo un caso,

2041
01:44:39,360 --> 01:44:41,870
para coger un poco errónea
situación, y luego salir.

2042
01:44:41,870 --> 01:44:45,690
Y luego, siempre es todo
así, no tener una cosa,

2043
01:44:45,690 --> 01:44:48,060
pero sólo tienen el código
fuera de que si, porque es

2044
01:44:48,060 --> 01:44:51,060
equivalentes en este
Caso particular, lógicamente.

2045
01:44:51,060 --> 01:44:54,480
Así que estoy devolviendo un 0, sólo para
significan explícitamente que todo está bien.

2046
01:44:54,480 --> 01:44:58,480
>> Si he omitido el retorno 0, lo haría
ser asumida de forma automática para mí.

2047
01:44:58,480 --> 01:45:00,890
Pero ahora que estoy volviendo
uno por lo menos en este caso,

2048
01:45:00,890 --> 01:45:04,940
Voy a, por si acaso, y
claridad, devuelven 0 en este caso.

2049
01:45:04,940 --> 01:45:09,690
Así que ahora quiero seguir adelante y hacer la salida,
que es una transición perfecta para dejar sólo.

2050
01:45:09,690 --> 01:45:14,401
>> Pero hacer la salida, y me dejó ir
adelante y hacer ./exit, Intro.

2051
01:45:14,401 --> 01:45:16,900
Y el programa me gritó,
falta argumento de línea de comandos.

2052
01:45:16,900 --> 01:45:18,120
OK, déjame cooperar.

2053
01:45:18,120 --> 01:45:23,810
>> Permítanme hacer lugar ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Y ahora se dice, hola David.

2055
01:45:25,190 --> 01:45:27,300
Y que normalmente no ver esto.

2056
01:45:27,300 --> 01:45:30,650
>> Pero resulta que hay una
de manera especial en Linux para ver realmente

2057
01:45:30,650 --> 01:45:34,470
con lo que la salida código de un programa se cierra.

2058
01:45:34,470 --> 01:45:37,184
A veces en una gráfica
mundo como Mac OS o Windows,

2059
01:45:37,184 --> 01:45:40,100
sólo se ve estos números cuando una
mensaje de error aparece en la pantalla

2060
01:45:40,100 --> 01:45:41,940
y el programador
que muestra que el número.

2061
01:45:41,940 --> 01:45:44,773
Pero si queremos ver lo que el error
el mensaje es, podemos hacerlo aquí--

2062
01:45:44,773 --> 01:45:48,100
por lo ./exit, Enter, imprimir
falta argumento de línea de comandos.

2063
01:45:48,100 --> 01:45:54,590
>> Si ahora lo hago eco $ ?, que es
ridículamente críptica buscando.

2064
01:45:54,590 --> 01:45:56,590
Pero $?

2065
01:45:56,590 --> 01:45:59,220
es el encantamiento mágico
que dice, oye, ordenador,

2066
01:45:59,220 --> 01:46:01,900
dime lo que el anterior
código de salida del programa era.

2067
01:46:01,900 --> 01:46:03,410
Y llegué a Enter.

2068
01:46:03,410 --> 01:46:07,520
Veo a 1, porque eso es lo que yo
dicho a mi función principal para volver.

2069
01:46:07,520 --> 01:46:12,310
>> Mientras tanto, si hago ./exit David,
y pulsa enter, veo, hola David.

2070
01:46:12,310 --> 01:46:16,800
Y si ahora lo hago eco $ ?, veo hola 0.

2071
01:46:16,800 --> 01:46:19,080
Y así esto va
ser información valiosa

2072
01:46:19,080 --> 01:46:23,420
en el contexto de el depurador, no tan
tanto que, el ser humano, le importaría.

2073
01:46:23,420 --> 01:46:26,060
Sin embargo, el depurador y otra
los programas que vamos a usar en este semestre

2074
01:46:26,060 --> 01:46:29,420
a menudo mirar a ese número,
a pesar de que es una especie de escondido

2075
01:46:29,420 --> 01:46:32,780
a menos que usted lo busca, a
determinar si un programa de o no

2076
01:46:32,780 --> 01:46:37,050
ejecución fue correcta o incorrecta.

2077
01:46:37,050 --> 01:46:40,450
>> Y por lo que nos lleva a
esto, al final del día.

2078
01:46:40,450 --> 01:46:43,917
Empezamos hoy examinado
depuración, ya su vez en el curso

2079
01:46:43,917 --> 01:46:46,750
sí, y luego más interesante,
técnicamente debajo de la campana

2080
01:46:46,750 --> 01:46:49,490
en qué cadenas son, que duró
semana nos lo tomamos por sentado,

2081
01:46:49,490 --> 01:46:51,900
y desde luego los llevó
por sentado en Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Seguidamente, examinamos cómo podemos acceder
caracteres individuales en una cadena,

2083
01:46:56,040 --> 01:47:00,310
y luego volvió a tomar un nivel más alto
mirar las cosas, mirando cómo bien--

2084
01:47:00,310 --> 01:47:04,226
Si queremos llegar a nivel individual
elementos de una lista como la estructura,

2085
01:47:04,226 --> 01:47:05,850
no podemos hacer eso con varias cadenas?

2086
01:47:05,850 --> 01:47:08,050
Y que podemos con los argumentos de línea de comandos.

2087
01:47:08,050 --> 01:47:12,800
Pero esta imagen de aquí sólo cajas
es demostrativa de esta idea general

2088
01:47:12,800 --> 01:47:14,451
de una matriz o una lista o un vector.

2089
01:47:14,451 --> 01:47:16,450
Y dependiendo de la
contexto, todas estas palabras

2090
01:47:16,450 --> 01:47:17,880
significados ligeramente diferentes.

2091
01:47:17,880 --> 01:47:20,060
Así que en C, sólo vamos
hablar de una matriz.

2092
01:47:20,060 --> 01:47:23,840
Y una matriz es un trozo
de la memoria, cada uno de los cuales es

2093
01:47:23,840 --> 01:47:27,720
elementos son contiguos, de nuevo,
hacia atrás, hacia atrás, hacia atrás.

2094
01:47:27,720 --> 01:47:31,970
>> Y esos elementos son, por lo general,
del mismo tipo de datos, carácter,

2095
01:47:31,970 --> 01:47:35,966
carácter, caracteres, carácter, o
cadena, cadena, cadena, cadena, o int,

2096
01:47:35,966 --> 01:47:38,600
int, int, sea lo que sea
estamos tratando de almacenar.

2097
01:47:38,600 --> 01:47:42,540
Pero al final del día, esto es
lo que parece conceptualmente.

2098
01:47:42,540 --> 01:47:44,530
Usted está tomando su
memoria o RAM del ordenador.

2099
01:47:44,530 --> 01:47:48,590
Y que está tallado a cabo en
cajas de idéntico tamaño, todos los cuales

2100
01:47:48,590 --> 01:47:50,920
están de vuelta, hacia atrás, a
de nuevo, a la parte posterior de esta manera.

2101
01:47:50,920 --> 01:47:53,200
>> Y lo que es bueno de
esta idea, y el hecho de

2102
01:47:53,200 --> 01:47:58,580
que podemos expresar los valores de esta manera
con la primera de nuestras estructuras de datos

2103
01:47:58,580 --> 01:48:02,520
en la clase, significa que podemos empezar
para resolver problemas con el código

2104
01:48:02,520 --> 01:48:04,079
que llegaron de manera intuitiva en la semana 0.

2105
01:48:04,079 --> 01:48:05,870
Usted recordará el teléfono
ejemplo libro, donde

2106
01:48:05,870 --> 01:48:09,110
se utilizó un divide y vencerás,
o un algoritmo de búsqueda binario,

2107
01:48:09,110 --> 01:48:13,220
para tamizar a través de un conjunto
montón de nombres y números.

2108
01:48:13,220 --> 01:48:18,220
Pero hemos supuesto, recordar, que esa
libreta de teléfonos que ya se solucionó,

2109
01:48:18,220 --> 01:48:21,630
que otra persona ya tenía
Robusto out-- dado una lista de nombres

2110
01:48:21,630 --> 01:48:24,430
y numbers-- cómo alfabéticamente ellos.

2111
01:48:24,430 --> 01:48:26,950
Y ahora que estamos en C,
también, tener la capacidad

2112
01:48:26,950 --> 01:48:30,290
para poner las cosas, no se
físicamente en una libreta de teléfonos

2113
01:48:30,290 --> 01:48:34,220
pero prácticamente en un ordenador de
memoria, seremos capaces próxima semana

2114
01:48:34,220 --> 01:48:38,470
introducir de nuevo la primera esto--
de nuestras estructuras de datos en un array--

2115
01:48:38,470 --> 01:48:43,530
pero lo más importante, equipo real
algoritmos implementados ciencia

2116
01:48:43,530 --> 01:48:47,720
en el código, con el que podemos almacenar
los datos en las estructuras de este tipo,

2117
01:48:47,720 --> 01:48:50,730
y luego empezar a manipularla, y
para resolver efectivamente los problemas con ella,

2118
01:48:50,730 --> 01:48:53,570
y construir encima de eso,
en última instancia, los programas en C,

2119
01:48:53,570 --> 01:48:56,730
en Python, en JavaScript,
la consulta de bases de datos con SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Y veremos que todos estos
ideas diferentes de enclavamiento.

2121
01:48:59,980 --> 01:49:04,100
Pero por ahora, recordar que la
dominio que presentamos hoy

2122
01:49:04,100 --> 01:49:06,920
Fue esta cosa aquí, y
el mundo de la criptografía.

2123
01:49:06,920 --> 01:49:11,200
Y entre los siguientes problemas que usted mismo
va a resolver es el arte de la criptografía,

2124
01:49:11,200 --> 01:49:13,630
aleatorización y desaleatorización
información, y de cifrado

2125
01:49:13,630 --> 01:49:15,930
y descifrar el texto,
y suponiendo que en última instancia

2126
01:49:15,930 --> 01:49:18,970
que ahora sabe lo
que hay debajo del capó

2127
01:49:18,970 --> 01:49:21,860
de manera que cuando se ve o recibe
un mensaje como este,

2128
01:49:21,860 --> 01:49:24,060
usted mismo puede descifrarlo.

2129
01:49:24,060 --> 01:49:26,740
Todo esto, y más la próxima vez.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [REPRODUCCIÓN DE VÍDEO]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Acaba de llegar.

2133
01:49:32,970 --> 01:49:35,146
Voy a ir a visitar
su profesor de la universidad.

2134
01:49:35,146 --> 01:49:37,611
Sí.

2135
01:49:37,611 --> 01:49:40,080
Hola.

2136
01:49:40,080 --> 01:49:40,660
Eres tu.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
¡Espere!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Sólo estoy tratando de entender
lo que le pasó.

2142
01:49:56,060 --> 01:49:58,130
Por favor, cualquier cosa podría ayudar.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Eras su universidad
compañero de piso, ¿verdad?

2145
01:50:08,354 --> 01:50:10,770
Usted estaba allí con él cuando
terminó el proyecto CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [REPRODUCIENDO MÚSICA]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> Eso fue CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Amo este lugar.

2152
01:50:44,770 --> 01:50:45,854
>> -Comer hasta.

2153
01:50:45,854 --> 01:50:47,020
Vamos a salir de los negocios.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [FIN DE REPRODUCCIÓN]

