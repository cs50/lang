1
00:00:00,000 --> 00:00:02,970
>> [RIPRODUZIONE DI BRANI MUSICALI]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> David J. MALAN: Va bene.

4
00:00:15,700 --> 00:00:18,832
Questo è CS50 e questo
è l'inizio della Settimana 2.

5
00:00:18,832 --> 00:00:21,040
E vi ricordate che oltre
la ultime due settimane,

6
00:00:21,040 --> 00:00:24,490
abbiamo introdotto calcolatore
scienza e, a sua volta, programmazione.

7
00:00:24,490 --> 00:00:27,640
>> E abbiamo iniziato la storia per mezzo di
Scratch, che linguaggio grafico

8
00:00:27,640 --> 00:00:28,990
dal MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
E poi, più recentemente,
la scorsa settimana, abbiamo fatto noi

10
00:00:30,780 --> 00:00:34,450
introdurre un higher-- un
lingua di livello inferiore noto

11
00:00:34,450 --> 00:00:36,770
come C, qualcosa che è puramente testuale.

12
00:00:36,770 --> 00:00:39,440
E, in effetti, l'ultima volta che abbiamo
esplorato in tale contesto

13
00:00:39,440 --> 00:00:40,450
una serie di concetti.

14
00:00:40,450 --> 00:00:43,010
>> Questo, richiamo, era molto
primo programma abbiamo guardato.

15
00:00:43,010 --> 00:00:45,710
E questo programma, molto semplicemente,
stampa fuori, "ciao, mondo".

16
00:00:45,710 --> 00:00:47,730
Ma c'è così tanto
magia apparente in corso.

17
00:00:47,730 --> 00:00:51,460
C'è questo #include
con queste parentesi angolari.

18
00:00:51,460 --> 00:00:52,170
C'è int.

19
00:00:52,170 --> 00:00:53,020
C'è (void).

20
00:00:53,020 --> 00:00:56,330
C'è parentesi, parentesi graffe,
punto e virgola, e molto altro ancora.

21
00:00:56,330 --> 00:00:58,480
>> E così, ricordare che
abbiamo introdotto Scratch

22
00:00:58,480 --> 00:01:02,110
in modo da poter, idealmente, a vedere oltre
che la sintassi, la roba che non è davvero

23
00:01:02,110 --> 00:01:04,590
tutto ciò che intellettualmente
interessante, ma nella fase iniziale

24
00:01:04,590 --> 00:01:07,700
è, assolutamente, un po 'complicato
per avvolgere la mente intorno.

25
00:01:07,700 --> 00:01:10,860
E, infatti, uno dei più comuni
le cose presto in una classe di programmazione,

26
00:01:10,860 --> 00:01:13,443
soprattutto per quelli meno
comodo, è quello di ottenere frustrati dalla

27
00:01:13,443 --> 00:01:17,460
e scattato da certa sintattica
errori, per non parlare di errori logici.

28
00:01:17,460 --> 00:01:19,800
E così tra i nostri obiettivi
Oggi, in realtà, la volontà

29
00:01:19,800 --> 00:01:23,280
essere quello di equipaggiare con un po '
tecniche di problem solving per come

30
00:01:23,280 --> 00:01:26,705
per risolvere meglio i problemi stessi
sotto forma di debug.

31
00:01:26,705 --> 00:01:29,330
E vi ricordate, inoltre, che il
ambiente che abbiamo introdotto

32
00:01:29,330 --> 00:01:31,780
ultima volta che è stato chiamato CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Questo è un software web-based che
permette di programmare in the cloud,

34
00:01:34,850 --> 00:01:38,450
per così dire, mantenendo tutti i tuoi
file insieme, come abbiamo di nuovo sarà oggi.

35
00:01:38,450 --> 00:01:41,480
E ricordare che noi
rivisitato questi argomenti qui,

36
00:01:41,480 --> 00:01:44,480
fra loro funzioni, e loop, e
variabili, e le espressioni booleane,

37
00:01:44,480 --> 00:01:45,110
e condizioni.

38
00:01:45,110 --> 00:01:49,190
E in realtà un po 'di più che abbiamo
tradotto dal mondo di Scratch

39
00:01:49,190 --> 00:01:50,800
nel mondo di C.

40
00:01:50,800 --> 00:01:53,220
>> Ma l'edificio fondamentale
blocchi, per così dire,

41
00:01:53,220 --> 00:01:55,150
erano in realtà ancora lo stesso della scorsa settimana.

42
00:01:55,150 --> 00:01:57,900
In realtà, abbiamo davvero avuto solo un
pezzo di puzzle diverso, se si vuole.

43
00:01:57,900 --> 00:02:00,300
Invece di che viola
salvare blocco, noi invece

44
00:02:00,300 --> 00:02:02,940
aveva printf, che è
questa funzione in C che

45
00:02:02,940 --> 00:02:05,890
consente di stampare qualcosa
e formattarla sullo schermo.

46
00:02:05,890 --> 00:02:07,950
Abbiamo introdotto il CS50
Biblioteca, dove si

47
00:02:07,950 --> 00:02:11,420
hanno ora a vostra disposizione get_char,
e get_int, e get_string,

48
00:02:11,420 --> 00:02:14,610
e alcune altre funzioni come
bene, tramite il quale è possibile ottenere in ingresso

49
00:02:14,610 --> 00:02:16,260
dalla propria tastiera dell'utente.

50
00:02:16,260 --> 00:02:20,640
E abbiamo anche preso uno sguardo alle cose
come these- bool, e char,

51
00:02:20,640 --> 00:02:22,490
e doppio, galleggiante,
int, string long_long.

52
00:02:22,490 --> 00:02:25,170
E ci sono anche altri tipi di dati in C.

53
00:02:25,170 --> 00:02:28,560
>> In altre parole, quando si dichiara
una variabile per memorizzare un certo valore,

54
00:02:28,560 --> 00:02:32,600
o quando si implementa una funzione
che restituisce un valore,

55
00:02:32,600 --> 00:02:35,290
è possibile specificare quali
tipo di valore che è.

56
00:02:35,290 --> 00:02:37,310
È una stringa, come un
sequenza di caratteri?

57
00:02:37,310 --> 00:02:39,490
È un numero, come un intero?

58
00:02:39,490 --> 00:02:41,390
Si tratta di una virgola mobile
il valore, o simili?

59
00:02:41,390 --> 00:02:46,180
Quindi, in C, a differenza di Scratch, abbiamo effettivamente
ha cominciato a specificare il tipo di dati

60
00:02:46,180 --> 00:02:48,330
eravamo di ritorno o utilizzando.

61
00:02:48,330 --> 00:02:51,910
>> Ma, naturalmente, abbiamo anche incontrato
alcuni limiti fondamentali dell'informatica.

62
00:02:51,910 --> 00:02:54,100
Ed in particolare,
questo linguaggio C, richiamo

63
00:02:54,100 --> 00:02:57,070
che abbiamo preso uno sguardo
integer overflow, la realtà

64
00:02:57,070 --> 00:03:00,460
che se avete solo un
quantità limitata di memoria

65
00:03:00,460 --> 00:03:04,600
o, in particolare, un numero finito
di bit, si può contare così in alto solo.

66
00:03:04,600 --> 00:03:08,460
E così abbiamo guardato questo esempio qui
quale un contatore in un aeroplano,,

67
00:03:08,460 --> 00:03:13,510
in realtà, se in esecuzione abbastanza a lungo sarebbe
traboccare e tradursi in un software

68
00:03:13,510 --> 00:03:15,560
un errore potenziale fisico.

69
00:03:15,560 --> 00:03:18,600
>> Abbiamo anche guardato galleggiante
punto di imprecisione, la realtà

70
00:03:18,600 --> 00:03:22,280
che con solo un numero finito
di bit, se è 32 o 64,

71
00:03:22,280 --> 00:03:27,330
è possibile specificare solo tanti numeri
dopo un punto decimale, dopo di che si

72
00:03:27,330 --> 00:03:29,110
cominciare ad ottenere impreciso.

73
00:03:29,110 --> 00:03:32,360
Così, per esempio, un terzo nel
mondo qui, nel nostro mondo umano,

74
00:03:32,360 --> 00:03:35,360
quello che sappiamo è solo un numero infinito
di 3 secondi dopo il punto decimale.

75
00:03:35,360 --> 00:03:38,820
Ma un computer non può necessariamente
rappresentare un numero infinito di numeri

76
00:03:38,820 --> 00:03:42,590
se si consente solo un po '
quantità limitata di informazioni.

77
00:03:42,590 --> 00:03:45,900
>> Quindi non solo abbiamo si dotare
con maggiore potenza in termini

78
00:03:45,900 --> 00:03:49,280
di come si potrebbe esprimersi a
una tastiera in termini di programmazione,

79
00:03:49,280 --> 00:03:51,430
abbiamo anche limitato ciò che
si può effettivamente fare.

80
00:03:51,430 --> 00:03:55,790
E in effetti, gli insetti e gli errori possono
derivare da questi tipi di problemi.

81
00:03:55,790 --> 00:03:59,900
E infatti, tra i temi di oggi
stanno per essere argomenti come il debug

82
00:03:59,900 --> 00:04:03,699
e in realtà guardando sotto il cofano
il modo in cui sono state introdotte le cose la scorsa settimana

83
00:04:03,699 --> 00:04:05,490
sono in realtà costituiti
in modo che è meglio

84
00:04:05,490 --> 00:04:10,530
comprendere sia le funzionalità di e
i limiti di una lingua come C.

85
00:04:10,530 --> 00:04:14,770
>> E infatti, ci sbucciamo gli strati
dei più semplici di struttura dati,

86
00:04:14,770 --> 00:04:17,756
qualcosa chiamato un array, che
Scratch capita di chiamare una "lista".

87
00:04:17,756 --> 00:04:19,589
E 'un po'
diverso in quel contesto.

88
00:04:19,589 --> 00:04:23,340
E poi ci sarà anche introdurre uno dei
primo dei nostri problemi specifici del dominio

89
00:04:23,340 --> 00:04:26,790
in CS50, il mondo del
la crittografia, l'arte di scrambling

90
00:04:26,790 --> 00:04:29,650
o in cifratura informazioni in modo
che è possibile inviare messaggi segreti

91
00:04:29,650 --> 00:04:34,520
e decodificare messaggi segreti
tra due persone, A e B.

92
00:04:34,520 --> 00:04:37,490
>> Quindi, prima di transizione
a quel nuovo mondo,

93
00:04:37,490 --> 00:04:42,059
cerchiamo di equipaggiare con un po '
le tecniche con cui è possibile eliminare

94
00:04:42,059 --> 00:04:43,850
o ridurre almeno alcuni
delle frustrazioni

95
00:04:43,850 --> 00:04:46,630
che probabilmente avete incontrato
durante la scorsa settimana da solo.

96
00:04:46,630 --> 00:04:50,830
In effetti, di fronte a voi sono such-- alcuni dei
i primi problemi in C. E le probabilità sono,

97
00:04:50,830 --> 00:04:54,010
se siete come me, la prima volta
si tenta di digitare un programma,

98
00:04:54,010 --> 00:04:57,330
anche se si pensa logicamente
il programma è piuttosto semplice,

99
00:04:57,330 --> 00:05:01,200
si potrebbe benissimo colpito un muro, e
il compilatore non ha intenzione di collaborare.

100
00:05:01,200 --> 00:05:03,940
Fare o Clang non sta andando
per fare in realtà la vostra offerta.

101
00:05:03,940 --> 00:05:05,450
>> E perché sarebbe?

102
00:05:05,450 --> 00:05:07,950
Bene, diamo uno sguardo a,
forse, un semplice programma.

103
00:05:07,950 --> 00:05:11,190
Ho intenzione di andare avanti e salvare questo in
un file volutamente chiamato buggy0.c,

104
00:05:11,190 --> 00:05:13,590
perché so che a
essere viziata in anticipo.

105
00:05:13,590 --> 00:05:17,400
Ma potrei non si rendono conto che se questo
è il primo o secondo o terzo programma

106
00:05:17,400 --> 00:05:18,830
che sto facendo in realtà me stesso.

107
00:05:18,830 --> 00:05:23,820
Quindi ho intenzione di andare avanti e
tipo out, int main (void).

108
00:05:23,820 --> 00:05:28,130
E poi all'interno delle mie parentesi graffe,
un molto familiare ( "ciao, world--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - e un punto e virgola.

110
00:05:30,980 --> 00:05:32,360
>> Ho salvato il file.

111
00:05:32,360 --> 00:05:34,850
Ora ho intenzione di andare verso il basso
alla mia finestra di terminale

112
00:05:34,850 --> 00:05:40,340
e tipo make buggy0, perché, di nuovo,
il nome del file di oggi è buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Così scrivo fare buggy0, Invio.

114
00:05:43,660 --> 00:05:48,200
>> E, oh, caspita, ricordare dall'ultima volta
che nessun messaggio di errore è una buona cosa.

115
00:05:48,200 --> 00:05:49,740
Quindi nessuna uscita è una buona cosa.

116
00:05:49,740 --> 00:05:52,920
Ma qui ho chiaramente
un numero di errori.

117
00:05:52,920 --> 00:05:56,470
>> Quindi la prima linea di uscita
dopo aver digitato fare buggy0, richiamo,

118
00:05:56,470 --> 00:05:59,540
è uscita piuttosto verboso di Clang.

119
00:05:59,540 --> 00:06:02,067
Sotto il cofano,
CS50 IDE è configurato

120
00:06:02,067 --> 00:06:04,150
di utilizzare tutta una serie di
opzioni con questo compilatore

121
00:06:04,150 --> 00:06:05,941
in modo che non si dispone di
pensare a loro.

122
00:06:05,941 --> 00:06:08,840
E questo è tutto ciò che prima linea
mezzi che inizia con Clang.

123
00:06:08,840 --> 00:06:11,720
>> Ma dopo che, i problemi
cominciare a fare la loro comparsa.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c sulla linea 3, carattere
5, vi è un grande errore rossa.

125
00:06:17,390 --> 00:06:18,380
Cos'è quello?

126
00:06:18,380 --> 00:06:23,562
dichiarando implicitamente funzione di libreria
printf con tipo int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Voglio dire, è molto rapidamente
diventa molto arcane.

129
00:06:28,379 --> 00:06:30,170
E certamente, a prima
sguardo, non ci

130
00:06:30,170 --> 00:06:32,380
aspetto che tu capisca la
elementi di quel messaggio.

131
00:06:32,380 --> 00:06:34,213
E così una delle lezioni
per oggi sta andando

132
00:06:34,213 --> 00:06:36,919
essere per cercare di notare
modelli, o cose simili,

133
00:06:36,919 --> 00:06:38,960
per gli errori si potrebbe avere
incontrato in passato.

134
00:06:38,960 --> 00:06:41,335
Quindi cerchiamo di prendere in giro a parte solo
quelle parole che sembrano familiari.

135
00:06:41,335 --> 00:06:44,290
Il grande, rosso errore è chiaramente
simbolico di qualcosa che è sbagliato.

136
00:06:44,290 --> 00:06:47,940
>> implicitamente dichiarando
funzione printf biblioteca.

137
00:06:47,940 --> 00:06:51,680
Quindi, anche se non ho ben capito cosa
dichiarando implicitamente funzione di libreria

138
00:06:51,680 --> 00:06:54,900
mezzi, il problema sicuramente
si riferisce a printf in qualche modo.

139
00:06:54,900 --> 00:06:59,130
E la fonte di tale questione
ha a che fare con dichiararla.

140
00:06:59,130 --> 00:07:02,440
>> Dichiarare una funzione è
menzionare per la prima volta.

141
00:07:02,440 --> 00:07:06,210
E abbiamo usato la terminologia della scorsa settimana
di dichiarare il prototipo di una funzione,

142
00:07:06,210 --> 00:07:11,860
sia con una linea nella parte superiore del vostro
file o in un cosiddetto file di intestazione.

143
00:07:11,860 --> 00:07:15,300
E in che file di fatto che diciamo
la settimana scorsa che printf è citazione,

144
00:07:15,300 --> 00:07:17,080
unquote, ha dichiarato?

145
00:07:17,080 --> 00:07:20,950
In quale file è il suo prototipo?

146
00:07:20,950 --> 00:07:24,640
>> Quindi, se vi ricordate, la prima cosa che ho
digitato, quasi tutti i programmi scorso tempo--

147
00:07:24,640 --> 00:07:30,790
e accidentalmente un momento fa ha iniziato
digitando myself-- era questo uno qui--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- per
Ingresso / output-- punto h E in effetti,

149
00:07:38,630 --> 00:07:41,860
se ora salvare il file, sto andando
di andare avanti e cancellare il mio schermo,

150
00:07:41,860 --> 00:07:44,740
che si può fare digitando
Chiaro, o si può tenere il controllo L,

151
00:07:44,740 --> 00:07:47,680
solo per cancellare la finestra del terminale
solo per eliminare alcuni disordine.

152
00:07:47,680 --> 00:07:51,370
>> Ho intenzione di andare avanti e
re-make di tipo buggy0, Invio.

153
00:07:51,370 --> 00:07:53,790
E voilà, continuo a vedere che
lungo comando da Clang,

154
00:07:53,790 --> 00:07:55,470
ma non c'è alcun messaggio di errore questa volta.

155
00:07:55,470 --> 00:07:58,800
E in effetti, se lo faccio ./buggy0,
proprio come l'ultima volta,

156
00:07:58,800 --> 00:08:01,860
dove dot significa che questo
directory, Slash significa semplicemente,

157
00:08:01,860 --> 00:08:05,040
qui viene il nome del programma e
che il nome del programma è buggy0,

158
00:08:05,040 --> 00:08:07,340
Invio, "ciao, mondo".

159
00:08:07,340 --> 00:08:09,440
>> Ora, come si potrebbe avere
raccolte questa soluzione

160
00:08:09,440 --> 00:08:12,017
senza necessariamente
riconoscendo il maggior numero di parole

161
00:08:12,017 --> 00:08:14,350
come ho fatto io, certamente, avendo
fatto questo per tanti anni?

162
00:08:14,350 --> 00:08:18,720
Ebbene, realizzare per il primo problema
set, vi presentiamo a un comando

163
00:08:18,720 --> 00:08:21,175
che proprio personale di CS50
ha scritto chiamato help50.

164
00:08:21,175 --> 00:08:24,300
E in effetti, C fa specifica per
il problema impostato su come utilizzare questo.

165
00:08:24,300 --> 00:08:27,210
>> Ma help50 è essenzialmente
un programma che lo staff di CS50

166
00:08:27,210 --> 00:08:30,850
Lei ha scritto che permette di eseguire
un comando o eseguire un programma,

167
00:08:30,850 --> 00:08:36,169
e se non si capisce la sua
uscita, di passare la sua uscita help50,

168
00:08:36,169 --> 00:08:38,890
a questo punto il software
che il personale del corso ha scritto

169
00:08:38,890 --> 00:08:42,429
esaminerà uscita del vostro programma
riga per riga, carattere per carattere.

170
00:08:42,429 --> 00:08:46,000
E se noi, il personale, riconosce il
messaggio di errore che si sta sperimentando,

171
00:08:46,000 --> 00:08:50,580
cercheremo di provocare con un certo
domande retoriche, con qualche consiglio,

172
00:08:50,580 --> 00:08:54,890
molto simile a una TF o una CA o di me stesso
avrebbe fatto di persona presso l'orario di ufficio.

173
00:08:54,890 --> 00:08:58,320
>> Così guardare a help50 se non lo fai
necessariamente riconoscere un problema.

174
00:08:58,320 --> 00:09:00,790
Ma non si basano su di esso
troppo come una stampella.

175
00:09:00,790 --> 00:09:03,990
Sicuramente cercare di capire la sua
uscita e poi imparare da esso

176
00:09:03,990 --> 00:09:07,571
in modo che solo una o due volte si fa
mai eseguito help50 per un particolare errore

177
00:09:07,571 --> 00:09:08,070
messaggio.

178
00:09:08,070 --> 00:09:10,660
Dopo di che, si dovrebbe essere
meglio te stesso attrezzata

179
00:09:10,660 --> 00:09:13,180
per capire ciò che effettivamente è.

180
00:09:13,180 --> 00:09:14,350
>> Facciamo un altro qui.

181
00:09:14,350 --> 00:09:20,410
Lasciami andare avanti, e in un altro
file che chiameremo questo buggy1.c.

182
00:09:20,410 --> 00:09:23,110
E in questo file sono
andando a deliberately--

183
00:09:23,110 --> 00:09:26,330
ma finta che non lo faccio
Capisco quello che errore ho fatto.

184
00:09:26,330 --> 00:09:31,420
>> Ho intenzione di andare avanti e fare questo--
# include, dal momento che ho

185
00:09:31,420 --> 00:09:33,660
imparato la lezione da un momento fa.

186
00:09:33,660 --> 00:09:36,220
Int main (void), come prima.

187
00:09:36,220 --> 00:09:40,880
E poi qui ho intenzione
fare stringa s - get_string.

188
00:09:40,880 --> 00:09:43,770
E ricordare dall'ultima volta che
questo significa, hey, computer,

189
00:09:43,770 --> 00:09:48,280
datemi una variabile, chiamata s, e
rendere il tipo di quella variabile una stringa

190
00:09:48,280 --> 00:09:50,150
in modo da poter memorizzare una o più parole in esso.

191
00:09:50,150 --> 00:09:52,191
>> E poi sul destro
lato del segno uguale

192
00:09:52,191 --> 00:09:54,980
è get_string, che è un
funzione nella libreria CS50

193
00:09:54,980 --> 00:09:55,980
che fa esattamente questo.

194
00:09:55,980 --> 00:09:59,740
Si ottiene una funzione e poi
mani da destra verso sinistra.

195
00:09:59,740 --> 00:10:02,670
Quindi questo segno di uguale non significa
"Uguale", come si potrebbe pensare in matematica.

196
00:10:02,670 --> 00:10:04,750
Significa assegnazione da destra a sinistra.

197
00:10:04,750 --> 00:10:09,640
Quindi questo significa, prendere la stringa da
l'utente e memorizzare all'interno di s.

198
00:10:09,640 --> 00:10:10,460
>> Ora cerchiamo di usarlo.

199
00:10:10,460 --> 00:10:13,820
Lasciami andare avanti ora e come secondo
la linea, mi permetta di andare avanti e dire "ciao" -

200
00:10:13,820 --> 00:10:19,330
Non "mondo", ma "Ciao,% S--
che è il nostro segnaposto, comma s,

201
00:10:19,330 --> 00:10:22,030
che è la nostra variabile,
e poi una virgola.

202
00:10:22,030 --> 00:10:26,070
Quindi, se non mi vite troppo
qui, questo appare come codice corretto.

203
00:10:26,070 --> 00:10:28,090
>> E il mio istinto ora sono per compilarlo.

204
00:10:28,090 --> 00:10:30,400
Il file si chiama buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Quindi ho intenzione di fare fare buggy1, Invio.

206
00:10:33,770 --> 00:10:36,377
E darn-it, se non c'è
anche più errori rispetto a prima.

207
00:10:36,377 --> 00:10:38,210
Voglio dire, non c'è più
i messaggi di errore che sarebbe

208
00:10:38,210 --> 00:10:40,400
Sembra che le linee reali in questo programma.

209
00:10:40,400 --> 00:10:42,730
>> Ma l'asporto qui è,
anche se sei sopraffatto

210
00:10:42,730 --> 00:10:45,040
con due o tre o
quattro messaggi di errore di più,

211
00:10:45,040 --> 00:10:48,340
sempre concentrarsi sulla molto
prima di tali messaggi.

212
00:10:48,340 --> 00:10:52,220
Guardando il più in alto uno,
scorrere indietro come necessario.

213
00:10:52,220 --> 00:10:53,930
Così qui ho digitato make buggy1.

214
00:10:53,930 --> 00:10:55,700
Ecco che l'uscita Clang come previsto.

215
00:10:55,700 --> 00:10:57,290
>> Ed ecco il primo errore rosso.

216
00:10:57,290 --> 00:11:02,370
L'utilizzo di identificatore non dichiarato
stringa, ho dire standard?

217
00:11:02,370 --> 00:11:04,260
Quindi, in standard è
in realtà qualcos'altro.

218
00:11:04,260 --> 00:11:06,240
Si riferisce per l'utente del
tastiera, essenzialmente.

219
00:11:06,240 --> 00:11:08,080
>> Ma non è quello che volevo dire.

220
00:11:08,080 --> 00:11:11,770
Intendevo stringa, e volevo dire get_string.

221
00:11:11,770 --> 00:11:16,200
Allora che cosa è che io
dimenticato di fare questa volta?

222
00:11:16,200 --> 00:11:20,230
Ciò che manca questa volta?

223
00:11:20,230 --> 00:11:23,600
Ho il mio # include,
così ho accesso a printf.

224
00:11:23,600 --> 00:11:26,090
>> Ma che cosa non ho
l'accesso a appena ancora?

225
00:11:26,090 --> 00:11:29,420
Ebbene, proprio come l'ultima volta,
Ho bisogno di dire al compilatore

226
00:11:29,420 --> 00:11:31,691
Clang quali queste funzioni sono.

227
00:11:31,691 --> 00:11:33,940
Get_string non arriva
con C. E in particolare,

228
00:11:33,940 --> 00:11:38,160
non venire in
File di intestazione,.

229
00:11:38,160 --> 00:11:40,770
Si tratta invece di
qualcosa che il personale ha scritto,

230
00:11:40,770 --> 00:11:44,176
che è un file diverso
nome ma giustamente chiamato.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Così semplicemente aggiungendo che una riga
di richiamo code-- dall'ultima volta

233
00:11:50,861 --> 00:11:53,610
che quando Clang corre, sta andando
a guardare il mio superiore del codice a fondo,

234
00:11:53,610 --> 00:11:54,193
da sinistra a destra.

235
00:11:54,193 --> 00:11:57,200
Sta andando a notare,
Oh, vuoi.

236
00:11:57,200 --> 00:11:59,900
Lasciami andare e scoprire che,
dovunque sia sul server,

237
00:11:59,900 --> 00:12:03,090
copia e incolla, in sostanza,
nella parte superiore del tuo file

238
00:12:03,090 --> 00:12:06,820
in modo che a questo punto della storia,
linea 1, il resto del programma

239
00:12:06,820 --> 00:12:11,651
può, infatti, utilizzare una delle funzioni
in esso, tra i quali get_string.

240
00:12:11,651 --> 00:12:13,650
Quindi ho intenzione di ignorare
il resto di tali errori,

241
00:12:13,650 --> 00:12:17,190
perché, in effetti, il sospetto che solo
il primo in realtà importava.

242
00:12:17,190 --> 00:12:20,780
E ho intenzione di andare avanti e replica,
dopo aver salvato il mio file fare buggy1.

243
00:12:20,780 --> 00:12:22,580
E voilà, ha funzionato.

244
00:12:22,580 --> 00:12:29,200
E se lo faccio ./buggy1 e digitare, per
esempio, Zamyla, ora otterrà ciao,

245
00:12:29,200 --> 00:12:32,000
Zamyla, invece di ciao, mondo.

246
00:12:32,000 --> 00:12:32,550
>> Tutto ok.

247
00:12:32,550 --> 00:12:35,890
Così i take away qui poi sono,
uno, cercare di raccogliere quanto più possibile

248
00:12:35,890 --> 00:12:39,140
dai messaggi di errore solo, cerco
alcune delle parole riconoscibili.

249
00:12:39,140 --> 00:12:43,070
A parte ciò, usare help50 per
il problema set specifica.

250
00:12:43,070 --> 00:12:46,500
Ma il blocco delle chiamate che, anche, sempre guardare
Allo Errore unica, almeno

251
00:12:46,500 --> 00:12:50,051
inizialmente, per vedere quali informazioni
si potrebbe effettivamente cedere.

252
00:12:50,051 --> 00:12:52,300
Ma si scopre c'è
ancora più funzionalità built

253
00:12:52,300 --> 00:12:55,030
nella libreria CS50 per aiutare
si presto nel semestre

254
00:12:55,030 --> 00:12:57,580
e nelle prime fasi di programmazione
capire che cosa sta andando male.

255
00:12:57,580 --> 00:12:59,840
Allora, facciamo un altro esempio qui.

256
00:12:59,840 --> 00:13:04,350
Ho intenzione di chiamare questo buggy2, che,
ancora una volta, sta per essere viziata fuori

257
00:13:04,350 --> 00:13:05,650
della porta, alla progettazione.

258
00:13:05,650 --> 00:13:09,980
>> E ho intenzione di andare avanti
e fare #include.

259
00:13:09,980 --> 00:13:12,580
E poi ho intenzione di fare int main (void).

260
00:13:12,580 --> 00:13:14,840
E poi ho intenzione di fare un ciclo for.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i è minore o uguale a 10.

263
00:13:18,750 --> 00:13:24,260
i ++, e poi tra parentesi graffe, sto andando
per stampare solo un simbolo hashtag qui

264
00:13:24,260 --> 00:13:25,920
e un carattere di nuova riga.

265
00:13:25,920 --> 00:13:29,220
>> Quindi il mio intento con questo
il programma è semplicemente

266
00:13:29,220 --> 00:13:33,150
iterare 10 volte
e ad ogni iterazione

267
00:13:33,150 --> 00:13:35,260
di quel ciclo di volta in volta
attraverso il ciclo,

268
00:13:35,260 --> 00:13:37,660
stampare un hashtag,
un hashtag, un hashtag.

269
00:13:37,660 --> 00:13:40,480
Una linea per perché ho
avere la nuova linea di lì.

270
00:13:40,480 --> 00:13:42,787
E ricordare che il per
cappio, per ultima week--

271
00:13:42,787 --> 00:13:44,620
e si otterrà di più
familiarità con la sintassi

272
00:13:44,620 --> 00:13:47,170
usandolo con la pratica
prima long-- questo mi dà

273
00:13:47,170 --> 00:13:49,740
una variabile ho chiamato e lo imposta a 0.

274
00:13:49,740 --> 00:13:52,650
>> Questo incrementa i su
ogni iterazione di 1.

275
00:13:52,650 --> 00:13:54,940
Così ho passa a 1 a 2 a 3.

276
00:13:54,940 --> 00:13:57,690
E poi questa condizione nel
di mezzo tra i punti e virgola

277
00:13:57,690 --> 00:14:03,010
viene controllato su ogni iterazione per fare
Assicurarsi che siamo ancora nel raggio d'azione.

278
00:14:03,010 --> 00:14:06,830
Quindi voglio iterare 10 volte, così ho
avere una sorta di molto intuitivamente solo

279
00:14:06,830 --> 00:14:09,070
mettere 10 come il mio limite superiore lì.

280
00:14:09,070 --> 00:14:14,310
>> Eppure, quando ho eseguito questo, dopo
compilarlo con make buggy2--

281
00:14:14,310 --> 00:14:15,440
e lo fa compilare OK.

282
00:14:15,440 --> 00:14:17,980
Quindi non ho un
Errore di sintassi questa volta.

283
00:14:17,980 --> 00:14:20,940
Lasciami andare avanti ora
ed eseguire buggy2, Invio.

284
00:14:20,940 --> 00:14:22,620
E ora scorrere verso l'alto.

285
00:14:22,620 --> 00:14:24,890
E mi permetta di aumentare
la dimensione della finestra.

286
00:14:24,890 --> 00:14:33,720
>> Mi sembra di avere 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Quindi c'è 11 hashtag, anche se
Ho chiaramente messo 10 all'interno di questo ciclo.

288
00:14:38,891 --> 00:14:42,140
Ora, alcuni di voi potrebbero vedere subito
ciò l'errore è perché, in effetti, questo

289
00:14:42,140 --> 00:14:43,720
Non è un errore molto difficile fare.

290
00:14:43,720 --> 00:14:46,070
Ma è molto comunemente
fatto molto presto.

291
00:14:46,070 --> 00:14:49,820
>> Quello che voglio sottolineare, però,
è, come potrei capirlo?

292
00:14:49,820 --> 00:14:52,300
Beh, si scopre che
la Biblioteca CS50 viene

293
00:14:52,300 --> 00:14:55,380
non solo get_string e get_int
e get_float e altre funzioni.

294
00:14:55,380 --> 00:14:59,980
Inoltre è dotato di una funzione speciale
chiamato eprintf, o, errore printf.

295
00:14:59,980 --> 00:15:03,270
Ed esiste solamente per fare
è un po 'più facile per voi

296
00:15:03,270 --> 00:15:06,310
quando il debug del codice a poco
stampare un messaggio di errore sullo schermo

297
00:15:06,310 --> 00:15:07,850
e sapere da dove proviene.

298
00:15:07,850 --> 00:15:11,000
>> Così, per esempio, una cosa che potrebbe
fare qui con questa funzione è questo--

299
00:15:11,000 --> 00:15:20,230
eprintf, e poi ho intenzione di andare avanti
e dire che è ora% i, backslash, n.

300
00:15:20,230 --> 00:15:22,330
E ho intenzione di collegare il valore di i.

301
00:15:22,330 --> 00:15:25,400
E fino in alto, perché questo
è nella Biblioteca CS50,

302
00:15:25,400 --> 00:15:27,580
Ho intenzione di andare avanti
e comprendono

303
00:15:27,580 --> 00:15:29,169
così ho accesso a questa funzione.

304
00:15:29,169 --> 00:15:31,460
Ma prendiamo in considerazione quale linea
9 si suppone di fare.

305
00:15:31,460 --> 00:15:32,670
Ho intenzione di cancellare questo fine.

306
00:15:32,670 --> 00:15:34,670
Questo non ha nulla a che fare
con il mio obiettivo primario.

307
00:15:34,670 --> 00:15:39,090
Ma eprintf, errore printf, è solo significato
darmi qualche informazioni diagnostiche.

308
00:15:39,090 --> 00:15:42,460
Quando eseguo il mio programma, voglio
vedere questo sullo schermo temporanea

309
00:15:42,460 --> 00:15:44,550
anche solo per capire
cosa sta succedendo.

310
00:15:44,550 --> 00:15:47,330
>> E, in effetti, su ciascun
iterazione qui di linea 9

311
00:15:47,330 --> 00:15:49,260
Voglio vedere, qual è il valore di i?

312
00:15:49,260 --> 00:15:50,290
Qual è il valore di i?

313
00:15:50,290 --> 00:15:51,280
Qual è il valore di i?

314
00:15:51,280 --> 00:15:55,650
E, si spera, ho solo dovrebbe
vedere che il messaggio, anche, 10 volte.

315
00:15:55,650 --> 00:15:57,780
>> Quindi, mi permetta di andare avanti e
ricompilare il mio programma,

316
00:15:57,780 --> 00:15:59,905
come devo fare in qualsiasi momento
Faccio un cambiamento. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
E now-- OK.

319
00:16:03,640 --> 00:16:04,820
C'è molto di più in corso.

320
00:16:04,820 --> 00:16:07,610
Così mi permetta di scorrere verso l'alto in
una finestra di ancora più grande.

321
00:16:07,610 --> 00:16:10,190
>> E vedrete che ognuno di
l'hashtag sta ancora stampando.

322
00:16:10,190 --> 00:16:15,270
Ma tra ciascuno di essi è ora questo
uscita diagnostica formattato come segue.

323
00:16:15,270 --> 00:16:17,960
Il nome del mio programma qui è buggy2.

324
00:16:17,960 --> 00:16:20,432
Il nome del file è buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Il numero di riga da cui
Questa è stata stampata è la linea 9.

326
00:16:24,080 --> 00:16:27,500
E poi a destra che è il
messaggio di errore che mi aspetto.

327
00:16:27,500 --> 00:16:30,701
>> E ciò che è bello di questo è che
ora non ho contare necessariamente

328
00:16:30,701 --> 00:16:32,200
nella mia testa quello che il mio programma sta facendo.

329
00:16:32,200 --> 00:16:34,240
Posso vedere che sulla
prima iterazione i è 0,

330
00:16:34,240 --> 00:16:39,420
poi 1, poi 2, poi 3, poi 4, poi
5, poi 6, poi 7, poi 8, poi 9, poi

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Quindi, aspetta un minuto.

333
00:16:42,050 --> 00:16:43,740
Cosa sta succedendo qui?

334
00:16:43,740 --> 00:16:48,190
Ho ancora sembra di contare
come previsto fino a 10.

335
00:16:48,190 --> 00:16:50,550
>> Ma da dove comincio?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Così 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- il dito 11

338
00:16:58,040 --> 00:16:59,990
è indicativo del problema.

339
00:16:59,990 --> 00:17:02,850
Mi sembra di aver contato
in modo non corretto nel mio ciclo.

340
00:17:02,850 --> 00:17:06,599
Piuttosto che andare 10 iterazioni,
Sto iniziando a 0,

341
00:17:06,599 --> 00:17:09,550
Sto finendo in e attraverso 10.

342
00:17:09,550 --> 00:17:12,030
Ma poiché, come un computer,
Sto iniziando il conteggio a 0,

343
00:17:12,030 --> 00:17:15,250
Dovrei essere conteggio
, ma non attraverso, 10.

344
00:17:15,250 --> 00:17:18,510
>> E così la correzione, alla fine ho
realizzato qui, è una delle due cose.

345
00:17:18,510 --> 00:17:22,430
Potrei semplicemente dire molto
contare fino a meno di 10.

346
00:17:22,430 --> 00:17:27,260
Così 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, che è, in effetti, corretto,

347
00:17:27,260 --> 00:17:28,900
anche se suona un po 'sbagliato.

348
00:17:28,900 --> 00:17:35,070
Oppure avrei potuto fare inferiore o uguale
a 9, fino a quando mi metto a 0.

349
00:17:35,070 --> 00:17:40,056
Oppure, se proprio non ti piace questo,
può contare fino a 10, ma iniziare a 1.

350
00:17:40,056 --> 00:17:41,680
Ma ancora una volta, questo proprio non è così comune.

351
00:17:41,680 --> 00:17:43,977
In programming-- seppur
non tanto in Scratch--

352
00:17:43,977 --> 00:17:45,810
ma in programmazione
C e altre lingue,

353
00:17:45,810 --> 00:17:47,670
come JavaScript e
Python e altri, è

354
00:17:47,670 --> 00:17:49,880
solo molto comune per
la nostra discussione di binario

355
00:17:49,880 --> 00:17:53,450
per iniziare a contare solo al
più basso il numero si può, che è 0.

356
00:17:53,450 --> 00:17:53,950
Tutto ok.

357
00:17:53,950 --> 00:17:55,160
Ecco, questo è eprintf.

358
00:17:55,160 --> 00:17:58,600
E di nuovo, ora che ho capito il mio
problema, e ho intenzione di tornare a 0

359
00:17:58,600 --> 00:18:01,470
attraverso inferiore a 10, io vado
di andare in ed eliminare eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Non dovrebbe essere lì quando ho
spedire il mio codice o presentare il mio codice

361
00:18:04,580 --> 00:18:05,800
o mostrare a chiunque altro.

362
00:18:05,800 --> 00:18:07,980
E 'davvero solo significava
essere utilizzate temporaneamente.

363
00:18:07,980 --> 00:18:11,650
Ma ora ho riparato questo
particolare problema pure.

364
00:18:11,650 --> 00:18:16,780
>> Bene, facciamo un altro esempio qui
che ho intenzione di montare come segue.

365
00:18:16,780 --> 00:18:22,850
Ho intenzione di andare avanti e
#includere . $ 50

366
00:18:22,850 --> 00:18:25,580
E ho intenzione di andare avanti
e # include.

367
00:18:25,580 --> 00:18:29,030
>> E ho intenzione di salvare
questo file come buggy3.c.

368
00:18:29,030 --> 00:18:31,740
E ho intenzione di andare avanti
e dichiarare int main (void).

369
00:18:31,740 --> 00:18:34,186
E poi dentro di lì
Ho intenzione di fare int i _ -

370
00:18:34,186 --> 00:18:36,435
Voglio realizzare un programma
con un get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Questa non è una funzione che esiste ancora.

373
00:18:40,770 --> 00:18:42,870
Quindi stiamo andando a implementare
in un attimo.

374
00:18:42,870 --> 00:18:45,541
Ma andiamo a vedere perché
è buggy primo passaggio.

375
00:18:45,541 --> 00:18:47,290
E una volta ho ottenuto
un int da parte dell'utente,

376
00:18:47,290 --> 00:18:53,365
Sto solo andando a stampare% i è negativo
intero, backslash, n, virgola, i.

377
00:18:53,365 --> 00:18:55,240
In altre parole, tutto ciò che
desidera che questo programma per fare

378
00:18:55,240 --> 00:18:58,000
è ottenere un int negativo da
l'utente e poi stampare

379
00:18:58,000 --> 00:18:59,980
che così e così è un int negativo.

380
00:18:59,980 --> 00:19:02,080
>> Ora ho bisogno di implementare questa funzione.

381
00:19:02,080 --> 00:19:05,740
Così più tardi nel mio file, ho intenzione di andare
avanti e dichiarare una funzione chiamata

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - e faremo
tornare a ciò che quella linea vuol dire ancora una volta

383
00:19:10,670 --> 00:19:18,790
in un moment-- int n; fare-- Do
il following-- printf n è :.

384
00:19:18,790 --> 00:19:26,210
E poi ho intenzione di fare n - get_int,
e fare questo, mentre n è maggiore di 0.

385
00:19:26,210 --> 00:19:28,310
E poi tornare n ;.

386
00:19:28,310 --> 00:19:31,730
>> Quindi c'è un sacco di cose in
questo, ma nessuno dei quali non abbiamo fatto

387
00:19:31,730 --> 00:19:33,710
guarda la scorsa settimana, almeno brevemente.

388
00:19:33,710 --> 00:19:36,980
Quindi, sulla linea 10 che ho qui dichiarata
funzione chiamata get_negative_int,

389
00:19:36,980 --> 00:19:39,620
e ho messo (void), in
parentesi, il motivo è questo

390
00:19:39,620 --> 00:19:40,950
non prende un input.

391
00:19:40,950 --> 00:19:42,910
Io non sto passando nulla
a questa funzione.

392
00:19:42,910 --> 00:19:44,690
Sto solo ottenere qualcosa di nuovo da esso.

393
00:19:44,690 --> 00:19:47,270
>> E quello che sto sperando di
tornare è un numero intero.

394
00:19:47,270 --> 00:19:50,040
Non vi è alcun tipo di dati in
C chiamato negative_int.

395
00:19:50,040 --> 00:19:52,880
E 'solo int, quindi sta andando
essere a noi per assicurarsi

396
00:19:52,880 --> 00:19:55,340
che il valore che in realtà
restituito è non solo un int

397
00:19:55,340 --> 00:19:56,380
ma è anche negativo.

398
00:19:56,380 --> 00:20:02,150
>> Sulla linea 12 Sto dichiarazione di una variabile
chiamato n e rendendolo di tipo int.

399
00:20:02,150 --> 00:20:07,500
E poi, in linea da 13 a 18 Sono
fare qualcosa mentre qualcosa è vero.

400
00:20:07,500 --> 00:20:11,040
Io vado avanti e la stampa
n è, colon, e quindi uno spazio,

401
00:20:11,040 --> 00:20:12,800
come una richiesta per l'utente.

402
00:20:12,800 --> 00:20:16,410
>> Sto quindi chiamando get_int e
memorizzandone il cosiddetto valore di ritorno

403
00:20:16,410 --> 00:20:18,130
in quella variabile n.

404
00:20:18,130 --> 00:20:22,600
Ma ho intenzione di continuare a fare
questo mentre n è maggiore di 0.

405
00:20:22,600 --> 00:20:27,960
In altre parole, se l'utente mi dà un
int e che il numero è maggiore di 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positivo, ho intenzione di
basta tenere reprompting l'utente,

407
00:20:31,180 --> 00:20:37,160
mantenere reprompting, costringendoli a
collaborare e darmi un int negativo.

408
00:20:37,160 --> 00:20:41,640
>> E una volta che è in realtà n negative--
Supponiamo che l'utente infine tipi -50,

409
00:20:41,640 --> 00:20:46,710
allora questo ciclo while non è più vero
perché -50 non è maggiore di 0.

410
00:20:46,710 --> 00:20:51,140
Così noi spezziamo fuori da quella
ciclo logicamente e tornare n.

411
00:20:51,140 --> 00:20:53,520
>> Ma c'è un altro
cosa devo fare.

412
00:20:53,520 --> 00:20:56,190
E posso semplicemente fare questo
dalla copia e incolla

413
00:20:56,190 --> 00:20:58,540
una riga di codice nella parte superiore del file.

414
00:20:58,540 --> 00:21:01,630
Ho bisogno di insegnare Clang,
o promettere di clang,

415
00:21:01,630 --> 00:21:04,630
esplicitamente che io voglio,
anzi, andare a implementare

416
00:21:04,630 --> 00:21:06,020
questa funzione get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Si potrebbe semplicemente essere inferiore nel file.

418
00:21:07,674 --> 00:21:09,840
Ancora una volta, ricordare che Clang
legge le cose dall'alto verso il basso,

419
00:21:09,840 --> 00:21:12,330
da sinistra a destra, quindi non è possibile
chiamare una funzione se Clang

420
00:21:12,330 --> 00:21:15,330
non sa che sta andando a esistere.

421
00:21:15,330 --> 00:21:18,430
>> Ora, purtroppo, questo programma,
Come alcuni di voi avranno notato,

422
00:21:18,430 --> 00:21:19,590
è già buggy.

423
00:21:19,590 --> 00:21:21,400
Mi permetta di andare avanti e fare buggy3.

424
00:21:21,400 --> 00:21:26,904
Compila, quindi il mio problema ora non è
un errore di sintassi, come un errore di testo,

425
00:21:26,904 --> 00:21:29,570
è in realtà sta per essere una logica
errore che ho volutamente

426
00:21:29,570 --> 00:21:32,450
fatto come un'opportunità per
passo attraverso quello che sta succedendo.

427
00:21:32,450 --> 00:21:35,540
>> Ho intenzione di andare avanti
ora ed eseguire buggy3.

428
00:21:35,540 --> 00:21:37,490
E ho intenzione di andare
avanti e non cooperare.

429
00:21:37,490 --> 00:21:39,494
Ho intenzione di dare il numero 1.

430
00:21:39,494 --> 00:21:41,410
Esso non piaceva, così
mi sta spingendo di nuovo.

431
00:21:41,410 --> 00:21:42,147
>> Come circa 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Nessuno di coloro che stanno lavorando.

435
00:21:44,740 --> 00:21:46,890
Come circa -50?

436
00:21:46,890 --> 00:21:48,560
E il programma sembra funzionare.

437
00:21:48,560 --> 00:21:49,970
>> Fammi provare ancora una volta.

438
00:21:49,970 --> 00:21:53,400
Fammi provare -1, sembra funzionare.

439
00:21:53,400 --> 00:21:56,380
Fammi provare -2, sembra funzionare.

440
00:21:56,380 --> 00:21:59,640
Fammi provare 0.

441
00:21:59,640 --> 00:22:01,684
Eh, questo è corretto.

442
00:22:01,684 --> 00:22:03,350
Ora, ci stanno un po 'pedanti qui.

443
00:22:03,350 --> 00:22:07,090
Ma è, infatti, il caso che 0
non è né positivo, né negativo.

444
00:22:07,090 --> 00:22:11,150
E così il fatto che il mio programma è
dicendo che 0 è un numero intero negativo,

445
00:22:11,150 --> 00:22:12,820
questo non è tecnicamente corretto.

446
00:22:12,820 --> 00:22:15,180
>> Ora, perché sta facendo questo?

447
00:22:15,180 --> 00:22:16,270
Ebbene, potrebbe essere evidente.

448
00:22:16,270 --> 00:22:18,110
E, in effetti, il programma è
vuole essere abbastanza semplice

449
00:22:18,110 --> 00:22:19,670
così abbiamo qualcosa da esplorare.

450
00:22:19,670 --> 00:22:25,870
>> Ma cerchiamo di introdurre una terza debug
tecnica qui chiamato debug50.

451
00:22:25,870 --> 00:22:27,750
Quindi, questo è un programma
che abbiamo appena creato

452
00:22:27,750 --> 00:22:30,770
quest'anno chiamato debug50
che vi permetterà di

453
00:22:30,770 --> 00:22:34,130
di utilizzare ciò che è chiamato un built-in
debugger grafico in CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
E un debugger è solo un programma che
generalmente consente di eseguire il programma

455
00:22:38,400 --> 00:22:44,050
ma passo dopo passo per passo, la linea
dalla riga per riga, pausa, frugando

456
00:22:44,050 --> 00:22:47,626
intorno, guardando variabili in modo che
il programma non si limita a soffiare oltre voi

457
00:22:47,626 --> 00:22:49,750
e rapidamente stampare qualcosa
o no stampare qualcosa.

458
00:22:49,750 --> 00:22:53,250
Ti dà l'opportunità, a
velocità umana, di interagire con esso.

459
00:22:53,250 --> 00:22:55,470
>> E per fare questo,
semplicemente effettuare le seguenti operazioni.

460
00:22:55,470 --> 00:22:58,479
Dopo aver compilato il codice,
che ho già fatto, buggy3,

461
00:22:58,479 --> 00:23:00,020
di andare avanti e di eseguire debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Tanto come help50 ha si esegue
help50 e poi il comando,

464
00:23:06,760 --> 00:23:10,120
debug50 ha si esegue debug50 e
quindi il nome del comando.

465
00:23:10,120 --> 00:23:14,440
>> Ora guarda cosa succede sul mio schermo,
sul lato destro in particolare.

466
00:23:14,440 --> 00:23:19,400
Quando mi ha colpito Esegui, tutte le
Pannello improvvisa questa destra

467
00:23:19,400 --> 00:23:20,419
apre sullo schermo.

468
00:23:20,419 --> 00:23:22,210
E ci sono un sacco di cose
su a prima vista.

469
00:23:22,210 --> 00:23:25,110
Ma non c'è troppo
molto di cui preoccuparsi ancora.

470
00:23:25,110 --> 00:23:28,570
>> Questo mi sta mostrando tutto
che sta succedendo all'interno del mio programma

471
00:23:28,570 --> 00:23:31,130
in questo momento e tramite questi
pulsanti sulla parte superiore è poi

472
00:23:31,130 --> 00:23:35,910
mi permette di scorrere il mio codice
in ultima analisi, passo dopo passo per passo.

473
00:23:35,910 --> 00:23:37,140
Ma non ancora.

474
00:23:37,140 --> 00:23:38,060
Si noti che cosa accade.

475
00:23:38,060 --> 00:23:40,600
Alla mia finestra di terminale
Mi viene richiamato per n.

476
00:23:40,600 --> 00:23:44,560
E ho intenzione di andare avanti e
cooperare questa volta e digitare -1.

477
00:23:44,560 --> 00:23:48,770
E anche se un po 'criptico, -1
è un numero intero negativo, come previsto.

478
00:23:48,770 --> 00:23:52,020
>> E poi è uscito con bambino
stato 0 gdbserver uscire.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, è il nome
del software sottostante

480
00:23:55,180 --> 00:23:56,620
che implementa questa debugger.

481
00:23:56,620 --> 00:24:00,500
Ma tutto questo significa veramente, il debugger
è andato via perché il mio programma di smettere

482
00:24:00,500 --> 00:24:01,710
e tutto andava bene.

483
00:24:01,710 --> 00:24:06,020
Se voglio eseguire il debug veramente il mio programma,
Devo dire preventivamente debug50,

484
00:24:06,020 --> 00:24:08,920
dove voglio cominciare
passando attraverso il mio codice?

485
00:24:08,920 --> 00:24:11,750
>> E forse il modo più semplice
per farlo è come segue.

486
00:24:11,750 --> 00:24:15,300
Se mi passa il mouse sopra il
grondaia del mio editore qui,

487
00:24:15,300 --> 00:24:19,090
così in realtà solo nella barra laterale qui,
a fianco del numero di linea,

488
00:24:19,090 --> 00:24:21,870
Si noti che se ho appena clic
una volta, ho messo un po 'punto rosso.

489
00:24:21,870 --> 00:24:24,460
E quel piccolo puntino rosso,
come un segnale di stop, significa, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, l'esecuzione di pausa del mio codice
proprio lì quando ho eseguito questo programma.

491
00:24:29,430 --> 00:24:30,260
>> Quindi cerchiamo di farlo.

492
00:24:30,260 --> 00:24:37,340
Lasciami andare avanti e correre il mio programma
di nuovo con debug50 ./buggy3, Invio.

493
00:24:37,340 --> 00:24:40,110
E ora, avviso, qualcosa
diverso è accaduto.

494
00:24:40,110 --> 00:24:42,440
Non sto venga richiesto
eppure nella mia finestra del terminale

495
00:24:42,440 --> 00:24:45,430
per qualsiasi cosa, perché non ho
ottenuto ancora arrivati ​​nel mio programma.

496
00:24:45,430 --> 00:24:47,950
Si noti che sulla linea 8
che ora è messo in evidenza,

497
00:24:47,950 --> 00:24:51,720
e c'è una piccola freccia a
dice di sinistra, si fermò qui.

498
00:24:51,720 --> 00:24:55,030
Questa linea di codice, riga
8, non ha ancora eseguita.

499
00:24:55,030 --> 00:24:58,940
>> E cosa c'è di curioso, se guardo
qui sul lato destro,

500
00:24:58,940 --> 00:25:03,530
Noto che i è un locale
variabile locale nel senso

501
00:25:03,530 --> 00:25:05,450
che è all'interno della funzione corrente.

502
00:25:05,450 --> 00:25:08,920
E il suo valore, a quanto pare per impostazione predefinita,
e una sorta di comoda, è 0.

503
00:25:08,920 --> 00:25:10,260
Ma non ho digitare 0.

504
00:25:10,260 --> 00:25:13,410
Ciò avviene solo per essere la sua
valore predefinito al momento.

505
00:25:13,410 --> 00:25:15,490
>> Quindi, mi permetta di andare avanti e farlo ora.

506
00:25:15,490 --> 00:25:18,680
Lasciami andare avanti e su
in alto a destra qui, sono

507
00:25:18,680 --> 00:25:20,970
intenzione di andare avanti e
fare clic su questo prima icona che

508
00:25:20,970 --> 00:25:25,360
significa scavalcare il che significa che non saltare
ma scavalcare questa riga di codice,

509
00:25:25,360 --> 00:25:27,770
esecuzione lungo la strada.

510
00:25:27,770 --> 00:25:30,710
>> E ora, si noti, la mia
prompt è appena cambiato.

511
00:25:30,710 --> 00:25:31,380
Perché?

512
00:25:31,380 --> 00:25:33,639
Ho detto debug50,
eseguire questa riga di codice.

513
00:25:33,639 --> 00:25:34,930
Che cosa significa questa riga di codice fare?

514
00:25:34,930 --> 00:25:35,960
mi spinge per un int.

515
00:25:35,960 --> 00:25:36,460
OK.

516
00:25:36,460 --> 00:25:37,400
Mi permetta di collaborare.

517
00:25:37,400 --> 00:25:41,340
Lasciami andare avanti ora e digitare -1, Enter.

518
00:25:41,340 --> 00:25:42,920
E ora notare che cosa è cambiato.

519
00:25:42,920 --> 00:25:46,060
Sul lato destro,
la mia variabile locale i

520
00:25:46,060 --> 00:25:48,200
viene indicato come -1 ora.

521
00:25:48,200 --> 00:25:49,810
Ed è ancora di tipo int.

522
00:25:49,810 --> 00:25:53,102
>> E notate, anche, il mio cosiddetto
chiamare pila, dove ho una pausa?

523
00:25:53,102 --> 00:25:54,810
Parleremo di più
questo in futuro.

524
00:25:54,810 --> 00:25:58,620
Ma lo stack di chiamate si riferisce solo a ciò che
funzioni sono attualmente in movimento.

525
00:25:58,620 --> 00:26:00,040
In questo momento è solo principale.

526
00:26:00,040 --> 00:26:03,590
E in questo momento l'unico locale
variabile è i con un valore 1.

527
00:26:03,590 --> 00:26:09,840
>> E quando finalmente un passo su questa linea
qui, con quella stessa icona in alto a destra,

528
00:26:09,840 --> 00:26:11,410
-1 È un numero intero negativo.

529
00:26:11,410 --> 00:26:13,580
Ora è in pausa su quella parentesi graffa.

530
00:26:13,580 --> 00:26:14,740
Lasciamo fare la sua cosa.

531
00:26:14,740 --> 00:26:17,300
Faccio un passo su quella linea, e voilà.

532
00:26:17,300 --> 00:26:20,240
>> Quindi, non tutto ciò che terribilmente
illuminante ancora,

533
00:26:20,240 --> 00:26:23,550
ma mi ha lasciato una pausa
e pensare attraverso logicamente

534
00:26:23,550 --> 00:26:24,870
quello che questo programma sta facendo.

535
00:26:24,870 --> 00:26:26,890
Ma non era il caso erronea.

536
00:26:26,890 --> 00:26:28,510
Facciamo di nuovo come segue.

537
00:26:28,510 --> 00:26:31,340
>> Ho intenzione di lasciare quel punto di interruzione
sulla linea 8 con il puntino rosso.

538
00:26:31,340 --> 00:26:32,830
Ho intenzione di eseguire nuovamente debug50.

539
00:26:32,830 --> 00:26:34,400
E 'in pausa automaticamente qui.

540
00:26:34,400 --> 00:26:37,660
Ma questa volta, invece di
scavalcando questa linea,

541
00:26:37,660 --> 00:26:42,290
mi permetta effettivamente andare all'interno di
get_negative_int e capire,

542
00:26:42,290 --> 00:26:45,530
perché è accettare 0 come una risposta valida?

543
00:26:45,530 --> 00:26:47,990
>> Così, invece di cliccare Step Over.

544
00:26:47,990 --> 00:26:50,630
Ho intenzione di andare avanti
e fare clic su Esegui istruzione.

545
00:26:50,630 --> 00:26:54,030
E si noti che la linea 8 che è
ora evidenziata ora improvvisamente

546
00:26:54,030 --> 00:26:56,900
diventa la linea 17.

547
00:26:56,900 --> 00:26:59,947
>> Ora, non è che il debugger
ha saltato le linee 14 e 15 e 16.

548
00:26:59,947 --> 00:27:01,780
E 'solo non c'è niente
visualizzare lì.

549
00:27:01,780 --> 00:27:04,050
Questi sono solo dichiarare le variabili,
E poi c'è la parola fare

550
00:27:04,050 --> 00:27:05,390
e poi una parentesi graffa aperta.

551
00:27:05,390 --> 00:27:09,227
L'unica linea funzionale che è
succosa è proprio questo uno qui, 17.

552
00:27:09,227 --> 00:27:11,060
Ed è qui che abbiamo
in pausa automaticamente.

553
00:27:11,060 --> 00:27:13,870
>> Così printf ( "n.is:") ;, così
che non è ancora successo.

554
00:27:13,870 --> 00:27:18,250
Quindi cerchiamo di andare avanti e fare clic su Step Over.

555
00:27:18,250 --> 00:27:20,326
Ora la mia pronta, infatti,
cambiato ( "n è:").

556
00:27:20,326 --> 00:27:22,450
Ora get_int, non sto andando
preoccuparsi entrare in,

557
00:27:22,450 --> 00:27:24,750
perché quella funzione era
fatta dal CS50 nella libreria.

558
00:27:24,750 --> 00:27:25,750
E 'probabilmente corretto.

559
00:27:25,750 --> 00:27:28,440
>> Quindi ho intenzione di andare avanti e
sorta di collaborare dandogli

560
00:27:28,440 --> 00:27:30,590
un int, ma non un int negativo.

561
00:27:30,590 --> 00:27:32,870
Quindi, mi permetta di andare avanti e ha colpito 0.

562
00:27:32,870 --> 00:27:39,460
E adesso cosa succede qui
quando torno giù per la linea 21?

563
00:27:39,460 --> 00:27:40,890
Non ho iterate di nuovo.

564
00:27:40,890 --> 00:27:43,320
Non mi sembra di essere bloccato in quel ciclo.

565
00:27:43,320 --> 00:27:45,990
In altre parole, questo giallo
bar non ha mantenuto andare in giro,

566
00:27:45,990 --> 00:27:47,130
e intorno, e dintorni.

567
00:27:47,130 --> 00:27:48,340
>> Ora, perché?

568
00:27:48,340 --> 00:27:49,920
Ebbene, n, ciò che è n questo momento?

569
00:27:49,920 --> 00:27:53,280
Posso guardare il locale
variabili nel debugger.

570
00:27:53,280 --> 00:27:53,816
n è 0.

571
00:27:53,816 --> 00:27:55,190
Va bene, qual era la mia condizione?

572
00:27:55,190 --> 00:27:58,700
>> 20-- linea 20 è, beh,
0 è maggiore di 0.

573
00:27:58,700 --> 00:27:59,500
Quello non è vero.

574
00:27:59,500 --> 00:28:01,020
0 non è maggiore di 0.

575
00:28:01,020 --> 00:28:02,820
E così ho rotto fuori da questo.

576
00:28:02,820 --> 00:28:06,370
>> Ed ecco perché on line
21, se io in realtà continuo,

577
00:28:06,370 --> 00:28:10,370
Ho intenzione di restituire 0, anche
anche se avrebbe dovuto respingere 0

578
00:28:10,370 --> 00:28:12,484
come in realtà non essere negativo.

579
00:28:12,484 --> 00:28:14,650
Così ora, non lo faccio davvero anche
preoccupano il debugger.

580
00:28:14,650 --> 00:28:16,900
Capito, non ho bisogno di
sapere che cosa altro sta succedendo.

581
00:28:16,900 --> 00:28:19,233
>> Quindi ho intenzione di andare avanti e
è sufficiente fare clic sul pulsante Play,

582
00:28:19,233 --> 00:28:20,240
e lasciare che questa finitura in su.

583
00:28:20,240 --> 00:28:23,440
Ora, mi sono reso conto che il mio
bug è apparentemente sulla linea 20.

584
00:28:23,440 --> 00:28:25,160
Questo è il mio errore logico.

585
00:28:25,160 --> 00:28:28,100
>> E così quello che voglio
fare per cambiare questo?

586
00:28:28,100 --> 00:28:32,500
Se il problema è che io non sono
cattura 0, è solo un errore logico.

587
00:28:32,500 --> 00:28:35,910
E posso dire, mentre n è
maggiore o uguale a 0,

588
00:28:35,910 --> 00:28:38,330
mantenere spingendo ancora e ancora l'utente.

589
00:28:38,330 --> 00:28:41,050
>> Così, ancora una volta, semplice errore, forse
anche evidente quando mi hai visto

590
00:28:41,050 --> 00:28:42,410
scriverlo solo pochi minuti fa.

591
00:28:42,410 --> 00:28:44,570
Ma l'asporto qui
è che con il debug 50,

592
00:28:44,570 --> 00:28:46,850
e con il debug
software più in generale,

593
00:28:46,850 --> 00:28:51,370
si dispone di questo nuovo potere trovato a
camminare attraverso il proprio codice, guarda

594
00:28:51,370 --> 00:28:55,590
attraverso tale pannello di destra che cosa
i valori variabili sono.

595
00:28:55,590 --> 00:28:57,700
Quindi non si fa necessariamente
è necessario utilizzare qualcosa

596
00:28:57,700 --> 00:29:00,630
come si eprintf stampare quei valori.

597
00:29:00,630 --> 00:29:04,430
Si può effettivamente vederli
visivamente sullo schermo.

598
00:29:04,430 --> 00:29:08,920
>> Ora, al di là di questo, vale la pena notare
che c'è un'altra tecnica che è

599
00:29:08,920 --> 00:29:09,890
in realtà super-comune.

600
00:29:09,890 --> 00:29:13,120
E si potrebbe chiedere perché questo piccolo
ragazzo qui è stato seduto sul palco.

601
00:29:13,120 --> 00:29:16,490
Quindi c'è questa tecnica, in genere
conosciuto come il debug papera di gomma,

602
00:29:16,490 --> 00:29:18,786
che è in realtà solo un
testimonianza del fatto

603
00:29:18,786 --> 00:29:20,660
che i programmatori spesso quando
sono la scrittura di codice,

604
00:29:20,660 --> 00:29:22,650
non sono necessariamente
collaborare con gli altri,

605
00:29:22,650 --> 00:29:24,030
o lavorare in un ambiente condiviso.

606
00:29:24,030 --> 00:29:25,050
>> Sono un po 'a casa.

607
00:29:25,050 --> 00:29:25,910
Forse è a tarda notte.

608
00:29:25,910 --> 00:29:28,190
Stanno cercando di capire
alcuni bug nel loro codice.

609
00:29:28,190 --> 00:29:29,330
E stanno semplicemente non vederlo.

610
00:29:29,330 --> 00:29:30,329
>> E non c'è compagno di stanza.

611
00:29:30,329 --> 00:29:31,250
Non c'è TF.

612
00:29:31,250 --> 00:29:32,680
Non c'è CA intorno.

613
00:29:32,680 --> 00:29:36,440
Tutto quello che hanno sulla propria piattaforma
è questo piccolo paperella di gomma.

614
00:29:36,440 --> 00:29:39,030
>> E così il debug papera di gomma
è proprio questo invito

615
00:29:39,030 --> 00:29:42,780
a pensare a qualcosa di così stupido
come questo come una creatura reale,

616
00:29:42,780 --> 00:29:46,940
e in realtà camminare attraverso il codice
verbalmente a questo oggetto inanimato.

617
00:29:46,940 --> 00:29:49,230
Così, per esempio, se
questo è il mio esempio qui--

618
00:29:49,230 --> 00:29:52,470
e ricordare che in precedenza
il problema era questo,

619
00:29:52,470 --> 00:29:58,140
se si elimina questa prima riga di codice,
ed io andare avanti e fare buggy 0 ancora una volta,

620
00:29:58,140 --> 00:30:01,220
ricordare che ho avuto questi
i messaggi di errore qui.

621
00:30:01,220 --> 00:30:05,997
Quindi, l'idea qui, anche se ridicola
si sentono in questo momento fare questo pubblicamente,

622
00:30:05,997 --> 00:30:06,580
è tale errore.

623
00:30:06,580 --> 00:30:10,910
>> OK, quindi il mio problema è che ho
implicitamente dichiarato una funzione di libreria.

624
00:30:10,910 --> 00:30:12,610
E che funzione di libreria è printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, dichiarare
mi ricorda di prototipi.

626
00:30:15,290 --> 00:30:18,930
>> Ciò significa che ho bisogno di realtà
dire al compilatore in anticipo cosa

627
00:30:18,930 --> 00:30:19,980
la funzione assomiglia.

628
00:30:19,980 --> 00:30:20,930
Apetta un minuto.

629
00:30:20,930 --> 00:30:23,580
Non ho avuto io.h. di serie

630
00:30:23,580 --> 00:30:24,530
Grazie mille.

631
00:30:24,530 --> 00:30:27,330
>> Quindi, solo questo processo si di--
non c'è bisogno di avere in realtà una papera.

632
00:30:27,330 --> 00:30:29,819
Ma questa idea di camminare
se stessi attraverso il proprio codice

633
00:30:29,819 --> 00:30:31,610
in modo che anche sentire
te stesso, in modo da

634
00:30:31,610 --> 00:30:35,620
realizzare omissioni nella vostra
osservazioni, è generalmente l'idea.

635
00:30:35,620 --> 00:30:38,910
>> E, forse più logico, non è così
molto con quello, ma il più coinvolti

636
00:30:38,910 --> 00:30:44,220
ad esempio abbiamo appena fatto in 3.c buggy,
si potrebbe camminare da soli attraverso di essa

637
00:30:44,220 --> 00:30:45,310
Come segue.

638
00:30:45,310 --> 00:30:49,190
Quindi tutto bene, in gomma
Ducky, DDB, se si vuole.

639
00:30:49,190 --> 00:30:52,350
Qui abbiamo nella mia funzione principale,
Chiamo ottenere int negativo.

640
00:30:52,350 --> 00:30:54,660
>> E io sono sempre il valore di ritorno.

641
00:30:54,660 --> 00:31:00,410
Sto riporlo sul lato sinistro
sulla linea 8 in una variabile denominata i.

642
00:31:00,410 --> 00:31:02,380
OK, ma aspetta, come ha fatto
che ottiene quel valore?

643
00:31:02,380 --> 00:31:04,130
Fammi vedere la funzione di linea 12.

644
00:31:04,130 --> 00:31:05,760
>> In linea 12, abbiamo ottenere int negativo.

645
00:31:05,760 --> 00:31:08,190
Non viene compiuta alcuna ingressi,
non restituisce un int, OK.

646
00:31:08,190 --> 00:31:10,929
Dichiaro on line 14 una variabile n.

647
00:31:10,929 --> 00:31:12,220
E 'intenzione di memorizzare un numero intero.

648
00:31:12,220 --> 00:31:13,760
È quello che voglio.

649
00:31:13,760 --> 00:31:18,480
>> Quindi effettuare le seguenti operazioni mentre n è-- lasciare
Mi disfare ciò che la correzione ho già fatto.

650
00:31:18,480 --> 00:31:22,710
Così, mentre n è maggiore
0, stampare N è, OK.

651
00:31:22,710 --> 00:31:25,170
E quindi chiamare ottenere int memorizzato in n.

652
00:31:25,170 --> 00:31:30,160
E quindi verificare se n è 0,
n è non-- è così.

653
00:31:30,160 --> 00:31:31,910
Così, ancora una volta, non è necessario
bisogno l'anatra reale.

654
00:31:31,910 --> 00:31:35,650
Ma solo a piedi se stessi attraverso
il codice come un esercizio intellettuale

655
00:31:35,650 --> 00:31:37,720
spesso vi aiuterà
rendersi conto di cosa sta succedendo,

656
00:31:37,720 --> 00:31:41,170
in contrasto con appena fare qualcosa
in questo modo, a fissare lo schermo,

657
00:31:41,170 --> 00:31:43,720
e non parlare se stessi attraverso
esso, che onestamente non è

658
00:31:43,720 --> 00:31:46,270
quasi come una tecnica efficace.

659
00:31:46,270 --> 00:31:48,620
Quindi non lo avete, un
numero di tecniche diverse

660
00:31:48,620 --> 00:31:52,102
per realtà il debug del codice
e ricerca guasti, tutti

661
00:31:52,102 --> 00:31:54,810
dovrebbe essere strumenti nel vostro toolkit
in modo che non sei a tarda notte,

662
00:31:54,810 --> 00:31:57,660
in particolare, si è in sala
sale, o in orario di ufficio,

663
00:31:57,660 --> 00:32:00,368
sbattere la testa contro il
muro, cercando di risolvere qualche problema.

664
00:32:00,368 --> 00:32:02,020
Rendetevi conto che ci sono strumenti software.

665
00:32:02,020 --> 00:32:03,720
Ci sono strumenti di anatra di gomma.

666
00:32:03,720 --> 00:32:09,630
E c'è un intero staff di
sostenere in attesa di dare una mano.

667
00:32:09,630 --> 00:32:13,120
>> Così ora, una parola sul problema
set, e su quello che stiamo sperando che tu

668
00:32:13,120 --> 00:32:15,620
uscire di loro, e come
andiamo circa la valutazione.

669
00:32:15,620 --> 00:32:17,680
Per programma del corso,
insiemi di problemi di CS50

670
00:32:17,680 --> 00:32:22,320
sono valutati su quattro assi primari, così
a speak-- ambito, la correttezza, la progettazione,

671
00:32:22,320 --> 00:32:23,060
e lo stile.

672
00:32:23,060 --> 00:32:25,910
E la portata solo si riferisce a quanto
del pezzo hai fatto il passo?

673
00:32:25,910 --> 00:32:28,080
Quanto di un problema che hai provato?

674
00:32:28,080 --> 00:32:30,110
Qual è il livello di sforzo
avete manifestato?

675
00:32:30,110 --> 00:32:35,750
>> La correttezza è, funziona il programma come
si suppone che secondo la specifica CS50

676
00:32:35,750 --> 00:32:38,640
quando si fornisce alcuni ingressi
o certe uscite a tornare?

677
00:32:38,640 --> 00:32:41,130
Il design è il più personale di loro.

678
00:32:41,130 --> 00:32:43,360
Ed è quello che sarà
prendere più tempo per imparare

679
00:32:43,360 --> 00:32:47,220
e più tempo per insegnare, in
misura in cui essa si riduce a,

680
00:32:47,220 --> 00:32:49,530
come ben scritto è il codice?

681
00:32:49,530 --> 00:32:52,920
>> E 'una cosa per stampare solo la corretta
uscite o restituiscono i valori giusti.

682
00:32:52,920 --> 00:32:55,400
Ma stai facendo come
efficiente possibile?

683
00:32:55,400 --> 00:32:58,210
Stai facendo lo divide
e conquistare, o binario

684
00:32:58,210 --> 00:33:01,500
ricerca come vedremo presto che abbiamo fatto
due settimane fa con l'elenco telefonico?

685
00:33:01,500 --> 00:33:04,670
ci sono modi migliori per risolvere il
problema di quello che attualmente avete qui?

686
00:33:04,670 --> 00:33:06,380
Questa è un'opportunità per una migliore progettazione.

687
00:33:06,380 --> 00:33:08,530
>> E allora come style--
piuttosto è il codice?

688
00:33:08,530 --> 00:33:12,370
Si noterà che sono abbastanza
particolare circa rientro il mio codice,

689
00:33:12,370 --> 00:33:15,300
e fare in modo mio variabili
ragionevolmente chiamato. n,

690
00:33:15,300 --> 00:33:19,660
mentre breve, è un buon nome per un
numero, i per un intero conteggio,

691
00:33:19,660 --> 00:33:20,727
s per una stringa.

692
00:33:20,727 --> 00:33:22,560
E siamo in grado di avere più a lungo
stile nomi delle variabili.

693
00:33:22,560 --> 00:33:25,500
Lo stile è solo quanto è buono
non il codice di look?

694
00:33:25,500 --> 00:33:26,600
E come leggibile è?

695
00:33:26,600 --> 00:33:29,650
>> E nel corso del tempo, quali i tuoi TA
e TF faranno nel corso

696
00:33:29,650 --> 00:33:31,870
è fornire con tale
tipo di feedback qualitativo

697
00:33:31,870 --> 00:33:34,330
in modo da ottenere una migliore
a quei vari aspetti.

698
00:33:34,330 --> 00:33:37,510
E in termini di come noi
valutare ciascuno di questi assi,

699
00:33:37,510 --> 00:33:40,080
è in genere con poche
secchi in modo che, in generale,

700
00:33:40,080 --> 00:33:41,680
avere un'idea di quanto bene si sta facendo.

701
00:33:41,680 --> 00:33:45,680
E, in effetti, se si riceve un punteggio su
una di queste correttezza axes--, disegno

702
00:33:45,680 --> 00:33:49,659
e lo stile especially-- quel numero
sarà generalmente tra 1 e 5.

703
00:33:49,659 --> 00:33:52,450
E, letteralmente, se stai ricevendo
3 del all'inizio del semestre,

704
00:33:52,450 --> 00:33:53,977
questa è una cosa molto buona.

705
00:33:53,977 --> 00:33:55,810
Significa c'è ancora
margini di miglioramento,

706
00:33:55,810 --> 00:33:58,490
che si sarebbe sperare in
prendere una classe per la prima volta.

707
00:33:58,490 --> 00:34:01,820
C'è spera qualche po 'di soffitto
a cui si sta aspirando a raggiungere.

708
00:34:01,820 --> 00:34:03,970
E in modo da ottenere il 3 di
i primi pezzi,

709
00:34:03,970 --> 00:34:06,550
se non qualche 2 e di 4 di,
è, infatti, una buona cosa.

710
00:34:06,550 --> 00:34:08,880
E 'bene nel raggio d'azione,
ben all'interno aspettative.

711
00:34:08,880 --> 00:34:11,421
>> E se la vostra mente è corsa, attendere
un minuto, tre su cinque.

712
00:34:11,421 --> 00:34:12,620
Questo è davvero un 6 su 10.

713
00:34:12,620 --> 00:34:13,560
Questo è il 60%.

714
00:34:13,560 --> 00:34:14,830
Mio Dio, che è una F.

715
00:34:14,830 --> 00:34:15,870
>> Non è.

716
00:34:15,870 --> 00:34:17,600
Non è, infatti, che.

717
00:34:17,600 --> 00:34:22,710
Piuttosto, si tratta di un'opportunità per migliorare
nel corso del semestre.

718
00:34:22,710 --> 00:34:25,580
E se stai ricevendo un po '
poveri, questi sono un'opportunità

719
00:34:25,580 --> 00:34:29,199
per sfruttare le ore di ufficio,
certamente sezioni e altre risorse.

720
00:34:29,199 --> 00:34:32,840
>> La cosa migliore è la possibilità, in realtà,
di cui essere orgogliosi quanto lontano hai

721
00:34:32,840 --> 00:34:34,520
venire nel corso del semestre.

722
00:34:34,520 --> 00:34:38,199
Quindi realizzare, se non
altrimenti, tre è buono.

723
00:34:38,199 --> 00:34:40,179
E permette spazio per la crescita nel tempo.

724
00:34:40,179 --> 00:34:43,090
>> Per quanto riguarda come quei assi sono
ponderata, realisticamente sei

725
00:34:43,090 --> 00:34:46,745
intenzione di trascorrere la maggior parte del vostro tempo ottenere
cose su cui lavorare, per non parlare correttamente.

726
00:34:46,745 --> 00:34:49,120
E così la correttezza tende a
essere ponderati di più, come con

727
00:34:49,120 --> 00:34:51,360
questo fattore moltiplicativo di tre.

728
00:34:51,360 --> 00:34:54,659
Il design è anche importante, ma
qualcosa che non si fa necessariamente

729
00:34:54,659 --> 00:34:58,220
spendere tutte quelle ore
cercando di ottenere le cose solo per lavorare.

730
00:34:58,220 --> 00:35:00,019
>> E così è ponderato
un po 'più leggera.

731
00:35:00,019 --> 00:35:01,560
E poi lo stile è ponderato in meno.

732
00:35:01,560 --> 00:35:03,710
Anche se non meno di
importante fondamentalmente,

733
00:35:03,710 --> 00:35:05,990
è solo, forse, la
cosa più facile da fare a destra,

734
00:35:05,990 --> 00:35:08,440
imitando gli esempi
fare in conferenza e la sezione,

735
00:35:08,440 --> 00:35:11,080
con le cose piacevolmente
frastagliata, e commentato,

736
00:35:11,080 --> 00:35:14,320
e così via è tra i più facili
le cose da fare e ottenere il diritto.

737
00:35:14,320 --> 00:35:16,960
Così come tale, realizzare
che quelli sono i punti

738
00:35:16,960 --> 00:35:19,000
che sono relativamente facili da afferrare.

739
00:35:19,000 --> 00:35:22,360
>> Ed ora una parola su
Questa poi onestà accademico.

740
00:35:22,360 --> 00:35:25,150
Quindi per il corso di
programma, si vedrà

741
00:35:25,150 --> 00:35:27,630
che il corso ha un bel
po 'di lingua intorno a questo.

742
00:35:27,630 --> 00:35:31,380
E il corso prende la questione della
onestà accademico molto seriamente.

743
00:35:31,380 --> 00:35:33,450
>> Noi abbiamo la distinzione,
nel bene e nel male,

744
00:35:33,450 --> 00:35:36,570
di aver inviato ogni anno più
gli studenti per azione disciplinare

745
00:35:36,570 --> 00:35:39,670
che la maggior parte di qualsiasi altro
Naturalmente, che sono a conoscenza.

746
00:35:39,670 --> 00:35:42,580
Questo non è necessariamente
indicativa del fatto

747
00:35:42,580 --> 00:35:46,340
che gli studenti CS, o studenti CS50, sono
meno onesti dei tuoi compagni di classe.

748
00:35:46,340 --> 00:35:49,090
Ma la realtà che in questo
mondo, per via elettronica, che abbiamo appena

749
00:35:49,090 --> 00:35:50,990
hanno tecnologica
mezzi di rilevamento di questo.

750
00:35:50,990 --> 00:35:53,360
>> E 'importante per noi per
l'equità attraverso la classe

751
00:35:53,360 --> 00:35:58,550
che facciamo rilevare questo, ed aumentare
la questione quando vediamo le cose.

752
00:35:58,550 --> 00:36:01,980
E proprio per dipingere un quadro, e davvero
per contribuire a qualcosa di simile lavandino in,

753
00:36:01,980 --> 00:36:04,600
questi i numeri di
studenti nel corso degli ultimi 10 anni

754
00:36:04,600 --> 00:36:07,610
che sono stati coinvolti in qualche
tali questioni di onestà accademica,

755
00:36:07,610 --> 00:36:10,990
con circa 32 studenti
dalla caduta 2015, che

756
00:36:10,990 --> 00:36:13,760
vale a dire che noi prendiamo
la questione molto seriamente.

757
00:36:13,760 --> 00:36:18,380
E, in ultima analisi, questi numeri comporre,
più recentemente, circa il 3%, 4%, oppure

758
00:36:18,380 --> 00:36:19,120
della classe.

759
00:36:19,120 --> 00:36:25,220
>> Così, per la super-maggioranza degli studenti
sembra che le linee sono chiare.

760
00:36:25,220 --> 00:36:27,940
Ma tenere questo in
mente, particolarmente in ritardo

761
00:36:27,940 --> 00:36:32,080
di notte, quando alle prese con
qualche soluzione di un problema proposto

762
00:36:32,080 --> 00:36:34,830
l'esistenza di meccanismi
per farti meglio

763
00:36:34,830 --> 00:36:37,870
supporto di quanto si possa
pensare, anche a quell'ora.

764
00:36:37,870 --> 00:36:40,514
Rendetevi conto che quando riceviamo
osservazioni degli studenti, si incrociano

765
00:36:40,514 --> 00:36:43,430
confrontare ogni presentazione di quest'anno
contro ogni presentazione l'anno scorso,

766
00:36:43,430 --> 00:36:47,590
contro ogni sottomissione a partire dal 2007,
e poiché, guardando, così,

767
00:36:47,590 --> 00:36:49,931
codice repository online,
forum di discussione, luoghi di lavoro.

768
00:36:49,931 --> 00:36:51,806
E ricordiamo questo,
veramente, tutti per il bene

769
00:36:51,806 --> 00:36:56,040
di una completa informativa, che se
qualcun altro può trovare on-line,

770
00:36:56,040 --> 00:36:57,880
Certamente, possiamo farlo anche noi il corso.

771
00:36:57,880 --> 00:37:00,100
Ma, in realtà, lo spirito
del corso si riduce

772
00:37:00,100 --> 00:37:01,650
a questo punto nel programma.

773
00:37:01,650 --> 00:37:03,670
E 'davvero solo, essere ragionevole.

774
00:37:03,670 --> 00:37:06,680
>> E se abbiamo dovuto elaborare su tale
con solo un po 'di più la lingua,

775
00:37:06,680 --> 00:37:09,770
conto che l'essenza di tutta
lavoro che si presenta a questo corso

776
00:37:09,770 --> 00:37:10,954
deve essere il vostro.

777
00:37:10,954 --> 00:37:13,870
Ma all'interno di questo, ci sono certamente
opportunità, e l'incoraggiamento,

778
00:37:13,870 --> 00:37:17,300
e valore pedagogico in rivolgendosi a
others-- me stesso, il TF, il CA,

779
00:37:17,300 --> 00:37:20,760
i TAS, e altri in classe,
per il supporto, e tanto amici da solo

780
00:37:20,760 --> 00:37:23,547
e compagni di stanza che hanno studiato
CS e programmazione prima.

781
00:37:23,547 --> 00:37:25,130
E così c'è un assegno per questo.

782
00:37:25,130 --> 00:37:28,180
E la regola generale
è questo-- quando chiedere aiuto,

783
00:37:28,180 --> 00:37:31,470
si può mostrare il codice per gli altri,
ma non si può visualizzare la loro.

784
00:37:31,470 --> 00:37:34,880
Quindi, anche se si è in orario d'ufficio,
o nella sala D, o da qualche altra parte

785
00:37:34,880 --> 00:37:37,450
lavorando su alcuni pezzi,
lavorando fianco a fianco un amico, che

786
00:37:37,450 --> 00:37:40,160
è totalmente bene, al
fine della giornata il vostro lavoro

787
00:37:40,160 --> 00:37:43,034
dovrebbe in ultima analisi, appartengono a ciascun
di voi, rispettivamente, e non

788
00:37:43,034 --> 00:37:45,700
essere qualche sforzo di collaborazione,
tranne per il progetto finale dove

789
00:37:45,700 --> 00:37:47,410
è consentito e incoraggiato.

790
00:37:47,410 --> 00:37:49,830
>> Rendetevi conto che se si è
alle prese con qualcosa

791
00:37:49,830 --> 00:37:52,520
e il tuo amico succede solo
per essere meglio a questo allora si,

792
00:37:52,520 --> 00:37:55,130
o meglio a quel problema di te,
o un po 'più avanti di te,

793
00:37:55,130 --> 00:37:57,330
è del tutto ragionevole a girare
al tuo amico e dire, ehi,

794
00:37:57,330 --> 00:38:00,480
ti dispiace guardando il mio codice qui,
aiutandomi macchio qual è il mio problema è?

795
00:38:00,480 --> 00:38:03,760
E, si spera, nel
interesse del valore pedagogico

796
00:38:03,760 --> 00:38:07,040
che amico non solo
dire, oh, fare questo, ma piuttosto,

797
00:38:07,040 --> 00:38:09,917
cosa stai perdendo on line
6, o qualcosa del genere?

798
00:38:09,917 --> 00:38:12,000
Ma la soluzione non è
per l'amico accanto a te

799
00:38:12,000 --> 00:38:15,617
per dire, oh, beh, qui, mi permetta di tirare
questo in su, e mostrare la mia soluzione per voi.

800
00:38:15,617 --> 00:38:16,450
In modo che sia la linea.

801
00:38:16,450 --> 00:38:18,670
Si mostra il codice per
gli altri, ma non si può

802
00:38:18,670 --> 00:38:22,350
visualizzare loro, soggetto all'altro
vincoli nel programma del corso.

803
00:38:22,350 --> 00:38:24,760
>> Quindi tenere a mente questo
cosiddetta clausola di rammarico

804
00:38:24,760 --> 00:38:27,560
nel programma del corso e,
che se si impegnano qualche atto che

805
00:38:27,560 --> 00:38:30,476
Non è ragionevole, ma portarlo a
l'attenzione dei capi del corso

806
00:38:30,476 --> 00:38:34,240
entro 72 ore, il corso
può imporre sanzioni locali che

807
00:38:34,240 --> 00:38:37,380
può includere un insoddisfacente o
in mancanza di grado per il lavoro presentato.

808
00:38:37,380 --> 00:38:41,410
Ma il corso non farà riferimento alla
la materia per ulteriori azioni disciplinari,

809
00:38:41,410 --> 00:38:43,010
salvo i casi di ripetuti atti.

810
00:38:43,010 --> 00:38:46,632
In altre parole, se si fa fare un po '
stupido, soprattutto a tarda notte, la decisione

811
00:38:46,632 --> 00:38:49,340
che la mattina successiva o due giorni
più tardi, ti svegli e rendersi conto,

812
00:38:49,340 --> 00:38:50,870
cosa stavo pensando?

813
00:38:50,870 --> 00:38:53,890
Si fa in CS50 avere uno sbocco
per fissare questo problema

814
00:38:53,890 --> 00:38:57,170
e possedere fino ad esso, in modo da
si incontreranno a metà strada e trattare

815
00:38:57,170 --> 00:39:01,500
con esso in una questione che è sia
educativo e prezioso per voi,

816
00:39:01,500 --> 00:39:04,200
ma ancora punitive in qualche modo.

817
00:39:04,200 --> 00:39:08,590
E ora, a prendere il bordo al largo, questo.

818
00:39:08,590 --> 00:39:10,570
>> [RIPRODUZIONE VIDEO]

819
00:39:10,570 --> 00:39:13,540
>> [RIPRODUZIONE DI BRANI MUSICALI]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [FINE RIPRODUZIONE]

822
00:39:58,866 --> 00:40:00,490
David J. MALAN: Va bene, siamo tornati.

823
00:40:00,490 --> 00:40:03,680
E ora guardiamo uno dei
primo dei nostri domini del mondo reale

824
00:40:03,680 --> 00:40:08,720
in CS50, l'arte della crittografia,
l'arte di invio e ricezione

825
00:40:08,720 --> 00:40:11,840
messaggi segreti, criptato
messaggi se si vuole,

826
00:40:11,840 --> 00:40:17,060
che può essere decifrato solo se si dispone
qualche ingrediente fondamentale che il mittente ha

827
00:40:17,060 --> 00:40:18,030
anche.

828
00:40:18,030 --> 00:40:22,120
Quindi, per motivare questo prenderemo
uno sguardo a questa cosa qui,

829
00:40:22,120 --> 00:40:26,750
che è un esempio di un
anello decoder segreto che

830
00:40:26,750 --> 00:40:34,042
può essere utilizzato per capire
quello che un messaggio segreto è in realtà.

831
00:40:34,042 --> 00:40:35,750
Infatti, torna in
giorno in grado di scuola,

832
00:40:35,750 --> 00:40:38,787
se mai inviato messaggi segreti per
qualche amico o qualche cotta in classe,

833
00:40:38,787 --> 00:40:40,620
si potrebbe pensare
si stavano intelligente

834
00:40:40,620 --> 00:40:46,530
per il tuo pezzo di carta che cambia,
come, da A a B e B a C, e C a D,

835
00:40:46,530 --> 00:40:47,590
e così via.

836
00:40:47,590 --> 00:40:50,300
Ma che sono stati effettivamente cifrando
le informazioni, anche

837
00:40:50,300 --> 00:40:53,300
se era un po 'banale, non era
così difficile per l'insegnante di realizzare,

838
00:40:53,300 --> 00:40:55,675
bene, se basta cambiare
B ad A e C a B,

839
00:40:55,675 --> 00:40:57,550
in realtà capire
ciò che il messaggio era,

840
00:40:57,550 --> 00:40:59,700
ma eri nella cifratura delle informazioni.

841
00:40:59,700 --> 00:41:03,420
>> Stavi solo facendo
semplicemente, molto simile a Ralphie qui

842
00:41:03,420 --> 00:41:07,934
in un famoso film che gioca
praticamente fino alla nausea ogni inverno.

843
00:41:07,934 --> 00:41:08,600
[RIPRODUZIONE VIDEO]

844
00:41:08,600 --> 00:41:11,180
-Essere È noto a tutti che
Ralph Parker è presente

845
00:41:11,180 --> 00:41:14,070
nominato membro del Piccolo
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
e ha diritto a tutti gli onori
e benefici che si verificano ad esso.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
contro-firmato Pierre Andre, in inchiostro.

848
00:41:24,340 --> 00:41:27,160
Onori e benefici,
già all'età di nove anni.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [URLANDO]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Dai.

853
00:41:34,250 --> 00:41:35,210
Andiamo avanti con lui.

854
00:41:35,210 --> 00:41:39,530
Non ho bisogno di tutto quel jazz
A proposito di contrabbandieri e pirati.

855
00:41:39,530 --> 00:41:41,660
>> domani sera -listen per
l'avventura conclusiva

856
00:41:41,660 --> 00:41:43,880
della nave pirata nero.

857
00:41:43,880 --> 00:41:46,650
Ora, è il momento per
messaggio segreto di Annie

858
00:41:46,650 --> 00:41:49,840
per voi i membri del Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Ricordate, bambini, solo i membri
di Secret Circle di Annie

860
00:41:53,570 --> 00:41:56,140
in grado di decodificare il messaggio segreto di Annie.

861
00:41:56,140 --> 00:42:00,340
>> Ricordate, Annie dipende da te.

862
00:42:00,340 --> 00:42:02,880
Impostare i perni di B2.

863
00:42:02,880 --> 00:42:05,230
Ecco il messaggio.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Sono In, il mio primo incontro segreto.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Era in grande stasera voce.

868
00:42:15,780 --> 00:42:19,000
Potrei dire che stasera
messaggio è stato davvero importante.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, che è un messaggio
da Annie se stessa.

870
00:42:22,694 --> 00:42:23,860
Ricordate, non dirlo a nessuno.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Secondi dopo, io sono l'unico in
stanza della casa dove un ragazzo di nove anni

873
00:42:32,930 --> 00:42:37,040
potrebbe sedersi in privacy e decodifica.

874
00:42:37,040 --> 00:42:39,730
Ah, B!

875
00:42:39,730 --> 00:42:42,360
Sono andato al prossimo, E.

876
00:42:42,360 --> 00:42:44,520
>> La prima parola è essere.

877
00:42:44,520 --> 00:42:49,032
S, che stava arrivando più facile ora, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Oh, dai, Ralphie, devo andare!

879
00:42:51,733 --> 00:42:53,688
>> -Ti Essere di destra verso il basso, Ma!

880
00:42:53,688 --> 00:42:54,188
Caspita!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, assicurarsi a-- essere sicuri di che cosa?

883
00:43:04,060 --> 00:43:05,970
Qual è stato Little Orphan
Annie cercando di dire?

884
00:43:05,970 --> 00:43:07,264
Essere sicuri di che cosa?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy ha avuto modo di
Go, vi prego di venire fuori?

886
00:43:09,634 --> 00:43:10,480
>> -Tutti destra, Ma!

887
00:43:10,480 --> 00:43:12,880
Sarò fuori proprio!

888
00:43:12,880 --> 00:43:14,550
>> -I Stava avvicinando ora.

889
00:43:14,550 --> 00:43:16,620
La tensione era terribile.

890
00:43:16,620 --> 00:43:17,720
Cos'era?

891
00:43:17,720 --> 00:43:20,170
Il destino del pianeta
possono in bilico.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
devo di Andy andare!

894
00:43:23,170 --> 00:43:26,890
>> -Ti Essere di destra fuori, per gridare forte!

895
00:43:26,890 --> 00:43:32,680
>> -Quasi Lì, le mie dita volavano, la mia mente
era una trappola d'acciaio, tutti i pori vibrare.

896
00:43:32,680 --> 00:43:37,198
Era quasi chiaro, sì, sì, sì.

897
00:43:37,198 --> 00:43:43,091
>> -Essere Sicuri di bere il tuo Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Uno spot scadente?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Figlio di puttana.

903
00:43:54,227 --> 00:43:54,810
[FINE RIPRODUZIONE]

904
00:43:54,810 --> 00:43:57,390
David J. MALAN: OK, così
che era un modo molto lungo

905
00:43:57,390 --> 00:44:00,660
di introdurre la crittografia,
e anche Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Infatti, da questo vecchio annuncio
qui, perché è Ovaltine così buono?

907
00:44:04,470 --> 00:44:09,470
È un'estrazione concentrata di ripe
malto d'orzo, puro latte di mucca cremoso,

908
00:44:09,470 --> 00:44:14,360
e appositamente preparati cacao, insieme
con fosfatidi naturali e vitamine.

909
00:44:14,360 --> 00:44:18,240
Si è ulteriormente fortificato con
ulteriori vitamine del gruppo B e D, yum.

910
00:44:18,240 --> 00:44:21,600
Ed è ancora possibile ottenere che, a quanto pare,
su Amazon, come abbiamo fatto qui.

911
00:44:21,600 --> 00:44:24,810
>> Ma la motivazione era quella di
introdurre la crittografia, in particolare

912
00:44:24,810 --> 00:44:28,340
un tipo di crittografia noto
come crittografia a chiave segreta.

913
00:44:28,340 --> 00:44:34,284
E come suggerisce il nome, l'intera
sicurezza di un sistema di crittografia a chiave segreta,

914
00:44:34,284 --> 00:44:36,200
se si vuole, una metodologia
solo per scrambling

915
00:44:36,200 --> 00:44:40,960
informazioni tra due persone, è che
solo il mittente e solo il destinatario

916
00:44:40,960 --> 00:44:46,980
conoscere un segreto key-- un certo valore, un po '
frase segreta, un numero segreto, che

917
00:44:46,980 --> 00:44:50,660
li permette di crittografare
e decifrare le informazioni.

918
00:44:50,660 --> 00:44:53,470
E la crittografia, in realtà,
è proprio questo a partire dalla settimana 0.

919
00:44:53,470 --> 00:44:56,715
>> E 'un problema dove c'è ingressi,
come il messaggio effettivo in inglese

920
00:44:56,715 --> 00:44:59,340
o qualunque lingua che si
desidera inviare a qualcuno in classe,

921
00:44:59,340 --> 00:45:00,580
o attraverso la rete internet.

922
00:45:00,580 --> 00:45:03,840
Vi è una certa uscita, che sta
essere il messaggio criptato che si

923
00:45:03,840 --> 00:45:05,250
desidera che il destinatario per ricevere.

924
00:45:05,250 --> 00:45:07,405
E anche se qualcuno in
mezzo riceve troppo,

925
00:45:07,405 --> 00:45:09,780
non li vuole
necessariamente essere in grado di decifrarlo,

926
00:45:09,780 --> 00:45:12,840
perché all'interno di questo
scatola nera, o algoritmo,

927
00:45:12,840 --> 00:45:17,650
è qualche meccanismo, qualche passo passo
le istruzioni, per l'adozione di tale ingresso

928
00:45:17,650 --> 00:45:20,710
e convertirlo in
uscita, in spera modo sicuro.

929
00:45:20,710 --> 00:45:23,640
>> E, infatti, c'è qualche
vocabolario in questo mondo nel modo seguente.

930
00:45:23,640 --> 00:45:26,100
Testo normale è la parola di un
informatico sarebbe

931
00:45:26,100 --> 00:45:28,449
utilizzare per descrivere l'input
messaggio, come l'inglese

932
00:45:28,449 --> 00:45:31,240
o qualunque linguaggio in realtà
desidera inviare a qualche altro essere umano.

933
00:45:31,240 --> 00:45:35,450
E poi il testo cifrato è la corsa
al cifrato o criptato,

934
00:45:35,450 --> 00:45:36,520
la versione della stessa.

935
00:45:36,520 --> 00:45:38,750
>> Ma c'è un altro ingrediente qui.

936
00:45:38,750 --> 00:45:43,200
C'è un altro ingresso a
crittografia a chiave segreta.

937
00:45:43,200 --> 00:45:45,200
E questa è la chiave stessa,
che è, in generale,

938
00:45:45,200 --> 00:45:48,930
come vedremo, un numero, o
lettera, o una parola, qualunque

939
00:45:48,930 --> 00:45:51,980
l'algoritmo è in realtà aspetta.

940
00:45:51,980 --> 00:45:53,870
>> E come si fa a decifrare le informazioni?

941
00:45:53,870 --> 00:45:55,110
Come si fa a decifrare esso?

942
00:45:55,110 --> 00:45:57,950
Beh, basta invertire il
uscite e gli ingressi.

943
00:45:57,950 --> 00:46:00,900
>> In altre parole, una volta che qualcuno
riceve il messaggio cifrato,

944
00:46:00,900 --> 00:46:03,740
lui o lei ha semplicemente
sapere lo stesso codice.

945
00:46:03,740 --> 00:46:05,700
Hanno ricevuto il testo cifrato.

946
00:46:05,700 --> 00:46:09,530
E collegando quei due
ingressi nel sistema di crittografia,

947
00:46:09,530 --> 00:46:14,260
l'algoritmo, questa scatola nera, fuori
dovrebbe venire il testo in chiaro originale.

948
00:46:14,260 --> 00:46:17,830
E così questo è il livello molto elevato
vista di ciò che la crittografia è effettivamente

949
00:46:17,830 --> 00:46:18,590
tutto su.

950
00:46:18,590 --> 00:46:20,030
>> Quindi cerchiamo di ottenere lì.

951
00:46:20,030 --> 00:46:22,700
Vediamo ora sotto
il cofano di qualcosa

952
00:46:22,700 --> 00:46:26,000
siamo stati dando per scontato per
la scorsa settimana, e per questa sessione

953
00:46:26,000 --> 00:46:27,629
qui-- la stringa.

954
00:46:27,629 --> 00:46:30,295
Una stringa alla fine della giornata
è solo una sequenza di caratteri.

955
00:46:30,295 --> 00:46:33,610
>> Potrebbe essere ciao mondo, o
ciao Zamyla, o qualsiasi altra cosa.

956
00:46:33,610 --> 00:46:37,050
Ma cosa significa per
essere una sequenza di caratteri?

957
00:46:37,050 --> 00:46:41,520
Infatti, la libreria CS50 dà
noi un tipo di dati chiamato stringa.

958
00:46:41,520 --> 00:46:45,140
>> Ma vi è in realtà alcuna
cosa come una stringa in C.

959
00:46:45,140 --> 00:46:49,450
E 'davvero solo una sequenza di
carattere, carattere, carattere,

960
00:46:49,450 --> 00:46:52,180
carattere, di nuovo, alla parte posteriore, a
indietro, alla parte posteriore, alla parte posteriore dentro

961
00:46:52,180 --> 00:46:54,650
della memoria del computer, o di RAM.

962
00:46:54,650 --> 00:46:58,940
E vedremo più in profondità che in
futuro, quando guardiamo memoria stessa,

963
00:46:58,940 --> 00:47:02,030
e l'utilizzazione e la
le minacce che sono coinvolti.

964
00:47:02,030 --> 00:47:04,100
>> Ma prendiamo in considerazione la stringa Zamyla.

965
00:47:04,100 --> 00:47:07,480
Quindi, solo il nome di
l'umano qui, Zamyla,

966
00:47:07,480 --> 00:47:12,030
cioè una sequenza di
caratteri, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
E ora supponiamo che il nome di Zamyla
viene immagazzinato all'interno di un computer

968
00:47:16,020 --> 00:47:16,880
programma.

969
00:47:16,880 --> 00:47:20,830
>> Beh, è ​​ovvio che dovremmo
essere in grado di guardare a quei caratteri

970
00:47:20,830 --> 00:47:21,590
individualmente.

971
00:47:21,590 --> 00:47:24,710
Così Sto solo andando a disegnare un po '
box intorno al nome del Zamyla qui.

972
00:47:24,710 --> 00:47:31,580
Ed è il caso in C che quando
avere una stringa, come Zamyla-- e forse

973
00:47:31,580 --> 00:47:34,940
tale stringa è tornato da
una funzione come stringa di get,

974
00:47:34,940 --> 00:47:38,540
si può effettivamente manipolare
carattere che per carattere.

975
00:47:38,540 --> 00:47:42,070
>> Ora, questo è germano per la
conversazione a portata di mano, perché

976
00:47:42,070 --> 00:47:46,420
in crittografia se si desidera modificare
A a B e B a C, e C a D,

977
00:47:46,420 --> 00:47:49,650
e così via, è necessario essere in grado
a guardare i singoli caratteri

978
00:47:49,650 --> 00:47:50,190
in una stringa.

979
00:47:50,190 --> 00:47:52,695
È necessario essere in grado di cambiare
Z a qualcos'altro, la A

980
00:47:52,695 --> 00:47:55,280
a qualcosa d'altro, la M per
qualcos'altro, e così via.

981
00:47:55,280 --> 00:47:58,000
E così abbiamo bisogno di un modo,
a livello di codice, in modo da

982
00:47:58,000 --> 00:48:03,020
parlare, in C per poter cambiare
e guardare le singole lettere.

983
00:48:03,020 --> 00:48:05,690
E possiamo farlo in questo modo.

984
00:48:05,690 --> 00:48:08,340
>> Lasciatemi andare tornate in CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
E mi permetta di andare avanti
e creare un nuovo file

986
00:48:11,130 --> 00:48:16,134
che chiamerò questa volta stringa0,
come il nostro primo esempio del genere, dot c.

987
00:48:16,134 --> 00:48:18,300
E ho intenzione di andare avanti
e frusta come segue.

988
00:48:18,300 --> 00:48:22,870
>> Quindi includere CS50.h, e
quindi includere io.h di serie,

989
00:48:22,870 --> 00:48:25,990
che ho quasi sempre andando a
prevede di utilizzare nei miei programmi, almeno

990
00:48:25,990 --> 00:48:26,780
inizialmente.

991
00:48:26,780 --> 00:48:32,180
int void main, e poi qui sono
andando a fare le stringhe si ottiene stringa.

992
00:48:32,180 --> 00:48:35,260
E poi ho intenzione di
andare avanti e fare questo.

993
00:48:35,260 --> 00:48:37,460
Voglio andare avanti
e, come un controllo di integrità,

994
00:48:37,460 --> 00:48:43,607
solo dire, ciao, cento s,
punto e virgola, rende stringa di 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, che cosa ho fatto qui?

996
00:48:44,690 --> 00:48:45,930
Oh, non ho collegarlo.

997
00:48:45,930 --> 00:48:48,120
Così lezione appresa, che
non era intenzionale.

998
00:48:48,120 --> 00:48:52,480
>> Quindi l'errore, più cento
conversioni di argomenti di dati.

999
00:48:52,480 --> 00:48:54,940
Ed è qui, in
Linea 7-- OK, quindi non ho,

1000
00:48:54,940 --> 00:48:56,690
tra virgolette, che è
la mia stringa di printf.

1001
00:48:56,690 --> 00:48:58,151
Ho un segno di percentuale.

1002
00:48:58,151 --> 00:48:59,650
Ma mi manca il secondo argomento.

1003
00:48:59,650 --> 00:49:03,190
>> Mi manca la virgola s, che
Ho avuto negli esempi precedenti.

1004
00:49:03,190 --> 00:49:06,650
Quindi, una buona occasione per fissare
un altro errore, accidentalmente.

1005
00:49:06,650 --> 00:49:09,950
E ora mi permetta di correre
stringa0, digitare Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, ciao Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Così abbiamo fatto funzionare questo tipo di programma
un paio di volte diverso.

1008
00:49:14,144 --> 00:49:16,310
Ma cerchiamo di fare qualcosa di un
po 'diverso questa volta.

1009
00:49:16,310 --> 00:49:19,450
Invece di limitarsi a stampare Zamyla di
intero nome con printf,

1010
00:49:19,450 --> 00:49:21,350
facciamolo carattere per carattere.

1011
00:49:21,350 --> 00:49:22,700
>> Ho intenzione di utilizzare un ciclo for.

1012
00:49:22,700 --> 00:49:26,160
E ho intenzione di dare a me stesso
una variabile di conteggio, chiamato i.

1013
00:49:26,160 --> 00:49:33,530
E ho intenzione di continuare l'iterazione, in modo da
Finché i è inferiore alla lunghezza di s.

1014
00:49:33,530 --> 00:49:35,930
>> Si scopre, non abbiamo
fare l'ultima volta,

1015
00:49:35,930 --> 00:49:39,100
che c viene fornito con un
funzione chiamata Stirling.

1016
00:49:39,100 --> 00:49:42,690
Indietro nel giorno, e in generale
ancora in sede di attuazione funzioni,

1017
00:49:42,690 --> 00:49:45,405
gli esseri umani spesso scelgono molto
I nomi succinta quel tipo di suono

1018
00:49:45,405 --> 00:49:48,280
come quello che si vuole, anche se è
mancano pochi vocali o lettere.

1019
00:49:48,280 --> 00:49:50,660
Così Stirling è il
nome di una funzione che

1020
00:49:50,660 --> 00:49:53,880
prende un argomento tra
parentesi che dovrebbe essere una stringa.

1021
00:49:53,880 --> 00:49:56,910
Ed è solo restituisce un intero,
la lunghezza di tale stringa.

1022
00:49:56,910 --> 00:50:00,580
>> Quindi questo ciclo for sulla linea 7 sta andando
per iniziare il conteggio a I è uguale a 0.

1023
00:50:00,580 --> 00:50:02,530
E 'intenzione di incrementare
i su ogni iterazione

1024
00:50:02,530 --> 00:50:04,350
da 1, come abbiamo fatto un paio di volte.

1025
00:50:04,350 --> 00:50:06,780
Ma sta andando a fare solo
questo fino al punto

1026
00:50:06,780 --> 00:50:09,660
quando i è la lunghezza
della stringa stessa.

1027
00:50:09,660 --> 00:50:14,520
>> Quindi questo è un modo di, in ultima analisi,
iterare sui caratteri

1028
00:50:14,520 --> 00:50:17,430
nella stringa come è seguito.

1029
00:50:17,430 --> 00:50:20,670
Ho intenzione di stampare non è una
un'intera stringa, ma cento C,

1030
00:50:20,670 --> 00:50:22,860
un singolo carattere
seguita da una nuova linea.

1031
00:50:22,860 --> 00:50:24,880
E poi ho intenzione di
Vai avanti, e ho bisogno

1032
00:50:24,880 --> 00:50:29,080
a dire che voglio per la stampa
carattere esimo di s.

1033
00:50:29,080 --> 00:50:33,450
>> Quindi, se i è la variabile che indica
l'indice della stringa, dove

1034
00:50:33,450 --> 00:50:37,230
si è in esso, ho bisogno di essere in grado di
dire, dammi il carattere esimo di s.

1035
00:50:37,230 --> 00:50:40,390
E c ha un modo di fare
questo con parentesi quadre.

1036
00:50:40,390 --> 00:50:43,679
È sufficiente dire il nome del
stringa, che in questo caso è s.

1037
00:50:43,679 --> 00:50:46,970
Poi si utilizza parentesi quadre, che sono
di solito appena sopra il vostro capo o Invio

1038
00:50:46,970 --> 00:50:48,110
tasto sulla tastiera.

1039
00:50:48,110 --> 00:50:52,410
E poi si mette l'indice del
carattere che si desidera stampare.

1040
00:50:52,410 --> 00:50:55,960
Così l'indice sarà un
number-- 0 o 1 o 2 o 3, o dot,

1041
00:50:55,960 --> 00:50:57,590
dot, dot, un altro numero.

1042
00:50:57,590 --> 00:51:00,920
>> E ci assicuriamo che sta andando a
essere il numero giusto, perché io

1043
00:51:00,920 --> 00:51:02,360
iniziare il conteggio a 0.

1044
00:51:02,360 --> 00:51:07,020
E per impostazione predefinita, il primo carattere
in una stringa è per convenzione 0.

1045
00:51:07,020 --> 00:51:09,230
E il secondo carattere è staffa 1.

1046
00:51:09,230 --> 00:51:11,120
E il terzo personaggio è staffa 2.

1047
00:51:11,120 --> 00:51:13,630
E non si vuole andare troppo
lontano, ma ci sarà non perché siamo

1048
00:51:13,630 --> 00:51:17,780
andando ad incrementare solo io fino a quando non
uguale alla lunghezza della stringa.

1049
00:51:17,780 --> 00:51:20,210
E a quel punto,
questo ciclo for si fermerà.

1050
00:51:20,210 --> 00:51:25,550
>> Quindi, mi permetta di andare avanti e salvare questo
il programma, ed eseguire fare stringa di 0.

1051
00:51:25,550 --> 00:51:28,400
Ma ho fatto un casino.

1052
00:51:28,400 --> 00:51:35,390
dichiarando implicitamente funzione di libreria
Stirling con il tipo di tale e such-- ora,

1053
00:51:35,390 --> 00:51:36,430
questo suona familiare.

1054
00:51:36,430 --> 00:51:37,440
Ma non è printf.

1055
00:51:37,440 --> 00:51:38,540
E non è ottenere stringa.

1056
00:51:38,540 --> 00:51:40,480
>> Non ho vite in
allo stesso modo questa volta.

1057
00:51:40,480 --> 00:51:45,100
Ma notare qui un po 'giù
inoltre, includere l'intestazione string.h,

1058
00:51:45,100 --> 00:51:47,210
fornire esplicitamente il
Dichiarazione per Stirling.

1059
00:51:47,210 --> 00:51:48,820
Quindi non vi è in realtà un indizio in là.

1060
00:51:48,820 --> 00:51:51,670
>> E in effetti si scopre
c'è un altro file di intestazione

1061
00:51:51,670 --> 00:51:53,970
che noi non abbiamo usato
nella classe ancora, ma è

1062
00:51:53,970 --> 00:51:56,480
tra quelli disponibili
a te, chiamato string.h.

1063
00:51:56,480 --> 00:52:00,930
E in quel file, string.h
è Stirling dichiarato.

1064
00:52:00,930 --> 00:52:05,220
Quindi, mi permetta di andare avanti e
salvare questo, fare stringa

1065
00:52:05,220 --> 00:52:08,040
0-- bello, nessun messaggio di errore questa volta.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, e
Sono in procinto di colpire Invio,

1067
00:52:12,290 --> 00:52:16,710
a questo punto getString sta andando
per restituire la stringa, metterlo in s.

1068
00:52:16,710 --> 00:52:21,890
Poi che per il ciclo sta per iterare
tra i caratteri di S uno alla volta,

1069
00:52:21,890 --> 00:52:28,420
e stamparli uno per riga, perché
Ho avuto che backslash n alla fine.

1070
00:52:28,420 --> 00:52:34,530
Così ho potuto omettere che backslash
n, e poi basta stampare Zamyla tutto

1071
00:52:34,530 --> 00:52:37,460
nella stessa linea,
efficacemente reimplementazione

1072
00:52:37,460 --> 00:52:38,999
printf, che non è poi così utile.

1073
00:52:38,999 --> 00:52:40,540
Ma in questo caso, non ho fatto.

1074
00:52:40,540 --> 00:52:43,610
In realtà ho stampato uno
carattere per volta, uno per riga,

1075
00:52:43,610 --> 00:52:45,400
in modo che in realtà vedere l'effetto.

1076
00:52:45,400 --> 00:52:46,900
>> Ma Vorrei sottolineare una cosa qui.

1077
00:52:46,900 --> 00:52:48,930
E torneremo a
questo in una settimana futuro.

1078
00:52:48,930 --> 00:52:52,650
Si scopre che questo
il codice è potenzialmente buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Si scopre che stringa get
e altre funzioni vitali

1080
00:52:56,560 --> 00:53:00,280
Non è necessariamente sempre
restituire ciò che vi aspettate.

1081
00:53:00,280 --> 00:53:03,010
Sappiamo dalla classe scorso
tempo in questa che ottengono

1082
00:53:03,010 --> 00:53:04,960
stringa deve restituire una stringa.

1083
00:53:04,960 --> 00:53:09,900
Ma cosa succede se l'utente digita tali
una parola lunga, o un paragrafo, o un saggio

1084
00:53:09,900 --> 00:53:13,010
che non c'è solo non basta
memoria del computer per adattarlo.

1085
00:53:13,010 --> 00:53:15,410
>> Come, cosa succede se qualcosa va
sbagliato sotto il cofano?

1086
00:53:15,410 --> 00:53:18,400
Potrebbe non accadere spesso,
ma potrebbe accadere una volta

1087
00:53:18,400 --> 00:53:21,520
in un po ', molto di rado.

1088
00:53:21,520 --> 00:53:25,460
E così si scopre che stringa get
e funzioni come lo fanno non necessariamente

1089
00:53:25,460 --> 00:53:26,380
tornare sempre stringhe.

1090
00:53:26,380 --> 00:53:30,680
Potrebbero tornare un valore di errore,
qualche valore sentinella così dire,

1091
00:53:30,680 --> 00:53:32,612
che indica che
qualcosa è andato storto.

1092
00:53:32,612 --> 00:53:35,320
E si sa solo questo da
avendo imparato in classe ora,

1093
00:53:35,320 --> 00:53:37,700
o aver letto un po 'di documentazione.

1094
00:53:37,700 --> 00:53:43,120
Si scopre che stringa get
può restituire un valore chiamato nullo.

1095
00:53:43,120 --> 00:53:46,220
Null è un valore speciale che faremo
tornare in una settimana futuro.

1096
00:53:46,220 --> 00:53:50,420
Ma per ora, è sufficiente sapere che se voglio
per essere veramente corretta in movimento in avanti

1097
00:53:50,420 --> 00:53:52,650
usando stringhe get, io
non deve solo chiamare,

1098
00:53:52,650 --> 00:53:56,870
e utilizzare ciecamente il suo valore di ritorno,
confidando che si tratta di una stringa.

1099
00:53:56,870 --> 00:53:59,420
>> Dovrei prima dire,
Ehi, aspetta un attimo, solo

1100
00:53:59,420 --> 00:54:03,380
procedere se s non è uguale
null, dove nulla, di nuovo,

1101
00:54:03,380 --> 00:54:04,660
è solo un po 'di valore speciale.

1102
00:54:04,660 --> 00:54:07,770
Ed è l'unico valore speciale
bisogno di preoccuparsi per la stringa GET.

1103
00:54:07,770 --> 00:54:10,900
Get stringa è o sta
per restituire una stringa o nullo.

1104
00:54:10,900 --> 00:54:17,219
>> E questo punto esclamativo segno di uguale
si potrebbe sapere da forse classe di matematica

1105
00:54:17,219 --> 00:54:20,510
che si potrebbe disegnare un segno di uguale con
una linea attraverso di essa per indicare non uguale.

1106
00:54:20,510 --> 00:54:23,135
Questo non è in genere un carattere
è possibile digitare sulla tastiera.

1107
00:54:23,135 --> 00:54:26,480
E così nella maggior parte dei linguaggi di programmazione,
quando si vuole dire non uguale,

1108
00:54:26,480 --> 00:54:29,160
si utilizza un punto esclamativo,
altrimenti noto come Bang.

1109
00:54:29,160 --> 00:54:33,180
Così dite botto è uguale, che
significa non uguale, logicamente.

1110
00:54:33,180 --> 00:54:38,060
E 'proprio come non c'è una maggiore
o uguale a, o inferiore

1111
00:54:38,060 --> 00:54:41,270
o uguale al tasto sulla tastiera
che fa tutto in un unico simbolo.

1112
00:54:41,270 --> 00:54:44,020
Ecco, questo è il motivo per cui, negli esempi precedenti,
hai fatto una parentesi aperta, e poi

1113
00:54:44,020 --> 00:54:48,670
un segno di uguale, in modo da fare
maggiore o, diciamo, meno.

1114
00:54:48,670 --> 00:54:49,910
>> Allora qual è il takeaway qui?

1115
00:54:49,910 --> 00:54:53,880
Questo è semplicemente un modo di ora
l'introduzione di questa sintassi, questa funzione,

1116
00:54:53,880 --> 00:54:57,390
iterare su singoli
caratteri di una stringa.

1117
00:54:57,390 --> 00:55:00,260
E proprio come quelli piazza
staffe consentono di ottenere a loro,

1118
00:55:00,260 --> 00:55:03,790
considerare quelle parentesi quadre come
tipo di accennare a questo fondo

1119
00:55:03,790 --> 00:55:06,040
disegno, per cui ogni
carattere all'interno di una stringa

1120
00:55:06,040 --> 00:55:10,180
è una specie di scatola in qualche parte sotto
la cappa in memoria del computer.

1121
00:55:10,180 --> 00:55:12,340
>> Ma facciamo una variante di questo.

1122
00:55:12,340 --> 00:55:14,880
Si scopre che questo
programma è corretta.

1123
00:55:14,880 --> 00:55:18,810
Quindi, per gli assi del CS50 per la valutazione
codice, questo è corretto ora.

1124
00:55:18,810 --> 00:55:22,959
Soprattutto ora che sto controllando per
null, questo programma non dovrebbe mai bloccarsi.

1125
00:55:22,959 --> 00:55:24,500
E so solo che per esperienza.

1126
00:55:24,500 --> 00:55:28,040
Ma non c'è niente altro che
possiamo davvero sbagliare.

1127
00:55:28,040 --> 00:55:31,860
Ma non è molto ben progettato,
perché torniamo alle origini.

1128
00:55:31,860 --> 00:55:34,450
>> In primo luogo, principles--
Che cosa fa un ciclo for fare?

1129
00:55:34,450 --> 00:55:36,290
Un ciclo for fa tre cose.

1130
00:55:36,290 --> 00:55:39,340
Si inizializza alcuni
valore, se chiedete a.

1131
00:55:39,340 --> 00:55:41,770
Controlla una condizione.

1132
00:55:41,770 --> 00:55:45,380
E poi, dopo ogni
iterazione, dopo ogni ciclo,

1133
00:55:45,380 --> 00:55:49,330
incrementa un po '
valore o dei valori, qui.

1134
00:55:49,330 --> 00:55:50,600
>> Che cosa vuol dire?

1135
00:55:50,600 --> 00:55:52,940
Inizializziamo i per 0.

1136
00:55:52,940 --> 00:55:58,610
Controlliamo e assicurarsi che i è inferiore
la lunghezza di s, che è Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
così che è meno di 6.

1138
00:55:59,900 --> 00:56:02,590
E, in effetti, 0 per meno di 6.

1139
00:56:02,590 --> 00:56:05,580
>> Stampiamo fuori Z da il nome di Zamyla.

1140
00:56:05,580 --> 00:56:08,080
Poi viene incrementato i da 0 a 1.

1141
00:56:08,080 --> 00:56:11,290
Abbiamo poi CHECK, è meno 1
della lunghezza di s?

1142
00:56:11,290 --> 00:56:13,270
La lunghezza di s è 6.

1143
00:56:13,270 --> 00:56:13,950
Sì.

1144
00:56:13,950 --> 00:56:16,880
>> Così stampiamo una a nome di Zamyla, ZA.

1145
00:56:16,880 --> 00:56:20,090
i viene incrementato da 0, a 1, a 2.

1146
00:56:20,090 --> 00:56:23,720
Abbiamo poi CHECK, è inferiore a 2
la lunghezza del nome del Zamyla.

1147
00:56:23,720 --> 00:56:25,380
6- così 2 è inferiore a 6.

1148
00:56:25,380 --> 00:56:30,460
Sì, cerchiamo di stampare fuori ora M in
Il nome di Zamyla, il terzo personaggio.

1149
00:56:30,460 --> 00:56:34,110
>> La chiave qui è che su ciascun
iterazione della storia, sto controllando,

1150
00:56:34,110 --> 00:56:37,810
Sono io inferiore alla lunghezza di Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Ma il problema è che
Stirling non è una proprietà.

1152
00:56:40,350 --> 00:56:43,100
Quelli di voi che hanno programmato
prima in Java o altri linguaggi

1153
00:56:43,100 --> 00:56:46,310
potrebbe sapere la lunghezza di una stringa è
una proprietà, solo alcuni di sola lettura valore.

1154
00:56:46,310 --> 00:56:50,220
>> In C in questo caso, se questo è
una funzione che è letteralmente

1155
00:56:50,220 --> 00:56:53,520
contando il numero di
personaggi in Zamyla ogni volta

1156
00:56:53,520 --> 00:56:54,740
chiamiamo tale funzione.

1157
00:56:54,740 --> 00:56:58,500
Ogni volta che si chiede il computer per utilizzare
Stirling, è dare un'occhiata a Zamyla,

1158
00:56:58,500 --> 00:57:01,960
e dicendo Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
E ritorna 6.

1160
00:57:02,962 --> 00:57:04,920
La prossima volta che si chiama
dentro che per il ciclo,

1161
00:57:04,920 --> 00:57:08,610
sta andando a guardare Zamyla
di nuovo, dice Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
E sta andando a tornare 6.

1163
00:57:10,320 --> 00:57:12,980
Quindi cosa c'è di stupido in questo progetto?

1164
00:57:12,980 --> 00:57:17,700
>> Perché il mio codice non un 5 su 5
per la progettazione in questo momento, per così dire?

1165
00:57:17,700 --> 00:57:20,600
Beh, io sto chiedendo un
domanda inutilmente.

1166
00:57:20,600 --> 00:57:23,030
Sto facendo più lavoro di quanto ne ho bisogno.

1167
00:57:23,030 --> 00:57:25,370
>> Così, anche se il
risposta è corretta, io sono

1168
00:57:25,370 --> 00:57:29,560
chiedendo il computer, ciò che è
la lunghezza di Zamyla nuovo,

1169
00:57:29,560 --> 00:57:31,380
e ancora, e ancora, e ancora?

1170
00:57:31,380 --> 00:57:33,980
E la risposta è
non cambierà mai.

1171
00:57:33,980 --> 00:57:35,900
Sta andando sempre essere 6.

1172
00:57:35,900 --> 00:57:39,730
>> Quindi una soluzione migliore di questo
sarebbe questa versione successiva.

1173
00:57:39,730 --> 00:57:43,390
Lasciami andare avanti e mettere in un
file separato chiamato string1.c,

1174
00:57:43,390 --> 00:57:44,990
solo per tenerlo separato.

1175
00:57:44,990 --> 00:57:47,260
E si scopre una per
ciclo, si può effettivamente

1176
00:57:47,260 --> 00:57:50,210
dichiarare più variabili in una sola volta.

1177
00:57:50,210 --> 00:57:53,460
>> Quindi ho intenzione di tenere i e impostarlo su 0.

1178
00:57:53,460 --> 00:57:56,190
Ma sto anche andando a
aggiungere una virgola, e dire:

1179
00:57:56,190 --> 00:58:01,050
datemi una variabile chiamata n, il cui
il valore è uguale alla lunghezza della stringa di s.

1180
00:58:01,050 --> 00:58:09,410
E ora, si prega di fare la mia condizione
purché i è minore di n.

1181
00:58:09,410 --> 00:58:14,140
>> Quindi, in questo modo, la logica è
identica alla fine della giornata.

1182
00:58:14,140 --> 00:58:18,280
Ma mi ricordo il
valore 6, in questo caso.

1183
00:58:18,280 --> 00:58:19,780
Qual è la lunghezza del nome del Zamyla?

1184
00:58:19,780 --> 00:58:20,860
E sto mettendo al n.

1185
00:58:20,860 --> 00:58:23,050
>> E sto ancora controllando
la condizione ogni volta.

1186
00:58:23,050 --> 00:58:24,300
È 0 a meno di 6?

1187
00:58:24,300 --> 00:58:25,600
È 1 meno di 6?

1188
00:58:25,600 --> 00:58:28,600
È 2 inferiore a 6, e così via?

1189
00:58:28,600 --> 00:58:31,914
>> Ma io non sto chiedendo il computer
ancora, e ancora, ciò che è

1190
00:58:31,914 --> 00:58:33,080
la lunghezza del nome del Zamyla?

1191
00:58:33,080 --> 00:58:34,320
Qual è la lunghezza del nome del Zamyla?

1192
00:58:34,320 --> 00:58:35,986
Qual è la lunghezza del nome di questo Zamyla?

1193
00:58:35,986 --> 00:58:40,440
Sto letteralmente ricordando che prima e
rispondere solo in questa seconda variabile n.

1194
00:58:40,440 --> 00:58:45,280
Così questo ora sarebbe non solo
corretta, ma anche ben progettato.

1195
00:58:45,280 --> 00:58:46,670
>> Ora, per quanto riguarda lo stile?

1196
00:58:46,670 --> 00:58:48,866
Ho chiamato il mio variabili
abbastanza bene, direi.

1197
00:58:48,866 --> 00:58:50,240
Sono super succinta in questo momento.

1198
00:58:50,240 --> 00:58:52,090
E questo è tutto bene.

1199
00:58:52,090 --> 00:58:55,120
>> Se si dispone di un solo
stringa in un programma,

1200
00:58:55,120 --> 00:58:56,860
si potrebbe anche chiamare s per le stringhe.

1201
00:58:56,860 --> 00:58:59,370
Se si dispone di una sola variabile
per il conteggio in un programma,

1202
00:58:59,370 --> 00:59:00,710
si potrebbe anche chiamare i.

1203
00:59:00,710 --> 00:59:03,500
Se si dispone di una lunghezza, n
è super comune così.

1204
00:59:03,500 --> 00:59:05,800
Ma non ho commentato nessun del mio codice.

1205
00:59:05,800 --> 00:59:09,200
>> Non ho informato il reader--
se questo è il mio TF, o TA,

1206
00:59:09,200 --> 00:59:12,460
o semplicemente colleague-- ciò che si suppone
essere in corso in questo programma.

1207
00:59:12,460 --> 00:59:15,760
E così per ottenere un buon stile,
quello che vorrei fare

1208
00:59:15,760 --> 00:59:24,580
è qualcosa questo--
come chiedere all'utente per l'input.

1209
00:59:24,580 --> 00:59:26,670
E potrei riscrivere
questo numero qualsiasi di modi.

1210
00:59:26,670 --> 00:59:35,630
>> Assicurarsi S-- assicurarsi get
stringa restituita una stringa.

1211
00:59:35,630 --> 00:59:40,280
E poi in qui-- e questo è forse
il più importante iterate comment--

1212
00:59:40,280 --> 00:59:44,450
sui caratteri in s uno alla volta.

1213
00:59:44,450 --> 00:59:47,060
E potrei usare qualsiasi
scelta della lingua inglese

1214
00:59:47,060 --> 00:59:49,650
qui per descrivere ogni
di questi blocchi di codice.

1215
00:59:49,650 --> 00:59:52,740
>> Si noti che non ho messo un
commentare ogni riga di codice,

1216
00:59:52,740 --> 00:59:55,690
in realtà solo sulla interessa
quelli, quelli che

1217
00:59:55,690 --> 00:59:59,460
hanno un significato che io possa
vuole fare super-chiaro a qualcuno

1218
00:59:59,460 --> 01:00:00,460
leggere il mio codice.

1219
01:00:00,460 --> 01:00:02,920
E perché sta chiamando ottiene
stringa di chiedere all'utente per l'input?

1220
01:00:02,920 --> 01:00:05,450
Anche questo non è necessariamente
tutto questo descrittiva.

1221
01:00:05,450 --> 01:00:09,340
Ma aiuta raccontare una storia, perché la
seconda linea della storia è, assicurarsi

1222
01:00:09,340 --> 01:00:10,740
ottenere stringa restituita una stringa.

1223
01:00:10,740 --> 01:00:14,260
>> E la terza linea della storia è,
scorrere i caratteri in s uno

1224
01:00:14,260 --> 01:00:15,380
Al tempo.

1225
01:00:15,380 --> 01:00:17,920
E ora per buona misura,
Ho intenzione di andare avanti e aggiungere

1226
01:00:17,920 --> 01:00:24,560
un altro commento che solo
dice di stampa i-esimo carattere s.

1227
01:00:24,560 --> 01:00:26,520
Ora, che cosa ho fatto
alla fine del giorno?

1228
01:00:26,520 --> 01:00:29,190
>> Ho aggiunto un po 'di inglese
parole in forma di commenti.

1229
01:00:29,190 --> 01:00:32,700
Il simbolo barra barra significa, hey,
calcolatore questo è per l'essere umano,

1230
01:00:32,700 --> 01:00:33,820
non per voi, il computer.

1231
01:00:33,820 --> 01:00:35,119
Così stanno ignorati logicamente.

1232
01:00:35,119 --> 01:00:35,910
Sono solo lì.

1233
01:00:35,910 --> 01:00:39,830
>> E, in effetti, CS50 IDE mostra loro come
grigio, come utili, ma non chiave

1234
01:00:39,830 --> 01:00:41,000
al programma.

1235
01:00:41,000 --> 01:00:42,570
Si noti che cosa si può fare ora.

1236
01:00:42,570 --> 01:00:44,950
Sia che si sa C
la programmazione o no, si

1237
01:00:44,950 --> 01:00:47,722
può solo stare indietro a questo
il programma, e sfiorano i commenti.

1238
01:00:47,722 --> 01:00:50,180
Chiedi all'utente per l'input, assicurarsi
ottenere stringa restituita una stringa,

1239
01:00:50,180 --> 01:00:53,009
scorrere i caratteri in s
uno alla volta, stampare il carattere

1240
01:00:53,009 --> 01:00:55,550
i-esimo carattere in S-- non lo fai
hanno nemmeno bisogno di guardare il codice

1241
01:00:55,550 --> 01:00:57,270
per capire che cosa questo programma fa.

1242
01:00:57,270 --> 01:01:00,280
E, meglio ancora, se vi guarda
in questo programma in una settimana o due,

1243
01:01:00,280 --> 01:01:02,280
o un mese o un anno,
anche voi non avete

1244
01:01:02,280 --> 01:01:04,420
a guardare il codice,
cercando di ricordare,

1245
01:01:04,420 --> 01:01:06,630
quello che stavo cercando di fare con questo codice?

1246
01:01:06,630 --> 01:01:07,770
>> Tu stesso hai detto.

1247
01:01:07,770 --> 01:01:11,660
Hai descritto per te stesso,
o qualche collega, o TA, o TF.

1248
01:01:11,660 --> 01:01:14,860
E così se ora
corretta, e il design buono,

1249
01:01:14,860 --> 01:01:18,210
e, infine, buon stile pure.

1250
01:01:18,210 --> 01:01:19,990
Quindi, fare tenere a mente.

1251
01:01:19,990 --> 01:01:22,200
>> Quindi c'è un altro
cosa ho intenzione di fare qui

1252
01:01:22,200 --> 01:01:28,240
che ora può rivelare esattamente ciò che è
succedendo sotto il cofano.

1253
01:01:28,240 --> 01:01:30,390
Quindi c'è questa funzione
in C, e altre lingue,

1254
01:01:30,390 --> 01:01:33,010
chiamato typecasting
che o implicitamente

1255
01:01:33,010 --> 01:01:37,250
o permette esplicitamente di convertire
da un tipo ad un altro.

1256
01:01:37,250 --> 01:01:39,800
Abbiamo avuto a che fare in modo
lontano oggi con le stringhe.

1257
01:01:39,800 --> 01:01:41,250
>> E stringhe sono caratteri.

1258
01:01:41,250 --> 01:01:44,910
Ma ricordare dalla settimana
0, quali sono i personaggi?

1259
01:01:44,910 --> 01:01:49,334
I personaggi sono solo un'astrazione
in cima numeri decimali numbers--,

1260
01:01:49,334 --> 01:01:52,500
e numeri decimali sono in realtà solo un
astrazione su cima di numeri binari,

1261
01:01:52,500 --> 01:01:53,720
come lo abbiamo definito.

1262
01:01:53,720 --> 01:01:55,540
>> Così i personaggi sono numeri.

1263
01:01:55,540 --> 01:01:58,410
E i numeri sono personaggi,
solo a seconda del contesto.

1264
01:01:58,410 --> 01:02:01,250
E si scopre che al suo interno
di un programma per elaboratore,

1265
01:02:01,250 --> 01:02:06,830
si può specificare come si vuole guardare
i bit all'interno di quel programma?

1266
01:02:06,830 --> 01:02:10,400
>> Richiamo dalla settimana 0 che avevamo
Ascii, che è solo il codice

1267
01:02:10,400 --> 01:02:11,620
lettere di mappatura ai numeri.

1268
01:02:11,620 --> 01:02:13,660
E abbiamo detto, il capitale A è 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B è 66, e così via.

1270
01:02:15,860 --> 01:02:20,500
>> E notate, abbiamo essenzialmente abbiamo caratteri su
la riga superiore qui, come C li avrebbe chiamati,

1271
01:02:20,500 --> 01:02:23,400
personaggi, e poi
interi sulla seconda fila.

1272
01:02:23,400 --> 01:02:28,180
E si scopre è possibile convertire
perfettamente tra i due, tipicamente.

1273
01:02:28,180 --> 01:02:30,042
E se vogliamo fare
questo proposito, abbiamo

1274
01:02:30,042 --> 01:02:31,750
potrebbe desiderare di affrontare
qualcosa come questo.

1275
01:02:31,750 --> 01:02:33,590
>> Potremmo desidera convertire
lettere maiuscole a lettere

1276
01:02:33,590 --> 01:02:35,330
caso, o minuscolo a maiuscolo.

1277
01:02:35,330 --> 01:02:38,000
E si scopre c'è
in realtà un modello qui

1278
01:02:38,000 --> 01:02:39,900
siamo in grado di abbracciare in un attimo.

1279
01:02:39,900 --> 01:02:44,120
Ma diamo un'occhiata prima a un
Esempio di fare questo in modo esplicito.

1280
01:02:44,120 --> 01:02:46,340
>> Ho intenzione di tornare in CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Ho intenzione di creare un
file chiamato Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
E ho intenzione di andare avanti e aggiungere il mio
io.h standard al top, int void main

1283
01:02:55,960 --> 01:02:57,370
nella parte superiore della mia funzione.

1284
01:02:57,370 --> 01:03:02,700
E poi sto solo andando a fare la
following-- un ciclo for da i pari,

1285
01:03:02,700 --> 01:03:04,610
diciamo, 65.

1286
01:03:04,610 --> 01:03:10,460
>> E poi mi sta per essere inferiore a
65, oltre a 26 lettere dell'alfabeto.

1287
01:03:10,460 --> 01:03:12,640
Così vi svelo il computer
fare la matematica per me lì.

1288
01:03:12,640 --> 01:03:15,100
E poi all'interno di questo ciclo,
quello che sto andando per la stampa?

1289
01:03:15,100 --> 01:03:19,230
>> % C è% i backslash n.

1290
01:03:19,230 --> 01:03:21,290
E ora voglio collegare due valori.

1291
01:03:21,290 --> 01:03:24,530
Ho temporaneamente messo domanda
segna lì per invitare la domanda.

1292
01:03:24,530 --> 01:03:29,940
>> Voglio scorrere da 65 in poi
per 26 lettere dell'alfabeto,

1293
01:03:29,940 --> 01:03:35,190
stampando su ogni iterazione che
equivalente integrante del personaggio.

1294
01:03:35,190 --> 01:03:38,299
In altre parole, voglio
iterare stampa oltre 26 numeri

1295
01:03:38,299 --> 01:03:41,590
ciò che il carattere ASCII è, alla lettera,
e ciò che il numero corrispondente è--

1296
01:03:41,590 --> 01:03:44,650
in realtà solo ricreando
il grafico da quella diapositiva.

1297
01:03:44,650 --> 01:03:47,010
Così che cosa dovrebbero questi punti interrogativi essere?

1298
01:03:47,010 --> 01:03:51,760
>> Beh, si scopre che il secondo
uno dovrebbe essere solo la variabile i.

1299
01:03:51,760 --> 01:03:53,860
Voglio vedere che come un numero.

1300
01:03:53,860 --> 01:03:58,920
E l'argomento centrale
qui, posso dire al computer

1301
01:03:58,920 --> 01:04:03,470
per il trattamento di tale intero
i come un personaggio, così come

1302
01:04:03,470 --> 01:04:05,880
per sostituirlo qui per cento C.

1303
01:04:05,880 --> 01:04:07,990
>> In altre parole, se la
programmatore umano, sapere

1304
01:04:07,990 --> 01:04:09,865
questi sono solo numeri
alla fine del giorno.

1305
01:04:09,865 --> 01:04:12,500
E so che il 65 dovrebbe
mappa di qualche personaggio.

1306
01:04:12,500 --> 01:04:15,310
Con questo cast esplicito,
con una parentesi,

1307
01:04:15,310 --> 01:04:18,840
il nome del tipo di dati che si desidera
convertire, e una parentesi chiusa,

1308
01:04:18,840 --> 01:04:21,200
si può dire la
calcolatore, ehi, computer,

1309
01:04:21,200 --> 01:04:24,130
convertire questo intero in un char.

1310
01:04:24,130 --> 01:04:26,250
>> Così, quando ho eseguito questo
programma dopo la compilazione,

1311
01:04:26,250 --> 01:04:29,740
vediamo quello che faccio get-- ASCII 0.

1312
01:04:29,740 --> 01:04:33,020
Maledizione, che cosa ho fatto di sbagliato qui?

1313
01:04:33,020 --> 01:04:35,884
Utilizzare di identificatore non dichiarato,
Va bene, non è intenzionale,

1314
01:04:35,884 --> 01:04:37,800
ma vediamo se non possiamo
ragione per questo.

1315
01:04:37,800 --> 01:04:41,220
>> Così la linea five-- così non ho avuto
molto lontano prima di avvitare.

1316
01:04:41,220 --> 01:04:42,140
Va bene.

1317
01:04:42,140 --> 01:04:46,560
Così la linea 5 per i uguale 65-- vedo.

1318
01:04:46,560 --> 01:04:50,130
Quindi ricorda che in C, a differenza
lingue, se si dispone di programmazione precedente

1319
01:04:50,130 --> 01:04:52,190
esperienza, si ha
per dire al computer,

1320
01:04:52,190 --> 01:04:55,040
a differenza di Scratch, cosa
tipo di variabile è.

1321
01:04:55,040 --> 01:04:56,860
>> E ho dimenticato una frase chiave qui.

1322
01:04:56,860 --> 01:04:59,200
In linea cinque, ho iniziato ad usare i.

1323
01:04:59,200 --> 01:05:01,560
Ma io non ho detto C
quali dati tipo si tratta.

1324
01:05:01,560 --> 01:05:04,570
Quindi ho intenzione di andare qui e
dire, ah, lo rendono un numero intero.

1325
01:05:04,570 --> 01:05:07,050
>> Ora ho intenzione di andare avanti e ricompilare.

1326
01:05:07,050 --> 01:05:08,080
Quello fisso che.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, che è genere di freddo.

1328
01:05:12,660 --> 01:05:15,360
Non solo è super veloce per
chiedere al computer a questa domanda,

1329
01:05:15,360 --> 01:05:18,885
piuttosto che guardare in su su una diapositiva,
è stampato uno per riga, A è 65,

1330
01:05:18,885 --> 01:05:24,860
B è 66, tutta la strada da quando ho down--
fatto questo 26 times-- alle lettere Z,

1331
01:05:24,860 --> 01:05:25,630
che è 90.

1332
01:05:25,630 --> 01:05:27,790
E, infatti, leggermente
più intelligente sarebbe

1333
01:05:27,790 --> 01:05:31,030
sono stati per me non fare affidamento
sul computer per aggiungere 26.

1334
01:05:31,030 --> 01:05:34,060
Avrei potuto appena fatto
90 così, così a lungo

1335
01:05:34,060 --> 01:05:37,390
come io non faccio lo stesso errore due volte.

1336
01:05:37,390 --> 01:05:41,880
Voglio andare attraverso
z, non solo attraverso y.

1337
01:05:41,880 --> 01:05:44,000
>> Ecco, questo è un cast esplicito.

1338
01:05:44,000 --> 01:05:47,860
Si scopre che questo
Non è nemmeno necessario.

1339
01:05:47,860 --> 01:05:52,480
Lasciami andare avanti e di eseguire nuovamente questo
compilatore, ed eseguire nuovamente Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Si scopre che C è abbastanza intelligente.

1341
01:05:54,940 --> 01:05:57,150
>> E printf, in particolare,
è piuttosto intelligente.

1342
01:05:57,150 --> 01:06:01,260
Se hai appena passa un i due volte
per entrambi i segnaposto, printf

1343
01:06:01,260 --> 01:06:04,510
si renderà conto, oh, beh io ti conosco
mi ha dato un integer-- qualche numero,

1344
01:06:04,510 --> 01:06:06,380
come 65, o 90, o qualsiasi altra cosa.

1345
01:06:06,380 --> 01:06:10,170
Ma vedo che mi vuoi
formattare quel numero come un personaggio.

1346
01:06:10,170 --> 01:06:16,460
E così printf può implicitamente espressi
int a un char per voi pure.

1347
01:06:16,460 --> 01:06:19,360
Quindi questo non è affatto un problema.

1348
01:06:19,360 --> 01:06:23,100
>> Ma bando, a causa di questa equivalenza
possiamo effettivamente fare anche questo.

1349
01:06:23,100 --> 01:06:26,520
Mi permetta di andare avanti e fare una
altra versione di questo-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
E invece di iterare su
interi, può davvero a bocca aperta

1351
01:06:31,800 --> 01:06:33,610
per iterare su caratteri.

1352
01:06:33,610 --> 01:06:37,660
Se un char c ottiene maiuscola, ho
voglia di andare avanti e fare questo,

1353
01:06:37,660 --> 01:06:41,740
purché C è inferiore o uguale
alla Z. capitale e ad ogni iterazione

1354
01:06:41,740 --> 01:06:45,690
Voglio incrementare C, posso
ora nella mia linea printf qui

1355
01:06:45,690 --> 01:06:51,320
per esempio, cento C è
cento Ho di nuovo, comma C.

1356
01:06:51,320 --> 01:06:57,200
>> E ora, posso andare nella direzione opposta,
gettando il carattere esplicitamente

1357
01:06:57,200 --> 01:06:58,500
a un numero intero.

1358
01:06:58,500 --> 01:07:00,560
Così, ancora una volta, perché vorresti fare questo?

1359
01:07:00,560 --> 01:07:03,830
E 'un po' strano per ordinare di
contare in termini di caratteri.

1360
01:07:03,830 --> 01:07:07,430
>> Ma se si capisce che cosa è
succedendo sotto il cofano,

1361
01:07:07,430 --> 01:07:08,430
non c'è davvero nessuna magia.

1362
01:07:08,430 --> 01:07:13,060
Stai solo dicendo, hey, computer di dare
me una variabile denominata C di tipo char.

1363
01:07:13,060 --> 01:07:16,520
Inizializzarlo al capitale A. E
notare singola materia citazioni.

1364
01:07:16,520 --> 01:07:19,580
>> Per i caratteri in C, ricordare da
la scorsa settimana, è possibile utilizzare le virgolette singole.

1365
01:07:19,580 --> 01:07:23,720
Per le stringhe, per le parole,
frasi, è usare le virgolette.

1366
01:07:23,720 --> 01:07:27,210
OK, computer, continuare a fare questo, in modo da
fino a quando il personaggio è inferiore

1367
01:07:27,210 --> 01:07:28,050
o uguale a z.

1368
01:07:28,050 --> 01:07:32,640
E so dalla mia tabella ASCII che tutti
di questi codici ASCII sono contigue.

1369
01:07:32,640 --> 01:07:33,400
>> Ci sono lacune.

1370
01:07:33,400 --> 01:07:36,737
Quindi è solo da A a Z,
separati da un numero ciascuno.

1371
01:07:36,737 --> 01:07:38,820
E allora posso incrementare
un char, se voglio davvero.

1372
01:07:38,820 --> 01:07:40,390
Alla fine del giorno,
è solo un numero.

1373
01:07:40,390 --> 01:07:41,030
Lo so.

1374
01:07:41,030 --> 01:07:43,670
Quindi posso solo presumere di aggiungere 1 ad esso.

1375
01:07:43,670 --> 01:07:46,940
>> E poi questa volta, a stampare C,
e poi l'equivalente integrale.

1376
01:07:46,940 --> 01:07:50,170
E non ho nemmeno bisogno del cast esplicito.

1377
01:07:50,170 --> 01:07:52,680
Posso lasciare printf e la
cose figura computer fuori,

1378
01:07:52,680 --> 01:07:57,300
così che ora, se corro
fare Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Ho la stessa cosa pure.

1380
01:08:01,520 --> 01:08:04,530
>> programma inutile, though-- nessuno
sta per scrivere in realtà il software

1381
01:08:04,530 --> 01:08:07,549
al fine di capire, quello che era il
numero che mappa di A o B o Z?

1382
01:08:07,549 --> 01:08:10,340
Si sta solo andando a google, o
cercarlo on-line, o cercarlo

1383
01:08:10,340 --> 01:08:11,650
su un vetrino, o simili.

1384
01:08:11,650 --> 01:08:13,520
Perché allora questa effettivamente ottenere utile?

1385
01:08:13,520 --> 01:08:15,960
>> Beh, parlando di quel
scivolo, notare non c'è

1386
01:08:15,960 --> 01:08:20,890
un andamento reale qui tra lettere maiuscole
e minuscole che non è stata casuale.

1387
01:08:20,890 --> 01:08:23,760
Si noti che il capitale A è 65.

1388
01:08:23,760 --> 01:08:25,830
Minuscole a è 97.

1389
01:08:25,830 --> 01:08:29,649
E quanto lontano si trova un minuscolo?

1390
01:08:29,649 --> 01:08:32,649
>> Così 65 è il numero di passi da 97?

1391
01:08:32,649 --> 01:08:36,210
Così 97 meno 65 è 32.

1392
01:08:36,210 --> 01:08:37,910
Così il capitale a è 65.

1393
01:08:37,910 --> 01:08:39,939
Se si aggiungono 32 che,
si ottiene un minuscole.

1394
01:08:39,939 --> 01:08:43,729
E, in modo equivalente, se si sottrae 32,
si ritorna al capitale A-- stesso con B

1395
01:08:43,729 --> 01:08:46,380
a poca B, grande C a poco c.

1396
01:08:46,380 --> 01:08:50,670
>> Tutte queste lacune sono 32 pezzi.

1397
01:08:50,670 --> 01:08:54,450
Ora, ciò sembrerebbe ci permettono di
fare qualcosa come Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
o Google Docs caratteristica, in cui si
è possibile selezionare tutto e poi dire,

1399
01:08:57,729 --> 01:09:00,520
cambiare tutto in minuscolo, o
cambiare tutto in lettere maiuscole,

1400
01:09:00,520 --> 01:09:03,840
o modificare solo la prima parola
di una frase in lettere maiuscole.

1401
01:09:03,840 --> 01:09:07,390
Siamo in grado di fare qualcosa di concreto
così noi stessi.

1402
01:09:07,390 --> 01:09:12,645
>> Lasciami andare avanti e salvare un file
qui chiamato capitalizzare 0.c.

1403
01:09:12,645 --> 01:09:15,770
E andiamo avanti e improvvisare un programma
che fa esattamente questo come segue.

1404
01:09:15,770 --> 01:09:18,460
Quindi includere la libreria CS50.

1405
01:09:18,460 --> 01:09:21,430
E comprende I / O standard.

1406
01:09:21,430 --> 01:09:22,787
>> E so che questo sarà presto disponibile.

1407
01:09:22,787 --> 01:09:24,870
Quindi ho intenzione di mettere in
c'è già, string.h,

1408
01:09:24,870 --> 01:09:26,960
così ho accesso a
cose come Stirling,

1409
01:09:26,960 --> 01:09:29,620
quindi int void main, come al solito.

1410
01:09:29,620 --> 01:09:33,420
E poi ho intenzione di andare avanti
e fare le stringhe ottiene ottenere stringa,

1411
01:09:33,420 --> 01:09:35,032
solo per ottenere una stringa dall'utente.

1412
01:09:35,032 --> 01:09:36,740
E poi ho intenzione di
fare il mio controllo di integrità.

1413
01:09:36,740 --> 01:09:40,510
Se la stringa non è uguale null,
allora è sicuro di procedere.

1414
01:09:40,510 --> 01:09:42,000
E quello che voglio fare?

1415
01:09:42,000 --> 01:09:48,700
Io vado a scorrere da i uguale a 0,
e n fino alla lunghezza della stringa di s.

1416
01:09:48,700 --> 01:09:51,899
>> E ho intenzione di fare questo a condizione che
i è inferiore a n, e io plus plus.

1417
01:09:51,899 --> 01:09:55,060
Finora, sono davvero solo
prendendo in prestito le idee da prima.

1418
01:09:55,060 --> 01:09:57,010
E ora ho intenzione di introdurre un ramo.

1419
01:09:57,010 --> 01:09:59,635
>> Quindi, pensare di nuovo a Scratch, dove
abbiamo avuto quei forchette in mezzo alla strada,

1420
01:09:59,635 --> 01:10:05,110
e la settimana scorsa in C. ho intenzione di
dirlo, se il carattere i-esimo in s

1421
01:10:05,110 --> 01:10:09,250
è maggiore di o
pari a minuscole a,

1422
01:10:09,250 --> 01:10:13,340
e- in Scratch si farebbe letteralmente
dici e, ma in C che dici e commerciale,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- e il carattere i-esimo in s
è inferiore o uguale a minuscole z,

1424
01:10:19,830 --> 01:10:21,780
facciamo qualcosa di interessante.

1425
01:10:21,780 --> 01:10:27,020
Facciamo in realtà stampare una
personaggio senza ritorno a capo

1426
01:10:27,020 --> 01:10:31,760
che è il carattere della stringa,
il carattere i-esimo nella stringa.

1427
01:10:31,760 --> 01:10:37,420
>> Ma andiamo avanti e
sottrarre 32 da esso.

1428
01:10:37,420 --> 01:10:42,120
Altrimenti, se il personaggio in
stringa che stiamo cercando

1429
01:10:42,120 --> 01:10:45,950
non è tra poco un
e poco z, andare avanti

1430
01:10:45,950 --> 01:10:48,610
e appena stampato fuori invariato.

1431
01:10:48,610 --> 01:10:50,840
Così abbiamo introdotto
questa notazione tra parentesi

1432
01:10:50,840 --> 01:10:53,560
per le nostre corde per arrivare al
i-esimo carattere della stringa.

1433
01:10:53,560 --> 01:10:57,520
>> Ho aggiunto un po 'di logica condizionale, come
Scratch in della scorsa settimana prima settimana, dove

1434
01:10:57,520 --> 01:10:59,880
Sto solo usando il mio fondamentale
comprensione di ciò che è

1435
01:10:59,880 --> 01:11:01,130
succedendo sotto il cofano.

1436
01:11:01,130 --> 01:11:04,190
Il personaggio è i-esimo di s
maggiore o uguale ad un?

1437
01:11:04,190 --> 01:11:08,290
Come, è 97, o 98,
o 99, e così via?

1438
01:11:08,290 --> 01:11:11,940
>> Ma è anche minore o uguale
al valore di z minuscola?

1439
01:11:11,940 --> 01:11:16,210
E se è così, che cosa significa questa linea?

1440
01:11:16,210 --> 01:11:20,250
14, questa è una sorta di
germe di tutta l'idea,

1441
01:11:20,250 --> 01:11:23,840
maiuscolo la lettera da
semplicemente sottraendo 32 da esso,

1442
01:11:23,840 --> 01:11:29,370
in questo caso, perché so, per quello
grafico, come i miei numeri sono rappresentati.

1443
01:11:29,370 --> 01:11:33,925
Quindi cerchiamo di andare avanti ed eseguire questo,
dopo la compilazione capitalizzare 0.c,

1444
01:11:33,925 --> 01:11:36,210
ed eseguire capitalizzare 0.

1445
01:11:36,210 --> 01:11:40,300
>> Facciamo digitare qualcosa di simile
Zamyla in tutto minuscolo entrare.

1446
01:11:40,300 --> 01:11:42,780
E ora abbiamo Zamyla in maiuscolo.

1447
01:11:42,780 --> 01:11:45,050
Facciamo digitare Rob in lettere minuscole.

1448
01:11:45,050 --> 01:11:46,674
Proviamo Jason in lettere minuscole.

1449
01:11:46,674 --> 01:11:48,590
E continuiamo ricevendo il
capitalizzazione forzata.

1450
01:11:48,590 --> 01:11:50,960
C'è un bug minore che ho
tipo di non anticipare.

1451
01:11:50,960 --> 01:11:54,050
Il mio nuovo prompt è di finire
sulla stessa linea come i loro nomi,

1452
01:11:54,050 --> 01:11:55,520
che si sente un po 'disordinato.

1453
01:11:55,520 --> 01:11:59,170
>> Quindi ho intenzione di andare qui, e
sino alla fine di questo programma

1454
01:11:59,170 --> 01:12:02,110
stampare un carattere di nuova riga.

1455
01:12:02,110 --> 01:12:03,160
È tutto.

1456
01:12:03,160 --> 01:12:06,120
Con printf, non è necessario per
passare variabili o codice del formato.

1457
01:12:06,120 --> 01:12:08,460
Si può letteralmente stampare
qualcosa di simile a una nuova riga.

1458
01:12:08,460 --> 01:12:13,529
>> Quindi cerchiamo di andare avanti e fare
capitalizzare ancora 0, eseguire nuovamente esso, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
E ora è un po 'più bello.

1460
01:12:14,820 --> 01:12:17,274
Ora, il mio prompt è sulla propria nuova linea.

1461
01:12:17,274 --> 01:12:18,440
Ecco, questo è tutto bello e buono.

1462
01:12:18,440 --> 01:12:19,910
Ecco, questo è un buon esempio.

1463
01:12:19,910 --> 01:12:22,700
Ma io non so nemmeno necessariamente
necessità di codificare il 32.

1464
01:12:22,700 --> 01:12:23,350
Sai cosa?

1465
01:12:23,350 --> 01:12:26,350
Potrei say-- non lo faccio mai
ricordare quale sia la differenza.

1466
01:12:26,350 --> 01:12:29,330
>> Ma so che se mi
avere una lettera minuscola,

1467
01:12:29,330 --> 01:12:34,430
Io essenzialmente da sottrarre off
qualunque sia la distanza è fra poco

1468
01:12:34,430 --> 01:12:39,160
un grande e A, perché se suppongo che
tutte le altre lettere sono gli stessi,

1469
01:12:39,160 --> 01:12:41,045
che dovrebbe ottenere il lavoro fatto.

1470
01:12:41,045 --> 01:12:42,670
Ma piuttosto che farlo, sai una cosa?

1471
01:12:42,670 --> 01:12:44,240
C'è un altro modo ancora.

1472
01:12:44,240 --> 01:12:48,090
>> Se questo è capitalizzare 1.c-- se fossi
Per mettere in un file separato.

1473
01:12:48,090 --> 01:12:51,030
Facciamo capitalizzare 2.c come segue.

1474
01:12:51,030 --> 01:12:53,060
Ho intenzione di pulire davvero questo qui.

1475
01:12:53,060 --> 01:12:57,420
E invece di dover nemmeno
sapere o cura di quelli di basso livello

1476
01:12:57,420 --> 01:13:01,090
dettagli di implementazione, io sono invece
solo andando a stampare un carattere,

1477
01:13:01,090 --> 01:13:04,610
tra virgolette, per cento C, e
quindi chiamare un'altra funzione che

1478
01:13:04,610 --> 01:13:09,950
esiste che prende un argomento,
che è un personaggio, come questo.

1479
01:13:09,950 --> 01:13:12,630
>> Si scopre in C, non c'è
un'altra chiamata di funzione

1480
01:13:12,630 --> 01:13:15,550
alla tomaia, che come il suo nome
suggerisce prende un carattere

1481
01:13:15,550 --> 01:13:19,350
e rende la sua maiuscolo
equivalente, e poi lo restituisce

1482
01:13:19,350 --> 01:13:21,410
in modo che printf può collegare in là.

1483
01:13:21,410 --> 01:13:25,484
E così, per fare questo, però,
necessità di introdurre un altro file.

1484
01:13:25,484 --> 01:13:28,400
Si scopre c'è un altro file
che si dovrebbe conoscere solo dalla classe,

1485
01:13:28,400 --> 01:13:33,020
o un libro di testo, o online
di riferimento, chiamato type.h. C

1486
01:13:33,020 --> 01:13:38,570
>> Quindi, se aggiungo che in mezzo il mio colpo di testa
file, e ora ri-compilare questo programma,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Invio.

1488
01:13:43,040 --> 01:13:46,690
Facciamo digitare in Zamyla in tutta
minuscolo, funziona ancora lo stesso.

1489
01:13:46,690 --> 01:13:48,040
Ma sai una cosa?

1490
01:13:48,040 --> 01:13:55,590
Si scopre che a superiore
ha alcune altre funzionalità.

1491
01:13:55,590 --> 01:13:58,410
>> E mi permetta di introdurre questo
comandare qui, una sorta di maldestramente

1492
01:13:58,410 --> 01:14:00,250
di nome, ma l'uomo per manuale.

1493
01:14:00,250 --> 01:14:03,960
Si scopre che la maggior parte dei computer Linux,
come stiamo usando qui-- operativo Linux

1494
01:14:03,960 --> 01:14:06,270
system-- avere un comando
chiamato uomo, che dice:

1495
01:14:06,270 --> 01:14:08,530
Hey, computer, dammi
manuale del computer.

1496
01:14:08,530 --> 01:14:10,680
cosa vuoi
guardare in quella manuale?

1497
01:14:10,680 --> 01:14:13,840
>> Voglio guardare la funzione
chiamato a superiore, Invio.

1498
01:14:13,840 --> 01:14:16,070
Ed è un po 'criptico
di leggere a volte.

1499
01:14:16,070 --> 01:14:18,780
Ma notiamo che siamo in
il manuale del programmatore Linux.

1500
01:14:18,780 --> 01:14:19,530
Ed è tutto il testo.

1501
01:14:19,530 --> 01:14:21,905
E notare che c'è la
nome della funzione qui.

1502
01:14:21,905 --> 01:14:25,030
Si scopre che ha un cugino chiamato
per abbassare, che fa il contrario.

1503
01:14:25,030 --> 01:14:29,710
E notate sotto sinossi, per utilizzare questo
funzionare la pagina man, per così dire,

1504
01:14:29,710 --> 01:14:32,220
Mi sta dicendo che ho
bisogno di includere c type.h.

1505
01:14:32,220 --> 01:14:33,630
E sapevo che dalla pratica.

1506
01:14:33,630 --> 01:14:36,210
>> Qui, si sta mostrando me i due
prototipi per la funzione,

1507
01:14:36,210 --> 01:14:39,070
in modo tale che se mai voglio usare questo
So quello che prendono come input,

1508
01:14:39,070 --> 01:14:40,652
e ciò che tornano come output.

1509
01:14:40,652 --> 01:14:42,360
E poi se ho letto
la descrizione, vedo

1510
01:14:42,360 --> 01:14:44,820
più in dettaglio le operazioni da essa.

1511
01:14:44,820 --> 01:14:48,100
Ma soprattutto, se
Guardo sotto il valore di ritorno,

1512
01:14:48,100 --> 01:14:51,710
si dice che il valore restituito è
quello della lettera convertito,

1513
01:14:51,710 --> 01:14:57,880
o C, l'ingresso originale, se
la conversione non era possibile.

1514
01:14:57,880 --> 01:15:01,992
>> In altre parole, per superiore cercherà
per convertire una lettera in maiuscolo.

1515
01:15:01,992 --> 01:15:03,450
E se sì, sta andando a restituirlo.

1516
01:15:03,450 --> 01:15:07,010
Ma se non può per qualche reason--
forse è comunque già alto,

1517
01:15:07,010 --> 01:15:09,550
forse è un punto esclamativo
o qualche altro punctuation--

1518
01:15:09,550 --> 01:15:12,200
è solo andare a
restituire l'originale C,

1519
01:15:12,200 --> 01:15:17,340
che significa che posso fare il mio codice
meglio progettati come segue.

1520
01:15:17,340 --> 01:15:20,580
>> Non ho bisogno di tutti
queste righe di codice maledettamente.

1521
01:15:20,580 --> 01:15:22,610
Tutte le linee che ho
appena evidenziata può

1522
01:15:22,610 --> 01:15:28,700
essere collassato in un solo semplice
la linea, che è questo-- printf per cento

1523
01:15:28,700 --> 01:15:33,510
c per S staffa superiore i.

1524
01:15:33,510 --> 01:15:36,090
E questo sarebbe un
esempio di una migliore progettazione.

1525
01:15:36,090 --> 01:15:40,040
>> Perché implementare in 7 o 8 linee
di codice, qualunque cosa fosse ho appena

1526
01:15:40,040 --> 01:15:44,960
eliminati, quando si può invece collassare
tutto questo la logica e il processo decisionale

1527
01:15:44,960 --> 01:15:49,620
in un'unica linea, 13 oggi, che
si basa su una libreria function--

1528
01:15:49,620 --> 01:15:53,430
una funzione che viene con C, ma che
fa esattamente quello che vuoi che faccia.

1529
01:15:53,430 --> 01:15:55,295
E, francamente, anche se
non è venuto con C,

1530
01:15:55,295 --> 01:15:58,880
si potrebbe implementare da soli, come
abbiamo visto, con get int negativo

1531
01:15:58,880 --> 01:16:01,700
e ottenere positivi int scorsa settimana pure.

1532
01:16:01,700 --> 01:16:03,470
>> Questo codice è ora molto più leggibile.

1533
01:16:03,470 --> 01:16:06,670
E, in effetti, se si scorrere verso l'alto,
guardare quanto più compatta

1534
01:16:06,670 --> 01:16:08,360
questa versione del mio programma è.

1535
01:16:08,360 --> 01:16:11,230
E 'un po' pesante in alto ora,
con tutti questi include.

1536
01:16:11,230 --> 01:16:14,380
Ma va bene, perché ora sto in piedi
sulle spalle dei programmatori

1537
01:16:14,380 --> 01:16:15,300
prima di me.

1538
01:16:15,300 --> 01:16:18,440
E chiunque fosse che
attuate per davvero superiore

1539
01:16:18,440 --> 01:16:21,470
mi ha fatto un favore, proprio come chiunque
implementato Stirling davvero

1540
01:16:21,470 --> 01:16:24,790
mi ha fatto un favore a qualche tempo fa.

1541
01:16:24,790 --> 01:16:26,970
E così ora abbiamo un
migliore programma di progettazione

1542
01:16:26,970 --> 01:16:31,680
che implementa la stessa logica.

1543
01:16:31,680 --> 01:16:35,580
>> Parlando di Stirling, lascia
me andare avanti e fare questo.

1544
01:16:35,580 --> 01:16:38,320
Lasciami andare avanti e salvare
questo file come stirling.c.

1545
01:16:38,320 --> 01:16:43,255
E si scopre, siamo in grado di buccia indietro
un altro strato abbastanza semplice ora.

1546
01:16:43,255 --> 01:16:45,630
Ho intenzione di andare avanti e frusta
un altro programma principale

1547
01:16:45,630 --> 01:16:49,759
qui che semplicemente ri-attrezzi
lunghezza della stringa come segue.

1548
01:16:49,759 --> 01:16:52,300
Quindi, ecco una riga di codice che
mi viene una stringa da parte dell'utente.

1549
01:16:52,300 --> 01:16:53,910
Noi continuiamo a utilizzare ancora e ancora questo.

1550
01:16:53,910 --> 01:16:58,900
Permettetemi di fare io stesso una variabile chiamata
n di tipo int che memorizza un numero.

1551
01:16:58,900 --> 01:17:02,490
>> E mi permetta di andare avanti e
fare la seguente logica.

1552
01:17:02,490 --> 01:17:15,610
Mentre il carattere n-esimo s fa
è uguale a 0 backslash, andare avanti

1553
01:17:15,610 --> 01:17:17,930
e incrementare n.

1554
01:17:17,930 --> 01:17:23,506
E poi stampare printf per cento i n.

1555
01:17:23,506 --> 01:17:29,200
Io sostengo che questo programma,
senza chiamare lunghezza della stringa,

1556
01:17:29,200 --> 01:17:31,150
le figure la lunghezza di una stringa.

1557
01:17:31,150 --> 01:17:34,600
>> E la magia è del tutto
incapsulato in linea 8

1558
01:17:34,600 --> 01:17:39,830
qui con quello che sembra nuova sintassi,
questa barra inversa 0 tra apici.

1559
01:17:39,830 --> 01:17:41,360
Ma perché?

1560
01:17:41,360 --> 01:17:44,100
Beh, prendere in considerazione ciò che è stato
succede tutto questo tempo.

1561
01:17:44,100 --> 01:17:47,990
>> E come un a parte prima che mi dimentichi, realizzare
Anche, che oltre alle pagine man

1562
01:17:47,990 --> 01:17:50,920
che vengono con un tipico
sistema Linux come CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
rendersi conto che noi, la
il personale del corso, hanno anche

1564
01:17:53,770 --> 01:17:56,030
fatto una versione del sito
di questa stessa idea chiamata

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, che ha
tutte quelle stesse pagine man,

1566
01:17:59,940 --> 01:18:02,020
tutte dello stesso
documentazione, nonché

1567
01:18:02,020 --> 01:18:05,730
una piccola scatola in alto che permette
di convertire tutto il abbastanza

1568
01:18:05,730 --> 01:18:09,025
linguaggio arcano in meno confortevole
Modalità, dove, il personale docente,

1569
01:18:09,025 --> 01:18:12,150
hanno attraversato e cercato di semplificare
alcuni di lingua per mantenere le cose

1570
01:18:12,150 --> 01:18:14,830
focalizzato sulle idee, e non
alcuni degli aspetti tecnici.

1571
01:18:14,830 --> 01:18:20,070
Quindi, tenere a mente, reference.cs50.net
come un'altra risorsa come bene.

1572
01:18:20,070 --> 01:18:23,800
>> Ma perché funziona lunghezza della stringa in
il modo in cui ho proposto un momento fa?

1573
01:18:23,800 --> 01:18:25,160
Ecco di nuovo il nome di Zamyla.

1574
01:18:25,160 --> 01:18:27,690
Ed ecco il nome di Zamyla
inscatolato in, come continuo a fare,

1575
01:18:27,690 --> 01:18:31,360
a dipingere un quadro di esso che è,
in realtà, solo una sequenza di caratteri.

1576
01:18:31,360 --> 01:18:34,260
Ma Zamyla non esiste
in isolamento in un programma.

1577
01:18:34,260 --> 01:18:37,420
>> Quando si scrive e si esegue un programma,
si sta utilizzando il vostro Mac o PC

1578
01:18:37,420 --> 01:18:40,010
come memoria o RAM per così dire.

1579
01:18:40,010 --> 01:18:42,620
E si può pensare di
il computer come avere

1580
01:18:42,620 --> 01:18:44,730
un sacco di gigabyte di memoria in questi giorni.

1581
01:18:44,730 --> 01:18:47,700
E un concerto significa miliardi,
così miliardi di byte.

1582
01:18:47,700 --> 01:18:48,910
>> Ma andiamo riavvolgere nel tempo.

1583
01:18:48,910 --> 01:18:51,530
E supponiamo che stiamo usando
un computer molto vecchio che

1584
01:18:51,530 --> 01:18:55,150
ha solo 32 byte di memoria.

1585
01:18:55,150 --> 01:18:59,310
Ho potuto, sullo schermo del computer,
semplicemente disegnare questo come segue.

1586
01:18:59,310 --> 01:19:05,240
>> Potrei semplicemente dire che la mia
computer possieda tutto questa memoria.

1587
01:19:05,240 --> 01:19:08,830
E questo è come un bastone di memoria, se
vi ricordate la nostra immagine dall'ultima volta.

1588
01:19:08,830 --> 01:19:11,670
E se ho appena divido
questo in tempi abbastanza,

1589
01:19:11,670 --> 01:19:15,040
Io affermo che ho 32 byte
della memoria sullo schermo.

1590
01:19:15,040 --> 01:19:18,239
>> Ora, in realtà, posso solo
disegnare finora in questa schermata qui.

1591
01:19:18,239 --> 01:19:20,280
Quindi ho intenzione di andare avanti,
e solo per convenzione,

1592
01:19:20,280 --> 01:19:24,050
tracciare la memoria del mio computer come un
griglia, non solo come una linea retta.

1593
01:19:24,050 --> 01:19:28,190
In particolare, io sostengo che ora
questa griglia, questo 8 per 4 griglia,

1594
01:19:28,190 --> 01:19:31,800
solo rappresenta tutti i 32 byte
di memoria disponibile nel mio Mac,

1595
01:19:31,800 --> 01:19:33,030
o disponibili nel mio PC.

1596
01:19:33,030 --> 01:19:34,780
E stanno avvolgendo
a due linee, basta

1597
01:19:34,780 --> 01:19:38,030
perché si adatta di più sullo schermo.

1598
01:19:38,030 --> 01:19:40,800
Ma questo è il primo byte.

1599
01:19:40,800 --> 01:19:41,990
Questo è il secondo byte.

1600
01:19:41,990 --> 01:19:43,300
Questo è il terzo byte.

1601
01:19:43,300 --> 01:19:45,310
>> E questo è il byte 32 °.

1602
01:19:45,310 --> 01:19:52,910
Oppure, se pensiamo come un computer
scienziato, questo è byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
In modo da avere da 0 a 31, se
si inizia a contare a 0.

1604
01:19:55,950 --> 01:19:59,830
>> Quindi, se usiamo un programma
che le chiamate ottengono stringa,

1605
01:19:59,830 --> 01:20:05,280
e otteniamo una stringa dall'umano
come ho chiamato Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
come nel mondo fa la
pista computer a evitare di cui Byte,

1607
01:20:09,430 --> 01:20:12,230
che pezzo di memoria,
appartiene alla quale stringa?

1608
01:20:12,230 --> 01:20:16,270
In altre parole, se si procede a
digitare un altro nome al computer,

1609
01:20:16,270 --> 01:20:19,890
come questo Andi, chiamando
ottenere stringa una seconda volta,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I deve finire nel
memoria del computer come bene.

1611
01:20:23,030 --> 01:20:23,850
Ma come?

1612
01:20:23,850 --> 01:20:29,700
>> Beh, si scopre che sotto la
Cappuccio, cosa C fa quando la memorizzazione di stringhe

1613
01:20:29,700 --> 01:20:35,080
che i tipi umani, o che
provengono da qualche altra fonte, è

1614
01:20:35,080 --> 01:20:39,190
delinea la fine del loro
una speciale barra rovesciata character--

1615
01:20:39,190 --> 01:20:44,750
0, che è solo un modo speciale
di dire 80 bit di fila.

1616
01:20:44,750 --> 01:20:47,950
>> Così A-- questo è il richiamo il numero 97.

1617
01:20:47,950 --> 01:20:51,770
Così alcuni reticolo di 8 bit
rappresenta numero decimale 97.

1618
01:20:51,770 --> 01:20:58,070
Questo backslash 0 è letteralmente il numero
0, nul pseudonimo, N-U-L, a differenza di prima,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, di cui abbiamo parlato.

1620
01:20:59,630 --> 01:21:05,700
Ma per ora, è sufficiente sapere che questo
backslash 0 a soli 80 bit di fila.

1621
01:21:05,700 --> 01:21:09,810
>> Ed è proprio questa riga nel
sabbia che dice qualcosa di sinistra

1622
01:21:09,810 --> 01:21:12,610
appartiene a una stringa o un tipo di dati.

1623
01:21:12,610 --> 01:21:15,480
E tutto ciò a destra
appartiene a qualcos'altro.

1624
01:21:15,480 --> 01:21:17,440
Andi del nome, nel frattempo,
che solo visivamente

1625
01:21:17,440 --> 01:21:21,310
accade per avvolgere sulla all'altra linea,
ma questo è solo un dettaglio estetico,

1626
01:21:21,310 --> 01:21:23,990
Allo stesso modo è nul terminata.

1627
01:21:23,990 --> 01:21:29,290
>> Si tratta di una stringa di caratteri a A-N-D-I,
più un quinto personaggio segreto,

1628
01:21:29,290 --> 01:21:33,560
tutti i 0 bit, che delimita solo
Alla fine del nome di Andi pure.

1629
01:21:33,560 --> 01:21:37,120
E se chiamiamo ottenere stringa per la terza volta
nel computer per ottenere una stringa come

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, similmente è Maria
Nome nul terminato con backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Questo è fondamentalmente diverso
dal modo in cui un computer sarebbe tipicamente

1632
01:21:47,170 --> 01:21:51,850
memorizzare un numero intero o un galleggiante, o altro
i tipi di dati ancora, perché il richiamo,

1633
01:21:51,850 --> 01:21:57,420
un intero è di solito 32 bit, o
4 byte, o forse anche 64 bit,

1634
01:21:57,420 --> 01:21:59,100
o otto byte.

1635
01:21:59,100 --> 01:22:02,620
Ma molti primitivi in ​​un computer
in un linguaggio di programmazione

1636
01:22:02,620 --> 01:22:05,550
hanno un numero fisso di
byte sotto il hood--

1637
01:22:05,550 --> 01:22:08,100
forse 1, forse 2, forse 4, forse 8.

1638
01:22:08,100 --> 01:22:13,250
>> Ma le stringhe, in base alla progettazione, hanno un
il numero dinamica di caratteri.

1639
01:22:13,250 --> 01:22:16,980
Non si sa in anticipo, fino a quando
i tipi umani in Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
o M-A-R-I-A, o A-N-D-I. Tu non sai
quante volte l'utente sta per colpire

1641
01:22:21,400 --> 01:22:22,070
la tastiera.

1642
01:22:22,070 --> 01:22:26,490
Pertanto, non si sa come
molti personaggi di anticipo

1643
01:22:26,490 --> 01:22:27,540
si sta andando ad avere bisogno.

1644
01:22:27,540 --> 01:22:31,840
>> E così C solo tipo di foglie come un
breadcrumb segreto sotto il cofano

1645
01:22:31,840 --> 01:22:32,960
alla fine della stringa.

1646
01:22:32,960 --> 01:22:39,280
Dopo aver memorizzato Z-A-M-Y-L-A nella memoria,
ma anche semplicemente mette l'equivalente

1647
01:22:39,280 --> 01:22:40,210
di un periodo.

1648
01:22:40,210 --> 01:22:45,060
Alla fine di una frase,
mette 80 bit, in modo da

1649
01:22:45,060 --> 01:22:49,120
di ricordare dove
Zamyla inizia e finisce.

1650
01:22:49,120 --> 01:22:51,490
>> Allora qual è il collegamento,
poi, a questo programma?

1651
01:22:51,490 --> 01:22:55,190
Questo programma, Stirling,
è semplicemente un meccanismo

1652
01:22:55,190 --> 01:22:57,970
per ottenere una stringa
da parte dell'utente, linea 6.

1653
01:22:57,970 --> 01:23:01,160
Linea 7, dichiaro una variabile
chiamato n e impostarlo uguale a 0.

1654
01:23:01,160 --> 01:23:08,680
>> E poi in linea 8, ho semplicemente chiesto al
domanda, mentre il carattere n-esimo fa

1655
01:23:08,680 --> 01:23:12,120
è uguale a tutto 0 bits--
in altre parole, non lo fa

1656
01:23:12,120 --> 01:23:14,500
uguali questo speciale
carattere, backslash 0, che

1657
01:23:14,500 --> 01:23:18,470
era solo quella speciale character-- nul
andare avanti e basta incrementare n.

1658
01:23:18,470 --> 01:23:21,460
>> E continuare a farlo, e tenere
farlo, e continuare a farlo.

1659
01:23:21,460 --> 01:23:23,430
E così, anche se in
passato ci ho usato,

1660
01:23:23,430 --> 01:23:25,181
è perfettamente bene
semanticamente da usare n,

1661
01:23:25,181 --> 01:23:27,430
se si sta solo cercando di
contare questa volta deliberatamente,

1662
01:23:27,430 --> 01:23:28,720
e vogliono solo chiamarlo n.

1663
01:23:28,720 --> 01:23:34,720
Quindi questo continua a porre la domanda,
è il carattere n-esimo s tutti 0?

1664
01:23:34,720 --> 01:23:38,470
In caso contrario, considerare il successivo aspetto,
considerare il successivo, considerare il successivo,

1665
01:23:38,470 --> 01:23:39,460
considerare il successivo.

1666
01:23:39,460 --> 01:23:45,540
>> Ma non appena si vede backslash 0,
questa linea loop-- 9 attraverso 11-- ferma.

1667
01:23:45,540 --> 01:23:49,640
Si interrompe fuori dal ciclo while,
lasciando all'interno di quella variabile n

1668
01:23:49,640 --> 01:23:54,530
un conteggio totale di tutte le
caratteri della stringa che avete visto,

1669
01:23:54,530 --> 01:23:55,660
stampa così fuori.

1670
01:23:55,660 --> 01:23:56,760
Quindi proviamo questo.

1671
01:23:56,760 --> 01:23:59,500
>> Lasciami andare avanti e, senza
utilizzando la funzione Stirling,

1672
01:23:59,500 --> 01:24:04,240
ma usando solo la mia versione homegrown
qui chiamato Stirling, mi permetta di andare avanti

1673
01:24:04,240 --> 01:24:07,700
ed eseguire stirling, digitare qualcosa
come Zamyla, che so in anticipo

1674
01:24:07,700 --> 01:24:08,670
è di sei caratteri.

1675
01:24:08,670 --> 01:24:10,080
Vediamo se funziona.

1676
01:24:10,080 --> 01:24:10,920
Infatti, è sei.

1677
01:24:10,920 --> 01:24:15,257
Proviamo con Rob, tre personaggi,
tre caratteri così, e così via.

1678
01:24:15,257 --> 01:24:17,340
Ecco, questo è tutto quello che sta succedendo
sul sotto la cappa.

1679
01:24:17,340 --> 01:24:19,548
E notare i collegamenti,
poi, con la prima settimana

1680
01:24:19,548 --> 01:24:22,370
di classe, dove abbiamo parlato
qualcosa come astrazione,

1681
01:24:22,370 --> 01:24:26,960
che è proprio questa stratificazione di idee, o
complessità, in cima principi fondamentali.

1682
01:24:26,960 --> 01:24:30,710
Qui, stiamo cercando una sorta di
sotto la cappa di Stirling,

1683
01:24:30,710 --> 01:24:33,510
per così dire, di capire,
come sarebbe essere attuata?

1684
01:24:33,510 --> 01:24:35,232
>> E potremmo re-implementare noi stessi.

1685
01:24:35,232 --> 01:24:37,440
Ma stiamo mai più andare
re-implementare Stirling.

1686
01:24:37,440 --> 01:24:39,780
Stiamo solo andando a
utilizzare stirling in ordine

1687
01:24:39,780 --> 01:24:42,100
per ottenere effettivamente una certa lunghezza stringhe.

1688
01:24:42,100 --> 01:24:44,200
>> Ma non c'è nessuna magia
sotto la cappa.

1689
01:24:44,200 --> 01:24:46,716
Se si sa che sotto
la cappa, una stringa

1690
01:24:46,716 --> 01:24:48,090
è solo una sequenza di caratteri.

1691
01:24:48,090 --> 01:24:51,090
E quella sequenza di caratteri
tutti possono essere affrontate numericamente

1692
01:24:51,090 --> 01:24:53,330
con staffa 0, staffa
1, staffa 2, e si

1693
01:24:53,330 --> 01:24:57,420
sapere che alla fine di una stringa è un
carattere speciale, si può capire

1694
01:24:57,420 --> 01:25:01,710
come fare più nulla in un
programma, perché tutto si riduce a

1695
01:25:01,710 --> 01:25:03,400
è la lettura e la scrittura della memoria.

1696
01:25:03,400 --> 01:25:06,130
Cioè, la modifica e alla ricerca
a memoria, o in movimento le cose

1697
01:25:06,130 --> 01:25:10,940
intorno a memoria, le cose da stampa
sullo schermo, e così via.

1698
01:25:10,940 --> 01:25:14,800
>> Quindi cerchiamo di utilizzare questo ora ritrovata
comprensione di ciò che realmente stringhe

1699
01:25:14,800 --> 01:25:17,910
sono sotto la cappa, e
sbucciare indietro di un altro livello

1700
01:25:17,910 --> 01:25:20,080
che fino ad ora abbiamo
stato ignorando del tutto.

1701
01:25:20,080 --> 01:25:22,650
In particolare, in qualsiasi momento
abbiamo implementato un programma,

1702
01:25:22,650 --> 01:25:25,930
abbiamo avuto questa riga di codice
vicino alla parte superiore dichiarando principale.

1703
01:25:25,930 --> 01:25:27,810
E abbiamo specificato int void main.

1704
01:25:27,810 --> 01:25:31,240
>> E quel vuoto all'interno delle parentesi
è stato detto tutto questo tempo che principale

1705
01:25:31,240 --> 01:25:33,440
sé non richiede alcun argomento.

1706
01:25:33,440 --> 01:25:36,210
Qualsiasi ingresso che principale è
intenzione di ottenere da parte dell'utente

1707
01:25:36,210 --> 01:25:39,020
deve venire da qualche altra
meccanismo, come get int,

1708
01:25:39,020 --> 01:25:42,040
o ottenere galleggiante, o ottenere stringa,
o qualche altra funzione.

1709
01:25:42,040 --> 01:25:44,710
Ma si scopre che
quando si scrive un programma,

1710
01:25:44,710 --> 01:25:47,690
si può effettivamente indicare
che tale programma è

1711
01:25:47,690 --> 01:25:51,730
prendere ingressi dall'umano
nella riga di comando stesso.

1712
01:25:51,730 --> 01:25:56,310
>> In altre parole, anche se finora
sono in corso solo ./ciao ciao

1713
01:25:56,310 --> 01:26:00,312
o programmi simili, tutti della
altri programmi che abbiamo usato,

1714
01:26:00,312 --> 01:26:02,770
che noi stessi non abbiamo scriviamo,
hanno preso, a quanto pare,

1715
01:26:02,770 --> 01:26:05,210
riga di comando arguments--
cose come fare.

1716
01:26:05,210 --> 01:26:07,450
Tu dici qualcosa come marca,
e poi una seconda parola.

1717
01:26:07,450 --> 01:26:10,950
Oppure clang, clang che dici, e poi
una seconda parola, il nome di un file.

1718
01:26:10,950 --> 01:26:14,410
>> O anche RM o CP, come si potrebbe
hanno visto o già utilizzato

1719
01:26:14,410 --> 01:26:15,880
per rimuovere o copiare i file.

1720
01:26:15,880 --> 01:26:18,920
Tutti coloro prendono cosiddetti
riga di comando arguments--

1721
01:26:18,920 --> 01:26:21,130
parole aggiuntive al prompt del terminale.

1722
01:26:21,130 --> 01:26:23,260
Ma fino ad ora, abbiamo
stessi non hanno avuto

1723
01:26:23,260 --> 01:26:27,080
questo lusso di prendere input dal
utente quando lui o lei corre in realtà

1724
01:26:27,080 --> 01:26:29,120
il programma stesso nella riga di comando.

1725
01:26:29,120 --> 01:26:33,710
>> Ma possiamo farlo ri-dichiarando
principale andare avanti, non è come avere

1726
01:26:33,710 --> 01:26:36,750
invalidare tra parentesi,
ma questi due argomenti

1727
01:26:36,750 --> 01:26:40,600
instead-- primo un numero intero,
e il secondo qualcosa

1728
01:26:40,600 --> 01:26:44,170
di nuovo, qualcosa che stiamo andando a chiamare
un array, qualcosa di simile nello spirito

1729
01:26:44,170 --> 01:26:49,220
a quello che abbiamo visto in Scratch come un elenco, ma
un array di stringhe, come vedremo tra poco.

1730
01:26:49,220 --> 01:26:51,790
Ma vediamo da questo
A titolo di esempio, prima

1731
01:26:51,790 --> 01:26:53,690
distinguere esattamente cosa significa.

1732
01:26:53,690 --> 01:26:56,520
>> Quindi, se vado in CS50 IDE
qui, Sono andato avanti

1733
01:26:56,520 --> 01:27:01,840
e dichiarato in un file chiamato
argv0.c il seguente modello.

1734
01:27:01,840 --> 01:27:04,120
E notare l'unica cosa
è diverso finora

1735
01:27:04,120 --> 01:27:08,570
è che ho cambiato nulla a int
stringa argc argv parentesi aperta, vicino

1736
01:27:08,570 --> 01:27:09,070
staffa.

1737
01:27:09,070 --> 01:27:11,730
E notate, per ora, non c'è
niente dentro di quelle parentesi.

1738
01:27:11,730 --> 01:27:12,620
>> Non c'è nessun numero.

1739
01:27:12,620 --> 01:27:15,070
E non c'è io, o
n, o qualsiasi altra lettera.

1740
01:27:15,070 --> 01:27:17,010
Sto solo usando il
parentesi quadre per ora,

1741
01:27:17,010 --> 01:27:19,510
per motivi verremo
torna a in un attimo.

1742
01:27:19,510 --> 01:27:21,330
>> E ora che cosa ho intenzione di fare è questo.

1743
01:27:21,330 --> 01:27:26,680
Se argc è uguale uguale 2--
e ricordano che è uguale uguale

1744
01:27:26,680 --> 01:27:30,040
è l'operatore di uguaglianza confrontando
destra e sinistra per l'uguaglianza.

1745
01:27:30,040 --> 01:27:31,790
Non è l'assegnazione
operatore, che è

1746
01:27:31,790 --> 01:27:36,510
il segno di uguale singolo, il che significa che la copia
da destra a sinistra un certo valore.

1747
01:27:36,510 --> 01:27:42,840
>> Se argc è uguale uguale a 2, voglio
per esempio, printf, ciao, percentuali, nuova linea,

1748
01:27:42,840 --> 01:27:47,340
e quindi collegare dentro-- ed ecco il nuovo
Staffa argv trick-- 1, per motivi

1749
01:27:47,340 --> 01:27:48,840
che torneremo a in un attimo.

1750
01:27:48,840 --> 01:27:52,110
Altrimenti, se non lo fa argc
uguale a 2, sai una cosa?

1751
01:27:52,110 --> 01:27:57,400
Andiamo avanti e, come al solito, la stampa
fuori ciao mondo senza sostituzione.

1752
01:27:57,400 --> 01:28:02,710
>> Quindi sembrerebbe che se argc, che
sta per numero di argomenti, è uguale a 2,

1753
01:28:02,710 --> 01:28:04,740
Ho intenzione di stampare
ciao qualcosa o altro.

1754
01:28:04,740 --> 01:28:07,560
In caso contrario, per impostazione predefinita, sono
andare in stampa ciao mondo.

1755
01:28:07,560 --> 01:28:08,770
Che cosa significa?

1756
01:28:08,770 --> 01:28:15,550
>> Beh, mi permetta di andare avanti e di risparmio
questo file, e poi fare fare argv0,

1757
01:28:15,550 --> 01:28:18,940
e poi ./argv0, Invio.

1758
01:28:18,940 --> 01:28:20,300
E dice ciao mondo.

1759
01:28:20,300 --> 01:28:21,260
Ora, perché?

1760
01:28:21,260 --> 01:28:24,730
>> Beh, si scopre ogni volta che si
eseguire un programma a riga di comando,

1761
01:28:24,730 --> 01:28:29,570
si sta riempiendo in quello che faremo
generalmente chiamare un vettore di argomento.

1762
01:28:29,570 --> 01:28:33,100
In altre parole, automaticamente la
computer, il sistema operativo,

1763
01:28:33,100 --> 01:28:38,340
sta per consegnare al vostro programma
sé un elenco di tutte le parole

1764
01:28:38,340 --> 01:28:40,850
che l'essere umano digitato
la richiesta, nel caso in cui

1765
01:28:40,850 --> 01:28:43,790
il programmatore vuole fare
qualcosa con queste informazioni.

1766
01:28:43,790 --> 01:28:48,540
E in questo caso, l'unica parola
Ho digitato al prompt è ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> E così il numero di argomenti che è
essere passato per il mio programma è solo uno.

1768
01:28:55,420 --> 01:28:58,880
In altre parole, l'argomento
contare, altrimenti noto come argc

1769
01:28:58,880 --> 01:29:00,970
qui come un intero, è solo uno.

1770
01:29:00,970 --> 01:29:03,000
Uno, naturalmente, non è uguale a due.

1771
01:29:03,000 --> 01:29:05,980
E così questo è ciò che stampa, ciao mondo.

1772
01:29:05,980 --> 01:29:08,170
>> Ma mi permetta di prendere questo da qualche parte.

1773
01:29:08,170 --> 01:29:09,930
Lasciatemi dire, argv0.

1774
01:29:09,930 --> 01:29:12,740
E allora che ne dite di Maria?

1775
01:29:12,740 --> 01:29:14,990
E poi premere Invio.

1776
01:29:14,990 --> 01:29:18,020
>> E notare cosa accade magicamente qui.

1777
01:29:18,020 --> 01:29:22,640
Ora, invece di mondo ciao, ho
modificato il comportamento di questo programma

1778
01:29:22,640 --> 01:29:26,310
prendendo l'input non da get
stringa o qualche altra funzione,

1779
01:29:26,310 --> 01:29:30,570
ma da, a quanto pare, il mio comando
in sé, quello che ho inizialmente digitato.

1780
01:29:30,570 --> 01:29:35,720
E posso giocare a questo gioco nuovamente
cambiandolo Stelios, per esempio.

1781
01:29:35,720 --> 01:29:38,400
>> E ora vedo un altro nome ancora.

1782
01:29:38,400 --> 01:29:40,540
E qui, potrei dire Andi.

1783
01:29:40,540 --> 01:29:42,137
E potrei dire Zamyla.

1784
01:29:42,137 --> 01:29:45,220
E siamo in grado di giocare a questo gioco tutto il giorno,
basta collegare valori diversi,

1785
01:29:45,220 --> 01:29:49,550
fintanto che fornisco esattamente
due parole al prompt,

1786
01:29:49,550 --> 01:29:52,260
in modo tale che argc, conta la mia tesi, è 2.

1787
01:29:52,260 --> 01:29:57,240
>> Vedo che il nome inserito nella
printf, per questa condizione qui?

1788
01:29:57,240 --> 01:30:00,550
Quindi ci sembra di avere ora
la capacità espressiva

1789
01:30:00,550 --> 01:30:04,410
di prendere input da un altro meccanismo,
dalla cosiddetta linea di comando,

1790
01:30:04,410 --> 01:30:07,000
anziché dover attendere
fino a quando l'utente esegue il programma,

1791
01:30:07,000 --> 01:30:10,220
e poi lui o lei chiederà
usando qualcosa come stringa di get.

1792
01:30:10,220 --> 01:30:11,230
>> Così che cosa è questo?

1793
01:30:11,230 --> 01:30:15,010
Argc, ancora una volta, è solo un numero intero,
il numero di parole-- arguments--

1794
01:30:15,010 --> 01:30:18,540
che l'utente fornito al
rapida, alla finestra terminale,

1795
01:30:18,540 --> 01:30:20,110
compreso il nome del programma.

1796
01:30:20,110 --> 01:30:23,340
Così il nostro ./argv0 è, di fatto,
il nome del programma,

1797
01:30:23,340 --> 01:30:24,520
o come ho eseguito il programma.

1798
01:30:24,520 --> 01:30:25,810
>> Che conta come una parola.

1799
01:30:25,810 --> 01:30:27,080
Così argc sarebbe 1.

1800
01:30:27,080 --> 01:30:29,750
Ma quando scrivo Stelios, o
Andi, o Zamyla, o Maria,

1801
01:30:29,750 --> 01:30:31,660
questo significa che il conteggio argomento è due.

1802
01:30:31,660 --> 01:30:33,910
E così ora ci sono due parole passati in.

1803
01:30:33,910 --> 01:30:36,070
>> E notate, possiamo continuare questa logica.

1804
01:30:36,070 --> 01:30:39,050
Se io in realtà dico
qualcosa come Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
un nome completo, passando così
tre argomenti in totale,

1806
01:30:42,200 --> 01:30:47,410
ora si dice di nuovo il default,
perché, naturalmente, 3 non è uguale 2.

1807
01:30:47,410 --> 01:30:54,080
>> E in questo modo, devo
accesso tramite argv questo nuovo parametro

1808
01:30:54,080 --> 01:30:56,080
che abbiamo potuto tecnicamente
chiamare tutto ciò che vogliamo.

1809
01:30:56,080 --> 01:30:58,940
Ma per convenzione, è
argv e argc, rispettivamente.

1810
01:30:58,940 --> 01:31:04,470
Argv, argomento vettore, è una specie
di sinonimo di programmazione

1811
01:31:04,470 --> 01:31:07,140
funzione in C chiamato un array.

1812
01:31:07,140 --> 01:31:14,410
>> Un array è un elenco di valori simili
indietro, alla parte posteriore, alla schiena, alla schiena.

1813
01:31:14,410 --> 01:31:17,810
In altre parole, se uno è proprio qui a
RAM, il prossimo è proprio accanto ad esso,

1814
01:31:17,810 --> 01:31:18,800
e proprio accanto ad esso.

1815
01:31:18,800 --> 01:31:20,101
Non sono in tutto il luogo.

1816
01:31:20,101 --> 01:31:23,100
E quest'ultimo scenario, in cui le cose
sono dappertutto in memoria,

1817
01:31:23,100 --> 01:31:25,082
può effettivamente essere una caratteristica potente.

1818
01:31:25,082 --> 01:31:28,040
Ma torneremo a che, quando ci
parlare di strutture di dati più elaborate.

1819
01:31:28,040 --> 01:31:32,260
Per ora, un array è solo un
pezzo di memoria contigua,

1820
01:31:32,260 --> 01:31:36,520
ciascuno di cui elementi sono
indietro, alla parte posteriore, alla schiena, alla parte posteriore,

1821
01:31:36,520 --> 01:31:38,050
e generalmente dello stesso tipo.

1822
01:31:38,050 --> 01:31:42,630
>> Quindi, se ci pensate, da un
Poco fa, che cosa è una stringa?

1823
01:31:42,630 --> 01:31:50,460
Ebbene, una stringa, come Zamyla,
Z-A-M-Y-L-A, è, tecnicamente,

1824
01:31:50,460 --> 01:31:51,400
solo un array.

1825
01:31:51,400 --> 01:31:53,700
Si tratta di un array di caratteri.

1826
01:31:53,700 --> 01:31:59,250
>> E così se davvero disegnare questo, come ho
fatto in precedenza, come un pezzo di memoria,

1827
01:31:59,250 --> 01:32:04,510
si scopre che ognuno di questi
personaggi occupa un byte.

1828
01:32:04,510 --> 01:32:07,630
E poi c'è quella speciale
carattere sentinella, il backslash 0,

1829
01:32:07,630 --> 01:32:12,360
o tutti gli otto bit 0, che
delimita la fine della stringa.

1830
01:32:12,360 --> 01:32:15,090
Quindi una stringa, si trasforma
fuori, citare stringa unquote,

1831
01:32:15,090 --> 01:32:20,580
è solo una serie di chara--
char essendo un tipo di dati effettivo.

1832
01:32:20,580 --> 01:32:24,560
>> E ora argv, meanwhile--
torniamo al programma.

1833
01:32:24,560 --> 01:32:29,582
Argv, anche se si vede la parola
stringa qui, non è una stringa stessa.

1834
01:32:29,582 --> 01:32:33,640
Argv, argomento vettore,
è un array di stringhe.

1835
01:32:33,640 --> 01:32:37,620
>> Così come si può avere una serie di
caratteri, si può avere di più alto livello,

1836
01:32:37,620 --> 01:32:46,279
un array di strings-- così, per esempio,
quando ho scritto poco fa ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, spazio Z-A-M-Y-L-A, ho sostenuto che
argv aveva due stringhe in ./argv0 it--,

1838
01:33:00,150 --> 01:33:03,185
e Z-A-M-Y-L-A. In
altre parole, argc era 2.

1839
01:33:03,185 --> 01:33:03,980
Perché?

1840
01:33:03,980 --> 01:33:08,370
>> Beh, in effetti, che cosa sta succedendo
on è che ciascuna di queste stringhe

1841
01:33:08,370 --> 01:33:13,990
è, naturalmente, un array di caratteri
Come prima, ciascuna di cui caratteri

1842
01:33:13,990 --> 01:33:15,670
occupa un byte.

1843
01:33:15,670 --> 01:33:19,720
E non confondere il reale 0
nel nome del programma con il 0,

1844
01:33:19,720 --> 01:33:22,040
il che significa che tutti i 80 bit.

1845
01:33:22,040 --> 01:33:27,140
E Zamyla, nel frattempo, è ancora
anche un array di caratteri.

1846
01:33:27,140 --> 01:33:31,450
>> Così, alla fine della giornata, è veramente
sembra che questo sotto la cappa.

1847
01:33:31,450 --> 01:33:38,800
Ma argv, per sua natura di come principale
opere, mi permette di avvolgere tutto questo

1848
01:33:38,800 --> 01:33:44,810
up in, se si vuole, una matrice più grande
che, se poco più di semplificare

1849
01:33:44,810 --> 01:33:48,180
ciò che l'immagine assomiglia e non
abbastanza tirarla per scalare lassù,

1850
01:33:48,180 --> 01:33:56,720
questa matrice è solo di dimensioni 2, la prima
elemento che contiene una stringa,

1851
01:33:56,720 --> 01:33:59,230
il secondo elemento di
che contiene una stringa.

1852
01:33:59,230 --> 01:34:01,687
E, a sua volta, se si
tipo di ingrandire ogni

1853
01:34:01,687 --> 01:34:03,770
di quelle stringhe, quello che
vedi sotto il cofano

1854
01:34:03,770 --> 01:34:07,190
è che ogni stringa è solo
un array di caratteri.

1855
01:34:07,190 --> 01:34:11,680
>> Ora, così come con le stringhe,
siamo stati in grado di ottenere l'accesso

1856
01:34:11,680 --> 01:34:15,260
al carattere i-esimo in una stringa
usando che la notazione parentesi quadra.

1857
01:34:15,260 --> 01:34:17,320
Allo stesso modo, con gli array
in generale, possiamo

1858
01:34:17,320 --> 01:34:22,700
utilizzare la notazione parentesi quadra per ottenere
in qualsiasi numero di stringhe in un array?

1859
01:34:22,700 --> 01:34:25,100
Per esempio, mi permetta
andare avanti e fare questo.

1860
01:34:25,100 --> 01:34:32,420
>> Lasciami andare avanti e creare argv1.c,
che è un po 'diverso questa volta.

1861
01:34:32,420 --> 01:34:35,635
Invece di controllare per argc2,
Ho intenzione di fare, invece questo.

1862
01:34:35,635 --> 01:34:41,270
Per int ottengo 0, I è meno
di argc, mi plus plus,

1863
01:34:41,270 --> 01:34:47,920
e poi stampare all'interno di questo,
cento s, la nuova linea, e poi

1864
01:34:47,920 --> 01:34:50,740
argv staffa i.

1865
01:34:50,740 --> 01:34:55,220
>> Quindi, in altre parole, non che fare con
singoli caratteri per ora.

1866
01:34:55,220 --> 01:35:00,190
Argv, come implicita da questi quadrato vuoto
bretelle a destra del nome argv,

1867
01:35:00,190 --> 01:35:03,320
significa argv è un array di stringhe.

1868
01:35:03,320 --> 01:35:04,870
E argc è solo un int.

1869
01:35:04,870 --> 01:35:08,800
>> Questa linea qui, 6, è
dicendo set ho uguale a 0.

1870
01:35:08,800 --> 01:35:11,980
Contare tutta la strada fino a,
ma non compresi, argc.

1871
01:35:11,980 --> 01:35:14,010
E poi ad ogni iterazione,
stampare una stringa.

1872
01:35:14,010 --> 01:35:14,800
Cosa stringa?

1873
01:35:14,800 --> 01:35:17,270
>> La stringa i-esimo in argv.

1874
01:35:17,270 --> 01:35:19,530
Così mentre prima ero
utilizzando la parentesi quadra

1875
01:35:19,530 --> 01:35:22,180
notazione per arrivare al esimo
carattere di una stringa, ora

1876
01:35:22,180 --> 01:35:27,240
Sto usando la notazione parentesi quadra
per ottenere la stringa esimo in un array.

1877
01:35:27,240 --> 01:35:30,310
Quindi è una specie di uno strato di
sopra, concettualmente.

1878
01:35:30,310 --> 01:35:35,390
>> E così ciò che è pulito su questo
programma di oggi, se compilo argv1,

1879
01:35:35,390 --> 01:35:42,067
e poi fare ./argv1, e quindi digitare
in qualcosa di simile a foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
che sono le tre parole predefinite che un
informatico raggiunge per qualsiasi momento

1881
01:35:45,400 --> 01:35:51,010
lui o lei ha bisogno di qualche parola segnaposto,
e premere Invio, ciascuna di quelle parole,

1882
01:35:51,010 --> 01:35:54,980
tra cui il nome del programma, che
è in argv alla prima posizione,

1883
01:35:54,980 --> 01:35:58,320
finisce per essere stampate una alla volta.

1884
01:35:58,320 --> 01:36:05,290
E se cambio questo, e lo dico
qualcosa come argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
otteniamo tutti e tre questi
parole, che è argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, perché in questo
caso argc, il conteggio, è 3.

1887
01:36:14,400 --> 01:36:20,020
>> Ma ciò che è pulito è se si capisce
che argv è solo un array di stringhe,

1888
01:36:20,020 --> 01:36:24,910
e si capisce che una stringa
è un array di caratteri,

1889
01:36:24,910 --> 01:36:29,470
possiamo in realtà tipo di utilizzare questo
Staffa notazione quadrata più volte

1890
01:36:29,470 --> 01:36:33,320
scegliere una stringa, e scegliere
un carattere all'interno della stringa,

1891
01:36:33,320 --> 01:36:35,730
immersioni in profondo come segue.

1892
01:36:35,730 --> 01:36:40,100
In questo esempio, lasciami andare
avanti e chiamare questo argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
E in questo caso, mi permetta di andare avanti
e fare la following-- per int ottengo 0,

1895
01:36:50,180 --> 01:36:53,286
i è inferiore argc, i Plus
Inoltre, proprio come prima.

1896
01:36:53,286 --> 01:36:55,910
Quindi, in altre parole-- e ora questo
è sempre abbastanza complicata.

1897
01:36:55,910 --> 01:36:59,940
Poi ho intenzione di dire
iterare su stringhe in argv,

1898
01:36:59,940 --> 01:37:01,294
come un commento a me stesso.

1899
01:37:01,294 --> 01:37:03,960
E poi ho intenzione di avere un
nidificato ciclo for, che probabilmente

1900
01:37:03,960 --> 01:37:06,290
hanno fatto, o considerati
facendo, in Scratch, dove

1901
01:37:06,290 --> 01:37:08,600
Sto per dire che sono int--
Non intenzione di utilizzare i nuovo,

1902
01:37:08,600 --> 01:37:12,590
perché non voglio ombra, o
sorta di sovrascrivere il I esistente.

1903
01:37:12,590 --> 01:37:15,780
>> Io vado a, invece, dire j, perché
questo è il mio andare a variabile dopo che io,

1904
01:37:15,780 --> 01:37:18,590
quando sto solo cercando di
contare semplici numeri.

1905
01:37:18,590 --> 01:37:28,850
Per j ottiene 0-- e anche, n, sta per
ottenere la lunghezza poppa della argv staffa I,

1906
01:37:28,850 --> 01:37:36,030
purché j è minore m,
j plus plus, effettuare le seguenti operazioni.

1907
01:37:36,030 --> 01:37:37,500
Ed ecco la parte interessante.

1908
01:37:37,500 --> 01:37:46,330
>> Stampare un carattere e una nuova linea,
collegare argv staffa i, j staffa.

1909
01:37:46,330 --> 01:37:47,940
OK, quindi permettetemi di aggiungere alcuni commenti qui.

1910
01:37:47,940 --> 01:37:54,820
Iterare su personaggi
nella stringa corrente,

1911
01:37:54,820 --> 01:38:02,290
stampa carattere j-esimo nella stringa i-esimo.

1912
01:38:02,290 --> 01:38:04,630
Così ora, prendiamo in considerazione
ciò che questi commenti significano.

1913
01:38:04,630 --> 01:38:06,750
>> Iterare le corde
in argv-- quanti

1914
01:38:06,750 --> 01:38:09,300
stringhe sono in argv, che è un array?

1915
01:38:09,300 --> 01:38:13,420
Argc molti, quindi sto iterazione
da i uguale a 0 fino a argc.

1916
01:38:13,420 --> 01:38:20,020
Nel frattempo, il numero di caratteri
sono nella stringa i-esimo in argv?

1917
01:38:20,020 --> 01:38:22,880
>> Ebbene, per ottenere quella risposta,
Ho appena chiamo lunghezza della stringa

1918
01:38:22,880 --> 01:38:26,810
sulla cura stringa corrente I
A proposito, che è argv staffa i.

1919
01:38:26,810 --> 01:38:30,090
E ho intenzione di memorizzare temporaneamente che
valore di n, solo per scopi di caching,

1920
01:38:30,090 --> 01:38:31,590
da ricordare che per l'efficienza.

1921
01:38:31,590 --> 01:38:36,330
E poi ho intenzione inizializzare j a 0,
andare avanti fino a quando j è minore di n,

1922
01:38:36,330 --> 01:38:38,430
e ogni j iterazione incremento.

1923
01:38:38,430 --> 01:38:41,030
>> E poi qui, a
il mio commento sulla linea 12,

1924
01:38:41,030 --> 01:38:43,390
stampare un carattere,
seguita da una nuova linea,

1925
01:38:43,390 --> 01:38:48,140
staffa appositamente argv
Io mi dà la stringa i-esima

1926
01:38:48,140 --> 01:38:51,690
in argv-- così la prima parola, la
seconda parola, la terza parola, qualunque cosa.

1927
01:38:51,690 --> 01:38:57,370
E poi immersioni j in profondità, e ottiene
me il carattere j-esima di quella parola.

1928
01:38:57,370 --> 01:39:02,200
E così, in effetti, si può trattare
argv come un multi-dimensionale,

1929
01:39:02,200 --> 01:39:06,050
come bidimensionale, matrice,
per cui ogni parola gentile di sguardi

1930
01:39:06,050 --> 01:39:08,580
come questo nella vostra mente di
occhio, e ogni personaggio

1931
01:39:08,580 --> 01:39:10,930
è una specie di composto nel
una colonna, se questo aiuta.

1932
01:39:10,930 --> 01:39:13,260
>> In realtà, quando si prendono in giro
A parte questo, in futuro, settimane,

1933
01:39:13,260 --> 01:39:15,580
che sta per essere un po '
più sofisticato di quello.

1934
01:39:15,580 --> 01:39:17,800
Ma si può veramente
pensare che, per ora,

1935
01:39:17,800 --> 01:39:22,110
come appena questo bidimensionali
matrice, in cui un livello di esso

1936
01:39:22,110 --> 01:39:23,260
è tutte le stringhe.

1937
01:39:23,260 --> 01:39:26,760
E poi se ci si immerge in profondità, si
possono ottenere presso i singoli caratteri

1938
01:39:26,760 --> 01:39:29,600
ivi utilizzando questa notazione qui.

1939
01:39:29,600 --> 01:39:31,620
>> Allora, qual è l'effetto netto?

1940
01:39:31,620 --> 01:39:34,970
Lasciami andare avanti e
rendere maledettamente argv2-- esso.

1941
01:39:34,970 --> 01:39:36,210
Ho fatto un errore qui.

1942
01:39:36,210 --> 01:39:40,160
Implicitamente dichiarando la
funzione di stirling biblioteca.

1943
01:39:40,160 --> 01:39:42,190
Quindi tutto questo tempo, è
forse il caso

1944
01:39:42,190 --> 01:39:45,130
che stiamo tipo di finitura
esattamente dove siamo partiti.

1945
01:39:45,130 --> 01:39:48,160
>> Ho sbagliato, implicitamente dichiarando
funzione di stirling biblioteca.

1946
01:39:48,160 --> 01:39:48,987
OK, aspetta un attimo.

1947
01:39:48,987 --> 01:39:51,070
Ricordo che, in particolare
dal momento che è proprio qui.

1948
01:39:51,070 --> 01:39:54,490
Ho bisogno di includere string.h in
questa versione del programma.

1949
01:39:54,490 --> 01:40:00,050
>> Lasciami andare avanti e includo
string.h, fermo restando che, andare avanti

1950
01:40:00,050 --> 01:40:04,460
e ricompilare argv2.

1951
01:40:04,460 --> 01:40:08,390
Ed ora, qui andiamo, fare argv2, Invio.

1952
01:40:08,390 --> 01:40:10,590
E anche se è un po '
criptico a prima vista,

1953
01:40:10,590 --> 01:40:15,690
notare che, in effetti, cosa
vengono stampati sono argv2 dot.

1954
01:40:15,690 --> 01:40:19,970
>> Ma se digito qualche parola dopo la
pronta, come argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Invio, anche un po '
criptico a prima vista.

1956
01:40:22,560 --> 01:40:30,540
Ma se scorrere indietro fino,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Così abbiamo ripetuti su ogni parola.

1958
01:40:32,190 --> 01:40:37,770
E, a sua volta, ci siamo ripetuti su
ogni personaggio all'interno di una parola.

1959
01:40:37,770 --> 01:40:40,040
>> Ora, dopo tutto questo,
si rendono conto che non c'è

1960
01:40:40,040 --> 01:40:43,120
un altro dettaglio che siamo stati genere
di ignorare tutto questo tempo.

1961
01:40:43,120 --> 01:40:46,180
Abbiamo solo preso in giro a parte ciò che
ingressi di principali possono essere?

1962
01:40:46,180 --> 01:40:47,780
Che dire di uscita del principale?

1963
01:40:47,780 --> 01:40:50,540
>> Tutto questo tempo, siamo stati
semplicemente copiando e incollando

1964
01:40:50,540 --> 01:40:53,870
la parola int di fronte al principale,
se si può vedere on-line,

1965
01:40:53,870 --> 01:40:58,340
a volte in modo non corretto nelle versioni più vecchie
di C e compilatori, che si dice nulla,

1966
01:40:58,340 --> 01:40:59,410
o niente del tutto.

1967
01:40:59,410 --> 01:41:01,580
Ma, in effetti, per la versione
di C che stiamo usando,

1968
01:41:01,580 --> 01:41:06,180
C 11, o 2011, realizzare
che dovrebbe essere int.

1969
01:41:06,180 --> 01:41:09,300
E dovrebbe essere sia
nulla o argc e argv qui.

1970
01:41:09,300 --> 01:41:10,790
>> Ma perché int main?

1971
01:41:10,790 --> 01:41:12,480
Che cosa è in realtà tornando?

1972
01:41:12,480 --> 01:41:16,280
Ebbene, si scopre tutto questo tempo,
qualsiasi momento hai scritto un principale del programma

1973
01:41:16,280 --> 01:41:18,440
è sempre il ritorno qualcosa.

1974
01:41:18,440 --> 01:41:19,960
Ma si sta facendo in modo segreto.

1975
01:41:19,960 --> 01:41:23,350
>> Che qualcosa è un
int, come la linea 5 suggerisce.

1976
01:41:23,350 --> 01:41:24,225
Ma cosa int?

1977
01:41:24,225 --> 01:41:26,100
Beh, c'è questo
convenzione in programmazione,

1978
01:41:26,100 --> 01:41:29,790
per cui se non ha
andato storto e tutto va bene,

1979
01:41:29,790 --> 01:41:34,250
programmi e funzioni generalmente
return-- po counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 significa generalmente va tutto bene.

1982
01:41:38,070 --> 01:41:40,610
Quindi, anche se si pensa di
come falso in molti contesti,

1983
01:41:40,610 --> 01:41:42,930
in realtà significa generalmente una buona cosa

1984
01:41:42,930 --> 01:41:49,560
>> Nel frattempo, se un programma restituisce 1,
o negativo 1 o 5, o negativo 42,

1985
01:41:49,560 --> 01:41:52,941
o qualsiasi-0 non valore,
che significa in genere

1986
01:41:52,941 --> 01:41:54,190
che qualcosa è andato storto.

1987
01:41:54,190 --> 01:41:56,700
In realtà, sul proprio Mac o PC,
si potrebbe avere effettivamente visto

1988
01:41:56,700 --> 01:42:01,050
un messaggio di errore, per cui
dice qualcosa o altro, l'errore

1989
01:42:01,050 --> 01:42:04,940
codice negativo 42, o il codice di errore
23, o qualcosa di simile.

1990
01:42:04,940 --> 01:42:08,980
Questo numero è generalmente solo un suggerimento
al programmatore, o la società

1991
01:42:08,980 --> 01:42:11,174
che ha reso il software,
cosa è andato storto e perché,

1992
01:42:11,174 --> 01:42:13,590
in modo che possano guardare attraverso
loro documentazione o il codice,

1993
01:42:13,590 --> 01:42:15,465
e capire cosa il
errore in realtà significa.

1994
01:42:15,465 --> 01:42:18,400
Non è in genere
utile per noi utenti finali.

1995
01:42:18,400 --> 01:42:20,550
>> Ma quando principali restituisce 0, tutto va bene.

1996
01:42:20,550 --> 01:42:23,770
E se non si specifica
quello principale dovrebbe restituire,

1997
01:42:23,770 --> 01:42:26,950
sarà solo automaticamente
restituire 0 per voi.

1998
01:42:26,950 --> 01:42:30,870
Ma tornando qualcosa
il resto è effettivamente utile.

1999
01:42:30,870 --> 01:42:34,660
>> In questo programma definitivo, mi permetta
andare avanti e chiamare questo exit.c,

2000
01:42:34,660 --> 01:42:38,630
e introdurre l'ultima di oggi
argomenti, noti come un codice di errore.

2001
01:42:38,630 --> 01:42:42,930
Lasciami andare avanti e includono la nostra
file di familiari fino in alto, fanno int main.

2002
01:42:42,930 --> 01:42:49,500
E questa volta, facciamolo int argc,
argv stringa e con le mie staffe

2003
01:42:49,500 --> 01:42:50,836
implicare che è nella matrice.

2004
01:42:50,836 --> 01:42:52,460
E poi vorrei solo fare un controllo di integrità.

2005
01:42:52,460 --> 01:42:56,640
Questa volta, se non lo fa argc
uguale a 2, poi si sa che cosa?

2006
01:42:56,640 --> 01:42:57,520
Dimenticalo.

2007
01:42:57,520 --> 01:43:03,170
Sto per dire che, hey, l'utente,
vi manca argomento della riga di comando

2008
01:43:03,170 --> 01:43:04,210
n backslash.

2009
01:43:04,210 --> 01:43:05,230
>> E poi il gioco è fatto.

2010
01:43:05,230 --> 01:43:06,130
Voglio uscire.

2011
01:43:06,130 --> 01:43:11,030
Ho intenzione di preventivamente,
e prematuramente in realtà, il ritorno

2012
01:43:11,030 --> 01:43:12,810
qualcosa diverso dal numero 1.

2013
01:43:12,810 --> 01:43:15,360
Il via al valore per il primo
errore che può accadere è 1.

2014
01:43:15,360 --> 01:43:17,860
Se avete qualche altro erroneo
situazione che potrebbe verificarsi,

2015
01:43:17,860 --> 01:43:21,390
si potrebbe dire di ritorno 2 o 3 tornare, o
forse addirittura negativo 1 o negativo 2.

2016
01:43:21,390 --> 01:43:23,750
>> Questi sono solo i codici di uscita
che sono, in generale,

2017
01:43:23,750 --> 01:43:27,770
solo utili al programmatore, o
società che è la spedizione del software.

2018
01:43:27,770 --> 01:43:30,500
Ma il fatto che è
Non 0 è ciò che è importante.

2019
01:43:30,500 --> 01:43:34,310
Quindi, se in questo programma, voglio
garantire che questo programma solo

2020
01:43:34,310 --> 01:43:38,190
funziona se l'utente fornisce me
con un numero di argomenti di due,

2021
01:43:38,190 --> 01:43:42,880
il nome del programma e un certo altro
parola, può valere tanto quanto segue,

2022
01:43:42,880 --> 01:43:46,110
urlare l'utente con printf detto,
manca argomento della riga di comando,

2023
01:43:46,110 --> 01:43:46,970
ritornare 1.

2024
01:43:46,970 --> 01:43:49,940
Che sarà solo subito
uscire dal programma.

2025
01:43:49,940 --> 01:43:55,840
>> Solo se argc è uguale a 2 otterremo giù
qui, a quel punto ho intenzione di dire,

2026
01:43:55,840 --> 01:44:00,410
ciao cento s, backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
In altre parole, io sono
Non andare dopo argv 0,

2028
01:44:03,827 --> 01:44:05,410
che è solo il nome del programma.

2029
01:44:05,410 --> 01:44:09,450
Voglio stampare ciao, virgola,
la seconda parola che l'uomo digitato.

2030
01:44:09,450 --> 01:44:12,580
E in questo caso sulla
linea 13, tutto va bene.

2031
01:44:12,580 --> 01:44:15,920
>> So che è argc 2
logicamente da questo programma.

2032
01:44:15,920 --> 01:44:17,770
Ho intenzione di andare avanti e restituire 0.

2033
01:44:17,770 --> 01:44:21,230
Per inciso, tenere a mente che
questo è vero in Scratch pure.

2034
01:44:21,230 --> 01:44:24,760
>> Logicamente, avrei potuto fare questo
e incapsulare queste righe

2035
01:44:24,760 --> 01:44:27,020
di codice in questa clausola altro qui.

2036
01:44:27,020 --> 01:44:29,420
Ma questo è una sorta di
inutilmente rientro il mio codice.

2037
01:44:29,420 --> 01:44:31,800
E voglio fare eccellente
chiaro che non importa cosa,

2038
01:44:31,800 --> 01:44:34,670
Per impostazione predefinita, ciao
qualcosa otterrà stampata,

2039
01:44:34,670 --> 01:44:36,050
finché l'utente coopera.

2040
01:44:36,050 --> 01:44:39,360
>> Quindi è molto comune l'uso
una condizione, solo un caso,

2041
01:44:39,360 --> 01:44:41,870
di catturare qualche erronea
situazione, e quindi uscire.

2042
01:44:41,870 --> 01:44:45,690
E poi, così tutto è
bene, non hanno un altro,

2043
01:44:45,690 --> 01:44:48,060
ma basta avere il codice
esterno che se, perché è

2044
01:44:48,060 --> 01:44:51,060
equivalente in questo
caso particolare, logicamente.

2045
01:44:51,060 --> 01:44:54,480
Così sto tornando 0, solo per
esplicitamente significare tutto va bene.

2046
01:44:54,480 --> 01:44:58,480
>> Se ho omesso il ritorno 0, sarebbe
essere assunta automaticamente per me.

2047
01:44:58,480 --> 01:45:00,890
Ma ora che sto tornando
uno in almeno questo caso,

2048
01:45:00,890 --> 01:45:04,940
Vado a, per buona misura e
chiarezza, restituire 0 in questo caso.

2049
01:45:04,940 --> 01:45:09,690
Così ora mi permetta di andare avanti e fare uscire,
che è un segue perfetto per lasciare solo.

2050
01:45:09,690 --> 01:45:14,401
>> Ma fare uscire, e lasciami andare
avanti e fare ./exit, Invio.

2051
01:45:14,401 --> 01:45:16,900
E il programma zittirmi,
manca argomento della riga di comando.

2052
01:45:16,900 --> 01:45:18,120
OK, mi permetta di collaborare.

2053
01:45:18,120 --> 01:45:23,810
>> Lasciatemi invece fare ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
E ora si dice, ciao David.

2055
01:45:25,190 --> 01:45:27,300
E che normalmente non vedere questo.

2056
01:45:27,300 --> 01:45:30,650
>> Ma si scopre che c'è un
special modo in Linux per vedere effettivamente

2057
01:45:30,650 --> 01:45:34,470
con quello che l'uscita del codice di un programma terminato.

2058
01:45:34,470 --> 01:45:37,184
A volte in una grafica
mondo come Mac OS o Windows,

2059
01:45:37,184 --> 01:45:40,100
si vede solo questi numeri quando un
messaggio di errore compare sullo schermo

2060
01:45:40,100 --> 01:45:41,940
e il programmatore
si dimostra che il numero.

2061
01:45:41,940 --> 01:45:44,773
Ma se vogliamo vedere ciò che l'errore
messaggio è, possiamo farlo qui--

2062
01:45:44,773 --> 01:45:48,100
così ./exit, Enter, stampa
manca argomento della riga di comando.

2063
01:45:48,100 --> 01:45:54,590
>> Se ora faccio $ echo ?, che è
ridicolmente criptico cercando.

2064
01:45:54,590 --> 01:45:56,590
Ma $?

2065
01:45:56,590 --> 01:45:59,220
è la formula magica
che dice, hey, computer,

2066
01:45:59,220 --> 01:46:01,900
dirmi che cosa il precedente
codice di uscita del programma è stato.

2067
01:46:01,900 --> 01:46:03,410
E mi ha colpito Invio.

2068
01:46:03,410 --> 01:46:07,520
Vedo 1, perché è quello che ho
ha detto la mia funzione principale di tornare.

2069
01:46:07,520 --> 01:46:12,310
>> Nel frattempo, se faccio ./exit David,
e premere invio, vedo, ciao Davide.

2070
01:46:12,310 --> 01:46:16,800
E se ora faccio $ echo ?, vedo ciao 0.

2071
01:46:16,800 --> 01:46:19,080
E così questo in realtà sarà
essere preziose informazioni

2072
01:46:19,080 --> 01:46:23,420
nel contesto del debugger, non così
tanto che, l'umano, si cura.

2073
01:46:23,420 --> 01:46:26,060
Ma il debugger e altro
programmi useremo questo semestre

2074
01:46:26,060 --> 01:46:29,420
spesso guardare a quel numero,
anche se è sorta di nascosto

2075
01:46:29,420 --> 01:46:32,780
a meno che non si guarda per esso, a
determinare se un programma di oppure no

2076
01:46:32,780 --> 01:46:37,050
esecuzione era corretta o errata.

2077
01:46:37,050 --> 01:46:40,450
>> E così che ci porta a
questo, alla fine della giornata.

2078
01:46:40,450 --> 01:46:43,917
Abbiamo iniziato oggi, cercando in
debugging, ed a sua volta al corso

2079
01:46:43,917 --> 01:46:46,750
stesso, e quindi più interessante,
tecnicamente sotto la cappa

2080
01:46:46,750 --> 01:46:49,490
a ciò che le stringhe sono, che durano
settimana abbiamo appena preso per scontato,

2081
01:46:49,490 --> 01:46:51,900
e certamente li portò
per scontato in Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Abbiamo poi visto come possiamo accedere
singoli caratteri di una stringa,

2083
01:46:56,040 --> 01:47:00,310
e poi di nuovo preso un livello superiore
guardare le cose, guardando a come well--

2084
01:47:00,310 --> 01:47:04,226
se vogliamo ottenere a livello individuale
elementi di una lista come la struttura,

2085
01:47:04,226 --> 01:47:05,850
non possiamo farlo con più stringhe?

2086
01:47:05,850 --> 01:47:08,050
E possiamo con gli argomenti della riga di comando.

2087
01:47:08,050 --> 01:47:12,800
Ma questa immagine qui di soli scatole
è dimostrativo di questa idea generale

2088
01:47:12,800 --> 01:47:14,451
di un array, o un elenco, o di un vettore.

2089
01:47:14,451 --> 01:47:16,450
E a seconda del
contesto, tutte queste parole

2090
01:47:16,450 --> 01:47:17,880
significare cose leggermente diverse.

2091
01:47:17,880 --> 01:47:20,060
Quindi, in C, stiamo solo andando
per parlare di un array.

2092
01:47:20,060 --> 01:47:23,840
E un array è un pezzo
della memoria, ciascuno dei quali è

2093
01:47:23,840 --> 01:47:27,720
elementi sono contigui, di nuovo,
to back, to back, to back.

2094
01:47:27,720 --> 01:47:31,970
>> E questi elementi sono, in generale,
dello stesso tipo di dati, carattere,

2095
01:47:31,970 --> 01:47:35,966
carattere, carattere, carattere, o
string, string, string, string, o int,

2096
01:47:35,966 --> 01:47:38,600
int, int, qualunque essa sia
stiamo cercando di negozio.

2097
01:47:38,600 --> 01:47:42,540
Ma alla fine della giornata, è
quello che sembra concettualmente.

2098
01:47:42,540 --> 01:47:44,530
Si sta prendendo la tua
memoria o RAM del computer.

2099
01:47:44,530 --> 01:47:48,590
E si sta carving fuori in
scatole identiche dimensioni, tutte

2100
01:47:48,590 --> 01:47:50,920
sono tornati, contro schiena, a
di nuovo, per sostenere in questo modo.

2101
01:47:50,920 --> 01:47:53,200
>> E che cosa c'è di bello
questa idea, e il fatto

2102
01:47:53,200 --> 01:47:58,580
che possiamo esprimere valori in questo modo
con il primo dei nostri strutture dati

2103
01:47:58,580 --> 01:48:02,520
nella classe, ci consente di iniziare
per risolvere problemi con il codice

2104
01:48:02,520 --> 01:48:04,079
che è venuto in modo intuitivo in settimana 0.

2105
01:48:04,079 --> 01:48:05,870
Vi ricorderete il telefono
Esempio libro, dove

2106
01:48:05,870 --> 01:48:09,110
abbiamo usato un divide et impera,
o un algoritmo di ricerca binaria,

2107
01:48:09,110 --> 01:48:13,220
per vagliare un intero
mucchio di nomi e numeri.

2108
01:48:13,220 --> 01:48:18,220
Ma abbiamo ipotizzato, ricordare, che tale
libro di telefono è stato già ordinato,

2109
01:48:18,220 --> 01:48:21,630
che qualcun altro aveva già
figurato fuori-- data una lista di nomi

2110
01:48:21,630 --> 01:48:24,430
e numbers-- come alfabetizzare loro.

2111
01:48:24,430 --> 01:48:26,950
E ora che in C siamo,
Anche, hanno la capacità

2112
01:48:26,950 --> 01:48:30,290
per gettare le cose, non
fisicamente in una rubrica telefonica

2113
01:48:30,290 --> 01:48:34,220
ma praticamente in un computer
la memoria, saremo in grado prossima settimana

2114
01:48:34,220 --> 01:48:38,470
di introdurre di nuovo il primo questo--
delle nostre strutture di dati in un array--

2115
01:48:38,470 --> 01:48:43,530
ma ancora più importante, computer vero e proprio
algoritmi di scienze applicate

2116
01:48:43,530 --> 01:48:47,720
in codice, con il quale possiamo memorizzare
i dati in strutture di questo tipo,

2117
01:48:47,720 --> 01:48:50,730
e poi iniziare a manipolarla, e
risolvere effettivamente problemi con esso,

2118
01:48:50,730 --> 01:48:53,570
e di costruire in cima a quello,
infine, programmi in C,

2119
01:48:53,570 --> 01:48:56,730
in Python, in JavaScript,
interrogazione di banche dati con SQL?

2120
01:48:56,730 --> 01:48:59,980
>> E vedremo che tutti questi
idee diverse di blocco.

2121
01:48:59,980 --> 01:49:04,100
Ma per ora, ricordare che la
dominio che abbiamo introdotto oggi

2122
01:49:04,100 --> 01:49:06,920
era questa cosa qui, e
il mondo della crittografia.

2123
01:49:06,920 --> 01:49:11,200
E tra i prossimi problemi che da soli
risolverà è l'arte della crittografia,

2124
01:49:11,200 --> 01:49:13,630
scrambling e de-scrambling
informazioni, e cifratura

2125
01:49:13,630 --> 01:49:15,930
e decifrare il testo,
e assumendo infine

2126
01:49:15,930 --> 01:49:18,970
che ora si sa che cosa
è sotto il cofano

2127
01:49:18,970 --> 01:49:21,860
in modo che quando si vede o si riceve
un messaggio come questo, è

2128
01:49:21,860 --> 01:49:24,060
te può decifrarlo.

2129
01:49:24,060 --> 01:49:26,740
Tutto questo, e più la prossima volta.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [RIPRODUZIONE VIDEO]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Appena arrivato.

2133
01:49:32,970 --> 01:49:35,146
Ho intenzione di andare a visitare
il suo professore universitario.

2134
01:49:35,146 --> 01:49:37,611
Sì.

2135
01:49:37,611 --> 01:49:40,080
Ciao.

2136
01:49:40,080 --> 01:49:40,660
Sei tu.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Aspetta!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Sto solo cercando di capire
cosa ti è successo.

2142
01:49:56,060 --> 01:49:58,130
Si prega, nulla potrebbe aiutare.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Eri suo collegio
compagno di stanza, non è vero?

2145
01:50:08,354 --> 01:50:10,770
Tu eri lì con lui quando
ha finito il progetto CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [RIPRODUZIONE DI BRANI MUSICALI]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Che Era CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Amo questo posto.

2152
01:50:44,770 --> 01:50:45,854
>> -Mangia.

2153
01:50:45,854 --> 01:50:47,020
Stiamo andando fuori mercato.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [FINE RIPRODUZIONE]

