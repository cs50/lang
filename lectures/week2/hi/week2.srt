1
00:00:00,000 --> 00:00:02,970
>> [संगीत बजाना]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> डेविड जे मालन: ठीक है।

4
00:00:15,700 --> 00:00:18,832
यह CS50 और यह है
2 सप्ताह की शुरुआत है।

5
00:00:18,832 --> 00:00:21,040
और तुम उस पर याद होगा
सप्ताह की पिछले कुछ,

6
00:00:21,040 --> 00:00:24,490
हम कंप्यूटर को शुरू किया गया है
विज्ञान और, बारी में, प्रोग्रामिंग।

7
00:00:24,490 --> 00:00:27,640
>> और हम के माध्यम से कहानी शुरू कर दिया
स्क्रैच, कि चित्रमय भाषा

8
00:00:27,640 --> 00:00:28,990
एमआईटी मीडिया लैब से।

9
00:00:28,990 --> 00:00:30,780
और फिर सबसे हाल ही में,
पिछले सप्ताह हमने किया

10
00:00:30,780 --> 00:00:34,450
एक higher-- एक परिचय
निचले स्तर की भाषा में जाना जाता है

11
00:00:34,450 --> 00:00:36,770
सी, कुछ ऐसा है जो विशुद्ध शाब्दिक रूप में है।

12
00:00:36,770 --> 00:00:39,440
और, वास्तव में, पिछली बार जब हम
इस संदर्भ के भीतर का पता लगाया

13
00:00:39,440 --> 00:00:40,450
अवधारणाओं की एक संख्या है।

14
00:00:40,450 --> 00:00:43,010
>> यह, याद है, बहुत था
पहला कार्यक्रम हम पर देखा।

15
00:00:43,010 --> 00:00:45,710
और इस कार्यक्रम, काफी बस,
बाहर प्रिंट, "हैलो, दुनिया।"

16
00:00:45,710 --> 00:00:47,730
लेकिन वहाँ इतना
सूरत से जादू चल रहा है।

17
00:00:47,730 --> 00:00:51,460
इस # शामिल है
इन कोण कोष्ठक के साथ।

18
00:00:51,460 --> 00:00:52,170
वहाँ int है।

19
00:00:52,170 --> 00:00:53,020
वहाँ (शून्य)।

20
00:00:53,020 --> 00:00:56,330
कोष्ठक, घुंघराले ब्रेसिज़ नहीं है,
अर्द्ध कॉलन, और इतना अधिक।

21
00:00:56,330 --> 00:00:58,480
>> और हां, याद है कि
हम खरोंच शुरू की

22
00:00:58,480 --> 00:01:02,110
इतना है कि हम, आदर्श, अतीत देख सकता है
कि वाक्य रचना, सामान सच नहीं है कि

23
00:01:02,110 --> 00:01:04,590
सब है कि बौद्धिक
दिलचस्प लेकिन जल्दी पर

24
00:01:04,590 --> 00:01:07,700
, बिल्कुल, थोड़ा मुश्किल
अपने मन के आसपास लपेटो करने के लिए।

25
00:01:07,700 --> 00:01:10,860
और, वास्तव में, सबसे आम में से एक
बातों पर जल्दी एक प्रोग्रामिंग वर्ग में,

26
00:01:10,860 --> 00:01:13,443
खासकर उन लोगों के लिए कम
आरामदायक, से निराश हो जाता है

27
00:01:13,443 --> 00:01:17,460
और कुछ वाक्यात्मक द्वारा गच्चा
त्रुटियों, तार्किक त्रुटियों का उल्लेख नहीं है।

28
00:01:17,460 --> 00:01:19,800
और हमारे लक्ष्य के बीच इतना
आज वास्तव में, होगा

29
00:01:19,800 --> 00:01:23,280
कुछ के साथ लैस करने के लिए हो
के लिए कैसे समस्या को हल करने की तकनीक

30
00:01:23,280 --> 00:01:26,705
बेहतर समस्याओं को खुद हल करने के लिए
डिबगिंग के रूप में।

31
00:01:26,705 --> 00:01:29,330
और आपको याद होगा, भी, कि
पर्यावरण कि हम शुरू की

32
00:01:29,330 --> 00:01:31,780
पिछली बार CS50 आईडीई बुलाया गया था।

33
00:01:31,780 --> 00:01:34,850
यह वेब आधारित सॉफ्टवेयर है कि
आप क्लाउड में कार्यक्रम के लिए अनुमति देता है,

34
00:01:34,850 --> 00:01:38,450
तो बात है, जबकि सभी को ध्यान में रखते हुए अपने
एक साथ फ़ाइलें, जैसा कि हम आज फिर से होगा।

35
00:01:38,450 --> 00:01:41,480
और कहा कि हम याद करते हैं
यहां इन विषयों पर दोबारा गौर,

36
00:01:41,480 --> 00:01:44,480
उन के बीच में काम करता है, और छोरों, और
चर, और बूलियन अभिव्यक्ति,

37
00:01:44,480 --> 00:01:45,110
और शर्तों।

38
00:01:45,110 --> 00:01:49,190
और वास्तव में कुछ अधिक है कि हम
स्क्रैच की दुनिया से अनुवाद

39
00:01:49,190 --> 00:01:50,800
सी की दुनिया में

40
00:01:50,800 --> 00:01:53,220
>> लेकिन मौलिक निर्माण
ब्लॉक, तो बात है,

41
00:01:53,220 --> 00:01:55,150
वास्तव में अभी भी एक ही पिछले सप्ताह थे।

42
00:01:55,150 --> 00:01:57,900
एक वास्तव में, हम वास्तव में सिर्फ था
अलग पहेली टुकड़ा, अगर तुम जाएगा।

43
00:01:57,900 --> 00:02:00,300
कि बैंगनी रंग के बजाय
ब्लॉक बचाने के लिए, हम बजाय

44
00:02:00,300 --> 00:02:02,940
printf था, जो है
सी में इस समारोह में कहा कि

45
00:02:02,940 --> 00:02:05,890
आप कुछ प्रिंट करने देता है
और स्क्रीन पर यह प्रारूप।

46
00:02:05,890 --> 00:02:07,950
हम CS50 शुरू की
लाइब्रेरी, तुम कहाँ

47
00:02:07,950 --> 00:02:11,420
अपने निपटान get_char पर अब है,
और get_int, और get_string,

48
00:02:11,420 --> 00:02:14,610
और के रूप में कुछ अन्य कार्यों
खैर, जो के माध्यम से आप इनपुट प्राप्त कर सकते हैं

49
00:02:14,610 --> 00:02:16,260
उपयोगकर्ता की अपनी कीबोर्ड से।

50
00:02:16,260 --> 00:02:20,640
और हम भी बातों पर एक नज़र लिया
these- बूल, और चार तरह,

51
00:02:20,640 --> 00:02:22,490
और डबल, नाव,
पूर्णांक, long_long स्ट्रिंग।

52
00:02:22,490 --> 00:02:25,170
और वहाँ सी में भी अन्य प्रकार के डेटा

53
00:02:25,170 --> 00:02:28,560
>> दूसरे शब्दों में, जब आप की घोषणा में
एक चर कुछ मूल्य की दुकान,

54
00:02:28,560 --> 00:02:32,600
या जब आप एक समारोह को लागू
कि कुछ मान देता है,

55
00:02:32,600 --> 00:02:35,290
आप क्या निर्दिष्ट कर सकते हैं
मूल्य है कि के प्रकार।

56
00:02:35,290 --> 00:02:37,310
यह एक स्ट्रिंग है, एक तरह
पात्रों के अनुक्रम?

57
00:02:37,310 --> 00:02:39,490
यह एक पूर्णांक की तरह एक नंबर है?

58
00:02:39,490 --> 00:02:41,390
यह एक चल बिन्दु है
मूल्य, या पसंद है?

59
00:02:41,390 --> 00:02:46,180
तो सी में, स्क्रैच के विपरीत, हम वास्तव में
किस प्रकार का डेटा निर्दिष्ट करने के लिए शुरू किया

60
00:02:46,180 --> 00:02:48,330
हम लौटने या उपयोग कर रहे थे।

61
00:02:48,330 --> 00:02:51,910
>> लेकिन जाहिर है, हम भी में भाग गया
कंप्यूटिंग के कुछ बुनियादी सीमा।

62
00:02:51,910 --> 00:02:54,100
खास तरीके से,
इस भाषा सी, याद

63
00:02:54,100 --> 00:02:57,070
हम पर एक नज़र लिया है कि
पूर्णांक अतिप्रवाह, वास्तविकता

64
00:02:57,070 --> 00:03:00,460
कि अगर आप केवल एक है
स्मृति की निश्चित राशि

65
00:03:00,460 --> 00:03:04,600
या, विशेष रूप से, एक परिमित संख्या
बिट्स के लिए, आप केवल इतनी अधिक भरोसा कर सकते हैं।

66
00:03:04,600 --> 00:03:08,460
और इसलिए हम यहां इस उदाहरण को देखा
जिससे एक हवाई जहाज में एक काउंटर,

67
00:03:08,460 --> 00:03:13,510
वास्तव में, अगर लंबे समय पर्याप्त होता चल रहा है
अतिप्रवाह और एक सॉफ्टवेयर में परिणाम

68
00:03:13,510 --> 00:03:15,560
एक वास्तविक भौतिक संभावित त्रुटि।

69
00:03:15,560 --> 00:03:18,600
>> हम यह भी तैर को देखा
बिंदु अस्पष्टता, वास्तविकता

70
00:03:18,600 --> 00:03:22,280
कि केवल एक सीमित संख्या के साथ
बिट्स के लिए, चाहे वह 32 या 64 है,

71
00:03:22,280 --> 00:03:27,330
आप केवल इतने सारे संख्या निर्दिष्ट कर सकते हैं
एक दशमलव बिंदु के बाद जिसके बाद आप

72
00:03:27,330 --> 00:03:29,110
imprecise पाने के लिए शुरू करते हैं।

73
00:03:29,110 --> 00:03:32,360
उदाहरण के लिए, एक तिहाई तो
यहाँ दुनिया, हमारे इंसानों की दुनिया में,

74
00:03:32,360 --> 00:03:35,360
हम जानते हैं कि अभी एक अनंत संख्या है
दशमलव बिंदु के बाद 3s की।

75
00:03:35,360 --> 00:03:38,820
लेकिन एक कंप्यूटर जरूरी नहीं कर सकते
संख्या की एक अनंत संख्या का प्रतिनिधित्व

76
00:03:38,820 --> 00:03:42,590
अगर आप केवल अनुमति देते हैं यह कुछ
जानकारी के सीमित मात्रा में।

77
00:03:42,590 --> 00:03:45,900
>> इतना ही नहीं, हम आप से लैस किया
मामले में अधिक से अधिक शक्ति के साथ

78
00:03:45,900 --> 00:03:49,280
कैसे तुम अपने आप को अभिव्यक्त कर सकता है
प्रोग्रामिंग के मामले में एक कीबोर्ड,

79
00:03:49,280 --> 00:03:51,430
हम भी सीमित क्या
आप वास्तव में क्या कर सकते हैं।

80
00:03:51,430 --> 00:03:55,790
और वास्तव में, कीड़े और गलतियों से कर सकते हैं
मुद्दों के उन प्रकार से उत्पन्न होती हैं।

81
00:03:55,790 --> 00:03:59,900
और वास्तव में, विषयों के बीच आज
डिबगिंग जैसे विषयों को होने जा रहे हैं

82
00:03:59,900 --> 00:04:03,699
और वास्तव में हुड के नीचे तलाश
कैसे चीजों को पेश किए गए पिछले सप्ताह में

83
00:04:03,699 --> 00:04:05,490
वास्तव में लागू कर रहे हैं
इतनी है कि आप बेहतर

84
00:04:05,490 --> 00:04:10,530
समझ में दोनों की क्षमताओं और
सी की तरह एक भाषा की सीमाओं

85
00:04:10,530 --> 00:04:14,770
>> और वास्तव में, हम वापस परत छील कर देंगे
डेटा संरचना का सरलतम की,

86
00:04:14,770 --> 00:04:17,756
कुछ एक सरणी कहा जाता है, जो
स्क्रैच एक फोन करने के लिए होता है 'की सूची। "

87
00:04:17,756 --> 00:04:19,589
यह एक छोटा सा है
इस संदर्भ में अलग है।

88
00:04:19,589 --> 00:04:23,340
और फिर हम भी की एक मिलवाता हूँ
हमारे डोमेन-विशिष्ट समस्याओं का पहला

89
00:04:23,340 --> 00:04:26,790
CS50 में, की दुनिया
क्रिप्टोग्राफी, पांव मार करने की कला

90
00:04:26,790 --> 00:04:29,650
या में इतनी जानकारी संकेताक्षर
आप गुप्त संदेश भेज सकते हैं कि

91
00:04:29,650 --> 00:04:34,520
और गुप्त संदेशों को डिकोड
दो व्यक्तियों, ए और बी के बीच

92
00:04:34,520 --> 00:04:37,490
>> इसलिए हम संक्रमण से पहले
कि नई दुनिया के लिए,

93
00:04:37,490 --> 00:04:42,059
चलो कुछ से लैस करने की कोशिश करते हैं
तकनीक है जिसके साथ आप समाप्त कर सकते हैं

94
00:04:42,059 --> 00:04:43,850
या कम से कम कुछ कम
कुंठा की

95
00:04:43,850 --> 00:04:46,630
आप शायद का सामना करना पड़ा है कि
पिछले एक सप्ताह से अकेले खत्म हो गया।

96
00:04:46,630 --> 00:04:50,830
वास्तव में, आप के आगे के कुछ कर रहे हैं such--
सी और बाधाओं में अपना पहला समस्याएं हैं

97
00:04:50,830 --> 00:04:54,010
अगर तुम मुझे पसंद कर रहे हैं, पहली बार
आप एक प्रोग्राम बाहर टाइप करने के लिए कोशिश करते हैं,

98
00:04:54,010 --> 00:04:57,330
भले ही आप तार्किक लगता है
कार्यक्रम बहुत आसान है,

99
00:04:57,330 --> 00:05:01,200
आप बहुत अच्छी तरह से एक दीवार हिट हो सकता है, और
संकलक सहयोग करने के लिए नहीं जा रहा है।

100
00:05:01,200 --> 00:05:03,940
करो या बजना नहीं जा रहा है
वास्तव में अपनी बोली करने के लिए।

101
00:05:03,940 --> 00:05:05,450
>> और क्यों है कि हो सकता है?

102
00:05:05,450 --> 00:05:07,950
खैर, चलो पर एक नज़र रखना
शायद, एक साधारण प्रोग्राम।

103
00:05:07,950 --> 00:05:11,190
मुझे आगे जाना है और इस को बचाने के लिए जा रहा हूँ
एक फ़ाइल जानबूझ buggy0.c कहा जाता है,

104
00:05:11,190 --> 00:05:13,590
क्योंकि मैं इसे करने के लिए पता
अग्रिम में त्रुटिपूर्ण हो।

105
00:05:13,590 --> 00:05:17,400
लेकिन मुझे पता है कि अगर यह नहीं हो सकता है
पहले या दूसरे या तीसरे कार्यक्रम है

106
00:05:17,400 --> 00:05:18,830
कि मैं वास्तव में खुद बना रहा हूँ।

107
00:05:18,830 --> 00:05:23,820
तो मैं आगे जाने के लिए जा रहा हूँ और
बाहर प्रकार, int मुख्य (शून्य)।

108
00:05:23,820 --> 00:05:28,130
और फिर मेरी घुंघराले ब्रेसिज़ के अंदर,
एक बहुत परिचित ( "हैलो, world--

109
00:05:28,130 --> 00:05:30,980
बैकस्लैश, एन ") - और एक अर्धविराम।

110
00:05:30,980 --> 00:05:32,360
>> मैं फ़ाइल बचा लिया।

111
00:05:32,360 --> 00:05:34,850
अब मैं नीचे जाने के लिए जा रहा हूँ
मेरे टर्मिनल विंडो पर

112
00:05:34,850 --> 00:05:40,340
और प्रकार बनाने buggy0, क्योंकि, फिर से,
आज फ़ाइल का नाम buggy0.c है।

113
00:05:40,340 --> 00:05:43,660
तो मैं buggy0 बनाने, दर्ज टाइप करें।

114
00:05:43,660 --> 00:05:48,200
>> और, ओह, भगवान, पिछली बार से याद करते हैं
कि कोई त्रुटि संदेश एक अच्छी बात है।

115
00:05:48,200 --> 00:05:49,740
तो कोई उत्पादन एक अच्छी बात है।

116
00:05:49,740 --> 00:05:52,920
लेकिन यहाँ मैं स्पष्ट रूप से है
गलतियों से कुछ संख्या है।

117
00:05:52,920 --> 00:05:56,470
>> उत्पादन की पहली पंक्ति तो
buggy0 बनाने लिखने के बाद, याद है,

118
00:05:56,470 --> 00:05:59,540
बजना की काफी वाचाल उत्पादन है।

119
00:05:59,540 --> 00:06:02,067
हुड के नीचे,
CS50 आईडीई कॉन्फ़िगर किया गया है

120
00:06:02,067 --> 00:06:04,150
की एक पूरी गुच्छा का उपयोग करने के लिए
इस संकलक के साथ विकल्प

121
00:06:04,150 --> 00:06:05,941
ताकि आप की जरूरत नहीं है कि
उनके बारे में सोचने के लिए।

122
00:06:05,941 --> 00:06:08,840
और यह सब है कि पहली पंक्ति है
इसका मतलब है कि बजना के साथ शुरू होता है।

123
00:06:08,840 --> 00:06:11,720
>> लेकिन उसके बाद, समस्या
उनकी उपस्थिति बनाने के लिए शुरू करते हैं।

124
00:06:11,720 --> 00:06:17,390
लाइन 3, चरित्र पर Buggy0.c
5, वहाँ एक बड़ा, लाल त्रुटि है।

125
00:06:17,390 --> 00:06:18,380
वो क्या है?

126
00:06:18,380 --> 00:06:23,562
परोक्ष पुस्तकालय समारोह की घोषणा
साथ प्रकार पूर्णांक (const चार * printf,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror]।

128
00:06:26,050 --> 00:06:28,379
मैं बहुत जल्दी मतलब है, यह
बहुत रहस्यमय हो जाता है।

129
00:06:28,379 --> 00:06:30,170
और निश्चित रूप से, पहली बार में
नज़र, हम नहीं होगा

130
00:06:30,170 --> 00:06:32,380
आप समझने की उम्मीद
उस संदेश की संपूर्णता।

131
00:06:32,380 --> 00:06:34,213
और तो सबक के एक
आज के लिए जा रहा है

132
00:06:34,213 --> 00:06:36,919
नोटिस करने की कोशिश करने के लिए किया जाना है
पैटर्न, या इसी तरह की बातें,

133
00:06:36,919 --> 00:06:38,960
त्रुटियों के तुम हो सकता है
अतीत में सामना करना पड़ा।

134
00:06:38,960 --> 00:06:41,335
तो चलो अलावा केवल छेड़ो
उन शब्दों है कि परिचित लग रही है।

135
00:06:41,335 --> 00:06:44,290
बड़े, लाल त्रुटि स्पष्ट रूप से है
कुछ का प्रतीक गलत जा रहा है।

136
00:06:44,290 --> 00:06:47,940
>> उलझाव की घोषणा
पुस्तकालय समारोह printf।

137
00:06:47,940 --> 00:06:51,680
तो भी अगर मैं काफी समझ में नहीं आता कि क्या
परोक्ष पुस्तकालय समारोह की घोषणा

138
00:06:51,680 --> 00:06:54,900
इसका मतलब है, निश्चित रूप से समस्या
किसी भी तरह printf से संबंधित है।

139
00:06:54,900 --> 00:06:59,130
और कहा कि इस मुद्दे का स्रोत
यह घोषणा के साथ नहीं है।

140
00:06:59,130 --> 00:07:02,440
>> घोषणा एक समारोह है
पहली बार के लिए यह उल्लेख।

141
00:07:02,440 --> 00:07:06,210
और हम पिछले हफ्ते शब्दावली का इस्तेमाल किया
एक समारोह के प्रोटोटाइप की घोषणा की,

142
00:07:06,210 --> 00:07:11,860
या तो के शीर्ष पर एक लाइन के साथ अपने
खुद फ़ाइल या एक तथाकथित हेडर फाइल में।

143
00:07:11,860 --> 00:07:15,300
और क्या हम फ़ाइल कहा था
पिछले हफ्ते कि printf उद्धरण है,

144
00:07:15,300 --> 00:07:17,080
गंदें शब्द बोलना, घोषित?

145
00:07:17,080 --> 00:07:20,950
क्या फाइल में अपने प्रोटोटाइप है?

146
00:07:20,950 --> 00:07:24,640
>> तो अगर आप याद है, बहुत पहले की बात मैं
टाइप, लगभग हर कार्यक्रम पिछले time--

147
00:07:24,640 --> 00:07:30,790
और गलती से एक पल पहले शुरू
myself-- लिखकर इस एक here-- था

148
00:07:30,790 --> 00:07:38,630
hash-- # शामिल <stio-- के लिए
इनपुट / output-- डॉट एच और वास्तव में,

149
00:07:38,630 --> 00:07:41,860
अगर मैं अब इस फाइल को बचाने के लिए, मैं जा रहा हूँ
आगे बढ़ो और अपनी स्क्रीन स्पष्ट करने,

150
00:07:41,860 --> 00:07:44,740
आप टाइप करके ऐसा कर सकते हैं जो
साफ है, या आप नियंत्रण एल पकड़ कर सकते हैं,

151
00:07:44,740 --> 00:07:47,680
बस अपने टर्मिनल विंडो स्पष्ट करने
बस कुछ अव्यवस्था को खत्म करने के लिए।

152
00:07:47,680 --> 00:07:51,370
>> मैं आगे जाने के लिए जा रहा हूँ और
फिर से लिखें buggy0 दर्ज करें।

153
00:07:51,370 --> 00:07:53,790
और देखा, मैं अभी भी उस देखना
बजना से लंबे आदेश,

154
00:07:53,790 --> 00:07:55,470
लेकिन वहाँ कोई त्रुटि संदेश इस समय है।

155
00:07:55,470 --> 00:07:58,800
और वास्तव में, अगर मैं ./buggy0 करते हैं,
अभी पिछली बार की तरह,

156
00:07:58,800 --> 00:08:01,860
जहां डॉट इसका मतलब यह है
निर्देशिका, स्लैश बस का अर्थ है,

157
00:08:01,860 --> 00:08:05,040
यहां कार्यक्रम का नाम आता है और
कार्यक्रम का नाम है कि buggy0 है,

158
00:08:05,040 --> 00:08:07,340
दर्ज, "हैलो, दुनिया।"

159
00:08:07,340 --> 00:08:09,440
>> अब, तुम कैसे हो सकता है
इस समाधान gleaned

160
00:08:09,440 --> 00:08:12,017
बिना जरूरी
के रूप में कई शब्दों को पहचानने

161
00:08:12,017 --> 00:08:14,350
के रूप में मैंने किया था, निश्चित रूप से, हो रही
इतने सालों के लिए यह किया?

162
00:08:14,350 --> 00:08:18,720
खैर, सबसे पहले समस्या प्रति एहसास
सेट, हम आपको एक आदेश से मिलवा

163
00:08:18,720 --> 00:08:21,175
कि CS50 के अपने स्टाफ
help50 नाम लिखा था।

164
00:08:21,175 --> 00:08:24,300
और वास्तव में, सी के लिए विशिष्टता करता है
समस्या यह कैसे उपयोग करने के लिए के रूप में निर्धारित किया है।

165
00:08:24,300 --> 00:08:27,210
>> लेकिन help50 अनिवार्य है
एक प्रोग्राम है कि CS50 के स्टाफ

166
00:08:27,210 --> 00:08:30,850
आप चलाने के लिए लिखा है कि अनुमति देता है
एक कमांड या एक कार्यक्रम चलाने के लिए,

167
00:08:30,850 --> 00:08:36,169
और अगर आप समझ में नहीं आता अपनी
उत्पादन, help50 करने के लिए अपने उत्पादन में पारित करने के लिए

168
00:08:36,169 --> 00:08:38,890
जिस पर सॉफ्टवेयर बिंदु
कि पाठ्यक्रम के कर्मचारियों ने लिखा है

169
00:08:38,890 --> 00:08:42,429
अपने कार्यक्रम के उत्पादन में दिखेगा
लाइन से लाइन, चरित्र द्वारा चरित्र।

170
00:08:42,429 --> 00:08:46,000
और अगर हम, स्टाफ, को पहचान
कि आप अनुभव कर रहे त्रुटि संदेश

171
00:08:46,000 --> 00:08:50,580
हम कुछ के साथ आप भड़काने की कोशिश करेंगे
बयानबाजी सवाल, कुछ सलाह के साथ,

172
00:08:50,580 --> 00:08:54,890
ज्यादा एक टीएफ या एक सीए या अपने आप की तरह
कार्यालय समय में व्यक्ति में क्या होगा।

173
00:08:54,890 --> 00:08:58,320
>> तो help50 को देखने के लिए अगर तुम नहीं करते
जरूरी नहीं कि एक समस्या को समझते हैं।

174
00:08:58,320 --> 00:09:00,790
लेकिन इस पर भरोसा नहीं है
एक बैसाखी के रूप में बहुत ज्यादा।

175
00:09:00,790 --> 00:09:03,990
निश्चित रूप से समझने की कोशिश अपने
उत्पादन और फिर इसे से सीख

176
00:09:03,990 --> 00:09:07,571
केवल इतना है कि एक या दो बार आप ऐसा करेंगे
कभी एक विशेष त्रुटि के लिए help50 चलाने

177
00:09:07,571 --> 00:09:08,070
संदेश।

178
00:09:08,070 --> 00:09:10,660
उसके बाद, आप होना चाहिए
अपने आप को बेहतर सुसज्जित

179
00:09:10,660 --> 00:09:13,180
यह पता लगाने के लिए क्या यह वास्तव में है।

180
00:09:13,180 --> 00:09:14,350
>> यहाँ एक दूसरे को करते हैं।

181
00:09:14,350 --> 00:09:20,410
मुझे आगे जाना है, और किसी अन्य रूप में करते हैं
फ़ाइल हम इस buggy1.c फोन करता हूँ।

182
00:09:20,410 --> 00:09:23,110
और इस फाइल में मैं हूँ
deliberately-- जा रहा

183
00:09:23,110 --> 00:09:26,330
लेकिन बहाना है कि मैं नहीं
समझने की क्या गलती मैंने बनाया है।

184
00:09:26,330 --> 00:09:31,420
>> मुझे आगे जाना है और this-- करने जा रहा हूँ
# शामिल है, क्योंकि मैं

185
00:09:31,420 --> 00:09:33,660
एक पल पहले से अपने सबक सीखा है।

186
00:09:33,660 --> 00:09:36,220
इंट मुख्य (शून्य) के रूप में पहले।

187
00:09:36,220 --> 00:09:40,880
और फिर यहाँ मैं जा रहा हूँ
स्ट्रिंग करने के लिए - get_string।

188
00:09:40,880 --> 00:09:43,770
और पिछली बार से याद है कि
इसका मतलब है, अरे, कंप्यूटर,

189
00:09:43,770 --> 00:09:48,280
मुझे एक चर देना, कॉल यह है, और
कि चर एक स्ट्रिंग के प्रकार बनाना

190
00:09:48,280 --> 00:09:50,150
इसलिए मैं इसे में एक या एक से अधिक शब्दों को स्टोर कर सकते हैं।

191
00:09:50,150 --> 00:09:52,191
>> और फिर दाएँ हाथ पर
बराबर चिह्न के पक्ष में

192
00:09:52,191 --> 00:09:54,980
get_string है, जो एक है
CS50 पुस्तकालय में समारोह

193
00:09:54,980 --> 00:09:55,980
कि ठीक है कि नहीं करता है।

194
00:09:55,980 --> 00:09:59,740
यह एक समारोह और फिर हो जाता है
सही से हाथ इसे छोड़ दिया है।

195
00:09:59,740 --> 00:10:02,670
तो यह बराबर चिह्न मतलब यह नहीं है
"बराबर" हम गणित में सोच सकते हैं के रूप में।

196
00:10:02,670 --> 00:10:04,750
यह दाईं से बाईं ओर से काम का मतलब है।

197
00:10:04,750 --> 00:10:09,640
तो इसका मतलब यह है, से तार ले लो
उपयोगकर्ता और यह एस के अंदर दुकान।

198
00:10:09,640 --> 00:10:10,460
>> अब इसका इस्तेमाल करते हैं।

199
00:10:10,460 --> 00:10:13,820
मुझे आगे अब और जाने के लिए एक दूसरे के रूप में करते हैं
लाइन, मुझे आगे जाना है और कहते हैं "नमस्ते" करते हैं -

200
00:10:13,820 --> 00:10:19,330
नहीं "दुनिया है," लेकिन "हैलो,% s--
जो हमारे प्लेसहोल्डर, अल्पविराम s है,

201
00:10:19,330 --> 00:10:22,030
जो हमारे चर रहा है,
और फिर एक अर्धविराम।

202
00:10:22,030 --> 00:10:26,070
तो अगर मैं बहुत ज्यादा बिगाड़ नहीं था
यहाँ, यह सही कोड की तरह लग रहा है।

203
00:10:26,070 --> 00:10:28,090
>> और मेरी प्रवृत्ति अब यह संकलन करने के लिए कर रहे हैं।

204
00:10:28,090 --> 00:10:30,400
फ़ाइल buggy1.c कहा जाता है।

205
00:10:30,400 --> 00:10:33,770
तो मैं buggy1 बनाने, दर्ज करने जा रहा हूँ।

206
00:10:33,770 --> 00:10:36,377
और रफ़ू-यह है, अगर वहाँ नहीं है
पहले की तुलना में और भी अधिक त्रुटियों।

207
00:10:36,377 --> 00:10:38,210
मेरा मतलब है, वहाँ और भी है
त्रुटि संदेश यह होगा

208
00:10:38,210 --> 00:10:40,400
इस कार्यक्रम में वास्तविक लाइनों की तुलना में लग रहे हैं।

209
00:10:40,400 --> 00:10:42,730
>> लेकिन takeaway यहाँ है,
भले ही आप अभिभूत हो

210
00:10:42,730 --> 00:10:45,040
दो या तीन या साथ
चार और त्रुटि संदेश,

211
00:10:45,040 --> 00:10:48,340
बहुत पर हमेशा ध्यान केंद्रित
उन संदेशों के पहले।

212
00:10:48,340 --> 00:10:52,220
सर्वोच्च एक को देख,
वापस ऊपर रूप में की जरूरत स्क्रॉल हो।

213
00:10:52,220 --> 00:10:53,930
यहाँ तो मैं मेकअप buggy1 टाइप।

214
00:10:53,930 --> 00:10:55,700
यहाँ है कि बजना उत्पादन की उम्मीद के रूप में है।

215
00:10:55,700 --> 00:10:57,290
>> और यहाँ पहली बार लाल त्रुटि है।

216
00:10:57,290 --> 00:11:02,370
अघोषित पहचानकर्ता का उपयोग
स्ट्रिंग, मैं में मानक मतलब था?

217
00:11:02,370 --> 00:11:04,260
तो मानक में है
वास्तव में कुछ और।

218
00:11:04,260 --> 00:11:06,240
यह उपयोगकर्ता के लिए संदर्भित करता है
कीबोर्ड, अनिवार्य।

219
00:11:06,240 --> 00:11:08,080
>> लेकिन यह है कि मैं क्या मतलब नहीं है।

220
00:11:08,080 --> 00:11:11,770
मैं स्ट्रिंग मतलब है, और मैं get_string मतलब था।

221
00:11:11,770 --> 00:11:16,200
तो क्या यह है कि मैं
इस बार भी ऐसा करने के लिए भूल गए हैं?

222
00:11:16,200 --> 00:11:20,230
क्या इस समय याद आ रही है?

223
00:11:20,230 --> 00:11:23,600
मैं अपने # शामिल है,
इसलिए मैं printf की पहुंच है।

224
00:11:23,600 --> 00:11:26,090
>> लेकिन मैं क्या जरूरत नहीं है
बस अभी तक के लिए उपयोग?

225
00:11:26,090 --> 00:11:29,420
खैर, अभी पिछली बार की तरह,
मैं संकलक बताने की जरूरत

226
00:11:29,420 --> 00:11:31,691
बजना क्या ये कार्य कर रहे हैं।

227
00:11:31,691 --> 00:11:33,940
Get_string नहीं आती है
सी के साथ और विशेष रूप से, यह

228
00:11:33,940 --> 00:11:38,160
में नहीं आता है
हेडर फाइल, ।

229
00:11:38,160 --> 00:11:40,770
यह बजाय में आता है
कुछ कर्मचारियों ने लिखा है,

230
00:11:40,770 --> 00:11:44,176
जो एक अलग फाइल है
नाम लेकिन जिसे उपयुक्त नाम।

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> तो बस एक लाइन है कि जोड़कर
पिछली बार से code-- याद की

233
00:11:50,861 --> 00:11:53,610
जब बजना चलाता है कि, यह क्या हो रहा है
नीचे करने के लिए अपने कोड के शीर्ष पर देखने के लिए,

234
00:11:53,610 --> 00:11:54,193
बाएं से दाएं।

235
00:11:54,193 --> 00:11:57,200
यह नोटिस करने जा रहा है
ओह, आप चाहते हैं।

236
00:11:57,200 --> 00:11:59,900
मुझे जाने और कहा कि पता करते हैं,
जहाँ भी यह सर्वर पर है,

237
00:11:59,900 --> 00:12:03,090
कॉपी और पेस्ट करें, अनिवार्य रूप से,
अपनी खुद की फ़ाइल के शीर्ष में

238
00:12:03,090 --> 00:12:06,820
तो यह है कि कहानी में इस बिंदु पर,
लाइन 1, कार्यक्रम के बाकी

239
00:12:06,820 --> 00:12:11,651
, वास्तव में, कार्यों के किसी भी उपयोग कर सकते हैं
उसमें उन के बीच में get_string।

240
00:12:11,651 --> 00:12:13,650
इसलिए मुझे लगता है की अनदेखी करने के लिए जा रहा हूँ
उन त्रुटियों के बाकी है,

241
00:12:13,650 --> 00:12:17,190
क्योंकि मैं, वास्तव में, यह है कि केवल संदेह
पहले एक वास्तव में मायने रखता है।

242
00:12:17,190 --> 00:12:20,780
और मैं आगे और फिर से दौड़ना जाने के लिए जा रहा हूँ
मेरी फाइल को बचाने के बाद buggy1 बनाते हैं।

243
00:12:20,780 --> 00:12:22,580
और देखा, यह काम किया है।

244
00:12:22,580 --> 00:12:29,200
और अगर मैं ./buggy1 करते हैं और, में टाइप करने के लिए
उदाहरण के लिए, Zamyla, मैं अब हैलो मिल जाएगा,

245
00:12:29,200 --> 00:12:32,000
Zamyla के बजाय, हैलो, दुनिया।

246
00:12:32,000 --> 00:12:32,550
>> ठीक है।

247
00:12:32,550 --> 00:12:35,890
तो यहाँ takeaways तो कर रहे हैं,
एक, के रूप में ज्यादा के रूप में आप कर सकते हैं बीनना करने की कोशिश

248
00:12:35,890 --> 00:12:39,140
अकेले त्रुटि संदेश से, तलाश
पहचानने शब्दों में से कुछ पर।

249
00:12:39,140 --> 00:12:43,070
को छोड़कर कि, प्रति help50 का उपयोग
समस्या सेट विनिर्देश।

250
00:12:43,070 --> 00:12:46,500
लेकिन छोड़कर वह भी, हमेशा देखो
शीर्ष त्रुटि पर ही है, कम से कम

251
00:12:46,500 --> 00:12:50,051
प्रारंभ में, देखने के लिए क्या जानकारी
यह वास्तव में उपज हो सकती है।

252
00:12:50,051 --> 00:12:52,300
लेकिन यह वहाँ है पता चला है
और भी अधिक कार्यक्षमता बनाया

253
00:12:52,300 --> 00:12:55,030
CS50 पुस्तकालय में मदद करने के लिए
आप पर जल्दी सेमेस्टर में

254
00:12:55,030 --> 00:12:57,580
और जल्दी पर प्रोग्रामिंग में
यह पता लगाने की क्या गलत हो रहा है।

255
00:12:57,580 --> 00:12:59,840
तो चलो एक और उदाहरण यहाँ क्या करते हैं।

256
00:12:59,840 --> 00:13:04,350
मैं, जो इस buggy2 फोन करने के लिए जा रहा हूँ,
फिर, बाहर त्रुटिपूर्ण होने जा रहा है

257
00:13:04,350 --> 00:13:05,650
गेट, डिजाइन द्वारा की।

258
00:13:05,650 --> 00:13:09,980
>> और मैं आगे जाने के लिए जा रहा हूँ
और # शामिल करना।

259
00:13:09,980 --> 00:13:12,580
और फिर मैं int मुख्य (शून्य) क्या करने जा रहा हूँ।

260
00:13:12,580 --> 00:13:14,840
और फिर मैं एक पाश के लिए क्या करने जा रहा हूँ।

261
00:13:14,840 --> 00:13:16,690
(मैं int _ 0।

262
00:13:16,690 --> 00:13:18,750
मैं कम से कम या 10 के बराबर है।

263
00:13:18,750 --> 00:13:24,260
मैं ++, और फिर घुंघराले ब्रेसिज़ में, मैं जा रहा हूँ
प्रिंट आउट करने के लिए यहाँ सिर्फ एक हैशटैग

264
00:13:24,260 --> 00:13:25,920
और एक नई लाइन चरित्र।

265
00:13:25,920 --> 00:13:29,220
>> इस के साथ मेरी मंशा तो
कार्यक्रम काफी बस है

266
00:13:29,220 --> 00:13:33,150
10 बार पुनरावृति
और प्रत्येक यात्रा पर

267
00:13:33,150 --> 00:13:35,260
कि पाश हर बार की
चक्र के माध्यम से,

268
00:13:35,260 --> 00:13:37,660
एक हैशटैग के बाहर प्रिंट,
एक हैशटैग, एक हैशटैग।

269
00:13:37,660 --> 00:13:40,480
मैं क्योंकि एक प्रति पंक्ति
वहां नई लाइन है।

270
00:13:40,480 --> 00:13:42,787
और उसके लिए याद करते हैं
पाश, पिछले week-- प्रति

271
00:13:42,787 --> 00:13:44,620
और आप अधिक मिलेगा
वाक्य रचना के साथ परिचित

272
00:13:44,620 --> 00:13:47,170
अभ्यास के साथ इसे का उपयोग करके
long-- से पहले यह मुझे देता है

273
00:13:47,170 --> 00:13:49,740
एक चर मैंने फोन किया और यह 0 से तय करता है।

274
00:13:49,740 --> 00:13:52,650
>> इस पर मैं वेतन वृद्धि
1 से हर चलना।

275
00:13:52,650 --> 00:13:54,940
तो मैं 2 से 3 करने के लिए 1 के लिए चला जाता है।

276
00:13:54,940 --> 00:13:57,690
और फिर इस हालत में
अर्द्ध कॉलन बीच बीच

277
00:13:57,690 --> 00:14:03,010
कराने के लिए हर यात्रा पर जाँच की जाती है
यकीन है कि हम सीमा के भीतर अभी भी कर रहे हैं।

278
00:14:03,010 --> 00:14:06,830
तो मैं 10 बार पुनरावृति करना चाहते हैं, तो मैं
राशि की तरह बहुत intuitively सिर्फ

279
00:14:06,830 --> 00:14:09,070
10 मेरे ऊपरी बाध्य वहाँ के रूप में डाल दिया।

280
00:14:09,070 --> 00:14:14,310
>> और फिर भी, जब मैं इस चलाते हैं, के बाद
मेकअप के साथ यह संकलन buggy2--

281
00:14:14,310 --> 00:14:15,440
और यह ठीक संकलन करता है।

282
00:14:15,440 --> 00:14:17,980
तो मैं एक की जरूरत नहीं है
सिंटेक्स त्रुटि इस बार।

283
00:14:17,980 --> 00:14:20,940
मुझे आगे अब चलते हैं
और buggy2 चलाने के लिए, दर्ज करें।

284
00:14:20,940 --> 00:14:22,620
और अब ऊपर स्क्रॉल।

285
00:14:22,620 --> 00:14:24,890
और मुझे वृद्धि करते हैं
खिड़की के आकार।

286
00:14:24,890 --> 00:14:33,720
>> मैं करने के लिए लग रहे हैं 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11।

287
00:14:33,720 --> 00:14:38,891
तो वहाँ, 11 हैशटैग है, भले ही
मैं स्पष्ट रूप से इस लूप के अंदर 10 डाल दिया।

288
00:14:38,891 --> 00:14:42,140
अब, आप में से कुछ को तुरंत देख सकते हैं
क्या त्रुटि है, क्योंकि वास्तव में, यह है

289
00:14:42,140 --> 00:14:43,720
एक बहुत ही मुश्किल त्रुटि को बनाने के लिए नहीं है।

290
00:14:43,720 --> 00:14:46,070
लेकिन यह बहुत सामान्य है
बहुत जल्दी पर बनाया है।

291
00:14:46,070 --> 00:14:49,820
>> क्या मैं बाहर बात करना चाहता है, हालांकि,
, कैसे मैं यह समझ सकता है?

292
00:14:49,820 --> 00:14:52,300
खैर, यह पता चला है कि
CS50 पुस्तकालय आता है

293
00:14:52,300 --> 00:14:55,380
न केवल get_string और get_int साथ
और get_float और अन्य कार्यों।

294
00:14:55,380 --> 00:14:59,980
यह भी एक विशेष समारोह के साथ आता है
कहा जाता है eprintf, या, त्रुटि printf।

295
00:14:59,980 --> 00:15:03,270
और यह पूरी तरह से मौजूद है बनाने के लिए
यह आप के लिए एक छोटा सा आसान

296
00:15:03,270 --> 00:15:06,310
जब बस के लिए अपने कोड डिबगिंग
स्क्रीन पर एक त्रुटि संदेश मुद्रित

297
00:15:06,310 --> 00:15:07,850
और पता है कि यह कहाँ से आया।

298
00:15:07,850 --> 00:15:11,000
>> तो उदाहरण के लिए, एक बात मैं हो सकता है
यहाँ क्या इस समारोह के साथ this-- है

299
00:15:11,000 --> 00:15:20,230
eprintf, और फिर मैं आगे जाने के लिए जा रहा हूँ
और कहते हैं कि मैं अब% है मैं, बैकस्लैश, एन।

300
00:15:20,230 --> 00:15:22,330
और मैं मैं के मूल्य में प्लग करने के लिए जा रहा हूँ।

301
00:15:22,330 --> 00:15:25,400
और ऊपर, इस वजह
CS50 पुस्तकालय में है,

302
00:15:25,400 --> 00:15:27,580
मैं आगे जाने के लिए जा रहा हूँ
और शामिल

303
00:15:27,580 --> 00:15:29,169
इसलिए मैं इस समारोह के लिए उपयोग किया है।

304
00:15:29,169 --> 00:15:31,460
लेकिन हम विचार करते हैं क्या लाइन
9 कर रही हो जाता है।

305
00:15:31,460 --> 00:15:32,670
मैं अंत में इसे हटाना जा रहा हूँ।

306
00:15:32,670 --> 00:15:34,670
यह कुछ नहीं करना है
मेरे व्यापक लक्ष्य के साथ।

307
00:15:34,670 --> 00:15:39,090
लेकिन eprintf, त्रुटि printf, बस मतलब है
मुझे कुछ नैदानिक ​​जानकारी देने के लिए।

308
00:15:39,090 --> 00:15:42,460
जब मैं अपने कार्यक्रम चलाने के लिए, मैं चाहता हूँ
अस्थायी रूप से स्क्रीन पर यह देखने के

309
00:15:42,460 --> 00:15:44,550
के रूप में अच्छी तरह से सिर्फ समझने के लिए
क्या चल रहा है।

310
00:15:44,550 --> 00:15:47,330
>> और, वास्तव में, पर प्रत्येक
9 लाइन के यहां चलना

311
00:15:47,330 --> 00:15:49,260
मैं देखना चाहता हूँ, मैं का मूल्य क्या है?

312
00:15:49,260 --> 00:15:50,290
मैं का मूल्य क्या है?

313
00:15:50,290 --> 00:15:51,280
मैं का मूल्य क्या है?

314
00:15:51,280 --> 00:15:55,650
और उम्मीद है, मैं केवल चाहिए
उस संदेश भी 10 बार देखते हैं।

315
00:15:55,650 --> 00:15:57,780
>> तो मुझे आगे जाना है और
मेरे प्रोग्राम कंपाइल,

316
00:15:57,780 --> 00:15:59,905
मैं किसी भी समय क्या करना है के रूप में
मैं एक परिवर्तन करते हैं। ./buggy2।

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
और now-- ठीक है।

319
00:16:03,640 --> 00:16:04,820
वहाँ एक बहुत अधिक चल रहा है।

320
00:16:04,820 --> 00:16:07,610
तो मुझे में स्क्रॉल
एक भी बड़ा खिड़की।

321
00:16:07,610 --> 00:16:10,190
>> और आप उस के प्रत्येक देखेंगे
हैशटैग अभी भी मुद्रण है।

322
00:16:10,190 --> 00:16:15,270
लेकिन बीच में उनमें से प्रत्येक अब यह है
नैदानिक ​​उत्पादन इस प्रकार के रूप में स्वरूपित।

323
00:16:15,270 --> 00:16:17,960
मेरे कार्यक्रम का नाम यहाँ buggy2 है।

324
00:16:17,960 --> 00:16:20,432
फ़ाइल का नाम buggy2.c है।

325
00:16:20,432 --> 00:16:24,080
लाइन नंबर से
इस छपा था 9 लाइन है।

326
00:16:24,080 --> 00:16:27,500
और फिर उस के अधिकार के लिए है
कि मैं उम्मीद कर रहा हूँ त्रुटि संदेश।

327
00:16:27,500 --> 00:16:30,701
>> और क्या अच्छा के बारे में यह है कि क्या है
अब मैं यह जरूरी गिनती के लिए नहीं है

328
00:16:30,701 --> 00:16:32,200
मेरे सिर में क्या अपने कार्यक्रम कर रही है।

329
00:16:32,200 --> 00:16:34,240
मैं उस पर देख सकते हैं
पहली यात्रा में मैं 0 है,

330
00:16:34,240 --> 00:16:39,420
तो 1, तो 2, तो 3, तो 4, तो
5, फिर 6, फिर 7, 8 तब, उसके बाद 9, तो

331
00:16:39,420 --> 00:16:40,980
10।

332
00:16:40,980 --> 00:16:42,050
तो एक मिनट रुको।

333
00:16:42,050 --> 00:16:43,740
यहाँ क्या चल रहा है?

334
00:16:43,740 --> 00:16:48,190
मैं अभी भी गिनती होने लगते हैं
के रूप में 10 से ऊपर का इरादा।

335
00:16:48,190 --> 00:16:50,550
>> लेकिन मैं कहाँ शुरू किया था?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10।

337
00:16:53,240 --> 00:16:58,040
तो 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 11 वीं 10-- उंगली

338
00:16:58,040 --> 00:16:59,990
समस्या का संकेत है।

339
00:16:59,990 --> 00:17:02,850
मैं गिना गए लगते हैं
गलत तरीके से अपने पाश में।

340
00:17:02,850 --> 00:17:06,599
10 पुनरावृत्तियों जाने के बजाय,
मैं 0 पर शुरू कर रहा हूँ,

341
00:17:06,599 --> 00:17:09,550
मैं कम और 10 के माध्यम से खत्म होने वाली हूँ।

342
00:17:09,550 --> 00:17:12,030
लेकिन क्योंकि, एक कंप्यूटर की तरह,
मैं 0 पर गिनती शुरू कर रहा हूँ,

343
00:17:12,030 --> 00:17:15,250
मैं गिन किया जाना चाहिए
करने के लिए, लेकिन 10 के माध्यम से, नहीं।

344
00:17:15,250 --> 00:17:18,510
>> और तो ठीक है, मैं अंत में
यहाँ का एहसास है, दो चीजों में से एक है।

345
00:17:18,510 --> 00:17:22,430
मैं बहुत आसानी से कह सकते हैं
कम से कम 10 तक गिनती।

346
00:17:22,430 --> 00:17:27,260
तो 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, जो है, वास्तव में, सही,

347
00:17:27,260 --> 00:17:28,900
यहां तक ​​कि यह एक छोटे से गलत लगता है यद्यपि।

348
00:17:28,900 --> 00:17:35,070
या मैं क्या कर सकता है की तुलना में कम या बराबर
9 के लिए इतने लंबे समय मैं 0 में शुरू के रूप में।

349
00:17:35,070 --> 00:17:40,056
या तुम सच में पसंद नहीं है, तो आप
के माध्यम से 10 तक गिनती लेकिन 1 पर शुरू कर सकते हैं।

350
00:17:40,056 --> 00:17:41,680
लेकिन फिर, यह बस नहीं है कि आम है।

351
00:17:41,680 --> 00:17:43,977
programming-- यद्यपि में
Scratch-- में इतना नहीं

352
00:17:43,977 --> 00:17:45,810
लेकिन प्रोग्रामिंग में
सी और अन्य भाषाओं,

353
00:17:45,810 --> 00:17:47,670
जावास्क्रिप्ट और पसंद
अजगर और दूसरे, यह है

354
00:17:47,670 --> 00:17:49,880
अभी के लिए बहुत आम
बाइनरी की हमारी चर्चा

355
00:17:49,880 --> 00:17:53,450
बस गिनती शुरू करने के लिए
सबसे कम संख्या आप कर सकते हैं, जो 0 है।

356
00:17:53,450 --> 00:17:53,950
ठीक है।

357
00:17:53,950 --> 00:17:55,160
तो यह है कि eprintf है।

358
00:17:55,160 --> 00:17:58,600
और फिर, अब मुझे पता लगा है कि मेरे
समस्या है, और मैं 0 करने के लिए वापस जाने के लिए जा रहा हूँ

359
00:17:58,600 --> 00:18:01,470
कम से कम 10 के माध्यम से, मैं जा रहा हूँ
में जाने के लिए और eprintf हटाने के लिए।

360
00:18:01,470 --> 00:18:04,580
>> यह वहाँ नहीं होना चाहिए जब मैं
मेरे कोड जहाज या मेरे कोड प्रस्तुत

361
00:18:04,580 --> 00:18:05,800
या इसे किसी और को दिखाने के लिए।

362
00:18:05,800 --> 00:18:07,980
यह वास्तव में सिर्फ मतलब है
अस्थायी रूप से इस्तेमाल किया जाएगा।

363
00:18:07,980 --> 00:18:11,650
लेकिन अब मैं यह तय कर लिया है
साथ ही विशेष समस्या नहीं है।

364
00:18:11,650 --> 00:18:16,780
>> ठीक है, चलो एक और उदाहरण यहाँ क्या करते हैं
कि मैं कोड़ा प्रकार के रूप में जा रहा हूँ।

365
00:18:16,780 --> 00:18:22,850
मैं आगे जाने के लिए जा रहा हूँ और
#शामिल । $ 50

366
00:18:22,850 --> 00:18:25,580
और मैं आगे जाने के लिए जा रहा हूँ
और # शामिल।

367
00:18:25,580 --> 00:18:29,030
>> और मुझे बचाने के लिए जा रहा हूँ
इस फ़ाइल buggy3.c के रूप में।

368
00:18:29,030 --> 00:18:31,740
और मैं आगे जाने के लिए जा रहा हूँ
और घोषणा int मुख्य (शून्य)।

369
00:18:31,740 --> 00:18:34,186
और फिर वहाँ के अंदर
मैं मैं int करने जा रहा हूँ _ -

370
00:18:34,186 --> 00:18:36,435
मैं एक कार्यक्रम को लागू करना चाहते हैं
एक get_negative_int के साथ।

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
यह एक समारोह अभी तक मौजूद है कि नहीं है।

373
00:18:40,770 --> 00:18:42,870
इसलिए हम को लागू करने के लिए जा रहे हैं
यह बस एक पल में।

374
00:18:42,870 --> 00:18:45,541
लेकिन हम क्यों देखने के लिए जा रहे हैं
यह पहली बार दर्रे पर छोटी गाड़ी है।

375
00:18:45,541 --> 00:18:47,290
और एक बार मैं डाल दिया है
उपयोगकर्ता से एक पूर्णांक,

376
00:18:47,290 --> 00:18:53,365
मैं सिर्फ% मैं मुद्रित करने के लिए जा रहा हूँ एक नकारात्मक है
पूर्णांक, बैकस्लैश, एन, अल्पविराम, मैं।

377
00:18:53,365 --> 00:18:55,240
दूसरे शब्दों में, यह सब मैं
इस कार्यक्रम के लिए करना चाहते हैं

378
00:18:55,240 --> 00:18:58,000
से एक नकारात्मक int मिलता है
उपयोगकर्ता और फिर बाहर प्रिंट

379
00:18:58,000 --> 00:18:59,980
कि इस तरह के और इस तरह के एक नकारात्मक int है।

380
00:18:59,980 --> 00:19:02,080
>> अब मैं इस समारोह को लागू करने की जरूरत है।

381
00:19:02,080 --> 00:19:05,740
तो मेरी फाइल में बाद में, मैं जा रहा हूँ
आगे और एक समारोह में कहा जाता घोषित

382
00:19:05,740 --> 00:19:10,670
get_negative_int (शून्य) - और हम करेंगे
करने के लिए वापस आने के लिए क्या मतलब है कि लाइन फिर से

383
00:19:10,670 --> 00:19:18,790
एक moment-- int n में; do-- Do
following-- printf n है :.

384
00:19:18,790 --> 00:19:26,210
और फिर मैं n क्या करने जा रहा हूँ - get_int,
और इस जबकि एन 0 से अधिक है।

385
00:19:26,210 --> 00:19:28,310
और फिर n लौटने के ;.

386
00:19:28,310 --> 00:19:31,730
>> तो एक बहुत में चल रहा है
इस पर जो कोई भी हम नहीं

387
00:19:31,730 --> 00:19:33,710
कम से कम संक्षेप में पिछले सप्ताह कम लग रही है।

388
00:19:33,710 --> 00:19:36,980
तो यहाँ लाइन 10 पर मैं घोषित किया है एक
समारोह get_negative_int कहा जाता है,

389
00:19:36,980 --> 00:19:39,620
और मैं डाल दिया है (शून्य), में
कोष्ठक, कारण यह जा रहा है

390
00:19:39,620 --> 00:19:40,950
एक इनपुट नहीं ले करता है।

391
00:19:40,950 --> 00:19:42,910
मैं कुछ भी नहीं गुजर रहा हूँ
इस समारोह के लिए।

392
00:19:42,910 --> 00:19:44,690
मैं बस कुछ इसे से वापस हो रही है।

393
00:19:44,690 --> 00:19:47,270
>> और क्या मैं उम्मीद कर रहा हूँ
वापस पाने के लिए एक पूर्णांक है।

394
00:19:47,270 --> 00:19:50,040
वहाँ में कोई डेटा प्रकार है
सी negative_int बुलाया।

395
00:19:50,040 --> 00:19:52,880
यह सिर्फ int है, तो यह जा रहा है
सुनिश्चित करने के लिए हम पर होना करने के लिए

396
00:19:52,880 --> 00:19:55,340
कि मूल्य वास्तव में है कि
वापस नहीं केवल एक int है

397
00:19:55,340 --> 00:19:56,380
लेकिन यह भी नकारात्मक है।

398
00:19:56,380 --> 00:20:02,150
>> लाइन 12 पर मैं एक चर घोषणा कर रहा हूँ
n और int प्रकार की इसे बनाने का आह्वान किया।

399
00:20:02,150 --> 00:20:07,500
और फिर लाइन 13 में से 18 के माध्यम से मैं कर रहा हूँ
कुछ कर रही है, जबकि कुछ सच है।

400
00:20:07,500 --> 00:20:11,040
मैं आगे और मुद्रण जा रहा हूँ
n है, पेट, और फिर एक जगह है,

401
00:20:11,040 --> 00:20:12,800
उपयोगकर्ता के लिए एक संकेत की तरह।

402
00:20:12,800 --> 00:20:16,410
>> मैं तो get_int बुला रहा हूँ और
अपनी तथाकथित वापसी मान के भंडारण

403
00:20:16,410 --> 00:20:18,130
उस चर n में।

404
00:20:18,130 --> 00:20:22,600
लेकिन मैं कर रखने के लिए जा रहा हूँ
इस जबकि एन 0 से अधिक है।

405
00:20:22,600 --> 00:20:27,960
दूसरे शब्दों में, उपयोगकर्ता मुझे एक देता है
int और यह संख्या 0 से अधिक है,

406
00:20:27,960 --> 00:20:31,180
फलस्वरूप, सकारात्मक, मैं जा रहा हूँ
सिर्फ उपयोगकर्ता reprompting रखने के लिए,

407
00:20:31,180 --> 00:20:37,160
reprompting रखने के लिए, उन्हें करने के लिए मजबूर द्वारा
सहयोग और मुझे एक नकारात्मक int दे।

408
00:20:37,160 --> 00:20:41,640
>> और एक बार n वास्तव में negative-- है
उपयोगकर्ता लगता है अंत में प्रकार -50,

409
00:20:41,640 --> 00:20:46,710
तो इस समय पाश अब सच है
क्योंकि -50 0 से अधिक नहीं है।

410
00:20:46,710 --> 00:20:51,140
तो हम उस से बाहर तोड़ने
पाश तार्किक और एन वापसी।

411
00:20:51,140 --> 00:20:53,520
>> लेकिन एक अन्य है
बात मुझे क्या करना है।

412
00:20:53,520 --> 00:20:56,190
और मैं बस यह कर सकते हैं
कॉपी करने और चिपकाने से

413
00:20:56,190 --> 00:20:58,540
फ़ाइल के शीर्ष पर कोड की एक पंक्ति।

414
00:20:58,540 --> 00:21:01,630
मैं, बजना सिखाने की जरूरत है
या बजना करने के लिए वादा करता हूँ,

415
00:21:01,630 --> 00:21:04,630
स्पष्ट है कि मैं लूंगा,
वास्तव में, जाने के लिए और लागू

416
00:21:04,630 --> 00:21:06,020
इस समारोह get_negative_int।

417
00:21:06,020 --> 00:21:07,674
यह सिर्फ फ़ाइल में कम हो सकता है।

418
00:21:07,674 --> 00:21:09,840
फिर, याद है कि बजना
ऊपर से नीचे बातों पर लिखा है,

419
00:21:09,840 --> 00:21:12,330
सही करने के लिए छोड़ दिया, तो तुम नहीं कर सकते
यदि बजना एक समारोह कॉल

420
00:21:12,330 --> 00:21:15,330
यह अस्तित्व में हो रहा है पता नहीं है।

421
00:21:15,330 --> 00:21:18,430
>> अब, दुर्भाग्य से, इस कार्यक्रम,
के रूप में आप में से कुछ देखा हो सकता है,

422
00:21:18,430 --> 00:21:19,590
पहले से ही छोटी गाड़ी है।

423
00:21:19,590 --> 00:21:21,400
मुझे आगे जाना है और buggy3 कर दूं।

424
00:21:21,400 --> 00:21:26,904
यह संकलन करता है, तो मेरी समस्या अब नहीं है
कोई सिंटैक्स त्रुटि, एक शाब्दिक त्रुटि की तरह,

425
00:21:26,904 --> 00:21:29,570
यह वास्तव में एक तार्किक होने जा रहा है
त्रुटि है कि मैं जानबूझ कर किया है

426
00:21:29,570 --> 00:21:32,450
करने के लिए एक अवसर के रूप में बनाया
क्या हो रहा है के माध्यम से कदम।

427
00:21:32,450 --> 00:21:35,540
>> मैं आगे जाने के लिए जा रहा हूँ
अब और buggy3 चलाते हैं।

428
00:21:35,540 --> 00:21:37,490
और मैं जाने के लिए जा रहा हूँ
आगे और नहीं सहयोग करते हैं।

429
00:21:37,490 --> 00:21:39,494
मैं यह संख्या 1 देने के लिए जा रहा हूँ।

430
00:21:39,494 --> 00:21:41,410
यह ऐसा नहीं था, इसलिए
यह मुझे फिर से उत्साह है।

431
00:21:41,410 --> 00:21:42,147
>> कैसे के बारे में 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
उन में से कोई भी काम कर रहे हैं।

435
00:21:44,740 --> 00:21:46,890
कैसे -50 के बारे में?

436
00:21:46,890 --> 00:21:48,560
और कार्यक्रम काम करने लगता है।

437
00:21:48,560 --> 00:21:49,970
>> मुझे यह एक बार फिर कोशिश करते हैं।

438
00:21:49,970 --> 00:21:53,400
मेरे -1 की कोशिश करते हैं, काम करने लगता है।

439
00:21:53,400 --> 00:21:56,380
मेरे -2 की कोशिश करते हैं, काम करने लगता है।

440
00:21:56,380 --> 00:21:59,640
मुझे 0 कोशिश करते हैं।

441
00:21:59,640 --> 00:22:01,684
हं, कि गलत है।

442
00:22:01,684 --> 00:22:03,350
अब, हम यहाँ एक छोटे से पंडिताऊ किया जा रहा हो।

443
00:22:03,350 --> 00:22:07,090
लेकिन यह है, वास्तव में, मामला यह है कि 0
न तो सकारात्मक और न ही नकारात्मक है।

444
00:22:07,090 --> 00:22:11,150
और तो तथ्य यह मेरे कार्यक्रम है कि
कह रही है, कि 0 एक नकारात्मक पूर्णांक है

445
00:22:11,150 --> 00:22:12,820
कि तकनीकी रूप से सही नहीं है।

446
00:22:12,820 --> 00:22:15,180
>> अब, यह यह क्यों कर रहा है?

447
00:22:15,180 --> 00:22:16,270
खैर, यह स्पष्ट हो सकता है।

448
00:22:16,270 --> 00:22:18,110
और, वास्तव में, इस कार्यक्रम है
काफी सरल होने का मतलब

449
00:22:18,110 --> 00:22:19,670
इसलिए हम पता लगाने के लिए कुछ है।

450
00:22:19,670 --> 00:22:25,870
>> लेकिन एक तिहाई डिबगिंग परिचय
तकनीक यहाँ debug50 बुलाया।

451
00:22:25,870 --> 00:22:27,750
तो यह एक कार्यक्रम है
हम अभी बनाया है कि

452
00:22:27,750 --> 00:22:30,770
इस साल कहा जाता debug50
कि आप की अनुमति देगा

453
00:22:30,770 --> 00:22:34,130
का उपयोग करने के लिए क्या एक निर्मित में कहा जाता है
CS50 आईडीई में चित्रमय डिबगर।

454
00:22:34,130 --> 00:22:38,400
और एक डिबगर सिर्फ एक प्रोग्राम है कि
आम तौर पर आप अपने प्रोग्राम चलाने देता है

455
00:22:38,400 --> 00:22:44,050
लेकिन कदम, लाइन से कदम से कदम
लाइन से लाइन द्वारा, रोक, poking

456
00:22:44,050 --> 00:22:47,626
चारों ओर, चर पर विचार कर रही है, ताकि
कार्यक्रम सिर्फ आप अतीत झटका नहीं है

457
00:22:47,626 --> 00:22:49,750
और जल्दी से कुछ प्रिंट
या कुछ और नहीं मुद्रित।

458
00:22:49,750 --> 00:22:53,250
यह आप का अवसर देता है, पर
मानव गति, इसके साथ बातचीत करने के लिए।

459
00:22:53,250 --> 00:22:55,470
>> और ऐसा करने के लिए, आप
बस निम्नलिखित है।

460
00:22:55,470 --> 00:22:58,479
अपने कोड संकलन के बाद,
जो मैं पहले से ही था, buggy3,

461
00:22:58,479 --> 00:23:00,020
तुम आगे बढ़ो और debug50 ./buggy चलाते हैं।

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
इतना पसंद help50 आप चलाने के लिए है
help50 और फिर कमान,

464
00:23:06,760 --> 00:23:10,120
debug50 आप debug50 चला गया है और
उसके बाद कमांड का नाम।

465
00:23:10,120 --> 00:23:14,440
>> अब देखना मेरा स्क्रीन पर क्या होता है,
विशेष रूप से दाएँ हाथ की ओर।

466
00:23:14,440 --> 00:23:19,400
जब मैं चला, के सभी हिट
अचानक इस दाएँ हाथ के पैनल

467
00:23:19,400 --> 00:23:20,419
स्क्रीन पर खुल जाता है।

468
00:23:20,419 --> 00:23:22,210
और वहाँ एक बहुत जा रहा है
पहली नज़र में पर।

469
00:23:22,210 --> 00:23:25,110
लेकिन वहाँ भी नहीं है
के बारे में अभी तक चिंता करने की ज्यादा।

470
00:23:25,110 --> 00:23:28,570
>> यह मुझे सब कुछ दिख रहा है
कि अपने कार्यक्रम के अंदर जा रहा है

471
00:23:28,570 --> 00:23:31,130
अभी और इन के माध्यम से
बटन शीर्ष तो है

472
00:23:31,130 --> 00:23:35,910
मुझे मेरे कोड के माध्यम से कदम के लिए अनुमति
अंत में कदम से कदम से कदम।

473
00:23:35,910 --> 00:23:37,140
लेकिन न सिर्फ अभी तक।

474
00:23:37,140 --> 00:23:38,060
सूचना है कि क्या होता है।

475
00:23:38,060 --> 00:23:40,600
मेरे टर्मिनल विंडो पर
मैं n के लिए प्रेरित किया जा रहा हूँ।

476
00:23:40,600 --> 00:23:44,560
और मैं आगे जाने के लिए जा रहा हूँ और
इस समय और -1 में टाइप सहयोग करते हैं।

477
00:23:44,560 --> 00:23:48,770
और यद्यपि एक छोटे cryptically, -1
एक नकारात्मक पूर्णांक, उम्मीद के रूप में है।

478
00:23:48,770 --> 00:23:52,020
>> और फिर बच्चे के साथ बाहर हुआ
स्थिति 0 gdbserver निकल।

479
00:23:52,020 --> 00:23:55,180
GDB, जीएनयू Debugger, नाम है
अंतर्निहित सॉफ्टवेयर की

480
00:23:55,180 --> 00:23:56,620
कि इस डिबगर लागू करता है।

481
00:23:56,620 --> 00:24:00,500
लेकिन यह सब वास्तव में इसका मतलब है, डिबगर
दूर चला गया क्योंकि मेरे प्रोग्राम से बाहर

482
00:24:00,500 --> 00:24:01,710
और सब कुछ ठीक था।

483
00:24:01,710 --> 00:24:06,020
मैं वास्तव में अपने कार्यक्रम डिबग करने के लिए चाहते हैं,
मैं, preemptively debug50 बताने के लिए है

484
00:24:06,020 --> 00:24:08,920
मैं कहाँ शुरू करने के लिए करना चाहते हैं
मेरे कोड के माध्यम से कदम?

485
00:24:08,920 --> 00:24:11,750
>> और शायद सबसे आसान तरीका
है कि इस प्रकार के रूप में है करने के लिए।

486
00:24:11,750 --> 00:24:15,300
अगर मैं पर हॉवर
मेरे संपादक के गटर यहाँ,

487
00:24:15,300 --> 00:24:19,090
इसलिए वास्तव में सिर्फ साइडबार में यहाँ,
लाइन नंबर के बाईं ओर,

488
00:24:19,090 --> 00:24:21,870
सूचना है कि अगर मैं बस क्लिक करें
एक बार, मैं एक छोटे लाल डॉट डाल दिया।

489
00:24:21,870 --> 00:24:24,460
और कहा कि छोटे लाल बिंदी,
एक बंद हस्ताक्षर की तरह है, जिसका अर्थ है, हे,

490
00:24:24,460 --> 00:24:29,430
debug50, मेरे कोड का ठहराव निष्पादन
सही वहाँ जब मैं इस कार्यक्रम चलाते हैं।

491
00:24:29,430 --> 00:24:30,260
>> तो चलो करते हैं।

492
00:24:30,260 --> 00:24:37,340
मुझे आगे जाना है और अपने कार्यक्रम चलाते हैं
debug50 ./buggy3 के साथ फिर से दर्ज करें।

493
00:24:37,340 --> 00:24:40,110
और अब, सूचना, कुछ
अलग हुआ है।

494
00:24:40,110 --> 00:24:42,440
मैं संकेत नहीं जा रहा हूँ
अभी तक मेरी टर्मिनल विंडो में

495
00:24:42,440 --> 00:24:45,430
कुछ के लिए, क्योंकि मैं नहीं किया है
मेरे प्रोग्राम में अभी तक वहाँ मिल गया।

496
00:24:45,430 --> 00:24:47,950
सूचना है कि 8 लाइन पर
जो अब प्रकाश डाला है,

497
00:24:47,950 --> 00:24:51,720
और वहाँ पर एक छोटा सा तीर है
बाएं कहावत है, आप यहाँ रोक दिए गए हैं।

498
00:24:51,720 --> 00:24:55,030
कोड, रेखा की यह पंक्ति
8, अभी तक क्रियान्वित नहीं किया गया है।

499
00:24:55,030 --> 00:24:58,940
>> और क्या अगर मैं देखो, उत्सुक है
दाएँ हाथ की ओर पर यहाँ पर,

500
00:24:58,940 --> 00:25:03,530
सूचना है कि मैं एक स्थानीय है
चर, इस अर्थ में स्थानीय

501
00:25:03,530 --> 00:25:05,450
कि यह वर्तमान समारोह के अंदर है।

502
00:25:05,450 --> 00:25:08,920
और इसकी कीमत, जाहिरा तौर पर डिफ़ॉल्ट रूप से,
और तरह की सुविधा, 0 है।

503
00:25:08,920 --> 00:25:10,260
लेकिन मैं 0 टाइप नहीं किया।

504
00:25:10,260 --> 00:25:13,410
वह सिर्फ होना होता है इसकी
पल में डिफ़ॉल्ट मान।

505
00:25:13,410 --> 00:25:15,490
>> तो मुझे आगे जाना है और अब यह करते हैं।

506
00:25:15,490 --> 00:25:18,680
मुझे आगे और पर चलते हैं
शीर्ष यहीं, मैं हूँ

507
00:25:18,680 --> 00:25:20,970
आगे जाने के लिए जा रहा है और
यह पहली आइकन पर क्लिक करें जो

508
00:25:20,970 --> 00:25:25,360
जिस पर कदम का मतलब को छोड़ नहीं है इसका मतलब है
लेकिन यह कोड की इस लाइन पर कदम,

509
00:25:25,360 --> 00:25:27,770
जिस तरह से साथ इसे क्रियान्वित।

510
00:25:27,770 --> 00:25:30,710
>> और अब, नोटिस, मेरे
शीघ्र सिर्फ बदल गया है।

511
00:25:30,710 --> 00:25:31,380
ऐसा क्यों है?

512
00:25:31,380 --> 00:25:33,639
मैं debug50 बता दिया है,
कोड की इस पंक्ति को चलाते हैं।

513
00:25:33,639 --> 00:25:34,930
कोड की इस पंक्ति क्या करता है?

514
00:25:34,930 --> 00:25:35,960
मेरे एक पूर्णांक के लिए संकेत देता है।

515
00:25:35,960 --> 00:25:36,460
ठीक।

516
00:25:36,460 --> 00:25:37,400
मेरे सहयोग करते हैं।

517
00:25:37,400 --> 00:25:41,340
मुझे आगे जाना है और अब टाइप -1, दर्ज करें।

518
00:25:41,340 --> 00:25:42,920
और अब नोटिस क्या बदल गया है।

519
00:25:42,920 --> 00:25:46,060
दाहिने हाथ की ओर,
मेरे स्थानीय चर रहा

520
00:25:46,060 --> 00:25:48,200
किया जा रहा -1 के रूप में अब संकेत दिया है।

521
00:25:48,200 --> 00:25:49,810
और यह int प्रकार का अब भी है।

522
00:25:49,810 --> 00:25:53,102
>> और नोटिस भी, मेरे तथाकथित
ढेर कहते हैं, मैं जहां थामने किया?

523
00:25:53,102 --> 00:25:54,810
हम के बारे में अधिक बात करेंगे
भविष्य में इस।

524
00:25:54,810 --> 00:25:58,620
लेकिन कॉल स्टैक बस के लिए संदर्भित करता है क्या
कार्यों के प्रस्ताव में वर्तमान में कर रहे हैं।

525
00:25:58,620 --> 00:26:00,040
अभी यह सिर्फ मुख्य है।

526
00:26:00,040 --> 00:26:03,590
और अभी केवल स्थानीय
चर 1 के एक मूल्य के साथ मैं है।

527
00:26:03,590 --> 00:26:09,840
>> और जब मैं अंत में इस लाइन पर कदम
इधर, सही शीर्ष पर है कि एक ही चिह्न के साथ,

528
00:26:09,840 --> 00:26:11,410
-1 एक नकारात्मक पूर्णांक है।

529
00:26:11,410 --> 00:26:13,580
अब यह है कि घुंघराले ब्रेस के ऊपर रोक रहा है।

530
00:26:13,580 --> 00:26:14,740
चलो यह अपनी बात करते चलो।

531
00:26:14,740 --> 00:26:17,300
मुझे लगता है कि लाइन, और देखा पर कदम।

532
00:26:17,300 --> 00:26:20,240
>> इसलिए नहीं कि सभी को बहुत
शिक्षाप्रद अभी तक,

533
00:26:20,240 --> 00:26:23,550
लेकिन यह जाने दिया मुझे थामने
और तार्किक माध्यम से लगता है

534
00:26:23,550 --> 00:26:24,870
इस कार्यक्रम के लिए क्या कर रही है।

535
00:26:24,870 --> 00:26:26,890
लेकिन यह है कि गलत मामला नहीं था।

536
00:26:26,890 --> 00:26:28,510
इस प्रकार के रूप में की यह फिर से करते हैं।

537
00:26:28,510 --> 00:26:31,340
>> मुझे लगता है कि ब्रेकप्वाइंट छोड़ने के लिए जा रहा हूँ
लाल बिंदी के साथ लाइन 8 पर।

538
00:26:31,340 --> 00:26:32,830
मैं फिर से दौड़ना debug50 करने जा रहा हूँ।

539
00:26:32,830 --> 00:26:34,400
यह स्वचालित रूप से यहां रुका हुआ है।

540
00:26:34,400 --> 00:26:37,660
लेकिन इस बार, बजाय
इस लाइन पर कदम,

541
00:26:37,660 --> 00:26:42,290
मुझे वास्तव में के अंदर जाने दिया
get_negative_int और यह पता लगाने,

542
00:26:42,290 --> 00:26:45,530
यही कारण है कि यह एक वैध जवाब के रूप में 0 स्वीकार कर रहा है?

543
00:26:45,530 --> 00:26:47,990
>> तो कदम पर क्लिक करने के बजाय।

544
00:26:47,990 --> 00:26:50,630
मैं आगे जाने के लिए जा रहा हूँ
और कदम क्लिक करें।

545
00:26:50,630 --> 00:26:54,030
और वह है कि लाइन 8 नोटिस
अब अचानक अब प्रकाश डाला

546
00:26:54,030 --> 00:26:56,900
लाइन 17 हो जाता है।

547
00:26:56,900 --> 00:26:59,947
>> अब, यह है कि डिबगर नहीं है
लाइनों 14 और 15 और 16 को छोड़ दिया गया है।

548
00:26:59,947 --> 00:27:01,780
यह सिर्फ वहाँ कुछ भी नहीं है है
तुम वहाँ दिखाने के लिए।

549
00:27:01,780 --> 00:27:04,050
उन सिर्फ चर घोषणा कर रहे हैं,
और फिर वहाँ शब्द क्या है

550
00:27:04,050 --> 00:27:05,390
और फिर एक खुला घुंघराले ब्रेस।

551
00:27:05,390 --> 00:27:09,227
केवल कार्यात्मक रेखा है कि
रसदार वास्तव में यह एक यहां, 17 है।

552
00:27:09,227 --> 00:27:11,060
और वह है जहाँ हम है है
स्वचालित रूप से रुका हुआ है।

553
00:27:11,060 --> 00:27:13,870
>> तो printf ( "n.is:") ;, इसलिए
जो कि अब तक नहीं हुआ है।

554
00:27:13,870 --> 00:27:18,250
तो चलो आगे जाना है और पर कदम क्लिक करते हैं।

555
00:27:18,250 --> 00:27:20,326
अब मेरी शीघ्र, वास्तव में,
करने के लिए बदल ( "n है:")।

556
00:27:20,326 --> 00:27:22,450
अब get_int, मैं नहीं जा रहा हूँ
में घुसने परेशान करने के लिए,

557
00:27:22,450 --> 00:27:24,750
क्योंकि उस समारोह था
लाइब्रेरी में CS50 द्वारा की गई।

558
00:27:24,750 --> 00:27:25,750
यह शायद सही है।

559
00:27:25,750 --> 00:27:28,440
>> तो मैं आगे जाने के लिए जा रहा हूँ और
एक तरह से यह देकर सहयोग

560
00:27:28,440 --> 00:27:30,590
एक int, लेकिन नहीं एक नकारात्मक इंट।

561
00:27:30,590 --> 00:27:32,870
तो मुझे आगे जाना है और 0 से मारा।

562
00:27:32,870 --> 00:27:39,460
और अब यहाँ क्या होता है
21 लाइन के लिए जब मैं नीचे मिलता है?

563
00:27:39,460 --> 00:27:40,890
मैं फिर से दोहराया नहीं है।

564
00:27:40,890 --> 00:27:43,320
मुझे लगता है कि पाश में फंस गया हो ऐसा नहीं लगता है।

565
00:27:43,320 --> 00:27:45,990
दूसरे शब्दों में, इस पीले
पट्टी के चारों ओर जा रहा नहीं रखा था,

566
00:27:45,990 --> 00:27:47,130
और चारों ओर, और चारों ओर।

567
00:27:47,130 --> 00:27:48,340
>> अब, ऐसा क्यों है?

568
00:27:48,340 --> 00:27:49,920
खैर, एन, क्या अब ठीक n है?

569
00:27:49,920 --> 00:27:53,280
मैं स्थानीय पर देख सकते हैं
debugger में चर।

570
00:27:53,280 --> 00:27:53,816
एन 0 है।

571
00:27:53,816 --> 00:27:55,190
ठीक है, मेरी हालत क्या थी?

572
00:27:55,190 --> 00:27:58,700
>> 20-- लाइन 20, ठीक है,
0 0 से अधिक है।

573
00:27:58,700 --> 00:27:59,500
वह सच नहीं है।

574
00:27:59,500 --> 00:28:01,020
0 0 से अधिक नहीं है।

575
00:28:01,020 --> 00:28:02,820
और इसलिए मैं इस से बाहर तोड़ दिया।

576
00:28:02,820 --> 00:28:06,370
>> और तो यही कारण है कि लाइन पर है
21, मैं वास्तव में जारी है,

577
00:28:06,370 --> 00:28:10,370
मैं 0 वापस करने के लिए जा रहा हूँ, भले
हालांकि मैं 0 खारिज कर दिया जाना चाहिए था

578
00:28:10,370 --> 00:28:12,484
के रूप में वास्तव में नकारात्मक नहीं किया जा रहा।

579
00:28:12,484 --> 00:28:14,650
तो अब, मैं वास्तव में भी नहीं है
डिबगर के बारे में परवाह है।

580
00:28:14,650 --> 00:28:16,900
यह, मैं करने की जरूरत नहीं मिला
पता है क्या और अधिक जा रहा है।

581
00:28:16,900 --> 00:28:19,233
>> तो मैं आगे जाने के लिए जा रहा हूँ और
सिर्फ खेलने के बटन पर क्लिक करें,

582
00:28:19,233 --> 00:28:20,240
और यह खत्म करते हैं।

583
00:28:20,240 --> 00:28:23,440
अब, मुझे लगता है कि एहसास हुआ है मेरी
बग लाइन 20 पर जाहिरा तौर पर है।

584
00:28:23,440 --> 00:28:25,160
यही कारण है कि मेरी तार्किक त्रुटि है।

585
00:28:25,160 --> 00:28:28,100
>> और तो क्या मैं चाहता हूँ
इस परिवर्तन के लिए क्या करना है?

586
00:28:28,100 --> 00:28:32,500
समस्या यह है कि अगर मैं नहीं हूँ
0 पकड़ने, यह सिर्फ एक तार्किक त्रुटि है।

587
00:28:32,500 --> 00:28:35,910
और मैं कह सकता है, जबकि n
से अधिक या 0 के बराबर है,

588
00:28:35,910 --> 00:28:38,330
उपयोगकर्ता को बार-बार याद दिलाने की क्रिया रहते हैं।

589
00:28:38,330 --> 00:28:41,050
>> तो, फिर से, साधारण गलती, शायद
यहां तक ​​कि स्पष्ट है जब तुमने मुझे देखा

590
00:28:41,050 --> 00:28:42,410
यह बस कुछ ही मिनट पहले लिखें।

591
00:28:42,410 --> 00:28:44,570
लेकिन यहाँ takeaway
है डिबग 50 के साथ कि,

592
00:28:44,570 --> 00:28:46,850
और डिबगिंग के साथ
सॉफ्टवेयर और अधिक आम तौर पर,

593
00:28:46,850 --> 00:28:51,370
आप को इस नए पाया शक्ति है
अपने खुद के कोड के माध्यम से चलना, देखो

594
00:28:51,370 --> 00:28:55,590
कि दाहिने हाथ पैनल के माध्यम से क्या
आपके चर मान रहे हैं।

595
00:28:55,590 --> 00:28:57,700
तो आप जरूरी नहीं है
कुछ का उपयोग करने के लिए है

596
00:28:57,700 --> 00:29:00,630
आप की तरह उन मूल्यों को मुद्रित करने के लिए eprintf।

597
00:29:00,630 --> 00:29:04,430
आप वास्तव में उन्हें देख सकते हैं
नेत्रहीन स्क्रीन पर।

598
00:29:04,430 --> 00:29:08,920
>> अब, इस के अलावा, यह ध्यान देने योग्य है
वहाँ एक और तकनीक है कि है कि

599
00:29:08,920 --> 00:29:09,890
वास्तव में सुपर आम है।

600
00:29:09,890 --> 00:29:13,120
और आप शायद पता नहीं क्यों इस छोटी सी
यहां पुरुष मंच पर बैठा दिया गया है।

601
00:29:13,120 --> 00:29:16,490
तो इस तकनीक है, आम तौर पर
रबर बतख डिबगिंग के रूप में जाना जाता है,

602
00:29:16,490 --> 00:29:18,786
जो वास्तव में सिर्फ एक है
इस तथ्य को वसीयतनामा

603
00:29:18,786 --> 00:29:20,660
कि अक्सर जब प्रोग्रामर
कोड लिख रहे हैं,

604
00:29:20,660 --> 00:29:22,650
वे जरूरी नहीं हो
दूसरों के साथ सहयोग,

605
00:29:22,650 --> 00:29:24,030
या एक साझा वातावरण में काम कर रहे।

606
00:29:24,030 --> 00:29:25,050
>> वे घर पर की तरह कर रहे हैं।

607
00:29:25,050 --> 00:29:25,910
हो सकता है कि यह रात में देर हो चुकी है।

608
00:29:25,910 --> 00:29:28,190
वे लगाने की कोशिश कर रहे हैं
अपने कोड में कुछ बग बाहर।

609
00:29:28,190 --> 00:29:29,330
और वे सिर्फ यह नहीं देख रहे हैं।

610
00:29:29,330 --> 00:29:30,329
>> और कोई रूममेट है।

611
00:29:30,329 --> 00:29:31,250
इसमें कोई टीएफ है।

612
00:29:31,250 --> 00:29:32,680
वहाँ के आसपास कोई सीए है।

613
00:29:32,680 --> 00:29:36,440
वे सब उनकी शेल्फ पर है
इस छोटे से रबर लालित्य है।

614
00:29:36,440 --> 00:29:39,030
>> और तो रबर बतख डिबगिंग
सिर्फ इस निमंत्रण है

615
00:29:39,030 --> 00:29:42,780
मूर्ख के रूप में कुछ सोचने के लिए
इस रूप में एक असली प्राणी के रूप में,

616
00:29:42,780 --> 00:29:46,940
और वास्तव में अपने कोड के माध्यम से चलना
मौखिक रूप से इस निर्जीव वस्तु के लिए।

617
00:29:46,940 --> 00:29:49,230
तो, उदाहरण के लिए, अगर
यह मेरा उदाहरण है here--

618
00:29:49,230 --> 00:29:52,470
और कहा कि पहले से याद करते हैं
समस्या यह थी,

619
00:29:52,470 --> 00:29:58,140
अगर मैं कोड की इस पहली पंक्ति को हटा दें,
और मुझे आगे जाना है और फिर छोटी गाड़ी 0 बनाने,

620
00:29:58,140 --> 00:30:01,220
याद है कि मैं इन थी
यहाँ त्रुटि संदेश।

621
00:30:01,220 --> 00:30:05,997
तो यहाँ विचार है, हालांकि मैं हास्यास्पद
पल में लगता है कि यह सार्वजनिक रूप से कर रही है,

622
00:30:05,997 --> 00:30:06,580
कि त्रुटि है।

623
00:30:06,580 --> 00:30:10,910
>> ठीक है, तो मेरी समस्या यह है कि मैं है
उलझाव से एक पुस्तकालय समारोह की घोषणा की।

624
00:30:10,910 --> 00:30:12,610
और कहा कि पुस्तकालय समारोह printf है।

625
00:30:12,610 --> 00:30:15,290
Declare-- ठीक है, घोषित
मेरे प्रोटोटाइप की याद दिलाता है।

626
00:30:15,290 --> 00:30:18,930
>> इसका मतलब है कि मैं वास्तव में करने की जरूरत है
अग्रिम में संकलक बताओ कि क्या

627
00:30:18,930 --> 00:30:19,980
समारोह की तरह लग रहा है।

628
00:30:19,980 --> 00:30:20,930
एक मिनट रुकिए।

629
00:30:20,930 --> 00:30:23,580
मैं मानक io.h. नहीं था

630
00:30:23,580 --> 00:30:24,530
आपका बहुत बहुत धन्यवाद।

631
00:30:24,530 --> 00:30:27,330
>> तो बस आप of-- इस प्रक्रिया
वास्तव में एक बतख की जरूरत नहीं है।

632
00:30:27,330 --> 00:30:29,819
लेकिन चलने के इस विचार
अपने आप को अपने खुद के कोड के माध्यम से

633
00:30:29,819 --> 00:30:31,610
तो आप भी सुना है कि
अपने आप को, इतना है कि आप

634
00:30:31,610 --> 00:30:35,620
अपने खुद में चूक का एहसास
टिप्पणी, आम तौर पर विचार है।

635
00:30:35,620 --> 00:30:38,910
>> और, शायद अधिक तार्किक रूप से, नहीं तो
कि एक है, लेकिन अधिक शामिल साथ ज्यादा

636
00:30:38,910 --> 00:30:44,220
उदाहरण हम सिर्फ छोटी गाड़ी 3.C में किया था,
आप इसे माध्यम से अपने आप चल सकता है

637
00:30:44,220 --> 00:30:45,310
निम्नलिखित नुसार।

638
00:30:45,310 --> 00:30:49,190
तो सब ठीक है, रबर
लालित्य, डीडीबी, अगर तुम जाएगा।

639
00:30:49,190 --> 00:30:52,350
यहाँ हम अपने मुख्य समारोह में है,
मैं नकारात्मक int मिल बुला रहा हूँ।

640
00:30:52,350 --> 00:30:54,660
>> और मैं वापसी मूल्य मिल रहा है।

641
00:30:54,660 --> 00:31:00,410
मैं बाएं हाथ की ओर यह भंडारण कर रहा हूँ
एक चर में 8 लाइन पर मैंने कहा जाता है।

642
00:31:00,410 --> 00:31:02,380
ठीक है, लेकिन रुकिए, कैसे किया
जो उस मूल्य मिलता है?

643
00:31:02,380 --> 00:31:04,130
मुझे लाइन 12 में समारोह पर नजर डालते हैं।

644
00:31:04,130 --> 00:31:05,760
>> 12 लाइन में, हम नकारात्मक int मिलता है।

645
00:31:05,760 --> 00:31:08,190
किसी भी जानकारी नहीं ले करता है,
एक पूर्णांक के ठीक वापस नहीं करता।

646
00:31:08,190 --> 00:31:10,929
मैं रेखा 14 एक चर n पर घोषणा।

647
00:31:10,929 --> 00:31:12,220
यह एक पूर्णांक स्टोर करने के लिए जा रहा है।

648
00:31:12,220 --> 00:31:13,760
मैं यही चाहता था।

649
00:31:13,760 --> 00:31:18,480
>> तो निम्नलिखित जबकि एन है- चलो
मेरे पूर्ववत क्या तय मैं पहले से ही बनाया है।

650
00:31:18,480 --> 00:31:22,710
तो, जबकि एन से अधिक है
0, प्रिंट आउट n है, ठीक है।

651
00:31:22,710 --> 00:31:25,170
और फिर कॉल int n में जमा हो।

652
00:31:25,170 --> 00:31:30,160
और फिर जांच, अगर एन 0 है
n not-- वहाँ यह है।

653
00:31:30,160 --> 00:31:31,910
तो, फिर से, तुम नहीं करते
वास्तविक बतख की जरूरत है।

654
00:31:31,910 --> 00:31:35,650
लेकिन सिर्फ खुद के माध्यम से चल रहा
एक बौद्धिक व्यायाम के रूप में अपने कोड

655
00:31:35,650 --> 00:31:37,720
अक्सर आप में मदद मिलेगी
एहसास क्या हो रहा है,

656
00:31:37,720 --> 00:31:41,170
बस के रूप में कुछ कर रही करने का विरोध किया
इस तरह, स्क्रीन घूर,

657
00:31:41,170 --> 00:31:43,720
और अपने आप के माध्यम से बात नहीं कर रहा
यह है, जो ईमानदारी से नहीं है

658
00:31:43,720 --> 00:31:46,270
लगभग एक प्रभावी तकनीक के रूप में।

659
00:31:46,270 --> 00:31:48,620
तो क्या तुम वहाँ यह है, एक
विभिन्न तकनीकों की संख्या

660
00:31:48,620 --> 00:31:52,102
वास्तव में अपने कोड डीबगिंग के लिए
और गलती खोजने, जो सभी के लिए

661
00:31:52,102 --> 00:31:54,810
अपने टूलकिट में उपकरण होना चाहिए
कि आप रात में देर नहीं हो तो,

662
00:31:54,810 --> 00:31:57,660
विशेष रूप से, आप भोजन में हो
हॉल, या कार्यालय समय में,

663
00:31:57,660 --> 00:32:00,368
के खिलाफ अपना सिर पीटने
दीवार, कुछ समस्या को हल करने के लिए कोशिश कर रहा।

664
00:32:00,368 --> 00:32:02,020
एहसास है कि वहाँ सॉफ्टवेयर उपकरण हैं।

665
00:32:02,020 --> 00:32:03,720
वहाँ रबर बतख उपकरण हैं।

666
00:32:03,720 --> 00:32:09,630
और वहाँ के एक पूरे स्टाफ है
एक हाथ उधार देने के लिए इंतजार कर समर्थन करते हैं।

667
00:32:09,630 --> 00:32:13,120
>> तो अब, इस समस्या पर एक शब्द
सेट, और हम आप क्या उम्मीद कर रहे हैं पर

668
00:32:13,120 --> 00:32:15,620
उनमें से बाहर निकलना, और कैसे
हम मूल्यांकन के बारे में जाना।

669
00:32:15,620 --> 00:32:17,680
प्रति पाठ्यक्रम के पाठ्यक्रम,
CS50 की समस्या सेट

670
00:32:17,680 --> 00:32:22,320
चार प्राथमिक कुल्हाड़ियों पर मूल्यांकन किया जाता है, तो
गुंजाइश speak-- करने के लिए, शुद्धता, डिजाइन,

671
00:32:22,320 --> 00:32:23,060
और शैली।

672
00:32:23,060 --> 00:32:25,910
और गुंजाइश अभी कितना संदर्भित करता है
टुकड़ा आप काट लिया है?

673
00:32:25,910 --> 00:32:28,080
आप कैसे एक समस्या की बहुत कोशिश की है?

674
00:32:28,080 --> 00:32:30,110
प्रयास का स्तर क्या
आप प्रकट किया है?

675
00:32:30,110 --> 00:32:35,750
>> शुद्धता, है के रूप में कार्यक्रम काम करता है
यह CS50 विनिर्देश के अनुसार माना जाता है

676
00:32:35,750 --> 00:32:38,640
जब आप कुछ जानकारी प्रदान
या कुछ outputs वापस आ रहा है?

677
00:32:38,640 --> 00:32:41,130
डिजाइन उनमें से ज्यादातर व्यक्तिपरक है।

678
00:32:41,130 --> 00:32:43,360
और यह है कि विल के
सबसे लंबे समय तक लेने के लिए सीखने के लिए

679
00:32:43,360 --> 00:32:47,220
और सबसे लंबे समय तक पढ़ाने के लिए, में
अब तक यह करने के लिए नीचे फोड़े के रूप में,

680
00:32:47,220 --> 00:32:49,530
कैसे अच्छी तरह से लिखा अपने कोड है?

681
00:32:49,530 --> 00:32:52,920
>> यह एक बात सिर्फ सही मुद्रित करने के लिए है
outputs या सही मान।

682
00:32:52,920 --> 00:32:55,400
लेकिन आप इसे के रूप में कर रहे हैं
कुशलता से संभव के रूप में?

683
00:32:55,400 --> 00:32:58,210
तुम यह विभाजन कर रहे हैं
और जीत के लिए, या बाइनरी

684
00:32:58,210 --> 00:33:01,500
खोज के रूप में हम जल्द ही देखेंगे कि हम किया था
दो सप्ताह पहले फोन की किताब के साथ?

685
00:33:01,500 --> 00:33:04,670
वहाँ हल करने के लिए बेहतर तरीके हैं
समस्या आप वर्तमान में यहाँ से?

686
00:33:04,670 --> 00:33:06,380
यही कारण है कि बेहतर डिजाइन के लिए एक अवसर है।

687
00:33:06,380 --> 00:33:08,530
>> और फिर कैसे style--
सुंदर अपने कोड है?

688
00:33:08,530 --> 00:33:12,370
तुम नोटिस हूँ कि मैं सुंदर हूँ
मेरे कोड इंडेंट के बारे में विशेष रूप से,

689
00:33:12,370 --> 00:33:15,300
और यकीन है कि मेरे चर बनाने
यथोचित नाम हैं। n,

690
00:33:15,300 --> 00:33:19,660
थोड़ी देर के लिए, एक के लिए एक अच्छा नाम है
संख्या, एक गिनती पूर्णांक के लिए मैं,

691
00:33:19,660 --> 00:33:20,727
एक स्ट्रिंग के लिए है।

692
00:33:20,727 --> 00:33:22,560
और हम अब हो सकता है
चर नाम शैली।

693
00:33:22,560 --> 00:33:25,500
शैली बस कितना अच्छा है
अपने कोड दिखता है?

694
00:33:25,500 --> 00:33:26,600
और यह कैसे पठनीय है?

695
00:33:26,600 --> 00:33:29,650
>> और समय के साथ, जो अपने TAs
और TFS पाठ्यक्रम में क्या करेंगे

696
00:33:29,650 --> 00:33:31,870
उस के साथ आप प्रदान कर रहा है
गुणात्मक प्रतिक्रिया की तरह

697
00:33:31,870 --> 00:33:34,330
इतनी है कि आप बेहतर हो
उन विभिन्न पहलुओं पर।

698
00:33:34,330 --> 00:33:37,510
और हम कैसे के मामले में
इन कुल्हाड़ियों से प्रत्येक का मूल्यांकन,

699
00:33:37,510 --> 00:33:40,080
यह बहुत कुछ के साथ आमतौर पर है
बाल्टी इतनी है कि आप, आम तौर पर,

700
00:33:40,080 --> 00:33:41,680
आप कितनी अच्छी तरह से कर रहे हैं की भावना हो।

701
00:33:41,680 --> 00:33:45,680
और, वास्तव में, तुम पर एक अंक प्राप्त करते हैं
उन axes-- शुद्धता, डिजाइन के किसी भी

702
00:33:45,680 --> 00:33:49,659
और शैली especially-- कि संख्या
आम तौर पर 1 और 5 के बीच होगा।

703
00:33:49,659 --> 00:33:52,450
और, सचमुच, तुम हो रही है, तो
सत्र की शुरुआत में 3 है,

704
00:33:52,450 --> 00:33:53,977
यह एक बहुत ही अच्छी बात है।

705
00:33:53,977 --> 00:33:55,810
इसका मतलब यह है कि वहाँ अभी भी है
सुधार की गुंजाइश,

706
00:33:55,810 --> 00:33:58,490
आप में उम्मीद करेंगे जो
पहली बार के लिए एक क्लास लेने।

707
00:33:58,490 --> 00:34:01,820
वहाँ उम्मीद है कि छत के कुछ सा है
जो करने के लिए आप तक पहुंचने के लिए इच्छुक रहे हैं।

708
00:34:01,820 --> 00:34:03,970
और तो 3 'पर हो रही है
जल्द से जल्द टुकड़े,

709
00:34:03,970 --> 00:34:06,550
नहीं तो कुछ 2 और 4 की,
, वास्तव में, एक अच्छी बात है।

710
00:34:06,550 --> 00:34:08,880
यह अच्छी तरह से सीमा के भीतर है,
अच्छी तरह से उम्मीदों के भीतर।

711
00:34:08,880 --> 00:34:11,421
>> और अगर आपके मन में दौड़ रहा है, इंतजार
एक मिनट, तीन से पांच के बाहर।

712
00:34:11,421 --> 00:34:12,620
यही कारण है कि वास्तव में 10 की एक 6 बाहर है।

713
00:34:12,620 --> 00:34:13,560
यही कारण है कि 60% है।

714
00:34:13,560 --> 00:34:14,830
हे भगवान, एक एफ है कि

715
00:34:14,830 --> 00:34:15,870
>> यह।

716
00:34:15,870 --> 00:34:17,600
यह नहीं है, वास्तव में है।

717
00:34:17,600 --> 00:34:22,710
दरअसल, यह सुधार करने के लिए एक अवसर है
सेमेस्टर के पाठ्यक्रम पर।

718
00:34:22,710 --> 00:34:25,580
और अगर आप कुछ हो रही है
Poors, ये एक अवसर है

719
00:34:25,580 --> 00:34:29,199
कार्यालय समय का लाभ लेने के लिए,
निश्चित रूप से वर्गों और अन्य संसाधनों।

720
00:34:29,199 --> 00:34:32,840
>> बेस्ट का अवसर है, वास्तव में, है
आप अभी कितनी दूर है पर गर्व होना करने के लिए

721
00:34:32,840 --> 00:34:34,520
सेमेस्टर के पाठ्यक्रम पर आते हैं।

722
00:34:34,520 --> 00:34:38,199
इसलिए महसूस करते हैं, अगर कुछ भी नहीं
वरना, तीन अच्छा है।

723
00:34:38,199 --> 00:34:40,179
और यह समय के साथ विकास के लिए कमरे की अनुमति देता है।

724
00:34:40,179 --> 00:34:43,090
>> कैसे उन कुल्हाड़ियों कर रहे हैं
भारित, वास्तविक आप कर रहे हैं

725
00:34:43,090 --> 00:34:46,745
हो रही अपने समय के सबसे अधिक खर्च करने जा रहा
काम करने के लिए चीजें, सही ढंग से अकेले चलो।

726
00:34:46,745 --> 00:34:49,120
और इसलिए शुद्धता के लिए जाता है
साथ के रूप में, सबसे भारित किया

727
00:34:49,120 --> 00:34:51,360
तीन के इस गुणक कारक है।

728
00:34:51,360 --> 00:34:54,659
डिजाइन, यह भी महत्वपूर्ण है, लेकिन
कुछ है कि आप जरूरी नहीं है

729
00:34:54,659 --> 00:34:58,220
उन घंटे के सभी पर खर्च
चीजें सिर्फ काम करने के लिए प्राप्त करने की कोशिश।

730
00:34:58,220 --> 00:35:00,019
>> और इसलिए यह भारित है
एक छोटे से अधिक हल्के से।

731
00:35:00,019 --> 00:35:01,560
और फिर शैली कम से कम भारित है।

732
00:35:01,560 --> 00:35:03,710
यहां तक ​​कि यह भी कम नहीं है, हालांकि
मूल रूप से महत्वपूर्ण,

733
00:35:03,710 --> 00:35:05,990
यह सिर्फ, शायद,
आसान बात सही है,

734
00:35:05,990 --> 00:35:08,440
उदाहरण हम नकल उतार
व्याख्यान और इस खंड में करते हैं,

735
00:35:08,440 --> 00:35:11,080
चीजों को अच्छी तरह से
दांतेदार, और टिप्पणी की,

736
00:35:11,080 --> 00:35:14,320
और इसके आगे के लिए सबसे आसान के बीच है
बातें करते हैं और अधिकार पाने के लिए।

737
00:35:14,320 --> 00:35:16,960
इसलिए इस तरह के रूप में, एहसास
कि उन अंक हैं

738
00:35:16,960 --> 00:35:19,000
कि काबू करने के लिए अपेक्षाकृत आसान कर रहे हैं।

739
00:35:19,000 --> 00:35:22,360
>> और अब एक शब्द पर
शैक्षणिक ईमानदारी this--।

740
00:35:22,360 --> 00:35:25,150
तो पाठ्यक्रम के प्रति
पाठ्यक्रम, आप देखेंगे

741
00:35:25,150 --> 00:35:27,630
कोर्स है कि काफी
इस के आसपास भाषा का सा।

742
00:35:27,630 --> 00:35:31,380
और निश्चित रूप से इस मुद्दे को ले जाता है
काफी गंभीरता से शैक्षणिक ईमानदारी।

743
00:35:31,380 --> 00:35:33,450
>> हम गौरव प्राप्त किया है,
बेहतर या बदतर के लिए,

744
00:35:33,450 --> 00:35:36,570
के लिए भेजा होने के लिए हर साल अधिक
अनुशासनात्मक कार्रवाई के लिए छात्रों को

745
00:35:36,570 --> 00:35:39,670
सबसे अधिक किसी भी अन्य की तुलना में
जाहिर है, कि मैं जानता हूँ।

746
00:35:39,670 --> 00:35:42,580
यह जरूरी नहीं है
इस तथ्य का संकेत

747
00:35:42,580 --> 00:35:46,340
सीएस छात्रों, या CS50 छात्रों, हैं कि
किसी से कम अपने सहपाठियों की तुलना में ईमानदार।

748
00:35:46,340 --> 00:35:49,090
लेकिन वास्तविकता यह है कि इस
दुनिया, इलेक्ट्रॉनिक, हम बस

749
00:35:49,090 --> 00:35:50,990
प्रौद्योगिकीय है
इस का पता लगाने का मतलब है।

750
00:35:50,990 --> 00:35:53,360
>> इसके लिए हमारे लिए महत्वपूर्ण है
कक्षा भर में निष्पक्षता

751
00:35:53,360 --> 00:35:58,550
इस का पता लगाने, और बढ़ा है कि हम क्या
मुद्दा है जब हम चीजों को देखते हैं।

752
00:35:58,550 --> 00:36:01,980
और सिर्फ एक तस्वीर पेंट करने, और वास्तव में
इस सिंक की तरह कुछ मदद करने के लिए,

753
00:36:01,980 --> 00:36:04,600
इन की संख्या रहे हैं
पिछले 10 साल से अधिक छात्र

754
00:36:04,600 --> 00:36:07,610
कुछ में शामिल किया गया है कि
शैक्षणिक ईमानदारी के इस तरह के मुद्दों,

755
00:36:07,610 --> 00:36:10,990
कुछ 32 छात्रों के साथ
गिरावट 2015, से जो

756
00:36:10,990 --> 00:36:13,760
कहते हैं कि हम लेते है
इस मामले को बहुत गंभीरता से।

757
00:36:13,760 --> 00:36:18,380
और, अंत में, इन नंबरों रचना,
सबसे हाल ही में, के बारे में 3%, 4% या तो

758
00:36:18,380 --> 00:36:19,120
वर्ग की।

759
00:36:19,120 --> 00:36:25,220
>> छात्रों के सुपर बहुमत के लिए तो
ऐसा लगता है कि लाइनों स्पष्ट कर रहे हैं।

760
00:36:25,220 --> 00:36:27,940
लेकिन इस रहते हो
मन, विशेष रूप से देर से

761
00:36:27,940 --> 00:36:32,080
रात में जब साथ संघर्ष
एक समस्या सेट करने के लिए कुछ समाधान,

762
00:36:32,080 --> 00:36:34,830
वहाँ तंत्र हैं कि
अपने आप को बेहतर प्राप्त करने के लिए

763
00:36:34,830 --> 00:36:37,870
आप से समर्थन हो सकता है
लगता है, यहां तक ​​कि एक घंटे में।

764
00:36:37,870 --> 00:36:40,514
एहसास जब कि हम प्राप्त
छात्र प्रस्तुतियाँ, हम पार

765
00:36:40,514 --> 00:36:43,430
इस साल हर प्रस्तुत की तुलना
हर प्रस्तुत पिछले साल के मुकाबले,

766
00:36:43,430 --> 00:36:47,590
2007 से हर प्रस्तुत खिलाफ,
और के बाद से, पर देख रहे हैं और साथ ही,

767
00:36:47,590 --> 00:36:49,931
कोड खजाने ऑनलाइन,
चर्चा मंचों, नौकरी साइटों।

768
00:36:49,931 --> 00:36:51,806
और हम यह उल्लेख है,
वास्तव में, कारण सब

769
00:36:51,806 --> 00:36:56,040
पूर्ण प्रकटीकरण के, कि अगर
किसी और को यह ऑनलाइन खोज सकते हैं,

770
00:36:56,040 --> 00:36:57,880
निश्चित रूप से, तो हम निश्चित रूप से कर सकते हैं।

771
00:36:57,880 --> 00:37:00,100
लेकिन, वास्तव में, आत्मा
बेशक नीचे फोड़े

772
00:37:00,100 --> 00:37:01,650
पाठ्यक्रम में इस खंड के लिए।

773
00:37:01,650 --> 00:37:03,670
यह वास्तव में सिर्फ, उचित होना है।

774
00:37:03,670 --> 00:37:06,680
>> और उस पर विस्तृत करने के लिए हम था कि अगर
बस थोड़ा और अधिक भाषा के साथ,

775
00:37:06,680 --> 00:37:09,770
पता चलता है कि सभी का सार
काम है कि आप इस पाठ्यक्रम के लिए प्रस्तुत

776
00:37:09,770 --> 00:37:10,954
अपने दम होना चाहिए।

777
00:37:10,954 --> 00:37:13,870
लेकिन उस के भीतर, वहाँ निश्चित रूप से कर रहे हैं
अवसरों, और प्रोत्साहन,

778
00:37:13,870 --> 00:37:17,300
और करने के लिए बदल में शैक्षणिक मूल्य
अपने आप others--, TFS, सीए,

779
00:37:17,300 --> 00:37:20,760
Tas, और, कक्षा में दूसरों
समर्थन के लिए, अकेले चलो मित्र

780
00:37:20,760 --> 00:37:23,547
और कमरे में रहते हैं, जो अध्ययन किया है
सीएस और प्रोग्रामिंग से पहले।

781
00:37:23,547 --> 00:37:25,130
और इसलिए वहाँ उस के लिए एक भत्ता है।

782
00:37:25,130 --> 00:37:28,180
और अंगूठे के सामान्य नियम
this-- जब मदद के लिए पूछ रहा है,

783
00:37:28,180 --> 00:37:31,470
आप दूसरों को अपने कोड दिखा सकते हैं,
लेकिन आप उनकी नहीं देख सकता है।

784
00:37:31,470 --> 00:37:34,880
तो अगर आप कार्यालय समय पर कर रहे हैं, भले ही,
या डी हॉल, वरना कहीं में

785
00:37:34,880 --> 00:37:37,450
कुछ टुकड़े सेट पर काम कर रहे,
एक दोस्त है, जो साथ काम

786
00:37:37,450 --> 00:37:40,160
पर, पूरी तरह से ठीक है
दिन अपने काम के अंत

787
00:37:40,160 --> 00:37:43,034
अंत में प्रत्येक से संबंधित होना चाहिए
आप में से क्रमशः, और नहीं

788
00:37:43,034 --> 00:37:45,700
कुछ सहयोगात्मक प्रयास हो सकता है,
अंतिम परियोजना जहां को छोड़कर

789
00:37:45,700 --> 00:37:47,410
यह अनुमति दी है और प्रोत्साहित किया है।

790
00:37:47,410 --> 00:37:49,830
>> एहसास आप कर रहे हैं कि
कुछ के साथ संघर्ष

791
00:37:49,830 --> 00:37:52,520
और अपने दोस्त सिर्फ होता है
तो इस पर बेहतर होने के लिए आप,

792
00:37:52,520 --> 00:37:55,130
या आप से है कि समस्या में बेहतर है,
या थोड़ा आगे आप की तुलना में आगे,

793
00:37:55,130 --> 00:37:57,330
इसे चालू करने के लिए पूरी तरह से उचित है
अपने दोस्त को और, कहते हैं कि अरे,

794
00:37:57,330 --> 00:38:00,480
आप यहाँ मेरे कोड को देख बुरा मत करो,
मदद मुझे हाजिर क्या मेरा मुद्दा है?

795
00:38:00,480 --> 00:38:03,760
और उम्मीद है, में
शैक्षणिक मूल्य का ब्याज

796
00:38:03,760 --> 00:38:07,040
उस दोस्त न सिर्फ करता है
कहते हैं, ओह, यह करते हैं, बल्कि,

797
00:38:07,040 --> 00:38:09,917
क्या आप लाइन पर याद कर रहे हैं
6, या ऐसा कुछ?

798
00:38:09,917 --> 00:38:12,000
लेकिन समाधान नहीं है
आप के बगल में दोस्त के लिए

799
00:38:12,000 --> 00:38:15,617
कहने के लिए, ओह, ठीक है, यहाँ, मुझे खींच
यह ऊपर है, और आप के लिए मेरी समाधान दिखा।

800
00:38:15,617 --> 00:38:16,450
तो यह है कि रेखा है।

801
00:38:16,450 --> 00:38:18,670
आप के लिए अपने कोड दिखाने
दूसरों के लिए, लेकिन तुम नहीं कर सकते

802
00:38:18,670 --> 00:38:22,350
उनकी देख, दूसरे के अधीन
पाठ्यक्रम के पाठ्यक्रम में कमी।

803
00:38:22,350 --> 00:38:24,760
>> तो मन में रखना है यह
अफसोस खंड तथाकथित

804
00:38:24,760 --> 00:38:27,560
पाठ्यक्रम के पाठ्यक्रम में के रूप में अच्छी तरह से,
कि आप कुछ कृत्य है कि अगर

805
00:38:27,560 --> 00:38:30,476
उचित नहीं है, लेकिन करने के लिए इसे लाने के लिए
पाठ्यक्रम के सिर का ध्यान

806
00:38:30,476 --> 00:38:34,240
72 घंटे के भीतर, ज़ाहिर
स्थानीय प्रतिबंधों लगाया जा सकता है कि

807
00:38:34,240 --> 00:38:37,380
एक असंतोषजनक शामिल हो सकते हैं या
काम प्रस्तुत करने के लिए असफल ग्रेड।

808
00:38:37,380 --> 00:38:41,410
लेकिन निश्चित उल्लेख नहीं होगा
आगे अनुशासनात्मक कार्रवाई के लिए बात है,

809
00:38:41,410 --> 00:38:43,010
बार-बार कृत्यों के मामलों को छोड़कर।

810
00:38:43,010 --> 00:38:46,632
दूसरे शब्दों में, कुछ कर यदि आप करते हैं
बेवकूफ, विशेष रूप से देर रात, निर्णय

811
00:38:46,632 --> 00:38:49,340
कि अगली सुबह या दो दिन
बाद में, तुम उठो और एहसास है,

812
00:38:49,340 --> 00:38:50,870
मैं क्या सोच रहा था?

813
00:38:50,870 --> 00:38:53,890
आप CS50 में क्या एक दुकान है
कि समस्या फिक्सिंग के लिए

814
00:38:53,890 --> 00:38:57,170
और यह करने के लिए मालिक, ताकि हम
आप आधे रास्ते से मिलने और सौदा होगा

815
00:38:57,170 --> 00:39:01,500
यह एक मामले में साथ है कि दोनों है
शैक्षिक और आप के लिए मूल्यवान है,

816
00:39:01,500 --> 00:39:04,200
लेकिन अभी भी कुछ रास्ते में दंडात्मक।

817
00:39:04,200 --> 00:39:08,590
और अब, किनारे से दूर ले करने के लिए, यह।

818
00:39:08,590 --> 00:39:10,570
>> [वीडियो प्लेबैक]

819
00:39:10,570 --> 00:39:13,540
>> [संगीत बजाना]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [अंत प्लेबैक]

822
00:39:58,866 --> 00:40:00,490
डेविड जे मालन: ठीक है, हम वापस आ रहे हैं।

823
00:40:00,490 --> 00:40:03,680
और अब हम में से एक को देखो
हमारी असली दुनिया डोमेन के पहले

824
00:40:03,680 --> 00:40:08,720
CS50 में, क्रिप्टोग्राफी की कला है,
भेजने और प्राप्त करने की कला

825
00:40:08,720 --> 00:40:11,840
गुप्त संदेश, एन्क्रिप्टेड
संदेशों अगर तुम जाएगा,

826
00:40:11,840 --> 00:40:17,060
कि केवल आप ही है, तो मतलब निकाला जा सकता है
कुछ प्रमुख घटक है कि इस

827
00:40:17,060 --> 00:40:18,030
भी।

828
00:40:18,030 --> 00:40:22,120
तो यह प्रेरित करने के लिए हम ले लेंगे
यहां इस बात को देखो,

829
00:40:22,120 --> 00:40:26,750
जो एक का एक उदाहरण है
गुप्त डिकोडर अंगूठी है कि

830
00:40:26,750 --> 00:40:34,042
के क्रम में पता लगाने के लिए इस्तेमाल किया जा सकता
क्या एक गुप्त संदेश वास्तव में है।

831
00:40:34,042 --> 00:40:35,750
वास्तव में, पीठ में
ग्रेड स्कूल में दिन,

832
00:40:35,750 --> 00:40:38,787
अगर आप कभी भी करने के लिए गुप्त संदेश भेजा
कुछ दोस्त या कक्षा में कुछ क्रश,

833
00:40:38,787 --> 00:40:40,620
तुम सोचा था कि हो सकता है
आप चतुर जा रहे थे

834
00:40:40,620 --> 00:40:46,530
कागज का टुकड़ा अपने बदलते पर रखकर
की तरह, एक बी करने के लिए, और बी सी के लिए, और सी डी को,

835
00:40:46,530 --> 00:40:47,590
इत्यादि।

836
00:40:47,590 --> 00:40:50,300
लेकिन आप वास्तव में encrypting थे
आपकी जानकारी के लिए, यहां तक ​​कि

837
00:40:50,300 --> 00:40:53,300
अगर यह एक छोटी सी तुच्छ था, नहीं था
कि कठिन शिक्षक का एहसास करने के लिए,

838
00:40:53,300 --> 00:40:55,675
वैसे, अगर आप बस बदल
ए और बी से सी बी को,

839
00:40:55,675 --> 00:40:57,550
आप वास्तव में यह पता लगाने
क्या संदेश था,

840
00:40:57,550 --> 00:40:59,700
लेकिन आप जानकारी Ciphering में थे।

841
00:40:59,700 --> 00:41:03,420
>> तुम सिर्फ यह क्या कर रहे थे
बस, बहुत Ralphie की तरह यहाँ

842
00:41:03,420 --> 00:41:07,934
एक प्रसिद्ध फिल्म कि नाटकों में
बहुत ज्यादा विज्ञापन nauseum प्रत्येक सर्दियों।

843
00:41:07,934 --> 00:41:08,600
[वीडियो प्लेबैक]

844
00:41:08,600 --> 00:41:11,180
रहो यह है कि सभी के लिए जाना जाता है
राल्फ पार्कर एतद्द्वारा है

845
00:41:11,180 --> 00:41:14,070
लिटिल का सदस्य नियुक्त
अनाथ एनी गुप्त सर्किल

846
00:41:14,070 --> 00:41:17,700
और सभी सम्मान के हकदार है
और लाभ बहां होने वाली।

847
00:41:17,700 --> 00:41:24,340
>> -Signed, लिटिल अनाथ एनी,
काउंटर पर हस्ताक्षर किए पियरे आंद्रे, स्याही में।

848
00:41:24,340 --> 00:41:27,160
सम्मान और लाभ,
पहले से ही नौ साल की उम्र में।

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [चिल्ला]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-आ जाओ।

853
00:41:34,250 --> 00:41:35,210
इसके साथ पर मिलता है।

854
00:41:35,210 --> 00:41:39,530
मैं सब जाज की जरूरत नहीं
तस्करों और समुद्री डाकुओं के बारे में।

855
00:41:39,530 --> 00:41:41,660
>> के लिए -listen कल रात
समापन साहसिक

856
00:41:41,660 --> 00:41:43,880
काले समुद्री डाकू जहाज के।

857
00:41:43,880 --> 00:41:46,650
अब इसके लिए समय आ गया है
एनी गुप्त संदेश

858
00:41:46,650 --> 00:41:49,840
आप गुप्त सर्किल के सदस्यों के लिए।

859
00:41:49,840 --> 00:41:53,570
याद रखें, बच्चों, केवल सदस्यों
एनी की सीक्रेट सर्किल के

860
00:41:53,570 --> 00:41:56,140
एनी गुप्त संदेश को डिकोड कर सकते हैं।

861
00:41:56,140 --> 00:42:00,340
>> याद रखें, एनी आप पर निर्भर करता है।

862
00:42:00,340 --> 00:42:02,880
बी 2 के लिए अपने पिन सेट करें।

863
00:42:02,880 --> 00:42:05,230
यहाँ संदेश है।

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -मैं, में हूँ मेरा पहला गुप्त बैठक।

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16।

867
00:42:13,890 --> 00:42:15,780
>> -Pierre महान आवाज आज रात में किया गया था।

868
00:42:15,780 --> 00:42:19,000
मुझे लगता है कि आज रात के बता सकता है
संदेश वास्तव में महत्वपूर्ण था।

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, कि एक संदेश है
एनी खुद से।

870
00:42:22,694 --> 00:42:23,860
याद रखें, किसी को मत बताना।

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 सेकंड बाद में, मैं केवल में हूँ
घर में कमरे में जहां नौ का एक लड़का

873
00:42:32,930 --> 00:42:37,040
गोपनीयता और व्याख्या में बैठ सकता है।

874
00:42:37,040 --> 00:42:39,730
अहा, बी!

875
00:42:39,730 --> 00:42:42,360
मैं अगले, ई करने के लिए चला गया

876
00:42:42,360 --> 00:42:44,520
>> पहला शब्द होना है।

877
00:42:44,520 --> 00:42:49,032
एस, यह आसान आ रहा था अब, यू, 25--

878
00:42:49,032 --> 00:42:51,733
>> -ओह, Ralphie पर आते हैं, मुझे जाना है!

879
00:42:51,733 --> 00:42:53,688
>> ठीक नीचे हो -I'll, मा!

880
00:42:53,688 --> 00:42:54,188
हाइ - फाइ पढ़ाकू!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> टी हे, है-- क्या करने के लिए सुनिश्चित हो यकीन है कि हो सकता है?

883
00:43:04,060 --> 00:43:05,970
क्या छोटे अनाथ था
एनी कहने की कोशिश?

884
00:43:05,970 --> 00:43:07,264
क्या करने के लिए यकीन है कि हो सकता है?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, एंडी गया है
जाओ, आप कृपया बाहर आ जाएगा?

886
00:43:09,634 --> 00:43:10,480
>> -सभी सही, मा!

887
00:43:10,480 --> 00:43:12,880
मैं सही बाहर हो जाएगा!

888
00:43:12,880 --> 00:43:14,550
>> -मैं करीब अब हो रही थी।

889
00:43:14,550 --> 00:43:16,620
तनाव भयानक था।

890
00:43:16,620 --> 00:43:17,720
यह क्या था?

891
00:43:17,720 --> 00:43:20,170
ग्रह के भाग्य
अधर में लटका सकता है।

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
एंडी जाना होगा!

894
00:43:23,170 --> 00:43:26,890
>> जोर से रोने के लिए सही बाहर हो -I'll!

895
00:43:26,890 --> 00:43:32,680
>> वहाँ -Almost, मेरी उंगलियां उड़ गया, मेरे मन
एक इस्पात जाल था, हर ताकना स्फूर्त।

896
00:43:32,680 --> 00:43:37,198
यह लगभग स्पष्ट हो गया था, हाँ, हाँ, हाँ।

897
00:43:37,198 --> 00:43:43,091
>> अपने Ovaltine पीने के लिए सुनिश्चित रहो।

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
एक फालतू वाणिज्यिक?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
दुष्ट।

903
00:43:54,227 --> 00:43:54,810
[अंत प्लेबैक]

904
00:43:54,810 --> 00:43:57,390
डेविड जे मालन: ठीक है, तो
कि एक बहुत लंबा रास्ता तय करना था

905
00:43:57,390 --> 00:44:00,660
क्रिप्टोग्राफी शुरू करने की,
और भी Ovaltine।

906
00:44:00,660 --> 00:44:04,470
वास्तव में, इस वर्ष विज्ञापन से
इधर, क्यों Ovaltine इतना अच्छा है?

907
00:44:04,470 --> 00:44:09,470
यह परिपक्व के एक केंद्रित निष्कर्षण है
जौ माल्ट, शुद्ध मलाईदार गाय का दूध,

908
00:44:09,470 --> 00:44:14,360
और विशेष रूप से कोको तैयार, एक साथ
प्राकृतिक phosphatides और विटामिन के साथ।

909
00:44:14,360 --> 00:44:18,240
इसे आगे भी साथ दृढ़ है
अतिरिक्त विटामिन बी और डी, यम।

910
00:44:18,240 --> 00:44:21,600
और आप अभी भी यह, जाहिरा तौर पर प्राप्त कर सकते हैं
अमेज़न पर, हम यहाँ के रूप में किया।

911
00:44:21,600 --> 00:44:24,810
>> लेकिन प्रेरणा के लिए यहाँ था
क्रिप्टोग्राफी लागू करने, विशेष रूप से

912
00:44:24,810 --> 00:44:28,340
क्रिप्टोग्राफी का एक प्रकार से जाना जाता है
गुप्त कुंजी क्रिप्टोग्राफी के रूप में।

913
00:44:28,340 --> 00:44:34,284
और नाम का सुझाव है, पूरे के रूप में
एक गुप्त कुंजी क्रिप्टो प्रणाली की सुरक्षा,

914
00:44:34,284 --> 00:44:36,200
अगर तुम जाएगा, एक पद्धति
सिर्फ पांव मार के लिए

915
00:44:36,200 --> 00:44:40,960
दो लोगों के बीच जानकारी, वह यह है कि
केवल इस केवल प्राप्तकर्ता

916
00:44:40,960 --> 00:44:46,980
एक गुप्त key-- कुछ मूल्य पता है, कुछ
गुप्त वाक्यांश, कुछ गुप्त नंबर, कि

917
00:44:46,980 --> 00:44:50,660
उन दोनों को एन्क्रिप्ट करने के लिए अनुमति देता है
और जानकारी को डिक्रिप्ट।

918
00:44:50,660 --> 00:44:53,470
और क्रिप्टोग्राफी, वास्तव में,
हफ्ते 0 से सिर्फ यह है।

919
00:44:53,470 --> 00:44:56,715
>> यह एक समस्या है, जहां आदानों वहाँ है,
अंग्रेजी में वास्तविक संदेश की तरह

920
00:44:56,715 --> 00:44:59,340
या जो भाषा है कि आप
कक्षा में किसी को भेजना चाहते हैं,

921
00:44:59,340 --> 00:45:00,580
या इंटरनेट के पार।

922
00:45:00,580 --> 00:45:03,840
वहाँ कुछ उत्पादन है, जो जा रहा है
तले हुए संदेश हो सकता है कि आप

923
00:45:03,840 --> 00:45:05,250
प्राप्तकर्ता प्राप्त करना चाहते हैं।

924
00:45:05,250 --> 00:45:07,405
और अगर किसी में
बीच यह भी प्राप्त करता है,

925
00:45:07,405 --> 00:45:09,780
आप उन्हें नहीं करना चाहते हैं
जरूरी यह डिक्रिप्ट करने में सक्षम हो,

926
00:45:09,780 --> 00:45:12,840
इस वजह से अंदर
ब्लैक बॉक्स, या एल्गोरिथ्म,

927
00:45:12,840 --> 00:45:17,650
कुछ तंत्र, कदम से कुछ कदम है
निर्देश, कि इनपुट लेने के लिए

928
00:45:17,650 --> 00:45:20,710
और इसे में परिवर्तित
उत्पादन, उम्मीद है कि एक सुरक्षित तरीके से।

929
00:45:20,710 --> 00:45:23,640
>> कुछ और, वास्तव में, वहाँ है
इस दुनिया में शब्दावली के रूप में निम्नानुसार है।

930
00:45:23,640 --> 00:45:26,100
सादा पाठ शब्द एक है
कंप्यूटर वैज्ञानिक होगा

931
00:45:26,100 --> 00:45:28,449
इनपुट का वर्णन करने के लिए प्रयोग
संदेश, अंग्रेजी की तरह

932
00:45:28,449 --> 00:45:31,240
या जो भी आप वास्तव में भाषा
कुछ अन्य मानव को भेजने के लिए चाहते हैं।

933
00:45:31,240 --> 00:45:35,450
और फिर सिफर हाथापाई है
enciphered के लिए, या एन्क्रिप्टेड,

934
00:45:35,450 --> 00:45:36,520
संस्करण क्या है।

935
00:45:36,520 --> 00:45:38,750
>> लेकिन एक अन्य घटक यहाँ है।

936
00:45:38,750 --> 00:45:43,200
वहाँ करने के लिए एक अन्य इनपुट है
गुप्त कुंजी क्रिप्टोग्राफी।

937
00:45:43,200 --> 00:45:45,200
और उस कुंजी ही है,
जो आम तौर पर, है,

938
00:45:45,200 --> 00:45:48,930
जैसा कि हम देखेंगे, एक नंबर, या
पत्र, या शब्द है, जो कुछ भी

939
00:45:48,930 --> 00:45:51,980
एल्गोरिथ्म यह वास्तव में है उम्मीद है।

940
00:45:51,980 --> 00:45:53,870
>> और आपको जानकारी कैसे डिक्रिप्ट कर सकता हूं?

941
00:45:53,870 --> 00:45:55,110
आप इसे कैसे खोलना है?

942
00:45:55,110 --> 00:45:57,950
ठीक है, तुम बस रिवर्स
outputs और आदानों।

943
00:45:57,950 --> 00:46:00,900
>> दूसरे शब्दों में, एक बार किसी
अपने एन्क्रिप्टेड संदेश प्राप्त करता है,

944
00:46:00,900 --> 00:46:03,740
वह या वह बस है
कि एक ही कुंजी को पता है।

945
00:46:03,740 --> 00:46:05,700
वे सिफर प्राप्त हुआ है।

946
00:46:05,700 --> 00:46:09,530
और उन दो plugging द्वारा
क्रिप्टो प्रणाली में आदानों,

947
00:46:09,530 --> 00:46:14,260
एल्गोरिथ्म, इस ब्लैक बॉक्स से बाहर
मूल प्लेन आना चाहिए।

948
00:46:14,260 --> 00:46:17,830
और इतना है कि बहुत ही उच्च स्तर है
क्या क्रिप्टोग्राफी वास्तव में है का दृश्य

949
00:46:17,830 --> 00:46:18,590
बारे में सबकुछ।

950
00:46:18,590 --> 00:46:20,030
>> तो चलो वहाँ मिलता है।

951
00:46:20,030 --> 00:46:22,700
चलो अब नीचे नजर डालते हैं
कुछ के हुड

952
00:46:22,700 --> 00:46:26,000
हम के लिए के लिए दी ले जा रहा है
पिछले एक सप्ताह से, और के लिए इस सत्र

953
00:46:26,000 --> 00:46:27,629
स्ट्रिंग here--।

954
00:46:27,629 --> 00:46:30,295
दिन के अंत में एक स्ट्रिंग
सिर्फ पात्रों में से एक दृश्य है।

955
00:46:30,295 --> 00:46:33,610
>> यह दुनिया नमस्ते हो सकता है, या
हैलो Zamyla, या जो भी हो।

956
00:46:33,610 --> 00:46:37,050
लेकिन यह है कि क्या मतलब है
पात्रों के एक दृश्य हो सकता है?

957
00:46:37,050 --> 00:46:41,520
वास्तव में, CS50 पुस्तकालय देता है
हमें स्ट्रिंग नामक एक डेटा प्रकार।

958
00:46:41,520 --> 00:46:45,140
>> लेकिन वहाँ वास्तव में है कोई
सी में एक स्ट्रिंग के रूप में ऐसी बात

959
00:46:45,140 --> 00:46:49,450
यह वास्तव में सिर्फ का एक दृश्य है
चरित्र, चरित्र, चरित्र,

960
00:46:49,450 --> 00:46:52,180
चरित्र, पीठ, को वापस करने के लिए,
वापस, वापस करने के लिए, अंदर वापस करने के लिए

961
00:46:52,180 --> 00:46:54,650
अपने कंप्यूटर की स्मृति, या राम के।

962
00:46:54,650 --> 00:46:58,940
और हम उस में में गहरी लग रही हूँ
भविष्य में जब हम, स्मृति खुद को देखो

963
00:46:58,940 --> 00:47:02,030
और उपयोग, और
खतरों है कि शामिल कर रहे हैं।

964
00:47:02,030 --> 00:47:04,100
>> लेकिन स्ट्रिंग Zamyla पर विचार करते हैं।

965
00:47:04,100 --> 00:47:07,480
तो बस के नाम
मानव इधर, Zamyla,

966
00:47:07,480 --> 00:47:12,030
इस बात का एक दृश्य है
वर्ण, जेड-ए-एम-वाई-एल ए।

967
00:47:12,030 --> 00:47:16,020
और अब लगता है कि चलो Zamyla का नाम
एक कंप्यूटर के अंदर संग्रहित किया जा रहा है

968
00:47:16,020 --> 00:47:16,880
कार्यक्रम।

969
00:47:16,880 --> 00:47:20,830
>> खैर, यह कारण है कि हम चाहिए खड़ा है
उन पात्रों को देखने के लिए सक्षम हो

970
00:47:20,830 --> 00:47:21,590
व्यक्तिगत रूप से।

971
00:47:21,590 --> 00:47:24,710
तो मैं सिर्फ एक छोटे से आकर्षित करने के लिए जा रहा हूँ
यहाँ Zamyla का नाम चारों ओर बॉक्स।

972
00:47:24,710 --> 00:47:31,580
और यह सी में मामला है कि जब आप
Zamyla-- और हो सकता है की तरह, एक स्ट्रिंग है

973
00:47:31,580 --> 00:47:34,940
कि स्ट्रिंग से वापस आ गया है
मिल स्ट्रिंग की तरह एक समारोह में,

974
00:47:34,940 --> 00:47:38,540
आप वास्तव में हेरफेर कर सकते हैं
चरित्र से यह चरित्र।

975
00:47:38,540 --> 00:47:42,070
>> अब, इस के लिए सार्थक है
बातचीत के हाथ में है, क्योंकि

976
00:47:42,070 --> 00:47:46,420
क्रिप्टोग्राफी में आप बदलना चाहते हैं
एक बी करने के लिए, और बी सी के लिए, और डी के लिए सी,

977
00:47:46,420 --> 00:47:49,650
और बहुत आगे है, आप में सक्षम होने की जरूरत है
अलग-अलग पात्रों को देखने के लिए

978
00:47:49,650 --> 00:47:50,190
एक स्ट्रिंग में।

979
00:47:50,190 --> 00:47:52,695
आप को बदलने में सक्षम होने की जरूरत है
कुछ और, A से Z

980
00:47:52,695 --> 00:47:55,280
कुछ और, एम के लिए
वरना, और इतने पर कुछ और।

981
00:47:55,280 --> 00:47:58,000
और इसलिए हम एक तरह की जरूरत है,
प्रोग्राम के जरिए, तो

982
00:47:58,000 --> 00:48:03,020
बात करने के लिए सी में परिवर्तन करने में सक्षम होना करने के लिए
और व्यक्तिगत पत्रों को देखो।

983
00:48:03,020 --> 00:48:05,690
और हम इस प्रकार के रूप में कर सकते हैं।

984
00:48:05,690 --> 00:48:08,340
>> मेरे CS50 आईडीई में वापस सिर चलते हैं।

985
00:48:08,340 --> 00:48:11,130
और मुझे आगे चलते हैं
और एक नई फ़ाइल बनाने

986
00:48:11,130 --> 00:48:16,134
कि मैं इस समय string0 फोन करता हूँ,
हमारी पहली इस तरह के उदाहरण के रूप में, डॉट सी।

987
00:48:16,134 --> 00:48:18,300
और मैं आगे जाने के लिए जा रहा हूँ
और यह सचेतक इस प्रकार है।

988
00:48:18,300 --> 00:48:22,870
>> तो cs50.h शामिल है, और
तो मानक io.h शामिल हैं,

989
00:48:22,870 --> 00:48:25,990
जो मैं लगभग हमेशा के लिए जा रहा हूँ
अपने कार्यक्रमों में उपयोग करते हुए, कम से कम हो

990
00:48:25,990 --> 00:48:26,780
शुरू में।

991
00:48:26,780 --> 00:48:32,180
मुख्य शून्य int, और फिर यहाँ मैं हूँ
तार करने जा रहा स्ट्रिंग प्राप्त हो जाता है।

992
00:48:32,180 --> 00:48:35,260
और फिर मैं करने जा रहा हूँ
आगे जाना है और यह करते हैं।

993
00:48:35,260 --> 00:48:37,460
मैं आगे जाना चाहता हूँ
और, एक मानसिक स्वास्थ्य की जांच के रूप में,

994
00:48:37,460 --> 00:48:43,607
बस का कहना है, हैलो, प्रतिशत है,
सेमी कॉलन, स्ट्रिंग 0 बनाता है।

995
00:48:43,607 --> 00:48:44,690
उह ओह, क्या मैं यहाँ क्या किया?

996
00:48:44,690 --> 00:48:45,930
ओह, मैं यह प्लग में नहीं था।

997
00:48:45,930 --> 00:48:48,120
तो सबक सीखा है कि
जानबूझकर नहीं किया गया था।

998
00:48:48,120 --> 00:48:52,480
>> तो त्रुटि, अधिक प्रतिशत
डेटा तर्क से रूपांतरण।

999
00:48:52,480 --> 00:48:54,940
और इस में जहां है,
लाइन 7-- ठीक है, तो मेरे पास है,

1000
00:48:54,940 --> 00:48:56,690
बोली गंदें शब्द बोलना, कि
मेरे स्ट्रिंग printf करने के लिए।

1001
00:48:56,690 --> 00:48:58,151
मैं एक प्रतिशत चिह्न मिल गया है।

1002
00:48:58,151 --> 00:48:59,650
लेकिन मैं दूसरा तर्क याद आ रही है।

1003
00:48:59,650 --> 00:49:03,190
>> मुझे याद आ रही अल्पविराम है, जो
मैं पिछले उदाहरण में किया है।

1004
00:49:03,190 --> 00:49:06,650
तो एक अच्छा अवसर ठीक करने के लिए
एक और गलती, गलती से।

1005
00:49:06,650 --> 00:49:09,950
और अब मुझे चलाते हैं
Zamyla में string0, प्रकार।

1006
00:49:09,950 --> 00:49:10,970
Zamyla हैलो ठीक है,।

1007
00:49:10,970 --> 00:49:14,144
>> इसलिए हम कार्यक्रम के इस तरह भाग लिया
अब कुछ अलग अलग समय।

1008
00:49:14,144 --> 00:49:16,310
लेकिन कुछ एक करते हैं
छोटे से अलग इस बार।

1009
00:49:16,310 --> 00:49:19,450
इसके बजाय सिर्फ Zamyla की छपाई की
printf के साथ बाहर पूरे नाम,

1010
00:49:19,450 --> 00:49:21,350
के चरित्र से यह चरित्र करते हैं।

1011
00:49:21,350 --> 00:49:22,700
>> मैं एक पाश के लिए उपयोग करने के लिए जा रहा हूँ।

1012
00:49:22,700 --> 00:49:26,160
और मैं अपने आप को देने के लिए जा रहा हूँ
एक गिनती चर, मैंने फोन किया।

1013
00:49:26,160 --> 00:49:33,530
और मैं पुनरावृति को रखने के लिए जा रहा हूँ, इसलिए
जब तक मैं एस की लंबाई की तुलना में कम है।

1014
00:49:33,530 --> 00:49:35,930
>> यह पता चला है, हम नहीं
यह आखिरी बार करते हैं,

1015
00:49:35,930 --> 00:49:39,100
कि सी एक साथ आता है
समारोह स्टर्लिंग बुलाया।

1016
00:49:39,100 --> 00:49:42,690
वापस दिन में, और सामान्य में
अब भी जब कार्यों को लागू करने,

1017
00:49:42,690 --> 00:49:45,405
मनुष्य अक्सर बहुत चयन करेंगे
संक्षिप्त नाम है कि ध्वनि की तरह

1018
00:49:45,405 --> 00:49:48,280
आप क्या चाहते हैं, यह बात भले ही तरह
कुछ स्वर या पत्र गायब है।

1019
00:49:48,280 --> 00:49:50,660
तो स्टर्लिंग है
एक समारोह का नाम है कि

1020
00:49:50,660 --> 00:49:53,880
के बीच एक बहस लेता है
कोष्ठकों कि एक स्ट्रिंग होना चाहिए।

1021
00:49:53,880 --> 00:49:56,910
और यह सिर्फ एक पूर्णांक देता है,
कि स्ट्रिंग की लंबाई।

1022
00:49:56,910 --> 00:50:00,580
>> 7 लाइन पर पाश के लिए यह इसलिए हो रहा है
गिनती मैं 0 के बराबर होती है शुरू करने के लिए।

1023
00:50:00,580 --> 00:50:02,530
यह वेतन वृद्धि करने जा रहा है
प्रत्येक यात्रा पर मैं

1024
00:50:02,530 --> 00:50:04,350
1 से, हम एक बार कुछ कर रहा है के रूप में।

1025
00:50:04,350 --> 00:50:06,780
लेकिन यह केवल करने जा रहा है
बिंदु तक यह ऊपर

1026
00:50:06,780 --> 00:50:09,660
जब मैं लंबाई है
स्ट्रिंग ही की।

1027
00:50:09,660 --> 00:50:14,520
>> तो इस का एक तरीका है, अंत में,
पात्रों पर iterating

1028
00:50:14,520 --> 00:50:17,430
स्ट्रिंग के रूप में इस प्रकार है।

1029
00:50:17,430 --> 00:50:20,670
मुझे नहीं बाहर मुद्रित करने के लिए जा रहा हूँ एक
पूरे स्ट्रिंग, लेकिन प्रतिशत सी,

1030
00:50:20,670 --> 00:50:22,860
एक ही चरित्र
एक नई लाइन द्वारा पीछा किया।

1031
00:50:22,860 --> 00:50:24,880
और फिर मैं करने जा रहा हूँ
आगे बढ़ो, और मैं की जरूरत है

1032
00:50:24,880 --> 00:50:29,080
मैं मुद्रित करना चाहते हैं कहने के लिए
एस के ith चरित्र।

1033
00:50:29,080 --> 00:50:33,450
>> तो अगर मैं चर कि इंगित करता है
स्ट्रिंग, जहां के सूचकांक

1034
00:50:33,450 --> 00:50:37,230
आप इसे में, मैं करने में सक्षम होने की जरूरत है
कहते हैं, मेरे एस के ith चरित्र दे।

1035
00:50:37,230 --> 00:50:40,390
और ग करने का एक तरीका है
वर्ग कोष्ठक के साथ इस।

1036
00:50:40,390 --> 00:50:43,679
आप बस के नाम का कहना है
स्ट्रिंग, जो इस मामले में एस है।

1037
00:50:43,679 --> 00:50:46,970
तो फिर तुम वर्ग कोष्ठक कर रहे हैं, जो प्रयोग
आम तौर पर सिर्फ अपनी वापसी या ऊपर दर्ज

1038
00:50:46,970 --> 00:50:48,110
कुंजीपटल पर कुंजी।

1039
00:50:48,110 --> 00:50:52,410
और फिर आप के सूचकांक डाल
चरित्र है कि आप मुद्रित करना चाहते हैं।

1040
00:50:52,410 --> 00:50:55,960
इसलिए सूचकांक एक होने जा रहा है
संख्या-0, या 1, या 2, या 3, या डॉट,

1041
00:50:55,960 --> 00:50:57,590
डॉट, डॉट, कुछ अन्य संख्या।

1042
00:50:57,590 --> 00:51:00,920
>> और हम यह सुनिश्चित है कि यह जा रहा है
, सही संख्या हो सकता है क्योंकि मैं

1043
00:51:00,920 --> 00:51:02,360
0 पर गिनती शुरू।

1044
00:51:02,360 --> 00:51:07,020
और डिफ़ॉल्ट रूप से, पहले चरित्र
एक स्ट्रिंग में सम्मेलन 0 से है।

1045
00:51:07,020 --> 00:51:09,230
और दूसरा चरित्र ब्रैकेट 1 है।

1046
00:51:09,230 --> 00:51:11,120
और तीसरा चरित्र ब्रैकेट 2 है।

1047
00:51:11,120 --> 00:51:13,630
और अगर आप भी जाने के लिए नहीं करना चाहती
दूर है, लेकिन हम क्योंकि हम कर रहे हैं नहीं होगा

1048
00:51:13,630 --> 00:51:17,780
केवल यह जब तक मैं वेतन वृद्धि के लिए जा रहा
स्ट्रिंग की लंबाई के बराबर होती है।

1049
00:51:17,780 --> 00:51:20,210
और जो बात,
पाश के लिए यह बंद हो जाएगा।

1050
00:51:20,210 --> 00:51:25,550
>> तो मुझे आगे जाना है और इस को बचाने के
कार्यक्रम है, और रन स्ट्रिंग 0 बनाते हैं।

1051
00:51:25,550 --> 00:51:28,400
लेकिन मैं बँधा हुआ।

1052
00:51:28,400 --> 00:51:35,390
परोक्ष पुस्तकालय समारोह की घोषणा
इस तरह के प्रकार के साथ स्टर्लिंग और अब such--,

1053
00:51:35,390 --> 00:51:36,430
इस परिचित लगता है।

1054
00:51:36,430 --> 00:51:37,440
लेकिन यह printf नहीं है।

1055
00:51:37,440 --> 00:51:38,540
और यह स्ट्रिंग नहीं मिल रहा है।

1056
00:51:38,540 --> 00:51:40,480
>> मैं में पेंच नहीं था
उसी तरह से इस बार।

1057
00:51:40,480 --> 00:51:45,100
लेकिन यहाँ नीचे नीचे एक छोटे से नोटिस
आगे, शीर्षक string.h में शामिल हैं,

1058
00:51:45,100 --> 00:51:47,210
स्पष्ट रूप से प्रदान
स्टर्लिंग के लिए घोषणा।

1059
00:51:47,210 --> 00:51:48,820
तो वहाँ वास्तव में वहाँ में एक संकेत है।

1060
00:51:48,820 --> 00:51:51,670
>> और वास्तव में यह पता चला है
वहाँ एक हेडर फाइल है

1061
00:51:51,670 --> 00:51:53,970
कि हम इस्तेमाल नहीं किया है
कक्षा में अभी तक है, लेकिन यह है

1062
00:51:53,970 --> 00:51:56,480
उपलब्ध उन लोगों के बीच
आप के लिए, string.h बुलाया।

1063
00:51:56,480 --> 00:52:00,930
और उस फ़ाइल, string.h में
स्टर्लिंग घोषित है।

1064
00:52:00,930 --> 00:52:05,220
तो मुझे आगे जाना है और
इस बचाने के लिए, स्ट्रिंग बनाने

1065
00:52:05,220 --> 00:52:08,040
0-- अच्छा है, कोई त्रुटि संदेश इस बार।

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, और
मैं के बारे में दर्ज हिट करने के लिए कर रहा हूँ

1067
00:52:12,290 --> 00:52:16,710
पर जो बात GetString जा रहा है
स्ट्रिंग लौटने के लिए, यह में डाल दिया।

1068
00:52:16,710 --> 00:52:21,890
पाश के लिए पुनरावृति करने के लिए जा रहा है तो उस
एक समय में एस के पात्रों से अधिक,

1069
00:52:21,890 --> 00:52:28,420
और उन्हें प्रति पंक्ति एक प्रिंट, क्योंकि
मैं अंत में है कि बैकस्लैश n था।

1070
00:52:28,420 --> 00:52:34,530
इसलिए मुझे लगता है कि बैकस्लैश न आना हो सकता है
एन, और फिर बस Zamyla सभी प्रिंट

1071
00:52:34,530 --> 00:52:37,460
एक ही पंक्ति में,
प्रभावी ढंग से reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, जो कि सभी के लिए उपयोगी नहीं है।

1073
00:52:38,999 --> 00:52:40,540
लेकिन इस मामले में, मुझे लगता है कि नहीं किया है।

1074
00:52:40,540 --> 00:52:43,610
मैं वास्तव में एक छपा है
एक समय में चरित्र, प्रति पंक्ति एक,

1075
00:52:43,610 --> 00:52:45,400
इसलिए हम वास्तव में प्रभाव देखते हैं।

1076
00:52:45,400 --> 00:52:46,900
>> लेकिन मैं एक बात यहां ध्यान देना चाहिए।

1077
00:52:46,900 --> 00:52:48,930
और हम करने के लिए वापस आ गया हूँ
एक भविष्य सप्ताह में यह।

1078
00:52:48,930 --> 00:52:52,650
यह यह है कि पता चला है
कोड संभावित छोटी गाड़ी है।

1079
00:52:52,650 --> 00:52:56,560
>> यह पता चला है कि मिल स्ट्रिंग
और जीवन में कुछ अन्य कार्यों

1080
00:52:56,560 --> 00:53:00,280
जरूरी नहीं हमेशा करना
आप क्या उम्मीद कर रहे हैं वापसी।

1081
00:53:00,280 --> 00:53:03,010
हम कक्षा पिछले से पता
यह है कि मिल में समय

1082
00:53:03,010 --> 00:53:04,960
स्ट्रिंग एक स्ट्रिंग वापस करने के लिए माना जाता है।

1083
00:53:04,960 --> 00:53:09,900
लेकिन क्या अगर उपयोगकर्ता प्रकार के बाहर इस तरह के
एक लंबे शब्द, या पैरा, या निबंध

1084
00:53:09,900 --> 00:53:13,010
वहाँ अभी पर्याप्त नहीं है कि
कंप्यूटर में स्मृति इसे फिट करने के लिए।

1085
00:53:13,010 --> 00:53:15,410
>> की तरह, क्या कुछ हो जाता है, तो
हुड के नीचे क्या गलत है?

1086
00:53:15,410 --> 00:53:18,400
यह अक्सर नहीं हो सकता है,
लेकिन यह एक बार हो सकता है

1087
00:53:18,400 --> 00:53:21,520
एक समय में, बहुत बार बार।

1088
00:53:21,520 --> 00:53:25,460
और इसलिए यह पता चला है कि मिल स्ट्रिंग
और जरूरी नहीं है कि यह की तरह कार्य

1089
00:53:25,460 --> 00:53:26,380
हमेशा तार वापसी।

1090
00:53:26,380 --> 00:53:30,680
वे कुछ त्रुटि मान सकता है,
कुछ प्रहरी मूल्य तो बात है,

1091
00:53:30,680 --> 00:53:32,612
वह यह है कि इंगित करता है
कुछ गलत हो गया है।

1092
00:53:32,612 --> 00:53:35,320
और आप ही से यह पता होगा
कक्षा में अब यह सीखा है,

1093
00:53:35,320 --> 00:53:37,700
या कुछ और प्रलेखन पढ़ने वाले।

1094
00:53:37,700 --> 00:53:43,120
यह पता चला है कि मिल स्ट्रिंग
अशक्त नामक एक मूल्य वापसी कर सकते हैं।

1095
00:53:43,120 --> 00:53:46,220
अशक्त एक विशेष मूल्य है कि हम करेंगे
एक भविष्य सप्ताह में वापस करने के लिए आते हैं।

1096
00:53:46,220 --> 00:53:50,420
लेकिन अब के लिए, सिर्फ इतना पता है कि अगर मैं चाहता हूँ
वास्तव में आगे बढ़ने में उचित होना करने के लिए

1097
00:53:50,420 --> 00:53:52,650
तार मिल का उपयोग करते हुए, मैं
सिर्फ यह नहीं बुलाना चाहिए,

1098
00:53:52,650 --> 00:53:56,870
और आँख बंद करके अपनी वापसी मान का उपयोग,
विश्वास है कि यह एक स्ट्रिंग है।

1099
00:53:56,870 --> 00:53:59,420
>> मैं पहली बार, कहना चाहिए
अरे, एक मिनट ही इंतजार है,

1100
00:53:59,420 --> 00:54:03,380
आगे बढ़ना है, तो एस बराबर नहीं है
अशक्त, जहां अशक्त, फिर से,

1101
00:54:03,380 --> 00:54:04,660
सिर्फ कुछ विशेष मूल्य है।

1102
00:54:04,660 --> 00:54:07,770
और यह केवल विशेष मूल्य है आप
मिल स्ट्रिंग के लिए के बारे में चिंता करने की जरूरत है।

1103
00:54:07,770 --> 00:54:10,900
स्ट्रिंग या तो रहा है मिल
एक स्ट्रिंग या अशक्त लौटने के लिए।

1104
00:54:10,900 --> 00:54:17,219
>> और यह विस्मयादिबोधक बिंदु पर हस्ताक्षर के बराबर होती है
आप शायद गणित वर्ग से जानते हो सकता है

1105
00:54:17,219 --> 00:54:20,510
आप के साथ एक बराबर चिह्न आकर्षित हो सकता है कि
इसके माध्यम से एक लाइन के बराबर नहीं संकेत मिलता है।

1106
00:54:20,510 --> 00:54:23,135
यही कारण है कि आम तौर पर एक चरित्र नहीं है
आप अपने कीबोर्ड पर टाइप कर सकते हैं।

1107
00:54:23,135 --> 00:54:26,480
और तो सबसे प्रोग्रामिंग भाषाओं में,
आप बराबर नहीं कहना चाहता हूँ जब,

1108
00:54:26,480 --> 00:54:29,160
आप एक विस्मयादिबोधक बिंदु का उपयोग,
अन्यथा धमाके के रूप में जाना जाता है।

1109
00:54:29,160 --> 00:54:33,180
तो आप कह धमाके के बराबर होती है जो
बराबरी नहीं, तार्किक मतलब है।

1110
00:54:33,180 --> 00:54:38,060
यह वहाँ एक बड़ा नहीं है, बस की तरह है
की तुलना में, या के बराबर है, या कम से कम

1111
00:54:38,060 --> 00:54:41,270
या बराबर अपने कुंजीपटल पर कुंजी के लिए
कि यह सब एक प्रतीक में करता है।

1112
00:54:41,270 --> 00:54:44,020
तो यही कारण है, पिछले उदाहरण में,
आप एक खुले ब्रैकेट किया था, और उसके बाद

1113
00:54:44,020 --> 00:54:48,670
एक बराबर चिह्न, क्रम में करने के लिए
से अधिक या, कहते हैं, की तुलना में कम।

1114
00:54:48,670 --> 00:54:49,910
>> तो क्या takeaway यहाँ है?

1115
00:54:49,910 --> 00:54:53,880
यह बस अब का एक तरीका है
इस वाक्य रचना शुरू करने, इस सुविधा,

1116
00:54:53,880 --> 00:54:57,390
व्यक्ति पर iterating
एक स्ट्रिंग में वर्णों।

1117
00:54:57,390 --> 00:55:00,260
और सिर्फ उन वर्ग की तरह
कोष्ठक, आप उन पर प्राप्त करने की अनुमति

1118
00:55:00,260 --> 00:55:03,790
के रूप में उन पर विचार वर्ग कोष्ठक
एक तरह से यह अंतर्निहित पर इशारा

1119
00:55:03,790 --> 00:55:06,040
डिजाइन, जिससे हर
एक स्ट्रिंग के अंदर चरित्र

1120
00:55:06,040 --> 00:55:10,180
प्रकार के नीचे कहीं में बॉक्सिंग
अपने कंप्यूटर की स्मृति में हुड।

1121
00:55:10,180 --> 00:55:12,340
>> लेकिन इस का एक संस्करण बनाते हैं।

1122
00:55:12,340 --> 00:55:14,880
यह यह है कि पता चला है
कार्यक्रम सही है।

1123
00:55:14,880 --> 00:55:18,810
तो CS50 के कुल्हाड़ियों के मूल्यांकन के लिए प्रति
कोड, अब यह सही है।

1124
00:55:18,810 --> 00:55:22,959
विशेष रूप से अब है कि मैं के लिए जाँच कर रहा हूँ
अशक्त, इस कार्यक्रम दुर्घटना कभी नहीं करना चाहिए।

1125
00:55:22,959 --> 00:55:24,500
और मैं सिर्फ इतना है कि अनुभव से पता है।

1126
00:55:24,500 --> 00:55:28,040
लेकिन वहाँ और कुछ नहीं है कि
हम वास्तव में यहाँ गलत जा सकते हैं।

1127
00:55:28,040 --> 00:55:31,860
लेकिन यह बहुत अच्छी तरह से तैयार नहीं है,
क्योंकि हम बुनियादी बातों को वापस जाओ।

1128
00:55:31,860 --> 00:55:34,450
>> प्रथम सिद्धांत--
पाश के लिए एक क्या करता है?

1129
00:55:34,450 --> 00:55:36,290
पाश के लिए एक तीन बातें करता है।

1130
00:55:36,290 --> 00:55:39,340
यह कुछ initializes
मूल्य, यदि आप इसे करने के लिए पूछना।

1131
00:55:39,340 --> 00:55:41,770
यह एक शर्त जाँच करता है।

1132
00:55:41,770 --> 00:55:45,380
और फिर बाद में प्रत्येक
चलना, प्रत्येक चक्र के बाद,

1133
00:55:45,380 --> 00:55:49,330
यह कुछ वेतन वृद्धि
मूल्य, या मान, यहाँ।

1134
00:55:49,330 --> 00:55:50,600
>> तो उसका क्या मतलब हुआ?

1135
00:55:50,600 --> 00:55:52,940
हम मैं 0 करने के लिए प्रारंभ।

1136
00:55:52,940 --> 00:55:58,610
हम जाँच करें और सुनिश्चित करें कि मैं तुलना में कम है
एस की लंबाई, जो जेड-ए-एम-वाई-एल ए,

1137
00:55:58,610 --> 00:55:59,900
इसलिए जो 6 से कम है।

1138
00:55:59,900 --> 00:56:02,590
और, वास्तव में, 0 कम से कम 6 के रूप में।

1139
00:56:02,590 --> 00:56:05,580
>> हम Zamyla के नाम से जेड बाहर प्रिंट।

1140
00:56:05,580 --> 00:56:08,080
तो फिर हम मैं 0 से 1 वेतन वृद्धि।

1141
00:56:08,080 --> 00:56:11,290
हम तो जांच, 1 कम है
एस की लंबाई की तुलना में?

1142
00:56:11,290 --> 00:56:13,270
एस की लंबाई 6 है।

1143
00:56:13,270 --> 00:56:13,950
हाँ यही है।

1144
00:56:13,950 --> 00:56:16,880
>> इसलिए हम Zamyla का नाम, जुल्फिकार अली में एक प्रिंट।

1145
00:56:16,880 --> 00:56:20,090
हम 0 से मैं वेतन वृद्धि, 1, 2 करने के लिए।

1146
00:56:20,090 --> 00:56:23,720
हम तो जांच, 2 की तुलना में कम है
Zamyla के नाम की लंबाई।

1147
00:56:23,720 --> 00:56:25,380
6 इतनी 2 से 6 से कम है।

1148
00:56:25,380 --> 00:56:30,460
हाँ, चलो में एम अब बाहर मुद्रित करते हैं
Zamyla का नाम, तीसरे चरित्र।

1149
00:56:30,460 --> 00:56:34,110
>> यहां महत्वपूर्ण यह है कि प्रत्येक पर है
कहानी का चलना, मैं जाँच कर रहा हूँ,

1150
00:56:34,110 --> 00:56:37,810
मैं Zamyla की लंबाई की तुलना में कम है?

1151
00:56:37,810 --> 00:56:40,350
लेकिन पकड़ है कि है
स्टर्लिंग एक संपत्ति नहीं है।

1152
00:56:40,350 --> 00:56:43,100
तुम में से जो प्रोग्राम किया है
जावा या अन्य भाषाओं में से पहले

1153
00:56:43,100 --> 00:56:46,310
लंबाई जानते हो सकता है की एक स्ट्रिंग है
एक संपत्ति, बस कुछ ही मूल्य पढ़ा।

1154
00:56:46,310 --> 00:56:50,220
>> इस मामले में सी में, यह है कि अगर
एक समारोह का शाब्दिक है कि

1155
00:56:50,220 --> 00:56:53,520
की संख्या की गणना
हर बार Zamyla में पात्रों

1156
00:56:53,520 --> 00:56:54,740
हम उस समारोह कहते हैं।

1157
00:56:54,740 --> 00:56:58,500
हर बार जब आप का उपयोग करने के लिए कंप्यूटर पूछना
स्टर्लिंग, यह Zamyla पर एक नज़र ले जा रहा है,

1158
00:56:58,500 --> 00:57:01,960
और कह रही जेड-ए-एम-वाई-एल ए, 6।

1159
00:57:01,960 --> 00:57:02,962
और यह 6 रिटर्न।

1160
00:57:02,962 --> 00:57:04,920
अगली बार जब आप फोन
ऐसा नहीं है कि पाश के लिए अंदर,

1161
00:57:04,920 --> 00:57:08,610
यह Zamyla को देखने के लिए जा रहा है
फिर, का कहना है कि जेड-ए-एम-वाई-एल ए, 6।

1162
00:57:08,610 --> 00:57:10,320
और यह 6 लौटने के लिए जा रहा है।

1163
00:57:10,320 --> 00:57:12,980
तो क्या इस डिजाइन के बारे में बेवकूफ है?

1164
00:57:12,980 --> 00:57:17,700
>> क्यों मेरे कोड नहीं 5 के बाहर एक 5
डिजाइन के लिए अब ठीक है, तो बात करने के लिए?

1165
00:57:17,700 --> 00:57:20,600
खैर, मैं पूछ रहा हूँ एक
अनावश्यक रूप से सवाल है।

1166
00:57:20,600 --> 00:57:23,030
मैं और अधिक काम कर रहा हूँ की तुलना में मैं करने की जरूरत है।

1167
00:57:23,030 --> 00:57:25,370
>> तो फिर भी
जवाब सही है, मैं हूँ

1168
00:57:25,370 --> 00:57:29,560
कंप्यूटर पूछ रही है, क्या है
Zamyla की लंबाई फिर से,

1169
00:57:29,560 --> 00:57:31,380
और फिर, और फिर, और फिर?

1170
00:57:31,380 --> 00:57:33,980
और कहा कि इस सवाल का जवाब है
कभी नहीं बदलने जा रहा।

1171
00:57:33,980 --> 00:57:35,900
यह हमेशा के लिए 6 होने जा रहा है।

1172
00:57:35,900 --> 00:57:39,730
>> तो इस से बेहतर समाधान
यह अगले संस्करण होगा।

1173
00:57:39,730 --> 00:57:43,390
मुझे आगे चलते हैं और एक में डाल दिया
string1.c बुलाया अलग फाइल,

1174
00:57:43,390 --> 00:57:44,990
सिर्फ रखने के लिए यह अलग।

1175
00:57:44,990 --> 00:57:47,260
और इसके लिए एक में पता चला है
पाश, तुम वास्तव में कर सकते हैं

1176
00:57:47,260 --> 00:57:50,210
एक बार में कई चर घोषणा।

1177
00:57:50,210 --> 00:57:53,460
>> इसलिए मुझे लगता है मैं रखने के लिए और 0 के लिए यह निर्धारित करने के लिए जा रहा हूँ।

1178
00:57:53,460 --> 00:57:56,190
लेकिन मैं यह भी जा रहा हूँ
एक अल्पविराम जोड़ने के लिए, और कहते हैं,

1179
00:57:56,190 --> 00:58:01,050
मुझे एक चर n कहा जाता है, जिसका देना
मूल्य एस की स्ट्रिंग की लंबाई के बराबर होती है।

1180
00:58:01,050 --> 00:58:09,410
और अब, मेरी हालत बनाने कृपया
इतने लंबे समय के रूप में मैं n से भी कम है।

1181
00:58:09,410 --> 00:58:14,140
>> तो इस तरह से, तर्क है
दिन के अंत में समान।

1182
00:58:14,140 --> 00:58:18,280
लेकिन मैं याद कर रहा हूँ
मूल्य 6, इस मामले में।

1183
00:58:18,280 --> 00:58:19,780
Zamyla के नाम की लंबाई क्या है?

1184
00:58:19,780 --> 00:58:20,860
और मैं n पर यह डाल रहा हूँ।

1185
00:58:20,860 --> 00:58:23,050
>> और मैं अभी भी जाँच कर रहा हूँ
हालत हर बार।

1186
00:58:23,050 --> 00:58:24,300
0 6 से कम है?

1187
00:58:24,300 --> 00:58:25,600
1 से 6 से कम है?

1188
00:58:25,600 --> 00:58:28,600
2 से 6 की तुलना में कम है, और बहुत आगे है?

1189
00:58:28,600 --> 00:58:31,914
>> लेकिन मैं कंप्यूटर नहीं कह रहा हूँ
फिर, और फिर, क्या है

1190
00:58:31,914 --> 00:58:33,080
Zamyla के नाम की लंबाई?

1191
00:58:33,080 --> 00:58:34,320
Zamyla के नाम की लंबाई क्या है?

1192
00:58:34,320 --> 00:58:35,986
इस Zamyla के नाम की लंबाई क्या है?

1193
00:58:35,986 --> 00:58:40,440
मैं सचमुच याद कर रहा हूँ कि पहली और
केवल इस दूसरे चर n में जवाब।

1194
00:58:40,440 --> 00:58:45,280
तो यह अब न केवल होगी
सही है, लेकिन यह भी अच्छी तरह से डिजाइन।

1195
00:58:45,280 --> 00:58:46,670
>> अब, शैली के बारे में क्या?

1196
00:58:46,670 --> 00:58:48,866
मैं अपने चर नाम दिया है
बहुत अच्छी तरह से, मैं कहूँगा।

1197
00:58:48,866 --> 00:58:50,240
वे अब ठीक सुपर संक्षिप्त रहे हैं।

1198
00:58:50,240 --> 00:58:52,090
और वह पूरी तरह से ठीक है।

1199
00:58:52,090 --> 00:58:55,120
>> आप केवल एक है
एक कार्यक्रम में स्ट्रिंग,

1200
00:58:55,120 --> 00:58:56,860
तुम भी कॉल कर सकते हैं यह स्ट्रिंग के लिए है।

1201
00:58:56,860 --> 00:58:59,370
आप केवल एक चर है
एक कार्यक्रम में गिनती के लिए,

1202
00:58:59,370 --> 00:59:00,710
आप के रूप में अच्छी तरह से यह मैं बुला सकता है।

1203
00:59:00,710 --> 00:59:03,500
आप लंबाई है, तो n
साथ ही सुपर आम है।

1204
00:59:03,500 --> 00:59:05,800
लेकिन मैं अपने कोड के किसी भी टिप्पणी नहीं की है।

1205
00:59:05,800 --> 00:59:09,200
>> मैं reader-- सूचित नहीं किया है
कि मेरे टीएफ, या प्रादेशिक सेना है या नहीं,

1206
00:59:09,200 --> 00:59:12,460
या सिर्फ colleague-- क्या माना जाता है
इस कार्यक्रम में जा रहा हो।

1207
00:59:12,460 --> 00:59:15,760
और इतना अच्छा शैली पाने के लिए,
मैं करना चाहता हूँ क्या होगा

1208
00:59:15,760 --> 00:59:24,580
this-- कुछ है
जैसे इनपुट के लिए कहें।

1209
00:59:24,580 --> 00:59:26,670
और मैं फिर से लिखना कर सकता है
तरीके की यह किसी भी संख्या।

1210
00:59:26,670 --> 00:59:35,630
>> सुनिश्चित करें कि प्राप्त करना सुनिश्चित करें s--
स्ट्रिंग एक स्ट्रिंग लौट आए।

1211
00:59:35,630 --> 00:59:40,280
और फिर here-- में और यह शायद है
सबसे महत्वपूर्ण comment-- पुनरावृति

1212
00:59:40,280 --> 00:59:44,450
एक समय में एक है में पात्रों के ऊपर।

1213
00:59:44,450 --> 00:59:47,060
और मैं किसी भी इस्तेमाल कर सकते हैं
अंग्रेजी भाषा के विकल्प

1214
00:59:47,060 --> 00:59:49,650
यहाँ प्रत्येक का वर्णन करने के लिए
कोड के इन टुकडों की।

1215
00:59:49,650 --> 00:59:52,740
>> सूचना है कि मैं एक नहीं डाल दिया है
कोड की हर पंक्ति पर टिप्पणी,

1216
00:59:52,740 --> 00:59:55,690
वास्तव में दिलचस्प पर बस
सा हैं कि

1217
00:59:55,690 --> 00:59:59,460
कुछ अर्थ नहीं है कि मैं हो सकता है
किसी को सुपर स्पष्ट करना चाहता हूँ

1218
00:59:59,460 --> 01:00:00,460
मेरे कोड को पढ़ने के।

1219
01:00:00,460 --> 01:00:02,920
और क्यों आप प्राप्त कर बुला रहे हैं
स्ट्रिंग इनपुट के लिए उपयोगकर्ता पूछ रहे हो?

1220
01:00:02,920 --> 01:00:05,450
यहां तक ​​कि एक जरूरी नहीं है
सब है कि वर्णनात्मक।

1221
01:00:05,450 --> 01:00:09,340
लेकिन यह एक कहानी बताने में मदद करता है, क्योंकि
कहानी में दूसरी पंक्ति है, यह सुनिश्चित कर लें

1222
01:00:09,340 --> 01:00:10,740
स्ट्रिंग प्राप्त एक स्ट्रिंग लौट आए।

1223
01:00:10,740 --> 01:00:14,260
>> और कहानी में तीसरी लाइन है,
एस एक में पात्रों पर पुनरावृति

1224
01:00:14,260 --> 01:00:15,380
समय पर।

1225
01:00:15,380 --> 01:00:17,920
और अब सिर्फ अच्छे उपाय के लिए,
मुझे आगे जाना है और जोड़ने के लिए जा रहा हूँ

1226
01:00:17,920 --> 01:00:24,560
एक और टिप्पणी है कि बस
एस में प्रिंट मैं वें चरित्र कहते हैं।

1227
01:00:24,560 --> 01:00:26,520
अब, क्या मैंने किया है
दिन के अंत में?

1228
01:00:26,520 --> 01:00:29,190
>> मैं कुछ अंग्रेजी को शामिल किया है
टिप्पणी के रूप में शब्द।

1229
01:00:29,190 --> 01:00:32,700
स्लेश स्लेश प्रतीक का मतलब है, अरे,
कंप्यूटर इस मानव के लिए है,

1230
01:00:32,700 --> 01:00:33,820
आप के लिए नहीं, कंप्यूटर।

1231
01:00:33,820 --> 01:00:35,119
इसलिए वे तार्किक नजरअंदाज कर रहे हैं।

1232
01:00:35,119 --> 01:00:35,910
वे सिर्फ वहाँ रहे हैं।

1233
01:00:35,910 --> 01:00:39,830
>> और, वास्तव में, CS50 आईडीई के रूप में उन्हें पता चलता है
ग्रे, के रूप में उपयोगी है, लेकिन महत्वपूर्ण नहीं किया जा रहा है

1234
01:00:39,830 --> 01:00:41,000
कार्यक्रम के लिए।

1235
01:00:41,000 --> 01:00:42,570
सूचना है कि तुम अब क्या कर सकते हैं।

1236
01:00:42,570 --> 01:00:44,950
आप सी पता है कि क्या
प्रोग्रामिंग या नहीं, आप

1237
01:00:44,950 --> 01:00:47,722
सिर्फ इस पर वापस खड़े हो सकते हैं
कार्यक्रम है, और टिप्पणियों स्किम।

1238
01:00:47,722 --> 01:00:50,180
इनपुट के लिए उपयोगकर्ता से पूछो, यह सुनिश्चित कर लें
स्ट्रिंग एक स्ट्रिंग लौटे मिलता है,

1239
01:00:50,180 --> 01:00:53,009
एस में पात्रों पर पुनरावृति
एक समय में एक, चरित्र मुद्रित

1240
01:00:53,009 --> 01:00:55,550
मैं वें चरित्र s-- में तुम नहीं करते
यहां तक ​​कि कोड को देखने के लिए

1241
01:00:55,550 --> 01:00:57,270
समझने के लिए इस कार्यक्रम क्या करता है।

1242
01:00:57,270 --> 01:01:00,280
और, बेहतर अभी तक, अगर आप अपने आप को देखो
एक या दो सप्ताह में इस कार्यक्रम में,

1243
01:01:00,280 --> 01:01:02,280
या एक महीने या एक साल,
आप भी नहीं है

1244
01:01:02,280 --> 01:01:04,420
कोड घूरते,
याद करने की कोशिश कर रहा है,

1245
01:01:04,420 --> 01:01:06,630
क्या मैं इस कोड के साथ करने की कोशिश कर रहा था?

1246
01:01:06,630 --> 01:01:07,770
>> तुम अपने आप को बता दिया है।

1247
01:01:07,770 --> 01:01:11,660
आप इसे अपने आप के लिए वर्णित किया है,
या कुछ सहयोगी, या टीए, या टीएफ।

1248
01:01:11,660 --> 01:01:14,860
और हां, यह हो सकता है
सही है, और अच्छे डिजाइन,

1249
01:01:14,860 --> 01:01:18,210
और अंत में अच्छा शैली के रूप में अच्छी तरह से।

1250
01:01:18,210 --> 01:01:19,990
इतना रखना है कि दिमाग में नहीं है।

1251
01:01:19,990 --> 01:01:22,200
>> तो वहाँ एक अन्य है
बात मैं यहाँ करने के लिए जा रहा हूँ

1252
01:01:22,200 --> 01:01:28,240
कि अब प्रकट कर सकते हैं कि वास्तव में क्या है
हुड के नीचे चल रहा है।

1253
01:01:28,240 --> 01:01:30,390
तो वहाँ इस सुविधा है
सी, और अन्य भाषाओं में,

1254
01:01:30,390 --> 01:01:33,010
कहा जाता है typecasting
कि या तो परोक्ष

1255
01:01:33,010 --> 01:01:37,250
या स्पष्ट रूप से आप को बदलने की अनुमति देता है
एक दूसरे के लिए डेटा प्रकार से।

1256
01:01:37,250 --> 01:01:39,800
हम तो काम कर रहा है
अब तक तार के साथ आज।

1257
01:01:39,800 --> 01:01:41,250
>> और तार अक्षर हैं।

1258
01:01:41,250 --> 01:01:44,910
लेकिन पिछले एक सप्ताह से याद
0, वर्ण क्या कर रहे हैं?

1259
01:01:44,910 --> 01:01:49,334
वर्ण सिर्फ एक अमूर्त हैं
numbers-- दशमलव संख्या के शीर्ष पर,

1260
01:01:49,334 --> 01:01:52,500
और दशमलव संख्या वास्तव में सिर्फ एक हैं
द्विआधारी संख्या के शीर्ष पर अमूर्त,

1261
01:01:52,500 --> 01:01:53,720
हम इसे परिभाषित किया।

1262
01:01:53,720 --> 01:01:55,540
>> तो वर्ण संख्या रहे हैं।

1263
01:01:55,540 --> 01:01:58,410
और संख्या अक्षर हैं,
सिर्फ संदर्भ के आधार पर।

1264
01:01:58,410 --> 01:02:01,250
और यह है कि अंदर पता चला है
एक कंप्यूटर प्रोग्राम की,

1265
01:02:01,250 --> 01:02:06,830
आप कैसे आप देखना चाहता हूँ निर्दिष्ट कर सकते हैं
कि इस कार्यक्रम के अंदर बिट्स पर?

1266
01:02:06,830 --> 01:02:10,400
>> हफ्ते 0 कि हम था से याद
ASCII, जो सिर्फ इस कोड है

1267
01:02:10,400 --> 01:02:11,620
नंबरों के लिए मानचित्रण पत्र।

1268
01:02:11,620 --> 01:02:13,660
और हमने कहा, पूंजी एक 65 है।

1269
01:02:13,660 --> 01:02:15,860
पूंजी बी के आगे तो 66 है, और।

1270
01:02:15,860 --> 01:02:20,500
>> और नोटिस, हम अनिवार्य रूप से घर का काम पर है
यहाँ शीर्ष पंक्ति, के रूप में सी उन्हें फोन होगा,

1271
01:02:20,500 --> 01:02:23,400
वर्ण, और उसके बाद
दूसरी पंक्ति पर ints।

1272
01:02:23,400 --> 01:02:28,180
और यह पता चला आप परिवर्तित कर सकते हैं
को मूल दो, आम तौर पर के बीच।

1273
01:02:28,180 --> 01:02:30,042
और हम क्या करना चाहते हैं, तो
इस जानबूझ, हम

1274
01:02:30,042 --> 01:02:31,750
से निपटने के लिए चाहते हो सकता है
कुछ इस तरह।

1275
01:02:31,750 --> 01:02:33,590
>> हम परिवर्तित करने के लिए चाहते हो सकता है
ऊपरी मामले कम करने के लिए

1276
01:02:33,590 --> 01:02:35,330
मामले, अपर केस को कम मामले।

1277
01:02:35,330 --> 01:02:38,000
और यह वहाँ है पता चला है
वास्तव में एक पैटर्न यहाँ

1278
01:02:38,000 --> 01:02:39,900
हम बस एक पल में गले लगा सकते हैं।

1279
01:02:39,900 --> 01:02:44,120
लेकिन एक पर पहले देखो
स्पष्ट रूप से ऐसा करने का उदाहरण है।

1280
01:02:44,120 --> 01:02:46,340
>> मैं CS50 आईडीई में वापस जाने के लिए जा रहा हूँ।

1281
01:02:46,340 --> 01:02:50,640
मैं एक बनाने के लिए जा रहा हूँ
फ़ाइल आस्की 0.c. बुलाया

1282
01:02:50,640 --> 01:02:55,960
और मैं आगे जाना है और जोड़ने के लिए जा रहा हूँ मेरे
शीर्ष पर मानक io.h, int मुख्य शून्य

1283
01:02:55,960 --> 01:02:57,370
मेरे समारोह के शीर्ष पर।

1284
01:02:57,370 --> 01:03:02,700
और फिर मैं सिर्फ क्या करने जा रहा हूँ
पाश के लिए एक following-- मैं से बराबर होती है,

1285
01:03:02,700 --> 01:03:04,610
हम कहते हैं कि, 65 दें।

1286
01:03:04,610 --> 01:03:10,460
>> और फिर मैं की तुलना में कम होने जा रहा है
वर्णमाला में 65, प्लस 26 अक्षरों।

1287
01:03:10,460 --> 01:03:12,640
इसलिए मैं कंप्यूटर दूँगा
वहाँ मेरे लिए गणित है।

1288
01:03:12,640 --> 01:03:15,100
और फिर इस लूप के अंदर,
क्या मैं मुद्रित करने के लिए जा रहा हूँ?

1289
01:03:15,100 --> 01:03:19,230
>> % ग% मैं n बैकस्लैश है।

1290
01:03:19,230 --> 01:03:21,290
और अब मैं दो मूल्यों में प्लग करने के लिए चाहते हैं।

1291
01:03:21,290 --> 01:03:24,530
मैं अस्थायी रूप से सवाल रख दिया है
वहाँ के निशान सवाल आमंत्रित करने के लिए।

1292
01:03:24,530 --> 01:03:29,940
>> मैं आगे 65 से पुनरावृति करना चाहते हैं
वर्णमाला के 26 अक्षरों के लिए,

1293
01:03:29,940 --> 01:03:35,190
प्रत्येक यात्रा पर बाहर मुद्रण है कि
चरित्र का अभिन्न बराबर।

1294
01:03:35,190 --> 01:03:38,299
दूसरे शब्दों में, मैं चाहता हूँ
पुनरावृति से अधिक 26 संख्या मुद्रण

1295
01:03:38,299 --> 01:03:41,590
क्या ASCII वर्ण है, पत्र,
और क्या इसी नंबर है-

1296
01:03:41,590 --> 01:03:44,650
वास्तव में सिर्फ पुनः
उस स्लाइड से चार्ट।

1297
01:03:44,650 --> 01:03:47,010
तो क्या इन प्रश्न चिह्न होना चाहिए?

1298
01:03:47,010 --> 01:03:51,760
>> खैर, यह है कि दूसरे पता चला है
एक बस चर रहा होना चाहिए।

1299
01:03:51,760 --> 01:03:53,860
मैं देखना है कि एक नंबर के रूप में चाहते हैं।

1300
01:03:53,860 --> 01:03:58,920
और मध्य तर्क
यहाँ, मैं कंप्यूटर बता सकते हैं

1301
01:03:58,920 --> 01:04:03,470
कि पूर्णांक के इलाज के लिए
मैं एक चरित्र के रूप में, के रूप में तो

1302
01:04:03,470 --> 01:04:05,880
यह यहां प्रतिशत सी के लिए विकल्प

1303
01:04:05,880 --> 01:04:07,990
>> दूसरे शब्दों में, अगर मैं,
मानव प्रोग्रामर, जानते

1304
01:04:07,990 --> 01:04:09,865
ये तो बस संख्या रहे हैं
दिन के अंत में।

1305
01:04:09,865 --> 01:04:12,500
और मुझे पता है कि 65 चाहिए
कुछ चरित्र के लिए नक्शे।

1306
01:04:12,500 --> 01:04:15,310
इस स्पष्ट कलाकारों के साथ,
एक कोष्ठक,

1307
01:04:15,310 --> 01:04:18,840
आप चाहते हैं डेटा प्रकार का नाम
कन्वर्ट करने के लिए, और एक बंद कोष्ठक,

1308
01:04:18,840 --> 01:04:21,200
आप बता सकते हैं
कंप्यूटर, हे, कंप्यूटर,

1309
01:04:21,200 --> 01:04:24,130
एक चार को यह पूर्णांक परिवर्तित।

1310
01:04:24,130 --> 01:04:26,250
>> तो जब मैं इस चलाने
कार्यक्रम के संकलन के बाद,

1311
01:04:26,250 --> 01:04:29,740
चलो देखते हैं कि मैं क्या get-- आस्की 0 बनाते हैं।

1312
01:04:29,740 --> 01:04:33,020
अरे यह क्या मैं गलत यहाँ क्या किया?

1313
01:04:33,020 --> 01:04:35,884
अघोषित पहचानकर्ता का उपयोग करें,
सब ठीक है, जानबूझकर नहीं,

1314
01:04:35,884 --> 01:04:37,800
लेकिन चलो देखते हैं, तो हम नहीं कर सकते
इस के माध्यम से कारण है।

1315
01:04:37,800 --> 01:04:41,220
>> तो लाइन five-- तो मैं नहीं मिला
बहुत दूर पंगा लेना पहले।

1316
01:04:41,220 --> 01:04:42,140
ठीक है।

1317
01:04:42,140 --> 01:04:46,560
तो लाइन 5 मैं के लिए बराबर होती है 65-- मैं देख रहा हूँ।

1318
01:04:46,560 --> 01:04:50,130
तो सी में याद है कि, कुछ के विपरीत
यदि आप पहले प्रोग्रामिंग है भाषाओं

1319
01:04:50,130 --> 01:04:52,190
अनुभव, आपके पास
कंप्यूटर बताने के लिए,

1320
01:04:52,190 --> 01:04:55,040
स्क्रैच के विपरीत, क्या
चर का प्रकार है।

1321
01:04:55,040 --> 01:04:56,860
>> और मैं एक चाबी वाक्यांश यहाँ भूल गया।

1322
01:04:56,860 --> 01:04:59,200
लाइन पांच में, मैं मैं का उपयोग शुरू कर दिया है।

1323
01:04:59,200 --> 01:05:01,560
लेकिन मैं सी नहीं बताया है
क्या डेटा प्रकार यह है।

1324
01:05:01,560 --> 01:05:04,570
तो मैं यहाँ में जाने के लिए जा रहा हूँ और
कहते हैं, आह, यह एक पूर्णांक हैं।

1325
01:05:04,570 --> 01:05:07,050
>> अब मुझे आगे जाना है और फिर कंपाइल करने के लिए जा रहा हूँ।

1326
01:05:07,050 --> 01:05:08,080
यही कारण है कि तय की।

1327
01:05:08,080 --> 01:05:12,660
./ascii0 दर्ज करें, जो कि एक तरह से शांत है।

1328
01:05:12,660 --> 01:05:15,360
इतना ही नहीं यह सुपर करने के लिए तेजी से होता है
, कंप्यूटर इस सवाल पूछना

1329
01:05:15,360 --> 01:05:18,885
बल्कि एक स्लाइड पर यह ऊपर की तलाश से,
यह एक प्रति पंक्ति बाहर मुद्रित, एक 65 है,

1330
01:05:18,885 --> 01:05:24,860
बी के बाद से मैं down-- 66, सभी तरह है
पत्र Z करने के लिए इस 26 गुना था,

1331
01:05:24,860 --> 01:05:25,630
जो 90 है।

1332
01:05:25,630 --> 01:05:27,790
और, वास्तव में, थोड़ा
अधिक बुद्धिमान होता

1333
01:05:27,790 --> 01:05:31,030
मेरे लिए नहीं किया गया है भरोसा करने के लिए
कंप्यूटर पर 26 जोड़ने के लिए।

1334
01:05:31,030 --> 01:05:34,060
मैं तो बस किया जा सकता है
90 के रूप में अच्छी तरह से, इतने लंबे समय

1335
01:05:34,060 --> 01:05:37,390
के रूप में मैं एक ही गलती दो बार नहीं बनाते हैं।

1336
01:05:37,390 --> 01:05:41,880
मैं के माध्यम से ऊपर जाने के लिए चाहते हैं
जेड, न सिर्फ y के माध्यम से ऊपर।

1337
01:05:41,880 --> 01:05:44,000
>> ताकि एक स्पष्ट डाली है।

1338
01:05:44,000 --> 01:05:47,860
यह यह है कि पता चला है
यहां तक ​​कि जरूरी नहीं है।

1339
01:05:47,860 --> 01:05:52,480
मुझे आगे जाना है और यह फिर से दौड़ना चलो
संकलक, और फिर से दौड़ना आस्की 0।

1340
01:05:52,480 --> 01:05:54,940
यह पता चला है कि सी बहुत चालाक है।

1341
01:05:54,940 --> 01:05:57,150
>> और printf, विशेष रूप से,
बहुत चालाक है।

1342
01:05:57,150 --> 01:06:01,260
तुम सिर्फ एक मैं दो बार गुजरती हैं
दोनों प्लेसहोल्डर्स के लिए, printf

1343
01:06:01,260 --> 01:06:04,510
एहसास होगा ओह, ठीक है मैं तुम्हें पता है
मुझे एक कुछ संख्या integer-- दिया,

1344
01:06:04,510 --> 01:06:06,380
65, या 90, या जो भी पसंद है।

1345
01:06:06,380 --> 01:06:10,170
लेकिन मैं देख रहा हूँ कि तुम मुझे चाहते
एक चरित्र की तरह है कि संख्या स्वरूप।

1346
01:06:10,170 --> 01:06:16,460
और तो printf के संकेत भी डाल सकते हैं
के रूप में अच्छी तरह से आप के लिए एक चार को int।

1347
01:06:16,460 --> 01:06:19,360
तो यह है कि सब में एक समस्या नहीं है।

1348
01:06:19,360 --> 01:06:23,100
>> लेकिन नोटिस, इस तुल्यता की वजह
हम वास्तव में इस के रूप में अच्छी तरह से कर सकते हैं।

1349
01:06:23,100 --> 01:06:26,520
मुझे आगे जाना है और एक कर दूं
this-- आस्की 1.c. के दूसरे संस्करण

1350
01:06:26,520 --> 01:06:31,800
और के बजाय पर iterating
पूर्णांकों, वास्तव में आपके मन उड़ा सकते हैं

1351
01:06:31,800 --> 01:06:33,610
पात्रों पर iterating द्वारा।

1352
01:06:33,610 --> 01:06:37,660
एक चार सी पूंजी एक हो जाता है, तो मैं
आगे जाना है और ऐसा करना चाहते हैं,

1353
01:06:37,660 --> 01:06:41,740
इतने लंबे समय सेल्सियस से कम या बराबर है के रूप में
राजधानी जेड और प्रत्येक यात्रा पर

1354
01:06:41,740 --> 01:06:45,690
मैं सी वेतन वृद्धि करना चाहते हैं, मैं कर सकता हूँ
अब मेरे printf लाइन में यहाँ

1355
01:06:45,690 --> 01:06:51,320
कहते हैं, प्रतिशत सी है
मैं फिर प्रतिशत, अल्पविराम सी

1356
01:06:51,320 --> 01:06:57,200
>> और अब, मैं दूसरी दिशा में जा सकते हैं,
चरित्र को स्पष्ट रूप से कास्टिंग

1357
01:06:57,200 --> 01:06:58,500
एक पूर्णांक के लिए।

1358
01:06:58,500 --> 01:07:00,560
तो, फिर से, तुम क्यों यह करना होगा?

1359
01:07:00,560 --> 01:07:03,830
इसके बारे में सुलझाने के लिए एक अजीब सा है
पात्रों के मामले में गिनते हैं।

1360
01:07:03,830 --> 01:07:07,430
>> लेकिन अगर आप समझते क्या है
हुड के नीचे चल रहा है,

1361
01:07:07,430 --> 01:07:08,430
वहाँ वास्तव में कोई जादू है।

1362
01:07:08,430 --> 01:07:13,060
तुम बस कह रहे हैं, अरे, कंप्यूटर देना
मुझे एक चर प्रकार चार की सी कहा जाता है।

1363
01:07:13,060 --> 01:07:16,520
राजधानी ए करने के लिए इसे प्रारंभ और
एकल उद्धरण बात पर ध्यान दिया।

1364
01:07:16,520 --> 01:07:19,580
>> सी में पात्रों के लिए, से याद
पिछले हफ्ते, आप एक उद्धरण का उपयोग करें।

1365
01:07:19,580 --> 01:07:23,720
तार के लिए, शब्दों के लिए,
वाक्यांश, आप डबल उद्धरण का उपयोग करें।

1366
01:07:23,720 --> 01:07:27,210
ठीक है, कंप्यूटर, यह कर रखना है, तो
चरित्र के रूप में लंबे समय से कम है

1367
01:07:27,210 --> 01:07:28,050
या जेड के बराबर है।

1368
01:07:28,050 --> 01:07:32,640
और मैं अपने ASCII तालिका से पता है कि सब
इन आस्की कोड से सटे हैं।

1369
01:07:32,640 --> 01:07:33,400
>> वहाँ कोई अंतराल है।

1370
01:07:33,400 --> 01:07:36,737
तो यह सिर्फ एक जेड के माध्यम से है,
एक संख्या प्रत्येक से अलग कर दिया।

1371
01:07:36,737 --> 01:07:38,820
और फिर मैं वेतन वृद्धि कर सकते हैं
एक चार, अगर मैं वास्तव में चाहते हैं।

1372
01:07:38,820 --> 01:07:40,390
आखिरकार दिन के अंत में,
यह सिर्फ एक संख्या है।

1373
01:07:40,390 --> 01:07:41,030
मैं यह जानता हूँ।

1374
01:07:41,030 --> 01:07:43,670
तो मैं सिर्फ यह करने के लिए 1 से जोड़ने के लिए मान सकते हैं।

1375
01:07:43,670 --> 01:07:46,940
>> और फिर इस बार, मैं सी प्रिंट,
और फिर अभिन्न बराबर।

1376
01:07:46,940 --> 01:07:50,170
और मैं भी स्पष्ट कलाकारों की जरूरत नहीं है।

1377
01:07:50,170 --> 01:07:52,680
मैं printf और दे सकते हैं,
कंप्यूटर आंकड़ा चीजें बाहर,

1378
01:07:52,680 --> 01:07:57,300
तो यह है कि अब अगर मैं चला
Ascii1./ascii1 बनाने,

1379
01:07:57,300 --> 01:08:01,520
मैं भी सटीक एक ही बात हो।

1380
01:08:01,520 --> 01:08:04,530
>> बेकार कार्यक्रम, कोई भी though--
वास्तव में सॉफ्टवेयर लिखने के लिए जा रहा है

1381
01:08:04,530 --> 01:08:07,549
आदेश में यह पता लगाने के लिए, क्या था
संख्या है कि एक करने के लिए नक्शे, या बी, या जेड?

1382
01:08:07,549 --> 01:08:10,340
तुम बस या यह गूगल के लिए जा रहे हैं,
यह देखने के ऑनलाइन, या इसे देखो

1383
01:08:10,340 --> 01:08:11,650
एक स्लाइड, या जैसे पर।

1384
01:08:11,650 --> 01:08:13,520
तो जहां यह वास्तव में उपयोगी मिलता है?

1385
01:08:13,520 --> 01:08:15,960
>> खैर, उस की बात
स्लाइड, वहाँ नोटिस

1386
01:08:15,960 --> 01:08:20,890
अपरकेस के बीच एक वास्तविक पैटर्न यहाँ
और छोटे आकस्मिक नहीं था।

1387
01:08:20,890 --> 01:08:23,760
सूचना है कि राजधानी में एक 65 है।

1388
01:08:23,760 --> 01:08:25,830
लोअरकेस एक 97 है।

1389
01:08:25,830 --> 01:08:29,649
और दूर कितनी दूर निचले मामले एक है?

1390
01:08:29,649 --> 01:08:32,649
>> तो 65 97 से कितने कदम दूर है?

1391
01:08:32,649 --> 01:08:36,210
तो 97 शून्य से 65 से 32 है।

1392
01:08:36,210 --> 01:08:37,910
तो राजधानी में एक 65 है।

1393
01:08:37,910 --> 01:08:39,939
आप उस के लिए 32 जोड़ दें, तो
आप एक छोटे से मिलता है।

1394
01:08:39,939 --> 01:08:43,729
और, यों, अगर आप 32 घटाना,
आप पूंजी को वापस पाने के एक-- बी के साथ ही

1395
01:08:43,729 --> 01:08:46,380
छोटी सी बी करने के लिए, छोटी सी के लिए बड़ी सी।

1396
01:08:46,380 --> 01:08:50,670
>> इन कमियों के सभी 32 अलग कर रहे हैं।

1397
01:08:50,670 --> 01:08:54,450
अब, यह हमारे लिए अनुमति देने के लिए प्रतीत होता है
माइक्रोसॉफ्ट वर्ड की तरह कुछ करते हैं,

1398
01:08:54,450 --> 01:08:57,729
या गूगल डॉक्स की सुविधा है, जहां आप
सब कुछ का चयन कर सकते हैं और फिर कहते हैं,

1399
01:08:57,729 --> 01:09:00,520
लोअरकेस सब बदलने के लिए, या
अपर केस में सब बदलने के लिए,

1400
01:09:00,520 --> 01:09:03,840
या सिर्फ पहला शब्द बदल
अपर केस में एक वाक्य के।

1401
01:09:03,840 --> 01:09:07,390
हम वास्तव में कुछ कर सकते हैं
अपने आप को लगता है कि जैसे।

1402
01:09:07,390 --> 01:09:12,645
>> मुझे आगे चलते हैं और एक फ़ाइल को बचाने के
यहाँ 0.c. भुनाने बुलाया

1403
01:09:12,645 --> 01:09:15,770
और आगे बढ़ते हैं और एक कार्यक्रम कोड़ा चलो
कि ठीक है कि इस प्रकार के रूप में करता है।

1404
01:09:15,770 --> 01:09:18,460
तो CS50 पुस्तकालय में शामिल हैं।

1405
01:09:18,460 --> 01:09:21,430
और मानक आई / ओ शामिल हैं।

1406
01:09:21,430 --> 01:09:22,787
>> और मैं यह जल्द ही आ रहा है पता है।

1407
01:09:22,787 --> 01:09:24,870
तो मैं इसे में डाल करने के लिए जा रहा हूँ
वहां पहले से ही, string.h,

1408
01:09:24,870 --> 01:09:26,960
इसलिए मैं करने के लिए उपयोग किया है
स्टर्लिंग की तरह बातें,

1409
01:09:26,960 --> 01:09:29,620
और फिर मुख्य शून्य int, हमेशा की तरह।

1410
01:09:29,620 --> 01:09:33,420
और फिर मैं आगे जाने के लिए जा रहा हूँ
और तार कर स्ट्रिंग प्राप्त हो जाता है,

1411
01:09:33,420 --> 01:09:35,032
सिर्फ उपयोगकर्ता से एक स्ट्रिंग पाने के लिए।

1412
01:09:35,032 --> 01:09:36,740
और फिर मैं करने जा रहा हूँ
मेरी मानसिक स्वास्थ्य की जांच कर रहे हैं।

1413
01:09:36,740 --> 01:09:40,510
स्ट्रिंग बराबर रिक्त नहीं करता है,
तो यह आगे बढ़ने के लिए सुरक्षित है।

1414
01:09:40,510 --> 01:09:42,000
और मैं क्या करना चाहते हो?

1415
01:09:42,000 --> 01:09:48,700
मैं पुनरावृति करने से मैं 0 के बराबर होती है जा रहा हूँ,
और एन एस की स्ट्रिंग की लंबाई पर निर्भर है।

1416
01:09:48,700 --> 01:09:51,899
>> और मैं इतने लंबे समय के रूप में यह करने के लिए जा रहा हूँ
मैं n से कम नहीं है, और मैं प्लस प्लस।

1417
01:09:51,899 --> 01:09:55,060
अब तक, मैं वास्तव में अभी कर रहा हूँ
पहले से विचारों उधार।

1418
01:09:55,060 --> 01:09:57,010
और अब मैं एक शाखा शुरू करने जा रहा हूँ।

1419
01:09:57,010 --> 01:09:59,635
>> तो स्क्रैच, जहां के लिए वापस लगता है
हम सड़क में उन लोगों के कांटे था,

1420
01:09:59,635 --> 01:10:05,110
और पिछले हफ्ते सी में मैं जा रहा हूँ
यह कहना है, अगर एस में मैं वें चरित्र

1421
01:10:05,110 --> 01:10:09,250
है या उससे अधिक
मामले में एक कम करने के लिए बराबर है,

1422
01:10:09,250 --> 01:10:13,340
और-- खरोंच में आप सचमुच होगा
कहते हैं और, लेकिन सी में आप कहते हैं एम्परसेंड,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- और एस में मैं वें चरित्र
कम से कम या मामले Z कम करने के लिए बराबर है,

1424
01:10:19,830 --> 01:10:21,780
चलो कुछ दिलचस्प करते हैं।

1425
01:10:21,780 --> 01:10:27,020
चलो वास्तव में एक प्रिंट आउट
कोई newline के साथ चरित्र

1426
01:10:27,020 --> 01:10:31,760
कि स्ट्रिंग में चरित्र है,
स्ट्रिंग में मैं वें चरित्र।

1427
01:10:31,760 --> 01:10:37,420
>> लेकिन आगे चलते हैं और
इसमें से 32 घटाना।

1428
01:10:37,420 --> 01:10:42,120
वरना अगर चरित्र
स्ट्रिंग है कि हम देख रहे हैं

1429
01:10:42,120 --> 01:10:45,950
छोटे से एक के बीच नहीं है
और थोड़ा Z, आगे बढ़ो

1430
01:10:45,950 --> 01:10:48,610
और इसे बाहर अपरिवर्तित छपी।

1431
01:10:48,610 --> 01:10:50,840
इसलिए हम शुरू की है
इस कोष्ठकों के भीतर संकेतन

1432
01:10:50,840 --> 01:10:53,560
हमारे तार पर प्राप्त करने के लिए
मैं वें स्ट्रिंग में चरित्र।

1433
01:10:53,560 --> 01:10:57,520
>> मैं जैसे कुछ सशर्त तर्क जोड़ दिया है,
पिछले हफ्ते के सप्ताह एक है, जहां में खरोंच

1434
01:10:57,520 --> 01:10:59,880
मैं सिर्फ अपने मौलिक उपयोग कर रहा हूँ
क्या की समझ

1435
01:10:59,880 --> 01:11:01,130
हुड के नीचे चल रहा है।

1436
01:11:01,130 --> 01:11:04,190
एस के मैं वें चरित्र है
से अधिक या एक के बराबर?

1437
01:11:04,190 --> 01:11:08,290
की तरह, यह, 97, या 98 है
या 99, और बहुत आगे है?

1438
01:11:08,290 --> 01:11:11,940
>> लेकिन यह भी कम से कम या बराबर है
लोअरकेस जेड के मूल्य के लिए?

1439
01:11:11,940 --> 01:11:16,210
और अगर ऐसा है, क्या इस लाइन मतलब है?

1440
01:11:16,210 --> 01:11:20,250
14, इस की तरह है
पूरे विचार के रोगाणु,

1441
01:11:20,250 --> 01:11:23,840
द्वारा अक्षर को कैपिटल
बस से 32 को घटाकर,

1442
01:11:23,840 --> 01:11:29,370
इस मामले में, क्योंकि मुझे पता है, कि प्रति
चार्ट, कैसे अपनी संख्या प्रतिनिधित्व कर रहे हैं।

1443
01:11:29,370 --> 01:11:33,925
तो चलो आगे जाना है और इस चलाते हैं,
0.c भुनाने के संकलन के बाद,

1444
01:11:33,925 --> 01:11:36,210
और रन 0 कैपिटल में लिखें।

1445
01:11:36,210 --> 01:11:40,300
>> की तरह कुछ में टाइप करते हैं
सभी लोअरकेस में Zamyla दर्ज करें।

1446
01:11:40,300 --> 01:11:42,780
और अब हम सभी अपरकेस में Zamyla है।

1447
01:11:42,780 --> 01:11:45,050
के सभी छोटे अक्षरों में रोब में टाइप करते हैं।

1448
01:11:45,050 --> 01:11:46,674
के सभी छोटे अक्षरों में जेसन कोशिश करते हैं।

1449
01:11:46,674 --> 01:11:48,590
और हम हो रही रखने के
मजबूर पूंजीकरण।

1450
01:11:48,590 --> 01:11:50,960
वहाँ एक मामूली बग है कि मैं
एक तरह से सोचा भी नहीं था।

1451
01:11:50,960 --> 01:11:54,050
सूचना है मेरी नई शीघ्र खत्म हो रही है
उनके नाम के रूप में एक ही लाइन पर,

1452
01:11:54,050 --> 01:11:55,520
जो एक छोटे से गंदा लगता है।

1453
01:11:55,520 --> 01:11:59,170
>> तो मैं यहाँ जाने के लिए जा रहा हूँ, और
वास्तव में इस कार्यक्रम के अंत में

1454
01:11:59,170 --> 01:12:02,110
एक नई चरित्र बाहर प्रिंट।

1455
01:12:02,110 --> 01:12:03,160
बस इतना ही।

1456
01:12:03,160 --> 01:12:06,120
printf के साथ, आप की जरूरत नहीं है
चर या प्रारूप कोड में गुजरती हैं।

1457
01:12:06,120 --> 01:12:08,460
तुम सचमुच बस प्रिंट कर सकते हैं
एक नई तरह कुछ।

1458
01:12:08,460 --> 01:12:13,529
>> तो चलो आगे जाना है और बनाते हैं
0 फिर से भुनाने के लिए, यह फिर से दौड़ना, Zamyla।

1459
01:12:13,529 --> 01:12:14,820
और अब यह एक छोटे से सुंदर है।

1460
01:12:14,820 --> 01:12:17,274
अब, मेरे शीघ्र अपनी नई लाइन पर है।

1461
01:12:17,274 --> 01:12:18,440
तो यह है कि सब ठीक है और अच्छा है।

1462
01:12:18,440 --> 01:12:19,910
तो यह है कि एक अच्छा उदाहरण है।

1463
01:12:19,910 --> 01:12:22,700
लेकिन मैं यह भी जरूरी नहीं है
मुश्किल कोड 32 करने की जरूरत है।

1464
01:12:22,700 --> 01:12:23,350
आपको पता है कि?

1465
01:12:23,350 --> 01:12:26,350
मैं say-- सकता है मैं कभी नहीं करते
याद क्या अंतर है।

1466
01:12:26,350 --> 01:12:29,330
>> लेकिन मुझे पता है कि अगर मैं
एक कम मामले पत्र है,

1467
01:12:29,330 --> 01:12:34,430
मैं अनिवार्य रूप से बंद घटाना चाहते हैं
जो कुछ दूरी थोड़ा के बीच है

1468
01:12:34,430 --> 01:12:39,160
एक और बड़ी ए, क्योंकि अगर मैं उस मान
अन्य पत्र के सभी एक ही हैं,

1469
01:12:39,160 --> 01:12:41,045
कि काम मिल चाहिए।

1470
01:12:41,045 --> 01:12:42,670
लेकिन ऐसा करने कि बजाय, क्या आपको पता है?

1471
01:12:42,670 --> 01:12:44,240
वहाँ अभी भी एक और तरीका है।

1472
01:12:44,240 --> 01:12:48,090
>> तो यह है कि अगर मैं थे 1.c-- भुनाने है
एक अलग फाइल में डाल दिया है कि।

1473
01:12:48,090 --> 01:12:51,030
की भुनाने 2.c करते प्रकार के रूप में करते हैं।

1474
01:12:51,030 --> 01:12:53,060
मैं वास्तव में यहाँ यह साफ करने के लिए जा रहा हूँ।

1475
01:12:53,060 --> 01:12:57,420
और बदले की भी करने के लिए होने
जानते हैं या उन निम्न स्तर के बारे में परवाह

1476
01:12:57,420 --> 01:13:01,090
कार्यान्वयन के विवरण, मैं बजाय हूँ
सिर्फ एक चरित्र मुद्रित करने के लिए जा रहा है,

1477
01:13:01,090 --> 01:13:04,610
बोली गंदें शब्द बोलना, प्रतिशत सी, और
फिर एक और समारोह फोन है कि

1478
01:13:04,610 --> 01:13:09,950
मौजूद है कि एक तर्क लेता है,
जो एक चरित्र है, इस तरह से है।

1479
01:13:09,950 --> 01:13:12,630
>> यह सी में पता चला है, वहाँ है
एक अन्य समारोह कॉल

1480
01:13:12,630 --> 01:13:15,550
ऊपरी करने के लिए है जो अपने नाम के रूप में
पता चलता है एक चरित्र लेता है

1481
01:13:15,550 --> 01:13:19,350
और यह अपने ऊपरी मामले के लिए बनाता है
बराबर है, और फिर यह रिटर्न

1482
01:13:19,350 --> 01:13:21,410
इतना है कि printf वहाँ में प्लग कर सकते हैं।

1483
01:13:21,410 --> 01:13:25,484
और इसलिए यह करने के लिए, हालांकि, मैं
एक अन्य फ़ाइल को पेश करने की जरूरत है।

1484
01:13:25,484 --> 01:13:28,400
यह बदल जाता है एक और फाइल वहाँ बाहर
कि आप केवल वर्ग से पता होगा,

1485
01:13:28,400 --> 01:13:33,020
या एक पाठ्यपुस्तक, या एक ऑनलाइन
संदर्भ, सी type.h. बुलाया

1486
01:13:33,020 --> 01:13:38,570
>> तो अगर मुझे लगता है कि मेरे हेडर के बीच
फ़ाइलों, और अब फिर से संकलन इस कार्यक्रम,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, दर्ज ./capitalize2।

1488
01:13:43,040 --> 01:13:46,690
हम सब में Zamyla में टाइप करते हैं
लोअरकेस, अभी भी एक ही काम करता है।

1489
01:13:46,690 --> 01:13:48,040
लेकिन तुम जानते हो क्या?

1490
01:13:48,040 --> 01:13:55,590
यह ऊपरी को पता चला है कि
कुछ अन्य कार्यक्षमता है।

1491
01:13:55,590 --> 01:13:58,410
>> और मुझे इस परिचय
यहाँ की आज्ञा है, की तरह awkwardly

1492
01:13:58,410 --> 01:14:00,250
नाम है, लेकिन मैनुअल के लिए आदमी।

1493
01:14:00,250 --> 01:14:03,960
यह पता चला है कि ज्यादातर लिनक्स कंप्यूटर,
हम लिनक्स ऑपरेटिंग here-- के रूप में प्रयोग कर रहे हैं

1494
01:14:03,960 --> 01:14:06,270
system-- एक आदेश दिया है
कहा जाता है आदमी, जो कहते हैं,

1495
01:14:06,270 --> 01:14:08,530
अरे, कंप्यूटर, मुझे दे
कंप्यूटर के मैनुअल।

1496
01:14:08,530 --> 01:14:10,680
तुम चाहते क्या हो
कि मैनुअल में देखो?

1497
01:14:10,680 --> 01:14:13,840
>> मैं इस समारोह को देखने के लिए चाहते हैं
ऊपरी करने के लिए कहा जाता है, दर्ज करें।

1498
01:14:13,840 --> 01:14:16,070
और यह एक छोटे गुप्त है
कभी कभी पढ़ने के लिए।

1499
01:14:16,070 --> 01:14:18,780
लेकिन नोटिस हम कर रहे हैं
लिनक्स प्रोग्रामर मैनुअल।

1500
01:14:18,780 --> 01:14:19,530
और यह सब पाठ है।

1501
01:14:19,530 --> 01:14:21,905
और सूचना है कि वहाँ
यहाँ समारोह का नाम।

1502
01:14:21,905 --> 01:14:25,030
यह पता चला है कि यह एक चचेरे भाई का आह्वान किया है
कम करने के लिए है, जो विपरीत है।

1503
01:14:25,030 --> 01:14:29,710
और सार के तहत नोटिस, इस का उपयोग करने के लिए
आदमी पेज समारोह, तो बात है,

1504
01:14:29,710 --> 01:14:32,220
मुझे लगता है कि मैं बता रहा है
ग type.h. शामिल करने की जरूरत

1505
01:14:32,220 --> 01:14:33,630
और मैं अभ्यास से पता था कि।

1506
01:14:33,630 --> 01:14:36,210
>> इधर, यह मुझे दिखा रहा है दो
समारोह के लिए प्रोटोटाइप,

1507
01:14:36,210 --> 01:14:39,070
इतना है कि मैं कभी भी इस प्रयोग करना चाहते हैं
मैं जानता हूँ कि क्या वे इनपुट के रूप में लेते हैं,

1508
01:14:39,070 --> 01:14:40,652
और क्या वे आउटपुट के रूप में वापसी।

1509
01:14:40,652 --> 01:14:42,360
और फिर अगर मैं पढ़
विवरण, मैं देख रहा हूँ

1510
01:14:42,360 --> 01:14:44,820
और अधिक विस्तार में क्या कार्य करता है।

1511
01:14:44,820 --> 01:14:48,100
लेकिन अधिक महत्वपूर्ण बात, अगर
मैं, वापसी मान के नीचे देखो

1512
01:14:48,100 --> 01:14:51,710
इसे कहते हैं, मान है
परिवर्तित पत्र की कि,

1513
01:14:51,710 --> 01:14:57,880
या सी, मूल इनपुट, अगर
रूपांतरण संभव नहीं था।

1514
01:14:57,880 --> 01:15:01,992
>> दूसरे शब्दों में, ऊपरी कोशिश करेंगे
ऊपरी मामले को एक पत्र परिवर्तित करने के लिए।

1515
01:15:01,992 --> 01:15:03,450
और अगर हां, तो यह इसे वापस करने के लिए जा रहा है।

1516
01:15:03,450 --> 01:15:07,010
लेकिन अगर कुछ reason-- के लिए नहीं यह कर सकते हैं
शायद यह पहले से ही ऊपरी मामला है,

1517
01:15:07,010 --> 01:15:09,550
हो सकता है यह एक विस्मयादिबोधक बिंदु है
या कुछ अन्य punctuation--

1518
01:15:09,550 --> 01:15:12,200
यह सिर्फ करने के लिए जा रहा है
मूल सी वापसी,

1519
01:15:12,200 --> 01:15:17,340
जिसका मतलब है कि मैं अपने कोड बना सकते हैं
बेहतर रूप में इस प्रकार बनाया गया है।

1520
01:15:17,340 --> 01:15:20,580
>> मैं सभी की जरूरत नहीं है
कोड के इन रफ़ू लाइनों।

1521
01:15:20,580 --> 01:15:22,610
लाइनों रहा है सब
सिर्फ प्रकाश डाला कर सकते हैं

1522
01:15:22,610 --> 01:15:28,700
सिर्फ एक सरल में ढह किया
लाइन है, जो this-- printf प्रतिशत है

1523
01:15:28,700 --> 01:15:33,510
ऊपरी एस ब्रैकेट मैं करने के लिए ग।

1524
01:15:33,510 --> 01:15:36,090
और यह एक होगा
बेहतर डिजाइन का उदाहरण है।

1525
01:15:36,090 --> 01:15:40,040
>> क्यों 7 या 8 लाइनों में लागू
कोड की, जो कुछ भी मैं बस गया था

1526
01:15:40,040 --> 01:15:44,960
नष्ट कर दिया, जब आप के बजाय गिर सकते हैं
कि तर्क और निर्णय लेने के सभी

1527
01:15:44,960 --> 01:15:49,620
एक भी लाइन, 13, में है कि
एक पुस्तकालय पर निर्भर करता है function--

1528
01:15:49,620 --> 01:15:53,430
एक समारोह में कहा कि सी के साथ आता है, लेकिन लगता है कि
क्या आप यह करना चाहते हैं ठीक है।

1529
01:15:53,430 --> 01:15:55,295
और, सच में, भले ही
यह सी के साथ नहीं आया था,

1530
01:15:55,295 --> 01:15:58,880
आप इसे अपने आप लागू कर सकता है, के रूप में
हमने देखा है, नकारात्मक int मिल के साथ

1531
01:15:58,880 --> 01:16:01,700
और सकारात्मक int पिछले सप्ताह के रूप में अच्छी तरह से मिलता है।

1532
01:16:01,700 --> 01:16:03,470
>> इस कोड को अब और अधिक पठनीय है।

1533
01:16:03,470 --> 01:16:06,670
और, वास्तव में, हम ऊपर स्क्रॉल हैं,
कितना अधिक कॉम्पैक्ट देखो

1534
01:16:06,670 --> 01:16:08,360
अपने कार्यक्रम के इस संस्करण है।

1535
01:16:08,360 --> 01:16:11,230
यह एक छोटे से ऊपर भारी हो चुकी है,
इन सभी शामिल हैं के साथ।

1536
01:16:11,230 --> 01:16:14,380
लेकिन यह ठीक है, क्योंकि अब मैं खड़ा हूँ
प्रोग्रामर के कंधों पर

1537
01:16:14,380 --> 01:16:15,300
मुझसे पहले।

1538
01:16:15,300 --> 01:16:18,440
और जो कोई भी था जो
वास्तव में ऊपरी करने के लिए लागू

1539
01:16:18,440 --> 01:16:21,470
मुझे एक एहसान किया जो कोई भी बहुत पसंद है
कार्यान्वित स्टर्लिंग वास्तव में

1540
01:16:21,470 --> 01:16:24,790
मुझ पर एक एहसान कुछ समय पहले किया था।

1541
01:16:24,790 --> 01:16:26,970
और इसलिए अब हम एक है
बेहतर डिजाइन कार्यक्रम

1542
01:16:26,970 --> 01:16:31,680
कि सटीक एक ही तर्क लागू करता है।

1543
01:16:31,680 --> 01:16:35,580
>> स्टर्लिंग की बात हो रही है, चलो
मुझे आगे जाना है और यह करते हैं।

1544
01:16:35,580 --> 01:16:38,320
मुझे आगे जाना है और बचाने के लिए करते हैं
इस फ़ाइल stirling.c के रूप में।

1545
01:16:38,320 --> 01:16:43,255
और यह पता चला है, हम वापस छील कर सकते हैं
एक अन्य परत बहुत बस अब।

1546
01:16:43,255 --> 01:16:45,630
मैं आगे और कोड़ा जाने के लिए जा रहा हूँ
मुख्य में एक अन्य कार्यक्रम अप

1547
01:16:45,630 --> 01:16:49,759
यहाँ यह है कि बस फिर से लागू करता है
स्ट्रिंग की लंबाई इस प्रकार है।

1548
01:16:49,759 --> 01:16:52,300
यहाँ तो कोड की एक पंक्ति है कि
मुझे उपयोगकर्ता से एक स्ट्रिंग हो जाता है।

1549
01:16:52,300 --> 01:16:53,910
हम फिर से और फिर से इस का उपयोग कर रखना।

1550
01:16:53,910 --> 01:16:58,900
मुझे अपने आप को एक चर बुलाया दे
int प्रकार है कि एक नंबर भंडार के एन।

1551
01:16:58,900 --> 01:17:02,490
>> और मुझे आगे जाना है और
निम्नलिखित तर्क नहीं है।

1552
01:17:02,490 --> 01:17:15,610
एस में n वें चरित्र करता है
बराबर नहीं बैकस्लैश 0, आगे बढ़ो

1553
01:17:15,610 --> 01:17:17,930
और एन वेतन वृद्धि।

1554
01:17:17,930 --> 01:17:23,506
और फिर printf प्रतिशत मैं n बाहर प्रिंट।

1555
01:17:23,506 --> 01:17:29,200
मुझे लगता है कि इस कार्यक्रम को यहाँ दावा करते हैं,
स्ट्रिंग लंबाई फोन के बिना,

1556
01:17:29,200 --> 01:17:31,150
एक स्ट्रिंग की लंबाई बाहर के आंकड़े।

1557
01:17:31,150 --> 01:17:34,600
>> और जादू पूरी तरह से है
8 लाइन में समझाया

1558
01:17:34,600 --> 01:17:39,830
यहाँ क्या नई वाक्य रचना की तरह लग रहा है के साथ,
इस बैकस्लैश 0 एकल उद्धरण में।

1559
01:17:39,830 --> 01:17:41,360
लेकिन ऐसा क्यों है?

1560
01:17:41,360 --> 01:17:44,100
खैर, विचार क्या हो गया है
यह सब समय चल रहा है।

1561
01:17:44,100 --> 01:17:47,990
>> और एक अलग रूप में इससे पहले कि मैं भूल जाते हैं, पता ही के रूप में
भी, कि आदमी पृष्ठों के अलावा

1562
01:17:47,990 --> 01:17:50,920
कि एक विशिष्ट के साथ आए
CS50 आईडीई तरह लिनक्स प्रणाली,

1563
01:17:50,920 --> 01:17:53,770
हम महसूस करते हैं कि,
पाठ्यक्रम के कर्मचारियों को भी है

1564
01:17:53,770 --> 01:17:56,030
एक वेबसाइट के संस्करण बनाया
इस एक ही विचार कहा जाता है

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net है, जो
वे एक ही आदमी पृष्ठों के सभी,

1566
01:17:59,940 --> 01:18:02,020
कि उसी के सभी
प्रलेखन, साथ ही

1567
01:18:02,020 --> 01:18:05,730
शीर्ष अनुमति देता है कि एक छोटे से बॉक्स
आप काफी के सभी परिवर्तित करने के लिए

1568
01:18:05,730 --> 01:18:09,025
कम आराम में रहस्यमय भाषा
विधा है, जहां हम, शिक्षण स्टाफ,

1569
01:18:09,025 --> 01:18:12,150
के माध्यम से चला गया है और सरल बनाने की कोशिश की है
चीजें रखने के लिए भाषा के कुछ

1570
01:18:12,150 --> 01:18:14,830
विचारों पर ध्यान केंद्रित नहीं, और
तकनीकी हैं।

1571
01:18:14,830 --> 01:18:20,070
तो मन में रखने के लिए, reference.cs50.net
एक और संसाधन के रूप में रूप में अच्छी तरह।

1572
01:18:20,070 --> 01:18:23,800
>> लेकिन क्यों में स्ट्रिंग की लंबाई काम करता है
जिस तरह से मैं पहले एक पल के प्रस्तावित?

1573
01:18:23,800 --> 01:18:25,160
यहाँ Zamyla का नाम फिर से है।

1574
01:18:25,160 --> 01:18:27,690
और यहाँ Zamyla का नाम है
, में बॉक्सिंग के रूप में मैं कर रखना,

1575
01:18:27,690 --> 01:18:31,360
यह जा रहा है की एक तस्वीर पेंट करने,
वास्तव में, बस पात्रों का एक दृश्य।

1576
01:18:31,360 --> 01:18:34,260
लेकिन Zamyla मौजूद नहीं है
एक कार्यक्रम में अलगाव में।

1577
01:18:34,260 --> 01:18:37,420
>> जब आप लिखते हैं और एक कार्यक्रम चलाने के लिए,
आप अपने मैक या अपने पीसी का उपयोग कर रहे

1578
01:18:37,420 --> 01:18:40,010
स्मृति, या राम के रूप में तो बात है।

1579
01:18:40,010 --> 01:18:42,620
और अगर आप सोच सकते हैं
होने के रूप में आपके कंप्यूटर

1580
01:18:42,620 --> 01:18:44,730
स्मृति के गीगाबाइट इन दिनों बहुत सारी।

1581
01:18:44,730 --> 01:18:47,700
और एक टमटम अरबों का मतलब है,
इसलिए बाइट्स के अरबों।

1582
01:18:47,700 --> 01:18:48,910
>> लेकिन कुछ ही समय में उल्टा करते हैं।

1583
01:18:48,910 --> 01:18:51,530
और कहा कि हम प्रयोग कर रहे हैं लगता है
एक बहुत पुराने कंप्यूटर कि

1584
01:18:51,530 --> 01:18:55,150
केवल स्मृति के 32 बाइट्स है।

1585
01:18:55,150 --> 01:18:59,310
मैं कर सकता, अपने कंप्यूटर स्क्रीन पर,
बस इस आकर्षित इस प्रकार है।

1586
01:18:59,310 --> 01:19:05,240
>> मैं बस कह सकते हैं कि मेरे
कंप्यूटर इस स्मृति की गई है।

1587
01:19:05,240 --> 01:19:08,830
और इस स्मृति की एक छड़ी की तरह है, अगर
आप पिछली बार से हमारी तस्वीर याद करते हैं।

1588
01:19:08,830 --> 01:19:11,670
और अगर मैं सिर्फ विभाजित
पर्याप्त समय में इस,

1589
01:19:11,670 --> 01:19:15,040
मैं दावा मैं 32 बाइट्स है
स्क्रीन पर स्मृति की।

1590
01:19:15,040 --> 01:19:18,239
>> केवल अब, वास्तव में, मैं कर सकता हूँ
यहाँ इस स्क्रीन पर अब तक खींचना।

1591
01:19:18,239 --> 01:19:20,280
इसलिए मुझे लगता है, आगे जाने के लिए जा रहा हूँ
और सिर्फ परंपरा से,

1592
01:19:20,280 --> 01:19:24,050
एक के रूप में अपने कंप्यूटर की स्मृति आकर्षित
ग्रिड, नहीं बस के रूप में एक सीधी रेखा।

1593
01:19:24,050 --> 01:19:28,190
विशेष रूप से, मैं अब कि दावा
इस ग्रिड, यह 8 से 4 ग्रिड,

1594
01:19:28,190 --> 01:19:31,800
बस सभी 32 बाइट्स का प्रतिनिधित्व करता है
अपने मैक में उपलब्ध स्मृति की,

1595
01:19:31,800 --> 01:19:33,030
या अपने पीसी में उपलब्ध है।

1596
01:19:33,030 --> 01:19:34,780
और वे लपेटकर रहे हैं
पर दो लाइनों, बस

1597
01:19:34,780 --> 01:19:38,030
क्योंकि यह स्क्रीन पर अधिक फिट बैठता है।

1598
01:19:38,030 --> 01:19:40,800
लेकिन यह पहली बाइट है।

1599
01:19:40,800 --> 01:19:41,990
यह दूसरी बाइट है।

1600
01:19:41,990 --> 01:19:43,300
यह तीसरा बाइट है।

1601
01:19:43,300 --> 01:19:45,310
>> और यह 32 वें बाइट है।

1602
01:19:45,310 --> 01:19:52,910
या, हम एक कंप्यूटर की तरह लगता है कि अगर
वैज्ञानिक इस बाइट 0, 1, 2, 3, 31 है।

1603
01:19:52,910 --> 01:19:55,950
तो आप 31 करने के लिए 0 है, अगर
आप 0 पर गिनती शुरू।

1604
01:19:55,950 --> 01:19:59,830
>> तो अगर हम एक प्रोग्राम का उपयोग
कि कॉल स्ट्रिंग मिलता है,

1605
01:19:59,830 --> 01:20:05,280
और हम मानव से एक तार मिल
जैसे मैं Zamyla कहा जाता था, जेड-ए-एम-वाई-एल ए,

1606
01:20:05,280 --> 01:20:09,430
कैसे दुनिया में करता है
कंप्यूटर रखने ट्रैक जो बाइट की,

1607
01:20:09,430 --> 01:20:12,230
जो स्मृति का हिस्सा है,
जो स्ट्रिंग के अंतर्गत आता है?

1608
01:20:12,230 --> 01:20:16,270
दूसरे शब्दों में, अगर हम के लिए आगे बढ़ना
कंप्यूटर में एक और नाम टाइप करें,

1609
01:20:16,270 --> 01:20:19,890
इस Andi की तरह, बुला
स्ट्रिंग एक दूसरी बार मिलता है,

1610
01:20:19,890 --> 01:20:23,030
एक-एन-डी-मैं में खत्म करने के लिए है
कंप्यूटर की स्मृति के रूप में अच्छी तरह से।

1611
01:20:23,030 --> 01:20:23,850
पर कैसे?

1612
01:20:23,850 --> 01:20:29,700
>> खैर, यह पता चला है कि नीचे
डाकू, क्या सेल्सियस जब तार के संचय करता है

1613
01:20:29,700 --> 01:20:35,080
कि मानव प्रकार में, या कि
किसी अन्य स्रोत से आते हैं, यह है

1614
01:20:35,080 --> 01:20:39,190
साथ उनमें से अंत रूपरेखा बनाती है
एक विशेष character-- बैकस्लैश

1615
01:20:39,190 --> 01:20:44,750
0 है, जो सिर्फ एक विशेष तरीका है
की एक पंक्ति में 80 बिट्स कह रही है।

1616
01:20:44,750 --> 01:20:47,950
>> तो एक-- यह संख्या 97 याद करते है।

1617
01:20:47,950 --> 01:20:51,770
तो 8 बिट के कुछ पैटर्न
दशमलव संख्या 97 का प्रतिनिधित्व करता है।

1618
01:20:51,770 --> 01:20:58,070
इस बैकस्लैश 0 सचमुच संख्या है
0, उर्फ ​​नुल, एन-यू-एल, पहले के विपरीत,

1619
01:20:58,070 --> 01:20:59,630
एन-यू-एल-एल, जो हम के बारे में बात की थी।

1620
01:20:59,630 --> 01:21:05,700
लेकिन अब के लिए, बस यह है कि पता है
बैकस्लैश 0 एक पंक्ति में सिर्फ 80 बिट्स है।

1621
01:21:05,700 --> 01:21:09,810
>> और यह सिर्फ इस रेखा है
रेत कि बाईं ओर कुछ भी कहते हैं

1622
01:21:09,810 --> 01:21:12,610
एक स्ट्रिंग, या एक डेटा प्रकार के अंतर्गत आता है।

1623
01:21:12,610 --> 01:21:15,480
और सही करने के लिए कुछ भी
कुछ और करने के अंतर्गत आता है।

1624
01:21:15,480 --> 01:21:17,440
Andi का नाम, इस बीच,
जो सिर्फ नेत्रहीन

1625
01:21:17,440 --> 01:21:21,310
दूसरी लाइन के लिए पर लपेटने के लिए होता है,
लेकिन यह सिर्फ एक सौंदर्य विस्तार है,

1626
01:21:21,310 --> 01:21:23,990
इसी तरह नुल समाप्त होता है।

1627
01:21:23,990 --> 01:21:29,290
>> यह एक ए एन डी-मैं पात्रों में से एक स्ट्रिंग है,
प्लस एक पांचवें गुप्त चरित्र,

1628
01:21:29,290 --> 01:21:33,560
सभी 0 बिट्स, कि बस demarcates
एंडी के नाम के अंत के रूप में अच्छी तरह से।

1629
01:21:33,560 --> 01:21:37,120
और स्ट्रिंग एक तिहाई समय मिलता है, तो हम कहते हैं
कंप्यूटर में तरह एक स्ट्रिंग पाने के लिए

1630
01:21:37,120 --> 01:21:44,210
मारिया, एम-ए-R-मैं-ए, इसी तरह मारिया है
नाम नुल बैकस्लैश 0 के साथ समाप्त हुई।

1631
01:21:44,210 --> 01:21:47,170
>> यह मौलिक रूप से अलग है
से कैसे एक कंप्यूटर आम तौर पर होता है

1632
01:21:47,170 --> 01:21:51,850
एक पूर्णांक है, या एक नाव, या अन्य दुकान
अभी भी डेटा प्रकार, क्योंकि याद है,

1633
01:21:51,850 --> 01:21:57,420
एक पूर्णांक आमतौर पर 32 बिट है, या
4 बाइट्स, या शायद यह भी 64 बिट्स,

1634
01:21:57,420 --> 01:21:59,100
या आठ बाइट्स।

1635
01:21:59,100 --> 01:22:02,620
लेकिन एक कंप्यूटर में कई पुरातन
एक प्रोग्रामिंग भाषा में

1636
01:22:02,620 --> 01:22:05,550
की एक निश्चित संख्या है
hood-- नीचे बाइट्स

1637
01:22:05,550 --> 01:22:08,100
हो सकता है 1, शायद 2, शायद 4, शायद 8।

1638
01:22:08,100 --> 01:22:13,250
>> लेकिन तार, डिजाइन से, एक है
पात्रों के गतिशील संख्या।

1639
01:22:13,250 --> 01:22:16,980
आप पहले से पता नहीं है, जब तक
जेड-ए-एम-वाई-एल ए में मानव प्रकार,

1640
01:22:16,980 --> 01:22:21,400
या एम-ए-R-मैं-ए, या ए एन डी-मैं। आप नहीं जानते
कितनी बार उपयोगकर्ता मारा जा रहा है

1641
01:22:21,400 --> 01:22:22,070
कुंजीपटल।

1642
01:22:22,070 --> 01:22:26,490
इसलिए, आप नहीं जानते कि कैसे
अग्रिम में कई पात्रों

1643
01:22:26,490 --> 01:22:27,540
आप की जरूरत करने जा रहे हैं।

1644
01:22:27,540 --> 01:22:31,840
>> और तो सी बस की तरह एक तरह छोड़ देता है
हुड के नीचे गुप्त ब्रेडक्रम्ब

1645
01:22:31,840 --> 01:22:32,960
स्ट्रिंग के अंत में।

1646
01:22:32,960 --> 01:22:39,280
स्मृति में जेड-ए-एम-वाई-एल ए के भंडारण के बाद,
यह भी सिर्फ बराबर डालता है

1647
01:22:39,280 --> 01:22:40,210
अवधि की।

1648
01:22:40,210 --> 01:22:45,060
एक वाक्य के अंत में,
यह 80 बिट्स कहते हैं, के रूप में तो

1649
01:22:45,060 --> 01:22:49,120
याद करने के लिए जहां
Zamyla शुरू होता है और समाप्त होता है।

1650
01:22:49,120 --> 01:22:51,490
>> तो क्या संबंध है,
तो, इस कार्यक्रम के लिए?

1651
01:22:51,490 --> 01:22:55,190
यहाँ इस कार्यक्रम, स्टर्लिंग,
बस एक तंत्र है

1652
01:22:55,190 --> 01:22:57,970
एक स्ट्रिंग प्राप्त करने के लिए
उपयोगकर्ता से, लाइन 6।

1653
01:22:57,970 --> 01:23:01,160
लाइन 7, मैं एक चर घोषित
n कहा जाता है और यह 0 के बराबर सेट।

1654
01:23:01,160 --> 01:23:08,680
>> और फिर लाइन 8 में, मैं बस से पूछा
सवाल है, जबकि n वें चरित्र करता है

1655
01:23:08,680 --> 01:23:12,120
बराबर नहीं सभी 0 bits--
दूसरे शब्दों में, नहीं करता है

1656
01:23:12,120 --> 01:23:14,500
बराबर इस विशेष
चरित्र, बैकस्लैश 0, जो

1657
01:23:14,500 --> 01:23:18,470
सिर्फ इतना है कि विशेष नुल character-- था
आगे जाना है और सिर्फ n वेतन वृद्धि।

1658
01:23:18,470 --> 01:23:21,460
>> और यह कर रखने के लिए, और रखना
यह कर रहा है, और यह कर रखना।

1659
01:23:21,460 --> 01:23:23,430
और इसलिए भी में यद्यपि
अतीत हम मैं का उपयोग किया है,

1660
01:23:23,430 --> 01:23:25,181
यह पूरी तरह से ठीक है
शब्दार्थ n का उपयोग करने के लिए,

1661
01:23:25,181 --> 01:23:27,430
तुम बस करने के लिए कोशिश कर रहे हैं
जान-बूझकर इस बार गिनती,

1662
01:23:27,430 --> 01:23:28,720
और सिर्फ यह n फोन करना चाहते हैं।

1663
01:23:28,720 --> 01:23:34,720
तो यह सिर्फ सवाल पूछ रहती है,
के सभी 0s n वें चरित्र है?

1664
01:23:34,720 --> 01:23:38,470
यदि नहीं, तो अगले देखने के लिए लग रही है,
अगले करने के लिए आगे देखें लग रही है,

1665
01:23:38,470 --> 01:23:39,460
अगले करने के लिए लग रही है।

1666
01:23:39,460 --> 01:23:45,540
>> लेकिन जैसे ही आप बैकस्लैश 0 देखने के रूप में,
11-- के माध्यम से इस loop-- लाइन 9 बंद हो जाता है।

1667
01:23:45,540 --> 01:23:49,640
आप जबकि पाश से बाहर तोड़ने,
उस चर n के अंदर छोड़ने

1668
01:23:49,640 --> 01:23:54,530
सभी का एक कुल गिनती
स्ट्रिंग तुम्हें देखा में वर्ण,

1669
01:23:54,530 --> 01:23:55,660
जिससे यह बाहर मुद्रण।

1670
01:23:55,660 --> 01:23:56,760
तो चलो इस कोशिश करते हैं।

1671
01:23:56,760 --> 01:23:59,500
>> मुझे आगे चलते हैं और बिना,
स्टर्लिंग समारोह का उपयोग कर,

1672
01:23:59,500 --> 01:24:04,240
लेकिन सिर्फ अपने खुद के देसी संस्करण का उपयोग
यहाँ स्टर्लिंग कहा जाता है, मुझे आगे चलते हैं

1673
01:24:04,240 --> 01:24:07,700
और रन स्टर्लिंग, कुछ में टाइप
Zamyla, जो मुझे पहले से पता है की तरह

1674
01:24:07,700 --> 01:24:08,670
छह वर्ण है।

1675
01:24:08,670 --> 01:24:10,080
चलो देखते हैं अगर यह काम करता है।

1676
01:24:10,080 --> 01:24:10,920
वास्तव में, यह छह है।

1677
01:24:10,920 --> 01:24:15,257
रोब के साथ की कोशिश करते हैं, तीन अक्षर,
तीन पात्रों के रूप में अच्छी तरह से, और बहुत आगे है।

1678
01:24:15,257 --> 01:24:17,340
इसलिए है कि यह सब हो रहा है
हुड के नीचे।

1679
01:24:17,340 --> 01:24:19,548
और कनेक्शन नोटिस,
तो, पहले सप्ताह के साथ

1680
01:24:19,548 --> 01:24:22,370
वर्ग की है, जहां हम के बारे में बात
अमूर्त तरह कुछ है,

1681
01:24:22,370 --> 01:24:26,960
जो सिर्फ विचारों के इस लेयरिंग है, या
जटिलता, बुनियादी सिद्धांतों के शीर्ष पर।

1682
01:24:26,960 --> 01:24:30,710
यहाँ, हम एक तरह से देख रहे हैं
स्टर्लिंग के हुड के नीचे,

1683
01:24:30,710 --> 01:24:33,510
तो बात है, यह पता लगाने के लिए,
यह कैसे लागू किया जाएगा?

1684
01:24:33,510 --> 01:24:35,232
>> और हम इसे अपने आप को फिर से लागू कर सकता है।

1685
01:24:35,232 --> 01:24:37,440
लेकिन हम फिर कभी नहीं जा रहे हैं
को फिर से लागू स्टर्लिंग।

1686
01:24:37,440 --> 01:24:39,780
हम सिर्फ करने के लिए जा रहे हैं
आदेश में स्टर्लिंग का उपयोग

1687
01:24:39,780 --> 01:24:42,100
वास्तव में कुछ तार की लंबाई पाने के लिए।

1688
01:24:42,100 --> 01:24:44,200
>> लेकिन वहाँ कोई जादू है
हुड के नीचे।

1689
01:24:44,200 --> 01:24:46,716
यदि आप जानते हैं कि नीचे
डाकू, एक स्ट्रिंग

1690
01:24:46,716 --> 01:24:48,090
सिर्फ पात्रों में से एक दृश्य है।

1691
01:24:48,090 --> 01:24:51,090
और वर्ण के अनुक्रम कि
सभी संख्यानुसार संबोधित किया जा सकता

1692
01:24:51,090 --> 01:24:53,330
ब्रैकेट 0, वर्ग के साथ
1, वर्ग 2, और आप

1693
01:24:53,330 --> 01:24:57,420
जानते हैं कि एक स्ट्रिंग के अंत में एक है
विशेष चरित्र है, आप समझ सकते हैं

1694
01:24:57,420 --> 01:25:01,710
कैसे एक में सबसे अधिक कुछ भी करने को
कार्यक्रम है, क्योंकि यह करने के लिए नीचे फोड़े

1695
01:25:01,710 --> 01:25:03,400
पढ़ने और स्मृति लिख रही है।

1696
01:25:03,400 --> 01:25:06,130
यही कारण है, बदल रहा है और तलाश
स्मृति में, या बातें चलती

1697
01:25:06,130 --> 01:25:10,940
स्मृति में चारों ओर, मुद्रण बातों
स्क्रीन, और बहुत आगे है।

1698
01:25:10,940 --> 01:25:14,800
>> तो चलो अब इस नयी उपयोग करें
क्या वास्तव में तारों की समझ

1699
01:25:14,800 --> 01:25:17,910
हुड के नीचे हैं, और
वापस छील एक अन्य परत

1700
01:25:17,910 --> 01:25:20,080
कि अब तक हम है
पूरी तरह अनदेखी की गई।

1701
01:25:20,080 --> 01:25:22,650
विशेष रूप से, किसी भी समय में
हम एक कार्यक्रम लागू किया गया है,

1702
01:25:22,650 --> 01:25:25,930
हम कोड की इस पंक्ति को मिला है
शीर्ष के निकट मुख्य घोषणा।

1703
01:25:25,930 --> 01:25:27,810
और हम int मुख्य शून्य निर्दिष्ट किया है।

1704
01:25:27,810 --> 01:25:31,240
>> और कोष्ठक के अंदर उस शून्य
यह सब समय कह दिया गया है कि मुख्य

1705
01:25:31,240 --> 01:25:33,440
खुद को किसी भी तर्क नहीं ले करता है।

1706
01:25:33,440 --> 01:25:36,210
कोई इनपुट मुख्य है कि
उपयोगकर्ता से मिल जा

1707
01:25:36,210 --> 01:25:39,020
कुछ अन्य से आ गया है
तंत्र, पाने पूर्णांक,

1708
01:25:39,020 --> 01:25:42,040
या नाव हो, या स्ट्रिंग मिलता है,
या कुछ अन्य कार्य करते हैं।

1709
01:25:42,040 --> 01:25:44,710
लेकिन यह पता चला है कि
जब आप एक प्रोग्राम लिखने,

1710
01:25:44,710 --> 01:25:47,690
आप वास्तव में निर्दिष्ट कर सकते हैं
कि इस कार्यक्रम करेगा

1711
01:25:47,690 --> 01:25:51,730
मानव से जानकारी लेने के लिए
कमांड लाइन पर ही।

1712
01:25:51,730 --> 01:25:56,310
>> दूसरे शब्दों में, भले ही हम इस प्रकार अब तक
सिर्फ ./hello चल रहा है हैलो

1713
01:25:56,310 --> 01:26:00,312
या इसी तरह के कार्यक्रमों के सभी
अन्य कार्यक्रमों है कि हम प्रयोग किया गया है,

1714
01:26:00,312 --> 01:26:02,770
कि हम खुद नहीं लिखा था,
राशि ले गया, ऐसा लगता है,

1715
01:26:02,770 --> 01:26:05,210
कमांड लाइन arguments--
मेकअप की तरह बातें।

1716
01:26:05,210 --> 01:26:07,450
आप मेकअप की तरह कुछ कहते हैं,
और फिर एक दूसरा शब्द।

1717
01:26:07,450 --> 01:26:10,950
या बजना, आप बजना कहते हैं, और उसके बाद
एक दूसरा शब्द, एक फ़ाइल का नाम है।

1718
01:26:10,950 --> 01:26:14,410
>> या यहां तक ​​कि आर एम या सी.पी., के रूप में आप कर सकते हैं
देखा या पहले से ही इस्तेमाल किया है

1719
01:26:14,410 --> 01:26:15,880
हटाने या फाइल कॉपी करने के लिए।

1720
01:26:15,880 --> 01:26:18,920
उन सब के सब तथाकथित लेने के लिए
कमांड लाइन arguments--

1721
01:26:18,920 --> 01:26:21,130
टर्मिनल प्रॉम्प्ट पर अतिरिक्त शब्द।

1722
01:26:21,130 --> 01:26:23,260
लेकिन अब तक, हम
अपने आप को नहीं मिला है

1723
01:26:23,260 --> 01:26:27,080
से इनपुट लेने के इस विलासिता
उपयोगकर्ता जब वह या वह वास्तव में चलाता है

1724
01:26:27,080 --> 01:26:29,120
कार्यक्रम में ही कमांड लाइन पर।

1725
01:26:29,120 --> 01:26:33,710
>> लेकिन हम उस से फिर से घोषित कर सकते हैं
मुख्य आगे नहीं बढ़ रहा है, होने के रूप में

1726
01:26:33,710 --> 01:26:36,750
कोष्ठकों में शून्य,
लेकिन इन दोनों के तर्क

1727
01:26:36,750 --> 01:26:40,600
पहले एक पूर्णांक instead--,
और दूसरा कुछ

1728
01:26:40,600 --> 01:26:44,170
नया, कुछ है कि हम फोन करने के लिए जा रहे हैं
एक सरणी, आत्मा में कुछ इसी तरह

1729
01:26:44,170 --> 01:26:49,220
क्या हम एक सूची के रूप में खरोंच में देखा है, लेकिन
तारों की एक सरणी, हम जल्द ही देखेंगे के रूप में।

1730
01:26:49,220 --> 01:26:51,790
लेकिन चलो द्वारा यह देखने
उदाहरण के लिए, हम पहले

1731
01:26:51,790 --> 01:26:53,690
भेद है कि वास्तव में क्या मतलब है।

1732
01:26:53,690 --> 01:26:56,520
>> तो अगर मैं CS50 आईडीई में जाना
यहाँ, मैं आगे चला गया है

1733
01:26:56,520 --> 01:27:01,840
और नामक एक फाइल में घोषित
निम्नलिखित टेम्पलेट argv0.c।

1734
01:27:01,840 --> 01:27:04,120
और केवल एक चीज को नोटिस
कि अब तक अलग है

1735
01:27:04,120 --> 01:27:08,570
है कि मैं int करने के लिए शून्य बदल दिया है
argc स्ट्रिंग खुला ब्रैकेट argv, बंद

1736
01:27:08,570 --> 01:27:09,070
ब्रैकेट।

1737
01:27:09,070 --> 01:27:11,730
और अब के लिए नोटिस, वहाँ है
उन कोष्ठक के अंदर कुछ भी नहीं है।

1738
01:27:11,730 --> 01:27:12,620
>> वहाँ कोई संख्या है।

1739
01:27:12,620 --> 01:27:15,070
और कोई रहा है, या
n, या किसी अन्य पत्र।

1740
01:27:15,070 --> 01:27:17,010
मैं सिर्फ का उपयोग कर रहा हूँ
अब के लिए वर्ग कोष्ठक,

1741
01:27:17,010 --> 01:27:19,510
कारणों से हम आऊँगा
वापस बस एक पल में करने के लिए।

1742
01:27:19,510 --> 01:27:21,330
>> और अब मैं क्या करने जा रहा हूँ यह है।

1743
01:27:21,330 --> 01:27:26,680
argc के बराबर होती है तो बराबर 2--
और याद है कि बराबरी के बराबर होती है

1744
01:27:26,680 --> 01:27:30,040
समानता ऑपरेटर की तुलना
बाएँ और समानता के लिए सही है।

1745
01:27:30,040 --> 01:27:31,790
यह काम नहीं है
ऑपरेटर है, जो

1746
01:27:31,790 --> 01:27:36,510
एकल बराबर संकेत है, जो प्रतिलिपि का मतलब
सही से कुछ मूल्य के लिए छोड़ दिया।

1747
01:27:36,510 --> 01:27:42,840
>> argc बराबरी 2 के बराबर होती है, तो मैं चाहता हूँ
कहते हैं, printf, नमस्ते, percents, नई लाइन,

1748
01:27:42,840 --> 01:27:47,340
और फिर in-- प्लग और यहाँ नया है
trick-- argv ब्रैकेट 1, कारणों के लिए

1749
01:27:47,340 --> 01:27:48,840
कि हम एक पल में वापस करने के लिए आ जाएगा।

1750
01:27:48,840 --> 01:27:52,110
वरना यदि argc नहीं करता
बराबर 2, तुम्हें पता है क्या?

1751
01:27:52,110 --> 01:27:57,400
चलो बस आगे चलते हैं और हमेशा की तरह, प्रिंट के रूप में,
बाहर हैलो कोई प्रतिस्थापन के साथ दुनिया।

1752
01:27:57,400 --> 01:28:02,710
>> तो यह प्रतीत होता है कि अगर argc, जो
तर्क गिनती के लिए खड़ा है, 2 के बराबर होती है,

1753
01:28:02,710 --> 01:28:04,740
मैं बाहर मुद्रित करने के लिए जा रहा हूँ
हैलो कुछ न कुछ।

1754
01:28:04,740 --> 01:28:07,560
अन्यथा, डिफ़ॉल्ट रूप से, मैं हूँ
हैलो मुद्रित करने के लिए दुनिया जा रही है।

1755
01:28:07,560 --> 01:28:08,770
अच्छा तो इसका क्या मतलब है?

1756
01:28:08,770 --> 01:28:15,550
>> खैर, मुझे आगे जाना है और बचाने के लिए करते हैं
इस फ़ाइल, और फिर argv0 करते हैं,

1757
01:28:15,550 --> 01:28:18,940
और फिर ./argv0 दर्ज करें।

1758
01:28:18,940 --> 01:28:20,300
और यह दुनिया नमस्ते कहते हैं।

1759
01:28:20,300 --> 01:28:21,260
अब, ऐसा क्यों है?

1760
01:28:21,260 --> 01:28:24,730
>> खैर, यह कभी भी निकलता है कि आप
कमांड लाइन पर एक कार्यक्रम चलाने के लिए,

1761
01:28:24,730 --> 01:28:29,570
आप में भर रहे हैं कि हम क्या करेंगे
आम तौर पर एक बहस वेक्टर कहते हैं।

1762
01:28:29,570 --> 01:28:33,100
दूसरे शब्दों में, अपने आप में
कंप्यूटर, ऑपरेटिंग सिस्टम,

1763
01:28:33,100 --> 01:28:38,340
अपने कार्यक्रम के लिए हाथ करने के लिए जा रहा है
खुद को शब्दों के सभी की एक सूची

1764
01:28:38,340 --> 01:28:40,850
मानव में टाइप किया है कि
शीघ्र, मामले में तुम

1765
01:28:40,850 --> 01:28:43,790
प्रोग्रामर क्या करना चाहते हैं
कि जानकारी के साथ कुछ और।

1766
01:28:43,790 --> 01:28:48,540
और इस मामले में, केवल शब्द
मैं प्रॉम्प्ट पर टाइप किया है ./argv0 है।

1767
01:28:48,540 --> 01:28:55,420
>> और इसलिए तर्क की संख्या है कि
अपने कार्यक्रम के लिए पारित किया जा रहा से एक है।

1768
01:28:55,420 --> 01:28:58,880
दूसरे शब्दों में, तर्क
गिनती, अन्यथा argc के रूप में जाना

1769
01:28:58,880 --> 01:29:00,970
यहाँ एक पूर्णांक के रूप में, बस एक है।

1770
01:29:00,970 --> 01:29:03,000
एक, ज़ाहिर है, बराबर दो नहीं करता है।

1771
01:29:03,000 --> 01:29:05,980
और तो यह है कि क्या प्रिंट, नमस्ते दुनिया है।

1772
01:29:05,980 --> 01:29:08,170
>> लेकिन मुझे यह कहीं ले चलो।

1773
01:29:08,170 --> 01:29:09,930
मुझे कहना है, argv0।

1774
01:29:09,930 --> 01:29:12,740
और फिर कैसे मारिया के बारे में?

1775
01:29:12,740 --> 01:29:14,990
और फिर हिट दर्ज करें।

1776
01:29:14,990 --> 01:29:18,020
>> और नोटिस क्या जादुई यहाँ होता है।

1777
01:29:18,020 --> 01:29:22,640
अब, के बजाय हैलो दुनिया की, मेरे पास है
इस कार्यक्रम का व्यवहार बदल गया

1778
01:29:22,640 --> 01:29:26,310
इनपुट मिल से नहीं लेने के द्वारा
स्ट्रिंग या कुछ अन्य समारोह,

1779
01:29:26,310 --> 01:29:30,570
लेकिन, जाहिर है, मेरे लिए आदेश
ही है, क्या मैं मूल रूप में टाइप।

1780
01:29:30,570 --> 01:29:35,720
और मैं फिर से इस खेल खेल सकते हैं
यह Stelios को बदल रहा है, उदाहरण के लिए।

1781
01:29:35,720 --> 01:29:38,400
>> और अब मैं एक और नाम अभी भी देखते हैं।

1782
01:29:38,400 --> 01:29:40,540
और यहाँ, मैं Andi कह सकते हैं।

1783
01:29:40,540 --> 01:29:42,137
और मैं Zamyla कह सकते हैं।

1784
01:29:42,137 --> 01:29:45,220
और हम इस खेल को दिन भर खेल सकते हैं,
सिर्फ अलग मूल्यों में plugging,

1785
01:29:45,220 --> 01:29:49,550
इतने लंबे समय मैं वास्तव में प्रदान के रूप में
प्रॉम्प्ट पर दो शब्द,

1786
01:29:49,550 --> 01:29:52,260
ऐसी है कि argc, मेरे तर्क गिनती, 2 है।

1787
01:29:52,260 --> 01:29:57,240
>> मैं देख रहा है कि नाम में खामियों को दूर
printf, इस हालत यहां प्रति?

1788
01:29:57,240 --> 01:30:00,550
तो क्या अब हम करने लगते हैं
अर्थपूर्ण क्षमता

1789
01:30:00,550 --> 01:30:04,410
एक और तंत्र से इनपुट लेने की,
तथाकथित कमांड लाइन से,

1790
01:30:04,410 --> 01:30:07,000
बल्कि इंतजार करने के लिए होने से
जब तक उपयोगकर्ता कार्यक्रम चलाता है,

1791
01:30:07,000 --> 01:30:10,220
और फिर उसे या उसके संकेत
मिल स्ट्रिंग की तरह कुछ का उपयोग कर।

1792
01:30:10,220 --> 01:30:11,230
>> तो यह क्या है?

1793
01:30:11,230 --> 01:30:15,010
Argc, फिर से, बस एक पूर्णांक है,
words-- arguments-- की संख्या

1794
01:30:15,010 --> 01:30:18,540
उस पर प्रदान की जाती उपयोगकर्ता
शीघ्र, टर्मिनल विंडो में,

1795
01:30:18,540 --> 01:30:20,110
कार्यक्रम का नाम भी शामिल है।

1796
01:30:20,110 --> 01:30:23,340
इसलिए हमारे ./argv0, प्रभावी ढंग से है,
कार्यक्रम का नाम,

1797
01:30:23,340 --> 01:30:24,520
या कैसे मैं इस कार्यक्रम चलाते हैं।

1798
01:30:24,520 --> 01:30:25,810
>> यही कारण है कि एक शब्द के रूप में गिना जाता है।

1799
01:30:25,810 --> 01:30:27,080
तो argc 1 होगा।

1800
01:30:27,080 --> 01:30:29,750
लेकिन जब मैं Stelios लिखते हैं, या
Andi, या Zamyla, या मारिया,

1801
01:30:29,750 --> 01:30:31,660
इसका मतलब है कि तर्क गिनती दो है।

1802
01:30:31,660 --> 01:30:33,910
और इसलिए अब वहाँ में पारित दो शब्द है।

1803
01:30:33,910 --> 01:30:36,070
>> और नोटिस, हम इस तर्क जारी रख सकते हैं।

1804
01:30:36,070 --> 01:30:39,050
अगर मैं वास्तव में कहना
Zamyla चान की तरह कुछ है,

1805
01:30:39,050 --> 01:30:42,200
एक पूरा नाम, जिससे गुजर
कुल में तीन तर्क,

1806
01:30:42,200 --> 01:30:47,410
अब यह डिफ़ॉल्ट फिर कहते हैं,
क्योंकि, बेशक, 3 बराबर नहीं 2 नहीं करता है।

1807
01:30:47,410 --> 01:30:54,080
>> और इसलिए इस तरह से, मैं क्या है
argv इस नए तर्क के माध्यम का उपयोग

1808
01:30:54,080 --> 01:30:56,080
कि हम तकनीकी रूप से कर सकता है
कुछ भी हम चाहते हैं कहते हैं।

1809
01:30:56,080 --> 01:30:58,940
लेकिन परंपरा से, यह है
argv और argc, क्रमशः।

1810
01:30:58,940 --> 01:31:04,470
Argv, तर्क वेक्टर, प्रकार है
एक प्रोग्रामिंग के लिए एक पर्याय के

1811
01:31:04,470 --> 01:31:07,140
सी में एक सरणी सुविधा का आह्वान किया।

1812
01:31:07,140 --> 01:31:14,410
>> एक सरणी समान मूल्यों की एक सूची है
वापस, वापस करने के लिए वापस करने के लिए वापस करने के लिए।

1813
01:31:14,410 --> 01:31:17,810
दूसरे शब्दों में, अगर एक सही यहाँ है
राम, अगले एक ठीक उसके बगल में है,

1814
01:31:17,810 --> 01:31:18,800
और ठीक उसके बगल में।

1815
01:31:18,800 --> 01:31:20,101
वे सब जगह नहीं हो।

1816
01:31:20,101 --> 01:31:23,100
और है कि बाद के परिदृश्य है, जहां चीजें
सभी स्मृति में जगह खत्म हो गई हैं,

1817
01:31:23,100 --> 01:31:25,082
वास्तव में एक शक्तिशाली सुविधा हो सकती है।

1818
01:31:25,082 --> 01:31:28,040
लेकिन हम जब हम उस पर वापस करने आया हूँ
शौक़ीन डेटा संरचनाओं के बारे में बात करते हैं।

1819
01:31:28,040 --> 01:31:32,260
अभी के लिए, एक सरणी सिर्फ एक है
सन्निहित स्मृति का हिस्सा है,

1820
01:31:32,260 --> 01:31:36,520
से प्रत्येक जिसका तत्व हैं
वापस, वापस करने के लिए वापस करने के लिए वापस करने के लिए,

1821
01:31:36,520 --> 01:31:38,050
और आम तौर पर एक ही प्रकार के।

1822
01:31:38,050 --> 01:31:42,630
>> तो आप के बारे में लगता है कि अगर एक से,
पल पहले, एक स्ट्रिंग क्या है?

1823
01:31:42,630 --> 01:31:50,460
खैर, एक स्ट्रिंग, Zamyla की तरह,
जेड-ए-एम-वाई-एल ए, तकनीकी रूप से, है,

1824
01:31:50,460 --> 01:31:51,400
सिर्फ एक सरणी।

1825
01:31:51,400 --> 01:31:53,700
यह पात्रों में से एक सरणी है।

1826
01:31:53,700 --> 01:31:59,250
>> और अगर ऐसा है हम वास्तव में इस खींचना, के रूप में मैं
, स्मृति का एक हिस्सा के रूप में, पहले किया था

1827
01:31:59,250 --> 01:32:04,510
ऐसा नहीं है कि इनमें से प्रत्येक पता चला है
अक्षर एक बाइट ले लेता है।

1828
01:32:04,510 --> 01:32:07,630
और फिर वहाँ है कि विशेष
प्रहरी चरित्र, बैकस्लैश 0,

1829
01:32:07,630 --> 01:32:12,360
या सभी आठ 0 बिट्स, कि
कि स्ट्रिंग के अंत demarcates।

1830
01:32:12,360 --> 01:32:15,090
तो एक स्ट्रिंग, यह बदल जाता है
बाहर, गंदें शब्द बोलना स्ट्रिंग बोली,

1831
01:32:15,090 --> 01:32:20,580
सिर्फ chara-- की एक सरणी है
चार एक वास्तविक डेटा प्रकार किया जा रहा है।

1832
01:32:20,580 --> 01:32:24,560
>> और अब argv, meanwhile--
की पीठ कार्यक्रम के लिए चलते हैं।

1833
01:32:24,560 --> 01:32:29,582
Argv, भले ही हम शब्द को देखने
स्ट्रिंग इधर, एक स्ट्रिंग में ही नहीं है।

1834
01:32:29,582 --> 01:32:33,640
Argv, तर्क वेक्टर,
तारों की एक सरणी है।

1835
01:32:33,640 --> 01:32:37,620
>> आप की एक सरणी हो सकता है तो बस के रूप में
वर्ण, आप उच्च स्तर हो सकता है,

1836
01:32:37,620 --> 01:32:46,279
strings-- की एक सरणी इसलिए, उदाहरण के लिए,
जब मैं पहले एक पल के द्वारा लिखे गए ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, अंतरिक्ष जेड-ए-एम-वाई-एल ए, मैं दावा किया है कि
argv, it-- ./argv0 में दो तार था

1838
01:33:00,150 --> 01:33:03,185
और जेड-ए-एम-वाई-एल ए। में
दूसरे शब्दों में, argc 2 था।

1839
01:33:03,185 --> 01:33:03,980
ऐसा क्यों है?

1840
01:33:03,980 --> 01:33:08,370
>> खैर, प्रभावी ढंग से, क्या हो रहा है
पर इन तारों की प्रत्येक कि

1841
01:33:08,370 --> 01:33:13,990
जाहिर है, पात्रों में से एक सरणी है
के रूप में पहले, जिसका के प्रत्येक अक्षर के

1842
01:33:13,990 --> 01:33:15,670
एक बाइट ले लेता है।

1843
01:33:15,670 --> 01:33:19,720
और वास्तविक 0 भ्रमित नहीं है
0 के साथ कार्यक्रम के नाम पर,

1844
01:33:19,720 --> 01:33:22,040
जो सभी 80 बिट्स का मतलब है।

1845
01:33:22,040 --> 01:33:27,140
और Zamyla, इस बीच, अब भी है
यह भी पात्रों में से एक सरणी।

1846
01:33:27,140 --> 01:33:31,450
>> दिन के अंत में इसलिए, यह वास्तव
हुड के नीचे इस तरह दिखता है।

1847
01:33:31,450 --> 01:33:38,800
लेकिन यह कैसे मुख्य argv, स्वभाव से
काम करता है, मुझे इस सब को लपेटने के लिए अनुमति देता है

1848
01:33:38,800 --> 01:33:44,810
अगर तुम जाएगा, एक बड़ा सरणी में अप
, कि अगर हम थोड़ा अधिक आसान बनाने में

1849
01:33:44,810 --> 01:33:48,180
तस्वीर की तरह नहीं है और ऐसा लग रहा है क्या
काफी वहाँ पैमाने पर करने के लिए आकर्षित,

1850
01:33:48,180 --> 01:33:56,720
इस सरणी, पहले ही आकार 2 की है
तत्व है जो की एक स्ट्रिंग है,

1851
01:33:56,720 --> 01:33:59,230
के दूसरे तत्व
जो एक स्ट्रिंग है।

1852
01:33:59,230 --> 01:34:01,687
और बदले में, तुम अगर
एक तरह से प्रत्येक पर ज़ूम

1853
01:34:01,687 --> 01:34:03,770
उन तार, की क्या आप
हुड के नीचे देख

1854
01:34:03,770 --> 01:34:07,190
कि प्रत्येक स्ट्रिंग सिर्फ है
पात्रों में से एक सरणी।

1855
01:34:07,190 --> 01:34:11,680
>> अब, बस तार के साथ के रूप में,
हम पहुँच प्राप्त करने में सक्षम थे

1856
01:34:11,680 --> 01:34:15,260
एक स्ट्रिंग में मैं वें चरित्र को
उस वर्ग ब्रैकेट संकेतन का उपयोग कर।

1857
01:34:15,260 --> 01:34:17,320
इसी तरह, सरणियों के साथ
सामान्य रूप में, हम कर सकते हैं

1858
01:34:17,320 --> 01:34:22,700
वर्ग कोष्ठक संकेतन का उपयोग पाने के लिए
एक सरणी में तार के किसी भी नंबर पर?

1859
01:34:22,700 --> 01:34:25,100
उदाहरण के लिए, मुझे जाने
आगे जाना है और यह करते हैं।

1860
01:34:25,100 --> 01:34:32,420
>> मुझे आगे जाना है और argv1.c पैदा करते हैं,
जो एक छोटे से अलग इस समय है।

1861
01:34:32,420 --> 01:34:35,635
इसके बजाय argc2 के लिए जाँच की,
मैं बजाय यह करने के लिए जा रहा हूँ।

1862
01:34:35,635 --> 01:34:41,270
int मैं 0 मिलता है, मैं कम है
argc से, मैं प्लस प्लस,

1863
01:34:41,270 --> 01:34:47,920
और फिर इस के अंदर बाहर प्रिंट,
प्रतिशत है, नई लाइन, और उसके बाद

1864
01:34:47,920 --> 01:34:50,740
argv ब्रैकेट रहा।

1865
01:34:50,740 --> 01:34:55,220
>> दूसरे शब्दों में, मैं के साथ काम नहीं कर रहा हूँ
समय पर अलग-अलग पात्रों।

1866
01:34:55,220 --> 01:35:00,190
Argv, के रूप में इन खाली वर्ग से गर्भित
नाम argv के अधिकार के लिए ब्रेसिज़,

1867
01:35:00,190 --> 01:35:03,320
argv तारों की एक सरणी है इसका मतलब है।

1868
01:35:03,320 --> 01:35:04,870
और argc सिर्फ एक int है।

1869
01:35:04,870 --> 01:35:08,800
>> यहाँ इस लाइन, 6, ​​है
सेट कह मैं 0 के बराबर है।

1870
01:35:08,800 --> 01:35:11,980
अप करने के लिए सभी तरह से गणना,
लेकिन argc सहित नहीं।

1871
01:35:11,980 --> 01:35:14,010
और फिर प्रत्येक यात्रा पर,
एक स्ट्रिंग बाहर प्रिंट।

1872
01:35:14,010 --> 01:35:14,800
क्या स्ट्रिंग?

1873
01:35:14,800 --> 01:35:17,270
>> argv में मैं वें स्ट्रिंग।

1874
01:35:17,270 --> 01:35:19,530
तो, जबकि इससे पहले कि मैं था
वर्ग कोष्ठक का उपयोग कर

1875
01:35:19,530 --> 01:35:22,180
संकेतन ith पर पाने के लिए
एक स्ट्रिंग में चरित्र, अब

1876
01:35:22,180 --> 01:35:27,240
मैं वर्ग कोष्ठक संकेतन का उपयोग कर रहा हूँ
एक सरणी में ith स्ट्रिंग पर पाने के लिए।

1877
01:35:27,240 --> 01:35:30,310
तो यह एक परत की तरह है
ऊपर, धारणात्मक।

1878
01:35:30,310 --> 01:35:35,390
>> और तो क्या इस बारे में साफ है
अब कार्यक्रम, अगर मैं argv1 संकलन,

1879
01:35:35,390 --> 01:35:42,067
और फिर ./argv1 करते हैं, और फिर टाइप करें
foo बार बाज की तरह कुछ में,

1880
01:35:42,067 --> 01:35:45,400
जो तीन डिफ़ॉल्ट शब्द है कि एक हैं
कंप्यूटर वैज्ञानिक किसी भी समय के लिए पहुंचता

1881
01:35:45,400 --> 01:35:51,010
वह या वह कुछ प्लेसहोल्डर शब्दों की जरूरत है,
और हिट दर्ज करें, उन शब्दों के प्रत्येक,

1882
01:35:51,010 --> 01:35:54,980
कार्यक्रम का नाम, सहित जो
पहले स्थान पर argv में है,

1883
01:35:54,980 --> 01:35:58,320
समाप्त होता है एक समय में एक मुद्रित किया जा रहा।

1884
01:35:58,320 --> 01:36:05,290
और अगर मैं इस बदलने के लिए, और मैं कहना है
argv1 Zamyla चान की तरह कुछ है,

1885
01:36:05,290 --> 01:36:08,800
हम उन सभी के तीन मिल
शब्द है, जो argv0 है,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, इस में क्योंकि
मामले argc, गिनती, 3 है।

1887
01:36:14,400 --> 01:36:20,020
>> लेकिन क्या साफ है अगर आप समझ है
कि argv, बस तारों की एक सरणी है

1888
01:36:20,020 --> 01:36:24,910
और आप एक स्ट्रिंग है कि समझ में
पात्रों में से एक सरणी है,

1889
01:36:24,910 --> 01:36:29,470
हम वास्तव में एक तरह से इस का उपयोग कर सकते हैं
वर्ग कोष्ठक संकेतन कई बार

1890
01:36:29,470 --> 01:36:33,320
एक स्ट्रिंग चुनने के लिए, और उसके बाद का चयन
स्ट्रिंग के भीतर एक चरित्र है,

1891
01:36:33,320 --> 01:36:35,730
इस प्रकार गहरी के रूप में डाइविंग।

1892
01:36:35,730 --> 01:36:40,100
इस उदाहरण में, मुझे जाने दो
आगे और इस argv2.c कहते हैं।

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
और इस उदाहरण में, मुझे आगे चलते हैं
और int मैं 0 मिल के लिए following-- करते हैं,

1895
01:36:50,180 --> 01:36:53,286
मैं argc की तुलना में कम है, मैं प्लस
साथ ही, पहले की तरह।

1896
01:36:53,286 --> 01:36:55,910
तो दूसरे words-- और अब इस में
काफी जटिल हो रही है।

1897
01:36:55,910 --> 01:36:59,940
तब मैं कहने जा रहा हूँ
argv में तार पर पुनरावृति,

1898
01:36:59,940 --> 01:37:01,294
अपने आप के लिए एक टिप्पणी के रूप में।

1899
01:37:01,294 --> 01:37:03,960
और फिर मैं एक के लिए जा रहा हूँ
पाश के लिए नेस्ट, तो आप शायद जो

1900
01:37:03,960 --> 01:37:06,290
किया है, या माना
जहां, कर खरोंच में,

1901
01:37:06,290 --> 01:37:08,600
मेरे कहने का int-- मैं जा रहा हूँ
मैं फिर से उपयोग करने के लिए नहीं जा रहे हैं,

1902
01:37:08,600 --> 01:37:12,590
क्योंकि मैं छाया के लिए नहीं करना चाहते हैं, या
एक तरह से मौजूदा मैं ऊपर लिख।

1903
01:37:12,590 --> 01:37:15,780
>> मैं करने के लिए, बजाय, जम्मू कहना जा रहा हूँ, क्योंकि
कि मैं के बाद चर करने के लिए मेरे जाने है,

1904
01:37:15,780 --> 01:37:18,590
जब मैं सिर्फ कोशिश कर रहा हूँ
साधारण संख्या गिनती।

1905
01:37:18,590 --> 01:37:28,850
जम्मू जाता है के लिए 0-- और भी, एन, जा रहा है
, Argv ब्रैकेट मैं की कड़ी लंबाई प्राप्त

1906
01:37:28,850 --> 01:37:36,030
इतने लंबे समय के रूप में जे एम की तुलना में कम है,
जम्मू प्लस प्लस, निम्न कार्य करें।

1907
01:37:36,030 --> 01:37:37,500
और यहाँ दिलचस्प हिस्सा है।

1908
01:37:37,500 --> 01:37:46,330
>> एक चरित्र और एक नई लाइन बाहर प्रिंट,
argv ब्रैकेट मैं, ब्रैकेट जम्मू में plugging।

1909
01:37:46,330 --> 01:37:47,940
ठीक है, तो मुझे यहाँ कुछ टिप्पणी जोड़ें।

1910
01:37:47,940 --> 01:37:54,820
पात्रों पर पुनरावृति
वर्तमान में स्ट्रिंग,

1911
01:37:54,820 --> 01:38:02,290
मैं वें स्ट्रिंग में प्रिंट जम्मू-वें चरित्र।

1912
01:38:02,290 --> 01:38:04,630
तो अब, चलो पर विचार करते हैं
इन टिप्पणियों क्या मतलब है।

1913
01:38:04,630 --> 01:38:06,750
>> तार पर पुनरावृति
argv-- में कितने

1914
01:38:06,750 --> 01:38:09,300
तार argv में हैं, जो एक सरणी है?

1915
01:38:09,300 --> 01:38:13,420
Argc कई है, तो मैं कर रहा हूँ पुनरावृति
मैं से बराबर 0 argc तक।

1916
01:38:13,420 --> 01:38:20,020
इस बीच, कितने अक्षर
argv में मैं वें स्ट्रिंग में हैं?

1917
01:38:20,020 --> 01:38:22,880
>> खैर, कि इस सवाल का जवाब पाने के लिए,
मैं सिर्फ स्ट्रिंग लंबाई फोन

1918
01:38:22,880 --> 01:38:26,810
वर्तमान स्ट्रिंग मैं देखभाल पर
के बारे में है, जो argv ब्रैकेट रहा है।

1919
01:38:26,810 --> 01:38:30,090
और मैं अस्थायी रूप से स्टोर करने के लिए जा रहा हूँ
मूल्य एन में, बस कैशिंग प्रयोजनों के लिए,

1920
01:38:30,090 --> 01:38:31,590
दक्षता के लिए यह याद रखना।

1921
01:38:31,590 --> 01:38:36,330
और फिर मैं 0 करने के लिए जम्मू से प्रारंभ जा रहा हूँ,
इतने लंबे समय के लिए जा जम्मू के रूप में एन कम है रखने के लिए,

1922
01:38:36,330 --> 01:38:38,430
और प्रत्येक यात्रा के वेतन वृद्धि जम्मू पर।

1923
01:38:38,430 --> 01:38:41,030
>> और फिर यहाँ में, प्रति
लाइन 12 पर मेरी टिप्पणी,

1924
01:38:41,030 --> 01:38:43,390
एक चरित्र बाहर प्रिंट,
एक नई लाइन द्वारा पीछा किया,

1925
01:38:43,390 --> 01:38:48,140
विशेष रूप से argv ब्रैकेट
मैं मेरे मैं वें स्ट्रिंग देता है

1926
01:38:48,140 --> 01:38:51,690
argv-- तो पहला शब्द में,
दूसरा शब्द, तीसरे शब्द है, जो भी हो।

1927
01:38:51,690 --> 01:38:57,370
और फिर गहरी में जम्मू गोते, और हो जाता है
मुझे उस शब्द के जम्मू-वें चरित्र।

1928
01:38:57,370 --> 01:39:02,200
और हां, वास्तव में, आप का इलाज कर सकते
argv एक बहु-आयामी रूप में,

1929
01:39:02,200 --> 01:39:06,050
एक दो आयामी, सरणी के रूप में,
जिससे लग रहा है की तरह हर शब्द

1930
01:39:06,050 --> 01:39:08,580
अपने मन में इस तरह
आंख, और हर चरित्र

1931
01:39:08,580 --> 01:39:10,930
एक तरह से में बना है
एक कॉलम, कि अगर मदद करता है।

1932
01:39:10,930 --> 01:39:13,260
>> हकीकत में, हम जब तंग
भविष्य हफ्तों में इस के अलावा,

1933
01:39:13,260 --> 01:39:15,580
यह एक छोटे से होने जा रहा है
कि अधिक से अधिक परिष्कृत।

1934
01:39:15,580 --> 01:39:17,800
लेकिन क्या तुम सच में कर सकते हैं
इस बात का लगता है, अब के लिए,

1935
01:39:17,800 --> 01:39:22,110
सिर्फ इस दो आयामी रूप में
सरणी, जिससे एक यह के स्तर पर

1936
01:39:22,110 --> 01:39:23,260
तार के सभी है।

1937
01:39:23,260 --> 01:39:26,760
और फिर आप गहरी, और आप में डुबकी यदि
व्यक्तिगत चरित्र पर प्राप्त कर सकते हैं

1938
01:39:26,760 --> 01:39:29,600
यहाँ इस संकेतन का उपयोग करके उसमें।

1939
01:39:29,600 --> 01:39:31,620
>> तो शुद्ध प्रभाव क्या है?

1940
01:39:31,620 --> 01:39:34,970
मुझे आगे चलते हैं और
argv2-- रफ़ू इसे बनाते हैं।

1941
01:39:34,970 --> 01:39:36,210
मैं यहाँ एक गलती।

1942
01:39:36,210 --> 01:39:40,160
उलझाव की घोषणा
पुस्तकालय समारोह स्टर्लिंग।

1943
01:39:40,160 --> 01:39:42,190
तो यह सब समय है, यह
शायद उचित

1944
01:39:42,190 --> 01:39:45,130
हम एक तरह से खत्म कर रहे हैं कि
वास्तव में, जहां हम शुरू कर दिया।

1945
01:39:45,130 --> 01:39:48,160
>> मैं बँधा हुआ है, उलझाव की घोषणा
पुस्तकालय समारोह स्टर्लिंग।

1946
01:39:48,160 --> 01:39:48,987
ठीक है एक मिनट रुको।

1947
01:39:48,987 --> 01:39:51,070
मुझे याद है कि, विशेष रूप से
के बाद से यह यहीं है।

1948
01:39:51,070 --> 01:39:54,490
मैं string.h शामिल करने की जरूरत
कार्यक्रम के इस संस्करण।

1949
01:39:54,490 --> 01:40:00,050
>> मुझे आगे जाना है और शामिल करते हैं
string.h, कि बचाने के लिए, आगे बढ़ो

1950
01:40:00,050 --> 01:40:04,460
और argv2 कंपाइल।

1951
01:40:04,460 --> 01:40:08,390
और अब, यहाँ हम चले, argv2 बनाने दर्ज करें।

1952
01:40:08,390 --> 01:40:10,590
हालांकि यह एक छोटी सी है
पहली नज़र में गुप्त,

1953
01:40:10,590 --> 01:40:15,690
सूचना है कि, वास्तव में, क्या
मुद्रित किया जाता है डॉट argv2 है।

1954
01:40:15,690 --> 01:40:19,970
>> लेकिन अगर मैं के बाद कुछ शब्द टाइप
शीघ्र, argv2 Zamyla चान की तरह,

1955
01:40:19,970 --> 01:40:22,560
दर्ज करें, जो भी एक छोटे से
पहली नज़र में गुप्त।

1956
01:40:22,560 --> 01:40:30,540
लेकिन अगर हम वापस ऊपर स्क्रॉल,
./argv2 जेड-ए-एम-वाई-एल ए सी-एच-ए-एन।

1957
01:40:30,540 --> 01:40:32,190
इसलिए हम हर शब्द पर दोहराया है।

1958
01:40:32,190 --> 01:40:37,770
और बदले में, हम पर दोहराया गए
एक शब्द के भीतर हर चरित्र।

1959
01:40:37,770 --> 01:40:40,040
>> अब, इस सब के बाद,
एहसास है कि वहाँ

1960
01:40:40,040 --> 01:40:43,120
एक अन्य विस्तार से हम किस तरह से किया गया है
इस पूरे समय की अनदेखी।

1961
01:40:43,120 --> 01:40:46,180
हम सिर्फ अलग छेड़ा क्या
मुख्य के आदानों हो सकता है?

1962
01:40:46,180 --> 01:40:47,780
क्या मुख्य के उत्पादन के बारे में?

1963
01:40:47,780 --> 01:40:50,540
>> इस समय के सभी, हम किया गया है
सिर्फ कॉपी करने और चिपकाने

1964
01:40:50,540 --> 01:40:53,870
मुख्य के सामने शब्द पूर्णांक,
आप ऑनलाइन देख सकते हैं, हालांकि,

1965
01:40:53,870 --> 01:40:58,340
कभी कभी पुराने संस्करणों में गलत तरीके से
सी और compilers के, वे शून्य का कहना है कि,

1966
01:40:58,340 --> 01:40:59,410
या कुछ भी नहीं।

1967
01:40:59,410 --> 01:41:01,580
लेकिन, वास्तव में, संस्करण के लिए
सी का हम प्रयोग कर रहे हैं कि,

1968
01:41:01,580 --> 01:41:06,180
सी 11, या 2011, एहसास
कि यह int होना चाहिए।

1969
01:41:06,180 --> 01:41:09,300
और यह तो होना चाहिए
शून्य या argc और यहाँ argv।

1970
01:41:09,300 --> 01:41:10,790
>> लेकिन क्यों int मुख्य?

1971
01:41:10,790 --> 01:41:12,480
यह वास्तव में क्या लौट रहा है?

1972
01:41:12,480 --> 01:41:16,280
खैर, यह इस समय के सभी पता चला है,
किसी भी समय आप एक कार्यक्रम के मुख्य लिखा है

1973
01:41:16,280 --> 01:41:18,440
हमेशा कुछ लौट रहा है।

1974
01:41:18,440 --> 01:41:19,960
लेकिन यह तो चुपके से कर रहा है।

1975
01:41:19,960 --> 01:41:23,350
>> एक यही कारण है कि कुछ तो है
पूर्णांक, रेखा के रूप में 5 चलता है।

1976
01:41:23,350 --> 01:41:24,225
लेकिन क्या Int?

1977
01:41:24,225 --> 01:41:26,100
ठीक है, वहाँ यह है
प्रोग्रामिंग में सम्मेलन,

1978
01:41:26,100 --> 01:41:29,790
जिससे अगर कुछ भी नहीं है
गलत हो गया और सब कुछ ठीक है,

1979
01:41:29,790 --> 01:41:34,250
कार्यक्रमों और समारोहों में आम तौर पर
return-- कुछ हद तक counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0।

1981
01:41:35,230 --> 01:41:38,070
0 आम तौर पर सब कुछ ठीक है का प्रतीक है।

1982
01:41:38,070 --> 01:41:40,610
तो फिर भी आप के बारे में सोच
यह कई संदर्भों में के रूप में झूठी,

1983
01:41:40,610 --> 01:41:42,930
यह वास्तव में आम तौर पर एक अच्छी बात का मतलब

1984
01:41:42,930 --> 01:41:49,560
>> इस बीच, अगर एक कार्यक्रम रिटर्न 1,
या नकारात्मक 1, या 5, या नकारात्मक 42,

1985
01:41:49,560 --> 01:41:52,941
या किसी भी गैर-0 मूल्य,
कि आम तौर पर प्रतीक

1986
01:41:52,941 --> 01:41:54,190
कि कुछ गलत हो गया है।

1987
01:41:54,190 --> 01:41:56,700
वास्तव में, अपने खुद के मैक या पीसी पर,
आप वास्तव में देखा हो सकता है

1988
01:41:56,700 --> 01:42:01,050
एक त्रुटि संदेश, जिससे यह
कहते हैं कुछ या अन्य, त्रुटि

1989
01:42:01,050 --> 01:42:04,940
कोड नकारात्मक 42, या त्रुटि कोड
23, या कुछ ऐसे ही।

1990
01:42:04,940 --> 01:42:08,980
यह संख्या आम तौर पर सिर्फ एक संकेत है
प्रोग्रामर, या कंपनी के लिए

1991
01:42:08,980 --> 01:42:11,174
कि सॉफ्टवेयर बनाया है,
क्या है, गलत है और क्यों चला गया

1992
01:42:11,174 --> 01:42:13,590
इतना है कि वे के माध्यम से देख सकते हैं
उनकी प्रलेखन या कोड,

1993
01:42:13,590 --> 01:42:15,465
और यह पता लगाने की क्या
त्रुटि का वास्तव में मतलब है।

1994
01:42:15,465 --> 01:42:18,400
यह आम तौर पर नहीं है
हमारे लिए उपयोगी उपयोगकर्ताओं को समाप्त।

1995
01:42:18,400 --> 01:42:20,550
>> लेकिन मुख्य रिटर्न 0, सब कुछ ठीक है जब।

1996
01:42:20,550 --> 01:42:23,770
और अगर आप निर्दिष्ट नहीं करते
मुख्य वापस आ जाना चाहिए क्या,

1997
01:42:23,770 --> 01:42:26,950
यह सिर्फ स्वतः होगा
आप के लिए 0 वापसी।

1998
01:42:26,950 --> 01:42:30,870
लेकिन कुछ लौटने
बाकी वास्तव में उपयोगी है।

1999
01:42:30,870 --> 01:42:34,660
>> यह अंतिम कार्यक्रम में, मुझे जाने
आगे बढ़ो और इस exit.c कहते हैं,

2000
01:42:34,660 --> 01:42:38,630
और आज के के अंतिम परिचय
विषयों, एक त्रुटि कोड के रूप में जाना जाता है।

2001
01:42:38,630 --> 01:42:42,930
मुझे आगे जाना है और शामिल करते हैं हमारे
परिचित फाइलों को शीर्ष, int मुख्य करो।

2002
01:42:42,930 --> 01:42:49,500
और इस बार, चलो int argc करते हैं
स्ट्रिंग argv, और मेरे साथ कोष्ठक

2003
01:42:49,500 --> 01:42:50,836
समझा जाए कि यह सरणी में है।

2004
01:42:50,836 --> 01:42:52,460
और फिर मुझे सिर्फ एक मानसिक स्वास्थ्य की जांच करते हैं।

2005
01:42:52,460 --> 01:42:56,640
इस बार, अगर argc नहीं करता
बराबर 2, तो आप जानते हो क्या?

2006
01:42:56,640 --> 01:42:57,520
रहने भी दो।

2007
01:42:57,520 --> 01:43:03,170
मुझे लगता है कि कहने जा रहा हूँ, हे, उपयोगकर्ता,
आप कमांड लाइन तर्क याद कर रहे हैं

2008
01:43:03,170 --> 01:43:04,210
बैकस्लैश एन।

2009
01:43:04,210 --> 01:43:05,230
>> और फिर यह बात है।

2010
01:43:05,230 --> 01:43:06,130
मैं बाहर निकलने के लिए चाहते हैं।

2011
01:43:06,130 --> 01:43:11,030
मैं preemptively करने के लिए जा रहा हूँ,
और समय से पहले वास्तव में, वापसी

2012
01:43:11,030 --> 01:43:12,810
कुछ संख्या 1 के अलावा अन्य।

2013
01:43:12,810 --> 01:43:15,360
पहली बार के लिए मूल्य के लिए जाना
त्रुटि है कि हो सकता है 1 है।

2014
01:43:15,360 --> 01:43:17,860
आप कुछ अन्य गलत है, तो
स्थिति है कि हो सकता है,

2015
01:43:17,860 --> 01:43:21,390
तुम बदले 2 या 3 का कहना है कि वापस आ सकता है, या
शायद यह भी नकारात्मक 1 या 2 नकारात्मक।

2016
01:43:21,390 --> 01:43:23,750
>> ये सिर्फ बाहर निकलने के कोड रहे हैं
कि कर रहे हैं, आम तौर पर,

2017
01:43:23,750 --> 01:43:27,770
केवल प्रोग्रामर के लिए उपयोगी है, या
कंपनी है कि सॉफ्टवेयर शिपिंग है।

2018
01:43:27,770 --> 01:43:30,500
लेकिन तथ्य यह है कि यह
0 नहीं है जो महत्वपूर्ण है।

2019
01:43:30,500 --> 01:43:34,310
इसलिए इस कार्यक्रम में हैं, मैं चाहता हूँ
गारंटी है कि इस कार्यक्रम केवल

2020
01:43:34,310 --> 01:43:38,190
काम करता है अगर उपयोगकर्ता मेरे प्रदान करता है
दो में से एक तर्क गिनती के साथ,

2021
01:43:38,190 --> 01:43:42,880
कार्यक्रम का नाम है, और कुछ अन्य
शब्द, मैं के रूप में ज्यादा के रूप में लागू कर सकते हैं,

2022
01:43:42,880 --> 01:43:46,110
printf कहावत के साथ उपयोगकर्ता पर चिल्लाओ,
लापता कमांड लाइन तर्क है,

2023
01:43:46,110 --> 01:43:46,970
1 वापसी।

2024
01:43:46,970 --> 01:43:49,940
यही कारण है कि अभी तुरंत होगा
कार्यक्रम छोड़ दिया।

2025
01:43:49,940 --> 01:43:55,840
>> तभी argc के बराबर होती है 2 हम नीचे मिल जाएगा
इधर, पर जो बात मैं कहने जा रहा हूँ,

2026
01:43:55,840 --> 01:44:00,410
हैलो प्रतिशत है, बैकस्लैश एन, argv1।

2027
01:44:00,410 --> 01:44:03,827
दूसरे शब्दों में, मैं हूँ
argv 0 के बाद नहीं जा रहा है,

2028
01:44:03,827 --> 01:44:05,410
जो सिर्फ कार्यक्रम का नाम है।

2029
01:44:05,410 --> 01:44:09,450
मैं बाहर मुद्रित करने के लिए हैलो, अल्पविराम चाहते हैं,
दूसरा शब्द है कि मानव टाइप।

2030
01:44:09,450 --> 01:44:12,580
और इस मामले में
13 लाइन, सब कुछ ठीक है।

2031
01:44:12,580 --> 01:44:15,920
>> मुझे पता है कि argc 2
तार्किक रूप से इस कार्यक्रम से।

2032
01:44:15,920 --> 01:44:17,770
मुझे आगे जाना है और वापस जाने को 0 पर जा रहा हूँ।

2033
01:44:17,770 --> 01:44:21,230
एक अलग रूप में, यह ध्यान रखें कि
इस के रूप में अच्छी तरह से खरोंच में सच है।

2034
01:44:21,230 --> 01:44:24,760
>> तार्किक रूप से, मैं यह कर सकता है
और इन पंक्तियों के encapsulate

2035
01:44:24,760 --> 01:44:27,020
इस वरना यहाँ खंड में कोड की।

2036
01:44:27,020 --> 01:44:29,420
लेकिन उस तरह का है
अनावश्यक रूप से मेरे कोड इंडेंट।

2037
01:44:29,420 --> 01:44:31,800
और मैं सुपर बनाना चाहते
स्पष्ट है कि कोई बात नहीं,

2038
01:44:31,800 --> 01:44:34,670
डिफ़ॉल्ट रूप से, हैलो
कुछ छपा हो जाएगी,

2039
01:44:34,670 --> 01:44:36,050
इतने लंबे समय के उपयोगकर्ता सहयोग के रूप में।

2040
01:44:36,050 --> 01:44:39,360
>> तो इसका इस्तेमाल करने के लिए बहुत आम है
एक शर्त है, बस एक हैं,

2041
01:44:39,360 --> 01:44:41,870
कुछ गलत पकड़ने के लिए
स्थिति, और फिर बाहर निकलें।

2042
01:44:41,870 --> 01:44:45,690
और फिर, इतने लंबे समय में सब है
वैसे, एक और को ही नहीं है,

2043
01:44:45,690 --> 01:44:48,060
लेकिन सिर्फ कोड है
कि बाहर हैं, क्योंकि यह

2044
01:44:48,060 --> 01:44:51,060
इस में बराबर
विशेष मामले, तार्किक।

2045
01:44:51,060 --> 01:44:54,480
तो मैं 0 लौट रहा हूँ, बस के लिए
स्पष्ट रूप से दर्शाता है सब कुछ ठीक है।

2046
01:44:54,480 --> 01:44:58,480
>> अगर मैं वापसी 0 छोड़े गए, यह होगा
स्वचालित रूप से मेरे लिए ग्रहण किया।

2047
01:44:58,480 --> 01:45:00,890
लेकिन अब लगता है कि मैं वापस आ रहा हूँ
कम से कम इस मामले में एक,

2048
01:45:00,890 --> 01:45:04,940
मैं जा रहा हूँ, अच्छे उपाय के लिए और
स्पष्टता, इस मामले में 0 वापसी।

2049
01:45:04,940 --> 01:45:09,690
तो अब मुझे आगे जाना है और बाहर निकलने बनाते हैं,
जो एक सही segue सिर्फ छोड़ रहा है।

2050
01:45:09,690 --> 01:45:14,401
>> लेकिन बाहर निकलें, और मुझे जाने दो
आगे और ./exit करते हैं, दर्ज करें।

2051
01:45:14,401 --> 01:45:16,900
और कार्यक्रम मुझ पर चिल्लाया,
लापता कमांड लाइन तर्क।

2052
01:45:16,900 --> 01:45:18,120
ठीक है, मुझे सहयोग करते हैं।

2053
01:45:18,120 --> 01:45:23,810
>> मुझे बजाय ./exit करना, डेविड, दर्ज करें।

2054
01:45:23,810 --> 01:45:25,190
और अब यह कहते हैं, हैलो डेविड।

2055
01:45:25,190 --> 01:45:27,300
और आप सामान्य रूप में यह देखने के लिए नहीं होता।

2056
01:45:27,300 --> 01:45:30,650
>> लेकिन यह पता चला है कि वहाँ एक बात यह है कि
लिनक्स में खास तरह से वास्तव में देखने के लिए

2057
01:45:30,650 --> 01:45:34,470
क्या बाहर निकलें कोड के साथ एक कार्यक्रम से बाहर निकल गया।

2058
01:45:34,470 --> 01:45:37,184
एक ग्राफिकल में कभी कभी
मैक ओएस या Windows की तरह दुनिया,

2059
01:45:37,184 --> 01:45:40,100
आप केवल इन नंबरों जब एक देखना
त्रुटि संदेश स्क्रीन पर चबूतरे

2060
01:45:40,100 --> 01:45:41,940
और प्रोग्रामर
आप उस नंबर से पता चलता है।

2061
01:45:41,940 --> 01:45:44,773
लेकिन हम क्या त्रुटि देखना चाहते हैं
संदेश है, हम इसे here-- क्या कर सकते हैं

2062
01:45:44,773 --> 01:45:48,100
इसलिए ./exit, दर्ज करें, प्रिंट
लापता कमांड लाइन तर्क।

2063
01:45:48,100 --> 01:45:54,590
>> मैं अब गूंज $ ?, करते हैं जो है
हास्यास्पद गुप्त रहा।

2064
01:45:54,590 --> 01:45:56,590
लेकिन $?

2065
01:45:56,590 --> 01:45:59,220
जादुई जादू है
जो कहते हैं, अरे, कंप्यूटर,

2066
01:45:59,220 --> 01:46:01,900
मुझे बताओ कि क्या पिछले
कार्यक्रम के बाहर निकलने के कोड था।

2067
01:46:01,900 --> 01:46:03,410
और मैं हिट दर्ज करें।

2068
01:46:03,410 --> 01:46:07,520
मैं 1 देखते हैं, वह है, क्योंकि जो मैं
लौटने के लिए अपने मुख्य समारोह में बताया।

2069
01:46:07,520 --> 01:46:12,310
>> इस बीच, अगर मैं ./exit डेविड करते हैं,
और हिट दर्ज करें, मैं देख रहा हूँ, हैलो डेविड।

2070
01:46:12,310 --> 01:46:16,800
और अगर मैं अब गूंज $ करना ?, मैं हैलो 0 देखें।

2071
01:46:16,800 --> 01:46:19,080
और इसलिए यह वास्तव में होगा
बहुमूल्य जानकारी हो

2072
01:46:19,080 --> 01:46:23,420
डिबगर के संदर्भ में, इसलिए नहीं
इतना है कि आप, मानव, देखभाल करेगा।

2073
01:46:23,420 --> 01:46:26,060
लेकिन डिबगर और अन्य
प्रोग्राम हम इस सेमेस्टर इस्तेमाल करेंगे

2074
01:46:26,060 --> 01:46:29,420
अक्सर उस नंबर पर दिखेगा,
भले ही यह एक तरह से दूर छिपा हुआ है

2075
01:46:29,420 --> 01:46:32,780
जब तक आप इसके लिए, करने के लिए देखो
निर्धारित किया जाए या नहीं एक कार्यक्रम के

2076
01:46:32,780 --> 01:46:37,050
निष्पादन सही या गलत था।

2077
01:46:37,050 --> 01:46:40,450
>> और इतना है कि हमारे लिए लाता है
यही नहीं, दिन के अंत में।

2078
01:46:40,450 --> 01:46:43,917
हम देख द्वारा आज शुरू
डिबगिंग, और निश्चित रूप से बारी में

2079
01:46:43,917 --> 01:46:46,750
ही है, और तो और अधिक दिलचस्प है,
तकनीकी रूप से हुड के नीचे

2080
01:46:46,750 --> 01:46:49,490
क्या में तार कर रहे हैं, जो पिछले
सप्ताह हम सिर्फ लिए दी ले लिया है,

2081
01:46:49,490 --> 01:46:51,900
और निश्चित रूप से उन्हें ले गए
के लिए खरोंच में दी।

2082
01:46:51,900 --> 01:46:56,040
>> हम तो हम कैसे उपयोग कर सकते हैं को देखा
एक स्ट्रिंग में व्यक्तिगत चरित्र,

2083
01:46:56,040 --> 01:47:00,310
और उसके बाद फिर से एक उच्च स्तर ले लिया
, चीजों को देखने well-- कैसे पर देख रहे हैं

2084
01:47:00,310 --> 01:47:04,226
हम व्यक्तिगत पर प्राप्त करना चाहते हैं
संरचना की तरह एक सूची में तत्वों,

2085
01:47:04,226 --> 01:47:05,850
हम चाहते हैं कि कई तार के साथ ऐसा नहीं कर सकते?

2086
01:47:05,850 --> 01:47:08,050
और हम कमांड लाइन तर्क के साथ कर सकते हैं।

2087
01:47:08,050 --> 01:47:12,800
लेकिन इस तस्वीर सिर्फ बक्से के यहां
इस सामान्य विचार की प्रदर्शनात्मक है

2088
01:47:12,800 --> 01:47:14,451
एक सरणी, या एक सूची है, या एक वेक्टर की।

2089
01:47:14,451 --> 01:47:16,450
और पर निर्भर करता है
संदर्भ, इन शब्दों के सभी

2090
01:47:16,450 --> 01:47:17,880
थोड़ा अलग बातें मतलब है।

2091
01:47:17,880 --> 01:47:20,060
तो सी में, हम केवल जा रहे हैं
एक सरणी के बारे में बात करने के लिए।

2092
01:47:20,060 --> 01:47:23,840
और एक सरणी एक हिस्सा है
स्मृति की है, जिनमें से प्रत्येक है

2093
01:47:23,840 --> 01:47:27,720
तत्वों, सन्निहित हैं वापस,
वापस करने के लिए वापस करने के लिए वापस करने के लिए।

2094
01:47:27,720 --> 01:47:31,970
>> और उन तत्वों, आम तौर पर,
एक ही डेटा प्रकार की, चरित्र,

2095
01:47:31,970 --> 01:47:35,966
चरित्र, चरित्र, चरित्र, या
स्ट्रिंग, स्ट्रिंग, स्ट्रिंग, स्ट्रिंग, या पूर्णांक,

2096
01:47:35,966 --> 01:47:38,600
पूर्णांक, पूर्णांक, जो कुछ भी है
हम दुकान करने की कोशिश कर रहे हैं।

2097
01:47:38,600 --> 01:47:42,540
लेकिन दिन के अंत में, यह है
क्या यह धारणा की तरह लग रहा है।

2098
01:47:42,540 --> 01:47:44,530
आप ले जा रहे हैं अपने
कंप्यूटर की मेमोरी या राम।

2099
01:47:44,530 --> 01:47:48,590
और अगर आप इसे बाहर नक्काशी कर रहे हैं में
हूबहू आकार के बक्से, जो सभी के लिए

2100
01:47:48,590 --> 01:47:50,920
वापस आ रहे हैं, को वापस करने के लिए,
वापस, इस तरह से वापस करने के लिए।

2101
01:47:50,920 --> 01:47:53,200
>> और क्या बारे में अच्छा है
इस विचार, और यह तथ्य

2102
01:47:53,200 --> 01:47:58,580
हम इस तरह से व्यक्त कर सकते हैं कि मानों
हमारे डेटा संरचनाओं के साथ पहली बार

2103
01:47:58,580 --> 01:48:02,520
कक्षा में, हम शुरू कर सकते हैं मतलब
कोड के साथ समस्याओं को हल करने के लिए

2104
01:48:02,520 --> 01:48:04,079
कि हफ्ते 0 में इतना intuitively आया था।

2105
01:48:04,079 --> 01:48:05,870
आप फोन याद होगा
पुस्तक उदाहरण है, जहां

2106
01:48:05,870 --> 01:48:09,110
हम एक विभाजन का इस्तेमाल किया और जीत के लिए,
या एक द्विआधारी खोज एल्गोरिथ्म,

2107
01:48:09,110 --> 01:48:13,220
एक पूरे के माध्यम से झारना
नाम और नंबर का एक गुच्छा।

2108
01:48:13,220 --> 01:48:18,220
लेकिन हम मान लिया है, याद है, वह यह है कि
फोन की किताब पहले से ही हल किया गया था

2109
01:48:18,220 --> 01:48:21,630
किसी और पहले से ही था कि
out-- नामों की एक सूची दी सोचा

2110
01:48:21,630 --> 01:48:24,430
और numbers-- उन्हें alphabetize करने के लिए कैसे।

2111
01:48:24,430 --> 01:48:26,950
और अब है कि सी में हम,
भी क्षमता है

2112
01:48:26,950 --> 01:48:30,290
चीजों को बाहर रखना करने के लिए, नहीं
शारीरिक रूप से एक फोन बुक में

2113
01:48:30,290 --> 01:48:34,220
लेकिन लगभग एक कंप्यूटर में
स्मृति, हम सक्षम अगले सप्ताह किया जाएगा

2114
01:48:34,220 --> 01:48:38,470
पहले this-- फिर से शुरू करने की
एक array-- में हमारे डेटा संरचनाओं की

2115
01:48:38,470 --> 01:48:43,530
लेकिन अधिक महत्वपूर्ण बात, वास्तविक कंप्यूटर
विज्ञान एल्गोरिदम लागू

2116
01:48:43,530 --> 01:48:47,720
कोड में, जिसके साथ हम स्टोर कर सकते हैं
इस तरह के ढांचे में डेटा,

2117
01:48:47,720 --> 01:48:50,730
और फिर यह हेरफेर करने के लिए शुरू, और
वास्तव में इसके साथ समस्याओं को हल करने के लिए,

2118
01:48:50,730 --> 01:48:53,570
और उस के शीर्ष पर निर्माण करने के लिए,
अंत में, सी में कार्यक्रम,

2119
01:48:53,570 --> 01:48:56,730
अजगर में, जावास्क्रिप्ट में,
एसक्यूएल के साथ डेटाबेस क्वैरी?

2120
01:48:56,730 --> 01:48:59,980
>> और हम यह है कि इन सभी को देखेंगे
विभिन्न विचारों गूंथ।

2121
01:48:59,980 --> 01:49:04,100
लेकिन अब के लिए, कि याद करते हैं
डोमेन है कि हम आज पेश

2122
01:49:04,100 --> 01:49:06,920
इस बात को यहाँ था, और
क्रिप्टोग्राफी की दुनिया।

2123
01:49:06,920 --> 01:49:11,200
और तुम अपने आप को अगले समस्याओं के बीच
समाधान होगा क्रिप्टोग्राफी की कला है,

2124
01:49:11,200 --> 01:49:13,630
पांव मार और de-पांव मार
जानकारी है, और संकेताक्षर

2125
01:49:13,630 --> 01:49:15,930
और पाठ का गूढ़ रहस्य,
और अंत में यह सोचते

2126
01:49:15,930 --> 01:49:18,970
अब आप जानते हैं कि क्या
हुड के नीचे है

2127
01:49:18,970 --> 01:49:21,860
तो यह है कि जब आप देखते हैं या प्राप्त
इस तरह से एक संदेश है, आप

2128
01:49:21,860 --> 01:49:24,060
अपने आप को यह समझने कर सकते हैं।

2129
01:49:24,060 --> 01:49:26,740
यह सब, और अधिक अगली बार।

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [वीडियो प्लेबैक]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover सिर्फ पहुंचे।

2133
01:49:32,970 --> 01:49:35,146
मैं यात्रा जाने के लिए जा रहा हूँ
अपने कॉलेज के प्रोफेसर हैं।

2134
01:49:35,146 --> 01:49:37,611
हां।

2135
01:49:37,611 --> 01:49:40,080
नमस्ते।

2136
01:49:40,080 --> 01:49:40,660
ये तुम हो।

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
रुकिए!

2139
01:49:45,110 --> 01:49:45,610
डेविड।

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
मैं सिर्फ लगाने की कोशिश कर रहा हूँ
तुम्हें क्या हुआ बाहर।

2142
01:49:56,060 --> 01:49:58,130
कृपया, कुछ भी मदद कर सकता है।

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
आप अपने कॉलेज के थे
रूममेट, तुम नहीं थे?

2145
01:50:08,354 --> 01:50:10,770
तुम उसे जब साथ वहाँ थे
वह CS50 परियोजना समाप्त हो गया?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [संगीत बजाना]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -यही CS50 था।

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> मुझे इस जगह से प्यार है।

2152
01:50:44,770 --> 01:50:45,854
>> -खाएं।

2153
01:50:45,854 --> 01:50:47,020
हम व्यापार के बाहर जा रहे हैं।

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [अंत प्लेबैक]

