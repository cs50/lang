[Музички] 

Дејвид Џ MALAN: Во ред. Ова е CS50 и ова е почеток на недела 2. И ќе се потсетиме дека во текот на Во изминатите неколку недели, ние сме биле воведување на компјутер науката и, пак, програмирање. 

И почнавме приказната по пат на Нула, дека графички јазик од лабораторијата на МИТ. А потоа и во поново време, минатата недела, почнавме воведе higher-- на јазик од пониско ниво познат како C, нешто што е чисто текстуални. И, навистина, последен пат се истражени во тој контекст голем број на концепти. 

Ова, се потсетиме, беше многу првата програма ние погледна. И оваа програма, едноставно, отпечатоци од "Здраво, свет". Но, има толку многу навидум магија се случува. Тука е тоа # Include со овие аглести загради. Има Инт. Има (празно). Има голема заграда, кадрави загради, полу-запирки, и многу повеќе. 

И така, да се потсетиме дека воведовме гребење така што би можеле, идеално, види минатото дека синтаксата, работи дека навистина не е сето она што интелектуално интересно, но на почетокот е, апсолутно, малку незгодно да се заврши вашиот ум околу. И, навистина, еден од најчестите работи на почетокот на класа програмирање, особено за оние кои се помалку удобно, е да се фрустрирани од и сопнат од страна на одредени синтаксички грешки, да не зборуваме за логички грешки. И така кај нашите цели денес, всушност, ќе е да ви овозможат со некои решавање на проблеми техники за тоа како подобро да ги реши проблемите со самите себе во форма на отстранување грешки. И што ќе се сетите, исто така, дека животната средина, кој ќе воведе последен пат беше наречен CS50 ИРО. Ова е веб-базиран софтвер кој ти овозможува да програма во облакот, така да се каже, додека чувањето на сите ваши додадени фајлови заедно, како што повторно ќе денес. И се сети дека ние ревидира овие теми тука, меѓу нив и функции, и петелки, и променливи, и Булова изрази, и услови. И всушност уште неколку кои ги превод од светот на гребење во светот на В. 

Но, основните градежни блокови, така да се каже, навистина се уште е иста минатата недела. Всушност, ние навистина само имаше различни загатка парче, ако сакате. Наместо тоа, виолетова спаси блок, ние наместо да го printf, што е оваа функција во C, кој ви овозможува да се печати нешто и да го форматирате на екранот. Воведовме CS50 Библиотека, каде што има сега на get_char располагање, и get_int, и get_string, и неколку други функции, како Па, преку кој може да се добие влез од сопствени тастатура на корисникот. И ние исто така се погледне на работите како these- bool, и знак, и двојно, плови, int, long_long стринг. И таму е дури и други типови на податоци во В. 

Со други зборови, кога ќе се прогласи променлива за чување на некои вредност, или кога ќе се спроведе функција кој се враќа некои вредност, можете да наведете што тип на вредност тоа е. Дали е стринг, како низа од карактери? Дали е тоа голем број, како цел број? Дали е тоа со подвижна запирка вредност, или слично? Значи во C, за разлика од нула, ние, всушност, почна да одредите каков вид на податоци се враќавме или користење. 

Но, се разбира, ние исто така, се стрча во некои основни граници на компјутерите. А особено, овој јазик C, да се потсетиме дека ние ја погледнете број претекување, реалноста дека ако имате само еден ограничен износ на меморија или, поточно, на ограничен број на битови, вие само може да се смета толку висока. И така ние погледна во овој пример тука при контра во авион,, Всушност, ако работи доволно долго ќе прелеваат и ќе резултира во софтвер вистински физички потенцијална грешка. 

Ние, исто така, погледна лебдечки точка непрецизност, реалноста дека со само ограничен број на битови, без разлика дали е 32 или 64, можете да наведете само толку многу броеви по децималната точка, по што почнуваат да се непрецизни. Така на пример, една третина во свет тука, во нашата човечка светот, ние знаеме, е само бесконечен број на 3s по децималната точка. Но на компјутер не мора да може да претставува бесконечен број на броеви ако само му се овозможи на некои ограничен износ на информации. 

Затоа, не само што ќе ви овозможат со уште поголема сила во однос за тоа како можете да го изразат себе си во тастатура во однос на програмирање, ние, исто така, она што се ограничени навистина може да се направи. И навистина, грешки и грешките може да произлегуваат од овие видови на прашања. И, навистина, меѓу темите за денес се ќе биде во теми како дебагирање а всушност во потрага под хаубата колку беа воведени работи минатата недела всушност се спроведува така што подобро се разбере и на можностите на и ограничувањата на јазик како В. 

И всушност, ќе лупам назад на слоеви од наједноставните на податочна структура, нешто што се нарекува низа, која Нула случува да се јавите на "листата." Тоа е малку различни во тој контекст. И тогаш или ќе се воведе еден од Првиот од нашиот домен-специфични проблеми во CS50, во светот на криптографијата, уметноста на питачи или во шифрирани информации, така кои може да се испрати тајни пораки и декодирање на тајни пораки помеѓу две лица, А и Б. 

Па пред да транзиција на тој нов свет, ајде да се обидеме да ви овозможат со некои техники со кои може да се елиминира или да се намалат барем некои на фрустрации што веројатно се соочиле Само во текот на изминатата недела. Всушност, пред вас се such-- некои од прва проблеми во C. И шансите се, Ако сте како мене, за прв пат ќе се обидат да напишеш на програма, дури и ако се размислува логично на програмата е прилично едноставна, вие многу добро може да удри во ѕид, и компајлерот не се случува да соработуваат. Да се ​​биде или ѕвекот не се случува за да всушност го направите вашиот наддавање. 

И зошто е тоа така? Па, ајде да ги разгледаме во, можеби, едноставна програма. Одам да се оди напред и да се спаси ова датотека намерно наречен buggy0.c, затоа што јас го знам тоа да Погрешно е однапред. Но, јас не би можеле да сфатат дека ако ова е во првата или втората или третата програма дека јас сум всушност се прави себе. Па јас ќе одам да се оди напред и да се тип надвор, int главната (празно). А потоа и во внатрешноста на мојата големи загради, многу познати ( "Здраво, world-- обратна коса црта, n ") - и точка-запирка. 

Сум зачувани во датотеката. Сега ќе одам да одат надолу на терминалот мојот прозорец и тип на шминка buggy0, затоа што, повторно, името на датотеката денес е buggy0.c. Па јас напишете направи buggy0, Enter. 

И, о, боже, да се потсетиме од последниот пат дека нема пораки за грешка е добра работа. Па нема излез е добра работа. Но, тука имам јасно некои број на грешки. 

Значи првата линија на производство по пишување направи buggy0, да се потсетиме, е прилично опширниот излез ѕвекот е. Под хаубата, CS50 IDE е конфигуриран да се користи целиот куп на опции со овој компајлер така што вие не мора да да се размислува за нив. И тоа е се што првата линија значи дека започнува со ѕвекот. 

Но после тоа, проблемите почнат да се направи нивниот изглед. Buggy0.c на линијата 3, карактер 5, постои голема, црвени грешка. Што е тоа? Имплицитно прогласување библиотека функција printf со тип int (const char *, ...) [-Werror]. Мислам, тоа многу брзо добива многу таинствени. И, секако, на прв поглед, ние не би се очекува да се разбере интегритет на таа порака. И така една од лекциите за денес се случува да биде да се обиде да се забележи модели, или слични работи, на грешки може да има се среќаваат во минатото. Значи, да се разграничат само оние зборови кои изгледа познато. Големите, црвени грешка е јасно симбол на нешто се биде во ред. 

имплицитно прогласување библиотека функција printf. Па дури и ако јас не се разбирам она што имплицитно прогласување библиотека функција средства, проблемот сигурно се однесува на printf некако. И извор на ова прашање мора да се направи со неа прогласување. 

За прогласување на функцијата е да се спомене тоа за прв пат. И ние се користи терминологијата минатата недела за прогласување на прототип на функцијата, или со една линија на врвот на вашиот сопствена датотека или во т.н. хедер датотека. И во она што датотеката не кажеме минатата недела дека printf е цитат, unquote, пријавена? Во она што датотеката е прототип? 

Значи, ако се сеќавате, многу првото нешто што напишан, речиси секоја програма последните time-- и случајно пред некој миг започна пишување myself-- беше еден here-- hash-- # Include <stio-- за влез / output-- точка ж И навистина, ако сега можам да се спаси оваа датотека, јас ќе одам да се оди напред и да ја исчистите мојот екран, кои може да се направи од страна на пишување Јасно, или можете да се одржи контрола L, само да го исчистите вашиот терминал само за да се елиминираат некои средена. 

Одам да се оди напред и да Повторно внесете го направи buggy0, Enter. И Voila, јас се уште се види дека долго команда од ѕвекот, но нема порака за грешка тоа време. И навистина, ако јас ./buggy0 направи, исто како и минатиот пат, каде точка значи тоа директориум, коса црта само значи, тука доаѓа името на програмата и тоа име на програмата е buggy0, Внесете "Здраво, свет". 

Сега, како може да имате изваде ова решение без да мора да признавајќи ја како многу зборови како што го направив, секако, има направи тоа за толку многу години? Па, се реализира на првиот проблем сет, ние ќе се воведе на команда дека самиот персонал CS50 е напиша наречен help50. И навистина, C не спецификација за на проблем во собата за тоа како да го користите овој. 

Но, во суштина help50 програма со која вработените CS50 е напиша дека ви овозможува да се кандидира команда или ја извршите програмата, и ако не се разбере нејзината излез, да го помине своето производство да help50, на која точка на софтвер дека персоналот на курсот пишува ќе се погледне на излез од вашата програма линија по линија, карактер по карактер. И ако ние, вработените, го признаваат порака за грешка која сте доживува, ние ќе се обидеме да ви предизвика некои реторички прашања, со некои совети, слично на ТФ или CA или мене би го направил во лицето на работното време. 

Па гледам да help50 ако не мора да се признае проблем. Но, не се потпираат на неа премногу како патерица. Секако се обиде да ги разбере нејзините излез, а потоа да учиме од него така што само еднаш или двапати да се направи некогаш работат help50 за одредена грешка порака. После тоа, ќе треба да се подобро опремени себе за да дознаам што тој навистина е. 

Ајде да направиме еден друг тука. Дозволете ми да оди напред, а во друг датотека ние ќе го наречеме ова buggy1.c. И во оваа датотека сум ќе deliberately-- но се преправам дека не се разбере она што грешка што го направив. 

Одам да се оди напред и да прават this-- # Include, бидејќи јас сум научив лекцијата од пред една момент. Int главната (празно), како и досега. И тогаш тука јас ќе одам да се направи низа S - get_string. И се сети од последниот пат кога Ова значи дека, еј, компјутер, дај ми променлива, го нарекуваат S, и се од типот на таа променлива низа па јас може да се сместат на еден или повеќе зборови во неа. 

А потоа на десната страна страна на знак за еднаквост е get_string, што е функција во CS50 библиотека што го прави токму тоа. Станува функција и потоа тоа рацете од десно кон лево. Значи овој знак за еднаквост не значи "Еднакво", како што може да се размислува по математика. Тоа значи задача од десно кон лево. Па тоа значи, да ги преземе низа од корисникот и чувајте го во внатрешноста на ОК. 

Сега ајде да го користат. Дозволете ми да оди напред сега и како втор линија, дозволете ми да оди напред и да каже "Здраво" - не е "свет", но "Здраво,% s-- која е нашата случаеви, запирка s, која е нашата променлива, а потоа и точка-запирка. Значи, ако јас не се зафркнам премногу тука, ова изгледа како точниот код. 

И моите инстинкти се сега за да ја состави. Датотеката се нарекува buggy1.c. Па јас ќе одам да направите buggy1, Enter. И ебам-тоа, ако не постои дури и повеќе грешки отколку порано. Мислам, има уште пораки за грешки што би се чини дека од реалните линии во оваа програма. 

Но, готова брза тука е, дури и ако не се преоптоварени со две или три или уште четири пораки за грешки, секогаш се фокусира на самиот Првиот од овие пораки. Гледајќи во горниот најмногу една, лизгање се врати како треба да биде. Па еве јас ја внеле шминка buggy1. Тука е дека производството ѕвекот како што се очекуваше. 

И тука е првата црвена грешка. Употреба на непријавена идентификатор стринг, не мислам стандард во? Па стандард е всушност нешто друго. Таа се однесува на корисникот тастатура, во суштина. 

Но, тоа не е она што мислев. Мислев стринг, и мислев get_string. Значи, што е тоа што јас заборавив да го направите ова време? Она што недостасува овој пат? Имам # Include, па имам пристап до printf. 

Но, она што не сум пристап до само уште? Па, исто како и минатиот пат, Јас треба да се каже на компајлерот Ѕвекот што овие функции се. Get_string не доаѓа со C. И особено, не дојде во хедер датотека,. Наместо тоа доаѓа во нешто персоналот напиша: кој е на друга датотека името, туку во потполност именуван. 

Толку едноставно додава дека една линија на code-- потсетиме од последниот пат дека кога ѕвекот работи, тоа се случува да се погледне во мојот код врвот до дното, лево кон десно. Тоа се случува да се забележи, О, вие сакате. Дозволете ми да оди и да најде дека, секаде каде што е на серверот, копирајте го и ставете, во суштина, во врвот на вашата датотека така што во овој момент во приказната, линија 1, на другиот дел на програмата може, навистина, да користите било која од функциите во него, меѓу нив get_string. Па јас ќе одам да се игнорира остатокот од оние грешки, затоа што, всушност, се сомневаат дека само првиот всушност важно. И јас одам да се оди напред и прегласувањето, по спасување моето досие направи buggy1. И Voila, тоа не работа. И ако го направам ./buggy1 и напишете, за На пример, Zamyla, јас сега ќе се здраво, Zamyla, наместо Здраво, свет. 

Во ред. Значи takeaways тука тогаш треба да, еден, се обиде да собере колку што можеш од пораките за грешка сам, во потрага во некои од препознатливите зборови. Забрана тоа, користете help50 на проблемот спецификација. Но, за забрана на тоа, исто така, секогаш гледам на врвот грешка само, барем на почетокот, да видите какви информации таа всушност може да се добие. Но, се покажа дека е уште поголема функционалност изградена во CS50 библиотека да им помогне на ви на почетокот на семестарот и почетокот на програмирање дознаам што се случува во ред. Значи, да се направи уште еден пример тука. Јас ќе одам да се јавите на оваа buggy2, кои, повторно, ќе се недостатоци од на портата, од страна на дизајнот. 

И јас одам да се оди напред и направете # Include. А потоа јас ќе одам да направите int главната (празно). И тогаш јас ќе одам да се направи за телефонска линија. За (int i _ 0. i е помала или еднаква на 10. i ++, а потоа и во големи загради, јас ќе одам да се печати само симбол хаштаг тука и нова линија карактер. 

Значи мојата намера со овој Програмата е многу едноставно да iterate 10 пати и на секој повторување на тој циклус секој пат преку циклус, печатење на хаштагови, хаштаг, хаштаг. Еден на линија, бидејќи јас имаат нова линија таму. И да се потсетиме дека за циклус, по последните week-- и ќе добиете повеќе запознаени со синтаксата со помош на него со практиката пред long-- тоа ми дава променлива наречена i и го поставува на 0. 

Овој чекор на зголемување I на секој повторување на 1. Па јас оди на 1 до 2 или 3. И тогаш оваа состојба во средината помеѓу полу-запирки добива проверуваат на секој повторување да се направи Осигурајте се дека се уште сме во тој опсег. Значи сакам да iterate 10 пати, па јас имаат некој вид на многу интуитивно само стави 10 како мојот горниот врзани таму. 

А сепак, кога ќе ја извршите оваа, по тоа составувањето со шминка buggy2-- и тоа не ги собира во ред. Па јас не имаат Грешка во синтаксата тоа време. Дозволете ми да оди напред сега и да ја стартувате buggy2, Enter. И сега скролувајте нагоре. И дозволете ми да се зголеми големината на прозорецот. 

Ми се чини дека има 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Значи има 11 хаштагови, иако Јас јасно стави 10 во внатрешноста на овој циклус. Сега, некои од вас може да се види веднаш она што на грешка е затоа што, навистина, ова не е многу тешко грешка да се направи. Но, тоа е многу често се направи многу рано. 

Она што сакам да истакнам, сепак, е, како би можел да дознаам ова? Па, излегува дека на CS50 библиотека збор не само со get_string и get_int и get_float и други функции. Таа, исто така доаѓа со посебна функција наречен eprintf, или, printf грешка. И тоа постои само за да се направи тоа малку полесно за вас кога дебагирање на кодот да се само порака за грешка на екранот и знаат од каде доаѓа. 

Така на пример, едно нешто што би можеле да направите тука со оваа функција е this-- eprintf, а потоа јас ќе одам да се оди напред и да каже јас сега е% i, обратна коса црта, n. И јас одам да го приклучиш во вредноста на i. И до врвот, бидејќи тоа е во CS50 библиотека, Одам да се оди напред и вклучуваат така имаат пристап до оваа функција. Но, ајде да се разгледа она што линијата 9 треба да се прави. Одам да го избришете овој крај. Ова нема никаква врска со моите Општата цел. Но eprintf, printf грешка, е само наменета да ми даде некои дијагностички информации. Кога ќе се кандидира мојата програма, сакам да види ова на екранот привремено како и само да се разбере што се случува. 

И, навистина, на секоја повторување тука на линија 9 Сакам да ја видам, што е вредноста на i? Која е вредноста на i? Која е вредноста на i? И, се надевам, јас само треба да види таа порака, исто така, 10 пати. 

Па дозволете ми да оди напред и да прекомпајлирате мојата програма, како што мора да се направи во секое време Јас се направи промена. ./buggy2. И now-- OK. Има многу повеќе се случува. Па дозволете ми да дојдете во уште поголем прозорец. 

И ќе видите дека секој од на хаштагови се уште печатење. Но помеѓу секој од нив ова е сега дијагностички излез форматирана како што следи. Името на мојата програмата овде е buggy2. Името на датотеката е buggy2.c. бројот на линијата, од кои ова беше отпечатена е алинеја 9. А потоа на десно од тоа е порака за грешка дека сум очекуваме. 

И, што е убаво за ова е тоа што сега не мора да значи да се смета во мојата глава она што ми го прави програмата. Јас може да се види дека на првата итерација i е 0, а потоа 1, а потоа 2, потоа 3, а потоа 4, а потоа 5, а потоа 6, а потоа 7, а потоа 8, потоа 9, а потоа 10. Па почекајте една минута. Што се случува овде? Јас се уште се чини дека се брои како што е предвидено до 10. 

Но, од каде да почнам? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Па 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- на 11-ти прст е показател за проблемот. Ми се чини дека се бројат погрешно во мојот циклус. Наместо да одат 10 повторувања, Јас сум почнуваат во 0, Јас сум завршува во и до 10. Туку затоа што, како компјутер, Јас сум почнуваат броење на 0, Јас треба да се броење до да, но не преку, 10. 

И така на фикс, јас на крајот реализираат овде, е една од две работи. Јас може многу едноставно да се каже брои до помалку од 10. Па 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, кој е, всушност, точно, иако тоа звучи малку ред. Или би можел да направи помала или еднаква до 9, толку долго како што со почеток во 0. Или, пак, ако навистина не ми се допаѓа тоа, може да смета до преку 10, но со почеток во 1. Но, повторно, ова едноставно не е толку честа појава. Во programming-- иако не толку во Scratch-- но во програмирање C и на други јазици, како вклучите Javascript-и Python и други, тоа е само многу честа појава за нашата дискусија на бинарни само да почне пребројување на најмал број што може, што е 0. Во ред. Значи тоа е eprintf. И повторно, сега што сум ги сфатиле мојата проблем, и јас ќе одам да се врати во 0 со помалку од 10, јас ќе одам да одат и да го избришете eprintf. 

Тоа не треба да биде таму кога ќе брод мојот код или да поднесе мојот код или да ја покаже на некој друг. Тоа е навистина само значеше што треба да се користи за привремено. Но, сега сум фиксна ова посебен проблем, како и. 

Па, ајде да направиме уште еден пример тука дека јас ќе одам да разбивам како што следи. Одам да се оди напред и да # Include. $ 50 И јас одам да се оди напред и # Include. 

И јас одам да се спаси оваа датотека како buggy3.c. И јас одам да се оди напред и го прогласи int главната (празно). А потоа и во внатрешноста на таму Одам да се направи int i _ - Сакам да спроведе програма со get_negative_int. Ова не е во функција, која постои уште. Значи ние се случува да се имплементираат тоа во само еден миг. Но, ние ќе треба да се види зошто тоа е кабриолет во првиот помине. И уште сум добил на int од корисникот, Јас сум само се случува да се печати% i е негативен цел број, обратна коса црта n, запирка, i. Со други зборови, сите јас сакаат оваа програма да се направи се добие негативен int од на корисникот, а потоа печати дека тој и тој е негативен Инт. 

Сега е потребно за спроведување на оваа функција. Така подоцна во моето досие, јас ќе одам да се оди напред и да се изјасни за функција наречена get_negative_int (празно) - и ние ќе се врати на она што значи повторно таа линија во moment-- int n; do-- do following-- printf n е :. А потоа јас ќе одам да направите N - get_int, и го прават тоа додека n е поголем од 0. А потоа се врати n ;. 

Значи има многу случува во ова, но ниту еден од нив, ние не се погледне на минатата недела, барем на кратко. Така, на линија 10 тука сум прогласена за функција наречена get_negative_int, и јас сум се стави (празно), во загради, од причина е тоа што не се смета за влез. Јас не сум поминува ништо на оваа функција. Јас сум само добивање на нешто назад од него. 

И она што јас сум надевајќи се да се вратам е цел број. Не постои тип на податоци во C наречен negative_int. Тоа е само цел број, па затоа се случува да биде на нас да бидете сигурни дека вредноста која е всушност Се врати не е само int но исто така е негативен. 

On-line 12 Јас сум прогласување на променлива наречен n и правење на тип int. А потоа и во линија 13 до 18 Јас сум прави нешто, додека нешто не е точно. Јас ќе одам напред и печатење n се применува, дебелото црево, а потоа и простор, како потсетник за корисникот. 

тогаш јас сум нарекувајќи get_int и складирање на т.н. повратната вредност со тоа, што променлива n. Но јас ќе одам да го прави ова, а n е поголем од 0. Со други зборови, ако корисникот ми даде дава int, а тој број е поголем од 0, Ерго, позитивни, јас ќе одам да се само задржи reprompting на корисникот, задржи reprompting, ќе го натераат да соработуваат и да ми даде негативен Инт. 

И уште n е всушност negative-- Да претпоставиме дека корисникот конечно видови -50, тогаш ова додека јамка веќе не е точно бидејќи -50 не е поголем од 0. Значи ние се пробие на тој јамка логично и да се врати n. 

Но, има еден друг нешто што треба да направите. И јас може едноставно да го направите ова од копирање и вметнување една линија код на врвот на датотеката. Јас треба да ги учат ѕвекот, или ветување за ѕвекот, експлицитно дека јас ќе, всушност, оди и да се спроведе оваа функција get_negative_int. Тоа само може да биде помал во датотеката. Повторно, да се потсетиме дека ѕвекот чита работите врвот до дното, лево кон десно, така што не може јавите на функција ако ѕвекот не знае дека тоа нема да постои. 

Сега, за жал, оваа програма, како што некои од вас може да се забележи, веќе кабриолет. Дозволете ми да оди напред и да buggy3. Се компајлира, па мојот проблем сега не е синтаксичка грешка, како грешка текстуални, тоа е, всушност, ќе биде логичен грешка што сум намерно направени како можност за чекор преку она што се случува. 

Одам да се оди напред сега и да ја стартувате buggy3. И јас одам да се оди напред и не соработуваат. Одам да го даде бројот 1. Тоа не им се допаѓа, па тоа ме прашува повторно. 

Како за 2? 3? 50? Ниту еден од тие работат. Како за -50? И програмата изгледа да се работи. 

Дозволете ми да се обиде уште еднаш. Дозволете ми да се обиде -1, изгледа да се работи. Дозволете ми да се обиде -2, изгледа да се работи. Дозволете ми да се обиде 0. Нели, тоа е неточно. Сега, ние сме да се биде малку педантни тука. Но, тоа е, всушност, во случај дека 0 е ниту позитивно, ниту негативно. И така и фактот дека програмата е велејќи дека 0 е негативен број, тоа не е технички исправно. 

Сега, зошто тоа го правиме тоа? Па, тоа може да биде очигледна. И, навистина, на програмата е со цел да биде прилично едноставна па ние имаме нешто да се истражуваат. 

Но, ајде да се воведе трета дебагирање техниката тука се нарекува debug50. Значи ова е програма дека ние сме само создаде оваа година се нарекува debug50 кои ќе ви овозможи да се користи она што се нарекува вграден графички дебагерот во CS50 ИРО. И дебагерот е само една програма која генерално ви овозможува да се кандидира на вашиот програма но чекор по чекор по чекор, линија од ред до ред, паузирање, ѕиркаа наоколу, во потрага на променлива, така што на програма не само удар минатото и брзо да се печати нешто или не печати нешто. Тоа ви дава можност, во човечки брзина, за да комуницирате со неа. 

И да го направите ова, едноставно да го направите следново. По составувањето на вашиот код, кои што веќе го направи, buggy3, да оди напред и да ја стартувате debug50 ./buggy. Толку многу како help50 има да се кандидира help50 а потоа командата, debug50 мора да се кандидира и debug50 тогаш името на командата. 

Сега се види што ќе се случи на мојот екран, на десната рака, а особено. Кога ќе се погоди Испратена, сите одеднаш се јави овој десната страна панел се отвора на екранот. И има многу работи се случуваат за на прв поглед. Но, не е премногу многу да се грижите за уште. 

Ова е се што ми покажува што се случува во внатрешноста на мојата програма токму сега и преку овие копчиња до врвот е тогаш што ми дозволивте да влезете низ мојот код во крајна линија, чекор по чекор по чекор. Но, не е само уште. Информации што се случува. На терминалот мојот прозорец Јас сум се прашани за n. И јас одам да се оди напред и да соработуваат ова време и во вид -1. И иако малку cryptically, -1 е негативен број, како што се очекуваше. 

И тогаш детето излезе со статус 0 GDBserver излегување. GDB, GNU грешки, е името на основните софтверски кои ги спроведува овој дебагерот. Но, сето тоа навистина значи, дебагерот отиде далеку, бидејќи мојата програма се откажат од и сите беше добро. Ако сакам да навистина debug мојата програма, Морам да кажам превентивно debug50, каде можам да сакате да започнете Менувајќи мојот код? 

И можеби наједноставниот начин да го направите тоа е како што следува. Ако јас лебдат над олук на уредникот тука, Значи, навистина само во страничната лента тука, од лево на бројот на линијата, Забележете дека ако јас само кликнете еднаш, јас се стави малку црвена точка. И дека многу малку црвена точка, како знак стоп, значи, еј, debug50, извршување пауза од мојот код право таму кога ќе ја извршите оваа програма. 

Па ајде да го направите тоа. Дозволете ми да оди напред и да ја стартувате мојата програма повторно со debug50 ./buggy3, Enter. И сега, информации, нешто различни се случило. Јас не сум се поттикнати уште во терминал мојот прозорец за ништо, бидејќи јас не се стигнал уште во мојата програма. Забележете дека на линија 8 кој сега е обележана, и таму е малку стрелка лево вели, вие сте на пауза тука. Оваа линија код, линија 8, се уште не е извршена. 

И, што е чудно, ако погледнам овде на десната рака, Забележете дека јас е локална променлива, локално во смисла дека тоа е во внатрешноста на тековната функција. И неговата вредност, очигледно по дифолт, и вид на практично, е 0. Но, јас не напишете 0. Тоа едноставно се случува да биде нејзин Вообичаената вредност во моментот. 

Па дозволете ми да оди напред и да се направи тоа сега. Дозволете ми да оди напред и на во горниот десен агол тука, јас сум да се оди напред и кликнете на оваа икона, која прв значи чекор преку што значи не го прескокнувајте тоа, но се повлече во текот на оваа линија код, негово извршување на патот. 

И сега, да се забележи, мојата брза штотуку се промени. Зошто е тоа така? Јас сум изјави debug50, ја извршите оваа линија код. Што значи оваа линија код направам? ме прашува за int. ДОБРО. Дозволете ми да соработуваат. Дозволете ми да оди напред сега и тип-1, Enter. И сега се забележи она што не се сменило. На десната рака, мојата локална променлива i се посочуваат како -1 сега. И тоа е уште од типот int. 

И информации, исто така, мојата т.н. јавете магацинот, каде што се откажеш? Ние ќе разговараме повеќе за во иднина. Но магацинот на повикот само се однесува на она што функции во моментов се во движење. Токму сега тоа е само главните. И сега единствениот локален променлива е i со вредност од 1. 

И кога конечно се повлече во текот на оваа линија тука, со што истата икона во горниот десен агол, -1 Е негативен број. Сега е задржувањето во текот на овој кадрава голема заграда. Ајде нека си ја работи својата работа. Јас се повлече во текот на таа линија, и Voila. 

Затоа, не се што е страшно просветителската сепак, но тоа ми дозволи да го паузирате и мислам преку логички она што оваа програма прави. Но, тоа не беше погрешна случај. Ајде да го направиме тоа повторно како што следи. 

Одам да ја напуштат таа точка на прекин on line 8 со црвена точка. Одам да повторување debug50. Тоа е автоматски пауза тука. Но овој пат, наместо повлекува над оваа линија, дозволете ми да всушност одат во внатрешноста на get_negative_int и да дознаам, зошто е тоа прифаќање 0 како валиден одговор? 

Така, наместо кликнување оддалечува. Одам да се оди напред и кликнете чекор во. И ќе забележите дека линијата 8, кој е сега истакна сега одеднаш станува линија 17. 

Сега, тоа не е толку дебагерот има прескокнаа линии 14 и 15 и 16. Тоа е само нема ништо да ви покаже таму. Тоа се само прогласување променливи, А тука е и зборот Дали а потоа отворен кадрава голема заграда. Единственото функционално линија која е сочни навистина е овој овде, 17. И тоа е каде што ние сме паузира автоматски. 

Значи printf ( "n.is:") ;, така што не се случило досега. Па ајде да одиме напред и да кликнете да се оддалечува. Сега, мојот брза, навистина, изменета на ( "n е:"). Сега get_int, јас не одам да се мачи повлекува во, бидејќи таа функција беше направени од страна на CS50 во библиотеката. Тоа е веројатно точно. 

Па јас ќе одам да се оди напред и да се вид на соработка со давање на int, но не и негативен Инт. Па дозволете ми да оди напред и да ја погоди 0. И сега што се случува овде кога ќе се фаќате за линија 21? Јас не сум повтори уште еднаш. Јас не се чини дека се заглавени во тој циклус. Со други зборови, жолта бар не продолжи да оди наоколу, и околу и наоколу. 

Сега, зошто е тоа така? Па, n, што е N моментов? Јас може да се погледне на локално променливи во дебагерот. n е 0. Сите во право, што е мојата состојба? 

20-- линија 20 е, добро, 0 е поголем од 0. Тоа не е вистина. 0 не е поголем од 0. И така јас се скрши надвор од ова. 

И така тоа е причината зошто на линија 21, ако јас всушност продолжи, Одам да се врати 0, дури и иако треба да ги отфрлија 0 како што е, всушност, не е негативна. Па сега, јас не навистина дури и се грижат за дебагерот. Доби тоа, јас не треба да се знам што повеќе се случува. 

Па јас ќе одам да се оди напред и да се само кликнете на копчето за изведба, и нека оваа завршам. Сега, јас сфатив дека мојот бубачки е очигледно на линија 20. Тоа е мојата логичка грешка. 

И така она што сакам да се направи да се промени тоа? Ако проблемот е во тоа што јас не сум фаќање на 0, тоа е само една логичка грешка. И можам да кажам, а n е поголемо од или еднакво на 0, задржи прашува корисникот за повторно и повторно. 

Значи, повторно, едноставна грешка, можеби дури и очигледно кога ме виде, напишете пред само неколку минути. Но, готова брза тука е дека со debug 50, и со дебагирање софтвер поопшто, го имате овој новонастанатата моќ да прошетка низ свој код, погледнете преку кои десниот панел што променливите вредности. Значи, вие не мора да треба да се користи нешто како да eprintf за печатење тие вредности. Ти всушност може да ги види визуелно на екранот. 

Сега, надвор од тоа, тоа е вреди да се напомене дека има уште една техника која е всушност супер заедничко. И може да се прашувам зошто оваа мала Човекот тука е седница на сцената. Па таму е оваа техника, генерално, познат како гумена патка дебагирање, кои, навистина, е само еден доказ на фактот дека често, кога програмерите се пишува код, тие не се нужно соработува со други, или работат во една заедничка животната средина. 

Тие се вид на дома. Можеби тоа е доцна во ноќта. Тие се обидуваат да дознаам некои грешки во нивниот код. И тие се само да го видат. 

И нема цимер. Не постои ТФ. Не постои CA наоколу. Сите тие го имаат на нивниот рок е оваа мала гума пиленце. 

И така гумена патка дебагирање е само оваа покана да се мисли на нешто толку глупаво како ова како вистински суштество, и всушност оди преку вашиот код усно на овој апатичен објект. Така, на пример, ако ова е мојот пример here-- и да се потсетиме дека на почетокот проблемот е тоа, ако јас ја избришете оваа прва линија код, и одам напред и да направат кабриолет 0 повторно, потсетиме дека имав овие пораки за грешки овде. Значи идејата тука, смешно иако јас се чувствуваат во моментот тоа јавно, е дека грешка. 

Добро, така што мојот проблем е што сум имплицитно декларирани функција библиотека. И тоа е библиотека функција printf. Declare-- ред, да изјави ме потсетува на прототипи. 

Тоа значи дека треба да се, всушност, каже на компајлерот однапред што функцијата како изгледа. Почекај минута. Немав стандард io.h. Ти благодарам многу. 

Па само овој процес ќе of-- не треба да се, всушност, имаат патка. Но, оваа идеја на одење себе преку свој код така што ќе ги слушнам себе, така што ќе реализира пропусти во свој забелешки, генерално е идејата. 

И, можеби уште логично, не е толку многу со тоа една, туку повеќе се вклучени пример, ние само го направи во кабриолет 3.C, можете да се оди преку него како што следи. Значи во ред, гума пиленце, ДДБ, ако сакате. Тука имаме во мојата главна функција, Се јавувам добие негативен Инт. 

И јас сум добивање на повратната вредност. Јас сум тоа чување на левата страна on line 8 во променлива наречена i. Добро, но чекајте, како го направи кои се на таа вредност? Дозволете ми да се погледне на функција во линија 12. 

Во алинејата 12, имаме добие негативен Инт. Не ги преземат сите влезови, се врати на int, ОК. Изјавувам on-line 14 променлива n. Тоа се случува да се сместат на цел број. Тоа е она што сакам. 

Затоа направете го следново додека n is-- да ми го вратите она фикс јас веќе направени. Па така додека n е поголемо од 0, печатење N е, во ред. И тогаш јавете се int чуваат во n. И потоа проверете ако n е 0, n е not-- таму е. Значи, повторно, вие не треба вистинските патка. Но, само одење себе преку вашиот код како интелектуална вежба често ќе ви помогнат сфаќаш што се случува, за разлика од само прави нешто вака, зјапаше во екранот, и не зборува себе преку неа, кои искрено не е скоро како ефективна техника. Па таму ќе ја имаат, а број на различни техники за всушност дебагирање на кодот и наоѓање на вина, од кои сите треба да бидат алатки во вашето раководство така што вие не сте доцна во ноќта, особено, ти си во за јадење сали, или на работното време, удира главата на ѕид, во обид да се реши некој проблем. Сфатат дека постојат софтверски алатки. Постојат гума алатки патка. И таму е целиот персонал на поддршка чека да ја дадат на рака. 

Па сега, еден збор на проблемот сетови, и на она што ние сме ви надевајќи да излезе од нив, и како ние одиме за оценување. По силабусот на предметот е, проблем поставува CS50 е се проценува на четири основни оски, така да speak-- обемот, точноста, дизајн, и стил. И обемот само се однесува на тоа колку на парче сте каснати надвор? Како голем дел од проблемот сте се обиделе? Што ниво на напор сте се манифестира? 

Точноста е, дали програмата за работа како што би требало да по спецификација CS50 кога ќе се обезбедат одредени влезови или одредени излези се враќаат? Дизајн е најстариот субјективни од нив. И тоа е оној кој ќе се најдолго за да дознаете а најдолго за да учат, во доколку тоа се сведува на, колку добро напишани е вашиот код? 

Тоа е една работа да се печати само точниот излези или враќање на вистинските вредности. Но дали сте го прави тоа како ефикасно е можно? Дали сте го прави тоа јаз и го освои, или во бинарна пребарување како што наскоро ќе видите дека ние го сторивме пред две недели со телефонот книга? Дали има подобар начин да се реши проблем отколку во моментов го имаме тука? Тоа е можност за подобар дизајн. 

И тогаш како style-- прилично е вашиот број? Ќе забележите дека јас сум прилично особено за вовлекување мојот код, и правејќи се дека моите променливи разумно се именувани. n, а кратко, е добро име за број, јас за броење број, и за низа. И ние може да имаат подолг променлива имиња стил. Стил е само колку е добар изгледа вашиот код? И како може да се чита е тоа? 

И со текот на времето, она што ти TAS и TFS ќе го направи во текот е ви обезбеди дека вид на квалитативни повратни информации така што ќе добие подобро во тие различни аспекти. И во однос на тоа како ние оцени секој од овие оски, тоа е типично со многу малку кофи, така што, генерално, да се добие чувство за тоа колку добро го правиш. И, навистина, ако добиете резултат на било која од овие axes-- коректност, дизајн и стил especially-- тој број, генерално ќе биде помеѓу 1 и 5. И, буквално, ако сте добивање на 3 е на почетокот на семестарот, ова е многу добра работа. Тоа значи дека има уште простор за подобрување, која би надеж за во земање на класа за прв пат. Има се надевам дека некои малку на таванот на кои сте се стремат кон постигнување. И така добиваш 3 за најраните дела, Ако не е околу 2 и 4 на, е, всушност, е добра работа. Тоа е добро во рамките на опсег, и во рамките на очекувањата. 

И ако вашиот ум е дербито, почекајте една минута, три од пет. Тоа е навистина 6 од 10. Тоа е 60%. Боже мој, тоа е еден Ф. 

Тоа не е. Тоа не е, всушност, тоа. Напротив, тоа е можност да се подобри во текот на семестарот. И ако сте добивање на некои Poors, тие се можност да ги искористат предностите на работното време, сигурно делови и други ресурси. 

Најдобро е можност, навистина, да бидат горди на тоа колку далеку сте дојде во текот на семестарот. Така сфаќаат, ако ништо друго, три е добро. И тоа им овозможува простор за раст со текот на времето. 

За тоа како тие оски пондерирана, реално сте ќе поминуваат поголемиот дел од вашето време добивам работи кои треба да работат, а камоли правилно. И така точноста тенденција да се бројат најмногу, како и со ова мултипликативни фактор на три. Дизајн е исто така важно, но нешто што не мора да значи поминуваат сите тие часови на обидувајќи се да се работи само за да работат. 

И така тоа е бројат малку повеќе лесно. И тогаш стил е бројат во најмала рака. Иако тоа не е помалку е важна основа, тоа е само, можеби, најлесната работа да се направи тоа право, имитирајќи ние примери го направи во предавање и дел, со работи убаво вдлабнат, и забележува: и така натаму е меѓу најлесните нешта да се направи и да добијат право. Па како такви, се реализира дека тие се точки кои се релативно лесно да се сфати. 

И сега еден збор на this-- академски искреност. Значи за на курсот програма, ќе видите дека курсот има доста малку јазик околу ова. А се разбира е потребно прашањето на академски искреност доста сериозно. 

Имаме разлика, за подобро или за полошо, на ја испрати секоја година повеќе студентите за дисциплинска постапка од повеќето други Се разбира, дека јас сум свесен. Ова не е нужно укажува на фактот дека CS студенти или CS50 студенти, се помалку чесни од своите соученици. Но, реалноста дека во овој светот, по електронски пат, ние само имаат технолошките значи за откривање ова. 

Тоа е важно за нас за праведност низ класа што правиме откривање на тоа, и да се подигне прашањето кога ги гледаме работите. И само да наслика слика, и навистина да им помогне на нешто како ова потоне во, овие се броеви на студентите во текот на изминатите 10 години кои биле вклучени во некој ваквите прашања на академски искреност, со околу 32 студенти од есента 2015 година, што е да се каже дека ние се ова прашање многу сериозно. И, на крајот, овие бројки компонира, Неодамна, околу 3%, 4% или така на класата. 

Значи за супер дел од студентите се чини дека линии се јасни. Но, имајте го ова ум, особено кон крајот на во текот на ноќта, кога се борат со некои решение на сет на проблеми, дека постојат механизми за себе добивање на подобро поддршка отколку што може мислам, дури и во тој час. Сфатат дека кога ќе добиеме студент поднесоци, да преминеме споредба на секоја достава оваа година против секоја достава од минатата година, против секоја достава од 2007 година, и бидејќи, гледајќи, како и, код складишта на интернет, форуми за дискусија, работни локации. И ние се спомене тоа, навистина, сите за доброто на целосно обелоденување, дека ако некој друг може да го најдете на интернет, Секако, така да ние на курсот. Но, навистина, духот на курсот се сведува на оваа клаузула во наставната програма. Тоа навистина е праведен, да биде разумна. 

И ако ние требаше да се осврнам на тоа со само малку повеќе јазик, сфатат дека суштината на сите работа што ќе ги достават до овој курс мора да биде свој. Но, во тоа, секако дека постојат можности, како и охрабрување, и педагошка вредност во вртење на others-- јас, TFS, на договорниот орган, на TAS, а други во класата, за поддршка, а камоли пријатели и цимери кои ги проучувале CS и програмирање порано. И така таму е надоместок за тоа. А општо правило на палецот е this-- кога прашува за помош, може да се покаже вашиот код на другите, но не може да ја видите нивната. Па дури и ако сте на работното време, или во Д-сала, или на друго место работи на некои парче сет, работат заедно со еден пријател, кој е сосема во ред, во крајот на вашата работа на денот во крајна линија треба да припаѓаат на секоја од вас, соодветно, а не да има некои заеднички напори, освен за финалниот проект каде тоа е дозволено и охрабруваат. 

Сфатат дека ако се се борат со нешто и вашиот пријател едноставно се случува, да се подобри во ова, тогаш, или подобро во тој проблем од вас, или малку понапред од вас, тоа е сосема разумно да се претвори на вашиот пријател и да каже, еј, Дали ќе ти пречи да гледа во мојот код тука, Помагање на мене самото место она што е моето прашање? И, се надевам, во интерес на педагошката вредност тој пријател не само велат, ох, го прават тоа, туку, Што ви се исчезнати на линија 6, или нешто слично? Но, решението не е за пријател до тебе да се каже, добро де, тука, дозволете ми да се повлече на овој горе, и да покаже мојот решение за вас. Па тоа е линија. Ви покаже вашиот код, за да другите, но не може да видите нивната, да подлежат на другите ограничувања во силабусот на предметот е. 

Па имајте на ум ова т.н. клаузула жалење во силабусот на предметот, како и, дека ако изврши некое дело за кое Не е разумно, но го донесе на вниманието на шефовите на курсот во рок од 72 часа, се разбира, може да воведе локалните санкции кои може да вклучи незадоволително или не оценка за работата поднесени. Но, се разбира, не ќе се однесуваат на Тема за понатамошна дисциплинска постапка, освен во случај на повторно акти. Со други зборови, ако го прават некои глупави, особено доцна во ноќта, одлуката дека следното утро или два дена подоцна, ќе се разбудат и да сфатат, Што бев размислување? Можете да го направи во CS50 има излез за одредување тој проблем и сопственик до него, така што можеме ќе најдеме на половина пат и да се справат со тоа во прашање, како што е образовни и вредни за вас, но сепак казнени на некој начин. И сега, да се земе острото надвор, ова. 

[Видео репродукција] 

[Музички] 

[END репродукција] Дејвид Џ MALAN: Добро, ние сме назад. И сега ние се погледне во еден од Првиот на нашата реалниот свет домени во CS50, уметноста на криптографијата, уметноста на праќање и примање тајни пораки, шифрирана пораки ако сакате, кои може да се дешифрира само ако имате некои клучни состојка која Испраќачот исто така. Значи за да се мотивира ова ние ќе се Еден поглед во ова нешто овде, која е пример на еден тајна декодер прстен што може да се користи со цел да дознаам што всушност е тајна порака. Всушност, уште во ден во основно училиште, Ако некогаш сте се испрати тајни пораки до некој пријател или некој здроби во класа, може да си помисли сте биле се паметни од страна на вашиот парче менување хартија, како, од А до Б и Б на C и C до Д, и така натаму. Но се, всушност, енкрипција вашите податоци, па дури и ако тоа беше малку тривијални, не беше тоа тешко за наставникот да се реализира, Па, ако сте само промена Б на А и Ц на Б, што всушност дознаам она што беше пораката, но сте биле во шифрирани информации. 

Сте биле само го прават Едноставно, многу сличен на Ralphie тука во познатиот филм кој игра доста реклама nauseum секоја зима. [Видео репродукција] -Бидете Познат на сите кои Ралф Паркер е ова именуван за член на малата Сирачиња Ени Тајната Круг и има право на сите почести и придобивките се случува со него. 

Пропишан, Литл Ени сирачиња, Контра потпишан Пјер Андре, со мастило. Почести и бенефиции, веќе на возраст од девет години. 

[Викање] -Ајде. Ајде да се е со неа. Јас не треба сиот тој џез за шверцери и пирати. 

-Listen Утре вечер за склучување авантура на црната пиратскиот брод. Сега, тоа е време за тајна порака на Annie за да припадници на тајната круг. Запомнете, деца, само членови на Тајната Круг на Annie може да го декодира тајна порака на Annie. 

Запомнете, Ени е во зависност од вас. Поставете ги вашите иглички на Б2. Еве ја пораката. 12, 11-- 

-Јас Сум во мојата прва таен состанок. 

-14, 11, 18, 16. 

-Pierre Беше во голема глас вечерва. Можам да кажам дека вечерва порака е навистина важно. 

-3, 25, тоа е порака од самата Ени. Запомнете, не кажам на никого. 

-90 Секунди подоцна, јас сум во само соба во куќата во која едно момче од девет може да седат во приватноста и декодирање. Аха, Б! Отидов на следното, Е. 

Првиот збор е да биде. S, тоа доаѓа полесно сега, U, 25-- 

-OH, Ајде, Ralphie, морам да одам! 

-I'll Биде во право надолу, Ма! Gee факир! 

Т, О, да бидат сигурни дека to-- бидете сигурни на она што? Она што беше малку сирачиња Ени се обидува да се каже? Бидете сигурни на она што? 

-Ralphie, Енди мора да одат, ќе ве молиме да излезе? 

-Сите Право, Ма! Јас ќе бидам надвор! 

-Бев Доближуваат сега. Напнатоста беше страшно. Што беше тоа? Судбината на планетата може да висат во воздух. 

-Ralphie! Мора Енди одам! 

-I'll Биде во право надвор, за плачење гласно! 

-Almost Таму, моите прсти полета, мојот ум беше челик стапица, секоја пора вибрираше. Тоа беше речиси јасно, да, да, да. 

-Бидете Сигурни да пиете ovaltine. Ovaltine? Кофти комерцијални? Копиле. [END репродукција] Дејвид Џ MALAN: Добро, па тоа е многу долг пат за воведување на криптографијата, и, исто така, ovaltine. Всушност, од оваа стара реклама тука, зошто е ovaltine толку добар? Тоа е концентрирана екстракција на зрели јачменов слад, чиста крем кравјо млеко, и специјално подготвени какао, заедно со природни фосфатиди и витамини. Тоа е дополнително збогатена со дополнителни витамини Б и Д, yum. И се уште може да се добие тоа, очигледно, на Амазон, како што направивме овде. 

Но, мотивација тука е да се воведување на криптографијата, посебно еден вид на криптографијата познат како таен клуч криптографија. И како што сугерира името, целата безбедноста на таен клуч криптографија систем, ако сакате, методологија за само питачи информации помеѓу две лица, е во тоа што само на испраќачот и само на примачот знам тајна key-- некои вредност, некои тајна фраза, некои тајни број, им овозможува на двете криптирате и декриптирање на информации. И криптографијата, навистина, е само тоа од недела 0. 

Тоа е проблем каде што има влезови, како вистински порака на англиски јазик или што и јазикот што го сакате да ја испратите на некој во класа, или преку интернет. Има некои излез, што се случува да биде пржени порака дека сте ја сакате примателот да се добие. И дури и ако некој во средината што ја добива премногу, вие не би сакале да го мора да биде во можност да го дешифрираат, бидејќи во внатрешноста на оваа црна кутија, или алгоритам, некои механизам, некои чекор по чекор упатства, за преземање дека влезот и конвертирање на тоа во излез, се надевам дека во безбеден начин. 

И, всушност, има некои речник во овој свет како што следи. Обичен текст е зборот на компјутерски научник би се користи за опишување на внесување порака, како на англиски јазик или што и да јазик, всушност, сакате да ги пратите на некои други луѓе. И тогаш ciphertext е трка на enciphered, или енкриптирани, верзија од него. 

Но, има една друга состојка тука. Има еден друг влез на таен клуч криптографија. И тоа е самиот клуч, што е, генерално, како што ќе видиме, голем број, или писмо, или збор, без оглед на алгоритам е, всушност, не очекува. 

И како да се декриптира информации? Како да го разшифровам? Па, ти само се смени излези и влезови. 

Со други зборови, некој добива вашиот шифрирана порака, тој или таа едноставно има да се знае дека истиот клуч. Тие добиле ciphertext. И со вклучување на овие две влезови во системот за криптографија, алгоритам, оваа црна кутија, од треба да дојде на оригиналниот чист текст. И така тоа е на многу високо ниво поглед на она што е, всушност, криптографијата за сите. 

Па ајде стигнете таму. Ајде сега погледнете под хаубата на нешто ние сме биле преземање здраво за готово за на изминатата недела, и за оваа сесија here-- стрингот. А низа на крајот на денот е само низа од карактери. 

Тоа може да биде здраво светот, или Здраво Zamyla, или whatever. Но, што значи тоа за да биде низа од карактери? Всушност, CS50 библиотека дава ни тип на податоци се нарекува стринг. 

Но, таму е, всушност, нема такво нешто како стринг со В. Тоа навистина е само низа од карактер, карактер, карактер, карактер, назад, да се врати, да се назад, да се врати, да се врати во на меморијата на вашиот компјутер, или RAM меморија. И ние ќе се погледне подлабоко во дека во иднина, кога ќе погледнеме во себе меморија, и користење, како и закани кои се вклучени. 

Но, ајде да се разгледа на низа Zamyla. Па само името човечкиот тука, Zamyla, кој е низа од знаци, Z-A-M-Y-L-A. И сега ајде да претпоставиме дека името Zamyla е се складира во внатрешноста на компјутер програмата. 

Па, очигледно е дека не треба да да биде во можност да се погледне во овие ликови поединечно. Па јас сум само се случува да се подготви малку поле околу името Zamyla тука. И тоа е случај во C дека кога ќе имаат низа, како Zamyla-- а можеби таа низа се врати од функција како добие стринг, што всушност може да се манипулира тоа карактер по карактер. 

Сега, ова е germane за разговор во рака, бидејќи во криптографијата, ако сакате да го промените А до Б, и Б на C и C до D, и така натаму, треба да бидете во можност да се погледне на индивидуалните карактери во стринг. Вие треба да бидат способни да се промени на Z на нешто друго, А на нешто друго, на М на нешто друго, и така натаму. И така ние треба на некој начин, програмски, така да се каже, во C за да може да се промени и се погледне на поединечни букви. И ние може да го направите тоа како што следува. 

Дозволете ми да се упатат назад во CS50 ИРО. И дозволете ми да оди напред и да се создаде нова датотека дека јас ќе се јавам овој пат string0, како наш прв таков пример, точка C. И јас одам да се оди напред и го разбивам како што следи. 

Така вклучуваат cs50.h, и тогаш вклучуваат стандардни io.h, што јас сум речиси секогаш ќе да се користат во мојата програма, најмалку на почетокот. int главната празнина, а потоа и овде сум случува да се направи жици добива се стринг. И тогаш јас ќе одам да оди напред и да го направите тоа. Сакам да се оди напред и, како проверка на разумност, само да кажам, здраво, проценти и, точка-запирка, прави низа 0. Уф, она што го правам тука? О, јас не го уклучете. Значи ја научил лекцијата и дека не беше намерно. 

Значи грешка, повеќе проценти конверзии од аргументите на податоци. И ова е местото каде што, во линија 7-- Добро, така што имам, цитат unquote, тоа е низа ми printf. Јас имам знакот за процент. Но, јас сум недостасува вториот аргумент. 

Јас сум недостасува запирка, кое Јас не имаат во претходните примери. Па добра можност да се поправи уште една грешка, случајно. А сега дозволете ми да се кандидира string0, тип во Zamyla. ОК, здраво Zamyla. 

Значи, ние ја стартувате овој вид на програма неколку различни времиња сега. Но, ајде да се направи нешто малку различен тоа време. Наместо само печатење Zamyla е Целата име надвор со printf, ајде да го направиме карактер по карактер. 

Одам да се користи за телефонска линија. И јас одам да си даде променлива броење, наречен i. И јас одам да се задржи процесирањето, па долго како што е помала од должината на ови. 

Излезе, ние не да го направите ова за последен пат, дека в доаѓа со функција наречена Стирлинг. Назад во текот на денот, а и воопшто уште при спроведувањето на функции, луѓето често ќе го избере многу содржаен имиња кои вид на звук како она што го сакате, дури и покрај тоа што е недостасуваат неколку самогласки или букви. Значи Стирлинг е име на функција која потребно расправија меѓу заграда дека треба да биде променлива. И тоа само се враќа цел број, должината на стрингот. 

Значи ова за телефонска линија за алинејата 7 се случува да почне пребројување на i е еднаква на 0. Тоа се случува за зголемување јас на секој повторување со 1, како што ние сме биле прави неколку пати. Но, тоа се случува да се направи само ова се до точка кога ќе е должината на самиот стринг. 

Значи ова е начин на, во крајна линија, процесирањето во текот на карактери во низа како што е подолу. Јас ќе одам да се печати не е цела низа, но отсто в, еден лик проследено со нова линија. И тогаш јас ќе одам да оди напред, а јас треба да се каже сакам да се печати о карактер е. 

Значи, ако јас е променлива, која покажува индексот на стринг, каде што Вие сте во тоа, јас треба да бидат способни да се велат, дај ми го о карактер е. И в има свој начин на водење ова со квадратни загради. Можете едноставно да се каже името на стринг, кој во овој случај е ОК. Потоа го користите квадратни загради, кои се обично над вашата Враќање или Внесете копче на тастатурата. И тогаш ќе се стави на индексот на карактерот што сакате да печатите. Така индексот ќе биде number-- 0 или 1, или 2, или 3, или точка, точка, точка, за други. 

И ние се осигура дека тоа се случува да да биде вистинскиот број, затоа што почне пребројување на 0. И по дифолт, првиот карактер во низа е од страна на конвенцијата 0. И вториот лик е заградата 1. И третиот лик е држач 2. А вие не сакате да одите премногу До сега, но ќе не затоа што ние сме оди за зголемување јас само додека не е еднаква на должината на стрингот. И во тој момент, ова за јамка ќе престане. 

Па дозволете ми да оди напред и да се спаси оваа програма, и да ја стартувате направи низа 0. Но, јас се зезнав. Имплицитно прогласување библиотека функција Стирлинг со тип како и such-- сега, ова звучи познато. Но, тоа не printf. И тоа не е се стринг. 

Јас не се зафркнам во на ист начин тоа време. Но забележите овде долу малку надолу понатаму, вклучува насловот string.h, експлицитно се обезбеди декларација за Стирлинг. Па таму е всушност поим во таму. 

И навистина излегува има уште еден хедер датотека дека не сум користел во класата сеуште, но тоа е меѓу оние кои се достапни за вас, наречен string.h. И во таа датотека, string.h Стирлинг е декларирана. Па дозволете ми да оди напред и да освен ова, бидете низа 0-- убаво, нема пораки за грешка тоа време. 

./string0 Zamyla и Јас сум за да притиснете Enter, на која точка GetString се случува да се врати стринг, го стави во с. Тогаш тоа за телефонска линија ќе iterate повеќе карактери S е едно по едно време, и да ги испечатите еден на линија, бидејќи Ја имав таа обратна коса црта n на крајот. Па можев да се изостави дека обратна коса црта n, а потоа само да се печати Zamyla сите во иста линија, ефикасно reimplementing printf, што и не е толку корисна. Но, во овој случај, јас не го направив тоа. Јас сум, всушност печатат карактер во еден момент, еден на линија, така што ние всушност го видите ефектот. 

Но, јас треба да се истакне една работа тука. И ние ќе се вратам на ова во иднина недела. Излезе дека ова кодот е потенцијално кабриолет. 

Излегува кои се низа и некои други функции во животот не мора секогаш врати она што го очекуваме. Ние знаеме од последната класа време во оваа, кои се стринг би требало да се врати стринг. Но, што ако на корисникот видови на такви долг збор или став, или есеј дека има само не е доволно меморија во компјутерот за да одговара на тоа. 

Како, што ако нешто тргне во ред под хаубата? Тоа би можело да се случува често, но тоа може да се случи еднаш во некое време, многу ретко. И така излегува, кои се низа и функции како што го направи тоа не мора да значи секогаш се врати жици. Тие може да се вратат некои грешка вредност, некои стража вредност, така да се каже, што укажува на тоа дека нешто не е во ред. И ќе се знае само тоа од тоа што го научиле во класа сега, или ја прочита некои повеќе документација. Излегува кои се низа може да се врати на вредност наречена нула. Null е посебна вредност што ние ќе се врати во иднина недела. Но, за сега, само знам дека ако сакам да биде навистина соодветна за напредок користење добие низа, јас не треба само да го наречеме, и слепо го искористи своето враќање вредност, верувајќи дека тоа е стринг. 

Јас прво треба да се каже, Еј, почекајте една минута, само продолжи доколку тој не е еднакво на null, каде null, повторно, е само некоја посебна вредност. И тоа е единствената посебна вредност ќе се треба да се грижите за се стринг. Земете низа е или ќе да се врати стринг или нула. 

И овој фантастичен точка е еднаква знак може да знам од можеби математика кои можеби ќе привлече знак за еднаквост со линија низ него да се покаже не се еднакви. Тоа не е обично знак можете да напишете на тастатурата. И така во повеќето програмски јазици, кога сакате да се каже да не се еднакви, го користите фантастичен точка, инаку позната како страшен тресок. Така да се каже тресне еднакво, кој значи не е еднаква, логично. Тоа е исто како таму не е поголема од или еднакво на или помалку од или еднаква на тастатурата што го прави сето тоа во еден симбол. Па затоа, во минатото примери, што направи отворена заграда, а потоа ист знак, со цел да се направи поголема или, да речеме, помалку од. 

Значи она што е готова брза тука? Ова е само еден начин сега на воведување на оваа синтакса, оваа функција, процесирањето над индивидуалните карактери во стринг. И исто како и оние плоштад заграда ќе ви овозможи да се добие во нив, разгледа оние квадратни загради како вид на алудирајќи на овој основната дизајн, што во секој карактер во внатрешноста на низа е вид на кухо во некаде под капакот на моторот во меморијата на вашиот компјутер. 

Но, ајде да се направи една варијанта на ова. Излезе дека ова Програмата е точно. Така на оски CS50 за оценување код, тоа е точно сега. Особено сега, кога сум проверка за нула, оваа програма не треба никогаш да се сруши. И јас само знам дека од искуство. Но, нема ништо друго што ние навистина може да оди како што треба. Но, тоа не е многу добро дизајнирани, затоа ајде да се вратиме на основите. 

Прво, principles-- она што го прави за телефонска линија да направам? За телефонска линија не три нешта. Тоа го иницијализира некои вредност, ако тоа го побара од вас да. Се проверува состојба. А потоа по секоја повторување, по секој циклус, го наголемува некои вредност или вредности, тука. 

Па што значи тоа? Ние се иницијализира i 0. Ние се провери и бидете сигурни дека јас е помал од должината на s, што е Z-A-M-Y-L-A, така што е помалку од 6. И, навистина, 0. Стрелец е помалку од 6. 

Ние испечатите Зи од името Zamyla е. Тогаш ние прираст јас од 0 до 1. Ние тогаш се провери, е 1 помалку од должината на s? Должината на ОК е 6. Да тоа е. 

Значи ние се печати во името Zamyla е, ZA. Ние подигање I од 0, 1, 2. Ние тогаш се провери, е помалку од 2 должината на името Zamyla е. 6- така 2 е помалку од 6. Да, да испечатите сега M во име Zamyla е, третиот карактер. 

Клучот тука е дека на секоја повторување на приказната, јас сум проверка, i е помала од должината на Zamyla? Но, се фати е дека Стирлинг не е сопственост. Оние од вас кои се програмирани пред во Јава или други јазици може да се знае должината на стрингот е имот, само некои само за читање вредност. 

Во C, во овој случај, ако тоа е функција која е буквално броење на бројот на ликови во Zamyla во секое време тоа го нарекуваме функција. Секој пат кога ќе го прашуваат компјутерот да се користи Стирлинг, тоа е Гледано во Zamyla, и велејќи Z-A-M-Y-L-A, 6. И го враќа 6. Следниот пат кога ќе се јавите тоа внатре што за телефонска линија, тоа се случува да се погледне во Zamyla повторно, велат Z-А-М-Y-L-А, 6. И тоа се случува да се врати 6. Значи она што е глупаво за овој дизајн? 

Зошто ми е кодот не 5 од 5 за дизајн во моментов, така да се каже? Па, јас сум поставување на прашање непотребно. Јас го правам повеќе работи отколку што треба. 

Значи иако одговорот е точен, јас сум бара од компјутер, она што е должината на Zamyla повторно, и повторно, и повторно, и повторно? И дека одговорот е никогаш нема да се промени. Тоа секогаш ќе биде 6. 

Значи подобро решение од ова ќе биде овој следната верзија. Дозволете ми да оди напред и да го стави во посебен фајл наречен string1.c, само за да го разделат. И што излезе во за јамка, всушност можете да пријават повеќе променливи одеднаш. 

Па јас ќе одам да се задржи и и го постави на 0. Но, јас сум исто така, ќе се додадете запирка, и да каже, дај ми променлива наречена n, чија вредност е еднаква на стринг должина на ОК. И сега, ве молиме бидете мојата состојба се додека i е помал од n. 

Така на овој начин, логиката е идентична на крајот на денот. Но, јас сум сеќавајќи се на вредност 6, во овој случај. Која е должината на името Zamyla е? И јас сум тоа ставање на n. 

И јас сум уште се проверуваат состојбата во секое време. E 0 помалку од 6? Е 1 помалку од 6? Е 2 помалку од 6, и така натаму? 

Но, јас не барам компјутер повторно, и повторно, она што е должината на името Zamyla е? Која е должината на името Zamyla е? Која е должината на името на овој Zamyla е? Јас сум буквално да заборавиме дека првиот и одговори само во овој втор променлива n. Значи ова сега ќе биде не само точно, но, исто така, добро дизајниран. 

Сега, она што за стил? Сум име ми променливи многу добро, јас би рекол. Тие се супер содржаен во моментов. И тоа е сосема во ред. 

Ако имате само една стринг во програма, што би можело да се јавите тоа за низа. Ако имате само една променлива за броење во програма, што би можело да се нарече i. Ако имате должина, n е супер заеднички, како и. Но, јас не се коментира било кој од моите код. 

Јас не сум информираше reader-- без разлика дали тоа е мојот ТФ, или техничка помош, или само colleague-- што би требало што треба да се случува во оваа програма. И така да се добие добар стил, она што јас би сакал да се направи е this-- нешто како и да побара корисникот за влез. И јас може да го преработи уште еднаш ова било кој број на начини. 

Бидете сигурни дека s-- бидете сигурни стапите низа се врати стринг. А потоа и во here-- и ова е можеби најважните comment-- iterate во текот на карактери во с едно по едно време. И јас може да се користи било кој Изборот на англиски јазик тука за да се опише секој на овие делови од код. 

Забележете дека јас не се стави на коментира за секоја линија код, навистина само на интересни , оние кои има некои што значи дека би можел сакате да се направи супер јасно за некој читање мојот код. И зошто се јавувате вие ​​се низа побара корисникот за влез? Дури и тоа не е нужно сето тоа описни. Но тоа им помага раскаже приказна, бидејќи втора линија во приказната е, осигурајте се се врати стринг низа. 

И третата линија во приказната е, iterate во текот на карактери е една во време. И сега само за добра мерка, Одам да се оди напред и да додадете уште еден коментар дека само вели печатење i-тиот карактер во с. Сега, она што сум направил на крајот на денот? 

Имам додадени некои англиски зборови во форма на коментари. Симболот за коса црта црта значи, еј, компјутер тоа е за луѓе, не за вас, на компјутерот. Значи тие се игнорирани логично. Тие се само таму. 

И, навистина, CS50 IDE ги покажува како сива, како да бидат корисни, но не го копчето на програмата. Информации што сега може да се направи. Дали знаете C програмирање или не, само може да се застане назад во овој програма, и прелистаат коментари. Прашајте корисникот за влез, бидете сигурни дека се врати стринг низа, iterate во текот на ликовите во ОК еден по еден, печати карактер i-тиот карактер во s-- ти не дури и треба да се погледне на код да се разбере она што оваа програма прави. И, уште подобро, ако се погледне во оваа програма во една недела или две, или еден месец, или една година, можете исто така не треба да да се зјапа во кодот, обидувајќи се да се запамети, Што се обидував да се направи со овој код? 

Вие сте си кажа. Сте го опиша за себе, или некој колега, или ТС, или ТФ. И така ова сега ќе биде точни и добар дизајн, и конечно добар стил, како и. Па затоа, да го задржи дека во умот. 

Значи има еден друг нешто што ќе одам да го направите тука дека сега може да се открие што точно е се случува под хауба. Значи има оваа функција, во C, и други јазици, наречен изборот на улоги дека или имплицитно или експлицитно им овозможува да ги конвертирате од еден вид на податоци на друг. Ние сме биле занимаваат така до денес со жици. 

И стрингови се ликови. Но се сети од недела 0, што се карактери? Ликовите се само апстракција на врвот на numbers-- броеви, и децимални броеви се навистина само апстракција на врвот на бинарни броеви, како што го дефинира. 

Значи ликови се броеви. И броевите се ликови, само во зависност од контекстот. И излегува дека внатре на компјутерска програма, може да се определи како сакате да се погледне на битови во внатрешноста на таа програма? 

Се потсетиме од недела 0 што имавме ASCII, што е само овој код мапирање писма до броеви. И рековме, главен град е 65. Капитал Б е 66, и така натаму. 

И ќе забележите, ние во суштина имаат знаци на горниот ред тука, на пример C ќе им се јавам, знаци, а потоа ints на вториот ред. И излегува можете да ги конвертирате беспрекорно помеѓу двете, обично. И ако сакаме да се направи ова намерно, ние можеби ќе сакате да се справи со нешто како ова. 

Ние би можеле да сакате да го конвертирате големи букви за да се намали случај, или мали букви со големи букви. И излегува дека е всушност шема тука можеме да се вратиме во само еден миг. Но, ајде да погледнеме прво во еден Пример за ова прави експлицитно. 

Одам да се врати во CS50 ИРО. Одам да се создаде датотека со име на ascii 0.c. И јас одам да се оди напред и да додадете ми стандард io.h на врвот, int главната неважечки на врвот на мојата функција. И тогаш јас сум само се случува да се направи following-- за телефонска линија од i еднакви, да речеме, 65. 

И тогаш јас се случува да биде помал од 65, плус 26 букви во азбуката. Па јас ќе нека компјутер направи математика за мене таму. А потоа и во овој циклус, она што сум јас ќе ја печати? 

% C е i обратна коса црта n%. И сега сакам да го приклучиш во две вредности. Сум привремено ставен прашање означува таму да го покани на прашањето. 

Сакам да iterate од 65 па наваму за 26 букви од азбуката, печатење на секој повторување дека составен еквивалент карактер е. Со други зборови, сакам да iterate над 26 броеви печатење она што е ASCII карактер, во писмото, и она што is-- соодветниот број навистина само Пресоздавањето табелата од тоа слајд. Значи она што треба да бидат овие прашалници? 

Па, излегува дека вториот треба само да биде променлива i. Сакам да видам што како број. И средната аргумент овде, можам да му кажете на компјутерот за лекување на тоа цел број Јас како карактер, така што да го замени тука за проценти В. 

Со други зборови, ако Јас, човековите програмер, знам овие се само броеви на крајот на денот. И знам дека треба 65 карта на некои карактер. Со овој експлицитни Наѓ, со заграда, името на типот на податоците што сакате да конвертирате да, и затворена заграда, може да се каже компјутер, еј, компјутер, претворање на оваа цел број со знак. 

Па кога ќе ја извршите оваа програма по составувањето, ајде да видиме што јас се направи на ascii get-- 0. Ебам тоа, она што го направив во ред овде? Употреба на непријавена идентификатор, во ред, не намерно, но ајде да видиме ако не можеме да Причината преку ова. 

Значи линија five-- па јас не се многу далеку пред нарезници до. Во ред е. Значи линија 5 за i е еднаква 65-- гледам. Па се сеќавам дека во C, за разлика од некои јазици доколку имате пред програмирање искуство, треба да му кажете на компјутерот, за разлика од нула, што тип на променлива е тоа. 

И јас заборавив клучна фраза овде. Во согласност пет, јас сум започнале да го користат i. Но, јас не реков C она што тип на податоци што е. Па јас ќе одам да се оди тука и велат, ах, да го цел број. 

Сега ќе одам да се оди напред и да го компајлирате. Тоа фиксна тоа. ./ascii0 Внесете, тоа е вид на ладно. Не само што е супер брзо за да прашуваат компјутерот на ова прашање, наместо да го барате на фолија, го испечати по еден на линија, A е 65, Б е 66, па се down-- бидејќи јас го направи ова 26 times-- на буквите ш, кој е 90. И, всушност, малку поинтелигентен би се за мене да не се потпираат на компјутерот за да додадете 26. Јас би можеле да имаат само направено 90, како и, се додека како што јас не се направи истата грешка два пати. Сакам да одам низ z, а не само низ y. 

Значи тоа е експлицитно Наѓ. Излезе дека ова дури и не е потребно. Дозволете ми да оди напред и повторување на оваа компајлер, и повторување на ascii 0. Излегува дека C е прилично паметни. 

И printf, особено, е прилично паметни. Ако само да помине јас два пати и за местата за чување, printf ќе се реализира, О, добро, јас знаете ми даде еден integer-- некој број, како 65 или 90, или whatever. Но гледам дека ме сакаат да формат, кој број како лик. И така printf може имплицитно го дадат ИНТ на знак за вас, како и. Значи тоа не е проблем на сите. 

Но, забележи, бидејќи на овој еквивалентност ние всушност може да го направите ова, како и. Дозволете ми да оди напред и да се направи една друга верзија на this-- Ascii 1.в. И наместо процесирањето над цели броеви, навистина може да се удар вашиот ум од процесирањето над карактери. Ако знак в добива капитал, јас сакаат да одат напред и да го направите ова, се додека C е помал или еднаков во главниот град на З А на секој повторување Сакам да прираст C, можам да сега во мојот printf линија тука да речеме, проценти C е проценти i повторно, запирка В. 

И сега, можам да одам во друга насока, кастинг ликот експлицитно во цел број. Значи, повторно, зошто би го направил тоа? Тоа е малку чудно да се најде решение на смета во однос на карактери. 

Но, ако се разбере она што е се случува под хаубата, има навистина нема магија. Ти си само велејќи дека, еј, компјутерски даде ме променлива наречена C од типот char. се иницијализира на капиталот А и забележите единечен наводник прашање. 

За ликови во C, да се потсетиме од минатата недела, се користи единечен наводник. За жици, за зборови, фрази, можете да користите двојни наводници. Добро, компјутер, продолжуваат да го прават тоа, па додека карактер е помалку од или еднаква на z. И јас знам од моето ASCII табелата дека сите на овие ASCII кодови се соседни. 

Нема празнини. Па тоа е само од A до Z, одделени со еден број секоја од нив. А потоа можам да прираст знак, ако навистина го сакате. На крајот на денот, тоа е само еден број. Знам дека ова. Па јас само може да се претпостави да додадете 1 до него. 

И тогаш тоа време, јас се печати в, а потоа и составен еквивалент. И јас дури и не треба експлицитно Наѓ. Можам да ги споделите printf и компјутер дознаам нешто надвор, така што сега ако јас се кандидира направи Ascii1./ascii1, Јас се иста работа, како и. 

Бескорисни програма, though-- никој се случува да се, всушност, пишуваат софтвер со цел да дознаам, она што беше број кој мапира на А или Б, или Z? Ти си само ќе го Google или го погледнете на интернет, или да побараат на слајд, или слично. Значи, каде што го прави ова всушност се корисни? 

Па, се зборува за тоа слајд, забележително е вистински шаблон овде големи букви и мали букви, тоа не беше случајно. Забележете дека главниот град е 65. Мали на 97. И колку далеку е помал случај? 

Па 65 е колку чекори подалеку од 97? Значи 97 минус 65 е 32. Значи главен град е 65. Ако додадете 32 до тоа, ќе го добиете со мали букви. И, еквивалентно, ако ви одземе 32, да се вратите на главниот град A-- истиот со Б со малку б, големи C до малку в. 

Сите овие празнини се 32 распаѓа. Сега, ова се чини да ни овозможи да направи нешто како што е Microsoft Word, или Google Docs функција, каде што може да изберете сè и тогаш се каже, промена на сите мали букви, или промена на сите со големи букви, или промена само на првиот збор на реченицата со големи букви. ние всушност може да направи нешто како што самите. 

Дозволете ми да оди напред и да ја зачувате датотеката тука се нарекува профитираат 0.c. И да одиме напред и да разбивам програма што го прави токму тоа како што следува. Така вклучуваат CS50 библиотека. И вклучуваат стандардни I / O. 

И знам дека ова е наскоро. Па јас ќе одам да го стави во таму веќе, string.h, па имам пристап до работи како Стирлинг, а потоа int главната празнина, како и обично. И тогаш јас ќе одам да се оди напред и се добива жици се низа, само за да се добие стринг од корисникот. И тогаш јас ќе одам да дадам разумност провери. Ако стрингот не еднакви нула, тогаш тоа е безбедно да се продолжи. И она што сакам да го направам? Одам да iterate од i е еднаква на 0, и n до стринг должина на ОК. 

И јас одам да го направите ова толку долго како i е помал од n, и јас плус плус. Досега, јас сум навистина само позајмување идеи од порано. И сега јас ќе одам да се воведе една гранка. 

Значи се сетам на гребење, каде што Ги имавме сите овие вилиците на патот, и минатата недела во C. јас ќе одам да го кажам ова, ако i-тиот карактер во ОК е поголемо од или еднаква со мали букви a, and-- во Скреч што би буквално каже и, но во C да се каже симболот, ampersand-- и i-тиот карактер во ОК е помала од или еднаква на мали букви z, ајде да направиме нешто интересно. Ајде да всушност печатење на карактер без нов ред тоа е карактер во низа, i-тиот карактер во низа. 

Но, ајде да одиме напред и да одземе 32 од него. Друго, ако ликот во стринг што ние сме во потрага не е меѓу малку a и малку z, повелете и само да го испечати непроменети. Значи, ние воведовме ова загради нотација за нашите стрингови за да се добие во i-тиот карактер во низа. 

Јас додадов неколку условни логика, како Нула во минатата недела една недела, каде што Јас сум само со користење на мојот основните разбирање на она што е се случува под хауба. Е i-тиот карактер на ОК е поголема или еднаква на? Како, тоа е 97 или 98, или 99, и така натаму? 

Но, тоа е, исто така, помалку од или еднакво на вредноста на мали z? И ако е така, она што го прави оваа линија значи? 14, ова е вид на зародиш на целата идеја, профитираат на писмото на едноставно одземање 32 од него, во овој случај, затоа што знам, на кој шема, како се претставени моите броеви. Па ајде да одиме напред и да ја извршите оваа, по составувањето профитираат 0.c, и да ја стартувате профитираат 0. 

Ајде да напишете нешто како Zamyla во сите мали влезе. И сега имаме Zamyla во сите големи букви. Ајде да напишете Роб во сите мали букви. Ајде да се обидеме Џејсон во сите мали букви. И ние Продолжувам да добивам принудени капитализација. Постои мала грешка што јас вид на не го очекувале. Забележете мојата нова линија е завршуваа на иста линија како и нивните имиња, која се чувствува малку неуредна. 

Па јас ќе одам да си тука, и всушност, на крајот на оваа програма печати една линија карактер. Тоа е се. Со printf, вие не треба да се помине во променливи или кодот формат. Вие буквално може само да се печати нешто како нова линија. 

Па ајде да одиме напред и да направат профитираат 0 повторно, повторување, Zamyla. И сега тоа е малку поубава. Сега, мојот брза е на својата нова линија. Па тоа е во ред и добро. Значи тоа е добар пример. Но, јас дури и не мора да значи треба да тешко кодот на 32. Знаеш што? Можев да say-- јас никогаш не се сеќавам она што разликата е. 

Но, знам дека ако јас имаат мала буква, Јас во суштина сакаат да го извадите надвор што е растојанието помеѓу малку а и голема, затоа што ако јас се претпостави дека сите други букви се исти, кои треба да се заврши работата. Но, наместо да го направите тоа, знаеш што? Постои друг начин уште. 

Ако е тоа профитираат 1.c-- ако сум да се стави тоа во посебен фајл. ајде да се профитира 2.в како што следи. Одам да навистина се исчисти овој овде. И наместо да се дури и морале да знаат или се грижи за оние на ниско ниво имплементација детали, јас сум наместо само случува да се печати карактер, цитат unquote, проценти C, а потоа побарајте друга функција што постои дека го аргумент, кој е лик, вака. 

Излезе во C, има друг повик на функција на горниот дел, кој како што сугерира името укажува зема карактер и тоа го прави на горниот случај противвредност, а потоа се враќа printf, така што може да го приклучиш во таму. И така да го направите ова, иако, јас треба да се воведе една друга датотека. Излегува има уште една датотека што ќе се знае само од класа, или учебник, или онлајн референца, наречен C type.h. 

Значи, ако јас се додаде дека до кај мојот глава додадени фајлови, и сега повторно се собере на оваа програма, capitalize2, ./capitalize2 Enter. Ајде да напишете во Zamyla во сите мали, се уште работи на истиот. Но знаеш што? Излегува дека на горниот дел има некои други функционалност. 

И дозволете ми да се воведе оваа команда тука, вид на чудно име, но човекот за рачно. Излезе дека повеќето Линукс компјутери, како што се користење на here-- Linux оперативниот system-- имаат команда се нарекува човек, кој вели: Еј, компјутер, дај ми прирачник на компјутерот. Што сакате да се погледне во тоа рачно? 

Сакам да се погледне до функцијата повика на горниот дел, Enter. И тоа е малку криптичната за да го прочитате понекогаш. Но забележите дека сме во прирачник Линукс програмерот. И сето тоа е текст. И ќе забележите дека тука е името на функцијата тука. Излегува дека има братучед наречен да се намали, што го прави спротивното. И известување според синопсис, за да ја користите оваа функционира на страницата човек, така да се каже, се ми кажуваше дека јас треба да се вклучат в type.h. И знаев дека од праксата. 

Тука, тоа е покажувајќи ми две прототипови за функцијата, така што ако некогаш сакате да ја користите оваа Знам дека она што тие се како влез, и она што тие се врати како излез. А потоа, ако читам описот, гледам во повеќе детали во која функција го прави тоа. Но, уште поважно, ако Гледам во повратната вредност, таа вели дека вредноста врати е дека на конвертира писмо, или C, оригиналниот влез, ако конверзијата не беше можно. 

Со други зборови, на горниот дел ќе се обидам да го конвертирате писмо до големи букви. И ако е така, тоа се случува да се врати. Но, ако тоа не може да за некои reason-- Можеби тоа е веќе големи букви, можеби тоа е фантастичен точка или некои други punctuation-- тоа е само случува да се врати на оригиналниот C, што значи дека може да се направи мојот код подобро дизајниран како што следи. 

Јас не треба сите овие ебам линии на код. Сите линии што сум само истакна може се распадна во само една едноставна линија, која е this-- printf проценти в на горниот дел на заградата јас. И ова ќе биде пример за подобар дизајн. 

Зошто да се спроведе во 7 или 8 линии на код, што и да е јас само избришани, кога ќе може, наместо да пропадне сето тоа логика и донесување на одлуки во една линија, 13 сега, дека се потпира на библиотека function-- функција која доаѓа со C, но тоа го прави токму она што го сакате тоа да се направи. И, искрено, дури и ако тоа не дојде со C, може да се имплементира себе, како што видовме, со добие негативен int и да добиете позитивни int минатата недела, како и. 

Овој код сега е многу повеќе може да се чита. И, навистина, ако се движите нагоре, изгледа како многу покомпактен оваа верзија на мојата програма е. Тоа е малку врвот тешки сега, со сите овие вклучува. Но, тоа е во ред, бидејќи сега Стојам на рамениците на програмери пред мене. И кој беше кој спроведува на горниот дел на навистина ми направи услуга, слично како оној спроведува Стирлинг навистина ми направи услуга пред некое време. И така сега имаме подобар дизајн програма што ја спроведува иста логика. 

Говорејќи во Стирлинг, ајде ми да оди напред и да го направите тоа. Дозволете ми да оди напред и да се спаси оваа датотека како stirling.c. И што излезе, ние може да лупам назад уште еден слој прилично едноставно сега. Одам да се оди напред и да камшик до друга програма во главниот тука дека едноставно повторно спроведува стринг должина како што следи. Значи тука е линија на кодот кој ми добива низа од корисникот. Ние ги користите ова повторно и повторно. Дозволете ми да се даде променлива наречена n од тип int која содржи број. 

И дозволете ми да оди напред и да направете го следново логика. Додека не на n-ти карактер во ОК не се еднакви обратна коса црта 0, повелете и зголемување n. А потоа печати од printf проценти i n. Тврдам дека оваа програма тука, без да се доведат стринг должина, фигури на должината на стрингот. 

И магијата е целосно внесен во алинеја 8 тука со она што изгледа како нова синтакса, ова обратна коса црта 0 во еден наводници. Но, зошто е тоа така? Па, размислете за она што било се случува сето ова време. 

И како настрана пред да заборавам, се реализира исто така, дека во прилог на човекот страници кои доаѓаат со типичен Linux систем како CS50 IDE, сфатат дека ние, вработените се разбира, имаат, исто така, направени на веб-сајт верзија на истата таа идеја наречена reference.cs50.net, која има сите оние истите man страници, сите на истиот документација, како и мала кутија на врвот, која им овозможува да ги конвертирате сите на прилично таинствениот јазик во помалку удобно на владата, каде што ние, наставниот кадар, се качил преку и да се обиде да се поедностави некои на јазикот да работи фокусирани на идеи, а не некои од техничките. Значи имајте на ум, reference.cs50.net како уште еден ресурс, како и. 

Но, зошто не работи стринг должина во начинот на кој се предлага пред некој миг? Еве повторно име Zamyla е. И тука е името Zamyla е кухо во, како што ги прават, да се наслика слика на тоа да се биде, навистина, само низа од карактери. Но Zamyla не постои во изолација во програмата. 

Кога пишувате и да ја стартувате програмата, го користите вашиот Mac или вашиот компјутер како меморија или RAM меморија, така да се каже. И можете да замислите вашиот компјутер како што имаат многу гигабајти меморија, овие денови. И свирка значи милијарди, така милијарди бајти. 

Но, ајде да ја премотате назад во времето. И да претпоставиме дека ние сме со користење навистина стар компјутер што има само 32 бајти меморија. Можев, на мојот компјутер екранот, едноставно да се подготви ова како што следи. 

Јас едноставно може да се каже дека ми компјутер има сите на оваа меморија. И ова е како гума за меморијата, ако Се сеќаваш ли нашата слика од минатиот пат. И ако јас само се подели ова доволно пати, Тврдам дека имам 32 бајти меморија на екранот. 

Сега, во реалноста, можам само да подготви досега на овој екран тука. Па јас ќе одам да се оди напред, и само по конвенција, подготви меморија на компјутерот ми е како мрежа, а не само како една права линија. Поточно, тврдам дека сега оваа мрежа, овој 8 од 4 мрежа, само ги претставува сите 32 бајти на меморија достапна во мојот Mac, или достапни во мојот компјутер. И тие се завиткување на две линии, само бидејќи тоа се вклопува повеќе на екранот. Но, ова е првиот бајт. Ова е втор бајт. Ова е третиот бајт. 

И ова е 32-бајт. Или, ако сметаме како компјутер научник, ова е бајт 0, 1, 2, 3, 31. Значи, вие 0 до 31, ако ќе почне пребројување на 0. 

Значи, ако ние ги користиме на програмата дека повиците се низа, и да добиеме низа од човечкото како да сум го повика Zamyla, Z-А-М-Y-L-А, како во светот го прави компјутер да ги пратите на кој бајт, кое парче на меморија, припаѓа на кој стринг? Со други зборови, ако се продолжи да се тип друго име во компјутерот, вака Анди, повикувајќи се низа по втор пат, А-Н-D-јас мора да завршат во меморија на компјутерот, како и. Но како? 

Па, излегува дека под капакот на моторот, што C не кога складирање низи дека човечкиот видови во, или дека доаѓаат од некој друг извор, тоа е опишува крајот на нив со посебен character-- обратна коса црта 0, што е само еден посебен начин да се каже 80 бита по ред. 

Значи A-- ова е да се потсетиме број 97. Па така некои модел на 8 бита децималниот претставува број 97. Ова црта 0 е буквално на бројот 0, a.k.a. НУБ, N-У-L, за разлика од порано, N-У-L-L, кои ние разговаравме за. Но, за сега, само знам дека ова обратна коса црта 0 е само 80 битови по ред. 

И тоа е само оваа линија во песок, што не кажува ништо на лево му припаѓа на еден стринг, или еден тип на податок. И ништо на правото припаѓа на нешто друго. име Анди, пак, кои само визуелно се случува да се заврши на другата линија, но тоа е само естетски детали, слично е прекинат НУБ. 

Тоа е низа на карактери A-N-D-I, плус една петтина таен карактер, сите 0 бита, што само ја демаркира на крајот од името Анди, како и. И ако ние го нарекуваме добијат низа по трет пат во компјутерот за да добиете низа како Марија, М-А-Р-И-А, слично е на Марија Име на НУБ престанува со коса црта 0. 

Ова е фундаментално различно од тоа како еден компјутер ќе обично чување на цел број, или плови, или други типови на податоци, сепак, бидејќи се потсетиме, цел број е обично 32 бити, или 4 бајти, или можеби дури и 64 парчиња, или осум бајти. Но, многу примитивците во компјутер во програмскиот јазик имаат фиксен број на бајти под hood-- можеби 1, можеби 2, можеби 4, а можеби и 8. 

Но, жици, од страна на дизајнот, имаат динамичен бројот на карактери. Ти не знаеш однапред, додека видовите на човекот во Z-A-M-Y-L-A, или M-A-R-I-A, или A-N-D-I. Ти не знаеш колку пати корисникот е да се погоди тастатурата. Затоа, вие не знаете како многу ликови однапред ви се случува да треба. 

И така Ц само вид на листовите како тајна Breadcrumb под хаубата на крајот на низата. После складирање на Z-A-M-Y-L-A во меморијата, тоа, исто така, само го става еквивалент на период. На крајот на реченицата, го става 80 бита, со цел да се сетам каде Zamyla почнува и завршува. 

Значи она што е во врска, тогаш, на оваа програма? Оваа програма тука, Стирлинг, е само еден механизам за добивање на низа од страна на корисникот, алинеја 6. Алинеја 7, се декларирате променлива наречен n и го постави еднаква на 0. 

А потоа и во алинеја 8, јас едноставно побара од прашање, додека n-ти карактер прави не се еднакви ги сите 0 bits-- со други зборови, не го прави тоа еднакви оваа специјална карактер, обратна коса црта 0, што беше само тој посебен НУБ character-- одиме напред и само подигање n. 

И да го прават тоа, и да ја задржите го прават тоа, и да го прави тоа. И така, иако во минатото сме користи i, тоа е совршено во ред семантички да се користи n, ако сте само се обидува да смета тоа време намерно, и само сакаат да го нарекуваат n. Значи ова само чува поставува прашањето, е n-ти карактер на 0-ти и сите? Ако не, погледнете на следниот изглед, погледнете на следниот, погледнете на следниот, погледнете на следната. 

Но, веднаш штом ќе го видите обратна коса црта 0, ова loop-- линија 9 до 11-- запира. Да се ​​пробие на додека јамка, оставајќи внатрешноста на таа променлива n на вкупниот број на сите ликови во низата што сте ја виде, а со тоа печатење. Значи, да се обиде ова. 

Дозволете ми да оди напред и, без користење на функцијата за Стирлинг, Но, само користење на мојот домашните верзија тука се нарекува Стирлинг, дозволете ми да оди напред и да ја стартувате Стирлинг, во вид на нешто како Zamyla, што знам однапред е шест знаци. Ајде да видиме дали таа работи. Всушност, тоа е шест. Ајде да се обидеме со Роб, три карактери, три букви, како и, и така натаму. Значи, тоа е сето она што се случува на под хауба. И информации за врски, а потоа, со текот на првата недела на класа, каде што зборуваше за нешто како апстракција, што е само овој дели на идеи, или комплексност, на врвот на основните принципи. Тука, ние сме вид на гледање под хаубата на човекот, така да се каже, да дознаам, како тоа ќе се спроведува? 

И ние би можеле повторно да се спроведе тоа самите себеси. Но, ние никогаш повторно ќе повторно да се спроведе Стирлинг. Ние сме само ќе Стирлинг користат со цел да се всушност некои должина жици. 

Но, не постои магија под хауба. Ако знаете дека под хаубата, стринг е само низа од карактери. И дека низа од карактери сите може да се нумеричко однесува со држач 0, држач 1, 2 заградата, а вие знам дека на крајот од стрингот е посебен карактер, можете да дознаам како да се направи повеќето ништо во програмата, затоа што сите се сведува на е читање и пишување меморија. Тоа е, се менува и се во потрага во меморијата или да се движат работите околу во меморијата, печатење работи на екранот, и така натаму. 

Па ајде сега се користи оваа ново- разбирање на она што, всушност, жици се под хаубата, и лупам назад уште еден слој кои до сега ги имаме игнорираат целосно. Особено, во секое време ние спроведе програма, имавме оваа линија код во близина на врвот прогласување главните. И ние сме наведени int главната неважечки. 

И таа празнина во внатрешноста на загради е велејќи дека сето ова време дека главната себе не презема никакви аргументи. Секој влез кој е главен случува да се добие од страна на корисникот мора да дојде од некој друг механизам, како стапите int, или да плови, или да добијат низа, или некоја друга функција. Но, се покажа дека кога ќе се напише програма, што всушност може да се определи дека оваа програма ќе се влезови од човечкото во командната линија себе. 

Со други зборови, иако досега се работи само ./hello здраво или слични програми, сите на други програми кои ние сме биле во употреба, дека ние самите не пишувам, сме биле преземање, се чини, командната линија arguments-- работи како шминка. Да се ​​каже нешто како шминка, а потоа и вториот збор. Или ѕвекот, велиш ѕвекот, а потоа втор збор, името на датотеката. 

Или дури РМ или ЦП, како што може да сте го виделе или веќе во употреба да ги избришат или копирате датотеки. Сите тие се т.н. командната линија arguments-- дополнителни зборови во терминалот прашува. Но, до сега, ние самите не сте имале овој луксуз за преземање на влез од корисникот кога тој или таа всушност бега самата програма во командната линија. 

Но, можеме да го направат тоа повторно прогласување Главната движи напред, а не како што имаат празнина во загради, но овие два аргументи instead-- првата цел број, а вториот нешто ново, нешто што ние ќе треба да се јавите низа, нешто слично на дух на она што го видовме во Скреч како листа, но низа од стрингови, како што наскоро ќе видиме. Но, да видиме тоа со На пример, пред да разлика точно што значи тоа. 

Значи, ако јас одам во CS50 IDE тука, јас сум качил пред и изјави во датотека наречена argv0.c следната дефиниција. И ќе забележите дека единственото нешто што е различно досега е што сум смени празнина на INT argc низа argv отворена заграда, во близина заграда. И ќе забележите за сега, нема ништо во внатрешноста на овие загради. 

Нема број. И нема ли, или n, или било која друга букви. Јас сум само со користење на квадратни загради, за сега, од причини што ние ќе се назад во само еден миг. 

И сега што јас ќе одам да направите е ова. Ако argc еднаква еднаква 2-- и да се потсетиме која е еднаква на еднаквите е оператор на еднаквост споредба лево и десно за еднаквост. Тоа не е задача оператор, кој е знакот за еднакво еден, што значи копија од десно кон лево некоја вредност. 

Ако argc еднакво еднакво на 2, сакам да да речеме, printf, здраво, проценти, нова линија, а потоа приклучок in-- и тука е новиот trick-- argv заградата 1, за причини дека ние ќе се вратам во еден момент. Друго, ако argc не еднакви 2, знаеш што? Ајде само оди напред и, како и обично, печатење на Здраво светот без замена. 

Како што се чини дека ако argc, која се залага за бројот на аргументи, еднакво на 2, Јас ќе одам да се печати Здраво нешто или други. Инаку, по дифолт, јас сум случува да се печати Здраво светот. Па што значи ова? 

Па, дозволете ми да оди напред и да го спаси оваа датотека, а потоа прават argv0, а потоа ./argv0, Enter. И што вели Здраво светот. Сега, зошто е тоа така? 

Па, излегува во секое време извршување на програма во командната линија, ви се полнат во она што ние ќе генерално се јавите на аргументот за векторот. Со други зборови, автоматски компјутер, оперативен систем, се случува да се предаде на својата програма самата листа на сите зборови дека човечкиот внесе во брза, во случај да на програмерот сакате да го направите нешто со таа информација. И во овој случај, единствениот збор Јас ја внеле во конзолата е ./argv0. 

И така бројот на аргументи дека е се пренесува на мојата програма е само еден. Со други зборови, аргументот брои, инаку позната како argc тука како цел број, е само еден. Кое, се разбира, не се рамноправни. И така тоа е она што ги печати, Здраво светот. 

Но, дозволете ми да ја искористам оваа некаде. Дозволете ми да кажам, argv0. И тогаш, како за Марија? А потоа притиснете Enter. 

И ќе забележите што магично се случува тука. Сега, наместо на Здраво светот, имам го смени однесувањето на оваа програма со преземање на влез не од се стринг или некоја друга функција, но од, очигледно, моја команда себе, она што првично јас ја внеле во. И јас може да се игра оваа игра, повторно од страна на тоа се менува за да Стелиос, на пример. 

А сега гледам друго име уште. И тука, може да се каже Andi. И јас може да се каже Zamyla. И ние може да се игра оваа игра на целиот ден, само приклучување во различни вредности, толку долго како што се обезбеди точно два збора во конзолата, така што argc, мојата теза смета, е 2. 

Можам да видам тоа име вклучен во printf, по оваа состојба овде? Значи ние се чини дека сега експресивните способности за преземање на информации од друг механизам, од т.н. командната линија, наместо да се чека додека корисникот работи на програмата, а потоа него го извести користење на нешто како добие стринг. 

Па што е ова? Argc, повторно, е само цел број, бројот на words-- arguments-- дека корисникот предвидени во брза, на прозорецот на терминалот, вклучувајќи го и името на програмата. Значи, нашата ./argv0 е, ефикасно, името на програмата, или како јас ја стартувате програмата. 

Тоа се смета за еден збор. Значи argc ќе биде 1. Но, кога пишувам Стелиос, или Andi или Zamyla, или Марија, тоа значи дека бројот на аргумент е два. И така сега има два збора проследени во. 

И информации, да продолжиме оваа логика. Ако јас всушност се каже нешто како Zamyla Чан, целосно име и презиме, а со тоа поминува три аргументи во целост, сега вели стандардно повторно, затоа што, се разбира, 3 не се еднакви 2. 

И така на овој начин, морам пристап преку argv овој нов аргумент што би можеле технички наречи го сакаме. Но, по конвенција, тоа е argv и argc, соодветно. Argv, аргументот за векторот, е вид на синоним за програмирање функција во C наречен низа. 

Низа е листа на слични вредности назад, да се врати, да се врати, да се врати. Со други зборови, ако некој е во право тука во RAM меморија, на следната е веднаш до него, а веднаш до него. Тие не се сите над местото. И дека второто сценарио, каде што работи се сите над местото во меморијата, всушност може да биде моќна функција. Но, ние ќе се вратам на тоа кога ќе се зборува за познавач структури на податоци. За сега, низа е само парче од соседни меморија, секој од чии елементи се назад, да се врати, да се врати, да се врати, и, генерално, од ист тип. 

Значи, ако се размислува за, од Пред момент, што е стринг? Па, стринг, како Zamyla, Z-A-M-Y-L-A, е, технички, само низа. Тоа е низа од карактери. 

И така, ако ние навистина се подготви ова, како што не порано, како парче на меморија, излегува дека секој од овие карактери зазема бајт. А потоа, тука е тој посебен Сентинел карактер, обратна коса црта 0, или сите осум 0 битови, кои демаркира крајот на стрингот. Значи низа, што се испоставува надвор, цитирам unquote стринг, е само низа од chara-- char се вистински тип на податок. 

И сега argv, meanwhile-- ајде да се вратиме на програмата. Argv, иако можеме да видиме на зборот стринг тука, не е само по себе низа. Argv, аргументот за векторот, е низа од стрингови. 

Значи како што може да имаат низа на знаци, може да имаат повисоко ниво, низа на strings-- така, на пример, кога го напишав пред некој миг ./argv0 argv0, простор Z-А-М-Y-L-А, јас тврдеше дека argv имаше две жици во it-- ./argv0, и Z-A-M-Y-L-A. во Со други зборови, argc е 2. Зошто е тоа така? 

Па, ефикасно, што се случува на е дека секоја од овие низи е, се разбира, низа на карактери како и досега, секој од чии ликови зазема еден бајт. И не се збуни реалните 0 во името на програмата со 0, што значи дека сите 80 бита. И Zamyla, пак, се уште е Исто така, постои низа на карактери. 

Па на крајот на краиштата, тоа навистина изгледа вака под хауба. Но, argv, од страна на природата на тоа како главна работи, ми дозволува да се заврши сето ова нагоре кон, ако сакате, поголем спектар дека, ако ние нешто повеќе од поедностави што на сликата изгледа и не сосема го подготви да скала до таму, оваа низа е само на големината на 2, првиот елемент од кој содржи низа, вториот елемент на кој содржи низа. А, пак, ако вид на зумирате на секоја од тие жици, она што види под хаубата е дека секој стринг е само низа од карактери. 

Сега, исто како и жици, бевме во можност да се добие пристап на i-тиот карактер во низа користење на тој плоштад заградата нотација. Слично на тоа, со низи Генерално, ние го користите квадратни заградата нотација да се добие на било кој број на жици во низа? На пример, да ме оди напред и да го направите тоа. 

Дозволете ми да оди напред и да се создаде argv1.c, која е малку различен тоа време. Наместо проверка за argc2, Одам да наместо да го направите тоа. За int i добие 0, што е помалку од argc, јас плус плус, а потоа печати од внатрешноста на ова, проценти и, нова линија, а потоа argv заградата јас. 

Значи со други зборови, не сум се занимаваат со индивидуални ликови во моментот. Argv, како имплицирани од овие празниот плоштад протези на правото на argv името, значи argv е низа од стрингови. И argc е само int. 

Оваа линија тука, 6, е велејќи сет i еднаков на 0. Смета на целиот пат до, но не вклучувајќи ги, argc. А потоа на секој повторување, печати низа. Што стринг? 

i-тиот стринг во argv. Значи додека пред Бев со користење на средна заграда нотација да се добие во о карактер во низа, сега Јас сум со користење квадратни заградата нотација на да се добие во низа о во низа. Така, тоа е вид на еден слој погоре, концептуално. 

И така она што е уреден во врска со оваа Програмата сега, ако јас ги собере argv1, а потоа направи ./argv1, и потоа внеси во нешто како foo bar Баз, кои се трите стандардно зборови дека компјутерски научник посегнува по секое време тој или таа треба некои случаеви зборови, и притиснете Enter, секој од овие зборови, вклучувајќи го и името на програмата, која е во argv на првата локација, завршува се печатат во исто време. И ако јас го промените ова, и јас велам нешто како argv1 Zamyla Чан, ги добиете сите три од овие зборови, што е argv0, argv1, argv2, бидејќи во овој случај argc, пребројувањето на гласовите, е 3. 

Но она што е уредно е ако се разбере дека argv е само низа од стрингови, и да се разбере дека стрингот е низа од карактери, ние всушност може да го користат овој вид на квадратни заградата нотација повеќе пати да се избере низа, а потоа изберете лик во низата нуркање во подлабоко како што следи. Во овој пример, дозволете ми да оди напред и да се јавите на оваа argv2.c. И во овој случај, дозволете ми да оди напред и го стори following-- за int i добие 0, i е помал од argc, јас плус плус, како и порано. Значи со други words-- а сега ова е добивање доволно комплицирано. Тогаш јас ќе одам да се каже iterate во текот конците во argv, како коментар на себе. И тогаш јас ќе одам да имаат вгнездени за телефонска линија, која најверојатно да се направи, или се сметаат за Притоа, во нула, каде што Јас ќе одам да се каже јас сум int-- не се случува да го користите повторно, затоа што не сакаат да го следат, или вид на избрише постоечките i. 

Одам да се, наместо тоа, велат j, бидејќи тоа е мојот одат на променлива откако јас, кога јас сум само се обидува да брои едноставни броеви. За j добива 0--, а исто така, n, ќе се се строгиот должината на argv заградата јас, се додека j е помалку од m, ѕ плус плус, го направите следново. И тука е интересниот дел. 

Печатење на карактер и нова линија, приклучување на argv заградата јас, држач j. Добро, па дозволете ми да додадете некои коментари тука. Iterate во текот карактери во тековната низа, печатење ѕ-та лик во i-тиот стринг. А сега, ајде да се разгледа што значат овие коментари. 

Iterate во текот на жици во argv-- колку жици се во argv, што е низа? Argc многу, па јас сум процесирањето од i изнесува 0 до argc. Во меѓувреме, уште колку знаци се во i-тиот низа во argv? 

Па, да се добие тој одговор, Јас само да се јавите стринг должина за нега на тековниот ред јас , што е и argv заградата јас. И јас одам да ја запази привремено дека вредност на n, само за целите на кеширање, да се сеќава на него за ефикасност. И тогаш јас ќе одам да се иницијализира ѕ на 0, Продолжувам да одам толку долго како ј е помал од n, и на секоја прираст повторување j. 

И тогаш тука, по мојот коментар на линија 12, печатење на карактер, проследено со нова линија, посебно argv држач i ми дава i-тиот низа во argv-- така што првиот збор, вториот збор, третиот збор, сеедно. И тогаш ѕ нурка во подлабоко, и добива ме ѕ-та карактер на тој збор. И така, всушност, може да се третираат argv како мулти-димензионален, како две-димензионални, низа, при што секој збор вид на изглед како овој во вашиот ум е око, и секој лик е вид на составен во колона, ако тоа им помага. 

Во реалноста, кога ќе закачам оваа разлика во идните недели, тоа се случува да биде малку пософистициран од тоа. Но, што навистина може да мислам на тоа, за сега, како само овој две-димензионални низа, при што едно ниво на ИТ е за сите на жиците. А потоа, ако се нурне во подлабоко, може да се добијат на индивидуалните карактери во неа со користење на оваа нотација тука. 

Значи она што е нето ефект? Дозволете ми да оди напред и да го прават тоа argv2-- ебам. Направив грешка тука. Имплицитно прогласување на библиотека функција Стирлинг. Значи сето ова време, тоа е можеби е соодветно дека ние сме вид на завршувањето на токму каде што започна. 

Јас зезнав, имплицитно прогласување библиотека функција Стирлинг. Добро, почекајте една минута. Се сеќавам дека, особено бидејќи тоа е во право тука. Јас треба да се вклучат во string.h оваа верзија на програмата. 

Дозволете ми да оди напред и да се вклучат string.h, освен тоа, да оди напред и прекомпајлирате argv2. И сега, тука ќе одиме, бидете argv2, Enter. И покрај тоа што е малку криптичната на прв поглед, се забележи дека, навистина, она што е отпечатен е точка argv2. 

Но, ако сум тип на некои зборови по брза, како argv2 Zamyla Чан, Внесете, исто така, малку криптичната на прв поглед. Но, ако се движите врати, ./argv2 Z-A-M-Y-L-A C-H-A-N. Значи ние сме повтори во текот на секој збор. И, за возврат, ние сме повтори во текот на секој лик во еден збор. 

Сега, по сето ова, да сфатат дека постои еден друг детал ние сме вид на неа цело време. Ние само се задеваат, освен што Главните влезови може да биде? Што е со излез главната е? 

Сето ова време, ние сме биле само копирање и вметнување зборот int пред главната, и покрај тоа што може да се види на интернет, понекогаш погрешно во постарите верзии на C и компајлери, за кој велат дека празнина, или ништо на сите. Но, навистина, за верзијата на C кои ги користите, C 11, или 2011 година, се реализира дека треба да се Инт. И тоа треба да биде или неважечки или argc и argv тука. 

Но, зошто int главната? Што е тоа, всушност, се враќаат? Па, излегува сето ова време, секое време што сум напишал програма главната е секогаш враќање нешто. Но, тоа е тоа толку тајно. 

Дека нешто не е int, како линија 5 сугерира. Но, она што int? Па, тука е тоа Конвенцијата во програмирање, при што ништо да не се во ред и се е во ред, програми и функции, генерално, return-- малку counterintuitively-- 0. 0 генерално значи се е во ред. Па дури и ако мислите дека на тоа е погрешна во многу контексти, тоа, всушност, обично значи дека е добра работа 

Во меѓувреме, ако некоја програма се враќа 1, или негативни 1, или 5, или негативни 42, или било кој не-0 вредност, кои обично означува дека нешто не е во ред. Всушност, на свој Mac или PC, можеби сте всушност се гледа порака за грешка, при што вели нешто или други, грешка код негативни 42, или код на грешка 23, или нешто слично. Тој број е обично само навестување на програмерот, или на компанијата што го направија софтвер, она што не беше во ред и зошто, така што тие може да се погледне преку документацијата или код, и да дознаам што на грешка всушност значи. Тоа е генерално не е корисни за нас крајните корисници. 

Но, кога главниот враќа 0, се е во ред. И ако не се определи што главна треба да се врати, тоа ќе само автоматски 0 се врати за вас. Но, да се врати нешто друго е всушност корисно. 

Во конечната програма, дозволете ми да оди напред и да се јавите на оваа exit.c, и воведување на последниот од денешната теми, познат како код за грешка. Дозволете ми да оди напред и вклучуваат нашите запознаени датотеки до врвот, направи int главната. И овој пат, да го направиме int argc, низа argv, и со мојот загради да се имплицира дека тоа е во низа. И тогаш дозволете ми да се направи проверка на разумност. Овој пат, ако argc не 2 еднакви, тогаш знаете што? Заборави. Одам да се каже дека, еј, корисник, се водат за исчезнати по командата обратна коса црта n. 

И тогаш тоа е тоа. Сакам да излезете. Одам да превентивно, и предвреме, навистина, враќање нешто друго од бројот 1. На движење на вредноста за прв грешка која може да се случи е 1. Ако имате некои други погрешни ситуација која може да се случи, може да се каже враќање 2 или да се вратат 3, или можеби дури и негативни 1 или негативни 2. 

Овие се само излез кодови кои се, генерално, само корисна за програмер, или компанија која е превозот на софтвер. Но, фактот дека тоа е 0 не е она што е важно. Значи, ако во оваа програма, сакам да гарантира дека оваа програма, само работи ако корисникот ми дава со бројот на аргументот на две деца, името на програмата, и некои други збор, јас може да ги спроведе колку што следи, развикам на корисникот со printf изрека, недостасува командата, Враќање 1. Тоа само ќе веднаш прекинувате програмата. 

Само ако argc е еднакво на 2 ние ќе се фаќате тука, во тој момент јас ќе одам да се каже, Здраво проценти s, обратна коса црта n, argv1. Со други зборови, јас сум не оди по argv 0, која е само името на програмата. Сакам да се печати Здраво, запирка, вториот збор дека човечкиот напишале. И во овој случај на точка 13, се е добро. 

Знам дека argc е 2 логично од оваа програма. Одам да се оди напред и да се врати 0. Како настрана, имајте на ум дека ова е точно во гребење, како и. 

Логично, би можел да го направите тоа и капсулирало овие линии на код во овој друго клаузула тука. Но, тоа е вид на непотребно вовлекување мојот код. И јас сакам да се направи супер јасно е дека без разлика што, по дифолт, здраво нешто ќе се печатени, толку долго како корисник соработува. 

Така, тоа е многу честа појава за користење услов, само ако, да го фати некои погрешни ситуација, а потоа излез. И тогаш, се додека сите се Па, нема да имаат друг, но само треба да го кодот надвор од тоа, ако, поради тоа што е еквивалент на овој конкретен случај, логично. Па јас сум се враќа 0, само за да експлицитно да значи се е во ред. 

Ако јас изоставени враќање 0, што би автоматски да се претпостави за мене. Но, сега дека јас сум враќање еден во најмалку овој случај, Одам да, за добра мерка и јасност, се врати 0 во овој случај. Па сега дозволете ми да оди напред и да излезете, која е совршена segue да го напушти само. 

Но, бидете излез, и дозволете ми да оди напред и ./exit направи, Enter. И програмата викна по мене, недостасува командната линија аргумент. Добро, дозволете ми да соработуваат. 

Дозволете ми да го направи наместо ./exit, Давид, Enter. И сега што се вели, здраво Давид. А ти да не нормално ќе се види тоа. 

Но, се покажа дека има посебен начин во Linux да всушност гледаат со она излез код програма излезено. Понекогаш во графички светот како Mac OS или Windows, ти само гледаш овие броеви кога порака за грешка се појавува на екранот и на програмерот ви покажува дека бројот. Но, ако сакаме да видиме што на грешка Пораката е, ние може да го направи тоа here-- така ./exit, Enter, печатење недостасува командната линија аргумент. 

Ако јас сега го прават echo $ ?, која е смешно криптичната потрага. Но, $? Магиската инкантација во која се вели, еј, компјутер, да ми кажете што претходниот излез код програмата беше. И јас притиснете Enter. Гледам 1, бидејќи тоа е она што изјави мојата главна функција да се вратат. 

Во меѓувреме, ако го направам ./exit Давид, и притиснете Enter, гледам, здраво Давид. И ако сега го правам echo $ ?, гледам здраво 0. И така ова, всушност, ќе да бидат корисни информации во контекст на дебагерот, не е толку колку што вие, луѓе, ќе се грижи. Но, дебагерот и други програми што ќе го користите овој семестар често ќе се погледне на овој број, иако тоа е вид на скриен освен ако не се погледне за неа, за да се се утврди дали на програмата или не извршување е точно или неточно. 

И така, што нè доведува до тоа, на крајот на денот. Ние денеска почна со разгледување на дебагирање, а за возврат на курсот себе, а потоа и повеќе интересно, технички под хаубата во она што се жици, кои траат недела ние само го зеде здраво за готово, и, секако, ги зеде здраво за готово во Scratch. 

тогаш ние погледна како можеме да пристапите индивидуални ликови во серијата, а потоа повторно се на повисоко ниво се погледне на работите, гледајќи како well-- ако сакаме да се на ниво на поединец елементи во листа како структура, не можеме да го направи тоа со повеќе жици? И ние може да се со аргументи на командната линија. Но, оваа слика овде само кутии е покажана на оваа општа идеја на низа, или список, или вектор. И во зависност од контекст, сите овие зборови значи малку различни нешта. Значи во C, ние сме само ќе да се зборува за низа. И низа е парче на меморија, од кои секој е елементи се соседни, грбот, да се врати, да се врати, да се врати. 

И оние елементи се, генерално, од ист вид на податоци, карактер, карактер, карактер, карактер, или низа, низа, низа, низа, или цел број, int, int, што и да е ние се обидуваме да ги чувате. Но, на крајот на денот, ова е она што изгледа како концептуално. Ти си со земање на меморија или RAM меморија на компјутерот. И ти си го резба во идентична големина кутии, од кои сите се назад, да се врати, да се назад, за да се врати на овој начин. 

И, што е убаво за оваа идеја, како и фактот дека ние може да се изразат вредностите на овој начин со прв од нашите структури на податоци во класата, значи дека ние може да започне да ги реши проблемите со код кој дојде толку интуитивно во недела 0. Што ќе се сетите на телефонот книга пример, каде што ние се користи подели и владеј, или бинарни пребарување алгоритам, да се кваси, преку цела куп на имиња и броеви. Но, ние се претпостави, да се потсетиме, дека тоа телефон книга е веќе сортирана, дека некој друг веќе сфатиле out-- дадена листа на имиња и numbers-- како да ги alphabetize. И сега, кога во C ние, исто така, имаат способност да се постават работите, не физички во именикот но буквално во компјутерот меморија, ние ќе бидеме во можност следната недела да се воведе повторно this-- првиот од нашите структури на податоци во array-- но уште поважно, вистински компјутер Наука алгоритми имплементиран во кодот, со кои можеме да ги чувате податоци во структури како оваа, а потоа почнете да манипулира со него, и за да всушност ги реши проблемите со неа, и да се изгради на врвот на тоа, во крајна линија, програми во C, во Python, во JavaScript, доведување во прашање бази на податоци со SQL? 

И ние ќе се види дека сите овие различни идеи блокирам. Но, за сега, да се потсетиме дека домен, кој ќе претстави денес беше тоа нешто тука, и светот на криптографијата. И меѓу следниот ќе се проблеми ќе го реши е уметност на криптографијата, scrambling и декодирање информации и шифрирани и дешифрирање на текст, и под претпоставка дека на крајот што сега знам што е под хаубата така што кога ќе ги видите или примате порака како оваа, себе да го дешифрира. Сето ова и многу повеќе следниот пат. 

[Видео репродукција] 

-Mover Само што пристигнале. Одам да одат посета неговиот универзитетски професор. Да. Здраво. Тоа си ти. Чекај! Давид. Јас сум само се обидувам да дознаам што се случило со вас. Ве молиме, нешто може да помогне. Ти беше неговиот колега цимер, не ти е? Сте биле таму со него кога тој заврши проектот на CS50? 

[Музички] 

-Тоа Е CS50. 

Го сакам ова место. 

-Јадете Нагоре. Ние сме случува надвор од бизнисот. 

[END репродукција] 