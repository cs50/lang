[MUSIC SVIRA] 

DAVID J. Malan: U redu. To je CS50 i to je početak tjedna 2. A vi ćete se sjetiti da je preko u posljednjih nekoliko tjedana, mi smo bili uvođenjem računala znanost i, zauzvrat, programiranje. 

I počeli smo priču putem Blok, koji grafički jezik iz MIT Media Laba. I onda nedavno, prošli tjedan, jesmo li uvesti higher-- A niže razine jezik poznat kao C, nešto što je čisto tekstualnog. I, doista, posljednji put smo istražiti u tom kontekstu broj koncepata. 

To je, podsjetimo, bio je vrlo Prvi program smo pogledali. I ovaj program, jednostavno, ispisuje "Hello, World". No, postoji toliko činilo magija događa. Tu je ovaj #include s tim zagrade. Postoji int. Postoji (void). Postoji zagrade, vitičastim zagradama, točkom sa zarezom, i tako mnogo više. 

I tako, podsjetiti da je uveli smo Scratch tako da bismo mogli, u idealnom slučaju, vidi prošlost da sintaksa, stvari koje stvarno ne sve to intelektualno zanimljivo, ali rano je, apsolutno, malo zeznuto omotati svoje mišljenje oko sebe. I, doista, jedan od najčešćih stvari rano u programiranju klasi, pogotovo za one manje udoban, je da se frustriran i spotaknula se po određenom sintaktičkih pogreške, da ne spominjemo logičke pogreške. I tako među našim ciljevima Danas, zapravo, hoće biti da vas opremiti s nekim Tehnike rješavanja problema za koliko kako bi se bolje sami rješavaju probleme u obliku pogrešaka. A vi ćete se sjetiti, također, da je okruženje koje smo uveli Posljednji put bio pozvan CS50 IDE. Ovo je web-temeljen softver koji omogućuje programiranje u oblaku, da tako kažemo, a imajući sve svoje datoteka zajedno, kao što smo ponovno će se danas. A sjećam da smo revisited ove teme ovdje, među njima i funkcije, i petlje, i varijable i Boolean izrazi, i stanja. A zapravo malo više da mi preveo iz svijeta nule u svijet C. 

No, temeljni zgrada blokovi, da tako kažemo, su zaista uvijek isti prošlog tjedna. U stvari, mi zapravo samo imali drugačiji puzzle komad, ako hoćete. Umjesto da ljubičasta spasiti blok, mi umjesto je printf, što je ova funkcija u C koji Omogućuje ispis nešto i formatirajte ga na ekranu. Uveli smo CS50 Knjižnica, gdje vas sada imamo na raspolaganju Vam get_char, i get_int i get_string, i nekoliko drugih funkcija dobro, preko kojeg možete dobiti ulaz od korisnikove tipkovnici. I mi također uzeo pogledati stvari kao these- bool i char, i dvostruko, plutaju, int, long_long niz. A tu je još i druge vrste podataka u C 

Drugim riječima, kada se izjasniti varijabla za pohranu neku vrijednost, ili kada implementirati funkciju koji vraća neku vrijednost, možete odrediti što vrsta vrijednosti koja je. Je li to string, poput niz znakova? Je li to broj, kao što je cijeli broj? Je li to s pomičnim zarezom vrijednosti, ili slično? Tako je u C, za razliku od nule, mi zapravo počeo navesti koje sve vrste podataka smo se vraćaju ili korištenjem. 

Ali, naravno, mi također naletio neke temeljne granice računarstva. I posebno, taj jezik C, opoziv da mi je pogledati broj preljeva, stvarnost da, ako imate samo jedan konačna količina memorije ili, točnije, konačan broj bitova, samo možete računati tako visoka. I tako smo pogledali ovaj primjer ovdje pri čemu je brojač u zrakoplovu,, Zapravo, ako se radi dovoljno dugo će prelijevati i dovesti u softveru stvarni fizički potencijal pogreška. 

Također smo promatrali pluta točka nepreciznosti, stvarnost da samo s konačnim brojem bitova, da li je 32 ili 64, možete odrediti samo toliko brojeva nakon decimalne točke, nakon čega počinju da se neprecizan. Tako, na primjer, jedna trećina u Svijet je ovdje, u našem ljudskom svijetu, znamo samo beskonačan broj od 3s nakon decimalne točke. No, računalo ne može nužno predstavlja beskonačan broj brojeva ako samo dopustiti da neki konačna količina informacija. 

Dakle, ne samo da smo vas opremiti s većom snagom u smislu kako se može izraziti sebe na tipkovnica u smislu programiranja, mi također ograničen ono što zapravo može učiniti. I doista, bugovi i greške mogu proizlazi iz one vrste pitanja. I doista, neke od tema danas će biti teme kao što su ispravljanje pogrešaka i zapravo izgleda ispod haube kako stvari su uvedene prošlog tjedna su zapravo provodi tako da bolje razumjeti obje mogućnosti i ograničenja na jeziku kao što je C 

A u stvari, mi ćemo ponovno oguliti slojeve od najjednostavnijih strukture podataka, nešto što se zove niz, koji je Blok se događa nazvati "popis". To je malo razlikuje u tom kontekstu. A onda ćemo također predstaviti na jedan od Prvi od naših problema određenih područja u CS50, svijet kriptografija, umjetnost remećenje ili šifriranje podataka te da možete slati tajne poruke i dekodiranje tajnih poruka između dvije osobe, A i B. 

Dakle, prije nego što smo tranziciju u tom novom svijetu, pokušajmo vas opremiti s nekim Tehnike kojima možete eliminirati ili smanjivanje barem neke od frustracije da ste vjerojatno naišli više samo u posljednjih tjedan dana. Naime, pred vama su neki od such-- vaši prvi problemi u C, a izgledi su, Ako ste poput mene, prvi put pokušate tip iz programa, čak i ako mislite logično Program je prilično jednostavan, možda vrlo dobro udario u zid, a prevodilac neće surađivati. Napraviti ili zveket ne ide zapravo učiniti vaš ponudu. 

A zašto bi to moglo biti? Pa, neka je pogledati, možda, jednostavan program. Ja ću ići naprijed i spasiti ovo file namjerno zove buggy0.c, jer ja to znam da biti pogrešno unaprijed. Ali ne može shvatiti da ako se to je prvi ili drugi ili treći program da sam zapravo čineći sebe. Tako ću ići naprijed i upišite se, int glavni (prazninu). I onda unutar mojih vitičastim zagradama, vrlo poznati ( "Hello, svijet- Obrnuta kosa crta, n ") - i zarez. 

Ja sam spremili datoteku. Sada ću ići dolje na moj prozor terminala i tip make buggy0, jer je, opet, naziv datoteke je danas buggy0.c. Tako sam tip bi buggy0, Enter. 

I, oh, bože, prisjetiti od zadnjeg puta da nema poruka o pogrešci je dobra stvar. Dakle, nema izlaza je dobra stvar. Ali ovdje moram jasno neki broj pogrešaka. 

Dakle, prvi red izlaza nakon upisivanja bi buggy0, podsjetimo, je zveket je prilično detaljne izlaz. Ispod haube, CS50 IDE konfiguriran koristiti hrpu opcije s ovim prevodilac tako da se ne morate razmišljati o njima. I to je sve što je prva linija znači da počinje s jeka. 

Ali nakon toga, problemi početi da njihov izgled. Buggy0.c na liniji 3, karaktera 5, nalazi se velika, crvena pogreška. Što je to? Implicitno proglašenja funkcije knjižnica printf s tipa int (const char *, ...) [-Werror]. Mislim, to se vrlo brzo dobiva vrlo kompliciranih. I svakako, na prvi pogled, ne bismo očekuju vas razumjeti cjelokupnost te poruke. I tako jedna od lekcija za danas ide se pokušati uočiti uzoraka, ili slične stvari, pogrešaka možete imati naišao u prošlosti. Tako ćemo zafrkavati osim samo one riječi koje izgledaju poznato. Velika, crvena greška je jasno simbol nečega što je krivo. 

implicitno izjavljujući Biblioteka funkcija printf. Pa čak i ako ja ne razumijem što implicitno izjavljuje funkcije knjižnica znači, problem sigurno odnosi se na printf nekako. A izvor tog problema ima veze s ga progla. 

Progla funkcija spomena po prvi put. I koristili smo terminologiju prošlog tjedna proglašavanja funkciju je prototip, ili s jedne linije na vrhu svoje vlastite datoteke ili u tzv datoteku zaglavlja. A u ono što datoteku učinili smo rekli prošlog tjedna da printf je citat, citat, izjavio? U onome što je datoteka njegov prototip? 

Dakle, ako se sjećate, vrlo prva stvar koju sam upisali, gotovo svaki program prošle time-- i slučajno trenutak prije počela upisivanjem myself-- je to jedan here-- hash-- #include <stio-- za ulaz / output-- točka h I doista, ako sam sada spremiti datoteku, idem ići naprijed i razbistriti zaslon, što možete učiniti tako da upišete Vedro, ili možete zadržati kontrolu L, samo očistiti prozor terminala samo kako bi se uklonili neki nered. 

Ja ću ići naprijed i re-tipa make buggy0, Enter. I voila, još uvijek se vidi da dugo naredba iz jeka, ali nema poruka o pogrešci ovaj put. I doista, ako ja to ./buggy0, baš kao i zadnji put, gdje je točka znači to imenik, Slash samo znači, Ovdje dolazi naziv programa i to ime je programa buggy0, Ulaz: "Zdravo, svijet." 

Sada, kako možete imati sakupljen ovo rješenje bez nužno prepoznavanje što više riječi kao što sam učinio, svakako, ima učinio toliko godina? Pa, ostvariti po prvi problem set, mi vam predstaviti na naredbe da CS50 vlastitog osoblja je napisao pod nazivom help50. I doista, C radi specifikaciju problem postaviti kako koristiti ovu značajku. 

Ali help50 je u suštini program koji CS50 osoblje napisao da vam omogućuje da pokrenete naredba ili pokrenuti program, a ako ne razumije njegova izlaz, da prođe svoj izlaz na help50, nakon čega softver da osoblje toku je napisao će izgledati na izlazu vašeg programa redak po redak, znak po znak. I ako mi, osoblje, prepoznati Poruka o pogrešci je što imate, ćemo pokušati isprovocirati sa nekim retorička pitanja, s nekim savjetima, slično kao TF ili CA ili sebe će učiniti osobno u uredovno vrijeme. 

Dakle, izgleda da help50 ako ne nužno prepoznati problem. No, nemojte se oslanjati na njega previše kao štaka. Dakako, pokušati razumjeti njegove izlaz, a zatim naučiti iz nje tako da je samo jednom ili dva puta vi ikada pokrenuti help50 za određenu pogreške poruka. Nakon toga, trebali biste biti u Bolje se opremljen shvatiti što je to zapravo. 

Idemo napraviti jedan drugi ovdje. Pusti me naprijed, a drugi file ćemo nazvati ovu buggy1.c. I u ovoj datoteci sam ide na deliberately-- ali se pretvarati da ne znam razumjeti ono grešku sam napravio. 

Ja ću ići naprijed i to učinimo #include, jer sam saznao moj lekciju od maloprije. Int main (void), kao i prije. I onda se ovdje idem učiniti String s - get_string. I sjećam od posljednjeg puta kada to znači, hej, računalo, daj mi varijablu, nazovite to je i bi tip tu varijablu string tako da mogu spremiti jednu ili više riječi u njemu. 

A onda se na desnoj strana znaka jednakosti je get_string, što je Funkcija u CS50 knjižnici koji radi upravo to. Ona dobiva funkciju, a zatim Ruke ga s desna na lijevo. Dakle, ovaj znak jednakosti ne znači "Jednako" kao što smo mogli misliti u matematici. To znači zadatak s desna na lijevo. Dakle, to znači, uzeti string iz korisnik i pohraniti unutar sekunde. 

Sada ćemo ga koristiti. Pusti me naprijed i sada kao drugi linija, neka mi ići naprijed i reći "bok" - nije "svijet", ali "hello,% S- koji je naš rezervirano mjesto, zarez s, koja je naša varijabla, a onda je točka-zarez. Dakle, ako nisam zeznuo previše ovdje, ovo izgleda kao ispravan kod. 

I moji instinkti sad su ga sastaviti. Datoteka naziva buggy1.c. Tako ću učiniti make buggy1, Enter. I prokleto-to, ako ne postoji čak i više grešaka nego prije. Mislim, ima još poruke o pogreškama to bi Čini od stvarnih linija u ovom programu. 

Ali takeaway je ovdje, čak i ako ste osvaja s dva ili tri ili Još četiri poruka o pogrešci, usredotočiti uvijek na vrlo Prvi od tih poruka. Gledajući na top-najviše jedan, pomicanje natrag kao treba. Dakle, ovdje sam upisao make buggy1. Evo da se zveket izlaz kao što se očekivalo. 

I ovdje je prva crvena greška. Korištenje neprijavljenog identifikatora string, jesam mislim standarde u? Tako je standard u je zapravo nešto drugo. To se odnosi na korisnikov tipkovnica, u suštini. 

Ali to nije ono što sam mislio. Mislio sam niz, a ja mislio get_string. Dakle, što je to što sam zaboravio to učiniti ovaj put? Ono što nedostaje u ovo doba? Imam svoj #include, tako da imam pristup printf. 

Ali što nisam pristup samo još? Pa, baš kao i zadnji put, Moram reći prevodilac Jeka što se ove funkcije su. Get_string ne dolazi sa C i posebno, to ne dolazi u zaglavlje datoteke,. Ona umjesto toga dolazi u nešto osoblje napisao, koji je drugačiji datoteka ime, ali podesno zove. 

Tako jednostavno dodajući da jednom redu od code-- opozivu od zadnjeg puta da kad zveket radi, to će gledati na moj broj vrha do dna, s lijeva na desno. Bit će to primijetiti, oh, što želite. Pusti me i da, gdje god je to na poslužitelju, kopirati i zalijepiti ga, u suštini, na vrh vlastite datoteke tako da je u ovom trenutku u priči, linija 1, ostatak programa može, doista, koristiti bilo koji od funkcija u njemu, među njima get_string. Zato ću ignorirati Ostatak od tih pogrešaka, Zato što sam, doista, sumnjaju da je samo prvi je zapravo važno. I ja ću ići naprijed i ponovno, nakon spremanja moj dosje bi buggy1. I voila, to je posao. A ako ja ./buggy1 i upišite u za Primjerice, Zamyla, sada će dobiti zdravo, Zamyla, umjesto zdravo, svijet. 

U redu. Tako su ponijeti sa sobom ovdje onda su se, jedan, pokušati skupljati što više možete od samo poruka o pogrešci, u potrazi na neke od prepoznatljivih riječi. Blokiranje da koristite help50 po problem postaviti specifikaciju. No, zabrana koja je, također, uvijek traže na gornjem pogreške samo barem u početku, da se vidi što informacije to bi zapravo prinos. No, ispostavilo se da postoji čak i više funkcionalnosti izgrađen u CS50 knjižnice pomoći ti rano u semestru i rano u programiranju shvatiti što se događa u krivu. Tako ćemo napraviti još jedan primjer. Idem nazvati ovu buggy2, koja je, opet će biti manjkav iz od vrata, do dizajna. 

I ja ću ići naprijed i to #include. A onda ću to učiniti int glavni (prazninu). A onda ću to učiniti for petlje. Za (int i _ 0. i manji od ili jednak 10. i ++, a zatim u vitičastim zagradama, idem ispisati samo hashtag simbol ovdje a nova linija karakter. 

Dakle, moje namjere s tim Program je vrlo jednostavno iteraciju 10 puta i na svakoj iteraciji tog procesa svaki put kroz ciklus, ispisati #oznake, s oznakom #, s oznakom #. Jedan po retku, jer sam imaju novu liniju tamo. I podsjetiti da je za petlje, na zadnjem week-- a vi ćete dobiti više upoznati sa sintaksom koristeći ga s praksom Prije long-- to mi daje varijabla Zvao sam i postavlja se na 0. 

To povećava i na svaka iteracija za 1. Tako sam ide na 1 do 2 do 3. I onda ovo stanje u sredini između točkom sa zarezom dobiva ček na svakoj iteraciji napraviti sigurni da smo još uvijek u dometu. Dakle, želim ponoviti 10 puta, pa sam ima vrsta vrlo intuitivno samo stavi 10 kao moja gornja granica postoji. 

Pa ipak, kad sam pokrenuti ovaj, nakon što je sastavljanju ga s make buggy2-- i to ne sastaviti redu. Pa ja nemam sintaktička pogreška ovaj put. Pusti me naprijed sada i pokrenuti buggy2, Enter. A sada pomaknite se prema gore. I neka mi se poveća veličina prozora. 

Čini mi se da ima 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Dakle, tu je 11 #oznake, iako Jasno sam stavio 10 unutar te petlje. Sada, neki od vas bi mogli vidjeti odmah što je pogreška, jer, doista, ovaj nije jako teško greška napraviti. No, to je vrlo često napravio vrlo rano. 

Ono što želim naglasiti, međutim, je, kako bih mogao to shvatiti? Pa, ispada da CS50 Knjižnica dolazi s ne samo get_string i get_int i get_float i druge funkcije. Također dolazi s posebnom funkcijom zove eprintf, ili greška printf. I to postoji isključivo kako bi to malo jednostavnije za vas kada pogrešaka koda samo ispisati poruku o grešci na zaslonu i znam gdje je došao iz. 

Tako, na primjer, jedna stvar koju bi mogao učiniti ovdje s ova funkcija učinimo eprintf, a onda ću ići naprijed i reći da je sada% i, kosih crta, br. I ja ću se priključiti vrijednosti i. I do vrha, jer je to je u CS50 knjižnici Idem samo naprijed a uključuju tako da imam pristup ovoj mogućnosti. Ali neka se uzeti u obzir ono linija 9 je trebao biti događaj. Idem obrisati ovaj na kraju. To nema nikakve veze s mojim glavna cilja. Ali eprintf, greška printf, samo se misli da mi daju neke dijagnostičke informacije. Kad sam trčanje moj program, želim vidjeti na zaslonu privremeno i samo da se razumijemo što se događa. 

I doista, na svakom iteracija ovdje linije 9 Želim vidjeti, što je vrijednost od i? Što je vrijednost od i? Što je vrijednost od i? I, nadam se, samo sam trebao vidi tu poruku, takođe, 10 puta. 

Pa neka mi ići naprijed i rekompiliranje moj program, što moram učiniti u bilo koje vrijeme I napraviti promjenu. ./buggy2. I now-- OK. Postoji puno više događa. Pa neka mi dođite u još veći prozor. 

I vidjet ćete da je svaki od izrazi s oznakom # dalje ispisuje. No, između svake od njih je sada ovo dijagnostički izlaz oblikovati na sljedeći način. Ime moj program, ovdje je buggy2. Ime datoteke je buggy2.c. Broj linija od kojih ovo je tiskana je linija 9. A onda na desnoj strani koji je Poruka o pogrešci da sam očekivao. 

A što je lijepo o tome da sad ja ne moram nužno računati u glavi ono što moj program radi. Vidim da se na prva iteracija sam 0, zatim 1, zatim 2, a zatim 3, te 4, tada 5, zatim 6, a zatim 7, pa 8, pa 9, a zatim 10. Pa čekaj malo. Što se ovdje događa? Ja još uvijek čini se da se računaju u skladu s namjenom do 10. 

Ali odakle početi? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10, Tako 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11. prst indikativna problema. Izgleda da sam broji netočno u mom petlji. Umjesto da ide 10 iteracija, Ja sam početak na 0, Ja sam završio na i do 10. No, budući da, kao i računalo, Počinjem brojati na 0, I treba brojati do do, ali ne i preko, 10. 

I tako je popraviti, i na kraju shvatio ovdje je jedna od dvije stvari. Ja bi vrlo jednostavno reći brojati do manje od 10. Tako 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, koji je, doista, ispravan, iako to zvuči malo krivo. Ili sam mogao učiniti manje ili jednako do 9, sve dok sam start na 0. Ili, ako ti stvarno ne sviđa, ti može računati kroz 10, ali start na 1. Ali opet, to jednostavno nije to uobičajeno. U programming-- iako ne toliko u Scratch-- ali u programiranju u C i drugim jezicima, kao što su JavaScript i Python i drugima, to je Samo vrlo uobičajena za naša rasprava o binarnom samo početi odbrojavanje u Najmanji broj možete, što je 0. U redu. Dakle, to je eprintf. I opet, sad kad sam shvatio moj problem, a ja ću se vratiti na 0 kroz manje od 10, idem otići i izbrisati eprintf. 

To ne bi trebao biti tamo kad sam brod moj broj ili poslati moj broj ili ga pokazati bilo kome drugome. To je zapravo samo znači da se privremeno. Ali sada sam fiksni to Poseban problem kao dobro. 

Pa, neka je učiniti još jedan primjer ovdje da ću ščepati kako slijedi. Ja ću ići naprijed i #include. 50 $ I ja ću ići naprijed i #include. 

I ja ću spasiti Na ovu sliku kao buggy3.c. I ja ću ići naprijed i proglasiti int glavni (prazninu). I onda unutar tamo Ja ću učiniti int i _ - Želim provesti program s get_negative_int. To nije funkcija koja postoji još. Tako ćemo provesti to u samo jednom trenutku. No, idemo vidjeti zašto to je buggy na prvom prolazu. I jednom sam stečen int od korisnika, Samo ću ispisati% i negativna broj, kosih crta, n, zarez, ja. Drugim riječima, sve što želimo ovaj program za napraviti se dobiti negativan int od korisnik, a zatim ispisati da je takva i takva je negativna int. 

Sada mi treba implementirati tu funkciju. Pa kasnije u mojoj datoteci, ja ću ići naprijed i proglasiti funkciju pod nazivom get_negative_int (void) - a mi ćemo vratiti na ono da je linija opet znači u moment-- int n; do-- učiniti following-- printf n :. A onda ću to učiniti n - get_int, i to učiniti dok je n veći od 0. A onda se vrati n ;. 

Dakle, postoji mnogo događa u to, ali nitko od kojih nismo pogledajte prošli tjedan, barem nakratko. Dakle, na liniji 10, ovdje sam proglašen Funkcija se zove get_negative_int, a ja sam stavio (void), u zagrade, razlog je to ne uzima ulaz. Ja ne prolazi ništa na ovu funkciju. Ja sam samo dobivanje nešto natrag od nje. 

A što se nadam da vratiti cijeli broj. Nema vrsta podataka u C zove negative_int. To je samo int, tako to ide da se na nas kako bi bili sigurni da je vrijednost koja je zapravo Vraćeno je ne samo int ali je također negativan. 

On line 12 Ja sam proglašenja varijablu zove n i što je tipa int. A onda u redu 13 do 18 sam raditi nešto dok je nešto istinito. Idem naprijed i tisak n je, debelog crijeva, te razmak kao poticaj za korisnika. 

Ja sam tada zove get_int i spremanje svoje tzv povratnu vrijednost u tom promjenjivom n. Ali ja ću nastaviti raditi to dok je n veći od 0 ° C. Drugim riječima, ako korisnik mi daje int a taj broj je veći od 0, ergo, pozitivna, idem samo držati reprompting korisniku, držati reprompting, prisiljavajući ih da se surađivati ​​i dati mi negativan int. 

A nakon nje je zapravo negative-- Pretpostavljam korisniku konačno vrste -50, onda je ovo while petlja se više ne vrijedi zato -50 nije veći od 0 ° C. Tako smo pobjeći iz toga petlje logično i vratiti n. 

No, postoji još jedna što moram učiniti. A ja jednostavno to učiniti od kopiranja i lijepljenja jedna linija koda na vrhu datoteke. Moram naučiti zveket, ili obećanje da jeka, izričito da ću, dapače, ići i provesti ova funkcija get_negative_int. To samo može biti niža u datoteci. Opet, podsjetiti da jeka čita stvari vrha do dna, s lijeva na desno, tako da ne mogu pozvati funkciju ako jeka ne zna da će postojati. 

Sada, nažalost, ovaj program, kao što neki od vas možda primijetili, već je lud. Dopustite mi ići naprijed i učiniti buggy3. Ona sastavlja, tako da je moj problem je sada ne pogreška u sintaksa, poput tekstualne pogreške, to je zapravo će biti logičan greška da imam namjerno napravio kao priliku za korak kroz ono što se događa. 

Idem samo naprijed sad i pokrenuti buggy3. I ja ću otići naprijed i ne surađuju. Idem mu dati broj 1. To se nije svidjelo, pa to me opet upita. 

Kako oko 2? 3? 50? Nitko od onih koji rade. Kako o -50? A program izgleda kao da rade. 

Dopustite mi da to probati još jednom. Pokušat ću -1, čini se da rade. Pokušat ću -2, izgleda kao da rade. Pokušat ću 0. Huh, to je netočno. Sada smo se malo pedantan ovdje. No, to je, doista, u slučaju da 0 nije ni pozitivan, ni negativan. I tako je činjenica da je moj program rekavši da 0 je negativan cijeli broj, to nije tehnički ispravna. 

Sada, zašto se to radi? Pa, to bi moglo biti očito. I, doista, program je trebao biti prilično jednostavan tako da imamo nešto za istraživanje. 

Ali neka je uvesti treću ispravljanje pogrešaka Tehnika se ovdje nazivaju debug50. Dakle, ovo je program da smo upravo stvorili ove godine pod nazivom debug50 koji će vam omogućiti koristiti ono što se zove ugrađeni grafički debugger u CS50 IDE. I debugger je samo program koji Općenito omogućuje pokrenuti program ali korak po korak po korak, linija po redak po redak, pauziranje, poking okolo, gleda na varijabli, tako da program ne samo puhati prošlosti vas i brzo ispisati nešto ili ne ispisati nešto. To vam daje priliku, na ljudska brzina, u interakciji s njom. 

I da to učinite, jednostavno učinite sljedeće. Nakon sastavljanja koda, što sam već učinio, buggy3, ići naprijed i pokrenuti debug50 ./buggy. Toliko kao help50 ima li pokrenuti help50 a zatim naredbu, debug50 ima li pokrenuti debug50 i zatim naziv naredbe. 

Sada gledajte što se događa na zaslonu, Na desnoj strani posebno. Kad sam udario Run, sve od Nagli ova desna ploča otvara na zaslonu. I tu je mnogo događa na na prvi pogled. No, tu nije previše više brinuti o još. 

To pokazuje mi sve što se događa u mojoj programa sada i preko njih Tipke do vrha je tada dopuštajući mi da korak kroz moj broj u konačnici, korak po korak po korak. Ali ne još. Obavijest što se događa. Na moj prozor terminala Ja sam se zatraži n. I ja ću ići naprijed i surađuju ovaj put i unesite -1. I mada je malo zagonetno, -1 je negativan cijeli broj, kao što se očekivalo. 

I onda dijete izašao s Status 0 GDBserver izlaska. GDB, GNU Debugger, je naziv od temeljne softvera koji implementira ovaj program za ispravljanje pogrešaka. No, sve to zapravo znači, za ispravljanje pogrešaka ode jer je moj program za otkaz i sve je dobro. Ako želim da zaista ispravljanje moj program, Moram preventivno reći debug50, gdje želim početi koračni kroz moj kod? 

A možda je najjednostavniji način za to je kao što slijedi. Ako sam lebdjeti iznad oluk mog urednika ovdje tako da zapravo samo u sidebar ovdje lijevo od broja linije, Uočite da ako sam samo kliknite Jednom sam stavio malu crvenu točku. A da se malo crvena točka, kao znak stop, znači, hej, debug50, izvršenje stanka mog koda tamo kad sam pokrenuti ovaj program. 

Tako ćemo to učiniti. Dopustite mi ići naprijed i pokrenuti svoj program opet s debug50 ./buggy3, Enter. A sada, obavijesti, nešto drugačije nije dogodilo. Nisam se zatraži još u svojoj terminalnoj prozoru za bilo što, jer ja nemam stečen još tamo u svom programu. Uočite da na liniji 8 koji je sada označen, a tu je malo strelica lijevi izreka, koju je zastao ovdje. Ova linija koda, linija 8, još nije izvršen. 

A što je zanima, ako pogledam ovamo na desnoj strani, primijetiti da je i lokalna varijabla, lokalni u smislu da je u trenutnoj funkciji. A njegova vrijednost, očito po defaultu, i vrsta povoljno, 0. Ali nisam tip 0. To se događa samo da bude njegova Zadana vrijednost u ovom trenutku. 

Pa neka mi ići naprijed i to sada. Pusti me naprijed i na gornji upravo ovdje, ja sam ići naprijed i kliknite ovaj prvi simbol koji znači korak više, što znači nemojte preskočiti , ali korak po toj liniji koda, njezina izvršenja na putu. 

A sada, primijetiti, moj brz je upravo promijenila. Zašto je to? Rekao sam debug50, pokrenuti ovu liniju koda. Što to linija koda učiniti? Traži me int. U REDU. Pusti me da surađuju. Pusti me naprijed sada i unesite -1, Enter. A sada primijetiti što se promijenilo. Na desnoj strani, moja lokalna varijabla i označen kao -1 sada. I to je još uvijek tipa int. 

I napomena, također, moja takozvana pozvati stog, gdje sam pauzu? Mi ćemo govoriti više o ovaj u budućnosti. Ali poziv stog samo na ono što funkcije su trenutno u pokretu. Upravo sada je samo glavni. I upravo sada jedina lokalna promjenjiva je i sa vrijednošću 1. 

I kad sam konačno korak preko te linije ovdje, s tom istom ikonom na vrhu desno, -1 Je negativan cijeli broj. Sada je pauziranje tijekom tog kovrčavom braće. Recimo neka to učini svojim stvar. I korak po toj liniji, i voila. 

Dakle, nije sve što je strašno rasvijetliti još, ali to nije neka mi pauza I razmisliti logički što ovaj program radi. No, to nije bio pogrešan slučaj. Neka je to opet na sljedeći način. 

Idem ostaviti da Kontrolna točka na liniji 8, s crvenom točkom. Idem repriza debug50. To automatski je zastao ovdje. No, ovaj put, umjesto koračni preko ove linije, neka mi zapravo ide unutar get_negative_int i shvatiti, zašto je to prihvaćanje 0 kao valjan odgovor? 

Dakle, umjesto da kliknete korak preko. Idem samo naprijed i kliknite korak u. I primijetiti da je linija 8 to je Sada je istaknuo sada odjednom postaje linija 17. 

Sada, to ne znači da je za pronalaženje pogrešaka je preskočena linije 14 i 15 i 16. To je samo nema ništa da vam pokazati tamo. Oni su samo progla varijabli, A tu je riječ učiniti a zatim otvorena vitičasta zagrada. Jedina funkcionalna linija koja je sočan stvarno je ovaj ovdje, 17. A to je gdje imamo Zastao automatski. 

Pa printf ( "n.is:") ;, tako koja još nije dogodilo. Dakle idemo naprijed i kliknite korak Over. Sada mi je brz, doista, mijenja u ( "n"). Sada get_int, ja ne idem gnjaviti zakoračiti u, jer je to funkcija bila izradio CS50 u knjižnici. To je vjerojatno točno. 

Tako ću ići naprijed i vrsta surađivati ​​tako da je davanje int, ali ne i negativna int. Pa neka mi ići naprijed i udario 0. I što se sada događa ovdje kad sam se dolje na liniji 21? Nisam opet ponovljena. Ne čini se da se zaglavi u toj petlji. Drugim riječima, ova žuta Bar ne zadržati ide okolo, i oko i okolo. 

Sada, zašto je to tako? Pa, n, što je N upravo sada? Ja mogu gledati na lokalnoj varijable u ispravljanje pogrešaka. nje 0. U redu, što je bilo moje stanje? 

20-- linija 20 je, dobro, 0 je veći od 0 ° C. To nije istina. 0 nije veći od 0. I tako sam izbio iz ovoga. 

I to je razlog zašto on line 21, ako sam zapravo i dalje, Idem se vratiti 0, čak iako sam trebao odbiti 0 što zapravo nije bio negativan. Pa sad, ne znam stvarno ni brigu o ispravljanje pogrešaka. Got to, ne trebaju znam što još se događa. 

Tako ću ići naprijed i jednostavno kliknite gumb za reprodukciju, i neka ovo završiti. Sada sam shvatio da je moj bug je očito na liniji 20. To je moja logička pogreška. 

I ono što želim učiniti da se to promijeni? Ako je problem je u tome što ja nisam uhvatiti 0, to je samo logička pogreška. I ja mogu reći, dok je n veći ili jednak 0, držati i opet je navelo korisniku. 

Dakle, opet, jednostavno pogreška, možda čak i očito kad si me vidio pisati prije samo nekoliko minuta. Ali takeaway ovdje je da se uz ispravljanje 50, i ispravljanje pogrešaka Softver općenitije, Imate li ovaj novi pronašao snage na hodati kroz svoj vlastiti kod, izgleda putem tog desnoj ploči ono varijable vrijednosti. Tako da to ne mora nužno morati koristiti nešto kao da eprintf ispisati te vrijednosti. Vi zapravo možete ih vidjeti vizualno na ekranu. 

Sada, iza toga, to je vrijedno napomenuti da postoji još jedna tehnika koja je zapravo super čest. A možda se pitate zašto je to malo tip ovdje je sjedio na pozornici. Tako da je to tehnika, općenito poznat kao gumene patke za ispravljanje pogrešaka, što zapravo je samo dokaz tome koji se često kada programera su pisanje koda, oni nisu nužno suradnju s drugima, ili rade u zajedničkom okruženju. 

Oni su na neki način kod kuće. Možda je kasno u noć. Pokušavaju slici iz nekog buga u svom kodu. I oni jednostavno ne vide. 

I nema cimer. Nema TF. Nema CA okolo. Svi oni imaju na polici je ovaj mali gumeni ljubak. 

I tako gumena patka za ispravljanje pogrešaka samo je ovaj poziv misliti na nešto što je blesav jer to kao pravi stvorenje, a zapravo prošetati kodu usmeno na ovaj neživog objekta. Tako, na primjer, ako ovo je moj primjer here-- a podsjećaju da je ranije problem je bio u tome, ako sam izbrisati taj prvi redak koda, i ja ići naprijed i učiniti lud 0 opet, sjetiti da sam to poruke o pogreškama ovdje. Tako je ideja ovdje, smiješan iako sam osjećaju u ovom trenutku to je javno, je da je greška. 

OK, moj problem je u tome što imam implicitno proglasio funkciju knjižnica. I to biblioteka funkcija printf. Declare-- OK, proglasiti podsjeća me prototipa. 

To znači da je potrebno da se zapravo reci prevodilac unaprijed što funkcija izgleda. Pričekaj minutu. Nisam imao standardnu ​​io.h. Hvala vam puno. 

Dakle, samo ovaj proces of-- vas ne moraju zapravo imaju patku. No, ta ideja o hodanja sebe kroz svoj vlastiti kod tako da čak i čuti sebe, tako da ostvariti propuste u svoj vlastiti primjedbe, općenito ideja. 

I, možda više logično, ne tako puno s tom jednom, ali više uključeni Primjer smo upravo učinili u buggy 3.c, možda prošetati se kroz njega kako slijedi. Dakle, sve u redu, gumeni ljubak, DDB, ako hoćete. Ovdje imamo u svojoj glavnoj funkciji, Zovem dobili negativan int. 

I ja sam uzimajući vrijednost povratka. Ja sam spremiti na lijevoj strani na liniji 8 u varijablu nazvao sam. U redu, ali čekaj, kako je kako dobiti tu vrijednost? Pusti me, pogledajte funkciju u skladu 12. 

U skladu 12, moramo dobiti negativne int. Ne poduzimati nikakve ulaza, ne vraća int, OK. Izjavljujem on line 14 varijabla n. To će pohraniti cijeli broj. To je ono što želim. 

Dakle, učinite nešto od sljedećeg, a n is-- neka mi poništiti ono što je popravak sam već napravio. Dakle, dok je n veći od 0, ispisati n je, u redu. A onda zvati se int pohranjena u n. A onda provjeriti da li je n 0, n not-- tu je. Dakle, opet, ne potreban stvarni patka. No, samo se u šetnji Vaš broj kao intelektualni vježbe često će vam pomoći shvatiti što se događa, za razliku od samo radi nešto ovako, bulji u ekran, a ne govori se kroz ona koja iskreno nije gotovo kao djelotvorna tehnika. Tako da ste ga, A broj različitih tehnika za stvarno ispravljanje pogrešaka kod i prigovora, od kojih su svi bi trebao biti alat u svom alat tako da niste kasno u noć, pogotovo, ti si u blagovaonom dvorane, ili u radno vrijeme, lupanje glavom o zid, pokušavajući riješiti neki problem. Shvatite da postoje softverske alate. Postoje gumena patkica alata. I tu je cijeli osoblje podržavaju čekanja pružiti ruku. 

Tako sada, riječ o problemu setovi, i na ono što smo vam u nadi dobiti od njih, i kako idemo o ocjenjivanju. Po toku je nastavni plan i program, CS50 je problematična seta se procjenjuju na četiri osnovne osi, tako da da speak-- opseg, točnost, projektiranje, i stil. I opseg upravo odnosi na to koliko u kom ste ugriza off? Koliko problema ste pokušali? Koja razina napora ste manifestira? 

Ispravnost je li program rada kao to je trebao po CS50 specifikaciji kada dati određene inpute ili neki izlazi vraća? Dizajn je najviše subjektivno od njih. I to je onaj koji će uzeti najduže za naučiti a najduže poučavati u utoliko što se svodi na, koliko dobro napisana je tvoj broj? 

To je jedna stvar da se samo ispisati ispravan izlazi ili se vratiti prave vrijednosti. Ali to radiš kao učinkovitije moguće? To radiš podjelu i osvojiti ili binarna Traženje kao što ćemo uskoro vidjeti da smo učinili prije dva tjedna s telefonskog imenika? Postoje bolji načini da se riješi Problem nego što trenutno imamo ovdje? To je prilika za bolji dizajn. 

I onda style-- kako prilično je tvoj broj? Primijetit ćete da sam prilično posebno o uvlačenje moj broj, i da se moje varijable razumno ime. n, a kratko je dobro ime za broj, ja za brojanje cijeli broj, a za niz. I mi možemo imati više varijabla imena stilu. Stil je samo koliko je dobra vaša šifra izgleda? A kako čitati je to? 

A tijekom vremena, što je vaš TAS i TFS će učiniti u tijeku je pružiti vam da vrsta kvalitativne povratne informacije tako da ćete dobiti bolje na tim različitim aspektima. I u smislu kako smo procijeniti svaki od tih osi, to je obično sa vrlo malo kante, tako da, u pravilu, dobiti osjećaj koliko dobro radite. I doista, ako primite rezultat na bilo koji od tih axes-- ispravnost, dizajn i stil especially-- taj broj općenito će biti između 1 i 5 ° C. I doslovno, ako ste uzimajući 3 je na početku semestra, ovo je jako dobra stvar. To znači da postoji još prostora za poboljšanja, koje će se nadati u uzimanje klase po prvi put. Postoji nadamo se neki malo strop na koje ste težiti postizanju. I tako sve 3 je na najraniji komada, ako nije neki 2-a i 4-a, je, doista, dobra stvar. To je dobro u dometu, dobro u očekivanjima. 

A ako vam je um je utrka, pričekajte minute, tri od pet. To je stvarno 6 od 10. To je 60%. Bože moj, to je F. 

Nije. To nije, u stvari, da. Umjesto toga, to je prilika za poboljšanje tijekom semestra. A ako ste uzimajući neke Poors, to su prilika iskoristiti radnog vremena, svakako sekcija i drugih resursa. 

Najbolje je prilika, stvarno, biti ponosan na koliko daleko ste doći tijekom semestra. Dakle, ne shvaćaju, ako ništa Inače, tri je dobro. I to vam prostora za rast tijekom vremena. 

Kako ti osi ponderirani, realno si će provesti većinu svog vremena uzimajući stvari na poslu, a kamoli pravilno. I tako ispravnost sklon ponderiraju se najviše, kao i sa ovo multiplikativni faktor tri. Dizajn je također važno, ali nešto što ne mora nužno provesti sve one sati pokušavajući da se stvari samo na posao. 

I tako to je ponderirana malo više olako. A onda je stil ponderirana najmanje. Iako to nije ni manje važna temelja, to je samo, možda, najjednostavnija stvar za napraviti pravo, oponašajući WE primjere učiniti u predavanju i odjeljku, sa stvarima vrlo lijepa razvedena, a komentirao, i tako dalje je među najlakše stvari koje treba učiniti i dobiti pravo. Dakle, kao takav, ostvariti da oni su točke koji su relativno lako shvatiti. 

A sada riječ o učinimo, akademskog poštenja. Dakle, po naravno a nastavni plan i program, vidjet ćete da naravno ima dosta Malo jezik oko toga. I naravno uzima pitanje akademska iskrenost sasvim ozbiljno. 

Imamo razliku, za bolje ili za lošije, da su poslali svake godine više studenti za disciplinski postupak od većine bilo koje druge Naravno da sam svjestan. To nije nužno ukazuje na činjenicu da CS studenti, ili CS50 učenika, su ništa manje iskren od vaših kolega. Ali realnost da u ovom svijet, elektroničkim putem, samo mi imaju tehnološke sredstva za otkrivanje ove. 

Važno je da nam za pravičnost po razredu da mi to prepoznati i povećati pitanje kada vidimo stvari. I samo slikati sliku, i stvarno kako bi se nešto kao što je ovaj sudoper u, To su brojevi studenti u proteklih 10 godina koji su bili uključeni u neki takva pitanja akademskog poštenja, s nekim 32 studenata od jeseni 2015., što jest da mi ne uzimaju stvar vrlo ozbiljno. I, na kraju, ti brojevi sastaviti, Nedavno, oko 3%, 4%, ili tako klase. 

Tako je za super većini učenika Čini se da su linije jasne. Ali nemojte držati to u smeta, naročito kasno noću kad se bori sa neko rješenje na skup problema, da postoje mehanizmi za sebe uzimajući bolje podrška nego što bi mogli mislim, čak i na tom satu. Shvatite da kad dobijemo student podnesci, prelazimo usporediti svaki podnesak ove godine protiv svakog podnošenja prošle godine, protiv svakog podnošenja iz 2007. godine, a budući da je, gledajući, kao i, broj repozitorija online, forumima, radilištima. I ovo spomenuti, Stvarno, sve radi od prikaza, da ako netko drugi može pronaći na internetu, sigurno, tako da možemo naravno. Ali, stvarno, duh tečaja svodi toj klauzuli u nastavnom planu. To je uistinu jednostavno, biti razumna. 

A ako smo morali razraditi na koji sa samo malo više jezika, shvatiti da je bit svega djelo koje ste nam poslali na ovaj tečaj Treba biti svoj vlastiti. Ali unutar toga, tu su svakako prilike i ohrabrenje, i pedagoško vrijednost u okretanju others-- mene, TFS, CAS, u TAS, a drugi u razredu, za podršku, a kamoli prijatelje i cimeri koji su proučavali CS i programiranje prije. I tako postoji dodatak za to. A opće pravilo je učinimo, kada molba za pomoć, možete pokazati svoju šifru drugima, ali vam ne mogu vidjeti svoje. Pa čak i ako ste na radno vrijeme, ili u D dvorani ili negdje drugdje radi na nekom komadu skupa, rade uz prijatelja, koji je je potpuno u redu, u Kraj je dana svoga rada konačnici bi trebao pripadati svaki od vas pojedinačno, a ne biti neki zajednički napor, osim za konačni projekt u kojem to je dozvoljeno i potiču. 

Shvatite da ako ste bori s nečim i vaš prijatelj upravo događa da bude bolje u ovome onda se, ili bolje na taj problem od tebe, ili malo dalje naprijed od tebe, to je potpuno razumna za uključivanje za svog prijatelja i reći, hej, Imate li nešto protiv gleda na moj broj ovdje, pomaže mi uočiti ono što je moj problem? I, nadam se, u Interes pedagoške vrijednosti taj prijatelj, ne samo kažu, oh, to učiniti, ali umjesto toga, što ti nedostaje na liniji 6, ili nešto slično? Ali rješenje nije za prijatelja pored vas reći, oh, dobro, evo, neka mi povući ovo gore, i pokazati svoje rješenje za vas. Tako da je linija. Vam pokazati svoj kôd drugi, ali ne smijete vidjeti njihov, u skladu s drugim Ograničenja u toku je nastavni plan i program. 

Dakle, ne imajte na umu ove Takozvani žaljenje klauzula U toku je nastavni plan i program, kao i, da ako počine neko djelo koje nije razumno, već bi ga pozornost glava toku je u roku od 72 sata, naravno može izreći lokalne sankcije koje mogu uključivati ​​nezadovoljavajući ili negativnu ocjenu za rad podnosi. No, naravno, neće se glede važno za daljnje disciplinske mjere, osim u slučaju ponovljenih djela. Drugim riječima, ako ništa napraviti neke glupo, pogotovo kasno navečer, odluka da se sljedećeg jutra ili dva dana kasnije, što se probuditi i shvatiti, Što sam mislio? Što učiniti u CS50 imaju izlaz za pričvršćivanje taj problem i posjedovanje do njega, kako bismo Tamo ćete sresti na pola puta i nositi uz to u roku koji je i obrazovne i vrijedan za tebe, ali još uvijek kaznenu na neki način. A sada, da se rub off, to. 

[VIDEO PLAYBACK] 

[MUSIC SVIRA] 

[END PLAYBACK] DAVID J. Malan: U redu, mi smo natrag. A sada ćemo pogledati jedan od Prvi od naših stvarnom svijetu domene u CS50, umjetnost kriptografije, umijeće slanja i primanja tajna poruka, šifrirana Poruke ako će, koji se može dešifrirati samo ako imate neki ključni sastojak da pošiljatelj ima također. Tako da motivira to ćemo se Pogled na ovu stvar ovdje, što je Primjer za Tajna dekoder prsten koji mogu se koristiti kako bi se shvatiti kakva tajna poruka zapravo je. Naime, još u dan u osnovnoj školi, ako ikad poslao tajne poruke neki prijatelj ili neka simpatija u razredu, možda ste mislili si biti pametan po na svom komadu mijenjanje papira, slično, A do B i B do C i C na D, i tako dalje. Ali, da su zapravo šifriranje Vaše informacije, čak i ako je to bio malo trivijalan, nije bilo da je teško da nastavnici shvatiti, dobro, ako se samo promijeniti B na A i C na B, što zapravo shvatiti što je poruka bila, ali ti su bili u šifriranje podataka. 

Samo si to rade Jednostavno, baš kao Ralphie ovdje u poznatom film koji igra prilično mnogo oglas nauseum svake zime. [VIDEO PLAYBACK] -Be Je poznato da sve što Ralph Parker je ovime imenovan član Mala Orphan Annie Secret Circle i ima pravo na sve počasti i koristi u toj proceduri. 

-Signed, Little Orphan Annie, counter-potpisali Pierre Andre, tintom. Priznanja i koristi, Već u dobi od devet. 

[VIČE] -Ajde. Idemo se s njim. Ne treba sve to jazz o krijumčarima i gusarima. 

-Listen Sutra navečer za završna avantura crne gusarskom brodu. Sada je vrijeme za Annie je tajna poruka za vas članovi Tajnog Kruga. Zapamtite, djeco, samo članove Annie Tajna krug može dekodirati Annie je tajnu poruku. 

Zapamtite, Annie ovisi o vama. Postavite svoje igle B2. Ovo je poruka. 12, 11-- 

-Ja Sam u, moj prvi tajni sastanak. 

-14, 11, 18, 16. 

-Pierre Je u velikoj govornom večeras. Mogao bih reći da je večeras a Poruka je stvarno važno. 

-3, 25, to je poruka od Annie sama. Zapamtite, ne govori nikome. 

-90 Sekundi kasnije, ja sam u samo prostorija u kući u kojoj je dječak od devet mogao sjediti u privatnost i dekodiranje. Aha, B! Otišao sam do sljedećeg, E. 

Prva riječ je biti. S, to dolazi sada lakše, U, 25-- 

Oh, hajde, Ralphie, moram ići! 

-I'll Se desno dolje, mama! Gee čudo! 

T, O, svakako to-- biti siguran na što? Što je Little Orphan Annie pokušava reći? Svakako što? 

-Ralphie, Andy je dobio Idi, molim vas izaći? 

-Sve U redu, mama! Odmah ću se! 

-Bio Sam sve bliže sada. Napetost je bila strašna. Što je to bilo? Sudbina planeta može držati u ravnoteži. 

-Ralphie! Andy moram ići! 

-I'll Se odmah, za Boga miloga! 

-Almost Tamo, moji prsti letjeli, moj um bio je čelik zamka, svaka pora vibrirao. Bilo je gotovo jasno, da, da, da. 

-Be Obavezno popijte ovaltine. Ovaltine? Bijedan reklamu? Kurvin sin. [END PLAYBACK] DAVID J. Malan: OK, koji je bio vrlo dug put uvođenja kriptografija, i ovaltine. U stvari, iz ovog starog oglasa ovdje, zašto je ovaltine tako dobar? To je koncentrirana ekstrakcija zrela ječma slad, Pure kremasti kravlje mlijeko, a posebno pripremljen kakao zajedno s prirodnim fosfatidi i vitaminima. Nadalje je utvrđeno s Dodatni vitamini B i D, mljac. A ipak možete ga dobiti, očito, na Amazon, kao što smo učinili ovdje. 

No, motivacija ovdje bio uvesti kriptografija, posebno vrsta kriptografije poznat kao tajnim ključem kriptografije. I kao što ime sugerira, cijela sigurnost tajnim ključem kripto sustav, ako hoćete, metodologija za samo remećenje informacija između dvoje ljudi, je li to samo pošiljatelj i samo primatelj znati tajnu key-- neke vrijednosti, neke Tajna fraza, neki tajni broj, koji omogućuje im da oba šifriranje i dešifriranje podataka. I kriptografija, zaista, samo je to iz tjedna 0. 

To je problem tamo gdje ulaze, kao stvarni poruci na engleskom jeziku ili što god jezik da ti želite poslati nekome u razredu, ili preko interneta. Tu je neki izlaz, što se događa biti kodiranih poruka koja vas Želite primatelj primiti. A čak i ako je netko u Srednji ga prima previše, da ih ne želite nužno biti u mogućnosti to dešifrirati, zbog toga unutrašnjost crne kutije, ili algoritam, neki mehanizam, neki korak po korak Upute, za uzimanje ulaz i to pretvorbom u izlaz, u nadamo se na siguran način. 

A, u stvari, ima neke vokabular u ovom svijetu kako slijedi. Običan tekst je riječ A računalni znanstvenik koristiti za opisivanje unos Poruka, kao i na engleskom ili bilo kojem jeziku koji je zapravo želite poslati na neki drugi ljudi. A onda je šifrirana je jagma na šifrirane ili kodiran, njegove verzije. 

No, postoji jedan drugi sastojak ovdje. Postoji još jedan ulaz za Tajni ključ kriptografija. I to je sam ključ, koji je, u pravilu, kao što ćemo vidjeti, jedan broj ili slovo, ili riječ, bez obzira algoritam to je zapravo očekuje. 

I kako dešifrirati podatke? Kako ga dešifrirati? Pa, samo preokrenuti izlaza i ulaza. 

Drugim riječima, kada netko prima vaš šifrirana poruka, on ili ona jednostavno mora znati da isti ključ. Oni su primili šifrirana. I priključivanjem njih dvoje Ulazi u kripto sustav, algoritam, ova crna kutija, kako trebao doći izvorni otvoreni tekst. I tako je to vrlo visoka razina pogled na ono što kriptografija je zapravo sve o. 

Tako ćemo doći. Idemo sada pogledati ispod sjenilo za nešto uzimamo zdravo za gotovo za prošli tjedan, a za to sesije here-- string. Niz na kraju dan je samo niz znakova. 

To bi moglo biti zdravo svijet, ili Pozdrav Zamyla, ili bilo što drugo. No, što to znači za se niz znakova? U stvari, CS50 knjižnica pruža nam vrstu podataka pod nazivom niz. 

Ali zapravo ne postoji takva stvar kao znakovni niz u C To stvarno je samo slijed lik, lik, lik, karakter, leđa, na leđa, na natrag, natrag, natrag unutra memorije računala ili RAM. A mi ćemo gledati dublje u da je u Budućnost kada gledamo na samom sjećanju, i korištenja, a prijetnje koje su uključene. 

Ali neka se uzeti u obzir niz Zamyla. Tako je samo ime ljudski ovdje Zamyla, da je slijed znakova, Z-A-M-Y-L-A. A sada pretpostavimo da je ime Zamyla-a se pohranjuju unutar računala program. 

Pa, to stoji da je razlog da bismo trebali moći gledati na one likove pojedinačno. Pa Samo ću izvući nešto okvir oko Zamyla ime ovdje. A što je to slučaj u C da kada vas imaju niz, kao što Zamyla-- i možda taj se niz vratila iz poput funkcije get niz, zapravo možete manipulirati to znak po znak. 

Sada, ovo je tijesnoj za razgovor pri ruci, jer u kriptografiji ako želite promijeniti A do B i B do C i C na D, i tako dalje, morate biti u mogućnosti gledati na pojedine likove u nizu. Morate biti u mogućnosti promijeniti Z na nešto drugo, A na nešto drugo, M se nešto drugo, i tako dalje. I tako trebamo način, programski, tako govoriti, u C da bi mogli promijeniti i pogled na pojedinim slovima. A to možemo učiniti na sljedeći način. 

Pusti me da krenemo natrag u CS50 IDE. I neka mi samo naprijed i stvoriti novu datoteku da ću pozvati ovaj put string0, kao prvi takav primjer, točka c. I ja ću ići naprijed i bič ga na sljedeći način. 

Tako su CS50.h i onda su standardne io.h, što sam gotovo uvijek ide se koristi u mojim programima, barem u početku. int glavni prazninu, a zatim u tu sam učiniti konce dobiva dobiti niz. A onda ću ići naprijed i učiniti. Želim ići naprijed i, kao provjera razum, samo reci, zdravo, posto je, -zarez, čini niz 0. Uh, što sam ovdje? Oh, nisam ga priključite. Tako naučena lekcija, koje Nije bilo namjerno. 

Dakle, greška, više posto pretvorbi od argumenata podataka. A to je, kada je u linija 7-- redu, tako da imam, citat citat, to je moj string printf. Imam posto znak. Ali ja sam nedostaje drugi argument. 

Ja nedostaje zarez S, koji Ja sam se u prethodnim primjerima. Dakle, dobra prilika za popravak još jedna pogreška, slučajno. I sad neka mi pokrenuti string0, upišite u Zamyla. OK, zdravo Zamyla. 

Stoga smo pokrenuti ovu vrstu programa nekoliko različitih puta sada. Ali neka je učiniti nešto Malo drugačije ovaj put. Umjesto da samo tiskanje Zamyla-a Cijeli naziv s printf, Učinimo to znak po znak. 

Idem na sustav za petlju. A ja ću osobno dati brojanje varijabla, nazvao sam. I ja ću zadržati ponavljanjem, tako Sve dok je i manje od duljine s. 

Ispostavilo se, nismo učiniti posljednji put, da c dolazi s Funkcija se zove Stirling. Natrag u dan, te općenito uvijek pri provedbi funkcija, ljudi često će odabrati vrlo , dat imena koja vrsta zvuka kao što želite, iako je nedostaje nekoliko samoglasnika ili slova. Dakle, Stirling je naziv funkcije koje traje rasprava između zagrade koja bi trebala biti niz. I to samo vraća cijeli broj, duljina toga niza. 

Dakle, ovo za petlju na liniji 7 ide za početak brojanja na sam jednak 0. To će se povećavati ja na svakoj iteraciji za 1, što smo radili nekoliko puta. Ali to će učiniti samo to sve do točke kad sam je duljina od samog niza. 

Dakle, ovo je način, u konačnici, iterating preko likova u nizu kako jest slijedi. Idem isprintati nije Cijeli niz, ali posto c, jedan lik nakon čega slijedi novi red. A onda ću ići naprijed i moram reći da želite ispisati ith karakter s. 

Dakle, ako i je varijabla koja označava indeks niza, gdje vi ste u njoj, moram biti u stanju kažem, daj mi-ti karakter s. I c ima način rada ovo s uglatim zagradama. Jednostavno reci naziv niz, koji je u ovom slučaju s. Tada koristite uglate zagrade, koje su obično samo iznad povratka ili Ulaz tipku na tipkovnici. I onda se stavi indeksa znak koji želite ispisati. Tako je indeks će biti number-- 0, ili 1, ili 2, ili 3, ili točka, točka, točka, neki drugi broj. 

I mi bi se osiguralo da će to biti pravi broj, jer sam početi računajući na 0. I po defaultu, prvi znak u nizu je po konvenciji 0. I drugi lik je nosač 1. I treći lik je nosač 2. A vi ne želite ići previše daleko, ali nećemo jer smo će se samo povećavati sam dok ne dođe jednaka duljine niza. I u tom trenutku, ovo za petlje će se zaustaviti. 

Pa neka mi ići naprijed i spasiti ovu Program i pokretanje napraviti niz 0. Ali ja zeznuo. Implicitno proglašenja funkcije knjižnica Stirling s tipom takav i such-- sada, ovo zvuči poznato. Ali to nije printf. I to ne dobiti niz. 

Nisam zeznuo u na isti način kao ovaj put. No, malo primijetiti ovdje dolje nadalje, uključuju zaglavlje string.h, izričito osigurati Izjava za Stirling. Tako da je zapravo trag tamo. 

I doista ispada postoji još jedan zaglavlje datoteke da nismo koristili u razredu, ali to je Među onima koji su dostupni vama, zove string.h. I u toj datoteci, string.h je Stirling proglašen. Pa neka mi ići naprijed i spasi to, napraviti niz 0-- lijepo, nema poruke o pogreškama i ovaj put. 

./string0 Zamyla i Ja sam o hit Enter, na kojem trenutku getstring ide da se vrati string, stavi ga u s. Onda je za petlju će ponoviti preko tvrtke S likovi jedan po jedan, i ispisati ih jedan po retku, jer Imao sam tu kosih crta n na kraju. Tako sam mogao izostaviti tu kosu crtu n, i onda samo ispisati Zamyla sve u istoj liniji, učinkovito reimplementing printf, što nije sve što je korisno. No, u ovom slučaju, nisam to učinio. Ja sam zapravo ispisuju jedan lik u isto vrijeme, jedan po retku, tako da smo zapravo vidjeli učinak. 

Ali moram napomenuti jednu stvar ovdje. A mi ćemo se vratiti to u budućem tjednu. Ispada da je ovaj kod je potencijalno lud. 

Ispada koje se niz i neke druge funkcije u životu ne moraju nužno uvijek povratak što ste očekivali. Znamo iz klase prošle Vrijeme u tome da je mogao Niz je trebalo da se vrati niz. No, što ako korisnik upiše takvu duga riječ, ili stav ili esej da postoji samo nije dovoljno memorije u računalu da stane. 

Kao, što ako nešto pođe krivo ispod haube? Nije se moglo dogoditi često, ali to bi se moglo dogoditi nakon s vremena na vrijeme, vrlo rijetko. I tako ispada koje se niz i funkcije kao što su to učinili ne nužno uvijek vraćaju konce. Oni mogu vratiti neku vrijednost pogreške, neki stražar vrijednost takoreći, to pokazuje da je nešto nije u redu. A ti bi samo znam iz što ga je naučio u klasi danas, ili što je pročitao malo više dokumentacije. Ispada koje se niz može vratiti vrijednost zove null. Null je posebna vrijednost da ćemo vratiti se u budućem tjednu. No, za sada, samo znam da ako želim da se stvarno pravi u napredovanju pomoću get niz, ja ne bi smjela zvati, i slijepo koristiti svoje povratnu vrijednost, vjerujući da je to niz. 

Prvo da kažem, hej, čekaj malo, samo postupiti ukoliko nije jednak null, gdje je null, opet, samo neka posebna vrijednost. I to je jedina posebna vrijednost koju morate brinuti o za get niza. Dobiti string ili ide da se vrati niz ili null. 

A to uskličnik znak jednakosti možda znate iz možda sat matematike da bi moglo privući znak jednakosti s linija kroz nju ukazati nisu jednaki. To nije obično znak možete upisati na tipkovnici. I tako je u većini programskih jezika, kada želite reći ne jednaki, Koristite uskličnik, inače poznat kao prasak. Kažeš bang jednaka, što znači ne jednak, logično. To je isto kao ne postoji veći od ili jednaka ili manja od ili jednaka tipku na tipkovnici da to sve u jednom simbolu. Dakle, to je razlog zašto, u posljednjih primjera, jesi otvoren nosač, a zatim znak jednakosti, kako bi se učiniti veći ili, recimo, manje od. 

Zato što je takeaway ovdje? To je jednostavno način na koji sad Uvođenjem ove sintakse, ova značajka, iterating preko pojedinca znakova u nizu. I baš kao i one trga nosači omogućuju da se u njih, uzeti u obzir one uglate zagrade kao vrsta aludirati na to temeljni dizajn, pri čemu je svaki karakter unutar niza je vrsta uokvireno negdje ispod sjenilo u memoriju računala. 

Ali neka je napraviti varijantu ovoga. Ispada da je ovaj Program je ispravan. Dakle, po CS50-a osi za vrednovanje kod, to je sada točno. Pogotovo sada kada sam provjeravati null, ovaj program nikada ne bi trebao srušiti. A ja samo znam da iz iskustva. Ali nema ništa drugo da mi stvarno ne možete pogriješiti ovdje. No, to nije vrlo dobro osmišljen, zato idemo natrag na osnove. 

Prvo, principles-- Što for petlje učiniti? For petlja se tri stvari. Ona pokreće neki vrijednosti, ako ga pitati. Ona provjerava stanje. I onda nakon svakog iteracija, nakon svakog ciklusa, to koracima neki vrijednost ili vrijednosti, ovdje. 

Dakle, što to znači? Mi inicijalizirati sam 0. Mi smo provjeriti i provjerite da li je i manje od duljina s, što je Z-A-M-Y-L-A, tako što je manje od 6. I, doista, 0 manje od 6. 

Mi ispisati Z od Zamyla ime. Onda smo povećavati I od 0 do 1. Zatim smo provjeriti je jedan manje od duljine s? Duljina s je 6. Da je. 

Tako smo ispisali u Zamyla ime, ZA. Možemo povećavati ja od 0 do 1, u 2. Zatim smo provjerili, 2 manje od duljina Zamyla ime. 6 pa 2 je manje od 6. Da, idemo ispisati sad M u Ime Zamyla-a, treći lik. 

Ključ je u tome da se na svaki iteracija priče, ja sam provjeru, je i manja od duljine Zamyla? No, kvaka je da Stirling nije svojstvo. Oni od vas koji su programirani Prije nego u Javi ili drugim jezicima možda znati duljinu niza je imovine, samo su neke samo za čitanje vrijednost. 

U C, u ovom slučaju, ako je to funkcija koja je doslovno brojenjem likovi u Zamyla svaki put zovemo tu funkciju. Svaki put kada pitati računalo za korištenje Stirling, to je uzimanje pogled na Zamyla, govoreći Z-A-M-Y-L-A, 6. I to se vraća 6. Sljedeći put kad poziv je iznutra da je za petlje, to će pogledati Zamyla Ponovno, recimo Z-A-M-Y-L-a, 6. I to će se vratiti 6. Zato što je glupo o ovom dizajnu? 

Zašto je moj broj nije 5 od 5 za dizajn upravo sada, da se tako izrazim? Pa, ja tražim pitanje nepotrebno. Radim više posla nego što je potrebno. 

Dakle, iako je odgovor je točan, ja sam traži računalo, što je duljina Zamyla opet i opet, i opet, i opet? I to je odgovor nikada neće promijeniti. To je uvijek će biti 6. 

Pa bolje rješenje od toga bio bi to sljedeća verzija. Pusti me naprijed i stavi ga u zasebna datoteka zove string1.c, samo da bi se odvojili. I ispada u za petlje, možete zapravo proglasiti više varijabli odjednom. 

Tako ću zadržati ja i postaviti ga na 0. Ali ja također idem dodati zarez, i reći: daj mi varijablu nazvanu n, čija vrijednost jednaka duljina niza s. A sada, molim vas provjerite moje stanje tako dugo dok je i manje od n. 

Tako da na taj način, logika je identična krajem dana. Ali ja sam prisjećajući se vrijednost 6, u ovom slučaju. Koja je duljina Zamyla ime? I ja sam ga staviti na n. 

A ja sam još uvijek provjerava svaki put je stanje. 0 manje od 6? Je li jedan manje od 6? Iznosi 2 manje od 6, i tako dalje? 

Ali ja ne tražim računalo opet, i opet, što je duljina Zamyla ime? Što je duljina Zamyla ime? Što je dužina ove Zamyla ime? Ja sam doslovno imajući na umu da prva i jedini odgovor u ovom drugom varijablu n. Dakle, ovo će sada biti ne samo točno, ali i dobro osmišljen. 

Sada, što je stil? Ja sam dobio ime moje varijable prilično dobro, rekao bih. Oni su super kratak sada. I to je sasvim u redu. 

Ako imate samo jedan niz u programu, možda i nazvati to je za niz. Ako imate samo jednu varijablu za brojanje u programu, možda i to nazvati i. Ako imate duljinu, n super je uobičajeno, kao dobro. Ali nisam komentirao bilo koji od mojih koda. 

Nisam obavijestio reader-- da li je to moj TF ili TA, ili samo colleague-- ono što je trebalo koji se događa u ovom programu. I tako da se dobar stil, ono što želite učiniti je učinimo nešto kao i pitati korisnika za ulaz. A mogao sam prepisati to bilo koji broj načina. 

Pobrinite S- bi bili sigurni get Niz vratio niz. A onda u here-- i to je možda najvažniji comment-- mijenjajte više likova u S jedne u isto vrijeme. I ja sam mogao koristiti bilo Izbor engleskom jeziku Ovdje se opisuju svaku tih komade koda. 

Uočite da nisam stavio komentar na svaku liniju koda, zapravo samo na zanimljiv one, one koje imaju neki smisao, da bi želite napraviti super jasno da je netko čitajući moj broj. I zašto zovete dobiti string pitati korisnika za ulaz? Čak i da je netko nije nužno sve to opisno. No, to pomaže ispričati priču, jer je Drugi redak u priči je, pazite dobili niz vratio niz. 

I treći redak u priči je, ponoviti više likova u S jedne u isto vrijeme. A sada samo za dobru mjeru, Ja ću ići naprijed i dodati još jedan komentar da je upravo kaže za ispis i-lik s. Sada, ono što sam učinio na kraju dana? 

Ja sam dodao neki engleski riječi u obliku komentara. Simbol slash slash znači, hej, Računalo je to za čovjeka, nije za tebe, računalo. Dakle, oni su ignorirali logično. Oni su samo tamo. 

I doista, CS50 IDE ih prikazuje kao sivo, kao korisni, ali ne i ključ programu. Obavijest što sada možete učiniti. Da li znate C programiranje ili ne, može samo stajati natrag na ovo programa i obrano komentare. Pitaj korisnika za ulaz, provjerite je li dobili niz vratio niz, ponoviti više likova u sekundi jedan po jedan, ispisati karakter i-lik u S- vi ne imaju čak i pogledati koda razumjeti ono što ovaj program radi. I, još bolje, ako sami izgledaju U ovom programu u tjedan ili dva, ili mjesec ili godinu, vi nemate zuriti u kodu, pokušavajući se sjetiti, ono što sam pokušava učiniti s ovim kodom? 

Vi ste rekli sami. Vi ste ga opisali za sebe, ili neki kolega ili TA, ili TF. I tako će to sada biti ispravan i dobar dizajn, i na kraju dobar stil, kao dobro. Dakle, ne imajte to na umu. 

Dakle, postoji jedna druga što ću učiniti ovdje da se sada mogu otkriti točno što je događa ispod haube. Dakle, tu je ova značajka u C i drugim jezicima, zove typecasting da ili implicitno ili eksplicitno omogućuje vam da pretvoriti od jedne vrste podataka u drugu. Mi smo bili bave tako koliko je danas sa žicama. 

A žice su likovi. Ali sjećam iz tjedna 0, što su likovi? Likovi su samo apstrakcija na vrhu numbers-- decimalnih brojeva, i decimalni brojevi su zapravo samo apstrakcija na vrhu binarnih brojeva, kao što smo to definirano. 

Dakle, likovi su brojevi. I brojevi su likovi, samo ovisno o kontekstu. I ispada da je unutra računalnog programa, Možete li navesti kako želite da izgleda na bitova unutar tog programa? 

Podsjetimo iz tjedna 0 koje smo imali Ascii, što je samo ovaj kod mapiranja slova u brojeve. A mi smo, kapital A je 65. Capital B je 66, i tako dalje. 

I napomena, mi u suštini ima znakova na prvi red ovdje, kao što bi ih C nazvati, znakova, a zatim Ints u drugom redu. I ispada da možete pretvoriti neprimjetno između njih, tipično. A ako želimo učiniti to namjerno, mi možda žele uhvatiti u koštac nešto kao ovo. 

Možda bismo se mogli pretvoriti velika slova na niže slučaj, i mala slova u velika slova. I ispada da postoji zapravo uzorak ovdje možemo prihvatiti u samo jednom trenutku. No, pogledajmo najprije u jednom trenutku Primjer za to eksplicitno. 

Idem se vratiti u CS50 IDE. Idem za stvaranje file Ascii 0.c. I ja ću ići naprijed i dodati moje standardni io.h na vrhu, int glavna void na vrhu moje funkcije. A onda Samo ću učiniti following-- for petlje od ja jednak, recimo, 65. 

I onda ja će biti manje od 65, plus 26 slova abecede. Dakle, ja ću pustiti računalo učiniti math za mene postoji. I onda unutar te petlje, što ću ispisati? 

% C% i obrnute kose crte n. A sada želim priključiti dvije vrijednosti. Ja sam privremeno stavio pitanje označava tu pozvati na pitanje. 

Želim ponoviti od 65 pa nadalje 26 slova abecede, ispis na svakoj iteraciji da Sastavni ekvivalent lika. Drugim riječima, želim ponoviti više od 26 brojeva ispis što ASCII karakter, pismo, i što je odgovarajući broj is-- zapravo samo ponovno grafikon iz tog slajda. Tako što bi ovi upitnici biti? 

Pa, ispada da je u drugom jednom samo treba biti promjenjiva ja. Želim vidjeti da je kao broj. A srednji argument ovdje, ja mogu reći računalo tretirati taj cijeli broj ja kao lik, kako da ga zamijeni ovdje posto C. 

Drugim riječima, ako sam ja, Ljudski programer, znam to su samo brojevi na kraju dana. I znam da je 65 trebalo map na neki karakter. Uz ovaj izričitog cast, sa zagradama, naziv vrste podataka koje želite pretvoriti u, a zatvorena zagrada, možete reći računalo, hej, računalo, pretvoriti ovaj cijeli broj u char. 

Dakle, kada sam pokrenuti ovaj Program nakon prikupljanja, da vidimo što sam get-- napraviti ASCII 0. Prokleto je to, što sam krivo ovdje? Koristite neprijavljenog identifikator, Sve je u redu, a ne namjerna ali vidjet ćemo, ako ne možemo Razlog kroz ovo. 

Dakle, linija five-- pa nisam mogao daleko prije nego uništava. To je u redu. Tako je jednak linija 5 za i 65-- vidim. Dakle, imajte na umu da u C, za razliku od nekih jezici, ako imate prethodnu programiranje iskustva, imate reći računalo, za razliku od nule, što Vrsta varijable je. 

I zaboravio sam ključnu rečenicu ovdje. U skladu pet, ja sam počeo koristiti i. Ali nisam rekao C koji su podaci tipa je. Tako ću ići ovdje i reći, ah, čine ga cijeli broj. 

Sad ću ići naprijed i rekompiliranje. Taj fiksni to. ./ascii0 Enter, to je vrsta cool. Ne samo da je super brzo za pitati računalo na to pitanje, umjesto da ga se gleda na slajd, Isprintajte jedan po retku, A je 65, B je 66, pa sve down-- Budući da sam je to učinio 26 times-- do slova Z, što je 90. I, u stvari, blago inteligentniji bi su za mene da se ne oslanjaju na računalu da biste dodali 26. Mogao sam samo učinio 90, kao i, tako dugo kao što ja ne napraviti istu grešku dvaput. Želim ići kroz z, a ne samo kroz y. 

Dakle, to je izričito cast. Ispada da je ovaj nije ni potrebno. Pusti me naprijed i ponovno ovu prevodilac, i ponovno Ascii 0. Ispada da je C je prilično pametan. 

I printf, posebno, je prilično pametan. Ako ste upravo prođe Dvaput sam za oba rezerviranih mjesta, printf shvatit će, oh, dobro te znam mi je dao integer-- neki broj, kao što su 65 ili 90, ili bilo što drugo. Ali vidim da si me žele formatirati taj broj kao lik. I tako printf implicitno može baciti INT na char za vas kao dobro. Dakle, to nije nikakav problem. 

Ali primijetiti, zbog ove ekvivalencije zapravo možemo učiniti kao dobro. Pusti me naprijed i napraviti jedan druga verzija učinimo ASCII 1.c. I umjesto da prolazi preko cijeli brojevi, zaista može puhati vaš um ponavljanjem više znakova. Ako char c dobiva kapitalni A, ja žele ići naprijed i učiniti, tako dugo dok je C manja od ili jednaka do grada Z., a na svakoj iteraciji Želim povećajte C, mogu Sada u mom printf liniji ovdje recimo, posto je C posto sam opet, zarez C. 

A sada, ja mogu otići na drugi smjer, lijevanje karakter izričito u cijeli broj. Dakle, opet, zašto bi to učinili? To je malo čudno da se na neki način računati u smislu znakova. 

Ali, ako ste razumjeli što je događa ispod haube, da stvarno nema magije. Samo si rekao, hej, računalo dati ja varijabla zove C tipa char. inicijalizaciju do glavnog A. A primjetiti jednu citati materiju. 

Za likova u C, podsjećaju iz prošli tjedan, koristite jednostruke navodnike. Za gudače, riječi, fraze, koristite navodnike. OK, računalo, stalno to, pa Sve dok lik je manji od ili jednak z. I znam da iz mog ASCII tablice da je sve tih ASCII kodovi se nastavljaju. 

Nema praznine. Dakle, to je samo A do Z, odvojeni jednim brojem svakog. I onda ja mogu povećavati ugljen, ako sam stvarno želite. Na kraju dana, to je samo broj. Znam to. Dakle, ja mogu samo pretpostaviti da dodate 1 do njega. 

I onda ovaj put, ja ispisati c, a onda je sastavni ekvivalent. A ja ni ne treba eksplicitan cast. Mogu pustiti printf a Računalo shvatiti stvari, tako da sada, ako sam pokrenuti napraviti Ascii1./ascii1, JA dobiti točno istu stvar kao dobro. 

Beskoristan program though-- nikoga će zapravo pisanje softvera kako bi se shvatiti, što je broj koji se preslikava na A ili B, ili Z? Samo si idući u Google ili gledati ga online, ili ga potražite na slajd, ili slično. Pa gdje se to zaista dobiti korisne? 

Pa, govoreći o tome tobogan, primijetiti da postoji stvarni uzorak ovdje između velikih i mala to nije bilo slučajno. Uočite da je kapital A je 65. Mala je a 97. A koliko je daleko niža slučaju se? 

Dakle, 65 je koliko je koraka od 97? Dakle, 97 minus 65 je 32. Dakle, glavni je a 65. Ako dodate 32 na to, ste dobili mala slova a. I, ekvivalentno, ako oduzmemo 32, li se vratiti u glavni grad A- isto s B na malo b, veliki C do malog c. 

Sve ove praznine su 32 apart. Sada, to čini da bi nam omogućiti da nešto kao što su Microsoft Word, ili Google Docs imaju, gdje vas Možete odabrati sve i onda reći: promijeniti sve u mala slova, ili promijeniti sve u velika slova, ili promijeniti samo prvu riječ kazne u gornjem slučaju. Mi zapravo može učiniti nešto kao što je to nama samima. 

Pusti me naprijed i spremanje datoteke ovdje se zove kapitalizirati 0.c. I idemo naprijed i ščepati program koji radi upravo to kako slijedi. Dakle uključuju CS50 knjižnicu. A uključuju standardni I / O. 

I znam da je to uskoro. Tako ću ga staviti u već tamo, string.h, tako da imam pristup stvari kao što su Stirling, a zatim int glavni prazninu, kao i obično. A onda ću ići naprijed i to konce dobiva dobili niz, samo da bi dobili niz od korisnika. A onda ću raditi svoj razum ček. Ako string nije jednak null, onda je sigurno nastaviti. A što ja želim? Idem ponoviti iz i = 0, a nje do duljine niza s. 

I ja ću to učiniti, tako dugo dok je i manje od nje, a ja plus plus. Do sada, ja sam zapravo samo posuđivanje ideja od prije. A sada ću predstaviti granu. 

Tako da mislim natrag nule, gdje je imali smo one vilice na cesti, a prošli tjedan u C. idem ovo reći, ako je i-lik s veći ili jednaka mala slova a, and-- u nule što bi doslovno reći i, ali u C kažeš znak za struju, ampersand-- i i-lik s je manja od ili jednaka mala slova Z, neka je učiniti nešto zanimljivo. Idemo zapravo ispisati lik bez novi red to je znak u nizu, i-th znak u nizu. 

No, idemo naprijed i oduzmite 32 od toga. Inače, ako je znak u niz koji tražimo nije između malog a i malo z, samo naprijed i samo ga ispisati nepromijenjen. Tako smo uveli ovo bracketed zapis za naše žice da biste dobili na i-znak u nizu. 

Ja sam dodao neke uvjetno logike, kao što su Blok u prošlotjednom tjedan jedan, gdje Ja sam samo pomoću moje temeljno razumijevanje onoga što je događa ispod haube. Jeli I-og karakter s veći ili jednak do? Kao, je li to 97 ili 98, ili 99, i tako dalje? 

Ali također manja od ili jednaka vrijednosti od malih z? I ako je tako, što to crta znači? 14, to je vrsta od klice od cijele ideje, iskoristiti pismo po Jednostavno oduzimanjem 32 od njega, u ovom slučaju, jer znam, po to grafikon, kako su zastupljeni moji brojevi. Tako ćemo ići naprijed i pokrenuti ovaj, Nakon prikupljanja kapitalizirati 0.c, i trčanje kapitalizirati 0. 

Idemo upisati nešto slično Zamyla u svim malim slovima upisati. I sada imamo Zamyla u svim velikim slovima. Idemo upisati Roba u svim malim slovima. Pokušajmo Jasona u svim malim slovima. I držimo dobivanje prisiljeni kapitalizacije. Postoji manji bug koji sam vrsta nije očekivao. Obavijest moj novi redak je završio na istoj liniji kao i njihova imena, koji se osjeća malo neuredan. 

Tako ću ići ovdje i zapravo na kraju ovog programa ispisati novi red karakter. To je sve. Uz printf, vi ne morate proći varijabli ili format koda. Vi doslovno možete jednostavno ispisati nešto kao novi red. 

Tako ćemo ići naprijed i učiniti kapitalizirati 0 opet ponoviti to, Zamyla. A sada je malo ljepše. Sada, moj brz je na svom novom linijom. Tako da je sve u redu i dobro. Dakle, to je dobar primjer. Ali ja uopće ne mora nužno potrebno je hard kod 32. Znaš što? Mogao sam say-- ja nikada ne Sjeti se što je razlika. 

Ali znam da ako ja imaju malim slovom, Ja u biti želim oduzimati off bez obzira na udaljenost između malo A i jedan veliki, jer ako pretpostavimo da sve ostale slovima su isti, koji bi trebao dobiti posao ispunjavanja. No, umjesto da to, znaš što? Postoji drugi način dalje. 

Ako je to kapitalizirati 1.c-- da sam staviti da u zasebnu datoteku. neka je ne iskoristiti 2.c kako slijedi. Idem stvarno očistiti ovo ovdje. I umjesto da čak i da se znaju ili briga o tim niskoj razini pojedinosti provedbe, ja sam umjesto samo ide za ispis karakter, citat citat, posto C, a zatim pozvati drugu funkciju koja postoji koji traje argument, koji je lik, kao što je ovaj. 

Ispada u C, ima još jedna funkcija poziva na gornji, koji je kao svoje ime predlaže potrebno slovo i to čini na njegovu gornjem slučaju ekvivalent, a zatim ga vraća tako da printf može priključiti tamo. I tako to učiniti, iako sam potrebno je uvesti još jednu datoteku. Ispada postoji još jedan file da bi samo znali iz razreda, ili udžbenik ili online referenca, pod nazivom C type.h. 

Dakle, ako sam dodati da se kod mog napadača datoteke, a sada ponovno sastaviti ovaj program, capitalize2, ./capitalize2 Enter. Idemo upisati Zamyla u svemu mala slova, i dalje radi isto. Ali znate što? Ispada da se gornja ima neke druge funkcionalnosti. 

I neka me upoznati ovaj zapovijedam ovdje, nekako nespretno ime, ali čovjek za uporabu. Ispostavilo se da je većina Linux računala, kao što mi koristimo here-- Linux operativni system-- imaju naredbu zvana čovjek, koji kaže: hej, računalo, daj mi računala priručnik. Što želiš gledati u tom priručniku? 

Želim pogledati funkciju pozvani da gornja, Enter. A to je malo zagonetna čitati ponekad. Ali primijetiti da smo u Linux programer priručnik. I to je sve tekst. A primijetiti da je naziv funkcije ovdje. Ispada da ima rođaka pod nazivom na niže, što čini suprotno. I obavijest pod sinopsis, koristiti ovu funkcionirati stranicu čovjek, da tako kažemo, govori mi da potrebno uključiti c type.h. I znao sam da je od prakse. 

Evo, to je da mi pokaže dva prototipova za funkciju, tako da, ako sam ikada želite koristiti ovu Znam što su uzeti kao ulaz, i što su se vratili kao izlaz. A onda, ako sam pročitao opis, vidim detaljnije što funkcija radi. No, još važnije, ako Gledam u povratnom vrijednosti, kaže se vrijednost vratio je koji je pretvorena pismu, ili C, originalni ulaz, ako pretvorba nije bilo moguće. 

Drugim riječima, da se gornja će pokušati pretvoriti pismo u velika slova. I ako je tako, to će ga vratiti. Ali ako to ne može za neke reason-- možda je već velika slova, možda je uskličnik ili neki drugi punctuation-- to je samo ide povratak izvorni C, što znači da mogu napraviti moj broj većoj mjeri kao što slijedi. 

Ne treba mi sve ti prokleto linija koda. Sve linije sam Samo istaknuo mogu se srušio u samo jednom jednostavnom linija, što je učinimo printf posto c gornje S nosača i. I to će biti Primjer bolji dizajn. 

Zašto provesti u 7 ili 8 linija koda, što god to bilo samo sam izbrisan, kad umjesto toga može se srušiti sve je to logika i odlučivanje u jednu liniju, 13, koji oslanja se na knjižnici function-- funkcija koja dolazi s C, ali to radi upravo ono što želite učiniti. I, iskreno, čak i ako nije došao s C, možete ga provoditi sami, kao što je vidjeli smo, uz dobili negativan int i dobiti pozitivno int prošli tjedan, kao dobro. 

Ovaj kod je sada puno više čitati. I doista, ako se pomičite se gore, Pogledajte kako je kompaktniji ova verzija mog programa je. To je malo teži pri vrhu, i sada, uz sve to sadrži. No, to je u redu, jer sada stojim na ramenima programera prije mene. I tko god to bio, koji provodi se gornja stvarno nije mi uslugu, slično ko provodi Stirling stvarno nije mi uslugu prije nekog vremena. I tako sada imamo bolji program design koje provodi isti logiku. 

Govoreći o Stirling, neka mi ići naprijed i učiniti. Pusti me naprijed i spasiti Na ovu sliku kao stirling.c. I to ispada, mi možemo ponovno oguliti još jedan sloj prilično jednostavno sada. Ja ću ići naprijed i bič do drugog programa u glavnom da se ovdje jednostavno ponovno implementira Duljina niza na sljedeći način. Dakle, ovdje je linija koda koji dobiva mi niz od korisnika. Mi dalje koristiti opet i opet. Dopustite mi da si dati varijablu naziva n tipa int koja pohranjuje broj. 

I neka mi ići naprijed i učinite sljedeće logike. Dok je n-ti lik s ne nije jednako kosih crta 0, samo naprijed i povećajte n. A onda ispisati printf posto I n. Tvrdim da je ovaj program ovdje, bez poziva duljinu niza, figure out duljinu niza. 

A magija je u cijelosti upakiranog u redu 8 Ovdje s onim što izgleda kao novi sintakse, ova obrnuta kosa crta 0 u jednostrukim navodnicima. Ali zašto je to tako? Pa, razmislite što je bio događa sve ovo vrijeme. 

I kao usput da ne zaboravim, shvatiti također, da osim man stranice koji dolaze s tipično Linux sustav kao CS50 IDE, shvatiti da smo mi, Naravno osoblje, imaju također napravio web verziju ove iste ideje pod nazivom reference.cs50.net, koji je sve od tih istih man stranica, sve to isto dokumentacija, kao malo dragocjenosti na vrhu koji omogućava da se pretvoriti sve na relativno arcane jezik u manje ugodno Način rada, gdje smo, nastavno osoblje, su prošla i pokušao pojednostaviti neki od jezika kako bi stvari usmjerena na idejama, a ne neki od tehnikalija. Dakle, imajte na umu, reference.cs50.net kao drugog resursa, kao dobro. 

Ali zašto duljine niza rada u način na koji sam predložio trenutak prije? Evo Zamyla ime ponovno. I ovdje je Zamyla ime uokvireno u, kao što sam to raditi, slikati sliku da ga se, zapravo, samo niz znakova. Ali Zamyla ne postoji u izolaciji u programu. 

Kada pišete i pokrenuti program, koju koristite Mac ili računalo što su memorija, ili RAM takoreći. A možete misliti računalo kao vlasništvo puno gigabajta memorije ovih dana. A koncert znači milijarde, tako milijarde bajtova. 

Ali neka se unatrag u vremenu. I pretpostavimo da koristimo stvarno staro računalo koje ima samo 32 bajtova memorije. Mogao bih, na mom zaslonu računala, jednostavno povući to na sljedeći način. 

Ja jednostavno mogao reći da je moj računalo ima sve ove memorije. A to je kao stick memorije, ako li podsjetiti naše slike iz prošlog vremena. A ako sam podijeliti to u dovoljno vremena, Ja tvrdim da imam 32 bajta memorije na ekranu. 

Sada, u stvarnosti, ja samo mogu izvući do sada na ovom ekranu ovdje. Tako ću ići naprijed, i samo po konvenciji, izvući memoriju mog računala kao rešetke, a ne samo kao jedan pravac. Naime, ja tvrdim da sada ova rešetka, to 8 od 4 rešetke, samo predstavlja sve 32 bajta memorije na raspolaganju na mom Macu, ili dostupan u moj PC. I oni su umatanje na dvije linije, samo jer se uklapa više na ekranu. No, ovo je prvi bajt. Ovo je drugi bajt. Ovo je treći bajt. 

I ovo je 32. bajt. Ili, ako mislimo poput računala Znanstvenik to bajtove 0, 1, 2, 3, 31. Dakle, morate 0 do 31, ako početi računajući na 0. 

Dakle, ako ćemo koristiti program da pozivi dobili niz, i dobili smo niz od čovjeka kao da je nazvao Zamyla, Z-A-M-Y-L-A, kako u svijetu čini Računalo pratiti što bajt, koji komad memorije, pripada kojoj string? Drugim riječima, ako ćemo do unesite drugo ime u računalo, kao što je ovaj Andi, pozivajući dobili niz drugi put, A-N-D-ja mora završiti u memorije računala, kao dobro. Ali kako? 

Pa, ispada da ispod napa, ono C se pri spremanju žice da ljudski vrste u, ili da dolazi iz nekog drugog izvora, je li ocrtava kraj njih s posebna character-- kosih crta 0, što je samo jedan poseban način govoreći: 80 bitova u nizu. 

Dakle, A- ovo je broj 97 opoziv. Tako su neki uzorak od 8 bitova predstavlja decimalni broj 97. Ova obrnuta kosa crta 0 je doslovno broj 0, poznatiji NSK, N-U-L, za razliku od ranije, N-U-L-L, kojima smo razgovarali o tome. No, za sada, samo znam da je to Obrnuta kosa crta 0 je samo 80 bita u nizu. 

A to je samo ova linija u pijesak koji kaže da ništa na lijevo pripada jednoj žici, ili jedan tip podataka. I ništa na desno spada u nešto drugo. Andi je ime, u međuvremenu, koji je upravo vizualno događa završiti na drugoj liniji, ali to je samo estetski detalj, Slično se prekida nul. 

To je niz od A-N-D-i znakova, plus jedna petina tajni znak, sve 0 bita, samo da markira kraj Andi ime kao dobro. A ako mi zovemo dobili STRING po treći put u računalo da biste dobili niz kao što je Maria, M-A-R-I-A, na sličan je Maria je Naziv nul prestaje s obrnute kose crte 0. 

To je bitno drugačija od kako računalo će obično pohraniti cijeli broj, ili plovak ili drugi vrste podataka i dalje, jer opoziva, cijeli je obično 32 bita ili 4 bajta, ili možda čak i 64 bita, ili osam bajtova. No, mnogi primitivci u računalo u programskom jeziku ima fiksni broj bajtova ispod hood-- možda jednom, možda dva, možda četiri, možda osam. 

No strings, po dizajnu, imaju dinamičan broj znakova. Ne znate unaprijed, sve dok ljudske vrste u Z-A-M-Y-L-A, ili M-A-R-I-A ili A-N-D-I. Ne znam koliko puta je korisnik će pogoditi tipkovnica. Stoga, ne znam kako mnogi likovi unaprijed ti si idući u morati. 

I tako C samo vrsta ostavlja poput Tajna breadcrumb ispod haube na kraju niza. Nakon skladištenja Z-A-M-Y-L-a u memoriji, to je također samo stavlja u protuvrijednosti je razdoblju. Na kraju rečenice, stavlja 80 bitova, kako sjetiti gdje Zamyla počinje i završava. 

Zato što je veza, dakle, da se ovaj program? Ovaj program ovdje, Stirling, je jednostavno mehanizam za dobivanje niza od korisnika, linija 6. Linija 7, izjavljujem varijablu zove n i postaviti ga jednak 0. 

A onda u redu 8, jednostavno sam pitao pitanje, dok je n-ti lik ne nije jednako sve 0 bits-- drugim riječima, ne jednaka ovaj poseban karakter, kosih crta 0, što bio je upravo to poseban nul character-- ići naprijed i samo povećavati n. 

I imajte to rade, i držati to radi, i držati ga radi. I tako, iako u prošlosti smo koristi i, to je savršeno u redu semantički koristiti n, ako ste samo pokušava računati ovaj put namjerno, i samo želim da ga zovu n. Dakle, to samo čuva postavlja pitanje, je n-ti karakter je sve 0s? Ako ne, pogledaj na sljedeći izgled, gledati na drugu, izgleda na sljedeći, izgleda na sljedeći. 

No, čim vidite kosu crtu 0, zaustavlja taj loop-- linija od 9 do 11--. Vi se probiti iz while petlje, ostavljajući unutar tog promjenjivog n ukupno broj od svih znakova u nizu koje ste vidjeli, čime ga ispišete. Tako ćemo probati ovaj. 

Pusti me naprijed i bez pomoću funkcije Stirling, ali samo pomoću svoje vlastite domaću verziju ovdje se zove Stirling, neka mi samo naprijed i trčanje Stirling, upišite u nešto kao Zamyla, što ja znam unaprijed je šest znakova. Idemo vidjeti ako to radi. Doista, to je šest. Pokušajmo s Robom, tri znaka, tri znaka, kao i, i tako dalje. Dakle, to je sve što se događa na ispod haube. A primijetiti veze, zatim, s prvom tjednu klase, gdje smo razgovarali o nešto poput apstrakcije, što je samo to raslojavanje ideja ili složenost, na vrhu osnovnih principa. Evo, mi smo na neki način u potrazi ispod haube Stirling, da tako kažemo, shvatiti, kako bi se provoditi? 

A mogli smo ponovno provesti ga sami. Ali mi nikad ne opet ide ponovno provesti Stirling. Samo ćemo se koriste Stirling kako zapravo dobili neki duljina žice. 

Ali nema magije ispod haube. Ako znate da je ispod sjenilo, niz je samo niz znakova. I to niz znakova sve se može numerički riješiti s nosača 0, zagrada 1, nosač 2, a vi zna da na kraju niza je poseban znak, možete shvatiti kako napraviti najviše ništa u programa, jer sve se svodi na je čitanje i pisanje memorije. To je, mijenja i izgleda na memoriju, ili se kreće stvari oko u memoriji, tiskanje stvari na zaslonu i tako dalje. 

Tako ćemo sada koristiti ovaj novootkriveni razumijevanje onoga što konce zapravo su ispod poklopca motora, a oguliti jedan drugi sloj koje do sada imamo ignorirala u potpunosti. Posebno, svako doba implementirali smo program, imali smo tu liniju koda pri vrhu progla glavni. A mi smo naveli int glavni prazninu. 

I to praznina unutar zagrada ima govorim cijelo vrijeme da je glavni sama po sebi ne poduzimati nikakve argumente. Svaki ulaz je glavna je događa da se od korisnika je da dolaze iz neke druge mehanizam, kao što get int, ili dobiti plutaju, ili dobiti niz, ili neku drugu funkciju. No, ispada da prilikom pisanja programa, zapravo možete odrediti da ovaj program će uzeti ulaza od čovjeka u naredbeni redak sama. 

Drugim riječima, iako smo do sada bio pokrenut samo ./hello zdravo ili slične programe, sve od ostali programi koje smo koristili, da se mi sami ne pisati, su uzimanje, čini se, naredbenog retka arguments-- stvari kao što napraviti. Kažeš nešto slično napraviti, a zatim druga riječ. Ili zveket, kažeš zveket, a zatim druga riječ, naziv datoteke. 

Ili čak RM ili CP, kao možda Vidjeli ili se koristi već ukloniti ili kopiranje datoteka. Svi oni uzeti tzv naredbenog retka arguments-- dodatne riječi na terminalu redak. No, do sada, mi sami nisu imali ovaj luksuzni uzimanja ulaz iz korisnički kada on ili ona zapravo radi sam program u naredbenom retku. 

Ali što možemo učiniti da se ponovo progla Glavni kreće naprijed, a ne kao vlasništvo poništiti u zagradi, ali ta dva argumenta instead-- prvi cijeli broj, a drugi nešto novo, nešto što ćemo nazvati niz, nešto slično u duhu na ono što smo vidjeli u nule kao popis, ali polje nizova, kao što ćemo uskoro vidjeti. No, da vidimo to tako Na primjer, prije nego razlikovati točno što to znači. 

Dakle, ako ja ići u CS50 IDE Ovdje sam otišao naprijed i proglasio u datoteci pod nazivom argv0.c sljedeći predložak. A primijetiti jedino da je drugačije dosad je da sam promijenio void int argc niz argv otvorena zagrada, u neposrednoj blizini zagrada. A primjetiti za sada, nema ništa unutar tih skupina. 

Nema broja. I nema ja, ili n, ili bilo koji drugi znak. Ja sam samo pomoću uglate zagrade za sada, iz razloga što će doći natrag u samo jednom trenutku. 

A sada ono što ću učiniti je to. Ako argc jednak jednak 2-- a podsjećaju da je jednako jednakima je operator jednakosti uspoređivanje lijevi i desni za jednakost. To nije zadatak operater, koji je jedini znak jednakosti, što znači kopiju s desne strane ulijevo neku vrijednost. 

Ako argc jednak jednak 2, želim recimo, printf, zdravo, postotaka, nova linija, a zatim ga priključite in-- a evo nova trick-- argv nosač 1, iz razloga da ćemo se vratiti u trenutku. Inače, ako argc ne jednak 2, znate što? Recimo samo ići naprijed i, kao i obično, tisak kako zdravo svijet bez zamjene. 

Dakle, čini se da, ako argc, što stoji za argument count, jednak 2, Idem ispisati zdravo ili nešto drugo. Inače, po defaultu, ja sam tiskanja Pozdrav svijetu. Dakle, što to znači? 

Pa, dopustite mi ići naprijed i spasiti Na ovu sliku, a zatim učinite napraviti argv0, a onda ./argv0, Enter. I to kaže Hello World. Sada, zašto je to tako? 

Pa, ispada u bilo koje vrijeme pokrenuti program u naredbenom retku, ti si ispunjavanja što ćemo općenito nazvati bajtova vektor. Drugim riječima, automatski se računalo, operativni sustav, ide na ruku svome programu Sam popis sve riječi da ljudski ispisane na brz, u slučaju da programer želite učiniti nešto s tim informacijama. I u ovom slučaju, samo riječ Ja sam upisali u retku je ./argv0. 

I tako je broj argumenata koji se šalje se moj program je samo jedan. Drugim riječima, argument strani, inače poznat kao argc Ovdje kao cijeli broj, samo je jedan. Jedan od njih, naravno, nije jednako dva. I tako to je ono što ispisuje, zdravo svijet. 

No, dopustite mi da se ovaj negdje. Dopustite mi da kažem, argv0. A zatim o tome kako Maria? A onda pritisnite Enter. 

A primjetiti ono magično se ovdje događa. Sada, umjesto da zdravo svijetu, imam promijenio ponašanje ovog programa uzimajući ulaz ne od get niz ili neke druge funkcije, ali od, očito, moju zapovijed Sam, ono što sam prvobitno upisali u. I mogu igrati ovu igru ​​ponovno to mijenja na Stelios, na primjer. 

I sada vidim drugo ime i dalje. I ovdje, mogao bih reći Andi. I ja sam mogao reći Zamyla. I možemo igrati ovu igru ​​tijekom cijelog dana, samo uključivanjem u različite vrijednosti, tako dugo dok sam pružiti upravo dvije riječi na upit tako da argc, moj argument strani, 2. 

Vidim da je ime priključen na printf, po tom stanju ovdje? Dakle, izgleda da nam se sada izražajna sposobnost uzimanja ulaz iz drugog mehanizma, od tzv naredbenog retka, umjesto da čekaju dok korisnik pokreće program, a onda mu ili joj brz korištenjem nešto kao get niza. 

Pa što je ovo? Argc, opet, samo je cijeli broj, broj words-- arguments-- da korisnik osigurano od redak, na prozoru terminala, uključujući i naziv programa. Tako je naša ./argv0 je, zapravo, Ime programski, ili kako sam pokrenuti program. 

To se računa kao riječ. Dakle argc će biti 1. Ali kad sam pisati Stelios ili Andi, ili Zamyla ili Maria, to znači da je argument broj je dva. I tako sada postoji dvije riječi doneseni u. 

I napomena, možemo nastaviti ovu logiku. Ako sam zapravo reći nešto poput Zamyla Chan, ime i prezime, a time prolazu tri argumenta u ukupnom, Sada se kaže zadani opet, zbog, naravno, 3 nije jednak 2. 

I tako na ovaj način, moram pristup putem argv ovaj novi argument da bismo mogli tehnički nazvati što god želimo. No, po konvenciji, to je argv i argc, respektivno. Argv, argument vektor, je vrsta od sinonim za programiranje značajka u C zove niz. 

Niz je popis sličnim vrijednostima natrag, natrag, natrag, na leđa. Drugim riječima, ako je netko ovdje, u RAM-a, sljedeći je tik do nje, a tik do njega. Nisu sve više mjesta. I to potonji scenarij, gdje su stvari su sve više mjesta u memoriji, može zapravo biti snažan lik. No, mi ćemo se vratiti na to kada smo govoriti o luksuznijih struktura podataka. Za sada, niz je samo komad memorijskog, svaki od čiji se elementi natrag, natrag, natrag, natrag, i uglavnom isti tip. 

Dakle, ako mislite o tome, iz Prije trenutak, što je string? Pa, niz, kao Zamyla, Z-A-M-Y-L-A, je tehnički, samo polje. To je niz znakova. 

I tako, ako smo zaista privući toga, kao što sam učinili ranije, kao komad memorije, ispada da je svaki od tih likovi zauzima bajt. A tu je i ona posebna sentinel lik, kosih crta 0, ili svih osam 0 bita, to markira kraj tog niza. Dakle, niz, ispada van, citiram citat niz, je samo niz chara-- char kao stvarna vrsta podataka. 

A sada argv, meanwhile-- Vratimo se na program. Argv, iako se riječ string ovdje nije sama niz. Argv, argument vektor, je niz žice. 

Dakle, kao što možete imati niz znakova, možete imati višu razinu, niz strings-- tako, na primjer, kad sam upisao trenutak prije ./argv0 argv0, prostor Ž-A-M-Y-L-A, tvrdio sam da je argv imao dva konce u it-- ./argv0, i Z-A-M-Y-L-A. U Drugim riječima, argc je 2. Zašto je to? 

Pa, zapravo, ono što se događa na je da svaki od tih nizova je, naravno, niz znakova Kao i prije, od kojih svaki likovi zauzima jedan bajt. I ne brkati stvarni 0 u ime programa s 0, što znači da svih 80 bita. I Zamyla, u međuvremenu, i dalje je Također niz znakova. 

Tako je na kraju dana, to je stvarno izgleda ovako ispod haube. Ali argv, po prirodi kako glavni djela, mi omogućuje da zamotate sve ovo gore u, ako hoćete, veći niz da, ako smo nešto više pojednostaviti što je slika izgleda i ne dosta ga izvući na ljestvici do tamo, ovo polje je samo veličina 2, prvi element koji sadrži niz, drugi element koji sadrži niz. A, s druge strane, ako vam se vrsta uvećanje na svakoj od tih nizova, što vidi ispod haube je da svaki niz je samo niz znakova. 

Sada, baš kao i sa žicama, bili smo u mogućnosti da biste dobili pristup do i-tog lika u nizu koristiti taj uglata zagrada zapis. Na sličan način, s polja u cjelini, možemo korištenje uglata zagrada zapis dobiti na bilo koji broj nizova u nizu? Na primjer, neka me ići naprijed i učiniti. 

Pusti me naprijed i stvoriti argv1.c, što je malo drugačije ovaj put. Umjesto provjere argc2, Idem umjesto toga učiniti. Za int mogu dobiti 0, ja manje od argc, ja plus plus, a zatim ispisati unutar toga, posto s, nova linija, a zatim argv nosač ja. 

Dakle, drugim riječima, neću se bave pojedini likovi u ovom trenutku. Argv, kao što je uz te prazne kvadrat aparatić za desno od imena argv, znači argv je niz žice. I argc je samo int. 

Ova linija ovdje, 6, je govoreći set i jednaka 0. Grof sve do, ali ne uključujući, argc. A onda se na svakoj iteraciji, ispisati niz. Što string? 

I-tog niza u argv. Dakle, dok je prije nego što sam bio pomoću uglata zagrada zapis dobiti na i-tog lik je u nizu, a sada Ja sam koristeći uglata zagrada zapis dobiti na i-tog niza u niz. Dakle, to je vrsta jednom sloju gore, konceptualno. 

I stoga, što je uredno o tome Program sada, ako sam sastaviti argv1, a zatim učinite ./argv1, a zatim upišite u nešto poput foo bar Baz, koje su tri zadane riječi koje računalni znanstvenik poseže za bilo koje vrijeme on ili ona treba neki rezerviranim riječi, i pritisnite Enter, svaki od tih riječi, uključujući i naziv programa, koji u argv na prvom mjestu, završava se ispisuje jedan po jedan. A ako se to promijeni, a ja kažem nešto kao argv1 Zamyla Chan, smo dobili sve tri od njih riječi, koje je argv0, argv1, argv2, jer je u to Slučaj argc, grof je 3. 

No, ono što je uredan je ako ste razumjeli da argv je samo niz žice, i ti shvatiti da niz je niz znakova, možemo zapravo vrsta koristiti uglata zagrada označavanja više puta odabrati string, a zatim odaberite lik u nizu, ronjenje u dublje kako slijedi. U ovom primjeru, pusti me naprijed i pozvati ovaj argv2.c. I u ovom primjeru, neka mi samo naprijed i učiniti following-- za int ja dobiti 0, je i manje od argc, i plus plus, baš kao i prije. Tako je u drugom words-- i sada to sve je dosta komplicirano. Onda ću reći ponoviti preko žice u argv, kao komentar na sebe. A onda ću imati uklopljeni za petlju, što vjerojatno učinio, ili se smatra radi, u nule, gdje je Ja ću reći int-- sam neće opet koristiti, jer ne želim da se sjena, ili vrsta prebrisati postojeći i. 

Idem, umjesto toga, kažu j, jer to je moj ići na varijablu nakon I., kad sam samo pokušava računati jednostavnih brojeva. Za j dobiva 0-- i, n, ide dobiti krmi duljinu argv nosača i, tako dugo dok je manji od j, m, j plus plus, učinite sljedeće. I ovdje je zanimljiv dio. 

Ispiši lik i novu liniju, priključivanja argv zagrada I, nosača j. U redu, pa neka mi dodati neke komentare ovdje. Ponoviti više znakova u tekućem nizu, print j-og lik u i-tom nizu. Tako sada, razmotrimo Što ovi komentari znače. 

Prolazi preko žice u argv-- koliko žice su u argv, koji je niz? Argc mnogi, pa sam iterating iz i jednaka 0 do argc. U međuvremenu, koliko znakova u i-tog niza u argv? 

Pa, da se taj odgovor, Ja jednostavno nazvati duljine niza na tekući string me briga o, što je argv nosač ja. A ja ću privremeno pohraniti da vrijednost n, samo za caching svrhe, da ga zapamtiti za učinkovitost. A onda ću inicijalizirati j 0, nastaviti tako dugo dok j je manji od nje, i na svakoj iteraciji prirasta j. 

I onda ovdje, po moj komentar na liniji 12, ispisati karakter, nakon čega slijedi novi red, posebno argv nosač ja mi daje i-th string u argv-- tako da je prvi riječju, Druga riječ, treća riječ, što god. A onda j urona u dublje, te dobiva mi j-th karakter te riječi. I tako, u stvari, možete liječiti argv kao višedimenzionalan, kao dvodimenzionalni, polje, pri čemu svaka riječ vrsta izgleda kao što je ovaj u vašem umu oka, a svaki lik je vrsta sastavljena u stupac, ako to pomaže. 

U stvarnosti, kada se zafrkavati to osim u budućim tjedana, to će biti malo sofisticiraniji od toga. No, možete zaista misliti da je, za sada, kao upravo to dvodimenzionalno polje, pri čemu jedna razina tome je sve od žice. I onda ako zaronite u dublje, vama možete dobiti na pojedinim likovima u njoj pomoću ove oznake ovdje. 

Dakle, što je neto učinak? Pusti me naprijed i bi argv2-- prokleto je. Pogriješio sam ovdje. Implicitno proglašenja Biblioteka funkcija Stirling. Dakle, sve ovo vrijeme, to je možda je prikladno da smo na neki način završavanja upravo tamo gdje smo počeli. 

pijan sam, implicitno izjavljuje Biblioteka funkcija Stirling. OK, čekaj malo. Sjećam se da je, osobito budući da je upravo ovdje. Trebam uključiti string.h u ova verzija programa. 

Pusti me naprijed i uključuju string.h, osim toga, samo naprijed i rekompiliranje argv2. A sada, evo, čine argv2, Enter. I iako je to malo grobni na prvi pogled, primijetiti da je, zaista, ono je tiskana je točka argv2. 

Ali, ako sam tipa neke riječi nakon što se brz, kao argv2 Zamyla Chan, Ulaz, i malo grobni na prvi pogled. Ali ako smo pomicanje natrag gore, ./argv2 Z-A-M-Y-L-C-H-A-N. Stoga smo ponovljena tijekom svake riječi. A, s druge strane, mi smo ponovljena više Svaki lik unutar riječi. 

Sada, nakon svega toga, shvatiti da postoji jedan detalj smo bili ljubazni ignoriranje cijelo ovo vrijeme. Mi smo samo zadirkivali osim što glavna-a ulazi mogu biti? Što je glavna je izlaz? 

Sve to vrijeme, mi smo bili samo kopiranje i lijepljenje Riječ int ispred glavne, iako možete vidjeti na internetu, ponekad pogrešno u starijim verzijama od C i prevodiocima, koji kažu praznina, ili ništa at svi. Ali, doista, za verziju od C koje koristite, C 11, ili 2011, ostvariti da bi trebalo biti int. I bilo bi trebao biti praznina ili argc i argv ovdje. 

Ali zašto int main? Što je to zapravo vraća? Pa, to ispada sve ovo vrijeme, svaki put kad sam napisao Programa Glavni uvijek vraća nešto. No, to je bilo to u tajnosti. 

To nešto je int, kao linija 5 sugerira. No, ono što int? Pa, tu je to Konvencija u programiranju, pri čemu se ništa nije otišao u krivu i sve je dobro, programi i funkcije općenito return-- nešto counterintuitively-- 0. 0 općenito označava sve je dobro. Dakle, iako mislite to što je lažno u mnogim kontekstima, to zapravo obično znači dobra stvar 

U međuvremenu, ako program vraća 1, ili negativan 1, ili 5, ili negativno 42, ili bilo koji ne-0 vrijednosti, koji općenito označava da nešto nije u redu. U stvari, na svoju ruku, Mac ili PC, možda ste zapravo vidjeli poruka o pogrešci, pri čemu je kaže nešto ili nekog drugog, pogreška kod negativna 42, ili kod pogreške 23, ili nešto slično tome. Taj broj je obično samo nagovještaj programer, ili tvrtke koji je napravio softver, što je pošlo po zlu i zašto, tako da oni mogu gledati kroz dokumentaciju ili kod, i shvatiti što je greška zapravo znači. To obično ne korisno za nas krajnje korisnike. 

No, kada glavni vraća 0, sve je dobro. A ako ne odredite ono glavno trebao vratiti, to će samo automatski povratak 0 za vas. No, nešto se vraćaju drugo je zapravo korisno. 

U ovom završnom programu, pusti me ići naprijed i pozvati ovaj exit.c, i uvesti posljednji od današnje teme, poznat kao koda pogreške. Pusti me naprijed i uključuju naš Poznate datoteke do vrha, da li int main. I ovaj put, neka je učiniti int argc, niz argv, i sa mojim zagradama impliciraju da je u nizu. I onda neka mi samo to ček razum. Ovaj put, ako argc ne jednak 2, onda znate što? Zaboravi. Ja ću reći da je, hej, korisnik, vi ste nedostaje naredbenog retka argumente Obrnuta kosa crta n. 

I onda to je to. Želim izlaz. Ja ću preventivno, i prerano stvarno, povratak nešto drugo od broja 1. Go to vrijednosti za prvu greška se može dogoditi je 1. Ako imate neki drugi pogrešna Situacija koja se mogu pojaviti, moglo bi se reći 2 povrat ili vratiti 3, ili možda čak i negativna 1 ili negativna 2. 

To su samo izlazni kodovi koji su, u pravilu, samo korisno za programera, ili Tvrtka koja se isporučuje softver. No, činjenica da je Ne 0 je ono što je važno. Dakle, ako u ovom programu, želim jamči da je ovaj program samo radi ako me korisniku pruža uz argument brojem od dva, naziv programa, a neke druge riječ, mogu provoditi onoliko koliko slijedi, vikati na korisnika s printf govoreći: Nedostaje naredbenog retka argumente, povratak 1. To će samo odmah zatvorite program. 

Samo ako argc jednak 2 ćemo sići Ovdje, na kojem trenutku ću reći, zdravo posto s, kosih crta n, argv1. Drugim riječima, ja sam Ne ide nakon argv 0, što je samo ime programa. Želim ispisati Hello, zarez, druga riječ koju ljudski upisali. I u ovom slučaju na linija 13, sve je dobro. 

Znam da argc 2 logično iz ovog programa. Ja ću ići naprijed i povratak 0. Kao na stranu, imajte na umu da To je istina u nule, kao dobro. 

Logično, što sam mogao učiniti i zatvoriti u kućište ove retke koda u ovom drugom članku ovdje. Ali, to je neka vrsta nepotrebno uvlačenje moj broj. I želim napraviti super jasno da bez obzira što, po defaultu, zdravo nešto će se tiskati, tako dugo dok korisnik surađuje. 

Dakle, to je vrlo uobičajena za korištenje uvjet, samo ako se, uhvatiti neki pogrešan situaciju, a zatim izlaz. A onda, sve dok je sve dobro, ne imati drugo, ali samo kod vani da ako, jer je to ekvivalent u ovom konkretnom slučaju, logično. Tako sam vraća 0, samo da izričito naznačiti sve je dobro. 

Ako sam izostavio 0 povratak, to bi automatski se pretpostavlja za mene. Ali sad kad sam povratka jedan u najmanje ovom slučaju, Idem, za dobru mjeru i jasnoća, vratite 0 u ovom slučaju. Pa sad neka mi ići naprijed i učiniti izlaz, koja je savršena prikazali samo otići. 

Ali napraviti izlaz i pusti me naprijed i učiniti ./exit, Enter. A program vikao na mene, Nedostaje naredbenog retka argumente. OK, neka mi surađivati. 

Dopustite mi da umjesto toga učiniti ./exit, David, Enter. A sada je, kaže, zdravo David. A ti ne bi normalno vidjeti. 

No, ispada da postoji poseban način u Linuxu da se zapravo vidjeti s tim što izlazni kod program zatvara. Ponekad u grafičkom Svijet kao Mac OS ili Windows, vidite samo ove brojeve kada je poruka o pogrešci pops gore na ekranu i programer prikazuje taj broj. No, ako želimo vidjeti što je greška Poruka je, možemo to učiniti here-- tako ./exit, Enter, print Nedostaje naredbenog retka argumente. 

Ako sam to echo $ ?, što je smiješno grobni izgleda. No $? je čarobni bajanje koji kaže, hej, računalo, reci mi što je prethodna Program je izlazni kod bilo. I ja pritisnite Enter. Vidim 1, jer to je ono što sam rekla moja glavna funkcija da se vrate. 

U međuvremenu, ako ja ./exit Davida, i pritisnite Enter, vidim, zdravo Davida. I ako ja sad to echo $ ?, vidim zdravo 0. I tako će se to biti vrijedne informacije u kontekstu debugger, ne tako mnogo toga što je ljudsko, ne bi stalo. No, debugger i druge Programi ćemo koristiti ovaj semestar Često će gledati na taj broj, iako je to na neki način skrivena osim ako ste u potrazi za to, da se utvrditi je li program-a ili ne Izvršenje bile su točne ili netočne. 

I tako to nas dovodi do to, na kraju dana. Počeli smo se danas gleda na ispravljanje pogrešaka, a zauzvrat u tijeku sama, a onda još zanimljivije, tehnički ispod haube na ono što žice su, koji traje tjedan mi samo uzeo zdravo za gotovo, a sigurno ih je zdravo za gotovo nule. 

onda smo pogledali kako možemo pristupiti pojedini likovi u nizu, a onda opet uzeo višu razinu gledati na stvari, gledajući kako well-- ako želimo da se na pojedinca elementi u popisu kao što su struktura, Ne možemo to učiniti s više nizova? I što možemo s naredbenog retka argumente. Ali ova slika ovdje od samo kutije je demonstrativno ove opće ideje od niza ili popis ili vektoru. A ovisno o kontekstu, svi ovi riječi znači malo različite stvari. Tako je u C, mi smo samo ide razgovarati o nizu. I niz je komad memorije, svaki od kojih je elementi su u dodiru, leđa, natrag, natrag, na leđa. 

A ti su elementi, uglavnom, istog tipa podataka, karakter, lik, lik, lik, ili string, string, string, string, ili int, int, int, što god to bilo Pokušavamo trgovine. Ali na kraju krajeva, to je kako to izgleda konceptualno. Vi ste uzimajući vaše memorije ili RAM računala. A ti si to probijanje u jednaki veličine kutije, od kojih su svi su se vratile, na leđa, na natrag, natrag na ovaj način. 

I što je lijepo o ova ideja, kao i činjenica da možemo izraziti vrijednosti na ovaj način s prvom od naših podatkovnih struktura u razredu, znači da možemo početi za rješavanje problema s kodom koji je došao tako intuitivno u tjednu 0. Vi ćete se sjetiti telefon Knjiga primjer, gdje je koristili smo podijeli pa vladaj, ili binarni algoritam za pretraživanje, prosijati kroz cjelinu hrpa imena i brojeve. No, pretpostavlja se, podsjetimo, da je to telefonski imenik je već riješeno, da je netko drugi već Pomislio out-- dati popis imena i numbers-- kako ih po abecednom redu. A sada da u C mi, također imaju mogućnost da stavi stvari, a ne fizički u telefonskom imeniku ali gotovo u računalu, memorije, moći ćemo sljedeći tjedan ponovno uvesti učinimo prvi od naših podatkovnih struktura u array-- ali je još važnije, stvarna računala znanost algoritmi provode u kodu, s kojima možemo pohraniti Podaci u strukturama kao što je ovaj, a zatim početi manipulirati, a zapravo rješavanje problema s njim, i graditi na vrhu toga, u konačnici, programi u C, u Python, u JavaScriptu, Pretraživanjem baze podataka sa SQL? 

A mi ćemo vidjeti da sve te različite ideje interlock. No, za sada, podsjetiti da je domene koje smo uveli danas je to stvar ovdje, a svijet kriptografije. A među sljedećih problema vi sami će riješiti je umjetnost kriptografije, remećenje i de-remećenje Informacije i šifriranje i dešifriranja teksta, i uz pretpostavku konačnici da sada znam što je ispod haube tako da kada vidite ili primanja poruka poput ove, te se to može dešifrirati. Sve to, i još mnogo toga sljedeći put. 

[VIDEO PLAYBACK] 

-Mover Upravo stigao. Ja ću ići posjet njegov sveučilišni profesor. Da. Bok. Ti si. Čekati! David. Samo pokušavam shvatiti što ti se dogodilo. Molim vas, bilo što može pomoći. Bili ste njegova koledža cimer, zar ne? Bio si tamo s njim kad je završio CS50 projekt? 

[MUSIC SVIRA] 

-To Je CS50. 

Volim ovo mjesto. 

-Pojesti. Idemo bez posla. 

[END PLAYBACK] 