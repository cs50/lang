1
00:00:00,000 --> 00:00:02,970
>> [REPRODUÇÃO DE MÚSICA]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN: Tudo bem.

4
00:00:15,700 --> 00:00:18,832
Este é CS50 e este
é o início da Semana 2.

5
00:00:18,832 --> 00:00:21,040
E você vai lembrar que, ao longo
o último par de semanas,

6
00:00:21,040 --> 00:00:24,490
temos vindo a introduzir computador
ciência e, por sua vez, a programação.

7
00:00:24,490 --> 00:00:27,640
>> E começamos a história por meio de
Zero, que a linguagem gráfica

8
00:00:27,640 --> 00:00:28,990
a partir do MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
E, em seguida, mais recentemente,
na semana passada, fizemos

10
00:00:30,780 --> 00:00:34,450
introduzir um higher-- um
linguagem de nível mais baixo conhecido

11
00:00:34,450 --> 00:00:36,770
como C, algo que é puramente textual.

12
00:00:36,770 --> 00:00:39,440
E, de fato, última vez que
explorado dentro desse contexto

13
00:00:39,440 --> 00:00:40,450
uma série de conceitos.

14
00:00:40,450 --> 00:00:43,010
>> Este, recall, era a própria
primeiro programa nós verificamos.

15
00:00:43,010 --> 00:00:45,710
E este programa, muito simplesmente,
imprime, "Olá, mundo".

16
00:00:45,710 --> 00:00:47,730
Mas há muito
magic parecendo acontecendo.

17
00:00:47,730 --> 00:00:51,460
Há essa #include
com estes colchetes.

18
00:00:51,460 --> 00:00:52,170
Há int.

19
00:00:52,170 --> 00:00:53,020
Há (void).

20
00:00:53,020 --> 00:00:56,330
Há parênteses, colchetes,
ponto e vírgula, e muito mais.

21
00:00:56,330 --> 00:00:58,480
>> E assim, lembrar que
introduzimos Raspadinha

22
00:00:58,480 --> 00:01:02,110
para que pudéssemos, idealmente, ver o passado
que a sintaxe, o material que não é realmente

23
00:01:02,110 --> 00:01:04,590
tudo o que intelectualmente
interessante, mas cedo

24
00:01:04,590 --> 00:01:07,700
é, absolutamente, um pouco complicado
para envolver sua mente em torno.

25
00:01:07,700 --> 00:01:10,860
E, de facto, um dos mais comuns
as coisas no início de uma classe de programação,

26
00:01:10,860 --> 00:01:13,443
especialmente para os menos
confortável, é para se frustrado por

27
00:01:13,443 --> 00:01:17,460
e tropeçou por alguns sintática
erros, para não mencionar a erros lógicos.

28
00:01:17,460 --> 00:01:19,800
E assim entre os nossos objectivos
hoje, na verdade, vontade

29
00:01:19,800 --> 00:01:23,280
seja para equipá-lo com algum
técnicas de resolução de problemas sobre como

30
00:01:23,280 --> 00:01:26,705
para resolver melhor os problemas próprios
sob a forma de depuração.

31
00:01:26,705 --> 00:01:29,330
E você vai lembrar, também, que o
ambiente que foi introduzida

32
00:01:29,330 --> 00:01:31,780
última vez que foi chamado CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Este é um software baseado na Web que
permite programar na nuvem,

34
00:01:34,850 --> 00:01:38,450
por assim dizer, mantendo todo o seu
arquivos juntos, como teremos novamente hoje.

35
00:01:38,450 --> 00:01:41,480
E recordar que nós
revisitado estes tópicos aqui,

36
00:01:41,480 --> 00:01:44,480
entre elas funções e loops, e
variáveis ​​e expressões booleanas,

37
00:01:44,480 --> 00:01:45,110
e condições.

38
00:01:45,110 --> 00:01:49,190
E, na verdade, um pouco mais que nós
traduzido do mundo do Scratch

39
00:01:49,190 --> 00:01:50,800
para o mundo do C.

40
00:01:50,800 --> 00:01:53,220
>> Mas a construção fundamental
blocos, por assim dizer,

41
00:01:53,220 --> 00:01:55,150
foram realmente ainda o mesmo na semana passada.

42
00:01:55,150 --> 00:01:57,900
Na verdade, nós realmente só tinha um
diferente peça do puzzle, se você quiser.

43
00:01:57,900 --> 00:02:00,300
Em vez de que o roxo
salvar bloco, nós em vez

44
00:02:00,300 --> 00:02:02,940
tinha printf, que é
esta função em C que

45
00:02:02,940 --> 00:02:05,890
permite imprimir algo
e formatá-lo na tela.

46
00:02:05,890 --> 00:02:07,950
Introduzimos o CS50
Biblioteca, onde você

47
00:02:07,950 --> 00:02:11,420
têm agora à sua disposição get_char,
e get_int, e get_string,

48
00:02:11,420 --> 00:02:14,610
e algumas outras funções como
bem, através do qual você pode obter a entrada

49
00:02:14,610 --> 00:02:16,260
do próprio teclado do utilizador.

50
00:02:16,260 --> 00:02:20,640
E também teve um olhar para as coisas
como these- bool, e char,

51
00:02:20,640 --> 00:02:22,490
e double, float,
int, cadeia long_long.

52
00:02:22,490 --> 00:02:25,170
E há ainda outros tipos de dados em C.

53
00:02:25,170 --> 00:02:28,560
>> Em outras palavras, quando você declarar
uma variável para armazenar algum valor,

54
00:02:28,560 --> 00:02:32,600
ou quando você implementar uma função
que retorna algum valor,

55
00:02:32,600 --> 00:02:35,290
você pode especificar o que
tipo de valor que seja.

56
00:02:35,290 --> 00:02:37,310
É uma cadeia, como um
sequência de caracteres?

57
00:02:37,310 --> 00:02:39,490
É um número, como um número inteiro?

58
00:02:39,490 --> 00:02:41,390
É um ponto flutuante
valor, ou semelhantes?

59
00:02:41,390 --> 00:02:46,180
Assim, em C, ao contrário do risco, nós realmente
começou a especificar o tipo de dados

60
00:02:46,180 --> 00:02:48,330
estávamos voltando ou usando.

61
00:02:48,330 --> 00:02:51,910
>> Mas, é claro, nós também correu para
alguns limites fundamentais da computação.

62
00:02:51,910 --> 00:02:54,100
E, em particular,
essa linguagem C, recordação

63
00:02:54,100 --> 00:02:57,070
que nós demos uma olhada em
integer overflow, a realidade

64
00:02:57,070 --> 00:03:00,460
que, se você tiver apenas um
quantidade finita de memória

65
00:03:00,460 --> 00:03:04,600
ou, especificamente, um número finito
de bits, você só pode contar tão alto.

66
00:03:04,600 --> 00:03:08,460
E assim nós olhamos para este exemplo aqui
em que um contador em um avião,

67
00:03:08,460 --> 00:03:13,510
na verdade, se correr o tempo suficiente seria
transbordar e resultar em um software

68
00:03:13,510 --> 00:03:15,560
um erro potencial físico real.

69
00:03:15,560 --> 00:03:18,600
>> Também olhou para flutuante
ponto de imprecisão, a realidade

70
00:03:18,600 --> 00:03:22,280
que, com apenas um número finito
de bits, se é 32 ou 64,

71
00:03:22,280 --> 00:03:27,330
você só pode especificar tantos números
após um ponto decimal, após o qual você

72
00:03:27,330 --> 00:03:29,110
começam a ficar imprecisa.

73
00:03:29,110 --> 00:03:32,360
Assim, por exemplo, um terço na
mundo aqui, no nosso mundo humano,

74
00:03:32,360 --> 00:03:35,360
o que sabemos é apenas um número infinito
de 3s após o ponto decimal.

75
00:03:35,360 --> 00:03:38,820
Mas um computador não pode necessariamente
representam um número infinito de números

76
00:03:38,820 --> 00:03:42,590
se você permitir apenas que alguns
quantidade finita de informação.

77
00:03:42,590 --> 00:03:45,900
>> Assim, não só nós equipá-lo
com maior poder em termos

78
00:03:45,900 --> 00:03:49,280
de como você pode expressar-se em
um teclado em termos de programação,

79
00:03:49,280 --> 00:03:51,430
nós também limita o
você pode realmente fazer.

80
00:03:51,430 --> 00:03:55,790
E, de fato, os erros e os erros podem
surgem a partir desses tipos de problemas.

81
00:03:55,790 --> 00:03:59,900
E, de fato, entre os temas hoje
vão ser temas como a depuração

82
00:03:59,900 --> 00:04:03,699
e, na verdade, olhando por baixo do capuz
a forma como as coisas foram introduzidos na semana passada

83
00:04:03,699 --> 00:04:05,490
são realmente implementadas
de modo que é melhor você

84
00:04:05,490 --> 00:04:10,530
compreender tanto as capacidades de e
as limitações de uma linguagem como C.

85
00:04:10,530 --> 00:04:14,770
>> E, de fato, vamos descascar as camadas
dos mais simples de estrutura de dados,

86
00:04:14,770 --> 00:04:17,756
algo chamado um array, que
Zero acontece para chamar uma "lista".

87
00:04:17,756 --> 00:04:19,589
É um pouco
diferente nesse contexto.

88
00:04:19,589 --> 00:04:23,340
E então nós também vamos apresentar um dos
primeiro dos nossos problemas específicos do domínio

89
00:04:23,340 --> 00:04:26,790
em CS50, o mundo da
criptografia, a arte de cifragem

90
00:04:26,790 --> 00:04:29,650
ou cifrar informações para
que você pode enviar mensagens secretas

91
00:04:29,650 --> 00:04:34,520
e descodificar mensagens secretas
entre duas pessoas, A e B.

92
00:04:34,520 --> 00:04:37,490
>> Portanto, antes de transição,
a esse novo mundo,

93
00:04:37,490 --> 00:04:42,059
vamos tentar equipá-lo com algum
técnicas com as quais você pode eliminar

94
00:04:42,059 --> 00:04:43,850
ou reduzir, pelo menos, alguns
das frustrações

95
00:04:43,850 --> 00:04:46,630
que você provavelmente já encontrou
ao longo da última semana sozinho.

96
00:04:46,630 --> 00:04:50,830
Na verdade, antes de você são alguns dos such--
seus primeiros problemas em C. E as probabilidades são,

97
00:04:50,830 --> 00:04:54,010
se você é como eu, pela primeira vez
tenta escrever um programa,

98
00:04:54,010 --> 00:04:57,330
mesmo se você pensar logicamente
o programa é bastante simples,

99
00:04:57,330 --> 00:05:01,200
você pode muito bem bater em uma parede, e
o compilador não vai cooperar.

100
00:05:01,200 --> 00:05:03,940
Fazer ou Clang não vai
para realmente fazer o seu lance.

101
00:05:03,940 --> 00:05:05,450
>> E por que pode ser isso?

102
00:05:05,450 --> 00:05:07,950
Bem, vamos dar uma olhada,
talvez, um programa simples.

103
00:05:07,950 --> 00:05:11,190
Eu estou indo para ir em frente e salvar isto em
um arquivo chamado deliberadamente buggy0.c,

104
00:05:11,190 --> 00:05:13,590
porque eu sei que a
ser falho com antecedência.

105
00:05:13,590 --> 00:05:17,400
Mas pode não perceber que, se esta
é o primeiro ou segundo ou terceiro programa

106
00:05:17,400 --> 00:05:18,830
que eu realmente estou me tornando.

107
00:05:18,830 --> 00:05:23,820
Então, eu estou indo para ir em frente e
digitar, int main (void).

108
00:05:23,820 --> 00:05:28,130
E, em seguida, dentro das minhas chaves,
muito familiar ( "Olá, mundo--

109
00:05:28,130 --> 00:05:30,980
barra invertida, n ") - e um ponto e vírgula.

110
00:05:30,980 --> 00:05:32,360
>> Eu salvou o arquivo.

111
00:05:32,360 --> 00:05:34,850
Agora eu estou indo para ir para baixo
na minha janela de terminal

112
00:05:34,850 --> 00:05:40,340
e tipo make buggy0, porque, novamente,
o nome do arquivo é hoje buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Então eu digito fazer buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> E, oh, Deus, lembro da última vez
que nenhuma mensagem de erro é uma coisa boa.

115
00:05:48,200 --> 00:05:49,740
Assim, nenhuma saída é uma coisa boa.

116
00:05:49,740 --> 00:05:52,920
Mas aqui eu tenho claramente
um certo número de erros.

117
00:05:52,920 --> 00:05:56,470
>> Assim, a primeira linha de saída
depois de digitar fazer buggy0, recall,

118
00:05:56,470 --> 00:05:59,540
é emitido bastante detalhado do Clang.

119
00:05:59,540 --> 00:06:02,067
Debaixo do capô,
IDE é configurado CS50

120
00:06:02,067 --> 00:06:04,150
para usar um monte de
opções com este compilador

121
00:06:04,150 --> 00:06:05,941
de modo que você não tem
para pensar sobre eles.

122
00:06:05,941 --> 00:06:08,840
E isso é tudo que a primeira linha
meios que começa com Clang.

123
00:06:08,840 --> 00:06:11,720
>> Mas depois disso, os problemas
começar a fazer a sua aparência.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c na linha 3, caráter
5, existe um grande erro, vermelho.

125
00:06:17,390 --> 00:06:18,380
O que é isso?

126
00:06:18,380 --> 00:06:23,562
Implicitamente declarando função de biblioteca
printf com o tipo int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Quero dizer, muito rapidamente
fica muito misterioso.

129
00:06:28,379 --> 00:06:30,170
E, certamente, à primeira
vista, não queremos

130
00:06:30,170 --> 00:06:32,380
espero que você entenda o
totalidade da mensagem.

131
00:06:32,380 --> 00:06:34,213
E assim uma das lições
para hoje vai

132
00:06:34,213 --> 00:06:36,919
ser a de tentar perceber
padrões, ou coisas semelhantes,

133
00:06:36,919 --> 00:06:38,960
a erros que você pode ter
encontradas no passado.

134
00:06:38,960 --> 00:06:41,335
Então, vamos provocar única apart
aquelas palavras que olha familiar.

135
00:06:41,335 --> 00:06:44,290
O grande, vermelho de erro é claramente
simbólica de que algo está errado.

136
00:06:44,290 --> 00:06:47,940
>> implicitamente declarando
biblioteca printf função.

137
00:06:47,940 --> 00:06:51,680
Assim, mesmo se eu não entendo muito bem o que
declarar implicitamente função de biblioteca

138
00:06:51,680 --> 00:06:54,900
meios, o problema certamente
refere-se a printf de alguma forma.

139
00:06:54,900 --> 00:06:59,130
E a fonte desse problema
tem a ver com o declarar.

140
00:06:59,130 --> 00:07:02,440
>> Declarar uma função é
mencioná-lo pela primeira vez.

141
00:07:02,440 --> 00:07:06,210
E usamos a terminologia na semana passada
de declarar um protótipo de função,

142
00:07:06,210 --> 00:07:11,860
ou com uma linha na parte superior do seu
próprio arquivo ou em um arquivo de cabeçalho chamado.

143
00:07:11,860 --> 00:07:15,300
E em que arquivo fez dizemos
na semana passada que printf é citar,

144
00:07:15,300 --> 00:07:17,080
unquote, declarou?

145
00:07:17,080 --> 00:07:20,950
Em qual arquivo é o seu protótipo?

146
00:07:20,950 --> 00:07:24,640
>> Então, se você se lembra, a primeira coisa que eu
digitado, quase todos os programas última vez--

147
00:07:24,640 --> 00:07:30,790
e, acidentalmente, um momento atrás começou
digitando myself-- foi esta aqui--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- para
input / output-- dot h E, de fato,

149
00:07:38,630 --> 00:07:41,860
se eu agora salve este arquivo, eu vou
para ir em frente e limpar minha tela,

150
00:07:41,860 --> 00:07:44,740
que pode ser feito digitando
Limpar, ou pode manter controle de L,

151
00:07:44,740 --> 00:07:47,680
apenas para limpar a sua janela de terminal
apenas para eliminar alguma desordem.

152
00:07:47,680 --> 00:07:51,370
>> Eu estou indo para ir em frente e
re-digite make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
E pronto, eu ainda ver que
comando longo de Clang,

154
00:07:53,790 --> 00:07:55,470
mas não há nenhuma mensagem de erro neste momento.

155
00:07:55,470 --> 00:07:58,800
E, de fato, se eu fizer ./buggy0,
Como da última vez,

156
00:07:58,800 --> 00:08:01,860
onde ponto significa esta
directório, Slash apenas significa,

157
00:08:01,860 --> 00:08:05,040
aqui vem o nome do programa e
que nome do programa é buggy0,

158
00:08:05,040 --> 00:08:07,340
Enter, "Olá, mundo".

159
00:08:07,340 --> 00:08:09,440
>> Agora, como você pode ter
esta solução adquirida

160
00:08:09,440 --> 00:08:12,017
sem necessariamente
reconhecendo como muitas palavras

161
00:08:12,017 --> 00:08:14,350
como eu fiz, certamente, ter
feito isso por tantos anos?

162
00:08:14,350 --> 00:08:18,720
Bem, perceber por o primeiro problema
set, vamos apresentar-lhe um comando

163
00:08:18,720 --> 00:08:21,175
que a própria equipe do CS50
escreveu chamado help50.

164
00:08:21,175 --> 00:08:24,300
E, de fato, C faz especificação para
o conjunto de problemas a respeito de como usar isso.

165
00:08:24,300 --> 00:08:27,210
>> Mas é essencialmente help50
um programa que o pessoal do CS50

166
00:08:27,210 --> 00:08:30,850
escreveu que permite que você execute
um comando ou executar um programa,

167
00:08:30,850 --> 00:08:36,169
e se você não compreender a sua
de saída, para passar a sua saída para help50,

168
00:08:36,169 --> 00:08:38,890
altura em que o software
que o pessoal do curso escreveu

169
00:08:38,890 --> 00:08:42,429
vai olhar para a saída de seu programa
linha por linha, caractere por caractere.

170
00:08:42,429 --> 00:08:46,000
E se nós, os funcionários, reconhecer o
mensagem de erro que você está experimentando,

171
00:08:46,000 --> 00:08:50,580
vamos tentar provocá-lo com algum
perguntas retóricas, com alguns conselhos,

172
00:08:50,580 --> 00:08:54,890
bem como um TF ou de uma CA ou eu mesmo
faria pessoalmente no horário de expediente.

173
00:08:54,890 --> 00:08:58,320
>> Então olhe para help50 se não o fizer
-se reconhecer necessariamente um problema.

174
00:08:58,320 --> 00:09:00,790
Mas não contar com ele
muito como uma muleta.

175
00:09:00,790 --> 00:09:03,990
Certamente tentar entender a sua
de saída e, em seguida, aprender com ele

176
00:09:03,990 --> 00:09:07,571
de modo que apenas uma ou duas vezes você
nunca correr help50 para um erro específico

177
00:09:07,571 --> 00:09:08,070
mensagem.

178
00:09:08,070 --> 00:09:10,660
Depois disso, você deve ser
melhor equipado-se

179
00:09:10,660 --> 00:09:13,180
para descobrir o que ele realmente é.

180
00:09:13,180 --> 00:09:14,350
>> Vamos fazer um outro aqui.

181
00:09:14,350 --> 00:09:20,410
Deixe-me ir em frente, e em outro
arquivo vamos chamar este buggy1.c.

182
00:09:20,410 --> 00:09:23,110
E neste arquivo que eu sou
vai deliberately--

183
00:09:23,110 --> 00:09:26,330
mas fingir que eu não
entender o erro que eu fiz.

184
00:09:26,330 --> 00:09:31,420
>> Eu estou indo para ir em frente e fazer isto--
#include, desde que eu tenho

185
00:09:31,420 --> 00:09:33,660
aprendi minha lição de um momento atrás.

186
00:09:33,660 --> 00:09:36,220
Int main (void), como antes.

187
00:09:36,220 --> 00:09:40,880
E então aqui eu vou
para fazer corda s - get_string.

188
00:09:40,880 --> 00:09:43,770
E lembro da última vez que
este meio, hey, computador,

189
00:09:43,770 --> 00:09:48,280
dá-me uma variável, chame-s, e
fazer o tipo dessa variável uma string

190
00:09:48,280 --> 00:09:50,150
para que eu possa armazenar uma ou mais palavras nele.

191
00:09:50,150 --> 00:09:52,191
>> E em seguida, no lado direito
lado do sinal de igual

192
00:09:52,191 --> 00:09:54,980
é get_string, que é um
função na biblioteca CS50

193
00:09:54,980 --> 00:09:55,980
que faz exatamente isso.

194
00:09:55,980 --> 00:09:59,740
Ela recebe uma função e, em seguida,
mãos da direita para a esquerda.

195
00:09:59,740 --> 00:10:02,670
Portanto, este sinal de igual não significa
"Iguais" como poderíamos pensar em matemática.

196
00:10:02,670 --> 00:10:04,750
Isso significa que a atribuição da direita para a esquerda.

197
00:10:04,750 --> 00:10:09,640
Então isso significa, tomar a seqüência de
o usuário e armazená-lo dentro de s.

198
00:10:09,640 --> 00:10:10,460
>> Agora vamos usá-lo.

199
00:10:10,460 --> 00:10:13,820
Deixe-me ir em frente agora e como uma segunda
linha, deixe-me ir em frente e dizer "Olá" -

200
00:10:13,820 --> 00:10:19,330
não "mundo", mas "Olá,% s--
que é o nosso espaço reservado, vírgula s,

201
00:10:19,330 --> 00:10:22,030
que é a nossa variável,
e, em seguida, um ponto e vírgula.

202
00:10:22,030 --> 00:10:26,070
Então, se eu não estragar demais
aqui, isso parece correta do código.

203
00:10:26,070 --> 00:10:28,090
>> E meus instintos são agora compilá-lo.

204
00:10:28,090 --> 00:10:30,400
O arquivo é chamado buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Então eu vou fazer fazer buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
E ma-lo, se não houver
até mesmo mais erros do que antes.

207
00:10:36,377 --> 00:10:38,210
Quer dizer, há mais
mensagens de erro que faria

208
00:10:38,210 --> 00:10:40,400
Parece que as linhas reais neste programa.

209
00:10:40,400 --> 00:10:42,730
>> Mas o takeaway aqui é,
mesmo se você está sobrecarregado

210
00:10:42,730 --> 00:10:45,040
com dois ou três ou
mais quatro mensagens de erro,

211
00:10:45,040 --> 00:10:48,340
concentrar sempre sobre o próprio
primeira dessas mensagens.

212
00:10:48,340 --> 00:10:52,220
Olhando para o mais alto um,
rolagem de volta sempre que necessário.

213
00:10:52,220 --> 00:10:53,930
Então aqui eu digitei make buggy1.

214
00:10:53,930 --> 00:10:55,700
Aqui é que a produção Clang como esperado.

215
00:10:55,700 --> 00:10:57,290
>> E aqui está o primeiro erro vermelho.

216
00:10:57,290 --> 00:11:02,370
Uso de identificador não declarado
corda, que eu quero dizer padrão em?

217
00:11:02,370 --> 00:11:04,260
Assim, em padrão é
realmente outra coisa.

218
00:11:04,260 --> 00:11:06,240
Ele se refere ao usuário do
teclado, essencialmente.

219
00:11:06,240 --> 00:11:08,080
>> Mas não é isso que eu quis dizer.

220
00:11:08,080 --> 00:11:11,770
Eu quis dizer corda, e eu quis dizer get_string.

221
00:11:11,770 --> 00:11:16,200
Então o que é que eu
esqueceu de fazer desta vez?

222
00:11:16,200 --> 00:11:20,230
O que está faltando neste momento?

223
00:11:20,230 --> 00:11:23,600
Eu tenho o meu #include,
então eu tenho acesso a printf.

224
00:11:23,600 --> 00:11:26,090
>> Mas o que eu não tenho
acesso a apenas ainda?

225
00:11:26,090 --> 00:11:29,420
Bem, assim como da última vez,
Eu preciso dizer ao compilador

226
00:11:29,420 --> 00:11:31,691
Clang o que essas funções são.

227
00:11:31,691 --> 00:11:33,940
O get_string não vem
com C. E, em particular, ele

228
00:11:33,940 --> 00:11:38,160
não vem na
cabeçalho do arquivo,.

229
00:11:38,160 --> 00:11:40,770
Em vez disso vem em
algo que a equipe escreveu,

230
00:11:40,770 --> 00:11:44,176
que é um arquivo diferente
nome, mas apropriadamente chamado.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Então, simplesmente adicionando que uma linha
da recordação code-- da última vez

233
00:11:50,861 --> 00:11:53,610
que quando Clang é executado, ele vai
a olhar para o meu top código para baixo,

234
00:11:53,610 --> 00:11:54,193
da esquerda para direita.

235
00:11:54,193 --> 00:11:57,200
Vai notar,
oh, você quer.

236
00:11:57,200 --> 00:11:59,900
Deixe-me ir e descobrir que,
onde quer que seja no servidor,

237
00:11:59,900 --> 00:12:03,090
copiar e colá-lo, essencialmente,
na parte superior do seu próprio arquivo

238
00:12:03,090 --> 00:12:06,820
de modo que, neste ponto da história,
A linha 1, o resto do programa

239
00:12:06,820 --> 00:12:11,651
pode, de fato, usar qualquer uma das funções
nele, entre eles get_string.

240
00:12:11,651 --> 00:12:13,650
Então, eu vou ignorar
o resto desses erros,

241
00:12:13,650 --> 00:12:17,190
porque eu, na verdade, suspeito que apenas
o primeiro realmente importava.

242
00:12:17,190 --> 00:12:20,780
E eu estou indo para ir em frente e reprise,
depois de salvar meu arquivo fazer buggy1.

243
00:12:20,780 --> 00:12:22,580
E pronto, ele fez trabalho.

244
00:12:22,580 --> 00:12:29,200
E se eu fizer ./buggy1 e digite, por
exemplo, Zamyla, agora terá Olá,

245
00:12:29,200 --> 00:12:32,000
Zamyla, em vez de Olá, mundo.

246
00:12:32,000 --> 00:12:32,550
>> Tudo certo.

247
00:12:32,550 --> 00:12:35,890
Assim, os takeaways aqui, em seguida, devem,
um, tentar recolher o máximo que puder

248
00:12:35,890 --> 00:12:39,140
a partir das mensagens de erro por si só, olhando
Em algumas das palavras reconhecíveis.

249
00:12:39,140 --> 00:12:43,070
Exceto isso, use help50 per
o conjunto de problemas especificação.

250
00:12:43,070 --> 00:12:46,500
Mas tirando isso, também, sempre olhar
no topo de erro única, pelo menos

251
00:12:46,500 --> 00:12:50,051
inicialmente, para ver quais informações
ele pode realmente render.

252
00:12:50,051 --> 00:12:52,300
Mas acontece que há
ainda mais funcionalidade embutida

253
00:12:52,300 --> 00:12:55,030
para a Biblioteca CS50 para ajudar
você logo no início do semestre

254
00:12:55,030 --> 00:12:57,580
e no início da programação
descobrir o que está acontecendo de errado.

255
00:12:57,580 --> 00:12:59,840
Então vamos fazer um outro exemplo aqui.

256
00:12:59,840 --> 00:13:04,350
Vou chamar este buggy2, que,
mais uma vez, vai ser falho fora

257
00:13:04,350 --> 00:13:05,650
do portão, por design.

258
00:13:05,650 --> 00:13:09,980
>> E eu estou indo para ir em frente
e fazer #include.

259
00:13:09,980 --> 00:13:12,580
E então eu vou fazer int main (void).

260
00:13:12,580 --> 00:13:14,840
E então eu vou fazer um loop.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i é menos do que ou igual a 10.

263
00:13:18,750 --> 00:13:24,260
i ++, e em seguida, entre chaves, eu vou
para imprimir apenas um símbolo hashtag aqui

264
00:13:24,260 --> 00:13:25,920
e um novo caractere de linha.

265
00:13:25,920 --> 00:13:29,220
>> Assim, a minha intenção com este
programa é bastante simples

266
00:13:29,220 --> 00:13:33,150
para repetir 10 vezes
e em cada iteração

267
00:13:33,150 --> 00:13:35,260
de cada vez que o circuito
ao longo do ciclo,

268
00:13:35,260 --> 00:13:37,660
imprimir uma hashtag,
uma hashtag, uma hashtag.

269
00:13:37,660 --> 00:13:40,480
Uma linha por causa I
tem a nova linha de ali.

270
00:13:40,480 --> 00:13:42,787
E recordar que o de
loop, por último week--

271
00:13:42,787 --> 00:13:44,620
e você vai ter mais
familiarizados com a sintaxe

272
00:13:44,620 --> 00:13:47,170
usando-o com a prática
antes long-- isso me dá

273
00:13:47,170 --> 00:13:49,740
uma variável chamada i e define-o como 0.

274
00:13:49,740 --> 00:13:52,650
>> Isso incrementa i na
cada iteração em 1.

275
00:13:52,650 --> 00:13:54,940
Assim i vai para 1 a 2 a 3.

276
00:13:54,940 --> 00:13:57,690
E então esta condição na
meio entre os pontos e vírgulas

277
00:13:57,690 --> 00:14:03,010
checado a cada iteração para fazer
Certifique-se de que ainda estão dentro do alcance.

278
00:14:03,010 --> 00:14:06,830
Então, eu quero fazer uma iteração 10 vezes, então eu
temos um tipo de muito intuitivamente apenas

279
00:14:06,830 --> 00:14:09,070
colocar 10 como o meu limite superior lá.

280
00:14:09,070 --> 00:14:14,310
>> E ainda assim, quando eu executar este, depois de
compilá-lo com o make buggy2--

281
00:14:14,310 --> 00:14:15,440
e ele não compilar OK.

282
00:14:15,440 --> 00:14:17,980
Então, eu não tenho um
erro de sintaxe desta vez.

283
00:14:17,980 --> 00:14:20,940
Deixe-me ir em frente agora
e executar buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
E agora vá para cima.

285
00:14:22,620 --> 00:14:24,890
E deixe-me aumentar
o tamanho da janela.

286
00:14:24,890 --> 00:14:33,720
>> Eu pareço ter 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Portanto, há 11 hashtags, embora
Eu coloquei claramente 10 dentro deste loop.

288
00:14:38,891 --> 00:14:42,140
Agora, alguns de vocês podem ver imediatamente
o que o erro é porque, de fato, este

289
00:14:42,140 --> 00:14:43,720
não é um erro muito difícil de fazer.

290
00:14:43,720 --> 00:14:46,070
Mas é muito comumente
feita muito cedo.

291
00:14:46,070 --> 00:14:49,820
>> O que eu quero salientar, no entanto,
é, como eu poderia descobrir isso?

292
00:14:49,820 --> 00:14:52,300
Bem, verifica-se que
Biblioteca CS50 vem

293
00:14:52,300 --> 00:14:55,380
não só com get_string e get_int
e get_float e outras funções.

294
00:14:55,380 --> 00:14:59,980
Ele também vem com uma função especial
chamado eprintf ou, erro printf.

295
00:14:59,980 --> 00:15:03,270
E existe unicamente para fazer
-lo um pouco mais fácil para você

296
00:15:03,270 --> 00:15:06,310
ao depurar seu código para apenas
imprimir uma mensagem de erro no ecrã

297
00:15:06,310 --> 00:15:07,850
e saber de onde veio.

298
00:15:07,850 --> 00:15:11,000
>> Assim, por exemplo, uma coisa que eu poderia
fazer aqui com esta função é isto--

299
00:15:11,000 --> 00:15:20,230
eprintf, e então eu estou indo para ir em frente
e dizer que está agora% i, barra invertida, n.

300
00:15:20,230 --> 00:15:22,330
E eu vou ligar o valor de i.

301
00:15:22,330 --> 00:15:25,400
E em cima, porque este
está na Biblioteca CS50,

302
00:15:25,400 --> 00:15:27,580
Eu estou indo para ir em frente
e incluir

303
00:15:27,580 --> 00:15:29,169
então eu tenho acesso a esta função.

304
00:15:29,169 --> 00:15:31,460
Mas vamos considerar o que linha
9 é suposto estar a fazer.

305
00:15:31,460 --> 00:15:32,670
Eu vou apagar este eventualmente.

306
00:15:32,670 --> 00:15:34,670
Isto não tem nada a ver
com o meu objectivo global.

307
00:15:34,670 --> 00:15:39,090
Mas eprintf, printf de erro, é apenas significou
para me dar algumas informações de diagnóstico.

308
00:15:39,090 --> 00:15:42,460
Quando eu executar o meu programa, eu quero
ver isso na tela temporariamente

309
00:15:42,460 --> 00:15:44,550
bem só para entender
o que está acontecendo.

310
00:15:44,550 --> 00:15:47,330
>> E, de fato, em cada
iteração aqui da linha 9

311
00:15:47,330 --> 00:15:49,260
Eu quero ver, qual é o valor de i?

312
00:15:49,260 --> 00:15:50,290
O que é o valor de i?

313
00:15:50,290 --> 00:15:51,280
O que é o valor de i?

314
00:15:51,280 --> 00:15:55,650
E, esperançosamente, eu só deve
veja essa mensagem, também, 10 vezes.

315
00:15:55,650 --> 00:15:57,780
>> Então deixe-me ir em frente e
recompilar o meu programa,

316
00:15:57,780 --> 00:15:59,905
como eu tenho que fazer a qualquer hora
I fazer uma mudança. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
E agora-- OK.

319
00:16:03,640 --> 00:16:04,820
Há muito mais acontecendo.

320
00:16:04,820 --> 00:16:07,610
Então deixe-me rolar para cima no
uma janela ainda maior.

321
00:16:07,610 --> 00:16:10,190
>> E você verá que cada um de
o hashtags ainda está imprimindo.

322
00:16:10,190 --> 00:16:15,270
Mas entre cada um deles é agora este
saída de diagnóstico formatado como segue.

323
00:16:15,270 --> 00:16:17,960
O nome do meu programa aqui é buggy2.

324
00:16:17,960 --> 00:16:20,432
O nome do arquivo é buggy2.c.

325
00:16:20,432 --> 00:16:24,080
O número da linha a partir da qual
este foi impressa é a linha 9.

326
00:16:24,080 --> 00:16:27,500
E, em seguida, para a direita do que é a
mensagem de erro que eu estou esperando.

327
00:16:27,500 --> 00:16:30,701
>> E o que é bom sobre isso é que
Agora eu não tenho que contar, necessariamente,

328
00:16:30,701 --> 00:16:32,200
na minha cabeça que o meu programa está fazendo.

329
00:16:32,200 --> 00:16:34,240
Eu posso ver que na
primeira iteração i é 0,

330
00:16:34,240 --> 00:16:39,420
em seguida, 1, em seguida 2, em seguida, 3, 4, em seguida, em seguida
5, em seguida, 6, 7, em seguida, em seguida, 8, 9, em seguida, em seguida

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Então, espere um minuto.

333
00:16:42,050 --> 00:16:43,740
Oque esta acontecendo aqui?

334
00:16:43,740 --> 00:16:48,190
Eu ainda parecem estar contando
como pretendido até 10.

335
00:16:48,190 --> 00:16:50,550
>> Mas onde eu começo?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Assim, 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- o 11º dedo

338
00:16:58,040 --> 00:16:59,990
é indicativa do problema.

339
00:16:59,990 --> 00:17:02,850
Parece-me ter contado
incorretamente no meu loop.

340
00:17:02,850 --> 00:17:06,599
Ao invés de ir para 10 iterações,
Estou começando a 0,

341
00:17:06,599 --> 00:17:09,550
Estou terminando em e através de 10.

342
00:17:09,550 --> 00:17:12,030
Mas porque, como um computador,
Estou começando a contagem em 0,

343
00:17:12,030 --> 00:17:15,250
Eu deveria estar contando
para, mas não através, 10.

344
00:17:15,250 --> 00:17:18,510
>> E assim a correção, eu finalmente
percebi aqui, é uma das duas coisas.

345
00:17:18,510 --> 00:17:22,430
Eu poderia muito simplesmente dizer
contam-se a menos de 10.

346
00:17:22,430 --> 00:17:27,260
Assim, 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, que é, de fato, correto,

347
00:17:27,260 --> 00:17:28,900
mesmo que isso soa um pouco errado.

348
00:17:28,900 --> 00:17:35,070
Ou eu poderia fazer igual ou inferior
a 9, enquanto eu começo a 0.

349
00:17:35,070 --> 00:17:40,056
Ou se você realmente não gosta disso, você
pode contar-se a 10, mas começar em 1.

350
00:17:40,056 --> 00:17:41,680
Mas, novamente, isso não é tão comum.

351
00:17:41,680 --> 00:17:43,977
Em programming-- embora
não tanto em Scratch--

352
00:17:43,977 --> 00:17:45,810
mas em programação em
C e outras linguagens,

353
00:17:45,810 --> 00:17:47,670
como JavaScript e
Python e outros, é

354
00:17:47,670 --> 00:17:49,880
apenas muito comum para
nossa discussão de binário

355
00:17:49,880 --> 00:17:53,450
apenas para começar a contar no
menor número possível, que é 0.

356
00:17:53,450 --> 00:17:53,950
Tudo certo.

357
00:17:53,950 --> 00:17:55,160
Então, isso é eprintf.

358
00:17:55,160 --> 00:17:58,600
E mais uma vez, agora que eu descobri o meu
problema, e eu vou voltar para 0

359
00:17:58,600 --> 00:18:01,470
através de menos de 10, eu vou
para entrar e apagar eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Ele não deveria estar lá quando eu
Envio o meu código ou enviar o meu código

361
00:18:04,580 --> 00:18:05,800
ou mostrá-lo a ninguém.

362
00:18:05,800 --> 00:18:07,980
É realmente apenas significou
para ser utilizado temporariamente.

363
00:18:07,980 --> 00:18:11,650
Mas agora eu reparei isso
nomeadamente problema bem.

364
00:18:11,650 --> 00:18:16,780
>> Bem, vamos fazer mais um exemplo aqui
que eu estou indo para chicotear acima da seguinte forma.

365
00:18:16,780 --> 00:18:22,850
Eu estou indo para ir em frente e
#incluir . $ 50

366
00:18:22,850 --> 00:18:25,580
E eu estou indo para ir em frente
e #include.

367
00:18:25,580 --> 00:18:29,030
>> E eu estou indo para salvar
este arquivo como buggy3.c.

368
00:18:29,030 --> 00:18:31,740
E eu estou indo para ir em frente
e declarar int main (void).

369
00:18:31,740 --> 00:18:34,186
E então lá dentro
Eu vou fazer int i _ -

370
00:18:34,186 --> 00:18:36,435
Eu quero implementar um programa
com um get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Esta não é uma função que existe ainda.

373
00:18:40,770 --> 00:18:42,870
Então, nós estamos indo para implementar
-lo em apenas um momento.

374
00:18:42,870 --> 00:18:45,541
Mas vamos ver o porquê
é de buggy na primeira passagem.

375
00:18:45,541 --> 00:18:47,290
E uma vez que eu comecei
um int do utilizador,

376
00:18:47,290 --> 00:18:53,365
Eu só vou para imprimir% i é um negativo
inteiro, barra invertida, n, vírgula, i.

377
00:18:53,365 --> 00:18:55,240
Em outras palavras, todos os I
quer este programa para fazer

378
00:18:55,240 --> 00:18:58,000
é obter um int negativa de
o usuário e, em seguida, imprimir

379
00:18:58,000 --> 00:18:59,980
que tal e tal é um int negativo.

380
00:18:59,980 --> 00:19:02,080
>> Agora eu preciso para implementar esta função.

381
00:19:02,080 --> 00:19:05,740
Então, mais tarde no meu arquivo, eu estou indo para ir
frente e declarar uma função chamada

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - e nós
voltar ao que essa linha significa novamente

383
00:19:10,670 --> 00:19:18,790
num moment-- int n; fazer-- fazer
o following-- printf n é :.

384
00:19:18,790 --> 00:19:26,210
E então eu vou fazer n - get_int,
e fazer isso enquanto n é maior que 0.

385
00:19:26,210 --> 00:19:28,310
E depois voltar n ;.

386
00:19:28,310 --> 00:19:31,730
>> Portanto, há muita coisa acontecendo em
isso, mas nenhum dos quais nós não

387
00:19:31,730 --> 00:19:33,710
olhar na semana passada, pelo menos momentaneamente.

388
00:19:33,710 --> 00:19:36,980
Assim, na linha 10 aqui eu tenho declarado
função chamada get_negative_int,

389
00:19:36,980 --> 00:19:39,620
e eu coloquei (void), em
parênteses, a razão de ser desta

390
00:19:39,620 --> 00:19:40,950
Não é preciso uma entrada.

391
00:19:40,950 --> 00:19:42,910
Eu não estou passando tudo
para esta função.

392
00:19:42,910 --> 00:19:44,690
Eu estou apenas começando algo de volta a partir dele.

393
00:19:44,690 --> 00:19:47,270
>> E o que eu estou esperando para
voltar é um inteiro.

394
00:19:47,270 --> 00:19:50,040
Não há nenhum tipo de dados em
C chamado negative_int.

395
00:19:50,040 --> 00:19:52,880
É só int, por isso vai
estar em nós para certificar-se de

396
00:19:52,880 --> 00:19:55,340
que o valor que é realmente
retornado é não só um int

397
00:19:55,340 --> 00:19:56,380
mas também é negativo.

398
00:19:56,380 --> 00:20:02,150
>> Na linha 12 Estou declarando uma variável
chamado n e tornando-a do tipo int.

399
00:20:02,150 --> 00:20:07,500
E, em seguida, na linha 13 a 18 que eu sou
fazendo algo enquanto algo é verdadeiro.

400
00:20:07,500 --> 00:20:11,040
Eu vou em frente e impressão
n é, do cólon, e em seguida, um espaço,

401
00:20:11,040 --> 00:20:12,800
como um aviso para o usuário.

402
00:20:12,800 --> 00:20:16,410
>> Estou em seguida, chamando get_int e
armazenar seu chamado valor de retorno

403
00:20:16,410 --> 00:20:18,130
nessa variável n.

404
00:20:18,130 --> 00:20:22,600
Mas eu vou continuar fazendo
enquanto esta n for maior do que 0.

405
00:20:22,600 --> 00:20:27,960
Em outras palavras, se o usuário-me um dá
int e esse número é maior que 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positivo, eu vou
basta manter reprompting o usuário,

407
00:20:31,180 --> 00:20:37,160
manter reprompting, forçando-os a
cooperar e me dar um int negativo.

408
00:20:37,160 --> 00:20:41,640
>> E uma vez que n é, na verdade negative--
Suponha que o usuário finalmente tipos -50,

409
00:20:41,640 --> 00:20:46,710
então este loop while não é mais verdade
-50 porque não é maior do que 0.

410
00:20:46,710 --> 00:20:51,140
Então, nós sair dessa
loop de lógica e retornar n.

411
00:20:51,140 --> 00:20:53,520
>> Mas há uma outra
coisa que tenho a fazer.

412
00:20:53,520 --> 00:20:56,190
E eu posso simplesmente fazer isso
copiando e colando

413
00:20:56,190 --> 00:20:58,540
uma linha de código na parte superior do arquivo.

414
00:20:58,540 --> 00:21:01,630
Eu preciso ensinar Clang,
ou promessa de Clang,

415
00:21:01,630 --> 00:21:04,630
explicitamente que eu quero,
na verdade, ir e implementar

416
00:21:04,630 --> 00:21:06,020
esta função get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Poderia ser apenas mais baixa no arquivo.

418
00:21:07,674 --> 00:21:09,840
Mais uma vez, lembrar que Clang
lê as coisas de cima para baixo,

419
00:21:09,840 --> 00:21:12,330
esquerda para a direita, de modo que não pode
chamar uma função, se Clang

420
00:21:12,330 --> 00:21:15,330
não sabe que vai existir.

421
00:21:15,330 --> 00:21:18,430
>> Agora, infelizmente, este programa,
Como alguns de vocês devem ter notado,

422
00:21:18,430 --> 00:21:19,590
já é buggy.

423
00:21:19,590 --> 00:21:21,400
Deixe-me ir em frente e fazer buggy3.

424
00:21:21,400 --> 00:21:26,904
Ele compila, por isso o meu problema agora não é
um erro de sintaxe, como um erro textual,

425
00:21:26,904 --> 00:21:29,570
ele é, na verdade, vai ser uma lógica
erro que eu tenho deliberadamente

426
00:21:29,570 --> 00:21:32,450
feita como uma oportunidade de
percorrer o que está acontecendo.

427
00:21:32,450 --> 00:21:35,540
>> Eu estou indo para ir em frente
agora e executar buggy3.

428
00:21:35,540 --> 00:21:37,490
E eu estou indo para ir
em frente e não cooperar.

429
00:21:37,490 --> 00:21:39,494
Vou dar-lhe o número 1.

430
00:21:39,494 --> 00:21:41,410
Ele não gostou, então
isso está me levando novamente.

431
00:21:41,410 --> 00:21:42,147
>> Como cerca de 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Nenhum dos que estão trabalhando.

435
00:21:44,740 --> 00:21:46,890
Como cerca de -50?

436
00:21:46,890 --> 00:21:48,560
E o programa parece funcionar.

437
00:21:48,560 --> 00:21:49,970
>> Deixe-me tentar mais uma vez.

438
00:21:49,970 --> 00:21:53,400
Deixe-me tentar -1, parece funcionar.

439
00:21:53,400 --> 00:21:56,380
Deixe-me tentar -2, parece funcionar.

440
00:21:56,380 --> 00:21:59,640
Deixe-me tentar 0.

441
00:21:59,640 --> 00:22:01,684
Huh, isso é incorreto.

442
00:22:01,684 --> 00:22:03,350
Agora, estamos sendo um pouco pedante aqui.

443
00:22:03,350 --> 00:22:07,090
Mas é, na verdade, o caso que 0
não é nem positivo nem negativo.

444
00:22:07,090 --> 00:22:11,150
E assim o fato de que meu programa é
dizendo que 0 é um inteiro negativo,

445
00:22:11,150 --> 00:22:12,820
isso não é tecnicamente correto.

446
00:22:12,820 --> 00:22:15,180
>> Agora, por que ele está fazendo isso?

447
00:22:15,180 --> 00:22:16,270
Bem, pode ser óbvio.

448
00:22:16,270 --> 00:22:18,110
E, de fato, o programa é
pretende ser bastante simples

449
00:22:18,110 --> 00:22:19,670
por isso temos algo para explorar.

450
00:22:19,670 --> 00:22:25,870
>> Mas vamos introduzir uma terceira depuração
técnica aqui chamado debug50.

451
00:22:25,870 --> 00:22:27,750
Portanto, este é um programa
que acabou de criar

452
00:22:27,750 --> 00:22:30,770
este ano chamado debug50
que permitirá que você

453
00:22:30,770 --> 00:22:34,130
usar o que é chamado um built-in
depurador gráfico no IDE CS50.

454
00:22:34,130 --> 00:22:38,400
E um depurador é apenas um programa que
geralmente permite que você execute o seu programa

455
00:22:38,400 --> 00:22:44,050
mas passo a passo a passo, linha
por linha por linha, parando, cutucando

456
00:22:44,050 --> 00:22:47,626
ao redor, olhando para as variáveis ​​de modo a que
o programa não só golpe passado você

457
00:22:47,626 --> 00:22:49,750
e imprimir rapidamente algo
ou não imprimir algo.

458
00:22:49,750 --> 00:22:53,250
Dá-lhe uma oportunidade, pelo
velocidade humana, para interagir com ele.

459
00:22:53,250 --> 00:22:55,470
>> E para fazer isso, você
simplesmente faça o seguinte.

460
00:22:55,470 --> 00:22:58,479
Depois de compilar seu código,
que eu já fiz, buggy3,

461
00:22:58,479 --> 00:23:00,020
vá em frente e correr debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Tão parecido com help50 tem de executar
help50 e então o comando,

464
00:23:06,760 --> 00:23:10,120
debug50 tem de executar debug50 e
em seguida, o nome do comando.

465
00:23:10,120 --> 00:23:14,440
>> Agora observe o que acontece na minha tela,
no lado da mão direita em particular.

466
00:23:14,440 --> 00:23:19,400
Quando eu bati Run, todos os
painel deste direito súbita

467
00:23:19,400 --> 00:23:20,419
abre na tela.

468
00:23:20,419 --> 00:23:22,210
E há muita coisa acontecendo
na à primeira vista.

469
00:23:22,210 --> 00:23:25,110
Mas não há muito
muito que se preocupar ainda.

470
00:23:25,110 --> 00:23:28,570
>> Isso está me mostrando tudo
que está acontecendo dentro do meu programa

471
00:23:28,570 --> 00:23:31,130
agora e através destes
botões para cima topo é então

472
00:23:31,130 --> 00:23:35,910
permitindo-me a percorrer o meu código
em última análise, passo a passo a passo.

473
00:23:35,910 --> 00:23:37,140
Mas ainda não.

474
00:23:37,140 --> 00:23:38,060
Observe o que acontece.

475
00:23:38,060 --> 00:23:40,600
Na minha janela de terminal
Estou sendo solicitado para n.

476
00:23:40,600 --> 00:23:44,560
E eu estou indo para ir em frente e
cooperar neste momento e digite -1.

477
00:23:44,560 --> 00:23:48,770
E embora um pouco enigmaticamente, -1
é um número inteiro negativo, como esperado.

478
00:23:48,770 --> 00:23:52,020
>> E, em seguida, filho terminou com
Status 0 gdbserver sair.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, é o nome
do software subjacente

480
00:23:55,180 --> 00:23:56,620
que implementa essa depurador.

481
00:23:56,620 --> 00:24:00,500
Mas tudo isso realmente significa, o depurador
foi embora porque o meu programa de sair

482
00:24:00,500 --> 00:24:01,710
e tudo estava bem.

483
00:24:01,710 --> 00:24:06,020
Se eu quiser depurar verdadeiramente meu programa,
Eu tenho que dizer preventivamente debug50,

484
00:24:06,020 --> 00:24:08,920
Onde eu gostaria de começar
percorrendo o meu código?

485
00:24:08,920 --> 00:24:11,750
>> E talvez a maneira mais simples
para fazer isto é como se segue.

486
00:24:11,750 --> 00:24:15,300
Se eu pairar sobre o
sarjeta do meu editor aqui,

487
00:24:15,300 --> 00:24:19,090
por isso realmente apenas na barra lateral aqui,
para a esquerda do número de linha,

488
00:24:19,090 --> 00:24:21,870
Observe que, se eu só clique
uma vez, eu coloquei um pequeno ponto vermelho.

489
00:24:21,870 --> 00:24:24,460
E aquele pequeno ponto vermelho,
como um sinal de parada, significa, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, execução de pausa do meu código
ali quando eu executar este programa.

491
00:24:29,430 --> 00:24:30,260
>> Então, vamos fazer isso.

492
00:24:30,260 --> 00:24:37,340
Deixe-me ir em frente e executar o meu programa
novamente com debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
E agora, o aviso prévio, algo
diferente aconteceu.

494
00:24:40,110 --> 00:24:42,440
Eu não estou sendo solicitado
ainda na minha janela de terminal

495
00:24:42,440 --> 00:24:45,430
para nada, porque eu não tenho
chegado lá ainda no meu programa.

496
00:24:45,430 --> 00:24:47,950
Observe que na linha 8
que agora está em destaque,

497
00:24:47,950 --> 00:24:51,720
e há uma pequena seta no
ditado esquerda, você está em pausa aqui.

498
00:24:51,720 --> 00:24:55,030
Esta linha de código, linha
8, ainda não foi executado.

499
00:24:55,030 --> 00:24:58,940
>> E o que é curioso, se eu olhar
aqui no lado da mão direita,

500
00:24:58,940 --> 00:25:03,530
Repare que eu é o local
variável, local no sentido

501
00:25:03,530 --> 00:25:05,450
que é dentro da função atual.

502
00:25:05,450 --> 00:25:08,920
E seu valor, aparentemente, por padrão,
e tipo de convenientemente, é 0.

503
00:25:08,920 --> 00:25:10,260
Mas eu não digite 0.

504
00:25:10,260 --> 00:25:13,410
Isso só acontece de ser sua
valor padrão no momento.

505
00:25:13,410 --> 00:25:15,490
>> Então deixe-me ir em frente e fazer isso agora.

506
00:25:15,490 --> 00:25:18,680
Deixe-me ir em frente e na
canto superior direito aqui, estou

507
00:25:18,680 --> 00:25:20,970
indo para ir em frente e
clique neste primeiro ícone que

508
00:25:20,970 --> 00:25:25,360
significa um passo sobre o que significa que não pule
mas passar por cima dessa linha de código,

509
00:25:25,360 --> 00:25:27,770
executá-lo ao longo do caminho.

510
00:25:27,770 --> 00:25:30,710
>> E agora, observe, meu
linha acaba de mudar.

511
00:25:30,710 --> 00:25:31,380
Por que é que?

512
00:25:31,380 --> 00:25:33,639
Eu disse debug50,
executar esta linha de código.

513
00:25:33,639 --> 00:25:34,930
O que é que esta linha de código faz?

514
00:25:34,930 --> 00:25:35,960
Leva-me para um int.

515
00:25:35,960 --> 00:25:36,460
ESTÁ BEM.

516
00:25:36,460 --> 00:25:37,400
Deixe-me cooperar.

517
00:25:37,400 --> 00:25:41,340
Deixe-me ir em frente agora e digite -1, Enter.

518
00:25:41,340 --> 00:25:42,920
E agora perceber o que mudou.

519
00:25:42,920 --> 00:25:46,060
No lado direito,
minha variável local i

520
00:25:46,060 --> 00:25:48,200
é indicado como sendo -1 agora.

521
00:25:48,200 --> 00:25:49,810
E ainda é do tipo int.

522
00:25:49,810 --> 00:25:53,102
>> E note, também, a minha chamada
chamar pilha, onde eu fazer uma pausa?

523
00:25:53,102 --> 00:25:54,810
Falaremos mais sobre
esta no futuro.

524
00:25:54,810 --> 00:25:58,620
Mas a pilha de chamadas apenas se refere ao que
funções estão em movimento.

525
00:25:58,620 --> 00:26:00,040
Agora é só principal.

526
00:26:00,040 --> 00:26:03,590
E agora o único local,
variável representa I, com um valor de 1.

527
00:26:03,590 --> 00:26:09,840
>> E quando eu finalmente passar por cima desta linha
aqui, com aquele mesmo ícone no canto superior direito,

528
00:26:09,840 --> 00:26:11,410
-1 É um inteiro negativo.

529
00:26:11,410 --> 00:26:13,580
Agora ele está parando ao longo desse chaveta.

530
00:26:13,580 --> 00:26:14,740
Vamos deixá-lo fazer a sua coisa.

531
00:26:14,740 --> 00:26:17,300
Eu passar por cima dessa linha, e voila.

532
00:26:17,300 --> 00:26:20,240
>> Então, nem tudo o que terrivelmente
esclarecedor ainda,

533
00:26:20,240 --> 00:26:23,550
mas me deixou fazer uma pausa
e pensar logicamente

534
00:26:23,550 --> 00:26:24,870
o que este programa está fazendo.

535
00:26:24,870 --> 00:26:26,890
Mas isso não foi o caso errônea.

536
00:26:26,890 --> 00:26:28,510
Vamos fazer isso de novo como se segue.

537
00:26:28,510 --> 00:26:31,340
>> Vou deixar esse ponto de interrupção
na linha 8 com o ponto vermelho.

538
00:26:31,340 --> 00:26:32,830
Eu estou indo para executar novamente debug50.

539
00:26:32,830 --> 00:26:34,400
É automaticamente uma pausa aqui.

540
00:26:34,400 --> 00:26:37,660
Mas desta vez, em vez de
pisando sobre esta linha,

541
00:26:37,660 --> 00:26:42,290
deixe-me realmente ir para dentro de
get_negative_int e descobrir,

542
00:26:42,290 --> 00:26:45,530
por que é aceitar 0 como uma resposta válida?

543
00:26:45,530 --> 00:26:47,990
>> Então, ao invés de clicar Step Over.

544
00:26:47,990 --> 00:26:50,630
Eu estou indo para ir em frente
e clique em Step Into.

545
00:26:50,630 --> 00:26:54,030
E observe que a linha 8 que é
agora destacado agora, de repente

546
00:26:54,030 --> 00:26:56,900
torna-se linha 17.

547
00:26:56,900 --> 00:26:59,947
>> Agora, não é que o depurador
tem ignorado as linhas 14 e 15 e 16.

548
00:26:59,947 --> 00:27:01,780
É só não há nada
para mostrar-lhe lá.

549
00:27:01,780 --> 00:27:04,050
Essas são apenas declarar variáveis,
E depois há a palavra Faça

550
00:27:04,050 --> 00:27:05,390
e depois uma chaveta aberto.

551
00:27:05,390 --> 00:27:09,227
A única linha funcional que é
suculento realmente é este aqui, 17.

552
00:27:09,227 --> 00:27:11,060
E é aí que nós temos
pausada automaticamente.

553
00:27:11,060 --> 00:27:13,870
>> Então printf ( "n.is:") ;, por isso
que ainda não aconteceu.

554
00:27:13,870 --> 00:27:18,250
Então, vamos em frente e clique Step Over.

555
00:27:18,250 --> 00:27:20,326
Agora, a minha linha, de fato,
alterado para ( "N é:").

556
00:27:20,326 --> 00:27:22,450
Agora get_int, eu não vou
incomodá entrando,

557
00:27:22,450 --> 00:27:24,750
porque esta função foi
feita por CS50 na Biblioteca.

558
00:27:24,750 --> 00:27:25,750
É provavelmente correto.

559
00:27:25,750 --> 00:27:28,440
>> Então, eu estou indo para ir em frente e
tipo de cooperar, dando-lhe

560
00:27:28,440 --> 00:27:30,590
um int, mas não um int negativo.

561
00:27:30,590 --> 00:27:32,870
Então deixe-me ir em frente e bateu 0.

562
00:27:32,870 --> 00:27:39,460
E agora o que acontece aqui
quando eu descer para a linha 21?

563
00:27:39,460 --> 00:27:40,890
Eu não tenho reiterou novamente.

564
00:27:40,890 --> 00:27:43,320
Eu não parecem ser preso nesse loop.

565
00:27:43,320 --> 00:27:45,990
Em outras palavras, este amarelo
bar não continue indo ao redor,

566
00:27:45,990 --> 00:27:47,130
e ao redor, e ao redor.

567
00:27:47,130 --> 00:27:48,340
>> Agora, por que isso?

568
00:27:48,340 --> 00:27:49,920
Bem, n, o que é n agora?

569
00:27:49,920 --> 00:27:53,280
Eu posso olhar para o local,
variáveis ​​no depurador.

570
00:27:53,280 --> 00:27:53,816
n é 0.

571
00:27:53,816 --> 00:27:55,190
Tudo bem, o que foi a minha condição?

572
00:27:55,190 --> 00:27:58,700
>> 20-- linha 20 é, bem,
0 é maior do que 0.

573
00:27:58,700 --> 00:27:59,500
Isso não é verdade.

574
00:27:59,500 --> 00:28:01,020
0 não é maior do que 0.

575
00:28:01,020 --> 00:28:02,820
E assim eu quebrei para fora deste.

576
00:28:02,820 --> 00:28:06,370
>> E é por isso que na linha
21, se eu realmente continuar,

577
00:28:06,370 --> 00:28:10,370
Eu estou indo para retornar 0, mesmo
embora eu deveria ter rejeitado 0

578
00:28:10,370 --> 00:28:12,484
a não ser realmente negativo.

579
00:28:12,484 --> 00:28:14,650
Então, agora, eu realmente não mesmo
se preocupam com o depurador.

580
00:28:14,650 --> 00:28:16,900
Entendi, eu não preciso
sei o que mais está acontecendo.

581
00:28:16,900 --> 00:28:19,233
>> Então, eu estou indo para ir em frente e
basta clicar no botão Play,

582
00:28:19,233 --> 00:28:20,240
e deixe este terminar.

583
00:28:20,240 --> 00:28:23,440
Agora, eu percebi que a minha
bug é, aparentemente, na linha 20.

584
00:28:23,440 --> 00:28:25,160
Esse é o meu erro lógico.

585
00:28:25,160 --> 00:28:28,100
>> E então o que eu quero
que fazer para mudar isso?

586
00:28:28,100 --> 00:28:32,500
Se o problema é que eu não sou
pegando 0, é apenas um erro de lógica.

587
00:28:32,500 --> 00:28:35,910
E eu posso dizer quando n é
maior do que ou igual a 0,

588
00:28:35,910 --> 00:28:38,330
manter avisar o usuário novamente e novamente.

589
00:28:38,330 --> 00:28:41,050
>> Então, de novo, simples erro, talvez
mesmo óbvio quando você me viu

590
00:28:41,050 --> 00:28:42,410
escrevê-lo apenas alguns minutos atrás.

591
00:28:42,410 --> 00:28:44,570
Mas o takeaway aqui
é que, com depuração 50,

592
00:28:44,570 --> 00:28:46,850
e com a depuração
software de um modo mais geral,

593
00:28:46,850 --> 00:28:51,370
você tem esse novo poder para
caminhar por seu próprio código, olhar

594
00:28:51,370 --> 00:28:55,590
através desse painel do lado direito o que
seus valores variáveis ​​são.

595
00:28:55,590 --> 00:28:57,700
Então, você não necessariamente
tem que usar algo

596
00:28:57,700 --> 00:29:00,630
como você eprintf para imprimir esses valores.

597
00:29:00,630 --> 00:29:04,430
Você pode realmente vê-los
visualmente no ecrã.

598
00:29:04,430 --> 00:29:08,920
>> Agora, além disso, é importante notar
que não há outra técnica que é

599
00:29:08,920 --> 00:29:09,890
realmente super-comum.

600
00:29:09,890 --> 00:29:13,120
E você pode perguntar por que este pequeno
cara aqui tem sido sentado no palco.

601
00:29:13,120 --> 00:29:16,490
Portanto, há essa técnica, em geral
conhecido como o pato de borracha depuração,

602
00:29:16,490 --> 00:29:18,786
o que realmente é apenas uma
testamento ao fato

603
00:29:18,786 --> 00:29:20,660
que os programadores muitas vezes, quando
está escrevendo código,

604
00:29:20,660 --> 00:29:22,650
eles não são necessariamente
colaborar com os outros,

605
00:29:22,650 --> 00:29:24,030
ou trabalhar em um ambiente compartilhado.

606
00:29:24,030 --> 00:29:25,050
>> Eles são tipo de em casa.

607
00:29:25,050 --> 00:29:25,910
Talvez seja tarde da noite.

608
00:29:25,910 --> 00:29:28,190
Eles estão tentando figura
algum bug em seu código.

609
00:29:28,190 --> 00:29:29,330
E eles simplesmente não está vendo isso.

610
00:29:29,330 --> 00:29:30,329
>> E não há nenhum companheiro de quarto.

611
00:29:30,329 --> 00:29:31,250
Não há TF.

612
00:29:31,250 --> 00:29:32,680
Não há CA torno.

613
00:29:32,680 --> 00:29:36,440
Tudo o que eles têm em sua prateleira
é este pequeno patinho de borracha.

614
00:29:36,440 --> 00:29:39,030
>> E assim pato de borracha depuração
é apenas este convite

615
00:29:39,030 --> 00:29:42,780
pensar em algo tão bobo
como esta como uma criatura real

616
00:29:42,780 --> 00:29:46,940
e realmente andar através de seu código
verbalmente a este objeto inanimado.

617
00:29:46,940 --> 00:29:49,230
Assim, por exemplo, se
este é o meu exemplo aqui--

618
00:29:49,230 --> 00:29:52,470
e recordar que no início
o problema era esse,

619
00:29:52,470 --> 00:29:58,140
se eu excluir esta primeira linha de código,
e eu ir em frente e fazer buggy de 0 novamente,

620
00:29:58,140 --> 00:30:01,220
lembro que eu tinha esses
mensagens de erro aqui.

621
00:30:01,220 --> 00:30:05,997
Portanto, a ideia aqui, ridículo que eu
sente no momento fazendo isso publicamente,

622
00:30:05,997 --> 00:30:06,580
é que o erro.

623
00:30:06,580 --> 00:30:10,910
>> OK, então meu problema é que eu tenho
implicitamente declarada uma função de biblioteca.

624
00:30:10,910 --> 00:30:12,610
E essa função de biblioteca é printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, declarar
lembra-me de protótipos.

626
00:30:15,290 --> 00:30:18,930
>> Isso significa que eu preciso realmente
informar o compilador de antemão o que

627
00:30:18,930 --> 00:30:19,980
a função se parece.

628
00:30:19,980 --> 00:30:20,930
Espere um minuto.

629
00:30:20,930 --> 00:30:23,580
Eu não tinha io.h. padrão

630
00:30:23,580 --> 00:30:24,530
Muito obrigado.

631
00:30:24,530 --> 00:30:27,330
>> Então, só este processo de-- você
não precisa realmente ter um pato.

632
00:30:27,330 --> 00:30:29,819
Mas esta ideia de caminhar
-se através de seu próprio código

633
00:30:29,819 --> 00:30:31,610
de modo que você sequer ouvir
mesmo, para que você

634
00:30:31,610 --> 00:30:35,620
perceber omissões no seu próprio
observações, é geralmente a idéia.

635
00:30:35,620 --> 00:30:38,910
>> E, talvez mais logicamente, não tão
tanto com que um, mas o mais envolvidos

636
00:30:38,910 --> 00:30:44,220
exemplo que acabamos de fazer em 3.c de buggy,
você pode caminhar-se através dele

637
00:30:44,220 --> 00:30:45,310
do seguinte modo.

638
00:30:45,310 --> 00:30:49,190
Então tudo bem, borracha
ducky, DDB, se você quiser.

639
00:30:49,190 --> 00:30:52,350
Aqui nós temos na minha função principal,
Eu estou chamando obter int negativo.

640
00:30:52,350 --> 00:30:54,660
>> E eu estou recebendo o valor de retorno.

641
00:30:54,660 --> 00:31:00,410
Eu estou armazenando-o no lado esquerdo
na linha 8 em uma variável chamada i.

642
00:31:00,410 --> 00:31:02,380
OK, mas espera, como fez
que obter esse valor?

643
00:31:02,380 --> 00:31:04,130
Deixe-me olhar para a função na linha 12.

644
00:31:04,130 --> 00:31:05,760
>> Na linha 12, nós temos obter int negativo.

645
00:31:05,760 --> 00:31:08,190
não tomar quaisquer entradas,
não retornar um int, OK.

646
00:31:08,190 --> 00:31:10,929
Declaro na linha 14 uma variável n.

647
00:31:10,929 --> 00:31:12,220
Ele vai armazenar um número inteiro.

648
00:31:12,220 --> 00:31:13,760
Isso é o que eu quero.

649
00:31:13,760 --> 00:31:18,480
>> Então faça o seguinte enquanto n é-- deixe
me desfazer o que a correção já fiz.

650
00:31:18,480 --> 00:31:22,710
Assim, enquanto que n é maior do que
0, imprima n é, OK.

651
00:31:22,710 --> 00:31:25,170
E depois chamar se int armazenado em n.

652
00:31:25,170 --> 00:31:30,160
E, em seguida, verificar se n é 0,
n é não-- aí está.

653
00:31:30,160 --> 00:31:31,910
Então, novamente, você não fazer
precisa o pato real.

654
00:31:31,910 --> 00:31:35,650
Mas apenas caminhando-se através de
seu código como um exercício intelectual

655
00:31:35,650 --> 00:31:37,720
muitas vezes vai ajudá-lo
perceber o que está acontecendo,

656
00:31:37,720 --> 00:31:41,170
ao invés de apenas fazer algo
assim, olhando para a tela,

657
00:31:41,170 --> 00:31:43,720
e não falar-se através de
-lo, o que sinceramente não é

658
00:31:43,720 --> 00:31:46,270
quase como uma técnica eficaz.

659
00:31:46,270 --> 00:31:48,620
Então, você tem isso, uma
número de técnicas diferentes

660
00:31:48,620 --> 00:31:52,102
para realmente depuração do código
e encontrar a falha, os quais

661
00:31:52,102 --> 00:31:54,810
devem ser ferramentas em sua caixa de ferramentas
de modo que você não é tarde da noite,

662
00:31:54,810 --> 00:31:57,660
especialmente, você está no jantar
salões, ou pelo horário de expediente,

663
00:31:57,660 --> 00:32:00,368
batendo com a cabeça contra o
parede, tentando resolver algum problema.

664
00:32:00,368 --> 00:32:02,020
Perceber que existem ferramentas de software.

665
00:32:02,020 --> 00:32:03,720
Existem ferramentas de pato de borracha.

666
00:32:03,720 --> 00:32:09,630
E há uma equipe inteira de
apoiar esperando para dar uma mão.

667
00:32:09,630 --> 00:32:13,120
>> Então, agora, uma palavra sobre o problema
conjuntos, e sobre o que estamos esperando que você

668
00:32:13,120 --> 00:32:15,620
sair deles, e como
nós vamos sobre a avaliação.

669
00:32:15,620 --> 00:32:17,680
Por syllabus do curso,
conjuntos de problemas do CS50

670
00:32:17,680 --> 00:32:22,320
são avaliados em quatro eixos primários, assim
para speak-- âmbito de aplicação, correção, design,

671
00:32:22,320 --> 00:32:23,060
e estilo.

672
00:32:23,060 --> 00:32:25,910
E alcance apenas se refere a quanto
da peça que você mordido?

673
00:32:25,910 --> 00:32:28,080
Quanto de um problema você já tentou?

674
00:32:28,080 --> 00:32:30,110
O nível de esforço
você manifesta?

675
00:32:30,110 --> 00:32:35,750
>> Exatidão é, o programa trabalha como
que deveria por a especificação CS50

676
00:32:35,750 --> 00:32:38,640
quando você fornecer certos insumos
ou certas saídas de volta?

677
00:32:38,640 --> 00:32:41,130
O design é o mais subjetivo deles.

678
00:32:41,130 --> 00:32:43,360
E é o que vai
demoram mais para aprender

679
00:32:43,360 --> 00:32:47,220
e mais tempo para ensinar, em
medida em que se resume a,

680
00:32:47,220 --> 00:32:49,530
como bem escrito é o código?

681
00:32:49,530 --> 00:32:52,920
>> É uma coisa para apenas imprimir a correta
saídas ou devolver os valores corretos.

682
00:32:52,920 --> 00:32:55,400
Mas você está fazendo isso como
mais eficiente possível?

683
00:32:55,400 --> 00:32:58,210
Você está fazendo isso divisão
e conquistar, ou binário

684
00:32:58,210 --> 00:33:01,500
pesquisa como veremos em breve que nós fizemos
há duas semanas com o livro de telefone?

685
00:33:01,500 --> 00:33:04,670
Existem melhores maneiras de resolver o
problema que você tem atualmente aqui?

686
00:33:04,670 --> 00:33:06,380
Essa é uma oportunidade para melhor design.

687
00:33:06,380 --> 00:33:08,530
>> E, em seguida, como style--
bonito é o seu código?

688
00:33:08,530 --> 00:33:12,370
Você vai perceber que eu sou bonito
particular sobre o recuo meu código,

689
00:33:12,370 --> 00:33:15,300
e ter certeza que meus variáveis
são razoavelmente nomeado. N,

690
00:33:15,300 --> 00:33:19,660
enquanto suma, é um bom nome para um
número, i para um número inteiro de contagem,

691
00:33:19,660 --> 00:33:20,727
s para uma string.

692
00:33:20,727 --> 00:33:22,560
E podemos ter mais tempo
estilo nomes variável.

693
00:33:22,560 --> 00:33:25,500
Estilo é apenas como bom
O seu código de olhar?

694
00:33:25,500 --> 00:33:26,600
E como legível é?

695
00:33:26,600 --> 00:33:29,650
>> E ao longo do tempo, o que suas agências de viagens
e TFs fará no curso

696
00:33:29,650 --> 00:33:31,870
é fornecer-lhe que
tipo de feedback qualitativo

697
00:33:31,870 --> 00:33:34,330
para que você obtenha uma melhor
nesses vários aspectos.

698
00:33:34,330 --> 00:33:37,510
E em termos de como nós
avaliar cada um destes eixos,

699
00:33:37,510 --> 00:33:40,080
é tipicamente com muito poucos
baldes para que você, em geral,

700
00:33:40,080 --> 00:33:41,680
ter uma noção de quão bem você está fazendo.

701
00:33:41,680 --> 00:33:45,680
E, de fato, se você receber uma pontuação de
qualquer um desses axes-- correção, design

702
00:33:45,680 --> 00:33:49,659
e estilo especially-- esse número
será geralmente entre 1 e 5.

703
00:33:49,659 --> 00:33:52,450
E, literalmente, se você está recebendo
3 de no início do semestre,

704
00:33:52,450 --> 00:33:53,977
isso é uma coisa muito boa.

705
00:33:53,977 --> 00:33:55,810
Isso significa que ainda há
espaço para melhorias,

706
00:33:55,810 --> 00:33:58,490
que seria de esperar em
tendo uma classe para a primeira vez.

707
00:33:58,490 --> 00:34:01,820
Há espero que algum pedaço de teto
para o qual você está aspirando a alcançar.

708
00:34:01,820 --> 00:34:03,970
E assim que começar no dia 3 de
as primeiras peças,

709
00:34:03,970 --> 00:34:06,550
Se não a cerca de 2 e 4 de do,
é, na verdade, uma coisa boa.

710
00:34:06,550 --> 00:34:08,880
É bem dentro do alcance,
bem dentro das expectativas.

711
00:34:08,880 --> 00:34:11,421
>> E se sua mente está correndo, espere
um minuto, três em cada cinco.

712
00:34:11,421 --> 00:34:12,620
Isso é realmente um 6 out of 10.

713
00:34:12,620 --> 00:34:13,560
Isso é 60%.

714
00:34:13,560 --> 00:34:14,830
Meu Deus, isso é um F.

715
00:34:14,830 --> 00:34:15,870
>> Não é.

716
00:34:15,870 --> 00:34:17,600
Não é, de fato, que.

717
00:34:17,600 --> 00:34:22,710
Pelo contrário, é uma oportunidade para melhorar
ao longo do semestre.

718
00:34:22,710 --> 00:34:25,580
E se você está recebendo algum
Poors, estes são uma oportunidade

719
00:34:25,580 --> 00:34:29,199
para aproveitar as horas de expediente,
certamente seções e outros recursos.

720
00:34:29,199 --> 00:34:32,840
>> Melhor é uma oportunidade, realmente,
para se orgulhar de quão longe você

721
00:34:32,840 --> 00:34:34,520
vêm ao longo do semestre.

722
00:34:34,520 --> 00:34:38,199
Então percebem, se nada
mais, três é bom.

723
00:34:38,199 --> 00:34:40,179
E permite espaço para o crescimento ao longo do tempo.

724
00:34:40,179 --> 00:34:43,090
>> Quanto à forma como esses eixos são
ponderada, de forma realista você está

725
00:34:43,090 --> 00:34:46,745
vai passar a maior parte do seu tempo a chegar
coisas para trabalhar, e muito menos corretamente.

726
00:34:46,745 --> 00:34:49,120
E assim correção tende a
a ponderação do mais, como com

727
00:34:49,120 --> 00:34:51,360
este factor multiplicativo de três.

728
00:34:51,360 --> 00:34:54,659
O design também é importante, mas
algo que você não necessariamente

729
00:34:54,659 --> 00:34:58,220
gastar todas essas horas em
tentando fazer as coisas apenas para trabalhar.

730
00:34:58,220 --> 00:35:00,019
>> E por isso é ponderado
um pouco mais de ânimo leve.

731
00:35:00,019 --> 00:35:01,560
E, em seguida, o estilo é ponderado o mínimo.

732
00:35:01,560 --> 00:35:03,710
Mesmo que ele não é menos
importante, fundamentalmente,

733
00:35:03,710 --> 00:35:05,990
é apenas, talvez, o
coisa mais fácil de fazer o certo,

734
00:35:05,990 --> 00:35:08,440
imitando os exemplos que
fazer em palestra e seção,

735
00:35:08,440 --> 00:35:11,080
com as coisas nicely
recuado, e comentou,

736
00:35:11,080 --> 00:35:14,320
e assim por diante é entre os mais fáceis
coisas para fazer e acertar.

737
00:35:14,320 --> 00:35:16,960
Assim, como tal, perceber
aqueles que são pontos

738
00:35:16,960 --> 00:35:19,000
que são relativamente fáceis de entender.

739
00:35:19,000 --> 00:35:22,360
>> E agora uma palavra sobre
isto-- honestidade acadêmica.

740
00:35:22,360 --> 00:35:25,150
Então por o curso de
plano de estudos, você vai ver

741
00:35:25,150 --> 00:35:27,630
que o curso tem bastante
pouco da linguagem em torno deste.

742
00:35:27,630 --> 00:35:31,380
E o curso leva a questão da
honestidade acadêmica muito a sério.

743
00:35:31,380 --> 00:35:33,450
>> Temos a distinção,
por bem ou por mal,

744
00:35:33,450 --> 00:35:36,570
de ter enviado a cada ano mais
estudantes para ação disciplinar

745
00:35:36,570 --> 00:35:39,670
do que a maioria qualquer outro
claro, que eu estou ciente.

746
00:35:39,670 --> 00:35:42,580
Este não é necessariamente
indicativa do facto

747
00:35:42,580 --> 00:35:46,340
que os estudantes do CS, ou estudantes CS50, são
menos honesto do que seus colegas.

748
00:35:46,340 --> 00:35:49,090
Mas a realidade que neste
mundo, eletronicamente, nós apenas

749
00:35:49,090 --> 00:35:50,990
tem tecnológico
Os meios de detecção deste.

750
00:35:50,990 --> 00:35:53,360
>> É importante para nós, para
justiça em toda a classe

751
00:35:53,360 --> 00:35:58,550
o que fazemos detectar isso, e aumentar
o problema quando vemos as coisas.

752
00:35:58,550 --> 00:36:01,980
E só para pintar um quadro, e realmente
para ajudar a algo como isto pia,

753
00:36:01,980 --> 00:36:04,600
estes são os números de
alunos ao longo dos últimos 10 anos

754
00:36:04,600 --> 00:36:07,610
que foram envolvidos em algum
tais questões de honestidade acadêmica,

755
00:36:07,610 --> 00:36:10,990
com cerca de 32 alunos
da queda de 2015, que

756
00:36:10,990 --> 00:36:13,760
é dizer que nós levamos
o assunto muito a sério.

757
00:36:13,760 --> 00:36:18,380
E, em última análise, estes números compor,
mais recentemente, cerca de 3%, 4% ou menos

758
00:36:18,380 --> 00:36:19,120
da classe.

759
00:36:19,120 --> 00:36:25,220
>> Assim, para o super maioria dos estudantes
parece que as linhas são claras.

760
00:36:25,220 --> 00:36:27,940
Mas manter isso em
importa, particularmente tarde

761
00:36:27,940 --> 00:36:32,080
à noite, quando lutando com
alguma solução para um conjunto de problemas,

762
00:36:32,080 --> 00:36:34,830
que existem mecanismos
para obter-se melhor

763
00:36:34,830 --> 00:36:37,870
apoio do que você pode
acho que, mesmo nessa hora.

764
00:36:37,870 --> 00:36:40,514
Perceba que quando recebermos
apresentações dos alunos, atravessamos

765
00:36:40,514 --> 00:36:43,430
comparar cada apresentação este ano
contra cada apresentação no ano passado,

766
00:36:43,430 --> 00:36:47,590
contra cada apresentação a partir de 2007,
e desde que, olhando para, assim,

767
00:36:47,590 --> 00:36:49,931
código de repositórios online,
fóruns de discussão, sites de emprego.

768
00:36:49,931 --> 00:36:51,806
E nós mencionar isso,
realmente, todos para o bem

769
00:36:51,806 --> 00:36:56,040
da divulgação cheia, que se
alguém pode encontrá-lo on-line,

770
00:36:56,040 --> 00:36:57,880
Certamente, nós também podemos curso.

771
00:36:57,880 --> 00:37:00,100
Mas, na verdade, o espírito
do curso resume

772
00:37:00,100 --> 00:37:01,650
a esta cláusula no programa.

773
00:37:01,650 --> 00:37:03,670
É realmente apenas, ser razoável.

774
00:37:03,670 --> 00:37:06,680
>> E se tivéssemos de elaborar sobre isso
com apenas um pouco mais da linguagem,

775
00:37:06,680 --> 00:37:09,770
perceber que a essência de tudo
trabalho que você enviar para este curso

776
00:37:09,770 --> 00:37:10,954
deve ser o seu próprio.

777
00:37:10,954 --> 00:37:13,870
Mas dentro disso, há certamente
oportunidades e encorajamento,

778
00:37:13,870 --> 00:37:17,300
e valor pedagógico em transformar a
outros- mim mesmo, o FT, o CAs,

779
00:37:17,300 --> 00:37:20,760
os assistentes técnicos, e outros na classe,
para o apoio, muito menos amigos

780
00:37:20,760 --> 00:37:23,547
e companheiros que estudaram
CS e programação antes.

781
00:37:23,547 --> 00:37:25,130
E assim há um subsídio para isso.

782
00:37:25,130 --> 00:37:28,180
E a regra geral do polegar
é isto-- quando pedir ajuda,

783
00:37:28,180 --> 00:37:31,470
você pode mostrar o seu código para os outros,
mas você não pode ver a deles.

784
00:37:31,470 --> 00:37:34,880
Assim, mesmo se você estiver em horário de expediente,
ou na sala D, ou em outro lugar

785
00:37:34,880 --> 00:37:37,450
trabalhando em algum conjunto peça,
trabalhando ao lado de um amigo, que

786
00:37:37,450 --> 00:37:40,160
é totalmente bem, na
final do dia o seu trabalho

787
00:37:40,160 --> 00:37:43,034
deve, em última instância pertencem a cada
de vocês, respectivamente, e não

788
00:37:43,034 --> 00:37:45,700
haver algum esforço colaborativo,
exceto para o projeto final, onde

789
00:37:45,700 --> 00:37:47,410
é permitido e incentivado.

790
00:37:47,410 --> 00:37:49,830
>> Perceba que se você estiver
lutando com alguma coisa

791
00:37:49,830 --> 00:37:52,520
e seu amigo só acontece
para ser melhor nisso, então você,

792
00:37:52,520 --> 00:37:55,130
ou melhor a esse problema do que você,
ou um pouco mais à frente do que você,

793
00:37:55,130 --> 00:37:57,330
é totalmente razoável para transformar
para o seu amigo e dizer, hey,

794
00:37:57,330 --> 00:38:00,480
você se importa de olhar para o meu código aqui,
me ajudar a detectar o que o meu problema é?

795
00:38:00,480 --> 00:38:03,760
E, esperançosamente, no
juros de valor pedagógico

796
00:38:03,760 --> 00:38:07,040
que o amigo não apenas
digo, oh, fazer isso, mas sim,

797
00:38:07,040 --> 00:38:09,917
o que está faltando na linha
6, ou algo parecido?

798
00:38:09,917 --> 00:38:12,000
Mas a solução não é
para o amigo ao seu lado

799
00:38:12,000 --> 00:38:15,617
quer dizer, oh, bem, aqui, deixa-me tirar
isto, e mostrar a minha solução para você.

800
00:38:15,617 --> 00:38:16,450
Assim que é a linha.

801
00:38:16,450 --> 00:38:18,670
Você mostra o seu código para
outros, mas você não pode

802
00:38:18,670 --> 00:38:22,350
ver deles, sujeitos a outro
restrições no currículo do curso.

803
00:38:22,350 --> 00:38:24,760
>> Portanto, tenha em mente que esta
chamada cláusula de arrependimento

804
00:38:24,760 --> 00:38:27,560
no plano de estudos do curso, bem como,
que se você cometer algum ato que

805
00:38:27,560 --> 00:38:30,476
Não é razoável, mas trazê-lo para
a atenção dos chefes do curso

806
00:38:30,476 --> 00:38:34,240
dentro de 72 horas, o curso
pode impor sanções locais que

807
00:38:34,240 --> 00:38:37,380
pode incluir uma ou insatisfatória
classe de failing para o trabalho apresentado.

808
00:38:37,380 --> 00:38:41,410
Mas o curso não vai remeter o
importa para posterior ação disciplinar,

809
00:38:41,410 --> 00:38:43,010
exceto em casos de atos repetidos.

810
00:38:43,010 --> 00:38:46,632
Em outras palavras, se você fizer alguma
estúpida, especialmente tarde da noite, a decisão

811
00:38:46,632 --> 00:38:49,340
que na manhã seguinte ou dois dias
mais tarde, você acordar e perceber,

812
00:38:49,340 --> 00:38:50,870
o que eu estava pensando?

813
00:38:50,870 --> 00:38:53,890
Você fazer em CS50 ter uma saída
para fixar esse problema

814
00:38:53,890 --> 00:38:57,170
e possuir-se a ele, de modo que nós
irá encontrá-lo no meio do caminho e lidar

815
00:38:57,170 --> 00:39:01,500
com isso de uma questão que é simultaneamente
educacional e valioso para você,

816
00:39:01,500 --> 00:39:04,200
mas ainda punitiva de alguma forma.

817
00:39:04,200 --> 00:39:08,590
E agora, para tomar a borda fora, este.

818
00:39:08,590 --> 00:39:10,570
>> [REPRODUÇÃO DE VÍDEO]

819
00:39:10,570 --> 00:39:13,540
>> [REPRODUÇÃO DE MÚSICA]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [FIM DE REPRODUÇÃO]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN: Tudo bem, estamos de volta.

823
00:40:00,490 --> 00:40:03,680
E agora olhamos para uma das
primeiro dos nossos domínios do mundo real

824
00:40:03,680 --> 00:40:08,720
em CS50, a arte de criptografia,
a arte de envio e recebimento

825
00:40:08,720 --> 00:40:11,840
mensagens secretas, criptografado
mensagens se quiser,

826
00:40:11,840 --> 00:40:17,060
que só pode ser decifrado se você tiver
algum ingrediente chave que o remetente tem

827
00:40:17,060 --> 00:40:18,030
também.

828
00:40:18,030 --> 00:40:22,120
Então, para motivar este tomaremos
um olhar para esta coisa aqui,

829
00:40:22,120 --> 00:40:26,750
que é um exemplo de um
decodificador secreto que

830
00:40:26,750 --> 00:40:34,042
pode ser utilizado a fim de descobrir
o que uma mensagem secreta é realmente.

831
00:40:34,042 --> 00:40:35,750
Na verdade, de volta ao
dia na escola,

832
00:40:35,750 --> 00:40:38,787
se você nunca enviou mensagens secretas para
algum amigo ou alguma queda em sala de aula,

833
00:40:38,787 --> 00:40:40,620
que você pode ter pensado
você estava sendo inteligente

834
00:40:40,620 --> 00:40:46,530
por no seu pedaço de mudança de papel,
como, de A a B e B para C e C para D,

835
00:40:46,530 --> 00:40:47,590
e assim por diante.

836
00:40:47,590 --> 00:40:50,300
Mas você estava realmente criptografar
suas informações, mesmo

837
00:40:50,300 --> 00:40:53,300
se ele foi um pouco trivial, não foi
tão difícil para o professor a perceber,

838
00:40:53,300 --> 00:40:55,675
bem, se você acabou de mudar
B para A e C para B,

839
00:40:55,675 --> 00:40:57,550
você realmente descobrir
que a mensagem foi,

840
00:40:57,550 --> 00:40:59,700
mas você estava em cifrar informações.

841
00:40:59,700 --> 00:41:03,420
>> Você só estava fazendo isso
simplesmente, muito parecido com Ralphie aqui

842
00:41:03,420 --> 00:41:07,934
em um filme famoso que desempenha
praticamente ad nauseum cada inverno.

843
00:41:07,934 --> 00:41:08,600
[REPRODUÇÃO DE VÍDEO]

844
00:41:08,600 --> 00:41:11,180
-Ser-Lo conhecido de todos que
Ralph Parker é por este meio

845
00:41:11,180 --> 00:41:14,070
nomeado membro da Pequena
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
e tem direito a todas as honras
e benefícios ocorrendo ao mesmo.

847
00:41:17,700 --> 00:41:24,340
>> Assinatura automática, Little Orphan Annie,
contra-assinado Pierre Andre, em tinta.

848
00:41:24,340 --> 00:41:27,160
Honras e benefícios,
já com a idade de nove.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [GRITANDO]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Vamos.

853
00:41:34,250 --> 00:41:35,210
Vamos continuar com ele.

854
00:41:35,210 --> 00:41:39,530
Eu não preciso de todo esse jazz
cerca de contrabandistas e piratas.

855
00:41:39,530 --> 00:41:41,660
>> -listen Amanhã à noite para
a aventura final

856
00:41:41,660 --> 00:41:43,880
do navio pirata preto.

857
00:41:43,880 --> 00:41:46,650
Agora, é hora de
mensagem secreta de Annie

858
00:41:46,650 --> 00:41:49,840
para você membros do Círculo Secreto.

859
00:41:49,840 --> 00:41:53,570
Lembre-se, miúdos, apenas os membros
de Secret Circle de Annie

860
00:41:53,570 --> 00:41:56,140
pode decodificar mensagem secreta de Annie.

861
00:41:56,140 --> 00:42:00,340
>> Lembre-se, Annie está dependendo de você.

862
00:42:00,340 --> 00:42:02,880
Defina seus pinos para B2.

863
00:42:02,880 --> 00:42:05,230
Aqui está a mensagem.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Eu Estou em minha primeira reunião secreta.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Estava em grande voz esta noite.

868
00:42:15,780 --> 00:42:19,000
Eu poderia dizer que esta noite
mensagem era realmente importante.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, que é uma mensagem
de Annie si mesma.

870
00:42:22,694 --> 00:42:23,860
Lembre-se, não conte a ninguém.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Segundos depois, estou na única
quarto na casa onde um menino de nove anos

873
00:42:32,930 --> 00:42:37,040
poderia sentar em privacidade e decodificar.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Eu fui para o outro, E.

876
00:42:42,360 --> 00:42:44,520
>> A primeira palavra é ser.

877
00:42:44,520 --> 00:42:49,032
S, que estava chegando mais fácil agora, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Ah, vamos lá, Ralphie, eu tenho que ir!

879
00:42:51,733 --> 00:42:53,688
>> -Vou Estar certo para baixo, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee Whiz!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, certifique-a-- certifique-se de que?

883
00:43:04,060 --> 00:43:05,970
Qual foi Little Orphan
Annie está tentando dizer?

884
00:43:05,970 --> 00:43:07,264
Certifique-se de que?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy tem que
Vai, vai fazer o favor de sair?

886
00:43:09,634 --> 00:43:10,480
>> direito -Todos, Ma!

887
00:43:10,480 --> 00:43:12,880
Estarei fora para a direita!

888
00:43:12,880 --> 00:43:14,550
>> -Eu Estava ficando mais perto agora.

889
00:43:14,550 --> 00:43:16,620
A tensão era terrível.

890
00:43:16,620 --> 00:43:17,720
O que foi isso?

891
00:43:17,720 --> 00:43:20,170
O destino do planeta
pode pendurar na balança.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
gotta de Andy ir!

894
00:43:23,170 --> 00:43:26,890
>> -Vou Estar certo para fora, pelo amor de Deus!

895
00:43:26,890 --> 00:43:32,680
>> -Quase Lá, meus dedos voaram, minha mente
era uma armadilha de aço, todos os poros vibrou.

896
00:43:32,680 --> 00:43:37,198
Era quase clara, sim, sim, sim.

897
00:43:37,198 --> 00:43:43,091
>> -Certifique-Se de beber o seu ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovomaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Um comercial miserável?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Filho da puta.

903
00:43:54,227 --> 00:43:54,810
[FIM DE REPRODUÇÃO]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN: OK, então
que era um caminho muito longo

905
00:43:57,390 --> 00:44:00,660
introdução de criptografia,
e também Ovomaltine.

906
00:44:00,660 --> 00:44:04,470
Na verdade, desde este anúncio velho
aqui, por que é ovaltine tão bom?

907
00:44:04,470 --> 00:44:09,470
É uma extracção de concentrado maduro
malte de cevada, leite puro de vaca cremoso,

908
00:44:09,470 --> 00:44:14,360
e especialmente preparado de cacau, em conjunto
com fosfatidos naturais e vitaminas.

909
00:44:14,360 --> 00:44:18,240
É ainda enriquecidos com
vitaminas adicionais B e D, yum.

910
00:44:18,240 --> 00:44:21,600
E você ainda pode obtê-lo, aparentemente,
na Amazônia, como fizemos aqui.

911
00:44:21,600 --> 00:44:24,810
>> Mas a motivação aqui foi
introduzir criptografia, especificamente

912
00:44:24,810 --> 00:44:28,340
um tipo de criptografia conhecido
como criptografia de chave secreta.

913
00:44:28,340 --> 00:44:34,284
E como o nome sugere, o conjunto
segurança de um sistema de criptografia de chave secreta,

914
00:44:34,284 --> 00:44:36,200
se quiserem, uma metodologia
para apenas lutando

915
00:44:36,200 --> 00:44:40,960
informações entre duas pessoas, é que
apenas o remetente e o destinatário única

916
00:44:40,960 --> 00:44:46,980
conhecer um key-- segredo algum valor, alguma
frase secreta, um número secreto, que

917
00:44:46,980 --> 00:44:50,660
lhes permite criptografar
e descriptografar informações.

918
00:44:50,660 --> 00:44:53,470
E criptografia, realmente,
é apenas isso a partir da semana 0.

919
00:44:53,470 --> 00:44:56,715
>> É um problema onde não há entradas,
como a mensagem real em Inglês

920
00:44:56,715 --> 00:44:59,340
ou qualquer outra língua que você
deseja enviar para alguém na sala de aula,

921
00:44:59,340 --> 00:45:00,580
ou através da internet.

922
00:45:00,580 --> 00:45:03,840
Há alguma saída, que vai
ser a mensagem que mexidos

923
00:45:03,840 --> 00:45:05,250
deseja que o destinatário receba.

924
00:45:05,250 --> 00:45:07,405
E mesmo se alguém no
middle recebe-lo também,

925
00:45:07,405 --> 00:45:09,780
você não quer que eles
necessariamente ser capaz de decifrá-lo,

926
00:45:09,780 --> 00:45:12,840
porque dentro desta
caixa preta, ou algoritmo,

927
00:45:12,840 --> 00:45:17,650
é algum mecanismo, algum passo a passo
instruções, para tomar essa entrada

928
00:45:17,650 --> 00:45:20,710
e convertendo-o na
de saída, na esperança de forma segura.

929
00:45:20,710 --> 00:45:23,640
>> E, de fato, há algum
vocabulário neste mundo como se segue.

930
00:45:23,640 --> 00:45:26,100
Texto simples é a palavra de um
cientista da computação seria

931
00:45:26,100 --> 00:45:28,449
usar para descrever os dados
mensagem, como o Inglês

932
00:45:28,449 --> 00:45:31,240
ou qualquer outra língua que você realmente
deseja enviar para algum outro humano.

933
00:45:31,240 --> 00:45:35,450
E, em seguida, o texto cifrado é a corrida
ao cifrada, ou criptografada,

934
00:45:35,450 --> 00:45:36,520
versão do mesmo.

935
00:45:36,520 --> 00:45:38,750
>> Mas há um outro ingrediente aqui.

936
00:45:38,750 --> 00:45:43,200
Há uma outra entrada para
criptografia de chave secreta.

937
00:45:43,200 --> 00:45:45,200
E essa é a chave em si,
que é, geralmente,

938
00:45:45,200 --> 00:45:48,930
como veremos, um número ou
letra, ou uma palavra, qualquer que seja

939
00:45:48,930 --> 00:45:51,980
o algoritmo é realmente espera.

940
00:45:51,980 --> 00:45:53,870
>> E como você descriptografar as informações?

941
00:45:53,870 --> 00:45:55,110
Como você desembaralhar-lo?

942
00:45:55,110 --> 00:45:57,950
Bem, você só inverter a
saídas e as entradas.

943
00:45:57,950 --> 00:46:00,900
>> Em outras palavras, uma vez que alguém
recebe a sua mensagem criptografada,

944
00:46:00,900 --> 00:46:03,740
ele ou ela simplesmente tem
a saber, que mesmo chave.

945
00:46:03,740 --> 00:46:05,700
Eles receberam o texto cifrado.

946
00:46:05,700 --> 00:46:09,530
E ligando esses dois
contributos para o sistema de criptografia,

947
00:46:09,530 --> 00:46:14,260
o algoritmo, esta caixa preta, para fora
deve vir o texto plano inicial.

948
00:46:14,260 --> 00:46:17,830
E assim que é o nível muito elevado
visão do que a criptografia é realmente

949
00:46:17,830 --> 00:46:18,590
tudo sobre.

950
00:46:18,590 --> 00:46:20,030
>> Então, vamos chegar lá.

951
00:46:20,030 --> 00:46:22,700
Vamos agora olhar por baixo
a capa de alguma coisa

952
00:46:22,700 --> 00:46:26,000
temos vindo a tomar para concedido para
na semana passada, e para esta sessão

953
00:46:26,000 --> 00:46:27,629
aqui-- a corda.

954
00:46:27,629 --> 00:46:30,295
Uma cadeia no final do dia
é apenas uma sequência de caracteres.

955
00:46:30,295 --> 00:46:33,610
>> Pode ser Olá mundo, ou
Olá Zamyla, ou o que quer.

956
00:46:33,610 --> 00:46:37,050
Mas o que isso significa para
Ser uma seqüência de caracteres?

957
00:46:37,050 --> 00:46:41,520
Na verdade, a biblioteca CS50 dá
-nos um tipo de dados chamado string.

958
00:46:41,520 --> 00:46:45,140
>> Mas não há realmente nenhuma
tal coisa como uma string em C.

959
00:46:45,140 --> 00:46:49,450
É realmente apenas uma sequência de
caráter, personalidade, caráter,

960
00:46:49,450 --> 00:46:52,180
caráter, para trás, para trás, para
para trás, para trás, para trás dentro

961
00:46:52,180 --> 00:46:54,650
da memória do seu computador, ou RAM.

962
00:46:54,650 --> 00:46:58,940
E nós vamos olhar mais profundo em que, no
futuro, quando olharmos para a própria memória,

963
00:46:58,940 --> 00:47:02,030
ea utilização, ea
ameaças que estão envolvidos.

964
00:47:02,030 --> 00:47:04,100
>> Mas vamos considerar a string Zamyla.

965
00:47:04,100 --> 00:47:07,480
Assim, apenas o nome do
o ser humano aqui, Zamyla,

966
00:47:07,480 --> 00:47:12,030
que é uma sequência de
caracteres, Z-A-H-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
E agora vamos supor que o nome de Zamyla
está a ser armazenado no interior de um computador

968
00:47:16,020 --> 00:47:16,880
programa.

969
00:47:16,880 --> 00:47:20,830
>> Bem, é lógico que devemos
ser capaz de olhar para os personagens

970
00:47:20,830 --> 00:47:21,590
individualmente.

971
00:47:21,590 --> 00:47:24,710
Então, eu estou indo só para desenhar um pouco
caixa à volta o nome de Zamyla aqui.

972
00:47:24,710 --> 00:47:31,580
E é o caso em C que, quando você
ter uma seqüência, como Zamyla-- e talvez

973
00:47:31,580 --> 00:47:34,940
essa seqüência voltou da
uma função como cadeia get,

974
00:47:34,940 --> 00:47:38,540
você pode realmente manipular
-lo caractere por caractere.

975
00:47:38,540 --> 00:47:42,070
>> Agora, isso é pertinente para o
conversa à mão, porque

976
00:47:42,070 --> 00:47:46,420
em criptografia se você quer mudar
A a B, e B para C e C para D,

977
00:47:46,420 --> 00:47:49,650
e assim por diante, você precisa ser capaz
olhar para os caracteres individuais

978
00:47:49,650 --> 00:47:50,190
em uma string.

979
00:47:50,190 --> 00:47:52,695
Você precisa ser capaz de mudar
o Z para outra coisa, o A

980
00:47:52,695 --> 00:47:55,280
a outra coisa, o M para
outra coisa, e assim por diante.

981
00:47:55,280 --> 00:47:58,000
E por isso precisamos de uma maneira,
programaticamente, então

982
00:47:58,000 --> 00:48:03,020
falar, em C, para ser capaz de mudar
e olhar para cartas individuais.

983
00:48:03,020 --> 00:48:05,690
E nós podemos fazer isso da seguinte forma.

984
00:48:05,690 --> 00:48:08,340
>> Deixe-me ir voltar no IDE CS50.

985
00:48:08,340 --> 00:48:11,130
E deixe-me ir em frente
e criar um novo arquivo

986
00:48:11,130 --> 00:48:16,134
que eu vou chamar este string0 tempo,
como nosso primeiro exemplo desta situação, ponto c.

987
00:48:16,134 --> 00:48:18,300
E eu estou indo para ir em frente
e chicoteá-lo como se segue.

988
00:48:18,300 --> 00:48:22,870
>> Assim incluem CS50.h, e
em seguida, incluir io.h standard,

989
00:48:22,870 --> 00:48:25,990
que eu estou quase sempre vai
estar usando em meus programas, pelo menos,

990
00:48:25,990 --> 00:48:26,780
inicialmente.

991
00:48:26,780 --> 00:48:32,180
int void main, em seguida, aqui estou
vai fazer cordas recebe obter string.

992
00:48:32,180 --> 00:48:35,260
E então eu vou
vá em frente e fazer isso.

993
00:48:35,260 --> 00:48:37,460
Eu quero ir em frente
e, como verificação de sanidade,

994
00:48:37,460 --> 00:48:43,607
apenas dizer, Olá, cento s,
-e-vírgula, torna corda 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, o que eu fiz aqui?

996
00:48:44,690 --> 00:48:45,930
Oh, eu não ligá-lo.

997
00:48:45,930 --> 00:48:48,120
Então, lição aprendida, que
não foi intencional.

998
00:48:48,120 --> 00:48:52,480
>> Assim erro, mais por cento
conversões do que argumentos dados.

999
00:48:52,480 --> 00:48:54,940
E é aí que, em
linha 7-- OK, então eu tenho,

1000
00:48:54,940 --> 00:48:56,690
entre aspas, que é
minha cadeia de caracteres para printf.

1001
00:48:56,690 --> 00:48:58,151
Eu tenho um sinal de porcentagem.

1002
00:48:58,151 --> 00:48:59,650
Mas eu estou perdendo o segundo argumento.

1003
00:48:59,650 --> 00:49:03,190
>> Eu estou faltando o s vírgula, que
Eu tinha nos exemplos anteriores.

1004
00:49:03,190 --> 00:49:06,650
Então, uma boa oportunidade para corrigir
mais um erro, acidentalmente.

1005
00:49:06,650 --> 00:49:09,950
E agora me deixar correr
string0, digite Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, Olá Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Então nós executar este tipo de programa
algumas vezes diferente agora.

1008
00:49:14,144 --> 00:49:16,310
Mas vamos fazer algo um
pouco diferente desta vez.

1009
00:49:16,310 --> 00:49:19,450
Em vez de apenas imprimir Zamyla de
nome completo com printf,

1010
00:49:19,450 --> 00:49:21,350
vamos fazê-lo caractere por caractere.

1011
00:49:21,350 --> 00:49:22,700
>> Vou usar um loop for.

1012
00:49:22,700 --> 00:49:26,160
E eu vou entregar-me
uma variável de contagem, chamado i.

1013
00:49:26,160 --> 00:49:33,530
E eu vou continuar a iteração, então
desde que i é inferior ao comprimento de s.

1014
00:49:33,530 --> 00:49:35,930
>> Acontece que, não o fizemos
fazer isso da última vez,

1015
00:49:35,930 --> 00:49:39,100
que vem com um c
função chamada Stirling.

1016
00:49:39,100 --> 00:49:42,690
De volta ao dia, e, em geral
ainda na implementação de funções,

1017
00:49:42,690 --> 00:49:45,405
seres humanos, muitas vezes, escolher com muito
nomes sucintas que tipo de som

1018
00:49:45,405 --> 00:49:48,280
como o que você quer, mesmo que seja
faltando algumas vogais ou letras.

1019
00:49:48,280 --> 00:49:50,660
Assim Stirling é a
nome de uma função que

1020
00:49:50,660 --> 00:49:53,880
toma uma discussão entre
entre parênteses, que deve ser uma string.

1021
00:49:53,880 --> 00:49:56,910
E ele só retorna um inteiro,
o comprimento dessa corda.

1022
00:49:56,910 --> 00:50:00,580
>> Portanto, este loop for na linha 7 vai
para iniciar a contagem em i é igual a 0.

1023
00:50:00,580 --> 00:50:02,530
Vai para incrementar
i em cada iteração

1024
00:50:02,530 --> 00:50:04,350
por 1, como temos vindo a fazer algumas vezes.

1025
00:50:04,350 --> 00:50:06,780
Mas vai fazer apenas
isso até o ponto

1026
00:50:06,780 --> 00:50:09,660
quando i é o comprimento
da própria cadeia.

1027
00:50:09,660 --> 00:50:14,520
>> Portanto, esta é uma maneira de, em última análise,
iteração sobre os personagens

1028
00:50:14,520 --> 00:50:17,430
na seqüência como é segue.

1029
00:50:17,430 --> 00:50:20,670
Vou imprimir não um
seqüência inteira, mas por cento c,

1030
00:50:20,670 --> 00:50:22,860
um único caractere
seguido por uma nova linha.

1031
00:50:22,860 --> 00:50:24,880
E então eu vou
vá em frente, e eu preciso

1032
00:50:24,880 --> 00:50:29,080
dizer Quero imprimir
caráter i de s.

1033
00:50:29,080 --> 00:50:33,450
>> Portanto, se i é a variável que indica
o índice da cadeia, onde

1034
00:50:33,450 --> 00:50:37,230
você está nele, eu preciso ser capaz de
dizer, me dar ao personagem i de s.

1035
00:50:37,230 --> 00:50:40,390
E c tem uma maneira de fazer
isso com colchetes.

1036
00:50:40,390 --> 00:50:43,679
Você simplesmente dizer o nome do
cadeia, que neste caso é s.

1037
00:50:43,679 --> 00:50:46,970
Então você usar colchetes, que são
geralmente apenas acima de sua Return ou Enter

1038
00:50:46,970 --> 00:50:48,110
tecla no teclado.

1039
00:50:48,110 --> 00:50:52,410
E então você colocar o índice do
caractere que você deseja imprimir.

1040
00:50:52,410 --> 00:50:55,960
Assim, o índice vai ser um
number-- 0, ou 1, ou 2, ou 3, ou um ponto,

1041
00:50:55,960 --> 00:50:57,590
ponto, ponto, algum outro número.

1042
00:50:57,590 --> 00:51:00,920
>> E podemos garantir que ele vai
ser o número certo, porque eu

1043
00:51:00,920 --> 00:51:02,360
começar a contar a 0.

1044
00:51:02,360 --> 00:51:07,020
E, por padrão, o primeiro caractere
em uma string é, por convenção 0.

1045
00:51:07,020 --> 00:51:09,230
E o segundo personagem é suporte 1.

1046
00:51:09,230 --> 00:51:11,120
E o terceiro personagem é bracket 2.

1047
00:51:11,120 --> 00:51:13,630
E você não quer ir muito
longe, mas não vamos porque somos

1048
00:51:13,630 --> 00:51:17,780
vai incrementar eu só até que ele
é igual ao comprimento da corda.

1049
00:51:17,780 --> 00:51:20,210
E em que ponto,
este loop irá parar.

1050
00:51:20,210 --> 00:51:25,550
>> Então deixe-me ir em frente e salvar este
programa, e executar fazer corda 0.

1051
00:51:25,550 --> 00:51:28,400
Mas eu estraguei tudo.

1052
00:51:28,400 --> 00:51:35,390
Implicitamente declarando função de biblioteca
Stirling com o tipo tal e such-- agora,

1053
00:51:35,390 --> 00:51:36,430
isso soa familiar.

1054
00:51:36,430 --> 00:51:37,440
Mas não é printf.

1055
00:51:37,440 --> 00:51:38,540
E não é obter string.

1056
00:51:38,540 --> 00:51:40,480
>> Eu não estragar em
Do mesmo modo neste momento.

1057
00:51:40,480 --> 00:51:45,100
Mas note-se aqui um pouco para baixo
Além disso, incluem o string.h cabeçalho,

1058
00:51:45,100 --> 00:51:47,210
fornecer explicitamente o
declaração de Stirling.

1059
00:51:47,210 --> 00:51:48,820
Portanto, não é realmente uma pista lá.

1060
00:51:48,820 --> 00:51:51,670
>> E de fato ele sair
há um outro arquivo de cabeçalho

1061
00:51:51,670 --> 00:51:53,970
que não usei
em sala de aula ainda, mas é

1062
00:51:53,970 --> 00:51:56,480
entre os disponíveis
para você, chamado string.h.

1063
00:51:56,480 --> 00:52:00,930
E nesse arquivo, string.h
é Stirling declarou.

1064
00:52:00,930 --> 00:52:05,220
Então deixe-me ir em frente e
salvar isso, certifique-corda

1065
00:52:05,220 --> 00:52:08,040
0-- agradável, sem mensagens de erro neste momento.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, e
Estou prestes a pressionar Enter,

1067
00:52:12,290 --> 00:52:16,710
em que ponto getString vai
para retornar a corda, colocá-lo em s.

1068
00:52:16,710 --> 00:52:21,890
Em seguida que for loop vai fazer uma iteração
sobre os personagens de S um de cada vez,

1069
00:52:21,890 --> 00:52:28,420
e imprimi-los um por linha, porque
Eu tinha que barra invertida n no final.

1070
00:52:28,420 --> 00:52:34,530
Assim eu poderia omitir que barra invertida
n, e depois é só imprimir Zamyla tudo

1071
00:52:34,530 --> 00:52:37,460
na mesma linha,
eficazmente reimplementar

1072
00:52:37,460 --> 00:52:38,999
printf, que não é tão útil.

1073
00:52:38,999 --> 00:52:40,540
Mas, neste caso, eu não fiz isso.

1074
00:52:40,540 --> 00:52:43,610
Eu realmente impressa uma
carácter de cada vez, um por linha,

1075
00:52:43,610 --> 00:52:45,400
de modo que nós realmente ver o efeito.

1076
00:52:45,400 --> 00:52:46,900
>> Mas devo salientar uma coisa aqui.

1077
00:52:46,900 --> 00:52:48,930
E nós vamos voltar a
este em uma semana futuro.

1078
00:52:48,930 --> 00:52:52,650
Acontece que este
código é potencialmente buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Acontece que cadeia get
e algumas outras funções na vida

1080
00:52:56,560 --> 00:53:00,280
não necessariamente sempre
devolver o que você está esperando.

1081
00:53:00,280 --> 00:53:03,010
Sabemos da classe passada
tempo nesta que ficar

1082
00:53:03,010 --> 00:53:04,960
cadeia deve retornar uma string.

1083
00:53:04,960 --> 00:53:09,900
Mas e se o usuário digita fora, tais
uma palavra longa, ou parágrafo, ou ensaio

1084
00:53:09,900 --> 00:53:13,010
que há apenas não é suficiente
memória do computador para ajustá-lo.

1085
00:53:13,010 --> 00:53:15,410
>> Como, o que se algo der
errado debaixo do capô?

1086
00:53:15,410 --> 00:53:18,400
Pode não acontece muitas vezes,
mas poderia acontecer uma vez

1087
00:53:18,400 --> 00:53:21,520
em quando, muito raramente.

1088
00:53:21,520 --> 00:53:25,460
E assim acontece que cadeia get
e funções como ele faz não necessariamente

1089
00:53:25,460 --> 00:53:26,380
sempre retornam strings.

1090
00:53:26,380 --> 00:53:30,680
Eles podem retornar algum valor de erro,
algum valor de sentinela por assim dizer,

1091
00:53:30,680 --> 00:53:32,612
que indica que
algo deu errado.

1092
00:53:32,612 --> 00:53:35,320
E você só sabe que isso
terem aprendido em sala de aula agora,

1093
00:53:35,320 --> 00:53:37,700
ou de ter lido mais alguma documentação.

1094
00:53:37,700 --> 00:53:43,120
Acontece que cadeia get
pode retornar um valor chamado nulo.

1095
00:53:43,120 --> 00:53:46,220
Nulo é um valor especial que vamos
voltar em uma semana futuro.

1096
00:53:46,220 --> 00:53:50,420
Mas, por enquanto, só sei que se eu quiser
para ser realmente bom em avançar

1097
00:53:50,420 --> 00:53:52,650
usando a corda get, I
não deve apenas chamá-lo,

1098
00:53:52,650 --> 00:53:56,870
e cegamente usar seu valor de retorno,
confiando que é uma string.

1099
00:53:56,870 --> 00:53:59,420
>> Eu deveria dizer em primeiro lugar,
Ei, espere um minuto, única

1100
00:53:59,420 --> 00:54:03,380
proceder se s não é igual
nulo, onde nula, novamente,

1101
00:54:03,380 --> 00:54:04,660
é apenas um valor especial.

1102
00:54:04,660 --> 00:54:07,770
E é o único valor especial que você
precisa se preocupar com a seqüência de get.

1103
00:54:07,770 --> 00:54:10,900
Obter string é qualquer um que vai
para devolver uma cadeia ou nulo.

1104
00:54:10,900 --> 00:54:17,219
>> E este ponto de exclamação sinal de igual
você pode saber a partir talvez aula de matemática

1105
00:54:17,219 --> 00:54:20,510
que você pode desenhar um sinal de igualdade com
uma linha através dele para indicar não é igual.

1106
00:54:20,510 --> 00:54:23,135
Isso não é geralmente um personagem
você pode digitar no teclado.

1107
00:54:23,135 --> 00:54:26,480
E assim na maioria das linguagens de programação,
quando você quer dizer não é igual,

1108
00:54:26,480 --> 00:54:29,160
você usar um ponto de exclamação,
também conhecido como estrondo.

1109
00:54:29,160 --> 00:54:33,180
Então você diz Bang é igual, o que
significa não é igual, logicamente.

1110
00:54:33,180 --> 00:54:38,060
É como não há um maior
do que, ou igual a, ou inferior a

1111
00:54:38,060 --> 00:54:41,270
ou igual a tecla no teclado
que faz tudo em um símbolo.

1112
00:54:41,270 --> 00:54:44,020
É por isso que, nos exemplos anteriores,
você fez um suporte aberto, e em seguida

1113
00:54:44,020 --> 00:54:48,670
um sinal de igual, a fim de fazer
maior ou, digamos, menos de.

1114
00:54:48,670 --> 00:54:49,910
>> Então qual é o takeaway aqui?

1115
00:54:49,910 --> 00:54:53,880
Isto é simplesmente uma maneira de agora
introduzir esta sintaxe, este recurso,

1116
00:54:53,880 --> 00:54:57,390
iteração sobre indivíduo
caracteres em uma string.

1117
00:54:57,390 --> 00:55:00,260
E, assim como aqueles quadrado
colchetes permitem que você chegar a eles,

1118
00:55:00,260 --> 00:55:03,790
considerar os colchetes como
tipo de insinuando neste subjacente

1119
00:55:03,790 --> 00:55:06,040
design, em que cada
caracteres dentro de uma string

1120
00:55:06,040 --> 00:55:10,180
é uma espécie de caixa em algum lugar embaixo
o capô na memória do seu computador.

1121
00:55:10,180 --> 00:55:12,340
>> Mas vamos fazer uma variante deste.

1122
00:55:12,340 --> 00:55:14,880
Acontece que este
programa é correcta.

1123
00:55:14,880 --> 00:55:18,810
Então por eixos de CS50 para avaliar
código, isso é correto agora.

1124
00:55:18,810 --> 00:55:22,959
Especialmente agora que estou verificando
null, esse programa nunca deve falhar.

1125
00:55:22,959 --> 00:55:24,500
E eu só sei que com a experiência.

1126
00:55:24,500 --> 00:55:28,040
Mas não há nada mais que
podemos realmente dar errado aqui.

1127
00:55:28,040 --> 00:55:31,860
Mas não é muito bem concebido,
porque vamos voltar ao básico.

1128
00:55:31,860 --> 00:55:34,450
>> Em primeiro lugar, principles--
o que faz um loop for fazer?

1129
00:55:34,450 --> 00:55:36,290
Um loop for faz três coisas.

1130
00:55:36,290 --> 00:55:39,340
Ele inicializa alguns
valor, se você pedir para ele.

1131
00:55:39,340 --> 00:55:41,770
Ele verifica uma condição.

1132
00:55:41,770 --> 00:55:45,380
E em seguida, após cada
iteração, depois de cada ciclo,

1133
00:55:45,380 --> 00:55:49,330
incrementa alguns
valor ou valores, aqui.

1134
00:55:49,330 --> 00:55:50,600
>> Então, o que isso significa?

1135
00:55:50,600 --> 00:55:52,940
Nós inicializar i a 0.

1136
00:55:52,940 --> 00:55:58,610
Nós verificar e certificar-i é inferior a
o comprimento do s, o que é Z-A-H-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
de modo que é inferior a 6.

1138
00:55:59,900 --> 00:56:02,590
E, na verdade, como menos do que 0 6.

1139
00:56:02,590 --> 00:56:05,580
>> Nós imprimir Z do nome de Zamyla.

1140
00:56:05,580 --> 00:56:08,080
Em seguida, incrementar i 0-1.

1141
00:56:08,080 --> 00:56:11,290
Em seguida, verifique, é de 1 a menos
do que o comprimento do s?

1142
00:56:11,290 --> 00:56:13,270
O comprimento s é 6.

1143
00:56:13,270 --> 00:56:13,950
Sim.

1144
00:56:13,950 --> 00:56:16,880
>> Por isso, imprimir uma em nome de Zamyla, ZA.

1145
00:56:16,880 --> 00:56:20,090
Nós incrementar i de 0, a 1, a 2.

1146
00:56:20,090 --> 00:56:23,720
Em seguida, verifique, é inferior a 2
o comprimento do nome de Zamyla.

1147
00:56:23,720 --> 00:56:25,380
6- SO 2 é menor do que 6.

1148
00:56:25,380 --> 00:56:30,460
Sim, vamos imprimir agora M em
O nome de Zamyla, o terceiro personagem.

1149
00:56:30,460 --> 00:56:34,110
>> A chave aqui é que em cada
iteração da história, eu estou verificando,

1150
00:56:34,110 --> 00:56:37,810
i é inferior ao comprimento de Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Mas o problema é que
Stirling não é uma propriedade.

1152
00:56:40,350 --> 00:56:43,100
Aqueles de vocês que tenha programado
antes em Java ou outras linguagens

1153
00:56:43,100 --> 00:56:46,310
pode saber o comprimento de uma string é
uma propriedade, apenas algumas leia único valor.

1154
00:56:46,310 --> 00:56:50,220
>> Em C, neste caso, se este for
uma função que é, literalmente,

1155
00:56:50,220 --> 00:56:53,520
a contagem do número de
caracteres em Zamyla cada vez

1156
00:56:53,520 --> 00:56:54,740
chamamos essa função.

1157
00:56:54,740 --> 00:56:58,500
Toda vez que você perguntar ao computador para usar
Stirling, está tendo um olhar para Zamyla,

1158
00:56:58,500 --> 00:57:01,960
e dizendo Z-A-H-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
E ele retorna 6.

1160
00:57:02,962 --> 00:57:04,920
A próxima vez que você chamar
-lo dentro desse loop for,

1161
00:57:04,920 --> 00:57:08,610
ele vai olhar para Zamyla
novamente, digamos, Z-A-H-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
E ele vai voltar 6.

1163
00:57:10,320 --> 00:57:12,980
Então, o que é estúpido sobre este projeto?

1164
00:57:12,980 --> 00:57:17,700
>> Por que meu código não a 5 de 5
para o projeto agora, por assim dizer?

1165
00:57:17,700 --> 00:57:20,600
Bem, eu estou pedindo um
pergunta desnecessariamente.

1166
00:57:20,600 --> 00:57:23,030
Eu estou fazendo mais trabalho do que eu preciso.

1167
00:57:23,030 --> 00:57:25,370
>> Assim, mesmo que o
resposta está correta, eu sou

1168
00:57:25,370 --> 00:57:29,560
pedindo o computador, o que é
o comprimento de Zamyla novamente,

1169
00:57:29,560 --> 00:57:31,380
e de novo, e de novo, e de novo?

1170
00:57:31,380 --> 00:57:33,980
E essa resposta é
nunca vai mudar.

1171
00:57:33,980 --> 00:57:35,900
É sempre vai ser 6.

1172
00:57:35,900 --> 00:57:39,730
>> Então, uma solução melhor do que este
Seria esta próxima versão.

1173
00:57:39,730 --> 00:57:43,390
Deixe-me ir em frente e colocá-lo em um
arquivo separado chamado string1.c,

1174
00:57:43,390 --> 00:57:44,990
apenas para mantê-lo separado.

1175
00:57:44,990 --> 00:57:47,260
E verifica-se em um de
loop, você pode realmente

1176
00:57:47,260 --> 00:57:50,210
declarar múltiplas variáveis ​​ao mesmo tempo.

1177
00:57:50,210 --> 00:57:53,460
>> Então, eu vou continuar i e configurá-lo para 0.

1178
00:57:53,460 --> 00:57:56,190
Mas eu também vou
adicionar uma vírgula, e dizer:

1179
00:57:56,190 --> 00:58:01,050
dá-me uma variável chamada n, cujas
valor é igual ao comprimento da corda de s.

1180
00:58:01,050 --> 00:58:09,410
E agora, por favor, faça minha condição
desde que i é menor que n.

1181
00:58:09,410 --> 00:58:14,140
>> Assim, deste modo, a lógica está
idênticas no final do dia.

1182
00:58:14,140 --> 00:58:18,280
Mas estou lembrando a
valor 6, neste caso.

1183
00:58:18,280 --> 00:58:19,780
Qual é o comprimento do nome de Zamyla?

1184
00:58:19,780 --> 00:58:20,860
E eu estou colocando-o n.

1185
00:58:20,860 --> 00:58:23,050
>> E eu ainda estou verificando
a condição de cada vez.

1186
00:58:23,050 --> 00:58:24,300
0 é inferior a 6?

1187
00:58:24,300 --> 00:58:25,600
1 é inferior a 6?

1188
00:58:25,600 --> 00:58:28,600
É de 2 a menos de 6, e assim por diante?

1189
00:58:28,600 --> 00:58:31,914
>> Mas eu não estou pedindo o computador
de novo, e de novo, o que é

1190
00:58:31,914 --> 00:58:33,080
o comprimento do nome de Zamyla?

1191
00:58:33,080 --> 00:58:34,320
Qual é o comprimento do nome de Zamyla?

1192
00:58:34,320 --> 00:58:35,986
Qual é o comprimento do nome deste Zamyla?

1193
00:58:35,986 --> 00:58:40,440
Eu estou literalmente lembrando que em primeiro
única resposta neste segundo n variável.

1194
00:58:40,440 --> 00:58:45,280
Então, isso agora seria não só
correto, mas também bem concebido.

1195
00:58:45,280 --> 00:58:46,670
>> Agora, o que sobre o estilo?

1196
00:58:46,670 --> 00:58:48,866
Eu nomeei meus variáveis
muito bem, eu diria.

1197
00:58:48,866 --> 00:58:50,240
Elas são super sucinta agora.

1198
00:58:50,240 --> 00:58:52,090
E isso é totalmente bem.

1199
00:58:52,090 --> 00:58:55,120
>> Se você só tem uma
Cadeia de caracteres em um programa,

1200
00:58:55,120 --> 00:58:56,860
assim como você pode chamá-lo de s para a cadeia.

1201
00:58:56,860 --> 00:58:59,370
Se você só tem uma variável
para contagem num programa,

1202
00:58:59,370 --> 00:59:00,710
assim como você pode chamá-lo i.

1203
00:59:00,710 --> 00:59:03,500
Se você tem um comprimento, n
é super comum também.

1204
00:59:03,500 --> 00:59:05,800
Mas eu não comentou qualquer do meu código.

1205
00:59:05,800 --> 00:59:09,200
>> Eu não tenho informou o reader--
se essa é a minha TF ou TA,

1206
00:59:09,200 --> 00:59:12,460
ou apenas colleague-- o que é suposto
estar acontecendo neste programa.

1207
00:59:12,460 --> 00:59:15,760
E assim, para obter um bom estilo,
o que eu gostaria de fazer

1208
00:59:15,760 --> 00:59:24,580
é isto-- algo
como pedir usuário para entrada.

1209
00:59:24,580 --> 00:59:26,670
E eu poderia reescrever
este qualquer número de maneiras.

1210
00:59:26,670 --> 00:59:35,630
>> Certifique-se de s-- certifique-get
string retornada uma string.

1211
00:59:35,630 --> 00:59:40,280
E então, em aqui-- e este é, talvez,
o iterate comment-- mais importante

1212
00:59:40,280 --> 00:59:44,450
sobre os personagens s um de cada vez.

1213
00:59:44,450 --> 00:59:47,060
E eu poderia usar qualquer
escolha do idioma Inglês

1214
00:59:47,060 --> 00:59:49,650
aqui para descrever cada
destes pedaços de código.

1215
00:59:49,650 --> 00:59:52,740
>> Repare que eu não ter colocado um
comentar sobre cada linha de código,

1216
00:59:52,740 --> 00:59:55,690
realmente apenas sobre a interessante
queridos, os que

1217
00:59:55,690 --> 00:59:59,460
ter algum significado que eu poderia
quer fazer super clara a alguém

1218
00:59:59,460 --> 01:00:00,460
ler o meu código.

1219
01:00:00,460 --> 01:00:02,920
E por que você está chamando de obter
cadeia perguntar utilizador para a entrada?

1220
01:00:02,920 --> 01:00:05,450
Mesmo que um não é necessariamente
tudo o que descritiva.

1221
01:00:05,450 --> 01:00:09,340
Mas ajuda a contar uma história, porque o
segunda linha na história é, certifique-se

1222
01:00:09,340 --> 01:00:10,740
obter cadeia devolvida uma cadeia de caracteres.

1223
01:00:10,740 --> 01:00:14,260
>> E a terceira linha na história é,
iterar sobre os personagens s um

1224
01:00:14,260 --> 01:00:15,380
de uma vez.

1225
01:00:15,380 --> 01:00:17,920
E agora apenas para uma boa medida,
Eu estou indo para ir em frente e adicionar

1226
01:00:17,920 --> 01:00:24,560
mais um comentário que apenas
diz impressão de caracteres i-th em s.

1227
01:00:24,560 --> 01:00:26,520
Agora, o que eu fiz
No fim do dia?

1228
01:00:26,520 --> 01:00:29,190
>> Eu adicionei um pouco de Inglês
palavras a forma de comentários.

1229
01:00:29,190 --> 01:00:32,700
O símbolo de barra barra significa, hey,
computador isto é para o ser humano,

1230
01:00:32,700 --> 01:00:33,820
não para você, o computador.

1231
01:00:33,820 --> 01:00:35,119
Então, eles são ignorados logicamente.

1232
01:00:35,119 --> 01:00:35,910
Eles são apenas lá.

1233
01:00:35,910 --> 01:00:39,830
>> E, de fato, CS50 IDE mostra-los como
cinza, como sendo útil, mas não tecla

1234
01:00:39,830 --> 01:00:41,000
para o programa.

1235
01:00:41,000 --> 01:00:42,570
Observe o que você agora pode fazer.

1236
01:00:42,570 --> 01:00:44,950
Se você conhece C
programação ou não, você

1237
01:00:44,950 --> 01:00:47,722
pode apenas ficar para trás neste
programa, e roçar os comentários.

1238
01:00:47,722 --> 01:00:50,180
Perguntar ao usuário para entrada, certifique-se
obter cadeia devolvida uma cadeia de caracteres,

1239
01:00:50,180 --> 01:00:53,009
iterar sobre os personagens de s
um de cada vez, imprimir o caracter

1240
01:00:53,009 --> 01:00:55,550
i-th personagem em s-- você não faz
ainda tem que olhar para o código

1241
01:00:55,550 --> 01:00:57,270
para entender o que este programa faz.

1242
01:00:57,270 --> 01:01:00,280
E, melhor ainda, se você olhar
neste programa de uma semana ou duas,

1243
01:01:00,280 --> 01:01:02,280
ou um mês ou um ano,
você também não têm

1244
01:01:02,280 --> 01:01:04,420
a olhar para o código,
tentando lembrar,

1245
01:01:04,420 --> 01:01:06,630
o que eu estava tentando fazer com esse código?

1246
01:01:06,630 --> 01:01:07,770
>> Você já disse a si mesmo.

1247
01:01:07,770 --> 01:01:11,660
Você descreveu-o para si mesmo,
ou algum colega ou TA, ou TF.

1248
01:01:11,660 --> 01:01:14,860
E assim este seria agora
correta, e um bom design,

1249
01:01:14,860 --> 01:01:18,210
e, finalmente, um bom estilo também.

1250
01:01:18,210 --> 01:01:19,990
Então faça manter isso em mente.

1251
01:01:19,990 --> 01:01:22,200
>> Portanto, há um outro
coisa que eu vou fazer aqui

1252
01:01:22,200 --> 01:01:28,240
que agora podem revelar exatamente o que é
acontecendo debaixo do capô.

1253
01:01:28,240 --> 01:01:30,390
Então há esse recurso
no C, e outras línguas,

1254
01:01:30,390 --> 01:01:33,010
chamado typecasting
que de forma implícita

1255
01:01:33,010 --> 01:01:37,250
ou explicitamente permite converter
a partir de um tipo de dados para outro.

1256
01:01:37,250 --> 01:01:39,800
Temos lidado tão
até hoje, com cordas.

1257
01:01:39,800 --> 01:01:41,250
>> E as cordas são caracteres.

1258
01:01:41,250 --> 01:01:44,910
Mas lembre-se a partir da semana
0, quais são personagens?

1259
01:01:44,910 --> 01:01:49,334
Caracteres são apenas uma abstração
em cima de números decimais Números de,

1260
01:01:49,334 --> 01:01:52,500
e os números decimais são realmente apenas um
abstração em cima dos números binários,

1261
01:01:52,500 --> 01:01:53,720
como nós definimos.

1262
01:01:53,720 --> 01:01:55,540
>> Então personagens são números.

1263
01:01:55,540 --> 01:01:58,410
E os números são personagens,
apenas, dependendo do contexto.

1264
01:01:58,410 --> 01:02:01,250
E verifica-se que dentro
de um programa de computador,

1265
01:02:01,250 --> 01:02:06,830
você pode especificar como você quer olhar
nos bits dentro desse programa?

1266
01:02:06,830 --> 01:02:10,400
>> Lembre-se da semana 0 que tivemos
Ascii, que é apenas este código

1267
01:02:10,400 --> 01:02:11,620
letras de mapeamento para números.

1268
01:02:11,620 --> 01:02:13,660
E nós dissemos, o capital Um é de 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B é 66, e assim por diante.

1270
01:02:15,860 --> 01:02:20,500
>> E observem, temos essencialmente caracteres em
a linha superior aqui, como C seria chamá-los,

1271
01:02:20,500 --> 01:02:23,400
caracteres e, em seguida
ints na segunda linha.

1272
01:02:23,400 --> 01:02:28,180
E acontece que você pode converter
sem problemas entre os dois, normalmente.

1273
01:02:28,180 --> 01:02:30,042
E se nós queremos fazer
este deliberadamente, nós

1274
01:02:30,042 --> 01:02:31,750
pode querer enfrentar
algo assim.

1275
01:02:31,750 --> 01:02:33,590
>> Podemos querer converter
letras maiúsculas para diminuir

1276
01:02:33,590 --> 01:02:35,330
caso, ou minúsculas para maiúsculas.

1277
01:02:35,330 --> 01:02:38,000
E verifica-se que há
na verdade, um padrão aqui

1278
01:02:38,000 --> 01:02:39,900
podemos abraçar em apenas um momento.

1279
01:02:39,900 --> 01:02:44,120
Mas vamos olhar primeiro para um
exemplo de fazer isso explicitamente.

1280
01:02:44,120 --> 01:02:46,340
>> Vou voltar para IDE CS50.

1281
01:02:46,340 --> 01:02:50,640
Eu estou indo para criar um
arquivo chamado Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
E eu estou indo para ir em frente e adicionar o meu
io.h padrão no topo, int void main

1283
01:02:55,960 --> 01:02:57,370
no topo da minha função.

1284
01:02:57,370 --> 01:03:02,700
E então eu estou indo só para fazer o
following-- um loop de i é igual,

1285
01:03:02,700 --> 01:03:04,610
digamos, 65.

1286
01:03:04,610 --> 01:03:10,460
>> E então eu vai ser inferior a
65, além de 26 letras no alfabeto.

1287
01:03:10,460 --> 01:03:12,640
Então eu vou deixar o computador
fazer a matemática para mim lá.

1288
01:03:12,640 --> 01:03:15,100
E, em seguida, no interior deste circuito,
o que eu vou para imprimir?

1289
01:03:15,100 --> 01:03:19,230
>> % C é% i barra invertida n.

1290
01:03:19,230 --> 01:03:21,290
E agora eu quero para ligar dois valores.

1291
01:03:21,290 --> 01:03:24,530
Eu coloquei temporariamente questão
marca lá para convidar a questão.

1292
01:03:24,530 --> 01:03:29,940
>> Eu quero fazer uma iteração de 65 em diante
durante 26 letras do alfabeto,

1293
01:03:29,940 --> 01:03:35,190
imprimindo em cada iteração que
equivalente integrante do personagem.

1294
01:03:35,190 --> 01:03:38,299
Em outras palavras, eu quero
iteração mais de 26 números de impressão

1295
01:03:38,299 --> 01:03:41,590
o que o personagem Ascii é, a carta,
e qual o número correspondente é--

1296
01:03:41,590 --> 01:03:44,650
realmente apenas recriando
o gráfico a partir desse slide.

1297
01:03:44,650 --> 01:03:47,010
Então, o que esses pontos de interrogação ser?

1298
01:03:47,010 --> 01:03:51,760
>> Bem, verifica-se que a segunda
deve-se ser apenas o i variável.

1299
01:03:51,760 --> 01:03:53,860
Quero ver isso como um número.

1300
01:03:53,860 --> 01:03:58,920
E o argumento média
aqui, posso dizer ao computador

1301
01:03:58,920 --> 01:04:03,470
para tratar esse inteiro
i como um personagem, de modo

1302
01:04:03,470 --> 01:04:05,880
para substituí-lo aqui por cento C.

1303
01:04:05,880 --> 01:04:07,990
>> Em outras palavras, se I, o
programador humano, sabe

1304
01:04:07,990 --> 01:04:09,865
estes são apenas números
No fim do dia.

1305
01:04:09,865 --> 01:04:12,500
E eu sei que 65 devem
mapear para algum personagem.

1306
01:04:12,500 --> 01:04:15,310
Com esse elenco explícito,
com um parêntese,

1307
01:04:15,310 --> 01:04:18,840
o nome do tipo de dados que você deseja
converter, e um parêntese fechado,

1308
01:04:18,840 --> 01:04:21,200
você pode dizer o
computador, hey, computador,

1309
01:04:21,200 --> 01:04:24,130
converter este número inteiro para um char.

1310
01:04:24,130 --> 01:04:26,250
>> Então, quando eu executar este
programa depois de compilar,

1311
01:04:26,250 --> 01:04:29,740
vamos ver o que eu get-- fazer Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Darn-lo, o que eu fiz de errado aqui?

1313
01:04:33,020 --> 01:04:35,884
Use de identificador não declarado,
tudo bem, não intencional,

1314
01:04:35,884 --> 01:04:37,800
mas vamos ver se não podemos
razão por isso.

1315
01:04:37,800 --> 01:04:41,220
>> Então linha five-- então eu não chegar
muito longe antes de estragar.

1316
01:04:41,220 --> 01:04:42,140
Isso está ok.

1317
01:04:42,140 --> 01:04:46,560
Assim, a linha 5 para i é igual a 65-- eu vejo.

1318
01:04:46,560 --> 01:04:50,130
Então lembre-se que, em C, ao contrário de alguns
idiomas, se você tem programação prévia

1319
01:04:50,130 --> 01:04:52,190
experiência, você tem
para dizer ao computador,

1320
01:04:52,190 --> 01:04:55,040
Ao contrário de risco, o que
tipo de variável que é.

1321
01:04:55,040 --> 01:04:56,860
>> E eu esqueci uma frase-chave aqui.

1322
01:04:56,860 --> 01:04:59,200
Na linha de cinco, eu comecei a usar i.

1323
01:04:59,200 --> 01:05:01,560
Mas eu não contei C
o tipo de dados que é.

1324
01:05:01,560 --> 01:05:04,570
Então, eu estou indo para ir aqui e
dizer, ah, torná-lo um inteiro.

1325
01:05:04,570 --> 01:05:07,050
>> Agora eu estou indo para ir em frente e recompilar.

1326
01:05:07,050 --> 01:05:08,080
Que fixa isso.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, isso é legal.

1328
01:05:12,660 --> 01:05:15,360
Não só é super rápido para
pedir ao computador a esta pergunta,

1329
01:05:15,360 --> 01:05:18,885
em vez de olhar-lo em um slide,
-lo impresso um por linha, A é 65,

1330
01:05:18,885 --> 01:05:24,860
B é de 66, todo o caminho desde que eu down--
fez isso 26 vezes-- ao letras z,

1331
01:05:24,860 --> 01:05:25,630
que é de 90.

1332
01:05:25,630 --> 01:05:27,790
E, na verdade, ligeiramente
mais inteligente seria

1333
01:05:27,790 --> 01:05:31,030
têm sido para mim a não confiar
no computador para adicionar 26.

1334
01:05:31,030 --> 01:05:34,060
I poderia ter feito
90, bem como, tanto tempo

1335
01:05:34,060 --> 01:05:37,390
como eu não cometer o mesmo erro duas vezes.

1336
01:05:37,390 --> 01:05:41,880
Eu quero ir para cima através
z, não apenas através y.

1337
01:05:41,880 --> 01:05:44,000
>> Então, isso é uma conversão explícita.

1338
01:05:44,000 --> 01:05:47,860
Acontece que este
Nem sequer é necessário.

1339
01:05:47,860 --> 01:05:52,480
Deixe-me ir em frente e execute novamente este
compilador e reprise Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Acontece que C é muito inteligente.

1341
01:05:54,940 --> 01:05:57,150
>> E printf, em particular,
é muito inteligente.

1342
01:05:57,150 --> 01:06:01,260
Se você apenas passar um i duas vezes
para ambos os espaços reservados, printf

1343
01:06:01,260 --> 01:06:04,510
vai perceber, oh, bem, eu sei que você
deu-me um integer-- algum número,

1344
01:06:04,510 --> 01:06:06,380
como 65, ou 90, ou o que quer.

1345
01:06:06,380 --> 01:06:10,170
Mas eu ver que você me quer
formatar esse número como um personagem.

1346
01:06:10,170 --> 01:06:16,460
E assim printf pode implicitamente fundido
o int para um char para você também.

1347
01:06:16,460 --> 01:06:19,360
Então isso não é um problema de todos.

1348
01:06:19,360 --> 01:06:23,100
>> Mas observe, por causa dessa equivalência
nós podemos realmente fazer isso também.

1349
01:06:23,100 --> 01:06:26,520
Deixe-me ir em frente e fazer um
outra versão do isto-- 1.c. Ascii

1350
01:06:26,520 --> 01:06:31,800
E em vez de iteração sobre
inteiros, pode realmente fundir sua mente

1351
01:06:31,800 --> 01:06:33,610
iterando sobre personagens.

1352
01:06:33,610 --> 01:06:37,660
Se um char c obtém capital de A, I
quer ir em frente e fazer isso,

1353
01:06:37,660 --> 01:06:41,740
contanto que C é menos do que ou igual
a Z. de capital e em cada iteração

1354
01:06:41,740 --> 01:06:45,690
Quero incrementar C, eu posso
agora na minha linha printf aqui

1355
01:06:45,690 --> 01:06:51,320
digamos, por cento C é
por cento i novamente, vírgula C.

1356
01:06:51,320 --> 01:06:57,200
>> E agora, eu posso ir na outra direção,
lançando o caráter explicitamente

1357
01:06:57,200 --> 01:06:58,500
para um número inteiro.

1358
01:06:58,500 --> 01:07:00,560
Então, mais uma vez, por que você faria isso?

1359
01:07:00,560 --> 01:07:03,830
É um pouco estranho para classificar de
contar em termos de caracteres.

1360
01:07:03,830 --> 01:07:07,430
>> Mas se você entender o que está
acontecendo sob o capô,

1361
01:07:07,430 --> 01:07:08,430
não há realmente nenhuma mágica.

1362
01:07:08,430 --> 01:07:13,060
Você só está dizendo, hey, computador dar
me uma variável chamada C do tipo char.

1363
01:07:13,060 --> 01:07:16,520
Inicialize-o ao capital A. E
notar única questão aspas.

1364
01:07:16,520 --> 01:07:19,580
>> Para caracteres em C, lembre-se de
na semana passada, você usar aspas simples.

1365
01:07:19,580 --> 01:07:23,720
Para strings, por palavras,
frases, você usar aspas duplas.

1366
01:07:23,720 --> 01:07:27,210
OK, computador, continuar fazendo isso, então
desde que o personagem é inferior a

1367
01:07:27,210 --> 01:07:28,050
ou igual a z.

1368
01:07:28,050 --> 01:07:32,640
E eu sei da minha mesa Ascii que todos
destes códigos ASCII são contíguos.

1369
01:07:32,640 --> 01:07:33,400
>> Não há lacunas.

1370
01:07:33,400 --> 01:07:36,737
Então é só de A a Z,
separados por um número cada.

1371
01:07:36,737 --> 01:07:38,820
E então eu posso incrementar
um char, se eu realmente quero.

1372
01:07:38,820 --> 01:07:40,390
No fim do dia,
é apenas um número.

1373
01:07:40,390 --> 01:07:41,030
Eu sei isso.

1374
01:07:41,030 --> 01:07:43,670
Então eu só posso presumir para adicionar 1 a ela.

1375
01:07:43,670 --> 01:07:46,940
>> E, em seguida, desta vez, eu imprimir c,
e, em seguida, o equivalente integrante.

1376
01:07:46,940 --> 01:07:50,170
E eu nem sequer precisa do elenco explícito.

1377
01:07:50,170 --> 01:07:52,680
Eu posso deixar printf eo
computador entender as coisas,

1378
01:07:52,680 --> 01:07:57,300
de modo que agora se eu correr
fazer Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Recebo exatamente a mesma coisa também.

1380
01:08:01,520 --> 01:08:04,530
>> programa inútil, embora-- ninguém
vai realmente escrever software

1381
01:08:04,530 --> 01:08:07,549
a fim de descobrir, qual foi o
número que mapeia para A ou B, ou Z?

1382
01:08:07,549 --> 01:08:10,340
Você só está indo para o Google-lo, ou
procurá-lo on-line, ou procurá-lo

1383
01:08:10,340 --> 01:08:11,650
sobre uma lâmina, ou semelhantes.

1384
01:08:11,650 --> 01:08:13,520
Então onde é que isto realmente obter útil?

1385
01:08:13,520 --> 01:08:15,960
>> Bem, falando nisso
slide, notar que há

1386
01:08:15,960 --> 01:08:20,890
um padrão real aqui entre maiúsculas
e minúsculas que não foi acidental.

1387
01:08:20,890 --> 01:08:23,760
Observe que o capital Um é de 65.

1388
01:08:23,760 --> 01:08:25,830
Minúsculas um é de 97.

1389
01:08:25,830 --> 01:08:29,649
E quão longe é minúscula a?

1390
01:08:29,649 --> 01:08:32,649
>> Assim, 65 é o número de passos de 97?

1391
01:08:32,649 --> 01:08:36,210
Então, 97 menos 65 é de 32.

1392
01:08:36,210 --> 01:08:37,910
Assim, o capital um é de 65.

1393
01:08:37,910 --> 01:08:39,939
Se você adicionar 32 a isso,
você começa minúsculas a.

1394
01:08:39,939 --> 01:08:43,729
E, de forma equivalente, se você subtrair 32,
-lo a voltar para o capital A-- mesmo com B

1395
01:08:43,729 --> 01:08:46,380
a pouco b, C grande para pouco c.

1396
01:08:46,380 --> 01:08:50,670
>> Todas essas lacunas são 32 apart.

1397
01:08:50,670 --> 01:08:54,450
Agora, isso parece para nos permitir
fazer algo como Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
ou o Google Docs possuem, onde você
pode selecionar tudo e, em seguida, dizer:

1399
01:08:57,729 --> 01:09:00,520
mudar tudo em minúsculas, ou
mudar tudo em maiúsculas,

1400
01:09:00,520 --> 01:09:03,840
ou alterar apenas a primeira palavra
de uma frase em letras maiúsculas.

1401
01:09:03,840 --> 01:09:07,390
Nós podemos realmente fazer alguma coisa
assim nós mesmos.

1402
01:09:07,390 --> 01:09:12,645
>> Deixe-me ir em frente e salvar um arquivo
aqui chamado de capitalizar 0.c.

1403
01:09:12,645 --> 01:09:15,770
E vamos em frente e chicote de um programa
que faz exatamente isso como se segue.

1404
01:09:15,770 --> 01:09:18,460
Assim, a biblioteca incluem CS50.

1405
01:09:18,460 --> 01:09:21,430
E incluem padrão de I / O.

1406
01:09:21,430 --> 01:09:22,787
>> E eu sei que isso está chegando.

1407
01:09:22,787 --> 01:09:24,870
Então, eu vou colocá-lo em
já, string.h,

1408
01:09:24,870 --> 01:09:26,960
então eu tenho acesso a
coisas como Stirling,

1409
01:09:26,960 --> 01:09:29,620
e, em seguida, int void main, como de costume.

1410
01:09:29,620 --> 01:09:33,420
E então eu estou indo para ir em frente
e fazer cordas recebe obter corda,

1411
01:09:33,420 --> 01:09:35,032
apenas para obter uma seqüência do usuário.

1412
01:09:35,032 --> 01:09:36,740
E então eu vou
fazer o meu teste de sanidade.

1413
01:09:36,740 --> 01:09:40,510
Se a string não é igual a zero,
então é seguro para prosseguir.

1414
01:09:40,510 --> 01:09:42,000
E o que eu quero fazer?

1415
01:09:42,000 --> 01:09:48,700
Eu estou indo para percorrer a partir de i é igual a 0,
e n até o comprimento da corda de s.

1416
01:09:48,700 --> 01:09:51,899
>> E eu vou fazer isso, desde que
i é menor que n, e eu plus plus.

1417
01:09:51,899 --> 01:09:55,060
Até agora, eu sou realmente apenas
emprestando idéias de antes.

1418
01:09:55,060 --> 01:09:57,010
E agora eu estou indo para introduzir um ramo.

1419
01:09:57,010 --> 01:09:59,635
>> Então, acho que volta para zero, onde
tivemos esses garfos na estrada,

1420
01:09:59,635 --> 01:10:05,110
e na semana passada em C. Eu vou
dizer isso, se o personagem i-th em s

1421
01:10:05,110 --> 01:10:09,250
é maior do que ou
igual a um minúsculas,

1422
01:10:09,250 --> 01:10:13,340
e- em risco se fosse literalmente
dizer e, mas em C você diz e comercial,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- eo caráter i-th em s
é inferior ou igual a z minúsculas,

1424
01:10:19,830 --> 01:10:21,780
vamos fazer algo interessante.

1425
01:10:21,780 --> 01:10:27,020
Vamos realmente imprimir um
personagem com nenhuma nova linha

1426
01:10:27,020 --> 01:10:31,760
que é o caractere na seqüência,
o caráter i-th na cadeia.

1427
01:10:31,760 --> 01:10:37,420
>> Mas vamos em frente e
subtrair 32 a partir dele.

1428
01:10:37,420 --> 01:10:42,120
Else se o personagem do
string que nós estamos olhando

1429
01:10:42,120 --> 01:10:45,950
não é entre um pouco
e pouca z, vá em frente

1430
01:10:45,950 --> 01:10:48,610
e apenas imprimiu inalterado.

1431
01:10:48,610 --> 01:10:50,840
Então, nós introduzimos
esta notação entre colchetes

1432
01:10:50,840 --> 01:10:53,560
para nossas cordas para chegar à
i-th carácter na cadeia.

1433
01:10:53,560 --> 01:10:57,520
>> Eu adicionei alguma lógica condicional, como
Zero na semana última semana, onde

1434
01:10:57,520 --> 01:10:59,880
Eu só estou usando o meu fundamentais
compreensão do que é

1435
01:10:59,880 --> 01:11:01,130
acontecendo debaixo do capô.

1436
01:11:01,130 --> 01:11:04,190
É o personagem i da s
maior do que ou igual a um?

1437
01:11:04,190 --> 01:11:08,290
Como, é 97, ou 98,
ou 99, e assim por diante?

1438
01:11:08,290 --> 01:11:11,940
>> Mas é também menor ou igual
para o valor de z minúsculas?

1439
01:11:11,940 --> 01:11:16,210
E se assim for, o que é que esta linha significa?

1440
01:11:16,210 --> 01:11:20,250
14, esta é uma espécie de
germe de toda a idéia,

1441
01:11:20,250 --> 01:11:23,840
capitalizar a letra por
simplesmente subtraindo 32 a partir dele,

1442
01:11:23,840 --> 01:11:29,370
neste caso, porque eu sei, por que
gráfico, como os meus números são representados.

1443
01:11:29,370 --> 01:11:33,925
Então, vamos em frente e executar isso,
depois de compilar capitalizar 0.c,

1444
01:11:33,925 --> 01:11:36,210
e correr capitalizar 0.

1445
01:11:36,210 --> 01:11:40,300
>> Vamos digitar algo como
Zamyla em todas as letras minúsculas entrar.

1446
01:11:40,300 --> 01:11:42,780
E agora temos Zamyla em todas as letras maiúsculas.

1447
01:11:42,780 --> 01:11:45,050
Vamos digitar Rob em todas as letras minúsculas.

1448
01:11:45,050 --> 01:11:46,674
Vamos tentar Jason em todas as letras minúsculas.

1449
01:11:46,674 --> 01:11:48,590
E continuamos recebendo o
capitalização forçada.

1450
01:11:48,590 --> 01:11:50,960
Há um pequeno bug que eu
tipo de não antecipar.

1451
01:11:50,960 --> 01:11:54,050
Observe o meu novo prompt é acabar
na mesma linha como os seus nomes,

1452
01:11:54,050 --> 01:11:55,520
que se sente um pouco confuso.

1453
01:11:55,520 --> 01:11:59,170
>> Então, eu estou indo para ir aqui, e
na verdade, no final do presente programa

1454
01:11:59,170 --> 01:12:02,110
imprimir um caractere de nova linha.

1455
01:12:02,110 --> 01:12:03,160
Isso é tudo.

1456
01:12:03,160 --> 01:12:06,120
Com printf, você não precisa
passar em variáveis ​​ou código de formato.

1457
01:12:06,120 --> 01:12:08,460
Você pode literalmente apenas imprimir
algo como uma nova linha.

1458
01:12:08,460 --> 01:12:13,529
>> Então, vamos em frente e fazer
capitalizar 0 novamente, executá-lo novamente, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
E agora é um pouco mais bonita.

1460
01:12:14,820 --> 01:12:17,274
Agora, a minha linha é em sua própria linha nova.

1461
01:12:17,274 --> 01:12:18,440
Então, isso é tudo muito bem e bom.

1462
01:12:18,440 --> 01:12:19,910
Então, isso é um bom exemplo.

1463
01:12:19,910 --> 01:12:22,700
Mas eu nem sequer necessariamente
precisa codificar a 32.

1464
01:12:22,700 --> 01:12:23,350
Você sabe o que?

1465
01:12:23,350 --> 01:12:26,350
Eu poderia dizer-- eu nunca
lembre-se qual é a diferença.

1466
01:12:26,350 --> 01:12:29,330
>> Mas eu sei que se eu
tem uma letra minúscula,

1467
01:12:29,330 --> 01:12:34,430
I, essencialmente, quer subtrair off
qualquer que seja a distância entre é pouco

1468
01:12:34,430 --> 01:12:39,160
um e um grande, porque se eu assumir que
todas as outras cartas são os mesmos,

1469
01:12:39,160 --> 01:12:41,045
que deve começar o trabalho feito.

1470
01:12:41,045 --> 01:12:42,670
Mas em vez de fazer isso, você sabe o quê?

1471
01:12:42,670 --> 01:12:44,240
Há uma outra maneira ainda.

1472
01:12:44,240 --> 01:12:48,090
>> Se isso é capitalizar 1.c-- se eu fosse
Para colocar isso em um arquivo separado.

1473
01:12:48,090 --> 01:12:51,030
Vamos fazer capitalizar 2.c como segue.

1474
01:12:51,030 --> 01:12:53,060
Eu estou indo para realmente limpar isso aqui.

1475
01:12:53,060 --> 01:12:57,420
E em vez de ter que mesmo
sabem ou se preocupam com aqueles de baixo nível

1476
01:12:57,420 --> 01:13:01,090
detalhes de implementação, eu sou vez
indo só para imprimir um caráter,

1477
01:13:01,090 --> 01:13:04,610
entre aspas, por cento C, e
em seguida, chamar uma outra função que

1478
01:13:04,610 --> 01:13:09,950
existe que leva um argumento,
que é um personagem, como este.

1479
01:13:09,950 --> 01:13:12,630
>> Acontece em C, não há
outra chamada de função

1480
01:13:12,630 --> 01:13:15,550
a superior, que como o próprio nome
sugere leva um personagem

1481
01:13:15,550 --> 01:13:19,350
e torna a sua maiúsculas
equivalente, e, em seguida, devolve-lo

1482
01:13:19,350 --> 01:13:21,410
de modo que printf pode ligá-lo lá.

1483
01:13:21,410 --> 01:13:25,484
E assim, para fazer isso, porém, eu
necessidade de introduzir um outro arquivo.

1484
01:13:25,484 --> 01:13:28,400
Acontece que há um outro arquivo
que você só saberia de classe,

1485
01:13:28,400 --> 01:13:33,020
ou um livro, ou um on-line
referência, chamada C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Então, se eu acrescentar que até entre meu cabeçalho
arquivos, e agora re-compilar este programa,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Vamos digitar Zamyla em todos
minúsculas, ainda funciona da mesma.

1489
01:13:46,690 --> 01:13:48,040
Mas você sabe o que?

1490
01:13:48,040 --> 01:13:55,590
Acontece que a parte superior
tem alguma outra funcionalidade.

1491
01:13:55,590 --> 01:13:58,410
>> E deixe-me apresentar este
comando aqui, mais ou menos desajeitadamente

1492
01:13:58,410 --> 01:14:00,250
chamado, mas o homem para manual.

1493
01:14:00,250 --> 01:14:03,960
Acontece que a maioria dos computadores Linux,
como estamos usando aqui-- operacional Linux

1494
01:14:03,960 --> 01:14:06,270
system-- ter um comando
chamado homem, que diz:

1495
01:14:06,270 --> 01:14:08,530
hey, computador, dá-me
manual do computador.

1496
01:14:08,530 --> 01:14:10,680
O que você quer
olhar para cima nesse manual?

1497
01:14:10,680 --> 01:14:13,840
>> Eu quero olhar para cima a função
chamados a superior, Enter.

1498
01:14:13,840 --> 01:14:16,070
E é um pouco críptica
para ler, às vezes.

1499
01:14:16,070 --> 01:14:18,780
Mas note que estamos no
Manual do Programador Linux.

1500
01:14:18,780 --> 01:14:19,530
E é todo o texto.

1501
01:14:19,530 --> 01:14:21,905
E note que há a
nome da função até aqui.

1502
01:14:21,905 --> 01:14:25,030
Acontece que tem um primo chamado
para diminuir, o que faz o oposto.

1503
01:14:25,030 --> 01:14:29,710
E notificação de acordo com sinopse, para usar este
funcionar a página do manual, por assim dizer,

1504
01:14:29,710 --> 01:14:32,220
está me dizendo que eu
precisa incluir c type.h.

1505
01:14:32,220 --> 01:14:33,630
E eu sabia que a partir da prática.

1506
01:14:33,630 --> 01:14:36,210
>> Aqui, ele está me mostrando os dois
protótipos para a função,

1507
01:14:36,210 --> 01:14:39,070
de modo que se eu quiser usar este
Eu sei o que eles tomam como entrada,

1508
01:14:39,070 --> 01:14:40,652
eo que eles retornam como saída.

1509
01:14:40,652 --> 01:14:42,360
E então se eu ler
a descrição, eu vejo

1510
01:14:42,360 --> 01:14:44,820
com mais detalhes o que a função faz.

1511
01:14:44,820 --> 01:14:48,100
Mas o mais importante, se
Eu olho abaixo do valor de troca,

1512
01:14:48,100 --> 01:14:51,710
ele diz que o valor devolvido é
que da carta convertido,

1513
01:14:51,710 --> 01:14:57,880
ou C, a entrada original, Se
a conversão não foi possível.

1514
01:14:57,880 --> 01:15:01,992
>> Em outras palavras, a parte superior vai tentar
para converter uma carta para maiúsculas.

1515
01:15:01,992 --> 01:15:03,450
E se assim for, ele vai para devolvê-lo.

1516
01:15:03,450 --> 01:15:07,010
Mas se ele não pode por alguma razăo
talvez seja caso já superior,

1517
01:15:07,010 --> 01:15:09,550
talvez seja um ponto de exclamação
ou algum outro punctuation--

1518
01:15:09,550 --> 01:15:12,200
ele só vai para
devolver o C original,

1519
01:15:12,200 --> 01:15:17,340
o que significa que eu posso fazer o meu código
melhor concebido como segue.

1520
01:15:17,340 --> 01:15:20,580
>> Eu não preciso de todos
estas linhas danado de código.

1521
01:15:20,580 --> 01:15:22,610
Todas as linhas que eu
apenas iluminada pode

1522
01:15:22,610 --> 01:15:28,700
ser recolhidas em apenas um simples
linha, que é isto-- cento printf

1523
01:15:28,700 --> 01:15:33,510
c ao suporte S superior i.

1524
01:15:33,510 --> 01:15:36,090
E esta seria uma
exemplo de melhor design.

1525
01:15:36,090 --> 01:15:40,040
>> Por implementar em 7 ou 8 linhas
de código, qualquer que fosse eu só

1526
01:15:40,040 --> 01:15:44,960
suprimido, quando você pode, em vez colapso
tudo isso a tomada de lógica e da decisão

1527
01:15:44,960 --> 01:15:49,620
em uma única linha, 13 agora, que
depende de uma biblioteca function--

1528
01:15:49,620 --> 01:15:53,430
uma função que vem com C, mas que
faz exatamente o que você quer que ele faça.

1529
01:15:53,430 --> 01:15:55,295
E, francamente, mesmo se
ele não veio com C,

1530
01:15:55,295 --> 01:15:58,880
você pode implementá-lo, como
vimos, com a obter int negativo

1531
01:15:58,880 --> 01:16:01,700
e obter positiva int na semana passada também.

1532
01:16:01,700 --> 01:16:03,470
>> Este código é agora muito mais legível.

1533
01:16:03,470 --> 01:16:06,670
E, de fato, se deslocar para cima,
veja como muito mais compacto

1534
01:16:06,670 --> 01:16:08,360
esta versão do meu programa é.

1535
01:16:08,360 --> 01:16:11,230
É um pouco pesado top agora,
com todos estes inclui.

1536
01:16:11,230 --> 01:16:14,380
Mas tudo bem, porque agora eu estou de pé
sobre os ombros dos programadores

1537
01:16:14,380 --> 01:16:15,300
antes de mim.

1538
01:16:15,300 --> 01:16:18,440
E quem quer que fosse que
implementadas para superior realmente

1539
01:16:18,440 --> 01:16:21,470
fez-me um favor, muito parecido com quem
implementado Stirling realmente

1540
01:16:21,470 --> 01:16:24,790
me fez um favor há algum tempo.

1541
01:16:24,790 --> 01:16:26,970
E agora temos uma
melhor programa de design

1542
01:16:26,970 --> 01:16:31,680
que implementa a mesma lógica exata.

1543
01:16:31,680 --> 01:16:35,580
>> Falando de Stirling, vamos
me ir em frente e fazer isso.

1544
01:16:35,580 --> 01:16:38,320
Deixe-me ir em frente e salvar
este arquivo como stirling.c.

1545
01:16:38,320 --> 01:16:43,255
E acontece, podemos descascar
uma outra camada bastante simples agora.

1546
01:16:43,255 --> 01:16:45,630
Eu estou indo para ir em frente e chicote
-se outro programa na principal

1547
01:16:45,630 --> 01:16:49,759
aqui que simplesmente re-implementa
comprimento da corda como se segue.

1548
01:16:49,759 --> 01:16:52,300
Então aqui está uma linha de código que
me deixa uma seqüência do usuário.

1549
01:16:52,300 --> 01:16:53,910
Continuamos a usar este novamente e novamente.

1550
01:16:53,910 --> 01:16:58,900
Deixe-me dar-me uma variável chamada
n do tipo int que armazena um número.

1551
01:16:58,900 --> 01:17:02,490
>> E deixe-me ir em frente e
faça o seguinte lógica.

1552
01:17:02,490 --> 01:17:15,610
Enquanto o personagem n-th no s faz
é igual a barra invertida 0, vá em frente

1553
01:17:15,610 --> 01:17:17,930
e incrementar n.

1554
01:17:17,930 --> 01:17:23,506
E, em seguida, imprimir printf cento i n.

1555
01:17:23,506 --> 01:17:29,200
Eu afirmo que este programa aqui,
sem chamar comprimento da corda,

1556
01:17:29,200 --> 01:17:31,150
descobre o comprimento de uma string.

1557
01:17:31,150 --> 01:17:34,600
>> E a magia é inteiramente
encapsulada em linha 8

1558
01:17:34,600 --> 01:17:39,830
aqui com o que parece ser uma nova sintaxe,
esta barra invertida 0 entre aspas simples.

1559
01:17:39,830 --> 01:17:41,360
Mas por que isso?

1560
01:17:41,360 --> 01:17:44,100
Bem, considere o que tem sido
acontecendo todo esse tempo.

1561
01:17:44,100 --> 01:17:47,990
>> E como um aparte antes que eu esqueça, percebe
também, que para além das páginas man

1562
01:17:47,990 --> 01:17:50,920
que vêm com um típico
sistema Linux como CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
perceber que nós, o
Os funcionários do curso, têm também

1564
01:17:53,770 --> 01:17:56,030
fez uma versão website
desta mesma idéia chamada

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, que possui
todas essas mesmas páginas man,

1566
01:17:59,940 --> 01:18:02,020
todos da mesma
documentação, bem como

1567
01:18:02,020 --> 01:18:05,730
uma pequena caixa na parte superior que permite
você converter todo o bastante

1568
01:18:05,730 --> 01:18:09,025
linguagem arcano em menos confortável
mode, onde nós, o corpo docente,

1569
01:18:09,025 --> 01:18:12,150
passaram por e tentou simplificar
um pouco da linguagem para manter as coisas

1570
01:18:12,150 --> 01:18:14,830
incidiu sobre as ideias, e não
alguns dos aspectos técnicos.

1571
01:18:14,830 --> 01:18:20,070
Portanto, tenha em mente, reference.cs50.net
como outro recurso também.

1572
01:18:20,070 --> 01:18:23,800
>> Mas por que funciona comprimento da corda em
a maneira como eu propus um momento atrás?

1573
01:18:23,800 --> 01:18:25,160
Aqui é o nome do Zamyla novamente.

1574
01:18:25,160 --> 01:18:27,690
E aqui é o nome do Zamyla
encaixotado, como eu continuar fazendo,

1575
01:18:27,690 --> 01:18:31,360
para pintar uma imagem de ser,
realmente, apenas uma sequência de caracteres.

1576
01:18:31,360 --> 01:18:34,260
Mas não existe Zamyla
no isolamento de um programa.

1577
01:18:34,260 --> 01:18:37,420
>> Quando você escrever e executar um programa,
você está usando o seu Mac ou PC

1578
01:18:37,420 --> 01:18:40,010
como memória, ou RAM, por assim dizer.

1579
01:18:40,010 --> 01:18:42,620
E você pode pensar
o computador como tendo

1580
01:18:42,620 --> 01:18:44,730
lotes de gigabytes de memória nestes dias.

1581
01:18:44,730 --> 01:18:47,700
E um show significa bilhões,
por isso milhares de milhões de bytes.

1582
01:18:47,700 --> 01:18:48,910
>> Mas vamos retroceder no tempo.

1583
01:18:48,910 --> 01:18:51,530
E suponha que estamos usando
um computador muito antigo que

1584
01:18:51,530 --> 01:18:55,150
só tem 32 bytes de memória.

1585
01:18:55,150 --> 01:18:59,310
Eu poderia, na tela do meu computador,
simplesmente desenhar isso como se segue.

1586
01:18:59,310 --> 01:19:05,240
>> Eu poderia simplesmente dizer que o meu
computador tem toda essa memória.

1587
01:19:05,240 --> 01:19:08,830
E isso é como uma vara de memória, se
você se lembra a nossa imagem da última vez.

1588
01:19:08,830 --> 01:19:11,670
E se eu apenas dividir
isso em várias vezes,

1589
01:19:11,670 --> 01:19:15,040
Eu afirmo que tenho 32 bytes
de memória na tela.

1590
01:19:15,040 --> 01:19:18,239
>> Agora, na realidade, só posso
desenhar até agora nesta tela aqui.

1591
01:19:18,239 --> 01:19:20,280
Então, eu estou indo para a frente,
e apenas por convenção,

1592
01:19:20,280 --> 01:19:24,050
chamar a memória do meu computador como um
grade, não apenas como uma linha reta.

1593
01:19:24,050 --> 01:19:28,190
Especificamente, eu afirmo agora que
essa grade, esta grade 8 por 4,

1594
01:19:28,190 --> 01:19:31,800
apenas representa todos os 32 bytes
de memória disponível no meu Mac,

1595
01:19:31,800 --> 01:19:33,030
ou disponíveis em meu PC.

1596
01:19:33,030 --> 01:19:34,780
E eles estão enrolando
em duas linhas, apenas

1597
01:19:34,780 --> 01:19:38,030
porque ele se encaixa mais na tela.

1598
01:19:38,030 --> 01:19:40,800
Mas este é o primeiro byte.

1599
01:19:40,800 --> 01:19:41,990
Este é o segundo byte.

1600
01:19:41,990 --> 01:19:43,300
Este é o terceiro byte.

1601
01:19:43,300 --> 01:19:45,310
>> E este é o byte 32.

1602
01:19:45,310 --> 01:19:52,910
Ou, se pensarmos como um computador
cientista, isto é o octeto 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Então você tem 0 a 31, se
você começar a contar a 0.

1604
01:19:55,950 --> 01:19:59,830
>> Então, se nós usamos um programa
que as chamadas obter corda,

1605
01:19:59,830 --> 01:20:05,280
e ficamos com uma corda do humano
como eu fiz chamado Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
como no mundo faz o
faixa do computador sustento dos quais byte,

1607
01:20:09,430 --> 01:20:12,230
que pedaço de memória,
pertence a qual corda?

1608
01:20:12,230 --> 01:20:16,270
Em outras palavras, se proceder à
digite um outro nome para o computador,

1609
01:20:16,270 --> 01:20:19,890
como este Andi, chamando
obter cadeia uma segunda vez,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I tem que acabar no
memória do computador também.

1611
01:20:23,030 --> 01:20:23,850
Mas como?

1612
01:20:23,850 --> 01:20:29,700
>> Bem, acontece que por baixo da
capô, o C faz quando armazenar cordas

1613
01:20:29,700 --> 01:20:35,080
que os tipos humanos, ou que
vir de alguma outra fonte, é

1614
01:20:35,080 --> 01:20:39,190
delineia a fim de lhes
uma barra invertida character-- especial

1615
01:20:39,190 --> 01:20:44,750
0, que é apenas uma maneira especial
de dizer 80 bits em uma fileira.

1616
01:20:44,750 --> 01:20:47,950
>> Então A-- este é o recall número 97.

1617
01:20:47,950 --> 01:20:51,770
Então, algum padrão de 8 bits
representa o número decimal 97.

1618
01:20:51,770 --> 01:20:58,070
Esta barra invertida 0 é, literalmente, o número
0, nul a.k.a., N-L-G, ao contrário da anterior,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, que falamos sobre.

1620
01:20:59,630 --> 01:21:05,700
Mas, por enquanto, só sei que esta
barra invertida 0 é apenas 80 bits em uma fileira.

1621
01:21:05,700 --> 01:21:09,810
>> E é apenas esta linha no
areia que diz qualquer coisa à esquerda

1622
01:21:09,810 --> 01:21:12,610
pertence a uma corda, ou um tipo de dados.

1623
01:21:12,610 --> 01:21:15,480
E qualquer coisa para a direita
pertence a alguma outra coisa.

1624
01:21:15,480 --> 01:21:17,440
Andi do nome, entretanto,
que apenas visualmente

1625
01:21:17,440 --> 01:21:21,310
acontece para embrulhar para a outra linha,
mas isso é apenas um detalhe estético,

1626
01:21:21,310 --> 01:21:23,990
Do mesmo modo é nul terminada.

1627
01:21:23,990 --> 01:21:29,290
>> É uma seqüência de caracteres a A-N-D-I,
além de um quinto personagem secreto,

1628
01:21:29,290 --> 01:21:33,560
todos os 0 bits, que só demarcam
o fim do nome do andi bem.

1629
01:21:33,560 --> 01:21:37,120
E se nós chamamos obter seqüência de uma terceira vez
no computador para obter uma string como

1630
01:21:37,120 --> 01:21:44,210
Maria, H-A-R-I-A, de forma semelhante é o Maria
nome nul terminou com barra invertida 0.

1631
01:21:44,210 --> 01:21:47,170
>> Isto é fundamentalmente diferente
de como um computador faria normalmente

1632
01:21:47,170 --> 01:21:51,850
armazenar um número inteiro, ou um float, ou outra
tipos de dados ainda, porque recall,

1633
01:21:51,850 --> 01:21:57,420
um inteiro é geralmente de 32 bits, ou
4 bytes, ou talvez até 64 bits,

1634
01:21:57,420 --> 01:21:59,100
ou oito bytes.

1635
01:21:59,100 --> 01:22:02,620
Mas muitas primitivas em um computador
em uma linguagem de programação

1636
01:22:02,620 --> 01:22:05,550
têm um número fixo de
bytes debaixo da hood--

1637
01:22:05,550 --> 01:22:08,100
talvez um, talvez dois, talvez 4, talvez 8.

1638
01:22:08,100 --> 01:22:13,250
>> Mas cordas, pelo projeto, ter um
número dinâmico de caracteres.

1639
01:22:13,250 --> 01:22:16,980
Você não sabe com antecedência, até
os tipos humanos em Z-A-H-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
ou M-A-R-I-A, ou A-N-D-I. Você não sabe
quantas vezes o usuário está indo para bater

1641
01:22:21,400 --> 01:22:22,070
o teclado.

1642
01:22:22,070 --> 01:22:26,490
Portanto, você não sabe como
muitos personagens de antecedência

1643
01:22:26,490 --> 01:22:27,540
você vai precisar.

1644
01:22:27,540 --> 01:22:31,840
>> E assim C apenas uma espécie de folhas como um
breadcrumb segredo debaixo do capô

1645
01:22:31,840 --> 01:22:32,960
no final da cadeia.

1646
01:22:32,960 --> 01:22:39,280
Depois de armazenar Z-A-H-Y-L-A em memória,
ele também só coloca o equivalente

1647
01:22:39,280 --> 01:22:40,210
de um período.

1648
01:22:40,210 --> 01:22:45,060
No final de uma frase,
põe 80 bits, de modo

1649
01:22:45,060 --> 01:22:49,120
se lembrar de onde
Zamyla começa e termina.

1650
01:22:49,120 --> 01:22:51,490
>> Então, qual é a conexão,
então, para este programa?

1651
01:22:51,490 --> 01:22:55,190
Este programa aqui, Stirling,
é simplesmente um mecanismo

1652
01:22:55,190 --> 01:22:57,970
para obter uma string
do utilizador, a linha 6.

1653
01:22:57,970 --> 01:23:01,160
Linha 7, eu declarar uma variável
chamado n e defini-lo igual a 0.

1654
01:23:01,160 --> 01:23:08,680
>> E, em seguida, na linha 8, eu simplesmente perguntou ao
pergunta, enquanto o personagem N-th faz

1655
01:23:08,680 --> 01:23:12,120
é igual a todos os 0 bits--
Em outras palavras, não faz

1656
01:23:12,120 --> 01:23:14,500
igual este especial
caráter, barra invertida 0, o que

1657
01:23:14,500 --> 01:23:18,470
Era só que character-- nul especial
vá em frente e apenas incrementar n.

1658
01:23:18,470 --> 01:23:21,460
>> E continuar fazendo isso, e manter a
fazendo isso, e continuar fazendo isso.

1659
01:23:21,460 --> 01:23:23,430
E por isso mesmo que em
o passado nós usamos i,

1660
01:23:23,430 --> 01:23:25,181
é perfeitamente bem
semanticamente para usar N,

1661
01:23:25,181 --> 01:23:27,430
se você está apenas tentando
contar desta vez deliberadamente,

1662
01:23:27,430 --> 01:23:28,720
e só quero chamá-lo n.

1663
01:23:28,720 --> 01:23:34,720
Então, isso simplesmente continua fazendo a pergunta,
é o personagem n-th de s todos os 0s?

1664
01:23:34,720 --> 01:23:38,470
Se não, olhe para o próximo look,
olhar para o outro, olhar para o outro,

1665
01:23:38,470 --> 01:23:39,460
olhar para o próximo.

1666
01:23:39,460 --> 01:23:45,540
>> Mas assim que você vê barra invertida 0,
esta linha loop-- 9 a 11-- pára.

1667
01:23:45,540 --> 01:23:49,640
Você sair do loop while,
deixando dentro dessa variável n

1668
01:23:49,640 --> 01:23:54,530
uma contagem total de todo o
caracteres na seqüência que você viu,

1669
01:23:54,530 --> 01:23:55,660
imprimi-lo desse modo para fora.

1670
01:23:55,660 --> 01:23:56,760
Então, vamos tentar isso.

1671
01:23:56,760 --> 01:23:59,500
>> Deixe-me ir em frente e, sem
utilizando a função de Stirling,

1672
01:23:59,500 --> 01:24:04,240
mas apenas usando minha própria versão homegrown
aqui chamado de Stirling, deixe-me ir em frente

1673
01:24:04,240 --> 01:24:07,700
e correr Stirling, digite algo
como Zamyla, que eu saiba com antecedência

1674
01:24:07,700 --> 01:24:08,670
é de seis caracteres.

1675
01:24:08,670 --> 01:24:10,080
Vamos ver se funciona.

1676
01:24:10,080 --> 01:24:10,920
Na verdade, é seis.

1677
01:24:10,920 --> 01:24:15,257
Vamos tentar com Rob, três personagens,
três caracteres, bem como, e assim por diante.

1678
01:24:15,257 --> 01:24:17,340
Então, isso é tudo o que está acontecendo
por baixo do capuz.

1679
01:24:17,340 --> 01:24:19,548
E observe as conexões,
depois, com a primeira semana

1680
01:24:19,548 --> 01:24:22,370
de classe, onde falamos sobre
algo como abstração,

1681
01:24:22,370 --> 01:24:26,960
que é apenas isso camadas de ideias, ou
complexidade, no topo dos princípios básicos.

1682
01:24:26,960 --> 01:24:30,710
Aqui, nós estamos olhando tipo de
debaixo do capô de Stirling,

1683
01:24:30,710 --> 01:24:33,510
por assim dizer, de descobrir,
como ele seria implementado?

1684
01:24:33,510 --> 01:24:35,232
>> E nós poderíamos re-implementá-lo nós mesmos.

1685
01:24:35,232 --> 01:24:37,440
Mas estamos nunca mais vai
reimplementar Stirling.

1686
01:24:37,440 --> 01:24:39,780
Nós apenas estamos indo para
Stirling, a fim usar

1687
01:24:39,780 --> 01:24:42,100
para realmente obter algum comprimento cordas.

1688
01:24:42,100 --> 01:24:44,200
>> Mas não há mágica
debaixo do capô.

1689
01:24:44,200 --> 01:24:46,716
Se você sabe que por baixo
o capô, uma string

1690
01:24:46,716 --> 01:24:48,090
é apenas uma sequência de caracteres.

1691
01:24:48,090 --> 01:24:51,090
E essa sequência de caracteres
tudo pode ser numericamente dirigida

1692
01:24:51,090 --> 01:24:53,330
com o suporte 0, suporte
1, o suporte 2, e você

1693
01:24:53,330 --> 01:24:57,420
sabe que no final de uma sequência é um
caractere especial, você pode descobrir

1694
01:24:57,420 --> 01:25:01,710
como fazer mais qualquer coisa em um
programa, porque tudo o que se resume a

1695
01:25:01,710 --> 01:25:03,400
é a leitura ea escrita de memória.

1696
01:25:03,400 --> 01:25:06,130
Isto é, a mudança e à procura
na memória, ou mover as coisas

1697
01:25:06,130 --> 01:25:10,940
em torno da memória, coisas de impressão
na tela, e assim por diante.

1698
01:25:10,940 --> 01:25:14,800
>> Então, vamos agora usar essa nova
compreensão do que realmente amarra

1699
01:25:14,800 --> 01:25:17,910
estão debaixo do capô, e
descascar uma outra camada

1700
01:25:17,910 --> 01:25:20,080
que até agora nós temos
sido ignorando completamente.

1701
01:25:20,080 --> 01:25:22,650
Em particular, qualquer momento
temos implementado um programa,

1702
01:25:22,650 --> 01:25:25,930
nós tivemos esta linha de código
perto do topo declarando principal.

1703
01:25:25,930 --> 01:25:27,810
E nós temos especificado void main int.

1704
01:25:27,810 --> 01:25:31,240
>> E esse vazio dentro dos parênteses
tem vindo a dizer todo esse tempo que a principal

1705
01:25:31,240 --> 01:25:33,440
em si não recebe qualquer argumento.

1706
01:25:33,440 --> 01:25:36,210
Qualquer entrada que o principal é
vai começar a partir do utilizador

1707
01:25:36,210 --> 01:25:39,020
tem que vir de algum outro
mecanismo, como get int,

1708
01:25:39,020 --> 01:25:42,040
ou obter float, ou obter corda,
ou alguma outra função.

1709
01:25:42,040 --> 01:25:44,710
Mas verifica-se que
quando você escreve um programa,

1710
01:25:44,710 --> 01:25:47,690
você pode realmente especificar
que este programa

1711
01:25:47,690 --> 01:25:51,730
tomar entradas do humano
na própria linha de comando.

1712
01:25:51,730 --> 01:25:56,310
>> Em outras palavras, mesmo que até agora
ter sido executado apenas ./hello Olá

1713
01:25:56,310 --> 01:26:00,312
ou programas semelhantes, todos do
outros programas que temos vindo a utilizar,

1714
01:26:00,312 --> 01:26:02,770
que nós mesmos não escreveu,
tem vindo a tomar, ao que parece,

1715
01:26:02,770 --> 01:26:05,210
linha de comando arguments--
coisas como fazer.

1716
01:26:05,210 --> 01:26:07,450
Você diz algo como marca,
e, em seguida, uma segunda palavra.

1717
01:26:07,450 --> 01:26:10,950
Ou clang, você diz clang, e em seguida
uma segunda palavra, o nome de um ficheiro.

1718
01:26:10,950 --> 01:26:14,410
>> Ou mesmo RM ou CP, como você pode
ter visto ou já utilizado

1719
01:26:14,410 --> 01:26:15,880
para remover ou copiar arquivos.

1720
01:26:15,880 --> 01:26:18,920
Todos aqueles tomar chamada
linha de comando arguments--

1721
01:26:18,920 --> 01:26:21,130
palavras adicionais no prompt de terminal.

1722
01:26:21,130 --> 01:26:23,260
Mas até agora, nós
nós não tivemos

1723
01:26:23,260 --> 01:26:27,080
esse luxo de tomar a entrada do
usuário quando ele ou ela realmente funciona

1724
01:26:27,080 --> 01:26:29,120
o próprio programa na linha de comando.

1725
01:26:29,120 --> 01:26:33,710
>> Mas podemos fazer isso por re-declarar
principal em frente, não tendo

1726
01:26:33,710 --> 01:26:36,750
anular entre parênteses,
mas estes dois argumentos

1727
01:26:36,750 --> 01:26:40,600
instead-- o primeiro um inteiro,
e a segunda algo

1728
01:26:40,600 --> 01:26:44,170
novo, algo que nós vamos chamar
uma matriz, algo semelhante em espírito

1729
01:26:44,170 --> 01:26:49,220
ao que vimos em risco como uma lista, mas
uma matriz de cadeias, como veremos em breve.

1730
01:26:49,220 --> 01:26:51,790
Mas vamos ver isso
Como exemplo, antes de

1731
01:26:51,790 --> 01:26:53,690
distinguir exatamente o que isso significa.

1732
01:26:53,690 --> 01:26:56,520
>> Então, se eu entrar em CS50 IDE
aqui, eu tenho ido em frente

1733
01:26:56,520 --> 01:27:01,840
e declarou em um arquivo chamado
argv0.c o modelo a seguir.

1734
01:27:01,840 --> 01:27:04,120
E observe a única coisa
que é diferente até agora

1735
01:27:04,120 --> 01:27:08,570
é que eu tenha mudado vazio para int
cadeia argc argv suporte de abrir, fechar

1736
01:27:08,570 --> 01:27:09,070
suporte.

1737
01:27:09,070 --> 01:27:11,730
E observe, por enquanto, não há
nada dentro desses suportes.

1738
01:27:11,730 --> 01:27:12,620
>> Não há nenhum número.

1739
01:27:12,620 --> 01:27:15,070
E não há nenhum i, ou
n, ou qualquer outra letra.

1740
01:27:15,070 --> 01:27:17,010
Estou apenas usando o
colchetes, por agora,

1741
01:27:17,010 --> 01:27:19,510
por razões que virá
de volta para em apenas um momento.

1742
01:27:19,510 --> 01:27:21,330
>> E agora o que eu vou fazer é esta.

1743
01:27:21,330 --> 01:27:26,680
Se argc é igual é igual a 2--
e recordar que é igual a igual

1744
01:27:26,680 --> 01:27:30,040
é o operador de igualdade comparando
à esquerda e à direita para a igualdade.

1745
01:27:30,040 --> 01:27:31,790
Não é a atribuição
operador, que é

1746
01:27:31,790 --> 01:27:36,510
o sinal de igual única, o que significa cópia
da direita para a esquerda algum valor.

1747
01:27:36,510 --> 01:27:42,840
>> Se argc é igual é igual a 2, eu quero
digamos, printf, Olá, porcentagens, nova linha,

1748
01:27:42,840 --> 01:27:47,340
em seguida, conecte em-- e aqui está o novo
suporte de argv trick-- 1, por razões

1749
01:27:47,340 --> 01:27:48,840
que vamos voltar a em um momento.

1750
01:27:48,840 --> 01:27:52,110
Else if argc não
igual a 2, você sabe o quê?

1751
01:27:52,110 --> 01:27:57,400
Vamos apenas ir em frente e, como de costume, impressão
out Olá mundo sem substituição.

1752
01:27:57,400 --> 01:28:02,710
>> Assim, parece que, se argc, que
significa contagem de argumento, é igual a 2,

1753
01:28:02,710 --> 01:28:04,740
Eu estou indo para imprimir
Olá uma coisa ou outra.

1754
01:28:04,740 --> 01:28:07,560
Caso contrário, por padrão, eu sou
vai imprimir Olá mundo.

1755
01:28:07,560 --> 01:28:08,770
Então o que isso quer dizer?

1756
01:28:08,770 --> 01:28:15,550
>> Bem, deixe-me ir em frente e salvar
este arquivo, e depois fazem argv0,

1757
01:28:15,550 --> 01:28:18,940
e depois ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
E diz Olá mundo.

1759
01:28:20,300 --> 01:28:21,260
Agora, por que isso?

1760
01:28:21,260 --> 01:28:24,730
>> Bem, acontece que quando você
executar um programa na linha de comando,

1761
01:28:24,730 --> 01:28:29,570
estiver preenchendo o que vamos
geralmente chamamos de um vetor de argumento.

1762
01:28:29,570 --> 01:28:33,100
Em outras palavras, automaticamente o
computador, o sistema operativo,

1763
01:28:33,100 --> 01:28:38,340
vai entregar ao seu programa
-se uma lista de todas as palavras

1764
01:28:38,340 --> 01:28:40,850
que o ser humano digitado no
prompt, no caso de você

1765
01:28:40,850 --> 01:28:43,790
o programador quer fazer
algo com essa informação.

1766
01:28:43,790 --> 01:28:48,540
E, neste caso, a única palavra
Eu digitado no prompt é ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> E assim o número de argumentos que é
sendo passado para o meu programa é apenas um.

1768
01:28:55,420 --> 01:28:58,880
Em outras palavras, o argumento
contar, também conhecido como argc

1769
01:28:58,880 --> 01:29:00,970
aqui como um inteiro, é apenas um.

1770
01:29:00,970 --> 01:29:03,000
Um, é claro, não é igual a dois.

1771
01:29:03,000 --> 01:29:05,980
E então é isso que imprime, Olá mundo.

1772
01:29:05,980 --> 01:29:08,170
>> Mas deixe-me levar isso em algum lugar.

1773
01:29:08,170 --> 01:29:09,930
Deixe-me dizer, argv0.

1774
01:29:09,930 --> 01:29:12,740
E então como sobre Maria?

1775
01:29:12,740 --> 01:29:14,990
E, em seguida, pressione Enter.

1776
01:29:14,990 --> 01:29:18,020
>> E observe o que acontece magicamente aqui.

1777
01:29:18,020 --> 01:29:22,640
Agora, em vez de mundo Olá, tenho
alterou o comportamento deste programa

1778
01:29:22,640 --> 01:29:26,310
tomando a entrada não de get
corda ou alguma outra função,

1779
01:29:26,310 --> 01:29:30,570
mas a partir de, aparentemente, o meu comando
em si, o que eu originalmente digitada.

1780
01:29:30,570 --> 01:29:35,720
E eu posso jogar este jogo novamente
mudá-lo para Stelios, por exemplo.

1781
01:29:35,720 --> 01:29:38,400
>> E agora eu vejo outro nome ainda.

1782
01:29:38,400 --> 01:29:40,540
E aqui, eu poderia dizer Andi.

1783
01:29:40,540 --> 01:29:42,137
E eu poderia dizer Zamyla.

1784
01:29:42,137 --> 01:29:45,220
E nós podemos jogar este jogo durante todo o dia,
apenas ligar valores diferentes,

1785
01:29:45,220 --> 01:29:49,550
contanto que eu fornecer exatamente
duas palavras no prompt,

1786
01:29:49,550 --> 01:29:52,260
de tal forma que argc, contar o meu argumento, é 2.

1787
01:29:52,260 --> 01:29:57,240
>> Não vejo que o nome ligado a
printf, por essa condição aqui?

1788
01:29:57,240 --> 01:30:00,550
Então parece que temos agora
a capacidade expressiva

1789
01:30:00,550 --> 01:30:04,410
de tomar a entrada de outro mecanismo,
na linha de comando chamada,

1790
01:30:04,410 --> 01:30:07,000
ao invés de ter que esperar
até que o usuário executa o programa,

1791
01:30:07,000 --> 01:30:10,220
e, em seguida, pedir-lhe
usando algo como corda get.

1792
01:30:10,220 --> 01:30:11,230
>> Então, o que é isso?

1793
01:30:11,230 --> 01:30:15,010
Argc, mais uma vez, é apenas um inteiro,
o número de palavras-- arguments--

1794
01:30:15,010 --> 01:30:18,540
que o utilizador proporcionado na
alerta, na janela de terminal,

1795
01:30:18,540 --> 01:30:20,110
incluindo o nome do programa.

1796
01:30:20,110 --> 01:30:23,340
Portanto, a nossa ./argv0 é, efetivamente,
o nome do programa,

1797
01:30:23,340 --> 01:30:24,520
ou como eu executar o programa.

1798
01:30:24,520 --> 01:30:25,810
>> Isso conta como uma palavra.

1799
01:30:25,810 --> 01:30:27,080
Assim, seria uma argc.

1800
01:30:27,080 --> 01:30:29,750
Mas quando eu escrevo Stelios, ou
Andi, ou Zamyla, ou Maria,

1801
01:30:29,750 --> 01:30:31,660
isso significa que o número de argumentos é dois.

1802
01:30:31,660 --> 01:30:33,910
E agora há duas palavras passado para ele.

1803
01:30:33,910 --> 01:30:36,070
>> E notem, podemos continuar essa lógica.

1804
01:30:36,070 --> 01:30:39,050
Se eu realmente dizer
algo como Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
um nome completo, passando, assim,
três argumentos no total,

1806
01:30:42,200 --> 01:30:47,410
Agora ele diz que o padrão novo,
porque, obviamente, 3 não é igual a dois.

1807
01:30:47,410 --> 01:30:54,080
>> E assim, desta forma, eu tenho
acesso via argv este novo argumento

1808
01:30:54,080 --> 01:30:56,080
que poderíamos tecnicamente
chamar qualquer coisa que quisermos.

1809
01:30:56,080 --> 01:30:58,940
Mas, por convenção, é
argv e argc, respectivamente.

1810
01:30:58,940 --> 01:31:04,470
Argv, vetor argumento, é uma espécie
de um sinónimo para uma programação

1811
01:31:04,470 --> 01:31:07,140
recurso em C chamado um array.

1812
01:31:07,140 --> 01:31:14,410
>> Uma matriz é uma lista de valores semelhantes
para trás, para trás, para trás, para trás.

1813
01:31:14,410 --> 01:31:17,810
Em outras palavras, se um está bem aqui em
RAM, a próxima é bem próximo a ela,

1814
01:31:17,810 --> 01:31:18,800
e à direita próximo a ele.

1815
01:31:18,800 --> 01:31:20,101
Eles não estão em todo o lugar.

1816
01:31:20,101 --> 01:31:23,100
E que este último cenário, onde as coisas
estão por todo o lugar na memória,

1817
01:31:23,100 --> 01:31:25,082
pode realmente ser um poderoso recurso.

1818
01:31:25,082 --> 01:31:28,040
Mas vamos voltar a isso quando nós
falar sobre estruturas de dados mais sofisticados.

1819
01:31:28,040 --> 01:31:32,260
Por enquanto, uma matriz é apenas um
pedaço de memória contígua,

1820
01:31:32,260 --> 01:31:36,520
cada um de cujos elementos são
para trás, para trás, para trás, para trás,

1821
01:31:36,520 --> 01:31:38,050
e, geralmente, do mesmo tipo.

1822
01:31:38,050 --> 01:31:42,630
>> Então, se você pensar, a partir de um
há pouco, o que é uma cadeia?

1823
01:31:42,630 --> 01:31:50,460
Bem, uma corda, como Zamyla,
Z-A-H-Y-L-A, é, tecnicamente,

1824
01:31:50,460 --> 01:31:51,400
apenas uma matriz.

1825
01:31:51,400 --> 01:31:53,700
É uma matriz de caracteres.

1826
01:31:53,700 --> 01:31:59,250
>> E por isso, se nós realmente chamar a isso, como eu
fez anteriormente, como um pedaço de memória,

1827
01:31:59,250 --> 01:32:04,510
verifica-se que cada um destes
caracteres ocupa um byte.

1828
01:32:04,510 --> 01:32:07,630
E depois há aquele especial
caráter sentinela, a barra invertida 0,

1829
01:32:07,630 --> 01:32:12,360
ou todos os oito bits de 0, que
demarca o fim dessa cadeia.

1830
01:32:12,360 --> 01:32:15,090
Assim, uma corda, ele se transforma
para fora, citar cadeia unquote,

1831
01:32:15,090 --> 01:32:20,580
é apenas um conjunto de chara--
carbonizar ser um tipo de dados real.

1832
01:32:20,580 --> 01:32:24,560
>> E agora argv, meanwhile--
vamos voltar para o programa.

1833
01:32:24,560 --> 01:32:29,582
Argv, apesar de ver a palavra
cadeia aqui, não é uma string em si.

1834
01:32:29,582 --> 01:32:33,640
Argv, o argumento do vetor,
é uma matriz de cadeias.

1835
01:32:33,640 --> 01:32:37,620
>> Então, assim como você pode ter uma variedade de
caracteres, você pode ter nível superior,

1836
01:32:37,620 --> 01:32:46,279
uma matriz de strings-- Assim, por exemplo,
quando eu digitei um momento atrás ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, espaço Z-A-M-Y-L-A, I alegou que
argv tinha duas cordas em ./argv0 ele--,

1838
01:33:00,150 --> 01:33:03,185
e Z-A-H-Y-L-A. Dentro
outras palavras, foi argc 2.

1839
01:33:03,185 --> 01:33:03,980
Por que é que?

1840
01:33:03,980 --> 01:33:08,370
>> Bem, de forma eficaz, o que está acontecendo
on é que cada uma dessas cordas

1841
01:33:08,370 --> 01:33:13,990
é, naturalmente, uma série de caracteres
Como antes, cada um de cujos personagens

1842
01:33:13,990 --> 01:33:15,670
ocupa um byte.

1843
01:33:15,670 --> 01:33:19,720
E não confundir a 0 real
em nome do programa com a 0,

1844
01:33:19,720 --> 01:33:22,040
o que significa que todos os 80 bits.

1845
01:33:22,040 --> 01:33:27,140
E Zamyla, entretanto, ainda é
também uma matriz de caracteres.

1846
01:33:27,140 --> 01:33:31,450
>> Assim, no final do dia, ele realmente
se parece com isso debaixo do capô.

1847
01:33:31,450 --> 01:33:38,800
Mas argv, por natureza, de como principal
obras, permite-me para embrulhar tudo isso

1848
01:33:38,800 --> 01:33:44,810
-se para, se quiserem, uma matriz maior
que, se um pouco mais de simplificar

1849
01:33:44,810 --> 01:33:48,180
o que a imagem se parece e não
bastante desenhá-lo para escalar lá em cima,

1850
01:33:48,180 --> 01:33:56,720
essa matriz é apenas o tamanho 2, o primeiro
elemento que contém uma string,

1851
01:33:56,720 --> 01:33:59,230
o segundo elemento de
que contém uma string.

1852
01:33:59,230 --> 01:34:01,687
E, por sua vez, se
tipo de zoom em cada

1853
01:34:01,687 --> 01:34:03,770
dessas cordas, o que lhe
veja debaixo do capô

1854
01:34:03,770 --> 01:34:07,190
é que cada corda é apenas
um conjunto de caracteres.

1855
01:34:07,190 --> 01:34:11,680
>> Agora, assim como com cordas,
fomos capazes de obter acesso

1856
01:34:11,680 --> 01:34:15,260
ao caráter i-th em uma string
usando essa notação colchete.

1857
01:34:15,260 --> 01:34:17,320
Da mesma forma, com matrizes
Em geral, podemos

1858
01:34:17,320 --> 01:34:22,700
usar a notação de colchete para obter
em qualquer número de cordas em uma matriz?

1859
01:34:22,700 --> 01:34:25,100
Por exemplo, deixe-me
vá em frente e fazer isso.

1860
01:34:25,100 --> 01:34:32,420
>> Deixe-me ir em frente e criar argv1.c,
que é um pouco diferente desta vez.

1861
01:34:32,420 --> 01:34:35,635
Em vez de verificar para argc2,
Vou vez fazer isso.

1862
01:34:35,635 --> 01:34:41,270
Para int eu recebo 0, I é menos
que argc, eu plus plus,

1863
01:34:41,270 --> 01:34:47,920
e, em seguida, imprimir dentro desta,
por cento s, nova linha e, em seguida,

1864
01:34:47,920 --> 01:34:50,740
argv suporte de i.

1865
01:34:50,740 --> 01:34:55,220
>> Portanto, em outras palavras, eu não estou lidando com
caracteres individuais no momento.

1866
01:34:55,220 --> 01:35:00,190
Argv, como sugere estes quadrado vazio
cintas à direita do nome argv,

1867
01:35:00,190 --> 01:35:03,320
significa argv é um array de strings.

1868
01:35:03,320 --> 01:35:04,870
E argc é apenas um int.

1869
01:35:04,870 --> 01:35:08,800
>> Esta linha aqui, 6, é
dizendo set i igual a 0.

1870
01:35:08,800 --> 01:35:11,980
Contagem todo o caminho até,
mas não incluindo, argc.

1871
01:35:11,980 --> 01:35:14,010
E, em seguida, em cada iteração,
imprimir uma string.

1872
01:35:14,010 --> 01:35:14,800
O que corda?

1873
01:35:14,800 --> 01:35:17,270
>> A cadeia i-th em argv.

1874
01:35:17,270 --> 01:35:19,530
Assim, enquanto que antes eu era
usando o colchete

1875
01:35:19,530 --> 01:35:22,180
notação para chegar ao om
carácter de uma cadeia, agora

1876
01:35:22,180 --> 01:35:27,240
Eu estou usando a notação colchete
para chegar à cadeia om em uma matriz.

1877
01:35:27,240 --> 01:35:30,310
Então, é uma espécie de uma camada
acima, conceptualmente.

1878
01:35:30,310 --> 01:35:35,390
>> E então o que é interessante sobre esta
programa de agora, se eu compilar argv1,

1879
01:35:35,390 --> 01:35:42,067
e depois fazer ./argv1 e digite
em algo como foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
que são as três palavras padrão que um
cientista da computação pega qualquer momento

1881
01:35:45,400 --> 01:35:51,010
ele ou ela precisa de algumas palavras de espaço reservado,
e pressione Enter, cada uma dessas palavras,

1882
01:35:51,010 --> 01:35:54,980
incluindo o nome do programa, que
é em argv no primeiro local,

1883
01:35:54,980 --> 01:35:58,320
termina-se a ser impresso um de cada vez.

1884
01:35:58,320 --> 01:36:05,290
E se eu mudar isso, e eu digo
algo como argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
temos todos os três daqueles
palavras, que é argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, porque neste
caso argc, a contagem, é 3.

1887
01:36:14,400 --> 01:36:20,020
>> Mas o que é interessante é se você entender
que argv é apenas uma matriz de cadeias,

1888
01:36:20,020 --> 01:36:24,910
e você entende que uma string
é um array de caracteres,

1889
01:36:24,910 --> 01:36:29,470
podemos realmente tipo de usar este
notação colchete várias vezes

1890
01:36:29,470 --> 01:36:33,320
para escolher uma corda, em seguida, escolha
um personagem dentro da cadeia,

1891
01:36:33,320 --> 01:36:35,730
mergulho em profundo como se segue.

1892
01:36:35,730 --> 01:36:40,100
Neste exemplo, deixe-me ir
em frente e chamar este argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
E, neste exemplo, deixe-me ir em frente
e fazer o following-- para int i obter 0,

1895
01:36:50,180 --> 01:36:53,286
i é menos de argc, i mais
Além disso, como antes.

1896
01:36:53,286 --> 01:36:55,910
Portanto, em outras palavras-- e agora este
está ficando complicado o suficiente.

1897
01:36:55,910 --> 01:36:59,940
Então eu vou dizer
iterar sobre cordas em argv,

1898
01:36:59,940 --> 01:37:01,294
como um comentário para mim mesmo.

1899
01:37:01,294 --> 01:37:03,960
E então eu vou ter um
aninhada para loop, que você provavelmente

1900
01:37:03,960 --> 01:37:06,290
ter feito, ou considerado
fazendo, em arranhões, onde

1901
01:37:06,290 --> 01:37:08,600
Eu vou dizer que eu sou int--
não vai usar i novamente,

1902
01:37:08,600 --> 01:37:12,590
porque eu não quero sombra, ou
tipo de substituir o i existente.

1903
01:37:12,590 --> 01:37:15,780
>> Eu estou indo para, em vez disso, dizem j, porque
essa é a minha vez de variável após i,

1904
01:37:15,780 --> 01:37:18,590
quando eu só estou tentando
contar números simples.

1905
01:37:18,590 --> 01:37:28,850
Para j obtém 0-- e também, N, vai
obter o comprimento popa do suporte de argv i,

1906
01:37:28,850 --> 01:37:36,030
desde que J é inferior a M,
j plus plus, faça o seguinte.

1907
01:37:36,030 --> 01:37:37,500
E aqui é a parte interessante.

1908
01:37:37,500 --> 01:37:46,330
>> Imprimir um caráter e uma nova linha,
conectando suporte argv i, j suporte.

1909
01:37:46,330 --> 01:37:47,940
OK, então deixe-me acrescentar alguns comentários aqui.

1910
01:37:47,940 --> 01:37:54,820
Iterar sobre personagens
na seqüência atual,

1911
01:37:54,820 --> 01:38:02,290
impressão de caracteres j-th na cadeia i-th.

1912
01:38:02,290 --> 01:38:04,630
Então, agora, vamos considerar
que esses comentários dizer.

1913
01:38:04,630 --> 01:38:06,750
>> Iterar sobre as cordas
em argv-- quantas

1914
01:38:06,750 --> 01:38:09,300
cordas estão em argv, que é uma matriz?

1915
01:38:09,300 --> 01:38:13,420
Argc muitos, por isso estou a iteração
a partir de i igual a 0 até argc.

1916
01:38:13,420 --> 01:38:20,020
Enquanto isso, o número de caracteres
estão na cadeia i-th em argv?

1917
01:38:20,020 --> 01:38:22,880
>> Bem, para obter essa resposta,
Eu só chamar comprimento da corda

1918
01:38:22,880 --> 01:38:26,810
sobre os cuidados da cadeia corrente I
sobre, que é argv suporte de i.

1919
01:38:26,810 --> 01:38:30,090
E eu estou indo para armazenar temporariamente que
valor n, apenas para fins de armazenamento em cache,

1920
01:38:30,090 --> 01:38:31,590
para salvá-lo para a eficiência.

1921
01:38:31,590 --> 01:38:36,330
E então eu vou inicializar j a 0,
continuar enquanto j for menor que n,

1922
01:38:36,330 --> 01:38:38,430
e em cada incremento iteração j.

1923
01:38:38,430 --> 01:38:41,030
>> E então aqui, por
o meu comentário na linha 12,

1924
01:38:41,030 --> 01:38:43,390
imprimir um caráter,
seguido por uma nova linha,

1925
01:38:43,390 --> 01:38:48,140
suporte especificamente argv
i me dá a seqüência de i-th

1926
01:38:48,140 --> 01:38:51,690
em argv-- assim que a primeira palavra, o
segunda palavra, terceira palavra, que seja.

1927
01:38:51,690 --> 01:38:57,370
E, em seguida, mergulhos j no mais profundo, e fica
me o personagem j-th da palavra.

1928
01:38:57,370 --> 01:39:02,200
E assim, com efeito, você pode tratar
argv como um multi-dimensional,

1929
01:39:02,200 --> 01:39:06,050
como bidimensional, matriz,
em que cada palavra tipo de olhares

1930
01:39:06,050 --> 01:39:08,580
como este em sua mente de
olho, e cada personagem

1931
01:39:08,580 --> 01:39:10,930
é uma espécie de composto em
uma coluna, se isso ajuda.

1932
01:39:10,930 --> 01:39:13,260
>> Na realidade, quando provocá
este apart em futuras semanas,

1933
01:39:13,260 --> 01:39:15,580
ele vai ser um pouco
mais sofisticado do que isso.

1934
01:39:15,580 --> 01:39:17,800
Mas você pode realmente
pensar que, por enquanto,

1935
01:39:17,800 --> 01:39:22,110
como apenas isso bidimensional
array, em que um nível de que

1936
01:39:22,110 --> 01:39:23,260
é todas as cordas.

1937
01:39:23,260 --> 01:39:26,760
E então se você mergulhar mais fundo, você
pode chegar aos caracteres individuais

1938
01:39:26,760 --> 01:39:29,600
nele usando esta notação aqui.

1939
01:39:29,600 --> 01:39:31,620
>> Então, qual é o efeito líquido?

1940
01:39:31,620 --> 01:39:34,970
Deixe-me ir em frente e
fazer danado argv2---lo.

1941
01:39:34,970 --> 01:39:36,210
Eu cometi um erro aqui.

1942
01:39:36,210 --> 01:39:40,160
Implicitamente declarando a
Biblioteca Stirling função.

1943
01:39:40,160 --> 01:39:42,190
Então todo esse tempo, é
talvez apropriado

1944
01:39:42,190 --> 01:39:45,130
que estamos tipo de acabamento
exatamente onde começamos.

1945
01:39:45,130 --> 01:39:48,160
>> Eu estraguei tudo, declarando implicitamente
Biblioteca Stirling função.

1946
01:39:48,160 --> 01:39:48,987
OK, espere um minuto.

1947
01:39:48,987 --> 01:39:51,070
Lembro-me que, especialmente
uma vez que é aqui mesmo.

1948
01:39:51,070 --> 01:39:54,490
Preciso incluir string.h em
esta versão do programa.

1949
01:39:54,490 --> 01:40:00,050
>> Deixe-me ir em frente e incluem
string.h, salvo que, vá em frente

1950
01:40:00,050 --> 01:40:04,460
e recompilar argv2.

1951
01:40:04,460 --> 01:40:08,390
E agora, aqui vamos nós, fazer argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
E, embora seja um pouco
enigmática, à primeira vista,

1953
01:40:10,590 --> 01:40:15,690
perceber que, de fato, o que
é impresso é argv2 ponto.

1954
01:40:15,690 --> 01:40:19,970
>> Mas se eu digitar algumas palavras após o
alerta, como argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Enter, também um pouco
críptica à primeira vista.

1956
01:40:22,560 --> 01:40:30,540
Mas se deslocar para cima,
./argv2 Z-A-H-Y-G-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Então, nós temos iteração sobre cada palavra.

1958
01:40:32,190 --> 01:40:37,770
E, por sua vez, nós iterada
cada personagem dentro de uma palavra.

1959
01:40:37,770 --> 01:40:40,040
>> Agora, depois de tudo isto,
perceber que não há

1960
01:40:40,040 --> 01:40:43,120
um outro detalhe que estivemos tipo
de ignorar esse tempo todo.

1961
01:40:43,120 --> 01:40:46,180
Nós apenas brincou separar o que
entradas do principal pode ser?

1962
01:40:46,180 --> 01:40:47,780
E quanto a saída do principal?

1963
01:40:47,780 --> 01:40:50,540
>> Todo este tempo, temos sido
apenas copiando e colando

1964
01:40:50,540 --> 01:40:53,870
a palavra int na frente do principal,
que você pode ver on-line,

1965
01:40:53,870 --> 01:40:58,340
às vezes incorretamente em versões mais antigas
de C e compiladores, que eles dizem vazio,

1966
01:40:58,340 --> 01:40:59,410
ou nada.

1967
01:40:59,410 --> 01:41:01,580
Mas, com efeito, para a versão
de C que estamos usando,

1968
01:41:01,580 --> 01:41:06,180
C 11, ou 2011, percebe
que deve ser int.

1969
01:41:06,180 --> 01:41:09,300
E deve ser tanto
nula ou argc e argv aqui.

1970
01:41:09,300 --> 01:41:10,790
>> Mas por int main?

1971
01:41:10,790 --> 01:41:12,480
O que é que realmente retornando?

1972
01:41:12,480 --> 01:41:16,280
Bem, acontece que todo esse tempo,
qualquer momento que você tenha escrito um programa principal

1973
01:41:16,280 --> 01:41:18,440
está sempre retornando alguma coisa.

1974
01:41:18,440 --> 01:41:19,960
Mas tem sido fazê-lo secretamente.

1975
01:41:19,960 --> 01:41:23,350
>> Isso é algo que é um
int, como sugere a linha 5.

1976
01:41:23,350 --> 01:41:24,225
Mas o que int?

1977
01:41:24,225 --> 01:41:26,100
Bem, há este
convenção em programação,

1978
01:41:26,100 --> 01:41:29,790
pelo qual se nada tem
errado e tudo está bem,

1979
01:41:29,790 --> 01:41:34,250
programas e funções geralmente
return-- pouco counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 geralmente significa que tudo está bem.

1982
01:41:38,070 --> 01:41:40,610
Assim, mesmo que você acha de
-la como falsa em muitos contextos,

1983
01:41:40,610 --> 01:41:42,930
ele realmente geralmente significa uma coisa boa

1984
01:41:42,930 --> 01:41:49,560
>> Por outro lado, se um programa retorna 1,
ou negativo 1 ou 5, ou negativo 42,

1985
01:41:49,560 --> 01:41:52,941
ou qualquer-0 não valor,
que geralmente significa

1986
01:41:52,941 --> 01:41:54,190
que algo deu errado.

1987
01:41:54,190 --> 01:41:56,700
De fato, em seu próprio Mac ou PC,
você poderia ter realmente visto

1988
01:41:56,700 --> 01:42:01,050
uma mensagem de erro, pelo qual ele
diz uma coisa ou outra, erro

1989
01:42:01,050 --> 01:42:04,940
código de negativo 42, ou código de erro
23, ou algo parecido.

1990
01:42:04,940 --> 01:42:08,980
Esse número é geralmente apenas uma sugestão
para o programador, ou a empresa

1991
01:42:08,980 --> 01:42:11,174
que fez o software,
o que deu errado e por quê,

1992
01:42:11,174 --> 01:42:13,590
de modo que possam olhar através
sua documentação ou código,

1993
01:42:13,590 --> 01:42:15,465
e descobrir o que o
de erro significa realmente.

1994
01:42:15,465 --> 01:42:18,400
Ela geralmente não é
útil para nós usuários finais.

1995
01:42:18,400 --> 01:42:20,550
>> Mas quando principais retorna 0, tudo está bem.

1996
01:42:20,550 --> 01:42:23,770
E se você não especificar
o principal deve retornar,

1997
01:42:23,770 --> 01:42:26,950
Ela só vai automaticamente
retornar 0 para você.

1998
01:42:26,950 --> 01:42:30,870
Mas voltando algo
outra coisa é realmente útil.

1999
01:42:30,870 --> 01:42:34,660
>> Neste programa final, deixe-me
vá em frente e chamar este exit.c,

2000
01:42:34,660 --> 01:42:38,630
e introduzir o último de hoje
tópicos conhecidos, como um código de erro.

2001
01:42:38,630 --> 01:42:42,930
Deixe-me ir em frente e incluir o nosso
arquivos familiares em cima, fazer int main.

2002
01:42:42,930 --> 01:42:49,500
E, desta vez, vamos fazer int argc,
cadeia argv, e com os meus suportes

2003
01:42:49,500 --> 01:42:50,836
implicar que é na matriz.

2004
01:42:50,836 --> 01:42:52,460
E, em seguida, deixe-me apenas fazer uma verificação de sanidade.

2005
01:42:52,460 --> 01:42:56,640
Desta vez, se argc não
igual a 2, então você sabe o quê?

2006
01:42:56,640 --> 01:42:57,520
Esqueça.

2007
01:42:57,520 --> 01:43:03,170
Vou dizer que, hey, usuário,
você está faltando argumento de linha de comando

2008
01:43:03,170 --> 01:43:04,210
n barra invertida.

2009
01:43:04,210 --> 01:43:05,230
>> E então é isso.

2010
01:43:05,230 --> 01:43:06,130
Eu quero sair.

2011
01:43:06,130 --> 01:43:11,030
Vou preventivamente,
e prematuramente realmente, o retorno

2012
01:43:11,030 --> 01:43:12,810
algo que não seja o número 1.

2013
01:43:12,810 --> 01:43:15,360
O movimento de valor para o primeiro
erro que pode acontecer é 1.

2014
01:43:15,360 --> 01:43:17,860
Se você tiver alguma outra errada
situação que possa ocorrer,

2015
01:43:17,860 --> 01:43:21,390
pode-se dizer de retorno 2 ou retornar 3, ou
talvez até negativo 1 ou 2 negativo.

2016
01:43:21,390 --> 01:43:23,750
>> Estes são apenas códigos de saída
que são, geralmente,

2017
01:43:23,750 --> 01:43:27,770
só é útil para o programador, ou o
empresa que está enviando o software.

2018
01:43:27,770 --> 01:43:30,500
Mas o fato de que é
Não 0 é o que é importante.

2019
01:43:30,500 --> 01:43:34,310
Então, se neste programa, eu quero
garantir que esse programa só

2020
01:43:34,310 --> 01:43:38,190
funciona se o usuário fornece me
com uma contagem de argumentos de dois,

2021
01:43:38,190 --> 01:43:42,880
o nome do programa, e alguns outros
palavra, posso fazer valer tanto quanto se segue,

2022
01:43:42,880 --> 01:43:46,110
gritar com o usuário com provérbio printf,
faltando argumento de linha de comando,

2023
01:43:46,110 --> 01:43:46,970
retornar 1.

2024
01:43:46,970 --> 01:43:49,940
Que só vai imediatamente
sair do programa.

2025
01:43:49,940 --> 01:43:55,840
>> Só se argc é igual a 2 vamos descer
aqui, altura em que eu vou dizer,

2026
01:43:55,840 --> 01:44:00,410
Olá por cento s, barra invertida n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Em outras palavras, eu estou
não indo atrás argv 0,

2028
01:44:03,827 --> 01:44:05,410
que é apenas o nome do programa.

2029
01:44:05,410 --> 01:44:09,450
Quero imprimir Olá, vírgula,
a segunda palavra que o ser humano digitado.

2030
01:44:09,450 --> 01:44:12,580
E, neste caso em
linha 13, está tudo bem.

2031
01:44:12,580 --> 01:44:15,920
>> Eu sei que argc é 2
logicamente a partir deste programa.

2032
01:44:15,920 --> 01:44:17,770
Eu estou indo para ir em frente e retornar 0.

2033
01:44:17,770 --> 01:44:21,230
Como um aparte, tenha em mente que
isso é verdade em risco também.

2034
01:44:21,230 --> 01:44:24,760
>> Logicamente, eu poderia fazer isso
e encapsular estas linhas

2035
01:44:24,760 --> 01:44:27,020
de código nesta cláusula else aqui.

2036
01:44:27,020 --> 01:44:29,420
Mas isso é uma espécie de
desnecessariamente o recuo meu código.

2037
01:44:29,420 --> 01:44:31,800
E eu quero fazer de super
claro que não importa o que,

2038
01:44:31,800 --> 01:44:34,670
por padrão, Olá
algo vai obter impressos,

2039
01:44:34,670 --> 01:44:36,050
desde que o utilizador coopera.

2040
01:44:36,050 --> 01:44:39,360
>> Portanto, é muito comum o uso de
uma condição, apenas uma se,

2041
01:44:39,360 --> 01:44:41,870
para pegar alguns errada
situação, e depois sair.

2042
01:44:41,870 --> 01:44:45,690
E, em seguida, tanto tempo tudo é
bem, não tem uma pessoa,

2043
01:44:45,690 --> 01:44:48,060
mas só tem o código
fora que, se, porque é

2044
01:44:48,060 --> 01:44:51,060
equivalente neste
caso particular, logicamente.

2045
01:44:51,060 --> 01:44:54,480
Então, eu estou retornando 0, só para
significar explicitamente tudo está bem.

2046
01:44:54,480 --> 01:44:58,480
>> Se eu omitido o retorno 0, seria
presumir-se automaticamente para mim.

2047
01:44:58,480 --> 01:45:00,890
Mas agora que estou retornando
uma em, pelo menos, neste caso,

2048
01:45:00,890 --> 01:45:04,940
Eu vou, para uma boa medida e
clareza, retornar 0, neste caso.

2049
01:45:04,940 --> 01:45:09,690
Então, agora deixe-me ir em frente e fazer a saída,
que é um segue perfeito para a apenas sair.

2050
01:45:09,690 --> 01:45:14,401
>> Mas certifique-saída, e me deixe ir
em frente e fazer ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
E o programa gritou comigo,
faltando argumento de linha de comando.

2052
01:45:16,900 --> 01:45:18,120
OK, deixe-me cooperar.

2053
01:45:18,120 --> 01:45:23,810
>> Deixe-me em vez fazer ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
E agora ele diz, Olá David.

2055
01:45:25,190 --> 01:45:27,300
E você normalmente não ver isso.

2056
01:45:27,300 --> 01:45:30,650
>> Mas verifica-se que há uma
maneira especial em Linux para realmente ver

2057
01:45:30,650 --> 01:45:34,470
com o que o código de saída de um programa encerrado.

2058
01:45:34,470 --> 01:45:37,184
Às vezes em uma gráfica
mundo como Mac OS ou Windows,

2059
01:45:37,184 --> 01:45:40,100
você só vê estes números quando um
mensagem de erro aparece na tela

2060
01:45:40,100 --> 01:45:41,940
e o programador
mostra esse número.

2061
01:45:41,940 --> 01:45:44,773
Mas se quiser ver o que o erro
mensagem é, nós podemos fazer isso aqui--

2062
01:45:44,773 --> 01:45:48,100
assim ./exit, Enter, impressão
faltando argumento de linha de comando.

2063
01:45:48,100 --> 01:45:54,590
>> Se eu faço agora $ echo ?, que é
ridiculamente enigmático olhar.

2064
01:45:54,590 --> 01:45:56,590
Mas $?

2065
01:45:56,590 --> 01:45:59,220
é o encantamento mágico
que diz, hey, computador,

2066
01:45:59,220 --> 01:46:01,900
diga-me o que o anterior
código de saída do programa era.

2067
01:46:01,900 --> 01:46:03,410
E eu pressione Enter.

2068
01:46:03,410 --> 01:46:07,520
Vejo 1, porque isso é o que eu
disse a minha principal função para retornar.

2069
01:46:07,520 --> 01:46:12,310
>> Enquanto isso, se eu fizer ./exit David,
e pressione Enter, eu vejo, Olá David.

2070
01:46:12,310 --> 01:46:16,800
E se eu faço agora $ eco ?, eu vejo Olá 0.

2071
01:46:16,800 --> 01:46:19,080
E assim isso realmente vai
ser uma informação valiosa

2072
01:46:19,080 --> 01:46:23,420
no contexto do depurador, não tão
tanto que você, o ser humano, se importaria.

2073
01:46:23,420 --> 01:46:26,060
Mas o depurador e outras
programas usaremos este semestre

2074
01:46:26,060 --> 01:46:29,420
, muitas vezes, olhar para esse número,
mesmo que ele é tipo de escondido

2075
01:46:29,420 --> 01:46:32,780
a menos que você olhar para ele, para
determinar se um programa ou não de

2076
01:46:32,780 --> 01:46:37,050
execução foi correta ou incorreta.

2077
01:46:37,050 --> 01:46:40,450
>> E assim que nos leva a
este, no final do dia.

2078
01:46:40,450 --> 01:46:43,917
Começamos hoje, olhando para
depuração, e por sua vez no campo

2079
01:46:43,917 --> 01:46:46,750
em si, e, em seguida, mais interessante,
tecnicamente por baixo do capuz

2080
01:46:46,750 --> 01:46:49,490
em que as cordas são, o que durar
semana que acabamos levou para concedido,

2081
01:46:49,490 --> 01:46:51,900
e certamente os levou
para concedido em risco.

2082
01:46:51,900 --> 01:46:56,040
>> Em seguida, analisaram a forma como podemos acessar
caracteres individuais em uma corda,

2083
01:46:56,040 --> 01:47:00,310
e, em seguida, novamente teve um nível mais elevado
olhar para as coisas, olhando como bem--

2084
01:47:00,310 --> 01:47:04,226
Se queremos chegar a nível individual
elementos em uma lista como estrutura,

2085
01:47:04,226 --> 01:47:05,850
não podemos fazer isso com várias cadeias de caracteres?

2086
01:47:05,850 --> 01:47:08,050
E podemos com argumentos de linha de comando.

2087
01:47:08,050 --> 01:47:12,800
Mas esta imagem aqui de apenas caixas
é demonstrativa desta ideia geral

2088
01:47:12,800 --> 01:47:14,451
de uma matriz ou uma lista, ou um vetor.

2089
01:47:14,451 --> 01:47:16,450
E, dependendo do
contexto, todas estas palavras

2090
01:47:16,450 --> 01:47:17,880
significar coisas ligeiramente diferentes.

2091
01:47:17,880 --> 01:47:20,060
Assim, em C, estamos apenas indo
para falar sobre uma matriz.

2092
01:47:20,060 --> 01:47:23,840
E uma matriz é um pedaço
da memória, cada um dos quais é

2093
01:47:23,840 --> 01:47:27,720
elementos são contíguos, de volta,
para trás, para trás, para trás.

2094
01:47:27,720 --> 01:47:31,970
>> E esses elementos são, em geral,
do mesmo tipo de dados, caráter,

2095
01:47:31,970 --> 01:47:35,966
caráter, caráter, personagem ou
corda, corda, corda, corda, ou int,

2096
01:47:35,966 --> 01:47:38,600
int, int, seja o que for
estamos tentando loja.

2097
01:47:38,600 --> 01:47:42,540
Contudo, no final do dia, esta é
o que parece conceitualmente.

2098
01:47:42,540 --> 01:47:44,530
Você está tendo o seu
memória ou RAM do computador.

2099
01:47:44,530 --> 01:47:48,590
E você está esculpindo-o para fora em
caixas de tamanho idêntico, todos os quais

2100
01:47:48,590 --> 01:47:50,920
estão de volta, para trás, para
para trás, para trás desta maneira.

2101
01:47:50,920 --> 01:47:53,200
>> E o que é agradável sobre
esta ideia, eo fato

2102
01:47:53,200 --> 01:47:58,580
que podemos expressar valores desta maneira
com a primeira das nossas estruturas de dados

2103
01:47:58,580 --> 01:48:02,520
na classe, significa que podemos começar
para resolver problemas com o código

2104
01:48:02,520 --> 01:48:04,079
que veio tão intuitivamente na semana 0.

2105
01:48:04,079 --> 01:48:05,870
Você deve se lembrar o telefone
exemplo do livro, onde

2106
01:48:05,870 --> 01:48:09,110
foi utilizado um dividir e conquistar,
ou um algoritmo de busca binária,

2107
01:48:09,110 --> 01:48:13,220
para peneirar um todo
monte de nomes e números.

2108
01:48:13,220 --> 01:48:18,220
Mas nós assumimos, recall, que esse
livro de telefone já foi resolvido,

2109
01:48:18,220 --> 01:48:21,630
que outra pessoa já teve
figurado out-- dada uma lista de nomes

2110
01:48:21,630 --> 01:48:24,430
e Números de como alfabetizar-los.

2111
01:48:24,430 --> 01:48:26,950
E agora que em C que,
também, ter a capacidade

2112
01:48:26,950 --> 01:48:30,290
para colocar as coisas, não
fisicamente em uma lista telefônica

2113
01:48:30,290 --> 01:48:34,220
mas praticamente em um computador de
memória, poderemos na próxima semana

2114
01:48:34,220 --> 01:48:38,470
para introduzir novamente o primeiro o--
de nossas estruturas de dados em um array--

2115
01:48:38,470 --> 01:48:43,530
mas mais importante, computador real
algoritmos de ciências aplicadas

2116
01:48:43,530 --> 01:48:47,720
no código, com o qual podemos armazenar
dados em estruturas como esta,

2117
01:48:47,720 --> 01:48:50,730
e, em seguida, começar a manipulá-lo, e
para resolver problemas, na verdade, com ele,

2118
01:48:50,730 --> 01:48:53,570
e construir em cima disso,
em última análise, programas em C,

2119
01:48:53,570 --> 01:48:56,730
em Python, em JavaScript,
consultar bancos de dados com SQL?

2120
01:48:56,730 --> 01:48:59,980
>> E vamos ver que todos estes
idéias diferentes de bloqueio.

2121
01:48:59,980 --> 01:49:04,100
Mas, por enquanto, lembre-se que o
domínio que apresentou hoje

2122
01:49:04,100 --> 01:49:06,920
era esta coisa aqui, e
o mundo da criptografia.

2123
01:49:06,920 --> 01:49:11,200
E, entre os próximos problemas que você mesmo
vai resolver é a arte de criptografia,

2124
01:49:11,200 --> 01:49:13,630
codificação e de-embaralhamento
informações, e codificação

2125
01:49:13,630 --> 01:49:15,930
e decifrar texto,
e assumindo que, em última análise

2126
01:49:15,930 --> 01:49:18,970
que você já sabe o que
é debaixo do capô

2127
01:49:18,970 --> 01:49:21,860
de modo que quando você vê ou receber
uma mensagem como esta, você

2128
01:49:21,860 --> 01:49:24,060
mesmo pode decifrá-la.

2129
01:49:24,060 --> 01:49:26,740
Tudo isso, e mais da próxima vez.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [REPRODUÇÃO DE VÍDEO]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Acabado de chegar.

2133
01:49:32,970 --> 01:49:35,146
Eu estou indo para ir visita
seu professor de faculdade.

2134
01:49:35,146 --> 01:49:37,611
Sim.

2135
01:49:37,611 --> 01:49:40,080
Oi.

2136
01:49:40,080 --> 01:49:40,660
É você.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Esperar!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Eu só estou tentando descobrir
o que aconteceu com você.

2142
01:49:56,060 --> 01:49:58,130
Por favor, qualquer coisa poderia ajudar.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Você era sua faculdade
companheiro de quarto, não estava?

2145
01:50:08,354 --> 01:50:10,770
Você estava lá com ele quando
ele terminou o projeto CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [REPRODUÇÃO DE MÚSICA]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Isso Foi CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Eu amo esse lugar.

2152
01:50:44,770 --> 01:50:45,854
>> -Coma.

2153
01:50:45,854 --> 01:50:47,020
Nós estamos indo para fora do negócio.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [FIM DE REPRODUÇÃO]

