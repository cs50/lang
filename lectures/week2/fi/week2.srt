1
00:00:00,000 --> 00:00:02,970
>> [MUSIIKKIA]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN: Selvä.

4
00:00:15,700 --> 00:00:18,832
Tämä on CS50 ja tämän
on alku Viikko 2.

5
00:00:18,832 --> 00:00:21,040
Ja te muistaa, että yli
parin viime viikon aikana,

6
00:00:21,040 --> 00:00:24,490
olemme esitelleet tietokoneella
tiede ja puolestaan ​​ohjelmointi.

7
00:00:24,490 --> 00:00:27,640
>> Ja aloitimme tarinan Poiketen
Scratch, että graafinen kieli

8
00:00:27,640 --> 00:00:28,990
MIT: N Media Lab.

9
00:00:28,990 --> 00:00:30,780
Ja sitten viimeksi
viime viikolla, teki meidän

10
00:00:30,780 --> 00:00:34,450
käyttöön higher--
alemman tason kieli tiedossa

11
00:00:34,450 --> 00:00:36,770
kuten C, jotain, joka on puhtaasti tekstimuodossa.

12
00:00:36,770 --> 00:00:39,440
Ja todellakin, viimeinen kerta
tutkia niihin liittyvistä

13
00:00:39,440 --> 00:00:40,450
useita käsitteitä.

14
00:00:40,450 --> 00:00:43,010
>> Tämä muistuttaa, oli hyvin
Ensimmäinen ohjelma tarkastelimme.

15
00:00:43,010 --> 00:00:45,710
Ja tämä ohjelma, yksinkertaisesti,
tulostaa, "hei, maailma."

16
00:00:45,710 --> 00:00:47,730
Mutta on niin paljon
näennäisestä magic meneillään.

17
00:00:47,730 --> 00:00:51,460
Ei tämä include
Näiden Kulmasulkeet.

18
00:00:51,460 --> 00:00:52,170
On int.

19
00:00:52,170 --> 00:00:53,020
On (void).

20
00:00:53,020 --> 00:00:56,330
On sulkuja, aaltosulkeita,
puolipistettä, ja niin paljon enemmän.

21
00:00:56,330 --> 00:00:58,480
>> Ja niin, muistaa, että
otimme käyttöön Scratch

22
00:00:58,480 --> 00:01:02,110
jotta voisimme ihannetapauksessa nähdä ohi
että syntaksi, tavaraa, joka ei todellakaan ole

23
00:01:02,110 --> 00:01:04,590
kaikki että älyllisesti
mielenkiintoinen, mutta jo varhain

24
00:01:04,590 --> 00:01:07,700
on, ehdottomasti, vähän hankala
kääriä mielesi ympärille.

25
00:01:07,700 --> 00:01:10,860
Ja, todellakin, yksi yleisimmistä
asiat varhaisessa ohjelmointi luokan,

26
00:01:10,860 --> 00:01:13,443
erityisesti niille vähemmän
mukava, on saada turhautuvat

27
00:01:13,443 --> 00:01:17,460
katkaisemaan jopa tiettyjen syntaktinen
virheet, puhumattakaan loogisia virheitä.

28
00:01:17,460 --> 00:01:19,800
Ja niin keskuudessa tavoitteemme
tänään, todella, tulee

29
00:01:19,800 --> 00:01:23,280
olla varustaa sinulle joitakin
ongelmanratkaisu tekniikoita, miten

30
00:01:23,280 --> 00:01:26,705
paremmin ratkaista ongelmia itse
muodossa virheenkorjaus.

31
00:01:26,705 --> 00:01:29,330
Ja voit muistaa myös, että
ympäristö että otimme käyttöön

32
00:01:29,330 --> 00:01:31,780
Edellisen kerran kutsuttiin CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Tämä on web-pohjainen ohjelmisto, joka
voidaan ohjelmoida pilvessä,

34
00:01:34,850 --> 00:01:38,450
niin sanotusti, pitäen kaikki
tiedostot yhteen, kuten olemme jälleen tulee tänään.

35
00:01:38,450 --> 00:01:41,480
Ja muistaa, että me
revisited näistä aiheista täällä,

36
00:01:41,480 --> 00:01:44,480
joukossa toimintoja, ja silmukoita, ja
muuttujia, ja Boolen operaattoreilla,

37
00:01:44,480 --> 00:01:45,110
ja olosuhteet.

38
00:01:45,110 --> 00:01:49,190
Ja itse asiassa vielä muutama että olemme
käännetty maailmasta Scratch

39
00:01:49,190 --> 00:01:50,800
maailmaan C.

40
00:01:50,800 --> 00:01:53,220
>> Mutta perusongelma rakennus
lohkot, niin sanotusti,

41
00:01:53,220 --> 00:01:55,150
olivat todella edelleen sama viime viikolla.

42
00:01:55,150 --> 00:01:57,900
Itse asiassa olemme todella vain oli
eri palapelin pala, jos haluatte.

43
00:01:57,900 --> 00:02:00,300
Sen sijaan, että violetti
tallentaa lohko, me sen sijaan

44
00:02:00,300 --> 00:02:02,940
oli printf, joka on
Tätä toimintoa C että

45
00:02:02,940 --> 00:02:05,890
voit tulostaa jotain
ja alustaa sen ruudulla.

46
00:02:05,890 --> 00:02:07,950
Otimme CS50
Kirjasto, jossa

47
00:02:07,950 --> 00:02:11,420
on nyt käytettävissänne get_char,
ja get_int, ja get_string,

48
00:02:11,420 --> 00:02:14,610
ja muutamia muita toimintoja
hyvin, jonka kautta voi saada syöttää

49
00:02:14,610 --> 00:02:16,260
käyttäjän omalla näppäimistöllä.

50
00:02:16,260 --> 00:02:20,640
Ja me myös katsoimme asioita
kuten these- bool, ja nieriä,

51
00:02:20,640 --> 00:02:22,490
ja kaksinkertainen, kellua,
int, long_long merkkijono.

52
00:02:22,490 --> 00:02:25,170
Ja siellä on jopa muita tietotyyppejä C.

53
00:02:25,170 --> 00:02:28,560
>> Toisin sanoen, kun julistaa
muuttuja tallentaa jotain arvoa,

54
00:02:28,560 --> 00:02:32,600
tai kun toteuttaa funktion
joka palauttaa jotain arvoa,

55
00:02:32,600 --> 00:02:35,290
voit määrittää, mitä
tyyppinen arvo on.

56
00:02:35,290 --> 00:02:37,310
Onko se merkkijono, kuten
merkkijono?

57
00:02:37,310 --> 00:02:39,490
Onko se numero, kuten kokonaisluku?

58
00:02:39,490 --> 00:02:41,390
Onko se liukuluku
arvo, tai vastaavaa?

59
00:02:41,390 --> 00:02:46,180
Joten C, toisin kuin Scratch, me todellakin
alkoi määrittää, millaisia ​​tietoja

60
00:02:46,180 --> 00:02:48,330
olimme palaamassa tai käyttämällä.

61
00:02:48,330 --> 00:02:51,910
>> Mutta tietysti myös törmäsi
joitakin perustavanlaatuisia rajoja computing.

62
00:02:51,910 --> 00:02:54,100
Ja erityisesti,
tällä kielellä C, recall

63
00:02:54,100 --> 00:02:57,070
että me katsoimme
kokonaisluvun ylivuoto, todellisuus

64
00:02:57,070 --> 00:03:00,460
että jos sinulla on vain
rajallinen määrä muistia

65
00:03:00,460 --> 00:03:04,600
tai, erityisesti, rajallinen määrä
bittejä, voi vain laskea niin korkea.

66
00:03:04,600 --> 00:03:08,460
Ja niin me katsoimme tätä esimerkkiä tästä
jolloin laskuri lentokoneella,

67
00:03:08,460 --> 00:03:13,510
todella, jos käynnissä tarpeeksi kauan olisi
ylivuoto ja johtaa ohjelmistojen

68
00:03:13,510 --> 00:03:15,560
todelliseen fyysiseen mahdollinen virhe.

69
00:03:15,560 --> 00:03:18,600
>> Me tarkasteltiin myös kelluva
piste epätäsmällisyys, todellisuus

70
00:03:18,600 --> 00:03:22,280
että vain rajallinen määrä
bittien, onko se 32 tai 64,

71
00:03:22,280 --> 00:03:27,330
voit vain määrittää niin monta numeroa
jälkeen desimaalierottimen jonka jälkeen

72
00:03:27,330 --> 00:03:29,110
alkaa saada epätarkka.

73
00:03:29,110 --> 00:03:32,360
Niinpä esimerkiksi kolmasosa on
maailma täällä, meidän ihmisten maailmassa,

74
00:03:32,360 --> 00:03:35,360
tiedämme vain ääretön määrä
3s desimaalipisteen jälkeen.

75
00:03:35,360 --> 00:03:38,820
Mutta tietokone ei voi välttämättä
edustavat ääretön määrä numeroita

76
00:03:38,820 --> 00:03:42,590
jos vain antaa sille joitakin
rajallinen määrä tietoa.

77
00:03:42,590 --> 00:03:45,900
>> Joten ei ainoastaan ​​me varustaa voit
enemmän valtaa suhteen

78
00:03:45,900 --> 00:03:49,280
miten voit ilmaista itseäsi
näppäimistö ohjelmatyön,

79
00:03:49,280 --> 00:03:51,430
me myös rajoitettu mitä
voit itse tehdä.

80
00:03:51,430 --> 00:03:55,790
Ja todellakin, bugeja ja virheitä voi
syntyvät tuollaiset asiat.

81
00:03:55,790 --> 00:03:59,900
Ja todellakin, joukossa aiheista tänään
tulevat olemaan aiheita kuten virheenkorjaus

82
00:03:59,900 --> 00:04:03,699
ja todella etsivät alla huppu
kuinka asiat esiteltiin viime viikolla

83
00:04:03,699 --> 00:04:05,490
todella toteutetaan
jotta voit paremmin

84
00:04:05,490 --> 00:04:10,530
ymmärtää sekä ominaisuuksia ja
rajoitukset kielen kuten C.

85
00:04:10,530 --> 00:04:14,770
>> Ja itse asiassa, me kuori takaisin kerroksia
yksinkertaisin tietorakenne,

86
00:04:14,770 --> 00:04:17,756
jotain kutsutaan joukko, joka
Scratch sattuu soittaa "lista."

87
00:04:17,756 --> 00:04:19,589
Se on hieman
Eri tässä yhteydessä.

88
00:04:19,589 --> 00:04:23,340
Ja sitten me myös esitellä yksi
Ensimmäinen meidän domain-erityisongelmat

89
00:04:23,340 --> 00:04:26,790
in CS50, maailma
salaus, taidetta muokkaamisella

90
00:04:26,790 --> 00:04:29,650
tai salausinformaatioon niin
että voit lähettää salaisia ​​viestejä

91
00:04:29,650 --> 00:04:34,520
ja purkaa salaisia ​​viestejä
kahden henkilön välillä, A ja B.

92
00:04:34,520 --> 00:04:37,490
>> Joten ennen kuin siirtyminen
kyseiseen uuteen maailmaan,

93
00:04:37,490 --> 00:04:42,059
koetamme varustaa sinulle joitakin
tekniikoita, jolla voit poistaa

94
00:04:42,059 --> 00:04:43,850
tai vähentää ainakin joitakin
turhautumista

95
00:04:43,850 --> 00:04:46,630
että olet todennäköisesti kohdannut
viime viikon yksin.

96
00:04:46,630 --> 00:04:50,830
Itse asiassa, ennen olet such-- joitakin
ensimmäinen ongelmat C. Ja kertoimet ovat,

97
00:04:50,830 --> 00:04:54,010
jos olet kuten minä, ensimmäistä kertaa
yrität kirjoittaa ulos ohjelma,

98
00:04:54,010 --> 00:04:57,330
vaikka luulet loogisesti
ohjelma on melko yksinkertainen,

99
00:04:57,330 --> 00:05:01,200
saatat hyvinkin osui seinään, ja
kääntäjä ei aio tehdä yhteistyötä.

100
00:05:01,200 --> 00:05:03,940
Tee tai Clang ei aio
todella tehdä oman hinnoittelu.

101
00:05:03,940 --> 00:05:05,450
>> Ja miksi se voisi olla?

102
00:05:05,450 --> 00:05:07,950
No, katsomaan,
ehkä yksinkertainen ohjelma.

103
00:05:07,950 --> 00:05:11,190
Aion mennä eteenpäin ja tallenna tämä
Tiedoston tarkoituksella nimeltä buggy0.c,

104
00:05:11,190 --> 00:05:13,590
koska tiedän sen
olla virheellinen etukäteen.

105
00:05:13,590 --> 00:05:17,400
Mutta en ehkä ymmärtää, että jos tämä
on ensimmäinen tai toinen tai kolmas ohjelma

106
00:05:17,400 --> 00:05:18,830
että olen todella tehdä itse.

107
00:05:18,830 --> 00:05:23,820
Joten aion mennä eteenpäin ja
kirjoittamiseen, int main (void).

108
00:05:23,820 --> 00:05:28,130
Ja sitten sisällä minun aaltosulkeita,
hyvin tuttu ( "Hei, world--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - ja puolipisteellä.

110
00:05:30,980 --> 00:05:32,360
>> Olen tallentanut tiedoston.

111
00:05:32,360 --> 00:05:34,850
Nyt aion mennä alas
minun pääteikkuna

112
00:05:34,850 --> 00:05:40,340
ja tyyppi tehdä buggy0, koska, jälleen,
nimi tiedoston nykyään buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Joten kirjoitan tehdä buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Ja oi, gosh, muistaa viime kerran
että ei virheilmoitukset on hyvä asia.

115
00:05:48,200 --> 00:05:49,740
Joten ei ulostulo on hyvä asia.

116
00:05:49,740 --> 00:05:52,920
Mutta täällä minulla on selvästi
jotkut määrä virheitä.

117
00:05:52,920 --> 00:05:56,470
>> Joten ensimmäinen rivi ulostulo
kirjoittamisen jälkeen tehdä buggy0, recall,

118
00:05:56,470 --> 00:05:59,540
on Clang n melko laveasti.

119
00:05:59,540 --> 00:06:02,067
Alapuolella huppu,
CS50 IDE on konfiguroitu

120
00:06:02,067 --> 00:06:04,150
käyttää koko joukko
vaihtoehtoja tämän kääntäjä

121
00:06:04,150 --> 00:06:05,941
jotta sinun ei tarvitse
ajatella niitä.

122
00:06:05,941 --> 00:06:08,840
Ja siinä kaikki, että ensimmäinen rivi
keinot, joka alkaa Clang.

123
00:06:08,840 --> 00:06:11,720
>> Mutta sen jälkeen, ongelmia
alkaa tehdä niiden ulkonäköä.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c rivillä 3, character
5, on suuri, punainen virhe.

125
00:06:17,390 --> 00:06:18,380
Mikä tuo on?

126
00:06:18,380 --> 00:06:23,562
Epäsuorasti julistaa kirjaston funktion
printf tyypin int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Siis, se hyvin nopeasti
saa hyvin vaikeaselkoisia.

129
00:06:28,379 --> 00:06:30,170
Ja varmasti, ensin
silmäyksellä, me emme tahdo

130
00:06:30,170 --> 00:06:32,380
odottavat sinua ymmärtämään
kokonaisuudessaan kyseisen viestin.

131
00:06:32,380 --> 00:06:34,213
Ja niin yksi opetuksista
tänään on menossa

132
00:06:34,213 --> 00:06:36,919
olla yrittää huomata
kuvioita, tai samanlaisia ​​asioita,

133
00:06:36,919 --> 00:06:38,960
virheisiin saatat olla
kohdannut aikaisemmin.

134
00:06:38,960 --> 00:06:41,335
Joten kiusaa toisistaan ​​vain
ne sanat, jotka tutulta.

135
00:06:41,335 --> 00:06:44,290
Suuri punainen virhe on selvästi
symbolinen jotain on vialla.

136
00:06:44,290 --> 00:06:47,940
>> epäsuorasti julistamisesta
kirjaston funktion printf.

137
00:06:47,940 --> 00:06:51,680
Joten vaikka en oikein ymmärrä, mitä
epäsuorasti julistaa kirjaston funktion

138
00:06:51,680 --> 00:06:54,900
keinoin, ongelma varmasti
koskee printf jotenkin.

139
00:06:54,900 --> 00:06:59,130
Ja lähde tästä asiasta
on tekemistä julistaa sen.

140
00:06:59,130 --> 00:07:02,440
>> Julistamisesta toiminto on
mainita sitä ensimmäistä kertaa.

141
00:07:02,440 --> 00:07:06,210
Ja käytimme terminologiaa viime viikolla
julistaa funktion prototyyppi,

142
00:07:06,210 --> 00:07:11,860
joko yhden rivin yläreunassa
oma tiedosto tai ns header-tiedosto.

143
00:07:11,860 --> 00:07:15,300
Ja mitä tiedostoa teki sanomme
viime viikolla, että printf on lainaus,

144
00:07:15,300 --> 00:07:17,080
lainaus, julisti?

145
00:07:17,080 --> 00:07:20,950
Missä tiedosto on sen prototyyppi?

146
00:07:20,950 --> 00:07:24,640
>> Joten jos muistatte, aivan ensimmäinen asia, I
konekirjoitettu, lähes jokainen ohjelma viime time--

147
00:07:24,640 --> 00:07:30,790
ja vahingossa hetki sitten alkanut
kirjoittamalla myself-- oli tämä here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- varten
tulo / output-- piste h Ja todellakin,

149
00:07:38,630 --> 00:07:41,860
kun nyt tallentaa tämän tiedoston, aion
mennä eteenpäin ja tyhjentää näytön,

150
00:07:41,860 --> 00:07:44,740
joka voi tehdä kirjoittamalla
Kirkas, tai voit pitää Ohjaus L,

151
00:07:44,740 --> 00:07:47,680
vain tyhjentää pääteikkunaan
vain poistamaan joitakin sotkua.

152
00:07:47,680 --> 00:07:51,370
>> Aion mennä eteenpäin ja
re-tyyppinen merkki buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Ja voila, olen edelleen nähdä, että
pitkä komento Clang,

154
00:07:53,790 --> 00:07:55,470
mutta ei ole mitään virheilmoitusta tällä kertaa.

155
00:07:55,470 --> 00:07:58,800
Ja todellakin, jos en ./buggy0,
aivan kuten viime kerralla,

156
00:07:58,800 --> 00:08:01,860
missä piste tarkoittaa tämä
hakemisto, Slash vain tarkoittaa,

157
00:08:01,860 --> 00:08:05,040
tässä tulee ohjelman nimi ja
että ohjelman nimi on buggy0,

158
00:08:05,040 --> 00:08:07,340
Enter, "hei, maailma."

159
00:08:07,340 --> 00:08:09,440
>> Nyt miten voisi olet
poimittu tämä ratkaisu

160
00:08:09,440 --> 00:08:12,017
ilman välttämättä
tunnustaa niin monta sanaa

161
00:08:12,017 --> 00:08:14,350
kuten tein, varmasti, joilla
tehnyt tämän niin monta vuotta?

162
00:08:14,350 --> 00:08:18,720
No, ymmärtää per ensimmäinen ongelma
set, esittelemme komentoon

163
00:08:18,720 --> 00:08:21,175
että CS50 oma henkilökunta
kirjoitti kutsutaan help50.

164
00:08:21,175 --> 00:08:24,300
Ja todellakin, C tekee määrittelyn
ongelma asetettu, miten käyttää tätä.

165
00:08:24,300 --> 00:08:27,210
>> Mutta help50 on olennaisesti
ohjelma, joka CS50 henkilöstö

166
00:08:27,210 --> 00:08:30,850
kirjoitti, että voit ajaa
komennon tai suorita ohjelma,

167
00:08:30,850 --> 00:08:36,169
ja jos et ymmärrä sen
ulostulo, siirtää tuotannostaan ​​help50,

168
00:08:36,169 --> 00:08:38,890
jolloin ohjelmisto
että kurssin henkilökunta kirjoitti

169
00:08:38,890 --> 00:08:42,429
tarkastellaan ohjelman ulostulo
rivi riviltä, ​​merkki kerrallaan.

170
00:08:42,429 --> 00:08:46,000
Ja jos me, henkilökunta, tunnistaa
virheilmoituksen, joka sinulla on,

171
00:08:46,000 --> 00:08:50,580
yritämme provosoida teille joitakin
retorisia kysymyksiä, joitakin neuvoja,

172
00:08:50,580 --> 00:08:54,890
paljon kuin TF tai CA tai itse
tekisi henkilökohtaisesti virka.

173
00:08:54,890 --> 00:08:58,320
>> Niin katso help50 jos et
välttämättä tunnista ongelma.

174
00:08:58,320 --> 00:09:00,790
Mutta eivät ole riippuvaisia ​​siitä
liian paljon kuin kainalosauva.

175
00:09:00,790 --> 00:09:03,990
Varmasti yrittää ymmärtää sen
lähtö ja sitten oppia siitä

176
00:09:03,990 --> 00:09:07,571
niin että vain kerran tai kahdesti sinä
koskaan ajaa help50 tietylle virhe

177
00:09:07,571 --> 00:09:08,070
viesti.

178
00:09:08,070 --> 00:09:10,660
Tämän jälkeen sinun pitäisi olla
paremmat itse

179
00:09:10,660 --> 00:09:13,180
selvittää, mitä se todellisuudessa on.

180
00:09:13,180 --> 00:09:14,350
>> Tehdään yksi muu täällä.

181
00:09:14,350 --> 00:09:20,410
Anna minun mennä eteenpäin, ja toiseen
tiedosto me kutsumme tätä buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Ja tähän tiedostoon olen
menossa deliberately--

183
00:09:23,110 --> 00:09:26,330
mutta teeskennellä että en
ymmärtää, mitä virheen olen tehnyt.

184
00:09:26,330 --> 00:09:31,420
>> Aion mennä eteenpäin ja tehdä this--
# include, koska olen

185
00:09:31,420 --> 00:09:33,660
oppinut läksynsä hetki sitten.

186
00:09:33,660 --> 00:09:36,220
Int main (void), kuten aiemmin.

187
00:09:36,220 --> 00:09:40,880
Ja sitten täällä aion
tehdä string s - get_string.

188
00:09:40,880 --> 00:09:43,770
Ja muistaa viime kerran
Tämä tarkoittaa, hei, tietokone,

189
00:09:43,770 --> 00:09:48,280
antaa minulle muuttuja, soita se s, ja
tehdä tyypin muuttujan merkkijonon

190
00:09:48,280 --> 00:09:50,150
joten en voi tallentaa yhden tai useamman sanan sitä.

191
00:09:50,150 --> 00:09:52,191
>> Ja sitten oikeanpuoleisessa
puolella yhtäläisyysmerkin

192
00:09:52,191 --> 00:09:54,980
on get_string, joka on
toiminto CS50 kirjastosta

193
00:09:54,980 --> 00:09:55,980
että juuri näin.

194
00:09:55,980 --> 00:09:59,740
Se saa funktio ja sitten
käsiä sen oikealta vasemmalle.

195
00:09:59,740 --> 00:10:02,670
Joten tämä yhtäläisyysmerkki ei tarkoita
"On yhtä kuin" kuten voisi luulla matematiikasta.

196
00:10:02,670 --> 00:10:04,750
Se tarkoittaa toimeksianto oikealta vasemmalle.

197
00:10:04,750 --> 00:10:09,640
Joten tämä tarkoittaa, ottaa merkkijonon
käyttäjä ja tallentaa sen sisällä s.

198
00:10:09,640 --> 00:10:10,460
>> Nyt käyttää sitä.

199
00:10:10,460 --> 00:10:13,820
Anna minun mennä eteenpäin nyt ja toisena
line, anna minun mennä eteenpäin ja sanoa "hei" -

200
00:10:13,820 --> 00:10:19,330
ei "maailman", mutta "Hei,% S--
joka on meidän paikkamerkki, pilkku s,

201
00:10:19,330 --> 00:10:22,030
joka on meidän vaihteleva,
ja sitten puolipisteellä.

202
00:10:22,030 --> 00:10:26,070
Joten jos en tyriä liikaa
täällä, tämä näyttää oikean koodin.

203
00:10:26,070 --> 00:10:28,090
>> Ja vaistoni ovat nyt niiden keräämiseksi.

204
00:10:28,090 --> 00:10:30,400
Tiedosto on nimeltään buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Joten aion tehdä tehdä buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Ja hiton-, jos se ei ole
vieläkin enemmän virheitä kuin ennen.

207
00:10:36,377 --> 00:10:38,210
Siis, ei enempää
virheilmoituksia se olisi

208
00:10:38,210 --> 00:10:40,400
näyttävät kuin todellinen riviä tässä ohjelmassa.

209
00:10:40,400 --> 00:10:42,730
>> Mutta takeaway tässä,
vaikka olet hukkua

210
00:10:42,730 --> 00:10:45,040
joissa on kaksi tai kolme tai
neljä enemmän virheilmoituksia,

211
00:10:45,040 --> 00:10:48,340
keskittyvät aina hyvin
Ensimmäinen näistä viesteistä.

212
00:10:48,340 --> 00:10:52,220
Tarkasteltaessa Ylimmässä yksi,
rullata takaisin ylös kuin tarvetta on.

213
00:10:52,220 --> 00:10:53,930
Joten tässä olen kirjoittanut make buggy1.

214
00:10:53,930 --> 00:10:55,700
Tässä että Clang tuotanto odotetusti.

215
00:10:55,700 --> 00:10:57,290
>> Ja tässä on ensimmäinen punainen virhe.

216
00:10:57,290 --> 00:11:02,370
Käytä pimeän tunnisteen
string, minä tarkoitan vakiona?

217
00:11:02,370 --> 00:11:04,260
Joten standardi on
todella jotain muuta.

218
00:11:04,260 --> 00:11:06,240
Se viittaa käyttäjän
näppäimistö, lähinnä.

219
00:11:06,240 --> 00:11:08,080
>> Mutta se ei ole mitä tarkoitin.

220
00:11:08,080 --> 00:11:11,770
Tarkoitin merkkijono, ja tarkoitin get_string.

221
00:11:11,770 --> 00:11:16,200
Mikä siis on se, että minä
unohti tehdä tällä kertaa?

222
00:11:16,200 --> 00:11:20,230
Mitä puuttuu tällä kertaa?

223
00:11:20,230 --> 00:11:23,600
Minulla on # include,
joten Olen pääsy printf.

224
00:11:23,600 --> 00:11:26,090
>> Mutta mitä minä ole
pääsy vain vielä?

225
00:11:26,090 --> 00:11:29,420
No, aivan kuten viime kerralla,
Minun täytyy kertoa kääntäjä

226
00:11:29,420 --> 00:11:31,691
Kalahtaa mitä nämä toiminnot ovat.

227
00:11:31,691 --> 00:11:33,940
Get_string ei tule
C. Ja erityisesti, se

228
00:11:33,940 --> 00:11:38,160
ei tulla
header tiedosto,.

229
00:11:38,160 --> 00:11:40,770
Se sijaan tulee
jotain henkilökunta kirjoitti,

230
00:11:40,770 --> 00:11:44,176
joka on eri tiedosto
nimetä mutta osuvasti nimetty.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Joten yksinkertaisesti lisäämällä, että yhdellä rivillä
of code-- hae viimeksi

233
00:11:50,861 --> 00:11:53,610
että kun Clang kulkee, se tulee
katsomaan minun koodi ylhäältä alas,

234
00:11:53,610 --> 00:11:54,193
vasemmalta oikealle.

235
00:11:54,193 --> 00:11:57,200
Se tulee huomata,
oh, haluat.

236
00:11:57,200 --> 00:11:59,900
Anna minun mennä ja huomaavat,
missä se on palvelimella,

237
00:11:59,900 --> 00:12:03,090
Kopioi ja liitä se pääasiallisesti,
yläosaan oman tiedoston

238
00:12:03,090 --> 00:12:06,820
jotta tässä vaiheessa tarinan,
rivi 1, loput ohjelman

239
00:12:06,820 --> 00:12:11,651
voi todellakin käyttää mitä tahansa toimintoja
siinä joukossa get_string.

240
00:12:11,651 --> 00:12:13,650
Joten aion sivuuttaa
loput näistä virheistä,

241
00:12:13,650 --> 00:12:17,190
koska olen todellakin epäillä, että vain
ensimmäinen todella väliä.

242
00:12:17,190 --> 00:12:20,780
Ja aion mennä eteenpäin ja uusinta,
tallennuksen jälkeen minun arkistoida tehdä buggy1.

243
00:12:20,780 --> 00:12:22,580
Ja voila, se teki työtä.

244
00:12:22,580 --> 00:12:29,200
Ja jos en ./buggy1 ja kirjoita varten
Esimerkiksi Zamyla, en nyt saa hei,

245
00:12:29,200 --> 00:12:32,000
Zamyla sijasta hei, maailma.

246
00:12:32,000 --> 00:12:32,550
>> Selvä.

247
00:12:32,550 --> 00:12:35,890
Joten takeaways täällä sitten ovat,
yksi, yrittää poimia niin paljon kuin voit

248
00:12:35,890 --> 00:12:39,140
alkaen virheilmoitukset yksin, etsii
joitakin tunnistettavia sanoja.

249
00:12:39,140 --> 00:12:43,070
Esto, että käyttävät help50 per
ongelma asettaa erittely.

250
00:12:43,070 --> 00:12:46,500
Mutta esto että myös aina etsiä
yläosassa virhe vain, vähintään

251
00:12:46,500 --> 00:12:50,051
aluksi, mitä tietoja
se voisi todella tuottaa.

252
00:12:50,051 --> 00:12:52,300
Mutta näyttää siltä siellä n
vieläkin enemmän toimintoja rakennettu

253
00:12:52,300 --> 00:12:55,030
osaksi CS50 Library auttaa
te varhaisessa lukukausi

254
00:12:55,030 --> 00:12:57,580
ja varhaisessa vaiheessa ohjelmointi
selvittää, mitä on vialla.

255
00:12:57,580 --> 00:12:59,840
Tehdäänpä toinen esimerkki tästä.

256
00:12:59,840 --> 00:13:04,350
Aion kutsua tätä buggy2, joka,
taas aiotaan virheellinen ulos

257
00:13:04,350 --> 00:13:05,650
portin suunnittelun.

258
00:13:05,650 --> 00:13:09,980
>> Ja aion mennä eteenpäin
ja tehdä # include.

259
00:13:09,980 --> 00:13:12,580
Ja sitten aion tehdä int main (void).

260
00:13:12,580 --> 00:13:14,840
Ja sitten aion tehdä silmukka.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i on pienempi tai yhtä suuri kuin 10.

263
00:13:18,750 --> 00:13:24,260
i ++, ja sitten aaltosulkeita, aion
tulostaa vain hashtagia symboli täällä

264
00:13:24,260 --> 00:13:25,920
ja uusi rivi merkki.

265
00:13:25,920 --> 00:13:29,220
>> Joten tahallisuus tämän
Ohjelma on yksinkertaisesti

266
00:13:29,220 --> 00:13:33,150
kerrata 10 kertaa
ja jokaisen iteraation

267
00:13:33,150 --> 00:13:35,260
Tämän silmukan kerta
läpi sykli,

268
00:13:35,260 --> 00:13:37,660
tulostaa hashtagia,
hashtagia, hashtagia.

269
00:13:37,660 --> 00:13:40,480
Yksi per rivi, koska olen
on uusi linja siellä.

270
00:13:40,480 --> 00:13:42,787
Ja muistuttaa, että varten
silmukka, kohti viime week--

271
00:13:42,787 --> 00:13:44,620
ja saat enemmän
perehtynyt syntaksia

272
00:13:44,620 --> 00:13:47,170
käyttämällä sitä käytäntöä
ennen long-- tämä antaa minulle

273
00:13:47,170 --> 00:13:49,740
muuttuja nimeltä i ja asettaa sen 0.

274
00:13:49,740 --> 00:13:52,650
>> Tämä kasvattaa i päälle
jokainen iteraatio 1.

275
00:13:52,650 --> 00:13:54,940
Joten i menee 1-2 ja 3 vastaan.

276
00:13:54,940 --> 00:13:57,690
Ja sitten tästä ehdosta
keskimmäinen välillä puolipisteet

277
00:13:57,690 --> 00:14:03,010
saa tarkastaa jokaisen iteraation tekemään
Varmista, että olemme edelleen kuuluvuusalueella.

278
00:14:03,010 --> 00:14:06,830
Joten haluan kerrata 10 kertaa, joten en
on eräänlainen hyvin intuitiivisesti juuri

279
00:14:06,830 --> 00:14:09,070
laittaa 10 minun yläraja siellä.

280
00:14:09,070 --> 00:14:14,310
>> Ja kuitenkin, kun käytän tämän jälkeen
kokoamisessa make buggy2--

281
00:14:14,310 --> 00:14:15,440
ja se koota OK.

282
00:14:15,440 --> 00:14:17,980
Joten en ole
syntaksivirhe tällä kertaa.

283
00:14:17,980 --> 00:14:20,940
Anna minun mennä eteenpäin nyt
ja ajaa buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Nyt selaa ylöspäin.

285
00:14:22,620 --> 00:14:24,890
Ja haluaisin lisätä
koko ikkunan.

286
00:14:24,890 --> 00:14:33,720
>> Olen ilmeisesti on 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Joten ei 11 hashtags, vaikka
Olen selvästi laittaa 10 sisälle tämän silmukan.

288
00:14:38,891 --> 00:14:42,140
Nyt jotkut teistä ehkä nähdä heti
mikä virhe johtuu siitä, että itse asiassa, tämä

289
00:14:42,140 --> 00:14:43,720
ei ole kovin vaikea virhe tehdä.

290
00:14:43,720 --> 00:14:46,070
Mutta se on hyvin yleisesti
teki hyvin varhain.

291
00:14:46,070 --> 00:14:49,820
>> Haluan huomauttaa kuitenkin,
on, miten voisi minä kuva tästä?

292
00:14:49,820 --> 00:14:52,300
No, käy ilmi, että
CS50 kirjasto tulee

293
00:14:52,300 --> 00:14:55,380
ei ainoastaan ​​get_string ja get_int
ja get_float ja muita toimintoja.

294
00:14:55,380 --> 00:14:59,980
Sen mukana tulee myös erityinen toiminto
nimeltään eprintf, tai virhe printf.

295
00:14:59,980 --> 00:15:03,270
Ja se on olemassa ainoastaan ​​tehdä
se hieman helpompaa

296
00:15:03,270 --> 00:15:06,310
kun virheenkorjaus koodi vain
tulosta virheilmoitus ruudulla

297
00:15:06,310 --> 00:15:07,850
ja tietää, mistä se tuli.

298
00:15:07,850 --> 00:15:11,000
>> Niinpä esimerkiksi yksi asia voisin
tehdä täällä tällä toiminnolla on this--

299
00:15:11,000 --> 00:15:20,230
eprintf, ja sitten aion mennä eteenpäin
ja sanoa i on nyt% i, kenoviiva n.

300
00:15:20,230 --> 00:15:22,330
Ja aion kytkeä arvon i.

301
00:15:22,330 --> 00:15:25,400
Ja ylös, koska tämä
on CS50 Library,

302
00:15:25,400 --> 00:15:27,580
Aion mennä eteenpäin
ja sisältävät

303
00:15:27,580 --> 00:15:29,169
joten minun täytyy käyttää tätä toimintoa.

304
00:15:29,169 --> 00:15:31,460
Mutta Tarkastellaan mitä linjaa
9 on tarkoitus olla tekemässä.

305
00:15:31,460 --> 00:15:32,670
Aion poistaa tämän lopulta.

306
00:15:32,670 --> 00:15:34,670
Tällä ei ole mitään tekemistä
minun yleisenä tavoitteena.

307
00:15:34,670 --> 00:15:39,090
Mutta eprintf, virhe printf, on vain tarkoitus
antaa minulle joitakin diagnostisia tietoja.

308
00:15:39,090 --> 00:15:42,460
Kun olen suorittanut minun ohjelma, haluan
nähdä tämän näytön väliaikaisesti

309
00:15:42,460 --> 00:15:44,550
yhtä hyvin ymmärtää
mitä tapahtuu.

310
00:15:44,550 --> 00:15:47,330
>> Ja, todellakin, kullakin
iterointia here linjan 9

311
00:15:47,330 --> 00:15:49,260
Haluan nähdä, mikä on arvo i?

312
00:15:49,260 --> 00:15:50,290
Mikä on arvo i?

313
00:15:50,290 --> 00:15:51,280
Mikä on arvo i?

314
00:15:51,280 --> 00:15:55,650
Ja toivottavasti minun pitäisi vain
nähdä, että viestin, myös 10 kertaa.

315
00:15:55,650 --> 00:15:57,780
>> Joten anna minun mennä eteenpäin ja
kääntää minun ohjelma,

316
00:15:57,780 --> 00:15:59,905
koska minun täytyy tehdä tahansa
I tehdä muutoksia. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Ja now-- OK.

319
00:16:03,640 --> 00:16:04,820
Siellä on paljon enemmän tekeillä.

320
00:16:04,820 --> 00:16:07,610
Haluan siis vierittää ylöspäin
vielä suurempi ikkuna.

321
00:16:07,610 --> 00:16:10,190
>> Ja näet, että jokainen
hashtags on edelleen tulostuksen.

322
00:16:10,190 --> 00:16:15,270
Mutta jokaisen niistä on nyt tämä
diagnostiikkalähtö muotoiltu seuraavasti.

323
00:16:15,270 --> 00:16:17,960
Nimi minun ohjelma tässä buggy2.

324
00:16:17,960 --> 00:16:20,432
Nimi tiedosto on buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Linjan numero, josta
tämä painettiin on viiva 9.

326
00:16:24,080 --> 00:16:27,500
Ja sitten oikealla joka on
virheilmoituksen, Odotan.

327
00:16:27,500 --> 00:16:30,701
>> Ja mitä mukavaa tästä on, että
nyt en tarvitse välttämättä laskea

328
00:16:30,701 --> 00:16:32,200
päähäni mitä minun ohjelma tekee.

329
00:16:32,200 --> 00:16:34,240
Näen, että on
ensimmäinen iterointi i on 0,

330
00:16:34,240 --> 00:16:39,420
Sitten 1, sitten 2, sitten 3 ja sitten 4, niin
5, sitten 6, sitten 7, niin 8, sitten 9, sitten

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Joten odota hetki.

333
00:16:42,050 --> 00:16:43,740
Mitä täällä tapahtuu?

334
00:16:43,740 --> 00:16:48,190
Olen edelleen näyttävät laskenta
aiotulla jopa 10.

335
00:16:48,190 --> 00:16:50,550
>> Mutta mistä aloittaa?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

337
00:16:53,240 --> 00:16:58,040
Joten 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11. sormi

338
00:16:58,040 --> 00:16:59,990
on osoitus ongelmasta.

339
00:16:59,990 --> 00:17:02,850
Olen ilmeisesti lasketa
virheellisesti minun silmukka.

340
00:17:02,850 --> 00:17:06,599
Eikä mennä 10 toistojen,
Olen alkaen 0,

341
00:17:06,599 --> 00:17:09,550
Olen päättyy ja kautta 10.

342
00:17:09,550 --> 00:17:12,030
Mutta koska, kuten tietokone,
Olen alkanut laskenta 0,

343
00:17:12,030 --> 00:17:15,250
Olisin laskemalla ylös
sen, mutta ei läpi, 10.

344
00:17:15,250 --> 00:17:18,510
>> Ja niin korjata, I lopulta
toteutunut täällä, on yksi kaksi asiaa.

345
00:17:18,510 --> 00:17:22,430
Voisin hyvin yksinkertaisesti sanoa
laskea jopa alle 10.

346
00:17:22,430 --> 00:17:27,260
Joten 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, joka on todellakin oikea,

347
00:17:27,260 --> 00:17:28,900
vaikka se kuulostaa vähän väärin.

348
00:17:28,900 --> 00:17:35,070
Tai sitten voisi tehdä pienempi tai yhtä suuri
9, niin kauan kuin minä alkavat 0.

349
00:17:35,070 --> 00:17:40,056
Tai jos todella eivät pidä siitä, et
laskea läpi 10 mutta alkavat 1.

350
00:17:40,056 --> 00:17:41,680
Mutta jälleen kerran, tämä vain ei ole kovin yleistä.

351
00:17:41,680 --> 00:17:43,977
In programming-- vaikkakin
ei niinkään Scratch--

352
00:17:43,977 --> 00:17:45,810
mutta ohjelmointi
C ja muita kieliä,

353
00:17:45,810 --> 00:17:47,670
kuten JavaScript ja
Python ja muut, se on

354
00:17:47,670 --> 00:17:49,880
vain hyvin yleinen
keskustelumme binary

355
00:17:49,880 --> 00:17:53,450
vain alkaa laskea tällä
pienin määrä voit, joka on 0.

356
00:17:53,450 --> 00:17:53,950
Selvä.

357
00:17:53,950 --> 00:17:55,160
Niin, että eprintf.

358
00:17:55,160 --> 00:17:58,600
Ja vielä, nyt kun olen tajunnut minun
ongelma, ja aion palata 0

359
00:17:58,600 --> 00:18:01,470
kautta alle 10, aion
mennä ja poistaa eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Sen ei pitäisi olla siellä, kun
alus minun koodi tai lähetä oma koodi

361
00:18:04,580 --> 00:18:05,800
tai näyttää sitä kenellekään muulle.

362
00:18:05,800 --> 00:18:07,980
Se on oikeastaan ​​vain tarkoitti
voidaan käyttää väliaikaisesti.

363
00:18:07,980 --> 00:18:11,650
Mutta nyt olen korjannut
Erityisenä ongelmana samoin.

364
00:18:11,650 --> 00:18:16,780
>> No, tehdään yksi esimerkki tästä
että aion lietsoa seuraavasti.

365
00:18:16,780 --> 00:18:22,850
Aion mennä eteenpäin ja
#sisältää . $ 50

366
00:18:22,850 --> 00:18:25,580
Ja aion mennä eteenpäin
ja # include.

367
00:18:25,580 --> 00:18:29,030
>> Ja aion säästää
tämä kuva buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Ja aion mennä eteenpäin
ja julistaa int main (void).

369
00:18:31,740 --> 00:18:34,186
Ja sitten sisällä siellä
Aion tehdä int i _ -

370
00:18:34,186 --> 00:18:36,435
Haluan toteuttaa ohjelman
kanssa get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Tämä ei ole funktio, joka on olemassa vielä.

373
00:18:40,770 --> 00:18:42,870
Joten aiomme toteuttaa
se vain hetken.

374
00:18:42,870 --> 00:18:45,541
Mutta me tulemme näkemään miksi
se viallisista ensin omille.

375
00:18:45,541 --> 00:18:47,290
Ja kun olen saanut
int käyttäjältä,

376
00:18:47,290 --> 00:18:53,365
Olen juuri menossa painoon% i on negatiivinen
kokonaisluku, kenoviiva, n, pilkku, i.

377
00:18:53,365 --> 00:18:55,240
Toisin sanoen, kaikki I
haluavat ohjelman tehdä

378
00:18:55,240 --> 00:18:58,000
on saada negatiivinen int alkaen
käyttäjä ja sitten tulostaa

379
00:18:58,000 --> 00:18:59,980
että tällainen ja tällainen on negatiivinen int.

380
00:18:59,980 --> 00:19:02,080
>> Nyt minun täytyy toteuttaa tätä toimintoa.

381
00:19:02,080 --> 00:19:05,740
Joten myöhemmin minun tiedoston, aion mennä
eteenpäin ja julistaa toiminto nimeltään

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - ja me
palata mitä tämä linja tarkoittaa jälleen

383
00:19:10,670 --> 00:19:18,790
joka moment-- int n; do-- do
following-- printf n on :.

384
00:19:18,790 --> 00:19:26,210
Ja sitten aion tehdä n - get_int,
ja tehdä tämä, kun n on suurempi kuin 0.

385
00:19:26,210 --> 00:19:28,310
Ja palata sitten n ;.

386
00:19:28,310 --> 00:19:31,730
>> Joten siellä on paljon meneillään
Tässä mutta mikään jota emme

387
00:19:31,730 --> 00:19:33,710
katsokaa viime viikolla, ainakin hetkeksi.

388
00:19:33,710 --> 00:19:36,980
Joten rivillä 10 täällä olen julistettu
toiminto nimeltään get_negative_int,

389
00:19:36,980 --> 00:19:39,620
ja Laitoin (void), vuonna
sulkuja, syy on tähän

390
00:19:39,620 --> 00:19:40,950
ei ota tulo.

391
00:19:40,950 --> 00:19:42,910
En ohimennen mitään
Tämän toiminnon.

392
00:19:42,910 --> 00:19:44,690
Olen vain saada jotain takaisin siitä.

393
00:19:44,690 --> 00:19:47,270
>> Ja mitä olen haluavat
saada takaisin on kokonaisluku.

394
00:19:47,270 --> 00:19:50,040
Ei ole tietoa tyyppi
C kutsutaan negative_int.

395
00:19:50,040 --> 00:19:52,880
Se on vain int, joten se menee
olla meille varmista

396
00:19:52,880 --> 00:19:55,340
että arvo, joka on itse asiassa
Palautetut on paitsi int

397
00:19:55,340 --> 00:19:56,380
mutta on myös negatiivinen.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 Olen julistaa muuttuja
nimeltään n ja tehden tyyppiä int.

399
00:20:02,150 --> 00:20:07,500
Ja sitten linjan 13 kautta 18 Olen
tekemässä jotain vaikka jokin on totta.

400
00:20:07,500 --> 00:20:11,040
Aion eteenpäin ja tulostus
n on, paksusuoli, ja sitten tilaan,

401
00:20:11,040 --> 00:20:12,800
kuten nopea käyttäjälle.

402
00:20:12,800 --> 00:20:16,410
>> Olen silloin kutsuvan get_int ja
tallentamiseen sen niin sanottu palautusarvo

403
00:20:16,410 --> 00:20:18,130
että muuttujan n.

404
00:20:18,130 --> 00:20:22,600
Mutta aion pitää tehdä
Tämän kun n on suurempi kuin 0.

405
00:20:22,600 --> 00:20:27,960
Toisin sanoen, jos käyttäjä antaa minulle
int ja että määrä on suurempi kuin 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positiivinen, aion
vain pitää reprompting käyttäjälle,

407
00:20:31,180 --> 00:20:37,160
pitää reprompting, pakottamalla
yhteistyötä ja antaa minulle negatiivinen int.

408
00:20:37,160 --> 00:20:41,640
>> Ja kun n on todella negative--
Oletetaan käyttäjä lopulta tyyppejä -50,

409
00:20:41,640 --> 00:20:46,710
niin tämä taas silmukka ei ole enää totta
koska -50 ei ole suurempi kuin 0.

410
00:20:46,710 --> 00:20:51,140
Joten me murtautua ulos että
loop loogisesti ja palauttaa n.

411
00:20:51,140 --> 00:20:53,520
>> Mutta on olemassa yksi muu
asia minun täytyy tehdä.

412
00:20:53,520 --> 00:20:56,190
Ja voin vain tehdä tämän
kopioimalla ja liittämällä

413
00:20:56,190 --> 00:20:58,540
yhtä riviä koodia yläreunassa tiedoston.

414
00:20:58,540 --> 00:21:01,630
Minun täytyy opettaa Clang,
tai lupaus kalahtaa,

415
00:21:01,630 --> 00:21:04,630
nimenomaisesti, että minä,
todellakin, mene ja toteuttaa

416
00:21:04,630 --> 00:21:06,020
Tämän toiminnon get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Voisi vain pienempi tiedosto.

418
00:21:07,674 --> 00:21:09,840
Jälleen muistaa, että Clang
lukee asioita ylhäältä alas,

419
00:21:09,840 --> 00:21:12,330
vasemmalta oikealle, joten et voi
soittaa toiminto, jos Clang

420
00:21:12,330 --> 00:21:15,330
ei tiedä sitä tulee olla olemassa.

421
00:21:15,330 --> 00:21:18,430
>> Nyt valitettavasti tätä ohjelmaa,
kuten jotkut teistä ehkä huomannut,

422
00:21:18,430 --> 00:21:19,590
on jo buginen.

423
00:21:19,590 --> 00:21:21,400
Anna minun mennä eteenpäin ja tehdä buggy3.

424
00:21:21,400 --> 00:21:26,904
Se kokoaa, joten minun ongelmani nyt ei ole
syntaksivirhe, kuten sanallisesti virhe,

425
00:21:26,904 --> 00:21:29,570
se todella tulee olemaan looginen
virhe, että olen tarkoituksella

426
00:21:29,570 --> 00:21:32,450
teki mahdollisuutena
selata mitä tapahtuu.

427
00:21:32,450 --> 00:21:35,540
>> Aion mennä eteenpäin
nyt ja ajaa buggy3.

428
00:21:35,540 --> 00:21:37,490
Ja aion mennä
eteenpäin ja tee yhteistyötä.

429
00:21:37,490 --> 00:21:39,494
Aion antaa sen numero 1.

430
00:21:39,494 --> 00:21:41,410
Se ei pidä siitä, niin
se kehotukset minua uudelleen.

431
00:21:41,410 --> 00:21:42,147
>> Miten noin 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Mikään näistä toimivat.

435
00:21:44,740 --> 00:21:46,890
Miten noin -50?

436
00:21:46,890 --> 00:21:48,560
Ja ohjelma näyttää toimivan.

437
00:21:48,560 --> 00:21:49,970
>> Yritän vielä kerran.

438
00:21:49,970 --> 00:21:53,400
Yritän -1, tuntuu toimivan.

439
00:21:53,400 --> 00:21:56,380
Yritän -2, tuntuu toimivan.

440
00:21:56,380 --> 00:21:59,640
Yritän 0.

441
00:21:59,640 --> 00:22:01,684
Huh, se on virheellinen.

442
00:22:01,684 --> 00:22:03,350
Nyt olemme nyt hieman pikkutarkka täällä.

443
00:22:03,350 --> 00:22:07,090
Mutta se on todellakin niin, että 0
ei ole myönteinen eikä kielteinen.

444
00:22:07,090 --> 00:22:11,150
Ja niin, että minun ohjelma on
sanomalla, että 0 on negatiivinen kokonaisluku,

445
00:22:11,150 --> 00:22:12,820
se ei ole teknisesti oikein.

446
00:22:12,820 --> 00:22:15,180
>> Nyt miksi se tekee näin?

447
00:22:15,180 --> 00:22:16,270
No, se voisi olla ilmeinen.

448
00:22:16,270 --> 00:22:18,110
Ja, todellakin, ohjelma on
tarkoitus olla melko yksinkertainen

449
00:22:18,110 --> 00:22:19,670
joten meillä on jotain tutkia.

450
00:22:19,670 --> 00:22:25,870
>> Mutta perehdymme kolmannen virheenkorjaus
tekniikkaa tässä kutsutaan debug50.

451
00:22:25,870 --> 00:22:27,750
Eli tämä on ohjelma
että olemme juuri luonut

452
00:22:27,750 --> 00:22:30,770
tänä vuonna nimeltään debug50
jonka avulla voit

453
00:22:30,770 --> 00:22:34,130
käyttää mitä kutsutaan sisäänrakennettu
graafinen debuggeri CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Ja debugger on vain ohjelma, joka
yleensä voit ajaa ohjelmaa

455
00:22:38,400 --> 00:22:44,050
mutta askel askeleelta askeleelta, linja
jonka rivi riviltä, ​​tauot, tönäisi

456
00:22:44,050 --> 00:22:47,626
noin, katsomalla muuttujia, jotta
ohjelma ei ole vain puhaltaa ohi

457
00:22:47,626 --> 00:22:49,750
ja nopeasti tulostaa jotain
tai ei tulosta jotain.

458
00:22:49,750 --> 00:22:53,250
Se antaa sinulle mahdollisuuden, at
ihmisen nopeus, olla vuorovaikutuksessa sen kanssa.

459
00:22:53,250 --> 00:22:55,470
>> Ja tehdä tämän, sinun
yksinkertaisesti toimi seuraavasti.

460
00:22:55,470 --> 00:22:58,479
Sen jälkeen koota koodin,
joka Olen jo tehnyt, buggy3,

461
00:22:58,479 --> 00:23:00,020
mennä eteenpäin ja ajaa debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Niin paljon kuin help50 on juokset
help50 ja sitten komento,

464
00:23:06,760 --> 00:23:10,120
debug50 on juokset debug50 ja
Sitten nimi komennon.

465
00:23:10,120 --> 00:23:14,440
>> Nyt katsoa mitä tapahtuu tietokoneen näytöllä,
oikealla puolella erityisesti.

466
00:23:14,440 --> 00:23:19,400
Kun osuin Run, kaikki
äkillinen tämä oikeanpuoleinen paneeli

467
00:23:19,400 --> 00:23:20,419
avaa näytölle.

468
00:23:20,419 --> 00:23:22,210
Ja siellä on paljon menossa
on ensi silmäyksellä.

469
00:23:22,210 --> 00:23:25,110
Mutta ei ole liian
paljon murehtia vielä.

470
00:23:25,110 --> 00:23:28,570
>> Tämä osoittaa minulle kaiken
joka on meneillään sisällä minun ohjelman

471
00:23:28,570 --> 00:23:31,130
nyt ja kautta nämä
painikkeet ylös sitten

472
00:23:31,130 --> 00:23:35,910
että saan selata minun koodi
lopulta askel askel askeleelta.

473
00:23:35,910 --> 00:23:37,140
Mutta ei aivan vielä.

474
00:23:37,140 --> 00:23:38,060
Huomaa, mitä tapahtuu.

475
00:23:38,060 --> 00:23:40,600
Minun pääteikkuna
Minua kehotetaan n.

476
00:23:40,600 --> 00:23:44,560
Ja aion mennä eteenpäin ja
yhteistyöhön tällä kertaa ja kirjoita -1.

477
00:23:44,560 --> 00:23:48,770
Ja vaikkakin hieman arvoituksellisesti, -1
on negatiivinen kokonaisluku, kuten odotettua.

478
00:23:48,770 --> 00:23:52,020
>> Ja sitten lapsi poistui
tila 0 GDBserver poistumista.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, on nimi
perustana olevien ohjelmistojen

480
00:23:55,180 --> 00:23:56,620
joka toteuttaa tämän debugger.

481
00:23:56,620 --> 00:24:00,500
Mutta kaikki tämä todella tarkoittaa, debuggeri
meni pois, koska minun ohjelma lopettaa

482
00:24:00,500 --> 00:24:01,710
ja kaikki oli hyvin.

483
00:24:01,710 --> 00:24:06,020
Jos haluan todella testaan ​​ohjelma,
Minun täytyy ennaltaehkäisevästi kertoa debug50,

484
00:24:06,020 --> 00:24:08,920
minne haluan aloittaa
askelletaan läpi koodia?

485
00:24:08,920 --> 00:24:11,750
>> Ja ehkä yksinkertaisin tapa
tehdä se on seuraava.

486
00:24:11,750 --> 00:24:15,300
Jos minä viemällä hiiri
kouru minun toimittaja täällä,

487
00:24:15,300 --> 00:24:19,090
joten oikeastaan ​​vain sivupalkissa täällä,
vasemmalle linjan numero,

488
00:24:19,090 --> 00:24:21,870
Huomaa että jos minä klikkaa
kerran, Laitoin pieni punainen piste.

489
00:24:21,870 --> 00:24:24,460
Ja että pieni punainen piste,
kuten stop-merkin, tarkoittaa, hei,

490
00:24:24,460 --> 00:24:29,430
debug50, tauko suorittamisen minun koodi
tuolla kun olen ohjelman suorittamiseen.

491
00:24:29,430 --> 00:24:30,260
>> Joten tehdään se.

492
00:24:30,260 --> 00:24:37,340
Anna minun mennä eteenpäin ja ajaa minun ohjelma
jälleen debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Ja nyt, ilmoitusta, jotain
eri on tapahtunut.

494
00:24:40,110 --> 00:24:42,440
En sitä pyydettäessä
vielä omassa pääteikkunaan

495
00:24:42,440 --> 00:24:45,430
mitään, koska en ole
saanut siellä vielä omassa ohjelmassa.

496
00:24:45,430 --> 00:24:47,950
Huomaa, että rivillä 8
joka on nyt korostettu,

497
00:24:47,950 --> 00:24:51,720
ja siellä on pieni nuoli
vasen sanonta, olet keskeytetty täällä.

498
00:24:51,720 --> 00:24:55,030
Koodirivin, linja
8, ei ole vielä toteutettu.

499
00:24:55,030 --> 00:24:58,940
>> Ja mikä utelias, jos katson
tänne oikealla puolella,

500
00:24:58,940 --> 00:25:03,530
huomaa, että i on paikallinen
muuttuja, paikallinen siinä mielessä

501
00:25:03,530 --> 00:25:05,450
että se on sisällä olevan toiminnon.

502
00:25:05,450 --> 00:25:08,920
Ja sen arvo, ilmeisesti oletuksena,
ja tavallaan sopivasti, on 0.

503
00:25:08,920 --> 00:25:10,260
Mutta en kirjoita 0.

504
00:25:10,260 --> 00:25:13,410
Se vain sattuu olemaan sen
oletusarvo tällä hetkellä.

505
00:25:13,410 --> 00:25:15,490
>> Joten anna minun mennä eteenpäin ja tehdä tätä nyt.

506
00:25:15,490 --> 00:25:18,680
Anna minun mennä eteenpäin ja
yläkulmassa täällä, olen

507
00:25:18,680 --> 00:25:20,970
menossa eteenpäin ja
valitse tämä ensimmäinen kuvake, joka

508
00:25:20,970 --> 00:25:25,360
tarkoittaa askel yli, mikä tarkoittaa, älä ohita
se kuitenkin askel yli koodirivin,

509
00:25:25,360 --> 00:25:27,770
suorittamalla se matkan varrella.

510
00:25:27,770 --> 00:25:30,710
>> Ja nyt, huomaa, minun
nopea juuri muuttunut.

511
00:25:30,710 --> 00:25:31,380
Miksi niin?

512
00:25:31,380 --> 00:25:33,639
Olen kertonut debug50,
suorita koodirivin.

513
00:25:33,639 --> 00:25:34,930
Mitä tämä rivi koodia tehdä?

514
00:25:34,930 --> 00:25:35,960
Kysyy minua int.

515
00:25:35,960 --> 00:25:36,460
OK.

516
00:25:36,460 --> 00:25:37,400
Saanen yhteistyötä.

517
00:25:37,400 --> 00:25:41,340
Anna minun mennä eteenpäin nyt ja kirjoita -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Ja nyt huomaa, mikä on muuttunut.

519
00:25:42,920 --> 00:25:46,060
Oikealla puolella,
oman paikallisen muuttujan i

520
00:25:46,060 --> 00:25:48,200
arvellaan olevan noin -1 nyt.

521
00:25:48,200 --> 00:25:49,810
Ja se on edelleen tyyppiä int.

522
00:25:49,810 --> 00:25:53,102
>> Ja ilmoitus, myös minun niin kutsuttu
soittaa pino, missä minä keskeyttää?

523
00:25:53,102 --> 00:25:54,810
Me puhua enemmän
tätä tulevaisuudessa.

524
00:25:54,810 --> 00:25:58,620
Mutta kutsupino juuri viittaa mihin
toiminnot ovat tällä hetkellä liikkeessä.

525
00:25:58,620 --> 00:26:00,040
Juuri nyt se on vain tärkeimmät.

526
00:26:00,040 --> 00:26:03,590
Ja juuri nyt ainoa paikallinen
muuttuja on i, jonka arvo on 1.

527
00:26:03,590 --> 00:26:09,840
>> Ja kun lopulta askel yli tämän linjan
täällä, että sama kuvake oikeassa yläkulmassa,

528
00:26:09,840 --> 00:26:11,410
-1 On negatiivinen kokonaisluku.

529
00:26:11,410 --> 00:26:13,580
Nyt se on pysähtyen yli että kihara ahdin.

530
00:26:13,580 --> 00:26:14,740
Annetaan sen tehdä sen asian.

531
00:26:14,740 --> 00:26:17,300
Astun yli että linja, ja voila.

532
00:26:17,300 --> 00:26:20,240
>> Joten kaikki, että hirveän
valaiseva vielä,

533
00:26:20,240 --> 00:26:23,550
mutta se ei anna minun keskeyttää
ja miettiä loogisesti

534
00:26:23,550 --> 00:26:24,870
mitä tämä ohjelma tekee.

535
00:26:24,870 --> 00:26:26,890
Mutta se ei ollut virheellinen asia.

536
00:26:26,890 --> 00:26:28,510
Tehdään tämä uudelleen seuraavasti.

537
00:26:28,510 --> 00:26:31,340
>> Aion lähteä että keskeytyskohta
rivillä 8 kanssa red dot.

538
00:26:31,340 --> 00:26:32,830
Aion uusintana debug50.

539
00:26:32,830 --> 00:26:34,400
Se automaattisesti keskeytetty täällä.

540
00:26:34,400 --> 00:26:37,660
Mutta tällä kertaa sen sijaan,
tehostamalla tämän rajan yläpuolella,

541
00:26:37,660 --> 00:26:42,290
anna minun itse mennä sisälle
get_negative_int ja selvittää,

542
00:26:42,290 --> 00:26:45,530
miksi se hyväksyä 0 kelvolliseksi vastaus?

543
00:26:45,530 --> 00:26:47,990
>> Joten sen sijaan klikkaamalla Step Over.

544
00:26:47,990 --> 00:26:50,630
Aion mennä eteenpäin
ja valitse Step Into.

545
00:26:50,630 --> 00:26:54,030
Ja huomaa, että linja 8, joka on
nyt korostettu nyt yhtäkkiä

546
00:26:54,030 --> 00:26:56,900
tulee linja 17.

547
00:26:56,900 --> 00:26:59,947
>> Nyt, se ei ole niin debugger
on ohitettu linjat 14 ja 15 ja 16.

548
00:26:59,947 --> 00:27:01,780
Se on vain ei ole mitään
näyttämään siellä.

549
00:27:01,780 --> 00:27:04,050
Ne ovat vain julistaa muuttujia,
Ja sitten on sana Do

550
00:27:04,050 --> 00:27:05,390
ja sitten avoin kihara ahdin.

551
00:27:05,390 --> 00:27:09,227
Ainoa toimiva linja, joka on
mehukas todella on tämä yksi täällä, 17.

552
00:27:09,227 --> 00:27:11,060
Ja siellä olemme
keskeytetty automaattisesti.

553
00:27:11,060 --> 00:27:13,870
>> Niin printf ( "n.is:") ;, niin
joka ei ole vielä tapahtunut.

554
00:27:13,870 --> 00:27:18,250
Joten mene eteenpäin ja valitse Step Over.

555
00:27:18,250 --> 00:27:20,326
Nyt nopea, todellakin,
muutettu ( "n on:").

556
00:27:20,326 --> 00:27:22,450
Nyt get_int, en ole menossa
vaivata astumassa,

557
00:27:22,450 --> 00:27:24,750
koska toiminta oli
tekemät CS50 kirjastossa.

558
00:27:24,750 --> 00:27:25,750
Se on oletettavasti oikein.

559
00:27:25,750 --> 00:27:28,440
>> Joten aion mennä eteenpäin ja
tavallaan yhteistyötä antamalla sille

560
00:27:28,440 --> 00:27:30,590
int, mutta ei negatiivinen int.

561
00:27:30,590 --> 00:27:32,870
Joten anna minun mennä eteenpäin ja osui 0.

562
00:27:32,870 --> 00:27:39,460
Ja nyt, mitä tapahtuu täällä
kun saan alas linja 21?

563
00:27:39,460 --> 00:27:40,890
En ole iteroidaan uudelleen.

564
00:27:40,890 --> 00:27:43,320
En näytä olevan jumissa, että silmukka.

565
00:27:43,320 --> 00:27:45,990
Toisin sanoen, tämä keltainen
bar ei jatka ympärillä,

566
00:27:45,990 --> 00:27:47,130
ja ympäri ja ympäri.

567
00:27:47,130 --> 00:27:48,340
>> Nyt Miksi?

568
00:27:48,340 --> 00:27:49,920
No, n, mikä on n juuri nyt?

569
00:27:49,920 --> 00:27:53,280
Voin katsoa paikallisen
muuttujat virheenkorjauksen.

570
00:27:53,280 --> 00:27:53,816
n on 0.

571
00:27:53,816 --> 00:27:55,190
Selvä, mikä oli tilani?

572
00:27:55,190 --> 00:27:58,700
>> 20-- linja 20 on hyvin,
0 on suurempi kuin 0.

573
00:27:58,700 --> 00:27:59,500
Tuo ei ole totta.

574
00:27:59,500 --> 00:28:01,020
0 ei ole suurempi kuin 0.

575
00:28:01,020 --> 00:28:02,820
Ja niin minä puhkesi tästä.

576
00:28:02,820 --> 00:28:06,370
>> Ja joten siksi linjalla
21, jos olen itse edelleen,

577
00:28:06,370 --> 00:28:10,370
Aion palata 0, jopa
vaikka en olisi pitänyt hylätä 0

578
00:28:10,370 --> 00:28:12,484
sillä ei oikeastaan ​​ole negatiivisia.

579
00:28:12,484 --> 00:28:14,650
Joten nyt, en oikein edes
välitä virheenkorjauksen.

580
00:28:14,650 --> 00:28:16,900
Sain sen, en tarvitse
tietävät, mitä enemmän on tekeillä.

581
00:28:16,900 --> 00:28:19,233
>> Joten aion mennä eteenpäin ja
klikkaa Play-painiketta,

582
00:28:19,233 --> 00:28:20,240
ja olkoon tämä viimeistely ylös.

583
00:28:20,240 --> 00:28:23,440
Nyt olen ymmärtänyt, että minun
bug on ilmeisesti linjalla 20.

584
00:28:23,440 --> 00:28:25,160
Se on minun looginen virhe.

585
00:28:25,160 --> 00:28:28,100
>> Ja niin mitä haluanko
tehdä muuttaa tätä?

586
00:28:28,100 --> 00:28:32,500
Jos ongelma on että en ole
pyydystämiseen 0, se on vain looginen virhe.

587
00:28:32,500 --> 00:28:35,910
Ja voin sanoa, kun n on
suurempi tai yhtä suuri kuin 0,

588
00:28:35,910 --> 00:28:38,330
pitää kehottaa käyttäjää uudestaan ​​ja uudestaan.

589
00:28:38,330 --> 00:28:41,050
>> Joten, jälleen, yksinkertainen virhe, ehkä
vaikka esiin, kun näit minut

590
00:28:41,050 --> 00:28:42,410
kirjoittaa se vain muutama minuutti sitten.

591
00:28:42,410 --> 00:28:44,570
Mutta takeaway täällä
on, että debug 50,

592
00:28:44,570 --> 00:28:46,850
ja virheenkorjaus
ohjelmisto yleisemmin

593
00:28:46,850 --> 00:28:51,370
olet tämän uuden löytyi voimaa
käydä läpi oman koodin, katso

594
00:28:51,370 --> 00:28:55,590
kautta, että oikea käsi paneeli mitä
muuttujia arvot.

595
00:28:55,590 --> 00:28:57,700
Joten et välttämättä
täytyy käyttää jotain

596
00:28:57,700 --> 00:29:00,630
kuten sinä eprintf tulostaa näitä arvoja.

597
00:29:00,630 --> 00:29:04,430
Voit itse nähdä ne
visuaalisesti näytöllä.

598
00:29:04,430 --> 00:29:08,920
>> Nyt pidemmälle, on syytä huomata,
että on olemassa toinen tekniikka, joka on

599
00:29:08,920 --> 00:29:09,890
todella Super yhteinen.

600
00:29:09,890 --> 00:29:13,120
Ja ehkä ihmetellä, miksi tämä pieni
kaveri täällä on istunut lavalla.

601
00:29:13,120 --> 00:29:16,490
Joten on tämä tekniikka, yleensä
tunnetaan kumiankka virheenkorjaus,

602
00:29:16,490 --> 00:29:18,786
joka oikeastaan ​​on vain
osoitus siitä,

603
00:29:18,786 --> 00:29:20,660
että usein kun ohjelmoijat
kirjoittavat koodia,

604
00:29:20,660 --> 00:29:22,650
he eivät välttämättä
yhteistyössä muiden kanssa,

605
00:29:22,650 --> 00:29:24,030
tai työskentelevät jaetussa ympäristössä.

606
00:29:24,030 --> 00:29:25,050
>> He tavallaan kotona.

607
00:29:25,050 --> 00:29:25,910
Ehkä se on myöhään illalla.

608
00:29:25,910 --> 00:29:28,190
He yrittävät hahmo
joitakin vian koodiaan.

609
00:29:28,190 --> 00:29:29,330
Ja he vain näe sitä.

610
00:29:29,330 --> 00:29:30,329
>> Ja ei ole kämppäkaveri.

611
00:29:30,329 --> 00:29:31,250
Ei ole mitään TF.

612
00:29:31,250 --> 00:29:32,680
Ei ole CA ympärillä.

613
00:29:32,680 --> 00:29:36,440
Kaikki ne on heidän hyllylle
on tämä pieni kumiankalla.

614
00:29:36,440 --> 00:29:39,030
>> Ja niin kumiankka virheenkorjaus
on juuri tämä kutsu

615
00:29:39,030 --> 00:29:42,780
ajatella jotain niin typerä
koska tämä on todellinen olento,

616
00:29:42,780 --> 00:29:46,940
ja itse kävellä läpi koodin
suullisesti tämän eloton objekti.

617
00:29:46,940 --> 00:29:49,230
Niinpä esimerkiksi, jos
tämä on minun esimerkki here--

618
00:29:49,230 --> 00:29:52,470
ja muistuttavat, että aikaisemmin
ongelma oli tämä,

619
00:29:52,470 --> 00:29:58,140
jos en poistaa tämän ensimmäisen rivin koodia,
ja minä mennä eteenpäin ja tehdä buginen 0 jälleen,

620
00:29:58,140 --> 00:30:01,220
muistaa, että sain nämä
virheilmoitukset täällä.

621
00:30:01,220 --> 00:30:05,997
Joten ajatus täällä, naurettava vaikka en
tuntea tällä hetkellä teet tämän julkisesti,

622
00:30:05,997 --> 00:30:06,580
on, että virhe.

623
00:30:06,580 --> 00:30:10,910
>> OK, joten minun ongelmani on, että olen
epäsuorasti julisti kirjaston funktion.

624
00:30:10,910 --> 00:30:12,610
Ja että kirjaston funktion on printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, julistaa
mieleeni prototyyppejä.

626
00:30:15,290 --> 00:30:18,930
>> Se tarkoittaa, että minun täytyy itse
kertoa kääntäjä etukäteen, mitä

627
00:30:18,930 --> 00:30:19,980
toiminto näyttää.

628
00:30:19,980 --> 00:30:20,930
Odota hetki.

629
00:30:20,930 --> 00:30:23,580
En ole vakio io.h.

630
00:30:23,580 --> 00:30:24,530
Paljon kiitoksia.

631
00:30:24,530 --> 00:30:27,330
>> Joten tässä prosessissa soita näin te
ei tarvitse itse olla ankka.

632
00:30:27,330 --> 00:30:29,819
Mutta tämä ajatus kävely
itse kautta oman koodin

633
00:30:29,819 --> 00:30:31,610
niin että te edes kuulla
itse, jotta voit

634
00:30:31,610 --> 00:30:35,620
ymmärtää puutteita omassa
huomautukset, on yleensä ajatus.

635
00:30:35,620 --> 00:30:38,910
>> Ja ehkä enemmän loogisesti, ei niin
paljoa, että yksi, mutta enemmän mukana

636
00:30:38,910 --> 00:30:44,220
Esimerkiksi me vain teki buginen 3.c,
saatat kävellä itse läpi

637
00:30:44,220 --> 00:30:45,310
seuraavasti.

638
00:30:45,310 --> 00:30:49,190
Joten kunnossa, kumia
ducky, DDB, jos haluatte.

639
00:30:49,190 --> 00:30:52,350
Tässä meillä on minun päätehtävä,
Soitan saada negatiivinen int.

640
00:30:52,350 --> 00:30:54,660
>> Ja Saan palauttaa arvon.

641
00:30:54,660 --> 00:31:00,410
Olen tallentamalla sen vasemmalla puolella
rivillä 8 muuttujaan nimeltä i.

642
00:31:00,410 --> 00:31:02,380
OK, mutta odottaa, kuinka teki
että tuon arvon?

643
00:31:02,380 --> 00:31:04,130
Saanen tarkastella toiminto linjassa 12.

644
00:31:04,130 --> 00:31:05,760
>> Linjassa 12, meillä on saada negatiivinen int.

645
00:31:05,760 --> 00:31:08,190
Ei ota mitään tuloa,
ei palaa int, OK.

646
00:31:08,190 --> 00:31:10,929
Vakuutan linjan 14 muuttujan n.

647
00:31:10,929 --> 00:31:12,220
Se tulee tallentaa kokonaisluku.

648
00:31:12,220 --> 00:31:13,760
Se on, mitä haluan.

649
00:31:13,760 --> 00:31:18,480
>> Joten tee alla n is-- let
minulle kumoa mitä fix olen jo tehnyt.

650
00:31:18,480 --> 00:31:22,710
Joten kun n on suurempi kuin
0, tulostaa N, OK.

651
00:31:22,710 --> 00:31:25,170
Ja sitten soittaa saada int tallennettu n.

652
00:31:25,170 --> 00:31:30,160
Ja sitten tarkistaa, jos n on 0,
n on not-- siellä se on.

653
00:31:30,160 --> 00:31:31,910
Joten, jälleen, et
tarvitsevat todellinen ankka.

654
00:31:31,910 --> 00:31:35,650
Mutta vain kävely itseäsi
koodi kuin henkinen harjoitus

655
00:31:35,650 --> 00:31:37,720
usein auttaa
ymmärtää, mitä on tekeillä,

656
00:31:37,720 --> 00:31:41,170
toisin kuin juuri tekemässä jotain
näin, tuijottaen näyttöä,

657
00:31:41,170 --> 00:31:43,720
ja ei puhu itseäsi
se, mikä rehellisesti ei ole

658
00:31:43,720 --> 00:31:46,270
lähes yhtä tehokas tekniikka.

659
00:31:46,270 --> 00:31:48,620
Siinäpä se, joka on
useita erilaisia ​​tekniikoita

660
00:31:48,620 --> 00:31:52,102
kapasiteetin varsinaisen virheenkorjaus koodi
ja löytää vika, jotka kaikki

661
00:31:52,102 --> 00:31:54,810
pitäisi olla välineitä oman työkalupakin
niin että et ole myöhään illalla,

662
00:31:54,810 --> 00:31:57,660
varsinkin, olet ruokailu
hallit, tai toimistossa tuntia,

663
00:31:57,660 --> 00:32:00,368
hakkaa päätäsi
seinä, yrittää ratkaista joitakin ongelmia.

664
00:32:00,368 --> 00:32:02,020
Ymmärtää, että on olemassa ohjelmistotyökaluja.

665
00:32:02,020 --> 00:32:03,720
On kumiankka työkaluja.

666
00:32:03,720 --> 00:32:09,630
Ja siellä on koko henkilökunta
tukea odottaa lainata käsi.

667
00:32:09,630 --> 00:32:13,120
>> Joten nyt, sana ongelmasta
asetetaan, ja mitä toivomme teille

668
00:32:13,120 --> 00:32:15,620
päästä ulos niistä, ja miten
osaamme arvioida.

669
00:32:15,620 --> 00:32:17,680
Per kurssin oppimäärän,
CS50 ongelma sarjaa

670
00:32:17,680 --> 00:32:22,320
arvioidaan neljän ensisijaisen akseleilla, niin
ja speak-- laajuus, oikeellisuudesta, suunnittelu,

671
00:32:22,320 --> 00:32:23,060
ja tyyli.

672
00:32:23,060 --> 00:32:25,910
Ja laajuus vain tarkoittaa sitä, kuinka paljon
pala olet purrut pois?

673
00:32:25,910 --> 00:32:28,080
Kuinka suuri ongelma olet kokeillut?

674
00:32:28,080 --> 00:32:30,110
Mikä rasitustaso
olet ilmenee?

675
00:32:30,110 --> 00:32:35,750
>> Oikeellisuutta on, tekee ohjelma työtä
sen pitäisi per CS50 toiveiden

676
00:32:35,750 --> 00:32:38,640
Kun annat tiettyjä panoksia
tai tietyt lähtöihin?

677
00:32:38,640 --> 00:32:41,130
Suunnittelu on kaikkein subjektiivinen niistä.

678
00:32:41,130 --> 00:32:43,360
Ja se on se, joka tulee
ottaa pisin oppia

679
00:32:43,360 --> 00:32:47,220
ja pisin opettaa, vuonna
sikäli kuin se kuihtuu,

680
00:32:47,220 --> 00:32:49,530
kuinka hyvin kirjoitettu on koodi?

681
00:32:49,530 --> 00:32:52,920
>> Se on yksi asia vain tulostaa oikea
lähtöjen tai palauttaa oikeat arvot.

682
00:32:52,920 --> 00:32:55,400
Mutta teet sen
mahdollisimman tehokkaasti?

683
00:32:55,400 --> 00:32:58,210
Teetkö sitä kuilua
ja valloittaa, tai binary

684
00:32:58,210 --> 00:33:01,500
search kuten tulemme pian nähdä, että me teimme
kaksi viikkoa sitten kanssa puhelinluettelosta?

685
00:33:01,500 --> 00:33:04,670
Onko parempia tapoja ratkaista
ongelma kuin sinulla on täällä?

686
00:33:04,670 --> 00:33:06,380
Se mahdollisuus parempaan suunnitteluun.

687
00:33:06,380 --> 00:33:08,530
>> Ja sitten style-- miten
aika on koodi?

688
00:33:08,530 --> 00:33:12,370
Huomaat, että olen aika
erityisesti siitä sisennys oma koodi,

689
00:33:12,370 --> 00:33:15,300
ja varmista minun muuttujat
kohtuudella nimetty. n,

690
00:33:15,300 --> 00:33:19,660
vaikka lyhyt, on hyvä nimi varten
numero, i laskenta kokonaisluku,

691
00:33:19,660 --> 00:33:20,727
s merkkijono.

692
00:33:20,727 --> 00:33:22,560
Ja voimme olla pidempi
muuttujanimiin tyyli.

693
00:33:22,560 --> 00:33:25,500
Tyyli on, kuinka hyvä
ei koodin näyttää?

694
00:33:25,500 --> 00:33:26,600
Ja miten luettavissa on se?

695
00:33:26,600 --> 00:33:29,650
>> Ja ajan mittaan, mitä avustajat
ja TF: t tekevät kurssin

696
00:33:29,650 --> 00:33:31,870
on tarjota sinulle, että
sellaista laadullista palautetta

697
00:33:31,870 --> 00:33:34,330
jotta saat paremman
noita eri näkökohtia.

698
00:33:34,330 --> 00:33:37,510
Ja siinä, miten me
arvioi jokaisen näistä akseleista,

699
00:33:37,510 --> 00:33:40,080
se on tyypillisesti hyvin vähän
kauhat niin että te, yleensä,

700
00:33:40,080 --> 00:33:41,680
Saat käsityksen siitä, miten hyvin teet.

701
00:33:41,680 --> 00:33:45,680
Ja todellakin, jos saat pisteet
mitään näistä axes-- oikeellisuuden, suunnittelu

702
00:33:45,680 --> 00:33:49,659
ja tyyli especially-- että määrä
on yleensä välillä 1 ja 5.

703
00:33:49,659 --> 00:33:52,450
Ja kirjaimellisesti, jos saat
3: n alussa lukukauden,

704
00:33:52,450 --> 00:33:53,977
tämä on erittäin hyvä asia.

705
00:33:53,977 --> 00:33:55,810
Se tarkoittaa, että on vielä
tilaa parannuksille,

706
00:33:55,810 --> 00:33:58,490
johon voisi toivoa vuonna
ottaen luokan ensimmäistä kertaa.

707
00:33:58,490 --> 00:34:01,820
On toivottavasti joitakin vähän katto
johon olet pyrkivä pääsemiseksi.

708
00:34:01,820 --> 00:34:03,970
Ja niin saaminen 3: n päälle
aikaisintaan kappaletta,

709
00:34:03,970 --> 00:34:06,550
jos ei joitakin 2: n ja 4: n,
on todellakin hyvä asia.

710
00:34:06,550 --> 00:34:08,880
Se on hyvin ulottuvilla,
reilusti odotukset.

711
00:34:08,880 --> 00:34:11,421
>> Ja jos mielesi on kilpa, odota
minuutti, kolme viidestä.

712
00:34:11,421 --> 00:34:12,620
Se on todella 6 10.

713
00:34:12,620 --> 00:34:13,560
Se on 60%.

714
00:34:13,560 --> 00:34:14,830
Luoja, tuo on F.

715
00:34:14,830 --> 00:34:15,870
>> Se ei ole.

716
00:34:15,870 --> 00:34:17,600
Se ei ole, itse asiassa, että.

717
00:34:17,600 --> 00:34:22,710
Pikemminkin se mahdollisuuden parantaa
aikana lukukauden.

718
00:34:22,710 --> 00:34:25,580
Ja jos saat joitakin
Poors, nämä ovat mahdollisuus

719
00:34:25,580 --> 00:34:29,199
hyödyntää virka,
varmasti kohdat ja muita resursseja.

720
00:34:29,199 --> 00:34:32,840
>> Paras on mahdollisuus, todella,
olla ylpeä, kuinka pitkälle olet

721
00:34:32,840 --> 00:34:34,520
tulevat aikana lukukauden.

722
00:34:34,520 --> 00:34:38,199
Joten älä ymmärrä, jos mitään
muuten, kolme on hyvä.

723
00:34:38,199 --> 00:34:40,179
Ja se mahdollistaa tilaa kasvulle ajan.

724
00:34:40,179 --> 00:34:43,090
>> Siitä, miten nämä akselit ovat
painotettu, realistisesti olet

725
00:34:43,090 --> 00:34:46,745
aikoo viettää suurimman osan aikaa saada
asioita työtä, puhumattakaan oikein.

726
00:34:46,745 --> 00:34:49,120
Ja niin oikeellisuus on taipumus
painotetaan eniten, kuten

727
00:34:49,120 --> 00:34:51,360
tämä monikertaisesti kolme.

728
00:34:51,360 --> 00:34:54,659
Design on myös tärkeää, mutta
jotain, et välttämättä

729
00:34:54,659 --> 00:34:58,220
viettävät kaikki nämä tuntia
yrittää saada asiat vain töihin.

730
00:34:58,220 --> 00:35:00,019
>> Ja niin se on painotettu
hieman kevyemmin.

731
00:35:00,019 --> 00:35:01,560
Ja sitten tyyli painotetaan vähiten.

732
00:35:01,560 --> 00:35:03,710
Vaikka se ei ole yhtä
tärkeä pohjimmiltaan,

733
00:35:03,710 --> 00:35:05,990
se on vain, kenties
helpointa oikealle,

734
00:35:05,990 --> 00:35:08,440
matkien esimerkeissä
do luento ja osassa,

735
00:35:08,440 --> 00:35:11,080
asioita mukavasti
sisennetty ja kommentoi,

736
00:35:11,080 --> 00:35:14,320
ja niin edelleen on yksi helpoin
asioita ja saada oikea.

737
00:35:14,320 --> 00:35:16,960
Joten sinänsä, ymmärtää
että ne ovat pistettä

738
00:35:16,960 --> 00:35:19,000
jotka ovat suhteellisen helppo ymmärtää.

739
00:35:19,000 --> 00:35:22,360
>> Ja nyt muutaman sanan
this-- akateemisen rehellisyys.

740
00:35:22,360 --> 00:35:25,150
Joten kohti kurssin
oppimäärä, näet

741
00:35:25,150 --> 00:35:27,630
että kurssi on melko
bittinen kielen ympärillä.

742
00:35:27,630 --> 00:35:31,380
Ja tietenkin ottaa kysymys
akateeminen rehellisyys melko vakavasti.

743
00:35:31,380 --> 00:35:33,450
>> Meillä on eroa,
parempaan tai huonompaan,

744
00:35:33,450 --> 00:35:36,570
että on lähettänyt vuosittain enemmän
opiskelijat kurinpitotoimista

745
00:35:36,570 --> 00:35:39,670
kuin useimmat muita
Tietenkin, että olen tietoinen.

746
00:35:39,670 --> 00:35:42,580
Tämä ei välttämättä ole
osoituksena siitä,

747
00:35:42,580 --> 00:35:46,340
että CS opiskelijoita, tai CS50 opiskelijoita, ovat
mitään vähemmän rehellinen kuin luokkatoverit.

748
00:35:46,340 --> 00:35:49,090
Mutta tosiasia, että tässä
maailma, sähköisesti, me vain

749
00:35:49,090 --> 00:35:50,990
on teknologinen
keino havaita tämän.

750
00:35:50,990 --> 00:35:53,360
>> On tärkeää meille
oikeudenmukaisuus poikki luokka

751
00:35:53,360 --> 00:35:58,550
että teemme tunnistaa tämän, ja nosta
ongelma kun näemme asiat.

752
00:35:58,550 --> 00:36:01,980
Ja vain maalata kuvan, ja oikeastaan
auttamaan jotain tällaista uppoavat,

753
00:36:01,980 --> 00:36:04,600
nämä ovat ne
opiskelijat yli viimeisten 10 vuoden aikana

754
00:36:04,600 --> 00:36:07,610
jotka ovat olleet mukana joissakin
tällaiset asiat akateemisen rehellisyys,

755
00:36:07,610 --> 00:36:10,990
joidenkin 32 opiskelijoille
syksystä 2015, mikä

756
00:36:10,990 --> 00:36:13,760
on sanoa, että otamme
asiaan erittäin vakavasti.

757
00:36:13,760 --> 00:36:18,380
Ja lopulta, nämä luvut säveltää,
viimeksi noin 3%, 4% tai niin

758
00:36:18,380 --> 00:36:19,120
luokan.

759
00:36:19,120 --> 00:36:25,220
>> Joten määräenemmistö opiskelijoiden
näyttää siltä, ​​että viivat ovat selkeitä.

760
00:36:25,220 --> 00:36:27,940
Mutta älä pitää tämä
välitä, varsinkin myöhään

761
00:36:27,940 --> 00:36:32,080
yöllä, kun kamppailee
Joissakin ratkaisu ongelmaan asettaa,

762
00:36:32,080 --> 00:36:34,830
että käytössä on mekanismit
saada itseäsi paremmin

763
00:36:34,830 --> 00:36:37,870
tukea kuin voisi
ajatella, vaikka sillä hetkellä.

764
00:36:37,870 --> 00:36:40,514
Ymmärtää, että kun saamme
opiskelija väittää, ylitämme

765
00:36:40,514 --> 00:36:43,430
vertailla kaikkia lähetyksiä tänä vuonna
vastaan ​​kaikkia lähetyksiä viime vuonna,

766
00:36:43,430 --> 00:36:47,590
vastaan ​​kaikkia lähetyksiä vuodesta 2007,
ja koska, katsomalla, samoin,

767
00:36:47,590 --> 00:36:49,931
koodi -tietovarastoja verkossa,
keskustelufoorumit, työmailla.

768
00:36:49,931 --> 00:36:51,806
Ja me mainita,
todella, kaikki vuoksi

769
00:36:51,806 --> 00:36:56,040
kaikkien tietojen, että jos
joku muu voi löytää sen verkossa,

770
00:36:56,040 --> 00:36:57,880
varmasti, joten voimme kurssin.

771
00:36:57,880 --> 00:37:00,100
Mutta, todella, henki
Kurssin kuihtuu

772
00:37:00,100 --> 00:37:01,650
Tämän lausekkeen oppimäärän.

773
00:37:01,650 --> 00:37:03,670
Se on todellakin vain, kohtuullinen.

774
00:37:03,670 --> 00:37:06,680
>> Ja jos meidän oli tarkentaa, että
vain hieman kieltä,

775
00:37:06,680 --> 00:37:09,770
ymmärtää, että pohjimmiltaan kaikki
teoksesta, jota esittää tämän kurssin

776
00:37:09,770 --> 00:37:10,954
täytyy olla oma.

777
00:37:10,954 --> 00:37:13,870
Mutta sisällä, että on varmasti
mahdollisuuksia, ja rohkaisua,

778
00:37:13,870 --> 00:37:17,300
ja pedagoginen arvo kääntyen
others-- itse, TF: ien, CAS,

779
00:37:17,300 --> 00:37:20,760
TAS, ja muut luokassa,
tukea, saati ystäviä

780
00:37:20,760 --> 00:37:23,547
ja kämppäkaverini jotka ovat opiskelleet
CS ja ohjelmointi ennen.

781
00:37:23,547 --> 00:37:25,130
Ja niin on olemassa korvaus siitä.

782
00:37:25,130 --> 00:37:28,180
Ja Nyrkkisääntönä
on this-- kun pyytää apua,

783
00:37:28,180 --> 00:37:31,470
voit näyttää koodin muille,
mutta et voi katsella omaansa.

784
00:37:31,470 --> 00:37:34,880
Joten vaikka olet toimistossa tuntia,
tai D sali, tai jossain muualla

785
00:37:34,880 --> 00:37:37,450
työskennellyt joitakin osainen sarja,
yksiköiden kanssa ystävä, joka

786
00:37:37,450 --> 00:37:40,160
on täysin hieno, klo
Lopussa päivän työsi

787
00:37:40,160 --> 00:37:43,034
olisi viime kädessä kuuluvat kunkin
teistä vastaavasti, eikä

788
00:37:43,034 --> 00:37:45,700
jonkin verran yhteistä ponnistusta,
paitsi opinnäytetyön jossa

789
00:37:45,700 --> 00:37:47,410
se on sallittua ja suositeltavaa.

790
00:37:47,410 --> 00:37:49,830
>> Tiedä, että jos olet
kamppailevat jotain

791
00:37:49,830 --> 00:37:52,520
ja ystäväsi vain sattuu
paremmaksi tässä sinun,

792
00:37:52,520 --> 00:37:55,130
tai parempi tuohon ongelma kuin te,
tai vähän kauemmaksi eteenpäin kuin te,

793
00:37:55,130 --> 00:37:57,330
se on täysin järkevää kääntyä
ystäväsi ja sanoa, hei,

794
00:37:57,330 --> 00:38:00,480
Haittaako katsot minun koodi täällä,
auttaa minua spot mitä minun ongelma on?

795
00:38:00,480 --> 00:38:03,760
Ja toivottavasti vuonna
edun pedagogista arvoa

796
00:38:03,760 --> 00:38:07,040
että ystävä ei ole vain
sanovat, oi, tee tätä, vaan pikemminkin,

797
00:38:07,040 --> 00:38:09,917
mitä puuttuu verkossa
6, tai jotain?

798
00:38:09,917 --> 00:38:12,000
Ratkaisu ei kuitenkaan ole
että ystävä vieressäsi

799
00:38:12,000 --> 00:38:15,617
sanoa, No, täällä, anna minun vetää
tähän asti, ja näyttää minun ratkaisu sinulle.

800
00:38:15,617 --> 00:38:16,450
Niin, että on linja.

801
00:38:16,450 --> 00:38:18,670
Näytät koodia
toiset, mutta et saa

802
00:38:18,670 --> 00:38:22,350
katsella omaansa, jollei muuta
rajoitteet kurssin oppimäärän.

803
00:38:22,350 --> 00:38:24,760
>> Joten älä pitää mielessä tämä
niin sanottu pahoillani lauseke

804
00:38:24,760 --> 00:38:27,560
in kurssin oppimäärän samoin,
että jos sitoutua joitakin asiakirjalla

805
00:38:27,560 --> 00:38:30,476
ei ole järkevää, vaan tuo se
huomiota kurssin päät

806
00:38:30,476 --> 00:38:34,240
72 tunnin kuluessa, kurssin
voivat asettaa paikallisia seuraamuksia että

807
00:38:34,240 --> 00:38:37,380
voi kuulua epätyydyttävä tai
muussa arvosana työstä toimitettu.

808
00:38:37,380 --> 00:38:41,410
Mutta tietenkään ei viitata
asia edelleen kurinpitotoimia,

809
00:38:41,410 --> 00:38:43,010
lukuun ottamatta toistuvia tekoja.

810
00:38:43,010 --> 00:38:46,632
Toisin sanoen, jos et tehdä joitakin
tyhmä, varsinkin myöhään yöllä, päätös

811
00:38:46,632 --> 00:38:49,340
että seuraavana aamuna tai kaksi päivää
myöhemmin, heräät ja ymmärtää,

812
00:38:49,340 --> 00:38:50,870
mitä minä ajattelin?

813
00:38:50,870 --> 00:38:53,890
Teet CS50 näillä on markkinat
vahvistamisesta, että ongelma

814
00:38:53,890 --> 00:38:57,170
ja omistavat jopa se, että me
tavata puolitiehen ja käsitellä

815
00:38:57,170 --> 00:39:01,500
sen kanssa asiassa, joka on sekä
koulutus- ja arvokkaita sinulle,

816
00:39:01,500 --> 00:39:04,200
mutta silti rankaiseva jollakin tavalla.

817
00:39:04,200 --> 00:39:08,590
Ja nyt, ottaa terän, tämä.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEOTOISTOSTA]

819
00:39:10,570 --> 00:39:13,540
>> [MUSIIKKIA]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END TOISTO]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN: Selvä, olemme takaisin.

823
00:40:00,490 --> 00:40:03,680
Nyt katsomme yhdessä
Ensimmäinen meidän reaalimaailman verkkotunnuksia

824
00:40:03,680 --> 00:40:08,720
in CS50, taiteen salakirjoituksen,
taiteen lähettävän ja vastaanottavan

825
00:40:08,720 --> 00:40:11,840
salaisuus viestejä, salattu
viestit, jos haluatte,

826
00:40:11,840 --> 00:40:17,060
joita voidaan deciphered jos olet
joitakin keskeisiä ainesosa, että lähettäjä on

827
00:40:17,060 --> 00:40:18,030
yhtä hyvin.

828
00:40:18,030 --> 00:40:22,120
Joten motivoida tähän otamme
Katso tämä asia täällä,

829
00:40:22,120 --> 00:40:26,750
joka on esimerkki
salaisuus dekooderi rengas, joka

830
00:40:26,750 --> 00:40:34,042
voidaan käyttää, jotta selvittää
mitä salaista todellisuudessa on.

831
00:40:34,042 --> 00:40:35,750
Itse takaisin
päivä alakoulussa,

832
00:40:35,750 --> 00:40:38,787
jos koskaan lähettänyt salaisia ​​viestejä
jotkut ystävä tai jonkin murskaa luokassa,

833
00:40:38,787 --> 00:40:40,620
saattaisi kuvitella
olitte taitava

834
00:40:40,620 --> 00:40:46,530
by oman paperille muuttuvat,
kuten A-B, ja B C ja C D,

835
00:40:46,530 --> 00:40:47,590
ja niin edelleen.

836
00:40:47,590 --> 00:40:50,300
Mutta olit todella salaamalla
tietosi, vaikka

837
00:40:50,300 --> 00:40:53,300
jos se oli hieman triviaali, ei ollut
että vaikea opettaja ymmärtää,

838
00:40:53,300 --> 00:40:55,675
hyvin, jos vain vaihtaa
B ja C B,

839
00:40:55,675 --> 00:40:57,550
todella selvittää
mitä viesti oli,

840
00:40:57,550 --> 00:40:59,700
mutta olit salausinformaatioon.

841
00:40:59,700 --> 00:41:03,420
>> Olit juuri tekemässä sitä
yksinkertaisesti, aivan kuten Ralphie täällä

842
00:41:03,420 --> 00:41:07,934
kuuluisassa elokuvan, joka toimii
melko paljon loputtomiin joka talvi.

843
00:41:07,934 --> 00:41:08,600
[VIDEOTOISTOSTA]

844
00:41:08,600 --> 00:41:11,180
-Ole Se tiedetään kaiken
Ralph Parker on täten

845
00:41:11,180 --> 00:41:14,070
nimitetty jäseneksi Little
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
ja on oikeutettu kaikkiin kunnianosoitukset
ja hyödyt ilmenevät siihen.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
counter-allekirjoitettu Pierre Andre, musteella.

848
00:41:24,340 --> 00:41:27,160
Honors ja hyödyt,
jo yhdeksän vuoden iässä.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [HUUTAMINEN]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Come Päälle.

853
00:41:34,250 --> 00:41:35,210
Mennään sen kanssa.

854
00:41:35,210 --> 00:41:39,530
En tarvitse kaikki muu
noin salakuljettajia ja merirosvoja.

855
00:41:39,530 --> 00:41:41,660
>> : Kuuntele huomenna yö
solmittaessa seikkailu

856
00:41:41,660 --> 00:41:43,880
musta merirosvolaiva.

857
00:41:43,880 --> 00:41:46,650
Nyt on aika
Annien salainen viesti

858
00:41:46,650 --> 00:41:49,840
sinulle jäsenille Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Muista, lapset, vain jäsenille
Annie Secret Circle

860
00:41:53,570 --> 00:41:56,140
pystyy purkamaan Annien salainen viesti.

861
00:41:56,140 --> 00:42:00,340
>> Muista, Annie on riippuvainen teitä.

862
00:42:00,340 --> 00:42:02,880
Aseta nastat B2.

863
00:42:02,880 --> 00:42:05,230
Tässä on viesti.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Olen In, ensimmäinen salainen kokous.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Oli suuren äänen tänään.

868
00:42:15,780 --> 00:42:19,000
Voisin sanoa, että illan
Viesti oli todella tärkeä.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, joka on viesti
alkaen Annie itse.

870
00:42:22,694 --> 00:42:23,860
Muista, älä kerro kenellekään.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekuntia myöhemmin, olen ainoa
huoneeseen, jossa poika yhdeksän

873
00:42:32,930 --> 00:42:37,040
voisi istua rauhassa ja purkaa.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Menin seuraavaan, E.

876
00:42:42,360 --> 00:42:44,520
>> Ensimmäinen sana on olla.

877
00:42:44,520 --> 00:42:49,032
S, mitä oli tulossa helpompaa nyt, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -Voi, Tule, Ralphie, minun täytyy mennä!

879
00:42:51,733 --> 00:42:53,688
>> -Otan Olla alas, Ma!

880
00:42:53,688 --> 00:42:54,188
Jannu hurahtaa!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, varmista to-- varmasti mitä?

883
00:43:04,060 --> 00:43:05,970
Mikä oli pieni Orphan
Annie yrittää sanoa?

884
00:43:05,970 --> 00:43:07,264
Muista mitä?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy on saanut
mennä, voisitko tulla ulos?

886
00:43:09,634 --> 00:43:10,480
>> -Kaikki Oikea, Ma!

887
00:43:10,480 --> 00:43:12,880
Tulen ulos!

888
00:43:12,880 --> 00:43:14,550
>> -I Lähestyi nyt.

889
00:43:14,550 --> 00:43:16,620
Jännitys oli kauhea.

890
00:43:16,620 --> 00:43:17,720
Mitä se oli?

891
00:43:17,720 --> 00:43:20,170
Kohtalo planeetan
voi vaakalaudalla.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andyn mentävä!

894
00:43:23,170 --> 00:43:26,890
>> -Otan Olla oikealle ulos, itkeä ääneen!

895
00:43:26,890 --> 00:43:32,680
>> Muodostaen miltei siellä, sormet lensi, mieleni
oli teräs ansa, joka huokosten vibrated.

896
00:43:32,680 --> 00:43:37,198
Se oli melkein selvä, kyllä, kyllä, kyllä.

897
00:43:37,198 --> 00:43:43,091
>> -Ole Muista juoda Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Crummy kaupallinen?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Paskiainen.

903
00:43:54,227 --> 00:43:54,810
[END TOISTO]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN: OK, niin
että oli hyvin pitkä matka

905
00:43:57,390 --> 00:44:00,660
ottaa käyttöön salakirjoituksen,
ja myös Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Itse asiassa tästä vanha mainos
täällä, miksi Ovaltine niin hyvä?

907
00:44:04,470 --> 00:44:09,470
Se on keskittynyt louhinta kypsiä
ohramallas, puhdas kermaista lehmänmaito,

908
00:44:09,470 --> 00:44:14,360
ja erityisesti valmistettu kaakao, yhdessä
luonnon fosfatidien ja vitamiineja.

909
00:44:14,360 --> 00:44:18,240
Se on lisäksi täydennetty
lisävitamiineja B ja D, yum.

910
00:44:18,240 --> 00:44:21,600
Ja voit silti saada sen, ilmeisesti,
Amazon, kuten teimme täällä.

911
00:44:21,600 --> 00:44:24,810
>> Mutta motivaatio täällä oli
esitellä salakirjoitusta, erityisesti

912
00:44:24,810 --> 00:44:28,340
eräänlainen salakirjoituksen tiedossa
salaisiksi avaimen salausta.

913
00:44:28,340 --> 00:44:34,284
Ja kuten nimestä voi päätellä, koko
turvallisuus salainen avain salakirjoitusjärjestelmä,

914
00:44:34,284 --> 00:44:36,200
jos haluatte, menetelmää
vain muokkaamisella

915
00:44:36,200 --> 00:44:40,960
tiedot kahden ihmisen välillä, on se, että
vain lähettäjä ja vain vastaanottaja

916
00:44:40,960 --> 00:44:46,980
tietää salaisuuden key-- jotain arvoa, jotkut
salainen lause, jotkut salainen numero, joka

917
00:44:46,980 --> 00:44:50,660
ansiosta ne molemmat salata
ja purkaa tiedot.

918
00:44:50,660 --> 00:44:53,470
Ja salaus, oikeastaan,
on vain tällä viikolla 0.

919
00:44:53,470 --> 00:44:56,715
>> Se on ongelma, missä on tuloa,
kuten todelliset viestisi Englanti

920
00:44:56,715 --> 00:44:59,340
tai mitä kielen mukaan
haluat lähettää jollekulle luokassa,

921
00:44:59,340 --> 00:45:00,580
tai Internetin kautta.

922
00:45:00,580 --> 00:45:03,840
On olemassa jonkin verran lähtö, joka on menossa
olla salattu viesti, jota

923
00:45:03,840 --> 00:45:05,250
haluat vastaanottajan vastaan.

924
00:45:05,250 --> 00:45:07,405
Ja vaikka joku
keskimmäinen saa sitä liian,

925
00:45:07,405 --> 00:45:09,780
et halua niitä
välttämättä voi purkaa sen,

926
00:45:09,780 --> 00:45:12,840
koska sisällä tätä
musta laatikko, tai algoritmi,

927
00:45:12,840 --> 00:45:17,650
on jonkinlainen järjestelmä, jotkut askel askeleelta
ohjeet, ottamiseen että panos

928
00:45:17,650 --> 00:45:20,710
ja muuntamalla se osaksi
tulos on toivottavasti turvallisella tavalla.

929
00:45:20,710 --> 00:45:23,640
>> Ja itse asiassa, on jonkin verran
sanastoa tässä maailmassa seuraavasti.

930
00:45:23,640 --> 00:45:26,100
Vain teksti on sanaan
tietojenkäsittelytieteessä olisi

931
00:45:26,100 --> 00:45:28,449
käyttää kuvaamaan tuloon
sanoma, kuten Englanti

932
00:45:28,449 --> 00:45:31,240
tai mitä kieltä sitten itse
haluaa lähettää jollekin toiselle ihmiselle.

933
00:45:31,240 --> 00:45:35,450
Ja sitten salakieli on scramble
että salakoodattu, tai salattu,

934
00:45:35,450 --> 00:45:36,520
versio siitä.

935
00:45:36,520 --> 00:45:38,750
>> Mutta on yksi muu ainesosa täällä.

936
00:45:38,750 --> 00:45:43,200
On yksi muu tulo
salainen avaimen salausta.

937
00:45:43,200 --> 00:45:45,200
Ja se on avain itse,
joka on yleensä

938
00:45:45,200 --> 00:45:48,930
kuten näemme, useita, tai
kirjain tai sana riippumatta

939
00:45:48,930 --> 00:45:51,980
algoritmi on todella odottaa.

940
00:45:51,980 --> 00:45:53,870
>> Ja miten purkaa tietoa?

941
00:45:53,870 --> 00:45:55,110
Miten purkaa sitä?

942
00:45:55,110 --> 00:45:57,950
No, juuri kääntää
lähdöt ja tulot.

943
00:45:57,950 --> 00:46:00,900
>> Toisin sanoen, kun joku
vastaanottanut salatun viestin,

944
00:46:00,900 --> 00:46:03,740
hänellä yksinkertaisesti on
tietää, että sama avain.

945
00:46:03,740 --> 00:46:05,700
He ovat saaneet salakieli.

946
00:46:05,700 --> 00:46:09,530
Ja kytkemällä näiden kahden
panoksina salakirjoitusjärjestelmä,

947
00:46:09,530 --> 00:46:14,260
algoritmi, tämä musta laatikko, ulos
pitäisi tulla alkuperäisen selväkielisenä.

948
00:46:14,260 --> 00:46:17,830
Ja niin se on erittäin korkea
näkemys siitä, mikä salaustekniikan on oikeastaan

949
00:46:17,830 --> 00:46:18,590
kaikki.

950
00:46:18,590 --> 00:46:20,030
>> Joten sinne.

951
00:46:20,030 --> 00:46:22,700
Tarkastellaan alla
huppu jotain

952
00:46:22,700 --> 00:46:26,000
olemme saaneet selvinä
viime viikolla, ja tässä istunnossa

953
00:46:26,000 --> 00:46:27,629
here-- merkkijono.

954
00:46:27,629 --> 00:46:30,295
Merkkijono lopussa päivän
on vain joukko merkkejä.

955
00:46:30,295 --> 00:46:33,610
>> Voisi olla Hello World, tai
hei Zamyla, tai mitä tahansa.

956
00:46:33,610 --> 00:46:37,050
Mutta mitä se merkitsee
olla jono merkkejä?

957
00:46:37,050 --> 00:46:41,520
Itse asiassa, CS50 kirjasto antaa
meille tietotyyppiä kutsutaan merkkijono.

958
00:46:41,520 --> 00:46:45,140
>> Mutta ei oikeastaan ​​ole
sellaista kuin merkkijono C.

959
00:46:45,140 --> 00:46:49,450
Se on todellakin vain jono
merkki, merkki, merkki,

960
00:46:49,450 --> 00:46:52,180
merkki, takaisin, takaisin, jotta
takaisin, takaisin, takaisin sisälle

961
00:46:52,180 --> 00:46:54,650
tietokoneen muistiin, tai RAM.

962
00:46:54,650 --> 00:46:58,940
Ja me katsoa syvemmälle, että
tulevaisuudessa kun katsomme muistin itse,

963
00:46:58,940 --> 00:47:02,030
ja hyödyntäminen, ja
uhat, jotka ovat mukana.

964
00:47:02,030 --> 00:47:04,100
>> Mutta Tarkastellaan merkkijonon Zamyla.

965
00:47:04,100 --> 00:47:07,480
Joten vain nimi
ihmisen täällä, Zamyla,

966
00:47:07,480 --> 00:47:12,030
joka on sekvenssi
merkkiä, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Nyt oletetaan, että Zamyla nimi
on tallennettu tietokoneen

968
00:47:16,020 --> 00:47:16,880
ohjelmoida.

969
00:47:16,880 --> 00:47:20,830
>> No, on aivan selvää, että meidän pitäisi
pystyä katsomaan ne merkit

970
00:47:20,830 --> 00:47:21,590
erikseen.

971
00:47:21,590 --> 00:47:24,710
Joten olen juuri menossa vetää hieman
box noin Zamyla nimi tähän.

972
00:47:24,710 --> 00:47:31,580
Ja se on asia C että kun
on merkkijono, kuten Zamyla-- ja ehkä

973
00:47:31,580 --> 00:47:34,940
että jono on palannut
funktio kuin get merkkijonon,

974
00:47:34,940 --> 00:47:38,540
voit itse manipuloida
se merkki kerrallaan.

975
00:47:38,540 --> 00:47:42,070
>> Nyt tämä on germane varten
keskustelu käsillä, koska

976
00:47:42,070 --> 00:47:46,420
salakirjoituksessa jos haluat muuttaa
A B, ja B C ja C D,

977
00:47:46,420 --> 00:47:49,650
ja niin edelleen, sinun täytyy pystyä
tarkastella yksittäisten merkkien

978
00:47:49,650 --> 00:47:50,190
merkkijono.

979
00:47:50,190 --> 00:47:52,695
Sinun täytyy pystyä muuttamaan
Z jotain muuta, A

980
00:47:52,695 --> 00:47:55,280
jotain muuta, M
jotain muuta, ja niin edelleen.

981
00:47:55,280 --> 00:47:58,000
Ja niin me tarvitaan tapa,
ohjelmallisesti, joten

982
00:47:58,000 --> 00:48:03,020
puhua, C pystyä muuttamaan
ja tarkastella yksittäisiä kirjaimia.

983
00:48:03,020 --> 00:48:05,690
Ja voimme tehdä tämän seuraavasti.

984
00:48:05,690 --> 00:48:08,340
>> Anna minun mennä suunnata takaisin CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Ja anna minun mennä eteenpäin
ja luoda uuden tiedoston

986
00:48:11,130 --> 00:48:16,134
että Soitan tällä kertaa string0,
koska meidän ensimmäinen esimerkki, piste c.

987
00:48:16,134 --> 00:48:18,300
Ja aion mennä eteenpäin
ja piiska sitä seuraavasti.

988
00:48:18,300 --> 00:48:22,870
>> Joten kuuluvat CS50.h, ja
Sitten ovat standardin io.h,

989
00:48:22,870 --> 00:48:25,990
joka Olen melkein aina menossa
käyttää minun ohjelmia, ainakin

990
00:48:25,990 --> 00:48:26,780
ensin.

991
00:48:26,780 --> 00:48:32,180
int main mitätön, ja sitten täällä olen
aikoo tehdä jouset saa päästä merkkijono.

992
00:48:32,180 --> 00:48:35,260
Ja sitten aion
mennä eteenpäin ja tehdä tätä.

993
00:48:35,260 --> 00:48:37,460
Haluan mennä eteenpäin
ja, kuten järki tarkistaa,

994
00:48:37,460 --> 00:48:43,607
vain sanoa, hei, prosenttia s,
puolipisteitä tekee merkkijono 0.

995
00:48:43,607 --> 00:48:44,690
Ohoh, mitä teen täällä?

996
00:48:44,690 --> 00:48:45,930
Voi, en kytke se.

997
00:48:45,930 --> 00:48:48,120
Joten opetus, että
ollut tarkoituksellista.

998
00:48:48,120 --> 00:48:52,480
>> Joten virhe, enemmän prosenttia
tuloksia kuin data argumentteja.

999
00:48:52,480 --> 00:48:54,940
Ja tämä on, vuonna
line 7-- ok, joten minulla on,

1000
00:48:54,940 --> 00:48:56,690
lainaus lainaus päättyy, se
minun merkkijono printf.

1001
00:48:56,690 --> 00:48:58,151
Minulla on prosenttimerkki.

1002
00:48:58,151 --> 00:48:59,650
Mutta olen puuttuu toinen argumentti.

1003
00:48:59,650 --> 00:49:03,190
>> Olen puuttuu pilkku s, mikä
En ole aiemmissa esimerkeissä.

1004
00:49:03,190 --> 00:49:06,650
Joten hyvä tilaisuus korjata
yksi virhe, vahingossa.

1005
00:49:06,650 --> 00:49:09,950
Ja nyt minä juoksen
string0, kirjoita Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, hei Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Joten olemme ajaa tällaista ohjelmaa
muutamia eri kertaa nyt.

1008
00:49:14,144 --> 00:49:16,310
Mutta Tehdään jotain
hieman erilainen tällä kertaa.

1009
00:49:16,310 --> 00:49:19,450
Sen sijaan vain tulostus Zamyla n
Koko nimi ulos printf,

1010
00:49:19,450 --> 00:49:21,350
Tehdään se merkki kerrallaan.

1011
00:49:21,350 --> 00:49:22,700
>> Aion käyttää silmukka.

1012
00:49:22,700 --> 00:49:26,160
Ja aion antaa itselleni
laskenta muuttuja, nimeltään i.

1013
00:49:26,160 --> 00:49:33,530
Ja aion pitää iteroimalla, niin
kunhan i on pienempi kuin pituus s.

1014
00:49:33,530 --> 00:49:35,930
>> On käynyt ilmi, emme
Tätä viimeistä kertaa,

1015
00:49:35,930 --> 00:49:39,100
että c mukana
toiminto nimeltään Stirling.

1016
00:49:39,100 --> 00:49:42,690
Takaisin seuraavana päivänä, ja yleensäkin
edelleen toteutettaessa toimintoja,

1017
00:49:42,690 --> 00:49:45,405
ihmisillä usein valita hyvin
ytimekäs nimet tuollainen ääni

1018
00:49:45,405 --> 00:49:48,280
kuten mitä haluat, vaikka se on
puuttuu muutamia vokaaleja tai kirjaimia.

1019
00:49:48,280 --> 00:49:50,660
Joten Stirling on
nimi on toiminto,

1020
00:49:50,660 --> 00:49:53,880
vie argumentti välillä
Suluissa että pitäisi olla merkkijono.

1021
00:49:53,880 --> 00:49:56,910
Ja se vain palauttaa kokonaisluvun,
pituus merkkijonon.

1022
00:49:56,910 --> 00:50:00,580
>> Joten tämä silmukka rivillä 7 on menossa
aloittaa laskemisen i on yhtä suuri kuin 0.

1023
00:50:00,580 --> 00:50:02,530
Se tulee kasvattaa
i on jokaisen iteraation

1024
00:50:02,530 --> 00:50:04,350
1, kun olemme tehneet muutaman kerran.

1025
00:50:04,350 --> 00:50:06,780
Mutta se tulee vain tehdä
Tämän asti pisteeseen

1026
00:50:06,780 --> 00:50:09,660
kun i on pituus
merkkijonon itse.

1027
00:50:09,660 --> 00:50:14,520
>> Joten tämä on tapa, lopulta,
iteroimalla yli merkkiä

1028
00:50:14,520 --> 00:50:17,430
merkkijono sellaisenaan seuraavasti.

1029
00:50:17,430 --> 00:50:20,670
Aion tulostaa ole
Koko merkkijono, mutta prosenttia c,

1030
00:50:20,670 --> 00:50:22,860
yhden merkin
jonka jälkeen uusi rivi.

1031
00:50:22,860 --> 00:50:24,880
Ja sitten aion
mennä eteenpäin, ja tarvitsen

1032
00:50:24,880 --> 00:50:29,080
sanoa haluat tulostaa
nteen luonnetta s.

1033
00:50:29,080 --> 00:50:33,450
>> Joten jos i on muuttuja, joka ilmaisee
indeksi merkkijono, jossa

1034
00:50:33,450 --> 00:50:37,230
olet siinä, minun täytyy pystyä
sanoa, anna minulle nnen luonnetta s.

1035
00:50:37,230 --> 00:50:40,390
Ja c on tapa tehdä
Tämän hakasulkeilla.

1036
00:50:40,390 --> 00:50:43,679
Sinä yksinkertaisesti sanoa nimen
merkkijono, joka tässä tapauksessa on s.

1037
00:50:43,679 --> 00:50:46,970
Sitten käytät hakasulkeita, jotka ovat
yleensä vain yläpuolella rivinvaihtonäppäintä

1038
00:50:46,970 --> 00:50:48,110
näppäintä.

1039
00:50:48,110 --> 00:50:52,410
Ja sitten laitat indeksi
merkki, että haluat tulostaa.

1040
00:50:52,410 --> 00:50:55,960
Joten indeksin olemaan
number-- 0 tai 1, tai 2, tai 3, tai piste,

1041
00:50:55,960 --> 00:50:57,590
piste, piste, joitakin muita numero.

1042
00:50:57,590 --> 00:51:00,920
>> Ja voimme varmistaa, että se tulee
olla oikea määrä, koska olen

1043
00:51:00,920 --> 00:51:02,360
alkaa laskea 0.

1044
00:51:02,360 --> 00:51:07,020
Ja oletuksena, ensimmäinen merkki
merkkijono on sovitun käytännön 0.

1045
00:51:07,020 --> 00:51:09,230
Ja toinen merkki on teline 1.

1046
00:51:09,230 --> 00:51:11,120
Ja kolmas merkki on kiinnike 2.

1047
00:51:11,120 --> 00:51:13,630
Ja et halua mennä liian
pitkälle, mutta emme, koska olemme

1048
00:51:13,630 --> 00:51:17,780
menossa vain kasvattaa i kunnes se
on yhtä suuri kuin langan pituutta.

1049
00:51:17,780 --> 00:51:20,210
Ja jossa vaiheessa,
Tämän silmukan pysähtyy.

1050
00:51:20,210 --> 00:51:25,550
>> Joten anna minun mennä eteenpäin ja tallentaa tämän
ohjelma, ja ajaa tehdä jono 0.

1051
00:51:25,550 --> 00:51:28,400
Mutta minä mokasin.

1052
00:51:28,400 --> 00:51:35,390
Epäsuorasti julistaa kirjaston funktion
Stirling tyypin niin ja such-- nyt,

1053
00:51:35,390 --> 00:51:36,430
tämä kuulostaa tutulta.

1054
00:51:36,430 --> 00:51:37,440
Mutta se ei ole printf.

1055
00:51:37,440 --> 00:51:38,540
Ja se ei saa merkkijono.

1056
00:51:38,540 --> 00:51:40,480
>> En tyriä vuonna
samalla tavalla tällä kertaa.

1057
00:51:40,480 --> 00:51:45,100
Mutta huomaa täällä hieman alaspäin
lisäksi, kuuluu otsikon string.h,

1058
00:51:45,100 --> 00:51:47,210
määräyksiä tarvittavista
ilmoitus Stirling.

1059
00:51:47,210 --> 00:51:48,820
Joten on todella vihje siellä.

1060
00:51:48,820 --> 00:51:51,670
>> Ja todellakin se osoittautuu
on toinen otsikkotiedoston

1061
00:51:51,670 --> 00:51:53,970
että olemme ei käytetä
luokassa vielä, mutta se on

1062
00:51:53,970 --> 00:51:56,480
joukossa käytettävissä
teille, nimeltään string.h.

1063
00:51:56,480 --> 00:52:00,930
Ja kyseisen tiedoston, string.h
on Stirling ilmoitettu.

1064
00:52:00,930 --> 00:52:05,220
Joten anna minun mennä eteenpäin ja
tallentaa, tehdä jono

1065
00:52:05,220 --> 00:52:08,040
0-- mukava, ei virheilmoitukset tällä kertaa.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, ja
Olen aikeissa Enter,

1067
00:52:12,290 --> 00:52:16,710
jossa vaiheessa getstring on menossa
palauttaa merkkijonon, laita se s.

1068
00:52:16,710 --> 00:52:21,890
Sitten, että silmukka on menossa kerrata
yli S: n merkit yksi kerrallaan,

1069
00:52:21,890 --> 00:52:28,420
ja tulostaa ne yksi per rivi, koska
Jouduin että kenoviiva n lopussa.

1070
00:52:28,420 --> 00:52:34,530
Joten en voinut jättää että kenoviiva
n, ja sitten vain tulostaa Zamyla kaikki

1071
00:52:34,530 --> 00:52:37,460
samassa linjassa,
tehokkaasti reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, joka ei ole kovin hyödyllistä.

1073
00:52:38,999 --> 00:52:40,540
Mutta tässä tapauksessa, en ole tehnyt sitä.

1074
00:52:40,540 --> 00:52:43,610
Olen itse painettu yksi
merkin kerrallaan, yksi per rivi,

1075
00:52:43,610 --> 00:52:45,400
jotta voimme itse nähdä vaikutuksen.

1076
00:52:45,400 --> 00:52:46,900
>> Mutta minun pitäisi huomata yksi asia täällä.

1077
00:52:46,900 --> 00:52:48,930
Ja me palaamme
Tässä tulevassa viikossa.

1078
00:52:48,930 --> 00:52:52,650
Osoittautuu, että tämä
koodi on mahdollisesti buginen.

1079
00:52:52,650 --> 00:52:56,560
>> On käynyt ilmi, että get merkkijono
ja joitakin muita toimintoja elämässä

1080
00:52:56,560 --> 00:53:00,280
eivät välttämättä aina
palata mitä odotat.

1081
00:53:00,280 --> 00:53:03,010
Tiedämme luokan viimeinen
kerran tässä, jotka saavat

1082
00:53:03,010 --> 00:53:04,960
merkkijono on tarkoitus palauttaa merkkijono.

1083
00:53:04,960 --> 00:53:09,900
Mutta mitä jos käyttäjä kirjoittaa tällaista
pitkä sana, tai kohta, tai essee

1084
00:53:09,900 --> 00:53:13,010
että ei vain ole tarpeeksi
tietokoneen muistin sopivaksi sitä.

1085
00:53:13,010 --> 00:53:15,410
>> Kuten, mitä jos jotain menee
väärä alla huppu?

1086
00:53:15,410 --> 00:53:18,400
Se ei ehkä tapahdu usein,
mutta se voisi tapahtua kerran

1087
00:53:18,400 --> 00:53:21,520
tällöin, hyvin harvoin.

1088
00:53:21,520 --> 00:53:25,460
Ja niin käy ilmi, että get merkkijono
ja toimintoja, kuten se ei välttämättä

1089
00:53:25,460 --> 00:53:26,380
aina palata jouset.

1090
00:53:26,380 --> 00:53:30,680
He saattavat palauttaa jokin virhe arvo,
Joissakin Sentinel arvo niin sanotusti,

1091
00:53:30,680 --> 00:53:32,612
joka osoittaa, että
jotain on mennyt vikaan.

1092
00:53:32,612 --> 00:53:35,320
Ja te vain tiedä tätä maasta
on oppinut sen luokassa nyt,

1093
00:53:35,320 --> 00:53:37,700
tai ovat lukea lisää asiakirjoja.

1094
00:53:37,700 --> 00:53:43,120
On käynyt ilmi, että get merkkijono
voi palauttaa arvon nimeltä null.

1095
00:53:43,120 --> 00:53:46,220
Null on erityinen arvo, että me will
palata tulevassa viikossa.

1096
00:53:46,220 --> 00:53:50,420
Mutta nyt, juuri tietää, että jos haluan
olla todella asiallista eteenpäin

1097
00:53:50,420 --> 00:53:52,650
käyttäen get string, I
ei pitäisi vain kutsua sitä,

1098
00:53:52,650 --> 00:53:56,870
ja sokeasti käyttää paluuarvon,
luottaen siihen, että se on merkkijono.

1099
00:53:56,870 --> 00:53:59,420
>> Haluan ensin sanoa,
hei, hetkinen, vain

1100
00:53:59,420 --> 00:54:03,380
toteuttaa, jos s ei ole sama kuin
null, jos null, jälleen,

1101
00:54:03,380 --> 00:54:04,660
on vain joitakin erityisiä arvoa.

1102
00:54:04,660 --> 00:54:07,770
Ja se on ainoa erityinen arvon
tarvitse pelätä varten get merkkijono.

1103
00:54:07,770 --> 00:54:10,900
Hanki merkkijonon joko menossa
palauttaa merkkijono tai null.

1104
00:54:10,900 --> 00:54:17,219
>> Ja tämä huutomerkki yhtäläisyysmerkki
saatat tietää ehkä matematiikka luokka

1105
00:54:17,219 --> 00:54:20,510
että saatat piirtää yhtäläisyysmerkki kanssa
linjan läpi osoittamaan ole samanarvoisia.

1106
00:54:20,510 --> 00:54:23,135
Se ei ole yleensä luonteeltaan
voit kirjoittaa näppäimistöllä.

1107
00:54:23,135 --> 00:54:26,480
Ja niin useimmissa ohjelmointikieliä,
kun haluat sanoa erisuuri,

1108
00:54:26,480 --> 00:54:29,160
käytät huutomerkki,
muuten kutsutaan Bang.

1109
00:54:29,160 --> 00:54:33,180
Joten sanot bang yhtä kuin, mikä
ei tarkoita yhtä kuin loogisesti.

1110
00:54:33,180 --> 00:54:38,060
Se on aivan kuin siellä ei ole suurempi
kuin, tai yhtä suuri tai pienempi kuin

1111
00:54:38,060 --> 00:54:41,270
tai yhtä näppäimistön
joka tekee kaiken yhdessä symbolin.

1112
00:54:41,270 --> 00:54:44,020
Joten siksi, aikaisemmissa esimerkeissä,
teit avoin teline, ja sitten

1113
00:54:44,020 --> 00:54:48,670
yhtäläisyysmerkki, voidakseen tehdä
suurempi tai vaikkapa alle.

1114
00:54:48,670 --> 00:54:49,910
>> Joten mitä takeaway täällä?

1115
00:54:49,910 --> 00:54:53,880
Tämä on yksinkertaisesti tapa nyt on
Kyseisellä syntaksi, tämä ominaisuus,

1116
00:54:53,880 --> 00:54:57,390
iteroimalla yksilöllisiin
merkkijonon merkkien.

1117
00:54:57,390 --> 00:55:00,260
Ja aivan kuten ne neliö
suluissa voit saada niitä,

1118
00:55:00,260 --> 00:55:03,790
pitää näitä neliö suluissa
Tällainen vihjaten tämän taustalla

1119
00:55:03,790 --> 00:55:06,040
suunnittelu, jolloin jokainen
luonnetta sisällä merkkijono

1120
00:55:06,040 --> 00:55:10,180
on eräänlainen pakattuna jossain alla
huppu tietokoneen muistiin.

1121
00:55:10,180 --> 00:55:12,340
>> Mutta Tehdään muunnelmaa.

1122
00:55:12,340 --> 00:55:14,880
Osoittautuu, että tämä
Ohjelma on oikea.

1123
00:55:14,880 --> 00:55:18,810
Joten per CS50 kirveille arvioimiseksi
koodi, tämä on oikea nyt.

1124
00:55:18,810 --> 00:55:22,959
Erityisesti nyt, että olen tarkistanut
null, tämä ohjelma pitäisi koskaan kaatua.

1125
00:55:22,959 --> 00:55:24,500
Ja minä vain tiedän, että kokemuksesta.

1126
00:55:24,500 --> 00:55:28,040
Mutta ei ole mitään muuta,
voimme todella mennä pieleen.

1127
00:55:28,040 --> 00:55:31,860
Mutta se ei ole kovin hyvin suunniteltu,
koska mennään takaisin perusasioihin.

1128
00:55:31,860 --> 00:55:34,450
>> Ensimmäinen, principles--
Mitä for-silmukka tehdä?

1129
00:55:34,450 --> 00:55:36,290
A silmukka tekee kolme asiaa.

1130
00:55:36,290 --> 00:55:39,340
Se alustaa joitakin
arvoa, jos kysyt sitä.

1131
00:55:39,340 --> 00:55:41,770
Se tarkistaa ehdon.

1132
00:55:41,770 --> 00:55:45,380
Ja sitten jokaisen
iteraation, jokaisen jakson,

1133
00:55:45,380 --> 00:55:49,330
se kasvattaa joitakin
arvo tai arvot, täällä.

1134
00:55:49,330 --> 00:55:50,600
>> Mitä tämä tarkoittaa?

1135
00:55:50,600 --> 00:55:52,940
Me alustaa i 0.

1136
00:55:52,940 --> 00:55:58,610
Tarkistamme ja varmista i on pienempi kuin
pituus s, joka on Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
niin, joka on pienempi kuin 6.

1138
00:55:59,900 --> 00:56:02,590
Ja, todellakin, 0, kun vähemmän kuin 6.

1139
00:56:02,590 --> 00:56:05,580
>> Me tulostaa Z päässä Zamyla nimi.

1140
00:56:05,580 --> 00:56:08,080
Sitten kasvattaa i 0-1.

1141
00:56:08,080 --> 00:56:11,290
Me sitten tarkistaa, on 1 vähemmän
kuin pituus s?

1142
00:56:11,290 --> 00:56:13,270
Pituus s on 6.

1143
00:56:13,270 --> 00:56:13,950
Kyllä se on.

1144
00:56:13,950 --> 00:56:16,880
>> Joten me tulostaa in Zamyla nimi, ZA.

1145
00:56:16,880 --> 00:56:20,090
Me kasvattaa i 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Me sitten tarkistaa, on 2 alle
pituus Zamyla nimi.

1147
00:56:23,720 --> 00:56:25,380
6- joten 2 on alle 6.

1148
00:56:25,380 --> 00:56:30,460
Kyllä, nyt tulostaa nyt M
Zamyla nimi, kolmas merkki.

1149
00:56:30,460 --> 00:56:34,110
>> Tärkeintä tässä on, että kullakin
iterointia tarina, olen tarkkailun,

1150
00:56:34,110 --> 00:56:37,810
on i pienempi kuin pituus Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Mutta saalis on, että
Stirling ei ole omaisuutta.

1152
00:56:40,350 --> 00:56:43,100
Ne teistä, jotka ovat ohjelmoitu
ennen Java tai muilla kielillä

1153
00:56:43,100 --> 00:56:46,310
tunteakseen merkkijonon pituuden on
ominaisuus, vain joitakin lukea vain arvoa.

1154
00:56:46,310 --> 00:56:50,220
>> C tässä tapauksessa, jos tämä on
funktio, joka on kirjaimellisesti

1155
00:56:50,220 --> 00:56:53,520
lukumäärän laskemisen
merkkiä Zamyla joka kerta

1156
00:56:53,520 --> 00:56:54,740
kutsumme tätä toiminnallisuutta.

1157
00:56:54,740 --> 00:56:58,500
Joka kerta kun pyytää tietokoneen käyttämään
Stirling, se vilkaisemalla Zamyla,

1158
00:56:58,500 --> 00:57:01,960
ja sanomalla Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Ja se palaa 6.

1160
00:57:02,962 --> 00:57:04,920
Seuraavan kerran kun soittaa
se sisällä että silmukka,

1161
00:57:04,920 --> 00:57:08,610
se tulee katsomaan Zamyla
jälleen, sanovat Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Ja se tulee palauttaa 6.

1163
00:57:10,320 --> 00:57:12,980
Joten mitä tyhmä tästä suunnittelu?

1164
00:57:12,980 --> 00:57:17,700
>> Miksi koodia ole 5 out of 5
suunnittelu juuri nyt, niin sanotusti?

1165
00:57:17,700 --> 00:57:20,600
No, minä kysyy
kysymys tarpeettomasti.

1166
00:57:20,600 --> 00:57:23,030
Teen enemmän työtä kuin minun täytyy.

1167
00:57:23,030 --> 00:57:25,370
>> Joten vaikka
vastaus on oikea, olen

1168
00:57:25,370 --> 00:57:29,560
kysyy tietokone, mikä on
pituus Zamyla uudelleen,

1169
00:57:29,560 --> 00:57:31,380
ja uudestaan, ja uudestaan, ja uudestaan?

1170
00:57:31,380 --> 00:57:33,980
Ja vastaus on
koskaan muutu.

1171
00:57:33,980 --> 00:57:35,900
Se on aina olemaan 6.

1172
00:57:35,900 --> 00:57:39,730
>> Joten parempi ratkaisu kuin tämä
olisi tämän seuraavan version.

1173
00:57:39,730 --> 00:57:43,390
Anna minun mennä eteenpäin ja laita se
erillinen tiedosto nimeltä string1.c,

1174
00:57:43,390 --> 00:57:44,990
vain pitää se erillään.

1175
00:57:44,990 --> 00:57:47,260
Ja se osoittautuu on varten
silmukka, voit itse

1176
00:57:47,260 --> 00:57:50,210
julistaa useita muuttujia kerralla.

1177
00:57:50,210 --> 00:57:53,460
>> Joten aion pitää i ja aseta se 0.

1178
00:57:53,460 --> 00:57:56,190
Mutta minä myös menossa
lisätä pilkku, ja sanoa,

1179
00:57:56,190 --> 00:58:01,050
antaa minulle muuttuja nimeltä n, jonka
arvo on merkkijonon pituus s.

1180
00:58:01,050 --> 00:58:09,410
Ja nyt, tee tilani
kunhan i on pienempi kuin n.

1181
00:58:09,410 --> 00:58:14,140
>> Joten tällä tavalla, logiikka on
identtiset lopussa päivän.

1182
00:58:14,140 --> 00:58:18,280
Olen kuitenkin muistaen
arvo 6, tässä tapauksessa.

1183
00:58:18,280 --> 00:58:19,780
Mikä on pituus Zamyla nimi?

1184
00:58:19,780 --> 00:58:20,860
Ja olen laskemisesta sitä n.

1185
00:58:20,860 --> 00:58:23,050
>> Ja olen edelleen tarkkailun
ehto joka kerta.

1186
00:58:23,050 --> 00:58:24,300
On 0 vähintään 6?

1187
00:58:24,300 --> 00:58:25,600
On 1 vähemmän kuin 6?

1188
00:58:25,600 --> 00:58:28,600
On 2 alle 6, ja niin edelleen?

1189
00:58:28,600 --> 00:58:31,914
>> Mutta en pyydä tietokonetta
uudestaan, ja uudestaan, mikä

1190
00:58:31,914 --> 00:58:33,080
pituus Zamyla nimi?

1191
00:58:33,080 --> 00:58:34,320
Mitä pituus Zamyla nimi?

1192
00:58:34,320 --> 00:58:35,986
Mitä pituus tämän Zamyla nimi?

1193
00:58:35,986 --> 00:58:40,440
Olen kirjaimellisesti muistaa, että ensimmäinen ja
vain vastata tässä toisessa muuttujan n.

1194
00:58:40,440 --> 00:58:45,280
Joten tämä nyt olisi paitsi
oikea, mutta myös hyvin suunniteltu.

1195
00:58:45,280 --> 00:58:46,670
>> Nyt entä tyyli?

1196
00:58:46,670 --> 00:58:48,866
Olen Nimesin muuttujat
melko hyvin, sanoisin.

1197
00:58:48,866 --> 00:58:50,240
He Super ytimekäs juuri nyt.

1198
00:58:50,240 --> 00:58:52,090
Ja se on täysin kunnossa.

1199
00:58:52,090 --> 00:58:55,120
>> Jos sinulla on vain yksi
merkkijono ohjelmassa,

1200
00:58:55,120 --> 00:58:56,860
voit yhtä hyvin kutsua sitä s jousikvartetille.

1201
00:58:56,860 --> 00:58:59,370
Jos sinulla on vain yksi muuttuja
laskemiseksi ohjelmassa,

1202
00:58:59,370 --> 00:59:00,710
voit yhtä hyvin kutsua sitä i.

1203
00:59:00,710 --> 00:59:03,500
Jos on pituus, n
on super yhteinen samoin.

1204
00:59:03,500 --> 00:59:05,800
Mutta en ole kommentoinut mitään minun koodia.

1205
00:59:05,800 --> 00:59:09,200
>> En ole ilmoittanut reader--
onko se minun TF, tai TA,

1206
00:59:09,200 --> 00:59:12,460
tai vain colleague-- mitä on oletettu
on käynnissä tässä ohjelmassa.

1207
00:59:12,460 --> 00:59:15,760
Ja niin saada hyvä tyyli,
mitä haluaisi tehdä

1208
00:59:15,760 --> 00:59:24,580
on this-- jotain
kuten pyytää käyttäjältä syötettä.

1209
00:59:24,580 --> 00:59:26,670
Voisin kirjoittaa
Tämän monin tavoin.

1210
00:59:26,670 --> 00:59:35,630
>> Varmista S-- varmista get
merkkijono palautetaan merkkijono.

1211
00:59:35,630 --> 00:59:40,280
Ja sitten here-- ja tämä on ehkä
tärkein comment-- toistaa

1212
00:59:40,280 --> 00:59:44,450
yli merkkiä s kerrallaan.

1213
00:59:44,450 --> 00:59:47,060
Ja voisin käyttää mitä tahansa
valikoima Englanti kielen

1214
00:59:47,060 --> 00:59:49,650
tässä kuvaamaan kukin
Näiden paloina koodia.

1215
00:59:49,650 --> 00:59:52,740
>> Huomaa, että en ole laittaa
kommentoida jokainen rivi koodia,

1216
00:59:52,740 --> 00:59:55,690
oikeastaan ​​vain on mielenkiintoinen
niitä, ne jotka

1217
00:59:55,690 --> 00:59:59,460
on joitakin merkitys etten tekisi
haluamme tehdä Super selväksi jonkun

1218
00:59:59,460 --> 01:00:00,460
käsittelyssä minun koodi.

1219
01:00:00,460 --> 01:00:02,920
Ja miksi soitat saat
string pyytää käyttäjältä syöttää?

1220
01:00:02,920 --> 01:00:05,450
Jopa, että yksi ei välttämättä
kaiken kuvaileva.

1221
01:00:05,450 --> 01:00:09,340
Mutta se auttaa kertoa tarinan, koska
toinen rivi tarina on, varmista

1222
01:00:09,340 --> 01:00:10,740
saada merkkijono palautetaan merkkijono.

1223
01:00:10,740 --> 01:00:14,260
>> Ja kolmas rivi tarina on,
kerrata yli merkkiä s yhteen

1224
01:00:14,260 --> 01:00:15,380
kerrallaan.

1225
01:00:15,380 --> 01:00:17,920
Ja nyt vain hyvä toimenpide,
Aion mennä eteenpäin ja lisätä

1226
01:00:17,920 --> 01:00:24,560
yhden huomautuksen, että vain
sanoo print i: nnen hahmo s.

1227
01:00:24,560 --> 01:00:26,520
Nyt, mitä olen tehnyt
päivän päätteeksi?

1228
01:00:26,520 --> 01:00:29,190
>> Olen lisännyt joitakin Englanti
sanojen muodossa kommentteja.

1229
01:00:29,190 --> 01:00:32,700
Kautta-slash symboli tarkoittaa, hei,
tietokone tämä on ihmisen,

1230
01:00:32,700 --> 01:00:33,820
ei teille, tietokone.

1231
01:00:33,820 --> 01:00:35,119
Niinpä he huomiotta loogisesti.

1232
01:00:35,119 --> 01:00:35,910
Ne ovat vain siellä.

1233
01:00:35,910 --> 01:00:39,830
>> Ja todellakin, CS50 IDE näyttää niitä
harmaa, koska ne ovat hyödyllisiä, mutta ei avain

1234
01:00:39,830 --> 01:00:41,000
ohjelmaan.

1235
01:00:41,000 --> 01:00:42,570
Huomaa mitä voit nyt tehdä.

1236
01:00:42,570 --> 01:00:44,950
Onko tiedät C
ohjelmointi tai ei,

1237
01:00:44,950 --> 01:00:47,722
voi vain seistä takaisin tähän
ohjelma, ja kuoria kommentteja.

1238
01:00:47,722 --> 01:00:50,180
Pyydä käyttäjä syöttää, varmista
saada merkkijono palautetaan merkkijono,

1239
01:00:50,180 --> 01:00:53,009
kerrata yli merkkiä s
yksi kerrallaan, tulostaa merkki

1240
01:00:53,009 --> 01:00:55,550
i: nnen merkin S-- et
edes tarvitse katsoa koodia

1241
01:00:55,550 --> 01:00:57,270
ymmärtää, mitä tämä ohjelma tekee.

1242
01:00:57,270 --> 01:01:00,280
Ja mikä vielä parempaa, jos itse näyttää
Tämän ohjelman viikon tai kaksi,

1243
01:01:00,280 --> 01:01:02,280
tai kuukauden tai vuoden,
tekin ei ole

1244
01:01:02,280 --> 01:01:04,420
tuijottaa koodia,
yrittää muistaa,

1245
01:01:04,420 --> 01:01:06,630
mitä minä yrittänyt tehdä tätä koodia?

1246
01:01:06,630 --> 01:01:07,770
>> Sinä olet kertonut itse.

1247
01:01:07,770 --> 01:01:11,660
Olet kuvattu sitä itse,
tai jotkut kollegansa, tai TA tai TF.

1248
01:01:11,660 --> 01:01:14,860
Ja niin tämä olisi nyt
oikea, ja hyvä muotoilu,

1249
01:01:14,860 --> 01:01:18,210
ja lopulta hyvä tyyli samoin.

1250
01:01:18,210 --> 01:01:19,990
Niin pitää tämä mielessä.

1251
01:01:19,990 --> 01:01:22,200
>> Joten on olemassa yksi muu
asia aion tehdä täällä

1252
01:01:22,200 --> 01:01:28,240
joka voi nyt paljastaa, mitä on
meneillään alla huppu.

1253
01:01:28,240 --> 01:01:30,390
Joten ei tätä ominaisuutta
C, ja muita kieliä,

1254
01:01:30,390 --> 01:01:33,010
kutsutaan tyypittely
että joko epäsuorasti

1255
01:01:33,010 --> 01:01:37,250
tai eksplisiittisesti voit muuntaa
yhdestä tietotyyppi toiseen.

1256
01:01:37,250 --> 01:01:39,800
Olemme tekemisissä niin
pitkälle tänään jousille.

1257
01:01:39,800 --> 01:01:41,250
>> Ja jouset ovat merkkejä.

1258
01:01:41,250 --> 01:01:44,910
Mutta muistaa viikosta
0, mitä merkkejä?

1259
01:01:44,910 --> 01:01:49,334
Merkit ovat vain abstraktio
päälle numbers-- desimaalin numeroita,

1260
01:01:49,334 --> 01:01:52,500
ja desimaaliluvuilla ovat todella vain
abstraktio päälle binääriluvut,

1261
01:01:52,500 --> 01:01:53,720
koska me määritelty sitä.

1262
01:01:53,720 --> 01:01:55,540
>> Joten merkit ovat numeroita.

1263
01:01:55,540 --> 01:01:58,410
Ja numerot ovat merkkejä,
vain asiayhteydestä riippuen.

1264
01:01:58,410 --> 01:02:01,250
Ja käy ilmi, että sisällä
tietokoneohjelman,

1265
01:02:01,250 --> 01:02:06,830
voit määrittää, miten haluat etsiä
at bitit sisällä kyseisen ohjelman?

1266
01:02:06,830 --> 01:02:10,400
>> Recall viikolla 0, että meillä oli
Ascii, joka on vain tämän koodin

1267
01:02:10,400 --> 01:02:11,620
kartoitus kirjeitä numeroita.

1268
01:02:11,620 --> 01:02:13,660
Ja sanoimme, pääoma A on 65.

1269
01:02:13,660 --> 01:02:15,860
Pääoma B on 66, ja niin edelleen.

1270
01:02:15,860 --> 01:02:20,500
>> Ja ilmoitus, meillä lähinnä on merkkiä siitä
ylärivin täällä, kuten C kutsuisi heitä,

1271
01:02:20,500 --> 01:02:23,400
merkkejä, ja sitten
ints toisella rivillä.

1272
01:02:23,400 --> 01:02:28,180
Ja se osoittautuu voit muuntaa
saumattomasti välillä, tyypillisesti.

1273
01:02:28,180 --> 01:02:30,042
Ja jos me haluamme tehdä
Tämän tarkoituksella, me

1274
01:02:30,042 --> 01:02:31,750
kannattaa puuttua
jotain tällaista.

1275
01:02:31,750 --> 01:02:33,590
>> Meidän kannattaa muuntaa
isoja alentaa

1276
01:02:33,590 --> 01:02:35,330
tapauksessa, tai pienet kirjaimet isoiksi.

1277
01:02:35,330 --> 01:02:38,000
Ja se osoittautuu siellä n
oikeastaan ​​kuvio täällä

1278
01:02:38,000 --> 01:02:39,900
voimme omaksua vain hetken.

1279
01:02:39,900 --> 01:02:44,120
Mutta Katsotaanpa ensin klo
Esimerkkinä Näin yksiselitteisesti.

1280
01:02:44,120 --> 01:02:46,340
>> Aion mennä takaisin CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Aion luoda
tiedosto nimeltä Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Ja aion mennä eteenpäin ja lisätä minun
standardi io.h huipulla, int main void

1283
01:02:55,960 --> 01:02:57,370
yläreunassa tehtäväni.

1284
01:02:57,370 --> 01:03:02,700
Ja sitten olen juuri menossa tekemään
following-- for-silmukka i on yhtä suuri kuin,

1285
01:03:02,700 --> 01:03:04,610
sanokaamme, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Ja sitten minä tulee olemaan pienempi kuin
65, plus 26 kirjaimia.

1287
01:03:10,460 --> 01:03:12,640
Joten minä anna tietokoneen
tehdä matematiikka minua siellä.

1288
01:03:12,640 --> 01:03:15,100
Ja sitten sisälle silmukan,
mitä olen menossa tulostaa?

1289
01:03:15,100 --> 01:03:19,230
>> % C on% i backslash n.

1290
01:03:19,230 --> 01:03:21,290
Ja nyt haluan kytkeä kaksi arvoa.

1291
01:03:21,290 --> 01:03:24,530
Olen tilapäisesti laittaa kysymyksen
merkitsee siellä kutsua kysymykseen.

1292
01:03:24,530 --> 01:03:29,940
>> Haluan kerrata 65 lähtien
26 kirjaimet,

1293
01:03:29,940 --> 01:03:35,190
tulostus pois jokaisen iteraation että
hahmon kiinteä vastaava.

1294
01:03:35,190 --> 01:03:38,299
Toisin sanoen, haluan
kerrata yli 26 numerot tulostus

1295
01:03:38,299 --> 01:03:41,590
mitä ASCII on, kirjain,
ja mitä vastaava määrä is--

1296
01:03:41,590 --> 01:03:44,650
oikeastaan ​​vain uudestaan
kaaviota että dia.

1297
01:03:44,650 --> 01:03:47,010
Joten mitä pitäisi nämä kysymysmerkkejä olla?

1298
01:03:47,010 --> 01:03:51,760
>> No, käy ilmi, että toinen
pitäisi olla vain muuttuja i.

1299
01:03:51,760 --> 01:03:53,860
Haluan nähdä, että lukuna.

1300
01:03:53,860 --> 01:03:58,920
Ja keskellä argumentti
täällä, voin kertoa tietokoneen

1301
01:03:58,920 --> 01:04:03,470
hoitoon että kokonaisluku
i kuten merkki, niin kuin

1302
01:04:03,470 --> 01:04:05,880
korvata sen tästä prosenttia C.

1303
01:04:05,880 --> 01:04:07,990
>> Toisin sanoen, jos minä,
ihmisen ohjelmoija, tietää

1304
01:04:07,990 --> 01:04:09,865
nämä ovat vain numeroita
päivän päätteeksi.

1305
01:04:09,865 --> 01:04:12,500
Ja tiedän, että 65 olisi
karttaa joitakin luonnetta.

1306
01:04:12,500 --> 01:04:15,310
Tämän nimenomaisen valettu,
jossa on suluissa,

1307
01:04:15,310 --> 01:04:18,840
nimi tietotyypin haluat
muuntaa, ja suljettu suluissa,

1308
01:04:18,840 --> 01:04:21,200
voit kertoa
tietokone, hei, tietokone,

1309
01:04:21,200 --> 01:04:24,130
muuntaa tämän kokonaisluku char.

1310
01:04:24,130 --> 01:04:26,250
>> Joten kun käytän tätä
Ohjelman jälkeen kokoamiseen,

1311
01:04:26,250 --> 01:04:29,740
katsotaanpa mitä minä get-- tehdä ASCII 0.

1312
01:04:29,740 --> 01:04:33,020
Hiivatti, mitä tein väärin täällä?

1313
01:04:33,020 --> 01:04:35,884
Käytä pimeän tunnisteen,
kunnossa, ei tahallinen,

1314
01:04:35,884 --> 01:04:37,800
mutta katsotaan, jos emme voi
Syy kautta.

1315
01:04:37,800 --> 01:04:41,220
>> Joten viiva five-- joten en saanut
kovin pitkälle ennen ruuvaamalla ylöspäin.

1316
01:04:41,220 --> 01:04:42,140
Se on okei.

1317
01:04:42,140 --> 01:04:46,560
Joten linja 5 i on yhtä kuin 65-- näen.

1318
01:04:46,560 --> 01:04:50,130
Niin muista, että C, toisin kuin jotkut
kieliä jos olet etukäteen ohjelmointi

1319
01:04:50,130 --> 01:04:52,190
kokemus, olet
kertoa tietokoneen,

1320
01:04:52,190 --> 01:04:55,040
toisin Scratch, mitä
tyyppinen muuttuja on.

1321
01:04:55,040 --> 01:04:56,860
>> Ja unohdin hokeman täällä.

1322
01:04:56,860 --> 01:04:59,200
Linjassa viisi, olen alkanut käyttää i.

1323
01:04:59,200 --> 01:05:01,560
Mutta en ole kertonut C
mitä tietotyyppi se on.

1324
01:05:01,560 --> 01:05:04,570
Joten aion mennä täällä ja
sanovat, ah, tee se kokonaisluku.

1325
01:05:04,570 --> 01:05:07,050
>> Nyt aion mennä eteenpäin ja kääntää.

1326
01:05:07,050 --> 01:05:08,080
Tämä kiinteänä.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Anna, joka on eräänlainen jäähtyä.

1328
01:05:12,660 --> 01:05:15,360
Ei vain se huippunopea
kysyä tietokone tätä kysymystä,

1329
01:05:15,360 --> 01:05:18,885
ennemmin kuin sen nyt dia,
se tulostaa yksi per rivi, A on 65,

1330
01:05:18,885 --> 01:05:24,860
B on 66, aina down-- koska olen
teki tämän 26 times-- kirjaimia z,

1331
01:05:24,860 --> 01:05:25,630
joka on 90.

1332
01:05:25,630 --> 01:05:27,790
Ja, itse asiassa, hieman
älykkäämpiä olisi

1333
01:05:27,790 --> 01:05:31,030
ovat olleet minulle ei luottaa
tietokoneen lisätä 26.

1334
01:05:31,030 --> 01:05:34,060
Voisin juuri tehneet
90 samoin, niin kauan

1335
01:05:34,060 --> 01:05:37,390
sillä en tee samaa virhettä kahdesti.

1336
01:05:37,390 --> 01:05:41,880
Haluan mennä läpi
z, ei vain läpi y.

1337
01:05:41,880 --> 01:05:44,000
>> Niin, että nimenomainen valettu.

1338
01:05:44,000 --> 01:05:47,860
Osoittautuu, että tämä
ei ole edes tarpeen.

1339
01:05:47,860 --> 01:05:52,480
Anna minun mennä eteenpäin ja uusintana tämän
kääntäjä, ja suorita ASCII 0.

1340
01:05:52,480 --> 01:05:54,940
On käynyt ilmi, että C on aika fiksu.

1341
01:05:54,940 --> 01:05:57,150
>> Ja printf, erityisesti,
on aika fiksu.

1342
01:05:57,150 --> 01:06:01,260
Jos vain läpäistävä i kahdesti
molemmille paikkamerkit, printf

1343
01:06:01,260 --> 01:06:04,510
huomaavat, oi, hyvin Tiedän
antoi minulle integer-- joitakin numero,

1344
01:06:04,510 --> 01:06:06,380
kuten 65, tai 90, tai mitä tahansa.

1345
01:06:06,380 --> 01:06:10,170
Mutta näen, että haluat minun
muotoilla että määrä kuin merkin.

1346
01:06:10,170 --> 01:06:16,460
Ja niin printf voi epäsuorasti heittää
Int char sinulle samoin.

1347
01:06:16,460 --> 01:06:19,360
Joten se ei ole ongelma lainkaan.

1348
01:06:19,360 --> 01:06:23,100
>> Mutta huomaa, koska tämä vastaavuus
voimme itse tehdä tämän myös.

1349
01:06:23,100 --> 01:06:26,520
Anna minun mennä eteenpäin ja tehdä yhden
muut versio this-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
Ja sen sijaan iteroimalla yli
kokonaislukuja, voi todella puhaltaa mieltäsi

1351
01:06:31,800 --> 01:06:33,610
iteroimalla yli merkkiä.

1352
01:06:33,610 --> 01:06:37,660
Jos char c saa pääomaa A, I
haluavat mennä eteenpäin ja tehdä tämän,

1353
01:06:37,660 --> 01:06:41,740
niin kauan kuin C on pienempi tai yhtä suuri kuin
pääoman Z. Ja jokaisen iteraation

1354
01:06:41,740 --> 01:06:45,690
Haluan kasvattaa C, voin
Nyt minun Printf linjan täällä

1355
01:06:45,690 --> 01:06:51,320
vaikkapa prosenttia C on
prosenttia uudelleen i, pilkku C.

1356
01:06:51,320 --> 01:06:57,200
>> Ja nyt, voin mennä toiseen suuntaan,
valu merkki nimenomaisesti

1357
01:06:57,200 --> 01:06:58,500
kokonaisluvuksi.

1358
01:06:58,500 --> 01:07:00,560
Joten jälleen, miksi teet tämän?

1359
01:07:00,560 --> 01:07:03,830
Se on vähän outo tavallaan
laskea kannalta merkkiä.

1360
01:07:03,830 --> 01:07:07,430
>> Mutta jos ymmärrät mitä
meneillään alla huppu,

1361
01:07:07,430 --> 01:07:08,430
siellä oikeastaan ​​mitään taikuutta.

1362
01:07:08,430 --> 01:07:13,060
Sinä vain sanoa, hei, tietokone antaa
minulle muuttuja nimeltä C tyypin char.

1363
01:07:13,060 --> 01:07:16,520
Alustaa sen pääoman A. And
huomaa heittomerkkeihin asia.

1364
01:07:16,520 --> 01:07:19,580
>> Sillä merkkejä C, muistan
viime viikolla, käytät heittomerkkien.

1365
01:07:19,580 --> 01:07:23,720
Jousille, sanoja,
lauseita, käytät lainausmerkkejä.

1366
01:07:23,720 --> 01:07:27,210
OK, tietokone, pitää tehdä tämä, niin
kunhan merkki on alle

1367
01:07:27,210 --> 01:07:28,050
tai yhtä suuri kuin z.

1368
01:07:28,050 --> 01:07:32,640
Ja tiedän ASCII taulukosta että kaikki
Näiden ASCII-koodit ovat vierekkäin.

1369
01:07:32,640 --> 01:07:33,400
>> Ei ole aukkoja.

1370
01:07:33,400 --> 01:07:36,737
Joten se on vain A-Z,
erottaa yksi numero kunkin.

1371
01:07:36,737 --> 01:07:38,820
Ja sitten voin kasvattaa
char, jos en todellakaan halua.

1372
01:07:38,820 --> 01:07:40,390
Päivän päätteeksi,
se on vain numero.

1373
01:07:40,390 --> 01:07:41,030
Tiedän tämän.

1374
01:07:41,030 --> 01:07:43,670
Voin siis vain olettaa lisätä 1 siihen.

1375
01:07:43,670 --> 01:07:46,940
>> Ja sitten tällä kertaa, voin tulostaa c,
ja sitten kiinteä vastaava.

1376
01:07:46,940 --> 01:07:50,170
Enkä edes tarvitse nimenomaista valettu.

1377
01:07:50,170 --> 01:07:52,680
Voin antaa printf ja
tietokone selvittää asioita,

1378
01:07:52,680 --> 01:07:57,300
niin että nyt jos juoksen
tehdä Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Saan täsmälleen sama asia kuin hyvin.

1380
01:08:01,520 --> 01:08:04,530
>> Hyödytön ohjelma, though-- kukaan
tulee todella kirjoittaa ohjelmisto

1381
01:08:04,530 --> 01:08:07,549
jotta selvittää, mikä oli
numero, joka kuvaa A, B, tai Z?

1382
01:08:07,549 --> 01:08:10,340
Olet juuri menossa googlettaa, tai
etsiä sen verkossa, tai etsi se

1383
01:08:10,340 --> 01:08:11,650
levyllä, tai vastaavalla.

1384
01:08:11,650 --> 01:08:13,520
Joten mistä tämä itse saada hyötyä?

1385
01:08:13,520 --> 01:08:15,960
>> No, puhutaan että
dia, huomaa siellä

1386
01:08:15,960 --> 01:08:20,890
todellinen kuvio täällä isojen
ja pienet joka ei ollut sattumaa.

1387
01:08:20,890 --> 01:08:23,760
Huomaa, että pääoma A on 65.

1388
01:08:23,760 --> 01:08:25,830
Lowercase a on 97.

1389
01:08:25,830 --> 01:08:29,649
Ja kuinka kaukana on alempi tapauksessa?

1390
01:08:29,649 --> 01:08:32,649
>> Joten 65 on, kuinka monta askeleen päässä 97?

1391
01:08:32,649 --> 01:08:36,210
Joten 97 miinus 65 on 32.

1392
01:08:36,210 --> 01:08:37,910
Joten pääoma a on 65.

1393
01:08:37,910 --> 01:08:39,939
Jos lisäät 32 että,
saat pienet kirjaimet a.

1394
01:08:39,939 --> 01:08:43,729
Ja vastaavasti, jos vähennä 32,
saat takaisin pääomaa A-- sama B

1395
01:08:43,729 --> 01:08:46,380
pikku b, iso C pikku c.

1396
01:08:46,380 --> 01:08:50,670
>> Kaikki nämä puutteet ovat 32 toisistaan.

1397
01:08:50,670 --> 01:08:54,450
Nyt tämä näyttäisi jotta voisimme
tehdä jotain Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
tai Google Docs ominaisuus, jossa
voi valita kaiken ja sitten sanoa,

1399
01:08:57,729 --> 01:09:00,520
muuttaa kaikki pieniksi, tai
muuttaa kaikki isoiksi,

1400
01:09:00,520 --> 01:09:03,840
tai muuttaa vain ensimmäinen sana
lauseen isoiksi.

1401
01:09:03,840 --> 01:09:07,390
Voimme todella tehdä jotain
niin itse.

1402
01:09:07,390 --> 01:09:12,645
>> Anna minun mennä eteenpäin ja tallentaa tiedostoa
tässä kutsutaan hyödyntää 0.c.

1403
01:09:12,645 --> 01:09:15,770
Ja mennään eteenpäin ja lietsoa ohjelma
että juuri näin seuraavasti.

1404
01:09:15,770 --> 01:09:18,460
Joten sisältävät CS50 kirjasto.

1405
01:09:18,460 --> 01:09:21,430
Ja kuuluu vakio I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Ja tiedän tämä on tulossa pian.

1407
01:09:22,787 --> 01:09:24,870
Joten aion laittaa sen
siellä jo, string.h,

1408
01:09:24,870 --> 01:09:26,960
joten Olen pääsy
asioita, kuten Stirling,

1409
01:09:26,960 --> 01:09:29,620
ja sitten int main mitätön, kuten tavallista.

1410
01:09:29,620 --> 01:09:33,420
Ja sitten aion mennä eteenpäin
ja tehdä jouset saa päästä string,

1411
01:09:33,420 --> 01:09:35,032
vain saada merkkijonon käyttäjältä.

1412
01:09:35,032 --> 01:09:36,740
Ja sitten aion
teen järki tarkistaa.

1413
01:09:36,740 --> 01:09:40,510
Jos jono ei ole sama null,
niin se on turvallista jatkaa.

1414
01:09:40,510 --> 01:09:42,000
Ja mitä haluan tehdä?

1415
01:09:42,000 --> 01:09:48,700
Aion kerrata välillä i on yhtä suuri kuin 0,
ja n asti merkkijonon pituus s.

1416
01:09:48,700 --> 01:09:51,899
>> Ja aion tehdä niin kauan kuin
i on pienempi kuin n, ja i plus plus.

1417
01:09:51,899 --> 01:09:55,060
Toistaiseksi olen oikeastaan ​​vain
lainanotto ideoita ennen.

1418
01:09:55,060 --> 01:09:57,010
Ja nyt aion esitellä haara.

1419
01:09:57,010 --> 01:09:59,635
>> Joten muistelen Scratch, missä
meillä oli nuo haarautuu tie,

1420
01:09:59,635 --> 01:10:05,110
ja viime viikolla C. aion
sanoa, jos i: nnen hahmo s

1421
01:10:05,110 --> 01:10:09,250
on suurempi tai
yhtäläinen alentaa tapauksessa,

1422
01:10:09,250 --> 01:10:13,340
and-- Scratch olisit kirjaimellisesti
sanoa ja, mutta C sanot et-merkki,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- ja i: nnen merkki s
on pienempi tai yhtä suuri kuin alempi tapauksessa z,

1424
01:10:19,830 --> 01:10:21,780
Tehdään jotain mielenkiintoista.

1425
01:10:21,780 --> 01:10:27,020
Katsotaan todella tulostaa
merkki ilman rivinvaihto

1426
01:10:27,020 --> 01:10:31,760
että on merkin merkkijono,
i: nnen merkin merkkijonon.

1427
01:10:31,760 --> 01:10:37,420
>> Mutta mennään eteenpäin ja
vähennä 32 siitä.

1428
01:10:37,420 --> 01:10:42,120
Else jos hahmo
merkkijonon etsimme

1429
01:10:42,120 --> 01:10:45,950
ei välillä pikku
ja pikku z, mennä eteenpäin

1430
01:10:45,950 --> 01:10:48,610
ja vain tulostaa sen ulos muuttumattomana.

1431
01:10:48,610 --> 01:10:50,840
Niinpä olemme ottaneet käyttöön
Tämän haarukoitua merkintätapa

1432
01:10:50,840 --> 01:10:53,560
meidän jousille saada aikaa
i: nnen merkin merkkijonon.

1433
01:10:53,560 --> 01:10:57,520
>> Olen lisännyt joitakin ehdollinen logiikka, kuten
Scratch viime viikon viikolla yksi, jossa

1434
01:10:57,520 --> 01:10:59,880
Olen vain käyttää minun perustavanlaatuinen
käsitys siitä, mitä on

1435
01:10:59,880 --> 01:11:01,130
meneillään alla huppu.

1436
01:11:01,130 --> 01:11:04,190
On i: nnen luonne s
suurempi tai yhtä suuri kuin?

1437
01:11:04,190 --> 01:11:08,290
Kuten, on se 97 tai 98,
tai 99, ja niin edelleen?

1438
01:11:08,290 --> 01:11:11,940
>> Mutta se on myös pienempi tai yhtä suuri kuin
arvoon pieniä z?

1439
01:11:11,940 --> 01:11:16,210
Ja jos on, mitä tämä linja tarkoittaa?

1440
01:11:16,210 --> 01:11:20,250
14, tämä on tavallaan
alkiot koko ajatus,

1441
01:11:20,250 --> 01:11:23,840
isolla kirje
yksinkertaisesti vähentämällä 32 siitä,

1442
01:11:23,840 --> 01:11:29,370
Tässä tapauksessa, koska tiedän, per se
kaavio, miten omat numerot ovat edustettuina.

1443
01:11:29,370 --> 01:11:33,925
Joten mene eteenpäin ja suorittaa tämän,
jälkeen kootaan hyödyntää 0.c,

1444
01:11:33,925 --> 01:11:36,210
ja ajaa isolla 0.

1445
01:11:36,210 --> 01:11:40,300
>> Katsotaan kirjoita jotain
Zamyla in pienillä tulevat.

1446
01:11:40,300 --> 01:11:42,780
Ja nyt meillä on Zamyla isoilla.

1447
01:11:42,780 --> 01:11:45,050
Katsotaan kirjoita Rob pienillä.

1448
01:11:45,050 --> 01:11:46,674
Yritetään Jason pienillä.

1449
01:11:46,674 --> 01:11:48,590
Ja pidämme saada
pakko-arvo.

1450
01:11:48,590 --> 01:11:50,960
On pieni vika, että olen
Tällainen ei ennakoida.

1451
01:11:50,960 --> 01:11:54,050
Huomatkaa uusi nopea päätyy
samalla rivillä kuin heidän nimensä,

1452
01:11:54,050 --> 01:11:55,520
joka tuntuu hieman sotkuinen.

1453
01:11:55,520 --> 01:11:59,170
>> Joten aion mennä täällä, ja
todella lopussa tämän ohjelman

1454
01:11:59,170 --> 01:12:02,110
tulostaa Rivinvaihtomerkkiä.

1455
01:12:02,110 --> 01:12:03,160
Siinä kaikki.

1456
01:12:03,160 --> 01:12:06,120
Kanssa printf, sinun ei tarvitse
pass muuttujia tai muodossa koodin.

1457
01:12:06,120 --> 01:12:08,460
Voit kirjaimellisesti vain tulostaa
jotain rivinvaihto.

1458
01:12:08,460 --> 01:12:13,529
>> Joten mene eteenpäin ja tehdä
hyötymään 0 jälleen, uusintana se, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Ja nyt se on hieman kauniimpi.

1460
01:12:14,820 --> 01:12:17,274
Nyt minun nopea on omalla uuden rivin.

1461
01:12:17,274 --> 01:12:18,440
Niin, että kaikki hyvä ja hieno.

1462
01:12:18,440 --> 01:12:19,910
Niin se on hyvä esimerkki.

1463
01:12:19,910 --> 01:12:22,700
Mutta en edes välttämättä
täytyy kovaa koodia 32.

1464
01:12:22,700 --> 01:12:23,350
Tiedätkö mitä?

1465
01:12:23,350 --> 01:12:26,350
Voisin say-- en koskaan
muistaa, mikä ero on.

1466
01:12:26,350 --> 01:12:29,330
>> Mutta tiedän, että jos olen
on pientä,

1467
01:12:29,330 --> 01:12:34,430
En olennaisesti halua vähentää pois
riippumatta etäisyys vaihtelee hieman

1468
01:12:34,430 --> 01:12:39,160
A ja iso, sillä jos oletan, että
kaikki muut kirjaimet ovat samat,

1469
01:12:39,160 --> 01:12:41,045
että pitäisi saada työtä tehnyt.

1470
01:12:41,045 --> 01:12:42,670
Mutta sen sijaan tehdä sitä, tiedätkö mitä?

1471
01:12:42,670 --> 01:12:44,240
On toinenkin tapa edelleen.

1472
01:12:44,240 --> 01:12:48,090
>> Jos tämä on hyödyntää 1.c-- jos olisin
esittää, että erilliseen tiedostoon.

1473
01:12:48,090 --> 01:12:51,030
Tehdään hyödyntää 2.c seuraavasti.

1474
01:12:51,030 --> 01:12:53,060
Aion todella puhdista täällä.

1475
01:12:53,060 --> 01:12:57,420
Ja sen sijaan, että edes
tietää tai välitä niistä alhainen

1476
01:12:57,420 --> 01:13:01,090
toteutuksen yksityiskohdat, olen sen sijaan
juuri menossa tulostaa merkin,

1477
01:13:01,090 --> 01:13:04,610
lainaus lainaus, prosenttia C, ja
soita toinen toiminto,

1478
01:13:04,610 --> 01:13:09,950
olemassa joka vie argumentti,
joka on luonteeltaan, kuten tämä.

1479
01:13:09,950 --> 01:13:12,630
>> On käynyt ilmi C, siellä
toinen toiminto puhelun

1480
01:13:12,630 --> 01:13:15,550
ylä-, joka nimensä
ehdottaa vie hahmo

1481
01:13:15,550 --> 01:13:19,350
ja tekee sen isoiksi
vastaava, ja sitten palauttaa sen

1482
01:13:19,350 --> 01:13:21,410
jotta printf voi ampua sitä siellä.

1483
01:13:21,410 --> 01:13:25,484
Ja niin tehdä tämän, vaikka olen
otettava käyttöön yksi muu tiedosto.

1484
01:13:25,484 --> 01:13:28,400
On käynyt ilmi, on olemassa toinen tiedosto
että te vain tietää luokasta,

1485
01:13:28,400 --> 01:13:33,020
tai oppikirja tai online
viite, jota kutsutaan C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Jos siis lisätä, että kesken minun header
tiedostoja, ja nyt uudelleen kääntää ohjelman,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Katsotaan kirjoita Zamyla kaikissa
pieniä, toimii edelleen sama.

1489
01:13:46,690 --> 01:13:48,040
Mutta tiedätkö mitä?

1490
01:13:48,040 --> 01:13:55,590
On käynyt ilmi, että ylemmän
on joitakin muita toimintoja.

1491
01:13:55,590 --> 01:13:58,410
>> Ja haluan esitellä tämän
komento täällä, tavallaan kangerrellen

1492
01:13:58,410 --> 01:14:00,250
nimeltään, mutta ihminen manuaaliseen.

1493
01:14:00,250 --> 01:14:03,960
On käynyt ilmi, että useimmat Linux-tietokoneet,
koska käytämme here-- Linux-käyttöjärjestelmä

1494
01:14:03,960 --> 01:14:06,270
system-- hallitse
nimeltään mies, joka sanoo,

1495
01:14:06,270 --> 01:14:08,530
hei, tietokone, anna minulle
tietokoneen käsikirja.

1496
01:14:08,530 --> 01:14:10,680
Mitä haluat
etsiä että opasta?

1497
01:14:10,680 --> 01:14:13,840
>> Haluan etsiä toiminnon
kutsuttu ylempi, Enter.

1498
01:14:13,840 --> 01:14:16,070
Ja se on hieman arvoituksellisesti
lukea joskus.

1499
01:14:16,070 --> 01:14:18,780
Mutta huomaa me olemme
Linux ohjelmoijan käsikirja.

1500
01:14:18,780 --> 01:14:19,530
Ja kaikki teksti.

1501
01:14:19,530 --> 01:14:21,905
Ja huomaa, että siellä on
toiminnon nimi täällä.

1502
01:14:21,905 --> 01:14:25,030
On käynyt ilmi siinä on serkku nimeltään
alentaa, mikä tekee päinvastoin.

1503
01:14:25,030 --> 01:14:29,710
Ja ilmoituksen alle synopsis, käyttää tätä
toimivat miehen sivun, niin sanotusti,

1504
01:14:29,710 --> 01:14:32,220
kertoo minulle, että minä
täytyy sisällyttää c type.h.

1505
01:14:32,220 --> 01:14:33,630
Ja tiesin, että käytäntöön.

1506
01:14:33,630 --> 01:14:36,210
>> Täällä, se osoitti minulle kaksi
prototyyppejä toiminto,

1507
01:14:36,210 --> 01:14:39,070
niin että jos joskus haluat käyttää tätä
En tiedä, mitä he ottaa syötteenä

1508
01:14:39,070 --> 01:14:40,652
ja mitä he palaavat tuotokseksi.

1509
01:14:40,652 --> 01:14:42,360
Ja sitten jos luen
kuvausta, näen

1510
01:14:42,360 --> 01:14:44,820
tarkemmin mitä toiminto tekee.

1511
01:14:44,820 --> 01:14:48,100
Mutta vielä tärkeämpää, jos
Odotan alle tuottoarvo,

1512
01:14:48,100 --> 01:14:51,710
se sanoo palautettu arvo on
vaihdettavien kirjeen,

1513
01:14:51,710 --> 01:14:57,880
tai C, alkuperäisen tulo, jos
muuntaminen ei ollut mahdollista.

1514
01:14:57,880 --> 01:15:01,992
>> Toisin sanoen ylempi yrittää
muuntaa kirjeen isoiksi.

1515
01:15:01,992 --> 01:15:03,450
Ja jos on, se tulee palauttaa sen.

1516
01:15:03,450 --> 01:15:07,010
Mutta jos se ei voi jostain reason--
ehkä se on jo isoiksi,

1517
01:15:07,010 --> 01:15:09,550
ehkä se on huutomerkki
tai jokin muu punctuation--

1518
01:15:09,550 --> 01:15:12,200
se juuri menossa
palauttaa alkuperäisen C,

1519
01:15:12,200 --> 01:15:17,340
mikä tarkoittaa, että voin tehdä minun koodi
parempi rakenne on seuraavanlainen.

1520
01:15:17,340 --> 01:15:20,580
>> En tarvitse kaikkia
nämä hiton riviä koodia.

1521
01:15:20,580 --> 01:15:22,610
Kaikki linjat olen
vain korosti voi

1522
01:15:22,610 --> 01:15:28,700
luhistuneilta osaksi vain yksi yksinkertainen
linja, joka on this-- printf prosenttia

1523
01:15:28,700 --> 01:15:33,510
c ylempään S kiinnikkeen i.

1524
01:15:33,510 --> 01:15:36,090
Ja tämä olisi
Esimerkkinä paremman suunnittelun.

1525
01:15:36,090 --> 01:15:40,040
>> Miksi toteuttaa 7 tai 8 riviä
koodia, mitä se oli Sain

1526
01:15:40,040 --> 01:15:44,960
poistetaan, kun voit sen sijaan romahtaa
kaikki tämä logiikka ja päätöksenteko

1527
01:15:44,960 --> 01:15:49,620
yhdeksi linja, 13 nyt, että
tukeutuu kirjasto function--

1528
01:15:49,620 --> 01:15:53,430
toiminnon, joka tulee C, mutta se
tekee mitä haluat sen tehdä.

1529
01:15:53,430 --> 01:15:55,295
Ja rehellisesti, vaikka
se ei tullut C,

1530
01:15:55,295 --> 01:15:58,880
voit toteuttaa sen itse, koska
olemme nähneet, jossa saat negatiivinen int

1531
01:15:58,880 --> 01:16:01,700
ja saada positiivinen int viime viikolla samoin.

1532
01:16:01,700 --> 01:16:03,470
>> Tämä koodi on nyt paljon enemmän luettavissa.

1533
01:16:03,470 --> 01:16:06,670
Ja todellakin, jos selaa ylöspäin,
katso kuinka paljon kompaktimpi

1534
01:16:06,670 --> 01:16:08,360
Tämä versio minun ohjelma on.

1535
01:16:08,360 --> 01:16:11,230
Se on vähän ylhäältä raskas nyt,
kaikki nämä kuuluvat.

1536
01:16:11,230 --> 01:16:14,380
Mutta se on OK, koska nyt seison
harteille ohjelmoijat

1537
01:16:14,380 --> 01:16:15,300
ennen minua.

1538
01:16:15,300 --> 01:16:18,440
Ja joka se oli joka
toteutetaan ylempi todella

1539
01:16:18,440 --> 01:16:21,470
teki minulle palveluksen, aivan kuten kuka
täytäntöön Stirling todella

1540
01:16:21,470 --> 01:16:24,790
teki minulle palveluksen jokin aika sitten.

1541
01:16:24,790 --> 01:16:26,970
Ja niin nyt meillä on
parempi suunnitteluohjelma

1542
01:16:26,970 --> 01:16:31,680
joka toteuttaa täsmälleen samaa logiikkaa.

1543
01:16:31,680 --> 01:16:35,580
>> Puhuminen Stirling, anna
minun mennä eteenpäin ja tehdä tätä.

1544
01:16:35,580 --> 01:16:38,320
Anna minun mennä eteenpäin ja tallenna
tämä kuva stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Ja se osoittautuu, voimme kuoria takaisin
yksi toinen kerros melko yksinkertaisesti nyt.

1546
01:16:43,255 --> 01:16:45,630
Aion mennä eteenpäin ja piiska
up toinen ohjelma main

1547
01:16:45,630 --> 01:16:49,759
tässä että yksinkertaisesti uudelleen työkoneiden
merkkijonon pituus seuraavasti.

1548
01:16:49,759 --> 01:16:52,300
Joten tässä on koodiriviä että
saa minut merkkijono käyttäjältä.

1549
01:16:52,300 --> 01:16:53,910
Pidämme käyttämällä tätä uudestaan ​​ja uudestaan.

1550
01:16:53,910 --> 01:16:58,900
Annan itselleni muuttuja nimeltä
n tyyppiä int, joka tallentaa useita.

1551
01:16:58,900 --> 01:17:02,490
>> Ja anna minun mennä eteenpäin ja
tee seuraava logiikka.

1552
01:17:02,490 --> 01:17:15,610
Vaikka nnen hahmo s tekee
erisuuri backslash 0, mennä eteenpäin

1553
01:17:15,610 --> 01:17:17,930
ja kasvu n.

1554
01:17:17,930 --> 01:17:23,506
Ja sitten tulostaa printf prosenttia i n.

1555
01:17:23,506 --> 01:17:29,200
Väitän, että tämä ohjelma täällä,
käymättä merkkijonon pituus,

1556
01:17:29,200 --> 01:17:31,150
keksii pituus merkkijono.

1557
01:17:31,150 --> 01:17:34,600
>> Ja taika on täysin
kapseloitu linja 8

1558
01:17:34,600 --> 01:17:39,830
täällä mitä näyttää uudet syntaksin,
Tämän kenoviiva 0 heittomerkkeihin.

1559
01:17:39,830 --> 01:17:41,360
Mutta miksi?

1560
01:17:41,360 --> 01:17:44,100
No, miettiä, mitä on ollut
jatkunut koko tämän ajan.

1561
01:17:44,100 --> 01:17:47,990
>> Ja Sivuhuomautuksena ennen kuin unohdan, ymmärtää
myös, että sen lisäksi, että ihminen sivuille

1562
01:17:47,990 --> 01:17:50,920
jotka tulevat tyypillinen
Linux-järjestelmän kuten CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
ymmärtää, että me,
kurssin henkilökunta, on myös

1564
01:17:53,770 --> 01:17:56,030
teki verkkosivusto versio
Tämän saman ajatuksen nimeltään

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, joka on
kaikki nämä samassa man-sivuja,

1566
01:17:59,940 --> 01:18:02,020
kaikki saman
dokumentointi, sekä

1567
01:18:02,020 --> 01:18:05,730
pieni laatikko huipulla, joka mahdollistaa
voit muuntaa kaikki melko

1568
01:18:05,730 --> 01:18:09,025
arcane Kielestä vähemmän mukavaksi
tilassa, jossa, opetushenkilöstön,

1569
01:18:09,025 --> 01:18:12,150
ovat menneet läpi ja pyrkinyt yksinkertaistamaan
jotkut kielen pitää asiat

1570
01:18:12,150 --> 01:18:14,830
keskittyi ajatuksia, eikä
joitakin teknisiä.

1571
01:18:14,830 --> 01:18:20,070
Joten pitää mielessä, reference.cs50.net
kuin toinen resurssi samoin.

1572
01:18:20,070 --> 01:18:23,800
>> Mutta miksi merkkijonon pituus työtä
Muuten olen ehdottanut hetki sitten?

1573
01:18:23,800 --> 01:18:25,160
Tässä Zamyla nimi uudelleen.

1574
01:18:25,160 --> 01:18:27,690
Ja tässä Zamyla nimi
boxed, kuten minä pitää tehdä,

1575
01:18:27,690 --> 01:18:31,360
maalata kuvan siitä että,
oikeastaan ​​vain merkkijono.

1576
01:18:31,360 --> 01:18:34,260
Mutta Zamyla ei ole olemassa
eristyksissä ohjelmassa.

1577
01:18:34,260 --> 01:18:37,420
>> Kun kirjoittaa ja käynnistää ohjelman
käytät Mac tai PC

1578
01:18:37,420 --> 01:18:40,010
muistin tai RAM niin sanotusti.

1579
01:18:40,010 --> 01:18:42,620
Ja voit ajatella
tietokoneen olevan

1580
01:18:42,620 --> 01:18:44,730
paljon gigatavua muistia näinä päivinä.

1581
01:18:44,730 --> 01:18:47,700
Ja keikka tarkoittaa miljardeja,
joten miljardeja tavua.

1582
01:18:47,700 --> 01:18:48,910
>> Mutta katsotaan taaksepäin ajassa.

1583
01:18:48,910 --> 01:18:51,530
Ja olettaa, että käytämme
todella vanha tietokone, joka

1584
01:18:51,530 --> 01:18:55,150
vain 32 tavua muistia.

1585
01:18:55,150 --> 01:18:59,310
Voisin, minun tietokoneen näytöllä,
yksinkertaisesti vetää tätä seuraavasti.

1586
01:18:59,310 --> 01:19:05,240
>> Voisin vain sanoa, että
tietokone on kaikki tämä muisti.

1587
01:19:05,240 --> 01:19:08,830
Ja tämä on kuin tikku muistia, jos
muistatte meidän kuva edellisen kerran.

1588
01:19:08,830 --> 01:19:11,670
Ja jos vain jakaa
tätä riittävän monta kertaa,

1589
01:19:11,670 --> 01:19:15,040
Väitän, että minulla on 32 tavua
muistin ruudulla.

1590
01:19:15,040 --> 01:19:18,239
>> Nyt todellisuudessa, voin vain
piirtää toistaiseksi tällä näytöllä täällä.

1591
01:19:18,239 --> 01:19:20,280
Joten aion mennä eteenpäin,
ja vain sopimuksen mukaan,

1592
01:19:20,280 --> 01:19:24,050
kiinnittää tietokoneeni muistissa
ruudukko, eikä vain yksi suora viiva.

1593
01:19:24,050 --> 01:19:28,190
Erityisesti Väitän nyt
ruudukkoon, tämä 8 4 ruudukko,

1594
01:19:28,190 --> 01:19:31,800
vain edustaa kaikkia 32 tavua
muistia saatavilla Mac,

1595
01:19:31,800 --> 01:19:33,030
tai saatavilla tietokoneeseen.

1596
01:19:33,030 --> 01:19:34,780
Ja he kääre
on kaksi riviä, vain

1597
01:19:34,780 --> 01:19:38,030
koska se sopii paremmin ruudulle.

1598
01:19:38,030 --> 01:19:40,800
Mutta tämä on ensimmäinen tavu.

1599
01:19:40,800 --> 01:19:41,990
Tämä on toinen tavu.

1600
01:19:41,990 --> 01:19:43,300
Tämä on kolmas tavu.

1601
01:19:43,300 --> 01:19:45,310
>> Ja tämä on 32. tavu.

1602
01:19:45,310 --> 01:19:52,910
Tai, jos ajattelemme kuin tietokone
tutkija, tämä on tavu 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Joten sinun täytyy 0-31, jos
te alkaa laskea 0.

1604
01:19:55,950 --> 01:19:59,830
>> Jos siis käyttää ohjelmaa
että puhelut saavat merkkijono,

1605
01:19:59,830 --> 01:20:05,280
ja saamme merkkijono ihmisen
kuten tein kutsutaan Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
miten maailmassa tekee
tietokone seurata joka tavun,

1607
01:20:09,430 --> 01:20:12,230
joka kimpale muistia,
kuuluu mihinkin merkkijono?

1608
01:20:12,230 --> 01:20:16,270
Toisin sanoen, jos siirrymme
Kirjoita toinen nimi tietokoneeseen,

1609
01:20:16,270 --> 01:20:19,890
näin Andi kutsuen
saada merkkijono toisen kerran,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I on päätyä
tietokoneen muistiin samoin.

1611
01:20:23,030 --> 01:20:23,850
Mutta miten?

1612
01:20:23,850 --> 01:20:29,700
>> No, käy ilmi, että alla
huppu, mitä C tekee säilytettäessä jouset

1613
01:20:29,700 --> 01:20:35,080
että ihmisen tyypit, tai että
tulevat muusta lähteestä, on se

1614
01:20:35,080 --> 01:20:39,190
rajataan lopussa niitä
erityinen character-- kenoviiva

1615
01:20:39,190 --> 01:20:44,750
0, joka on vain erityinen tapa
sanomalla 80 bittiä peräkkäin.

1616
01:20:44,750 --> 01:20:47,950
>> Joten A-- tämä on numero 97 muistaa.

1617
01:20:47,950 --> 01:20:51,770
Siksi jotkut kuvio 8 bittiä
edustaa desimaaliluku 97.

1618
01:20:51,770 --> 01:20:58,070
Tämä kenoviiva 0 on kirjaimellisesti määrä
0, alias nul, N-U-L, toisin kuin aikaisemmin,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, joka puhuttiin.

1620
01:20:59,630 --> 01:21:05,700
Mutta nyt, vain tietää, että tämä
kenoviiva 0 on vain 80 bittiä peräkkäin.

1621
01:21:05,700 --> 01:21:09,810
>> Ja se on vain tämä rivi
hiekka, joka sanoo mitään vasemmalle

1622
01:21:09,810 --> 01:21:12,610
kuuluu yksi merkkijono, tai yksi tietotyyppi.

1623
01:21:12,610 --> 01:21:15,480
Ja kaiken oikealla
kuuluu jotain muuta.

1624
01:21:15,480 --> 01:21:17,440
Andi nimi puolestaan
joka vain visuaalisesti

1625
01:21:17,440 --> 01:21:21,310
sattuu kääriä kiinni toisella linjalla,
mutta se on vain esteettinen yksityiskohta,

1626
01:21:21,310 --> 01:21:23,990
Samoin on NUL lopetetaan.

1627
01:21:23,990 --> 01:21:29,290
>> Se on merkkijono A-N-D-I merkkejä,
plus viidesosa salainen luonne,

1628
01:21:29,290 --> 01:21:33,560
kaikki 0 bitit, että vain rajataan
lopussa Andi nimi samoin.

1629
01:21:33,560 --> 01:21:37,120
Ja jos me kutsumme saada merkkijono kolmannen kerran
tietokone saada kielen kaltaisen

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, samoin on Marian
name nul lopetettiin kenoviivaan 0.

1631
01:21:44,210 --> 01:21:47,170
>> Tämä on täysin erilainen
siitä, miten tietokone tyypillisesti

1632
01:21:47,170 --> 01:21:51,850
tallentaa kokonaisluku tai float, tai muita
tietotyypit edelleen, koska muistaa,

1633
01:21:51,850 --> 01:21:57,420
kokonaisluku on yleensä 32 bittiä, tai
4 tavua, tai ehkä jopa 64 bittiä,

1634
01:21:57,420 --> 01:21:59,100
tai kahdeksan tavua.

1635
01:21:59,100 --> 01:22:02,620
Mutta monet primitives tietokoneella
ohjelmointikielellä

1636
01:22:02,620 --> 01:22:05,550
on kiinteä määrä
tavua alla hood--

1637
01:22:05,550 --> 01:22:08,100
ehkä 1, ehkä 2, ehkä 4, ehkä 8.

1638
01:22:08,100 --> 01:22:13,250
>> Mutta jouset, jonka muotoilu, on
dynaaminen määrän merkkejä.

1639
01:22:13,250 --> 01:22:16,980
Et tiedä etukäteen, kunnes
Ihmisen tyypit Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
tai M-A-R-I-A tai A-N-D-I. Et tiedä
kuinka monta kertaa käyttäjä tulee iskemään

1641
01:22:21,400 --> 01:22:22,070
näppäimistö.

1642
01:22:22,070 --> 01:22:26,490
Siksi et tiedä miten
monta merkkiä etukäteen

1643
01:22:26,490 --> 01:22:27,540
olet menossa tarvitsevat.

1644
01:22:27,540 --> 01:22:31,840
>> Ja niin C juuri sellainen lähtee kuin
salainen linkkipolku alla huppu

1645
01:22:31,840 --> 01:22:32,960
lopussa merkkijonon.

1646
01:22:32,960 --> 01:22:39,280
Tallennettuasi Z-A-M-Y-L-A muistiin,
se myös vain asettaa vastaava

1647
01:22:39,280 --> 01:22:40,210
ajanjaksolta.

1648
01:22:40,210 --> 01:22:45,060
Lopussa lauseen,
se asettaa 80 bittiä, niin kuin

1649
01:22:45,060 --> 01:22:49,120
muistaa, missä
Zamyla alkaa ja loppuu.

1650
01:22:49,120 --> 01:22:51,490
>> Mikä siis yhteys,
Sitten, tämän ohjelman?

1651
01:22:51,490 --> 01:22:55,190
Tämä ohjelma täällä, Stirling,
on yksinkertaisesti mekanismi

1652
01:22:55,190 --> 01:22:57,970
saada merkkijono
käyttäjältä, rivi 6.

1653
01:22:57,970 --> 01:23:01,160
Linja 7, julistan muuttuja
nimeltään n ja aseta se yhtä suuri kuin 0.

1654
01:23:01,160 --> 01:23:08,680
>> Ja sitten linjassa 8, en yksinkertaisesti pyytänyt
kysymys, kun taas n: nnen merkki ei

1655
01:23:08,680 --> 01:23:12,120
erisuuri kaikki 0 bits--
Toisin sanoen, ei ole

1656
01:23:12,120 --> 01:23:14,500
yhtäläiset tämä erityinen
merkki, kenoviivan 0, joka

1657
01:23:14,500 --> 01:23:18,470
oli vain, että erityistä nul character--
mennä eteenpäin ja vain kasvattaa n.

1658
01:23:18,470 --> 01:23:21,460
>> Ja pitää tehdä se, ja pitää
tee sitä, ja pitää tehdä se.

1659
01:23:21,460 --> 01:23:23,430
Ja niin vaikka
Aiemmin olemme käyttäneet i,

1660
01:23:23,430 --> 01:23:25,181
se on täysin kunnossa
semanttisesti käyttää n,

1661
01:23:25,181 --> 01:23:27,430
jos olet vain yrittää
laskea tällä kertaa tarkoituksella,

1662
01:23:27,430 --> 01:23:28,720
ja haluavat vain kutsua sitä n.

1663
01:23:28,720 --> 01:23:34,720
Joten tämä vain pitää kysyvät,
on n: nnen luonne on kaikki 0s?

1664
01:23:34,720 --> 01:23:38,470
Jos ei, katso seuraavaan ilmeen,
katso seuraavaan, katso seuraavaan,

1665
01:23:38,470 --> 01:23:39,460
katso seuraavaan.

1666
01:23:39,460 --> 01:23:45,540
>> Mutta heti kun näet backslash 0,
Tämän loop-- linjan 9 kautta 11-- pysähtyy.

1667
01:23:45,540 --> 01:23:49,640
Rikot ulos samalla silmukka,
jättäen sisällä että muuttujan n

1668
01:23:49,640 --> 01:23:54,530
yhteen laskettu kaikkien
merkkejä merkkijonon näit,

1669
01:23:54,530 --> 01:23:55,660
siten tulostamalla.

1670
01:23:55,660 --> 01:23:56,760
Joten kokeile tätä.

1671
01:23:56,760 --> 01:23:59,500
>> Anna minun mennä eteenpäin ja ilman
käyttämällä Stirling toimintoa,

1672
01:23:59,500 --> 01:24:04,240
mutta vain käyttämällä omaa paljasjalkainen versio
tässä kutsutaan Stirling, anna minun mennä eteenpäin

1673
01:24:04,240 --> 01:24:07,700
ja ajaa Stirling, kirjoita jotain
kuten Zamyla, jonka tiedän etukäteen

1674
01:24:07,700 --> 01:24:08,670
on kuusi merkkiä.

1675
01:24:08,670 --> 01:24:10,080
Katsotaan, se toimii.

1676
01:24:10,080 --> 01:24:10,920
Itse asiassa se on kuusi.

1677
01:24:10,920 --> 01:24:15,257
Yritetään Rob kolme merkkiä,
kolme merkkiä samoin, ja niin edelleen.

1678
01:24:15,257 --> 01:24:17,340
Niin, että kaikki se menee
on alla huppu.

1679
01:24:17,340 --> 01:24:19,548
Ja huomaa yhteydet,
Sitten, jossa ensimmäisellä viikolla

1680
01:24:19,548 --> 01:24:22,370
luokan, jossa puhuimme
jotain abstraktio,

1681
01:24:22,370 --> 01:24:26,960
joka on juuri tämä Kerrostaa ideoita, tai
monimutkaisuus, päälle perusperiaatteista.

1682
01:24:26,960 --> 01:24:30,710
Täällä, me tavallaan etsivät
alla huppu Stirling,

1683
01:24:30,710 --> 01:24:33,510
niin sanotusti selvittää,
miten se voidaan toteuttaa?

1684
01:24:33,510 --> 01:24:35,232
>> Ja voisimme uudestaan ​​toteuttaa sen itse.

1685
01:24:35,232 --> 01:24:37,440
Mutta emme koskaan menossa
uudelleen toteuttaa Stirling.

1686
01:24:37,440 --> 01:24:39,780
Olemme juuri menossa
käyttää Stirling järjestyksessä

1687
01:24:39,780 --> 01:24:42,100
todella saada joitakin jouset pituus.

1688
01:24:42,100 --> 01:24:44,200
>> Mutta ei ole maaginen
alla huppu.

1689
01:24:44,200 --> 01:24:46,716
Jos tiedät, että alla
huppu, merkkijono

1690
01:24:46,716 --> 01:24:48,090
on vain joukko merkkejä.

1691
01:24:48,090 --> 01:24:51,090
Ja että merkkijono
kaikki voidaan numeerisesti käsiteltävä

1692
01:24:51,090 --> 01:24:53,330
jossa kannatin 0, kannatin
1, kannatin 2, ja te

1693
01:24:53,330 --> 01:24:57,420
tietävät, että lopussa merkkijono on
erikoismerkki, voit selvittää

1694
01:24:57,420 --> 01:25:01,710
miten useimmat mitä vain
ohjelma, koska kaikki se kiehuu

1695
01:25:01,710 --> 01:25:03,400
lukee ja kirjoittaa muistiin.

1696
01:25:03,400 --> 01:25:06,130
Eli muuttumassa ja etsimässä
at muisti, tai liikkuvat asiat

1697
01:25:06,130 --> 01:25:10,940
noin muistiin, tulostus asiat
ruudulla, ja niin edelleen.

1698
01:25:10,940 --> 01:25:14,800
>> Joten nyt käyttää tätä newfound
ymmärtäminen mitä kieliä tosiasiassa

1699
01:25:14,800 --> 01:25:17,910
ovat alla huppu, ja
Taitat yksi toinen kerros

1700
01:25:17,910 --> 01:25:20,080
että tähän asti olemme
ollut välittämättä kokonaan.

1701
01:25:20,080 --> 01:25:22,650
Erityisesti tahansa
Olemme toteuttaneet ohjelman,

1702
01:25:22,650 --> 01:25:25,930
meillä on ollut koodirivin
yläosassa julistaa tärkein.

1703
01:25:25,930 --> 01:25:27,810
Olemme myös määritelty int main mitätön.

1704
01:25:27,810 --> 01:25:31,240
>> Ja että mitätön sisällä suluissa
on sanonut koko ajan, että tärkeimmät

1705
01:25:31,240 --> 01:25:33,440
itse ei ota argumentteja.

1706
01:25:33,440 --> 01:25:36,210
Kaikki tulo että tärkein on
menossa käyttäjälle

1707
01:25:36,210 --> 01:25:39,020
on tultava muulla
mekanismi, kuten get int,

1708
01:25:39,020 --> 01:25:42,040
tai saada float tai saada merkkijono,
tai jokin muu toiminto.

1709
01:25:42,040 --> 01:25:44,710
Mutta käy ilmi, että
kun kirjoittaa ohjelma,

1710
01:25:44,710 --> 01:25:47,690
voit itse määrittää
että tämä ohjelma on

1711
01:25:47,690 --> 01:25:51,730
ottaa tuotantopanokset ihmisen
komentoriviltä itse.

1712
01:25:51,730 --> 01:25:56,310
>> Toisin sanoen, vaikka me tähän mennessä
on ollut käynnissä vain ./hello hei

1713
01:25:56,310 --> 01:26:00,312
tai vastaavia ohjelmia, kaikki
muut ohjelmat, jotka olemme käyttäneet,

1714
01:26:00,312 --> 01:26:02,770
että me itse ei kirjoittanut,
ovat saaneet, näyttää siltä,

1715
01:26:02,770 --> 01:26:05,210
komentorivi arguments--
asioita, kuten make.

1716
01:26:05,210 --> 01:26:07,450
Sanot jotain tehdä,
ja sitten toinen sana.

1717
01:26:07,450 --> 01:26:10,950
Tai kalahtaa, sanot clang, ja sitten
toinen sana, nimi tiedoston.

1718
01:26:10,950 --> 01:26:14,410
>> Tai jopa RM tai CP, kuten saatat
nähnyt tai käytetty jo

1719
01:26:14,410 --> 01:26:15,880
poistaa tai kopioida tiedostoja.

1720
01:26:15,880 --> 01:26:18,920
Kaikki nämä ottaa niin sanottuja
komentorivi arguments--

1721
01:26:18,920 --> 01:26:21,130
lisäsanoja terminaalissa nopea.

1722
01:26:21,130 --> 01:26:23,260
Mutta tähän asti, me
itse ei ole ollut

1723
01:26:23,260 --> 01:26:27,080
tämä ylellisyys ottaa panosta
käyttäjä kun hän todella toimii

1724
01:26:27,080 --> 01:26:29,120
itse ohjelman komentoriviltä.

1725
01:26:29,120 --> 01:26:33,710
>> Mutta voimme tehdä sen uudestaan ​​ilmoittamalla
Tärkein eteenpäin, ei olevan

1726
01:26:33,710 --> 01:26:36,750
mitätöidä suluissa,
mutta nämä kaksi argumenttia

1727
01:26:36,750 --> 01:26:40,600
instead-- ensimmäinen kokonaisluku,
ja toinen jotain

1728
01:26:40,600 --> 01:26:44,170
uusi, jota me aiomme soittaa
array, jotain vastaavaa hengessä

1729
01:26:44,170 --> 01:26:49,220
mitä näimme Scratch luettelona, ​​mutta
merkkijonojen joukko, kuten tulemme pian nähdä.

1730
01:26:49,220 --> 01:26:51,790
Mutta katsotaanpa tämän
Esimerkiksi, ennen kuin

1731
01:26:51,790 --> 01:26:53,690
erottaa mitä se tarkoittaa.

1732
01:26:53,690 --> 01:26:56,520
>> Joten jos menen CS50 IDE
täällä, olen mennyt eteenpäin

1733
01:26:56,520 --> 01:27:01,840
ja ilmoitettu niminen tiedosto
argv0.c seuraavat mallin.

1734
01:27:01,840 --> 01:27:04,120
Ja huomaa ainoa asia
se on erilaista toistaiseksi

1735
01:27:04,120 --> 01:27:08,570
on, että olen muuttunut mitätön int
argc string argv alkusulkumerkki lähellä

1736
01:27:08,570 --> 01:27:09,070
kiinnike.

1737
01:27:09,070 --> 01:27:11,730
Ja huomaa nyt, siellä
mitään sisällä näistä suluissa.

1738
01:27:11,730 --> 01:27:12,620
>> Ei ole numero.

1739
01:27:12,620 --> 01:27:15,070
Eikä ole i, tai
n, tai mikä tahansa muu kirjain.

1740
01:27:15,070 --> 01:27:17,010
Olen vain käyttämällä
hakasulkeissa nyt,

1741
01:27:17,010 --> 01:27:19,510
syistä tulemme
takaisin vain hetken.

1742
01:27:19,510 --> 01:27:21,330
>> Ja nyt, mitä aion tehdä, on tämä.

1743
01:27:21,330 --> 01:27:26,680
Jos argc yhtä kuin yhtä kuin 2--
ja muistuttavat, että on yhtä tasavertaisia

1744
01:27:26,680 --> 01:27:30,040
on yhtäsuuruusoperaattorin vertaamalla
vasen ja oikea tasa-arvoa.

1745
01:27:30,040 --> 01:27:31,790
Se ei ole toimeksianto
operaattori, joka on

1746
01:27:31,790 --> 01:27:36,510
yhden yhtäläisyysmerkki, mikä tarkoittaa kopio
oikealta vasemmalle jotain arvoa.

1747
01:27:36,510 --> 01:27:42,840
>> Jos argc yhtä kuin yhtä kuin 2, haluan
vaikkapa printf, hei, prosentteja, uusi linja,

1748
01:27:42,840 --> 01:27:47,340
ja sitten kytke in-- ja tässä uudessa
trick-- argv kiinnike 1 syistä

1749
01:27:47,340 --> 01:27:48,840
että me palaamme hetken.

1750
01:27:48,840 --> 01:27:52,110
Else if argc ei
equal 2, tiedätkö mitä?

1751
01:27:52,110 --> 01:27:57,400
Mennään eteenpäin ja, kuten tavallista, tulostaa
out Hello World ilman korvaamista.

1752
01:27:57,400 --> 01:28:02,710
>> Joten näyttää siltä, ​​että jos argc, joka
sanoista argumentti count, on 2,

1753
01:28:02,710 --> 01:28:04,740
Aion tulostaa
hei jotain tai muuta.

1754
01:28:04,740 --> 01:28:07,560
Muussa tapauksessa oletuksena, olen
menossa painoon Hello World.

1755
01:28:07,560 --> 01:28:08,770
Mitä tämä tarkoittaa?

1756
01:28:08,770 --> 01:28:15,550
>> No, anna minun mennä eteenpäin ja tallenna
tämän tiedoston, ja sitten eivät tee argv0,

1757
01:28:15,550 --> 01:28:18,940
ja sitten ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Ja se sanoo Hello World.

1759
01:28:20,300 --> 01:28:21,260
Nyt Miksi?

1760
01:28:21,260 --> 01:28:24,730
>> No, se kääntyy pois milloin vain
suorittaa ohjelman komentoriviltä,

1761
01:28:24,730 --> 01:28:29,570
täytät Mitä me
yleensä soittaa argumenttivektorin.

1762
01:28:29,570 --> 01:28:33,100
Toisin sanoen, automaattisesti
tietokone, käyttöjärjestelmä,

1763
01:28:33,100 --> 01:28:38,340
on menossa käsi ohjelmaasi
itse listan kaikista sanoista

1764
01:28:38,340 --> 01:28:40,850
että ihmisen kirjoitettuna
kehotteen siltä varalta,

1765
01:28:40,850 --> 01:28:43,790
ohjelmoija haluavat tehdä
jotain tämän tiedon.

1766
01:28:43,790 --> 01:28:48,540
Ja tässä tapauksessa ainoa sana
Olen kirjoittanut kehoitteessa on ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Ja niin useita väitteitä, jotka on
siirrellään minun ohjelma on vain yksi.

1768
01:28:55,420 --> 01:28:58,880
Toisin sanoen, argumentti
count, joka tunnetaan myös argc

1769
01:28:58,880 --> 01:29:00,970
täällä kokonaisluku, on vain yksi.

1770
01:29:00,970 --> 01:29:03,000
Yksi tietenkään ei ole sama kahden.

1771
01:29:03,000 --> 01:29:05,980
Ja niin tämä on mitä tulostaa, Hello World.

1772
01:29:05,980 --> 01:29:08,170
>> Mutta minäpä ottaa tämän jonnekin.

1773
01:29:08,170 --> 01:29:09,930
Saanen sanoa, argv0.

1774
01:29:09,930 --> 01:29:12,740
Ja sitten miten Maria?

1775
01:29:12,740 --> 01:29:14,990
Ja sitten Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Ja huomaa, mitä maagisesti tapahtuu täällä.

1777
01:29:18,020 --> 01:29:22,640
Nyt sen sijaan Hello World, olen
muuttanut käyttäytymistä ohjelman

1778
01:29:22,640 --> 01:29:26,310
ottamalla tulo eikä get
merkkijono tai jokin muu toiminto,

1779
01:29:26,310 --> 01:29:30,570
mutta ilmeisesti minun komento
itse, mitä alun perin kirjoitettu.

1780
01:29:30,570 --> 01:29:35,720
Ja voin pelata tätä peliä uudelleen
muuttamalla sen Stelios, esimerkiksi.

1781
01:29:35,720 --> 01:29:38,400
>> Ja nyt näen toinen nimi vielä.

1782
01:29:38,400 --> 01:29:40,540
Ja tässä, sanoisin Andi.

1783
01:29:40,540 --> 01:29:42,137
Ja voisin sanoa Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Voimme pelata tätä peliä koko päivän,
vain kytkemällä eri arvoja,

1785
01:29:45,220 --> 01:29:49,550
niin kauan kuin minä antaa tarkalleen
kaksi sanaa kehotteeseen,

1786
01:29:49,550 --> 01:29:52,260
niin että argc, minun argumentti laskea, on 2.

1787
01:29:52,260 --> 01:29:57,240
>> Näen että nimi kytketty
printf, per tämä ehto täällä?

1788
01:29:57,240 --> 01:30:00,550
Joten meillä näyttää nyt
ilmaisuvoimainen ominaisuus

1789
01:30:00,550 --> 01:30:04,410
ottaa panos toinen mekanismi,
alkaen ns komentorivin,

1790
01:30:04,410 --> 01:30:07,000
eikä tarvitse odottaa
kunnes käyttäjä käynnistää ohjelman,

1791
01:30:07,000 --> 01:30:10,220
ja kehottaa sitten hänelle
käyttämällä jotain get merkkijono.

1792
01:30:10,220 --> 01:30:11,230
>> Joten mitä tämä on?

1793
01:30:11,230 --> 01:30:15,010
Argc, jälleen, on vain kokonaisluku,
määrä words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
että käyttäjä on aikaansaatu
nopea kello pääteikkunaa

1795
01:30:18,540 --> 01:30:20,110
mukaan lukien ohjelman nimen.

1796
01:30:20,110 --> 01:30:23,340
Joten meidän ./argv0 on tehokkaasti,
ohjelman nimen,

1797
01:30:23,340 --> 01:30:24,520
tai miten ajaa ohjelman.

1798
01:30:24,520 --> 01:30:25,810
>> Se lasketaan sana.

1799
01:30:25,810 --> 01:30:27,080
Joten argc olisi 1.

1800
01:30:27,080 --> 01:30:29,750
Mutta kun kirjoitan Stelios, tai
Andi, tai Zamyla tai Maria,

1801
01:30:29,750 --> 01:30:31,660
se tarkoittaa, että väite määrä on kaksi.

1802
01:30:31,660 --> 01:30:33,910
Ja niin nyt on kaksi sanaa hyväksyttiin.

1803
01:30:33,910 --> 01:30:36,070
>> Ja ilmoitus, voimme jatkaa tätä logiikkaa.

1804
01:30:36,070 --> 01:30:39,050
Jos minä oikeastaan ​​sanoa
jotain Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
täydellinen nimi, näin ohimennen
kolme väitettä yhteensä,

1806
01:30:42,200 --> 01:30:47,410
Nyt se sanoo oletuksena uudelleen,
koska tietenkin, 3 ei ole sama 2.

1807
01:30:47,410 --> 01:30:54,080
>> Ja niin tällä tavalla, minulla on
tulotie argv tämä uusi väite

1808
01:30:54,080 --> 01:30:56,080
että voisimme teknisesti
soittaa mitä haluamme.

1809
01:30:56,080 --> 01:30:58,940
Mutta sopimuksen mukaan, se on
argv ja argc, vastaavasti.

1810
01:30:58,940 --> 01:31:04,470
Argv, argumenttivektorin, on eräänlainen
of synonyymi ohjelmointi

1811
01:31:04,470 --> 01:31:07,140
ominaisuus C kutsutaan jono.

1812
01:31:07,140 --> 01:31:14,410
>> Valikoima on luettelo vastaavista arvoista
takaisin, takaisin, takaisin, takaisin.

1813
01:31:14,410 --> 01:31:17,810
Toisin sanoen, jos yksi on täällä
RAM, seuraava on aivan sen vieressä,

1814
01:31:17,810 --> 01:31:18,800
ja aivan sen vieressä.

1815
01:31:18,800 --> 01:31:20,101
Ne eivät ole koko paikka.

1816
01:31:20,101 --> 01:31:23,100
Ja että viimeksi mainittu skenaario, jossa asiat
ovat koko paikka muistiin,

1817
01:31:23,100 --> 01:31:25,082
voi todella olla tehokas ominaisuus.

1818
01:31:25,082 --> 01:31:28,040
Mutta palaamme asiaan, kun me
puhua harrastaja tietorakenteita.

1819
01:31:28,040 --> 01:31:32,260
Nyt joukko on vain
kimpale yhtenäistä muistia,

1820
01:31:32,260 --> 01:31:36,520
jokainen jonka alkiot ovat
takaisin, takaisin, takaisin, takaisin,

1821
01:31:36,520 --> 01:31:38,050
ja yleensä samaa tyyppiä.

1822
01:31:38,050 --> 01:31:42,630
>> Joten jos ajattelee, mistä
hetki sitten, mikä on merkkijono?

1823
01:31:42,630 --> 01:31:50,460
No, merkkijono, kuten Zamyla,
Z-A-M-Y-L-A, on teknisesti,

1824
01:31:50,460 --> 01:31:51,400
vain joukko.

1825
01:31:51,400 --> 01:31:53,700
Se on joukko merkkejä.

1826
01:31:53,700 --> 01:31:59,250
>> Ja niin jos todella vetää tämän, koska olen
aiemminkin, koska kimpale muistia,

1827
01:31:59,250 --> 01:32:04,510
käy ilmi, että jokainen näistä
merkkiä vie tavu.

1828
01:32:04,510 --> 01:32:07,630
Ja sitten on, että erityistä
Sentinel luonne, kenoviivan 0,

1829
01:32:07,630 --> 01:32:12,360
tai kaikki kahdeksan 0 bittiä, että
rajataan loppuun merkkijonon.

1830
01:32:12,360 --> 01:32:15,090
Joten merkkijono, se muuttuu
out, lainata lainaus päättyy merkkijono,

1831
01:32:15,090 --> 01:32:20,580
on vain joukko chara--
char on todellinen tietotyyppi.

1832
01:32:20,580 --> 01:32:24,560
>> Ja nyt argv, meanwhile--
mennään takaisin ohjelmaan.

1833
01:32:24,560 --> 01:32:29,582
Argv, vaikka näemme sanan
string täällä, ei ole merkkijono itse.

1834
01:32:29,582 --> 01:32:33,640
Argv, argumenttivektorin,
on joukko merkkijonoja.

1835
01:32:33,640 --> 01:32:37,620
>> Joten kun voit olla erilaisia
merkkiä, voit olla korkeampi,

1836
01:32:37,620 --> 01:32:46,279
joukko strings-- niin, esimerkiksi,
kun olen kirjoittanut hetki sitten ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, tila Z-A-M-Y-L-A, I väitti, että
argv oli kaksi jousille it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
ja Z-A-M-Y-L-A. Sisään
Toisin sanoen, argc oli 2.

1839
01:33:03,185 --> 01:33:03,980
Miksi niin?

1840
01:33:03,980 --> 01:33:08,370
>> No, tehokkaasti, mitä tapahtuu
siitä, että kukin näistä jouset

1841
01:33:08,370 --> 01:33:13,990
on tietenkin joukko merkkejä
kuten ennen, jonka jokainen merkkiä

1842
01:33:13,990 --> 01:33:15,670
vie yhden tavun.

1843
01:33:15,670 --> 01:33:19,720
Ja älä sekoita todellista 0
ohjelman nimen kanssa 0,

1844
01:33:19,720 --> 01:33:22,040
mikä tarkoittaa kaikkia 80 bittiä.

1845
01:33:22,040 --> 01:33:27,140
Ja Zamyla puolestaan ​​on edelleen
myös joukko merkkejä.

1846
01:33:27,140 --> 01:33:31,450
>> Joten lopussa päivä, se todella
näyttää tältä alla huppu.

1847
01:33:31,450 --> 01:33:38,800
Mutta argv, luonteeltaan kuinka tärkeimmistä
työt, avulla voin paketoida kaikki tämä

1848
01:33:38,800 --> 01:33:44,810
ylös, jos haluatte, isompi array
että jos me hieman yksinkertaistaa

1849
01:33:44,810 --> 01:33:48,180
mitä kuva näyttää eivätkä
melko piirtää mittakaavassa jopa siellä,

1850
01:33:48,180 --> 01:33:56,720
Tämä joukko on vain koko 2, ensimmäinen
elementti, joka sisältää merkkijonon,

1851
01:33:56,720 --> 01:33:59,230
toinen elementti
joka sisältää merkkijonon.

1852
01:33:59,230 --> 01:34:01,687
Ja puolestaan ​​jos
Tällainen zoomata kussakin

1853
01:34:01,687 --> 01:34:03,770
näistä jouset, mitä
katso alla huppu

1854
01:34:03,770 --> 01:34:07,190
on, että jokainen merkkijono on vain
erilaisia ​​merkkejä.

1855
01:34:07,190 --> 01:34:11,680
>> Nyt aivan kuten jouset,
pystyimme päästä käsiksi

1856
01:34:11,680 --> 01:34:15,260
on i: nnen merkin merkkijono
käyttämällä että hakasulku merkintätapa.

1857
01:34:15,260 --> 01:34:17,320
Vastaavasti, paneelit
yleensä, voimme

1858
01:34:17,320 --> 01:34:22,700
käyttää hakasulje merkintää saada
milloin tahansa määrän merkkijonojen joukko?

1859
01:34:22,700 --> 01:34:25,100
Esimerkiksi haluan
mennä eteenpäin ja tehdä tätä.

1860
01:34:25,100 --> 01:34:32,420
>> Anna minun mennä eteenpäin ja luoda argv1.c,
joka on hieman erilainen tällä kertaa.

1861
01:34:32,420 --> 01:34:35,635
Sen sijaan, että tarkistamalla argc2,
Aion sen sijaan tehdä tämän.

1862
01:34:35,635 --> 01:34:41,270
Sillä int saan 0, I on vähemmän
kuin argc, I plus plus,

1863
01:34:41,270 --> 01:34:47,920
ja sitten tulostaa sisällä tästä,
prosentin s, uusi rivi, ja sitten

1864
01:34:47,920 --> 01:34:50,740
argv kiinnike i.

1865
01:34:50,740 --> 01:34:55,220
>> Eli toisin sanoen, en ole tekemisissä
yksittäisiä merkkejä tällä hetkellä.

1866
01:34:55,220 --> 01:35:00,190
Argv, kuten epäsuorasti tyhjään ruutuun
olkaimet oikealla nimen argv,

1867
01:35:00,190 --> 01:35:03,320
tarkoittaa argv on Merkkijonotaulukko.

1868
01:35:03,320 --> 01:35:04,870
Ja argc on vain int.

1869
01:35:04,870 --> 01:35:08,800
>> Tämä linja täällä, 6, on
sanomalla asettaa i yhtä suuri kuin 0.

1870
01:35:08,800 --> 01:35:11,980
Laske kaikki asti,
mutta ei, argc.

1871
01:35:11,980 --> 01:35:14,010
Ja sitten jokaisen iteraation,
tulostaa merkkijonon.

1872
01:35:14,010 --> 01:35:14,800
Mikä merkkijono?

1873
01:35:14,800 --> 01:35:17,270
>> I: nnen merkkijono argv.

1874
01:35:17,270 --> 01:35:19,530
Joten kun ennen olin
käyttäen hakasulku

1875
01:35:19,530 --> 01:35:22,180
merkintätapa saada i: nnessä
merkin merkkijono, nyt

1876
01:35:22,180 --> 01:35:27,240
Olen käyttäen hakasulku merkintätapa
saada aikaa nnen merkkijonon array.

1877
01:35:27,240 --> 01:35:30,310
Joten se on eräänlainen yhden kerroksen
edellä, käsitteellisesti.

1878
01:35:30,310 --> 01:35:35,390
>> Ja niin mitä siisti tästä
ohjelma nyt, jos en koota argv1,

1879
01:35:35,390 --> 01:35:42,067
ja sitten tehdä ./argv1, ja kirjoita sitten
moisesta foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
jotka ovat kolme oletuksena sanaa, että
tietojenkäsittelytieteessä kurottaa tahansa

1881
01:35:45,400 --> 01:35:51,010
hän tarvitsee jonkin paikkamerkki sanoja,
ja Enter, kullakin sanalla,

1882
01:35:51,010 --> 01:35:54,980
kuten ohjelman nimen, joka
on argv ensimmäisessä paikassa,

1883
01:35:54,980 --> 01:35:58,320
päätyy painetaan yksi kerrallaan.

1884
01:35:58,320 --> 01:36:05,290
Ja jos minä muuttaa tätä, ja sanon
jotain argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
saamme kaikki kolme näistä
sanoja, joka on argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, koska tässä
tapauksessa argc, count, on 3.

1887
01:36:14,400 --> 01:36:20,020
>> Mutta mikä on siisti on jos ymmärrät
että argv on vain joukko jouset,

1888
01:36:20,020 --> 01:36:24,910
ja ymmärrät, että merkkijono
on joukko merkkejä,

1889
01:36:24,910 --> 01:36:29,470
voimme todella sellaista käyttävät tätä
hakasulje merkintätapa useita kertoja

1890
01:36:29,470 --> 01:36:33,320
valita merkkijono ja valitse
merkin sisällä merkkijono,

1891
01:36:33,320 --> 01:36:35,730
sukellus syvemmälle seuraavasti.

1892
01:36:35,730 --> 01:36:40,100
Tässä esimerkissä anna minun mennä
eteenpäin ja kutsuvat tätä argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Ja tässä esimerkissä, anna minun mennä eteenpäin
ja tehdä following-- varten int saan 0,

1895
01:36:50,180 --> 01:36:53,286
i on pienempi kuin argc, i plus
plus, aivan kuten ennenkin.

1896
01:36:53,286 --> 01:36:55,910
Eli toisin words-- ja nyt tämä
on saada monimutkainen tarpeeksi.

1897
01:36:55,910 --> 01:36:59,940
Sitten aion sanoa
kerrata yli jousille argv,

1898
01:36:59,940 --> 01:37:01,294
kommenttina itselleni.

1899
01:37:01,294 --> 01:37:03,960
Ja sitten aion olla
sisäkkäisiä silmukka, joka luultavasti

1900
01:37:03,960 --> 01:37:06,290
ovat tehneet, tai katsotaan
teet, Scratch, jossa

1901
01:37:06,290 --> 01:37:08,600
Aion sanoa int-- olen
aio käyttää i uudelleen,

1902
01:37:08,600 --> 01:37:12,590
koska en halua varjo, tai
tavallaan korvata olemassa olevan i.

1903
01:37:12,590 --> 01:37:15,780
>> Aion sen sijaan, sanovat j, koska
se on minun mennä muuttuja jälkeen i,

1904
01:37:15,780 --> 01:37:18,590
kun olen vain yrittää
laskea yksinkertaisen numeroita.

1905
01:37:18,590 --> 01:37:28,850
J saa 0-- ja myös, n, on menossa
saada perä pituus argv kiinnike i,

1906
01:37:28,850 --> 01:37:36,030
kunhan j on pienempi kuin m,
j plus plus, toimi seuraavasti.

1907
01:37:36,030 --> 01:37:37,500
Ja tässä on mielenkiintoinen osa.

1908
01:37:37,500 --> 01:37:46,330
>> Tulosta merkin ja uusi linja,
kytkemällä argv kannatin i, kannatin j.

1909
01:37:46,330 --> 01:37:47,940
OK, joten haluan lisätä joitakin kommentteja täällä.

1910
01:37:47,940 --> 01:37:54,820
Kerrata yli merkkiä
nykyisessä string,

1911
01:37:54,820 --> 01:38:02,290
print j: nnen hahmo i: nnelle merkkijono.

1912
01:38:02,290 --> 01:38:04,630
Joten nyt Tarkastellaan
mitä nämä kommentit tarkoittaa.

1913
01:38:04,630 --> 01:38:06,750
>> Kerrata yli jouset
in argv-- montako

1914
01:38:06,750 --> 01:38:09,300
jouset ovat argv, joka on taulukko?

1915
01:38:09,300 --> 01:38:13,420
Argc monta, joten olen iteroimalla
alkaen i = 0, jopa argc.

1916
01:38:13,420 --> 01:38:20,020
Samaan aikaan, kuinka monta merkkiä
ovat i: nnen merkkijonon argv?

1917
01:38:20,020 --> 01:38:22,880
>> No, saada, että vastaus,
Olen juuri soittaa merkkijonon pituus

1918
01:38:22,880 --> 01:38:26,810
nykyisestä string I care
noin, mikä on argv kiinnike i.

1919
01:38:26,810 --> 01:38:30,090
Ja aion väliaikaisesti varastoida että
arvo n, vain välimuistiin tarkoituksiin,

1920
01:38:30,090 --> 01:38:31,590
muistaa sen tehokkuutta.

1921
01:38:31,590 --> 01:38:36,330
Ja sitten aion alustaa j 0,
pitää käynnissä niin kauan kuin j on pienempi kuin n,

1922
01:38:36,330 --> 01:38:38,430
ja jokaisen iteraation lisäyksen j.

1923
01:38:38,430 --> 01:38:41,030
>> Ja sitten täällä, kohti
minun kommentoida linja 12,

1924
01:38:41,030 --> 01:38:43,390
tulostaa merkin,
jonka jälkeen uusi rivi,

1925
01:38:43,390 --> 01:38:48,140
Erityisesti argv kiinnike
i antaa minulle i: nnen string

1926
01:38:48,140 --> 01:38:51,690
in argv-- joten ensimmäinen sanaa,
toinen sana, kolmas sana riippumatta.

1927
01:38:51,690 --> 01:38:57,370
Ja sitten j sukellusta syvemmälle, ja saa
me j: nnen luonne tuo sana.

1928
01:38:57,370 --> 01:39:02,200
Ja niin, itse asiassa, voit hoitaa
argv niin moniulotteinen,

1929
01:39:02,200 --> 01:39:06,050
kuten kaksiulotteinen, array,
jolloin jokainen sana sellainen näyttää

1930
01:39:06,050 --> 01:39:08,580
kuten tämä mielesi
silmä, ja jokainen merkki

1931
01:39:08,580 --> 01:39:10,930
on sellainen muodostetaan
sarake, jos se auttaa.

1932
01:39:10,930 --> 01:39:13,260
>> Todellisuudessa kun kiusaa
Tämän lisäksi tulevaisuudessa viikkoja,

1933
01:39:13,260 --> 01:39:15,580
se tulee olemaan hieman
kehittyneempiä kuin.

1934
01:39:15,580 --> 01:39:17,800
Mutta voit todella
ajatella, että nyt,

1935
01:39:17,800 --> 01:39:22,110
koska juuri tämä kaksiulotteinen
array, jolloin yksi taso sen

1936
01:39:22,110 --> 01:39:23,260
on kaikki jouset.

1937
01:39:23,260 --> 01:39:26,760
Ja sitten jos sukeltaa syvemmälle, te
voi saada aikaa yksittäisten merkkien

1938
01:39:26,760 --> 01:39:29,600
taavaa käyttämällä tätä merkintää täällä.

1939
01:39:29,600 --> 01:39:31,620
>> Joten mikä on nettovaikutus?

1940
01:39:31,620 --> 01:39:34,970
Anna minun mennä eteenpäin ja
tehdä argv2-- hiton sitä.

1941
01:39:34,970 --> 01:39:36,210
Tein virheen täällä.

1942
01:39:36,210 --> 01:39:40,160
Epäsuorasti ilmoittamisessa
kirjaston funktion Stirling.

1943
01:39:40,160 --> 01:39:42,190
Joten koko tämän ajan, se on
ehkä aiheellista

1944
01:39:42,190 --> 01:39:45,130
että olemme tavallaan viimeistely
missä aloitimme.

1945
01:39:45,130 --> 01:39:48,160
>> Mokasin implisiittisesti julistaa
kirjaston funktion Stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, odota hetki.

1947
01:39:48,987 --> 01:39:51,070
Muistan, että varsinkin
koska se on täällä.

1948
01:39:51,070 --> 01:39:54,490
Minun täytyy sisällyttää string.h vuonna
tämä versio ohjelmasta.

1949
01:39:54,490 --> 01:40:00,050
>> Anna minun mennä eteenpäin ja sisältävät
string.h, paitsi että, mennä eteenpäin

1950
01:40:00,050 --> 01:40:04,460
ja kääntää argv2.

1951
01:40:04,460 --> 01:40:08,390
Ja nyt, tässä sitä mennään, tee argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Ja vaikka se on hieman
arvoituksellinen ensi silmäyksellä,

1953
01:40:10,590 --> 01:40:15,690
huomata, todellakin, mitä
tulostetaan on piste argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Mutta jos kirjoitan joitakin sanoja jälkeen
nopea, kuten argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Anna, myös hieman
arvoituksellinen ensi silmäyksellä.

1956
01:40:22,560 --> 01:40:30,540
Mutta jos me vierittää takaisin ylös,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Siksi olemme iterated yli jokaista sanaa.

1958
01:40:32,190 --> 01:40:37,770
Ja puolestaan ​​olemme iterated yli
jokainen kirjaimen sanan.

1959
01:40:37,770 --> 01:40:40,040
>> Nyt, kun kaikki tämä,
ymmärtää, että on olemassa

1960
01:40:40,040 --> 01:40:43,120
yksi muu yksityiskohtaisesti olemme olleet eräänlainen
unohdetaan koko tämän ajan.

1961
01:40:43,120 --> 01:40:46,180
Me vain kiusoitteli toisistaan ​​mitä
Tärkeimmät n tulot voivat olla?

1962
01:40:46,180 --> 01:40:47,780
Entä tärkeimmät tuotannosta?

1963
01:40:47,780 --> 01:40:50,540
>> Kaikki tämä aika, olemme olleet
vain kopioimalla

1964
01:40:50,540 --> 01:40:53,870
sana int edessä tärkein,
vaikka et voi nähdä verkossa,

1965
01:40:53,870 --> 01:40:58,340
joskus virheellisesti vanhemmissa versioissa
C ja kääntäjät, että he sanovat mitätön,

1966
01:40:58,340 --> 01:40:59,410
tai ei mitään.

1967
01:40:59,410 --> 01:41:01,580
Mutta todellakin, että version
C, että käytämme,

1968
01:41:01,580 --> 01:41:06,180
C 11, tai 2011, ymmärtää
että sen pitäisi olla int.

1969
01:41:06,180 --> 01:41:09,300
Ja sen pitäisi olla joko
mitätön tai argc ja argv täällä.

1970
01:41:09,300 --> 01:41:10,790
>> Mutta miksi int main?

1971
01:41:10,790 --> 01:41:12,480
Mikä on se todella palaamassa?

1972
01:41:12,480 --> 01:41:16,280
No, se kääntyy pois kaiken tämän ajan,
tahansa olet kirjoittanut ohjelman pääasiallinen

1973
01:41:16,280 --> 01:41:18,440
on aina palaa jotain.

1974
01:41:18,440 --> 01:41:19,960
Mutta se on ollut näin salaa.

1975
01:41:19,960 --> 01:41:23,350
>> Se jokin on
int, koska rivi 5 ehdottaa.

1976
01:41:23,350 --> 01:41:24,225
Mutta mitä int?

1977
01:41:24,225 --> 01:41:26,100
No, on tämä
sopimus ohjelmointi,

1978
01:41:26,100 --> 01:41:29,790
jolloin jos mitään on
mennyt pieleen ja kaikki on hyvin,

1979
01:41:29,790 --> 01:41:34,250
ohjelmat ja toiminnot yleisesti
return-- hieman counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 yleensä merkitsee kaikki on hyvin.

1982
01:41:38,070 --> 01:41:40,610
Joten vaikka ajatella
se väärinä monissa yhteyksissä,

1983
01:41:40,610 --> 01:41:42,930
se itse asiassa tarkoittaa yleensä hyvä asia

1984
01:41:42,930 --> 01:41:49,560
>> Samaan aikaan, jos ohjelma palauttaa 1,
tai negatiivinen 1, tai 5, tai negatiivinen 42,

1985
01:41:49,560 --> 01:41:52,941
tai ei-0-arvo,
että yleensä merkitsee

1986
01:41:52,941 --> 01:41:54,190
että jotain on mennyt vikaan.

1987
01:41:54,190 --> 01:41:56,700
Itse omalla Mac- tai PC,
olet ehkä nähneet

1988
01:41:56,700 --> 01:42:01,050
virheilmoituksen, jolloin se
sanoo jotain tai muuta, virhe

1989
01:42:01,050 --> 01:42:04,940
koodi negatiivinen 42 tai virhekoodi
23, tai jotain sellaista.

1990
01:42:04,940 --> 01:42:08,980
Tämä numero on yleensä vain aavistuksen
ohjelmoija tai yritys

1991
01:42:08,980 --> 01:42:11,174
joka teki ohjelmisto,
mikä meni pieleen ja miksi,

1992
01:42:11,174 --> 01:42:13,590
jotta he voivat käydä läpi
asiakirjansa tai koodi,

1993
01:42:13,590 --> 01:42:15,465
ja selvittää, mitä
virhe todella tarkoittaa.

1994
01:42:15,465 --> 01:42:18,400
Se on yleensä ole
hyödyllistä meille loppukäyttäjille.

1995
01:42:18,400 --> 01:42:20,550
>> Mutta kun tärkein palauttaa 0, kaikki on hyvin.

1996
01:42:20,550 --> 01:42:23,770
Ja jos et määritä
mitä tärkein pitäisi palata,

1997
01:42:23,770 --> 01:42:26,950
se vain automaattisesti
palata 0 sinulle.

1998
01:42:26,950 --> 01:42:30,870
Mutta palaavat jotain
muu on todella hyödyllinen.

1999
01:42:30,870 --> 01:42:34,660
>> Tässä lopullinen ohjelma, haluan
mennä eteenpäin ja kutsuvat tätä exit.c,

2000
01:42:34,660 --> 01:42:38,630
ja ottaa viimeisen päivän
aiheita, tunnettu virhekoodi.

2001
01:42:38,630 --> 01:42:42,930
Anna minun mennä eteenpäin ja sisältää myös
tuttu tiedostoja ylös, tee int main.

2002
01:42:42,930 --> 01:42:49,500
Ja tällä kertaa, tehdään int argc,
string argv, ja minun suluissa

2003
01:42:49,500 --> 01:42:50,836
vihjata, että se on jono.

2004
01:42:50,836 --> 01:42:52,460
Ja sitten haluan vain tehdä järki tarkistaa.

2005
01:42:52,460 --> 01:42:56,640
Tällä kertaa, jos argc ei
equal 2, niin tiedät mitä?

2006
01:42:56,640 --> 01:42:57,520
Unohda.

2007
01:42:57,520 --> 01:43:03,170
Aion sanoa, hei, käyttäjä,
olet puuttuu komentorivillä

2008
01:43:03,170 --> 01:43:04,210
backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> Ja sitten se on siinä.

2010
01:43:05,230 --> 01:43:06,130
Haluan poistua.

2011
01:43:06,130 --> 01:43:11,030
Aion ennaltaehkäisevästi,
ja ennenaikaisesti todella, paluu

2012
01:43:11,030 --> 01:43:12,810
jotain muuta kuin numero 1.

2013
01:43:12,810 --> 01:43:15,360
Go to arvoa ensimmäistä
virhe, joka voi tapahtua on 1.

2014
01:43:15,360 --> 01:43:17,860
Jos sinulla on jokin muu virheellinen
tilanne, joka saattaa ilmetä,

2015
01:43:17,860 --> 01:43:21,390
voisi sanoa paluu 2 tai palauttaa 3, tai
ehkä jopa negatiivinen 1 tai negatiivinen 2.

2016
01:43:21,390 --> 01:43:23,750
>> Nämä ovat vain exit koodeja
jotka ovat yleensä

2017
01:43:23,750 --> 01:43:27,770
hyötyä vain ohjelmoija, tai
yritys, joka on merenkulun ohjelmisto.

2018
01:43:27,770 --> 01:43:30,500
Mutta se, että se on
ei 0 on, mikä on tärkeää.

2019
01:43:30,500 --> 01:43:34,310
Joten jos tässä ohjelmassa, haluan
taata, että tässä ohjelmassa ainoastaan

2020
01:43:34,310 --> 01:43:38,190
toimii, jos käyttäjä antaa minulle
argumenttia lasken kaksi,

2021
01:43:38,190 --> 01:43:42,880
nimi ohjelman, ja joitakin muita
sana, voin valvoa niin paljon kuin seuraava,

2022
01:43:42,880 --> 01:43:46,110
Yell käyttäjälle printf sanonta,
puuttuva komentorivillä,

2023
01:43:46,110 --> 01:43:46,970
palata 1.

2024
01:43:46,970 --> 01:43:49,940
Se tulee vain välittömästi
lopettaa ohjelman.

2025
01:43:49,940 --> 01:43:55,840
>> Vain jos argc = 2 saamme alas
täällä, jossa vaiheessa aion sanoa,

2026
01:43:55,840 --> 01:44:00,410
hei prosenttia s, kenoviiva n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Toisin sanoen, olen
aio jälkeen argv 0,

2028
01:44:03,827 --> 01:44:05,410
joka on vain ohjelman nimi.

2029
01:44:05,410 --> 01:44:09,450
Haluan tulostaa hei, pilkku,
toinen sana, että ihmisen kirjoitetaan.

2030
01:44:09,450 --> 01:44:12,580
Ja tässä tapauksessa
linja 13, kaikki on hyvin.

2031
01:44:12,580 --> 01:44:15,920
>> Tiedän, että argc on 2
loogisesti tästä ohjelmasta.

2032
01:44:15,920 --> 01:44:17,770
Aion mennä eteenpäin ja palauttaa 0.

2033
01:44:17,770 --> 01:44:21,230
Sivuhuomautuksena, pitää mielessä, että
Tämä pätee Scratch samoin.

2034
01:44:21,230 --> 01:44:24,760
>> Loogisesti, voisin tehdä tätä
ja kiteyttää nämä rivit

2035
01:44:24,760 --> 01:44:27,020
koodia tässä muu lauseke täällä.

2036
01:44:27,020 --> 01:44:29,420
Mutta se on eräänlainen
tarpeettomasti sisennys minun koodi.

2037
01:44:29,420 --> 01:44:31,800
Ja Haluan tehdä Super
selvää, että mitä tahansa,

2038
01:44:31,800 --> 01:44:34,670
oletuksena, hei
jotain saavat painettu,

2039
01:44:34,670 --> 01:44:36,050
niin kauan kuin käyttäjä tekee yhteistyötä.

2040
01:44:36,050 --> 01:44:39,360
>> Joten on hyvin tavallista käyttää
ehdon, vain jos,

2041
01:44:39,360 --> 01:44:41,870
pyydystämään virheellinen
tilanne, ja sitten poistu.

2042
01:44:41,870 --> 01:44:45,690
Ja sitten, niin kauan kaikki on
hyvin, ei ole muuta,

2043
01:44:45,690 --> 01:44:48,060
mutta vain koodia
ulkopuolella että jos, koska se on

2044
01:44:48,060 --> 01:44:51,060
vastaava tässä
erityistapauksessa, loogisesti.

2045
01:44:51,060 --> 01:44:54,480
Joten olen palaamassa 0, vain
nimenomaisesti merkitsevät kaikki on hyvin.

2046
01:44:54,480 --> 01:44:58,480
>> Jos minä pois paluuta 0, se olisi
automaattisesti olettaa minulle.

2047
01:44:58,480 --> 01:45:00,890
Mutta nyt kun palaan
yksi ainakin tässä tapauksessa

2048
01:45:00,890 --> 01:45:04,940
Aion, kaupanpäällisiksi ja
selkeys, palauttaa 0 tässä tapauksessa.

2049
01:45:04,940 --> 01:45:09,690
Nyt anna minun mennä eteenpäin ja tehdä exit,
joka on täydellinen segue vain lähteä.

2050
01:45:09,690 --> 01:45:14,401
>> Mutta varmista exit, ja anna minun mennä
eteenpäin ja tehdä ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Ja ohjelma huusi minulle,
puuttuva komentorivillä.

2052
01:45:16,900 --> 01:45:18,120
OK, anna minun tehdä yhteistyötä.

2053
01:45:18,120 --> 01:45:23,810
>> Saanen sen sijaan tehdä ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Ja nyt se sanoo, hei David.

2055
01:45:25,190 --> 01:45:27,300
Ja et normaalisti näe tätä.

2056
01:45:27,300 --> 01:45:30,650
>> Mutta näyttää siltä, ​​että on olemassa
erityisellä tavalla Linux todella nähdä

2057
01:45:30,650 --> 01:45:34,470
mitä exit koodin ohjelma poistui.

2058
01:45:34,470 --> 01:45:37,184
Joskus graafinen
maailmaa, kuten Mac OS tai Windows,

2059
01:45:37,184 --> 01:45:40,100
näet vain näitä numeroita, kun
virheilmoitus ponnahtaa näytölle

2060
01:45:40,100 --> 01:45:41,940
ja ohjelmoija
näyttää, että numeron.

2061
01:45:41,940 --> 01:45:44,773
Mutta jos haluamme nähdä, mitä virhe
viesti on, voimme tehdä sen here--

2062
01:45:44,773 --> 01:45:48,100
niin ./exit, Enter, tulostaa
puuttuva komentorivillä.

2063
01:45:48,100 --> 01:45:54,590
>> Jos minä nyt tehdä echo $ ?, joka on
naurettavan arvoituksellinen näköinen.

2064
01:45:54,590 --> 01:45:56,590
Mutta $?

2065
01:45:56,590 --> 01:45:59,220
on maaginen loitsu
joka sanoo, hei, tietokone,

2066
01:45:59,220 --> 01:46:01,900
kerro mitä edellisessä
Ohjelman exit-koodi oli.

2067
01:46:01,900 --> 01:46:03,410
Ja osuin Enter.

2068
01:46:03,410 --> 01:46:07,520
Näen 1, koska se mitä
kertonut päätehtävä palata.

2069
01:46:07,520 --> 01:46:12,310
>> Samaan aikaan, jos en ./exit David,
ja Enter, näen, hei David.

2070
01:46:12,310 --> 01:46:16,800
Ja jos minä nyt tehdä echo $ ?, näen hei 0.

2071
01:46:16,800 --> 01:46:19,080
Ja niin tämä todella
olla arvokasta tietoa

2072
01:46:19,080 --> 01:46:23,420
yhteydessä debuggeri, ei niin
paljon, että te, ihmisen, ei välittäisi.

2073
01:46:23,420 --> 01:46:26,060
Mutta debuggerin ja muut
ohjelmat käytämme tämän lukukauden

2074
01:46:26,060 --> 01:46:29,420
usein tarkastellaan, että määrä,
vaikka se tavallaan piilossa

2075
01:46:29,420 --> 01:46:32,780
ellet etsiä sitä,
määrittää, onko ohjelman

2076
01:46:32,780 --> 01:46:37,050
suorittamisen oikea vai väärä.

2077
01:46:37,050 --> 01:46:40,450
>> Ja niin tämä tuo meidät
Tämän lopussa päivän.

2078
01:46:40,450 --> 01:46:43,917
Aloitimme tänään katsomalla
virheenkorjaus, ja vuorotellen kurssin

2079
01:46:43,917 --> 01:46:46,750
itse, ja sitten enemmän kiinnostavaa,
Teknisesti alla huppu

2080
01:46:46,750 --> 01:46:49,490
mitä jouset ovat, jotka kestävät
viikolla vain otti itsestäänselvyytenä,

2081
01:46:49,490 --> 01:46:51,900
ja varmasti vei heidät
selvänä Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Sitten tarkasteltiin, kuinka voimme käyttää
yksittäisiä merkkejä merkkijonon,

2083
01:46:56,040 --> 01:47:00,310
ja sitten taas otti korkeammalle tasolle
katsomaan asioita, katsomalla miten well--

2084
01:47:00,310 --> 01:47:04,226
jos haluamme saada yksittäisiä
elementtiä yhdessä listassa kuten rakenne,

2085
01:47:04,226 --> 01:47:05,850
ei voi teemme että useita jouset?

2086
01:47:05,850 --> 01:47:08,050
Ja voimme kanssa komentoriviargumentteja.

2087
01:47:08,050 --> 01:47:12,800
Mutta tämä kuva täällä vain laatikoiden
on demonstratiivipronominit tämä yleinen ajatus

2088
01:47:12,800 --> 01:47:14,451
array, tai lista, tai vektori.

2089
01:47:14,451 --> 01:47:16,450
Ja riippuen
yhteydessä, kaikki nämä sanat

2090
01:47:16,450 --> 01:47:17,880
tarkoittaa hieman eri asioita.

2091
01:47:17,880 --> 01:47:20,060
Joten C, olemme vain menossa
puhua array.

2092
01:47:20,060 --> 01:47:23,840
Ja joukko on murikka
muistia, joista kukin on

2093
01:47:23,840 --> 01:47:27,720
elementit ovat vierekkäisiä, takaisin,
takaisin, takaisin, takaisin.

2094
01:47:27,720 --> 01:47:31,970
>> Ja nämä seikat ovat yleensä
samat tiedot tyyppi, merkki,

2095
01:47:31,970 --> 01:47:35,966
merkki, merkki, merkki, tai
string, string, string, string, tai int,

2096
01:47:35,966 --> 01:47:38,600
int, int, mitä se on
yritämme säilyttää.

2097
01:47:38,600 --> 01:47:42,540
Mutta lopussa päivä, tämä on
miltä se näyttää käsitteellisesti.

2098
01:47:42,540 --> 01:47:44,530
Olet ottaen oman
tietokoneen muistin tai RAM.

2099
01:47:44,530 --> 01:47:48,590
Ja olet veistämällä sen ulos
samankokoisia laatikoita, jotka kaikki

2100
01:47:48,590 --> 01:47:50,920
takaisin, takaisin, jotta
takaisin, takaisin tällä tavalla.

2101
01:47:50,920 --> 01:47:53,200
>> Ja mitä mukavaa noin
Tämä ajatus, ja se

2102
01:47:53,200 --> 01:47:58,580
että voimme ilmaista arvoja tällä tavoin
ensimmäisen meidän tietorakenteiden

2103
01:47:58,580 --> 01:48:02,520
luokassa, tarkoittaa voimme aloittaa
ongelmien ratkaisemiseksi koodilla

2104
01:48:02,520 --> 01:48:04,079
joka tuli niin intuitiivisesti viikolla 0.

2105
01:48:04,079 --> 01:48:05,870
Saat muistaa puhelimen
kirjaesimerkkiin, jossa

2106
01:48:05,870 --> 01:48:09,110
käytimme hajoita ja hallitse,
tai puolitushaku,

2107
01:48:09,110 --> 01:48:13,220
käydä läpi koko
nippu nimiä ja numeroita.

2108
01:48:13,220 --> 01:48:18,220
Mutta oletimme, muistuttaa, että
puhelinluettelo on jo järjestetty,

2109
01:48:18,220 --> 01:48:21,630
että joku muu oli jo
tajunnut out-- annetaan luettelo nimiä

2110
01:48:21,630 --> 01:48:24,430
ja numbers-- miten aakkostaa niitä.

2111
01:48:24,430 --> 01:48:26,950
Ja nyt, että C me,
Myös on kyky

2112
01:48:26,950 --> 01:48:30,290
antaa asioita, ei
fyysisesti puhelinluettelosta

2113
01:48:30,290 --> 01:48:34,220
mutta käytännössä on tietokoneen
muisti, voimme ensi viikolla

2114
01:48:34,220 --> 01:48:38,470
esitellä uudelleen this-- ensimmäisen
meidän tietorakenteiden käytettäessä array--

2115
01:48:38,470 --> 01:48:43,530
mutta vielä tärkeämpää, todellinen tietokone
tiede algoritmit toteutetaan

2116
01:48:43,530 --> 01:48:47,720
koodin, jolla voimme varastoida
data rakenteissa, kuten tämä,

2117
01:48:47,720 --> 01:48:50,730
ja sitten alkaa käsitellä sitä, ja
todella ratkaista ongelmia sen kanssa,

2118
01:48:50,730 --> 01:48:53,570
ja rakentaa sen päälle,
lopulta, ohjelmia C,

2119
01:48:53,570 --> 01:48:56,730
Python, JavaScript,
kyselyitä tietokantoja SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Ja näemme, että kaikki nämä
erilaisia ​​ajatuksia lukitus.

2121
01:48:59,980 --> 01:49:04,100
Mutta nyt, muistaa, että
verkkotunnuksen että otimme käyttöön tänään

2122
01:49:04,100 --> 01:49:06,920
oli tämä asia täällä, ja
maailmaan salakirjoituksen.

2123
01:49:06,920 --> 01:49:11,200
Ja joukossa seuraavan ongelmat itse
ratkaisee on taidetta salakirjoituksen,

2124
01:49:11,200 --> 01:49:13,630
scrambling ja vastahajotus
tietoa, ja salauksen

2125
01:49:13,630 --> 01:49:15,930
ja deciphering tekstiä,
ja olettaen lopulta

2126
01:49:15,930 --> 01:49:18,970
että te nyt tietää, mitä
on alla huppu

2127
01:49:18,970 --> 01:49:21,860
niin että kun näet tai vastaanottaa
tällaisen viestin, te

2128
01:49:21,860 --> 01:49:24,060
itse voi tulkita sitä.

2129
01:49:24,060 --> 01:49:26,740
Kaikki tämä, ja enemmän ensi kerralla.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEOTOISTOSTA]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Juuri saapunut.

2133
01:49:32,970 --> 01:49:35,146
Aion mennä vierailun
hänen yliopiston professori.

2134
01:49:35,146 --> 01:49:37,611
Jep.

2135
01:49:37,611 --> 01:49:40,080
Moi.

2136
01:49:40,080 --> 01:49:40,660
Se olet sinä.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Odota!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Olen vain yrittänyt selvittää
mitä sinulle tapahtui.

2142
01:49:56,060 --> 01:49:58,130
Ole hyvä, mitä tahansa voi auttaa.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Olit hänen college
kämppäkaveri, vai mitä?

2145
01:50:08,354 --> 01:50:10,770
Olit siellä hänen kanssaan, kun
hän sijoittui CS50 hanke?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUSIIKKIA]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Se Oli CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Rakastan tätä paikkaa.

2152
01:50:44,770 --> 01:50:45,854
>> -Syödä.

2153
01:50:45,854 --> 01:50:47,020
Menemme ulos liiketoimintaa.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END TOISTO]

