1
00:00:00,000 --> 00:00:02,970
>> [MUSIK AFSPILLER]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN: Okay.

4
00:00:15,700 --> 00:00:18,832
Dette er CS50 og dette
er starten af ​​uge 2.

5
00:00:18,832 --> 00:00:21,040
Og du vil huske, at over
de sidste par uger,

6
00:00:21,040 --> 00:00:24,490
Vi har været at indføre computer
videnskab og til gengæld programmering.

7
00:00:24,490 --> 00:00:27,640
>> Og vi begyndte historien i form af
Scratch, at grafisk sprog

8
00:00:27,640 --> 00:00:28,990
fra MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
Og derefter senest
sidste uge, gjorde vi

10
00:00:30,780 --> 00:00:34,450
indføre en higher-- a
lavere niveau sprog kendt

11
00:00:34,450 --> 00:00:36,770
som C, noget, der er rent tekstmæssige.

12
00:00:36,770 --> 00:00:39,440
Og, ja, sidste gang vi
udforsket i denne sammenhæng

13
00:00:39,440 --> 00:00:40,450
en række begreber.

14
00:00:40,450 --> 00:00:43,010
>> Dette, tilbagekaldelse, var den meget
første program vi kiggede på.

15
00:00:43,010 --> 00:00:45,710
Og dette program, ganske enkelt,
udskriver, "Hej, verden."

16
00:00:45,710 --> 00:00:47,730
Men der er så meget
tilsyneladende magi foregår.

17
00:00:47,730 --> 00:00:51,460
Der er denne #include
med disse vinkelbeslag.

18
00:00:51,460 --> 00:00:52,170
Der er int.

19
00:00:52,170 --> 00:00:53,020
Der er (void).

20
00:00:53,020 --> 00:00:56,330
Der er parenteser, krøllede parenteser,
semikolon, og så meget mere.

21
00:00:56,330 --> 00:00:58,480
>> Og ja, minde om, at
vi indførte Scratch

22
00:00:58,480 --> 00:01:02,110
så vi kunne ideelt set se forbi
at syntaks, de ting, der er virkelig ikke

23
00:01:02,110 --> 00:01:04,590
alt, intellektuelt
interessant men tidligt

24
00:01:04,590 --> 00:01:07,700
er, absolut, lidt tricky
at pakke dit sind omkring.

25
00:01:07,700 --> 00:01:10,860
Og faktisk en af ​​de mest almindelige
ting tidligt i en programmering klasse,

26
00:01:10,860 --> 00:01:13,443
især for de mindre
komfortable, er at få frustreret over

27
00:01:13,443 --> 00:01:17,460
og udløst op af visse syntaktiske
fejl, for ikke at nævne logiske fejl.

28
00:01:17,460 --> 00:01:19,800
Og så blandt vores mål
dag, faktisk, vil

29
00:01:19,800 --> 00:01:23,280
være at udstyre dig med nogle
problemløsning teknikker til, hvordan

30
00:01:23,280 --> 00:01:26,705
for bedre at løse problemerne selv
i form af debugging.

31
00:01:26,705 --> 00:01:29,330
Og du vil huske, også, at den
miljø, som vi introduceret

32
00:01:29,330 --> 00:01:31,780
sidste gang blev kaldt CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Dette er webbaseret software, der
giver dig mulighed for at programmere i skyen,

34
00:01:34,850 --> 00:01:38,450
så at sige, og samtidig holde alle dine
filer sammen, som vi igen vil i dag.

35
00:01:38,450 --> 00:01:41,480
Og minde om, at vi
revisited disse emner her,

36
00:01:41,480 --> 00:01:44,480
blandt dem funktioner og loops, og
variabler og booleske udtryk,

37
00:01:44,480 --> 00:01:45,110
og betingelser.

38
00:01:45,110 --> 00:01:49,190
Og faktisk et par mere, at vi
oversat fra verden af ​​Scratch

39
00:01:49,190 --> 00:01:50,800
til en verden af ​​C.

40
00:01:50,800 --> 00:01:53,220
>> Men det grundlæggende bygning
blokke, så at sige,

41
00:01:53,220 --> 00:01:55,150
var virkelig stadig den samme sidste uge.

42
00:01:55,150 --> 00:01:57,900
Faktisk, vi virkelig bare havde en
anderledes brik, hvis du vil.

43
00:01:57,900 --> 00:02:00,300
I stedet for at lilla
spare blok, vi i stedet

44
00:02:00,300 --> 00:02:02,940
havde printf, som er
denne funktion i C, der

45
00:02:02,940 --> 00:02:05,890
giver dig mulighed for at udskrive noget
og formatere det på skærmen.

46
00:02:05,890 --> 00:02:07,950
Vi introducerede CS50
Bibliotek, hvor du

47
00:02:07,950 --> 00:02:11,420
har nu til din rådighed get_char,
og get_int, og get_string,

48
00:02:11,420 --> 00:02:14,610
og et par andre funktioner som
godt, via hvilken du kan få input

49
00:02:14,610 --> 00:02:16,260
fra brugerens eget tastatur.

50
00:02:16,260 --> 00:02:20,640
Og vi tog også et kig på tingene
ligesom disse-bool, og fjeldørred,

51
00:02:20,640 --> 00:02:22,490
og dobbelt, flyde,
int, long_long streng.

52
00:02:22,490 --> 00:02:25,170
Og der er endda andre datatyper i C.

53
00:02:25,170 --> 00:02:28,560
>> Med andre ord, når du erklærer
en variabel til at gemme en vis værdi,

54
00:02:28,560 --> 00:02:32,600
eller når du implementerer en funktion
der returnerer en vis værdi,

55
00:02:32,600 --> 00:02:35,290
du kan angive, hvad
type værdi, der er.

56
00:02:35,290 --> 00:02:37,310
Er det en streng, som en
sekvens af tegn?

57
00:02:37,310 --> 00:02:39,490
Er det et nummer, som et heltal?

58
00:02:39,490 --> 00:02:41,390
Er det en floating point
værdi, eller lignende?

59
00:02:41,390 --> 00:02:46,180
Så i C, i modsætning Scratch, vi faktisk
begyndte at angive, hvilken slags data

60
00:02:46,180 --> 00:02:48,330
vi tilbage eller bruger.

61
00:02:48,330 --> 00:02:51,910
>> Men selvfølgelig, vi løb også ind i
nogle fundamentale grænser for computing.

62
00:02:51,910 --> 00:02:54,100
Og i særdeleshed,
dette sprog C, tilbagekaldelse

63
00:02:54,100 --> 00:02:57,070
at vi tog et kig på
heltalsoverløb, virkeligheden

64
00:02:57,070 --> 00:03:00,460
at hvis du kun har en
begrænset mængde hukommelse

65
00:03:00,460 --> 00:03:04,600
eller specifikt et endeligt antal
af bits, kan du kun regne så højt.

66
00:03:04,600 --> 00:03:08,460
Og så vi kiggede på dette eksempel her
hvorved en tæller i et fly,,

67
00:03:08,460 --> 00:03:13,510
faktisk, hvis der kører længe nok ville
overløb og resultere i en software

68
00:03:13,510 --> 00:03:15,560
et virkeligt fysiske potentiale fejl.

69
00:03:15,560 --> 00:03:18,600
>> Vi så også på flydende
punkt unøjagtighed, virkeligheden

70
00:03:18,600 --> 00:03:22,280
at med kun et endeligt antal
af bits, uanset om det er 32 eller 64,

71
00:03:22,280 --> 00:03:27,330
du kan kun angive så mange numre
efter et komma, hvorefter du

72
00:03:27,330 --> 00:03:29,110
begynder at få upræcis.

73
00:03:29,110 --> 00:03:32,360
Så for eksempel, en tredjedel i
verden her, i vores menneskelige verden,

74
00:03:32,360 --> 00:03:35,360
vi ved er blot et uendeligt antal
af 3s efter kommaet.

75
00:03:35,360 --> 00:03:38,820
Men en computer kan ikke nødvendigvis
repræsenterer et uendeligt antal numre

76
00:03:38,820 --> 00:03:42,590
hvis du kun tillader det nogle
endelig mængde information.

77
00:03:42,590 --> 00:03:45,900
>> Så ikke kun vi udstyre dig
med større kraft i form

78
00:03:45,900 --> 00:03:49,280
af, hvordan du kan udtrykke dig selv på
et tastatur i form af programmering,

79
00:03:49,280 --> 00:03:51,430
vi også begrænset hvad
du rent faktisk kan gøre.

80
00:03:51,430 --> 00:03:55,790
Og ja, bugs og fejl kan
skyldes den slags spørgsmål.

81
00:03:55,790 --> 00:03:59,900
Og ja, blandt de emner i dag
vil være emner som debugging

82
00:03:59,900 --> 00:04:03,699
og faktisk ser under kølerhjelmen
på, hvordan tingene blev indført i sidste uge

83
00:04:03,699 --> 00:04:05,490
faktisk implementeres
så du bedre

84
00:04:05,490 --> 00:04:10,530
forstå både funktionerne i og
begrænsningerne af et sprog som C.

85
00:04:10,530 --> 00:04:14,770
>> Og i virkeligheden, vil vi skrælle lagene
af de enkleste af datastruktur,

86
00:04:14,770 --> 00:04:17,756
noget, der hedder et array, som
Scratch sker for at kalde en "liste."

87
00:04:17,756 --> 00:04:19,589
Det er en lille smule
forskellige i denne sammenhæng.

88
00:04:19,589 --> 00:04:23,340
Og så vil vi også indføre en af ​​de
første af vores domænespecifikke problemer

89
00:04:23,340 --> 00:04:26,790
i CS50, en verden af
kryptografi, kunsten at forvanske

90
00:04:26,790 --> 00:04:29,650
eller chifrere oplysninger, så
at du kan sende hemmelige beskeder

91
00:04:29,650 --> 00:04:34,520
og afkode hemmelige beskeder
mellem to personer, A og B.

92
00:04:34,520 --> 00:04:37,490
>> Så før vi overgang
til den nye verden,

93
00:04:37,490 --> 00:04:42,059
lad os prøve at udstyre dig med nogle
teknikker, som du kan fjerne

94
00:04:42,059 --> 00:04:43,850
eller reducere i det mindste nogle
af de frustrationer

95
00:04:43,850 --> 00:04:46,630
at du sandsynligvis er stødt
løbet alene den seneste uge.

96
00:04:46,630 --> 00:04:50,830
Faktisk foran dig er such-- nogle af
dine første problemer i C. Og odds er,

97
00:04:50,830 --> 00:04:54,010
Hvis du ligesom mig, første gang
du forsøger at skrive et program,

98
00:04:54,010 --> 00:04:57,330
selvom du tror logisk
programmet er ret enkel,

99
00:04:57,330 --> 00:05:01,200
du kan meget vel ramme en mur, og
compileren ikke kommer til at samarbejde.

100
00:05:01,200 --> 00:05:03,940
Lav eller Dunk ikke vil
til rent faktisk at gøre dit bud.

101
00:05:03,940 --> 00:05:05,450
>> Og hvorfor kan det være?

102
00:05:05,450 --> 00:05:07,950
Nå, lad os tage et kig på,
måske, et simpelt program.

103
00:05:07,950 --> 00:05:11,190
Jeg har tænkt mig at gå videre og gemme denne i
en fil bevidst kaldet buggy0.c,

104
00:05:11,190 --> 00:05:13,590
fordi jeg ved det til
være fejlbehæftet på forhånd.

105
00:05:13,590 --> 00:05:17,400
Men jeg måske ikke klar over, at hvis dette
er den første eller anden eller tredje program

106
00:05:17,400 --> 00:05:18,830
at jeg faktisk gør mig selv.

107
00:05:18,830 --> 00:05:23,820
Så jeg har tænkt mig at gå videre og
skrive ud, int main (void).

108
00:05:23,820 --> 00:05:28,130
Og så indersiden af ​​mine krøllede parenteser,
en meget velkendt ( "Hej, verden-

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - og et semikolon.

110
00:05:30,980 --> 00:05:32,360
>> Jeg har gemt filen.

111
00:05:32,360 --> 00:05:34,850
Nu vil jeg gå ned
til min terminal vindue

112
00:05:34,850 --> 00:05:40,340
og type make buggy0, fordi igen,
navnet på filen dag buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Så jeg skriver gøre buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Og, åh, gosh, husker fra sidste gang
at ingen fejlmeddelelser er en god ting.

115
00:05:48,200 --> 00:05:49,740
Så ingen output er en god ting.

116
00:05:49,740 --> 00:05:52,920
Men her har jeg tydeligt
nogle antal fejl.

117
00:05:52,920 --> 00:05:56,470
>> Så den første linje af output
efter indtastning gøre buggy0, tilbagekaldelse,

118
00:05:56,470 --> 00:05:59,540
er Dunk er temmelig detaljeret output.

119
00:05:59,540 --> 00:06:02,067
Under kølerhjelmen,
CS50 IDE er konfigureret

120
00:06:02,067 --> 00:06:04,150
at bruge en hel masse
valgmuligheder med dette compiler

121
00:06:04,150 --> 00:06:05,941
så du ikke behøver
at tænke over dem.

122
00:06:05,941 --> 00:06:08,840
Og det er alt, første linje
midler, der starter med Dunk.

123
00:06:08,840 --> 00:06:11,720
>> Men efter det, de problemer
begynde at gøre deres udseende.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c på linje 3, karakter
5, er der en stor, rød fejl.

125
00:06:17,390 --> 00:06:18,380
Hvad er det?

126
00:06:18,380 --> 00:06:23,562
Implicit erklære biblioteksfunktionen
printf med type int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Jeg mener, det er meget hurtigt
bliver meget mystiske.

129
00:06:28,379 --> 00:06:30,170
Og helt sikkert, ved første
blik, ville vi ikke

130
00:06:30,170 --> 00:06:32,380
forventer, at du forstå
helhed af dette budskab.

131
00:06:32,380 --> 00:06:34,213
Og så en af ​​de erfaringer,
for i dag går

132
00:06:34,213 --> 00:06:36,919
at være at forsøge at lægge mærke
mønstre eller lignende ting,

133
00:06:36,919 --> 00:06:38,960
fejl, du måtte have
stødt i fortiden.

134
00:06:38,960 --> 00:06:41,335
Så lad os drille hinanden kun
disse ord, der ser bekendt.

135
00:06:41,335 --> 00:06:44,290
Den store, røde fejl er klart
symbol på noget at tage fejl.

136
00:06:44,290 --> 00:06:47,940
>> implicit erklære
biblioteksfunktionen printf.

137
00:06:47,940 --> 00:06:51,680
Så selv om jeg ikke helt forstår, hvad
implicit erklære biblioteksfunktionen

138
00:06:51,680 --> 00:06:54,900
midler, problemet sikkert
angår printf eller anden måde.

139
00:06:54,900 --> 00:06:59,130
Og kilden til dette spørgsmål
har at gøre med at erklære det.

140
00:06:59,130 --> 00:07:02,440
>> Erklære en funktion er
nævne det for første gang.

141
00:07:02,440 --> 00:07:06,210
Og vi brugte terminologi sidste uge
erklære en funktion prototype,

142
00:07:06,210 --> 00:07:11,860
enten med en linje i toppen af ​​din
egen fil eller i en såkaldt header fil.

143
00:07:11,860 --> 00:07:15,300
Og i hvilken fil gjorde vi siger
sidste uge, at printf er tilbud,

144
00:07:15,300 --> 00:07:17,080
citat slut, erklærede?

145
00:07:17,080 --> 00:07:20,950
I hvilken fil er dens prototype?

146
00:07:20,950 --> 00:07:24,640
>> Så hvis du husker, den allerførste ting, jeg
maskinskrevet, næsten hver program sidste time--

147
00:07:24,640 --> 00:07:30,790
og ved et uheld et øjeblik siden startede
skrive myself-- var denne ene her--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- for
input / output-- dot h Og ja,

149
00:07:38,630 --> 00:07:41,860
hvis jeg nu gemme denne fil, vil jeg
at gå videre og rydde min skærm,

150
00:07:41,860 --> 00:07:44,740
som du kan gøre ved at skrive
Klar, eller du kan holde Kontrol L,

151
00:07:44,740 --> 00:07:47,680
bare for at rydde din terminalvindue
blot at eliminere nogle rod.

152
00:07:47,680 --> 00:07:51,370
>> Jeg har tænkt mig at gå videre og
re-typen make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Og voila, jeg ser stadig, at
lange kommando fra Dunk,

154
00:07:53,790 --> 00:07:55,470
men der er ingen fejlmeddelelse denne gang.

155
00:07:55,470 --> 00:07:58,800
Og ja, hvis jeg gør ./buggy0,
ligesom sidste gang,

156
00:07:58,800 --> 00:08:01,860
hvor prik betyder dette
bibliotek, Slash betyder blot,

157
00:08:01,860 --> 00:08:05,040
her kommer navnet på programmet og
at navnet på det program er buggy0,

158
00:08:05,040 --> 00:08:07,340
Enter, "Hej, verden."

159
00:08:07,340 --> 00:08:09,440
>> Nu, hvordan kan du have
forstået denne opløsning

160
00:08:09,440 --> 00:08:12,017
uden nødvendigvis
anerkende så mange ord

161
00:08:12,017 --> 00:08:14,350
som jeg gjorde, i hvert fald, at have
gjort i så mange år?

162
00:08:14,350 --> 00:08:18,720
Nå, indser per det første problem
sæt, vi præsentere dig for en kommando

163
00:08:18,720 --> 00:08:21,175
at CS50 egne medarbejdere
skrev kaldet help50.

164
00:08:21,175 --> 00:08:24,300
Og ja, C gør specifikation for
problemet indstillet, hvordan man bruger dette.

165
00:08:24,300 --> 00:08:27,210
>> Men help50 det væsentlige
et program, der CS50 personale

166
00:08:27,210 --> 00:08:30,850
skrev der tillader dig at køre
en kommando eller køre et program,

167
00:08:30,850 --> 00:08:36,169
og hvis du ikke forstår sin
output, til at videregive sin produktion til help50,

168
00:08:36,169 --> 00:08:38,890
ved hvilket punkt software
at kurset personale skrev

169
00:08:38,890 --> 00:08:42,429
vil se på dit program output
linje for linje, tegn for tegn.

170
00:08:42,429 --> 00:08:46,000
Og hvis vi, personalet, genkende
fejlmeddelelse, du oplever,

171
00:08:46,000 --> 00:08:50,580
Vi vil forsøge at provokere dig med nogle
retoriske spørgsmål, med nogle råd,

172
00:08:50,580 --> 00:08:54,890
meget gerne en TF eller en CA eller mig selv
ville gøre personligt i kontortiden.

173
00:08:54,890 --> 00:08:58,320
>> Så se at help50 hvis du ikke gør
nødvendigvis genkende et problem.

174
00:08:58,320 --> 00:09:00,790
Men du behøver ikke stole på det
for meget som en krykke.

175
00:09:00,790 --> 00:09:03,990
Bestemt forsøge at forstå dens
output og derefter lære af det

176
00:09:03,990 --> 00:09:07,571
således at kun én eller to gange har du
nogensinde køre help50 til en bestemt fejl

177
00:09:07,571 --> 00:09:08,070
besked.

178
00:09:08,070 --> 00:09:10,660
Efter dette, skal du være
bedre rustet dig selv

179
00:09:10,660 --> 00:09:13,180
at finde ud af, hvad det egentlig er.

180
00:09:13,180 --> 00:09:14,350
>> Lad os lave en anden her.

181
00:09:14,350 --> 00:09:20,410
Lad mig gå videre, og i et andet
fil vi vil kalde denne buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Og i denne fil er jeg
vil deliberately--

183
00:09:23,110 --> 00:09:26,330
men lade som om jeg ikke
forstå, hvad fejl jeg har lavet.

184
00:09:26,330 --> 00:09:31,420
>> Jeg har tænkt mig at gå videre og gøre denne--
#include, da jeg har

185
00:09:31,420 --> 00:09:33,660
lært min lektie fra et øjeblik siden.

186
00:09:33,660 --> 00:09:36,220
Int main (void), som før.

187
00:09:36,220 --> 00:09:40,880
Og så herinde jeg har tænkt mig
at gøre string s - get_string.

188
00:09:40,880 --> 00:09:43,770
Og husker fra sidste gang, at
denne måde, hey, computer,

189
00:09:43,770 --> 00:09:48,280
give mig en variabel, kalder det s, og
gøre den type pågældende variabel en streng

190
00:09:48,280 --> 00:09:50,150
så jeg kan gemme et eller flere ord i det.

191
00:09:50,150 --> 00:09:52,191
>> Og så på højre hånd
side af lighedstegnet

192
00:09:52,191 --> 00:09:54,980
er get_string, som er en
funktion i CS50 Bibliotek

193
00:09:54,980 --> 00:09:55,980
der gør netop dette.

194
00:09:55,980 --> 00:09:59,740
Det bliver en funktion og derefter
hænder det fra højre til venstre.

195
00:09:59,740 --> 00:10:02,670
Så denne lighedstegn betyder ikke
"Lig" som vi måske tror i matematik.

196
00:10:02,670 --> 00:10:04,750
Det betyder overdragelse fra højre mod venstre.

197
00:10:04,750 --> 00:10:09,640
Så dette betyder, tage snoren fra
brugeren og gemme det inde i s.

198
00:10:09,640 --> 00:10:10,460
>> Lad os bruge den.

199
00:10:10,460 --> 00:10:13,820
Lad mig gå videre nu, og som en anden
line, lad mig gå videre og sige "Hej" -

200
00:10:13,820 --> 00:10:19,330
ikke "verden", men "Hej,% S--
som er vores pladsholder, komma s,

201
00:10:19,330 --> 00:10:22,030
som er vores variabel,
og derefter et semikolon.

202
00:10:22,030 --> 00:10:26,070
Så hvis jeg ikke skrue op for meget
her, det ligner rigtige kode.

203
00:10:26,070 --> 00:10:28,090
>> Og mine instinkter nu er at kompilere den.

204
00:10:28,090 --> 00:10:30,400
Filen hedder buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Så jeg har tænkt mig at gør buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Og darn-det, hvis der ikke er
endnu flere fejl end før.

207
00:10:36,377 --> 00:10:38,210
Jeg mener, der er mere
fejlmeddelelser det ville

208
00:10:38,210 --> 00:10:40,400
synes end faktiske linjer i dette program.

209
00:10:40,400 --> 00:10:42,730
>> Men takeaway her er,
selv om du er overvældet

210
00:10:42,730 --> 00:10:45,040
med to eller tre eller
fire flere fejlmeddelelser,

211
00:10:45,040 --> 00:10:48,340
fokus altid på den meget
første af disse meddelelser.

212
00:10:48,340 --> 00:10:52,220
Ser man på den øverste mest en,
rulle tilbage op som nødvendigt.

213
00:10:52,220 --> 00:10:53,930
Så her har skrevet jeg make buggy1.

214
00:10:53,930 --> 00:10:55,700
Her er der Dunk output som forventet.

215
00:10:55,700 --> 00:10:57,290
>> Og her er den første røde fejl.

216
00:10:57,290 --> 00:11:02,370
Anvendelse af sort identifikator
snor, jeg mener standard i?

217
00:11:02,370 --> 00:11:04,260
Så standard in er
faktisk noget andet.

218
00:11:04,260 --> 00:11:06,240
Det refererer til brugerens
tastatur, i det væsentlige.

219
00:11:06,240 --> 00:11:08,080
>> Men det er ikke det, jeg mente.

220
00:11:08,080 --> 00:11:11,770
Jeg mente streng, og jeg mente get_string.

221
00:11:11,770 --> 00:11:16,200
Så hvad er det, at jeg
glemte at gøre denne gang?

222
00:11:16,200 --> 00:11:20,230
Hvad mangler denne gang?

223
00:11:20,230 --> 00:11:23,600
Jeg har min #include,
så jeg har adgang til printf.

224
00:11:23,600 --> 00:11:26,090
>> Men hvad har jeg ikke
adgang til endnu?

225
00:11:26,090 --> 00:11:29,420
Nå, ligesom sidste gang,
Jeg har brug for at fortælle compileren

226
00:11:29,420 --> 00:11:31,691
Klang, hvad disse funktioner er.

227
00:11:31,691 --> 00:11:33,940
Get_string kommer ikke
med C. Og i særdeleshed, det

228
00:11:33,940 --> 00:11:38,160
ikke kommer i
header fil,.

229
00:11:38,160 --> 00:11:40,770
Det i stedet kommer i
noget personalet skrev,

230
00:11:40,770 --> 00:11:44,176
som er en anden fil
navn, men rammende navngivet.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Så blot ved at tilføje, at en linje
af code-- tilbagekaldelse fra sidste gang

233
00:11:50,861 --> 00:11:53,610
at når Dunk kører, går det
til at se på min kode top til bund,

234
00:11:53,610 --> 00:11:54,193
venstre til højre.

235
00:11:54,193 --> 00:11:57,200
Det kommer til at lægge mærke til,
Åh, du ønsker.

236
00:11:57,200 --> 00:11:59,900
Lad mig gå ud og finde det,
hvor det er på serveren,

237
00:11:59,900 --> 00:12:03,090
kopiere og indsætte det væsentlige,
i toppen af ​​din egen fil

238
00:12:03,090 --> 00:12:06,820
så på dette tidspunkt i historien,
linie 1, resten af ​​programmet

239
00:12:06,820 --> 00:12:11,651
kan, ja, bruge nogen af ​​de funktioner
deri, blandt dem get_string.

240
00:12:11,651 --> 00:12:13,650
Så jeg har tænkt mig at ignorere
resten af ​​disse fejl,

241
00:12:13,650 --> 00:12:17,190
fordi jeg, ja, har mistanke om, at kun
den første faktisk betød noget.

242
00:12:17,190 --> 00:12:20,780
Og jeg har tænkt mig at gå videre og gentagelsen,
efter at redde mit fil gør buggy1.

243
00:12:20,780 --> 00:12:22,580
Og voila, det virkede.

244
00:12:22,580 --> 00:12:29,200
Og hvis jeg gør ./buggy1 og skriv, for
Eksempelvis Zamyla, jeg nu vil få goddag,

245
00:12:29,200 --> 00:12:32,000
Zamyla, i stedet for hej, verden.

246
00:12:32,000 --> 00:12:32,550
>> Okay.

247
00:12:32,550 --> 00:12:35,890
Så grillbarer her så skal,
en, så prøv at indsamle så meget som du kan

248
00:12:35,890 --> 00:12:39,140
fra fejlmeddelelser alene, ser
på nogle af de genkendelige ord.

249
00:12:39,140 --> 00:12:43,070
Spærring at bruge help50 pr
problemet indstillet specifikation.

250
00:12:43,070 --> 00:12:46,500
Men spærring, at også, altid ser
øverst fejlen kun, i det mindste

251
00:12:46,500 --> 00:12:50,051
i første omgang, for at se, hvilke oplysninger
det kan faktisk give.

252
00:12:50,051 --> 00:12:52,300
Men det viser sig at der er
endnu mere funktionalitet bygget

253
00:12:52,300 --> 00:12:55,030
i CS50 Bibliotek til at hjælpe
du tidligt i semesteret

254
00:12:55,030 --> 00:12:57,580
og tidligt i programmering
regne ud hvad der går galt.

255
00:12:57,580 --> 00:12:59,840
Så lad os gøre et andet eksempel her.

256
00:12:59,840 --> 00:13:04,350
Jeg har tænkt mig at kalde denne buggy2, som,
igen, vil være behæftet med fejl ud

257
00:13:04,350 --> 00:13:05,650
af porten, ved design.

258
00:13:05,650 --> 00:13:09,980
>> Og jeg har tænkt mig at gå videre
og gøre #include.

259
00:13:09,980 --> 00:13:12,580
Og så jeg har tænkt mig at gøre int main (void).

260
00:13:12,580 --> 00:13:14,840
Og så jeg har tænkt mig at lave en for-løkke.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i er mindre end eller lig med 10.

263
00:13:18,750 --> 00:13:24,260
Jeg ++, og derefter i krøllede parenteser, vil jeg
at udskrive bare en hashtag symbol her

264
00:13:24,260 --> 00:13:25,920
og en ny linje karakter.

265
00:13:25,920 --> 00:13:29,220
>> Så min hensigt med dette
Programmet er ganske enkelt

266
00:13:29,220 --> 00:13:33,150
at gentage 10 gange
og på hver iteration

267
00:13:33,150 --> 00:13:35,260
af denne løkke hver gang
gennem cyklussen,

268
00:13:35,260 --> 00:13:37,660
udskrive en hashtag,
et hashtag, et hashtag.

269
00:13:37,660 --> 00:13:40,480
En pr linje, fordi jeg
har den nye linje der.

270
00:13:40,480 --> 00:13:42,787
Og minde om, at for
loop, per sidste week--

271
00:13:42,787 --> 00:13:44,620
og du får mere
bekendt med syntaksen

272
00:13:44,620 --> 00:13:47,170
ved at bruge det med praksis
før long-- det giver mig

273
00:13:47,170 --> 00:13:49,740
en variabel kaldet jeg og sætter den til 0.

274
00:13:49,740 --> 00:13:52,650
>> Dette intervaller jeg på
hver iteration af en.

275
00:13:52,650 --> 00:13:54,940
Så jeg går til 1 til 2 til 3.

276
00:13:54,940 --> 00:13:57,690
Og derefter denne tilstand i
midten mellem semikolon

277
00:13:57,690 --> 00:14:03,010
bliver kontrolleret på hver iteration for at gøre
sikker på, at vi stadig er inden for rækkevidde.

278
00:14:03,010 --> 00:14:06,830
Så jeg vil gerne gentage 10 gange, så jeg
har slags meget intuitivt bare

279
00:14:06,830 --> 00:14:09,070
sætte 10 som min øvre grænse der.

280
00:14:09,070 --> 00:14:14,310
>> Og dog, når jeg kører dette, efter
kompilere den med make buggy2--

281
00:14:14,310 --> 00:14:15,440
og det gør kompilere OK.

282
00:14:15,440 --> 00:14:17,980
Så jeg har ikke en
syntaksfejl denne gang.

283
00:14:17,980 --> 00:14:20,940
Lad mig gå videre nu
og køre buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Og nu rulle op.

285
00:14:22,620 --> 00:14:24,890
Og lad mig øge
størrelsen af ​​vinduet.

286
00:14:24,890 --> 00:14:33,720
>> Jeg synes at have 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Så der er 11 hashtags, selvom
Jeg klart sætte 10 inde i denne sløjfe.

288
00:14:38,891 --> 00:14:42,140
Nu kan nogle af jer se straks
hvad fejlen skyldes, ja, dette

289
00:14:42,140 --> 00:14:43,720
er ikke en meget hård fejl at gøre.

290
00:14:43,720 --> 00:14:46,070
Men det er meget almindeligt
gjort meget tidligt.

291
00:14:46,070 --> 00:14:49,820
>> Hvad jeg vil påpege, selv om,
er, hvordan kan jeg regne det ud?

292
00:14:49,820 --> 00:14:52,300
Tja, det viser sig, at
Den CS50 Bibliotek kommer

293
00:14:52,300 --> 00:14:55,380
med ikke kun get_string og get_int
og get_float og andre funktioner.

294
00:14:55,380 --> 00:14:59,980
Det leveres også med en speciel funktion
kaldet eprintf, eller, fejl printf.

295
00:14:59,980 --> 00:15:03,270
Og det udelukkende eksisterer for at gøre
det lidt nemmere for dig

296
00:15:03,270 --> 00:15:06,310
når fejlfinding din kode til bare
udskrive en fejlmeddelelse på skærmen

297
00:15:06,310 --> 00:15:07,850
og vide, hvor det kom fra.

298
00:15:07,850 --> 00:15:11,000
>> Så for eksempel, en ting jeg kunne
gøre her med denne funktion er denne--

299
00:15:11,000 --> 00:15:20,230
eprintf, og så jeg har tænkt mig at gå videre
og sige, at jeg nu er% i, omvendt skråstreg, n.

300
00:15:20,230 --> 00:15:22,330
Og jeg har tænkt mig at sætte i værdien af ​​i.

301
00:15:22,330 --> 00:15:25,400
Og op top, fordi dette
er i CS50 Bibliotek,

302
00:15:25,400 --> 00:15:27,580
Jeg har tænkt mig at gå videre
og indbefatter

303
00:15:27,580 --> 00:15:29,169
så jeg har adgang til denne funktion.

304
00:15:29,169 --> 00:15:31,460
Men lad os overveje, hvad linje
9 formodes at gøre.

305
00:15:31,460 --> 00:15:32,670
Jeg har tænkt mig at slette denne i sidste ende.

306
00:15:32,670 --> 00:15:34,670
Dette har intet at gøre
med min overordnede mål.

307
00:15:34,670 --> 00:15:39,090
Men eprintf, fejl printf er bare ment
at give mig nogle diagnostisk information.

308
00:15:39,090 --> 00:15:42,460
Når jeg kører mit program, jeg ønsker at
se på skærmen midlertidigt

309
00:15:42,460 --> 00:15:44,550
så godt bare at forstå
hvad sker der.

310
00:15:44,550 --> 00:15:47,330
>> Og endog på hver
iteration her for linje 9

311
00:15:47,330 --> 00:15:49,260
Jeg ønsker at se, hvad er værdien af ​​i?

312
00:15:49,260 --> 00:15:50,290
Hvad er værdien af ​​jeg?

313
00:15:50,290 --> 00:15:51,280
Hvad er værdien af ​​jeg?

314
00:15:51,280 --> 00:15:55,650
Og forhåbentlig skal jeg kun
se, at budskabet, også, 10 gange.

315
00:15:55,650 --> 00:15:57,780
>> Så lad mig gå videre og
kompilere mit program,

316
00:15:57,780 --> 00:15:59,905
som jeg er nødt til at gøre nogen tid
Jeg foretager en ændring. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Og nu-- OK.

319
00:16:03,640 --> 00:16:04,820
Der er meget mere foregår.

320
00:16:04,820 --> 00:16:07,610
Så lad mig rulle op i
en endnu større vindue.

321
00:16:07,610 --> 00:16:10,190
>> Og du vil se, at hver af
den hashtags stadig udskrives.

322
00:16:10,190 --> 00:16:15,270
Men i mellem hver af dem er nu dette
diagnostisk output formateret som følger.

323
00:16:15,270 --> 00:16:17,960
Navnet på mit program her er buggy2.

324
00:16:17,960 --> 00:16:20,432
Navnet på filen er buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Linjenummeret hvorfra
dette blev trykt, er linie 9.

326
00:16:24,080 --> 00:16:27,500
Og derefter til højre for dette er
fejlmeddelelse, jeg forventer.

327
00:16:27,500 --> 00:16:30,701
>> Og hvad er nice om dette er, at
nu har jeg ikke nødvendigvis regne

328
00:16:30,701 --> 00:16:32,200
i mit hoved, hvad mit program gør.

329
00:16:32,200 --> 00:16:34,240
Jeg kan se, at på
første iteration i er 0,

330
00:16:34,240 --> 00:16:39,420
derefter 1, derefter 2, derefter 3, så 4, så
5 og derefter 6 og derefter 7, så 8, derefter 9, derefter

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Så vent et øjeblik.

333
00:16:42,050 --> 00:16:43,740
Hvad sker der her?

334
00:16:43,740 --> 00:16:48,190
Jeg synes stadig at være tælle
som tilsigtet op til 10.

335
00:16:48,190 --> 00:16:50,550
>> Men hvor har jeg starte?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Så 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- det 11. finger

338
00:16:58,040 --> 00:16:59,990
er indikativ for problemet.

339
00:16:59,990 --> 00:17:02,850
Jeg synes at have talt
forkert i mit loop.

340
00:17:02,850 --> 00:17:06,599
Snarere end at gå 10 iterationer,
Jeg starter ved 0,

341
00:17:06,599 --> 00:17:09,550
Jeg slutter ved og gennem ti.

342
00:17:09,550 --> 00:17:12,030
Men fordi, som en computer,
Jeg begynder at tælle ved 0,

343
00:17:12,030 --> 00:17:15,250
Jeg skal tælle op
til, men ikke gennem, 10.

344
00:17:15,250 --> 00:17:18,510
>> Og så rettelsen, jeg til sidst
realiseres her, er en af ​​to ting.

345
00:17:18,510 --> 00:17:22,430
Jeg kunne meget enkelt sige
tælle op til mindre end 10.

346
00:17:22,430 --> 00:17:27,260
Så 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, som er faktisk korrekt,

347
00:17:27,260 --> 00:17:28,900
selv om det lyder lidt forkert.

348
00:17:28,900 --> 00:17:35,070
Eller jeg kunne gøre mindre end eller lig
til 9, så længe jeg starter ved 0.

349
00:17:35,070 --> 00:17:40,056
Eller hvis du virkelig ikke kan lide det, du
kan tælle op til 10, men starter på en.

350
00:17:40,056 --> 00:17:41,680
Men igen, dette er bare ikke det fælles.

351
00:17:41,680 --> 00:17:43,977
I programming-- omend
ikke så meget i Scratch--

352
00:17:43,977 --> 00:17:45,810
men i programmering i
C og andre sprog,

353
00:17:45,810 --> 00:17:47,670
ligesom JavaScript og
Python og andre, det er

354
00:17:47,670 --> 00:17:49,880
bare meget almindeligt for
vores diskussion af binære

355
00:17:49,880 --> 00:17:53,450
at bare begynde at tælle på
laveste antal du kan, hvilket er 0.

356
00:17:53,450 --> 00:17:53,950
Okay.

357
00:17:53,950 --> 00:17:55,160
Så det er eprintf.

358
00:17:55,160 --> 00:17:58,600
Og igen, nu hvor jeg har fundet ud af min
problem, og jeg har tænkt mig at gå tilbage til 0

359
00:17:58,600 --> 00:18:01,470
gennem mindre end 10, vil jeg
at gå ind og slette eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Det bør ikke være der, når jeg
skib min kode eller sende min kode

361
00:18:04,580 --> 00:18:05,800
eller vise det til nogen anden.

362
00:18:05,800 --> 00:18:07,980
Det er virkelig bare betød
kan anvendes foreløbigt.

363
00:18:07,980 --> 00:18:11,650
Men nu har jeg løst dette
særligt problem samt.

364
00:18:11,650 --> 00:18:16,780
>> Nå, lad os gøre endnu et eksempel her
at jeg har tænkt mig at piske op som følger.

365
00:18:16,780 --> 00:18:22,850
Jeg har tænkt mig at gå videre og
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
Og jeg har tænkt mig at gå videre
og #include.

367
00:18:25,580 --> 00:18:29,030
>> Og jeg har tænkt mig at spare
denne fil som buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Og jeg har tænkt mig at gå videre
og erklære int main (void).

369
00:18:31,740 --> 00:18:34,186
Og derefter inderside der
Jeg har tænkt mig at gøre int i _ -

370
00:18:34,186 --> 00:18:36,435
Jeg ønsker at gennemføre et program
med en get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Dette er ikke en funktion, der eksisterer endnu.

373
00:18:40,770 --> 00:18:42,870
Så vi kommer til at gennemføre
det på blot et øjeblik.

374
00:18:42,870 --> 00:18:45,541
Men vi kommer til at se, hvorfor
det er buggy ved første passage.

375
00:18:45,541 --> 00:18:47,290
Og når jeg har fået
en int fra brugeren,

376
00:18:47,290 --> 00:18:53,365
Jeg skal bare udskrive% i er en negativ
heltal, omvendt skråstreg, n, komma, i.

377
00:18:53,365 --> 00:18:55,240
Med andre ord, alle I
ønsker dette program til at gøre

378
00:18:55,240 --> 00:18:58,000
er at få en negativ int fra
brugeren og derefter udskrive

379
00:18:58,000 --> 00:18:59,980
at den og den er en negativ int.

380
00:18:59,980 --> 00:19:02,080
>> Nu har jeg brug for at gennemføre denne funktion.

381
00:19:02,080 --> 00:19:05,740
Så senere i min fil, vil jeg gå
videre og erklære en funktion kaldet

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - og vi vil
komme tilbage til hvad denne linje betyder igen

383
00:19:10,670 --> 00:19:18,790
i en moment-- int n; do-- do
den following-- printf n er :.

384
00:19:18,790 --> 00:19:26,210
Og så jeg har tænkt mig at gøre n - get_int,
og gøre dette, mens n er større end 0.

385
00:19:26,210 --> 00:19:28,310
Og derefter vende tilbage n ;.

386
00:19:28,310 --> 00:19:31,730
>> Så der er en masse i gang i
dette, men ingen af ​​dem vi ikke

387
00:19:31,730 --> 00:19:33,710
se på i sidste uge, i det mindste kortvarigt.

388
00:19:33,710 --> 00:19:36,980
Så på linje 10 her har jeg erklæret
funktion kaldet get_negative_int,

389
00:19:36,980 --> 00:19:39,620
og jeg har lagt (void), i
parenteser, årsagen er dette

390
00:19:39,620 --> 00:19:40,950
tager ikke en indgang.

391
00:19:40,950 --> 00:19:42,910
Jeg er ikke passerer noget
til denne funktion.

392
00:19:42,910 --> 00:19:44,690
Jeg er bare at få noget tilbage fra den.

393
00:19:44,690 --> 00:19:47,270
>> Og hvad jeg håber at
få tilbage er et helt tal.

394
00:19:47,270 --> 00:19:50,040
Der er ingen datatype i
C kaldes negative_int.

395
00:19:50,040 --> 00:19:52,880
Det er bare int, så det vil
at være på os for at sikre

396
00:19:52,880 --> 00:19:55,340
at den værdi, der er faktisk
Returneret er ikke kun en int

397
00:19:55,340 --> 00:19:56,380
men er også negativ.

398
00:19:56,380 --> 00:20:02,150
>> På linje 12 jeg erklære en variabel
kaldet n og gøre det af typen int.

399
00:20:02,150 --> 00:20:07,500
Og så i linje 13 til 18 jeg er
gør noget, mens noget er sandt.

400
00:20:07,500 --> 00:20:11,040
Jeg har tænkt mig videre og udskrivning
n er, colon, og derefter et mellemrum,

401
00:20:11,040 --> 00:20:12,800
som en prompt for brugeren.

402
00:20:12,800 --> 00:20:16,410
>> Jeg derefter ringer get_int og
lagring sin såkaldte returværdi

403
00:20:16,410 --> 00:20:18,130
i denne variabel n.

404
00:20:18,130 --> 00:20:22,600
Men jeg har tænkt mig at holde gør
dette, mens n er større end 0.

405
00:20:22,600 --> 00:20:27,960
Med andre ord, hvis brugeren giver mig en
int og at antallet er større end 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positive, jeg har tænkt mig at
bare holde reprompting brugeren,

407
00:20:31,180 --> 00:20:37,160
holde reprompting, ved at tvinge dem til
samarbejde og give mig en negativ int.

408
00:20:37,160 --> 00:20:41,640
>> Og når n er faktisk negative--
Antag brugeren endelig typer -50,

409
00:20:41,640 --> 00:20:46,710
så dette, mens loop er ikke længere sandt
fordi -50 ikke er større end 0.

410
00:20:46,710 --> 00:20:51,140
Så vi bryde ud af det
loop logisk og vende tilbage n.

411
00:20:51,140 --> 00:20:53,520
>> Men der er et andet
ting jeg skal gøre.

412
00:20:53,520 --> 00:20:56,190
Og jeg kan simpelthen gøre dette
ved at kopiere og indsætte

413
00:20:56,190 --> 00:20:58,540
én linje kode i toppen af ​​filen.

414
00:20:58,540 --> 00:21:01,630
Jeg har brug for at lære Dunk,
eller lover at clang,

415
00:21:01,630 --> 00:21:04,630
udtrykkeligt, at jeg vil,
ja, gå og implementere

416
00:21:04,630 --> 00:21:06,020
denne funktion get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Det kunne bare være lavere i filen.

418
00:21:07,674 --> 00:21:09,840
Igen, minde om, at Dunk
læser tingene top til bund,

419
00:21:09,840 --> 00:21:12,330
venstre til højre, så kan du ikke
kalde en funktion, hvis Dunk

420
00:21:12,330 --> 00:21:15,330
ved det ikke kommer til at eksistere.

421
00:21:15,330 --> 00:21:18,430
>> Nu desværre dette program,
som nogle af jer måske har bemærket,

422
00:21:18,430 --> 00:21:19,590
er allerede buggy.

423
00:21:19,590 --> 00:21:21,400
Lad mig gå videre og gøre buggy3.

424
00:21:21,400 --> 00:21:26,904
Det samler, så mit problem nu ikke er
en syntaksfejl, ligesom en tekstuel fejl,

425
00:21:26,904 --> 00:21:29,570
Det er faktisk kommer til at være en logisk
fejl, som jeg har med vilje

426
00:21:29,570 --> 00:21:32,450
lavet som en mulighed for at
gå gennem hvad der foregår.

427
00:21:32,450 --> 00:21:35,540
>> Jeg har tænkt mig at gå videre
nu og køre buggy3.

428
00:21:35,540 --> 00:21:37,490
Og jeg har tænkt mig at gå
fremad og ikke samarbejder.

429
00:21:37,490 --> 00:21:39,494
Jeg har tænkt mig at give det nummer 1.

430
00:21:39,494 --> 00:21:41,410
Det kunne ikke lide det, så
det er at spørge mig igen.

431
00:21:41,410 --> 00:21:42,147
>> Hvad med 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Ingen af ​​dem arbejder.

435
00:21:44,740 --> 00:21:46,890
Hvad med -50?

436
00:21:46,890 --> 00:21:48,560
Og programmet synes at virke.

437
00:21:48,560 --> 00:21:49,970
>> Lad mig prøve det en gang mere.

438
00:21:49,970 --> 00:21:53,400
Lad mig prøve -1, synes at virke.

439
00:21:53,400 --> 00:21:56,380
Lad mig prøve -2, synes at virke.

440
00:21:56,380 --> 00:21:59,640
Lad mig prøve 0.

441
00:21:59,640 --> 00:22:01,684
Huh, det er forkert.

442
00:22:01,684 --> 00:22:03,350
Nu er vi er lidt pedantisk her.

443
00:22:03,350 --> 00:22:07,090
Men det er faktisk sådan, at 0
hverken positiv eller negativ.

444
00:22:07,090 --> 00:22:11,150
Og så det faktum, at mit program er
sige, at 0 er et negativt heltal,

445
00:22:11,150 --> 00:22:12,820
det er ikke teknisk korrekt.

446
00:22:12,820 --> 00:22:15,180
>> Nu, hvorfor er det at gøre dette?

447
00:22:15,180 --> 00:22:16,270
Nå, kan det være indlysende.

448
00:22:16,270 --> 00:22:18,110
Og faktisk er programmet
beregnet til at være forholdsvis enkel

449
00:22:18,110 --> 00:22:19,670
så vi har noget at udforske.

450
00:22:19,670 --> 00:22:25,870
>> Men lad os indføre en tredje debugging
teknik her kaldet debug50.

451
00:22:25,870 --> 00:22:27,750
Så dette er et program
at vi netop har oprettet

452
00:22:27,750 --> 00:22:30,770
i år kaldet debug50
som vil give dig

453
00:22:30,770 --> 00:22:34,130
at bruge, hvad der kaldes en indbygget
grafisk debugger i CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Og en debugger er bare et program,
generelt kan du køre dit program

455
00:22:38,400 --> 00:22:44,050
men skridt for skridt for skridt, linje
ved linje for linje, pause, stikke

456
00:22:44,050 --> 00:22:47,626
rundt, ser på variabler, således at
programmet ikke bare blæse forbi dig

457
00:22:47,626 --> 00:22:49,750
og hurtigt udskrive noget
eller ikke udskrive noget.

458
00:22:49,750 --> 00:22:53,250
Det giver dig en mulighed, på
human hastighed, til at interagere med den.

459
00:22:53,250 --> 00:22:55,470
>> Og for at gøre dette, du
blot gøre følgende.

460
00:22:55,470 --> 00:22:58,479
Efter kompilere din kode,
som jeg allerede gjorde, buggy3,

461
00:22:58,479 --> 00:23:00,020
du gå videre og køre debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Så meget som help50 har du løber
help50 og derefter kommandoen,

464
00:23:06,760 --> 00:23:10,120
debug50 har du kører debug50 og
derefter navnet på kommandoen.

465
00:23:10,120 --> 00:23:14,440
>> Nu se hvad der sker på min skærm,
på højre side i særdeleshed.

466
00:23:14,440 --> 00:23:19,400
Da jeg ramte Run, alle af
pludselig denne højre panel

467
00:23:19,400 --> 00:23:20,419
åbner op på skærmen.

468
00:23:20,419 --> 00:23:22,210
Og der er en masse i gang
på ved første øjekast.

469
00:23:22,210 --> 00:23:25,110
Men der er ikke er for
meget at bekymre sig om endnu.

470
00:23:25,110 --> 00:23:28,570
>> Dette viser mig alt
der foregår inde i mit program

471
00:23:28,570 --> 00:23:31,130
lige nu, og via disse
knapper op toppen er derefter

472
00:23:31,130 --> 00:23:35,910
tillader mig at gå gennem min kode
i sidste ende trin for trin for trin.

473
00:23:35,910 --> 00:23:37,140
Men ikke endnu.

474
00:23:37,140 --> 00:23:38,060
Læg mærke til, hvad der sker.

475
00:23:38,060 --> 00:23:40,600
På mit terminalvindue
Jeg bliver bedt om n.

476
00:23:40,600 --> 00:23:44,560
Og jeg har tænkt mig at gå videre og
samarbejde denne gang og skrive i -1.

477
00:23:44,560 --> 00:23:48,770
Og omend lidt kryptisk, -1
er et negativt heltal, som forventet.

478
00:23:48,770 --> 00:23:52,020
>> Og så barn afsluttede med
status 0 GDBserver spændende.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, er navnet
af den underliggende software

480
00:23:55,180 --> 00:23:56,620
der implementerer denne debugger.

481
00:23:56,620 --> 00:24:00,500
Men alt dette egentlig betyder, fejlsøgeren
gik væk, fordi mit program afslutte

482
00:24:00,500 --> 00:24:01,710
og alt var godt.

483
00:24:01,710 --> 00:24:06,020
Hvis jeg vil virkelig debug mit program,
Jeg er nødt til forebyggende fortælle debug50,

484
00:24:06,020 --> 00:24:08,920
hvor skal jeg ønsker at starte
stepping gennem min kode?

485
00:24:08,920 --> 00:24:11,750
>> Og måske den enkleste måde
at gøre det er som følger.

486
00:24:11,750 --> 00:24:15,300
Hvis jeg svæve over
tagrende af min redaktør her,

487
00:24:15,300 --> 00:24:19,090
så virkelig bare i sidebjælken her,
til venstre for linje nummer,

488
00:24:19,090 --> 00:24:21,870
Bemærk, at hvis jeg bare klikke
gang, jeg satte en lille rød prik.

489
00:24:21,870 --> 00:24:24,460
Og den lille røde prik,
ligesom et stopskilt, betyder, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, pause udførelse af min kode
lige der, når jeg kører dette program.

491
00:24:29,430 --> 00:24:30,260
>> Så lad os gøre det.

492
00:24:30,260 --> 00:24:37,340
Lad mig gå videre og køre mit program
igen med debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Og nu, varsel, noget
anderledes er sket.

494
00:24:40,110 --> 00:24:42,440
Jeg er ikke blevet bedt om
men i mit terminalvindue

495
00:24:42,440 --> 00:24:45,430
til noget, fordi jeg har ikke
fået der endnu i mit program.

496
00:24:45,430 --> 00:24:47,950
Bemærk, at på linje 8
som nu fremhæves,

497
00:24:47,950 --> 00:24:51,720
og der er en lille pil på
venstre ordsprog, du er sat på pause her.

498
00:24:51,720 --> 00:24:55,030
Denne linje kode, linje
8, er endnu ikke gennemført.

499
00:24:55,030 --> 00:24:58,940
>> Og hvad er nysgerrig, hvis jeg ser
her på den højre side,

500
00:24:58,940 --> 00:25:03,530
bemærke, at jeg er en lokal
variabel, lokal i den forstand

501
00:25:03,530 --> 00:25:05,450
at det er inde i aktuelle funktion.

502
00:25:05,450 --> 00:25:08,920
Og dens værdi, tilsyneladende som standard,
og sortering af bekvemt, er 0.

503
00:25:08,920 --> 00:25:10,260
Men jeg havde ikke skrive 0.

504
00:25:10,260 --> 00:25:13,410
Det bare sker for at være sin
standardværdi i øjeblikket.

505
00:25:13,410 --> 00:25:15,490
>> Så lad mig gå videre og gøre det nu.

506
00:25:15,490 --> 00:25:18,680
Lad mig gå videre og på
Øverst til højre her, jeg er

507
00:25:18,680 --> 00:25:20,970
kommer til at gå videre og
klik på denne første ikon, som

508
00:25:20,970 --> 00:25:25,360
betyder trin over hvilke betyder ikke springe
det men trin over denne linje kode,

509
00:25:25,360 --> 00:25:27,770
udfører den undervejs.

510
00:25:27,770 --> 00:25:30,710
>> Og nu, mærke, min
prompt har lige ændret.

511
00:25:30,710 --> 00:25:31,380
Hvorfor det?

512
00:25:31,380 --> 00:25:33,639
Jeg har fortalt debug50,
køre denne linje kode.

513
00:25:33,639 --> 00:25:34,930
Hvad betyder denne linje kode gøre?

514
00:25:34,930 --> 00:25:35,960
Spørger mig for en int.

515
00:25:35,960 --> 00:25:36,460
OKAY.

516
00:25:36,460 --> 00:25:37,400
Lad mig samarbejde.

517
00:25:37,400 --> 00:25:41,340
Lad mig gå videre nu og skriv -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Og nu mærke til, hvad der har ændret sig.

519
00:25:42,920 --> 00:25:46,060
På den højre side,
min lokale variabel i

520
00:25:46,060 --> 00:25:48,200
er angivet som værende -1 nu.

521
00:25:48,200 --> 00:25:49,810
Og det er stadig af typen int.

522
00:25:49,810 --> 00:25:53,102
>> Og varsel, også, min såkaldte
kalder stakken, hvor har jeg pause?

523
00:25:53,102 --> 00:25:54,810
Vi taler mere om
dette i fremtiden.

524
00:25:54,810 --> 00:25:58,620
Men kaldstakkens henviser blot til, hvad
funktioner er i øjeblikket i bevægelse.

525
00:25:58,620 --> 00:26:00,040
Lige nu er det bare main.

526
00:26:00,040 --> 00:26:03,590
Og lige nu er den eneste lokale
variabel er i med en værdi på 1.

527
00:26:03,590 --> 00:26:09,840
>> Og når jeg endelig træde over denne linje
her, med den samme ikon øverst til højre,

528
00:26:09,840 --> 00:26:11,410
-1 Er et negativt heltal.

529
00:26:11,410 --> 00:26:13,580
Nu er det pause over den krøllede tandbøjle.

530
00:26:13,580 --> 00:26:14,740
Lad os lade det gøre sit ting.

531
00:26:14,740 --> 00:26:17,300
Jeg træde over denne linje, og voila.

532
00:26:17,300 --> 00:26:20,240
>> Så ikke alt, frygtelig
oplysende endnu,

533
00:26:20,240 --> 00:26:23,550
men det lod mig pause
og tænke igennem logisk

534
00:26:23,550 --> 00:26:24,870
hvad dette program gør.

535
00:26:24,870 --> 00:26:26,890
Men det var ikke den fejlagtige tilfældet.

536
00:26:26,890 --> 00:26:28,510
Lad os gøre det igen som følger.

537
00:26:28,510 --> 00:26:31,340
>> Jeg har tænkt mig at forlade denne breakpoint
på linje 8 med den røde prik.

538
00:26:31,340 --> 00:26:32,830
Jeg har tænkt mig at kør debug50.

539
00:26:32,830 --> 00:26:34,400
Det er automatisk sat på pause her.

540
00:26:34,400 --> 00:26:37,660
Men denne gang, i stedet for
stepping over denne linje,

541
00:26:37,660 --> 00:26:42,290
lad mig faktisk gå inde i
get_negative_int og finde ud af,

542
00:26:42,290 --> 00:26:45,530
hvorfor er det at acceptere 0 som en gyldig svar?

543
00:26:45,530 --> 00:26:47,990
>> Så i stedet for at klikke Step Over.

544
00:26:47,990 --> 00:26:50,630
Jeg har tænkt mig at gå videre
og klik Step Into.

545
00:26:50,630 --> 00:26:54,030
Og bemærk, at linje 8, der er
nu fremhævet nu pludselig

546
00:26:54,030 --> 00:26:56,900
bliver ledning 17.

547
00:26:56,900 --> 00:26:59,947
>> Nu er det ikke, at debugger
har sprunget linjer 14 og 15 og 16.

548
00:26:59,947 --> 00:27:01,780
Det er bare der ikke er noget
at vise dig der.

549
00:27:01,780 --> 00:27:04,050
De er bare erklære variabler,
og så er der ordet Do

550
00:27:04,050 --> 00:27:05,390
og derefter en åben krøllet brace.

551
00:27:05,390 --> 00:27:09,227
Det eneste funktionelle linje, der er
saftig virkelig denne ene her, 17.

552
00:27:09,227 --> 00:27:11,060
Og det er, hvor vi har
standsede automatisk.

553
00:27:11,060 --> 00:27:13,870
>> Så printf ( "n.is:") ;, så
der er ikke sket endnu.

554
00:27:13,870 --> 00:27:18,250
Så lad os gå videre og klik Step Over.

555
00:27:18,250 --> 00:27:20,326
Nu er min prompt, ja,
ændret til ( "n er:").

556
00:27:20,326 --> 00:27:22,450
Nu get_int, jeg har ikke tænkt mig
at genere træde ind,

557
00:27:22,450 --> 00:27:24,750
fordi denne funktion var
lavet af CS50 i biblioteket.

558
00:27:24,750 --> 00:27:25,750
Det er formentlig korrekt.

559
00:27:25,750 --> 00:27:28,440
>> Så jeg har tænkt mig at gå videre og
slags samarbejde ved at give det

560
00:27:28,440 --> 00:27:30,590
en int, men ikke en negativ int.

561
00:27:30,590 --> 00:27:32,870
Så lad mig gå videre og ramte 0.

562
00:27:32,870 --> 00:27:39,460
Og nu, hvad der sker her
når jeg kommer ned til linje 21?

563
00:27:39,460 --> 00:27:40,890
Jeg har ikke gentages igen.

564
00:27:40,890 --> 00:27:43,320
Jeg synes ikke at blive hængende i den løkke.

565
00:27:43,320 --> 00:27:45,990
Med andre ord, denne gule
bar holde ikke går rundt,

566
00:27:45,990 --> 00:27:47,130
og omkring, og omkring.

567
00:27:47,130 --> 00:27:48,340
>> Nu, hvorfor er det?

568
00:27:48,340 --> 00:27:49,920
Nå, n, hvad er N lige nu?

569
00:27:49,920 --> 00:27:53,280
Jeg kan se på det lokale
variabler i debugger.

570
00:27:53,280 --> 00:27:53,816
n er 0.

571
00:27:53,816 --> 00:27:55,190
Okay, hvad var min tilstand?

572
00:27:55,190 --> 00:27:58,700
>> 20-- linje 20 er, godt,
0 er større end 0.

573
00:27:58,700 --> 00:27:59,500
Det er ikke sandt.

574
00:27:59,500 --> 00:28:01,020
0 er ikke større end 0.

575
00:28:01,020 --> 00:28:02,820
Og så jeg brød ud af dette.

576
00:28:02,820 --> 00:28:06,370
>> Og så derfor på linje
21, hvis jeg rent faktisk fortsætter,

577
00:28:06,370 --> 00:28:10,370
Jeg har tænkt mig at vende tilbage 0, selv
selvom jeg burde have afvist 0

578
00:28:10,370 --> 00:28:12,484
som ikke rent faktisk at være negativ.

579
00:28:12,484 --> 00:28:14,650
Så nu gør jeg ikke virkelig selv
bekymrer sig om debugger.

580
00:28:14,650 --> 00:28:16,900
Fik det, behøver jeg ikke at
ved, hvad mere der foregår.

581
00:28:16,900 --> 00:28:19,233
>> Så jeg har tænkt mig at gå videre og
blot klikke på knappen Afspil,

582
00:28:19,233 --> 00:28:20,240
og lad denne færdig op.

583
00:28:20,240 --> 00:28:23,440
Nu har jeg indset, at min
bug er tilsyneladende på linje 20.

584
00:28:23,440 --> 00:28:25,160
Det er min logiske fejl.

585
00:28:25,160 --> 00:28:28,100
>> Og så hvad ønsker jeg
at gøre for at ændre dette?

586
00:28:28,100 --> 00:28:32,500
Hvis problemet er, at jeg ikke er
fange 0, det er bare en logisk fejl.

587
00:28:32,500 --> 00:28:35,910
Og jeg kan sige, mens n er
større end eller lig med 0,

588
00:28:35,910 --> 00:28:38,330
holde spørge brugeren igen og igen.

589
00:28:38,330 --> 00:28:41,050
>> Så igen, simpel fejl, måske
selv indlysende, når du så mig

590
00:28:41,050 --> 00:28:42,410
skrive det blot et par minutter siden.

591
00:28:42,410 --> 00:28:44,570
Men takeaway her
er, at med debug 50,

592
00:28:44,570 --> 00:28:46,850
og med debugging
software mere generelt,

593
00:28:46,850 --> 00:28:51,370
du har denne nyfundne magt til
gå gennem din egen kode, se

594
00:28:51,370 --> 00:28:55,590
via denne højre panel hvad
dine variabler værdier er.

595
00:28:55,590 --> 00:28:57,700
Så du ikke nødvendigvis
nødt til at bruge noget

596
00:28:57,700 --> 00:29:00,630
ligesom du eprintf at udskrive disse værdier.

597
00:29:00,630 --> 00:29:04,430
Du kan faktisk se dem
visuelt på skærmen.

598
00:29:04,430 --> 00:29:08,920
>> Nu, ud over dette, er det værd at bemærke,
at der er en anden teknik, der er

599
00:29:08,920 --> 00:29:09,890
faktisk super almindelige.

600
00:29:09,890 --> 00:29:13,120
Og du måske spekulerer på, hvorfor denne lille
fyr her har siddet på scenen.

601
00:29:13,120 --> 00:29:16,490
Så der er denne teknik, generelt
kendt som gummi and debugging,

602
00:29:16,490 --> 00:29:18,786
som virkelig er blot en
bevis på det faktum,

603
00:29:18,786 --> 00:29:20,660
der ofte når programmører
skriver kode,

604
00:29:20,660 --> 00:29:22,650
de er ikke nødvendigvis
samarbejde med andre,

605
00:29:22,650 --> 00:29:24,030
eller arbejder i et fælles miljø.

606
00:29:24,030 --> 00:29:25,050
>> De er en slags hjemme.

607
00:29:25,050 --> 00:29:25,910
Måske er det sent om natten.

608
00:29:25,910 --> 00:29:28,190
De forsøger at figur
nogle fejl i deres kode.

609
00:29:28,190 --> 00:29:29,330
Og de er bare ikke se det.

610
00:29:29,330 --> 00:29:30,329
>> Og der er ingen værelseskammerat.

611
00:29:30,329 --> 00:29:31,250
Der er ingen TF.

612
00:29:31,250 --> 00:29:32,680
Der er ingen CA rundt.

613
00:29:32,680 --> 00:29:36,440
Alt, hvad de har på deres hylde
er denne lille gummi ducky.

614
00:29:36,440 --> 00:29:39,030
>> Og så rubber duck debugging
er netop denne invitation

615
00:29:39,030 --> 00:29:42,780
at tænke på noget så fjollet
da dette som en reel skabning,

616
00:29:42,780 --> 00:29:46,940
og faktisk gå gennem din kode
mundtligt til denne livløs genstand.

617
00:29:46,940 --> 00:29:49,230
Så, for eksempel, hvis
dette er mit eksempel her--

618
00:29:49,230 --> 00:29:52,470
og huske, at tidligere
problemet var dette,

619
00:29:52,470 --> 00:29:58,140
hvis jeg sletter denne første linje kode,
og jeg gå videre og gøre buggy 0 igen,

620
00:29:58,140 --> 00:30:01,220
minde om, at jeg havde disse
fejlmeddelelser her.

621
00:30:01,220 --> 00:30:05,997
Så ideen her, latterlig selvom jeg
føler i øjeblikket gør dette offentligt,

622
00:30:05,997 --> 00:30:06,580
er, at fejl.

623
00:30:06,580 --> 00:30:10,910
>> OK, så mit problem er, at jeg har
implicit erklæret en biblioteksfunktion.

624
00:30:10,910 --> 00:30:12,610
Og at biblioteksfunktionen er printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, erklærer
minder mig om prototyper.

626
00:30:15,290 --> 00:30:18,930
>> Det betyder, at jeg har brug for at faktisk
fortælle compileren på forhånd, hvad

627
00:30:18,930 --> 00:30:19,980
funktionen ser ud.

628
00:30:19,980 --> 00:30:20,930
Vent et øjeblik.

629
00:30:20,930 --> 00:30:23,580
Jeg havde ikke standard io.h.

630
00:30:23,580 --> 00:30:24,530
Mange tak.

631
00:30:24,530 --> 00:30:27,330
>> Så bare denne proces of-- du
behøver ikke at faktisk har en and.

632
00:30:27,330 --> 00:30:29,819
Men denne idé om Walking
dig selv gennem din egen kode

633
00:30:29,819 --> 00:30:31,610
så du endda høre
dig selv, så du

634
00:30:31,610 --> 00:30:35,620
realisere udeladelser i din egen
bemærkninger, er generelt den idé.

635
00:30:35,620 --> 00:30:38,910
>> Og måske mere logisk, ikke så
meget med at én, men mere involveret

636
00:30:38,910 --> 00:30:44,220
eksempel vi lige gjorde i buggy 3.c,
du kan gå dig selv gennem det

637
00:30:44,220 --> 00:30:45,310
som følger.

638
00:30:45,310 --> 00:30:49,190
Så okay, gummi
ducky, DDB, hvis du vil.

639
00:30:49,190 --> 00:30:52,350
Her har vi i min primære funktion,
Jeg ringer få negativ int.

640
00:30:52,350 --> 00:30:54,660
>> Og jeg får returværdien.

641
00:30:54,660 --> 00:31:00,410
Jeg opbevare det på venstre side
på linje 8 i en variabel kaldet i.

642
00:31:00,410 --> 00:31:02,380
OK, men vent, hvordan gjorde
at få denne værdi?

643
00:31:02,380 --> 00:31:04,130
Lad mig se på den funktion på linje 12.

644
00:31:04,130 --> 00:31:05,760
>> På linje 12, vi har få negativ int.

645
00:31:05,760 --> 00:31:08,190
Tager ikke nogen indgange,
vender tilbage en int, OK.

646
00:31:08,190 --> 00:31:10,929
Jeg erklærer på linie 14 en variabel n.

647
00:31:10,929 --> 00:31:12,220
Det kommer til at gemme et heltal.

648
00:31:12,220 --> 00:31:13,760
Det er hvad jeg vil have.

649
00:31:13,760 --> 00:31:18,480
>> Så skal du gøre følgende, mens n is-- lade
mig fortryde hvad rettelsen jeg allerede gjort.

650
00:31:18,480 --> 00:31:22,710
Så mens n er større end
0, udskrive n er, OK.

651
00:31:22,710 --> 00:31:25,170
Og derefter kalde få int gemt i n.

652
00:31:25,170 --> 00:31:30,160
Og derefter kontrollere hvis n er 0,
n er not-- der er det.

653
00:31:30,160 --> 00:31:31,910
Så, igen, ikke gøre dig
brug for det faktiske duck.

654
00:31:31,910 --> 00:31:35,650
Men bare gå dig selv gennem
din kode som en intellektuel øvelse

655
00:31:35,650 --> 00:31:37,720
vil ofte hjælpe dig
indse, hvad der foregår,

656
00:31:37,720 --> 00:31:41,170
i modsætning til blot at gøre noget
som denne og stirrede på skærmen,

657
00:31:41,170 --> 00:31:43,720
og taler ikke dig selv gennem
det, som ærligt ikke

658
00:31:43,720 --> 00:31:46,270
næsten som en effektiv teknik.

659
00:31:46,270 --> 00:31:48,620
Så der har du det, en
række forskellige teknikker

660
00:31:48,620 --> 00:31:52,102
for faktisk debugging din kode
og finde fejl, som alle

661
00:31:52,102 --> 00:31:54,810
bør være værktøjer i din værktøjskasse
så du ikke er sent om natten,

662
00:31:54,810 --> 00:31:57,660
især, er du i spisesalen
haller eller i kontortid,

663
00:31:57,660 --> 00:32:00,368
banke hovedet mod
væg, forsøger at løse et problem.

664
00:32:00,368 --> 00:32:02,020
Indse at der er software-værktøjer.

665
00:32:02,020 --> 00:32:03,720
Der er gummi duck værktøjer.

666
00:32:03,720 --> 00:32:09,630
Og der er en hel stab af
støtte venter på at give en hånd.

667
00:32:09,630 --> 00:32:13,120
>> Så nu, et ord på problemet
sæt, og hvad vi håber du

668
00:32:13,120 --> 00:32:15,620
komme ud af dem, og hvordan
vi går om at vurdere.

669
00:32:15,620 --> 00:32:17,680
Per kursets pensum,
CS50 problemområder sæt

670
00:32:17,680 --> 00:32:22,320
evalueres fire primære akser, så
at speak-- omfang, korrekthed, design,

671
00:32:22,320 --> 00:32:23,060
og stil.

672
00:32:23,060 --> 00:32:25,910
Og omfanget henviser bare til, hvor meget
af stykket har du bidt?

673
00:32:25,910 --> 00:32:28,080
Hvor meget af et problem har du prøvet?

674
00:32:28,080 --> 00:32:30,110
Hvilket niveau af indsats
har du manifesteret?

675
00:32:30,110 --> 00:32:35,750
>> Korrekthed er, gør programmet arbejde som
det er meningen at pr CS50 specifikation

676
00:32:35,750 --> 00:32:38,640
når du giver visse input
eller visse udgange kommer tilbage?

677
00:32:38,640 --> 00:32:41,130
Design er den mest subjektive af dem.

678
00:32:41,130 --> 00:32:43,360
Og det er den, der vil
tage længst tid at lære

679
00:32:43,360 --> 00:32:47,220
og den længste til at undervise i
så vidt det kan koges ned til,

680
00:32:47,220 --> 00:32:49,530
hvor godt skrevet, er din kode?

681
00:32:49,530 --> 00:32:52,920
>> Det er én ting at bare udskrive den korrekte
udgange eller returnere de rigtige værdier.

682
00:32:52,920 --> 00:32:55,400
Men gør du det som
effektivt som muligt?

683
00:32:55,400 --> 00:32:58,210
Gør du det kløft
og erobre, eller binær

684
00:32:58,210 --> 00:33:01,500
søgning som vi snart vil se, at vi gjorde
to uger siden med telefonbogen?

685
00:33:01,500 --> 00:33:04,670
Er der bedre måder at løse
problem, end du har i øjeblikket her?

686
00:33:04,670 --> 00:33:06,380
Det er en mulighed for bedre design.

687
00:33:06,380 --> 00:33:08,530
>> Og så style-- hvordan
temmelig er din kode?

688
00:33:08,530 --> 00:33:12,370
Du vil opdage, at jeg er temmelig
særlig om indrykning min kode,

689
00:33:12,370 --> 00:33:15,300
og sikre mine variabler
er rimeligt navngivet. n,

690
00:33:15,300 --> 00:33:19,660
mens korte, er et godt navn til en
nummer, i for en optælling heltal,

691
00:33:19,660 --> 00:33:20,727
s for en streng.

692
00:33:20,727 --> 00:33:22,560
Og vi kan have længere
variabel navne stil.

693
00:33:22,560 --> 00:33:25,500
Style er bare hvor god
gør din kode ud?

694
00:33:25,500 --> 00:33:26,600
Og hvor læsbar er det?

695
00:33:26,600 --> 00:33:29,650
>> Og over tid, hvad din TAs
og TF'er vil gøre i løbet

696
00:33:29,650 --> 00:33:31,870
er at give dig med det
slags kvalitativ feedback

697
00:33:31,870 --> 00:33:34,330
så du får bedre
ved disse forskellige aspekter.

698
00:33:34,330 --> 00:33:37,510
Og med hensyn til, hvordan vi
evaluere hver af disse akser,

699
00:33:37,510 --> 00:33:40,080
det er typisk med meget få
spande, så du generelt

700
00:33:40,080 --> 00:33:41,680
få en fornemmelse af, hvor godt du laver.

701
00:33:41,680 --> 00:33:45,680
Og, ja, hvis du modtager en score på
enhver af de axes-- korrekthed, design

702
00:33:45,680 --> 00:33:49,659
og stil especially-- dette nummer
vil generelt være mellem 1 og 5.

703
00:33:49,659 --> 00:33:52,450
Og, bogstaveligt, hvis du får
3 s i starten af ​​semesteret,

704
00:33:52,450 --> 00:33:53,977
dette er en meget god ting.

705
00:33:53,977 --> 00:33:55,810
Det betyder, at der er stadig
plads til forbedring,

706
00:33:55,810 --> 00:33:58,490
som du ville håbe på i
tage en klasse for første gang.

707
00:33:58,490 --> 00:34:01,820
Der er forhåbentlig nogle lidt af loftet
som du stræber efter at nå.

708
00:34:01,820 --> 00:34:03,970
Og så at få 3 s på
de tidligste stykker,

709
00:34:03,970 --> 00:34:06,550
hvis ikke nogle 2s og 4 s,
er faktisk en god ting.

710
00:34:06,550 --> 00:34:08,880
Det er godt inden for rækkevidde,
godt inden forventninger.

711
00:34:08,880 --> 00:34:11,421
>> Og hvis dit sind er racing, vente
et minut, tre ud af fem.

712
00:34:11,421 --> 00:34:12,620
Det er virkelig en 6 ud af 10.

713
00:34:12,620 --> 00:34:13,560
Det er 60%.

714
00:34:13,560 --> 00:34:14,830
Min Gud, det er en F.

715
00:34:14,830 --> 00:34:15,870
>> Det er ikke.

716
00:34:15,870 --> 00:34:17,600
Det er ikke i virkeligheden, at.

717
00:34:17,600 --> 00:34:22,710
Snarere er det en mulighed for at forbedre
i løbet af semestret.

718
00:34:22,710 --> 00:34:25,580
Og hvis du får nogle
Poors, disse er en mulighed

719
00:34:25,580 --> 00:34:29,199
at drage fordel af kontortid,
sikkert sektioner og andre ressourcer.

720
00:34:29,199 --> 00:34:32,840
>> Bedste er en mulighed, virkelig,
at være stolt af, hvor langt du har

721
00:34:32,840 --> 00:34:34,520
kommer i løbet af semestret.

722
00:34:34,520 --> 00:34:38,199
Så indser, hvis intet
andet, tre er god.

723
00:34:38,199 --> 00:34:40,179
Og det giver plads til vækst over tid.

724
00:34:40,179 --> 00:34:43,090
>> Med hensyn til hvordan disse akser er
vægtet, realistisk er du

725
00:34:43,090 --> 00:34:46,745
kommer til at tilbringe det meste af din tid på at få
ting til arbejde, endsige korrekt.

726
00:34:46,745 --> 00:34:49,120
Og så korrekthed tendens til
vægtes mest, som med

727
00:34:49,120 --> 00:34:51,360
denne multiplikativ faktor tre.

728
00:34:51,360 --> 00:34:54,659
Design er også vigtigt, men
noget, som du ikke nødvendigvis

729
00:34:54,659 --> 00:34:58,220
bruge alle disse timer på
forsøger at få tingene bare for at arbejde.

730
00:34:58,220 --> 00:35:00,019
>> Og så det er vægtet
lidt mere let.

731
00:35:00,019 --> 00:35:01,560
Og så stil er vægtet mindst.

732
00:35:01,560 --> 00:35:03,710
Selvom det er ikke mindre
vigtigt fundamentalt,

733
00:35:03,710 --> 00:35:05,990
det er bare, måske den
letteste ting at gøre det rette,

734
00:35:05,990 --> 00:35:08,440
efterligne de eksempler, vi
gøre i foredrag og afsnit,

735
00:35:08,440 --> 00:35:11,080
med ting pænt
indrykket, og kommenteret,

736
00:35:11,080 --> 00:35:14,320
og så videre er blandt de letteste
ting at gøre og få ret.

737
00:35:14,320 --> 00:35:16,960
Så som sådan, indser
at de er punkter

738
00:35:16,960 --> 00:35:19,000
der er relativt lette at forstå.

739
00:35:19,000 --> 00:35:22,360
>> Og nu et ord om
denne-- akademisk ærlighed.

740
00:35:22,360 --> 00:35:25,150
Så pr kursets
pensum, vil du se

741
00:35:25,150 --> 00:35:27,630
at kurset har en ganske
bit af sprog omkring dette.

742
00:35:27,630 --> 00:35:31,380
Og kurset tager spørgsmålet om
akademisk ærlighed ganske alvorligt.

743
00:35:31,380 --> 00:35:33,450
>> Vi har den sondring,
for bedre eller værre,

744
00:35:33,450 --> 00:35:36,570
for at have sendt hvert år mere
studerende til disciplinære foranstaltninger

745
00:35:36,570 --> 00:35:39,670
end de fleste andre
selvfølgelig, at jeg er klar over.

746
00:35:39,670 --> 00:35:42,580
Dette er ikke nødvendigvis
tegn på,

747
00:35:42,580 --> 00:35:46,340
at CS studerende, eller CS50 studerende, er
mindre ærlig end dine klassekammerater.

748
00:35:46,340 --> 00:35:49,090
Men den virkelighed, at i dette
verden, elektronisk, vi bare

749
00:35:49,090 --> 00:35:50,990
har teknologisk
middel til påvisning af dette.

750
00:35:50,990 --> 00:35:53,360
>> Det er vigtigt for os for
fairness tværs klassen

751
00:35:53,360 --> 00:35:58,550
at vi gør opdage dette, og hæve
spørgsmålet, når vi ser tingene.

752
00:35:58,550 --> 00:36:01,980
Og bare for at male et billede, og virkelig
at hjælpe noget som dette vask i,

753
00:36:01,980 --> 00:36:04,600
disse er antallet af
studerende i løbet af de seneste 10 år

754
00:36:04,600 --> 00:36:07,610
der har været involveret i nogle
sådanne spørgsmål for akademisk ærlighed,

755
00:36:07,610 --> 00:36:10,990
med nogle 32 elever
fra efteråret 2015, som

756
00:36:10,990 --> 00:36:13,760
vil sige, at vi tager
sagen meget alvorligt.

757
00:36:13,760 --> 00:36:18,380
Og i sidste ende, disse tal komponere,
senest ca. 3%, 4%, eller

758
00:36:18,380 --> 00:36:19,120
af klassen.

759
00:36:19,120 --> 00:36:25,220
>> Så for kvalificeret flertal af studerende
ser det ud til, at linjerne er klare.

760
00:36:25,220 --> 00:36:27,940
Men du skal holde dette i
noget imod, især sent

761
00:36:27,940 --> 00:36:32,080
om natten, når kæmper med
nogle løsning på et problem sæt,

762
00:36:32,080 --> 00:36:34,830
at der findes ordninger
for at få dig selv bedre

763
00:36:34,830 --> 00:36:37,870
støtte end du måske
tror, ​​selv i denne time.

764
00:36:37,870 --> 00:36:40,514
Indse, at når vi modtager
studerende redegørelser, vi krydser

765
00:36:40,514 --> 00:36:43,430
sammenligne hvert indsendelse i år
imod enhver indsendelse sidste år,

766
00:36:43,430 --> 00:36:47,590
mod hver indsendelse fra 2007,
og da, ser på, så godt,

767
00:36:47,590 --> 00:36:49,931
kode opbevaringssteder online,
diskussionsfora, jobsites.

768
00:36:49,931 --> 00:36:51,806
Og vi nævner dette,
virkelig, alle af hensyn

769
00:36:51,806 --> 00:36:56,040
af fuld åbenhed, at hvis
en anden kan finde den online,

770
00:36:56,040 --> 00:36:57,880
sikkert, så kan vi kurset.

771
00:36:57,880 --> 00:37:00,100
Men virkelig, ånden
af kurset koges ned

772
00:37:00,100 --> 00:37:01,650
til denne klausul i pensum.

773
00:37:01,650 --> 00:37:03,670
Det er virkelig bare, være rimelig.

774
00:37:03,670 --> 00:37:06,680
>> Og hvis vi skulle uddybe det
med blot en smule mere sprog,

775
00:37:06,680 --> 00:37:09,770
indse, at essensen af ​​alle
arbejde, som du sender til dette kursus

776
00:37:09,770 --> 00:37:10,954
skal være din egen.

777
00:37:10,954 --> 00:37:13,870
Men inden for det, der er helt sikkert
muligheder og opmuntring,

778
00:37:13,870 --> 00:37:17,300
og pædagogisk værdi i at dreje til
others-- mig, TFS, CAS,

779
00:37:17,300 --> 00:37:20,760
TAS, og andre i klassen,
for støtte, endsige venner

780
00:37:20,760 --> 00:37:23,547
og roommates der har studeret
CS og programmering før.

781
00:37:23,547 --> 00:37:25,130
Og så er der en godtgørelse for det.

782
00:37:25,130 --> 00:37:28,180
Og den generelle tommelfingerregel
er denne-- når beder om hjælp,

783
00:37:28,180 --> 00:37:31,470
du kan vise din kode til andre,
men du kan ikke se deres.

784
00:37:31,470 --> 00:37:34,880
Så selv om du er på kontortid,
eller i D hal, eller et andet sted

785
00:37:34,880 --> 00:37:37,450
arbejder på nogle stykke sæt,
arbejder sammen med en ven, der

786
00:37:37,450 --> 00:37:40,160
er helt fint, på
slutningen af ​​dagen dit arbejde

787
00:37:40,160 --> 00:37:43,034
skal i sidste ende hører til hver
af jer henholdsvis og ikke

788
00:37:43,034 --> 00:37:45,700
være nogle fælles indsats,
bortset fra den afsluttende projekt, hvor

789
00:37:45,700 --> 00:37:47,410
det er tilladt og opmuntret.

790
00:37:47,410 --> 00:37:49,830
>> Indse, at hvis du er
kæmper med noget

791
00:37:49,830 --> 00:37:52,520
og din ven bare sker
være bedre til dette, så du,

792
00:37:52,520 --> 00:37:55,130
eller bedre til dette problem end du,
eller lidt længere frem end dig,

793
00:37:55,130 --> 00:37:57,330
det er helt rimeligt at vende
til din ven og sige, hey,

794
00:37:57,330 --> 00:38:00,480
Har du noget imod at kigge på min kode her,
hjælpe mig spotte hvad mit problem er?

795
00:38:00,480 --> 00:38:03,760
Og forhåbentlig i
interesse pædagogisk værdi

796
00:38:03,760 --> 00:38:07,040
denne ven ikke bare
sige, åh, gør dette, men snarere,

797
00:38:07,040 --> 00:38:09,917
hvad du mangler på nettet
6, eller sådan noget?

798
00:38:09,917 --> 00:38:12,000
Men løsningen er ikke
for den ven, ved siden af ​​dig

799
00:38:12,000 --> 00:38:15,617
at sige, åh, ja, her, lad mig trække
dette op, og vise min løsning til dig.

800
00:38:15,617 --> 00:38:16,450
Så det er den linje.

801
00:38:16,450 --> 00:38:18,670
Du viser din kode til
andre, men du ikke kan

802
00:38:18,670 --> 00:38:22,350
se deres, med forbehold af den anden
begrænsninger i kursets pensum.

803
00:38:22,350 --> 00:38:24,760
>> Så du huske dette
såkaldte beklagelse klausul

804
00:38:24,760 --> 00:38:27,560
i kursets pensum så godt,
at hvis du begår en handling, som

805
00:38:27,560 --> 00:38:30,476
er ikke rimeligt, men bringe det til
opmærksomhed kursets hoveder

806
00:38:30,476 --> 00:38:34,240
inden for 72 timer, forløbet
kan pålægge de lokale sanktioner,

807
00:38:34,240 --> 00:38:37,380
kan omfatte en utilfredsstillende eller
dumpekarakter for arbejdet indgivet.

808
00:38:37,380 --> 00:38:41,410
Men kurset vil ikke henvise
noget for yderligere disciplinære foranstaltninger,

809
00:38:41,410 --> 00:38:43,010
undtagen i tilfælde af gentagne handlinger.

810
00:38:43,010 --> 00:38:46,632
Med andre ord, hvis du gør nogle
dum, især sent nat, beslutning

811
00:38:46,632 --> 00:38:49,340
at den næste morgen eller to dage
senere, du vågner op og indser,

812
00:38:49,340 --> 00:38:50,870
hvad tænkte jeg?

813
00:38:50,870 --> 00:38:53,890
Du gør i CS50 har en stikkontakt
for fastsættelse dette problem

814
00:38:53,890 --> 00:38:57,170
og eje op til det, så vi
vil møde dig halvvejs og håndtere

815
00:38:57,170 --> 00:39:01,500
med det i et spørgsmål, der både
uddannelsesmæssige og værdifuldt for dig,

816
00:39:01,500 --> 00:39:04,200
men stadig straffende på en eller anden måde.

817
00:39:04,200 --> 00:39:08,590
Og nu, til at tage brodden, dette.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO PLAYBACK]

819
00:39:10,570 --> 00:39:13,540
>> [MUSIK AFSPILLER]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END AFSPIL]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN: Okay, vi er tilbage.

823
00:40:00,490 --> 00:40:03,680
Og nu ser vi på en af ​​de
første af vores virkelige verden domæner

824
00:40:03,680 --> 00:40:08,720
i CS50, kunsten kryptografi,
kunsten at sende og modtage

825
00:40:08,720 --> 00:40:11,840
hemmelige beskeder, krypteret
meddelelser om du vil,

826
00:40:11,840 --> 00:40:17,060
som kun kan tydes hvis du har
nogle vigtigste ingrediens at afsenderen har

827
00:40:17,060 --> 00:40:18,030
såvel.

828
00:40:18,030 --> 00:40:22,120
Så for at motivere denne vi vil tage
et kig på denne ting her,

829
00:40:22,120 --> 00:40:26,750
som er et eksempel på en
hemmelig dekoder ring,

830
00:40:26,750 --> 00:40:34,042
kan anvendes for at finde ud af
hvad en hemmelig besked faktisk er.

831
00:40:34,042 --> 00:40:35,750
Faktisk tilbage i
dag i folkeskolen,

832
00:40:35,750 --> 00:40:38,787
hvis du nogensinde sendt hemmelige beskeder til
nogle ven eller nogle crush i klassen,

833
00:40:38,787 --> 00:40:40,620
du måske har troet
du var at være klog

834
00:40:40,620 --> 00:40:46,530
ved på din stykke papir skiftende,
lignende, A til B, og B til C, og C til D,

835
00:40:46,530 --> 00:40:47,590
og så videre.

836
00:40:47,590 --> 00:40:50,300
Men du var faktisk kryptere
dine oplysninger, selv

837
00:40:50,300 --> 00:40:53,300
hvis det var lidt triviel, var ikke
at hårdt for læreren til at indse,

838
00:40:53,300 --> 00:40:55,675
godt, hvis du bare ændre
B til A og C til B,

839
00:40:55,675 --> 00:40:57,550
du faktisk regne ud
hvad budskabet var,

840
00:40:57,550 --> 00:40:59,700
men du var i chifrere oplysninger.

841
00:40:59,700 --> 00:41:03,420
>> Du var bare gør det
simpelthen, ligesom Ralphie her

842
00:41:03,420 --> 00:41:07,934
i en berømt film, der spiller
temmelig meget ad nauseam hver vinter.

843
00:41:07,934 --> 00:41:08,600
[VIDEO PLAYBACK]

844
00:41:08,600 --> 00:41:11,180
-Vær Det kendt for alle, at
Ralph Parker er hermed

845
00:41:11,180 --> 00:41:14,070
udnævnes til medlem af den lille
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
og har ret til alle de æresbevisninger
og fordele forekommende dertil.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
counter-signeret Pierre Andre, med blæk.

848
00:41:24,340 --> 00:41:27,160
Honors og fordele,
allerede i en alder af ni.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [RÅBE]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Kom nu.

853
00:41:34,250 --> 00:41:35,210
Lad os komme videre med det.

854
00:41:35,210 --> 00:41:39,530
Jeg behøver ikke alt det jazz
om smuglere og pirater.

855
00:41:39,530 --> 00:41:41,660
>> Lyt morgen aften for
den afsluttende eventyr

856
00:41:41,660 --> 00:41:43,880
af den sorte pirat skib.

857
00:41:43,880 --> 00:41:46,650
Nu er det tid til
Annies hemmelig besked

858
00:41:46,650 --> 00:41:49,840
for dig medlemmer af Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Husk, børn, kun medlemmer
af Annies Secret Circle

860
00:41:53,570 --> 00:41:56,140
kan afkode Annies hemmelig besked.

861
00:41:56,140 --> 00:42:00,340
>> Husk, er Annie afhængig af dig.

862
00:42:00,340 --> 00:42:02,880
Sæt dine ben til B2.

863
00:42:02,880 --> 00:42:05,230
Her er budskabet.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Jeg Er i min første hemmeligt møde.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Var i stor stemme i aften.

868
00:42:15,780 --> 00:42:19,000
Jeg kunne fortælle, at aftenens
budskab var virkelig vigtigt.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, der er et budskab
fra Annie selv.

870
00:42:22,694 --> 00:42:23,860
Husk, ikke fortælle nogen.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekunder senere, jeg er i den eneste
rum i huset, hvor en dreng på ni

873
00:42:32,930 --> 00:42:37,040
kunne sidde i fred og afkode.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Jeg gik til den næste, E.

876
00:42:42,360 --> 00:42:44,520
>> Det første ord er være.

877
00:42:44,520 --> 00:42:49,032
S, blev det kommer lettere nu, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Ĺh, kom nu, Ralphie, jeg skal gå!

879
00:42:51,733 --> 00:42:53,688
>> -Jeg Være rigtigt ned, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee whiz!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, skal du sørge for at-- være sikker på hvad?

883
00:43:04,060 --> 00:43:05,970
Hvad var lille Orphan
Annie prøver at sige?

884
00:43:05,970 --> 00:43:07,264
Vær sikker på at hvad?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy har fået til
gå, vil du venligst komme ud?

886
00:43:09,634 --> 00:43:10,480
>> -Alle Højre, Ma!

887
00:43:10,480 --> 00:43:12,880
Jeg kommer lige ud!

888
00:43:12,880 --> 00:43:14,550
>> -Jeg Var at komme tættere nu.

889
00:43:14,550 --> 00:43:16,620
Spændingen var forfærdeligt.

890
00:43:16,620 --> 00:43:17,720
Hvad var det?

891
00:43:17,720 --> 00:43:20,170
Den skæbne af planeten
kan hænge i balance.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy mĺ gå!

894
00:43:23,170 --> 00:43:26,890
>> -Jeg Være lige ud, for skriger højt!

895
00:43:26,890 --> 00:43:32,680
>> -Næsten der, mine fingre fløj, mit sind
var en stål fælde, hver pore vibrerede.

896
00:43:32,680 --> 00:43:37,198
Det var næsten klar, ja, ja, ja.

897
00:43:37,198 --> 00:43:43,091
>> -Vær Sikker på at drikke din ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
En mærkværdige kommerciel?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Søn af en tæve.

903
00:43:54,227 --> 00:43:54,810
[END AFSPIL]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN: OK, så
det var en meget lang vej

905
00:43:57,390 --> 00:44:00,660
indføre kryptografi,
og også Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Faktisk fra denne gamle annonce
her, hvorfor er Ovaltine så godt?

907
00:44:04,470 --> 00:44:09,470
Det er en koncentreret ekstraktion af modne
bygmalt, ren cremet komælk,

908
00:44:09,470 --> 00:44:14,360
og specielt tilberedt kakao, sammen
med naturlige phosphatider og vitaminer.

909
00:44:14,360 --> 00:44:18,240
Det er yderligere forstærket med
yderligere vitaminer B og D, yum.

910
00:44:18,240 --> 00:44:21,600
Og du kan stadig få det, tilsyneladende,
på Amazon, som vi gjorde her.

911
00:44:21,600 --> 00:44:24,810
>> Men motivationen her var at
indføre kryptografi, specielt

912
00:44:24,810 --> 00:44:28,340
en type kryptografi kendt
som hemmelige nøgle kryptografi.

913
00:44:28,340 --> 00:44:34,284
Og som navnet antyder, det hele
sikkerhed af en hemmelig nøgle kryptosystem,

914
00:44:34,284 --> 00:44:36,200
hvis du vil, en metode
for bare scrambling

915
00:44:36,200 --> 00:44:40,960
information mellem to mennesker, er, at
kun afsenderen og modtageren kun

916
00:44:40,960 --> 00:44:46,980
kender en hemmelig key-- vis værdi, nogle
hemmelige sætning, nogle hemmeligt nummer, at

917
00:44:46,980 --> 00:44:50,660
tillader dem at både kryptere
og dekryptere information.

918
00:44:50,660 --> 00:44:53,470
Og kryptografi, virkelig,
er netop dette fra uge 0.

919
00:44:53,470 --> 00:44:56,715
>> Det er et problem, hvor der er input,
ligesom selve besked på engelsk

920
00:44:56,715 --> 00:44:59,340
eller hvad sprog, du
ønsker at sende til en person i klassen,

921
00:44:59,340 --> 00:45:00,580
eller på tværs af internettet.

922
00:45:00,580 --> 00:45:03,840
Der er en vis output, som vil
at være den krypterede besked, du

923
00:45:03,840 --> 00:45:05,250
ønsker, at modtageren til at modtage.

924
00:45:05,250 --> 00:45:07,405
Og selv hvis nogen i
midten modtager det også,

925
00:45:07,405 --> 00:45:09,780
du ikke vil have dem til
nødvendigvis være i stand til at dekryptere det,

926
00:45:09,780 --> 00:45:12,840
fordi indersiden af ​​denne
sort boks, eller algoritme,

927
00:45:12,840 --> 00:45:17,650
er en mekanisme, nogle trin for trin
instruktioner, for at tage det input

928
00:45:17,650 --> 00:45:20,710
og omdanne den til den
output, i forhåbentlig en sikker måde.

929
00:45:20,710 --> 00:45:23,640
>> Og i virkeligheden er der en vis
ordforråd i denne verden som følger.

930
00:45:23,640 --> 00:45:26,100
Almindelig tekst er ordet et
datalog ville

931
00:45:26,100 --> 00:45:28,449
bruge til at beskrive input
besked, ligesom den engelske

932
00:45:28,449 --> 00:45:31,240
eller hvad sprog du rent faktisk
ønsker at sende til en anden menneske.

933
00:45:31,240 --> 00:45:35,450
Og så ciphertext er kapløbet
til indkodede, eller krypteret,

934
00:45:35,450 --> 00:45:36,520
udgave heraf.

935
00:45:36,520 --> 00:45:38,750
>> Men der er én anden ingrediens her.

936
00:45:38,750 --> 00:45:43,200
Der er en anden indgang til
hemmelig nøgle kryptografi.

937
00:45:43,200 --> 00:45:45,200
Og det er selve nøglen,
der er generelt

938
00:45:45,200 --> 00:45:48,930
som vi skal se, et tal, eller
brev, eller ord, uanset

939
00:45:48,930 --> 00:45:51,980
algoritmen er det faktisk forventer.

940
00:45:51,980 --> 00:45:53,870
>> Og hvordan kan du dekryptere oplysninger?

941
00:45:53,870 --> 00:45:55,110
Hvordan unscramble det?

942
00:45:55,110 --> 00:45:57,950
Nå, du bare vende den
udgange og indgange.

943
00:45:57,950 --> 00:46:00,900
>> Med andre ord, når først der
modtager dit krypteret meddelelse,

944
00:46:00,900 --> 00:46:03,740
han eller hun har simpelthen
at vide, at samme nøgle.

945
00:46:03,740 --> 00:46:05,700
De har modtaget ciphertext.

946
00:46:05,700 --> 00:46:09,530
Og ved at tilslutte de to
input i den krypto-system,

947
00:46:09,530 --> 00:46:14,260
algoritmen, denne sorte boks, ud
bør komme den oprindelige klartekst.

948
00:46:14,260 --> 00:46:17,830
Og så er det meget høje niveau
opfattelse af, hvad kryptografi er faktisk

949
00:46:17,830 --> 00:46:18,590
alt om.

950
00:46:18,590 --> 00:46:20,030
>> Så lad os komme der.

951
00:46:20,030 --> 00:46:22,700
Lad os nu se nedenunder
hætten af ​​noget

952
00:46:22,700 --> 00:46:26,000
vi har taget for givet for
den seneste uge, og for denne session

953
00:46:26,000 --> 00:46:27,629
her-- strengen.

954
00:46:27,629 --> 00:46:30,295
En streng i slutningen af ​​dagen
er blot en sekvens af tegn.

955
00:46:30,295 --> 00:46:33,610
>> Det kan være hej verden, eller
hej Zamyla, eller hvad.

956
00:46:33,610 --> 00:46:37,050
Men hvad betyder det for
være en sekvens af tegn?

957
00:46:37,050 --> 00:46:41,520
Faktisk CS50 biblioteket giver
os en datatype kaldet streng.

958
00:46:41,520 --> 00:46:45,140
>> Men der er faktisk ikke noget
sådan noget som en streng i C.

959
00:46:45,140 --> 00:46:49,450
Det er virkelig bare en sekvens af
karakter, karakter, karakter,

960
00:46:49,450 --> 00:46:52,180
karakter, ryg, til tilbage, til
tilbage, til tilbage, til tilbage inde

961
00:46:52,180 --> 00:46:54,650
af computerens hukommelse, eller RAM.

962
00:46:54,650 --> 00:46:58,940
Og vi vil se dybere ind i, at der i
fremtiden, når vi ser på selve hukommelse,

963
00:46:58,940 --> 00:47:02,030
og udnyttelsen, og
trusler, der er involveret.

964
00:47:02,030 --> 00:47:04,100
>> Men lad os overveje strengen Zamyla.

965
00:47:04,100 --> 00:47:07,480
Så bare navnet på
mennesket her, Zamyla,

966
00:47:07,480 --> 00:47:12,030
der er en sekvens af
tegn, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Og lad os nu antage, at Zamyla navn
der opbevares inde i en computer

968
00:47:16,020 --> 00:47:16,880
program.

969
00:47:16,880 --> 00:47:20,830
>> Tja, det er indlysende, at vi bør
kunne se på disse figurer

970
00:47:20,830 --> 00:47:21,590
individuelt.

971
00:47:21,590 --> 00:47:24,710
Så jeg bare at trække lidt
kasse omkring Zamyla navn her.

972
00:47:24,710 --> 00:47:31,580
Og det er tilfældet i C, at når man
har en streng, ligesom Zamyla-- og måske

973
00:47:31,580 --> 00:47:34,940
denne streng er kommet tilbage fra
en funktion som get streng,

974
00:47:34,940 --> 00:47:38,540
du rent faktisk kan manipulere
det tegn for tegn.

975
00:47:38,540 --> 00:47:42,070
>> Nu, dette er germane for
samtale ved hånden, fordi

976
00:47:42,070 --> 00:47:46,420
i kryptografi, hvis du ønsker at ændre
A til B, og B til C, og C til D,

977
00:47:46,420 --> 00:47:49,650
og så videre, er du nødt til at være i stand til
at se på de enkelte tegn

978
00:47:49,650 --> 00:47:50,190
i en streng.

979
00:47:50,190 --> 00:47:52,695
Du skal være i stand til at ændre
Z til noget andet, A

980
00:47:52,695 --> 00:47:55,280
til noget andet, M til
noget andet, og så videre.

981
00:47:55,280 --> 00:47:58,000
Og så har vi brug for en måde,
programmeringsmæssigt, så

982
00:47:58,000 --> 00:48:03,020
at tale, i C for at kunne ændre
og se på de enkelte bogstaver.

983
00:48:03,020 --> 00:48:05,690
Og vi kan gøre det på følgende måde.

984
00:48:05,690 --> 00:48:08,340
>> Lad mig gå hovedet tilbage i CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Og lad mig gå videre
og oprette en ny fil

986
00:48:11,130 --> 00:48:16,134
at jeg vil kalde denne gang string0,
som vores første sådant eksempel, dot c.

987
00:48:16,134 --> 00:48:18,300
Og jeg har tænkt mig at gå videre
og pisk det op som følger.

988
00:48:18,300 --> 00:48:22,870
>> Så omfatte CS50.h, og
så omfatter standard io.h,

989
00:48:22,870 --> 00:48:25,990
som jeg næsten altid vil
være hjælp i mine programmer, mindst

990
00:48:25,990 --> 00:48:26,780
i første omgang.

991
00:48:26,780 --> 00:48:32,180
int vigtigste tomrum, og derefter i her er jeg
vil gøre strengene får få streng.

992
00:48:32,180 --> 00:48:35,260
Og så jeg har tænkt mig at
gå videre og gøre dette.

993
00:48:35,260 --> 00:48:37,460
Jeg ønsker at gå videre
og, som en sanity check,

994
00:48:37,460 --> 00:48:43,607
bare sige, hej, procent s,
semikolon, gør streng 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, hvad gjorde jeg her?

996
00:48:44,690 --> 00:48:45,930
Åh, jeg ikke sætte den i.

997
00:48:45,930 --> 00:48:48,120
Så lektion lærte, at
var ikke tilsigtet.

998
00:48:48,120 --> 00:48:52,480
>> Så fejl, mere procent
konverteringer end data argumenter.

999
00:48:52,480 --> 00:48:54,940
Og det er her, i
line 7-- OK, så jeg har,

1000
00:48:54,940 --> 00:48:56,690
citat Citat slut, det er
min streng til printf.

1001
00:48:56,690 --> 00:48:58,151
Jeg har fået et procenttegn.

1002
00:48:58,151 --> 00:48:59,650
Men jeg mangler det andet argument.

1003
00:48:59,650 --> 00:49:03,190
>> Jeg mangler komma s, som
Jeg havde i de foregående eksempler.

1004
00:49:03,190 --> 00:49:06,650
Så en god mulighed for at løse
endnu en fejl, ved et uheld.

1005
00:49:06,650 --> 00:49:09,950
Og lad mig køre
string0, type i Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, hej Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Så vi har kørt denne form for program
et par forskellige gange nu.

1008
00:49:14,144 --> 00:49:16,310
Men lad os gøre noget
lidt anderledes denne gang.

1009
00:49:16,310 --> 00:49:19,450
I stedet for bare at udskrive Zamyla s
hele navnet ud med printf,

1010
00:49:19,450 --> 00:49:21,350
lad os gøre det tegn for tegn.

1011
00:49:21,350 --> 00:49:22,700
>> Jeg har tænkt mig at bruge en for-løkke.

1012
00:49:22,700 --> 00:49:26,160
Og jeg har tænkt mig at give mig selv
en optælling variabel, kaldet i.

1013
00:49:26,160 --> 00:49:33,530
Og jeg har tænkt mig at holde iteration, så
længe i er mindre end længden af ​​s.

1014
00:49:33,530 --> 00:49:35,930
>> Det viser sig, gjorde vi ikke
gøre denne sidste gang,

1015
00:49:35,930 --> 00:49:39,100
at C kommer med en
funktion kaldet Stirling.

1016
00:49:39,100 --> 00:49:42,690
Tilbage i dag, og generelt
stadig, når de gennemfører funktioner,

1017
00:49:42,690 --> 00:49:45,405
mennesker vil ofte vælger meget
præcise navne, slags lyd

1018
00:49:45,405 --> 00:49:48,280
ligesom hvad du vil, selv om det er
mangler et par vokaler eller bogstaver.

1019
00:49:48,280 --> 00:49:50,660
Så Stirling er
navn på en funktion,

1020
00:49:50,660 --> 00:49:53,880
tager et argument mellem
parenteser, der bør være en streng.

1021
00:49:53,880 --> 00:49:56,910
Og det bare returnerer et heltal,
længden af ​​denne streng.

1022
00:49:56,910 --> 00:50:00,580
>> Så dette for loop på linje 7 går
at begynde at tælle på I lig 0.

1023
00:50:00,580 --> 00:50:02,530
Det kommer til at forøge
I på hver iteration

1024
00:50:02,530 --> 00:50:04,350
med 1, som vi har gjort et par gange.

1025
00:50:04,350 --> 00:50:06,780
Men det vil kun gøre
dette indtil det punkt

1026
00:50:06,780 --> 00:50:09,660
når jeg er længden
af selve strengen.

1027
00:50:09,660 --> 00:50:14,520
>> Så dette er en måde, i sidste ende,
iteration over tegn

1028
00:50:14,520 --> 00:50:17,430
i strengen som den er følger.

1029
00:50:17,430 --> 00:50:20,670
Jeg har tænkt mig at udskrive ikke en
Hele snor, men procent c,

1030
00:50:20,670 --> 00:50:22,860
et enkelt tegn
efterfulgt af en ny linje.

1031
00:50:22,860 --> 00:50:24,880
Og så jeg har tænkt mig at
gå videre, og jeg har brug for

1032
00:50:24,880 --> 00:50:29,080
at sige, at jeg ønsker at udskrive
i'te karakter s.

1033
00:50:29,080 --> 00:50:33,450
>> Så hvis i er variabel, der angiver
indekset af strengen, hvor

1034
00:50:33,450 --> 00:50:37,230
du er i det, jeg har brug for at være i stand til
sige, giv mig den i'te karakter s.

1035
00:50:37,230 --> 00:50:40,390
Og c har en måde at gøre
dette med firkantede parenteser.

1036
00:50:40,390 --> 00:50:43,679
Du skal blot sige navnet på den
streng, som i dette tilfælde er s.

1037
00:50:43,679 --> 00:50:46,970
Så du bruger firkantede parenteser, som er
normalt lige over din Return eller Enter

1038
00:50:46,970 --> 00:50:48,110
tasten på tastaturet.

1039
00:50:48,110 --> 00:50:52,410
Og så skal du sætte indekset for den
tegn, du vil udskrive.

1040
00:50:52,410 --> 00:50:55,960
Så indekset vil være en
number-- 0 eller 1, eller 2, eller 3, eller prik,

1041
00:50:55,960 --> 00:50:57,590
prik, prik, et andet nummer.

1042
00:50:57,590 --> 00:51:00,920
>> Og vi sikrer, at det vil
være det rigtige antal, fordi jeg

1043
00:51:00,920 --> 00:51:02,360
begynde at tælle på 0.

1044
00:51:02,360 --> 00:51:07,020
Og som standard, det første tegn
i en streng er konventionelt 0.

1045
00:51:07,020 --> 00:51:09,230
Og det andet tegn er beslag 1.

1046
00:51:09,230 --> 00:51:11,120
Og den tredje karakter er beslag 2.

1047
00:51:11,120 --> 00:51:13,630
Og du ikke ønsker at gå alt for
langt, men vi vil ikke, fordi vi er

1048
00:51:13,630 --> 00:51:17,780
vil kun forøge jeg indtil det
lig med længden af ​​strengen.

1049
00:51:17,780 --> 00:51:20,210
Og på hvilket tidspunkt,
dette for løkke vil stoppe.

1050
00:51:20,210 --> 00:51:25,550
>> Så lad mig gå videre og gemme denne
program, og køre gør snor 0.

1051
00:51:25,550 --> 00:51:28,400
Men jeg skruet op.

1052
00:51:28,400 --> 00:51:35,390
Implicit erklære biblioteksfunktionen
Stirling med type sådan og such-- nu,

1053
00:51:35,390 --> 00:51:36,430
det lyder bekendt.

1054
00:51:36,430 --> 00:51:37,440
Men det er ikke printf.

1055
00:51:37,440 --> 00:51:38,540
Og det er ikke få streng.

1056
00:51:38,540 --> 00:51:40,480
>> Jeg har ikke skrue op i
på samme måde denne gang.

1057
00:51:40,480 --> 00:51:45,100
Men mærke hernede lidt ned
yderligere, omfatter header string.h,

1058
00:51:45,100 --> 00:51:47,210
udtrykkeligt give den
angivelse til Stirling.

1059
00:51:47,210 --> 00:51:48,820
Så der er faktisk en anelse derinde.

1060
00:51:48,820 --> 00:51:51,670
>> Og faktisk viser det sig
der er en anden header fil

1061
00:51:51,670 --> 00:51:53,970
at vi ikke har brugt
i klassen endnu, men det er

1062
00:51:53,970 --> 00:51:56,480
blandt de disponible
til dig, der kaldes string.h.

1063
00:51:56,480 --> 00:52:00,930
Og i denne fil, string.h
er Stirling erklæret.

1064
00:52:00,930 --> 00:52:05,220
Så lad mig gå videre og
gemme denne, gør streng

1065
00:52:05,220 --> 00:52:08,040
0-- nice, ingen fejlmeddelelser denne gang.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, og
Jeg er ved at trykke Enter,

1067
00:52:12,290 --> 00:52:16,710
på hvilket tidspunkt getString går
at returnere strengen, sætte det i s.

1068
00:52:16,710 --> 00:52:21,890
Så at for-løkke vil iterere
i S 'tegn en ad gangen,

1069
00:52:21,890 --> 00:52:28,420
og udskrive dem én pr linje, fordi
Jeg havde at backslash n i slutningen.

1070
00:52:28,420 --> 00:52:34,530
Så jeg kunne udelade at backslash
n, og derefter bare udskrive Zamyla alle

1071
00:52:34,530 --> 00:52:37,460
i samme linje,
effektivt reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, hvilket ikke er så nyttige.

1073
00:52:38,999 --> 00:52:40,540
Men i dette tilfælde, har jeg ikke gjort.

1074
00:52:40,540 --> 00:52:43,610
Jeg har faktisk udskrives en
tegn ad gangen, én pr linje,

1075
00:52:43,610 --> 00:52:45,400
så vi faktisk se effekten.

1076
00:52:45,400 --> 00:52:46,900
>> Men jeg bør bemærke en ting her.

1077
00:52:46,900 --> 00:52:48,930
Og vi vil vende tilbage til
dette i en kommende uge.

1078
00:52:48,930 --> 00:52:52,650
Det viser sig, at denne
kode er potentielt buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Det viser sig, get streng
og nogle andre funktioner i livet

1080
00:52:56,560 --> 00:53:00,280
ikke nødvendigvis altid
tilbage, hvad du forventer.

1081
00:53:00,280 --> 00:53:03,010
Vi ved fra klassen sidste
tid i dette, der får

1082
00:53:03,010 --> 00:53:04,960
streng formodes at returnere en streng.

1083
00:53:04,960 --> 00:53:09,900
Men hvad hvis brugeren skriver sådan
et langt ord, eller afsnit eller essay

1084
00:53:09,900 --> 00:53:13,010
at der er bare ikke nok
hukommelse i computeren til at passe det.

1085
00:53:13,010 --> 00:53:15,410
>> Ligesom, hvad hvis noget går
forkert under kølerhjelmen?

1086
00:53:15,410 --> 00:53:18,400
Det kan ikke ske ofte,
men det kunne ske, når

1087
00:53:18,400 --> 00:53:21,520
i et stykke tid, meget sjældent.

1088
00:53:21,520 --> 00:53:25,460
Og så viser det sig at komme snor
og funktioner som det gør ikke nødvendigvis

1089
00:53:25,460 --> 00:53:26,380
altid returnere strenge.

1090
00:53:26,380 --> 00:53:30,680
De kan returnere nogle fejl værdi,
nogle sentinel værdi så at sige,

1091
00:53:30,680 --> 00:53:32,612
der angiver, at
noget er gået galt.

1092
00:53:32,612 --> 00:53:35,320
Og du vil kun kender det fra
have lært det i klassen nu,

1093
00:53:35,320 --> 00:53:37,700
eller have læst nogle mere dokumentation.

1094
00:53:37,700 --> 00:53:43,120
Det viser sig, get streng
kan returnere en værdi, der hedder nul.

1095
00:53:43,120 --> 00:53:46,220
Null er en særlig værdi, som vi får
komme tilbage til i en kommende uge.

1096
00:53:46,220 --> 00:53:50,420
Men for nu, bare vide, at hvis jeg vil
at være virkelig korrekt i at bevæge sig fremad

1097
00:53:50,420 --> 00:53:52,650
hjælp get streng, jeg
skal ikke bare kalde det,

1098
00:53:52,650 --> 00:53:56,870
og blindt bruge sin returværdi,
tillid til, at det er en streng.

1099
00:53:56,870 --> 00:53:59,420
>> Jeg skal først sige,
hey, vent et øjeblik, kun

1100
00:53:59,420 --> 00:54:03,380
fortsætte, hvis s ikke er lig
null, hvor null, igen,

1101
00:54:03,380 --> 00:54:04,660
er blot nogle særlig værdi.

1102
00:54:04,660 --> 00:54:07,770
Og det er den eneste særlige værdi, du
at bekymre sig om for get streng.

1103
00:54:07,770 --> 00:54:10,900
Få strengen enten går
til at returnere en streng eller nul.

1104
00:54:10,900 --> 00:54:17,219
>> Og denne udråbstegn lighedstegn
du måske kender fra måske matematik klasse

1105
00:54:17,219 --> 00:54:20,510
at du måske tegne et lighedstegn med
en linje gennem det at angive ikke lige.

1106
00:54:20,510 --> 00:54:23,135
Det er generelt ikke et tegn
du kan skrive på tastaturet.

1107
00:54:23,135 --> 00:54:26,480
Og så i de fleste programmeringssprog,
når du ønsker at sige ikke lige,

1108
00:54:26,480 --> 00:54:29,160
du bruger et udråbstegn,
ellers kendt som bang.

1109
00:54:29,160 --> 00:54:33,180
Så du siger bang lig, som
betyder ikke lig, logisk.

1110
00:54:33,180 --> 00:54:38,060
Det er bare som om der ikke er en større
end, eller lig med eller mindre end

1111
00:54:38,060 --> 00:54:41,270
eller lig med tasten på tastaturet
der kan det hele i ét symbol.

1112
00:54:41,270 --> 00:54:44,020
Så det er derfor, i tidligere eksempler,
du gjorde en åben konsol, og derefter

1113
00:54:44,020 --> 00:54:48,670
et lighedstegn, for at gøre
større end eller, siger, mindre end.

1114
00:54:48,670 --> 00:54:49,910
>> Så hvad er takeaway her?

1115
00:54:49,910 --> 00:54:53,880
Dette er blot en måde nu af
indføre denne syntaks, denne funktion,

1116
00:54:53,880 --> 00:54:57,390
iteration frem for individuelle
tegn i en streng.

1117
00:54:57,390 --> 00:55:00,260
Og ligesom dem pladsen
parentes tillader dig at få på dem,

1118
00:55:00,260 --> 00:55:03,790
overveje disse kantede parenteser som
slags antyde denne underliggende

1119
00:55:03,790 --> 00:55:06,040
design, hvorved hver
karakter indersiden af ​​en streng

1120
00:55:06,040 --> 00:55:10,180
er slags boxed i et eller andet sted under
hætten i computerens hukommelse.

1121
00:55:10,180 --> 00:55:12,340
>> Men lad os lave en variant af denne.

1122
00:55:12,340 --> 00:55:14,880
Det viser sig, at denne
Programmet er korrekt.

1123
00:55:14,880 --> 00:55:18,810
Så pr CS50 akser til evaluering
kode, dette er korrekt nu.

1124
00:55:18,810 --> 00:55:22,959
Især nu, at jeg tjekker for
null, bør dette program aldrig gå ned.

1125
00:55:22,959 --> 00:55:24,500
Og jeg ved bare, at fra erfaring.

1126
00:55:24,500 --> 00:55:28,040
Men der er ikke noget andet, der
vi kan virkelig gå galt her.

1127
00:55:28,040 --> 00:55:31,860
Men det er ikke meget veltilrettelagt,
fordi lad os gå tilbage til basics.

1128
00:55:31,860 --> 00:55:34,450
>> Første, principles--
hvad betyder en for-løkke gøre?

1129
00:55:34,450 --> 00:55:36,290
En for-løkke gør tre ting.

1130
00:55:36,290 --> 00:55:39,340
Det initialiserer nogle
værdi, hvis du beder den om.

1131
00:55:39,340 --> 00:55:41,770
Den kontrollerer en betingelse.

1132
00:55:41,770 --> 00:55:45,380
Og så efter hver
iteration, efter hver cyklus,

1133
00:55:45,380 --> 00:55:49,330
det forøger nogle
værdi eller værdier, her.

1134
00:55:49,330 --> 00:55:50,600
>> Så hvad betyder det?

1135
00:55:50,600 --> 00:55:52,940
Vi initialisere jeg til 0.

1136
00:55:52,940 --> 00:55:58,610
Vi kontrollere og sørge for jeg er mindre end
længden af ​​s, som er Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
så der er mindre end 6.

1138
00:55:59,900 --> 00:56:02,590
Og, ja, 0 som mindre end 6.

1139
00:56:02,590 --> 00:56:05,580
>> Vi udskrive Z fra Zamyla navn.

1140
00:56:05,580 --> 00:56:08,080
Derefter tilvækst vi i fra 0 til 1.

1141
00:56:08,080 --> 00:56:11,290
Vi derefter kontrollere, er en mindre
end længden af ​​s?

1142
00:56:11,290 --> 00:56:13,270
Længden af ​​s er 6.

1143
00:56:13,270 --> 00:56:13,950
Ja det er.

1144
00:56:13,950 --> 00:56:16,880
>> Så vi udskrive en i Zamyla navn, ZA.

1145
00:56:16,880 --> 00:56:20,090
Vi tilvækst i fra 0 til 1, til to.

1146
00:56:20,090 --> 00:56:23,720
Vi derefter kontrollere, er to mindre end
længden af ​​Zamyla navn.

1147
00:56:23,720 --> 00:56:25,380
6- så 2 er mindre end 6.

1148
00:56:25,380 --> 00:56:30,460
Ja, lad os udskrive nu M i
Zamyla navn, den tredje karakter.

1149
00:56:30,460 --> 00:56:34,110
>> Det centrale her er, at hver
iteration af historien, jeg tjekker,

1150
00:56:34,110 --> 00:56:37,810
er jeg mindre end længden af ​​Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Men fangsten er, at
Stirling er ikke en egenskab.

1152
00:56:40,350 --> 00:56:43,100
De af jer, der har programmeret
før i Java eller andre sprog

1153
00:56:43,100 --> 00:56:46,310
måske kender længden af ​​en streng er
en ejendom, blot nogle read only værdi.

1154
00:56:46,310 --> 00:56:50,220
>> I C i dette tilfælde, hvis det er
en funktion, der er bogstaveligt

1155
00:56:50,220 --> 00:56:53,520
tælling af antallet af
tegn i Zamyla hver gang

1156
00:56:53,520 --> 00:56:54,740
vi kalder denne funktion.

1157
00:56:54,740 --> 00:56:58,500
Hver gang du beder computeren til at bruge
Stirling, er det at tage et kig på Zamyla,

1158
00:56:58,500 --> 00:57:01,960
og siger Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Og den returnerer 6.

1160
00:57:02,962 --> 00:57:04,920
Næste gang du ringer
det indeni, der for-løkke,

1161
00:57:04,920 --> 00:57:08,610
det kommer til at se på Zamyla
atter siger Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Og det kommer til at vende tilbage 6.

1163
00:57:10,320 --> 00:57:12,980
Så hvad er dumt om dette design?

1164
00:57:12,980 --> 00:57:17,700
>> Hvorfor er min kode ikke en 5 ud af 5
for design lige nu, så at sige?

1165
00:57:17,700 --> 00:57:20,600
Nå, jeg spørger en
spørgsmål unødigt.

1166
00:57:20,600 --> 00:57:23,030
Jeg gør mere arbejde, end jeg har brug for.

1167
00:57:23,030 --> 00:57:25,370
>> Så selvom
svar er korrekt, er jeg

1168
00:57:25,370 --> 00:57:29,560
beder computeren, hvad der er
længden af ​​Zamyla igen,

1169
00:57:29,560 --> 00:57:31,380
og igen, og igen, og igen?

1170
00:57:31,380 --> 00:57:33,980
Og svaret er
aldrig kommer til at ændre sig.

1171
00:57:33,980 --> 00:57:35,900
Det er altid vil være 6.

1172
00:57:35,900 --> 00:57:39,730
>> Så en bedre løsning end dette
ville være denne næste version.

1173
00:57:39,730 --> 00:57:43,390
Lad mig gå videre og sætte det i en
separat fil kaldet string1.c,

1174
00:57:43,390 --> 00:57:44,990
bare for at holde det adskilt.

1175
00:57:44,990 --> 00:57:47,260
Og det viser sig i en for
loop, kan du faktisk

1176
00:57:47,260 --> 00:57:50,210
erklære flere variabler på én gang.

1177
00:57:50,210 --> 00:57:53,460
>> Så jeg har tænkt mig at holde i og sæt den til 0.

1178
00:57:53,460 --> 00:57:56,190
Men jeg vil også
tilføje et komma, og sige,

1179
00:57:56,190 --> 00:58:01,050
give mig en variabel kaldet n, hvis
værdi svarer strengen længde s.

1180
00:58:01,050 --> 00:58:09,410
Og nu skal du gøre min tilstand
så længe jeg er mindre end n.

1181
00:58:09,410 --> 00:58:14,140
>> Så på denne måde, logikken er
identisk i slutningen af ​​dagen.

1182
00:58:14,140 --> 00:58:18,280
Men jeg huske
værdi 6, i dette tilfælde.

1183
00:58:18,280 --> 00:58:19,780
Hvad er længden af ​​Zamyla navn?

1184
00:58:19,780 --> 00:58:20,860
Og jeg sætte det på n.

1185
00:58:20,860 --> 00:58:23,050
>> Og jeg er stadig kontrol
tilstanden hver gang.

1186
00:58:23,050 --> 00:58:24,300
Er 0 mindre end 6?

1187
00:58:24,300 --> 00:58:25,600
Er 1 mindre end 6?

1188
00:58:25,600 --> 00:58:28,600
Er 2 mindre end 6, og så videre?

1189
00:58:28,600 --> 00:58:31,914
>> Men jeg beder ikke computeren
igen og igen, hvad er

1190
00:58:31,914 --> 00:58:33,080
længden af ​​Zamyla navn?

1191
00:58:33,080 --> 00:58:34,320
Hvad er længden på Zamyla navn?

1192
00:58:34,320 --> 00:58:35,986
Hvad er længden af ​​denne Zamyla navn?

1193
00:58:35,986 --> 00:58:40,440
Jeg bogstaveligt huske, at første og
kun svare i denne anden variabel n.

1194
00:58:40,440 --> 00:58:45,280
Så det nu ville være ikke blot
korrekt, men også veldesignede.

1195
00:58:45,280 --> 00:58:46,670
>> Nu, hvad stil?

1196
00:58:46,670 --> 00:58:48,866
Jeg har navngivet mine variabler
temmelig godt, vil jeg sige.

1197
00:58:48,866 --> 00:58:50,240
De er super kortfattet lige nu.

1198
00:58:50,240 --> 00:58:52,090
Og det er helt fint.

1199
00:58:52,090 --> 00:58:55,120
>> Hvis du kun har én
streng i et program,

1200
00:58:55,120 --> 00:58:56,860
du kan lige så godt kalde det s for streng.

1201
00:58:56,860 --> 00:58:59,370
Hvis du kun har en variabel
til tælling i et program,

1202
00:58:59,370 --> 00:59:00,710
du kan lige så godt kalde det i.

1203
00:59:00,710 --> 00:59:03,500
Hvis du har en længde, n
er super almindeligt.

1204
00:59:03,500 --> 00:59:05,800
Men jeg har ikke kommenteret nogen af ​​min kode.

1205
00:59:05,800 --> 00:59:09,200
>> Jeg har ikke informeret reader--
hvorvidt det er min TF eller TA,

1206
00:59:09,200 --> 00:59:12,460
eller bare colleague-- hvad formodes
at være foregår i dette program.

1207
00:59:12,460 --> 00:59:15,760
Og så for at få god stil,
hvad jeg ønsker at gøre

1208
00:59:15,760 --> 00:59:24,580
er denne-- noget
ligesom bede brugeren om input.

1209
00:59:24,580 --> 00:59:26,670
Og jeg kunne omskrive
dette en række forskellige måder.

1210
00:59:26,670 --> 00:59:35,630
>> Sørg S-- sørg get
streng returneres en streng.

1211
00:59:35,630 --> 00:59:40,280
Og så i her-- og det er måske
det vigtigste comment-- iterate

1212
00:59:40,280 --> 00:59:44,450
over tegn i s én ad gangen.

1213
00:59:44,450 --> 00:59:47,060
Og jeg kunne bruge nogen
valg af engelsk sprog

1214
00:59:47,060 --> 00:59:49,650
her for at beskrive hver
af disse klumper af kode.

1215
00:59:49,650 --> 00:59:52,740
>> Bemærk, at jeg ikke har lagt et
kommentere på hver linje kode,

1216
00:59:52,740 --> 00:59:55,690
egentlig bare på det interessante
dem, dem, der

1217
00:59:55,690 --> 00:59:59,460
har en mening, som jeg kunne
ønsker at gøre super klar til en person

1218
00:59:59,460 --> 01:00:00,460
læse min kode.

1219
01:00:00,460 --> 01:00:02,920
Og hvorfor kalder du få
snor bede brugeren om input?

1220
01:00:02,920 --> 01:00:05,450
Selv at man ikke nødvendigvis
alt det beskrivende.

1221
01:00:05,450 --> 01:00:09,340
Men det hjælper at fortælle en historie, fordi den
anden linje i historien er, skal du sørge

1222
01:00:09,340 --> 01:00:10,740
få strengen returneres en streng.

1223
01:00:10,740 --> 01:00:14,260
>> Og den tredje linje i historien er,
gentage over personerne i s én

1224
01:00:14,260 --> 01:00:15,380
på et tidspunkt.

1225
01:00:15,380 --> 01:00:17,920
Og nu bare for god foranstaltning,
Jeg har tænkt mig at gå videre og tilføje

1226
01:00:17,920 --> 01:00:24,560
endnu en kommentar, der bare
siger print i'te tegn i s.

1227
01:00:24,560 --> 01:00:26,520
Nu, hvad har jeg gjort
i sidste ende?

1228
01:00:26,520 --> 01:00:29,190
>> Jeg har tilføjet nogle engelsk
ord i form af kommentarer.

1229
01:00:29,190 --> 01:00:32,700
Den skråstreg skråstreg symbol betyder, hey,
computer er for den menneskelige,

1230
01:00:32,700 --> 01:00:33,820
ikke for dig, computeren.

1231
01:00:33,820 --> 01:00:35,119
Så de er ignoreret logisk.

1232
01:00:35,119 --> 01:00:35,910
De er der bare.

1233
01:00:35,910 --> 01:00:39,830
>> Og, ja, CS50 IDE viser dem som
grå, som nyttige, men ikke nøgle

1234
01:00:39,830 --> 01:00:41,000
til programmet.

1235
01:00:41,000 --> 01:00:42,570
Læg mærke til hvad du nu kan gøre.

1236
01:00:42,570 --> 01:00:44,950
Uanset om du kender C
programmering eller ej, du

1237
01:00:44,950 --> 01:00:47,722
kan bare stå tilbage på dette
program, og skimme kommentarerne.

1238
01:00:47,722 --> 01:00:50,180
Spørg brugeren om input, så sørg
få strengen returneres en streng,

1239
01:00:50,180 --> 01:00:53,009
gentage over personerne i s
en ad gangen, udskrive tegnet

1240
01:00:53,009 --> 01:00:55,550
i'te tegn i S-- du ikke
engang at se på koden

1241
01:00:55,550 --> 01:00:57,270
at forstå, hvad dette program gør.

1242
01:00:57,270 --> 01:01:00,280
Og, endnu bedre, hvis man selv ser
på dette program i en uge eller to,

1243
01:01:00,280 --> 01:01:02,280
eller en måned eller et år,
du også ikke har

1244
01:01:02,280 --> 01:01:04,420
at stirre på den kode,
forsøge at huske,

1245
01:01:04,420 --> 01:01:06,630
hvad var jeg forsøger at gøre med denne kode?

1246
01:01:06,630 --> 01:01:07,770
>> Du har fortalt dig selv.

1247
01:01:07,770 --> 01:01:11,660
Du har beskrevet det for dig selv,
eller nogle kollega, eller TA, eller TF.

1248
01:01:11,660 --> 01:01:14,860
Og så det ville nu være
korrekt, og godt design,

1249
01:01:14,860 --> 01:01:18,210
og i sidste ende god stil så godt.

1250
01:01:18,210 --> 01:01:19,990
Så gør holder det i tankerne.

1251
01:01:19,990 --> 01:01:22,200
>> Så der er en anden
ting jeg har tænkt mig at gøre her

1252
01:01:22,200 --> 01:01:28,240
der kan nu afsløre præcis, hvad der er
foregår under kølerhjelmen.

1253
01:01:28,240 --> 01:01:30,390
Så der er denne funktion
i C, og andre sprog,

1254
01:01:30,390 --> 01:01:33,010
kaldet typecasting
at enten implicit

1255
01:01:33,010 --> 01:01:37,250
eller eksplicit tillader dig at konvertere
fra en datatype til en anden.

1256
01:01:37,250 --> 01:01:39,800
Vi har været der beskæftiger sig så
langt i dag med strenge.

1257
01:01:39,800 --> 01:01:41,250
>> Og strenge er tegn.

1258
01:01:41,250 --> 01:01:44,910
Men huske fra uge
0, hvad er tegn?

1259
01:01:44,910 --> 01:01:49,334
Tegn er blot en abstraktion
oven på numbers-- decimaltal,

1260
01:01:49,334 --> 01:01:52,500
og decimaltal er egentlig bare en
abstraktion oven på binære tal,

1261
01:01:52,500 --> 01:01:53,720
som vi definerede det.

1262
01:01:53,720 --> 01:01:55,540
>> Så tegn er tal.

1263
01:01:55,540 --> 01:01:58,410
Og tal er tegn,
bare afhængigt af sammenhængen.

1264
01:01:58,410 --> 01:02:01,250
Og det viser sig, at der inde
af et edb-program,

1265
01:02:01,250 --> 01:02:06,830
kan du angive, hvordan du ønsker at se
på de bits inde i det program?

1266
01:02:06,830 --> 01:02:10,400
>> Recall fra uge 0, som vi havde
Ascii, som er lige denne kode

1267
01:02:10,400 --> 01:02:11,620
kortlægning breve til tal.

1268
01:02:11,620 --> 01:02:13,660
Og vi sagde, kapital A er 65.

1269
01:02:13,660 --> 01:02:15,860
Kapital B er 66, og så videre.

1270
01:02:15,860 --> 01:02:20,500
>> Og varsel, vi hovedsageligt har chars på
den øverste række her, som C ville kalde dem,

1271
01:02:20,500 --> 01:02:23,400
tegn og derefter
ints på den anden række.

1272
01:02:23,400 --> 01:02:28,180
Og det viser sig, du kan konvertere
problemfrit mellem de to, typisk.

1273
01:02:28,180 --> 01:02:30,042
Og hvis vi ønsker at gøre
dette bevidst, vi

1274
01:02:30,042 --> 01:02:31,750
måske ønsker at tackle
noget som dette.

1275
01:02:31,750 --> 01:02:33,590
>> Vi vil måske konvertere
store bogstaver for at sænke

1276
01:02:33,590 --> 01:02:35,330
tilfælde, eller små bogstaver til store bogstaver.

1277
01:02:35,330 --> 01:02:38,000
Og det viser sig at der er
faktisk et mønster her

1278
01:02:38,000 --> 01:02:39,900
vi kan omfavne på bare et øjeblik.

1279
01:02:39,900 --> 01:02:44,120
Men lad os først se på en
eksempel på at gøre dette eksplicit.

1280
01:02:44,120 --> 01:02:46,340
>> Jeg har tænkt mig at gå tilbage til CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Jeg har tænkt mig at skabe en
fil kaldet Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Og jeg har tænkt mig at gå videre og tilføje min
standard io.h foroven, int main void

1283
01:02:55,960 --> 01:02:57,370
på toppen af ​​min funktion.

1284
01:02:57,370 --> 01:03:02,700
Og så er jeg bare at gøre det
following-- en for-løkke fra i lig,

1285
01:03:02,700 --> 01:03:04,610
lad os sige, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Og så er jeg kommer til at være mindre end
65, plus 26 bogstaver i alfabetet.

1287
01:03:10,460 --> 01:03:12,640
Så jeg vil lade computeren
gøre det math for mig der.

1288
01:03:12,640 --> 01:03:15,100
Og derefter inde i denne løkke,
hvad skal jeg printe?

1289
01:03:15,100 --> 01:03:19,230
>> % C er% i omvendt skråstreg n.

1290
01:03:19,230 --> 01:03:21,290
Og nu vil jeg tilslutte to værdier.

1291
01:03:21,290 --> 01:03:24,530
Jeg har midlertidigt sat spørgsmål
markerer der for at invitere spørgsmålet.

1292
01:03:24,530 --> 01:03:29,940
>> Jeg ønsker at gentage fra 65 og fremefter
i 26 bogstaver i alfabetet,

1293
01:03:29,940 --> 01:03:35,190
udskrivning ud på hver iteration, som
figurs integreret tilsvarende.

1294
01:03:35,190 --> 01:03:38,299
Med andre ord, jeg ønsker at
gentage over 26 numre udskrivning

1295
01:03:38,299 --> 01:03:41,590
hvad Ascii karakter er, brevet,
og hvad det tilsvarende antal is--

1296
01:03:41,590 --> 01:03:44,650
virkelig bare genskabe
diagrammet fra dias.

1297
01:03:44,650 --> 01:03:47,010
Så hvad skal disse spørgsmålstegn være?

1298
01:03:47,010 --> 01:03:51,760
>> Tja, det viser sig, at den anden
man skal bare være variablen i.

1299
01:03:51,760 --> 01:03:53,860
Jeg ønsker at se det som et tal.

1300
01:03:53,860 --> 01:03:58,920
Og den midterste argument
her, kan jeg fortælle computeren

1301
01:03:58,920 --> 01:04:03,470
at behandle, at heltal
i som et tegn, så som

1302
01:04:03,470 --> 01:04:05,880
at erstatte det her for procent C.

1303
01:04:05,880 --> 01:04:07,990
>> Med andre ord, hvis I,
menneskelig programmør, vide

1304
01:04:07,990 --> 01:04:09,865
disse er blot tal
i sidste ende.

1305
01:04:09,865 --> 01:04:12,500
Og jeg ved, at 65 skulle
kort til nogle tegn.

1306
01:04:12,500 --> 01:04:15,310
Med denne eksplicit konvertering,
med en parentes,

1307
01:04:15,310 --> 01:04:18,840
navnet på den datatype, du ønsker at
konvertere til, og en lukket parentes,

1308
01:04:18,840 --> 01:04:21,200
du kan fortælle
computer, hey, computer,

1309
01:04:21,200 --> 01:04:24,130
konvertere dette heltal til en char.

1310
01:04:24,130 --> 01:04:26,250
>> Så når jeg køre dette
program efter kompilering,

1311
01:04:26,250 --> 01:04:29,740
lad os se, hvad jeg get-- gøre Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Darn det, hvad gjorde jeg forkert her?

1313
01:04:33,020 --> 01:04:35,884
Anvendelse af sort identifikator,
okay, ikke tilsigtet,

1314
01:04:35,884 --> 01:04:37,800
men lad os se om vi ikke kan
Grunden gennem dette.

1315
01:04:37,800 --> 01:04:41,220
>> Så linje five-- så jeg ikke får
meget langt, før skrue op.

1316
01:04:41,220 --> 01:04:42,140
Det er ok.

1317
01:04:42,140 --> 01:04:46,560
Så linje 5 for jeg lig 65-- jeg ser.

1318
01:04:46,560 --> 01:04:50,130
Så husk at i C, i modsætning til nogle
sprog, hvis du har forudgående programmering

1319
01:04:50,130 --> 01:04:52,190
erfaring, du har
at fortælle computeren,

1320
01:04:52,190 --> 01:04:55,040
modsætning Scratch, hvad
type variabel det er.

1321
01:04:55,040 --> 01:04:56,860
>> Og jeg glemte en central sætning her.

1322
01:04:56,860 --> 01:04:59,200
På linje fem, har jeg begyndte at bruge i.

1323
01:04:59,200 --> 01:05:01,560
Men jeg har ikke fortalt C
hvad datatype det er.

1324
01:05:01,560 --> 01:05:04,570
Så jeg har tænkt mig at gå ind her og
sige, ah, gør det et heltal.

1325
01:05:04,570 --> 01:05:07,050
>> Nu vil jeg gå videre og kompilere.

1326
01:05:07,050 --> 01:05:08,080
Det faste det.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, der er slags cool.

1328
01:05:12,660 --> 01:05:15,360
Ikke alene er det super hurtigt til
bede computeren dette spørgsmål,

1329
01:05:15,360 --> 01:05:18,885
snarere end at se det op på et dias,
det udskrives én pr linje, A er 65,

1330
01:05:18,885 --> 01:05:24,860
B er 66, hele vejen down-- da jeg
gjorde dette 26 gange-- til bogstaverne z,

1331
01:05:24,860 --> 01:05:25,630
hvilket er 90.

1332
01:05:25,630 --> 01:05:27,790
Og i virkeligheden, let
mere intelligent ville

1333
01:05:27,790 --> 01:05:31,030
har været for mig ikke at stole
på computeren for at tilføje 26.

1334
01:05:31,030 --> 01:05:34,060
Jeg kunne bare have gjort
90 så godt, så længe

1335
01:05:34,060 --> 01:05:37,390
da jeg ikke begå den samme fejl to gange.

1336
01:05:37,390 --> 01:05:41,880
Jeg ønsker at gå op gennem
z, ikke bare op gennem y.

1337
01:05:41,880 --> 01:05:44,000
>> Så det er en udtrykkelig cast.

1338
01:05:44,000 --> 01:05:47,860
Det viser sig, at denne
er ikke engang nødvendigt.

1339
01:05:47,860 --> 01:05:52,480
Lad mig gå videre og gentag dette
compiler, og gentagelsen Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Det viser sig, at C er temmelig smart.

1341
01:05:54,940 --> 01:05:57,150
>> Og printf, i særdeleshed,
er temmelig smart.

1342
01:05:57,150 --> 01:06:01,260
Hvis du bare bestå en jeg to gange
for begge pladsholdere, printf

1343
01:06:01,260 --> 01:06:04,510
vil indse, oh, godt jeg kender dig
gav mig en integer-- nogle tal,

1344
01:06:04,510 --> 01:06:06,380
ligesom 65 eller 90, eller hvad.

1345
01:06:06,380 --> 01:06:10,170
Men jeg kan se, at du vil have mig til
formatere dette nummer som et tegn.

1346
01:06:10,170 --> 01:06:16,460
Og så printf kan implicit støbt
den int til en char for dig så godt.

1347
01:06:16,460 --> 01:06:19,360
Så det er ikke et problem overhovedet.

1348
01:06:19,360 --> 01:06:23,100
>> Men varsel, på grund af denne ækvivalens
vi faktisk kan gøre det så godt.

1349
01:06:23,100 --> 01:06:26,520
Lad mig gå videre og gøre en
anden version af denne-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
Og i stedet for iteration løbet
heltal, kan virkelig blæse dit sind

1351
01:06:31,800 --> 01:06:33,610
ved iteration løbet tegn.

1352
01:06:33,610 --> 01:06:37,660
Hvis en char c får kapital A, jeg
ønsker at gå videre og gøre det,

1353
01:06:37,660 --> 01:06:41,740
så længe C er mindre end eller lig
til kapital Z. Og på hver iteration

1354
01:06:41,740 --> 01:06:45,690
Jeg ønsker at forøge C, jeg kan
nu i min printf linje her

1355
01:06:45,690 --> 01:06:51,320
sige, procent C er
procent i igen, komma C.

1356
01:06:51,320 --> 01:06:57,200
>> Og nu kan jeg gå den anden retning,
støbning tegnet udtrykkeligt

1357
01:06:57,200 --> 01:06:58,500
til et heltal.

1358
01:06:58,500 --> 01:07:00,560
Så igen, hvorfor skulle du gøre det?

1359
01:07:00,560 --> 01:07:03,830
Det er lidt underligt at sortere af
tæller i form af tegn.

1360
01:07:03,830 --> 01:07:07,430
>> Men hvis du forstår, hvad der er
foregår under emhætten,

1361
01:07:07,430 --> 01:07:08,430
der er virkelig ingen magi.

1362
01:07:08,430 --> 01:07:13,060
Du siger bare, hey, computer giver
mig en variabel kaldet C af typen char.

1363
01:07:13,060 --> 01:07:16,520
Initialiser den til kapital A. Og
bemærke enkelt citater sagen.

1364
01:07:16,520 --> 01:07:19,580
>> For tegn i C, husker fra
sidste uge, du bruger enkelte anførselstegn.

1365
01:07:19,580 --> 01:07:23,720
For strenge, efter ord,
sætninger, du bruger dobbelte anførselstegn.

1366
01:07:23,720 --> 01:07:27,210
OK, computer, holde gør dette, så
længe karakter er mindre end

1367
01:07:27,210 --> 01:07:28,050
eller lig med z.

1368
01:07:28,050 --> 01:07:32,640
Og jeg ved fra min Ascii tabel, alle
af disse ASCII-koder er sammenhængende.

1369
01:07:32,640 --> 01:07:33,400
>> Der er ingen huller.

1370
01:07:33,400 --> 01:07:36,737
Så det er bare A til Z,
adskilt af ét nummer hver.

1371
01:07:36,737 --> 01:07:38,820
Og så kan jeg tilvækst
en char, hvis jeg virkelig ønsker.

1372
01:07:38,820 --> 01:07:40,390
I sidste ende,
det er bare et tal.

1373
01:07:40,390 --> 01:07:41,030
Det ved jeg.

1374
01:07:41,030 --> 01:07:43,670
Så jeg kan bare antage at føje en til det.

1375
01:07:43,670 --> 01:07:46,940
>> Og så denne gang, jeg udskriver c,
og derefter integralet tilsvarende.

1376
01:07:46,940 --> 01:07:50,170
Og jeg behøver ikke engang den eksplicitte cast.

1377
01:07:50,170 --> 01:07:52,680
Jeg kan lade printf og
computer finde ud af ting,

1378
01:07:52,680 --> 01:07:57,300
så nu, hvis jeg løber
gøre Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Jeg får præcis det samme som godt.

1380
01:08:01,520 --> 01:08:04,530
>> Ubrugelig program, though-- ingen
vil faktisk skrive software

1381
01:08:04,530 --> 01:08:07,549
med henblik på at finde ud af, hvad der var den
nummer, der til A eller B, eller Z?

1382
01:08:07,549 --> 01:08:10,340
Du er bare kommer til at Google det, eller
slå det op online, eller slå det op

1383
01:08:10,340 --> 01:08:11,650
på et dias, eller lignende.

1384
01:08:11,650 --> 01:08:13,520
Så hvor dette rent faktisk få nyttige?

1385
01:08:13,520 --> 01:08:15,960
>> Nå, taler om, at
dias, bemærke at der er

1386
01:08:15,960 --> 01:08:20,890
en faktiske mønster her mellem store
og små bogstaver, der var ikke tilfældig.

1387
01:08:20,890 --> 01:08:23,760
Bemærk, at kapital A er 65.

1388
01:08:23,760 --> 01:08:25,830
Små bogstaver a er 97.

1389
01:08:25,830 --> 01:08:29,649
Og hvor langt væk er lavere tilfælde en?

1390
01:08:29,649 --> 01:08:32,649
>> Så 65 er, hvor mange skridt væk fra 97?

1391
01:08:32,649 --> 01:08:36,210
Så 97 minus 65 er 32.

1392
01:08:36,210 --> 01:08:37,910
Så kapital a er 65.

1393
01:08:37,910 --> 01:08:39,939
Hvis du tilføjer 32 til det,
du får små bogstaver a.

1394
01:08:39,939 --> 01:08:43,729
Og, ækvivalent, hvis du trækker 32,
du kommer tilbage til kapital en-- samme med B

1395
01:08:43,729 --> 01:08:46,380
til lille b, big C til lille c.

1396
01:08:46,380 --> 01:08:50,670
>> Alle disse huller er 32 fra hinanden.

1397
01:08:50,670 --> 01:08:54,450
Nu, dette synes at tillade os at
gøre noget som Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
eller Google Docs funktionen, hvor man
kan vælge alt og derefter sige,

1399
01:08:57,729 --> 01:09:00,520
ændre alle til små bogstaver, eller
ændre alle til store bogstaver,

1400
01:09:00,520 --> 01:09:03,840
eller ændre kun det første ord
af en sætning til store bogstaver.

1401
01:09:03,840 --> 01:09:07,390
Vi kan faktisk gøre noget
ligesom os selv.

1402
01:09:07,390 --> 01:09:12,645
>> Lad mig gå videre og gemme en fil
her kaldet kapitalisere 0.c.

1403
01:09:12,645 --> 01:09:15,770
Og lad os gå videre og pisk op et program
der gør netop dette som følger.

1404
01:09:15,770 --> 01:09:18,460
Så omfatte CS50 bibliotek.

1405
01:09:18,460 --> 01:09:21,430
Og inkluderer standard I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Og jeg ved, at dette kommer snart.

1407
01:09:22,787 --> 01:09:24,870
Så jeg har tænkt mig at sætte det i
der allerede, string.h,

1408
01:09:24,870 --> 01:09:26,960
så jeg har adgang til
ting som Stirling,

1409
01:09:26,960 --> 01:09:29,620
og derefter int vigtigste tomrum, som sædvanlig.

1410
01:09:29,620 --> 01:09:33,420
Og så jeg har tænkt mig at gå videre
og gøre strengene får få strengen,

1411
01:09:33,420 --> 01:09:35,032
bare for at få en streng fra brugeren.

1412
01:09:35,032 --> 01:09:36,740
Og så jeg har tænkt mig at
gøre mit sanity check.

1413
01:09:36,740 --> 01:09:40,510
Hvis strengen ikke er lig nul,
så er det sikkert at fortsætte.

1414
01:09:40,510 --> 01:09:42,000
Og hvad gør jeg ønsker at gøre?

1415
01:09:42,000 --> 01:09:48,700
Jeg har tænkt mig at gentage fra jeg lig 0,
og n op til strengen længde s.

1416
01:09:48,700 --> 01:09:51,899
>> Og jeg har tænkt mig at gøre det, så længe
Jeg er mindre end n, og jeg plus plus.

1417
01:09:51,899 --> 01:09:55,060
Indtil videre, jeg er virkelig bare
låne ideer fra før.

1418
01:09:55,060 --> 01:09:57,010
Og nu vil jeg præsentere en gren.

1419
01:09:57,010 --> 01:09:59,635
>> Så tænker tilbage på Scratch, hvor
vi havde disse gafler i vejen,

1420
01:09:59,635 --> 01:10:05,110
og i sidste uge i C. Jeg har tænkt mig at
sige dette, hvis den i'te tegn i s

1421
01:10:05,110 --> 01:10:09,250
er større end eller
lig til små bogstaver a,

1422
01:10:09,250 --> 01:10:13,340
og-- i Scratch du ville bogstaveligt
siger og, men i C du siger ét-tegn,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- og den i'te tegn i s
er mindre end eller lig med små bogstaver z,

1424
01:10:19,830 --> 01:10:21,780
lad os gøre noget interessant.

1425
01:10:21,780 --> 01:10:27,020
Lad os faktisk udskrive en
karakter uden ny linje

1426
01:10:27,020 --> 01:10:31,760
der er tegnet i strengen,
den i'te tegn i strengen.

1427
01:10:31,760 --> 01:10:37,420
>> Men lad os gå videre og
trække 32 fra den.

1428
01:10:37,420 --> 01:10:42,120
Else hvis tegnet i
streng, som vi leder efter

1429
01:10:42,120 --> 01:10:45,950
ikke er mellem lille en
og lidt z, gå videre

1430
01:10:45,950 --> 01:10:48,610
og lige udskrives det uændret.

1431
01:10:48,610 --> 01:10:50,840
Så vi har introduceret
denne parentes notation

1432
01:10:50,840 --> 01:10:53,560
for vores strenge at komme på
i'te tegn i strengen.

1433
01:10:53,560 --> 01:10:57,520
>> Jeg har tilføjet nogle betinget logik, ligesom
Scratch i sidste uges uge en, hvor

1434
01:10:57,520 --> 01:10:59,880
Jeg er bare bruge min grundlæggende
forståelse af, hvad der er

1435
01:10:59,880 --> 01:11:01,130
foregår under kølerhjelmen.

1436
01:11:01,130 --> 01:11:04,190
Er den i'te karakter s
større end eller lig med en?

1437
01:11:04,190 --> 01:11:08,290
Ligesom, er det 97 eller 98,
eller 99, og så videre?

1438
01:11:08,290 --> 01:11:11,940
>> Men det er også mindre end eller lig
til værdien af ​​små bogstaver z?

1439
01:11:11,940 --> 01:11:16,210
Og hvis ja, hvad betyder denne linje betyder?

1440
01:11:16,210 --> 01:11:20,250
14, dette er sortering af
kim af hele idéen,

1441
01:11:20,250 --> 01:11:23,840
kapitalisere brevet af
simpelthen at trække 32 fra det,

1442
01:11:23,840 --> 01:11:29,370
i dette tilfælde, fordi jeg ved, pr, at
diagram, hvordan mine tal er repræsenteret.

1443
01:11:29,370 --> 01:11:33,925
Så lad os gå videre og køre dette,
efter kompilering kapitalisere 0.c,

1444
01:11:33,925 --> 01:11:36,210
og køre kapitalisere 0.

1445
01:11:36,210 --> 01:11:40,300
>> Lad os skrive noget lignende
Zamyla i små bogstaver ind.

1446
01:11:40,300 --> 01:11:42,780
Og nu har vi Zamyla i alle store bogstaver.

1447
01:11:42,780 --> 01:11:45,050
Lad os skrive i Rob i små bogstaver.

1448
01:11:45,050 --> 01:11:46,674
Lad os prøve Jason i små bogstaver.

1449
01:11:46,674 --> 01:11:48,590
Og vi holder få
tvungen aktivering.

1450
01:11:48,590 --> 01:11:50,960
Der er en mindre fejl, som jeg
slags ikke forudse.

1451
01:11:50,960 --> 01:11:54,050
Læg mærke min nye prompt slutter op
på samme linje som deres navne,

1452
01:11:54,050 --> 01:11:55,520
som føles lidt rodet.

1453
01:11:55,520 --> 01:11:59,170
>> Så jeg har tænkt mig at gå her, og
faktisk i slutningen af ​​dette program

1454
01:11:59,170 --> 01:12:02,110
udskrive en ny linje karakter.

1455
01:12:02,110 --> 01:12:03,160
Det er alt.

1456
01:12:03,160 --> 01:12:06,120
Med printf, behøver du ikke at
passere i variabler eller format kode.

1457
01:12:06,120 --> 01:12:08,460
Du kan bogstaveligt talt bare udskrive
noget som en ny linje.

1458
01:12:08,460 --> 01:12:13,529
>> Så lad os gå videre og gøre
kapitalisere 0 igen, gentages det, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Og nu er det lidt pænere.

1460
01:12:14,820 --> 01:12:17,274
Nu er min prompt er på sin egen nye linje.

1461
01:12:17,274 --> 01:12:18,440
Så det er alt fint og godt.

1462
01:12:18,440 --> 01:12:19,910
Så det er et godt eksempel.

1463
01:12:19,910 --> 01:12:22,700
Men jeg ikke selv nødvendigvis
nødt til at indkode de 32.

1464
01:12:22,700 --> 01:12:23,350
Du ved hvad?

1465
01:12:23,350 --> 01:12:26,350
Jeg kunne say-- jeg ikke nogensinde
huske, hvad forskellen er.

1466
01:12:26,350 --> 01:12:29,330
>> Men jeg ved, at hvis jeg
har en lille bogstav,

1467
01:12:29,330 --> 01:12:34,430
Jeg hovedsagelig vil trække off
uanset afstand er mellem lidt

1468
01:12:34,430 --> 01:12:39,160
et og store A, fordi hvis jeg antager, at
alle de andre bogstaver er de samme,

1469
01:12:39,160 --> 01:12:41,045
der bør få arbejdet gjort.

1470
01:12:41,045 --> 01:12:42,670
Men i stedet for at gøre det, ved du hvad?

1471
01:12:42,670 --> 01:12:44,240
Der er en anden måde stadig.

1472
01:12:44,240 --> 01:12:48,090
>> Hvis der er kapitalisere 1.c-- hvis jeg var
at sætte det ind i en separat fil.

1473
01:12:48,090 --> 01:12:51,030
Lad os gøre kapitalisere 2.c som følger.

1474
01:12:51,030 --> 01:12:53,060
Jeg har tænkt mig at virkelig rydde det op her.

1475
01:12:53,060 --> 01:12:57,420
Og i stedet for selv at skulle
kender eller bekymrer sig om dem, lavt niveau

1476
01:12:57,420 --> 01:13:01,090
implementeringsdetaljer, jeg er i stedet
bare at udskrive en karakter,

1477
01:13:01,090 --> 01:13:04,610
citat Citat slut, procent C, og
derefter kalde en anden funktion, som

1478
01:13:04,610 --> 01:13:09,950
eksisterer der tager et argument,
hvilket er et tegn, som denne.

1479
01:13:09,950 --> 01:13:12,630
>> Det viser sig i C, er der
en anden funktion opkald

1480
01:13:12,630 --> 01:13:15,550
til øvre, der som navnet
foreslår tager en karakter

1481
01:13:15,550 --> 01:13:19,350
og gør det til sin store bogstaver
tilsvarende, og derefter vender tilbage det

1482
01:13:19,350 --> 01:13:21,410
så printf kan tilslutte det der.

1483
01:13:21,410 --> 01:13:25,484
Og så for at gøre det, selv om, jeg
nødt til at indføre en anden fil.

1484
01:13:25,484 --> 01:13:28,400
Det viser sig, at der er en anden fil
at du kun ville vide fra klassen,

1485
01:13:28,400 --> 01:13:33,020
eller en lærebog, eller en online
reference, kaldet C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Så hvis jeg tilføje, at op blandt min header
filer, og nu re-kompilere dette program,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Lad os skrive i Zamyla i alt
små bogstaver, fungerer stadig den samme.

1489
01:13:46,690 --> 01:13:48,040
Men ved du hvad?

1490
01:13:48,040 --> 01:13:55,590
Det viser sig, at øvre
har nogle andre funktioner.

1491
01:13:55,590 --> 01:13:58,410
>> Og lad mig introducere dette
befaler her, slags akavet

1492
01:13:58,410 --> 01:14:00,250
navngivet, men mennesket til manuel.

1493
01:14:00,250 --> 01:14:03,960
Det viser sig, at de fleste Linux computere,
som vi bruger her-- Linux operativsystem

1494
01:14:03,960 --> 01:14:06,270
system-- have en kommando
kaldet mand, som siger,

1495
01:14:06,270 --> 01:14:08,530
hey, computer, giv mig
computerens manual.

1496
01:14:08,530 --> 01:14:10,680
hvad vil du
ser op i den manual?

1497
01:14:10,680 --> 01:14:13,840
>> Jeg ønsker at se op funktionen
kaldet til øverste, Enter.

1498
01:14:13,840 --> 01:14:16,070
Og det er lidt kryptisk
at læse nogle gange.

1499
01:14:16,070 --> 01:14:18,780
Men bemærker vi er i
Linux programmør manual.

1500
01:14:18,780 --> 01:14:19,530
Og det er al tekst.

1501
01:14:19,530 --> 01:14:21,905
Og bemærke, at der er den
navn på funktionen heroppe.

1502
01:14:21,905 --> 01:14:25,030
Det viser sig, det har en fætter kaldet
at sænke, hvilket gør det modsatte.

1503
01:14:25,030 --> 01:14:29,710
Og varsel under synopsis, at bruge denne
fungere manden siden, så at sige,

1504
01:14:29,710 --> 01:14:32,220
fortæller mig, at jeg
nødt til at omfatte c type.h.

1505
01:14:32,220 --> 01:14:33,630
Og jeg vidste, at fra praksis.

1506
01:14:33,630 --> 01:14:36,210
>> Her er det viser mig de to
prototyper til funktionen,

1507
01:14:36,210 --> 01:14:39,070
så hvis jeg nogensinde vil bruge denne
Jeg ved, hvad de tager som input,

1508
01:14:39,070 --> 01:14:40,652
og hvad de vender tilbage som output.

1509
01:14:40,652 --> 01:14:42,360
Og så hvis jeg læser
beskrivelsen, jeg ser

1510
01:14:42,360 --> 01:14:44,820
mere detaljeret, hvad funktionen gør.

1511
01:14:44,820 --> 01:14:48,100
Men endnu vigtigere, hvis
Jeg ser under returværdi,

1512
01:14:48,100 --> 01:14:51,710
det siger den returnerede værdi er
den af ​​den konverterede brev,

1513
01:14:51,710 --> 01:14:57,880
eller C, den oprindelige input, hvis
omdannelsen var ikke muligt.

1514
01:14:57,880 --> 01:15:01,992
>> Med andre ord, at øvre vil forsøge
at konvertere et brev til store bogstaver.

1515
01:15:01,992 --> 01:15:03,450
Og hvis ja, vil det returnere det.

1516
01:15:03,450 --> 01:15:07,010
Men hvis det ikke kan for nogle reason--
måske er det allerede store bogstaver,

1517
01:15:07,010 --> 01:15:09,550
måske er det et udråbstegn
eller en anden punctuation--

1518
01:15:09,550 --> 01:15:12,200
det bare at gå til
returnerer originalen C,

1519
01:15:12,200 --> 01:15:17,340
hvilket betyder, at jeg kan gøre min kode
bedre udformet som følger.

1520
01:15:17,340 --> 01:15:20,580
>> Jeg har ikke brug for alle
disse darn linjer kode.

1521
01:15:20,580 --> 01:15:22,610
Alle de linjer, jeg har
netop fremhævet kan

1522
01:15:22,610 --> 01:15:28,700
foldes sammen i kun et enkelt
linje, som er denne-- printf procent

1523
01:15:28,700 --> 01:15:33,510
C til øvre S beslag i.

1524
01:15:33,510 --> 01:15:36,090
Og det ville være en
eksempel på bedre design.

1525
01:15:36,090 --> 01:15:40,040
>> Hvorfor gennemføre i 7 eller 8 linjer
kode, hvad det var jeg bare

1526
01:15:40,040 --> 01:15:44,960
slettet, når du i stedet kan kollapse
alt dette logik og beslutningstagning

1527
01:15:44,960 --> 01:15:49,620
i en enkelt linje, 13 nu, at
afhængig af et bibliotek function--

1528
01:15:49,620 --> 01:15:53,430
en funktion, der kommer med C, men
gør præcis, hvad du vil have den til at gøre.

1529
01:15:53,430 --> 01:15:55,295
Og helt ærligt, selv om
det kom ikke med C,

1530
01:15:55,295 --> 01:15:58,880
du kunne gennemføre det selv, som
vi har set, med få negativ int

1531
01:15:58,880 --> 01:16:01,700
og få positiv int sidste uge så godt.

1532
01:16:01,700 --> 01:16:03,470
>> Denne kode nu er meget mere læsbar.

1533
01:16:03,470 --> 01:16:06,670
Og, ja, hvis vi rulle op,
se, hvor meget mere kompakt

1534
01:16:06,670 --> 01:16:08,360
denne version af mit program er.

1535
01:16:08,360 --> 01:16:11,230
Det er lidt top tung nu,
med alle disse omfatter.

1536
01:16:11,230 --> 01:16:14,380
Men det er OK, fordi nu er jeg stående
på skuldrene af programmører

1537
01:16:14,380 --> 01:16:15,300
før mig.

1538
01:16:15,300 --> 01:16:18,440
Og hvem var det, der
implementeret til øvre virkelig

1539
01:16:18,440 --> 01:16:21,470
gjorde mig en tjeneste, ligesom hvem
implementeret Stirling virkelig

1540
01:16:21,470 --> 01:16:24,790
gjorde mig en tjeneste for nogen tid siden.

1541
01:16:24,790 --> 01:16:26,970
Og så nu har vi en
bedre design program

1542
01:16:26,970 --> 01:16:31,680
som gennemfører den præcis samme logik.

1543
01:16:31,680 --> 01:16:35,580
>> Apropos stirling, lad
mig gå videre og gøre dette.

1544
01:16:35,580 --> 01:16:38,320
Lad mig gå videre og spare
denne fil som stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Og det viser sig, kan vi skrælle
et andet lag temmelig simpelthen nu.

1546
01:16:43,255 --> 01:16:45,630
Jeg har tænkt mig at gå videre og pisk
op et andet program i main

1547
01:16:45,630 --> 01:16:49,759
her, der blot re-redskaber
snor længde som følger.

1548
01:16:49,759 --> 01:16:52,300
Så her er en linje kode, der
får mig en streng fra brugeren.

1549
01:16:52,300 --> 01:16:53,910
Vi bliver ved at bruge det igen og igen.

1550
01:16:53,910 --> 01:16:58,900
Lad mig give mig selv en variabel kaldet
n af typen int, der gemmer et nummer.

1551
01:16:58,900 --> 01:17:02,490
>> Og lad mig gå videre og
gøre følgende logik.

1552
01:17:02,490 --> 01:17:15,610
Mens det n'te tegn i s gør
ikke lige omvendt skråstreg 0, gå videre

1553
01:17:15,610 --> 01:17:17,930
og tilvækst n.

1554
01:17:17,930 --> 01:17:23,506
Og så udskrive printf procent i n.

1555
01:17:23,506 --> 01:17:29,200
Jeg hævder, at dette program her,
uden at strengen længde,

1556
01:17:29,200 --> 01:17:31,150
tal ud længden af ​​en streng.

1557
01:17:31,150 --> 01:17:34,600
>> Og magien er helt
indkapslet i linje 8

1558
01:17:34,600 --> 01:17:39,830
her med hvad der ligner ny syntaks,
denne backslash 0 i enkelte anførselstegn.

1559
01:17:39,830 --> 01:17:41,360
Men hvorfor er det?

1560
01:17:41,360 --> 01:17:44,100
Nå, overveje, hvad der er blevet
foregår al denne tid.

1561
01:17:44,100 --> 01:17:47,990
>> Og som en sidebemærkning, før jeg glemmer, indser
også, at der ud over man-siderne

1562
01:17:47,990 --> 01:17:50,920
der kommer med en typisk
Linux system som CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
indse, at vi, den
Selvfølgelig personale, også har

1564
01:17:53,770 --> 01:17:56,030
lavet en hjemmeside-version
af denne samme idé kaldet

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, der har
alle de samme man-sider,

1566
01:17:59,940 --> 01:18:02,020
alt dette samme
dokumentation, samt

1567
01:18:02,020 --> 01:18:05,730
en lille boks i toppen, der giver mulighed
at konvertere alle de forholdsvis

1568
01:18:05,730 --> 01:18:09,025
mystiske sprog i mindre behagelig
tilstand, hvor vi, lærergruppen,

1569
01:18:09,025 --> 01:18:12,150
har gennemgået og forsøgt at forenkle
nogle af sproget til at holde tingene

1570
01:18:12,150 --> 01:18:14,830
fokuseret på ideer, og ikke
nogle af de tekniske detaljer.

1571
01:18:14,830 --> 01:18:20,070
Så husk, reference.cs50.net
som en anden ressource samt.

1572
01:18:20,070 --> 01:18:23,800
>> Men hvorfor gør strengen længde arbejde i
den måde, jeg foreslog for et øjeblik siden?

1573
01:18:23,800 --> 01:18:25,160
Her er Zamyla navn igen.

1574
01:18:25,160 --> 01:18:27,690
Og her er Zamyla navn
boxed i, da jeg holde gør,

1575
01:18:27,690 --> 01:18:31,360
at male et billede af det er,
virkelig, bare en sekvens af tegn.

1576
01:18:31,360 --> 01:18:34,260
Men Zamyla eksisterer ikke
isoleret i et program.

1577
01:18:34,260 --> 01:18:37,420
>> Når du skriver og køre et program,
du bruger din Mac eller din PC

1578
01:18:37,420 --> 01:18:40,010
som hukommelse, eller RAM så at sige.

1579
01:18:40,010 --> 01:18:42,620
Og du kan tænke på
computeren som havende

1580
01:18:42,620 --> 01:18:44,730
masser af gigabyte hukommelse i disse dage.

1581
01:18:44,730 --> 01:18:47,700
Og en koncert betyder milliarder,
så milliarder af bytes.

1582
01:18:47,700 --> 01:18:48,910
>> Men lad os spole tilbage i tiden.

1583
01:18:48,910 --> 01:18:51,530
Og formoder, at vi bruger
en rigtig gammel computer,

1584
01:18:51,530 --> 01:18:55,150
kun har 32 bytes hukommelse.

1585
01:18:55,150 --> 01:18:59,310
Jeg kunne, på min computerskærm,
blot trække det ud som følger.

1586
01:18:59,310 --> 01:19:05,240
>> Jeg kunne simpelthen sige, at min
computer har hele denne hukommelse.

1587
01:19:05,240 --> 01:19:08,830
Og det er ligesom en pind af hukommelse, hvis
du husker vores billede fra sidste gang.

1588
01:19:08,830 --> 01:19:11,670
Og hvis jeg bare dividere
dette i nok gange,

1589
01:19:11,670 --> 01:19:15,040
Jeg hævder, at jeg har 32 bytes
hukommelse på skærmen.

1590
01:19:15,040 --> 01:19:18,239
>> Nu, i virkeligheden, kan jeg kun
trække så langt på denne skærm her.

1591
01:19:18,239 --> 01:19:20,280
Så jeg har tænkt mig at gå videre,
og bare ved konvention,

1592
01:19:20,280 --> 01:19:24,050
henlede min computers hukommelse som en
grid, ikke blot som en lige linje.

1593
01:19:24,050 --> 01:19:28,190
Specifikt Jeg hævder nu, at
dette gitter, denne 8 ved 4 gitter,

1594
01:19:28,190 --> 01:19:31,800
blot repræsenterer alle 32 bytes
tilgængelige hukommelse i min Mac,

1595
01:19:31,800 --> 01:19:33,030
eller tilgængelige i min PC.

1596
01:19:33,030 --> 01:19:34,780
Og de er indpakning
på to linjer, bare

1597
01:19:34,780 --> 01:19:38,030
fordi det passer mere på skærmen.

1598
01:19:38,030 --> 01:19:40,800
Men dette er den første byte.

1599
01:19:40,800 --> 01:19:41,990
Dette er den anden byte.

1600
01:19:41,990 --> 01:19:43,300
Dette er den tredje byte.

1601
01:19:43,300 --> 01:19:45,310
>> Og det er den 32. byte.

1602
01:19:45,310 --> 01:19:52,910
Eller, hvis vi tænker som en computer
videnskabsmand, er dette byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Så du har 0 til 31, hvis
du begynde at tælle på 0.

1604
01:19:55,950 --> 01:19:59,830
>> Så hvis vi bruger et program
at opkald får streng,

1605
01:19:59,830 --> 01:20:05,280
og vi får en streng fra det menneskelige
ligesom jeg gjorde kaldet Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
hvordan i verden gør
computer holde styr på, hvilke byte,

1607
01:20:09,430 --> 01:20:12,230
hvilken klump hukommelse,
hører til hvilken streng?

1608
01:20:12,230 --> 01:20:16,270
Med andre ord, hvis vi går over til
skriv et andet navn i computeren,

1609
01:20:16,270 --> 01:20:19,890
som denne Andi, kalder
få snor anden gang,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I har at ende i den
computerens hukommelse så godt.

1611
01:20:23,030 --> 01:20:23,850
Men hvordan?

1612
01:20:23,850 --> 01:20:29,700
>> Tja, det viser sig, at under
hætte, hvad C gør, når opbevaring af strenge

1613
01:20:29,700 --> 01:20:35,080
at de menneskelige typer i, eller at
komme fra en anden kilde, er det

1614
01:20:35,080 --> 01:20:39,190
afgrænser enden af ​​dem med
en særlig character-- backslash

1615
01:20:39,190 --> 01:20:44,750
0, som er blot en særlig måde
sige 80 bit i en række.

1616
01:20:44,750 --> 01:20:47,950
>> Så en-- dette er nummer 97 tilbagekaldelse.

1617
01:20:47,950 --> 01:20:51,770
Så nogle mønster af 8 bit
repræsenterer decimaltal 97.

1618
01:20:51,770 --> 01:20:58,070
Denne backslash 0 er bogstaveligt talt det antal
0, alias nul, N-U-L modsætning tidligere,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, som vi talte om.

1620
01:20:59,630 --> 01:21:05,700
Men for nu, bare vide, at denne
backslash 0 er kun 80 bits i træk.

1621
01:21:05,700 --> 01:21:09,810
>> Og det er bare denne linje i
sand, der siger noget til venstre

1622
01:21:09,810 --> 01:21:12,610
hører til en streng, eller en datatype.

1623
01:21:12,610 --> 01:21:15,480
Og noget til højre
hører til noget andet.

1624
01:21:15,480 --> 01:21:17,440
Andi navn, i mellemtiden,
som netop visuelt

1625
01:21:17,440 --> 01:21:21,310
sker for at ombryde på den anden linje,
men det er bare en æstetisk detalje,

1626
01:21:21,310 --> 01:21:23,990
tilsvarende er nul afsluttes.

1627
01:21:23,990 --> 01:21:29,290
>> Det er en streng af en A-N-D-I figurer,
plus en femte hemmelig karakter,

1628
01:21:29,290 --> 01:21:33,560
alle 0 bits, der bare afgrænser
slutningen af ​​Andi navn så godt.

1629
01:21:33,560 --> 01:21:37,120
Og hvis vi kalder får strengen en tredje gang
i computeren for at få en streng som

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, ligeledes er Marias
navn nul termineret med backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Dette er fundamentalt forskellige
fra hvordan en computer ville typisk

1632
01:21:47,170 --> 01:21:51,850
lagre et heltal eller en flyder, eller andre
datatyper stadig, fordi tilbagekaldelse,

1633
01:21:51,850 --> 01:21:57,420
et helt tal er normalt 32 bits, eller
4 byte, eller måske endda 64 bit,

1634
01:21:57,420 --> 01:21:59,100
eller otte bytes.

1635
01:21:59,100 --> 01:22:02,620
Men mange primitiver i en computer
i et programmeringssprog

1636
01:22:02,620 --> 01:22:05,550
har et fast antal
bytes under hood--

1637
01:22:05,550 --> 01:22:08,100
måske en, måske to, måske 4, måske 8.

1638
01:22:08,100 --> 01:22:13,250
>> Men strygere, ved design, har en
dynamisk antal tegn.

1639
01:22:13,250 --> 01:22:16,980
Du ved ikke på forhånd, indtil
de humane typer i Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
eller M-A-R-I-A, eller A-N-D-I. Du kender ikke
hvor mange gange brugeren vil ramme

1641
01:22:21,400 --> 01:22:22,070
tastaturet.

1642
01:22:22,070 --> 01:22:26,490
Derfor behøver du ikke ved, hvordan
mange tegn i forvejen

1643
01:22:26,490 --> 01:22:27,540
du får brug for.

1644
01:22:27,540 --> 01:22:31,840
>> Og så C bare lidt blade som en
hemmelig brødkrumme under kølerhjelmen

1645
01:22:31,840 --> 01:22:32,960
ved slutningen af ​​strengen.

1646
01:22:32,960 --> 01:22:39,280
Efter lagring Z-A-M-Y-L-A i hukommelsen,
det også bare sætter ækvivalent

1647
01:22:39,280 --> 01:22:40,210
af en periode.

1648
01:22:40,210 --> 01:22:45,060
Ved slutningen af ​​en sætning,
det sætter 80 bit, så

1649
01:22:45,060 --> 01:22:49,120
at huske, hvor
Zamyla begynder og slutter.

1650
01:22:49,120 --> 01:22:51,490
>> Så hvad er forbindelsen,
derefter, til dette program?

1651
01:22:51,490 --> 01:22:55,190
Dette program her, Stirling,
er simpelthen en mekanisme

1652
01:22:55,190 --> 01:22:57,970
for at få en streng
fra brugeren, linie 6.

1653
01:22:57,970 --> 01:23:01,160
Linje 7, erklærer jeg en variabel
kaldet n og sæt den lig med 0.

1654
01:23:01,160 --> 01:23:08,680
>> Og så i linje 8, simpelthen spurgte jeg
spørgsmål, mens det n'te karakter gør

1655
01:23:08,680 --> 01:23:12,120
ikke lig alle 0 bits--
med andre ord, ikke

1656
01:23:12,120 --> 01:23:14,500
lig denne særlige
karakter, omvendt skråstreg 0, som

1657
01:23:14,500 --> 01:23:18,470
var bare at særlige nul character--
gå videre og bare tilvækst n.

1658
01:23:18,470 --> 01:23:21,460
>> Og holde gør det, og holde
gør det, og holde gør det.

1659
01:23:21,460 --> 01:23:23,430
Og så selvom i
fortiden, vi har brugt i,

1660
01:23:23,430 --> 01:23:25,181
det er helt fint
semantisk at bruge n,

1661
01:23:25,181 --> 01:23:27,430
hvis du bare prøver at
tælle denne gang bevidst,

1662
01:23:27,430 --> 01:23:28,720
og bare ønsker at kalde det n.

1663
01:23:28,720 --> 01:23:34,720
Så dette blot holder stille spørgsmålet,
er den n'te karakter s alle 0'er?

1664
01:23:34,720 --> 01:23:38,470
Hvis ikke, se til næste look,
se på den næste, se på den næste,

1665
01:23:38,470 --> 01:23:39,460
se til den næste.

1666
01:23:39,460 --> 01:23:45,540
>> Men så snart du ser omvendt skråstreg 0,
denne loop-- linje 9 gennem 11-- stopper.

1667
01:23:45,540 --> 01:23:49,640
Du bryder ud af while-løkken,
forlader indersiden af ​​denne variabel n

1668
01:23:49,640 --> 01:23:54,530
en samlet optælling af alle de
tegn i strengen du så,

1669
01:23:54,530 --> 01:23:55,660
derved printe det ud.

1670
01:23:55,660 --> 01:23:56,760
Så lad os prøve dette.

1671
01:23:56,760 --> 01:23:59,500
>> Lad mig gå videre og uden
ved hjælp af stirling funktion,

1672
01:23:59,500 --> 01:24:04,240
men blot ved hjælp af min egen hjemmelavede udgave
her kaldet stirling, lad mig gå videre

1673
01:24:04,240 --> 01:24:07,700
og køre stirling, type i noget
ligesom Zamyla, som jeg på forhånd ved

1674
01:24:07,700 --> 01:24:08,670
er seks tegn.

1675
01:24:08,670 --> 01:24:10,080
Lad os se om det virker.

1676
01:24:10,080 --> 01:24:10,920
Faktisk er det seks.

1677
01:24:10,920 --> 01:24:15,257
Lad os prøve med Rob, tre tegn,
tre figurer samt, og så videre.

1678
01:24:15,257 --> 01:24:17,340
Så det er alt, der foregår
på under kølerhjelmen.

1679
01:24:17,340 --> 01:24:19,548
Og mærke tilslutningerne,
derefter, med den første uge

1680
01:24:19,548 --> 01:24:22,370
af klasse, hvor vi talte om
noget som abstraktion,

1681
01:24:22,370 --> 01:24:26,960
som er lige denne lagdeling af ideer, eller
kompleksitet, oven på grundlæggende principper.

1682
01:24:26,960 --> 01:24:30,710
Her er vi slags leder
under kølerhjelmen af ​​stirling,

1683
01:24:30,710 --> 01:24:33,510
så at sige, at finde ud af,
hvordan ville det blive gennemført?

1684
01:24:33,510 --> 01:24:35,232
>> Og vi kunne re-implementere det selv.

1685
01:24:35,232 --> 01:24:37,440
Men vi aldrig igen vil
at re-implementere stirling.

1686
01:24:37,440 --> 01:24:39,780
Vi er lige at gå til
bruge stirling for

1687
01:24:39,780 --> 01:24:42,100
til rent faktisk at få nogle strings længde.

1688
01:24:42,100 --> 01:24:44,200
>> Men der er ingen magi
under emhætten.

1689
01:24:44,200 --> 01:24:46,716
Hvis du ved, at under
hætten, en streng

1690
01:24:46,716 --> 01:24:48,090
er blot en sekvens af tegn.

1691
01:24:48,090 --> 01:24:51,090
Og at sekvens af tegn
alle kan numerisk rettet

1692
01:24:51,090 --> 01:24:53,330
med beslag 0, beslag
1, beslag 2, og du

1693
01:24:53,330 --> 01:24:57,420
ved, at ved afslutningen af ​​en streng er en
specialtegn, kan du regne ud

1694
01:24:57,420 --> 01:25:01,710
hvordan man gør de fleste noget i en
program, fordi alle det koges ned til

1695
01:25:01,710 --> 01:25:03,400
læser og skriver hukommelse.

1696
01:25:03,400 --> 01:25:06,130
Det vil sige, skiftende og leder
på hukommelsen, eller flytte ting

1697
01:25:06,130 --> 01:25:10,940
rundt i hukommelsen, trykning ting
på skærmen, og så videre.

1698
01:25:10,940 --> 01:25:14,800
>> Så lad os nu bruge denne nyfundne
forståelse af, hvad strings faktisk

1699
01:25:14,800 --> 01:25:17,910
er under kølerhjelmen, og
skrælle et andet lag

1700
01:25:17,910 --> 01:25:20,080
at indtil nu vi har
været ignorerer helt.

1701
01:25:20,080 --> 01:25:22,650
Navnlig helst
Vi har implementeret et program,

1702
01:25:22,650 --> 01:25:25,930
vi har haft denne linje kode
nær toppen erklære vigtigste.

1703
01:25:25,930 --> 01:25:27,810
Og vi har specificeret int main tomrum.

1704
01:25:27,810 --> 01:25:31,240
>> Og det tomrum i parentes
har sagt hele tiden, at main

1705
01:25:31,240 --> 01:25:33,440
selv tager ikke nogen argumenter.

1706
01:25:33,440 --> 01:25:36,210
Enhver input, vigtigste er
vil få fra brugeren

1707
01:25:36,210 --> 01:25:39,020
skal komme fra en anden
mekanisme, ligesom get int,

1708
01:25:39,020 --> 01:25:42,040
eller få float, eller få strengen,
eller en anden funktion.

1709
01:25:42,040 --> 01:25:44,710
Men det viser sig, at
når du skriver et program,

1710
01:25:44,710 --> 01:25:47,690
du rent faktisk kan angive
at dette program skal

1711
01:25:47,690 --> 01:25:51,730
tage input fra det menneskelige
på kommandolinjen selv.

1712
01:25:51,730 --> 01:25:56,310
>> Med andre ord, selvom vi hidtil
har kørt lige ./hello hej

1713
01:25:56,310 --> 01:26:00,312
eller lignende programmer, alle af
andre programmer, som vi har brugt,

1714
01:26:00,312 --> 01:26:02,770
at vi selv ikke skrive,
har taget, synes det,

1715
01:26:02,770 --> 01:26:05,210
kommandolinje arguments--
ting som make.

1716
01:26:05,210 --> 01:26:07,450
Du siger noget i retning af fabrikat,
og derefter en anden ord.

1717
01:26:07,450 --> 01:26:10,950
Eller klang, siger du clang, og derefter
et andet ord, navnet på en fil.

1718
01:26:10,950 --> 01:26:14,410
>> Eller endda RM eller CP, som du måske
har set eller brugt allerede

1719
01:26:14,410 --> 01:26:15,880
at fjerne eller kopiere filer.

1720
01:26:15,880 --> 01:26:18,920
Alle de tager såkaldte
kommandolinje arguments--

1721
01:26:18,920 --> 01:26:21,130
yderligere ord i terminalen prompt.

1722
01:26:21,130 --> 01:26:23,260
Men indtil nu, vi
selv har ikke haft

1723
01:26:23,260 --> 01:26:27,080
denne luksus at tage input fra
brugeren, når han eller hun faktisk løber

1724
01:26:27,080 --> 01:26:29,120
selve programmet på kommandolinjen.

1725
01:26:29,120 --> 01:26:33,710
>> Men vi kan gøre det ved at re-erklære
vigtigste bevæger sig fremad, ikke at have

1726
01:26:33,710 --> 01:26:36,750
ugyldig i parentes,
men disse to argumenter

1727
01:26:36,750 --> 01:26:40,600
instead-- den første et heltal,
og den anden noget

1728
01:26:40,600 --> 01:26:44,170
nyt, noget, som vi kommer til at kalde
et array, noget lignende i ånden

1729
01:26:44,170 --> 01:26:49,220
til hvad vi så i Scratch som en liste, men
en vifte af strenge, som vi vil snart se.

1730
01:26:49,220 --> 01:26:51,790
Men lad os se dette ved
Eksempelvis inden vi

1731
01:26:51,790 --> 01:26:53,690
skelne præcist, hvad det betyder.

1732
01:26:53,690 --> 01:26:56,520
>> Så hvis jeg går ind i CS50 IDE
her, jeg har gået fremad

1733
01:26:56,520 --> 01:27:01,840
og erklærede i en fil kaldet
argv0.c følgende skabelon.

1734
01:27:01,840 --> 01:27:04,120
Og bemærke den eneste
der er anderledes hidtil

1735
01:27:04,120 --> 01:27:08,570
er, at jeg har ændret ugyldig til int
argc snor argv åben konsol, tæt

1736
01:27:08,570 --> 01:27:09,070
beslag.

1737
01:27:09,070 --> 01:27:11,730
Og mærke til nu, er der
intet inde af disse konsoller.

1738
01:27:11,730 --> 01:27:12,620
>> Der er ingen tal.

1739
01:27:12,620 --> 01:27:15,070
Og der er ingen i, eller
n, eller enhver anden brev.

1740
01:27:15,070 --> 01:27:17,010
Jeg er bare ved hjælp af
firkantede parenteser til nu,

1741
01:27:17,010 --> 01:27:19,510
af årsager, vi vil komme
tilbage til om et øjeblik.

1742
01:27:19,510 --> 01:27:21,330
>> Og nu, hvad jeg har tænkt mig at gøre, er dette.

1743
01:27:21,330 --> 01:27:26,680
Hvis argc lig lig 2--
og minde om, at lig ligemænd

1744
01:27:26,680 --> 01:27:30,040
er operatør lighed sammenligne
venstre og højre for ligestilling.

1745
01:27:30,040 --> 01:27:31,790
Det er ikke opgaven
operatør, som er

1746
01:27:31,790 --> 01:27:36,510
enkelt lighedstegn, hvilket betyder kopi
fra højre til venstre en vis værdi.

1747
01:27:36,510 --> 01:27:42,840
>> Hvis argc lig lig med 2, vil jeg
siger, printf, hallo, procenter, ny linje,

1748
01:27:42,840 --> 01:27:47,340
og sæt in-- og her er den nye
trick-- argv beslag 1, af grunde

1749
01:27:47,340 --> 01:27:48,840
at vi vil vende tilbage til om et øjeblik.

1750
01:27:48,840 --> 01:27:52,110
Else hvis argc ikke gør
lige 2, ved du hvad?

1751
01:27:52,110 --> 01:27:57,400
Lad os bare gå videre og, som sædvanlig, print
ud hello world uden substitution.

1752
01:27:57,400 --> 01:28:02,710
>> Så det ser ud til, at hvis argc, som
står for argument tæller, er lig med 2,

1753
01:28:02,710 --> 01:28:04,740
Jeg har tænkt mig at udskrive
hej et eller andet.

1754
01:28:04,740 --> 01:28:07,560
Ellers som standard, jeg er
kommer til at udskrive hej verden.

1755
01:28:07,560 --> 01:28:08,770
Så hvad betyder det?

1756
01:28:08,770 --> 01:28:15,550
>> Nå, lad mig gå videre og spare
denne fil, og derefter gør argv0,

1757
01:28:15,550 --> 01:28:18,940
og derefter ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Og det siger hej verden.

1759
01:28:20,300 --> 01:28:21,260
Nu, hvorfor er det?

1760
01:28:21,260 --> 01:28:24,730
>> Tja, det viser sig når som helst du
køre et program på kommandolinjen,

1761
01:28:24,730 --> 01:28:29,570
du udfylde hvad vi får
generelt kalder et argument vektor.

1762
01:28:29,570 --> 01:28:33,100
Med andre ord, automatisk
computer, operativsystemet,

1763
01:28:33,100 --> 01:28:38,340
kommer til at aflevere til dit program
selv en liste over alle ordene

1764
01:28:38,340 --> 01:28:40,850
at det menneskelige indtastet på
prompt, hvis du

1765
01:28:40,850 --> 01:28:43,790
programmøren ønsker at gøre
noget med disse oplysninger.

1766
01:28:43,790 --> 01:28:48,540
Og i dette tilfælde, det eneste ord
Jeg har indtastet ved prompten er ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Og så antallet af argumenter, der er
gives videre til mit program er blot én.

1768
01:28:55,420 --> 01:28:58,880
Med andre ord, det argument
noget ud, også kendt som argc

1769
01:28:58,880 --> 01:29:00,970
her som et helt tal, er blot én.

1770
01:29:00,970 --> 01:29:03,000
Et naturligvis ikke lig to.

1771
01:29:03,000 --> 01:29:05,980
Og så dette er hvad udskriver, hej verden.

1772
01:29:05,980 --> 01:29:08,170
>> Men lad mig tage dette sted.

1773
01:29:08,170 --> 01:29:09,930
Lad mig sige, argv0.

1774
01:29:09,930 --> 01:29:12,740
Og så hvad med Maria?

1775
01:29:12,740 --> 01:29:14,990
Og så tryk Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Og mærke til, hvad magisk sker her.

1777
01:29:18,020 --> 01:29:22,640
Nu, i stedet for hej verden, jeg har
ændret adfærd af dette program

1778
01:29:22,640 --> 01:29:26,310
ved at tage inputtet ikke fra get
snor eller en anden funktion,

1779
01:29:26,310 --> 01:29:30,570
men fra tilsyneladende min kommando
selv, hvad jeg oprindeligt skrevet i.

1780
01:29:30,570 --> 01:29:35,720
Og jeg kan spille dette spil igen ved
ændre det til Stelios, f.eks.

1781
01:29:35,720 --> 01:29:38,400
>> Og nu ser jeg et andet navn stadig.

1782
01:29:38,400 --> 01:29:40,540
Og her, kan jeg sige Andi.

1783
01:29:40,540 --> 01:29:42,137
Og jeg kan sige Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Og vi kan spille dette spil hele dagen lang,
bare tilslutte forskellige værdier,

1785
01:29:45,220 --> 01:29:49,550
så længe jeg levere præcis
to ord på prompt,

1786
01:29:49,550 --> 01:29:52,260
sådan at argc, mit argument tæller, er to.

1787
01:29:52,260 --> 01:29:57,240
>> Skal jeg se, at navnet tilsluttet
printf, pr denne betingelse her?

1788
01:29:57,240 --> 01:30:00,550
Så vi synes at have nu
den ekspressive kapacitet

1789
01:30:00,550 --> 01:30:04,410
tage input fra en anden mekanisme,
fra den såkaldte kommandolinjen,

1790
01:30:04,410 --> 01:30:07,000
snarere end at skulle vente
indtil brugeren kører programmet,

1791
01:30:07,000 --> 01:30:10,220
og derefter bede ham eller hende
bruge noget lignende get streng.

1792
01:30:10,220 --> 01:30:11,230
>> Så hvad er det?

1793
01:30:11,230 --> 01:30:15,010
Argc, igen, er bare et heltal,
antallet af words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
at brugeren tilvejebragt ved
prompt på terminalvinduet,

1795
01:30:18,540 --> 01:30:20,110
herunder programmets navn.

1796
01:30:20,110 --> 01:30:23,340
Så vores ./argv0 er effektivt,
programmets navn,

1797
01:30:23,340 --> 01:30:24,520
eller hvordan jeg køre programmet.

1798
01:30:24,520 --> 01:30:25,810
>> Det tæller som et ord.

1799
01:30:25,810 --> 01:30:27,080
Så argc ville være en.

1800
01:30:27,080 --> 01:30:29,750
Men når jeg skriver Stelios, eller
Andi, eller Zamyla, eller Maria,

1801
01:30:29,750 --> 01:30:31,660
det betyder, at argumentet tæller er to.

1802
01:30:31,660 --> 01:30:33,910
Og så nu er der to ord bestået i.

1803
01:30:33,910 --> 01:30:36,070
>> Og varsel, kan vi fortsætte med denne logik.

1804
01:30:36,070 --> 01:30:39,050
Hvis jeg faktisk sige
noget som Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
et fuldt navn, og dermed passerer
tre argumenter i alt,

1806
01:30:42,200 --> 01:30:47,410
nu står standard igen,
fordi, selvfølgelig, 3 ikke er lig 2.

1807
01:30:47,410 --> 01:30:54,080
>> Og så på den måde, har jeg
adgang via argv dette nye argument

1808
01:30:54,080 --> 01:30:56,080
at vi kunne teknisk
kalde noget, vi ønsker.

1809
01:30:56,080 --> 01:30:58,940
Men ved konvention, det er
argv og argc hhv.

1810
01:30:58,940 --> 01:31:04,470
Argv, argument vektor, er en slags
af et synonym for en programmering

1811
01:31:04,470 --> 01:31:07,140
funktion i C kaldes et array.

1812
01:31:07,140 --> 01:31:14,410
>> Et array er en liste over lignende værdier
tilbage, til tilbage, til tilbage, mod ryg.

1813
01:31:14,410 --> 01:31:17,810
Med andre ord, hvis man er lige her i
RAM, den næste er lige ved siden af ​​det,

1814
01:31:17,810 --> 01:31:18,800
og lige ved siden af ​​den.

1815
01:31:18,800 --> 01:31:20,101
De er ikke over det hele.

1816
01:31:20,101 --> 01:31:23,100
Og sidstnævnte scenarie, hvor tingene
er over det hele i hukommelsen,

1817
01:31:23,100 --> 01:31:25,082
kan faktisk være en effektiv funktion.

1818
01:31:25,082 --> 01:31:28,040
Men vi vil vende tilbage til, at når vi
tale om amatør datastrukturer.

1819
01:31:28,040 --> 01:31:32,260
For nu, et array er blot en
luns af sammenhængende hukommelse,

1820
01:31:32,260 --> 01:31:36,520
hver af hvis elementer
tilbage, til tilbage, til tilbage, til at bakke,

1821
01:31:36,520 --> 01:31:38,050
og generelt den samme type.

1822
01:31:38,050 --> 01:31:42,630
>> Så hvis du tænker over, fra en
øjeblik siden, hvad er en streng?

1823
01:31:42,630 --> 01:31:50,460
Tja, en streng, ligesom Zamyla,
Z-A-M-Y-L-A, er teknisk set

1824
01:31:50,460 --> 01:31:51,400
blot et array.

1825
01:31:51,400 --> 01:31:53,700
Det er et array af tegn.

1826
01:31:53,700 --> 01:31:59,250
>> Og så hvis vi virkelig trække dette, da jeg
gjorde tidligere, da en luns af hukommelse,

1827
01:31:59,250 --> 01:32:04,510
viser det sig, at hver af disse
tegn fylder en byte.

1828
01:32:04,510 --> 01:32:07,630
Og så er der det særlige
sentinel karakter, omvendt skråstreg 0,

1829
01:32:07,630 --> 01:32:12,360
eller alle otte 0 bits, at
afgrænser udgangen af ​​denne streng.

1830
01:32:12,360 --> 01:32:15,090
Så en streng, viser det sig
ud, citerer citat slut streng,

1831
01:32:15,090 --> 01:32:20,580
er bare en vifte af chara--
char at være en egentlige datatype.

1832
01:32:20,580 --> 01:32:24,560
>> Og nu argv, meanwhile--
lad os gå tilbage til programmet.

1833
01:32:24,560 --> 01:32:29,582
Argv, selv om vi ser ordet
snor her, er ikke en streng selv.

1834
01:32:29,582 --> 01:32:33,640
Argv, argument vektor,
er et array af strenge.

1835
01:32:33,640 --> 01:32:37,620
>> Så ligesom du kan have en bred vifte af
tegn, kan du få højere niveau,

1836
01:32:37,620 --> 01:32:46,279
en matrix af strings-- så, for eksempel,
når jeg har skrevet et øjeblik siden ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, space Z-A-M-Y-L-A, I hævdede, at
argv havde to strenge i it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
og Z-A-M-Y-L-A. I
andre ord argc var 2.

1839
01:33:03,185 --> 01:33:03,980
Hvorfor det?

1840
01:33:03,980 --> 01:33:08,370
>> Nå, effektivt, hvad der foregår
på er, at hver af disse strenge

1841
01:33:08,370 --> 01:33:13,990
er naturligvis et array af tegn
som før, hver af hvis tegn

1842
01:33:13,990 --> 01:33:15,670
fylder en byte.

1843
01:33:15,670 --> 01:33:19,720
Og ikke forveksle den faktiske 0
i programmets navn med 0,

1844
01:33:19,720 --> 01:33:22,040
hvilket betyder alle 80 bit.

1845
01:33:22,040 --> 01:33:27,140
Og Zamyla, i mellemtiden, er stadig
også et array af tegn.

1846
01:33:27,140 --> 01:33:31,450
>> Så ved slutningen af ​​dagen, er det virkelig
ser sådan ud under motorhjelmen.

1847
01:33:31,450 --> 01:33:38,800
Men argv, i kraft af hvordan vigtigste
værker, tillader mig at ombryde alt dette

1848
01:33:38,800 --> 01:33:44,810
op i, hvis du vil, en større vifte
at hvis vi lidt over forenkle

1849
01:33:44,810 --> 01:33:48,180
hvad billedet ser ud, og ikke
helt trække det til at skalere op der,

1850
01:33:48,180 --> 01:33:56,720
dette array er kun af størrelse 2, den første
element, som indeholder en streng,

1851
01:33:56,720 --> 01:33:59,230
det andet element af
som indeholder en streng.

1852
01:33:59,230 --> 01:34:01,687
Og til gengæld, hvis du
slags zoome ind på hver

1853
01:34:01,687 --> 01:34:03,770
af disse strenge, hvad du
se under kølerhjelmen

1854
01:34:03,770 --> 01:34:07,190
er, at hver streng er lige
et array af tegn.

1855
01:34:07,190 --> 01:34:11,680
>> Nu, ligesom med strygere,
vi var i stand til at få adgang

1856
01:34:11,680 --> 01:34:15,260
til det i'te karakter i en streng
ved hjælp af denne firkantede beslag notation.

1857
01:34:15,260 --> 01:34:17,320
Ligeledes med arrays
Generelt kan vi

1858
01:34:17,320 --> 01:34:22,700
bruge firkantede beslag notation for at få
på et vilkårligt antal strenge i et array?

1859
01:34:22,700 --> 01:34:25,100
For eksempel, lad mig
gå videre og gøre dette.

1860
01:34:25,100 --> 01:34:32,420
>> Lad mig gå videre og skabe argv1.c,
som er lidt anderledes denne gang.

1861
01:34:32,420 --> 01:34:35,635
I stedet for at kontrollere for argc2,
Jeg har tænkt mig at i stedet gøre det.

1862
01:34:35,635 --> 01:34:41,270
For int jeg får 0, jeg er mindre
end argc, jeg plus plus,

1863
01:34:41,270 --> 01:34:47,920
og derefter printe ud inde i dette,
procent s, ny linje, og derefter

1864
01:34:47,920 --> 01:34:50,740
argv beslag i.

1865
01:34:50,740 --> 01:34:55,220
>> Så med andre ord, jeg ikke beskæftiger sig med
enkelte tegn i øjeblikket.

1866
01:34:55,220 --> 01:35:00,190
Argv, som det fremgår af disse tomme firkant
seler til højre for navnet argv,

1867
01:35:00,190 --> 01:35:03,320
betyder argv er et array af strenge.

1868
01:35:03,320 --> 01:35:04,870
Og argc er bare en int.

1869
01:35:04,870 --> 01:35:08,800
>> Denne linje her, 6, er
siger sæt jeg lig med 0.

1870
01:35:08,800 --> 01:35:11,980
Tæl hele vejen op til,
men ikke inklusive, argc.

1871
01:35:11,980 --> 01:35:14,010
Og så på hver iteration,
udskrive en streng.

1872
01:35:14,010 --> 01:35:14,800
Hvad snor?

1873
01:35:14,800 --> 01:35:17,270
>> Den i'te streng i argv.

1874
01:35:17,270 --> 01:35:19,530
Så mens før jeg var
ved hjælp af den firkantede beslag

1875
01:35:19,530 --> 01:35:22,180
notation at få ram på den i'te
karakter i en streng, nu

1876
01:35:22,180 --> 01:35:27,240
Jeg bruger den firkantede beslag notation
at få på den i'te streng i et array.

1877
01:35:27,240 --> 01:35:30,310
Så det er lidt et lag
ovenfor, konceptuelt.

1878
01:35:30,310 --> 01:35:35,390
>> Og så hvad er pæn om dette
program nu, hvis jeg kompilere argv1,

1879
01:35:35,390 --> 01:35:42,067
og derefter gøre ./argv1, og derefter skrive
i noget lignende foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
som er de tre standard ord, en
datalog rækker ud efter noget tidspunkt

1881
01:35:45,400 --> 01:35:51,010
han eller hun har brug for nogle pladsholder ord,
og tryk på Enter, hvert af disse ord,

1882
01:35:51,010 --> 01:35:54,980
herunder programmets navn, som
er i argv ved den første placering,

1883
01:35:54,980 --> 01:35:58,320
ender med at blive udskrevet en ad gangen.

1884
01:35:58,320 --> 01:36:05,290
Og hvis jeg ændre dette, og jeg siger
noget som argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
vi får alle tre af disse
ord, hvilket er argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, fordi der i dette
tilfælde argc, optællingen, er tre.

1887
01:36:14,400 --> 01:36:20,020
>> Men hvad er pæn er, hvis du forstår
at argv er bare en vifte af strenge,

1888
01:36:20,020 --> 01:36:24,910
og du forstår, at en streng
er en vifte af tegn,

1889
01:36:24,910 --> 01:36:29,470
Vi kan faktisk slags bruge denne
firkantet beslag notation flere gange

1890
01:36:29,470 --> 01:36:33,320
at vælge en streng, og vælg derefter
en karakter inden for streng,

1891
01:36:33,320 --> 01:36:35,730
dykning i dybere som følger.

1892
01:36:35,730 --> 01:36:40,100
I dette eksempel, lad mig gå
videre og kalder det argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Og i dette eksempel, lad mig gå videre
og gøre det following-- for int jeg får 0,

1895
01:36:50,180 --> 01:36:53,286
Jeg er mindre end argc, jeg plus
plus, ligesom før.

1896
01:36:53,286 --> 01:36:55,910
Så i anden words-- og nu denne
bliver kompliceret nok.

1897
01:36:55,910 --> 01:36:59,940
Så jeg har tænkt mig at sige
gentage over strenge i argv,

1898
01:36:59,940 --> 01:37:01,294
som en kommentar til mig selv.

1899
01:37:01,294 --> 01:37:03,960
Og så jeg har tænkt mig at have en
indlejret for løkke, som du sikkert

1900
01:37:03,960 --> 01:37:06,290
har gjort, eller anses
gør, i Scratch, hvor

1901
01:37:06,290 --> 01:37:08,600
Jeg har tænkt mig at sige int-- jeg er
ikke kommer til at bruge i igen,

1902
01:37:08,600 --> 01:37:12,590
fordi jeg ikke ønsker at skygge, eller
slags overskrive den eksisterende i.

1903
01:37:12,590 --> 01:37:15,780
>> Jeg har tænkt mig at i stedet, siger j, fordi
det er min gå til variabel efter jeg,

1904
01:37:15,780 --> 01:37:18,590
når jeg prøver bare at
tælle simple numre.

1905
01:37:18,590 --> 01:37:28,850
For j får 0-- og også, n, vil
få agterstavnen længde argv beslag I,

1906
01:37:28,850 --> 01:37:36,030
så længe j er mindre end m,
j plus plus, skal du gøre følgende.

1907
01:37:36,030 --> 01:37:37,500
Og her er den interessante del.

1908
01:37:37,500 --> 01:37:46,330
>> Udskriv en karakter og en ny linje,
tilslutte argv beslag i, beslag j.

1909
01:37:46,330 --> 01:37:47,940
OK, så lad mig tilføje nogle kommentarer her.

1910
01:37:47,940 --> 01:37:54,820
Gentage over tegn
i aktuelle streng,

1911
01:37:54,820 --> 01:38:02,290
print j-th tegn i i'te streng.

1912
01:38:02,290 --> 01:38:04,630
Så nu, lad os overveje
hvad disse bemærkninger betyder.

1913
01:38:04,630 --> 01:38:06,750
>> Gentage over strengene
i argv-- hvor mange

1914
01:38:06,750 --> 01:38:09,300
strenge er i argv, hvilket er et array?

1915
01:38:09,300 --> 01:38:13,420
Argc mange, så jeg iteration
fra i lig 0 op til argc.

1916
01:38:13,420 --> 01:38:20,020
I mellemtiden, hvor mange tegn
er i den i'te streng i argv?

1917
01:38:20,020 --> 01:38:22,880
>> Nå, for at få det svar,
Jeg bare kalde snor længde

1918
01:38:22,880 --> 01:38:26,810
på den aktuelle snor I pleje
om, hvilket er argv beslag i.

1919
01:38:26,810 --> 01:38:30,090
Og jeg har tænkt mig at midlertidigt at gemme, at
værdi i n, bare for caching formål,

1920
01:38:30,090 --> 01:38:31,590
at huske det for effektivitet.

1921
01:38:31,590 --> 01:38:36,330
Og så jeg har tænkt mig initialisere j til 0,
holde ud, så længe j er mindre end n,

1922
01:38:36,330 --> 01:38:38,430
og på hver iteration tilvækst j.

1923
01:38:38,430 --> 01:38:41,030
>> Og så i her, per
min kommentar på linje 12,

1924
01:38:41,030 --> 01:38:43,390
udskrive en karakter,
efterfulgt af en ny linje,

1925
01:38:43,390 --> 01:38:48,140
specifikt argv beslag
Jeg giver mig den i'te snor

1926
01:38:48,140 --> 01:38:51,690
i argv-- så det første ord, den
andet ord, den tredje ord, uanset hvad.

1927
01:38:51,690 --> 01:38:57,370
Og så j dyk i dybere og får
mig j-th karakter af dette ord.

1928
01:38:57,370 --> 01:39:02,200
Og så i realiteten kan du behandle
argv som en multi-dimensional,

1929
01:39:02,200 --> 01:39:06,050
som et todimensionalt, array,
hvorved hvert ord slags udseende

1930
01:39:06,050 --> 01:39:08,580
som denne i dit sind s
øje, og hvert tegn

1931
01:39:08,580 --> 01:39:10,930
er slags sammensat i
en søjle, hvis det hjælper.

1932
01:39:10,930 --> 01:39:13,260
>> I virkeligheden, når vi drille
denne afstand i fremtidige uger,

1933
01:39:13,260 --> 01:39:15,580
det kommer til at være lidt
mere sofistikeret end det.

1934
01:39:15,580 --> 01:39:17,800
Men du kan virkelig
tænke på, at for nu,

1935
01:39:17,800 --> 01:39:22,110
som netop dette todimensionale
matrix, hvorved et niveau af det

1936
01:39:22,110 --> 01:39:23,260
er alle strengene.

1937
01:39:23,260 --> 01:39:26,760
Og så hvis du dykke i dybere, du
kan få på de enkelte tegn

1938
01:39:26,760 --> 01:39:29,600
deri ved hjælp af denne notation her.

1939
01:39:29,600 --> 01:39:31,620
>> Så hvad er nettoeffekten?

1940
01:39:31,620 --> 01:39:34,970
Lad mig gå videre og
gøre argv2-- darn det.

1941
01:39:34,970 --> 01:39:36,210
Jeg lavet en fejl her.

1942
01:39:36,210 --> 01:39:40,160
Implicit erklære
biblioteksfunktionen stirling.

1943
01:39:40,160 --> 01:39:42,190
Så alt denne gang, er det
måske passende

1944
01:39:42,190 --> 01:39:45,130
at vi slags efterbehandling
præcis hvor vi startede.

1945
01:39:45,130 --> 01:39:48,160
>> Jeg skruet op, implicit erklære
biblioteksfunktionen stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, vent et øjeblik.

1947
01:39:48,987 --> 01:39:51,070
Jeg husker, at især
da det er lige her.

1948
01:39:51,070 --> 01:39:54,490
Jeg har brug for at inkludere string.h i
denne version af programmet.

1949
01:39:54,490 --> 01:40:00,050
>> Lad mig gå videre og inkludere
string.h, bortset fra at gå videre

1950
01:40:00,050 --> 01:40:04,460
og kompilere argv2.

1951
01:40:04,460 --> 01:40:08,390
Og nu, her går vi, gør argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Og selvom det er lidt
kryptiske ved første øjekast,

1953
01:40:10,590 --> 01:40:15,690
Bemærk at, ja, hvad
udskrives er dot argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Men hvis jeg skriver nogle ord efter
prompt, ligesom argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Indtast, også lidt
kryptiske ved første øjekast.

1956
01:40:22,560 --> 01:40:30,540
Men hvis vi rulle tilbage op,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Så vi har gentaget i løbet af hvert ord.

1958
01:40:32,190 --> 01:40:37,770
Og til gengæld har vi gentog løbet
hver karakter inden et ord.

1959
01:40:37,770 --> 01:40:40,040
>> Nu, efter alt dette,
indse, at der er

1960
01:40:40,040 --> 01:40:43,120
en anden detalje, vi har været så venlige
for at ignorere denne hele tiden.

1961
01:40:43,120 --> 01:40:46,180
Vi har lige drilles hinanden hvad
vigtigste input kan være?

1962
01:40:46,180 --> 01:40:47,780
Hvad vigtigste produktion?

1963
01:40:47,780 --> 01:40:50,540
>> Alt dette tidspunkt, har vi været
bare kopiere og indsætte

1964
01:40:50,540 --> 01:40:53,870
Ordet int foran vigtigste,
selvom du måske se online,

1965
01:40:53,870 --> 01:40:58,340
undertiden forkert i ældre versioner
af C og compilere, at de siger ugyldig

1966
01:40:58,340 --> 01:40:59,410
eller slet ingenting.

1967
01:40:59,410 --> 01:41:01,580
Men, ja, for den version
C, som vi bruger,

1968
01:41:01,580 --> 01:41:06,180
C 11, eller 2011, indser
at det skal være int.

1969
01:41:06,180 --> 01:41:09,300
Og det bør enten være
ugyldig eller argc og argv her.

1970
01:41:09,300 --> 01:41:10,790
>> Men hvorfor int main?

1971
01:41:10,790 --> 01:41:12,480
Hvad er det egentlig tilbage?

1972
01:41:12,480 --> 01:41:16,280
Tja, det viser sig al den tid,
helst du har skrevet et program main

1973
01:41:16,280 --> 01:41:18,440
altid returnere noget.

1974
01:41:18,440 --> 01:41:19,960
Men det har været at gøre det hemmeligt.

1975
01:41:19,960 --> 01:41:23,350
>> At noget er en
int, som linje 5 antyder.

1976
01:41:23,350 --> 01:41:24,225
Men hvad int?

1977
01:41:24,225 --> 01:41:26,100
Tja, der er det
konvention i programmering,

1978
01:41:26,100 --> 01:41:29,790
hvorved hvis intet har
gået galt og alt er godt,

1979
01:41:29,790 --> 01:41:34,250
programmer og funktioner generelt
return-- noget counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 generelt betyder alt er godt.

1982
01:41:38,070 --> 01:41:40,610
Så selv om du tænker på
det som falsk i mange sammenhænge,

1983
01:41:40,610 --> 01:41:42,930
det faktisk betyder generelt en god ting

1984
01:41:42,930 --> 01:41:49,560
>> I mellemtiden, hvis et program returnerer 1,
eller negativ 1 eller 5, eller negativ 42,

1985
01:41:49,560 --> 01:41:52,941
eller enhver ikke-0 værdi,
der generelt betegner

1986
01:41:52,941 --> 01:41:54,190
at noget er gået galt.

1987
01:41:54,190 --> 01:41:56,700
Faktisk på din egen Mac eller pc,
du måske har faktisk set

1988
01:41:56,700 --> 01:42:01,050
en fejlmeddelelse, hvorved den
siger et eller andet, fejl

1989
01:42:01,050 --> 01:42:04,940
kode negativ 42, eller fejlkode
23, eller noget lignende.

1990
01:42:04,940 --> 01:42:08,980
Dette antal er generelt bare en antydning
til programmøren, eller virksomheden

1991
01:42:08,980 --> 01:42:11,174
der gjorde softwaren,
hvad der gik galt og hvorfor,

1992
01:42:11,174 --> 01:42:13,590
så de kan se gennem
deres dokumentation eller kode,

1993
01:42:13,590 --> 01:42:15,465
og regne ud, hvad den
fejl betyder faktisk.

1994
01:42:15,465 --> 01:42:18,400
Det er generelt ikke
nyttig for os slutbrugere.

1995
01:42:18,400 --> 01:42:20,550
>> Men når vigtigste afkast 0, alt er godt.

1996
01:42:20,550 --> 01:42:23,770
Og hvis du ikke angiver
hvad vigtigste skal returnere,

1997
01:42:23,770 --> 01:42:26,950
det vil bare automatisk
returnere 0 for dig.

1998
01:42:26,950 --> 01:42:30,870
Men returnere noget
ellers er faktisk nyttigt.

1999
01:42:30,870 --> 01:42:34,660
>> I denne sidste program, lad mig
gå videre og kalde dette exit.c,

2000
01:42:34,660 --> 01:42:38,630
og introducere den sidste af dagens
emner, der er kendt som en fejlkode.

2001
01:42:38,630 --> 01:42:42,930
Lad mig gå videre og inkludere vores
velkendte filer op top, gør int main.

2002
01:42:42,930 --> 01:42:49,500
Og denne gang, lad os gøre int argc,
string argv, og med mine konsoller

2003
01:42:49,500 --> 01:42:50,836
at antyde, at det er i array.

2004
01:42:50,836 --> 01:42:52,460
Og så lad mig bare gøre et sanity check.

2005
01:42:52,460 --> 01:42:56,640
Denne gang, hvis argc ikke gør
lige to, så ved du hvad?

2006
01:42:56,640 --> 01:42:57,520
Glem det.

2007
01:42:57,520 --> 01:43:03,170
Jeg vil sige, at, hey, bruger,
du mangler kommandolinje argument

2008
01:43:03,170 --> 01:43:04,210
backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> Og så er det.

2010
01:43:05,230 --> 01:43:06,130
Jeg ønsker at afslutte.

2011
01:43:06,130 --> 01:43:11,030
Jeg vil forebyggende,
og tidligt virkelig, afkast

2012
01:43:11,030 --> 01:43:12,810
noget andet end nummer 1.

2013
01:43:12,810 --> 01:43:15,360
Gå til værdi for den første
fejl, der kan ske, er en.

2014
01:43:15,360 --> 01:43:17,860
Hvis du har nogle andre fejlagtige
situation, der kan forekomme,

2015
01:43:17,860 --> 01:43:21,390
du kan sige afkast 2 eller returnere 3, eller
måske endda negativ 1 eller negativ 2.

2016
01:43:21,390 --> 01:43:23,750
>> Disse er blot afslutningskoder
der er generelt

2017
01:43:23,750 --> 01:43:27,770
kun nyttig for programmøren, eller
selskab, der er forsendelse af softwaren.

2018
01:43:27,770 --> 01:43:30,500
Men det faktum, at det er
ikke 0 er hvad der er vigtigt.

2019
01:43:30,500 --> 01:43:34,310
Så hvis i dette program, vil jeg
garantere, at dette program kun

2020
01:43:34,310 --> 01:43:38,190
virker, hvis brugeren giver mig
med et argument optælling af to,

2021
01:43:38,190 --> 01:43:42,880
navnet på det program, og nogle andre
ord, kan jeg håndhæve så meget som følger,

2022
01:43:42,880 --> 01:43:46,110
yell på brugeren med printf ordsprog,
mangler kommandolinje argument,

2023
01:43:46,110 --> 01:43:46,970
returnere en.

2024
01:43:46,970 --> 01:43:49,940
Det vil bare straks
afslutte programmet.

2025
01:43:49,940 --> 01:43:55,840
>> Kun hvis argc lig 2 vil vi komme ned
her, på hvilket tidspunkt jeg har tænkt mig at sige,

2026
01:43:55,840 --> 01:44:00,410
hej procent s, omvendt skråstreg n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Med andre ord, er jeg
ikke går efter argv 0,

2028
01:44:03,827 --> 01:44:05,410
som er lige navnet på programmet.

2029
01:44:05,410 --> 01:44:09,450
Jeg ønsker at udskrive hej, komma,
det andet ord, at den menneskelige indtastet.

2030
01:44:09,450 --> 01:44:12,580
Og i dette tilfælde på
linje 13, alt er godt.

2031
01:44:12,580 --> 01:44:15,920
>> Jeg ved, at argc er 2
logisk fra dette program.

2032
01:44:15,920 --> 01:44:17,770
Jeg har tænkt mig at gå videre og returnere 0.

2033
01:44:17,770 --> 01:44:21,230
Som en sidebemærkning, huske på, at
dette er sandt i Scratch så godt.

2034
01:44:21,230 --> 01:44:24,760
>> Logisk, jeg kunne gøre dette
og indkapsle disse linjer

2035
01:44:24,760 --> 01:44:27,020
af koden i denne ellers klausul her.

2036
01:44:27,020 --> 01:44:29,420
Men det er slags
unødigt indrykning min kode.

2037
01:44:29,420 --> 01:44:31,800
Og jeg vil gerne gøre super
klart, at uanset hvad,

2038
01:44:31,800 --> 01:44:34,670
som standard, hej
noget vil blive udskrevet,

2039
01:44:34,670 --> 01:44:36,050
så længe brugeren samarbejder.

2040
01:44:36,050 --> 01:44:39,360
>> Så det er meget almindeligt at bruge
en tilstand, blot en if,

2041
01:44:39,360 --> 01:44:41,870
at fange nogle fejlagtige
situationen, og derefter afslutte.

2042
01:44:41,870 --> 01:44:45,690
Og så, så længe alt er
godt, ikke have en anden,

2043
01:44:45,690 --> 01:44:48,060
men bare har koden
uden at såfremt, for det er

2044
01:44:48,060 --> 01:44:51,060
ækvivalente i denne
særlige tilfælde, logisk.

2045
01:44:51,060 --> 01:44:54,480
Så jeg vender tilbage 0, bare for at
udtrykkeligt tilkendegiver alt er godt.

2046
01:44:54,480 --> 01:44:58,480
>> Hvis jeg udeladt tilbagevenden 0, ville det
automatisk antages for mig.

2047
01:44:58,480 --> 01:45:00,890
Men nu, at jeg vender tilbage
en i det mindste dette tilfælde

2048
01:45:00,890 --> 01:45:04,940
Jeg har tænkt mig at, for god foranstaltning og
klarhed, returnere 0 i dette tilfælde.

2049
01:45:04,940 --> 01:45:09,690
Så lad mig gå videre og gøre exit,
som er en perfekt Overgang til bare forlade.

2050
01:45:09,690 --> 01:45:14,401
>> Men gør exit, og lade mig gå
videre og gøre ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Og programmet råbte på mig,
mangler kommandolinje argument.

2052
01:45:16,900 --> 01:45:18,120
OK, lad mig samarbejder.

2053
01:45:18,120 --> 01:45:23,810
>> Lad mig i stedet gøre ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Og nu siger goddag David.

2055
01:45:25,190 --> 01:45:27,300
Og du normalt ikke ville se dette.

2056
01:45:27,300 --> 01:45:30,650
>> Men det viser sig, at der er en
særlig måde i Linux faktisk se

2057
01:45:30,650 --> 01:45:34,470
med, hvad exit kode et program forlades.

2058
01:45:34,470 --> 01:45:37,184
Nogle gange i en grafisk
verden som Mac OS eller Windows,

2059
01:45:37,184 --> 01:45:40,100
du kun se disse tal, når en
fejlmeddelelse popper op på skærmen

2060
01:45:40,100 --> 01:45:41,940
og programmøren
viser dig dette nummer.

2061
01:45:41,940 --> 01:45:44,773
Men hvis vi ønsker at se, hvad fejlen
budskab er, at vi kan gøre det her--

2062
01:45:44,773 --> 01:45:48,100
så ./exit, Enter, print
mangler kommandolinje argument.

2063
01:45:48,100 --> 01:45:54,590
>> Hvis jeg nu gøre echo $ ?, der er
latterligt kryptisk leder.

2064
01:45:54,590 --> 01:45:56,590
Men $?

2065
01:45:56,590 --> 01:45:59,220
er den magiske besværgelse
der siger, hey, computer,

2066
01:45:59,220 --> 01:46:01,900
fortælle mig, hvad den tidligere
program exit kode var.

2067
01:46:01,900 --> 01:46:03,410
Og jeg ramte Enter.

2068
01:46:03,410 --> 01:46:07,520
Jeg ser en, fordi det er hvad jeg
fortalte min vigtigste funktion til at vende tilbage.

2069
01:46:07,520 --> 01:46:12,310
>> I mellemtiden, hvis jeg gør ./exit David,
og tryk på Enter, jeg ser, hej David.

2070
01:46:12,310 --> 01:46:16,800
Og hvis jeg nu gør echo $ ?, jeg ser hej 0.

2071
01:46:16,800 --> 01:46:19,080
Og så dette vil faktisk
være værdifuld information

2072
01:46:19,080 --> 01:46:23,420
i forbindelse med debugger, ikke så
meget, at du som menneske, ville pleje.

2073
01:46:23,420 --> 01:46:26,060
Men debugger og andre
programmer vi vil bruge dette semester

2074
01:46:26,060 --> 01:46:29,420
vil ofte se på dette nummer,
selvom det er slags gemt væk

2075
01:46:29,420 --> 01:46:32,780
medmindre du kigge efter det, til
afgøre, om et programs eller ej

2076
01:46:32,780 --> 01:46:37,050
henrettelse var korrekt eller forkert.

2077
01:46:37,050 --> 01:46:40,450
>> Og så bringer os til
dette, ved slutningen af ​​dagen.

2078
01:46:40,450 --> 01:46:43,917
Vi startede i dag ved at se på
debugging, og til gengæld på kurset

2079
01:46:43,917 --> 01:46:46,750
selv, og derefter mere interessant,
teknisk under kølerhjelmen

2080
01:46:46,750 --> 01:46:49,490
på, hvad strenge er, som vare
uge vi bare tog for givet,

2081
01:46:49,490 --> 01:46:51,900
og helt sikkert tog dem
for givet i Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Vi kiggede derefter på, hvordan vi kan få adgang til
enkelte tegn i en streng,

2083
01:46:56,040 --> 01:47:00,310
og derefter igen tog et højere niveau
se på tingene, ser på, hvordan well--

2084
01:47:00,310 --> 01:47:04,226
hvis vi ønsker at komme på individuelt
elementer i en liste som struktur,

2085
01:47:04,226 --> 01:47:05,850
kan vi ikke gøre det med flere strenge?

2086
01:47:05,850 --> 01:47:08,050
Og vi kan med kommandolinjeargumenter.

2087
01:47:08,050 --> 01:47:12,800
Men dette billede her for bare kasser
er demonstrative af denne generelle idé

2088
01:47:12,800 --> 01:47:14,451
af et array, eller en liste, eller en vektor.

2089
01:47:14,451 --> 01:47:16,450
Og afhængigt af
sammenhæng alle disse ord

2090
01:47:16,450 --> 01:47:17,880
betyde lidt forskellige ting.

2091
01:47:17,880 --> 01:47:20,060
Så i C, er vi kun vil
at tale om et array.

2092
01:47:20,060 --> 01:47:23,840
Og et array er en luns
hukommelse, som hver især er

2093
01:47:23,840 --> 01:47:27,720
elementer er sammenhængende, tilbage,
til tilbage, til at bakke, til ryggen.

2094
01:47:27,720 --> 01:47:31,970
>> Og disse elementer er generelt
af samme datatype, karakter,

2095
01:47:31,970 --> 01:47:35,966
karakter, karakter, karakter, eller
streng, snor, snor, snor, eller int,

2096
01:47:35,966 --> 01:47:38,600
int, int, hvad det er
vi forsøger at gemme.

2097
01:47:38,600 --> 01:47:42,540
Men i slutningen af ​​dagen, er dette
hvad det ligner begrebsmæssigt.

2098
01:47:42,540 --> 01:47:44,530
Du tager din
computerens hukommelse eller RAM.

2099
01:47:44,530 --> 01:47:48,590
Og du skære det ud i
identisk størrelse æsker, som alle

2100
01:47:48,590 --> 01:47:50,920
er tilbage, til tilbage, til
tilbage, til tilbage på denne måde.

2101
01:47:50,920 --> 01:47:53,200
>> Og hvad er rart om
denne idé, og det faktum,

2102
01:47:53,200 --> 01:47:58,580
at vi kan udtrykke værdier på denne måde
med den første af vores datastrukturer

2103
01:47:58,580 --> 01:48:02,520
i klassen, betyder, at vi kan begynde
til at løse problemer med kode

2104
01:48:02,520 --> 01:48:04,079
der kom så intuitivt i uge 0.

2105
01:48:04,079 --> 01:48:05,870
Du husker telefonen
bog eksempel hvor

2106
01:48:05,870 --> 01:48:09,110
vi brugte en del og hersk,
eller en binær søgealgoritme,

2107
01:48:09,110 --> 01:48:13,220
at finkæmme gennem en hel
bundt af navne og numre.

2108
01:48:13,220 --> 01:48:18,220
Men vi antog, husker, at der
telefonbog blev allerede sorteret,

2109
01:48:18,220 --> 01:48:21,630
at nogen havde ellers allerede
regnede out-- givet en liste over navne

2110
01:48:21,630 --> 01:48:24,430
og numbers-- hvordan alphabetize dem.

2111
01:48:24,430 --> 01:48:26,950
Og nu, at i C vi,
Også har evnen

2112
01:48:26,950 --> 01:48:30,290
at lægge tingene ud, ikke
fysisk i en telefonbog

2113
01:48:30,290 --> 01:48:34,220
men næsten i en computers
hukommelse, vil vi være i stand næste uge

2114
01:48:34,220 --> 01:48:38,470
at indføre igen denne-- den første
af vores datastrukturer i en array--

2115
01:48:38,470 --> 01:48:43,530
men endnu vigtigere, faktiske computer
videnskab algoritmer implementeret

2116
01:48:43,530 --> 01:48:47,720
i koden, som vi kan gemme
data i strukturer som dette,

2117
01:48:47,720 --> 01:48:50,730
og derefter begynde at manipulere det, og
til faktisk at løse problemer med det,

2118
01:48:50,730 --> 01:48:53,570
og at bygge videre på toppen af ​​det,
i sidste ende, programmer i C,

2119
01:48:53,570 --> 01:48:56,730
i Python, i JavaScript,
forespørge databaser med SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Og vi vil se, at alle disse
forskellige ideer interlock.

2121
01:48:59,980 --> 01:49:04,100
Men for nu, minde om, at
domæne, som vi introducerede i dag

2122
01:49:04,100 --> 01:49:06,920
var denne ting her, og
verden af ​​kryptografi.

2123
01:49:06,920 --> 01:49:11,200
Og blandt de næste problemer, du selv
vil løse er kunsten kryptografi,

2124
01:49:11,200 --> 01:49:13,630
scrambling og de-scrambling
information, og krypteringsydelsesinformationen

2125
01:49:13,630 --> 01:49:15,930
og decifrere tekst,
og under antagelse sidste ende

2126
01:49:15,930 --> 01:49:18,970
at du nu ved, hvad
er under kølerhjelmen

2127
01:49:18,970 --> 01:49:21,860
så når du ser eller modtage
en besked som denne, du

2128
01:49:21,860 --> 01:49:24,060
selv kan tyde det.

2129
01:49:24,060 --> 01:49:26,740
Alt dette, og mere næste gang.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO PLAYBACK]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Lige ankommet.

2133
01:49:32,970 --> 01:49:35,146
Jeg har tænkt mig at gå besøg
hans college professor.

2134
01:49:35,146 --> 01:49:37,611
Yep.

2135
01:49:37,611 --> 01:49:40,080
Hej.

2136
01:49:40,080 --> 01:49:40,660
Det er dig.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Vente!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Jeg prøver bare at regne
ud af, hvad der skete med dig.

2142
01:49:56,060 --> 01:49:58,130
Please, noget kunne hjælpe.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Du var hans college
værelseskammerat, var du ikke?

2145
01:50:08,354 --> 01:50:10,770
Du var der med ham, når
han færdig med CS50 projektet?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUSIK AFSPILLER]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Det Var CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Jeg elsker dette sted.

2152
01:50:44,770 --> 01:50:45,854
>> -Spise op.

2153
01:50:45,854 --> 01:50:47,020
Vi kommer ud af markedet.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END AFSPIL]

