1
00:00:00,000 --> 00:00:02,970
>> [MUZICĂ]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> David J. MALAN: Bine.

4
00:00:15,700 --> 00:00:18,832
Aceasta este CS50 si aceasta
este începutul săptămânii 2.

5
00:00:18,832 --> 00:00:21,040
Și veți aminti că peste
ultimele două săptămâni,

6
00:00:21,040 --> 00:00:24,490
am fost introducerea de calculator
știință și, la rândul său, de programare.

7
00:00:24,490 --> 00:00:27,640
>> Și am început povestea prin intermediul
Zero, această limbă grafică

8
00:00:27,640 --> 00:00:28,990
de la MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
Și apoi cel mai recent,
săptămâna trecută, ne-am

10
00:00:30,780 --> 00:00:34,450
introduce un higher-- un
limbaj de nivel inferior cunoscut

11
00:00:34,450 --> 00:00:36,770
ca C, ceva care este pur textuală.

12
00:00:36,770 --> 00:00:39,440
Și, într-adevăr, ultima dată când am
a explorat în acest context,

13
00:00:39,440 --> 00:00:40,450
o serie de concepte.

14
00:00:40,450 --> 00:00:43,010
>> Acest lucru, amintesc, a fost foarte
Primul program de ne-am uitat la.

15
00:00:43,010 --> 00:00:45,710
Si acest program, pur și simplu,
imprimă, "Bună ziua, lume."

16
00:00:45,710 --> 00:00:47,730
Dar, există atât de mult
părând magie merge mai departe.

17
00:00:47,730 --> 00:00:51,460
Exista acest #include
cu aceste paranteze unghiulare.

18
00:00:51,460 --> 00:00:52,170
Nu e int.

19
00:00:52,170 --> 00:00:53,020
Nu e (void).

20
00:00:53,020 --> 00:00:56,330
Există între paranteze, acolade,
semi-colons, și multe altele.

21
00:00:56,330 --> 00:00:58,480
>> Și astfel, reamintim că
am introdus Scratch

22
00:00:58,480 --> 00:01:02,110
astfel încât să putem, în mod ideal, vedea trecutul
că sintaxa, lucrurile care nu este cu adevărat

23
00:01:02,110 --> 00:01:04,590
tot ceea ce intelectual
interesant, dar devreme

24
00:01:04,590 --> 00:01:07,700
este, în mod absolut, un pic mai complicat
să-și încheie mintea în jurul valorii.

25
00:01:07,700 --> 00:01:10,860
Și, într-adevăr, una dintre cele mai frecvente
lucruri devreme într-o clasă de programare,

26
00:01:10,860 --> 00:01:13,443
în special pentru cei mai puțin
confortabil, este de a obține frustrat de

27
00:01:13,443 --> 00:01:17,460
și împiedicați de anumite sintactic
erori, să nu mai vorbim de erori logice.

28
00:01:17,460 --> 00:01:19,800
Și astfel, printre scopurile noastre
astăzi, de fapt, va

29
00:01:19,800 --> 00:01:23,280
fie pentru a vă dota cu unele
Tehnici de rezolvare a problemelor pentru modul în care

30
00:01:23,280 --> 00:01:26,705
pentru a rezolva mai bine problemele ei înșiși
sub formă de depanare.

31
00:01:26,705 --> 00:01:29,330
Și veți aminti, de asemenea, că
mediu pe care am introdus

32
00:01:29,330 --> 00:01:31,780
Ultima dată a fost numit CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Acest lucru este un software bazat pe web, care
vă permite să programați în nor,

34
00:01:34,850 --> 00:01:38,450
ca să spunem așa, păstrând în același timp toate dvs.
fișiere împreună, așa cum vom astăzi din nou.

35
00:01:38,450 --> 00:01:41,480
Și amintesc că noi
Revisited aceste subiecte aici,

36
00:01:41,480 --> 00:01:44,480
printre ei funcții și bucle, și
variabile și expresii booleene,

37
00:01:44,480 --> 00:01:45,110
și condiții.

38
00:01:45,110 --> 00:01:49,190
Și, de fapt, câteva mai mult ca noi
tradus din lumea Scratch

39
00:01:49,190 --> 00:01:50,800
la lumea C.

40
00:01:50,800 --> 00:01:53,220
>> Dar, clădirea fundamentală
blocuri, ca să spunem așa,

41
00:01:53,220 --> 00:01:55,150
au fost într-adevăr încă în aceeași săptămână trecută.

42
00:01:55,150 --> 00:01:57,900
De fapt, am de fapt doar a avut o
diferite piese de puzzle, dacă vreți.

43
00:01:57,900 --> 00:02:00,300
În loc de asta violet
salvați bloc, noi în loc

44
00:02:00,300 --> 00:02:02,940
a printf, care este
această funcție în C, care

45
00:02:02,940 --> 00:02:05,890
vă permite să imprimați ceva
și-l formatați pe ecran.

46
00:02:05,890 --> 00:02:07,950
Am introdus CS50
Bibliotecă, în cazul în care tu

47
00:02:07,950 --> 00:02:11,420
au acum la get_char ta de eliminare,
și get_int, și get_string,

48
00:02:11,420 --> 00:02:14,610
și alte câteva funcții ca
bine, prin care puteți obține de intrare

49
00:02:14,610 --> 00:02:16,260
de la tastatura proprie a utilizatorului.

50
00:02:16,260 --> 00:02:20,640
Si am luat, de asemenea, o privire la lucrurile
cum ar fi these- bool, și char,

51
00:02:20,640 --> 00:02:22,490
și dublu, float,
int, string long_long.

52
00:02:22,490 --> 00:02:25,170
Și, există chiar și alte tipuri de date în C.

53
00:02:25,170 --> 00:02:28,560
>> Cu alte cuvinte, atunci când declarați
o variabilă pentru a stoca o anumită valoare,

54
00:02:28,560 --> 00:02:32,600
sau când implementați o funcție
care returnează o anumită valoare,

55
00:02:32,600 --> 00:02:35,290
puteți specifica ce
tipul de valoare care este.

56
00:02:35,290 --> 00:02:37,310
Este un șir de caractere, cum ar fi o
secvență de caractere?

57
00:02:37,310 --> 00:02:39,490
Este un număr, cum ar fi un număr întreg?

58
00:02:39,490 --> 00:02:41,390
Este un punct plutitor
valoare, sau ceva asemănător?

59
00:02:41,390 --> 00:02:46,180
Deci, în C, spre deosebire de zero, de fapt, ne-am
a început să se precizeze ce fel de date

60
00:02:46,180 --> 00:02:48,330
ne intorceam sau folosind.

61
00:02:48,330 --> 00:02:51,910
>> Dar, desigur, am fugit, de asemenea, în
anumite limite fundamentale de calcul.

62
00:02:51,910 --> 00:02:54,100
Și, în special,
această limbă C, rechemare

63
00:02:54,100 --> 00:02:57,070
că am luat o privire
preaplin întreg, realitatea

64
00:02:57,070 --> 00:03:00,460
că, dacă aveți doar un
cantitate finită de memorie

65
00:03:00,460 --> 00:03:04,600
sau, în mod specific, un număr finit
de biți, puteți conta doar atât de mare.

66
00:03:04,600 --> 00:03:08,460
Și așa ne-am uitat la acest exemplu aici
prin care un contor într-un avion,,

67
00:03:08,460 --> 00:03:13,510
de fapt, în cazul în care rulează suficient de mult s-ar
overflow si duce la un software

68
00:03:13,510 --> 00:03:15,560
un potențial de eroare fizică reală.

69
00:03:15,560 --> 00:03:18,600
>> De asemenea, ne-am uitat la plutitoare
punctul imprecizie, realitatea

70
00:03:18,600 --> 00:03:22,280
că doar un număr finit
de biți, fie că este vorba de 32 sau 64,

71
00:03:22,280 --> 00:03:27,330
puteți specifica doar atât de multe numere
după un punct zecimal, după care

72
00:03:27,330 --> 00:03:29,110
încep să se imprecis.

73
00:03:29,110 --> 00:03:32,360
Deci, de exemplu, o treime din
mondial aici, în lumea noastră umană,

74
00:03:32,360 --> 00:03:35,360
stim ca este doar un număr infinit
de 3s după virgulă.

75
00:03:35,360 --> 00:03:38,820
Dar un computer nu poate în mod necesar
reprezintă un număr infinit de numere

76
00:03:38,820 --> 00:03:42,590
dacă permiteți numai că unele
cantitate finită de informație.

77
00:03:42,590 --> 00:03:45,900
>> Deci, nu numai că v-am dota
cu o mai mare putere în termeni

78
00:03:45,900 --> 00:03:49,280
de modul în care s-ar putea exprima-te la
o tastatură în termeni de programare,

79
00:03:49,280 --> 00:03:51,430
De asemenea, am limitat ceea ce
puteți face de fapt.

80
00:03:51,430 --> 00:03:55,790
Și într-adevăr, erorile și greșelile pot
provin din aceste tipuri de probleme.

81
00:03:55,790 --> 00:03:59,900
Și într-adevăr, printre subiectele de astăzi
vor fi subiecte cum ar fi depanare

82
00:03:59,900 --> 00:04:03,699
și de fapt, în căutarea sub capota
la modul în care au fost introduse lucruri săptămâna trecută

83
00:04:03,699 --> 00:04:05,490
sunt de fapt puse în aplicare
astfel încât să o mai bună

84
00:04:05,490 --> 00:04:10,530
să înțeleagă atât capacitățile și
limitările unui limbaj cum ar fi C.

85
00:04:10,530 --> 00:04:14,770
>> Și, de fapt, ne vom coaja înapoi straturile
dintre cele mai simple structurii de date,

86
00:04:14,770 --> 00:04:17,756
ceva numit o matrice, care
Se întâmplă la zero pentru a apela o "listă."

87
00:04:17,756 --> 00:04:19,589
E un pic
diferite în acest context.

88
00:04:19,589 --> 00:04:23,340
Și apoi vom introduce, de asemenea, una dintre cele mai
în primul rând problemelor noastre specifice domeniului

89
00:04:23,340 --> 00:04:26,790
în CS50, lumea
criptografie, arta de codare

90
00:04:26,790 --> 00:04:29,650
sau în cifrare informații, astfel
pe care le puteți trimite mesaje secrete

91
00:04:29,650 --> 00:04:34,520
și să decodifice mesaje secrete
între două persoane, A și B.

92
00:04:34,520 --> 00:04:37,490
>> Așa că, înainte de tranziție
la acea lume nouă,

93
00:04:37,490 --> 00:04:42,059
să încercăm să vă dota cu unele
tehnici cu care puteți elimina

94
00:04:42,059 --> 00:04:43,850
sau reduce cel puțin unele
din frustrările

95
00:04:43,850 --> 00:04:46,630
pe care le-ați întâlnit, probabil,
peste numai săptămâna trecută.

96
00:04:46,630 --> 00:04:50,830
De fapt, înainte de tine sunt such-- unele dintre
primele probleme în C. Și cote sunt,

97
00:04:50,830 --> 00:04:54,010
daca esti ca mine, prima dată
încercați să tastați un program,

98
00:04:54,010 --> 00:04:57,330
chiar dacă te gândești logic
programul este destul de simplu,

99
00:04:57,330 --> 00:05:01,200
s-ar putea lovi foarte bine un zid, și
compilator nu este de gând să coopereze.

100
00:05:01,200 --> 00:05:03,940
Asigurați-vă sau zăngănit nu se întâmplă
pentru a face de fapt licitarea.

101
00:05:03,940 --> 00:05:05,450
>> Și de ce s-ar putea să fie asta?

102
00:05:05,450 --> 00:05:07,950
Ei bine, hai să aruncăm o privire,
probabil, un program simplu.

103
00:05:07,950 --> 00:05:11,190
Mă duc să merg mai departe și de a salva acest lucru în
un fișier în mod deliberat numit buggy0.c,

104
00:05:11,190 --> 00:05:13,590
pentru că eu știu să
viciate în avans.

105
00:05:13,590 --> 00:05:17,400
Dar eu s-ar putea să nu dau seama că, dacă acest lucru
este primul sau al doilea sau al treilea program

106
00:05:17,400 --> 00:05:18,830
că eu sunt de fapt, mă fac.

107
00:05:18,830 --> 00:05:23,820
Așa că am de gând să merg mai departe și
tip out, int main (void).

108
00:05:23,820 --> 00:05:28,130
Și apoi în interiorul bretele mele buclat,
un foarte familiar ( "Bună ziua, world--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - și o semi-colon.

110
00:05:30,980 --> 00:05:32,360
>> Am salvat fișierul.

111
00:05:32,360 --> 00:05:34,850
Acum am de gând să merg în jos
la fereastra mea terminală

112
00:05:34,850 --> 00:05:40,340
și tipul de marca buggy0, pentru că, din nou,
numele fișierului de astăzi este buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Așa că am tip face buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Si, oh, Doamne, amintesc de la ultima dată
că nici un mesaj de eroare este un lucru bun.

115
00:05:48,200 --> 00:05:49,740
Astfel încât nici o ieșire este un lucru bun.

116
00:05:49,740 --> 00:05:52,920
Dar aici am clar
unele număr de greșeli.

117
00:05:52,920 --> 00:05:56,470
>> Deci, prima linie de ieșire
după tastarea face buggy0, rechemare,

118
00:05:56,470 --> 00:05:59,540
este de ieșire destul de verbose zăngănit lui.

119
00:05:59,540 --> 00:06:02,067
Sub capota,
CS50 IDE este configurat

120
00:06:02,067 --> 00:06:04,150
de a utiliza un întreg buchet de
opțiuni cu acest compilator

121
00:06:04,150 --> 00:06:05,941
astfel încât să nu aveți
să se gândească la ele.

122
00:06:05,941 --> 00:06:08,840
Și asta e tot ce prima linie
înseamnă că începe cu zăngănit.

123
00:06:08,840 --> 00:06:11,720
>> Dar, după aceea, problemele
încep să-și facă apariția lor.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c pe linia 3, caracter
5, există o mare eroare, roșu.

125
00:06:17,390 --> 00:06:18,380
Ce este asta?

126
00:06:18,380 --> 00:06:23,562
de declarare a funcției de bibliotecă implicit
printf cu tipul int (char * const,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Vreau să spun, foarte repede
devine foarte arcane.

129
00:06:28,379 --> 00:06:30,170
Și, cu siguranță, la început
vedere, nu ne-ar

130
00:06:30,170 --> 00:06:32,380
se așteaptă să înțelegeți
integralitatea mesajului respectiv.

131
00:06:32,380 --> 00:06:34,213
Și astfel, una dintre lecțiile
pentru ziua de azi se întâmplă

132
00:06:34,213 --> 00:06:36,919
să fie pentru a încerca să observe
modele, sau alte lucruri similare,

133
00:06:36,919 --> 00:06:38,960
la erori s-ar putea avea
întâlnite în trecut.

134
00:06:38,960 --> 00:06:41,335
Așa că hai numai lui tachineze în afară
acele cuvinte care arata familiar.

135
00:06:41,335 --> 00:06:44,290
Mare eroare, roșu este în mod clar
simbolic de ceva fiind greșit.

136
00:06:44,290 --> 00:06:47,940
>> implicit de declarare
Funcția bibliotecă printf.

137
00:06:47,940 --> 00:06:51,680
Deci, chiar dacă eu nu înțeleg ce
declarând implicit funcția de bibliotecă

138
00:06:51,680 --> 00:06:54,900
înseamnă, problema cu siguranță
se referă la printf într-un fel.

139
00:06:54,900 --> 00:06:59,130
Iar sursa acestei probleme
are de a face cu declararea acesteia.

140
00:06:59,130 --> 00:07:02,440
>> Declararea unei funcții este
menționând-o pentru prima dată.

141
00:07:02,440 --> 00:07:06,210
Si am folosit terminologia săptămâna trecută
de a declara prototipul unei funcții, a

142
00:07:06,210 --> 00:07:11,860
fie cu o singură linie, la partea de sus a ta
fișier propriu sau într-un fișier antet așa-numitele.

143
00:07:11,860 --> 00:07:15,300
Și în ce dosar a făcut am spus
săptămâna trecută că printf este citat,

144
00:07:15,300 --> 00:07:17,080
unquote, a declarat?

145
00:07:17,080 --> 00:07:20,950
În ce fișier este prototipul ei?

146
00:07:20,950 --> 00:07:24,640
>> Deci, dacă vă amintiți, primul lucru pe care am
dactilografiate, aproape fiecare program de ultima time--

147
00:07:24,640 --> 00:07:30,790
și din greșeală un moment în urmă a început
tastând myself-- a fost acesta aici--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- pentru
intrare / output-- punct h Și într-adevăr,

149
00:07:38,630 --> 00:07:41,860
dacă salvez acum acest fișier, voi
pentru a merge mai departe și clar ecranul meu,

150
00:07:41,860 --> 00:07:44,740
pe care le puteți face prin tastarea
Clar, sau puteți ține de Control L,

151
00:07:44,740 --> 00:07:47,680
doar pentru a șterge fereastra terminalului
doar pentru a elimina unele dezordine.

152
00:07:47,680 --> 00:07:51,370
>> Mă duc să merg mai departe și
re-make tip buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Și, iată, eu încă văd că
comandă lung de la zăngănit,

154
00:07:53,790 --> 00:07:55,470
dar nu există nici un mesaj de eroare de data asta.

155
00:07:55,470 --> 00:07:58,800
Și într-adevăr, dacă eu fac ./buggy0,
la fel ca ultima dată,

156
00:07:58,800 --> 00:08:01,860
în cazul în care acest lucru înseamnă că dot
director, Slash înseamnă doar,

157
00:08:01,860 --> 00:08:05,040
aici vine numele programului și
că numele programului este buggy0,

158
00:08:05,040 --> 00:08:07,340
Enter, "Bună ziua, lume."

159
00:08:07,340 --> 00:08:09,440
>> Acum, cum v-ar putea avea
spicuite această soluție

160
00:08:09,440 --> 00:08:12,017
fără a fi necesar
recunoscând cât mai multe cuvinte

161
00:08:12,017 --> 00:08:14,350
așa cum am făcut-o, cu siguranță, având în
făcut acest lucru pentru atât de mulți ani?

162
00:08:14,350 --> 00:08:18,720
Ei bine, dau seama pe prima problemă
set, vă prezentăm o comandă

163
00:08:18,720 --> 00:08:21,175
că personalul propriu CS50 lui
a scris numit help50.

164
00:08:21,175 --> 00:08:24,300
Și într-adevăr, C nu specificație pentru
problema stabilită cu privire la modul de a utiliza aceasta.

165
00:08:24,300 --> 00:08:27,210
>> Dar, în esență, este help50
un program care personalul CS50 lui

166
00:08:27,210 --> 00:08:30,850
ați scris că permite să ruleze
o comandă sau de a rula un program,

167
00:08:30,850 --> 00:08:36,169
și dacă nu înțelegi ei
de ieșire, pentru a trece la producția help50,

168
00:08:36,169 --> 00:08:38,890
moment în care software-ul
că personalul cursului scris

169
00:08:38,890 --> 00:08:42,429
se va uita la ieșire programul tău
linie cu linie, caracter cu caracter.

170
00:08:42,429 --> 00:08:46,000
Iar dacă noi, personalul, să recunoască
mesaj de eroare care vă confruntați,

171
00:08:46,000 --> 00:08:50,580
vom încerca să vă provoace cu unele
întrebări retorice, cu un sfat,

172
00:08:50,580 --> 00:08:54,890
mult ca un TF sau AC sau de mine
s-ar face în persoană la ore de birou.

173
00:08:54,890 --> 00:08:58,320
>> Asa ca uita-te la help50 dacă nu
să recunoască în mod necesar o problemă.

174
00:08:58,320 --> 00:09:00,790
Dar nu se bazează pe ea
prea mult ca o carja.

175
00:09:00,790 --> 00:09:03,990
Cu siguranță încerca să înțeleagă ei
de ieșire și apoi să învețe de la ea

176
00:09:03,990 --> 00:09:07,571
astfel încât numai o dată sau de două ori nu-i
vreodată rula help50 pentru o anumită eroare

177
00:09:07,571 --> 00:09:08,070
mesaj.

178
00:09:08,070 --> 00:09:10,660
După aceea, ar trebui să fie
mai bine te echipate

179
00:09:10,660 --> 00:09:13,180
să ne dăm seama ce este de fapt.

180
00:09:13,180 --> 00:09:14,350
>> Hai să facem încă o aici.

181
00:09:14,350 --> 00:09:20,410
Lasă-mă să merg mai departe, și într-un alt
fișier îl vom numi acest buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Și, în acest fișier Sunt
mergi la deliberately--

183
00:09:23,110 --> 00:09:26,330
dar pretind că nu fac eu
să înțeleagă ce greșeală am făcut.

184
00:09:26,330 --> 00:09:31,420
>> Mă duc să merg mai departe și de a face astea--
#include, de când am

185
00:09:31,420 --> 00:09:33,660
a învățat lecția mea de la un moment în urmă.

186
00:09:33,660 --> 00:09:36,220
Int main (void), la fel ca înainte.

187
00:09:36,220 --> 00:09:40,880
Și apoi aici voi
de a face string s - get_string.

188
00:09:40,880 --> 00:09:43,770
Si amintesc de ultima dată
Aceasta înseamnă, hei, calculator,

189
00:09:43,770 --> 00:09:48,280
da-mi o variabilă, numesc s, i
face tipul acelei variabile un șir de caractere

190
00:09:48,280 --> 00:09:50,150
așa că pot stoca unul sau mai multe cuvinte în ea.

191
00:09:50,150 --> 00:09:52,191
>> Și apoi pe-dreapta
parte a semnului egal

192
00:09:52,191 --> 00:09:54,980
este get_string, care este
funcție în Biblioteca CS50

193
00:09:54,980 --> 00:09:55,980
care face exact asta.

194
00:09:55,980 --> 00:09:59,740
Ea devine o funcție și apoi
mâinile-l de la dreapta la stânga.

195
00:09:59,740 --> 00:10:02,670
Așa că acest semn egal nu înseamnă
"Este egal cu" așa cum ne-am putea gândi la matematică.

196
00:10:02,670 --> 00:10:04,750
Aceasta înseamnă misiune de la dreapta la stânga.

197
00:10:04,750 --> 00:10:09,640
Deci, acest lucru înseamnă, luați șirul de
utilizatorul și depozitați-l în interiorul lui.

198
00:10:09,640 --> 00:10:10,460
>> Acum, să-l folosească.

199
00:10:10,460 --> 00:10:13,820
Lasă-mă să merg mai departe acum și ca un al doilea
line, lasă-mă să merg mai departe și spun "salut" -

200
00:10:13,820 --> 00:10:19,330
nu "lume", dar "salut,% S-
care este substituent nostru, virgulă s,

201
00:10:19,330 --> 00:10:22,030
care este variabila noastră,
și apoi un semi-colon.

202
00:10:22,030 --> 00:10:26,070
Așa că, dacă nu am șurub prea mult
aici, acest lucru arata ca codul corect.

203
00:10:26,070 --> 00:10:28,090
>> Iar instinctele mele acum trebuie să-l compila.

204
00:10:28,090 --> 00:10:30,400
Fișierul este numit buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Așa că voi face să fac buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Și, darn-l, în cazul în care nu există
chiar și mai multe erori decât înainte.

207
00:10:36,377 --> 00:10:38,210
Vreau să spun, mai este
mesaje de eroare s-ar

208
00:10:38,210 --> 00:10:40,400
par decât liniile reale în acest program.

209
00:10:40,400 --> 00:10:42,730
>> Dar aici este takeaway,
chiar dacă ești copleșit

210
00:10:42,730 --> 00:10:45,040
cu două sau trei ori
mai mult de patru mesaje de eroare,

211
00:10:45,040 --> 00:10:48,340
întotdeauna se concentreze pe foarte
mai întâi aceste mesaje.

212
00:10:48,340 --> 00:10:52,220
Cautati cel mai de sus-unul,
defilare din nou cât este necesar.

213
00:10:52,220 --> 00:10:53,930
Deci, aici am scris marca buggy1.

214
00:10:53,930 --> 00:10:55,700
Iată că producția zăngănit cum era de așteptat.

215
00:10:55,700 --> 00:10:57,290
>> Și aici e prima eroare roșie.

216
00:10:57,290 --> 00:11:02,370
Utilizarea de identificator nedeclarat
șir de caractere, am să spun standard?

217
00:11:02,370 --> 00:11:04,260
Deci, în standard este
de fapt, altceva.

218
00:11:04,260 --> 00:11:06,240
Aceasta se referă la ul utilizatorului
tastatură, în esență.

219
00:11:06,240 --> 00:11:08,080
>> Dar asta nu e ceea ce am vrut să spun.

220
00:11:08,080 --> 00:11:11,770
Am vrut să spun șir, și am vrut să spun get_string.

221
00:11:11,770 --> 00:11:16,200
Deci, ce este că eu
a uitat să facă acest timp?

222
00:11:16,200 --> 00:11:20,230
Ce lipsește de data asta?

223
00:11:20,230 --> 00:11:23,600
Am #include meu,
așa că am acces la printf.

224
00:11:23,600 --> 00:11:26,090
>> Dar ce nu am
acces la doar încă?

225
00:11:26,090 --> 00:11:29,420
Ei bine, la fel ca și ultima dată,
Trebuie să spun compilator

226
00:11:29,420 --> 00:11:31,691
Clang ce aceste funcții sunt.

227
00:11:31,691 --> 00:11:33,940
Get_string nu vine
cu C. Și, în special,

228
00:11:33,940 --> 00:11:38,160
nu a venit în
antetul fișierului,.

229
00:11:38,160 --> 00:11:40,770
Ea vine în schimb în
ceva personalul scris,

230
00:11:40,770 --> 00:11:44,176
care este un alt fișier
nume, dar pe bună dreptate numit.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Așa că, pur și simplu prin adăugarea că o singură linie
de rechemare din code-- ultima dată

233
00:11:50,861 --> 00:11:53,610
că, atunci când zăngănit se execută, va
să se uite la codul meu de sus în jos,

234
00:11:53,610 --> 00:11:54,193
de la stânga la dreapta.

235
00:11:54,193 --> 00:11:57,200
Se va observa,
oh, vrei.

236
00:11:57,200 --> 00:11:59,900
Lasă-mă să plec și găsesc că,
ori de câte ori este pe server,

237
00:11:59,900 --> 00:12:03,090
copiați și lipiți-l, în esență,
în partea de sus a propriul fișier

238
00:12:03,090 --> 00:12:06,820
astfel încât în ​​acest moment în poveste,
linia 1, restul programului

239
00:12:06,820 --> 00:12:11,651
poate, într-adevăr, utilizați oricare dintre funcțiile
în aceasta, printre care get_string.

240
00:12:11,651 --> 00:12:13,650
Așa că voi ignora
restul acestor erori,

241
00:12:13,650 --> 00:12:17,190
pentru că, într-adevăr, suspecta că numai
primul a contat de fapt.

242
00:12:17,190 --> 00:12:20,780
Si voi merge mai departe și rulați din nou,
după salvarea fișierul meu face buggy1.

243
00:12:20,780 --> 00:12:22,580
Și voila, a făcut de lucru.

244
00:12:22,580 --> 00:12:29,200
Și, dacă fac eu ./buggy1 și tastați, pentru
exemplu, Zamyla, eu acum va primi salut,

245
00:12:29,200 --> 00:12:32,000
Zamyla, în loc de salut, lume.

246
00:12:32,000 --> 00:12:32,550
>> In regula.

247
00:12:32,550 --> 00:12:35,890
Așa că takeaways de aici, apoi sunt,
unul, încercați să culeagă spice la fel de mult ca tine poate

248
00:12:35,890 --> 00:12:39,140
din mesajele de eroare în monoterapie, în căutarea
la unele dintre cuvintele de recunoscut.

249
00:12:39,140 --> 00:12:43,070
Barare că, utilizați help50 per
problema set caietul de sarcini.

250
00:12:43,070 --> 00:12:46,500
Exceptând însă că, de asemenea, uita-te mereu
la eroarea de sus numai, cel puțin

251
00:12:46,500 --> 00:12:50,051
inițial, pentru a vedea ce informații
ar putea rezulta de fapt.

252
00:12:50,051 --> 00:12:52,300
Dar se pare că nu există
chiar și o funcționalitate mai construit

253
00:12:52,300 --> 00:12:55,030
în Biblioteca CS50 pentru a ajuta
te devreme în semestrul

254
00:12:55,030 --> 00:12:57,580
și timpuriu în programarea
dau seama ce se întâmplă greșit.

255
00:12:57,580 --> 00:12:59,840
Așa că hai să facem un alt exemplu aici.

256
00:12:59,840 --> 00:13:04,350
Mă duc să sun acest buggy2, care,
din nou, va fi eronate din

257
00:13:04,350 --> 00:13:05,650
de la poarta, prin design.

258
00:13:05,650 --> 00:13:09,980
>> Si voi merge mai departe
și de a face #include.

259
00:13:09,980 --> 00:13:12,580
Și apoi am de gând să fac int main (void).

260
00:13:12,580 --> 00:13:14,840
Și apoi am de gând să fac o buclă.

261
00:13:14,840 --> 00:13:16,690
Pentru (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i este mai mică sau egală cu 10.

263
00:13:18,750 --> 00:13:24,260
i ++, și apoi în acolade, voi
pentru a imprima doar un simbol hashtag aici

264
00:13:24,260 --> 00:13:25,920
și o nouă linie de caractere.

265
00:13:25,920 --> 00:13:29,220
>> Așa că intenția mea cu această
Programul este destul de simplu

266
00:13:29,220 --> 00:13:33,150
revizuim de 10 ori
și pe fiecare iterație

267
00:13:33,150 --> 00:13:35,260
din această buclă de fiecare dată
prin ciclul,

268
00:13:35,260 --> 00:13:37,660
imprima un hashtag,
un hashtag, un hashtag.

269
00:13:37,660 --> 00:13:40,480
Câte unul pe fiecare rând pentru că am
au noua linie de acolo.

270
00:13:40,480 --> 00:13:42,787
Și reamintească faptul că pentru
buclă, pe ultima week--

271
00:13:42,787 --> 00:13:44,620
și veți obține mai mult
familiarizat cu sintaxa

272
00:13:44,620 --> 00:13:47,170
prin utilizarea acestuia cu practica
înainte de a long-- acest lucru mi dă

273
00:13:47,170 --> 00:13:49,740
o variabilă am numit și setează-l la 0.

274
00:13:49,740 --> 00:13:52,650
>> Acest lucru incrementează i pe
fiecare iterație de 1.

275
00:13:52,650 --> 00:13:54,940
Deci, am merge la 1 la 2 la 3.

276
00:13:54,940 --> 00:13:57,690
Și apoi această condiție în
mijloc între semi colonul

277
00:13:57,690 --> 00:14:03,010
se verifică la fiecare iterație pentru a face
sigur că suntem încă în raza de acțiune.

278
00:14:03,010 --> 00:14:06,830
Așa că vreau să itera de 10 ori, așa că am
au un fel de foarte intuitiv doar

279
00:14:06,830 --> 00:14:09,070
a pus 10 ca meu de sus legat acolo.

280
00:14:09,070 --> 00:14:14,310
>> Și totuși, când am rulat acest lucru, după
compilarea cu marca buggy2--

281
00:14:14,310 --> 00:14:15,440
și alcătuiește OK.

282
00:14:15,440 --> 00:14:17,980
Deci, eu nu am un
Eroare de sintaxă de această dată.

283
00:14:17,980 --> 00:14:20,940
Lasă-mă să plec mai departe acum
și a alerga buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Și acum derulați în sus.

285
00:14:22,620 --> 00:14:24,890
Și lasă-mă crească
dimensiunea ferestrei.

286
00:14:24,890 --> 00:14:33,720
>> Se pare că am 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Deci, nu există 11 hashtagurilor, chiar dacă
Am pus în mod clar 10 în interiorul acestei bucle.

288
00:14:38,891 --> 00:14:42,140
Acum, unii dintre voi s-ar putea vedea imediat
care eroarea se datorează faptului că, într-adevăr, această

289
00:14:42,140 --> 00:14:43,720
nu este o eroare foarte greu de făcut.

290
00:14:43,720 --> 00:14:46,070
Dar este foarte frecvent
a făcut foarte devreme.

291
00:14:46,070 --> 00:14:49,820
>> Ceea ce vreau să subliniez, totuși,
este, cum s-ar putea să dau asta?

292
00:14:49,820 --> 00:14:52,300
Ei bine, se pare că
Biblioteca CS50 vine

293
00:14:52,300 --> 00:14:55,380
nu numai get_string și get_int
și get_float și alte funcții.

294
00:14:55,380 --> 00:14:59,980
De asemenea, vine cu o funcție specială
numita eprintf, sau, eroare printf.

295
00:14:59,980 --> 00:15:03,270
Și ea există numai pentru a face
un pic mai ușor pentru tine

296
00:15:03,270 --> 00:15:06,310
atunci când codul de depanare doar spre
imprima un mesaj de eroare pe ecran

297
00:15:06,310 --> 00:15:07,850
și știu de unde a venit.

298
00:15:07,850 --> 00:15:11,000
>> Deci, de exemplu, un singur lucru aș putea
face aici cu această funcție este astea--

299
00:15:11,000 --> 00:15:20,230
eprintf, și apoi am de gând să merg mai departe
și spun eu acum este% i, backslash, n.

300
00:15:20,230 --> 00:15:22,330
Și am de gând să conectați în valoarea lui i.

301
00:15:22,330 --> 00:15:25,400
Și până sus, deoarece acest lucru
este în Biblioteca CS50,

302
00:15:25,400 --> 00:15:27,580
Mă duc să merg mai departe
și includ

303
00:15:27,580 --> 00:15:29,169
așa că am acces la această funcție.

304
00:15:29,169 --> 00:15:31,460
Dar, să ia în considerare ce linie
9 se presupune a face.

305
00:15:31,460 --> 00:15:32,670
Voi șterge acest în cele din urmă.

306
00:15:32,670 --> 00:15:34,670
Acest lucru nu are nimic de-a face
cu scopul meu primordial.

307
00:15:34,670 --> 00:15:39,090
Dar, eprintf, eroare printf, este doar a însemnat
să-mi dea niște informații de diagnostic.

308
00:15:39,090 --> 00:15:42,460
Când m-am rula programul meu, vreau să
a se vedea acest lucru pe ecran temporar

309
00:15:42,460 --> 00:15:44,550
precum și doar pentru a înțelege
ce se întâmplă.

310
00:15:44,550 --> 00:15:47,330
>> Și, într-adevăr, pe fiecare
iterație aici de linia 9

311
00:15:47,330 --> 00:15:49,260
Vreau să văd, ceea ce este valoarea lui i?

312
00:15:49,260 --> 00:15:50,290
Care este valoarea lui i?

313
00:15:50,290 --> 00:15:51,280
Care este valoarea lui i?

314
00:15:51,280 --> 00:15:55,650
Și, sperăm, numai eu ar trebui
a se vedea acel mesaj, de asemenea, de 10 ori.

315
00:15:55,650 --> 00:15:57,780
>> Așa că lasă-mă să merg mai departe și
recompilați programul meu,

316
00:15:57,780 --> 00:15:59,905
așa cum am să fac orice moment
Eu fac o schimbare. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Și now-- OK.

319
00:16:03,640 --> 00:16:04,820
Există o mult mai întâmplă.

320
00:16:04,820 --> 00:16:07,610
Așa că lasă-mă în defila în sus
o fereastră chiar mai mare.

321
00:16:07,610 --> 00:16:10,190
>> Și veți vedea că fiecare dintre
hashtag-ul este încă de imprimare.

322
00:16:10,190 --> 00:16:15,270
Dar, între fiecare dintre ele este acum această
ieșire diagnosticare formatat după cum urmează.

323
00:16:15,270 --> 00:16:17,960
Numele programului meu de aici este buggy2.

324
00:16:17,960 --> 00:16:20,432
Numele fișierului este buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Numărul liniei din care
acest lucru a fost tipărit este linia 9.

326
00:16:24,080 --> 00:16:27,500
Și apoi spre dreapta, care este
mesaj de eroare pe care mă așteptam.

327
00:16:27,500 --> 00:16:30,701
>> Și ce e frumos despre acest lucru este faptul că
Acum nu trebuie să conta în mod necesar

328
00:16:30,701 --> 00:16:32,200
în capul meu ce programul meu este de a face.

329
00:16:32,200 --> 00:16:34,240
Pot să văd că, pe
prima iterație i este 0,

330
00:16:34,240 --> 00:16:39,420
apoi 1, apoi 2, apoi 3, apoi 4, apoi
5, apoi 6, apoi 7, apoi 8, apoi 9, atunci

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Stai un minut.

333
00:16:42,050 --> 00:16:43,740
Ce se petrece aici?

334
00:16:43,740 --> 00:16:48,190
Eu încă par să fie de numărare
în conformitate cu destinația de până la 10.

335
00:16:48,190 --> 00:16:50,550
>> Dar de unde am început?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Deci 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- degetul 11

338
00:16:58,040 --> 00:16:59,990
este un indiciu al problemei.

339
00:16:59,990 --> 00:17:02,850
Se pare că am numărat
incorect în buclă mea.

340
00:17:02,850 --> 00:17:06,599
Mai degrabă decât a merge 10 iterații,
Sunt incepand de la 0,

341
00:17:06,599 --> 00:17:09,550
Mă termină la și prin 10.

342
00:17:09,550 --> 00:17:12,030
Dar, pentru că, la fel ca un computer,
Am început de numărare de la 0,

343
00:17:12,030 --> 00:17:15,250
Ar trebui să fie incrementală
la, dar nu prin, 10.

344
00:17:15,250 --> 00:17:18,510
>> Și așa fix, am în cele din urmă
a realizat aici, este una dintre cele două lucruri.

345
00:17:18,510 --> 00:17:22,430
Aș putea spune foarte simplu
conta până la mai puțin de 10.

346
00:17:22,430 --> 00:17:27,260
Deci 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, care este, într-adevăr, corect,

347
00:17:27,260 --> 00:17:28,900
chiar dacă sună un pic greșit.

348
00:17:28,900 --> 00:17:35,070
Sau aș putea face mai mică sau egală
la 9, atâta timp cât am început de la 0 ° C.

349
00:17:35,070 --> 00:17:40,056
Sau, dacă într-adevăr nu-mi place asta,
poate conta până prin 10, dar încep de la 1.

350
00:17:40,056 --> 00:17:41,680
Dar, din nou, acest lucru pur și simplu nu este atât de comună.

351
00:17:41,680 --> 00:17:43,977
În programming-- deși
nu atât de mult în rămășițe

352
00:17:43,977 --> 00:17:45,810
dar în programarea în
C și alte limbi,

353
00:17:45,810 --> 00:17:47,670
cum ar fi JavaScript și
Python și altele, este

354
00:17:47,670 --> 00:17:49,880
doar foarte frecvente pentru
discuția noastră de binare

355
00:17:49,880 --> 00:17:53,450
pentru a începe numărarea doar la cele mai
cel mai mic număr posibil, care este 0.

356
00:17:53,450 --> 00:17:53,950
In regula.

357
00:17:53,950 --> 00:17:55,160
Deci asta e eprintf.

358
00:17:55,160 --> 00:17:58,600
Și din nou, acum că mi-am dat seama mea
problemă, și am de gând să mă întorc la 0

359
00:17:58,600 --> 00:18:01,470
prin mai puțin de 10, voi
pentru a merge și să ștergeți eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Nu trebuie să fie acolo când
navă codul meu sau să prezinte codul meu

361
00:18:04,580 --> 00:18:05,800
sau arata oricui altcineva.

362
00:18:05,800 --> 00:18:07,980
Este într-adevăr doar a însemnat
să fie utilizat temporar.

363
00:18:07,980 --> 00:18:11,650
Dar acum am stabilit acest lucru
problemă specială, de asemenea.

364
00:18:11,650 --> 00:18:16,780
>> Ei bine, să facem încă un exemplu aici
că am de gând să bici după cum urmează.

365
00:18:16,780 --> 00:18:22,850
Mă duc să merg mai departe și
#include . $ 50

366
00:18:22,850 --> 00:18:25,580
Si voi merge mai departe
și #include.

367
00:18:25,580 --> 00:18:29,030
>> Si voi salva
acest fișier ca buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Si voi merge mai departe
și să declare int main (void).

369
00:18:31,740 --> 00:18:34,186
Și apoi în interiorul acolo
Am de gând să fac int i _ -

370
00:18:34,186 --> 00:18:36,435
Vreau să pună în aplicare un program de
cu un get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Aceasta nu este o funcție care există încă.

373
00:18:40,770 --> 00:18:42,870
Așa că vom pune în aplicare
ea într-un moment.

374
00:18:42,870 --> 00:18:45,541
Dar, vom vedea de ce
este buggy la prima trecere.

375
00:18:45,541 --> 00:18:47,290
Și odată ce am ajuns
o int de utilizator,

376
00:18:47,290 --> 00:18:53,365
Am de gând doar pentru a imprima% i este un negativ
număr întreg, backslash, n, virgulă, i.

377
00:18:53,365 --> 00:18:55,240
Cu alte cuvinte, tot ce am
doresc acest program să facă

378
00:18:55,240 --> 00:18:58,000
se obține un int negativ
utilizatorul și apoi imprimați

379
00:18:58,000 --> 00:18:59,980
că cutare este un int negativ.

380
00:18:59,980 --> 00:19:02,080
>> Acum am nevoie pentru a pune în aplicare această funcție.

381
00:19:02,080 --> 00:19:05,740
Așa că mai târziu, în dosarul meu, am de gând să merg
înainte și să declare o funcție numită

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - și vom
vin înapoi la ceea ce înseamnă din nou acea linie

383
00:19:10,670 --> 00:19:18,790
într-un moment-- int n; do-- do
following-- printf n este :.

384
00:19:18,790 --> 00:19:26,210
Și apoi am de gând să fac n - get_int,
și de a face acest lucru în timp ce n este mai mare decât 0.

385
00:19:26,210 --> 00:19:28,310
Și apoi să se întoarcă n ;.

386
00:19:28,310 --> 00:19:31,730
>> Deci, există o mulțime întâmplă în
acest lucru, dar nici unul dintre care nu am făcut-o

387
00:19:31,730 --> 00:19:33,710
uita-te la săptămâna trecută, cel puțin pentru scurt timp.

388
00:19:33,710 --> 00:19:36,980
Deci, pe linia 10 aici am declarat
functie numita get_negative_int,

389
00:19:36,980 --> 00:19:39,620
și am pus (void), în
paranteze, motivul fiind această

390
00:19:39,620 --> 00:19:40,950
nu ia o intrare.

391
00:19:40,950 --> 00:19:42,910
N-am nimic care trece
la această funcție.

392
00:19:42,910 --> 00:19:44,690
Sunt doar obtinerea ceva înapoi de la ea.

393
00:19:44,690 --> 00:19:47,270
>> Și ce eu sunt în speranța de a
primi înapoi este un număr întreg.

394
00:19:47,270 --> 00:19:50,040
Nu există nici un tip de date în
C numit negative_int.

395
00:19:50,040 --> 00:19:52,880
Este pur și simplu int, asa ca va
să fie pe noi să ne asigurăm

396
00:19:52,880 --> 00:19:55,340
că valoarea care este de fapt
Returned nu este doar un int

397
00:19:55,340 --> 00:19:56,380
dar este, de asemenea, negativ.

398
00:19:56,380 --> 00:20:02,150
>> Pe linia 12 Declar o variabilă
numit n și făcându-l de tip int.

399
00:20:02,150 --> 00:20:07,500
Și apoi, în linia 13, prin 18 Sunt
face ceva în timp ce ceva este adevărat.

400
00:20:07,500 --> 00:20:11,040
Mă duc mai departe și de imprimare
n este, de colon, și apoi un spațiu,

401
00:20:11,040 --> 00:20:12,800
cum ar fi un prompt pentru utilizator.

402
00:20:12,800 --> 00:20:16,410
>> Sunt apoi sunat get_int și
stocarea valorii sale de întoarcere așa-numitele

403
00:20:16,410 --> 00:20:18,130
în acea variabilă n.

404
00:20:18,130 --> 00:20:22,600
Dar, voi continua să faci
acest lucru în timp ce n este mai mare decât 0.

405
00:20:22,600 --> 00:20:27,960
Cu alte cuvinte, în cazul în care utilizatorul mi-o dă
int și acest număr este mai mare decât 0,

406
00:20:27,960 --> 00:20:31,180
ergo, pozitiv, voi
doar ține reprompting utilizatorul,

407
00:20:31,180 --> 00:20:37,160
să păstreze reprompting, forțându-le să
cooperează și dă-mi un int negativ.

408
00:20:37,160 --> 00:20:41,640
>> Și odată ce n este de fapt negative--
să presupunem că utilizatorul în cele din urmă tipuri de -50,

409
00:20:41,640 --> 00:20:46,710
atunci această buclă în timp ce nu mai este valabil
deoarece -50 nu este mai mare decât 0.

410
00:20:46,710 --> 00:20:51,140
Asa ca am iesi din asta
buclă în mod logic și să se întoarcă n.

411
00:20:51,140 --> 00:20:53,520
>> Dar există o altă
lucru ce trebuie să fac.

412
00:20:53,520 --> 00:20:56,190
Și eu pot face acest lucru pur și simplu
prin copierea și lipirea

413
00:20:56,190 --> 00:20:58,540
o linie de cod în partea de sus a fișierului.

414
00:20:58,540 --> 00:21:01,630
Am nevoie pentru a preda zăngănit,
sau promisiunea de a zăngănit,

415
00:21:01,630 --> 00:21:04,630
în mod explicit că voi,
într-adevăr, du-te și să pună în aplicare

416
00:21:04,630 --> 00:21:06,020
această funcție get_negative_int.

417
00:21:06,020 --> 00:21:07,674
S-ar putea fi la fel de jos în fișierul.

418
00:21:07,674 --> 00:21:09,840
Din nou, reamintim că zăngănit
citeste lucrurile de sus în jos,

419
00:21:09,840 --> 00:21:12,330
la stânga la dreapta, așa că nu poți
apela o funcție în cazul în care zăngănit

420
00:21:12,330 --> 00:21:15,330
nu știe că va exista.

421
00:21:15,330 --> 00:21:18,430
>> Acum, din păcate, acest program,
ca unii dintre voi s-ar putea fi observat,

422
00:21:18,430 --> 00:21:19,590
este deja buggy.

423
00:21:19,590 --> 00:21:21,400
Lasă-mă să merg mai departe și să facă buggy3.

424
00:21:21,400 --> 00:21:26,904
Compilează, deci problema mea acum nu este
o eroare de sintaxă, cum ar fi o eroare textuală,

425
00:21:26,904 --> 00:21:29,570
este de fapt, va fi o logică
eroare pe care am intenționat

426
00:21:29,570 --> 00:21:32,450
a făcut ca o oportunitate de a
pas prin ceea ce se întâmplă.

427
00:21:32,450 --> 00:21:35,540
>> Mă duc să merg mai departe
acum și a alerga buggy3.

428
00:21:35,540 --> 00:21:37,490
Iar eu mă duc
înainte, și nu cooperează.

429
00:21:37,490 --> 00:21:39,494
Mă duc să-l dau numărul 1.

430
00:21:39,494 --> 00:21:41,410
Nu mi-a plăcut, așa
Mi-a determinat din nou.

431
00:21:41,410 --> 00:21:42,147
>> Ce zici de 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Nici unul dintre cei care lucrează.

435
00:21:44,740 --> 00:21:46,890
Ce zici de -50?

436
00:21:46,890 --> 00:21:48,560
Iar programul pare să funcționeze.

437
00:21:48,560 --> 00:21:49,970
>> Lasă-mă să-l încercați încă o dată.

438
00:21:49,970 --> 00:21:53,400
Lasă-mă să încerc -1, pare să funcționeze.

439
00:21:53,400 --> 00:21:56,380
Lasă-mă să încerc -2, pare să funcționeze.

440
00:21:56,380 --> 00:21:59,640
Lasă-mă să încerc 0.

441
00:21:59,640 --> 00:22:01,684
Nu-i asa, e incorect.

442
00:22:01,684 --> 00:22:03,350
Acum, suntem un pic pedant aici.

443
00:22:03,350 --> 00:22:07,090
Dar este, într-adevăr, cazul în care 0
nu este nici pozitiv, nici negativ.

444
00:22:07,090 --> 00:22:11,150
Și astfel, faptul că programul meu este
spunând că 0 este un număr întreg negativ,

445
00:22:11,150 --> 00:22:12,820
că nu e corect punct de vedere tehnic.

446
00:22:12,820 --> 00:22:15,180
>> Acum, de ce faci asta?

447
00:22:15,180 --> 00:22:16,270
Ei bine, s-ar putea să fie evident.

448
00:22:16,270 --> 00:22:18,110
Și, într-adevăr, programul este
menit să fie destul de simplu

449
00:22:18,110 --> 00:22:19,670
așa că avem ceva de a explora.

450
00:22:19,670 --> 00:22:25,870
>> Dar, să introducă oa treia depanare
Tehnica numită aici debug50.

451
00:22:25,870 --> 00:22:27,750
Deci, acesta este un program de
pe care tocmai l-am creat

452
00:22:27,750 --> 00:22:30,770
acest an numit debug50
pe care le va permite

453
00:22:30,770 --> 00:22:34,130
de a folosi ceea ce se numește un built-in
debugger grafic în IDE CS50.

454
00:22:34,130 --> 00:22:38,400
Și un depanator este doar un program care
în general, vă permite să rulați programul

455
00:22:38,400 --> 00:22:44,050
dar pas cu pas cu pas, linie
linie cu linie, oprindu-se, poking

456
00:22:44,050 --> 00:22:47,626
în jurul valorii, uita la variabile, astfel încât
programul nu doar sufla peste tine

457
00:22:47,626 --> 00:22:49,750
și imprima rapid ceva
sau nu imprimă ceva.

458
00:22:49,750 --> 00:22:53,250
Acesta vă oferă o oportunitate, la
viteza de om, pentru a interacționa cu ea.

459
00:22:53,250 --> 00:22:55,470
>> Și pentru a face acest lucru,
pur și simplu faceți următoarele.

460
00:22:55,470 --> 00:22:58,479
După compilarea codului,
pe care am făcut-o deja, buggy3,

461
00:22:58,479 --> 00:23:00,020
merge mai departe și a alerga debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Atât de mult ca help50 are executați
help50 și apoi comanda,

464
00:23:06,760 --> 00:23:10,120
debug50 are rulați debug50 și
atunci numele comenzii.

465
00:23:10,120 --> 00:23:14,440
>> Acum priviți ce se întâmplă pe ecran,
pe partea dreaptă, în special.

466
00:23:14,440 --> 00:23:19,400
Când m-am lovit alerga, tot
Panoul de bruscă această mână dreaptă

467
00:23:19,400 --> 00:23:20,419
se deschide pe ecran.

468
00:23:20,419 --> 00:23:22,210
Și există o mulțime întâmplă
pe la prima vedere.

469
00:23:22,210 --> 00:23:25,110
Dar nu e prea
mult să vă faceți griji încă.

470
00:23:25,110 --> 00:23:28,570
>> Acest lucru dă-mi totul
care se întâmplă în interiorul programului meu

471
00:23:28,570 --> 00:23:31,130
chiar acum și prin intermediul acestora
Butoanele sus de sus este apoi

472
00:23:31,130 --> 00:23:35,910
permițându-mi să pas prin codul meu
în cele din urmă pas cu pas cu pas.

473
00:23:35,910 --> 00:23:37,140
Dar, nu doar încă.

474
00:23:37,140 --> 00:23:38,060
Observați ce se întâmplă.

475
00:23:38,060 --> 00:23:40,600
La fereastra mea terminală
Mi se cere pentru n.

476
00:23:40,600 --> 00:23:44,560
Și mă duc să merg mai departe și
cooperează acest timp și tipul în -1.

477
00:23:44,560 --> 00:23:48,770
Și, deși puțin criptic, -1
este un număr întreg negativ, cum era de așteptat.

478
00:23:48,770 --> 00:23:52,020
>> Și apoi copilul a ieșit cu
starea 0 GDBserver care iese.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, este numele
a software-ului de bază

480
00:23:55,180 --> 00:23:56,620
care pune în aplicare această depanator.

481
00:23:56,620 --> 00:24:00,500
Dar toate acestea înseamnă că într-adevăr, debugger
a plecat pentru că programul meu renuntat

482
00:24:00,500 --> 00:24:01,710
și totul a fost bine.

483
00:24:01,710 --> 00:24:06,020
Dacă vreau să depana cu adevărat programul meu,
Trebuie să spun preemptively debug50,

484
00:24:06,020 --> 00:24:08,920
unde vreau să încep
pas cu pas prin codul meu?

485
00:24:08,920 --> 00:24:11,750
>> Și, probabil, cel mai simplu mod
pentru a face acest lucru este după cum urmează.

486
00:24:11,750 --> 00:24:15,300
Dacă aș fi plasați cursorul peste
jgheab de editorul meu aici,

487
00:24:15,300 --> 00:24:19,090
astfel încât într-adevăr doar în bara laterală aici,
la stânga numărului liniei,

488
00:24:19,090 --> 00:24:21,870
observați că, dacă am doar să faceți clic
o dată, am pus un punct roșu puțin.

489
00:24:21,870 --> 00:24:24,460
Si acel mic punct roșu,
ca un semn de oprire, înseamnă, hei,

490
00:24:24,460 --> 00:24:29,430
debug50, execuție pauză de codul meu
chiar acolo când am rula acest program.

491
00:24:29,430 --> 00:24:30,260
>> Așa că hai să facem asta.

492
00:24:30,260 --> 00:24:37,340
Lasă-mă să merg mai departe și a alerga programul meu
din nou cu debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Și acum, o notificare, ceva
altfel sa întâmplat.

494
00:24:40,110 --> 00:24:42,440
N-am fost întrebat în prealabil
totuși, în fereastra mea terminală

495
00:24:42,440 --> 00:24:45,430
pentru nimic, pentru că nu am
ajuns încă acolo în programul meu.

496
00:24:45,430 --> 00:24:47,950
Observați că pe linia 8
care este evidențiată,

497
00:24:47,950 --> 00:24:51,720
și există o mică săgeată la
spunând stânga, ești întrerupt aici.

498
00:24:51,720 --> 00:24:55,030
Această linie de cod, linie
8, nu a fost încă executată.

499
00:24:55,030 --> 00:24:58,940
>> Și ce e curios, dacă mă uit
aici pe partea dreaptă,

500
00:24:58,940 --> 00:25:03,530
Observați că este un localnic
variabilă, locală în sensul

501
00:25:03,530 --> 00:25:05,450
că este în interiorul funcției curente.

502
00:25:05,450 --> 00:25:08,920
Și valoarea ei, se pare că, în mod implicit,
și un fel de convenabil, este 0.

503
00:25:08,920 --> 00:25:10,260
Dar eu nu am de tip 0.

504
00:25:10,260 --> 00:25:13,410
Care tocmai se întâmplă să fie ei
Valoarea implicită în acest moment.

505
00:25:13,410 --> 00:25:15,490
>> Așa că lasă-mă să merg mai departe și fac asta acum.

506
00:25:15,490 --> 00:25:18,680
Lasă-mă să merg mai departe și
partea de sus chiar aici, sunt

507
00:25:18,680 --> 00:25:20,970
merge mai departe și
faceți clic pe această primă pictogramă care

508
00:25:20,970 --> 00:25:25,360
înseamnă pas peste ceea ce înseamnă că nu săriți
acest lucru, dar pas peste această linie de cod,

509
00:25:25,360 --> 00:25:27,770
executându-l de-a lungul drum.

510
00:25:27,770 --> 00:25:30,710
>> Și acum, observați, meu
promptă tocmai sa schimbat.

511
00:25:30,710 --> 00:25:31,380
De ce este asta?

512
00:25:31,380 --> 00:25:33,639
I-am spus debug50,
rula această linie de cod.

513
00:25:33,639 --> 00:25:34,930
Ce face această linie de cod nu?

514
00:25:34,930 --> 00:25:35,960
mă solicită pentru un int.

515
00:25:35,960 --> 00:25:36,460
O.K.

516
00:25:36,460 --> 00:25:37,400
Lasă-mă să coopereze.

517
00:25:37,400 --> 00:25:41,340
Lasă-mă să merg mai departe acum și tastați -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Și acum, observați ce sa schimbat.

519
00:25:42,920 --> 00:25:46,060
Pe partea dreaptă,
variabila mea locală i

520
00:25:46,060 --> 00:25:48,200
este indicat ca fiind -1 acum.

521
00:25:48,200 --> 00:25:49,810
Și este încă de tip int.

522
00:25:49,810 --> 00:25:53,102
>> Și observați, de asemenea, meu așa-numitele
stiva de apel, unde am pauză?

523
00:25:53,102 --> 00:25:54,810
Vom vorbi mai multe despre
acest lucru în viitor.

524
00:25:54,810 --> 00:25:58,620
Dar, stiva de apel pur și simplu se referă la ceea ce
funcții sunt în prezent în mișcare.

525
00:25:58,620 --> 00:26:00,040
Chiar acum e doar principal.

526
00:26:00,040 --> 00:26:03,590
Și chiar acum singurul locale
variabilă este i cu o valoare de 1.

527
00:26:03,590 --> 00:26:09,840
>> Și, în sfârșit, când am pas peste această linie
aici, cu aceeași pictogramă în dreapta sus,

528
00:26:09,840 --> 00:26:11,410
-1 Este un număr întreg negativ.

529
00:26:11,410 --> 00:26:13,580
Acum este oprindu-se peste asta acoladă.

530
00:26:13,580 --> 00:26:14,740
Hai să lăsați-o să facem treaba.

531
00:26:14,740 --> 00:26:17,300
Am pas peste acea linie, și voila.

532
00:26:17,300 --> 00:26:20,240
>> Deci, nu tot ce teribil
edificator încă,

533
00:26:20,240 --> 00:26:23,550
dar mi-a lăsat o pauză
și să se gândească logic prin

534
00:26:23,550 --> 00:26:24,870
ce acest program este de a face.

535
00:26:24,870 --> 00:26:26,890
Dar acest lucru nu a fost cazul eronată.

536
00:26:26,890 --> 00:26:28,510
Hai să facem asta din nou, după cum urmează.

537
00:26:28,510 --> 00:26:31,340
>> Am de gând să părăsească breakpoint
pe linia 8 cu punct roșu.

538
00:26:31,340 --> 00:26:32,830
Mă duc să rulați din nou debug50.

539
00:26:32,830 --> 00:26:34,400
Se opri automat aici.

540
00:26:34,400 --> 00:26:37,660
Dar, de data aceasta, în loc de
pas cu pas peste această linie,

541
00:26:37,660 --> 00:26:42,290
lasă-mă să merg de fapt, în interiorul
get_negative_int și dau seama,

542
00:26:42,290 --> 00:26:45,530
de ce este acceptarea 0 ca un răspuns valid?

543
00:26:45,530 --> 00:26:47,990
>> Deci, în loc de a da click Step Over.

544
00:26:47,990 --> 00:26:50,630
Mă duc să merg mai departe
și faceți clic pe Step Into.

545
00:26:50,630 --> 00:26:54,030
Și observați că linia 8 care este
acum evidențiate acum dintr-o dată

546
00:26:54,030 --> 00:26:56,900
devine linia 17.

547
00:26:56,900 --> 00:26:59,947
>> Acum, nu e ca debugger
a sărit peste liniile 14 și 15 și 16.

548
00:26:59,947 --> 00:27:01,780
Doar că nu e nimic
să-ți arăt acolo.

549
00:27:01,780 --> 00:27:04,050
Acestea sunt doar declarare variabile,
și apoi există cuvântul Do

550
00:27:04,050 --> 00:27:05,390
și apoi o acoladă deschisă.

551
00:27:05,390 --> 00:27:09,227
Singura linie funcțională care este
suculent într-adevăr este asta aici, 17.

552
00:27:09,227 --> 00:27:11,060
Și asta e în cazul în care ne-am
se opri în mod automat.

553
00:27:11,060 --> 00:27:13,870
>> Așa că printf ( "n.is:") ;, asa
care încă nu sa întâmplat.

554
00:27:13,870 --> 00:27:18,250
Așa că hai să mergem mai departe și faceți clic pe Step Over.

555
00:27:18,250 --> 00:27:20,326
Acum prompte mea, într-adevăr,
schimbat la ( "n este:").

556
00:27:20,326 --> 00:27:22,450
Acum get_int, nu plec
să deranjez pas cu pas în,

557
00:27:22,450 --> 00:27:24,750
pentru că această funcție a fost
realizat de CS50 în bibliotecă.

558
00:27:24,750 --> 00:27:25,750
Este probabil corect.

559
00:27:25,750 --> 00:27:28,440
>> Așa că am de gând să merg mai departe și
un fel de coopera dându-

560
00:27:28,440 --> 00:27:30,590
un int, dar nu o int negativ.

561
00:27:30,590 --> 00:27:32,870
Așa că lasă-mă să merg mai departe și a lovit 0.

562
00:27:32,870 --> 00:27:39,460
Și acum ce se întâmplă aici
când voi ajunge la linia de 21?

563
00:27:39,460 --> 00:27:40,890
Nu am iterat din nou.

564
00:27:40,890 --> 00:27:43,320
Eu nu par să fie blocat în această buclă.

565
00:27:43,320 --> 00:27:45,990
Cu alte cuvinte, acest galben
bare nu a ținut merge în jurul valorii,

566
00:27:45,990 --> 00:27:47,130
și în jur, și în jur.

567
00:27:47,130 --> 00:27:48,340
>> Acum, de ce e asta?

568
00:27:48,340 --> 00:27:49,920
Ei bine, n, ceea ce este n chiar acum?

569
00:27:49,920 --> 00:27:53,280
Mă pot uita la nivel local
variabilele din debugger.

570
00:27:53,280 --> 00:27:53,816
n este 0.

571
00:27:53,816 --> 00:27:55,190
Bine, ce era starea mea?

572
00:27:55,190 --> 00:27:58,700
>> 20-- linia 20 este, de asemenea,
0 este mai mare decât 0.

573
00:27:58,700 --> 00:27:59,500
Nu este adevarat.

574
00:27:59,500 --> 00:28:01,020
0 nu este mai mare decât 0.

575
00:28:01,020 --> 00:28:02,820
Și așa mi-am rupt din asta.

576
00:28:02,820 --> 00:28:06,370
>> Și astfel, de aceea on-line
21, în cazul în care am de fapt continua,

577
00:28:06,370 --> 00:28:10,370
Mă duc să se întoarcă 0, chiar
deși ar fi trebuit sa respins 0

578
00:28:10,370 --> 00:28:12,484
ca nefiind de fapt negativ.

579
00:28:12,484 --> 00:28:14,650
Așa că acum, eu nu fac într-adevăr, chiar
pasă de debugger.

580
00:28:14,650 --> 00:28:16,900
Am înțeles, nu am nevoie să
mai stiu ce se întâmplă.

581
00:28:16,900 --> 00:28:19,233
>> Așa că am de gând să merg mai departe și
doar să faceți clic pe butonul de redare,

582
00:28:19,233 --> 00:28:20,240
și lăsați acest finisaj în sus.

583
00:28:20,240 --> 00:28:23,440
Acum, mi-am dat seama că mi
bug-ul este aparent pe linia 20.

584
00:28:23,440 --> 00:28:25,160
Asta e eroarea mea logică.

585
00:28:25,160 --> 00:28:28,100
>> Și ce vreau
pentru a face pentru a schimba acest lucru?

586
00:28:28,100 --> 00:28:32,500
În cazul în care problema este că eu nu sunt
prinderea 0, este doar o eroare de logică.

587
00:28:32,500 --> 00:28:35,910
Și eu pot spune în timp ce n este
mai mare sau egal cu 0,

588
00:28:35,910 --> 00:28:38,330
păstrează fapt care ia determinat din nou și din nou utilizatorul.

589
00:28:38,330 --> 00:28:41,050
>> Deci, din nou, greșeală simplu, probabil
chiar și evident atunci când m-ai văzut

590
00:28:41,050 --> 00:28:42,410
scrie-l în urmă cu doar câteva minute.

591
00:28:42,410 --> 00:28:44,570
Dar aici takeaway
este că, cu depanare 50,

592
00:28:44,570 --> 00:28:46,850
și cu depanare
software-ul mai general,

593
00:28:46,850 --> 00:28:51,370
aveți această putere nouă constatat
plimbare prin propriul cod, uita-te

594
00:28:51,370 --> 00:28:55,590
prin panoul cu mâna dreaptă ce
variabile valorile sunt.

595
00:28:55,590 --> 00:28:57,700
Deci, tu nu neapărat
trebuie să folosească ceva

596
00:28:57,700 --> 00:29:00,630
ca tine eprintf pentru a imprima aceste valori.

597
00:29:00,630 --> 00:29:04,430
Le puteti vedea de fapt,
vizual pe ecran.

598
00:29:04,430 --> 00:29:08,920
>> Acum, dincolo de aceasta, este demn de remarcat
că există o altă tehnică care este

599
00:29:08,920 --> 00:29:09,890
de fapt, super-comun.

600
00:29:09,890 --> 00:29:13,120
Si te va intrebati de ce acest mic
Tipul aici a fost așezat pe scenă.

601
00:29:13,120 --> 00:29:16,490
Deci, nu există această tehnică, în general,
cunoscut sub numele de cauciuc rață depanare,

602
00:29:16,490 --> 00:29:18,786
care într-adevăr este doar un
o dovadă a faptului

603
00:29:18,786 --> 00:29:20,660
că programatorii de multe ori atunci când
sunt scrierea de cod,

604
00:29:20,660 --> 00:29:22,650
ei nu sunt în mod necesar
colaborarea cu alte persoane,

605
00:29:22,650 --> 00:29:24,030
sau care lucrează într-un mediu partajat.

606
00:29:24,030 --> 00:29:25,050
>> Sunt un fel de acasă.

607
00:29:25,050 --> 00:29:25,910
Poate că e noaptea târziu.

608
00:29:25,910 --> 00:29:28,190
Ei încearcă să descifreze
unele bug în codul lor.

609
00:29:28,190 --> 00:29:29,330
Si ei doar nu-l văd.

610
00:29:29,330 --> 00:29:30,329
>> Și nu există nici un coleg de cameră.

611
00:29:30,329 --> 00:29:31,250
Nu există nici un TF.

612
00:29:31,250 --> 00:29:32,680
Nu există nici o CA jur.

613
00:29:32,680 --> 00:29:36,440
Tot ce au pe raft lor
este acest rățușcă mic.

614
00:29:36,440 --> 00:29:39,030
>> Și așa depanare rață de cauciuc
este doar această invitație

615
00:29:39,030 --> 00:29:42,780
să se gândească la ceva la fel de prostie
ca acest lucru ca o creatură reală,

616
00:29:42,780 --> 00:29:46,940
și de fapt, merge prin codul
verbal la acest obiect neînsuflețit.

617
00:29:46,940 --> 00:29:49,230
Astfel, de exemplu, în cazul în care
acesta este exemplul meu aici--

618
00:29:49,230 --> 00:29:52,470
și reamintească faptul că mai devreme
problema a fost aceasta,

619
00:29:52,470 --> 00:29:58,140
dacă ștergeți această primă linie de cod,
și mă duc mai departe și fac buggy 0 din nou,

620
00:29:58,140 --> 00:30:01,220
amintesc că am avut aceste
mesaje de eroare aici.

621
00:30:01,220 --> 00:30:05,997
Deci, ideea de aici, deși am ridicol
se simt în acest moment face acest lucru în mod public,

622
00:30:05,997 --> 00:30:06,580
este acea eroare.

623
00:30:06,580 --> 00:30:10,910
>> OK, deci problema mea este că am
a declarat, implicit, o funcție de bibliotecă.

624
00:30:10,910 --> 00:30:12,610
Și că funcția de bibliotecă este printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, declara
îmi amintește de prototipuri.

626
00:30:15,290 --> 00:30:18,930
>> Asta înseamnă că am nevoie să de fapt
spune-compilator dinainte ce

627
00:30:18,930 --> 00:30:19,980
funcția arată.

628
00:30:19,980 --> 00:30:20,930
Așteptaţi un minut.

629
00:30:20,930 --> 00:30:23,580
Nu am avut io.h. standard de

630
00:30:23,580 --> 00:30:24,530
Mulțumesc foarte mult.

631
00:30:24,530 --> 00:30:27,330
>> Deci, doar acest proces de-- vă
nu este nevoie să aibă de fapt o rață.

632
00:30:27,330 --> 00:30:29,819
Dar această idee de mers pe jos
te prin propriul cod

633
00:30:29,819 --> 00:30:31,610
astfel încât să auzi chiar
le astfel încât să

634
00:30:31,610 --> 00:30:35,620
realizeze omisiuni în propria
observații, este, în general ideea.

635
00:30:35,620 --> 00:30:38,910
>> Si, poate mai logic, nu atât
mult cu una, dar implica mai mult

636
00:30:38,910 --> 00:30:44,220
de exemplu, tocmai am făcut-o în 3.c buggy,
s-ar putea te plimbi prin ea

637
00:30:44,220 --> 00:30:45,310
după cum urmează.

638
00:30:45,310 --> 00:30:49,190
Deci, toate dreapta, cauciuc
Ducky, DDB, dacă vreți.

639
00:30:49,190 --> 00:30:52,350
Aici avem în funcția mea principală,
O sun primi int negativ.

640
00:30:52,350 --> 00:30:54,660
>> Si eu sunt obtinerea de valoarea de returnare.

641
00:30:54,660 --> 00:31:00,410
Sunt o depozitați pe partea stângă
pe linia 8 într-o variabilă numită i.

642
00:31:00,410 --> 00:31:02,380
OK, dar așteptați, cum a făcut
care obține această valoare?

643
00:31:02,380 --> 00:31:04,130
Lasă-mă să mă uit la funcția în linia 12.

644
00:31:04,130 --> 00:31:05,760
>> În linia 12, avem de a lua int negativ.

645
00:31:05,760 --> 00:31:08,190
Nu ia nici o intrare,
se întoarce int, OK.

646
00:31:08,190 --> 00:31:10,929
Declar pe linia 14 a n variabile.

647
00:31:10,929 --> 00:31:12,220
Se va stoca un număr întreg.

648
00:31:12,220 --> 00:31:13,760
Asta vreau.

649
00:31:13,760 --> 00:31:18,480
>> Deci următoarele în timp ce n este-- lasa
mi-a anula ce fix am deja făcut.

650
00:31:18,480 --> 00:31:22,710
Deci, în timp ce n este mai mare decât
0, imprima n este, OK.

651
00:31:22,710 --> 00:31:25,170
Apel și apoi se int stocat în n.

652
00:31:25,170 --> 00:31:30,160
Și apoi verificați dacă n este 0,
n este not-- acolo este.

653
00:31:30,160 --> 00:31:31,910
Deci, din nou, tu nu faci
au nevoie de rață reală.

654
00:31:31,910 --> 00:31:35,650
Dar, pur și simplu de mers pe jos prin tine
codul ca un exercițiu intelectual

655
00:31:35,650 --> 00:31:37,720
vă va ajuta de multe ori
dau seama ce se întâmplă,

656
00:31:37,720 --> 00:31:41,170
, spre deosebire de a face doar ceva
ca aceasta, cu ochii la ecran,

657
00:31:41,170 --> 00:31:43,720
și nu te vorbind prin
ea, care sincer nu este

658
00:31:43,720 --> 00:31:46,270
aproape ca o tehnica eficienta.

659
00:31:46,270 --> 00:31:48,620
Deci nu aveți ea, o
Numărul de diferite tehnici

660
00:31:48,620 --> 00:31:52,102
pentru depanarea de fapt codul
și mustrare, toate acestea

661
00:31:52,102 --> 00:31:54,810
ar trebui să fie instrumente în Toolkit dumneavoastră
astfel încât să nu te noaptea târziu,

662
00:31:54,810 --> 00:31:57,660
mai ales, tu ești în sala de mese
hale, sau la orele de birou,

663
00:31:57,660 --> 00:32:00,368
trage cu capul de
de perete, încercând să rezolve unele probleme.

664
00:32:00,368 --> 00:32:02,020
Dau seama că există instrumente de software.

665
00:32:02,020 --> 00:32:03,720
Există instrumente de rață de cauciuc.

666
00:32:03,720 --> 00:32:09,630
Și există un întreg personal de
să sprijine în așteptare pentru a da o mână.

667
00:32:09,630 --> 00:32:13,120
>> Deci, acum, un cuvânt cu privire la problema
seturi, și ceea ce suntem în speranța de tine

668
00:32:13,120 --> 00:32:15,620
ieși afară din ele, și modul în care
vom merge cu privire la evaluarea.

669
00:32:15,620 --> 00:32:17,680
Per Programa cursului,
seturi problemă CS50 lui

670
00:32:17,680 --> 00:32:22,320
sunt evaluate pe patru axe principale, așa
la speak-- domeniul de aplicare, corectitudine, proiectare,

671
00:32:22,320 --> 00:32:23,060
și stil.

672
00:32:23,060 --> 00:32:25,910
Și domeniul de aplicare doar se referă la cât de mult
a piesei ai muscat?

673
00:32:25,910 --> 00:32:28,080
Cât de mult de o problemă ați încercat?

674
00:32:28,080 --> 00:32:30,110
Ce nivel de efort
te-ai manifestat?

675
00:32:30,110 --> 00:32:35,750
>> Corectitudinea este, face munca de program ca
se presupune că pentru fiecare specificație CS50

676
00:32:35,750 --> 00:32:38,640
atunci când furnizați anumite intrări
sau anumite ieșiri vin înapoi?

677
00:32:38,640 --> 00:32:41,130
Design-ul este cel mai subiectiv dintre ele.

678
00:32:41,130 --> 00:32:43,360
Și este cel care va
ia cea mai lungă pentru a învăța

679
00:32:43,360 --> 00:32:47,220
și cea mai lungă pentru a preda, în
măsura în care se reduce la,

680
00:32:47,220 --> 00:32:49,530
cât de bine scris este codul?

681
00:32:49,530 --> 00:32:52,920
>> Este un lucru pentru a imprima doar corectă
ieșiri sau a reveni la valorile corecte.

682
00:32:52,920 --> 00:32:55,400
Dar o faci ca
mai eficient posibil?

683
00:32:55,400 --> 00:32:58,210
O faci diviza
și cuceri, sau binar

684
00:32:58,210 --> 00:33:01,500
căutare după cum vom vedea în curând că am făcut-o
în urmă cu două săptămâni, cu cartea de telefon?

685
00:33:01,500 --> 00:33:04,670
Există modalități mai bune de a rezolva
problemă decât în ​​prezent aici?

686
00:33:04,670 --> 00:33:06,380
Aceasta este o oportunitate pentru un design mai bun.

687
00:33:06,380 --> 00:33:08,530
>> Și apoi style-- cum
destul este codul?

688
00:33:08,530 --> 00:33:12,370
Vei observa că sunt destul de
special despre crestarea codul meu,

689
00:33:12,370 --> 00:33:15,300
și asigurându-vă că variabilele mele
sunt numite în mod rezonabil. n,

690
00:33:15,300 --> 00:33:19,660
în timp scurt, este un nume bun pentru un
număr, i pentru un număr întreg de numărare,

691
00:33:19,660 --> 00:33:20,727
pentru un șir de caractere.

692
00:33:20,727 --> 00:33:22,560
Si putem avea mai mult
stil de nume de variabile.

693
00:33:22,560 --> 00:33:25,500
Stilul este doar cât de bun
arata codul?

694
00:33:25,500 --> 00:33:26,600
Si cum poate fi citit este?

695
00:33:26,600 --> 00:33:29,650
>> Și-a lungul timpului, ceea ce TAs dvs.
și TFS va face în cursul

696
00:33:29,650 --> 00:33:31,870
este vă oferi cu
un fel de feedback calitativ

697
00:33:31,870 --> 00:33:34,330
astfel încât să obțineți mai bine
la aceste aspecte diferite.

698
00:33:34,330 --> 00:33:37,510
Iar în ceea ce privește modul în care ne-am
evalua fiecare dintre aceste axe,

699
00:33:37,510 --> 00:33:40,080
este de obicei, cu foarte puține
găleți, astfel încât tu, în general,

700
00:33:40,080 --> 00:33:41,680
obține un sentiment de cat de bine faci.

701
00:33:41,680 --> 00:33:45,680
Și, într-adevăr, în cazul în care primiți un scor pe
oricare dintre aceste axes-- corectitudine, design

702
00:33:45,680 --> 00:33:49,659
și stilul especially-- numărul respectiv
va fi, în general, între 1 și 5.

703
00:33:49,659 --> 00:33:52,450
Si, literalmente, dacă sunteți obtinerea
3, la începutul semestrului,

704
00:33:52,450 --> 00:33:53,977
acest lucru este un lucru foarte bun.

705
00:33:53,977 --> 00:33:55,810
Aceasta înseamnă că încă
loc pentru imbunatatiri,

706
00:33:55,810 --> 00:33:58,490
pe care le-ar spera în
luând o clasă pentru prima dată.

707
00:33:58,490 --> 00:34:01,820
Există unele sperăm pic de plafon
la care te aspiră la atingerea.

708
00:34:01,820 --> 00:34:03,970
Si astfel obtinerea 3 pe
primele piese,

709
00:34:03,970 --> 00:34:06,550
dacă nu vreo 2 și 4, a
este, într-adevăr, un lucru bun.

710
00:34:06,550 --> 00:34:08,880
Este bine în raza de acțiune,
bine în așteptări.

711
00:34:08,880 --> 00:34:11,421
>> Iar dacă mintea ta este de curse, așteptați
un minut, trei din cinci.

712
00:34:11,421 --> 00:34:12,620
Asta e într-adevăr un 6 din 10.

713
00:34:12,620 --> 00:34:13,560
Asta e 60%.

714
00:34:13,560 --> 00:34:14,830
Dumnezeul meu, e un F.

715
00:34:14,830 --> 00:34:15,870
>> Nu este.

716
00:34:15,870 --> 00:34:17,600
Nu e, de fapt, asta.

717
00:34:17,600 --> 00:34:22,710
Mai degrabă, este o oportunitate de a îmbunătăți
pe parcursul semestrului.

718
00:34:22,710 --> 00:34:25,580
Iar dacă primiți niște
Poors, acestea sunt o oportunitate

719
00:34:25,580 --> 00:34:29,199
pentru a profita de ore de birou,
cu siguranță secțiuni și alte resurse.

720
00:34:29,199 --> 00:34:32,840
>> Cel mai bun este o oportunitate, într-adevăr,
să fie mândri de cât de departe ai

721
00:34:32,840 --> 00:34:34,520
vin pe parcursul semestrului.

722
00:34:34,520 --> 00:34:38,199
Așa că ne dăm seama, dacă nimic
altfel, trei este bun.

723
00:34:38,199 --> 00:34:40,179
Și permite o cameră pentru o creștere a lungul timpului.

724
00:34:40,179 --> 00:34:43,090
>> În ceea ce privește modul în care aceste axe sunt
ponderată, în mod realist tu ești

725
00:34:43,090 --> 00:34:46,745
O să-și petreacă cel mai mult timp obtinerea
lucrurile să meargă, să nu mai vorbim corect.

726
00:34:46,745 --> 00:34:49,120
Si deci corectitudinea tinde să
ponderate cel mai mult, la fel ca

727
00:34:49,120 --> 00:34:51,360
acest factor multiplicativ de trei.

728
00:34:51,360 --> 00:34:54,659
Design-ul este de asemenea important, dar
ceva ce nu neapărat

729
00:34:54,659 --> 00:34:58,220
cheltui toate aceste ore
încercarea de a obține lucrurile doar pentru a lucra.

730
00:34:58,220 --> 00:35:00,019
>> Și așa este ponderat
un pic mai ușor.

731
00:35:00,019 --> 00:35:01,560
Și apoi stilul este ponderat cel mai puțin.

732
00:35:01,560 --> 00:35:03,710
Chiar dacă nu mai e
importantă în mod fundamental,

733
00:35:03,710 --> 00:35:05,990
este doar, poate,
Cel mai simplu lucru de făcut dreapta,

734
00:35:05,990 --> 00:35:08,440
mimarea exemplele pe care le
face în curs și secțiunea,

735
00:35:08,440 --> 00:35:11,080
cu lucruri, frumos
alin, și a comentat,

736
00:35:11,080 --> 00:35:14,320
și așa mai departe este printre cele mai usoare
lucruri de făcut și de a obține dreapta.

737
00:35:14,320 --> 00:35:16,960
Deci, ca atare, își dau seama
că toate acestea sunt punctele

738
00:35:16,960 --> 00:35:19,000
care sunt relativ ușor de înțeles.

739
00:35:19,000 --> 00:35:22,360
>> Și acum un cuvânt pe
astea-- onestitatea academică.

740
00:35:22,360 --> 00:35:25,150
Așa că pentru fiecare cursului
programa, veți vedea

741
00:35:25,150 --> 00:35:27,630
că cursul are destul
bit de limbaj în jurul valorii de acest lucru.

742
00:35:27,630 --> 00:35:31,380
Iar cursul ia problema
onestitate academică destul de serios.

743
00:35:31,380 --> 00:35:33,450
>> Avem distincția,
la bine și la rău,

744
00:35:33,450 --> 00:35:36,570
de a fi trimis în fiecare an, mai mult
studenți pentru măsuri disciplinare

745
00:35:36,570 --> 00:35:39,670
decât majoritatea orice alt
Desigur, că eu sunt conștient.

746
00:35:39,670 --> 00:35:42,580
Acest lucru nu este neapărat
indică faptul

747
00:35:42,580 --> 00:35:46,340
că studenții CS, sau studenți CS50, sunt
mai puțin onest decât colegii tăi.

748
00:35:46,340 --> 00:35:49,090
Dar realitatea că, în această
mondială, în format electronic, ne-am

749
00:35:49,090 --> 00:35:50,990
au tehnologic
mijloace de detectare a prezentei.

750
00:35:50,990 --> 00:35:53,360
>> Este important pentru noi pentru
corectitudine în întreaga clasă

751
00:35:53,360 --> 00:35:58,550
că noi facem detecta acest lucru, și să ridice
problema atunci când vom vedea lucrurile.

752
00:35:58,550 --> 00:36:01,980
Si doar pentru a picta o imagine, și într-adevăr
pentru a ajuta la ceva de genul asta chiuveta,

753
00:36:01,980 --> 00:36:04,600
acestea sunt numerele
elevii de-a lungul ultimilor 10 de ani

754
00:36:04,600 --> 00:36:07,610
care au fost implicați într-o
astfel de probleme de onestitate academice,

755
00:36:07,610 --> 00:36:10,990
cu aproximativ 32 de studenți
din toamna 2015, care

756
00:36:10,990 --> 00:36:13,760
este să spunem că noi nu iau
problema foarte serios.

757
00:36:13,760 --> 00:36:18,380
Și, în cele din urmă, aceste numere compun,
cel mai recent, aproximativ 3%, 4% sau cam asa

758
00:36:18,380 --> 00:36:19,120
clasei.

759
00:36:19,120 --> 00:36:25,220
>> Deci, pentru majoritatea super-a studenților
se pare că liniile sunt clare.

760
00:36:25,220 --> 00:36:27,940
Dar, nu păstrați acest lucru în
minte, mai ales cu întârziere

761
00:36:27,940 --> 00:36:32,080
în timpul nopții, când se luptă cu
unele soluție la un set de probleme,

762
00:36:32,080 --> 00:36:34,830
că există mecanisme
pentru a obține o mai bună-te

763
00:36:34,830 --> 00:36:37,870
sprijin decât s-ar putea
cred că, chiar și la acea oră.

764
00:36:37,870 --> 00:36:40,514
Dau seama că atunci când primim
depuneri de student, traversăm

765
00:36:40,514 --> 00:36:43,430
compara fiecare depunere in acest an
față de fiecare depunere de anul trecut,

766
00:36:43,430 --> 00:36:47,590
împotriva fiecărui supunere din 2007,
și din moment ce, se uită la, precum și,

767
00:36:47,590 --> 00:36:49,931
cod repertoarele on-line,
forumuri de discuții, site-uri de locuri de muncă.

768
00:36:49,931 --> 00:36:51,806
Si amintim acest lucru,
într-adevăr, toate de dragul

769
00:36:51,806 --> 00:36:56,040
de dezvăluirea completă, că dacă
altcineva poate găsi on-line,

770
00:36:56,040 --> 00:36:57,880
cu siguranță, așa că putem curs.

771
00:36:57,880 --> 00:37:00,100
Dar, într-adevăr, spiritul
a cursului se reduce

772
00:37:00,100 --> 00:37:01,650
la această clauză în programa.

773
00:37:01,650 --> 00:37:03,670
Este într-adevăr este doar, să fie rezonabil.

774
00:37:03,670 --> 00:37:06,680
>> Și, dacă a trebuit să elaboreze pe acel
cu doar un limbaj pic mai mult,

775
00:37:06,680 --> 00:37:09,770
dau seama că esența tuturor
munca pe care le trimiteți la acest curs

776
00:37:09,770 --> 00:37:10,954
trebuie să fie propriul tău.

777
00:37:10,954 --> 00:37:13,870
Dar, în termen de faptul că, există cu siguranță
oportunități și încurajare,

778
00:37:13,870 --> 00:37:17,300
și valoarea pedagogică întorcându-se la
mă others--, TFS, AC,

779
00:37:17,300 --> 00:37:20,760
a Tas, precum și altele în clasă,
pentru sprijin, lasa prietenii singuri

780
00:37:20,760 --> 00:37:23,547
și colegi de cameră, care au studiat
CS și programare înainte de a.

781
00:37:23,547 --> 00:37:25,130
Și, deci există o alocație pentru asta.

782
00:37:25,130 --> 00:37:28,180
Iar regula generală de degetul mare
este astea-- atunci când a cere ajutor,

783
00:37:28,180 --> 00:37:31,470
vă poate afișa codul altora,
dar nu ale lor pot vizualiza.

784
00:37:31,470 --> 00:37:34,880
Deci, chiar dacă sunteți la orele de birou,
sau în sala D, sau în altă parte

785
00:37:34,880 --> 00:37:37,450
de lucru pe un anumit set bucată,
lucrând alături de un prieten, care

786
00:37:37,450 --> 00:37:40,160
este total bine, la
sfârșitul zilei munca

787
00:37:40,160 --> 00:37:43,034
în cele din urmă ar trebui să aparțină fiecărui
dintre voi, respectiv, și nu

788
00:37:43,034 --> 00:37:45,700
să fie un efort de colaborare,
cu excepția proiectul final în cazul în care

789
00:37:45,700 --> 00:37:47,410
este permis și încurajat.

790
00:37:47,410 --> 00:37:49,830
>> Dau seama că, dacă sunteți
se luptă cu ceva

791
00:37:49,830 --> 00:37:52,520
și prietenul tău doar se întâmplă
pentru a fi mai bine la acest lucru, atunci voi,

792
00:37:52,520 --> 00:37:55,130
sau mai bine la această problemă decât tine,
sau un pic mai departe în față decât tine,

793
00:37:55,130 --> 00:37:57,330
este absolut rezonabil să se transforme
la prietenul tău și spune, hei,

794
00:37:57,330 --> 00:38:00,480
te superi uita la codul meu aici,
m-ai ajutat la fața locului care este problema mea?

795
00:38:00,480 --> 00:38:03,760
Și, sperăm, în
interes de valoare pedagogică

796
00:38:03,760 --> 00:38:07,040
că prietenul nu doar
spun, oh, face acest lucru, ci mai degrabă,

797
00:38:07,040 --> 00:38:09,917
ce lipsesc on-line
6, sau ceva de genul asta?

798
00:38:09,917 --> 00:38:12,000
Dar soluția nu este
pentru prieten lângă tine

799
00:38:12,000 --> 00:38:15,617
să spunem, oh, bine, aici, lasă-mă să trag
acest lucru în sus, și arată soluția mea pentru tine.

800
00:38:15,617 --> 00:38:16,450
Deci, aceasta este linia.

801
00:38:16,450 --> 00:38:18,670
Vă arată codul de la
alții, dar nu pot

802
00:38:18,670 --> 00:38:22,350
vezi al lor, sub rezerva celuilalt
constrângeri în programa cursului.

803
00:38:22,350 --> 00:38:24,760
>> Așa că nu ține cont de acest lucru
așa-numita clauză de regret

804
00:38:24,760 --> 00:38:27,560
în programa cursului, precum și,
că, dacă ai comite vreun act

805
00:38:27,560 --> 00:38:30,476
nu este rezonabil, dar aduce la
atenția capetelor cursului

806
00:38:30,476 --> 00:38:34,240
în termen de 72 de ore, cursul
poate impune sancțiuni locale

807
00:38:34,240 --> 00:38:37,380
poate include o nesatisfăcătoare sau
grad în caz contrar pentru munca depusă.

808
00:38:37,380 --> 00:38:41,410
Dar, desigur, nu va deferi
contează pentru măsuri disciplinare suplimentare,

809
00:38:41,410 --> 00:38:43,010
cu excepția cazurilor de acte repetate.

810
00:38:43,010 --> 00:38:46,632
Cu alte cuvinte, dacă nu face unele
prost, mai ales noaptea târziu, decizia

811
00:38:46,632 --> 00:38:49,340
că dimineața următoare sau două zile
mai târziu, te trezești și realizezi,

812
00:38:49,340 --> 00:38:50,870
ce mă gândeam?

813
00:38:50,870 --> 00:38:53,890
Ai face in CS50 au un orificiu de evacuare
pentru fixarea acestei probleme

814
00:38:53,890 --> 00:38:57,170
și care deține până la ea, astfel încât să ne
vei întâlni la jumătatea drumului și de a face

815
00:38:57,170 --> 00:39:01,500
cu ea într-o chestiune care este în același timp
educaționale și valoroase pentru tine,

816
00:39:01,500 --> 00:39:04,200
dar încă punitive în vreun fel.

817
00:39:04,200 --> 00:39:08,590
Și acum, să ia marginea off, acest lucru.

818
00:39:08,590 --> 00:39:10,570
>> [REDARE VIDEO]

819
00:39:10,570 --> 00:39:13,540
>> [MUZICĂ]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END REDARE]

822
00:39:58,866 --> 00:40:00,490
David J. MALAN: Bine, ne-am întors.

823
00:40:00,490 --> 00:40:03,680
Și acum ne uităm la una dintre cele mai
Primul dintre domeniile noastre din lumea reală

824
00:40:03,680 --> 00:40:08,720
în CS50, arta criptografiei,
arta de a trimiterea și primirea

825
00:40:08,720 --> 00:40:11,840
mesaje secrete, criptate
mesaje dacă va fi,

826
00:40:11,840 --> 00:40:17,060
care poate fi descifrat numai dacă aveți
unele ingredient cheie pe care expeditorul are

827
00:40:17,060 --> 00:40:18,030
de asemenea.

828
00:40:18,030 --> 00:40:22,120
Deci, pentru a motiva acest lucru vom lua
o privire la acest lucru aici,

829
00:40:22,120 --> 00:40:26,750
care este un exemplu de
inel decodor secret faptul că

830
00:40:26,750 --> 00:40:34,042
pot fi folosite pentru a da seama
ce un mesaj secret este de fapt.

831
00:40:34,042 --> 00:40:35,750
De fapt, înapoi în
zi în școală de grad,

832
00:40:35,750 --> 00:40:38,787
dacă ați trimis vreodată mesaje secrete
unele prieten sau unele zdrobi în clasă,

833
00:40:38,787 --> 00:40:40,620
s-ar putea fi crezut
ai fost inteligent

834
00:40:40,620 --> 00:40:46,530
de pe piesa ta de schimbare a hârtiei,
cum ar fi, de la A la B și B la C și C la D,

835
00:40:46,530 --> 00:40:47,590
si asa mai departe.

836
00:40:47,590 --> 00:40:50,300
Dar ați fost de fapt, criptarea
informațiile, chiar

837
00:40:50,300 --> 00:40:53,300
dacă era un pic banal, nu a fost
greu pentru ca profesorul să realizeze,

838
00:40:53,300 --> 00:40:55,675
bine, dacă pur și simplu schimbați
B la A și C la B,

839
00:40:55,675 --> 00:40:57,550
de fapt, tu dai seama
ce mesajul a fost,

840
00:40:57,550 --> 00:40:59,700
dar ai fost în cifrare informații.

841
00:40:59,700 --> 00:41:03,420
>> Ai fost doar o faci
pur și simplu, la fel ca Ralphie aici

842
00:41:03,420 --> 00:41:07,934
într-un film celebru care joacă
destul de mult în fiecare iarnă de anunțuri nauseum.

843
00:41:07,934 --> 00:41:08,600
[REDARE VIDEO]

844
00:41:08,600 --> 00:41:11,180
-Fi Cunoscut tuturor faptul că
Ralph Parker este prin prezenta

845
00:41:11,180 --> 00:41:14,070
a numit un membru al Micii
Orfane Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
și are dreptul la toate onorurile
și beneficiile care apar la acestea.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little orfane Annie,
-Trasemnate Pierre Andre, cu cerneală.

848
00:41:24,340 --> 00:41:27,160
Onoruri și beneficii,
deja la vârsta de nouă ani.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Strigând]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Haide.

853
00:41:34,250 --> 00:41:35,210
Hai să mergem mai departe cu ea.

854
00:41:35,210 --> 00:41:39,530
Nu am nevoie de tot jazz
despre contrabandiști și pirați.

855
00:41:39,530 --> 00:41:41,660
>> mâine seară pentru Ascultă
aventura de încheiere

856
00:41:41,660 --> 00:41:43,880
a navei pirat negru.

857
00:41:43,880 --> 00:41:46,650
Acum, este timpul pentru
mesaj secret Annie

858
00:41:46,650 --> 00:41:49,840
pentru voi, membri ai Cercului Secret.

859
00:41:49,840 --> 00:41:53,570
Amintiți-vă, copii, numai membrii
Annie Secret Circle

860
00:41:53,570 --> 00:41:56,140
poate decoda mesaj secret lui Annie.

861
00:41:56,140 --> 00:42:00,340
>> Nu uitați, Annie depinde de tine.

862
00:42:00,340 --> 00:42:02,880
Setați pinii dvs. la B2.

863
00:42:02,880 --> 00:42:05,230
Aici este mesajul.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -I Sunt în prima mea întâlnire secretă.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre A fost în mare în seara asta de voce.

868
00:42:15,780 --> 00:42:19,000
Aș putea spune că seară
Mesajul a fost foarte important.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, e un mesaj
de la Annie însăși.

870
00:42:22,694 --> 00:42:23,860
Amintiți-vă, nu spune nimănui.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Secunde mai târziu, eu sunt în singurul
cameră din casa unde un băiat de nouă

873
00:42:32,930 --> 00:42:37,040
ar putea sta în intimitate și decoda.

874
00:42:37,040 --> 00:42:39,730
Ha! B!

875
00:42:39,730 --> 00:42:42,360
M-am dus la următorul, E.

876
00:42:42,360 --> 00:42:44,520
>> Primul cuvânt este să fie.

877
00:42:44,520 --> 00:42:49,032
S, venea mai ușor acum, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -Oh, Haide, Ralphie, trebuie să plec!

879
00:42:51,733 --> 00:42:53,688
>> -Voi Fi dreapta jos, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee bâzâit!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, asigurați-vă că sa-- fi sigur de ce?

883
00:43:04,060 --> 00:43:05,970
Ce a fost Micul orfane
Annie încearcă să spună?

884
00:43:05,970 --> 00:43:07,264
Asigurați-vă că la ce?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy a reușit să
du-te, te rog ieși?

886
00:43:09,634 --> 00:43:10,480
>> dreapta -all, Ma!

887
00:43:10,480 --> 00:43:12,880
Voi ieși bine!

888
00:43:12,880 --> 00:43:14,550
>> -Am Fost apropie acum.

889
00:43:14,550 --> 00:43:16,620
Tensiunea a fost teribil.

890
00:43:16,620 --> 00:43:17,720
Ce-a fost asta?

891
00:43:17,720 --> 00:43:20,170
Soarta planetei
poate atârna în balanță.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Trebuie să Andy du-te!

894
00:43:23,170 --> 00:43:26,890
>> -Voi Fi chiar afară, pentru Dumnezeu!

895
00:43:26,890 --> 00:43:32,680
>> -Aproape Acolo, degetele mele au zburat, mintea mea
a fost o capcană de oțel, fiecare por vibrat.

896
00:43:32,680 --> 00:43:37,198
Era aproape limpede, da, da, da.

897
00:43:37,198 --> 00:43:43,091
>> -Fi Sigur de a bea Ovaltine ta.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
O reclamă crummy?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Fecior de curva.

903
00:43:54,227 --> 00:43:54,810
[END REDARE]

904
00:43:54,810 --> 00:43:57,390
David J. MALAN: OK, deci
care a fost un mod foarte lung

905
00:43:57,390 --> 00:44:00,660
de introducere a criptografie,
și, de asemenea, Ovaltine.

906
00:44:00,660 --> 00:44:04,470
De fapt, din acest anunț vechi
aici, de ce este Ovaltine atât de bine?

907
00:44:04,470 --> 00:44:09,470
Este o extracție concentrată de copt
malț de orz, lapte de vacă cremos pură, a

908
00:44:09,470 --> 00:44:14,360
și special preparate de cacao, împreună
cu fosfatide naturale și vitamine.

909
00:44:14,360 --> 00:44:18,240
Ea este îmbogățit în continuare cu
vitamine suplimentare B și D, yum.

910
00:44:18,240 --> 00:44:21,600
Și îl puteți obține în continuare, se pare că,
pe Amazon, așa cum am făcut-o aici.

911
00:44:21,600 --> 00:44:24,810
>> Dar, motivația aici a fost de a
să introducă criptografie, în special

912
00:44:24,810 --> 00:44:28,340
un tip de criptografie cunoscută
ca criptografia cheie secretă.

913
00:44:28,340 --> 00:44:34,284
Și, după cum sugerează și numele, întregul
securitatea unui sistem cripto-cheie secretă,

914
00:44:34,284 --> 00:44:36,200
dacă vreți, o metodologie
pentru doar codare

915
00:44:36,200 --> 00:44:40,960
informații între doi oameni, este că
numai expeditorul și destinatarul numai

916
00:44:40,960 --> 00:44:46,980
știu o key-- secretă o anumită valoare, unele
frază secretă, unele număr secret, că

917
00:44:46,980 --> 00:44:50,660
le permite atât criptați
și decripta informații.

918
00:44:50,660 --> 00:44:53,470
Și criptografie, într-adevăr,
este doar în această săptămână de la 0.

919
00:44:53,470 --> 00:44:56,715
>> Este o problemă în cazul în care există intrări,
cum ar fi mesajul real în limba engleză

920
00:44:56,715 --> 00:44:59,340
sau orice limbă pe care
doresc să trimită pe cineva în clasă,

921
00:44:59,340 --> 00:45:00,580
sau pe internet.

922
00:45:00,580 --> 00:45:03,840
Există unele de ieșire, care se întâmplă
pentru a fi mesajul criptat pe care le

923
00:45:03,840 --> 00:45:05,250
doriți ca destinatarul să primească.

924
00:45:05,250 --> 00:45:07,405
Și chiar dacă cineva din
de mijloc primește de asemenea,

925
00:45:07,405 --> 00:45:09,780
nu le doresc să
în mod necesar în măsură să-l decripta,

926
00:45:09,780 --> 00:45:12,840
deoarece în interiorul acestei
cutie neagră, sau algoritm,

927
00:45:12,840 --> 00:45:17,650
este un mecanism, unele pas cu pas
instrucțiuni, pentru a lua acea intrare

928
00:45:17,650 --> 00:45:20,710
și conversia în
de ieșire, în sperăm, un mod securizat.

929
00:45:20,710 --> 00:45:23,640
>> Și, de fapt, există unele
vocabular în această lume, după cum urmează.

930
00:45:23,640 --> 00:45:26,100
Text simplu este cuvântul A
om de știință de calculator ar

931
00:45:26,100 --> 00:45:28,449
utilizați pentru a descrie intrarea
mesaj, cum ar fi limba engleză

932
00:45:28,449 --> 00:45:31,240
sau orice ai limbă de fapt
doresc să trimită la un alt om.

933
00:45:31,240 --> 00:45:35,450
Și apoi este ciphertext încăierare
la cifrate, sau criptat,

934
00:45:35,450 --> 00:45:36,520
versiune a acestuia.

935
00:45:36,520 --> 00:45:38,750
>> Dar, există un alt ingredient aici.

936
00:45:38,750 --> 00:45:43,200
Mai este o intrare la
criptografia cheie secretă.

937
00:45:43,200 --> 00:45:45,200
Și aceasta este cheia în sine,
care este, în general,

938
00:45:45,200 --> 00:45:48,930
după cum vom vedea, un număr, sau
literă sau cuvânt, oricare ar fi

939
00:45:48,930 --> 00:45:51,980
algoritmul este de fapt se așteaptă.

940
00:45:51,980 --> 00:45:53,870
>> Și cum decripta informații?

941
00:45:53,870 --> 00:45:55,110
Cum de a face tu unscramble?

942
00:45:55,110 --> 00:45:57,950
Ei bine, doar inversa
ieșirile și intrările.

943
00:45:57,950 --> 00:46:00,900
>> Cu alte cuvinte, odată ce cineva
primește mesajul criptat,

944
00:46:00,900 --> 00:46:03,740
el sau ea are pur și simplu
să știe că aceeași cheie.

945
00:46:03,740 --> 00:46:05,700
Aceștia au primit ciphertext.

946
00:46:05,700 --> 00:46:09,530
Și, prin conectarea celor doi
intrări în sistemul cripto,

947
00:46:09,530 --> 00:46:14,260
algoritmul, această cutie neagră, dintr-un
ar trebui să vină plaintext- originală.

948
00:46:14,260 --> 00:46:17,830
Și, astfel că este nivelul foarte ridicat
vedere a ceea ce criptografiei este de fapt

949
00:46:17,830 --> 00:46:18,590
totul despre.

950
00:46:18,590 --> 00:46:20,030
>> Așa că hai să ajungem acolo.

951
00:46:20,030 --> 00:46:22,700
Să ne uităm acum dedesubt
capota ceva

952
00:46:22,700 --> 00:46:26,000
ne-am luat de la sine pentru
saptamana trecuta, iar pentru această sesiune

953
00:46:26,000 --> 00:46:27,629
aici-- șirul.

954
00:46:27,629 --> 00:46:30,295
Un șir la sfârșitul zilei
este doar o secvență de caractere.

955
00:46:30,295 --> 00:46:33,610
>> S-ar putea să fie Hello World, sau
Bună ziua Zamyla, sau orice altceva.

956
00:46:33,610 --> 00:46:37,050
Dar ce înseamnă asta pentru
să fie o secvență de caractere?

957
00:46:37,050 --> 00:46:41,520
De fapt, biblioteca CS50 da
ne un tip de date numit șir.

958
00:46:41,520 --> 00:46:45,140
>> Dar nu există de fapt nici
de lucru, cum ar fi un șir de caractere în C.

959
00:46:45,140 --> 00:46:49,450
Este într-adevăr este doar o secvență de
caracter, caracter, caracter,

960
00:46:49,450 --> 00:46:52,180
caracter, înapoi, în spate, la
înapoi, în spate, în spate interior

961
00:46:52,180 --> 00:46:54,650
din memoria computerului, sau RAM.

962
00:46:54,650 --> 00:46:58,940
Si ne vom uita mai adânc în faptul că, în
viitor, atunci când ne uităm la memorie în sine,

963
00:46:58,940 --> 00:47:02,030
precum și utilizarea, precum și
amenințări care sunt implicate.

964
00:47:02,030 --> 00:47:04,100
>> Dar, să considerăm șirul Zamyla.

965
00:47:04,100 --> 00:47:07,480
Deci, doar numele
omul aici, Zamyla,

966
00:47:07,480 --> 00:47:12,030
care este o secvență de
caractere, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Și acum să presupunem că numele lui Zamyla
este stocată în interiorul unui calculator

968
00:47:16,020 --> 00:47:16,880
program.

969
00:47:16,880 --> 00:47:20,830
>> Ei bine, este evident motivul pentru care ar trebui să ne
să fie în măsură să se uite la acele caractere

970
00:47:20,830 --> 00:47:21,590
individual.

971
00:47:21,590 --> 00:47:24,710
Deci, eu sunt doar de gând să atragă un pic
cutie în jurul numelui Zamyla aici.

972
00:47:24,710 --> 00:47:31,580
Și este cazul în C, că, atunci când
au un șir de caractere, cum ar fi Zamyla-- și poate

973
00:47:31,580 --> 00:47:34,940
acel șir a venit înapoi de la
o funcție cum ar fi șir get,

974
00:47:34,940 --> 00:47:38,540
puteți manipula de fapt,
caracterul prin caracter.

975
00:47:38,540 --> 00:47:42,070
>> Acum, acest lucru este germaniu, Pentru
conversație la îndemână, deoarece

976
00:47:42,070 --> 00:47:46,420
în criptografie, dacă doriți să modificați
A la B și B la C și C la D,

977
00:47:46,420 --> 00:47:49,650
și așa mai departe, trebuie să fie în măsură
să se uite la caracterele individuale

978
00:47:49,650 --> 00:47:50,190
într-un șir de caractere.

979
00:47:50,190 --> 00:47:52,695
Trebuie să fii capabil să se schimbe
Z la altceva, A

980
00:47:52,695 --> 00:47:55,280
la altceva, M pentru a
altceva, și așa mai departe.

981
00:47:55,280 --> 00:47:58,000
Și așa avem nevoie de un fel,
programatică, așa

982
00:47:58,000 --> 00:48:03,020
să vorbească, în C pentru a putea schimba
si uita-te la litere individuale.

983
00:48:03,020 --> 00:48:05,690
Și noi putem face acest lucru, după cum urmează.

984
00:48:05,690 --> 00:48:08,340
>> Lasă-mă să plec capul înapoi în IDE CS50.

985
00:48:08,340 --> 00:48:11,130
Și lasă-mă să merg mai departe
și de a crea un nou fișier

986
00:48:11,130 --> 00:48:16,134
că voi suna de data asta string0,
ca primul nostru astfel de exemplu, dot c.

987
00:48:16,134 --> 00:48:18,300
Si voi merge mai departe
și bici-l după cum urmează.

988
00:48:18,300 --> 00:48:22,870
>> Așa că includ CS50.h, și
apoi includ io.h standard

989
00:48:22,870 --> 00:48:25,990
pe care am aproape întotdeauna o să
să fie utilizați în programele mele, cel puțin

990
00:48:25,990 --> 00:48:26,780
inițial.

991
00:48:26,780 --> 00:48:32,180
int void main, iar apoi aici sunt eu
O să facă siruri de caractere devine primi șir de caractere.

992
00:48:32,180 --> 00:48:35,260
Și apoi voi
mergeți mai departe și de a face acest lucru.

993
00:48:35,260 --> 00:48:37,460
Vreau să merg mai departe
și, ca un control bun-simț,

994
00:48:37,460 --> 00:48:43,607
doar spun, salut, procente s,
semi-colon, face string 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, ce am făcut aici?

996
00:48:44,690 --> 00:48:45,930
Oh, nu l-am conectați.

997
00:48:45,930 --> 00:48:48,120
Așa că lecția învățată, că
nu a fost intenționată.

998
00:48:48,120 --> 00:48:52,480
>> Asa ca eroare, mai mult la sută
conversii decât argumentele date.

999
00:48:52,480 --> 00:48:54,940
Și acest lucru este în cazul în care, în
line 7-- OK, așa că am,

1000
00:48:54,940 --> 00:48:56,690
citat unquote, asta
string meu la printf.

1001
00:48:56,690 --> 00:48:58,151
Am un semn la sută.

1002
00:48:58,151 --> 00:48:59,650
Dar îmi lipsește al doilea argument.

1003
00:48:59,650 --> 00:49:03,190
>> Ratez virgulă s, care
Am avut în exemplele anterioare.

1004
00:49:03,190 --> 00:49:06,650
Deci, o bună oportunitate de a repara
una mai greșeală, în mod accidental.

1005
00:49:06,650 --> 00:49:09,950
Și acum lasă-mă alerga
string0, tip în Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, salut Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Așa că ne-am rula acest tip de program
de câteva ori diferite acum.

1008
00:49:14,144 --> 00:49:16,310
Dar hai să facem ceva
puțin diferit de data asta.

1009
00:49:16,310 --> 00:49:19,450
În loc de doar de imprimare a lui Zamyla
numele întreg cu printf,

1010
00:49:19,450 --> 00:49:21,350
să o facem caracter cu caracter.

1011
00:49:21,350 --> 00:49:22,700
>> Am de gând să utilizeze o buclă.

1012
00:49:22,700 --> 00:49:26,160
Iar eu mă voi da
o variabilă de numărare, numit i.

1013
00:49:26,160 --> 00:49:33,530
Și, voi păstra recapitularea, așa
atâta timp cât i este mai mică decât lungimea lui.

1014
00:49:33,530 --> 00:49:35,930
>> Se pare, nu am făcut-o
a face acest lucru ultima dată,

1015
00:49:35,930 --> 00:49:39,100
că c vine cu o
functie numita Stirling.

1016
00:49:39,100 --> 00:49:42,690
Înapoi în a doua zi, și, în general,
încă atunci când punerea în aplicare a funcțiilor,

1017
00:49:42,690 --> 00:49:45,405
oamenii vor alege de multe ori foarte
nume succinte acest tip de sunet

1018
00:49:45,405 --> 00:49:48,280
ca ceea ce vrei, chiar dacă este
lipsesc câteva vocalele sau litere.

1019
00:49:48,280 --> 00:49:50,660
Deci Stirling este
numele unei funcții care

1020
00:49:50,660 --> 00:49:53,880
ia un argument între
paranteze care ar trebui să fie un șir.

1021
00:49:53,880 --> 00:49:56,910
Și se returnează doar un număr întreg,
lungimea acelui șir.

1022
00:49:56,910 --> 00:50:00,580
>> Deci, acest lucru pentru bucla de pe linia 7 se întâmplă
pentru a începe numărarea la i este egal cu 0.

1023
00:50:00,580 --> 00:50:02,530
Se va incrementa
i pe fiecare iterație

1024
00:50:02,530 --> 00:50:04,350
de 1, așa cum ne-am făcut de câteva ori.

1025
00:50:04,350 --> 00:50:06,780
Dar se va face numai
acest lucru până la punctul

1026
00:50:06,780 --> 00:50:09,660
atunci când i este lungimea
din șirul în sine.

1027
00:50:09,660 --> 00:50:14,520
>> Deci, acesta este un mod de a, în cele din urmă,
iterarea peste caractere

1028
00:50:14,520 --> 00:50:17,430
în șir după cum urmează este.

1029
00:50:17,430 --> 00:50:20,670
Am de gând să imprima nu o
șir întreg, dar c la sută,

1030
00:50:20,670 --> 00:50:22,860
un singur caracter
urmată de o nouă linie.

1031
00:50:22,860 --> 00:50:24,880
Și apoi voi
merge mai departe, și am nevoie

1032
00:50:24,880 --> 00:50:29,080
să spun că vreau să imprimați
caracterul i-lea al lui.

1033
00:50:29,080 --> 00:50:33,450
>> Deci dacă este variabila care indica
indicele șir, unde

1034
00:50:33,450 --> 00:50:37,230
ești în ea, trebuie să fie în măsură să
spun, da-mi caracterul i-lea al lui.

1035
00:50:37,230 --> 00:50:40,390
Și c are o cale de a face
acest lucru cu paranteze drepte.

1036
00:50:40,390 --> 00:50:43,679
Tu spui pur și simplu, pe numele
șir de caractere, care în acest caz este s.

1037
00:50:43,679 --> 00:50:46,970
Apoi, utilizați paranteze pătrate, care sunt
de obicei, chiar deasupra Revenire sau Enter

1038
00:50:46,970 --> 00:50:48,110
tasta de pe tastatură.

1039
00:50:48,110 --> 00:50:52,410
Și apoi ai pus indexul
caracterul pe care doriți să le imprimați.

1040
00:50:52,410 --> 00:50:55,960
Astfel încât indicele va fi un
number-- 0 sau 1 sau 2 sau 3 sau punct,

1041
00:50:55,960 --> 00:50:57,590
punct, punct, un alt număr.

1042
00:50:57,590 --> 00:51:00,920
>> Și să ne asigurăm că va
este numărul corect, pentru că am

1043
00:51:00,920 --> 00:51:02,360
începe numărarea de la 0 ° C.

1044
00:51:02,360 --> 00:51:07,020
Și, în mod implicit, primul caracter
într-un șir de caractere este, prin convenție 0.

1045
00:51:07,020 --> 00:51:09,230
Iar al doilea caracter este placuta 1.

1046
00:51:09,230 --> 00:51:11,120
Iar al treilea caracter este placuta 2.

1047
00:51:11,120 --> 00:51:13,630
Si tu nu vrei să mergi prea
de departe, dar vom nu pentru că suntem

1048
00:51:13,630 --> 00:51:17,780
O să incrementa i numai până când
este egală cu lungimea șirului.

1049
00:51:17,780 --> 00:51:20,210
Și, moment în care,
acest lucru pentru bucla se va opri.

1050
00:51:20,210 --> 00:51:25,550
>> Așa că lasă-mă să merg mai departe și de a salva acest lucru
de program și rulați make șir 0.

1051
00:51:25,550 --> 00:51:28,400
Dar am greșit.

1052
00:51:28,400 --> 00:51:35,390
de declarare a funcției de bibliotecă implicit
Stirling cu tipul de astfel și such-- acum,

1053
00:51:35,390 --> 00:51:36,430
acest lucru sună familiar.

1054
00:51:36,430 --> 00:51:37,440
Dar nu e printf.

1055
00:51:37,440 --> 00:51:38,540
Și nu ajunge șir.

1056
00:51:38,540 --> 00:51:40,480
>> Nu m-am șurub sus în
la fel de data aceasta.

1057
00:51:40,480 --> 00:51:45,100
Dar observați aici un pic mai jos
în continuare, includ string.h antet,

1058
00:51:45,100 --> 00:51:47,210
prevede în mod explicit
Declarația pentru Stirling.

1059
00:51:47,210 --> 00:51:48,820
Deci, există de fapt un indiciu acolo.

1060
00:51:48,820 --> 00:51:51,670
>> Și, într-adevăr, se pare
există un alt fișier antet

1061
00:51:51,670 --> 00:51:53,970
că nu ne-am folosit
în clasa încă, dar este

1062
00:51:53,970 --> 00:51:56,480
printre cele disponibile
pentru tine, numit string.h.

1063
00:51:56,480 --> 00:52:00,930
Și în acel dosar, string.h
este Stirling a declarat.

1064
00:52:00,930 --> 00:52:05,220
Așa că lasă-mă să merg mai departe și
salvați acest lucru, face șir

1065
00:52:05,220 --> 00:52:08,040
0-- frumos, nici un mesaj de eroare de data asta.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, și
Sunt pe cale de a lovi Enter,

1067
00:52:12,290 --> 00:52:16,710
la care punctul getstring se întâmplă
pentru a reveni șir, pune-l în s.

1068
00:52:16,710 --> 00:52:21,890
Apoi, faptul că pentru bucla se va repeta
peste caractere S e unul la un moment dat,

1069
00:52:21,890 --> 00:52:28,420
și imprimați-le câte unul pe fiecare rând, deoarece
Am avut că backslash n la sfârșitul anului.

1070
00:52:28,420 --> 00:52:34,530
Așa că am putut omite că backslash
n, și apoi imprimați doar Zamyla toate

1071
00:52:34,530 --> 00:52:37,460
în aceeași linie,
reimplementing efectiv

1072
00:52:37,460 --> 00:52:38,999
printf, care nu este tot ceea ce folositor.

1073
00:52:38,999 --> 00:52:40,540
Dar, în acest caz, nu am făcut asta.

1074
00:52:40,540 --> 00:52:43,610
de fapt, am tipărit unul
caracter la un moment dat, câte unul pe fiecare rând,

1075
00:52:43,610 --> 00:52:45,400
astfel încât să vedem de fapt efectul.

1076
00:52:45,400 --> 00:52:46,900
>> Dar, trebuie să adaug un singur lucru aici.

1077
00:52:46,900 --> 00:52:48,930
Și ne vom întoarce la
acest lucru într-o săptămână viitoare.

1078
00:52:48,930 --> 00:52:52,650
Se pare că acest lucru
Codul este potențial buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Se pare că, șir de caractere get
și alte funcții în viață

1080
00:52:56,560 --> 00:53:00,280
nu întotdeauna în mod necesar
a reveni la ce te asteapta.

1081
00:53:00,280 --> 00:53:03,010
Știm din clasa trecută
timp în această care obține

1082
00:53:03,010 --> 00:53:04,960
șir de caractere ar trebui să se întoarcă un șir de caractere.

1083
00:53:04,960 --> 00:53:09,900
Dar dacă utilizatorul introduce un astfel dintr-
un cuvânt lung, sau paragraf, sau un eseu

1084
00:53:09,900 --> 00:53:13,010
că pur și simplu nu suficient
memorie în computer pentru a se potrivi.

1085
00:53:13,010 --> 00:53:15,410
>> Cum ar fi, ce se întâmplă dacă ceva nu merge
greșit sub capota?

1086
00:53:15,410 --> 00:53:18,400
S-ar putea să nu se întâmple de multe ori,
dar s-ar putea întâmpla o dată

1087
00:53:18,400 --> 00:53:21,520
într-un timp, foarte rar.

1088
00:53:21,520 --> 00:53:25,460
Și așa se pare că șir get
și funcționează ca o fac, nu neapărat

1089
00:53:25,460 --> 00:53:26,380
a reveni întotdeauna siruri.

1090
00:53:26,380 --> 00:53:30,680
S-ar putea returna o anumită valoare de eroare,
o anumită valoare santinelă ca să spunem așa,

1091
00:53:30,680 --> 00:53:32,612
care indică faptul că
ceva a mers prost.

1092
00:53:32,612 --> 00:53:35,320
Si tu ar sti doar asta de la
au învățat în clasa acum,

1093
00:53:35,320 --> 00:53:37,700
sau după ce a citit unele mai multe documentare.

1094
00:53:37,700 --> 00:53:43,120
Se pare că, șir de caractere get
poate returna o valoare numită nulă.

1095
00:53:43,120 --> 00:53:46,220
Nul este o valoare deosebită pe care o vom
vin înapoi într-o săptămână viitoare.

1096
00:53:46,220 --> 00:53:50,420
Dar pentru moment, doar știu că, dacă vreau
să fie într-adevăr adecvată în mișcare înainte

1097
00:53:50,420 --> 00:53:52,650
folosind string get, eu
nu trebuie doar să-l numesc,

1098
00:53:52,650 --> 00:53:56,870
și orbește folosi valoarea de întoarcere,
încrederea că este un șir de caractere.

1099
00:53:56,870 --> 00:53:59,420
>> Ar trebui să spun în primul rând,
hei, așteptați un minut, numai

1100
00:53:59,420 --> 00:54:03,380
proceda în cazul în care s nu este egal
nul, în cazul în care nul, din nou,

1101
00:54:03,380 --> 00:54:04,660
este doar o valoare deosebită.

1102
00:54:04,660 --> 00:54:07,770
Și este singura valoare specială vă
Trebuie să vă faceți griji pentru șir get.

1103
00:54:07,770 --> 00:54:10,900
Primi șir de caractere este fie merge
pentru a returna un șir de caractere sau nul.

1104
00:54:10,900 --> 00:54:17,219
>> Iar acest punct exclamație semnul egal
s-ar putea stii de la clasa de matematică poate

1105
00:54:17,219 --> 00:54:20,510
că s-ar putea trage un semn egal cu
o linie prin ea pentru a indica nu este egal.

1106
00:54:20,510 --> 00:54:23,135
Asta nu este, în general, un caracter
aveți posibilitatea să tastați pe tastatură.

1107
00:54:23,135 --> 00:54:26,480
Și astfel, în cele mai multe limbaje de programare,
atunci când doriți să spun, nu egal,

1108
00:54:26,480 --> 00:54:29,160
utilizați un punct de exclamare,
în caz contrar, cunoscut sub numele bang-ului.

1109
00:54:29,160 --> 00:54:33,180
Deci tu spui bang este egal, care
înseamnă că nu este egal, în mod logic.

1110
00:54:33,180 --> 00:54:38,060
E ca și cum nu există o mai mare
decât sau egală sau mai mică

1111
00:54:38,060 --> 00:54:41,270
sau egală cu taste de pe tastatura
care face totul într-un singur simbol.

1112
00:54:41,270 --> 00:54:44,020
Deci, de aceea, în exemplele anterioare,
ai făcut-o paranteză deschisă, și apoi

1113
00:54:44,020 --> 00:54:48,670
un semn egal, în scopul de a face
mai mare sau, să zicem, mai puțin.

1114
00:54:48,670 --> 00:54:49,910
>> Deci, ce-i MENIUL aici?

1115
00:54:49,910 --> 00:54:53,880
Acest lucru este pur și simplu o modalitate de acum
introducând această sintaxă, această caracteristică,

1116
00:54:53,880 --> 00:54:57,390
iterating peste individuale
caractere dintr-un șir de caractere.

1117
00:54:57,390 --> 00:55:00,260
Și, la fel ca și cele pătrat
paranteze vă permit să obțineți de la ei,

1118
00:55:00,260 --> 00:55:03,790
ia în considerare aceste paranteze pătrate ca
un fel de aluzie la acest suport

1119
00:55:03,790 --> 00:55:06,040
proiectare, prin care fiecare
caracterul în interiorul unui șir de caractere

1120
00:55:06,040 --> 00:55:10,180
este un fel de cutie undeva dedesubt
hota în memoria calculatorului.

1121
00:55:10,180 --> 00:55:12,340
>> Dar, hai să facem o variantă a acestei.

1122
00:55:12,340 --> 00:55:14,880
Se pare că acest lucru
Programul este corect.

1123
00:55:14,880 --> 00:55:18,810
Asa ca pe axele CS50 pentru evaluarea
cod, acest lucru este corect acum.

1124
00:55:18,810 --> 00:55:22,959
Mai ales acum că eu sunt de verificare pentru
null, acest program nu ar trebui să se prăbușească.

1125
00:55:22,959 --> 00:55:24,500
Și eu știu doar că din experiență.

1126
00:55:24,500 --> 00:55:28,040
Dar nu e nimic altceva
putem merge într-adevăr greșit aici.

1127
00:55:28,040 --> 00:55:31,860
Dar nu este foarte bine conceput,
pentru că hai să ne întoarcem la elementele de bază.

1128
00:55:31,860 --> 00:55:34,450
>> În primul rând, principles--
ceea ce face o buclă pentru a face?

1129
00:55:34,450 --> 00:55:36,290
O buclă face trei lucruri.

1130
00:55:36,290 --> 00:55:39,340
Acesta inițializează unele
valoare, dacă ceri să.

1131
00:55:39,340 --> 00:55:41,770
Acesta verifică o condiție.

1132
00:55:41,770 --> 00:55:45,380
Și apoi, după fiecare
repetare, după fiecare ciclu,

1133
00:55:45,380 --> 00:55:49,330
ea incrementează unele
valoare, sau valori, aici.

1134
00:55:49,330 --> 00:55:50,600
>> Deci, ce înseamnă asta?

1135
00:55:50,600 --> 00:55:52,940
Noi am inițializa la 0.

1136
00:55:52,940 --> 00:55:58,610
Verificăm și asigurați-vă că i este mai mică decât
lungimea lui, care este Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
acest lucru care este mai mic de 6.

1138
00:55:59,900 --> 00:56:02,590
Și, într-adevăr, 0, mai puțin de 6.

1139
00:56:02,590 --> 00:56:05,580
>> Noi imprima Z din numele Zamyla lui.

1140
00:56:05,580 --> 00:56:08,080
Apoi am incrementa i la 0 la 1.

1141
00:56:08,080 --> 00:56:11,290
Apoi vom verifica, este 1 mai puțin
decât lungimea lui?

1142
00:56:11,290 --> 00:56:13,270
Lungimea este de 6.

1143
00:56:13,270 --> 00:56:13,950
Da, este.

1144
00:56:13,950 --> 00:56:16,880
>> Așa că am imprima o în numele lui Zamyla, ZA.

1145
00:56:16,880 --> 00:56:20,090
Noi incrementa i de la 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Apoi vom verifica, este mai mică de 2
lungimea numelui lui Zamyla.

1147
00:56:23,720 --> 00:56:25,380
6- asa 2 este mai mic de 6.

1148
00:56:25,380 --> 00:56:30,460
Da, să imprime acum M în
Numele lui Zamyla, al treilea caracter.

1149
00:56:30,460 --> 00:56:34,110
>> Cheia aici este că pe fiecare
iterație de poveste, eu sunt de verificare,

1150
00:56:34,110 --> 00:56:37,810
este i mai mică decât lungimea Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Dar captura este că
Stirling nu este o proprietate.

1152
00:56:40,350 --> 00:56:43,100
Aceia dintre voi care au programat
înainte de a în Java sau în alte limbi

1153
00:56:43,100 --> 00:56:46,310
ar putea să cunoască lungimea unui șir de caractere este
o proprietate, doar câteva citit doar o valoare.

1154
00:56:46,310 --> 00:56:50,220
>> În C, în acest caz, în cazul în care acest lucru este
o funcție care este literalmente

1155
00:56:50,220 --> 00:56:53,520
numararea
caractere în Zamyla de fiecare dată

1156
00:56:53,520 --> 00:56:54,740
noi numim această funcție.

1157
00:56:54,740 --> 00:56:58,500
De fiecare dată când cere computerului să utilizeze
Stirling, este de a lua o privire la Zamyla,

1158
00:56:58,500 --> 00:57:01,960
și spunând Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Și se întoarce 6.

1160
00:57:02,962 --> 00:57:04,920
Data viitoare când te sun
ea în interiorul că pentru bucla,

1161
00:57:04,920 --> 00:57:08,610
o să se uite la Zamyla
din nou, să zicem Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Și va să se întoarcă 6.

1163
00:57:10,320 --> 00:57:12,980
Deci, ce e prost despre acest design?

1164
00:57:12,980 --> 00:57:17,700
>> De ce este codul meu nu un 5 din 5
pentru proiectare chiar acum, ca să spunem așa?

1165
00:57:17,700 --> 00:57:20,600
Ei bine, eu cer un
întrebare în mod inutil.

1166
00:57:20,600 --> 00:57:23,030
Fac mai mult de lucru decât am nevoie.

1167
00:57:23,030 --> 00:57:25,370
>> Așa că, chiar dacă
raspunsul este corect, eu sunt

1168
00:57:25,370 --> 00:57:29,560
cere computerului, ceea ce este
lungimea Zamyla din nou,

1169
00:57:29,560 --> 00:57:31,380
și din nou, și din nou, și din nou?

1170
00:57:31,380 --> 00:57:33,980
Iar acest răspuns este
nu se va schimba.

1171
00:57:33,980 --> 00:57:35,900
Întotdeauna o să fie 6.

1172
00:57:35,900 --> 00:57:39,730
>> Deci, o soluție mai bună decât aceasta
ar fi această versiune următoare.

1173
00:57:39,730 --> 00:57:43,390
Lasă-mă să merg mai departe și pune-l într-un
fișier separat numit string1.c,

1174
00:57:43,390 --> 00:57:44,990
doar să-l păstrați separa.

1175
00:57:44,990 --> 00:57:47,260
Și se pare că într-un timp de
buclă, aveți posibilitatea de fapt

1176
00:57:47,260 --> 00:57:50,210
declara mai multe variabile dintr-o dată.

1177
00:57:50,210 --> 00:57:53,460
>> Așa că voi să mă păstreze și să-l setați la 0.

1178
00:57:53,460 --> 00:57:56,190
Dar eu sunt, de asemenea, o să
adăugați o virgulă, și spune,

1179
00:57:56,190 --> 00:58:01,050
da-mi o variabilă numită n, a cărui
valoare este egală cu lungimea șirului de caractere de s.

1180
00:58:01,050 --> 00:58:09,410
Și acum, te rog să-mi starea
atât timp cât i este mai mică decât n.

1181
00:58:09,410 --> 00:58:14,140
>> Deci, în acest fel, logica este
identic la sfârșitul zilei.

1182
00:58:14,140 --> 00:58:18,280
Dar eu sunt amintindu-ne
Valoarea 6, în acest caz.

1183
00:58:18,280 --> 00:58:19,780
Care este lungimea numelui lui Zamyla?

1184
00:58:19,780 --> 00:58:20,860
Si eu o pune la n.

1185
00:58:20,860 --> 00:58:23,050
>> Si eu sunt încă de verificare
condiția de fiecare dată.

1186
00:58:23,050 --> 00:58:24,300
Este 0 mai puțin de 6?

1187
00:58:24,300 --> 00:58:25,600
Este 1 mai puțin de 6?

1188
00:58:25,600 --> 00:58:28,600
Este de 2 mai puțin de 6, și așa mai departe?

1189
00:58:28,600 --> 00:58:31,914
>> Dar nu-ți cer calculatorul
din nou, și din nou, ceea ce este

1190
00:58:31,914 --> 00:58:33,080
lungimea numelui lui Zamyla?

1191
00:58:33,080 --> 00:58:34,320
Care este lungimea numelui lui Zamyla?

1192
00:58:34,320 --> 00:58:35,986
Care este lungimea numelui acestui Zamyla lui?

1193
00:58:35,986 --> 00:58:40,440
Sunt literalmente să ne amintim că mai întâi și
răspundă doar în această a doua n variabile.

1194
00:58:40,440 --> 00:58:45,280
Deci, acest lucru acum ar fi nu numai
corectă, dar, de asemenea, bine concepute.

1195
00:58:45,280 --> 00:58:46,670
>> Acum, ce zici de stil?

1196
00:58:46,670 --> 00:58:48,866
Am numit variabilele mele
destul de bine, aș spune.

1197
00:58:48,866 --> 00:58:50,240
Sunt foarte succint chiar acum.

1198
00:58:50,240 --> 00:58:52,090
Și asta e total bine.

1199
00:58:52,090 --> 00:58:55,120
>> Dacă aveți doar un singur
șir într-un program,

1200
00:58:55,120 --> 00:58:56,860
s-ar putea la fel de bine suna-l pentru șir.

1201
00:58:56,860 --> 00:58:59,370
Dacă aveți doar o singură variabilă
pentru numărarea într-un program,

1202
00:58:59,370 --> 00:59:00,710
s-ar putea la fel de bine numi i.

1203
00:59:00,710 --> 00:59:03,500
Dacă aveți o lungime, n
este super comun, de asemenea.

1204
00:59:03,500 --> 00:59:05,800
Dar nu am comentat nici din codul meu.

1205
00:59:05,800 --> 00:59:09,200
>> Nu am informat reader--
dacă asta e TF mea, sau TA,

1206
00:59:09,200 --> 00:59:12,460
sau pur și simplu colleague-- ceea ce se presupune
să se întâmplă în acest program.

1207
00:59:12,460 --> 00:59:15,760
Și, astfel încât pentru a obține stil bun,
ceea ce aș vrea să fac

1208
00:59:15,760 --> 00:59:24,580
este astea-- ceva
cum ar fi întrebați de utilizator pentru intrare.

1209
00:59:24,580 --> 00:59:26,670
Și aș putea rescrie
acest orice număr de moduri.

1210
00:59:26,670 --> 00:59:35,630
>> Asigurați-vă că asigurați-vă că get S-
șir de caractere returnat un șir de caractere.

1211
00:59:35,630 --> 00:59:40,280
Și apoi în aici-- și acest lucru este, probabil,
cel mai important iterăm comment--

1212
00:59:40,280 --> 00:59:44,450
peste personajele e unul la un moment dat.

1213
00:59:44,450 --> 00:59:47,060
Și aș putea folosi orice
alegerea limbii engleze

1214
00:59:47,060 --> 00:59:49,650
aici pentru a descrie fiecare
din aceste bucăți de cod.

1215
00:59:49,650 --> 00:59:52,740
>> Observați că nu am pus-o
comentariu pe fiecare linie de cod,

1216
00:59:52,740 --> 00:59:55,690
într-adevăr doar pe interesant
Noștri, cei care

1217
00:59:55,690 --> 00:59:59,460
au un înțeles că aș putea
doresc să facă super-clar cuiva

1218
00:59:59,460 --> 01:00:00,460
citind codul meu.

1219
01:00:00,460 --> 01:00:02,920
Și de ce ai sunat obține
string întreba de utilizator pentru intrare?

1220
01:00:02,920 --> 01:00:05,450
Chiar că nu este neapărat
tot ceea ce descriptiv.

1221
01:00:05,450 --> 01:00:09,340
Dar ajută spune o poveste, pentru că
a doua linie din poveste este, asigurați-vă că

1222
01:00:09,340 --> 01:00:10,740
obține șir returnat un șir de caractere.

1223
01:00:10,740 --> 01:00:14,260
>> Și al treilea rând din poveste este,
itera personajele s-unul

1224
01:00:14,260 --> 01:00:15,380
la un moment dat.

1225
01:00:15,380 --> 01:00:17,920
Și acum doar pentru o bună măsură,
Mă duc să merg mai departe și se adaugă

1226
01:00:17,920 --> 01:00:24,560
mai mult de un comentariu care tocmai
spune imprimare i-lea caracter din s.

1227
01:00:24,560 --> 01:00:26,520
Acum, ce am făcut
la sfarsitul zilei?

1228
01:00:26,520 --> 01:00:29,190
>> Am adăugat puțină engleză
cuvinte sub formă de comentarii.

1229
01:00:29,190 --> 01:00:32,700
Simbolul slash slash înseamnă, hei,
computerul este pentru om,

1230
01:00:32,700 --> 01:00:33,820
nu pentru tine, calculatorul.

1231
01:00:33,820 --> 01:00:35,119
Deci sunt ignorate în mod logic.

1232
01:00:35,119 --> 01:00:35,910
Sunt pur și simplu acolo.

1233
01:00:35,910 --> 01:00:39,830
>> Și, într-adevăr, CS50 IDE le prezinta ca
gri, ca fiind util, dar nu-cheie

1234
01:00:39,830 --> 01:00:41,000
la program.

1235
01:00:41,000 --> 01:00:42,570
Observați ce poți face acum.

1236
01:00:42,570 --> 01:00:44,950
Indiferent dacă știi C
programare sau nu,

1237
01:00:44,950 --> 01:00:47,722
poate sta doar înapoi la acest
program și degresat comentarii.

1238
01:00:47,722 --> 01:00:50,180
Solicitați utilizatorului de intrare, asigurați-vă că
obține șir returnat un șir de caractere,

1239
01:00:50,180 --> 01:00:53,009
itera caracterele din s
unul la un moment dat, imprima caracterul

1240
01:00:53,009 --> 01:00:55,550
caracterul i-lea în tine nu S-
chiar trebuie să se uite la codul

1241
01:00:55,550 --> 01:00:57,270
pentru a înțelege ce face acest program.

1242
01:00:57,270 --> 01:01:00,280
Si, mai bine încă, dacă te uiți
la acest program într-o săptămână sau două,

1243
01:01:00,280 --> 01:01:02,280
sau o lună sau un an,
tu nu ai

1244
01:01:02,280 --> 01:01:04,420
să se uite la codul,
încercând să-și amintească,

1245
01:01:04,420 --> 01:01:06,630
ce am fost încercarea de a face cu acest cod?

1246
01:01:06,630 --> 01:01:07,770
>> Te-ai spus.

1247
01:01:07,770 --> 01:01:11,660
L-ai descris pentru tine,
sau un coleg, sau AT, sau TF.

1248
01:01:11,660 --> 01:01:14,860
Și, astfel încât acest lucru ar fi acum
corectă, și un design bun,

1249
01:01:14,860 --> 01:01:18,210
și în cele din urmă stil bun, de asemenea.

1250
01:01:18,210 --> 01:01:19,990
Deci, nu țin minte.

1251
01:01:19,990 --> 01:01:22,200
>> Așa că există un alt
lucru pe care am de gând să fac aici

1252
01:01:22,200 --> 01:01:28,240
care poate dezvălui acum exact ceea ce-i
merge pe sub capota.

1253
01:01:28,240 --> 01:01:30,390
Deci, nu există această caracteristică
în C, și în alte limbi,

1254
01:01:30,390 --> 01:01:33,010
numit typecasting
că, fie implicit

1255
01:01:33,010 --> 01:01:37,250
sau permite în mod explicit să convertiți
de la un tip de date la altul.

1256
01:01:37,250 --> 01:01:39,800
Am fost de-a face acest lucru
departe astăzi, cu siruri de caractere.

1257
01:01:39,800 --> 01:01:41,250
>> Si sunt siruri de caractere.

1258
01:01:41,250 --> 01:01:44,910
Dar, amintesc de săptămână
0, ce sunt caractere?

1259
01:01:44,910 --> 01:01:49,334
Caracterele sunt doar o abstracție
pe partea de sus a numerelor zecimale Numere,

1260
01:01:49,334 --> 01:01:52,500
și numere zecimale sunt de fapt doar un
abstracție de pe partea de sus a numerelor binare,

1261
01:01:52,500 --> 01:01:53,720
așa cum l-am definit.

1262
01:01:53,720 --> 01:01:55,540
>> Așa că caractere sunt numere.

1263
01:01:55,540 --> 01:01:58,410
Si numerele sunt caractere,
doar în funcție de context.

1264
01:01:58,410 --> 01:02:01,250
Și se pare că în interior
a unui program de calculator,

1265
01:02:01,250 --> 01:02:06,830
se poate specifica modul în care doriți să se uite
la biții din interiorul acestui program?

1266
01:02:06,830 --> 01:02:10,400
>> Reamintim din săptămâna 0 pe care am avut
Ascii, care este doar acest cod

1267
01:02:10,400 --> 01:02:11,620
scrisori de mapare către numere.

1268
01:02:11,620 --> 01:02:13,660
Și noi am spus, capitalul A este de 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B este de 66, și așa mai departe.

1270
01:02:15,860 --> 01:02:20,500
>> Și observați, avem în esență Alfabet pe
rândul de sus de aici, așa cum le-ar numi C,

1271
01:02:20,500 --> 01:02:23,400
caractere și apoi
Ints de pe al doilea rând.

1272
01:02:23,400 --> 01:02:28,180
Și se pare că se poate converti
perfect între cele două, de obicei.

1273
01:02:28,180 --> 01:02:30,042
Iar dacă vrem să facem
acest lucru în mod deliberat, noi

1274
01:02:30,042 --> 01:02:31,750
ar putea dori să abordeze
ceva de genul.

1275
01:02:31,750 --> 01:02:33,590
>> S-ar putea dori să convertească
caz de sus pentru a scădea

1276
01:02:33,590 --> 01:02:35,330
caz, sau litere mici la majuscule.

1277
01:02:35,330 --> 01:02:38,000
Și se pare că nu există
de fapt, un model de aici

1278
01:02:38,000 --> 01:02:39,900
putem îmbrățișa într-un moment.

1279
01:02:39,900 --> 01:02:44,120
Dar, să ne uităm mai întâi la un
de exemplu, de a face acest lucru în mod explicit.

1280
01:02:44,120 --> 01:02:46,340
>> Mă duc să mă întorc în IDE CS50.

1281
01:02:46,340 --> 01:02:50,640
Voi crea un
fișier numit Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Si voi merge mai departe și se adaugă meu
io.h standard la partea de sus, void main int

1283
01:02:55,960 --> 01:02:57,370
în partea superioară a funcției mele.

1284
01:02:57,370 --> 01:03:02,700
Și apoi am de gând doar pentru a face
following-- o buclă de la i este egal,

1285
01:03:02,700 --> 01:03:04,610
să zicem, 65 de ani.

1286
01:03:04,610 --> 01:03:10,460
>> Și apoi am va fi mai mică
65, plus 26 de litere din alfabet.

1287
01:03:10,460 --> 01:03:12,640
Așa că voi lăsa computerul
nu matematica pentru mine acolo.

1288
01:03:12,640 --> 01:03:15,100
Și apoi în interiorul această buclă,
ce am de gând să imprima?

1289
01:03:15,100 --> 01:03:19,230
>> % C este% i n backslash-ul.

1290
01:03:19,230 --> 01:03:21,290
Și acum vreau să conectați două valori.

1291
01:03:21,290 --> 01:03:24,530
Am pus temporar întrebare
marchează acolo pentru a invita la întrebare.

1292
01:03:24,530 --> 01:03:29,940
>> Vreau să itera de la 65 mai departe
pentru 26 de litere ale alfabetului,

1293
01:03:29,940 --> 01:03:35,190
imprimarea pe fiecare iterație care
echivalent integrală personajului.

1294
01:03:35,190 --> 01:03:38,299
Cu alte cuvinte, vreau să
itera peste 26 de numere de imprimare

1295
01:03:38,299 --> 01:03:41,590
ceea ce este caracterul Ascii, litera,
și ce este-- numărul corespunzător

1296
01:03:41,590 --> 01:03:44,650
într-adevăr doar recrearea
diagrama din acel diapozitiv.

1297
01:03:44,650 --> 01:03:47,010
Deci, ce ar trebui să fie aceste semne de întrebare?

1298
01:03:47,010 --> 01:03:51,760
>> Ei bine, se pare că a doua
ar trebui să fie doar variabila i.

1299
01:03:51,760 --> 01:03:53,860
Vreau să văd că un număr.

1300
01:03:53,860 --> 01:03:58,920
Iar argumentul din mijloc
aici, pot spune computerul

1301
01:03:58,920 --> 01:04:03,470
pentru a trata acel număr întreg
i ca un caracter, astfel încât

1302
01:04:03,470 --> 01:04:05,880
să-l înlocuiască aici pentru procente C.

1303
01:04:05,880 --> 01:04:07,990
>> Cu alte cuvinte, dacă I,
programator uman, știu

1304
01:04:07,990 --> 01:04:09,865
acestea sunt doar numere
la sfarsitul zilei.

1305
01:04:09,865 --> 01:04:12,500
Și știu că 65 ar trebui
harta la unele caractere.

1306
01:04:12,500 --> 01:04:15,310
Cu această distribuție explicită,
cu o paranteză,

1307
01:04:15,310 --> 01:04:18,840
denumirea tipului de date pe care doriți să
converti la, și o paranteză închisă,

1308
01:04:18,840 --> 01:04:21,200
vă pot spune
calculator, hei, calculator,

1309
01:04:21,200 --> 01:04:24,130
converti acest număr întreg de la un char.

1310
01:04:24,130 --> 01:04:26,250
>> Așa că, atunci când am rula acest
Programul după compilare,

1311
01:04:26,250 --> 01:04:29,740
Să vedem ce fac get-- Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Darn asta, ce am făcut greșit aici?

1313
01:04:33,020 --> 01:04:35,884
Utilizarea de identificator la negru,
Bine, nu intenționat,

1314
01:04:35,884 --> 01:04:37,800
dar hai să vedem dacă nu putem
motiv pentru asta.

1315
01:04:37,800 --> 01:04:41,220
>> Așa că linia five-- așa că nu am primit
foarte mult înainte de înșurubare.

1316
01:04:41,220 --> 01:04:42,140
Asta e ok.

1317
01:04:42,140 --> 01:04:46,560
Așa că linia 5 pentru i este egal cu 65-- eu văd.

1318
01:04:46,560 --> 01:04:50,130
Deci, amintiți că în C, spre deosebire de unele
limbi dacă aveți programare prealabilă

1319
01:04:50,130 --> 01:04:52,190
experiență, aveți
pentru a spune calculatorul,

1320
01:04:52,190 --> 01:04:55,040
spre deosebire de zero, ceea ce
tipul de variabilă este.

1321
01:04:55,040 --> 01:04:56,860
>> Am uitat o fraza cheie aici.

1322
01:04:56,860 --> 01:04:59,200
În linia de cinci, am inceput sa folosesc eu.

1323
01:04:59,200 --> 01:05:01,560
Dar nu am spus C
ce tip de date este.

1324
01:05:01,560 --> 01:05:04,570
Așa că am de gând să merg aici și
spun, ah, este un număr întreg de a face.

1325
01:05:04,570 --> 01:05:07,050
>> Acum am de gând să merg mai departe și recompilare.

1326
01:05:07,050 --> 01:05:08,080
Asta fix asta.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, asta e un fel de rece.

1328
01:05:12,660 --> 01:05:15,360
Nu numai ca este super rapid la
întrebați calculatorul la această întrebare,

1329
01:05:15,360 --> 01:05:18,885
mai degrabă decât în ​​căutarea sus pe un diapozitiv,
tipărit unul pe fiecare rând, A este de 65,

1330
01:05:18,885 --> 01:05:24,860
B este de 66, tot drumul down-- de când am
a făcut acest lucru 26 times-- la literele z,

1331
01:05:24,860 --> 01:05:25,630
care este de 90.

1332
01:05:25,630 --> 01:05:27,790
Și, de fapt, ușor
mai inteligent ar

1333
01:05:27,790 --> 01:05:31,030
au fost pentru mine să nu se bazeze
pe computer pentru a adăuga 26.

1334
01:05:31,030 --> 01:05:34,060
Aș fi putut face doar
90, de asemenea, atât de mult timp

1335
01:05:34,060 --> 01:05:37,390
ca eu nu fac aceeași greșeală de două ori.

1336
01:05:37,390 --> 01:05:41,880
Vreau să merg în sus, prin
z, nu doar în sus prin y.

1337
01:05:41,880 --> 01:05:44,000
>> Deci, asta e o distribuție explicită.

1338
01:05:44,000 --> 01:05:47,860
Se pare că acest lucru
nu este chiar necesar.

1339
01:05:47,860 --> 01:05:52,480
Lasă-mă să merg mai departe și să rulați din nou acest lucru
compilator, și executați din nou ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Se pare că, C este destul de inteligent.

1341
01:05:54,940 --> 01:05:57,150
>> Și printf, în special,
este destul de inteligent.

1342
01:05:57,150 --> 01:06:01,260
Dacă treci doar un i de două ori
pentru ambele Substituenți, printf

1343
01:06:01,260 --> 01:06:04,510
va realiza, oh, bine eu te cunosc
mi-a dat un integer-- unele număr,

1344
01:06:04,510 --> 01:06:06,380
cum ar fi 65, sau 90, sau orice altceva.

1345
01:06:06,380 --> 01:06:10,170
Dar eu văd că ai vrea să
formata acel număr ca un personaj.

1346
01:06:10,170 --> 01:06:16,460
Si astfel printf poate arunca implicit
int la un char pentru tine la fel de bine.

1347
01:06:16,460 --> 01:06:19,360
Deci asta nu e deloc o problemă.

1348
01:06:19,360 --> 01:06:23,100
>> Dar, observați, din cauza acestei echivalență
putem face de fapt acest lucru la fel de bine.

1349
01:06:23,100 --> 01:06:26,520
Lasă-mă să merg mai departe și să facă o
altă versiune a astea-- 1.c. Ascii

1350
01:06:26,520 --> 01:06:31,800
Și în loc de itera peste
numere întregi, se poate sufla într-adevăr mintea ta

1351
01:06:31,800 --> 01:06:33,610
prin iterarea peste caractere.

1352
01:06:33,610 --> 01:06:37,660
În cazul în care un char c devine de capital A, I
doresc să meargă mai departe și de a face acest lucru,

1353
01:06:37,660 --> 01:06:41,740
atâta timp cât C este mai mică sau egală
la Z. de capital și pe fiecare iterație

1354
01:06:41,740 --> 01:06:45,690
Vreau să incrementa C, eu pot
acum, în linia mea printf aici

1355
01:06:45,690 --> 01:06:51,320
să zicem, procente C este
procente i din nou, virgula C.

1356
01:06:51,320 --> 01:06:57,200
>> Și acum, eu pot merge în altă direcție,
turnare caracterul explicit

1357
01:06:57,200 --> 01:06:58,500
la un întreg.

1358
01:06:58,500 --> 01:07:00,560
Deci, din nou, de ce ai face asta?

1359
01:07:00,560 --> 01:07:03,830
E un pic ciudat pentru a sorta de
conta în termeni de caractere.

1360
01:07:03,830 --> 01:07:07,430
>> Dar, dacă înțelegi ce e
merge pe sub capota,

1361
01:07:07,430 --> 01:07:08,430
nu există într-adevăr nici o magie.

1362
01:07:08,430 --> 01:07:13,060
Spui, hei, calculator da
mi o variabilă numită C de tip char.

1363
01:07:13,060 --> 01:07:16,520
Inițializați la capitalul A. Și
observați o singură chestiune citate.

1364
01:07:16,520 --> 01:07:19,580
>> Pentru caractere în C, amintesc de la
săptămâna trecută, utilizați ghilimele simple.

1365
01:07:19,580 --> 01:07:23,720
Pentru siruri de caractere, pentru cuvinte,
fraze, utilizați ghilimele duble.

1366
01:07:23,720 --> 01:07:27,210
OK, calculator, face asta, așa
atâta timp cât caracterul este mai mic

1367
01:07:27,210 --> 01:07:28,050
sau egală cu z.

1368
01:07:28,050 --> 01:07:32,640
Și eu știu de la masa mea Ascii că toate
din aceste coduri Ascii sunt învecinate.

1369
01:07:32,640 --> 01:07:33,400
>> Nu există lacune.

1370
01:07:33,400 --> 01:07:36,737
Deci, e doar de la A la Z,
separate printr-un singur număr fiecare.

1371
01:07:36,737 --> 01:07:38,820
Și apoi eu pot incrementa
char, dacă eu chiar vreau.

1372
01:07:38,820 --> 01:07:40,390
La sfarsitul zilei,
este doar un număr.

1373
01:07:40,390 --> 01:07:41,030
Stiu asta.

1374
01:07:41,030 --> 01:07:43,670
Deci, eu pot presupune că doar pentru a adăuga 1 la acesta.

1375
01:07:43,670 --> 01:07:46,940
>> Și apoi de data aceasta, am imprima c,
și apoi echivalentul integrală.

1376
01:07:46,940 --> 01:07:50,170
Si eu nici nu trebuie exprimate explicit.

1377
01:07:50,170 --> 01:07:52,680
Eu pot lăsa printf și
Figura de calculator lucrurile,

1378
01:07:52,680 --> 01:07:57,300
astfel că acum, dacă am alerga
face Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Am obține exact același lucru la fel de bine.

1380
01:08:01,520 --> 01:08:04,530
>> Programul nefolositor, though-- nimeni
se va scrie de fapt, software-ul

1381
01:08:04,530 --> 01:08:07,549
în scopul de a da seama, ce a fost
număr care hărți la A, sau B, sau Z?

1382
01:08:07,549 --> 01:08:10,340
Tu doar o să-l Google sau
uite-l on-line, sau uite-l

1383
01:08:10,340 --> 01:08:11,650
pe un diapozitiv, sau ceva asemănător.

1384
01:08:11,650 --> 01:08:13,520
Așa că în cazul în care acest lucru nu obține de fapt, util?

1385
01:08:13,520 --> 01:08:15,960
>> Ei bine, vorbind de asta
diapozitiv, observați acolo

1386
01:08:15,960 --> 01:08:20,890
un tipar real aici între litere mari
și litere mici, care nu a fost accidentală.

1387
01:08:20,890 --> 01:08:23,760
Observați că capitalul A este de 65.

1388
01:08:23,760 --> 01:08:25,830
Minuscule a este de 97.

1389
01:08:25,830 --> 01:08:29,649
Și, cât de departe este mai mic caz o?

1390
01:08:29,649 --> 01:08:32,649
>> Asa ca 65 de ani este cât de mulți pași distanță de 97?

1391
01:08:32,649 --> 01:08:36,210
Așa că 97 minus 65 este de 32.

1392
01:08:36,210 --> 01:08:37,910
Astfel încât capitalul este o 65 de ani.

1393
01:08:37,910 --> 01:08:39,939
Dacă adăugați 32 la faptul că,
veți obține literele mici.

1394
01:08:39,939 --> 01:08:43,729
Și, în mod echivalent, dacă scădem 32,
te înapoi la capital a-- același cu B

1395
01:08:43,729 --> 01:08:46,380
la puțin b, C mare la puțin c.

1396
01:08:46,380 --> 01:08:50,670
>> Toate aceste decalaje sunt 32 în afară.

1397
01:08:50,670 --> 01:08:54,450
Acum, acest lucru s-ar părea să ne permită să
a face ceva de genul Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
sau Google Docs dispun, în cazul în care vă
poate selecta totul și apoi spune,

1399
01:08:57,729 --> 01:09:00,520
schimba toate în litere mici, sau
schimba toate la majuscule,

1400
01:09:00,520 --> 01:09:03,840
sau schimba numai primul cuvânt
a unei teze la majuscule.

1401
01:09:03,840 --> 01:09:07,390
Putem face de fapt ceva
așa noi înșine.

1402
01:09:07,390 --> 01:09:12,645
>> Lasă-mă să merg mai departe și de a salva un fișier
numită aici valorifica 0.c.

1403
01:09:12,645 --> 01:09:15,770
Și să mergem mai departe și biciul un program de
care face exact asta după cum urmează.

1404
01:09:15,770 --> 01:09:18,460
Așa că includ biblioteca CS50.

1405
01:09:18,460 --> 01:09:21,430
Și includ standardul I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Și știu că acest lucru vine în curând.

1407
01:09:22,787 --> 01:09:24,870
Așa că am de gând să-l pună în
există deja, string.h,

1408
01:09:24,870 --> 01:09:26,960
așa că am acces la
lucruri cum ar fi Stirling,

1409
01:09:26,960 --> 01:09:29,620
și apoi int void main, ca de obicei.

1410
01:09:29,620 --> 01:09:33,420
Și apoi am de gând să merg mai departe
și de a face siruri de caractere devine obține șir,

1411
01:09:33,420 --> 01:09:35,032
doar pentru a obține un șir de caractere de utilizator.

1412
01:09:35,032 --> 01:09:36,740
Și apoi voi
face cecul meu bun-simț.

1413
01:09:36,740 --> 01:09:40,510
În cazul în șir nu nul egal,
atunci este sigur pentru a continua.

1414
01:09:40,510 --> 01:09:42,000
Și ce vreau să fac?

1415
01:09:42,000 --> 01:09:48,700
Mă duc la itera de la i este egal cu 0,
și n până la lungimea șirului de caractere de s.

1416
01:09:48,700 --> 01:09:51,899
>> Si eu voi face acest lucru, atât timp cât
i este mai mică decât n, și eu, plus, plus.

1417
01:09:51,899 --> 01:09:55,060
Până în prezent, eu sunt cu adevărat doar
împrumută idei de la mai înainte.

1418
01:09:55,060 --> 01:09:57,010
Și acum am de gând să introducă o sucursală.

1419
01:09:57,010 --> 01:09:59,635
>> Deci, cred că înapoi la zero, în cazul în care
am avut aceste furci în drum,

1420
01:09:59,635 --> 01:10:05,110
și săptămâna trecută în C. voi
spun acest lucru, în cazul în care caracterul i-lea s

1421
01:10:05,110 --> 01:10:09,250
este mai mare sau
egală cu un caz mai mic,

1422
01:10:09,250 --> 01:10:13,340
si-- în Scratch te-ar literalmente
spune și, dar în C, ai spune ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- și caracterul i-lea s
este mai mică sau egală cu litere mici z,

1424
01:10:19,830 --> 01:10:21,780
hai să facem ceva interesant.

1425
01:10:21,780 --> 01:10:27,020
Hai să tipăriți, de fapt dintr-un
caracter cu nici o linie noua

1426
01:10:27,020 --> 01:10:31,760
care este personajul din șirul,
caracterul i-lea în șir.

1427
01:10:31,760 --> 01:10:37,420
>> Dar, să mergem mai departe și
scade 32 din ea.

1428
01:10:37,420 --> 01:10:42,120
Altfel, dacă personajul din
șir de caractere pe care-l căutăm

1429
01:10:42,120 --> 01:10:45,950
nu este între o mică
și puțin z, mergeți mai departe

1430
01:10:45,950 --> 01:10:48,610
și doar tipărit neschimbat.

1431
01:10:48,610 --> 01:10:50,840
Prin urmare, am introdus
această notație între paranteze

1432
01:10:50,840 --> 01:10:53,560
pentru coarde noastre pentru a ajunge la
i-lea caracter din șirul.

1433
01:10:53,560 --> 01:10:57,520
>> Am adăugat unele logica condiționată, cum ar fi
Zgârietură într-o săptămână săptămâna trecută, în cazul în care

1434
01:10:57,520 --> 01:10:59,880
Sunt doar cu ajutorul meu fundamental
înțelegerea a ceea ce este

1435
01:10:59,880 --> 01:11:01,130
merge pe sub capota.

1436
01:11:01,130 --> 01:11:04,190
Este caracterul i-lea al lui
mai mare sau egală cu o?

1437
01:11:04,190 --> 01:11:08,290
Cum ar fi, este de 97, sau 98,
sau 99, și așa mai departe?

1438
01:11:08,290 --> 01:11:11,940
>> Dar este, de asemenea, mai mică sau egală
la valoarea de litere mici z?

1439
01:11:11,940 --> 01:11:16,210
Și dacă da, ce înseamnă această linie?

1440
01:11:16,210 --> 01:11:20,250
14, acesta este un fel de
germeni de întreaga idee,

1441
01:11:20,250 --> 01:11:23,840
valorifica scrisoarea de
pur și simplu, scăzând 32 din aceasta,

1442
01:11:23,840 --> 01:11:29,370
în acest caz, pentru că știu, pe care
diagramă, modul în care sunt reprezentate numerele mele.

1443
01:11:29,370 --> 01:11:33,925
Așa că hai să mergem mai departe și a alerga acest lucru,
după compilarea valorifica 0.c,

1444
01:11:33,925 --> 01:11:36,210
și a alerga valorifica 0.

1445
01:11:36,210 --> 01:11:40,300
>> Hai să scrieți ceva de genul
Zamyla în litere mici intră.

1446
01:11:40,300 --> 01:11:42,780
Și acum avem Zamyla în majuscule.

1447
01:11:42,780 --> 01:11:45,050
Hai să introduceți Rob în litere mici.

1448
01:11:45,050 --> 01:11:46,674
Să încercăm Jason în toate cu litere mici.

1449
01:11:46,674 --> 01:11:48,590
Si ne-a păstra achiziție
capitalizarea forțată.

1450
01:11:48,590 --> 01:11:50,960
E un bug minor pe care am
un fel de nu a anticipat.

1451
01:11:50,960 --> 01:11:54,050
Observă noua mea promptă se încheie în sus
pe aceeași linie ca și numele lor,

1452
01:11:54,050 --> 01:11:55,520
care se simte un pic murdar.

1453
01:11:55,520 --> 01:11:59,170
>> Așa că am de gând să merg aici, și
de fapt, la sfârșitul acestui program

1454
01:11:59,170 --> 01:12:02,110
imprima un caracter de linie noua.

1455
01:12:02,110 --> 01:12:03,160
Asta e tot.

1456
01:12:03,160 --> 01:12:06,120
Cu printf, nu trebuie să
trece în variabile sau cod format.

1457
01:12:06,120 --> 01:12:08,460
Aveți posibilitatea să literalmente doar de imprimare
ceva de genul o linie nouă.

1458
01:12:08,460 --> 01:12:13,529
>> Așa că hai să mergem mai departe și să facă
valorifica 0 din nou, rulați din nou ea, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Și acum este un pic mai frumos.

1460
01:12:14,820 --> 01:12:17,274
Acum, prompta mea este pe linie nouă.

1461
01:12:17,274 --> 01:12:18,440
Deci asta e tot fin și bun.

1462
01:12:18,440 --> 01:12:19,910
Deci asta e un bun exemplu.

1463
01:12:19,910 --> 01:12:22,700
Dar eu nici măcar nu neapărat
Trebuie să codul greu 32.

1464
01:12:22,700 --> 01:12:23,350
Știi ce?

1465
01:12:23,350 --> 01:12:26,350
Aș putea say-- eu nu fac niciodată
amintiți-vă ce diferența este.

1466
01:12:26,350 --> 01:12:29,330
>> Dar eu știu că, dacă am
au o literă mică,

1467
01:12:29,330 --> 01:12:34,430
Vreau, în esență, pentru a scădea off
indiferent de distanța este între mică

1468
01:12:34,430 --> 01:12:39,160
o și mai mare A, pentru că dacă presupun că
toate celelalte litere sunt aceleași,

1469
01:12:39,160 --> 01:12:41,045
că ar trebui să obțineți treaba.

1470
01:12:41,045 --> 01:12:42,670
Dar, mai degrabă decât a face asta, știi ce?

1471
01:12:42,670 --> 01:12:44,240
Mai există o cale încă.

1472
01:12:44,240 --> 01:12:48,090
>> În cazul în care se valorifica 1.c-- dacă aș fi fost
pentru a pune că într-un fișier separat.

1473
01:12:48,090 --> 01:12:51,030
să-și valorifică 2.c după cum urmează.

1474
01:12:51,030 --> 01:12:53,060
Voi curăța într-adevăr asta aici.

1475
01:12:53,060 --> 01:12:57,420
Și, în loc de a avea chiar să
știu sau de îngrijire despre cele de nivel scăzut

1476
01:12:57,420 --> 01:13:01,090
detaliile de implementare, sunt în schimb
merge doar pentru a imprima un caracter,

1477
01:13:01,090 --> 01:13:04,610
citat unquote, procente C, și
apoi apelați o altă funcție care

1478
01:13:04,610 --> 01:13:09,950
există, că are un argument,
care este un personaj, ca aceasta.

1479
01:13:09,950 --> 01:13:12,630
>> Se pare ca în C, există
un alt apel de funcție

1480
01:13:12,630 --> 01:13:15,550
la partea superioară, care, ca și numele
sugerează ia un caracter

1481
01:13:15,550 --> 01:13:19,350
și-l face la cazul său superior
echivalent, și apoi se întoarce

1482
01:13:19,350 --> 01:13:21,410
astfel încât printf se poate conecta acolo.

1483
01:13:21,410 --> 01:13:25,484
Și, ca să facă acest lucru, deși, eu
Trebuie să se introducă un alt fișier.

1484
01:13:25,484 --> 01:13:28,400
Se pare ca exista un alt fișier
pe care le-ar cunoaște doar din clasă,

1485
01:13:28,400 --> 01:13:33,020
sau un manual sau o platformă online
referință, numit type.h. C

1486
01:13:33,020 --> 01:13:38,570
>> Deci, dacă am adăuga că în sus printre antetul meu
fișiere, iar acum re-compila acest program,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Hai să tastați în Zamyla în toate
litere mici, funcționează încă la fel.

1489
01:13:46,690 --> 01:13:48,040
Dar știi ce?

1490
01:13:48,040 --> 01:13:55,590
Se pare că, la partea superioară
are unele alte funcționalități.

1491
01:13:55,590 --> 01:13:58,410
>> Și lasă-mă să introducă această
comand de aici, un fel de penibil

1492
01:13:58,410 --> 01:14:00,250
numit, dar pentru om manual.

1493
01:14:00,250 --> 01:14:03,960
Se pare că, cele mai multe calculatoare Linux,
așa cum ne folosim aici-- de operare Linux

1494
01:14:03,960 --> 01:14:06,270
system-- au o comandă
numit om, care spune,

1495
01:14:06,270 --> 01:14:08,530
hei, calculator, da-mi
manualul computerului.

1496
01:14:08,530 --> 01:14:10,680
Ce dorești să
privi în sus în acest manual?

1497
01:14:10,680 --> 01:14:13,840
>> Vreau să mă uit în sus funcția
chemat la partea superioară, Enter.

1498
01:14:13,840 --> 01:14:16,070
Și este un pic criptic
pentru a citi uneori.

1499
01:14:16,070 --> 01:14:18,780
Dar observați că suntem în
manualul Linux programator.

1500
01:14:18,780 --> 01:14:19,530
Și e tot textul.

1501
01:14:19,530 --> 01:14:21,905
Și observați că acolo e
numele funcției aici.

1502
01:14:21,905 --> 01:14:25,030
Se pare ca ea are un văr numit
pentru a reduce, care face exact opusul.

1503
01:14:25,030 --> 01:14:29,710
Și o notificare în conformitate cu sinopsis, pentru a utiliza aceasta
funcționa pagina de om, ca să spunem așa,

1504
01:14:29,710 --> 01:14:32,220
îmi spune că am
Trebuie să includă c type.h.

1505
01:14:32,220 --> 01:14:33,630
Și am știut că din practică.

1506
01:14:33,630 --> 01:14:36,210
>> Aici, eu care arată cele două
prototipuri pentru funcția,

1507
01:14:36,210 --> 01:14:39,070
astfel încât, dacă am dori vreodată să utilizați acest
Știu ce le iau ca intrare,

1508
01:14:39,070 --> 01:14:40,652
și ceea ce se întorc ca ieșire.

1509
01:14:40,652 --> 01:14:42,360
Și apoi, dacă am citit
descrierea, eu văd

1510
01:14:42,360 --> 01:14:44,820
mai în detaliu ceea ce face funcția.

1511
01:14:44,820 --> 01:14:48,100
Dar, mai important, dacă
Mă uit sub valoarea de returnare,

1512
01:14:48,100 --> 01:14:51,710
se spune valoarea returnată este
cea a literei convertite,

1513
01:14:51,710 --> 01:14:57,880
sau C, intrarea originală, dacă
conversia nu a fost posibilă.

1514
01:14:57,880 --> 01:15:01,992
>> Cu alte cuvinte, la partea superioară va încerca
pentru a converti o literă la majuscule.

1515
01:15:01,992 --> 01:15:03,450
Și dacă este așa, o să-l întoarcă.

1516
01:15:03,450 --> 01:15:07,010
Dar, în cazul în care nu se poate pentru unii reason--
Poate că e cazul deja de sus,

1517
01:15:07,010 --> 01:15:09,550
Poate că e un punct de exclamare
sau alte punctuation--

1518
01:15:09,550 --> 01:15:12,200
este doar de gând să
returnează originalul C,

1519
01:15:12,200 --> 01:15:17,340
ceea ce înseamnă că pot face codul meu
mai bine proiectate după cum urmează.

1520
01:15:17,340 --> 01:15:20,580
>> Nu am nevoie de toate
aceste linii darn de cod.

1521
01:15:20,580 --> 01:15:22,610
Toate liniile l-am
doar a subliniat poate

1522
01:15:22,610 --> 01:15:28,700
fi prăbușit într-un singur simplu
line, care este astea-- la sută printf

1523
01:15:28,700 --> 01:15:33,510
c pentru suportul superior S i.

1524
01:15:33,510 --> 01:15:36,090
Și acest lucru ar fi o
exemplu de design mai bun.

1525
01:15:36,090 --> 01:15:40,040
>> De ce să pună în aplicare în 7 sau 8 linii
de cod, oricare ar fi fost eu doar

1526
01:15:40,040 --> 01:15:44,960
șters, atunci când se poate prăbuși în schimb
toate că procesul de luare a deciziilor și logica

1527
01:15:44,960 --> 01:15:49,620
într-o singură linie, 13 acum, că
se bazează pe o bibliotecă de function--

1528
01:15:49,620 --> 01:15:53,430
o funcție care vine cu C, dar că
face exact ceea ce vrei să faci.

1529
01:15:53,430 --> 01:15:55,295
Si, sincer, chiar dacă
ea nu a venit cu C,

1530
01:15:55,295 --> 01:15:58,880
ai putea pune în aplicare le ca
am vazut, cu a lua int negativ

1531
01:15:58,880 --> 01:16:01,700
și pentru a obține pozitiv int săptămâna trecută, de asemenea.

1532
01:16:01,700 --> 01:16:03,470
>> Acest cod de acum este mult mai ușor de citit.

1533
01:16:03,470 --> 01:16:06,670
Și, într-adevăr, dacă vom defila în sus,
uite cât de mult mai compact

1534
01:16:06,670 --> 01:16:08,360
această versiune a programului meu este.

1535
01:16:08,360 --> 01:16:11,230
Este un pic mai grea de top acum,
cu toate acestea include.

1536
01:16:11,230 --> 01:16:14,380
Dar asta e în regulă, pentru că acum sunt în picioare
pe umerii programatori

1537
01:16:14,380 --> 01:16:15,300
înaintea mea.

1538
01:16:15,300 --> 01:16:18,440
Si oricine ar fi fost cine
puse în aplicare la partea superioară într-adevăr

1539
01:16:18,440 --> 01:16:21,470
mi-a făcut o favoare, la fel ca oricine
Stirling a implementat într-adevăr

1540
01:16:21,470 --> 01:16:24,790
mi-a făcut o favoare ceva timp în urmă.

1541
01:16:24,790 --> 01:16:26,970
Și așa acum avem un
mai bine programul de proiectare

1542
01:16:26,970 --> 01:16:31,680
care pune în aplicare aceeași logică exactă.

1543
01:16:31,680 --> 01:16:35,580
>> Vorbind de Stirling, să
mă să merg mai departe și fac acest lucru.

1544
01:16:35,580 --> 01:16:38,320
Lasă-mă să merg mai departe și de a salva
acest fișier ca stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Și se pare, putem coaja înapoi
un alt strat destul de simplu acum.

1546
01:16:43,255 --> 01:16:45,630
Mă duc să merg mai departe și bici
un alt program, în principal

1547
01:16:45,630 --> 01:16:49,759
aici că pur și simplu re-unelte
Lungimea șir după cum urmează.

1548
01:16:49,759 --> 01:16:52,300
Deci, aici este o linie de cod care
mă primește un șir de caractere de utilizator.

1549
01:16:52,300 --> 01:16:53,910
Continuăm să utilizați acest lucru din nou și din nou.

1550
01:16:53,910 --> 01:16:58,900
Permiteți-mi să mă dau o variabilă numită
n de tip int care stochează un număr.

1551
01:16:58,900 --> 01:17:02,490
>> Și lasă-mă să merg mai departe și
face următoarea logică.

1552
01:17:02,490 --> 01:17:15,610
În timp ce caracterul n-lea, în s nu
nu este egal cu 0 backslash, merge mai departe

1553
01:17:15,610 --> 01:17:17,930
și creșterea n.

1554
01:17:17,930 --> 01:17:23,506
Și apoi imprima procente printf i n.

1555
01:17:23,506 --> 01:17:29,200
Eu susțin că acest program aici,
fără a apela lungimea șirului de caractere,

1556
01:17:29,200 --> 01:17:31,150
cifrele lungimea unui șir de caractere.

1557
01:17:31,150 --> 01:17:34,600
>> Iar magia este în întregime
încapsulate în linia 8

1558
01:17:34,600 --> 01:17:39,830
aici cu ceea ce arata ca sintaxă nouă,
acest backslash 0 în ghilimele simple.

1559
01:17:39,830 --> 01:17:41,360
Dar de ce este asta?

1560
01:17:41,360 --> 01:17:44,100
Ei bine, ia în considerare ceea ce a fost
întâmplă tot acest timp.

1561
01:17:44,100 --> 01:17:47,990
>> Și, ca o parte, înainte să uit, dau seama
de asemenea, că, în plus față de paginile man

1562
01:17:47,990 --> 01:17:50,920
care vin cu un tipic
sistem Linux cum ar fi CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
dăm seama că noi,
Personalul curs, au, de asemenea,

1564
01:17:53,770 --> 01:17:56,030
a făcut o versiune site
din aceeași idee numită

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, care are
toate aceste pagini același om,

1566
01:17:59,940 --> 01:18:02,020
toate aceeași
documentație, precum și

1567
01:18:02,020 --> 01:18:05,730
o cutie mică la partea de sus, care permite
să converti toate în mod echitabil

1568
01:18:05,730 --> 01:18:09,025
limba Arcane în mai puțin confortabil
modul, în cazul în care noi, cadrele didactice,

1569
01:18:09,025 --> 01:18:12,150
au trecut prin și au încercat să simplifice
o parte din limba pentru a păstra lucrurile

1570
01:18:12,150 --> 01:18:14,830
axat pe idei, și nu
unele dintre aspectele tehnice.

1571
01:18:14,830 --> 01:18:20,070
Astfel încât să păstreze în minte, reference.cs50.net
ca o altă resursă, de asemenea.

1572
01:18:20,070 --> 01:18:23,800
>> Dar de ce funcționează lungimea șir în
modul în care am propus un moment în urmă?

1573
01:18:23,800 --> 01:18:25,160
Iată numele lui Zamyla din nou.

1574
01:18:25,160 --> 01:18:27,690
Si aici e numele lui Zamyla
cutie în, așa cum am continua să faci,

1575
01:18:27,690 --> 01:18:31,360
pentru a picta o imagine a acesteia fiind,
într-adevăr, doar o secvență de caractere.

1576
01:18:31,360 --> 01:18:34,260
Dar Zamyla nu există
în mod izolat, într-un program.

1577
01:18:34,260 --> 01:18:37,420
>> Atunci când scrieți și executați un program,
utilizați Mac-ul sau PC-ul

1578
01:18:37,420 --> 01:18:40,010
ca memorie, sau RAM ca să spunem așa.

1579
01:18:40,010 --> 01:18:42,620
Și vă puteți gândi
computerul dvs. ca având

1580
01:18:42,620 --> 01:18:44,730
o mulțime de GB de memorie în aceste zile.

1581
01:18:44,730 --> 01:18:47,700
Și un concert înseamnă miliarde,
astfel încât miliarde de bytes.

1582
01:18:47,700 --> 01:18:48,910
>> Dar hai să derulați înapoi în timp.

1583
01:18:48,910 --> 01:18:51,530
Și să presupunem că noi folosim
un calculator foarte vechi, care

1584
01:18:51,530 --> 01:18:55,150
are doar 32 de bytes de memorie.

1585
01:18:55,150 --> 01:18:59,310
Am putea, pe ecranul computerului meu,
trage pur și simplu acest lucru, după cum urmează.

1586
01:18:59,310 --> 01:19:05,240
>> Aș putea spune pur și simplu că mi
computer are toate această memorie.

1587
01:19:05,240 --> 01:19:08,830
Și acest lucru este ca un stick de memorie, în cazul în care
vă amintiți imaginea noastră de ultima dată.

1588
01:19:08,830 --> 01:19:11,670
Și, dacă aș împărți
acest lucru în destul de ori,

1589
01:19:11,670 --> 01:19:15,040
Eu pretind că am 32 de octeți
de memorie de pe ecran.

1590
01:19:15,040 --> 01:19:18,239
>> Acum, în realitate, eu pot doar
trage până în prezent pe acest ecran de aici.

1591
01:19:18,239 --> 01:19:20,280
Așa că am de gând să merg mai departe,
și doar prin convenție,

1592
01:19:20,280 --> 01:19:24,050
trage memoria computerului meu ca
grilă, nu doar ca o singură linie dreaptă.

1593
01:19:24,050 --> 01:19:28,190
Mai exact, eu pretind acum că
această grilă, această 8 prin 4 grilă,

1594
01:19:28,190 --> 01:19:31,800
doar reprezintă toți cei 32 de bytes
de memorie disponibil în Mac-ul meu,

1595
01:19:31,800 --> 01:19:33,030
sau disponibil în PC-ul meu.

1596
01:19:33,030 --> 01:19:34,780
Si acestea sunt ambalate
pe două linii, doar

1597
01:19:34,780 --> 01:19:38,030
deoarece se potrivește mai mult pe ecran.

1598
01:19:38,030 --> 01:19:40,800
Dar acesta este primul octet.

1599
01:19:40,800 --> 01:19:41,990
Acesta este al doilea octet.

1600
01:19:41,990 --> 01:19:43,300
Acesta este al treilea octet.

1601
01:19:43,300 --> 01:19:45,310
>> Și acest lucru este octet al 32-lea.

1602
01:19:45,310 --> 01:19:52,910
Sau, dacă ne gândim ca un computer
om de știință, acest lucru este octet 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Asa ca aveti 0 la 31, în cazul în care
începe numărarea de la 0 ° C.

1604
01:19:55,950 --> 01:19:59,830
>> Așa că, dacă vom folosi un program de
că apelurile obține șir de caractere,

1605
01:19:59,830 --> 01:20:05,280
și vom obține un șir de la om
așa cum am numit Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
cum în lume face
urmări a vă menține computerul de care octet,

1607
01:20:09,430 --> 01:20:12,230
care bucată de memorie,
aparține care șir?

1608
01:20:12,230 --> 01:20:16,270
Cu alte cuvinte, dacă vom proceda la
introduceți un alt nume în computer,

1609
01:20:16,270 --> 01:20:19,890
ca aceasta Andi, numindu
obține șir de caractere pentru a doua oară,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I trebuie să ajungă în
memoriei calculatorului, de asemenea.

1611
01:20:23,030 --> 01:20:23,850
Dar cum?

1612
01:20:23,850 --> 01:20:29,700
>> Ei bine, se pare că dedesubtul
hota, ceea ce face C atunci când se stochează șiruri

1613
01:20:29,700 --> 01:20:35,080
că tipurile umane, sau că
provin dintr-o altă sursă, este

1614
01:20:35,080 --> 01:20:39,190
delimiteaza sfârșitul celor cu
un backslash character-- specială

1615
01:20:39,190 --> 01:20:44,750
0, care este doar un mod special
de a spune 80 de biți într-un rând.

1616
01:20:44,750 --> 01:20:47,950
>> Așa că a-- aceasta este retragerea numarul 97.

1617
01:20:47,950 --> 01:20:51,770
Astfel încât unele model de 8 biți
reprezintă număr zecimal 97.

1618
01:20:51,770 --> 01:20:58,070
Acest lucru backslash 0 este literalmente numărul
0, Nul a.k.a., N-U-L, spre deosebire de mai devreme,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, pe care am discutat.

1620
01:20:59,630 --> 01:21:05,700
Dar pentru moment, doar știu că acest lucru
backslash 0 este la doar 80 de biți într-un rând.

1621
01:21:05,700 --> 01:21:09,810
>> Și este doar linia urmatoare în
nisip care spune nimic la stânga

1622
01:21:09,810 --> 01:21:12,610
aparține unuia șir de caractere, sau un singur tip de date.

1623
01:21:12,610 --> 01:21:15,480
Și orice la dreapta
face parte din altceva.

1624
01:21:15,480 --> 01:21:17,440
Numele lui Andi, între timp,
care doar vizual

1625
01:21:17,440 --> 01:21:21,310
se întâmplă să-și încheie pe cealaltă linie,
dar asta e doar un detaliu estetic,

1626
01:21:21,310 --> 01:21:23,990
în mod similar, este terminată Nul.

1627
01:21:23,990 --> 01:21:29,290
>> Este un șir de caractere A-un N-D-I,
plus un caracter secret de-al cincilea,

1628
01:21:29,290 --> 01:21:33,560
toate 0 biți, pe care tocmai l delimiteze
la sfârșitul numelui lui Andi, de asemenea.

1629
01:21:33,560 --> 01:21:37,120
Iar dacă facem apel primi șir pentru a treia oară
în computer pentru a obține un șir de caractere cum ar fi

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, la fel este Maria
Numele Nul terminat cu backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Acest lucru este fundamental diferit
de la modul în care un calculator ar fi în mod tipic

1632
01:21:47,170 --> 01:21:51,850
stoca un număr întreg, sau un float, sau alt
tipuri de date încă, deoarece amintesc,

1633
01:21:51,850 --> 01:21:57,420
un număr întreg este de obicei de 32 de biți, sau
4 bytes, sau poate chiar 64 de biți,

1634
01:21:57,420 --> 01:21:59,100
sau opt octeți.

1635
01:21:59,100 --> 01:22:02,620
Dar, de multe într-un calculator Primitive
într-un limbaj de programare

1636
01:22:02,620 --> 01:22:05,550
au un număr fix de
bytes sub hood--

1637
01:22:05,550 --> 01:22:08,100
poate 1, poate 2, poate 4, poate 8.

1638
01:22:08,100 --> 01:22:13,250
>> Dar, siruri de caractere, prin design, au un
Numărul dinamic de caractere.

1639
01:22:13,250 --> 01:22:16,980
Dacă nu știi în avans, până la
a omului tipurile în Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
sau M-A-R-I-A, sau A-N-D-I. Dacă nu știi
de câte ori utilizatorul va lovi

1641
01:22:21,400 --> 01:22:22,070
tastatura.

1642
01:22:22,070 --> 01:22:26,490
Prin urmare, nu știi cum
multe caractere in avans

1643
01:22:26,490 --> 01:22:27,540
vei avea nevoie.

1644
01:22:27,540 --> 01:22:31,840
>> Și așa C doar un fel de frunze ca un
breadcrumb secrete sub capota

1645
01:22:31,840 --> 01:22:32,960
la sfârșitul șirului.

1646
01:22:32,960 --> 01:22:39,280
După stocarea Z-A-M-Y-L-A în memorie,
ea, de asemenea, pune doar echivalentul

1647
01:22:39,280 --> 01:22:40,210
unei perioade.

1648
01:22:40,210 --> 01:22:45,060
La sfârșitul unei propoziții,
pune 80 de biți, astfel încât

1649
01:22:45,060 --> 01:22:49,120
să vă amintiți unde
Zamyla începe și se termină.

1650
01:22:49,120 --> 01:22:51,490
>> Deci, ce e legătura,
apoi, la acest program?

1651
01:22:51,490 --> 01:22:55,190
Acest program aici, Stirling,
este pur și simplu un mecanism

1652
01:22:55,190 --> 01:22:57,970
pentru a obține un șir de caractere
de la utilizator, linia 6.

1653
01:22:57,970 --> 01:23:01,160
Linia 7, declar o variabilă
numit n și setați-l egal cu 0.

1654
01:23:01,160 --> 01:23:08,680
>> Și apoi, în linia 8, pur și simplu am întrebat
întrebare, în timp ce caracterul n-lea nu

1655
01:23:08,680 --> 01:23:12,120
nu este egal cu 0 toate bits--
cu alte cuvinte, nu

1656
01:23:12,120 --> 01:23:14,500
egală cu această specială
caracter, backslash 0, care

1657
01:23:14,500 --> 01:23:18,470
a fost doar că character-- Nul speciale
merge mai departe și doar incrementa n.

1658
01:23:18,470 --> 01:23:21,460
>> Și continua să faci asta, și să păstreze
făcând-o și continua să faci asta.

1659
01:23:21,460 --> 01:23:23,430
Și astfel, chiar dacă în
trecut le-am folosit eu,

1660
01:23:23,430 --> 01:23:25,181
Este foarte bine
semantically de a utiliza n,

1661
01:23:25,181 --> 01:23:27,430
dacă doar încerci să
Numar de data aceasta în mod deliberat,

1662
01:23:27,430 --> 01:23:28,720
și vreau doar să-l sun n.

1663
01:23:28,720 --> 01:23:34,720
Deci, acest lucru păstrează doar pune întrebarea,
este caracterul n-lea al lui toate 0s?

1664
01:23:34,720 --> 01:23:38,470
În cazul în care nu, uita-te la aspectul următor,
uita-te la următorul, uita-te la următorul,

1665
01:23:38,470 --> 01:23:39,460
uita-te la următorul.

1666
01:23:39,460 --> 01:23:45,540
>> Dar, de îndată ce veți vedea backslash 0,
oprește această linie loop-- 9 prin 11--.

1667
01:23:45,540 --> 01:23:49,640
Te rupe din bucla in timp ce,
lăsând în interiorul acelei variabile n

1668
01:23:49,640 --> 01:23:54,530
un număr total al tuturor
caractere din șirul văzut,

1669
01:23:54,530 --> 01:23:55,660
i astfel imprimarea.

1670
01:23:55,660 --> 01:23:56,760
Așa că hai să încercăm acest lucru.

1671
01:23:56,760 --> 01:23:59,500
>> Lasă-mă să merg mai departe și, fără
folosind funcția Stirling,

1672
01:23:59,500 --> 01:24:04,240
dar folosind doar propria mea versiune Homegrown
numit aici Stirling, lasă-mă să merg mai departe

1673
01:24:04,240 --> 01:24:07,700
și a alerga Stirling, tastați ceva
cum ar fi Zamyla, pe care știu dinainte

1674
01:24:07,700 --> 01:24:08,670
este de șase caractere.

1675
01:24:08,670 --> 01:24:10,080
Hai să vedem dacă funcționează.

1676
01:24:10,080 --> 01:24:10,920
Într-adevăr, este de șase.

1677
01:24:10,920 --> 01:24:15,257
Să încercăm cu Rob, trei personaje,
trei personaje la fel de bine, și așa mai departe.

1678
01:24:15,257 --> 01:24:17,340
Deci, asta e tot ce se întâmplă
pe sub capota.

1679
01:24:17,340 --> 01:24:19,548
Și observați conexiunile,
apoi, cu prima săptămână

1680
01:24:19,548 --> 01:24:22,370
de clasă, în cazul în care am vorbit despre
ceva de genul abstractizare,

1681
01:24:22,370 --> 01:24:26,960
care este doar această stratificare de idei, sau
complexitate, pe partea de sus a principiilor de bază.

1682
01:24:26,960 --> 01:24:30,710
Aici, suntem un fel de a privi
sub capota lui Stirling,

1683
01:24:30,710 --> 01:24:33,510
ca să spunem așa, să ne dăm seama,
cum ar fi pus în aplicare?

1684
01:24:33,510 --> 01:24:35,232
>> Si am putea re-pune în aplicare noi înșine.

1685
01:24:35,232 --> 01:24:37,440
Dar noi niciodată nu merge
pentru a re-punerea în aplicare a Stirling.

1686
01:24:37,440 --> 01:24:39,780
Noi doar o să
utilizați în ordine Stirling

1687
01:24:39,780 --> 01:24:42,100
pentru a obține de fapt, unele de lungime siruri de caractere.

1688
01:24:42,100 --> 01:24:44,200
>> Dar nu e nici o magie
sub capota.

1689
01:24:44,200 --> 01:24:46,716
Dacă știți că dedesubt
capota, un șir de caractere

1690
01:24:46,716 --> 01:24:48,090
este doar o secvență de caractere.

1691
01:24:48,090 --> 01:24:51,090
Și acea secvență de caractere
toate pot fi abordate numeric

1692
01:24:51,090 --> 01:24:53,330
cu suport de 0, placuta
1, suport 2, și tu

1693
01:24:53,330 --> 01:24:57,420
știu că, la sfârșitul unui șir de caractere este
caracter special, vă puteți da seama

1694
01:24:57,420 --> 01:25:01,710
cum să facă mai nimic într-un
Programul, pentru că toate se reduce la

1695
01:25:01,710 --> 01:25:03,400
este citirea și scrierea de memorie.

1696
01:25:03,400 --> 01:25:06,130
Aceasta este, în schimbare și în căutarea
în memorie, sau lucrurile în mișcare

1697
01:25:06,130 --> 01:25:10,940
în jurul valorii în memorie, lucruri de imprimare
pe ecran, și așa mai departe.

1698
01:25:10,940 --> 01:25:14,800
>> Așa că hai să folosim acum acest nou descoperita
înțelegere a ceea ce siruri de fapt

1699
01:25:14,800 --> 01:25:17,910
sunt sub capota, si
coaja de spate un alt strat

1700
01:25:17,910 --> 01:25:20,080
că până acum ne-am
ignorat cu totul.

1701
01:25:20,080 --> 01:25:22,650
În special, orice moment
am implementat un program,

1702
01:25:22,650 --> 01:25:25,930
am avut această linie de cod
lângă partea de sus a declara principal.

1703
01:25:25,930 --> 01:25:27,810
Si ne-am specificat void main int.

1704
01:25:27,810 --> 01:25:31,240
>> Iar acel gol în interiorul paranteze
a fost spus tot acest timp că principala

1705
01:25:31,240 --> 01:25:33,440
ea însăși nu ia nici un argument.

1706
01:25:33,440 --> 01:25:36,210
Orice intrare care este principala
mergi pentru a obține de la utilizator

1707
01:25:36,210 --> 01:25:39,020
trebuie să provină din alte
mecanism, cum ar fi get int

1708
01:25:39,020 --> 01:25:42,040
sau de a lua float, sau pentru a obține șir de caractere,
sau o altă funcție.

1709
01:25:42,040 --> 01:25:44,710
Dar se pare că
atunci când scrie un program,

1710
01:25:44,710 --> 01:25:47,690
puteți specifica de fapt,
că acest program va

1711
01:25:47,690 --> 01:25:51,730
ia de la om intrări
la linia de comandă în sine.

1712
01:25:51,730 --> 01:25:56,310
>> Cu alte cuvinte, chiar dacă până acum
au fost difuzate doar ./hello salut

1713
01:25:56,310 --> 01:26:00,312
sau programe similare, toate cele trei opțiuni
alte programe pe care le-am fost folosind,

1714
01:26:00,312 --> 01:26:02,770
că noi înșine nu am scris,
au fost luati, se pare,

1715
01:26:02,770 --> 01:26:05,210
linie de comandă arguments--
lucruri cum ar fi marca.

1716
01:26:05,210 --> 01:26:07,450
Tu spui ceva de genul marca,
și apoi un al doilea cuvânt.

1717
01:26:07,450 --> 01:26:10,950
Sau zăngăni, tu spui clang, și apoi
un al doilea cuvânt, numele unui fișier.

1718
01:26:10,950 --> 01:26:14,410
>> Sau chiar RM sau CP, după cum s-ar putea
au văzut sau utilizate deja

1719
01:26:14,410 --> 01:26:15,880
pentru a elimina sau a copia fișiere.

1720
01:26:15,880 --> 01:26:18,920
Toți cei care iau așa-numitele
linie de comandă arguments--

1721
01:26:18,920 --> 01:26:21,130
cuvinte suplimentare la terminal prompt.

1722
01:26:21,130 --> 01:26:23,260
Dar, până în prezent, noi
noi nu am avut

1723
01:26:23,260 --> 01:26:27,080
acest lux de a lua de intrare de la
utilizator atunci când el sau ea se execută efectiv

1724
01:26:27,080 --> 01:26:29,120
programul in sine, la linia de comandă.

1725
01:26:29,120 --> 01:26:33,710
>> Dar putem face acest lucru prin re-declarând
principal în mișcare înainte, nu ca având

1726
01:26:33,710 --> 01:26:36,750
nule în paranteze,
dar aceste două argumente

1727
01:26:36,750 --> 01:26:40,600
instead-- primul un număr întreg,
iar al doilea ceva

1728
01:26:40,600 --> 01:26:44,170
nou, ceva ce vom suna
o matrice, ceva similar în spirit

1729
01:26:44,170 --> 01:26:49,220
ceea ce am văzut în Scratch ca o listă, dar
o serie de șiruri, după cum vom vedea în curând.

1730
01:26:49,220 --> 01:26:51,790
Dar, să vedem acest lucru
Ca exemplu, înainte

1731
01:26:51,790 --> 01:26:53,690
distinge exact ceea ce înseamnă că.

1732
01:26:53,690 --> 01:26:56,520
>> Așa că, dacă mă duc în CS50 IDE
aici, m-am dus mai departe

1733
01:26:56,520 --> 01:27:01,840
și a declarat într-un fișier numit
argv0.c următorul șablon.

1734
01:27:01,840 --> 01:27:04,120
Și observați singurul lucru
care este diferit de până acum

1735
01:27:04,120 --> 01:27:08,570
este că m-am schimbat void int
argc șir de caractere argv placuta deschis, aproape

1736
01:27:08,570 --> 01:27:09,070
placuta.

1737
01:27:09,070 --> 01:27:11,730
Și observați pentru moment, există
nimic în interiorul acestor paranteze.

1738
01:27:11,730 --> 01:27:12,620
>> Nu există nici un număr.

1739
01:27:12,620 --> 01:27:15,070
Și nu există nici eu, sau
n, sau orice altă literă.

1740
01:27:15,070 --> 01:27:17,010
Sunt doar folosind
paranteze pătrate pentru acum,

1741
01:27:17,010 --> 01:27:19,510
din motive noi vom veni
înapoi la un moment.

1742
01:27:19,510 --> 01:27:21,330
>> Și acum, ce am de gând să fac asta.

1743
01:27:21,330 --> 01:27:26,680
În cazul în care este egal cu argc este egal cu 2--
și reamintească faptul că este egal la egal la egal

1744
01:27:26,680 --> 01:27:30,040
este operatorul de egalitate comparat
la stânga și la dreapta pentru egalitate.

1745
01:27:30,040 --> 01:27:31,790
Nu-i cesiunea
operatorul, care este

1746
01:27:31,790 --> 01:27:36,510
semnul egal unic, ceea ce înseamnă copie
de la dreapta la stânga, o anumită valoare.

1747
01:27:36,510 --> 01:27:42,840
>> În cazul în care este egal cu argc este egal cu 2, vreau să
să zicem, printf, Buna ziua, procente, noua linie,

1748
01:27:42,840 --> 01:27:47,340
și apoi conectați in-- și aici este noul
Suport argv trick-- 1, din motive

1749
01:27:47,340 --> 01:27:48,840
că vom reveni la un moment.

1750
01:27:48,840 --> 01:27:52,110
Altfel, dacă argc nu
egal cu 2, știi ce?

1751
01:27:52,110 --> 01:27:57,400
Să mergem mai departe și, ca de obicei, de imprimare
out salut lume, cu nici o schimbare.

1752
01:27:57,400 --> 01:28:02,710
>> Asa ca s-ar părea că, dacă argc, care
reprezintă numărul de argument, este egal cu 2,

1753
01:28:02,710 --> 01:28:04,740
Am de gând să imprima
salut ceva sau altul.

1754
01:28:04,740 --> 01:28:07,560
În caz contrar, în mod implicit, sunt
va imprima Bună ziua lume.

1755
01:28:07,560 --> 01:28:08,770
Deci, ce înseamnă asta?

1756
01:28:08,770 --> 01:28:15,550
>> Ei bine, lasă-mă să merg mai departe și de a salva
acest fișier, și apoi faceți face argv0,

1757
01:28:15,550 --> 01:28:18,940
și apoi ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Și se spune Salut lume.

1759
01:28:20,300 --> 01:28:21,260
Acum, de ce e asta?

1760
01:28:21,260 --> 01:28:24,730
>> Ei bine, se pare că oricând aveți
rula un program de la linia de comandă,

1761
01:28:24,730 --> 01:28:29,570
vă sunt de umplere în ceea ce noi vom
numesc în general, un vector de argument.

1762
01:28:29,570 --> 01:28:33,100
Cu alte cuvinte, în mod automat
calculator, sistemul de operare,

1763
01:28:33,100 --> 01:28:38,340
va înmâna programul
ea însăși o listă cu toate cuvintele

1764
01:28:38,340 --> 01:28:40,850
că omul tastat la
prompt, în cazul în care

1765
01:28:40,850 --> 01:28:43,790
programator doresc să facă
ceva cu aceste informații.

1766
01:28:43,790 --> 01:28:48,540
Și, în acest caz, singurul cuvânt
Am tastat la prompt este ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Și, astfel încât numărul de argumente care este
fiind trecut la programul meu este doar unul.

1768
01:28:55,420 --> 01:28:58,880
Cu alte cuvinte, argumentul
conta, altfel cunoscut sub numele de argc

1769
01:28:58,880 --> 01:29:00,970
aici, ca un întreg, este doar una.

1770
01:29:00,970 --> 01:29:03,000
Una, desigur, nu egal cu doi.

1771
01:29:03,000 --> 01:29:05,980
Și, astfel încât aceasta este ceea ce se imprimă, hello world.

1772
01:29:05,980 --> 01:29:08,170
>> Dar, lasă-mă să iau acest lucru undeva.

1773
01:29:08,170 --> 01:29:09,930
Permiteți-mi să spun, argv0.

1774
01:29:09,930 --> 01:29:12,740
Și apoi cum despre Maria?

1775
01:29:12,740 --> 01:29:14,990
Și apoi apăsați pe Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Și observați ce se întâmplă în mod magic aici.

1777
01:29:18,020 --> 01:29:22,640
Acum, în loc de lumi salut, am
a schimbat comportamentul acestui program

1778
01:29:22,640 --> 01:29:26,310
prin luarea de intrare nu de la get
șir de caractere sau o altă funcție,

1779
01:29:26,310 --> 01:29:30,570
dar, de la, aparent, comanda mea
în sine, ceea ce am scris inițial în limba.

1780
01:29:30,570 --> 01:29:35,720
Și eu pot juca acest joc din nou
schimbându-l la Stelios, de exemplu.

1781
01:29:35,720 --> 01:29:38,400
>> Și acum văd un alt nume încă.

1782
01:29:38,400 --> 01:29:40,540
Si aici, am putea spune Andi.

1783
01:29:40,540 --> 01:29:42,137
Și, aș putea spune Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Și noi putem juca acest joc toată ziua,
doar conectarea la valori diferite,

1785
01:29:45,220 --> 01:29:49,550
atât timp cât am oferi exact
două cuvinte la prompt,

1786
01:29:49,550 --> 01:29:52,260
astfel încât argc, conta argumentul meu, este de 2.

1787
01:29:52,260 --> 01:29:57,240
>> Am vedea că numele conectat
printf, pe această condiție aici?

1788
01:29:57,240 --> 01:30:00,550
Așa că se pare că avem acum
capacitatea expresivă

1789
01:30:00,550 --> 01:30:04,410
de a lua de intrare de la un alt mecanism,
din linia de comandă așa-numitele,

1790
01:30:04,410 --> 01:30:07,000
mai degrabă decât să aștepte
până când utilizatorul execută programul,

1791
01:30:07,000 --> 01:30:10,220
și apoi cere el sau ea
folosind ceva de genul șir get.

1792
01:30:10,220 --> 01:30:11,230
>> Deci, ce e asta?

1793
01:30:11,230 --> 01:30:15,010
Argc, din nou, este doar un număr întreg,
numărul de words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
că utilizatorul furnizate la
promptă, la fereastra terminalului,

1795
01:30:18,540 --> 01:30:20,110
inclusiv numele programului.

1796
01:30:20,110 --> 01:30:23,340
Așa că ./argv0 noastră este, în mod eficient,
numele programului,

1797
01:30:23,340 --> 01:30:24,520
sau cum am rulat programul.

1798
01:30:24,520 --> 01:30:25,810
>> Care contează ca un cuvânt.

1799
01:30:25,810 --> 01:30:27,080
Așa că argc ar fi 1.

1800
01:30:27,080 --> 01:30:29,750
Dar când am scrie Stelios, sau
Andi, sau Zamyla, sau Maria,

1801
01:30:29,750 --> 01:30:31,660
înseamnă că contorul de argumente este de două.

1802
01:30:31,660 --> 01:30:33,910
Și așa acum există două cuvinte pronunțate în.

1803
01:30:33,910 --> 01:30:36,070
>> Și observați, putem continua această logică.

1804
01:30:36,070 --> 01:30:39,050
Dacă aș fi spus de fapt
ceva de genul Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
un nume complet, trecând astfel
trei argumente în total,

1806
01:30:42,200 --> 01:30:47,410
acum spune implicit din nou,
pentru că, desigur, 3 nu egal cu 2.

1807
01:30:47,410 --> 01:30:54,080
>> Și, în acest fel, nu am
accesul prin argv acest nou argument

1808
01:30:54,080 --> 01:30:56,080
că am putea punct de vedere tehnic
suna orice vrem.

1809
01:30:56,080 --> 01:30:58,940
Dar, prin convenție, este
argv și argc, respectiv.

1810
01:30:58,940 --> 01:31:04,470
Argv, vector argument, este un fel
un sinonim pentru o programare

1811
01:31:04,470 --> 01:31:07,140
facilitate în C numită o matrice.

1812
01:31:07,140 --> 01:31:14,410
>> O matrice este o listă de valori similare
înapoi, în spate, în spate, în spate.

1813
01:31:14,410 --> 01:31:17,810
Cu alte cuvinte, în cazul în care unul este chiar aici, în
RAM, următoarea este chiar lângă el,

1814
01:31:17,810 --> 01:31:18,800
și chiar lângă el.

1815
01:31:18,800 --> 01:31:20,101
Ei nu sunt peste tot.

1816
01:31:20,101 --> 01:31:23,100
Și aceasta din urmă scenariu, în cazul în care lucrurile
sunt peste tot în memorie,

1817
01:31:23,100 --> 01:31:25,082
poate fi de fapt o caracteristică puternic.

1818
01:31:25,082 --> 01:31:28,040
Dar vom reveni la faptul că atunci când ne
vorbim despre structuri de date columbofil.

1819
01:31:28,040 --> 01:31:32,260
Pentru moment, o matrice este doar un
bucată de memorie contiguă,

1820
01:31:32,260 --> 01:31:36,520
fiecare dintre ale cărui elemente sunt
înapoi, în spate, în spate, în spate,

1821
01:31:36,520 --> 01:31:38,050
și, în general, de același tip.

1822
01:31:38,050 --> 01:31:42,630
>> Așa că, dacă te gândești, dintr-un
moment în urmă, ceea ce este un șir de caractere?

1823
01:31:42,630 --> 01:31:50,460
Ei bine, un șir de caractere, cum ar fi Zamyla,
Z-A-M-Y-L-A, este, tehnic,

1824
01:31:50,460 --> 01:31:51,400
doar o matrice.

1825
01:31:51,400 --> 01:31:53,700
Este o serie de caractere.

1826
01:31:53,700 --> 01:31:59,250
>> Și astfel, dacă vom trage într-adevăr acest lucru, așa cum am
a făcut mai devreme, ca o bucată de memorie,

1827
01:31:59,250 --> 01:32:04,510
se dovedește că fiecare dintre acestea
caractere ocupă un octet.

1828
01:32:04,510 --> 01:32:07,630
Și apoi există acea specială
caracterul santinelă, backslash 0,

1829
01:32:07,630 --> 01:32:12,360
sau toate cele opt biți 0, că
delimitează sfârșitul acelui șir.

1830
01:32:12,360 --> 01:32:15,090
Deci, un șir de caractere, se transformă
out, cita șir unquote,

1831
01:32:15,090 --> 01:32:20,580
este doar o matrice de chara--
char fiind un tip de date reale.

1832
01:32:20,580 --> 01:32:24,560
>> Și acum argv, meanwhile--
Să ne întoarcem la program.

1833
01:32:24,560 --> 01:32:29,582
Argv, chiar dacă vom vedea cuvântul
string aici, nu este un șir de caractere în sine.

1834
01:32:29,582 --> 01:32:33,640
Argv, vector argument,
este o matrice de siruri de caractere.

1835
01:32:33,640 --> 01:32:37,620
>> Așa cum poți avea o serie de
de caractere, poti avea nivel mai ridicat,

1836
01:32:37,620 --> 01:32:46,279
o serie de strings-- astfel încât, de exemplu,
când am tastat un moment în urmă ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, spațiu Z-A-M-Y-L-A, am susținut că
argv a avut două șiruri în ./argv0 it--,

1838
01:33:00,150 --> 01:33:03,185
și Z-A-M-Y-L-A. În
Cu alte cuvinte, argc fost 2.

1839
01:33:03,185 --> 01:33:03,980
De ce este asta?

1840
01:33:03,980 --> 01:33:08,370
>> Ei bine, în mod eficient, ceea ce se întâmplă
on este că fiecare dintre aceste șiruri

1841
01:33:08,370 --> 01:33:13,990
este, desigur, o serie de caractere
ca și mai înainte, fiecare dintre personaje a căror

1842
01:33:13,990 --> 01:33:15,670
ocupă un octet.

1843
01:33:15,670 --> 01:33:19,720
Si nu confunda 0 real
în numele programului cu 0,

1844
01:33:19,720 --> 01:33:22,040
ceea ce înseamnă că toți cei 80 de biți.

1845
01:33:22,040 --> 01:33:27,140
Și Zamyla, între timp, este încă
De asemenea, o serie de caractere.

1846
01:33:27,140 --> 01:33:31,450
>> Astfel, la sfârșitul zilei, într-adevăr
arata ca acest lucru sub capota.

1847
01:33:31,450 --> 01:33:38,800
Dar, argv, prin natura modului principal
lucrari, îmi permite să-și încheie toate astea

1848
01:33:38,800 --> 01:33:44,810
până în, dacă vreți, o matrice mai mare
că, dacă vom simplifica puțin peste

1849
01:33:44,810 --> 01:33:48,180
ce imaginea arata ca si nu
destul trage la scară acolo,

1850
01:33:48,180 --> 01:33:56,720
această matrice este doar de marimea 2, primul
element care conține un șir de caractere,

1851
01:33:56,720 --> 01:33:59,230
al doilea element
care conține un șir de caractere.

1852
01:33:59,230 --> 01:34:01,687
Și, la rândul său, dacă vă
un fel de zoom pe fiecare

1853
01:34:01,687 --> 01:34:03,770
din aceste siruri de caractere, ceea ce
vezi sub capota

1854
01:34:03,770 --> 01:34:07,190
este faptul că fiecare șir de caractere este doar
o serie de caractere.

1855
01:34:07,190 --> 01:34:11,680
>> Acum, la fel ca și cu siruri de caractere,
am fost capabili de a obține acces

1856
01:34:11,680 --> 01:34:15,260
la caracterul i-lea într-un șir de caractere
folosind acea notație paranteză pătrată.

1857
01:34:15,260 --> 01:34:17,320
În mod similar, cu tablouri
în general, putem

1858
01:34:17,320 --> 01:34:22,700
utilizați notația croșetă pentru a obține
la orice număr de șiruri într-o matrice?

1859
01:34:22,700 --> 01:34:25,100
De exemplu, permiteți-mi
mergeți mai departe și de a face acest lucru.

1860
01:34:25,100 --> 01:34:32,420
>> Lasă-mă să merg mai departe și de a crea argv1.c,
care este un pic diferit de data asta.

1861
01:34:32,420 --> 01:34:35,635
În loc de verificare pentru argc2,
Am de gând să fac în schimb acest lucru.

1862
01:34:35,635 --> 01:34:41,270
Pentru int I a lua 0, I este mai puțin
decât argc, I, plus, plus,

1863
01:34:41,270 --> 01:34:47,920
și apoi imprimați în interiorul acestui fapt,
procente s, noua linie, apoi

1864
01:34:47,920 --> 01:34:50,740
argv placuta i.

1865
01:34:50,740 --> 01:34:55,220
>> Deci, cu alte cuvinte, nu am de-a face cu
caractere individuale în acest moment.

1866
01:34:55,220 --> 01:35:00,190
Argv, dupa cum implica aceste pătrate goale
bretele la dreapta numelui argv,

1867
01:35:00,190 --> 01:35:03,320
înseamnă că argv este o matrice de siruri de caractere.

1868
01:35:03,320 --> 01:35:04,870
Si argc este doar un int.

1869
01:35:04,870 --> 01:35:08,800
>> Această linie de aici, 6, este
spunând set i egal cu 0.

1870
01:35:08,800 --> 01:35:11,980
Conta tot drumul până la,
dar nu inclusiv, argc.

1871
01:35:11,980 --> 01:35:14,010
Și apoi pe fiecare iterație,
imprima un șir de caractere.

1872
01:35:14,010 --> 01:35:14,800
Ce șir?

1873
01:35:14,800 --> 01:35:17,270
>> Șirul de-al i-lea în argv.

1874
01:35:17,270 --> 01:35:19,530
Așadar, în timp înainte de a mă
folosind consola pătrat

1875
01:35:19,530 --> 01:35:22,180
Notația pentru a ajunge la i-lea
caracter într-un șir de caractere, acum

1876
01:35:22,180 --> 01:35:27,240
Sunt folosind notația paranteză pătrată
pentru a ajunge la șirul i-lea într-o matrice.

1877
01:35:27,240 --> 01:35:30,310
Deci, e un fel de un singur strat
de mai sus, conceptual.

1878
01:35:30,310 --> 01:35:35,390
>> Și ce e îngrijit despre asta
program acum, dacă am compila argv1,

1879
01:35:35,390 --> 01:35:42,067
și apoi face ./argv1, și apoi tastați
în ceva de genul foo bar de Baz,

1880
01:35:42,067 --> 01:35:45,400
care sunt cele trei cuvinte implicit pe care
om de știință de calculator ajunge pentru orice moment

1881
01:35:45,400 --> 01:35:51,010
el sau ea are nevoie de unele cuvinte substituent,
și apăsați pe Enter, fiecare dintre aceste cuvinte,

1882
01:35:51,010 --> 01:35:54,980
inclusiv numele programului, care
este în argv la prima locație,

1883
01:35:54,980 --> 01:35:58,320
sfârșește prin a fi imprimate una câte una, la un moment dat.

1884
01:35:58,320 --> 01:36:05,290
Și, dacă am schimba acest lucru, și eu spun
ceva de genul argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
vom obține toate cele trei dintre cei
cuvinte, care este argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, pentru că în această
caz argc, contorul, este 3.

1887
01:36:14,400 --> 01:36:20,020
>> Dar ceea ce este elegant, este dacă înțelegi
că argv este doar o matrice de siruri de caractere,

1888
01:36:20,020 --> 01:36:24,910
și înțelegeți că un șir de caractere
este un șir de caractere,

1889
01:36:24,910 --> 01:36:29,470
de fapt, putem folosi un fel de acest
notație paranteză pătrată de mai multe ori

1890
01:36:29,470 --> 01:36:33,320
pentru a alege un șir de caractere, și apoi selectați
un caracter în șir,

1891
01:36:33,320 --> 01:36:35,730
scufundări mai adânc, după cum urmează.

1892
01:36:35,730 --> 01:36:40,100
În acest exemplu, lasă-mă să plec
înainte și numesc acest argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Și, în acest exemplu, lasă-mă să merg mai departe
și de a face following-- pentru int I a lua 0,

1895
01:36:50,180 --> 01:36:53,286
i este mai mică decât argc, i-plus
în plus, la fel ca înainte.

1896
01:36:53,286 --> 01:36:55,910
Așa că în alte words-- și acum acest lucru
este obtinerea destul de complicat.

1897
01:36:55,910 --> 01:36:59,940
Apoi am de gând să spun
itera peste siruri de caractere în argv,

1898
01:36:59,940 --> 01:37:01,294
ca un comentariu pentru mine.

1899
01:37:01,294 --> 01:37:03,960
Și apoi voi avea un
imbricate pentru bucla, tu care, probabil,

1900
01:37:03,960 --> 01:37:06,290
au făcut, sau luate în considerare
a face, în Scratch, în cazul în care

1901
01:37:06,290 --> 01:37:08,600
Mă duc să spun int-- că sunt
nu merge să folosesc din nou,

1902
01:37:08,600 --> 01:37:12,590
pentru că nu vreau să umbra, sau
un fel de suprascrie i existente.

1903
01:37:12,590 --> 01:37:15,780
>> Voi, în schimb, să zicem j, pentru că
asta e du-te la meu variabilă după I,

1904
01:37:15,780 --> 01:37:18,590
când eu doar încerc să
Numar de numere simple.

1905
01:37:18,590 --> 01:37:28,850
Pentru j devine 0-- și, de asemenea, n, se va
obține lungimea pupa a suportului argv i,

1906
01:37:28,850 --> 01:37:36,030
atâta timp cât j este mai mică m,
j plus, plus, efectuați următoarele.

1907
01:37:36,030 --> 01:37:37,500
Și aici e partea interesantă.

1908
01:37:37,500 --> 01:37:46,330
>> Tipăriți un caracter și o nouă linie,
conectarea placuta argv i, suport j.

1909
01:37:46,330 --> 01:37:47,940
OK, deci lasă-mă să adaug câteva comentarii aici.

1910
01:37:47,940 --> 01:37:54,820
Itera de caractere
în șir de curent,

1911
01:37:54,820 --> 01:38:02,290
imprimare j-caracter în șir i-lea.

1912
01:38:02,290 --> 01:38:04,630
Deci, acum, să ia în considerare
ceea ce înseamnă aceste observații.

1913
01:38:04,630 --> 01:38:06,750
>> Itera siruri de caractere
în argv-- cât de multe

1914
01:38:06,750 --> 01:38:09,300
string-urile sunt în argv, care este o matrice?

1915
01:38:09,300 --> 01:38:13,420
Argc multe, așa că eu sunt iterarea
din i egal cu 0 până la argc.

1916
01:38:13,420 --> 01:38:20,020
În același timp, cât de multe caractere
sunt în șirul i-lea argv?

1917
01:38:20,020 --> 01:38:22,880
>> Ei bine, pentru a obține acest răspuns,
Fac apel doar lungimea șirului de caractere

1918
01:38:22,880 --> 01:38:26,810
privind îngrijirea curentă șir I
despre care este argv placuta i.

1919
01:38:26,810 --> 01:38:30,090
Si voi pentru a stoca temporar că
valoare în n, doar în scopuri de memorare în cache,

1920
01:38:30,090 --> 01:38:31,590
să-l amintesc pentru eficiență.

1921
01:38:31,590 --> 01:38:36,330
Și apoi voi inițializa j la 0,
să păstreze merge atât timp cât j este mai mică decât n,

1922
01:38:36,330 --> 01:38:38,430
și la fiecare iterație creștere j.

1923
01:38:38,430 --> 01:38:41,030
>> Și apoi aici, pe
comentariul meu pe linia 12,

1924
01:38:41,030 --> 01:38:43,390
imprima un caracter,
urmată de o nouă linie,

1925
01:38:43,390 --> 01:38:48,140
Suport specific argv
I-mi dă șirul i-lea

1926
01:38:48,140 --> 01:38:51,690
în argv-- astfel încât primul cuvânt,
al doilea cuvânt, al treilea cuvânt, oricare ar fi.

1927
01:38:51,690 --> 01:38:57,370
Și apoi j scufundările mai adânc, și devine
mi caracterul j-a acelui cuvânt.

1928
01:38:57,370 --> 01:39:02,200
Și așa, în vigoare, puteți trata
argv ca un sistem multi-dimensional,

1929
01:39:02,200 --> 01:39:06,050
ca un bi-dimensional, matrice,
prin care fiecare cuvânt un fel de arata

1930
01:39:06,050 --> 01:39:08,580
ca asta în mintea ta
ochi, și fiecare caracter

1931
01:39:08,580 --> 01:39:10,930
este un fel de compus din
o coloană, în cazul în care vă ajută.

1932
01:39:10,930 --> 01:39:13,260
>> In realitate, atunci când ne șicana
acest lucru în afară, în săptămânile următoare,

1933
01:39:13,260 --> 01:39:15,580
acesta va fi un pic
mai sofisticate decât atât.

1934
01:39:15,580 --> 01:39:17,800
Dar tu poți cu adevărat
gândesc că, deocamdată,

1935
01:39:17,800 --> 01:39:22,110
ca doar acest bi-dimensional
matrice, prin care un nivel de ea

1936
01:39:22,110 --> 01:39:23,260
este toate siruri de caractere.

1937
01:39:23,260 --> 01:39:26,760
Și apoi, dacă te arunca cu capul mai adânc, ai
se pot obține de la caracterele individuale

1938
01:39:26,760 --> 01:39:29,600
prin utilizarea acestei in ele notatie aici.

1939
01:39:29,600 --> 01:39:31,620
>> Deci, ce este efectul net?

1940
01:39:31,620 --> 01:39:34,970
Lasă-mă să merg mai departe și
face darn argv2---l.

1941
01:39:34,970 --> 01:39:36,210
Am făcut o greșeală aici.

1942
01:39:36,210 --> 01:39:40,160
Implicit declararea
Funcția de bibliotecă Stirling.

1943
01:39:40,160 --> 01:39:42,190
Așa că în tot acest timp, este
poate este cazul

1944
01:39:42,190 --> 01:39:45,130
că suntem un fel de finisare
exact unde am început.

1945
01:39:45,130 --> 01:39:48,160
>> Am greșit, implicit, declarând
Funcția de bibliotecă Stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, așteptați un minut.

1947
01:39:48,987 --> 01:39:51,070
Îmi amintesc că, mai ales
din moment ce e chiar aici.

1948
01:39:51,070 --> 01:39:54,490
Trebuie să includă string.h în
această versiune a programului.

1949
01:39:54,490 --> 01:40:00,050
>> Lasă-mă să merg mai departe și să includă
string.h, cu excepția că, mergeți mai departe

1950
01:40:00,050 --> 01:40:04,460
și recompilați argv2.

1951
01:40:04,460 --> 01:40:08,390
Și acum, aici vom merge, face argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Și, deși este un pic
criptică la prima vedere,

1953
01:40:10,590 --> 01:40:15,690
observă că, într-adevăr, ce
este imprimată este argv2 punct.

1954
01:40:15,690 --> 01:40:19,970
>> Dar, dacă tastați câteva cuvinte după ce
prompte, cum ar fi argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Intra, de asemenea, un pic
criptică la prima vedere.

1956
01:40:22,560 --> 01:40:30,540
Dar, dacă ne defila înapoi în sus,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Așa că ne-am reiterată peste fiecare cuvânt.

1958
01:40:32,190 --> 01:40:37,770
Și, la rândul său, ne-am iterat peste
fiecare caracter dintr-un cuvânt.

1959
01:40:37,770 --> 01:40:40,040
>> Acum, după toate acestea,
dau seama că există

1960
01:40:40,040 --> 01:40:43,120
un alt detaliu am fost un fel
de a ignora tot acest timp.

1961
01:40:43,120 --> 01:40:46,180
Tocmai ne-am desfăcuți ce
intrările principale pot fi?

1962
01:40:46,180 --> 01:40:47,780
Cum rămâne cu ieșire principală a lui?

1963
01:40:47,780 --> 01:40:50,540
>> Tot acest timp, am fost
doar copierea și lipirea

1964
01:40:50,540 --> 01:40:53,870
int cuvântul în fața principală,
deși s-ar putea vedea on-line,

1965
01:40:53,870 --> 01:40:58,340
uneori incorect în versiuni mai vechi
C și compilatoare, că spun ei nule,

1966
01:40:58,340 --> 01:40:59,410
sau nimic.

1967
01:40:59,410 --> 01:41:01,580
Dar, într-adevăr, pentru versiunea
C pe care îl utilizăm,

1968
01:41:01,580 --> 01:41:06,180
C 11, sau 2011, își dau seama
că ar trebui să fie int.

1969
01:41:06,180 --> 01:41:09,300
Și ar trebui să fie
nule sau argc și argv aici.

1970
01:41:09,300 --> 01:41:10,790
>> Dar, de ce int main?

1971
01:41:10,790 --> 01:41:12,480
Ce este de fapt se întoarce?

1972
01:41:12,480 --> 01:41:16,280
Ei bine, se pare că tot acest timp,
orice moment ai scris un program de principal

1973
01:41:16,280 --> 01:41:18,440
este întotdeauna se întoarce ceva.

1974
01:41:18,440 --> 01:41:19,960
Dar a făcut acest lucru în secret.

1975
01:41:19,960 --> 01:41:23,350
>> Acel ceva este un
int, după cum sugerează linia 5.

1976
01:41:23,350 --> 01:41:24,225
Dar ce int?

1977
01:41:24,225 --> 01:41:26,100
Ei bine, există această
convenție în programare,

1978
01:41:26,100 --> 01:41:29,790
prin care, dacă nimic nu are
mers prost și totul este bine,

1979
01:41:29,790 --> 01:41:34,250
programe și funcții în general
return-- oarecum counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 semnifică, în general, totul este bine.

1982
01:41:38,070 --> 01:41:40,610
Deci, chiar dacă te gândești la
ea ca fiind false în mai multe contexte,

1983
01:41:40,610 --> 01:41:42,930
aceasta înseamnă, de fapt, în general, un lucru bun

1984
01:41:42,930 --> 01:41:49,560
>> Între timp, în cazul în care un program returnează 1,
sau negativă 1 sau 5, sau negativă 42,

1985
01:41:49,560 --> 01:41:52,941
sau orice-0 non valoare,
care semnifică, în general,

1986
01:41:52,941 --> 01:41:54,190
că ceva a mers prost.

1987
01:41:54,190 --> 01:41:56,700
De fapt, pe propriul dvs. Mac sau PC,
s-ar putea fi văzut de fapt,

1988
01:41:56,700 --> 01:42:01,050
un mesaj de eroare, acesta prin
spune ceva sau altul, eroare

1989
01:42:01,050 --> 01:42:04,940
cod negativ 42, sau codul de eroare
23, sau ceva de genul asta.

1990
01:42:04,940 --> 01:42:08,980
Acel număr este, în general, doar un indiciu
la programator, sau compania

1991
01:42:08,980 --> 01:42:11,174
care a făcut software-ul,
ce a mers bine și de ce,

1992
01:42:11,174 --> 01:42:13,590
astfel încât acestea să poată privi prin
documentație sau codul lor,

1993
01:42:13,590 --> 01:42:15,465
și dau seama ce
eroare înseamnă de fapt.

1994
01:42:15,465 --> 01:42:18,400
Nu e în general
util pentru a ne utilizatorii finali.

1995
01:42:18,400 --> 01:42:20,550
>> Dar, când principalele întoarce 0, totul este bine.

1996
01:42:20,550 --> 01:42:23,770
Și, dacă nu specificați
ce principal ar trebui să se întoarcă,

1997
01:42:23,770 --> 01:42:26,950
acesta va doar automat
return 0 pentru tine.

1998
01:42:26,950 --> 01:42:30,870
Dar, revenind ceva
altfel este de fapt util.

1999
01:42:30,870 --> 01:42:34,660
>> În cadrul acestui program final să-mi
mergeți mai departe și numesc acest exit.c,

2000
01:42:34,660 --> 01:42:38,630
și să introducă ultima astăzi
subiecte, cunoscut sub numele de un cod de eroare.

2001
01:42:38,630 --> 01:42:42,930
Lasă-mă să merg mai departe și includ nostru
fișiere familiare până sus, fac int main.

2002
01:42:42,930 --> 01:42:49,500
Și de data asta, să facem int argc,
argv șir, și cu paranteze mele

2003
01:42:49,500 --> 01:42:50,836
pentru a sugera că este în matrice.

2004
01:42:50,836 --> 01:42:52,460
Și apoi permiteți-mi să fac o verificare bun-simț.

2005
01:42:52,460 --> 01:42:56,640
De data aceasta, în cazul în care nu argc
egal cu 2, atunci știi ce?

2006
01:42:56,640 --> 01:42:57,520
Uita.

2007
01:42:57,520 --> 01:43:03,170
Am de gând să spun că, hei, utilizator,
vă lipsește în linie de comandă argument

2008
01:43:03,170 --> 01:43:04,210
n backslash.

2009
01:43:04,210 --> 01:43:05,230
>> Și apoi asta e.

2010
01:43:05,230 --> 01:43:06,130
Vreau să ieșiți.

2011
01:43:06,130 --> 01:43:11,030
Mă duc la preemptively,
și într-adevăr prematur, întoarcere

2012
01:43:11,030 --> 01:43:12,810
altceva decât numărul 1.

2013
01:43:12,810 --> 01:43:15,360
Du-te la valoarea primei
eroare care se poate întâmpla este 1.

2014
01:43:15,360 --> 01:43:17,860
Dacă aveți alte eronate
situație care ar putea apărea,

2015
01:43:17,860 --> 01:43:21,390
s-ar putea spune retur 2 sau retur 3, sau
poate chiar negativă 1 sau 2 negativ.

2016
01:43:21,390 --> 01:43:23,750
>> Acestea sunt doar coduri de ieșire
care sunt, în general,

2017
01:43:23,750 --> 01:43:27,770
util numai pentru programator, sau
companie care este de transport maritim software-ul.

2018
01:43:27,770 --> 01:43:30,500
Dar, faptul că este
nu 0 este ceea ce este important.

2019
01:43:30,500 --> 01:43:34,310
Așa că, dacă în acest program, vreau să
garanta că acest program numai

2020
01:43:34,310 --> 01:43:38,190
funcționează în cazul în care utilizatorul îmi oferă
cu un număr de două argumente,

2021
01:43:38,190 --> 01:43:42,880
numele programului, și alte
cuvânt, eu pot pune în aplicare la fel de mult, după cum urmează,

2022
01:43:42,880 --> 01:43:46,110
tipa la utilizatorul cu printf spune,
lipsă linie de comandă argument,

2023
01:43:46,110 --> 01:43:46,970
retur 1.

2024
01:43:46,970 --> 01:43:49,940
Care va pur și simplu imediat
a iesi din program.

2025
01:43:49,940 --> 01:43:55,840
>> Numai în cazul în care argc este egal cu 2 vom ajunge în jos
aici, moment în care am de gând să spun,

2026
01:43:55,840 --> 01:44:00,410
Buna ziua la suta s, backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Cu alte cuvinte, eu sunt
nu merge după argv 0,

2028
01:44:03,827 --> 01:44:05,410
care este doar numele programului.

2029
01:44:05,410 --> 01:44:09,450
Vreau să imprime salut, virgulă,
al doilea cuvânt care tastat uman.

2030
01:44:09,450 --> 01:44:12,580
Și, în acest caz
linia 13, totul este bine.

2031
01:44:12,580 --> 01:44:15,920
>> Știu că argc este 2
în mod logic din acest program.

2032
01:44:15,920 --> 01:44:17,770
Mă duc să merg mai departe și să se întoarcă 0.

2033
01:44:17,770 --> 01:44:21,230
Ca o parte, ține cont de faptul că
acest lucru este valabil și în zero, de asemenea.

2034
01:44:21,230 --> 01:44:24,760
>> În mod logic, am putut face acest lucru
și încapsula aceste linii

2035
01:44:24,760 --> 01:44:27,020
de cod în această clauză altcineva aici.

2036
01:44:27,020 --> 01:44:29,420
Dar asta e un fel de
crestarea inutil codul meu.

2037
01:44:29,420 --> 01:44:31,800
Și vreau să fac super-
clar că, indiferent de ce,

2038
01:44:31,800 --> 01:44:34,670
în mod implicit, salut
ceva se va obține imprimate,

2039
01:44:34,670 --> 01:44:36,050
atât timp cât utilizatorul cooperează.

2040
01:44:36,050 --> 01:44:39,360
>> Deci, este foarte obișnuit să folosească
o condiție, doar o dacă,

2041
01:44:39,360 --> 01:44:41,870
pentru a prinde unele eronate
situație, și apoi de ieșire.

2042
01:44:41,870 --> 01:44:45,690
Și apoi, atât de mult timp totul este
bine, nu au o alta,

2043
01:44:45,690 --> 01:44:48,060
dar au doar codul
în afara că, dacă, pentru că este

2044
01:44:48,060 --> 01:44:51,060
echivalent în această
caz particular, în mod logic.

2045
01:44:51,060 --> 01:44:54,480
Așa că mă întorc la 0, doar pentru a
semnifică în mod explicit totul este bine.

2046
01:44:54,480 --> 01:44:58,480
>> În cazul în care am omis returnarea 0, aceasta ar
se presupune în mod automat pentru mine.

2047
01:44:58,480 --> 01:45:00,890
Dar acum că mă întorc
unul din cel puțin acest caz,

2048
01:45:00,890 --> 01:45:04,940
Mă duc să, pentru o bună măsură și
claritate, randamentul 0 în acest caz.

2049
01:45:04,940 --> 01:45:09,690
Deci, acum lasă-mă să merg mai departe și să ieși,
care este un segue perfect pentru a părăsi pur și simplu.

2050
01:45:09,690 --> 01:45:14,401
>> Dar, să ieși, și lasă-mă să plec
înainte și de a face ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Și programul țipat la mine,
Lipsește un argument în linia de comandă.

2052
01:45:16,900 --> 01:45:18,120
Bine, lasă-mă să coopereze.

2053
01:45:18,120 --> 01:45:23,810
>> Lasă-mă să fac în schimb ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Și acum se spune, salut David.

2055
01:45:25,190 --> 01:45:27,300
Și n-ar vedea în mod normal, acest lucru.

2056
01:45:27,300 --> 01:45:30,650
>> Dar, se pare că există o
mod special în Linux pentru a vedea de fapt

2057
01:45:30,650 --> 01:45:34,470
cu ce ieșire cod de un program ieșit.

2058
01:45:34,470 --> 01:45:37,184
Uneori, într-un grafic
lume ca Mac OS sau Windows,

2059
01:45:37,184 --> 01:45:40,100
vedeți numai aceste numere atunci când un
Mesajul de eroare apare pe ecran

2060
01:45:40,100 --> 01:45:41,940
și programator
vă arată că numărul de.

2061
01:45:41,940 --> 01:45:44,773
Dar dacă vrem să vedem ce eroarea
Mesajul este, putem face aici--

2062
01:45:44,773 --> 01:45:48,100
astfel încât ./exit, Enter, print
Lipsește un argument în linia de comandă.

2063
01:45:48,100 --> 01:45:54,590
>> Dacă o fac acum $ echo ?, care este
ridicol de criptic cautati.

2064
01:45:54,590 --> 01:45:56,590
Dar, $?

2065
01:45:56,590 --> 01:45:59,220
este incantația magică
care spune, hei, calculator,

2066
01:45:59,220 --> 01:46:01,900
spune-mi ce anterior
Codul de ieșire al programului a fost.

2067
01:46:01,900 --> 01:46:03,410
Si am lovit Enter.

2068
01:46:03,410 --> 01:46:07,520
Eu văd 1, pentru că asta e ceea ce am
a declarat funcția mea principală să se întoarcă.

2069
01:46:07,520 --> 01:46:12,310
>> Între timp, dacă eu fac ./exit David,
și apăsați pe Enter, eu văd, salut pe David.

2070
01:46:12,310 --> 01:46:16,800
Și, dacă eu fac acum $ echo ?, eu văd salut 0.

2071
01:46:16,800 --> 01:46:19,080
Și, astfel încât aceasta va de fapt
fie informații valoroase

2072
01:46:19,080 --> 01:46:23,420
în contextul debugger, nu asa
de mult că tu, omul, ar pasa.

2073
01:46:23,420 --> 01:46:26,060
Dar debugger și alte
programe vom folosi acest semestru

2074
01:46:26,060 --> 01:46:29,420
se va uita de multe ori la acel număr,
chiar dacă este un fel de ascuns

2075
01:46:29,420 --> 01:46:32,780
cu excepția cazului când îl căutați, să
a determina dacă un program sau nu

2076
01:46:32,780 --> 01:46:37,050
execuție a fost corectă sau incorectă.

2077
01:46:37,050 --> 01:46:40,450
>> Și astfel, încât ne aduce la
aceasta, la sfârșitul zilei.

2078
01:46:40,450 --> 01:46:43,917
Am început astăzi de privirea de la
depanare, și, la rândul său, la cursul

2079
01:46:43,917 --> 01:46:46,750
în sine, și apoi mai interesant,
punct de vedere tehnic sub capota

2080
01:46:46,750 --> 01:46:49,490
la ce string-urile sunt, care ultimul
Săptămâna tocmai ne-am luat de la sine,

2081
01:46:49,490 --> 01:46:51,900
și cu siguranță le-a luat
pentru a acordat în Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Apoi ne-am uitat la modul în care putem accesa
caractere individuale într-un șir de caractere,

2083
01:46:56,040 --> 01:47:00,310
și apoi din nou, a avut un nivel mai ridicat
uita-te la lucruri, uita la modul în care well--

2084
01:47:00,310 --> 01:47:04,226
dacă vrem să ajungem la individ
elemente într-o listă ca structură,

2085
01:47:04,226 --> 01:47:05,850
nu putem face asta cu mai multe siruri de caractere?

2086
01:47:05,850 --> 01:47:08,050
Și noi putem cu argumente în linia de comandă.

2087
01:47:08,050 --> 01:47:12,800
Dar această imagine aici doar de cutii
este demonstrativ al acestei idei generale

2088
01:47:12,800 --> 01:47:14,451
a unei matrice, sau o listă, sau un vector.

2089
01:47:14,451 --> 01:47:16,450
Și în funcție de
context, toate aceste cuvinte

2090
01:47:16,450 --> 01:47:17,880
înseamnă lucruri ușor diferite.

2091
01:47:17,880 --> 01:47:20,060
Deci, în C, vom merge doar
pentru a vorbi despre o matrice.

2092
01:47:20,060 --> 01:47:23,840
Și o matrice este o bucată
de memorie, fiecare dintre ei este

2093
01:47:23,840 --> 01:47:27,720
elemente sunt adiacente, spate,
în spate, în spate, în spate.

2094
01:47:27,720 --> 01:47:31,970
>> Iar aceste elemente sunt, în general,
de același tip de date, caracter,

2095
01:47:31,970 --> 01:47:35,966
caracter, caracter, caracter, sau
string, string, string, string, sau int

2096
01:47:35,966 --> 01:47:38,600
int, oricare ar fi ea
încercăm să magazin.

2097
01:47:38,600 --> 01:47:42,540
Dar, la sfârșitul zilei, aceasta este
cum arată conceptual.

2098
01:47:42,540 --> 01:47:44,530
Iei ta
memorie sau RAM calculator.

2099
01:47:44,530 --> 01:47:48,590
Si tu te-l în sculptură
cutii identice dimensiuni, toate acestea

2100
01:47:48,590 --> 01:47:50,920
sunt înapoi, în spate, la
înapoi, în spate, în acest fel.

2101
01:47:50,920 --> 01:47:53,200
>> Și ce e frumos despre
această idee, și faptul

2102
01:47:53,200 --> 01:47:58,580
pe care o putem exprima valori în acest fel
cu prima dintre structurile noastre de date

2103
01:47:58,580 --> 01:48:02,520
în clasă, înseamnă că putem începe să
pentru a rezolva problemele cu cod

2104
01:48:02,520 --> 01:48:04,079
care a venit atât de intuitiv în săptămâna 0.

2105
01:48:04,079 --> 01:48:05,870
Vă amintiți telefonul
exemplu de carte, în cazul în care

2106
01:48:05,870 --> 01:48:09,110
am folosit o divide și cuceri,
sau un algoritm de căutare binară,

2107
01:48:09,110 --> 01:48:13,220
pentru a trece printr-un întreg
grămadă de nume și numere.

2108
01:48:13,220 --> 01:48:18,220
Dar am presupus, amintesc, că
carte de telefon a fost deja sortate,

2109
01:48:18,220 --> 01:48:21,630
că altcineva a avut deja
dat o out-- figure listă de nume

2110
01:48:21,630 --> 01:48:24,430
și cum să le Numere în ordine alfabetică.

2111
01:48:24,430 --> 01:48:26,950
Și acum, că, în C, noi,
de asemenea, au capacitatea

2112
01:48:26,950 --> 01:48:30,290
pentru a pune lucrurile, nu
fizic într-o carte de telefon

2113
01:48:30,290 --> 01:48:34,220
dar, practic, într-un computer
memorie, va vom fi în măsură săptămâna viitoare

2114
01:48:34,220 --> 01:48:38,470
să introducă din nou astea-- primul
a structurilor noastre de date într-un array--

2115
01:48:38,470 --> 01:48:43,530
dar, mai important, calculator real
algoritmi de știință puse în aplicare

2116
01:48:43,530 --> 01:48:47,720
în cod, cu care putem stoca
date în structuri de acest gen,

2117
01:48:47,720 --> 01:48:50,730
și apoi începe să-l manipuleze, și
pentru a rezolva de fapt probleme cu ea,

2118
01:48:50,730 --> 01:48:53,570
și să se bazeze pe deasupra,
în cele din urmă, programe în C,

2119
01:48:53,570 --> 01:48:56,730
în Python, în JavaScript,
interoghează baze de date cu SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Și vom vedea că toate acestea
idei diferite de blocare.

2121
01:48:59,980 --> 01:49:04,100
Dar, pentru moment, reamintească faptul că
domeniu pe care am introdus astăzi

2122
01:49:04,100 --> 01:49:06,920
a fost acest lucru aici, și
lumea criptografiei.

2123
01:49:06,920 --> 01:49:11,200
Și printre următoarele probleme pe care le voi
va rezolva este arta criptografiei,

2124
01:49:11,200 --> 01:49:13,630
de codare și de-codare
informații și cifrarea

2125
01:49:13,630 --> 01:49:15,930
și descifrarea textului,
și presupunând că în cele din urmă

2126
01:49:15,930 --> 01:49:18,970
că acum știi ce
este sub capota

2127
01:49:18,970 --> 01:49:21,860
astfel încât atunci când vedeți sau să primiți
un mesaj de genul asta,

2128
01:49:21,860 --> 01:49:24,060
le poate descifra.

2129
01:49:24,060 --> 01:49:26,740
Toate acestea, și mai mult data viitoare.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [REDARE VIDEO]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Tocmai a sosit.

2133
01:49:32,970 --> 01:49:35,146
Mă duc să merg vizita
profesor de colegiu.

2134
01:49:35,146 --> 01:49:37,611
Da.

2135
01:49:37,611 --> 01:49:40,080
Bună.

2136
01:49:40,080 --> 01:49:40,660
Esti tu.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Aștepta!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Eu doar încerc să dau
ce sa întâmplat cu tine.

2142
01:49:56,060 --> 01:49:58,130
Te rog, orice ar putea ajuta.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Tu ai fost colegiu lui
colega de camera, nu-i așa?

2145
01:50:08,354 --> 01:50:10,770
Ai fost acolo cu el când
el a terminat proiectul CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUZICĂ]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> Asta a fost CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Iubesc locul acesta.

2152
01:50:44,770 --> 01:50:45,854
>> -Mânca în întregime.

2153
01:50:45,854 --> 01:50:47,020
Vom ieși din afaceri.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END REDARE]

