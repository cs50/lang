[MUZICĂ] 

David J. MALAN: Bine. Aceasta este CS50 si aceasta este începutul săptămânii 2. Și veți aminti că peste ultimele două săptămâni, am fost introducerea de calculator știință și, la rândul său, de programare. 

Și am început povestea prin intermediul Zero, această limbă grafică de la MIT Media Lab. Și apoi cel mai recent, săptămâna trecută, ne-am introduce un higher-- un limbaj de nivel inferior cunoscut ca C, ceva care este pur textuală. Și, într-adevăr, ultima dată când am a explorat în acest context, o serie de concepte. 

Acest lucru, amintesc, a fost foarte Primul program de ne-am uitat la. Si acest program, pur și simplu, imprimă, "Bună ziua, lume." Dar, există atât de mult părând magie merge mai departe. Exista acest #include cu aceste paranteze unghiulare. Nu e int. Nu e (void). Există între paranteze, acolade, semi-colons, și multe altele. 

Și astfel, reamintim că am introdus Scratch astfel încât să putem, în mod ideal, vedea trecutul că sintaxa, lucrurile care nu este cu adevărat tot ceea ce intelectual interesant, dar devreme este, în mod absolut, un pic mai complicat să-și încheie mintea în jurul valorii. Și, într-adevăr, una dintre cele mai frecvente lucruri devreme într-o clasă de programare, în special pentru cei mai puțin confortabil, este de a obține frustrat de și împiedicați de anumite sintactic erori, să nu mai vorbim de erori logice. Și astfel, printre scopurile noastre astăzi, de fapt, va fie pentru a vă dota cu unele Tehnici de rezolvare a problemelor pentru modul în care pentru a rezolva mai bine problemele ei înșiși sub formă de depanare. Și veți aminti, de asemenea, că mediu pe care am introdus Ultima dată a fost numit CS50 IDE. Acest lucru este un software bazat pe web, care vă permite să programați în nor, ca să spunem așa, păstrând în același timp toate dvs. fișiere împreună, așa cum vom astăzi din nou. Și amintesc că noi Revisited aceste subiecte aici, printre ei funcții și bucle, și variabile și expresii booleene, și condiții. Și, de fapt, câteva mai mult ca noi tradus din lumea Scratch la lumea C. 

Dar, clădirea fundamentală blocuri, ca să spunem așa, au fost într-adevăr încă în aceeași săptămână trecută. De fapt, am de fapt doar a avut o diferite piese de puzzle, dacă vreți. În loc de asta violet salvați bloc, noi în loc a printf, care este această funcție în C, care vă permite să imprimați ceva și-l formatați pe ecran. Am introdus CS50 Bibliotecă, în cazul în care tu au acum la get_char ta de eliminare, și get_int, și get_string, și alte câteva funcții ca bine, prin care puteți obține de intrare de la tastatura proprie a utilizatorului. Si am luat, de asemenea, o privire la lucrurile cum ar fi these- bool, și char, și dublu, float, int, string long_long. Și, există chiar și alte tipuri de date în C. 

Cu alte cuvinte, atunci când declarați o variabilă pentru a stoca o anumită valoare, sau când implementați o funcție care returnează o anumită valoare, puteți specifica ce tipul de valoare care este. Este un șir de caractere, cum ar fi o secvență de caractere? Este un număr, cum ar fi un număr întreg? Este un punct plutitor valoare, sau ceva asemănător? Deci, în C, spre deosebire de zero, de fapt, ne-am a început să se precizeze ce fel de date ne intorceam sau folosind. 

Dar, desigur, am fugit, de asemenea, în anumite limite fundamentale de calcul. Și, în special, această limbă C, rechemare că am luat o privire preaplin întreg, realitatea că, dacă aveți doar un cantitate finită de memorie sau, în mod specific, un număr finit de biți, puteți conta doar atât de mare. Și așa ne-am uitat la acest exemplu aici prin care un contor într-un avion,, de fapt, în cazul în care rulează suficient de mult s-ar overflow si duce la un software un potențial de eroare fizică reală. 

De asemenea, ne-am uitat la plutitoare punctul imprecizie, realitatea că doar un număr finit de biți, fie că este vorba de 32 sau 64, puteți specifica doar atât de multe numere după un punct zecimal, după care încep să se imprecis. Deci, de exemplu, o treime din mondial aici, în lumea noastră umană, stim ca este doar un număr infinit de 3s după virgulă. Dar un computer nu poate în mod necesar reprezintă un număr infinit de numere dacă permiteți numai că unele cantitate finită de informație. 

Deci, nu numai că v-am dota cu o mai mare putere în termeni de modul în care s-ar putea exprima-te la o tastatură în termeni de programare, De asemenea, am limitat ceea ce puteți face de fapt. Și într-adevăr, erorile și greșelile pot provin din aceste tipuri de probleme. Și într-adevăr, printre subiectele de astăzi vor fi subiecte cum ar fi depanare și de fapt, în căutarea sub capota la modul în care au fost introduse lucruri săptămâna trecută sunt de fapt puse în aplicare astfel încât să o mai bună să înțeleagă atât capacitățile și limitările unui limbaj cum ar fi C. 

Și, de fapt, ne vom coaja înapoi straturile dintre cele mai simple structurii de date, ceva numit o matrice, care Se întâmplă la zero pentru a apela o "listă." E un pic diferite în acest context. Și apoi vom introduce, de asemenea, una dintre cele mai în primul rând problemelor noastre specifice domeniului în CS50, lumea criptografie, arta de codare sau în cifrare informații, astfel pe care le puteți trimite mesaje secrete și să decodifice mesaje secrete între două persoane, A și B. 

Așa că, înainte de tranziție la acea lume nouă, să încercăm să vă dota cu unele tehnici cu care puteți elimina sau reduce cel puțin unele din frustrările pe care le-ați întâlnit, probabil, peste numai săptămâna trecută. De fapt, înainte de tine sunt such-- unele dintre primele probleme în C. Și cote sunt, daca esti ca mine, prima dată încercați să tastați un program, chiar dacă te gândești logic programul este destul de simplu, s-ar putea lovi foarte bine un zid, și compilator nu este de gând să coopereze. Asigurați-vă sau zăngănit nu se întâmplă pentru a face de fapt licitarea. 

Și de ce s-ar putea să fie asta? Ei bine, hai să aruncăm o privire, probabil, un program simplu. Mă duc să merg mai departe și de a salva acest lucru în un fișier în mod deliberat numit buggy0.c, pentru că eu știu să viciate în avans. Dar eu s-ar putea să nu dau seama că, dacă acest lucru este primul sau al doilea sau al treilea program că eu sunt de fapt, mă fac. Așa că am de gând să merg mai departe și tip out, int main (void). Și apoi în interiorul bretele mele buclat, un foarte familiar ( "Bună ziua, world-- backslash, n ") - și o semi-colon. 

Am salvat fișierul. Acum am de gând să merg în jos la fereastra mea terminală și tipul de marca buggy0, pentru că, din nou, numele fișierului de astăzi este buggy0.c. Așa că am tip face buggy0, Enter. 

Si, oh, Doamne, amintesc de la ultima dată că nici un mesaj de eroare este un lucru bun. Astfel încât nici o ieșire este un lucru bun. Dar aici am clar unele număr de greșeli. 

Deci, prima linie de ieșire după tastarea face buggy0, rechemare, este de ieșire destul de verbose zăngănit lui. Sub capota, CS50 IDE este configurat de a utiliza un întreg buchet de opțiuni cu acest compilator astfel încât să nu aveți să se gândească la ele. Și asta e tot ce prima linie înseamnă că începe cu zăngănit. 

Dar, după aceea, problemele încep să-și facă apariția lor. Buggy0.c pe linia 3, caracter 5, există o mare eroare, roșu. Ce este asta? de declarare a funcției de bibliotecă implicit printf cu tipul int (char * const, ...) [-Werror]. Vreau să spun, foarte repede devine foarte arcane. Și, cu siguranță, la început vedere, nu ne-ar se așteaptă să înțelegeți integralitatea mesajului respectiv. Și astfel, una dintre lecțiile pentru ziua de azi se întâmplă să fie pentru a încerca să observe modele, sau alte lucruri similare, la erori s-ar putea avea întâlnite în trecut. Așa că hai numai lui tachineze în afară acele cuvinte care arata familiar. Mare eroare, roșu este în mod clar simbolic de ceva fiind greșit. 

implicit de declarare Funcția bibliotecă printf. Deci, chiar dacă eu nu înțeleg ce declarând implicit funcția de bibliotecă înseamnă, problema cu siguranță se referă la printf într-un fel. Iar sursa acestei probleme are de a face cu declararea acesteia. 

Declararea unei funcții este menționând-o pentru prima dată. Si am folosit terminologia săptămâna trecută de a declara prototipul unei funcții, a fie cu o singură linie, la partea de sus a ta fișier propriu sau într-un fișier antet așa-numitele. Și în ce dosar a făcut am spus săptămâna trecută că printf este citat, unquote, a declarat? În ce fișier este prototipul ei? 

Deci, dacă vă amintiți, primul lucru pe care am dactilografiate, aproape fiecare program de ultima time-- și din greșeală un moment în urmă a început tastând myself-- a fost acesta aici-- hash-- #include <stio-- pentru intrare / output-- punct h Și într-adevăr, dacă salvez acum acest fișier, voi pentru a merge mai departe și clar ecranul meu, pe care le puteți face prin tastarea Clar, sau puteți ține de Control L, doar pentru a șterge fereastra terminalului doar pentru a elimina unele dezordine. 

Mă duc să merg mai departe și re-make tip buggy0, Enter. Și, iată, eu încă văd că comandă lung de la zăngănit, dar nu există nici un mesaj de eroare de data asta. Și într-adevăr, dacă eu fac ./buggy0, la fel ca ultima dată, în cazul în care acest lucru înseamnă că dot director, Slash înseamnă doar, aici vine numele programului și că numele programului este buggy0, Enter, "Bună ziua, lume." 

Acum, cum v-ar putea avea spicuite această soluție fără a fi necesar recunoscând cât mai multe cuvinte așa cum am făcut-o, cu siguranță, având în făcut acest lucru pentru atât de mulți ani? Ei bine, dau seama pe prima problemă set, vă prezentăm o comandă că personalul propriu CS50 lui a scris numit help50. Și într-adevăr, C nu specificație pentru problema stabilită cu privire la modul de a utiliza aceasta. 

Dar, în esență, este help50 un program care personalul CS50 lui ați scris că permite să ruleze o comandă sau de a rula un program, și dacă nu înțelegi ei de ieșire, pentru a trece la producția help50, moment în care software-ul că personalul cursului scris se va uita la ieșire programul tău linie cu linie, caracter cu caracter. Iar dacă noi, personalul, să recunoască mesaj de eroare care vă confruntați, vom încerca să vă provoace cu unele întrebări retorice, cu un sfat, mult ca un TF sau AC sau de mine s-ar face în persoană la ore de birou. 

Asa ca uita-te la help50 dacă nu să recunoască în mod necesar o problemă. Dar nu se bazează pe ea prea mult ca o carja. Cu siguranță încerca să înțeleagă ei de ieșire și apoi să învețe de la ea astfel încât numai o dată sau de două ori nu-i vreodată rula help50 pentru o anumită eroare mesaj. După aceea, ar trebui să fie mai bine te echipate să ne dăm seama ce este de fapt. 

Hai să facem încă o aici. Lasă-mă să merg mai departe, și într-un alt fișier îl vom numi acest buggy1.c. Și, în acest fișier Sunt mergi la deliberately-- dar pretind că nu fac eu să înțeleagă ce greșeală am făcut. 

Mă duc să merg mai departe și de a face astea-- #include, de când am a învățat lecția mea de la un moment în urmă. Int main (void), la fel ca înainte. Și apoi aici voi de a face string s - get_string. Si amintesc de ultima dată Aceasta înseamnă, hei, calculator, da-mi o variabilă, numesc s, i face tipul acelei variabile un șir de caractere așa că pot stoca unul sau mai multe cuvinte în ea. 

Și apoi pe-dreapta parte a semnului egal este get_string, care este funcție în Biblioteca CS50 care face exact asta. Ea devine o funcție și apoi mâinile-l de la dreapta la stânga. Așa că acest semn egal nu înseamnă "Este egal cu" așa cum ne-am putea gândi la matematică. Aceasta înseamnă misiune de la dreapta la stânga. Deci, acest lucru înseamnă, luați șirul de utilizatorul și depozitați-l în interiorul lui. 

Acum, să-l folosească. Lasă-mă să merg mai departe acum și ca un al doilea line, lasă-mă să merg mai departe și spun "salut" - nu "lume", dar "salut,% S- care este substituent nostru, virgulă s, care este variabila noastră, și apoi un semi-colon. Așa că, dacă nu am șurub prea mult aici, acest lucru arata ca codul corect. 

Iar instinctele mele acum trebuie să-l compila. Fișierul este numit buggy1.c. Așa că voi face să fac buggy1, Enter. Și, darn-l, în cazul în care nu există chiar și mai multe erori decât înainte. Vreau să spun, mai este mesaje de eroare s-ar par decât liniile reale în acest program. 

Dar aici este takeaway, chiar dacă ești copleșit cu două sau trei ori mai mult de patru mesaje de eroare, întotdeauna se concentreze pe foarte mai întâi aceste mesaje. Cautati cel mai de sus-unul, defilare din nou cât este necesar. Deci, aici am scris marca buggy1. Iată că producția zăngănit cum era de așteptat. 

Și aici e prima eroare roșie. Utilizarea de identificator nedeclarat șir de caractere, am să spun standard? Deci, în standard este de fapt, altceva. Aceasta se referă la ul utilizatorului tastatură, în esență. 

Dar asta nu e ceea ce am vrut să spun. Am vrut să spun șir, și am vrut să spun get_string. Deci, ce este că eu a uitat să facă acest timp? Ce lipsește de data asta? Am #include meu, așa că am acces la printf. 

Dar ce nu am acces la doar încă? Ei bine, la fel ca și ultima dată, Trebuie să spun compilator Clang ce aceste funcții sunt. Get_string nu vine cu C. Și, în special, nu a venit în antetul fișierului,. Ea vine în schimb în ceva personalul scris, care este un alt fișier nume, dar pe bună dreptate numit. 

Așa că, pur și simplu prin adăugarea că o singură linie de rechemare din code-- ultima dată că, atunci când zăngănit se execută, va să se uite la codul meu de sus în jos, de la stânga la dreapta. Se va observa, oh, vrei. Lasă-mă să plec și găsesc că, ori de câte ori este pe server, copiați și lipiți-l, în esență, în partea de sus a propriul fișier astfel încât în ​​acest moment în poveste, linia 1, restul programului poate, într-adevăr, utilizați oricare dintre funcțiile în aceasta, printre care get_string. Așa că voi ignora restul acestor erori, pentru că, într-adevăr, suspecta că numai primul a contat de fapt. Si voi merge mai departe și rulați din nou, după salvarea fișierul meu face buggy1. Și voila, a făcut de lucru. Și, dacă fac eu ./buggy1 și tastați, pentru exemplu, Zamyla, eu acum va primi salut, Zamyla, în loc de salut, lume. 

In regula. Așa că takeaways de aici, apoi sunt, unul, încercați să culeagă spice la fel de mult ca tine poate din mesajele de eroare în monoterapie, în căutarea la unele dintre cuvintele de recunoscut. Barare că, utilizați help50 per problema set caietul de sarcini. Exceptând însă că, de asemenea, uita-te mereu la eroarea de sus numai, cel puțin inițial, pentru a vedea ce informații ar putea rezulta de fapt. Dar se pare că nu există chiar și o funcționalitate mai construit în Biblioteca CS50 pentru a ajuta te devreme în semestrul și timpuriu în programarea dau seama ce se întâmplă greșit. Așa că hai să facem un alt exemplu aici. Mă duc să sun acest buggy2, care, din nou, va fi eronate din de la poarta, prin design. 

Si voi merge mai departe și de a face #include. Și apoi am de gând să fac int main (void). Și apoi am de gând să fac o buclă. Pentru (int i _ 0. i este mai mică sau egală cu 10. i ++, și apoi în acolade, voi pentru a imprima doar un simbol hashtag aici și o nouă linie de caractere. 

Așa că intenția mea cu această Programul este destul de simplu revizuim de 10 ori și pe fiecare iterație din această buclă de fiecare dată prin ciclul, imprima un hashtag, un hashtag, un hashtag. Câte unul pe fiecare rând pentru că am au noua linie de acolo. Și reamintească faptul că pentru buclă, pe ultima week-- și veți obține mai mult familiarizat cu sintaxa prin utilizarea acestuia cu practica înainte de a long-- acest lucru mi dă o variabilă am numit și setează-l la 0. 

Acest lucru incrementează i pe fiecare iterație de 1. Deci, am merge la 1 la 2 la 3. Și apoi această condiție în mijloc între semi colonul se verifică la fiecare iterație pentru a face sigur că suntem încă în raza de acțiune. Așa că vreau să itera de 10 ori, așa că am au un fel de foarte intuitiv doar a pus 10 ca meu de sus legat acolo. 

Și totuși, când am rulat acest lucru, după compilarea cu marca buggy2-- și alcătuiește OK. Deci, eu nu am un Eroare de sintaxă de această dată. Lasă-mă să plec mai departe acum și a alerga buggy2, Enter. Și acum derulați în sus. Și lasă-mă crească dimensiunea ferestrei. 

Se pare că am 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Deci, nu există 11 hashtagurilor, chiar dacă Am pus în mod clar 10 în interiorul acestei bucle. Acum, unii dintre voi s-ar putea vedea imediat care eroarea se datorează faptului că, într-adevăr, această nu este o eroare foarte greu de făcut. Dar este foarte frecvent a făcut foarte devreme. 

Ceea ce vreau să subliniez, totuși, este, cum s-ar putea să dau asta? Ei bine, se pare că Biblioteca CS50 vine nu numai get_string și get_int și get_float și alte funcții. De asemenea, vine cu o funcție specială numita eprintf, sau, eroare printf. Și ea există numai pentru a face un pic mai ușor pentru tine atunci când codul de depanare doar spre imprima un mesaj de eroare pe ecran și știu de unde a venit. 

Deci, de exemplu, un singur lucru aș putea face aici cu această funcție este astea-- eprintf, și apoi am de gând să merg mai departe și spun eu acum este% i, backslash, n. Și am de gând să conectați în valoarea lui i. Și până sus, deoarece acest lucru este în Biblioteca CS50, Mă duc să merg mai departe și includ așa că am acces la această funcție. Dar, să ia în considerare ce linie 9 se presupune a face. Voi șterge acest în cele din urmă. Acest lucru nu are nimic de-a face cu scopul meu primordial. Dar, eprintf, eroare printf, este doar a însemnat să-mi dea niște informații de diagnostic. Când m-am rula programul meu, vreau să a se vedea acest lucru pe ecran temporar precum și doar pentru a înțelege ce se întâmplă. 

Și, într-adevăr, pe fiecare iterație aici de linia 9 Vreau să văd, ceea ce este valoarea lui i? Care este valoarea lui i? Care este valoarea lui i? Și, sperăm, numai eu ar trebui a se vedea acel mesaj, de asemenea, de 10 ori. 

Așa că lasă-mă să merg mai departe și recompilați programul meu, așa cum am să fac orice moment Eu fac o schimbare. ./buggy2. Și now-- OK. Există o mult mai întâmplă. Așa că lasă-mă în defila în sus o fereastră chiar mai mare. 

Și veți vedea că fiecare dintre hashtag-ul este încă de imprimare. Dar, între fiecare dintre ele este acum această ieșire diagnosticare formatat după cum urmează. Numele programului meu de aici este buggy2. Numele fișierului este buggy2.c. Numărul liniei din care acest lucru a fost tipărit este linia 9. Și apoi spre dreapta, care este mesaj de eroare pe care mă așteptam. 

Și ce e frumos despre acest lucru este faptul că Acum nu trebuie să conta în mod necesar în capul meu ce programul meu este de a face. Pot să văd că, pe prima iterație i este 0, apoi 1, apoi 2, apoi 3, apoi 4, apoi 5, apoi 6, apoi 7, apoi 8, apoi 9, atunci 10. Stai un minut. Ce se petrece aici? Eu încă par să fie de numărare în conformitate cu destinația de până la 10. 

Dar de unde am început? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Deci 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- degetul 11 este un indiciu al problemei. Se pare că am numărat incorect în buclă mea. Mai degrabă decât a merge 10 iterații, Sunt incepand de la 0, Mă termină la și prin 10. Dar, pentru că, la fel ca un computer, Am început de numărare de la 0, Ar trebui să fie incrementală la, dar nu prin, 10. 

Și așa fix, am în cele din urmă a realizat aici, este una dintre cele două lucruri. Aș putea spune foarte simplu conta până la mai puțin de 10. Deci 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, care este, într-adevăr, corect, chiar dacă sună un pic greșit. Sau aș putea face mai mică sau egală la 9, atâta timp cât am început de la 0 ° C. Sau, dacă într-adevăr nu-mi place asta, poate conta până prin 10, dar încep de la 1. Dar, din nou, acest lucru pur și simplu nu este atât de comună. În programming-- deși nu atât de mult în rămășițe dar în programarea în C și alte limbi, cum ar fi JavaScript și Python și altele, este doar foarte frecvente pentru discuția noastră de binare pentru a începe numărarea doar la cele mai cel mai mic număr posibil, care este 0. In regula. Deci asta e eprintf. Și din nou, acum că mi-am dat seama mea problemă, și am de gând să mă întorc la 0 prin mai puțin de 10, voi pentru a merge și să ștergeți eprintf. 

Nu trebuie să fie acolo când navă codul meu sau să prezinte codul meu sau arata oricui altcineva. Este într-adevăr doar a însemnat să fie utilizat temporar. Dar acum am stabilit acest lucru problemă specială, de asemenea. 

Ei bine, să facem încă un exemplu aici că am de gând să bici după cum urmează. Mă duc să merg mai departe și #include . $ 50 Si voi merge mai departe și #include. 

Si voi salva acest fișier ca buggy3.c. Si voi merge mai departe și să declare int main (void). Și apoi în interiorul acolo Am de gând să fac int i _ - Vreau să pună în aplicare un program de cu un get_negative_int. Aceasta nu este o funcție care există încă. Așa că vom pune în aplicare ea într-un moment. Dar, vom vedea de ce este buggy la prima trecere. Și odată ce am ajuns o int de utilizator, Am de gând doar pentru a imprima% i este un negativ număr întreg, backslash, n, virgulă, i. Cu alte cuvinte, tot ce am doresc acest program să facă se obține un int negativ utilizatorul și apoi imprimați că cutare este un int negativ. 

Acum am nevoie pentru a pune în aplicare această funcție. Așa că mai târziu, în dosarul meu, am de gând să merg înainte și să declare o funcție numită get_negative_int (void) - și vom vin înapoi la ceea ce înseamnă din nou acea linie într-un moment-- int n; do-- do following-- printf n este :. Și apoi am de gând să fac n - get_int, și de a face acest lucru în timp ce n este mai mare decât 0. Și apoi să se întoarcă n ;. 

Deci, există o mulțime întâmplă în acest lucru, dar nici unul dintre care nu am făcut-o uita-te la săptămâna trecută, cel puțin pentru scurt timp. Deci, pe linia 10 aici am declarat functie numita get_negative_int, și am pus (void), în paranteze, motivul fiind această nu ia o intrare. N-am nimic care trece la această funcție. Sunt doar obtinerea ceva înapoi de la ea. 

Și ce eu sunt în speranța de a primi înapoi este un număr întreg. Nu există nici un tip de date în C numit negative_int. Este pur și simplu int, asa ca va să fie pe noi să ne asigurăm că valoarea care este de fapt Returned nu este doar un int dar este, de asemenea, negativ. 

Pe linia 12 Declar o variabilă numit n și făcându-l de tip int. Și apoi, în linia 13, prin 18 Sunt face ceva în timp ce ceva este adevărat. Mă duc mai departe și de imprimare n este, de colon, și apoi un spațiu, cum ar fi un prompt pentru utilizator. 

Sunt apoi sunat get_int și stocarea valorii sale de întoarcere așa-numitele în acea variabilă n. Dar, voi continua să faci acest lucru în timp ce n este mai mare decât 0. Cu alte cuvinte, în cazul în care utilizatorul mi-o dă int și acest număr este mai mare decât 0, ergo, pozitiv, voi doar ține reprompting utilizatorul, să păstreze reprompting, forțându-le să cooperează și dă-mi un int negativ. 

Și odată ce n este de fapt negative-- să presupunem că utilizatorul în cele din urmă tipuri de -50, atunci această buclă în timp ce nu mai este valabil deoarece -50 nu este mai mare decât 0. Asa ca am iesi din asta buclă în mod logic și să se întoarcă n. 

Dar există o altă lucru ce trebuie să fac. Și eu pot face acest lucru pur și simplu prin copierea și lipirea o linie de cod în partea de sus a fișierului. Am nevoie pentru a preda zăngănit, sau promisiunea de a zăngănit, în mod explicit că voi, într-adevăr, du-te și să pună în aplicare această funcție get_negative_int. S-ar putea fi la fel de jos în fișierul. Din nou, reamintim că zăngănit citeste lucrurile de sus în jos, la stânga la dreapta, așa că nu poți apela o funcție în cazul în care zăngănit nu știe că va exista. 

Acum, din păcate, acest program, ca unii dintre voi s-ar putea fi observat, este deja buggy. Lasă-mă să merg mai departe și să facă buggy3. Compilează, deci problema mea acum nu este o eroare de sintaxă, cum ar fi o eroare textuală, este de fapt, va fi o logică eroare pe care am intenționat a făcut ca o oportunitate de a pas prin ceea ce se întâmplă. 

Mă duc să merg mai departe acum și a alerga buggy3. Iar eu mă duc înainte, și nu cooperează. Mă duc să-l dau numărul 1. Nu mi-a plăcut, așa Mi-a determinat din nou. 

Ce zici de 2? 3? 50? Nici unul dintre cei care lucrează. Ce zici de -50? Iar programul pare să funcționeze. 

Lasă-mă să-l încercați încă o dată. Lasă-mă să încerc -1, pare să funcționeze. Lasă-mă să încerc -2, pare să funcționeze. Lasă-mă să încerc 0. Nu-i asa, e incorect. Acum, suntem un pic pedant aici. Dar este, într-adevăr, cazul în care 0 nu este nici pozitiv, nici negativ. Și astfel, faptul că programul meu este spunând că 0 este un număr întreg negativ, că nu e corect punct de vedere tehnic. 

Acum, de ce faci asta? Ei bine, s-ar putea să fie evident. Și, într-adevăr, programul este menit să fie destul de simplu așa că avem ceva de a explora. 

Dar, să introducă oa treia depanare Tehnica numită aici debug50. Deci, acesta este un program de pe care tocmai l-am creat acest an numit debug50 pe care le va permite de a folosi ceea ce se numește un built-in debugger grafic în IDE CS50. Și un depanator este doar un program care în general, vă permite să rulați programul dar pas cu pas cu pas, linie linie cu linie, oprindu-se, poking în jurul valorii, uita la variabile, astfel încât programul nu doar sufla peste tine și imprima rapid ceva sau nu imprimă ceva. Acesta vă oferă o oportunitate, la viteza de om, pentru a interacționa cu ea. 

Și pentru a face acest lucru, pur și simplu faceți următoarele. După compilarea codului, pe care am făcut-o deja, buggy3, merge mai departe și a alerga debug50 ./buggy. Atât de mult ca help50 are executați help50 și apoi comanda, debug50 are rulați debug50 și atunci numele comenzii. 

Acum priviți ce se întâmplă pe ecran, pe partea dreaptă, în special. Când m-am lovit alerga, tot Panoul de bruscă această mână dreaptă se deschide pe ecran. Și există o mulțime întâmplă pe la prima vedere. Dar nu e prea mult să vă faceți griji încă. 

Acest lucru dă-mi totul care se întâmplă în interiorul programului meu chiar acum și prin intermediul acestora Butoanele sus de sus este apoi permițându-mi să pas prin codul meu în cele din urmă pas cu pas cu pas. Dar, nu doar încă. Observați ce se întâmplă. La fereastra mea terminală Mi se cere pentru n. Și mă duc să merg mai departe și cooperează acest timp și tipul în -1. Și, deși puțin criptic, -1 este un număr întreg negativ, cum era de așteptat. 

Și apoi copilul a ieșit cu starea 0 GDBserver care iese. GDB, GNU Debugger, este numele a software-ului de bază care pune în aplicare această depanator. Dar toate acestea înseamnă că într-adevăr, debugger a plecat pentru că programul meu renuntat și totul a fost bine. Dacă vreau să depana cu adevărat programul meu, Trebuie să spun preemptively debug50, unde vreau să încep pas cu pas prin codul meu? 

Și, probabil, cel mai simplu mod pentru a face acest lucru este după cum urmează. Dacă aș fi plasați cursorul peste jgheab de editorul meu aici, astfel încât într-adevăr doar în bara laterală aici, la stânga numărului liniei, observați că, dacă am doar să faceți clic o dată, am pus un punct roșu puțin. Si acel mic punct roșu, ca un semn de oprire, înseamnă, hei, debug50, execuție pauză de codul meu chiar acolo când am rula acest program. 

Așa că hai să facem asta. Lasă-mă să merg mai departe și a alerga programul meu din nou cu debug50 ./buggy3, Enter. Și acum, o notificare, ceva altfel sa întâmplat. N-am fost întrebat în prealabil totuși, în fereastra mea terminală pentru nimic, pentru că nu am ajuns încă acolo în programul meu. Observați că pe linia 8 care este evidențiată, și există o mică săgeată la spunând stânga, ești întrerupt aici. Această linie de cod, linie 8, nu a fost încă executată. 

Și ce e curios, dacă mă uit aici pe partea dreaptă, Observați că este un localnic variabilă, locală în sensul că este în interiorul funcției curente. Și valoarea ei, se pare că, în mod implicit, și un fel de convenabil, este 0. Dar eu nu am de tip 0. Care tocmai se întâmplă să fie ei Valoarea implicită în acest moment. 

Așa că lasă-mă să merg mai departe și fac asta acum. Lasă-mă să merg mai departe și partea de sus chiar aici, sunt merge mai departe și faceți clic pe această primă pictogramă care înseamnă pas peste ceea ce înseamnă că nu săriți acest lucru, dar pas peste această linie de cod, executându-l de-a lungul drum. 

Și acum, observați, meu promptă tocmai sa schimbat. De ce este asta? I-am spus debug50, rula această linie de cod. Ce face această linie de cod nu? mă solicită pentru un int. O.K. Lasă-mă să coopereze. Lasă-mă să merg mai departe acum și tastați -1, Enter. Și acum, observați ce sa schimbat. Pe partea dreaptă, variabila mea locală i este indicat ca fiind -1 acum. Și este încă de tip int. 

Și observați, de asemenea, meu așa-numitele stiva de apel, unde am pauză? Vom vorbi mai multe despre acest lucru în viitor. Dar, stiva de apel pur și simplu se referă la ceea ce funcții sunt în prezent în mișcare. Chiar acum e doar principal. Și chiar acum singurul locale variabilă este i cu o valoare de 1. 

Și, în sfârșit, când am pas peste această linie aici, cu aceeași pictogramă în dreapta sus, -1 Este un număr întreg negativ. Acum este oprindu-se peste asta acoladă. Hai să lăsați-o să facem treaba. Am pas peste acea linie, și voila. 

Deci, nu tot ce teribil edificator încă, dar mi-a lăsat o pauză și să se gândească logic prin ce acest program este de a face. Dar acest lucru nu a fost cazul eronată. Hai să facem asta din nou, după cum urmează. 

Am de gând să părăsească breakpoint pe linia 8 cu punct roșu. Mă duc să rulați din nou debug50. Se opri automat aici. Dar, de data aceasta, în loc de pas cu pas peste această linie, lasă-mă să merg de fapt, în interiorul get_negative_int și dau seama, de ce este acceptarea 0 ca un răspuns valid? 

Deci, în loc de a da click Step Over. Mă duc să merg mai departe și faceți clic pe Step Into. Și observați că linia 8 care este acum evidențiate acum dintr-o dată devine linia 17. 

Acum, nu e ca debugger a sărit peste liniile 14 și 15 și 16. Doar că nu e nimic să-ți arăt acolo. Acestea sunt doar declarare variabile, și apoi există cuvântul Do și apoi o acoladă deschisă. Singura linie funcțională care este suculent într-adevăr este asta aici, 17. Și asta e în cazul în care ne-am se opri în mod automat. 

Așa că printf ( "n.is:") ;, asa care încă nu sa întâmplat. Așa că hai să mergem mai departe și faceți clic pe Step Over. Acum prompte mea, într-adevăr, schimbat la ( "n este:"). Acum get_int, nu plec să deranjez pas cu pas în, pentru că această funcție a fost realizat de CS50 în bibliotecă. Este probabil corect. 

Așa că am de gând să merg mai departe și un fel de coopera dându- un int, dar nu o int negativ. Așa că lasă-mă să merg mai departe și a lovit 0. Și acum ce se întâmplă aici când voi ajunge la linia de 21? Nu am iterat din nou. Eu nu par să fie blocat în această buclă. Cu alte cuvinte, acest galben bare nu a ținut merge în jurul valorii, și în jur, și în jur. 

Acum, de ce e asta? Ei bine, n, ceea ce este n chiar acum? Mă pot uita la nivel local variabilele din debugger. n este 0. Bine, ce era starea mea? 

20-- linia 20 este, de asemenea, 0 este mai mare decât 0. Nu este adevarat. 0 nu este mai mare decât 0. Și așa mi-am rupt din asta. 

Și astfel, de aceea on-line 21, în cazul în care am de fapt continua, Mă duc să se întoarcă 0, chiar deși ar fi trebuit sa respins 0 ca nefiind de fapt negativ. Așa că acum, eu nu fac într-adevăr, chiar pasă de debugger. Am înțeles, nu am nevoie să mai stiu ce se întâmplă. 

Așa că am de gând să merg mai departe și doar să faceți clic pe butonul de redare, și lăsați acest finisaj în sus. Acum, mi-am dat seama că mi bug-ul este aparent pe linia 20. Asta e eroarea mea logică. 

Și ce vreau pentru a face pentru a schimba acest lucru? În cazul în care problema este că eu nu sunt prinderea 0, este doar o eroare de logică. Și eu pot spune în timp ce n este mai mare sau egal cu 0, păstrează fapt care ia determinat din nou și din nou utilizatorul. 

Deci, din nou, greșeală simplu, probabil chiar și evident atunci când m-ai văzut scrie-l în urmă cu doar câteva minute. Dar aici takeaway este că, cu depanare 50, și cu depanare software-ul mai general, aveți această putere nouă constatat plimbare prin propriul cod, uita-te prin panoul cu mâna dreaptă ce variabile valorile sunt. Deci, tu nu neapărat trebuie să folosească ceva ca tine eprintf pentru a imprima aceste valori. Le puteti vedea de fapt, vizual pe ecran. 

Acum, dincolo de aceasta, este demn de remarcat că există o altă tehnică care este de fapt, super-comun. Si te va intrebati de ce acest mic Tipul aici a fost așezat pe scenă. Deci, nu există această tehnică, în general, cunoscut sub numele de cauciuc rață depanare, care într-adevăr este doar un o dovadă a faptului că programatorii de multe ori atunci când sunt scrierea de cod, ei nu sunt în mod necesar colaborarea cu alte persoane, sau care lucrează într-un mediu partajat. 

Sunt un fel de acasă. Poate că e noaptea târziu. Ei încearcă să descifreze unele bug în codul lor. Si ei doar nu-l văd. 

Și nu există nici un coleg de cameră. Nu există nici un TF. Nu există nici o CA jur. Tot ce au pe raft lor este acest rățușcă mic. 

Și așa depanare rață de cauciuc este doar această invitație să se gândească la ceva la fel de prostie ca acest lucru ca o creatură reală, și de fapt, merge prin codul verbal la acest obiect neînsuflețit. Astfel, de exemplu, în cazul în care acesta este exemplul meu aici-- și reamintească faptul că mai devreme problema a fost aceasta, dacă ștergeți această primă linie de cod, și mă duc mai departe și fac buggy 0 din nou, amintesc că am avut aceste mesaje de eroare aici. Deci, ideea de aici, deși am ridicol se simt în acest moment face acest lucru în mod public, este acea eroare. 

OK, deci problema mea este că am a declarat, implicit, o funcție de bibliotecă. Și că funcția de bibliotecă este printf. Declare-- OK, declara îmi amintește de prototipuri. 

Asta înseamnă că am nevoie să de fapt spune-compilator dinainte ce funcția arată. Așteptaţi un minut. Nu am avut io.h. standard de Mulțumesc foarte mult. 

Deci, doar acest proces de-- vă nu este nevoie să aibă de fapt o rață. Dar această idee de mers pe jos te prin propriul cod astfel încât să auzi chiar le astfel încât să realizeze omisiuni în propria observații, este, în general ideea. 

Si, poate mai logic, nu atât mult cu una, dar implica mai mult de exemplu, tocmai am făcut-o în 3.c buggy, s-ar putea te plimbi prin ea după cum urmează. Deci, toate dreapta, cauciuc Ducky, DDB, dacă vreți. Aici avem în funcția mea principală, O sun primi int negativ. 

Si eu sunt obtinerea de valoarea de returnare. Sunt o depozitați pe partea stângă pe linia 8 într-o variabilă numită i. OK, dar așteptați, cum a făcut care obține această valoare? Lasă-mă să mă uit la funcția în linia 12. 

În linia 12, avem de a lua int negativ. Nu ia nici o intrare, se întoarce int, OK. Declar pe linia 14 a n variabile. Se va stoca un număr întreg. Asta vreau. 

Deci următoarele în timp ce n este-- lasa mi-a anula ce fix am deja făcut. Deci, în timp ce n este mai mare decât 0, imprima n este, OK. Apel și apoi se int stocat în n. Și apoi verificați dacă n este 0, n este not-- acolo este. Deci, din nou, tu nu faci au nevoie de rață reală. Dar, pur și simplu de mers pe jos prin tine codul ca un exercițiu intelectual vă va ajuta de multe ori dau seama ce se întâmplă, , spre deosebire de a face doar ceva ca aceasta, cu ochii la ecran, și nu te vorbind prin ea, care sincer nu este aproape ca o tehnica eficienta. Deci nu aveți ea, o Numărul de diferite tehnici pentru depanarea de fapt codul și mustrare, toate acestea ar trebui să fie instrumente în Toolkit dumneavoastră astfel încât să nu te noaptea târziu, mai ales, tu ești în sala de mese hale, sau la orele de birou, trage cu capul de de perete, încercând să rezolve unele probleme. Dau seama că există instrumente de software. Există instrumente de rață de cauciuc. Și există un întreg personal de să sprijine în așteptare pentru a da o mână. 

Deci, acum, un cuvânt cu privire la problema seturi, și ceea ce suntem în speranța de tine ieși afară din ele, și modul în care vom merge cu privire la evaluarea. Per Programa cursului, seturi problemă CS50 lui sunt evaluate pe patru axe principale, așa la speak-- domeniul de aplicare, corectitudine, proiectare, și stil. Și domeniul de aplicare doar se referă la cât de mult a piesei ai muscat? Cât de mult de o problemă ați încercat? Ce nivel de efort te-ai manifestat? 

Corectitudinea este, face munca de program ca se presupune că pentru fiecare specificație CS50 atunci când furnizați anumite intrări sau anumite ieșiri vin înapoi? Design-ul este cel mai subiectiv dintre ele. Și este cel care va ia cea mai lungă pentru a învăța și cea mai lungă pentru a preda, în măsura în care se reduce la, cât de bine scris este codul? 

Este un lucru pentru a imprima doar corectă ieșiri sau a reveni la valorile corecte. Dar o faci ca mai eficient posibil? O faci diviza și cuceri, sau binar căutare după cum vom vedea în curând că am făcut-o în urmă cu două săptămâni, cu cartea de telefon? Există modalități mai bune de a rezolva problemă decât în ​​prezent aici? Aceasta este o oportunitate pentru un design mai bun. 

Și apoi style-- cum destul este codul? Vei observa că sunt destul de special despre crestarea codul meu, și asigurându-vă că variabilele mele sunt numite în mod rezonabil. n, în timp scurt, este un nume bun pentru un număr, i pentru un număr întreg de numărare, pentru un șir de caractere. Si putem avea mai mult stil de nume de variabile. Stilul este doar cât de bun arata codul? Si cum poate fi citit este? 

Și-a lungul timpului, ceea ce TAs dvs. și TFS va face în cursul este vă oferi cu un fel de feedback calitativ astfel încât să obțineți mai bine la aceste aspecte diferite. Iar în ceea ce privește modul în care ne-am evalua fiecare dintre aceste axe, este de obicei, cu foarte puține găleți, astfel încât tu, în general, obține un sentiment de cat de bine faci. Și, într-adevăr, în cazul în care primiți un scor pe oricare dintre aceste axes-- corectitudine, design și stilul especially-- numărul respectiv va fi, în general, între 1 și 5. Si, literalmente, dacă sunteți obtinerea 3, la începutul semestrului, acest lucru este un lucru foarte bun. Aceasta înseamnă că încă loc pentru imbunatatiri, pe care le-ar spera în luând o clasă pentru prima dată. Există unele sperăm pic de plafon la care te aspiră la atingerea. Si astfel obtinerea 3 pe primele piese, dacă nu vreo 2 și 4, a este, într-adevăr, un lucru bun. Este bine în raza de acțiune, bine în așteptări. 

Iar dacă mintea ta este de curse, așteptați un minut, trei din cinci. Asta e într-adevăr un 6 din 10. Asta e 60%. Dumnezeul meu, e un F. 

Nu este. Nu e, de fapt, asta. Mai degrabă, este o oportunitate de a îmbunătăți pe parcursul semestrului. Iar dacă primiți niște Poors, acestea sunt o oportunitate pentru a profita de ore de birou, cu siguranță secțiuni și alte resurse. 

Cel mai bun este o oportunitate, într-adevăr, să fie mândri de cât de departe ai vin pe parcursul semestrului. Așa că ne dăm seama, dacă nimic altfel, trei este bun. Și permite o cameră pentru o creștere a lungul timpului. 

În ceea ce privește modul în care aceste axe sunt ponderată, în mod realist tu ești O să-și petreacă cel mai mult timp obtinerea lucrurile să meargă, să nu mai vorbim corect. Si deci corectitudinea tinde să ponderate cel mai mult, la fel ca acest factor multiplicativ de trei. Design-ul este de asemenea important, dar ceva ce nu neapărat cheltui toate aceste ore încercarea de a obține lucrurile doar pentru a lucra. 

Și așa este ponderat un pic mai ușor. Și apoi stilul este ponderat cel mai puțin. Chiar dacă nu mai e importantă în mod fundamental, este doar, poate, Cel mai simplu lucru de făcut dreapta, mimarea exemplele pe care le face în curs și secțiunea, cu lucruri, frumos alin, și a comentat, și așa mai departe este printre cele mai usoare lucruri de făcut și de a obține dreapta. Deci, ca atare, își dau seama că toate acestea sunt punctele care sunt relativ ușor de înțeles. 

Și acum un cuvânt pe astea-- onestitatea academică. Așa că pentru fiecare cursului programa, veți vedea că cursul are destul bit de limbaj în jurul valorii de acest lucru. Iar cursul ia problema onestitate academică destul de serios. 

Avem distincția, la bine și la rău, de a fi trimis în fiecare an, mai mult studenți pentru măsuri disciplinare decât majoritatea orice alt Desigur, că eu sunt conștient. Acest lucru nu este neapărat indică faptul că studenții CS, sau studenți CS50, sunt mai puțin onest decât colegii tăi. Dar realitatea că, în această mondială, în format electronic, ne-am au tehnologic mijloace de detectare a prezentei. 

Este important pentru noi pentru corectitudine în întreaga clasă că noi facem detecta acest lucru, și să ridice problema atunci când vom vedea lucrurile. Si doar pentru a picta o imagine, și într-adevăr pentru a ajuta la ceva de genul asta chiuveta, acestea sunt numerele elevii de-a lungul ultimilor 10 de ani care au fost implicați într-o astfel de probleme de onestitate academice, cu aproximativ 32 de studenți din toamna 2015, care este să spunem că noi nu iau problema foarte serios. Și, în cele din urmă, aceste numere compun, cel mai recent, aproximativ 3%, 4% sau cam asa clasei. 

Deci, pentru majoritatea super-a studenților se pare că liniile sunt clare. Dar, nu păstrați acest lucru în minte, mai ales cu întârziere în timpul nopții, când se luptă cu unele soluție la un set de probleme, că există mecanisme pentru a obține o mai bună-te sprijin decât s-ar putea cred că, chiar și la acea oră. Dau seama că atunci când primim depuneri de student, traversăm compara fiecare depunere in acest an față de fiecare depunere de anul trecut, împotriva fiecărui supunere din 2007, și din moment ce, se uită la, precum și, cod repertoarele on-line, forumuri de discuții, site-uri de locuri de muncă. Si amintim acest lucru, într-adevăr, toate de dragul de dezvăluirea completă, că dacă altcineva poate găsi on-line, cu siguranță, așa că putem curs. Dar, într-adevăr, spiritul a cursului se reduce la această clauză în programa. Este într-adevăr este doar, să fie rezonabil. 

Și, dacă a trebuit să elaboreze pe acel cu doar un limbaj pic mai mult, dau seama că esența tuturor munca pe care le trimiteți la acest curs trebuie să fie propriul tău. Dar, în termen de faptul că, există cu siguranță oportunități și încurajare, și valoarea pedagogică întorcându-se la mă others--, TFS, AC, a Tas, precum și altele în clasă, pentru sprijin, lasa prietenii singuri și colegi de cameră, care au studiat CS și programare înainte de a. Și, deci există o alocație pentru asta. Iar regula generală de degetul mare este astea-- atunci când a cere ajutor, vă poate afișa codul altora, dar nu ale lor pot vizualiza. Deci, chiar dacă sunteți la orele de birou, sau în sala D, sau în altă parte de lucru pe un anumit set bucată, lucrând alături de un prieten, care este total bine, la sfârșitul zilei munca în cele din urmă ar trebui să aparțină fiecărui dintre voi, respectiv, și nu să fie un efort de colaborare, cu excepția proiectul final în cazul în care este permis și încurajat. 

Dau seama că, dacă sunteți se luptă cu ceva și prietenul tău doar se întâmplă pentru a fi mai bine la acest lucru, atunci voi, sau mai bine la această problemă decât tine, sau un pic mai departe în față decât tine, este absolut rezonabil să se transforme la prietenul tău și spune, hei, te superi uita la codul meu aici, m-ai ajutat la fața locului care este problema mea? Și, sperăm, în interes de valoare pedagogică că prietenul nu doar spun, oh, face acest lucru, ci mai degrabă, ce lipsesc on-line 6, sau ceva de genul asta? Dar soluția nu este pentru prieten lângă tine să spunem, oh, bine, aici, lasă-mă să trag acest lucru în sus, și arată soluția mea pentru tine. Deci, aceasta este linia. Vă arată codul de la alții, dar nu pot vezi al lor, sub rezerva celuilalt constrângeri în programa cursului. 

Așa că nu ține cont de acest lucru așa-numita clauză de regret în programa cursului, precum și, că, dacă ai comite vreun act nu este rezonabil, dar aduce la atenția capetelor cursului în termen de 72 de ore, cursul poate impune sancțiuni locale poate include o nesatisfăcătoare sau grad în caz contrar pentru munca depusă. Dar, desigur, nu va deferi contează pentru măsuri disciplinare suplimentare, cu excepția cazurilor de acte repetate. Cu alte cuvinte, dacă nu face unele prost, mai ales noaptea târziu, decizia că dimineața următoare sau două zile mai târziu, te trezești și realizezi, ce mă gândeam? Ai face in CS50 au un orificiu de evacuare pentru fixarea acestei probleme și care deține până la ea, astfel încât să ne vei întâlni la jumătatea drumului și de a face cu ea într-o chestiune care este în același timp educaționale și valoroase pentru tine, dar încă punitive în vreun fel. Și acum, să ia marginea off, acest lucru. 

[REDARE VIDEO] 

[MUZICĂ] 

[END REDARE] David J. MALAN: Bine, ne-am întors. Și acum ne uităm la una dintre cele mai Primul dintre domeniile noastre din lumea reală în CS50, arta criptografiei, arta de a trimiterea și primirea mesaje secrete, criptate mesaje dacă va fi, care poate fi descifrat numai dacă aveți unele ingredient cheie pe care expeditorul are de asemenea. Deci, pentru a motiva acest lucru vom lua o privire la acest lucru aici, care este un exemplu de inel decodor secret faptul că pot fi folosite pentru a da seama ce un mesaj secret este de fapt. De fapt, înapoi în zi în școală de grad, dacă ați trimis vreodată mesaje secrete unele prieten sau unele zdrobi în clasă, s-ar putea fi crezut ai fost inteligent de pe piesa ta de schimbare a hârtiei, cum ar fi, de la A la B și B la C și C la D, si asa mai departe. Dar ați fost de fapt, criptarea informațiile, chiar dacă era un pic banal, nu a fost greu pentru ca profesorul să realizeze, bine, dacă pur și simplu schimbați B la A și C la B, de fapt, tu dai seama ce mesajul a fost, dar ai fost în cifrare informații. 

Ai fost doar o faci pur și simplu, la fel ca Ralphie aici într-un film celebru care joacă destul de mult în fiecare iarnă de anunțuri nauseum. [REDARE VIDEO] -Fi Cunoscut tuturor faptul că Ralph Parker este prin prezenta a numit un membru al Micii Orfane Annie Secret Circle și are dreptul la toate onorurile și beneficiile care apar la acestea. 

-Signed, Little orfane Annie, -Trasemnate Pierre Andre, cu cerneală. Onoruri și beneficii, deja la vârsta de nouă ani. 

[Strigând] -Haide. Hai să mergem mai departe cu ea. Nu am nevoie de tot jazz despre contrabandiști și pirați. 

mâine seară pentru Ascultă aventura de încheiere a navei pirat negru. Acum, este timpul pentru mesaj secret Annie pentru voi, membri ai Cercului Secret. Amintiți-vă, copii, numai membrii Annie Secret Circle poate decoda mesaj secret lui Annie. 

Nu uitați, Annie depinde de tine. Setați pinii dvs. la B2. Aici este mesajul. 12, 11-- 

-I Sunt în prima mea întâlnire secretă. 

-14, 11, 18, 16. 

-Pierre A fost în mare în seara asta de voce. Aș putea spune că seară Mesajul a fost foarte important. 

-3, 25, e un mesaj de la Annie însăși. Amintiți-vă, nu spune nimănui. 

-90 Secunde mai târziu, eu sunt în singurul cameră din casa unde un băiat de nouă ar putea sta în intimitate și decoda. Ha! B! M-am dus la următorul, E. 

Primul cuvânt este să fie. S, venea mai ușor acum, U, 25-- 

-Oh, Haide, Ralphie, trebuie să plec! 

-Voi Fi dreapta jos, Ma! Gee bâzâit! 

-T, O, asigurați-vă că sa-- fi sigur de ce? Ce a fost Micul orfane Annie încearcă să spună? Asigurați-vă că la ce? 

-Ralphie, Andy a reușit să du-te, te rog ieși? 

dreapta -all, Ma! Voi ieși bine! 

-Am Fost apropie acum. Tensiunea a fost teribil. Ce-a fost asta? Soarta planetei poate atârna în balanță. 

-Ralphie! Trebuie să Andy du-te! 

-Voi Fi chiar afară, pentru Dumnezeu! 

-Aproape Acolo, degetele mele au zburat, mintea mea a fost o capcană de oțel, fiecare por vibrat. Era aproape limpede, da, da, da. 

-Fi Sigur de a bea Ovaltine ta. Ovaltine? O reclamă crummy? Fecior de curva. [END REDARE] David J. MALAN: OK, deci care a fost un mod foarte lung de introducere a criptografie, și, de asemenea, Ovaltine. De fapt, din acest anunț vechi aici, de ce este Ovaltine atât de bine? Este o extracție concentrată de copt malț de orz, lapte de vacă cremos pură, a și special preparate de cacao, împreună cu fosfatide naturale și vitamine. Ea este îmbogățit în continuare cu vitamine suplimentare B și D, yum. Și îl puteți obține în continuare, se pare că, pe Amazon, așa cum am făcut-o aici. 

Dar, motivația aici a fost de a să introducă criptografie, în special un tip de criptografie cunoscută ca criptografia cheie secretă. Și, după cum sugerează și numele, întregul securitatea unui sistem cripto-cheie secretă, dacă vreți, o metodologie pentru doar codare informații între doi oameni, este că numai expeditorul și destinatarul numai știu o key-- secretă o anumită valoare, unele frază secretă, unele număr secret, că le permite atât criptați și decripta informații. Și criptografie, într-adevăr, este doar în această săptămână de la 0. 

Este o problemă în cazul în care există intrări, cum ar fi mesajul real în limba engleză sau orice limbă pe care doresc să trimită pe cineva în clasă, sau pe internet. Există unele de ieșire, care se întâmplă pentru a fi mesajul criptat pe care le doriți ca destinatarul să primească. Și chiar dacă cineva din de mijloc primește de asemenea, nu le doresc să în mod necesar în măsură să-l decripta, deoarece în interiorul acestei cutie neagră, sau algoritm, este un mecanism, unele pas cu pas instrucțiuni, pentru a lua acea intrare și conversia în de ieșire, în sperăm, un mod securizat. 

Și, de fapt, există unele vocabular în această lume, după cum urmează. Text simplu este cuvântul A om de știință de calculator ar utilizați pentru a descrie intrarea mesaj, cum ar fi limba engleză sau orice ai limbă de fapt doresc să trimită la un alt om. Și apoi este ciphertext încăierare la cifrate, sau criptat, versiune a acestuia. 

Dar, există un alt ingredient aici. Mai este o intrare la criptografia cheie secretă. Și aceasta este cheia în sine, care este, în general, după cum vom vedea, un număr, sau literă sau cuvânt, oricare ar fi algoritmul este de fapt se așteaptă. 

Și cum decripta informații? Cum de a face tu unscramble? Ei bine, doar inversa ieșirile și intrările. 

Cu alte cuvinte, odată ce cineva primește mesajul criptat, el sau ea are pur și simplu să știe că aceeași cheie. Aceștia au primit ciphertext. Și, prin conectarea celor doi intrări în sistemul cripto, algoritmul, această cutie neagră, dintr-un ar trebui să vină plaintext- originală. Și, astfel că este nivelul foarte ridicat vedere a ceea ce criptografiei este de fapt totul despre. 

Așa că hai să ajungem acolo. Să ne uităm acum dedesubt capota ceva ne-am luat de la sine pentru saptamana trecuta, iar pentru această sesiune aici-- șirul. Un șir la sfârșitul zilei este doar o secvență de caractere. 

S-ar putea să fie Hello World, sau Bună ziua Zamyla, sau orice altceva. Dar ce înseamnă asta pentru să fie o secvență de caractere? De fapt, biblioteca CS50 da ne un tip de date numit șir. 

Dar nu există de fapt nici de lucru, cum ar fi un șir de caractere în C. Este într-adevăr este doar o secvență de caracter, caracter, caracter, caracter, înapoi, în spate, la înapoi, în spate, în spate interior din memoria computerului, sau RAM. Si ne vom uita mai adânc în faptul că, în viitor, atunci când ne uităm la memorie în sine, precum și utilizarea, precum și amenințări care sunt implicate. 

Dar, să considerăm șirul Zamyla. Deci, doar numele omul aici, Zamyla, care este o secvență de caractere, Z-A-M-Y-L-A. Și acum să presupunem că numele lui Zamyla este stocată în interiorul unui calculator program. 

Ei bine, este evident motivul pentru care ar trebui să ne să fie în măsură să se uite la acele caractere individual. Deci, eu sunt doar de gând să atragă un pic cutie în jurul numelui Zamyla aici. Și este cazul în C, că, atunci când au un șir de caractere, cum ar fi Zamyla-- și poate acel șir a venit înapoi de la o funcție cum ar fi șir get, puteți manipula de fapt, caracterul prin caracter. 

Acum, acest lucru este germaniu, Pentru conversație la îndemână, deoarece în criptografie, dacă doriți să modificați A la B și B la C și C la D, și așa mai departe, trebuie să fie în măsură să se uite la caracterele individuale într-un șir de caractere. Trebuie să fii capabil să se schimbe Z la altceva, A la altceva, M pentru a altceva, și așa mai departe. Și așa avem nevoie de un fel, programatică, așa să vorbească, în C pentru a putea schimba si uita-te la litere individuale. Și noi putem face acest lucru, după cum urmează. 

Lasă-mă să plec capul înapoi în IDE CS50. Și lasă-mă să merg mai departe și de a crea un nou fișier că voi suna de data asta string0, ca primul nostru astfel de exemplu, dot c. Si voi merge mai departe și bici-l după cum urmează. 

Așa că includ CS50.h, și apoi includ io.h standard pe care am aproape întotdeauna o să să fie utilizați în programele mele, cel puțin inițial. int void main, iar apoi aici sunt eu O să facă siruri de caractere devine primi șir de caractere. Și apoi voi mergeți mai departe și de a face acest lucru. Vreau să merg mai departe și, ca un control bun-simț, doar spun, salut, procente s, semi-colon, face string 0. Uh oh, ce am făcut aici? Oh, nu l-am conectați. Așa că lecția învățată, că nu a fost intenționată. 

Asa ca eroare, mai mult la sută conversii decât argumentele date. Și acest lucru este în cazul în care, în line 7-- OK, așa că am, citat unquote, asta string meu la printf. Am un semn la sută. Dar îmi lipsește al doilea argument. 

Ratez virgulă s, care Am avut în exemplele anterioare. Deci, o bună oportunitate de a repara una mai greșeală, în mod accidental. Și acum lasă-mă alerga string0, tip în Zamyla. OK, salut Zamyla. 

Așa că ne-am rula acest tip de program de câteva ori diferite acum. Dar hai să facem ceva puțin diferit de data asta. În loc de doar de imprimare a lui Zamyla numele întreg cu printf, să o facem caracter cu caracter. 

Am de gând să utilizeze o buclă. Iar eu mă voi da o variabilă de numărare, numit i. Și, voi păstra recapitularea, așa atâta timp cât i este mai mică decât lungimea lui. 

Se pare, nu am făcut-o a face acest lucru ultima dată, că c vine cu o functie numita Stirling. Înapoi în a doua zi, și, în general, încă atunci când punerea în aplicare a funcțiilor, oamenii vor alege de multe ori foarte nume succinte acest tip de sunet ca ceea ce vrei, chiar dacă este lipsesc câteva vocalele sau litere. Deci Stirling este numele unei funcții care ia un argument între paranteze care ar trebui să fie un șir. Și se returnează doar un număr întreg, lungimea acelui șir. 

Deci, acest lucru pentru bucla de pe linia 7 se întâmplă pentru a începe numărarea la i este egal cu 0. Se va incrementa i pe fiecare iterație de 1, așa cum ne-am făcut de câteva ori. Dar se va face numai acest lucru până la punctul atunci când i este lungimea din șirul în sine. 

Deci, acesta este un mod de a, în cele din urmă, iterarea peste caractere în șir după cum urmează este. Am de gând să imprima nu o șir întreg, dar c la sută, un singur caracter urmată de o nouă linie. Și apoi voi merge mai departe, și am nevoie să spun că vreau să imprimați caracterul i-lea al lui. 

Deci dacă este variabila care indica indicele șir, unde ești în ea, trebuie să fie în măsură să spun, da-mi caracterul i-lea al lui. Și c are o cale de a face acest lucru cu paranteze drepte. Tu spui pur și simplu, pe numele șir de caractere, care în acest caz este s. Apoi, utilizați paranteze pătrate, care sunt de obicei, chiar deasupra Revenire sau Enter tasta de pe tastatură. Și apoi ai pus indexul caracterul pe care doriți să le imprimați. Astfel încât indicele va fi un number-- 0 sau 1 sau 2 sau 3 sau punct, punct, punct, un alt număr. 

Și să ne asigurăm că va este numărul corect, pentru că am începe numărarea de la 0 ° C. Și, în mod implicit, primul caracter într-un șir de caractere este, prin convenție 0. Iar al doilea caracter este placuta 1. Iar al treilea caracter este placuta 2. Si tu nu vrei să mergi prea de departe, dar vom nu pentru că suntem O să incrementa i numai până când este egală cu lungimea șirului. Și, moment în care, acest lucru pentru bucla se va opri. 

Așa că lasă-mă să merg mai departe și de a salva acest lucru de program și rulați make șir 0. Dar am greșit. de declarare a funcției de bibliotecă implicit Stirling cu tipul de astfel și such-- acum, acest lucru sună familiar. Dar nu e printf. Și nu ajunge șir. 

Nu m-am șurub sus în la fel de data aceasta. Dar observați aici un pic mai jos în continuare, includ string.h antet, prevede în mod explicit Declarația pentru Stirling. Deci, există de fapt un indiciu acolo. 

Și, într-adevăr, se pare există un alt fișier antet că nu ne-am folosit în clasa încă, dar este printre cele disponibile pentru tine, numit string.h. Și în acel dosar, string.h este Stirling a declarat. Așa că lasă-mă să merg mai departe și salvați acest lucru, face șir 0-- frumos, nici un mesaj de eroare de data asta. 

./string0 Zamyla, și Sunt pe cale de a lovi Enter, la care punctul getstring se întâmplă pentru a reveni șir, pune-l în s. Apoi, faptul că pentru bucla se va repeta peste caractere S e unul la un moment dat, și imprimați-le câte unul pe fiecare rând, deoarece Am avut că backslash n la sfârșitul anului. Așa că am putut omite că backslash n, și apoi imprimați doar Zamyla toate în aceeași linie, reimplementing efectiv printf, care nu este tot ceea ce folositor. Dar, în acest caz, nu am făcut asta. de fapt, am tipărit unul caracter la un moment dat, câte unul pe fiecare rând, astfel încât să vedem de fapt efectul. 

Dar, trebuie să adaug un singur lucru aici. Și ne vom întoarce la acest lucru într-o săptămână viitoare. Se pare că acest lucru Codul este potențial buggy. 

Se pare că, șir de caractere get și alte funcții în viață nu întotdeauna în mod necesar a reveni la ce te asteapta. Știm din clasa trecută timp în această care obține șir de caractere ar trebui să se întoarcă un șir de caractere. Dar dacă utilizatorul introduce un astfel dintr- un cuvânt lung, sau paragraf, sau un eseu că pur și simplu nu suficient memorie în computer pentru a se potrivi. 

Cum ar fi, ce se întâmplă dacă ceva nu merge greșit sub capota? S-ar putea să nu se întâmple de multe ori, dar s-ar putea întâmpla o dată într-un timp, foarte rar. Și așa se pare că șir get și funcționează ca o fac, nu neapărat a reveni întotdeauna siruri. S-ar putea returna o anumită valoare de eroare, o anumită valoare santinelă ca să spunem așa, care indică faptul că ceva a mers prost. Si tu ar sti doar asta de la au învățat în clasa acum, sau după ce a citit unele mai multe documentare. Se pare că, șir de caractere get poate returna o valoare numită nulă. Nul este o valoare deosebită pe care o vom vin înapoi într-o săptămână viitoare. Dar pentru moment, doar știu că, dacă vreau să fie într-adevăr adecvată în mișcare înainte folosind string get, eu nu trebuie doar să-l numesc, și orbește folosi valoarea de întoarcere, încrederea că este un șir de caractere. 

Ar trebui să spun în primul rând, hei, așteptați un minut, numai proceda în cazul în care s nu este egal nul, în cazul în care nul, din nou, este doar o valoare deosebită. Și este singura valoare specială vă Trebuie să vă faceți griji pentru șir get. Primi șir de caractere este fie merge pentru a returna un șir de caractere sau nul. 

Iar acest punct exclamație semnul egal s-ar putea stii de la clasa de matematică poate că s-ar putea trage un semn egal cu o linie prin ea pentru a indica nu este egal. Asta nu este, în general, un caracter aveți posibilitatea să tastați pe tastatură. Și astfel, în cele mai multe limbaje de programare, atunci când doriți să spun, nu egal, utilizați un punct de exclamare, în caz contrar, cunoscut sub numele bang-ului. Deci tu spui bang este egal, care înseamnă că nu este egal, în mod logic. E ca și cum nu există o mai mare decât sau egală sau mai mică sau egală cu taste de pe tastatura care face totul într-un singur simbol. Deci, de aceea, în exemplele anterioare, ai făcut-o paranteză deschisă, și apoi un semn egal, în scopul de a face mai mare sau, să zicem, mai puțin. 

Deci, ce-i MENIUL aici? Acest lucru este pur și simplu o modalitate de acum introducând această sintaxă, această caracteristică, iterating peste individuale caractere dintr-un șir de caractere. Și, la fel ca și cele pătrat paranteze vă permit să obțineți de la ei, ia în considerare aceste paranteze pătrate ca un fel de aluzie la acest suport proiectare, prin care fiecare caracterul în interiorul unui șir de caractere este un fel de cutie undeva dedesubt hota în memoria calculatorului. 

Dar, hai să facem o variantă a acestei. Se pare că acest lucru Programul este corect. Asa ca pe axele CS50 pentru evaluarea cod, acest lucru este corect acum. Mai ales acum că eu sunt de verificare pentru null, acest program nu ar trebui să se prăbușească. Și eu știu doar că din experiență. Dar nu e nimic altceva putem merge într-adevăr greșit aici. Dar nu este foarte bine conceput, pentru că hai să ne întoarcem la elementele de bază. 

În primul rând, principles-- ceea ce face o buclă pentru a face? O buclă face trei lucruri. Acesta inițializează unele valoare, dacă ceri să. Acesta verifică o condiție. Și apoi, după fiecare repetare, după fiecare ciclu, ea incrementează unele valoare, sau valori, aici. 

Deci, ce înseamnă asta? Noi am inițializa la 0. Verificăm și asigurați-vă că i este mai mică decât lungimea lui, care este Z-A-M-Y-L-A, acest lucru care este mai mic de 6. Și, într-adevăr, 0, mai puțin de 6. 

Noi imprima Z din numele Zamyla lui. Apoi am incrementa i la 0 la 1. Apoi vom verifica, este 1 mai puțin decât lungimea lui? Lungimea este de 6. Da, este. 

Așa că am imprima o în numele lui Zamyla, ZA. Noi incrementa i de la 0, 1, 2. Apoi vom verifica, este mai mică de 2 lungimea numelui lui Zamyla. 6- asa 2 este mai mic de 6. Da, să imprime acum M în Numele lui Zamyla, al treilea caracter. 

Cheia aici este că pe fiecare iterație de poveste, eu sunt de verificare, este i mai mică decât lungimea Zamyla? Dar captura este că Stirling nu este o proprietate. Aceia dintre voi care au programat înainte de a în Java sau în alte limbi ar putea să cunoască lungimea unui șir de caractere este o proprietate, doar câteva citit doar o valoare. 

În C, în acest caz, în cazul în care acest lucru este o funcție care este literalmente numararea caractere în Zamyla de fiecare dată noi numim această funcție. De fiecare dată când cere computerului să utilizeze Stirling, este de a lua o privire la Zamyla, și spunând Z-A-M-Y-L-A, 6. Și se întoarce 6. Data viitoare când te sun ea în interiorul că pentru bucla, o să se uite la Zamyla din nou, să zicem Z-A-M-Y-L-A, 6. Și va să se întoarcă 6. Deci, ce e prost despre acest design? 

De ce este codul meu nu un 5 din 5 pentru proiectare chiar acum, ca să spunem așa? Ei bine, eu cer un întrebare în mod inutil. Fac mai mult de lucru decât am nevoie. 

Așa că, chiar dacă raspunsul este corect, eu sunt cere computerului, ceea ce este lungimea Zamyla din nou, și din nou, și din nou, și din nou? Iar acest răspuns este nu se va schimba. Întotdeauna o să fie 6. 

Deci, o soluție mai bună decât aceasta ar fi această versiune următoare. Lasă-mă să merg mai departe și pune-l într-un fișier separat numit string1.c, doar să-l păstrați separa. Și se pare că într-un timp de buclă, aveți posibilitatea de fapt declara mai multe variabile dintr-o dată. 

Așa că voi să mă păstreze și să-l setați la 0. Dar eu sunt, de asemenea, o să adăugați o virgulă, și spune, da-mi o variabilă numită n, a cărui valoare este egală cu lungimea șirului de caractere de s. Și acum, te rog să-mi starea atât timp cât i este mai mică decât n. 

Deci, în acest fel, logica este identic la sfârșitul zilei. Dar eu sunt amintindu-ne Valoarea 6, în acest caz. Care este lungimea numelui lui Zamyla? Si eu o pune la n. 

Si eu sunt încă de verificare condiția de fiecare dată. Este 0 mai puțin de 6? Este 1 mai puțin de 6? Este de 2 mai puțin de 6, și așa mai departe? 

Dar nu-ți cer calculatorul din nou, și din nou, ceea ce este lungimea numelui lui Zamyla? Care este lungimea numelui lui Zamyla? Care este lungimea numelui acestui Zamyla lui? Sunt literalmente să ne amintim că mai întâi și răspundă doar în această a doua n variabile. Deci, acest lucru acum ar fi nu numai corectă, dar, de asemenea, bine concepute. 

Acum, ce zici de stil? Am numit variabilele mele destul de bine, aș spune. Sunt foarte succint chiar acum. Și asta e total bine. 

Dacă aveți doar un singur șir într-un program, s-ar putea la fel de bine suna-l pentru șir. Dacă aveți doar o singură variabilă pentru numărarea într-un program, s-ar putea la fel de bine numi i. Dacă aveți o lungime, n este super comun, de asemenea. Dar nu am comentat nici din codul meu. 

Nu am informat reader-- dacă asta e TF mea, sau TA, sau pur și simplu colleague-- ceea ce se presupune să se întâmplă în acest program. Și, astfel încât pentru a obține stil bun, ceea ce aș vrea să fac este astea-- ceva cum ar fi întrebați de utilizator pentru intrare. Și aș putea rescrie acest orice număr de moduri. 

Asigurați-vă că asigurați-vă că get S- șir de caractere returnat un șir de caractere. Și apoi în aici-- și acest lucru este, probabil, cel mai important iterăm comment-- peste personajele e unul la un moment dat. Și aș putea folosi orice alegerea limbii engleze aici pentru a descrie fiecare din aceste bucăți de cod. 

Observați că nu am pus-o comentariu pe fiecare linie de cod, într-adevăr doar pe interesant Noștri, cei care au un înțeles că aș putea doresc să facă super-clar cuiva citind codul meu. Și de ce ai sunat obține string întreba de utilizator pentru intrare? Chiar că nu este neapărat tot ceea ce descriptiv. Dar ajută spune o poveste, pentru că a doua linie din poveste este, asigurați-vă că obține șir returnat un șir de caractere. 

Și al treilea rând din poveste este, itera personajele s-unul la un moment dat. Și acum doar pentru o bună măsură, Mă duc să merg mai departe și se adaugă mai mult de un comentariu care tocmai spune imprimare i-lea caracter din s. Acum, ce am făcut la sfarsitul zilei? 

Am adăugat puțină engleză cuvinte sub formă de comentarii. Simbolul slash slash înseamnă, hei, computerul este pentru om, nu pentru tine, calculatorul. Deci sunt ignorate în mod logic. Sunt pur și simplu acolo. 

Și, într-adevăr, CS50 IDE le prezinta ca gri, ca fiind util, dar nu-cheie la program. Observați ce poți face acum. Indiferent dacă știi C programare sau nu, poate sta doar înapoi la acest program și degresat comentarii. Solicitați utilizatorului de intrare, asigurați-vă că obține șir returnat un șir de caractere, itera caracterele din s unul la un moment dat, imprima caracterul caracterul i-lea în tine nu S- chiar trebuie să se uite la codul pentru a înțelege ce face acest program. Si, mai bine încă, dacă te uiți la acest program într-o săptămână sau două, sau o lună sau un an, tu nu ai să se uite la codul, încercând să-și amintească, ce am fost încercarea de a face cu acest cod? 

Te-ai spus. L-ai descris pentru tine, sau un coleg, sau AT, sau TF. Și, astfel încât acest lucru ar fi acum corectă, și un design bun, și în cele din urmă stil bun, de asemenea. Deci, nu țin minte. 

Așa că există un alt lucru pe care am de gând să fac aici care poate dezvălui acum exact ceea ce-i merge pe sub capota. Deci, nu există această caracteristică în C, și în alte limbi, numit typecasting că, fie implicit sau permite în mod explicit să convertiți de la un tip de date la altul. Am fost de-a face acest lucru departe astăzi, cu siruri de caractere. 

Si sunt siruri de caractere. Dar, amintesc de săptămână 0, ce sunt caractere? Caracterele sunt doar o abstracție pe partea de sus a numerelor zecimale Numere, și numere zecimale sunt de fapt doar un abstracție de pe partea de sus a numerelor binare, așa cum l-am definit. 

Așa că caractere sunt numere. Si numerele sunt caractere, doar în funcție de context. Și se pare că în interior a unui program de calculator, se poate specifica modul în care doriți să se uite la biții din interiorul acestui program? 

Reamintim din săptămâna 0 pe care am avut Ascii, care este doar acest cod scrisori de mapare către numere. Și noi am spus, capitalul A este de 65. Capital B este de 66, și așa mai departe. 

Și observați, avem în esență Alfabet pe rândul de sus de aici, așa cum le-ar numi C, caractere și apoi Ints de pe al doilea rând. Și se pare că se poate converti perfect între cele două, de obicei. Iar dacă vrem să facem acest lucru în mod deliberat, noi ar putea dori să abordeze ceva de genul. 

S-ar putea dori să convertească caz de sus pentru a scădea caz, sau litere mici la majuscule. Și se pare că nu există de fapt, un model de aici putem îmbrățișa într-un moment. Dar, să ne uităm mai întâi la un de exemplu, de a face acest lucru în mod explicit. 

Mă duc să mă întorc în IDE CS50. Voi crea un fișier numit Ascii 0.c. Si voi merge mai departe și se adaugă meu io.h standard la partea de sus, void main int în partea superioară a funcției mele. Și apoi am de gând doar pentru a face following-- o buclă de la i este egal, să zicem, 65 de ani. 

Și apoi am va fi mai mică 65, plus 26 de litere din alfabet. Așa că voi lăsa computerul nu matematica pentru mine acolo. Și apoi în interiorul această buclă, ce am de gând să imprima? 

% C este% i n backslash-ul. Și acum vreau să conectați două valori. Am pus temporar întrebare marchează acolo pentru a invita la întrebare. 

Vreau să itera de la 65 mai departe pentru 26 de litere ale alfabetului, imprimarea pe fiecare iterație care echivalent integrală personajului. Cu alte cuvinte, vreau să itera peste 26 de numere de imprimare ceea ce este caracterul Ascii, litera, și ce este-- numărul corespunzător într-adevăr doar recrearea diagrama din acel diapozitiv. Deci, ce ar trebui să fie aceste semne de întrebare? 

Ei bine, se pare că a doua ar trebui să fie doar variabila i. Vreau să văd că un număr. Iar argumentul din mijloc aici, pot spune computerul pentru a trata acel număr întreg i ca un caracter, astfel încât să-l înlocuiască aici pentru procente C. 

Cu alte cuvinte, dacă I, programator uman, știu acestea sunt doar numere la sfarsitul zilei. Și știu că 65 ar trebui harta la unele caractere. Cu această distribuție explicită, cu o paranteză, denumirea tipului de date pe care doriți să converti la, și o paranteză închisă, vă pot spune calculator, hei, calculator, converti acest număr întreg de la un char. 

Așa că, atunci când am rula acest Programul după compilare, Să vedem ce fac get-- Ascii 0. Darn asta, ce am făcut greșit aici? Utilizarea de identificator la negru, Bine, nu intenționat, dar hai să vedem dacă nu putem motiv pentru asta. 

Așa că linia five-- așa că nu am primit foarte mult înainte de înșurubare. Asta e ok. Așa că linia 5 pentru i este egal cu 65-- eu văd. Deci, amintiți că în C, spre deosebire de unele limbi dacă aveți programare prealabilă experiență, aveți pentru a spune calculatorul, spre deosebire de zero, ceea ce tipul de variabilă este. 

Am uitat o fraza cheie aici. În linia de cinci, am inceput sa folosesc eu. Dar nu am spus C ce tip de date este. Așa că am de gând să merg aici și spun, ah, este un număr întreg de a face. 

Acum am de gând să merg mai departe și recompilare. Asta fix asta. ./ascii0 Enter, asta e un fel de rece. Nu numai ca este super rapid la întrebați calculatorul la această întrebare, mai degrabă decât în ​​căutarea sus pe un diapozitiv, tipărit unul pe fiecare rând, A este de 65, B este de 66, tot drumul down-- de când am a făcut acest lucru 26 times-- la literele z, care este de 90. Și, de fapt, ușor mai inteligent ar au fost pentru mine să nu se bazeze pe computer pentru a adăuga 26. Aș fi putut face doar 90, de asemenea, atât de mult timp ca eu nu fac aceeași greșeală de două ori. Vreau să merg în sus, prin z, nu doar în sus prin y. 

Deci, asta e o distribuție explicită. Se pare că acest lucru nu este chiar necesar. Lasă-mă să merg mai departe și să rulați din nou acest lucru compilator, și executați din nou ascii 0. Se pare că, C este destul de inteligent. 

Și printf, în special, este destul de inteligent. Dacă treci doar un i de două ori pentru ambele Substituenți, printf va realiza, oh, bine eu te cunosc mi-a dat un integer-- unele număr, cum ar fi 65, sau 90, sau orice altceva. Dar eu văd că ai vrea să formata acel număr ca un personaj. Si astfel printf poate arunca implicit int la un char pentru tine la fel de bine. Deci asta nu e deloc o problemă. 

Dar, observați, din cauza acestei echivalență putem face de fapt acest lucru la fel de bine. Lasă-mă să merg mai departe și să facă o altă versiune a astea-- 1.c. Ascii Și în loc de itera peste numere întregi, se poate sufla într-adevăr mintea ta prin iterarea peste caractere. În cazul în care un char c devine de capital A, I doresc să meargă mai departe și de a face acest lucru, atâta timp cât C este mai mică sau egală la Z. de capital și pe fiecare iterație Vreau să incrementa C, eu pot acum, în linia mea printf aici să zicem, procente C este procente i din nou, virgula C. 

Și acum, eu pot merge în altă direcție, turnare caracterul explicit la un întreg. Deci, din nou, de ce ai face asta? E un pic ciudat pentru a sorta de conta în termeni de caractere. 

Dar, dacă înțelegi ce e merge pe sub capota, nu există într-adevăr nici o magie. Spui, hei, calculator da mi o variabilă numită C de tip char. Inițializați la capitalul A. Și observați o singură chestiune citate. 

Pentru caractere în C, amintesc de la săptămâna trecută, utilizați ghilimele simple. Pentru siruri de caractere, pentru cuvinte, fraze, utilizați ghilimele duble. OK, calculator, face asta, așa atâta timp cât caracterul este mai mic sau egală cu z. Și eu știu de la masa mea Ascii că toate din aceste coduri Ascii sunt învecinate. 

Nu există lacune. Deci, e doar de la A la Z, separate printr-un singur număr fiecare. Și apoi eu pot incrementa char, dacă eu chiar vreau. La sfarsitul zilei, este doar un număr. Stiu asta. Deci, eu pot presupune că doar pentru a adăuga 1 la acesta. 

Și apoi de data aceasta, am imprima c, și apoi echivalentul integrală. Si eu nici nu trebuie exprimate explicit. Eu pot lăsa printf și Figura de calculator lucrurile, astfel că acum, dacă am alerga face Ascii1./ascii1, Am obține exact același lucru la fel de bine. 

Programul nefolositor, though-- nimeni se va scrie de fapt, software-ul în scopul de a da seama, ce a fost număr care hărți la A, sau B, sau Z? Tu doar o să-l Google sau uite-l on-line, sau uite-l pe un diapozitiv, sau ceva asemănător. Așa că în cazul în care acest lucru nu obține de fapt, util? 

Ei bine, vorbind de asta diapozitiv, observați acolo un tipar real aici între litere mari și litere mici, care nu a fost accidentală. Observați că capitalul A este de 65. Minuscule a este de 97. Și, cât de departe este mai mic caz o? 

Asa ca 65 de ani este cât de mulți pași distanță de 97? Așa că 97 minus 65 este de 32. Astfel încât capitalul este o 65 de ani. Dacă adăugați 32 la faptul că, veți obține literele mici. Și, în mod echivalent, dacă scădem 32, te înapoi la capital a-- același cu B la puțin b, C mare la puțin c. 

Toate aceste decalaje sunt 32 în afară. Acum, acest lucru s-ar părea să ne permită să a face ceva de genul Microsoft Word, sau Google Docs dispun, în cazul în care vă poate selecta totul și apoi spune, schimba toate în litere mici, sau schimba toate la majuscule, sau schimba numai primul cuvânt a unei teze la majuscule. Putem face de fapt ceva așa noi înșine. 

Lasă-mă să merg mai departe și de a salva un fișier numită aici valorifica 0.c. Și să mergem mai departe și biciul un program de care face exact asta după cum urmează. Așa că includ biblioteca CS50. Și includ standardul I / O. 

Și știu că acest lucru vine în curând. Așa că am de gând să-l pună în există deja, string.h, așa că am acces la lucruri cum ar fi Stirling, și apoi int void main, ca de obicei. Și apoi am de gând să merg mai departe și de a face siruri de caractere devine obține șir, doar pentru a obține un șir de caractere de utilizator. Și apoi voi face cecul meu bun-simț. În cazul în șir nu nul egal, atunci este sigur pentru a continua. Și ce vreau să fac? Mă duc la itera de la i este egal cu 0, și n până la lungimea șirului de caractere de s. 

Si eu voi face acest lucru, atât timp cât i este mai mică decât n, și eu, plus, plus. Până în prezent, eu sunt cu adevărat doar împrumută idei de la mai înainte. Și acum am de gând să introducă o sucursală. 

Deci, cred că înapoi la zero, în cazul în care am avut aceste furci în drum, și săptămâna trecută în C. voi spun acest lucru, în cazul în care caracterul i-lea s este mai mare sau egală cu un caz mai mic, si-- în Scratch te-ar literalmente spune și, dar în C, ai spune ampersand, ampersand-- și caracterul i-lea s este mai mică sau egală cu litere mici z, hai să facem ceva interesant. Hai să tipăriți, de fapt dintr-un caracter cu nici o linie noua care este personajul din șirul, caracterul i-lea în șir. 

Dar, să mergem mai departe și scade 32 din ea. Altfel, dacă personajul din șir de caractere pe care-l căutăm nu este între o mică și puțin z, mergeți mai departe și doar tipărit neschimbat. Prin urmare, am introdus această notație între paranteze pentru coarde noastre pentru a ajunge la i-lea caracter din șirul. 

Am adăugat unele logica condiționată, cum ar fi Zgârietură într-o săptămână săptămâna trecută, în cazul în care Sunt doar cu ajutorul meu fundamental înțelegerea a ceea ce este merge pe sub capota. Este caracterul i-lea al lui mai mare sau egală cu o? Cum ar fi, este de 97, sau 98, sau 99, și așa mai departe? 

Dar este, de asemenea, mai mică sau egală la valoarea de litere mici z? Și dacă da, ce înseamnă această linie? 14, acesta este un fel de germeni de întreaga idee, valorifica scrisoarea de pur și simplu, scăzând 32 din aceasta, în acest caz, pentru că știu, pe care diagramă, modul în care sunt reprezentate numerele mele. Așa că hai să mergem mai departe și a alerga acest lucru, după compilarea valorifica 0.c, și a alerga valorifica 0. 

Hai să scrieți ceva de genul Zamyla în litere mici intră. Și acum avem Zamyla în majuscule. Hai să introduceți Rob în litere mici. Să încercăm Jason în toate cu litere mici. Si ne-a păstra achiziție capitalizarea forțată. E un bug minor pe care am un fel de nu a anticipat. Observă noua mea promptă se încheie în sus pe aceeași linie ca și numele lor, care se simte un pic murdar. 

Așa că am de gând să merg aici, și de fapt, la sfârșitul acestui program imprima un caracter de linie noua. Asta e tot. Cu printf, nu trebuie să trece în variabile sau cod format. Aveți posibilitatea să literalmente doar de imprimare ceva de genul o linie nouă. 

Așa că hai să mergem mai departe și să facă valorifica 0 din nou, rulați din nou ea, Zamyla. Și acum este un pic mai frumos. Acum, prompta mea este pe linie nouă. Deci asta e tot fin și bun. Deci asta e un bun exemplu. Dar eu nici măcar nu neapărat Trebuie să codul greu 32. Știi ce? Aș putea say-- eu nu fac niciodată amintiți-vă ce diferența este. 

Dar eu știu că, dacă am au o literă mică, Vreau, în esență, pentru a scădea off indiferent de distanța este între mică o și mai mare A, pentru că dacă presupun că toate celelalte litere sunt aceleași, că ar trebui să obțineți treaba. Dar, mai degrabă decât a face asta, știi ce? Mai există o cale încă. 

În cazul în care se valorifica 1.c-- dacă aș fi fost pentru a pune că într-un fișier separat. să-și valorifică 2.c după cum urmează. Voi curăța într-adevăr asta aici. Și, în loc de a avea chiar să știu sau de îngrijire despre cele de nivel scăzut detaliile de implementare, sunt în schimb merge doar pentru a imprima un caracter, citat unquote, procente C, și apoi apelați o altă funcție care există, că are un argument, care este un personaj, ca aceasta. 

Se pare ca în C, există un alt apel de funcție la partea superioară, care, ca și numele sugerează ia un caracter și-l face la cazul său superior echivalent, și apoi se întoarce astfel încât printf se poate conecta acolo. Și, ca să facă acest lucru, deși, eu Trebuie să se introducă un alt fișier. Se pare ca exista un alt fișier pe care le-ar cunoaște doar din clasă, sau un manual sau o platformă online referință, numit type.h. C 

Deci, dacă am adăuga că în sus printre antetul meu fișiere, iar acum re-compila acest program, capitalize2, ./capitalize2 Enter. Hai să tastați în Zamyla în toate litere mici, funcționează încă la fel. Dar știi ce? Se pare că, la partea superioară are unele alte funcționalități. 

Și lasă-mă să introducă această comand de aici, un fel de penibil numit, dar pentru om manual. Se pare că, cele mai multe calculatoare Linux, așa cum ne folosim aici-- de operare Linux system-- au o comandă numit om, care spune, hei, calculator, da-mi manualul computerului. Ce dorești să privi în sus în acest manual? 

Vreau să mă uit în sus funcția chemat la partea superioară, Enter. Și este un pic criptic pentru a citi uneori. Dar observați că suntem în manualul Linux programator. Și e tot textul. Și observați că acolo e numele funcției aici. Se pare ca ea are un văr numit pentru a reduce, care face exact opusul. Și o notificare în conformitate cu sinopsis, pentru a utiliza aceasta funcționa pagina de om, ca să spunem așa, îmi spune că am Trebuie să includă c type.h. Și am știut că din practică. 

Aici, eu care arată cele două prototipuri pentru funcția, astfel încât, dacă am dori vreodată să utilizați acest Știu ce le iau ca intrare, și ceea ce se întorc ca ieșire. Și apoi, dacă am citit descrierea, eu văd mai în detaliu ceea ce face funcția. Dar, mai important, dacă Mă uit sub valoarea de returnare, se spune valoarea returnată este cea a literei convertite, sau C, intrarea originală, dacă conversia nu a fost posibilă. 

Cu alte cuvinte, la partea superioară va încerca pentru a converti o literă la majuscule. Și dacă este așa, o să-l întoarcă. Dar, în cazul în care nu se poate pentru unii reason-- Poate că e cazul deja de sus, Poate că e un punct de exclamare sau alte punctuation-- este doar de gând să returnează originalul C, ceea ce înseamnă că pot face codul meu mai bine proiectate după cum urmează. 

Nu am nevoie de toate aceste linii darn de cod. Toate liniile l-am doar a subliniat poate fi prăbușit într-un singur simplu line, care este astea-- la sută printf c pentru suportul superior S i. Și acest lucru ar fi o exemplu de design mai bun. 

De ce să pună în aplicare în 7 sau 8 linii de cod, oricare ar fi fost eu doar șters, atunci când se poate prăbuși în schimb toate că procesul de luare a deciziilor și logica într-o singură linie, 13 acum, că se bazează pe o bibliotecă de function-- o funcție care vine cu C, dar că face exact ceea ce vrei să faci. Si, sincer, chiar dacă ea nu a venit cu C, ai putea pune în aplicare le ca am vazut, cu a lua int negativ și pentru a obține pozitiv int săptămâna trecută, de asemenea. 

Acest cod de acum este mult mai ușor de citit. Și, într-adevăr, dacă vom defila în sus, uite cât de mult mai compact această versiune a programului meu este. Este un pic mai grea de top acum, cu toate acestea include. Dar asta e în regulă, pentru că acum sunt în picioare pe umerii programatori înaintea mea. Si oricine ar fi fost cine puse în aplicare la partea superioară într-adevăr mi-a făcut o favoare, la fel ca oricine Stirling a implementat într-adevăr mi-a făcut o favoare ceva timp în urmă. Și așa acum avem un mai bine programul de proiectare care pune în aplicare aceeași logică exactă. 

Vorbind de Stirling, să mă să merg mai departe și fac acest lucru. Lasă-mă să merg mai departe și de a salva acest fișier ca stirling.c. Și se pare, putem coaja înapoi un alt strat destul de simplu acum. Mă duc să merg mai departe și bici un alt program, în principal aici că pur și simplu re-unelte Lungimea șir după cum urmează. Deci, aici este o linie de cod care mă primește un șir de caractere de utilizator. Continuăm să utilizați acest lucru din nou și din nou. Permiteți-mi să mă dau o variabilă numită n de tip int care stochează un număr. 

Și lasă-mă să merg mai departe și face următoarea logică. În timp ce caracterul n-lea, în s nu nu este egal cu 0 backslash, merge mai departe și creșterea n. Și apoi imprima procente printf i n. Eu susțin că acest program aici, fără a apela lungimea șirului de caractere, cifrele lungimea unui șir de caractere. 

Iar magia este în întregime încapsulate în linia 8 aici cu ceea ce arata ca sintaxă nouă, acest backslash 0 în ghilimele simple. Dar de ce este asta? Ei bine, ia în considerare ceea ce a fost întâmplă tot acest timp. 

Și, ca o parte, înainte să uit, dau seama de asemenea, că, în plus față de paginile man care vin cu un tipic sistem Linux cum ar fi CS50 IDE, dăm seama că noi, Personalul curs, au, de asemenea, a făcut o versiune site din aceeași idee numită reference.cs50.net, care are toate aceste pagini același om, toate aceeași documentație, precum și o cutie mică la partea de sus, care permite să converti toate în mod echitabil limba Arcane în mai puțin confortabil modul, în cazul în care noi, cadrele didactice, au trecut prin și au încercat să simplifice o parte din limba pentru a păstra lucrurile axat pe idei, și nu unele dintre aspectele tehnice. Astfel încât să păstreze în minte, reference.cs50.net ca o altă resursă, de asemenea. 

Dar de ce funcționează lungimea șir în modul în care am propus un moment în urmă? Iată numele lui Zamyla din nou. Si aici e numele lui Zamyla cutie în, așa cum am continua să faci, pentru a picta o imagine a acesteia fiind, într-adevăr, doar o secvență de caractere. Dar Zamyla nu există în mod izolat, într-un program. 

Atunci când scrieți și executați un program, utilizați Mac-ul sau PC-ul ca memorie, sau RAM ca să spunem așa. Și vă puteți gândi computerul dvs. ca având o mulțime de GB de memorie în aceste zile. Și un concert înseamnă miliarde, astfel încât miliarde de bytes. 

Dar hai să derulați înapoi în timp. Și să presupunem că noi folosim un calculator foarte vechi, care are doar 32 de bytes de memorie. Am putea, pe ecranul computerului meu, trage pur și simplu acest lucru, după cum urmează. 

Aș putea spune pur și simplu că mi computer are toate această memorie. Și acest lucru este ca un stick de memorie, în cazul în care vă amintiți imaginea noastră de ultima dată. Și, dacă aș împărți acest lucru în destul de ori, Eu pretind că am 32 de octeți de memorie de pe ecran. 

Acum, în realitate, eu pot doar trage până în prezent pe acest ecran de aici. Așa că am de gând să merg mai departe, și doar prin convenție, trage memoria computerului meu ca grilă, nu doar ca o singură linie dreaptă. Mai exact, eu pretind acum că această grilă, această 8 prin 4 grilă, doar reprezintă toți cei 32 de bytes de memorie disponibil în Mac-ul meu, sau disponibil în PC-ul meu. Si acestea sunt ambalate pe două linii, doar deoarece se potrivește mai mult pe ecran. Dar acesta este primul octet. Acesta este al doilea octet. Acesta este al treilea octet. 

Și acest lucru este octet al 32-lea. Sau, dacă ne gândim ca un computer om de știință, acest lucru este octet 0, 1, 2, 3, 31. Asa ca aveti 0 la 31, în cazul în care începe numărarea de la 0 ° C. 

Așa că, dacă vom folosi un program de că apelurile obține șir de caractere, și vom obține un șir de la om așa cum am numit Zamyla, Z-A-M-Y-L-A, cum în lume face urmări a vă menține computerul de care octet, care bucată de memorie, aparține care șir? Cu alte cuvinte, dacă vom proceda la introduceți un alt nume în computer, ca aceasta Andi, numindu obține șir de caractere pentru a doua oară, A-N-D-I trebuie să ajungă în memoriei calculatorului, de asemenea. Dar cum? 

Ei bine, se pare că dedesubtul hota, ceea ce face C atunci când se stochează șiruri că tipurile umane, sau că provin dintr-o altă sursă, este delimiteaza sfârșitul celor cu un backslash character-- specială 0, care este doar un mod special de a spune 80 de biți într-un rând. 

Așa că a-- aceasta este retragerea numarul 97. Astfel încât unele model de 8 biți reprezintă număr zecimal 97. Acest lucru backslash 0 este literalmente numărul 0, Nul a.k.a., N-U-L, spre deosebire de mai devreme, N-U-L-L, pe care am discutat. Dar pentru moment, doar știu că acest lucru backslash 0 este la doar 80 de biți într-un rând. 

Și este doar linia urmatoare în nisip care spune nimic la stânga aparține unuia șir de caractere, sau un singur tip de date. Și orice la dreapta face parte din altceva. Numele lui Andi, între timp, care doar vizual se întâmplă să-și încheie pe cealaltă linie, dar asta e doar un detaliu estetic, în mod similar, este terminată Nul. 

Este un șir de caractere A-un N-D-I, plus un caracter secret de-al cincilea, toate 0 biți, pe care tocmai l delimiteze la sfârșitul numelui lui Andi, de asemenea. Iar dacă facem apel primi șir pentru a treia oară în computer pentru a obține un șir de caractere cum ar fi Maria, M-A-R-I-A, la fel este Maria Numele Nul terminat cu backslash 0. 

Acest lucru este fundamental diferit de la modul în care un calculator ar fi în mod tipic stoca un număr întreg, sau un float, sau alt tipuri de date încă, deoarece amintesc, un număr întreg este de obicei de 32 de biți, sau 4 bytes, sau poate chiar 64 de biți, sau opt octeți. Dar, de multe într-un calculator Primitive într-un limbaj de programare au un număr fix de bytes sub hood-- poate 1, poate 2, poate 4, poate 8. 

Dar, siruri de caractere, prin design, au un Numărul dinamic de caractere. Dacă nu știi în avans, până la a omului tipurile în Z-A-M-Y-L-A, sau M-A-R-I-A, sau A-N-D-I. Dacă nu știi de câte ori utilizatorul va lovi tastatura. Prin urmare, nu știi cum multe caractere in avans vei avea nevoie. 

Și așa C doar un fel de frunze ca un breadcrumb secrete sub capota la sfârșitul șirului. După stocarea Z-A-M-Y-L-A în memorie, ea, de asemenea, pune doar echivalentul unei perioade. La sfârșitul unei propoziții, pune 80 de biți, astfel încât să vă amintiți unde Zamyla începe și se termină. 

Deci, ce e legătura, apoi, la acest program? Acest program aici, Stirling, este pur și simplu un mecanism pentru a obține un șir de caractere de la utilizator, linia 6. Linia 7, declar o variabilă numit n și setați-l egal cu 0. 

Și apoi, în linia 8, pur și simplu am întrebat întrebare, în timp ce caracterul n-lea nu nu este egal cu 0 toate bits-- cu alte cuvinte, nu egală cu această specială caracter, backslash 0, care a fost doar că character-- Nul speciale merge mai departe și doar incrementa n. 

Și continua să faci asta, și să păstreze făcând-o și continua să faci asta. Și astfel, chiar dacă în trecut le-am folosit eu, Este foarte bine semantically de a utiliza n, dacă doar încerci să Numar de data aceasta în mod deliberat, și vreau doar să-l sun n. Deci, acest lucru păstrează doar pune întrebarea, este caracterul n-lea al lui toate 0s? În cazul în care nu, uita-te la aspectul următor, uita-te la următorul, uita-te la următorul, uita-te la următorul. 

Dar, de îndată ce veți vedea backslash 0, oprește această linie loop-- 9 prin 11--. Te rupe din bucla in timp ce, lăsând în interiorul acelei variabile n un număr total al tuturor caractere din șirul văzut, i astfel imprimarea. Așa că hai să încercăm acest lucru. 

Lasă-mă să merg mai departe și, fără folosind funcția Stirling, dar folosind doar propria mea versiune Homegrown numit aici Stirling, lasă-mă să merg mai departe și a alerga Stirling, tastați ceva cum ar fi Zamyla, pe care știu dinainte este de șase caractere. Hai să vedem dacă funcționează. Într-adevăr, este de șase. Să încercăm cu Rob, trei personaje, trei personaje la fel de bine, și așa mai departe. Deci, asta e tot ce se întâmplă pe sub capota. Și observați conexiunile, apoi, cu prima săptămână de clasă, în cazul în care am vorbit despre ceva de genul abstractizare, care este doar această stratificare de idei, sau complexitate, pe partea de sus a principiilor de bază. Aici, suntem un fel de a privi sub capota lui Stirling, ca să spunem așa, să ne dăm seama, cum ar fi pus în aplicare? 

Si am putea re-pune în aplicare noi înșine. Dar noi niciodată nu merge pentru a re-punerea în aplicare a Stirling. Noi doar o să utilizați în ordine Stirling pentru a obține de fapt, unele de lungime siruri de caractere. 

Dar nu e nici o magie sub capota. Dacă știți că dedesubt capota, un șir de caractere este doar o secvență de caractere. Și acea secvență de caractere toate pot fi abordate numeric cu suport de 0, placuta 1, suport 2, și tu știu că, la sfârșitul unui șir de caractere este caracter special, vă puteți da seama cum să facă mai nimic într-un Programul, pentru că toate se reduce la este citirea și scrierea de memorie. Aceasta este, în schimbare și în căutarea în memorie, sau lucrurile în mișcare în jurul valorii în memorie, lucruri de imprimare pe ecran, și așa mai departe. 

Așa că hai să folosim acum acest nou descoperita înțelegere a ceea ce siruri de fapt sunt sub capota, si coaja de spate un alt strat că până acum ne-am ignorat cu totul. În special, orice moment am implementat un program, am avut această linie de cod lângă partea de sus a declara principal. Si ne-am specificat void main int. 

Iar acel gol în interiorul paranteze a fost spus tot acest timp că principala ea însăși nu ia nici un argument. Orice intrare care este principala mergi pentru a obține de la utilizator trebuie să provină din alte mecanism, cum ar fi get int sau de a lua float, sau pentru a obține șir de caractere, sau o altă funcție. Dar se pare că atunci când scrie un program, puteți specifica de fapt, că acest program va ia de la om intrări la linia de comandă în sine. 

Cu alte cuvinte, chiar dacă până acum au fost difuzate doar ./hello salut sau programe similare, toate cele trei opțiuni alte programe pe care le-am fost folosind, că noi înșine nu am scris, au fost luati, se pare, linie de comandă arguments-- lucruri cum ar fi marca. Tu spui ceva de genul marca, și apoi un al doilea cuvânt. Sau zăngăni, tu spui clang, și apoi un al doilea cuvânt, numele unui fișier. 

Sau chiar RM sau CP, după cum s-ar putea au văzut sau utilizate deja pentru a elimina sau a copia fișiere. Toți cei care iau așa-numitele linie de comandă arguments-- cuvinte suplimentare la terminal prompt. Dar, până în prezent, noi noi nu am avut acest lux de a lua de intrare de la utilizator atunci când el sau ea se execută efectiv programul in sine, la linia de comandă. 

Dar putem face acest lucru prin re-declarând principal în mișcare înainte, nu ca având nule în paranteze, dar aceste două argumente instead-- primul un număr întreg, iar al doilea ceva nou, ceva ce vom suna o matrice, ceva similar în spirit ceea ce am văzut în Scratch ca o listă, dar o serie de șiruri, după cum vom vedea în curând. Dar, să vedem acest lucru Ca exemplu, înainte distinge exact ceea ce înseamnă că. 

Așa că, dacă mă duc în CS50 IDE aici, m-am dus mai departe și a declarat într-un fișier numit argv0.c următorul șablon. Și observați singurul lucru care este diferit de până acum este că m-am schimbat void int argc șir de caractere argv placuta deschis, aproape placuta. Și observați pentru moment, există nimic în interiorul acestor paranteze. 

Nu există nici un număr. Și nu există nici eu, sau n, sau orice altă literă. Sunt doar folosind paranteze pătrate pentru acum, din motive noi vom veni înapoi la un moment. 

Și acum, ce am de gând să fac asta. În cazul în care este egal cu argc este egal cu 2-- și reamintească faptul că este egal la egal la egal este operatorul de egalitate comparat la stânga și la dreapta pentru egalitate. Nu-i cesiunea operatorul, care este semnul egal unic, ceea ce înseamnă copie de la dreapta la stânga, o anumită valoare. 

În cazul în care este egal cu argc este egal cu 2, vreau să să zicem, printf, Buna ziua, procente, noua linie, și apoi conectați in-- și aici este noul Suport argv trick-- 1, din motive că vom reveni la un moment. Altfel, dacă argc nu egal cu 2, știi ce? Să mergem mai departe și, ca de obicei, de imprimare out salut lume, cu nici o schimbare. 

Asa ca s-ar părea că, dacă argc, care reprezintă numărul de argument, este egal cu 2, Am de gând să imprima salut ceva sau altul. În caz contrar, în mod implicit, sunt va imprima Bună ziua lume. Deci, ce înseamnă asta? 

Ei bine, lasă-mă să merg mai departe și de a salva acest fișier, și apoi faceți face argv0, și apoi ./argv0, Enter. Și se spune Salut lume. Acum, de ce e asta? 

Ei bine, se pare că oricând aveți rula un program de la linia de comandă, vă sunt de umplere în ceea ce noi vom numesc în general, un vector de argument. Cu alte cuvinte, în mod automat calculator, sistemul de operare, va înmâna programul ea însăși o listă cu toate cuvintele că omul tastat la prompt, în cazul în care programator doresc să facă ceva cu aceste informații. Și, în acest caz, singurul cuvânt Am tastat la prompt este ./argv0. 

Și, astfel încât numărul de argumente care este fiind trecut la programul meu este doar unul. Cu alte cuvinte, argumentul conta, altfel cunoscut sub numele de argc aici, ca un întreg, este doar una. Una, desigur, nu egal cu doi. Și, astfel încât aceasta este ceea ce se imprimă, hello world. 

Dar, lasă-mă să iau acest lucru undeva. Permiteți-mi să spun, argv0. Și apoi cum despre Maria? Și apoi apăsați pe Enter. 

Și observați ce se întâmplă în mod magic aici. Acum, în loc de lumi salut, am a schimbat comportamentul acestui program prin luarea de intrare nu de la get șir de caractere sau o altă funcție, dar, de la, aparent, comanda mea în sine, ceea ce am scris inițial în limba. Și eu pot juca acest joc din nou schimbându-l la Stelios, de exemplu. 

Și acum văd un alt nume încă. Si aici, am putea spune Andi. Și, aș putea spune Zamyla. Și noi putem juca acest joc toată ziua, doar conectarea la valori diferite, atât timp cât am oferi exact două cuvinte la prompt, astfel încât argc, conta argumentul meu, este de 2. 

Am vedea că numele conectat printf, pe această condiție aici? Așa că se pare că avem acum capacitatea expresivă de a lua de intrare de la un alt mecanism, din linia de comandă așa-numitele, mai degrabă decât să aștepte până când utilizatorul execută programul, și apoi cere el sau ea folosind ceva de genul șir get. 

Deci, ce e asta? Argc, din nou, este doar un număr întreg, numărul de words-- arguments-- că utilizatorul furnizate la promptă, la fereastra terminalului, inclusiv numele programului. Așa că ./argv0 noastră este, în mod eficient, numele programului, sau cum am rulat programul. 

Care contează ca un cuvânt. Așa că argc ar fi 1. Dar când am scrie Stelios, sau Andi, sau Zamyla, sau Maria, înseamnă că contorul de argumente este de două. Și așa acum există două cuvinte pronunțate în. 

Și observați, putem continua această logică. Dacă aș fi spus de fapt ceva de genul Zamyla Chan, un nume complet, trecând astfel trei argumente în total, acum spune implicit din nou, pentru că, desigur, 3 nu egal cu 2. 

Și, în acest fel, nu am accesul prin argv acest nou argument că am putea punct de vedere tehnic suna orice vrem. Dar, prin convenție, este argv și argc, respectiv. Argv, vector argument, este un fel un sinonim pentru o programare facilitate în C numită o matrice. 

O matrice este o listă de valori similare înapoi, în spate, în spate, în spate. Cu alte cuvinte, în cazul în care unul este chiar aici, în RAM, următoarea este chiar lângă el, și chiar lângă el. Ei nu sunt peste tot. Și aceasta din urmă scenariu, în cazul în care lucrurile sunt peste tot în memorie, poate fi de fapt o caracteristică puternic. Dar vom reveni la faptul că atunci când ne vorbim despre structuri de date columbofil. Pentru moment, o matrice este doar un bucată de memorie contiguă, fiecare dintre ale cărui elemente sunt înapoi, în spate, în spate, în spate, și, în general, de același tip. 

Așa că, dacă te gândești, dintr-un moment în urmă, ceea ce este un șir de caractere? Ei bine, un șir de caractere, cum ar fi Zamyla, Z-A-M-Y-L-A, este, tehnic, doar o matrice. Este o serie de caractere. 

Și astfel, dacă vom trage într-adevăr acest lucru, așa cum am a făcut mai devreme, ca o bucată de memorie, se dovedește că fiecare dintre acestea caractere ocupă un octet. Și apoi există acea specială caracterul santinelă, backslash 0, sau toate cele opt biți 0, că delimitează sfârșitul acelui șir. Deci, un șir de caractere, se transformă out, cita șir unquote, este doar o matrice de chara-- char fiind un tip de date reale. 

Și acum argv, meanwhile-- Să ne întoarcem la program. Argv, chiar dacă vom vedea cuvântul string aici, nu este un șir de caractere în sine. Argv, vector argument, este o matrice de siruri de caractere. 

Așa cum poți avea o serie de de caractere, poti avea nivel mai ridicat, o serie de strings-- astfel încât, de exemplu, când am tastat un moment în urmă ./argv0 argv0, spațiu Z-A-M-Y-L-A, am susținut că argv a avut două șiruri în ./argv0 it--, și Z-A-M-Y-L-A. În Cu alte cuvinte, argc fost 2. De ce este asta? 

Ei bine, în mod eficient, ceea ce se întâmplă on este că fiecare dintre aceste șiruri este, desigur, o serie de caractere ca și mai înainte, fiecare dintre personaje a căror ocupă un octet. Si nu confunda 0 real în numele programului cu 0, ceea ce înseamnă că toți cei 80 de biți. Și Zamyla, între timp, este încă De asemenea, o serie de caractere. 

Astfel, la sfârșitul zilei, într-adevăr arata ca acest lucru sub capota. Dar, argv, prin natura modului principal lucrari, îmi permite să-și încheie toate astea până în, dacă vreți, o matrice mai mare că, dacă vom simplifica puțin peste ce imaginea arata ca si nu destul trage la scară acolo, această matrice este doar de marimea 2, primul element care conține un șir de caractere, al doilea element care conține un șir de caractere. Și, la rândul său, dacă vă un fel de zoom pe fiecare din aceste siruri de caractere, ceea ce vezi sub capota este faptul că fiecare șir de caractere este doar o serie de caractere. 

Acum, la fel ca și cu siruri de caractere, am fost capabili de a obține acces la caracterul i-lea într-un șir de caractere folosind acea notație paranteză pătrată. În mod similar, cu tablouri în general, putem utilizați notația croșetă pentru a obține la orice număr de șiruri într-o matrice? De exemplu, permiteți-mi mergeți mai departe și de a face acest lucru. 

Lasă-mă să merg mai departe și de a crea argv1.c, care este un pic diferit de data asta. În loc de verificare pentru argc2, Am de gând să fac în schimb acest lucru. Pentru int I a lua 0, I este mai puțin decât argc, I, plus, plus, și apoi imprimați în interiorul acestui fapt, procente s, noua linie, apoi argv placuta i. 

Deci, cu alte cuvinte, nu am de-a face cu caractere individuale în acest moment. Argv, dupa cum implica aceste pătrate goale bretele la dreapta numelui argv, înseamnă că argv este o matrice de siruri de caractere. Si argc este doar un int. 

Această linie de aici, 6, este spunând set i egal cu 0. Conta tot drumul până la, dar nu inclusiv, argc. Și apoi pe fiecare iterație, imprima un șir de caractere. Ce șir? 

Șirul de-al i-lea în argv. Așadar, în timp înainte de a mă folosind consola pătrat Notația pentru a ajunge la i-lea caracter într-un șir de caractere, acum Sunt folosind notația paranteză pătrată pentru a ajunge la șirul i-lea într-o matrice. Deci, e un fel de un singur strat de mai sus, conceptual. 

Și ce e îngrijit despre asta program acum, dacă am compila argv1, și apoi face ./argv1, și apoi tastați în ceva de genul foo bar de Baz, care sunt cele trei cuvinte implicit pe care om de știință de calculator ajunge pentru orice moment el sau ea are nevoie de unele cuvinte substituent, și apăsați pe Enter, fiecare dintre aceste cuvinte, inclusiv numele programului, care este în argv la prima locație, sfârșește prin a fi imprimate una câte una, la un moment dat. Și, dacă am schimba acest lucru, și eu spun ceva de genul argv1 Zamyla Chan, vom obține toate cele trei dintre cei cuvinte, care este argv0, argv1, argv2, pentru că în această caz argc, contorul, este 3. 

Dar ceea ce este elegant, este dacă înțelegi că argv este doar o matrice de siruri de caractere, și înțelegeți că un șir de caractere este un șir de caractere, de fapt, putem folosi un fel de acest notație paranteză pătrată de mai multe ori pentru a alege un șir de caractere, și apoi selectați un caracter în șir, scufundări mai adânc, după cum urmează. În acest exemplu, lasă-mă să plec înainte și numesc acest argv2.c. Și, în acest exemplu, lasă-mă să merg mai departe și de a face following-- pentru int I a lua 0, i este mai mică decât argc, i-plus în plus, la fel ca înainte. Așa că în alte words-- și acum acest lucru este obtinerea destul de complicat. Apoi am de gând să spun itera peste siruri de caractere în argv, ca un comentariu pentru mine. Și apoi voi avea un imbricate pentru bucla, tu care, probabil, au făcut, sau luate în considerare a face, în Scratch, în cazul în care Mă duc să spun int-- că sunt nu merge să folosesc din nou, pentru că nu vreau să umbra, sau un fel de suprascrie i existente. 

Voi, în schimb, să zicem j, pentru că asta e du-te la meu variabilă după I, când eu doar încerc să Numar de numere simple. Pentru j devine 0-- și, de asemenea, n, se va obține lungimea pupa a suportului argv i, atâta timp cât j este mai mică m, j plus, plus, efectuați următoarele. Și aici e partea interesantă. 

Tipăriți un caracter și o nouă linie, conectarea placuta argv i, suport j. OK, deci lasă-mă să adaug câteva comentarii aici. Itera de caractere în șir de curent, imprimare j-caracter în șir i-lea. Deci, acum, să ia în considerare ceea ce înseamnă aceste observații. 

Itera siruri de caractere în argv-- cât de multe string-urile sunt în argv, care este o matrice? Argc multe, așa că eu sunt iterarea din i egal cu 0 până la argc. În același timp, cât de multe caractere sunt în șirul i-lea argv? 

Ei bine, pentru a obține acest răspuns, Fac apel doar lungimea șirului de caractere privind îngrijirea curentă șir I despre care este argv placuta i. Si voi pentru a stoca temporar că valoare în n, doar în scopuri de memorare în cache, să-l amintesc pentru eficiență. Și apoi voi inițializa j la 0, să păstreze merge atât timp cât j este mai mică decât n, și la fiecare iterație creștere j. 

Și apoi aici, pe comentariul meu pe linia 12, imprima un caracter, urmată de o nouă linie, Suport specific argv I-mi dă șirul i-lea în argv-- astfel încât primul cuvânt, al doilea cuvânt, al treilea cuvânt, oricare ar fi. Și apoi j scufundările mai adânc, și devine mi caracterul j-a acelui cuvânt. Și așa, în vigoare, puteți trata argv ca un sistem multi-dimensional, ca un bi-dimensional, matrice, prin care fiecare cuvânt un fel de arata ca asta în mintea ta ochi, și fiecare caracter este un fel de compus din o coloană, în cazul în care vă ajută. 

In realitate, atunci când ne șicana acest lucru în afară, în săptămânile următoare, acesta va fi un pic mai sofisticate decât atât. Dar tu poți cu adevărat gândesc că, deocamdată, ca doar acest bi-dimensional matrice, prin care un nivel de ea este toate siruri de caractere. Și apoi, dacă te arunca cu capul mai adânc, ai se pot obține de la caracterele individuale prin utilizarea acestei in ele notatie aici. 

Deci, ce este efectul net? Lasă-mă să merg mai departe și face darn argv2---l. Am făcut o greșeală aici. Implicit declararea Funcția de bibliotecă Stirling. Așa că în tot acest timp, este poate este cazul că suntem un fel de finisare exact unde am început. 

Am greșit, implicit, declarând Funcția de bibliotecă Stirling. OK, așteptați un minut. Îmi amintesc că, mai ales din moment ce e chiar aici. Trebuie să includă string.h în această versiune a programului. 

Lasă-mă să merg mai departe și să includă string.h, cu excepția că, mergeți mai departe și recompilați argv2. Și acum, aici vom merge, face argv2, Enter. Și, deși este un pic criptică la prima vedere, observă că, într-adevăr, ce este imprimată este argv2 punct. 

Dar, dacă tastați câteva cuvinte după ce prompte, cum ar fi argv2 Zamyla Chan, Intra, de asemenea, un pic criptică la prima vedere. Dar, dacă ne defila înapoi în sus, ./argv2 Z-A-M-Y-L-A C-H-A-N. Așa că ne-am reiterată peste fiecare cuvânt. Și, la rândul său, ne-am iterat peste fiecare caracter dintr-un cuvânt. 

Acum, după toate acestea, dau seama că există un alt detaliu am fost un fel de a ignora tot acest timp. Tocmai ne-am desfăcuți ce intrările principale pot fi? Cum rămâne cu ieșire principală a lui? 

Tot acest timp, am fost doar copierea și lipirea int cuvântul în fața principală, deși s-ar putea vedea on-line, uneori incorect în versiuni mai vechi C și compilatoare, că spun ei nule, sau nimic. Dar, într-adevăr, pentru versiunea C pe care îl utilizăm, C 11, sau 2011, își dau seama că ar trebui să fie int. Și ar trebui să fie nule sau argc și argv aici. 

Dar, de ce int main? Ce este de fapt se întoarce? Ei bine, se pare că tot acest timp, orice moment ai scris un program de principal este întotdeauna se întoarce ceva. Dar a făcut acest lucru în secret. 

Acel ceva este un int, după cum sugerează linia 5. Dar ce int? Ei bine, există această convenție în programare, prin care, dacă nimic nu are mers prost și totul este bine, programe și funcții în general return-- oarecum counterintuitively-- 0. 0 semnifică, în general, totul este bine. Deci, chiar dacă te gândești la ea ca fiind false în mai multe contexte, aceasta înseamnă, de fapt, în general, un lucru bun 

Între timp, în cazul în care un program returnează 1, sau negativă 1 sau 5, sau negativă 42, sau orice-0 non valoare, care semnifică, în general, că ceva a mers prost. De fapt, pe propriul dvs. Mac sau PC, s-ar putea fi văzut de fapt, un mesaj de eroare, acesta prin spune ceva sau altul, eroare cod negativ 42, sau codul de eroare 23, sau ceva de genul asta. Acel număr este, în general, doar un indiciu la programator, sau compania care a făcut software-ul, ce a mers bine și de ce, astfel încât acestea să poată privi prin documentație sau codul lor, și dau seama ce eroare înseamnă de fapt. Nu e în general util pentru a ne utilizatorii finali. 

Dar, când principalele întoarce 0, totul este bine. Și, dacă nu specificați ce principal ar trebui să se întoarcă, acesta va doar automat return 0 pentru tine. Dar, revenind ceva altfel este de fapt util. 

În cadrul acestui program final să-mi mergeți mai departe și numesc acest exit.c, și să introducă ultima astăzi subiecte, cunoscut sub numele de un cod de eroare. Lasă-mă să merg mai departe și includ nostru fișiere familiare până sus, fac int main. Și de data asta, să facem int argc, argv șir, și cu paranteze mele pentru a sugera că este în matrice. Și apoi permiteți-mi să fac o verificare bun-simț. De data aceasta, în cazul în care nu argc egal cu 2, atunci știi ce? Uita. Am de gând să spun că, hei, utilizator, vă lipsește în linie de comandă argument n backslash. 

Și apoi asta e. Vreau să ieșiți. Mă duc la preemptively, și într-adevăr prematur, întoarcere altceva decât numărul 1. Du-te la valoarea primei eroare care se poate întâmpla este 1. Dacă aveți alte eronate situație care ar putea apărea, s-ar putea spune retur 2 sau retur 3, sau poate chiar negativă 1 sau 2 negativ. 

Acestea sunt doar coduri de ieșire care sunt, în general, util numai pentru programator, sau companie care este de transport maritim software-ul. Dar, faptul că este nu 0 este ceea ce este important. Așa că, dacă în acest program, vreau să garanta că acest program numai funcționează în cazul în care utilizatorul îmi oferă cu un număr de două argumente, numele programului, și alte cuvânt, eu pot pune în aplicare la fel de mult, după cum urmează, tipa la utilizatorul cu printf spune, lipsă linie de comandă argument, retur 1. Care va pur și simplu imediat a iesi din program. 

Numai în cazul în care argc este egal cu 2 vom ajunge în jos aici, moment în care am de gând să spun, Buna ziua la suta s, backslash n, argv1. Cu alte cuvinte, eu sunt nu merge după argv 0, care este doar numele programului. Vreau să imprime salut, virgulă, al doilea cuvânt care tastat uman. Și, în acest caz linia 13, totul este bine. 

Știu că argc este 2 în mod logic din acest program. Mă duc să merg mai departe și să se întoarcă 0. Ca o parte, ține cont de faptul că acest lucru este valabil și în zero, de asemenea. 

În mod logic, am putut face acest lucru și încapsula aceste linii de cod în această clauză altcineva aici. Dar asta e un fel de crestarea inutil codul meu. Și vreau să fac super- clar că, indiferent de ce, în mod implicit, salut ceva se va obține imprimate, atât timp cât utilizatorul cooperează. 

Deci, este foarte obișnuit să folosească o condiție, doar o dacă, pentru a prinde unele eronate situație, și apoi de ieșire. Și apoi, atât de mult timp totul este bine, nu au o alta, dar au doar codul în afara că, dacă, pentru că este echivalent în această caz particular, în mod logic. Așa că mă întorc la 0, doar pentru a semnifică în mod explicit totul este bine. 

În cazul în care am omis returnarea 0, aceasta ar se presupune în mod automat pentru mine. Dar acum că mă întorc unul din cel puțin acest caz, Mă duc să, pentru o bună măsură și claritate, randamentul 0 în acest caz. Deci, acum lasă-mă să merg mai departe și să ieși, care este un segue perfect pentru a părăsi pur și simplu. 

Dar, să ieși, și lasă-mă să plec înainte și de a face ./exit, Enter. Și programul țipat la mine, Lipsește un argument în linia de comandă. Bine, lasă-mă să coopereze. 

Lasă-mă să fac în schimb ./exit, David, Enter. Și acum se spune, salut David. Și n-ar vedea în mod normal, acest lucru. 

Dar, se pare că există o mod special în Linux pentru a vedea de fapt cu ce ieșire cod de un program ieșit. Uneori, într-un grafic lume ca Mac OS sau Windows, vedeți numai aceste numere atunci când un Mesajul de eroare apare pe ecran și programator vă arată că numărul de. Dar dacă vrem să vedem ce eroarea Mesajul este, putem face aici-- astfel încât ./exit, Enter, print Lipsește un argument în linia de comandă. 

Dacă o fac acum $ echo ?, care este ridicol de criptic cautati. Dar, $? este incantația magică care spune, hei, calculator, spune-mi ce anterior Codul de ieșire al programului a fost. Si am lovit Enter. Eu văd 1, pentru că asta e ceea ce am a declarat funcția mea principală să se întoarcă. 

Între timp, dacă eu fac ./exit David, și apăsați pe Enter, eu văd, salut pe David. Și, dacă eu fac acum $ echo ?, eu văd salut 0. Și, astfel încât aceasta va de fapt fie informații valoroase în contextul debugger, nu asa de mult că tu, omul, ar pasa. Dar debugger și alte programe vom folosi acest semestru se va uita de multe ori la acel număr, chiar dacă este un fel de ascuns cu excepția cazului când îl căutați, să a determina dacă un program sau nu execuție a fost corectă sau incorectă. 

Și astfel, încât ne aduce la aceasta, la sfârșitul zilei. Am început astăzi de privirea de la depanare, și, la rândul său, la cursul în sine, și apoi mai interesant, punct de vedere tehnic sub capota la ce string-urile sunt, care ultimul Săptămâna tocmai ne-am luat de la sine, și cu siguranță le-a luat pentru a acordat în Scratch. 

Apoi ne-am uitat la modul în care putem accesa caractere individuale într-un șir de caractere, și apoi din nou, a avut un nivel mai ridicat uita-te la lucruri, uita la modul în care well-- dacă vrem să ajungem la individ elemente într-o listă ca structură, nu putem face asta cu mai multe siruri de caractere? Și noi putem cu argumente în linia de comandă. Dar această imagine aici doar de cutii este demonstrativ al acestei idei generale a unei matrice, sau o listă, sau un vector. Și în funcție de context, toate aceste cuvinte înseamnă lucruri ușor diferite. Deci, în C, vom merge doar pentru a vorbi despre o matrice. Și o matrice este o bucată de memorie, fiecare dintre ei este elemente sunt adiacente, spate, în spate, în spate, în spate. 

Iar aceste elemente sunt, în general, de același tip de date, caracter, caracter, caracter, caracter, sau string, string, string, string, sau int int, oricare ar fi ea încercăm să magazin. Dar, la sfârșitul zilei, aceasta este cum arată conceptual. Iei ta memorie sau RAM calculator. Si tu te-l în sculptură cutii identice dimensiuni, toate acestea sunt înapoi, în spate, la înapoi, în spate, în acest fel. 

Și ce e frumos despre această idee, și faptul pe care o putem exprima valori în acest fel cu prima dintre structurile noastre de date în clasă, înseamnă că putem începe să pentru a rezolva problemele cu cod care a venit atât de intuitiv în săptămâna 0. Vă amintiți telefonul exemplu de carte, în cazul în care am folosit o divide și cuceri, sau un algoritm de căutare binară, pentru a trece printr-un întreg grămadă de nume și numere. Dar am presupus, amintesc, că carte de telefon a fost deja sortate, că altcineva a avut deja dat o out-- figure listă de nume și cum să le Numere în ordine alfabetică. Și acum, că, în C, noi, de asemenea, au capacitatea pentru a pune lucrurile, nu fizic într-o carte de telefon dar, practic, într-un computer memorie, va vom fi în măsură săptămâna viitoare să introducă din nou astea-- primul a structurilor noastre de date într-un array-- dar, mai important, calculator real algoritmi de știință puse în aplicare în cod, cu care putem stoca date în structuri de acest gen, și apoi începe să-l manipuleze, și pentru a rezolva de fapt probleme cu ea, și să se bazeze pe deasupra, în cele din urmă, programe în C, în Python, în JavaScript, interoghează baze de date cu SQL? 

Și vom vedea că toate acestea idei diferite de blocare. Dar, pentru moment, reamintească faptul că domeniu pe care am introdus astăzi a fost acest lucru aici, și lumea criptografiei. Și printre următoarele probleme pe care le voi va rezolva este arta criptografiei, de codare și de-codare informații și cifrarea și descifrarea textului, și presupunând că în cele din urmă că acum știi ce este sub capota astfel încât atunci când vedeți sau să primiți un mesaj de genul asta, le poate descifra. Toate acestea, și mai mult data viitoare. 

[REDARE VIDEO] 

-Mover Tocmai a sosit. Mă duc să merg vizita profesor de colegiu. Da. Bună. Esti tu. Aștepta! David. Eu doar încerc să dau ce sa întâmplat cu tine. Te rog, orice ar putea ajuta. Tu ai fost colegiu lui colega de camera, nu-i așa? Ai fost acolo cu el când el a terminat proiectul CS50? 

[MUZICĂ] 

Asta a fost CS50. 

Iubesc locul acesta. 

-Mânca în întregime. Vom ieși din afaceri. 

[END REDARE] 