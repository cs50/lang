1
00:00:00,000 --> 00:00:02,970
>> [ΜΟΥΣΙΚΗ Playing]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Malan: Εντάξει.

4
00:00:15,700 --> 00:00:18,832
Αυτό είναι CS50 και αυτό
είναι η αρχή της Εβδομάδας 2.

5
00:00:18,832 --> 00:00:21,040
Και θα θυμάστε ότι πάνω από
τις τελευταίες δύο εβδομάδες,

6
00:00:21,040 --> 00:00:24,490
έχουμε την εισαγωγή του υπολογιστή
επιστήμη και, με τη σειρά του, τον προγραμματισμό.

7
00:00:24,490 --> 00:00:27,640
>> Και αρχίσαμε την ιστορία μέσω της
Το μηδέν, ώστε γραφική γλώσσα

8
00:00:27,640 --> 00:00:28,990
από το Media Lab του MIT.

9
00:00:28,990 --> 00:00:30,780
Και στη συνέχεια πιο πρόσφατα,
την περασμένη εβδομάδα, κάναμε

10
00:00:30,780 --> 00:00:34,450
εισαγάγει ένα higher-- ένα
γλώσσα χαμηλότερου επιπέδου γνωστή

11
00:00:34,450 --> 00:00:36,770
όπως C, κάτι που είναι καθαρά κειμένου.

12
00:00:36,770 --> 00:00:39,440
Και, πράγματι, την τελευταία φορά που
διερευνηθεί σε αυτό το πλαίσιο

13
00:00:39,440 --> 00:00:40,450
διάφορες έννοιες.

14
00:00:40,450 --> 00:00:43,010
>> Αυτό, ανάκληση, ήταν το πολύ
πρώτο πρόγραμμα κοιτάξαμε.

15
00:00:43,010 --> 00:00:45,710
Και το πρόγραμμα αυτό, πολύ απλά,
εκτυπώνει, "γειά σου, τον κόσμο."

16
00:00:45,710 --> 00:00:47,730
Αλλά υπάρχει τόσο πολύ
φαινομενική μαγεία συμβαίνει.

17
00:00:47,730 --> 00:00:51,460
Υπάρχει αυτό το #include
με αυτές τις γωνιακές αγκύλες.

18
00:00:51,460 --> 00:00:52,170
Υπάρχει int.

19
00:00:52,170 --> 00:00:53,020
Υπάρχει (άκυρο).

20
00:00:53,020 --> 00:00:56,330
Υπάρχει παρενθέσεις, αγκύλες,
ημι-παχύ έντερο, και πολύ περισσότερα.

21
00:00:56,330 --> 00:00:58,480
>> Και έτσι, υπενθυμίζουν ότι
εισαγάγαμε Scratch

22
00:00:58,480 --> 00:01:02,110
έτσι ώστε να μπορούμε, στην ιδανική περίπτωση, δείτε το παρελθόν
ότι η σύνταξη, η ουσία που δεν είναι πραγματικά

23
00:01:02,110 --> 00:01:04,590
όλα αυτά πνευματικά
ενδιαφέρουσα, αλλά νωρίς

24
00:01:04,590 --> 00:01:07,700
είναι, απολύτως, είναι λίγο δύσκολο
να τυλίξουν το μυαλό σας γύρω.

25
00:01:07,700 --> 00:01:10,860
Και, πράγματι, ένα από τα πιο κοινά
τα πράγματα από νωρίς σε μια κατηγορία προγραμματισμού,

26
00:01:10,860 --> 00:01:13,443
Ειδικά για εκείνους λιγότερο
άνετα, είναι να πάρει απογοητευμένοι από

27
00:01:13,443 --> 00:01:17,460
και σκόνταψε πάνω από ορισμένες συντακτικές
σφάλματα, για να μην αναφέρουμε λογικά σφάλματα.

28
00:01:17,460 --> 00:01:19,800
Και έτσι στους στόχους μας
Σήμερα, στην πραγματικότητα, θα

29
00:01:19,800 --> 00:01:23,280
είναι να σας εξοπλίσει με μερικές
τεχνικές επίλυσης προβλημάτων για το πώς

30
00:01:23,280 --> 00:01:26,705
να λύσει καλύτερα τον εαυτό τους προβλήματα
με τη μορφή εντοπισμού σφαλμάτων.

31
00:01:26,705 --> 00:01:29,330
Και θα θυμάστε, επίσης, ότι η
περιβάλλον που εισαγάγαμε

32
00:01:29,330 --> 00:01:31,780
τελευταία φορά που κλήθηκε CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Αυτό είναι web-based λογισμικό που
Σας επιτρέπει να προγραμματίσετε στο σύννεφο,

34
00:01:34,850 --> 00:01:38,450
να το πω έτσι, διατηρώντας παράλληλα όλες σας
αρχεία μαζί, όπως θα είναι και πάλι σήμερα.

35
00:01:38,450 --> 00:01:41,480
Και υπενθυμίζουν ότι εμείς
επανεξεταστούν αυτά τα θέματα εδώ,

36
00:01:41,480 --> 00:01:44,480
μεταξύ τους λειτουργίες, και βρόχους, και
μεταβλητές, και Boolean εκφράσεις,

37
00:01:44,480 --> 00:01:45,110
και προϋποθέσεις.

38
00:01:45,110 --> 00:01:49,190
Και στην πραγματικότητα μερικές ακόμα ότι εμείς
μεταφράστηκε από τον κόσμο του Scratch

39
00:01:49,190 --> 00:01:50,800
στον κόσμο του C.

40
00:01:50,800 --> 00:01:53,220
>> Αλλά το βασικό κτίριο
μπλοκ, να το πω έτσι,

41
00:01:53,220 --> 00:01:55,150
ήταν πραγματικά ακόμα το ίδιο την περασμένη εβδομάδα.

42
00:01:55,150 --> 00:01:57,900
Στην πραγματικότητα, έχουμε πραγματικά ακριβώς είχε
διαφορετικό κομμάτι του παζλ, αν θέλετε.

43
00:01:57,900 --> 00:02:00,300
Αντί αυτού του μοβ
αποθηκεύσετε μπλοκ, εμείς αντί

44
00:02:00,300 --> 00:02:02,940
είχε printf, η οποία είναι
αυτή η λειτουργία σε c που

45
00:02:02,940 --> 00:02:05,890
Σας επιτρέπει να εκτυπώσετε κάτι
και διαμορφώστε στην οθόνη.

46
00:02:05,890 --> 00:02:07,950
Εισαγάγαμε το CS50
Βιβλιοθήκη, σας όπου

47
00:02:07,950 --> 00:02:11,420
έχουν τώρα στη διάθεσή σας get_char,
και get_int, και get_string,

48
00:02:11,420 --> 00:02:14,610
και μερικές άλλες λειτουργίες, όπως
επίσης, μέσω του οποίου μπορείτε να πάρετε είσοδο

49
00:02:14,610 --> 00:02:16,260
από τη δική πληκτρολόγιο του χρήστη.

50
00:02:16,260 --> 00:02:20,640
Και πήραμε επίσης μια ματιά στα πράγματα
όπως αυτά-bool και char,

51
00:02:20,640 --> 00:02:22,490
και δίκλινα, float,
int, long_long εγχόρδων.

52
00:02:22,490 --> 00:02:25,170
Και υπάρχει ακόμη και άλλους τύπους δεδομένων στη C.

53
00:02:25,170 --> 00:02:28,560
>> Με άλλα λόγια, όταν δηλώνετε
μια μεταβλητή για να αποθηκεύσετε κάποια αξία,

54
00:02:28,560 --> 00:02:32,600
ή όταν εφαρμόζετε μια λειτουργία
ότι επιστρέφει κάποια τιμή,

55
00:02:32,600 --> 00:02:35,290
μπορείτε να καθορίσετε τι
είδος της τιμής που είναι.

56
00:02:35,290 --> 00:02:37,310
Είναι ένα string, όπως ένα
ακολουθία χαρακτήρων;

57
00:02:37,310 --> 00:02:39,490
Είναι ένας αριθμός, σαν ένα ακέραιο;

58
00:02:39,490 --> 00:02:41,390
Είναι ένα πλωτό σημείο
αξία, ή κάτι παρόμοιο;

59
00:02:41,390 --> 00:02:46,180
Έτσι σε C, σε αντίθεση με το μηδέν, στην πραγματικότητα
άρχισε να καθορίσετε τι είδους δεδομένα

60
00:02:46,180 --> 00:02:48,330
είχαμε την επιστροφή ή τη χρήση.

61
00:02:48,330 --> 00:02:51,910
>> Αλλά, φυσικά, τρέξαμε επίσης υπόψη
ορισμένες θεμελιώδεις όρια των υπολογιστών.

62
00:02:51,910 --> 00:02:54,100
Και ειδικότερα,
Αυτή η γλώσσα C, ανάκληση

63
00:02:54,100 --> 00:02:57,070
ότι πήραμε μια ματιά
υπερχείλιση ακεραίου, η πραγματικότητα

64
00:02:57,070 --> 00:03:00,460
ότι αν έχετε μόνο ένα
πεπερασμένη ποσότητα μνήμης

65
00:03:00,460 --> 00:03:04,600
ή, ειδικότερα, ένας πεπερασμένος αριθμός
των bits, το μόνο που μπορεί να μετρήσει τόσο υψηλή.

66
00:03:04,600 --> 00:03:08,460
Και έτσι κοιτάξαμε αυτό το παράδειγμα εδώ
σύμφωνα με την οποία ένας μετρητής σε ένα αεροπλάνο,,

67
00:03:08,460 --> 00:03:13,510
στην πραγματικότητα, εάν τρέχει αρκετά μεγάλο χρονικό διάστημα θα
ξεχειλίσει και να οδηγήσει σε ένα λογισμικό

68
00:03:13,510 --> 00:03:15,560
μια πραγματική φυσική δυνητικό σφάλμα.

69
00:03:15,560 --> 00:03:18,600
>> Εξετάσαμε επίσης επιπλέει
σημείο ανακρίβεια, η πραγματικότητα

70
00:03:18,600 --> 00:03:22,280
ότι με μόνο έναν πεπερασμένο αριθμό
των bits, είτε πρόκειται για 32 ή 64,

71
00:03:22,280 --> 00:03:27,330
μπορείτε να καθορίσετε μόνο τόσο πολλούς αριθμούς
μετά την υποδιαστολή, μετά την οποία θα

72
00:03:27,330 --> 00:03:29,110
αρχίζουν να πάρει ανακριβή.

73
00:03:29,110 --> 00:03:32,360
Έτσι, για παράδειγμα, το ένα τρίτο στο
κόσμο εδώ, στον ανθρώπινο κόσμο μας,

74
00:03:32,360 --> 00:03:35,360
Γνωρίζουμε ότι μόνο ένας άπειρος αριθμός
της 3s μετά την υποδιαστολή.

75
00:03:35,360 --> 00:03:38,820
Αλλά ένας υπολογιστής δεν μπορεί κατ 'ανάγκη
αντιπροσωπεύουν έναν άπειρο αριθμό των αριθμών

76
00:03:38,820 --> 00:03:42,590
αν επιτρέψετε μόνο ότι κάποιοι
πεπερασμένη ποσότητα των πληροφοριών.

77
00:03:42,590 --> 00:03:45,900
>> Έτσι, όχι μόνο δεν θα σας εξοπλίσει
με μεγαλύτερη δύναμη από την άποψη

78
00:03:45,900 --> 00:03:49,280
για το πώς μπορείτε να εκφραστείτε σε
ένα πληκτρολόγιο όσον αφορά τον προγραμματισμό,

79
00:03:49,280 --> 00:03:51,430
θα περιορίζονται επίσης τι
μπορείτε πραγματικά να κάνετε.

80
00:03:51,430 --> 00:03:55,790
Και πράγματι, τα σφάλματα και τα λάθη μπορούν να
προκύπτουν από τέτοιου είδους θέματα.

81
00:03:55,790 --> 00:03:59,900
Και πράγματι, μεταξύ των θεμάτων που σήμερα
πρόκειται να είναι θέματα όπως εντοπισμός σφαλμάτων

82
00:03:59,900 --> 00:04:03,699
και πραγματικά ψάχνει κάτω από την κουκούλα
πώς εισήχθησαν τα πράγματα την περασμένη εβδομάδα

83
00:04:03,699 --> 00:04:05,490
εφαρμόζονται πραγματικά
έτσι ώστε να μπορείτε καλύτερα

84
00:04:05,490 --> 00:04:10,530
κατανοήσουν τόσο οι δυνατότητες και
οι περιορισμοί μιας γλώσσας όπως η C.

85
00:04:10,530 --> 00:04:14,770
>> Και στην πραγματικότητα, θα ξεφλουδίσετε πίσω τα στρώματα
της απλούστερης δομής δεδομένων,

86
00:04:14,770 --> 00:04:17,756
κάτι που ονομάζεται μια σειρά, η οποία
Scratch συμβαίνει να καλέσετε μια "λίστα".

87
00:04:17,756 --> 00:04:19,589
Είναι ένα μικρό κομμάτι
διαφορετικά σε αυτό το πλαίσιο.

88
00:04:19,589 --> 00:04:23,340
Και τότε θα εισάγουν επίσης ένα από τα
πρώτα προβλήματα σε συγκεκριμένους τομείς μας

89
00:04:23,340 --> 00:04:26,790
σε CS50, ο κόσμος του
κρυπτογραφία, η τέχνη της κρυπτογράφησης

90
00:04:26,790 --> 00:04:29,650
ή σε κρυπτογραφήσεως πληροφορίες τόσο
ότι μπορείτε να στείλετε μυστικά μηνύματα

91
00:04:29,650 --> 00:04:34,520
και να αποκωδικοποιήσει μυστικά μηνύματα
μεταξύ δύο ατόμων, Α και Β

92
00:04:34,520 --> 00:04:37,490
>> Έτσι, πριν από τη μετάβαση μας
σε αυτό το νέο κόσμο,

93
00:04:37,490 --> 00:04:42,059
ας προσπαθήσουμε να σας εξοπλίσει με μερικές
τεχνικές με τις οποίες μπορείτε να εξαλείψει

94
00:04:42,059 --> 00:04:43,850
ή να μειώσει τουλάχιστον κάποια
των απογοητεύσεις

95
00:04:43,850 --> 00:04:46,630
ότι έχετε αντιμετωπίσει κατά πάσα πιθανότητα
πάνω από μόνα τους την περασμένη εβδομάδα.

96
00:04:46,630 --> 00:04:50,830
Στην πραγματικότητα, μπροστά από εσάς such-- μερικά από
την πρώτη σας προβλήματα στην C. Και οι πιθανότητες είναι,

97
00:04:50,830 --> 00:04:54,010
αν είστε σαν εμένα, είναι η πρώτη φορά
μπορείτε να δοκιμάσετε να πληκτρολογήσετε ένα πρόγραμμα,

98
00:04:54,010 --> 00:04:57,330
ακόμη και αν νομίζετε ότι λογικά
το πρόγραμμα είναι αρκετά απλή,

99
00:04:57,330 --> 00:05:01,200
θα μπορούσε κάλλιστα να χτυπήσει έναν τοίχο, και
ο compiler δεν πρόκειται να συνεργαστεί.

100
00:05:01,200 --> 00:05:03,940
Κάνει ή Clang δεν πρόκειται
να κάνει πραγματικά την προσφορά σας.

101
00:05:03,940 --> 00:05:05,450
>> Και γιατί θα μπορούσε αυτό να είναι;

102
00:05:05,450 --> 00:05:07,950
Λοιπόν, ας ρίξουμε μια ματιά στο,
ίσως, ένα απλό πρόγραμμα.

103
00:05:07,950 --> 00:05:11,190
Πάω να πάει μπροστά και να σώσει αυτό το
ένα αρχείο σκόπιμα ονομάζεται buggy0.c,

104
00:05:11,190 --> 00:05:13,590
γιατί ξέρω να
να λανθασμένη εκ των προτέρων.

105
00:05:13,590 --> 00:05:17,400
Αλλά εγώ μπορεί να μην συνειδητοποιούν ότι αν αυτό
είναι το πρώτο ή το δεύτερο ή τρίτο πρόγραμμα

106
00:05:17,400 --> 00:05:18,830
ότι είμαι πραγματικά κάνει τον εαυτό μου.

107
00:05:18,830 --> 00:05:23,820
Έτσι, Πάω να πάει μπροστά και να
πληκτρολογήσετε, int main (void).

108
00:05:23,820 --> 00:05:28,130
Και τότε μέσα από άγκιστρα μου,
ένα πολύ γνωστό ( «γειά σου, world--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - και μια άνω τελεία.

110
00:05:30,980 --> 00:05:32,360
>> Έχω αποθηκεύσει το αρχείο.

111
00:05:32,360 --> 00:05:34,850
Τώρα είμαι πρόκειται να πάει προς τα κάτω
στο παράθυρό μου τερματικού

112
00:05:34,850 --> 00:05:40,340
και τον τύπο make buggy0, επειδή, και πάλι,
το όνομα του αρχείου είναι σήμερα buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Γι 'αυτό και πληκτρολογήστε κάνει buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Και, ω, Θεέ, ανάκληση από την τελευταία φορά
ότι δεν υπάρχουν μηνύματα λάθους είναι ένα καλό πράγμα.

115
00:05:48,200 --> 00:05:49,740
Έτσι, καμία έξοδος είναι ένα καλό πράγμα.

116
00:05:49,740 --> 00:05:52,920
Αλλά εδώ έχω σαφώς
κάποιος αριθμός των λαθών.

117
00:05:52,920 --> 00:05:56,470
>> Έτσι, στην πρώτη γραμμή της εξόδου
μετά την πληκτρολόγηση κάνει buggy0, ανάκληση,

118
00:05:56,470 --> 00:05:59,540
είναι αρκετά φλύαρη έξοδος Clang του.

119
00:05:59,540 --> 00:06:02,067
Κάτω από το καπό,
CS50 IDE έχει ρυθμιστεί

120
00:06:02,067 --> 00:06:04,150
να χρησιμοποιήσει ένα σωρό
επιλογές με αυτό το μεταγλωττιστή

121
00:06:04,150 --> 00:06:05,941
έτσι ώστε να μην έχουν
να σκεφτούμε γι 'αυτούς.

122
00:06:05,941 --> 00:06:08,840
Και αυτό είναι όλο ότι η πρώτη γραμμή
μέσα που ξεκινά με Clang.

123
00:06:08,840 --> 00:06:11,720
>> Αλλά μετά από αυτό, τα προβλήματα
αρχίζουν να κάνουν την εμφάνισή τους.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c στη γραμμή 3, χαρακτήρα
5, υπάρχει ένα μεγάλο, κόκκινο σφάλμα.

125
00:06:17,390 --> 00:06:18,380
Τι είναι αυτό?

126
00:06:18,380 --> 00:06:23,562
Σιωπηρά δηλώνοντας τη λειτουργία της βιβλιοθήκης
printf με τον τύπο int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Θέλω να πω, πολύ γρήγορα
παίρνει πολύ απόκρυφες.

129
00:06:28,379 --> 00:06:30,170
Και βεβαίως, σε πρώτη
ματιά, δεν θα

130
00:06:30,170 --> 00:06:32,380
αναμένουμε από εσάς να καταλάβετε το
σύνολό του μηνύματος.

131
00:06:32,380 --> 00:06:34,213
Και έτσι ένα από τα μαθήματα
για σήμερα πρόκειται

132
00:06:34,213 --> 00:06:36,919
να είναι να προσπαθήσουμε να παρατηρήσετε
πρότυπα, ή παρόμοια πράγματα,

133
00:06:36,919 --> 00:06:38,960
σε σφάλματα που μπορεί να έχετε
αντιμετώπισε στο παρελθόν.

134
00:06:38,960 --> 00:06:41,335
Ας δώσουμε έμφαση, εκτός μόνο
αυτά τα λόγια που φαίνονται εξοικειωμένοι.

135
00:06:41,335 --> 00:06:44,290
Το μεγάλο, κόκκινο σφάλμα είναι σαφώς
συμβολική του κάτι που είναι λάθος.

136
00:06:44,290 --> 00:06:47,940
>> σιωπηρά δηλώνοντας
βιβλιοθήκη printf λειτουργία.

137
00:06:47,940 --> 00:06:51,680
Έτσι, ακόμη και αν δεν καταλαβαίνω τι
δηλώνοντας εμμέσως λειτουργία της βιβλιοθήκης

138
00:06:51,680 --> 00:06:54,900
μέσα, το πρόβλημα σίγουρα
σχετίζεται με printf με κάποιο τρόπο.

139
00:06:54,900 --> 00:06:59,130
Και η πηγή του ζητήματος
έχει να κάνει με την κήρυξή της.

140
00:06:59,130 --> 00:07:02,440
>> Δηλώνοντας μια λειτουργία είναι
να σημειωθεί ότι για πρώτη φορά.

141
00:07:02,440 --> 00:07:06,210
Και χρησιμοποιήσαμε την ορολογία την περασμένη εβδομάδα
δήλωσης πρωτότυπο μιας συνάρτησης,

142
00:07:06,210 --> 00:07:11,860
είτε με μία γραμμή στο πάνω μέρος της σας
το δικό της αρχείο ή σε ένα λεγόμενο αρχείο κεφαλίδας.

143
00:07:11,860 --> 00:07:15,300
Και σε ποια αρχείο έκαναν λέμε
την περασμένη εβδομάδα ότι η printf είναι απόσπασμα,

144
00:07:15,300 --> 00:07:17,080
εισαγωγικά, δήλωσε;

145
00:07:17,080 --> 00:07:20,950
Σε ποιο αρχείο είναι το πρωτότυπο της;

146
00:07:20,950 --> 00:07:24,640
>> Έτσι, αν θυμάστε, το πρώτο πράγμα που
δακτυλογραφημένα, σχεδόν κάθε πρόγραμμα τελευταίο time--

147
00:07:24,640 --> 00:07:30,790
και κατά λάθος μια στιγμή πριν αρχίσει
πληκτρολογώντας myself-- ήταν αυτό here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- για
εισόδου / output-- dot h Και πράγματι,

149
00:07:38,630 --> 00:07:41,860
αν μπορώ τώρα να αποθηκεύσετε αυτό το αρχείο, θα πάω
να προχωρήσει και να καθαρίσετε την οθόνη μου,

150
00:07:41,860 --> 00:07:44,740
το οποίο μπορείτε να κάνετε με την πληκτρολόγηση
Σαφείς, ή μπορείτε να κρατήσετε Ελέγχου L,

151
00:07:44,740 --> 00:07:47,680
απλά για να καθαρίσετε το παράθυρό σας τερματικού
απλά για να εξαλειφθούν κάποια ακαταστασία.

152
00:07:47,680 --> 00:07:51,370
>> Πάω να πάει μπροστά και να
νέου τύπου make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Και ιδού, εγώ εξακολουθώ να βλέπω ότι
μακρά εντολή από Clang,

154
00:07:53,790 --> 00:07:55,470
αλλά δεν υπάρχει μήνυμα λάθους αυτή τη φορά.

155
00:07:55,470 --> 00:07:58,800
Και πράγματι, αν το κάνω ./buggy0,
ακριβώς όπως την τελευταία φορά,

156
00:07:58,800 --> 00:08:01,860
όπου τελεία σημαίνει αυτό
κατάλογο, Slash σημαίνει απλώς,

157
00:08:01,860 --> 00:08:05,040
εδώ έρχεται το όνομα του προγράμματος και
ότι το όνομα του προγράμματος είναι buggy0,

158
00:08:05,040 --> 00:08:07,340
Εισάγετε, "γειά σου, τον κόσμο."

159
00:08:07,340 --> 00:08:09,440
>> Τώρα, πώς μπορεί να έχετε
σταχυολογούνται αυτή τη λύση

160
00:08:09,440 --> 00:08:12,017
χωρίς κατ 'ανάγκη
αναγνωρίζοντας όσες λέξεις

161
00:08:12,017 --> 00:08:14,350
όπως έκανα, βέβαια, έχει
κάνει αυτό για τόσα πολλά χρόνια;

162
00:08:14,350 --> 00:08:18,720
Λοιπόν, συνειδητοποιούν ανά το πρώτο πρόβλημα
σύνολο, θα σας παρουσιάσουμε σε μια εντολή

163
00:08:18,720 --> 00:08:21,175
ότι το προσωπικό CS50 του
έγραψε ονομάζεται help50.

164
00:08:21,175 --> 00:08:24,300
Και πράγματι, C κάνει προδιαγραφές
το πρόβλημα που ως προς το πώς να χρησιμοποιήσετε αυτό.

165
00:08:24,300 --> 00:08:27,210
>> Αλλά είναι help50 ουσιαστικά
ένα πρόγραμμα που το προσωπικό CS50 του

166
00:08:27,210 --> 00:08:30,850
που έγραψε ότι επιτρέπει να εκτελέσετε
μια εντολή ή να εκτελέσετε ένα πρόγραμμα,

167
00:08:30,850 --> 00:08:36,169
και αν δεν μπορείτε να καταλάβετε τους
εξόδου, για να περάσει η παραγωγή της σε help50,

168
00:08:36,169 --> 00:08:38,890
στο οποίο σημείο το λογισμικό
ότι το προσωπικό του μαθήματος έγραψε

169
00:08:38,890 --> 00:08:42,429
θα δούμε στην έξοδο του προγράμματός σας
γραμμή προς γραμμή, χαρακτήρα προς χαρακτήρα.

170
00:08:42,429 --> 00:08:46,000
Και αν εμείς, το προσωπικό, να αναγνωρίσει το
μήνυμα λάθους που αντιμετωπίζετε,

171
00:08:46,000 --> 00:08:50,580
θα προσπαθήσουμε να σας προκαλέσει με κάποια
ρητορικές ερωτήσεις, με κάποιες συμβουλές,

172
00:08:50,580 --> 00:08:54,890
μοιάζει πολύ με ένα TF ή μιας ΑΠ ή τον εαυτό μου
θα κάνει το άτομο σε ώρες γραφείου.

173
00:08:54,890 --> 00:08:58,320
>> Έτσι κοιτάξουμε να help50 αν δεν το κάνετε
αναγνωρίζουν κατ 'ανάγκη ένα πρόβλημα.

174
00:08:58,320 --> 00:09:00,790
Αλλά μην βασίζονται σε αυτό
πάρα πολύ ως δεκανίκι.

175
00:09:00,790 --> 00:09:03,990
Σίγουρα προσπαθήσουμε να κατανοήσουμε τους
εξόδου και, στη συνέχεια, να μάθουμε από αυτό

176
00:09:03,990 --> 00:09:07,571
έτσι ώστε μόνο μία ή δύο φορές το κάνετε
ποτέ τρέξει help50 για ένα συγκεκριμένο σφάλμα

177
00:09:07,571 --> 00:09:08,070
μήνυμα.

178
00:09:08,070 --> 00:09:10,660
Μετά από αυτό, θα πρέπει να
καλύτερα εξοπλισμένη τον εαυτό σας

179
00:09:10,660 --> 00:09:13,180
να καταλάβω τι είναι στην πραγματικότητα.

180
00:09:13,180 --> 00:09:14,350
>> Ας κάνουμε ένα άλλο εδώ.

181
00:09:14,350 --> 00:09:20,410
Επιτρέψτε μου να πάει μπροστά, και σε ένα άλλο
αρχείο θα καλέσετε αυτό το buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Και σε αυτό το αρχείο είμαι
πρόκειται να deliberately--

183
00:09:23,110 --> 00:09:26,330
αλλά προσποιούνται ότι δεν το κάνω
καταλάβετε τι λάθος έχω κάνει.

184
00:09:26,330 --> 00:09:31,420
>> Πάω να πάει μπροστά και να κάνουμε this--
#include, δεδομένου ότι έχω

185
00:09:31,420 --> 00:09:33,660
μάθει το μάθημά μου από πριν από λίγο.

186
00:09:33,660 --> 00:09:36,220
Int main (void), όπως και πριν.

187
00:09:36,220 --> 00:09:40,880
Και τότε εδώ θα πάω
να κάνει κορδόνι s - get_string.

188
00:09:40,880 --> 00:09:43,770
Και ανάκληση από τους τελευταία φορά που
Αυτό σημαίνει, hey, ηλεκτρονικών υπολογιστών,

189
00:09:43,770 --> 00:09:48,280
να μου δώσει μια μεταβλητή, καλέστε το s, και
κάνουν το είδος της εν λόγω μεταβλητής μια συμβολοσειρά

190
00:09:48,280 --> 00:09:50,150
ώστε να μπορώ να αποθηκεύσετε μία ή περισσότερες λέξεις σε αυτό.

191
00:09:50,150 --> 00:09:52,191
>> Και στη συνέχεια, στο δεξί χέρι
πλευρά του ίσον

192
00:09:52,191 --> 00:09:54,980
είναι get_string, η οποία είναι μια
λειτουργία στο CS50 Βιβλιοθήκη

193
00:09:54,980 --> 00:09:55,980
ότι κάνει ακριβώς αυτό.

194
00:09:55,980 --> 00:09:59,740
Παίρνει μια λειτουργία και, στη συνέχεια,
τα χέρια του από δεξιά προς τα αριστερά.

195
00:09:59,740 --> 00:10:02,670
Έτσι, αυτό το σύμβολο της ισότητας δεν σημαίνει
"Ισούται", όπως θα μπορούσαμε να σκεφτούμε στα μαθηματικά.

196
00:10:02,670 --> 00:10:04,750
Αυτό σημαίνει εκχώρηση από δεξιά προς τα αριστερά.

197
00:10:04,750 --> 00:10:09,640
Έτσι, αυτό σημαίνει, πάρτε το κορδόνι από το
ο χρήστης και να αποθηκεύσει στο εσωτερικό του s.

198
00:10:09,640 --> 00:10:10,460
>> Τώρα ας το χρησιμοποιήσει.

199
00:10:10,460 --> 00:10:13,820
Επιτρέψτε μου να προχωρήσει τώρα και ως δεύτερης
γραμμή, επιτρέψτε μου να πάει μπροστά και να πω "γεια" -

200
00:10:13,820 --> 00:10:19,330
δεν «κόσμο», αλλά «γειά σου,% S--
το οποίο είναι σύμβολο κράτησης θέσης μας, κόμμα s,

201
00:10:19,330 --> 00:10:22,030
η οποία είναι μεταβλητή μας,
και στη συνέχεια μια άνω τελεία.

202
00:10:22,030 --> 00:10:26,070
Έτσι, αν δεν είχα βίδα μέχρι πολύ
Εδώ, αυτό μοιάζει σωστό κωδικό.

203
00:10:26,070 --> 00:10:28,090
>> Και το ένστικτό μου τώρα είναι να το υπολογίσουν.

204
00:10:28,090 --> 00:10:30,400
Το αρχείο ονομάζεται buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Έτσι, Πάω να κάνουν buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Και καταριέται-it, αν δεν υπάρχει
ακόμη περισσότερα λάθη από ό, τι πριν.

207
00:10:36,377 --> 00:10:38,210
Θέλω να πω, υπάρχουν και άλλα
μηνύματα λάθους θα ήταν

208
00:10:38,210 --> 00:10:40,400
φαίνεται από τις πραγματικές γραμμές σε αυτό το πρόγραμμα.

209
00:10:40,400 --> 00:10:42,730
>> Αλλά το πακέτο είναι εδώ,
ακόμα και αν είστε συγκλονισμένοι

210
00:10:42,730 --> 00:10:45,040
με δύο ή τρία ή
τέσσερις περισσότερα μηνύματα λάθους,

211
00:10:45,040 --> 00:10:48,340
επικεντρώνονται πάντα σε πολύ
πρώτο από αυτά τα μηνύματα.

212
00:10:48,340 --> 00:10:52,220
Κοιτάζοντας την κορυφή-πολύ ένα,
κύλιση προς τα πίσω ως ανάγκη.

213
00:10:52,220 --> 00:10:53,930
Εδώ, λοιπόν, δακτυλογραφημένες make buggy1.

214
00:10:53,930 --> 00:10:55,700
Εδώ είναι η έξοδος Clang όπως αναμενόταν.

215
00:10:55,700 --> 00:10:57,290
>> Και εδώ είναι το πρώτο κόκκινο σφάλμα.

216
00:10:57,290 --> 00:11:02,370
Χρήση της αδήλωτης αναγνωριστικό
string, δεν εννοώ πρότυπο;

217
00:11:02,370 --> 00:11:04,260
Έτσι πρότυπο είναι
πραγματικά το κάτι άλλο.

218
00:11:04,260 --> 00:11:06,240
Αναφέρεται στον χρήστη
πληκτρολόγιο, κατ 'ουσίαν.

219
00:11:06,240 --> 00:11:08,080
>> Αλλά αυτό δεν είναι ό, τι εννοούσα.

220
00:11:08,080 --> 00:11:11,770
Εννοούσα string, και εννοούσα get_string.

221
00:11:11,770 --> 00:11:16,200
Έτσι τι είναι αυτό που εγώ
ξέχασε να κάνει αυτή τη φορά;

222
00:11:16,200 --> 00:11:20,230
Τι λείπει αυτή τη φορά;

223
00:11:20,230 --> 00:11:23,600
Έχω #include μου,
έτσι έχω πρόσβαση σε printf.

224
00:11:23,600 --> 00:11:26,090
>> Αλλά τι μπορώ να μην έχουν
την πρόσβαση σε ακριβώς ακόμα;

225
00:11:26,090 --> 00:11:29,420
Λοιπόν, ακριβώς όπως την τελευταία φορά,
Πρέπει να πω την compiler

226
00:11:29,420 --> 00:11:31,691
Κλαγγή ποιες είναι αυτές οι λειτουργίες.

227
00:11:31,691 --> 00:11:33,940
Get_string δεν έρχεται
με C. Και ειδικότερα,

228
00:11:33,940 --> 00:11:38,160
δεν έρχεται σε η
κεφαλίδα του αρχείου,.

229
00:11:38,160 --> 00:11:40,770
Έρχεται αντί σε
κάτι το προσωπικό έγραψε,

230
00:11:40,770 --> 00:11:44,176
το οποίο είναι ένα διαφορετικό αρχείο
ονομάσει αλλά εύστοχα ονομάστηκε.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Έτσι απλά προσθέτοντας ότι μία γραμμή
της code-- ανάκληση από την τελευταία φορά

233
00:11:50,861 --> 00:11:53,610
ότι όταν Clang τρέχει, πρόκειται
να εξετάσουμε τον κωδικό επάνω μου προς τα κάτω,

234
00:11:53,610 --> 00:11:54,193
από αριστερά προς τα δεξιά.

235
00:11:54,193 --> 00:11:57,200
Είναι πρόκειται να παρατηρήσετε,
Ω, τι θέλετε.

236
00:11:57,200 --> 00:11:59,900
Επιτρέψτε μου να πάει και να βρει ότι,
όπου είναι στο διακομιστή,

237
00:11:59,900 --> 00:12:03,090
αντιγραφή και επικόλληση, κατ 'ουσίαν,
στην κορυφή του δικού σας αρχείου

238
00:12:03,090 --> 00:12:06,820
έτσι ώστε σε αυτό το σημείο στην ιστορία,
γραμμή 1, το υπόλοιπο του προγράμματος

239
00:12:06,820 --> 00:12:11,651
μπορεί, πράγματι, χρησιμοποιήστε οποιαδήποτε από τις λειτουργίες
σ 'αυτό, μεταξύ των οποίων get_string.

240
00:12:11,651 --> 00:12:13,650
Έτσι, Πάω να αγνοήσει
το υπόλοιπο των εν λόγω σφαλμάτων,

241
00:12:13,650 --> 00:12:17,190
γιατί, πράγματι, υποψιάζομαι ότι μόνο
η πρώτη πραγματικά σημασία.

242
00:12:17,190 --> 00:12:20,780
Και Πάω να πάει μπροστά και να επαναπροσδιοριστούν,
Μετά την αποθήκευση του αρχείου μου κάνει buggy1.

243
00:12:20,780 --> 00:12:22,580
Και ιδού, το έκανε δουλειά.

244
00:12:22,580 --> 00:12:29,200
Και αν το κάνω ./buggy1 και πληκτρολογήστε, για
παράδειγμα, Zamyla, εγώ τώρα θα πάρει ένα γεια,

245
00:12:29,200 --> 00:12:32,000
Zamyla, αντί του Hello, world.

246
00:12:32,000 --> 00:12:32,550
>> Εντάξει.

247
00:12:32,550 --> 00:12:35,890
Έτσι, οι takeaways Εδώ λοιπόν είναι να,
ένα, προσπαθήστε να μαζέψει όσο μπορείτε

248
00:12:35,890 --> 00:12:39,140
από τα μηνύματα λάθους και μόνο, ψάχνει
σε μερικά από τα αναγνωρίσιμες λέξεις.

249
00:12:39,140 --> 00:12:43,070
Φραγή ότι, χρησιμοποιήστε help50 ανά
το πρόβλημα που προδιαγραφή.

250
00:12:43,070 --> 00:12:46,500
Αλλά φραγής ότι, πάρα πολύ, πάντα αναζητούν
στην κορυφή σφάλμα μόνο, τουλάχιστον

251
00:12:46,500 --> 00:12:50,051
Αρχικά, για να δούμε τι πληροφορίες
θα μπορούσε στην πραγματικότητα να δώσει.

252
00:12:50,051 --> 00:12:52,300
Αλλά αποδεικνύεται εκεί που
ακόμη περισσότερη λειτουργικότητα χτίστηκε

253
00:12:52,300 --> 00:12:55,030
στο CS50 Βιβλιοθήκη για να βοηθήσει
σας νωρίς στο εξάμηνο

254
00:12:55,030 --> 00:12:57,580
και νωρίς τον προγραμματισμό
καταλάβουμε τι πηγαίνει στραβά.

255
00:12:57,580 --> 00:12:59,840
Έτσι, ας κάνουμε ένα άλλο παράδειγμα εδώ.

256
00:12:59,840 --> 00:13:04,350
Πάω να καλέσετε αυτό buggy2, η οποία,
και πάλι, πρόκειται να αποτύχουν έξω

257
00:13:04,350 --> 00:13:05,650
από την πύλη, από το σχεδιασμό.

258
00:13:05,650 --> 00:13:09,980
>> Και Πάω να πάει μπροστά
και να κάνουμε #include.

259
00:13:09,980 --> 00:13:12,580
Και τότε Πάω να κάνω int main (void).

260
00:13:12,580 --> 00:13:14,840
Και τότε Πάω να κάνω ένα για το βρόχο.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i είναι μικρότερη ή ίση με 10.

263
00:13:18,750 --> 00:13:24,260
i ++, και στη συνέχεια σε άγκιστρα, Πάω
να εκτυπώσετε μόνο ένα σύμβολο hashtag εδώ

264
00:13:24,260 --> 00:13:25,920
και ένα νέο χαρακτήρα γραμμής.

265
00:13:25,920 --> 00:13:29,220
>> Έτσι, η πρόθεση μου με αυτό
το πρόγραμμα είναι πολύ απλά

266
00:13:29,220 --> 00:13:33,150
να επαναλάβει 10 φορές
και σε κάθε επανάληψη

267
00:13:33,150 --> 00:13:35,260
του εν λόγω βρόχου κάθε φορά
μέσω του κύκλου,

268
00:13:35,260 --> 00:13:37,660
εκτυπώσετε ένα hashtag,
ένα hashtag, το hashtag.

269
00:13:37,660 --> 00:13:40,480
Μια γραμμή ανά γιατί
έχουν τη νέα γραμμή εκεί.

270
00:13:40,480 --> 00:13:42,787
Και υπενθυμίζουν ότι η για
βρόχο, ανά τελευταία week--

271
00:13:42,787 --> 00:13:44,620
και θα πάρετε περισσότερα
εξοικειωμένοι με τη σύνταξη

272
00:13:44,620 --> 00:13:47,170
με τη χρήση του με την πρακτική
πριν long-- αυτό μου δίνει

273
00:13:47,170 --> 00:13:49,740
μια μεταβλητή που ονομάζεται i και θέτει σε 0.

274
00:13:49,740 --> 00:13:52,650
>> Αυτό αυξάνει i σε
κάθε επανάληψη από 1.

275
00:13:52,650 --> 00:13:54,940
Έτσι i πηγαίνει στο 1 έως 2 έως 3.

276
00:13:54,940 --> 00:13:57,690
Και τότε αυτός ο όρος στο
μέση μεταξύ των ημι-παχύ έντερο

277
00:13:57,690 --> 00:14:03,010
παίρνει ελέγχεται σε κάθε επανάληψη να κάνουν
βεβαιωθείτε ότι είμαστε ακόμα μέσα στη σειρά.

278
00:14:03,010 --> 00:14:06,830
Γι 'αυτό θέλω να επαναλάβει 10 φορές, γι'
έχουν το είδος της πολύ διαισθητικά μόνο

279
00:14:06,830 --> 00:14:09,070
βάλει 10 ως άνω όριο μου εκεί.

280
00:14:09,070 --> 00:14:14,310
>> Και όμως, όταν τρέχω αυτό, μετά από
μεταγλώττιση με make buggy2--

281
00:14:14,310 --> 00:14:15,440
και δεν συγκεντρώνει OK.

282
00:14:15,440 --> 00:14:17,980
Γι 'αυτό και δεν έχουν
συντακτικό λάθος αυτή τη φορά.

283
00:14:17,980 --> 00:14:20,940
Επιτρέψτε μου να προχωρήσει τώρα
και να τρέξει buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Και τώρα μετακινηθείτε προς τα επάνω.

285
00:14:22,620 --> 00:14:24,890
Και επιτρέψτε μου να αυξήσουν
το μέγεθος του παραθύρου.

286
00:14:24,890 --> 00:14:33,720
>> I φαίνεται να έχει 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Έτσι, υπάρχει 11 διέσεις, παρόλο
Έβαλα ξεκάθαρα 10 στο εσωτερικό αυτού του βρόχου.

288
00:14:38,891 --> 00:14:42,140
Τώρα, κάποιοι από εσάς μπορεί να δει αμέσως
τι το σφάλμα είναι επειδή, πράγματι, αυτή η

289
00:14:42,140 --> 00:14:43,720
δεν είναι ένα πολύ δύσκολο να κάνει λάθος.

290
00:14:43,720 --> 00:14:46,070
Αλλά είναι πολύ συχνά
έκανε πολύ νωρίς.

291
00:14:46,070 --> 00:14:49,820
>> Αυτό που θέλω να επισημάνω, όμως,
είναι, πώς θα μπορούσε να μπορώ να καταλάβω αυτό έξω;

292
00:14:49,820 --> 00:14:52,300
Λοιπόν, αποδεικνύεται ότι
το CS50 Βιβλιοθήκη έρχεται

293
00:14:52,300 --> 00:14:55,380
με όχι μόνο get_string και get_int
και get_float και άλλες λειτουργίες.

294
00:14:55,380 --> 00:14:59,980
Επίσης, έρχεται με μια ειδική λειτουργία
που ονομάζεται eprintf, ή, printf σφάλμα.

295
00:14:59,980 --> 00:15:03,270
Και υπάρχει μόνο για να κάνουν
είναι λίγο πιο εύκολο για εσάς

296
00:15:03,270 --> 00:15:06,310
όταν τον εντοπισμό σφαλμάτων κώδικα σας μόνο
εκτυπώσετε ένα μήνυμα σφάλματος στην οθόνη

297
00:15:06,310 --> 00:15:07,850
και να ξέρετε από πού προήλθε.

298
00:15:07,850 --> 00:15:11,000
>> Έτσι, για παράδειγμα, ένα πράγμα που θα μπορούσε
κάνουμε εδώ με αυτή τη λειτουργία είναι this--

299
00:15:11,000 --> 00:15:20,230
eprintf, και στη συνέχεια, Πάω να πάει μπροστά
και να πω εγώ τώρα είναι% i, backslash, n.

300
00:15:20,230 --> 00:15:22,330
Και Πάω να συνδέσετε την αξία του i.

301
00:15:22,330 --> 00:15:25,400
Και επάνω στην κορυφή, διότι αυτό
είναι στη CS50 Βιβλιοθήκη,

302
00:15:25,400 --> 00:15:27,580
Πάω να πάει μπροστά
και περιλαμβάνουν

303
00:15:27,580 --> 00:15:29,169
έτσι έχω πρόσβαση σε αυτή τη λειτουργία.

304
00:15:29,169 --> 00:15:31,460
Αλλά ας εξετάσουμε τι γραμμή
9 υποτίθεται ότι πρέπει να κάνει.

305
00:15:31,460 --> 00:15:32,670
Πάω να διαγράψετε αυτό τελικά.

306
00:15:32,670 --> 00:15:34,670
Αυτό δεν έχει να κάνει
με πρωταρχικό στόχο μου.

307
00:15:34,670 --> 00:15:39,090
Αλλά eprintf, printf λάθος, είναι ακριβώς σήμαινε
να μου δώσει κάποιες διαγνωστικές πληροφορίες.

308
00:15:39,090 --> 00:15:42,460
Όταν τρέχω το πρόγραμμα μου, θέλω να
δείτε αυτό στην οθόνη προσωρινά

309
00:15:42,460 --> 00:15:44,550
καθώς και απλά για να καταλάβετε
τι συμβαίνει.

310
00:15:44,550 --> 00:15:47,330
>> Και, πράγματι, σε καθένα
επανάληψη εδώ γραμμής 9

311
00:15:47,330 --> 00:15:49,260
Θέλω να δω, ποια είναι η αξία του i;

312
00:15:49,260 --> 00:15:50,290
Ποια είναι η τιμή του i;

313
00:15:50,290 --> 00:15:51,280
Ποια είναι η τιμή του i;

314
00:15:51,280 --> 00:15:55,650
Και, ελπίζω, θα ήθελα μόνο
δείτε αυτό το μήνυμα, επίσης, 10 φορές.

315
00:15:55,650 --> 00:15:57,780
>> Επιτρέψτε μου λοιπόν να πάει μπροστά και να
μεταγλωττίσετε το πρόγραμμά μου,

316
00:15:57,780 --> 00:15:59,905
όπως έχω να κάνω οποιαδήποτε στιγμή
Έχω κάνει μια αλλαγή. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Και now-- OK.

319
00:16:03,640 --> 00:16:04,820
Υπάρχουν πολλά άλλα πράγματα.

320
00:16:04,820 --> 00:16:07,610
Επιτρέψτε μου λοιπόν να μετακινηθείτε προς τα επάνω στο
ένα ακόμη μεγαλύτερο παράθυρο.

321
00:16:07,610 --> 00:16:10,190
>> Και θα δείτε ότι κάθε ένα από
η hashtags εξακολουθεί εκτύπωση.

322
00:16:10,190 --> 00:16:15,270
Αλλά στο μεταξύ κάθε μία από αυτές είναι τώρα αυτό
διαγνωστική έξοδος διαμορφωθεί ως εξής.

323
00:16:15,270 --> 00:16:17,960
Το όνομα του προγράμματος μου εδώ είναι buggy2.

324
00:16:17,960 --> 00:16:20,432
Το όνομα του αρχείου είναι buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Ο αριθμός γραμμή από την οποία
αυτό τυπώθηκε είναι η γραμμή 9.

326
00:16:24,080 --> 00:16:27,500
Και στη συνέχεια στα δεξιά ότι είναι η
μήνυμα λάθους που περιμένω.

327
00:16:27,500 --> 00:16:30,701
>> Και τι είναι ωραίο για αυτό είναι ότι
τώρα δεν έχω να μετρήσει απαραίτητα

328
00:16:30,701 --> 00:16:32,200
στο κεφάλι μου τι κάνει το πρόγραμμά μου.

329
00:16:32,200 --> 00:16:34,240
Βλέπω ότι για την
πρώτη επανάληψη i είναι 0,

330
00:16:34,240 --> 00:16:39,420
τότε 1, έπειτα 2, τότε 3, τότε 4, τότε
5, και στη συνέχεια 6, τότε 7, τότε 8, στη συνέχεια 9, τότε

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Έτσι, περιμένετε ένα λεπτό.

333
00:16:42,050 --> 00:16:43,740
Τι συμβαίνει εδώ?

334
00:16:43,740 --> 00:16:48,190
Ακόμα φαίνεται να μετράει
όπως προβλεπόταν μέχρι 10.

335
00:16:48,190 --> 00:16:50,550
>> Αλλά πού να αρχίσω;

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Έτσι 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- το 11ο δάχτυλο

338
00:16:58,040 --> 00:16:59,990
είναι ενδεικτικό του προβλήματος.

339
00:16:59,990 --> 00:17:02,850
Μου φαίνεται να έχουν μετρηθεί
εσφαλμένα στο βρόχο μου.

340
00:17:02,850 --> 00:17:06,599
Αντί να πάει 10 επαναλήψεις,
Αρχίζω σε 0,

341
00:17:06,599 --> 00:17:09,550
Είμαι τελειώνει στο και μέσω της 10.

342
00:17:09,550 --> 00:17:12,030
Αλλά επειδή, όπως έναν υπολογιστή,
Αρχίζω καταμέτρηση σε 0,

343
00:17:12,030 --> 00:17:15,250
Θα πρέπει να μετράει μέχρι
σε, αλλά όχι μέσω της 10.

344
00:17:15,250 --> 00:17:18,510
>> Και έτσι η λύση, εγώ τελικά
συνειδητοποιήσει εδώ, είναι ένα από τα δύο πράγματα.

345
00:17:18,510 --> 00:17:22,430
Θα μπορούσε πολύ απλά να πω
μετράνε μέχρι λιγότερο από 10.

346
00:17:22,430 --> 00:17:27,260
Έτσι 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, το οποίο είναι, πράγματι, σωστή,

347
00:17:27,260 --> 00:17:28,900
ακόμα κι αν αυτό ακούγεται λίγο λάθος.

348
00:17:28,900 --> 00:17:35,070
Ή θα μπορούσα να κάνω μικρότερη ή ίση
έως 9, εφ 'όσον μπορώ να ξεκινήσω σε 0.

349
00:17:35,070 --> 00:17:40,056
Ή αν πραγματικά δεν μου αρέσει αυτό, θα
μπορεί να μετρήσει μέχρι έως 10, αλλά ξεκινούν από 1.

350
00:17:40,056 --> 00:17:41,680
Αλλά και πάλι, αυτό δεν είναι ακριβώς ότι η κοινή.

351
00:17:41,680 --> 00:17:43,977
Σε programming-- έστω
όχι τόσο σε Scratch--

352
00:17:43,977 --> 00:17:45,810
αλλά στον προγραμματισμό σε
C και σε άλλες γλώσσες,

353
00:17:45,810 --> 00:17:47,670
όπως JavaScript και
Python και άλλους, είναι

354
00:17:47,670 --> 00:17:49,880
απλά πολύ κοινό για
συζήτησή μας της δυαδικής

355
00:17:49,880 --> 00:17:53,450
σε μόλις αρχίζουν να μετρούν κατά τη
χαμηλότερο αριθμό μπορείτε, η οποία είναι 0.

356
00:17:53,450 --> 00:17:53,950
Εντάξει.

357
00:17:53,950 --> 00:17:55,160
Έτσι ώστε να είναι eprintf.

358
00:17:55,160 --> 00:17:58,600
Και πάλι, τώρα που έχω καταλάβει μου
πρόβλημα, και είμαι πρόκειται να πάει πίσω στο 0

359
00:17:58,600 --> 00:18:01,470
μέσω λιγότερο από 10, Πάω
να πάει μέσα και να διαγράψετε eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Δεν θα πρέπει να υπάρχει όταν
Στέλνουμε τον κωδικό μου ή να υποβάλει τον κωδικό μου

361
00:18:04,580 --> 00:18:05,800
ή το δείξει σε κανέναν άλλο.

362
00:18:05,800 --> 00:18:07,980
Είναι πραγματικά ακριβώς σήμαινε
που θα χρησιμοποιηθεί προσωρινά.

363
00:18:07,980 --> 00:18:11,650
Αλλά τώρα έχω αυτή καθορίζεται
ιδιαίτερο πρόβλημα, καθώς και.

364
00:18:11,650 --> 00:18:16,780
>> Λοιπόν, ας κάνουμε ένα ακόμη παράδειγμα εδώ
ότι θα πάω να κτυπήσει επάνω ως εξής.

365
00:18:16,780 --> 00:18:22,850
Πάω να πάει μπροστά και να
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
Και Πάω να πάει μπροστά
και #include.

367
00:18:25,580 --> 00:18:29,030
>> Και Πάω να αποθηκεύσετε
Αυτό το αρχείο όπως buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Και Πάω να πάει μπροστά
και να κηρύξει int main (void).

369
00:18:31,740 --> 00:18:34,186
Και στη συνέχεια στο εσωτερικό του υπάρχει
Πάω να κάνω int i _ -

370
00:18:34,186 --> 00:18:36,435
Θέλω να εφαρμόσει ένα πρόγραμμα
με get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Αυτό δεν είναι μια λειτουργία που υπάρχει ακόμα.

373
00:18:40,770 --> 00:18:42,870
Έτσι θα πάμε να εφαρμόσουν
αυτό ακριβώς σε μια στιγμή.

374
00:18:42,870 --> 00:18:45,541
Αλλά θα πάμε να δούμε γιατί
Είναι λάθη στο πρώτο πέρασμα.

375
00:18:45,541 --> 00:18:47,290
Και από τη στιγμή που έχω πάρει
ένας int από το χρήστη,

376
00:18:47,290 --> 00:18:53,365
Είμαι ακριβώς πρόκειται να εκτυπώσετε% i είναι ένας αρνητικός
ακέραιος, backslash, n, κόμμα, i.

377
00:18:53,365 --> 00:18:55,240
Με άλλα λόγια, το μόνο που μπορώ
θέλετε αυτό το πρόγραμμα για να κάνει

378
00:18:55,240 --> 00:18:58,000
έχει πάρει μια αρνητική int από
ο χρήστης και στη συνέχεια να εκτυπώσετε

379
00:18:58,000 --> 00:18:59,980
ότι ο τάδε είναι αρνητικό int.

380
00:18:59,980 --> 00:19:02,080
>> Τώρα πρέπει να εφαρμόσουν αυτή τη λειτουργία.

381
00:19:02,080 --> 00:19:05,740
Έτσι αργότερα στο αρχείο μου, είμαι πρόκειται να πάει
μπροστά και να κηρύξει μια λειτουργία που ονομάζεται

382
00:19:05,740 --> 00:19:10,670
get_negative_int (κενό) - και θα
επανέλθω σε αυτό που σημαίνει και πάλι ότι η γραμμή

383
00:19:10,670 --> 00:19:18,790
σε moment-- int n? παίξε
η following-- printf n είναι :.

384
00:19:18,790 --> 00:19:26,210
Και τότε Πάω να κάνω n - get_int,
και να το κάνουμε αυτό, ενώ n είναι μεγαλύτερο από 0.

385
00:19:26,210 --> 00:19:28,310
Και στη συνέχεια επιστρέφουν n ;.

386
00:19:28,310 --> 00:19:31,730
>> Έτσι, υπάρχει μια παρτίδα σε εξέλιξη στην
αυτό, αλλά κανένα από τα οποία δεν είχαμε

387
00:19:31,730 --> 00:19:33,710
εξετάσουμε την περασμένη εβδομάδα, τουλάχιστον για λίγο.

388
00:19:33,710 --> 00:19:36,980
Έτσι, στη γραμμή 10 εδώ έχω κηρυχθεί
συνάρτηση που ονομάζεται get_negative_int,

389
00:19:36,980 --> 00:19:39,620
και έχω βάλει (κενό), σε
παρένθεση, ο λόγος είναι αυτό

390
00:19:39,620 --> 00:19:40,950
δεν λαμβάνει μια είσοδο.

391
00:19:40,950 --> 00:19:42,910
Δεν είμαι περνά τίποτα
σε αυτή τη λειτουργία.

392
00:19:42,910 --> 00:19:44,690
Είμαι απλά να πάρει κάτι πίσω από αυτό.

393
00:19:44,690 --> 00:19:47,270
>> Και τι είμαι ελπίζοντας να
να πάρει πίσω είναι ένας ακέραιος.

394
00:19:47,270 --> 00:19:50,040
Δεν υπάρχει τύπος δεδομένων σε
C ονομάζεται negative_int.

395
00:19:50,040 --> 00:19:52,880
Είναι ακριβώς int, γι 'αυτό πρόκειται
να είναι σε εμάς για να βεβαιωθείτε

396
00:19:52,880 --> 00:19:55,340
ότι η τιμή που πραγματικά
επιστρέφεται είναι όχι μόνο ένας int

397
00:19:55,340 --> 00:19:56,380
αλλά είναι επίσης αρνητική.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 Είμαι δηλώνοντας μια μεταβλητή
καλείται ν και καθιστώντας τύπου int.

399
00:20:02,150 --> 00:20:07,500
Και, στη συνέχεια, στη γραμμή 13 έως 18 Είμαι
να κάνει κάτι, ενώ κάτι είναι αληθινό.

400
00:20:07,500 --> 00:20:11,040
Πάω μπροστά και εκτύπωση
Ν είναι, του παχέος εντέρου, και στη συνέχεια ένα διάστημα,

401
00:20:11,040 --> 00:20:12,800
σαν μια γραμμή για το χρήστη.

402
00:20:12,800 --> 00:20:16,410
>> Είμαι στη συνέχεια, καλώντας get_int και
αποθήκευση λεγόμενη τιμή επιστροφής της

403
00:20:16,410 --> 00:20:18,130
σε αυτή τη μεταβλητή n.

404
00:20:18,130 --> 00:20:22,600
Αλλά Πάω να συνεχίσω να το κάνω
αυτό, ενώ το η είναι μεγαλύτερο από μηδέν.

405
00:20:22,600 --> 00:20:27,960
Με άλλα λόγια, αν ο χρήστης μου ένα δίνει
int και ο αριθμός αυτός είναι μεγαλύτερος από 0,

406
00:20:27,960 --> 00:20:31,180
ergo, θετική, Πάω να
κρατήσει μόνο reprompting το χρήστη,

407
00:20:31,180 --> 00:20:37,160
κρατήσει reprompting, αναγκάζοντάς τους να
συνεργάζονται και να μου δώσει μια αρνητική int.

408
00:20:37,160 --> 00:20:41,640
>> Και από τη στιγμή n είναι πραγματικά negative--
ας υποθέσουμε ότι ο χρήστης τελικά είδη -50,

409
00:20:41,640 --> 00:20:46,710
τότε αυτό το βρόχο, ενώ δεν ισχύει πλέον
επειδή -50 δεν είναι μεγαλύτερη από μηδέν.

410
00:20:46,710 --> 00:20:51,140
Γι 'αυτό ξεφύγει από ότι
βρόχο λογικά και να επιστρέψει n.

411
00:20:51,140 --> 00:20:53,520
>> Αλλά υπάρχει ένα άλλο
πράγμα που έχω να κάνω.

412
00:20:53,520 --> 00:20:56,190
Και απλά μπορώ να το κάνω αυτό
με αντιγραφή και επικόλληση

413
00:20:56,190 --> 00:20:58,540
μία γραμμή κώδικα στην κορυφή του αρχείου.

414
00:20:58,540 --> 00:21:01,630
Θα πρέπει να διδάξουμε Clang,
ή υπόσχονται να κλαγγή,

415
00:21:01,630 --> 00:21:04,630
ρητά ότι θα το κάνω,
Πράγματι, πάει και να εφαρμόσουν

416
00:21:04,630 --> 00:21:06,020
αυτή η λειτουργία get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Θα μπορούσε απλώς να είναι χαμηλότερη στο αρχείο.

418
00:21:07,674 --> 00:21:09,840
Και πάλι, υπενθυμίζουν ότι Clang
διαβάζει πράγματα πάνω προς τα κάτω,

419
00:21:09,840 --> 00:21:12,330
αριστερά προς τα δεξιά, έτσι ώστε να μην μπορεί να
καλέσετε μια συνάρτηση αν Clang

420
00:21:12,330 --> 00:21:15,330
δεν ξέρει ότι πρόκειται να υπάρχουν.

421
00:21:15,330 --> 00:21:18,430
>> Τώρα, δυστυχώς, αυτό το πρόγραμμα,
όπως κάποιοι από εσάς ίσως έχετε παρατηρήσει,

422
00:21:18,430 --> 00:21:19,590
είναι ήδη λάθη.

423
00:21:19,590 --> 00:21:21,400
Επιτρέψτε μου να προχωρήσει και να κάνει buggy3.

424
00:21:21,400 --> 00:21:26,904
Καταρτίζει, οπότε το πρόβλημά μου τώρα δεν είναι
συντακτικό σφάλμα, όπως ένα σφάλμα κειμένου,

425
00:21:26,904 --> 00:21:29,570
αυτό είναι πραγματικά πρόκειται να είναι μια λογική
λάθους που έχω σκόπιμα

426
00:21:29,570 --> 00:21:32,450
έκανε ως μια ευκαιρία για να
βήμα μέσα από ό, τι συμβαίνει.

427
00:21:32,450 --> 00:21:35,540
>> Πάω να πάει μπροστά
τώρα και τρέχει buggy3.

428
00:21:35,540 --> 00:21:37,490
Και Πάω να πάει
μπροστά και όχι να συνεργαστούν.

429
00:21:37,490 --> 00:21:39,494
Πάω να του δώσει τον αριθμό 1.

430
00:21:39,494 --> 00:21:41,410
Δεν του άρεσε, οπότε
αυτό είναι μου ζητά και πάλι.

431
00:21:41,410 --> 00:21:42,147
>> Πόσο περίπου 2;

432
00:21:42,147 --> 00:21:43,021
3;

433
00:21:43,021 --> 00:21:43,520
50;

434
00:21:43,520 --> 00:21:44,740
Κανένας από αυτούς εργάζονται.

435
00:21:44,740 --> 00:21:46,890
Πόσο περίπου -50;

436
00:21:46,890 --> 00:21:48,560
Και το πρόγραμμα φαίνεται να λειτουργεί.

437
00:21:48,560 --> 00:21:49,970
>> Επιτρέψτε μου να το δοκιμάσετε για μια ακόμη φορά.

438
00:21:49,970 --> 00:21:53,400
Επιτρέψτε μου να προσπαθήσω -1, φαίνεται να λειτουργεί.

439
00:21:53,400 --> 00:21:56,380
Επιτρέψτε μου να προσπαθήσω -2, φαίνεται να λειτουργεί.

440
00:21:56,380 --> 00:21:59,640
Επιτρέψτε μου να προσπαθήσω 0.

441
00:21:59,640 --> 00:22:01,684
Ε, αυτό είναι εσφαλμένη.

442
00:22:01,684 --> 00:22:03,350
Τώρα, θέλουμε να είμαστε λίγο σχολαστικός εδώ.

443
00:22:03,350 --> 00:22:07,090
Αλλά είναι, πράγματι, η υπόθεση ότι 0
δεν είναι ούτε θετική ούτε αρνητική.

444
00:22:07,090 --> 00:22:11,150
Και έτσι το γεγονός ότι το πρόγραμμά μου είναι
λέγοντας ότι το 0 είναι ένας αρνητικός ακέραιος,

445
00:22:11,150 --> 00:22:12,820
αυτό δεν είναι τεχνικά σωστό.

446
00:22:12,820 --> 00:22:15,180
>> Τώρα, γιατί το κάνει αυτό;

447
00:22:15,180 --> 00:22:16,270
Λοιπόν, θα μπορούσε να είναι προφανής.

448
00:22:16,270 --> 00:22:18,110
Και, πράγματι, το πρόγραμμα είναι
προορίζεται να είναι αρκετά απλή

449
00:22:18,110 --> 00:22:19,670
ώστε να έχουμε κάτι για να εξερευνήσετε.

450
00:22:19,670 --> 00:22:25,870
>> Αλλά ας εισαγάγει μια τρίτη εντοπισμού σφαλμάτων
τεχνική που ονομάζεται εδώ debug50.

451
00:22:25,870 --> 00:22:27,750
Έτσι, αυτό είναι ένα πρόγραμμα
ότι έχουμε μόλις δημιουργήσατε

452
00:22:27,750 --> 00:22:30,770
φέτος ονομάζεται debug50
που θα σας επιτρέψει

453
00:22:30,770 --> 00:22:34,130
να χρησιμοποιήσετε ό, τι λέγεται ένα ενσωματωμένο
γραφικό πρόγραμμα εντοπισμού σφαλμάτων σε CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Και ένα πρόγραμμα εντοπισμού σφαλμάτων είναι απλά ένα πρόγραμμα που
γενικά σας επιτρέπει να εκτελέσετε το πρόγραμμά σας

455
00:22:38,400 --> 00:22:44,050
αλλά βήμα-βήμα προς βήμα, γραμμή
από τη γραμμή προς γραμμή, παύση, σπρώχνει

456
00:22:44,050 --> 00:22:47,626
γύρω, κοιτάζοντας μεταβλητές έτσι ώστε
το πρόγραμμα δεν βγάζει μόνο το παρελθόν σας

457
00:22:47,626 --> 00:22:49,750
και γρήγορα να εκτυπώσετε κάτι
ή όχι να εκτυπώσετε κάτι.

458
00:22:49,750 --> 00:22:53,250
Σας δίνει την ευκαιρία, σε
ανθρώπινα ταχύτητα, να αλληλεπιδρούν με αυτό.

459
00:22:53,250 --> 00:22:55,470
>> Και για να το κάνετε αυτό,
απλά κάντε τα εξής.

460
00:22:55,470 --> 00:22:58,479
Μετά την μεταγλώττιση κωδικό σας,
που έκανα ήδη, buggy3,

461
00:22:58,479 --> 00:23:00,020
να προχωρήσει και να τρέξει debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Τόσο πολύ όπως help50 έχει τρέχετε
help50 και τότε η εντολή,

464
00:23:06,760 --> 00:23:10,120
debug50 έχει τρέχετε debug50 και
τότε το όνομα της εντολής.

465
00:23:10,120 --> 00:23:14,440
>> Τώρα παρακολουθούμε τι συμβαίνει στην οθόνη μου,
στη δεξιά πλευρά ειδικότερα.

466
00:23:14,440 --> 00:23:19,400
Όταν χτύπησα Run, όλα τα
ξαφνική πάνελ αυτό το δεξί χέρι

467
00:23:19,400 --> 00:23:20,419
ανοίγει στην οθόνη.

468
00:23:20,419 --> 00:23:22,210
Και υπάρχει μια παρτίδα σε εξέλιξη
σχετικά με την πρώτη ματιά.

469
00:23:22,210 --> 00:23:25,110
Αλλά δεν είναι εκεί
πολύ να ανησυχείτε για ακόμη.

470
00:23:25,110 --> 00:23:28,570
>> Αυτό μου δείχνει τα πάντα
ότι συμβαίνει στο εσωτερικό του προγράμματός μου

471
00:23:28,570 --> 00:23:31,130
τώρα και μέσω αυτών
κουμπιά επάνω στην κορυφή είναι τότε

472
00:23:31,130 --> 00:23:35,910
μου επιτρέπει να το βήμα μέσω του κωδικού μου
τελικά, βήμα προς βήμα με βήμα.

473
00:23:35,910 --> 00:23:37,140
Αλλά δεν είναι ακριβώς ακόμα.

474
00:23:37,140 --> 00:23:38,060
Παρατηρήστε τι συμβαίνει.

475
00:23:38,060 --> 00:23:40,600
Στο παράθυρό μου τερματικού
Είμαι να ζητηθεί n.

476
00:23:40,600 --> 00:23:44,560
Και Πάω να πάει μπροστά και να
συνεργάζεται αυτή τη φορά και τον τύπο στο -1.

477
00:23:44,560 --> 00:23:48,770
Και αν και είναι λίγο κρυφά, -1
είναι ένας αρνητικός ακέραιος, όπως αναμενόταν.

478
00:23:48,770 --> 00:23:52,020
>> Και τότε το παιδί βγήκε με
κατάσταση 0 GDBserver την έξοδο.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, είναι το όνομα
του υποκείμενου λογισμικού

480
00:23:55,180 --> 00:23:56,620
ότι υλοποιεί αυτό το πρόγραμμα εντοπισμού σφαλμάτων.

481
00:23:56,620 --> 00:24:00,500
Αλλά όλο αυτό σημαίνει πραγματικά, το πρόγραμμα εντοπισμού σφαλμάτων
πήγε μακριά, γιατί το πρόγραμμά μου κόψει

482
00:24:00,500 --> 00:24:01,710
και όλα ήταν καλά.

483
00:24:01,710 --> 00:24:06,020
Αν θέλω να debug πραγματικά το πρόγραμμά μου,
Οφείλω να πω preemptively debug50,

484
00:24:06,020 --> 00:24:08,920
όπου μπορώ να θέλετε να ξεκινήσετε
ενίσχυση μέσω του κωδικού μου;

485
00:24:08,920 --> 00:24:11,750
>> Και ίσως ο απλούστερος τρόπος
για να γίνει αυτό είναι η εξής.

486
00:24:11,750 --> 00:24:15,300
Αν μου αιωρείται πάνω από το
υδρορροή του επεξεργαστή μου εδώ,

487
00:24:15,300 --> 00:24:19,090
έτσι ώστε πραγματικά ακριβώς στο sidebar εδώ,
στα αριστερά του αριθμού γραμμής,

488
00:24:19,090 --> 00:24:21,870
Παρατηρήστε ότι αν μπορώ απλά κάντε κλικ
μια φορά, έβαλα λίγο κόκκινη κουκίδα.

489
00:24:21,870 --> 00:24:24,460
Και αυτή η μικρή κόκκινη κουκκίδα,
σαν ένα σήμα στοπ, σημαίνει, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, εκτέλεση παύση των κωδικό μου
εκεί όταν τρέχω αυτό το πρόγραμμα.

491
00:24:29,430 --> 00:24:30,260
>> Οπότε ας το κάνουμε αυτό.

492
00:24:30,260 --> 00:24:37,340
Επιτρέψτε μου να πάει μπροστά και να τρέξει το πρόγραμμά μου
πάλι με debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Και τώρα, προειδοποίηση, κάτι
διαφορετικών έχει συμβεί.

494
00:24:40,110 --> 00:24:42,440
Δεν είμαι να σας ζητηθεί
ακόμα στο παράθυρό μου τερματικού

495
00:24:42,440 --> 00:24:45,430
για τίποτα, επειδή δεν έχω
πάρει εκεί ακόμα στο πρόγραμμά μου.

496
00:24:45,430 --> 00:24:47,950
Παρατηρήστε ότι στη γραμμή 8
η οποία είναι πλέον τονίζεται,

497
00:24:47,950 --> 00:24:51,720
και υπάρχει ένα μικρό βέλος
αριστερά ρητό, είστε εδώ σε παύση.

498
00:24:51,720 --> 00:24:55,030
Αυτή η γραμμή του κώδικα, γραμμή
8, δεν έχει ακόμη εκτελεστεί.

499
00:24:55,030 --> 00:24:58,940
>> Και τι είναι περίεργο, αν κοιτάξω
εδώ στη δεξιά πλευρά,

500
00:24:58,940 --> 00:25:03,530
Παρατηρήστε ότι είναι ένα τοπικό
μεταβλητή, η τοπική με την έννοια

501
00:25:03,530 --> 00:25:05,450
ότι είναι μέσα στην τρέχουσα λειτουργία.

502
00:25:05,450 --> 00:25:08,920
Και την αξία του, προφανώς από προεπιλογή,
και το είδος βολικά, είναι 0.

503
00:25:08,920 --> 00:25:10,260
Αλλά εγώ δεν πληκτρολογήστε 0.

504
00:25:10,260 --> 00:25:13,410
Αυτό συμβαίνει ακριβώς να είναι της
προεπιλεγμένη τιμή αυτή τη στιγμή.

505
00:25:13,410 --> 00:25:15,490
>> Επιτρέψτε μου λοιπόν να προχωρήσει και να το κάνουμε αυτό τώρα.

506
00:25:15,490 --> 00:25:18,680
Επιτρέψτε μου να προχωρήσει και σε
το πάνω δεξιά εδώ, είμαι

507
00:25:18,680 --> 00:25:20,970
πρόκειται να πάει μπροστά και να
κάντε κλικ σε αυτό το πρώτο εικονίδιο που

508
00:25:20,970 --> 00:25:25,360
σημαίνει το βήμα πάνω από το οποίο σημαίνει ότι δεν παραλείψετε
αυτό, αλλά βήμα πέρα ​​από αυτή τη γραμμή του κώδικα,

509
00:25:25,360 --> 00:25:27,770
εκτέλεσης κατά μήκος του τρόπου.

510
00:25:27,770 --> 00:25:30,710
>> Και τώρα, παρατηρήσετε, μου
γραμμή έχει μόλις αλλάξει.

511
00:25:30,710 --> 00:25:31,380
Γιατί αυτό?

512
00:25:31,380 --> 00:25:33,639
Έχω πει debug50,
τρέχουν αυτή τη γραμμή του κώδικα.

513
00:25:33,639 --> 00:25:34,930
Τι σημαίνει αυτή η γραμμή του κώδικα κάνω;

514
00:25:34,930 --> 00:25:35,960
Μου ζητά έναν int.

515
00:25:35,960 --> 00:25:36,460
ΕΝΤΆΞΕΙ.

516
00:25:36,460 --> 00:25:37,400
Επιτρέψτε μου να συνεργάζονται.

517
00:25:37,400 --> 00:25:41,340
Επιτρέψτε μου να προχωρήσει τώρα και πληκτρολογήστε -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Και τώρα παρατηρήσετε τι έχει αλλάξει.

519
00:25:42,920 --> 00:25:46,060
Στη δεξιά πλευρά,
τοπική μεταβλητή i μου

520
00:25:46,060 --> 00:25:48,200
ενδείκνυται ως -1 τώρα.

521
00:25:48,200 --> 00:25:49,810
Και εξακολουθεί να είναι του τύπου int.

522
00:25:49,810 --> 00:25:53,102
>> Και ειδοποίηση, πάρα πολύ, μου λεγόμενη
στοίβα κλήσεων, πού μπορώ να διακόψω;

523
00:25:53,102 --> 00:25:54,810
Θα μιλήσουμε περισσότερο για
αυτό στο μέλλον.

524
00:25:54,810 --> 00:25:58,620
Αλλά η στοίβα κλήσεων αναφέρεται μόνο σε ό, τι
λειτουργίες είναι επί του παρόντος σε κίνηση.

525
00:25:58,620 --> 00:26:00,040
Αυτή τη στιγμή είναι απλά κύριο.

526
00:26:00,040 --> 00:26:03,590
Και τώρα το μόνο τοπικό
μεταβλητή είναι i με τιμή 1.

527
00:26:03,590 --> 00:26:09,840
>> Και όταν τελικά βήμα πέρα ​​από αυτή τη γραμμή
Εδώ, με το ίδιο εικονίδιο στο πάνω δεξιά,

528
00:26:09,840 --> 00:26:11,410
-1 Είναι ένας αρνητικός ακέραιος.

529
00:26:11,410 --> 00:26:13,580
Τώρα είναι να σταθούμε πάνω από το σγουρά κηδεμόνα.

530
00:26:13,580 --> 00:26:14,740
Ας αφήστε το να κάνει το πράγμα του.

531
00:26:14,740 --> 00:26:17,300
Πατάω πάνω από αυτή τη γραμμή, και voila.

532
00:26:17,300 --> 00:26:20,240
>> Έτσι, δεν είναι όλα τόσο τρομερά
διαφωτιστική ακόμα,

533
00:26:20,240 --> 00:26:23,550
αλλά άφησε να διακόψετε
και σκεφτείτε μέσω λογικά

534
00:26:23,550 --> 00:26:24,870
τι κάνει αυτό το πρόγραμμα.

535
00:26:24,870 --> 00:26:26,890
Αλλά αυτό δεν ήταν η λανθασμένη υπόθεση.

536
00:26:26,890 --> 00:26:28,510
Ας το κάνουμε αυτό και πάλι ως εξής.

537
00:26:28,510 --> 00:26:31,340
>> Πάω να αφήσει αυτό το σημείο διακοπής
on line 8 με την κόκκινη κουκκίδα.

538
00:26:31,340 --> 00:26:32,830
Πάω να επαναληφθεί debug50.

539
00:26:32,830 --> 00:26:34,400
Είναι αυτόματα παύση εδώ.

540
00:26:34,400 --> 00:26:37,660
Αλλά αυτή τη φορά, αντί της
την ενίσχυση πάνω από τη γραμμή αυτή,

541
00:26:37,660 --> 00:26:42,290
επιτρέψτε μου να πραγματικά να πάμε στο εσωτερικό της
get_negative_int και να καταλάβω,

542
00:26:42,290 --> 00:26:45,530
γιατί είναι αποδοχή 0 ως έγκυρη απάντηση;

543
00:26:45,530 --> 00:26:47,990
>> Έτσι, αντί να κάνετε κλικ Step Over.

544
00:26:47,990 --> 00:26:50,630
Πάω να πάει μπροστά
και κάντε κλικ στο Βήμα Into.

545
00:26:50,630 --> 00:26:54,030
Και παρατηρήστε ότι η γραμμή 8 που είναι
τώρα τονίζεται τώρα ξαφνικά

546
00:26:54,030 --> 00:26:56,900
γίνεται γραμμή 17.

547
00:26:56,900 --> 00:26:59,947
>> Τώρα, δεν είναι ότι το πρόγραμμα εντοπισμού σφαλμάτων
έχει παραληφθεί γραμμές 14 και 15 και 16.

548
00:26:59,947 --> 00:27:01,780
Είναι απλά δεν υπάρχει τίποτα
για να σας δείξει εκεί.

549
00:27:01,780 --> 00:27:04,050
Αυτά είναι μόνο δηλώνοντας μεταβλητές,
και στη συνέχεια να υπάρχει είναι η λέξη Do

550
00:27:04,050 --> 00:27:05,390
και στη συνέχεια ένα ανοιχτό σγουρά κηδεμόνα.

551
00:27:05,390 --> 00:27:09,227
Η μόνη λειτουργική γραμμή που είναι
ζουμερά είναι πραγματικά αυτό εδώ, 17.

552
00:27:09,227 --> 00:27:11,060
Και αυτό είναι που έχουμε
παύση αυτόματα.

553
00:27:11,060 --> 00:27:13,870
>> Έτσι printf ( "n.is:") ;, έτσι
ότι δεν έχει συμβεί ακόμα.

554
00:27:13,870 --> 00:27:18,250
Οπότε ας προχωρήσει και κάντε κλικ στο Βήμα Πάνω.

555
00:27:18,250 --> 00:27:20,326
Τώρα προτροπή μου, πράγματι,
άλλαξε σε ( "η είναι:").

556
00:27:20,326 --> 00:27:22,450
Τώρα get_int, εγώ δεν πάω
να ενοχλεί αναβάθμιση σε,

557
00:27:22,450 --> 00:27:24,750
γιατί αυτή η λειτουργία ήταν
από CS50 στη Βιβλιοθήκη.

558
00:27:24,750 --> 00:27:25,750
Είναι πιθανώς σωστό.

559
00:27:25,750 --> 00:27:28,440
>> Έτσι, Πάω να πάει μπροστά και να
είδος συνεργάζονται δίνοντάς

560
00:27:28,440 --> 00:27:30,590
ένας int, αλλά δεν είναι αρνητικά int.

561
00:27:30,590 --> 00:27:32,870
Επιτρέψτε μου λοιπόν να προχωρήσει και να χτυπήσει 0.

562
00:27:32,870 --> 00:27:39,460
Και τώρα τι θα συμβεί εδώ
όταν πιάσουμε γραμμή 21;

563
00:27:39,460 --> 00:27:40,890
Δεν έχω επαναληφθεί ξανά.

564
00:27:40,890 --> 00:27:43,320
Δεν φαίνεται να έχει κολλήσει στην εν λόγω βρόχο.

565
00:27:43,320 --> 00:27:45,990
Με άλλα λόγια, αυτό το κίτρινο
μπαρ δεν συνεχίζω γύρω,

566
00:27:45,990 --> 00:27:47,130
και γύρω και γύρω.

567
00:27:47,130 --> 00:27:48,340
>> Τώρα, γιατί είναι αυτό;

568
00:27:48,340 --> 00:27:49,920
Λοιπόν, n, τι n τώρα;

569
00:27:49,920 --> 00:27:53,280
Μπορώ να δούμε σε τοπικό
μεταβλητές στο πρόγραμμα εντοπισμού σφαλμάτων.

570
00:27:53,280 --> 00:27:53,816
η είναι μηδέν.

571
00:27:53,816 --> 00:27:55,190
Εντάξει, ποια ήταν η κατάστασή μου;

572
00:27:55,190 --> 00:27:58,700
>> 20-- γραμμή 20 είναι, επίσης,
0 είναι μεγαλύτερη από 0.

573
00:27:58,700 --> 00:27:59,500
Αυτό δεν είναι αλήθεια.

574
00:27:59,500 --> 00:28:01,020
0 δεν είναι μεγαλύτερο από μηδέν.

575
00:28:01,020 --> 00:28:02,820
Και γι 'αυτό έσπασε έξω από αυτό.

576
00:28:02,820 --> 00:28:06,370
>> Και έτσι γι 'αυτό στη γραμμή
21, αν μπορώ πραγματικά να συνεχίσει,

577
00:28:06,370 --> 00:28:10,370
Πάω να επιστρέψει 0, ακόμη και
αν και θα έπρεπε να απορριφθεί 0

578
00:28:10,370 --> 00:28:12,484
καθώς στην πραγματικότητα δεν είναι αρνητική.

579
00:28:12,484 --> 00:28:14,650
Έτσι τώρα, δεν το κάνω πραγματικά ακόμη
νοιάζονται για το πρόγραμμα εντοπισμού σφαλμάτων.

580
00:28:14,650 --> 00:28:16,900
Πήρε αυτό, δεν χρειάζεται να
ξέρετε τι περισσότερο γίνεται.

581
00:28:16,900 --> 00:28:19,233
>> Έτσι, Πάω να πάει μπροστά και να
απλά κάντε κλικ στο κουμπί Αναπαραγωγή,

582
00:28:19,233 --> 00:28:20,240
και αφήστε αυτό το φινίρισμα up.

583
00:28:20,240 --> 00:28:23,440
Τώρα, έχω συνειδητοποιήσει ότι μου
bug είναι προφανώς στη γραμμή 20.

584
00:28:23,440 --> 00:28:25,160
Αυτό είναι λογικό λάθος μου.

585
00:28:25,160 --> 00:28:28,100
>> Και έτσι ό, τι θέλω
να κάνουμε για να το αλλάξουμε αυτό;

586
00:28:28,100 --> 00:28:32,500
Αν το πρόβλημα είναι ότι δεν είμαι
αλίευση 0, είναι απλώς ένα λογικό σφάλμα.

587
00:28:32,500 --> 00:28:35,910
Και μπορώ να πω, ενώ n είναι
μεγαλύτερο ή ίσο με 0,

588
00:28:35,910 --> 00:28:38,330
κρατήσει προτρέποντας ξανά και ξανά από το χρήστη.

589
00:28:38,330 --> 00:28:41,050
>> Έτσι, και πάλι, απλό λάθος, ίσως
ακόμη και προφανής όταν με είδε

590
00:28:41,050 --> 00:28:42,410
γράψτε μόλις πριν από λίγα λεπτά.

591
00:28:42,410 --> 00:28:44,570
Αλλά το πακέτο εδώ
είναι ότι με debug 50,

592
00:28:44,570 --> 00:28:46,850
και με τον εντοπισμό σφαλμάτων
λογισμικό γενικότερα,

593
00:28:46,850 --> 00:28:51,370
Έχετε αυτό το νέο βρέθηκαν εξουσία
με τα πόδια μέσα από το δικό σας κώδικα, δείτε

594
00:28:51,370 --> 00:28:55,590
μέσω του εν λόγω δικαιώματος πάνελ χέρι τι
μεταβλητές τιμές σας είναι.

595
00:28:55,590 --> 00:28:57,700
Έτσι δεν κάνουν απαραίτητα
πρέπει να χρησιμοποιήσετε κάτι

596
00:28:57,700 --> 00:29:00,630
όπως σας eprintf να εκτυπώσετε αυτές τις αξίες.

597
00:29:00,630 --> 00:29:04,430
Μπορείτε να δείτε πραγματικά τους
οπτικά στην οθόνη.

598
00:29:04,430 --> 00:29:08,920
>> Τώρα, πέρα ​​από αυτό, αξίζει να σημειωθεί
ότι υπάρχει μια άλλη τεχνική που είναι

599
00:29:08,920 --> 00:29:09,890
πραγματικά σούπερ κοινό.

600
00:29:09,890 --> 00:29:13,120
Και ίσως να αναρωτηθούμε γιατί αυτό το μικρό
τύπος εδώ έχει καθίσει στη σκηνή.

601
00:29:13,120 --> 00:29:16,490
Έτσι, υπάρχει η τεχνική αυτή, σε γενικές γραμμές
γνωστή ως πάπια καουτσούκ εντοπισμό σφαλμάτων,

602
00:29:16,490 --> 00:29:18,786
το οποίο είναι πραγματικά ακριβώς ένα
απόδειξη για το γεγονός

603
00:29:18,786 --> 00:29:20,660
ότι συχνά, όταν οι προγραμματιστές
γράφουν κώδικα,

604
00:29:20,660 --> 00:29:22,650
δεν είναι κατ 'ανάγκην
συνεργάζεται με τους άλλους,

605
00:29:22,650 --> 00:29:24,030
ή εργάζονται σε ένα κοινό περιβάλλον.

606
00:29:24,030 --> 00:29:25,050
>> Είναι το είδος του στο σπίτι.

607
00:29:25,050 --> 00:29:25,910
Ίσως είναι αργά το βράδυ.

608
00:29:25,910 --> 00:29:28,190
Προσπαθούν να φιγούρα
από κάποιο bug στον κώδικα τους.

609
00:29:28,190 --> 00:29:29,330
Και από όπου και αν απλά δεν το βλέπουμε.

610
00:29:29,330 --> 00:29:30,329
>> Και δεν υπάρχει συγκάτοικο.

611
00:29:30,329 --> 00:29:31,250
Δεν υπάρχει TF.

612
00:29:31,250 --> 00:29:32,680
Δεν υπάρχει CA γύρω.

613
00:29:32,680 --> 00:29:36,440
Το μόνο που έχουν στο ράφι τους
Είναι αυτό το μικρό ducky καουτσούκ.

614
00:29:36,440 --> 00:29:39,030
>> Και έτσι debugging πάπια καουτσούκ
Είναι ακριβώς αυτή η πρόσκληση

615
00:29:39,030 --> 00:29:42,780
να σκεφτεί κάτι τόσο ανόητο
όπως αυτό ως ένα πραγματικό πλάσμα,

616
00:29:42,780 --> 00:29:46,940
και στην πραγματικότητα τα πόδια μέσα από τον κωδικό σας
προφορικά σε αυτό το άψυχο αντικείμενο.

617
00:29:46,940 --> 00:29:49,230
Έτσι, για παράδειγμα, αν
αυτό είναι το παράδειγμά μου here--

618
00:29:49,230 --> 00:29:52,470
και υπενθυμίζουν ότι νωρίτερα
το πρόβλημα ήταν αυτό,

619
00:29:52,470 --> 00:29:58,140
αν μπορώ να διαγράψω αυτό το πρώτη γραμμή του κώδικα,
και να πάω μπροστά και να κάνουν λάθη 0 και πάλι,

620
00:29:58,140 --> 00:30:01,220
Υπενθυμίζουμε ότι είχα αυτά
μηνύματα λάθους εδώ.

621
00:30:01,220 --> 00:30:05,997
Έτσι, η ιδέα εδώ, γελοίο κι αν
αισθάνονται αυτή τη στιγμή να γίνει αυτό δημοσίως,

622
00:30:05,997 --> 00:30:06,580
είναι ότι το σφάλμα.

623
00:30:06,580 --> 00:30:10,910
>> Εντάξει, έτσι το πρόβλημά μου είναι ότι έχω
δηλώνεται σιωπηρά μια λειτουργία βιβλιοθήκης.

624
00:30:10,910 --> 00:30:12,610
Και ότι η λειτουργία της βιβλιοθήκης είναι printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- ΟΚ, δηλώνουν
μου θυμίζει πρωτοτύπων.

626
00:30:15,290 --> 00:30:18,930
>> Αυτό σημαίνει ότι πρέπει πραγματικά να
πουν τον compiler σε εκ των προτέρων τι

627
00:30:18,930 --> 00:30:19,980
η λειτουργία μοιάζει.

628
00:30:19,980 --> 00:30:20,930
Περίμενε ένα λεπτό.

629
00:30:20,930 --> 00:30:23,580
Δεν είχα πρότυπο io.h.

630
00:30:23,580 --> 00:30:24,530
Ευχαριστώ πολύ.

631
00:30:24,530 --> 00:30:27,330
>> Έτσι ακριβώς αυτή η διαδικασία τον αριθμό τους θα
Δεν χρειάζεται να έχουμε πραγματικά μια πάπια.

632
00:30:27,330 --> 00:30:29,819
Αλλά αυτή η ιδέα του περπατήματος
τον εαυτό σας μέσα από τον δικό σας κώδικα

633
00:30:29,819 --> 00:30:31,610
έτσι ώστε να μπορείτε ακόμα να ακούσετε
τον εαυτό σας, έτσι ώστε να

634
00:30:31,610 --> 00:30:35,620
συνειδητοποιήσουν παραλείψεις στη δική σας
παρατηρήσεις, είναι γενικά η ιδέα.

635
00:30:35,620 --> 00:30:38,910
>> Και, ίσως πιο λογικά, δεν είναι τόσο
πολύ με εκείνο το ένα, αλλά το πιο ενεργά

636
00:30:38,910 --> 00:30:44,220
παράδειγμα που μόλις έκανε στο αμαξάκι 3.γ,
μπορείτε να περπατήσετε τον εαυτό σας μέσα από αυτό

637
00:30:44,220 --> 00:30:45,310
ως εξής.

638
00:30:45,310 --> 00:30:49,190
Έτσι, εντάξει, καουτσούκ
ducky, DDB, αν θέλετε.

639
00:30:49,190 --> 00:30:52,350
Εδώ έχουμε στην κύρια λειτουργία μου,
Είμαι καλώντας πάρει αρνητική int.

640
00:30:52,350 --> 00:30:54,660
>> Και έχω πάρει την τιμή επιστροφής.

641
00:30:54,660 --> 00:31:00,410
Είμαι αυτό που αποθηκεύει στην αριστερή πλευρά
στη γραμμή 8 σε μια μεταβλητή που ονομάζεται i.

642
00:31:00,410 --> 00:31:02,380
ΟΚ, αλλά περιμένετε, πώς το έκανε
ότι έχετε αυτή την τιμή;

643
00:31:02,380 --> 00:31:04,130
Επιτρέψτε μου να δούμε τη λειτουργία στη γραμμή 12.

644
00:31:04,130 --> 00:31:05,760
>> Στη γραμμή 12, έχουμε πάρει αρνητική int.

645
00:31:05,760 --> 00:31:08,190
δεν λαμβάνει εισόδους,
δεν επιστρέψει ένα int, ΟΚ.

646
00:31:08,190 --> 00:31:10,929
Δηλώνω στη γραμμή 14 μια μεταβλητή n.

647
00:31:10,929 --> 00:31:12,220
Είναι πρόκειται να αποθηκεύσει έναν ακέραιο.

648
00:31:12,220 --> 00:31:13,760
Αυτό θέλω.

649
00:31:13,760 --> 00:31:18,480
>> Έτσι κάνετε το εξής, ενώ n is-- ας
Θέλω να αναιρέσετε ό, τι η λύση που έχει ήδη γίνει.

650
00:31:18,480 --> 00:31:22,710
Έτσι, ενώ το η είναι μεγαλύτερο από
0, εκτυπώστε Ν, OK.

651
00:31:22,710 --> 00:31:25,170
Και στη συνέχεια να καλέσει να int αποθηκεύονται σε n.

652
00:31:25,170 --> 00:31:30,160
Και στη συνέχεια, ελέγξτε αν το n είναι 0,
n είναι not-- εκεί είναι.

653
00:31:30,160 --> 00:31:31,910
Έτσι, και πάλι, δεν το κάνετε
χρειάζεται την πραγματική πάπια.

654
00:31:31,910 --> 00:31:35,650
Αλλά απλά περπατώντας τον εαυτό σας μέσα από
κωδικό σας ως μια πνευματική άσκηση

655
00:31:35,650 --> 00:31:37,720
θα σας βοηθήσει συχνά
συνειδητοποιήσει τι συμβαίνει,

656
00:31:37,720 --> 00:31:41,170
σε αντιδιαστολή με ακριβώς να κάνει κάτι
όπως αυτό, κοιτάζοντας την οθόνη,

657
00:31:41,170 --> 00:31:43,720
και δεν μιλάμε εαυτό σας μέσα
αυτό, η οποία ειλικρινά δεν είναι

658
00:31:43,720 --> 00:31:46,270
σχεδόν ως μια αποτελεσματική τεχνική.

659
00:31:46,270 --> 00:31:48,620
Έτσι εκεί το έχετε, ένα
αριθμός διαφορετικών τεχνικών

660
00:31:48,620 --> 00:31:52,102
για πραγματικά τον εντοπισμό σφαλμάτων κώδικα σας
και εύρεση σφαλμάτων, τα οποία όλα

661
00:31:52,102 --> 00:31:54,810
θα πρέπει να είναι τα εργαλεία στην εργαλειοθήκη σας
έτσι ώστε να μην είστε αργά το βράδυ,

662
00:31:54,810 --> 00:31:57,660
ειδικά, είστε στην τραπεζαρία
αίθουσες ή σε ώρες γραφείου,

663
00:31:57,660 --> 00:32:00,368
χτυπάς το κεφάλι σου στον
τοίχο, προσπαθεί να λύσει κάποιο πρόβλημα.

664
00:32:00,368 --> 00:32:02,020
Συνειδητοποιήστε ότι υπάρχουν εργαλεία λογισμικού.

665
00:32:02,020 --> 00:32:03,720
Υπάρχουν λαστιχένια εργαλεία πάπια.

666
00:32:03,720 --> 00:32:09,630
Και υπάρχει ένα σύνολο του προσωπικού της
υποστήριξη που περιμένουν να δώσει μια χείρα βοηθείας.

667
00:32:09,630 --> 00:32:13,120
>> Έτσι τώρα, μια λέξη σχετικά με το πρόβλημα
σύνολα, και σε ό, τι είμαστε εσείς που ελπίζετε

668
00:32:13,120 --> 00:32:15,620
βγούμε από αυτά, και πώς
πάμε για την αξιολόγηση.

669
00:32:15,620 --> 00:32:17,680
Ανά εξεταστέα ύλη του μαθήματος,
πρόβλημα σύνολα CS50 του

670
00:32:17,680 --> 00:32:22,320
αξιολογούνται σε τέσσερις βασικούς άξονες, έτσι
να speak-- πεδίο εφαρμογής, την ορθότητα, το σχεδιασμό,

671
00:32:22,320 --> 00:32:23,060
και το στυλ.

672
00:32:23,060 --> 00:32:25,910
Και το πεδίο εφαρμογής αναφέρεται ακριβώς στο πόσο
του κομματιού έχετε δαγκώσει μακριά;

673
00:32:25,910 --> 00:32:28,080
Πόσο μεγάλο πρόβλημα έχετε δοκιμάσει;

674
00:32:28,080 --> 00:32:30,110
Τι επίπεδο προσπάθειας
έχετε εκδηλώνεται;

675
00:32:30,110 --> 00:32:35,750
>> Ορθότητα είναι, κάνει τη δουλειά του προγράμματος ως
που υποτίθεται ότι ανά προδιαγραφή CS50

676
00:32:35,750 --> 00:32:38,640
όταν παρέχουν ορισμένες εισόδους
ή ορισμένα αποτελέσματα που έρχονται πίσω;

677
00:32:38,640 --> 00:32:41,130
Design είναι η πιο υποκειμενική από αυτούς.

678
00:32:41,130 --> 00:32:43,360
Και αυτό είναι το ένα που θα
να λάβει τη μεγαλύτερη να μάθετε

679
00:32:43,360 --> 00:32:47,220
και η μεγαλύτερη για να διδάξουν, σε
καθόσον βράζει κάτω,

680
00:32:47,220 --> 00:32:49,530
πόσο καλά γραμμένο είναι ο κωδικός σας;

681
00:32:49,530 --> 00:32:52,920
>> Είναι ένα πράγμα για να εκτυπώσετε μόνο το σωστό
εξόδους ή να επιστρέψει τις σωστές τιμές.

682
00:32:52,920 --> 00:32:55,400
Αλλά μπορείτε να το κάνετε ως
το δυνατόν πιο αποτελεσματικά;

683
00:32:55,400 --> 00:32:58,210
Είσαι το κάνει χάσματος
και να κατακτήσουν, ή δυαδική

684
00:32:58,210 --> 00:33:01,500
αναζήτησης, όπως θα δείτε σύντομα ότι κάναμε
πριν από δύο εβδομάδες με τον τηλεφωνικό κατάλογο;

685
00:33:01,500 --> 00:33:04,670
Είναι καλύτεροι τρόποι για να λύσει το εκεί
πρόβλημα από ό, τι έχετε σήμερα εδώ;

686
00:33:04,670 --> 00:33:06,380
Αυτή είναι μια ευκαιρία για καλύτερο σχεδιασμό.

687
00:33:06,380 --> 00:33:08,530
>> Και τότε style-- πώς
όμορφο είναι ο κωδικός σας;

688
00:33:08,530 --> 00:33:12,370
Θα παρατηρήσετε ότι είμαι αρκετά
Ειδικότερα για την εσοχή κωδικό μου,

689
00:33:12,370 --> 00:33:15,300
και να διασφαλίσουμε τις μεταβλητές μου
Τα εύλογα το όνομα. n,

690
00:33:15,300 --> 00:33:19,660
ενώ λίγα λόγια, είναι ένα καλό όνομα για ένα
αριθμό, i για ένα ακέραιο καταμέτρηση,

691
00:33:19,660 --> 00:33:20,727
s για ένα string.

692
00:33:20,727 --> 00:33:22,560
Και μπορούμε να έχουμε πλέον
μεταβλητό ύφος ονόματα.

693
00:33:22,560 --> 00:33:25,500
Στυλ είναι ακριβώς το πόσο καλή
φαίνεται κωδικό σας;

694
00:33:25,500 --> 00:33:26,600
Και πώς αναγνώσιμο είναι αυτό;

695
00:33:26,600 --> 00:33:29,650
>> Και την πάροδο του χρόνου, τι βοηθούς σας
και TFs θα κάνει κατά τη διάρκεια

696
00:33:29,650 --> 00:33:31,870
είναι να σας παρέχει με ότι
το είδος των ποιοτικών σχολίων

697
00:33:31,870 --> 00:33:34,330
έτσι ώστε να έχετε την καλύτερη
σε αυτές τις διάφορες πτυχές.

698
00:33:34,330 --> 00:33:37,510
Και από την άποψη του πώς μπορούμε
αξιολογεί κάθε ένα από αυτούς τους άξονες,

699
00:33:37,510 --> 00:33:40,080
είναι συνήθως με πολύ λίγα
κουβάδες έτσι ώστε να μπορείτε, σε γενικές γραμμές,

700
00:33:40,080 --> 00:33:41,680
να πάρετε μια αίσθηση του πόσο καλά κάνετε.

701
00:33:41,680 --> 00:33:45,680
Και, πράγματι, εάν λάβετε μια βαθμολογία για
οποιοδήποτε από αυτά τα axes-- ορθότητα, το σχεδιασμό

702
00:33:45,680 --> 00:33:49,659
και το στυλ especially-- ότι ο αριθμός
θα είναι γενικά μεταξύ 1 και 5.

703
00:33:49,659 --> 00:33:52,450
Και, στην κυριολεξία, αν παίρνετε
3 κατά την έναρξη του εξαμήνου,

704
00:33:52,450 --> 00:33:53,977
αυτό είναι ένα πολύ καλό πράγμα.

705
00:33:53,977 --> 00:33:55,810
Αυτό σημαίνει ότι υπάρχει ακόμα
περιθώρια βελτίωσης,

706
00:33:55,810 --> 00:33:58,490
το οποίο θα ελπίζουμε για το
λαμβάνοντας μια τάξη για πρώτη φορά.

707
00:33:58,490 --> 00:34:01,820
Υπάρχει ελπίζω κάποια κομμάτι της οροφής
στην οποία είστε φιλοδοξούν να επιτευχθεί.

708
00:34:01,820 --> 00:34:03,970
Και έτσι ώστε να πάρει στις 3 του
τα πρώτα κομμάτια,

709
00:34:03,970 --> 00:34:06,550
αν όχι μερικά 2 και 4, η
Είναι, πράγματι, ένα καλό πράγμα.

710
00:34:06,550 --> 00:34:08,880
Είναι καλά εντός εμβέλειας,
σαφώς εντός των προσδοκιών.

711
00:34:08,880 --> 00:34:11,421
>> Και αν το μυαλό σας είναι αγωνιστικά, περιμένετε
ένα λεπτό, τρία από τα πέντε.

712
00:34:11,421 --> 00:34:12,620
Αυτό είναι πραγματικά ένα 6 στα 10.

713
00:34:12,620 --> 00:34:13,560
Αυτό είναι 60%.

714
00:34:13,560 --> 00:34:14,830
Θεέ μου, που είναι ένα F.

715
00:34:14,830 --> 00:34:15,870
>> Δεν είναι.

716
00:34:15,870 --> 00:34:17,600
Δεν είναι, στην πραγματικότητα, ότι.

717
00:34:17,600 --> 00:34:22,710
Μάλλον, είναι μια ευκαιρία για τη βελτίωση της
κατά τη διάρκεια του εξαμήνου.

718
00:34:22,710 --> 00:34:25,580
Και αν παίρνετε κάποια
Poors, αυτά είναι μια ευκαιρία

719
00:34:25,580 --> 00:34:29,199
να επωφεληθούν από τις ώρες γραφείου,
Σίγουρα τμήματα και άλλους πόρους.

720
00:34:29,199 --> 00:34:32,840
>> Καλύτερη είναι μια ευκαιρία, πραγματικά,
να είμαστε υπερήφανοι για το πόσο μακριά έχετε

721
00:34:32,840 --> 00:34:34,520
έρχονται κατά τη διάρκεια του εξαμήνου.

722
00:34:34,520 --> 00:34:38,199
Έτσι αντιλαμβάνονται, αν δεν
άλλο, τρεις είναι καλό.

723
00:34:38,199 --> 00:34:40,179
Και επιτρέπει χώρο για την ανάπτυξη την πάροδο του χρόνου.

724
00:34:40,179 --> 00:34:43,090
>> Όσο για το πώς είναι αυτές οι άξονες
σταθμισμένο, ρεαλιστικά είστε

725
00:34:43,090 --> 00:34:46,745
πρόκειται να περνούν τον περισσότερο χρόνο σας να πάρει
τα πράγματα στη δουλειά, πόσο σωστά μόνο.

726
00:34:46,745 --> 00:34:49,120
Και έτσι ορθότητα τείνει να
να σταθμίζεται το πιο, όπως με

727
00:34:49,120 --> 00:34:51,360
Αυτό πολλαπλασιαστικός συντελεστής των τριών.

728
00:34:51,360 --> 00:34:54,659
Σχεδιασμός είναι επίσης σημαντική, αλλά
κάτι που δεν κάνουν απαραίτητα

729
00:34:54,659 --> 00:34:58,220
ξοδεύουν όλα αυτά τα ωρών για
προσπαθεί να πάρει τα πράγματα απλά για να εργαστούν.

730
00:34:58,220 --> 00:35:00,019
>> Και γι 'αυτό σταθμίζεται
λίγο πιο ελαφριά.

731
00:35:00,019 --> 00:35:01,560
Και τότε το στυλ σταθμίζεται το λιγότερο.

732
00:35:01,560 --> 00:35:03,710
Ακόμα κι αν δεν είναι λιγότερο είναι
σημαντικό ριζικά,

733
00:35:03,710 --> 00:35:05,990
είναι απλά, ίσως, η
πιο εύκολο πράγμα να κάνουμε το σωστό,

734
00:35:05,990 --> 00:35:08,440
μιμούνται τα παραδείγματα που
κάνετε σε διάλεξη και ενότητα,

735
00:35:08,440 --> 00:35:11,080
με τα πράγματα όμορφα
εσοχή, και σχολίασε,

736
00:35:11,080 --> 00:35:14,320
και ούτω καθεξής είναι μεταξύ των πιο εύκολος
πράγματα να κάνουμε και να πάρει το δικαίωμα.

737
00:35:14,320 --> 00:35:16,960
Έτσι ως τέτοια, συνειδητοποιούν
ότι αυτά είναι τα σημεία

738
00:35:16,960 --> 00:35:19,000
που είναι σχετικά εύκολο να γίνει αντιληπτό.

739
00:35:19,000 --> 00:35:22,360
>> Και τώρα μια λέξη για
this-- ακαδημαϊκή ειλικρίνεια.

740
00:35:22,360 --> 00:35:25,150
Έτσι, σύμφωνα με την πορεία του
διδακτέα ύλη, θα δείτε

741
00:35:25,150 --> 00:35:27,630
ότι το μάθημα έχει ένα αρκετά
κομμάτι της γλώσσας γύρω από αυτό.

742
00:35:27,630 --> 00:35:31,380
Και η πορεία παίρνει το θέμα της
ακαδημαϊκή ειλικρίνεια αρκετά σοβαρά.

743
00:35:31,380 --> 00:35:33,450
>> Έχουμε τη διάκριση,
προς το καλύτερο ή προς το χειρότερο,

744
00:35:33,450 --> 00:35:36,570
ότι έστειλε κάθε χρόνο περισσότερα
μαθητές για πειθαρχικά μέτρα

745
00:35:36,570 --> 00:35:39,670
από ό, τι οι περισσότεροι κάθε άλλο
Φυσικά, ότι είμαι γνωρίζει.

746
00:35:39,670 --> 00:35:42,580
Αυτό δεν είναι απαραίτητα
ενδεικτικό του γεγονότος

747
00:35:42,580 --> 00:35:46,340
ότι CS φοιτητές, ή CS50 μαθητές, είναι
λιγότερο ειλικρινής από τους συμμαθητές σας.

748
00:35:46,340 --> 00:35:49,090
Αλλά η πραγματικότητα ότι σε αυτό το
κόσμο, ηλεκτρονικά, εμείς απλά

749
00:35:49,090 --> 00:35:50,990
έχουν τεχνολογική
μέσο για την ανίχνευση αυτή.

750
00:35:50,990 --> 00:35:53,360
>> Είναι σημαντικό για εμάς για
δικαιοσύνη σε όλη την τάξη

751
00:35:53,360 --> 00:35:58,550
ότι κάνουμε το εντοπίσει, και να αυξήσει
το θέμα, όταν βλέπουμε τα πράγματα.

752
00:35:58,550 --> 00:36:01,980
Και ακριβώς για να ζωγραφίσει μια εικόνα, και πραγματικά
για να βοηθήσει κάτι σαν αυτό το νεροχύτη,

753
00:36:01,980 --> 00:36:04,600
αυτοί είναι οι αριθμοί των
οι μαθητές κατά τη διάρκεια των τελευταίων 10 ετών

754
00:36:04,600 --> 00:36:07,610
που έχουν εμπλακεί σε ορισμένες
τέτοια ζητήματα της ακαδημαϊκής δεοντολογίας,

755
00:36:07,610 --> 00:36:10,990
με κάποιες 32 μαθητές
από το φθινόπωρο του 2015, η οποία

756
00:36:10,990 --> 00:36:13,760
είναι να πούμε ότι δεν λαμβάνουν
το θέμα πολύ σοβαρά.

757
00:36:13,760 --> 00:36:18,380
Και, τελικά, αυτοί οι αριθμοί συνθέτουν,
πιο πρόσφατα, περίπου 3%, 4% ή έτσι

758
00:36:18,380 --> 00:36:19,120
της κατηγορίας.

759
00:36:19,120 --> 00:36:25,220
>> Έτσι, για το σούπερ πλειοψηφία των φοιτητών
φαίνεται ότι οι γραμμές είναι σαφείς.

760
00:36:25,220 --> 00:36:27,940
Αλλά κρατήσει αυτό
νου, ιδιαίτερα αργά

761
00:36:27,940 --> 00:36:32,080
τη νύχτα, όταν αγωνίζεται με
κάποια λύση σε ένα σύνολο το πρόβλημα,

762
00:36:32,080 --> 00:36:34,830
ότι υπάρχουν μηχανισμοί
για να πάρει τον εαυτό σας καλύτερα

763
00:36:34,830 --> 00:36:37,870
υποστήριξη από ό, τι θα μπορούσε
σκέφτονται, ακόμα και εκείνη την ώρα.

764
00:36:37,870 --> 00:36:40,514
Συνειδητοποιήστε ότι όταν λάβουμε
υποβολές των σπουδαστών, διασχίζουμε

765
00:36:40,514 --> 00:36:43,430
συγκρίνουν κάθε υποβολή του τρέχοντος έτους
ενάντια σε κάθε κατάθεση το περασμένο έτος,

766
00:36:43,430 --> 00:36:47,590
ενάντια σε κάθε κατάθεση από το 2007,
και δεδομένου ότι, κοιτάζοντας, καθώς και,

767
00:36:47,590 --> 00:36:49,931
Κωδικός αποθετήρια σε απευθείας σύνδεση,
φόρουμ συζητήσεων, χώρους εργασίας.

768
00:36:49,931 --> 00:36:51,806
Και εμείς αναφέρουμε αυτό,
Πραγματικά, όλα για χάρη

769
00:36:51,806 --> 00:36:56,040
της πλήρους αποκάλυψης, ότι αν
κάποιος άλλος μπορεί να το βρείτε online,

770
00:36:56,040 --> 00:36:57,880
Σίγουρα, οπότε μπορούμε να κάνουμε το μάθημα.

771
00:36:57,880 --> 00:37:00,100
Αλλά, πραγματικά, το πνεύμα
από το μάθημα βράζει κάτω

772
00:37:00,100 --> 00:37:01,650
με τη ρήτρα αυτή στην εξεταστέα ύλη.

773
00:37:01,650 --> 00:37:03,670
Είναι πραγματικά είναι απλά, είναι λογικό.

774
00:37:03,670 --> 00:37:06,680
>> Και αν έπρεπε να αναπτύξω ότι
με μόνο ένα λίγο πιο γλώσσας,

775
00:37:06,680 --> 00:37:09,770
συνειδητοποιούν ότι η ουσία όλων
εργασία που υποβάλλετε σε αυτό το μάθημα

776
00:37:09,770 --> 00:37:10,954
πρέπει να είναι δική σας.

777
00:37:10,954 --> 00:37:13,870
Αλλά μέσα σε αυτό, υπάρχουν σίγουρα
ευκαιρίες, και την ενθάρρυνση,

778
00:37:13,870 --> 00:37:17,300
και παιδαγωγική αξία στρέφονται προς
others-- τον εαυτό μου, η ΤΡ, η ΑΠ,

779
00:37:17,300 --> 00:37:20,760
οι τεχνικοί βοηθοί, και άλλους στην τάξη,
για την υποστήριξη, πόσο μάλλον τους φίλους

780
00:37:20,760 --> 00:37:23,547
και συγκάτοικοι που έχουν μελετηθεί
CS και τον προγραμματισμό πριν.

781
00:37:23,547 --> 00:37:25,130
Και έτσι υπάρχει μια αποζημίωση για αυτό.

782
00:37:25,130 --> 00:37:28,180
Και ο γενικός κανόνας του αντίχειρα
είναι this-- όταν ζητούν βοήθεια,

783
00:37:28,180 --> 00:37:31,470
μπορεί να δείξει τον κωδικό σας σε άλλους,
αλλά δεν μπορείτε να δείτε τις δικές τους.

784
00:37:31,470 --> 00:37:34,880
Έτσι, ακόμη και αν είστε σε ώρες γραφείου,
ή στην αίθουσα D, ή κάπου αλλού

785
00:37:34,880 --> 00:37:37,450
εργάζονται πάνω σε κάποια σετ κομμάτι,
που εργάζονται μαζί με μια φίλη, η οποία

786
00:37:37,450 --> 00:37:40,160
είναι εντελώς καλά, κατά τη
τέλος της ημέρας εργασίας σας

787
00:37:40,160 --> 00:37:43,034
θα πρέπει τελικά να ανήκουν σε κάθε
από εσάς, αντίστοιχα, και όχι

788
00:37:43,034 --> 00:37:45,700
είναι κάποια συλλογική προσπάθεια,
εκτός από το τελικό σχέδιο στο οποίο

789
00:37:45,700 --> 00:37:47,410
αυτό είναι επιτρέπεται και ενθαρρύνεται.

790
00:37:47,410 --> 00:37:49,830
>> Συνειδητοποιήστε ότι αν είστε
παλεύουν με κάτι

791
00:37:49,830 --> 00:37:52,520
και ο φίλος σας συμβαίνει ακριβώς
να είναι καλύτερα σε αυτό, τότε,

792
00:37:52,520 --> 00:37:55,130
ή καλύτερα σε αυτό το πρόβλημα από ό, τι μπορείτε,
ή λίγο μακρύτερα μπροστά από εσάς,

793
00:37:55,130 --> 00:37:57,330
είναι εντελώς λογικό να μετατρέψει
στο φίλο σας και να πω, hey,

794
00:37:57,330 --> 00:38:00,480
Σας πειράζει κοιτάζοντας τον κωδικό μου εδώ,
με βοήθησαν εντοπίσετε αυτό το θέμα μου;

795
00:38:00,480 --> 00:38:03,760
Και, ελπίζω, στην
ενδιαφέρον της παιδαγωγικής αξίας

796
00:38:03,760 --> 00:38:07,040
ότι ο φίλος κάνει όχι μόνο
λένε, ω, να το κάνετε αυτό, αλλά μάλλον,

797
00:38:07,040 --> 00:38:09,917
τι λείπει on line
6, ή κάτι τέτοιο;

798
00:38:09,917 --> 00:38:12,000
Αλλά η λύση δεν είναι
για το φίλο δίπλα σας

799
00:38:12,000 --> 00:38:15,617
να πει, OH, καλά, εδώ, επιτρέψτε μου να τραβήξει
αυτό επάνω, και να δείξει λύση μου σε εσάς.

800
00:38:15,617 --> 00:38:16,450
Έτσι ώστε να είναι η γραμμή.

801
00:38:16,450 --> 00:38:18,670
Σας δείξει τον κωδικό σας
τους άλλους, αλλά δεν μπορείτε να

802
00:38:18,670 --> 00:38:22,350
δείτε το δικό τους, υπόκεινται σε άλλη
περιορισμούς στην εξεταστέα ύλη του μαθήματος.

803
00:38:22,350 --> 00:38:24,760
>> Έτσι, να έχετε κατά νου αυτό το
λεγόμενη ρήτρα λύπη

804
00:38:24,760 --> 00:38:27,560
στη διδακτέα ύλη του μαθήματος, καθώς και,
ότι αν διαπράξουν κάποια πράξη ότι

805
00:38:27,560 --> 00:38:30,476
Δεν είναι λογικό, αλλά να το φέρει σε
η προσοχή των προϊσταμένων του μαθήματος

806
00:38:30,476 --> 00:38:34,240
εντός 72 ωρών, η πορεία
δύνανται να επιβάλλουν τοπικές κυρώσεις που θα

807
00:38:34,240 --> 00:38:37,380
μπορεί να περιλαμβάνει ένα μη ικανοποιητικό ή
ελλείψει βαθμού για το έργο που υποβλήθηκε.

808
00:38:37,380 --> 00:38:41,410
Αλλά η πορεία δεν θα παραπέμψει την
σημασία για την περαιτέρω πειθαρχικά μέτρα,

809
00:38:41,410 --> 00:38:43,010
εκτός από τις περιπτώσεις επανειλημμένων πράξεων.

810
00:38:43,010 --> 00:38:46,632
Με άλλα λόγια, αν κάνουν κάποια
ηλίθιο, ειδικά αργά τη νύχτα, η απόφαση

811
00:38:46,632 --> 00:38:49,340
ότι το επόμενο πρωί με δύο μέρες
αργότερα, ξυπνάς και να συνειδητοποιήσουν,

812
00:38:49,340 --> 00:38:50,870
τι σκεφτόμουν;

813
00:38:50,870 --> 00:38:53,890
Μπορείτε να το κάνετε σε CS50 έχει μια έξοδο
για τον καθορισμό αυτό το πρόβλημα

814
00:38:53,890 --> 00:38:57,170
και η ιδιοκτησία σε αυτό, έτσι ώστε να
θα σας συναντήσει στα μισά του δρόμου και την αντιμετώπιση

815
00:38:57,170 --> 00:39:01,500
με αυτό σε ένα θέμα που είναι τόσο
εκπαιδευτικές και πολύτιμη για εσάς,

816
00:39:01,500 --> 00:39:04,200
αλλά εξακολουθεί να τιμωρητική με κάποιο τρόπο.

817
00:39:04,200 --> 00:39:08,590
Και τώρα, για να λάβει την άκρη μακριά, αυτό.

818
00:39:08,590 --> 00:39:10,570
>> [ΑΝΑΠΑΡΑΓΩΓΉ ΒΊΝΤΕΟ]

819
00:39:10,570 --> 00:39:13,540
>> [ΜΟΥΣΙΚΗ Playing]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [ΤΕΛΟΣ ΑΝΑΠΑΡΑΓΩΓΗ]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Malan: Εντάξει, είμαστε πίσω.

823
00:40:00,490 --> 00:40:03,680
Και τώρα θα δούμε σε ένα από τα
πρώτη του πραγματικού κόσμου τομείς μας

824
00:40:03,680 --> 00:40:08,720
σε CS50, η τέχνη της κρυπτογραφίας,
η τέχνη της αποστολής και λήψης

825
00:40:08,720 --> 00:40:11,840
μυστικά μηνύματα, κρυπτογραφημένα
μηνύματα, αν θέλετε,

826
00:40:11,840 --> 00:40:17,060
ότι μπορεί να αποκρυπτογραφηθεί μόνο εάν έχετε
κάποια βασικό συστατικό ότι ο αποστολέας έχει

827
00:40:17,060 --> 00:40:18,030
επίσης.

828
00:40:18,030 --> 00:40:22,120
Έτσι για να παρακινήσει αυτό θα ρίξουμε
μια ματιά σε αυτό το πράγμα εδώ,

829
00:40:22,120 --> 00:40:26,750
το οποίο είναι ένα παράδειγμα ενός
μυστικό δαχτυλίδι αποκωδικοποιητή ότι

830
00:40:26,750 --> 00:40:34,042
μπορεί να χρησιμοποιηθεί για να καταλάβω
ό, τι ένα μυστικό μήνυμα είναι στην πραγματικότητα.

831
00:40:34,042 --> 00:40:35,750
Στην πραγματικότητα, πίσω στο
μέρα στο σχολείο βαθμού,

832
00:40:35,750 --> 00:40:38,787
αν στείλει ποτέ μυστικό μηνύματα σε
κάποιος φίλος ή κάποιο φλερτ στην τάξη,

833
00:40:38,787 --> 00:40:40,620
μπορεί να έχετε σκεφτεί
ήσουν είσαι έξυπνος

834
00:40:40,620 --> 00:40:46,530
από το κομμάτι σας χαρτί αλλαγή,
όπως, το Α στο Β, και Β σε C και C έως D,

835
00:40:46,530 --> 00:40:47,590
και ούτω καθεξής.

836
00:40:47,590 --> 00:40:50,300
Αλλά θα ήταν πραγματικά κρυπτογράφηση
τις πληροφορίες σας, ακόμα και

837
00:40:50,300 --> 00:40:53,300
αν ήταν λίγο ασήμαντο, δεν ήταν
ότι σκληρά για το δάσκαλο να συνειδητοποιήσει,

838
00:40:53,300 --> 00:40:55,675
καλά, αν απλά αλλάξετε
Β σε Α και Γ στο Β,

839
00:40:55,675 --> 00:40:57,550
μπορείτε πραγματικά να καταλάβω
ποιο είναι το μήνυμα ήταν,

840
00:40:57,550 --> 00:40:59,700
αλλά θα ήταν σε κρυπτογραφήσεως πληροφορίες.

841
00:40:59,700 --> 00:41:03,420
>> Ήσουν απλά να κάνει
απλά, σαν Ralphie εδώ

842
00:41:03,420 --> 00:41:07,934
σε μια διάσημη ταινία που παίζει
λίγο πολύ nauseum ad κάθε χειμώνα.

843
00:41:07,934 --> 00:41:08,600
[ΑΝΑΠΑΡΑΓΩΓΉ ΒΊΝΤΕΟ]

844
00:41:08,600 --> 00:41:11,180
-Να Είναι γνωστό σε όλους ότι
Ralph Parker είναι παρόν

845
00:41:11,180 --> 00:41:14,070
τακτικό μέλος της Μικρής
Τα ορφανά Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
και δικαιούται να επικαλείται όλα τα τιμά
και τα οφέλη που συμβαίνουν σ 'αυτό.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
θεωρημένη Pierre Andre, με μελάνι.

848
00:41:24,340 --> 00:41:27,160
Τιμητικές διακρίσεις και τα οφέλη,
ήδη στην ηλικία των εννέα.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [ΚΡΑΥΓΈΣ]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Ελα.

853
00:41:34,250 --> 00:41:35,210
Ας προχωρήσουμε με αυτό.

854
00:41:35,210 --> 00:41:39,530
Δεν χρειάζεται όλη αυτή η τζαζ
για τους λαθρεμπόρους και τους πειρατές.

855
00:41:39,530 --> 00:41:41,660
>> Ακούστε αύριο το βράδυ για
Η περιπέτεια καταληκτική

856
00:41:41,660 --> 00:41:43,880
του μαύρο πειρατικό πλοίο.

857
00:41:43,880 --> 00:41:46,650
Τώρα, ήρθε η ώρα για
μυστικό μήνυμα της Annie

858
00:41:46,650 --> 00:41:49,840
για εσάς τα μέλη της Μυστικής Κύκλου.

859
00:41:49,840 --> 00:41:53,570
Θυμηθείτε, τα παιδιά, μόνο τα μέλη
της Annie Μυστική Κύκλος

860
00:41:53,570 --> 00:41:56,140
μπορεί να αποκωδικοποιήσει το μυστικό μήνυμα Annie του.

861
00:41:56,140 --> 00:42:00,340
>> Θυμηθείτε, η Annie είναι ανάλογα με σας.

862
00:42:00,340 --> 00:42:02,880
Ορίστε καρφίτσες σας Β2.

863
00:42:02,880 --> 00:42:05,230
Εδώ είναι το μήνυμα.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Είμαι Στην πρώτη μου μυστική συνάντηση.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Ήταν σε μεγάλη φωνή απόψε.

868
00:42:15,780 --> 00:42:19,000
Θα μπορούσα να πω ότι απόψε
μήνυμα ήταν πραγματικά σημαντικό.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, αυτό είναι ένα μήνυμα
από Annie τον εαυτό της.

870
00:42:22,694 --> 00:42:23,860
Θυμηθείτε, μην το πω σε κανέναν.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Δευτερόλεπτα αργότερα, είμαι στο μόνο
δωμάτιο του σπιτιού, όπου ένα αγόρι εννέα

873
00:42:32,930 --> 00:42:37,040
θα μπορούσε να καθίσει στην προστασία της ιδιωτικής ζωής και αποκωδικοποιήσει.

874
00:42:37,040 --> 00:42:39,730
Aha, Β!

875
00:42:39,730 --> 00:42:42,360
Πήγα στο επόμενο, Ε

876
00:42:42,360 --> 00:42:44,520
>> Η πρώτη λέξη είναι να είναι.

877
00:42:44,520 --> 00:42:49,032
S, ερχόταν πιο εύκολο τώρα, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -ΟΗ, Έλα, Ralphie, πρέπει να φύγω!

879
00:42:51,733 --> 00:42:53,688
>> -I'll Να είναι δεξιά κάτω, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee σφυρίζω!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, να είστε βέβαιος to-- να είναι σίγουρος για το τι;

883
00:43:04,060 --> 00:43:05,970
Ποια ήταν η Μικρή ορφανά
Annie προσπαθώ να πω;

884
00:43:05,970 --> 00:43:07,264
Να είστε βέβαιος για το τι;

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy έχει να
πάτε, θα σας παρακαλούμε να βγει;

886
00:43:09,634 --> 00:43:10,480
>> -Όλα Τα δεξιά, Ma!

887
00:43:10,480 --> 00:43:12,880
Θα είμαι δεξιά έξω!

888
00:43:12,880 --> 00:43:14,550
>> -I Ήταν να πάρει πιο κοντά τώρα.

889
00:43:14,550 --> 00:43:16,620
Η ένταση ήταν τρομερή.

890
00:43:16,620 --> 00:43:17,720
Τι ήταν αυτό?

891
00:43:17,720 --> 00:43:20,170
Η μοίρα του πλανήτη
μπορεί να κολλήσει στην ισορροπία.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Gotta Andy πάμε!

894
00:43:23,170 --> 00:43:26,890
>> -I'll Είναι δεξιά έξω, για να φωνάξει δυνατά!

895
00:43:26,890 --> 00:43:32,680
>> -σχεδόν Εκεί, τα δάχτυλά μου πέταξε, το μυαλό μου
Ήταν μια παγίδα χάλυβα, κάθε πόρο δονείται.

896
00:43:32,680 --> 00:43:37,198
Ήταν σχεδόν σαφές, ναι, ναι, ναι.

897
00:43:37,198 --> 00:43:43,091
>> -Να Είστε βέβαιος να πίνετε Ovaltine σας.

898
00:43:43,091 --> 00:43:43,590
Ovaltine;

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Ένας ταλαιπωρημένος εμπορικό;

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Κάθαρμα.

903
00:43:54,227 --> 00:43:54,810
[ΤΕΛΟΣ ΑΝΑΠΑΡΑΓΩΓΗ]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Malan: Εντάξει, έτσι
ότι ήταν ένα πολύ μακρύ δρόμο

905
00:43:57,390 --> 00:44:00,660
της εισαγωγής κρυπτογραφίας,
και επίσης Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Στην πραγματικότητα, από αυτό το παλιό αγγελία
εδώ, γιατί είναι Ovaltine τόσο καλό;

907
00:44:04,470 --> 00:44:09,470
Είναι μια συμπυκνωμένη εκχύλιση ώριμων
βύνη κριθαριού, καθαρό κρεμώδες αγελαδινό γάλα,

908
00:44:09,470 --> 00:44:14,360
και ειδικά παρασκευασμένα κακάο, μαζί
με φυσικό φωσφατίδια και βιταμίνες.

909
00:44:14,360 --> 00:44:18,240
Είναι επίσης εμπλουτισμένα με
πρόσθετες βιταμίνες Β και D, yum.

910
00:44:18,240 --> 00:44:21,600
Και μπορείτε να το πάρετε, προφανώς,
για την Amazon, όπως κάναμε εδώ.

911
00:44:21,600 --> 00:44:24,810
>> Αλλά το κίνητρο εδώ ήταν να
εισαγάγει κρυπτογραφία, ειδικά

912
00:44:24,810 --> 00:44:28,340
ένα είδος κρυπτογραφίας γνωστών
ως μυστικό κλειδί κρυπτογράφησης.

913
00:44:28,340 --> 00:44:34,284
Και όπως υποδηλώνει το όνομα, το σύνολο
ασφάλεια από ένα μυστικό κλειδί του συστήματος κρυπτογραφίας,

914
00:44:34,284 --> 00:44:36,200
αν θέλετε, μια μεθοδολογία
για μόλις κρυπτογράφησης

915
00:44:36,200 --> 00:44:40,960
πληροφοριών μεταξύ δύο ανθρώπων, είναι ότι
μόνο ο αποστολέας και ο παραλήπτης μόνο

916
00:44:40,960 --> 00:44:46,980
ξέρετε ένα μυστικό key-- κάποια αξία, μερικά
μυστική φράση, κάποιο μυστικό αριθμό, ότι

917
00:44:46,980 --> 00:44:50,660
τους επιτρέπει τόσο για την κρυπτογράφηση
και την αποκρυπτογράφηση των πληροφοριών.

918
00:44:50,660 --> 00:44:53,470
Και κρυπτογραφία, πραγματικά,
Είναι ακριβώς αυτό από την εβδομάδα 0.

919
00:44:53,470 --> 00:44:56,715
>> Είναι ένα πρόβλημα όπου υπάρχει εισόδους,
όπως το πραγματικό μήνυμα στα αγγλικά

920
00:44:56,715 --> 00:44:59,340
ή ό, τι γλώσσα που
θέλετε να στείλετε σε κάποιον στην τάξη,

921
00:44:59,340 --> 00:45:00,580
ή μέσω του Διαδικτύου.

922
00:45:00,580 --> 00:45:03,840
Υπάρχει κάποια έξοδος, η οποία πρόκειται
να είναι το κωδικοποιημένο μήνυμα που

923
00:45:03,840 --> 00:45:05,250
θέλετε ο παραλήπτης να λάβει.

924
00:45:05,250 --> 00:45:07,405
Και ακόμα και αν κάποιος στην
μέση λαμβάνει πάρα πολύ,

925
00:45:07,405 --> 00:45:09,780
δεν τους θέλουν να
απαραιτήτως να είναι σε θέση να το αποκρυπτογραφήσει,

926
00:45:09,780 --> 00:45:12,840
γιατί μέσα από αυτό
μαύρο κουτί, ή αλγόριθμο,

927
00:45:12,840 --> 00:45:17,650
είναι κάποιος μηχανισμός, μερικά βήμα-βήμα
οδηγίες, για την λήψη της εισόδου

928
00:45:17,650 --> 00:45:20,710
και μετατροπή σε η
εξόδου, το ελπίζω με ασφαλή τρόπο.

929
00:45:20,710 --> 00:45:23,640
>> Και, στην πραγματικότητα, υπάρχει κάποια
λεξιλόγιο σε αυτόν τον κόσμο ως εξής.

930
00:45:23,640 --> 00:45:26,100
Απλό κείμενο είναι η λέξη ένα
επιστήμονας υπολογιστών θα

931
00:45:26,100 --> 00:45:28,449
χρησιμοποιούμε για να περιγράψουμε την είσοδο
μήνυμα, όπως το αγγλικό

932
00:45:28,449 --> 00:45:31,240
ή ό, τι γλώσσα που πραγματικά
θέλετε να στείλετε σε κάποιον άλλο άνθρωπο.

933
00:45:31,240 --> 00:45:35,450
Και τότε το κρυπτογράφημα είναι το σκαρφάλωμα
στο κρυπτογραφημένες, ή κρυπτογραφημένη,

934
00:45:35,450 --> 00:45:36,520
έκδοση αυτών.

935
00:45:36,520 --> 00:45:38,750
>> Αλλά υπάρχει ένα άλλο συστατικό εδώ.

936
00:45:38,750 --> 00:45:43,200
Υπάρχει μια άλλη είσοδο για να
μυστικό κλειδί κρυπτογράφησης.

937
00:45:43,200 --> 00:45:45,200
Και αυτό είναι το κλειδί για τον εαυτό της,
το οποίο είναι, σε γενικές γραμμές,

938
00:45:45,200 --> 00:45:48,930
όπως θα δούμε, ένας αριθμός, ή
e-mail, ή μια λέξη, ανεξαρτήτως

939
00:45:48,930 --> 00:45:51,980
ο αλγόριθμος είναι στην πραγματικότητα περιμένει.

940
00:45:51,980 --> 00:45:53,870
>> Και πώς να αποκρυπτογραφήσει τις πληροφορίες;

941
00:45:53,870 --> 00:45:55,110
Πώς μπορείτε να το βάλει στη σωστή σειρά;

942
00:45:55,110 --> 00:45:57,950
Λοιπόν, μόλις αντιστραφεί η
έξοδοι και οι είσοδοι.

943
00:45:57,950 --> 00:46:00,900
>> Με άλλα λόγια, όταν κάποιος
λαμβάνει κρυπτογραφημένο μήνυμα σας,

944
00:46:00,900 --> 00:46:03,740
αυτός ή αυτή απλά έχει
να γνωρίζουν το ίδιο κλειδί.

945
00:46:03,740 --> 00:46:05,700
Έχουν λάβει το κρυπτοκείμενο.

946
00:46:05,700 --> 00:46:09,530
Και συνδέοντας αυτά τα δύο
εισροές στο σύστημα κρυπτογραφίας,

947
00:46:09,530 --> 00:46:14,260
ο αλγόριθμος, αυτό το μαύρο κουτί, έξω
θα πρέπει να έρθει το αρχικό απλό κείμενο.

948
00:46:14,260 --> 00:46:17,830
Και έτσι αυτό είναι το πολύ υψηλό επίπεδο
άποψη για το τι είναι στην πραγματικότητα κρυπτογραφίας

949
00:46:17,830 --> 00:46:18,590
όλα για.

950
00:46:18,590 --> 00:46:20,030
>> Ας φτάσουμε εκεί.

951
00:46:20,030 --> 00:46:22,700
Ας δούμε τώρα κάτω
Η κουκούλα του κάτι

952
00:46:22,700 --> 00:46:26,000
έχουμε ήδη λάβει ως δεδομένο για
την περασμένη εβδομάδα, και γι 'αυτό συνεδρίας

953
00:46:26,000 --> 00:46:27,629
here-- το string.

954
00:46:27,629 --> 00:46:30,295
Μια χορδή στο τέλος της ημέρας
είναι απλά μια ακολουθία χαρακτήρων.

955
00:46:30,295 --> 00:46:33,610
>> Θα μπορούσε να είναι ο κόσμος ένα γεια, ή
γεια Zamyla, ή οτιδήποτε άλλο.

956
00:46:33,610 --> 00:46:37,050
Αλλά τι σημαίνει αυτό για
είναι μια ακολουθία χαρακτήρων;

957
00:46:37,050 --> 00:46:41,520
Στην πραγματικότητα, η βιβλιοθήκη CS50 δίνει
μας ένας τύπος δεδομένων που ονομάζεται χορδή.

958
00:46:41,520 --> 00:46:45,140
>> Αλλά στην πραγματικότητα δεν υπάρχει
τέτοιο πράγμα όπως ένα string σε C.

959
00:46:45,140 --> 00:46:49,450
Είναι πραγματικά ακριβώς μια ακολουθία
χαρακτήρα, χαρακτήρα, χαρακτήρα,

960
00:46:49,450 --> 00:46:52,180
χαρακτήρα, πίσω, προς τα πίσω, για να
πίσω, προς τα πίσω, προς τα πίσω μέσα

961
00:46:52,180 --> 00:46:54,650
της μνήμης του υπολογιστή σας, ή RAM.

962
00:46:54,650 --> 00:46:58,940
Και θα εξετάσουμε βαθύτερα ότι η
μέλλον, όταν κοιτάξουμε την ίδια μνήμη,

963
00:46:58,940 --> 00:47:02,030
και η χρησιμοποίηση, και ο
απειλές που εμπλέκονται.

964
00:47:02,030 --> 00:47:04,100
>> Αλλά ας εξετάσουμε το string Zamyla.

965
00:47:04,100 --> 00:47:07,480
Έτσι απλά το όνομα της
η ανθρώπινη εδώ, Zamyla,

966
00:47:07,480 --> 00:47:12,030
ότι είναι μια ακολουθία
χαρακτήρες, Ζ-Α-Μ-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Και τώρα ας υποθέσουμε ότι το όνομα Zamyla του
που αποθηκεύονται μέσα σε ένα υπολογιστή

968
00:47:16,020 --> 00:47:16,880
πρόγραμμα.

969
00:47:16,880 --> 00:47:20,830
>> Λοιπόν, στέκεται στο λόγο ότι θα έπρεπε
να είναι σε θέση να εξετάσουμε αυτούς τους χαρακτήρες

970
00:47:20,830 --> 00:47:21,590
ατομικά.

971
00:47:21,590 --> 00:47:24,710
Έτσι, είμαι απλώς πρόκειται να συντάξει ένα μικρό
κουτί γύρω από το όνομά Zamyla εδώ.

972
00:47:24,710 --> 00:47:31,580
Και αυτό συμβαίνει σε C ότι όταν
έχουν μια σειρά, όπως Zamyla-- και ίσως

973
00:47:31,580 --> 00:47:34,940
ότι η χορδή έχει επιστρέψει από
μια λειτουργία όπως εγχόρδων get,

974
00:47:34,940 --> 00:47:38,540
μπορείτε πραγματικά να χειριστείτε
το χαρακτήρα προς χαρακτήρα.

975
00:47:38,540 --> 00:47:42,070
>> Τώρα, αυτό είναι σχετικός για το
συνομιλία στο χέρι, επειδή

976
00:47:42,070 --> 00:47:46,420
στην κρυπτογραφία, αν θέλετε να αλλάξετε
Α στο Β, και Β σε C και C έως D,

977
00:47:46,420 --> 00:47:49,650
και ούτω καθεξής, θα πρέπει να είναι σε θέση
να δούμε τις επιμέρους χαρακτήρες

978
00:47:49,650 --> 00:47:50,190
σε μια σειρά.

979
00:47:50,190 --> 00:47:52,695
Θα πρέπει να είναι σε θέση να αλλάξει
το Z σε κάτι άλλο, το Α

980
00:47:52,695 --> 00:47:55,280
σε κάτι άλλο, το Μ να
κάτι άλλο, και ούτω καθεξής.

981
00:47:55,280 --> 00:47:58,000
Και γι 'αυτό χρειαζόμαστε έναν τρόπο,
προγραμματισμού, έτσι

982
00:47:58,000 --> 00:48:03,020
να μιλήσει, σε C για να είναι σε θέση να αλλάξει
και να κοιτάξουμε μεμονωμένα γράμματα.

983
00:48:03,020 --> 00:48:05,690
Και μπορούμε να το κάνουμε αυτό ως εξής.

984
00:48:05,690 --> 00:48:08,340
>> Επιτρέψτε μου να πάω το κεφάλι πίσω στο CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Και επιτρέψτε μου να πάει μπροστά
και να δημιουργήσετε ένα νέο αρχείο

986
00:48:11,130 --> 00:48:16,134
ότι θα καλέσω αυτή τη φορά string0,
ως το πρώτο τέτοιο παράδειγμα μας, τελεία γ.

987
00:48:16,134 --> 00:48:18,300
Και Πάω να πάει μπροστά
και το μαστίγιο ως εξής.

988
00:48:18,300 --> 00:48:22,870
>> Έτσι περιλαμβάνουν CS50.h, και
Στη συνέχεια περιλαμβάνει τις τυποποιημένες io.h,

989
00:48:22,870 --> 00:48:25,990
το οποίο είμαι σχεδόν πάντα πρόκειται να
να χρησιμοποιούν σε προγράμματα μου, τουλάχιστον

990
00:48:25,990 --> 00:48:26,780
αρχικά.

991
00:48:26,780 --> 00:48:32,180
int main κενό, και στη συνέχεια, εδώ είμαι
πρόκειται να κάνει χορδές παίρνει πάρει εγχόρδων.

992
00:48:32,180 --> 00:48:35,260
Και τότε Πάω να
να προχωρήσει και να το κάνουμε αυτό.

993
00:48:35,260 --> 00:48:37,460
Θέλω να πάω μπροστά
και, ως επιταγή λογική,

994
00:48:37,460 --> 00:48:43,607
μόνο να πω, γεια, τοις εκατό s,
ερωτηματικό, κάνει εγχόρδων 0.

995
00:48:43,607 --> 00:48:44,690
Ωχ, τι έκανα εδώ;

996
00:48:44,690 --> 00:48:45,930
Αχ, εγώ δεν το συνδέσετε.

997
00:48:45,930 --> 00:48:48,120
Έτσι δίδαγμα, ότι
δεν ήταν εσκεμμένο.

998
00:48:48,120 --> 00:48:52,480
>> Έτσι σφάλμα, περισσότερο τοις εκατό
μετατροπές από τα επιχειρήματα των δεδομένων.

999
00:48:52,480 --> 00:48:54,940
Και αυτό είναι που, σε
γραμμή 7-- Εντάξει, έτσι έχω,

1000
00:48:54,940 --> 00:48:56,690
απόσπασμα εισαγωγικά, ότι είναι
κορδόνι μου στο printf.

1001
00:48:56,690 --> 00:48:58,151
Έχω ένα σημάδι τοις εκατό.

1002
00:48:58,151 --> 00:48:59,650
Αλλά είμαι λείπει το δεύτερο επιχείρημα.

1003
00:48:59,650 --> 00:49:03,190
>> Είμαι λείπει το κόμμα, το οποίο
Είχα στα προηγούμενα παραδείγματα.

1004
00:49:03,190 --> 00:49:06,650
Έτσι, μια καλή ευκαιρία για να διορθώσετε
ένα ακόμα λάθος, λάθος.

1005
00:49:06,650 --> 00:49:09,950
Και τώρα επιτρέψτε μου να τρέξει
string0, πληκτρολογήστε Zamyla.

1006
00:49:09,950 --> 00:49:10,970
Εντάξει, γεια Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Έτσι έχουμε τρέξει αυτό το είδος του προγράμματος
μερικές διαφορετικές φορές μέχρι τώρα.

1008
00:49:14,144 --> 00:49:16,310
Αλλά ας κάνουμε κάτι
λίγο διαφορετικά αυτή τη φορά.

1009
00:49:16,310 --> 00:49:19,450
Αντί απλά την εκτύπωση Zamyla του
ολόκληρο το όνομα με printf,

1010
00:49:19,450 --> 00:49:21,350
ας το κάνουμε ανά χαρακτήρα.

1011
00:49:21,350 --> 00:49:22,700
>> Πάω να χρησιμοποιήσετε ένα βρόχο for.

1012
00:49:22,700 --> 00:49:26,160
Και Πάω να δώσω στον εαυτό μου
μια μεταβλητή καταμέτρηση, που ονομάζεται i.

1013
00:49:26,160 --> 00:49:33,530
Και Πάω να κρατήσει την επανάληψη, έτσι
Όσο i είναι μικρότερο από το μήκος του s.

1014
00:49:33,530 --> 00:49:35,930
>> Αποδεικνύεται, δεν το κάναμε
κάνετε αυτή την τελευταία φορά,

1015
00:49:35,930 --> 00:49:39,100
ότι γ έρχεται με ένα
συνάρτηση που ονομάζεται Stirling.

1016
00:49:39,100 --> 00:49:42,690
Πίσω στην ημέρα, και σε γενικές γραμμές
ακόμα κατά την εφαρμογή λειτουργιών,

1017
00:49:42,690 --> 00:49:45,405
οι άνθρωποι θα επιλέγουν συχνά πολύ
συνοπτική ονόματα αυτό το είδος του ήχου

1018
00:49:45,405 --> 00:49:48,280
όπως αυτό που θέλετε, ακόμα κι αν είναι
λείπουν μερικά φωνήεντα ή γράμματα.

1019
00:49:48,280 --> 00:49:50,660
Έτσι Stirling είναι η
όνομα της συνάρτησης που

1020
00:49:50,660 --> 00:49:53,880
παίρνει ένα επιχείρημα μεταξύ
παρενθέσεις που θα πρέπει να είναι ένα string.

1021
00:49:53,880 --> 00:49:56,910
Και επιστρέφει ακριβώς έναν ακέραιο αριθμό,
το μήκος της συμβολοσειράς.

1022
00:49:56,910 --> 00:50:00,580
>> Έτσι, αυτό για το βρόχο στη γραμμή 7 πρόκειται
να αρχίσουμε να μετράμε σε i ισούται με 0.

1023
00:50:00,580 --> 00:50:02,530
Είναι πρόκειται να αυξήσετε
i σε κάθε επανάληψη

1024
00:50:02,530 --> 00:50:04,350
με 1, όπως έχουμε κάνει μερικές φορές.

1025
00:50:04,350 --> 00:50:06,780
Αλλά πρόκειται να κάνουμε μόνο
αυτό μέχρι το σημείο

1026
00:50:06,780 --> 00:50:09,660
όταν i είναι το μήκος
της ίδιας της στοιχειοσειράς.

1027
00:50:09,660 --> 00:50:14,520
>> Έτσι, αυτό είναι ένας τρόπος, τελικά,
την επανάληψη πάνω από τους χαρακτήρες

1028
00:50:14,520 --> 00:50:17,430
στη συμβολοσειρά όπως είναι εξής.

1029
00:50:17,430 --> 00:50:20,670
Πάω να εκτυπώσετε όχι
ολόκληρη σειρά, αλλά τοις εκατό c,

1030
00:50:20,670 --> 00:50:22,860
ένα ενιαίο χαρακτήρα
ακολουθείται από μια νέα γραμμή.

1031
00:50:22,860 --> 00:50:24,880
Και τότε Πάω να
να προχωρήσει, και χρειάζομαι

1032
00:50:24,880 --> 00:50:29,080
να πω θέλω να εκτυπώσετε
i-χαρακτήρας του s.

1033
00:50:29,080 --> 00:50:33,450
>> Έτσι, αν i είναι η μεταβλητή που δείχνει
ο δείκτης του κορδονιού, όπου

1034
00:50:33,450 --> 00:50:37,230
είστε σε αυτό, θα πρέπει να είναι σε θέση να
λένε, να μου δώσει το i-οστό χαρακτήρα του s.

1035
00:50:37,230 --> 00:50:40,390
Και γ έχει τον τρόπο του να κάνει
αυτό με αγκύλες.

1036
00:50:40,390 --> 00:50:43,679
Μπορείτε απλά να πω το όνομα του
χορδών, η οποία στην προκειμένη περίπτωση είναι s.

1037
00:50:43,679 --> 00:50:46,970
Στη συνέχεια, μπορείτε να χρησιμοποιήσετε αγκύλες, τα οποία είναι
συνήθως ακριβώς πάνω από Return ή Enter σας

1038
00:50:46,970 --> 00:50:48,110
πλήκτρο στο πληκτρολόγιο.

1039
00:50:48,110 --> 00:50:52,410
Και στη συνέχεια βάζετε το δείκτη του
χαρακτήρα που θέλετε να εκτυπώσετε.

1040
00:50:52,410 --> 00:50:55,960
Έτσι, ο δείκτης πρόκειται να είναι μια
number-- 0, ή 1, ή 2, ή 3, ή τελεία,

1041
00:50:55,960 --> 00:50:57,590
τελεία, τελεία, κάποιο άλλο αριθμό.

1042
00:50:57,590 --> 00:51:00,920
>> Και έχουμε διασφαλίσει ότι πρόκειται να
είναι το σωστό αριθμό, γιατί

1043
00:51:00,920 --> 00:51:02,360
αρχίζουν να μετρούν σε 0.

1044
00:51:02,360 --> 00:51:07,020
Και από προεπιλογή, ο πρώτος χαρακτήρας
σε μια σειρά είναι κατά συνθήκη 0.

1045
00:51:07,020 --> 00:51:09,230
Και ο δεύτερος χαρακτήρας είναι στήριγμα 1.

1046
00:51:09,230 --> 00:51:11,120
Και ο τρίτος χαρακτήρας είναι στήριγμα 2.

1047
00:51:11,120 --> 00:51:13,630
Και δεν θέλετε να πάει πολύ
μακριά, αλλά εμείς δεν θα επειδή είμαστε

1048
00:51:13,630 --> 00:51:17,780
πρόκειται να αυξήσετε i μόνο μέχρι να
ισούται με το μήκος του νήματος.

1049
00:51:17,780 --> 00:51:20,210
Και στο οποίο σημείο,
αυτό για loop θα σταματήσει.

1050
00:51:20,210 --> 00:51:25,550
>> Επιτρέψτε μου λοιπόν να πάει μπροστά και να σώσει αυτό το
πρόγραμμα, και τρέχει να κάνει κορδόνι 0.

1051
00:51:25,550 --> 00:51:28,400
Αλλά εγώ μαντάρα.

1052
00:51:28,400 --> 00:51:35,390
Σιωπηρά δηλώνοντας τη λειτουργία της βιβλιοθήκης
Stirling με τον τύπο, όπως και such-- τώρα,

1053
00:51:35,390 --> 00:51:36,430
αυτό ακούγεται οικείο.

1054
00:51:36,430 --> 00:51:37,440
Αλλά δεν printf.

1055
00:51:37,440 --> 00:51:38,540
Και δεν είναι να πάρει εγχόρδων.

1056
00:51:38,540 --> 00:51:40,480
>> Εγώ δεν βίδα μέχρι το
με τον ίδιο τρόπο αυτή τη φορά.

1057
00:51:40,480 --> 00:51:45,100
Αλλά παρατηρήσετε εδώ κάτω λίγο προς τα κάτω
περαιτέρω, περιλαμβάνουν την string.h κεφαλίδα,

1058
00:51:45,100 --> 00:51:47,210
προβλέπουν ρητά η
δήλωση για Stirling.

1059
00:51:47,210 --> 00:51:48,820
Έτσι, υπάρχει πραγματικά μια ένδειξη εκεί.

1060
00:51:48,820 --> 00:51:51,670
>> Και πράγματι αποδεικνύεται
υπάρχει ένα άλλο αρχείο κεφαλίδας

1061
00:51:51,670 --> 00:51:53,970
ότι δεν έχω χρησιμοποιήσει
στην τάξη ακόμα, αλλά είναι

1062
00:51:53,970 --> 00:51:56,480
μεταξύ εκείνων που διατίθενται
για να σας, που ονομάζεται string.h.

1063
00:51:56,480 --> 00:52:00,930
Και σε αυτό το αρχείο, string.h
είναι Stirling δηλωθεί.

1064
00:52:00,930 --> 00:52:05,220
Επιτρέψτε μου λοιπόν να πάει μπροστά και να
αποθηκεύσετε αυτή, κάνει εγχόρδων

1065
00:52:05,220 --> 00:52:08,040
0-- ωραίο, δεν υπάρχουν μηνύματα λάθους αυτή τη φορά.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, και
Είμαι έτοιμος να πατήστε Enter,

1067
00:52:12,290 --> 00:52:16,710
σε ποιο σημείο getstring πρόκειται
να επιστρέψει το string, το έθεσε σε s.

1068
00:52:16,710 --> 00:52:21,890
Στη συνέχεια, ότι για βρόχος πρόκειται να επαναλάβει
πάνω από τους χαρακτήρες του S, ένα κάθε φορά,

1069
00:52:21,890 --> 00:52:28,420
και να τις εκτυπώσετε μία ανά γραμμή, επειδή
Είχα αυτή την ανάστροφη κάθετο n στο τέλος.

1070
00:52:28,420 --> 00:52:34,530
Έτσι θα μπορούσα να παραλείψετε αυτό το backslash
n, και στη συνέχεια απλά να εκτυπώσετε Zamyla όλα

1071
00:52:34,530 --> 00:52:37,460
στην ίδια γραμμή,
αποτελεσματικά reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, η οποία δεν είναι καθόλου χρήσιμο.

1073
00:52:38,999 --> 00:52:40,540
Αλλά στην περίπτωση αυτή, δεν έχω κάνει αυτό.

1074
00:52:40,540 --> 00:52:43,610
Έχω πραγματικά τυπωμένο ένα
χαρακτήρα σε μια στιγμή, ένα ανά γραμμή,

1075
00:52:43,610 --> 00:52:45,400
έτσι ώστε να δούμε πραγματικά το αποτέλεσμα.

1076
00:52:45,400 --> 00:52:46,900
>> Αλλά θα ήθελα να τονίσω ένα πράγμα εδώ.

1077
00:52:46,900 --> 00:52:48,930
Και θα επανέλθουμε
αυτό σε μια μελλοντική εβδομάδα.

1078
00:52:48,930 --> 00:52:52,650
Αποδεικνύεται ότι αυτό
κώδικας είναι δυνητικά λάθη.

1079
00:52:52,650 --> 00:52:56,560
>> Αποδεικνύεται ότι το κορδόνι get
και κάποιες άλλες λειτουργίες της ζωής

1080
00:52:56,560 --> 00:53:00,280
δεν κάνει απαραίτητα πάντα
επιστρέφουν αυτό που περιμένουμε.

1081
00:53:00,280 --> 00:53:03,010
Γνωρίζουμε από την τάξη τελευταία
φορά σε αυτό που παίρνουν

1082
00:53:03,010 --> 00:53:04,960
κορδόνι υποτίθεται ότι θα επιστρέψει ένα string.

1083
00:53:04,960 --> 00:53:09,900
Τι γίνεται όμως όταν ο χρήστης πληκτρολογεί τέτοιου είδους
μια μακρά λέξη ή σκέψη, ή ένα δοκίμιο

1084
00:53:09,900 --> 00:53:13,010
ότι υπάρχει απλά δεν είναι αρκετό
μνήμη στον υπολογιστή για να το χωρέσει.

1085
00:53:13,010 --> 00:53:15,410
>> Όπως, τι θα γινόταν αν κάτι πάει
λάθος κάτω από την κουκούλα;

1086
00:53:15,410 --> 00:53:18,400
Μπορεί να μην συμβαίνει συχνά,
αλλά θα μπορούσε να συμβεί μία φορά

1087
00:53:18,400 --> 00:53:21,520
σε μια στιγμή, πολύ σπάνια.

1088
00:53:21,520 --> 00:53:25,460
Και έτσι αποδεικνύεται ότι εγχόρδων get
και λειτουργίες όπως το κάνουμε δεν είναι απαραίτητα

1089
00:53:25,460 --> 00:53:26,380
πάντα επιστρέφουν χορδές.

1090
00:53:26,380 --> 00:53:30,680
Μπορεί να επιστρέψει κάποια τιμή σφάλματος,
κάποια αξία φρουρού να το πω έτσι,

1091
00:53:30,680 --> 00:53:32,612
που δείχνει ότι
κάτι έχει πάει στραβά.

1092
00:53:32,612 --> 00:53:35,320
Και εσείς θα ξέρετε μόνο αυτό από
έχοντας μάθει στην τάξη τώρα,

1093
00:53:35,320 --> 00:53:37,700
ή έχοντας διαβάσει κάποια περισσότερη τεκμηρίωση.

1094
00:53:37,700 --> 00:53:43,120
Αποδεικνύεται ότι το κορδόνι get
μπορεί να επιστρέψει μια τιμή που ονομάζεται μηδενική.

1095
00:53:43,120 --> 00:53:46,220
Null είναι μια ειδική αξία ότι θα
επανέλθει στην μελλοντική εβδομάδα.

1096
00:53:46,220 --> 00:53:50,420
Αλλά για τώρα, απλά να ξέρετε ότι αν θέλω
να είναι πραγματικά κατάλληλη για τη μετακίνηση προς τα εμπρός

1097
00:53:50,420 --> 00:53:52,650
χρησιμοποιώντας εγχόρδων πάρει, εγώ
δεν θα πρέπει να την αποκαλούν απλώς,

1098
00:53:52,650 --> 00:53:56,870
και τυφλά χρησιμοποιήσει τιμή επιστροφής της,
πιστεύοντας ότι αυτό είναι ένα string.

1099
00:53:56,870 --> 00:53:59,420
>> Θα πρέπει πρώτα να πω,
hey, περιμένετε ένα λεπτό, μόνο

1100
00:53:59,420 --> 00:54:03,380
να πραγματοποιηθεί, εάν s δεν είναι ίσο με
null, όπου null, και πάλι,

1101
00:54:03,380 --> 00:54:04,660
είναι μερικά μόνο από ιδιαίτερη αξία.

1102
00:54:04,660 --> 00:54:07,770
Και είναι η μόνη ιδιαίτερη αξία σας
χρειάζεται να ανησυχείτε για για κορδόνι get.

1103
00:54:07,770 --> 00:54:10,900
Πάρτε κορδόνι είτε πρόκειται
να επιστρέψει ένα string ή null.

1104
00:54:10,900 --> 00:54:17,219
>> Και αυτό το θαυμαστικό ίσον
ίσως γνωρίζετε από ίσως μάθημα των Μαθηματικών

1105
00:54:17,219 --> 00:54:20,510
ότι μπορεί να αντλήσει ένα ίσον με
μια γραμμή μέσα από αυτό για να δείξει όχι ίσες.

1106
00:54:20,510 --> 00:54:23,135
Αυτό δεν είναι γενικά ένα χαρακτήρα
μπορείτε να πληκτρολογήσετε στο πληκτρολόγιό σας.

1107
00:54:23,135 --> 00:54:26,480
Και έτσι στις περισσότερες γλώσσες προγραμματισμού,
όταν θέλετε να πείτε όχι ίσο,

1108
00:54:26,480 --> 00:54:29,160
μπορείτε να χρησιμοποιήσετε ένα θαυμαστικό,
αλλιώς γνωστή ως κτύπημα.

1109
00:54:29,160 --> 00:54:33,180
Έτσι που λέτε κτύπημα ισούται, η οποία
δεν σημαίνει ισούται, λογικά.

1110
00:54:33,180 --> 00:54:38,060
Είναι ακριβώς σαν να μην υπάρχει μια μεγαλύτερη
από, ή ίση με, ή μικρότερη από

1111
00:54:38,060 --> 00:54:41,270
ή ίση με πλήκτρο στο πληκτρολόγιό σας
ότι τα κάνει όλα σε ένα σύμβολο.

1112
00:54:41,270 --> 00:54:44,020
Έτσι, γι 'αυτό, στο παρελθόν παραδείγματα,
κάνατε ένα ανοιχτό βραχίονα, και στη συνέχεια,

1113
00:54:44,020 --> 00:54:48,670
ένα σύμβολο της ισότητας, προκειμένου να γίνει
ή μεγαλύτερη από, ας πούμε, λιγότερο από ό, τι.

1114
00:54:48,670 --> 00:54:49,910
>> Έτσι ποια είναι η takeaway εδώ;

1115
00:54:49,910 --> 00:54:53,880
Αυτό είναι απλά ένας τρόπος τώρα
εισάγοντας αυτή τη σύνταξη, αυτό το χαρακτηριστικό,

1116
00:54:53,880 --> 00:54:57,390
επανάληψη των ατομικών
χαρακτήρες σε μια σειρά.

1117
00:54:57,390 --> 00:55:00,260
Και ακριβώς όπως αυτά τα τετραγωνικά
παρένθεση σας επιτρέπουν να πάρετε σε αυτούς,

1118
00:55:00,260 --> 00:55:03,790
να εξετάσει αυτές τις αγκύλες, όπως
είδος υπαινίχθηκε σε αυτό το υποκείμενο

1119
00:55:03,790 --> 00:55:06,040
σχεδιασμού, σύμφωνα με την οποία κάθε
χαρακτήρα μέσα από μια σειρά

1120
00:55:06,040 --> 00:55:10,180
είναι το είδος της εγκλωβιστούμε σε κάπου κάτω
η κουκούλα στη μνήμη του υπολογιστή σας.

1121
00:55:10,180 --> 00:55:12,340
>> Αλλά ας κάνουμε μια παραλλαγή αυτού.

1122
00:55:12,340 --> 00:55:14,880
Αποδεικνύεται ότι αυτό
πρόγραμμα είναι σωστή.

1123
00:55:14,880 --> 00:55:18,810
Έτσι, ανά άξονα CS50 για την αξιολόγηση
κώδικα, αυτό είναι σωστό τώρα.

1124
00:55:18,810 --> 00:55:22,959
Ειδικά τώρα που είμαι έλεγχος για
null, το πρόγραμμα αυτό δεν πρέπει ποτέ να διακοπεί.

1125
00:55:22,959 --> 00:55:24,500
Και ξέρω ακριβώς ότι από την εμπειρία.

1126
00:55:24,500 --> 00:55:28,040
Αλλά δεν υπάρχει τίποτα άλλο που
μπορούμε πραγματικά να πάει στραβά εδώ.

1127
00:55:28,040 --> 00:55:31,860
Αλλά δεν είναι πολύ καλά σχεδιασμένη,
γιατί ας πάμε πίσω στα βασικά.

1128
00:55:31,860 --> 00:55:34,450
>> Κατ 'αρχάς, principles--
τι ένα για το βρόχο κάνω;

1129
00:55:34,450 --> 00:55:36,290
Ένας βρόχος for κάνει τρία πράγματα.

1130
00:55:36,290 --> 00:55:39,340
Προετοιμάζει μερικά
αξία, αν το ζητήσετε.

1131
00:55:39,340 --> 00:55:41,770
Ελέγχει μια κατάσταση.

1132
00:55:41,770 --> 00:55:45,380
Και στη συνέχεια μετά από κάθε
επανάληψη, μετά από κάθε κύκλο,

1133
00:55:45,380 --> 00:55:49,330
αυτό αυξάνει μερικά
αξία, ή τις αξίες, εδώ.

1134
00:55:49,330 --> 00:55:50,600
>> Λοιπόν, τι σημαίνει αυτό;

1135
00:55:50,600 --> 00:55:52,940
Έχουμε προετοιμαστεί θ 0.

1136
00:55:52,940 --> 00:55:58,610
Ελέγχουμε και να είμαι σίγουρη ότι είναι λιγότερο από ό, τι
το μήκος του, η οποία είναι Ζ-Α-Μ-Υ-Ε-Α,

1137
00:55:58,610 --> 00:55:59,900
οπότε η οποία είναι μικρότερη από 6.

1138
00:55:59,900 --> 00:56:02,590
Και, πράγματι, 0 ως λιγότερο από 6.

1139
00:56:02,590 --> 00:56:05,580
>> Εμείς εκτυπώσετε Ζ από το όνομα Zamyla του.

1140
00:56:05,580 --> 00:56:08,080
Τότε i αυξήσετε από 0 έως 1.

1141
00:56:08,080 --> 00:56:11,290
Εμείς στη συνέχεια, ελέγξτε, είναι ένα λιγότερο
από το μήκος του s;

1142
00:56:11,290 --> 00:56:13,270
Το μήκος του s είναι 6.

1143
00:56:13,270 --> 00:56:13,950
Ναι είναι.

1144
00:56:13,950 --> 00:56:16,880
>> Έτσι μπορούμε να εκτυπώσετε ένα στο όνομα Zamyla του, ΖΑ.

1145
00:56:16,880 --> 00:56:20,090
Εμείς θ αυξήσετε από 0 σε 1, σε 2.

1146
00:56:20,090 --> 00:56:23,720
Εμείς στη συνέχεια, ελέγξτε, είναι μικρότερη από 2
το μήκος του ονόματος Zamyla του.

1147
00:56:23,720 --> 00:56:25,380
6- έτσι 2 είναι μικρότερη από 6.

1148
00:56:25,380 --> 00:56:30,460
Ναι, ας εκτυπώσετε τώρα Μ σε
Το όνομά Zamyla, ο τρίτος χαρακτήρας.

1149
00:56:30,460 --> 00:56:34,110
>> Το κλειδί εδώ είναι ότι σε κάθε
επανάληψη της ιστορίας, είμαι έλεγχο,

1150
00:56:34,110 --> 00:56:37,810
είναι i μικρότερο από το μήκος του Zamyla;

1151
00:56:37,810 --> 00:56:40,350
Αλλά η σύλληψη είναι ότι
Stirling δεν είναι ένα ξενοδοχείο.

1152
00:56:40,350 --> 00:56:43,100
Όσοι από εσάς έχετε προγραμματίσει
πριν σε Java ή άλλες γλώσσες

1153
00:56:43,100 --> 00:56:46,310
μπορεί να γνωρίζει το μήκος ενός string είναι
ένα ακίνητο, μόνο μερικά μόνο για ανάγνωση αξία.

1154
00:56:46,310 --> 00:56:50,220
>> Στην C σε αυτήν την περίπτωση, αν αυτό είναι
μια λειτουργία που είναι κυριολεκτικά

1155
00:56:50,220 --> 00:56:53,520
μετρώντας τον αριθμό των
χαρακτήρες σε Zamyla κάθε φορά

1156
00:56:53,520 --> 00:56:54,740
καλούμε την εν λόγω λειτουργία.

1157
00:56:54,740 --> 00:56:58,500
Κάθε φορά που θα ζητήσει από τον υπολογιστή για να χρησιμοποιήσετε
Stirling, είναι να ρίξουμε μια ματιά σε Zamyla,

1158
00:56:58,500 --> 00:57:01,960
και λέγοντας Ζ-Α-Μ-Υ-Ε-Α, 6.

1159
00:57:01,960 --> 00:57:02,962
Και επιστρέφει 6.

1160
00:57:02,962 --> 00:57:04,920
Την επόμενη φορά που θα καλέσετε
το μέσα ότι για βρόχο,

1161
00:57:04,920 --> 00:57:08,610
πρόκειται να δούμε Zamyla
πάλι, λένε Ζ-Α-Μ-Υ-Ε-Α, 6.

1162
00:57:08,610 --> 00:57:10,320
Και πρόκειται να επιστρέψει 6.

1163
00:57:10,320 --> 00:57:12,980
Έτσι τι είναι ηλίθια σχετικά με αυτό το σχέδιο;

1164
00:57:12,980 --> 00:57:17,700
>> Γιατί είναι ο κώδικας δεν σε 5 από τα 5 μου
για το σχεδιασμό τώρα, να το πω έτσι;

1165
00:57:17,700 --> 00:57:20,600
Λοιπόν, ρωτάω ένα
ερώτηση άσκοπα.

1166
00:57:20,600 --> 00:57:23,030
Κάνω περισσότερη δουλειά από ό, τι χρειαστεί.

1167
00:57:23,030 --> 00:57:25,370
>> Έτσι, ακόμη και αν η
απάντηση είναι σωστή, είμαι

1168
00:57:25,370 --> 00:57:29,560
ζητώντας από τον υπολογιστή, τι είναι
το μήκος του Zamyla πάλι,

1169
00:57:29,560 --> 00:57:31,380
και ξανά, και ξανά, και ξανά;

1170
00:57:31,380 --> 00:57:33,980
Και η απάντηση είναι
Ποτέ δεν πρόκειται να αλλάξει.

1171
00:57:33,980 --> 00:57:35,900
Είναι πάντα θα είναι 6.

1172
00:57:35,900 --> 00:57:39,730
>> Έτσι, μια καλύτερη λύση από αυτή
θα είναι αυτή η επόμενη έκδοση.

1173
00:57:39,730 --> 00:57:43,390
Επιτρέψτε μου να πάει μπροστά και το βάζουμε σε ένα
ξεχωριστό αρχείο που ονομάζεται string1.c,

1174
00:57:43,390 --> 00:57:44,990
μόνο για να κρατήσει το διαχωρισμό.

1175
00:57:44,990 --> 00:57:47,260
Και αποδεικνύεται σε ένα για την
βρόχο, μπορείτε πραγματικά

1176
00:57:47,260 --> 00:57:50,210
δηλώνουν πολλών μεταβλητών με τη μία.

1177
00:57:50,210 --> 00:57:53,460
>> Έτσι, Πάω να κρατήσει i και να το θέσει σε 0.

1178
00:57:53,460 --> 00:57:56,190
Αλλά είμαι επίσης πρόκειται να
προσθέστε ένα κόμμα, και να πω,

1179
00:57:56,190 --> 00:58:01,050
να μου δώσει μια μεταβλητή που ονομάζεται n, του οποίου η
αξία ισούται με το μήκος του νήματος του s.

1180
00:58:01,050 --> 00:58:09,410
Και τώρα, παρακαλούμε να κάνετε την κατάστασή μου
εφ 'όσον το i είναι μικρότερο από το Ν.

1181
00:58:09,410 --> 00:58:14,140
>> Έτσι, με αυτόν τον τρόπο, η λογική είναι
ταυτόσημες στο τέλος της ημέρας.

1182
00:58:14,140 --> 00:58:18,280
Είμαι, όμως, να θυμόμαστε το
αξία 6, σε αυτή την περίπτωση.

1183
00:58:18,280 --> 00:58:19,780
Ποιο είναι το μήκος του ονόματος Zamyla του;

1184
00:58:19,780 --> 00:58:20,860
Και είμαι το θέτει σε n.

1185
00:58:20,860 --> 00:58:23,050
>> Και είμαι ακόμα έλεγχο
η κατάσταση κάθε φορά.

1186
00:58:23,050 --> 00:58:24,300
0 λιγότερο από 6;

1187
00:58:24,300 --> 00:58:25,600
Είναι 1 λιγότερο από 6;

1188
00:58:25,600 --> 00:58:28,600
Είναι 2 λιγότερο από 6, και ούτω καθεξής;

1189
00:58:28,600 --> 00:58:31,914
>> Αλλά δεν είμαι ζητώντας από τον υπολογιστή
και πάλι, και πάλι, τι είναι

1190
00:58:31,914 --> 00:58:33,080
το μήκος του ονόματος Zamyla του;

1191
00:58:33,080 --> 00:58:34,320
Ποιο είναι το μήκος του ονόματος Zamyla του;

1192
00:58:34,320 --> 00:58:35,986
Ποιο είναι το μήκος του ονόματος αυτού Zamyla του;

1193
00:58:35,986 --> 00:58:40,440
Είμαι κυριολεκτικά να θυμηθούμε ότι το πρώτο και
απαντήσει μόνο σε αυτή τη δεύτερη μεταβλητή n.

1194
00:58:40,440 --> 00:58:45,280
Έτσι, αυτό τώρα θα ήταν όχι μόνο
σωστή, αλλά επίσης καλά σχεδιασμένη.

1195
00:58:45,280 --> 00:58:46,670
>> Τώρα, τι γίνεται με το στυλ;

1196
00:58:46,670 --> 00:58:48,866
Έχω μεταβλητές με όνομα μου
αρκετά καλά, θα έλεγα.

1197
00:58:48,866 --> 00:58:50,240
Είναι σούπερ σύντομη αυτή τη στιγμή.

1198
00:58:50,240 --> 00:58:52,090
Και αυτό είναι απολύτως εντάξει.

1199
00:58:52,090 --> 00:58:55,120
>> Αν έχετε μόνο ένα
συμβολοσειράς σε ένα πρόγραμμα,

1200
00:58:55,120 --> 00:58:56,860
ίσως και να το ονομάσουμε S για τον σπάγκο.

1201
00:58:56,860 --> 00:58:59,370
Αν έχετε μόνο μία μεταβλητή
για την καταμέτρηση σε ένα πρόγραμμα,

1202
00:58:59,370 --> 00:59:00,710
ίσως και να το ονομάσουμε i.

1203
00:59:00,710 --> 00:59:03,500
Εάν έχετε ένα μήκος, n
είναι εξαιρετικά κοινή, καθώς και.

1204
00:59:03,500 --> 00:59:05,800
Αλλά δεν έχουν σχολιάσει οποιοδήποτε κώδικα μου.

1205
00:59:05,800 --> 00:59:09,200
>> Δεν έχω ενημερώσει την reader--
αν αυτό είναι TF μου, ή TA,

1206
00:59:09,200 --> 00:59:12,460
ή απλά colleague-- τι υποτίθεται
να συμβαίνει σε αυτό το πρόγραμμα.

1207
00:59:12,460 --> 00:59:15,760
Και έτσι για να πάρετε καλό στυλ,
ό, τι θα ήθελα να κάνω

1208
00:59:15,760 --> 00:59:24,580
είναι this-- κάτι
όπως ρωτήστε τον χρήστη για την είσοδο.

1209
00:59:24,580 --> 00:59:26,670
Και θα μπορούσα να ξαναγράψει
αυτό οποιοδήποτε αριθμό τρόπων.

1210
00:59:26,670 --> 00:59:35,630
>> Βεβαιωθείτε S-- βεβαιωθείτε get
συμβολοσειρά επιστρέφεται ένα string.

1211
00:59:35,630 --> 00:59:40,280
Και στη συνέχεια σε here-- και αυτό είναι ίσως
το πιο σημαντικό comment-- επαναλάβει

1212
00:59:40,280 --> 00:59:44,450
πάνω από τους χαρακτήρες στην s, ένα κάθε φορά.

1213
00:59:44,450 --> 00:59:47,060
Και θα μπορούσα να χρησιμοποιήσω οποιαδήποτε
επιλογή της αγγλικής γλώσσας

1214
00:59:47,060 --> 00:59:49,650
εδώ για να περιγράψει κάθε
αυτών των κομματιών του κώδικα.

1215
00:59:49,650 --> 00:59:52,740
>> Παρατηρήστε ότι δεν έχω βάλει ένα
Σχολιάστε σε κάθε γραμμή κώδικα,

1216
00:59:52,740 --> 00:59:55,690
πραγματικά μόνο για το ενδιαφέρον
αυτοί, αυτοί που

1217
00:59:55,690 --> 00:59:59,460
έχουν κάποιο νόημα ότι θα μπορούσα να
θέλουν να κάνουν σούπερ σαφές σε κάποιον

1218
00:59:59,460 --> 01:00:00,460
ανάγνωση τον κωδικό μου.

1219
01:00:00,460 --> 01:00:02,920
Και γιατί σας καλούν να πάρετε
κορδόνι ρωτήστε τον χρήστη για την είσοδο;

1220
01:00:02,920 --> 01:00:05,450
Ακόμη και ότι δεν είναι κατ 'ανάγκη
όλα αυτά περιγραφικό.

1221
01:00:05,450 --> 01:00:09,340
Αλλά βοηθά πω μια ιστορία, επειδή η
δεύτερη γραμμή στην ιστορία, βεβαιωθείτε

1222
01:00:09,340 --> 01:00:10,740
πάρετε εγχόρδων επέστρεψε ένα string.

1223
01:00:10,740 --> 01:00:14,260
>> Και η τρίτη γραμμή στην ιστορία είναι,
επαναλάβει πάνω από τους χαρακτήρες στην s ένα

1224
01:00:14,260 --> 01:00:15,380
σε μια στιγμή.

1225
01:00:15,380 --> 01:00:17,920
Και τώρα μόνο για το καλό μέτρο,
Πάω να πάει μπροστά και να προσθέσετε

1226
01:00:17,920 --> 01:00:24,560
ένα ακόμη σχόλιο που μόλις
λέει εκτύπωσης i-οστό χαρακτήρα s.

1227
01:00:24,560 --> 01:00:26,520
Τώρα, τι έκανα
στο τέλος της μέρας?

1228
01:00:26,520 --> 01:00:29,190
>> Έχω προσθέσει κάποια αγγλικά
λέξεων με τη μορφή σχολίων.

1229
01:00:29,190 --> 01:00:32,700
σημαίνει το σύμβολο κάθετο κάθετο, hey,
υπολογιστή αυτό είναι για τον άνθρωπο,

1230
01:00:32,700 --> 01:00:33,820
δεν είναι για σας, ο υπολογιστής.

1231
01:00:33,820 --> 01:00:35,119
Έτσι, από όπου και αν αγνοηθεί λογικά.

1232
01:00:35,119 --> 01:00:35,910
Είναι απλά εκεί.

1233
01:00:35,910 --> 01:00:39,830
>> Και, πράγματι, CS50 IDE τους δείχνει ως
γκρι, ως χρήσιμη, αλλά όχι κλειδί

1234
01:00:39,830 --> 01:00:41,000
στο πρόγραμμα.

1235
01:00:41,000 --> 01:00:42,570
Παρατηρήστε τι μπορείτε τώρα να κάνετε.

1236
01:00:42,570 --> 01:00:44,950
Είτε θέλετε να ξέρετε C
προγραμματισμό ή όχι,

1237
01:00:44,950 --> 01:00:47,722
μπορεί απλά να σταθεί πίσω σε αυτό
πρόγραμμα, και το αποβουτυρωμένο τα σχόλια.

1238
01:00:47,722 --> 01:00:50,180
Ζητήστε από το χρήστη για την είσοδο, βεβαιωθείτε
πάρετε εγχόρδων επέστρεψε ένα string,

1239
01:00:50,180 --> 01:00:53,009
επαναλάβει πάνω από τους χαρακτήρες στην s
ένα κάθε φορά, εκτυπώστε το χαρακτήρα

1240
01:00:53,009 --> 01:00:55,550
i-th χαρακτήρα S-- δεν το κάνετε
ακόμη και να δούμε τον κώδικα

1241
01:00:55,550 --> 01:00:57,270
να καταλάβουμε τι κάνει αυτό το πρόγραμμα.

1242
01:00:57,270 --> 01:01:00,280
Και, ακόμα καλύτερα, αν εσείς οι ίδιοι φαίνονται
σε αυτό το πρόγραμμα σε μια εβδομάδα ή δύο,

1243
01:01:00,280 --> 01:01:02,280
ή ένα μήνα ή ένα έτος,
εσείς δεν έχετε

1244
01:01:02,280 --> 01:01:04,420
να κοιτάζω τον κώδικα,
προσπαθώντας να θυμηθεί,

1245
01:01:04,420 --> 01:01:06,630
τι προσπαθώ να κάνω με αυτόν τον κωδικό;

1246
01:01:06,630 --> 01:01:07,770
>> Έχετε πει στον εαυτό σας.

1247
01:01:07,770 --> 01:01:11,660
Έχετε αυτό που περιγράφεται για τον εαυτό σας,
ή κάποιο συνάδελφο, ή TA, ή TF.

1248
01:01:11,660 --> 01:01:14,860
Και έτσι αυτό θα είναι τώρα
σωστή, και καλό σχεδιασμό,

1249
01:01:14,860 --> 01:01:18,210
και, τελικά, καλό στυλ, καθώς και.

1250
01:01:18,210 --> 01:01:19,990
Έτσι κάνετε να το έχουμε κατά νου.

1251
01:01:19,990 --> 01:01:22,200
>> Έτσι, υπάρχει ένα άλλο
πράγμα Πάω να κάνω εδώ

1252
01:01:22,200 --> 01:01:28,240
ότι μπορούν τώρα να αποκαλύψει τι ακριβώς είναι
συμβαίνει κάτω από το καπό.

1253
01:01:28,240 --> 01:01:30,390
Έτσι υπάρχει αυτή η δυνατότητα
σε C, και σε άλλες γλώσσες,

1254
01:01:30,390 --> 01:01:33,010
που ονομάζεται typecasting
ότι είτε σιωπηρά

1255
01:01:33,010 --> 01:01:37,250
ή ρητά επιτρέπει να μετατρέψετε
από έναν τύπο δεδομένων σε άλλο.

1256
01:01:37,250 --> 01:01:39,800
Έχουμε ήδη ασχολούνται τόσο
πολύ σήμερα με χορδές.

1257
01:01:39,800 --> 01:01:41,250
>> Και έγχορδα είναι χαρακτήρες.

1258
01:01:41,250 --> 01:01:44,910
Αλλά ανάκληση από εβδομάδα
0, ποιες είναι οι χαρακτήρες;

1259
01:01:44,910 --> 01:01:49,334
Χαρακτήρες είναι απλώς μια αφηρημένη έννοια
στην κορυφή του numbers-- δεκαδικοί αριθμοί,

1260
01:01:49,334 --> 01:01:52,500
και δεκαδικών αριθμών είναι πραγματικά ακριβώς ένα
αφαίρεσης πάνω από δυαδικούς αριθμούς,

1261
01:01:52,500 --> 01:01:53,720
όπως την ορίσαμε.

1262
01:01:53,720 --> 01:01:55,540
>> Έτσι, οι χαρακτήρες είναι αριθμοί.

1263
01:01:55,540 --> 01:01:58,410
Και οι αριθμοί είναι χαρακτήρες,
ακριβώς ανάλογα με το πλαίσιο.

1264
01:01:58,410 --> 01:02:01,250
Και αποδεικνύεται ότι στο εσωτερικό
ενός προγράμματος ηλεκτρονικού υπολογιστή,

1265
01:02:01,250 --> 01:02:06,830
μπορείτε να καθορίσετε πώς θέλετε να αναζητήσετε
στα κομμάτια στο εσωτερικό του εν λόγω προγράμματος;

1266
01:02:06,830 --> 01:02:10,400
>> Ανάκληση από την εβδομάδα 0 που είχαμε
Ascii, το οποίο είναι ακριβώς αυτός ο κώδικας

1267
01:02:10,400 --> 01:02:11,620
γράμματα χαρτογράφηση σε αριθμούς.

1268
01:02:11,620 --> 01:02:13,660
Και είπαμε, το κεφάλαιο Α είναι 65.

1269
01:02:13,660 --> 01:02:15,860
Πρωτεύουσα Β είναι 66, και ούτω καθεξής.

1270
01:02:15,860 --> 01:02:20,500
>> Και ειδοποίηση, έχουμε ουσιαστικά χαρακτήρες για
η κορυφαία σειρά εδώ, όπως θα τους καλέσει C,

1271
01:02:20,500 --> 01:02:23,400
χαρακτήρες, και στη συνέχεια
ints στη δεύτερη σειρά.

1272
01:02:23,400 --> 01:02:28,180
Και αποδεικνύεται μπορείτε να μετατρέψετε
απρόσκοπτα μεταξύ των δύο, συνήθως.

1273
01:02:28,180 --> 01:02:30,042
Και αν θέλουμε να κάνουμε
αυτό σκόπιμα, θα

1274
01:02:30,042 --> 01:02:31,750
μπορεί να θέλουν να αντιμετωπίσουν
κάτι σαν αυτό.

1275
01:02:31,750 --> 01:02:33,590
>> Μπορούμε ίσως να θέλετε να μετατρέψετε
κεφαλαία για να μειώσει

1276
01:02:33,590 --> 01:02:35,330
περίπτωση, ή πεζά σε κεφαλαία.

1277
01:02:35,330 --> 01:02:38,000
Και αποδεικνύεται εκεί που
στην πραγματικότητα ένα μοτίβο εδώ

1278
01:02:38,000 --> 01:02:39,900
μπορούμε να αγκαλιάσει ακριβώς σε μια στιγμή.

1279
01:02:39,900 --> 01:02:44,120
Αλλά ας δούμε πρώτα σε ένα
παράδειγμα για να γίνει αυτό ρητά.

1280
01:02:44,120 --> 01:02:46,340
>> Πάω να πάει πίσω στο CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Πάω να δημιουργήσει ένα
αρχείο που ονομάζεται Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Και Πάω να πάει μπροστά και να προσθέσετε μου
πρότυπο io.h στην κορυφή, int main κενό

1283
01:02:55,960 --> 01:02:57,370
στην κορυφή της συνάρτησης μου.

1284
01:02:57,370 --> 01:03:02,700
Και τότε είμαι απλώς πρόκειται να κάνει η
following-- ένα για το βρόχο από το i ισούται με,

1285
01:03:02,700 --> 01:03:04,610
ας πούμε, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Και τότε εγώ πρόκειται να είναι μικρότερη από
65, συν 26 γράμματα του αλφαβήτου.

1287
01:03:10,460 --> 01:03:12,640
Γι 'αυτό θα αφήσει τον υπολογιστή
κάνει τα μαθηματικά για μένα εκεί.

1288
01:03:12,640 --> 01:03:15,100
Και τότε μέσα σε αυτό το βρόχο,
τι θα πάω να εκτυπώσετε;

1289
01:03:15,100 --> 01:03:19,230
>> % C είναι% i ανάστροφη κάθετο n.

1290
01:03:19,230 --> 01:03:21,290
Και τώρα θέλω να συνδέσετε δύο τιμές.

1291
01:03:21,290 --> 01:03:24,530
Έχω βάλει προσωρινά ερώτηση
σηματοδοτεί εκεί για να καλέσει την ερώτηση.

1292
01:03:24,530 --> 01:03:29,940
>> Θέλω να επαναλάβει από 65 και μετά
για 26 γράμματα της αλφαβήτου,

1293
01:03:29,940 --> 01:03:35,190
εκτύπωση σε κάθε επανάληψη ότι
αναπόσπαστο ισοδύναμο χαρακτήρα.

1294
01:03:35,190 --> 01:03:38,299
Με άλλα λόγια, θέλω να
επαναλάβει την εκτύπωση πάνω από 26 αριθμούς

1295
01:03:38,299 --> 01:03:41,590
τι ο χαρακτήρας ASCII θα είναι, η επιστολή,
και τι is-- ο αντίστοιχος αριθμός

1296
01:03:41,590 --> 01:03:44,650
πραγματικά ακριβώς αναδημιουργία
το διάγραμμα από την εν λόγω διαφάνεια.

1297
01:03:44,650 --> 01:03:47,010
Λοιπόν, τι θα πρέπει να είναι αυτά τα ερωτηματικά;

1298
01:03:47,010 --> 01:03:51,760
>> Λοιπόν, αποδεικνύεται ότι το δεύτερο
θα πρέπει απλώς να είναι η μεταβλητή i.

1299
01:03:51,760 --> 01:03:53,860
Θέλω να δω ότι ως αριθμός.

1300
01:03:53,860 --> 01:03:58,920
Και η μεσαία επιχείρημα
Εδώ, μπορώ να πω τον υπολογιστή

1301
01:03:58,920 --> 01:04:03,470
να διαχειριστεί το εν λόγω ακέραιο
i ως χαρακτήρα, έτσι ώστε

1302
01:04:03,470 --> 01:04:05,880
να υποκαταστήσει εδώ για εκατό C.

1303
01:04:05,880 --> 01:04:07,990
>> Με άλλα λόγια, αν η
ανθρώπινη προγραμματιστής, ξέρετε

1304
01:04:07,990 --> 01:04:09,865
αυτά είναι μόνο αριθμοί
στο τέλος της μέρας.

1305
01:04:09,865 --> 01:04:12,500
Και ξέρω ότι το 65 θα πρέπει να
χάρτης σε κάποιο χαρακτήρα.

1306
01:04:12,500 --> 01:04:15,310
Με αυτό το ρητό καστ,
με μια παρένθεση,

1307
01:04:15,310 --> 01:04:18,840
το όνομα του τύπου δεδομένων που θέλετε να
μετατροπή σε, και μια κλειστή παρένθεση,

1308
01:04:18,840 --> 01:04:21,200
μπορείτε να πείτε το
υπολογιστή, hey, ηλεκτρονικών υπολογιστών,

1309
01:04:21,200 --> 01:04:24,130
μετατρέψει αυτό το ακέραιο σε ένα char.

1310
01:04:24,130 --> 01:04:26,250
>> Έτσι, όταν τρέχω αυτό
προγράμματος μετά την κατάρτιση,

1311
01:04:26,250 --> 01:04:29,740
ας δούμε τι get-- κάνουν Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Καταριέται αυτό, τι έκανα λάθος εδώ;

1313
01:04:33,020 --> 01:04:35,884
Χρησιμοποιήστε της αδήλωτης αναγνωριστικό,
Εντάξει, όχι εκ προθέσεως,

1314
01:04:35,884 --> 01:04:37,800
αλλά ας δούμε αν δεν μπορούμε να
λόγο μέσα από αυτό.

1315
01:04:37,800 --> 01:04:41,220
>> Έτσι γραμμή five-- έτσι δεν είχα πάρει
πολύ μακριά πριν από το βίδωμα επάνω.

1316
01:04:41,220 --> 01:04:42,140
Εντάξει.

1317
01:04:42,140 --> 01:04:46,560
Έτσι γραμμή 5 για i ισούται με 65-- βλέπω.

1318
01:04:46,560 --> 01:04:50,130
Ώστε να θυμάστε ότι σε C, σε αντίθεση με ορισμένους
γλώσσες, αν έχετε προηγούμενη προγραμματισμού

1319
01:04:50,130 --> 01:04:52,190
εμπειρία, έχετε
για να πει τον υπολογιστή,

1320
01:04:52,190 --> 01:04:55,040
σε αντίθεση με το μηδέν, τι
το είδος της μεταβλητής είναι.

1321
01:04:55,040 --> 01:04:56,860
>> Και ξέχασα μια φράση-κλειδί εδώ.

1322
01:04:56,860 --> 01:04:59,200
Σύμφωνα πέντε, έχω αρχίσει να χρησιμοποιούν i.

1323
01:04:59,200 --> 01:05:01,560
Αλλά δεν έχω πει C
τι δεδομένα τύπου είναι.

1324
01:05:01,560 --> 01:05:04,570
Έτσι, Πάω να πάει εδώ και
λένε, αχ, ότι ένας ακέραιος κάνουν.

1325
01:05:04,570 --> 01:05:07,050
>> Τώρα είμαι πρόκειται να πάει μπροστά και να ξαναμεταγλωττίσετε.

1326
01:05:07,050 --> 01:05:08,080
Ότι το σταθερό αυτό.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, αυτό είναι το είδος της δροσερό.

1328
01:05:12,660 --> 01:05:15,360
Όχι μόνο είναι εξαιρετικά γρήγορο να
να ζητήσει από τον υπολογιστή στο ερώτημα αυτό,

1329
01:05:15,360 --> 01:05:18,885
αντί να ψάχνει επάνω σε μια διαφάνεια,
να εκτυπώνεται μία ανά γραμμή, Α είναι 65,

1330
01:05:18,885 --> 01:05:24,860
Β είναι 66, σε όλη τη διαδρομή down-- από τότε που
έκανε αυτό 26 times-- στον γράμματα z,

1331
01:05:24,860 --> 01:05:25,630
το οποίο είναι 90.

1332
01:05:25,630 --> 01:05:27,790
Και, στην πραγματικότητα, ελαφρώς
πιο ευφυής θα

1333
01:05:27,790 --> 01:05:31,030
ήταν για μένα να μην βασίζεστε
στον υπολογιστή για να προσθέσετε 26.

1334
01:05:31,030 --> 01:05:34,060
Θα μπορούσα να είχα μόλις γίνει
90, καθώς και, εφ '

1335
01:05:34,060 --> 01:05:37,390
καθώς δεν κάνουν το ίδιο λάθος δύο φορές.

1336
01:05:37,390 --> 01:05:41,880
Θέλω να πάω μέσα από
z, όχι μόνο μέσα από το y.

1337
01:05:41,880 --> 01:05:44,000
>> Έτσι ώστε να είναι ρητή καστ.

1338
01:05:44,000 --> 01:05:47,860
Αποδεικνύεται ότι αυτό
δεν είναι καν απαραίτητο.

1339
01:05:47,860 --> 01:05:52,480
Επιτρέψτε μου να προχωρήσει και να επαναληφθεί αυτό
compiler, και να επαναπροσδιοριστούν Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Αποδεικνύεται ότι η C είναι αρκετά έξυπνος.

1341
01:05:54,940 --> 01:05:57,150
>> Και printf, ιδίως,
είναι αρκετά έξυπνος.

1342
01:05:57,150 --> 01:06:01,260
Αν μόλις περάσει ένα i δύο φορές
και για τα δύο σύμβολα κράτησης θέσης, printf

1343
01:06:01,260 --> 01:06:04,510
θα συνειδητοποιήσει, OH, καλά θα γνωρίζετε
μου έδωσε ένα integer-- κάποιο αριθμό,

1344
01:06:04,510 --> 01:06:06,380
όπως 65, ή 90, ή οτιδήποτε άλλο.

1345
01:06:06,380 --> 01:06:10,170
Αλλά βλέπω ότι θέλεις να
διαμορφώστε τον αριθμό αυτό σαν χαρακτήρα.

1346
01:06:10,170 --> 01:06:16,460
Και έτσι printf μπορεί να θέσει εμμέσως
το int σε μια char για σας, καθώς και.

1347
01:06:16,460 --> 01:06:19,360
Έτσι, αυτό δεν είναι ένα πρόβλημα σε όλα.

1348
01:06:19,360 --> 01:06:23,100
>> Αλλά παρατηρήσετε, εξαιτίας αυτής της ισοδυναμίας
μπορούμε πραγματικά να το κάνετε αυτό, καθώς και.

1349
01:06:23,100 --> 01:06:26,520
Επιτρέψτε μου να προχωρήσει και να κάνει ένα
άλλη εκδοχή του this-- Ascii 1.γ.

1350
01:06:26,520 --> 01:06:31,800
Και αντί για επανάληψη πάνω
ακέραιοι, μπορεί να φυσήξει πραγματικά το μυαλό σας

1351
01:06:31,800 --> 01:06:33,610
με την επανάληψη πάνω από τους χαρακτήρες.

1352
01:06:33,610 --> 01:06:37,660
Εάν ένα char c παίρνει κεφάλαιο Α, Ι
θέλουν να πάνε μπροστά και να το κάνουμε αυτό,

1353
01:06:37,660 --> 01:06:41,740
εφ 'όσον το C είναι μικρότερο ή ίσο
έως το Ω κεφαλαίου και σε κάθε επανάληψη

1354
01:06:41,740 --> 01:06:45,690
Θέλω να αυξήσετε C, μπορώ
τώρα στη γραμμή printf μου εδώ

1355
01:06:45,690 --> 01:06:51,320
ας πούμε, τοις εκατό C είναι
τοις εκατό Εγώ πάλι, κόμμα C.

1356
01:06:51,320 --> 01:06:57,200
>> Και τώρα, μπορώ να πάω την άλλη κατεύθυνση,
χύτευση το χαρακτήρα ρητά

1357
01:06:57,200 --> 01:06:58,500
σε ένα ακέραιο.

1358
01:06:58,500 --> 01:07:00,560
Έτσι, και πάλι, γιατί θα το κάνετε αυτό;

1359
01:07:00,560 --> 01:07:03,830
Είναι λίγο περίεργο να ταξινομήσετε του
μετρήσει την άποψη των χαρακτήρων.

1360
01:07:03,830 --> 01:07:07,430
>> Αλλά αν καταλαβαίνετε τι είναι
συμβαίνει κάτω από το καπό,

1361
01:07:07,430 --> 01:07:08,430
πραγματικά δεν υπάρχει μαγεία.

1362
01:07:08,430 --> 01:07:13,060
Είσαι ακριβώς λέει, hey, υπολογιστή δώσει
μένα μια μεταβλητή που ονομάζεται C τύπου char.

1363
01:07:13,060 --> 01:07:16,520
Αρχικοποίηση αυτό στο κεφάλαιο Α και
παρατηρήσετε μονά εισαγωγικά θέμα.

1364
01:07:16,520 --> 01:07:19,580
>> Για τους χαρακτήρες σε C, ανάκληση από τους
την περασμένη εβδομάδα, μπορείτε να χρησιμοποιήσετε μονά εισαγωγικά.

1365
01:07:19,580 --> 01:07:23,720
Για έγχορδα, για τα λόγια,
φράσεις, μπορείτε να χρησιμοποιήσετε διπλά εισαγωγικά.

1366
01:07:23,720 --> 01:07:27,210
OK, ο υπολογιστής, συνεχίστε να το κάνετε αυτό, έτσι
Όσο ο χαρακτήρας είναι μικρότερη από

1367
01:07:27,210 --> 01:07:28,050
ή ίση με z.

1368
01:07:28,050 --> 01:07:32,640
Και ξέρω από το τραπέζι Ascii μου ότι όλα
από αυτούς τους κωδικούς ASCII είναι συνεχόμενα.

1369
01:07:32,640 --> 01:07:33,400
>> Είναι δεν υπάρχουν κενά.

1370
01:07:33,400 --> 01:07:36,737
Γι 'αυτό ακριβώς το A έως Z,
που χωρίζονται από έναν αριθμό η κάθε μία.

1371
01:07:36,737 --> 01:07:38,820
Και τότε μπορώ να αυξήσετε
μια χαρα, αν θέλω πραγματικά.

1372
01:07:38,820 --> 01:07:40,390
Στο τέλος της μέρας,
Είναι απλά ένας αριθμός.

1373
01:07:40,390 --> 01:07:41,030
Το ξερω αυτο.

1374
01:07:41,030 --> 01:07:43,670
Έτσι απλά μπορώ να αποτολμήσω να προσθέσετε 1 σε αυτό.

1375
01:07:43,670 --> 01:07:46,940
>> Και τότε αυτή τη φορά, μπορώ να εκτυπώσω γ,
και στη συνέχεια το ολοκλήρωμα ισοδύναμο.

1376
01:07:46,940 --> 01:07:50,170
Και δεν χρειάζεται καν τη ρητή καστ.

1377
01:07:50,170 --> 01:07:52,680
Μπορώ να αφήσω printf και η
Σχήμα υπολογιστή πράγματα,

1378
01:07:52,680 --> 01:07:57,300
έτσι ώστε τώρα αν τρέχω
κάνει Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Παίρνω ακριβώς το ίδιο πράγμα, όπως καλά.

1380
01:08:01,520 --> 01:08:04,530
>> Άχρηστο πρόγραμμα, though-- κανείς
πρόκειται να γράψει πραγματικά λογισμικού

1381
01:08:04,530 --> 01:08:07,549
Για να καταλάβω, ποια ήταν η
αριθμός που αντιστοιχίζει σε Α ή Β ή Ζ;

1382
01:08:07,549 --> 01:08:10,340
Είστε ακριβώς πρόκειται να το Google ή
αναζητήστε το σε απευθείας σύνδεση, ή αναζητήστε το

1383
01:08:10,340 --> 01:08:11,650
σε μια διαφάνεια, ή τα παρόμοια.

1384
01:08:11,650 --> 01:08:13,520
Έτσι, όταν κάνει αυτό πραγματικά να πάρει χρήσιμα;

1385
01:08:13,520 --> 01:08:15,960
>> Λοιπόν, μιλώντας για ότι
slide, παρατηρήσετε υπάρχει

1386
01:08:15,960 --> 01:08:20,890
ένα πραγματικό σχέδιο εδώ μεταξύ κεφαλαίων
και πεζά που δεν ήταν τυχαία.

1387
01:08:20,890 --> 01:08:23,760
Παρατηρήστε ότι το κεφάλαιο Α είναι 65.

1388
01:08:23,760 --> 01:08:25,830
Πεζά ένας είναι 97.

1389
01:08:25,830 --> 01:08:29,649
Και πόσο μακριά είναι χαμηλότερη περίπτωση;

1390
01:08:29,649 --> 01:08:32,649
>> Έτσι, 65 είναι πόσα βήματα μακριά από το 97;

1391
01:08:32,649 --> 01:08:36,210
Έτσι, 97 μείον 65 είναι 32.

1392
01:08:36,210 --> 01:08:37,910
Έτσι κεφάλαιο ένα είναι 65.

1393
01:08:37,910 --> 01:08:39,939
Αν προσθέσετε 32 σε αυτό,
μπορείτε να πάρετε πεζά ένα.

1394
01:08:39,939 --> 01:08:43,729
Και, αντίστοιχα, αν αφαιρέσουμε 32,
μπορείτε να πάρετε πίσω στην πρωτεύουσα A-- ίδιο με το Β

1395
01:08:43,729 --> 01:08:46,380
στο μικρό β, μεγάλα C σε λίγο c.

1396
01:08:46,380 --> 01:08:50,670
>> Όλα αυτά τα κενά είναι 32 χώρια.

1397
01:08:50,670 --> 01:08:54,450
Τώρα, αυτό φαίνεται να μας επιτρέψει να
κάνει κάτι όπως το Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
ή το Google Docs διαθέτουν, όπου μπορείτε
να επιλέξετε τα πάντα και στη συνέχεια να πω,

1399
01:08:57,729 --> 01:09:00,520
τα αλλάξει όλα σε πεζά, ή
τα αλλάξει όλα με κεφαλαία γράμματα,

1400
01:09:00,520 --> 01:09:03,840
ή να αλλάξετε μόνο την πρώτη λέξη
της ποινής σε κεφαλαία.

1401
01:09:03,840 --> 01:09:07,390
Μπορούμε να κάνουμε πραγματικά κάτι
όπως κι εμείς.

1402
01:09:07,390 --> 01:09:12,645
>> Επιτρέψτε μου να προχωρήσει και να αποθηκεύσετε ένα αρχείο
εδώ ονομάζεται κεφαλαιοποιήσει 0.c.

1403
01:09:12,645 --> 01:09:15,770
Και ας πάμε μπροστά και να μαστίγιο μέχρι ένα πρόγραμμα
ότι κάνει ακριβώς αυτό ως εξής.

1404
01:09:15,770 --> 01:09:18,460
Έτσι, περιλαμβάνουν τη βιβλιοθήκη CS50.

1405
01:09:18,460 --> 01:09:21,430
Και περιλαμβάνει τις τυποποιημένες I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Και ξέρω ότι αυτό είναι σύντομα κοντά σας.

1407
01:09:22,787 --> 01:09:24,870
Έτσι, Πάω να το βάλετε στο
υπάρχουν ήδη, string.h,

1408
01:09:24,870 --> 01:09:26,960
έτσι έχω πρόσβαση σε
τα πράγματα όπως Stirling,

1409
01:09:26,960 --> 01:09:29,620
και, στη συνέχεια, int main άκυρη, ως συνήθως.

1410
01:09:29,620 --> 01:09:33,420
Και τότε Πάω να πάει μπροστά
και να κάνει χορδές παίρνει πάρει string,

1411
01:09:33,420 --> 01:09:35,032
απλά για να πάρετε μια σειρά από τον χρήστη.

1412
01:09:35,032 --> 01:09:36,740
Και τότε Πάω να
κάνετε check λογική μου.

1413
01:09:36,740 --> 01:09:40,510
Αν κορδόνι δεν είναι ίσο με null,
τότε είναι ασφαλές να προχωρήσει.

1414
01:09:40,510 --> 01:09:42,000
Και τι θέλω να κάνω;

1415
01:09:42,000 --> 01:09:48,700
Πάω να επαναλάβει από το i ισούται με 0,
και Ν μέχρι το μήκος του νήματος του s.

1416
01:09:48,700 --> 01:09:51,899
>> Και Πάω να το κάνετε αυτό, εφόσον
i είναι μικρότερο από το η, και Ι συν συν.

1417
01:09:51,899 --> 01:09:55,060
Μέχρι στιγμής, είμαι πραγματικά ακριβώς
δανεισμού ιδέες από πριν.

1418
01:09:55,060 --> 01:09:57,010
Και τώρα πάω να εισαγάγει ένα υποκατάστημα.

1419
01:09:57,010 --> 01:09:59,635
>> Έτσι σκεφτείτε πίσω στο μηδέν, όπου
είχαμε αυτά τα πιρούνια στο δρόμο,

1420
01:09:59,635 --> 01:10:05,110
και την περασμένη εβδομάδα στο Γ Πάω να
το πω αυτό, αν το i-οστό χαρακτήρα s

1421
01:10:05,110 --> 01:10:09,250
είναι μεγαλύτερο από ή
ίσο με πεζά ένα,

1422
01:10:09,250 --> 01:10:13,340
and-- στο Ξυστό θα κάνατε στην κυριολεξία
λένε και, αλλά σε C λέτε σύμβολο,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- και το i-οστό χαρακτήρα s
είναι μικρότερη ή ίση με πεζά z,

1424
01:10:19,830 --> 01:10:21,780
ας κάνουμε κάτι ενδιαφέρον.

1425
01:10:21,780 --> 01:10:27,020
Ας πραγματικότητα εκτυπώσετε μια
χαρακτήρα χωρίς αλλαγή γραμμής

1426
01:10:27,020 --> 01:10:31,760
ότι είναι ο χαρακτήρας στη συμβολοσειρά,
το i-οστό χαρακτήρα στη συμβολοσειρά.

1427
01:10:31,760 --> 01:10:37,420
>> Αλλά ας πάμε μπροστά και να
αφαιρέσουμε 32 από αυτό.

1428
01:10:37,420 --> 01:10:42,120
Αλλιώς, αν ο χαρακτήρας στο
εγχόρδων που ψάχνουμε

1429
01:10:42,120 --> 01:10:45,950
δεν είναι μεταξύ λίγο ένα
και λίγο z, προχωρήστε

1430
01:10:45,950 --> 01:10:48,610
και απλά να εκτυπωθούν αμετάβλητη.

1431
01:10:48,610 --> 01:10:50,840
Έτσι έχουμε εισαχθεί
Αυτή η παρένθεση σημειογραφία

1432
01:10:50,840 --> 01:10:53,560
για έγχορδα μας για να πάρει το
i-ου χαρακτήρα στη συμβολοσειρά.

1433
01:10:53,560 --> 01:10:57,520
>> Έχω προσθέσει κάποια υπό όρους λογικής, όπως
Scratch στην εβδομάδα μία περασμένης εβδομάδας, όπου

1434
01:10:57,520 --> 01:10:59,880
Είμαι απλά χρησιμοποιώντας τα θεμελιώδη μου
κατανόηση του τι είναι

1435
01:10:59,880 --> 01:11:01,130
συμβαίνει κάτω από το καπό.

1436
01:11:01,130 --> 01:11:04,190
Είναι το i-οστό χαρακτήρα του s
μεγαλύτερο ή ίσο προς ένα;

1437
01:11:04,190 --> 01:11:08,290
Όπως, είναι 97, ή 98,
ή 99, και ούτω καθεξής;

1438
01:11:08,290 --> 01:11:11,940
>> Αλλά είναι επίσης μικρότερο ή ίσο
με την αξία των πεζών z;

1439
01:11:11,940 --> 01:11:16,210
Και αν ναι, τι σημαίνει αυτή η γραμμή;

1440
01:11:16,210 --> 01:11:20,250
14, αυτό είναι το είδος της
φύτρο του συνόλου της ιδέας,

1441
01:11:20,250 --> 01:11:23,840
κεφαλαιοποιήσει την επιστολή
απλά αφαιρώντας 32 από αυτό,

1442
01:11:23,840 --> 01:11:29,370
σε αυτή την περίπτωση, επειδή ξέρω, ανά ότι
διάγραμμα, πώς οι αριθμοί μου εκπροσωπούνται.

1443
01:11:29,370 --> 01:11:33,925
Ας πάμε μπροστά και να τρέξει αυτό,
μετά την κατάρτιση κεφαλαιοποιήσει 0.c,

1444
01:11:33,925 --> 01:11:36,210
και τρέχει να κεφαλαιοποιήσει 0.

1445
01:11:36,210 --> 01:11:40,300
>> Ας πληκτρολογήσετε κάτι σαν
Zamyla σε όλα τα πεζά εισάγετε.

1446
01:11:40,300 --> 01:11:42,780
Και τώρα έχουμε Zamyla σε όλα τα κεφαλαία.

1447
01:11:42,780 --> 01:11:45,050
Ας πληκτρολογήσετε Rob σε όλα τα πεζά.

1448
01:11:45,050 --> 01:11:46,674
Ας προσπαθήσουμε Jason σε όλα τα πεζά.

1449
01:11:46,674 --> 01:11:48,590
Και κρατάμε πάρει το
αναγκαστική κεφαλαιοποίηση.

1450
01:11:48,590 --> 01:11:50,960
Υπάρχει ένα μικρό bug που έχω
είδος δεν είχε προβλέψει.

1451
01:11:50,960 --> 01:11:54,050
Ανακοίνωση για το νέο μου προτροπή καταλήγουν
στην ίδια γραμμή όπως τα ονόματά τους,

1452
01:11:54,050 --> 01:11:55,520
η οποία αισθάνεται λίγο βρώμικο.

1453
01:11:55,520 --> 01:11:59,170
>> Έτσι, Πάω να πάει εδώ, και
στην πραγματικότητα, στο τέλος αυτού του προγράμματος

1454
01:11:59,170 --> 01:12:02,110
εκτυπώσετε ένα χαρακτήρα νέας γραμμής.

1455
01:12:02,110 --> 01:12:03,160
Αυτό είναι όλο.

1456
01:12:03,160 --> 01:12:06,120
Με printf, δεν χρειάζεται να
περάσει σε μεταβλητές ή ο κωδικός μορφή.

1457
01:12:06,120 --> 01:12:08,460
Μπορείτε να κυριολεκτικά εκτυπώσετε
κάτι σαν μια νέα γραμμή.

1458
01:12:08,460 --> 01:12:13,529
>> Ας πάμε μπροστά και να κάνουν
κεφαλαιοποιήσει 0 και πάλι, εκτελέστε ξανά αυτό, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Και τώρα είναι λίγο πιο όμορφη.

1460
01:12:14,820 --> 01:12:17,274
Τώρα, προτροπή μου είναι από μόνη νέα γραμμή του.

1461
01:12:17,274 --> 01:12:18,440
Έτσι ώστε να είναι όλα ωραία και καλά.

1462
01:12:18,440 --> 01:12:19,910
Έτσι, αυτό είναι ένα καλό παράδειγμα.

1463
01:12:19,910 --> 01:12:22,700
Αλλά εγώ δεν κάνω καν κατ 'ανάγκην
πρέπει να σκληρό κωδικό 32.

1464
01:12:22,700 --> 01:12:23,350
Ξέρεις τι?

1465
01:12:23,350 --> 01:12:26,350
Θα μπορούσα να say-- εγώ δεν κάνω ποτέ
να θυμάστε ποια είναι η διαφορά.

1466
01:12:26,350 --> 01:12:29,330
>> Αλλά ξέρω ότι αν έχω
έχουν ένα πεζό γράμμα,

1467
01:12:29,330 --> 01:12:34,430
Θα ουσιαστικά θέλουν να αφαιρούμε
ό, τι η απόσταση είναι μεταξύ λίγο

1468
01:12:34,430 --> 01:12:39,160
μια και τα μεγάλα Α, γιατί αν υποθέσουμε ότι
όλα τα άλλα γράμματα είναι το ίδιο,

1469
01:12:39,160 --> 01:12:41,045
ότι θα πρέπει να γίνει η δουλειά.

1470
01:12:41,045 --> 01:12:42,670
Αλλά αντί να το κάνουμε αυτό, ξέρετε τι;

1471
01:12:42,670 --> 01:12:44,240
Υπάρχει ένας άλλος τρόπος ακόμα.

1472
01:12:44,240 --> 01:12:48,090
>> Αν αυτό είναι κεφαλαιοποιήσει 1.c-- αν ήμουν
να θέσω σε ένα ξεχωριστό αρχείο.

1473
01:12:48,090 --> 01:12:51,030
ας μην επωφεληθούμε 2.γ ως εξής.

1474
01:12:51,030 --> 01:12:53,060
Πάω να καθαρίσει πραγματικά αυτό εδώ.

1475
01:12:53,060 --> 01:12:57,420
Και αντί να χρειάζεται να
γνωρίζουν ή ενδιαφέρονται για αυτά τα χαμηλά επίπεδα

1476
01:12:57,420 --> 01:13:01,090
λεπτομέρειες εφαρμογής, είμαι αντί
ακριβώς πρόκειται να εκτυπώσετε ένα χαρακτήρα,

1477
01:13:01,090 --> 01:13:04,610
απόσπασμα εισαγωγικά, τοις εκατό C, και
τότε καλέστε μια άλλη λειτουργία που

1478
01:13:04,610 --> 01:13:09,950
υπάρχει ότι παίρνει ένα επιχείρημα,
η οποία είναι ένας χαρακτήρας, όπως αυτό.

1479
01:13:09,950 --> 01:13:12,630
>> Αποδεικνύεται σε C, υπάρχει
μια άλλη κλήση συνάρτησης

1480
01:13:12,630 --> 01:13:15,550
με ανώτερο, το οποίο όπως το όνομά του
προτείνει παίρνει ένα χαρακτήρα

1481
01:13:15,550 --> 01:13:19,350
και αυτό με κάνει να κεφαλαία της
ισοδύναμο, και στη συνέχεια επιστρέφει

1482
01:13:19,350 --> 01:13:21,410
έτσι ώστε printf να το συνδέσετε εκεί.

1483
01:13:21,410 --> 01:13:25,484
Και έτσι για να γίνει αυτό, όμως,
πρέπει να εισαγάγει ένα άλλο αρχείο.

1484
01:13:25,484 --> 01:13:28,400
Αποδεικνύεται ότι υπάρχει ένα άλλο αρχείο
ότι θα γνωρίζουν μόνο από την τάξη,

1485
01:13:28,400 --> 01:13:33,020
ή ένα βιβλίο, ή ένα online
αναφοράς, που ονομάζεται type.h. C

1486
01:13:33,020 --> 01:13:38,570
>> Έτσι, αν μπορώ να προσθέσω ότι μέχρι μεταξύ κεφαλίδα μου
αρχείων, και τώρα μεταγλωττίσετε ξανά το πρόγραμμα αυτό,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Ας πληκτρολογήσετε Zamyla σε όλα
πεζά, εξακολουθεί να λειτουργεί με τον ίδιο.

1489
01:13:46,690 --> 01:13:48,040
Αλλά ξέρετε τι;

1490
01:13:48,040 --> 01:13:55,590
Αποδεικνύεται ότι σε ανώτερο
έχει κάποια άλλη λειτουργικότητα.

1491
01:13:55,590 --> 01:13:58,410
>> Και επιτρέψτε μου να εισαγάγει αυτό
εντολή εδώ, είδος αδέξια

1492
01:13:58,410 --> 01:14:00,250
το όνομά του, αλλά ο άνθρωπος για χειροκίνητη.

1493
01:14:00,250 --> 01:14:03,960
Αποδεικνύεται ότι οι περισσότεροι υπολογιστές Linux,
όπως είμαστε με here-- λειτουργικό Linux

1494
01:14:03,960 --> 01:14:06,270
system-- έχουν μια εντολή
που ονομάζεται άνθρωπος, που λέει,

1495
01:14:06,270 --> 01:14:08,530
hey, υπολογιστή, να μου δώσει
το εγχειρίδιο του υπολογιστή.

1496
01:14:08,530 --> 01:14:10,680
Τι θέλεις να
κοιτάζω προς τα πάνω σε αυτό το εγχειρίδιο;

1497
01:14:10,680 --> 01:14:13,840
>> Θέλω να κοιτάζω προς τα πάνω τη λειτουργία
καλείται να ανώτερο, Enter.

1498
01:14:13,840 --> 01:14:16,070
Και είναι μια μικρή αινιγματική
να διαβάσει πολλές φορές.

1499
01:14:16,070 --> 01:14:18,780
Αλλά παρατηρήσετε είμαστε στην
εγχειρίδιο του Linux προγραμματιστή.

1500
01:14:18,780 --> 01:14:19,530
Και είναι όλο το κείμενο.

1501
01:14:19,530 --> 01:14:21,905
Και παρατηρήσετε ότι υπάρχει η
όνομα της συνάρτησης μέχρι εδώ.

1502
01:14:21,905 --> 01:14:25,030
Αποδεικνύεται ότι έχει μια ξαδέλφη που ονομάζεται
να μειώσουν, το οποίο κάνει το αντίθετο.

1503
01:14:25,030 --> 01:14:29,710
Και ειδοποίηση δυνάμει σύνοψη, για να χρησιμοποιήσετε αυτό το
λειτουργούν την σελίδα man, να το πω έτσι,

1504
01:14:29,710 --> 01:14:32,220
μου λέει ότι εγώ
πρέπει να περιλαμβάνουν γ type.h.

1505
01:14:32,220 --> 01:14:33,630
Και ήξερα ότι από την πρακτική.

1506
01:14:33,630 --> 01:14:36,210
>> Εδώ, είναι να μου δείξει τα δύο
πρωτότυπα για τη λειτουργία,

1507
01:14:36,210 --> 01:14:39,070
έτσι ώστε αν ποτέ θέλετε να χρησιμοποιήσετε αυτό το
Ξέρω τι παίρνουν ως είσοδο,

1508
01:14:39,070 --> 01:14:40,652
και τι επιστρέψει ως έξοδο.

1509
01:14:40,652 --> 01:14:42,360
Και στη συνέχεια, αν διάβασα
η περιγραφή, βλέπω

1510
01:14:42,360 --> 01:14:44,820
με περισσότερες λεπτομέρειες το τι κάνει η λειτουργία.

1511
01:14:44,820 --> 01:14:48,100
Αλλά το πιο σημαντικό, αν
Κοιτάζω κάτω τιμή επιστροφής,

1512
01:14:48,100 --> 01:14:51,710
λέει η τιμή που επιστρέφεται είναι
ότι του μετατραπέντος γράμμα,

1513
01:14:51,710 --> 01:14:57,880
ή C, η αρχική είσοδος, αν
η μετατροπή δεν ήταν δυνατή.

1514
01:14:57,880 --> 01:15:01,992
>> Με άλλα λόγια, στα ανώτατα θα προσπαθήσει
να μετατρέψετε ένα γράμμα σε κεφαλαία.

1515
01:15:01,992 --> 01:15:03,450
Και αν ναι, πρόκειται να το επιστρέψει.

1516
01:15:03,450 --> 01:15:07,010
Αλλά αν αυτό δεν μπορεί για κάποιο reason--
ίσως είναι ήδη άνω περίπτωση,

1517
01:15:07,010 --> 01:15:09,550
ίσως είναι ένα θαυμαστικό
ή κάποιο άλλο punctuation--

1518
01:15:09,550 --> 01:15:12,200
είναι ακριβώς πρόκειται να
επιστρέφει το πρωτότυπο C,

1519
01:15:12,200 --> 01:15:17,340
πράγμα που σημαίνει ότι μπορώ να κάνω τον κωδικό μου
καλύτερα σχεδιασμένη ως εξής.

1520
01:15:17,340 --> 01:15:20,580
>> Δεν χρειάζεται όλα
Αυτές οι γραμμές καταριέται του κώδικα.

1521
01:15:20,580 --> 01:15:22,610
Όλες οι γραμμές που έχω
ακριβώς τονίζεται μπορεί

1522
01:15:22,610 --> 01:15:28,700
να καταρρεύσει σε ένα μόνο απλό
γραμμή, η οποία είναι this-- τοις εκατό printf

1523
01:15:28,700 --> 01:15:33,510
c για άνω βραχίονα S i.

1524
01:15:33,510 --> 01:15:36,090
Και αυτό θα ήταν μια
παράδειγμα του καλύτερου σχεδιασμού.

1525
01:15:36,090 --> 01:15:40,040
>> Γιατί να εφαρμόσουν σε 7 ή 8 γραμμές
του κώδικα, όποια και αν ήταν εγώ απλά

1526
01:15:40,040 --> 01:15:44,960
διαγράφονται, όταν αντί να καταρρεύσει
όλα αυτή τη λογική και τη λήψη αποφάσεων

1527
01:15:44,960 --> 01:15:49,620
σε μια ενιαία γραμμή, 13 τώρα, ότι
βασίζεται σε μια βιβλιοθήκη function--

1528
01:15:49,620 --> 01:15:53,430
μια λειτουργία που έρχεται με C, αλλά ότι
κάνει ακριβώς αυτό που θέλετε να κάνετε.

1529
01:15:53,430 --> 01:15:55,295
Και, ειλικρινά, ακόμα και αν
δεν έρχονται με C,

1530
01:15:55,295 --> 01:15:58,880
θα μπορούσε να την εφαρμόσει τον εαυτό σας, όπως
έχουμε δει, με πάρει αρνητική int

1531
01:15:58,880 --> 01:16:01,700
και να πάρει θετικό int την περασμένη εβδομάδα, καθώς και.

1532
01:16:01,700 --> 01:16:03,470
>> Αυτός ο κωδικός τώρα είναι πολύ πιο ευανάγνωστο.

1533
01:16:03,470 --> 01:16:06,670
Και, πράγματι, αν μετακινηθείτε προς τα επάνω,
δείτε πόσο πιο συμπαγής

1534
01:16:06,670 --> 01:16:08,360
Αυτή η έκδοση του προγράμματος μου.

1535
01:16:08,360 --> 01:16:11,230
Είναι λίγο βαριά τώρα,
με όλα αυτά περιλαμβάνονται.

1536
01:16:11,230 --> 01:16:14,380
Αλλά αυτό είναι εντάξει, επειδή τώρα στέκομαι
στους ώμους των προγραμματιστών

1537
01:16:14,380 --> 01:16:15,300
πριν από εμένα.

1538
01:16:15,300 --> 01:16:18,440
Και όποιος ήταν που
εφαρμοστούν στην ανώτερη πραγματικά

1539
01:16:18,440 --> 01:16:21,470
μου έκανε μια χάρη, όπως και όποιος
εφαρμοστεί Stirling πραγματικά

1540
01:16:21,470 --> 01:16:24,790
μου έκανε μια χάρη πριν από λίγο καιρό.

1541
01:16:24,790 --> 01:16:26,970
Και έτσι τώρα έχουμε μια
καλύτερο πρόγραμμα σχεδίασης

1542
01:16:26,970 --> 01:16:31,680
ότι εφαρμόζει την ίδια ακριβώς λογική.

1543
01:16:31,680 --> 01:16:35,580
>> Μιλώντας του Stirling, ας
Θέλω να προχωρήσει και να το κάνουμε αυτό.

1544
01:16:35,580 --> 01:16:38,320
Επιτρέψτε μου να πάει μπροστά και να σώσει
Αυτό το αρχείο όπως stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Και αποδεικνύεται, μπορούμε να ξεκολλήσετε
ένα άλλο στρώμα αρκετά απλά τώρα.

1546
01:16:43,255 --> 01:16:45,630
Πάω να προχωρήσει και μαστίγιο
μέχρι ένα άλλο πρόγραμμα στην κύρια

1547
01:16:45,630 --> 01:16:49,759
εδώ ότι απλά ξανά υλοποιεί
μήκος συμβολοσειράς ως εξής.

1548
01:16:49,759 --> 01:16:52,300
Έτσι, εδώ είναι μια γραμμή κώδικα που
Μου παίρνει ένα string από το χρήστη.

1549
01:16:52,300 --> 01:16:53,910
Εμείς συνεχίσετε να χρησιμοποιείτε αυτό ξανά και ξανά.

1550
01:16:53,910 --> 01:16:58,900
Επιτρέψτε μου να δώσω στον εαυτό μου μια μεταβλητή που ονομάζεται
n του τύπου int που αποθηκεύει έναν αριθμό.

1551
01:16:58,900 --> 01:17:02,490
>> Και επιτρέψτε μου να πάει μπροστά και να
κάνει την εξής λογική.

1552
01:17:02,490 --> 01:17:15,610
Ενώ η n-ου χαρακτήρα s κάνει
δεν είναι ίσες backslash 0, προχωρήστε

1553
01:17:15,610 --> 01:17:17,930
και αυξήσετε n.

1554
01:17:17,930 --> 01:17:23,506
Και στη συνέχεια να εκτυπώσετε τοις εκατό printf i n.

1555
01:17:23,506 --> 01:17:29,200
Ισχυρίζομαι ότι αυτό το πρόγραμμα εδώ,
χωρίς να θέτει το μήκος των χορδών,

1556
01:17:29,200 --> 01:17:31,150
υπολογίζει το μήκος μιας συμβολοσειράς.

1557
01:17:31,150 --> 01:17:34,600
>> Και η μαγεία είναι εξ ολοκλήρου
έγκλειστα σε γραμμή 8

1558
01:17:34,600 --> 01:17:39,830
εδώ με αυτό που μοιάζει με νέα σύνταξη,
αυτό το backslash 0 σε μονά εισαγωγικά.

1559
01:17:39,830 --> 01:17:41,360
Αλλά γιατί είναι αυτό;

1560
01:17:41,360 --> 01:17:44,100
Λοιπόν, σκεφτείτε τι ήταν
συμβαίνει όλο αυτό το διάστημα.

1561
01:17:44,100 --> 01:17:47,990
>> Και ως μέρος πριν ξεχάσω, να συνειδητοποιήσουν
επίσης, ότι εκτός από τις σελίδες man

1562
01:17:47,990 --> 01:17:50,920
ότι έρχονται με ένα τυπικό
σύστημα Linux, όπως CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
συνειδητοποιήσουμε ότι εμείς, η
προσωπικό μαθήματος, έχουν επίσης

1564
01:17:53,770 --> 01:17:56,030
έκανε μια έκδοση ιστοσελίδα
αυτής της ίδιας ιδέας που ονομάζεται

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, η οποία έχει
όλες αυτές τις ίδιες σελίδες άνθρωπος,

1566
01:17:59,940 --> 01:18:02,020
όλα του ιδίου
τεκμηρίωση, καθώς και

1567
01:18:02,020 --> 01:18:05,730
ένα μικρό κουτί στο πάνω μέρος που επιτρέπει
μπορείτε να μετατρέψετε όλα τα δίκαια

1568
01:18:05,730 --> 01:18:09,025
απόκρυφες γλώσσα σε λιγότερο άνετα
κατάσταση, όπου, το διδακτικό προσωπικό,

1569
01:18:09,025 --> 01:18:12,150
έχουν περάσει και προσπάθησε να απλοποιήσει
ορισμένα από τη γλώσσα για να κρατήσει τα πράγματα

1570
01:18:12,150 --> 01:18:14,830
επικεντρώθηκε στις ιδέες, και όχι
μερικές από τις τεχνικές λεπτομέρειες.

1571
01:18:14,830 --> 01:18:20,070
Έτσι, να έχετε κατά νου, reference.cs50.net
ως μια άλλη πηγή, καθώς και.

1572
01:18:20,070 --> 01:18:23,800
>> Αλλά γιατί κάνει τη δουλειά μήκος συμβολοσειράς σε
ο τρόπος που πρότεινε πριν από λίγο;

1573
01:18:23,800 --> 01:18:25,160
Εδώ είναι και πάλι το όνομα Zamyla του.

1574
01:18:25,160 --> 01:18:27,690
Και εδώ είναι το όνομα Zamyla του
εγκλωβιστούμε σε, όπως εγώ συνεχίσω να το κάνω,

1575
01:18:27,690 --> 01:18:31,360
να ζωγραφίσει μια εικόνα του να είναι,
Πραγματικά, μόνο μια ακολουθία χαρακτήρων.

1576
01:18:31,360 --> 01:18:34,260
Αλλά Zamyla δεν υπάρχει
σε απομόνωση σε ένα πρόγραμμα.

1577
01:18:34,260 --> 01:18:37,420
>> Όταν γράφετε και να εκτελέσετε ένα πρόγραμμα,
χρησιμοποιείτε το Mac σας ή τον υπολογιστή σας

1578
01:18:37,420 --> 01:18:40,010
η μνήμη, ή μνήμη RAM να το πω έτσι.

1579
01:18:40,010 --> 01:18:42,620
Και μπορείτε να σκεφτείτε
υπολογιστή σας, όπως έχει

1580
01:18:42,620 --> 01:18:44,730
πολλά gigabytes μνήμη αυτές τις ημέρες.

1581
01:18:44,730 --> 01:18:47,700
Και μια συναυλία μέσα δισεκατομμύρια,
έτσι δισεκατομμύρια bytes.

1582
01:18:47,700 --> 01:18:48,910
>> Αλλά ας τα πίσω στο χρόνο.

1583
01:18:48,910 --> 01:18:51,530
Και ας υποθέσουμε ότι χρησιμοποιείτε
ένα πραγματικά παλιό υπολογιστή που

1584
01:18:51,530 --> 01:18:55,150
έχει μόνο 32 bytes της μνήμης.

1585
01:18:55,150 --> 01:18:59,310
Θα μπορούσα, στην οθόνη του υπολογιστή μου,
απλά σχεδιάσετε αυτό έξω ως εξής.

1586
01:18:59,310 --> 01:19:05,240
>> Θα μπορούσα απλά να πω ότι μου
υπολογιστής έχει όλη αυτή τη μνήμη.

1587
01:19:05,240 --> 01:19:08,830
Και αυτό είναι σαν ένα ραβδί μνήμης, εάν
θα θυμάστε την εικόνα μας από την τελευταία φορά.

1588
01:19:08,830 --> 01:19:11,670
Και αν εγώ απλά χωρίζουν
αυτό αρκετές φορές,

1589
01:19:11,670 --> 01:19:15,040
Ισχυρίζομαι ότι έχω 32 bytes
της μνήμης στην οθόνη.

1590
01:19:15,040 --> 01:19:18,239
>> Τώρα, στην πραγματικότητα, δεν μπορώ παρά να
αντλήσει μέχρι στιγμής σε αυτή την οθόνη εδώ.

1591
01:19:18,239 --> 01:19:20,280
Έτσι, Πάω να πάει μπροστά,
και μόνο κατά σύμβαση,

1592
01:19:20,280 --> 01:19:24,050
επιστήσει την μνήμη του υπολογιστή μου ως
πλέγμα, όχι μόνο ως μία ευθεία γραμμή.

1593
01:19:24,050 --> 01:19:28,190
Συγκεκριμένα, έχω ισχυρίζονται τώρα ότι
Αυτό το πλέγμα, αυτό 8 από 4 πλέγμα,

1594
01:19:28,190 --> 01:19:31,800
ακριβώς αντιπροσωπεύει όλα τα 32 bytes
της διαθέσιμης μνήμης στο Mac μου,

1595
01:19:31,800 --> 01:19:33,030
ή είναι διαθέσιμα στον υπολογιστή μου.

1596
01:19:33,030 --> 01:19:34,780
Και από όπου και αν το τύλιγμα
επί σε δύο γραμμές, μόλις

1597
01:19:34,780 --> 01:19:38,030
επειδή ταιριάζει περισσότερο στην οθόνη.

1598
01:19:38,030 --> 01:19:40,800
Αλλά αυτό είναι το πρώτο byte.

1599
01:19:40,800 --> 01:19:41,990
Αυτό είναι το δεύτερο byte.

1600
01:19:41,990 --> 01:19:43,300
Αυτή είναι η τρίτη byte.

1601
01:19:43,300 --> 01:19:45,310
>> Και αυτή είναι η 32η byte.

1602
01:19:45,310 --> 01:19:52,910
Ή, αν σκεφτούμε σαν έναν υπολογιστή
επιστήμονας, αυτό είναι το byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Έτσι έχετε 0-31, αν
θα αρχίσουμε να μετράμε σε 0.

1604
01:19:55,950 --> 01:19:59,830
>> Έτσι, αν χρησιμοποιήσουμε ένα πρόγραμμα
ότι οι κλήσεις πάρει string,

1605
01:19:59,830 --> 01:20:05,280
και παίρνουμε μια σειρά από το ανθρώπινο
όπως έκανα ονομάζεται Zamyla, Ζ-Α-Μ-Υ-Ι-Α,

1606
01:20:05,280 --> 01:20:09,430
Πώς στον κόσμο κάνει η
Κρατήστε τον υπολογιστή διαδρομή της οποίας byte,

1607
01:20:09,430 --> 01:20:12,230
το οποίο κομμάτι της μνήμης,
ανήκει στην οποία χορδών;

1608
01:20:12,230 --> 01:20:16,270
Με άλλα λόγια, αν προχωρούμε
πληκτρολογήστε ένα άλλο όνομα στον υπολογιστή,

1609
01:20:16,270 --> 01:20:19,890
όπως αυτό Andi, καλώντας
πάρετε κορδόνι για δεύτερη φορά,

1610
01:20:19,890 --> 01:20:23,030
Α-Ν-Δ-Ι πρέπει να καταλήγουν στην
μνήμη του υπολογιστή, καθώς και.

1611
01:20:23,030 --> 01:20:23,850
Αλλά πως?

1612
01:20:23,850 --> 01:20:29,700
>> Λοιπόν, αποδεικνύεται ότι κάτω από το
κουκούλα, τι C κάνει κατά την αποθήκευση χορδές

1613
01:20:29,700 --> 01:20:35,080
ότι η ανθρώπινη τύποι του, ή ότι
προέρχονται από κάποια άλλη πηγή, είναι

1614
01:20:35,080 --> 01:20:39,190
σκιαγραφεί το τέλος τους με
μια ειδική character-- backslash

1615
01:20:39,190 --> 01:20:44,750
0, η οποία είναι απλώς ένα ιδιαίτερο τρόπο
λέγοντας 80 bits σε μια σειρά.

1616
01:20:44,750 --> 01:20:47,950
>> Έτσι A-- αυτή είναι η ανάκληση αριθμό 97.

1617
01:20:47,950 --> 01:20:51,770
Έτσι, μερικές μοτίβο από 8 bits
αντιπροσωπεύει δεκαδικό αριθμό 97.

1618
01:20:51,770 --> 01:20:58,070
Αυτό το backslash 0 είναι κυριολεκτικά ο αριθμός
0, γνωστός και ως nul, Ν-U-L, σε αντίθεση με προηγούμενες,

1619
01:20:58,070 --> 01:20:59,630
Ν-U-L-L, η οποία μιλήσαμε για.

1620
01:20:59,630 --> 01:21:05,700
Αλλά για τώρα, απλά να ξέρετε ότι αυτή η
backslash 0 είναι μόλις 80 bits σε μια σειρά.

1621
01:21:05,700 --> 01:21:09,810
>> Και είναι ακριβώς αυτή η γραμμή στο
άμμο που λέει τίποτα προς τα αριστερά

1622
01:21:09,810 --> 01:21:12,610
ανήκει σε μία κλωστή, ή έναν τύπο δεδομένων.

1623
01:21:12,610 --> 01:21:15,480
Και τίποτα προς τα δεξιά
ανήκει σε κάτι άλλο.

1624
01:21:15,480 --> 01:21:17,440
Όνομα Andi, εν τω μεταξύ,
που μόνο οπτικά

1625
01:21:17,440 --> 01:21:21,310
συμβαίνει για να τυλίξει στο άλλο γραμμή,
αλλά αυτό είναι μόνο μια αισθητική λεπτομέρεια,

1626
01:21:21,310 --> 01:21:23,990
Ομοίως τερματίζεται Nul.

1627
01:21:23,990 --> 01:21:29,290
>> Είναι μια σειρά από χαρακτήρες ενός Α-Ν-D-I,
συν ένα πέμπτο μυστικό χαρακτήρα,

1628
01:21:29,290 --> 01:21:33,560
όλα 0 bits, που οριοθετεί μόνο
το τέλος του ονόματος Andi, καθώς και.

1629
01:21:33,560 --> 01:21:37,120
Και αν καλούμε να πάρετε κορδόνι για τρίτη φορά
στον υπολογιστή για να πάρει ένα string, όπως

1630
01:21:37,120 --> 01:21:44,210
Μαρία, Μ-Α-Ρ-Ι-Α, ομοίως είναι της Μαρίας
Το όνομά Nul τερματίστηκε με backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Αυτό είναι θεμελιωδώς διαφορετική
από το πώς ένας υπολογιστής θα συνήθως

1632
01:21:47,170 --> 01:21:51,850
αποθηκεύει έναν ακέραιο, ή float, ή άλλες
τύπους δεδομένων ακόμα, γιατί ανάκληση,

1633
01:21:51,850 --> 01:21:57,420
ένας ακέραιος είναι συνήθως 32 bits, ή
4 bytes, ή ίσως ακόμη και 64 bits,

1634
01:21:57,420 --> 01:21:59,100
ή οκτώ bytes.

1635
01:21:59,100 --> 01:22:02,620
Αλλά πολλοί πρωτόγονων σε έναν υπολογιστή
σε μια γλώσσα προγραμματισμού

1636
01:22:02,620 --> 01:22:05,550
έχουν ένα σταθερό αριθμό
bytes κάτω από το hood--

1637
01:22:05,550 --> 01:22:08,100
ίσως 1, ίσως 2, ίσως και 4, ίσως και 8.

1638
01:22:08,100 --> 01:22:13,250
>> Αλλά χορδές, από το σχεδιασμό, έχουν
δυναμική αριθμό χαρακτήρων.

1639
01:22:13,250 --> 01:22:16,980
Δεν ξέρεις εκ των προτέρων, έως ότου
τα ανθρώπινα είδη σε Ζ-Α-Μ-Υ-Ε-Α,

1640
01:22:16,980 --> 01:22:21,400
ή Μ-Α-Κ-Ι-Α, ή Α-Ν-D-I. Δεν ξέρετε
πόσες φορές ο χρήστης πρόκειται να χτυπήσει

1641
01:22:21,400 --> 01:22:22,070
το πληκτρολόγιο.

1642
01:22:22,070 --> 01:22:26,490
Ως εκ τούτου, δεν ξέρεις πώς
πολλοί χαρακτήρες εκ των προτέρων

1643
01:22:26,490 --> 01:22:27,540
θα πάμε να χρειάζονται.

1644
01:22:27,540 --> 01:22:31,840
>> Και έτσι C ακριβώς το είδος του αφήνει σαν ένα
μυστικό ψίχουλο κάτω από την κουκούλα

1645
01:22:31,840 --> 01:22:32,960
στο τέλος της σειράς.

1646
01:22:32,960 --> 01:22:39,280
Μετά από αποθήκευση Ζ-Α-Μ-Y-L-Α στη μνήμη,
Επίσης, θέτει ακριβώς το ισοδύναμο

1647
01:22:39,280 --> 01:22:40,210
μιας περιόδου.

1648
01:22:40,210 --> 01:22:45,060
Στο τέλος της ποινής,
το θέτει 80 bits, έτσι ώστε

1649
01:22:45,060 --> 01:22:49,120
να θυμηθείτε πού
Zamyla αρχίζει και τελειώνει.

1650
01:22:49,120 --> 01:22:51,490
>> Έτσι ποια είναι η σύνδεση,
Στη συνέχεια, σε αυτό το πρόγραμμα;

1651
01:22:51,490 --> 01:22:55,190
Αυτό το πρόγραμμα εδώ, Stirling,
είναι απλά ένας μηχανισμός

1652
01:22:55,190 --> 01:22:57,970
για να πάρει ένα string
από το χρήστη, γραμμή 6.

1653
01:22:57,970 --> 01:23:01,160
Γραμμή 7, δηλώνω μια μεταβλητή
καλείται ν και να το θέσει ίση με 0.

1654
01:23:01,160 --> 01:23:08,680
>> Και, στη συνέχεια, στη γραμμή 8, απλά ζήτησε από την
ερώτηση, ενώ το n-ου χαρακτήρα δεν

1655
01:23:08,680 --> 01:23:12,120
Δεν ίσο όλα 0 bits--
Με άλλα λόγια, δεν

1656
01:23:12,120 --> 01:23:14,500
ίσης αυτό το ειδικό
χαρακτήρα, backslash 0, η οποία

1657
01:23:14,500 --> 01:23:18,470
Ήταν απλά ότι η ειδική Nul character--
να προχωρήσει και μόνο αυξήσετε n.

1658
01:23:18,470 --> 01:23:21,460
>> Και συνεχίζω να, και να κρατήσει
να γίνει αυτό, και να το κάνουμε.

1659
01:23:21,460 --> 01:23:23,430
Και έτσι ακόμα κι αν το
το παρελθόν έχουμε χρησιμοποιήσει i,

1660
01:23:23,430 --> 01:23:25,181
είναι απολύτως εντάξει
σημασιολογικά για χρήση n,

1661
01:23:25,181 --> 01:23:27,430
αν είστε ακριβώς που προσπαθεί να
μετράνε αυτή τη φορά σκόπιμα,

1662
01:23:27,430 --> 01:23:28,720
και απλά θέλετε να το ονομάσετε n.

1663
01:23:28,720 --> 01:23:34,720
Έτσι, αυτό κρατά μόνο την ερώτηση,
είναι το n-ου χαρακτήρα s όλα 0s;

1664
01:23:34,720 --> 01:23:38,470
Αν όχι, δείτε την επόμενη εμφάνιση,
κοιτάξουμε το επόμενο, να δούμε στο επόμενο,

1665
01:23:38,470 --> 01:23:39,460
κοιτάξουμε το επόμενο.

1666
01:23:39,460 --> 01:23:45,540
>> Αλλά μόλις δείτε backslash 0,
Αυτό loop-- γραμμή 9 έως 11-- σταματά.

1667
01:23:45,540 --> 01:23:49,640
Μπορείτε να σπάσει έξω από το βρόχο, ενώ,
αφήνοντας μέσα αυτής της μεταβλητής n

1668
01:23:49,640 --> 01:23:54,530
μια συνολική καταμέτρηση όλων των
χαρακτήρες στη συμβολοσειρά είδατε,

1669
01:23:54,530 --> 01:23:55,660
με αυτόν τον τρόπο θα εκτύπωση.

1670
01:23:55,660 --> 01:23:56,760
Έτσι, ας προσπαθήσουμε αυτό.

1671
01:23:56,760 --> 01:23:59,500
>> Επιτρέψτε μου να προχωρήσει και χωρίς
χρησιμοποιώντας τη λειτουργία Stirling,

1672
01:23:59,500 --> 01:24:04,240
αλλά μόνο με τα δικά μου σταθεροποιητικών έκδοση
εδώ ονομάζεται Stirling, επιτρέψτε μου να πάει μπροστά

1673
01:24:04,240 --> 01:24:07,700
και τρέχει Stirling, πληκτρολογήστε σε κάτι
όπως Zamyla, το οποίο γνωρίζω εκ των προτέρων

1674
01:24:07,700 --> 01:24:08,670
είναι έξι χαρακτήρες.

1675
01:24:08,670 --> 01:24:10,080
Ας δούμε αν αυτό δουλεύει.

1676
01:24:10,080 --> 01:24:10,920
Πράγματι, είναι έξι.

1677
01:24:10,920 --> 01:24:15,257
Ας προσπαθήσουμε με τον Rob, τρεις χαρακτήρες,
τρεις χαρακτήρες, καθώς, και ούτω καθεξής.

1678
01:24:15,257 --> 01:24:17,340
Έτσι, αυτό είναι το μόνο που πρόκειται
για κάτω από το καπό.

1679
01:24:17,340 --> 01:24:19,548
Και παρατηρήστε τις συνδέσεις,
Στη συνέχεια, με την πρώτη εβδομάδα

1680
01:24:19,548 --> 01:24:22,370
της κατηγορίας, όπου μιλήσαμε για
κάτι σαν αφαίρεση,

1681
01:24:22,370 --> 01:24:26,960
το οποίο είναι ακριβώς αυτή η διαστρωμάτωση των ιδεών, ή
πολυπλοκότητα, πάνω από τις βασικές αρχές.

1682
01:24:26,960 --> 01:24:30,710
Εδώ, είμαστε είδος που αναζητούν
κάτω από την κουκούλα του Stirling,

1683
01:24:30,710 --> 01:24:33,510
να το πω έτσι, για να καταλάβω,
πώς θα πρέπει να εφαρμοστεί;

1684
01:24:33,510 --> 01:24:35,232
>> Και θα μπορούσαμε να χορηγήσει εκ νέου τον εαυτό μας.

1685
01:24:35,232 --> 01:24:37,440
Αλλά είμαστε ποτέ ξανά πρόκειται
για την εκ νέου εφαρμογή Stirling.

1686
01:24:37,440 --> 01:24:39,780
Είμαστε ακριβώς πρόκειται να
χρησιμοποιήστε Stirling, προκειμένου

1687
01:24:39,780 --> 01:24:42,100
για να πάρει πραγματικά κάποια μήκους χορδές.

1688
01:24:42,100 --> 01:24:44,200
>> Αλλά δεν υπάρχει καμία μαγική
κάτω από το καπό.

1689
01:24:44,200 --> 01:24:46,716
Εάν γνωρίζετε ότι κάτω
η κουκούλα, ένα string

1690
01:24:46,716 --> 01:24:48,090
είναι απλά μια ακολουθία χαρακτήρων.

1691
01:24:48,090 --> 01:24:51,090
Και αυτό ακολουθία χαρακτήρων
όλα μπορούν να αντιμετωπιστούν αριθμητικά

1692
01:24:51,090 --> 01:24:53,330
με στήριγμα 0, βραχίονα
1, βραχίονα 2, και

1693
01:24:53,330 --> 01:24:57,420
γνωρίζουν ότι στο τέλος μιας σειράς είναι ένα
ειδικού χαρακτήρα, μπορείτε να υπολογίσετε

1694
01:24:57,420 --> 01:25:01,710
πώς να κάνει σχεδόν οτιδήποτε σε μια
πρόγραμμα, διότι όλα βράζει κάτω σε

1695
01:25:01,710 --> 01:25:03,400
διαβάζει και γράφει μνήμης.

1696
01:25:03,400 --> 01:25:06,130
Δηλαδή, αλλάζοντας και αναζητούν
στην μνήμη, ή μετακίνηση πράγματα

1697
01:25:06,130 --> 01:25:10,940
γύρω στη μνήμη, τα πράγματα εκτύπωση
στην οθόνη, και ούτω καθεξής.

1698
01:25:10,940 --> 01:25:14,800
>> Έτσι ας χρησιμοποιήσουμε τώρα αυτό πρωτόγνωρη
κατανόηση του τι πραγματικά χορδές

1699
01:25:14,800 --> 01:25:17,910
είναι κάτω από την κουκούλα, και
φλούδα πίσω ένα άλλο στρώμα

1700
01:25:17,910 --> 01:25:20,080
ότι μέχρι τώρα έχουμε
αγνοώντας εντελώς.

1701
01:25:20,080 --> 01:25:22,650
Ειδικότερα, οποιαδήποτε στιγμή
έχουμε εφαρμόσει ένα πρόγραμμα,

1702
01:25:22,650 --> 01:25:25,930
είχαμε αυτή τη γραμμή κώδικα
κοντά στην κορυφή δηλώνοντας κύριο.

1703
01:25:25,930 --> 01:25:27,810
Και έχουμε διευκρινίζεται int main άκυρη.

1704
01:25:27,810 --> 01:25:31,240
>> Και αυτό κενό μέσα στις παρενθέσεις
έχει πει όλο αυτό το διάστημα ότι η κύρια

1705
01:25:31,240 --> 01:25:33,440
η ίδια δεν λαμβάνει κανένα επιχείρημα.

1706
01:25:33,440 --> 01:25:36,210
Κάθε εισόδου ότι ο κύριος είναι
πρόκειται να πάρει από τον χρήστη

1707
01:25:36,210 --> 01:25:39,020
πρέπει να προέρχονται από κάποια άλλη
μηχανισμού, όπως get int,

1708
01:25:39,020 --> 01:25:42,040
ή να πάρετε float, ή να πάρετε string,
ή κάποια άλλη λειτουργία.

1709
01:25:42,040 --> 01:25:44,710
Αλλά αποδεικνύεται ότι
όταν γράφετε ένα πρόγραμμα,

1710
01:25:44,710 --> 01:25:47,690
μπορείτε πραγματικά να καθορίσετε
ότι το πρόγραμμα αυτό θα

1711
01:25:47,690 --> 01:25:51,730
λαμβάνουν εισροές από το ανθρώπινο
στην ίδια την γραμμή εντολών.

1712
01:25:51,730 --> 01:25:56,310
>> Με άλλα λόγια, ακόμα κι αν μέχρι στιγμής
έχει τρέξει μόλις ./hello γεια

1713
01:25:56,310 --> 01:26:00,312
ή παρόμοια προγράμματα, το σύνολο των
άλλα προγράμματα που έχουμε χρησιμοποιήσει,

1714
01:26:00,312 --> 01:26:02,770
ότι εμείς οι ίδιοι δεν γράφουν,
έχουν ήδη λάβει, όπως φαίνεται,

1715
01:26:02,770 --> 01:26:05,210
γραμμή εντολών arguments--
τα πράγματα όπως κάνουν.

1716
01:26:05,210 --> 01:26:07,450
Λέτε κάτι σαν μάρκα,
και στη συνέχεια ένα δεύτερο λέξη.

1717
01:26:07,450 --> 01:26:10,950
Ή κλαγγή, λέτε κλαγγή, και στη συνέχεια,
μια δεύτερη λέξη, το όνομα ενός αρχείου.

1718
01:26:10,950 --> 01:26:14,410
>> Ή ακόμα και RM ή CP, όπως μπορείτε να
έχουν δει ή χρησιμοποιείται ήδη

1719
01:26:14,410 --> 01:26:15,880
για να αφαιρέσετε ή να αντιγράψετε αρχεία.

1720
01:26:15,880 --> 01:26:18,920
Όλα αυτά λαμβάνουν λεγόμενη
γραμμή εντολών arguments--

1721
01:26:18,920 --> 01:26:21,130
πρόσθετες λέξεις στο τερματικό εντολών.

1722
01:26:21,130 --> 01:26:23,260
Αλλά μέχρι τώρα,
οι ίδιοι δεν είχαν

1723
01:26:23,260 --> 01:26:27,080
Αυτό το πολυτελές τη λήψη εισόδου από το
χρήστη όταν αυτός ή αυτή τρέχει πραγματικά

1724
01:26:27,080 --> 01:26:29,120
το ίδιο το πρόγραμμα στη γραμμή εντολών.

1725
01:26:29,120 --> 01:26:33,710
>> Αλλά μπορούμε να το κάνουμε αυτό με την εκ νέου κήρυξη
κύρια κινείται προς τα εμπρός, όχι ως έχει

1726
01:26:33,710 --> 01:26:36,750
άκυρη σε παρένθεση,
αλλά αυτά τα δύο επιχειρήματα

1727
01:26:36,750 --> 01:26:40,600
instead-- το πρώτο ακέραιο,
και η δεύτερη κάτι

1728
01:26:40,600 --> 01:26:44,170
νέο, κάτι που θα πάμε να καλέσετε
μια σειρά, κάτι παρόμοιο σε πνεύμα

1729
01:26:44,170 --> 01:26:49,220
σε ό, τι είδαμε στο Scratch ως μια λίστα, αλλά
μια σειρά από χορδές, όπως θα δούμε σύντομα.

1730
01:26:49,220 --> 01:26:51,790
Αλλά ας δούμε αυτό με
Σαν παράδειγμα, πριν

1731
01:26:51,790 --> 01:26:53,690
διακρίνουμε τι ακριβώς σημαίνει αυτό.

1732
01:26:53,690 --> 01:26:56,520
>> Έτσι, αν πάω σε CS50 IDE
εδώ, έχω πάει μπροστά

1733
01:26:56,520 --> 01:27:01,840
και δήλωσε σε ένα αρχείο που ονομάζεται
argv0.c το ακόλουθο πρότυπο.

1734
01:27:01,840 --> 01:27:04,120
Και παρατηρήστε το μόνο πράγμα
αυτό είναι διαφορετικό μέχρι στιγμής

1735
01:27:04,120 --> 01:27:08,570
είναι ότι έχω αλλάξει κενό για να int
argc κορδόνι argv ανοιχτό βραχίονα, κοντά

1736
01:27:08,570 --> 01:27:09,070
υποστήριγμα.

1737
01:27:09,070 --> 01:27:11,730
Και παρατηρήσετε για τώρα, δεν υπάρχει
τίποτα μέσα από αυτές τις παρενθέσεις.

1738
01:27:11,730 --> 01:27:12,620
>> Δεν υπάρχει κανένας αριθμός.

1739
01:27:12,620 --> 01:27:15,070
Και δεν υπάρχει i, ή
n, ή οποιοδήποτε άλλο έγγραφο.

1740
01:27:15,070 --> 01:27:17,010
Είμαι απλά χρησιμοποιώντας το
αγκύλες για τώρα,

1741
01:27:17,010 --> 01:27:19,510
για λόγους που θα έρθουν
Επιστροφή στην ακριβώς σε μια στιγμή.

1742
01:27:19,510 --> 01:27:21,330
>> Και τώρα τι Πάω να κάνουμε είναι αυτό.

1743
01:27:21,330 --> 01:27:26,680
Αν argc ισούται ισούται 2--
και υπενθυμίζουν ότι ισούται με ίσων

1744
01:27:26,680 --> 01:27:30,040
είναι ο φορέας της ισότητας συγκρίνοντας
το αριστερό και το δεξί για την ισότητα.

1745
01:27:30,040 --> 01:27:31,790
Δεν είναι η εκχώρηση
χειριστή, η οποία είναι

1746
01:27:31,790 --> 01:27:36,510
το ενιαίο σύμβολο της ισότητας, η οποία σημαίνει αντίγραφο
από τα δεξιά προς τα αριστερά κάποια αξία.

1747
01:27:36,510 --> 01:27:42,840
>> Αν argc ισούται ισούται με 2, θέλω να
ας πούμε, printf, γεια σου, ποσοστά, νέα γραμμή,

1748
01:27:42,840 --> 01:27:47,340
και, στη συνέχεια, συνδέστε in-- και εδώ είναι το νέο
trick-- βραχίονα argv 1, για λόγους

1749
01:27:47,340 --> 01:27:48,840
ότι θα επανέλθουμε σε λίγο.

1750
01:27:48,840 --> 01:27:52,110
Άλλο αν argc δεν
ίσες 2, ξέρετε τι;

1751
01:27:52,110 --> 01:27:57,400
Ας πάμε μπροστά και, ως συνήθως, εκτύπωση
έξω γεια κόσμο χωρίς αντικατάσταση.

1752
01:27:57,400 --> 01:28:02,710
>> Έτσι φαίνεται ότι αν argc, τα οποία
σημαίνει καταμέτρηση επιχείρημα, ισούται με 2,

1753
01:28:02,710 --> 01:28:04,740
Πάω να εκτυπώσετε
γεια κάτι ή άλλο.

1754
01:28:04,740 --> 01:28:07,560
Διαφορετικά, από προεπιλογή, είμαι
πρόκειται να εκτυπώσετε hello world.

1755
01:28:07,560 --> 01:28:08,770
Λοιπόν, τι σημαίνει αυτό;

1756
01:28:08,770 --> 01:28:15,550
>> Λοιπόν, επιτρέψτε μου να πάω μπροστά και να σώσει
αυτό το αρχείο, και στη συνέχεια να κάνουν argv0,

1757
01:28:15,550 --> 01:28:18,940
και στη συνέχεια ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Και λέει hello world.

1759
01:28:20,300 --> 01:28:21,260
Τώρα, γιατί είναι αυτό;

1760
01:28:21,260 --> 01:28:24,730
>> Λοιπόν, αποδεικνύεται ανά πάσα στιγμή να
εκτελέσετε ένα πρόγραμμα στη γραμμή εντολών,

1761
01:28:24,730 --> 01:28:29,570
σας συμπληρώνοντας αυτό που θα
γενικά καλέσετε έναν φορέα επιχείρημα.

1762
01:28:29,570 --> 01:28:33,100
Με άλλα λόγια, αυτόματα ο
υπολογιστή, το λειτουργικό σύστημα,

1763
01:28:33,100 --> 01:28:38,340
πρόκειται να παραδώσει στο πρόγραμμά σας
η ίδια μια λίστα με όλες τις λέξεις

1764
01:28:38,340 --> 01:28:40,850
ότι η ανθρώπινη πληκτρολογήσει στο
η προτροπή, σε περίπτωση που

1765
01:28:40,850 --> 01:28:43,790
ο προγραμματιστής θέλετε να κάνετε
κάτι με αυτές τις πληροφορίες.

1766
01:28:43,790 --> 01:28:48,540
Και σε αυτή την περίπτωση, η μόνη λέξη
Έχω πληκτρολογήσει στη γραμμή είναι ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Και έτσι ο αριθμός των επιχειρημάτων που είναι
που έχουν περάσει στο πρόγραμμά μου είναι μόνο ένα.

1768
01:28:55,420 --> 01:28:58,880
Με άλλα λόγια, το επιχείρημα
μετράνε, αλλιώς γνωστή ως argc

1769
01:28:58,880 --> 01:29:00,970
εδώ ως ακέραιος, είναι μόνο μία.

1770
01:29:00,970 --> 01:29:03,000
Ένα, βέβαια, δεν είναι ίσο με δύο.

1771
01:29:03,000 --> 01:29:05,980
Και έτσι αυτό είναι που εκτυπώνει, γεια κόσμο.

1772
01:29:05,980 --> 01:29:08,170
>> Αλλά επιτρέψτε μου να εκμεταλλευτώ αυτή κάπου.

1773
01:29:08,170 --> 01:29:09,930
Επιτρέψτε μου να πω, argv0.

1774
01:29:09,930 --> 01:29:12,740
Και τότε πώς για τη Μαρία;

1775
01:29:12,740 --> 01:29:14,990
Και στη συνέχεια πατήστε Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Και παρατηρήστε τι συμβαίνει μαγικά εδώ.

1777
01:29:18,020 --> 01:29:22,640
Τώρα, αντί του κόσμου Γεια σας, έχω
άλλαξε τη συμπεριφορά αυτού του προγράμματος

1778
01:29:22,640 --> 01:29:26,310
με τη λήψη της εισόδου όχι από get
κορδόνι ή κάποια άλλη λειτουργία,

1779
01:29:26,310 --> 01:29:30,570
αλλά από την, κατά τα φαινόμενα, η εντολή μου
το ίδιο, αυτό που αρχικά πληκτρολογήσει.

1780
01:29:30,570 --> 01:29:35,720
Και μπορώ να παίξω αυτό το παιχνίδι και πάλι από
αλλαγή να Στέλιο, για παράδειγμα.

1781
01:29:35,720 --> 01:29:38,400
>> Και τώρα βλέπω ένα άλλο όνομα ακόμα.

1782
01:29:38,400 --> 01:29:40,540
Και εδώ, θα μπορούσα να πω Andi.

1783
01:29:40,540 --> 01:29:42,137
Και μπορώ να πω Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Και μπορούμε να παίξουμε αυτό το παιχνίδι όλη την ημέρα,
απλά συνδέοντας διαφορετικές τιμές,

1785
01:29:45,220 --> 01:29:49,550
εφ 'όσον θα παρέχουν ακριβώς
δύο λέξεις στη γραμμή,

1786
01:29:49,550 --> 01:29:52,260
έτσι ώστε argc, το επιχείρημά μου μετράνε, είναι 2.

1787
01:29:52,260 --> 01:29:57,240
>> Βλέπω ότι το όνομα συνδεδεμένο σε
printf, ανά αυτή την κατάσταση εδώ;

1788
01:29:57,240 --> 01:30:00,550
Έτσι, φαίνεται να έχουμε σήμερα
η εκφραστική ικανότητα

1789
01:30:00,550 --> 01:30:04,410
από τη λήψη εισόδου από άλλο μηχανισμό,
από τη λεγόμενη γραμμή εντολών,

1790
01:30:04,410 --> 01:30:07,000
αντί να χρειάζεται να περιμένετε
έως ότου ο χρήστης τρέχει το πρόγραμμα,

1791
01:30:07,000 --> 01:30:10,220
και στη συνέχεια να τον ή την προτρέψει
χρησιμοποιώντας κάτι σαν κλωστή get.

1792
01:30:10,220 --> 01:30:11,230
>> Λοιπόν, τι είναι αυτό;

1793
01:30:11,230 --> 01:30:15,010
Argc, πάλι, είναι απλά ένας ακέραιος,
ο αριθμός των words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
ότι ο χρήστης που παρέχονται στο
προτροπή, στο παράθυρο τερματικού,

1795
01:30:18,540 --> 01:30:20,110
συμπεριλαμβανομένου του ονόματος του προγράμματος.

1796
01:30:20,110 --> 01:30:23,340
Έτσι ./argv0 μας είναι, ουσιαστικά,
το όνομα του προγράμματος,

1797
01:30:23,340 --> 01:30:24,520
ή πώς θα τρέξει το πρόγραμμα.

1798
01:30:24,520 --> 01:30:25,810
>> Αυτό μετράει ως μια λέξη.

1799
01:30:25,810 --> 01:30:27,080
Έτσι argc θα είναι 1.

1800
01:30:27,080 --> 01:30:29,750
Αλλά όταν γράφω Στέλιος, ή
Andi, ή Zamyla, ή Μαρία,

1801
01:30:29,750 --> 01:30:31,660
αυτό σημαίνει ότι ο αριθμός επιχείρημα είναι δύο.

1802
01:30:31,660 --> 01:30:33,910
Και έτσι τώρα υπάρχουν δύο λέξεις που ψηφίστηκε το.

1803
01:30:33,910 --> 01:30:36,070
>> Και ειδοποίηση, μπορούμε να συνεχίσουμε αυτή τη λογική.

1804
01:30:36,070 --> 01:30:39,050
Αν μπορώ πραγματικά να πω
κάτι σαν Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
ένα πλήρες όνομα, έτσι περνώντας
τρία επιχειρήματα συνολικά,

1806
01:30:42,200 --> 01:30:47,410
Τώρα λέει η προεπιλογή και πάλι,
επειδή, φυσικά, 3 δεν ισούται 2.

1807
01:30:47,410 --> 01:30:54,080
>> Και έτσι με αυτό τον τρόπο, έχω
πρόσβαση μέσω argv αυτό το νέο επιχείρημα

1808
01:30:54,080 --> 01:30:56,080
ότι θα μπορούσαμε τεχνικά
καλέστε οτιδήποτε θέλουμε.

1809
01:30:56,080 --> 01:30:58,940
Αλλά κατά συνθήκη, είναι
argv και argc, αντίστοιχα.

1810
01:30:58,940 --> 01:31:04,470
Argv, τον φορέα επιχείρημα, είναι το είδος
των συνώνυμο για τον προγραμματισμό

1811
01:31:04,470 --> 01:31:07,140
χαρακτηριστικό στην C ονομάζεται μια σειρά.

1812
01:31:07,140 --> 01:31:14,410
>> Ένας πίνακας είναι μια λίστα με παρόμοιες τιμές
πίσω, προς τα πίσω, προς τα πίσω, προς τα πίσω.

1813
01:31:14,410 --> 01:31:17,810
Με άλλα λόγια, αν κάποιος είναι ακριβώς εδώ στο
RAM, η επόμενη θα είναι δίπλα σε αυτό,

1814
01:31:17,810 --> 01:31:18,800
και δίπλα σε αυτό.

1815
01:31:18,800 --> 01:31:20,101
Δεν είναι σε όλη τη χώρα.

1816
01:31:20,101 --> 01:31:23,100
Και αυτό το τελευταίο σενάριο, όπου τα πράγματα
είναι σε όλη τη χώρα στη μνήμη,

1817
01:31:23,100 --> 01:31:25,082
μπορεί στην πραγματικότητα να είναι ένα ισχυρό χαρακτηριστικό.

1818
01:31:25,082 --> 01:31:28,040
Αλλά θα επανέλθουμε σε αυτό όταν θα
μιλήσουμε για το φανταχτερό δομές δεδομένων.

1819
01:31:28,040 --> 01:31:32,260
Προς το παρόν, ένας πίνακας είναι μόνο ένα
κομμάτι της συνεχούς μνήμης,

1820
01:31:32,260 --> 01:31:36,520
κάθε ένα από τα στοιχεία της οποίας είναι
πίσω, προς τα πίσω, προς τα πίσω, προς τα πίσω,

1821
01:31:36,520 --> 01:31:38,050
και γενικά του ίδιου τύπου.

1822
01:31:38,050 --> 01:31:42,630
>> Έτσι, αν το σκεφτείτε, από ένα
Πριν στιγμή, αυτό είναι ένα string;

1823
01:31:42,630 --> 01:31:50,460
Λοιπόν, ένα string, όπως Zamyla,
Ζ-Α-Μ-Y-L-Α, είναι, από τεχνική άποψη,

1824
01:31:50,460 --> 01:31:51,400
απλά ένας πίνακας.

1825
01:31:51,400 --> 01:31:53,700
Είναι μια σειρά από χαρακτήρες.

1826
01:31:53,700 --> 01:31:59,250
>> Και έτσι αν θέλουμε πραγματικά να σχεδιάσετε αυτό, όπως εγώ
έκανε νωρίτερα, ως κομμάτι της μνήμης,

1827
01:31:59,250 --> 01:32:04,510
αποδεικνύεται ότι κάθε μία από αυτές
χαρακτήρες καταλαμβάνει ένα byte.

1828
01:32:04,510 --> 01:32:07,630
Και έπειτα υπάρχει το εν λόγω ειδικό
φρουρού χαρακτήρα, το backslash 0,

1829
01:32:07,630 --> 01:32:12,360
ή και οι οκτώ 0 bits, ότι
οριοθετεί το τέλος αυτής της σειράς.

1830
01:32:12,360 --> 01:32:15,090
Έτσι, ένα κορδόνι, αποδεικνύεται
έξω, αναφέρω εισαγωγικά string,

1831
01:32:15,090 --> 01:32:20,580
είναι απλά μια σειρά από chara--
char είναι ένα πραγματικό τύπο δεδομένων.

1832
01:32:20,580 --> 01:32:24,560
>> Και τώρα argv, meanwhile--
ας πάμε πίσω στο πρόγραμμα.

1833
01:32:24,560 --> 01:32:29,582
Argv, ακόμα κι αν βλέπουμε τη λέξη
συμβολοσειρά εδώ, δεν είναι η ίδια ένα string.

1834
01:32:29,582 --> 01:32:33,640
Argv, τον φορέα επιχείρημα,
είναι μια σειρά από χορδές.

1835
01:32:33,640 --> 01:32:37,620
>> Έτσι ακριβώς όπως μπορείτε να έχετε μια σειρά από
χαρακτήρες, μπορείτε να έχετε υψηλότερο επίπεδο,

1836
01:32:37,620 --> 01:32:46,279
μια σειρά από strings-- έτσι, για παράδειγμα,
όταν πληκτρολογήσει μια στιγμή πριν ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, το διάστημα Ζ-Α-Μ-Y-L-Α, Ι ισχυρίστηκε ότι
argv είχε δύο χορδές σε it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
και Ζ-Α-Μ-Y-L-A. Σε
Με άλλα λόγια, argc ήταν 2.

1839
01:33:03,185 --> 01:33:03,980
Γιατί αυτό?

1840
01:33:03,980 --> 01:33:08,370
>> Λοιπόν, αποτελεσματικά, τι συμβαίνει
on είναι ότι κάθε μία από αυτές χορδές

1841
01:33:08,370 --> 01:33:13,990
είναι, φυσικά, μια σειρά από χαρακτήρες
όπως και πριν, καθένας εκ των οποίων οι χαρακτήρες

1842
01:33:13,990 --> 01:33:15,670
καταλαμβάνει ένα byte.

1843
01:33:15,670 --> 01:33:19,720
Και μην συγχέουμε την πραγματική 0
στο όνομα του προγράμματος με το 0,

1844
01:33:19,720 --> 01:33:22,040
πράγμα που σημαίνει ότι όλα τα 80 bits.

1845
01:33:22,040 --> 01:33:27,140
Και Zamyla, εν τω μεταξύ, εξακολουθεί να είναι
επίσης μια σειρά από χαρακτήρες.

1846
01:33:27,140 --> 01:33:31,450
>> Έτσι, στο τέλος της ημέρας, πραγματικά
μοιάζει με αυτό κάτω από την κουκούλα.

1847
01:33:31,450 --> 01:33:38,800
Αλλά argv, από τη φύση του τρόπου με τον κύριο
έργα, μου επιτρέπει να τυλίξετε όλα αυτά

1848
01:33:38,800 --> 01:33:44,810
επάνω σε, αν θέλετε, ένα μεγαλύτερο φάσμα
ότι, αν έχουμε λίγο πάνω από την απλοποίηση

1849
01:33:44,810 --> 01:33:48,180
ό, τι η εικόνα μοιάζει και δεν
αρκετά να επιστήσει την κλίμακα μέχρι εκεί,

1850
01:33:48,180 --> 01:33:56,720
αυτή η συστοιχία είναι μόνο από το μέγεθος 2, η πρώτη
στοιχείο του οποίου περιέχει μια συμβολοσειρά,

1851
01:33:56,720 --> 01:33:59,230
Το δεύτερο στοιχείο της
το οποίο περιέχει μια σειρά.

1852
01:33:59,230 --> 01:34:01,687
Και, με τη σειρά του, αν
είδος μεγέθυνση σε κάθε

1853
01:34:01,687 --> 01:34:03,770
από αυτές τις χορδές, τι
δείτε κάτω από την κουκούλα

1854
01:34:03,770 --> 01:34:07,190
είναι ότι κάθε string είναι μόνο
μια σειρά από χαρακτήρες.

1855
01:34:07,190 --> 01:34:11,680
>> Τώρα, ακριβώς όπως με χορδές,
ήμασταν σε θέση να αποκτήσουν πρόσβαση

1856
01:34:11,680 --> 01:34:15,260
για το i-οστό χαρακτήρα της συμβολοσειράς
χρησιμοποιώντας το τετράγωνο συμβολισμός βραχίονα.

1857
01:34:15,260 --> 01:34:17,320
Ομοίως, με συστοιχίες
σε γενικές γραμμές, μπορούμε να κάνουμε

1858
01:34:17,320 --> 01:34:22,700
χρησιμοποιήστε πλατεία συμβολισμός βραχίονα για να πάρει
σε οποιοδήποτε αριθμό των χορδών σε μια σειρά;

1859
01:34:22,700 --> 01:34:25,100
Για παράδειγμα, επιτρέψτε μου
να προχωρήσει και να το κάνουμε αυτό.

1860
01:34:25,100 --> 01:34:32,420
>> Επιτρέψτε μου να προχωρήσει και να δημιουργήσει argv1.c,
η οποία είναι λίγο διαφορετική αυτή τη φορά.

1861
01:34:32,420 --> 01:34:35,635
Αντί για τον έλεγχο για argc2,
Πάω να αντί να το κάνετε αυτό.

1862
01:34:35,635 --> 01:34:41,270
Για int παίρνω 0, I είναι λιγότερο
από argc, εγώ συν συν,

1863
01:34:41,270 --> 01:34:47,920
και στη συνέχεια να εκτυπώσετε στο εσωτερικό αυτού,
τοις εκατό s, νέα γραμμή, και στη συνέχεια,

1864
01:34:47,920 --> 01:34:50,740
argv βραχίονα i.

1865
01:34:50,740 --> 01:34:55,220
>> Έτσι με άλλα λόγια, δεν είμαι ασχολούνται με
μεμονωμένους χαρακτήρες αυτή τη στιγμή.

1866
01:34:55,220 --> 01:35:00,190
Argv, όπως υπονοείται από αυτές κενό τετράγωνο
τιράντες στα δεξιά του ονόματος argv,

1867
01:35:00,190 --> 01:35:03,320
σημαίνει argv είναι μια σειρά από χορδές.

1868
01:35:03,320 --> 01:35:04,870
Και argc είναι απλώς μια int.

1869
01:35:04,870 --> 01:35:08,800
>> Αυτή η γραμμή εδώ, 6, είναι
λέγοντας σύνολο i ισούται με 0.

1870
01:35:08,800 --> 01:35:11,980
Μετρήστε σε όλη τη διαδρομή μέχρι το,
αλλά μη συμπεριλαμβανομένων, argc.

1871
01:35:11,980 --> 01:35:14,010
Και στη συνέχεια σε κάθε επανάληψη,
εκτυπώσετε ένα string.

1872
01:35:14,010 --> 01:35:14,800
Τι χορδών;

1873
01:35:14,800 --> 01:35:17,270
>> Το i-th κορδόνι στο argv.

1874
01:35:17,270 --> 01:35:19,530
Έτσι, ενώ πριν ήμουν
χρησιμοποιώντας την αγκύλη

1875
01:35:19,530 --> 01:35:22,180
σημειογραφία για να πάρει το i-οστό
χαρακτήρα σε μια σειρά, τώρα

1876
01:35:22,180 --> 01:35:27,240
Είμαι χρησιμοποιώντας το συμβολισμό πλατεία βραχίονα
για να πάρει στο κορδόνι i-σε μια σειρά.

1877
01:35:27,240 --> 01:35:30,310
Έτσι είναι το είδος της ένα στρώμα
παραπάνω, εννοιολογικά.

1878
01:35:30,310 --> 01:35:35,390
>> Και έτσι τι είναι πετυχημένος γι 'αυτό
πρόγραμμα τώρα, αν έχω συγκεντρώσει argv1,

1879
01:35:35,390 --> 01:35:42,067
και στη συνέχεια να κάνουμε ./argv1, και στη συνέχεια πληκτρολογήστε
σε κάτι σαν foo bar Baz,

1880
01:35:42,067 --> 01:35:45,400
ποιες είναι οι τρεις προεπιλεγμένες λέξεις που ένα
επιστήμονας υπολογιστών φτάνει για κάθε στιγμή

1881
01:35:45,400 --> 01:35:51,010
αυτός ή αυτή χρειάζεται μερικές λέξεις κράτησης θέσης,
και πατήστε Enter, κάθε μία από αυτές τις λέξεις,

1882
01:35:51,010 --> 01:35:54,980
συμπεριλαμβανομένου του ονόματος του προγράμματος, το οποίο
είναι στην argv στην πρώτη θέση,

1883
01:35:54,980 --> 01:35:58,320
καταλήγει να τυπώνεται ένα κάθε φορά.

1884
01:35:58,320 --> 01:36:05,290
Και αν μπορώ να αλλάξω αυτό, και το λέω
κάτι σαν argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
παίρνουμε και τα τρία από αυτά
Δηλαδή, η οποία είναι argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, γιατί σε αυτό το
περίπτωση argc, ο αριθμός, είναι 3.

1887
01:36:14,400 --> 01:36:20,020
>> Αλλά τι είναι τακτοποιημένο είναι αν έχετε κατανοήσει
ότι argv είναι απλά μια σειρά από χορδές,

1888
01:36:20,020 --> 01:36:24,910
και καταλαβαίνετε ότι ένα string
είναι μια σειρά από χαρακτήρες,

1889
01:36:24,910 --> 01:36:29,470
μπορούμε πραγματικά να το είδος της χρήσης αυτής της
πλατεία συμβολισμός βραχίονα πολλές φορές

1890
01:36:29,470 --> 01:36:33,320
για να επιλέξετε μια σειρά, και στη συνέχεια επιλέξτε
ένας χαρακτήρας μέσα στο string,

1891
01:36:33,320 --> 01:36:35,730
κατάδυση σε βαθύτερα ως εξής.

1892
01:36:35,730 --> 01:36:40,100
Σε αυτό το παράδειγμα, επιτρέψτε μου να πάω
προχωρήσει και να καλέσετε αυτό argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Και σε αυτό το παράδειγμα, επιτρέψτε μου να πάει μπροστά
και να κάνει το following-- για int παίρνω 0,

1895
01:36:50,180 --> 01:36:53,286
i είναι μικρότερο από argc, i συν
συν, ακριβώς όπως και πριν.

1896
01:36:53,286 --> 01:36:55,910
Έτσι με άλλα words-- και τώρα αυτό
είναι να πάρει αρκετά περίπλοκη.

1897
01:36:55,910 --> 01:36:59,940
Στη συνέχεια, Πάω να πω
επαναλάβει πάνω από χορδές σε argv,

1898
01:36:59,940 --> 01:37:01,294
ως ένα σχόλιο για τον εαυτό μου.

1899
01:37:01,294 --> 01:37:03,960
Και τότε Πάω να έχουν μια
ένθετα για το βρόχο, η οποία πιθανώς

1900
01:37:03,960 --> 01:37:06,290
έχουν κάνει, ή θεωρούνται
αυτόν τον τρόπο, το Ξυστό, όπου

1901
01:37:06,290 --> 01:37:08,600
Πάω να πω int-- είμαι
δεν πρόκειται να χρησιμοποιήσετε το i και πάλι,

1902
01:37:08,600 --> 01:37:12,590
γιατί δεν θέλω να σκιά, ή
είδος αντικαταστήσετε το υπάρχον i.

1903
01:37:12,590 --> 01:37:15,780
>> Πάω να, αντ 'αυτού, ας πούμε j, επειδή
ότι πάμε μου σε μια μεταβλητή μετά θ,

1904
01:37:15,780 --> 01:37:18,590
όταν είμαι ακριβώς που προσπαθεί να
μετρούν απλούς αριθμούς.

1905
01:37:18,590 --> 01:37:28,850
Για παίρνει ι 0-- και επίσης, ιδ, πρόκειται να
να πάρει την πρύμνη μήκος του βραχίονα argv i,

1906
01:37:28,850 --> 01:37:36,030
εφ 'όσον το j είναι μικρότερη από m,
ι συν συν, κάντε τα εξής.

1907
01:37:36,030 --> 01:37:37,500
Και εδώ είναι το ενδιαφέρον μέρος.

1908
01:37:37,500 --> 01:37:46,330
>> Εκτυπώστε ένα χαρακτήρα και μια νέα γραμμή,
συνδέοντας βραχίονα argv i, j βραχίονα.

1909
01:37:46,330 --> 01:37:47,940
Εντάξει, οπότε επιτρέψτε μου να προσθέσω κάποια σχόλια εδώ.

1910
01:37:47,940 --> 01:37:54,820
Επαναλάβει πάνω από χαρακτήρες
στο ρεύμα στοιχειοσειράς,

1911
01:37:54,820 --> 01:38:02,290
εκτύπωσης ι-ου χαρακτήρα στο i-th εγχόρδων.

1912
01:38:02,290 --> 01:38:04,630
Έτσι τώρα, ας εξετάσουμε
ποια είναι αυτά τα σχόλια σημαίνουν.

1913
01:38:04,630 --> 01:38:06,750
>> Επαναλάβει πάνω από τις χορδές
σε argv-- πόσα

1914
01:38:06,750 --> 01:38:09,300
χορδές είναι σε argv, η οποία είναι μια σειρά;

1915
01:38:09,300 --> 01:38:13,420
Argc πολλές, έτσι είμαι επανάληψη
από i ισούται με 0 έως argc.

1916
01:38:13,420 --> 01:38:20,020
Εν τω μεταξύ, πόσους χαρακτήρες
είναι το i-οστό κορδόνι στο argv;

1917
01:38:20,020 --> 01:38:22,880
>> Λοιπόν, για να πάρει την απάντηση,
Απλά καλέστε μήκος συμβολοσειράς

1918
01:38:22,880 --> 01:38:26,810
για την φροντίδα ρεύμα στοιχειοσειράς μου
περίπου, το οποίο είναι argv βραχίονα i.

1919
01:38:26,810 --> 01:38:30,090
Και Πάω να αποθηκεύουν προσωρινά ότι
αξία σε n, μόνο για τους σκοπούς της προσωρινής αποθήκευσης,

1920
01:38:30,090 --> 01:38:31,590
να το θυμάστε για την αποδοτικότητα.

1921
01:38:31,590 --> 01:38:36,330
Και τότε Πάω προετοιμασία j στο 0,
συνεχίζω εφ 'όσον j είναι μικρότερη από n,

1922
01:38:36,330 --> 01:38:38,430
και σε κάθε επανάληψη αύξηση j.

1923
01:38:38,430 --> 01:38:41,030
>> Και στη συνέχεια εδώ, ανά
το σχόλιό μου στη γραμμή 12,

1924
01:38:41,030 --> 01:38:43,390
εκτυπώσετε ένα χαρακτήρα,
ακολουθείται από μια νέα γραμμή,

1925
01:38:43,390 --> 01:38:48,140
Συγκεκριμένα argv βραχίονα
i μου δίνει το i-th εγχόρδων

1926
01:38:48,140 --> 01:38:51,690
στην argv-- έτσι την πρώτη λέξη, η
δεύτερη λέξη, η τρίτη λέξη, οτιδήποτε.

1927
01:38:51,690 --> 01:38:57,370
Και τότε καταδύσεις ι σε βαθύτερα, και παίρνει
μένα η j-th χαρακτήρα αυτής της λέξης.

1928
01:38:57,370 --> 01:39:02,200
Και έτσι, στην πραγματικότητα, μπορείτε να προσφέρετε
argv ως πολυδιάστατη,

1929
01:39:02,200 --> 01:39:06,050
ως ένα δισδιάστατο, συστοιχία,
σύμφωνα με την οποία κάθε λέξη είδος των βλεμμάτων

1930
01:39:06,050 --> 01:39:08,580
όπως αυτό στο μυαλό σας
μάτι, και κάθε χαρακτήρας

1931
01:39:08,580 --> 01:39:10,930
είναι το είδος της αποτελείται κατά
μια στήλη, αν αυτό βοηθάει.

1932
01:39:10,930 --> 01:39:13,260
>> Στην πραγματικότητα, όταν πειράζω
Αυτό πέρα ​​στο μέλλον εβδομάδες,

1933
01:39:13,260 --> 01:39:15,580
πρόκειται να είναι μια μικρή
πιο πολύπλοκη από αυτό.

1934
01:39:15,580 --> 01:39:17,800
Αλλά μπορείτε πραγματικά να
σκεφτείτε ότι, προς το παρόν,

1935
01:39:17,800 --> 01:39:22,110
όπως ακριβώς αυτό το δισδιάστατο
σειρά, σύμφωνα με την οποία ένα επίπεδο που

1936
01:39:22,110 --> 01:39:23,260
είναι όλα των χορδών.

1937
01:39:23,260 --> 01:39:26,760
Και στη συνέχεια, αν έχετε βουτήξει σε βαθύτερα,
μπορούν να πάρουν στα επιμέρους χαρακτήρες

1938
01:39:26,760 --> 01:39:29,600
σ 'αυτήν από τη χρήση αυτού του συμβολισμό εδώ.

1939
01:39:29,600 --> 01:39:31,620
>> Έτσι, αυτό είναι το καθαρό αποτέλεσμα;

1940
01:39:31,620 --> 01:39:34,970
Επιτρέψτε μου να προχωρήσει και να
να argv2-- καταριέται αυτό.

1941
01:39:34,970 --> 01:39:36,210
Έκανα ένα λάθος εδώ.

1942
01:39:36,210 --> 01:39:40,160
Εμμέσως δηλώνει η
βιβλιοθήκη Stirling λειτουργία.

1943
01:39:40,160 --> 01:39:42,190
Έτσι, όλο αυτό το διάστημα, είναι
ίσως σκόπιμο

1944
01:39:42,190 --> 01:39:45,130
ότι είμαστε το είδος του φινίρισμα
ακριβώς όπου ξεκινήσαμε.

1945
01:39:45,130 --> 01:39:48,160
>> Έχω μαντάρα, εμμέσως δηλώνοντας
βιβλιοθήκη Stirling λειτουργία.

1946
01:39:48,160 --> 01:39:48,987
ΟΚ, περιμένετε ένα λεπτό.

1947
01:39:48,987 --> 01:39:51,070
Θυμάμαι ότι, ειδικά
δεδομένου ότι είναι ακριβώς εδώ.

1948
01:39:51,070 --> 01:39:54,490
Θα πρέπει να συμπεριλάβετε string.h στην
Αυτή η έκδοση του προγράμματος.

1949
01:39:54,490 --> 01:40:00,050
>> Επιτρέψτε μου να προχωρήσει και να περιλαμβάνουν
string.h, εκτός του ότι, προχωρήστε

1950
01:40:00,050 --> 01:40:04,460
και ξαναμεταγλωττίσετε argv2.

1951
01:40:04,460 --> 01:40:08,390
Και τώρα, εδώ πηγαίνουμε, να argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Και αν και είναι λίγο
αινιγματική με την πρώτη ματιά,

1953
01:40:10,590 --> 01:40:15,690
παρατηρήσετε ότι, πράγματι, αυτό που
εκτυπώνεται είναι dot argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Αλλά αν πληκτρολογήσετε κάποιες λέξεις μετά την
προτροπή, όπως argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Εισάγετε, επίσης, μια μικρή
αινιγματική με την πρώτη ματιά.

1956
01:40:22,560 --> 01:40:30,540
Αλλά αν μετακινηθείτε προς τα πίσω επάνω,
./argv2 Ζ-Α-Μ-Y-L-Α C-H-Α-Ν.

1957
01:40:30,540 --> 01:40:32,190
Έτσι έχουμε επαναλαμβάνεται πάνω από κάθε λέξη.

1958
01:40:32,190 --> 01:40:37,770
Και, στη συνέχεια, έχουμε επαναληφθεί σ 'όλη
κάθε χαρακτήρας μέσα σε μια λέξη.

1959
01:40:37,770 --> 01:40:40,040
>> Τώρα, μετά από όλα αυτά,
συνειδητοποιούν ότι υπάρχει

1960
01:40:40,040 --> 01:40:43,120
μία άλλη λεπτομέρεια ήμασταν είδος
αγνοώντας ολόκληρη αυτή τη φορά.

1961
01:40:43,120 --> 01:40:46,180
Εμείς απλά πείραζαν πέρα ​​ό, τι
είσοδοι κύρια μπορεί να είναι;

1962
01:40:46,180 --> 01:40:47,780
Τι γίνεται με έξοδο κύριο του;

1963
01:40:47,780 --> 01:40:50,540
>> Όλα αυτό το διάστημα, έχουμε ήδη
απλά αντιγραφή και επικόλληση

1964
01:40:50,540 --> 01:40:53,870
η λέξη int μπροστά από την κύρια,
αν και μπορείτε να δείτε σε απευθείας σύνδεση,

1965
01:40:53,870 --> 01:40:58,340
μερικές φορές λανθασμένα σε παλαιότερες εκδόσεις
της C και μεταγλωττιστές, που λένε άκυρη,

1966
01:40:58,340 --> 01:40:59,410
ή τίποτα δεν σε όλα.

1967
01:40:59,410 --> 01:41:01,580
Αλλά, πράγματι, για την έκδοση
της C που χρησιμοποιείτε,

1968
01:41:01,580 --> 01:41:06,180
C 11, ή το 2011, να συνειδητοποιήσουν
ότι πρέπει να είναι int.

1969
01:41:06,180 --> 01:41:09,300
Και θα πρέπει να είναι είτε
άκυρη ή argc και argv εδώ.

1970
01:41:09,300 --> 01:41:10,790
>> Αλλά γιατί int main;

1971
01:41:10,790 --> 01:41:12,480
Τι είναι αυτό στην πραγματικότητα την επιστροφή;

1972
01:41:12,480 --> 01:41:16,280
Λοιπόν, αποδεικνύεται όλο αυτό το διάστημα,
κάθε φορά που έχω γράψει ένα κύριο πρόγραμμα

1973
01:41:16,280 --> 01:41:18,440
πάντα επιστρέφει κάτι.

1974
01:41:18,440 --> 01:41:19,960
Αλλά έχει κάνει τόσο κρυφά.

1975
01:41:19,960 --> 01:41:23,350
>> Αυτό το κάτι είναι μια
int, όπως γραμμή 5 δείχνει.

1976
01:41:23,350 --> 01:41:24,225
Αλλά τι int;

1977
01:41:24,225 --> 01:41:26,100
Λοιπόν, υπάρχει αυτό το
σύμβαση στον προγραμματισμό,

1978
01:41:26,100 --> 01:41:29,790
σύμφωνα με την οποία, εάν δεν έχει
πάει στραβά και όλα είναι καλά,

1979
01:41:29,790 --> 01:41:34,250
τα προγράμματα και τις λειτουργίες εν γένει
return-- κάπως counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 σημαίνει γενικά όλα είναι καλά.

1982
01:41:38,070 --> 01:41:40,610
Έτσι, ακόμη κι αν σκεφτείτε
ως ψευδή σε πολλές περιπτώσεις,

1983
01:41:40,610 --> 01:41:42,930
στην πραγματικότητα σημαίνει γενικά ένα καλό πράγμα

1984
01:41:42,930 --> 01:41:49,560
>> Εν τω μεταξύ, εάν ένα πρόγραμμα επιστρέφει 1,
ή αρνητική 1, ή 5, ή αρνητική 42,

1985
01:41:49,560 --> 01:41:52,941
ή μη 0 αξίας,
ότι σημαίνει γενικά

1986
01:41:52,941 --> 01:41:54,190
ότι κάτι έχει πάει στραβά.

1987
01:41:54,190 --> 01:41:56,700
Στην πραγματικότητα, για τη δική σας Mac ή PC,
μπορεί να έχετε δει στην πραγματικότητα

1988
01:41:56,700 --> 01:42:01,050
ένα μήνυμα σφάλματος, το οποίο
λέει κάτι ή άλλο, χωρίς σφάλματα

1989
01:42:01,050 --> 01:42:04,940
κωδικός αρνητικής 42, ή λάθος κωδικό
23, ή κάτι τέτοιο.

1990
01:42:04,940 --> 01:42:08,980
Αυτός ο αριθμός είναι γενικά μόνο μια υπόδειξη
στον προγραμματιστή, ή την εταιρεία

1991
01:42:08,980 --> 01:42:11,174
που έκανε το λογισμικό,
τι πήγε στραβά και γιατί,

1992
01:42:11,174 --> 01:42:13,590
έτσι ώστε να μπορεί να κοιτάξει μέσα από
τεκμηρίωση ή τον κωδικό τους,

1993
01:42:13,590 --> 01:42:15,465
και να καταλάβω ποια είναι η
σφάλματος σημαίνει στην πραγματικότητα.

1994
01:42:15,465 --> 01:42:18,400
Είναι γενικά δεν είναι
χρήσιμο για εμάς τους τελικούς χρήστες.

1995
01:42:18,400 --> 01:42:20,550
>> Αλλά όταν η κύρια επιστρέφει 0, όλα είναι καλά.

1996
01:42:20,550 --> 01:42:23,770
Και αν δεν προσδιορίζουν
ποια είναι τα κυριότερα πρέπει να επιστρέψουν,

1997
01:42:23,770 --> 01:42:26,950
Θα μόνο αυτόματα
επιστρέψετε 0 για εσάς.

1998
01:42:26,950 --> 01:42:30,870
Αλλά επιστρέφοντας κάτι
άλλος είναι πραγματικά χρήσιμη.

1999
01:42:30,870 --> 01:42:34,660
>> Σε αυτό το τελικό πρόγραμμα, επιτρέψτε μου
να προχωρήσει και να καλέσετε αυτό το exit.c,

2000
01:42:34,660 --> 01:42:38,630
και εισάγουν την τελευταία της σημερινής
θέματα, που είναι γνωστή ως έναν κωδικό σφάλματος.

2001
01:42:38,630 --> 01:42:42,930
Επιτρέψτε μου να προχωρήσει και να περιλαμβάνουν μας
εξοικειωμένοι αρχεία επάνω στην κορυφή, κάντε int main.

2002
01:42:42,930 --> 01:42:49,500
Και αυτή τη φορά, ας κάνουμε int argc,
εγχόρδων argv, και με στηρίγματα μου

2003
01:42:49,500 --> 01:42:50,836
να σημαίνει ότι είναι στη συστοιχία.

2004
01:42:50,836 --> 01:42:52,460
Και τότε επιτρέψτε μου να κάνω μια επιταγή λογική.

2005
01:42:52,460 --> 01:42:56,640
Αυτή τη φορά, αν argc δεν
ίσες 2, τότε ξέρετε τι;

2006
01:42:56,640 --> 01:42:57,520
Ξέχνα το.

2007
01:42:57,520 --> 01:43:03,170
Πάω να πω ότι, hey, ο χρήστης,
σας λείπει το επιχείρημα της γραμμής εντολών

2008
01:43:03,170 --> 01:43:04,210
backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> Και, στη συνέχεια, αυτό είναι όλο.

2010
01:43:05,230 --> 01:43:06,130
Θέλω να βγείτε.

2011
01:43:06,130 --> 01:43:11,030
Πάω να preemptively,
και πρόωρα πραγματικά, επιστροφή

2012
01:43:11,030 --> 01:43:12,810
κάτι άλλο εκτός από τον αριθμό 1.

2013
01:43:12,810 --> 01:43:15,360
Ο Συνήγορος του Πολίτη για την αξία για την πρώτη
σφάλμα που μπορεί να συμβεί είναι 1.

2014
01:43:15,360 --> 01:43:17,860
Αν έχετε κάποια άλλη λανθασμένη
κατάσταση που μπορεί να προκύψουν,

2015
01:43:17,860 --> 01:43:21,390
θα μπορούσαμε να πούμε επιστροφή 2 ή επιστροφής 3, ή
ίσως ακόμη και αρνητική 1 ή αρνητική 2.

2016
01:43:21,390 --> 01:43:23,750
>> Αυτά είναι απλά κωδικοί εξόδου
που είναι, γενικά,

2017
01:43:23,750 --> 01:43:27,770
μόνο χρήσιμη για τον προγραμματιστή, ή ο
Η εταιρεία που έχει την αποστολή του λογισμικού.

2018
01:43:27,770 --> 01:43:30,500
Αλλά το γεγονός ότι είναι
Δεν 0 είναι αυτό που είναι σημαντικό.

2019
01:43:30,500 --> 01:43:34,310
Έτσι, εάν σε αυτό το πρόγραμμα, θέλω να
εγγυάται ότι το πρόγραμμα αυτό μόνο

2020
01:43:34,310 --> 01:43:38,190
λειτουργεί αν ο χρήστης μου παρέχει
με μια καταμέτρηση επιχείρημα των δύο,

2021
01:43:38,190 --> 01:43:42,880
το όνομα του προγράμματος, και κάποια άλλα
λέξη, μπορώ να επιβάλουν όσο το εξής,

2022
01:43:42,880 --> 01:43:46,110
φωνάζω στο χρήστη με printf ρητό,
λείπει το επιχείρημα της γραμμής εντολών,

2023
01:43:46,110 --> 01:43:46,970
επιστρέψουν 1.

2024
01:43:46,970 --> 01:43:49,940
Αυτό θα είναι ακριβώς αμέσως
κλείστε το πρόγραμμα.

2025
01:43:49,940 --> 01:43:55,840
>> Μόνο αν argc ισούται με 2 θα μπορούμε να πιάσουμε
εδώ, σε ποιο σημείο Πάω να πω,

2026
01:43:55,840 --> 01:44:00,410
γεια τοις εκατό s, ανάστροφη κάθετο n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Με άλλα λόγια, είμαι
Δεν πηγαίνει μετά argv 0,

2028
01:44:03,827 --> 01:44:05,410
η οποία είναι μόνο το όνομα του προγράμματος.

2029
01:44:05,410 --> 01:44:09,450
Θέλω να εκτυπώσετε ένα γεια, κόμμα,
η δεύτερη λέξη που το ανθρώπινο πληκτρολογήσει.

2030
01:44:09,450 --> 01:44:12,580
Και σε αυτή την περίπτωση για
γραμμή 13, όλα είναι καλά.

2031
01:44:12,580 --> 01:44:15,920
>> Ξέρω ότι argc είναι 2
λογικά από αυτό το πρόγραμμα.

2032
01:44:15,920 --> 01:44:17,770
Πάω να πάει μπροστά και να επιστρέψει 0.

2033
01:44:17,770 --> 01:44:21,230
Παρεμπιπτόντως, έχετε κατά νου ότι
Αυτό είναι αληθές σε Scratch επίσης.

2034
01:44:21,230 --> 01:44:24,760
>> Λογικά, θα μπορούσα να κάνω αυτό
και συμπυκνώνουν αυτές τις γραμμές

2035
01:44:24,760 --> 01:44:27,020
του κώδικα σε αυτό το άλλο ρήτρα εδώ.

2036
01:44:27,020 --> 01:44:29,420
Αλλά αυτό είναι το είδος της
άσκοπα εσοχή κωδικό μου.

2037
01:44:29,420 --> 01:44:31,800
Και θέλω να υπερ
σαφές ότι αυτό δεν έχει σημασία,

2038
01:44:31,800 --> 01:44:34,670
από προεπιλογή, γεια
κάτι που θα εκτυπωθεί,

2039
01:44:34,670 --> 01:44:36,050
εφ 'όσον ο χρήστης συνεργάζεται.

2040
01:44:36,050 --> 01:44:39,360
>> Έτσι είναι πολύ κοινό να χρησιμοποιήσει
μια κατάσταση, απλά μια περίπτωση,

2041
01:44:39,360 --> 01:44:41,870
να πιάσει κάποια λανθασμένη
κατάσταση, και στη συνέχεια την έξοδο.

2042
01:44:41,870 --> 01:44:45,690
Και στη συνέχεια, εφ 'όλα είναι
καλά, δεν έχουν ένα άλλο,

2043
01:44:45,690 --> 01:44:48,060
αλλά απλώς έχουν τον κωδικό
εκτός ότι αν, επειδή είναι

2044
01:44:48,060 --> 01:44:51,060
ισοδύναμο με αυτό
συγκεκριμένη περίπτωση, λογικά.

2045
01:44:51,060 --> 01:44:54,480
Έτσι είμαι επιστρέφουν 0, ακριβώς για να
δηλώνουν ρητά ότι όλα είναι καλά.

2046
01:44:54,480 --> 01:44:58,480
>> Αν έχω παραλείψει την επιστροφή 0, θα ήταν
να υποτεθεί αυτόματα για μένα.

2047
01:44:58,480 --> 01:45:00,890
Αλλά τώρα που είμαι επιστρέφουν
ένα σε τουλάχιστον αυτή την περίπτωση,

2048
01:45:00,890 --> 01:45:04,940
Πάω να, για το καλό μέτρο και
σαφήνεια, επιστρέφουν 0 στην περίπτωση αυτή.

2049
01:45:04,940 --> 01:45:09,690
Έτσι τώρα επιτρέψτε μου να προχωρήσει και να κάνει την έξοδο,
το οποίο είναι ένα τέλειο segue σε μόλις φύγει.

2050
01:45:09,690 --> 01:45:14,401
>> Αλλά να κάνει την έξοδο, και επιτρέψτε μου να πάω
μπροστά και να κάνουμε ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Και το πρόγραμμα φώναξε σε μένα,
λείπει το επιχείρημα της γραμμής εντολών.

2052
01:45:16,900 --> 01:45:18,120
Εντάξει, επιτρέψτε μου να συνεργάζονται.

2053
01:45:18,120 --> 01:45:23,810
>> Επιτρέψτε μου αντί να κάνει ./exit, Ντέιβιντ, Enter.

2054
01:45:23,810 --> 01:45:25,190
Και τώρα λέει, γειά σου Δαβίδ.

2055
01:45:25,190 --> 01:45:27,300
Και κανονικά δεν θα δείτε αυτό.

2056
01:45:27,300 --> 01:45:30,650
>> Αλλά αποδεικνύεται ότι υπάρχει μια
ιδιαίτερο τρόπο στο Linux για να δούμε πραγματικά

2057
01:45:30,650 --> 01:45:34,470
με ποιο έξοδο κώδικα ενός προγράμματος αποχώρησε.

2058
01:45:34,470 --> 01:45:37,184
Μερικές φορές, σε μια γραφική
κόσμο, όπως το Mac OS ή Windows,

2059
01:45:37,184 --> 01:45:40,100
βλέπετε μόνο τους αριθμούς αυτούς, όταν ένα
μήνυμα σφάλματος εμφανίζεται στην οθόνη

2060
01:45:40,100 --> 01:45:41,940
και ο προγραμματιστής
σας δείχνει τον αριθμό αυτό.

2061
01:45:41,940 --> 01:45:44,773
Αλλά αν θέλουμε να δούμε ποιο είναι το σφάλμα
μήνυμα είναι, μπορούμε να το κάνουμε here--

2062
01:45:44,773 --> 01:45:48,100
έτσι ./exit, Enter, εκτύπωση
λείπει το επιχείρημα της γραμμής εντολών.

2063
01:45:48,100 --> 01:45:54,590
>> Αν εγώ τώρα κάνω echo $ ?, η οποία είναι
γελοία αινιγματικό ψάχνετε.

2064
01:45:54,590 --> 01:45:56,590
Αλλά $;

2065
01:45:56,590 --> 01:45:59,220
είναι το μαγικό ξόρκι
που λέει, hey, ηλεκτρονικών υπολογιστών,

2066
01:45:59,220 --> 01:46:01,900
πες μου τι το προηγούμενο
κωδικό εξόδου του προγράμματος ήταν.

2067
01:46:01,900 --> 01:46:03,410
Και εγώ πατήστε Enter.

2068
01:46:03,410 --> 01:46:07,520
Βλέπω 1, γιατί αυτό είναι που εγώ
είπε κύρια λειτουργία μου να επιστρέψει.

2069
01:46:07,520 --> 01:46:12,310
>> Εν τω μεταξύ, αν το κάνω ./exit David,
και πατήστε Enter, βλέπω, γεια David.

2070
01:46:12,310 --> 01:46:16,800
Κι αν τώρα κάνω echo $ ?, βλέπω γεια 0.

2071
01:46:16,800 --> 01:46:19,080
Και έτσι αυτό θα είναι πράγματι
είναι πολύτιμες πληροφορίες

2072
01:46:19,080 --> 01:46:23,420
στο πλαίσιο του προγράμματος εντοπισμού σφαλμάτων, δεν είναι τόσο
πολύ ότι, το ανθρώπινο, θα με νοιάζει.

2073
01:46:23,420 --> 01:46:26,060
Αλλά το πρόγραμμα εντοπισμού σφαλμάτων και άλλα
προγράμματα θα χρησιμοποιήσουμε αυτό το εξάμηνο

2074
01:46:26,060 --> 01:46:29,420
θα δούμε συχνά σε αυτόν τον αριθμό,
ακόμα κι αν αυτό είναι το είδος της κρυμμένα

2075
01:46:29,420 --> 01:46:32,780
εκτός και αν το ψάξετε, να
καθορίσει εάν ένα πρόγραμμα ή όχι

2076
01:46:32,780 --> 01:46:37,050
εκτέλεσης ήταν σωστή ή λανθασμένη.

2077
01:46:37,050 --> 01:46:40,450
>> Και έτσι αυτό μας φέρνει στο
αυτό, στο τέλος της ημέρας.

2078
01:46:40,450 --> 01:46:43,917
Ξεκινήσαμε σήμερα με την εξέταση
τον εντοπισμό σφαλμάτων, και με τη σειρά του στο γήπεδο

2079
01:46:43,917 --> 01:46:46,750
μόνη της, και στη συνέχεια πιο ενδιαφέροντα,
τεχνικά κάτω από την κουκούλα

2080
01:46:46,750 --> 01:46:49,490
σε ποιο χορδές είναι, που διαρκούν
την εβδομάδα που μόλις πήρε για δεδομένος,

2081
01:46:49,490 --> 01:46:51,900
και σίγουρα τους πήρε
δεδομένο το Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Στη συνέχεια κοίταξε πώς μπορούμε να έχουμε πρόσβαση
μεμονωμένους χαρακτήρες σε μια σειρά,

2083
01:46:56,040 --> 01:47:00,310
και στη συνέχεια πήρε και πάλι ένα υψηλότερο επίπεδο
δούμε τα πράγματα, εξετάζοντας το πώς well--

2084
01:47:00,310 --> 01:47:04,226
αν θέλουμε να πάρει σε ατομικό
στοιχεία σε μια λίστα, όπως δομή,

2085
01:47:04,226 --> 01:47:05,850
Δεν μπορούμε να το κάνουμε αυτό με πολλαπλές χορδές;

2086
01:47:05,850 --> 01:47:08,050
Και μπορούμε με τα επιχειρήματα της γραμμής εντολών.

2087
01:47:08,050 --> 01:47:12,800
Αλλά αυτή η εικόνα εδώ ακριβώς κουτιά
είναι εκδηλωτικός αυτής γενικής ιδέας

2088
01:47:12,800 --> 01:47:14,451
ενός πίνακα ή μια λίστα, ή φορέα.

2089
01:47:14,451 --> 01:47:16,450
Και ανάλογα με το
πλαίσιο, όλες αυτές τις λέξεις

2090
01:47:16,450 --> 01:47:17,880
σημαίνει ελαφρώς διαφορετικά πράγματα.

2091
01:47:17,880 --> 01:47:20,060
Έτσι σε C, θα πρόκειται μόνο
για να μιλήσουμε για μια σειρά.

2092
01:47:20,060 --> 01:47:23,840
Και μια σειρά είναι ένα κομμάτι
της μνήμης, καθένας από τους οποίους είναι

2093
01:47:23,840 --> 01:47:27,720
στοιχεία είναι συνεχόμενα, την πλάτη,
προς τα πίσω, προς τα πίσω, προς τα πίσω.

2094
01:47:27,720 --> 01:47:31,970
>> Και τα στοιχεία αυτά είναι, σε γενικές γραμμές,
του ίδιου τύπου δεδομένων, το χαρακτήρα,

2095
01:47:31,970 --> 01:47:35,966
χαρακτήρα, χαρακτήρα, χαρακτήρα, ή
string, string, string, string, ή int,

2096
01:47:35,966 --> 01:47:38,600
int, int, ό, τι είναι
προσπαθούμε να κατάστημα.

2097
01:47:38,600 --> 01:47:42,540
Αλλά στο τέλος της ημέρας, αυτό είναι
τι μοιάζει εννοιολογικά.

2098
01:47:42,540 --> 01:47:44,530
Παίρνετε σας
μνήμης ή RAM του υπολογιστή.

2099
01:47:44,530 --> 01:47:48,590
Και είστε το αποσύρουν σε
πανομοιότυπα μεγέθους κουτιά, τα οποία όλα

2100
01:47:48,590 --> 01:47:50,920
είναι πίσω, προς τα πίσω, για να
πίσω, προς τα πίσω με αυτόν τον τρόπο.

2101
01:47:50,920 --> 01:47:53,200
>> Και τι είναι ωραίο για
Αυτή η ιδέα, και το γεγονός

2102
01:47:53,200 --> 01:47:58,580
ότι μπορούμε να εκφράσουμε τις τιμές με τον τρόπο αυτό
με την πρώτη από τις δομές δεδομένων μας

2103
01:47:58,580 --> 01:48:02,520
στην τάξη, σημαίνει ότι μπορεί να ξεκινήσει
να λύσει τα προβλήματα με κωδικό

2104
01:48:02,520 --> 01:48:04,079
ότι ήρθε τόσο διαισθητικά στην εβδομάδα 0.

2105
01:48:04,079 --> 01:48:05,870
Θα θυμηθούμε το τηλέφωνο
παράδειγμα το βιβλίο, όπου

2106
01:48:05,870 --> 01:48:09,110
χρησιμοποιήσαμε ένα διαίρει και βασίλευε,
ή μια δυαδική αναζήτηση,

2107
01:48:09,110 --> 01:48:13,220
να κοσκινίσει μέσω μιας ολόκληρης
δέσμη των ονομάτων και αριθμών.

2108
01:48:13,220 --> 01:48:18,220
Αλλά εμείς υποτίθεται, ανάκληση, ότι
τηλεφωνικό είχε ήδη διευθετηθεί,

2109
01:48:18,220 --> 01:48:21,630
ότι κάποιος άλλος είχε ήδη
κατάλαβα out-- δίνεται μια λίστα με τα ονόματα

2110
01:48:21,630 --> 01:48:24,430
και numbers-- πώς να τα alphabetize.

2111
01:48:24,430 --> 01:48:26,950
Και τώρα που σε C εμείς,
επίσης, έχουν την ικανότητα

2112
01:48:26,950 --> 01:48:30,290
να θέσει τα πράγματα, δεν
σωματικά σε ένα τηλεφωνικό κατάλογο

2113
01:48:30,290 --> 01:48:34,220
αλλά σχεδόν σε ένα υπολογιστή
μνήμη, θα είμαστε σε θέση την επόμενη εβδομάδα

2114
01:48:34,220 --> 01:48:38,470
να εισαγάγει και πάλι this-- πρώτη
δομών δεδομένων μας σε ένα array--

2115
01:48:38,470 --> 01:48:43,530
αλλά το πιο σημαντικό, πραγματικό υπολογιστή
επιστήμη αλγόριθμοι εφαρμόζονται

2116
01:48:43,530 --> 01:48:47,720
στον κώδικα, με το οποίο μπορούμε να αποθηκεύσουμε
δεδομένα σε δομές όπως αυτό,

2117
01:48:47,720 --> 01:48:50,730
και στη συνέχεια να αρχίσουν να το χειραγωγήσουν, και
να λύσει πραγματικά προβλήματα με αυτό,

2118
01:48:50,730 --> 01:48:53,570
και να χτίσει στην κορυφή του ότι,
τελικά, τα προγράμματα σε C,

2119
01:48:53,570 --> 01:48:56,730
σε Python, το JavaScript,
διερευνούν τις βάσεις δεδομένων με τον SQL;

2120
01:48:56,730 --> 01:48:59,980
>> Και θα δείτε ότι όλα αυτά
διαφορετικές ιδέες αλληλοσυνδέονται.

2121
01:48:59,980 --> 01:49:04,100
Αλλά για τώρα, να υπενθυμίσω ότι η
τομέα που παρουσιάσαμε σήμερα

2122
01:49:04,100 --> 01:49:06,920
ήταν αυτό το πράγμα εδώ, και
ο κόσμος της κρυπτογραφίας.

2123
01:49:06,920 --> 01:49:11,200
Και μεταξύ τους επόμενους εσείς προβλήματα
θα λύσει είναι η τέχνη της κρυπτογραφίας,

2124
01:49:11,200 --> 01:49:13,630
κρυπτογράφησης και αποκρυπτογράφηση
πληροφοριών, και κρυπτογράφηση

2125
01:49:13,630 --> 01:49:15,930
και αποκρυπτογράφηση κειμένου,
και υποθέτοντας ότι, τελικά,

2126
01:49:15,930 --> 01:49:18,970
ότι ξέρετε τώρα τι
είναι κάτω από την κουκούλα

2127
01:49:18,970 --> 01:49:21,860
έτσι ώστε όταν βλέπετε ή να λάβετε
ένα μήνυμα σαν αυτό,

2128
01:49:21,860 --> 01:49:24,060
τον εαυτό σας μπορεί να το αποκρυπτογραφήσει.

2129
01:49:24,060 --> 01:49:26,740
Όλα αυτά, και περισσότερο την επόμενη φορά.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [ΑΝΑΠΑΡΑΓΩΓΉ ΒΊΝΤΕΟ]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Μόλις έφτασε.

2133
01:49:32,970 --> 01:49:35,146
Πάω να πάει επίσκεψη
καθηγητής κολεγίου του.

2134
01:49:35,146 --> 01:49:37,611
Ναι.

2135
01:49:37,611 --> 01:49:40,080
Γεια.

2136
01:49:40,080 --> 01:49:40,660
Είσαι εσύ.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Περιμένετε!

2139
01:49:45,110 --> 01:49:45,610
Δαβίδ.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Είμαι απλώς προσπαθώ να καταλάβω
τι συνέβη σε σας.

2142
01:49:56,060 --> 01:49:58,130
Παρακαλούμε, οτιδήποτε θα μπορούσε να βοηθήσει.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Ήσουν κολέγιο του
συγκάτοικο, δεν ήσουν;

2145
01:50:08,354 --> 01:50:10,770
Ήσουν εκεί μαζί του, όταν
τελείωσε το έργο CS50;

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [ΜΟΥΣΙΚΗ Playing]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -ότι Ήταν CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Αγαπώ αυτό το μέρος.

2152
01:50:44,770 --> 01:50:45,854
>> -Φάε.

2153
01:50:45,854 --> 01:50:47,020
Εμείς πάμε έξω από τις επιχειρήσεις.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [ΤΕΛΟΣ ΑΝΑΠΑΡΑΓΩΓΗ]

