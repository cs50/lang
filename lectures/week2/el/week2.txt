[ΜΟΥΣΙΚΗ Playing] 

DAVID J. Malan: Εντάξει. Αυτό είναι CS50 και αυτό είναι η αρχή της Εβδομάδας 2. Και θα θυμάστε ότι πάνω από τις τελευταίες δύο εβδομάδες, έχουμε την εισαγωγή του υπολογιστή επιστήμη και, με τη σειρά του, τον προγραμματισμό. 

Και αρχίσαμε την ιστορία μέσω της Το μηδέν, ώστε γραφική γλώσσα από το Media Lab του MIT. Και στη συνέχεια πιο πρόσφατα, την περασμένη εβδομάδα, κάναμε εισαγάγει ένα higher-- ένα γλώσσα χαμηλότερου επιπέδου γνωστή όπως C, κάτι που είναι καθαρά κειμένου. Και, πράγματι, την τελευταία φορά που διερευνηθεί σε αυτό το πλαίσιο διάφορες έννοιες. 

Αυτό, ανάκληση, ήταν το πολύ πρώτο πρόγραμμα κοιτάξαμε. Και το πρόγραμμα αυτό, πολύ απλά, εκτυπώνει, "γειά σου, τον κόσμο." Αλλά υπάρχει τόσο πολύ φαινομενική μαγεία συμβαίνει. Υπάρχει αυτό το #include με αυτές τις γωνιακές αγκύλες. Υπάρχει int. Υπάρχει (άκυρο). Υπάρχει παρενθέσεις, αγκύλες, ημι-παχύ έντερο, και πολύ περισσότερα. 

Και έτσι, υπενθυμίζουν ότι εισαγάγαμε Scratch έτσι ώστε να μπορούμε, στην ιδανική περίπτωση, δείτε το παρελθόν ότι η σύνταξη, η ουσία που δεν είναι πραγματικά όλα αυτά πνευματικά ενδιαφέρουσα, αλλά νωρίς είναι, απολύτως, είναι λίγο δύσκολο να τυλίξουν το μυαλό σας γύρω. Και, πράγματι, ένα από τα πιο κοινά τα πράγματα από νωρίς σε μια κατηγορία προγραμματισμού, Ειδικά για εκείνους λιγότερο άνετα, είναι να πάρει απογοητευμένοι από και σκόνταψε πάνω από ορισμένες συντακτικές σφάλματα, για να μην αναφέρουμε λογικά σφάλματα. Και έτσι στους στόχους μας Σήμερα, στην πραγματικότητα, θα είναι να σας εξοπλίσει με μερικές τεχνικές επίλυσης προβλημάτων για το πώς να λύσει καλύτερα τον εαυτό τους προβλήματα με τη μορφή εντοπισμού σφαλμάτων. Και θα θυμάστε, επίσης, ότι η περιβάλλον που εισαγάγαμε τελευταία φορά που κλήθηκε CS50 IDE. Αυτό είναι web-based λογισμικό που Σας επιτρέπει να προγραμματίσετε στο σύννεφο, να το πω έτσι, διατηρώντας παράλληλα όλες σας αρχεία μαζί, όπως θα είναι και πάλι σήμερα. Και υπενθυμίζουν ότι εμείς επανεξεταστούν αυτά τα θέματα εδώ, μεταξύ τους λειτουργίες, και βρόχους, και μεταβλητές, και Boolean εκφράσεις, και προϋποθέσεις. Και στην πραγματικότητα μερικές ακόμα ότι εμείς μεταφράστηκε από τον κόσμο του Scratch στον κόσμο του C. 

Αλλά το βασικό κτίριο μπλοκ, να το πω έτσι, ήταν πραγματικά ακόμα το ίδιο την περασμένη εβδομάδα. Στην πραγματικότητα, έχουμε πραγματικά ακριβώς είχε διαφορετικό κομμάτι του παζλ, αν θέλετε. Αντί αυτού του μοβ αποθηκεύσετε μπλοκ, εμείς αντί είχε printf, η οποία είναι αυτή η λειτουργία σε c που Σας επιτρέπει να εκτυπώσετε κάτι και διαμορφώστε στην οθόνη. Εισαγάγαμε το CS50 Βιβλιοθήκη, σας όπου έχουν τώρα στη διάθεσή σας get_char, και get_int, και get_string, και μερικές άλλες λειτουργίες, όπως επίσης, μέσω του οποίου μπορείτε να πάρετε είσοδο από τη δική πληκτρολόγιο του χρήστη. Και πήραμε επίσης μια ματιά στα πράγματα όπως αυτά-bool και char, και δίκλινα, float, int, long_long εγχόρδων. Και υπάρχει ακόμη και άλλους τύπους δεδομένων στη C. 

Με άλλα λόγια, όταν δηλώνετε μια μεταβλητή για να αποθηκεύσετε κάποια αξία, ή όταν εφαρμόζετε μια λειτουργία ότι επιστρέφει κάποια τιμή, μπορείτε να καθορίσετε τι είδος της τιμής που είναι. Είναι ένα string, όπως ένα ακολουθία χαρακτήρων; Είναι ένας αριθμός, σαν ένα ακέραιο; Είναι ένα πλωτό σημείο αξία, ή κάτι παρόμοιο; Έτσι σε C, σε αντίθεση με το μηδέν, στην πραγματικότητα άρχισε να καθορίσετε τι είδους δεδομένα είχαμε την επιστροφή ή τη χρήση. 

Αλλά, φυσικά, τρέξαμε επίσης υπόψη ορισμένες θεμελιώδεις όρια των υπολογιστών. Και ειδικότερα, Αυτή η γλώσσα C, ανάκληση ότι πήραμε μια ματιά υπερχείλιση ακεραίου, η πραγματικότητα ότι αν έχετε μόνο ένα πεπερασμένη ποσότητα μνήμης ή, ειδικότερα, ένας πεπερασμένος αριθμός των bits, το μόνο που μπορεί να μετρήσει τόσο υψηλή. Και έτσι κοιτάξαμε αυτό το παράδειγμα εδώ σύμφωνα με την οποία ένας μετρητής σε ένα αεροπλάνο,, στην πραγματικότητα, εάν τρέχει αρκετά μεγάλο χρονικό διάστημα θα ξεχειλίσει και να οδηγήσει σε ένα λογισμικό μια πραγματική φυσική δυνητικό σφάλμα. 

Εξετάσαμε επίσης επιπλέει σημείο ανακρίβεια, η πραγματικότητα ότι με μόνο έναν πεπερασμένο αριθμό των bits, είτε πρόκειται για 32 ή 64, μπορείτε να καθορίσετε μόνο τόσο πολλούς αριθμούς μετά την υποδιαστολή, μετά την οποία θα αρχίζουν να πάρει ανακριβή. Έτσι, για παράδειγμα, το ένα τρίτο στο κόσμο εδώ, στον ανθρώπινο κόσμο μας, Γνωρίζουμε ότι μόνο ένας άπειρος αριθμός της 3s μετά την υποδιαστολή. Αλλά ένας υπολογιστής δεν μπορεί κατ 'ανάγκη αντιπροσωπεύουν έναν άπειρο αριθμό των αριθμών αν επιτρέψετε μόνο ότι κάποιοι πεπερασμένη ποσότητα των πληροφοριών. 

Έτσι, όχι μόνο δεν θα σας εξοπλίσει με μεγαλύτερη δύναμη από την άποψη για το πώς μπορείτε να εκφραστείτε σε ένα πληκτρολόγιο όσον αφορά τον προγραμματισμό, θα περιορίζονται επίσης τι μπορείτε πραγματικά να κάνετε. Και πράγματι, τα σφάλματα και τα λάθη μπορούν να προκύπτουν από τέτοιου είδους θέματα. Και πράγματι, μεταξύ των θεμάτων που σήμερα πρόκειται να είναι θέματα όπως εντοπισμός σφαλμάτων και πραγματικά ψάχνει κάτω από την κουκούλα πώς εισήχθησαν τα πράγματα την περασμένη εβδομάδα εφαρμόζονται πραγματικά έτσι ώστε να μπορείτε καλύτερα κατανοήσουν τόσο οι δυνατότητες και οι περιορισμοί μιας γλώσσας όπως η C. 

Και στην πραγματικότητα, θα ξεφλουδίσετε πίσω τα στρώματα της απλούστερης δομής δεδομένων, κάτι που ονομάζεται μια σειρά, η οποία Scratch συμβαίνει να καλέσετε μια "λίστα". Είναι ένα μικρό κομμάτι διαφορετικά σε αυτό το πλαίσιο. Και τότε θα εισάγουν επίσης ένα από τα πρώτα προβλήματα σε συγκεκριμένους τομείς μας σε CS50, ο κόσμος του κρυπτογραφία, η τέχνη της κρυπτογράφησης ή σε κρυπτογραφήσεως πληροφορίες τόσο ότι μπορείτε να στείλετε μυστικά μηνύματα και να αποκωδικοποιήσει μυστικά μηνύματα μεταξύ δύο ατόμων, Α και Β 

Έτσι, πριν από τη μετάβαση μας σε αυτό το νέο κόσμο, ας προσπαθήσουμε να σας εξοπλίσει με μερικές τεχνικές με τις οποίες μπορείτε να εξαλείψει ή να μειώσει τουλάχιστον κάποια των απογοητεύσεις ότι έχετε αντιμετωπίσει κατά πάσα πιθανότητα πάνω από μόνα τους την περασμένη εβδομάδα. Στην πραγματικότητα, μπροστά από εσάς such-- μερικά από την πρώτη σας προβλήματα στην C. Και οι πιθανότητες είναι, αν είστε σαν εμένα, είναι η πρώτη φορά μπορείτε να δοκιμάσετε να πληκτρολογήσετε ένα πρόγραμμα, ακόμη και αν νομίζετε ότι λογικά το πρόγραμμα είναι αρκετά απλή, θα μπορούσε κάλλιστα να χτυπήσει έναν τοίχο, και ο compiler δεν πρόκειται να συνεργαστεί. Κάνει ή Clang δεν πρόκειται να κάνει πραγματικά την προσφορά σας. 

Και γιατί θα μπορούσε αυτό να είναι; Λοιπόν, ας ρίξουμε μια ματιά στο, ίσως, ένα απλό πρόγραμμα. Πάω να πάει μπροστά και να σώσει αυτό το ένα αρχείο σκόπιμα ονομάζεται buggy0.c, γιατί ξέρω να να λανθασμένη εκ των προτέρων. Αλλά εγώ μπορεί να μην συνειδητοποιούν ότι αν αυτό είναι το πρώτο ή το δεύτερο ή τρίτο πρόγραμμα ότι είμαι πραγματικά κάνει τον εαυτό μου. Έτσι, Πάω να πάει μπροστά και να πληκτρολογήσετε, int main (void). Και τότε μέσα από άγκιστρα μου, ένα πολύ γνωστό ( «γειά σου, world-- backslash, n ") - και μια άνω τελεία. 

Έχω αποθηκεύσει το αρχείο. Τώρα είμαι πρόκειται να πάει προς τα κάτω στο παράθυρό μου τερματικού και τον τύπο make buggy0, επειδή, και πάλι, το όνομα του αρχείου είναι σήμερα buggy0.c. Γι 'αυτό και πληκτρολογήστε κάνει buggy0, Enter. 

Και, ω, Θεέ, ανάκληση από την τελευταία φορά ότι δεν υπάρχουν μηνύματα λάθους είναι ένα καλό πράγμα. Έτσι, καμία έξοδος είναι ένα καλό πράγμα. Αλλά εδώ έχω σαφώς κάποιος αριθμός των λαθών. 

Έτσι, στην πρώτη γραμμή της εξόδου μετά την πληκτρολόγηση κάνει buggy0, ανάκληση, είναι αρκετά φλύαρη έξοδος Clang του. Κάτω από το καπό, CS50 IDE έχει ρυθμιστεί να χρησιμοποιήσει ένα σωρό επιλογές με αυτό το μεταγλωττιστή έτσι ώστε να μην έχουν να σκεφτούμε γι 'αυτούς. Και αυτό είναι όλο ότι η πρώτη γραμμή μέσα που ξεκινά με Clang. 

Αλλά μετά από αυτό, τα προβλήματα αρχίζουν να κάνουν την εμφάνισή τους. Buggy0.c στη γραμμή 3, χαρακτήρα 5, υπάρχει ένα μεγάλο, κόκκινο σφάλμα. Τι είναι αυτό? Σιωπηρά δηλώνοντας τη λειτουργία της βιβλιοθήκης printf με τον τύπο int (const char *, ...) [-Werror]. Θέλω να πω, πολύ γρήγορα παίρνει πολύ απόκρυφες. Και βεβαίως, σε πρώτη ματιά, δεν θα αναμένουμε από εσάς να καταλάβετε το σύνολό του μηνύματος. Και έτσι ένα από τα μαθήματα για σήμερα πρόκειται να είναι να προσπαθήσουμε να παρατηρήσετε πρότυπα, ή παρόμοια πράγματα, σε σφάλματα που μπορεί να έχετε αντιμετώπισε στο παρελθόν. Ας δώσουμε έμφαση, εκτός μόνο αυτά τα λόγια που φαίνονται εξοικειωμένοι. Το μεγάλο, κόκκινο σφάλμα είναι σαφώς συμβολική του κάτι που είναι λάθος. 

σιωπηρά δηλώνοντας βιβλιοθήκη printf λειτουργία. Έτσι, ακόμη και αν δεν καταλαβαίνω τι δηλώνοντας εμμέσως λειτουργία της βιβλιοθήκης μέσα, το πρόβλημα σίγουρα σχετίζεται με printf με κάποιο τρόπο. Και η πηγή του ζητήματος έχει να κάνει με την κήρυξή της. 

Δηλώνοντας μια λειτουργία είναι να σημειωθεί ότι για πρώτη φορά. Και χρησιμοποιήσαμε την ορολογία την περασμένη εβδομάδα δήλωσης πρωτότυπο μιας συνάρτησης, είτε με μία γραμμή στο πάνω μέρος της σας το δικό της αρχείο ή σε ένα λεγόμενο αρχείο κεφαλίδας. Και σε ποια αρχείο έκαναν λέμε την περασμένη εβδομάδα ότι η printf είναι απόσπασμα, εισαγωγικά, δήλωσε; Σε ποιο αρχείο είναι το πρωτότυπο της; 

Έτσι, αν θυμάστε, το πρώτο πράγμα που δακτυλογραφημένα, σχεδόν κάθε πρόγραμμα τελευταίο time-- και κατά λάθος μια στιγμή πριν αρχίσει πληκτρολογώντας myself-- ήταν αυτό here-- hash-- #include <stio-- για εισόδου / output-- dot h Και πράγματι, αν μπορώ τώρα να αποθηκεύσετε αυτό το αρχείο, θα πάω να προχωρήσει και να καθαρίσετε την οθόνη μου, το οποίο μπορείτε να κάνετε με την πληκτρολόγηση Σαφείς, ή μπορείτε να κρατήσετε Ελέγχου L, απλά για να καθαρίσετε το παράθυρό σας τερματικού απλά για να εξαλειφθούν κάποια ακαταστασία. 

Πάω να πάει μπροστά και να νέου τύπου make buggy0, Enter. Και ιδού, εγώ εξακολουθώ να βλέπω ότι μακρά εντολή από Clang, αλλά δεν υπάρχει μήνυμα λάθους αυτή τη φορά. Και πράγματι, αν το κάνω ./buggy0, ακριβώς όπως την τελευταία φορά, όπου τελεία σημαίνει αυτό κατάλογο, Slash σημαίνει απλώς, εδώ έρχεται το όνομα του προγράμματος και ότι το όνομα του προγράμματος είναι buggy0, Εισάγετε, "γειά σου, τον κόσμο." 

Τώρα, πώς μπορεί να έχετε σταχυολογούνται αυτή τη λύση χωρίς κατ 'ανάγκη αναγνωρίζοντας όσες λέξεις όπως έκανα, βέβαια, έχει κάνει αυτό για τόσα πολλά χρόνια; Λοιπόν, συνειδητοποιούν ανά το πρώτο πρόβλημα σύνολο, θα σας παρουσιάσουμε σε μια εντολή ότι το προσωπικό CS50 του έγραψε ονομάζεται help50. Και πράγματι, C κάνει προδιαγραφές το πρόβλημα που ως προς το πώς να χρησιμοποιήσετε αυτό. 

Αλλά είναι help50 ουσιαστικά ένα πρόγραμμα που το προσωπικό CS50 του που έγραψε ότι επιτρέπει να εκτελέσετε μια εντολή ή να εκτελέσετε ένα πρόγραμμα, και αν δεν μπορείτε να καταλάβετε τους εξόδου, για να περάσει η παραγωγή της σε help50, στο οποίο σημείο το λογισμικό ότι το προσωπικό του μαθήματος έγραψε θα δούμε στην έξοδο του προγράμματός σας γραμμή προς γραμμή, χαρακτήρα προς χαρακτήρα. Και αν εμείς, το προσωπικό, να αναγνωρίσει το μήνυμα λάθους που αντιμετωπίζετε, θα προσπαθήσουμε να σας προκαλέσει με κάποια ρητορικές ερωτήσεις, με κάποιες συμβουλές, μοιάζει πολύ με ένα TF ή μιας ΑΠ ή τον εαυτό μου θα κάνει το άτομο σε ώρες γραφείου. 

Έτσι κοιτάξουμε να help50 αν δεν το κάνετε αναγνωρίζουν κατ 'ανάγκη ένα πρόβλημα. Αλλά μην βασίζονται σε αυτό πάρα πολύ ως δεκανίκι. Σίγουρα προσπαθήσουμε να κατανοήσουμε τους εξόδου και, στη συνέχεια, να μάθουμε από αυτό έτσι ώστε μόνο μία ή δύο φορές το κάνετε ποτέ τρέξει help50 για ένα συγκεκριμένο σφάλμα μήνυμα. Μετά από αυτό, θα πρέπει να καλύτερα εξοπλισμένη τον εαυτό σας να καταλάβω τι είναι στην πραγματικότητα. 

Ας κάνουμε ένα άλλο εδώ. Επιτρέψτε μου να πάει μπροστά, και σε ένα άλλο αρχείο θα καλέσετε αυτό το buggy1.c. Και σε αυτό το αρχείο είμαι πρόκειται να deliberately-- αλλά προσποιούνται ότι δεν το κάνω καταλάβετε τι λάθος έχω κάνει. 

Πάω να πάει μπροστά και να κάνουμε this-- #include, δεδομένου ότι έχω μάθει το μάθημά μου από πριν από λίγο. Int main (void), όπως και πριν. Και τότε εδώ θα πάω να κάνει κορδόνι s - get_string. Και ανάκληση από τους τελευταία φορά που Αυτό σημαίνει, hey, ηλεκτρονικών υπολογιστών, να μου δώσει μια μεταβλητή, καλέστε το s, και κάνουν το είδος της εν λόγω μεταβλητής μια συμβολοσειρά ώστε να μπορώ να αποθηκεύσετε μία ή περισσότερες λέξεις σε αυτό. 

Και στη συνέχεια, στο δεξί χέρι πλευρά του ίσον είναι get_string, η οποία είναι μια λειτουργία στο CS50 Βιβλιοθήκη ότι κάνει ακριβώς αυτό. Παίρνει μια λειτουργία και, στη συνέχεια, τα χέρια του από δεξιά προς τα αριστερά. Έτσι, αυτό το σύμβολο της ισότητας δεν σημαίνει "Ισούται", όπως θα μπορούσαμε να σκεφτούμε στα μαθηματικά. Αυτό σημαίνει εκχώρηση από δεξιά προς τα αριστερά. Έτσι, αυτό σημαίνει, πάρτε το κορδόνι από το ο χρήστης και να αποθηκεύσει στο εσωτερικό του s. 

Τώρα ας το χρησιμοποιήσει. Επιτρέψτε μου να προχωρήσει τώρα και ως δεύτερης γραμμή, επιτρέψτε μου να πάει μπροστά και να πω "γεια" - δεν «κόσμο», αλλά «γειά σου,% S-- το οποίο είναι σύμβολο κράτησης θέσης μας, κόμμα s, η οποία είναι μεταβλητή μας, και στη συνέχεια μια άνω τελεία. Έτσι, αν δεν είχα βίδα μέχρι πολύ Εδώ, αυτό μοιάζει σωστό κωδικό. 

Και το ένστικτό μου τώρα είναι να το υπολογίσουν. Το αρχείο ονομάζεται buggy1.c. Έτσι, Πάω να κάνουν buggy1, Enter. Και καταριέται-it, αν δεν υπάρχει ακόμη περισσότερα λάθη από ό, τι πριν. Θέλω να πω, υπάρχουν και άλλα μηνύματα λάθους θα ήταν φαίνεται από τις πραγματικές γραμμές σε αυτό το πρόγραμμα. 

Αλλά το πακέτο είναι εδώ, ακόμα και αν είστε συγκλονισμένοι με δύο ή τρία ή τέσσερις περισσότερα μηνύματα λάθους, επικεντρώνονται πάντα σε πολύ πρώτο από αυτά τα μηνύματα. Κοιτάζοντας την κορυφή-πολύ ένα, κύλιση προς τα πίσω ως ανάγκη. Εδώ, λοιπόν, δακτυλογραφημένες make buggy1. Εδώ είναι η έξοδος Clang όπως αναμενόταν. 

Και εδώ είναι το πρώτο κόκκινο σφάλμα. Χρήση της αδήλωτης αναγνωριστικό string, δεν εννοώ πρότυπο; Έτσι πρότυπο είναι πραγματικά το κάτι άλλο. Αναφέρεται στον χρήστη πληκτρολόγιο, κατ 'ουσίαν. 

Αλλά αυτό δεν είναι ό, τι εννοούσα. Εννοούσα string, και εννοούσα get_string. Έτσι τι είναι αυτό που εγώ ξέχασε να κάνει αυτή τη φορά; Τι λείπει αυτή τη φορά; Έχω #include μου, έτσι έχω πρόσβαση σε printf. 

Αλλά τι μπορώ να μην έχουν την πρόσβαση σε ακριβώς ακόμα; Λοιπόν, ακριβώς όπως την τελευταία φορά, Πρέπει να πω την compiler Κλαγγή ποιες είναι αυτές οι λειτουργίες. Get_string δεν έρχεται με C. Και ειδικότερα, δεν έρχεται σε η κεφαλίδα του αρχείου,. Έρχεται αντί σε κάτι το προσωπικό έγραψε, το οποίο είναι ένα διαφορετικό αρχείο ονομάσει αλλά εύστοχα ονομάστηκε. 

Έτσι απλά προσθέτοντας ότι μία γραμμή της code-- ανάκληση από την τελευταία φορά ότι όταν Clang τρέχει, πρόκειται να εξετάσουμε τον κωδικό επάνω μου προς τα κάτω, από αριστερά προς τα δεξιά. Είναι πρόκειται να παρατηρήσετε, Ω, τι θέλετε. Επιτρέψτε μου να πάει και να βρει ότι, όπου είναι στο διακομιστή, αντιγραφή και επικόλληση, κατ 'ουσίαν, στην κορυφή του δικού σας αρχείου έτσι ώστε σε αυτό το σημείο στην ιστορία, γραμμή 1, το υπόλοιπο του προγράμματος μπορεί, πράγματι, χρησιμοποιήστε οποιαδήποτε από τις λειτουργίες σ 'αυτό, μεταξύ των οποίων get_string. Έτσι, Πάω να αγνοήσει το υπόλοιπο των εν λόγω σφαλμάτων, γιατί, πράγματι, υποψιάζομαι ότι μόνο η πρώτη πραγματικά σημασία. Και Πάω να πάει μπροστά και να επαναπροσδιοριστούν, Μετά την αποθήκευση του αρχείου μου κάνει buggy1. Και ιδού, το έκανε δουλειά. Και αν το κάνω ./buggy1 και πληκτρολογήστε, για παράδειγμα, Zamyla, εγώ τώρα θα πάρει ένα γεια, Zamyla, αντί του Hello, world. 

Εντάξει. Έτσι, οι takeaways Εδώ λοιπόν είναι να, ένα, προσπαθήστε να μαζέψει όσο μπορείτε από τα μηνύματα λάθους και μόνο, ψάχνει σε μερικά από τα αναγνωρίσιμες λέξεις. Φραγή ότι, χρησιμοποιήστε help50 ανά το πρόβλημα που προδιαγραφή. Αλλά φραγής ότι, πάρα πολύ, πάντα αναζητούν στην κορυφή σφάλμα μόνο, τουλάχιστον Αρχικά, για να δούμε τι πληροφορίες θα μπορούσε στην πραγματικότητα να δώσει. Αλλά αποδεικνύεται εκεί που ακόμη περισσότερη λειτουργικότητα χτίστηκε στο CS50 Βιβλιοθήκη για να βοηθήσει σας νωρίς στο εξάμηνο και νωρίς τον προγραμματισμό καταλάβουμε τι πηγαίνει στραβά. Έτσι, ας κάνουμε ένα άλλο παράδειγμα εδώ. Πάω να καλέσετε αυτό buggy2, η οποία, και πάλι, πρόκειται να αποτύχουν έξω από την πύλη, από το σχεδιασμό. 

Και Πάω να πάει μπροστά και να κάνουμε #include. Και τότε Πάω να κάνω int main (void). Και τότε Πάω να κάνω ένα για το βρόχο. For (int i _ 0. i είναι μικρότερη ή ίση με 10. i ++, και στη συνέχεια σε άγκιστρα, Πάω να εκτυπώσετε μόνο ένα σύμβολο hashtag εδώ και ένα νέο χαρακτήρα γραμμής. 

Έτσι, η πρόθεση μου με αυτό το πρόγραμμα είναι πολύ απλά να επαναλάβει 10 φορές και σε κάθε επανάληψη του εν λόγω βρόχου κάθε φορά μέσω του κύκλου, εκτυπώσετε ένα hashtag, ένα hashtag, το hashtag. Μια γραμμή ανά γιατί έχουν τη νέα γραμμή εκεί. Και υπενθυμίζουν ότι η για βρόχο, ανά τελευταία week-- και θα πάρετε περισσότερα εξοικειωμένοι με τη σύνταξη με τη χρήση του με την πρακτική πριν long-- αυτό μου δίνει μια μεταβλητή που ονομάζεται i και θέτει σε 0. 

Αυτό αυξάνει i σε κάθε επανάληψη από 1. Έτσι i πηγαίνει στο 1 έως 2 έως 3. Και τότε αυτός ο όρος στο μέση μεταξύ των ημι-παχύ έντερο παίρνει ελέγχεται σε κάθε επανάληψη να κάνουν βεβαιωθείτε ότι είμαστε ακόμα μέσα στη σειρά. Γι 'αυτό θέλω να επαναλάβει 10 φορές, γι' έχουν το είδος της πολύ διαισθητικά μόνο βάλει 10 ως άνω όριο μου εκεί. 

Και όμως, όταν τρέχω αυτό, μετά από μεταγλώττιση με make buggy2-- και δεν συγκεντρώνει OK. Γι 'αυτό και δεν έχουν συντακτικό λάθος αυτή τη φορά. Επιτρέψτε μου να προχωρήσει τώρα και να τρέξει buggy2, Enter. Και τώρα μετακινηθείτε προς τα επάνω. Και επιτρέψτε μου να αυξήσουν το μέγεθος του παραθύρου. 

I φαίνεται να έχει 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Έτσι, υπάρχει 11 διέσεις, παρόλο Έβαλα ξεκάθαρα 10 στο εσωτερικό αυτού του βρόχου. Τώρα, κάποιοι από εσάς μπορεί να δει αμέσως τι το σφάλμα είναι επειδή, πράγματι, αυτή η δεν είναι ένα πολύ δύσκολο να κάνει λάθος. Αλλά είναι πολύ συχνά έκανε πολύ νωρίς. 

Αυτό που θέλω να επισημάνω, όμως, είναι, πώς θα μπορούσε να μπορώ να καταλάβω αυτό έξω; Λοιπόν, αποδεικνύεται ότι το CS50 Βιβλιοθήκη έρχεται με όχι μόνο get_string και get_int και get_float και άλλες λειτουργίες. Επίσης, έρχεται με μια ειδική λειτουργία που ονομάζεται eprintf, ή, printf σφάλμα. Και υπάρχει μόνο για να κάνουν είναι λίγο πιο εύκολο για εσάς όταν τον εντοπισμό σφαλμάτων κώδικα σας μόνο εκτυπώσετε ένα μήνυμα σφάλματος στην οθόνη και να ξέρετε από πού προήλθε. 

Έτσι, για παράδειγμα, ένα πράγμα που θα μπορούσε κάνουμε εδώ με αυτή τη λειτουργία είναι this-- eprintf, και στη συνέχεια, Πάω να πάει μπροστά και να πω εγώ τώρα είναι% i, backslash, n. Και Πάω να συνδέσετε την αξία του i. Και επάνω στην κορυφή, διότι αυτό είναι στη CS50 Βιβλιοθήκη, Πάω να πάει μπροστά και περιλαμβάνουν έτσι έχω πρόσβαση σε αυτή τη λειτουργία. Αλλά ας εξετάσουμε τι γραμμή 9 υποτίθεται ότι πρέπει να κάνει. Πάω να διαγράψετε αυτό τελικά. Αυτό δεν έχει να κάνει με πρωταρχικό στόχο μου. Αλλά eprintf, printf λάθος, είναι ακριβώς σήμαινε να μου δώσει κάποιες διαγνωστικές πληροφορίες. Όταν τρέχω το πρόγραμμα μου, θέλω να δείτε αυτό στην οθόνη προσωρινά καθώς και απλά για να καταλάβετε τι συμβαίνει. 

Και, πράγματι, σε καθένα επανάληψη εδώ γραμμής 9 Θέλω να δω, ποια είναι η αξία του i; Ποια είναι η τιμή του i; Ποια είναι η τιμή του i; Και, ελπίζω, θα ήθελα μόνο δείτε αυτό το μήνυμα, επίσης, 10 φορές. 

Επιτρέψτε μου λοιπόν να πάει μπροστά και να μεταγλωττίσετε το πρόγραμμά μου, όπως έχω να κάνω οποιαδήποτε στιγμή Έχω κάνει μια αλλαγή. ./buggy2. Και now-- OK. Υπάρχουν πολλά άλλα πράγματα. Επιτρέψτε μου λοιπόν να μετακινηθείτε προς τα επάνω στο ένα ακόμη μεγαλύτερο παράθυρο. 

Και θα δείτε ότι κάθε ένα από η hashtags εξακολουθεί εκτύπωση. Αλλά στο μεταξύ κάθε μία από αυτές είναι τώρα αυτό διαγνωστική έξοδος διαμορφωθεί ως εξής. Το όνομα του προγράμματος μου εδώ είναι buggy2. Το όνομα του αρχείου είναι buggy2.c. Ο αριθμός γραμμή από την οποία αυτό τυπώθηκε είναι η γραμμή 9. Και στη συνέχεια στα δεξιά ότι είναι η μήνυμα λάθους που περιμένω. 

Και τι είναι ωραίο για αυτό είναι ότι τώρα δεν έχω να μετρήσει απαραίτητα στο κεφάλι μου τι κάνει το πρόγραμμά μου. Βλέπω ότι για την πρώτη επανάληψη i είναι 0, τότε 1, έπειτα 2, τότε 3, τότε 4, τότε 5, και στη συνέχεια 6, τότε 7, τότε 8, στη συνέχεια 9, τότε 10. Έτσι, περιμένετε ένα λεπτό. Τι συμβαίνει εδώ? Ακόμα φαίνεται να μετράει όπως προβλεπόταν μέχρι 10. 

Αλλά πού να αρχίσω; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Έτσι 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- το 11ο δάχτυλο είναι ενδεικτικό του προβλήματος. Μου φαίνεται να έχουν μετρηθεί εσφαλμένα στο βρόχο μου. Αντί να πάει 10 επαναλήψεις, Αρχίζω σε 0, Είμαι τελειώνει στο και μέσω της 10. Αλλά επειδή, όπως έναν υπολογιστή, Αρχίζω καταμέτρηση σε 0, Θα πρέπει να μετράει μέχρι σε, αλλά όχι μέσω της 10. 

Και έτσι η λύση, εγώ τελικά συνειδητοποιήσει εδώ, είναι ένα από τα δύο πράγματα. Θα μπορούσε πολύ απλά να πω μετράνε μέχρι λιγότερο από 10. Έτσι 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, το οποίο είναι, πράγματι, σωστή, ακόμα κι αν αυτό ακούγεται λίγο λάθος. Ή θα μπορούσα να κάνω μικρότερη ή ίση έως 9, εφ 'όσον μπορώ να ξεκινήσω σε 0. Ή αν πραγματικά δεν μου αρέσει αυτό, θα μπορεί να μετρήσει μέχρι έως 10, αλλά ξεκινούν από 1. Αλλά και πάλι, αυτό δεν είναι ακριβώς ότι η κοινή. Σε programming-- έστω όχι τόσο σε Scratch-- αλλά στον προγραμματισμό σε C και σε άλλες γλώσσες, όπως JavaScript και Python και άλλους, είναι απλά πολύ κοινό για συζήτησή μας της δυαδικής σε μόλις αρχίζουν να μετρούν κατά τη χαμηλότερο αριθμό μπορείτε, η οποία είναι 0. Εντάξει. Έτσι ώστε να είναι eprintf. Και πάλι, τώρα που έχω καταλάβει μου πρόβλημα, και είμαι πρόκειται να πάει πίσω στο 0 μέσω λιγότερο από 10, Πάω να πάει μέσα και να διαγράψετε eprintf. 

Δεν θα πρέπει να υπάρχει όταν Στέλνουμε τον κωδικό μου ή να υποβάλει τον κωδικό μου ή το δείξει σε κανέναν άλλο. Είναι πραγματικά ακριβώς σήμαινε που θα χρησιμοποιηθεί προσωρινά. Αλλά τώρα έχω αυτή καθορίζεται ιδιαίτερο πρόβλημα, καθώς και. 

Λοιπόν, ας κάνουμε ένα ακόμη παράδειγμα εδώ ότι θα πάω να κτυπήσει επάνω ως εξής. Πάω να πάει μπροστά και να #include. $ 50 Και Πάω να πάει μπροστά και #include. 

Και Πάω να αποθηκεύσετε Αυτό το αρχείο όπως buggy3.c. Και Πάω να πάει μπροστά και να κηρύξει int main (void). Και στη συνέχεια στο εσωτερικό του υπάρχει Πάω να κάνω int i _ - Θέλω να εφαρμόσει ένα πρόγραμμα με get_negative_int. Αυτό δεν είναι μια λειτουργία που υπάρχει ακόμα. Έτσι θα πάμε να εφαρμόσουν αυτό ακριβώς σε μια στιγμή. Αλλά θα πάμε να δούμε γιατί Είναι λάθη στο πρώτο πέρασμα. Και από τη στιγμή που έχω πάρει ένας int από το χρήστη, Είμαι ακριβώς πρόκειται να εκτυπώσετε% i είναι ένας αρνητικός ακέραιος, backslash, n, κόμμα, i. Με άλλα λόγια, το μόνο που μπορώ θέλετε αυτό το πρόγραμμα για να κάνει έχει πάρει μια αρνητική int από ο χρήστης και στη συνέχεια να εκτυπώσετε ότι ο τάδε είναι αρνητικό int. 

Τώρα πρέπει να εφαρμόσουν αυτή τη λειτουργία. Έτσι αργότερα στο αρχείο μου, είμαι πρόκειται να πάει μπροστά και να κηρύξει μια λειτουργία που ονομάζεται get_negative_int (κενό) - και θα επανέλθω σε αυτό που σημαίνει και πάλι ότι η γραμμή σε moment-- int n? παίξε η following-- printf n είναι :. Και τότε Πάω να κάνω n - get_int, και να το κάνουμε αυτό, ενώ n είναι μεγαλύτερο από 0. Και στη συνέχεια επιστρέφουν n ;. 

Έτσι, υπάρχει μια παρτίδα σε εξέλιξη στην αυτό, αλλά κανένα από τα οποία δεν είχαμε εξετάσουμε την περασμένη εβδομάδα, τουλάχιστον για λίγο. Έτσι, στη γραμμή 10 εδώ έχω κηρυχθεί συνάρτηση που ονομάζεται get_negative_int, και έχω βάλει (κενό), σε παρένθεση, ο λόγος είναι αυτό δεν λαμβάνει μια είσοδο. Δεν είμαι περνά τίποτα σε αυτή τη λειτουργία. Είμαι απλά να πάρει κάτι πίσω από αυτό. 

Και τι είμαι ελπίζοντας να να πάρει πίσω είναι ένας ακέραιος. Δεν υπάρχει τύπος δεδομένων σε C ονομάζεται negative_int. Είναι ακριβώς int, γι 'αυτό πρόκειται να είναι σε εμάς για να βεβαιωθείτε ότι η τιμή που πραγματικά επιστρέφεται είναι όχι μόνο ένας int αλλά είναι επίσης αρνητική. 

On line 12 Είμαι δηλώνοντας μια μεταβλητή καλείται ν και καθιστώντας τύπου int. Και, στη συνέχεια, στη γραμμή 13 έως 18 Είμαι να κάνει κάτι, ενώ κάτι είναι αληθινό. Πάω μπροστά και εκτύπωση Ν είναι, του παχέος εντέρου, και στη συνέχεια ένα διάστημα, σαν μια γραμμή για το χρήστη. 

Είμαι στη συνέχεια, καλώντας get_int και αποθήκευση λεγόμενη τιμή επιστροφής της σε αυτή τη μεταβλητή n. Αλλά Πάω να συνεχίσω να το κάνω αυτό, ενώ το η είναι μεγαλύτερο από μηδέν. Με άλλα λόγια, αν ο χρήστης μου ένα δίνει int και ο αριθμός αυτός είναι μεγαλύτερος από 0, ergo, θετική, Πάω να κρατήσει μόνο reprompting το χρήστη, κρατήσει reprompting, αναγκάζοντάς τους να συνεργάζονται και να μου δώσει μια αρνητική int. 

Και από τη στιγμή n είναι πραγματικά negative-- ας υποθέσουμε ότι ο χρήστης τελικά είδη -50, τότε αυτό το βρόχο, ενώ δεν ισχύει πλέον επειδή -50 δεν είναι μεγαλύτερη από μηδέν. Γι 'αυτό ξεφύγει από ότι βρόχο λογικά και να επιστρέψει n. 

Αλλά υπάρχει ένα άλλο πράγμα που έχω να κάνω. Και απλά μπορώ να το κάνω αυτό με αντιγραφή και επικόλληση μία γραμμή κώδικα στην κορυφή του αρχείου. Θα πρέπει να διδάξουμε Clang, ή υπόσχονται να κλαγγή, ρητά ότι θα το κάνω, Πράγματι, πάει και να εφαρμόσουν αυτή η λειτουργία get_negative_int. Θα μπορούσε απλώς να είναι χαμηλότερη στο αρχείο. Και πάλι, υπενθυμίζουν ότι Clang διαβάζει πράγματα πάνω προς τα κάτω, αριστερά προς τα δεξιά, έτσι ώστε να μην μπορεί να καλέσετε μια συνάρτηση αν Clang δεν ξέρει ότι πρόκειται να υπάρχουν. 

Τώρα, δυστυχώς, αυτό το πρόγραμμα, όπως κάποιοι από εσάς ίσως έχετε παρατηρήσει, είναι ήδη λάθη. Επιτρέψτε μου να προχωρήσει και να κάνει buggy3. Καταρτίζει, οπότε το πρόβλημά μου τώρα δεν είναι συντακτικό σφάλμα, όπως ένα σφάλμα κειμένου, αυτό είναι πραγματικά πρόκειται να είναι μια λογική λάθους που έχω σκόπιμα έκανε ως μια ευκαιρία για να βήμα μέσα από ό, τι συμβαίνει. 

Πάω να πάει μπροστά τώρα και τρέχει buggy3. Και Πάω να πάει μπροστά και όχι να συνεργαστούν. Πάω να του δώσει τον αριθμό 1. Δεν του άρεσε, οπότε αυτό είναι μου ζητά και πάλι. 

Πόσο περίπου 2; 3; 50; Κανένας από αυτούς εργάζονται. Πόσο περίπου -50; Και το πρόγραμμα φαίνεται να λειτουργεί. 

Επιτρέψτε μου να το δοκιμάσετε για μια ακόμη φορά. Επιτρέψτε μου να προσπαθήσω -1, φαίνεται να λειτουργεί. Επιτρέψτε μου να προσπαθήσω -2, φαίνεται να λειτουργεί. Επιτρέψτε μου να προσπαθήσω 0. Ε, αυτό είναι εσφαλμένη. Τώρα, θέλουμε να είμαστε λίγο σχολαστικός εδώ. Αλλά είναι, πράγματι, η υπόθεση ότι 0 δεν είναι ούτε θετική ούτε αρνητική. Και έτσι το γεγονός ότι το πρόγραμμά μου είναι λέγοντας ότι το 0 είναι ένας αρνητικός ακέραιος, αυτό δεν είναι τεχνικά σωστό. 

Τώρα, γιατί το κάνει αυτό; Λοιπόν, θα μπορούσε να είναι προφανής. Και, πράγματι, το πρόγραμμα είναι προορίζεται να είναι αρκετά απλή ώστε να έχουμε κάτι για να εξερευνήσετε. 

Αλλά ας εισαγάγει μια τρίτη εντοπισμού σφαλμάτων τεχνική που ονομάζεται εδώ debug50. Έτσι, αυτό είναι ένα πρόγραμμα ότι έχουμε μόλις δημιουργήσατε φέτος ονομάζεται debug50 που θα σας επιτρέψει να χρησιμοποιήσετε ό, τι λέγεται ένα ενσωματωμένο γραφικό πρόγραμμα εντοπισμού σφαλμάτων σε CS50 IDE. Και ένα πρόγραμμα εντοπισμού σφαλμάτων είναι απλά ένα πρόγραμμα που γενικά σας επιτρέπει να εκτελέσετε το πρόγραμμά σας αλλά βήμα-βήμα προς βήμα, γραμμή από τη γραμμή προς γραμμή, παύση, σπρώχνει γύρω, κοιτάζοντας μεταβλητές έτσι ώστε το πρόγραμμα δεν βγάζει μόνο το παρελθόν σας και γρήγορα να εκτυπώσετε κάτι ή όχι να εκτυπώσετε κάτι. Σας δίνει την ευκαιρία, σε ανθρώπινα ταχύτητα, να αλληλεπιδρούν με αυτό. 

Και για να το κάνετε αυτό, απλά κάντε τα εξής. Μετά την μεταγλώττιση κωδικό σας, που έκανα ήδη, buggy3, να προχωρήσει και να τρέξει debug50 ./buggy. Τόσο πολύ όπως help50 έχει τρέχετε help50 και τότε η εντολή, debug50 έχει τρέχετε debug50 και τότε το όνομα της εντολής. 

Τώρα παρακολουθούμε τι συμβαίνει στην οθόνη μου, στη δεξιά πλευρά ειδικότερα. Όταν χτύπησα Run, όλα τα ξαφνική πάνελ αυτό το δεξί χέρι ανοίγει στην οθόνη. Και υπάρχει μια παρτίδα σε εξέλιξη σχετικά με την πρώτη ματιά. Αλλά δεν είναι εκεί πολύ να ανησυχείτε για ακόμη. 

Αυτό μου δείχνει τα πάντα ότι συμβαίνει στο εσωτερικό του προγράμματός μου τώρα και μέσω αυτών κουμπιά επάνω στην κορυφή είναι τότε μου επιτρέπει να το βήμα μέσω του κωδικού μου τελικά, βήμα προς βήμα με βήμα. Αλλά δεν είναι ακριβώς ακόμα. Παρατηρήστε τι συμβαίνει. Στο παράθυρό μου τερματικού Είμαι να ζητηθεί n. Και Πάω να πάει μπροστά και να συνεργάζεται αυτή τη φορά και τον τύπο στο -1. Και αν και είναι λίγο κρυφά, -1 είναι ένας αρνητικός ακέραιος, όπως αναμενόταν. 

Και τότε το παιδί βγήκε με κατάσταση 0 GDBserver την έξοδο. GDB, GNU Debugger, είναι το όνομα του υποκείμενου λογισμικού ότι υλοποιεί αυτό το πρόγραμμα εντοπισμού σφαλμάτων. Αλλά όλο αυτό σημαίνει πραγματικά, το πρόγραμμα εντοπισμού σφαλμάτων πήγε μακριά, γιατί το πρόγραμμά μου κόψει και όλα ήταν καλά. Αν θέλω να debug πραγματικά το πρόγραμμά μου, Οφείλω να πω preemptively debug50, όπου μπορώ να θέλετε να ξεκινήσετε ενίσχυση μέσω του κωδικού μου; 

Και ίσως ο απλούστερος τρόπος για να γίνει αυτό είναι η εξής. Αν μου αιωρείται πάνω από το υδρορροή του επεξεργαστή μου εδώ, έτσι ώστε πραγματικά ακριβώς στο sidebar εδώ, στα αριστερά του αριθμού γραμμής, Παρατηρήστε ότι αν μπορώ απλά κάντε κλικ μια φορά, έβαλα λίγο κόκκινη κουκίδα. Και αυτή η μικρή κόκκινη κουκκίδα, σαν ένα σήμα στοπ, σημαίνει, hey, debug50, εκτέλεση παύση των κωδικό μου εκεί όταν τρέχω αυτό το πρόγραμμα. 

Οπότε ας το κάνουμε αυτό. Επιτρέψτε μου να πάει μπροστά και να τρέξει το πρόγραμμά μου πάλι με debug50 ./buggy3, Enter. Και τώρα, προειδοποίηση, κάτι διαφορετικών έχει συμβεί. Δεν είμαι να σας ζητηθεί ακόμα στο παράθυρό μου τερματικού για τίποτα, επειδή δεν έχω πάρει εκεί ακόμα στο πρόγραμμά μου. Παρατηρήστε ότι στη γραμμή 8 η οποία είναι πλέον τονίζεται, και υπάρχει ένα μικρό βέλος αριστερά ρητό, είστε εδώ σε παύση. Αυτή η γραμμή του κώδικα, γραμμή 8, δεν έχει ακόμη εκτελεστεί. 

Και τι είναι περίεργο, αν κοιτάξω εδώ στη δεξιά πλευρά, Παρατηρήστε ότι είναι ένα τοπικό μεταβλητή, η τοπική με την έννοια ότι είναι μέσα στην τρέχουσα λειτουργία. Και την αξία του, προφανώς από προεπιλογή, και το είδος βολικά, είναι 0. Αλλά εγώ δεν πληκτρολογήστε 0. Αυτό συμβαίνει ακριβώς να είναι της προεπιλεγμένη τιμή αυτή τη στιγμή. 

Επιτρέψτε μου λοιπόν να προχωρήσει και να το κάνουμε αυτό τώρα. Επιτρέψτε μου να προχωρήσει και σε το πάνω δεξιά εδώ, είμαι πρόκειται να πάει μπροστά και να κάντε κλικ σε αυτό το πρώτο εικονίδιο που σημαίνει το βήμα πάνω από το οποίο σημαίνει ότι δεν παραλείψετε αυτό, αλλά βήμα πέρα ​​από αυτή τη γραμμή του κώδικα, εκτέλεσης κατά μήκος του τρόπου. 

Και τώρα, παρατηρήσετε, μου γραμμή έχει μόλις αλλάξει. Γιατί αυτό? Έχω πει debug50, τρέχουν αυτή τη γραμμή του κώδικα. Τι σημαίνει αυτή η γραμμή του κώδικα κάνω; Μου ζητά έναν int. ΕΝΤΆΞΕΙ. Επιτρέψτε μου να συνεργάζονται. Επιτρέψτε μου να προχωρήσει τώρα και πληκτρολογήστε -1, Enter. Και τώρα παρατηρήσετε τι έχει αλλάξει. Στη δεξιά πλευρά, τοπική μεταβλητή i μου ενδείκνυται ως -1 τώρα. Και εξακολουθεί να είναι του τύπου int. 

Και ειδοποίηση, πάρα πολύ, μου λεγόμενη στοίβα κλήσεων, πού μπορώ να διακόψω; Θα μιλήσουμε περισσότερο για αυτό στο μέλλον. Αλλά η στοίβα κλήσεων αναφέρεται μόνο σε ό, τι λειτουργίες είναι επί του παρόντος σε κίνηση. Αυτή τη στιγμή είναι απλά κύριο. Και τώρα το μόνο τοπικό μεταβλητή είναι i με τιμή 1. 

Και όταν τελικά βήμα πέρα ​​από αυτή τη γραμμή Εδώ, με το ίδιο εικονίδιο στο πάνω δεξιά, -1 Είναι ένας αρνητικός ακέραιος. Τώρα είναι να σταθούμε πάνω από το σγουρά κηδεμόνα. Ας αφήστε το να κάνει το πράγμα του. Πατάω πάνω από αυτή τη γραμμή, και voila. 

Έτσι, δεν είναι όλα τόσο τρομερά διαφωτιστική ακόμα, αλλά άφησε να διακόψετε και σκεφτείτε μέσω λογικά τι κάνει αυτό το πρόγραμμα. Αλλά αυτό δεν ήταν η λανθασμένη υπόθεση. Ας το κάνουμε αυτό και πάλι ως εξής. 

Πάω να αφήσει αυτό το σημείο διακοπής on line 8 με την κόκκινη κουκκίδα. Πάω να επαναληφθεί debug50. Είναι αυτόματα παύση εδώ. Αλλά αυτή τη φορά, αντί της την ενίσχυση πάνω από τη γραμμή αυτή, επιτρέψτε μου να πραγματικά να πάμε στο εσωτερικό της get_negative_int και να καταλάβω, γιατί είναι αποδοχή 0 ως έγκυρη απάντηση; 

Έτσι, αντί να κάνετε κλικ Step Over. Πάω να πάει μπροστά και κάντε κλικ στο Βήμα Into. Και παρατηρήστε ότι η γραμμή 8 που είναι τώρα τονίζεται τώρα ξαφνικά γίνεται γραμμή 17. 

Τώρα, δεν είναι ότι το πρόγραμμα εντοπισμού σφαλμάτων έχει παραληφθεί γραμμές 14 και 15 και 16. Είναι απλά δεν υπάρχει τίποτα για να σας δείξει εκεί. Αυτά είναι μόνο δηλώνοντας μεταβλητές, και στη συνέχεια να υπάρχει είναι η λέξη Do και στη συνέχεια ένα ανοιχτό σγουρά κηδεμόνα. Η μόνη λειτουργική γραμμή που είναι ζουμερά είναι πραγματικά αυτό εδώ, 17. Και αυτό είναι που έχουμε παύση αυτόματα. 

Έτσι printf ( "n.is:") ;, έτσι ότι δεν έχει συμβεί ακόμα. Οπότε ας προχωρήσει και κάντε κλικ στο Βήμα Πάνω. Τώρα προτροπή μου, πράγματι, άλλαξε σε ( "η είναι:"). Τώρα get_int, εγώ δεν πάω να ενοχλεί αναβάθμιση σε, γιατί αυτή η λειτουργία ήταν από CS50 στη Βιβλιοθήκη. Είναι πιθανώς σωστό. 

Έτσι, Πάω να πάει μπροστά και να είδος συνεργάζονται δίνοντάς ένας int, αλλά δεν είναι αρνητικά int. Επιτρέψτε μου λοιπόν να προχωρήσει και να χτυπήσει 0. Και τώρα τι θα συμβεί εδώ όταν πιάσουμε γραμμή 21; Δεν έχω επαναληφθεί ξανά. Δεν φαίνεται να έχει κολλήσει στην εν λόγω βρόχο. Με άλλα λόγια, αυτό το κίτρινο μπαρ δεν συνεχίζω γύρω, και γύρω και γύρω. 

Τώρα, γιατί είναι αυτό; Λοιπόν, n, τι n τώρα; Μπορώ να δούμε σε τοπικό μεταβλητές στο πρόγραμμα εντοπισμού σφαλμάτων. η είναι μηδέν. Εντάξει, ποια ήταν η κατάστασή μου; 

20-- γραμμή 20 είναι, επίσης, 0 είναι μεγαλύτερη από 0. Αυτό δεν είναι αλήθεια. 0 δεν είναι μεγαλύτερο από μηδέν. Και γι 'αυτό έσπασε έξω από αυτό. 

Και έτσι γι 'αυτό στη γραμμή 21, αν μπορώ πραγματικά να συνεχίσει, Πάω να επιστρέψει 0, ακόμη και αν και θα έπρεπε να απορριφθεί 0 καθώς στην πραγματικότητα δεν είναι αρνητική. Έτσι τώρα, δεν το κάνω πραγματικά ακόμη νοιάζονται για το πρόγραμμα εντοπισμού σφαλμάτων. Πήρε αυτό, δεν χρειάζεται να ξέρετε τι περισσότερο γίνεται. 

Έτσι, Πάω να πάει μπροστά και να απλά κάντε κλικ στο κουμπί Αναπαραγωγή, και αφήστε αυτό το φινίρισμα up. Τώρα, έχω συνειδητοποιήσει ότι μου bug είναι προφανώς στη γραμμή 20. Αυτό είναι λογικό λάθος μου. 

Και έτσι ό, τι θέλω να κάνουμε για να το αλλάξουμε αυτό; Αν το πρόβλημα είναι ότι δεν είμαι αλίευση 0, είναι απλώς ένα λογικό σφάλμα. Και μπορώ να πω, ενώ n είναι μεγαλύτερο ή ίσο με 0, κρατήσει προτρέποντας ξανά και ξανά από το χρήστη. 

Έτσι, και πάλι, απλό λάθος, ίσως ακόμη και προφανής όταν με είδε γράψτε μόλις πριν από λίγα λεπτά. Αλλά το πακέτο εδώ είναι ότι με debug 50, και με τον εντοπισμό σφαλμάτων λογισμικό γενικότερα, Έχετε αυτό το νέο βρέθηκαν εξουσία με τα πόδια μέσα από το δικό σας κώδικα, δείτε μέσω του εν λόγω δικαιώματος πάνελ χέρι τι μεταβλητές τιμές σας είναι. Έτσι δεν κάνουν απαραίτητα πρέπει να χρησιμοποιήσετε κάτι όπως σας eprintf να εκτυπώσετε αυτές τις αξίες. Μπορείτε να δείτε πραγματικά τους οπτικά στην οθόνη. 

Τώρα, πέρα ​​από αυτό, αξίζει να σημειωθεί ότι υπάρχει μια άλλη τεχνική που είναι πραγματικά σούπερ κοινό. Και ίσως να αναρωτηθούμε γιατί αυτό το μικρό τύπος εδώ έχει καθίσει στη σκηνή. Έτσι, υπάρχει η τεχνική αυτή, σε γενικές γραμμές γνωστή ως πάπια καουτσούκ εντοπισμό σφαλμάτων, το οποίο είναι πραγματικά ακριβώς ένα απόδειξη για το γεγονός ότι συχνά, όταν οι προγραμματιστές γράφουν κώδικα, δεν είναι κατ 'ανάγκην συνεργάζεται με τους άλλους, ή εργάζονται σε ένα κοινό περιβάλλον. 

Είναι το είδος του στο σπίτι. Ίσως είναι αργά το βράδυ. Προσπαθούν να φιγούρα από κάποιο bug στον κώδικα τους. Και από όπου και αν απλά δεν το βλέπουμε. 

Και δεν υπάρχει συγκάτοικο. Δεν υπάρχει TF. Δεν υπάρχει CA γύρω. Το μόνο που έχουν στο ράφι τους Είναι αυτό το μικρό ducky καουτσούκ. 

Και έτσι debugging πάπια καουτσούκ Είναι ακριβώς αυτή η πρόσκληση να σκεφτεί κάτι τόσο ανόητο όπως αυτό ως ένα πραγματικό πλάσμα, και στην πραγματικότητα τα πόδια μέσα από τον κωδικό σας προφορικά σε αυτό το άψυχο αντικείμενο. Έτσι, για παράδειγμα, αν αυτό είναι το παράδειγμά μου here-- και υπενθυμίζουν ότι νωρίτερα το πρόβλημα ήταν αυτό, αν μπορώ να διαγράψω αυτό το πρώτη γραμμή του κώδικα, και να πάω μπροστά και να κάνουν λάθη 0 και πάλι, Υπενθυμίζουμε ότι είχα αυτά μηνύματα λάθους εδώ. Έτσι, η ιδέα εδώ, γελοίο κι αν αισθάνονται αυτή τη στιγμή να γίνει αυτό δημοσίως, είναι ότι το σφάλμα. 

Εντάξει, έτσι το πρόβλημά μου είναι ότι έχω δηλώνεται σιωπηρά μια λειτουργία βιβλιοθήκης. Και ότι η λειτουργία της βιβλιοθήκης είναι printf. Declare-- ΟΚ, δηλώνουν μου θυμίζει πρωτοτύπων. 

Αυτό σημαίνει ότι πρέπει πραγματικά να πουν τον compiler σε εκ των προτέρων τι η λειτουργία μοιάζει. Περίμενε ένα λεπτό. Δεν είχα πρότυπο io.h. Ευχαριστώ πολύ. 

Έτσι ακριβώς αυτή η διαδικασία τον αριθμό τους θα Δεν χρειάζεται να έχουμε πραγματικά μια πάπια. Αλλά αυτή η ιδέα του περπατήματος τον εαυτό σας μέσα από τον δικό σας κώδικα έτσι ώστε να μπορείτε ακόμα να ακούσετε τον εαυτό σας, έτσι ώστε να συνειδητοποιήσουν παραλείψεις στη δική σας παρατηρήσεις, είναι γενικά η ιδέα. 

Και, ίσως πιο λογικά, δεν είναι τόσο πολύ με εκείνο το ένα, αλλά το πιο ενεργά παράδειγμα που μόλις έκανε στο αμαξάκι 3.γ, μπορείτε να περπατήσετε τον εαυτό σας μέσα από αυτό ως εξής. Έτσι, εντάξει, καουτσούκ ducky, DDB, αν θέλετε. Εδώ έχουμε στην κύρια λειτουργία μου, Είμαι καλώντας πάρει αρνητική int. 

Και έχω πάρει την τιμή επιστροφής. Είμαι αυτό που αποθηκεύει στην αριστερή πλευρά στη γραμμή 8 σε μια μεταβλητή που ονομάζεται i. ΟΚ, αλλά περιμένετε, πώς το έκανε ότι έχετε αυτή την τιμή; Επιτρέψτε μου να δούμε τη λειτουργία στη γραμμή 12. 

Στη γραμμή 12, έχουμε πάρει αρνητική int. δεν λαμβάνει εισόδους, δεν επιστρέψει ένα int, ΟΚ. Δηλώνω στη γραμμή 14 μια μεταβλητή n. Είναι πρόκειται να αποθηκεύσει έναν ακέραιο. Αυτό θέλω. 

Έτσι κάνετε το εξής, ενώ n is-- ας Θέλω να αναιρέσετε ό, τι η λύση που έχει ήδη γίνει. Έτσι, ενώ το η είναι μεγαλύτερο από 0, εκτυπώστε Ν, OK. Και στη συνέχεια να καλέσει να int αποθηκεύονται σε n. Και στη συνέχεια, ελέγξτε αν το n είναι 0, n είναι not-- εκεί είναι. Έτσι, και πάλι, δεν το κάνετε χρειάζεται την πραγματική πάπια. Αλλά απλά περπατώντας τον εαυτό σας μέσα από κωδικό σας ως μια πνευματική άσκηση θα σας βοηθήσει συχνά συνειδητοποιήσει τι συμβαίνει, σε αντιδιαστολή με ακριβώς να κάνει κάτι όπως αυτό, κοιτάζοντας την οθόνη, και δεν μιλάμε εαυτό σας μέσα αυτό, η οποία ειλικρινά δεν είναι σχεδόν ως μια αποτελεσματική τεχνική. Έτσι εκεί το έχετε, ένα αριθμός διαφορετικών τεχνικών για πραγματικά τον εντοπισμό σφαλμάτων κώδικα σας και εύρεση σφαλμάτων, τα οποία όλα θα πρέπει να είναι τα εργαλεία στην εργαλειοθήκη σας έτσι ώστε να μην είστε αργά το βράδυ, ειδικά, είστε στην τραπεζαρία αίθουσες ή σε ώρες γραφείου, χτυπάς το κεφάλι σου στον τοίχο, προσπαθεί να λύσει κάποιο πρόβλημα. Συνειδητοποιήστε ότι υπάρχουν εργαλεία λογισμικού. Υπάρχουν λαστιχένια εργαλεία πάπια. Και υπάρχει ένα σύνολο του προσωπικού της υποστήριξη που περιμένουν να δώσει μια χείρα βοηθείας. 

Έτσι τώρα, μια λέξη σχετικά με το πρόβλημα σύνολα, και σε ό, τι είμαστε εσείς που ελπίζετε βγούμε από αυτά, και πώς πάμε για την αξιολόγηση. Ανά εξεταστέα ύλη του μαθήματος, πρόβλημα σύνολα CS50 του αξιολογούνται σε τέσσερις βασικούς άξονες, έτσι να speak-- πεδίο εφαρμογής, την ορθότητα, το σχεδιασμό, και το στυλ. Και το πεδίο εφαρμογής αναφέρεται ακριβώς στο πόσο του κομματιού έχετε δαγκώσει μακριά; Πόσο μεγάλο πρόβλημα έχετε δοκιμάσει; Τι επίπεδο προσπάθειας έχετε εκδηλώνεται; 

Ορθότητα είναι, κάνει τη δουλειά του προγράμματος ως που υποτίθεται ότι ανά προδιαγραφή CS50 όταν παρέχουν ορισμένες εισόδους ή ορισμένα αποτελέσματα που έρχονται πίσω; Design είναι η πιο υποκειμενική από αυτούς. Και αυτό είναι το ένα που θα να λάβει τη μεγαλύτερη να μάθετε και η μεγαλύτερη για να διδάξουν, σε καθόσον βράζει κάτω, πόσο καλά γραμμένο είναι ο κωδικός σας; 

Είναι ένα πράγμα για να εκτυπώσετε μόνο το σωστό εξόδους ή να επιστρέψει τις σωστές τιμές. Αλλά μπορείτε να το κάνετε ως το δυνατόν πιο αποτελεσματικά; Είσαι το κάνει χάσματος και να κατακτήσουν, ή δυαδική αναζήτησης, όπως θα δείτε σύντομα ότι κάναμε πριν από δύο εβδομάδες με τον τηλεφωνικό κατάλογο; Είναι καλύτεροι τρόποι για να λύσει το εκεί πρόβλημα από ό, τι έχετε σήμερα εδώ; Αυτή είναι μια ευκαιρία για καλύτερο σχεδιασμό. 

Και τότε style-- πώς όμορφο είναι ο κωδικός σας; Θα παρατηρήσετε ότι είμαι αρκετά Ειδικότερα για την εσοχή κωδικό μου, και να διασφαλίσουμε τις μεταβλητές μου Τα εύλογα το όνομα. n, ενώ λίγα λόγια, είναι ένα καλό όνομα για ένα αριθμό, i για ένα ακέραιο καταμέτρηση, s για ένα string. Και μπορούμε να έχουμε πλέον μεταβλητό ύφος ονόματα. Στυλ είναι ακριβώς το πόσο καλή φαίνεται κωδικό σας; Και πώς αναγνώσιμο είναι αυτό; 

Και την πάροδο του χρόνου, τι βοηθούς σας και TFs θα κάνει κατά τη διάρκεια είναι να σας παρέχει με ότι το είδος των ποιοτικών σχολίων έτσι ώστε να έχετε την καλύτερη σε αυτές τις διάφορες πτυχές. Και από την άποψη του πώς μπορούμε αξιολογεί κάθε ένα από αυτούς τους άξονες, είναι συνήθως με πολύ λίγα κουβάδες έτσι ώστε να μπορείτε, σε γενικές γραμμές, να πάρετε μια αίσθηση του πόσο καλά κάνετε. Και, πράγματι, εάν λάβετε μια βαθμολογία για οποιοδήποτε από αυτά τα axes-- ορθότητα, το σχεδιασμό και το στυλ especially-- ότι ο αριθμός θα είναι γενικά μεταξύ 1 και 5. Και, στην κυριολεξία, αν παίρνετε 3 κατά την έναρξη του εξαμήνου, αυτό είναι ένα πολύ καλό πράγμα. Αυτό σημαίνει ότι υπάρχει ακόμα περιθώρια βελτίωσης, το οποίο θα ελπίζουμε για το λαμβάνοντας μια τάξη για πρώτη φορά. Υπάρχει ελπίζω κάποια κομμάτι της οροφής στην οποία είστε φιλοδοξούν να επιτευχθεί. Και έτσι ώστε να πάρει στις 3 του τα πρώτα κομμάτια, αν όχι μερικά 2 και 4, η Είναι, πράγματι, ένα καλό πράγμα. Είναι καλά εντός εμβέλειας, σαφώς εντός των προσδοκιών. 

Και αν το μυαλό σας είναι αγωνιστικά, περιμένετε ένα λεπτό, τρία από τα πέντε. Αυτό είναι πραγματικά ένα 6 στα 10. Αυτό είναι 60%. Θεέ μου, που είναι ένα F. 

Δεν είναι. Δεν είναι, στην πραγματικότητα, ότι. Μάλλον, είναι μια ευκαιρία για τη βελτίωση της κατά τη διάρκεια του εξαμήνου. Και αν παίρνετε κάποια Poors, αυτά είναι μια ευκαιρία να επωφεληθούν από τις ώρες γραφείου, Σίγουρα τμήματα και άλλους πόρους. 

Καλύτερη είναι μια ευκαιρία, πραγματικά, να είμαστε υπερήφανοι για το πόσο μακριά έχετε έρχονται κατά τη διάρκεια του εξαμήνου. Έτσι αντιλαμβάνονται, αν δεν άλλο, τρεις είναι καλό. Και επιτρέπει χώρο για την ανάπτυξη την πάροδο του χρόνου. 

Όσο για το πώς είναι αυτές οι άξονες σταθμισμένο, ρεαλιστικά είστε πρόκειται να περνούν τον περισσότερο χρόνο σας να πάρει τα πράγματα στη δουλειά, πόσο σωστά μόνο. Και έτσι ορθότητα τείνει να να σταθμίζεται το πιο, όπως με Αυτό πολλαπλασιαστικός συντελεστής των τριών. Σχεδιασμός είναι επίσης σημαντική, αλλά κάτι που δεν κάνουν απαραίτητα ξοδεύουν όλα αυτά τα ωρών για προσπαθεί να πάρει τα πράγματα απλά για να εργαστούν. 

Και γι 'αυτό σταθμίζεται λίγο πιο ελαφριά. Και τότε το στυλ σταθμίζεται το λιγότερο. Ακόμα κι αν δεν είναι λιγότερο είναι σημαντικό ριζικά, είναι απλά, ίσως, η πιο εύκολο πράγμα να κάνουμε το σωστό, μιμούνται τα παραδείγματα που κάνετε σε διάλεξη και ενότητα, με τα πράγματα όμορφα εσοχή, και σχολίασε, και ούτω καθεξής είναι μεταξύ των πιο εύκολος πράγματα να κάνουμε και να πάρει το δικαίωμα. Έτσι ως τέτοια, συνειδητοποιούν ότι αυτά είναι τα σημεία που είναι σχετικά εύκολο να γίνει αντιληπτό. 

Και τώρα μια λέξη για this-- ακαδημαϊκή ειλικρίνεια. Έτσι, σύμφωνα με την πορεία του διδακτέα ύλη, θα δείτε ότι το μάθημα έχει ένα αρκετά κομμάτι της γλώσσας γύρω από αυτό. Και η πορεία παίρνει το θέμα της ακαδημαϊκή ειλικρίνεια αρκετά σοβαρά. 

Έχουμε τη διάκριση, προς το καλύτερο ή προς το χειρότερο, ότι έστειλε κάθε χρόνο περισσότερα μαθητές για πειθαρχικά μέτρα από ό, τι οι περισσότεροι κάθε άλλο Φυσικά, ότι είμαι γνωρίζει. Αυτό δεν είναι απαραίτητα ενδεικτικό του γεγονότος ότι CS φοιτητές, ή CS50 μαθητές, είναι λιγότερο ειλικρινής από τους συμμαθητές σας. Αλλά η πραγματικότητα ότι σε αυτό το κόσμο, ηλεκτρονικά, εμείς απλά έχουν τεχνολογική μέσο για την ανίχνευση αυτή. 

Είναι σημαντικό για εμάς για δικαιοσύνη σε όλη την τάξη ότι κάνουμε το εντοπίσει, και να αυξήσει το θέμα, όταν βλέπουμε τα πράγματα. Και ακριβώς για να ζωγραφίσει μια εικόνα, και πραγματικά για να βοηθήσει κάτι σαν αυτό το νεροχύτη, αυτοί είναι οι αριθμοί των οι μαθητές κατά τη διάρκεια των τελευταίων 10 ετών που έχουν εμπλακεί σε ορισμένες τέτοια ζητήματα της ακαδημαϊκής δεοντολογίας, με κάποιες 32 μαθητές από το φθινόπωρο του 2015, η οποία είναι να πούμε ότι δεν λαμβάνουν το θέμα πολύ σοβαρά. Και, τελικά, αυτοί οι αριθμοί συνθέτουν, πιο πρόσφατα, περίπου 3%, 4% ή έτσι της κατηγορίας. 

Έτσι, για το σούπερ πλειοψηφία των φοιτητών φαίνεται ότι οι γραμμές είναι σαφείς. Αλλά κρατήσει αυτό νου, ιδιαίτερα αργά τη νύχτα, όταν αγωνίζεται με κάποια λύση σε ένα σύνολο το πρόβλημα, ότι υπάρχουν μηχανισμοί για να πάρει τον εαυτό σας καλύτερα υποστήριξη από ό, τι θα μπορούσε σκέφτονται, ακόμα και εκείνη την ώρα. Συνειδητοποιήστε ότι όταν λάβουμε υποβολές των σπουδαστών, διασχίζουμε συγκρίνουν κάθε υποβολή του τρέχοντος έτους ενάντια σε κάθε κατάθεση το περασμένο έτος, ενάντια σε κάθε κατάθεση από το 2007, και δεδομένου ότι, κοιτάζοντας, καθώς και, Κωδικός αποθετήρια σε απευθείας σύνδεση, φόρουμ συζητήσεων, χώρους εργασίας. Και εμείς αναφέρουμε αυτό, Πραγματικά, όλα για χάρη της πλήρους αποκάλυψης, ότι αν κάποιος άλλος μπορεί να το βρείτε online, Σίγουρα, οπότε μπορούμε να κάνουμε το μάθημα. Αλλά, πραγματικά, το πνεύμα από το μάθημα βράζει κάτω με τη ρήτρα αυτή στην εξεταστέα ύλη. Είναι πραγματικά είναι απλά, είναι λογικό. 

Και αν έπρεπε να αναπτύξω ότι με μόνο ένα λίγο πιο γλώσσας, συνειδητοποιούν ότι η ουσία όλων εργασία που υποβάλλετε σε αυτό το μάθημα πρέπει να είναι δική σας. Αλλά μέσα σε αυτό, υπάρχουν σίγουρα ευκαιρίες, και την ενθάρρυνση, και παιδαγωγική αξία στρέφονται προς others-- τον εαυτό μου, η ΤΡ, η ΑΠ, οι τεχνικοί βοηθοί, και άλλους στην τάξη, για την υποστήριξη, πόσο μάλλον τους φίλους και συγκάτοικοι που έχουν μελετηθεί CS και τον προγραμματισμό πριν. Και έτσι υπάρχει μια αποζημίωση για αυτό. Και ο γενικός κανόνας του αντίχειρα είναι this-- όταν ζητούν βοήθεια, μπορεί να δείξει τον κωδικό σας σε άλλους, αλλά δεν μπορείτε να δείτε τις δικές τους. Έτσι, ακόμη και αν είστε σε ώρες γραφείου, ή στην αίθουσα D, ή κάπου αλλού εργάζονται πάνω σε κάποια σετ κομμάτι, που εργάζονται μαζί με μια φίλη, η οποία είναι εντελώς καλά, κατά τη τέλος της ημέρας εργασίας σας θα πρέπει τελικά να ανήκουν σε κάθε από εσάς, αντίστοιχα, και όχι είναι κάποια συλλογική προσπάθεια, εκτός από το τελικό σχέδιο στο οποίο αυτό είναι επιτρέπεται και ενθαρρύνεται. 

Συνειδητοποιήστε ότι αν είστε παλεύουν με κάτι και ο φίλος σας συμβαίνει ακριβώς να είναι καλύτερα σε αυτό, τότε, ή καλύτερα σε αυτό το πρόβλημα από ό, τι μπορείτε, ή λίγο μακρύτερα μπροστά από εσάς, είναι εντελώς λογικό να μετατρέψει στο φίλο σας και να πω, hey, Σας πειράζει κοιτάζοντας τον κωδικό μου εδώ, με βοήθησαν εντοπίσετε αυτό το θέμα μου; Και, ελπίζω, στην ενδιαφέρον της παιδαγωγικής αξίας ότι ο φίλος κάνει όχι μόνο λένε, ω, να το κάνετε αυτό, αλλά μάλλον, τι λείπει on line 6, ή κάτι τέτοιο; Αλλά η λύση δεν είναι για το φίλο δίπλα σας να πει, OH, καλά, εδώ, επιτρέψτε μου να τραβήξει αυτό επάνω, και να δείξει λύση μου σε εσάς. Έτσι ώστε να είναι η γραμμή. Σας δείξει τον κωδικό σας τους άλλους, αλλά δεν μπορείτε να δείτε το δικό τους, υπόκεινται σε άλλη περιορισμούς στην εξεταστέα ύλη του μαθήματος. 

Έτσι, να έχετε κατά νου αυτό το λεγόμενη ρήτρα λύπη στη διδακτέα ύλη του μαθήματος, καθώς και, ότι αν διαπράξουν κάποια πράξη ότι Δεν είναι λογικό, αλλά να το φέρει σε η προσοχή των προϊσταμένων του μαθήματος εντός 72 ωρών, η πορεία δύνανται να επιβάλλουν τοπικές κυρώσεις που θα μπορεί να περιλαμβάνει ένα μη ικανοποιητικό ή ελλείψει βαθμού για το έργο που υποβλήθηκε. Αλλά η πορεία δεν θα παραπέμψει την σημασία για την περαιτέρω πειθαρχικά μέτρα, εκτός από τις περιπτώσεις επανειλημμένων πράξεων. Με άλλα λόγια, αν κάνουν κάποια ηλίθιο, ειδικά αργά τη νύχτα, η απόφαση ότι το επόμενο πρωί με δύο μέρες αργότερα, ξυπνάς και να συνειδητοποιήσουν, τι σκεφτόμουν; Μπορείτε να το κάνετε σε CS50 έχει μια έξοδο για τον καθορισμό αυτό το πρόβλημα και η ιδιοκτησία σε αυτό, έτσι ώστε να θα σας συναντήσει στα μισά του δρόμου και την αντιμετώπιση με αυτό σε ένα θέμα που είναι τόσο εκπαιδευτικές και πολύτιμη για εσάς, αλλά εξακολουθεί να τιμωρητική με κάποιο τρόπο. Και τώρα, για να λάβει την άκρη μακριά, αυτό. 

[ΑΝΑΠΑΡΑΓΩΓΉ ΒΊΝΤΕΟ] 

[ΜΟΥΣΙΚΗ Playing] 

[ΤΕΛΟΣ ΑΝΑΠΑΡΑΓΩΓΗ] DAVID J. Malan: Εντάξει, είμαστε πίσω. Και τώρα θα δούμε σε ένα από τα πρώτη του πραγματικού κόσμου τομείς μας σε CS50, η τέχνη της κρυπτογραφίας, η τέχνη της αποστολής και λήψης μυστικά μηνύματα, κρυπτογραφημένα μηνύματα, αν θέλετε, ότι μπορεί να αποκρυπτογραφηθεί μόνο εάν έχετε κάποια βασικό συστατικό ότι ο αποστολέας έχει επίσης. Έτσι για να παρακινήσει αυτό θα ρίξουμε μια ματιά σε αυτό το πράγμα εδώ, το οποίο είναι ένα παράδειγμα ενός μυστικό δαχτυλίδι αποκωδικοποιητή ότι μπορεί να χρησιμοποιηθεί για να καταλάβω ό, τι ένα μυστικό μήνυμα είναι στην πραγματικότητα. Στην πραγματικότητα, πίσω στο μέρα στο σχολείο βαθμού, αν στείλει ποτέ μυστικό μηνύματα σε κάποιος φίλος ή κάποιο φλερτ στην τάξη, μπορεί να έχετε σκεφτεί ήσουν είσαι έξυπνος από το κομμάτι σας χαρτί αλλαγή, όπως, το Α στο Β, και Β σε C και C έως D, και ούτω καθεξής. Αλλά θα ήταν πραγματικά κρυπτογράφηση τις πληροφορίες σας, ακόμα και αν ήταν λίγο ασήμαντο, δεν ήταν ότι σκληρά για το δάσκαλο να συνειδητοποιήσει, καλά, αν απλά αλλάξετε Β σε Α και Γ στο Β, μπορείτε πραγματικά να καταλάβω ποιο είναι το μήνυμα ήταν, αλλά θα ήταν σε κρυπτογραφήσεως πληροφορίες. 

Ήσουν απλά να κάνει απλά, σαν Ralphie εδώ σε μια διάσημη ταινία που παίζει λίγο πολύ nauseum ad κάθε χειμώνα. [ΑΝΑΠΑΡΑΓΩΓΉ ΒΊΝΤΕΟ] -Να Είναι γνωστό σε όλους ότι Ralph Parker είναι παρόν τακτικό μέλος της Μικρής Τα ορφανά Annie Secret Circle και δικαιούται να επικαλείται όλα τα τιμά και τα οφέλη που συμβαίνουν σ 'αυτό. 

-Signed, Little Orphan Annie, θεωρημένη Pierre Andre, με μελάνι. Τιμητικές διακρίσεις και τα οφέλη, ήδη στην ηλικία των εννέα. 

[ΚΡΑΥΓΈΣ] -Ελα. Ας προχωρήσουμε με αυτό. Δεν χρειάζεται όλη αυτή η τζαζ για τους λαθρεμπόρους και τους πειρατές. 

Ακούστε αύριο το βράδυ για Η περιπέτεια καταληκτική του μαύρο πειρατικό πλοίο. Τώρα, ήρθε η ώρα για μυστικό μήνυμα της Annie για εσάς τα μέλη της Μυστικής Κύκλου. Θυμηθείτε, τα παιδιά, μόνο τα μέλη της Annie Μυστική Κύκλος μπορεί να αποκωδικοποιήσει το μυστικό μήνυμα Annie του. 

Θυμηθείτε, η Annie είναι ανάλογα με σας. Ορίστε καρφίτσες σας Β2. Εδώ είναι το μήνυμα. 12, 11-- 

-Είμαι Στην πρώτη μου μυστική συνάντηση. 

-14, 11, 18, 16. 

-Pierre Ήταν σε μεγάλη φωνή απόψε. Θα μπορούσα να πω ότι απόψε μήνυμα ήταν πραγματικά σημαντικό. 

-3, 25, αυτό είναι ένα μήνυμα από Annie τον εαυτό της. Θυμηθείτε, μην το πω σε κανέναν. 

-90 Δευτερόλεπτα αργότερα, είμαι στο μόνο δωμάτιο του σπιτιού, όπου ένα αγόρι εννέα θα μπορούσε να καθίσει στην προστασία της ιδιωτικής ζωής και αποκωδικοποιήσει. Aha, Β! Πήγα στο επόμενο, Ε 

Η πρώτη λέξη είναι να είναι. S, ερχόταν πιο εύκολο τώρα, U, 25-- 

-ΟΗ, Έλα, Ralphie, πρέπει να φύγω! 

-I'll Να είναι δεξιά κάτω, Ma! Gee σφυρίζω! 

-T, O, να είστε βέβαιος to-- να είναι σίγουρος για το τι; Ποια ήταν η Μικρή ορφανά Annie προσπαθώ να πω; Να είστε βέβαιος για το τι; 

-Ralphie, Andy έχει να πάτε, θα σας παρακαλούμε να βγει; 

-Όλα Τα δεξιά, Ma! Θα είμαι δεξιά έξω! 

-I Ήταν να πάρει πιο κοντά τώρα. Η ένταση ήταν τρομερή. Τι ήταν αυτό? Η μοίρα του πλανήτη μπορεί να κολλήσει στην ισορροπία. 

-Ralphie! Gotta Andy πάμε! 

-I'll Είναι δεξιά έξω, για να φωνάξει δυνατά! 

-σχεδόν Εκεί, τα δάχτυλά μου πέταξε, το μυαλό μου Ήταν μια παγίδα χάλυβα, κάθε πόρο δονείται. Ήταν σχεδόν σαφές, ναι, ναι, ναι. 

-Να Είστε βέβαιος να πίνετε Ovaltine σας. Ovaltine; Ένας ταλαιπωρημένος εμπορικό; Κάθαρμα. [ΤΕΛΟΣ ΑΝΑΠΑΡΑΓΩΓΗ] DAVID J. Malan: Εντάξει, έτσι ότι ήταν ένα πολύ μακρύ δρόμο της εισαγωγής κρυπτογραφίας, και επίσης Ovaltine. Στην πραγματικότητα, από αυτό το παλιό αγγελία εδώ, γιατί είναι Ovaltine τόσο καλό; Είναι μια συμπυκνωμένη εκχύλιση ώριμων βύνη κριθαριού, καθαρό κρεμώδες αγελαδινό γάλα, και ειδικά παρασκευασμένα κακάο, μαζί με φυσικό φωσφατίδια και βιταμίνες. Είναι επίσης εμπλουτισμένα με πρόσθετες βιταμίνες Β και D, yum. Και μπορείτε να το πάρετε, προφανώς, για την Amazon, όπως κάναμε εδώ. 

Αλλά το κίνητρο εδώ ήταν να εισαγάγει κρυπτογραφία, ειδικά ένα είδος κρυπτογραφίας γνωστών ως μυστικό κλειδί κρυπτογράφησης. Και όπως υποδηλώνει το όνομα, το σύνολο ασφάλεια από ένα μυστικό κλειδί του συστήματος κρυπτογραφίας, αν θέλετε, μια μεθοδολογία για μόλις κρυπτογράφησης πληροφοριών μεταξύ δύο ανθρώπων, είναι ότι μόνο ο αποστολέας και ο παραλήπτης μόνο ξέρετε ένα μυστικό key-- κάποια αξία, μερικά μυστική φράση, κάποιο μυστικό αριθμό, ότι τους επιτρέπει τόσο για την κρυπτογράφηση και την αποκρυπτογράφηση των πληροφοριών. Και κρυπτογραφία, πραγματικά, Είναι ακριβώς αυτό από την εβδομάδα 0. 

Είναι ένα πρόβλημα όπου υπάρχει εισόδους, όπως το πραγματικό μήνυμα στα αγγλικά ή ό, τι γλώσσα που θέλετε να στείλετε σε κάποιον στην τάξη, ή μέσω του Διαδικτύου. Υπάρχει κάποια έξοδος, η οποία πρόκειται να είναι το κωδικοποιημένο μήνυμα που θέλετε ο παραλήπτης να λάβει. Και ακόμα και αν κάποιος στην μέση λαμβάνει πάρα πολύ, δεν τους θέλουν να απαραιτήτως να είναι σε θέση να το αποκρυπτογραφήσει, γιατί μέσα από αυτό μαύρο κουτί, ή αλγόριθμο, είναι κάποιος μηχανισμός, μερικά βήμα-βήμα οδηγίες, για την λήψη της εισόδου και μετατροπή σε η εξόδου, το ελπίζω με ασφαλή τρόπο. 

Και, στην πραγματικότητα, υπάρχει κάποια λεξιλόγιο σε αυτόν τον κόσμο ως εξής. Απλό κείμενο είναι η λέξη ένα επιστήμονας υπολογιστών θα χρησιμοποιούμε για να περιγράψουμε την είσοδο μήνυμα, όπως το αγγλικό ή ό, τι γλώσσα που πραγματικά θέλετε να στείλετε σε κάποιον άλλο άνθρωπο. Και τότε το κρυπτογράφημα είναι το σκαρφάλωμα στο κρυπτογραφημένες, ή κρυπτογραφημένη, έκδοση αυτών. 

Αλλά υπάρχει ένα άλλο συστατικό εδώ. Υπάρχει μια άλλη είσοδο για να μυστικό κλειδί κρυπτογράφησης. Και αυτό είναι το κλειδί για τον εαυτό της, το οποίο είναι, σε γενικές γραμμές, όπως θα δούμε, ένας αριθμός, ή e-mail, ή μια λέξη, ανεξαρτήτως ο αλγόριθμος είναι στην πραγματικότητα περιμένει. 

Και πώς να αποκρυπτογραφήσει τις πληροφορίες; Πώς μπορείτε να το βάλει στη σωστή σειρά; Λοιπόν, μόλις αντιστραφεί η έξοδοι και οι είσοδοι. 

Με άλλα λόγια, όταν κάποιος λαμβάνει κρυπτογραφημένο μήνυμα σας, αυτός ή αυτή απλά έχει να γνωρίζουν το ίδιο κλειδί. Έχουν λάβει το κρυπτοκείμενο. Και συνδέοντας αυτά τα δύο εισροές στο σύστημα κρυπτογραφίας, ο αλγόριθμος, αυτό το μαύρο κουτί, έξω θα πρέπει να έρθει το αρχικό απλό κείμενο. Και έτσι αυτό είναι το πολύ υψηλό επίπεδο άποψη για το τι είναι στην πραγματικότητα κρυπτογραφίας όλα για. 

Ας φτάσουμε εκεί. Ας δούμε τώρα κάτω Η κουκούλα του κάτι έχουμε ήδη λάβει ως δεδομένο για την περασμένη εβδομάδα, και γι 'αυτό συνεδρίας here-- το string. Μια χορδή στο τέλος της ημέρας είναι απλά μια ακολουθία χαρακτήρων. 

Θα μπορούσε να είναι ο κόσμος ένα γεια, ή γεια Zamyla, ή οτιδήποτε άλλο. Αλλά τι σημαίνει αυτό για είναι μια ακολουθία χαρακτήρων; Στην πραγματικότητα, η βιβλιοθήκη CS50 δίνει μας ένας τύπος δεδομένων που ονομάζεται χορδή. 

Αλλά στην πραγματικότητα δεν υπάρχει τέτοιο πράγμα όπως ένα string σε C. Είναι πραγματικά ακριβώς μια ακολουθία χαρακτήρα, χαρακτήρα, χαρακτήρα, χαρακτήρα, πίσω, προς τα πίσω, για να πίσω, προς τα πίσω, προς τα πίσω μέσα της μνήμης του υπολογιστή σας, ή RAM. Και θα εξετάσουμε βαθύτερα ότι η μέλλον, όταν κοιτάξουμε την ίδια μνήμη, και η χρησιμοποίηση, και ο απειλές που εμπλέκονται. 

Αλλά ας εξετάσουμε το string Zamyla. Έτσι απλά το όνομα της η ανθρώπινη εδώ, Zamyla, ότι είναι μια ακολουθία χαρακτήρες, Ζ-Α-Μ-Y-L-A. Και τώρα ας υποθέσουμε ότι το όνομα Zamyla του που αποθηκεύονται μέσα σε ένα υπολογιστή πρόγραμμα. 

Λοιπόν, στέκεται στο λόγο ότι θα έπρεπε να είναι σε θέση να εξετάσουμε αυτούς τους χαρακτήρες ατομικά. Έτσι, είμαι απλώς πρόκειται να συντάξει ένα μικρό κουτί γύρω από το όνομά Zamyla εδώ. Και αυτό συμβαίνει σε C ότι όταν έχουν μια σειρά, όπως Zamyla-- και ίσως ότι η χορδή έχει επιστρέψει από μια λειτουργία όπως εγχόρδων get, μπορείτε πραγματικά να χειριστείτε το χαρακτήρα προς χαρακτήρα. 

Τώρα, αυτό είναι σχετικός για το συνομιλία στο χέρι, επειδή στην κρυπτογραφία, αν θέλετε να αλλάξετε Α στο Β, και Β σε C και C έως D, και ούτω καθεξής, θα πρέπει να είναι σε θέση να δούμε τις επιμέρους χαρακτήρες σε μια σειρά. Θα πρέπει να είναι σε θέση να αλλάξει το Z σε κάτι άλλο, το Α σε κάτι άλλο, το Μ να κάτι άλλο, και ούτω καθεξής. Και γι 'αυτό χρειαζόμαστε έναν τρόπο, προγραμματισμού, έτσι να μιλήσει, σε C για να είναι σε θέση να αλλάξει και να κοιτάξουμε μεμονωμένα γράμματα. Και μπορούμε να το κάνουμε αυτό ως εξής. 

Επιτρέψτε μου να πάω το κεφάλι πίσω στο CS50 IDE. Και επιτρέψτε μου να πάει μπροστά και να δημιουργήσετε ένα νέο αρχείο ότι θα καλέσω αυτή τη φορά string0, ως το πρώτο τέτοιο παράδειγμα μας, τελεία γ. Και Πάω να πάει μπροστά και το μαστίγιο ως εξής. 

Έτσι περιλαμβάνουν CS50.h, και Στη συνέχεια περιλαμβάνει τις τυποποιημένες io.h, το οποίο είμαι σχεδόν πάντα πρόκειται να να χρησιμοποιούν σε προγράμματα μου, τουλάχιστον αρχικά. int main κενό, και στη συνέχεια, εδώ είμαι πρόκειται να κάνει χορδές παίρνει πάρει εγχόρδων. Και τότε Πάω να να προχωρήσει και να το κάνουμε αυτό. Θέλω να πάω μπροστά και, ως επιταγή λογική, μόνο να πω, γεια, τοις εκατό s, ερωτηματικό, κάνει εγχόρδων 0. Ωχ, τι έκανα εδώ; Αχ, εγώ δεν το συνδέσετε. Έτσι δίδαγμα, ότι δεν ήταν εσκεμμένο. 

Έτσι σφάλμα, περισσότερο τοις εκατό μετατροπές από τα επιχειρήματα των δεδομένων. Και αυτό είναι που, σε γραμμή 7-- Εντάξει, έτσι έχω, απόσπασμα εισαγωγικά, ότι είναι κορδόνι μου στο printf. Έχω ένα σημάδι τοις εκατό. Αλλά είμαι λείπει το δεύτερο επιχείρημα. 

Είμαι λείπει το κόμμα, το οποίο Είχα στα προηγούμενα παραδείγματα. Έτσι, μια καλή ευκαιρία για να διορθώσετε ένα ακόμα λάθος, λάθος. Και τώρα επιτρέψτε μου να τρέξει string0, πληκτρολογήστε Zamyla. Εντάξει, γεια Zamyla. 

Έτσι έχουμε τρέξει αυτό το είδος του προγράμματος μερικές διαφορετικές φορές μέχρι τώρα. Αλλά ας κάνουμε κάτι λίγο διαφορετικά αυτή τη φορά. Αντί απλά την εκτύπωση Zamyla του ολόκληρο το όνομα με printf, ας το κάνουμε ανά χαρακτήρα. 

Πάω να χρησιμοποιήσετε ένα βρόχο for. Και Πάω να δώσω στον εαυτό μου μια μεταβλητή καταμέτρηση, που ονομάζεται i. Και Πάω να κρατήσει την επανάληψη, έτσι Όσο i είναι μικρότερο από το μήκος του s. 

Αποδεικνύεται, δεν το κάναμε κάνετε αυτή την τελευταία φορά, ότι γ έρχεται με ένα συνάρτηση που ονομάζεται Stirling. Πίσω στην ημέρα, και σε γενικές γραμμές ακόμα κατά την εφαρμογή λειτουργιών, οι άνθρωποι θα επιλέγουν συχνά πολύ συνοπτική ονόματα αυτό το είδος του ήχου όπως αυτό που θέλετε, ακόμα κι αν είναι λείπουν μερικά φωνήεντα ή γράμματα. Έτσι Stirling είναι η όνομα της συνάρτησης που παίρνει ένα επιχείρημα μεταξύ παρενθέσεις που θα πρέπει να είναι ένα string. Και επιστρέφει ακριβώς έναν ακέραιο αριθμό, το μήκος της συμβολοσειράς. 

Έτσι, αυτό για το βρόχο στη γραμμή 7 πρόκειται να αρχίσουμε να μετράμε σε i ισούται με 0. Είναι πρόκειται να αυξήσετε i σε κάθε επανάληψη με 1, όπως έχουμε κάνει μερικές φορές. Αλλά πρόκειται να κάνουμε μόνο αυτό μέχρι το σημείο όταν i είναι το μήκος της ίδιας της στοιχειοσειράς. 

Έτσι, αυτό είναι ένας τρόπος, τελικά, την επανάληψη πάνω από τους χαρακτήρες στη συμβολοσειρά όπως είναι εξής. Πάω να εκτυπώσετε όχι ολόκληρη σειρά, αλλά τοις εκατό c, ένα ενιαίο χαρακτήρα ακολουθείται από μια νέα γραμμή. Και τότε Πάω να να προχωρήσει, και χρειάζομαι να πω θέλω να εκτυπώσετε i-χαρακτήρας του s. 

Έτσι, αν i είναι η μεταβλητή που δείχνει ο δείκτης του κορδονιού, όπου είστε σε αυτό, θα πρέπει να είναι σε θέση να λένε, να μου δώσει το i-οστό χαρακτήρα του s. Και γ έχει τον τρόπο του να κάνει αυτό με αγκύλες. Μπορείτε απλά να πω το όνομα του χορδών, η οποία στην προκειμένη περίπτωση είναι s. Στη συνέχεια, μπορείτε να χρησιμοποιήσετε αγκύλες, τα οποία είναι συνήθως ακριβώς πάνω από Return ή Enter σας πλήκτρο στο πληκτρολόγιο. Και στη συνέχεια βάζετε το δείκτη του χαρακτήρα που θέλετε να εκτυπώσετε. Έτσι, ο δείκτης πρόκειται να είναι μια number-- 0, ή 1, ή 2, ή 3, ή τελεία, τελεία, τελεία, κάποιο άλλο αριθμό. 

Και έχουμε διασφαλίσει ότι πρόκειται να είναι το σωστό αριθμό, γιατί αρχίζουν να μετρούν σε 0. Και από προεπιλογή, ο πρώτος χαρακτήρας σε μια σειρά είναι κατά συνθήκη 0. Και ο δεύτερος χαρακτήρας είναι στήριγμα 1. Και ο τρίτος χαρακτήρας είναι στήριγμα 2. Και δεν θέλετε να πάει πολύ μακριά, αλλά εμείς δεν θα επειδή είμαστε πρόκειται να αυξήσετε i μόνο μέχρι να ισούται με το μήκος του νήματος. Και στο οποίο σημείο, αυτό για loop θα σταματήσει. 

Επιτρέψτε μου λοιπόν να πάει μπροστά και να σώσει αυτό το πρόγραμμα, και τρέχει να κάνει κορδόνι 0. Αλλά εγώ μαντάρα. Σιωπηρά δηλώνοντας τη λειτουργία της βιβλιοθήκης Stirling με τον τύπο, όπως και such-- τώρα, αυτό ακούγεται οικείο. Αλλά δεν printf. Και δεν είναι να πάρει εγχόρδων. 

Εγώ δεν βίδα μέχρι το με τον ίδιο τρόπο αυτή τη φορά. Αλλά παρατηρήσετε εδώ κάτω λίγο προς τα κάτω περαιτέρω, περιλαμβάνουν την string.h κεφαλίδα, προβλέπουν ρητά η δήλωση για Stirling. Έτσι, υπάρχει πραγματικά μια ένδειξη εκεί. 

Και πράγματι αποδεικνύεται υπάρχει ένα άλλο αρχείο κεφαλίδας ότι δεν έχω χρησιμοποιήσει στην τάξη ακόμα, αλλά είναι μεταξύ εκείνων που διατίθενται για να σας, που ονομάζεται string.h. Και σε αυτό το αρχείο, string.h είναι Stirling δηλωθεί. Επιτρέψτε μου λοιπόν να πάει μπροστά και να αποθηκεύσετε αυτή, κάνει εγχόρδων 0-- ωραίο, δεν υπάρχουν μηνύματα λάθους αυτή τη φορά. 

./string0 Zamyla, και Είμαι έτοιμος να πατήστε Enter, σε ποιο σημείο getstring πρόκειται να επιστρέψει το string, το έθεσε σε s. Στη συνέχεια, ότι για βρόχος πρόκειται να επαναλάβει πάνω από τους χαρακτήρες του S, ένα κάθε φορά, και να τις εκτυπώσετε μία ανά γραμμή, επειδή Είχα αυτή την ανάστροφη κάθετο n στο τέλος. Έτσι θα μπορούσα να παραλείψετε αυτό το backslash n, και στη συνέχεια απλά να εκτυπώσετε Zamyla όλα στην ίδια γραμμή, αποτελεσματικά reimplementing printf, η οποία δεν είναι καθόλου χρήσιμο. Αλλά στην περίπτωση αυτή, δεν έχω κάνει αυτό. Έχω πραγματικά τυπωμένο ένα χαρακτήρα σε μια στιγμή, ένα ανά γραμμή, έτσι ώστε να δούμε πραγματικά το αποτέλεσμα. 

Αλλά θα ήθελα να τονίσω ένα πράγμα εδώ. Και θα επανέλθουμε αυτό σε μια μελλοντική εβδομάδα. Αποδεικνύεται ότι αυτό κώδικας είναι δυνητικά λάθη. 

Αποδεικνύεται ότι το κορδόνι get και κάποιες άλλες λειτουργίες της ζωής δεν κάνει απαραίτητα πάντα επιστρέφουν αυτό που περιμένουμε. Γνωρίζουμε από την τάξη τελευταία φορά σε αυτό που παίρνουν κορδόνι υποτίθεται ότι θα επιστρέψει ένα string. Τι γίνεται όμως όταν ο χρήστης πληκτρολογεί τέτοιου είδους μια μακρά λέξη ή σκέψη, ή ένα δοκίμιο ότι υπάρχει απλά δεν είναι αρκετό μνήμη στον υπολογιστή για να το χωρέσει. 

Όπως, τι θα γινόταν αν κάτι πάει λάθος κάτω από την κουκούλα; Μπορεί να μην συμβαίνει συχνά, αλλά θα μπορούσε να συμβεί μία φορά σε μια στιγμή, πολύ σπάνια. Και έτσι αποδεικνύεται ότι εγχόρδων get και λειτουργίες όπως το κάνουμε δεν είναι απαραίτητα πάντα επιστρέφουν χορδές. Μπορεί να επιστρέψει κάποια τιμή σφάλματος, κάποια αξία φρουρού να το πω έτσι, που δείχνει ότι κάτι έχει πάει στραβά. Και εσείς θα ξέρετε μόνο αυτό από έχοντας μάθει στην τάξη τώρα, ή έχοντας διαβάσει κάποια περισσότερη τεκμηρίωση. Αποδεικνύεται ότι το κορδόνι get μπορεί να επιστρέψει μια τιμή που ονομάζεται μηδενική. Null είναι μια ειδική αξία ότι θα επανέλθει στην μελλοντική εβδομάδα. Αλλά για τώρα, απλά να ξέρετε ότι αν θέλω να είναι πραγματικά κατάλληλη για τη μετακίνηση προς τα εμπρός χρησιμοποιώντας εγχόρδων πάρει, εγώ δεν θα πρέπει να την αποκαλούν απλώς, και τυφλά χρησιμοποιήσει τιμή επιστροφής της, πιστεύοντας ότι αυτό είναι ένα string. 

Θα πρέπει πρώτα να πω, hey, περιμένετε ένα λεπτό, μόνο να πραγματοποιηθεί, εάν s δεν είναι ίσο με null, όπου null, και πάλι, είναι μερικά μόνο από ιδιαίτερη αξία. Και είναι η μόνη ιδιαίτερη αξία σας χρειάζεται να ανησυχείτε για για κορδόνι get. Πάρτε κορδόνι είτε πρόκειται να επιστρέψει ένα string ή null. 

Και αυτό το θαυμαστικό ίσον ίσως γνωρίζετε από ίσως μάθημα των Μαθηματικών ότι μπορεί να αντλήσει ένα ίσον με μια γραμμή μέσα από αυτό για να δείξει όχι ίσες. Αυτό δεν είναι γενικά ένα χαρακτήρα μπορείτε να πληκτρολογήσετε στο πληκτρολόγιό σας. Και έτσι στις περισσότερες γλώσσες προγραμματισμού, όταν θέλετε να πείτε όχι ίσο, μπορείτε να χρησιμοποιήσετε ένα θαυμαστικό, αλλιώς γνωστή ως κτύπημα. Έτσι που λέτε κτύπημα ισούται, η οποία δεν σημαίνει ισούται, λογικά. Είναι ακριβώς σαν να μην υπάρχει μια μεγαλύτερη από, ή ίση με, ή μικρότερη από ή ίση με πλήκτρο στο πληκτρολόγιό σας ότι τα κάνει όλα σε ένα σύμβολο. Έτσι, γι 'αυτό, στο παρελθόν παραδείγματα, κάνατε ένα ανοιχτό βραχίονα, και στη συνέχεια, ένα σύμβολο της ισότητας, προκειμένου να γίνει ή μεγαλύτερη από, ας πούμε, λιγότερο από ό, τι. 

Έτσι ποια είναι η takeaway εδώ; Αυτό είναι απλά ένας τρόπος τώρα εισάγοντας αυτή τη σύνταξη, αυτό το χαρακτηριστικό, επανάληψη των ατομικών χαρακτήρες σε μια σειρά. Και ακριβώς όπως αυτά τα τετραγωνικά παρένθεση σας επιτρέπουν να πάρετε σε αυτούς, να εξετάσει αυτές τις αγκύλες, όπως είδος υπαινίχθηκε σε αυτό το υποκείμενο σχεδιασμού, σύμφωνα με την οποία κάθε χαρακτήρα μέσα από μια σειρά είναι το είδος της εγκλωβιστούμε σε κάπου κάτω η κουκούλα στη μνήμη του υπολογιστή σας. 

Αλλά ας κάνουμε μια παραλλαγή αυτού. Αποδεικνύεται ότι αυτό πρόγραμμα είναι σωστή. Έτσι, ανά άξονα CS50 για την αξιολόγηση κώδικα, αυτό είναι σωστό τώρα. Ειδικά τώρα που είμαι έλεγχος για null, το πρόγραμμα αυτό δεν πρέπει ποτέ να διακοπεί. Και ξέρω ακριβώς ότι από την εμπειρία. Αλλά δεν υπάρχει τίποτα άλλο που μπορούμε πραγματικά να πάει στραβά εδώ. Αλλά δεν είναι πολύ καλά σχεδιασμένη, γιατί ας πάμε πίσω στα βασικά. 

Κατ 'αρχάς, principles-- τι ένα για το βρόχο κάνω; Ένας βρόχος for κάνει τρία πράγματα. Προετοιμάζει μερικά αξία, αν το ζητήσετε. Ελέγχει μια κατάσταση. Και στη συνέχεια μετά από κάθε επανάληψη, μετά από κάθε κύκλο, αυτό αυξάνει μερικά αξία, ή τις αξίες, εδώ. 

Λοιπόν, τι σημαίνει αυτό; Έχουμε προετοιμαστεί θ 0. Ελέγχουμε και να είμαι σίγουρη ότι είναι λιγότερο από ό, τι το μήκος του, η οποία είναι Ζ-Α-Μ-Υ-Ε-Α, οπότε η οποία είναι μικρότερη από 6. Και, πράγματι, 0 ως λιγότερο από 6. 

Εμείς εκτυπώσετε Ζ από το όνομα Zamyla του. Τότε i αυξήσετε από 0 έως 1. Εμείς στη συνέχεια, ελέγξτε, είναι ένα λιγότερο από το μήκος του s; Το μήκος του s είναι 6. Ναι είναι. 

Έτσι μπορούμε να εκτυπώσετε ένα στο όνομα Zamyla του, ΖΑ. Εμείς θ αυξήσετε από 0 σε 1, σε 2. Εμείς στη συνέχεια, ελέγξτε, είναι μικρότερη από 2 το μήκος του ονόματος Zamyla του. 6- έτσι 2 είναι μικρότερη από 6. Ναι, ας εκτυπώσετε τώρα Μ σε Το όνομά Zamyla, ο τρίτος χαρακτήρας. 

Το κλειδί εδώ είναι ότι σε κάθε επανάληψη της ιστορίας, είμαι έλεγχο, είναι i μικρότερο από το μήκος του Zamyla; Αλλά η σύλληψη είναι ότι Stirling δεν είναι ένα ξενοδοχείο. Όσοι από εσάς έχετε προγραμματίσει πριν σε Java ή άλλες γλώσσες μπορεί να γνωρίζει το μήκος ενός string είναι ένα ακίνητο, μόνο μερικά μόνο για ανάγνωση αξία. 

Στην C σε αυτήν την περίπτωση, αν αυτό είναι μια λειτουργία που είναι κυριολεκτικά μετρώντας τον αριθμό των χαρακτήρες σε Zamyla κάθε φορά καλούμε την εν λόγω λειτουργία. Κάθε φορά που θα ζητήσει από τον υπολογιστή για να χρησιμοποιήσετε Stirling, είναι να ρίξουμε μια ματιά σε Zamyla, και λέγοντας Ζ-Α-Μ-Υ-Ε-Α, 6. Και επιστρέφει 6. Την επόμενη φορά που θα καλέσετε το μέσα ότι για βρόχο, πρόκειται να δούμε Zamyla πάλι, λένε Ζ-Α-Μ-Υ-Ε-Α, 6. Και πρόκειται να επιστρέψει 6. Έτσι τι είναι ηλίθια σχετικά με αυτό το σχέδιο; 

Γιατί είναι ο κώδικας δεν σε 5 από τα 5 μου για το σχεδιασμό τώρα, να το πω έτσι; Λοιπόν, ρωτάω ένα ερώτηση άσκοπα. Κάνω περισσότερη δουλειά από ό, τι χρειαστεί. 

Έτσι, ακόμη και αν η απάντηση είναι σωστή, είμαι ζητώντας από τον υπολογιστή, τι είναι το μήκος του Zamyla πάλι, και ξανά, και ξανά, και ξανά; Και η απάντηση είναι Ποτέ δεν πρόκειται να αλλάξει. Είναι πάντα θα είναι 6. 

Έτσι, μια καλύτερη λύση από αυτή θα είναι αυτή η επόμενη έκδοση. Επιτρέψτε μου να πάει μπροστά και το βάζουμε σε ένα ξεχωριστό αρχείο που ονομάζεται string1.c, μόνο για να κρατήσει το διαχωρισμό. Και αποδεικνύεται σε ένα για την βρόχο, μπορείτε πραγματικά δηλώνουν πολλών μεταβλητών με τη μία. 

Έτσι, Πάω να κρατήσει i και να το θέσει σε 0. Αλλά είμαι επίσης πρόκειται να προσθέστε ένα κόμμα, και να πω, να μου δώσει μια μεταβλητή που ονομάζεται n, του οποίου η αξία ισούται με το μήκος του νήματος του s. Και τώρα, παρακαλούμε να κάνετε την κατάστασή μου εφ 'όσον το i είναι μικρότερο από το Ν. 

Έτσι, με αυτόν τον τρόπο, η λογική είναι ταυτόσημες στο τέλος της ημέρας. Είμαι, όμως, να θυμόμαστε το αξία 6, σε αυτή την περίπτωση. Ποιο είναι το μήκος του ονόματος Zamyla του; Και είμαι το θέτει σε n. 

Και είμαι ακόμα έλεγχο η κατάσταση κάθε φορά. 0 λιγότερο από 6; Είναι 1 λιγότερο από 6; Είναι 2 λιγότερο από 6, και ούτω καθεξής; 

Αλλά δεν είμαι ζητώντας από τον υπολογιστή και πάλι, και πάλι, τι είναι το μήκος του ονόματος Zamyla του; Ποιο είναι το μήκος του ονόματος Zamyla του; Ποιο είναι το μήκος του ονόματος αυτού Zamyla του; Είμαι κυριολεκτικά να θυμηθούμε ότι το πρώτο και απαντήσει μόνο σε αυτή τη δεύτερη μεταβλητή n. Έτσι, αυτό τώρα θα ήταν όχι μόνο σωστή, αλλά επίσης καλά σχεδιασμένη. 

Τώρα, τι γίνεται με το στυλ; Έχω μεταβλητές με όνομα μου αρκετά καλά, θα έλεγα. Είναι σούπερ σύντομη αυτή τη στιγμή. Και αυτό είναι απολύτως εντάξει. 

Αν έχετε μόνο ένα συμβολοσειράς σε ένα πρόγραμμα, ίσως και να το ονομάσουμε S για τον σπάγκο. Αν έχετε μόνο μία μεταβλητή για την καταμέτρηση σε ένα πρόγραμμα, ίσως και να το ονομάσουμε i. Εάν έχετε ένα μήκος, n είναι εξαιρετικά κοινή, καθώς και. Αλλά δεν έχουν σχολιάσει οποιοδήποτε κώδικα μου. 

Δεν έχω ενημερώσει την reader-- αν αυτό είναι TF μου, ή TA, ή απλά colleague-- τι υποτίθεται να συμβαίνει σε αυτό το πρόγραμμα. Και έτσι για να πάρετε καλό στυλ, ό, τι θα ήθελα να κάνω είναι this-- κάτι όπως ρωτήστε τον χρήστη για την είσοδο. Και θα μπορούσα να ξαναγράψει αυτό οποιοδήποτε αριθμό τρόπων. 

Βεβαιωθείτε S-- βεβαιωθείτε get συμβολοσειρά επιστρέφεται ένα string. Και στη συνέχεια σε here-- και αυτό είναι ίσως το πιο σημαντικό comment-- επαναλάβει πάνω από τους χαρακτήρες στην s, ένα κάθε φορά. Και θα μπορούσα να χρησιμοποιήσω οποιαδήποτε επιλογή της αγγλικής γλώσσας εδώ για να περιγράψει κάθε αυτών των κομματιών του κώδικα. 

Παρατηρήστε ότι δεν έχω βάλει ένα Σχολιάστε σε κάθε γραμμή κώδικα, πραγματικά μόνο για το ενδιαφέρον αυτοί, αυτοί που έχουν κάποιο νόημα ότι θα μπορούσα να θέλουν να κάνουν σούπερ σαφές σε κάποιον ανάγνωση τον κωδικό μου. Και γιατί σας καλούν να πάρετε κορδόνι ρωτήστε τον χρήστη για την είσοδο; Ακόμη και ότι δεν είναι κατ 'ανάγκη όλα αυτά περιγραφικό. Αλλά βοηθά πω μια ιστορία, επειδή η δεύτερη γραμμή στην ιστορία, βεβαιωθείτε πάρετε εγχόρδων επέστρεψε ένα string. 

Και η τρίτη γραμμή στην ιστορία είναι, επαναλάβει πάνω από τους χαρακτήρες στην s ένα σε μια στιγμή. Και τώρα μόνο για το καλό μέτρο, Πάω να πάει μπροστά και να προσθέσετε ένα ακόμη σχόλιο που μόλις λέει εκτύπωσης i-οστό χαρακτήρα s. Τώρα, τι έκανα στο τέλος της μέρας? 

Έχω προσθέσει κάποια αγγλικά λέξεων με τη μορφή σχολίων. σημαίνει το σύμβολο κάθετο κάθετο, hey, υπολογιστή αυτό είναι για τον άνθρωπο, δεν είναι για σας, ο υπολογιστής. Έτσι, από όπου και αν αγνοηθεί λογικά. Είναι απλά εκεί. 

Και, πράγματι, CS50 IDE τους δείχνει ως γκρι, ως χρήσιμη, αλλά όχι κλειδί στο πρόγραμμα. Παρατηρήστε τι μπορείτε τώρα να κάνετε. Είτε θέλετε να ξέρετε C προγραμματισμό ή όχι, μπορεί απλά να σταθεί πίσω σε αυτό πρόγραμμα, και το αποβουτυρωμένο τα σχόλια. Ζητήστε από το χρήστη για την είσοδο, βεβαιωθείτε πάρετε εγχόρδων επέστρεψε ένα string, επαναλάβει πάνω από τους χαρακτήρες στην s ένα κάθε φορά, εκτυπώστε το χαρακτήρα i-th χαρακτήρα S-- δεν το κάνετε ακόμη και να δούμε τον κώδικα να καταλάβουμε τι κάνει αυτό το πρόγραμμα. Και, ακόμα καλύτερα, αν εσείς οι ίδιοι φαίνονται σε αυτό το πρόγραμμα σε μια εβδομάδα ή δύο, ή ένα μήνα ή ένα έτος, εσείς δεν έχετε να κοιτάζω τον κώδικα, προσπαθώντας να θυμηθεί, τι προσπαθώ να κάνω με αυτόν τον κωδικό; 

Έχετε πει στον εαυτό σας. Έχετε αυτό που περιγράφεται για τον εαυτό σας, ή κάποιο συνάδελφο, ή TA, ή TF. Και έτσι αυτό θα είναι τώρα σωστή, και καλό σχεδιασμό, και, τελικά, καλό στυλ, καθώς και. Έτσι κάνετε να το έχουμε κατά νου. 

Έτσι, υπάρχει ένα άλλο πράγμα Πάω να κάνω εδώ ότι μπορούν τώρα να αποκαλύψει τι ακριβώς είναι συμβαίνει κάτω από το καπό. Έτσι υπάρχει αυτή η δυνατότητα σε C, και σε άλλες γλώσσες, που ονομάζεται typecasting ότι είτε σιωπηρά ή ρητά επιτρέπει να μετατρέψετε από έναν τύπο δεδομένων σε άλλο. Έχουμε ήδη ασχολούνται τόσο πολύ σήμερα με χορδές. 

Και έγχορδα είναι χαρακτήρες. Αλλά ανάκληση από εβδομάδα 0, ποιες είναι οι χαρακτήρες; Χαρακτήρες είναι απλώς μια αφηρημένη έννοια στην κορυφή του numbers-- δεκαδικοί αριθμοί, και δεκαδικών αριθμών είναι πραγματικά ακριβώς ένα αφαίρεσης πάνω από δυαδικούς αριθμούς, όπως την ορίσαμε. 

Έτσι, οι χαρακτήρες είναι αριθμοί. Και οι αριθμοί είναι χαρακτήρες, ακριβώς ανάλογα με το πλαίσιο. Και αποδεικνύεται ότι στο εσωτερικό ενός προγράμματος ηλεκτρονικού υπολογιστή, μπορείτε να καθορίσετε πώς θέλετε να αναζητήσετε στα κομμάτια στο εσωτερικό του εν λόγω προγράμματος; 

Ανάκληση από την εβδομάδα 0 που είχαμε Ascii, το οποίο είναι ακριβώς αυτός ο κώδικας γράμματα χαρτογράφηση σε αριθμούς. Και είπαμε, το κεφάλαιο Α είναι 65. Πρωτεύουσα Β είναι 66, και ούτω καθεξής. 

Και ειδοποίηση, έχουμε ουσιαστικά χαρακτήρες για η κορυφαία σειρά εδώ, όπως θα τους καλέσει C, χαρακτήρες, και στη συνέχεια ints στη δεύτερη σειρά. Και αποδεικνύεται μπορείτε να μετατρέψετε απρόσκοπτα μεταξύ των δύο, συνήθως. Και αν θέλουμε να κάνουμε αυτό σκόπιμα, θα μπορεί να θέλουν να αντιμετωπίσουν κάτι σαν αυτό. 

Μπορούμε ίσως να θέλετε να μετατρέψετε κεφαλαία για να μειώσει περίπτωση, ή πεζά σε κεφαλαία. Και αποδεικνύεται εκεί που στην πραγματικότητα ένα μοτίβο εδώ μπορούμε να αγκαλιάσει ακριβώς σε μια στιγμή. Αλλά ας δούμε πρώτα σε ένα παράδειγμα για να γίνει αυτό ρητά. 

Πάω να πάει πίσω στο CS50 IDE. Πάω να δημιουργήσει ένα αρχείο που ονομάζεται Ascii 0.c. Και Πάω να πάει μπροστά και να προσθέσετε μου πρότυπο io.h στην κορυφή, int main κενό στην κορυφή της συνάρτησης μου. Και τότε είμαι απλώς πρόκειται να κάνει η following-- ένα για το βρόχο από το i ισούται με, ας πούμε, 65. 

Και τότε εγώ πρόκειται να είναι μικρότερη από 65, συν 26 γράμματα του αλφαβήτου. Γι 'αυτό θα αφήσει τον υπολογιστή κάνει τα μαθηματικά για μένα εκεί. Και τότε μέσα σε αυτό το βρόχο, τι θα πάω να εκτυπώσετε; 

% C είναι% i ανάστροφη κάθετο n. Και τώρα θέλω να συνδέσετε δύο τιμές. Έχω βάλει προσωρινά ερώτηση σηματοδοτεί εκεί για να καλέσει την ερώτηση. 

Θέλω να επαναλάβει από 65 και μετά για 26 γράμματα της αλφαβήτου, εκτύπωση σε κάθε επανάληψη ότι αναπόσπαστο ισοδύναμο χαρακτήρα. Με άλλα λόγια, θέλω να επαναλάβει την εκτύπωση πάνω από 26 αριθμούς τι ο χαρακτήρας ASCII θα είναι, η επιστολή, και τι is-- ο αντίστοιχος αριθμός πραγματικά ακριβώς αναδημιουργία το διάγραμμα από την εν λόγω διαφάνεια. Λοιπόν, τι θα πρέπει να είναι αυτά τα ερωτηματικά; 

Λοιπόν, αποδεικνύεται ότι το δεύτερο θα πρέπει απλώς να είναι η μεταβλητή i. Θέλω να δω ότι ως αριθμός. Και η μεσαία επιχείρημα Εδώ, μπορώ να πω τον υπολογιστή να διαχειριστεί το εν λόγω ακέραιο i ως χαρακτήρα, έτσι ώστε να υποκαταστήσει εδώ για εκατό C. 

Με άλλα λόγια, αν η ανθρώπινη προγραμματιστής, ξέρετε αυτά είναι μόνο αριθμοί στο τέλος της μέρας. Και ξέρω ότι το 65 θα πρέπει να χάρτης σε κάποιο χαρακτήρα. Με αυτό το ρητό καστ, με μια παρένθεση, το όνομα του τύπου δεδομένων που θέλετε να μετατροπή σε, και μια κλειστή παρένθεση, μπορείτε να πείτε το υπολογιστή, hey, ηλεκτρονικών υπολογιστών, μετατρέψει αυτό το ακέραιο σε ένα char. 

Έτσι, όταν τρέχω αυτό προγράμματος μετά την κατάρτιση, ας δούμε τι get-- κάνουν Ascii 0. Καταριέται αυτό, τι έκανα λάθος εδώ; Χρησιμοποιήστε της αδήλωτης αναγνωριστικό, Εντάξει, όχι εκ προθέσεως, αλλά ας δούμε αν δεν μπορούμε να λόγο μέσα από αυτό. 

Έτσι γραμμή five-- έτσι δεν είχα πάρει πολύ μακριά πριν από το βίδωμα επάνω. Εντάξει. Έτσι γραμμή 5 για i ισούται με 65-- βλέπω. Ώστε να θυμάστε ότι σε C, σε αντίθεση με ορισμένους γλώσσες, αν έχετε προηγούμενη προγραμματισμού εμπειρία, έχετε για να πει τον υπολογιστή, σε αντίθεση με το μηδέν, τι το είδος της μεταβλητής είναι. 

Και ξέχασα μια φράση-κλειδί εδώ. Σύμφωνα πέντε, έχω αρχίσει να χρησιμοποιούν i. Αλλά δεν έχω πει C τι δεδομένα τύπου είναι. Έτσι, Πάω να πάει εδώ και λένε, αχ, ότι ένας ακέραιος κάνουν. 

Τώρα είμαι πρόκειται να πάει μπροστά και να ξαναμεταγλωττίσετε. Ότι το σταθερό αυτό. ./ascii0 Enter, αυτό είναι το είδος της δροσερό. Όχι μόνο είναι εξαιρετικά γρήγορο να να ζητήσει από τον υπολογιστή στο ερώτημα αυτό, αντί να ψάχνει επάνω σε μια διαφάνεια, να εκτυπώνεται μία ανά γραμμή, Α είναι 65, Β είναι 66, σε όλη τη διαδρομή down-- από τότε που έκανε αυτό 26 times-- στον γράμματα z, το οποίο είναι 90. Και, στην πραγματικότητα, ελαφρώς πιο ευφυής θα ήταν για μένα να μην βασίζεστε στον υπολογιστή για να προσθέσετε 26. Θα μπορούσα να είχα μόλις γίνει 90, καθώς και, εφ ' καθώς δεν κάνουν το ίδιο λάθος δύο φορές. Θέλω να πάω μέσα από z, όχι μόνο μέσα από το y. 

Έτσι ώστε να είναι ρητή καστ. Αποδεικνύεται ότι αυτό δεν είναι καν απαραίτητο. Επιτρέψτε μου να προχωρήσει και να επαναληφθεί αυτό compiler, και να επαναπροσδιοριστούν Ascii 0. Αποδεικνύεται ότι η C είναι αρκετά έξυπνος. 

Και printf, ιδίως, είναι αρκετά έξυπνος. Αν μόλις περάσει ένα i δύο φορές και για τα δύο σύμβολα κράτησης θέσης, printf θα συνειδητοποιήσει, OH, καλά θα γνωρίζετε μου έδωσε ένα integer-- κάποιο αριθμό, όπως 65, ή 90, ή οτιδήποτε άλλο. Αλλά βλέπω ότι θέλεις να διαμορφώστε τον αριθμό αυτό σαν χαρακτήρα. Και έτσι printf μπορεί να θέσει εμμέσως το int σε μια char για σας, καθώς και. Έτσι, αυτό δεν είναι ένα πρόβλημα σε όλα. 

Αλλά παρατηρήσετε, εξαιτίας αυτής της ισοδυναμίας μπορούμε πραγματικά να το κάνετε αυτό, καθώς και. Επιτρέψτε μου να προχωρήσει και να κάνει ένα άλλη εκδοχή του this-- Ascii 1.γ. Και αντί για επανάληψη πάνω ακέραιοι, μπορεί να φυσήξει πραγματικά το μυαλό σας με την επανάληψη πάνω από τους χαρακτήρες. Εάν ένα char c παίρνει κεφάλαιο Α, Ι θέλουν να πάνε μπροστά και να το κάνουμε αυτό, εφ 'όσον το C είναι μικρότερο ή ίσο έως το Ω κεφαλαίου και σε κάθε επανάληψη Θέλω να αυξήσετε C, μπορώ τώρα στη γραμμή printf μου εδώ ας πούμε, τοις εκατό C είναι τοις εκατό Εγώ πάλι, κόμμα C. 

Και τώρα, μπορώ να πάω την άλλη κατεύθυνση, χύτευση το χαρακτήρα ρητά σε ένα ακέραιο. Έτσι, και πάλι, γιατί θα το κάνετε αυτό; Είναι λίγο περίεργο να ταξινομήσετε του μετρήσει την άποψη των χαρακτήρων. 

Αλλά αν καταλαβαίνετε τι είναι συμβαίνει κάτω από το καπό, πραγματικά δεν υπάρχει μαγεία. Είσαι ακριβώς λέει, hey, υπολογιστή δώσει μένα μια μεταβλητή που ονομάζεται C τύπου char. Αρχικοποίηση αυτό στο κεφάλαιο Α και παρατηρήσετε μονά εισαγωγικά θέμα. 

Για τους χαρακτήρες σε C, ανάκληση από τους την περασμένη εβδομάδα, μπορείτε να χρησιμοποιήσετε μονά εισαγωγικά. Για έγχορδα, για τα λόγια, φράσεις, μπορείτε να χρησιμοποιήσετε διπλά εισαγωγικά. OK, ο υπολογιστής, συνεχίστε να το κάνετε αυτό, έτσι Όσο ο χαρακτήρας είναι μικρότερη από ή ίση με z. Και ξέρω από το τραπέζι Ascii μου ότι όλα από αυτούς τους κωδικούς ASCII είναι συνεχόμενα. 

Είναι δεν υπάρχουν κενά. Γι 'αυτό ακριβώς το A έως Z, που χωρίζονται από έναν αριθμό η κάθε μία. Και τότε μπορώ να αυξήσετε μια χαρα, αν θέλω πραγματικά. Στο τέλος της μέρας, Είναι απλά ένας αριθμός. Το ξερω αυτο. Έτσι απλά μπορώ να αποτολμήσω να προσθέσετε 1 σε αυτό. 

Και τότε αυτή τη φορά, μπορώ να εκτυπώσω γ, και στη συνέχεια το ολοκλήρωμα ισοδύναμο. Και δεν χρειάζεται καν τη ρητή καστ. Μπορώ να αφήσω printf και η Σχήμα υπολογιστή πράγματα, έτσι ώστε τώρα αν τρέχω κάνει Ascii1./ascii1, Παίρνω ακριβώς το ίδιο πράγμα, όπως καλά. 

Άχρηστο πρόγραμμα, though-- κανείς πρόκειται να γράψει πραγματικά λογισμικού Για να καταλάβω, ποια ήταν η αριθμός που αντιστοιχίζει σε Α ή Β ή Ζ; Είστε ακριβώς πρόκειται να το Google ή αναζητήστε το σε απευθείας σύνδεση, ή αναζητήστε το σε μια διαφάνεια, ή τα παρόμοια. Έτσι, όταν κάνει αυτό πραγματικά να πάρει χρήσιμα; 

Λοιπόν, μιλώντας για ότι slide, παρατηρήσετε υπάρχει ένα πραγματικό σχέδιο εδώ μεταξύ κεφαλαίων και πεζά που δεν ήταν τυχαία. Παρατηρήστε ότι το κεφάλαιο Α είναι 65. Πεζά ένας είναι 97. Και πόσο μακριά είναι χαμηλότερη περίπτωση; 

Έτσι, 65 είναι πόσα βήματα μακριά από το 97; Έτσι, 97 μείον 65 είναι 32. Έτσι κεφάλαιο ένα είναι 65. Αν προσθέσετε 32 σε αυτό, μπορείτε να πάρετε πεζά ένα. Και, αντίστοιχα, αν αφαιρέσουμε 32, μπορείτε να πάρετε πίσω στην πρωτεύουσα A-- ίδιο με το Β στο μικρό β, μεγάλα C σε λίγο c. 

Όλα αυτά τα κενά είναι 32 χώρια. Τώρα, αυτό φαίνεται να μας επιτρέψει να κάνει κάτι όπως το Microsoft Word, ή το Google Docs διαθέτουν, όπου μπορείτε να επιλέξετε τα πάντα και στη συνέχεια να πω, τα αλλάξει όλα σε πεζά, ή τα αλλάξει όλα με κεφαλαία γράμματα, ή να αλλάξετε μόνο την πρώτη λέξη της ποινής σε κεφαλαία. Μπορούμε να κάνουμε πραγματικά κάτι όπως κι εμείς. 

Επιτρέψτε μου να προχωρήσει και να αποθηκεύσετε ένα αρχείο εδώ ονομάζεται κεφαλαιοποιήσει 0.c. Και ας πάμε μπροστά και να μαστίγιο μέχρι ένα πρόγραμμα ότι κάνει ακριβώς αυτό ως εξής. Έτσι, περιλαμβάνουν τη βιβλιοθήκη CS50. Και περιλαμβάνει τις τυποποιημένες I / O. 

Και ξέρω ότι αυτό είναι σύντομα κοντά σας. Έτσι, Πάω να το βάλετε στο υπάρχουν ήδη, string.h, έτσι έχω πρόσβαση σε τα πράγματα όπως Stirling, και, στη συνέχεια, int main άκυρη, ως συνήθως. Και τότε Πάω να πάει μπροστά και να κάνει χορδές παίρνει πάρει string, απλά για να πάρετε μια σειρά από τον χρήστη. Και τότε Πάω να κάνετε check λογική μου. Αν κορδόνι δεν είναι ίσο με null, τότε είναι ασφαλές να προχωρήσει. Και τι θέλω να κάνω; Πάω να επαναλάβει από το i ισούται με 0, και Ν μέχρι το μήκος του νήματος του s. 

Και Πάω να το κάνετε αυτό, εφόσον i είναι μικρότερο από το η, και Ι συν συν. Μέχρι στιγμής, είμαι πραγματικά ακριβώς δανεισμού ιδέες από πριν. Και τώρα πάω να εισαγάγει ένα υποκατάστημα. 

Έτσι σκεφτείτε πίσω στο μηδέν, όπου είχαμε αυτά τα πιρούνια στο δρόμο, και την περασμένη εβδομάδα στο Γ Πάω να το πω αυτό, αν το i-οστό χαρακτήρα s είναι μεγαλύτερο από ή ίσο με πεζά ένα, and-- στο Ξυστό θα κάνατε στην κυριολεξία λένε και, αλλά σε C λέτε σύμβολο, ampersand-- και το i-οστό χαρακτήρα s είναι μικρότερη ή ίση με πεζά z, ας κάνουμε κάτι ενδιαφέρον. Ας πραγματικότητα εκτυπώσετε μια χαρακτήρα χωρίς αλλαγή γραμμής ότι είναι ο χαρακτήρας στη συμβολοσειρά, το i-οστό χαρακτήρα στη συμβολοσειρά. 

Αλλά ας πάμε μπροστά και να αφαιρέσουμε 32 από αυτό. Αλλιώς, αν ο χαρακτήρας στο εγχόρδων που ψάχνουμε δεν είναι μεταξύ λίγο ένα και λίγο z, προχωρήστε και απλά να εκτυπωθούν αμετάβλητη. Έτσι έχουμε εισαχθεί Αυτή η παρένθεση σημειογραφία για έγχορδα μας για να πάρει το i-ου χαρακτήρα στη συμβολοσειρά. 

Έχω προσθέσει κάποια υπό όρους λογικής, όπως Scratch στην εβδομάδα μία περασμένης εβδομάδας, όπου Είμαι απλά χρησιμοποιώντας τα θεμελιώδη μου κατανόηση του τι είναι συμβαίνει κάτω από το καπό. Είναι το i-οστό χαρακτήρα του s μεγαλύτερο ή ίσο προς ένα; Όπως, είναι 97, ή 98, ή 99, και ούτω καθεξής; 

Αλλά είναι επίσης μικρότερο ή ίσο με την αξία των πεζών z; Και αν ναι, τι σημαίνει αυτή η γραμμή; 14, αυτό είναι το είδος της φύτρο του συνόλου της ιδέας, κεφαλαιοποιήσει την επιστολή απλά αφαιρώντας 32 από αυτό, σε αυτή την περίπτωση, επειδή ξέρω, ανά ότι διάγραμμα, πώς οι αριθμοί μου εκπροσωπούνται. Ας πάμε μπροστά και να τρέξει αυτό, μετά την κατάρτιση κεφαλαιοποιήσει 0.c, και τρέχει να κεφαλαιοποιήσει 0. 

Ας πληκτρολογήσετε κάτι σαν Zamyla σε όλα τα πεζά εισάγετε. Και τώρα έχουμε Zamyla σε όλα τα κεφαλαία. Ας πληκτρολογήσετε Rob σε όλα τα πεζά. Ας προσπαθήσουμε Jason σε όλα τα πεζά. Και κρατάμε πάρει το αναγκαστική κεφαλαιοποίηση. Υπάρχει ένα μικρό bug που έχω είδος δεν είχε προβλέψει. Ανακοίνωση για το νέο μου προτροπή καταλήγουν στην ίδια γραμμή όπως τα ονόματά τους, η οποία αισθάνεται λίγο βρώμικο. 

Έτσι, Πάω να πάει εδώ, και στην πραγματικότητα, στο τέλος αυτού του προγράμματος εκτυπώσετε ένα χαρακτήρα νέας γραμμής. Αυτό είναι όλο. Με printf, δεν χρειάζεται να περάσει σε μεταβλητές ή ο κωδικός μορφή. Μπορείτε να κυριολεκτικά εκτυπώσετε κάτι σαν μια νέα γραμμή. 

Ας πάμε μπροστά και να κάνουν κεφαλαιοποιήσει 0 και πάλι, εκτελέστε ξανά αυτό, Zamyla. Και τώρα είναι λίγο πιο όμορφη. Τώρα, προτροπή μου είναι από μόνη νέα γραμμή του. Έτσι ώστε να είναι όλα ωραία και καλά. Έτσι, αυτό είναι ένα καλό παράδειγμα. Αλλά εγώ δεν κάνω καν κατ 'ανάγκην πρέπει να σκληρό κωδικό 32. Ξέρεις τι? Θα μπορούσα να say-- εγώ δεν κάνω ποτέ να θυμάστε ποια είναι η διαφορά. 

Αλλά ξέρω ότι αν έχω έχουν ένα πεζό γράμμα, Θα ουσιαστικά θέλουν να αφαιρούμε ό, τι η απόσταση είναι μεταξύ λίγο μια και τα μεγάλα Α, γιατί αν υποθέσουμε ότι όλα τα άλλα γράμματα είναι το ίδιο, ότι θα πρέπει να γίνει η δουλειά. Αλλά αντί να το κάνουμε αυτό, ξέρετε τι; Υπάρχει ένας άλλος τρόπος ακόμα. 

Αν αυτό είναι κεφαλαιοποιήσει 1.c-- αν ήμουν να θέσω σε ένα ξεχωριστό αρχείο. ας μην επωφεληθούμε 2.γ ως εξής. Πάω να καθαρίσει πραγματικά αυτό εδώ. Και αντί να χρειάζεται να γνωρίζουν ή ενδιαφέρονται για αυτά τα χαμηλά επίπεδα λεπτομέρειες εφαρμογής, είμαι αντί ακριβώς πρόκειται να εκτυπώσετε ένα χαρακτήρα, απόσπασμα εισαγωγικά, τοις εκατό C, και τότε καλέστε μια άλλη λειτουργία που υπάρχει ότι παίρνει ένα επιχείρημα, η οποία είναι ένας χαρακτήρας, όπως αυτό. 

Αποδεικνύεται σε C, υπάρχει μια άλλη κλήση συνάρτησης με ανώτερο, το οποίο όπως το όνομά του προτείνει παίρνει ένα χαρακτήρα και αυτό με κάνει να κεφαλαία της ισοδύναμο, και στη συνέχεια επιστρέφει έτσι ώστε printf να το συνδέσετε εκεί. Και έτσι για να γίνει αυτό, όμως, πρέπει να εισαγάγει ένα άλλο αρχείο. Αποδεικνύεται ότι υπάρχει ένα άλλο αρχείο ότι θα γνωρίζουν μόνο από την τάξη, ή ένα βιβλίο, ή ένα online αναφοράς, που ονομάζεται type.h. C 

Έτσι, αν μπορώ να προσθέσω ότι μέχρι μεταξύ κεφαλίδα μου αρχείων, και τώρα μεταγλωττίσετε ξανά το πρόγραμμα αυτό, capitalize2, ./capitalize2 Enter. Ας πληκτρολογήσετε Zamyla σε όλα πεζά, εξακολουθεί να λειτουργεί με τον ίδιο. Αλλά ξέρετε τι; Αποδεικνύεται ότι σε ανώτερο έχει κάποια άλλη λειτουργικότητα. 

Και επιτρέψτε μου να εισαγάγει αυτό εντολή εδώ, είδος αδέξια το όνομά του, αλλά ο άνθρωπος για χειροκίνητη. Αποδεικνύεται ότι οι περισσότεροι υπολογιστές Linux, όπως είμαστε με here-- λειτουργικό Linux system-- έχουν μια εντολή που ονομάζεται άνθρωπος, που λέει, hey, υπολογιστή, να μου δώσει το εγχειρίδιο του υπολογιστή. Τι θέλεις να κοιτάζω προς τα πάνω σε αυτό το εγχειρίδιο; 

Θέλω να κοιτάζω προς τα πάνω τη λειτουργία καλείται να ανώτερο, Enter. Και είναι μια μικρή αινιγματική να διαβάσει πολλές φορές. Αλλά παρατηρήσετε είμαστε στην εγχειρίδιο του Linux προγραμματιστή. Και είναι όλο το κείμενο. Και παρατηρήσετε ότι υπάρχει η όνομα της συνάρτησης μέχρι εδώ. Αποδεικνύεται ότι έχει μια ξαδέλφη που ονομάζεται να μειώσουν, το οποίο κάνει το αντίθετο. Και ειδοποίηση δυνάμει σύνοψη, για να χρησιμοποιήσετε αυτό το λειτουργούν την σελίδα man, να το πω έτσι, μου λέει ότι εγώ πρέπει να περιλαμβάνουν γ type.h. Και ήξερα ότι από την πρακτική. 

Εδώ, είναι να μου δείξει τα δύο πρωτότυπα για τη λειτουργία, έτσι ώστε αν ποτέ θέλετε να χρησιμοποιήσετε αυτό το Ξέρω τι παίρνουν ως είσοδο, και τι επιστρέψει ως έξοδο. Και στη συνέχεια, αν διάβασα η περιγραφή, βλέπω με περισσότερες λεπτομέρειες το τι κάνει η λειτουργία. Αλλά το πιο σημαντικό, αν Κοιτάζω κάτω τιμή επιστροφής, λέει η τιμή που επιστρέφεται είναι ότι του μετατραπέντος γράμμα, ή C, η αρχική είσοδος, αν η μετατροπή δεν ήταν δυνατή. 

Με άλλα λόγια, στα ανώτατα θα προσπαθήσει να μετατρέψετε ένα γράμμα σε κεφαλαία. Και αν ναι, πρόκειται να το επιστρέψει. Αλλά αν αυτό δεν μπορεί για κάποιο reason-- ίσως είναι ήδη άνω περίπτωση, ίσως είναι ένα θαυμαστικό ή κάποιο άλλο punctuation-- είναι ακριβώς πρόκειται να επιστρέφει το πρωτότυπο C, πράγμα που σημαίνει ότι μπορώ να κάνω τον κωδικό μου καλύτερα σχεδιασμένη ως εξής. 

Δεν χρειάζεται όλα Αυτές οι γραμμές καταριέται του κώδικα. Όλες οι γραμμές που έχω ακριβώς τονίζεται μπορεί να καταρρεύσει σε ένα μόνο απλό γραμμή, η οποία είναι this-- τοις εκατό printf c για άνω βραχίονα S i. Και αυτό θα ήταν μια παράδειγμα του καλύτερου σχεδιασμού. 

Γιατί να εφαρμόσουν σε 7 ή 8 γραμμές του κώδικα, όποια και αν ήταν εγώ απλά διαγράφονται, όταν αντί να καταρρεύσει όλα αυτή τη λογική και τη λήψη αποφάσεων σε μια ενιαία γραμμή, 13 τώρα, ότι βασίζεται σε μια βιβλιοθήκη function-- μια λειτουργία που έρχεται με C, αλλά ότι κάνει ακριβώς αυτό που θέλετε να κάνετε. Και, ειλικρινά, ακόμα και αν δεν έρχονται με C, θα μπορούσε να την εφαρμόσει τον εαυτό σας, όπως έχουμε δει, με πάρει αρνητική int και να πάρει θετικό int την περασμένη εβδομάδα, καθώς και. 

Αυτός ο κωδικός τώρα είναι πολύ πιο ευανάγνωστο. Και, πράγματι, αν μετακινηθείτε προς τα επάνω, δείτε πόσο πιο συμπαγής Αυτή η έκδοση του προγράμματος μου. Είναι λίγο βαριά τώρα, με όλα αυτά περιλαμβάνονται. Αλλά αυτό είναι εντάξει, επειδή τώρα στέκομαι στους ώμους των προγραμματιστών πριν από εμένα. Και όποιος ήταν που εφαρμοστούν στην ανώτερη πραγματικά μου έκανε μια χάρη, όπως και όποιος εφαρμοστεί Stirling πραγματικά μου έκανε μια χάρη πριν από λίγο καιρό. Και έτσι τώρα έχουμε μια καλύτερο πρόγραμμα σχεδίασης ότι εφαρμόζει την ίδια ακριβώς λογική. 

Μιλώντας του Stirling, ας Θέλω να προχωρήσει και να το κάνουμε αυτό. Επιτρέψτε μου να πάει μπροστά και να σώσει Αυτό το αρχείο όπως stirling.c. Και αποδεικνύεται, μπορούμε να ξεκολλήσετε ένα άλλο στρώμα αρκετά απλά τώρα. Πάω να προχωρήσει και μαστίγιο μέχρι ένα άλλο πρόγραμμα στην κύρια εδώ ότι απλά ξανά υλοποιεί μήκος συμβολοσειράς ως εξής. Έτσι, εδώ είναι μια γραμμή κώδικα που Μου παίρνει ένα string από το χρήστη. Εμείς συνεχίσετε να χρησιμοποιείτε αυτό ξανά και ξανά. Επιτρέψτε μου να δώσω στον εαυτό μου μια μεταβλητή που ονομάζεται n του τύπου int που αποθηκεύει έναν αριθμό. 

Και επιτρέψτε μου να πάει μπροστά και να κάνει την εξής λογική. Ενώ η n-ου χαρακτήρα s κάνει δεν είναι ίσες backslash 0, προχωρήστε και αυξήσετε n. Και στη συνέχεια να εκτυπώσετε τοις εκατό printf i n. Ισχυρίζομαι ότι αυτό το πρόγραμμα εδώ, χωρίς να θέτει το μήκος των χορδών, υπολογίζει το μήκος μιας συμβολοσειράς. 

Και η μαγεία είναι εξ ολοκλήρου έγκλειστα σε γραμμή 8 εδώ με αυτό που μοιάζει με νέα σύνταξη, αυτό το backslash 0 σε μονά εισαγωγικά. Αλλά γιατί είναι αυτό; Λοιπόν, σκεφτείτε τι ήταν συμβαίνει όλο αυτό το διάστημα. 

Και ως μέρος πριν ξεχάσω, να συνειδητοποιήσουν επίσης, ότι εκτός από τις σελίδες man ότι έρχονται με ένα τυπικό σύστημα Linux, όπως CS50 IDE, συνειδητοποιήσουμε ότι εμείς, η προσωπικό μαθήματος, έχουν επίσης έκανε μια έκδοση ιστοσελίδα αυτής της ίδιας ιδέας που ονομάζεται reference.cs50.net, η οποία έχει όλες αυτές τις ίδιες σελίδες άνθρωπος, όλα του ιδίου τεκμηρίωση, καθώς και ένα μικρό κουτί στο πάνω μέρος που επιτρέπει μπορείτε να μετατρέψετε όλα τα δίκαια απόκρυφες γλώσσα σε λιγότερο άνετα κατάσταση, όπου, το διδακτικό προσωπικό, έχουν περάσει και προσπάθησε να απλοποιήσει ορισμένα από τη γλώσσα για να κρατήσει τα πράγματα επικεντρώθηκε στις ιδέες, και όχι μερικές από τις τεχνικές λεπτομέρειες. Έτσι, να έχετε κατά νου, reference.cs50.net ως μια άλλη πηγή, καθώς και. 

Αλλά γιατί κάνει τη δουλειά μήκος συμβολοσειράς σε ο τρόπος που πρότεινε πριν από λίγο; Εδώ είναι και πάλι το όνομα Zamyla του. Και εδώ είναι το όνομα Zamyla του εγκλωβιστούμε σε, όπως εγώ συνεχίσω να το κάνω, να ζωγραφίσει μια εικόνα του να είναι, Πραγματικά, μόνο μια ακολουθία χαρακτήρων. Αλλά Zamyla δεν υπάρχει σε απομόνωση σε ένα πρόγραμμα. 

Όταν γράφετε και να εκτελέσετε ένα πρόγραμμα, χρησιμοποιείτε το Mac σας ή τον υπολογιστή σας η μνήμη, ή μνήμη RAM να το πω έτσι. Και μπορείτε να σκεφτείτε υπολογιστή σας, όπως έχει πολλά gigabytes μνήμη αυτές τις ημέρες. Και μια συναυλία μέσα δισεκατομμύρια, έτσι δισεκατομμύρια bytes. 

Αλλά ας τα πίσω στο χρόνο. Και ας υποθέσουμε ότι χρησιμοποιείτε ένα πραγματικά παλιό υπολογιστή που έχει μόνο 32 bytes της μνήμης. Θα μπορούσα, στην οθόνη του υπολογιστή μου, απλά σχεδιάσετε αυτό έξω ως εξής. 

Θα μπορούσα απλά να πω ότι μου υπολογιστής έχει όλη αυτή τη μνήμη. Και αυτό είναι σαν ένα ραβδί μνήμης, εάν θα θυμάστε την εικόνα μας από την τελευταία φορά. Και αν εγώ απλά χωρίζουν αυτό αρκετές φορές, Ισχυρίζομαι ότι έχω 32 bytes της μνήμης στην οθόνη. 

Τώρα, στην πραγματικότητα, δεν μπορώ παρά να αντλήσει μέχρι στιγμής σε αυτή την οθόνη εδώ. Έτσι, Πάω να πάει μπροστά, και μόνο κατά σύμβαση, επιστήσει την μνήμη του υπολογιστή μου ως πλέγμα, όχι μόνο ως μία ευθεία γραμμή. Συγκεκριμένα, έχω ισχυρίζονται τώρα ότι Αυτό το πλέγμα, αυτό 8 από 4 πλέγμα, ακριβώς αντιπροσωπεύει όλα τα 32 bytes της διαθέσιμης μνήμης στο Mac μου, ή είναι διαθέσιμα στον υπολογιστή μου. Και από όπου και αν το τύλιγμα επί σε δύο γραμμές, μόλις επειδή ταιριάζει περισσότερο στην οθόνη. Αλλά αυτό είναι το πρώτο byte. Αυτό είναι το δεύτερο byte. Αυτή είναι η τρίτη byte. 

Και αυτή είναι η 32η byte. Ή, αν σκεφτούμε σαν έναν υπολογιστή επιστήμονας, αυτό είναι το byte 0, 1, 2, 3, 31. Έτσι έχετε 0-31, αν θα αρχίσουμε να μετράμε σε 0. 

Έτσι, αν χρησιμοποιήσουμε ένα πρόγραμμα ότι οι κλήσεις πάρει string, και παίρνουμε μια σειρά από το ανθρώπινο όπως έκανα ονομάζεται Zamyla, Ζ-Α-Μ-Υ-Ι-Α, Πώς στον κόσμο κάνει η Κρατήστε τον υπολογιστή διαδρομή της οποίας byte, το οποίο κομμάτι της μνήμης, ανήκει στην οποία χορδών; Με άλλα λόγια, αν προχωρούμε πληκτρολογήστε ένα άλλο όνομα στον υπολογιστή, όπως αυτό Andi, καλώντας πάρετε κορδόνι για δεύτερη φορά, Α-Ν-Δ-Ι πρέπει να καταλήγουν στην μνήμη του υπολογιστή, καθώς και. Αλλά πως? 

Λοιπόν, αποδεικνύεται ότι κάτω από το κουκούλα, τι C κάνει κατά την αποθήκευση χορδές ότι η ανθρώπινη τύποι του, ή ότι προέρχονται από κάποια άλλη πηγή, είναι σκιαγραφεί το τέλος τους με μια ειδική character-- backslash 0, η οποία είναι απλώς ένα ιδιαίτερο τρόπο λέγοντας 80 bits σε μια σειρά. 

Έτσι A-- αυτή είναι η ανάκληση αριθμό 97. Έτσι, μερικές μοτίβο από 8 bits αντιπροσωπεύει δεκαδικό αριθμό 97. Αυτό το backslash 0 είναι κυριολεκτικά ο αριθμός 0, γνωστός και ως nul, Ν-U-L, σε αντίθεση με προηγούμενες, Ν-U-L-L, η οποία μιλήσαμε για. Αλλά για τώρα, απλά να ξέρετε ότι αυτή η backslash 0 είναι μόλις 80 bits σε μια σειρά. 

Και είναι ακριβώς αυτή η γραμμή στο άμμο που λέει τίποτα προς τα αριστερά ανήκει σε μία κλωστή, ή έναν τύπο δεδομένων. Και τίποτα προς τα δεξιά ανήκει σε κάτι άλλο. Όνομα Andi, εν τω μεταξύ, που μόνο οπτικά συμβαίνει για να τυλίξει στο άλλο γραμμή, αλλά αυτό είναι μόνο μια αισθητική λεπτομέρεια, Ομοίως τερματίζεται Nul. 

Είναι μια σειρά από χαρακτήρες ενός Α-Ν-D-I, συν ένα πέμπτο μυστικό χαρακτήρα, όλα 0 bits, που οριοθετεί μόνο το τέλος του ονόματος Andi, καθώς και. Και αν καλούμε να πάρετε κορδόνι για τρίτη φορά στον υπολογιστή για να πάρει ένα string, όπως Μαρία, Μ-Α-Ρ-Ι-Α, ομοίως είναι της Μαρίας Το όνομά Nul τερματίστηκε με backslash 0. 

Αυτό είναι θεμελιωδώς διαφορετική από το πώς ένας υπολογιστής θα συνήθως αποθηκεύει έναν ακέραιο, ή float, ή άλλες τύπους δεδομένων ακόμα, γιατί ανάκληση, ένας ακέραιος είναι συνήθως 32 bits, ή 4 bytes, ή ίσως ακόμη και 64 bits, ή οκτώ bytes. Αλλά πολλοί πρωτόγονων σε έναν υπολογιστή σε μια γλώσσα προγραμματισμού έχουν ένα σταθερό αριθμό bytes κάτω από το hood-- ίσως 1, ίσως 2, ίσως και 4, ίσως και 8. 

Αλλά χορδές, από το σχεδιασμό, έχουν δυναμική αριθμό χαρακτήρων. Δεν ξέρεις εκ των προτέρων, έως ότου τα ανθρώπινα είδη σε Ζ-Α-Μ-Υ-Ε-Α, ή Μ-Α-Κ-Ι-Α, ή Α-Ν-D-I. Δεν ξέρετε πόσες φορές ο χρήστης πρόκειται να χτυπήσει το πληκτρολόγιο. Ως εκ τούτου, δεν ξέρεις πώς πολλοί χαρακτήρες εκ των προτέρων θα πάμε να χρειάζονται. 

Και έτσι C ακριβώς το είδος του αφήνει σαν ένα μυστικό ψίχουλο κάτω από την κουκούλα στο τέλος της σειράς. Μετά από αποθήκευση Ζ-Α-Μ-Y-L-Α στη μνήμη, Επίσης, θέτει ακριβώς το ισοδύναμο μιας περιόδου. Στο τέλος της ποινής, το θέτει 80 bits, έτσι ώστε να θυμηθείτε πού Zamyla αρχίζει και τελειώνει. 

Έτσι ποια είναι η σύνδεση, Στη συνέχεια, σε αυτό το πρόγραμμα; Αυτό το πρόγραμμα εδώ, Stirling, είναι απλά ένας μηχανισμός για να πάρει ένα string από το χρήστη, γραμμή 6. Γραμμή 7, δηλώνω μια μεταβλητή καλείται ν και να το θέσει ίση με 0. 

Και, στη συνέχεια, στη γραμμή 8, απλά ζήτησε από την ερώτηση, ενώ το n-ου χαρακτήρα δεν Δεν ίσο όλα 0 bits-- Με άλλα λόγια, δεν ίσης αυτό το ειδικό χαρακτήρα, backslash 0, η οποία Ήταν απλά ότι η ειδική Nul character-- να προχωρήσει και μόνο αυξήσετε n. 

Και συνεχίζω να, και να κρατήσει να γίνει αυτό, και να το κάνουμε. Και έτσι ακόμα κι αν το το παρελθόν έχουμε χρησιμοποιήσει i, είναι απολύτως εντάξει σημασιολογικά για χρήση n, αν είστε ακριβώς που προσπαθεί να μετράνε αυτή τη φορά σκόπιμα, και απλά θέλετε να το ονομάσετε n. Έτσι, αυτό κρατά μόνο την ερώτηση, είναι το n-ου χαρακτήρα s όλα 0s; Αν όχι, δείτε την επόμενη εμφάνιση, κοιτάξουμε το επόμενο, να δούμε στο επόμενο, κοιτάξουμε το επόμενο. 

Αλλά μόλις δείτε backslash 0, Αυτό loop-- γραμμή 9 έως 11-- σταματά. Μπορείτε να σπάσει έξω από το βρόχο, ενώ, αφήνοντας μέσα αυτής της μεταβλητής n μια συνολική καταμέτρηση όλων των χαρακτήρες στη συμβολοσειρά είδατε, με αυτόν τον τρόπο θα εκτύπωση. Έτσι, ας προσπαθήσουμε αυτό. 

Επιτρέψτε μου να προχωρήσει και χωρίς χρησιμοποιώντας τη λειτουργία Stirling, αλλά μόνο με τα δικά μου σταθεροποιητικών έκδοση εδώ ονομάζεται Stirling, επιτρέψτε μου να πάει μπροστά και τρέχει Stirling, πληκτρολογήστε σε κάτι όπως Zamyla, το οποίο γνωρίζω εκ των προτέρων είναι έξι χαρακτήρες. Ας δούμε αν αυτό δουλεύει. Πράγματι, είναι έξι. Ας προσπαθήσουμε με τον Rob, τρεις χαρακτήρες, τρεις χαρακτήρες, καθώς, και ούτω καθεξής. Έτσι, αυτό είναι το μόνο που πρόκειται για κάτω από το καπό. Και παρατηρήστε τις συνδέσεις, Στη συνέχεια, με την πρώτη εβδομάδα της κατηγορίας, όπου μιλήσαμε για κάτι σαν αφαίρεση, το οποίο είναι ακριβώς αυτή η διαστρωμάτωση των ιδεών, ή πολυπλοκότητα, πάνω από τις βασικές αρχές. Εδώ, είμαστε είδος που αναζητούν κάτω από την κουκούλα του Stirling, να το πω έτσι, για να καταλάβω, πώς θα πρέπει να εφαρμοστεί; 

Και θα μπορούσαμε να χορηγήσει εκ νέου τον εαυτό μας. Αλλά είμαστε ποτέ ξανά πρόκειται για την εκ νέου εφαρμογή Stirling. Είμαστε ακριβώς πρόκειται να χρησιμοποιήστε Stirling, προκειμένου για να πάρει πραγματικά κάποια μήκους χορδές. 

Αλλά δεν υπάρχει καμία μαγική κάτω από το καπό. Εάν γνωρίζετε ότι κάτω η κουκούλα, ένα string είναι απλά μια ακολουθία χαρακτήρων. Και αυτό ακολουθία χαρακτήρων όλα μπορούν να αντιμετωπιστούν αριθμητικά με στήριγμα 0, βραχίονα 1, βραχίονα 2, και γνωρίζουν ότι στο τέλος μιας σειράς είναι ένα ειδικού χαρακτήρα, μπορείτε να υπολογίσετε πώς να κάνει σχεδόν οτιδήποτε σε μια πρόγραμμα, διότι όλα βράζει κάτω σε διαβάζει και γράφει μνήμης. Δηλαδή, αλλάζοντας και αναζητούν στην μνήμη, ή μετακίνηση πράγματα γύρω στη μνήμη, τα πράγματα εκτύπωση στην οθόνη, και ούτω καθεξής. 

Έτσι ας χρησιμοποιήσουμε τώρα αυτό πρωτόγνωρη κατανόηση του τι πραγματικά χορδές είναι κάτω από την κουκούλα, και φλούδα πίσω ένα άλλο στρώμα ότι μέχρι τώρα έχουμε αγνοώντας εντελώς. Ειδικότερα, οποιαδήποτε στιγμή έχουμε εφαρμόσει ένα πρόγραμμα, είχαμε αυτή τη γραμμή κώδικα κοντά στην κορυφή δηλώνοντας κύριο. Και έχουμε διευκρινίζεται int main άκυρη. 

Και αυτό κενό μέσα στις παρενθέσεις έχει πει όλο αυτό το διάστημα ότι η κύρια η ίδια δεν λαμβάνει κανένα επιχείρημα. Κάθε εισόδου ότι ο κύριος είναι πρόκειται να πάρει από τον χρήστη πρέπει να προέρχονται από κάποια άλλη μηχανισμού, όπως get int, ή να πάρετε float, ή να πάρετε string, ή κάποια άλλη λειτουργία. Αλλά αποδεικνύεται ότι όταν γράφετε ένα πρόγραμμα, μπορείτε πραγματικά να καθορίσετε ότι το πρόγραμμα αυτό θα λαμβάνουν εισροές από το ανθρώπινο στην ίδια την γραμμή εντολών. 

Με άλλα λόγια, ακόμα κι αν μέχρι στιγμής έχει τρέξει μόλις ./hello γεια ή παρόμοια προγράμματα, το σύνολο των άλλα προγράμματα που έχουμε χρησιμοποιήσει, ότι εμείς οι ίδιοι δεν γράφουν, έχουν ήδη λάβει, όπως φαίνεται, γραμμή εντολών arguments-- τα πράγματα όπως κάνουν. Λέτε κάτι σαν μάρκα, και στη συνέχεια ένα δεύτερο λέξη. Ή κλαγγή, λέτε κλαγγή, και στη συνέχεια, μια δεύτερη λέξη, το όνομα ενός αρχείου. 

Ή ακόμα και RM ή CP, όπως μπορείτε να έχουν δει ή χρησιμοποιείται ήδη για να αφαιρέσετε ή να αντιγράψετε αρχεία. Όλα αυτά λαμβάνουν λεγόμενη γραμμή εντολών arguments-- πρόσθετες λέξεις στο τερματικό εντολών. Αλλά μέχρι τώρα, οι ίδιοι δεν είχαν Αυτό το πολυτελές τη λήψη εισόδου από το χρήστη όταν αυτός ή αυτή τρέχει πραγματικά το ίδιο το πρόγραμμα στη γραμμή εντολών. 

Αλλά μπορούμε να το κάνουμε αυτό με την εκ νέου κήρυξη κύρια κινείται προς τα εμπρός, όχι ως έχει άκυρη σε παρένθεση, αλλά αυτά τα δύο επιχειρήματα instead-- το πρώτο ακέραιο, και η δεύτερη κάτι νέο, κάτι που θα πάμε να καλέσετε μια σειρά, κάτι παρόμοιο σε πνεύμα σε ό, τι είδαμε στο Scratch ως μια λίστα, αλλά μια σειρά από χορδές, όπως θα δούμε σύντομα. Αλλά ας δούμε αυτό με Σαν παράδειγμα, πριν διακρίνουμε τι ακριβώς σημαίνει αυτό. 

Έτσι, αν πάω σε CS50 IDE εδώ, έχω πάει μπροστά και δήλωσε σε ένα αρχείο που ονομάζεται argv0.c το ακόλουθο πρότυπο. Και παρατηρήστε το μόνο πράγμα αυτό είναι διαφορετικό μέχρι στιγμής είναι ότι έχω αλλάξει κενό για να int argc κορδόνι argv ανοιχτό βραχίονα, κοντά υποστήριγμα. Και παρατηρήσετε για τώρα, δεν υπάρχει τίποτα μέσα από αυτές τις παρενθέσεις. 

Δεν υπάρχει κανένας αριθμός. Και δεν υπάρχει i, ή n, ή οποιοδήποτε άλλο έγγραφο. Είμαι απλά χρησιμοποιώντας το αγκύλες για τώρα, για λόγους που θα έρθουν Επιστροφή στην ακριβώς σε μια στιγμή. 

Και τώρα τι Πάω να κάνουμε είναι αυτό. Αν argc ισούται ισούται 2-- και υπενθυμίζουν ότι ισούται με ίσων είναι ο φορέας της ισότητας συγκρίνοντας το αριστερό και το δεξί για την ισότητα. Δεν είναι η εκχώρηση χειριστή, η οποία είναι το ενιαίο σύμβολο της ισότητας, η οποία σημαίνει αντίγραφο από τα δεξιά προς τα αριστερά κάποια αξία. 

Αν argc ισούται ισούται με 2, θέλω να ας πούμε, printf, γεια σου, ποσοστά, νέα γραμμή, και, στη συνέχεια, συνδέστε in-- και εδώ είναι το νέο trick-- βραχίονα argv 1, για λόγους ότι θα επανέλθουμε σε λίγο. Άλλο αν argc δεν ίσες 2, ξέρετε τι; Ας πάμε μπροστά και, ως συνήθως, εκτύπωση έξω γεια κόσμο χωρίς αντικατάσταση. 

Έτσι φαίνεται ότι αν argc, τα οποία σημαίνει καταμέτρηση επιχείρημα, ισούται με 2, Πάω να εκτυπώσετε γεια κάτι ή άλλο. Διαφορετικά, από προεπιλογή, είμαι πρόκειται να εκτυπώσετε hello world. Λοιπόν, τι σημαίνει αυτό; 

Λοιπόν, επιτρέψτε μου να πάω μπροστά και να σώσει αυτό το αρχείο, και στη συνέχεια να κάνουν argv0, και στη συνέχεια ./argv0, Enter. Και λέει hello world. Τώρα, γιατί είναι αυτό; 

Λοιπόν, αποδεικνύεται ανά πάσα στιγμή να εκτελέσετε ένα πρόγραμμα στη γραμμή εντολών, σας συμπληρώνοντας αυτό που θα γενικά καλέσετε έναν φορέα επιχείρημα. Με άλλα λόγια, αυτόματα ο υπολογιστή, το λειτουργικό σύστημα, πρόκειται να παραδώσει στο πρόγραμμά σας η ίδια μια λίστα με όλες τις λέξεις ότι η ανθρώπινη πληκτρολογήσει στο η προτροπή, σε περίπτωση που ο προγραμματιστής θέλετε να κάνετε κάτι με αυτές τις πληροφορίες. Και σε αυτή την περίπτωση, η μόνη λέξη Έχω πληκτρολογήσει στη γραμμή είναι ./argv0. 

Και έτσι ο αριθμός των επιχειρημάτων που είναι που έχουν περάσει στο πρόγραμμά μου είναι μόνο ένα. Με άλλα λόγια, το επιχείρημα μετράνε, αλλιώς γνωστή ως argc εδώ ως ακέραιος, είναι μόνο μία. Ένα, βέβαια, δεν είναι ίσο με δύο. Και έτσι αυτό είναι που εκτυπώνει, γεια κόσμο. 

Αλλά επιτρέψτε μου να εκμεταλλευτώ αυτή κάπου. Επιτρέψτε μου να πω, argv0. Και τότε πώς για τη Μαρία; Και στη συνέχεια πατήστε Enter. 

Και παρατηρήστε τι συμβαίνει μαγικά εδώ. Τώρα, αντί του κόσμου Γεια σας, έχω άλλαξε τη συμπεριφορά αυτού του προγράμματος με τη λήψη της εισόδου όχι από get κορδόνι ή κάποια άλλη λειτουργία, αλλά από την, κατά τα φαινόμενα, η εντολή μου το ίδιο, αυτό που αρχικά πληκτρολογήσει. Και μπορώ να παίξω αυτό το παιχνίδι και πάλι από αλλαγή να Στέλιο, για παράδειγμα. 

Και τώρα βλέπω ένα άλλο όνομα ακόμα. Και εδώ, θα μπορούσα να πω Andi. Και μπορώ να πω Zamyla. Και μπορούμε να παίξουμε αυτό το παιχνίδι όλη την ημέρα, απλά συνδέοντας διαφορετικές τιμές, εφ 'όσον θα παρέχουν ακριβώς δύο λέξεις στη γραμμή, έτσι ώστε argc, το επιχείρημά μου μετράνε, είναι 2. 

Βλέπω ότι το όνομα συνδεδεμένο σε printf, ανά αυτή την κατάσταση εδώ; Έτσι, φαίνεται να έχουμε σήμερα η εκφραστική ικανότητα από τη λήψη εισόδου από άλλο μηχανισμό, από τη λεγόμενη γραμμή εντολών, αντί να χρειάζεται να περιμένετε έως ότου ο χρήστης τρέχει το πρόγραμμα, και στη συνέχεια να τον ή την προτρέψει χρησιμοποιώντας κάτι σαν κλωστή get. 

Λοιπόν, τι είναι αυτό; Argc, πάλι, είναι απλά ένας ακέραιος, ο αριθμός των words-- arguments-- ότι ο χρήστης που παρέχονται στο προτροπή, στο παράθυρο τερματικού, συμπεριλαμβανομένου του ονόματος του προγράμματος. Έτσι ./argv0 μας είναι, ουσιαστικά, το όνομα του προγράμματος, ή πώς θα τρέξει το πρόγραμμα. 

Αυτό μετράει ως μια λέξη. Έτσι argc θα είναι 1. Αλλά όταν γράφω Στέλιος, ή Andi, ή Zamyla, ή Μαρία, αυτό σημαίνει ότι ο αριθμός επιχείρημα είναι δύο. Και έτσι τώρα υπάρχουν δύο λέξεις που ψηφίστηκε το. 

Και ειδοποίηση, μπορούμε να συνεχίσουμε αυτή τη λογική. Αν μπορώ πραγματικά να πω κάτι σαν Zamyla Chan, ένα πλήρες όνομα, έτσι περνώντας τρία επιχειρήματα συνολικά, Τώρα λέει η προεπιλογή και πάλι, επειδή, φυσικά, 3 δεν ισούται 2. 

Και έτσι με αυτό τον τρόπο, έχω πρόσβαση μέσω argv αυτό το νέο επιχείρημα ότι θα μπορούσαμε τεχνικά καλέστε οτιδήποτε θέλουμε. Αλλά κατά συνθήκη, είναι argv και argc, αντίστοιχα. Argv, τον φορέα επιχείρημα, είναι το είδος των συνώνυμο για τον προγραμματισμό χαρακτηριστικό στην C ονομάζεται μια σειρά. 

Ένας πίνακας είναι μια λίστα με παρόμοιες τιμές πίσω, προς τα πίσω, προς τα πίσω, προς τα πίσω. Με άλλα λόγια, αν κάποιος είναι ακριβώς εδώ στο RAM, η επόμενη θα είναι δίπλα σε αυτό, και δίπλα σε αυτό. Δεν είναι σε όλη τη χώρα. Και αυτό το τελευταίο σενάριο, όπου τα πράγματα είναι σε όλη τη χώρα στη μνήμη, μπορεί στην πραγματικότητα να είναι ένα ισχυρό χαρακτηριστικό. Αλλά θα επανέλθουμε σε αυτό όταν θα μιλήσουμε για το φανταχτερό δομές δεδομένων. Προς το παρόν, ένας πίνακας είναι μόνο ένα κομμάτι της συνεχούς μνήμης, κάθε ένα από τα στοιχεία της οποίας είναι πίσω, προς τα πίσω, προς τα πίσω, προς τα πίσω, και γενικά του ίδιου τύπου. 

Έτσι, αν το σκεφτείτε, από ένα Πριν στιγμή, αυτό είναι ένα string; Λοιπόν, ένα string, όπως Zamyla, Ζ-Α-Μ-Y-L-Α, είναι, από τεχνική άποψη, απλά ένας πίνακας. Είναι μια σειρά από χαρακτήρες. 

Και έτσι αν θέλουμε πραγματικά να σχεδιάσετε αυτό, όπως εγώ έκανε νωρίτερα, ως κομμάτι της μνήμης, αποδεικνύεται ότι κάθε μία από αυτές χαρακτήρες καταλαμβάνει ένα byte. Και έπειτα υπάρχει το εν λόγω ειδικό φρουρού χαρακτήρα, το backslash 0, ή και οι οκτώ 0 bits, ότι οριοθετεί το τέλος αυτής της σειράς. Έτσι, ένα κορδόνι, αποδεικνύεται έξω, αναφέρω εισαγωγικά string, είναι απλά μια σειρά από chara-- char είναι ένα πραγματικό τύπο δεδομένων. 

Και τώρα argv, meanwhile-- ας πάμε πίσω στο πρόγραμμα. Argv, ακόμα κι αν βλέπουμε τη λέξη συμβολοσειρά εδώ, δεν είναι η ίδια ένα string. Argv, τον φορέα επιχείρημα, είναι μια σειρά από χορδές. 

Έτσι ακριβώς όπως μπορείτε να έχετε μια σειρά από χαρακτήρες, μπορείτε να έχετε υψηλότερο επίπεδο, μια σειρά από strings-- έτσι, για παράδειγμα, όταν πληκτρολογήσει μια στιγμή πριν ./argv0 argv0, το διάστημα Ζ-Α-Μ-Y-L-Α, Ι ισχυρίστηκε ότι argv είχε δύο χορδές σε it-- ./argv0, και Ζ-Α-Μ-Y-L-A. Σε Με άλλα λόγια, argc ήταν 2. Γιατί αυτό? 

Λοιπόν, αποτελεσματικά, τι συμβαίνει on είναι ότι κάθε μία από αυτές χορδές είναι, φυσικά, μια σειρά από χαρακτήρες όπως και πριν, καθένας εκ των οποίων οι χαρακτήρες καταλαμβάνει ένα byte. Και μην συγχέουμε την πραγματική 0 στο όνομα του προγράμματος με το 0, πράγμα που σημαίνει ότι όλα τα 80 bits. Και Zamyla, εν τω μεταξύ, εξακολουθεί να είναι επίσης μια σειρά από χαρακτήρες. 

Έτσι, στο τέλος της ημέρας, πραγματικά μοιάζει με αυτό κάτω από την κουκούλα. Αλλά argv, από τη φύση του τρόπου με τον κύριο έργα, μου επιτρέπει να τυλίξετε όλα αυτά επάνω σε, αν θέλετε, ένα μεγαλύτερο φάσμα ότι, αν έχουμε λίγο πάνω από την απλοποίηση ό, τι η εικόνα μοιάζει και δεν αρκετά να επιστήσει την κλίμακα μέχρι εκεί, αυτή η συστοιχία είναι μόνο από το μέγεθος 2, η πρώτη στοιχείο του οποίου περιέχει μια συμβολοσειρά, Το δεύτερο στοιχείο της το οποίο περιέχει μια σειρά. Και, με τη σειρά του, αν είδος μεγέθυνση σε κάθε από αυτές τις χορδές, τι δείτε κάτω από την κουκούλα είναι ότι κάθε string είναι μόνο μια σειρά από χαρακτήρες. 

Τώρα, ακριβώς όπως με χορδές, ήμασταν σε θέση να αποκτήσουν πρόσβαση για το i-οστό χαρακτήρα της συμβολοσειράς χρησιμοποιώντας το τετράγωνο συμβολισμός βραχίονα. Ομοίως, με συστοιχίες σε γενικές γραμμές, μπορούμε να κάνουμε χρησιμοποιήστε πλατεία συμβολισμός βραχίονα για να πάρει σε οποιοδήποτε αριθμό των χορδών σε μια σειρά; Για παράδειγμα, επιτρέψτε μου να προχωρήσει και να το κάνουμε αυτό. 

Επιτρέψτε μου να προχωρήσει και να δημιουργήσει argv1.c, η οποία είναι λίγο διαφορετική αυτή τη φορά. Αντί για τον έλεγχο για argc2, Πάω να αντί να το κάνετε αυτό. Για int παίρνω 0, I είναι λιγότερο από argc, εγώ συν συν, και στη συνέχεια να εκτυπώσετε στο εσωτερικό αυτού, τοις εκατό s, νέα γραμμή, και στη συνέχεια, argv βραχίονα i. 

Έτσι με άλλα λόγια, δεν είμαι ασχολούνται με μεμονωμένους χαρακτήρες αυτή τη στιγμή. Argv, όπως υπονοείται από αυτές κενό τετράγωνο τιράντες στα δεξιά του ονόματος argv, σημαίνει argv είναι μια σειρά από χορδές. Και argc είναι απλώς μια int. 

Αυτή η γραμμή εδώ, 6, είναι λέγοντας σύνολο i ισούται με 0. Μετρήστε σε όλη τη διαδρομή μέχρι το, αλλά μη συμπεριλαμβανομένων, argc. Και στη συνέχεια σε κάθε επανάληψη, εκτυπώσετε ένα string. Τι χορδών; 

Το i-th κορδόνι στο argv. Έτσι, ενώ πριν ήμουν χρησιμοποιώντας την αγκύλη σημειογραφία για να πάρει το i-οστό χαρακτήρα σε μια σειρά, τώρα Είμαι χρησιμοποιώντας το συμβολισμό πλατεία βραχίονα για να πάρει στο κορδόνι i-σε μια σειρά. Έτσι είναι το είδος της ένα στρώμα παραπάνω, εννοιολογικά. 

Και έτσι τι είναι πετυχημένος γι 'αυτό πρόγραμμα τώρα, αν έχω συγκεντρώσει argv1, και στη συνέχεια να κάνουμε ./argv1, και στη συνέχεια πληκτρολογήστε σε κάτι σαν foo bar Baz, ποιες είναι οι τρεις προεπιλεγμένες λέξεις που ένα επιστήμονας υπολογιστών φτάνει για κάθε στιγμή αυτός ή αυτή χρειάζεται μερικές λέξεις κράτησης θέσης, και πατήστε Enter, κάθε μία από αυτές τις λέξεις, συμπεριλαμβανομένου του ονόματος του προγράμματος, το οποίο είναι στην argv στην πρώτη θέση, καταλήγει να τυπώνεται ένα κάθε φορά. Και αν μπορώ να αλλάξω αυτό, και το λέω κάτι σαν argv1 Zamyla Chan, παίρνουμε και τα τρία από αυτά Δηλαδή, η οποία είναι argv0, argv1, argv2, γιατί σε αυτό το περίπτωση argc, ο αριθμός, είναι 3. 

Αλλά τι είναι τακτοποιημένο είναι αν έχετε κατανοήσει ότι argv είναι απλά μια σειρά από χορδές, και καταλαβαίνετε ότι ένα string είναι μια σειρά από χαρακτήρες, μπορούμε πραγματικά να το είδος της χρήσης αυτής της πλατεία συμβολισμός βραχίονα πολλές φορές για να επιλέξετε μια σειρά, και στη συνέχεια επιλέξτε ένας χαρακτήρας μέσα στο string, κατάδυση σε βαθύτερα ως εξής. Σε αυτό το παράδειγμα, επιτρέψτε μου να πάω προχωρήσει και να καλέσετε αυτό argv2.c. Και σε αυτό το παράδειγμα, επιτρέψτε μου να πάει μπροστά και να κάνει το following-- για int παίρνω 0, i είναι μικρότερο από argc, i συν συν, ακριβώς όπως και πριν. Έτσι με άλλα words-- και τώρα αυτό είναι να πάρει αρκετά περίπλοκη. Στη συνέχεια, Πάω να πω επαναλάβει πάνω από χορδές σε argv, ως ένα σχόλιο για τον εαυτό μου. Και τότε Πάω να έχουν μια ένθετα για το βρόχο, η οποία πιθανώς έχουν κάνει, ή θεωρούνται αυτόν τον τρόπο, το Ξυστό, όπου Πάω να πω int-- είμαι δεν πρόκειται να χρησιμοποιήσετε το i και πάλι, γιατί δεν θέλω να σκιά, ή είδος αντικαταστήσετε το υπάρχον i. 

Πάω να, αντ 'αυτού, ας πούμε j, επειδή ότι πάμε μου σε μια μεταβλητή μετά θ, όταν είμαι ακριβώς που προσπαθεί να μετρούν απλούς αριθμούς. Για παίρνει ι 0-- και επίσης, ιδ, πρόκειται να να πάρει την πρύμνη μήκος του βραχίονα argv i, εφ 'όσον το j είναι μικρότερη από m, ι συν συν, κάντε τα εξής. Και εδώ είναι το ενδιαφέρον μέρος. 

Εκτυπώστε ένα χαρακτήρα και μια νέα γραμμή, συνδέοντας βραχίονα argv i, j βραχίονα. Εντάξει, οπότε επιτρέψτε μου να προσθέσω κάποια σχόλια εδώ. Επαναλάβει πάνω από χαρακτήρες στο ρεύμα στοιχειοσειράς, εκτύπωσης ι-ου χαρακτήρα στο i-th εγχόρδων. Έτσι τώρα, ας εξετάσουμε ποια είναι αυτά τα σχόλια σημαίνουν. 

Επαναλάβει πάνω από τις χορδές σε argv-- πόσα χορδές είναι σε argv, η οποία είναι μια σειρά; Argc πολλές, έτσι είμαι επανάληψη από i ισούται με 0 έως argc. Εν τω μεταξύ, πόσους χαρακτήρες είναι το i-οστό κορδόνι στο argv; 

Λοιπόν, για να πάρει την απάντηση, Απλά καλέστε μήκος συμβολοσειράς για την φροντίδα ρεύμα στοιχειοσειράς μου περίπου, το οποίο είναι argv βραχίονα i. Και Πάω να αποθηκεύουν προσωρινά ότι αξία σε n, μόνο για τους σκοπούς της προσωρινής αποθήκευσης, να το θυμάστε για την αποδοτικότητα. Και τότε Πάω προετοιμασία j στο 0, συνεχίζω εφ 'όσον j είναι μικρότερη από n, και σε κάθε επανάληψη αύξηση j. 

Και στη συνέχεια εδώ, ανά το σχόλιό μου στη γραμμή 12, εκτυπώσετε ένα χαρακτήρα, ακολουθείται από μια νέα γραμμή, Συγκεκριμένα argv βραχίονα i μου δίνει το i-th εγχόρδων στην argv-- έτσι την πρώτη λέξη, η δεύτερη λέξη, η τρίτη λέξη, οτιδήποτε. Και τότε καταδύσεις ι σε βαθύτερα, και παίρνει μένα η j-th χαρακτήρα αυτής της λέξης. Και έτσι, στην πραγματικότητα, μπορείτε να προσφέρετε argv ως πολυδιάστατη, ως ένα δισδιάστατο, συστοιχία, σύμφωνα με την οποία κάθε λέξη είδος των βλεμμάτων όπως αυτό στο μυαλό σας μάτι, και κάθε χαρακτήρας είναι το είδος της αποτελείται κατά μια στήλη, αν αυτό βοηθάει. 

Στην πραγματικότητα, όταν πειράζω Αυτό πέρα ​​στο μέλλον εβδομάδες, πρόκειται να είναι μια μικρή πιο πολύπλοκη από αυτό. Αλλά μπορείτε πραγματικά να σκεφτείτε ότι, προς το παρόν, όπως ακριβώς αυτό το δισδιάστατο σειρά, σύμφωνα με την οποία ένα επίπεδο που είναι όλα των χορδών. Και στη συνέχεια, αν έχετε βουτήξει σε βαθύτερα, μπορούν να πάρουν στα επιμέρους χαρακτήρες σ 'αυτήν από τη χρήση αυτού του συμβολισμό εδώ. 

Έτσι, αυτό είναι το καθαρό αποτέλεσμα; Επιτρέψτε μου να προχωρήσει και να να argv2-- καταριέται αυτό. Έκανα ένα λάθος εδώ. Εμμέσως δηλώνει η βιβλιοθήκη Stirling λειτουργία. Έτσι, όλο αυτό το διάστημα, είναι ίσως σκόπιμο ότι είμαστε το είδος του φινίρισμα ακριβώς όπου ξεκινήσαμε. 

Έχω μαντάρα, εμμέσως δηλώνοντας βιβλιοθήκη Stirling λειτουργία. ΟΚ, περιμένετε ένα λεπτό. Θυμάμαι ότι, ειδικά δεδομένου ότι είναι ακριβώς εδώ. Θα πρέπει να συμπεριλάβετε string.h στην Αυτή η έκδοση του προγράμματος. 

Επιτρέψτε μου να προχωρήσει και να περιλαμβάνουν string.h, εκτός του ότι, προχωρήστε και ξαναμεταγλωττίσετε argv2. Και τώρα, εδώ πηγαίνουμε, να argv2, Enter. Και αν και είναι λίγο αινιγματική με την πρώτη ματιά, παρατηρήσετε ότι, πράγματι, αυτό που εκτυπώνεται είναι dot argv2. 

Αλλά αν πληκτρολογήσετε κάποιες λέξεις μετά την προτροπή, όπως argv2 Zamyla Chan, Εισάγετε, επίσης, μια μικρή αινιγματική με την πρώτη ματιά. Αλλά αν μετακινηθείτε προς τα πίσω επάνω, ./argv2 Ζ-Α-Μ-Y-L-Α C-H-Α-Ν. Έτσι έχουμε επαναλαμβάνεται πάνω από κάθε λέξη. Και, στη συνέχεια, έχουμε επαναληφθεί σ 'όλη κάθε χαρακτήρας μέσα σε μια λέξη. 

Τώρα, μετά από όλα αυτά, συνειδητοποιούν ότι υπάρχει μία άλλη λεπτομέρεια ήμασταν είδος αγνοώντας ολόκληρη αυτή τη φορά. Εμείς απλά πείραζαν πέρα ​​ό, τι είσοδοι κύρια μπορεί να είναι; Τι γίνεται με έξοδο κύριο του; 

Όλα αυτό το διάστημα, έχουμε ήδη απλά αντιγραφή και επικόλληση η λέξη int μπροστά από την κύρια, αν και μπορείτε να δείτε σε απευθείας σύνδεση, μερικές φορές λανθασμένα σε παλαιότερες εκδόσεις της C και μεταγλωττιστές, που λένε άκυρη, ή τίποτα δεν σε όλα. Αλλά, πράγματι, για την έκδοση της C που χρησιμοποιείτε, C 11, ή το 2011, να συνειδητοποιήσουν ότι πρέπει να είναι int. Και θα πρέπει να είναι είτε άκυρη ή argc και argv εδώ. 

Αλλά γιατί int main; Τι είναι αυτό στην πραγματικότητα την επιστροφή; Λοιπόν, αποδεικνύεται όλο αυτό το διάστημα, κάθε φορά που έχω γράψει ένα κύριο πρόγραμμα πάντα επιστρέφει κάτι. Αλλά έχει κάνει τόσο κρυφά. 

Αυτό το κάτι είναι μια int, όπως γραμμή 5 δείχνει. Αλλά τι int; Λοιπόν, υπάρχει αυτό το σύμβαση στον προγραμματισμό, σύμφωνα με την οποία, εάν δεν έχει πάει στραβά και όλα είναι καλά, τα προγράμματα και τις λειτουργίες εν γένει return-- κάπως counterintuitively-- 0. 0 σημαίνει γενικά όλα είναι καλά. Έτσι, ακόμη κι αν σκεφτείτε ως ψευδή σε πολλές περιπτώσεις, στην πραγματικότητα σημαίνει γενικά ένα καλό πράγμα 

Εν τω μεταξύ, εάν ένα πρόγραμμα επιστρέφει 1, ή αρνητική 1, ή 5, ή αρνητική 42, ή μη 0 αξίας, ότι σημαίνει γενικά ότι κάτι έχει πάει στραβά. Στην πραγματικότητα, για τη δική σας Mac ή PC, μπορεί να έχετε δει στην πραγματικότητα ένα μήνυμα σφάλματος, το οποίο λέει κάτι ή άλλο, χωρίς σφάλματα κωδικός αρνητικής 42, ή λάθος κωδικό 23, ή κάτι τέτοιο. Αυτός ο αριθμός είναι γενικά μόνο μια υπόδειξη στον προγραμματιστή, ή την εταιρεία που έκανε το λογισμικό, τι πήγε στραβά και γιατί, έτσι ώστε να μπορεί να κοιτάξει μέσα από τεκμηρίωση ή τον κωδικό τους, και να καταλάβω ποια είναι η σφάλματος σημαίνει στην πραγματικότητα. Είναι γενικά δεν είναι χρήσιμο για εμάς τους τελικούς χρήστες. 

Αλλά όταν η κύρια επιστρέφει 0, όλα είναι καλά. Και αν δεν προσδιορίζουν ποια είναι τα κυριότερα πρέπει να επιστρέψουν, Θα μόνο αυτόματα επιστρέψετε 0 για εσάς. Αλλά επιστρέφοντας κάτι άλλος είναι πραγματικά χρήσιμη. 

Σε αυτό το τελικό πρόγραμμα, επιτρέψτε μου να προχωρήσει και να καλέσετε αυτό το exit.c, και εισάγουν την τελευταία της σημερινής θέματα, που είναι γνωστή ως έναν κωδικό σφάλματος. Επιτρέψτε μου να προχωρήσει και να περιλαμβάνουν μας εξοικειωμένοι αρχεία επάνω στην κορυφή, κάντε int main. Και αυτή τη φορά, ας κάνουμε int argc, εγχόρδων argv, και με στηρίγματα μου να σημαίνει ότι είναι στη συστοιχία. Και τότε επιτρέψτε μου να κάνω μια επιταγή λογική. Αυτή τη φορά, αν argc δεν ίσες 2, τότε ξέρετε τι; Ξέχνα το. Πάω να πω ότι, hey, ο χρήστης, σας λείπει το επιχείρημα της γραμμής εντολών backslash n. 

Και, στη συνέχεια, αυτό είναι όλο. Θέλω να βγείτε. Πάω να preemptively, και πρόωρα πραγματικά, επιστροφή κάτι άλλο εκτός από τον αριθμό 1. Ο Συνήγορος του Πολίτη για την αξία για την πρώτη σφάλμα που μπορεί να συμβεί είναι 1. Αν έχετε κάποια άλλη λανθασμένη κατάσταση που μπορεί να προκύψουν, θα μπορούσαμε να πούμε επιστροφή 2 ή επιστροφής 3, ή ίσως ακόμη και αρνητική 1 ή αρνητική 2. 

Αυτά είναι απλά κωδικοί εξόδου που είναι, γενικά, μόνο χρήσιμη για τον προγραμματιστή, ή ο Η εταιρεία που έχει την αποστολή του λογισμικού. Αλλά το γεγονός ότι είναι Δεν 0 είναι αυτό που είναι σημαντικό. Έτσι, εάν σε αυτό το πρόγραμμα, θέλω να εγγυάται ότι το πρόγραμμα αυτό μόνο λειτουργεί αν ο χρήστης μου παρέχει με μια καταμέτρηση επιχείρημα των δύο, το όνομα του προγράμματος, και κάποια άλλα λέξη, μπορώ να επιβάλουν όσο το εξής, φωνάζω στο χρήστη με printf ρητό, λείπει το επιχείρημα της γραμμής εντολών, επιστρέψουν 1. Αυτό θα είναι ακριβώς αμέσως κλείστε το πρόγραμμα. 

Μόνο αν argc ισούται με 2 θα μπορούμε να πιάσουμε εδώ, σε ποιο σημείο Πάω να πω, γεια τοις εκατό s, ανάστροφη κάθετο n, argv1. Με άλλα λόγια, είμαι Δεν πηγαίνει μετά argv 0, η οποία είναι μόνο το όνομα του προγράμματος. Θέλω να εκτυπώσετε ένα γεια, κόμμα, η δεύτερη λέξη που το ανθρώπινο πληκτρολογήσει. Και σε αυτή την περίπτωση για γραμμή 13, όλα είναι καλά. 

Ξέρω ότι argc είναι 2 λογικά από αυτό το πρόγραμμα. Πάω να πάει μπροστά και να επιστρέψει 0. Παρεμπιπτόντως, έχετε κατά νου ότι Αυτό είναι αληθές σε Scratch επίσης. 

Λογικά, θα μπορούσα να κάνω αυτό και συμπυκνώνουν αυτές τις γραμμές του κώδικα σε αυτό το άλλο ρήτρα εδώ. Αλλά αυτό είναι το είδος της άσκοπα εσοχή κωδικό μου. Και θέλω να υπερ σαφές ότι αυτό δεν έχει σημασία, από προεπιλογή, γεια κάτι που θα εκτυπωθεί, εφ 'όσον ο χρήστης συνεργάζεται. 

Έτσι είναι πολύ κοινό να χρησιμοποιήσει μια κατάσταση, απλά μια περίπτωση, να πιάσει κάποια λανθασμένη κατάσταση, και στη συνέχεια την έξοδο. Και στη συνέχεια, εφ 'όλα είναι καλά, δεν έχουν ένα άλλο, αλλά απλώς έχουν τον κωδικό εκτός ότι αν, επειδή είναι ισοδύναμο με αυτό συγκεκριμένη περίπτωση, λογικά. Έτσι είμαι επιστρέφουν 0, ακριβώς για να δηλώνουν ρητά ότι όλα είναι καλά. 

Αν έχω παραλείψει την επιστροφή 0, θα ήταν να υποτεθεί αυτόματα για μένα. Αλλά τώρα που είμαι επιστρέφουν ένα σε τουλάχιστον αυτή την περίπτωση, Πάω να, για το καλό μέτρο και σαφήνεια, επιστρέφουν 0 στην περίπτωση αυτή. Έτσι τώρα επιτρέψτε μου να προχωρήσει και να κάνει την έξοδο, το οποίο είναι ένα τέλειο segue σε μόλις φύγει. 

Αλλά να κάνει την έξοδο, και επιτρέψτε μου να πάω μπροστά και να κάνουμε ./exit, Enter. Και το πρόγραμμα φώναξε σε μένα, λείπει το επιχείρημα της γραμμής εντολών. Εντάξει, επιτρέψτε μου να συνεργάζονται. 

Επιτρέψτε μου αντί να κάνει ./exit, Ντέιβιντ, Enter. Και τώρα λέει, γειά σου Δαβίδ. Και κανονικά δεν θα δείτε αυτό. 

Αλλά αποδεικνύεται ότι υπάρχει μια ιδιαίτερο τρόπο στο Linux για να δούμε πραγματικά με ποιο έξοδο κώδικα ενός προγράμματος αποχώρησε. Μερικές φορές, σε μια γραφική κόσμο, όπως το Mac OS ή Windows, βλέπετε μόνο τους αριθμούς αυτούς, όταν ένα μήνυμα σφάλματος εμφανίζεται στην οθόνη και ο προγραμματιστής σας δείχνει τον αριθμό αυτό. Αλλά αν θέλουμε να δούμε ποιο είναι το σφάλμα μήνυμα είναι, μπορούμε να το κάνουμε here-- έτσι ./exit, Enter, εκτύπωση λείπει το επιχείρημα της γραμμής εντολών. 

Αν εγώ τώρα κάνω echo $ ?, η οποία είναι γελοία αινιγματικό ψάχνετε. Αλλά $; είναι το μαγικό ξόρκι που λέει, hey, ηλεκτρονικών υπολογιστών, πες μου τι το προηγούμενο κωδικό εξόδου του προγράμματος ήταν. Και εγώ πατήστε Enter. Βλέπω 1, γιατί αυτό είναι που εγώ είπε κύρια λειτουργία μου να επιστρέψει. 

Εν τω μεταξύ, αν το κάνω ./exit David, και πατήστε Enter, βλέπω, γεια David. Κι αν τώρα κάνω echo $ ?, βλέπω γεια 0. Και έτσι αυτό θα είναι πράγματι είναι πολύτιμες πληροφορίες στο πλαίσιο του προγράμματος εντοπισμού σφαλμάτων, δεν είναι τόσο πολύ ότι, το ανθρώπινο, θα με νοιάζει. Αλλά το πρόγραμμα εντοπισμού σφαλμάτων και άλλα προγράμματα θα χρησιμοποιήσουμε αυτό το εξάμηνο θα δούμε συχνά σε αυτόν τον αριθμό, ακόμα κι αν αυτό είναι το είδος της κρυμμένα εκτός και αν το ψάξετε, να καθορίσει εάν ένα πρόγραμμα ή όχι εκτέλεσης ήταν σωστή ή λανθασμένη. 

Και έτσι αυτό μας φέρνει στο αυτό, στο τέλος της ημέρας. Ξεκινήσαμε σήμερα με την εξέταση τον εντοπισμό σφαλμάτων, και με τη σειρά του στο γήπεδο μόνη της, και στη συνέχεια πιο ενδιαφέροντα, τεχνικά κάτω από την κουκούλα σε ποιο χορδές είναι, που διαρκούν την εβδομάδα που μόλις πήρε για δεδομένος, και σίγουρα τους πήρε δεδομένο το Scratch. 

Στη συνέχεια κοίταξε πώς μπορούμε να έχουμε πρόσβαση μεμονωμένους χαρακτήρες σε μια σειρά, και στη συνέχεια πήρε και πάλι ένα υψηλότερο επίπεδο δούμε τα πράγματα, εξετάζοντας το πώς well-- αν θέλουμε να πάρει σε ατομικό στοιχεία σε μια λίστα, όπως δομή, Δεν μπορούμε να το κάνουμε αυτό με πολλαπλές χορδές; Και μπορούμε με τα επιχειρήματα της γραμμής εντολών. Αλλά αυτή η εικόνα εδώ ακριβώς κουτιά είναι εκδηλωτικός αυτής γενικής ιδέας ενός πίνακα ή μια λίστα, ή φορέα. Και ανάλογα με το πλαίσιο, όλες αυτές τις λέξεις σημαίνει ελαφρώς διαφορετικά πράγματα. Έτσι σε C, θα πρόκειται μόνο για να μιλήσουμε για μια σειρά. Και μια σειρά είναι ένα κομμάτι της μνήμης, καθένας από τους οποίους είναι στοιχεία είναι συνεχόμενα, την πλάτη, προς τα πίσω, προς τα πίσω, προς τα πίσω. 

Και τα στοιχεία αυτά είναι, σε γενικές γραμμές, του ίδιου τύπου δεδομένων, το χαρακτήρα, χαρακτήρα, χαρακτήρα, χαρακτήρα, ή string, string, string, string, ή int, int, int, ό, τι είναι προσπαθούμε να κατάστημα. Αλλά στο τέλος της ημέρας, αυτό είναι τι μοιάζει εννοιολογικά. Παίρνετε σας μνήμης ή RAM του υπολογιστή. Και είστε το αποσύρουν σε πανομοιότυπα μεγέθους κουτιά, τα οποία όλα είναι πίσω, προς τα πίσω, για να πίσω, προς τα πίσω με αυτόν τον τρόπο. 

Και τι είναι ωραίο για Αυτή η ιδέα, και το γεγονός ότι μπορούμε να εκφράσουμε τις τιμές με τον τρόπο αυτό με την πρώτη από τις δομές δεδομένων μας στην τάξη, σημαίνει ότι μπορεί να ξεκινήσει να λύσει τα προβλήματα με κωδικό ότι ήρθε τόσο διαισθητικά στην εβδομάδα 0. Θα θυμηθούμε το τηλέφωνο παράδειγμα το βιβλίο, όπου χρησιμοποιήσαμε ένα διαίρει και βασίλευε, ή μια δυαδική αναζήτηση, να κοσκινίσει μέσω μιας ολόκληρης δέσμη των ονομάτων και αριθμών. Αλλά εμείς υποτίθεται, ανάκληση, ότι τηλεφωνικό είχε ήδη διευθετηθεί, ότι κάποιος άλλος είχε ήδη κατάλαβα out-- δίνεται μια λίστα με τα ονόματα και numbers-- πώς να τα alphabetize. Και τώρα που σε C εμείς, επίσης, έχουν την ικανότητα να θέσει τα πράγματα, δεν σωματικά σε ένα τηλεφωνικό κατάλογο αλλά σχεδόν σε ένα υπολογιστή μνήμη, θα είμαστε σε θέση την επόμενη εβδομάδα να εισαγάγει και πάλι this-- πρώτη δομών δεδομένων μας σε ένα array-- αλλά το πιο σημαντικό, πραγματικό υπολογιστή επιστήμη αλγόριθμοι εφαρμόζονται στον κώδικα, με το οποίο μπορούμε να αποθηκεύσουμε δεδομένα σε δομές όπως αυτό, και στη συνέχεια να αρχίσουν να το χειραγωγήσουν, και να λύσει πραγματικά προβλήματα με αυτό, και να χτίσει στην κορυφή του ότι, τελικά, τα προγράμματα σε C, σε Python, το JavaScript, διερευνούν τις βάσεις δεδομένων με τον SQL; 

Και θα δείτε ότι όλα αυτά διαφορετικές ιδέες αλληλοσυνδέονται. Αλλά για τώρα, να υπενθυμίσω ότι η τομέα που παρουσιάσαμε σήμερα ήταν αυτό το πράγμα εδώ, και ο κόσμος της κρυπτογραφίας. Και μεταξύ τους επόμενους εσείς προβλήματα θα λύσει είναι η τέχνη της κρυπτογραφίας, κρυπτογράφησης και αποκρυπτογράφηση πληροφοριών, και κρυπτογράφηση και αποκρυπτογράφηση κειμένου, και υποθέτοντας ότι, τελικά, ότι ξέρετε τώρα τι είναι κάτω από την κουκούλα έτσι ώστε όταν βλέπετε ή να λάβετε ένα μήνυμα σαν αυτό, τον εαυτό σας μπορεί να το αποκρυπτογραφήσει. Όλα αυτά, και περισσότερο την επόμενη φορά. 

[ΑΝΑΠΑΡΑΓΩΓΉ ΒΊΝΤΕΟ] 

-Mover Μόλις έφτασε. Πάω να πάει επίσκεψη καθηγητής κολεγίου του. Ναι. Γεια. Είσαι εσύ. Περιμένετε! Δαβίδ. Είμαι απλώς προσπαθώ να καταλάβω τι συνέβη σε σας. Παρακαλούμε, οτιδήποτε θα μπορούσε να βοηθήσει. Ήσουν κολέγιο του συγκάτοικο, δεν ήσουν; Ήσουν εκεί μαζί του, όταν τελείωσε το έργο CS50; 

[ΜΟΥΣΙΚΗ Playing] 

-ότι Ήταν CS50. 

Αγαπώ αυτό το μέρος. 

-Φάε. Εμείς πάμε έξω από τις επιχειρήσεις. 

[ΤΕΛΟΣ ΑΝΑΠΑΡΑΓΩΓΗ] 