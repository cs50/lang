1
00:00:00,000 --> 00:00:02,970
>> [Musik spelar]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN: Okej.

4
00:00:15,700 --> 00:00:18,832
Detta är CS50 och detta
är början på vecka två.

5
00:00:18,832 --> 00:00:21,040
Och du kommer ihåg att över
Sedan ett par veckor,

6
00:00:21,040 --> 00:00:24,490
vi har infört dator
vetenskap och, i sin tur, programmering.

7
00:00:24,490 --> 00:00:27,640
>> Och vi började historien med hjälp av
Scratch, som grafiska språket

8
00:00:27,640 --> 00:00:28,990
från MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
Och sedan senast,
förra veckan, gjorde vi

10
00:00:30,780 --> 00:00:34,450
införa en higher-- en
lägre nivå språk känt

11
00:00:34,450 --> 00:00:36,770
som C, något som är rent text.

12
00:00:36,770 --> 00:00:39,440
Och faktiskt, sista gången vi
utforskas i det sammanhanget

13
00:00:39,440 --> 00:00:40,450
ett antal begrepp.

14
00:00:40,450 --> 00:00:43,010
>> Detta minns, var mycket
första programmet vi tittat på.

15
00:00:43,010 --> 00:00:45,710
Och detta program, helt enkelt,
skriver ut, "Hej, världen".

16
00:00:45,710 --> 00:00:47,730
Men det finns så mycket
problem magi pågår.

17
00:00:47,730 --> 00:00:51,460
Det är det här #include
med dessa vinkeljärnen.

18
00:00:51,460 --> 00:00:52,170
Det finns int.

19
00:00:52,170 --> 00:00:53,020
Det finns (void).

20
00:00:53,020 --> 00:00:56,330
Det finns parenteser, klamrar,
semikolon, och så mycket mer.

21
00:00:56,330 --> 00:00:58,480
>> Och så minns att
introducerade vi Scratch

22
00:00:58,480 --> 00:01:02,110
så att vi kunde, i idealfallet, se förbi
att syntax, de saker som är verkligen inte

23
00:01:02,110 --> 00:01:04,590
allt som intellektuellt
intressant men tidigt

24
00:01:04,590 --> 00:01:07,700
är absolut, lite knepigt
att linda dig runt.

25
00:01:07,700 --> 00:01:10,860
Och, faktiskt, ett av de vanligaste
saker tidigt på i en program klass,

26
00:01:10,860 --> 00:01:13,443
särskilt för de mindre
bekväm, är att bli frustrerad av

27
00:01:13,443 --> 00:01:17,460
och trippade upp av vissa syntaktiska
fel, för att inte tala logiska fel.

28
00:01:17,460 --> 00:01:19,800
Och så bland våra mål
idag, faktiskt, kommer

29
00:01:19,800 --> 00:01:23,280
vara att utrusta dig med några
problemlösning tekniker för hur

30
00:01:23,280 --> 00:01:26,705
att bättre lösa problem själva
i form av felsökning.

31
00:01:26,705 --> 00:01:29,330
Och du minns också att
miljö som vi införde

32
00:01:29,330 --> 00:01:31,780
förra gången kallades CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Detta är webbaserad programvara som
kan du programmera i molnet,

34
00:01:34,850 --> 00:01:38,450
så att säga, och samtidigt hålla alla dina
filer tillsammans, som vi återigen kommer i dag.

35
00:01:38,450 --> 00:01:41,480
Och minns att vi
revisited dessa frågor här,

36
00:01:41,480 --> 00:01:44,480
bland dem funktioner och loopar, och
variabler och booleska uttryck,

37
00:01:44,480 --> 00:01:45,110
och villkor.

38
00:01:45,110 --> 00:01:49,190
Och faktiskt några fler att vi
översatt från världen av Scratch

39
00:01:49,190 --> 00:01:50,800
till en värld av C.

40
00:01:50,800 --> 00:01:53,220
>> Men de grundläggande bygg
block, så att säga,

41
00:01:53,220 --> 00:01:55,150
var verkligen fortfarande samma förra veckan.

42
00:01:55,150 --> 00:01:57,900
Faktum är att vi egentligen bara hade en
olika pusselbit, om man så vill.

43
00:01:57,900 --> 00:02:00,300
I stället för att lila
spara blocket, vi istället

44
00:02:00,300 --> 00:02:02,940
hade printf, vilket är
denna funktion i C som

45
00:02:02,940 --> 00:02:05,890
kan du skriva ut något
och formatera den på skärmen.

46
00:02:05,890 --> 00:02:07,950
Vi introducerade CS50
Bibliotek, där du

47
00:02:07,950 --> 00:02:11,420
Nu har till ditt förfogande get_char,
och get_int, och get_string,

48
00:02:11,420 --> 00:02:14,610
och några andra funktioner som
väl, via vilken du kan få input

49
00:02:14,610 --> 00:02:16,260
från användarens egen tangentbord.

50
00:02:16,260 --> 00:02:20,640
Och vi tog också en titt på saker
som dessa-bool och röding,

51
00:02:20,640 --> 00:02:22,490
och dubbel, flyta,
int, long_long sträng.

52
00:02:22,490 --> 00:02:25,170
Och det finns även andra datatyper i C.

53
00:02:25,170 --> 00:02:28,560
>> Med andra ord, när du deklarerar
en variabel för att lagra ett visst värde,

54
00:02:28,560 --> 00:02:32,600
eller när du genomför en funktion
som returnerar ett visst värde,

55
00:02:32,600 --> 00:02:35,290
Du kan ange vad
typ av värde som är.

56
00:02:35,290 --> 00:02:37,310
Är det en sträng, som en
sekvens av tecken?

57
00:02:37,310 --> 00:02:39,490
Är det ett nummer, som ett heltal?

58
00:02:39,490 --> 00:02:41,390
Är det en flyttals
värde, eller liknande?

59
00:02:41,390 --> 00:02:46,180
Så i C, till skillnad från Scratch, vi faktiskt
började att ange vilken typ av data

60
00:02:46,180 --> 00:02:48,330
vi tillbaka eller använder.

61
00:02:48,330 --> 00:02:51,910
>> Men, naturligtvis, sprang vi även i
vissa grundläggande begränsningar av datorer.

62
00:02:51,910 --> 00:02:54,100
Och framför allt,
detta språk C, minns

63
00:02:54,100 --> 00:02:57,070
att vi tog en titt på
heltalsspill, verkligheten

64
00:02:57,070 --> 00:03:00,460
att om du bara har en
ändlig mängd minne

65
00:03:00,460 --> 00:03:04,600
eller, närmare bestämt, ett ändligt antal
bitar, kan du bara räkna så högt.

66
00:03:04,600 --> 00:03:08,460
Och så vi tittat på det här exemplet här
varigenom en räknare i ett flygplan,

67
00:03:08,460 --> 00:03:13,510
faktiskt, om det körs tillräckligt länge skulle
svämma över och resulterar i en programvara

68
00:03:13,510 --> 00:03:15,560
en fysisk potential fel.

69
00:03:15,560 --> 00:03:18,600
>> Vi har också tittat på flytande
punkt vaghet, verkligheten

70
00:03:18,600 --> 00:03:22,280
att med endast ett ändligt antal
bitar, oavsett om det är 32 eller 64,

71
00:03:22,280 --> 00:03:27,330
Du kan endast ange så många siffror
efter ett decimalkomma, varefter du

72
00:03:27,330 --> 00:03:29,110
börjar få oprecis.

73
00:03:29,110 --> 00:03:32,360
Så till exempel, en tredjedel i
värld här, i vår mänskliga världen,

74
00:03:32,360 --> 00:03:35,360
vi vet är bara ett oändligt antal
av 3s efter decimalkommat.

75
00:03:35,360 --> 00:03:38,820
Men en dator kan inte nödvändigtvis
representerar ett oändligt antal siffror

76
00:03:38,820 --> 00:03:42,590
om du bara låta det några
begränsad mängd information.

77
00:03:42,590 --> 00:03:45,900
>> Så inte nog med att vi utrustar dig
med större kraft när det gäller

78
00:03:45,900 --> 00:03:49,280
på hur du kan uttrycka dig på
ett tangentbord i form av programmering,

79
00:03:49,280 --> 00:03:51,430
vi begränsat också vad
du faktiskt kan göra.

80
00:03:51,430 --> 00:03:55,790
Och faktiskt, buggar och misstag kan
uppstå från dessa typer av frågor.

81
00:03:55,790 --> 00:03:59,900
Och faktiskt, bland de ämnen idag
kommer att vara som felsökning ämnen

82
00:03:59,900 --> 00:04:03,699
och faktiskt ser under huven
på hur saker och ting infördes förra veckan

83
00:04:03,699 --> 00:04:05,490
faktiskt genomförs
så att du bättre

84
00:04:05,490 --> 00:04:10,530
förstå både kapacitet och
begränsningarna hos ett språk som C.

85
00:04:10,530 --> 00:04:14,770
>> Och i själva verket kommer vi skära ner lagren
av den enklaste av datastrukturen,

86
00:04:14,770 --> 00:04:17,756
något som kallas en matris, som
Scratch råkar kalla en "lista".

87
00:04:17,756 --> 00:04:19,589
Det är lite
annorlunda i detta sammanhang.

88
00:04:19,589 --> 00:04:23,340
Och sedan kommer vi också att införa en av de
första av våra domänspecifika problem

89
00:04:23,340 --> 00:04:26,790
i CS50, värld
kryptografi, konsten att klättra

90
00:04:26,790 --> 00:04:29,650
eller kryptering uppgifter så
att du kan skicka hemliga meddelanden

91
00:04:29,650 --> 00:04:34,520
och avkoda hemliga meddelanden
mellan två personer, A och B.

92
00:04:34,520 --> 00:04:37,490
>> Så innan vi övergång
till den nya världen,

93
00:04:37,490 --> 00:04:42,059
låt oss försöka att utrusta dig med några
tekniker som du kan eliminera

94
00:04:42,059 --> 00:04:43,850
eller reducera åtminstone en del
av frustration

95
00:04:43,850 --> 00:04:46,630
att du förmodligen har stött
under den senaste veckan ensam.

96
00:04:46,630 --> 00:04:50,830
I själva verket före du such-- några av
dina första problem i C. Och oddsen är,

97
00:04:50,830 --> 00:04:54,010
Om du är som mig, första gången
du försöker skriva ut ett program,

98
00:04:54,010 --> 00:04:57,330
även om du tror logiskt
Programmet är ganska enkelt,

99
00:04:57,330 --> 00:05:01,200
du kan mycket väl slå en vägg, och
kompilatorn kommer inte att samarbeta.

100
00:05:01,200 --> 00:05:03,940
Gör eller Clang kommer inte
att faktiskt göra din budgivning.

101
00:05:03,940 --> 00:05:05,450
>> Och varför skulle det vara?

102
00:05:05,450 --> 00:05:07,950
Nåväl, låt oss ta en titt på,
kanske, ett enkelt program.

103
00:05:07,950 --> 00:05:11,190
Jag kommer att gå vidare och spara det i
en fil medvetet kallas buggy0.c,

104
00:05:11,190 --> 00:05:13,590
eftersom jag vet att det
vara bristfällig i förväg.

105
00:05:13,590 --> 00:05:17,400
Men jag kanske inte inser att om detta
är den första eller andra eller tredje programmet

106
00:05:17,400 --> 00:05:18,830
att jag faktiskt gör mig.

107
00:05:18,830 --> 00:05:23,820
Så jag kommer att gå vidare och
skriver ut, int main (void).

108
00:05:23,820 --> 00:05:28,130
Och sedan inne i mina klammerparenteser,
en mycket bekant ( "Hej, world--

109
00:05:28,130 --> 00:05:30,980
bakåtstreck, n ") - och ett semikolon.

110
00:05:30,980 --> 00:05:32,360
>> Jag har sparat filen.

111
00:05:32,360 --> 00:05:34,850
Nu ska jag gå ner
till min terminalfönster

112
00:05:34,850 --> 00:05:40,340
och typ gör buggy0, eftersom, återigen,
namnet på filen i dag är buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Så jag skriver göra buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Och, oh, gosh, minns från förra gången
att inga felmeddelanden är en bra sak.

115
00:05:48,200 --> 00:05:49,740
Så ingen utgång är en bra sak.

116
00:05:49,740 --> 00:05:52,920
Men här har jag klart
visst antal misstag.

117
00:05:52,920 --> 00:05:56,470
>> Så den första raden av produktionen
när du har skrivit göra buggy0, återkallande,

118
00:05:56,470 --> 00:05:59,540
är Clang är ganska utförlig utgång.

119
00:05:59,540 --> 00:06:02,067
Under huven,
CS50 IDE är konfigurerad

120
00:06:02,067 --> 00:06:04,150
att använda en massa
alternativ med denna kompilator

121
00:06:04,150 --> 00:06:05,941
så att du inte har
att tänka på dem.

122
00:06:05,941 --> 00:06:08,840
Och det är allt som första raden
medel som börjar med klang.

123
00:06:08,840 --> 00:06:11,720
>> Men efter att de problem
börja göra sitt utseende.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c på linje 3, tecken
5, finns det en stor, röd fel.

125
00:06:17,390 --> 00:06:18,380
Vad är det?

126
00:06:18,380 --> 00:06:23,562
Underförstått att förklara biblioteksfunktion
printf med typen int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Jag menar, det mycket snabbt
blir mycket svårbegripliga.

129
00:06:28,379 --> 00:06:30,170
Och visst, i första
blick, vi skulle inte

130
00:06:30,170 --> 00:06:32,380
förväntar dig att förstå
helheten av det meddelandet.

131
00:06:32,380 --> 00:06:34,213
Och så en av de lärdomar
för idag går

132
00:06:34,213 --> 00:06:36,919
att vara att försöka att lägga märke till
mönster, eller liknande saker,

133
00:06:36,919 --> 00:06:38,960
fel du kan ha
stött på tidigare.

134
00:06:38,960 --> 00:06:41,335
Så låt oss retas isär endast
dessa ord som ser bekant.

135
00:06:41,335 --> 00:06:44,290
Den stora, röda fel är klart
symbol för något att ha fel.

136
00:06:44,290 --> 00:06:47,940
>> Underförstått förstått~~POS=HEADCOMP att förklara
biblioteksfunktion printf.

137
00:06:47,940 --> 00:06:51,680
Så även om jag inte riktigt förstår vad
implicit förklarar biblioteksfunktion

138
00:06:51,680 --> 00:06:54,900
medel, problemet säkert
avser printf på något sätt.

139
00:06:54,900 --> 00:06:59,130
Och källan till denna fråga
har att göra med att förklara det.

140
00:06:59,130 --> 00:07:02,440
>> Förklara en funktion är
nämna det för första gången.

141
00:07:02,440 --> 00:07:06,210
Och vi använde terminologin förra veckan
att förklara en funktion prototyp,

142
00:07:06,210 --> 00:07:11,860
antingen med en rad högst upp på din
egen fil eller i en så kallad header-fil.

143
00:07:11,860 --> 00:07:15,300
Och i vilken fil gjorde vi säga
förra veckan att printf är citat,

144
00:07:15,300 --> 00:07:17,080
unquote förklarade?

145
00:07:17,080 --> 00:07:20,950
I vilken fil är dess prototyp?

146
00:07:20,950 --> 00:07:24,640
>> Så om ni minns, den allra första jag
skrivs nästan varje program förra time--

147
00:07:24,640 --> 00:07:30,790
och av misstag en stund sedan började
skriva myself-- var detta en här--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- för
input / output-- prick h Och faktiskt,

149
00:07:38,630 --> 00:07:41,860
om jag sparar nu den här filen, kommer jag
att gå vidare och rensa skärmen,

150
00:07:41,860 --> 00:07:44,740
som du kan göra genom att skriva
Klar, eller så kan du hålla kontroll L,

151
00:07:44,740 --> 00:07:47,680
bara för att rensa terminalfönster
bara för att eliminera en del skräp.

152
00:07:47,680 --> 00:07:51,370
>> Jag kommer att gå vidare och
re-typ make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Och voila, ser jag ändå att
lång kommando från klang,

154
00:07:53,790 --> 00:07:55,470
men det finns inget felmeddelande den här gången.

155
00:07:55,470 --> 00:07:58,800
Och faktiskt, om jag gör ./buggy0,
precis som förra gången,

156
00:07:58,800 --> 00:08:01,860
där prick innebär detta
katalog, Slash betyder bara,

157
00:08:01,860 --> 00:08:05,040
här kommer namnet på programmet och
att namnet på programmet är buggy0,

158
00:08:05,040 --> 00:08:07,340
Ange "Hello, World."

159
00:08:07,340 --> 00:08:09,440
>> Nu, hur kan du ha
gleaned denna lösning

160
00:08:09,440 --> 00:08:12,017
utan att nödvändigtvis
erkänna så många ord

161
00:08:12,017 --> 00:08:14,350
som jag gjorde, verkligen, med
gjort detta i så många år?

162
00:08:14,350 --> 00:08:18,720
Tja, inser per det första problemet
set, presenterar vi ett kommando

163
00:08:18,720 --> 00:08:21,175
att CS50 egen personal
skrev kallas help50.

164
00:08:21,175 --> 00:08:24,300
Och faktiskt, C gör specifikation för
problemet satt som på hur man använder denna.

165
00:08:24,300 --> 00:08:27,210
>> Men help50 är väsentligen
ett program som CS50 personal

166
00:08:27,210 --> 00:08:30,850
skrev som tillåter dig att köra
ett kommando eller köra ett program,

167
00:08:30,850 --> 00:08:36,169
och om du inte förstår dess
utgång, att passera sin produktion till help50,

168
00:08:36,169 --> 00:08:38,890
vid vilken punkt programvaran
att kursen personal skrev

169
00:08:38,890 --> 00:08:42,429
kommer att titta på ditt program produktion
rad för rad, tecken för tecken.

170
00:08:42,429 --> 00:08:46,000
Och om vi, personalen, erkänner
felmeddelande som du upplever,

171
00:08:46,000 --> 00:08:50,580
Vi kommer att försöka provocera dig med några
retoriska frågor, med några råd,

172
00:08:50,580 --> 00:08:54,890
ungefär som en TF eller en CA eller själv
skulle göra personligen på kontorstid.

173
00:08:54,890 --> 00:08:58,320
>> Så se till help50 om du inte
nödvändigtvis känna igen ett problem.

174
00:08:58,320 --> 00:09:00,790
Men lita inte på det
alltför mycket som en krycka.

175
00:09:00,790 --> 00:09:03,990
Visst försöka förstå dess
utgång och sedan lära av det

176
00:09:03,990 --> 00:09:07,571
så att endast en eller två gånger gör du
någonsin köra help50 för ett visst fel

177
00:09:07,571 --> 00:09:08,070
meddelande.

178
00:09:08,070 --> 00:09:10,660
Efter det, bör du vara
bättre rustade själv

179
00:09:10,660 --> 00:09:13,180
att räkna ut vad det egentligen är.

180
00:09:13,180 --> 00:09:14,350
>> Låt oss göra en annan här.

181
00:09:14,350 --> 00:09:20,410
Låt mig gå vidare, och i en annan
fil vi kallar detta buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Och i den här filen är jag
kommer att deliberately--

183
00:09:23,110 --> 00:09:26,330
men låtsas att jag inte
förstå vad misstag jag har gjort.

184
00:09:26,330 --> 00:09:31,420
>> Jag kommer att gå vidare och göra this--
#include, eftersom jag har

185
00:09:31,420 --> 00:09:33,660
lärt mig min läxa från en stund sedan.

186
00:09:33,660 --> 00:09:36,220
Int main (void), som tidigare.

187
00:09:36,220 --> 00:09:40,880
Och sedan i här jag tänker
att göra sträng s - get_string.

188
00:09:40,880 --> 00:09:43,770
Och minns från förra gången som
detta sätt, hej, dator,

189
00:09:43,770 --> 00:09:48,280
ge mig en variabel, kalla det är, och
göra den typ av denna variabel en sträng

190
00:09:48,280 --> 00:09:50,150
så jag kan lagra ett eller flera ord i det.

191
00:09:50,150 --> 00:09:52,191
>> Och sedan på den högra
sidan av likhetstecknet

192
00:09:52,191 --> 00:09:54,980
är get_string, som är en
funktion i CS50 Library

193
00:09:54,980 --> 00:09:55,980
som gör just detta.

194
00:09:55,980 --> 00:09:59,740
Det blir en funktion och sedan
händer det från höger till vänster.

195
00:09:59,740 --> 00:10:02,670
Så detta likhetstecken betyder inte
"Lika med" som vi tror i matematik.

196
00:10:02,670 --> 00:10:04,750
Det betyder uppdrag från höger till vänster.

197
00:10:04,750 --> 00:10:09,640
Så innebär detta, ta strängen från
användaren och lagra den inne i er.

198
00:10:09,640 --> 00:10:10,460
>> Nu använder den.

199
00:10:10,460 --> 00:10:13,820
Låt mig gå vidare nu och som en andra
linje, låt mig gå vidare och säga "hej" -

200
00:10:13,820 --> 00:10:19,330
inte "världen", men "Hej,% s--
som är vår platshållare kommatecken s,

201
00:10:19,330 --> 00:10:22,030
som är vår variabel,
och sedan ett semikolon.

202
00:10:22,030 --> 00:10:26,070
Så om jag inte skruva upp för mycket
Här ser detta som rätt kod.

203
00:10:26,070 --> 00:10:28,090
>> Och mina instinkter är nu att kompilera det.

204
00:10:28,090 --> 00:10:30,400
Filen heter buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Så jag kommer att göra göra buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Och darn-det, om det inte finns
ännu fler fel än tidigare.

207
00:10:36,377 --> 00:10:38,210
Jag menar, det finns mer
felmeddelanden Det skulle

208
00:10:38,210 --> 00:10:40,400
verkar än faktiska linjer i det här programmet.

209
00:10:40,400 --> 00:10:42,730
>> Men takeaway här är,
även om du är överväldigad

210
00:10:42,730 --> 00:10:45,040
med två eller tre eller
fyra felmeddelanden,

211
00:10:45,040 --> 00:10:48,340
fokusera alltid på mycket
första av dessa meddelanden.

212
00:10:48,340 --> 00:10:52,220
Om man tittar på det översta en,
bläddra tillbaka upp som behövs.

213
00:10:52,220 --> 00:10:53,930
Så här skrev jag göra buggy1.

214
00:10:53,930 --> 00:10:55,700
Här är det klang ut som förväntat.

215
00:10:55,700 --> 00:10:57,290
>> Och här är det första röda fel.

216
00:10:57,290 --> 00:11:02,370
Användning av odeklarerat identifierare
sträng, jag menar standard?

217
00:11:02,370 --> 00:11:04,260
Så standard är
faktiskt något annat.

218
00:11:04,260 --> 00:11:06,240
Den hänvisar till användarens
tangentbord, i huvudsak.

219
00:11:06,240 --> 00:11:08,080
>> Men det är inte vad jag menade.

220
00:11:08,080 --> 00:11:11,770
Jag menade sträng, och jag menade get_string.

221
00:11:11,770 --> 00:11:16,200
Så vad är det som jag
glömde att göra den här gången?

222
00:11:16,200 --> 00:11:20,230
Vad som saknas den här gången?

223
00:11:20,230 --> 00:11:23,600
Jag har min #include,
så jag har tillgång till printf.

224
00:11:23,600 --> 00:11:26,090
>> Men vad jag inte har
tillgång till ännu?

225
00:11:26,090 --> 00:11:29,420
Jo, precis som förra gången,
Jag måste tala om för kompilatorn

226
00:11:29,420 --> 00:11:31,691
Klang vad dessa funktioner är.

227
00:11:31,691 --> 00:11:33,940
Get_string kommer inte
med C. Och i synnerhet det

228
00:11:33,940 --> 00:11:38,160
inte kommer i
header fil.

229
00:11:38,160 --> 00:11:40,770
Det kommer i stället i
något personalen skrev,

230
00:11:40,770 --> 00:11:44,176
vilket är en annan fil
namn men passande namnet.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Så enkelt genom att lägga till att en rad
av code-- minns från förra gången

233
00:11:50,861 --> 00:11:53,610
att när Clang körs, det kommer
att titta på min kod topp till botten,

234
00:11:53,610 --> 00:11:54,193
vänster till höger.

235
00:11:54,193 --> 00:11:57,200
Det kommer att lägga märke till,
Åh, du.

236
00:11:57,200 --> 00:11:59,900
Låt mig gå och hitta det,
varhelst det är på servern,

237
00:11:59,900 --> 00:12:03,090
kopiera och klistra in den i huvudsak
i toppen av din egen fil

238
00:12:03,090 --> 00:12:06,820
så att vid denna punkt i berättelsen,
linje 1, resten av programmet

239
00:12:06,820 --> 00:12:11,651
kan faktiskt använda någon av de funktioner
däri, bland dem get_string.

240
00:12:11,651 --> 00:12:13,650
Så jag kommer att ignorera
resten av dessa fel,

241
00:12:13,650 --> 00:12:17,190
eftersom jag faktiskt misstänker att endast
den första faktiskt betydde.

242
00:12:17,190 --> 00:12:20,780
Och jag kommer att gå vidare och repris,
efter att ha sparat min fil gör buggy1.

243
00:12:20,780 --> 00:12:22,580
Och voila, gjorde det arbete.

244
00:12:22,580 --> 00:12:29,200
Och om jag gör ./buggy1 och skriva in, för
Exempelvis Zamyla, jag nu kommer att få hej,

245
00:12:29,200 --> 00:12:32,000
Zamyla, i stället för hello, världen.

246
00:12:32,000 --> 00:12:32,550
>> Okej.

247
00:12:32,550 --> 00:12:35,890
Så hämtställen här då är att,
ett försök att få fram så mycket som möjligt

248
00:12:35,890 --> 00:12:39,140
från felmeddelanden ensam, ser
på några av de igenkännbara ord.

249
00:12:39,140 --> 00:12:43,070
Spärr att använda help50 per
problemet inställd specifikationen.

250
00:12:43,070 --> 00:12:46,500
Men spärra det också alltid se
upptill fel bara, åtminstone

251
00:12:46,500 --> 00:12:50,051
initialt, för att se vilken information
det faktiskt kan ge.

252
00:12:50,051 --> 00:12:52,300
Men det visar sig att det finns
ännu mer funktionalitet byggs

253
00:12:52,300 --> 00:12:55,030
i CS50 biblioteket för att hjälpa
du tidigt i terminen

254
00:12:55,030 --> 00:12:57,580
och tidigt i programmering
räkna ut vad som händer fel.

255
00:12:57,580 --> 00:12:59,840
Så låt oss göra ett annat exempel här.

256
00:12:59,840 --> 00:13:04,350
Jag kommer att kalla denna buggy2, som
igen, kommer att vara bristfällig ut

257
00:13:04,350 --> 00:13:05,650
porten, avsiktligt.

258
00:13:05,650 --> 00:13:09,980
>> Och jag kommer att gå vidare
och göra #include.

259
00:13:09,980 --> 00:13:12,580
Och sedan ska jag göra int main (void).

260
00:13:12,580 --> 00:13:14,840
Och sedan ska jag göra en for-loop.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i är mindre än eller lika med 10.

263
00:13:18,750 --> 00:13:24,260
i ++, och sedan i klammerparenteser, jag kommer
att skriva ut bara en hashtag symbol här

264
00:13:24,260 --> 00:13:25,920
och en ny rad tecken.

265
00:13:25,920 --> 00:13:29,220
>> Så min avsikt med denna
Programmet är helt enkelt

266
00:13:29,220 --> 00:13:33,150
att iterera 10 gånger
och på varje iteration

267
00:13:33,150 --> 00:13:35,260
i nämnda slinga varje gång
genom cykeln,

268
00:13:35,260 --> 00:13:37,660
skriva ut en hashtag,
en hashtag, en hashtag.

269
00:13:37,660 --> 00:13:40,480
Ett per rad, eftersom jag
har den nya linjen där.

270
00:13:40,480 --> 00:13:42,787
Och minns att för
slinga, per sista week--

271
00:13:42,787 --> 00:13:44,620
och du får mer
bekant med syntaxen

272
00:13:44,620 --> 00:13:47,170
genom att använda den med praxis
innan long-- detta ger mig

273
00:13:47,170 --> 00:13:49,740
en variabel som heter i och ställer det till 0.

274
00:13:49,740 --> 00:13:52,650
>> Detta ökar i på
varje iteration av en.

275
00:13:52,650 --> 00:13:54,940
Så jag går till 1 till 2-3.

276
00:13:54,940 --> 00:13:57,690
Och då detta villkor i
mitt emellan semikolon

277
00:13:57,690 --> 00:14:03,010
får kontrolleras på varje iteration att göra
säker på att vi fortfarande är inom räckhåll.

278
00:14:03,010 --> 00:14:06,830
Så jag vill iterera 10 gånger, så jag
har slags mycket intuitivt bara

279
00:14:06,830 --> 00:14:09,070
sätta 10 min övre gräns där.

280
00:14:09,070 --> 00:14:14,310
>> Och ändå, när jag kör detta, efter
sammanställa det med make buggy2--

281
00:14:14,310 --> 00:14:15,440
och det gör sammanställa OK.

282
00:14:15,440 --> 00:14:17,980
Så jag har inte en
syntaxfel den här gången.

283
00:14:17,980 --> 00:14:20,940
Låt mig gå vidare nu
och kör buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Och nu rulla upp.

285
00:14:22,620 --> 00:14:24,890
Och låt mig öka
storleken på fönstret.

286
00:14:24,890 --> 00:14:33,720
>> Jag verkar ha en, två, tre,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Så det finns 11 hashtags, även om
Jag satte klart 10 insidan av denna slinga.

288
00:14:38,891 --> 00:14:42,140
Nu kanske några av er ser omedelbart
vad felet beror på att, faktiskt, detta

289
00:14:42,140 --> 00:14:43,720
är inte ett mycket hårt fel att göra.

290
00:14:43,720 --> 00:14:46,070
Men det är mycket vanligt
gjort mycket tidigt.

291
00:14:46,070 --> 00:14:49,820
>> Vad jag vill påpeka, men,
är, hur kan jag räkna ut?

292
00:14:49,820 --> 00:14:52,300
Tja, visar det sig att
den CS50 Biblioteket kommer

293
00:14:52,300 --> 00:14:55,380
med inte bara get_string och get_int
och get_float och andra funktioner.

294
00:14:55,380 --> 00:14:59,980
Det kommer också med en speciell funktion
kallas eprintf, eller fel printf.

295
00:14:59,980 --> 00:15:03,270
Och det finns enbart för att göra
det lite lättare för dig

296
00:15:03,270 --> 00:15:06,310
när felsökning koden att bara
ut ett felmeddelande på skärmen

297
00:15:06,310 --> 00:15:07,850
och vet var den kom ifrån.

298
00:15:07,850 --> 00:15:11,000
>> Så till exempel, en sak som jag kanske
göra här med den här funktionen är this--

299
00:15:11,000 --> 00:15:20,230
eprintf, och sedan kommer jag att gå vidare
och säga att jag är nu% i, backslash, n.

300
00:15:20,230 --> 00:15:22,330
Och jag kommer att koppla in värde i.

301
00:15:22,330 --> 00:15:25,400
Och där uppe, eftersom detta
är i CS50 Library,

302
00:15:25,400 --> 00:15:27,580
Jag kommer att gå vidare
och innefattar

303
00:15:27,580 --> 00:15:29,169
så jag har tillgång till denna funktion.

304
00:15:29,169 --> 00:15:31,460
Men låt oss fundera på vad linje
9 är tänkt att göra.

305
00:15:31,460 --> 00:15:32,670
Jag kommer att ta bort detta så småningom.

306
00:15:32,670 --> 00:15:34,670
Detta har ingenting att göra
med min övergripande mål.

307
00:15:34,670 --> 00:15:39,090
Men eprintf, fel printf är bara tänkt
att ge mig några diagnosinformation.

308
00:15:39,090 --> 00:15:42,460
När jag kör mitt program, vill jag
se detta på skärmen tillfälligt

309
00:15:42,460 --> 00:15:44,550
liksom bara för att förstå
Vad pågår.

310
00:15:44,550 --> 00:15:47,330
>> Och, faktiskt, på varje
iteration här linjen 9

311
00:15:47,330 --> 00:15:49,260
Jag vill se, vad är värdet av i?

312
00:15:49,260 --> 00:15:50,290
Vad är värdet av i?

313
00:15:50,290 --> 00:15:51,280
Vad är värdet av i?

314
00:15:51,280 --> 00:15:55,650
Och förhoppningsvis jag skulle bara
se meddelandet, även, 10 gånger.

315
00:15:55,650 --> 00:15:57,780
>> Så låt mig gå vidare och
kompilera mitt program,

316
00:15:57,780 --> 00:15:59,905
som jag måste göra när som helst
Jag gör en ändring. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Och now-- OK.

319
00:16:03,640 --> 00:16:04,820
Det finns mycket mer att gå på.

320
00:16:04,820 --> 00:16:07,610
Så låt mig rulla upp i
en ännu större fönster.

321
00:16:07,610 --> 00:16:10,190
>> Och du ser att var och en av
den hashtags fortfarande utskrift.

322
00:16:10,190 --> 00:16:15,270
Men mellan vart och ett av dem är nu detta
diagnosuttag formaterade som följer.

323
00:16:15,270 --> 00:16:17,960
Namnet på mitt program här är buggy2.

324
00:16:17,960 --> 00:16:20,432
Namnet på filen är buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Radnumret som
detta trycktes är linjen 9.

326
00:16:24,080 --> 00:16:27,500
Och sedan till höger om denna är den
felmeddelande som jag förväntat mig.

327
00:16:27,500 --> 00:16:30,701
>> Och vad är trevligt om det här är att
nu har jag inte behöver nödvändigtvis räkna

328
00:16:30,701 --> 00:16:32,200
i mitt huvud vad mitt program gör.

329
00:16:32,200 --> 00:16:34,240
Jag kan se det på
första iterationen i är 0,

330
00:16:34,240 --> 00:16:39,420
sedan en, sedan två, sedan tre, sedan fyra, sedan
5, då sex, sedan 7, sedan 8, sedan 9, sedan

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Så vänta en minut.

333
00:16:42,050 --> 00:16:43,740
Vad händer här?

334
00:16:43,740 --> 00:16:48,190
Jag verkar fortfarande räknar
som avsett upp till 10.

335
00:16:48,190 --> 00:16:50,550
>> Men var jag börja?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Så 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11 finger

338
00:16:58,040 --> 00:16:59,990
är indikativ för problemet.

339
00:16:59,990 --> 00:17:02,850
Jag verkar ha räknat
felaktigt i min slinga.

340
00:17:02,850 --> 00:17:06,599
I stället för att gå 10 iterationer,
Jag börjar på 0,

341
00:17:06,599 --> 00:17:09,550
Jag slutar vid och genom 10.

342
00:17:09,550 --> 00:17:12,030
Men eftersom, som en dator,
Jag börjar räkna på 0,

343
00:17:12,030 --> 00:17:15,250
Jag ska räkna upp
till, men inte igenom, 10.

344
00:17:15,250 --> 00:17:18,510
>> Och så fix, jag så småningom
realiseras här, är en av två saker.

345
00:17:18,510 --> 00:17:22,430
Jag kunde mycket enkelt säga
räkna upp till mindre än 10.

346
00:17:22,430 --> 00:17:27,260
Så 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, som är verkligen rätt,

347
00:17:27,260 --> 00:17:28,900
även om det låter lite fel.

348
00:17:28,900 --> 00:17:35,070
Eller jag kunde göra mindre än eller lika
till 9, så länge jag börjar på 0.

349
00:17:35,070 --> 00:17:40,056
Eller om du verkligen inte gillar det, du
kan räkna upp till 10, men börjar på en.

350
00:17:40,056 --> 00:17:41,680
Men återigen, detta är bara inte så vanligt.

351
00:17:41,680 --> 00:17:43,977
I programming-- albeit
inte så mycket i Scratch--

352
00:17:43,977 --> 00:17:45,810
men i programmering i
C och andra språk,

353
00:17:45,810 --> 00:17:47,670
som JavaScript och
Python och andra är det

354
00:17:47,670 --> 00:17:49,880
bara mycket vanligt att
vår diskussion av binära

355
00:17:49,880 --> 00:17:53,450
att bara börja räkna på
lägsta antalet du kan, som är 0.

356
00:17:53,450 --> 00:17:53,950
Okej.

357
00:17:53,950 --> 00:17:55,160
Så det är eprintf.

358
00:17:55,160 --> 00:17:58,600
Och återigen, nu när jag har räknat ut min
problem, och jag kommer att gå tillbaka till 0

359
00:17:58,600 --> 00:18:01,470
genom mindre än 10, kommer jag
att gå in och ta bort eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Det bör inte vara där när jag
transportera min kod eller lämna min kod

361
00:18:04,580 --> 00:18:05,800
eller visa den för någon annan.

362
00:18:05,800 --> 00:18:07,980
Det är egentligen bara menade
att användas tillfälligt.

363
00:18:07,980 --> 00:18:11,650
Men nu har jag fast detta
särskilt problem också.

364
00:18:11,650 --> 00:18:16,780
>> Nåväl, låt oss göra ett exempel här
att jag kommer att piska upp enligt följande.

365
00:18:16,780 --> 00:18:22,850
Jag kommer att gå vidare och
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
Och jag kommer att gå vidare
och #include.

367
00:18:25,580 --> 00:18:29,030
>> Och jag kommer att spara
denna fil som buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Och jag kommer att gå vidare
och förklarar int main (void).

369
00:18:31,740 --> 00:18:34,186
Och sedan inne i det
Jag kommer att göra int i _ -

370
00:18:34,186 --> 00:18:36,435
Jag vill genomföra ett program
med en get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Detta är inte en funktion som existerar ännu.

373
00:18:40,770 --> 00:18:42,870
Så vi kommer att genomföra
det på bara ett ögonblick.

374
00:18:42,870 --> 00:18:45,541
Men vi kommer att se varför
det är sulky på första passage.

375
00:18:45,541 --> 00:18:47,290
Och när jag har blivit
en int från användaren,

376
00:18:47,290 --> 00:18:53,365
Jag kommer bara att skriva% i är en negativ
heltal, omvänt snedstreck, n, komma, i.

377
00:18:53,365 --> 00:18:55,240
Med andra ord, allt jag
vill att detta program att göra

378
00:18:55,240 --> 00:18:58,000
är att få en negativ int från
användaren och sedan skriva ut

379
00:18:58,000 --> 00:18:59,980
att den och den är en negativ int.

380
00:18:59,980 --> 00:19:02,080
>> Nu behöver jag för att genomföra denna funktion.

381
00:19:02,080 --> 00:19:05,740
Så senare i min fil, jag kommer att gå
framåt och förklara en funktion som kallas

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - och vi kommer
komma tillbaka till vad den linjen innebär återigen

383
00:19:10,670 --> 00:19:18,790
i en moment-- int n; do-- do
den following-- printf n är :.

384
00:19:18,790 --> 00:19:26,210
Och då kommer jag att göra n - get_int,
och göra detta samtidigt som n är större än 0.

385
00:19:26,210 --> 00:19:28,310
Och sedan återvända n ;.

386
00:19:28,310 --> 00:19:31,730
>> Så det finns en hel del som pågår i
detta men ingen som vi inte

387
00:19:31,730 --> 00:19:33,710
titta på förra veckan, åtminstone kortfattat.

388
00:19:33,710 --> 00:19:36,980
Så på linje 10 här jag har deklarerat en
funktion kallad get_negative_int,

389
00:19:36,980 --> 00:19:39,620
och jag har lagt (void), i
parentes, på grund av detta

390
00:19:39,620 --> 00:19:40,950
tar någon signal.

391
00:19:40,950 --> 00:19:42,910
Jag är inte passerar något
till denna funktion.

392
00:19:42,910 --> 00:19:44,690
Jag är bara att få något tillbaka från den.

393
00:19:44,690 --> 00:19:47,270
>> Och vad jag hoppas
få tillbaka är ett heltal.

394
00:19:47,270 --> 00:19:50,040
Det finns ingen datatyp i
C kallas negative_int.

395
00:19:50,040 --> 00:19:52,880
Det är bara int, så det kommer
att vara på oss att se till

396
00:19:52,880 --> 00:19:55,340
att det värde som faktiskt
returneras är inte bara en int

397
00:19:55,340 --> 00:19:56,380
men är också negativ.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 Jag förklara en variabel
kallas n och göra det av typen int.

399
00:20:02,150 --> 00:20:07,500
Och sedan i linje 13 till 18 jag
göra något medan något är sant.

400
00:20:07,500 --> 00:20:11,040
Jag går vidare och utskrift
N, kolon, och sedan ett mellanslag,

401
00:20:11,040 --> 00:20:12,800
som en uppmaning till användaren.

402
00:20:12,800 --> 00:20:16,410
>> Jag sedan ringer get_int och
lagring av dess så kallade returvärde

403
00:20:16,410 --> 00:20:18,130
i den variabeln n.

404
00:20:18,130 --> 00:20:22,600
Men jag kommer att fortsätta att göra
detta medan n är större än 0.

405
00:20:22,600 --> 00:20:27,960
Med andra ord, om användaren ger mig en
int och att antalet är större än 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positiv, jag ska
bara hålla reprompting användaren,

407
00:20:31,180 --> 00:20:37,160
hålla reprompting, genom att tvinga dem att
samarbeta och ge mig en negativ int.

408
00:20:37,160 --> 00:20:41,640
>> Och när n är faktiskt negative--
Antag att användaren slutligen typerna -50,

409
00:20:41,640 --> 00:20:46,710
då detta medan slingan är inte längre sant
eftersom -50 inte är större än 0.

410
00:20:46,710 --> 00:20:51,140
Så vi bryta sig ur det
loop logiskt och retur n.

411
00:20:51,140 --> 00:20:53,520
>> Men det finns en annan
jag måste göra.

412
00:20:53,520 --> 00:20:56,190
Och jag kan bara göra detta
genom att kopiera och klistra in

413
00:20:56,190 --> 00:20:58,540
en kodrad på toppen av filen.

414
00:20:58,540 --> 00:21:01,630
Jag måste lära klang,
eller lovar att klang,

415
00:21:01,630 --> 00:21:04,630
uttryckligen att jag kommer,
faktiskt gå och genomföra

416
00:21:04,630 --> 00:21:06,020
denna funktion get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Det kan bara vara lägre i filen.

418
00:21:07,674 --> 00:21:09,840
Återigen, påminna om att klang
läser saker topp till botten,

419
00:21:09,840 --> 00:21:12,330
från vänster till höger, så kan du inte
anropa en funktion om klang

420
00:21:12,330 --> 00:21:15,330
inte vet att det kommer att existera.

421
00:21:15,330 --> 00:21:18,430
>> Nu, tyvärr, det här programmet,
som några av er kanske har märkt,

422
00:21:18,430 --> 00:21:19,590
redan är paraplyvagn.

423
00:21:19,590 --> 00:21:21,400
Låt mig gå vidare och göra buggy3.

424
00:21:21,400 --> 00:21:26,904
Det samman, så mitt problem är nu inte
ett syntaxfel, som en text fel,

425
00:21:26,904 --> 00:21:29,570
det är faktiskt kommer att bli en logisk
fel som jag har medvetet

426
00:21:29,570 --> 00:21:32,450
gjort som en möjlighet att
stega igenom vad som händer.

427
00:21:32,450 --> 00:21:35,540
>> Jag kommer att gå vidare
nu och kör buggy3.

428
00:21:35,540 --> 00:21:37,490
Och jag kommer att gå
framåt och inte samarbeta.

429
00:21:37,490 --> 00:21:39,494
Jag kommer att ge den nummer ett.

430
00:21:39,494 --> 00:21:41,410
Det tyckte inte om det, så
det föranledde mig igen.

431
00:21:41,410 --> 00:21:42,147
>> Vad sägs om två?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Ingen av de arbetar.

435
00:21:44,740 --> 00:21:46,890
Hur ca -50?

436
00:21:46,890 --> 00:21:48,560
Och programmet verkar fungera.

437
00:21:48,560 --> 00:21:49,970
>> Låt mig prova en gång mer.

438
00:21:49,970 --> 00:21:53,400
Låt mig försöka -1, verkar fungera.

439
00:21:53,400 --> 00:21:56,380
Låt mig försöka -2, verkar fungera.

440
00:21:56,380 --> 00:21:59,640
Låt mig försöka 0.

441
00:21:59,640 --> 00:22:01,684
Huh, det är fel.

442
00:22:01,684 --> 00:22:03,350
Nu, vi är lite pedantisk här.

443
00:22:03,350 --> 00:22:07,090
Men det är faktiskt så att 0
är varken positiv eller negativ.

444
00:22:07,090 --> 00:22:11,150
Och så det faktum att mitt program är
att säga att 0 är en negativt heltal,

445
00:22:11,150 --> 00:22:12,820
det är inte tekniskt korrekt.

446
00:22:12,820 --> 00:22:15,180
>> Nu, varför är det att göra detta?

447
00:22:15,180 --> 00:22:16,270
Väl, kan det vara uppenbart.

448
00:22:16,270 --> 00:22:18,110
Och faktiskt, är programmet
tänkt att vara ganska enkel

449
00:22:18,110 --> 00:22:19,670
så vi har något att utforska.

450
00:22:19,670 --> 00:22:25,870
>> Men låt oss införa en tredje felsökning
teknik som här kallas debug50.

451
00:22:25,870 --> 00:22:27,750
Så det här är ett program
att vi bara har skapat

452
00:22:27,750 --> 00:22:30,770
Detta år kallas debug50
som gör att du

453
00:22:30,770 --> 00:22:34,130
att använda vad som kallas en inbyggd
grafisk debugger i CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Och en debugger är bara ett program som
generellt kan du köra programmet

455
00:22:38,400 --> 00:22:44,050
men steg för steg för steg, rad
av rad för rad, pausa, peta

456
00:22:44,050 --> 00:22:47,626
runt, titta på variabler så att
programmet inte bara blåsa förbi dig

457
00:22:47,626 --> 00:22:49,750
och snabbt skriva ut något
eller inte skriva ut något.

458
00:22:49,750 --> 00:22:53,250
Det ger dig en möjlighet, vid
mänsklig hastighet, för att interagera med det.

459
00:22:53,250 --> 00:22:55,470
>> Och att göra detta, du
helt enkelt göra följande.

460
00:22:55,470 --> 00:22:58,479
Efter att sammanställa koden,
som jag redan gjort, buggy3,

461
00:22:58,479 --> 00:23:00,020
du gå vidare och köra debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Så mycket som help50 har du kör
help50 och sedan kommandot,

464
00:23:06,760 --> 00:23:10,120
debug50 har du kör debug50 och
sedan namnet på kommandot.

465
00:23:10,120 --> 00:23:14,440
>> Nu se vad som händer på skärmen,
på den högra sidan i synnerhet.

466
00:23:14,440 --> 00:23:19,400
När jag slog Kör alla
plötsligt denna högra panelen

467
00:23:19,400 --> 00:23:20,419
öppnar upp på skärmen.

468
00:23:20,419 --> 00:23:22,210
Och det finns en hel del att gå
på vid första anblicken.

469
00:23:22,210 --> 00:23:25,110
Men det är inte alltför
mycket att oroa sig ännu.

470
00:23:25,110 --> 00:23:28,570
>> Detta visar mig allt
som pågår inne i mitt program

471
00:23:28,570 --> 00:23:31,130
just nu och via dessa
knappar uppe sedan

472
00:23:31,130 --> 00:23:35,910
tillåter mig att gå igenom min kod
ultimately steg för steg för steg.

473
00:23:35,910 --> 00:23:37,140
Men inte ännu.

474
00:23:37,140 --> 00:23:38,060
Lägg märke till vad som händer.

475
00:23:38,060 --> 00:23:40,600
På min terminalfönster
Jag blir tillfrågad om n.

476
00:23:40,600 --> 00:23:44,560
Och jag kommer att gå vidare och
samarbeta denna gång och skriv in -1.

477
00:23:44,560 --> 00:23:48,770
Och om än lite kryptiskt, -1
är ett negativt heltal, som förväntat.

478
00:23:48,770 --> 00:23:52,020
>> Och sedan barn avslutades med
status 0 GDBserver spännande.

479
00:23:52,020 --> 00:23:55,180
GDB, gnu debugger, är namnet
av den underliggande mjukvaran

480
00:23:55,180 --> 00:23:56,620
som implementerar detta debugger.

481
00:23:56,620 --> 00:24:00,500
Men allt detta egentligen innebär, debugger
gick bort eftersom mitt program sluta

482
00:24:00,500 --> 00:24:01,710
och allt var bra.

483
00:24:01,710 --> 00:24:06,020
Om jag vill verkligen felsöka mitt program,
Jag måste preemptively berätta debug50,

484
00:24:06,020 --> 00:24:08,920
där jag vill börja
stega igenom min kod?

485
00:24:08,920 --> 00:24:11,750
>> Och kanske det enklaste sättet
att göra det är som följer.

486
00:24:11,750 --> 00:24:15,300
Om jag svävar över
ränna av min redaktör här,

487
00:24:15,300 --> 00:24:19,090
så egentligen bara i sidofältet här,
till vänster om radnumret,

488
00:24:19,090 --> 00:24:21,870
Lägg märke till att om jag bara klicka
en gång satte jag en liten röd prick.

489
00:24:21,870 --> 00:24:24,460
Och den lilla röda pricken,
som en stoppskylt, betyder, hej,

490
00:24:24,460 --> 00:24:29,430
debug50, pausa exekvering av min kod
direkt när jag kör det här programmet.

491
00:24:29,430 --> 00:24:30,260
>> Så låt oss göra det.

492
00:24:30,260 --> 00:24:37,340
Låt mig gå vidare och köra mitt program
igen med debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Och nu, varsel, något
annorlunda har hänt.

494
00:24:40,110 --> 00:24:42,440
Jag är inte uppmanas
men i mitt terminalfönster

495
00:24:42,440 --> 00:24:45,430
för något, eftersom jag har inte
fått det ännu i mitt program.

496
00:24:45,430 --> 00:24:47,950
Lägg märke till att på ledningen 8
som nu är markerad,

497
00:24:47,950 --> 00:24:51,720
och det finns en liten pil på
vänstra säger, är du pausade här.

498
00:24:51,720 --> 00:24:55,030
Denna kodrad, linje
8, ännu inte har verkställt.

499
00:24:55,030 --> 00:24:58,940
>> Och vad är nyfiken, om jag ser
hit på höger sida,

500
00:24:58,940 --> 00:25:03,530
märker att jag är en lokal
variabel, lokalt i den meningen

501
00:25:03,530 --> 00:25:05,450
att det är inuti den aktuella funktionen.

502
00:25:05,450 --> 00:25:08,920
Och dess värde, till synes som standard,
och typ av enkelt, är 0.

503
00:25:08,920 --> 00:25:10,260
Men jag inte skriver 0.

504
00:25:10,260 --> 00:25:13,410
Det råkar vara dess
Standardvärdet för tillfället.

505
00:25:13,410 --> 00:25:15,490
>> Så låt mig gå vidare och göra det nu.

506
00:25:15,490 --> 00:25:18,680
Låt mig gå vidare och på
upp till höger här, jag är

507
00:25:18,680 --> 00:25:20,970
kommer att gå vidare och
klicka på denna första ikon som

508
00:25:20,970 --> 00:25:25,360
betyder steg över vilket betyder inte hoppa
det men steg över den här kodraden,

509
00:25:25,360 --> 00:25:27,770
verkställer det på vägen.

510
00:25:27,770 --> 00:25:30,710
>> Och nu, märker min
prompt har just ändrats.

511
00:25:30,710 --> 00:25:31,380
Varför är det så?

512
00:25:31,380 --> 00:25:33,639
Jag har sagt debug50,
köra denna kodrad.

513
00:25:33,639 --> 00:25:34,930
Vad betyder den här kodraden göra?

514
00:25:34,930 --> 00:25:35,960
Frågar mig för en int.

515
00:25:35,960 --> 00:25:36,460
OK.

516
00:25:36,460 --> 00:25:37,400
Låt mig samarbeta.

517
00:25:37,400 --> 00:25:41,340
Låt mig gå vidare nu och skriver -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Och nu märker vad som har förändrats.

519
00:25:42,920 --> 00:25:46,060
På den högra sidan,
min lokala variabeln i

520
00:25:46,060 --> 00:25:48,200
indikeras som -1 nu.

521
00:25:48,200 --> 00:25:49,810
Och det är fortfarande av typen int.

522
00:25:49,810 --> 00:25:53,102
>> Och varsel, även min så kallade
call stack, där jag paus?

523
00:25:53,102 --> 00:25:54,810
Vi kommer att prata mer om
detta i framtiden.

524
00:25:54,810 --> 00:25:58,620
Men anropsstacken hänvisar bara till vad
funktioner finns för närvarande i rörelse.

525
00:25:58,620 --> 00:26:00,040
Just nu är det bara huvud.

526
00:26:00,040 --> 00:26:03,590
Och just nu den enda lokala
variabel är i med ett värde på ett.

527
00:26:03,590 --> 00:26:09,840
>> Och när jag steg slutligen över denna linje
här, med samma ikon uppe till höger,

528
00:26:09,840 --> 00:26:11,410
-1 Är ett negativt heltal.

529
00:26:11,410 --> 00:26:13,580
Nu är det paus över det lockiga stag.

530
00:26:13,580 --> 00:26:14,740
Låt oss låt den göra sin sak.

531
00:26:14,740 --> 00:26:17,300
Jag steg över den linjen, och voila.

532
00:26:17,300 --> 00:26:20,240
>> Så inte alla som fruktansvärt
upplysande ännu,

533
00:26:20,240 --> 00:26:23,550
men det lät mig paus
och tänka igenom logiskt

534
00:26:23,550 --> 00:26:24,870
vad detta program gör.

535
00:26:24,870 --> 00:26:26,890
Men det var inte den felaktiga fallet.

536
00:26:26,890 --> 00:26:28,510
Låt oss göra detta igen på följande sätt.

537
00:26:28,510 --> 00:26:31,340
>> Jag kommer att lämna den brytpunkt
på rad 8 med den röda pricken.

538
00:26:31,340 --> 00:26:32,830
Jag kommer att köra debug50.

539
00:26:32,830 --> 00:26:34,400
Det är automatiskt paus här.

540
00:26:34,400 --> 00:26:37,660
Men den här gången, i stället för
kliva över denna linje,

541
00:26:37,660 --> 00:26:42,290
Låt mig faktiskt gå inuti
get_negative_int och räkna ut,

542
00:26:42,290 --> 00:26:45,530
varför är det att acceptera 0 som ett giltigt svar?

543
00:26:45,530 --> 00:26:47,990
>> Så istället för att klicka Step Over.

544
00:26:47,990 --> 00:26:50,630
Jag kommer att gå vidare
och klicka på Step Into.

545
00:26:50,630 --> 00:26:54,030
Och lägg märke till att linjen 8 som är
nu markerat nu plötsligt

546
00:26:54,030 --> 00:26:56,900
blir linje 17.

547
00:26:56,900 --> 00:26:59,947
>> Nu är det inte så debugger
har hoppat linjerna 14 och 15 och 16.

548
00:26:59,947 --> 00:27:01,780
Det är bara det finns inget
att visa dig där.

549
00:27:01,780 --> 00:27:04,050
De är bara deklarera variabler,
och sedan finns det ord Gör

550
00:27:04,050 --> 00:27:05,390
och sedan en öppen klammerparentes.

551
00:27:05,390 --> 00:27:09,227
Den enda fungerande linje som är
saftig är verkligen detta här, 17.

552
00:27:09,227 --> 00:27:11,060
Och det är där vi har
pausas automatiskt.

553
00:27:11,060 --> 00:27:13,870
>> Så printf ( "n.is:") ;, så
som inte har hänt ännu.

554
00:27:13,870 --> 00:27:18,250
Så låt oss gå vidare och klicka på Step Over.

555
00:27:18,250 --> 00:27:20,326
Nu är min snabb, faktiskt,
ändras till ( "n är:").

556
00:27:20,326 --> 00:27:22,450
Nu get_int, jag tänker inte
bry kliva in,

557
00:27:22,450 --> 00:27:24,750
eftersom denna funktion var
tillverkad av CS50 i biblioteket.

558
00:27:24,750 --> 00:27:25,750
Det är antagligen korrekt.

559
00:27:25,750 --> 00:27:28,440
>> Så jag kommer att gå vidare och
sorts samarbeta genom att ge den

560
00:27:28,440 --> 00:27:30,590
en int, men inte en negativ int.

561
00:27:30,590 --> 00:27:32,870
Så låt mig gå vidare och slå 0.

562
00:27:32,870 --> 00:27:39,460
Och nu vad som händer här
när jag kommer ner till linje 21?

563
00:27:39,460 --> 00:27:40,890
Jag har inte upprepas igen.

564
00:27:40,890 --> 00:27:43,320
Jag verkar inte ha fastnat i denna slinga.

565
00:27:43,320 --> 00:27:45,990
Med andra ord, denna gula
baren inte hålla gå runt,

566
00:27:45,990 --> 00:27:47,130
och runt, och runt.

567
00:27:47,130 --> 00:27:48,340
>> Nu, varför är det?

568
00:27:48,340 --> 00:27:49,920
Tja, n, vad är N just nu?

569
00:27:49,920 --> 00:27:53,280
Jag kan titta på den lokala
variabler i debugger.

570
00:27:53,280 --> 00:27:53,816
n är 0.

571
00:27:53,816 --> 00:27:55,190
Okej, vad som var mitt tillstånd?

572
00:27:55,190 --> 00:27:58,700
>> 20-- linje 20 är, tja,
0 är större än 0.

573
00:27:58,700 --> 00:27:59,500
Det är inte sant.

574
00:27:59,500 --> 00:28:01,020
0 inte är större än 0.

575
00:28:01,020 --> 00:28:02,820
Och så jag bröt ut ur detta.

576
00:28:02,820 --> 00:28:06,370
>> Och så det är därför på rad
21, om jag faktiskt fortsätter,

577
00:28:06,370 --> 00:28:10,370
Jag kommer att återvända 0, även
men jag borde ha förkastat 0

578
00:28:10,370 --> 00:28:12,484
som egentligen inte är negativt.

579
00:28:12,484 --> 00:28:14,650
Så nu gör jag egentligen inte ens
bryr sig om debugger.

580
00:28:14,650 --> 00:28:16,900
Fick det, jag behöver inte
vet vad mer som pågår.

581
00:28:16,900 --> 00:28:19,233
>> Så jag kommer att gå vidare och
klickar du bara på play-knappen,

582
00:28:19,233 --> 00:28:20,240
och låt detta avslut.

583
00:28:20,240 --> 00:28:23,440
Nu har jag insett att min
felet är tydligen på linje 20.

584
00:28:23,440 --> 00:28:25,160
Det är min logiskt fel.

585
00:28:25,160 --> 00:28:28,100
>> Och så vad vill jag
att göra för att ändra på detta?

586
00:28:28,100 --> 00:28:32,500
Om problemet är att jag inte
fånga 0, det är bara ett logiskt fel.

587
00:28:32,500 --> 00:28:35,910
Och jag kan säga när n är
större än eller lika med 0,

588
00:28:35,910 --> 00:28:38,330
hålla uppmanar användaren och om igen.

589
00:28:38,330 --> 00:28:41,050
>> Så, återigen, enkelt misstag, kanske
även uppenbart när du såg mig

590
00:28:41,050 --> 00:28:42,410
skriva det bara några minuter sedan.

591
00:28:42,410 --> 00:28:44,570
Men takeaway här
är att med debug 50,

592
00:28:44,570 --> 00:28:46,850
och med felsökning
programvara mer allmänt,

593
00:28:46,850 --> 00:28:51,370
du har denna nyfunna kraft till
gå igenom din egen kod, ser

594
00:28:51,370 --> 00:28:55,590
via den högra panelen vad
dina variabler värden.

595
00:28:55,590 --> 00:28:57,700
Så att du inte nödvändigtvis
måste använda något

596
00:28:57,700 --> 00:29:00,630
som du eprintf att skriva ut dessa värden.

597
00:29:00,630 --> 00:29:04,430
Du kan faktiskt se dem
visuellt på skärmen.

598
00:29:04,430 --> 00:29:08,920
>> Nu, utöver detta, är det värt att notera
att det finns en annan teknik som är

599
00:29:08,920 --> 00:29:09,890
faktiskt super vanligt.

600
00:29:09,890 --> 00:29:13,120
Och kanske du undrar varför denna lilla
killen här har suttit på scenen.

601
00:29:13,120 --> 00:29:16,490
Så det finns denna teknik i allmänhet
känd som gummi anka felsökning,

602
00:29:16,490 --> 00:29:18,786
som verkligen är bara en
bevis på det faktum

603
00:29:18,786 --> 00:29:20,660
som ofta när programmerare
skriver kod,

604
00:29:20,660 --> 00:29:22,650
de är inte nödvändigtvis
samarbeta med andra,

605
00:29:22,650 --> 00:29:24,030
eller arbetar i en delad miljö.

606
00:29:24,030 --> 00:29:25,050
>> De är typ av hemma.

607
00:29:25,050 --> 00:29:25,910
Kanske det är sent på natten.

608
00:29:25,910 --> 00:29:28,190
De försöker figur
in några fel i sin kod.

609
00:29:28,190 --> 00:29:29,330
Och de är bara inte ser det.

610
00:29:29,330 --> 00:29:30,329
>> Och det finns ingen rumskompis.

611
00:29:30,329 --> 00:29:31,250
Det finns ingen TF.

612
00:29:31,250 --> 00:29:32,680
Det finns ingen CA runt.

613
00:29:32,680 --> 00:29:36,440
Allt de har på sin hylla
är denna lilla plastanka.

614
00:29:36,440 --> 00:29:39,030
>> Och så gummi anka felsökning
är just denna inbjudan

615
00:29:39,030 --> 00:29:42,780
att tänka på något så dumt
eftersom detta som en verklig varelse,

616
00:29:42,780 --> 00:29:46,940
och faktiskt gå igenom koden
muntligt till detta livlösa objekt.

617
00:29:46,940 --> 00:29:49,230
Så, till exempel, om
detta är mitt exempel här--

618
00:29:49,230 --> 00:29:52,470
och påminna om att tidigare
problemet var detta,

619
00:29:52,470 --> 00:29:58,140
om jag tar bort den första raden av kod,
och jag gå vidare och göra buggy 0 igen,

620
00:29:58,140 --> 00:30:01,220
minns att jag hade dessa
felmeddelanden här.

621
00:30:01,220 --> 00:30:05,997
Så tanken här, löjligt om jag
känner just nu gör detta offentligt,

622
00:30:05,997 --> 00:30:06,580
är detta fel.

623
00:30:06,580 --> 00:30:10,910
>> OK, så mitt problem är att jag har
implicit deklarerade en biblioteksfunktion.

624
00:30:10,910 --> 00:30:12,610
Och att biblioteksfunktion är printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, förklara
påminner mig om prototyper.

626
00:30:15,290 --> 00:30:18,930
>> Det betyder att jag måste faktiskt
tala om för kompilatorn i förväg vad

627
00:30:18,930 --> 00:30:19,980
funktionen ser ut.

628
00:30:19,980 --> 00:30:20,930
Vänta en minut.

629
00:30:20,930 --> 00:30:23,580
Jag hade inte standard io.h.

630
00:30:23,580 --> 00:30:24,530
Tack så mycket.

631
00:30:24,530 --> 00:30:27,330
>> Så just denna process of-- du
behöver inte faktiskt ha en anka.

632
00:30:27,330 --> 00:30:29,819
Men denna idé Walking
själv via din egen kod

633
00:30:29,819 --> 00:30:31,610
så att du även höra
själv, så att du

634
00:30:31,610 --> 00:30:35,620
inse brister i den egna
anmärkningar, är i allmänhet idén.

635
00:30:35,620 --> 00:30:38,910
>> Och kanske mer logiskt, inte så
mycket tydligt, men mer delaktiga

636
00:30:38,910 --> 00:30:44,220
Exempelvis gjorde vi just i buggy 3.c,
du kanske gå själv genom det

637
00:30:44,220 --> 00:30:45,310
som följer.

638
00:30:45,310 --> 00:30:49,190
Så okej, gummi
ducky, DDB, om man så vill.

639
00:30:49,190 --> 00:30:52,350
Här har vi i min huvudsakliga funktion,
Jag ringer få negativ int.

640
00:30:52,350 --> 00:30:54,660
>> Och jag får returvärdet.

641
00:30:54,660 --> 00:31:00,410
Jag lagra den på vänster sida
på rad 8 i en variabel som kallas i.

642
00:31:00,410 --> 00:31:02,380
OK, men vänta, hur gjorde
att få detta värde?

643
00:31:02,380 --> 00:31:04,130
Låt mig titta på funktionen i linje 12.

644
00:31:04,130 --> 00:31:05,760
>> I linje 12, har vi negativ int.

645
00:31:05,760 --> 00:31:08,190
Inte ta några insatsvaror,
kommer tillbaka en int, OK.

646
00:31:08,190 --> 00:31:10,929
Jag försäkrar på linje 14 en variabel n.

647
00:31:10,929 --> 00:31:12,220
Det kommer att lagra ett heltal.

648
00:31:12,220 --> 00:31:13,760
Det är vad jag vill ha.

649
00:31:13,760 --> 00:31:18,480
>> Så gör följande medan n är-- låt
mig ångra vad fix jag redan gjort.

650
00:31:18,480 --> 00:31:22,710
Så medan n är större än
0, skriva ut N, OK.

651
00:31:22,710 --> 00:31:25,170
Och sedan ringa få int lagras i n.

652
00:31:25,170 --> 00:31:30,160
Och sedan kontrollera om n är 0,
n är inte-- det är.

653
00:31:30,160 --> 00:31:31,910
Så, återigen, behöver du inte
behöver själva anka.

654
00:31:31,910 --> 00:31:35,650
Men bara gå själv genom
koden som en intellektuell övning

655
00:31:35,650 --> 00:31:37,720
kommer ofta hjälpa dig
inse vad som händer,

656
00:31:37,720 --> 00:31:41,170
till skillnad från att bara göra något
så här, stirrar på skärmen,

657
00:31:41,170 --> 00:31:43,720
och talar inte dig själv genom
den, vilket ärligt inte är

658
00:31:43,720 --> 00:31:46,270
nästan som en effektiv teknik.

659
00:31:46,270 --> 00:31:48,620
Så där har ni det, en
antal olika tekniker

660
00:31:48,620 --> 00:31:52,102
för att faktiskt felsöka din kod
och hitta fel, som alla

661
00:31:52,102 --> 00:31:54,810
bör vara verktyg i din verktygslåda
så att du inte sent på kvällen,

662
00:31:54,810 --> 00:31:57,660
speciellt, du är i matsalen
hallar, eller på kontorstid,

663
00:31:57,660 --> 00:32:00,368
banka huvudet mot
vägg, försöker att lösa några problem.

664
00:32:00,368 --> 00:32:02,020
Inse att det finns mjukvaruverktyg.

665
00:32:02,020 --> 00:32:03,720
Det finns gummianka verktyg.

666
00:32:03,720 --> 00:32:09,630
Och det finns en hel stab av
stödja väntar på att låna ut en hand.

667
00:32:09,630 --> 00:32:13,120
>> Så nu, ett ord om problemet
uppsättningar, och på vad vi hoppas dig

668
00:32:13,120 --> 00:32:15,620
få ut av dem, och hur
vi går om att utvärdera.

669
00:32:15,620 --> 00:32:17,680
Per kursens kursplan,
CS50: s problemsamlingar

670
00:32:17,680 --> 00:32:22,320
utvärderas på fyra primära axlar, så
att speak-- omfattning, korrekthet, design,

671
00:32:22,320 --> 00:32:23,060
och stil.

672
00:32:23,060 --> 00:32:25,910
Och omfattning hänvisar bara till hur mycket
av pjäsen har du biten av?

673
00:32:25,910 --> 00:32:28,080
Hur mycket av ett problem har du försökt?

674
00:32:28,080 --> 00:32:30,110
Vilken nivå av ansträngning
har du uttryck?

675
00:32:30,110 --> 00:32:35,750
>> Korrektheten är, fungerar programmet som
det är tänkt att per CS50 specifikation

676
00:32:35,750 --> 00:32:38,640
när du ger vissa insatsvaror
eller vissa utgångar komma tillbaka?

677
00:32:38,640 --> 00:32:41,130
Design är den mest subjektiva av dem.

678
00:32:41,130 --> 00:32:43,360
Och det är den som kommer
ta längst tid att lära sig

679
00:32:43,360 --> 00:32:47,220
och den längsta att undervisa i
såvitt det kokar ner till,

680
00:32:47,220 --> 00:32:49,530
hur välskriven är koden?

681
00:32:49,530 --> 00:32:52,920
>> Det är en sak att bara skriva ut rätt
utgångar eller returnera de rätta värdena.

682
00:32:52,920 --> 00:32:55,400
Men gör du det som
effektivt som möjligt?

683
00:32:55,400 --> 00:32:58,210
Gör du det klyftan
och erövra, eller binär

684
00:32:58,210 --> 00:33:01,500
sökning som vi snart kommer att se att vi gjorde
två veckor sedan med telefonboken?

685
00:33:01,500 --> 00:33:04,670
Finns det bättre sätt att lösa
problem än du redan har här?

686
00:33:04,670 --> 00:33:06,380
Det är en möjlighet för bättre design.

687
00:33:06,380 --> 00:33:08,530
>> Och sedan style-- hur
ganska är koden?

688
00:33:08,530 --> 00:33:12,370
Du kommer att märka att jag är ganska
särskilt om indrag min kod,

689
00:33:12,370 --> 00:33:15,300
och se till att mina variabler
är rimligt namnges. n,

690
00:33:15,300 --> 00:33:19,660
medan korta, är ett bra namn för en
nummer, i för en räkning heltal,

691
00:33:19,660 --> 00:33:20,727
s för en sträng.

692
00:33:20,727 --> 00:33:22,560
Och vi kan ha längre
variabelnamn stil.

693
00:33:22,560 --> 00:33:25,500
Style är hur bra
gör din kod ut?

694
00:33:25,500 --> 00:33:26,600
Och hur läsbar är det?

695
00:33:26,600 --> 00:33:29,650
>> Och över tiden, vad dina terapi
och TF kommer att göra under

696
00:33:29,650 --> 00:33:31,870
är att förse dig med det
typ av kvalitativ feedback

697
00:33:31,870 --> 00:33:34,330
så att du får bättre
på dessa olika aspekter.

698
00:33:34,330 --> 00:33:37,510
Och i termer av hur vi
utvärdera var och en av dessa axlar,

699
00:33:37,510 --> 00:33:40,080
det är typiskt med mycket få
hinkar så att ni, i allmänhet,

700
00:33:40,080 --> 00:33:41,680
få en känsla för hur väl du gör.

701
00:33:41,680 --> 00:33:45,680
Och faktiskt, om du får en poäng på
helst av de som axes-- korrekthet, designen

702
00:33:45,680 --> 00:33:49,659
och stil especially-- det numret
kommer i allmänhet att vara mellan 1 och 5.

703
00:33:49,659 --> 00:33:52,450
Och, bokstavligen, om du får
3: s i början av terminen,

704
00:33:52,450 --> 00:33:53,977
detta är en mycket bra sak.

705
00:33:53,977 --> 00:33:55,810
Det innebär att det fortfarande
plats för förbättring,

706
00:33:55,810 --> 00:33:58,490
som du skulle önska i
ta en klass för första gången.

707
00:33:58,490 --> 00:34:01,820
Det finns förhoppningsvis några bit av taket
till vilken du strävar efter att nå.

708
00:34:01,820 --> 00:34:03,970
Och så får 3s på
de tidigaste bitar,

709
00:34:03,970 --> 00:34:06,550
om inte några 2: s och 4: s,
är verkligen en bra sak.

710
00:34:06,550 --> 00:34:08,880
Det är väl inom räckhåll,
väl inom förväntningarna.

711
00:34:08,880 --> 00:34:11,421
>> Och om ditt sinne är racing, vänta
en minut, tre av fem.

712
00:34:11,421 --> 00:34:12,620
Det är verkligen en 6 av 10.

713
00:34:12,620 --> 00:34:13,560
Det är 60%.

714
00:34:13,560 --> 00:34:14,830
Herregud, det är en F.

715
00:34:14,830 --> 00:34:15,870
>> Det är inte.

716
00:34:15,870 --> 00:34:17,600
Det är inte, i själva verket det.

717
00:34:17,600 --> 00:34:22,710
Snarare är det en möjlighet att förbättra
under loppet av terminen.

718
00:34:22,710 --> 00:34:25,580
Och om du får några
poors, dessa är en möjlighet

719
00:34:25,580 --> 00:34:29,199
att dra nytta av kontorstid,
förvisso sektioner och andra resurser.

720
00:34:29,199 --> 00:34:32,840
>> Bäst är en möjlighet, verkligen,
att vara stolt över hur långt du har

721
00:34:32,840 --> 00:34:34,520
komma under loppet av terminen.

722
00:34:34,520 --> 00:34:38,199
Så inser, om inget
annars, tre är bra.

723
00:34:38,199 --> 00:34:40,179
Och det ger utrymme för tillväxt över tiden.

724
00:34:40,179 --> 00:34:43,090
>> När det gäller hur dessa axlar är
viktade, realistiskt du

725
00:34:43,090 --> 00:34:46,745
kommer att tillbringa större delen av din tid att få
saker att arbeta, för att inte tala korrekt.

726
00:34:46,745 --> 00:34:49,120
Och så korrekthet tenderar att
viktas mest, såsom med

727
00:34:49,120 --> 00:34:51,360
denna multiplikativ faktor tre.

728
00:34:51,360 --> 00:34:54,659
Design är också viktigt, men
något som du inte nödvändigtvis

729
00:34:54,659 --> 00:34:58,220
spendera alla dessa timmar på
försöker få saker bara för att arbeta.

730
00:34:58,220 --> 00:35:00,019
>> Och så det viktade
lite mer lätt.

731
00:35:00,019 --> 00:35:01,560
Och sedan stil viktas minst.

732
00:35:01,560 --> 00:35:03,710
Även om det är mindre
viktigt i grunden,

733
00:35:03,710 --> 00:35:05,990
det är bara kanske det
enklaste sak att göra rätt,

734
00:35:05,990 --> 00:35:08,440
härma exemplen vi
göra i föreläsning och avsnitt,

735
00:35:08,440 --> 00:35:11,080
med saker fint
indragen, och kommenterade,

736
00:35:11,080 --> 00:35:14,320
och så vidare är bland det enklaste
saker att göra och få rätt.

737
00:35:14,320 --> 00:35:16,960
Så som sådan, inser
att de är punkter

738
00:35:16,960 --> 00:35:19,000
som är relativt lätt att greppa.

739
00:35:19,000 --> 00:35:22,360
>> Och nu ett ord på
this-- akademisk hederlighet.

740
00:35:22,360 --> 00:35:25,150
Så per kursens
kursplan, kommer du att se

741
00:35:25,150 --> 00:35:27,630
att kursen har en ganska
bit av språket kring detta.

742
00:35:27,630 --> 00:35:31,380
Och kursen tar upp frågan om
akademisk hederlighet ganska allvarligt.

743
00:35:31,380 --> 00:35:33,450
>> Vi har skillnaden,
på gott och ont,

744
00:35:33,450 --> 00:35:36,570
för att ha skickat varje år mer
studenter för disciplinära åtgärder

745
00:35:36,570 --> 00:35:39,670
än de flesta andra
naturligtvis att jag är medveten om.

746
00:35:39,670 --> 00:35:42,580
Detta är inte nödvändigtvis
indikativ för det faktum

747
00:35:42,580 --> 00:35:46,340
att CS studenter, eller CS50 studenter, är
något mindre ärlig än dina klasskamrater.

748
00:35:46,340 --> 00:35:49,090
Men det faktum att i detta
värld, elektroniskt, vi bara

749
00:35:49,090 --> 00:35:50,990
har teknisk
innebär att upptäcka detta.

750
00:35:50,990 --> 00:35:53,360
>> Det är viktigt för oss
rättvisa i hela klassen

751
00:35:53,360 --> 00:35:58,550
att vi gör upptäcker detta, och höja
frågan när vi ser saker.

752
00:35:58,550 --> 00:36:01,980
Och bara för att måla en bild, och verkligen
att hjälpa något sådant sjunka in,

753
00:36:01,980 --> 00:36:04,600
dessa är antalet
studenter under de senaste 10 åren

754
00:36:04,600 --> 00:36:07,610
som har varit inblandade i några
sådana frågor av akademisk hederlighet,

755
00:36:07,610 --> 00:36:10,990
med några 32 elever
från hösten 2015, vilket

756
00:36:10,990 --> 00:36:13,760
Det vill säga att vi tar
frågan på största allvar.

757
00:36:13,760 --> 00:36:18,380
Och slutligen, dessa siffror komponera,
mest nyligen, ca 3%, 4% eller så

758
00:36:18,380 --> 00:36:19,120
av klassen.

759
00:36:19,120 --> 00:36:25,220
>> Så för super majoriteten av studenter
det verkar som om linjer är klara.

760
00:36:25,220 --> 00:36:27,940
Men inte hålla detta i
sinne, särskilt sent

761
00:36:27,940 --> 00:36:32,080
på natten när kämpar med
någon lösning på ett problem som,

762
00:36:32,080 --> 00:36:34,830
att det finns mekanismer
för att få dig bättre

763
00:36:34,830 --> 00:36:37,870
stöd än du kanske
tror, ​​även vid denna timme.

764
00:36:37,870 --> 00:36:40,514
Inse att när vi tar emot
elevinlämningar korsar vi

765
00:36:40,514 --> 00:36:43,430
jämföra varje underkastelse i år
mot varje inlämning förra året,

766
00:36:43,430 --> 00:36:47,590
mot varje inlaga från 2007,
och sedan, titta på, liksom,

767
00:36:47,590 --> 00:36:49,931
kod lagringsplatser på nätet,
diskussionsforum, jobbsajter.

768
00:36:49,931 --> 00:36:51,806
Och vi nämner detta,
verkligen, allt på grund

769
00:36:51,806 --> 00:36:56,040
fullständig redovisning, att om
någon annan kan hitta det på nätet,

770
00:36:56,040 --> 00:36:57,880
säkert, så kan vi kursen.

771
00:36:57,880 --> 00:37:00,100
Men egentligen, anden
av kursen handlar om

772
00:37:00,100 --> 00:37:01,650
denna punkt i kursplanen.

773
00:37:01,650 --> 00:37:03,670
Det är egentligen bara vara rimlig.

774
00:37:03,670 --> 00:37:06,680
>> Och om vi var tvungna att utveckla det
med bara lite mer språk,

775
00:37:06,680 --> 00:37:09,770
inse att kärnan i alla
arbete som du skickar till denna kurs

776
00:37:09,770 --> 00:37:10,954
måste vara din egen.

777
00:37:10,954 --> 00:37:13,870
Men inom det, det finns säkert
möjligheter och uppmuntran,

778
00:37:13,870 --> 00:37:17,300
och pedagogiskt värde i att vända sig till
others-- själv, TF, den CA,

779
00:37:17,300 --> 00:37:20,760
TAS, och andra i klassen,
för stöd, för att inte tala vänner

780
00:37:20,760 --> 00:37:23,547
och rumskamrater som har studerat
CS och programmering innan.

781
00:37:23,547 --> 00:37:25,130
Och så finns det en ersättning för det.

782
00:37:25,130 --> 00:37:28,180
Och den allmänna tumregel
är this-- när ber om hjälp,

783
00:37:28,180 --> 00:37:31,470
Du kan visa din kod för andra,
men du kanske inte se deras.

784
00:37:31,470 --> 00:37:34,880
Så även om du är på kontorstid,
eller i D hallen, eller någon annanstans

785
00:37:34,880 --> 00:37:37,450
arbetar på någon bit set,
arbetar tillsammans med en vän, som

786
00:37:37,450 --> 00:37:40,160
är helt bra, på
slutet av dagen ditt arbete

787
00:37:40,160 --> 00:37:43,034
bör slutligen hör ihop
er respektive, och inte

788
00:37:43,034 --> 00:37:45,700
vara någon samarbetsinsats,
med undantag för den sista projekt där

789
00:37:45,700 --> 00:37:47,410
det är tillåtet och uppmuntras.

790
00:37:47,410 --> 00:37:49,830
>> Inse att om du är
kämpar med något

791
00:37:49,830 --> 00:37:52,520
och din vän bara händer
bli bättre på detta då du,

792
00:37:52,520 --> 00:37:55,130
eller bättre på det problemet än dig,
eller lite längre framåt än dig,

793
00:37:55,130 --> 00:37:57,330
det är helt rimligt att vända
till din vän och säga hej,

794
00:37:57,330 --> 00:38:00,480
Har du något emot att titta på min kod här,
hjälpa mig upptäcka vad mitt problem är?

795
00:38:00,480 --> 00:38:03,760
Och, förhoppningsvis, i
intresse av pedagogiskt värde

796
00:38:03,760 --> 00:38:07,040
att vän inte bara
säga, oh, gör detta, utan snarare,

797
00:38:07,040 --> 00:38:09,917
Vad saknar du på linje
6, eller något liknande?

798
00:38:09,917 --> 00:38:12,000
Men lösningen är inte
för vän bredvid dig

799
00:38:12,000 --> 00:38:15,617
att säga, oh, ja, här, låt mig dra
upp detta, och visa min lösning för dig.

800
00:38:15,617 --> 00:38:16,450
Så det är den linje.

801
00:38:16,450 --> 00:38:18,670
Du visar koden till
andra, men du får inte

802
00:38:18,670 --> 00:38:22,350
visa deras, under förutsättning att den andra
begränsningar i kursens kursplan.

803
00:38:22,350 --> 00:38:24,760
>> Så kom ihåg detta
så kallade ånger klausulen

804
00:38:24,760 --> 00:38:27,560
under loppet s planen också,
att om du begår någon handling som

805
00:38:27,560 --> 00:38:30,476
är inte rimligt, men ta det till
uppmärksamhet av kursens huvuden

806
00:38:30,476 --> 00:38:34,240
inom 72 timmar, kursen
får införa lokala påföljder som

807
00:38:34,240 --> 00:38:37,380
kan innefatta en otillfredsställande eller
IG för arbetet in.

808
00:38:37,380 --> 00:38:41,410
Men naturligtvis inte kommer att hänvisa
roll för ytterligare disciplinära åtgärder,

809
00:38:41,410 --> 00:38:43,010
utom i fall av upprepade handlingar.

810
00:38:43,010 --> 00:38:46,632
Med andra ord, om du gör några
dum, särskilt sent på kvällen, beslut

811
00:38:46,632 --> 00:38:49,340
att nästa morgon eller två dagar
senare, du vaknar upp och inser,

812
00:38:49,340 --> 00:38:50,870
Vad tänkte jag?

813
00:38:50,870 --> 00:38:53,890
Du gör i CS50 har ett utlopp
för fastställande av detta problem

814
00:38:53,890 --> 00:38:57,170
och äga upp till det, så att vi
kommer att möta dig halvvägs och ta itu

815
00:38:57,170 --> 00:39:01,500
med det i en fråga som är både
utbildning och värdefull för dig,

816
00:39:01,500 --> 00:39:04,200
men fortfarande bestraffande på något sätt.

817
00:39:04,200 --> 00:39:08,590
Och nu, för att ta udden av detta.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEOUPPSPELNING]

819
00:39:10,570 --> 00:39:13,540
>> [Musik spelar]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END SPELA]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN: Okej, vi är tillbaka.

823
00:40:00,490 --> 00:40:03,680
Och nu tittar vi på en av de
första av våra verkliga världen domäner

824
00:40:03,680 --> 00:40:08,720
i CS50, konsten att kryptografi,
konsten att skicka och ta emot

825
00:40:08,720 --> 00:40:11,840
hemliga meddelanden, krypterade
meddelanden om du vill,

826
00:40:11,840 --> 00:40:17,060
som endast kan tydas om du har
några viktig ingrediens att avsändaren har

827
00:40:17,060 --> 00:40:18,030
också.

828
00:40:18,030 --> 00:40:22,120
Så för att motivera detta vi tar
en titt på denna sak här,

829
00:40:22,120 --> 00:40:26,750
vilket är ett exempel på en
hemlig dekoder ring som

830
00:40:26,750 --> 00:40:34,042
kan användas för att räkna ut
vad ett hemligt meddelande faktiskt är.

831
00:40:34,042 --> 00:40:35,750
I själva verket tillbaka i
dag i skolan,

832
00:40:35,750 --> 00:40:38,787
Om du någonsin skickat hemliga meddelanden till
några vän eller någon krossa i klassen,

833
00:40:38,787 --> 00:40:40,620
du kanske har tänkt
du var smart

834
00:40:40,620 --> 00:40:46,530
av på papper förändras,
liknande, A till B, och B till C och C till D,

835
00:40:46,530 --> 00:40:47,590
och så vidare.

836
00:40:47,590 --> 00:40:50,300
Men du faktiskt kryptering
din information, även

837
00:40:50,300 --> 00:40:53,300
om det var en liten trivial, var inte
så svårt för läraren att inse,

838
00:40:53,300 --> 00:40:55,675
Tja, om du bara ändra
B till A och C till B,

839
00:40:55,675 --> 00:40:57,550
du faktiskt räkna ut
vad budskapet var

840
00:40:57,550 --> 00:40:59,700
men du var i kryptering information.

841
00:40:59,700 --> 00:41:03,420
>> Du bara göra det
enkelt mycket som Ralphie här

842
00:41:03,420 --> 00:41:07,934
i en berömd film som spelar
ganska mycket till leda varje vinter.

843
00:41:07,934 --> 00:41:08,600
[VIDEOUPPSPELNING]

844
00:41:08,600 --> 00:41:11,180
-vara Det känt att allt som
Ralph Parker är härmed

845
00:41:11,180 --> 00:41:14,070
utsett en medlem av den lilla
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
och är berättigad till alla de utmärkelser
och förmåner som uppträder därtill.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
kontrasignerat Pierre Andre, i bläck.

848
00:41:24,340 --> 00:41:27,160
Heder och förmåner,
redan vid nio års ålder.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [SKRIKANDE]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Kom igen.

853
00:41:34,250 --> 00:41:35,210
Låt oss gå vidare med det.

854
00:41:35,210 --> 00:41:39,530
Jag behöver inte all that jazz
om smugglare och pirater.

855
00:41:39,530 --> 00:41:41,660
>> -listen Morgon kväll för
den avslutande äventyr

856
00:41:41,660 --> 00:41:43,880
av svart piratskepp.

857
00:41:43,880 --> 00:41:46,650
Nu är det dags för
Annies hemliga meddelande

858
00:41:46,650 --> 00:41:49,840
för dig medlemmar av Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Kom ihåg, barn, endast medlemmar
Annie hemliga Circle

860
00:41:53,570 --> 00:41:56,140
kan avkoda Annies hemliga meddelande.

861
00:41:56,140 --> 00:42:00,340
>> Kom ihåg att Annie beroende på dig.

862
00:42:00,340 --> 00:42:02,880
Ställ dina stift till B2.

863
00:42:02,880 --> 00:42:05,230
Här är budskapet.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Jag Är i min första hemliga mötet.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> Pierre var i stark röst i kväll.

868
00:42:15,780 --> 00:42:19,000
Jag kan tala om att kvällens
meddelande var verkligen viktigt.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, som är ett meddelande
från Annie själv.

870
00:42:22,694 --> 00:42:23,860
Kom ihåg att inte berätta för någon.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekunder senare, jag är den enda
rum i huset där en pojke på nio

873
00:42:32,930 --> 00:42:37,040
kunde sitta i avskildhet och avkoda.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Jag gick till nästa, E.

876
00:42:42,360 --> 00:42:44,520
>> Det första ordet är vara.

877
00:42:44,520 --> 00:42:49,032
S, var det komma lättare nu, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -Oh, Kom igen, Ralphie, jag måste gå!

879
00:42:51,733 --> 00:42:53,688
>> -Jag Vara rätt ner, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee vina!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, se att-- vara säker på vad?

883
00:43:04,060 --> 00:43:05,970
Vad var Little Orphan
Annie försöker säga?

884
00:43:05,970 --> 00:43:07,264
Var noga med vad?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy har fått
gå, kommer ni att komma ut?

886
00:43:09,634 --> 00:43:10,480
>> -Alla Rätt, Ma!

887
00:43:10,480 --> 00:43:12,880
Jag kommer att vara rätt ut!

888
00:43:12,880 --> 00:43:14,550
>> -Jag Började bli närmare nu.

889
00:43:14,550 --> 00:43:16,620
Spänningen var hemskt.

890
00:43:16,620 --> 00:43:17,720
Vad var det?

891
00:43:17,720 --> 00:43:20,170
Öde planet
kan hänga i balans.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andys måste gå!

894
00:43:23,170 --> 00:43:26,890
>> -Jag Vara rätt ut, för crying out loud!

895
00:43:26,890 --> 00:43:32,680
>> -Nästan Där, mina fingrar flög, mitt sinne
var en stålfälla, vibrerat varje por.

896
00:43:32,680 --> 00:43:37,198
Det var nästan klar, ja, ja, ja.

897
00:43:37,198 --> 00:43:43,091
>> -vara Noga med att dricka din Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
En crummy kommersiell?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Jävel.

903
00:43:54,227 --> 00:43:54,810
[END SPELA]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN: OK, så
Det var en mycket lång väg

905
00:43:57,390 --> 00:44:00,660
att införa kryptografi,
och även Ovaltine.

906
00:44:00,660 --> 00:44:04,470
I själva verket, från denna gamla annons
här, varför är Ovaltine så bra?

907
00:44:04,470 --> 00:44:09,470
Det är en koncentrerad utvinning av mogna
kornmalt, ren krämig komjölk,

908
00:44:09,470 --> 00:44:14,360
och speciellt beredd kakao, tillsammans
med naturliga fosfatider och vitaminer.

909
00:44:14,360 --> 00:44:18,240
Det är vidare berikade med
extra vitaminer B och D, yum.

910
00:44:18,240 --> 00:44:21,600
Och du kan fortfarande få det, tydligen,
på Amazon, som vi gjorde här.

911
00:44:21,600 --> 00:44:24,810
>> Men motivationen här var att
introducera kryptografi, särskilt

912
00:44:24,810 --> 00:44:28,340
en typ av kryptering känd
som hemlig nyckel kryptering.

913
00:44:28,340 --> 00:44:34,284
Och som namnet antyder, hela
säkerhet av en hemlig nyckel krypteringssystem,

914
00:44:34,284 --> 00:44:36,200
om man så vill, en metod
bara klättra

915
00:44:36,200 --> 00:44:40,960
information mellan två personer, är att
endast avsändaren och endast mottagaren

916
00:44:40,960 --> 00:44:46,980
veta en hemlighet key-- visst värde, en del
hemlig fras, något hemligt nummer, som

917
00:44:46,980 --> 00:44:50,660
tillåter dem att både kryptera
och dekryptera information.

918
00:44:50,660 --> 00:44:53,470
Och kryptografi, egentligen,
är just detta från vecka 0.

919
00:44:53,470 --> 00:44:56,715
>> Det är ett problem där det finns ingångar,
liksom själva meddelande på engelska

920
00:44:56,715 --> 00:44:59,340
eller vilket språk som du
vill skicka till någon i klassen,

921
00:44:59,340 --> 00:45:00,580
eller över Internet.

922
00:45:00,580 --> 00:45:03,840
Det finns en viss utgång, som kommer
att vara den kodade meddelande som du

923
00:45:03,840 --> 00:45:05,250
vill att mottagaren ska få.

924
00:45:05,250 --> 00:45:07,405
Och även om någon i
mitt emot det också,

925
00:45:07,405 --> 00:45:09,780
du inte vill att de ska
nödvändigtvis kunna dekryptera den,

926
00:45:09,780 --> 00:45:12,840
eftersom insidan av denna
svart låda, eller algoritm,

927
00:45:12,840 --> 00:45:17,650
är någon mekanism, några steg för steg
instruktioner för att ta denna ingång

928
00:45:17,650 --> 00:45:20,710
och omvandla den till den
utgång, i förhoppningsvis ett säkert sätt.

929
00:45:20,710 --> 00:45:23,640
>> Och i själva verket, det finns en viss
vokabulär i denna värld som följer.

930
00:45:23,640 --> 00:45:26,100
Klartext är ordet en
datavetare skulle

931
00:45:26,100 --> 00:45:28,449
använda för att beskriva den ingående
meddelande, som det engelska

932
00:45:28,449 --> 00:45:31,240
eller vilket språk du faktiskt
vill skicka till någon annan människa.

933
00:45:31,240 --> 00:45:35,450
Och då chiffertexten är scramble
till chiffrerade, eller krypterad,

934
00:45:35,450 --> 00:45:36,520
version därav.

935
00:45:36,520 --> 00:45:38,750
>> Men det finns en annan ingrediens här.

936
00:45:38,750 --> 00:45:43,200
Det finns en annan ingång till
hemlig nyckel kryptografi.

937
00:45:43,200 --> 00:45:45,200
Och det är själva nyckeln,
vilket är, i allmänhet,

938
00:45:45,200 --> 00:45:48,930
som vi ser, ett nummer eller
brev eller ord, oavsett

939
00:45:48,930 --> 00:45:51,980
algoritmen är det faktiskt förväntar sig.

940
00:45:51,980 --> 00:45:53,870
>> Och hur gör du dekryptera informationen?

941
00:45:53,870 --> 00:45:55,110
How do you avkoda det?

942
00:45:55,110 --> 00:45:57,950
Tja, du bara vända
utgångar och ingångar.

943
00:45:57,950 --> 00:46:00,900
>> Med andra ord, när någon
emot krypterade meddelandet,

944
00:46:00,900 --> 00:46:03,740
han eller hon har helt enkelt
att veta att samma nyckel.

945
00:46:03,740 --> 00:46:05,700
De har fått chiffertexten.

946
00:46:05,700 --> 00:46:09,530
Och genom att koppla dessa två
indata i kryptosystemet,

947
00:46:09,530 --> 00:46:14,260
algoritmen, denna svarta låda, ut
skulle komma den ursprungliga klartext.

948
00:46:14,260 --> 00:46:17,830
Och så det är mycket hög nivå
uppfattning om vad kryptering är faktiskt

949
00:46:17,830 --> 00:46:18,590
allt om.

950
00:46:18,590 --> 00:46:20,030
>> Så låt oss komma dit.

951
00:46:20,030 --> 00:46:22,700
Låt oss nu titta under
motorhuven på något

952
00:46:22,700 --> 00:46:26,000
vi har tagit för givet för
den senaste veckan, och för denna session

953
00:46:26,000 --> 00:46:27,629
här-- strängen.

954
00:46:27,629 --> 00:46:30,295
En sträng vid slutet av dagen
är bara en sekvens av tecken.

955
00:46:30,295 --> 00:46:33,610
>> Det kan vara hello world, eller
hej Zamyla, eller vad som helst.

956
00:46:33,610 --> 00:46:37,050
Men vad betyder det att
vara en följd av tecken?

957
00:46:37,050 --> 00:46:41,520
I själva verket ger CS50-biblioteket
oss en datatyp som kallas sträng.

958
00:46:41,520 --> 00:46:45,140
>> Men det finns faktiskt ingen
sådant som en sträng i C.

959
00:46:45,140 --> 00:46:49,450
Det är egentligen bara en sekvens av
tecken, tecken, tecken,

960
00:46:49,450 --> 00:46:52,180
karaktär, rygg, mot rygg, till
tillbaka mot rygg, att backa innanför

961
00:46:52,180 --> 00:46:54,650
datorns minne, eller RAM.

962
00:46:54,650 --> 00:46:58,940
Och vi kommer att titta djupare in i det i
framtiden när vi tittar på minne själv,

963
00:46:58,940 --> 00:47:02,030
och utnyttjande, och
hot som är inblandade.

964
00:47:02,030 --> 00:47:04,100
>> Men låt oss betrakta strängen Zamyla.

965
00:47:04,100 --> 00:47:07,480
Så bara namnet på
den humana här, Zamyla,

966
00:47:07,480 --> 00:47:12,030
som är en sekvens av
tecken, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Och nu ska vi anta att Zamyla namn
lagras insidan av en dator

968
00:47:16,020 --> 00:47:16,880
program.

969
00:47:16,880 --> 00:47:20,830
>> Tja, är det förståeligt att vi bör
kunna titta på dessa tecken

970
00:47:20,830 --> 00:47:21,590
individuellt.

971
00:47:21,590 --> 00:47:24,710
Så jag ska bara dra en liten
ruta runt Zamyla namn här.

972
00:47:24,710 --> 00:47:31,580
Och det är fallet i C att när du
har en sträng, som Zamyla-- och kanske

973
00:47:31,580 --> 00:47:34,940
att strängen har kommit tillbaka från
en funktion som få sträng,

974
00:47:34,940 --> 00:47:38,540
du kan faktiskt manipulera
det tecken för tecken.

975
00:47:38,540 --> 00:47:42,070
>> Nu är denna förbunden för
samtal till hands, eftersom

976
00:47:42,070 --> 00:47:46,420
i kryptografi om du vill ändra
A till B, och B till C och C till D,

977
00:47:46,420 --> 00:47:49,650
och så vidare, du behöver för att kunna
att titta på enskilda tecken

978
00:47:49,650 --> 00:47:50,190
i en sträng.

979
00:47:50,190 --> 00:47:52,695
Du måste kunna ändra
Z till något annat, A

980
00:47:52,695 --> 00:47:55,280
till något annat, den M till
något annat, och så vidare.

981
00:47:55,280 --> 00:47:58,000
Och så behöver vi en väg,
programmatiskt, så

982
00:47:58,000 --> 00:48:03,020
att tala, i C för att kunna ändra
och titta på enskilda bokstäver.

983
00:48:03,020 --> 00:48:05,690
Och vi kan göra detta på följande sätt.

984
00:48:05,690 --> 00:48:08,340
>> Låt mig gå gå tillbaka i CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Och låt mig gå vidare
och skapa en ny fil

986
00:48:11,130 --> 00:48:16,134
att jag ringer här gången string0,
som vår första sådant exempel, dot c.

987
00:48:16,134 --> 00:48:18,300
Och jag kommer att gå vidare
och piska upp enligt följande.

988
00:48:18,300 --> 00:48:22,870
>> Så inkluderar CS50.h, och
då inkluderar standard io.h,

989
00:48:22,870 --> 00:48:25,990
som jag nästan alltid kommer att
att använda i mitt program, åtminstone

990
00:48:25,990 --> 00:48:26,780
till en början.

991
00:48:26,780 --> 00:48:32,180
int main tomrum, och sedan här är jag
kommer att göra strängar blir få sträng.

992
00:48:32,180 --> 00:48:35,260
Och då kommer jag att
gå vidare och göra det.

993
00:48:35,260 --> 00:48:37,460
Jag vill gå vidare
och, som en sanity check,

994
00:48:37,460 --> 00:48:43,607
bara säga, hej, procent s,
semikolon gör sträng 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, vad gjorde jag här?

996
00:48:44,690 --> 00:48:45,930
Åh, det gjorde jag inte koppla in den.

997
00:48:45,930 --> 00:48:48,120
Så lärdom, att
var inte avsiktligt.

998
00:48:48,120 --> 00:48:52,480
>> Så fel, mer procent
omvandlingar än uppgifter argument.

999
00:48:52,480 --> 00:48:54,940
Och det är här, i
linje 7-- OK, så jag har,

1000
00:48:54,940 --> 00:48:56,690
citat unquote, det är
min sträng till printf.

1001
00:48:56,690 --> 00:48:58,151
Jag har en procenttecken.

1002
00:48:58,151 --> 00:48:59,650
Men jag saknar det andra argumentet.

1003
00:48:59,650 --> 00:49:03,190
>> Jag saknar kommatecken s, vilket
Jag hade i tidigare exempel.

1004
00:49:03,190 --> 00:49:06,650
Så en bra möjlighet att åtgärda
en mer misstag, oavsiktligt.

1005
00:49:06,650 --> 00:49:09,950
Och nu vill jag köra
string0, typ i Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, hej Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Så vi har kört den här typen av program
ett par olika gånger nu.

1008
00:49:14,144 --> 00:49:16,310
Men låt oss göra något
lite annorlunda den här gången.

1009
00:49:16,310 --> 00:49:19,450
Istället för att bara skriva ut Zamyla s
hela namnet med printf,

1010
00:49:19,450 --> 00:49:21,350
låt oss göra det tecken för tecken.

1011
00:49:21,350 --> 00:49:22,700
>> Jag kommer att använda en for-loop.

1012
00:49:22,700 --> 00:49:26,160
Och jag kommer att ge mig själv
en räkningsvariabel kallas i.

1013
00:49:26,160 --> 00:49:33,530
Och jag kommer att hålla iteration, så
länge som i är mindre än längden på s.

1014
00:49:33,530 --> 00:49:35,930
>> Det visar sig, gjorde vi inte
gör detta sista gången,

1015
00:49:35,930 --> 00:49:39,100
att c kommer med en
funktion kallad Stirling.

1016
00:49:39,100 --> 00:49:42,690
Tillbaka i dag, och i allmänhet
fortfarande vid genomförandet av funktioner,

1017
00:49:42,690 --> 00:49:45,405
människor kommer ofta väljer mycket
koncisa namn som typ av ljud

1018
00:49:45,405 --> 00:49:48,280
precis vad du vill, även om det är
saknas några vokaler eller bokstäver.

1019
00:49:48,280 --> 00:49:50,660
Så Stirling är
namnet på en funktion som

1020
00:49:50,660 --> 00:49:53,880
tar ett argument mellan
parenteser som bör vara en sträng.

1021
00:49:53,880 --> 00:49:56,910
Och det bara returnerar ett heltal,
längden på den strängen.

1022
00:49:56,910 --> 00:50:00,580
>> Så detta för slinga på rad 7 kommer
att börja räkna på i lika med 0.

1023
00:50:00,580 --> 00:50:02,530
Det kommer att öka
i på varje iteration

1024
00:50:02,530 --> 00:50:04,350
med en, som vi har gjort ett par gånger.

1025
00:50:04,350 --> 00:50:06,780
Men det kommer att bara göra
detta fram till den punkt

1026
00:50:06,780 --> 00:50:09,660
när i är längden
av själva strängen.

1027
00:50:09,660 --> 00:50:14,520
>> Så detta är ett sätt att, i slutändan,
iterera över tecknen

1028
00:50:14,520 --> 00:50:17,430
i strängen som det är följande.

1029
00:50:17,430 --> 00:50:20,670
Jag kommer att skriva ut inte en
hela sträng, men procent c,

1030
00:50:20,670 --> 00:50:22,860
ett enda tecken
följt av en ny rad.

1031
00:50:22,860 --> 00:50:24,880
Och då kommer jag att
gå vidare, och jag behöver

1032
00:50:24,880 --> 00:50:29,080
att säga att jag vill skriva ut
te karaktär s.

1033
00:50:29,080 --> 00:50:33,450
>> Så om jag är den variabel som indikerar
index för den sträng, där

1034
00:50:33,450 --> 00:50:37,230
du i det, jag måste kunna
säga, ge mig te karaktär s.

1035
00:50:37,230 --> 00:50:40,390
Och c har ett sätt att göra
detta med hakparenteser.

1036
00:50:40,390 --> 00:50:43,679
Du säger helt enkelt namnet på
sträng, som i detta fall är s.

1037
00:50:43,679 --> 00:50:46,970
Då du använder hakparenteser, som är
vanligtvis strax ovanför Retur

1038
00:50:46,970 --> 00:50:48,110
tangent på tangentbordet.

1039
00:50:48,110 --> 00:50:52,410
Och då du sätter index för
tecken som du vill skriva ut.

1040
00:50:52,410 --> 00:50:55,960
Så indexet kommer att bli en
number-- 0, eller 1, eller 2, eller 3, eller dot,

1041
00:50:55,960 --> 00:50:57,590
prick, pricka, något annat nummer.

1042
00:50:57,590 --> 00:51:00,920
>> Och vi ser till att det kommer att
vara rätt nummer, eftersom jag

1043
00:51:00,920 --> 00:51:02,360
börja räkna på 0.

1044
00:51:02,360 --> 00:51:07,020
Och som standard, det första tecknet
i en sträng är genom konvention 0.

1045
00:51:07,020 --> 00:51:09,230
Och det andra tecknet är konsolen 1.

1046
00:51:09,230 --> 00:51:11,120
Och det tredje tecknet är fästet 2.

1047
00:51:11,120 --> 00:51:13,630
Och du inte vill gå alltför
långt, men vi kommer inte att vi är

1048
00:51:13,630 --> 00:51:17,780
kommer att endast inkrementera jag tills den
är lika med längden på strängen.

1049
00:51:17,780 --> 00:51:20,210
Och vid vilken punkt,
detta för slinga kommer att sluta.

1050
00:51:20,210 --> 00:51:25,550
>> Så låt mig gå vidare och spara
program, och kör gör sträng 0.

1051
00:51:25,550 --> 00:51:28,400
Men jag skruvas upp.

1052
00:51:28,400 --> 00:51:35,390
Underförstått att förklara biblioteksfunktion
Stirling med sådan typ och such-- nu,

1053
00:51:35,390 --> 00:51:36,430
detta låter bekant.

1054
00:51:36,430 --> 00:51:37,440
Men det är inte printf.

1055
00:51:37,440 --> 00:51:38,540
Och det är inte få sträng.

1056
00:51:38,540 --> 00:51:40,480
>> Jag inte skruva upp i
på samma sätt den här gången.

1057
00:51:40,480 --> 00:51:45,100
Men märker här nere lite ner
Vidare innefattar huvudet string.h,

1058
00:51:45,100 --> 00:51:47,210
uttryckligen ger
deklaration för Stirling.

1059
00:51:47,210 --> 00:51:48,820
Så det finns faktiskt en ledtråd där.

1060
00:51:48,820 --> 00:51:51,670
>> Och faktiskt det visar sig
det finns en annan huvudfil

1061
00:51:51,670 --> 00:51:53,970
att vi inte har använt
i klass ännu är men det

1062
00:51:53,970 --> 00:51:56,480
bland de tillgängliga
till dig, som kallas string.h.

1063
00:51:56,480 --> 00:52:00,930
Och i den filen, string.h
är Stirling deklareras.

1064
00:52:00,930 --> 00:52:05,220
Så låt mig gå vidare och
spara, göra sträng

1065
00:52:05,220 --> 00:52:08,040
0-- trevlig, inga felmeddelanden här gången.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, och
Jag är på väg att slå in,

1067
00:52:12,290 --> 00:52:16,710
vid vilken punkt getString kommer
att returnera strängen, placera den i er.

1068
00:52:16,710 --> 00:52:21,890
Då det för slingan kommer att iterera
över S tecken ett i taget,

1069
00:52:21,890 --> 00:52:28,420
och skriva ut dem en per rad, på grund
Jag hade att backslash n i slutet.

1070
00:52:28,420 --> 00:52:34,530
Så jag kunde utelämna att bakstreck
n, och sedan bara skriva Zamyla alla

1071
00:52:34,530 --> 00:52:37,460
i samma linje,
effektivt reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, vilket inte är så användbar.

1073
00:52:38,999 --> 00:52:40,540
Men i det här fallet, har jag inte gjort det.

1074
00:52:40,540 --> 00:52:43,610
Jag har faktiskt tryckt en
tecken i taget, en per rad,

1075
00:52:43,610 --> 00:52:45,400
så att vi faktiskt se effekten.

1076
00:52:45,400 --> 00:52:46,900
>> Men jag bör notera en sak här.

1077
00:52:46,900 --> 00:52:48,930
Och vi kommer tillbaka till
detta i en framtida vecka.

1078
00:52:48,930 --> 00:52:52,650
Det visar sig att detta
kod är potentiellt paraplyvagn.

1079
00:52:52,650 --> 00:52:56,560
>> Det visar sig att få sträng
och några andra funktioner i livet

1080
00:52:56,560 --> 00:53:00,280
inte nödvändigtvis alltid
tillbaka vad du förväntar sig.

1081
00:53:00,280 --> 00:53:03,010
Vi vet från klass sista
tid i detta att få

1082
00:53:03,010 --> 00:53:04,960
sträng är tänkt att returnera en sträng.

1083
00:53:04,960 --> 00:53:09,900
Men vad händer om användaren skriver en sådan
en långt ord, eller punkt, eller uppsats

1084
00:53:09,900 --> 00:53:13,010
att det finns helt enkelt inte tillräckligt
minne i datorn så att den passar den.

1085
00:53:13,010 --> 00:53:15,410
>> Liksom, tänk om något går
fel under huven?

1086
00:53:15,410 --> 00:53:18,400
Det kanske inte händer ofta,
men det kan hända en gång

1087
00:53:18,400 --> 00:53:21,520
på ett tag, mycket sällan.

1088
00:53:21,520 --> 00:53:25,460
Och så visar det sig att få sträng
och funktioner som det inte nödvändigtvis

1089
00:53:25,460 --> 00:53:26,380
alltid återvänder strängar.

1090
00:53:26,380 --> 00:53:30,680
De kan returnera något fel värde,
några sentinel värde så att säga,

1091
00:53:30,680 --> 00:53:32,612
som indikerar att
något har gått fel.

1092
00:53:32,612 --> 00:53:35,320
Och du skulle bara veta detta från
ha lärt sig det i klassen nu,

1093
00:53:35,320 --> 00:53:37,700
eller att ha läst några mer dokumentation.

1094
00:53:37,700 --> 00:53:43,120
Det visar sig att få sträng
kan returnera ett värde som kallas noll.

1095
00:53:43,120 --> 00:53:46,220
Null är ett speciellt värde som vi ska
komma tillbaka till i en framtida vecka.

1096
00:53:46,220 --> 00:53:50,420
Men nu, vet bara att om jag vill
att bli riktigt korrekt att gå vidare

1097
00:53:50,420 --> 00:53:52,650
med Hämta sträng, jag
bör inte bara kalla det,

1098
00:53:52,650 --> 00:53:56,870
och blint använda sin returvärde,
lita på att det är en sträng.

1099
00:53:56,870 --> 00:53:59,420
>> Jag vill först säga,
Vänta en minut, bara

1100
00:53:59,420 --> 00:54:03,380
fortsätta om s inte är lika
null, där null, återigen,

1101
00:54:03,380 --> 00:54:04,660
är bara några särskilt värde.

1102
00:54:04,660 --> 00:54:07,770
Och det är det enda speciellt värde du
behöver oroa sig för get sträng.

1103
00:54:07,770 --> 00:54:10,900
Få sträng antingen kommer
att returnera en sträng eller null.

1104
00:54:10,900 --> 00:54:17,219
>> Och detta utropstecken likhetstecken
ni kanske vet från kanske matematik klass

1105
00:54:17,219 --> 00:54:20,510
att du kan dra ett likhetstecken med
en linje genom att ange inte är lika.

1106
00:54:20,510 --> 00:54:23,135
Det är i allmänhet inte ett tecken
du kan skriva på tangentbordet.

1107
00:54:23,135 --> 00:54:26,480
Och så i de flesta programmeringsspråk,
när du vill säga inte är lika,

1108
00:54:26,480 --> 00:54:29,160
du använder ett utropstecken,
annars känd som bang.

1109
00:54:29,160 --> 00:54:33,180
Så du säger bang lika, vilket
betyder inte lika logiskt.

1110
00:54:33,180 --> 00:54:38,060
Det är precis som det inte finns en större
än eller lika med eller mindre än

1111
00:54:38,060 --> 00:54:41,270
eller lika med på tangentbordet
som gör allt i en symbol.

1112
00:54:41,270 --> 00:54:44,020
Så det är därför, i tidigare exempel,
du gjorde ett öppet fäste, och sedan

1113
00:54:44,020 --> 00:54:48,670
ett likhetstecken, för att göra
större än eller, säg, mindre än.

1114
00:54:48,670 --> 00:54:49,910
>> Så vad är takeaway här?

1115
00:54:49,910 --> 00:54:53,880
Detta är helt enkelt ett sätt nu av
införa denna syntax, den här funktionen,

1116
00:54:53,880 --> 00:54:57,390
iteration över individuella
tecken i en sträng.

1117
00:54:57,390 --> 00:55:00,260
Och precis som de kvadrat
konsoler kan du komma åt dem,

1118
00:55:00,260 --> 00:55:03,790
överväga dessa hakparenteser som
typ av antyder detta underliggande

1119
00:55:03,790 --> 00:55:06,040
design, där varje
karaktär insidan av en sträng

1120
00:55:06,040 --> 00:55:10,180
är typ av förpackade i någonstans nedanför
huven i datorns minne.

1121
00:55:10,180 --> 00:55:12,340
>> Men låt oss göra en variant av detta.

1122
00:55:12,340 --> 00:55:14,880
Det visar sig att detta
Programmet är korrekt.

1123
00:55:14,880 --> 00:55:18,810
Så per CS50: s axlar för att utvärdera
kod, är detta korrekt nu.

1124
00:55:18,810 --> 00:55:22,959
Speciellt nu när jag kontroll för
null, bör detta program aldrig krascha.

1125
00:55:22,959 --> 00:55:24,500
Och jag vet bara att av erfarenhet.

1126
00:55:24,500 --> 00:55:28,040
Men det finns inget annat att
Vi kan verkligen gå fel här.

1127
00:55:28,040 --> 00:55:31,860
Men det är inte mycket väl utformad,
eftersom låt oss gå tillbaka till grunderna.

1128
00:55:31,860 --> 00:55:34,450
>> Först, principles--
vad gör en for-loop göra?

1129
00:55:34,450 --> 00:55:36,290
En for-slinga gör tre saker.

1130
00:55:36,290 --> 00:55:39,340
Den initierar några
värde, om du frågar det.

1131
00:55:39,340 --> 00:55:41,770
Det kontrollerar ett villkor.

1132
00:55:41,770 --> 00:55:45,380
Och sedan efter varje
iteration, efter varje cykel,

1133
00:55:45,380 --> 00:55:49,330
det inkrementerar några
värde eller värden, här.

1134
00:55:49,330 --> 00:55:50,600
>> Så vad betyder det?

1135
00:55:50,600 --> 00:55:52,940
Vi initiera jag till 0.

1136
00:55:52,940 --> 00:55:58,610
Vi kontrollerar och se till att jag är mindre än
längden på s, vilket är Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
så som är mindre än sex.

1138
00:55:59,900 --> 00:56:02,590
Och, faktiskt, 0 som mindre än sex.

1139
00:56:02,590 --> 00:56:05,580
>> Vi skriver ut Z från Zamyla namn.

1140
00:56:05,580 --> 00:56:08,080
Då kan vi öka i 0-1.

1141
00:56:08,080 --> 00:56:11,290
Vi kontrollerar sedan, är en mindre
än längden av er?

1142
00:56:11,290 --> 00:56:13,270
Längd s är 6.

1143
00:56:13,270 --> 00:56:13,950
Ja det är det.

1144
00:56:13,950 --> 00:56:16,880
>> Så vi ut en i Zamyla namn, ZA.

1145
00:56:16,880 --> 00:56:20,090
Vi öka i från 0 till 1, till två.

1146
00:56:20,090 --> 00:56:23,720
Vi kontrollerar sedan, är två mindre än
längden av Zamyla namn.

1147
00:56:23,720 --> 00:56:25,380
6- så två är mindre än sex.

1148
00:56:25,380 --> 00:56:30,460
Ja, låt oss skriva ut nu M i
Zamyla namn, det tredje tecknet.

1149
00:56:30,460 --> 00:56:34,110
>> Det viktigaste här är att det på varje
iteration av historien, jag kontroll,

1150
00:56:34,110 --> 00:56:37,810
är jag mindre än längden på Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Men fångsten är att
Stirling är inte en egenskap.

1152
00:56:40,350 --> 00:56:43,100
De av er som har programmerat
tidigare i Java eller andra språk

1153
00:56:43,100 --> 00:56:46,310
kanske vet längden på en sträng är
en fastighet, bara några skrivskyddat värde.

1154
00:56:46,310 --> 00:56:50,220
>> I C i det här fallet, om det är
en funktion som är bokstavligen

1155
00:56:50,220 --> 00:56:53,520
räkning av antalet
tecken i Zamyla varje gång

1156
00:56:53,520 --> 00:56:54,740
Vi kallar denna funktion.

1157
00:56:54,740 --> 00:56:58,500
Varje gång du frågar datorn att använda
Stirling, det är att ta en titt på Zamyla,

1158
00:56:58,500 --> 00:57:01,960
och säger Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Och den returnerar 6.

1160
00:57:02,962 --> 00:57:04,920
Nästa gång du ringer
det insidan som for-loop,

1161
00:57:04,920 --> 00:57:08,610
det kommer att titta på Zamyla
Åter säger Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Och det kommer att återvända sex.

1163
00:57:10,320 --> 00:57:12,980
Så vad är dum om denna design?

1164
00:57:12,980 --> 00:57:17,700
>> Varför är min kod inte en 5 av 5
för design just nu, så att säga?

1165
00:57:17,700 --> 00:57:20,600
Tja, jag frågar en
fråga i onödan.

1166
00:57:20,600 --> 00:57:23,030
Jag gör mer arbete än jag behöver.

1167
00:57:23,030 --> 00:57:25,370
>> Så även om
svaret är rätt, jag

1168
00:57:25,370 --> 00:57:29,560
frågar datorn, vad är
längden av Zamyla igen,

1169
00:57:29,560 --> 00:57:31,380
och igen, och igen, och igen?

1170
00:57:31,380 --> 00:57:33,980
Och att svaret är
aldrig kommer att förändras.

1171
00:57:33,980 --> 00:57:35,900
Det kommer alltid att vara sex.

1172
00:57:35,900 --> 00:57:39,730
>> Så en bättre lösning än detta
skulle vara så här nästa version.

1173
00:57:39,730 --> 00:57:43,390
Låt mig gå vidare och lägga den i en
separat fil som heter string1.c,

1174
00:57:43,390 --> 00:57:44,990
bara för att hålla isär.

1175
00:57:44,990 --> 00:57:47,260
Och det visar sig i en för
slinga, kan du faktiskt

1176
00:57:47,260 --> 00:57:50,210
deklarera flera variabler samtidigt.

1177
00:57:50,210 --> 00:57:53,460
>> Så jag kommer att hålla i och ställa det till 0.

1178
00:57:53,460 --> 00:57:56,190
Men jag kommer också att
lägga till ett kommatecken, och säga,

1179
00:57:56,190 --> 00:58:01,050
ge mig en variabel som heter n, vars
värde är lika med stränglängd s.

1180
00:58:01,050 --> 00:58:09,410
Och nu, vänligen se mitt tillstånd
så länge jag är mindre än n.

1181
00:58:09,410 --> 00:58:14,140
>> Så på detta sätt, är logiken
identiska vid slutet av dagen.

1182
00:58:14,140 --> 00:58:18,280
Men jag minnas
värde 6, i det här fallet.

1183
00:58:18,280 --> 00:58:19,780
Vad är längden på Zamyla namn?

1184
00:58:19,780 --> 00:58:20,860
Och jag sätter den på n.

1185
00:58:20,860 --> 00:58:23,050
>> Och jag är fortfarande kontroll
villkoret varje gång.

1186
00:58:23,050 --> 00:58:24,300
Är 0 mindre än sex?

1187
00:58:24,300 --> 00:58:25,600
Är en mindre än sex?

1188
00:58:25,600 --> 00:58:28,600
Är två mindre än sex, och så vidare?

1189
00:58:28,600 --> 00:58:31,914
>> Men jag ber inte datorn
igen, och igen, vad är

1190
00:58:31,914 --> 00:58:33,080
längden på Zamyla namn?

1191
00:58:33,080 --> 00:58:34,320
Vad är längden på Zamyla namn?

1192
00:58:34,320 --> 00:58:35,986
Vad är längden på detta Zamyla namn?

1193
00:58:35,986 --> 00:58:40,440
Jag bokstavligen komma ihåg att första och
bara svara på denna andra variabeln n.

1194
00:58:40,440 --> 00:58:45,280
Så detta nu skulle vara inte bara
korrekt, men också väl utformad.

1195
00:58:45,280 --> 00:58:46,670
>> Nu, hur stil?

1196
00:58:46,670 --> 00:58:48,866
Jag har namngett mina variabler
ganska bra, skulle jag säga.

1197
00:58:48,866 --> 00:58:50,240
De är super kortfattad just nu.

1198
00:58:50,240 --> 00:58:52,090
Och det är helt bra.

1199
00:58:52,090 --> 00:58:55,120
>> Om du har bara en
sträng i ett program,

1200
00:58:55,120 --> 00:58:56,860
du kan lika gärna kalla det är för sträng.

1201
00:58:56,860 --> 00:58:59,370
Om du bara har en variabel
för räkning i ett program,

1202
00:58:59,370 --> 00:59:00,710
du kan lika gärna kalla det jag.

1203
00:59:00,710 --> 00:59:03,500
Om du har en längd, n
är super vanligt liksom.

1204
00:59:03,500 --> 00:59:05,800
Men jag har inte kommenterat några av min kod.

1205
00:59:05,800 --> 00:59:09,200
>> Jag har inte underrättat reader--
oavsett om det är min TF, eller TA,

1206
00:59:09,200 --> 00:59:12,460
eller bara colleague-- vad är tänkt
att gå på i det här programmet.

1207
00:59:12,460 --> 00:59:15,760
Och på så sätt få god stil,
vad jag vill göra

1208
00:59:15,760 --> 00:59:24,580
är this-- något
som ber användaren för inmatning.

1209
00:59:24,580 --> 00:59:26,670
Och jag kunde skriva om
detta på många olika sätt.

1210
00:59:26,670 --> 00:59:35,630
>> Se till s-- ser till get
strängen som returneras en sträng.

1211
00:59:35,630 --> 00:59:40,280
Och sedan i här-- och det är kanske
den viktigaste comment-- iterate

1212
00:59:40,280 --> 00:59:44,450
över tecken i s en i taget.

1213
00:59:44,450 --> 00:59:47,060
Och jag kunde använda
Valet av engelska språket

1214
00:59:47,060 --> 00:59:49,650
här för att beskriva varje
av dessa bitar av kod.

1215
00:59:49,650 --> 00:59:52,740
>> Lägg märke till att jag inte har lagt en
kommentera varje kodrad,

1216
00:59:52,740 --> 00:59:55,690
egentligen bara på den intressanta
sådana, de som

1217
00:59:55,690 --> 00:59:59,460
har en mening som jag kanske
vill göra super klart för någon

1218
00:59:59,460 --> 01:00:00,460
läsa min kod.

1219
01:00:00,460 --> 01:00:02,920
Och varför är du ringer få
sträng be användaren för inmatning?

1220
01:00:02,920 --> 01:00:05,450
Även att man inte nödvändigtvis
allt det beskrivande.

1221
01:00:05,450 --> 01:00:09,340
Men det hjälper att berätta en historia, eftersom
andra raden i historien, se

1222
01:00:09,340 --> 01:00:10,740
få sträng tillbaka en sträng.

1223
01:00:10,740 --> 01:00:14,260
>> Och den tredje raden i berättelsen är,
iterera över karaktärerna i s en

1224
01:00:14,260 --> 01:00:15,380
vid en tid.

1225
01:00:15,380 --> 01:00:17,920
Och nu bara för bra åtgärd,
Jag kommer att gå vidare och lägga till

1226
01:00:17,920 --> 01:00:24,560
en mer kommentar som bara
säger print i-te karaktär is.

1227
01:00:24,560 --> 01:00:26,520
Nu, vad har jag gjort
Vid slutet av dagen?

1228
01:00:26,520 --> 01:00:29,190
>> Jag har lagt till några engelska
ord i form av kommentarer.

1229
01:00:29,190 --> 01:00:32,700
Den snedstreck snedstreck symbolen betyder, hej,
dator är för människan,

1230
01:00:32,700 --> 01:00:33,820
inte för dig, datorn.

1231
01:00:33,820 --> 01:00:35,119
Så de ignoreras logiskt.

1232
01:00:35,119 --> 01:00:35,910
De är bara där.

1233
01:00:35,910 --> 01:00:39,830
>> Och faktiskt, CS50 IDE visar dem som
grå, vara användbara, men inte nyckeln

1234
01:00:39,830 --> 01:00:41,000
till programmet.

1235
01:00:41,000 --> 01:00:42,570
Lägg märke till vad du nu kan göra.

1236
01:00:42,570 --> 01:00:44,950
Oavsett om du vet C
programmering eller inte, du

1237
01:00:44,950 --> 01:00:47,722
kan bara stå tillbaka på detta
program, och skumma kommentarerna.

1238
01:00:47,722 --> 01:00:50,180
Be användaren för inmatning, se
få sträng tillbaka en sträng,

1239
01:00:50,180 --> 01:00:53,009
iterera över karaktärerna i s
en i taget, ut tecknet

1240
01:00:53,009 --> 01:00:55,550
i: te karaktär i s-- du inte
även måste titta på koden

1241
01:00:55,550 --> 01:00:57,270
att förstå vad detta program gör.

1242
01:00:57,270 --> 01:01:00,280
Och ännu bättre, om du själv ser
på detta program i en vecka eller två,

1243
01:01:00,280 --> 01:01:02,280
eller en månad, eller ett år,
du också inte har

1244
01:01:02,280 --> 01:01:04,420
stirra på koden,
försöka komma ihåg,

1245
01:01:04,420 --> 01:01:06,630
vad jag försöker göra med denna kod?

1246
01:01:06,630 --> 01:01:07,770
>> Du har sagt själv.

1247
01:01:07,770 --> 01:01:11,660
Du har beskrivit det själv,
eller någon kollega eller TA, eller TF.

1248
01:01:11,660 --> 01:01:14,860
Och så skulle nu vara
korrekt, och god design,

1249
01:01:14,860 --> 01:01:18,210
och i slutändan bra stil också.

1250
01:01:18,210 --> 01:01:19,990
Så gör ha det i åtanke.

1251
01:01:19,990 --> 01:01:22,200
>> Så det finns en annan
sak jag ska göra här

1252
01:01:22,200 --> 01:01:28,240
som kan nu avslöja exakt vad som är
pågår under huven.

1253
01:01:28,240 --> 01:01:30,390
Så det finns den här funktionen
i C och andra språk,

1254
01:01:30,390 --> 01:01:33,010
kallas type-casting
att antingen implicit

1255
01:01:33,010 --> 01:01:37,250
eller uttryckligen tillåter dig att konvertera
från en datatyp till en annan.

1256
01:01:37,250 --> 01:01:39,800
Vi har arbetat så
långt idag med strängar.

1257
01:01:39,800 --> 01:01:41,250
>> Och strängar är tecken.

1258
01:01:41,250 --> 01:01:44,910
Men minns från vecka
0, vilka är tecken?

1259
01:01:44,910 --> 01:01:49,334
Tecken är bara en abstraktion
ovanpå numbers-- decimaltal,

1260
01:01:49,334 --> 01:01:52,500
och decimaltal är egentligen bara en
abstraktion på toppen av binära tal,

1261
01:01:52,500 --> 01:01:53,720
som vi definierat det.

1262
01:01:53,720 --> 01:01:55,540
>> Så tecken är siffror.

1263
01:01:55,540 --> 01:01:58,410
Och siffrorna är tecken,
bara beroende på sammanhanget.

1264
01:01:58,410 --> 01:02:01,250
Och det visar sig att insidan
av ett datorprogram,

1265
01:02:01,250 --> 01:02:06,830
kan du ange hur du vill titta
på bitarna inne i programmet?

1266
01:02:06,830 --> 01:02:10,400
>> Minns från vecka 0 som vi hade
Ascii, vilket är just denna kod

1267
01:02:10,400 --> 01:02:11,620
kartläggning brev till siffror.

1268
01:02:11,620 --> 01:02:13,660
Och vi sade, kapital A är 65.

1269
01:02:13,660 --> 01:02:15,860
Kapital B är 66, och så vidare.

1270
01:02:15,860 --> 01:02:20,500
>> Och varsel, vi har i huvudsak tecken på
den översta raden här, eftersom C skulle kalla dem,

1271
01:02:20,500 --> 01:02:23,400
tecken, och sedan
ints på den andra raden.

1272
01:02:23,400 --> 01:02:28,180
Och det visar sig att du kan konvertera
sömlöst mellan de två, typiskt.

1273
01:02:28,180 --> 01:02:30,042
Och om vi vill göra
detta medvetet, vi

1274
01:02:30,042 --> 01:02:31,750
kanske vill ta itu med
något som det här.

1275
01:02:31,750 --> 01:02:33,590
>> Vi kanske vill konvertera
versaler för att sänka

1276
01:02:33,590 --> 01:02:35,330
fall eller gemener till versaler.

1277
01:02:35,330 --> 01:02:38,000
Och det visar sig att det finns
faktiskt ett mönster här

1278
01:02:38,000 --> 01:02:39,900
vi kan omfamna på bara ett ögonblick.

1279
01:02:39,900 --> 01:02:44,120
Men låt oss först titta på en
exempel på att göra detta uttryckligen.

1280
01:02:44,120 --> 01:02:46,340
>> Jag kommer att gå tillbaka till CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Jag kommer att skapa en
fil kallad Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Och jag kommer att gå vidare och lägga till min
standard io.h upptill, int main tomrum

1283
01:02:55,960 --> 01:02:57,370
på toppen av min funktion.

1284
01:02:57,370 --> 01:03:02,700
Och då jag ska bara göra det
following-- en for-loop från i lika,

1285
01:03:02,700 --> 01:03:04,610
låt oss säga, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Och sedan jag kommer att vara mindre än
65, plus 26 bokstäver i alfabetet.

1287
01:03:10,460 --> 01:03:12,640
Så jag ska låta datorn
göra matten för mig där.

1288
01:03:12,640 --> 01:03:15,100
Och sedan i denna slinga,
vad ska jag skriva ut?

1289
01:03:15,100 --> 01:03:19,230
>> % C är% i omvänt snedstreck n.

1290
01:03:19,230 --> 01:03:21,290
Och nu vill jag att koppla in två värden.

1291
01:03:21,290 --> 01:03:24,530
Jag har tillfälligt lagt fråga
markerar det att bjuda in frågan.

1292
01:03:24,530 --> 01:03:29,940
>> Jag vill upprepa från 65 och framåt
för 26 bokstäverna i alfabetet,

1293
01:03:29,940 --> 01:03:35,190
utskrift på varje iteration som
karaktärs integrerad motsvarande.

1294
01:03:35,190 --> 01:03:38,299
Med andra ord, vill jag
iterera över 26 nummer utskrift

1295
01:03:38,299 --> 01:03:41,590
vad ASCII är brevet,
och vad motsvarande antal är--

1296
01:03:41,590 --> 01:03:44,650
egentligen bara återskapa
diagrammet från att glida.

1297
01:03:44,650 --> 01:03:47,010
Så vad bör dessa frågetecken vara?

1298
01:03:47,010 --> 01:03:51,760
>> Tja, visar det sig att den andra
bör bara vara variabeln i.

1299
01:03:51,760 --> 01:03:53,860
Jag vill se det som ett tal.

1300
01:03:53,860 --> 01:03:58,920
Och mitt argument
Härifrån kan jag tala om för datorn

1301
01:03:58,920 --> 01:04:03,470
att behandla den heltal
i som en karaktär, så som

1302
01:04:03,470 --> 01:04:05,880
att ersätta det här för procent C.

1303
01:04:05,880 --> 01:04:07,990
>> Med andra ord, om jag,
mänsklig programmerare, vet

1304
01:04:07,990 --> 01:04:09,865
dessa är bara siffror
Vid slutet av dagen.

1305
01:04:09,865 --> 01:04:12,500
Och jag vet att 65 borde
mappas till vissa tecken.

1306
01:04:12,500 --> 01:04:15,310
Med detta explicit cast,
med en parentes,

1307
01:04:15,310 --> 01:04:18,840
namnet på den datatyp som du vill
konvertera till, och en sluten parentes,

1308
01:04:18,840 --> 01:04:21,200
du kan berätta
dator, hej, dator,

1309
01:04:21,200 --> 01:04:24,130
omvandla denna heltal till en röding.

1310
01:04:24,130 --> 01:04:26,250
>> Så när jag kör detta
program efter att sammanställa,

1311
01:04:26,250 --> 01:04:29,740
Låt oss se vad jag get-- göra Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Darn det, vad gjorde jag fel här?

1313
01:04:33,020 --> 01:04:35,884
Användning av odeklarerat identifierare,
okej, inte avsiktligt,

1314
01:04:35,884 --> 01:04:37,800
men låt oss se om vi kan inte
Anledningen till detta.

1315
01:04:37,800 --> 01:04:41,220
>> Så linje five-- så jag inte fick
mycket långt innan du skruvar upp.

1316
01:04:41,220 --> 01:04:42,140
Det är ok.

1317
01:04:42,140 --> 01:04:46,560
Så linje 5 för i lika 65-- jag ser.

1318
01:04:46,560 --> 01:04:50,130
Så kom ihåg att i C, till skillnad från vissa
språk om du har tidigare programmering

1319
01:04:50,130 --> 01:04:52,190
erfarenhet, har du
att tala om för datorn,

1320
01:04:52,190 --> 01:04:55,040
Till skillnad från Scratch, vad
typ av variabel är.

1321
01:04:55,040 --> 01:04:56,860
>> Och jag glömde en nyckelfras här.

1322
01:04:56,860 --> 01:04:59,200
I linje fem, jag har börjat använda i.

1323
01:04:59,200 --> 01:05:01,560
Men jag har inte sagt C
vilken datatyp det är.

1324
01:05:01,560 --> 01:05:04,570
Så jag kommer att gå in här och
säga, ah, gör det till ett heltal.

1325
01:05:04,570 --> 01:05:07,050
>> Nu ska jag gå vidare och kompilera.

1326
01:05:07,050 --> 01:05:08,080
Det fasta det.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, det är ganska coolt.

1328
01:05:12,660 --> 01:05:15,360
Inte bara är det supersnabb till
be datorn denna fråga,

1329
01:05:15,360 --> 01:05:18,885
snarare än att titta upp på en bild,
Det skrivs ut en per rad, A är 65,

1330
01:05:18,885 --> 01:05:24,860
B är 66, hela vägen down-- eftersom jag
gjorde detta 26 times-- till bokstäverna z,

1331
01:05:24,860 --> 01:05:25,630
vilket är 90.

1332
01:05:25,630 --> 01:05:27,790
Och, faktiskt, något
mer intelligent skulle

1333
01:05:27,790 --> 01:05:31,030
har varit för mig att inte lita
på datorn för att lägga till 26.

1334
01:05:31,030 --> 01:05:34,060
Jag kunde bara gjort
90 också, så länge

1335
01:05:34,060 --> 01:05:37,390
eftersom jag inte göra samma misstag två gånger.

1336
01:05:37,390 --> 01:05:41,880
Jag vill gå upp genom
z, inte bara upp genom y.

1337
01:05:41,880 --> 01:05:44,000
>> Så det är en explicit rösterna.

1338
01:05:44,000 --> 01:05:47,860
Det visar sig att detta
är inte ens nödvändigt.

1339
01:05:47,860 --> 01:05:52,480
Låt mig gå vidare och köra detta
kompilator, och repris Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Det visar sig att C är ganska smart.

1341
01:05:54,940 --> 01:05:57,150
>> Och printf, i synnerhet,
är ganska smart.

1342
01:05:57,150 --> 01:06:01,260
Om du bara passerar en i två gånger
för båda platshållare, printf

1343
01:06:01,260 --> 01:06:04,510
kommer att inse, oh, ja jag vet att du
gav mig ett integer-- ett visst antal,

1344
01:06:04,510 --> 01:06:06,380
som 65 eller 90, eller vad som helst.

1345
01:06:06,380 --> 01:06:10,170
Men jag ser att ni vill att jag ska
formatera det numret som ett tecken.

1346
01:06:10,170 --> 01:06:16,460
Och så printf kan helt klassificerad
int till en röding för dig också.

1347
01:06:16,460 --> 01:06:19,360
Så det är inte ett problem alls.

1348
01:06:19,360 --> 01:06:23,100
>> Men märker, på grund av denna likvärdighet
vi faktiskt kan göra detta.

1349
01:06:23,100 --> 01:06:26,520
Låt mig gå vidare och göra en
andra version av this-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
Och i stället för iteration över
heltal, kan verkligen blåsa dig

1351
01:06:31,800 --> 01:06:33,610
genom iteration över tecken.

1352
01:06:33,610 --> 01:06:37,660
Om en char c blir kapital A, I
vill gå vidare och göra det,

1353
01:06:37,660 --> 01:06:41,740
så länge som C är mindre än eller lika
kapital Z. Och på varje iteration

1354
01:06:41,740 --> 01:06:45,690
Jag vill öka C, jag kan
nu i min printf linje här

1355
01:06:45,690 --> 01:06:51,320
säg, är procent C
procent i igen, komma C.

1356
01:06:51,320 --> 01:06:57,200
>> Och nu kan jag gå åt andra hållet,
gjutning karaktären uttryckligen

1357
01:06:57,200 --> 01:06:58,500
till ett heltal.

1358
01:06:58,500 --> 01:07:00,560
Så, återigen, varför skulle du göra det?

1359
01:07:00,560 --> 01:07:03,830
Det är lite konstigt att sortera av
räkna i termer av tecken.

1360
01:07:03,830 --> 01:07:07,430
>> Men om du förstår vad är
pågår under huven,

1361
01:07:07,430 --> 01:07:08,430
det finns verkligen ingen magi.

1362
01:07:08,430 --> 01:07:13,060
Du bara säga hej, dator ge
mig en variabel som heter C av typen char.

1363
01:07:13,060 --> 01:07:16,520
Initiera det till kapital A. Och
märke apostrof materia.

1364
01:07:16,520 --> 01:07:19,580
>> För tecken i C, minns från
förra veckan, använder du enkla citattecken.

1365
01:07:19,580 --> 01:07:23,720
För strängar, för ord,
fraser använder du dubbla citattecken.

1366
01:07:23,720 --> 01:07:27,210
OK, dator, fortsätter att göra detta, så
länge som det tecken är mindre än

1367
01:07:27,210 --> 01:07:28,050
eller lika med z.

1368
01:07:28,050 --> 01:07:32,640
Och jag vet av Ascii tabell som alla
av dessa ASCII-koder är angränsande.

1369
01:07:32,640 --> 01:07:33,400
>> Det finns några luckor.

1370
01:07:33,400 --> 01:07:36,737
Så det är bara A till Z,
separerade med ett antal vardera.

1371
01:07:36,737 --> 01:07:38,820
Och då kan jag öka
en röding, om jag verkligen vill.

1372
01:07:38,820 --> 01:07:40,390
Vid slutet av dagen,
Det är bara en siffra.

1373
01:07:40,390 --> 01:07:41,030
Jag vet det här.

1374
01:07:41,030 --> 01:07:43,670
Så jag kan bara förutsätta att lägga en till den.

1375
01:07:43,670 --> 01:07:46,940
>> Och sedan den här gången, jag skriver ut c,
och sedan integralen motsvarande.

1376
01:07:46,940 --> 01:07:50,170
Och jag behöver inte ens ett uttryckligt rösterna.

1377
01:07:50,170 --> 01:07:52,680
Jag kan låta printf och
dator lista ut saker,

1378
01:07:52,680 --> 01:07:57,300
så att nu om jag kör
göra Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Jag får exakt samma sak också.

1380
01:08:01,520 --> 01:08:04,530
>> Värdelös program, though-- ingen
kommer att faktiskt skriva programvara

1381
01:08:04,530 --> 01:08:07,549
För att räkna ut, vad var det
nummer som avbildas till A eller B, eller Z?

1382
01:08:07,549 --> 01:08:10,340
Du bara gå till Google det, eller
slå upp det på nätet, eller slå upp det

1383
01:08:10,340 --> 01:08:11,650
på ett objektglas, eller liknande.

1384
01:08:11,650 --> 01:08:13,520
Så varifrån kommer denna får faktiskt bra?

1385
01:08:13,520 --> 01:08:15,960
>> Jo, på tal om det
slide, märker att det finns

1386
01:08:15,960 --> 01:08:20,890
en verklig mönster här mellan versaler
och gemener som inte var en tillfällighet.

1387
01:08:20,890 --> 01:08:23,760
Lägg märke till att kapital A är 65.

1388
01:08:23,760 --> 01:08:25,830
Gemener a är 97.

1389
01:08:25,830 --> 01:08:29,649
Och hur långt borta är gemena en?

1390
01:08:29,649 --> 01:08:32,649
>> Så 65 är hur många steg bort från 97?

1391
01:08:32,649 --> 01:08:36,210
Så 97 minus 65 är 32.

1392
01:08:36,210 --> 01:08:37,910
Så kapital a är 65.

1393
01:08:37,910 --> 01:08:39,939
Om du lägger till 32 till det,
du får gemener a.

1394
01:08:39,939 --> 01:08:43,729
Och, ekvivalent, om du subtrahera 32,
du kommer tillbaka till kapital A-- samma med B

1395
01:08:43,729 --> 01:08:46,380
för lite B, stora C till lite c.

1396
01:08:46,380 --> 01:08:50,670
>> Alla dessa brister är 32 isär.

1397
01:08:50,670 --> 01:08:54,450
Nu, detta förefaller att tillåta oss att
göra något som Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
eller Google Dokument funktionen där du
kan välja allt och sedan säga,

1399
01:08:57,729 --> 01:09:00,520
ändra alla till gemener, eller
ändra alla till versaler,

1400
01:09:00,520 --> 01:09:03,840
eller bara ändra det första ordet
av en mening till versaler.

1401
01:09:03,840 --> 01:09:07,390
Vi kan faktiskt göra något
som att själva.

1402
01:09:07,390 --> 01:09:12,645
>> Låt mig gå vidare och spara en fil
här kallad kapitalisera 0.c.

1403
01:09:12,645 --> 01:09:15,770
Och låt oss gå vidare och piska upp ett program
som gör exakt det som följer.

1404
01:09:15,770 --> 01:09:18,460
Så omfattar CS50 biblioteket.

1405
01:09:18,460 --> 01:09:21,430
Och inkluderar standard I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Och jag vet att det kommer snart.

1407
01:09:22,787 --> 01:09:24,870
Så jag kommer att sätta det i
det redan, string.h,

1408
01:09:24,870 --> 01:09:26,960
så jag har tillgång till
saker som Stirling,

1409
01:09:26,960 --> 01:09:29,620
och sedan int main tomrum, som vanligt.

1410
01:09:29,620 --> 01:09:33,420
Och då kommer jag att gå vidare
och göra strängar blir få sträng,

1411
01:09:33,420 --> 01:09:35,032
bara för att få en sträng från användaren.

1412
01:09:35,032 --> 01:09:36,740
Och då kommer jag att
göra mitt förstånd kontroll.

1413
01:09:36,740 --> 01:09:40,510
Om strängen inte är lika null,
då är det säkert att fortsätta.

1414
01:09:40,510 --> 01:09:42,000
Och vad vill jag göra?

1415
01:09:42,000 --> 01:09:48,700
Jag kommer att upprepa från i lika med 0,
och n fram till stränglängd s.

1416
01:09:48,700 --> 01:09:51,899
>> Och jag kommer att göra detta så länge som
Jag är mindre än n, och jag plus plus.

1417
01:09:51,899 --> 01:09:55,060
Hittills har jag är verkligen bara
låna idéer från förr.

1418
01:09:55,060 --> 01:09:57,010
Och nu ska jag presentera en gren.

1419
01:09:57,010 --> 01:09:59,635
>> Så tänker tillbaka på Scratch, där
Vi hade dessa gafflar i vägen,

1420
01:09:59,635 --> 01:10:05,110
och förra veckan i C. Jag ska
säger detta, om det i: te karaktär is

1421
01:10:05,110 --> 01:10:09,250
är större än eller
lika med gemener a,

1422
01:10:09,250 --> 01:10:13,340
och-- i Scratch du skulle bokstavligen
säga och, men i C du säger ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- och den i: te karaktär is
är mindre än eller lika med gemener z,

1424
01:10:19,830 --> 01:10:21,780
Låt oss göra något intressant.

1425
01:10:21,780 --> 01:10:27,020
Låt oss faktiskt skriva ut en
karaktär med ingen ny rad

1426
01:10:27,020 --> 01:10:31,760
det är tecknet i strängen,
den i: te tecken i strängen.

1427
01:10:31,760 --> 01:10:37,420
>> Men låt oss gå vidare och
subtrahera 32 från det.

1428
01:10:37,420 --> 01:10:42,120
Annars om tecknet i
sträng som vi letar

1429
01:10:42,120 --> 01:10:45,950
inte mellan Lite
och lite z, gå vidare

1430
01:10:45,950 --> 01:10:48,610
och bara skrivas ut oförändrad.

1431
01:10:48,610 --> 01:10:50,840
Så vi har infört
detta parantes notation

1432
01:10:50,840 --> 01:10:53,560
för våra strängar att komma åt
i: te tecken i strängen.

1433
01:10:53,560 --> 01:10:57,520
>> Jag har lagt till några villkorslogik, som
Scratch i förra veckans veckan en, där

1434
01:10:57,520 --> 01:10:59,880
Jag bara använda min grundläggande
förståelse av vad som är

1435
01:10:59,880 --> 01:11:01,130
pågår under huven.

1436
01:11:01,130 --> 01:11:04,190
Är den i: te karaktär s
större än eller lika med ett?

1437
01:11:04,190 --> 01:11:08,290
Liksom, är det 97, eller 98,
eller 99, och så vidare?

1438
01:11:08,290 --> 01:11:11,940
>> Men det är också mindre än eller lika
till värdet av gemener z?

1439
01:11:11,940 --> 01:11:16,210
Och i så fall, vad denna linje detta?

1440
01:11:16,210 --> 01:11:20,250
14, är denna typ av
fröet till hela idén,

1441
01:11:20,250 --> 01:11:23,840
kapitalisera brevet genom
helt enkelt subtrahera 32 från det,

1442
01:11:23,840 --> 01:11:29,370
i det här fallet, eftersom jag vet, per den
diagram, hur mina nummer är representerade.

1443
01:11:29,370 --> 01:11:33,925
Så låt oss gå vidare och köra,
efter sammanställningen kapitalisera 0.c,

1444
01:11:33,925 --> 01:11:36,210
och kör kapitalisera 0.

1445
01:11:36,210 --> 01:11:40,300
>> Låt oss skriva in något som
Zamyla i gemener anger.

1446
01:11:40,300 --> 01:11:42,780
Och nu har vi Zamyla i versaler.

1447
01:11:42,780 --> 01:11:45,050
Låt oss skriva in Rob i gemener.

1448
01:11:45,050 --> 01:11:46,674
Låt oss försöka Jason i gemener.

1449
01:11:46,674 --> 01:11:48,590
Och vi hålla få
tvångs kapitalisering.

1450
01:11:48,590 --> 01:11:50,960
Det finns en liten bugg som jag
typ av inte förutse.

1451
01:11:50,960 --> 01:11:54,050
Lägg märke till min nya prompt hamnar
på samma linje som deras namn,

1452
01:11:54,050 --> 01:11:55,520
vilket känns lite rörigt.

1453
01:11:55,520 --> 01:11:59,170
>> Så jag kommer att gå här, och
faktiskt i slutet av detta program

1454
01:11:59,170 --> 01:12:02,110
skriva ut ett nyradstecken.

1455
01:12:02,110 --> 01:12:03,160
Det är allt.

1456
01:12:03,160 --> 01:12:06,120
Med printf, behöver du inte
passera i variabler eller format kod.

1457
01:12:06,120 --> 01:12:08,460
Du kan bokstavligen bara ut
något som en ny rad.

1458
01:12:08,460 --> 01:12:13,529
>> Så låt oss gå vidare och göra
kapitalisera 0 igen, köra den, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Och nu är det lite sötare.

1460
01:12:14,820 --> 01:12:17,274
Nu är min prompt på egen ny rad.

1461
01:12:17,274 --> 01:12:18,440
Så det är alla fina och bra.

1462
01:12:18,440 --> 01:12:19,910
Så det är ett bra exempel.

1463
01:12:19,910 --> 01:12:22,700
Men jag inte ens nödvändigtvis
behöver hårdkoda 32.

1464
01:12:22,700 --> 01:12:23,350
Vet du vad?

1465
01:12:23,350 --> 01:12:26,350
Jag kunde säga-- jag inte någonsin
minns vad skillnaden är.

1466
01:12:26,350 --> 01:12:29,330
>> Men jag vet att om jag
har en liten bokstav,

1467
01:12:29,330 --> 01:12:34,430
Jag vill i huvudsak att subtrahera bort
oavsett avståndet är mellan lite

1468
01:12:34,430 --> 01:12:39,160
a och stora A, för om jag antar att
alla de andra bokstäverna är desamma,

1469
01:12:39,160 --> 01:12:41,045
som ska få jobbet gjort.

1470
01:12:41,045 --> 01:12:42,670
Men i stället för att göra det, vet du vad?

1471
01:12:42,670 --> 01:12:44,240
Det finns ett annat sätt fortfarande.

1472
01:12:44,240 --> 01:12:48,090
>> Om det är kapitalisera 1.c-- om jag var
att sätta in det i en separat fil.

1473
01:12:48,090 --> 01:12:51,030
Låt oss göra kapitalisera 2.c enligt följande.

1474
01:12:51,030 --> 01:12:53,060
Jag ska verkligen städa upp detta här.

1475
01:12:53,060 --> 01:12:57,420
Och istället för att ens behöva
vet eller bryr sig om de låg nivå

1476
01:12:57,420 --> 01:13:01,090
genomförandet detaljer, jag är i stället
bara att skriva ut ett tecken,

1477
01:13:01,090 --> 01:13:04,610
quote unquote, procent C, och
sedan ringa en annan funktion som

1478
01:13:04,610 --> 01:13:09,950
existerar som tar ett argument,
vilket är ett tecken, som den här.

1479
01:13:09,950 --> 01:13:12,630
>> Det visar sig i C, det finns
en annan funktionsanropet

1480
01:13:12,630 --> 01:13:15,550
till övre, som precis som namnet
antyder tar ett tecken

1481
01:13:15,550 --> 01:13:19,350
och gör det till dess övre fall
motsvarande och sedan återgår det

1482
01:13:19,350 --> 01:13:21,410
så att printf kan koppla in den där.

1483
01:13:21,410 --> 01:13:25,484
Och så för att göra detta, men jag
behovet av att införa en annan fil.

1484
01:13:25,484 --> 01:13:28,400
Det visar sig att det finns en annan fil
att du bara skulle veta från klass,

1485
01:13:28,400 --> 01:13:33,020
eller en lärobok eller en online
referens, kallad C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Så om jag lägger upp det bland min header
filer, och nu åter kompilera programmet,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Låt oss skriva in Zamyla i alla
gemener, fungerar fortfarande densamma.

1489
01:13:46,690 --> 01:13:48,040
Men vet du vad?

1490
01:13:48,040 --> 01:13:55,590
Det visar sig att till övre
har någon annan funktionalitet.

1491
01:13:55,590 --> 01:13:58,410
>> Och låt mig presentera denna
kommandot här sortens olyckligt

1492
01:13:58,410 --> 01:14:00,250
namngiven, men man för manuell.

1493
01:14:00,250 --> 01:14:03,960
Det visar sig att de flesta Linux-datorer,
som vi använder här-- Linux operativsystem

1494
01:14:03,960 --> 01:14:06,270
system-- har ett kommando
kallas man, som säger,

1495
01:14:06,270 --> 01:14:08,530
hej, dator, ge mig
datorns manual.

1496
01:14:08,530 --> 01:14:10,680
Vad vill du
slå upp i handboken?

1497
01:14:10,680 --> 01:14:13,840
>> Jag vill slå upp funktionen
kallas till övre Enter.

1498
01:14:13,840 --> 01:14:16,070
Och det är lite kryptisk
att läsa ibland.

1499
01:14:16,070 --> 01:14:18,780
Men märker vi är i
Linux programmerare handbok.

1500
01:14:18,780 --> 01:14:19,530
Och det är all text.

1501
01:14:19,530 --> 01:14:21,905
Och märker att det är
funktionens namn här uppe.

1502
01:14:21,905 --> 01:14:25,030
Det visar sig att det har en kusin som heter
att sänka, vilket gör det motsatta.

1503
01:14:25,030 --> 01:14:29,710
Och meddelande enligt synopsis, att använda denna
fungera manualsidan, så att säga,

1504
01:14:29,710 --> 01:14:32,220
säger mig att jag
måste inkludera c type.h.

1505
01:14:32,220 --> 01:14:33,630
Och jag visste att från praktiken.

1506
01:14:33,630 --> 01:14:36,210
>> Här är det visar mig de två
prototyper för funktion,

1507
01:14:36,210 --> 01:14:39,070
så att om jag någonsin vill använda denna
Jag vet vad de tar som indata,

1508
01:14:39,070 --> 01:14:40,652
och vad de återvänder som produktion.

1509
01:14:40,652 --> 01:14:42,360
Och sedan om jag läste
beskrivningen, ser jag

1510
01:14:42,360 --> 01:14:44,820
mer i detalj vad funktionen gör.

1511
01:14:44,820 --> 01:14:48,100
Men ännu viktigare, om
Jag ser i returvärdet,

1512
01:14:48,100 --> 01:14:51,710
det står värdet som returneras är
den för den konverterade brev,

1513
01:14:51,710 --> 01:14:57,880
eller C, den ursprungliga ingången, om
omvandlingen var inte möjligt.

1514
01:14:57,880 --> 01:15:01,992
>> Med andra ord, till den övre kommer att försöka
att konvertera ett brev till versaler.

1515
01:15:01,992 --> 01:15:03,450
Och om så är fallet, kommer det att lämna tillbaka den.

1516
01:15:03,450 --> 01:15:07,010
Men om det inte kan för vissa reason--
kanske är det redan versaler,

1517
01:15:07,010 --> 01:15:09,550
kanske är det ett utropstecken
eller någon annan punctuation--

1518
01:15:09,550 --> 01:15:12,200
det kommer bara att
återlämna originalet C,

1519
01:15:12,200 --> 01:15:17,340
vilket betyder att jag kan göra min kod
bättre utformade på följande sätt.

1520
01:15:17,340 --> 01:15:20,580
>> Jag behöver inte alla
dessa darn kodrader.

1521
01:15:20,580 --> 01:15:22,610
Alla linjer jag har
bara markerad kan

1522
01:15:22,610 --> 01:15:28,700
kollapsas in i bara en enkel
linje, som är this-- printf procent

1523
01:15:28,700 --> 01:15:33,510
c till övre S fäste i.

1524
01:15:33,510 --> 01:15:36,090
Och detta skulle vara en
exempel på bättre design.

1525
01:15:36,090 --> 01:15:40,040
>> Varför genomföra i 7 eller 8 rader
kod, vad det var jag bara

1526
01:15:40,040 --> 01:15:44,960
raderas, när du istället kan kollapsa
allt detta logik och beslutsfattandet

1527
01:15:44,960 --> 01:15:49,620
in en enda rad, 13 nu, som
förlitar sig på ett bibliotek function--

1528
01:15:49,620 --> 01:15:53,430
en funktion som kommer med C, men att
gör exakt vad du vill att den ska göra.

1529
01:15:53,430 --> 01:15:55,295
Och, ärligt talat, även om
Det kom inte med C,

1530
01:15:55,295 --> 01:15:58,880
du kan genomföra det själv, eftersom
vi har sett, med få negativa int

1531
01:15:58,880 --> 01:16:01,700
och få positiv int förra veckan också.

1532
01:16:01,700 --> 01:16:03,470
>> Denna kod är nu mycket lättare att läsa.

1533
01:16:03,470 --> 01:16:06,670
Och faktiskt, om vi rulla upp,
se hur mycket mer kompakt

1534
01:16:06,670 --> 01:16:08,360
denna version av mitt program är.

1535
01:16:08,360 --> 01:16:11,230
Det är en liten topp tung nu,
med alla dessa ingår.

1536
01:16:11,230 --> 01:16:14,380
Men det är OK, eftersom nu jag står
på axlarna av programmerare

1537
01:16:14,380 --> 01:16:15,300
före mig.

1538
01:16:15,300 --> 01:16:18,440
Och vem det var som
genomföras för att övre verkligen

1539
01:16:18,440 --> 01:16:21,470
gjorde mig en tjänst, ungefär som den som
implementeras Stirling verkligen

1540
01:16:21,470 --> 01:16:24,790
gjorde mig en tjänst för en tid sedan.

1541
01:16:24,790 --> 01:16:26,970
Och så har vi nu en
bättre design program

1542
01:16:26,970 --> 01:16:31,680
som implementerar exakt samma logik.

1543
01:16:31,680 --> 01:16:35,580
>> På tal om Stirling, låt
mig gå vidare och göra det.

1544
01:16:35,580 --> 01:16:38,320
Låt mig gå vidare och spara
denna fil som stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Och det visar sig, kan vi dra tillbaka
ett annat skikt ganska enkelt nu.

1546
01:16:43,255 --> 01:16:45,630
Jag kommer att gå vidare och piska
upp ett annat program i huvud

1547
01:16:45,630 --> 01:16:49,759
här som helt enkelt åter-redskap
stränglängd som följer.

1548
01:16:49,759 --> 01:16:52,300
Så här är en kodrad som
får mig en sträng från användaren.

1549
01:16:52,300 --> 01:16:53,910
Vi fortsätter att använda detta om och om igen.

1550
01:16:53,910 --> 01:16:58,900
Låt mig ge mig en variabel som heter
n av typen int som lagrar ett nummer.

1551
01:16:58,900 --> 01:17:02,490
>> Och låt mig gå vidare och
gör följande logik.

1552
01:17:02,490 --> 01:17:15,610
Medan den n: te karaktär is gör
inte lika bakstreck 0, gå vidare

1553
01:17:15,610 --> 01:17:17,930
och öka n.

1554
01:17:17,930 --> 01:17:23,506
Och sedan skriva ut printf procent v.

1555
01:17:23,506 --> 01:17:29,200
Jag hävdar att detta program här,
utan att stränglängd,

1556
01:17:29,200 --> 01:17:31,150
räknar ut längden på en sträng.

1557
01:17:31,150 --> 01:17:34,600
>> Och magin är helt
inkapslad i linje 8

1558
01:17:34,600 --> 01:17:39,830
här med vad som ser ut som ny syntax,
Detta snedstreck 0 i enkla citattecken.

1559
01:17:39,830 --> 01:17:41,360
Men varför är det?

1560
01:17:41,360 --> 01:17:44,100
Tja, överväga vad som varit
pågår hela tiden.

1561
01:17:44,100 --> 01:17:47,990
>> Och som en sidoreplik innan jag glömmer, inser
också att utöver de manualsidorna

1562
01:17:47,990 --> 01:17:50,920
som kommer med en typisk
Linux-system som CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
inse att vi,
Naturligtvis personal, har också

1564
01:17:53,770 --> 01:17:56,030
gjort en webbplats version
av samma idé som kallas

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, som har
alla dessa samma manualsidor,

1566
01:17:59,940 --> 01:18:02,020
allt detta samma
dokumentation, liksom

1567
01:18:02,020 --> 01:18:05,730
en liten låda på toppen som gör att
dig att konvertera alla av ganska

1568
01:18:05,730 --> 01:18:09,025
svårbegripliga språk i mindre bekväm
läge där vi, lärarkåren,

1569
01:18:09,025 --> 01:18:12,150
har gått igenom och försökte att förenkla
några av språket för att hålla saker och ting

1570
01:18:12,150 --> 01:18:14,830
fokuserat på idéer, och inte
några av teknikaliteter.

1571
01:18:14,830 --> 01:18:20,070
Så kom ihåg, reference.cs50.net
som en annan resurs också.

1572
01:18:20,070 --> 01:18:23,800
>> Men varför stränglängd arbete
det sätt jag föreslagit en stund sedan?

1573
01:18:23,800 --> 01:18:25,160
Här är Zamyla namn igen.

1574
01:18:25,160 --> 01:18:27,690
Och här är Zamyla namn
inramad, som jag fortsätta göra,

1575
01:18:27,690 --> 01:18:31,360
att måla en bild av att det är,
egentligen bara en sekvens av tecken.

1576
01:18:31,360 --> 01:18:34,260
Men Zamyla inte existerar
isolerade i ett program.

1577
01:18:34,260 --> 01:18:37,420
>> När du skriver och köra ett program,
du använder din Mac eller PC

1578
01:18:37,420 --> 01:18:40,010
som minne, eller RAM så att säga.

1579
01:18:40,010 --> 01:18:42,620
Och du kan tänka på
din dator ha

1580
01:18:42,620 --> 01:18:44,730
massor av gigabyte minne i dessa dagar.

1581
01:18:44,730 --> 01:18:47,700
Och en spelning betyder miljarder,
så miljarder bytes.

1582
01:18:47,700 --> 01:18:48,910
>> Men låt oss bakåt i tiden.

1583
01:18:48,910 --> 01:18:51,530
Och antar att vi använder
en riktigt gammal dator som

1584
01:18:51,530 --> 01:18:55,150
endast har 32 byte minne.

1585
01:18:55,150 --> 01:18:59,310
Jag kunde på min datorskärm,
helt enkelt dra detta på följande sätt.

1586
01:18:59,310 --> 01:19:05,240
>> Jag kan helt enkelt säga att min
datorn har allt detta minne.

1587
01:19:05,240 --> 01:19:08,830
Och detta är som en pinne av minne, om
ni minns vår bild från förra gången.

1588
01:19:08,830 --> 01:19:11,670
Och om jag delar bara
detta i tillräckligt många gånger,

1589
01:19:11,670 --> 01:19:15,040
Jag hävdar att jag har 32 bytes
minne på skärmen.

1590
01:19:15,040 --> 01:19:18,239
>> Nu, i verkligheten, jag kan bara
dra så långt på den här skärmen här.

1591
01:19:18,239 --> 01:19:20,280
Så jag kommer att gå framåt,
och bara genom konventionen,

1592
01:19:20,280 --> 01:19:24,050
dra datorns minne som en
galler, inte bara som en rak linje.

1593
01:19:24,050 --> 01:19:28,190
Specifikt, hävdar jag nu att
detta nät, detta åtta av fyra galler,

1594
01:19:28,190 --> 01:19:31,800
bara representerar alla 32 byte
tillgängligt minne i min Mac,

1595
01:19:31,800 --> 01:19:33,030
eller finns i min dator.

1596
01:19:33,030 --> 01:19:34,780
Och de är omslag
på två linjer, precis

1597
01:19:34,780 --> 01:19:38,030
eftersom det passar mer på skärmen.

1598
01:19:38,030 --> 01:19:40,800
Men detta är den första bitgruppen.

1599
01:19:40,800 --> 01:19:41,990
Detta är den andra byten.

1600
01:19:41,990 --> 01:19:43,300
Detta är den tredje byte.

1601
01:19:43,300 --> 01:19:45,310
>> Och detta är den 32: a byte.

1602
01:19:45,310 --> 01:19:52,910
Eller, om vi tänka som en dator
forskare, är denna bitgrupp 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Så du har 0-31, om
du börja räkna på 0.

1604
01:19:55,950 --> 01:19:59,830
>> Så om vi använder ett program
att samtal får sträng,

1605
01:19:59,830 --> 01:20:05,280
och vi får en sträng från människa
som jag gjorde kallat Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
hur i hela världen gör
dator hålla reda på vilka byte,

1607
01:20:09,430 --> 01:20:12,230
vilken bit av minne,
som hör till vilken sträng?

1608
01:20:12,230 --> 01:20:16,270
Med andra ord, om vi går vidare till
skriver ett annat namn i datorn,

1609
01:20:16,270 --> 01:20:19,890
så här Andi, ringa
få sträng en andra gång,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I har att hamna i
datorns minne samt.

1611
01:20:23,030 --> 01:20:23,850
Men hur?

1612
01:20:23,850 --> 01:20:29,700
>> Tja, visar det sig att under
huv, vilken C gör vid lagring av strängar

1613
01:20:29,700 --> 01:20:35,080
att de humana typerna i, eller att
komma från någon annan källa, är det

1614
01:20:35,080 --> 01:20:39,190
avgränsar slutet av dem med
en speciell character-- omvänt snedstreck

1615
01:20:39,190 --> 01:20:44,750
0, vilket är bara ett speciellt sätt
att säga 80 bitar i rad.

1616
01:20:44,750 --> 01:20:47,950
>> Så A-- detta är antalet 97 återkallelsen.

1617
01:20:47,950 --> 01:20:51,770
Så vissa mönster av 8 bitar
representerar decimaltal 97.

1618
01:20:51,770 --> 01:20:58,070
Denna backslash 0 är bokstavligen antalet
0, alias nul, N-U-L, till skillnad från tidigare,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, som vi talat om.

1620
01:20:59,630 --> 01:21:05,700
Men nu, bara vet att detta
omvänt snedstreck 0 är bara 80 bitar i en rad.

1621
01:21:05,700 --> 01:21:09,810
>> Och det är just detta rad i
sand som säger något till vänster

1622
01:21:09,810 --> 01:21:12,610
tillhör en sträng, eller en datatyp.

1623
01:21:12,610 --> 01:21:15,480
Och allt till höger
tillhör något annat.

1624
01:21:15,480 --> 01:21:17,440
Andi namn, under tiden,
som just visuellt

1625
01:21:17,440 --> 01:21:21,310
händer att linda på till den andra linjen,
men det är bara en estetisk detalj,

1626
01:21:21,310 --> 01:21:23,990
på liknande sätt nul avslutas.

1627
01:21:23,990 --> 01:21:29,290
>> Det är en sträng av en A-N-D-I tecken,
plus en femte hemlig karaktär,

1628
01:21:29,290 --> 01:21:33,560
alla 0 bitar, som bara avgränsar
I slutet av Andi namn också.

1629
01:21:33,560 --> 01:21:37,120
Och om vi kallar få sträng en tredje gång
i datorn för att få en sträng som

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, är på liknande sätt Marias
namn nul avslutas med backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Detta är fundamentalt annorlunda
från hur en dator skulle typiskt

1632
01:21:47,170 --> 01:21:51,850
lagra ett heltal, eller en flottör, eller annan
datatyper fortfarande, eftersom återkallande,

1633
01:21:51,850 --> 01:21:57,420
ett heltal vanligtvis är 32 bitar, eller
4 byte, eller kanske till och med 64 bitar,

1634
01:21:57,420 --> 01:21:59,100
eller åtta byte.

1635
01:21:59,100 --> 01:22:02,620
Men många primitiva i en dator
i ett programmeringsspråk

1636
01:22:02,620 --> 01:22:05,550
har ett fast antal
bytes under hood--

1637
01:22:05,550 --> 01:22:08,100
kanske en, kanske två, kanske fyra, kanske åtta.

1638
01:22:08,100 --> 01:22:13,250
>> Men strängar, genom sin konstruktion, har en
dynamisk antal tecken.

1639
01:22:13,250 --> 01:22:16,980
Du vet inte i förväg, tills
mänskliga typerna i Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
eller M-A-R-I-A, eller A-N-D-I. Du vet inte
hur många gånger användaren är på väg att slå

1641
01:22:21,400 --> 01:22:22,070
tangentbordet.

1642
01:22:22,070 --> 01:22:26,490
Därför behöver du inte vet hur
många tecken i förväg

1643
01:22:26,490 --> 01:22:27,540
du kommer att behöva.

1644
01:22:27,540 --> 01:22:31,840
>> Och så C bara typ av blad som en
hemliga brödsmula under huven

1645
01:22:31,840 --> 01:22:32,960
vid slutet av strängen.

1646
01:22:32,960 --> 01:22:39,280
Efter lagring Z-A-M-Y-L-A i minne,
det också bara sätter den ekvivalenta

1647
01:22:39,280 --> 01:22:40,210
av en period.

1648
01:22:40,210 --> 01:22:45,060
Vid slutet av en mening,
det sätter 80 bitar, så som

1649
01:22:45,060 --> 01:22:49,120
komma ihåg var
Zamyla börjar och slutar.

1650
01:22:49,120 --> 01:22:51,490
>> Så vad är anslutningen
då detta program?

1651
01:22:51,490 --> 01:22:55,190
Detta program här, Stirling,
är helt enkelt en mekanism

1652
01:22:55,190 --> 01:22:57,970
för att få en sträng
från användaren, rad 6.

1653
01:22:57,970 --> 01:23:01,160
Linje 7, jag deklarera en variabel
kallas n och ställ in den lika med 0.

1654
01:23:01,160 --> 01:23:08,680
>> Och sedan i linje 8, frågade jag helt enkelt
fråga, medan den n: te karaktär gör

1655
01:23:08,680 --> 01:23:12,120
inte lika alla 0 bits--
med andra ord, inte

1656
01:23:12,120 --> 01:23:14,500
lika denna speciella
tecken, bakstreck 0, som

1657
01:23:14,500 --> 01:23:18,470
var bara den speciella nul character--
gå vidare och bara öka n.

1658
01:23:18,470 --> 01:23:21,460
>> Och fortsätta göra det, och hålla
gör det, och fortsätta göra det.

1659
01:23:21,460 --> 01:23:23,430
Och så även om det i
Tidigare har vi har använt i,

1660
01:23:23,430 --> 01:23:25,181
Det är väl bra
semantiskt att använda n,

1661
01:23:25,181 --> 01:23:27,430
om du försöker bara
räkna den här gången medvetet,

1662
01:23:27,430 --> 01:23:28,720
och bara vill kalla det n.

1663
01:23:28,720 --> 01:23:34,720
Så här håller bara ställer frågan,
är den n: te karaktär är alla 0: or?

1664
01:23:34,720 --> 01:23:38,470
Om inte, se till nästa utseende,
ser till nästa, se till nästa,

1665
01:23:38,470 --> 01:23:39,460
ser till nästa.

1666
01:23:39,460 --> 01:23:45,540
>> Men så fort du ser bakstreck 0,
denna loop-- linje 9 genom 11-- stannar.

1667
01:23:45,540 --> 01:23:49,640
Du bryta sig ur while-slingan,
lämnar insidan av denna variabel n

1668
01:23:49,640 --> 01:23:54,530
en total räkning av alla av
tecken i strängen du såg,

1669
01:23:54,530 --> 01:23:55,660
därigenom skriva ut det.

1670
01:23:55,660 --> 01:23:56,760
Så låt oss prova detta.

1671
01:23:56,760 --> 01:23:59,500
>> Låt mig gå vidare och, utan
med hjälp av stirling-funktionen,

1672
01:23:59,500 --> 01:24:04,240
men bara använda min egen hemmagjord version
här kallad stirling, låt mig gå vidare

1673
01:24:04,240 --> 01:24:07,700
och kör stirling, typ i något
som Zamyla, som jag vet i förväg

1674
01:24:07,700 --> 01:24:08,670
är sex tecken.

1675
01:24:08,670 --> 01:24:10,080
Låt oss se om det fungerar.

1676
01:24:10,080 --> 01:24:10,920
I själva verket är det sex.

1677
01:24:10,920 --> 01:24:15,257
Låt oss försöka med Rob, tre tecken,
tre tecken också, och så vidare.

1678
01:24:15,257 --> 01:24:17,340
Så det är allt som händer
på under huven.

1679
01:24:17,340 --> 01:24:19,548
Och lägg märke till anslutningarna
sedan, med den första veckan

1680
01:24:19,548 --> 01:24:22,370
klass, där vi talade om
något i stil med abstraktion,

1681
01:24:22,370 --> 01:24:26,960
vilket är just denna skiktning av idéer, eller
komplexitet, på toppen av grundläggande principer.

1682
01:24:26,960 --> 01:24:30,710
Här, vi slags ser
under huven Stirling,

1683
01:24:30,710 --> 01:24:33,510
så att säga, att räkna ut,
hur skulle det kunna genomföras?

1684
01:24:33,510 --> 01:24:35,232
>> Och vi kunde åter genomföra det själva.

1685
01:24:35,232 --> 01:24:37,440
Men vi kommer aldrig igen kommer
att åter genomföra Stirling.

1686
01:24:37,440 --> 01:24:39,780
Vi kommer bara att
använda stirling i syfte

1687
01:24:39,780 --> 01:24:42,100
att faktiskt få några strängar längd.

1688
01:24:42,100 --> 01:24:44,200
>> Men det finns ingen magi
under huven.

1689
01:24:44,200 --> 01:24:46,716
Om du vet att under
huven, en sträng

1690
01:24:46,716 --> 01:24:48,090
är bara en sekvens av tecken.

1691
01:24:48,090 --> 01:24:51,090
Och att sekvens av tecken
alla kan numeriskt åtgärdas

1692
01:24:51,090 --> 01:24:53,330
med konsol 0, konsol
1, hållare 2, och du

1693
01:24:53,330 --> 01:24:57,420
vet att vid slutet av en sträng är en
specialtecken, kan du räkna ut

1694
01:24:57,420 --> 01:25:01,710
hur man gör de flesta något i en
program, eftersom allt kokar ner till

1695
01:25:01,710 --> 01:25:03,400
läser och skriver minne.

1696
01:25:03,400 --> 01:25:06,130
Det vill säga, att ändra och letar
på minnet, eller flytta saker

1697
01:25:06,130 --> 01:25:10,940
runt i minnet, tryck saker
på skärmen, och så vidare.

1698
01:25:10,940 --> 01:25:14,800
>> Så låt oss nu använda denna nyfunna
förståelse för vad strängar faktiskt

1699
01:25:14,800 --> 01:25:17,910
är under huven, och
skära ner ett annat skikt

1700
01:25:17,910 --> 01:25:20,080
som fram till nu har vi
ignorerat helt och hållet.

1701
01:25:20,080 --> 01:25:22,650
I synnerhet som helst
Vi har genomfört ett program,

1702
01:25:22,650 --> 01:25:25,930
Vi har haft den här kodraden
nära toppen förklara huvud.

1703
01:25:25,930 --> 01:25:27,810
Och vi har angett int main tomrum.

1704
01:25:27,810 --> 01:25:31,240
>> Och detta tomrum inuti parentesen
har sagt hela tiden som huvud

1705
01:25:31,240 --> 01:25:33,440
själv tar inga argument.

1706
01:25:33,440 --> 01:25:36,210
Varje ingång som huvud är
kommer att få från användaren

1707
01:25:36,210 --> 01:25:39,020
måste komma från någon annan
mekanism, som get int,

1708
01:25:39,020 --> 01:25:42,040
eller få flyta, eller få sträng,
eller någon annan funktion.

1709
01:25:42,040 --> 01:25:44,710
Men det visar sig att
när du skriver ett program,

1710
01:25:44,710 --> 01:25:47,690
du faktiskt kan ange
att detta program skall

1711
01:25:47,690 --> 01:25:51,730
ta insignaler från den humana
på kommandoraden själv.

1712
01:25:51,730 --> 01:25:56,310
>> Med andra ord, även om vi hittills
har varit igång just ./hello hej

1713
01:25:56,310 --> 01:26:00,312
eller liknande program, alla i
andra program som vi har använt,

1714
01:26:00,312 --> 01:26:02,770
som vi själva inte skriva,
har tagit, tycks det,

1715
01:26:02,770 --> 01:26:05,210
kommandoraden arguments--
saker som gör.

1716
01:26:05,210 --> 01:26:07,450
Du säger något som make,
och sedan en andra ord.

1717
01:26:07,450 --> 01:26:10,950
Eller klang, säger du klang, och sedan
ett andra ord, namnet på en fil.

1718
01:26:10,950 --> 01:26:14,410
>> Eller ens RM eller CP, som ni kanske
har sett eller använt redan

1719
01:26:14,410 --> 01:26:15,880
att ta bort eller kopiera filer.

1720
01:26:15,880 --> 01:26:18,920
Alla av dem tar så kallade
kommandoraden arguments--

1721
01:26:18,920 --> 01:26:21,130
ytterligare ord på terminalprompt.

1722
01:26:21,130 --> 01:26:23,260
Men fram till nu, vi
själva har inte haft

1723
01:26:23,260 --> 01:26:27,080
denna lyx att ta input från
användaren när han eller hon faktiskt körs

1724
01:26:27,080 --> 01:26:29,120
själva programmet på kommandoraden.

1725
01:26:29,120 --> 01:26:33,710
>> Men vi kan göra det genom att åter förklara
Huvud framåt, inte ha

1726
01:26:33,710 --> 01:26:36,750
ogiltig inom parentes,
men dessa två argument

1727
01:26:36,750 --> 01:26:40,600
instead-- den första ett heltal,
och den andra något

1728
01:26:40,600 --> 01:26:44,170
nytt, något som vi kommer att kalla
en matris, något liknande i anden

1729
01:26:44,170 --> 01:26:49,220
vad vi såg i Scratch som en lista, men
en array med strängar, som vi snart se.

1730
01:26:49,220 --> 01:26:51,790
Men låt oss se detta genom att
hjälp av exempel, innan vi

1731
01:26:51,790 --> 01:26:53,690
urskilja exakt vad det betyder.

1732
01:26:53,690 --> 01:26:56,520
>> Så om jag går in i CS50 IDE
Här har jag gått vidare

1733
01:26:56,520 --> 01:27:01,840
och förklarade i en fil som heter
argv0.c följande mall.

1734
01:27:01,840 --> 01:27:04,120
Och märker enda
som är annorlunda så långt

1735
01:27:04,120 --> 01:27:08,570
är att jag har ändrat ogiltig int
argc sträng argv öppen fäste, nära

1736
01:27:08,570 --> 01:27:09,070
konsol.

1737
01:27:09,070 --> 01:27:11,730
Och lägg märke till nu, det finns
ingenting i dessa konsoler.

1738
01:27:11,730 --> 01:27:12,620
>> Det finns inget nummer.

1739
01:27:12,620 --> 01:27:15,070
Och det finns ingen i, eller
n, eller någon annan bokstav.

1740
01:27:15,070 --> 01:27:17,010
Jag bara använda
hakparenteser för nu,

1741
01:27:17,010 --> 01:27:19,510
av skäl som vi kommer
tillbaka i ett ögonblick.

1742
01:27:19,510 --> 01:27:21,330
>> Och nu vad jag ska göra är det.

1743
01:27:21,330 --> 01:27:26,680
Om argc lika med lika med 2--
och erinrar om att lika jämlikar

1744
01:27:26,680 --> 01:27:30,040
är jämställdhets operatör jämföra
vänster och höger för jämställdhet.

1745
01:27:30,040 --> 01:27:31,790
Det är inte uppdraget
operatör, vilket är

1746
01:27:31,790 --> 01:27:36,510
den enda likhetstecknet, vilket innebär kopia
från höger till vänster ett visst värde.

1747
01:27:36,510 --> 01:27:42,840
>> Om argc lika är lika med 2, vill jag
säg, printf, hej, procent, ny rad,

1748
01:27:42,840 --> 01:27:47,340
och sedan koppla in-- och här är den nya
trick-- argv bygel 1, av skäl som

1749
01:27:47,340 --> 01:27:48,840
att vi ska återkomma till om en stund.

1750
01:27:48,840 --> 01:27:52,110
Else if argc inte
lika 2, vet du vad?

1751
01:27:52,110 --> 01:27:57,400
Låt oss gå vidare och, som vanligt, tryck
ut Hello World utan ersättning.

1752
01:27:57,400 --> 01:28:02,710
>> Så det verkar som om argc, som
står för argument räkna, är lika med 2,

1753
01:28:02,710 --> 01:28:04,740
Jag kommer att skriva ut
hej något eller annat.

1754
01:28:04,740 --> 01:28:07,560
Annars, som standard, jag är
tryckningen hallå världen.

1755
01:28:07,560 --> 01:28:08,770
Så vad betyder det?

1756
01:28:08,770 --> 01:28:15,550
>> Nåväl, låt mig gå vidare och spara
den här filen, och sedan göra göra argv0,

1757
01:28:15,550 --> 01:28:18,940
och sedan ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Och det säger Hej världen.

1759
01:28:20,300 --> 01:28:21,260
Nu, varför är det?

1760
01:28:21,260 --> 01:28:24,730
>> Tja, visar det sig när du
köra ett program på kommandoraden,

1761
01:28:24,730 --> 01:28:29,570
du fyller i vad vi ska
i allmänhet kallar ett argument vektor.

1762
01:28:29,570 --> 01:28:33,100
Med andra ord, automatiskt
dator, operativsystem,

1763
01:28:33,100 --> 01:28:38,340
kommer att lämna till ditt program
själv en lista över alla ord

1764
01:28:38,340 --> 01:28:40,850
att människan skrivit på
prompten om du

1765
01:28:40,850 --> 01:28:43,790
programmeraren vill göra
något med denna information.

1766
01:28:43,790 --> 01:28:48,540
Och i detta fall, det enda ord
Jag har skrivit vid prompten är ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Och så antalet argument som är
som skickas till mitt program är bara en.

1768
01:28:55,420 --> 01:28:58,880
Med andra ord, det argument
räkna, annars känd som argc

1769
01:28:58,880 --> 01:29:00,970
här som ett heltal, är bara en.

1770
01:29:00,970 --> 01:29:03,000
En naturligtvis inte är lika två.

1771
01:29:03,000 --> 01:29:05,980
Och så detta är vad skriver, hallå världen.

1772
01:29:05,980 --> 01:29:08,170
>> Men låt mig ta någonstans.

1773
01:29:08,170 --> 01:29:09,930
Låt mig säga, argv0.

1774
01:29:09,930 --> 01:29:12,740
Och sedan hur om Maria?

1775
01:29:12,740 --> 01:29:14,990
Och då slå Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Och lägg märke till vad magiskt händer här.

1777
01:29:18,020 --> 01:29:22,640
Nu, i stället för Hello World, har jag
förändrat beteende för detta program

1778
01:29:22,640 --> 01:29:26,310
genom att ingången inte från get
sträng eller någon annan funktion,

1779
01:29:26,310 --> 01:29:30,570
men från tydligen mitt kommando
själv, vad jag ursprungligen skrivits in.

1780
01:29:30,570 --> 01:29:35,720
Och jag kan spela det här spelet igen genom
ändra den till Stelios, till exempel.

1781
01:29:35,720 --> 01:29:38,400
>> Och nu ser jag ett annat namn fortfarande.

1782
01:29:38,400 --> 01:29:40,540
Och här kan jag säga Andi.

1783
01:29:40,540 --> 01:29:42,137
Och jag kan säga Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Och vi kan spela detta spel hela dagen lång,
bara koppla in olika värden,

1785
01:29:45,220 --> 01:29:49,550
så länge jag ger exakt
två ord på snabba,

1786
01:29:49,550 --> 01:29:52,260
så att argc, mitt argument räkna, är två.

1787
01:29:52,260 --> 01:29:57,240
>> Ser jag det namnet ansluten till
printf, per detta villkor här?

1788
01:29:57,240 --> 01:30:00,550
Så verkar vi ha nu
uttrycksförmåga

1789
01:30:00,550 --> 01:30:04,410
av att ta input från en annan mekanism,
från den så kallade kommandorad,

1790
01:30:04,410 --> 01:30:07,000
stället för att behöva vänta
tills användaren kör programmet,

1791
01:30:07,000 --> 01:30:10,220
och sedan be honom eller henne
med hjälp av något som få sträng.

1792
01:30:10,220 --> 01:30:11,230
>> Så vad är detta?

1793
01:30:11,230 --> 01:30:15,010
Argc, återigen, är bara ett heltal,
antalet words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
att användaren tillhandahålls vid
prompt, på terminalfönstret,

1795
01:30:18,540 --> 01:30:20,110
inklusive programmets namn.

1796
01:30:20,110 --> 01:30:23,340
Så vår ./argv0 är effektivt,
programmets namn,

1797
01:30:23,340 --> 01:30:24,520
eller hur jag köra programmet.

1798
01:30:24,520 --> 01:30:25,810
>> Som räknas som ett ord.

1799
01:30:25,810 --> 01:30:27,080
Så argc skulle vara ett.

1800
01:30:27,080 --> 01:30:29,750
Men när jag skriver Stelios, eller
Andi, eller Zamyla eller Maria,

1801
01:30:29,750 --> 01:30:31,660
det betyder argumentet räkningen är två.

1802
01:30:31,660 --> 01:30:33,910
Och så nu finns det två ord passerade i.

1803
01:30:33,910 --> 01:30:36,070
>> Och varsel, kan vi fortsätta denna logik.

1804
01:30:36,070 --> 01:30:39,050
Om jag faktiskt säga
något i stil Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
ett fullständigt namn, och därmed passerar
tre argument totalt,

1806
01:30:42,200 --> 01:30:47,410
Nu står det standard igen,
eftersom naturligtvis 3 inte är lika 2.

1807
01:30:47,410 --> 01:30:54,080
>> Och så på det här sättet, jag har
åtkomst via argv denna nya argument

1808
01:30:54,080 --> 01:30:56,080
att vi kunde tekniskt
kalla vad vi vill.

1809
01:30:56,080 --> 01:30:58,940
Men enligt praxis, är det
argv och argc, respektive.

1810
01:30:58,940 --> 01:31:04,470
Argv, argument vektor, är snäll
av en synonym för ett programmeringsspråk

1811
01:31:04,470 --> 01:31:07,140
funktion i C kallas en array.

1812
01:31:07,140 --> 01:31:14,410
>> En array är en lista med liknande värden
tillbaka mot rygg, mot rygg, mot rygg.

1813
01:31:14,410 --> 01:31:17,810
Med andra ord, om man är rätt här i
RAM, är nästa intill det,

1814
01:31:17,810 --> 01:31:18,800
och precis intill den.

1815
01:31:18,800 --> 01:31:20,101
De är inte överallt.

1816
01:31:20,101 --> 01:31:23,100
Och det senare scenariot, där saker och ting
är överallt i minnet,

1817
01:31:23,100 --> 01:31:25,082
kan faktiskt vara ett kraftfullt verktyg.

1818
01:31:25,082 --> 01:31:28,040
Men vi kommer tillbaka till det när vi
tala om finare datastrukturer.

1819
01:31:28,040 --> 01:31:32,260
För nu, är en matris bara en
bit av sammanhängande minne,

1820
01:31:32,260 --> 01:31:36,520
var och en av vars element är
tillbaka mot rygg, att backa, backa,

1821
01:31:36,520 --> 01:31:38,050
och i allmänhet samma typ.

1822
01:31:38,050 --> 01:31:42,630
>> Så om du tycker om, från en
nyss, vad är en sträng?

1823
01:31:42,630 --> 01:31:50,460
Tja, en sträng, som Zamyla,
Z-A-M-Y-L-A, är tekniskt,

1824
01:31:50,460 --> 01:31:51,400
bara en array.

1825
01:31:51,400 --> 01:31:53,700
Det är en matris med tecken.

1826
01:31:53,700 --> 01:31:59,250
>> Och så om vi verkligen dra detta, eftersom jag
gjorde tidigare, som en bit av minne,

1827
01:31:59,250 --> 01:32:04,510
det visar sig att var och en av dessa
tecken tar upp en byte.

1828
01:32:04,510 --> 01:32:07,630
Och så finns det den speciella
sentinel karaktär, bakstreck 0,

1829
01:32:07,630 --> 01:32:12,360
eller alla åtta 0 bitar, som
avgränsar slutet av strängen.

1830
01:32:12,360 --> 01:32:15,090
Så en sträng, visar det
ut, citerar unquote sträng,

1831
01:32:15,090 --> 01:32:20,580
är bara en array av chara--
char vara en verklig datatyp.

1832
01:32:20,580 --> 01:32:24,560
>> Och nu argv, meanwhile--
Låt oss gå tillbaka till programmet.

1833
01:32:24,560 --> 01:32:29,582
Argv, även om vi ser ordet
sträng här är inte en sträng själv.

1834
01:32:29,582 --> 01:32:33,640
Argv, argument vektor,
är en array med strängar.

1835
01:32:33,640 --> 01:32:37,620
>> Så precis som du kan ha en rad
tecken, kan du ha högre nivå,

1836
01:32:37,620 --> 01:32:46,279
en matris med strings-- så, till exempel,
när jag skrev nyss ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, utrymme Z-A-M-Y-L-A, hävdade jag att
argv hade två strängar i det-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
och Z-A-M-Y-L-A. I
andra ord, var argc 2.

1839
01:33:03,185 --> 01:33:03,980
Varför är det så?

1840
01:33:03,980 --> 01:33:08,370
>> Jo, på ett effektivt sätt, är vad händer
på är att var och en av dessa strängar

1841
01:33:08,370 --> 01:33:13,990
är, naturligtvis, en matris med tecken
som tidigare, vars samtliga tecken

1842
01:33:13,990 --> 01:33:15,670
tar upp en byte.

1843
01:33:15,670 --> 01:33:19,720
Och inte förväxla den faktiska 0
i programmets namn med 0,

1844
01:33:19,720 --> 01:33:22,040
vilket innebär att alla 80 bitar.

1845
01:33:22,040 --> 01:33:27,140
Och Zamyla, under tiden, är fortfarande
också en rad tecken.

1846
01:33:27,140 --> 01:33:31,450
>> Så i slutet av dagen, det är verkligen
ser ut så här under huven.

1847
01:33:31,450 --> 01:33:38,800
Men ArGV, som på grund av hur huvud
verk, tillåter mig att svepa allt detta

1848
01:33:38,800 --> 01:33:44,810
upp till, om man så vill, en större samling
att om vi drygt förenkla

1849
01:33:44,810 --> 01:33:48,180
hur bilden ser ut och inte
helt dra det att skala upp det,

1850
01:33:48,180 --> 01:33:56,720
denna samling är bara storlek 2, den första
element, som innehåller en sträng,

1851
01:33:56,720 --> 01:33:59,230
den andra delen av
vilken innehåller en sträng.

1852
01:33:59,230 --> 01:34:01,687
Och i sin tur, om du
typ av zooma in på varje

1853
01:34:01,687 --> 01:34:03,770
av dessa strängar, vad du
se under huven

1854
01:34:03,770 --> 01:34:07,190
är att varje sträng är bara
en array av tecken.

1855
01:34:07,190 --> 01:34:11,680
>> Nu, precis som med strängar,
vi skulle kunna få tillgång

1856
01:34:11,680 --> 01:34:15,260
till den i: te tecknet i en sträng
använder den hakparentes notation.

1857
01:34:15,260 --> 01:34:17,320
På liknande sätt, med arrayer
I allmänhet kan vi

1858
01:34:17,320 --> 01:34:22,700
använda klammer notation för att få
på valfritt antal strängar i en matris?

1859
01:34:22,700 --> 01:34:25,100
Till exempel, låt mig
gå vidare och göra det.

1860
01:34:25,100 --> 01:34:32,420
>> Låt mig gå vidare och skapa argv1.c,
som är lite annorlunda den här gången.

1861
01:34:32,420 --> 01:34:35,635
I stället för att kontrollera om argc2,
Jag ska istället göra detta.

1862
01:34:35,635 --> 01:34:41,270
För int jag får 0, är ​​jag mindre
än argc, jag plus plus,

1863
01:34:41,270 --> 01:34:47,920
och sedan skriva ut insidan av denna,
procent s, ny rad, och sedan

1864
01:34:47,920 --> 01:34:50,740
argv fäste i.

1865
01:34:50,740 --> 01:34:55,220
>> Så med andra ord, jag är inte att göra med
enskilda tecken för tillfället.

1866
01:34:55,220 --> 01:35:00,190
Argv, vilket antyds av dessa tom ruta
hängslen till höger om namnet argv,

1867
01:35:00,190 --> 01:35:03,320
innebär argv är en array med strängar.

1868
01:35:03,320 --> 01:35:04,870
Och argc är bara en int.

1869
01:35:04,870 --> 01:35:08,800
>> Denna linje här, 6, är
säger uppsättning i lika med 0.

1870
01:35:08,800 --> 01:35:11,980
Räkna hela vägen upp till,
men inte inklusive, argc.

1871
01:35:11,980 --> 01:35:14,010
Och sedan på varje iteration,
skriva ut en sträng.

1872
01:35:14,010 --> 01:35:14,800
Vilken sträng?

1873
01:35:14,800 --> 01:35:17,270
>> Den i: te sträng i argv.

1874
01:35:17,270 --> 01:35:19,530
Så medan innan jag var
med hjälp av hakparentes

1875
01:35:19,530 --> 01:35:22,180
notation för att komma åt den i: te
tecken i en sträng, nu

1876
01:35:22,180 --> 01:35:27,240
Jag använder klammer notation
för att komma åt den i: te strängen i en array.

1877
01:35:27,240 --> 01:35:30,310
Så det är typ av ett skikt
ovan, konceptuellt.

1878
01:35:30,310 --> 01:35:35,390
>> Och så vad är snyggt om detta
program nu, om jag sammanställa argv1,

1879
01:35:35,390 --> 01:35:42,067
och sedan göra ./argv1, och skriv sedan
i något som foo bar Baz

1880
01:35:42,067 --> 01:35:45,400
vilka är de tre standard ord som en
datavetare sträcker sig efter helst

1881
01:35:45,400 --> 01:35:51,010
han eller hon behöver några platshållare ord,
och tryck Enter, vart och ett av dessa ord,

1882
01:35:51,010 --> 01:35:54,980
inklusive programmets namn, som
är i argv i det första läget,

1883
01:35:54,980 --> 01:35:58,320
hamnar skrivs ut en i taget.

1884
01:35:58,320 --> 01:36:05,290
Och om jag ändrar detta, och jag säger
något liknande argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
Vi får alla tre av dem
ord, vilket är argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, eftersom detta
fall argc, räkningen, är tre.

1887
01:36:14,400 --> 01:36:20,020
>> Men vad som är snyggt är om du förstår
att argv är bara en array med strängar,

1888
01:36:20,020 --> 01:36:24,910
och du förstår att en sträng
är en rad tecken,

1889
01:36:24,910 --> 01:36:29,470
Vi kan faktiskt typ av använda
klammer notation flera gånger

1890
01:36:29,470 --> 01:36:33,320
att välja en sträng, och sedan välja
ett tecken i strängen,

1891
01:36:33,320 --> 01:36:35,730
dykning i djupare enligt följande.

1892
01:36:35,730 --> 01:36:40,100
I detta exempel, låt mig gå
framåt och kallar detta argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Och i det här exemplet, låt mig gå vidare
och gör following-- för int jag får 0,

1895
01:36:50,180 --> 01:36:53,286
i är mindre än argc, i plus
plus, precis som förut.

1896
01:36:53,286 --> 01:36:55,910
Så i andra words-- och nu detta
får tillräckligt komplicerat.

1897
01:36:55,910 --> 01:36:59,940
Då kommer jag att säga
iterera över strängar i argv,

1898
01:36:59,940 --> 01:37:01,294
som en kommentar till mig själv.

1899
01:37:01,294 --> 01:37:03,960
Och då jag kommer att ha en
kapslade för loop, som du antagligen

1900
01:37:03,960 --> 01:37:06,290
har gjort, eller anses
gör, i Scratch, där

1901
01:37:06,290 --> 01:37:08,600
Jag kommer att säga int-- jag
inte kommer att använda i igen,

1902
01:37:08,600 --> 01:37:12,590
eftersom jag inte vill skugga, eller
sorts över den befintliga i.

1903
01:37:12,590 --> 01:37:15,780
>> Jag ska i stället säga j, eftersom
det är min gå till variabel när jag,

1904
01:37:15,780 --> 01:37:18,590
när jag försöker bara
räkna enkla siffror.

1905
01:37:18,590 --> 01:37:28,850
För j får 0-- och även n, kommer att
få aktern längd argv fäste i,

1906
01:37:28,850 --> 01:37:36,030
så länge som j är mindre än m,
j plus plus, gör följande.

1907
01:37:36,030 --> 01:37:37,500
Och här är den intressanta delen.

1908
01:37:37,500 --> 01:37:46,330
>> Skriv ut en karaktär och en ny linje,
koppla in argv fäste i, fäste j.

1909
01:37:46,330 --> 01:37:47,940
OK, så låt mig lägga till några kommentarer här.

1910
01:37:47,940 --> 01:37:54,820
Iterera över tecken
i nuvarande sträng,

1911
01:37:54,820 --> 01:38:02,290
print j: te karaktär i i-te sträng.

1912
01:38:02,290 --> 01:38:04,630
Så nu, låt oss betrakta
vad dessa kommentarer betyder.

1913
01:38:04,630 --> 01:38:06,750
>> Iterera över strängarna
i argv-- hur många

1914
01:38:06,750 --> 01:38:09,300
strängar är i argv, som är en array?

1915
01:38:09,300 --> 01:38:13,420
Argc många, så jag iteration
från i lika 0 upp till argc.

1916
01:38:13,420 --> 01:38:20,020
Under tiden, hur många tecken
är i den i: te strängen i argv?

1917
01:38:20,020 --> 01:38:22,880
>> Jo, för att få det svaret,
Jag kallar bara stränglängd

1918
01:38:22,880 --> 01:38:26,810
på den aktuella strängen I vård
om, vilket är argv fäste i.

1919
01:38:26,810 --> 01:38:30,090
Och jag kommer att tillfälligt lagra att
värde i n, bara för caching ändamål,

1920
01:38:30,090 --> 01:38:31,590
att komma ihåg det för effektivitet.

1921
01:38:31,590 --> 01:38:36,330
Och sedan ska jag initiera j till 0,
fortsätt så länge j är mindre än n,

1922
01:38:36,330 --> 01:38:38,430
och på varje iteration ökning j.

1923
01:38:38,430 --> 01:38:41,030
>> Och sedan här, per
min kommentar på linje 12,

1924
01:38:41,030 --> 01:38:43,390
skriva ut ett tecken,
följt av en ny rad,

1925
01:38:43,390 --> 01:38:48,140
specifikt argv fäste
Jag ger mig i: te sträng

1926
01:38:48,140 --> 01:38:51,690
i argv-- så det första ordet, det
andra ord, det tredje ordet, vad som helst.

1927
01:38:51,690 --> 01:38:57,370
Och sedan j dyk i djupare och får
mig j: te karaktär det ordet.

1928
01:38:57,370 --> 01:39:02,200
Och så, i själva verket, du kan behandla
argv som en flerdimensionell,

1929
01:39:02,200 --> 01:39:06,050
som en två-dimensionell, array,
varvid varje ord slags utseende

1930
01:39:06,050 --> 01:39:08,580
så här i ditt sinne
ögat, och varje tecken

1931
01:39:08,580 --> 01:39:10,930
är typ av sammansatt
en kolumn, om det hjälper.

1932
01:39:10,930 --> 01:39:13,260
>> I verkligheten, när vi retas
Detta lägenhets i kommande veckor,

1933
01:39:13,260 --> 01:39:15,580
det kommer att vara lite
mer sofistikerade än så.

1934
01:39:15,580 --> 01:39:17,800
Men du kan verkligen
tänker på det, för nu,

1935
01:39:17,800 --> 01:39:22,110
som just detta tvådimensionella
array, varvid en nivå av det

1936
01:39:22,110 --> 01:39:23,260
är alla strängarna.

1937
01:39:23,260 --> 01:39:26,760
Och sedan om du dyker djupare, du
kan komma åt de enskilda tecknen

1938
01:39:26,760 --> 01:39:29,600
däri med hjälp av denna notation här.

1939
01:39:29,600 --> 01:39:31,620
>> Så vad är nettoeffekten?

1940
01:39:31,620 --> 01:39:34,970
Låt mig gå vidare och
göra argv2-- darn den.

1941
01:39:34,970 --> 01:39:36,210
Jag gjorde ett misstag här.

1942
01:39:36,210 --> 01:39:40,160
Underförstått att förklara
biblioteksfunktion Stirling.

1943
01:39:40,160 --> 01:39:42,190
Så hela tiden, är det
kanske lämpligt

1944
01:39:42,190 --> 01:39:45,130
att vi typ av efterbehandling
exakt där vi började.

1945
01:39:45,130 --> 01:39:48,160
>> Jag skruvas upp, underförstått att förklara
biblioteksfunktion Stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, vänta en minut.

1947
01:39:48,987 --> 01:39:51,070
Jag minns att särskilt
eftersom det är just här.

1948
01:39:51,070 --> 01:39:54,490
Jag måste inkludera string.h i
denna version av programmet.

1949
01:39:54,490 --> 01:40:00,050
>> Låt mig gå vidare och inkludera
string.h, förutom att gå vidare

1950
01:40:00,050 --> 01:40:04,460
och kompilera argv2.

1951
01:40:04,460 --> 01:40:08,390
Och nu, här går vi, göra argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Och även om det är lite
kryptiskt vid första anblicken,

1953
01:40:10,590 --> 01:40:15,690
märka det, ja, vad
skrivs är punkt argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Men om jag skriver några ord efter
prompten som argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Ange också lite
kryptiskt vid första anblicken.

1956
01:40:22,560 --> 01:40:30,540
Men om vi rulla tillbaka upp,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Så vi har itereras över varje ord.

1958
01:40:32,190 --> 01:40:37,770
Och i sin tur, har vi itereras över
varje tecken inom ett ord.

1959
01:40:37,770 --> 01:40:40,040
>> Nu, efter allt detta,
inse att det finns

1960
01:40:40,040 --> 01:40:43,120
en annan detalj som vi har varit snäll
ignorera hela tiden.

1961
01:40:43,120 --> 01:40:46,180
Vi retad bara ifrån varandra vad
huvudsakliga ingångar kan vara?

1962
01:40:46,180 --> 01:40:47,780
Vad om huvud produktion?

1963
01:40:47,780 --> 01:40:50,540
>> Hela denna tid har vi varit
bara kopiera och klistra in

1964
01:40:50,540 --> 01:40:53,870
ordet int framför huvud,
om du kan se på nätet,

1965
01:40:53,870 --> 01:40:58,340
ibland felaktigt i äldre versioner
C och kompilatorer, att de säger tomrum,

1966
01:40:58,340 --> 01:40:59,410
eller ingenting alls.

1967
01:40:59,410 --> 01:41:01,580
Men, faktiskt, för den version
C som vi använder,

1968
01:41:01,580 --> 01:41:06,180
C 11, eller 2011, inser
att det bör vara int.

1969
01:41:06,180 --> 01:41:09,300
Och det bör antingen vara
ogiltig eller argc och ArGV här.

1970
01:41:09,300 --> 01:41:10,790
>> Men varför int main?

1971
01:41:10,790 --> 01:41:12,480
Vad är det egentligen att återvända?

1972
01:41:12,480 --> 01:41:16,280
Tja, visar det sig all denna tid,
helst du har skrivit ett program huvud

1973
01:41:16,280 --> 01:41:18,440
alltid återvänder något.

1974
01:41:18,440 --> 01:41:19,960
Men det har varit att göra så i hemlighet.

1975
01:41:19,960 --> 01:41:23,350
>> Att något är en
int, som linje 5 antyder.

1976
01:41:23,350 --> 01:41:24,225
Men vad int?

1977
01:41:24,225 --> 01:41:26,100
Tja, det är det här
konvent i programmering,

1978
01:41:26,100 --> 01:41:29,790
varvid om ingenting har
gått fel och allt är väl,

1979
01:41:29,790 --> 01:41:34,250
program och funktioner i allmänhet
return-- något counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 innebär i allmänhet allt är väl.

1982
01:41:38,070 --> 01:41:40,610
Så även om du tänker på
det som falskt i många sammanhang,

1983
01:41:40,610 --> 01:41:42,930
det faktiskt innebär i allmänhet en bra sak

1984
01:41:42,930 --> 01:41:49,560
>> Samtidigt, om ett program returnerar 1,
eller negativt 1, eller 5, eller negativ 42,

1985
01:41:49,560 --> 01:41:52,941
eller icke-0 värde,
som i allmänhet betecknar

1986
01:41:52,941 --> 01:41:54,190
att något har gått fel.

1987
01:41:54,190 --> 01:41:56,700
I själva verket, på din egen Mac eller PC,
du kanske har faktiskt sett

1988
01:41:56,700 --> 01:42:01,050
ett felmeddelande, varigenom det
säger något eller andra fel

1989
01:42:01,050 --> 01:42:04,940
kod negativ 42, eller felkod
23, eller något liknande.

1990
01:42:04,940 --> 01:42:08,980
Det antalet är i allmänhet bara en antydan
till programmeraren, eller företaget

1991
01:42:08,980 --> 01:42:11,174
som gjorde programmet,
vad som gick fel och varför,

1992
01:42:11,174 --> 01:42:13,590
så att de kan titta igenom
deras dokumentation eller kod,

1993
01:42:13,590 --> 01:42:15,465
och räkna ut vad
fel egentligen innebär.

1994
01:42:15,465 --> 01:42:18,400
Det är i allmänhet inte
användbar för oss slutanvändare.

1995
01:42:18,400 --> 01:42:20,550
>> Men när huvud avkastning 0, är ​​allt väl.

1996
01:42:20,550 --> 01:42:23,770
Och om du inte anger
vad huvud skulle återvända,

1997
01:42:23,770 --> 01:42:26,950
det kommer bara automatiskt
tillbaka 0 för dig.

1998
01:42:26,950 --> 01:42:30,870
Men återvänder något
annars är faktiskt användbart.

1999
01:42:30,870 --> 01:42:34,660
>> I denna sista program, låt mig
gå vidare och kallar detta exit.c,

2000
01:42:34,660 --> 01:42:38,630
och införa det sista av dagens
ämnen, så kallade en felkod.

2001
01:42:38,630 --> 01:42:42,930
Låt mig gå vidare och inkludera vår
välbekanta filer där uppe, gör int main.

2002
01:42:42,930 --> 01:42:49,500
Och den här gången, låt oss göra int argc,
sträng argv, och med mina konsoler

2003
01:42:49,500 --> 01:42:50,836
att innebära att det är i gruppen.

2004
01:42:50,836 --> 01:42:52,460
Och låt mig bara göra en sanity check.

2005
01:42:52,460 --> 01:42:56,640
Den här gången, om argc inte
lika 2, då vet du vad?

2006
01:42:56,640 --> 01:42:57,520
Glöm det.

2007
01:42:57,520 --> 01:43:03,170
Jag kommer att säga att, hey, användare,
du saknar Kommandoradsargumentet

2008
01:43:03,170 --> 01:43:04,210
bakåtstreck n.

2009
01:43:04,210 --> 01:43:05,230
>> Och då är det.

2010
01:43:05,230 --> 01:43:06,130
Jag vill avsluta.

2011
01:43:06,130 --> 01:43:11,030
Jag kommer att i förebyggande syfte,
och i förtid verkligen, retur

2012
01:43:11,030 --> 01:43:12,810
något annat än antalet 1.

2013
01:43:12,810 --> 01:43:15,360
Gå till värdet för den första
fel som kan hända är en.

2014
01:43:15,360 --> 01:43:17,860
Om du har någon annan felaktig
situation som kan uppstå,

2015
01:43:17,860 --> 01:43:21,390
skulle man kunna säga retur två eller returnera 3, eller
kanske till och med negativ en eller negativ 2.

2016
01:43:21,390 --> 01:43:23,750
>> Dessa är bara slutkoder
som är, i allmänhet,

2017
01:43:23,750 --> 01:43:27,770
endast användbar till programmeraren, eller
företag som är sjöfarten programvaran.

2018
01:43:27,770 --> 01:43:30,500
Men det faktum att det är
inte 0 är vad som är viktigt.

2019
01:43:30,500 --> 01:43:34,310
Så om i det här programmet, jag vill
garantera att detta program endast

2020
01:43:34,310 --> 01:43:38,190
fungerar om användaren ger mig
med ett argument räkna till två,

2021
01:43:38,190 --> 01:43:42,880
namnet på programmet, och några andra
ord, kan jag genomdriva så mycket som följer,

2022
01:43:42,880 --> 01:43:46,110
skrika på användaren med printf säger,
saknas kommandorad argument,

2023
01:43:46,110 --> 01:43:46,970
tillbaka en.

2024
01:43:46,970 --> 01:43:49,940
Det kommer bara omedelbart
avsluta programmet.

2025
01:43:49,940 --> 01:43:55,840
>> Endast om argc är lika med 2 kommer vi att få ner
här, då jag tänker säga,

2026
01:43:55,840 --> 01:44:00,410
hello procent s, omvänt snedstreck n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Med andra ord, jag är
inte gå efter argv 0,

2028
01:44:03,827 --> 01:44:05,410
vilket är bara namnet på programmet.

2029
01:44:05,410 --> 01:44:09,450
Jag vill skriva ut Hej, komma,
det andra ordet som det mänskliga maskinskrivna.

2030
01:44:09,450 --> 01:44:12,580
Och i detta fall på
linje 13, är allt väl.

2031
01:44:12,580 --> 01:44:15,920
>> Jag vet att argc är 2
logiskt från detta program.

2032
01:44:15,920 --> 01:44:17,770
Jag kommer att gå vidare och åter 0.

2033
01:44:17,770 --> 01:44:21,230
Som en sidoreplik, tänk på att
detta är sant i Scratch också.

2034
01:44:21,230 --> 01:44:24,760
>> Logiskt sett kan jag göra detta
och kapsla in dessa rader

2035
01:44:24,760 --> 01:44:27,020
kod i denna annars klausul här.

2036
01:44:27,020 --> 01:44:29,420
Men det är typ av
onödan dra in min kod.

2037
01:44:29,420 --> 01:44:31,800
Och jag vill göra super
klart att oavsett vad,

2038
01:44:31,800 --> 01:44:34,670
som standard, hej
något kommer att skrivas,

2039
01:44:34,670 --> 01:44:36,050
så länge som användaren samverkar.

2040
01:44:36,050 --> 01:44:39,360
>> Så det är mycket vanligt att använda
ett tillstånd, bara en om,

2041
01:44:39,360 --> 01:44:41,870
att fånga några felaktiga
situation, och sedan avsluta.

2042
01:44:41,870 --> 01:44:45,690
Och då är så länge alla
väl, inte har ett annat,

2043
01:44:45,690 --> 01:44:48,060
men bara har koden
utanför att om eftersom det är

2044
01:44:48,060 --> 01:44:51,060
motsvarande i detta
särskilda fall, logiskt.

2045
01:44:51,060 --> 01:44:54,480
Så jag återvänder 0, bara för att
uttryckligen betyda allt är väl.

2046
01:44:54,480 --> 01:44:58,480
>> Om jag utelämnade avkastningen 0, skulle det
automatiskt antas för mig.

2047
01:44:58,480 --> 01:45:00,890
Men nu när jag återvänder
en i åtminstone det här fallet,

2048
01:45:00,890 --> 01:45:04,940
Jag ska, för bra åtgärd och
klarhet, åter 0 i detta fall.

2049
01:45:04,940 --> 01:45:09,690
Så låt mig nu gå vidare och göra exit,
som är en perfekt SEGUE att bara lämna.

2050
01:45:09,690 --> 01:45:14,401
>> Men göra exit, och låt mig gå
vidare och göra ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Och programmet skrek åt mig,
saknas kommandorad argument.

2052
01:45:16,900 --> 01:45:18,120
OK, låt mig samarbeta.

2053
01:45:18,120 --> 01:45:23,810
>> Låt mig i stället göra ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Och nu säger hej David.

2055
01:45:25,190 --> 01:45:27,300
Och du skulle inte normalt ser detta.

2056
01:45:27,300 --> 01:45:30,650
>> Men det visar sig att det finns en
speciellt sätt i Linux för att faktiskt se

2057
01:45:30,650 --> 01:45:34,470
med vilken utgång kod ett program avslutas.

2058
01:45:34,470 --> 01:45:37,184
Ibland i ett grafiskt
värld som Mac OS eller Windows,

2059
01:45:37,184 --> 01:45:40,100
du bara ser dessa siffror när en
felmeddelande dyker upp på skärmen

2060
01:45:40,100 --> 01:45:41,940
och programmeraren
visar det numret.

2061
01:45:41,940 --> 01:45:44,773
Men om vi vill se vad felet
meddelande är, vi kan göra det här--

2062
01:45:44,773 --> 01:45:48,100
så ./exit, Enter, tryck
saknas kommandorad argument.

2063
01:45:48,100 --> 01:45:54,590
>> Om jag nu gör echo $ ?, som är
löjligt kryptiska ser.

2064
01:45:54,590 --> 01:45:56,590
Men $?

2065
01:45:56,590 --> 01:45:59,220
är den magiska besvärjelse
som säger, hej, dator,

2066
01:45:59,220 --> 01:46:01,900
berätta vad den tidigare
programmets slutkoden var.

2067
01:46:01,900 --> 01:46:03,410
Och jag trycker på Retur.

2068
01:46:03,410 --> 01:46:07,520
Jag ser en, eftersom det är vad jag
berättade min huvuduppgift att återvända.

2069
01:46:07,520 --> 01:46:12,310
>> Under tiden, om jag gör ./exit David,
och tryck Enter, ser jag, hej David.

2070
01:46:12,310 --> 01:46:16,800
Och om jag nu gör echo $ ?, jag hej 0.

2071
01:46:16,800 --> 01:46:19,080
Och så här kommer faktiskt
vara värdefull information

2072
01:46:19,080 --> 01:46:23,420
inom ramen för den debugger, inte så
mycket att du är människa, skulle bry sig.

2073
01:46:23,420 --> 01:46:26,060
Men debugger och andra
program vi kommer att använda denna termin

2074
01:46:26,060 --> 01:46:29,420
kommer ofta titta på det numret,
även om det är typ av göms undan

2075
01:46:29,420 --> 01:46:32,780
om du letar efter det, till
avgöra om ett programs eller inte

2076
01:46:32,780 --> 01:46:37,050
utförande var rätt eller fel.

2077
01:46:37,050 --> 01:46:40,450
>> Och så det leder oss till
detta, i slutet av dagen.

2078
01:46:40,450 --> 01:46:43,917
Vi började i dag med att titta på
felsökning, och i sin tur på kursen

2079
01:46:43,917 --> 01:46:46,750
sig själv, och sedan mer intressant,
tekniskt under huven

2080
01:46:46,750 --> 01:46:49,490
vad strängar är, som varar
vecka vi tog bara för givet,

2081
01:46:49,490 --> 01:46:51,900
och tog verkligen dem
för givet i Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Vi tittade sedan på hur vi kan få tillgång till
enskilda tecken i en sträng,

2083
01:46:56,040 --> 01:47:00,310
och sedan igen tog en högre nivå
titta på saker, titta på hur well--

2084
01:47:00,310 --> 01:47:04,226
Om vi ​​vill komma åt enskilda
element i en lista liknande struktur,

2085
01:47:04,226 --> 01:47:05,850
kan vi inte göra det med flera strängar?

2086
01:47:05,850 --> 01:47:08,050
Och vi kan med kommandoradsargument.

2087
01:47:08,050 --> 01:47:12,800
Men den här bilden här för bara lådor
är demonstrativ av denna allmänna idé

2088
01:47:12,800 --> 01:47:14,451
av en array, eller en lista eller en vektor.

2089
01:47:14,451 --> 01:47:16,450
Och beroende på
sammanhang alla dessa ord

2090
01:47:16,450 --> 01:47:17,880
betyda lite olika saker.

2091
01:47:17,880 --> 01:47:20,060
Så i C, vi bara gå
att tala om en array.

2092
01:47:20,060 --> 01:47:23,840
Och en mängd är en bit
av minne, är var och en av vilka

2093
01:47:23,840 --> 01:47:27,720
element är sammanhängande, tillbaka,
att backa, att backa, att backa.

2094
01:47:27,720 --> 01:47:31,970
>> Och dessa delar är i allmänhet,
av samma datatyp, tecken,

2095
01:47:31,970 --> 01:47:35,966
tecken, tecken, tecken, eller
sträng, sträng, sträng, sträng, eller int,

2096
01:47:35,966 --> 01:47:38,600
int, int, vad det är
vi försöker att lagra.

2097
01:47:38,600 --> 01:47:42,540
Men i slutet av dagen, är detta
hur det ser ut konceptuellt.

2098
01:47:42,540 --> 01:47:44,530
Du tar din
datorns minne eller RAM.

2099
01:47:44,530 --> 01:47:48,590
Och du carving ut i
identiskt stora lådor, som alla

2100
01:47:48,590 --> 01:47:50,920
är tillbaka, mot rygg, till
tillbaka mot rygg på det här sättet.

2101
01:47:50,920 --> 01:47:53,200
>> Och vad är trevligt om
denna idé, och det faktum

2102
01:47:53,200 --> 01:47:58,580
att vi kan uttrycka värden på detta sätt
med den första av våra datastrukturer

2103
01:47:58,580 --> 01:48:02,520
i klassen, innebär att vi kan börja
att lösa problem med kod

2104
01:48:02,520 --> 01:48:04,079
som kom så intuitivt i vecka 0.

2105
01:48:04,079 --> 01:48:05,870
Du minns telefonen
bok exempel, där

2106
01:48:05,870 --> 01:48:09,110
Vi använde en söndra och härska,
eller en binär sökalgoritm,

2107
01:48:09,110 --> 01:48:13,220
att sålla igenom en hel
gäng namn och nummer.

2108
01:48:13,220 --> 01:48:18,220
Men vi trodde, minns, att det
telefonbok redan sorteras,

2109
01:48:18,220 --> 01:48:21,630
att någon annan hade redan
figured out-- ges en lista med namn

2110
01:48:21,630 --> 01:48:24,430
och numbers-- hur man alphabetize dem.

2111
01:48:24,430 --> 01:48:26,950
Och nu när i C vi,
också, har förmågan

2112
01:48:26,950 --> 01:48:30,290
att lägga ut saker, inte
fysiskt i en telefonbok

2113
01:48:30,290 --> 01:48:34,220
men praktiskt taget i en dators
minne, kommer vi att kunna nästa vecka

2114
01:48:34,220 --> 01:48:38,470
att införa igen this-- den första
av våra datastrukturer i ett array--

2115
01:48:38,470 --> 01:48:43,530
men ännu viktigare, själva datorn
vetenskap algoritmer implementeras

2116
01:48:43,530 --> 01:48:47,720
i koden, som vi kan lagra
data i strukturer som detta,

2117
01:48:47,720 --> 01:48:50,730
och sedan börja manipulera den, och
att faktiskt lösa problem med det,

2118
01:48:50,730 --> 01:48:53,570
och att bygga på toppen av det,
i slutändan, program i C,

2119
01:48:53,570 --> 01:48:56,730
i Python, i JavaScript,
fråge databaser med SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Och vi ser att alla dessa
olika idéer spärr.

2121
01:48:59,980 --> 01:49:04,100
Men nu, påminna om att
domän som vi införde i dag

2122
01:49:04,100 --> 01:49:06,920
var denna sak här, och
världen av kryptografi.

2123
01:49:06,920 --> 01:49:11,200
Och bland de kommande problem som du själv
kommer att lösa är konsten att kryptografi,

2124
01:49:11,200 --> 01:49:13,630
kryptering och de-krypterings
information och kryptering

2125
01:49:13,630 --> 01:49:15,930
och dechiffrera text,
och antar slutligen

2126
01:49:15,930 --> 01:49:18,970
att du nu vet vad
är under huven

2127
01:49:18,970 --> 01:49:21,860
så att när du ser eller tar emot
ett meddelande som detta, du

2128
01:49:21,860 --> 01:49:24,060
själv kan dechiffrera det.

2129
01:49:24,060 --> 01:49:26,740
Allt detta, och mer nästa gång.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEOUPPSPELNING]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Just anlänt.

2133
01:49:32,970 --> 01:49:35,146
Jag kommer att gå besök
hans college professor.

2134
01:49:35,146 --> 01:49:37,611
Japp.

2135
01:49:37,611 --> 01:49:40,080
Hej.

2136
01:49:40,080 --> 01:49:40,660
Det är du.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Vänta!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Jag försöker bara att räkna
ut vad som hände med dig.

2142
01:49:56,060 --> 01:49:58,130
Snälla, vad som helst kan hjälpa till.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Du var hans college
rumskamrat, inte du?

2145
01:50:08,354 --> 01:50:10,770
Du var där med honom när
han avslutade CS50 projektet?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [Musik spelar]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Det Var CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Jag älskar det här stället.

2152
01:50:44,770 --> 01:50:45,854
>> -Ät upp.

2153
01:50:45,854 --> 01:50:47,020
Vi går i konkurs.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END SPELA]

