[Musik spelar] 

DAVID J. MALAN: Okej. Detta är CS50 och detta är början på vecka två. Och du kommer ihåg att över Sedan ett par veckor, vi har infört dator vetenskap och, i sin tur, programmering. 

Och vi började historien med hjälp av Scratch, som grafiska språket från MIT Media Lab. Och sedan senast, förra veckan, gjorde vi införa en higher-- en lägre nivå språk känt som C, något som är rent text. Och faktiskt, sista gången vi utforskas i det sammanhanget ett antal begrepp. 

Detta minns, var mycket första programmet vi tittat på. Och detta program, helt enkelt, skriver ut, "Hej, världen". Men det finns så mycket problem magi pågår. Det är det här #include med dessa vinkeljärnen. Det finns int. Det finns (void). Det finns parenteser, klamrar, semikolon, och så mycket mer. 

Och så minns att introducerade vi Scratch så att vi kunde, i idealfallet, se förbi att syntax, de saker som är verkligen inte allt som intellektuellt intressant men tidigt är absolut, lite knepigt att linda dig runt. Och, faktiskt, ett av de vanligaste saker tidigt på i en program klass, särskilt för de mindre bekväm, är att bli frustrerad av och trippade upp av vissa syntaktiska fel, för att inte tala logiska fel. Och så bland våra mål idag, faktiskt, kommer vara att utrusta dig med några problemlösning tekniker för hur att bättre lösa problem själva i form av felsökning. Och du minns också att miljö som vi införde förra gången kallades CS50 IDE. Detta är webbaserad programvara som kan du programmera i molnet, så att säga, och samtidigt hålla alla dina filer tillsammans, som vi återigen kommer i dag. Och minns att vi revisited dessa frågor här, bland dem funktioner och loopar, och variabler och booleska uttryck, och villkor. Och faktiskt några fler att vi översatt från världen av Scratch till en värld av C. 

Men de grundläggande bygg block, så att säga, var verkligen fortfarande samma förra veckan. Faktum är att vi egentligen bara hade en olika pusselbit, om man så vill. I stället för att lila spara blocket, vi istället hade printf, vilket är denna funktion i C som kan du skriva ut något och formatera den på skärmen. Vi introducerade CS50 Bibliotek, där du Nu har till ditt förfogande get_char, och get_int, och get_string, och några andra funktioner som väl, via vilken du kan få input från användarens egen tangentbord. Och vi tog också en titt på saker som dessa-bool och röding, och dubbel, flyta, int, long_long sträng. Och det finns även andra datatyper i C. 

Med andra ord, när du deklarerar en variabel för att lagra ett visst värde, eller när du genomför en funktion som returnerar ett visst värde, Du kan ange vad typ av värde som är. Är det en sträng, som en sekvens av tecken? Är det ett nummer, som ett heltal? Är det en flyttals värde, eller liknande? Så i C, till skillnad från Scratch, vi faktiskt började att ange vilken typ av data vi tillbaka eller använder. 

Men, naturligtvis, sprang vi även i vissa grundläggande begränsningar av datorer. Och framför allt, detta språk C, minns att vi tog en titt på heltalsspill, verkligheten att om du bara har en ändlig mängd minne eller, närmare bestämt, ett ändligt antal bitar, kan du bara räkna så högt. Och så vi tittat på det här exemplet här varigenom en räknare i ett flygplan, faktiskt, om det körs tillräckligt länge skulle svämma över och resulterar i en programvara en fysisk potential fel. 

Vi har också tittat på flytande punkt vaghet, verkligheten att med endast ett ändligt antal bitar, oavsett om det är 32 eller 64, Du kan endast ange så många siffror efter ett decimalkomma, varefter du börjar få oprecis. Så till exempel, en tredjedel i värld här, i vår mänskliga världen, vi vet är bara ett oändligt antal av 3s efter decimalkommat. Men en dator kan inte nödvändigtvis representerar ett oändligt antal siffror om du bara låta det några begränsad mängd information. 

Så inte nog med att vi utrustar dig med större kraft när det gäller på hur du kan uttrycka dig på ett tangentbord i form av programmering, vi begränsat också vad du faktiskt kan göra. Och faktiskt, buggar och misstag kan uppstå från dessa typer av frågor. Och faktiskt, bland de ämnen idag kommer att vara som felsökning ämnen och faktiskt ser under huven på hur saker och ting infördes förra veckan faktiskt genomförs så att du bättre förstå både kapacitet och begränsningarna hos ett språk som C. 

Och i själva verket kommer vi skära ner lagren av den enklaste av datastrukturen, något som kallas en matris, som Scratch råkar kalla en "lista". Det är lite annorlunda i detta sammanhang. Och sedan kommer vi också att införa en av de första av våra domänspecifika problem i CS50, värld kryptografi, konsten att klättra eller kryptering uppgifter så att du kan skicka hemliga meddelanden och avkoda hemliga meddelanden mellan två personer, A och B. 

Så innan vi övergång till den nya världen, låt oss försöka att utrusta dig med några tekniker som du kan eliminera eller reducera åtminstone en del av frustration att du förmodligen har stött under den senaste veckan ensam. I själva verket före du such-- några av dina första problem i C. Och oddsen är, Om du är som mig, första gången du försöker skriva ut ett program, även om du tror logiskt Programmet är ganska enkelt, du kan mycket väl slå en vägg, och kompilatorn kommer inte att samarbeta. Gör eller Clang kommer inte att faktiskt göra din budgivning. 

Och varför skulle det vara? Nåväl, låt oss ta en titt på, kanske, ett enkelt program. Jag kommer att gå vidare och spara det i en fil medvetet kallas buggy0.c, eftersom jag vet att det vara bristfällig i förväg. Men jag kanske inte inser att om detta är den första eller andra eller tredje programmet att jag faktiskt gör mig. Så jag kommer att gå vidare och skriver ut, int main (void). Och sedan inne i mina klammerparenteser, en mycket bekant ( "Hej, world-- bakåtstreck, n ") - och ett semikolon. 

Jag har sparat filen. Nu ska jag gå ner till min terminalfönster och typ gör buggy0, eftersom, återigen, namnet på filen i dag är buggy0.c. Så jag skriver göra buggy0, Enter. 

Och, oh, gosh, minns från förra gången att inga felmeddelanden är en bra sak. Så ingen utgång är en bra sak. Men här har jag klart visst antal misstag. 

Så den första raden av produktionen när du har skrivit göra buggy0, återkallande, är Clang är ganska utförlig utgång. Under huven, CS50 IDE är konfigurerad att använda en massa alternativ med denna kompilator så att du inte har att tänka på dem. Och det är allt som första raden medel som börjar med klang. 

Men efter att de problem börja göra sitt utseende. Buggy0.c på linje 3, tecken 5, finns det en stor, röd fel. Vad är det? Underförstått att förklara biblioteksfunktion printf med typen int (const char *, ...) [-Werror]. Jag menar, det mycket snabbt blir mycket svårbegripliga. Och visst, i första blick, vi skulle inte förväntar dig att förstå helheten av det meddelandet. Och så en av de lärdomar för idag går att vara att försöka att lägga märke till mönster, eller liknande saker, fel du kan ha stött på tidigare. Så låt oss retas isär endast dessa ord som ser bekant. Den stora, röda fel är klart symbol för något att ha fel. 

Underförstått förstått~~POS=HEADCOMP att förklara biblioteksfunktion printf. Så även om jag inte riktigt förstår vad implicit förklarar biblioteksfunktion medel, problemet säkert avser printf på något sätt. Och källan till denna fråga har att göra med att förklara det. 

Förklara en funktion är nämna det för första gången. Och vi använde terminologin förra veckan att förklara en funktion prototyp, antingen med en rad högst upp på din egen fil eller i en så kallad header-fil. Och i vilken fil gjorde vi säga förra veckan att printf är citat, unquote förklarade? I vilken fil är dess prototyp? 

Så om ni minns, den allra första jag skrivs nästan varje program förra time-- och av misstag en stund sedan började skriva myself-- var detta en här-- hash-- #include <stio-- för input / output-- prick h Och faktiskt, om jag sparar nu den här filen, kommer jag att gå vidare och rensa skärmen, som du kan göra genom att skriva Klar, eller så kan du hålla kontroll L, bara för att rensa terminalfönster bara för att eliminera en del skräp. 

Jag kommer att gå vidare och re-typ make buggy0, Enter. Och voila, ser jag ändå att lång kommando från klang, men det finns inget felmeddelande den här gången. Och faktiskt, om jag gör ./buggy0, precis som förra gången, där prick innebär detta katalog, Slash betyder bara, här kommer namnet på programmet och att namnet på programmet är buggy0, Ange "Hello, World." 

Nu, hur kan du ha gleaned denna lösning utan att nödvändigtvis erkänna så många ord som jag gjorde, verkligen, med gjort detta i så många år? Tja, inser per det första problemet set, presenterar vi ett kommando att CS50 egen personal skrev kallas help50. Och faktiskt, C gör specifikation för problemet satt som på hur man använder denna. 

Men help50 är väsentligen ett program som CS50 personal skrev som tillåter dig att köra ett kommando eller köra ett program, och om du inte förstår dess utgång, att passera sin produktion till help50, vid vilken punkt programvaran att kursen personal skrev kommer att titta på ditt program produktion rad för rad, tecken för tecken. Och om vi, personalen, erkänner felmeddelande som du upplever, Vi kommer att försöka provocera dig med några retoriska frågor, med några råd, ungefär som en TF eller en CA eller själv skulle göra personligen på kontorstid. 

Så se till help50 om du inte nödvändigtvis känna igen ett problem. Men lita inte på det alltför mycket som en krycka. Visst försöka förstå dess utgång och sedan lära av det så att endast en eller två gånger gör du någonsin köra help50 för ett visst fel meddelande. Efter det, bör du vara bättre rustade själv att räkna ut vad det egentligen är. 

Låt oss göra en annan här. Låt mig gå vidare, och i en annan fil vi kallar detta buggy1.c. Och i den här filen är jag kommer att deliberately-- men låtsas att jag inte förstå vad misstag jag har gjort. 

Jag kommer att gå vidare och göra this-- #include, eftersom jag har lärt mig min läxa från en stund sedan. Int main (void), som tidigare. Och sedan i här jag tänker att göra sträng s - get_string. Och minns från förra gången som detta sätt, hej, dator, ge mig en variabel, kalla det är, och göra den typ av denna variabel en sträng så jag kan lagra ett eller flera ord i det. 

Och sedan på den högra sidan av likhetstecknet är get_string, som är en funktion i CS50 Library som gör just detta. Det blir en funktion och sedan händer det från höger till vänster. Så detta likhetstecken betyder inte "Lika med" som vi tror i matematik. Det betyder uppdrag från höger till vänster. Så innebär detta, ta strängen från användaren och lagra den inne i er. 

Nu använder den. Låt mig gå vidare nu och som en andra linje, låt mig gå vidare och säga "hej" - inte "världen", men "Hej,% s-- som är vår platshållare kommatecken s, som är vår variabel, och sedan ett semikolon. Så om jag inte skruva upp för mycket Här ser detta som rätt kod. 

Och mina instinkter är nu att kompilera det. Filen heter buggy1.c. Så jag kommer att göra göra buggy1, Enter. Och darn-det, om det inte finns ännu fler fel än tidigare. Jag menar, det finns mer felmeddelanden Det skulle verkar än faktiska linjer i det här programmet. 

Men takeaway här är, även om du är överväldigad med två eller tre eller fyra felmeddelanden, fokusera alltid på mycket första av dessa meddelanden. Om man tittar på det översta en, bläddra tillbaka upp som behövs. Så här skrev jag göra buggy1. Här är det klang ut som förväntat. 

Och här är det första röda fel. Användning av odeklarerat identifierare sträng, jag menar standard? Så standard är faktiskt något annat. Den hänvisar till användarens tangentbord, i huvudsak. 

Men det är inte vad jag menade. Jag menade sträng, och jag menade get_string. Så vad är det som jag glömde att göra den här gången? Vad som saknas den här gången? Jag har min #include, så jag har tillgång till printf. 

Men vad jag inte har tillgång till ännu? Jo, precis som förra gången, Jag måste tala om för kompilatorn Klang vad dessa funktioner är. Get_string kommer inte med C. Och i synnerhet det inte kommer i header fil. Det kommer i stället i något personalen skrev, vilket är en annan fil namn men passande namnet. 

Så enkelt genom att lägga till att en rad av code-- minns från förra gången att när Clang körs, det kommer att titta på min kod topp till botten, vänster till höger. Det kommer att lägga märke till, Åh, du. Låt mig gå och hitta det, varhelst det är på servern, kopiera och klistra in den i huvudsak i toppen av din egen fil så att vid denna punkt i berättelsen, linje 1, resten av programmet kan faktiskt använda någon av de funktioner däri, bland dem get_string. Så jag kommer att ignorera resten av dessa fel, eftersom jag faktiskt misstänker att endast den första faktiskt betydde. Och jag kommer att gå vidare och repris, efter att ha sparat min fil gör buggy1. Och voila, gjorde det arbete. Och om jag gör ./buggy1 och skriva in, för Exempelvis Zamyla, jag nu kommer att få hej, Zamyla, i stället för hello, världen. 

Okej. Så hämtställen här då är att, ett försök att få fram så mycket som möjligt från felmeddelanden ensam, ser på några av de igenkännbara ord. Spärr att använda help50 per problemet inställd specifikationen. Men spärra det också alltid se upptill fel bara, åtminstone initialt, för att se vilken information det faktiskt kan ge. Men det visar sig att det finns ännu mer funktionalitet byggs i CS50 biblioteket för att hjälpa du tidigt i terminen och tidigt i programmering räkna ut vad som händer fel. Så låt oss göra ett annat exempel här. Jag kommer att kalla denna buggy2, som igen, kommer att vara bristfällig ut porten, avsiktligt. 

Och jag kommer att gå vidare och göra #include. Och sedan ska jag göra int main (void). Och sedan ska jag göra en for-loop. For (int i _ 0. i är mindre än eller lika med 10. i ++, och sedan i klammerparenteser, jag kommer att skriva ut bara en hashtag symbol här och en ny rad tecken. 

Så min avsikt med denna Programmet är helt enkelt att iterera 10 gånger och på varje iteration i nämnda slinga varje gång genom cykeln, skriva ut en hashtag, en hashtag, en hashtag. Ett per rad, eftersom jag har den nya linjen där. Och minns att för slinga, per sista week-- och du får mer bekant med syntaxen genom att använda den med praxis innan long-- detta ger mig en variabel som heter i och ställer det till 0. 

Detta ökar i på varje iteration av en. Så jag går till 1 till 2-3. Och då detta villkor i mitt emellan semikolon får kontrolleras på varje iteration att göra säker på att vi fortfarande är inom räckhåll. Så jag vill iterera 10 gånger, så jag har slags mycket intuitivt bara sätta 10 min övre gräns där. 

Och ändå, när jag kör detta, efter sammanställa det med make buggy2-- och det gör sammanställa OK. Så jag har inte en syntaxfel den här gången. Låt mig gå vidare nu och kör buggy2, Enter. Och nu rulla upp. Och låt mig öka storleken på fönstret. 

Jag verkar ha en, två, tre, 4, 5, 6, 7, 8, 9, 10, 11. Så det finns 11 hashtags, även om Jag satte klart 10 insidan av denna slinga. Nu kanske några av er ser omedelbart vad felet beror på att, faktiskt, detta är inte ett mycket hårt fel att göra. Men det är mycket vanligt gjort mycket tidigt. 

Vad jag vill påpeka, men, är, hur kan jag räkna ut? Tja, visar det sig att den CS50 Biblioteket kommer med inte bara get_string och get_int och get_float och andra funktioner. Det kommer också med en speciell funktion kallas eprintf, eller fel printf. Och det finns enbart för att göra det lite lättare för dig när felsökning koden att bara ut ett felmeddelande på skärmen och vet var den kom ifrån. 

Så till exempel, en sak som jag kanske göra här med den här funktionen är this-- eprintf, och sedan kommer jag att gå vidare och säga att jag är nu% i, backslash, n. Och jag kommer att koppla in värde i. Och där uppe, eftersom detta är i CS50 Library, Jag kommer att gå vidare och innefattar så jag har tillgång till denna funktion. Men låt oss fundera på vad linje 9 är tänkt att göra. Jag kommer att ta bort detta så småningom. Detta har ingenting att göra med min övergripande mål. Men eprintf, fel printf är bara tänkt att ge mig några diagnosinformation. När jag kör mitt program, vill jag se detta på skärmen tillfälligt liksom bara för att förstå Vad pågår. 

Och, faktiskt, på varje iteration här linjen 9 Jag vill se, vad är värdet av i? Vad är värdet av i? Vad är värdet av i? Och förhoppningsvis jag skulle bara se meddelandet, även, 10 gånger. 

Så låt mig gå vidare och kompilera mitt program, som jag måste göra när som helst Jag gör en ändring. ./buggy2. Och now-- OK. Det finns mycket mer att gå på. Så låt mig rulla upp i en ännu större fönster. 

Och du ser att var och en av den hashtags fortfarande utskrift. Men mellan vart och ett av dem är nu detta diagnosuttag formaterade som följer. Namnet på mitt program här är buggy2. Namnet på filen är buggy2.c. Radnumret som detta trycktes är linjen 9. Och sedan till höger om denna är den felmeddelande som jag förväntat mig. 

Och vad är trevligt om det här är att nu har jag inte behöver nödvändigtvis räkna i mitt huvud vad mitt program gör. Jag kan se det på första iterationen i är 0, sedan en, sedan två, sedan tre, sedan fyra, sedan 5, då sex, sedan 7, sedan 8, sedan 9, sedan 10. Så vänta en minut. Vad händer här? Jag verkar fortfarande räknar som avsett upp till 10. 

Men var jag börja? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Så 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11 finger är indikativ för problemet. Jag verkar ha räknat felaktigt i min slinga. I stället för att gå 10 iterationer, Jag börjar på 0, Jag slutar vid och genom 10. Men eftersom, som en dator, Jag börjar räkna på 0, Jag ska räkna upp till, men inte igenom, 10. 

Och så fix, jag så småningom realiseras här, är en av två saker. Jag kunde mycket enkelt säga räkna upp till mindre än 10. Så 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, som är verkligen rätt, även om det låter lite fel. Eller jag kunde göra mindre än eller lika till 9, så länge jag börjar på 0. Eller om du verkligen inte gillar det, du kan räkna upp till 10, men börjar på en. Men återigen, detta är bara inte så vanligt. I programming-- albeit inte så mycket i Scratch-- men i programmering i C och andra språk, som JavaScript och Python och andra är det bara mycket vanligt att vår diskussion av binära att bara börja räkna på lägsta antalet du kan, som är 0. Okej. Så det är eprintf. Och återigen, nu när jag har räknat ut min problem, och jag kommer att gå tillbaka till 0 genom mindre än 10, kommer jag att gå in och ta bort eprintf. 

Det bör inte vara där när jag transportera min kod eller lämna min kod eller visa den för någon annan. Det är egentligen bara menade att användas tillfälligt. Men nu har jag fast detta särskilt problem också. 

Nåväl, låt oss göra ett exempel här att jag kommer att piska upp enligt följande. Jag kommer att gå vidare och #include. $ 50 Och jag kommer att gå vidare och #include. 

Och jag kommer att spara denna fil som buggy3.c. Och jag kommer att gå vidare och förklarar int main (void). Och sedan inne i det Jag kommer att göra int i _ - Jag vill genomföra ett program med en get_negative_int. Detta är inte en funktion som existerar ännu. Så vi kommer att genomföra det på bara ett ögonblick. Men vi kommer att se varför det är sulky på första passage. Och när jag har blivit en int från användaren, Jag kommer bara att skriva% i är en negativ heltal, omvänt snedstreck, n, komma, i. Med andra ord, allt jag vill att detta program att göra är att få en negativ int från användaren och sedan skriva ut att den och den är en negativ int. 

Nu behöver jag för att genomföra denna funktion. Så senare i min fil, jag kommer att gå framåt och förklara en funktion som kallas get_negative_int (void) - och vi kommer komma tillbaka till vad den linjen innebär återigen i en moment-- int n; do-- do den following-- printf n är :. Och då kommer jag att göra n - get_int, och göra detta samtidigt som n är större än 0. Och sedan återvända n ;. 

Så det finns en hel del som pågår i detta men ingen som vi inte titta på förra veckan, åtminstone kortfattat. Så på linje 10 här jag har deklarerat en funktion kallad get_negative_int, och jag har lagt (void), i parentes, på grund av detta tar någon signal. Jag är inte passerar något till denna funktion. Jag är bara att få något tillbaka från den. 

Och vad jag hoppas få tillbaka är ett heltal. Det finns ingen datatyp i C kallas negative_int. Det är bara int, så det kommer att vara på oss att se till att det värde som faktiskt returneras är inte bara en int men är också negativ. 

On line 12 Jag förklara en variabel kallas n och göra det av typen int. Och sedan i linje 13 till 18 jag göra något medan något är sant. Jag går vidare och utskrift N, kolon, och sedan ett mellanslag, som en uppmaning till användaren. 

Jag sedan ringer get_int och lagring av dess så kallade returvärde i den variabeln n. Men jag kommer att fortsätta att göra detta medan n är större än 0. Med andra ord, om användaren ger mig en int och att antalet är större än 0, ergo, positiv, jag ska bara hålla reprompting användaren, hålla reprompting, genom att tvinga dem att samarbeta och ge mig en negativ int. 

Och när n är faktiskt negative-- Antag att användaren slutligen typerna -50, då detta medan slingan är inte längre sant eftersom -50 inte är större än 0. Så vi bryta sig ur det loop logiskt och retur n. 

Men det finns en annan jag måste göra. Och jag kan bara göra detta genom att kopiera och klistra in en kodrad på toppen av filen. Jag måste lära klang, eller lovar att klang, uttryckligen att jag kommer, faktiskt gå och genomföra denna funktion get_negative_int. Det kan bara vara lägre i filen. Återigen, påminna om att klang läser saker topp till botten, från vänster till höger, så kan du inte anropa en funktion om klang inte vet att det kommer att existera. 

Nu, tyvärr, det här programmet, som några av er kanske har märkt, redan är paraplyvagn. Låt mig gå vidare och göra buggy3. Det samman, så mitt problem är nu inte ett syntaxfel, som en text fel, det är faktiskt kommer att bli en logisk fel som jag har medvetet gjort som en möjlighet att stega igenom vad som händer. 

Jag kommer att gå vidare nu och kör buggy3. Och jag kommer att gå framåt och inte samarbeta. Jag kommer att ge den nummer ett. Det tyckte inte om det, så det föranledde mig igen. 

Vad sägs om två? 3? 50? Ingen av de arbetar. Hur ca -50? Och programmet verkar fungera. 

Låt mig prova en gång mer. Låt mig försöka -1, verkar fungera. Låt mig försöka -2, verkar fungera. Låt mig försöka 0. Huh, det är fel. Nu, vi är lite pedantisk här. Men det är faktiskt så att 0 är varken positiv eller negativ. Och så det faktum att mitt program är att säga att 0 är en negativt heltal, det är inte tekniskt korrekt. 

Nu, varför är det att göra detta? Väl, kan det vara uppenbart. Och faktiskt, är programmet tänkt att vara ganska enkel så vi har något att utforska. 

Men låt oss införa en tredje felsökning teknik som här kallas debug50. Så det här är ett program att vi bara har skapat Detta år kallas debug50 som gör att du att använda vad som kallas en inbyggd grafisk debugger i CS50 IDE. Och en debugger är bara ett program som generellt kan du köra programmet men steg för steg för steg, rad av rad för rad, pausa, peta runt, titta på variabler så att programmet inte bara blåsa förbi dig och snabbt skriva ut något eller inte skriva ut något. Det ger dig en möjlighet, vid mänsklig hastighet, för att interagera med det. 

Och att göra detta, du helt enkelt göra följande. Efter att sammanställa koden, som jag redan gjort, buggy3, du gå vidare och köra debug50 ./buggy. Så mycket som help50 har du kör help50 och sedan kommandot, debug50 har du kör debug50 och sedan namnet på kommandot. 

Nu se vad som händer på skärmen, på den högra sidan i synnerhet. När jag slog Kör alla plötsligt denna högra panelen öppnar upp på skärmen. Och det finns en hel del att gå på vid första anblicken. Men det är inte alltför mycket att oroa sig ännu. 

Detta visar mig allt som pågår inne i mitt program just nu och via dessa knappar uppe sedan tillåter mig att gå igenom min kod ultimately steg för steg för steg. Men inte ännu. Lägg märke till vad som händer. På min terminalfönster Jag blir tillfrågad om n. Och jag kommer att gå vidare och samarbeta denna gång och skriv in -1. Och om än lite kryptiskt, -1 är ett negativt heltal, som förväntat. 

Och sedan barn avslutades med status 0 GDBserver spännande. GDB, gnu debugger, är namnet av den underliggande mjukvaran som implementerar detta debugger. Men allt detta egentligen innebär, debugger gick bort eftersom mitt program sluta och allt var bra. Om jag vill verkligen felsöka mitt program, Jag måste preemptively berätta debug50, där jag vill börja stega igenom min kod? 

Och kanske det enklaste sättet att göra det är som följer. Om jag svävar över ränna av min redaktör här, så egentligen bara i sidofältet här, till vänster om radnumret, Lägg märke till att om jag bara klicka en gång satte jag en liten röd prick. Och den lilla röda pricken, som en stoppskylt, betyder, hej, debug50, pausa exekvering av min kod direkt när jag kör det här programmet. 

Så låt oss göra det. Låt mig gå vidare och köra mitt program igen med debug50 ./buggy3, Enter. Och nu, varsel, något annorlunda har hänt. Jag är inte uppmanas men i mitt terminalfönster för något, eftersom jag har inte fått det ännu i mitt program. Lägg märke till att på ledningen 8 som nu är markerad, och det finns en liten pil på vänstra säger, är du pausade här. Denna kodrad, linje 8, ännu inte har verkställt. 

Och vad är nyfiken, om jag ser hit på höger sida, märker att jag är en lokal variabel, lokalt i den meningen att det är inuti den aktuella funktionen. Och dess värde, till synes som standard, och typ av enkelt, är 0. Men jag inte skriver 0. Det råkar vara dess Standardvärdet för tillfället. 

Så låt mig gå vidare och göra det nu. Låt mig gå vidare och på upp till höger här, jag är kommer att gå vidare och klicka på denna första ikon som betyder steg över vilket betyder inte hoppa det men steg över den här kodraden, verkställer det på vägen. 

Och nu, märker min prompt har just ändrats. Varför är det så? Jag har sagt debug50, köra denna kodrad. Vad betyder den här kodraden göra? Frågar mig för en int. OK. Låt mig samarbeta. Låt mig gå vidare nu och skriver -1, Enter. Och nu märker vad som har förändrats. På den högra sidan, min lokala variabeln i indikeras som -1 nu. Och det är fortfarande av typen int. 

Och varsel, även min så kallade call stack, där jag paus? Vi kommer att prata mer om detta i framtiden. Men anropsstacken hänvisar bara till vad funktioner finns för närvarande i rörelse. Just nu är det bara huvud. Och just nu den enda lokala variabel är i med ett värde på ett. 

Och när jag steg slutligen över denna linje här, med samma ikon uppe till höger, -1 Är ett negativt heltal. Nu är det paus över det lockiga stag. Låt oss låt den göra sin sak. Jag steg över den linjen, och voila. 

Så inte alla som fruktansvärt upplysande ännu, men det lät mig paus och tänka igenom logiskt vad detta program gör. Men det var inte den felaktiga fallet. Låt oss göra detta igen på följande sätt. 

Jag kommer att lämna den brytpunkt på rad 8 med den röda pricken. Jag kommer att köra debug50. Det är automatiskt paus här. Men den här gången, i stället för kliva över denna linje, Låt mig faktiskt gå inuti get_negative_int och räkna ut, varför är det att acceptera 0 som ett giltigt svar? 

Så istället för att klicka Step Over. Jag kommer att gå vidare och klicka på Step Into. Och lägg märke till att linjen 8 som är nu markerat nu plötsligt blir linje 17. 

Nu är det inte så debugger har hoppat linjerna 14 och 15 och 16. Det är bara det finns inget att visa dig där. De är bara deklarera variabler, och sedan finns det ord Gör och sedan en öppen klammerparentes. Den enda fungerande linje som är saftig är verkligen detta här, 17. Och det är där vi har pausas automatiskt. 

Så printf ( "n.is:") ;, så som inte har hänt ännu. Så låt oss gå vidare och klicka på Step Over. Nu är min snabb, faktiskt, ändras till ( "n är:"). Nu get_int, jag tänker inte bry kliva in, eftersom denna funktion var tillverkad av CS50 i biblioteket. Det är antagligen korrekt. 

Så jag kommer att gå vidare och sorts samarbeta genom att ge den en int, men inte en negativ int. Så låt mig gå vidare och slå 0. Och nu vad som händer här när jag kommer ner till linje 21? Jag har inte upprepas igen. Jag verkar inte ha fastnat i denna slinga. Med andra ord, denna gula baren inte hålla gå runt, och runt, och runt. 

Nu, varför är det? Tja, n, vad är N just nu? Jag kan titta på den lokala variabler i debugger. n är 0. Okej, vad som var mitt tillstånd? 

20-- linje 20 är, tja, 0 är större än 0. Det är inte sant. 0 inte är större än 0. Och så jag bröt ut ur detta. 

Och så det är därför på rad 21, om jag faktiskt fortsätter, Jag kommer att återvända 0, även men jag borde ha förkastat 0 som egentligen inte är negativt. Så nu gör jag egentligen inte ens bryr sig om debugger. Fick det, jag behöver inte vet vad mer som pågår. 

Så jag kommer att gå vidare och klickar du bara på play-knappen, och låt detta avslut. Nu har jag insett att min felet är tydligen på linje 20. Det är min logiskt fel. 

Och så vad vill jag att göra för att ändra på detta? Om problemet är att jag inte fånga 0, det är bara ett logiskt fel. Och jag kan säga när n är större än eller lika med 0, hålla uppmanar användaren och om igen. 

Så, återigen, enkelt misstag, kanske även uppenbart när du såg mig skriva det bara några minuter sedan. Men takeaway här är att med debug 50, och med felsökning programvara mer allmänt, du har denna nyfunna kraft till gå igenom din egen kod, ser via den högra panelen vad dina variabler värden. Så att du inte nödvändigtvis måste använda något som du eprintf att skriva ut dessa värden. Du kan faktiskt se dem visuellt på skärmen. 

Nu, utöver detta, är det värt att notera att det finns en annan teknik som är faktiskt super vanligt. Och kanske du undrar varför denna lilla killen här har suttit på scenen. Så det finns denna teknik i allmänhet känd som gummi anka felsökning, som verkligen är bara en bevis på det faktum som ofta när programmerare skriver kod, de är inte nödvändigtvis samarbeta med andra, eller arbetar i en delad miljö. 

De är typ av hemma. Kanske det är sent på natten. De försöker figur in några fel i sin kod. Och de är bara inte ser det. 

Och det finns ingen rumskompis. Det finns ingen TF. Det finns ingen CA runt. Allt de har på sin hylla är denna lilla plastanka. 

Och så gummi anka felsökning är just denna inbjudan att tänka på något så dumt eftersom detta som en verklig varelse, och faktiskt gå igenom koden muntligt till detta livlösa objekt. Så, till exempel, om detta är mitt exempel här-- och påminna om att tidigare problemet var detta, om jag tar bort den första raden av kod, och jag gå vidare och göra buggy 0 igen, minns att jag hade dessa felmeddelanden här. Så tanken här, löjligt om jag känner just nu gör detta offentligt, är detta fel. 

OK, så mitt problem är att jag har implicit deklarerade en biblioteksfunktion. Och att biblioteksfunktion är printf. Declare-- OK, förklara påminner mig om prototyper. 

Det betyder att jag måste faktiskt tala om för kompilatorn i förväg vad funktionen ser ut. Vänta en minut. Jag hade inte standard io.h. Tack så mycket. 

Så just denna process of-- du behöver inte faktiskt ha en anka. Men denna idé Walking själv via din egen kod så att du även höra själv, så att du inse brister i den egna anmärkningar, är i allmänhet idén. 

Och kanske mer logiskt, inte så mycket tydligt, men mer delaktiga Exempelvis gjorde vi just i buggy 3.c, du kanske gå själv genom det som följer. Så okej, gummi ducky, DDB, om man så vill. Här har vi i min huvudsakliga funktion, Jag ringer få negativ int. 

Och jag får returvärdet. Jag lagra den på vänster sida på rad 8 i en variabel som kallas i. OK, men vänta, hur gjorde att få detta värde? Låt mig titta på funktionen i linje 12. 

I linje 12, har vi negativ int. Inte ta några insatsvaror, kommer tillbaka en int, OK. Jag försäkrar på linje 14 en variabel n. Det kommer att lagra ett heltal. Det är vad jag vill ha. 

Så gör följande medan n är-- låt mig ångra vad fix jag redan gjort. Så medan n är större än 0, skriva ut N, OK. Och sedan ringa få int lagras i n. Och sedan kontrollera om n är 0, n är inte-- det är. Så, återigen, behöver du inte behöver själva anka. Men bara gå själv genom koden som en intellektuell övning kommer ofta hjälpa dig inse vad som händer, till skillnad från att bara göra något så här, stirrar på skärmen, och talar inte dig själv genom den, vilket ärligt inte är nästan som en effektiv teknik. Så där har ni det, en antal olika tekniker för att faktiskt felsöka din kod och hitta fel, som alla bör vara verktyg i din verktygslåda så att du inte sent på kvällen, speciellt, du är i matsalen hallar, eller på kontorstid, banka huvudet mot vägg, försöker att lösa några problem. Inse att det finns mjukvaruverktyg. Det finns gummianka verktyg. Och det finns en hel stab av stödja väntar på att låna ut en hand. 

Så nu, ett ord om problemet uppsättningar, och på vad vi hoppas dig få ut av dem, och hur vi går om att utvärdera. Per kursens kursplan, CS50: s problemsamlingar utvärderas på fyra primära axlar, så att speak-- omfattning, korrekthet, design, och stil. Och omfattning hänvisar bara till hur mycket av pjäsen har du biten av? Hur mycket av ett problem har du försökt? Vilken nivå av ansträngning har du uttryck? 

Korrektheten är, fungerar programmet som det är tänkt att per CS50 specifikation när du ger vissa insatsvaror eller vissa utgångar komma tillbaka? Design är den mest subjektiva av dem. Och det är den som kommer ta längst tid att lära sig och den längsta att undervisa i såvitt det kokar ner till, hur välskriven är koden? 

Det är en sak att bara skriva ut rätt utgångar eller returnera de rätta värdena. Men gör du det som effektivt som möjligt? Gör du det klyftan och erövra, eller binär sökning som vi snart kommer att se att vi gjorde två veckor sedan med telefonboken? Finns det bättre sätt att lösa problem än du redan har här? Det är en möjlighet för bättre design. 

Och sedan style-- hur ganska är koden? Du kommer att märka att jag är ganska särskilt om indrag min kod, och se till att mina variabler är rimligt namnges. n, medan korta, är ett bra namn för en nummer, i för en räkning heltal, s för en sträng. Och vi kan ha längre variabelnamn stil. Style är hur bra gör din kod ut? Och hur läsbar är det? 

Och över tiden, vad dina terapi och TF kommer att göra under är att förse dig med det typ av kvalitativ feedback så att du får bättre på dessa olika aspekter. Och i termer av hur vi utvärdera var och en av dessa axlar, det är typiskt med mycket få hinkar så att ni, i allmänhet, få en känsla för hur väl du gör. Och faktiskt, om du får en poäng på helst av de som axes-- korrekthet, designen och stil especially-- det numret kommer i allmänhet att vara mellan 1 och 5. Och, bokstavligen, om du får 3: s i början av terminen, detta är en mycket bra sak. Det innebär att det fortfarande plats för förbättring, som du skulle önska i ta en klass för första gången. Det finns förhoppningsvis några bit av taket till vilken du strävar efter att nå. Och så får 3s på de tidigaste bitar, om inte några 2: s och 4: s, är verkligen en bra sak. Det är väl inom räckhåll, väl inom förväntningarna. 

Och om ditt sinne är racing, vänta en minut, tre av fem. Det är verkligen en 6 av 10. Det är 60%. Herregud, det är en F. 

Det är inte. Det är inte, i själva verket det. Snarare är det en möjlighet att förbättra under loppet av terminen. Och om du får några poors, dessa är en möjlighet att dra nytta av kontorstid, förvisso sektioner och andra resurser. 

Bäst är en möjlighet, verkligen, att vara stolt över hur långt du har komma under loppet av terminen. Så inser, om inget annars, tre är bra. Och det ger utrymme för tillväxt över tiden. 

När det gäller hur dessa axlar är viktade, realistiskt du kommer att tillbringa större delen av din tid att få saker att arbeta, för att inte tala korrekt. Och så korrekthet tenderar att viktas mest, såsom med denna multiplikativ faktor tre. Design är också viktigt, men något som du inte nödvändigtvis spendera alla dessa timmar på försöker få saker bara för att arbeta. 

Och så det viktade lite mer lätt. Och sedan stil viktas minst. Även om det är mindre viktigt i grunden, det är bara kanske det enklaste sak att göra rätt, härma exemplen vi göra i föreläsning och avsnitt, med saker fint indragen, och kommenterade, och så vidare är bland det enklaste saker att göra och få rätt. Så som sådan, inser att de är punkter som är relativt lätt att greppa. 

Och nu ett ord på this-- akademisk hederlighet. Så per kursens kursplan, kommer du att se att kursen har en ganska bit av språket kring detta. Och kursen tar upp frågan om akademisk hederlighet ganska allvarligt. 

Vi har skillnaden, på gott och ont, för att ha skickat varje år mer studenter för disciplinära åtgärder än de flesta andra naturligtvis att jag är medveten om. Detta är inte nödvändigtvis indikativ för det faktum att CS studenter, eller CS50 studenter, är något mindre ärlig än dina klasskamrater. Men det faktum att i detta värld, elektroniskt, vi bara har teknisk innebär att upptäcka detta. 

Det är viktigt för oss rättvisa i hela klassen att vi gör upptäcker detta, och höja frågan när vi ser saker. Och bara för att måla en bild, och verkligen att hjälpa något sådant sjunka in, dessa är antalet studenter under de senaste 10 åren som har varit inblandade i några sådana frågor av akademisk hederlighet, med några 32 elever från hösten 2015, vilket Det vill säga att vi tar frågan på största allvar. Och slutligen, dessa siffror komponera, mest nyligen, ca 3%, 4% eller så av klassen. 

Så för super majoriteten av studenter det verkar som om linjer är klara. Men inte hålla detta i sinne, särskilt sent på natten när kämpar med någon lösning på ett problem som, att det finns mekanismer för att få dig bättre stöd än du kanske tror, ​​även vid denna timme. Inse att när vi tar emot elevinlämningar korsar vi jämföra varje underkastelse i år mot varje inlämning förra året, mot varje inlaga från 2007, och sedan, titta på, liksom, kod lagringsplatser på nätet, diskussionsforum, jobbsajter. Och vi nämner detta, verkligen, allt på grund fullständig redovisning, att om någon annan kan hitta det på nätet, säkert, så kan vi kursen. Men egentligen, anden av kursen handlar om denna punkt i kursplanen. Det är egentligen bara vara rimlig. 

Och om vi var tvungna att utveckla det med bara lite mer språk, inse att kärnan i alla arbete som du skickar till denna kurs måste vara din egen. Men inom det, det finns säkert möjligheter och uppmuntran, och pedagogiskt värde i att vända sig till others-- själv, TF, den CA, TAS, och andra i klassen, för stöd, för att inte tala vänner och rumskamrater som har studerat CS och programmering innan. Och så finns det en ersättning för det. Och den allmänna tumregel är this-- när ber om hjälp, Du kan visa din kod för andra, men du kanske inte se deras. Så även om du är på kontorstid, eller i D hallen, eller någon annanstans arbetar på någon bit set, arbetar tillsammans med en vän, som är helt bra, på slutet av dagen ditt arbete bör slutligen hör ihop er respektive, och inte vara någon samarbetsinsats, med undantag för den sista projekt där det är tillåtet och uppmuntras. 

Inse att om du är kämpar med något och din vän bara händer bli bättre på detta då du, eller bättre på det problemet än dig, eller lite längre framåt än dig, det är helt rimligt att vända till din vän och säga hej, Har du något emot att titta på min kod här, hjälpa mig upptäcka vad mitt problem är? Och, förhoppningsvis, i intresse av pedagogiskt värde att vän inte bara säga, oh, gör detta, utan snarare, Vad saknar du på linje 6, eller något liknande? Men lösningen är inte för vän bredvid dig att säga, oh, ja, här, låt mig dra upp detta, och visa min lösning för dig. Så det är den linje. Du visar koden till andra, men du får inte visa deras, under förutsättning att den andra begränsningar i kursens kursplan. 

Så kom ihåg detta så kallade ånger klausulen under loppet s planen också, att om du begår någon handling som är inte rimligt, men ta det till uppmärksamhet av kursens huvuden inom 72 timmar, kursen får införa lokala påföljder som kan innefatta en otillfredsställande eller IG för arbetet in. Men naturligtvis inte kommer att hänvisa roll för ytterligare disciplinära åtgärder, utom i fall av upprepade handlingar. Med andra ord, om du gör några dum, särskilt sent på kvällen, beslut att nästa morgon eller två dagar senare, du vaknar upp och inser, Vad tänkte jag? Du gör i CS50 har ett utlopp för fastställande av detta problem och äga upp till det, så att vi kommer att möta dig halvvägs och ta itu med det i en fråga som är både utbildning och värdefull för dig, men fortfarande bestraffande på något sätt. Och nu, för att ta udden av detta. 

[VIDEOUPPSPELNING] 

[Musik spelar] 

[END SPELA] DAVID J. MALAN: Okej, vi är tillbaka. Och nu tittar vi på en av de första av våra verkliga världen domäner i CS50, konsten att kryptografi, konsten att skicka och ta emot hemliga meddelanden, krypterade meddelanden om du vill, som endast kan tydas om du har några viktig ingrediens att avsändaren har också. Så för att motivera detta vi tar en titt på denna sak här, vilket är ett exempel på en hemlig dekoder ring som kan användas för att räkna ut vad ett hemligt meddelande faktiskt är. I själva verket tillbaka i dag i skolan, Om du någonsin skickat hemliga meddelanden till några vän eller någon krossa i klassen, du kanske har tänkt du var smart av på papper förändras, liknande, A till B, och B till C och C till D, och så vidare. Men du faktiskt kryptering din information, även om det var en liten trivial, var inte så svårt för läraren att inse, Tja, om du bara ändra B till A och C till B, du faktiskt räkna ut vad budskapet var men du var i kryptering information. 

Du bara göra det enkelt mycket som Ralphie här i en berömd film som spelar ganska mycket till leda varje vinter. [VIDEOUPPSPELNING] -vara Det känt att allt som Ralph Parker är härmed utsett en medlem av den lilla Orphan Annie Secret Circle och är berättigad till alla de utmärkelser och förmåner som uppträder därtill. 

-Signed, Little Orphan Annie, kontrasignerat Pierre Andre, i bläck. Heder och förmåner, redan vid nio års ålder. 

[SKRIKANDE] -Kom igen. Låt oss gå vidare med det. Jag behöver inte all that jazz om smugglare och pirater. 

-listen Morgon kväll för den avslutande äventyr av svart piratskepp. Nu är det dags för Annies hemliga meddelande för dig medlemmar av Secret Circle. Kom ihåg, barn, endast medlemmar Annie hemliga Circle kan avkoda Annies hemliga meddelande. 

Kom ihåg att Annie beroende på dig. Ställ dina stift till B2. Här är budskapet. 12, 11-- 

-Jag Är i min första hemliga mötet. 

-14, 11, 18, 16. 

Pierre var i stark röst i kväll. Jag kan tala om att kvällens meddelande var verkligen viktigt. 

-3, 25, som är ett meddelande från Annie själv. Kom ihåg att inte berätta för någon. 

-90 Sekunder senare, jag är den enda rum i huset där en pojke på nio kunde sitta i avskildhet och avkoda. Aha, B! Jag gick till nästa, E. 

Det första ordet är vara. S, var det komma lättare nu, U, 25-- 

-Oh, Kom igen, Ralphie, jag måste gå! 

-Jag Vara rätt ner, Ma! Gee vina! 

-T, O, se att-- vara säker på vad? Vad var Little Orphan Annie försöker säga? Var noga med vad? 

-Ralphie, Andy har fått gå, kommer ni att komma ut? 

-Alla Rätt, Ma! Jag kommer att vara rätt ut! 

-Jag Började bli närmare nu. Spänningen var hemskt. Vad var det? Öde planet kan hänga i balans. 

-Ralphie! Andys måste gå! 

-Jag Vara rätt ut, för crying out loud! 

-Nästan Där, mina fingrar flög, mitt sinne var en stålfälla, vibrerat varje por. Det var nästan klar, ja, ja, ja. 

-vara Noga med att dricka din Ovaltine. Ovaltine? En crummy kommersiell? Jävel. [END SPELA] DAVID J. MALAN: OK, så Det var en mycket lång väg att införa kryptografi, och även Ovaltine. I själva verket, från denna gamla annons här, varför är Ovaltine så bra? Det är en koncentrerad utvinning av mogna kornmalt, ren krämig komjölk, och speciellt beredd kakao, tillsammans med naturliga fosfatider och vitaminer. Det är vidare berikade med extra vitaminer B och D, yum. Och du kan fortfarande få det, tydligen, på Amazon, som vi gjorde här. 

Men motivationen här var att introducera kryptografi, särskilt en typ av kryptering känd som hemlig nyckel kryptering. Och som namnet antyder, hela säkerhet av en hemlig nyckel krypteringssystem, om man så vill, en metod bara klättra information mellan två personer, är att endast avsändaren och endast mottagaren veta en hemlighet key-- visst värde, en del hemlig fras, något hemligt nummer, som tillåter dem att både kryptera och dekryptera information. Och kryptografi, egentligen, är just detta från vecka 0. 

Det är ett problem där det finns ingångar, liksom själva meddelande på engelska eller vilket språk som du vill skicka till någon i klassen, eller över Internet. Det finns en viss utgång, som kommer att vara den kodade meddelande som du vill att mottagaren ska få. Och även om någon i mitt emot det också, du inte vill att de ska nödvändigtvis kunna dekryptera den, eftersom insidan av denna svart låda, eller algoritm, är någon mekanism, några steg för steg instruktioner för att ta denna ingång och omvandla den till den utgång, i förhoppningsvis ett säkert sätt. 

Och i själva verket, det finns en viss vokabulär i denna värld som följer. Klartext är ordet en datavetare skulle använda för att beskriva den ingående meddelande, som det engelska eller vilket språk du faktiskt vill skicka till någon annan människa. Och då chiffertexten är scramble till chiffrerade, eller krypterad, version därav. 

Men det finns en annan ingrediens här. Det finns en annan ingång till hemlig nyckel kryptografi. Och det är själva nyckeln, vilket är, i allmänhet, som vi ser, ett nummer eller brev eller ord, oavsett algoritmen är det faktiskt förväntar sig. 

Och hur gör du dekryptera informationen? How do you avkoda det? Tja, du bara vända utgångar och ingångar. 

Med andra ord, när någon emot krypterade meddelandet, han eller hon har helt enkelt att veta att samma nyckel. De har fått chiffertexten. Och genom att koppla dessa två indata i kryptosystemet, algoritmen, denna svarta låda, ut skulle komma den ursprungliga klartext. Och så det är mycket hög nivå uppfattning om vad kryptering är faktiskt allt om. 

Så låt oss komma dit. Låt oss nu titta under motorhuven på något vi har tagit för givet för den senaste veckan, och för denna session här-- strängen. En sträng vid slutet av dagen är bara en sekvens av tecken. 

Det kan vara hello world, eller hej Zamyla, eller vad som helst. Men vad betyder det att vara en följd av tecken? I själva verket ger CS50-biblioteket oss en datatyp som kallas sträng. 

Men det finns faktiskt ingen sådant som en sträng i C. Det är egentligen bara en sekvens av tecken, tecken, tecken, karaktär, rygg, mot rygg, till tillbaka mot rygg, att backa innanför datorns minne, eller RAM. Och vi kommer att titta djupare in i det i framtiden när vi tittar på minne själv, och utnyttjande, och hot som är inblandade. 

Men låt oss betrakta strängen Zamyla. Så bara namnet på den humana här, Zamyla, som är en sekvens av tecken, Z-A-M-Y-L-A. Och nu ska vi anta att Zamyla namn lagras insidan av en dator program. 

Tja, är det förståeligt att vi bör kunna titta på dessa tecken individuellt. Så jag ska bara dra en liten ruta runt Zamyla namn här. Och det är fallet i C att när du har en sträng, som Zamyla-- och kanske att strängen har kommit tillbaka från en funktion som få sträng, du kan faktiskt manipulera det tecken för tecken. 

Nu är denna förbunden för samtal till hands, eftersom i kryptografi om du vill ändra A till B, och B till C och C till D, och så vidare, du behöver för att kunna att titta på enskilda tecken i en sträng. Du måste kunna ändra Z till något annat, A till något annat, den M till något annat, och så vidare. Och så behöver vi en väg, programmatiskt, så att tala, i C för att kunna ändra och titta på enskilda bokstäver. Och vi kan göra detta på följande sätt. 

Låt mig gå gå tillbaka i CS50 IDE. Och låt mig gå vidare och skapa en ny fil att jag ringer här gången string0, som vår första sådant exempel, dot c. Och jag kommer att gå vidare och piska upp enligt följande. 

Så inkluderar CS50.h, och då inkluderar standard io.h, som jag nästan alltid kommer att att använda i mitt program, åtminstone till en början. int main tomrum, och sedan här är jag kommer att göra strängar blir få sträng. Och då kommer jag att gå vidare och göra det. Jag vill gå vidare och, som en sanity check, bara säga, hej, procent s, semikolon gör sträng 0. Uh oh, vad gjorde jag här? Åh, det gjorde jag inte koppla in den. Så lärdom, att var inte avsiktligt. 

Så fel, mer procent omvandlingar än uppgifter argument. Och det är här, i linje 7-- OK, så jag har, citat unquote, det är min sträng till printf. Jag har en procenttecken. Men jag saknar det andra argumentet. 

Jag saknar kommatecken s, vilket Jag hade i tidigare exempel. Så en bra möjlighet att åtgärda en mer misstag, oavsiktligt. Och nu vill jag köra string0, typ i Zamyla. OK, hej Zamyla. 

Så vi har kört den här typen av program ett par olika gånger nu. Men låt oss göra något lite annorlunda den här gången. Istället för att bara skriva ut Zamyla s hela namnet med printf, låt oss göra det tecken för tecken. 

Jag kommer att använda en for-loop. Och jag kommer att ge mig själv en räkningsvariabel kallas i. Och jag kommer att hålla iteration, så länge som i är mindre än längden på s. 

Det visar sig, gjorde vi inte gör detta sista gången, att c kommer med en funktion kallad Stirling. Tillbaka i dag, och i allmänhet fortfarande vid genomförandet av funktioner, människor kommer ofta väljer mycket koncisa namn som typ av ljud precis vad du vill, även om det är saknas några vokaler eller bokstäver. Så Stirling är namnet på en funktion som tar ett argument mellan parenteser som bör vara en sträng. Och det bara returnerar ett heltal, längden på den strängen. 

Så detta för slinga på rad 7 kommer att börja räkna på i lika med 0. Det kommer att öka i på varje iteration med en, som vi har gjort ett par gånger. Men det kommer att bara göra detta fram till den punkt när i är längden av själva strängen. 

Så detta är ett sätt att, i slutändan, iterera över tecknen i strängen som det är följande. Jag kommer att skriva ut inte en hela sträng, men procent c, ett enda tecken följt av en ny rad. Och då kommer jag att gå vidare, och jag behöver att säga att jag vill skriva ut te karaktär s. 

Så om jag är den variabel som indikerar index för den sträng, där du i det, jag måste kunna säga, ge mig te karaktär s. Och c har ett sätt att göra detta med hakparenteser. Du säger helt enkelt namnet på sträng, som i detta fall är s. Då du använder hakparenteser, som är vanligtvis strax ovanför Retur tangent på tangentbordet. Och då du sätter index för tecken som du vill skriva ut. Så indexet kommer att bli en number-- 0, eller 1, eller 2, eller 3, eller dot, prick, pricka, något annat nummer. 

Och vi ser till att det kommer att vara rätt nummer, eftersom jag börja räkna på 0. Och som standard, det första tecknet i en sträng är genom konvention 0. Och det andra tecknet är konsolen 1. Och det tredje tecknet är fästet 2. Och du inte vill gå alltför långt, men vi kommer inte att vi är kommer att endast inkrementera jag tills den är lika med längden på strängen. Och vid vilken punkt, detta för slinga kommer att sluta. 

Så låt mig gå vidare och spara program, och kör gör sträng 0. Men jag skruvas upp. Underförstått att förklara biblioteksfunktion Stirling med sådan typ och such-- nu, detta låter bekant. Men det är inte printf. Och det är inte få sträng. 

Jag inte skruva upp i på samma sätt den här gången. Men märker här nere lite ner Vidare innefattar huvudet string.h, uttryckligen ger deklaration för Stirling. Så det finns faktiskt en ledtråd där. 

Och faktiskt det visar sig det finns en annan huvudfil att vi inte har använt i klass ännu är men det bland de tillgängliga till dig, som kallas string.h. Och i den filen, string.h är Stirling deklareras. Så låt mig gå vidare och spara, göra sträng 0-- trevlig, inga felmeddelanden här gången. 

./string0 Zamyla, och Jag är på väg att slå in, vid vilken punkt getString kommer att returnera strängen, placera den i er. Då det för slingan kommer att iterera över S tecken ett i taget, och skriva ut dem en per rad, på grund Jag hade att backslash n i slutet. Så jag kunde utelämna att bakstreck n, och sedan bara skriva Zamyla alla i samma linje, effektivt reimplementing printf, vilket inte är så användbar. Men i det här fallet, har jag inte gjort det. Jag har faktiskt tryckt en tecken i taget, en per rad, så att vi faktiskt se effekten. 

Men jag bör notera en sak här. Och vi kommer tillbaka till detta i en framtida vecka. Det visar sig att detta kod är potentiellt paraplyvagn. 

Det visar sig att få sträng och några andra funktioner i livet inte nödvändigtvis alltid tillbaka vad du förväntar sig. Vi vet från klass sista tid i detta att få sträng är tänkt att returnera en sträng. Men vad händer om användaren skriver en sådan en långt ord, eller punkt, eller uppsats att det finns helt enkelt inte tillräckligt minne i datorn så att den passar den. 

Liksom, tänk om något går fel under huven? Det kanske inte händer ofta, men det kan hända en gång på ett tag, mycket sällan. Och så visar det sig att få sträng och funktioner som det inte nödvändigtvis alltid återvänder strängar. De kan returnera något fel värde, några sentinel värde så att säga, som indikerar att något har gått fel. Och du skulle bara veta detta från ha lärt sig det i klassen nu, eller att ha läst några mer dokumentation. Det visar sig att få sträng kan returnera ett värde som kallas noll. Null är ett speciellt värde som vi ska komma tillbaka till i en framtida vecka. Men nu, vet bara att om jag vill att bli riktigt korrekt att gå vidare med Hämta sträng, jag bör inte bara kalla det, och blint använda sin returvärde, lita på att det är en sträng. 

Jag vill först säga, Vänta en minut, bara fortsätta om s inte är lika null, där null, återigen, är bara några särskilt värde. Och det är det enda speciellt värde du behöver oroa sig för get sträng. Få sträng antingen kommer att returnera en sträng eller null. 

Och detta utropstecken likhetstecken ni kanske vet från kanske matematik klass att du kan dra ett likhetstecken med en linje genom att ange inte är lika. Det är i allmänhet inte ett tecken du kan skriva på tangentbordet. Och så i de flesta programmeringsspråk, när du vill säga inte är lika, du använder ett utropstecken, annars känd som bang. Så du säger bang lika, vilket betyder inte lika logiskt. Det är precis som det inte finns en större än eller lika med eller mindre än eller lika med på tangentbordet som gör allt i en symbol. Så det är därför, i tidigare exempel, du gjorde ett öppet fäste, och sedan ett likhetstecken, för att göra större än eller, säg, mindre än. 

Så vad är takeaway här? Detta är helt enkelt ett sätt nu av införa denna syntax, den här funktionen, iteration över individuella tecken i en sträng. Och precis som de kvadrat konsoler kan du komma åt dem, överväga dessa hakparenteser som typ av antyder detta underliggande design, där varje karaktär insidan av en sträng är typ av förpackade i någonstans nedanför huven i datorns minne. 

Men låt oss göra en variant av detta. Det visar sig att detta Programmet är korrekt. Så per CS50: s axlar för att utvärdera kod, är detta korrekt nu. Speciellt nu när jag kontroll för null, bör detta program aldrig krascha. Och jag vet bara att av erfarenhet. Men det finns inget annat att Vi kan verkligen gå fel här. Men det är inte mycket väl utformad, eftersom låt oss gå tillbaka till grunderna. 

Först, principles-- vad gör en for-loop göra? En for-slinga gör tre saker. Den initierar några värde, om du frågar det. Det kontrollerar ett villkor. Och sedan efter varje iteration, efter varje cykel, det inkrementerar några värde eller värden, här. 

Så vad betyder det? Vi initiera jag till 0. Vi kontrollerar och se till att jag är mindre än längden på s, vilket är Z-A-M-Y-L-A, så som är mindre än sex. Och, faktiskt, 0 som mindre än sex. 

Vi skriver ut Z från Zamyla namn. Då kan vi öka i 0-1. Vi kontrollerar sedan, är en mindre än längden av er? Längd s är 6. Ja det är det. 

Så vi ut en i Zamyla namn, ZA. Vi öka i från 0 till 1, till två. Vi kontrollerar sedan, är två mindre än längden av Zamyla namn. 6- så två är mindre än sex. Ja, låt oss skriva ut nu M i Zamyla namn, det tredje tecknet. 

Det viktigaste här är att det på varje iteration av historien, jag kontroll, är jag mindre än längden på Zamyla? Men fångsten är att Stirling är inte en egenskap. De av er som har programmerat tidigare i Java eller andra språk kanske vet längden på en sträng är en fastighet, bara några skrivskyddat värde. 

I C i det här fallet, om det är en funktion som är bokstavligen räkning av antalet tecken i Zamyla varje gång Vi kallar denna funktion. Varje gång du frågar datorn att använda Stirling, det är att ta en titt på Zamyla, och säger Z-A-M-Y-L-A, 6. Och den returnerar 6. Nästa gång du ringer det insidan som for-loop, det kommer att titta på Zamyla Åter säger Z-A-M-Y-L-A, 6. Och det kommer att återvända sex. Så vad är dum om denna design? 

Varför är min kod inte en 5 av 5 för design just nu, så att säga? Tja, jag frågar en fråga i onödan. Jag gör mer arbete än jag behöver. 

Så även om svaret är rätt, jag frågar datorn, vad är längden av Zamyla igen, och igen, och igen, och igen? Och att svaret är aldrig kommer att förändras. Det kommer alltid att vara sex. 

Så en bättre lösning än detta skulle vara så här nästa version. Låt mig gå vidare och lägga den i en separat fil som heter string1.c, bara för att hålla isär. Och det visar sig i en för slinga, kan du faktiskt deklarera flera variabler samtidigt. 

Så jag kommer att hålla i och ställa det till 0. Men jag kommer också att lägga till ett kommatecken, och säga, ge mig en variabel som heter n, vars värde är lika med stränglängd s. Och nu, vänligen se mitt tillstånd så länge jag är mindre än n. 

Så på detta sätt, är logiken identiska vid slutet av dagen. Men jag minnas värde 6, i det här fallet. Vad är längden på Zamyla namn? Och jag sätter den på n. 

Och jag är fortfarande kontroll villkoret varje gång. Är 0 mindre än sex? Är en mindre än sex? Är två mindre än sex, och så vidare? 

Men jag ber inte datorn igen, och igen, vad är längden på Zamyla namn? Vad är längden på Zamyla namn? Vad är längden på detta Zamyla namn? Jag bokstavligen komma ihåg att första och bara svara på denna andra variabeln n. Så detta nu skulle vara inte bara korrekt, men också väl utformad. 

Nu, hur stil? Jag har namngett mina variabler ganska bra, skulle jag säga. De är super kortfattad just nu. Och det är helt bra. 

Om du har bara en sträng i ett program, du kan lika gärna kalla det är för sträng. Om du bara har en variabel för räkning i ett program, du kan lika gärna kalla det jag. Om du har en längd, n är super vanligt liksom. Men jag har inte kommenterat några av min kod. 

Jag har inte underrättat reader-- oavsett om det är min TF, eller TA, eller bara colleague-- vad är tänkt att gå på i det här programmet. Och på så sätt få god stil, vad jag vill göra är this-- något som ber användaren för inmatning. Och jag kunde skriva om detta på många olika sätt. 

Se till s-- ser till get strängen som returneras en sträng. Och sedan i här-- och det är kanske den viktigaste comment-- iterate över tecken i s en i taget. Och jag kunde använda Valet av engelska språket här för att beskriva varje av dessa bitar av kod. 

Lägg märke till att jag inte har lagt en kommentera varje kodrad, egentligen bara på den intressanta sådana, de som har en mening som jag kanske vill göra super klart för någon läsa min kod. Och varför är du ringer få sträng be användaren för inmatning? Även att man inte nödvändigtvis allt det beskrivande. Men det hjälper att berätta en historia, eftersom andra raden i historien, se få sträng tillbaka en sträng. 

Och den tredje raden i berättelsen är, iterera över karaktärerna i s en vid en tid. Och nu bara för bra åtgärd, Jag kommer att gå vidare och lägga till en mer kommentar som bara säger print i-te karaktär is. Nu, vad har jag gjort Vid slutet av dagen? 

Jag har lagt till några engelska ord i form av kommentarer. Den snedstreck snedstreck symbolen betyder, hej, dator är för människan, inte för dig, datorn. Så de ignoreras logiskt. De är bara där. 

Och faktiskt, CS50 IDE visar dem som grå, vara användbara, men inte nyckeln till programmet. Lägg märke till vad du nu kan göra. Oavsett om du vet C programmering eller inte, du kan bara stå tillbaka på detta program, och skumma kommentarerna. Be användaren för inmatning, se få sträng tillbaka en sträng, iterera över karaktärerna i s en i taget, ut tecknet i: te karaktär i s-- du inte även måste titta på koden att förstå vad detta program gör. Och ännu bättre, om du själv ser på detta program i en vecka eller två, eller en månad, eller ett år, du också inte har stirra på koden, försöka komma ihåg, vad jag försöker göra med denna kod? 

Du har sagt själv. Du har beskrivit det själv, eller någon kollega eller TA, eller TF. Och så skulle nu vara korrekt, och god design, och i slutändan bra stil också. Så gör ha det i åtanke. 

Så det finns en annan sak jag ska göra här som kan nu avslöja exakt vad som är pågår under huven. Så det finns den här funktionen i C och andra språk, kallas type-casting att antingen implicit eller uttryckligen tillåter dig att konvertera från en datatyp till en annan. Vi har arbetat så långt idag med strängar. 

Och strängar är tecken. Men minns från vecka 0, vilka är tecken? Tecken är bara en abstraktion ovanpå numbers-- decimaltal, och decimaltal är egentligen bara en abstraktion på toppen av binära tal, som vi definierat det. 

Så tecken är siffror. Och siffrorna är tecken, bara beroende på sammanhanget. Och det visar sig att insidan av ett datorprogram, kan du ange hur du vill titta på bitarna inne i programmet? 

Minns från vecka 0 som vi hade Ascii, vilket är just denna kod kartläggning brev till siffror. Och vi sade, kapital A är 65. Kapital B är 66, och så vidare. 

Och varsel, vi har i huvudsak tecken på den översta raden här, eftersom C skulle kalla dem, tecken, och sedan ints på den andra raden. Och det visar sig att du kan konvertera sömlöst mellan de två, typiskt. Och om vi vill göra detta medvetet, vi kanske vill ta itu med något som det här. 

Vi kanske vill konvertera versaler för att sänka fall eller gemener till versaler. Och det visar sig att det finns faktiskt ett mönster här vi kan omfamna på bara ett ögonblick. Men låt oss först titta på en exempel på att göra detta uttryckligen. 

Jag kommer att gå tillbaka till CS50 IDE. Jag kommer att skapa en fil kallad Ascii 0.c. Och jag kommer att gå vidare och lägga till min standard io.h upptill, int main tomrum på toppen av min funktion. Och då jag ska bara göra det following-- en for-loop från i lika, låt oss säga, 65. 

Och sedan jag kommer att vara mindre än 65, plus 26 bokstäver i alfabetet. Så jag ska låta datorn göra matten för mig där. Och sedan i denna slinga, vad ska jag skriva ut? 

% C är% i omvänt snedstreck n. Och nu vill jag att koppla in två värden. Jag har tillfälligt lagt fråga markerar det att bjuda in frågan. 

Jag vill upprepa från 65 och framåt för 26 bokstäverna i alfabetet, utskrift på varje iteration som karaktärs integrerad motsvarande. Med andra ord, vill jag iterera över 26 nummer utskrift vad ASCII är brevet, och vad motsvarande antal är-- egentligen bara återskapa diagrammet från att glida. Så vad bör dessa frågetecken vara? 

Tja, visar det sig att den andra bör bara vara variabeln i. Jag vill se det som ett tal. Och mitt argument Härifrån kan jag tala om för datorn att behandla den heltal i som en karaktär, så som att ersätta det här för procent C. 

Med andra ord, om jag, mänsklig programmerare, vet dessa är bara siffror Vid slutet av dagen. Och jag vet att 65 borde mappas till vissa tecken. Med detta explicit cast, med en parentes, namnet på den datatyp som du vill konvertera till, och en sluten parentes, du kan berätta dator, hej, dator, omvandla denna heltal till en röding. 

Så när jag kör detta program efter att sammanställa, Låt oss se vad jag get-- göra Ascii 0. Darn det, vad gjorde jag fel här? Användning av odeklarerat identifierare, okej, inte avsiktligt, men låt oss se om vi kan inte Anledningen till detta. 

Så linje five-- så jag inte fick mycket långt innan du skruvar upp. Det är ok. Så linje 5 för i lika 65-- jag ser. Så kom ihåg att i C, till skillnad från vissa språk om du har tidigare programmering erfarenhet, har du att tala om för datorn, Till skillnad från Scratch, vad typ av variabel är. 

Och jag glömde en nyckelfras här. I linje fem, jag har börjat använda i. Men jag har inte sagt C vilken datatyp det är. Så jag kommer att gå in här och säga, ah, gör det till ett heltal. 

Nu ska jag gå vidare och kompilera. Det fasta det. ./ascii0 Enter, det är ganska coolt. Inte bara är det supersnabb till be datorn denna fråga, snarare än att titta upp på en bild, Det skrivs ut en per rad, A är 65, B är 66, hela vägen down-- eftersom jag gjorde detta 26 times-- till bokstäverna z, vilket är 90. Och, faktiskt, något mer intelligent skulle har varit för mig att inte lita på datorn för att lägga till 26. Jag kunde bara gjort 90 också, så länge eftersom jag inte göra samma misstag två gånger. Jag vill gå upp genom z, inte bara upp genom y. 

Så det är en explicit rösterna. Det visar sig att detta är inte ens nödvändigt. Låt mig gå vidare och köra detta kompilator, och repris Ascii 0. Det visar sig att C är ganska smart. 

Och printf, i synnerhet, är ganska smart. Om du bara passerar en i två gånger för båda platshållare, printf kommer att inse, oh, ja jag vet att du gav mig ett integer-- ett visst antal, som 65 eller 90, eller vad som helst. Men jag ser att ni vill att jag ska formatera det numret som ett tecken. Och så printf kan helt klassificerad int till en röding för dig också. Så det är inte ett problem alls. 

Men märker, på grund av denna likvärdighet vi faktiskt kan göra detta. Låt mig gå vidare och göra en andra version av this-- Ascii 1.c. Och i stället för iteration över heltal, kan verkligen blåsa dig genom iteration över tecken. Om en char c blir kapital A, I vill gå vidare och göra det, så länge som C är mindre än eller lika kapital Z. Och på varje iteration Jag vill öka C, jag kan nu i min printf linje här säg, är procent C procent i igen, komma C. 

Och nu kan jag gå åt andra hållet, gjutning karaktären uttryckligen till ett heltal. Så, återigen, varför skulle du göra det? Det är lite konstigt att sortera av räkna i termer av tecken. 

Men om du förstår vad är pågår under huven, det finns verkligen ingen magi. Du bara säga hej, dator ge mig en variabel som heter C av typen char. Initiera det till kapital A. Och märke apostrof materia. 

För tecken i C, minns från förra veckan, använder du enkla citattecken. För strängar, för ord, fraser använder du dubbla citattecken. OK, dator, fortsätter att göra detta, så länge som det tecken är mindre än eller lika med z. Och jag vet av Ascii tabell som alla av dessa ASCII-koder är angränsande. 

Det finns några luckor. Så det är bara A till Z, separerade med ett antal vardera. Och då kan jag öka en röding, om jag verkligen vill. Vid slutet av dagen, Det är bara en siffra. Jag vet det här. Så jag kan bara förutsätta att lägga en till den. 

Och sedan den här gången, jag skriver ut c, och sedan integralen motsvarande. Och jag behöver inte ens ett uttryckligt rösterna. Jag kan låta printf och dator lista ut saker, så att nu om jag kör göra Ascii1./ascii1, Jag får exakt samma sak också. 

Värdelös program, though-- ingen kommer att faktiskt skriva programvara För att räkna ut, vad var det nummer som avbildas till A eller B, eller Z? Du bara gå till Google det, eller slå upp det på nätet, eller slå upp det på ett objektglas, eller liknande. Så varifrån kommer denna får faktiskt bra? 

Jo, på tal om det slide, märker att det finns en verklig mönster här mellan versaler och gemener som inte var en tillfällighet. Lägg märke till att kapital A är 65. Gemener a är 97. Och hur långt borta är gemena en? 

Så 65 är hur många steg bort från 97? Så 97 minus 65 är 32. Så kapital a är 65. Om du lägger till 32 till det, du får gemener a. Och, ekvivalent, om du subtrahera 32, du kommer tillbaka till kapital A-- samma med B för lite B, stora C till lite c. 

Alla dessa brister är 32 isär. Nu, detta förefaller att tillåta oss att göra något som Microsoft Word, eller Google Dokument funktionen där du kan välja allt och sedan säga, ändra alla till gemener, eller ändra alla till versaler, eller bara ändra det första ordet av en mening till versaler. Vi kan faktiskt göra något som att själva. 

Låt mig gå vidare och spara en fil här kallad kapitalisera 0.c. Och låt oss gå vidare och piska upp ett program som gör exakt det som följer. Så omfattar CS50 biblioteket. Och inkluderar standard I / O. 

Och jag vet att det kommer snart. Så jag kommer att sätta det i det redan, string.h, så jag har tillgång till saker som Stirling, och sedan int main tomrum, som vanligt. Och då kommer jag att gå vidare och göra strängar blir få sträng, bara för att få en sträng från användaren. Och då kommer jag att göra mitt förstånd kontroll. Om strängen inte är lika null, då är det säkert att fortsätta. Och vad vill jag göra? Jag kommer att upprepa från i lika med 0, och n fram till stränglängd s. 

Och jag kommer att göra detta så länge som Jag är mindre än n, och jag plus plus. Hittills har jag är verkligen bara låna idéer från förr. Och nu ska jag presentera en gren. 

Så tänker tillbaka på Scratch, där Vi hade dessa gafflar i vägen, och förra veckan i C. Jag ska säger detta, om det i: te karaktär is är större än eller lika med gemener a, och-- i Scratch du skulle bokstavligen säga och, men i C du säger ampersand, ampersand-- och den i: te karaktär is är mindre än eller lika med gemener z, Låt oss göra något intressant. Låt oss faktiskt skriva ut en karaktär med ingen ny rad det är tecknet i strängen, den i: te tecken i strängen. 

Men låt oss gå vidare och subtrahera 32 från det. Annars om tecknet i sträng som vi letar inte mellan Lite och lite z, gå vidare och bara skrivas ut oförändrad. Så vi har infört detta parantes notation för våra strängar att komma åt i: te tecken i strängen. 

Jag har lagt till några villkorslogik, som Scratch i förra veckans veckan en, där Jag bara använda min grundläggande förståelse av vad som är pågår under huven. Är den i: te karaktär s större än eller lika med ett? Liksom, är det 97, eller 98, eller 99, och så vidare? 

Men det är också mindre än eller lika till värdet av gemener z? Och i så fall, vad denna linje detta? 14, är denna typ av fröet till hela idén, kapitalisera brevet genom helt enkelt subtrahera 32 från det, i det här fallet, eftersom jag vet, per den diagram, hur mina nummer är representerade. Så låt oss gå vidare och köra, efter sammanställningen kapitalisera 0.c, och kör kapitalisera 0. 

Låt oss skriva in något som Zamyla i gemener anger. Och nu har vi Zamyla i versaler. Låt oss skriva in Rob i gemener. Låt oss försöka Jason i gemener. Och vi hålla få tvångs kapitalisering. Det finns en liten bugg som jag typ av inte förutse. Lägg märke till min nya prompt hamnar på samma linje som deras namn, vilket känns lite rörigt. 

Så jag kommer att gå här, och faktiskt i slutet av detta program skriva ut ett nyradstecken. Det är allt. Med printf, behöver du inte passera i variabler eller format kod. Du kan bokstavligen bara ut något som en ny rad. 

Så låt oss gå vidare och göra kapitalisera 0 igen, köra den, Zamyla. Och nu är det lite sötare. Nu är min prompt på egen ny rad. Så det är alla fina och bra. Så det är ett bra exempel. Men jag inte ens nödvändigtvis behöver hårdkoda 32. Vet du vad? Jag kunde säga-- jag inte någonsin minns vad skillnaden är. 

Men jag vet att om jag har en liten bokstav, Jag vill i huvudsak att subtrahera bort oavsett avståndet är mellan lite a och stora A, för om jag antar att alla de andra bokstäverna är desamma, som ska få jobbet gjort. Men i stället för att göra det, vet du vad? Det finns ett annat sätt fortfarande. 

Om det är kapitalisera 1.c-- om jag var att sätta in det i en separat fil. Låt oss göra kapitalisera 2.c enligt följande. Jag ska verkligen städa upp detta här. Och istället för att ens behöva vet eller bryr sig om de låg nivå genomförandet detaljer, jag är i stället bara att skriva ut ett tecken, quote unquote, procent C, och sedan ringa en annan funktion som existerar som tar ett argument, vilket är ett tecken, som den här. 

Det visar sig i C, det finns en annan funktionsanropet till övre, som precis som namnet antyder tar ett tecken och gör det till dess övre fall motsvarande och sedan återgår det så att printf kan koppla in den där. Och så för att göra detta, men jag behovet av att införa en annan fil. Det visar sig att det finns en annan fil att du bara skulle veta från klass, eller en lärobok eller en online referens, kallad C type.h. 

Så om jag lägger upp det bland min header filer, och nu åter kompilera programmet, capitalize2, ./capitalize2 Enter. Låt oss skriva in Zamyla i alla gemener, fungerar fortfarande densamma. Men vet du vad? Det visar sig att till övre har någon annan funktionalitet. 

Och låt mig presentera denna kommandot här sortens olyckligt namngiven, men man för manuell. Det visar sig att de flesta Linux-datorer, som vi använder här-- Linux operativsystem system-- har ett kommando kallas man, som säger, hej, dator, ge mig datorns manual. Vad vill du slå upp i handboken? 

Jag vill slå upp funktionen kallas till övre Enter. Och det är lite kryptisk att läsa ibland. Men märker vi är i Linux programmerare handbok. Och det är all text. Och märker att det är funktionens namn här uppe. Det visar sig att det har en kusin som heter att sänka, vilket gör det motsatta. Och meddelande enligt synopsis, att använda denna fungera manualsidan, så att säga, säger mig att jag måste inkludera c type.h. Och jag visste att från praktiken. 

Här är det visar mig de två prototyper för funktion, så att om jag någonsin vill använda denna Jag vet vad de tar som indata, och vad de återvänder som produktion. Och sedan om jag läste beskrivningen, ser jag mer i detalj vad funktionen gör. Men ännu viktigare, om Jag ser i returvärdet, det står värdet som returneras är den för den konverterade brev, eller C, den ursprungliga ingången, om omvandlingen var inte möjligt. 

Med andra ord, till den övre kommer att försöka att konvertera ett brev till versaler. Och om så är fallet, kommer det att lämna tillbaka den. Men om det inte kan för vissa reason-- kanske är det redan versaler, kanske är det ett utropstecken eller någon annan punctuation-- det kommer bara att återlämna originalet C, vilket betyder att jag kan göra min kod bättre utformade på följande sätt. 

Jag behöver inte alla dessa darn kodrader. Alla linjer jag har bara markerad kan kollapsas in i bara en enkel linje, som är this-- printf procent c till övre S fäste i. Och detta skulle vara en exempel på bättre design. 

Varför genomföra i 7 eller 8 rader kod, vad det var jag bara raderas, när du istället kan kollapsa allt detta logik och beslutsfattandet in en enda rad, 13 nu, som förlitar sig på ett bibliotek function-- en funktion som kommer med C, men att gör exakt vad du vill att den ska göra. Och, ärligt talat, även om Det kom inte med C, du kan genomföra det själv, eftersom vi har sett, med få negativa int och få positiv int förra veckan också. 

Denna kod är nu mycket lättare att läsa. Och faktiskt, om vi rulla upp, se hur mycket mer kompakt denna version av mitt program är. Det är en liten topp tung nu, med alla dessa ingår. Men det är OK, eftersom nu jag står på axlarna av programmerare före mig. Och vem det var som genomföras för att övre verkligen gjorde mig en tjänst, ungefär som den som implementeras Stirling verkligen gjorde mig en tjänst för en tid sedan. Och så har vi nu en bättre design program som implementerar exakt samma logik. 

På tal om Stirling, låt mig gå vidare och göra det. Låt mig gå vidare och spara denna fil som stirling.c. Och det visar sig, kan vi dra tillbaka ett annat skikt ganska enkelt nu. Jag kommer att gå vidare och piska upp ett annat program i huvud här som helt enkelt åter-redskap stränglängd som följer. Så här är en kodrad som får mig en sträng från användaren. Vi fortsätter att använda detta om och om igen. Låt mig ge mig en variabel som heter n av typen int som lagrar ett nummer. 

Och låt mig gå vidare och gör följande logik. Medan den n: te karaktär is gör inte lika bakstreck 0, gå vidare och öka n. Och sedan skriva ut printf procent v. Jag hävdar att detta program här, utan att stränglängd, räknar ut längden på en sträng. 

Och magin är helt inkapslad i linje 8 här med vad som ser ut som ny syntax, Detta snedstreck 0 i enkla citattecken. Men varför är det? Tja, överväga vad som varit pågår hela tiden. 

Och som en sidoreplik innan jag glömmer, inser också att utöver de manualsidorna som kommer med en typisk Linux-system som CS50 IDE, inse att vi, Naturligtvis personal, har också gjort en webbplats version av samma idé som kallas reference.cs50.net, som har alla dessa samma manualsidor, allt detta samma dokumentation, liksom en liten låda på toppen som gör att dig att konvertera alla av ganska svårbegripliga språk i mindre bekväm läge där vi, lärarkåren, har gått igenom och försökte att förenkla några av språket för att hålla saker och ting fokuserat på idéer, och inte några av teknikaliteter. Så kom ihåg, reference.cs50.net som en annan resurs också. 

Men varför stränglängd arbete det sätt jag föreslagit en stund sedan? Här är Zamyla namn igen. Och här är Zamyla namn inramad, som jag fortsätta göra, att måla en bild av att det är, egentligen bara en sekvens av tecken. Men Zamyla inte existerar isolerade i ett program. 

När du skriver och köra ett program, du använder din Mac eller PC som minne, eller RAM så att säga. Och du kan tänka på din dator ha massor av gigabyte minne i dessa dagar. Och en spelning betyder miljarder, så miljarder bytes. 

Men låt oss bakåt i tiden. Och antar att vi använder en riktigt gammal dator som endast har 32 byte minne. Jag kunde på min datorskärm, helt enkelt dra detta på följande sätt. 

Jag kan helt enkelt säga att min datorn har allt detta minne. Och detta är som en pinne av minne, om ni minns vår bild från förra gången. Och om jag delar bara detta i tillräckligt många gånger, Jag hävdar att jag har 32 bytes minne på skärmen. 

Nu, i verkligheten, jag kan bara dra så långt på den här skärmen här. Så jag kommer att gå framåt, och bara genom konventionen, dra datorns minne som en galler, inte bara som en rak linje. Specifikt, hävdar jag nu att detta nät, detta åtta av fyra galler, bara representerar alla 32 byte tillgängligt minne i min Mac, eller finns i min dator. Och de är omslag på två linjer, precis eftersom det passar mer på skärmen. Men detta är den första bitgruppen. Detta är den andra byten. Detta är den tredje byte. 

Och detta är den 32: a byte. Eller, om vi tänka som en dator forskare, är denna bitgrupp 0, 1, 2, 3, 31. Så du har 0-31, om du börja räkna på 0. 

Så om vi använder ett program att samtal får sträng, och vi får en sträng från människa som jag gjorde kallat Zamyla, Z-A-M-Y-L-A, hur i hela världen gör dator hålla reda på vilka byte, vilken bit av minne, som hör till vilken sträng? Med andra ord, om vi går vidare till skriver ett annat namn i datorn, så här Andi, ringa få sträng en andra gång, A-N-D-I har att hamna i datorns minne samt. Men hur? 

Tja, visar det sig att under huv, vilken C gör vid lagring av strängar att de humana typerna i, eller att komma från någon annan källa, är det avgränsar slutet av dem med en speciell character-- omvänt snedstreck 0, vilket är bara ett speciellt sätt att säga 80 bitar i rad. 

Så A-- detta är antalet 97 återkallelsen. Så vissa mönster av 8 bitar representerar decimaltal 97. Denna backslash 0 är bokstavligen antalet 0, alias nul, N-U-L, till skillnad från tidigare, N-U-L-L, som vi talat om. Men nu, bara vet att detta omvänt snedstreck 0 är bara 80 bitar i en rad. 

Och det är just detta rad i sand som säger något till vänster tillhör en sträng, eller en datatyp. Och allt till höger tillhör något annat. Andi namn, under tiden, som just visuellt händer att linda på till den andra linjen, men det är bara en estetisk detalj, på liknande sätt nul avslutas. 

Det är en sträng av en A-N-D-I tecken, plus en femte hemlig karaktär, alla 0 bitar, som bara avgränsar I slutet av Andi namn också. Och om vi kallar få sträng en tredje gång i datorn för att få en sträng som Maria, M-A-R-I-A, är på liknande sätt Marias namn nul avslutas med backslash 0. 

Detta är fundamentalt annorlunda från hur en dator skulle typiskt lagra ett heltal, eller en flottör, eller annan datatyper fortfarande, eftersom återkallande, ett heltal vanligtvis är 32 bitar, eller 4 byte, eller kanske till och med 64 bitar, eller åtta byte. Men många primitiva i en dator i ett programmeringsspråk har ett fast antal bytes under hood-- kanske en, kanske två, kanske fyra, kanske åtta. 

Men strängar, genom sin konstruktion, har en dynamisk antal tecken. Du vet inte i förväg, tills mänskliga typerna i Z-A-M-Y-L-A, eller M-A-R-I-A, eller A-N-D-I. Du vet inte hur många gånger användaren är på väg att slå tangentbordet. Därför behöver du inte vet hur många tecken i förväg du kommer att behöva. 

Och så C bara typ av blad som en hemliga brödsmula under huven vid slutet av strängen. Efter lagring Z-A-M-Y-L-A i minne, det också bara sätter den ekvivalenta av en period. Vid slutet av en mening, det sätter 80 bitar, så som komma ihåg var Zamyla börjar och slutar. 

Så vad är anslutningen då detta program? Detta program här, Stirling, är helt enkelt en mekanism för att få en sträng från användaren, rad 6. Linje 7, jag deklarera en variabel kallas n och ställ in den lika med 0. 

Och sedan i linje 8, frågade jag helt enkelt fråga, medan den n: te karaktär gör inte lika alla 0 bits-- med andra ord, inte lika denna speciella tecken, bakstreck 0, som var bara den speciella nul character-- gå vidare och bara öka n. 

Och fortsätta göra det, och hålla gör det, och fortsätta göra det. Och så även om det i Tidigare har vi har använt i, Det är väl bra semantiskt att använda n, om du försöker bara räkna den här gången medvetet, och bara vill kalla det n. Så här håller bara ställer frågan, är den n: te karaktär är alla 0: or? Om inte, se till nästa utseende, ser till nästa, se till nästa, ser till nästa. 

Men så fort du ser bakstreck 0, denna loop-- linje 9 genom 11-- stannar. Du bryta sig ur while-slingan, lämnar insidan av denna variabel n en total räkning av alla av tecken i strängen du såg, därigenom skriva ut det. Så låt oss prova detta. 

Låt mig gå vidare och, utan med hjälp av stirling-funktionen, men bara använda min egen hemmagjord version här kallad stirling, låt mig gå vidare och kör stirling, typ i något som Zamyla, som jag vet i förväg är sex tecken. Låt oss se om det fungerar. I själva verket är det sex. Låt oss försöka med Rob, tre tecken, tre tecken också, och så vidare. Så det är allt som händer på under huven. Och lägg märke till anslutningarna sedan, med den första veckan klass, där vi talade om något i stil med abstraktion, vilket är just denna skiktning av idéer, eller komplexitet, på toppen av grundläggande principer. Här, vi slags ser under huven Stirling, så att säga, att räkna ut, hur skulle det kunna genomföras? 

Och vi kunde åter genomföra det själva. Men vi kommer aldrig igen kommer att åter genomföra Stirling. Vi kommer bara att använda stirling i syfte att faktiskt få några strängar längd. 

Men det finns ingen magi under huven. Om du vet att under huven, en sträng är bara en sekvens av tecken. Och att sekvens av tecken alla kan numeriskt åtgärdas med konsol 0, konsol 1, hållare 2, och du vet att vid slutet av en sträng är en specialtecken, kan du räkna ut hur man gör de flesta något i en program, eftersom allt kokar ner till läser och skriver minne. Det vill säga, att ändra och letar på minnet, eller flytta saker runt i minnet, tryck saker på skärmen, och så vidare. 

Så låt oss nu använda denna nyfunna förståelse för vad strängar faktiskt är under huven, och skära ner ett annat skikt som fram till nu har vi ignorerat helt och hållet. I synnerhet som helst Vi har genomfört ett program, Vi har haft den här kodraden nära toppen förklara huvud. Och vi har angett int main tomrum. 

Och detta tomrum inuti parentesen har sagt hela tiden som huvud själv tar inga argument. Varje ingång som huvud är kommer att få från användaren måste komma från någon annan mekanism, som get int, eller få flyta, eller få sträng, eller någon annan funktion. Men det visar sig att när du skriver ett program, du faktiskt kan ange att detta program skall ta insignaler från den humana på kommandoraden själv. 

Med andra ord, även om vi hittills har varit igång just ./hello hej eller liknande program, alla i andra program som vi har använt, som vi själva inte skriva, har tagit, tycks det, kommandoraden arguments-- saker som gör. Du säger något som make, och sedan en andra ord. Eller klang, säger du klang, och sedan ett andra ord, namnet på en fil. 

Eller ens RM eller CP, som ni kanske har sett eller använt redan att ta bort eller kopiera filer. Alla av dem tar så kallade kommandoraden arguments-- ytterligare ord på terminalprompt. Men fram till nu, vi själva har inte haft denna lyx att ta input från användaren när han eller hon faktiskt körs själva programmet på kommandoraden. 

Men vi kan göra det genom att åter förklara Huvud framåt, inte ha ogiltig inom parentes, men dessa två argument instead-- den första ett heltal, och den andra något nytt, något som vi kommer att kalla en matris, något liknande i anden vad vi såg i Scratch som en lista, men en array med strängar, som vi snart se. Men låt oss se detta genom att hjälp av exempel, innan vi urskilja exakt vad det betyder. 

Så om jag går in i CS50 IDE Här har jag gått vidare och förklarade i en fil som heter argv0.c följande mall. Och märker enda som är annorlunda så långt är att jag har ändrat ogiltig int argc sträng argv öppen fäste, nära konsol. Och lägg märke till nu, det finns ingenting i dessa konsoler. 

Det finns inget nummer. Och det finns ingen i, eller n, eller någon annan bokstav. Jag bara använda hakparenteser för nu, av skäl som vi kommer tillbaka i ett ögonblick. 

Och nu vad jag ska göra är det. Om argc lika med lika med 2-- och erinrar om att lika jämlikar är jämställdhets operatör jämföra vänster och höger för jämställdhet. Det är inte uppdraget operatör, vilket är den enda likhetstecknet, vilket innebär kopia från höger till vänster ett visst värde. 

Om argc lika är lika med 2, vill jag säg, printf, hej, procent, ny rad, och sedan koppla in-- och här är den nya trick-- argv bygel 1, av skäl som att vi ska återkomma till om en stund. Else if argc inte lika 2, vet du vad? Låt oss gå vidare och, som vanligt, tryck ut Hello World utan ersättning. 

Så det verkar som om argc, som står för argument räkna, är lika med 2, Jag kommer att skriva ut hej något eller annat. Annars, som standard, jag är tryckningen hallå världen. Så vad betyder det? 

Nåväl, låt mig gå vidare och spara den här filen, och sedan göra göra argv0, och sedan ./argv0, Enter. Och det säger Hej världen. Nu, varför är det? 

Tja, visar det sig när du köra ett program på kommandoraden, du fyller i vad vi ska i allmänhet kallar ett argument vektor. Med andra ord, automatiskt dator, operativsystem, kommer att lämna till ditt program själv en lista över alla ord att människan skrivit på prompten om du programmeraren vill göra något med denna information. Och i detta fall, det enda ord Jag har skrivit vid prompten är ./argv0. 

Och så antalet argument som är som skickas till mitt program är bara en. Med andra ord, det argument räkna, annars känd som argc här som ett heltal, är bara en. En naturligtvis inte är lika två. Och så detta är vad skriver, hallå världen. 

Men låt mig ta någonstans. Låt mig säga, argv0. Och sedan hur om Maria? Och då slå Enter. 

Och lägg märke till vad magiskt händer här. Nu, i stället för Hello World, har jag förändrat beteende för detta program genom att ingången inte från get sträng eller någon annan funktion, men från tydligen mitt kommando själv, vad jag ursprungligen skrivits in. Och jag kan spela det här spelet igen genom ändra den till Stelios, till exempel. 

Och nu ser jag ett annat namn fortfarande. Och här kan jag säga Andi. Och jag kan säga Zamyla. Och vi kan spela detta spel hela dagen lång, bara koppla in olika värden, så länge jag ger exakt två ord på snabba, så att argc, mitt argument räkna, är två. 

Ser jag det namnet ansluten till printf, per detta villkor här? Så verkar vi ha nu uttrycksförmåga av att ta input från en annan mekanism, från den så kallade kommandorad, stället för att behöva vänta tills användaren kör programmet, och sedan be honom eller henne med hjälp av något som få sträng. 

Så vad är detta? Argc, återigen, är bara ett heltal, antalet words-- arguments-- att användaren tillhandahålls vid prompt, på terminalfönstret, inklusive programmets namn. Så vår ./argv0 är effektivt, programmets namn, eller hur jag köra programmet. 

Som räknas som ett ord. Så argc skulle vara ett. Men när jag skriver Stelios, eller Andi, eller Zamyla eller Maria, det betyder argumentet räkningen är två. Och så nu finns det två ord passerade i. 

Och varsel, kan vi fortsätta denna logik. Om jag faktiskt säga något i stil Zamyla Chan, ett fullständigt namn, och därmed passerar tre argument totalt, Nu står det standard igen, eftersom naturligtvis 3 inte är lika 2. 

Och så på det här sättet, jag har åtkomst via argv denna nya argument att vi kunde tekniskt kalla vad vi vill. Men enligt praxis, är det argv och argc, respektive. Argv, argument vektor, är snäll av en synonym för ett programmeringsspråk funktion i C kallas en array. 

En array är en lista med liknande värden tillbaka mot rygg, mot rygg, mot rygg. Med andra ord, om man är rätt här i RAM, är nästa intill det, och precis intill den. De är inte överallt. Och det senare scenariot, där saker och ting är överallt i minnet, kan faktiskt vara ett kraftfullt verktyg. Men vi kommer tillbaka till det när vi tala om finare datastrukturer. För nu, är en matris bara en bit av sammanhängande minne, var och en av vars element är tillbaka mot rygg, att backa, backa, och i allmänhet samma typ. 

Så om du tycker om, från en nyss, vad är en sträng? Tja, en sträng, som Zamyla, Z-A-M-Y-L-A, är tekniskt, bara en array. Det är en matris med tecken. 

Och så om vi verkligen dra detta, eftersom jag gjorde tidigare, som en bit av minne, det visar sig att var och en av dessa tecken tar upp en byte. Och så finns det den speciella sentinel karaktär, bakstreck 0, eller alla åtta 0 bitar, som avgränsar slutet av strängen. Så en sträng, visar det ut, citerar unquote sträng, är bara en array av chara-- char vara en verklig datatyp. 

Och nu argv, meanwhile-- Låt oss gå tillbaka till programmet. Argv, även om vi ser ordet sträng här är inte en sträng själv. Argv, argument vektor, är en array med strängar. 

Så precis som du kan ha en rad tecken, kan du ha högre nivå, en matris med strings-- så, till exempel, när jag skrev nyss ./argv0 argv0, utrymme Z-A-M-Y-L-A, hävdade jag att argv hade två strängar i det-- ./argv0, och Z-A-M-Y-L-A. I andra ord, var argc 2. Varför är det så? 

Jo, på ett effektivt sätt, är vad händer på är att var och en av dessa strängar är, naturligtvis, en matris med tecken som tidigare, vars samtliga tecken tar upp en byte. Och inte förväxla den faktiska 0 i programmets namn med 0, vilket innebär att alla 80 bitar. Och Zamyla, under tiden, är fortfarande också en rad tecken. 

Så i slutet av dagen, det är verkligen ser ut så här under huven. Men ArGV, som på grund av hur huvud verk, tillåter mig att svepa allt detta upp till, om man så vill, en större samling att om vi drygt förenkla hur bilden ser ut och inte helt dra det att skala upp det, denna samling är bara storlek 2, den första element, som innehåller en sträng, den andra delen av vilken innehåller en sträng. Och i sin tur, om du typ av zooma in på varje av dessa strängar, vad du se under huven är att varje sträng är bara en array av tecken. 

Nu, precis som med strängar, vi skulle kunna få tillgång till den i: te tecknet i en sträng använder den hakparentes notation. På liknande sätt, med arrayer I allmänhet kan vi använda klammer notation för att få på valfritt antal strängar i en matris? Till exempel, låt mig gå vidare och göra det. 

Låt mig gå vidare och skapa argv1.c, som är lite annorlunda den här gången. I stället för att kontrollera om argc2, Jag ska istället göra detta. För int jag får 0, är ​​jag mindre än argc, jag plus plus, och sedan skriva ut insidan av denna, procent s, ny rad, och sedan argv fäste i. 

Så med andra ord, jag är inte att göra med enskilda tecken för tillfället. Argv, vilket antyds av dessa tom ruta hängslen till höger om namnet argv, innebär argv är en array med strängar. Och argc är bara en int. 

Denna linje här, 6, är säger uppsättning i lika med 0. Räkna hela vägen upp till, men inte inklusive, argc. Och sedan på varje iteration, skriva ut en sträng. Vilken sträng? 

Den i: te sträng i argv. Så medan innan jag var med hjälp av hakparentes notation för att komma åt den i: te tecken i en sträng, nu Jag använder klammer notation för att komma åt den i: te strängen i en array. Så det är typ av ett skikt ovan, konceptuellt. 

Och så vad är snyggt om detta program nu, om jag sammanställa argv1, och sedan göra ./argv1, och skriv sedan i något som foo bar Baz vilka är de tre standard ord som en datavetare sträcker sig efter helst han eller hon behöver några platshållare ord, och tryck Enter, vart och ett av dessa ord, inklusive programmets namn, som är i argv i det första läget, hamnar skrivs ut en i taget. Och om jag ändrar detta, och jag säger något liknande argv1 Zamyla Chan, Vi får alla tre av dem ord, vilket är argv0, argv1, argv2, eftersom detta fall argc, räkningen, är tre. 

Men vad som är snyggt är om du förstår att argv är bara en array med strängar, och du förstår att en sträng är en rad tecken, Vi kan faktiskt typ av använda klammer notation flera gånger att välja en sträng, och sedan välja ett tecken i strängen, dykning i djupare enligt följande. I detta exempel, låt mig gå framåt och kallar detta argv2.c. Och i det här exemplet, låt mig gå vidare och gör following-- för int jag får 0, i är mindre än argc, i plus plus, precis som förut. Så i andra words-- och nu detta får tillräckligt komplicerat. Då kommer jag att säga iterera över strängar i argv, som en kommentar till mig själv. Och då jag kommer att ha en kapslade för loop, som du antagligen har gjort, eller anses gör, i Scratch, där Jag kommer att säga int-- jag inte kommer att använda i igen, eftersom jag inte vill skugga, eller sorts över den befintliga i. 

Jag ska i stället säga j, eftersom det är min gå till variabel när jag, när jag försöker bara räkna enkla siffror. För j får 0-- och även n, kommer att få aktern längd argv fäste i, så länge som j är mindre än m, j plus plus, gör följande. Och här är den intressanta delen. 

Skriv ut en karaktär och en ny linje, koppla in argv fäste i, fäste j. OK, så låt mig lägga till några kommentarer här. Iterera över tecken i nuvarande sträng, print j: te karaktär i i-te sträng. Så nu, låt oss betrakta vad dessa kommentarer betyder. 

Iterera över strängarna i argv-- hur många strängar är i argv, som är en array? Argc många, så jag iteration från i lika 0 upp till argc. Under tiden, hur många tecken är i den i: te strängen i argv? 

Jo, för att få det svaret, Jag kallar bara stränglängd på den aktuella strängen I vård om, vilket är argv fäste i. Och jag kommer att tillfälligt lagra att värde i n, bara för caching ändamål, att komma ihåg det för effektivitet. Och sedan ska jag initiera j till 0, fortsätt så länge j är mindre än n, och på varje iteration ökning j. 

Och sedan här, per min kommentar på linje 12, skriva ut ett tecken, följt av en ny rad, specifikt argv fäste Jag ger mig i: te sträng i argv-- så det första ordet, det andra ord, det tredje ordet, vad som helst. Och sedan j dyk i djupare och får mig j: te karaktär det ordet. Och så, i själva verket, du kan behandla argv som en flerdimensionell, som en två-dimensionell, array, varvid varje ord slags utseende så här i ditt sinne ögat, och varje tecken är typ av sammansatt en kolumn, om det hjälper. 

I verkligheten, när vi retas Detta lägenhets i kommande veckor, det kommer att vara lite mer sofistikerade än så. Men du kan verkligen tänker på det, för nu, som just detta tvådimensionella array, varvid en nivå av det är alla strängarna. Och sedan om du dyker djupare, du kan komma åt de enskilda tecknen däri med hjälp av denna notation här. 

Så vad är nettoeffekten? Låt mig gå vidare och göra argv2-- darn den. Jag gjorde ett misstag här. Underförstått att förklara biblioteksfunktion Stirling. Så hela tiden, är det kanske lämpligt att vi typ av efterbehandling exakt där vi började. 

Jag skruvas upp, underförstått att förklara biblioteksfunktion Stirling. OK, vänta en minut. Jag minns att särskilt eftersom det är just här. Jag måste inkludera string.h i denna version av programmet. 

Låt mig gå vidare och inkludera string.h, förutom att gå vidare och kompilera argv2. Och nu, här går vi, göra argv2, Enter. Och även om det är lite kryptiskt vid första anblicken, märka det, ja, vad skrivs är punkt argv2. 

Men om jag skriver några ord efter prompten som argv2 Zamyla Chan, Ange också lite kryptiskt vid första anblicken. Men om vi rulla tillbaka upp, ./argv2 Z-A-M-Y-L-A C-H-A-N. Så vi har itereras över varje ord. Och i sin tur, har vi itereras över varje tecken inom ett ord. 

Nu, efter allt detta, inse att det finns en annan detalj som vi har varit snäll ignorera hela tiden. Vi retad bara ifrån varandra vad huvudsakliga ingångar kan vara? Vad om huvud produktion? 

Hela denna tid har vi varit bara kopiera och klistra in ordet int framför huvud, om du kan se på nätet, ibland felaktigt i äldre versioner C och kompilatorer, att de säger tomrum, eller ingenting alls. Men, faktiskt, för den version C som vi använder, C 11, eller 2011, inser att det bör vara int. Och det bör antingen vara ogiltig eller argc och ArGV här. 

Men varför int main? Vad är det egentligen att återvända? Tja, visar det sig all denna tid, helst du har skrivit ett program huvud alltid återvänder något. Men det har varit att göra så i hemlighet. 

Att något är en int, som linje 5 antyder. Men vad int? Tja, det är det här konvent i programmering, varvid om ingenting har gått fel och allt är väl, program och funktioner i allmänhet return-- något counterintuitively-- 0. 0 innebär i allmänhet allt är väl. Så även om du tänker på det som falskt i många sammanhang, det faktiskt innebär i allmänhet en bra sak 

Samtidigt, om ett program returnerar 1, eller negativt 1, eller 5, eller negativ 42, eller icke-0 värde, som i allmänhet betecknar att något har gått fel. I själva verket, på din egen Mac eller PC, du kanske har faktiskt sett ett felmeddelande, varigenom det säger något eller andra fel kod negativ 42, eller felkod 23, eller något liknande. Det antalet är i allmänhet bara en antydan till programmeraren, eller företaget som gjorde programmet, vad som gick fel och varför, så att de kan titta igenom deras dokumentation eller kod, och räkna ut vad fel egentligen innebär. Det är i allmänhet inte användbar för oss slutanvändare. 

Men när huvud avkastning 0, är ​​allt väl. Och om du inte anger vad huvud skulle återvända, det kommer bara automatiskt tillbaka 0 för dig. Men återvänder något annars är faktiskt användbart. 

I denna sista program, låt mig gå vidare och kallar detta exit.c, och införa det sista av dagens ämnen, så kallade en felkod. Låt mig gå vidare och inkludera vår välbekanta filer där uppe, gör int main. Och den här gången, låt oss göra int argc, sträng argv, och med mina konsoler att innebära att det är i gruppen. Och låt mig bara göra en sanity check. Den här gången, om argc inte lika 2, då vet du vad? Glöm det. Jag kommer att säga att, hey, användare, du saknar Kommandoradsargumentet bakåtstreck n. 

Och då är det. Jag vill avsluta. Jag kommer att i förebyggande syfte, och i förtid verkligen, retur något annat än antalet 1. Gå till värdet för den första fel som kan hända är en. Om du har någon annan felaktig situation som kan uppstå, skulle man kunna säga retur två eller returnera 3, eller kanske till och med negativ en eller negativ 2. 

Dessa är bara slutkoder som är, i allmänhet, endast användbar till programmeraren, eller företag som är sjöfarten programvaran. Men det faktum att det är inte 0 är vad som är viktigt. Så om i det här programmet, jag vill garantera att detta program endast fungerar om användaren ger mig med ett argument räkna till två, namnet på programmet, och några andra ord, kan jag genomdriva så mycket som följer, skrika på användaren med printf säger, saknas kommandorad argument, tillbaka en. Det kommer bara omedelbart avsluta programmet. 

Endast om argc är lika med 2 kommer vi att få ner här, då jag tänker säga, hello procent s, omvänt snedstreck n, argv1. Med andra ord, jag är inte gå efter argv 0, vilket är bara namnet på programmet. Jag vill skriva ut Hej, komma, det andra ordet som det mänskliga maskinskrivna. Och i detta fall på linje 13, är allt väl. 

Jag vet att argc är 2 logiskt från detta program. Jag kommer att gå vidare och åter 0. Som en sidoreplik, tänk på att detta är sant i Scratch också. 

Logiskt sett kan jag göra detta och kapsla in dessa rader kod i denna annars klausul här. Men det är typ av onödan dra in min kod. Och jag vill göra super klart att oavsett vad, som standard, hej något kommer att skrivas, så länge som användaren samverkar. 

Så det är mycket vanligt att använda ett tillstånd, bara en om, att fånga några felaktiga situation, och sedan avsluta. Och då är så länge alla väl, inte har ett annat, men bara har koden utanför att om eftersom det är motsvarande i detta särskilda fall, logiskt. Så jag återvänder 0, bara för att uttryckligen betyda allt är väl. 

Om jag utelämnade avkastningen 0, skulle det automatiskt antas för mig. Men nu när jag återvänder en i åtminstone det här fallet, Jag ska, för bra åtgärd och klarhet, åter 0 i detta fall. Så låt mig nu gå vidare och göra exit, som är en perfekt SEGUE att bara lämna. 

Men göra exit, och låt mig gå vidare och göra ./exit, Enter. Och programmet skrek åt mig, saknas kommandorad argument. OK, låt mig samarbeta. 

Låt mig i stället göra ./exit, David, Enter. Och nu säger hej David. Och du skulle inte normalt ser detta. 

Men det visar sig att det finns en speciellt sätt i Linux för att faktiskt se med vilken utgång kod ett program avslutas. Ibland i ett grafiskt värld som Mac OS eller Windows, du bara ser dessa siffror när en felmeddelande dyker upp på skärmen och programmeraren visar det numret. Men om vi vill se vad felet meddelande är, vi kan göra det här-- så ./exit, Enter, tryck saknas kommandorad argument. 

Om jag nu gör echo $ ?, som är löjligt kryptiska ser. Men $? är den magiska besvärjelse som säger, hej, dator, berätta vad den tidigare programmets slutkoden var. Och jag trycker på Retur. Jag ser en, eftersom det är vad jag berättade min huvuduppgift att återvända. 

Under tiden, om jag gör ./exit David, och tryck Enter, ser jag, hej David. Och om jag nu gör echo $ ?, jag hej 0. Och så här kommer faktiskt vara värdefull information inom ramen för den debugger, inte så mycket att du är människa, skulle bry sig. Men debugger och andra program vi kommer att använda denna termin kommer ofta titta på det numret, även om det är typ av göms undan om du letar efter det, till avgöra om ett programs eller inte utförande var rätt eller fel. 

Och så det leder oss till detta, i slutet av dagen. Vi började i dag med att titta på felsökning, och i sin tur på kursen sig själv, och sedan mer intressant, tekniskt under huven vad strängar är, som varar vecka vi tog bara för givet, och tog verkligen dem för givet i Scratch. 

Vi tittade sedan på hur vi kan få tillgång till enskilda tecken i en sträng, och sedan igen tog en högre nivå titta på saker, titta på hur well-- Om vi ​​vill komma åt enskilda element i en lista liknande struktur, kan vi inte göra det med flera strängar? Och vi kan med kommandoradsargument. Men den här bilden här för bara lådor är demonstrativ av denna allmänna idé av en array, eller en lista eller en vektor. Och beroende på sammanhang alla dessa ord betyda lite olika saker. Så i C, vi bara gå att tala om en array. Och en mängd är en bit av minne, är var och en av vilka element är sammanhängande, tillbaka, att backa, att backa, att backa. 

Och dessa delar är i allmänhet, av samma datatyp, tecken, tecken, tecken, tecken, eller sträng, sträng, sträng, sträng, eller int, int, int, vad det är vi försöker att lagra. Men i slutet av dagen, är detta hur det ser ut konceptuellt. Du tar din datorns minne eller RAM. Och du carving ut i identiskt stora lådor, som alla är tillbaka, mot rygg, till tillbaka mot rygg på det här sättet. 

Och vad är trevligt om denna idé, och det faktum att vi kan uttrycka värden på detta sätt med den första av våra datastrukturer i klassen, innebär att vi kan börja att lösa problem med kod som kom så intuitivt i vecka 0. Du minns telefonen bok exempel, där Vi använde en söndra och härska, eller en binär sökalgoritm, att sålla igenom en hel gäng namn och nummer. Men vi trodde, minns, att det telefonbok redan sorteras, att någon annan hade redan figured out-- ges en lista med namn och numbers-- hur man alphabetize dem. Och nu när i C vi, också, har förmågan att lägga ut saker, inte fysiskt i en telefonbok men praktiskt taget i en dators minne, kommer vi att kunna nästa vecka att införa igen this-- den första av våra datastrukturer i ett array-- men ännu viktigare, själva datorn vetenskap algoritmer implementeras i koden, som vi kan lagra data i strukturer som detta, och sedan börja manipulera den, och att faktiskt lösa problem med det, och att bygga på toppen av det, i slutändan, program i C, i Python, i JavaScript, fråge databaser med SQL? 

Och vi ser att alla dessa olika idéer spärr. Men nu, påminna om att domän som vi införde i dag var denna sak här, och världen av kryptografi. Och bland de kommande problem som du själv kommer att lösa är konsten att kryptografi, kryptering och de-krypterings information och kryptering och dechiffrera text, och antar slutligen att du nu vet vad är under huven så att när du ser eller tar emot ett meddelande som detta, du själv kan dechiffrera det. Allt detta, och mer nästa gång. 

[VIDEOUPPSPELNING] 

-Mover Just anlänt. Jag kommer att gå besök hans college professor. Japp. Hej. Det är du. Vänta! David. Jag försöker bara att räkna ut vad som hände med dig. Snälla, vad som helst kan hjälpa till. Du var hans college rumskamrat, inte du? Du var där med honom när han avslutade CS50 projektet? 

[Musik spelar] 

-Det Var CS50. 

Jag älskar det här stället. 

-Ät upp. Vi går i konkurs. 

[END SPELA] 