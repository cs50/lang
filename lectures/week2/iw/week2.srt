1
00:00:00,000 --> 00:00:02,970
>> [מוסיקה מתנגנת]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> דוד י מלאן: בסדר.

4
00:00:15,700 --> 00:00:18,832
זהו CS50 וזה
הוא תחילת השבוע 2.

5
00:00:18,832 --> 00:00:21,040
ואתה זוכר שבמשך
בני הזוג של השבועות האחרונים,

6
00:00:21,040 --> 00:00:24,490
הצגנו מחשב
מדע, בתורו, תכנות.

7
00:00:24,490 --> 00:00:27,640
>> והתחלנו את הסיפור בדרך של
Scratch, ששפה גרפית

8
00:00:27,640 --> 00:00:28,990
מ מעבדת המדיה של MIT.

9
00:00:28,990 --> 00:00:30,780
ואז ולאחרונה,
בשבוע שעבר, עשה לנו

10
00:00:30,780 --> 00:00:34,450
להציג א א higher--
שפה ברמה נמוכה ידועה

11
00:00:34,450 --> 00:00:36,770
כמו C, משהו שהוא גרידא טקסטואלי.

12
00:00:36,770 --> 00:00:39,440
ואכן, הפעם האחרונה שאנחנו
בחן בתוך ההקשר

13
00:00:39,440 --> 00:00:40,450
מספר מושגים.

14
00:00:40,450 --> 00:00:43,010
>> כזכור, זה, היה מאוד
התוכנית הראשונה הסתכלנו.

15
00:00:43,010 --> 00:00:45,710
תוכנית זו, בפשטות,
מדפיס, "שלום, עולם".

16
00:00:45,710 --> 00:00:47,730
אבל יש כל כך הרבה
קסם לכאורה קורה.

17
00:00:47,730 --> 00:00:51,460
יש זה #include
עם סוגריים משולשים אלה.

18
00:00:51,460 --> 00:00:52,170
יש int.

19
00:00:52,170 --> 00:00:53,020
יש (void).

20
00:00:53,020 --> 00:00:56,330
יש סוגריים, סוגריים מסולסלים,
חצי נקודות, ולכן הרבה יותר.

21
00:00:56,330 --> 00:00:58,480
>> וכך, לזכור כי
הצגנו Scratch

22
00:00:58,480 --> 00:01:02,110
כדי שנוכל, באופן אידיאלי, לראות מעבר
תחביר זה, הדברים האלה באמת לא

23
00:01:02,110 --> 00:01:04,590
כל מה אינטלקטואלי
מעניין אבל בשלב מוקדם

24
00:01:04,590 --> 00:01:07,700
הוא, בהחלט, קצת מסובך
כדי לעטוף את דעתך.

25
00:01:07,700 --> 00:01:10,860
ואכן, אחד הנפוץ ביותר
דברים מוקדם בכיתת תכנות,

26
00:01:10,860 --> 00:01:13,443
במיוחד עבור אלה פחות
נוח, היא מתוסכלת

27
00:01:13,443 --> 00:01:17,460
והכשיל ידי תחבירי מסוים
שגיאות, שלא לדבר על שגיאות לוגיות.

28
00:01:17,460 --> 00:01:19,800
וכך בין מטרותינו
היום, למעשה, יהיה

29
00:01:19,800 --> 00:01:23,280
להיות לצייד אותך עם כמה
טכניקות לפתרון בעיות עבור כמה

30
00:01:23,280 --> 00:01:26,705
עדיף לפתור בעיות בעצמם
בצורה של באגים.

31
00:01:26,705 --> 00:01:29,330
ואתה זוכר, מדי, כי
הסביבה הצגנו

32
00:01:29,330 --> 00:01:31,780
בפעם האחרונה נקראה CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
זוהי תוכנה מבוססת אינטרנט
מאפשר לך לתכנת בענן,

34
00:01:34,850 --> 00:01:38,450
כביכול, תוך שמירה על כל שלך
קבצים יחד, כפי שאנו שוב יהיו היום.

35
00:01:38,450 --> 00:01:41,480
ולהיזכר שאנחנו
ובקר נושאים אלה כאן,

36
00:01:41,480 --> 00:01:44,480
ביניהם פונקציות, ולולאות, ו
משתנים, ביטויים בוליאני,

37
00:01:44,480 --> 00:01:45,110
ותנאים.

38
00:01:45,110 --> 00:01:49,190
ובעצם עוד כמה שאנחנו
תורגם מהעולם של Scratch

39
00:01:49,190 --> 00:01:50,800
לעולם של ג

40
00:01:50,800 --> 00:01:53,220
>> אבל הבניין הבסיסי
בלוקים, כביכול,

41
00:01:53,220 --> 00:01:55,150
באמת עדיין היו באותו השבוע שעבר.

42
00:01:55,150 --> 00:01:57,900
למעשה, אנחנו באמת פשוט היו
חתיכת פאזל שונה, אם תרצה.

43
00:01:57,900 --> 00:02:00,300
במקום כי סגול
להציל לחסום, אנחנו במקום

44
00:02:00,300 --> 00:02:02,940
היה printf, שהוא
פונקציה זו ב- C כי

45
00:02:02,940 --> 00:02:05,890
מאפשר לך להדפיס משהו
ולאתחל אותו על המסך.

46
00:02:05,890 --> 00:02:07,950
הצגנו את CS50
ספרייה, שבו אתה

47
00:02:07,950 --> 00:02:11,420
יש כיום get_char לרשותך,
ו get_int, ו get_string,

48
00:02:11,420 --> 00:02:14,610
וכמה פונקציות נוספות כמו
טוב, באמצעות שבו אתה יכול לקבל קלט

49
00:02:14,610 --> 00:02:16,260
מהמקלדת של המשתמש עצמו.

50
00:02:16,260 --> 00:02:20,640
וגם לקחנו מבט הדברים
כמו these- bool, ו char,

51
00:02:20,640 --> 00:02:22,490
פעמיים, לצוף,
int, מחרוזת long_long.

52
00:02:22,490 --> 00:02:25,170
ויש גם סוגי נתונים אחרים ב C.

53
00:02:25,170 --> 00:02:28,560
>> במילים אחרות, כאשר אתה מצהיר
משתנה לאחסן ערך כלשהו,

54
00:02:28,560 --> 00:02:32,600
או כאשר אתה מיישם פונקציה
המחזירה ערך כלשהו,

55
00:02:32,600 --> 00:02:35,290
אתה יכול לציין מה
סוג של ערך זה.

56
00:02:35,290 --> 00:02:37,310
האם מקבלת מחרוזת, כמו
רצף של תווים?

57
00:02:37,310 --> 00:02:39,490
האם מדובר במספר, כמו מספר שלם?

58
00:02:39,490 --> 00:02:41,390
האם זה נקודה צפה
ערך, או משהו דומה?

59
00:02:41,390 --> 00:02:46,180
אז ב- C, בניגוד Scratch, אנחנו בעצם
החל לציין איזה סוג של נתונים

60
00:02:46,180 --> 00:02:48,330
היינו חוזרים או משתמש.

61
00:02:48,330 --> 00:02:51,910
>> אבל, כמובן, אנחנו גם התנגשנו
כמה גבולות יסוד של מחשוב.

62
00:02:51,910 --> 00:02:54,100
ובפרט,
זה בשפת C, כזכור

63
00:02:54,100 --> 00:02:57,070
שלקחנו מבט
גלישה נומרית, המציאות

64
00:02:57,070 --> 00:03:00,460
שאם יש לך רק
כמות הזיכרון סופית

65
00:03:00,460 --> 00:03:04,600
או, במיוחד, מספר סופי
ביטים, אתם יכולים לסמוך כל כך גבוהים רק.

66
00:03:04,600 --> 00:03:08,460
וכך הסתכלנו בדוגמה זו כאן
לפיה מונה במטוס,,

67
00:03:08,460 --> 00:03:13,510
למעשה, אם פועל די זמן יכול היה
על גדותיהם לגרום תוכנה

68
00:03:13,510 --> 00:03:15,560
שגיאת פוטנציאל פיזית ממשית.

69
00:03:15,560 --> 00:03:18,600
>> גם הסתכלנו צף
חוסר דיוק נקודה, המציאות

70
00:03:18,600 --> 00:03:22,280
כי עם רק מספר סופי
ביטים, אם זה 32 או 64,

71
00:03:22,280 --> 00:03:27,330
ניתן לציין כל כך הרבה מספרים בלבד
אחרי נקודה עשרונית, ואחרי זה אתה

72
00:03:27,330 --> 00:03:29,110
מתחיל לקבל מדויק.

73
00:03:29,110 --> 00:03:32,360
כך למשל, שליש ב
עולם כאן, בעולמנו האנושי,

74
00:03:32,360 --> 00:03:35,360
מה שאנחנו יודעים הוא רק מספר אינסופי
של 3s לאחר הנקודה העשרונית.

75
00:03:35,360 --> 00:03:38,820
אבל מחשב לא יכול בהכרח
מייצג מספר אינסופי של מספרים

76
00:03:38,820 --> 00:03:42,590
אם אתה רק לאפשר לו כמה
כמות המידע סופית.

77
00:03:42,590 --> 00:03:45,900
>> אז לא רק אנחנו לצייד אותך
עם כוח גדול במונחים

78
00:03:45,900 --> 00:03:49,280
איך אתה יכול לבטא את עצמך
מקלדת מבחינת תכנות,

79
00:03:49,280 --> 00:03:51,430
אנחנו גם מוגבלים מה
אתה יכול לעשות בפועל.

80
00:03:51,430 --> 00:03:55,790
ואכן, באגים וטעויות יכולים
לנבוע מיני סוגיות אלה.

81
00:03:55,790 --> 00:03:59,900
ואכן, בין הנושאים היום
הולכים להיות נושאים כמו באגים

82
00:03:59,900 --> 00:04:03,699
ולמעשה מחפש משהו מתחת למכסה המנוע
כיצד הוכנסו דברים בשבוע שעבר

83
00:04:03,699 --> 00:04:05,490
הם למעשה מיושמים
כך שאתה טוב יותר

84
00:04:05,490 --> 00:04:10,530
להבין הן את היכולות של ו
המגבלות של שפה כמו ג

85
00:04:10,530 --> 00:04:14,770
>> ואכן, נצטרך לקלף את השכבות
המבנה הפשוט של נתונים,

86
00:04:14,770 --> 00:04:17,756
משהו שנקרא מערך, אשר
Scratch קורית מכנה "רשימה."

87
00:04:17,756 --> 00:04:19,589
זה קצת
שונה בהקשר זה.

88
00:04:19,589 --> 00:04:23,340
ואז אנחנו גם נכיר אחד
הראשון של בעיות ספציפיתלתחום שלנו

89
00:04:23,340 --> 00:04:26,790
ב CS50, העולם
קריפטוגרפיה, אמנות ערבול

90
00:04:26,790 --> 00:04:29,650
או הצפנת מידע כה
כי אתה יכול לשלוח מסרים סודיים

91
00:04:29,650 --> 00:04:34,520
ולפענח מסרים סודיים
בין שני אנשים, A ו- B.

92
00:04:34,520 --> 00:04:37,490
>> אז לפני המעבר אנחנו
לעולם החדש,

93
00:04:37,490 --> 00:04:42,059
בואו ננסה לצייד אותך עם כמה
טכניקות שבה ניתן לחסל

94
00:04:42,059 --> 00:04:43,850
או להפחית לפחות חלק
של תסכולים

95
00:04:43,850 --> 00:04:46,630
כי אתה כנראה נתקלת
במהלך השבוע האחרון בלבד.

96
00:04:46,630 --> 00:04:50,830
למעשה, לפני שאתה such-- חלק
הבעיות הראשונות שלך ב C. ואת רוב הסיכויים הם,

97
00:04:50,830 --> 00:04:54,010
אם אתה אוהב אותי, בפעם הראשונה
אתה מנסה להקליד את תכנית,

98
00:04:54,010 --> 00:04:57,330
גם אם אתה חושב בצורה הגיונית
התוכנית היא פשוטה למדי,

99
00:04:57,330 --> 00:05:01,200
ייתכן מאוד גם פגע בקיר, ו
המהדר לא הולך לשתף פעולה.

100
00:05:01,200 --> 00:05:03,940
הפוך או קלאנג לא הולך
למעשה כדי לעשות את ההצעה שלך.

101
00:05:03,940 --> 00:05:05,450
>> ולמה זה יכול להיות?

102
00:05:05,450 --> 00:05:07,950
ובכן, בואו נסתכל,
אולי, תכנית פשוטה.

103
00:05:07,950 --> 00:05:11,190
אני הולך קדימה, לשמור את זה ב
קובץ בשם בכוונה buggy0.c,

104
00:05:11,190 --> 00:05:13,590
כי אני יודע את זה
להיפגם מראש.

105
00:05:13,590 --> 00:05:17,400
אבל אני לא יכול להבין שאם זה
היא התכנית הראשונה או שנייה או שלישית

106
00:05:17,400 --> 00:05:18,830
כי אני בעצם עושה את עצמי.

107
00:05:18,830 --> 00:05:23,820
אז אני הולך קדימה,
להקליד, int main (void).

108
00:05:23,820 --> 00:05:28,130
ואז בתוך הסוגריים המסולסלים שלי,
מאוד מוכר ( "שלום, בעולם--

109
00:05:28,130 --> 00:05:30,980
מהלך סרק, n ") - וא-פסיק.

110
00:05:30,980 --> 00:05:32,360
>> שמרתי את הקובץ.

111
00:05:32,360 --> 00:05:34,850
עכשיו אני הולך לרדת
כדי חלון המסוף שלי

112
00:05:34,850 --> 00:05:40,340
וסוג לעשות buggy0, כי, שוב,
השם של הקובץ היום הוא buggy0.c.

113
00:05:40,340 --> 00:05:43,660
אז אני מקליד לעשות buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> ואה, אלוהים, זוכר מהפעם הקודמת
שאף הודעות שגיאה הוא דבר טוב.

115
00:05:48,200 --> 00:05:49,740
אז לא פלט הוא דבר טוב.

116
00:05:49,740 --> 00:05:52,920
אבל כאן יש לי בבירור
כמה מספר טעויות.

117
00:05:52,920 --> 00:05:56,470
>> אז השורה של הפלט הראשון
לאחר הקלדת לעשות buggy0, כזכור,

118
00:05:56,470 --> 00:05:59,540
הוא פלט מפורט למדי של קלאנג.

119
00:05:59,540 --> 00:06:02,067
מתחת למכסה המנוע,
IDE CS50 מוגדר

120
00:06:02,067 --> 00:06:04,150
להשתמש חבורה שלמה של
אפשרויות עם מהדר זה

121
00:06:04,150 --> 00:06:05,941
כך שאתה לא צריך
לחשוב עליהם.

122
00:06:05,941 --> 00:06:08,840
וזה כל מה השורה הראשונה
אמצעי שמתחיל עם קלאנג.

123
00:06:08,840 --> 00:06:11,720
>> אבל אחרי זה, הבעיות
מתחיל להפוך את המראה שלהם.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c על קו 3, אופי
5, יש טעות גדולה, אדומה.

125
00:06:17,390 --> 00:06:18,380
מה זה?

126
00:06:18,380 --> 00:06:23,562
במשתמע להכריז פונקצית ספרייה
printf עם int סוג (char * const,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
זאת אומרת, זה מהר מאוד
אהיה מאוד מסתורי.

129
00:06:28,379 --> 00:06:30,170
ובוודאי, בהתחלה
מבט, לא היינו

130
00:06:30,170 --> 00:06:32,380
מצפה ממך להבין את
מכלול ההודעה.

131
00:06:32,380 --> 00:06:34,213
וכך אחד הלקחים
היום הוא הולך

132
00:06:34,213 --> 00:06:36,919
להיות כדי לנסות להבחין
דפוסים, או דברים דומים,

133
00:06:36,919 --> 00:06:38,960
לטעויות שאולי יש לך
נתקלו בעבר.

134
00:06:38,960 --> 00:06:41,335
אז בואו ננסה להפריד רק
את המילים האלה כי נראו מוכרות.

135
00:06:41,335 --> 00:06:44,290
The Big, השגיאה האדומה ברורה
סמלי של משהו לטעות.

136
00:06:44,290 --> 00:06:47,940
>> במשתמע להכריז
printf פונקציה הספרייה.

137
00:06:47,940 --> 00:06:51,680
אז גם אם אני לא ממש מבין מה
במשתמע להכריז פונקצית ספרייה

138
00:06:51,680 --> 00:06:54,900
אמצעי, הבעיה ללא ספק
מתייחס printf איכשהו.

139
00:06:54,900 --> 00:06:59,130
ואת מקור הבעיה
קשור להצהיר על כך.

140
00:06:59,130 --> 00:07:02,440
>> הכרזה על פונקציה היא
להזכיר את זה בפעם הראשונה.

141
00:07:02,440 --> 00:07:06,210
ונהגנו המינוח בשבוע שעבר
של הכרזה על אב הטיפוס של פונקציה,

142
00:07:06,210 --> 00:07:11,860
גם עם קו אחד בראש שלך
קובץ לבד או קובץ כותרת שנקרא.

143
00:07:11,860 --> 00:07:15,300
ובאיזה קובץ עשה אנו אומרים
printf בשבוע שעבר כי הוא ציטוט,

144
00:07:15,300 --> 00:07:17,080
סוף ציטוט, הכריז?

145
00:07:17,080 --> 00:07:20,950
באיזה קובץ הוא אב הטיפוס שלו?

146
00:07:20,950 --> 00:07:24,640
>> אז אם אתה זוכר, הדבר הראשון שאני
מוקלד, כמעט כל תוכנית הבאה-- האחרון

147
00:07:24,640 --> 00:07:30,790
ובטעות רגע לפני נכתב
הקלדת myself-- היה כאן-- אחד זה

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- עבור
קלט / h נקודת output-- ואכן,

149
00:07:38,630 --> 00:07:41,860
ואם אני כותב עכשיו לשמור קובץ זה, אני הולך
כדי להמשיך לנקות את המסך שלי,

150
00:07:41,860 --> 00:07:44,740
שבו אתה יכול לעשות על ידי הקלדה
נקה, או שאתה יכול להחזיק שליטה L,

151
00:07:44,740 --> 00:07:47,680
רק כדי לנקות חלון המסוף שלך
רק כדי לחסל כמה עומס.

152
00:07:47,680 --> 00:07:51,370
>> אני הולך קדימה,
הקלד לעשות buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
והנה, אני עדיין רואה את זה
פקודה ארוכה קלאנג,

154
00:07:53,790 --> 00:07:55,470
אבל אין הודעת שגיאה הפעם.

155
00:07:55,470 --> 00:07:58,800
ואכן, אם אני עושה ./buggy0,
בדיוק כמו בפעם הקודמת,

156
00:07:58,800 --> 00:08:01,860
שם נקודה זה אומר
בספרייה, סלאש רק אומר,

157
00:08:01,860 --> 00:08:05,040
כאן מגיע השם של התוכנית
השם של התוכנית היא buggy0,

158
00:08:05,040 --> 00:08:07,340
זן, "שלום, עולם".

159
00:08:07,340 --> 00:08:09,440
>> עכשיו, איך ייתכן שיש לך
ליקט את הפתרון הזה

160
00:08:09,440 --> 00:08:12,017
בלי בהכרח
הכרה כמו מילים רבות

161
00:08:12,017 --> 00:08:14,350
כמוני, בהחלט, שיש
עשה זאת במשך כל כך הרבה שנים?

162
00:08:14,350 --> 00:08:18,720
ובכן, לממש לכל הבעיה הראשונה
סט, אנחנו מציגים לכם פקודה

163
00:08:18,720 --> 00:08:21,175
כי הצוות של CS50 עצמו
כתב בשם help50.

164
00:08:21,175 --> 00:08:24,300
ואכן, C עושה מפרט
הבעיה להגדיר כיצד להשתמש בשיטה זו.

165
00:08:24,300 --> 00:08:27,210
>> אבל help50 הוא במהותו
תוכנית הצוות של CS50

166
00:08:27,210 --> 00:08:30,850
כתב המאפשר לך להפעיל
פקודה או להפעיל תוכנית,

167
00:08:30,850 --> 00:08:36,169
ואם אתה לא מבין שלה
פלט, כדי לעבור את תפוקתו כדי help50,

168
00:08:36,169 --> 00:08:38,890
ובנקודה התוכנה
כי הצוות כמובן כתב

169
00:08:38,890 --> 00:08:42,429
יסתכלו הפלט של התוכנית שלך
שורה אחר שורה, תו אחר תו.

170
00:08:42,429 --> 00:08:46,000
ואם אנחנו, הצוות, להכיר
הודעת שגיאה שאתה חווה,

171
00:08:46,000 --> 00:08:50,580
ננסה לעורר אותך עם כמה
שאלות רטוריות, עם כמה עצות,

172
00:08:50,580 --> 00:08:54,890
הרבה כמו TF או CA או את עצמי
יעשה באופן אישי בשעות המשרד.

173
00:08:54,890 --> 00:08:58,320
>> אז נראה help50 אם לא
בהכרח מכירים בעיה.

174
00:08:58,320 --> 00:09:00,790
אבל לא לסמוך על זה
יותר מדי כמו קביים.

175
00:09:00,790 --> 00:09:03,990
בהחלט לנסות להבין שלה
ואז להדפיס וללמוד ממנו

176
00:09:03,990 --> 00:09:07,571
כך שרק פעם או פעמיים אתה
אי פעם לרוץ help50 עבור טעות מסוימת

177
00:09:07,571 --> 00:09:08,070
הוֹדָעָה.

178
00:09:08,070 --> 00:09:10,660
אחרי זה, אתה צריך להיות
מצויד טוב יותר את עצמך

179
00:09:10,660 --> 00:09:13,180
כדי להבין מה זה באמת.

180
00:09:13,180 --> 00:09:14,350
>> בוא נעשה אחד כאן אחרים.

181
00:09:14,350 --> 00:09:20,410
תן לי ללכת קדימה, ובאחרת
קובץ נתקשר buggy1.c זה.

182
00:09:20,410 --> 00:09:23,110
וגם בקובץ זה אני
הולך deliberately--

183
00:09:23,110 --> 00:09:26,330
אבל להעמיד פנים שאני לא
להבין מה הטעות שעשיתי.

184
00:09:26,330 --> 00:09:31,420
>> אני הולך קדימה, לעשות זה-
#include, מאז שאני

185
00:09:31,420 --> 00:09:33,660
לפני למד את הלקח שלי לרגע.

186
00:09:33,660 --> 00:09:36,220
העיקרי Int (void), כמו קודם.

187
00:09:36,220 --> 00:09:40,880
ואז הנה, אני הולך
לעשות מחרוזת s - get_string.

188
00:09:40,880 --> 00:09:43,770
ולהיזכר מהעת אחרונה
פירוש הדבר, היי, המחשב,

189
00:09:43,770 --> 00:09:48,280
תן לי משתנה, קוראים לזה S,
להפוך את סוג המשתנה מחרוזת

190
00:09:48,280 --> 00:09:50,150
אז אני יכול לאחסן פריט אחד או יותר מילים.

191
00:09:50,150 --> 00:09:52,191
>> ואז על-יד ימין
הצד של סימן השוויון

192
00:09:52,191 --> 00:09:54,980
הוא get_string, שהינה
פונקציה בספריית CS50

193
00:09:54,980 --> 00:09:55,980
שעושה בדיוק את זה.

194
00:09:55,980 --> 00:09:59,740
זה נהיה פונקציה ולאחר מכן
ידיים זה מימין לשמאל.

195
00:09:59,740 --> 00:10:02,670
אז סימן שוויון זה לא אומר
"שווה" כמו שאנחנו נוטים לחשוב במתמטיקה.

196
00:10:02,670 --> 00:10:04,750
זה אומר משימה מימין לשמאל.

197
00:10:04,750 --> 00:10:09,640
אז זה אומר, לקחת את החוט מן
המשתמש ולאחסן אותו בתוך הים.

198
00:10:09,640 --> 00:10:10,460
>> עכשיו בואו להשתמש בו.

199
00:10:10,460 --> 00:10:13,820
תן לי ללכת קדימה עכשיו וכתוצאה שנייה
קו, תן לי להמשיך ולומר "שלום" -

200
00:10:13,820 --> 00:10:19,330
לא "העולם", אבל "שלום,% s--
שהוא מציין המיקום שלנו, פסיק ים,

201
00:10:19,330 --> 00:10:22,030
וזה משתנה שלנו,
ואז נקודת פסיק.

202
00:10:22,030 --> 00:10:26,070
אז אם אני לא לפשל יותר מדי
כאן, זה נראה כמו קוד נכון.

203
00:10:26,070 --> 00:10:28,090
>> והאינסטינקטים שלי עכשיו הם להדר אותו.

204
00:10:28,090 --> 00:10:30,400
הקובץ נקרא buggy1.c.

205
00:10:30,400 --> 00:10:33,770
אז אני הולך לעשות לעשות buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
ולעזאזל-זה, אם אין
אפילו יותר טעויות מאשר לפני.

207
00:10:36,377 --> 00:10:38,210
אני מתכוון, יש עוד
הודעות שגיאה שזה יהיה

208
00:10:38,210 --> 00:10:40,400
נראה מ קווים בפועל בתכנית זו.

209
00:10:40,400 --> 00:10:42,730
>> אבל האוכל המוכן הוא כאן,
גם אם אתה המום

210
00:10:42,730 --> 00:10:45,040
עם שתיים או שלוש או
עוד ארבע הודעות שגיאה,

211
00:10:45,040 --> 00:10:48,340
להתמקד תמיד על מאוד
הראשון של הודעות אלה.

212
00:10:48,340 --> 00:10:52,220
כאשר מסתכלים על אחד העליון ביותר,
גלילה לגבות לפי הצורך.

213
00:10:52,220 --> 00:10:53,930
אז הנה הקלדתי לעשות buggy1.

214
00:10:53,930 --> 00:10:55,700
הנה כי פלט קלאנג כצפוי.

215
00:10:55,700 --> 00:10:57,290
>> והנה השגיאה האדומה הראשונה.

216
00:10:57,290 --> 00:11:02,370
שימוש מזהה מוצהרים
מחרוזת, היה, כוונתי סטנדרטית?

217
00:11:02,370 --> 00:11:04,260
אז סטנדרטי הוא
בעצם משהו אחר.

218
00:11:04,260 --> 00:11:06,240
זה מתייחס למשתמש של
מקלדת, בעצם.

219
00:11:06,240 --> 00:11:08,080
>> אבל זה לא מה שהתכוונתי.

220
00:11:08,080 --> 00:11:11,770
התכוונתי מחרוזת, והתכוונתי get_string.

221
00:11:11,770 --> 00:11:16,200
אז מה זה שאני
שכחתי לעשות הפעם?

222
00:11:16,200 --> 00:11:20,230
מה שחסר הפעם?

223
00:11:20,230 --> 00:11:23,600
יש לי #include שלי,
אז יש לי גישה printf.

224
00:11:23,600 --> 00:11:26,090
>> אבל מה שאני לא צריך
גישה עדיין?

225
00:11:26,090 --> 00:11:29,420
ובכן, בדיוק כמו בפעם הקודמת,
אני צריך לומר למהדר

226
00:11:29,420 --> 00:11:31,691
צלצול מה פונקציות אלו.

227
00:11:31,691 --> 00:11:33,940
Get_string לא בא
עם ג בפרט, זה

228
00:11:33,940 --> 00:11:38,160
לא לבוא
כותרת קובץ,.

229
00:11:38,160 --> 00:11:40,770
זה במקום מגיע
משהו הצוות כתב,

230
00:11:40,770 --> 00:11:44,176
שהוא קובץ שונה
שם אבל בצדק בשם.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> אז פשוט על ידי הוספת שורה זו
היזכרות code-- מפעם קודמת

233
00:11:50,861 --> 00:11:53,610
שכאשר קלאנג פועל, זה הולך
להסתכל למעלה הקוד שלי למטה,

234
00:11:53,610 --> 00:11:54,193
משמאל לימין.

235
00:11:54,193 --> 00:11:57,200
זה הולך שם לב,
אה, אתה רוצה.

236
00:11:57,200 --> 00:11:59,900
תן לי ללכת ולמצוא כי,
בכל מקום בו הוא נמצא בשרת,

237
00:11:59,900 --> 00:12:03,090
להעתיק ולהדביק אותו, בעצם,
לתוך החלק העליון של קובץ משלך

238
00:12:03,090 --> 00:12:06,820
כך שבשלב זה של הסיפור,
קו 1, שאר התוכנית

239
00:12:06,820 --> 00:12:11,651
אכן יכול להשתמש בכל הפונקציות
בהם, ביניהם get_string.

240
00:12:11,651 --> 00:12:13,650
אז אני הולך להתעלם
שאר שגיאות אלה,

241
00:12:13,650 --> 00:12:17,190
כי אני, אכן, חושד שרק
הראשון ממש חשוב.

242
00:12:17,190 --> 00:12:20,780
ואני הולך קדימה, שידור חוזר,
לאחר שמירת הקובץ שלי לעשות buggy1.

243
00:12:20,780 --> 00:12:22,580
וזהו, זה כן עובד.

244
00:12:22,580 --> 00:12:29,200
ואם אני עושה ./buggy1 באמצעות הקלדה עבור
למשל, Zamyla, אני עכשיו אקבל שלום,

245
00:12:29,200 --> 00:12:32,000
Zamyla, במקום שלום, העולם.

246
00:12:32,000 --> 00:12:32,550
>> בסדר.

247
00:12:32,550 --> 00:12:35,890
אז מזנונים כאן אז הם,
אחד, מנסה ללקט ככל שאתה יכול

248
00:12:35,890 --> 00:12:39,140
מן הודעות שגיאה לבד, מחפש
בכמה מילים לזיהוי.

249
00:12:39,140 --> 00:12:43,070
חוץ מזה, להשתמש help50 לכל
הבעיה להגדיר מפרט.

250
00:12:43,070 --> 00:12:46,500
אבל חוץ מזה, גם תמיד נראה
על השגיאה העליונה בלבד, לפחות

251
00:12:46,500 --> 00:12:50,051
בתחילה, כדי לראות איזה מידע
זה באמת עשוי להניב.

252
00:12:50,051 --> 00:12:52,300
אבל מתברר של שם
אפילו יותר פונקציונלי מובנית

253
00:12:52,300 --> 00:12:55,030
אל ספריית CS50 לעזור
אתה בשלב מוקדם בסמסטר

254
00:12:55,030 --> 00:12:57,580
וכבר בשלב מוקדם בתכנות
להבין מה השתבש.

255
00:12:57,580 --> 00:12:59,840
אז בוא נעשה דוגמה נוספת כאן.

256
00:12:59,840 --> 00:13:04,350
אני הולך להתקשר buggy2 זה, אשר,
שוב, הוא הולך להיות פגום החוצה

257
00:13:04,350 --> 00:13:05,650
השער, על ידי עיצוב.

258
00:13:05,650 --> 00:13:09,980
>> ואני הולך קדימה
ולעשות #include.

259
00:13:09,980 --> 00:13:12,580
ואז אני הולך לעשות int main (void).

260
00:13:12,580 --> 00:13:14,840
ואז אני הולך לעשות לולאת for.

261
00:13:14,840 --> 00:13:16,690
עבור (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
אני הוא פחות או שווה ל -10.

263
00:13:18,750 --> 00:13:24,260
i ++, ולאחר מכן ב סוגריים מסולסלים, אני הולך
רק כדי להדפיס את סמל hashtag כאן

264
00:13:24,260 --> 00:13:25,920
ומעניק לו אופי קו חדש.

265
00:13:25,920 --> 00:13:29,220
>> אז הכוונה שלי עם זה
התוכנית היא בפשטות

266
00:13:29,220 --> 00:13:33,150
כדי לחזר 10 פעמים
ועל כל איטרציה

267
00:13:33,150 --> 00:13:35,260
של לולאה שבכל פעם
דרך מחזור,

268
00:13:35,260 --> 00:13:37,660
להדפיס hashtag,
Hashtag, בתגית.

269
00:13:37,660 --> 00:13:40,480
בכל שורה אחת כי אני
יש את הקו החדש שם.

270
00:13:40,480 --> 00:13:42,787
וגם לזכור כי עבור
לולאה, לכל week-- האחרון

271
00:13:42,787 --> 00:13:44,620
ותקבל יותר
מכיר את התחביר

272
00:13:44,620 --> 00:13:47,170
באמצעות אותו עם תרגול
לפני long-- זה נותן לי

273
00:13:47,170 --> 00:13:49,740
משתנה בשם i ומניח אותו ל -0.

274
00:13:49,740 --> 00:13:52,650
>> זה מגדיל i על
כל איטרציה על ידי 1.

275
00:13:52,650 --> 00:13:54,940
אז אני הולך 1 עד 2 עד 3.

276
00:13:54,940 --> 00:13:57,690
ואז במצב הזה
באמצע בין--נקודתיים

277
00:13:57,690 --> 00:14:03,010
מקבל בדק בכל איטרציה לעשות
בטוח שאנחנו עדיין בטווח.

278
00:14:03,010 --> 00:14:06,830
אז אני רוצה לחזר 10 פעמים, אז אני
יש מעין מאוד אינטואיטיבי פשוט

279
00:14:06,830 --> 00:14:09,070
לשים 10 כמו הגבול העליון שלי שם.

280
00:14:09,070 --> 00:14:14,310
>> ובכל זאת, כשאני רציתי זה, לאחר
קומפילציה אותו עם איפור buggy2--

281
00:14:14,310 --> 00:14:15,440
וזה לקמפל אישור.

282
00:14:15,440 --> 00:14:17,980
אז אין לי
שגיאת תחביר פעם.

283
00:14:17,980 --> 00:14:20,940
תן לי ללכת קדימה עכשיו
ולהפעיל buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
ועכשיו לגלול מעלה.

285
00:14:22,620 --> 00:14:24,890
ותנו לי להגדיל
את גודל החלון.

286
00:14:24,890 --> 00:14:33,720
>> יש לי כנראה 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
אז יש 11 סולמית, למרות
אני בבירור לשים 10 בתוך לולאה זו.

288
00:14:38,891 --> 00:14:42,140
עכשיו, כמה מכם עשויים לראות מיד
מהי השגיאה כי, אכן, זו

289
00:14:42,140 --> 00:14:43,720
לא הוא טעות קשה מאוד לעשות.

290
00:14:43,720 --> 00:14:46,070
אבל זה מאוד נפוץ
עשה בשלב מוקדם מאוד.

291
00:14:46,070 --> 00:14:49,820
>> מה אני רוצה להצביע, אם כי,
היא, איך יכול אני להבין את זה?

292
00:14:49,820 --> 00:14:52,300
ובכן, מתברר כי
ספריית CS50 מגיעה

293
00:14:52,300 --> 00:14:55,380
עם לא רק get_string ו get_int
ו get_float ופונקציות אחרות.

294
00:14:55,380 --> 00:14:59,980
היא גם מגיעה עם תפקיד מיוחד
eprintf שנקרא, או, printf שגיאה.

295
00:14:59,980 --> 00:15:03,270
וזה קיים אך ורק כדי לעשות
זה קצת יותר קל לך

296
00:15:03,270 --> 00:15:06,310
כאשר באגים בקוד שלך פשוט
להדפיס הודעת שגיאה על המסך

297
00:15:06,310 --> 00:15:07,850
ולדעת מאיפה זה בא.

298
00:15:07,850 --> 00:15:11,000
>> כך למשל, דבר אחד אני יכול
לעשות כאן עם פונקציה זו זה--

299
00:15:11,000 --> 00:15:20,230
eprintf, ולאחר מכן אני הולך קדימה
ואומר אני עכשיו% i, מהלך סרק, n.

300
00:15:20,230 --> 00:15:22,330
ואני הולך לחבר את הערך של i.

301
00:15:22,330 --> 00:15:25,400
וגם למעלה, כי זה
הוא בספריית CS50,

302
00:15:25,400 --> 00:15:27,580
אני הולך קדימה
ולכלול

303
00:15:27,580 --> 00:15:29,169
אז יש לי גישה בפונקציה זו.

304
00:15:29,169 --> 00:15:31,460
אבל הבה נבחן מה קו
9 הוא אמור לעשות.

305
00:15:31,460 --> 00:15:32,670
אני הולך למחוק זאת בסופו של דבר.

306
00:15:32,670 --> 00:15:34,670
יש זה לא קשור
עם מטרת העל שלי.

307
00:15:34,670 --> 00:15:39,090
אבל eprintf, printf שגיאה, הוא פשוט התכוון
לתת לי קצת מידע אבחוני.

308
00:15:39,090 --> 00:15:42,460
כאשר אני מפעיל את התוכנית שלי, אני רוצה
לראות את זה על המסך באופן זמני

309
00:15:42,460 --> 00:15:44,550
גם פשוט להבין
מה קורה.

310
00:15:44,550 --> 00:15:47,330
>> ואכן, על כל
איטרציה כאן של קו 9

311
00:15:47,330 --> 00:15:49,260
אני רוצה לראות, מה הוא הערך של i?

312
00:15:49,260 --> 00:15:50,290
מהו הערך של i?

313
00:15:50,290 --> 00:15:51,280
מהו הערך של i?

314
00:15:51,280 --> 00:15:55,650
וגם, בתקווה, אני צריך רק
רואה את ההודעה, גם, 10 פעמים.

315
00:15:55,650 --> 00:15:57,780
>> אז תן לי ללכת קדימה
הידור התוכנית שלי,

316
00:15:57,780 --> 00:15:59,905
כפי שאני צריך לעשות בכל עת
אני עושה שינוי. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
ו now-- אישור.

319
00:16:03,640 --> 00:16:04,820
יש הרבה יותר קורה.

320
00:16:04,820 --> 00:16:07,610
אז תנו לי לגלול מעלה ב
חלון גדול עוד יותר.

321
00:16:07,610 --> 00:16:10,190
>> ותראה שכל אחד
הסולמית עדיין מדפיסה.

322
00:16:10,190 --> 00:16:15,270
אבל בין כל אחד מהם הוא עכשיו זה
פלט אבחון מעוצב כדלקמן.

323
00:16:15,270 --> 00:16:17,960
השם של התוכנית שלי כאן הוא buggy2.

324
00:16:17,960 --> 00:16:20,432
השם של הקובץ הוא buggy2.c.

325
00:16:20,432 --> 00:16:24,080
מספר הקו שממנו
זה הודפס הוא קו 9.

326
00:16:24,080 --> 00:16:27,500
ואז בצד ימין של זה הוא
הודעת שגיאה שאני מצפה.

327
00:16:27,500 --> 00:16:30,701
>> ומה שיפה זה הוא כי
עכשיו אין לי לספור בהכרח

328
00:16:30,701 --> 00:16:32,200
בראשי מה התוכנית שלי עושה.

329
00:16:32,200 --> 00:16:34,240
אני רואה את זה על
גרסה הראשונה i היא 0,

330
00:16:34,240 --> 00:16:39,420
אז 1, ואז 2, אז 3, אז 4, אז
5, ולאחר מכן 6, ולאחר מכן 7, אז 8, אז 9, אז

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
אז חכו רגע.

333
00:16:42,050 --> 00:16:43,740
מה קורה פה?

334
00:16:43,740 --> 00:16:48,190
אני עדיין נראיתי לספור
כמתוכנן עד 10.

335
00:16:48,190 --> 00:16:50,550
>> אבל מאיפה אני מתחיל?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
אז 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- האצבע -11

338
00:16:58,040 --> 00:16:59,990
הוא מעיד על הבעיה.

339
00:16:59,990 --> 00:17:02,850
נראה לי לספור
שגוי בלולאה שלי.

340
00:17:02,850 --> 00:17:06,599
במקום ללכת 10 חזרות,
אני מתחיל ב 0,

341
00:17:06,599 --> 00:17:09,550
אני מסיים ב ובאמצעות 10.

342
00:17:09,550 --> 00:17:12,030
אבל בגלל, כמו מחשב,
אני מתחיל לספור ב 0,

343
00:17:12,030 --> 00:17:15,250
אני צריך לספור עד
כדי, אבל לא דרך, 10.

344
00:17:15,250 --> 00:17:18,510
>> וכך את התיקון, אני בסופו של דבר
הבנתי כאן, הוא אחד משני דברים.

345
00:17:18,510 --> 00:17:22,430
יכולתי מאוד פשוט לומר
לספור עד פחות מ -10.

346
00:17:22,430 --> 00:17:27,260
אז 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, שהוא, אכן, נכון,

347
00:17:27,260 --> 00:17:28,900
למרות שזה נשמע טיפה לא בסדר.

348
00:17:28,900 --> 00:17:35,070
או שאני יכול לעשות פחות או שווה
עד 9, כל עוד אני מתחיל ב 0.

349
00:17:35,070 --> 00:17:40,056
לחלופין, אם אתה באמת לא אוהב את זה, אתה
יכול לספור עד דרך 10 אבל מתחיל ב 1.

350
00:17:40,056 --> 00:17:41,680
אבל שוב, זה פשוט לא כל כך נפוץ.

351
00:17:41,680 --> 00:17:43,977
בשנת programming-- אם כי
לא כל כך הרבה Scratch--

352
00:17:43,977 --> 00:17:45,810
אבל בתכנות ב
C ושפות אחרות,

353
00:17:45,810 --> 00:17:47,670
כמו JavaScript ו-
פייטון ואחרים, זה

354
00:17:47,670 --> 00:17:49,880
רק מאוד נפוץ
דיון בינארי שלנו

355
00:17:49,880 --> 00:17:53,450
רק להתחיל לספור על
המספר הנמוך ביותר שאתה יכול, וזה 0.

356
00:17:53,450 --> 00:17:53,950
בסדר.

357
00:17:53,950 --> 00:17:55,160
אז זה eprintf.

358
00:17:55,160 --> 00:17:58,600
ושוב, עכשיו אני כבר הבנתי שלי
בעיה, ואני הולך לחזור 0

359
00:17:58,600 --> 00:18:01,470
באמצעות פחות מ -10, אני הולך
ללכת ולמחוק eprintf.

360
00:18:01,470 --> 00:18:04,580
>> זה לא אמור להיות שם כשאני
ספינת הקוד שלי או לשלוח את הקוד שלי

361
00:18:04,580 --> 00:18:05,800
או להראות את זה לאף אחד אחר.

362
00:18:05,800 --> 00:18:07,980
זה באמת רק התכוון
כדי לשמש באופן זמני.

363
00:18:07,980 --> 00:18:11,650
אבל עכשיו אני כבר תיקנו את זה
בעיה מסוימת גם כן.

364
00:18:11,650 --> 00:18:16,780
>> ובכן, בוא נעשה דוגמה אחת יותר כאן
כי אני הולך להלהיב כדלקמן.

365
00:18:16,780 --> 00:18:22,850
אני הולך קדימה,
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
ואני הולך קדימה
ו #include.

367
00:18:25,580 --> 00:18:29,030
>> ואני הולך להציל
קובץ זה כמו buggy3.c.

368
00:18:29,030 --> 00:18:31,740
ואני הולך קדימה
ולהכריז int main (void).

369
00:18:31,740 --> 00:18:34,186
ואז בתוך משם
אני הולך לעשות int i _ -

370
00:18:34,186 --> 00:18:36,435
אני רוצה ליישם תוכנית
עם get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
זה לא פונקציה כי קיימת עדיין.

373
00:18:40,770 --> 00:18:42,870
אז אנחנו הולכים ליישם
זה בעוד רגע.

374
00:18:42,870 --> 00:18:45,541
אבל אנחנו הולכים לראות מדוע
זאת העגלה לעבר תג המעבר הראשון.

375
00:18:45,541 --> 00:18:47,290
וברגע קיבלתי
מספר שלם מהמשתמש,

376
00:18:47,290 --> 00:18:53,365
אני רק הולך להדפיס% i הוא שלילי
שלם, מהלך סרק, n, פסיק, אני.

377
00:18:53,365 --> 00:18:55,240
במילים אחרות, כל מה שאני
רוצה תוכנית זו לעשות

378
00:18:55,240 --> 00:18:58,000
הוא מקבל int שלילית
המשתמש ולאחר מכן להדפיס

379
00:18:58,000 --> 00:18:59,980
כי כזאת וכזאת היא int שלילית.

380
00:18:59,980 --> 00:19:02,080
>> עכשיו אני צריך ליישם פונקציה זו.

381
00:19:02,080 --> 00:19:05,740
אז בהמשך התיק שלי, אני הולך ללכת
קדימה ולהכריז פונקציה שנקראת

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - ואנו
לחזור למה קו זה אומר שוב

383
00:19:10,670 --> 00:19:18,790
בתוך n int moment--; תעשה-- מטלות
את n printf following-- הוא :.

384
00:19:18,790 --> 00:19:26,210
ואז אני הולך לעשות n - get_int,
ולעשות בזמן n זה גדול מ -0.

385
00:19:26,210 --> 00:19:28,310
ואז לחזור n ;.

386
00:19:28,310 --> 00:19:31,730
>> אז יש הרבה קורה
זה אבל אף אחד מהם לא אנחנו

387
00:19:31,730 --> 00:19:33,710
להסתכל בשבוע שעבר, לפחות לזמן קצר.

388
00:19:33,710 --> 00:19:36,980
אז על קו 10 והנה אני כבר הכרזתי על
פונקציה שנקראת get_negative_int,

389
00:19:36,980 --> 00:19:39,620
ואני מחזיר (void), ב
בסוגריים, והסיבה זו

390
00:19:39,620 --> 00:19:40,950
לא צריך להיות קלט.

391
00:19:40,950 --> 00:19:42,910
אני לא עובר שום דבר
לפונקציה זו.

392
00:19:42,910 --> 00:19:44,690
אני רק מקבל משהו בחזרה ממנו.

393
00:19:44,690 --> 00:19:47,270
>> ומה אני מקווה
לחזור הוא מספר שלם.

394
00:19:47,270 --> 00:19:50,040
אין סוג נתונים
C קרא negative_int.

395
00:19:50,040 --> 00:19:52,880
זה פשוט int, אז זה הולך
להיות עלינו לוודא

396
00:19:52,880 --> 00:19:55,340
שהערך בעצם
שהחזרת לא רק int

397
00:19:55,340 --> 00:19:56,380
אבל הוא גם שלילי.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 אני מכריז על משתנה
n קרא והפיכתו של int סוג.

399
00:20:02,150 --> 00:20:07,500
ואז עולה בקנה אחד 13 עד 18 אני
עושה משהו תוך משהו נכון.

400
00:20:07,500 --> 00:20:11,040
אני הולך קדימה והדפסה
N הוא, מעי גס, ולאחר מכן רווח,

401
00:20:11,040 --> 00:20:12,800
כמו פקודה עבור המשתמש.

402
00:20:12,800 --> 00:20:16,410
>> אז אני הולך להתקשר get_int ו
לאחסון ערך החזרה שנקרא שלה

403
00:20:16,410 --> 00:20:18,130
באותה n משתנה.

404
00:20:18,130 --> 00:20:22,600
אבל אני הולך להמשיך לעשות
n בזמן זה הוא גדול מ -0.

405
00:20:22,600 --> 00:20:27,960
במילים אחרות, אם המשתמש נותן לי
int ומספר כי הוא גדול מ -0,

406
00:20:27,960 --> 00:20:31,180
ergo, חיובי, אני הולך
רק לשמור reprompting המשתמש,

407
00:20:31,180 --> 00:20:37,160
לשמור reprompting, כופה עליהם
פעולה ולתת לי int שלילית.

408
00:20:37,160 --> 00:20:41,640
>> וברגע n הוא למעשה negative--
מניח המשתמש ולבסוף סוגים -50,

409
00:20:41,640 --> 00:20:46,710
אז הלולאה בזמן הזה היא כבר לא נכון
משום -50 אינו גדול מ -0.

410
00:20:46,710 --> 00:20:51,140
אז אנחנו לפרוץ כי
לולאה לוגית ולחזור n.

411
00:20:51,140 --> 00:20:53,520
>> אבל יש אחד אחר
דבר שאני צריך לעשות.

412
00:20:53,520 --> 00:20:56,190
ואני פשוט יכול לעשות את זה
על ידי העתקה והדבקה

413
00:20:56,190 --> 00:20:58,540
שורה אחת של קוד בחלק העליון של הקובץ.

414
00:20:58,540 --> 00:21:01,630
אני צריך ללמד קלאנג,
או מבטיח להרעיש,

415
00:21:01,630 --> 00:21:04,630
במפורש כי אני אעשה זאת,
אכן, ללכת וליישם

416
00:21:04,630 --> 00:21:06,020
get_negative_int בפונקציה זו.

417
00:21:06,020 --> 00:21:07,674
זה יכול להיות רק נמוך בקובץ.

418
00:21:07,674 --> 00:21:09,840
שוב, לזכור כי קלאנג
קורא דברים מלמעלה למטה,

419
00:21:09,840 --> 00:21:12,330
משמאל לימין, כך שאתה לא יכול
לקרוא לפונקציה אם קלאנג

420
00:21:12,330 --> 00:21:15,330
לא יודע שזה הולך להתקיים.

421
00:21:15,330 --> 00:21:18,430
>> עכשיו, למרבה הצער, תוכנית זו,
כפי שחלקכם אולי הבחין,

422
00:21:18,430 --> 00:21:19,590
כבר הוא מרכבה.

423
00:21:19,590 --> 00:21:21,400
תן לי ללכת קדימה ולעשות buggy3.

424
00:21:21,400 --> 00:21:26,904
זה הידור, אז הבעיה שלי כרגע היא לא
שגיאת תחביר, כמו שגיאה טקסטואלית,

425
00:21:26,904 --> 00:21:29,570
זה באמת הולך להיות הגיוני
שגיאה לי בכוונה

426
00:21:29,570 --> 00:21:32,450
עשה כהזדמנות
צעד דרך מה קורה.

427
00:21:32,450 --> 00:21:35,540
>> אני הולך קדימה
עכשיו ולהפעיל buggy3.

428
00:21:35,540 --> 00:21:37,490
ואני מתכוון ללכת
קדימה ולא לשתף פעולה.

429
00:21:37,490 --> 00:21:39,494
אני הולך לתת לו את המספר 1.

430
00:21:39,494 --> 00:21:41,410
זה לא מצא חן בעיניהם, כך
זה מה שגרם לי שוב.

431
00:21:41,410 --> 00:21:42,147
>> מה דעתך על 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
אף אחד מאותם עובדים.

435
00:21:44,740 --> 00:21:46,890
מה דעתך על -50?

436
00:21:46,890 --> 00:21:48,560
והתוכנית נראה לעבוד.

437
00:21:48,560 --> 00:21:49,970
>> תן לי לנסות את זה פעם נוספת.

438
00:21:49,970 --> 00:21:53,400
תן לי לנסות -1, נראה לעבוד.

439
00:21:53,400 --> 00:21:56,380
תן לי לנסות -2, נראה לעבוד.

440
00:21:56,380 --> 00:21:59,640
תן לי לנסות 0.

441
00:21:59,640 --> 00:22:01,684
הא, זה לא נכון.

442
00:22:01,684 --> 00:22:03,350
עכשיו, אנחנו להיות קצת קפדנים כאן.

443
00:22:03,350 --> 00:22:07,090
אבל זה, אכן, במקרה זה 0
אף אחת מהן אינו חיובי או שלילי.

444
00:22:07,090 --> 00:22:11,150
ולכן העובדה כי התוכנית שלי היא
ואמר כי 0 הוא מספר שלילי,

445
00:22:11,150 --> 00:22:12,820
זה לא נכון מבחינה טכנית.

446
00:22:12,820 --> 00:22:15,180
>> עכשיו, למה הוא עושה את זה?

447
00:22:15,180 --> 00:22:16,270
ובכן, זה יכול להיות מובן מאליו.

448
00:22:16,270 --> 00:22:18,110
ואכן, התוכנית היא
אמור להיות פשוט למדי

449
00:22:18,110 --> 00:22:19,670
אז יש לנו משהו לחקור.

450
00:22:19,670 --> 00:22:25,870
>> אבל בואו להציג באגים שלישיים
טכניקה כאן נקראת debug50.

451
00:22:25,870 --> 00:22:27,750
אז מדובר בתוכנית
כי כרגע יצרנו

452
00:22:27,750 --> 00:22:30,770
שנה בשם זה debug50
שיאפשר לך

453
00:22:30,770 --> 00:22:34,130
להשתמש במה שנקרא המובנית
הבאגים גרפיים IDE CS50.

454
00:22:34,130 --> 00:22:38,400
ו הבאגים הוא רק תוכנית
בדרך כלל מאפשר לך להריץ את התוכנית

455
00:22:38,400 --> 00:22:44,050
אבל צעד אחר צעד אחר צעד, קו
על ידי שורה אחר שורה, משתהה, תוקעת

456
00:22:44,050 --> 00:22:47,626
סביב, מביט משתנים כך
התוכנית אינה רק לפוצץ לך בעבר

457
00:22:47,626 --> 00:22:49,750
ובמהירות להדפיס משהו
או לא להדפיס משהו.

458
00:22:49,750 --> 00:22:53,250
זה נותן לך הזדמנות, ב
מהירות אנושית, כדי אינטראקציה עם זה.

459
00:22:53,250 --> 00:22:55,470
>> וכדי לעשות זאת, אתה
פשוט לבצע את הפעולות הבאות.

460
00:22:55,470 --> 00:22:58,479
לאחר קומפילצית הקוד שלך,
שכבר עשיתי, buggy3,

461
00:22:58,479 --> 00:23:00,020
שאתה הולך קדימה ולהפעיל debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
כל כך הרבה כמו help50 יש לך לרוץ
help50 ולאחר מכן את הפקודה,

464
00:23:06,760 --> 00:23:10,120
debug50 יש לך לרוץ debug50 ו
אז שם הפקודה.

465
00:23:10,120 --> 00:23:14,440
>> עכשיו שימו לב מה קורה על המסך שלי,
בצד הימני בפרט.

466
00:23:14,440 --> 00:23:19,400
כאשר אני מכה על הפעלה, כל
לוח זה ימני פתאומי

467
00:23:19,400 --> 00:23:20,419
נפתח על המסך.

468
00:23:20,419 --> 00:23:22,210
ויש הרבה אקשן
על במבט ראשון.

469
00:23:22,210 --> 00:23:25,110
אבל יש לא יותר מדי
הרבה מה לדאוג עדיין.

470
00:23:25,110 --> 00:23:28,570
>> זה מראה לי הכל
מה שקורה בתוך התוכנית שלי

471
00:23:28,570 --> 00:23:31,130
עכשיו ובאמצעות אלה
כפתורים למעלה אז

472
00:23:31,130 --> 00:23:35,910
שאיפשר לי התקדמות הדרגתית בקוד שלי
בסופו של דבר צעד אחר צעד אחר צעד.

473
00:23:35,910 --> 00:23:37,140
אבל לא רק זאת.

474
00:23:37,140 --> 00:23:38,060
שימו לב מה קורה.

475
00:23:38,060 --> 00:23:40,600
בשעת חלון המסוף שלי
אני בקשת אישור עבור n.

476
00:23:40,600 --> 00:23:44,560
ואני הולך קדימה
פעולה זמן מסוג זה -1.

477
00:23:44,560 --> 00:23:48,770
וגם אם כי קצת סתום, -1
הוא מספר שלילי, כצפוי.

478
00:23:48,770 --> 00:23:52,020
>> ואז הילד יצא עם
מצב 0 GDBserver היציאה.

479
00:23:52,020 --> 00:23:55,180
GDB, Debugger גנו, הוא שם
של התוכנה הבסיסית

480
00:23:55,180 --> 00:23:56,620
מיישמת הבאגים זה.

481
00:23:56,620 --> 00:24:00,500
אבל כל זה באמת אומר, הבאגים
הלכתי משם כי התכנית שלי להפסיק

482
00:24:00,500 --> 00:24:01,710
הכל היה טוב.

483
00:24:01,710 --> 00:24:06,020
אם אני רוצה לאתר באגים בתוכנית שלי באמת,
אני חייב לומר debug50 מנע,

484
00:24:06,020 --> 00:24:08,920
איפה אני רוצה להתחיל
דורך דרך הקוד שלי?

485
00:24:08,920 --> 00:24:11,750
>> ואולי הדרך הפשוטה
כדי לעשות זאת היא כדלקמן.

486
00:24:11,750 --> 00:24:15,300
אם אני מרחף מעל
מרזב של העורך שלי כאן,

487
00:24:15,300 --> 00:24:19,090
אז באמת רק בסרגל הצדדי כאן,
משמאל את מספר הקו,

488
00:24:19,090 --> 00:24:21,870
לב שאם אני פשוט לוחץ
פעם, שמתי נקודה אדומה קטנה.

489
00:24:21,870 --> 00:24:24,460
וזה נקודה אדומה קטנה,
כמו תמרור עצור, אומר, היי,

490
00:24:24,460 --> 00:24:29,430
debug50, להשהות ביצוע הקוד שלי
ממש המקום כאשר אני מפעיל תוכנית זו.

491
00:24:29,430 --> 00:24:30,260
>> אז בואו נעשה את זה.

492
00:24:30,260 --> 00:24:37,340
תן לי ללכת קדימה ולהפעיל את התוכנית שלי
./buggy3 שוב עם debug50, Enter.

493
00:24:37,340 --> 00:24:40,110
ועכשיו, הודעה, משהו
שונה קרה.

494
00:24:40,110 --> 00:24:42,440
אני לא בקשת אישור
עדיין בחלון המסוף שלי

495
00:24:42,440 --> 00:24:45,430
לכל דבר, כי יש לי לא
הגעתי לשם עדיין בתכנית שלי.

496
00:24:45,430 --> 00:24:47,950
שימו לב כי על קו 8
אשר מסומן כעת,

497
00:24:47,950 --> 00:24:51,720
ויש חץ קטן ב
אמרה שמאלית, אתה מושהה כאן.

498
00:24:51,720 --> 00:24:55,030
שורת הקוד הזאת, קו
8, לא שהנהלה.

499
00:24:55,030 --> 00:24:58,940
>> ומה מוזר, אם אני מסתכל
כאן בצד הימני,

500
00:24:58,940 --> 00:25:03,530
שים לב כי אני הוא מקומי
משתנה, מקומי במובן

501
00:25:03,530 --> 00:25:05,450
שזה בתוך הפונקציה הנוכחית.

502
00:25:05,450 --> 00:25:08,920
והערכה, כנראה כברירת מחדל,
ולמיין של נוח, הוא 0.

503
00:25:08,920 --> 00:25:10,260
אבל אני לא להקליד 0.

504
00:25:10,260 --> 00:25:13,410
זה קורה רק כדי להיות שלו
ערך ברירת מחדל כרגע.

505
00:25:13,410 --> 00:25:15,490
>> אז תן לי ללכת ולעשות את זה עכשיו.

506
00:25:15,490 --> 00:25:18,680
תן לי ללכת קדימה על
העליון ממש כאן, אני

507
00:25:18,680 --> 00:25:20,970
הולך קדימה
לחץ סמל ראשון זה אשר

508
00:25:20,970 --> 00:25:25,360
פירושו צעד מעל כלומר לא לדלג
זה אבל לדרוך על הקו הזה של קוד,

509
00:25:25,360 --> 00:25:27,770
ביצוע לאורך הדרך.

510
00:25:27,770 --> 00:25:30,710
>> ועכשיו, שימו לב, שלי
פקוד עתה השתנה.

511
00:25:30,710 --> 00:25:31,380
למה זה?

512
00:25:31,380 --> 00:25:33,639
כבר אמרתי debug50,
להפעיל את שורת הקוד.

513
00:25:33,639 --> 00:25:34,930
מה את שורת הקוד לעשות?

514
00:25:34,930 --> 00:25:35,960
מנחה אותי int.

515
00:25:35,960 --> 00:25:36,460
בסדר.

516
00:25:36,460 --> 00:25:37,400
הרשו לי לשתף פעולה.

517
00:25:37,400 --> 00:25:41,340
תן לי ללכת קדימה עכשיו ולהקליד -1, Enter.

518
00:25:41,340 --> 00:25:42,920
ועכשיו לב מה השתנה.

519
00:25:42,920 --> 00:25:46,060
בצד-יד ימין,
משתנה המקומי שלי אני

520
00:25:46,060 --> 00:25:48,200
מותווה כמו להיות -1 עכשיו.

521
00:25:48,200 --> 00:25:49,810
וזה עדיין של int סוג.

522
00:25:49,810 --> 00:25:53,102
>> ושימו לב, גם שלי שנקרא
קוראים מחסנית, מאיפה אני עוצר?

523
00:25:53,102 --> 00:25:54,810
נדברנו עוד על
זה בעתיד.

524
00:25:54,810 --> 00:25:58,620
אבל מחסנית הקריאות רק מתייחסת למה
פונקציות כרגע בתנועה.

525
00:25:58,620 --> 00:26:00,040
כרגע זה רק ראשי.

526
00:26:00,040 --> 00:26:03,590
וכרגע מקומי בלבד
משתנה הוא אני עם ערך של 1.

527
00:26:03,590 --> 00:26:09,840
>> וכאשר סוף סוף אני ניגשתי את הקו הזה
כאן, עם אותו סמל בצד ימין למעלה,

528
00:26:09,840 --> 00:26:11,410
-1 הוא מספר שלילי.

529
00:26:11,410 --> 00:26:13,580
עכשיו זה משתהה מעל במחוך מתולתל.

530
00:26:13,580 --> 00:26:14,740
בואו לתת לו לעשות את הדבר שלו.

531
00:26:14,740 --> 00:26:17,300
אני ניגש כי קו, וזהו.

532
00:26:17,300 --> 00:26:20,240
>> אז לא כל כך נורא
מחכימה עדיין,

533
00:26:20,240 --> 00:26:23,550
אבל זה לא תן לי להשהות
ולחשוב דרך לוגית

534
00:26:23,550 --> 00:26:24,870
מה התוכנית הזו עושה.

535
00:26:24,870 --> 00:26:26,890
אבל זה לא היה המקרה השגוי.

536
00:26:26,890 --> 00:26:28,510
בוא נעשה את זה שוב כדלקמן.

537
00:26:28,510 --> 00:26:31,340
>> אני הולך לעזוב נקודת עצירה כי
על קו 8 עם הנקודה האדומה.

538
00:26:31,340 --> 00:26:32,830
אני הולך להפעיל מחדש debug50.

539
00:26:32,830 --> 00:26:34,400
זה באופן אוטומטי עצר כאן.

540
00:26:34,400 --> 00:26:37,660
אבל הפעם, במקום
דורך על הקו הזה,

541
00:26:37,660 --> 00:26:42,290
תן לי בעצם להיכנס פנימה של
get_negative_int להבין,

542
00:26:42,290 --> 00:26:45,530
למה זה מקבל 0 כתשובה תקפה?

543
00:26:45,530 --> 00:26:47,990
>> אז במקום ללחוץ שלב נגמר.

544
00:26:47,990 --> 00:26:50,630
אני הולך קדימה
ולחץ צעד לתוך.

545
00:26:50,630 --> 00:26:54,030
ושימו לב שקו 8 זה
עכשיו הדגיש ועכשיו פתאום

546
00:26:54,030 --> 00:26:56,900
הופך קו 17.

547
00:26:56,900 --> 00:26:59,947
>> עכשיו, זה לא כל כך הבאגים
דלג על קווי 14 ו -15 ו -16.

548
00:26:59,947 --> 00:27:01,780
זה פשוט אין שום דבר
להראות לך שם.

549
00:27:01,780 --> 00:27:04,050
אלה הם רק הצהרה על משתנה,
ואז יש את המילה האם

550
00:27:04,050 --> 00:27:05,390
ואז מעין משענת מתולתלת פתוחה.

551
00:27:05,390 --> 00:27:09,227
השורה פונקציונלית רק זה
עסיסי באמת זה אחד כאן, 17.

552
00:27:09,227 --> 00:27:11,060
וכאן יש לנו
השהייה אוטומטית.

553
00:27:11,060 --> 00:27:13,870
>> אז printf ( "n.is:") ;, כך
כי עדיין לא קרה.

554
00:27:13,870 --> 00:27:18,250
אז בואו נלך קדימה ולחצו לדלג מעל.

555
00:27:18,250 --> 00:27:20,326
עכשיו הפקודה שלי, אכן,
שונה ( "n הוא:").

556
00:27:20,326 --> 00:27:22,450
עכשיו get_int, אני לא הולך
להטריד צועד לתוך,

557
00:27:22,450 --> 00:27:24,750
כי הפונקציה הייתה
שנעשה על ידי CS50 בספרייה.

558
00:27:24,750 --> 00:27:25,750
זה כנראה נכון.

559
00:27:25,750 --> 00:27:28,440
>> אז אני הולך קדימה,
מעין פעולה על ידי מתן

560
00:27:28,440 --> 00:27:30,590
int, אבל לא int שלילי.

561
00:27:30,590 --> 00:27:32,870
אז תן לי ללכת קדימה ופגעו 0.

562
00:27:32,870 --> 00:27:39,460
ועכשיו מה קורה כאן
כשאגיע לקו 21?

563
00:27:39,460 --> 00:27:40,890
אני כבר לא iterated שוב.

564
00:27:40,890 --> 00:27:43,320
אני לא נראיתי תקוע בלולאה.

565
00:27:43,320 --> 00:27:45,990
במילים אחרות, זה צהוב
בר לא להמשיך סביב,

566
00:27:45,990 --> 00:27:47,130
ומסביב, ומסביב.

567
00:27:47,130 --> 00:27:48,340
>> עכשיו, מדוע זה כך?

568
00:27:48,340 --> 00:27:49,920
ובכן, n, מה הוא n עכשיו?

569
00:27:49,920 --> 00:27:53,280
אני יכול להסתכל המקומי
משתנים הבאגים.

570
00:27:53,280 --> 00:27:53,816
n הוא 0.

571
00:27:53,816 --> 00:27:55,190
בסדר, מה היה המצב שלי?

572
00:27:55,190 --> 00:27:58,700
>> 20-- קו 20 הוא, ובכן,
0 הוא גדול מ -0.

573
00:27:58,700 --> 00:27:59,500
זה לא נכון.

574
00:27:59,500 --> 00:28:01,020
0 אינו גדול מ -0.

575
00:28:01,020 --> 00:28:02,820
וכך שברתי מתוך זה.

576
00:28:02,820 --> 00:28:06,370
>> וכך זה למה על קו
21, אם אני באמת להמשיך,

577
00:28:06,370 --> 00:28:10,370
אני הולך להחזיר 0, אפילו
אם הייתי צריך דחה 0

578
00:28:10,370 --> 00:28:12,484
לא ממש להיות שלילי.

579
00:28:12,484 --> 00:28:14,650
אז עכשיו, אני לא באמת אפילו
אכפת הבאגים.

580
00:28:14,650 --> 00:28:16,900
הבנתי, אני לא צריך
יודע מה עוד קורה.

581
00:28:16,900 --> 00:28:19,233
>> אז אני הולך קדימה,
רק ללחוץ על כפתור Play,

582
00:28:19,233 --> 00:28:20,240
ולתת לסיים את זה.

583
00:28:20,240 --> 00:28:23,440
עכשיו, אני כבר הבנתי כי שלי
הבאג הוא כנראה על קו 20.

584
00:28:23,440 --> 00:28:25,160
זה הטעות הלוגית שלי.

585
00:28:25,160 --> 00:28:28,100
>> אז מה אני רוצה
לעשות כדי לשנות זאת?

586
00:28:28,100 --> 00:28:32,500
אם הבעיה היא שאני לא
המושכים 0, זה פשוט טעות לוגית.

587
00:28:32,500 --> 00:28:35,910
ואני יכול לומר while n הוא
גדול או שווה ל -0,

588
00:28:35,910 --> 00:28:38,330
לשמור להציג הודעה למשתמש שוב ושוב.

589
00:28:38,330 --> 00:28:41,050
>> אז, שוב, טעות פשוטה, אולי
אפילו ברור כשראית אותי

590
00:28:41,050 --> 00:28:42,410
לכתוב את זה רק לפני כמה דקות.

591
00:28:42,410 --> 00:28:44,570
אבל ממסעדה כאן
הוא שעם debug 50,

592
00:28:44,570 --> 00:28:46,850
ועם באגים
תוכנה באופן כללי יותר,

593
00:28:46,850 --> 00:28:51,370
יש לך כוח מצא חדש זו כדי
ללכת דרך קוד משלך, להסתכל

594
00:28:51,370 --> 00:28:55,590
דרך כי לוח יד ימין מה
ערכי המשתנים שלך.

595
00:28:55,590 --> 00:28:57,700
אז אתה לא בהכרח
צריך להשתמש במשהו

596
00:28:57,700 --> 00:29:00,630
כמוך eprintf להדפיס ערכים אלה.

597
00:29:00,630 --> 00:29:04,430
אתה יכול ממש לראות אותם
ויזואלית על המסך.

598
00:29:04,430 --> 00:29:08,920
>> עכשיו, מעבר לכך, ראוי לציין
שיש טכניקה אחרת זה

599
00:29:08,920 --> 00:29:09,890
למעשה סופר משותף.

600
00:29:09,890 --> 00:29:13,120
ואתם עשויים לתהות מדוע הקטן הזה
הבחור כאן כבר יושב על הבמה.

601
00:29:13,120 --> 00:29:16,490
אז יש את הטכניקה הזו, בדרך כלל
המכונה באגים ברווז גומי,

602
00:29:16,490 --> 00:29:18,786
אשר באמת הוא רק
עדות לעובדה

603
00:29:18,786 --> 00:29:20,660
לעתים קרובות שכאשר מתכנתים
כותבים קוד,

604
00:29:20,660 --> 00:29:22,650
הם לא בהכרח
שיתוף פעולה עם אחרים,

605
00:29:22,650 --> 00:29:24,030
או עובד בסביבה משותפת.

606
00:29:24,030 --> 00:29:25,050
>> הם מעין בבית.

607
00:29:25,050 --> 00:29:25,910
אולי זה מאוחר בלילה.

608
00:29:25,910 --> 00:29:28,190
הם מנסים להבין
כמה באגים בקוד שלהם.

609
00:29:28,190 --> 00:29:29,330
והם פשוט לא רואים את זה.

610
00:29:29,330 --> 00:29:30,329
>> ואין שותפה.

611
00:29:30,329 --> 00:29:31,250
אין TF.

612
00:29:31,250 --> 00:29:32,680
אין CA סביב.

613
00:29:32,680 --> 00:29:36,440
כל מה שהם צריכים על המדף שלהם
הוא חמוד גומי הקטן הזה.

614
00:29:36,440 --> 00:29:39,030
>> וכך באגים ברווז גומי
רק היא הזמנה זו

615
00:29:39,030 --> 00:29:42,780
לחשוב על משהו מטופש
כמו זה כיצור אמיתי,

616
00:29:42,780 --> 00:29:46,940
ולמעשה ללכת דרך הקוד שלך
מילולית חפץ דומם זה.

617
00:29:46,940 --> 00:29:49,230
כך, למשל, אם
זה הדוגמה שלי כאן--

618
00:29:49,230 --> 00:29:52,470
ולהיזכר כי מוקדם יותר
הבעיה היתה זו,

619
00:29:52,470 --> 00:29:58,140
אם אמחק לשורה הראשונה זו קוד,
ואני להמשיך ולעשות מרכבה 0 שוב,

620
00:29:58,140 --> 00:30:01,220
זוכר שיש לי אלה
הודעות שגיאה כאן.

621
00:30:01,220 --> 00:30:05,997
אז הרעיון כאן, מגוחך אם כי אני
מרגיש כרגע עושה את זה בפומבי,

622
00:30:05,997 --> 00:30:06,580
השגיאה היא כי.

623
00:30:06,580 --> 00:30:10,910
>> אוקיי, אז הבעיה שלי היא שאני כבר
במשתמע הכריז פונקצית ספרייה.

624
00:30:10,910 --> 00:30:12,610
וזה פונקציה הספרייה printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- אישור, להכריז
מזכיר לי טיפוס.

626
00:30:15,290 --> 00:30:18,930
>> זה אומר שאני צריך באמת
לומר למהדר מראש מה

627
00:30:18,930 --> 00:30:19,980
הפונקציה נראית.

628
00:30:19,980 --> 00:30:20,930
חכה דקה.

629
00:30:20,930 --> 00:30:23,580
לא היה לי io.h. תקן

630
00:30:23,580 --> 00:30:24,530
תודה רבה.

631
00:30:24,530 --> 00:30:27,330
>> אז פשוט תהליך זה זה-- לך
לא צריך באמת ברווז.

632
00:30:27,330 --> 00:30:29,819
אבל הרעיון הזה של הליכה
עצמך דרך קוד משלך

633
00:30:29,819 --> 00:30:31,610
כך שאתה אפילו לשמוע
עצמך, כך שאתה

634
00:30:31,610 --> 00:30:35,620
להבין השמטות משלך
דבריו, הוא בדרך כלל את הרעיון.

635
00:30:35,620 --> 00:30:38,910
>> וגם, אולי יותר הגיוני, לא כל כך
הרבה את מה שראו עיניו אך מעורב יותר

636
00:30:38,910 --> 00:30:44,220
למשל אנחנו פשוט עושים 3.ג מרכבה,
ייתכן ללכת עצמך דרכו

637
00:30:44,220 --> 00:30:45,310
כְּדִלקַמָן.

638
00:30:45,310 --> 00:30:49,190
אז בסדר, גומי
חמוד, DDB, אם תרצו.

639
00:30:49,190 --> 00:30:52,350
כאן יש לנו בתפקוד העיקרי שלי,
אני מתקשר לקבל int שלילית.

640
00:30:52,350 --> 00:30:54,660
>> ואני מקבל את הערך המוחזר.

641
00:30:54,660 --> 00:31:00,410
אני אחסונו על צד שמאל
על קו 8 משתנה בשם i.

642
00:31:00,410 --> 00:31:02,380
בסדר, אבל רגע, איך עשה
מניבות ערך זה?

643
00:31:02,380 --> 00:31:04,130
תן לי להסתכל הפונקציה בתור 12.

644
00:31:04,130 --> 00:31:05,760
>> בתור 12, יש לנו לקבל int שלילית.

645
00:31:05,760 --> 00:31:08,190
לא לוקח שום תשומות,
אין להחזיר int, אישור.

646
00:31:08,190 --> 00:31:10,929
אני מצהיר על קו 14 n משתנה.

647
00:31:10,929 --> 00:31:12,220
זה הולך לאחסן מספר שלם.

648
00:31:12,220 --> 00:31:13,760
זה מה שאני רוצה.

649
00:31:13,760 --> 00:31:18,480
>> אז לבצע את הפעולות הבאות תוך n הוא-- לתת
לי לבטל את מה את התיקון כבר עשה.

650
00:31:18,480 --> 00:31:22,710
אז בזמן n גדול מ
0, להדפיס n זה, או קיי.

651
00:31:22,710 --> 00:31:25,170
ואז לקרוא מאוחסנים int ב n.

652
00:31:25,170 --> 00:31:30,160
ואז לבדוק אם n הוא 0,
n הוא not-- זה מה שיש.

653
00:31:30,160 --> 00:31:31,910
אז, שוב, אתה לא
צריך הברווז בפועל.

654
00:31:31,910 --> 00:31:35,650
אבל רק הליכה עצמך דרך
הקוד שלך כתרגיל אינטלקטואלי

655
00:31:35,650 --> 00:31:37,720
לעתים קרובות יעזור לך
להבין מה קורה,

656
00:31:37,720 --> 00:31:41,170
לעומת רק עושה משהו
ככה, בוהה במסך,

657
00:31:41,170 --> 00:31:43,720
ולא לדבר את עצמך דרך
זה, אשר בכנות הוא לא

658
00:31:43,720 --> 00:31:46,270
כמעט כמו טכניקה יעילה.

659
00:31:46,270 --> 00:31:48,620
אז יש לך את זה,
מספר טכניקות שונות

660
00:31:48,620 --> 00:31:52,102
עבור למעשה באגים בקוד שלך
ומציאת תקלות, שכולן

661
00:31:52,102 --> 00:31:54,810
צריך להיות כלי Toolkit שלך
כך שאתה לא מאוחר בלילה,

662
00:31:54,810 --> 00:31:57,660
במיוחד, אתה בחדר האוכל
אולמות, או בשעות המשרד,

663
00:31:57,660 --> 00:32:00,368
לדפוק את הראש נגד
קיר, מנסה לפתור בעיה כלשהי.

664
00:32:00,368 --> 00:32:02,020
להבין כי יש כלי תוכנה.

665
00:32:02,020 --> 00:32:03,720
ישנם כלי ברווז גומי.

666
00:32:03,720 --> 00:32:09,630
ויש גם כל הצוות של
לתמוך מחכה להושיט יד.

667
00:32:09,630 --> 00:32:13,120
>> אז עכשיו, מילה על הבעיה
סטים, ועל מה אנחנו מקווים שאתה

668
00:32:13,120 --> 00:32:15,620
לצאת מהם, וכיצד
אנחנו הולכים על הערכה.

669
00:32:15,620 --> 00:32:17,680
לפי הסילבוס של הקורס,
סטי הבעיה של CS50

670
00:32:17,680 --> 00:32:22,320
מוערכים על ארבעה צירים הראשיים שלו, כך
כדי speak-- היקף, נכונותו, עיצוב,

671
00:32:22,320 --> 00:32:23,060
וסגנון.

672
00:32:23,060 --> 00:32:25,910
והיקף רק מתייחס כמה
של היצירה יש לך בנשיכה?

673
00:32:25,910 --> 00:32:28,080
כמה של בעיה ניסית?

674
00:32:28,080 --> 00:32:30,110
מה מידת המאמץ
יש לך מתבטא?

675
00:32:30,110 --> 00:32:35,750
>> תקינות היא, עושה את העבודה בתכנית כמו
זה אמור לפי המפרט CS50

676
00:32:35,750 --> 00:32:38,640
כאשר אתה מספק תשומות מסוימות
או פלטים מסוימים חוזרים?

677
00:32:38,640 --> 00:32:41,130
עיצוב הוא סובייקטיבי רובם.

678
00:32:41,130 --> 00:32:43,360
וזה אחד כי יהיה
שלוקח הכי הרבה זמן ללמוד

679
00:32:43,360 --> 00:32:47,220
ואת הארוך ביותר ללמד, ב
עד כה כפי שהוא מסתכם,

680
00:32:47,220 --> 00:32:49,530
איך כתוב היטב הוא הקוד שלך?

681
00:32:49,530 --> 00:32:52,920
>> זה דבר אחד פשוט להדפיס את הנכון
פלטים או להחזיר את הערכים הנכונים.

682
00:32:52,920 --> 00:32:55,400
אבל אתה עושה את זה כמו
ביעילות רבה ככל האפשר?

683
00:32:55,400 --> 00:32:58,210
אתה עושה את זה פרד
ומשול, או בינארי

684
00:32:58,210 --> 00:33:01,500
חיפוש כפי שאנו בקרוב נראה שעשינו
שבועיים לפני עם ספר הטלפונים?

685
00:33:01,500 --> 00:33:04,670
האם יש דרכים טובות יותר כדי לפתור את
בעיה מאשר כיום יש לך כאן?

686
00:33:04,670 --> 00:33:06,380
זה הזדמנות עבור עיצוב טוב.

687
00:33:06,380 --> 00:33:08,530
>> ואז style-- איך
די הוא הקוד שלך?

688
00:33:08,530 --> 00:33:12,370
תוכל להבחין כי אני די
בפרט על זחת הקוד שלי,

689
00:33:12,370 --> 00:33:15,300
ולוודא משתנים שלי
נקראים באופן סביר. n,

690
00:33:15,300 --> 00:33:19,660
זמן קצר, הוא שם טוב
מספר, אני עבור מספר שלם ספירה,

691
00:33:19,660 --> 00:33:20,727
ים עבור מחרוזת.

692
00:33:20,727 --> 00:33:22,560
ואנחנו יכולים להיות עוד
סגנון שמות משתנים.

693
00:33:22,560 --> 00:33:25,500
סגנון הוא פשוט כמה טוב
אין הקוד שלך נראה?

694
00:33:25,500 --> 00:33:26,600
ואיך קריא זה?

695
00:33:26,600 --> 00:33:29,650
>> פעם אחר פעם, מה עוזרי ההוראה שלך
ו TFS יעשה במהלך

696
00:33:29,650 --> 00:33:31,870
הוא לספק לך עם זה
סוג של משוב איכותי

697
00:33:31,870 --> 00:33:34,330
כך שאתה להשתפר
היבטים שונים אלה.

698
00:33:34,330 --> 00:33:37,510
וגם במונחים של איך אנחנו
להעריך כל אחד הצירים הללו,

699
00:33:37,510 --> 00:33:40,080
זה בדרך כלל עם מעט מאוד
דליים, כך שאתה, בדרך כלל,

700
00:33:40,080 --> 00:33:41,680
לקבל תחושה של כמה טוב אתה עושה.

701
00:33:41,680 --> 00:33:45,680
ואכן, אם תקבל ציון על
כל אלה נכונים, העיצוב axes--

702
00:33:45,680 --> 00:33:49,659
וסגנון especially-- כי מספר
בדרך כלל יהיה בין 1 ל -5.

703
00:33:49,659 --> 00:33:52,450
וגם, פשוטו כמשמעו, אם אתה מקבל
3 כבר עומד לפני תחילת הסמסטר,

704
00:33:52,450 --> 00:33:53,977
זה דבר מאוד טוב.

705
00:33:53,977 --> 00:33:55,810
זה אומר שיש עדיין
מקום לשיפור,

706
00:33:55,810 --> 00:33:58,490
אשר היית מקווה שכן
משתתף בקורס בפעם הראשונה.

707
00:33:58,490 --> 00:34:01,820
יש לקוות כמה קצת תקרה
שאליו אתה השואף להגיע.

708
00:34:01,820 --> 00:34:03,970
וכך מקבל על של 3
החלקים המוקדמים,

709
00:34:03,970 --> 00:34:06,550
אם לא איזה 2 ו 4 של,
הוא, אכן, דבר טוב.

710
00:34:06,550 --> 00:34:08,880
זה גם בטווח,
גם בתוך ציפיות.

711
00:34:08,880 --> 00:34:11,421
>> ואם המוח שלך מירוץ, לחכות
דקה, שלוש מתוך חמש.

712
00:34:11,421 --> 00:34:12,620
זה באמת מתוך 6 מתוך 10.

713
00:34:12,620 --> 00:34:13,560
זה 60%.

714
00:34:13,560 --> 00:34:14,830
אלוהים שלי, כי זהו פ

715
00:34:14,830 --> 00:34:15,870
>> זה לא.

716
00:34:15,870 --> 00:34:17,600
זה לא, למעשה, כי.

717
00:34:17,600 --> 00:34:22,710
במקום זאת, היא הזדמנות לשפר
במהלך הסמסטר.

718
00:34:22,710 --> 00:34:25,580
ואם אתה מקבל כמה
Poors, אלה הם הזדמנות

719
00:34:25,580 --> 00:34:29,199
כדי לנצל את שעות העבודה,
בהחלט סעיפים ומשאבים אחרים.

720
00:34:29,199 --> 00:34:32,840
>> הטוב ביותר הוא הזדמנות, באמת,
להתגאות רק כמה רחוק אתה כבר

721
00:34:32,840 --> 00:34:34,520
לבוא במהלך הסמסטר.

722
00:34:34,520 --> 00:34:38,199
אז מבין, אם שום דבר
אחר, שלוש הם טובים.

723
00:34:38,199 --> 00:34:40,179
וזה מאפשר מקום לצמיחה לאורך זמן.

724
00:34:40,179 --> 00:34:43,090
>> באשר לאופן שבו צירים אלה הם
משוקלל, מציאותי שאתה

725
00:34:43,090 --> 00:34:46,745
הולך לבלות את רוב הזמן שלך מקבל
דברים לעבודה, שלא לדבר כראוי.

726
00:34:46,745 --> 00:34:49,120
וכך התקינות נוטה
ישוקלל היותר, כמו עם

727
00:34:49,120 --> 00:34:51,360
גורם כפלי זה של שלוש.

728
00:34:51,360 --> 00:34:54,659
עיצוב הוא גם חשוב, אבל
משהו שאתה עושה לא בהכרח

729
00:34:54,659 --> 00:34:58,220
לבזבז את כל השעות הללו על
מנסה להשיג דברים רק כדי לעבוד.

730
00:34:58,220 --> 00:35:00,019
>> וכך זה משוקלל
קצת יותר קל.

731
00:35:00,019 --> 00:35:01,560
ואז בסגנון משוקלל המעטה.

732
00:35:01,560 --> 00:35:03,710
למרות שזה לא פחות
חשוב ביסודו,

733
00:35:03,710 --> 00:35:05,990
זה רק, אולי,
הדבר הכי קל לעשות את הדבר הנכון,

734
00:35:05,990 --> 00:35:08,440
מחק את הדוגמות אנו
לעשות בהרצאה וסעיף,

735
00:35:08,440 --> 00:35:11,080
עם דברים יפים
מסוכסך, והעיר,

736
00:35:11,080 --> 00:35:14,320
וכן הלאה, הוא בין ההקלה
דברים לעשות ולקבל זכות.

737
00:35:14,320 --> 00:35:16,960
אז ככזה, מבין
כי אלה הם נקודות

738
00:35:16,960 --> 00:35:19,000
כי הם יחסית קל לתפוס.

739
00:35:19,000 --> 00:35:22,360
>> ועכשיו מילה על
זה- יושרה אקדמית.

740
00:35:22,360 --> 00:35:25,150
אז לכל קורס
הסילבוס, תוכלו לראות

741
00:35:25,150 --> 00:35:27,630
יש שהקורס די
קצת שפה סביב זה.

742
00:35:27,630 --> 00:35:31,380
ואת כמובן לוקח את הנושא
יושרה אקדמית די ברצינות.

743
00:35:31,380 --> 00:35:33,450
>> יש לנו את ההבחנה,
לטוב או לרע,

744
00:35:33,450 --> 00:35:36,570
בכך הנשלח מדי שנה יותר
סטודנטים להליך משמעתי

745
00:35:36,570 --> 00:35:39,670
יותר מרוב כל האחרים
כמובן, כי אני מודע.

746
00:35:39,670 --> 00:35:42,580
זה לא בהכרח
מעיד על העובדה

747
00:35:42,580 --> 00:35:46,340
שתלמידים CS, או סטודנטים CS50, הם
פחות כנה יותר חברכם.

748
00:35:46,340 --> 00:35:49,090
אבל המציאות כי זה
בעולם, אלקטרוני, אנחנו רק

749
00:35:49,090 --> 00:35:50,990
יש טכנולוגי
פירושו של גילוי זה.

750
00:35:50,990 --> 00:35:53,360
>> חשוב לנו עבור
גינות ברחבי הכיתה

751
00:35:53,360 --> 00:35:58,550
שאנחנו עושים לזהות את זה, ולגדל
הנושא כאשר אנו רואים דברים.

752
00:35:58,550 --> 00:36:01,980
וזה רק כדי לצייר תמונה, ובאמת
כדי לעזור משהו כמו כיור זה,

753
00:36:01,980 --> 00:36:04,600
אלה הם המספרים של
סטודנטים במהלך 10 השנים האחרונות

754
00:36:04,600 --> 00:36:07,610
כי היו מעורבים כמה
בעיות כאלה של יושרה אקדמית,

755
00:36:07,610 --> 00:36:10,990
עם כ -32 תלמידים
מנפילה 2015, אשר

756
00:36:10,990 --> 00:36:13,760
הוא אומר שאנחנו לוקחים
העניין מאוד ברצינות.

757
00:36:13,760 --> 00:36:18,380
וגם, בסופו של דבר, המספרים האלה להלחין,
ולאחרונה, כ -3%, 4% בערך

758
00:36:18,380 --> 00:36:19,120
של הכיתה.

759
00:36:19,120 --> 00:36:25,220
>> אז עבור רוב מיוחס של תלמידים
נראה כי הקווים ברורים.

760
00:36:25,220 --> 00:36:27,940
אבל אל לשמור את זה
אכפת לך, במיוחד בסוף

761
00:36:27,940 --> 00:36:32,080
בלילה כאשר נאבק עם
איזה פתרון למערכת בעיה,

762
00:36:32,080 --> 00:36:34,830
כי ישנם מנגנונים
עבור מכניס את עצמך טוב יותר

763
00:36:34,830 --> 00:36:37,870
תמיכה ממה שאתה אולי
חושב, אפילו באותה שעה.

764
00:36:37,870 --> 00:36:40,514
להבין כי כאשר אנו מקבלים
הגשות מתלמידים, נחצינו

765
00:36:40,514 --> 00:36:43,430
להשוות את כל הטקסטים השנה
נגד כל הגשה בשנה שעברה,

766
00:36:43,430 --> 00:36:47,590
נגד כל הגשה משנת 2007,
ומאז, מסתכל, כמו גם,

767
00:36:47,590 --> 00:36:49,931
קוד מאגרים מקוונים,
פורומי דיון, אתרי עבודה.

768
00:36:49,931 --> 00:36:51,806
אנו מזכירים זה,
באמת, כל למען

769
00:36:51,806 --> 00:36:56,040
גילוי נאות, שאם
מישהו אחר יכול למצוא אותו באינטרנט,

770
00:36:56,040 --> 00:36:57,880
בהחלט, גם אנחנו יכולים הקורס.

771
00:36:57,880 --> 00:37:00,100
אבל, באמת, ברוח
הקורס מסתכם

772
00:37:00,100 --> 00:37:01,650
סעיף זה בתוכנית הלימודים.

773
00:37:01,650 --> 00:37:03,670
זה באמת פשוט, יהיה הגיוני.

774
00:37:03,670 --> 00:37:06,680
>> ואם היינו צריכים להרחיב על כך
עם רק שפה קצת יותר,

775
00:37:06,680 --> 00:37:09,770
להבין את המהות של כל
עבודה שתגיש לקורס הזה

776
00:37:09,770 --> 00:37:10,954
חייב להיות משלך.

777
00:37:10,954 --> 00:37:13,870
אבל בתוך זה, יש בהחלט
הזדמנויות, ועידוד,

778
00:37:13,870 --> 00:37:17,300
וערך פדגוגי פונה
נוספות-- עצמי, TFS, את הרשויות,

779
00:37:17,300 --> 00:37:20,760
TAS, ואחרים בכיתה,
עבור תמיכה, לתת לחברים בלבד

780
00:37:20,760 --> 00:37:23,547
ו השותפים שחקרו
CS ותכנות לפני.

781
00:37:23,547 --> 00:37:25,130
וכך יש קצבה בשביל זה.

782
00:37:25,130 --> 00:37:28,180
ואת ככלל אצבע
זה- הוא כאשר לבקש עזרה,

783
00:37:28,180 --> 00:37:31,470
ייתכן להציג הקוד שלך לאחרים,
אבל אתה לא יכול לצפות שלהם.

784
00:37:31,470 --> 00:37:34,880
אז גם אם אתה נמצא בבית שעות עבודה,
או באולם D, או במקום אחר

785
00:37:34,880 --> 00:37:37,450
עבודה על סט פיסה,
לעבוד לצד חבר, אשר

786
00:37:37,450 --> 00:37:40,160
זה בסדר לגמרי, בבית
בסופו של יום העבודה שלך

787
00:37:40,160 --> 00:37:43,034
בסופו של דבר צריך להיות שייך לכל
מכם בהתאמה, ולא

788
00:37:43,034 --> 00:37:45,700
להיות קצת מאמץ משותף,
למעט פרויקט הגמר שם

789
00:37:45,700 --> 00:37:47,410
זה מותר ועודד.

790
00:37:47,410 --> 00:37:49,830
>> להבין שאם אתה
נאבק עם משהו

791
00:37:49,830 --> 00:37:52,520
והחבר שלך פשוט קורה
להיות יותר טוב בזה אז אתה,

792
00:37:52,520 --> 00:37:55,130
או יותר באותה בעיה ממה שאתה,
או קצת לפני יותר ממה שאתה,

793
00:37:55,130 --> 00:37:57,330
זה לגמרי סביר להפוך
לחבר שלך ולהגיד, היי,

794
00:37:57,330 --> 00:38:00,480
אכפת לך להסתכל הקוד שלי כאן,
עוזרים לי לזהות מה הבעיה שלי היא?

795
00:38:00,480 --> 00:38:03,760
וגם, בתקווה, ב
עניין של ערך פדגוגי

796
00:38:03,760 --> 00:38:07,040
חבר שעושה לא רק
אומרים, אה, לעשות זאת, אלא,

797
00:38:07,040 --> 00:38:09,917
מה אתה חסר על קו
6, או משהו כזה?

798
00:38:09,917 --> 00:38:12,000
אבל הפתרון הוא לא
בשביל החבר לידך

799
00:38:12,000 --> 00:38:15,617
לומר, נו, טוב, כאן, תן לי למשוך
זה למעלה, ולהראות הפתרון שלי אליך.

800
00:38:15,617 --> 00:38:16,450
אז זה הקו.

801
00:38:16,450 --> 00:38:18,670
אתה להראות את הקוד שלך
אחרים, אבל אתה לא יכול

802
00:38:18,670 --> 00:38:22,350
להציג את שלהם, בכפוף האחר
אילוצים הסילבוס של הקורס.

803
00:38:22,350 --> 00:38:24,760
>> אז אל לזכור זה
מה שנקרא סעיף חרטה

804
00:38:24,760 --> 00:38:27,560
בתוכנית הלימודים של הקורס, כמו גם,
כי אם אתה להתחייב איזה מעשה כי

805
00:38:27,560 --> 00:38:30,476
לא סביר, אבל להביא אותו
לידיעת הראשי של הקורס

806
00:38:30,476 --> 00:38:34,240
בתוך 72 שעות, הקורס
עלול לגרור הטלת סנקציות מקומיות

807
00:38:34,240 --> 00:38:37,380
עשוי לכלול משביעת רצון או
ציון נכשל עבור העבודה שהוגשה.

808
00:38:37,380 --> 00:38:41,410
אבל כמובן לא להפנות את
משנה להליך משמעתי נוסף,

809
00:38:41,410 --> 00:38:43,010
למעט במקרים של פעולות חוזרות ונשנות.

810
00:38:43,010 --> 00:38:46,632
במילים אחרות, אם אתה עושה כמה
בשעת לילה מאוחר טפשה, במיוחד, החלטה

811
00:38:46,632 --> 00:38:49,340
כי בבוקר או בימים הבאים
מאוחר יותר, אתה מתעורר אל תוך המציאות,

812
00:38:49,340 --> 00:38:50,870
מה חשבתי לעצמי?

813
00:38:50,870 --> 00:38:53,890
יש לך לעשות CS50 לשקע
לתיקון הבעיה כי

814
00:38:53,890 --> 00:38:57,170
ומחזיקים בה עד אותו, כך שנוכל
יפגוש אותך באמצע הדרך ולהתמודד

815
00:38:57,170 --> 00:39:01,500
עם אותו עניין שהוא גם
חינוך יקר בשבילך,

816
00:39:01,500 --> 00:39:04,200
אבל עדיין ענישה בדרך כלשהי.

817
00:39:04,200 --> 00:39:08,590
ועכשיו, כדי להוציא את העוקץ, זה.

818
00:39:08,590 --> 00:39:10,570
>> [הפעלת סרטון]

819
00:39:10,570 --> 00:39:13,540
>> [מוסיקה מתנגנת]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [סוף PLAYBACK]

822
00:39:58,866 --> 00:40:00,490
דוד י מלאן: בסדר, אנחנו שוב.

823
00:40:00,490 --> 00:40:03,680
ועכשיו אנחנו מסתכלים אחד
הראשון של תחומים בעולם האמיתי שלנו

824
00:40:03,680 --> 00:40:08,720
ב CS50, אמנות קריפטוגרפיה,
אמנות שליחה וקבלה

825
00:40:08,720 --> 00:40:11,840
מסרים סודיים, מוצפן
הודעות אם תרצה,

826
00:40:11,840 --> 00:40:17,060
כי יכול להיות מפוענח רק אם אתה צריך
כמה מרכיב עיקרי שהשולח יש

827
00:40:17,060 --> 00:40:18,030
גם כן.

828
00:40:18,030 --> 00:40:22,120
אז להניע זה ניקח
מבט על זה כאן,

829
00:40:22,120 --> 00:40:26,750
המהווה דוגמה
טבעת מפענח סוד

830
00:40:26,750 --> 00:40:34,042
ניתן להשתמש על מנת להבין
איזה מסר סודי באמת.

831
00:40:34,042 --> 00:40:35,750
למעשה, חזרה
יום בבית הספר היסודי,

832
00:40:35,750 --> 00:40:38,787
אם אי פעם שלחו מסרים סודיים
חבר כמה או כמה למעוך בכיתה,

833
00:40:38,787 --> 00:40:40,620
אפשר לחשוב
היית להיות חכם

834
00:40:40,620 --> 00:40:46,530
ידי על שינוי פיסת נייר שלך,
כמו, A ל- B, ו- B ל- C, ו- C ל D,

835
00:40:46,530 --> 00:40:47,590
וכן הלאה.

836
00:40:47,590 --> 00:40:50,300
אבל אתה בעצם הצפנה
המידע שלך, אפילו

837
00:40:50,300 --> 00:40:53,300
אם זה היה קצת טריוויאלי, לא היה
קשה כי למורה להבין,

838
00:40:53,300 --> 00:40:55,675
טוב, אם אתה רק לשנות
B ל- A ו- C ל- B,

839
00:40:55,675 --> 00:40:57,550
אתה בעצם להבין
מה המסר היה,

840
00:40:57,550 --> 00:40:59,700
אבל היית הצפנת מידע.

841
00:40:59,700 --> 00:41:03,420
>> אתה פשוט עושה את זה
פשוט, בדומה ראלפי כאן

842
00:41:03,420 --> 00:41:07,934
בסרט מפורסם שמנגן
פחות או יותר nauseum מודעה בכל חורף.

843
00:41:07,934 --> 00:41:08,600
[הפעלת סרטון]

844
00:41:08,600 --> 00:41:11,180
-Be זה ידוע לכל כי
ראלף פארקר בזאת

845
00:41:11,180 --> 00:41:14,070
מינה חבר ליטל
אנני היתומה הסוד מעגל

846
00:41:14,070 --> 00:41:17,700
והוא זכאי לכל הכיבודים
והטבות המתרחשות לכך.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, אנני היתומה הקטנה,
נגד חתם פייר אנדרה, בדיו.

848
00:41:24,340 --> 00:41:27,160
בהצטיינות והטבות,
כבר בגיל תשע.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [צעקות]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-בחייך.

853
00:41:34,250 --> 00:41:35,210
בואו נגמור עם זה.

854
00:41:35,210 --> 00:41:39,530
אני לא צריך את כל השטויות האלה
על מבריחים ופיראטים.

855
00:41:39,530 --> 00:41:41,660
>> מחר בלילה "תשמע עבור
ההרפתקה המסכמת

856
00:41:41,660 --> 00:41:43,880
של ספינת פירטים השחורה.

857
00:41:43,880 --> 00:41:46,650
עכשיו, הגיע הזמן
המסר הסודי של אנני

858
00:41:46,650 --> 00:41:49,840
בשבילך חברי המעגל הסודי.

859
00:41:49,840 --> 00:41:53,570
זכור, ילדים, רק חברים
של המעגל הסודי של אנני

860
00:41:53,570 --> 00:41:56,140
יכול לפענח את המסר הסודי של אנני.

861
00:41:56,140 --> 00:42:00,340
>> זכרו, אנני תלויה בך.

862
00:42:00,340 --> 00:42:02,880
גדר הסיכות שלך B2.

863
00:42:02,880 --> 00:42:05,230
הנה ההודעה.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> 'אני ב, הפגישה החשאית הראשונה שלי.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre היה לילה קול גדול.

868
00:42:15,780 --> 00:42:19,000
יכולתי לספר שהלילה של
המסר היה באמת חשוב.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, זה הודעה
מ אנני עצמה.

870
00:42:22,694 --> 00:42:23,860
זכור, אל תספרו לאף אחד.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 שניות מאוחר יותר, אני היחיד
חדר בבית שבו ילד בן תשע

873
00:42:32,930 --> 00:42:37,040
יכולתי לשבת בפרטיות ולפענח.

874
00:42:37,040 --> 00:42:39,730
אהה, לינה!

875
00:42:39,730 --> 00:42:42,360
הלכתי הבא, E.

876
00:42:42,360 --> 00:42:44,520
>> המילה הראשונה היא להיות.

877
00:42:44,520 --> 00:42:49,032
S, זה היה מגיע יותר קל עכשיו, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> אה, בחייך, ראלפי, אני חייב ללכת!

879
00:42:51,733 --> 00:42:53,688
>> -I'll יורד מיד, מא!

880
00:42:53,688 --> 00:42:54,188
מצוץ מן האצבע!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, להיות בטוח עם-- הקפד מה?

883
00:43:04,060 --> 00:43:05,970
מה הייתה יתומה קטנה
אנני מנסה לומר?

884
00:43:05,970 --> 00:43:07,264
הקפד מה?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, אנדי חייב
ללכת, האם תוכל בבקשה לצאת?

886
00:43:09,634 --> 00:43:10,480
>> תקין -כל, מא!

887
00:43:10,480 --> 00:43:12,880
אני אהיה החוצה מימין!

888
00:43:12,880 --> 00:43:14,550
>> -אני מקבל עכשיו קרוב.

889
00:43:14,550 --> 00:43:16,620
המתח היה נורא.

890
00:43:16,620 --> 00:43:17,720
מה זה היה?

891
00:43:17,720 --> 00:43:20,170
גורלו של כדור הארץ
עשוי להיות תלוי ועומד.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
בנאדם של אנדי ללכת!

894
00:43:23,170 --> 00:43:26,890
>> -I'll להיות ישר, עבור בוכה בקול רם!

895
00:43:26,890 --> 00:43:32,680
>> -Almost שם, אצבעותיי טסות, דעתי
מלכודת הייתה פלדה, כל נקבובי רטט.

896
00:43:32,680 --> 00:43:37,198
זה היה כמעט ברור, כן, כן, כן.

897
00:43:37,198 --> 00:43:43,091
>> -Be הקפידו לשתות שוקו שלך.

898
00:43:43,091 --> 00:43:43,590
שוקו?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
פרסומת עלובה?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
בֶּן כַּלבָּה.

903
00:43:54,227 --> 00:43:54,810
[סוף PLAYBACK]

904
00:43:54,810 --> 00:43:57,390
דוד י מלאן: אוקיי, אז
זה היה דרך ארוכה מאוד

905
00:43:57,390 --> 00:44:00,660
של החדרת קריפטוגרפיה,
וגם שוקו.

906
00:44:00,660 --> 00:44:04,470
למעשה, מן הפרסומת הישנה הזאת
כאן, למה הוא שוקו כל כך טוב?

907
00:44:04,470 --> 00:44:09,470
זהו מיצוי מרוכז של בשלות
לתת שעורה, חלב פרה שמנת טהורה,

908
00:44:09,470 --> 00:44:14,360
והכן קקאו במיוחד, יחד
עם phosphatides וויטמינים טבעיים.

909
00:44:14,360 --> 00:44:18,240
היא היתה מבוצרת נוספת עם
ויטמינים נוספים B ו- D, יאם.

910
00:44:18,240 --> 00:44:21,600
ואתה עדיין יכול לקבל את זה, כנראה,
באמזון, כפי שעשינו כאן.

911
00:44:21,600 --> 00:44:24,810
>> אבל המוטיבציה כאן הייתה
להציג קריפטוגרפיה, במיוחד

912
00:44:24,810 --> 00:44:28,340
סוג של הצפנה ידוע
כמו הצפנה במפתח סודית.

913
00:44:28,340 --> 00:44:34,284
וכפי שהשם מרמז, כל
אבטחת מידע של מערכת הצפנת מפתח סודית,

914
00:44:34,284 --> 00:44:36,200
אם תרצו, מתודולוגיה
רק ערבול

915
00:44:36,200 --> 00:44:40,960
מידע בין שני אנשים, הוא
רק השולח והנמען בלבד

916
00:44:40,960 --> 00:44:46,980
מכיר key-- סוד ערך כלשהו, ​​כמה
ביטוי סוד, כמה מספר סודי, כי

917
00:44:46,980 --> 00:44:50,660
מאפשר להם הוא להצפין
ולפענח מידע.

918
00:44:50,660 --> 00:44:53,470
קריפטוגרפיה, באמת,
הוא רק זה משבוע 0.

919
00:44:53,470 --> 00:44:56,715
>> זוהי בעיה שבה יש תשומות,
כמו המסר בפועל באנגלית

920
00:44:56,715 --> 00:44:59,340
או בכל שפה שאתה
רוצה לשלוח למישהו בכיתה,

921
00:44:59,340 --> 00:45:00,580
או דרך האינטרנט.

922
00:45:00,580 --> 00:45:03,840
יש פלט כמה, שהוא הולך
להיות את ההודעה המקושקשת שאתה

923
00:45:03,840 --> 00:45:05,250
רוצה הנמען לקבל.

924
00:45:05,250 --> 00:45:07,405
וגם אם מישהו
באמצע מקבל את זה יותר מדי,

925
00:45:07,405 --> 00:45:09,780
אתה לא רוצה אותם
בהכרח להיות מסוגל לפענח אותו,

926
00:45:09,780 --> 00:45:12,840
כי בתוך זה
קופסה שחורה, או אלגוריתם,

927
00:45:12,840 --> 00:45:17,650
הוא מנגנון כלשהו, ​​צעד אחר צעד
הוראות, על שהקדשת קלט

928
00:45:17,650 --> 00:45:20,710
המרת אותו לתוך
פלט, ב בתקווה בצורה מאובטחת.

929
00:45:20,710 --> 00:45:23,640
>> ואכן, יש כמה
אוצר המילים בעולם הזה כדלקמן.

930
00:45:23,640 --> 00:45:26,100
טקסט רגיל הוא המילה
מדען מחשבים היו

931
00:45:26,100 --> 00:45:28,449
להשתמש בו כדי לתאר את הקלט
הודעה, כמו אנגלית

932
00:45:28,449 --> 00:45:31,240
או בכל שפה שאתה בעצם
רוצה לשלוח כמה אדם אחר.

933
00:45:31,240 --> 00:45:35,450
ואז המוצפן הוא לטרוף
אל המוצפן, או מוצפן,

934
00:45:35,450 --> 00:45:36,520
הגרסה שלו.

935
00:45:36,520 --> 00:45:38,750
>> אבל יש מרכיב אחד אחר כאן.

936
00:45:38,750 --> 00:45:43,200
יש קלט אחת אחר
הצפנה במפתח סודי.

937
00:45:43,200 --> 00:45:45,200
וזה המפתח עצמו,
שהוא, בדרך כלל,

938
00:45:45,200 --> 00:45:48,930
כפי שנראה בהמשך, מספר, או
מכתב או כל מילה, מה

939
00:45:48,930 --> 00:45:51,980
האלגוריתם הוא בעצם מצפה.

940
00:45:51,980 --> 00:45:53,870
>> ואיך אתה לפענח מידע?

941
00:45:53,870 --> 00:45:55,110
איך אתה לפענח את זה?

942
00:45:55,110 --> 00:45:57,950
ובכן, אתה פשוט להפוך את
תפוקות ואת התשומות.

943
00:45:57,950 --> 00:46:00,900
>> במילים אחרות, פעם מישהו
מקבלת ההודעה המוצפנת שלך,

944
00:46:00,900 --> 00:46:03,740
הוא או היא פשוט
לדעת אותו מפתח.

945
00:46:03,740 --> 00:46:05,700
הם קיבלו את ההודעה המוצפנת.

946
00:46:05,700 --> 00:46:09,530
ועל ידי חיבור שני אלה
תשומות למערכת ההצפנה,

947
00:46:09,530 --> 00:46:14,260
האלגוריתם, קופסה שחורה זו, החוצה
צריך לבוא בטקסט המקורי.

948
00:46:14,260 --> 00:46:17,830
וכך זה ברמה מאוד גבוהה
קריפטוגרפיה לאור מה היא בעצם

949
00:46:17,830 --> 00:46:18,590
הכול על.

950
00:46:18,590 --> 00:46:20,030
>> אז בואו להגיע לשם.

951
00:46:20,030 --> 00:46:22,700
עכשיו בואו נראה מתחת
מכסה המנוע של משהו

952
00:46:22,700 --> 00:46:26,000
אנחנו כבר לוקחים כמובן מאליו עבור
בשבוע האחרון, ועל בפגישה זו

953
00:46:26,000 --> 00:46:27,629
כאן-- המחרוזת.

954
00:46:27,629 --> 00:46:30,295
מחרוזת בסוף היום
רק הוא רצף של תווים.

955
00:46:30,295 --> 00:46:33,610
>> זה יכול להיות שלום עולם, או
שלום Zamyla, או מה שלא יהיה.

956
00:46:33,610 --> 00:46:37,050
אבל מה המשמעות של הדברים הללו
להיות רצף של תווים?

957
00:46:37,050 --> 00:46:41,520
למעשה, ספריית CS50 נותנת
לנו טיפוס בשם מחרוזת.

958
00:46:41,520 --> 00:46:45,140
>> אבל יש למעשה שום
דבר כזה כמחרוזת ב C.

959
00:46:45,140 --> 00:46:49,450
זה באמת רק רצף של
אופי, אופי, אופי,

960
00:46:49,450 --> 00:46:52,180
אופי, חזרה, אל גב, כדי
בחזרה, לגבות, לגבות בתוך

961
00:46:52,180 --> 00:46:54,650
של זיכרון המחשב שלך, או זיכרון RAM.

962
00:46:54,650 --> 00:46:58,940
ואנו להסתכל עמוק לתוך כי
בעתיד כאשר נתבונן הזיכרון עצמו,

963
00:46:58,940 --> 00:47:02,030
ואת הניצול, ואת
איומים כי הם מעורבים.

964
00:47:02,030 --> 00:47:04,100
>> אבל הבה נבחן את המחרוזת Zamyla.

965
00:47:04,100 --> 00:47:07,480
אז רק בשם
האדם כאן, Zamyla,

966
00:47:07,480 --> 00:47:12,030
כי הוא רצף של
תווים, ת-א-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
ועכשיו הבה נניח כי שמו של Zamyla
מאוחסן בתוך מחשב

968
00:47:16,020 --> 00:47:16,880
תָכְנִית.

969
00:47:16,880 --> 00:47:20,830
>> ובכן, זה מתקבל על הדעת, כי במקרה שבו אנו
להיות מסוגל להסתכל על הדמויות האלה

970
00:47:20,830 --> 00:47:21,590
בנפרד.

971
00:47:21,590 --> 00:47:24,710
אז אני רק הולך לצייר קצת
תיבה מסביב שמו של Zamyla כאן.

972
00:47:24,710 --> 00:47:31,580
וזה המקרה ב- C שכשאתה
יש מחרוזת, כמו Zamyla-- ואולי

973
00:47:31,580 --> 00:47:34,940
מחרוזת כי יש לחזור מ
פונקציה כמו מחרוזת גט,

974
00:47:34,940 --> 00:47:38,540
למעשה אתה יכול לתמרן
אופי זה של דמות.

975
00:47:38,540 --> 00:47:42,070
>> עכשיו, זה רלוונטי עבור
השיחה בהישג יד, כי

976
00:47:42,070 --> 00:47:46,420
בהצפנה אם אתה רוצה לשנות
A ל- B, ו- B ל- C, ו- C ל D,

977
00:47:46,420 --> 00:47:49,650
וכן הלאה, אתה צריך להיות מסוגל
להסתכל על תווים בודדים

978
00:47:49,650 --> 00:47:50,190
במחרוזת.

979
00:47:50,190 --> 00:47:52,695
אתה צריך להיות מסוגל לשנות
ה- Z למשהו אחר, א

980
00:47:52,695 --> 00:47:55,280
למשהו אחר, יג
משהו אחר, וכן הלאה.

981
00:47:55,280 --> 00:47:58,000
וכך אנחנו צריכים דרך,
תוכניתי, כך

982
00:47:58,000 --> 00:48:03,020
לדבר, ב- C כדי להיות מסוגל לשנות
ולהסתכל אותיות בודדות.

983
00:48:03,020 --> 00:48:05,690
ואנחנו יכולים לעשות את זה כדלקמן.

984
00:48:05,690 --> 00:48:08,340
>> תן לי ללכת לחזור ב IDE CS50.

985
00:48:08,340 --> 00:48:11,130
ותן לי ללכת קדימה
וליצור קובץ חדש

986
00:48:11,130 --> 00:48:16,134
שאני אתקשר string0 הפעם,
כמו למשל כאלה הראשונים שלנו, נקודת ג.

987
00:48:16,134 --> 00:48:18,300
ואני הולך קדימה
להלהיב אותו כדלקמן.

988
00:48:18,300 --> 00:48:22,870
>> אז לכלול CS50.h, ו
ואז לכלול io.h סטנדרטי,

989
00:48:22,870 --> 00:48:25,990
אשר אני כמעט תמיד הולך
להיות באמצעות בתוכניות שלי, לפחות

990
00:48:25,990 --> 00:48:26,780
בהתחלה.

991
00:48:26,780 --> 00:48:32,180
int void main, ולאחר מכן כאן אני
הולך לעשות מחרוזות מקבל מקבל מחרוזת.

992
00:48:32,180 --> 00:48:35,260
ואז אני הולך
אתם מוזמנים לעשות זאת.

993
00:48:35,260 --> 00:48:37,460
אני רוצה ללכת קדימה
ו, כבדיקת שפיות,

994
00:48:37,460 --> 00:48:43,607
רק לומר, שלום, s אחוזים,
פסיק, עושה מחרוזת 0.

995
00:48:43,607 --> 00:48:44,690
אוי, מה עשיתי כאן?

996
00:48:44,690 --> 00:48:45,930
הו, אני לא תקעתי את זה.

997
00:48:45,930 --> 00:48:48,120
אז כלקח, כי
לא היה בכוונה.

998
00:48:48,120 --> 00:48:52,480
>> אז טעות, יותר אחוזים
מרות מ טיעוני נתונים.

999
00:48:52,480 --> 00:48:54,940
וכאן, ב
קו 7-- אוקיי, אז יש לי,

1000
00:48:54,940 --> 00:48:56,690
ציטוט סוף ציטוט, זה
המחרוזת שלי printf.

1001
00:48:56,690 --> 00:48:58,151
יש לי סימן אחוזים.

1002
00:48:58,151 --> 00:48:59,650
אבל אני חסרתי את הטענה השנייה.

1003
00:48:59,650 --> 00:49:03,190
>> אני חסר פסיק הים, אשר
אני לא צריך בדוגמאות הקודמות.

1004
00:49:03,190 --> 00:49:06,650
אז הזדמנות טובה לתקן
עוד טעות, בטעות.

1005
00:49:06,650 --> 00:49:09,950
ועכשיו תן לי לרוץ
string0, הקלד Zamyla.

1006
00:49:09,950 --> 00:49:10,970
אוקיי, שלום Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> אז שביצענו סוג זה של התוכנית
עכשיו כמה פעמים שונות.

1008
00:49:14,144 --> 00:49:16,310
אבל בוא נעשה משהו
קצת שונה הפעם.

1009
00:49:16,310 --> 00:49:19,450
במקום סתם הדפסת Zamyla של
שם כולו החוצה עם printf,

1010
00:49:19,450 --> 00:49:21,350
בואו נעשה את זה תו אחרי תו.

1011
00:49:21,350 --> 00:49:22,700
>> אני הולך להשתמש בלולאת for.

1012
00:49:22,700 --> 00:49:26,160
ואני הולך לתת את עצמי
משתנה ספירה, שנקרא i.

1013
00:49:26,160 --> 00:49:33,530
ואני מתכוון להמשיך ולביקורות, כך
כל עוד אני הוא פחות מאורך של הים.

1014
00:49:33,530 --> 00:49:35,930
>> מתברר, עשינו לא
לעשות בפעם האחרונה זה,

1015
00:49:35,930 --> 00:49:39,100
ג שמגיע עם
פונקציה שנקראת סטירלינג.

1016
00:49:39,100 --> 00:49:42,690
חזרה היום, ובאופן כללי
עדיין בעת ​​יישום פונקציות,

1017
00:49:42,690 --> 00:49:45,405
בני האדם יעדיפו מאוד
שמות תמציתיים זה סוג של צליל

1018
00:49:45,405 --> 00:49:48,280
כמו מה שאתה רוצה, למרות שזה
חסר תנועות או אותיות.

1019
00:49:48,280 --> 00:49:50,660
אז סטירלינג היא
שם פונקציה

1020
00:49:50,660 --> 00:49:53,880
לוקח ויכוח בין
בסוגריים כי צריך להיות מחרוזת.

1021
00:49:53,880 --> 00:49:56,910
וזה רק מחזיר מספר שלם,
לכל האורך של מחרוזת.

1022
00:49:56,910 --> 00:50:00,580
>> אז זה עבור לולאה על קו 7 הולך
להתחיל לספור ב i שווה 0.

1023
00:50:00,580 --> 00:50:02,530
זה הולך להגדיל
אני בכל איטרציה

1024
00:50:02,530 --> 00:50:04,350
על ידי 1, כפי שאנו כבר עושים כמה פעמים.

1025
00:50:04,350 --> 00:50:06,780
אבל זה הולך רק לעשות
זאת עד לנקודה

1026
00:50:06,780 --> 00:50:09,660
כשאני הוא האורך
של המחרוזת עצמה.

1027
00:50:09,660 --> 00:50:14,520
>> אז זה הוא דרך, בסופו של דבר,
iterating על התווים

1028
00:50:14,520 --> 00:50:17,430
במחרוזת הוא כדלקמן.

1029
00:50:17,430 --> 00:50:20,670
אני הולך להדפיס את לא
מחרוזת שלמה, אבל ג אחוזים,

1030
00:50:20,670 --> 00:50:22,860
תו בודד
ואחריו בשורה חדשה.

1031
00:50:22,860 --> 00:50:24,880
ואז אני הולך
קדימה, ואני צריך

1032
00:50:24,880 --> 00:50:29,080
להגיד אני רוצה להדפיס
אופי ה- i של הים.

1033
00:50:29,080 --> 00:50:33,450
>> אז אם אני הוא המשתנה המציין
המדד של המחרוזת, שם

1034
00:50:33,450 --> 00:50:37,230
אתם מתחברים אליה, אני צריך להיות מסוגל
לומר, תן לי את אופי ה- i של הים.

1035
00:50:37,230 --> 00:50:40,390
ו- C יש דרך לעשות
זה עם סוגריים מרובעים.

1036
00:50:40,390 --> 00:50:43,679
אתה פשוט אומר את השם של
מחרוזת, אשר במקרה זה היא של.

1037
00:50:43,679 --> 00:50:46,970
ואז אתה משתמש בסוגריים מרובעים, אשר הם
בדרך כלל קצת מעל ההחזר או זן

1038
00:50:46,970 --> 00:50:48,110
מקש במקלדת.

1039
00:50:48,110 --> 00:50:52,410
ואז אתה מכניס את האינדקס של
תו שברצונך להדפיס.

1040
00:50:52,410 --> 00:50:55,960
אז המדד הולך להיות
0 number--, או 1, או 2, או 3, או נקודה,

1041
00:50:55,960 --> 00:50:57,590
נקודה, נקודה, ממספר אחר.

1042
00:50:57,590 --> 00:51:00,920
>> ואנחנו להבטיח כי זה הולך
להיות את המספר הנכון, כי אני

1043
00:51:00,920 --> 00:51:02,360
מתחילים לספור ב 0.

1044
00:51:02,360 --> 00:51:07,020
ו כברירת מחדל, התו הראשון
במחרוזת הוא לפי האמנה 0.

1045
00:51:07,020 --> 00:51:09,230
ואת הדמות השנייה היא תושבת 1.

1046
00:51:09,230 --> 00:51:11,120
ואת הדמות השלישית היא תושבת 2.

1047
00:51:11,120 --> 00:51:13,630
ואתה לא רוצה ללכת יותר מדי
כה, אבל אנחנו לא כי אנחנו

1048
00:51:13,630 --> 00:51:17,780
הולך להגדיל i עד רק
שווה אורך החוט.

1049
00:51:17,780 --> 00:51:20,210
ו ובנקודה,
זה עבור לולאה יפסיק.

1050
00:51:20,210 --> 00:51:25,550
>> אז תנו לי להמשיך ולשמור זה
התוכנית, וברח להפוך מחרוזת 0.

1051
00:51:25,550 --> 00:51:28,400
אבל אני דפוק.

1052
00:51:28,400 --> 00:51:35,390
במשתמע להכריז פונקצית ספרייה
סטירלינג עם סוג כזה such-- עכשיו,

1053
00:51:35,390 --> 00:51:36,430
זה נשמע מוכר.

1054
00:51:36,430 --> 00:51:37,440
אבל זה לא printf.

1055
00:51:37,440 --> 00:51:38,540
וזה לא מקבל מחרוזת.

1056
00:51:38,540 --> 00:51:40,480
>> אני לא לפשל ב
באותו אופן הפעם.

1057
00:51:40,480 --> 00:51:45,100
אבל לב נרד עוד קצת למטה
נוסף, כולל בכותרת string.h,

1058
00:51:45,100 --> 00:51:47,210
במפורש לספק את
הכרזה על סטירלינג.

1059
00:51:47,210 --> 00:51:48,820
אז יש בעצם רמז לשם.

1060
00:51:48,820 --> 00:51:51,670
>> ואכן מתברר
יש עוד כותרת קובץ

1061
00:51:51,670 --> 00:51:53,970
כי אנחנו כבר לא בשימוש
בכיתה עדיין, אבל זה

1062
00:51:53,970 --> 00:51:56,480
בין אלה זמינים
לך, בשם string.h.

1063
00:51:56,480 --> 00:52:00,930
ובאותו קובץ, string.h
הוא סטירלינג הכריז.

1064
00:52:00,930 --> 00:52:05,220
אז תן לי ללכת קדימה
לחסוך זה, לעשות מחרוזת

1065
00:52:05,220 --> 00:52:08,040
0-- נחמד, לא הודעות שגיאה הפעם.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, ו
אני עומד על Enter,

1067
00:52:12,290 --> 00:52:16,710
ובנקודה getstring הולך
להחזיר את המחרוזת, לשים אותו הים.

1068
00:52:16,710 --> 00:52:21,890
אז עבור לולאה הולך לחזר
על הדמויות של S אחד בכל פעם,

1069
00:52:21,890 --> 00:52:28,420
ולהדפיס אותן אחת בשורה, כי
היה לי כי מהלך סרק n בסוף.

1070
00:52:28,420 --> 00:52:34,530
אז יכולתי להשמיט כי מהלך סרק
n, ולאחר מכן פשוט להדפיס Zamyla כל

1071
00:52:34,530 --> 00:52:37,460
באותה השורה,
מימוש מחדש ביעילות

1072
00:52:37,460 --> 00:52:38,999
printf, וזה לא כל כך שימושי.

1073
00:52:38,999 --> 00:52:40,540
אבל במקרה הזה, אני כבר לא עושה את זה.

1074
00:52:40,540 --> 00:52:43,610
אני כבר מודפס למעשה אחד
דמות בכל פעם, אחד בכל שורה,

1075
00:52:43,610 --> 00:52:45,400
כך שאנחנו באמת לראות את ההשפעה.

1076
00:52:45,400 --> 00:52:46,900
>> אבל אני צריך לציין דבר אחד כאן.

1077
00:52:46,900 --> 00:52:48,930
ואנחנו נחזור
זה בעוד שבוע בעתיד.

1078
00:52:48,930 --> 00:52:52,650
מתברר כי זה
הקוד הוא פוטנציאל מרכבה.

1079
00:52:52,650 --> 00:52:56,560
>> מתברר כי מחרוזת גט
וכמה פונקציות אחרות בחיים

1080
00:52:56,560 --> 00:53:00,280
לא בהכרח תמיד
להחזיר את מה שאתה מצפה.

1081
00:53:00,280 --> 00:53:03,010
אנחנו יודעים מהכיתה אחרונה
זמן זה מניב

1082
00:53:03,010 --> 00:53:04,960
המחרוזת אמורה להחזיר מחרוזת.

1083
00:53:04,960 --> 00:53:09,900
אבל מה אם המשתמש מקליד את כזה
מילה ארוכה, או פסקה, או מסה

1084
00:53:09,900 --> 00:53:13,010
כי יש רק לא מספיק
זיכרון במחשב כדי להתאים אותו.

1085
00:53:13,010 --> 00:53:15,410
>> כאילו, מה אם משהו הולך
בסדר מתחת למכסה המנוע?

1086
00:53:15,410 --> 00:53:18,400
אולי זה לא קורה לעיתים קרובות,
אבל זה יכול לקרות פעם

1087
00:53:18,400 --> 00:53:21,520
בכמה זמן, לעתים רחוקות מאוד.

1088
00:53:21,520 --> 00:53:25,460
וכך מתברר כי מחרוזת גט
פונקציות כמו זה לא בהכרח

1089
00:53:25,460 --> 00:53:26,380
תמיד לחזור מחרוזות.

1090
00:53:26,380 --> 00:53:30,680
הם עלולים לחזור כמה ערך שגיאה,
כמה ערך זקיף כביכול,

1091
00:53:30,680 --> 00:53:32,612
המציין
משהו השתבש.

1092
00:53:32,612 --> 00:53:35,320
ואתה רק היה יודע את זה
לאחר שלמד את זה בכיתה עכשיו,

1093
00:53:35,320 --> 00:53:37,700
או שיש לקרוא קצת תיעוד יותר.

1094
00:53:37,700 --> 00:53:43,120
מתברר כי מחרוזת גט
יכול להחזיר ערך שנקרא null.

1095
00:53:43,120 --> 00:53:46,220
ריק הוא ערך מיוחד שנוסיף
לחזור בעוד שבוע בעתיד.

1096
00:53:46,220 --> 00:53:50,420
אבל לעת עתה, רק יודע שאם אני רוצה
להיות באמת ראוי לנוע קדימה

1097
00:53:50,420 --> 00:53:52,650
באמצעות מחרוזת מקבל, אני
לא צריך פשוט לקרוא לזה,

1098
00:53:52,650 --> 00:53:56,870
ו בעיוורון להשתמש ערך ההחזרה שלו,
אמון שזה מחרוזת.

1099
00:53:56,870 --> 00:53:59,420
>> אני צריך לומר קודם,
היי, חכה רגע, רק

1100
00:53:59,420 --> 00:54:03,380
להמשיך אם הים לא שווה
null, null שם, שוב,

1101
00:54:03,380 --> 00:54:04,660
הוא רק חלק ערך מיוחד.

1102
00:54:04,660 --> 00:54:07,770
וזה הערך המיוחד רק לך
צריך לדאוג עבור מחרוזת גט.

1103
00:54:07,770 --> 00:54:10,900
קבל מחרוזת או הולכת
להחזיר מחרוזת או null.

1104
00:54:10,900 --> 00:54:17,219
>> וזה סימן קריאה זה סימן שוויון
אתה אולי יודע מ אולי בשיעור מתמטיקה

1105
00:54:17,219 --> 00:54:20,510
כי אתם יכולים לצייר סימן שוויון עם
קו דרכו כדי לציין לא שווה.

1106
00:54:20,510 --> 00:54:23,135
זה לא בדרך כלל דמות
תוכל להקליד במקלדת.

1107
00:54:23,135 --> 00:54:26,480
וכך בשפות תכנות ביותר,
כשרוצים לומר לא שווה,

1108
00:54:26,480 --> 00:54:29,160
אתה משתמש בסימן קריאה,
הידוע גם בשם המפץ.

1109
00:54:29,160 --> 00:54:33,180
אז אתה אומר מפץ שווה, אשר
פירושו לא שווה, באופן הגיוני.

1110
00:54:33,180 --> 00:54:38,060
זה בדיוק כמו שיש לא יותר
מ או שווה, פחות או יותר

1111
00:54:38,060 --> 00:54:41,270
או שווה ל מקש במקלדת
שעושה את כל זה ב סמל אחד.

1112
00:54:41,270 --> 00:54:44,020
אז זאת הסיבה, בדוגמאות האחרונות,
עשית סוגר פתוח, ולאחר מכן

1113
00:54:44,020 --> 00:54:48,670
סימן שוויון, על מנת לעשות
גדול או, לומר, פחות.

1114
00:54:48,670 --> 00:54:49,910
>> אז מה takeaway כאן?

1115
00:54:49,910 --> 00:54:53,880
זוהי פשוט דרך החברה של
החדרת תחביר זה, תכונה זו,

1116
00:54:53,880 --> 00:54:57,390
iterating מעל הפרט
תווים במחרוזת.

1117
00:54:57,390 --> 00:55:00,260
ובדיוק כמו אלה מרובעים
בסוגריים מאפשרים לך להגיע אליהם,

1118
00:55:00,260 --> 00:55:03,790
לשקול אלה בסוגריים מרובעים כמו
סוג של הרמז בסיסי זה

1119
00:55:03,790 --> 00:55:06,040
עיצוב, לפיה מחלקים מדי
דמות בתוך מחרוזת

1120
00:55:06,040 --> 00:55:10,180
סוג של הוא התאגרף ב איפשהו מתחת
למכסה המנוע בזיכרון של המחשב שלך.

1121
00:55:10,180 --> 00:55:12,340
>> אבל בואו נעשה את וריאנט של זה.

1122
00:55:12,340 --> 00:55:14,880
מתברר כי זה
התכנית נכונה.

1123
00:55:14,880 --> 00:55:18,810
אז לכל הצירים של CS50 להערכה
קוד, זה נכון עכשיו.

1124
00:55:18,810 --> 00:55:22,959
בייחוד עכשיו, אני בודק עבור
null, תכנית זו לא צריכה לקרוס.

1125
00:55:22,959 --> 00:55:24,500
ואני פשוט יודע את זה מניסיון.

1126
00:55:24,500 --> 00:55:28,040
אבל אין שום דבר אחר כי
אנחנו באמת יכולים להשתבש כאן.

1127
00:55:28,040 --> 00:55:31,860
אבל זה לא מאוד מעוצב היטב,
כי בואו לחזור ליסודות.

1128
00:55:31,860 --> 00:55:34,450
>> ראשית, principles--
מה עושה עבור לולאה לעשות?

1129
00:55:34,450 --> 00:55:36,290
עבור לולאה עושה שלושה דברים.

1130
00:55:36,290 --> 00:55:39,340
זה מאתחל כמה
ערך, אם תשאל אותו.

1131
00:55:39,340 --> 00:55:41,770
הוא בודק מצב.

1132
00:55:41,770 --> 00:55:45,380
ואז אחרי כל
איטרציה, לאחר כל מחזור,

1133
00:55:45,380 --> 00:55:49,330
זה מגדיל קצת
ערך, או ערכים, כאן.

1134
00:55:49,330 --> 00:55:50,600
>> אז מה זה אומר?

1135
00:55:50,600 --> 00:55:52,940
נאתחל i ל -0.

1136
00:55:52,940 --> 00:55:58,610
אנו לבדוק ולוודא i הוא פחות מ
אורך חרא, שזו-A-M-Y-L-A Z,

1137
00:55:58,610 --> 00:55:59,900
כך שהוא פחות מ -6.

1138
00:55:59,900 --> 00:56:02,590
ואכן, 0 כפחות מ -6.

1139
00:56:02,590 --> 00:56:05,580
>> אנו להדפיס Z מהשם של Zamyla.

1140
00:56:05,580 --> 00:56:08,080
אז אנחנו מגדילים i בין 0 ל -1.

1141
00:56:08,080 --> 00:56:11,290
לאחר מכן, אנו לבדוק, היא 1 פחות
המאור של הים?

1142
00:56:11,290 --> 00:56:13,270
אורכו של הים הוא 6.

1143
00:56:13,270 --> 00:56:13,950
כן זה כן.

1144
00:56:13,950 --> 00:56:16,880
>> אז אנחנו להדפיס בשם Zamyla, כז.

1145
00:56:16,880 --> 00:56:20,090
אנחנו להגדיל i בין 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
לאחר מכן, אנו לבדוק, היא 2 פחות
אורך שמו של Zamyla.

1147
00:56:23,720 --> 00:56:25,380
6- כך 2 הוא פחות מ -6.

1148
00:56:25,380 --> 00:56:30,460
כן, בואו להדפיס חברת M ב
שמו של Zamyla, הדמות השלישית.

1149
00:56:30,460 --> 00:56:34,110
>> המפתח כאן הוא כי על כל
איטרציה של הסיפור, אני בודק,

1150
00:56:34,110 --> 00:56:37,810
הוא אני פחות מאורך של Zamyla?

1151
00:56:37,810 --> 00:56:40,350
אבל לתפוס את זה
סטירלינג אינו רכוש.

1152
00:56:40,350 --> 00:56:43,100
אלה מכם שיש להם מתוכנת
לפני ב- Java או בשפות אחרות

1153
00:56:43,100 --> 00:56:46,310
יכול לדעת את האורך של מחרוזת היא
נכס, רק חלק לקרוא את הערך בלבד.

1154
00:56:46,310 --> 00:56:50,220
>> ב C במקרה זה, אם זה
פונקציה שהיא פשוטו כמשמעו

1155
00:56:50,220 --> 00:56:53,520
ספירת מספר
תווי Zamyla בכל פעם

1156
00:56:53,520 --> 00:56:54,740
אנו קוראים לפונקציה זו.

1157
00:56:54,740 --> 00:56:58,500
בכל פעם אתה שואל את המחשב להשתמש
סטירלינג, זה לוקח מבט Zamyla,

1158
00:56:58,500 --> 00:57:01,960
ואומר ת-א-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
וזה מחזיר 6.

1160
00:57:02,962 --> 00:57:04,920
בפעם הבאה שאתה קורא
זה בפנים כי עבור לולאה,

1161
00:57:04,920 --> 00:57:08,610
זה הולך להסתכל Zamyla
שוב, אומר ת-א-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
וזה הולך לחזור 6.

1163
00:57:10,320 --> 00:57:12,980
אז מה טיפשי על העיצוב הזה?

1164
00:57:12,980 --> 00:57:17,700
>> למה הקוד שלי לא 5 מתוך 5
עבור עיצוב עכשיו, אם אפשר לומר כך?

1165
00:57:17,700 --> 00:57:20,600
ובכן, אני שואל
שאלה שלא לצורך.

1166
00:57:20,600 --> 00:57:23,030
אני עושה יותר עבודה ממה שאני צריך.

1167
00:57:23,030 --> 00:57:25,370
>> אז למרות
התשובה היא נכונה, אני

1168
00:57:25,370 --> 00:57:29,560
לשאול את המחשב, מה הוא
אורך Zamyla שוב,

1169
00:57:29,560 --> 00:57:31,380
ושוב, ושוב, ושוב?

1170
00:57:31,380 --> 00:57:33,980
והתשובה כי הוא
לא הולך להשתנות.

1171
00:57:33,980 --> 00:57:35,900
זה תמיד הולך להיות 6.

1172
00:57:35,900 --> 00:57:39,730
>> אז פתרון יותר טוב מזה
יהיה הגרסה הבאה זה.

1173
00:57:39,730 --> 00:57:43,390
תן לי ללכת קדימה ולשים אותו
בקובץ נפרד בשם string1.c,

1174
00:57:43,390 --> 00:57:44,990
רק כדי לשמור אותו בנפרד.

1175
00:57:44,990 --> 00:57:47,260
ומתברר בתוך עבור
לולאה, אתה יכול למעשה

1176
00:57:47,260 --> 00:57:50,210
להכריז על משתנים מרובים בבת אחת.

1177
00:57:50,210 --> 00:57:53,460
>> אז אני הולך לשמור i ולהגדיר אותו 0.

1178
00:57:53,460 --> 00:57:56,190
אבל אני גם הולך
להוסיף פסיק, ולומר,

1179
00:57:56,190 --> 00:58:01,050
תן לי משתנה בשם n, אשר
ערך שווה מחרוזת באורך של s.

1180
00:58:01,050 --> 00:58:09,410
ועכשיו, בבקשה לעשות במצב שלי
כל עוד אני נמצא במרחק של פחות מ n.

1181
00:58:09,410 --> 00:58:14,140
>> אז בדרך זו, ההיגיון הוא
זהה בסוף היום.

1182
00:58:14,140 --> 00:58:18,280
אבל אני זוכר את
ערך 6, במקרה זה.

1183
00:58:18,280 --> 00:58:19,780
מהו האורך של שמו של Zamyla?

1184
00:58:19,780 --> 00:58:20,860
ואני מנסה את זה בבית n.

1185
00:58:20,860 --> 00:58:23,050
>> ואני עדיין בודק
התנאי בכל פעם.

1186
00:58:23,050 --> 00:58:24,300
האם 0 פחות מ -6?

1187
00:58:24,300 --> 00:58:25,600
האם 1 פחות מ 6?

1188
00:58:25,600 --> 00:58:28,600
האם 2 פחות מ -6, וכן הלאה?

1189
00:58:28,600 --> 00:58:31,914
>> אבל אני לא מבקש את המחשב
שוב, ושוב, מה

1190
00:58:31,914 --> 00:58:33,080
אורך שמו של Zamyla?

1191
00:58:33,080 --> 00:58:34,320
מה האורך של שמו של Zamyla?

1192
00:58:34,320 --> 00:58:35,986
מה האורך של שמו של Zamyla זה?

1193
00:58:35,986 --> 00:58:40,440
אני ממש שאני זוכר כי ראשון
רק לענות n המשתנה השני זה.

1194
00:58:40,440 --> 00:58:45,280
אז זה עכשיו יהיה לא רק
נכון, אבל גם מעוצב היטב.

1195
00:58:45,280 --> 00:58:46,670
>> עכשיו, מה עם סגנון?

1196
00:58:46,670 --> 00:58:48,866
אני כבר בשם המשתנה שלי
די טוב, הייתי אומר.

1197
00:58:48,866 --> 00:58:50,240
הם סופר תמציתיים עכשיו.

1198
00:58:50,240 --> 00:58:52,090
וזה לגמרי בסדר.

1199
00:58:52,090 --> 00:58:55,120
>> אם יש לך רק אחד
מחרוזת בתוכנית,

1200
00:58:55,120 --> 00:58:56,860
באותה מידה אתה יכול לקרוא לזה s עבור מחרוזת.

1201
00:58:56,860 --> 00:58:59,370
אם יש לך רק משתנה אחד
לספירה בתכנית,

1202
00:58:59,370 --> 00:59:00,710
באותה מידה אתה יכול לקרוא את זה אני.

1203
00:59:00,710 --> 00:59:03,500
אם יש לך אורך, n
סופר נפוץ גם הוא.

1204
00:59:03,500 --> 00:59:05,800
אבל אני לא הגבתי כל הקוד שלי.

1205
00:59:05,800 --> 00:59:09,200
>> אני כבר לא הודעתי reader--
אם זה TF שלי, או TA,

1206
00:59:09,200 --> 00:59:12,460
או סתם colleague-- מה שאמור
להיות קורה בתוכנית זו.

1207
00:59:12,460 --> 00:59:15,760
וכך לקבל סגנון טוב,
מה הייתי רוצה לעשות

1208
00:59:15,760 --> 00:59:24,580
זה-- משהו
כמו לבקש מהמשתמש קלט.

1209
00:59:24,580 --> 00:59:26,670
ואני יכול לשכתב
זה בכל מספר דרכים.

1210
00:59:26,670 --> 00:59:35,630
>> ודא s-- לעשות גט בטוח
מחרוזת חזרה מחרוזת.

1211
00:59:35,630 --> 00:59:40,280
ואז ב כאן-- וזו אולי
לחזר comment-- החשוב ביותר

1212
00:59:40,280 --> 00:59:44,450
על הדמויות של אחד בכל פעם.

1213
00:59:44,450 --> 00:59:47,060
ואני יכול להשתמש בכל
הבחירה של השפה האנגלית

1214
00:59:47,060 --> 00:59:49,650
כאן לתאר כל
של קטעים אלה של קוד.

1215
00:59:49,650 --> 00:59:52,740
>> שימו לב שלא שמתי
להגיב על כל שורת קוד אחת,

1216
00:59:52,740 --> 00:59:55,690
באמת רק על המעניין
אלה, אלה

1217
00:59:55,690 --> 00:59:59,460
יש משמעות כלשהי שאני עלול
רוצה לעשות סופר ברור למישהו

1218
00:59:59,460 --> 01:00:00,460
קריאת הקוד שלי.

1219
01:00:00,460 --> 01:00:02,920
ולמה אתה מתקשר לקבל
מחרוזת לבקש מהמשתמש קלט?

1220
01:00:02,920 --> 01:00:05,450
גם כי אחד אינו בהכרח
כל תיאורים.

1221
01:00:05,450 --> 01:00:09,340
אבל זה עוזר לספר סיפור, כי
הקו השני בסיפור הוא, לוודא

1222
01:00:09,340 --> 01:00:10,740
מחרוזת לקבל חזרה מחרוזת.

1223
01:00:10,740 --> 01:00:14,260
>> והשורה השלישית בסיפור הוא,
לחזר על הדמויות של אחד

1224
01:00:14,260 --> 01:00:15,380
בכל פעם.

1225
01:00:15,380 --> 01:00:17,920
ועכשיו רק למען הסדר הטוב,
אני הולך קדימה ולהוסיף

1226
01:00:17,920 --> 01:00:24,560
הערה אחת נוספת כי רק
אומר אופי i-ה הדפסה שבסעיף.

1227
01:00:24,560 --> 01:00:26,520
עכשיו, מה עשיתי
בסופו של היום?

1228
01:00:26,520 --> 01:00:29,190
>> הוספתי קצת אנגלית
מילים בצורת הערות.

1229
01:00:29,190 --> 01:00:32,700
סמל לוכסן לוכסן אומר, היי,
המחשב הזה הוא עבור האדם,

1230
01:00:32,700 --> 01:00:33,820
לא בשבילך, המחשב.

1231
01:00:33,820 --> 01:00:35,119
אז הם התעלמו באופן הגיוני.

1232
01:00:35,119 --> 01:00:35,910
הם פשוט שם.

1233
01:00:35,910 --> 01:00:39,830
>> ואכן, CS50 IDE מציגה אותם
אפור, כמו להיות שימושי, אבל לא מפתח

1234
01:00:39,830 --> 01:00:41,000
לתוכנית.

1235
01:00:41,000 --> 01:00:42,570
שים לב מה אתה יכול לעשות עכשיו.

1236
01:00:42,570 --> 01:00:44,950
בין אם אתה יודע C
תכנות או לא, אתה

1237
01:00:44,950 --> 01:00:47,722
יכול רק לעמוד מנגד בשעה זו
התוכנית, ולקרוא את ההערות.

1238
01:00:47,722 --> 01:00:50,180
בקש ממשתמש קלט, לוודא
מחרוזת לקבל חזרה מחרוזת,

1239
01:00:50,180 --> 01:00:53,009
לחזר על הדמויות של
אחד בכל פעם, להדפיס את הדמות

1240
01:00:53,009 --> 01:00:55,550
i-ה דמות s-- אתה לא
יש אפילו להסתכל על הקוד

1241
01:00:55,550 --> 01:00:57,270
להבין מה התוכנית הזו עושה.

1242
01:00:57,270 --> 01:01:00,280
וגם, יותר טוב, אם אתה עצמך נראה
על תכנית זו בעוד שבוע או שניים,

1243
01:01:00,280 --> 01:01:02,280
או חודש, או שנה,
אתה גם לא צריך

1244
01:01:02,280 --> 01:01:04,420
לבהות קוד,
מנסה להיזכר,

1245
01:01:04,420 --> 01:01:06,630
מה שניסיתי לעשות עם הקוד הזה?

1246
01:01:06,630 --> 01:01:07,770
>> ספרת עצמך.

1247
01:01:07,770 --> 01:01:11,660
תיארת את זה בעצמך,
או מעמיתיה, או TA, או TF.

1248
01:01:11,660 --> 01:01:14,860
וכך זה אמור היה להסתיים בשלב
בתכנון נכון, וטוב,

1249
01:01:14,860 --> 01:01:18,210
ובסופו של דבר טוב סגנון וכן.

1250
01:01:18,210 --> 01:01:19,990
אז לעשות לזכור את זה.

1251
01:01:19,990 --> 01:01:22,200
>> אז יש אחד אחר
דבר אני הולך לעשות כאן

1252
01:01:22,200 --> 01:01:28,240
שיכולים כעת לחשוף בדיוק מה
קורה מתחת למכסה המנוע.

1253
01:01:28,240 --> 01:01:30,390
אז יש במאפיין זה
ב- C, ובשפות אחרות,

1254
01:01:30,390 --> 01:01:33,010
לליהוק שחקנים בשם
כי באופן בלתי מודע

1255
01:01:33,010 --> 01:01:37,250
או במפורש מאפשר לך להמיר
מן סוג נתונים אחד למשנהו.

1256
01:01:37,250 --> 01:01:39,800
אנחנו כבר עוסקים כל כך
רחוק היום עם מחרוזות.

1257
01:01:39,800 --> 01:01:41,250
>> ומחרוזות הם תווים.

1258
01:01:41,250 --> 01:01:44,910
אבל זוכר משבוע
0, מה הן הדמויות?

1259
01:01:44,910 --> 01:01:49,334
הדמויות הן רק הפשטה
על גבי מספרים עשרוניים numbers--,

1260
01:01:49,334 --> 01:01:52,500
ומספרים עשרוניים הם באמת רק
הפשטה על גבי מספרים בינאריים,

1261
01:01:52,500 --> 01:01:53,720
כפי שהגדרנו אותו.

1262
01:01:53,720 --> 01:01:55,540
>> אז הדמויות הם מספרים.

1263
01:01:55,540 --> 01:01:58,410
ומספרי תווים,
רק בהתאם להקשר.

1264
01:01:58,410 --> 01:02:01,250
ומתברר כי בתוך
של תוכנת מחשב,

1265
01:02:01,250 --> 01:02:06,830
אתה יכול לציין כיצד אתה רוצה להיראות
על החלקים פנימיים של התכנית?

1266
01:02:06,830 --> 01:02:10,400
>> כזכור משבוע 0 שהיה לנו
ASCII, וזה רק את הקוד הזה

1267
01:02:10,400 --> 01:02:11,620
אותיות מיפוי למספרים.

1268
01:02:11,620 --> 01:02:13,660
ואמרנו, בירה היא 65.

1269
01:02:13,660 --> 01:02:15,860
B Capital הוא 66, וכן הלאה.

1270
01:02:15,860 --> 01:02:20,500
>> ושים לב, בעצם יש לנו תווים על
בשורה העליונה כאן, כמו C תקרא להם,

1271
01:02:20,500 --> 01:02:23,400
תווים, ולאחר מכן
ints בשורה השנייה.

1272
01:02:23,400 --> 01:02:28,180
ומתברר אתה יכול להמיר
בין שתיים בצורה חלקה, בדרך כלל.

1273
01:02:28,180 --> 01:02:30,042
ואם אנחנו רוצים לעשות
זה נעשה באופן מכוון, אנו

1274
01:02:30,042 --> 01:02:31,750
אולי כדאי לך להתמודד
משהו כזה.

1275
01:02:31,750 --> 01:02:33,590
>> אנחנו אולי רוצים להמיר
רישית להנמיך

1276
01:02:33,590 --> 01:02:35,330
במקרה, או אותיות קטנות לאות רישית.

1277
01:02:35,330 --> 01:02:38,000
ומתברר של שם
למעשה כאן דפוס

1278
01:02:38,000 --> 01:02:39,900
אנו יכולים לאמץ בעוד רגע.

1279
01:02:39,900 --> 01:02:44,120
אבל בואו נסתכל הראשון בבית
דוגמה עושה את זה במפורש.

1280
01:02:44,120 --> 01:02:46,340
>> אני הולך לחזור אל IDE CS50.

1281
01:02:46,340 --> 01:02:50,640
אני הולך ליצור
קובץ בשם Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
ואני הולך קדימה ולהוסיף שלי
io.h תקן בראש, void main int

1283
01:02:55,960 --> 01:02:57,370
בחלק העליון של הפונקציה שלי.

1284
01:02:57,370 --> 01:03:02,700
ואז אני פשוט הולך לעשות את
following-- ללולאת for מ- i שווה,

1285
01:03:02,700 --> 01:03:04,610
נניח, 65.

1286
01:03:04,610 --> 01:03:10,460
>> ואז אני הולך להיות פחות מ
65, בתוספת 26 אותיות האלפבית.

1287
01:03:10,460 --> 01:03:12,640
אז אני נותן את המחשב
לעשות את המתמטיקה לי שם.

1288
01:03:12,640 --> 01:03:15,100
ואז בתוך לולאה זו,
מה אני הולך להדפיס?

1289
01:03:15,100 --> 01:03:19,230
>> ג% הוא% i מהלך סרק n.

1290
01:03:19,230 --> 01:03:21,290
ועכשיו אני רוצה לחבר שני ערכים.

1291
01:03:21,290 --> 01:03:24,530
שמתי זמני שאלה
מסמן שם כדי להזמין את השאלה.

1292
01:03:24,530 --> 01:03:29,940
>> אני רוצה לחזר מ -65 ואילך
במשך 26 אותיות האלפבית,

1293
01:03:29,940 --> 01:03:35,190
בהדפסה של כל איטרציה כי
שווה הערך הנפרד של הדמות.

1294
01:03:35,190 --> 01:03:38,299
במילים אחרות, אני רוצה
לחזר על 26 מספרים הדפסה

1295
01:03:38,299 --> 01:03:41,590
מהו תו ASCII, המכתב,
ומה את המספר המתאים אז--

1296
01:03:41,590 --> 01:03:44,650
באמת רק יצירה מחדש
בתרשים משקופית זה.

1297
01:03:44,650 --> 01:03:47,010
אז מה צריך סימני שאלה אלה להיות?

1298
01:03:47,010 --> 01:03:51,760
>> ובכן, מתברר כי שני
אחד צריך להיות רק אני משתנה.

1299
01:03:51,760 --> 01:03:53,860
אני רוצה לראות את זה בתור מספר.

1300
01:03:53,860 --> 01:03:58,920
וגם את הטענה באמצע
כאן, אני יכול לומר למחשב

1301
01:03:58,920 --> 01:04:03,470
לטיפול שלם כי
אני כדמות, כדי

1302
01:04:03,470 --> 01:04:05,880
להחליף אותו כאן אחוז ג

1303
01:04:05,880 --> 01:04:07,990
>> במילים אחרות, אם אני,
מתכנת אדם, לדעת

1304
01:04:07,990 --> 01:04:09,865
אלה הם מספרים בלבד
בסופו של היום.

1305
01:04:09,865 --> 01:04:12,500
ואני יודע כי 65 צריכים
ממופה איזו דמות.

1306
01:04:12,500 --> 01:04:15,310
עם גבס מפורש זו,
עם סוגריים,

1307
01:04:15,310 --> 01:04:18,840
השם של סוג הנתונים שברצונך
להמיר, ו סוגריים סגורים,

1308
01:04:18,840 --> 01:04:21,200
אתה יכול לספר את
מחשב, היי, מחשב,

1309
01:04:21,200 --> 01:04:24,130
להמיר מספר שלם זה על char.

1310
01:04:24,130 --> 01:04:26,250
>> אז כאשר אני מפעיל זה
התוכנית לאחר קומפילציה,

1311
01:04:26,250 --> 01:04:29,740
בוא נראה מה אני להתרגל-- לעשות Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
אוף זה, מה עשיתי לא בסדר כאן?

1313
01:04:33,020 --> 01:04:35,884
שימוש מזהה מוצהר,
בסדר, לא מכוון,

1314
01:04:35,884 --> 01:04:37,800
אבל בוא נראה אם ​​אנחנו לא יכולים
הסיבה דרך זו.

1315
01:04:37,800 --> 01:04:41,220
>> אז קו five-- אז אני לא מקבל
רחוק מאוד לפני לפשל.

1316
01:04:41,220 --> 01:04:42,140
זה בסדר.

1317
01:04:42,140 --> 01:04:46,560
אז קו 5 עבור i שווה 65-- אני רואה.

1318
01:04:46,560 --> 01:04:50,130
אז לזכור כי ב- C, בניגוד לכמה
בשפות אם יש לך תכנות מראש

1319
01:04:50,130 --> 01:04:52,190
ניסיון, אתה צריך
כדי להורות למחשב,

1320
01:04:52,190 --> 01:04:55,040
בניגוד Scratch, מה
סוג של משתנה זה.

1321
01:04:55,040 --> 01:04:56,860
>> ושכחתי ביטוי המפתח כאן.

1322
01:04:56,860 --> 01:04:59,200
בתור חמש, אני כבר התחלתי להשתמש i.

1323
01:04:59,200 --> 01:05:01,560
אבל לא סיפרתי C
איזה סוג נתונים זה.

1324
01:05:01,560 --> 01:05:04,570
אז אני הולך להיכנס פה
אומרים, אה, להפוך אותו שלם.

1325
01:05:04,570 --> 01:05:07,050
>> עכשיו אני הולך קדימה, להדר מחדש.

1326
01:05:07,050 --> 01:05:08,080
כי תיקנו את זה.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 הזן, זה די מגניב.

1328
01:05:12,660 --> 01:05:15,360
לא רק שזה סופר מהיר כדי
שאל את המחשב על שאלה זו,

1329
01:05:15,360 --> 01:05:18,885
ולא לחפש אותו בשקופית,
זה הדפיס אחת בכל שורה, A הוא 65,

1330
01:05:18,885 --> 01:05:24,860
B הוא 66, כל הדרך down-- מאז שאני
עשו זאת 26 times-- אל z מכתבים,

1331
01:05:24,860 --> 01:05:25,630
המהווה 90.

1332
01:05:25,630 --> 01:05:27,790
ואכן, מעט
יותר אינטליגנטי היה

1333
01:05:27,790 --> 01:05:31,030
היה לי לא להסתמך
במחשב כדי להוסיף 26.

1334
01:05:31,030 --> 01:05:34,060
יכולתי רק לעשות
90 וכן, כל כך הרבה זמן

1335
01:05:34,060 --> 01:05:37,390
כמו שאני לא עושה את אותה טעות פעמיים.

1336
01:05:37,390 --> 01:05:41,880
אני רוצה לעלות דרך
z, לא רק דרך y.

1337
01:05:41,880 --> 01:05:44,000
>> אז זה קאסט מפורש.

1338
01:05:44,000 --> 01:05:47,860
מתברר כי זה
לא הוא אפילו הכרחי.

1339
01:05:47,860 --> 01:05:52,480
תן לי להמשיך בשידור חוזר זה
מהדר, שידור חוזר Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
מתברר כי C הוא די חכם.

1341
01:05:54,940 --> 01:05:57,150
>> ו printf, בפרט,
הוא די חכם.

1342
01:05:57,150 --> 01:06:01,260
אם אתה פשוט לעבור i פעמיים
עבור שני מצייני מיקום, printf

1343
01:06:01,260 --> 01:06:04,510
תבין, הו, אני מכיר אותך
נתנו לי integer-- מספר מסוים,

1344
01:06:04,510 --> 01:06:06,380
כמו 65, או 90, או מה שלא יהיה.

1345
01:06:06,380 --> 01:06:10,170
אבל אני רואה שאתה רוצה שאני
תבנית מספר כי כמו דמות.

1346
01:06:10,170 --> 01:06:16,460
וכך printf יכול להטיל במרומז
int ל char גם בשבילך.

1347
01:06:16,460 --> 01:06:19,360
אז זה לא בעיה בכלל.

1348
01:06:19,360 --> 01:06:23,100
>> אבל שם לב, בגלל שקילות זו
אנחנו באמת יכולים לעשות את זה גם כן.

1349
01:06:23,100 --> 01:06:26,520
תן לי להמשיך ולעשות אחד
גרסה אחרת של זה- Ascii 1 ג

1350
01:06:26,520 --> 01:06:31,800
ובמקום iterating מעל
מספרים שלמים, יכול באמת מכה את דעתך

1351
01:06:31,800 --> 01:06:33,610
על ידי iterating על הדמויות.

1352
01:06:33,610 --> 01:06:37,660
אם ג char מקבל הון, אני
רוצה להמשיך לעשות את זה,

1353
01:06:37,660 --> 01:06:41,740
כל עוד C הוא פחות או שווה
עד Z. הון על כל איטרציה

1354
01:06:41,740 --> 01:06:45,690
אני רוצה להגדיל C, אני יכול
עכשיו בתור printf שלי כאן

1355
01:06:45,690 --> 01:06:51,320
למשל, אחוז C הוא
אחוז אני שוב, פסיק ג

1356
01:06:51,320 --> 01:06:57,200
>> ועכשיו, אני יכול ללכת לכיוון השני,
ליהוק הדמות במפורש

1357
01:06:57,200 --> 01:06:58,500
למספר שלם.

1358
01:06:58,500 --> 01:07:00,560
אז, שוב, למה אתה עושה את זה?

1359
01:07:00,560 --> 01:07:03,830
זה קצת מוזר למיין של
לספור מבחינת הדמויות.

1360
01:07:03,830 --> 01:07:07,430
>> אבל אם אתה מבין מה
קורה מתחת למכסה המנוע,

1361
01:07:07,430 --> 01:07:08,430
באמת אין קסם.

1362
01:07:08,430 --> 01:07:13,060
אתה רק אומר, היי, המחשב לתת
לי משתנה בשם ג 'מסוג char.

1363
01:07:13,060 --> 01:07:16,520
לאתחל אותו א ההון
לב עניין בגרשיים בודד.

1364
01:07:16,520 --> 01:07:19,580
>> לקבלת תווים ב- C, שזכור
בשבוע שעבר, אתה משתמש בגרשיים בודדים.

1365
01:07:19,580 --> 01:07:23,720
עבור מחרוזות, מילים,
ביטויים, אתה משתמש במרכאות כפולות.

1366
01:07:23,720 --> 01:07:27,210
אישור, מחשב, ימשיך לעשות את זה, אז
עוד התו הוא פחות מ

1367
01:07:27,210 --> 01:07:28,050
או שווה ל z.

1368
01:07:28,050 --> 01:07:32,640
ואני יודע משולחן Ascii שלי שכל
של קודי ASCII אלה הם רציפים.

1369
01:07:32,640 --> 01:07:33,400
>> אין פערים.

1370
01:07:33,400 --> 01:07:36,737
אז זה רק דרך Z,
מופרד על ידי כל מספר אחד.

1371
01:07:36,737 --> 01:07:38,820
ואז אני יכול להגדיל
לדמות יש, אם אני באמת רוצה.

1372
01:07:38,820 --> 01:07:40,390
בסופו של היום,
זה רק מספר.

1373
01:07:40,390 --> 01:07:41,030
אני יודע את זה.

1374
01:07:41,030 --> 01:07:43,670
אז אני יכול רק להניח להוסיף 1 אליו.

1375
01:07:43,670 --> 01:07:46,940
>> ואז הפעם, אני מדפיס ג,
ואז המקבילה הנפרדת.

1376
01:07:46,940 --> 01:07:50,170
ואני אפילו לא צריך להפיל המפורש.

1377
01:07:50,170 --> 01:07:52,680
אני יכול לתת printf ואת
דברי דמות מחשב החוצה,

1378
01:07:52,680 --> 01:07:57,300
כך שכעת אם אני רץ
להפוך Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
אני מקבל בדיוק את אותו הדבר גם כן.

1380
01:08:01,520 --> 01:08:04,530
>> תוכנית חסרת תועלת, though-- אף אחד
הולך לכתוב בעצם תוכנה

1381
01:08:04,530 --> 01:08:07,549
כדי להבין, מה היה
מספר הממפה ל A, או B, או Z?

1382
01:08:07,549 --> 01:08:10,340
אתה פשוט הולך בגוגל, או
לבדוק את זה באינטרנט, או לבדוק את זה

1383
01:08:10,340 --> 01:08:11,650
בשקופית, או משהו דומה.

1384
01:08:11,650 --> 01:08:13,520
אז איפה זה עושה בעצם לקבל שימושי?

1385
01:08:13,520 --> 01:08:15,960
>> ובכן, כבר מדברים על זה
שקופיות, שימו לב שיש

1386
01:08:15,960 --> 01:08:20,890
דפוס בפועל כאן בין רישיות
וקטן כי לא היה מקרי.

1387
01:08:20,890 --> 01:08:23,760
להבחין כי ההון הוא 65.

1388
01:08:23,760 --> 01:08:25,830
אותיות קטנות a הוא 97.

1389
01:08:25,830 --> 01:08:29,649
וכמה רחוק הוא במקרה נמוך יותר?

1390
01:08:29,649 --> 01:08:32,649
>> אז 65 הוא כמה צעדים מן 97?

1391
01:08:32,649 --> 01:08:36,210
אז 97 מינוס 65 הוא 32.

1392
01:08:36,210 --> 01:08:37,910
אז הון הוא 65.

1393
01:08:37,910 --> 01:08:39,939
אם אתה מוסיף 32 לזה,
אתה מקבל באותיות קטנות a.

1394
01:08:39,939 --> 01:08:43,729
וגם, באופן שקול, אם מחסר 32,
לך לחזור ההון לזה-- אותו עם B

1395
01:08:43,729 --> 01:08:46,380
ל- B הקטן, גדול C ל- C מעט.

1396
01:08:46,380 --> 01:08:50,670
>> כל הפערים האלה הם 32 זה מזה.

1397
01:08:50,670 --> 01:08:54,450
עכשיו, זה היה נראה מאפשר לנו
לעשות משהו כמו Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
או Google Docs תכונה, איפה אתה
ניתן לבחור כל דבר, ואז אומרים,

1399
01:08:57,729 --> 01:09:00,520
לשנות את כל לאותיות קטנות, או
לשנות את כל לאות רישית,

1400
01:09:00,520 --> 01:09:03,840
או לשנות רק את המילה הראשונה
משפט לאות רישית.

1401
01:09:03,840 --> 01:09:07,390
אנחנו יכולים בעצם לעשות משהו
ככה עצמנו.

1402
01:09:07,390 --> 01:09:12,645
>> תן לי להמשיך לשמור קובץ
כאן נקרא לנצל 0.c.

1403
01:09:12,645 --> 01:09:15,770
ועכשיו בואו נלך קדימה להלהיב תכנית
שעושה בדיוק את זה כדלקמן.

1404
01:09:15,770 --> 01:09:18,460
אז לכלול ספריית CS50.

1405
01:09:18,460 --> 01:09:21,430
וכולל I / O סטנדרטי.

1406
01:09:21,430 --> 01:09:22,787
>> ואני יודע שזה יהיה זמין בקרוב.

1407
01:09:22,787 --> 01:09:24,870
אז אני הולך לשים את זה
יש כבר, string.h,

1408
01:09:24,870 --> 01:09:26,960
אז יש לי גישה
דברים כמו סטירלינג,

1409
01:09:26,960 --> 01:09:29,620
ואז int void main, כרגיל.

1410
01:09:29,620 --> 01:09:33,420
ואז אני הולך קדימה
ולעשות מחרוזות מקבל מקבל מחרוזת,

1411
01:09:33,420 --> 01:09:35,032
רק כדי לקבל מחרוזת מהמשתמש.

1412
01:09:35,032 --> 01:09:36,740
ואז אני הולך
לעשות בדיקת השפיות שלי.

1413
01:09:36,740 --> 01:09:40,510
אם המחרוזת לא null השווה,
אז זה בטוח להמשיך.

1414
01:09:40,510 --> 01:09:42,000
ומה לעשות מה שאני רוצה לעשות?

1415
01:09:42,000 --> 01:09:48,700
אני הולך לחזר מ- i שווה 0,
ו n עד מחרוזת באורך של s.

1416
01:09:48,700 --> 01:09:51,899
>> ואני הולך לעשות את זה כל עוד
אני הוא פחות מ n, ואני פלוס פלוס.

1417
01:09:51,899 --> 01:09:55,060
עד כה, אני באמת רק
לשאול רעיונות מלפני.

1418
01:09:55,060 --> 01:09:57,010
ועכשיו אני הולך להכניס ענף.

1419
01:09:57,010 --> 01:09:59,635
>> אז נזכרתי Scratch, שם
היו לנו מזלגות אלה על הכביש,

1420
01:09:59,635 --> 01:10:05,110
ובשבוע שעבר ב C. אני הולך
להגיד את זה, אם הדמות i-ה שבסעיף

1421
01:10:05,110 --> 01:10:09,250
הוא גדול או
שווה לאותיות קטנות a,

1422
01:10:09,250 --> 01:10:13,340
ו-- ב Scratch שהיית ממש
לומר, אבל ב- C אתה אומר אמפרסנד,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- והאופי-ה i שבסעיף
הוא פחות מ z לאותיות קטנות או שווה,

1424
01:10:19,830 --> 01:10:21,780
בוא נעשה משהו מעניין.

1425
01:10:21,780 --> 01:10:27,020
בואו למעשה להדפיס
אופי ללא שורה חדשה

1426
01:10:27,020 --> 01:10:31,760
כי הוא הדמות במחרוזת,
הדמות i-ה במחרוזת.

1427
01:10:31,760 --> 01:10:37,420
>> אבל בואו נלך קדימה
להחסיר 32 ממנו.

1428
01:10:37,420 --> 01:10:42,120
אחר אם התו
מחרוזת שאנחנו מחפשים

1429
01:10:42,120 --> 01:10:45,950
הוא לא בין קצת
ומעט z, קדימה

1430
01:10:45,950 --> 01:10:48,610
ופשוט הדפיס אותו החוצה ללא שינוי.

1431
01:10:48,610 --> 01:10:50,840
אז השקנו
כיתוב בסוגריים זה

1432
01:10:50,840 --> 01:10:53,560
עבור המחרוזות שלנו להגיע לחקר
i-ה תו במחרוזת.

1433
01:10:53,560 --> 01:10:57,520
>> הוספתי קצת היגיון מותנה, כמו
Scratch בשבוע אחד בשבוע שעבר, שבו

1434
01:10:57,520 --> 01:10:59,880
אני רק באמצעות שלי היסוד
הבנה של מה

1435
01:10:59,880 --> 01:11:01,130
קורה מתחת למכסה המנוע.

1436
01:11:01,130 --> 01:11:04,190
האם דמות i-ה s
גדול או שווה ל?

1437
01:11:04,190 --> 01:11:08,290
כלומר, יש בו 97, או 98,
או 99, וכן הלאה?

1438
01:11:08,290 --> 01:11:11,940
>> אבל האם זה גם פחות או שווה
לערך z הקטנה?

1439
01:11:11,940 --> 01:11:16,210
ואם כן, מה המשמעות של קו זה אומר?

1440
01:11:16,210 --> 01:11:20,250
14, זה סוג של
נבט של הרעיון,

1441
01:11:20,250 --> 01:11:23,840
הופך את האות על ידי
פשוט חיסור 32 ממנו,

1442
01:11:23,840 --> 01:11:29,370
במקרה זה, כי אני יודע, לכל כי
תרשים, איך המספרים שלי מיוצגים.

1443
01:11:29,370 --> 01:11:33,925
אז בואו נלך קדימה ולרוץ זה,
לאחר קומפילציה לנצל 0.c,

1444
01:11:33,925 --> 01:11:36,210
וברח לנצל 0.

1445
01:11:36,210 --> 01:11:40,300
>> בואו להקליד משהו כמו
Zamyla בכל הקטן להיכנס.

1446
01:11:40,300 --> 01:11:42,780
ועכשיו יש לנו Zamyla בכל רישיות.

1447
01:11:42,780 --> 01:11:45,050
בואו להקליד רוב בכל הקטן.

1448
01:11:45,050 --> 01:11:46,674
בואו ננסה ג'ייסון בכל הקטן.

1449
01:11:46,674 --> 01:11:48,590
ואנחנו שומרים מקבלים את
היוון כפייה.

1450
01:11:48,590 --> 01:11:50,960
יש באגים קטנים שאני
סוג של לא צפה.

1451
01:11:50,960 --> 01:11:54,050
במועד ההודעה החדשה שלי מסתיימת
באותה שורה כמו שמותיהם,

1452
01:11:54,050 --> 01:11:55,520
אשר מרגיש מבולגן קצת.

1453
01:11:55,520 --> 01:11:59,170
>> אז אני הולך כאן,
למעשה בסוף תוכנית זו

1454
01:11:59,170 --> 01:12:02,110
להדפיס את אופי שורה חדש.

1455
01:12:02,110 --> 01:12:03,160
זה הכל.

1456
01:12:03,160 --> 01:12:06,120
עם printf, אתה לא צריך
לעבור במשתנים או קוד העיצוב.

1457
01:12:06,120 --> 01:12:08,460
אתה ממש יכול פשוט להדפיס
משהו כמו שורה חדשה.

1458
01:12:08,460 --> 01:12:13,529
>> אז בואו נלך קדימה ולעשות
לנצל 0 שוב, בשידור חוזר זה, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
ועכשיו זה יפה מעט.

1460
01:12:14,820 --> 01:12:17,274
עכשיו, הפקודה שלי היא על הקו החדש משלו.

1461
01:12:17,274 --> 01:12:18,440
אז זה הכל טוב ויפה.

1462
01:12:18,440 --> 01:12:19,910
אז זה דוגמא טובה.

1463
01:12:19,910 --> 01:12:22,700
אבל אני אפילו לא בהכרח
צריך קוד קשה 32.

1464
01:12:22,700 --> 01:12:23,350
אתה יודע מה?

1465
01:12:23,350 --> 01:12:26,350
יכולתי say-- שאני עושה לא פעם
זוכר מה ההבדל.

1466
01:12:26,350 --> 01:12:29,330
>> אבל אני יודע שאם אני
יש מכתב באותיות קטן,

1467
01:12:29,330 --> 01:12:34,430
אני בעצם רוצה להפחית את
מה המרחק בין קטן

1468
01:12:34,430 --> 01:12:39,160
א 'ו-גדול, כי אם אני מניח כי
כל האותיות האחרות זהה,

1469
01:12:39,160 --> 01:12:41,045
כי צריך לעשות את העבודה.

1470
01:12:41,045 --> 01:12:42,670
אבל במקום לעשות את זה, אתה יודע מה?

1471
01:12:42,670 --> 01:12:44,240
יש דרך נוספת עדיין.

1472
01:12:44,240 --> 01:12:48,090
>> ואם זה לנצל 1.c-- אם הייתי
לשים את זה לקובץ נפרד.

1473
01:12:48,090 --> 01:12:51,030
בוא נעשה לנצל 2.ג כדלקמן.

1474
01:12:51,030 --> 01:12:53,060
אני הולך באמת לנקות זה כאן.

1475
01:12:53,060 --> 01:12:57,420
ובמקום אפילו צורך
יודע או אכפת אלה ברמה הנמוכה

1476
01:12:57,420 --> 01:13:01,090
פרטי היישום, אני במקום
רק הולך להדפיס דמות,

1477
01:13:01,090 --> 01:13:04,610
ציטוט סוף ציטוט, אחוז C,
ואז להתקשר פונקציה אחרת כי

1478
01:13:04,610 --> 01:13:09,950
קיים שלוקח ויכוח,
אשר הוא דמות, ככה.

1479
01:13:09,950 --> 01:13:12,630
>> מתברר ב- C, יש
קריאה לפונקציה אחרת

1480
01:13:12,630 --> 01:13:15,550
כדי עליון, אשר כשמו
מרמז לוקח דמות

1481
01:13:15,550 --> 01:13:19,350
והופך אותו לאות רישית שלה
שווה ערך, ולאחר מכן מחזיר אותו

1482
01:13:19,350 --> 01:13:21,410
כך printf יכול לחבר אותו לשם.

1483
01:13:21,410 --> 01:13:25,484
וכך לעשות את זה, אם כי, אני
צריך להציג את הקובץ השני.

1484
01:13:25,484 --> 01:13:28,400
מתברר שיש עוד קובץ
כי היית יודע מכיתה רק,

1485
01:13:28,400 --> 01:13:33,020
או ספר לימוד, או באינטרנט
התייחסות, type.h. C שנקרא

1486
01:13:33,020 --> 01:13:38,570
>> אז אם אני מוסיף את זה בין הכותרת שלי
קבצים, ועכשיו מחדש לקמפל תוכנית זו,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
בואו להקליד Zamyla בכל
קטן, עדיין עובד אותו הדבר.

1489
01:13:46,690 --> 01:13:48,040
אבל אתה יודע מה?

1490
01:13:48,040 --> 01:13:55,590
מתברר שכדי עליון
יש כמה פונקציונלי אחרות.

1491
01:13:55,590 --> 01:13:58,410
>> ותנו לי להציג זה
מפקד פה, מעין במבוכה

1492
01:13:58,410 --> 01:14:00,250
בשם, אבל איש עבור ידני.

1493
01:14:00,250 --> 01:14:03,960
מתברר כי רוב מחשבי לינוקס,
כפי שאנו משתמשים כאן-- ההפעלה לינוקס

1494
01:14:03,960 --> 01:14:06,270
system-- יש פקודה
אדם בשם, אשר אומר,

1495
01:14:06,270 --> 01:14:08,530
היי, מחשב, תן לי
במדריך של המחשב.

1496
01:14:08,530 --> 01:14:10,680
מה אתה רוצה
לחפש במדריך זה?

1497
01:14:10,680 --> 01:14:13,840
>> אני רוצה לחפש את הפונקציה
קרא עליון, Enter.

1498
01:14:13,840 --> 01:14:16,070
וזה לא ברור מספיק
לקרוא לפעמים.

1499
01:14:16,070 --> 01:14:18,780
אבל לב שאנחנו בבית
במדריך של מתכנת לינוקס.

1500
01:14:18,780 --> 01:14:19,530
וזה כל הטקסט.

1501
01:14:19,530 --> 01:14:21,905
ושימו לב כי יש את
שם הפונקציה כאן.

1502
01:14:21,905 --> 01:14:25,030
מתברר שיש לו בת דודה בשם
להנמיך, אשר עושה את ההיפך.

1503
01:14:25,030 --> 01:14:29,710
והודעה תחת תקציר, להשתמש זה
לתפקד בו האדם, אם אפשר לומר כך,

1504
01:14:29,710 --> 01:14:32,220
הוא אומר לי שאני
צריך לכלול ג type.h.

1505
01:14:32,220 --> 01:14:33,630
וידעתי כי מהפרקטיקה.

1506
01:14:33,630 --> 01:14:36,210
>> הנה, זה מראה לי את שני
טיפוס עבור הפונקציה,

1507
01:14:36,210 --> 01:14:39,070
כך שאם אי פעם אני רוצה להשתמש זה
אני יודע מה הם לוקחים כקלט,

1508
01:14:39,070 --> 01:14:40,652
ומה הם חוזרים כפלט.

1509
01:14:40,652 --> 01:14:42,360
ואז אם אני קורא
התיאור, אני רואה

1510
01:14:42,360 --> 01:14:44,820
ביתר פירוט מה הפונקציה עושה.

1511
01:14:44,820 --> 01:14:48,100
אבל יותר חשוב, אם
אני מסתכל תחת ערך מוחזר,

1512
01:14:48,100 --> 01:14:51,710
זה אומר הערך המוחזר הוא
כי המכתב המר,

1513
01:14:51,710 --> 01:14:57,880
או C, הקלט המקורי, אם
ההמרה לא הייתה אפשרית.

1514
01:14:57,880 --> 01:15:01,992
>> במילים אחרות, כדי העליונה ינסו
להמיר מכתב לאות רישית.

1515
01:15:01,992 --> 01:15:03,450
ואם כן, זה הולך להחזיר אותו.

1516
01:15:03,450 --> 01:15:07,010
אבל אם זה לא יכול לחלק reason--
אולי זה כבר רישית,

1517
01:15:07,010 --> 01:15:09,550
אולי זה קריאת נקודה
או כמה punctuation-- אחר

1518
01:15:09,550 --> 01:15:12,200
זה פשוט הולך
להחזיר את C המקורי,

1519
01:15:12,200 --> 01:15:17,340
מה שאומר שאני יכול לעשות הקוד שלי
ככל שהיטיב כדלקמן.

1520
01:15:17,340 --> 01:15:20,580
>> אני לא צריך את כל
קווי המעצבן הזה אלה של קוד.

1521
01:15:20,580 --> 01:15:22,610
כל הקווים לי
יכול רק הדגיש

1522
01:15:22,610 --> 01:15:28,700
התמוטט רק לתוך אחד פשוט
קו, אשר זה-- printf אחוזים

1523
01:15:28,700 --> 01:15:33,510
ג סוגר S העליון i.

1524
01:15:33,510 --> 01:15:36,090
וזה יהיה
דוגמא של עיצוב טוב.

1525
01:15:36,090 --> 01:15:40,040
>> למה ליישם בקווים 7 או 8
של קוד, מה שזה לא היה אני פשוט

1526
01:15:40,040 --> 01:15:44,960
נמחק, כאשר אתה יכול במקום לקרוס
כל זה עושה היגיון וההחלטה

1527
01:15:44,960 --> 01:15:49,620
לתוך שורה אחת אחת, 13 עכשיו, כי
מסתמך על ספרייה function--

1528
01:15:49,620 --> 01:15:53,430
פונקציה שמגיעה עם C, אבל זה
עושה בדיוק מה שאתה רוצה לעשות את זה.

1529
01:15:53,430 --> 01:15:55,295
ולמען האמת, גם אם
זה לא הגיע עם C,

1530
01:15:55,295 --> 01:15:58,880
אתה יכול ליישם את זה בעצמך, כפי
שראינו, עם לקבל int שלילית

1531
01:15:58,880 --> 01:16:01,700
ולקבל שבוע חיובי int האחרון גם כן.

1532
01:16:01,700 --> 01:16:03,470
>> קוד זה עכשיו הרבה יותר קריא.

1533
01:16:03,470 --> 01:16:06,670
ואכן, אם אנו לגלול מעלה,
תראה כמה הרבה יותר קומפקטי

1534
01:16:06,670 --> 01:16:08,360
בגירסה זו של התוכנית שלי היא.

1535
01:16:08,360 --> 01:16:11,230
זהו כבד עליון קצת עכשיו,
עם כל אלה כוללים.

1536
01:16:11,230 --> 01:16:14,380
אבל זה בסדר, כי עכשיו אני עומד
על כתפיהם של מתכנתים

1537
01:16:14,380 --> 01:16:15,300
לפניי.

1538
01:16:15,300 --> 01:16:18,440
ומי זה היה מי
מיושם על מנת עליון באמת

1539
01:16:18,440 --> 01:16:21,470
עשה לי טוב, ממש כמו מי
מיושם סטירלינג באמת

1540
01:16:21,470 --> 01:16:24,790
עשה לי טוב לפני כמה זמן.

1541
01:16:24,790 --> 01:16:26,970
אז עכשיו יש לנו
תוכנית עיצוב טוב יותר

1542
01:16:26,970 --> 01:16:31,680
המיישמת את הלוגיקה זהה.

1543
01:16:31,680 --> 01:16:35,580
>> אם כבר מדברים על סטירלינג, תן
לי להמשיך לעשות את זה.

1544
01:16:35,580 --> 01:16:38,320
תן לי ללכת קדימה ולשמור
קובץ זה כמו stirling.c.

1545
01:16:38,320 --> 01:16:43,255
ומתברר, אנחנו יכולים לקלף בחזרה
אחד אחר שכבה די פשוט עכשיו.

1546
01:16:43,255 --> 01:16:45,630
אני הולך קדימה, שוט
עד תכנית אחרת ראשי

1547
01:16:45,630 --> 01:16:49,759
כאן שפשוט מחדש סככה
מחרוזת באורך כדלקמן.

1548
01:16:49,759 --> 01:16:52,300
אז הנה שורת קוד זה
יהיה לי מחרוזת מהמשתמש.

1549
01:16:52,300 --> 01:16:53,910
אנחנו ממשיכים באמצעות זה שוב ושוב.

1550
01:16:53,910 --> 01:16:58,900
תן לי לתת את עצמי משתנה בשם
n של int סוג מאחסן מספר.

1551
01:16:58,900 --> 01:17:02,490
>> ותן לי להמשיך
לעשות את ההיגיון הבא.

1552
01:17:02,490 --> 01:17:15,610
בעוד דמות-ה n שבסעיף עושה
לא מהלך סרק 0 שווה, קדימה

1553
01:17:15,610 --> 01:17:17,930
ו להגדיל n.

1554
01:17:17,930 --> 01:17:23,506
ואז להדפיס n i printf אחוזים.

1555
01:17:23,506 --> 01:17:29,200
אני טוען כי תכנית זו כאן,
בלי לקרוא אורך מחרוזת,

1556
01:17:29,200 --> 01:17:31,150
להבין איך פותחים את האורך של מחרוזת.

1557
01:17:31,150 --> 01:17:34,600
>> והקסם הוא לגמרי
הגלום קו 8

1558
01:17:34,600 --> 01:17:39,830
כאן עם מה שנראה כמו תחביר חדש,
מהלך סרק 0 זה במרכאות יחידות.

1559
01:17:39,830 --> 01:17:41,360
אבל למה זה?

1560
01:17:41,360 --> 01:17:44,100
ובכן, לחשוב על מה היה
קורה כל הזמן הזה.

1561
01:17:44,100 --> 01:17:47,990
>> ואגב זה לפני שאשכח, מבין
מדי, כי בנוסף לדפי ההוראות

1562
01:17:47,990 --> 01:17:50,920
שמגיע עם טיפוסי
מערכת לינוקס כמו CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
להבין כי אנו,
גם של הצוות כמובן, יש

1564
01:17:53,770 --> 01:17:56,030
עשה גרסת אתר
של אותו הרעיון הזה שנקרא

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, אשר יש
כל דפי איש אותם,

1566
01:17:59,940 --> 01:18:02,020
כל זה באותו
תיעוד, וכן

1567
01:18:02,020 --> 01:18:05,730
קופסה קטנה בחלק העליון המאפשר
לך להמיר את כל למדי

1568
01:18:05,730 --> 01:18:09,025
שפה מסתורית לתוך פחות נוח
מצב, שבו אנו, צוות המורים,

1569
01:18:09,025 --> 01:18:12,150
עברתי וניסה לפשט
חלק מהשפה לשמור דברים

1570
01:18:12,150 --> 01:18:14,830
התמקד הרעיונות, ולא
חלק הפרטים הטכניים.

1571
01:18:14,830 --> 01:18:20,070
אז לזכור, reference.cs50.net
כמשאב אחר גם כן.

1572
01:18:20,070 --> 01:18:23,800
>> אבל מדוע מחרוזת באורך עבודה
בדרך הצעתי לפני רגע?

1573
01:18:23,800 --> 01:18:25,160
הנה שם של Zamyla שוב.

1574
01:18:25,160 --> 01:18:27,690
והנה שמו של Zamyla
התאגרף, כפי שאני להמשיך לעשות,

1575
01:18:27,690 --> 01:18:31,360
לצייר תמונה של אותו להיות,
באמת, רק רצף של תווים.

1576
01:18:31,360 --> 01:18:34,260
אבל Zamyla אינו קיים
בבידוד בתוכנית.

1577
01:18:34,260 --> 01:18:37,420
>> כשאתה כותב ולהפעיל תוכנית,
אתה משתמש ב- Mac שלך או למחשב

1578
01:18:37,420 --> 01:18:40,010
כמו זיכרון, או RAM כביכול.

1579
01:18:40,010 --> 01:18:42,620
ואתה יכול לחשוב
מחשב כבעל

1580
01:18:42,620 --> 01:18:44,730
המון ג'יגה-בייט של זיכרון בימים אלה.

1581
01:18:44,730 --> 01:18:47,700
ו חלטורה אומרת מיליארדים,
כך מיליארדי בייטים.

1582
01:18:47,700 --> 01:18:48,910
>> אבל בואו אחורה בזמן.

1583
01:18:48,910 --> 01:18:51,530
ונניח שאנחנו משתמשים
מחשב ישן באמת כל כך

1584
01:18:51,530 --> 01:18:55,150
יש רק 32 בתים של זיכרון.

1585
01:18:55,150 --> 01:18:59,310
יכולתי, על מסך המחשב שלי,
לצייר זה פשוט החוצה כדלקמן.

1586
01:18:59,310 --> 01:19:05,240
>> אני פשוט יכול לומר שלי
יש מחשב כל הזיכרון הזה.

1587
01:19:05,240 --> 01:19:08,830
וזה כמו מקל של זיכרון, אם
אתה זוכר את התמונה שלנו מהפעם הקודמת.

1588
01:19:08,830 --> 01:19:11,670
ואם אני רק לחלק
זה מספיק פעמים,

1589
01:19:11,670 --> 01:19:15,040
אני טוען שיש לי 32 בתים
זיכרון על המסך.

1590
01:19:15,040 --> 01:19:18,239
>> עכשיו, במציאות, אני יכול רק
לצייר עד כה על המסך הזה כאן.

1591
01:19:18,239 --> 01:19:20,280
אז אני הולך קדימה,
ופשוט לפי האמנה,

1592
01:19:20,280 --> 01:19:24,050
לצייר את הזיכרון של המחשב שלי בתור
רשת, לא רק קו ישר אחד.

1593
01:19:24,050 --> 01:19:28,190
באופן ספציפי, אני טוען כעת כי
זה סמלים, סמלים 8 ב -4 זה,

1594
01:19:28,190 --> 01:19:31,800
רק מייצג את כל 32 הבתים
זיכרון זמין ב- Mac שלי,

1595
01:19:31,800 --> 01:19:33,030
או זמין במחשב שלי.

1596
01:19:33,030 --> 01:19:34,780
והם גלישה
על שתי שורות, רק

1597
01:19:34,780 --> 01:19:38,030
כי זה מתאים יותר על המסך.

1598
01:19:38,030 --> 01:19:40,800
אך זהו הבית הראשון.

1599
01:19:40,800 --> 01:19:41,990
זהו בייט השני.

1600
01:19:41,990 --> 01:19:43,300
זהו בייט השלישי.

1601
01:19:43,300 --> 01:19:45,310
>> וזו בייט ה -32.

1602
01:19:45,310 --> 01:19:52,910
לחלופין, אם אנחנו חושבים כמו מחשב
מדען, זה בייט 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
אז אתה יש לך 0 ל -31, אם
אתה מתחיל לספור ב 0.

1604
01:19:55,950 --> 01:19:59,830
>> אז אם נשתמש תוכנית
כי שיחות לקבל מחרוזת,

1605
01:19:59,830 --> 01:20:05,280
ואנחנו מקבלים מחרוזת מן האדם
כמו כן קראו לי Zamyla, ת-א-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
איך לכל הרוחות עושה את
לשמור על מחשב אחר אשר בייט,

1607
01:20:09,430 --> 01:20:12,230
אשר נתח של זיכרון,
שייך לאיזה מחרוזת?

1608
01:20:12,230 --> 01:20:16,270
במילים אחרות, אם אנו ממשיכים ומבקשים
הקלד שם אחר לתוך המחשב,

1609
01:20:16,270 --> 01:20:19,890
כמו אנדי זו, הקוראת
מחרוזת לקבל בפעם שנייה,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I צריך בסופו של דבר
גם הזיכרון של המחשב.

1611
01:20:23,030 --> 01:20:23,850
אבל איך?

1612
01:20:23,850 --> 01:20:29,700
>> ובכן, מתברר כי מתחת
מכסה המנוע, מה C עושה כאשר לאחסון מחרוזות

1613
01:20:29,700 --> 01:20:35,080
כך שסוגי האדם, או כי
לבוא ממקור אחר, הוא זה

1614
01:20:35,080 --> 01:20:39,190
מתווה סוף אותם עם
קו נטוי הפוך character-- מיוחד

1615
01:20:39,190 --> 01:20:44,750
0, שהוא רק בדרך מיוחדת
לומר 80 סיביות ברציפות.

1616
01:20:44,750 --> 01:20:47,950
>> אז לזה-- זהו זוכר מספר 97.

1617
01:20:47,950 --> 01:20:51,770
אז איזה דפוס של 8 סיביות
מייצג מספר עשרוני 97.

1618
01:20:51,770 --> 01:20:58,070
מהלך סרק 0 זהו פשוטו כמשמעו, את המספר
0, נול המוכר גם בשם, N-U-L, שלא כמו קודם לכן,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, אשר דיברנו.

1620
01:20:59,630 --> 01:21:05,700
אבל לעת עתה, רק יודע שזה
מהלך סרק 0 הוא רק 80 סיביות ברציפות.

1621
01:21:05,700 --> 01:21:09,810
>> וזה בדיוק הקו הזה
חול שאומר דבר שמאלה

1622
01:21:09,810 --> 01:21:12,610
שייך לאחד שרוכים או סוג נתונים אחד.

1623
01:21:12,610 --> 01:21:15,480
וכל דבר ימינה
שייך למשהו אחר.

1624
01:21:15,480 --> 01:21:17,440
אנדי של שם, בינתיים,
אשר רק ויזואלית

1625
01:21:17,440 --> 01:21:21,310
קורה לעטוף על הקו השני,
אבל זה רק פרט אסתטי,

1626
01:21:21,310 --> 01:21:23,990
באופן דומה הוא הופסק נול.

1627
01:21:23,990 --> 01:21:29,290
>> זוהי מחרוזת של תווים A-N-D-I,
בתוספת דמות הסוד חמישית,

1628
01:21:29,290 --> 01:21:33,560
כל 0 ביטים, כי רק תוחם
בסוף השם של אנדי גם כן.

1629
01:21:33,560 --> 01:21:37,120
ואם אנחנו קוראים לקבל מחרוזת בשלישית
במחשב כדי לקבל מחרוזת כמו

1630
01:21:37,120 --> 01:21:44,210
מריה, M-A-R-I-A, באופן דומה הוא של מריה
נול שם הסתיים עם מהלך סרק 0.

1631
01:21:44,210 --> 01:21:47,170
>> זהו ביסודו שונה
מאיך מחשב בדרך כלל יכלול

1632
01:21:47,170 --> 01:21:51,850
לאחסן מספר שלם, או לצוף, או אחר
סוגי נתונים עדיין, כי כזכור,

1633
01:21:51,850 --> 01:21:57,420
שלם הוא בדרך כלל 32 סיביות, או
4 בתים, או אולי אפילו 64 סיביות,

1634
01:21:57,420 --> 01:21:59,100
או שמונה בתים.

1635
01:21:59,100 --> 01:22:02,620
אבל הפרימיטיבים רבים במחשב
בשפת תכנות

1636
01:22:02,620 --> 01:22:05,550
יש מספר קבוע של
בתים מתחת hood--

1637
01:22:05,550 --> 01:22:08,100
אולי 1, אולי 2, אולי 4, אולי 8.

1638
01:22:08,100 --> 01:22:13,250
>> אבל מחרוזות, על ידי עיצוב, יש
מספר דינמי של תווים.

1639
01:22:13,250 --> 01:22:16,980
אתה לא יודע מראש, עד
סוגי האדם Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
או M-A-R-I-A או A-N-D-I. אתה לא יודע
כמה פעמים המשתמש הוא הולך להכות

1641
01:22:21,400 --> 01:22:22,070
המקלדת.

1642
01:22:22,070 --> 01:22:26,490
לכן, אתה לא יודע איך
דמויות רבות מראש

1643
01:22:26,490 --> 01:22:27,540
אתה הולך צריך.

1644
01:22:27,540 --> 01:22:31,840
>> וכך C פשוט סוג של עלים כמו
מיקום באתר סודי מתחת למכסה המנוע

1645
01:22:31,840 --> 01:22:32,960
בסוף המחרוזת.

1646
01:22:32,960 --> 01:22:39,280
לאחר אחסון Z-A-M-Y-L-A בזיכרון,
זה גם רק מוסיף המקבילה

1647
01:22:39,280 --> 01:22:40,210
של תקופה.

1648
01:22:40,210 --> 01:22:45,060
בסוף המשפט,
זה מכניס 80 סיבי, כדי

1649
01:22:45,060 --> 01:22:49,120
לזכור איפה
Zamyla מתחיל ונגמר.

1650
01:22:49,120 --> 01:22:51,490
>> אז מה הקשר,
אז, לתוכנית זו?

1651
01:22:51,490 --> 01:22:55,190
תוכנית זו כאן, סטירלינג,
הוא פשוט מנגנון

1652
01:22:55,190 --> 01:22:57,970
עבור מקבל מחרוזת
מהמשתמש, קו 6.

1653
01:22:57,970 --> 01:23:01,160
שורה 7, אני מכריז על משתנה
קרא n ולהגדיר אותו שווה ל -0.

1654
01:23:01,160 --> 01:23:08,680
>> ואז עולה בקנה אחד 8, רק שאלתי את
שאלה, ואילו דמות n-th עושה

1655
01:23:08,680 --> 01:23:12,120
לא שווה את כל 0 bits--
במילים אחרות, האם לא

1656
01:23:12,120 --> 01:23:14,500
מיוחד שווה זה
אופי, מהלך סרק 0, אשר

1657
01:23:14,500 --> 01:23:18,470
רק היה מיוחד כי character-- נול
קדימה ופשוט להגדיל n.

1658
01:23:18,470 --> 01:23:21,460
>> להמשיך לעשות את זה, ולשמור
עושה את זה, להמשיך לעשות את זה.

1659
01:23:21,460 --> 01:23:23,430
וכך אף ב
בעבר השתמשנו i,

1660
01:23:23,430 --> 01:23:25,181
זה בסדר גמור
סמנטי להשתמש n,

1661
01:23:25,181 --> 01:23:27,430
אם אתה רק מנסה
לספור הפעם בכוונה,

1662
01:23:27,430 --> 01:23:28,720
ואת רק רוצה לקרוא לזה n.

1663
01:23:28,720 --> 01:23:34,720
אז זה פשוט ממשיך לשאול את השאלה,
הוא 0s כל האופי של n-th?

1664
01:23:34,720 --> 01:23:38,470
אם לא, נראה את המראה הבא,
להסתכל למשנהו, להסתכל למשנהו,

1665
01:23:38,470 --> 01:23:39,460
להסתכל למשנהו.

1666
01:23:39,460 --> 01:23:45,540
>> אבל ברגע שאתה רואה מהלך סרק 0,
זה קו loop-- 9 עד 11-- מפסיק.

1667
01:23:45,540 --> 01:23:49,640
אתה לפרוץ את לולאת while,
עוזב בתוך כי n משתנה

1668
01:23:49,640 --> 01:23:54,530
מספר כולל של כל
תווים במחרוזת שראית,

1669
01:23:54,530 --> 01:23:55,660
ובכך להדפיס אותו.

1670
01:23:55,660 --> 01:23:56,760
אז בואו ננסה את זה.

1671
01:23:56,760 --> 01:23:59,500
>> תן לי ללכת קדימה, בלי
באמצעות פונקצית סטירלינג,

1672
01:23:59,500 --> 01:24:04,240
אבל רק באמצעות גרסת תוצרת משלי
סטירלינג שנקרא כאן, תן לי ללכת קדימה

1673
01:24:04,240 --> 01:24:07,700
סטירלינג הפעלה, הקלד במשהו
כמו Zamyla, אשר אני יודע מראש

1674
01:24:07,700 --> 01:24:08,670
הוא שישה תווים.

1675
01:24:08,670 --> 01:24:10,080
בוא נראה אם ​​זה עובד.

1676
01:24:10,080 --> 01:24:10,920
ואכן, זה שש.

1677
01:24:10,920 --> 01:24:15,257
בואו ננסה עם רוב, שלוש דמויות,
שלוש דמויות כמו גם, וכן הלאה.

1678
01:24:15,257 --> 01:24:17,340
אז זה כל מה שקורה כאן
על מתחת למכסה המנוע.

1679
01:24:17,340 --> 01:24:19,548
ושימו לב את החיבורים,
אז, עם השבוע הראשון

1680
01:24:19,548 --> 01:24:22,370
של הכיתה, שם דיברנו על
משהו כמו הפשטה,

1681
01:24:22,370 --> 01:24:26,960
וזה רק שכבות של רעיונות, או
מורכבות, על גבי עקרונות בסיסיים.

1682
01:24:26,960 --> 01:24:30,710
כאן, ואנחנו עוברים למעין מחפשים
מתחת למכסה המנוע של סטירלינג,

1683
01:24:30,710 --> 01:24:33,510
כביכול, כדי להבין,
כיצד ייושם זה?

1684
01:24:33,510 --> 01:24:35,232
>> ויכולנו מחדש ליישם את זה בעצמנו.

1685
01:24:35,232 --> 01:24:37,440
אבל אנחנו לעולם לא הולכים
מחדש ליישם סטירלינג.

1686
01:24:37,440 --> 01:24:39,780
אנחנו פשוט הולכים
להשתמש סטירלינג כדי

1687
01:24:39,780 --> 01:24:42,100
למעשה לקבל קצת אורך מחרוזות.

1688
01:24:42,100 --> 01:24:44,200
>> אבל אין בזה קסם
מתחת למכסה המנוע.

1689
01:24:44,200 --> 01:24:46,716
אם אתה יודע שמתחת
למכסה המנוע, מחרוזת

1690
01:24:46,716 --> 01:24:48,090
רק הוא רצף של תווים.

1691
01:24:48,090 --> 01:24:51,090
ורצף של תווים
כל ניתן לטפל מספרי

1692
01:24:51,090 --> 01:24:53,330
עם סוגר 0, סוגר
1, סוגר 2, ואתה

1693
01:24:53,330 --> 01:24:57,420
יודע כי בסוף המחרוזת היא
תו מיוחד, אתה יכול להבין

1694
01:24:57,420 --> 01:25:01,710
איך לעשות משהו ביותר בתוך
התוכנית, כי כל זה מסתכם

1695
01:25:01,710 --> 01:25:03,400
הוא קריאה וכתיבת זיכרון.

1696
01:25:03,400 --> 01:25:06,130
כלומר, שינוי ומחפשים
בזיכרון, או להזיז דברים

1697
01:25:06,130 --> 01:25:10,940
סביב בזיכרון, דברי הדפסה
על המסך, וכן הלאה.

1698
01:25:10,940 --> 01:25:14,800
>> אז בואו עכשיו להשתמש חדשה זו
הבנה של מה מחרוזות בפועל

1699
01:25:14,800 --> 01:25:17,910
הם מתחת למכסה המנוע, ו
לקלף שכבה אחת אחרת

1700
01:25:17,910 --> 01:25:20,080
כי עד עכשיו יש לנו
מתעלם לגמרי.

1701
01:25:20,080 --> 01:25:22,650
בפרט, בכל עת
מימשנו התוכנית,

1702
01:25:22,650 --> 01:25:25,930
היו לנו את שורת הקוד
סמוך לראש להכריז הראשי.

1703
01:25:25,930 --> 01:25:27,810
ואנחנו שציינו void main int.

1704
01:25:27,810 --> 01:25:31,240
>> ומבוטל כי בתוך הסוגריים
יש אומר כל הזמן הזה כי ראשי

1705
01:25:31,240 --> 01:25:33,440
עצמו אינו לוקח שום טענות.

1706
01:25:33,440 --> 01:25:36,210
כל קלט כי עיקרי הוא
הולך לקבל מהמשתמש

1707
01:25:36,210 --> 01:25:39,020
יש לבוא מכמה אחרים
מנגנון, כמו גט int,

1708
01:25:39,020 --> 01:25:42,040
או לקבל לצוף, או לקבל מחרוזת,
או תפקיד אחר.

1709
01:25:42,040 --> 01:25:44,710
אבל מתברר כי
בעת כתיבת תכנית,

1710
01:25:44,710 --> 01:25:47,690
למעשה אתה יכול לציין
כי תכנית זו תהיה

1711
01:25:47,690 --> 01:25:51,730
לקחת תשומות מן האדם
בשורת הפקודה עצמה.

1712
01:25:51,730 --> 01:25:56,310
>> במילים אחרות, אף על פי שאנו כה
יש כבר פועל רק ./hello שלום

1713
01:25:56,310 --> 01:26:00,312
או תוכניות דומות, כל
תוכניות אחרות כי אנחנו כבר משתמשים,

1714
01:26:00,312 --> 01:26:02,770
שאנחנו עצמנו לא לכתוב,
כבר לוקחים, כך נראה,

1715
01:26:02,770 --> 01:26:05,210
שורת הפקודה arguments--
דברים כמו לעשות.

1716
01:26:05,210 --> 01:26:07,450
אתה אומר משהו כמו איפור,
ואז מילה שנייה.

1717
01:26:07,450 --> 01:26:10,950
או צלצול, אתה אומר להרעיש, ולאחר מכן
מילה שנייה, שם של קובץ.

1718
01:26:10,950 --> 01:26:14,410
>> או אפילו RM או CP, כאילו היה לך
ראו או בשימוש כבר

1719
01:26:14,410 --> 01:26:15,880
להסיר או להעתיק קבצים.

1720
01:26:15,880 --> 01:26:18,920
כל אלה לוקחים מה שנקרא
שורת הפקודה arguments--

1721
01:26:18,920 --> 01:26:21,130
מילים נוספות בשורת סופנית.

1722
01:26:21,130 --> 01:26:23,260
אבל עד עכשיו, אנחנו
עצמנו לא היו

1723
01:26:23,260 --> 01:26:27,080
יוקרה זה לקחת קלט מן
המשתמש כאשר הוא או היא בעצם פועל

1724
01:26:27,080 --> 01:26:29,120
התוכנית עצמה בשורת הפקודה.

1725
01:26:29,120 --> 01:26:33,710
>> אבל אנחנו יכולים לעשות את זה על ידי מחדש המכריז
עיקרי לנוע קדימה, לא כבעל

1726
01:26:33,710 --> 01:26:36,750
לביטול בסוגריים,
אבל שני אלה טיעונים

1727
01:26:36,750 --> 01:26:40,600
instead-- שלם הראשונה,
ושנייה מאוחר יותר

1728
01:26:40,600 --> 01:26:44,170
חדש, משהו שאנחנו הולכים לקרוא
מערך, משהו דומה ברוחה

1729
01:26:44,170 --> 01:26:49,220
למה שראינו ב Scratch כרשימה, אבל
מערך של מחרוזות, כפי שאנו בקרוב לראות.

1730
01:26:49,220 --> 01:26:51,790
אבל בואו לראות זאת על ידי
לשם דוגמא, לפני שאנחנו

1731
01:26:51,790 --> 01:26:53,690
להבחין בדיוק מה זה אומר.

1732
01:26:53,690 --> 01:26:56,520
>> אז אם אני נכנסתי CS50 IDE
כאן, אני כבר הלכתי קדימה

1733
01:26:56,520 --> 01:27:01,840
והכריז בקובץ שנקרא
argv0.c את התבנית הבאה.

1734
01:27:01,840 --> 01:27:04,120
ושימו לב הדבר היחיד
זה שונה עד כה

1735
01:27:04,120 --> 01:27:08,570
הוא שהשתניתי הריק כדי int
מחרוזת argc argv סוגר פתוח, קרוב

1736
01:27:08,570 --> 01:27:09,070
סוֹגֵר.

1737
01:27:09,070 --> 01:27:11,730
ושימו לב לעת עתה, יש
כלום בפנים הגיל האלו.

1738
01:27:11,730 --> 01:27:12,620
>> אין מספר.

1739
01:27:12,620 --> 01:27:15,070
ואין אני, או
n, או כל מכתב אחר.

1740
01:27:15,070 --> 01:27:17,010
אני רק באמצעות
סוגריים מרובעים לעת עתה,

1741
01:27:17,010 --> 01:27:19,510
מסיבות נבוא
חזרה בעוד רגע.

1742
01:27:19,510 --> 01:27:21,330
>> ועכשיו מה אני הולך לעשות הוא זה.

1743
01:27:21,330 --> 01:27:26,680
אם argc שווה שווה 2--
ולהיזכר השווה שווה

1744
01:27:26,680 --> 01:27:30,040
היא המפעילה שוויון השוואה
על ימין ועל שמאל לשוויון.

1745
01:27:30,040 --> 01:27:31,790
זה לא המשימה
מפעיל, שהוא

1746
01:27:31,790 --> 01:27:36,510
סימן השוויון היחיד, כלומר עותק
מימין לערך כמה עזבו.

1747
01:27:36,510 --> 01:27:42,840
>> אם argc שווה שווה 2, אני רוצה
תניח, printf, שלום, אחוזים, קו חדש,

1748
01:27:42,840 --> 01:27:47,340
ולאחר מכן חבר ב-- והנה חדש
סוגר 1 argv trick--, מסיבות

1749
01:27:47,340 --> 01:27:48,840
כי נצטרך לחזור בעוד רגע.

1750
01:27:48,840 --> 01:27:52,110
אחר אם argc לא
2 שווה, אתה יודע מה?

1751
01:27:52,110 --> 01:27:57,400
בואו רק קדימה, כרגיל, הדפסה
מתוך hello world ללא החלפה.

1752
01:27:57,400 --> 01:28:02,710
>> אז זה היה נראה שאם argc, אשר
מייצג במספר הארגומנטים, שווה 2,

1753
01:28:02,710 --> 01:28:04,740
אני הולך להדפיס
שלום דבר זה או אחר.

1754
01:28:04,740 --> 01:28:07,560
אחרת, כברירת מחדל, אני
הולך להדפיס hello world.

1755
01:28:07,560 --> 01:28:08,770
אז מה זה אומר?

1756
01:28:08,770 --> 01:28:15,550
>> ובכן, הרשו לי להמשיך ולשמור
קובץ זה, ולאחר מכן עושה argv0,

1757
01:28:15,550 --> 01:28:18,940
ואז ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
וזה אומר שלום העולם.

1759
01:28:20,300 --> 01:28:21,260
עכשיו, מדוע זה כך?

1760
01:28:21,260 --> 01:28:24,730
>> ובכן, מתברר פעם שאתה
להפעיל תוכנית בשורת הפקודה,

1761
01:28:24,730 --> 01:28:29,570
אתה ממלא מה נעשה
קוראים וקטור טענה כלל.

1762
01:28:29,570 --> 01:28:33,100
במילים אחרות, באופן אוטומטי
מחשב, מערכת ההפעלה,

1763
01:28:33,100 --> 01:28:38,340
הוא הולך למסור לתוכנית שלך
עצם רשימה של כל המילים

1764
01:28:38,340 --> 01:28:40,850
כי האדם מוקלד ב
הבשורה, במקרה שאתה

1765
01:28:40,850 --> 01:28:43,790
המתכנת רוצה לעשות
משהו עם המידע הזה.

1766
01:28:43,790 --> 01:28:48,540
וגם במקרה זה, המילה היחידה
הדפסתי הבשורה הוא ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> וכך מספר הארגומנטים כי הוא
שמועבר התוכנית שלי היא רק אחת.

1768
01:28:55,420 --> 01:28:58,880
במילים אחרות, הטענה
לספור, הידוע גם בכינויו argc

1769
01:28:58,880 --> 01:29:00,970
כאן כמספר שלם, הוא רק אחד.

1770
01:29:00,970 --> 01:29:03,000
אחת, כמובן, לא שווה שתיים.

1771
01:29:03,000 --> 01:29:05,980
וכך זה מה מדפיס, hello world.

1772
01:29:05,980 --> 01:29:08,170
>> אבל תן לי לקחת את זה לאנשהו.

1773
01:29:08,170 --> 01:29:09,930
הרשו לי לומר, argv0.

1774
01:29:09,930 --> 01:29:12,740
ואז מה לגבי מריה?

1775
01:29:12,740 --> 01:29:14,990
ואז על Enter.

1776
01:29:14,990 --> 01:29:18,020
>> ושימו לב מה קסם קורה כאן.

1777
01:29:18,020 --> 01:29:22,640
עכשיו, במקום hello world, יש לי
התנהגות שונה של תוכנית זו

1778
01:29:22,640 --> 01:29:26,310
על ידי לקיחת הקלט לא מן הגט
מחרוזת או תפקיד אחר,

1779
01:29:26,310 --> 01:29:30,570
אלא, ככל הנראה, פיקודי
עצמו, מה אני במקור הקליד.

1780
01:29:30,570 --> 01:29:35,720
ואני יכול לשחק במשחק הזה שוב על ידי
שינוי זה כדי סטליוס, למשל.

1781
01:29:35,720 --> 01:29:38,400
>> ועכשיו אני רואה שם אחר עדיין.

1782
01:29:38,400 --> 01:29:40,540
והנה, אם יורשה לי לומר אנדי.

1783
01:29:40,540 --> 01:29:42,137
ואני יכול להגיד Zamyla.

1784
01:29:42,137 --> 01:29:45,220
ואנחנו יכולים לשחק את המשחק הזה כל היום,
רק חיבור ערכים שונים,

1785
01:29:45,220 --> 01:29:49,550
כל עוד אני מספק בדיוק
שתי מילות בשורה,

1786
01:29:49,550 --> 01:29:52,260
כך argc, הטענה שלי לספור, הוא 2.

1787
01:29:52,260 --> 01:29:57,240
>> האם אני רואה את השם הזה פקוק לתוך
printf, לכל מצב זה כאן?

1788
01:29:57,240 --> 01:30:00,550
אז אנחנו רואים שיש עכשיו
יכולת ההבעה

1789
01:30:00,550 --> 01:30:04,410
לקחת קלט מנגנון אחר,
משורת הפקודה שנקרא,

1790
01:30:04,410 --> 01:30:07,000
ולא צורך להמתין
עד שהמשתמש מפעיל את התכנית,

1791
01:30:07,000 --> 01:30:10,220
ואז להנחות אותו או אותה
באמצעות משהו כמו מחרוזת גט.

1792
01:30:10,220 --> 01:30:11,230
>> אז מה זה?

1793
01:30:11,230 --> 01:30:15,010
Argc, שוב, הוא פשוט מספר שלם,
מספר מילים-- arguments--

1794
01:30:15,010 --> 01:30:18,540
שהמשתמש הניתן
פקודה, ליד חלון המסוף,

1795
01:30:18,540 --> 01:30:20,110
כולל שם של התכנית.

1796
01:30:20,110 --> 01:30:23,340
אז ./argv0 שלנו הוא, ביעילות,
שמו של התוכנית,

1797
01:30:23,340 --> 01:30:24,520
או איך אני מפעיל את התוכנית.

1798
01:30:24,520 --> 01:30:25,810
>> זה נחשב מילה.

1799
01:30:25,810 --> 01:30:27,080
אז argc יהיה 1.

1800
01:30:27,080 --> 01:30:29,750
אבל כשאני כותב סטליוס, או
אנדי, או Zamyla, או מריה,

1801
01:30:29,750 --> 01:30:31,660
זה אומר לספור הטענה היא שני.

1802
01:30:31,660 --> 01:30:33,910
אז עכשיו יש שתי מילים עבר.

1803
01:30:33,910 --> 01:30:36,070
>> ושים לב, שנוכל להמשיך ההיגיון הזה.

1804
01:30:36,070 --> 01:30:39,050
אם אני אומר למעשה
משהו כמו Zamyla צ'אן,

1805
01:30:39,050 --> 01:30:42,200
שם מלא, ובכך עובר
שלוש טענות בסך הכל,

1806
01:30:42,200 --> 01:30:47,410
עכשיו זה אומר ברירת המחדל שוב,
כי, כמובן, 3 לא שווה 2.

1807
01:30:47,410 --> 01:30:54,080
>> וכך, בדרך זו, אני צריך
גישה דרך argv זו טענה חדשה

1808
01:30:54,080 --> 01:30:56,080
כי שיכולנו טכני
קורא כל מה שאנחנו רוצים.

1809
01:30:56,080 --> 01:30:58,940
אבל לפי האמנה, זה
argv ו argc, בהתאמה.

1810
01:30:58,940 --> 01:31:04,470
Argv, וקטור טענה, הוא סוג
של מילה נרדפת תכנות

1811
01:31:04,470 --> 01:31:07,140
תכונה ב- C נקרא מערך.

1812
01:31:07,140 --> 01:31:14,410
>> מערך הוא רשימה של ערכים דומים
בחזרה, לגבות, לגבות, אל גב.

1813
01:31:14,410 --> 01:31:17,810
במילים אחרות, אם אחד הוא ממש כאן
RAM, המאבק הבא הוא ממש ליד זה,

1814
01:31:17,810 --> 01:31:18,800
וממש ליד זה.

1815
01:31:18,800 --> 01:31:20,101
הם לא בכל מקום.

1816
01:31:20,101 --> 01:31:23,100
וזה תרחיש שני, שבו דברים
הם בכל מקום בזיכרון,

1817
01:31:23,100 --> 01:31:25,082
באמת יכול להיות תכונה חזקה.

1818
01:31:25,082 --> 01:31:28,040
אבל נחזור לזה כשאנחנו
לדבר על מבני נתונים להשתכלל.

1819
01:31:28,040 --> 01:31:32,260
לעת עתה, מערך הוא רק
נתח של זיכרון רציף,

1820
01:31:32,260 --> 01:31:36,520
כל אחד מהאלמנטים אשר הם
בחזרה, לגבות, לגבות, לגבות,

1821
01:31:36,520 --> 01:31:38,050
ובאופן כללי מאותו הסוג.

1822
01:31:38,050 --> 01:31:42,630
>> אז אם אתה חושב על, מתוך
לפני רגע, מה היא מחרוזת?

1823
01:31:42,630 --> 01:31:50,460
ובכן, מחרוזת, כמו Zamyla,
Z-A-M-Y-L-A, הוא, מבחינה טכנית,

1824
01:31:50,460 --> 01:31:51,400
רק מערך.

1825
01:31:51,400 --> 01:31:53,700
זה מערך של תווים.

1826
01:31:53,700 --> 01:31:59,250
>> וכך, אם אנחנו באמת לצייר זה, כפי שאני
קודם לכן עשה, כמו נתח של זיכרון,

1827
01:31:59,250 --> 01:32:04,510
מתברר כי כל אחד מאלה
הדמויות תופסת בייט.

1828
01:32:04,510 --> 01:32:07,630
ואז יש את מיוחד
אופי ניטור, הקו הנטוי 0,

1829
01:32:07,630 --> 01:32:12,360
או כל שמונה 0 ביטים, כי
מתחם בסוף אותה המחרוזת.

1830
01:32:12,360 --> 01:32:15,090
אז מחרוזת, מסתבר
החוצה, לצטט מחרוזת סוף ציטוט,

1831
01:32:15,090 --> 01:32:20,580
רק הוא מערך של chara--
char להיות סוג הנתונים בפועל.

1832
01:32:20,580 --> 01:32:24,560
>> ועכשיו argv, meanwhile--
בואו נחזור לתוכנית.

1833
01:32:24,560 --> 01:32:29,582
Argv, למרות שאנחנו רואים את המילה
מחרוזת כאן, אינה מחרוזת עוצמה.

1834
01:32:29,582 --> 01:32:33,640
Argv, וקטור טענה,
הוא מערך של מחרוזות.

1835
01:32:33,640 --> 01:32:37,620
>> אז בדיוק כפי שאתה יכול להיות מערך של
תווים, אתה יכול להיות ברמה גבוהה יותר,

1836
01:32:37,620 --> 01:32:46,279
מערך של: המיתרים כך, למשל,
כאשר הקלדתי רגע לפני ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0,-A Z-M-Y-L-חלל, טענתי
argv היו שתי מחרוזות ב ./argv0 it--,

1838
01:33:00,150 --> 01:33:03,185
ו- Z-A-M-Y-L-A. ב
במילים אחרות, argc היה 2.

1839
01:33:03,185 --> 01:33:03,980
למה זה?

1840
01:33:03,980 --> 01:33:08,370
>> ובכן, באופן יעיל, מה קורה
על הוא שכל אחד מחרוזות אלה

1841
01:33:08,370 --> 01:33:13,990
הוא, כמובן, מערך של תווים
כמו קודם, כל אחד אשר תווים

1842
01:33:13,990 --> 01:33:15,670
תופס בייט אחד.

1843
01:33:15,670 --> 01:33:19,720
ואל תבלבלו את ה -0 בפועל
על שם התוכנית עם 0,

1844
01:33:19,720 --> 01:33:22,040
כלומר כל 80 הבתים.

1845
01:33:22,040 --> 01:33:27,140
ו Zamyla, בינתיים, הוא עדיין
גם מערך של תווים.

1846
01:33:27,140 --> 01:33:31,450
>> אז בסוף היום, זה באמת
נראה כך מתחת למכסה המנוע.

1847
01:33:31,450 --> 01:33:38,800
אבל argv, מטבעו של איך ראשי
עבודות, מאפשרות לי לעטוף את כל זה

1848
01:33:38,800 --> 01:33:44,810
למעלה לתוך, אם תרצה, מערך גדול
כי, אם אנחנו מעט מעל לפשט

1849
01:33:44,810 --> 01:33:48,180
מה התמונה נראית כמו ולעשות לא
לצייר את זה די בהיקף של עד שם,

1850
01:33:48,180 --> 01:33:56,720
מערך זה הוא רק בגודל 2, הראשון
אלמנט אחד מהם מכיל מחרוזת,

1851
01:33:56,720 --> 01:33:59,230
המרכיב השני של
המכיל מחרוזת.

1852
01:33:59,230 --> 01:34:01,687
וזה, בתורו, אם אתה
סוג של קרב על כל

1853
01:34:01,687 --> 01:34:03,770
של המיתרים הללו, מה אתה
לראות מתחת למכסה המנוע

1854
01:34:03,770 --> 01:34:07,190
מחרוזת הוא כי כל אחד מהם היא רק
מערך של תווים.

1855
01:34:07,190 --> 01:34:11,680
>> עכשיו, בדיוק כמו עם מחרוזות,
הצלחנו לקבל גישה

1856
01:34:11,680 --> 01:34:15,260
לאופי-ה i במחרוזת
באמצעות כי בסימון סוגר מרובע.

1857
01:34:15,260 --> 01:34:17,320
באופן דומה, עם מערכים
בכלל, אנחנו יכולים

1858
01:34:17,320 --> 01:34:22,700
להשתמש בסימון סוגר מרובע לקבל
בכל מספר המחרוזות במערך?

1859
01:34:22,700 --> 01:34:25,100
למשל, תן לי
אתם מוזמנים לעשות זאת.

1860
01:34:25,100 --> 01:34:32,420
>> תן לי להמשיך וליצור argv1.c,
וזה קצת שונה הפעם.

1861
01:34:32,420 --> 01:34:35,635
במקום בדיקת argc2,
אני הולך במקום לעשות זאת.

1862
01:34:35,635 --> 01:34:41,270
עבור int אני מקבל 0, אני נמצא במרחק של פחות
מ argc, אני פלוס פלוס,

1863
01:34:41,270 --> 01:34:47,920
ואז להדפיס את החלק הפנימי של זה,
ימי אחוזים, קו חדש, ולאחר מכן

1864
01:34:47,920 --> 01:34:50,740
argv סוגר i.

1865
01:34:50,740 --> 01:34:55,220
>> אז במילים אחרות, אני לא עושה עסקים עם
תווים בודדים כרגע.

1866
01:34:55,220 --> 01:35:00,190
Argv, כפי שמשתמע ריבוע ריק אלה
כתפיות ימינה של argv שם,

1867
01:35:00,190 --> 01:35:03,320
פירושו argv הוא מערך של מחרוזות.

1868
01:35:03,320 --> 01:35:04,870
ו argc הוא רק int.

1869
01:35:04,870 --> 01:35:08,800
>> הקו הזה כאן, 6, הוא
אומר ואינדינ שווה ל -0.

1870
01:35:08,800 --> 01:35:11,980
לספור את כל הדרך עד,
אבל לא כולל, argc.

1871
01:35:11,980 --> 01:35:14,010
ואז על כל איטרציה,
להדפיס מחרוזת.

1872
01:35:14,010 --> 01:35:14,800
מה חבל?

1873
01:35:14,800 --> 01:35:17,270
>> מחרוזת i-th argv.

1874
01:35:17,270 --> 01:35:19,530
אז בעוד לפני שהייתי
באמצעות סוגר מרובע

1875
01:35:19,530 --> 01:35:22,180
הכיתוב כדי להגיע לחקר ה- i
אופי במחרוזת, עכשיו

1876
01:35:22,180 --> 01:35:27,240
אני משתמש בסימון סוגר מרובע
כדי להגיע לחקר מחרוזת ה- i במערך.

1877
01:35:27,240 --> 01:35:30,310
אז זה סוג של שכבה אחת
לעיל, מושגית.

1878
01:35:30,310 --> 01:35:35,390
>> וכך מה מסודר על זה
תוכנית עכשיו, אם אני לקמפל argv1,

1879
01:35:35,390 --> 01:35:42,067
ולאחר מכן לעשות ./argv1, ולאחר מכן הקלד
במשהו כמו באז foo בר,

1880
01:35:42,067 --> 01:35:45,400
שהן שלוש מילים מחדל כי
מדען המחשב מגיע לכל זמן

1881
01:35:45,400 --> 01:35:51,010
הוא או היא צריכה כמה מילים מציין מיקום,
והקש Enter, כל המילים האלה,

1882
01:35:51,010 --> 01:35:54,980
כולל שם של התכנית, אשר
ב argv הוא במיקום הראשון,

1883
01:35:54,980 --> 01:35:58,320
בסופו להיות מודפס אחד בכל פעם.

1884
01:35:58,320 --> 01:36:05,290
ואם אני משנה את זה, אני אומר
משהו כמו argv1 Zamyla צ'אן,

1885
01:36:05,290 --> 01:36:08,800
אנחנו מקבלים את כל שלושת אלה
מילים, וזה argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, כי זה
argc במקרה, הספירה, הוא 3.

1887
01:36:14,400 --> 01:36:20,020
>> אבל מה מסודר הוא אם אתה מבין
argv כי הוא פשוט מערך של מחרוזות,

1888
01:36:20,020 --> 01:36:24,910
ואתה מבין כי מחרוזת
הוא מערך של תווים,

1889
01:36:24,910 --> 01:36:29,470
אנחנו יכולים בעצם סוג של משתמש זה
בסימון סוגר מרובע מספר פעמים

1890
01:36:29,470 --> 01:36:33,320
לבחור מחרוזת, ולאחר מכן לבחור
דמות בתוך המחרוזת,

1891
01:36:33,320 --> 01:36:35,730
צלילה עמוקה כדלקמן.

1892
01:36:35,730 --> 01:36:40,100
בדוגמה זו, תן לי ללכת
קדימה ולקרוא argv2.c זה.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
ו בדוגמה זו, תן לי ללכת קדימה
ולעשות את following-- עבור int אני מקבל 0,

1895
01:36:50,180 --> 01:36:53,286
אני הוא פחות מ argc, אני פלוס
בתוספת, בדיוק כמו לפני.

1896
01:36:53,286 --> 01:36:55,910
אז מילים-- אחר ועכשיו זה
הוא מקבל מסובך מספיק.

1897
01:36:55,910 --> 01:36:59,940
אז אני הולך להגיד
לחזר על מחרוזות ב argv,

1898
01:36:59,940 --> 01:37:01,294
כהערה לעצמי.

1899
01:37:01,294 --> 01:37:03,960
ואז אני הולך להיות
מקוננים על לולאה, אשר אתה בטח

1900
01:37:03,960 --> 01:37:06,290
עשו, או נחשב
עושה, גרד, שם

1901
01:37:06,290 --> 01:37:08,600
אני הולך לומר int-- אני
לא הולך להשתמש אני שוב,

1902
01:37:08,600 --> 01:37:12,590
כי אני לא רוצה צל, או
מעין לדרוס את i הקיים.

1903
01:37:12,590 --> 01:37:15,780
>> אני הולך, במקום, אומר j, כי
כי ילך שלי משתנה אחרי שאני,

1904
01:37:15,780 --> 01:37:18,590
כשאני רק מנסה
לספור מספרים פשוטים.

1905
01:37:18,590 --> 01:37:28,850
עבור j מקבל 0-- וגם, n, הולך
לקבל את אורך שטרן סוגר argv אני,

1906
01:37:28,850 --> 01:37:36,030
כל עוד j הוא פחות מ,
j פלוס פלוס, לבצע את הפעולות הבאות.

1907
01:37:36,030 --> 01:37:37,500
והנה החלק המעניין.

1908
01:37:37,500 --> 01:37:46,330
>> הדפס את אופי שורה חדשה,
חיבור סוגר argv i, סוגר j.

1909
01:37:46,330 --> 01:37:47,940
אוקיי, אז הרשו לי להוסיף כמה הערות כאן.

1910
01:37:47,940 --> 01:37:54,820
לחזר על תווים
במחרוזת הנוכחית,

1911
01:37:54,820 --> 01:38:02,290
אופי j-ה הדפסה במחרוזת i-ה.

1912
01:38:02,290 --> 01:38:04,630
אז עכשיו, הבה נבחן
מה ההערות האלה אומרים.

1913
01:38:04,630 --> 01:38:06,750
>> לחזר על מחרוזות
ב argv-- כמה

1914
01:38:06,750 --> 01:38:09,300
מחרוזות נמצאות argv, שהוא מערך?

1915
01:38:09,300 --> 01:38:13,420
Argc רב, אז אני iterating
מ i שווה 0 עד argc.

1916
01:38:13,420 --> 01:38:20,020
בינתיים, כמה תווים
הם במחרוזת i-th argv?

1917
01:38:20,020 --> 01:38:22,880
>> ובכן, כדי לענות על השאלה הזאת,
אני פשוט קורא מחרוזת באורך

1918
01:38:22,880 --> 01:38:26,810
על הטיפול שאני מחרוזת הנוכחית
עליו, שהוא argv סוגר i.

1919
01:38:26,810 --> 01:38:30,090
ואני הולך לאחסן באופן זמני כי
ערך n, רק למטרות במטמון,

1920
01:38:30,090 --> 01:38:31,590
לזכור את זה במונחים של יעילות.

1921
01:38:31,590 --> 01:38:36,330
ואז אני הולך לאתחל j ל -0,
להמשיך כל עוד j הוא פחות מ n,

1922
01:38:36,330 --> 01:38:38,430
ועל כל j איטרציה תוספת.

1923
01:38:38,430 --> 01:38:41,030
>> ואז כאן, לכל
ההערה שלי על קו 12,

1924
01:38:41,030 --> 01:38:43,390
להדפיס את דמות,
ואחריו בשורה חדשה,

1925
01:38:43,390 --> 01:38:48,140
סוגר argv במיוחד
אני נותן לי את מחרוזת i-ה

1926
01:38:48,140 --> 01:38:51,690
ב כך argv-- המילה הראשונה,
מילה שנייה, המלה השלישית, מה שלא יהיה.

1927
01:38:51,690 --> 01:38:57,370
ואז צולל j עמוק יותר, ומקבל
לי דמות j-th של המילה הזאת.

1928
01:38:57,370 --> 01:39:02,200
וכך, למעשה, ניתן לטפל
argv בתור רב ממדים,

1929
01:39:02,200 --> 01:39:06,050
כמערך דו-ממדי,,
לפיה כל סוג מילה של מראה

1930
01:39:06,050 --> 01:39:08,580
ככה במוחו של שלך
עין, וכל תו

1931
01:39:08,580 --> 01:39:10,930
סוג של מורכב ב
טור, אם זה עוזר.

1932
01:39:10,930 --> 01:39:13,260
>> במציאות, כאשר אנו להקניט
זה מזה בשבועות בעתיד,

1933
01:39:13,260 --> 01:39:15,580
זה הולך להיות קצת
יותר מתוחכם מזה.

1934
01:39:15,580 --> 01:39:17,800
אבל אתה יכול באמת
לחשוב על זה, לעת עתה,

1935
01:39:17,800 --> 01:39:22,110
בתור סתם דו מימדי זה
מערך, לפיה רמה אחת של זה

1936
01:39:22,110 --> 01:39:23,260
כל הוא של המיתרים.

1937
01:39:23,260 --> 01:39:26,760
ואז אם אתה לצלול עמוק יותר, אתה
יכול לקבל על התווים הבודדים

1938
01:39:26,760 --> 01:39:29,600
בה באמצעות בסימון זה כאן.

1939
01:39:29,600 --> 01:39:31,620
>> אם כן, מהי ההשפעה נטו?

1940
01:39:31,620 --> 01:39:34,970
תן לי ללכת קדימה
להפוך argv2-- לעזאזל.

1941
01:39:34,970 --> 01:39:36,210
עשיתי טעות כאן.

1942
01:39:36,210 --> 01:39:40,160
במשתמע המכריז על
סטירלינג פונקציה הספרייה.

1943
01:39:40,160 --> 01:39:42,190
אז כל הזמן הזה, זה
אולי מתאים

1944
01:39:42,190 --> 01:39:45,130
שאנחנו סוג של גמר
בדיוק לנקודה שבה התחלנו.

1945
01:39:45,130 --> 01:39:48,160
>> אני דפוק, במשתמע להכריז
סטירלינג פונקציה הספרייה.

1946
01:39:48,160 --> 01:39:48,987
בסדר, חכה רגע.

1947
01:39:48,987 --> 01:39:51,070
אני זוכר את זה, במיוחד
מאז שזה צריך להימצא כאן.

1948
01:39:51,070 --> 01:39:54,490
אני צריך לכלול string.h ב
בגירסה זו של התוכנית.

1949
01:39:54,490 --> 01:40:00,050
>> תן לי ללכת קדימה ולכלול
string.h, שמור את זה, קדימה

1950
01:40:00,050 --> 01:40:04,460
ו קומפילציה argv2.

1951
01:40:04,460 --> 01:40:08,390
ועכשיו, הנה זה בא, לעשות argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
ואף על פי שזה קצת
נסתר במבט ראשון,

1953
01:40:10,590 --> 01:40:15,690
להבחין כי, אכן, מה
מודפס הוא argv2 נקודה.

1954
01:40:15,690 --> 01:40:19,970
>> אבל אם אני מקליד כמה מילים לאחר
הפקודה, כמו argv2 Zamyla צ'אן,

1955
01:40:19,970 --> 01:40:22,560
זן, גם קצת
נסתר במבט ראשון.

1956
01:40:22,560 --> 01:40:30,540
אבל אם אנחנו לגלול חזרה למעלה,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
אז אנחנו כבר איטרטיבית על כל מלה.

1958
01:40:32,190 --> 01:40:37,770
וזה, בתורו, שמנו iterated מעל
כל דמות בתוך מילה.

1959
01:40:37,770 --> 01:40:40,040
>> עכשיו, אחרי כל זה,
קולט שיש

1960
01:40:40,040 --> 01:40:43,120
אחד פרט אחר היינו סוג
של התעלמות זה כל הזמן.

1961
01:40:43,120 --> 01:40:46,180
אנחנו פשוט התגרו בנפרד מה
יכולה להיות תשומות ראשיות?

1962
01:40:46,180 --> 01:40:47,780
מה לגבי הפלט של ראשי?

1963
01:40:47,780 --> 01:40:50,540
>> כל הזמן הזה, היינו
רק העתקה והדבקה

1964
01:40:50,540 --> 01:40:53,870
המילה int מול עיקרי,
אם כי תוכלו לראות באינטרנט,

1965
01:40:53,870 --> 01:40:58,340
לפעמים שגוי בגירסאות ישנות יותר
של C מהדרים, כי הם אומרים הריק,

1966
01:40:58,340 --> 01:40:59,410
או בכלל לא.

1967
01:40:59,410 --> 01:41:01,580
אבל, אכן, עבור הגרסה
של C שבו אנו משתמשים,

1968
01:41:01,580 --> 01:41:06,180
C 11, או 2011, לממש
כי זה צריך להיות int.

1969
01:41:06,180 --> 01:41:09,300
וזה צריך להיות או
חלל או argc ו argv כאן.

1970
01:41:09,300 --> 01:41:10,790
>> אבל למה int main?

1971
01:41:10,790 --> 01:41:12,480
מה זה באמת מחזיר?

1972
01:41:12,480 --> 01:41:16,280
ובכן, מתברר כל הזמן הזה,
בכל פעם שאתה כבר כתבת ראשית של תכנית

1973
01:41:16,280 --> 01:41:18,440
תמיד חוזר משהו.

1974
01:41:18,440 --> 01:41:19,960
אבל היא עושה זאת בסתר.

1975
01:41:19,960 --> 01:41:23,350
>> המשהו הזה הוא
int, כמו קו 5 מרמז.

1976
01:41:23,350 --> 01:41:24,225
אבל מה int?

1977
01:41:24,225 --> 01:41:26,100
ובכן, יש את זה
כנס בתכנות,

1978
01:41:26,100 --> 01:41:29,790
לפיה אם דבר יש
השתבש הכל טוב,

1979
01:41:29,790 --> 01:41:34,250
תוכניות ופונקציות בדרך כלל
return-- מעט counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 בדרך כלל מסמל הכל טוב.

1982
01:41:38,070 --> 01:41:40,610
לכן, למרות שאתה חושב
זה כמו שווא בהקשרים רבים,

1983
01:41:40,610 --> 01:41:42,930
זה באמת פירושה בדרך כלל דבר טוב

1984
01:41:42,930 --> 01:41:49,560
>> בינתיים, אם תוכנית מחזירה 1,
או 1, או 5 שליליים, או 42 שליליים,

1985
01:41:49,560 --> 01:41:52,941
או כל ערך אחר שאינו 0,
שמשמעותו בדרך כלל

1986
01:41:52,941 --> 01:41:54,190
משהו השתבש.

1987
01:41:54,190 --> 01:41:56,700
למעשה, בעצמך Mac או PC,
ייתכן היה אפשר ממש לראות

1988
01:41:56,700 --> 01:42:01,050
הודעת שגיאה על פיה
אומרת דבר זה או אחר, שגיאה

1989
01:42:01,050 --> 01:42:04,940
קוד 42, או שגיאה שלילית
23, או משהו כזה.

1990
01:42:04,940 --> 01:42:08,980
מספר זה הוא בדרך כלל רק רמז
אל המתכנת, או החברה

1991
01:42:08,980 --> 01:42:11,174
שגרם תוכנה,
מה השתבש ומדוע,

1992
01:42:11,174 --> 01:42:13,590
כדי שיוכלו להסתכל דרך
תיעוד או הקוד שלהם,

1993
01:42:13,590 --> 01:42:15,465
להבין מה
שגיאה בעצם אומרת.

1994
01:42:15,465 --> 01:42:18,400
זה בדרך כלל לא
שימושי לנו למשתמשי קצה.

1995
01:42:18,400 --> 01:42:20,550
>> אבל כאשר תשואות עיקריות 0, הכל טוב.

1996
01:42:20,550 --> 01:42:23,770
ואם לא תציין
מה ראשי צריך לחזור,

1997
01:42:23,770 --> 01:42:26,950
זה יהיה רק ​​באופן אוטומטי
לחזור 0 בשבילך.

1998
01:42:26,950 --> 01:42:30,870
אבל חוזר משהו
אחר הוא ממש שימושי.

1999
01:42:30,870 --> 01:42:34,660
>> בתכנית סופית זה, תן לי
אתם מוזמנים לקרוא exit.c זה,

2000
01:42:34,660 --> 01:42:38,630
ולהציג את האחרון של היום
נושאים, המכונים קוד שגיאה.

2001
01:42:38,630 --> 01:42:42,930
תן לי ללכת קדימה ולכלול שלנו
קבצים למעלה מוכרים, לעשות ראשיים int.

2002
01:42:42,930 --> 01:42:49,500
והפעם, בוא נעשה int argc,
argv מחרוזת, ועם בסוגריים שלי

2003
01:42:49,500 --> 01:42:50,836
לרמוז שזה במערך.

2004
01:42:50,836 --> 01:42:52,460
ואז הם נתנו לי רק לבצע בדיקה בסיסית.

2005
01:42:52,460 --> 01:42:56,640
הפעם, אם argc לא
2 שווה, אז אתה יודע מה?

2006
01:42:56,640 --> 01:42:57,520
שכח מזה.

2007
01:42:57,520 --> 01:43:03,170
אני הולך להגיד את זה, היי, משתמשים,
אתה חסר ארגומנט שורת הפקודה

2008
01:43:03,170 --> 01:43:04,210
n לוכסן אחורי.

2009
01:43:04,210 --> 01:43:05,230
>> ואז זהו זה.

2010
01:43:05,230 --> 01:43:06,130
אני רוצה לצאת.

2011
01:43:06,130 --> 01:43:11,030
אני הולך מנע,
בטרם עת ממש, השיבה

2012
01:43:11,030 --> 01:43:12,810
משהו אחר מאשר מספר 1.

2013
01:43:12,810 --> 01:43:15,360
תוך כדי תנועה לשווי עבור הראשון
שגיאה שיכול לקרות היא 1.

2014
01:43:15,360 --> 01:43:17,860
אם יש לך כמה אחרים שגויים
מצב שעלול להתרחש,

2015
01:43:17,860 --> 01:43:21,390
אפשר לומר חזרה 2 או לחזור 3, או
אולי אפילו שלילי 1 או 2 שליליים.

2016
01:43:21,390 --> 01:43:23,750
>> אלה הם רק קודי יציאה
כי הם, בדרך כלל,

2017
01:43:23,750 --> 01:43:27,770
רק שימושי המתכנת, או
חברה זה משלוח התוכנה.

2018
01:43:27,770 --> 01:43:30,500
אבל העובדה שזה
לא 0 הוא מה שחשוב.

2019
01:43:30,500 --> 01:43:34,310
אז אם בתכנית זו, אני רוצה
להבטיח כי תוכנית זו רק

2020
01:43:34,310 --> 01:43:38,190
עובד אם המשתמש מספק אותי
עם ספירת טיעון של השני,

2021
01:43:38,190 --> 01:43:42,880
השם של התוכנית, וכמה אחרים
מילה, אני יכול לאכוף ככל כדלקמן,

2022
01:43:42,880 --> 01:43:46,110
לצעוק את המשתמש עם אמרת printf,
חסר ארגומנט שורת הפקודה,

2023
01:43:46,110 --> 01:43:46,970
לחזור 1.

2024
01:43:46,970 --> 01:43:49,940
זה יהיה רק ​​מיד
יציאה מהתוכנית.

2025
01:43:49,940 --> 01:43:55,840
>> רק אם argc שווה 2 נגיע למטה
כאן, אבל בכל מקרה אני הולך להגיד,

2026
01:43:55,840 --> 01:44:00,410
שלום s אחוזים, מהלך סרק n, argv1.

2027
01:44:00,410 --> 01:44:03,827
במילים אחרות, אני
לא הולך אחרי argv 0,

2028
01:44:03,827 --> 01:44:05,410
וזה רק השם של התוכנית.

2029
01:44:05,410 --> 01:44:09,450
אני רוצה להדפיס שלום, פסיק,
המילה השנייה כי האדם מוקלד.

2030
01:44:09,450 --> 01:44:12,580
וגם במקרה זה על
קו 13, הכל טוב.

2031
01:44:12,580 --> 01:44:15,920
>> אני יודע argc הוא 2
הגיוני מתוכנית זו.

2032
01:44:15,920 --> 01:44:17,770
אני הולך קדימה ולחזור 0.

2033
01:44:17,770 --> 01:44:21,230
במאמר מוסגר, יש לזכור כי
זה נכון Scratch גם כן.

2034
01:44:21,230 --> 01:44:24,760
>> מבחינה הגיונית, אני יכול לעשות את זה
ויעטוף שורות אלה

2035
01:44:24,760 --> 01:44:27,020
קוד בסעיף אחר זה כאן.

2036
01:44:27,020 --> 01:44:29,420
אבל זה סוג של
זחת הקוד שלי שלא לצורך.

2037
01:44:29,420 --> 01:44:31,800
ואני רוצה לעשות סופר
ברור כי לא משנה מה,

2038
01:44:31,800 --> 01:44:34,670
כברירת מחדל, שלום
משהו יקבל מודפס,

2039
01:44:34,670 --> 01:44:36,050
כל עוד המשתמש משתף פעולה.

2040
01:44:36,050 --> 01:44:39,360
>> אז זה נפוץ מאוד להשתמש
מצב, רק אם,

2041
01:44:39,360 --> 01:44:41,870
לתפוס כמה שגוי
מצב, ולאחר מכן יציאה.

2042
01:44:41,870 --> 01:44:45,690
ואז, כל עוד הכל
טוב, לא להיות אחר,

2043
01:44:45,690 --> 01:44:48,060
אבל רק צריך את הקוד
מחוץ שאם, כי זה

2044
01:44:48,060 --> 01:44:51,060
מקבילה זו
במקרה מסוים, באופן הגיוני.

2045
01:44:51,060 --> 01:44:54,480
אז אני מחזיר 0, רק כדי
במפורש לסמן שהכל בסדר.

2046
01:44:54,480 --> 01:44:58,480
>> אם השמטתי את התשואה 0, זה היה
יש להניח באופן אוטומטי בשבילי.

2047
01:44:58,480 --> 01:45:00,890
אבל עכשיו, אני מחזיר
אחד לפחות במקרה הזה,

2048
01:45:00,890 --> 01:45:04,940
אני הולך, למען הסדר הטוב ואת
בהירות, לחזור 0 במקרה זה.

2049
01:45:04,940 --> 01:45:09,690
אז עכשיו תן לי ללכת קדימה ולעשות יציאה,
שהינה segue מושלמת פשוט לעזוב.

2050
01:45:09,690 --> 01:45:14,401
>> אבל לעשות יציאה, ותן לי ללכת
קדימה ולעשות ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
והתכנית צעקה עליי,
חסר ארגומנט שורת הפקודה.

2052
01:45:16,900 --> 01:45:18,120
אישור, תן לי לשתף פעולה.

2053
01:45:18,120 --> 01:45:23,810
>> תן לי במקום לעשות ./exit, דוד, Enter.

2054
01:45:23,810 --> 01:45:25,190
ועכשיו זה אומר, שלום דוד.

2055
01:45:25,190 --> 01:45:27,300
ואתה בדרך כלל לא רואה את זה.

2056
01:45:27,300 --> 01:45:30,650
>> אבל מתברר שיש
דרך מיוחדת לינוקס ממש לראות

2057
01:45:30,650 --> 01:45:34,470
עם מה יציאת קוד תכנית יצאה.

2058
01:45:34,470 --> 01:45:37,184
לפעמים בתוך גרפי
עולם כמו Mac OS או Windows,

2059
01:45:37,184 --> 01:45:40,100
אתה רק רואה את המספרים האלה כאשר
הודעת שגיאה צצה על המסך

2060
01:45:40,100 --> 01:45:41,940
ואת המתכנת
מראה לך את המספר הזה.

2061
01:45:41,940 --> 01:45:44,773
אבל אם אנחנו רוצים לראות מה השגיאה
המסר הוא, אנחנו יכולים לעשות את זה כאן--

2062
01:45:44,773 --> 01:45:48,100
כך ./exit, זן, להדפיס
חסר ארגומנט שורת הפקודה.

2063
01:45:48,100 --> 01:45:54,590
>> אם אני עכשיו לעשות $ הד ?, שהוא
גיחוך נסתר למראה.

2064
01:45:54,590 --> 01:45:56,590
אבל $?

2065
01:45:56,590 --> 01:45:59,220
הוא לחש קסום
שאומר, היי, מחשב,

2066
01:45:59,220 --> 01:46:01,900
תגיד לי מה הקודם
הקוד של יציאת התכנית היה.

2067
01:46:01,900 --> 01:46:03,410
ואני על Enter.

2068
01:46:03,410 --> 01:46:07,520
אני רואה 1, כי זה מה שאני
אמר הפונקציה העיקרית שלי לחזור.

2069
01:46:07,520 --> 01:46:12,310
>> בינתיים, אם אני עושה ./exit דוד,
והקש Enter, אני רואה, שלום דוד.

2070
01:46:12,310 --> 01:46:16,800
ואם אני כותב עכשיו לעשות $ הד ?, אני רואה שלום 0.

2071
01:46:16,800 --> 01:46:19,080
וכך זה יהיה ממש
להיות מידע בעל ערך

2072
01:46:19,080 --> 01:46:23,420
בהקשר של הבאגים, לא כל כך
הרבה שאתם, אדם, היה אכפת.

2073
01:46:23,420 --> 01:46:26,060
אבל הבאגים ואחרים
תוכניות נשתמש בסמסטר הזה

2074
01:46:26,060 --> 01:46:29,420
לעתים קרובות יסתכל המספר הזה,
למרות שזה סוג של חבוי

2075
01:46:29,420 --> 01:46:32,780
אלא אם אתה מסתכל על זה, כדי
לקבוע אם או לא תוכנית של

2076
01:46:32,780 --> 01:46:37,050
הביצוע היה נכון או שגוי.

2077
01:46:37,050 --> 01:46:40,450
>> וכך זה מביא אותנו
זה, בסוף היום.

2078
01:46:40,450 --> 01:46:43,917
התחלנו היום ע"י הסתכלות
באגים, ו בתורו במשך הקורס

2079
01:46:43,917 --> 01:46:46,750
עצמו, ולאחר מכן יותר מעניין,
מבחינה טכנית מתחת למכסה המנוע

2080
01:46:46,750 --> 01:46:49,490
ובאיזה מייתרים הם, אשר לאחרונה
שבוע אנחנו פשוט לקחנו כמובנת מאליה,

2081
01:46:49,490 --> 01:46:51,900
ובוודאי לקח אותם
מאליו Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> לאחר מכן הסתכלנו איך אנחנו יכולים לגשת
תווים בודדים במחרוזת,

2083
01:46:56,040 --> 01:47:00,310
ואז שוב לקח רמה גבוהה יותר
להסתכל על הדברים, מסתכל איך well--

2084
01:47:00,310 --> 01:47:04,226
אם אנחנו רוצים להגיע פרט
גורמים ברשימה כמו מבנה,

2085
01:47:04,226 --> 01:47:05,850
אנחנו לא יכולים לעשות את זה עם מחרוזות מרובות?

2086
01:47:05,850 --> 01:47:08,050
ואנחנו יכולים עם הארגומנטים של שורת הפקודה.

2087
01:47:08,050 --> 01:47:12,800
אבל התמונה הזאת כאן רק תיבות
הוא מופגן של הרעיון הכללי הזה

2088
01:47:12,800 --> 01:47:14,451
של מערך, או רשימה, או וקטור.

2089
01:47:14,451 --> 01:47:16,450
וזה תלוי
בהקשר, כל המילים האלה

2090
01:47:16,450 --> 01:47:17,880
אומר דברים שונים במקצת.

2091
01:47:17,880 --> 01:47:20,060
אז ב- C, אנחנו רק הולכים
לדבר על מערך.

2092
01:47:20,060 --> 01:47:23,840
ואת מערך הוא נתח
של זיכרון, שכל אחד מהם זה

2093
01:47:23,840 --> 01:47:27,720
היסודות הם רציפים, גב,
אל גב, אל גב, אל גב.

2094
01:47:27,720 --> 01:47:31,970
>> וגם אלה הם מרכיבים, בדרך כלל,
מאותו סוג הנתונים, אופי,

2095
01:47:31,970 --> 01:47:35,966
אופי, אופי, אופי, או
מחרוזת, מחרוזת, מחרוזת, מחרוזת, או int,

2096
01:47:35,966 --> 01:47:38,600
int, int, מה שזה לא יהיה
אנחנו מנסים חנות.

2097
01:47:38,600 --> 01:47:42,540
אבל בסוף היום, זה
איך זה נראה מושגית.

2098
01:47:42,540 --> 01:47:44,530
אתה לוקח שלך
זיכרון או זיכרון RAM של המחשב.

2099
01:47:44,530 --> 01:47:48,590
ואתה גילוף אותו החוצה אל
תיבות זהים בגודלם, שכולן

2100
01:47:48,590 --> 01:47:50,920
חזור, לגבות, כדי
בחזרה, כדי לגבות בדרך זו.

2101
01:47:50,920 --> 01:47:53,200
>> ומה שיפה
הרעיון הזה, והעובדה

2102
01:47:53,200 --> 01:47:58,580
שנוכל לבטא ערכים בדרך זו
עם הראשון של מבני הנתונים שלנו

2103
01:47:58,580 --> 01:48:02,520
בכיתה, אומר שאנחנו יכולים להתחיל
לפתור בעיות עם קוד

2104
01:48:02,520 --> 01:48:04,079
כי בא כל כך אינטואיטיבי בשבוע 0.

2105
01:48:04,079 --> 01:48:05,870
אתם בוודאי זוכרים את הטלפון
ספר למשל, שם

2106
01:48:05,870 --> 01:48:09,110
השתמשנו הפרד ומשול,
או חיפוש בינארי,

2107
01:48:09,110 --> 01:48:13,220
לנפות כולה
חבורה של שמות ומספרים.

2108
01:48:13,220 --> 01:48:18,220
אבל הנחנו, כזכור, כי
ספר טלפונים כבר מסודר,

2109
01:48:18,220 --> 01:48:21,630
שמישהו היה אחר כבר
הבנתי נתון out-- רשימת השמות

2110
01:48:21,630 --> 01:48:24,430
ו numbers-- איך לסדר אותם לפי האלפבית.

2111
01:48:24,430 --> 01:48:26,950
ועכשיו, ב- C אנו,
מדי, יש את היכולת

2112
01:48:26,950 --> 01:48:30,290
להניח את הדברים, לא
פיזית ספר טלפונים

2113
01:48:30,290 --> 01:48:34,220
אבל כמעט במחשב של
זיכרון, אהיה בשבוע הבא מסוגל

2114
01:48:34,220 --> 01:48:38,470
להציג שוב זה- הראשון
של מבני הנתונים שלנו בתוך array--

2115
01:48:38,470 --> 01:48:43,530
אבל יותר חשוב, מחשב בפועל
אלגוריתמי מדע מיושמים

2116
01:48:43,530 --> 01:48:47,720
בקוד, שבו אנו יכולים לאחסן
נתונים במבנים כזה,

2117
01:48:47,720 --> 01:48:50,730
ולאחר מכן להתחיל לתפעל אותו,
למעשה לפתור בעיות עם זה,

2118
01:48:50,730 --> 01:48:53,570
וכדי לבנות על גבי זה,
בסופו של דבר, תוכניות ב- C,

2119
01:48:53,570 --> 01:48:56,730
בפייתון, ב- JavaScript,
שאילתות מסדי נתונים עם SQL?

2120
01:48:56,730 --> 01:48:59,980
>> ונראה כי כל אלה
רעיונות שונים משתלבים.

2121
01:48:59,980 --> 01:49:04,100
אבל לעת עתה, זוכר כי
תחום שבו הצגנו היום

2122
01:49:04,100 --> 01:49:06,920
היה את הדבר הזה כאן,
העולם של קריפטוגרפיה.

2123
01:49:06,920 --> 01:49:11,200
ובין הבעיות הבאות שאתה עצמך
יפתור היא אמנות קריפטוגרפיה,

2124
01:49:11,200 --> 01:49:13,630
ערבול ודה-ערבול
מידע, הצפנה

2125
01:49:13,630 --> 01:49:15,930
ופענוח טקסט,
ובהנחה בסופו של דבר

2126
01:49:15,930 --> 01:49:18,970
כי עכשיו אתה יודע מה
הוא מתחת למכסה המנוע

2127
01:49:18,970 --> 01:49:21,860
כך שכאשר אתה רואה או לקבל
הודעה כזאת, אתה

2128
01:49:21,860 --> 01:49:24,060
עצמך יכול לפענח אותו.

2129
01:49:24,060 --> 01:49:26,740
כל זאת, ועוד יותר בפעם הבאה.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [הפעלת סרטון]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover רק הגיע.

2133
01:49:32,970 --> 01:49:35,146
אני הולך ללכת לביקור
פרופסור בקולג 'שלו.

2134
01:49:35,146 --> 01:49:37,611
כֵּן.

2135
01:49:37,611 --> 01:49:40,080
היי.

2136
01:49:40,080 --> 01:49:40,660
זה אתה.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
לַחֲכוֹת!

2139
01:49:45,110 --> 01:49:45,610
דוד.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
אני רק מנסה להבין
מה קרה לך.

2142
01:49:56,060 --> 01:49:58,130
אנא, כל דבר יכול לעזור.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
היית הקולג 'שלו
שותפה, לא היו לך?

2145
01:50:08,354 --> 01:50:10,770
היית שם איתו כאשר
הוא סיים את הפרויקט CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [מוסיקה מתנגנת]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> ההיא." היה CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> אני אוהב את המקום הזה.

2152
01:50:44,770 --> 01:50:45,854
>> -תאכל.

2153
01:50:45,854 --> 01:50:47,020
אנחנו הולכים מחוץ לעסק.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [סוף PLAYBACK]

