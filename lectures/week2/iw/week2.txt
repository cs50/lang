[מוסיקה מתנגנת] 

דוד י מלאן: בסדר. זהו CS50 וזה הוא תחילת השבוע 2. ואתה זוכר שבמשך בני הזוג של השבועות האחרונים, הצגנו מחשב מדע, בתורו, תכנות. 

והתחלנו את הסיפור בדרך של Scratch, ששפה גרפית מ מעבדת המדיה של MIT. ואז ולאחרונה, בשבוע שעבר, עשה לנו להציג א א higher-- שפה ברמה נמוכה ידועה כמו C, משהו שהוא גרידא טקסטואלי. ואכן, הפעם האחרונה שאנחנו בחן בתוך ההקשר מספר מושגים. 

כזכור, זה, היה מאוד התוכנית הראשונה הסתכלנו. תוכנית זו, בפשטות, מדפיס, "שלום, עולם". אבל יש כל כך הרבה קסם לכאורה קורה. יש זה #include עם סוגריים משולשים אלה. יש int. יש (void). יש סוגריים, סוגריים מסולסלים, חצי נקודות, ולכן הרבה יותר. 

וכך, לזכור כי הצגנו Scratch כדי שנוכל, באופן אידיאלי, לראות מעבר תחביר זה, הדברים האלה באמת לא כל מה אינטלקטואלי מעניין אבל בשלב מוקדם הוא, בהחלט, קצת מסובך כדי לעטוף את דעתך. ואכן, אחד הנפוץ ביותר דברים מוקדם בכיתת תכנות, במיוחד עבור אלה פחות נוח, היא מתוסכלת והכשיל ידי תחבירי מסוים שגיאות, שלא לדבר על שגיאות לוגיות. וכך בין מטרותינו היום, למעשה, יהיה להיות לצייד אותך עם כמה טכניקות לפתרון בעיות עבור כמה עדיף לפתור בעיות בעצמם בצורה של באגים. ואתה זוכר, מדי, כי הסביבה הצגנו בפעם האחרונה נקראה CS50 IDE. זוהי תוכנה מבוססת אינטרנט מאפשר לך לתכנת בענן, כביכול, תוך שמירה על כל שלך קבצים יחד, כפי שאנו שוב יהיו היום. ולהיזכר שאנחנו ובקר נושאים אלה כאן, ביניהם פונקציות, ולולאות, ו משתנים, ביטויים בוליאני, ותנאים. ובעצם עוד כמה שאנחנו תורגם מהעולם של Scratch לעולם של ג 

אבל הבניין הבסיסי בלוקים, כביכול, באמת עדיין היו באותו השבוע שעבר. למעשה, אנחנו באמת פשוט היו חתיכת פאזל שונה, אם תרצה. במקום כי סגול להציל לחסום, אנחנו במקום היה printf, שהוא פונקציה זו ב- C כי מאפשר לך להדפיס משהו ולאתחל אותו על המסך. הצגנו את CS50 ספרייה, שבו אתה יש כיום get_char לרשותך, ו get_int, ו get_string, וכמה פונקציות נוספות כמו טוב, באמצעות שבו אתה יכול לקבל קלט מהמקלדת של המשתמש עצמו. וגם לקחנו מבט הדברים כמו these- bool, ו char, פעמיים, לצוף, int, מחרוזת long_long. ויש גם סוגי נתונים אחרים ב C. 

במילים אחרות, כאשר אתה מצהיר משתנה לאחסן ערך כלשהו, או כאשר אתה מיישם פונקציה המחזירה ערך כלשהו, אתה יכול לציין מה סוג של ערך זה. האם מקבלת מחרוזת, כמו רצף של תווים? האם מדובר במספר, כמו מספר שלם? האם זה נקודה צפה ערך, או משהו דומה? אז ב- C, בניגוד Scratch, אנחנו בעצם החל לציין איזה סוג של נתונים היינו חוזרים או משתמש. 

אבל, כמובן, אנחנו גם התנגשנו כמה גבולות יסוד של מחשוב. ובפרט, זה בשפת C, כזכור שלקחנו מבט גלישה נומרית, המציאות שאם יש לך רק כמות הזיכרון סופית או, במיוחד, מספר סופי ביטים, אתם יכולים לסמוך כל כך גבוהים רק. וכך הסתכלנו בדוגמה זו כאן לפיה מונה במטוס,, למעשה, אם פועל די זמן יכול היה על גדותיהם לגרום תוכנה שגיאת פוטנציאל פיזית ממשית. 

גם הסתכלנו צף חוסר דיוק נקודה, המציאות כי עם רק מספר סופי ביטים, אם זה 32 או 64, ניתן לציין כל כך הרבה מספרים בלבד אחרי נקודה עשרונית, ואחרי זה אתה מתחיל לקבל מדויק. כך למשל, שליש ב עולם כאן, בעולמנו האנושי, מה שאנחנו יודעים הוא רק מספר אינסופי של 3s לאחר הנקודה העשרונית. אבל מחשב לא יכול בהכרח מייצג מספר אינסופי של מספרים אם אתה רק לאפשר לו כמה כמות המידע סופית. 

אז לא רק אנחנו לצייד אותך עם כוח גדול במונחים איך אתה יכול לבטא את עצמך מקלדת מבחינת תכנות, אנחנו גם מוגבלים מה אתה יכול לעשות בפועל. ואכן, באגים וטעויות יכולים לנבוע מיני סוגיות אלה. ואכן, בין הנושאים היום הולכים להיות נושאים כמו באגים ולמעשה מחפש משהו מתחת למכסה המנוע כיצד הוכנסו דברים בשבוע שעבר הם למעשה מיושמים כך שאתה טוב יותר להבין הן את היכולות של ו המגבלות של שפה כמו ג 

ואכן, נצטרך לקלף את השכבות המבנה הפשוט של נתונים, משהו שנקרא מערך, אשר Scratch קורית מכנה "רשימה." זה קצת שונה בהקשר זה. ואז אנחנו גם נכיר אחד הראשון של בעיות ספציפיתלתחום שלנו ב CS50, העולם קריפטוגרפיה, אמנות ערבול או הצפנת מידע כה כי אתה יכול לשלוח מסרים סודיים ולפענח מסרים סודיים בין שני אנשים, A ו- B. 

אז לפני המעבר אנחנו לעולם החדש, בואו ננסה לצייד אותך עם כמה טכניקות שבה ניתן לחסל או להפחית לפחות חלק של תסכולים כי אתה כנראה נתקלת במהלך השבוע האחרון בלבד. למעשה, לפני שאתה such-- חלק הבעיות הראשונות שלך ב C. ואת רוב הסיכויים הם, אם אתה אוהב אותי, בפעם הראשונה אתה מנסה להקליד את תכנית, גם אם אתה חושב בצורה הגיונית התוכנית היא פשוטה למדי, ייתכן מאוד גם פגע בקיר, ו המהדר לא הולך לשתף פעולה. הפוך או קלאנג לא הולך למעשה כדי לעשות את ההצעה שלך. 

ולמה זה יכול להיות? ובכן, בואו נסתכל, אולי, תכנית פשוטה. אני הולך קדימה, לשמור את זה ב קובץ בשם בכוונה buggy0.c, כי אני יודע את זה להיפגם מראש. אבל אני לא יכול להבין שאם זה היא התכנית הראשונה או שנייה או שלישית כי אני בעצם עושה את עצמי. אז אני הולך קדימה, להקליד, int main (void). ואז בתוך הסוגריים המסולסלים שלי, מאוד מוכר ( "שלום, בעולם-- מהלך סרק, n ") - וא-פסיק. 

שמרתי את הקובץ. עכשיו אני הולך לרדת כדי חלון המסוף שלי וסוג לעשות buggy0, כי, שוב, השם של הקובץ היום הוא buggy0.c. אז אני מקליד לעשות buggy0, Enter. 

ואה, אלוהים, זוכר מהפעם הקודמת שאף הודעות שגיאה הוא דבר טוב. אז לא פלט הוא דבר טוב. אבל כאן יש לי בבירור כמה מספר טעויות. 

אז השורה של הפלט הראשון לאחר הקלדת לעשות buggy0, כזכור, הוא פלט מפורט למדי של קלאנג. מתחת למכסה המנוע, IDE CS50 מוגדר להשתמש חבורה שלמה של אפשרויות עם מהדר זה כך שאתה לא צריך לחשוב עליהם. וזה כל מה השורה הראשונה אמצעי שמתחיל עם קלאנג. 

אבל אחרי זה, הבעיות מתחיל להפוך את המראה שלהם. Buggy0.c על קו 3, אופי 5, יש טעות גדולה, אדומה. מה זה? במשתמע להכריז פונקצית ספרייה printf עם int סוג (char * const, ...) [-Werror]. זאת אומרת, זה מהר מאוד אהיה מאוד מסתורי. ובוודאי, בהתחלה מבט, לא היינו מצפה ממך להבין את מכלול ההודעה. וכך אחד הלקחים היום הוא הולך להיות כדי לנסות להבחין דפוסים, או דברים דומים, לטעויות שאולי יש לך נתקלו בעבר. אז בואו ננסה להפריד רק את המילים האלה כי נראו מוכרות. The Big, השגיאה האדומה ברורה סמלי של משהו לטעות. 

במשתמע להכריז printf פונקציה הספרייה. אז גם אם אני לא ממש מבין מה במשתמע להכריז פונקצית ספרייה אמצעי, הבעיה ללא ספק מתייחס printf איכשהו. ואת מקור הבעיה קשור להצהיר על כך. 

הכרזה על פונקציה היא להזכיר את זה בפעם הראשונה. ונהגנו המינוח בשבוע שעבר של הכרזה על אב הטיפוס של פונקציה, גם עם קו אחד בראש שלך קובץ לבד או קובץ כותרת שנקרא. ובאיזה קובץ עשה אנו אומרים printf בשבוע שעבר כי הוא ציטוט, סוף ציטוט, הכריז? באיזה קובץ הוא אב הטיפוס שלו? 

אז אם אתה זוכר, הדבר הראשון שאני מוקלד, כמעט כל תוכנית הבאה-- האחרון ובטעות רגע לפני נכתב הקלדת myself-- היה כאן-- אחד זה hash-- #include <stio-- עבור קלט / h נקודת output-- ואכן, ואם אני כותב עכשיו לשמור קובץ זה, אני הולך כדי להמשיך לנקות את המסך שלי, שבו אתה יכול לעשות על ידי הקלדה נקה, או שאתה יכול להחזיק שליטה L, רק כדי לנקות חלון המסוף שלך רק כדי לחסל כמה עומס. 

אני הולך קדימה, הקלד לעשות buggy0, Enter. והנה, אני עדיין רואה את זה פקודה ארוכה קלאנג, אבל אין הודעת שגיאה הפעם. ואכן, אם אני עושה ./buggy0, בדיוק כמו בפעם הקודמת, שם נקודה זה אומר בספרייה, סלאש רק אומר, כאן מגיע השם של התוכנית השם של התוכנית היא buggy0, זן, "שלום, עולם". 

עכשיו, איך ייתכן שיש לך ליקט את הפתרון הזה בלי בהכרח הכרה כמו מילים רבות כמוני, בהחלט, שיש עשה זאת במשך כל כך הרבה שנים? ובכן, לממש לכל הבעיה הראשונה סט, אנחנו מציגים לכם פקודה כי הצוות של CS50 עצמו כתב בשם help50. ואכן, C עושה מפרט הבעיה להגדיר כיצד להשתמש בשיטה זו. 

אבל help50 הוא במהותו תוכנית הצוות של CS50 כתב המאפשר לך להפעיל פקודה או להפעיל תוכנית, ואם אתה לא מבין שלה פלט, כדי לעבור את תפוקתו כדי help50, ובנקודה התוכנה כי הצוות כמובן כתב יסתכלו הפלט של התוכנית שלך שורה אחר שורה, תו אחר תו. ואם אנחנו, הצוות, להכיר הודעת שגיאה שאתה חווה, ננסה לעורר אותך עם כמה שאלות רטוריות, עם כמה עצות, הרבה כמו TF או CA או את עצמי יעשה באופן אישי בשעות המשרד. 

אז נראה help50 אם לא בהכרח מכירים בעיה. אבל לא לסמוך על זה יותר מדי כמו קביים. בהחלט לנסות להבין שלה ואז להדפיס וללמוד ממנו כך שרק פעם או פעמיים אתה אי פעם לרוץ help50 עבור טעות מסוימת הוֹדָעָה. אחרי זה, אתה צריך להיות מצויד טוב יותר את עצמך כדי להבין מה זה באמת. 

בוא נעשה אחד כאן אחרים. תן לי ללכת קדימה, ובאחרת קובץ נתקשר buggy1.c זה. וגם בקובץ זה אני הולך deliberately-- אבל להעמיד פנים שאני לא להבין מה הטעות שעשיתי. 

אני הולך קדימה, לעשות זה- #include, מאז שאני לפני למד את הלקח שלי לרגע. העיקרי Int (void), כמו קודם. ואז הנה, אני הולך לעשות מחרוזת s - get_string. ולהיזכר מהעת אחרונה פירוש הדבר, היי, המחשב, תן לי משתנה, קוראים לזה S, להפוך את סוג המשתנה מחרוזת אז אני יכול לאחסן פריט אחד או יותר מילים. 

ואז על-יד ימין הצד של סימן השוויון הוא get_string, שהינה פונקציה בספריית CS50 שעושה בדיוק את זה. זה נהיה פונקציה ולאחר מכן ידיים זה מימין לשמאל. אז סימן שוויון זה לא אומר "שווה" כמו שאנחנו נוטים לחשוב במתמטיקה. זה אומר משימה מימין לשמאל. אז זה אומר, לקחת את החוט מן המשתמש ולאחסן אותו בתוך הים. 

עכשיו בואו להשתמש בו. תן לי ללכת קדימה עכשיו וכתוצאה שנייה קו, תן לי להמשיך ולומר "שלום" - לא "העולם", אבל "שלום,% s-- שהוא מציין המיקום שלנו, פסיק ים, וזה משתנה שלנו, ואז נקודת פסיק. אז אם אני לא לפשל יותר מדי כאן, זה נראה כמו קוד נכון. 

והאינסטינקטים שלי עכשיו הם להדר אותו. הקובץ נקרא buggy1.c. אז אני הולך לעשות לעשות buggy1, Enter. ולעזאזל-זה, אם אין אפילו יותר טעויות מאשר לפני. אני מתכוון, יש עוד הודעות שגיאה שזה יהיה נראה מ קווים בפועל בתכנית זו. 

אבל האוכל המוכן הוא כאן, גם אם אתה המום עם שתיים או שלוש או עוד ארבע הודעות שגיאה, להתמקד תמיד על מאוד הראשון של הודעות אלה. כאשר מסתכלים על אחד העליון ביותר, גלילה לגבות לפי הצורך. אז הנה הקלדתי לעשות buggy1. הנה כי פלט קלאנג כצפוי. 

והנה השגיאה האדומה הראשונה. שימוש מזהה מוצהרים מחרוזת, היה, כוונתי סטנדרטית? אז סטנדרטי הוא בעצם משהו אחר. זה מתייחס למשתמש של מקלדת, בעצם. 

אבל זה לא מה שהתכוונתי. התכוונתי מחרוזת, והתכוונתי get_string. אז מה זה שאני שכחתי לעשות הפעם? מה שחסר הפעם? יש לי #include שלי, אז יש לי גישה printf. 

אבל מה שאני לא צריך גישה עדיין? ובכן, בדיוק כמו בפעם הקודמת, אני צריך לומר למהדר צלצול מה פונקציות אלו. Get_string לא בא עם ג בפרט, זה לא לבוא כותרת קובץ,. זה במקום מגיע משהו הצוות כתב, שהוא קובץ שונה שם אבל בצדק בשם. 

אז פשוט על ידי הוספת שורה זו היזכרות code-- מפעם קודמת שכאשר קלאנג פועל, זה הולך להסתכל למעלה הקוד שלי למטה, משמאל לימין. זה הולך שם לב, אה, אתה רוצה. תן לי ללכת ולמצוא כי, בכל מקום בו הוא נמצא בשרת, להעתיק ולהדביק אותו, בעצם, לתוך החלק העליון של קובץ משלך כך שבשלב זה של הסיפור, קו 1, שאר התוכנית אכן יכול להשתמש בכל הפונקציות בהם, ביניהם get_string. אז אני הולך להתעלם שאר שגיאות אלה, כי אני, אכן, חושד שרק הראשון ממש חשוב. ואני הולך קדימה, שידור חוזר, לאחר שמירת הקובץ שלי לעשות buggy1. וזהו, זה כן עובד. ואם אני עושה ./buggy1 באמצעות הקלדה עבור למשל, Zamyla, אני עכשיו אקבל שלום, Zamyla, במקום שלום, העולם. 

בסדר. אז מזנונים כאן אז הם, אחד, מנסה ללקט ככל שאתה יכול מן הודעות שגיאה לבד, מחפש בכמה מילים לזיהוי. חוץ מזה, להשתמש help50 לכל הבעיה להגדיר מפרט. אבל חוץ מזה, גם תמיד נראה על השגיאה העליונה בלבד, לפחות בתחילה, כדי לראות איזה מידע זה באמת עשוי להניב. אבל מתברר של שם אפילו יותר פונקציונלי מובנית אל ספריית CS50 לעזור אתה בשלב מוקדם בסמסטר וכבר בשלב מוקדם בתכנות להבין מה השתבש. אז בוא נעשה דוגמה נוספת כאן. אני הולך להתקשר buggy2 זה, אשר, שוב, הוא הולך להיות פגום החוצה השער, על ידי עיצוב. 

ואני הולך קדימה ולעשות #include. ואז אני הולך לעשות int main (void). ואז אני הולך לעשות לולאת for. עבור (int i _ 0. אני הוא פחות או שווה ל -10. i ++, ולאחר מכן ב סוגריים מסולסלים, אני הולך רק כדי להדפיס את סמל hashtag כאן ומעניק לו אופי קו חדש. 

אז הכוונה שלי עם זה התוכנית היא בפשטות כדי לחזר 10 פעמים ועל כל איטרציה של לולאה שבכל פעם דרך מחזור, להדפיס hashtag, Hashtag, בתגית. בכל שורה אחת כי אני יש את הקו החדש שם. וגם לזכור כי עבור לולאה, לכל week-- האחרון ותקבל יותר מכיר את התחביר באמצעות אותו עם תרגול לפני long-- זה נותן לי משתנה בשם i ומניח אותו ל -0. 

זה מגדיל i על כל איטרציה על ידי 1. אז אני הולך 1 עד 2 עד 3. ואז במצב הזה באמצע בין--נקודתיים מקבל בדק בכל איטרציה לעשות בטוח שאנחנו עדיין בטווח. אז אני רוצה לחזר 10 פעמים, אז אני יש מעין מאוד אינטואיטיבי פשוט לשים 10 כמו הגבול העליון שלי שם. 

ובכל זאת, כשאני רציתי זה, לאחר קומפילציה אותו עם איפור buggy2-- וזה לקמפל אישור. אז אין לי שגיאת תחביר פעם. תן לי ללכת קדימה עכשיו ולהפעיל buggy2, Enter. ועכשיו לגלול מעלה. ותנו לי להגדיל את גודל החלון. 

יש לי כנראה 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. אז יש 11 סולמית, למרות אני בבירור לשים 10 בתוך לולאה זו. עכשיו, כמה מכם עשויים לראות מיד מהי השגיאה כי, אכן, זו לא הוא טעות קשה מאוד לעשות. אבל זה מאוד נפוץ עשה בשלב מוקדם מאוד. 

מה אני רוצה להצביע, אם כי, היא, איך יכול אני להבין את זה? ובכן, מתברר כי ספריית CS50 מגיעה עם לא רק get_string ו get_int ו get_float ופונקציות אחרות. היא גם מגיעה עם תפקיד מיוחד eprintf שנקרא, או, printf שגיאה. וזה קיים אך ורק כדי לעשות זה קצת יותר קל לך כאשר באגים בקוד שלך פשוט להדפיס הודעת שגיאה על המסך ולדעת מאיפה זה בא. 

כך למשל, דבר אחד אני יכול לעשות כאן עם פונקציה זו זה-- eprintf, ולאחר מכן אני הולך קדימה ואומר אני עכשיו% i, מהלך סרק, n. ואני הולך לחבר את הערך של i. וגם למעלה, כי זה הוא בספריית CS50, אני הולך קדימה ולכלול אז יש לי גישה בפונקציה זו. אבל הבה נבחן מה קו 9 הוא אמור לעשות. אני הולך למחוק זאת בסופו של דבר. יש זה לא קשור עם מטרת העל שלי. אבל eprintf, printf שגיאה, הוא פשוט התכוון לתת לי קצת מידע אבחוני. כאשר אני מפעיל את התוכנית שלי, אני רוצה לראות את זה על המסך באופן זמני גם פשוט להבין מה קורה. 

ואכן, על כל איטרציה כאן של קו 9 אני רוצה לראות, מה הוא הערך של i? מהו הערך של i? מהו הערך של i? וגם, בתקווה, אני צריך רק רואה את ההודעה, גם, 10 פעמים. 

אז תן לי ללכת קדימה הידור התוכנית שלי, כפי שאני צריך לעשות בכל עת אני עושה שינוי. ./buggy2. ו now-- אישור. יש הרבה יותר קורה. אז תנו לי לגלול מעלה ב חלון גדול עוד יותר. 

ותראה שכל אחד הסולמית עדיין מדפיסה. אבל בין כל אחד מהם הוא עכשיו זה פלט אבחון מעוצב כדלקמן. השם של התוכנית שלי כאן הוא buggy2. השם של הקובץ הוא buggy2.c. מספר הקו שממנו זה הודפס הוא קו 9. ואז בצד ימין של זה הוא הודעת שגיאה שאני מצפה. 

ומה שיפה זה הוא כי עכשיו אין לי לספור בהכרח בראשי מה התוכנית שלי עושה. אני רואה את זה על גרסה הראשונה i היא 0, אז 1, ואז 2, אז 3, אז 4, אז 5, ולאחר מכן 6, ולאחר מכן 7, אז 8, אז 9, אז 10. אז חכו רגע. מה קורה פה? אני עדיין נראיתי לספור כמתוכנן עד 10. 

אבל מאיפה אני מתחיל? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. אז 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- האצבע -11 הוא מעיד על הבעיה. נראה לי לספור שגוי בלולאה שלי. במקום ללכת 10 חזרות, אני מתחיל ב 0, אני מסיים ב ובאמצעות 10. אבל בגלל, כמו מחשב, אני מתחיל לספור ב 0, אני צריך לספור עד כדי, אבל לא דרך, 10. 

וכך את התיקון, אני בסופו של דבר הבנתי כאן, הוא אחד משני דברים. יכולתי מאוד פשוט לומר לספור עד פחות מ -10. אז 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, שהוא, אכן, נכון, למרות שזה נשמע טיפה לא בסדר. או שאני יכול לעשות פחות או שווה עד 9, כל עוד אני מתחיל ב 0. לחלופין, אם אתה באמת לא אוהב את זה, אתה יכול לספור עד דרך 10 אבל מתחיל ב 1. אבל שוב, זה פשוט לא כל כך נפוץ. בשנת programming-- אם כי לא כל כך הרבה Scratch-- אבל בתכנות ב C ושפות אחרות, כמו JavaScript ו- פייטון ואחרים, זה רק מאוד נפוץ דיון בינארי שלנו רק להתחיל לספור על המספר הנמוך ביותר שאתה יכול, וזה 0. בסדר. אז זה eprintf. ושוב, עכשיו אני כבר הבנתי שלי בעיה, ואני הולך לחזור 0 באמצעות פחות מ -10, אני הולך ללכת ולמחוק eprintf. 

זה לא אמור להיות שם כשאני ספינת הקוד שלי או לשלוח את הקוד שלי או להראות את זה לאף אחד אחר. זה באמת רק התכוון כדי לשמש באופן זמני. אבל עכשיו אני כבר תיקנו את זה בעיה מסוימת גם כן. 

ובכן, בוא נעשה דוגמה אחת יותר כאן כי אני הולך להלהיב כדלקמן. אני הולך קדימה, #include. $ 50 ואני הולך קדימה ו #include. 

ואני הולך להציל קובץ זה כמו buggy3.c. ואני הולך קדימה ולהכריז int main (void). ואז בתוך משם אני הולך לעשות int i _ - אני רוצה ליישם תוכנית עם get_negative_int. זה לא פונקציה כי קיימת עדיין. אז אנחנו הולכים ליישם זה בעוד רגע. אבל אנחנו הולכים לראות מדוע זאת העגלה לעבר תג המעבר הראשון. וברגע קיבלתי מספר שלם מהמשתמש, אני רק הולך להדפיס% i הוא שלילי שלם, מהלך סרק, n, פסיק, אני. במילים אחרות, כל מה שאני רוצה תוכנית זו לעשות הוא מקבל int שלילית המשתמש ולאחר מכן להדפיס כי כזאת וכזאת היא int שלילית. 

עכשיו אני צריך ליישם פונקציה זו. אז בהמשך התיק שלי, אני הולך ללכת קדימה ולהכריז פונקציה שנקראת get_negative_int (void) - ואנו לחזור למה קו זה אומר שוב בתוך n int moment--; תעשה-- מטלות את n printf following-- הוא :. ואז אני הולך לעשות n - get_int, ולעשות בזמן n זה גדול מ -0. ואז לחזור n ;. 

אז יש הרבה קורה זה אבל אף אחד מהם לא אנחנו להסתכל בשבוע שעבר, לפחות לזמן קצר. אז על קו 10 והנה אני כבר הכרזתי על פונקציה שנקראת get_negative_int, ואני מחזיר (void), ב בסוגריים, והסיבה זו לא צריך להיות קלט. אני לא עובר שום דבר לפונקציה זו. אני רק מקבל משהו בחזרה ממנו. 

ומה אני מקווה לחזור הוא מספר שלם. אין סוג נתונים C קרא negative_int. זה פשוט int, אז זה הולך להיות עלינו לוודא שהערך בעצם שהחזרת לא רק int אבל הוא גם שלילי. 

On line 12 אני מכריז על משתנה n קרא והפיכתו של int סוג. ואז עולה בקנה אחד 13 עד 18 אני עושה משהו תוך משהו נכון. אני הולך קדימה והדפסה N הוא, מעי גס, ולאחר מכן רווח, כמו פקודה עבור המשתמש. 

אז אני הולך להתקשר get_int ו לאחסון ערך החזרה שנקרא שלה באותה n משתנה. אבל אני הולך להמשיך לעשות n בזמן זה הוא גדול מ -0. במילים אחרות, אם המשתמש נותן לי int ומספר כי הוא גדול מ -0, ergo, חיובי, אני הולך רק לשמור reprompting המשתמש, לשמור reprompting, כופה עליהם פעולה ולתת לי int שלילית. 

וברגע n הוא למעשה negative-- מניח המשתמש ולבסוף סוגים -50, אז הלולאה בזמן הזה היא כבר לא נכון משום -50 אינו גדול מ -0. אז אנחנו לפרוץ כי לולאה לוגית ולחזור n. 

אבל יש אחד אחר דבר שאני צריך לעשות. ואני פשוט יכול לעשות את זה על ידי העתקה והדבקה שורה אחת של קוד בחלק העליון של הקובץ. אני צריך ללמד קלאנג, או מבטיח להרעיש, במפורש כי אני אעשה זאת, אכן, ללכת וליישם get_negative_int בפונקציה זו. זה יכול להיות רק נמוך בקובץ. שוב, לזכור כי קלאנג קורא דברים מלמעלה למטה, משמאל לימין, כך שאתה לא יכול לקרוא לפונקציה אם קלאנג לא יודע שזה הולך להתקיים. 

עכשיו, למרבה הצער, תוכנית זו, כפי שחלקכם אולי הבחין, כבר הוא מרכבה. תן לי ללכת קדימה ולעשות buggy3. זה הידור, אז הבעיה שלי כרגע היא לא שגיאת תחביר, כמו שגיאה טקסטואלית, זה באמת הולך להיות הגיוני שגיאה לי בכוונה עשה כהזדמנות צעד דרך מה קורה. 

אני הולך קדימה עכשיו ולהפעיל buggy3. ואני מתכוון ללכת קדימה ולא לשתף פעולה. אני הולך לתת לו את המספר 1. זה לא מצא חן בעיניהם, כך זה מה שגרם לי שוב. 

מה דעתך על 2? 3? 50? אף אחד מאותם עובדים. מה דעתך על -50? והתוכנית נראה לעבוד. 

תן לי לנסות את זה פעם נוספת. תן לי לנסות -1, נראה לעבוד. תן לי לנסות -2, נראה לעבוד. תן לי לנסות 0. הא, זה לא נכון. עכשיו, אנחנו להיות קצת קפדנים כאן. אבל זה, אכן, במקרה זה 0 אף אחת מהן אינו חיובי או שלילי. ולכן העובדה כי התוכנית שלי היא ואמר כי 0 הוא מספר שלילי, זה לא נכון מבחינה טכנית. 

עכשיו, למה הוא עושה את זה? ובכן, זה יכול להיות מובן מאליו. ואכן, התוכנית היא אמור להיות פשוט למדי אז יש לנו משהו לחקור. 

אבל בואו להציג באגים שלישיים טכניקה כאן נקראת debug50. אז מדובר בתוכנית כי כרגע יצרנו שנה בשם זה debug50 שיאפשר לך להשתמש במה שנקרא המובנית הבאגים גרפיים IDE CS50. ו הבאגים הוא רק תוכנית בדרך כלל מאפשר לך להריץ את התוכנית אבל צעד אחר צעד אחר צעד, קו על ידי שורה אחר שורה, משתהה, תוקעת סביב, מביט משתנים כך התוכנית אינה רק לפוצץ לך בעבר ובמהירות להדפיס משהו או לא להדפיס משהו. זה נותן לך הזדמנות, ב מהירות אנושית, כדי אינטראקציה עם זה. 

וכדי לעשות זאת, אתה פשוט לבצע את הפעולות הבאות. לאחר קומפילצית הקוד שלך, שכבר עשיתי, buggy3, שאתה הולך קדימה ולהפעיל debug50 ./buggy. כל כך הרבה כמו help50 יש לך לרוץ help50 ולאחר מכן את הפקודה, debug50 יש לך לרוץ debug50 ו אז שם הפקודה. 

עכשיו שימו לב מה קורה על המסך שלי, בצד הימני בפרט. כאשר אני מכה על הפעלה, כל לוח זה ימני פתאומי נפתח על המסך. ויש הרבה אקשן על במבט ראשון. אבל יש לא יותר מדי הרבה מה לדאוג עדיין. 

זה מראה לי הכל מה שקורה בתוך התוכנית שלי עכשיו ובאמצעות אלה כפתורים למעלה אז שאיפשר לי התקדמות הדרגתית בקוד שלי בסופו של דבר צעד אחר צעד אחר צעד. אבל לא רק זאת. שימו לב מה קורה. בשעת חלון המסוף שלי אני בקשת אישור עבור n. ואני הולך קדימה פעולה זמן מסוג זה -1. וגם אם כי קצת סתום, -1 הוא מספר שלילי, כצפוי. 

ואז הילד יצא עם מצב 0 GDBserver היציאה. GDB, Debugger גנו, הוא שם של התוכנה הבסיסית מיישמת הבאגים זה. אבל כל זה באמת אומר, הבאגים הלכתי משם כי התכנית שלי להפסיק הכל היה טוב. אם אני רוצה לאתר באגים בתוכנית שלי באמת, אני חייב לומר debug50 מנע, איפה אני רוצה להתחיל דורך דרך הקוד שלי? 

ואולי הדרך הפשוטה כדי לעשות זאת היא כדלקמן. אם אני מרחף מעל מרזב של העורך שלי כאן, אז באמת רק בסרגל הצדדי כאן, משמאל את מספר הקו, לב שאם אני פשוט לוחץ פעם, שמתי נקודה אדומה קטנה. וזה נקודה אדומה קטנה, כמו תמרור עצור, אומר, היי, debug50, להשהות ביצוע הקוד שלי ממש המקום כאשר אני מפעיל תוכנית זו. 

אז בואו נעשה את זה. תן לי ללכת קדימה ולהפעיל את התוכנית שלי ./buggy3 שוב עם debug50, Enter. ועכשיו, הודעה, משהו שונה קרה. אני לא בקשת אישור עדיין בחלון המסוף שלי לכל דבר, כי יש לי לא הגעתי לשם עדיין בתכנית שלי. שימו לב כי על קו 8 אשר מסומן כעת, ויש חץ קטן ב אמרה שמאלית, אתה מושהה כאן. שורת הקוד הזאת, קו 8, לא שהנהלה. 

ומה מוזר, אם אני מסתכל כאן בצד הימני, שים לב כי אני הוא מקומי משתנה, מקומי במובן שזה בתוך הפונקציה הנוכחית. והערכה, כנראה כברירת מחדל, ולמיין של נוח, הוא 0. אבל אני לא להקליד 0. זה קורה רק כדי להיות שלו ערך ברירת מחדל כרגע. 

אז תן לי ללכת ולעשות את זה עכשיו. תן לי ללכת קדימה על העליון ממש כאן, אני הולך קדימה לחץ סמל ראשון זה אשר פירושו צעד מעל כלומר לא לדלג זה אבל לדרוך על הקו הזה של קוד, ביצוע לאורך הדרך. 

ועכשיו, שימו לב, שלי פקוד עתה השתנה. למה זה? כבר אמרתי debug50, להפעיל את שורת הקוד. מה את שורת הקוד לעשות? מנחה אותי int. בסדר. הרשו לי לשתף פעולה. תן לי ללכת קדימה עכשיו ולהקליד -1, Enter. ועכשיו לב מה השתנה. בצד-יד ימין, משתנה המקומי שלי אני מותווה כמו להיות -1 עכשיו. וזה עדיין של int סוג. 

ושימו לב, גם שלי שנקרא קוראים מחסנית, מאיפה אני עוצר? נדברנו עוד על זה בעתיד. אבל מחסנית הקריאות רק מתייחסת למה פונקציות כרגע בתנועה. כרגע זה רק ראשי. וכרגע מקומי בלבד משתנה הוא אני עם ערך של 1. 

וכאשר סוף סוף אני ניגשתי את הקו הזה כאן, עם אותו סמל בצד ימין למעלה, -1 הוא מספר שלילי. עכשיו זה משתהה מעל במחוך מתולתל. בואו לתת לו לעשות את הדבר שלו. אני ניגש כי קו, וזהו. 

אז לא כל כך נורא מחכימה עדיין, אבל זה לא תן לי להשהות ולחשוב דרך לוגית מה התוכנית הזו עושה. אבל זה לא היה המקרה השגוי. בוא נעשה את זה שוב כדלקמן. 

אני הולך לעזוב נקודת עצירה כי על קו 8 עם הנקודה האדומה. אני הולך להפעיל מחדש debug50. זה באופן אוטומטי עצר כאן. אבל הפעם, במקום דורך על הקו הזה, תן לי בעצם להיכנס פנימה של get_negative_int להבין, למה זה מקבל 0 כתשובה תקפה? 

אז במקום ללחוץ שלב נגמר. אני הולך קדימה ולחץ צעד לתוך. ושימו לב שקו 8 זה עכשיו הדגיש ועכשיו פתאום הופך קו 17. 

עכשיו, זה לא כל כך הבאגים דלג על קווי 14 ו -15 ו -16. זה פשוט אין שום דבר להראות לך שם. אלה הם רק הצהרה על משתנה, ואז יש את המילה האם ואז מעין משענת מתולתלת פתוחה. השורה פונקציונלית רק זה עסיסי באמת זה אחד כאן, 17. וכאן יש לנו השהייה אוטומטית. 

אז printf ( "n.is:") ;, כך כי עדיין לא קרה. אז בואו נלך קדימה ולחצו לדלג מעל. עכשיו הפקודה שלי, אכן, שונה ( "n הוא:"). עכשיו get_int, אני לא הולך להטריד צועד לתוך, כי הפונקציה הייתה שנעשה על ידי CS50 בספרייה. זה כנראה נכון. 

אז אני הולך קדימה, מעין פעולה על ידי מתן int, אבל לא int שלילי. אז תן לי ללכת קדימה ופגעו 0. ועכשיו מה קורה כאן כשאגיע לקו 21? אני כבר לא iterated שוב. אני לא נראיתי תקוע בלולאה. במילים אחרות, זה צהוב בר לא להמשיך סביב, ומסביב, ומסביב. 

עכשיו, מדוע זה כך? ובכן, n, מה הוא n עכשיו? אני יכול להסתכל המקומי משתנים הבאגים. n הוא 0. בסדר, מה היה המצב שלי? 

20-- קו 20 הוא, ובכן, 0 הוא גדול מ -0. זה לא נכון. 0 אינו גדול מ -0. וכך שברתי מתוך זה. 

וכך זה למה על קו 21, אם אני באמת להמשיך, אני הולך להחזיר 0, אפילו אם הייתי צריך דחה 0 לא ממש להיות שלילי. אז עכשיו, אני לא באמת אפילו אכפת הבאגים. הבנתי, אני לא צריך יודע מה עוד קורה. 

אז אני הולך קדימה, רק ללחוץ על כפתור Play, ולתת לסיים את זה. עכשיו, אני כבר הבנתי כי שלי הבאג הוא כנראה על קו 20. זה הטעות הלוגית שלי. 

אז מה אני רוצה לעשות כדי לשנות זאת? אם הבעיה היא שאני לא המושכים 0, זה פשוט טעות לוגית. ואני יכול לומר while n הוא גדול או שווה ל -0, לשמור להציג הודעה למשתמש שוב ושוב. 

אז, שוב, טעות פשוטה, אולי אפילו ברור כשראית אותי לכתוב את זה רק לפני כמה דקות. אבל ממסעדה כאן הוא שעם debug 50, ועם באגים תוכנה באופן כללי יותר, יש לך כוח מצא חדש זו כדי ללכת דרך קוד משלך, להסתכל דרך כי לוח יד ימין מה ערכי המשתנים שלך. אז אתה לא בהכרח צריך להשתמש במשהו כמוך eprintf להדפיס ערכים אלה. אתה יכול ממש לראות אותם ויזואלית על המסך. 

עכשיו, מעבר לכך, ראוי לציין שיש טכניקה אחרת זה למעשה סופר משותף. ואתם עשויים לתהות מדוע הקטן הזה הבחור כאן כבר יושב על הבמה. אז יש את הטכניקה הזו, בדרך כלל המכונה באגים ברווז גומי, אשר באמת הוא רק עדות לעובדה לעתים קרובות שכאשר מתכנתים כותבים קוד, הם לא בהכרח שיתוף פעולה עם אחרים, או עובד בסביבה משותפת. 

הם מעין בבית. אולי זה מאוחר בלילה. הם מנסים להבין כמה באגים בקוד שלהם. והם פשוט לא רואים את זה. 

ואין שותפה. אין TF. אין CA סביב. כל מה שהם צריכים על המדף שלהם הוא חמוד גומי הקטן הזה. 

וכך באגים ברווז גומי רק היא הזמנה זו לחשוב על משהו מטופש כמו זה כיצור אמיתי, ולמעשה ללכת דרך הקוד שלך מילולית חפץ דומם זה. כך, למשל, אם זה הדוגמה שלי כאן-- ולהיזכר כי מוקדם יותר הבעיה היתה זו, אם אמחק לשורה הראשונה זו קוד, ואני להמשיך ולעשות מרכבה 0 שוב, זוכר שיש לי אלה הודעות שגיאה כאן. אז הרעיון כאן, מגוחך אם כי אני מרגיש כרגע עושה את זה בפומבי, השגיאה היא כי. 

אוקיי, אז הבעיה שלי היא שאני כבר במשתמע הכריז פונקצית ספרייה. וזה פונקציה הספרייה printf. Declare-- אישור, להכריז מזכיר לי טיפוס. 

זה אומר שאני צריך באמת לומר למהדר מראש מה הפונקציה נראית. חכה דקה. לא היה לי io.h. תקן תודה רבה. 

אז פשוט תהליך זה זה-- לך לא צריך באמת ברווז. אבל הרעיון הזה של הליכה עצמך דרך קוד משלך כך שאתה אפילו לשמוע עצמך, כך שאתה להבין השמטות משלך דבריו, הוא בדרך כלל את הרעיון. 

וגם, אולי יותר הגיוני, לא כל כך הרבה את מה שראו עיניו אך מעורב יותר למשל אנחנו פשוט עושים 3.ג מרכבה, ייתכן ללכת עצמך דרכו כְּדִלקַמָן. אז בסדר, גומי חמוד, DDB, אם תרצו. כאן יש לנו בתפקוד העיקרי שלי, אני מתקשר לקבל int שלילית. 

ואני מקבל את הערך המוחזר. אני אחסונו על צד שמאל על קו 8 משתנה בשם i. בסדר, אבל רגע, איך עשה מניבות ערך זה? תן לי להסתכל הפונקציה בתור 12. 

בתור 12, יש לנו לקבל int שלילית. לא לוקח שום תשומות, אין להחזיר int, אישור. אני מצהיר על קו 14 n משתנה. זה הולך לאחסן מספר שלם. זה מה שאני רוצה. 

אז לבצע את הפעולות הבאות תוך n הוא-- לתת לי לבטל את מה את התיקון כבר עשה. אז בזמן n גדול מ 0, להדפיס n זה, או קיי. ואז לקרוא מאוחסנים int ב n. ואז לבדוק אם n הוא 0, n הוא not-- זה מה שיש. אז, שוב, אתה לא צריך הברווז בפועל. אבל רק הליכה עצמך דרך הקוד שלך כתרגיל אינטלקטואלי לעתים קרובות יעזור לך להבין מה קורה, לעומת רק עושה משהו ככה, בוהה במסך, ולא לדבר את עצמך דרך זה, אשר בכנות הוא לא כמעט כמו טכניקה יעילה. אז יש לך את זה, מספר טכניקות שונות עבור למעשה באגים בקוד שלך ומציאת תקלות, שכולן צריך להיות כלי Toolkit שלך כך שאתה לא מאוחר בלילה, במיוחד, אתה בחדר האוכל אולמות, או בשעות המשרד, לדפוק את הראש נגד קיר, מנסה לפתור בעיה כלשהי. להבין כי יש כלי תוכנה. ישנם כלי ברווז גומי. ויש גם כל הצוות של לתמוך מחכה להושיט יד. 

אז עכשיו, מילה על הבעיה סטים, ועל מה אנחנו מקווים שאתה לצאת מהם, וכיצד אנחנו הולכים על הערכה. לפי הסילבוס של הקורס, סטי הבעיה של CS50 מוערכים על ארבעה צירים הראשיים שלו, כך כדי speak-- היקף, נכונותו, עיצוב, וסגנון. והיקף רק מתייחס כמה של היצירה יש לך בנשיכה? כמה של בעיה ניסית? מה מידת המאמץ יש לך מתבטא? 

תקינות היא, עושה את העבודה בתכנית כמו זה אמור לפי המפרט CS50 כאשר אתה מספק תשומות מסוימות או פלטים מסוימים חוזרים? עיצוב הוא סובייקטיבי רובם. וזה אחד כי יהיה שלוקח הכי הרבה זמן ללמוד ואת הארוך ביותר ללמד, ב עד כה כפי שהוא מסתכם, איך כתוב היטב הוא הקוד שלך? 

זה דבר אחד פשוט להדפיס את הנכון פלטים או להחזיר את הערכים הנכונים. אבל אתה עושה את זה כמו ביעילות רבה ככל האפשר? אתה עושה את זה פרד ומשול, או בינארי חיפוש כפי שאנו בקרוב נראה שעשינו שבועיים לפני עם ספר הטלפונים? האם יש דרכים טובות יותר כדי לפתור את בעיה מאשר כיום יש לך כאן? זה הזדמנות עבור עיצוב טוב. 

ואז style-- איך די הוא הקוד שלך? תוכל להבחין כי אני די בפרט על זחת הקוד שלי, ולוודא משתנים שלי נקראים באופן סביר. n, זמן קצר, הוא שם טוב מספר, אני עבור מספר שלם ספירה, ים עבור מחרוזת. ואנחנו יכולים להיות עוד סגנון שמות משתנים. סגנון הוא פשוט כמה טוב אין הקוד שלך נראה? ואיך קריא זה? 

פעם אחר פעם, מה עוזרי ההוראה שלך ו TFS יעשה במהלך הוא לספק לך עם זה סוג של משוב איכותי כך שאתה להשתפר היבטים שונים אלה. וגם במונחים של איך אנחנו להעריך כל אחד הצירים הללו, זה בדרך כלל עם מעט מאוד דליים, כך שאתה, בדרך כלל, לקבל תחושה של כמה טוב אתה עושה. ואכן, אם תקבל ציון על כל אלה נכונים, העיצוב axes-- וסגנון especially-- כי מספר בדרך כלל יהיה בין 1 ל -5. וגם, פשוטו כמשמעו, אם אתה מקבל 3 כבר עומד לפני תחילת הסמסטר, זה דבר מאוד טוב. זה אומר שיש עדיין מקום לשיפור, אשר היית מקווה שכן משתתף בקורס בפעם הראשונה. יש לקוות כמה קצת תקרה שאליו אתה השואף להגיע. וכך מקבל על של 3 החלקים המוקדמים, אם לא איזה 2 ו 4 של, הוא, אכן, דבר טוב. זה גם בטווח, גם בתוך ציפיות. 

ואם המוח שלך מירוץ, לחכות דקה, שלוש מתוך חמש. זה באמת מתוך 6 מתוך 10. זה 60%. אלוהים שלי, כי זהו פ 

זה לא. זה לא, למעשה, כי. במקום זאת, היא הזדמנות לשפר במהלך הסמסטר. ואם אתה מקבל כמה Poors, אלה הם הזדמנות כדי לנצל את שעות העבודה, בהחלט סעיפים ומשאבים אחרים. 

הטוב ביותר הוא הזדמנות, באמת, להתגאות רק כמה רחוק אתה כבר לבוא במהלך הסמסטר. אז מבין, אם שום דבר אחר, שלוש הם טובים. וזה מאפשר מקום לצמיחה לאורך זמן. 

באשר לאופן שבו צירים אלה הם משוקלל, מציאותי שאתה הולך לבלות את רוב הזמן שלך מקבל דברים לעבודה, שלא לדבר כראוי. וכך התקינות נוטה ישוקלל היותר, כמו עם גורם כפלי זה של שלוש. עיצוב הוא גם חשוב, אבל משהו שאתה עושה לא בהכרח לבזבז את כל השעות הללו על מנסה להשיג דברים רק כדי לעבוד. 

וכך זה משוקלל קצת יותר קל. ואז בסגנון משוקלל המעטה. למרות שזה לא פחות חשוב ביסודו, זה רק, אולי, הדבר הכי קל לעשות את הדבר הנכון, מחק את הדוגמות אנו לעשות בהרצאה וסעיף, עם דברים יפים מסוכסך, והעיר, וכן הלאה, הוא בין ההקלה דברים לעשות ולקבל זכות. אז ככזה, מבין כי אלה הם נקודות כי הם יחסית קל לתפוס. 

ועכשיו מילה על זה- יושרה אקדמית. אז לכל קורס הסילבוס, תוכלו לראות יש שהקורס די קצת שפה סביב זה. ואת כמובן לוקח את הנושא יושרה אקדמית די ברצינות. 

יש לנו את ההבחנה, לטוב או לרע, בכך הנשלח מדי שנה יותר סטודנטים להליך משמעתי יותר מרוב כל האחרים כמובן, כי אני מודע. זה לא בהכרח מעיד על העובדה שתלמידים CS, או סטודנטים CS50, הם פחות כנה יותר חברכם. אבל המציאות כי זה בעולם, אלקטרוני, אנחנו רק יש טכנולוגי פירושו של גילוי זה. 

חשוב לנו עבור גינות ברחבי הכיתה שאנחנו עושים לזהות את זה, ולגדל הנושא כאשר אנו רואים דברים. וזה רק כדי לצייר תמונה, ובאמת כדי לעזור משהו כמו כיור זה, אלה הם המספרים של סטודנטים במהלך 10 השנים האחרונות כי היו מעורבים כמה בעיות כאלה של יושרה אקדמית, עם כ -32 תלמידים מנפילה 2015, אשר הוא אומר שאנחנו לוקחים העניין מאוד ברצינות. וגם, בסופו של דבר, המספרים האלה להלחין, ולאחרונה, כ -3%, 4% בערך של הכיתה. 

אז עבור רוב מיוחס של תלמידים נראה כי הקווים ברורים. אבל אל לשמור את זה אכפת לך, במיוחד בסוף בלילה כאשר נאבק עם איזה פתרון למערכת בעיה, כי ישנם מנגנונים עבור מכניס את עצמך טוב יותר תמיכה ממה שאתה אולי חושב, אפילו באותה שעה. להבין כי כאשר אנו מקבלים הגשות מתלמידים, נחצינו להשוות את כל הטקסטים השנה נגד כל הגשה בשנה שעברה, נגד כל הגשה משנת 2007, ומאז, מסתכל, כמו גם, קוד מאגרים מקוונים, פורומי דיון, אתרי עבודה. אנו מזכירים זה, באמת, כל למען גילוי נאות, שאם מישהו אחר יכול למצוא אותו באינטרנט, בהחלט, גם אנחנו יכולים הקורס. אבל, באמת, ברוח הקורס מסתכם סעיף זה בתוכנית הלימודים. זה באמת פשוט, יהיה הגיוני. 

ואם היינו צריכים להרחיב על כך עם רק שפה קצת יותר, להבין את המהות של כל עבודה שתגיש לקורס הזה חייב להיות משלך. אבל בתוך זה, יש בהחלט הזדמנויות, ועידוד, וערך פדגוגי פונה נוספות-- עצמי, TFS, את הרשויות, TAS, ואחרים בכיתה, עבור תמיכה, לתת לחברים בלבד ו השותפים שחקרו CS ותכנות לפני. וכך יש קצבה בשביל זה. ואת ככלל אצבע זה- הוא כאשר לבקש עזרה, ייתכן להציג הקוד שלך לאחרים, אבל אתה לא יכול לצפות שלהם. אז גם אם אתה נמצא בבית שעות עבודה, או באולם D, או במקום אחר עבודה על סט פיסה, לעבוד לצד חבר, אשר זה בסדר לגמרי, בבית בסופו של יום העבודה שלך בסופו של דבר צריך להיות שייך לכל מכם בהתאמה, ולא להיות קצת מאמץ משותף, למעט פרויקט הגמר שם זה מותר ועודד. 

להבין שאם אתה נאבק עם משהו והחבר שלך פשוט קורה להיות יותר טוב בזה אז אתה, או יותר באותה בעיה ממה שאתה, או קצת לפני יותר ממה שאתה, זה לגמרי סביר להפוך לחבר שלך ולהגיד, היי, אכפת לך להסתכל הקוד שלי כאן, עוזרים לי לזהות מה הבעיה שלי היא? וגם, בתקווה, ב עניין של ערך פדגוגי חבר שעושה לא רק אומרים, אה, לעשות זאת, אלא, מה אתה חסר על קו 6, או משהו כזה? אבל הפתרון הוא לא בשביל החבר לידך לומר, נו, טוב, כאן, תן לי למשוך זה למעלה, ולהראות הפתרון שלי אליך. אז זה הקו. אתה להראות את הקוד שלך אחרים, אבל אתה לא יכול להציג את שלהם, בכפוף האחר אילוצים הסילבוס של הקורס. 

אז אל לזכור זה מה שנקרא סעיף חרטה בתוכנית הלימודים של הקורס, כמו גם, כי אם אתה להתחייב איזה מעשה כי לא סביר, אבל להביא אותו לידיעת הראשי של הקורס בתוך 72 שעות, הקורס עלול לגרור הטלת סנקציות מקומיות עשוי לכלול משביעת רצון או ציון נכשל עבור העבודה שהוגשה. אבל כמובן לא להפנות את משנה להליך משמעתי נוסף, למעט במקרים של פעולות חוזרות ונשנות. במילים אחרות, אם אתה עושה כמה בשעת לילה מאוחר טפשה, במיוחד, החלטה כי בבוקר או בימים הבאים מאוחר יותר, אתה מתעורר אל תוך המציאות, מה חשבתי לעצמי? יש לך לעשות CS50 לשקע לתיקון הבעיה כי ומחזיקים בה עד אותו, כך שנוכל יפגוש אותך באמצע הדרך ולהתמודד עם אותו עניין שהוא גם חינוך יקר בשבילך, אבל עדיין ענישה בדרך כלשהי. ועכשיו, כדי להוציא את העוקץ, זה. 

[הפעלת סרטון] 

[מוסיקה מתנגנת] 

[סוף PLAYBACK] דוד י מלאן: בסדר, אנחנו שוב. ועכשיו אנחנו מסתכלים אחד הראשון של תחומים בעולם האמיתי שלנו ב CS50, אמנות קריפטוגרפיה, אמנות שליחה וקבלה מסרים סודיים, מוצפן הודעות אם תרצה, כי יכול להיות מפוענח רק אם אתה צריך כמה מרכיב עיקרי שהשולח יש גם כן. אז להניע זה ניקח מבט על זה כאן, המהווה דוגמה טבעת מפענח סוד ניתן להשתמש על מנת להבין איזה מסר סודי באמת. למעשה, חזרה יום בבית הספר היסודי, אם אי פעם שלחו מסרים סודיים חבר כמה או כמה למעוך בכיתה, אפשר לחשוב היית להיות חכם ידי על שינוי פיסת נייר שלך, כמו, A ל- B, ו- B ל- C, ו- C ל D, וכן הלאה. אבל אתה בעצם הצפנה המידע שלך, אפילו אם זה היה קצת טריוויאלי, לא היה קשה כי למורה להבין, טוב, אם אתה רק לשנות B ל- A ו- C ל- B, אתה בעצם להבין מה המסר היה, אבל היית הצפנת מידע. 

אתה פשוט עושה את זה פשוט, בדומה ראלפי כאן בסרט מפורסם שמנגן פחות או יותר nauseum מודעה בכל חורף. [הפעלת סרטון] -Be זה ידוע לכל כי ראלף פארקר בזאת מינה חבר ליטל אנני היתומה הסוד מעגל והוא זכאי לכל הכיבודים והטבות המתרחשות לכך. 

-Signed, אנני היתומה הקטנה, נגד חתם פייר אנדרה, בדיו. בהצטיינות והטבות, כבר בגיל תשע. 

[צעקות] -בחייך. בואו נגמור עם זה. אני לא צריך את כל השטויות האלה על מבריחים ופיראטים. 

מחר בלילה "תשמע עבור ההרפתקה המסכמת של ספינת פירטים השחורה. עכשיו, הגיע הזמן המסר הסודי של אנני בשבילך חברי המעגל הסודי. זכור, ילדים, רק חברים של המעגל הסודי של אנני יכול לפענח את המסר הסודי של אנני. 

זכרו, אנני תלויה בך. גדר הסיכות שלך B2. הנה ההודעה. 12, 11-- 

'אני ב, הפגישה החשאית הראשונה שלי. 

-14, 11, 18, 16. 

-Pierre היה לילה קול גדול. יכולתי לספר שהלילה של המסר היה באמת חשוב. 

-3, 25, זה הודעה מ אנני עצמה. זכור, אל תספרו לאף אחד. 

-90 שניות מאוחר יותר, אני היחיד חדר בבית שבו ילד בן תשע יכולתי לשבת בפרטיות ולפענח. אהה, לינה! הלכתי הבא, E. 

המילה הראשונה היא להיות. S, זה היה מגיע יותר קל עכשיו, U, 25-- 

אה, בחייך, ראלפי, אני חייב ללכת! 

-I'll יורד מיד, מא! מצוץ מן האצבע! 

-T, O, להיות בטוח עם-- הקפד מה? מה הייתה יתומה קטנה אנני מנסה לומר? הקפד מה? 

-Ralphie, אנדי חייב ללכת, האם תוכל בבקשה לצאת? 

תקין -כל, מא! אני אהיה החוצה מימין! 

-אני מקבל עכשיו קרוב. המתח היה נורא. מה זה היה? גורלו של כדור הארץ עשוי להיות תלוי ועומד. 

-Ralphie! בנאדם של אנדי ללכת! 

-I'll להיות ישר, עבור בוכה בקול רם! 

-Almost שם, אצבעותיי טסות, דעתי מלכודת הייתה פלדה, כל נקבובי רטט. זה היה כמעט ברור, כן, כן, כן. 

-Be הקפידו לשתות שוקו שלך. שוקו? פרסומת עלובה? בֶּן כַּלבָּה. [סוף PLAYBACK] דוד י מלאן: אוקיי, אז זה היה דרך ארוכה מאוד של החדרת קריפטוגרפיה, וגם שוקו. למעשה, מן הפרסומת הישנה הזאת כאן, למה הוא שוקו כל כך טוב? זהו מיצוי מרוכז של בשלות לתת שעורה, חלב פרה שמנת טהורה, והכן קקאו במיוחד, יחד עם phosphatides וויטמינים טבעיים. היא היתה מבוצרת נוספת עם ויטמינים נוספים B ו- D, יאם. ואתה עדיין יכול לקבל את זה, כנראה, באמזון, כפי שעשינו כאן. 

אבל המוטיבציה כאן הייתה להציג קריפטוגרפיה, במיוחד סוג של הצפנה ידוע כמו הצפנה במפתח סודית. וכפי שהשם מרמז, כל אבטחת מידע של מערכת הצפנת מפתח סודית, אם תרצו, מתודולוגיה רק ערבול מידע בין שני אנשים, הוא רק השולח והנמען בלבד מכיר key-- סוד ערך כלשהו, ​​כמה ביטוי סוד, כמה מספר סודי, כי מאפשר להם הוא להצפין ולפענח מידע. קריפטוגרפיה, באמת, הוא רק זה משבוע 0. 

זוהי בעיה שבה יש תשומות, כמו המסר בפועל באנגלית או בכל שפה שאתה רוצה לשלוח למישהו בכיתה, או דרך האינטרנט. יש פלט כמה, שהוא הולך להיות את ההודעה המקושקשת שאתה רוצה הנמען לקבל. וגם אם מישהו באמצע מקבל את זה יותר מדי, אתה לא רוצה אותם בהכרח להיות מסוגל לפענח אותו, כי בתוך זה קופסה שחורה, או אלגוריתם, הוא מנגנון כלשהו, ​​צעד אחר צעד הוראות, על שהקדשת קלט המרת אותו לתוך פלט, ב בתקווה בצורה מאובטחת. 

ואכן, יש כמה אוצר המילים בעולם הזה כדלקמן. טקסט רגיל הוא המילה מדען מחשבים היו להשתמש בו כדי לתאר את הקלט הודעה, כמו אנגלית או בכל שפה שאתה בעצם רוצה לשלוח כמה אדם אחר. ואז המוצפן הוא לטרוף אל המוצפן, או מוצפן, הגרסה שלו. 

אבל יש מרכיב אחד אחר כאן. יש קלט אחת אחר הצפנה במפתח סודי. וזה המפתח עצמו, שהוא, בדרך כלל, כפי שנראה בהמשך, מספר, או מכתב או כל מילה, מה האלגוריתם הוא בעצם מצפה. 

ואיך אתה לפענח מידע? איך אתה לפענח את זה? ובכן, אתה פשוט להפוך את תפוקות ואת התשומות. 

במילים אחרות, פעם מישהו מקבלת ההודעה המוצפנת שלך, הוא או היא פשוט לדעת אותו מפתח. הם קיבלו את ההודעה המוצפנת. ועל ידי חיבור שני אלה תשומות למערכת ההצפנה, האלגוריתם, קופסה שחורה זו, החוצה צריך לבוא בטקסט המקורי. וכך זה ברמה מאוד גבוהה קריפטוגרפיה לאור מה היא בעצם הכול על. 

אז בואו להגיע לשם. עכשיו בואו נראה מתחת מכסה המנוע של משהו אנחנו כבר לוקחים כמובן מאליו עבור בשבוע האחרון, ועל בפגישה זו כאן-- המחרוזת. מחרוזת בסוף היום רק הוא רצף של תווים. 

זה יכול להיות שלום עולם, או שלום Zamyla, או מה שלא יהיה. אבל מה המשמעות של הדברים הללו להיות רצף של תווים? למעשה, ספריית CS50 נותנת לנו טיפוס בשם מחרוזת. 

אבל יש למעשה שום דבר כזה כמחרוזת ב C. זה באמת רק רצף של אופי, אופי, אופי, אופי, חזרה, אל גב, כדי בחזרה, לגבות, לגבות בתוך של זיכרון המחשב שלך, או זיכרון RAM. ואנו להסתכל עמוק לתוך כי בעתיד כאשר נתבונן הזיכרון עצמו, ואת הניצול, ואת איומים כי הם מעורבים. 

אבל הבה נבחן את המחרוזת Zamyla. אז רק בשם האדם כאן, Zamyla, כי הוא רצף של תווים, ת-א-M-Y-L-A. ועכשיו הבה נניח כי שמו של Zamyla מאוחסן בתוך מחשב תָכְנִית. 

ובכן, זה מתקבל על הדעת, כי במקרה שבו אנו להיות מסוגל להסתכל על הדמויות האלה בנפרד. אז אני רק הולך לצייר קצת תיבה מסביב שמו של Zamyla כאן. וזה המקרה ב- C שכשאתה יש מחרוזת, כמו Zamyla-- ואולי מחרוזת כי יש לחזור מ פונקציה כמו מחרוזת גט, למעשה אתה יכול לתמרן אופי זה של דמות. 

עכשיו, זה רלוונטי עבור השיחה בהישג יד, כי בהצפנה אם אתה רוצה לשנות A ל- B, ו- B ל- C, ו- C ל D, וכן הלאה, אתה צריך להיות מסוגל להסתכל על תווים בודדים במחרוזת. אתה צריך להיות מסוגל לשנות ה- Z למשהו אחר, א למשהו אחר, יג משהו אחר, וכן הלאה. וכך אנחנו צריכים דרך, תוכניתי, כך לדבר, ב- C כדי להיות מסוגל לשנות ולהסתכל אותיות בודדות. ואנחנו יכולים לעשות את זה כדלקמן. 

תן לי ללכת לחזור ב IDE CS50. ותן לי ללכת קדימה וליצור קובץ חדש שאני אתקשר string0 הפעם, כמו למשל כאלה הראשונים שלנו, נקודת ג. ואני הולך קדימה להלהיב אותו כדלקמן. 

אז לכלול CS50.h, ו ואז לכלול io.h סטנדרטי, אשר אני כמעט תמיד הולך להיות באמצעות בתוכניות שלי, לפחות בהתחלה. int void main, ולאחר מכן כאן אני הולך לעשות מחרוזות מקבל מקבל מחרוזת. ואז אני הולך אתם מוזמנים לעשות זאת. אני רוצה ללכת קדימה ו, כבדיקת שפיות, רק לומר, שלום, s אחוזים, פסיק, עושה מחרוזת 0. אוי, מה עשיתי כאן? הו, אני לא תקעתי את זה. אז כלקח, כי לא היה בכוונה. 

אז טעות, יותר אחוזים מרות מ טיעוני נתונים. וכאן, ב קו 7-- אוקיי, אז יש לי, ציטוט סוף ציטוט, זה המחרוזת שלי printf. יש לי סימן אחוזים. אבל אני חסרתי את הטענה השנייה. 

אני חסר פסיק הים, אשר אני לא צריך בדוגמאות הקודמות. אז הזדמנות טובה לתקן עוד טעות, בטעות. ועכשיו תן לי לרוץ string0, הקלד Zamyla. אוקיי, שלום Zamyla. 

אז שביצענו סוג זה של התוכנית עכשיו כמה פעמים שונות. אבל בוא נעשה משהו קצת שונה הפעם. במקום סתם הדפסת Zamyla של שם כולו החוצה עם printf, בואו נעשה את זה תו אחרי תו. 

אני הולך להשתמש בלולאת for. ואני הולך לתת את עצמי משתנה ספירה, שנקרא i. ואני מתכוון להמשיך ולביקורות, כך כל עוד אני הוא פחות מאורך של הים. 

מתברר, עשינו לא לעשות בפעם האחרונה זה, ג שמגיע עם פונקציה שנקראת סטירלינג. חזרה היום, ובאופן כללי עדיין בעת ​​יישום פונקציות, בני האדם יעדיפו מאוד שמות תמציתיים זה סוג של צליל כמו מה שאתה רוצה, למרות שזה חסר תנועות או אותיות. אז סטירלינג היא שם פונקציה לוקח ויכוח בין בסוגריים כי צריך להיות מחרוזת. וזה רק מחזיר מספר שלם, לכל האורך של מחרוזת. 

אז זה עבור לולאה על קו 7 הולך להתחיל לספור ב i שווה 0. זה הולך להגדיל אני בכל איטרציה על ידי 1, כפי שאנו כבר עושים כמה פעמים. אבל זה הולך רק לעשות זאת עד לנקודה כשאני הוא האורך של המחרוזת עצמה. 

אז זה הוא דרך, בסופו של דבר, iterating על התווים במחרוזת הוא כדלקמן. אני הולך להדפיס את לא מחרוזת שלמה, אבל ג אחוזים, תו בודד ואחריו בשורה חדשה. ואז אני הולך קדימה, ואני צריך להגיד אני רוצה להדפיס אופי ה- i של הים. 

אז אם אני הוא המשתנה המציין המדד של המחרוזת, שם אתם מתחברים אליה, אני צריך להיות מסוגל לומר, תן לי את אופי ה- i של הים. ו- C יש דרך לעשות זה עם סוגריים מרובעים. אתה פשוט אומר את השם של מחרוזת, אשר במקרה זה היא של. ואז אתה משתמש בסוגריים מרובעים, אשר הם בדרך כלל קצת מעל ההחזר או זן מקש במקלדת. ואז אתה מכניס את האינדקס של תו שברצונך להדפיס. אז המדד הולך להיות 0 number--, או 1, או 2, או 3, או נקודה, נקודה, נקודה, ממספר אחר. 

ואנחנו להבטיח כי זה הולך להיות את המספר הנכון, כי אני מתחילים לספור ב 0. ו כברירת מחדל, התו הראשון במחרוזת הוא לפי האמנה 0. ואת הדמות השנייה היא תושבת 1. ואת הדמות השלישית היא תושבת 2. ואתה לא רוצה ללכת יותר מדי כה, אבל אנחנו לא כי אנחנו הולך להגדיל i עד רק שווה אורך החוט. ו ובנקודה, זה עבור לולאה יפסיק. 

אז תנו לי להמשיך ולשמור זה התוכנית, וברח להפוך מחרוזת 0. אבל אני דפוק. במשתמע להכריז פונקצית ספרייה סטירלינג עם סוג כזה such-- עכשיו, זה נשמע מוכר. אבל זה לא printf. וזה לא מקבל מחרוזת. 

אני לא לפשל ב באותו אופן הפעם. אבל לב נרד עוד קצת למטה נוסף, כולל בכותרת string.h, במפורש לספק את הכרזה על סטירלינג. אז יש בעצם רמז לשם. 

ואכן מתברר יש עוד כותרת קובץ כי אנחנו כבר לא בשימוש בכיתה עדיין, אבל זה בין אלה זמינים לך, בשם string.h. ובאותו קובץ, string.h הוא סטירלינג הכריז. אז תן לי ללכת קדימה לחסוך זה, לעשות מחרוזת 0-- נחמד, לא הודעות שגיאה הפעם. 

./string0 Zamyla, ו אני עומד על Enter, ובנקודה getstring הולך להחזיר את המחרוזת, לשים אותו הים. אז עבור לולאה הולך לחזר על הדמויות של S אחד בכל פעם, ולהדפיס אותן אחת בשורה, כי היה לי כי מהלך סרק n בסוף. אז יכולתי להשמיט כי מהלך סרק n, ולאחר מכן פשוט להדפיס Zamyla כל באותה השורה, מימוש מחדש ביעילות printf, וזה לא כל כך שימושי. אבל במקרה הזה, אני כבר לא עושה את זה. אני כבר מודפס למעשה אחד דמות בכל פעם, אחד בכל שורה, כך שאנחנו באמת לראות את ההשפעה. 

אבל אני צריך לציין דבר אחד כאן. ואנחנו נחזור זה בעוד שבוע בעתיד. מתברר כי זה הקוד הוא פוטנציאל מרכבה. 

מתברר כי מחרוזת גט וכמה פונקציות אחרות בחיים לא בהכרח תמיד להחזיר את מה שאתה מצפה. אנחנו יודעים מהכיתה אחרונה זמן זה מניב המחרוזת אמורה להחזיר מחרוזת. אבל מה אם המשתמש מקליד את כזה מילה ארוכה, או פסקה, או מסה כי יש רק לא מספיק זיכרון במחשב כדי להתאים אותו. 

כאילו, מה אם משהו הולך בסדר מתחת למכסה המנוע? אולי זה לא קורה לעיתים קרובות, אבל זה יכול לקרות פעם בכמה זמן, לעתים רחוקות מאוד. וכך מתברר כי מחרוזת גט פונקציות כמו זה לא בהכרח תמיד לחזור מחרוזות. הם עלולים לחזור כמה ערך שגיאה, כמה ערך זקיף כביכול, המציין משהו השתבש. ואתה רק היה יודע את זה לאחר שלמד את זה בכיתה עכשיו, או שיש לקרוא קצת תיעוד יותר. מתברר כי מחרוזת גט יכול להחזיר ערך שנקרא null. ריק הוא ערך מיוחד שנוסיף לחזור בעוד שבוע בעתיד. אבל לעת עתה, רק יודע שאם אני רוצה להיות באמת ראוי לנוע קדימה באמצעות מחרוזת מקבל, אני לא צריך פשוט לקרוא לזה, ו בעיוורון להשתמש ערך ההחזרה שלו, אמון שזה מחרוזת. 

אני צריך לומר קודם, היי, חכה רגע, רק להמשיך אם הים לא שווה null, null שם, שוב, הוא רק חלק ערך מיוחד. וזה הערך המיוחד רק לך צריך לדאוג עבור מחרוזת גט. קבל מחרוזת או הולכת להחזיר מחרוזת או null. 

וזה סימן קריאה זה סימן שוויון אתה אולי יודע מ אולי בשיעור מתמטיקה כי אתם יכולים לצייר סימן שוויון עם קו דרכו כדי לציין לא שווה. זה לא בדרך כלל דמות תוכל להקליד במקלדת. וכך בשפות תכנות ביותר, כשרוצים לומר לא שווה, אתה משתמש בסימן קריאה, הידוע גם בשם המפץ. אז אתה אומר מפץ שווה, אשר פירושו לא שווה, באופן הגיוני. זה בדיוק כמו שיש לא יותר מ או שווה, פחות או יותר או שווה ל מקש במקלדת שעושה את כל זה ב סמל אחד. אז זאת הסיבה, בדוגמאות האחרונות, עשית סוגר פתוח, ולאחר מכן סימן שוויון, על מנת לעשות גדול או, לומר, פחות. 

אז מה takeaway כאן? זוהי פשוט דרך החברה של החדרת תחביר זה, תכונה זו, iterating מעל הפרט תווים במחרוזת. ובדיוק כמו אלה מרובעים בסוגריים מאפשרים לך להגיע אליהם, לשקול אלה בסוגריים מרובעים כמו סוג של הרמז בסיסי זה עיצוב, לפיה מחלקים מדי דמות בתוך מחרוזת סוג של הוא התאגרף ב איפשהו מתחת למכסה המנוע בזיכרון של המחשב שלך. 

אבל בואו נעשה את וריאנט של זה. מתברר כי זה התכנית נכונה. אז לכל הצירים של CS50 להערכה קוד, זה נכון עכשיו. בייחוד עכשיו, אני בודק עבור null, תכנית זו לא צריכה לקרוס. ואני פשוט יודע את זה מניסיון. אבל אין שום דבר אחר כי אנחנו באמת יכולים להשתבש כאן. אבל זה לא מאוד מעוצב היטב, כי בואו לחזור ליסודות. 

ראשית, principles-- מה עושה עבור לולאה לעשות? עבור לולאה עושה שלושה דברים. זה מאתחל כמה ערך, אם תשאל אותו. הוא בודק מצב. ואז אחרי כל איטרציה, לאחר כל מחזור, זה מגדיל קצת ערך, או ערכים, כאן. 

אז מה זה אומר? נאתחל i ל -0. אנו לבדוק ולוודא i הוא פחות מ אורך חרא, שזו-A-M-Y-L-A Z, כך שהוא פחות מ -6. ואכן, 0 כפחות מ -6. 

אנו להדפיס Z מהשם של Zamyla. אז אנחנו מגדילים i בין 0 ל -1. לאחר מכן, אנו לבדוק, היא 1 פחות המאור של הים? אורכו של הים הוא 6. כן זה כן. 

אז אנחנו להדפיס בשם Zamyla, כז. אנחנו להגדיל i בין 0, 1, 2. לאחר מכן, אנו לבדוק, היא 2 פחות אורך שמו של Zamyla. 6- כך 2 הוא פחות מ -6. כן, בואו להדפיס חברת M ב שמו של Zamyla, הדמות השלישית. 

המפתח כאן הוא כי על כל איטרציה של הסיפור, אני בודק, הוא אני פחות מאורך של Zamyla? אבל לתפוס את זה סטירלינג אינו רכוש. אלה מכם שיש להם מתוכנת לפני ב- Java או בשפות אחרות יכול לדעת את האורך של מחרוזת היא נכס, רק חלק לקרוא את הערך בלבד. 

ב C במקרה זה, אם זה פונקציה שהיא פשוטו כמשמעו ספירת מספר תווי Zamyla בכל פעם אנו קוראים לפונקציה זו. בכל פעם אתה שואל את המחשב להשתמש סטירלינג, זה לוקח מבט Zamyla, ואומר ת-א-M-Y-L-A, 6. וזה מחזיר 6. בפעם הבאה שאתה קורא זה בפנים כי עבור לולאה, זה הולך להסתכל Zamyla שוב, אומר ת-א-M-Y-L-A, 6. וזה הולך לחזור 6. אז מה טיפשי על העיצוב הזה? 

למה הקוד שלי לא 5 מתוך 5 עבור עיצוב עכשיו, אם אפשר לומר כך? ובכן, אני שואל שאלה שלא לצורך. אני עושה יותר עבודה ממה שאני צריך. 

אז למרות התשובה היא נכונה, אני לשאול את המחשב, מה הוא אורך Zamyla שוב, ושוב, ושוב, ושוב? והתשובה כי הוא לא הולך להשתנות. זה תמיד הולך להיות 6. 

אז פתרון יותר טוב מזה יהיה הגרסה הבאה זה. תן לי ללכת קדימה ולשים אותו בקובץ נפרד בשם string1.c, רק כדי לשמור אותו בנפרד. ומתברר בתוך עבור לולאה, אתה יכול למעשה להכריז על משתנים מרובים בבת אחת. 

אז אני הולך לשמור i ולהגדיר אותו 0. אבל אני גם הולך להוסיף פסיק, ולומר, תן לי משתנה בשם n, אשר ערך שווה מחרוזת באורך של s. ועכשיו, בבקשה לעשות במצב שלי כל עוד אני נמצא במרחק של פחות מ n. 

אז בדרך זו, ההיגיון הוא זהה בסוף היום. אבל אני זוכר את ערך 6, במקרה זה. מהו האורך של שמו של Zamyla? ואני מנסה את זה בבית n. 

ואני עדיין בודק התנאי בכל פעם. האם 0 פחות מ -6? האם 1 פחות מ 6? האם 2 פחות מ -6, וכן הלאה? 

אבל אני לא מבקש את המחשב שוב, ושוב, מה אורך שמו של Zamyla? מה האורך של שמו של Zamyla? מה האורך של שמו של Zamyla זה? אני ממש שאני זוכר כי ראשון רק לענות n המשתנה השני זה. אז זה עכשיו יהיה לא רק נכון, אבל גם מעוצב היטב. 

עכשיו, מה עם סגנון? אני כבר בשם המשתנה שלי די טוב, הייתי אומר. הם סופר תמציתיים עכשיו. וזה לגמרי בסדר. 

אם יש לך רק אחד מחרוזת בתוכנית, באותה מידה אתה יכול לקרוא לזה s עבור מחרוזת. אם יש לך רק משתנה אחד לספירה בתכנית, באותה מידה אתה יכול לקרוא את זה אני. אם יש לך אורך, n סופר נפוץ גם הוא. אבל אני לא הגבתי כל הקוד שלי. 

אני כבר לא הודעתי reader-- אם זה TF שלי, או TA, או סתם colleague-- מה שאמור להיות קורה בתוכנית זו. וכך לקבל סגנון טוב, מה הייתי רוצה לעשות זה-- משהו כמו לבקש מהמשתמש קלט. ואני יכול לשכתב זה בכל מספר דרכים. 

ודא s-- לעשות גט בטוח מחרוזת חזרה מחרוזת. ואז ב כאן-- וזו אולי לחזר comment-- החשוב ביותר על הדמויות של אחד בכל פעם. ואני יכול להשתמש בכל הבחירה של השפה האנגלית כאן לתאר כל של קטעים אלה של קוד. 

שימו לב שלא שמתי להגיב על כל שורת קוד אחת, באמת רק על המעניין אלה, אלה יש משמעות כלשהי שאני עלול רוצה לעשות סופר ברור למישהו קריאת הקוד שלי. ולמה אתה מתקשר לקבל מחרוזת לבקש מהמשתמש קלט? גם כי אחד אינו בהכרח כל תיאורים. אבל זה עוזר לספר סיפור, כי הקו השני בסיפור הוא, לוודא מחרוזת לקבל חזרה מחרוזת. 

והשורה השלישית בסיפור הוא, לחזר על הדמויות של אחד בכל פעם. ועכשיו רק למען הסדר הטוב, אני הולך קדימה ולהוסיף הערה אחת נוספת כי רק אומר אופי i-ה הדפסה שבסעיף. עכשיו, מה עשיתי בסופו של היום? 

הוספתי קצת אנגלית מילים בצורת הערות. סמל לוכסן לוכסן אומר, היי, המחשב הזה הוא עבור האדם, לא בשבילך, המחשב. אז הם התעלמו באופן הגיוני. הם פשוט שם. 

ואכן, CS50 IDE מציגה אותם אפור, כמו להיות שימושי, אבל לא מפתח לתוכנית. שים לב מה אתה יכול לעשות עכשיו. בין אם אתה יודע C תכנות או לא, אתה יכול רק לעמוד מנגד בשעה זו התוכנית, ולקרוא את ההערות. בקש ממשתמש קלט, לוודא מחרוזת לקבל חזרה מחרוזת, לחזר על הדמויות של אחד בכל פעם, להדפיס את הדמות i-ה דמות s-- אתה לא יש אפילו להסתכל על הקוד להבין מה התוכנית הזו עושה. וגם, יותר טוב, אם אתה עצמך נראה על תכנית זו בעוד שבוע או שניים, או חודש, או שנה, אתה גם לא צריך לבהות קוד, מנסה להיזכר, מה שניסיתי לעשות עם הקוד הזה? 

ספרת עצמך. תיארת את זה בעצמך, או מעמיתיה, או TA, או TF. וכך זה אמור היה להסתיים בשלב בתכנון נכון, וטוב, ובסופו של דבר טוב סגנון וכן. אז לעשות לזכור את זה. 

אז יש אחד אחר דבר אני הולך לעשות כאן שיכולים כעת לחשוף בדיוק מה קורה מתחת למכסה המנוע. אז יש במאפיין זה ב- C, ובשפות אחרות, לליהוק שחקנים בשם כי באופן בלתי מודע או במפורש מאפשר לך להמיר מן סוג נתונים אחד למשנהו. אנחנו כבר עוסקים כל כך רחוק היום עם מחרוזות. 

ומחרוזות הם תווים. אבל זוכר משבוע 0, מה הן הדמויות? הדמויות הן רק הפשטה על גבי מספרים עשרוניים numbers--, ומספרים עשרוניים הם באמת רק הפשטה על גבי מספרים בינאריים, כפי שהגדרנו אותו. 

אז הדמויות הם מספרים. ומספרי תווים, רק בהתאם להקשר. ומתברר כי בתוך של תוכנת מחשב, אתה יכול לציין כיצד אתה רוצה להיראות על החלקים פנימיים של התכנית? 

כזכור משבוע 0 שהיה לנו ASCII, וזה רק את הקוד הזה אותיות מיפוי למספרים. ואמרנו, בירה היא 65. B Capital הוא 66, וכן הלאה. 

ושים לב, בעצם יש לנו תווים על בשורה העליונה כאן, כמו C תקרא להם, תווים, ולאחר מכן ints בשורה השנייה. ומתברר אתה יכול להמיר בין שתיים בצורה חלקה, בדרך כלל. ואם אנחנו רוצים לעשות זה נעשה באופן מכוון, אנו אולי כדאי לך להתמודד משהו כזה. 

אנחנו אולי רוצים להמיר רישית להנמיך במקרה, או אותיות קטנות לאות רישית. ומתברר של שם למעשה כאן דפוס אנו יכולים לאמץ בעוד רגע. אבל בואו נסתכל הראשון בבית דוגמה עושה את זה במפורש. 

אני הולך לחזור אל IDE CS50. אני הולך ליצור קובץ בשם Ascii 0.c. ואני הולך קדימה ולהוסיף שלי io.h תקן בראש, void main int בחלק העליון של הפונקציה שלי. ואז אני פשוט הולך לעשות את following-- ללולאת for מ- i שווה, נניח, 65. 

ואז אני הולך להיות פחות מ 65, בתוספת 26 אותיות האלפבית. אז אני נותן את המחשב לעשות את המתמטיקה לי שם. ואז בתוך לולאה זו, מה אני הולך להדפיס? 

ג% הוא% i מהלך סרק n. ועכשיו אני רוצה לחבר שני ערכים. שמתי זמני שאלה מסמן שם כדי להזמין את השאלה. 

אני רוצה לחזר מ -65 ואילך במשך 26 אותיות האלפבית, בהדפסה של כל איטרציה כי שווה הערך הנפרד של הדמות. במילים אחרות, אני רוצה לחזר על 26 מספרים הדפסה מהו תו ASCII, המכתב, ומה את המספר המתאים אז-- באמת רק יצירה מחדש בתרשים משקופית זה. אז מה צריך סימני שאלה אלה להיות? 

ובכן, מתברר כי שני אחד צריך להיות רק אני משתנה. אני רוצה לראות את זה בתור מספר. וגם את הטענה באמצע כאן, אני יכול לומר למחשב לטיפול שלם כי אני כדמות, כדי להחליף אותו כאן אחוז ג 

במילים אחרות, אם אני, מתכנת אדם, לדעת אלה הם מספרים בלבד בסופו של היום. ואני יודע כי 65 צריכים ממופה איזו דמות. עם גבס מפורש זו, עם סוגריים, השם של סוג הנתונים שברצונך להמיר, ו סוגריים סגורים, אתה יכול לספר את מחשב, היי, מחשב, להמיר מספר שלם זה על char. 

אז כאשר אני מפעיל זה התוכנית לאחר קומפילציה, בוא נראה מה אני להתרגל-- לעשות Ascii 0. אוף זה, מה עשיתי לא בסדר כאן? שימוש מזהה מוצהר, בסדר, לא מכוון, אבל בוא נראה אם ​​אנחנו לא יכולים הסיבה דרך זו. 

אז קו five-- אז אני לא מקבל רחוק מאוד לפני לפשל. זה בסדר. אז קו 5 עבור i שווה 65-- אני רואה. אז לזכור כי ב- C, בניגוד לכמה בשפות אם יש לך תכנות מראש ניסיון, אתה צריך כדי להורות למחשב, בניגוד Scratch, מה סוג של משתנה זה. 

ושכחתי ביטוי המפתח כאן. בתור חמש, אני כבר התחלתי להשתמש i. אבל לא סיפרתי C איזה סוג נתונים זה. אז אני הולך להיכנס פה אומרים, אה, להפוך אותו שלם. 

עכשיו אני הולך קדימה, להדר מחדש. כי תיקנו את זה. ./ascii0 הזן, זה די מגניב. לא רק שזה סופר מהיר כדי שאל את המחשב על שאלה זו, ולא לחפש אותו בשקופית, זה הדפיס אחת בכל שורה, A הוא 65, B הוא 66, כל הדרך down-- מאז שאני עשו זאת 26 times-- אל z מכתבים, המהווה 90. ואכן, מעט יותר אינטליגנטי היה היה לי לא להסתמך במחשב כדי להוסיף 26. יכולתי רק לעשות 90 וכן, כל כך הרבה זמן כמו שאני לא עושה את אותה טעות פעמיים. אני רוצה לעלות דרך z, לא רק דרך y. 

אז זה קאסט מפורש. מתברר כי זה לא הוא אפילו הכרחי. תן לי להמשיך בשידור חוזר זה מהדר, שידור חוזר Ascii 0. מתברר כי C הוא די חכם. 

ו printf, בפרט, הוא די חכם. אם אתה פשוט לעבור i פעמיים עבור שני מצייני מיקום, printf תבין, הו, אני מכיר אותך נתנו לי integer-- מספר מסוים, כמו 65, או 90, או מה שלא יהיה. אבל אני רואה שאתה רוצה שאני תבנית מספר כי כמו דמות. וכך printf יכול להטיל במרומז int ל char גם בשבילך. אז זה לא בעיה בכלל. 

אבל שם לב, בגלל שקילות זו אנחנו באמת יכולים לעשות את זה גם כן. תן לי להמשיך ולעשות אחד גרסה אחרת של זה- Ascii 1 ג ובמקום iterating מעל מספרים שלמים, יכול באמת מכה את דעתך על ידי iterating על הדמויות. אם ג char מקבל הון, אני רוצה להמשיך לעשות את זה, כל עוד C הוא פחות או שווה עד Z. הון על כל איטרציה אני רוצה להגדיל C, אני יכול עכשיו בתור printf שלי כאן למשל, אחוז C הוא אחוז אני שוב, פסיק ג 

ועכשיו, אני יכול ללכת לכיוון השני, ליהוק הדמות במפורש למספר שלם. אז, שוב, למה אתה עושה את זה? זה קצת מוזר למיין של לספור מבחינת הדמויות. 

אבל אם אתה מבין מה קורה מתחת למכסה המנוע, באמת אין קסם. אתה רק אומר, היי, המחשב לתת לי משתנה בשם ג 'מסוג char. לאתחל אותו א ההון לב עניין בגרשיים בודד. 

לקבלת תווים ב- C, שזכור בשבוע שעבר, אתה משתמש בגרשיים בודדים. עבור מחרוזות, מילים, ביטויים, אתה משתמש במרכאות כפולות. אישור, מחשב, ימשיך לעשות את זה, אז עוד התו הוא פחות מ או שווה ל z. ואני יודע משולחן Ascii שלי שכל של קודי ASCII אלה הם רציפים. 

אין פערים. אז זה רק דרך Z, מופרד על ידי כל מספר אחד. ואז אני יכול להגדיל לדמות יש, אם אני באמת רוצה. בסופו של היום, זה רק מספר. אני יודע את זה. אז אני יכול רק להניח להוסיף 1 אליו. 

ואז הפעם, אני מדפיס ג, ואז המקבילה הנפרדת. ואני אפילו לא צריך להפיל המפורש. אני יכול לתת printf ואת דברי דמות מחשב החוצה, כך שכעת אם אני רץ להפוך Ascii1./ascii1, אני מקבל בדיוק את אותו הדבר גם כן. 

תוכנית חסרת תועלת, though-- אף אחד הולך לכתוב בעצם תוכנה כדי להבין, מה היה מספר הממפה ל A, או B, או Z? אתה פשוט הולך בגוגל, או לבדוק את זה באינטרנט, או לבדוק את זה בשקופית, או משהו דומה. אז איפה זה עושה בעצם לקבל שימושי? 

ובכן, כבר מדברים על זה שקופיות, שימו לב שיש דפוס בפועל כאן בין רישיות וקטן כי לא היה מקרי. להבחין כי ההון הוא 65. אותיות קטנות a הוא 97. וכמה רחוק הוא במקרה נמוך יותר? 

אז 65 הוא כמה צעדים מן 97? אז 97 מינוס 65 הוא 32. אז הון הוא 65. אם אתה מוסיף 32 לזה, אתה מקבל באותיות קטנות a. וגם, באופן שקול, אם מחסר 32, לך לחזור ההון לזה-- אותו עם B ל- B הקטן, גדול C ל- C מעט. 

כל הפערים האלה הם 32 זה מזה. עכשיו, זה היה נראה מאפשר לנו לעשות משהו כמו Microsoft Word, או Google Docs תכונה, איפה אתה ניתן לבחור כל דבר, ואז אומרים, לשנות את כל לאותיות קטנות, או לשנות את כל לאות רישית, או לשנות רק את המילה הראשונה משפט לאות רישית. אנחנו יכולים בעצם לעשות משהו ככה עצמנו. 

תן לי להמשיך לשמור קובץ כאן נקרא לנצל 0.c. ועכשיו בואו נלך קדימה להלהיב תכנית שעושה בדיוק את זה כדלקמן. אז לכלול ספריית CS50. וכולל I / O סטנדרטי. 

ואני יודע שזה יהיה זמין בקרוב. אז אני הולך לשים את זה יש כבר, string.h, אז יש לי גישה דברים כמו סטירלינג, ואז int void main, כרגיל. ואז אני הולך קדימה ולעשות מחרוזות מקבל מקבל מחרוזת, רק כדי לקבל מחרוזת מהמשתמש. ואז אני הולך לעשות בדיקת השפיות שלי. אם המחרוזת לא null השווה, אז זה בטוח להמשיך. ומה לעשות מה שאני רוצה לעשות? אני הולך לחזר מ- i שווה 0, ו n עד מחרוזת באורך של s. 

ואני הולך לעשות את זה כל עוד אני הוא פחות מ n, ואני פלוס פלוס. עד כה, אני באמת רק לשאול רעיונות מלפני. ועכשיו אני הולך להכניס ענף. 

אז נזכרתי Scratch, שם היו לנו מזלגות אלה על הכביש, ובשבוע שעבר ב C. אני הולך להגיד את זה, אם הדמות i-ה שבסעיף הוא גדול או שווה לאותיות קטנות a, ו-- ב Scratch שהיית ממש לומר, אבל ב- C אתה אומר אמפרסנד, ampersand-- והאופי-ה i שבסעיף הוא פחות מ z לאותיות קטנות או שווה, בוא נעשה משהו מעניין. בואו למעשה להדפיס אופי ללא שורה חדשה כי הוא הדמות במחרוזת, הדמות i-ה במחרוזת. 

אבל בואו נלך קדימה להחסיר 32 ממנו. אחר אם התו מחרוזת שאנחנו מחפשים הוא לא בין קצת ומעט z, קדימה ופשוט הדפיס אותו החוצה ללא שינוי. אז השקנו כיתוב בסוגריים זה עבור המחרוזות שלנו להגיע לחקר i-ה תו במחרוזת. 

הוספתי קצת היגיון מותנה, כמו Scratch בשבוע אחד בשבוע שעבר, שבו אני רק באמצעות שלי היסוד הבנה של מה קורה מתחת למכסה המנוע. האם דמות i-ה s גדול או שווה ל? כלומר, יש בו 97, או 98, או 99, וכן הלאה? 

אבל האם זה גם פחות או שווה לערך z הקטנה? ואם כן, מה המשמעות של קו זה אומר? 14, זה סוג של נבט של הרעיון, הופך את האות על ידי פשוט חיסור 32 ממנו, במקרה זה, כי אני יודע, לכל כי תרשים, איך המספרים שלי מיוצגים. אז בואו נלך קדימה ולרוץ זה, לאחר קומפילציה לנצל 0.c, וברח לנצל 0. 

בואו להקליד משהו כמו Zamyla בכל הקטן להיכנס. ועכשיו יש לנו Zamyla בכל רישיות. בואו להקליד רוב בכל הקטן. בואו ננסה ג'ייסון בכל הקטן. ואנחנו שומרים מקבלים את היוון כפייה. יש באגים קטנים שאני סוג של לא צפה. במועד ההודעה החדשה שלי מסתיימת באותה שורה כמו שמותיהם, אשר מרגיש מבולגן קצת. 

אז אני הולך כאן, למעשה בסוף תוכנית זו להדפיס את אופי שורה חדש. זה הכל. עם printf, אתה לא צריך לעבור במשתנים או קוד העיצוב. אתה ממש יכול פשוט להדפיס משהו כמו שורה חדשה. 

אז בואו נלך קדימה ולעשות לנצל 0 שוב, בשידור חוזר זה, Zamyla. ועכשיו זה יפה מעט. עכשיו, הפקודה שלי היא על הקו החדש משלו. אז זה הכל טוב ויפה. אז זה דוגמא טובה. אבל אני אפילו לא בהכרח צריך קוד קשה 32. אתה יודע מה? יכולתי say-- שאני עושה לא פעם זוכר מה ההבדל. 

אבל אני יודע שאם אני יש מכתב באותיות קטן, אני בעצם רוצה להפחית את מה המרחק בין קטן א 'ו-גדול, כי אם אני מניח כי כל האותיות האחרות זהה, כי צריך לעשות את העבודה. אבל במקום לעשות את זה, אתה יודע מה? יש דרך נוספת עדיין. 

ואם זה לנצל 1.c-- אם הייתי לשים את זה לקובץ נפרד. בוא נעשה לנצל 2.ג כדלקמן. אני הולך באמת לנקות זה כאן. ובמקום אפילו צורך יודע או אכפת אלה ברמה הנמוכה פרטי היישום, אני במקום רק הולך להדפיס דמות, ציטוט סוף ציטוט, אחוז C, ואז להתקשר פונקציה אחרת כי קיים שלוקח ויכוח, אשר הוא דמות, ככה. 

מתברר ב- C, יש קריאה לפונקציה אחרת כדי עליון, אשר כשמו מרמז לוקח דמות והופך אותו לאות רישית שלה שווה ערך, ולאחר מכן מחזיר אותו כך printf יכול לחבר אותו לשם. וכך לעשות את זה, אם כי, אני צריך להציג את הקובץ השני. מתברר שיש עוד קובץ כי היית יודע מכיתה רק, או ספר לימוד, או באינטרנט התייחסות, type.h. C שנקרא 

אז אם אני מוסיף את זה בין הכותרת שלי קבצים, ועכשיו מחדש לקמפל תוכנית זו, capitalize2, ./capitalize2 Enter. בואו להקליד Zamyla בכל קטן, עדיין עובד אותו הדבר. אבל אתה יודע מה? מתברר שכדי עליון יש כמה פונקציונלי אחרות. 

ותנו לי להציג זה מפקד פה, מעין במבוכה בשם, אבל איש עבור ידני. מתברר כי רוב מחשבי לינוקס, כפי שאנו משתמשים כאן-- ההפעלה לינוקס system-- יש פקודה אדם בשם, אשר אומר, היי, מחשב, תן לי במדריך של המחשב. מה אתה רוצה לחפש במדריך זה? 

אני רוצה לחפש את הפונקציה קרא עליון, Enter. וזה לא ברור מספיק לקרוא לפעמים. אבל לב שאנחנו בבית במדריך של מתכנת לינוקס. וזה כל הטקסט. ושימו לב כי יש את שם הפונקציה כאן. מתברר שיש לו בת דודה בשם להנמיך, אשר עושה את ההיפך. והודעה תחת תקציר, להשתמש זה לתפקד בו האדם, אם אפשר לומר כך, הוא אומר לי שאני צריך לכלול ג type.h. וידעתי כי מהפרקטיקה. 

הנה, זה מראה לי את שני טיפוס עבור הפונקציה, כך שאם אי פעם אני רוצה להשתמש זה אני יודע מה הם לוקחים כקלט, ומה הם חוזרים כפלט. ואז אם אני קורא התיאור, אני רואה ביתר פירוט מה הפונקציה עושה. אבל יותר חשוב, אם אני מסתכל תחת ערך מוחזר, זה אומר הערך המוחזר הוא כי המכתב המר, או C, הקלט המקורי, אם ההמרה לא הייתה אפשרית. 

במילים אחרות, כדי העליונה ינסו להמיר מכתב לאות רישית. ואם כן, זה הולך להחזיר אותו. אבל אם זה לא יכול לחלק reason-- אולי זה כבר רישית, אולי זה קריאת נקודה או כמה punctuation-- אחר זה פשוט הולך להחזיר את C המקורי, מה שאומר שאני יכול לעשות הקוד שלי ככל שהיטיב כדלקמן. 

אני לא צריך את כל קווי המעצבן הזה אלה של קוד. כל הקווים לי יכול רק הדגיש התמוטט רק לתוך אחד פשוט קו, אשר זה-- printf אחוזים ג סוגר S העליון i. וזה יהיה דוגמא של עיצוב טוב. 

למה ליישם בקווים 7 או 8 של קוד, מה שזה לא היה אני פשוט נמחק, כאשר אתה יכול במקום לקרוס כל זה עושה היגיון וההחלטה לתוך שורה אחת אחת, 13 עכשיו, כי מסתמך על ספרייה function-- פונקציה שמגיעה עם C, אבל זה עושה בדיוק מה שאתה רוצה לעשות את זה. ולמען האמת, גם אם זה לא הגיע עם C, אתה יכול ליישם את זה בעצמך, כפי שראינו, עם לקבל int שלילית ולקבל שבוע חיובי int האחרון גם כן. 

קוד זה עכשיו הרבה יותר קריא. ואכן, אם אנו לגלול מעלה, תראה כמה הרבה יותר קומפקטי בגירסה זו של התוכנית שלי היא. זהו כבד עליון קצת עכשיו, עם כל אלה כוללים. אבל זה בסדר, כי עכשיו אני עומד על כתפיהם של מתכנתים לפניי. ומי זה היה מי מיושם על מנת עליון באמת עשה לי טוב, ממש כמו מי מיושם סטירלינג באמת עשה לי טוב לפני כמה זמן. אז עכשיו יש לנו תוכנית עיצוב טוב יותר המיישמת את הלוגיקה זהה. 

אם כבר מדברים על סטירלינג, תן לי להמשיך לעשות את זה. תן לי ללכת קדימה ולשמור קובץ זה כמו stirling.c. ומתברר, אנחנו יכולים לקלף בחזרה אחד אחר שכבה די פשוט עכשיו. אני הולך קדימה, שוט עד תכנית אחרת ראשי כאן שפשוט מחדש סככה מחרוזת באורך כדלקמן. אז הנה שורת קוד זה יהיה לי מחרוזת מהמשתמש. אנחנו ממשיכים באמצעות זה שוב ושוב. תן לי לתת את עצמי משתנה בשם n של int סוג מאחסן מספר. 

ותן לי להמשיך לעשות את ההיגיון הבא. בעוד דמות-ה n שבסעיף עושה לא מהלך סרק 0 שווה, קדימה ו להגדיל n. ואז להדפיס n i printf אחוזים. אני טוען כי תכנית זו כאן, בלי לקרוא אורך מחרוזת, להבין איך פותחים את האורך של מחרוזת. 

והקסם הוא לגמרי הגלום קו 8 כאן עם מה שנראה כמו תחביר חדש, מהלך סרק 0 זה במרכאות יחידות. אבל למה זה? ובכן, לחשוב על מה היה קורה כל הזמן הזה. 

ואגב זה לפני שאשכח, מבין מדי, כי בנוסף לדפי ההוראות שמגיע עם טיפוסי מערכת לינוקס כמו CS50 IDE, להבין כי אנו, גם של הצוות כמובן, יש עשה גרסת אתר של אותו הרעיון הזה שנקרא reference.cs50.net, אשר יש כל דפי איש אותם, כל זה באותו תיעוד, וכן קופסה קטנה בחלק העליון המאפשר לך להמיר את כל למדי שפה מסתורית לתוך פחות נוח מצב, שבו אנו, צוות המורים, עברתי וניסה לפשט חלק מהשפה לשמור דברים התמקד הרעיונות, ולא חלק הפרטים הטכניים. אז לזכור, reference.cs50.net כמשאב אחר גם כן. 

אבל מדוע מחרוזת באורך עבודה בדרך הצעתי לפני רגע? הנה שם של Zamyla שוב. והנה שמו של Zamyla התאגרף, כפי שאני להמשיך לעשות, לצייר תמונה של אותו להיות, באמת, רק רצף של תווים. אבל Zamyla אינו קיים בבידוד בתוכנית. 

כשאתה כותב ולהפעיל תוכנית, אתה משתמש ב- Mac שלך או למחשב כמו זיכרון, או RAM כביכול. ואתה יכול לחשוב מחשב כבעל המון ג'יגה-בייט של זיכרון בימים אלה. ו חלטורה אומרת מיליארדים, כך מיליארדי בייטים. 

אבל בואו אחורה בזמן. ונניח שאנחנו משתמשים מחשב ישן באמת כל כך יש רק 32 בתים של זיכרון. יכולתי, על מסך המחשב שלי, לצייר זה פשוט החוצה כדלקמן. 

אני פשוט יכול לומר שלי יש מחשב כל הזיכרון הזה. וזה כמו מקל של זיכרון, אם אתה זוכר את התמונה שלנו מהפעם הקודמת. ואם אני רק לחלק זה מספיק פעמים, אני טוען שיש לי 32 בתים זיכרון על המסך. 

עכשיו, במציאות, אני יכול רק לצייר עד כה על המסך הזה כאן. אז אני הולך קדימה, ופשוט לפי האמנה, לצייר את הזיכרון של המחשב שלי בתור רשת, לא רק קו ישר אחד. באופן ספציפי, אני טוען כעת כי זה סמלים, סמלים 8 ב -4 זה, רק מייצג את כל 32 הבתים זיכרון זמין ב- Mac שלי, או זמין במחשב שלי. והם גלישה על שתי שורות, רק כי זה מתאים יותר על המסך. אך זהו הבית הראשון. זהו בייט השני. זהו בייט השלישי. 

וזו בייט ה -32. לחלופין, אם אנחנו חושבים כמו מחשב מדען, זה בייט 0, 1, 2, 3, 31. אז אתה יש לך 0 ל -31, אם אתה מתחיל לספור ב 0. 

אז אם נשתמש תוכנית כי שיחות לקבל מחרוזת, ואנחנו מקבלים מחרוזת מן האדם כמו כן קראו לי Zamyla, ת-א-M-Y-L-A, איך לכל הרוחות עושה את לשמור על מחשב אחר אשר בייט, אשר נתח של זיכרון, שייך לאיזה מחרוזת? במילים אחרות, אם אנו ממשיכים ומבקשים הקלד שם אחר לתוך המחשב, כמו אנדי זו, הקוראת מחרוזת לקבל בפעם שנייה, A-N-D-I צריך בסופו של דבר גם הזיכרון של המחשב. אבל איך? 

ובכן, מתברר כי מתחת מכסה המנוע, מה C עושה כאשר לאחסון מחרוזות כך שסוגי האדם, או כי לבוא ממקור אחר, הוא זה מתווה סוף אותם עם קו נטוי הפוך character-- מיוחד 0, שהוא רק בדרך מיוחדת לומר 80 סיביות ברציפות. 

אז לזה-- זהו זוכר מספר 97. אז איזה דפוס של 8 סיביות מייצג מספר עשרוני 97. מהלך סרק 0 זהו פשוטו כמשמעו, את המספר 0, נול המוכר גם בשם, N-U-L, שלא כמו קודם לכן, N-U-L-L, אשר דיברנו. אבל לעת עתה, רק יודע שזה מהלך סרק 0 הוא רק 80 סיביות ברציפות. 

וזה בדיוק הקו הזה חול שאומר דבר שמאלה שייך לאחד שרוכים או סוג נתונים אחד. וכל דבר ימינה שייך למשהו אחר. אנדי של שם, בינתיים, אשר רק ויזואלית קורה לעטוף על הקו השני, אבל זה רק פרט אסתטי, באופן דומה הוא הופסק נול. 

זוהי מחרוזת של תווים A-N-D-I, בתוספת דמות הסוד חמישית, כל 0 ביטים, כי רק תוחם בסוף השם של אנדי גם כן. ואם אנחנו קוראים לקבל מחרוזת בשלישית במחשב כדי לקבל מחרוזת כמו מריה, M-A-R-I-A, באופן דומה הוא של מריה נול שם הסתיים עם מהלך סרק 0. 

זהו ביסודו שונה מאיך מחשב בדרך כלל יכלול לאחסן מספר שלם, או לצוף, או אחר סוגי נתונים עדיין, כי כזכור, שלם הוא בדרך כלל 32 סיביות, או 4 בתים, או אולי אפילו 64 סיביות, או שמונה בתים. אבל הפרימיטיבים רבים במחשב בשפת תכנות יש מספר קבוע של בתים מתחת hood-- אולי 1, אולי 2, אולי 4, אולי 8. 

אבל מחרוזות, על ידי עיצוב, יש מספר דינמי של תווים. אתה לא יודע מראש, עד סוגי האדם Z-A-M-Y-L-A, או M-A-R-I-A או A-N-D-I. אתה לא יודע כמה פעמים המשתמש הוא הולך להכות המקלדת. לכן, אתה לא יודע איך דמויות רבות מראש אתה הולך צריך. 

וכך C פשוט סוג של עלים כמו מיקום באתר סודי מתחת למכסה המנוע בסוף המחרוזת. לאחר אחסון Z-A-M-Y-L-A בזיכרון, זה גם רק מוסיף המקבילה של תקופה. בסוף המשפט, זה מכניס 80 סיבי, כדי לזכור איפה Zamyla מתחיל ונגמר. 

אז מה הקשר, אז, לתוכנית זו? תוכנית זו כאן, סטירלינג, הוא פשוט מנגנון עבור מקבל מחרוזת מהמשתמש, קו 6. שורה 7, אני מכריז על משתנה קרא n ולהגדיר אותו שווה ל -0. 

ואז עולה בקנה אחד 8, רק שאלתי את שאלה, ואילו דמות n-th עושה לא שווה את כל 0 bits-- במילים אחרות, האם לא מיוחד שווה זה אופי, מהלך סרק 0, אשר רק היה מיוחד כי character-- נול קדימה ופשוט להגדיל n. 

להמשיך לעשות את זה, ולשמור עושה את זה, להמשיך לעשות את זה. וכך אף ב בעבר השתמשנו i, זה בסדר גמור סמנטי להשתמש n, אם אתה רק מנסה לספור הפעם בכוונה, ואת רק רוצה לקרוא לזה n. אז זה פשוט ממשיך לשאול את השאלה, הוא 0s כל האופי של n-th? אם לא, נראה את המראה הבא, להסתכל למשנהו, להסתכל למשנהו, להסתכל למשנהו. 

אבל ברגע שאתה רואה מהלך סרק 0, זה קו loop-- 9 עד 11-- מפסיק. אתה לפרוץ את לולאת while, עוזב בתוך כי n משתנה מספר כולל של כל תווים במחרוזת שראית, ובכך להדפיס אותו. אז בואו ננסה את זה. 

תן לי ללכת קדימה, בלי באמצעות פונקצית סטירלינג, אבל רק באמצעות גרסת תוצרת משלי סטירלינג שנקרא כאן, תן לי ללכת קדימה סטירלינג הפעלה, הקלד במשהו כמו Zamyla, אשר אני יודע מראש הוא שישה תווים. בוא נראה אם ​​זה עובד. ואכן, זה שש. בואו ננסה עם רוב, שלוש דמויות, שלוש דמויות כמו גם, וכן הלאה. אז זה כל מה שקורה כאן על מתחת למכסה המנוע. ושימו לב את החיבורים, אז, עם השבוע הראשון של הכיתה, שם דיברנו על משהו כמו הפשטה, וזה רק שכבות של רעיונות, או מורכבות, על גבי עקרונות בסיסיים. כאן, ואנחנו עוברים למעין מחפשים מתחת למכסה המנוע של סטירלינג, כביכול, כדי להבין, כיצד ייושם זה? 

ויכולנו מחדש ליישם את זה בעצמנו. אבל אנחנו לעולם לא הולכים מחדש ליישם סטירלינג. אנחנו פשוט הולכים להשתמש סטירלינג כדי למעשה לקבל קצת אורך מחרוזות. 

אבל אין בזה קסם מתחת למכסה המנוע. אם אתה יודע שמתחת למכסה המנוע, מחרוזת רק הוא רצף של תווים. ורצף של תווים כל ניתן לטפל מספרי עם סוגר 0, סוגר 1, סוגר 2, ואתה יודע כי בסוף המחרוזת היא תו מיוחד, אתה יכול להבין איך לעשות משהו ביותר בתוך התוכנית, כי כל זה מסתכם הוא קריאה וכתיבת זיכרון. כלומר, שינוי ומחפשים בזיכרון, או להזיז דברים סביב בזיכרון, דברי הדפסה על המסך, וכן הלאה. 

אז בואו עכשיו להשתמש חדשה זו הבנה של מה מחרוזות בפועל הם מתחת למכסה המנוע, ו לקלף שכבה אחת אחרת כי עד עכשיו יש לנו מתעלם לגמרי. בפרט, בכל עת מימשנו התוכנית, היו לנו את שורת הקוד סמוך לראש להכריז הראשי. ואנחנו שציינו void main int. 

ומבוטל כי בתוך הסוגריים יש אומר כל הזמן הזה כי ראשי עצמו אינו לוקח שום טענות. כל קלט כי עיקרי הוא הולך לקבל מהמשתמש יש לבוא מכמה אחרים מנגנון, כמו גט int, או לקבל לצוף, או לקבל מחרוזת, או תפקיד אחר. אבל מתברר כי בעת כתיבת תכנית, למעשה אתה יכול לציין כי תכנית זו תהיה לקחת תשומות מן האדם בשורת הפקודה עצמה. 

במילים אחרות, אף על פי שאנו כה יש כבר פועל רק ./hello שלום או תוכניות דומות, כל תוכניות אחרות כי אנחנו כבר משתמשים, שאנחנו עצמנו לא לכתוב, כבר לוקחים, כך נראה, שורת הפקודה arguments-- דברים כמו לעשות. אתה אומר משהו כמו איפור, ואז מילה שנייה. או צלצול, אתה אומר להרעיש, ולאחר מכן מילה שנייה, שם של קובץ. 

או אפילו RM או CP, כאילו היה לך ראו או בשימוש כבר להסיר או להעתיק קבצים. כל אלה לוקחים מה שנקרא שורת הפקודה arguments-- מילים נוספות בשורת סופנית. אבל עד עכשיו, אנחנו עצמנו לא היו יוקרה זה לקחת קלט מן המשתמש כאשר הוא או היא בעצם פועל התוכנית עצמה בשורת הפקודה. 

אבל אנחנו יכולים לעשות את זה על ידי מחדש המכריז עיקרי לנוע קדימה, לא כבעל לביטול בסוגריים, אבל שני אלה טיעונים instead-- שלם הראשונה, ושנייה מאוחר יותר חדש, משהו שאנחנו הולכים לקרוא מערך, משהו דומה ברוחה למה שראינו ב Scratch כרשימה, אבל מערך של מחרוזות, כפי שאנו בקרוב לראות. אבל בואו לראות זאת על ידי לשם דוגמא, לפני שאנחנו להבחין בדיוק מה זה אומר. 

אז אם אני נכנסתי CS50 IDE כאן, אני כבר הלכתי קדימה והכריז בקובץ שנקרא argv0.c את התבנית הבאה. ושימו לב הדבר היחיד זה שונה עד כה הוא שהשתניתי הריק כדי int מחרוזת argc argv סוגר פתוח, קרוב סוֹגֵר. ושימו לב לעת עתה, יש כלום בפנים הגיל האלו. 

אין מספר. ואין אני, או n, או כל מכתב אחר. אני רק באמצעות סוגריים מרובעים לעת עתה, מסיבות נבוא חזרה בעוד רגע. 

ועכשיו מה אני הולך לעשות הוא זה. אם argc שווה שווה 2-- ולהיזכר השווה שווה היא המפעילה שוויון השוואה על ימין ועל שמאל לשוויון. זה לא המשימה מפעיל, שהוא סימן השוויון היחיד, כלומר עותק מימין לערך כמה עזבו. 

אם argc שווה שווה 2, אני רוצה תניח, printf, שלום, אחוזים, קו חדש, ולאחר מכן חבר ב-- והנה חדש סוגר 1 argv trick--, מסיבות כי נצטרך לחזור בעוד רגע. אחר אם argc לא 2 שווה, אתה יודע מה? בואו רק קדימה, כרגיל, הדפסה מתוך hello world ללא החלפה. 

אז זה היה נראה שאם argc, אשר מייצג במספר הארגומנטים, שווה 2, אני הולך להדפיס שלום דבר זה או אחר. אחרת, כברירת מחדל, אני הולך להדפיס hello world. אז מה זה אומר? 

ובכן, הרשו לי להמשיך ולשמור קובץ זה, ולאחר מכן עושה argv0, ואז ./argv0, Enter. וזה אומר שלום העולם. עכשיו, מדוע זה כך? 

ובכן, מתברר פעם שאתה להפעיל תוכנית בשורת הפקודה, אתה ממלא מה נעשה קוראים וקטור טענה כלל. במילים אחרות, באופן אוטומטי מחשב, מערכת ההפעלה, הוא הולך למסור לתוכנית שלך עצם רשימה של כל המילים כי האדם מוקלד ב הבשורה, במקרה שאתה המתכנת רוצה לעשות משהו עם המידע הזה. וגם במקרה זה, המילה היחידה הדפסתי הבשורה הוא ./argv0. 

וכך מספר הארגומנטים כי הוא שמועבר התוכנית שלי היא רק אחת. במילים אחרות, הטענה לספור, הידוע גם בכינויו argc כאן כמספר שלם, הוא רק אחד. אחת, כמובן, לא שווה שתיים. וכך זה מה מדפיס, hello world. 

אבל תן לי לקחת את זה לאנשהו. הרשו לי לומר, argv0. ואז מה לגבי מריה? ואז על Enter. 

ושימו לב מה קסם קורה כאן. עכשיו, במקום hello world, יש לי התנהגות שונה של תוכנית זו על ידי לקיחת הקלט לא מן הגט מחרוזת או תפקיד אחר, אלא, ככל הנראה, פיקודי עצמו, מה אני במקור הקליד. ואני יכול לשחק במשחק הזה שוב על ידי שינוי זה כדי סטליוס, למשל. 

ועכשיו אני רואה שם אחר עדיין. והנה, אם יורשה לי לומר אנדי. ואני יכול להגיד Zamyla. ואנחנו יכולים לשחק את המשחק הזה כל היום, רק חיבור ערכים שונים, כל עוד אני מספק בדיוק שתי מילות בשורה, כך argc, הטענה שלי לספור, הוא 2. 

האם אני רואה את השם הזה פקוק לתוך printf, לכל מצב זה כאן? אז אנחנו רואים שיש עכשיו יכולת ההבעה לקחת קלט מנגנון אחר, משורת הפקודה שנקרא, ולא צורך להמתין עד שהמשתמש מפעיל את התכנית, ואז להנחות אותו או אותה באמצעות משהו כמו מחרוזת גט. 

אז מה זה? Argc, שוב, הוא פשוט מספר שלם, מספר מילים-- arguments-- שהמשתמש הניתן פקודה, ליד חלון המסוף, כולל שם של התכנית. אז ./argv0 שלנו הוא, ביעילות, שמו של התוכנית, או איך אני מפעיל את התוכנית. 

זה נחשב מילה. אז argc יהיה 1. אבל כשאני כותב סטליוס, או אנדי, או Zamyla, או מריה, זה אומר לספור הטענה היא שני. אז עכשיו יש שתי מילים עבר. 

ושים לב, שנוכל להמשיך ההיגיון הזה. אם אני אומר למעשה משהו כמו Zamyla צ'אן, שם מלא, ובכך עובר שלוש טענות בסך הכל, עכשיו זה אומר ברירת המחדל שוב, כי, כמובן, 3 לא שווה 2. 

וכך, בדרך זו, אני צריך גישה דרך argv זו טענה חדשה כי שיכולנו טכני קורא כל מה שאנחנו רוצים. אבל לפי האמנה, זה argv ו argc, בהתאמה. Argv, וקטור טענה, הוא סוג של מילה נרדפת תכנות תכונה ב- C נקרא מערך. 

מערך הוא רשימה של ערכים דומים בחזרה, לגבות, לגבות, אל גב. במילים אחרות, אם אחד הוא ממש כאן RAM, המאבק הבא הוא ממש ליד זה, וממש ליד זה. הם לא בכל מקום. וזה תרחיש שני, שבו דברים הם בכל מקום בזיכרון, באמת יכול להיות תכונה חזקה. אבל נחזור לזה כשאנחנו לדבר על מבני נתונים להשתכלל. לעת עתה, מערך הוא רק נתח של זיכרון רציף, כל אחד מהאלמנטים אשר הם בחזרה, לגבות, לגבות, לגבות, ובאופן כללי מאותו הסוג. 

אז אם אתה חושב על, מתוך לפני רגע, מה היא מחרוזת? ובכן, מחרוזת, כמו Zamyla, Z-A-M-Y-L-A, הוא, מבחינה טכנית, רק מערך. זה מערך של תווים. 

וכך, אם אנחנו באמת לצייר זה, כפי שאני קודם לכן עשה, כמו נתח של זיכרון, מתברר כי כל אחד מאלה הדמויות תופסת בייט. ואז יש את מיוחד אופי ניטור, הקו הנטוי 0, או כל שמונה 0 ביטים, כי מתחם בסוף אותה המחרוזת. אז מחרוזת, מסתבר החוצה, לצטט מחרוזת סוף ציטוט, רק הוא מערך של chara-- char להיות סוג הנתונים בפועל. 

ועכשיו argv, meanwhile-- בואו נחזור לתוכנית. Argv, למרות שאנחנו רואים את המילה מחרוזת כאן, אינה מחרוזת עוצמה. Argv, וקטור טענה, הוא מערך של מחרוזות. 

אז בדיוק כפי שאתה יכול להיות מערך של תווים, אתה יכול להיות ברמה גבוהה יותר, מערך של: המיתרים כך, למשל, כאשר הקלדתי רגע לפני ./argv0 argv0,-A Z-M-Y-L-חלל, טענתי argv היו שתי מחרוזות ב ./argv0 it--, ו- Z-A-M-Y-L-A. ב במילים אחרות, argc היה 2. למה זה? 

ובכן, באופן יעיל, מה קורה על הוא שכל אחד מחרוזות אלה הוא, כמובן, מערך של תווים כמו קודם, כל אחד אשר תווים תופס בייט אחד. ואל תבלבלו את ה -0 בפועל על שם התוכנית עם 0, כלומר כל 80 הבתים. ו Zamyla, בינתיים, הוא עדיין גם מערך של תווים. 

אז בסוף היום, זה באמת נראה כך מתחת למכסה המנוע. אבל argv, מטבעו של איך ראשי עבודות, מאפשרות לי לעטוף את כל זה למעלה לתוך, אם תרצה, מערך גדול כי, אם אנחנו מעט מעל לפשט מה התמונה נראית כמו ולעשות לא לצייר את זה די בהיקף של עד שם, מערך זה הוא רק בגודל 2, הראשון אלמנט אחד מהם מכיל מחרוזת, המרכיב השני של המכיל מחרוזת. וזה, בתורו, אם אתה סוג של קרב על כל של המיתרים הללו, מה אתה לראות מתחת למכסה המנוע מחרוזת הוא כי כל אחד מהם היא רק מערך של תווים. 

עכשיו, בדיוק כמו עם מחרוזות, הצלחנו לקבל גישה לאופי-ה i במחרוזת באמצעות כי בסימון סוגר מרובע. באופן דומה, עם מערכים בכלל, אנחנו יכולים להשתמש בסימון סוגר מרובע לקבל בכל מספר המחרוזות במערך? למשל, תן לי אתם מוזמנים לעשות זאת. 

תן לי להמשיך וליצור argv1.c, וזה קצת שונה הפעם. במקום בדיקת argc2, אני הולך במקום לעשות זאת. עבור int אני מקבל 0, אני נמצא במרחק של פחות מ argc, אני פלוס פלוס, ואז להדפיס את החלק הפנימי של זה, ימי אחוזים, קו חדש, ולאחר מכן argv סוגר i. 

אז במילים אחרות, אני לא עושה עסקים עם תווים בודדים כרגע. Argv, כפי שמשתמע ריבוע ריק אלה כתפיות ימינה של argv שם, פירושו argv הוא מערך של מחרוזות. ו argc הוא רק int. 

הקו הזה כאן, 6, הוא אומר ואינדינ שווה ל -0. לספור את כל הדרך עד, אבל לא כולל, argc. ואז על כל איטרציה, להדפיס מחרוזת. מה חבל? 

מחרוזת i-th argv. אז בעוד לפני שהייתי באמצעות סוגר מרובע הכיתוב כדי להגיע לחקר ה- i אופי במחרוזת, עכשיו אני משתמש בסימון סוגר מרובע כדי להגיע לחקר מחרוזת ה- i במערך. אז זה סוג של שכבה אחת לעיל, מושגית. 

וכך מה מסודר על זה תוכנית עכשיו, אם אני לקמפל argv1, ולאחר מכן לעשות ./argv1, ולאחר מכן הקלד במשהו כמו באז foo בר, שהן שלוש מילים מחדל כי מדען המחשב מגיע לכל זמן הוא או היא צריכה כמה מילים מציין מיקום, והקש Enter, כל המילים האלה, כולל שם של התכנית, אשר ב argv הוא במיקום הראשון, בסופו להיות מודפס אחד בכל פעם. ואם אני משנה את זה, אני אומר משהו כמו argv1 Zamyla צ'אן, אנחנו מקבלים את כל שלושת אלה מילים, וזה argv0, argv1, argv2, כי זה argc במקרה, הספירה, הוא 3. 

אבל מה מסודר הוא אם אתה מבין argv כי הוא פשוט מערך של מחרוזות, ואתה מבין כי מחרוזת הוא מערך של תווים, אנחנו יכולים בעצם סוג של משתמש זה בסימון סוגר מרובע מספר פעמים לבחור מחרוזת, ולאחר מכן לבחור דמות בתוך המחרוזת, צלילה עמוקה כדלקמן. בדוגמה זו, תן לי ללכת קדימה ולקרוא argv2.c זה. ו בדוגמה זו, תן לי ללכת קדימה ולעשות את following-- עבור int אני מקבל 0, אני הוא פחות מ argc, אני פלוס בתוספת, בדיוק כמו לפני. אז מילים-- אחר ועכשיו זה הוא מקבל מסובך מספיק. אז אני הולך להגיד לחזר על מחרוזות ב argv, כהערה לעצמי. ואז אני הולך להיות מקוננים על לולאה, אשר אתה בטח עשו, או נחשב עושה, גרד, שם אני הולך לומר int-- אני לא הולך להשתמש אני שוב, כי אני לא רוצה צל, או מעין לדרוס את i הקיים. 

אני הולך, במקום, אומר j, כי כי ילך שלי משתנה אחרי שאני, כשאני רק מנסה לספור מספרים פשוטים. עבור j מקבל 0-- וגם, n, הולך לקבל את אורך שטרן סוגר argv אני, כל עוד j הוא פחות מ, j פלוס פלוס, לבצע את הפעולות הבאות. והנה החלק המעניין. 

הדפס את אופי שורה חדשה, חיבור סוגר argv i, סוגר j. אוקיי, אז הרשו לי להוסיף כמה הערות כאן. לחזר על תווים במחרוזת הנוכחית, אופי j-ה הדפסה במחרוזת i-ה. אז עכשיו, הבה נבחן מה ההערות האלה אומרים. 

לחזר על מחרוזות ב argv-- כמה מחרוזות נמצאות argv, שהוא מערך? Argc רב, אז אני iterating מ i שווה 0 עד argc. בינתיים, כמה תווים הם במחרוזת i-th argv? 

ובכן, כדי לענות על השאלה הזאת, אני פשוט קורא מחרוזת באורך על הטיפול שאני מחרוזת הנוכחית עליו, שהוא argv סוגר i. ואני הולך לאחסן באופן זמני כי ערך n, רק למטרות במטמון, לזכור את זה במונחים של יעילות. ואז אני הולך לאתחל j ל -0, להמשיך כל עוד j הוא פחות מ n, ועל כל j איטרציה תוספת. 

ואז כאן, לכל ההערה שלי על קו 12, להדפיס את דמות, ואחריו בשורה חדשה, סוגר argv במיוחד אני נותן לי את מחרוזת i-ה ב כך argv-- המילה הראשונה, מילה שנייה, המלה השלישית, מה שלא יהיה. ואז צולל j עמוק יותר, ומקבל לי דמות j-th של המילה הזאת. וכך, למעשה, ניתן לטפל argv בתור רב ממדים, כמערך דו-ממדי,, לפיה כל סוג מילה של מראה ככה במוחו של שלך עין, וכל תו סוג של מורכב ב טור, אם זה עוזר. 

במציאות, כאשר אנו להקניט זה מזה בשבועות בעתיד, זה הולך להיות קצת יותר מתוחכם מזה. אבל אתה יכול באמת לחשוב על זה, לעת עתה, בתור סתם דו מימדי זה מערך, לפיה רמה אחת של זה כל הוא של המיתרים. ואז אם אתה לצלול עמוק יותר, אתה יכול לקבל על התווים הבודדים בה באמצעות בסימון זה כאן. 

אם כן, מהי ההשפעה נטו? תן לי ללכת קדימה להפוך argv2-- לעזאזל. עשיתי טעות כאן. במשתמע המכריז על סטירלינג פונקציה הספרייה. אז כל הזמן הזה, זה אולי מתאים שאנחנו סוג של גמר בדיוק לנקודה שבה התחלנו. 

אני דפוק, במשתמע להכריז סטירלינג פונקציה הספרייה. בסדר, חכה רגע. אני זוכר את זה, במיוחד מאז שזה צריך להימצא כאן. אני צריך לכלול string.h ב בגירסה זו של התוכנית. 

תן לי ללכת קדימה ולכלול string.h, שמור את זה, קדימה ו קומפילציה argv2. ועכשיו, הנה זה בא, לעשות argv2, Enter. ואף על פי שזה קצת נסתר במבט ראשון, להבחין כי, אכן, מה מודפס הוא argv2 נקודה. 

אבל אם אני מקליד כמה מילים לאחר הפקודה, כמו argv2 Zamyla צ'אן, זן, גם קצת נסתר במבט ראשון. אבל אם אנחנו לגלול חזרה למעלה, ./argv2 Z-A-M-Y-L-A C-H-A-N. אז אנחנו כבר איטרטיבית על כל מלה. וזה, בתורו, שמנו iterated מעל כל דמות בתוך מילה. 

עכשיו, אחרי כל זה, קולט שיש אחד פרט אחר היינו סוג של התעלמות זה כל הזמן. אנחנו פשוט התגרו בנפרד מה יכולה להיות תשומות ראשיות? מה לגבי הפלט של ראשי? 

כל הזמן הזה, היינו רק העתקה והדבקה המילה int מול עיקרי, אם כי תוכלו לראות באינטרנט, לפעמים שגוי בגירסאות ישנות יותר של C מהדרים, כי הם אומרים הריק, או בכלל לא. אבל, אכן, עבור הגרסה של C שבו אנו משתמשים, C 11, או 2011, לממש כי זה צריך להיות int. וזה צריך להיות או חלל או argc ו argv כאן. 

אבל למה int main? מה זה באמת מחזיר? ובכן, מתברר כל הזמן הזה, בכל פעם שאתה כבר כתבת ראשית של תכנית תמיד חוזר משהו. אבל היא עושה זאת בסתר. 

המשהו הזה הוא int, כמו קו 5 מרמז. אבל מה int? ובכן, יש את זה כנס בתכנות, לפיה אם דבר יש השתבש הכל טוב, תוכניות ופונקציות בדרך כלל return-- מעט counterintuitively-- 0. 0 בדרך כלל מסמל הכל טוב. לכן, למרות שאתה חושב זה כמו שווא בהקשרים רבים, זה באמת פירושה בדרך כלל דבר טוב 

בינתיים, אם תוכנית מחזירה 1, או 1, או 5 שליליים, או 42 שליליים, או כל ערך אחר שאינו 0, שמשמעותו בדרך כלל משהו השתבש. למעשה, בעצמך Mac או PC, ייתכן היה אפשר ממש לראות הודעת שגיאה על פיה אומרת דבר זה או אחר, שגיאה קוד 42, או שגיאה שלילית 23, או משהו כזה. מספר זה הוא בדרך כלל רק רמז אל המתכנת, או החברה שגרם תוכנה, מה השתבש ומדוע, כדי שיוכלו להסתכל דרך תיעוד או הקוד שלהם, להבין מה שגיאה בעצם אומרת. זה בדרך כלל לא שימושי לנו למשתמשי קצה. 

אבל כאשר תשואות עיקריות 0, הכל טוב. ואם לא תציין מה ראשי צריך לחזור, זה יהיה רק ​​באופן אוטומטי לחזור 0 בשבילך. אבל חוזר משהו אחר הוא ממש שימושי. 

בתכנית סופית זה, תן לי אתם מוזמנים לקרוא exit.c זה, ולהציג את האחרון של היום נושאים, המכונים קוד שגיאה. תן לי ללכת קדימה ולכלול שלנו קבצים למעלה מוכרים, לעשות ראשיים int. והפעם, בוא נעשה int argc, argv מחרוזת, ועם בסוגריים שלי לרמוז שזה במערך. ואז הם נתנו לי רק לבצע בדיקה בסיסית. הפעם, אם argc לא 2 שווה, אז אתה יודע מה? שכח מזה. אני הולך להגיד את זה, היי, משתמשים, אתה חסר ארגומנט שורת הפקודה n לוכסן אחורי. 

ואז זהו זה. אני רוצה לצאת. אני הולך מנע, בטרם עת ממש, השיבה משהו אחר מאשר מספר 1. תוך כדי תנועה לשווי עבור הראשון שגיאה שיכול לקרות היא 1. אם יש לך כמה אחרים שגויים מצב שעלול להתרחש, אפשר לומר חזרה 2 או לחזור 3, או אולי אפילו שלילי 1 או 2 שליליים. 

אלה הם רק קודי יציאה כי הם, בדרך כלל, רק שימושי המתכנת, או חברה זה משלוח התוכנה. אבל העובדה שזה לא 0 הוא מה שחשוב. אז אם בתכנית זו, אני רוצה להבטיח כי תוכנית זו רק עובד אם המשתמש מספק אותי עם ספירת טיעון של השני, השם של התוכנית, וכמה אחרים מילה, אני יכול לאכוף ככל כדלקמן, לצעוק את המשתמש עם אמרת printf, חסר ארגומנט שורת הפקודה, לחזור 1. זה יהיה רק ​​מיד יציאה מהתוכנית. 

רק אם argc שווה 2 נגיע למטה כאן, אבל בכל מקרה אני הולך להגיד, שלום s אחוזים, מהלך סרק n, argv1. במילים אחרות, אני לא הולך אחרי argv 0, וזה רק השם של התוכנית. אני רוצה להדפיס שלום, פסיק, המילה השנייה כי האדם מוקלד. וגם במקרה זה על קו 13, הכל טוב. 

אני יודע argc הוא 2 הגיוני מתוכנית זו. אני הולך קדימה ולחזור 0. במאמר מוסגר, יש לזכור כי זה נכון Scratch גם כן. 

מבחינה הגיונית, אני יכול לעשות את זה ויעטוף שורות אלה קוד בסעיף אחר זה כאן. אבל זה סוג של זחת הקוד שלי שלא לצורך. ואני רוצה לעשות סופר ברור כי לא משנה מה, כברירת מחדל, שלום משהו יקבל מודפס, כל עוד המשתמש משתף פעולה. 

אז זה נפוץ מאוד להשתמש מצב, רק אם, לתפוס כמה שגוי מצב, ולאחר מכן יציאה. ואז, כל עוד הכל טוב, לא להיות אחר, אבל רק צריך את הקוד מחוץ שאם, כי זה מקבילה זו במקרה מסוים, באופן הגיוני. אז אני מחזיר 0, רק כדי במפורש לסמן שהכל בסדר. 

אם השמטתי את התשואה 0, זה היה יש להניח באופן אוטומטי בשבילי. אבל עכשיו, אני מחזיר אחד לפחות במקרה הזה, אני הולך, למען הסדר הטוב ואת בהירות, לחזור 0 במקרה זה. אז עכשיו תן לי ללכת קדימה ולעשות יציאה, שהינה segue מושלמת פשוט לעזוב. 

אבל לעשות יציאה, ותן לי ללכת קדימה ולעשות ./exit, Enter. והתכנית צעקה עליי, חסר ארגומנט שורת הפקודה. אישור, תן לי לשתף פעולה. 

תן לי במקום לעשות ./exit, דוד, Enter. ועכשיו זה אומר, שלום דוד. ואתה בדרך כלל לא רואה את זה. 

אבל מתברר שיש דרך מיוחדת לינוקס ממש לראות עם מה יציאת קוד תכנית יצאה. לפעמים בתוך גרפי עולם כמו Mac OS או Windows, אתה רק רואה את המספרים האלה כאשר הודעת שגיאה צצה על המסך ואת המתכנת מראה לך את המספר הזה. אבל אם אנחנו רוצים לראות מה השגיאה המסר הוא, אנחנו יכולים לעשות את זה כאן-- כך ./exit, זן, להדפיס חסר ארגומנט שורת הפקודה. 

אם אני עכשיו לעשות $ הד ?, שהוא גיחוך נסתר למראה. אבל $? הוא לחש קסום שאומר, היי, מחשב, תגיד לי מה הקודם הקוד של יציאת התכנית היה. ואני על Enter. אני רואה 1, כי זה מה שאני אמר הפונקציה העיקרית שלי לחזור. 

בינתיים, אם אני עושה ./exit דוד, והקש Enter, אני רואה, שלום דוד. ואם אני כותב עכשיו לעשות $ הד ?, אני רואה שלום 0. וכך זה יהיה ממש להיות מידע בעל ערך בהקשר של הבאגים, לא כל כך הרבה שאתם, אדם, היה אכפת. אבל הבאגים ואחרים תוכניות נשתמש בסמסטר הזה לעתים קרובות יסתכל המספר הזה, למרות שזה סוג של חבוי אלא אם אתה מסתכל על זה, כדי לקבוע אם או לא תוכנית של הביצוע היה נכון או שגוי. 

וכך זה מביא אותנו זה, בסוף היום. התחלנו היום ע"י הסתכלות באגים, ו בתורו במשך הקורס עצמו, ולאחר מכן יותר מעניין, מבחינה טכנית מתחת למכסה המנוע ובאיזה מייתרים הם, אשר לאחרונה שבוע אנחנו פשוט לקחנו כמובנת מאליה, ובוודאי לקח אותם מאליו Scratch. 

לאחר מכן הסתכלנו איך אנחנו יכולים לגשת תווים בודדים במחרוזת, ואז שוב לקח רמה גבוהה יותר להסתכל על הדברים, מסתכל איך well-- אם אנחנו רוצים להגיע פרט גורמים ברשימה כמו מבנה, אנחנו לא יכולים לעשות את זה עם מחרוזות מרובות? ואנחנו יכולים עם הארגומנטים של שורת הפקודה. אבל התמונה הזאת כאן רק תיבות הוא מופגן של הרעיון הכללי הזה של מערך, או רשימה, או וקטור. וזה תלוי בהקשר, כל המילים האלה אומר דברים שונים במקצת. אז ב- C, אנחנו רק הולכים לדבר על מערך. ואת מערך הוא נתח של זיכרון, שכל אחד מהם זה היסודות הם רציפים, גב, אל גב, אל גב, אל גב. 

וגם אלה הם מרכיבים, בדרך כלל, מאותו סוג הנתונים, אופי, אופי, אופי, אופי, או מחרוזת, מחרוזת, מחרוזת, מחרוזת, או int, int, int, מה שזה לא יהיה אנחנו מנסים חנות. אבל בסוף היום, זה איך זה נראה מושגית. אתה לוקח שלך זיכרון או זיכרון RAM של המחשב. ואתה גילוף אותו החוצה אל תיבות זהים בגודלם, שכולן חזור, לגבות, כדי בחזרה, כדי לגבות בדרך זו. 

ומה שיפה הרעיון הזה, והעובדה שנוכל לבטא ערכים בדרך זו עם הראשון של מבני הנתונים שלנו בכיתה, אומר שאנחנו יכולים להתחיל לפתור בעיות עם קוד כי בא כל כך אינטואיטיבי בשבוע 0. אתם בוודאי זוכרים את הטלפון ספר למשל, שם השתמשנו הפרד ומשול, או חיפוש בינארי, לנפות כולה חבורה של שמות ומספרים. אבל הנחנו, כזכור, כי ספר טלפונים כבר מסודר, שמישהו היה אחר כבר הבנתי נתון out-- רשימת השמות ו numbers-- איך לסדר אותם לפי האלפבית. ועכשיו, ב- C אנו, מדי, יש את היכולת להניח את הדברים, לא פיזית ספר טלפונים אבל כמעט במחשב של זיכרון, אהיה בשבוע הבא מסוגל להציג שוב זה- הראשון של מבני הנתונים שלנו בתוך array-- אבל יותר חשוב, מחשב בפועל אלגוריתמי מדע מיושמים בקוד, שבו אנו יכולים לאחסן נתונים במבנים כזה, ולאחר מכן להתחיל לתפעל אותו, למעשה לפתור בעיות עם זה, וכדי לבנות על גבי זה, בסופו של דבר, תוכניות ב- C, בפייתון, ב- JavaScript, שאילתות מסדי נתונים עם SQL? 

ונראה כי כל אלה רעיונות שונים משתלבים. אבל לעת עתה, זוכר כי תחום שבו הצגנו היום היה את הדבר הזה כאן, העולם של קריפטוגרפיה. ובין הבעיות הבאות שאתה עצמך יפתור היא אמנות קריפטוגרפיה, ערבול ודה-ערבול מידע, הצפנה ופענוח טקסט, ובהנחה בסופו של דבר כי עכשיו אתה יודע מה הוא מתחת למכסה המנוע כך שכאשר אתה רואה או לקבל הודעה כזאת, אתה עצמך יכול לפענח אותו. כל זאת, ועוד יותר בפעם הבאה. 

[הפעלת סרטון] 

-Mover רק הגיע. אני הולך ללכת לביקור פרופסור בקולג 'שלו. כֵּן. היי. זה אתה. לַחֲכוֹת! דוד. אני רק מנסה להבין מה קרה לך. אנא, כל דבר יכול לעזור. היית הקולג 'שלו שותפה, לא היו לך? היית שם איתו כאשר הוא סיים את הפרויקט CS50? 

[מוסיקה מתנגנת] 

ההיא." היה CS50. 

אני אוהב את המקום הזה. 

-תאכל. אנחנו הולכים מחוץ לעסק. 

[סוף PLAYBACK] 