[МУЗИКА] 

Дейвид Дж Малан: Добре. Това е и това CS50 е началото на седмица 2. И вие ще припомним, че през През последните няколко седмици, ние сме били въвеждане на компютър наука и, на свой ред, програмиране. 

И ние започнахме историята по пътя на Scratch, че графичен език от Media Lab на Масачузетския технологичен институт. И тогава най-скоро, миналата седмица, направихме ние въведе higher-- на език-ниско ниво познат като C, нещо, което е чисто текстова. И наистина, за последен път сме проучени в рамките на този контекст редица концепции. 

Това, изземване, е самото първата програма ще погледна. И тази програма, просто, отпечатва, "Здравей, свят". Но има толкова много сякаш магия става. Има тази #include с тези ъглови скоби. Има вътр. Има (недействителни). Има скоби, фигурни скоби, точка и запетая, и много повече. 

И така, припомни, че ние въведохме Scratch така че бихме могли, в идеалния случай, вижте минало че синтаксис, неща, които наистина не е всичко, което интелектуално Интересно, но в началото на деня е, абсолютно, малко сложно да приключи ума си наоколо. И наистина, един от най-често срещаните неща в началото на деня в един клас програмиране, особено за тези, които по-малко удобно, е да се разочароват от и спънал от определена синтактична грешки, да не говорим за логически грешки. И така сред нашите цели днес, всъщност, ще да бъде да ви снабди с някои решаване на проблеми техники за това как за по-добро решаване на проблемите си под формата на отстраняване на грешки. И вие ще си припомним също, че среда, ние въведохме последно време се нарича CS50 IDE. Това е уеб-базиран софтуер, който ви позволява да програмирате в облака, така да се каже, като същевременно запазят всичките си файлове заедно, тъй като ние отново ще се днес. И припомни, че ние преразгледани тези теми тук, сред тях функции, както и примки, и променливи и булеви изрази, и условия. И всъщност още няколко, които ние преведено от света на Scratch в света на C. 

Но основната сграда блокове, така да се каже, бяха наистина все още същото миналата седмица. В действителност, ние наистина просто имаше различен пъзел парче, ако щете. Вместо това лилаво запишете блок, ние вместо бе ФОРМАТ, което е тази функция в C, че ви позволява да отпечатате нещо и да го форматирате на екрана. Ние въведохме CS50 Библиотека, където можете имаме сега на свой get_char обезвреждане, и get_int, и get_string, и няколко други функции, добре, чрез които можете да получите вход от собствена клавиатура на потребителя. И ние също се погледнете на нещата като these- булев, и Чар, и двойно, поплавък, INT, long_long низ. А има и още други типове данни в C. 

С други думи, когато се декларират променлива за съхраняване на някои стойност, или когато се изпълнява функция който връща някаква стойност, можете да определите какво тип на стойност, която е. Дали това е низ, като последователност от символи? Дали това е номер, като цяло число? Дали това е плаваща запетая стойност, или други подобни? Така че в C, за разлика от нулата, ние всъщност започна да се уточни какъв вид данни ние се връщат или използване. 

Но, разбира се, ние също се блъсна в някои основни граници на изчислителната техника. И по-специално, този език C, изземване че ние разгледахме число преливник, реалността че, ако имате само един ограничен размер на паметта или, по-конкретно, краен брой на бита, можете само да разчитаме толкова висока. И така, ние погледна този пример тук при което брояч в самолет,, всъщност, ако работи достатъчно дълго, за да прелее и да доведе до софтуер действителен физически потенциал грешка. 

Ние също погледна към плаващ точка неточност, реалността че само с ограничен брой на бита, независимо дали е на 32 или 64, можете да посочите само толкова много номера след десетичната запетая, след което започне да се неточно. Така например, една трета в свят тук, в нашия човешки свят, Знаем, че е просто един безкраен брой от 3s след десетичната запетая. Но един компютър не може непременно представлява безкраен брой числа ако само му позволи някои ограничен обем информация. 

Така че не само, че ние ви снабди с по-голяма мощност от гледна как можете да изразите себе си в клавиатура от гледна точка на програмиране, Ние също така ограничава какво всъщност можете да направите. И наистина, бъгове и грешки могат възникнат от тези видове проблеми. И наистина, сред темите днес ще бъдат теми като отстраняване на грешки и всъщност търсят под капака как бяха въведени неща миналата седмица действително са приложени така че да можете по-добре разбирам и двете възможности на и ограниченията на език, като C. 

И в действителност, ние ще се лющи обратно слоевете от най-простите на структурата на данните, нещо, наречено масив, който Scratch случва да наречем "списък." Това е малко по- различно в този контекст. И тогава ние ще се представим един от най- първо на нашите домейни специфични проблеми в CS50, в света на криптография, изкуството на кодиране или в шифриране на информация, така че че можете да изпратите тайни послания и декодира тайни послания между две лица, A и B. 

Така че, преди да сме преход да, че нов свят, нека се опитаме да ви снабди с някои техники, с които можете да се елиминират или намаляване на поне някои на отчаянието че най-вероятно са се сблъсквали над сам изминалата седмица. В действителност, пред вас се such-- някои от Първите си проблеми в C. И шансовете са, ако сте като мен, за първи път опитате да напишете програма, дори и ако мислите логически програмата е доста проста, може много добре се удари в стената, и компилаторът няма да си сътрудничат. Уверете или звън не се случва действително да вършат работата си. 

И защо би могло да бъде това? Е, нека да погледнем, може би, една проста програма. Отивам да вървим напред и да спаси това в файл умишлено нарича buggy0.c, защото аз го знам, за да бъде опорочен предварително. Но аз може да не осъзнават, че ако тази е първата или втората или третата програма че аз съм всъщност прави себе си. Така че аз ще отида напред и напишете, INT главната (недействителни). И тогава вътре от моите големи скоби, много запознат ( "Здравей, world-- наклонена черта, п ") - и точка и запетая. 

Аз бях спасен файла. Сега аз ще сляза до терминал моя прозорец и тип грим buggy0, защото, отново, името на файла, днес е buggy0.c. Така че аз въведете направи buggy0, Enter. 

И, о, Боже, припомнят от последния път че няма съобщения за грешки е нещо добро. Така че без изход е нещо добро. Но тук имам ясно някои брой грешки. 

Така че на първа линия на изхода след въвеждане направи buggy0, изземване, е доста подробния изход звън е. Под предния капак, CS50 IDE е конфигуриран да използват цял ​​куп опции с този компилатор така че не е нужно да се мисли за тях. И това е всичко, че на първа линия средства, която започва с трясък. 

Но след това, проблемите, започват да се правят външния им вид. Buggy0.c на ред 3, характер 5, там е голям, червен грешка. Какво е това? Безусловно обявяване библиотека функция ФОРМАТ с тип INT (Конст Чар *, ...) [-Werror]. Искам да кажа, че е много бързо става много мистериозен. И разбира се, на първо поглед, ние не бихме Очаквам да се разбере цялост на това съобщение. И така, един от уроците за днес ще да бъде да се опита да се забележи модели или подобни неща, за грешки може да се наложи срещани в миналото. Така че нека да дразни с изключение само тези думи, които изглеждат познати. Големият, червено Грешката е ясно символ на нещо е погрешно. 

Безусловно обявяване библиотека функция ФОРМАТ. Така че дори и да не ми е ясно какво неявно обявяване библиотека функция средства, проблемът със сигурност се отнася до ФОРМАТ някак. А източникът на този въпрос има нещо общо с него се обявява. 

Деклариране на функция е тя се споменава за първи път. И ние използвахме терминологията миналата седмица на обявяване на функционални прототипи, или с една линия в горната част на вашия собствен файл или в така наречената заглавния файл. И в какво файл направихме ние казваме миналата седмица, че ФОРМАТ е цитат, край на цитата, обявена? В какво файл е негов прототип? 

Така че, ако си спомняте, първото нещо, което аз напечатан, почти всяка програма миналата time-- и случайно преди малко започна писането myself-- е този един here-- hash-- # включват <stio-- за вход / output-- точка з И наистина, ако сега запазите този файл, аз ще съм да вървим напред и да изчистите екрана ми, които можете да направите, като въведете Ясно, или да задържите Control L, само за да изчистите терминален прозорец само за да се премахнат някои елементарно. 

Отивам да се продължи напред и ре-тип грим buggy0, Enter. И готово, аз все още се види, че дълга команда от звън, но няма съобщение за грешка, този път. И наистина, ако аз ./buggy0 направя, точно като за последен път, където точка означава това директория, Слаш просто означава, тук идва и името на програмата и че името на програмата е buggy0, Въведете, "Здравей, свят". 

Сега, как може да имате придобит този разтвор без непременно признаване на колкото се може повече думи както направих аз, разбира се, като направил това за толкова много години? Е, да разбере, на първия проблем набор, ще ви запозная с една команда че собствения персонал CS50 е пише нарича help50. И наистина, C прави спецификация за проблемът определен за това как да използвате тази. 

Но help50 същество програма, която персонал CS50 е пише, че ви позволява да стартирате команда или изпълнение на програма, и ако ти не разбираш неговата изход, за да премине производството си, за да help50, при което софтуера че персоналът на курса е написал Ще разгледаме изход на вашата програма ред по ред, знак по знак. И ако ние, служителите, да признае съобщение за грешка, че сте изпитват, ние ще се опитаме да ви провокират с някои риторични въпроси, с някои съвети, много прилича на TF или CA или себе си ще направи лично в офис часа. 

Така че изглежда да help50 ако не го направите непременно признае проблем. Но не се разчита на него твърде много като патерица. Разбира се опитаме да разберем неговата изход и след това се поучим от него така че само веднъж или два пъти, което правите някога тече help50 за конкретна грешка съобщение. След това, вие трябва да бъдете по-добре оборудвана себе си за да разбера какво е в действителност. 

Нека да направим един друг тук. Нека да вървим напред, а в друг файл ще наричаме това buggy1.c. И в този файл съм Ще deliberately-- но се правя, че не го правят разбере какво грешка съм направил. 

Отивам да вървим напред и да направим this-- # включват, тъй като съм научих урока от преди малко. Int основни (свободен), както и преди. И тогава в тук Отивам да се направи струнни ите - get_string. И припомнят от последния път, че този път, хей, компютър, дайте ми една променлива, наричаме го е, и направи вида на тази променлива низ така че може да се съхранява една или повече думи в него. 

И след това в дясната ръка страна на знака за равенство се get_string, което е функция в библиотеката CS50 че прави точно това. Той получава функция и след това ИТ ръце от дясно на ляво. Така че този знак за равенство не означава, "Равнява", както бихме могли да мислим по математика. Това означава прехвърляне от дясно на ляво. Така че това означава, вземете низ от потребителя и да го съхранява вътре в с. 

Сега нека да го използвате. Нека вървим напред сега и като втори линия, нека да вървим напред и да кажа "здрасти" - не "свят", но "здравей,% s-- който е наш заместител, запетая и, което е нашата променлива, и след това запетая. Така че, ако аз не се притеснявам твърде много тук, това изглежда като правилния код. 

И инстинктите си сега трябва да я компилирате. Файлът се нарича buggy1.c. Така че аз ще направя направи buggy1, Enter. И дяволски-то, ако не съществува дори повече грешки, отколкото преди. Искам да кажа, има още съобщения за грешка, че ще Изглежда, отколкото действителните линии в тази програма. 

Но Takeaway тук е, дори ако сте претоварени с две или три, или още четири съобщения за грешки, съсредоточи винаги на самия Първата от тези съобщения. С поглед към най-много един, превъртане назад, както е необходимо. Така че тук аз напечатани изработка buggy1. Ето, че изход звън, както се очаква. 

И тук е първият червен грешката. Използването на недекларирания идентификатор низ, е имам предвид стандарт в? Така стандарт в е всъщност нещо друго. Това се отнася за потребителя клавиатура, по същество. 

Но това не е това, което имах предвид. Имах предвид, низ, и имах предвид get_string. Така че това, което е, че аз Забравих да направя този път? Какво липсва това време? Имам си # включват, така че да има достъп до ФОРМАТ. 

Но това, което мога да не трябва достъп до просто все още? Е, точно като за последен път, Трябва да се каже на компилатора Звън какво тези функции са. Get_string не идва с C. И по-специално, тя не идва в заглавния файл,. Той вместо да идва в нещо персонала пише, който е различен файл назове но ловко име. 

Така че, просто като добави, че един ред на code-- изземване от последния път че когато звън работи, то се случва да погледнем код ми горе до долу, Отляво надясно. Това ще забележите, О, вие искате. Нека да отидем и да откриете, че, където и да е на сървъра, копирате и да го поставите, по същество, в горната част на вашия собствен файл така че в този момент в историята, линия 1, до края на програмата да, наистина, да се използва някоя от функциите там, сред тях get_string. Така че аз отивам да се игнорира останалата част от тези грешки, защото, наистина, подозирам, че само първият действително има значение. И аз ще отида напред и разясняване, след спестяване на файла ми направи buggy1. И готово, го е направил труд. И ако го направя ./buggy1 и напишете, за Например, Zamyla, аз сега ще получите здравей, Zamyla, вместо здравей, свят. 

Добре. Така че на храна за вкъщи тук тогава да, един, се опита да събере колкото се може от съобщенията за грешки, сами по себе си, търси в някои от най-разпознаваемите думите. Пречи, че използвате help50 на проблема определя спецификация. Но за блокиране, които също винаги гледам в горната грешка само, най-малко първоначално, за да видите каква информация тя може в действителност да се получи. Но се оказва, че има още повече функционалност вградена в библиотеката CS50 да помогне вие в началото на семестъра и в началото на програмния разбера какво не е наред. Така че нека да направим още един пример тук. Отивам да наричаме това buggy2, които, отново, ще бъде опорочено от на портата, по дизайн. 

И аз ще отида напред и направи #include. И тогава аз ще направя INT главната (недействителни). И тогава аз ще направя за контур. За (INT I _ 0. I е по-малко от или равно на 10. аз ++, и след това в големи скоби, аз ще съм да разпечатате само символ маркер диез тук и нова линия характер. 

Така че моето намерение с този програма е доста просто да повторите 10 пъти и за всяка итерация на които контур всеки път чрез цикъл, разпечатате маркер диез, маркер диез, маркер диез. Един на ред, защото аз Трябва новата линия там. И припомни, че за линия, на последния week-- и ще получите повече запознат с синтаксис като тя се използва с практика преди long-- това ми дава променлива, наречена аз и го поставя на 0. 

Това увеличи стойноста аз на всяка итерация от 1. Така че отива до 1 към 2 до 3. И след това състояние в средната между точка и запетая получава проверява на всеки итерация да се направи сигурен, че ние все още сме в обхват. Така че аз искам да повторите 10 пъти, така че аз има нещо много интуитивно просто сложи 10 като горната ми граница там. 

И все пак, когато пускам това, след създаване, то с грим buggy2-- и тя се компилира OK. Така че аз не разполагат с синтактична грешка този път. Нека вървим напред сега и тичам buggy2, Enter. А сега превъртете нагоре. И нека да се увеличи размера на прозореца. 

Аз като че ли 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Така че има 11 маркери диез, въпреки че Аз ясно поставени 10 вътре в този цикъл. Сега, някои от които може да видите веднага което грешката е така, защото, наистина, този Не е много трудно грешка да се направи. Но това е много често направи много рано. 

Това, което искам да посоча, че, е, как бих могъл да разбера това? Е, оказва се, че на CS50 библиотека идва с не само get_string и get_int и get_float и други функции. Той също идва със специална функция наречен eprintf, или, ФОРМАТ грешка. И той съществува единствено, за да се направи тя е малко по-лесно за вас когато отстранявате грешки в кода, за да просто отпечата съобщение за грешка на екрана и знам от къде идва. 

Така например, едно нещо, което биха могли направите тук с тази функция е this-- eprintf, и тогава аз ще отида напред и да кажа сега аз се% аз, наклонена черта, п. И аз ще се включи в стойността на аз. И до върха, защото това е в библиотеката CS50, Отивам да се продължи напред и включва така че да има достъп до тази функция. Но нека да разгледаме какво линия 9 е трябвало да се прави. Отивам да изтриете това в крайна сметка. Това няма нищо общо с моята висша цел. Но eprintf, ФОРМАТ грешка, е просто означаваше да ми даде някаква информация за диагностика. Когато стартирам програмата ми, искам да виж това на екрана временно както и просто да се разбере какво става. 

И наистина, на всеки итерация тук на линия 9 Искам да видя, каква е стойността на аз? Каква е стойността на аз? Каква е стойността на аз? И, надявам се, аз само трябва видим, че съобщение, също, 10 пъти. 

Така че нека да вървим напред и да компилирате програмата си, като трябва да направя всяко време Аз се направи промяна. ./buggy2. И now-- OK. Има много по-става. Така че нека да се придвижите нагоре в още по-голям прозорец. 

И ще видите, че всеки един от на Hashtags все още се печата. Но в между всеки от тях сега това е диагностичен изход форматиран както следва. Името на програмата ми тук е buggy2. Името на файла е buggy2.c. Номерът на реда, от които това е отпечатана е линия 9. И след това в дясно от които е съобщение за грешка, че съм очаквал. 

И това, което е хубаво за това е, че Сега не е нужно да е задължително да се брои в главата ми какво ми програма се прави. Виждам, че на Първото повторение I е 0, след 1, след това 2, след това 3, след това 4, след това 5, след това 6, след това 7, след това 8, след това 9, тогава 10. Така че чакай малко. Какво става тук? Аз все още като че ли се брои по предназначение до 10. 

Но откъде да започнем? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. Така 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11 пръста е показателно за проблема. Изглежда съм преброени неправилно в моята линия. Вместо да отидат 10 повторения, Аз съм се започне от 0, Аз съм завършващ в и чрез 10. Но тъй като компютър, Аз съм се започне преброяване на 0, Аз трябва да се брои , но не чрез, 10. 

И така уговорката, че в крайна сметка реализира тук, е едно от двете неща. Аз може би просто се каже, брои до по-малко от 10. Така 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, което е, наистина, правилно, макар и да звучи малко погрешно. Или мога да направя по-малко или равно до 9, така че стига да започне в 0. Или ако наистина не ми харесва, че сте може да разчита нагоре през 10, но започват от 1. Но отново, това просто не е, че общата. В programming-- макар и не толкова в Scratch-- но в програмирането в C и други езици, като JavaScript и Python и други, това е Просто много често за нашата дискусия на двоичен просто да започнете да броим в най-малък брой можете, която е 0. Добре. Така че това е eprintf. И отново, сега, че съм разбрал ми проблем, и аз ще се върна към 0 чрез по-малко от 10, аз ще съм да ида и да изтрие eprintf. 

Тя не трябва да бъде там, когато аз кораб моя код или изпратете ми код или го покаже на някой друг. Това е наистина просто означаваше да се използва за временно. Но сега съм фиксиран това конкретен проблем, както добре. 

Е, нека да направим още един пример тук че аз отивам да привличам, както следва. Отивам да се продължи напред и # включват. $ 50 И аз ще отида напред и #include. 

И аз ще се спаси този файл като buggy3.c. И аз ще отида напред и декларира INT главната (недействителни). И тогава вътре има Отивам да направя INT I _ - Искам да се приложи програма с get_negative_int. Това не е функция, която съществува все още. Така че ние ще се приложат то в един момент. Но ние ще се види защо това е бъгав при първо преминаване. И след като съм намерила пад от потребителя, Аз съм просто ще отпечатате% и е отрицателен число, наклонена черта, п, запетая, аз. С други думи, всичко, което Искам тази програма, за да се направи се получи отрицателен инт от на потребителя и след това отпечатайте че такъв и такъв е отрицателен вътр. 

Сега трябва да се приложи тази функция. Така че по-късно в досието ми, аз ще отида напред и декларира функция, наречена get_negative_int (свободен) - и ние ще се върна към това, което означава отново тази линия в moment-- INT N; do-- задачи following-- ФОРМАТ п е :. И тогава аз ще направя п - get_int, и направи това, докато п е по-голямо от 0. И след това се върнете н ;. 

Така че има много неща се случват в това, но нито един от които не е погледнете миналата седмица, поне за кратко. Така че по линия 10 тук съм обявен за функция, наречена get_negative_int, и аз сме поставени (свободен), в скоби, Причината е тази не взема един вход. Аз не съм преминаване нищо за тази функция. Аз съм просто се нещо обратно от него. 

И това, което аз съм с надеждата да се върна е цяло число. Не е тип данни в С нарича negative_int. Това е просто INT, така че ще да бъде на нас, за да се уверите, че стойността, която е действително Върнато е не само инт но също е отрицателно. 

На линия 12 Аз съм за обявяване на променлива нарича н и я направи на тип Int. И след това в ред 13 до 18 съм прави нещо, докато нещо не е вярно. Отивам напред и печат п е, дебелото черво, и след това пространство, като изисква от потребителя. 

след това се обаждам get_int и съхраняване на така наречените връщане стойност в тази променлива п. Но аз ще продължавам това, докато п е по-голямо от 0. С други думи, ако потребителят ми дава Int и този брой е по-голям от 0, Ergo, положително, аз ще просто да reprompting на потребителя, запази reprompting, като ги принуждава да сътрудничат и да ми даде отрицателен вътр. 

И след като п е всъщност negative-- Предполагам, че потребителят накрая видове -50, След тази линия, докато вече не е вярно, защото -50 е не по-голямо от 0. Така че ние се измъкнат от това контур логично и да се върнат п. 

Но има и един друг нещо, което трябва да направите. И аз може просто да направите това от копиране и поставяне един ред код в началото на файла. Трябва да се научи звън, или обещават да звън, изрично, че ще го направя, Наистина, отидете и да приложат тази функция get_negative_int. Той може просто да бъде по-ниска в файла. Отново, припомни, че звън чете неща горе до долу, от ляво на дясно, така че не може извикате функция, ако звън не знае, че ще съществува. 

Сега, за съжаление, тази програма, Както някои от вас може би сте забелязали, е вече бъги. Нека да вървим напред и да направи buggy3. Той съставя, така че моят проблем сега не е синтактична грешка, като грешка текстова, това е всъщност ще бъде логична грешка, която съм умишлено направена като възможност за преминете през това, което се случва. 

Отивам да се продължи напред Сега и тече buggy3. И аз ще отида напред и да не сътрудничи. Отивам да го дам номер 1. Тя не го харесва, така че Това ме накара отново. 

Какво ще кажете за 2? 3? 50? Нито един от тези, които работят. Как около -50? И програмата изглежда да работи. 

Нека се опитаме още веднъж. Нека се опитам -1, изглежда да работи. Нека се опитам -2, изглежда да работи. Нека се опитам 0. Хм, това е неправилно. Сега, ние сме в малко педантичен тук. Но това е, наистина, при които 0 не е нито положително, нито отрицателно. И така факта, че моята програма е казвайки, че 0 е отрицателно число, това не е технически правилно. 

Сега, защо се прави това? Е, това може да е очевидно. И наистина, програмата е трябвало да бъде доста проста Така че ние имаме нещо да се изследват. 

Но нека да се въведе трета отстраняване на грешки Техниката тук наречен debug50. Така че това е програма, че ние току-що създадена тази година, наречен debug50 който ще ви позволи да използват това, което се нарича вграден графичен дебъгер в CS50 IDE. И за корекция на грешки е просто една програма, която обикновено ви позволява да стартирате програмата но стъпка по стъпка по стъпка, линия от ред по ред, спирайки, изпълзяват наоколо, погледнете в променливи, така че програмата не само взриви покрай вас и бързо отпечатване на нещо или не отпечата нещо. Тя ви дава възможност, при човешки скорост, да взаимодейства с него. 

И за да направите това, вие просто направете следното. След съставянето на кода си, което аз вече направих, buggy3, отидете напред и да тичам debug50 ./buggy. Така че много прилича help50 има изпълнявате help50 и след командата, debug50 има ли тече debug50 и след името на командата. 

Сега гледам какво се случва на екрана си, на дясната ръка и по-специално. Когато удари Run, всички от внезапна този десен панел отваря на екрана. А има и много неща се случват на пръв поглед. Но там не е твърде много да се притеснявате за още. 

Това ми показва всичко което се случва вътре в моята програма точно сега и чрез тях копчета до върха е след това че ми позволи да се засили чрез моя код в крайна сметка стъпка по стъпка по стъпка. Но не, просто все още. Забележете какво се случва. На терминал моя прозорец Аз съм се появи подкана за п. И аз ще отида напред и сътрудничат това време и тип в -1. И макар и малко загадъчно, -1 е отрицателно число, както се очаква. 

И тогава детето излезе с статус 0 GDBserver излизане. GDB, GNU Debugger, е името на базовия софтуер който реализира тази дебъгер. Но всичко това наистина означава, дебъгер си отиде, защото програмата ми откажат и всичко е наред. Ако искам наистина да трасира моята програма, Аз трябва да изпреварващо да кажа debug50, Къде мога да искате да започнете засилване през моя код? 

И може би най-простият начин да се направи това е, както следва. Ако мишката върху канавката на моя редактор тук, така наистина само в страничната лента тук, от лявата страна на номера на реда, Забележете, че ако аз просто кликнете веднъж, сложих малко червена точка. И това малко червена точка, като знак стоп, означава, хей, debug50, изпълнение пауза на моя код точно там, когато стартирате тази програма. 

Така че нека да направим това. Нека да вървим напред и да стартирате програмата си отново с debug50 ./buggy3, Enter. И сега, известие, нещо различно се е случило. Аз не съм питане Все още в терминал моя прозорец за нищо, защото не съм намерила там все още в моята програма. Забележете, че по линия 8 които сега се освети, и там е малко по-стрелка в лявото поговорка, която се спря тук. Тази линия на код, линия 8, все още не е изпълнена. 

И това, което е любопитно, ако аз гледам тук на дясната ръка, Забележете, че е местен променлива, местно, в смисъл, че това е в рамките на текущата функция. И неговата стойност, очевидно по подразбиране, и нещо удобно, е 0. Но аз не се объркате 0. Това просто се случва да бъде неговата стойност по подразбиране в момента. 

Така че нека да вървим напред и да направим това сега. Нека да вървим напред и на на върха точно тук, аз съм ще отида напред и кликнете тази първа икона, която означава стъпка над което означава, не пропускай го, но се оттегли през тази линия на код, тя изпълнява по протежение на пътя. 

И сега, забележете, ми бързо е просто променен. Защо така? Казах debug50, изпълня този ред код. Какво прави този ред код направя? ме пита за едно цяло число. ДОБРЕ. Нека да си сътрудничат. Нека вървим напред сега и въведете -1, Enter. И сега забележи какво се е променило. На дясната ръка, моята локална променлива аз е показан като -1 сега. И все пак е от тип Int. 

И известие, също ми т.нар наричаме стак, където се поставя на пауза? Ще говорим повече за това това в бъдеще. Но стека повикване просто се отнася до това, което функции в момента са в движение. Точно сега това е просто основна. И точно сега единственото местно променлива е и със стойност 1. 

И когато най-накрая се оттегли през тази линия тук, с които същата икона горе в дясно, -1 Е отрицателно число. Сега се спираше върху които фигурна скоба. Нека позволим на това, че направи нещо. I стъпка над тази линия, и готово. 

Така че не всичко, което ужасно поучително още, но това ми позволи да направите пауза и мисля, че чрез логически това, което тази програма се прави. Но това не е най-погрешното случая. Нека да направим това отново, както следва. 

Отивам да напуснат тази точка на прекъсване по линия 8 с червена точка. Отивам да се преиграва debug50. Тя автоматично се спря тук. Но този път, вместо да прекрачи тази линия, нека действително да влезем вътре на get_negative_int и да разбера, защо се приема 0 като валиден отговор? 

Така че вместо да кликнете Step Over. Отивам да се продължи напред и кликнете Step Into. И забележете, че линията 8, която е Сега подчерта сега изведнъж става линия 17. 

Сега, това не е толкова дебъгер е пропуснато линии 14 и 15 и 16. Това е просто няма нищо да ви покаже там. Тези, които са само за обявяване променливи, И тогава там е думата Смятате и след това отворен фигурна скоба. Единствената функционална линия, която е сочен наистина е този тук, 17. И това е, когато ние сме замълча автоматично. 

Така ФОРМАТ ( "n.is:") ;, така че не се е случило все още. Така че нека да вървим напред и да кликнете прекрача. Сега ми бързо, наистина, променен на ( "п"). Сега get_int, аз няма да се притеснява засилване в, защото тази функция е направено от CS50 в библиотеката. Това е вероятно правилно. 

Така че аз ще отида напред и сортиране на сътрудничат, като му дава пад, но не отрицателно вътр. Така че нека да вървим напред и да се удари 0. И сега какво се случва тук когато се прибера до ред 21? Аз не съм повтори отново. Аз не изглежда да се залепи в тази линия. С други думи, тази жълто бар не продължавай наоколо, и наоколо, и наоколо. 

Сега, защо е това? Е, п, какво е N точно сега? Мога да погледна на местно променливи в дебъгер. п е 0. Добре, какво е състоянието ми? 

20-- линия 20 е, добре, 0 е по-голямо от 0. Това не е вярно. 0 е не по-голямо от 0. И така, аз се измъкна от това. 

И така, ето защо на линия 21, ако аз действително да продължи, Отивам да се върне 0, дори макар че е трябвало да отхвърли 0 като всъщност не е отрицателен. Така че сега, аз наистина не дори грижа за дебъгер. Ясно, че не е нужно да се знам какво още се случва. 

Така че аз ще отида напред и Просто кликнете върху бутона за възпроизвеждане, и нека този финал нагоре. Сега, аз осъзнах, че ми бъг е очевидно по линия 20. Това ми е логическа грешка. 

И така, това, което искам да направя, за да се промени това? Ако проблемът е, че аз не съм улов 0, това е просто една логическа грешка. И мога да кажа, а п е по-голямо от или равно на 0, запази накара потребителят отново и отново. 

Така че, отново, просто грешка, може би дори очевидни, когато ме видя, го напиша само преди няколко минути. Но Takeaway тук е, че с отстраняване на грешки 50, и с отстраняване на грешки софтуер по-общо, имате тази нова намери сила да разходка из собствения си код, изглежда чрез които десен панел ръка какво променливите стойности са. Така че не е задължително Трябва да се използва нещо като теб eprintf да отпечатате тези стойности. Всъщност можете да ги видите визуално на екрана. 

Сега, след това, че си струва да се отбележи, че има и друга техника, която е всъщност супер общ. И може да се чудя защо този малък човек тук е седял на сцената. Така че има тази техника, като цяло известен като гумено пате отстраняване на грешки, което наистина е просто свидетелство за факта, които често, когато програмисти пишете код, те не са непременно сътрудничество с други, или работят в обща среда. 

Те са нещо като у дома си. Може би това е късно през нощта. Те се опитват да фигура някои бъгове в своя код. И те просто не го виждам. 

И няма съквартирант. Не е TF. Не е около СА. Всички те имат за своя рафт е тази малка гумена пиленце. 

И така, друже отстраняване на грешки е точно тази покана да се мисли за нещо като глупав тъй като това като реален създание, и всъщност ходят чрез своя код устно на този неодушевен предмет. Така, например, ако това е моят пример here-- и припомни, че по-рано проблема е този, ако изтрия тази първа линия на код, и аз отида напред и да направи бъги 0 отново, Припомняме, че имах тези съобщения за грешки тук. Така че идеята тук, смешно, че аз чувствам в момента прави това публично, е, че грешка. 

ОК, така че моят проблем е, че аз съм имплицитно обявен функция библиотека. И тази функция библиотека е ФОРМАТ. Declare-- OK, декларират ми напомня на прототипа. 

Това означава, че трябва да всъщност кажете на компилатора предварително какво функцията изглежда така. Чакай малко. Не съм имал стандарт io.h. Благодаря ти много. 

Така че просто този процес of-- ви не е нужно да имаме всъщност патица. Но тази идея за ходене себе си чрез своя собствен код така че можете дори чуете себе си, така че да осъзнават, пропуски в собствения си забележки, по принцип е идеята. 

И, може би по-логично, не толкова много от това, но на по-голямо участие Например ние просто направихме в бъги 3.В, може да се преведе през него както следва. Така че всичко е наред, каучук пиленце, DDB, ако щете. Тук имаме в моята основна функция, Обаждам се отрицателната вътр. 

И аз съм се върнатата стойност. Аз съм го съхраняване на лявата ръка по линия 8 в променлива наречена аз. ОК, но изчакайте, как е че се получи, че стойността? Нека да разгледаме функцията в ред 12. 

В ред 12, ние имаме получите отрицателен вътр. Не се предприемат никакви входове, се връща едно цяло число, OK. Декларирам, по линия 14 с променлива п. Това ще съхранява цяло число. Това е, което искам. 

Така че направете следното, докато п is-- нека ми отмените какво уговорката аз вече направени. Така че, докато п е по-голямо от 0, разпечатате п е ОК. И след това се обадете се инт съхранява в п. И след това проверете дали п е 0, п е not-- там е. Така че, отново, не е нужда от действителната патица. Но просто ходене себе си чрез кода си като интелектуално упражнение често ще ви помогне осъзнават какво се случва, за разлика от просто прави нещо като този, взирайки се в екрана, и не говорим себе си чрез това, което честно казано не е толкова ефективна техника. Така че има ли го, а няколко различни техники за действително коригирането на грешките в кода и укорява, всички от които трябва да са инструменти във вашия инструментариум така че не си късно през нощта, особено, вие сте в трапезарията зали, или в работно време, Блъскането на главата на стена, се опитва да реши някакъв проблем. Осъзнайте, че има софтуерни инструменти. Има гумени инструменти патица. И там е цяло персонала на подкрепа, чакащи да подадат ръка. 

Така че сега, и дума по проблема комплекти, и на това, което ние с вас с надеждата да излезе от тях, и как отиваме за оценяване. Per учебната програма на курса, проблемни комплекти CS50 е се оценяват по четири основни оси, така че да speak-- обхват, коректност, дизайн, и стил. И обхват просто се отнася до това колко на парчето са ви отхапал? Как кой знае какъв проблем сте опитвали? Какво ниво на усилие са ви проявява? 

Коректността е, върши работата на програмата, както е това е трябвало да спецификация CS50 когато ви предостави някои входове или някои изходи се върне? Design е най-субективният от тях. И това е този, който ще вземе най-дълго, за да научите и най-дълго, за да научи, в доколкото то се свежда до това, колко добре написан е кода си? 

Това е едно нещо просто да отпечатате правилно изходи или връщане на точните стойности. Но го правиш като ефективно възможно, тъй като? Възможно ли е да го прави разделение и владей, или двоичен търсене, тъй като ние скоро ще видите, че ние направихме преди две седмици с телефонния указател? Има по-добри начини за решаване на проблем, отколкото в момента имате тук? Това е една възможност за по-добър дизайн. 

И тогава style-- как доста е кода си? Ще забележите, че аз съм доста специално за редовете на моя код, и като се уверите, моите променливи са разумни име. N, докато кратко, е добро име за номер, аз за броене число, ите за низ. И ние можем да имаме по-дълго променлива имена стил. Style е точно колко добър изглежда кода си? И как се чете, че е? 

И с течение на времето, това, което си TAS и TFS ще правят в хода е ви осигури, че вид качествена обратна връзка така че да получите по-добре при тези различни аспекти. И по отношение на начина, по който оцени всяка от тези оси, това е обикновено с много малко кофи, така че вие, като цяло, се получи усещане за това колко добре сте прави. И наистина, ако получите резултат на всяко от тези axes-- коректност, дизайн и стил especially-- този брой обикновено ще бъде между 1 и 5. И, буквално, ако сте се 3 е в началото на семестъра, това е много добро нещо. Това означава, че все още има Стая за подобрения, които ще се надяваме за в като клас за първи път. Има надяваме някои малко на таван към която сте се стремят към постигане. И така става 3 относно най-ранните парчета, ако не някои 2 и 4 се, е, наистина, е нещо добро. Това е добре в рамките на диапазон, и в рамките на очакванията. 

И ако съзнанието ти се състезава, изчакайте една минута, три от пет. Това е наистина една 6 от 10. Това е 60%. Боже мой, това е F. 

Не е. Това не е, в действителност, че. По-скоро, това е една възможност да се подобри в течение на семестъра. И ако сте се някои Poors, те са възможност да се възползват от работното време, със сигурност секции и други ресурси. 

Най-добър е възможност, наистина, да се гордеем с това колко далеч сте дойде в течение на семестъра. Така че си дават сметка, ако нищо друго, три е добър. И това позволява място за растеж в течение на времето. 

Що се отнася до това как тези оси са претеглена, реалистично ли сте ще прекарват по-голямата част от времето си удар неща да работят, да не говорим за правилно. И така, коректност има тенденция да се претегля най-много, тъй като с това мултипликативен коефициент три. Дизайнът е също важно, но нещо, което не е задължително харчат всички тези часове опитвайки се да получите нещата просто да работят. 

И така, това е претеглен малко по-леко. И тогава стил се претегля най-малко. Въпреки че това не по-малко е важно фундаментално, това е просто, може би, Най-лесният нещо да направя така, имитират ние примери направя в лекция и раздел, с нещата добре разчленена, и коментира, и така нататък, е сред най-лесните неща за вършене и се прави. Така че като такива, да разбере, че тези, които са точки които са сравнително лесно да се разбере. 

А сега няколко думи за this-- академична честност. Така че на на курса учебната програма, ще видите, че по време има доста малко на език около това. И по време отнема издаването на академична честност доста сериозно. 

Имаме разграничението, за добро или за лошо, на които са изпратени всяка година повече студенти за дисциплинарни действия от най-всяка друга Разбира се, че съм запознат. Това не е непременно показателни за факта, че CS студенти, или CS50 студенти, са всяко по-малко честен от съучениците си. Но реалността, че в този свят, по електронен път, ние просто имат технологично средства за откриване на това. 

Това е важно за нас, за справедливост в целия клас че правим открие това, и да се повиши въпросът, когато виждаме нещата. И само за да нарисува картина, и наистина да помогне нещо подобно мивка в, това са номерата на студенти през последните 10 години че са били замесени в някои такива въпроси на академичната честност, с около 32 ученици от есента 2015 г., което е да се каже, че ние не приемайте въпроса много сериозно. И, в крайна сметка, тези номера съставят, Съвсем наскоро около 3%, 4%, или на класа. 

Така че за супер-голямата част от учениците изглежда, че линиите са ясни. Но имайте това против, особено късно през нощта, когато се борят с някакво решение по отношение на набор проблем, че са налице механизми за себе си все по-добре подкрепа, отколкото може да мисля, дори и в този час. Осъзнайте, че когато получим студентски изявления, ние пресичат сравни всяко представяне тази година срещу всеки представяне миналата година, срещу всеки представяне от 2007 г., и тъй, като гледаше, както и, код хранилищата онлайн, дискусионни форуми, сайтове за работа. И ние говорим за това, Наистина, всичко заради на пълно разкриване, че ако някой друг може да го намерите онлайн, със сигурност, така че можем курса. Но, наистина, на духа на курса се свежда за тази клауза в учебната програма. Това наистина е просто, да бъдат разумни. 

И ако ние трябваше да се изработи по този с малко повече езика, осъзнават, че същността на всички работа, която ви представя този курс трябва да бъде вашата собствена. Но в рамките на това, има със сигурност възможности, както и насърчаване, и педагогическа стойност в превръщането на others-- себе си, на TFS, КО, на TAS, и останалите в този клас, за подкрепа, да не говорим за приятели и съквартиранти, които са учили CS и програмиране преди. И така, има надбавка за това. А общото правило на палеца е this-- когато с молба за помощ, може да покаже кода си на другите, но вие не може да видите техните. Така че, дори ако сте на работното време, или в D зала, или някъде другаде работи върху някои парче набор, работи заедно с един приятел, който е напълно глоба, в край на работата си за деня трябва в крайна сметка да принадлежат към всеки на вас, съответно, и не бъдат някои съвместни усилия, с изключение на крайния проект, където това е позволено и насърчава. 

Осъзнайте, че ако сте борейки се с нещо и твоят приятел просто се случва да бъде по-добре в това тогава, или по-добре в този проблем, отколкото сте, или малко по-напред от вас, това е напълно логично да се включите да си приятел и да кажа, хей, Имате ли нещо против погледнете в моя код тук, помогнете ми забележи какво е моя въпрос? И, надявам се, в интерес на педагогическа стойност че приятел не само кажа, о, правя това, а по-скоро, какво липсва на линия 6, или нещо подобно? Но решението не е за приятел до теб да се каже, ох, добре, тук, нека да дръпне това нагоре, и да се покаже моето решение за вас. Така че е линията. Вие показвате вашия код за други, но не можете да видите техните, при спазване на останалите ограничения в учебната програма на курса. 

Така че имайте предвид това така наречената клауза съжаление в учебната програма на курса, както и, че ако се ангажират някои акт, който Не е разумно, но това доведе до На вниманието на ръководителите на курса в рамките на 72 часа, по време могат да налагат местни санкции, които може да включва незадоволителен или негативна оценка за работата представен. Но разбира се, не ще се позовават на значение за по-нататъшното дисциплинарни действия, освен в случаите на многократни актове. С други думи, ако го направите, да направи някои глупаво, особено късно вечер, решение че следващата сутрин или два дни по-късно, се събуждаш и осъзнаваш, това, което си мислех? Можете да направите в CS50 имат излаз за определяне на този проблем и е собственик до него, така че да можем Ще се срещнем по средата и да се справят с това е въпрос, който е едновременно образователна и ценно за вас, но все още наказателна по някакъв начин. И сега, за да се вземат ръба на разстояние, това. 

[Възпроизвеждане на видео] 

[МУЗИКА] 

[END PLAYBACK] Дейвид Дж Малан: Добре, ние сме назад. И сега ние гледаме на един от най- първо на нашите реалния свят домейни в CS50, изкуството на криптографията, изкуството на изпращане и получаване на тайни послания, криптирана съобщения, ако щете, които могат да бъдат разчетени само ако имате някои ключова съставка че подателят има както добре. Така че, за да мотивира това ние ще се Един поглед към това нещо тук, което е пример за тайна декодер пръстен, който може да се използва, за да разбера какво всъщност е тайно послание. Всъщност, обратно в ден в началното училище, ако някога изпрати тайни съобщения до някой приятел или някой влюбен в клас, може би си помислил сте умен от по парче си за промяна на хартия, като, от А до Б, и В, за да C и C до D, и т.н. Но вие всъщност криптиране вашата информация, дори ако беше малко по-тривиално, не беше че трудно за учителя да се реализира, добре, ако просто се промени B към A и C до точка Б, всъщност разбера какво е посланието, но сте били в шифриране на информация. 

Можете просто да го прави просто, много прилича Ралфи тук в известен филм, който играе доста много реклама nauseum всяка зима. [Възпроизвеждане на видео] Бензен-то известно на всички, че Ралф Паркър е тук назначен за член на малката Orphan Annie Secret Circle и има право на всички почести и ползи, настъпили към него. 

-Signed, Little Annie сираци, контра-подписан Пиер Андре, с мастило. Honors и ползи, вече на възраст от девет. 

[Крещеше] -Хайде. Нека се заемем с него. Нямам нужда от всичко, което джаз за контрабандисти и пирати. 

-Listen Утре вечер за заключителната приключението на черен пиратския кораб. Сега е време за тайно съобщение на Ани за вас, членовете на Тайният кръг. Помнете, деца, само за членове на Secret Circle Ани може да декодира тайно съобщение на Ани. 

Не забравяйте, че Ани е в зависимост от вас. Задайте вашите игли за B2. Ето съобщението. 12, 11-- 

-Аз Съм в, първата ми тайна среща. 

-14, 11, 18, 16. 

-Pierre Беше в силен глас тази вечер. Мога да кажа, че тази вечер съобщение е наистина важно. 

-3, 25, това е съобщение от себе си Ани. Не забравяйте, не казвай на никого. 

-90 Секунди по-късно, аз съм в единствения стая в къщата, в която едно момче на девет може да седне в личния живот и декодиране. Аха, B! Отидох до следващия, Е. 

Първата дума е било. S, то щеше да дойде по-лесно сега, U, 25-- 

-О, Хайде, Ралфи, аз трябва да отида! 

-Ще Бъде чак, Ма! Gee факир! 

-Т, О, бъдете сигурни, to-- бъде сигурен с какво? Какво е Little Orphan Ани се опитвам да кажа? Бъдете сигурни с какво? 

-Ralphie, Анди има да отида, ще ви моля да излезе? 

-Всички Полето, Ma! Аз ще бъда прав вън! 

-I Е все по-близо сега. Напрежението беше ужасно. Какво беше? Съдбата на планетата може да виси на косъм. 

-Ralphie! Трябва Анди вървим! 

-Ще Бъда прав вън, за да плаче на глас! 

-Almost Там, пръстите ми летяха, съзнанието ми Беше стомана капан, всяка пора вибрира. Това беше почти ясно, да, да, да. 

Бензен-забравяйте да пиете си Овалтин. Ovaltine? А калпав търговски? Кучи син. [END PLAYBACK] Дейвид Дж Малан: ОК, така че че е много дълъг път за въвеждане на криптографията, и също Овалтин. В действителност, от тази стара обява тук, защо е Овалтин толкова добър? Тя е концентрирана извличане на зрели ечемичен малц, чист кремообразна краве мляко, и специално приготвени какао, заедно с естествени фосфатиди и витамини. Освен това той се обогатява с допълнителни витамини от група В и D, Yum. И все пак можете да го получите, както изглежда, на Amazon, както направихме тук. 

Но мотивацията тук е да се въведат криптография, по-специално тип криптография познат като секретен ключ, криптография. И както подсказва и името, като цяло сигурност на таен ключ система крипто, ако щете, методология само за кодиране информация между двама души, е, че само на подателя и получателя само знаете таен key-- някаква стойност, някои тайна фраза, някакъв таен номер, че им позволява да и двете криптиране и декриптира информация. И криптография, наистина, е точно това, от седмица 0. 

Това е проблем, когато има входове, като действителната съобщение на английски език или какъвто и език, които можете искате да изпратите на някого в клас, или в интернет. Има някои изход, което се случва да бъде кодирано съобщение, че сте искате получателят да получи. И дори, ако някой в средна, която получава прекалено, не ги искат да е задължително да бъде в състояние да го разшифровате, защото вътре в този черна кутия, или алгоритъм, е някакъв механизъм, някои стъпка по стъпка инструкции, за вземане на този вход и превръщането му в изход, в надявам се по сигурен начин. 

И, всъщност, има някои лексика в този свят, както следва. Обикновен текст е дума компютърен учен би използва, за да опише на входа съобщение, като англичаните или каквото и да език всъщност искате да изпратите на някой друг човек. И тогава ciphertext е надпреварата до кодирана, или криптирани, версия за това. 

Но има и една друга съставка тук. Има един друг вход, за да таен ключ криптография. И това е самият ключ, което е, обикновено, както ще видим, номер, или писмо, или дума, каквото алгоритъм е всъщност очаква. 

И как да декриптира информация? Как да го разшифровам? Е, ти просто се обърне изходи и входове. 

С други думи, след като някой получава вашата криптирани съобщения, той или тя просто има да се знае, че един и същ ключ. Те са получили ciphertext. И като включите тези две вложения в системата на крипто, алгоритъма, тази черна кутия, изложени трябва да дойде оригиналния прав текст. И така, това е много високо ниво Предвид на това, което криптография е всъщност всичко за. 

Така че нека да стигнем до там. Нека сега да разгледаме под капака на нещо ние сме били като за даденост, за изминалата седмица, и за тази сесия here-- низа. Низ в края на деня е просто поредица от символи. 

То може да бъде здравей свят, или здравей Zamyla, или каквото. Но какво означава това за да бъде последователност от символи? В действителност, библиотеката CS50 дава ни един тип данни, наречен низ. 

Но там е всъщност не такова нещо като низ в C. Това наистина е просто поредица от характер, характер, характер, характер, обратно, за да архивирате, да обратно, за да архивирате, за да направите резервно вътре от паметта на компютъра, или RAM. И ние ще разгледаме по-дълбоко в това, че в бъдеще, когато се вгледаме в себе си памет, и оползотворяването и заплахи, които са включени. 

Но нека разгледаме низа Zamyla. Така че просто името на човекът тук, Zamyla, че е последователност от символи, Z-A-М-Y-L-A. А сега нека да предположим, че името Zamyla на се съхранява вътре в компютър програма. 

Е, очевидно е, че ние трябва да да е в състояние да погледнете тези символи индивидуално. Така че аз съм просто ще направи малко каре около името Zamyla тук. И това е така в C, че когато има низ, като Zamyla-- и може би че низ се е върнал от функция като GET низ, всъщност може да се манипулира то знак по знак. 

Сега, това е уместен за разговор в ръка, защото в криптографията, ако искате да се промени А към Б и В на С и С до D, и така нататък, което трябва да бъде в състояние да разгледаме отделните герои в низ. Трябва да бъде в състояние да се промени на Z към нещо друго, А за нещо друго, на м нещо друго, и така нататък. И така, ние се нуждаем от по начин, програмно, така да се каже, в C, за да може да се промени и погледнете в отделни писма. И ние можем да направим това, както следва. 

Оставете ме да се насочват обратно в CS50 IDE. И нека да вървим напред и да се създаде нов файл че ще се обадя този път string0, като първата ни като например точка, гр. И аз ще отида напред и го привличам, както следва. 

Така че да включва CS50.h, и След това включва стандартен io.h, което аз съм почти винаги ще да бъде използване в моите програми, най-малко първоначално. INT главната нищожен, а след това в тук съм ще направим струни получава получите низ. И тогава аз ще давай напред и да направим това. Искам да отида напред и, като проверка на здрав разум, само да кажа, здравей, процента ите, точка и запетая, прави низ 0. Ъъъ, това, което съм направил тук? О, аз не го включите. Така урок научих, че не беше умишлено. 

Така че грешка, повече процента реализации, отколкото аргументи данни. И това е мястото, където, в Онлайн 7-- ОК, така че аз нямам, цитат цитата, че е низ ми да ФОРМАТ. Имам един знак за процент. Но аз съм липсва втория аргумент. 

Аз съм липсва запетая S, който Аз нямаше в предишните примери. Така че по-добра възможност да се определи още една грешка, случайно. А сега нека да тече string0, тип в Zamyla. ОК, здравей Zamyla. 

Така че ние сме тече този вид програма няколко различни времена сега. Но нека да се направи нещо по- малко по-различно този път. Вместо просто да печатате Zamyla на Цялата име с ФОРМАТ, нека го направим знак по знак. 

Отивам да се използва за линия. И аз ще се предам променлива броене, наречена I. И аз ще се запази следващите стъпки, така че стига да е по-малка от дължината на S. 

Оказва се, че не е направил направим това последно време, че в идва с функция, наречена Стърлинг. Обратно, в деня, и като цяло още при изпълнението на функции, хората често ще избират много кратки имена, че вид на звук като това, което искате, въпреки че е липсват няколко гласни или букви. Така Stirling е име на функция, която приема аргумент между скоби, които трябва да бъдат низ. И то просто се връща цяло число, Продължителността на този низ. 

Така че това за линия по линия 7 се случва да започне преброяване на I е равна на 0. Това ще увеличите и на всяка итерация от 1, тъй като ние сме били прави няколко пъти. Но това се случва само правя това, докато точката когато е дължината на самия низ. 

Така че това е начин да се, в крайна сметка, итерации над героите в низа като Е. следва. Отивам да разпечатате не целият низ, но процента в, един символ последвано от нов ред. И тогава аз ще давай, и имам нужда да кажем, че искате да отпечатате Ith характер на лидер. 

Така че, ако аз е променлива, която показва, индекса на низа, където Вие сте в това, че трябва да бъде в състояние да се каже, дай ми Ith характер на лидер. И в има начин за правене това с квадратни скоби. Можете просто да каже името на низ, който в този случай е лидер. След това можете да използвате квадратни скоби, които са Обикновено точно над вашия Return или Enter клавиш от клавиатурата. И тогава ще ви постави на индекса на характер, които искате да отпечатате. Така че индексът ще бъде number-- 0, или 1, или 2, или 3, или точка, точка, DOT, някакъв друг номер. 

И ние се гарантира, че това ще е правилният номер, защото аз започне броенето при 0. И по подразбиране, първият знак в низ по условие е 0. И вторият символ е скоба 1. И третият знак е скоба 2. А вие не искате да отидете твърде до момента, но ние ще не защото ние сме Ще увеличим аз само докато го е равна на дължината на низа. И в този момент, това за цикъл ще спре. 

Така че нека да вървим напред и да спаси това програма, и тичам да низ 0. Но аз прецаках. Безусловно обявяване библиотека функция Стърлинг с тип като и such-- сега, това звучи познато. Но това не е ФОРМАТ. И това не е получите низ. 

Аз не се притеснявам в по същия начин, този път. Но забележете тук малко надолу допълнително, включва заглавна string.h, изрично предоставя на декларация за Стърлинг. Така че там всъщност е улика в там. 

И наистина се оказва, има и друг файл заглавието че ние не сме използвали в клас все още, но това е измежду наличните за вас, наречен string.h. И в този файл, string.h е Stirling обявена. Така че нека да вървим напред и да освен това, да низ 0-- хубаво, няма съобщения за грешки и този път. 

./string0 Zamyla, и Аз съм на път да удари Enter, в който момент getstring се случва да се върне низа, слага се в с. След това в продължение на линия ще обхождане над знака S е един по един, и да ги отпечатате по един на ред, защото Имах че наклонена черта н в края. Така че може да се пропусне, че наклонена черта п, и след това просто да отпечатате Zamyla всички в една и съща линия, ефективно reimplementing ФОРМАТ, което не е всичко, което полезно. Но в този случай, аз не съм направил това. Аз всъщност отпечатан един характер в даден момент, по един на ред, така че да можем действително да видите ефекта. 

Но трябва да се отбележи едно нещо тук. И ние ще се върнем към това в бъдеще седмица. Оказва се, че този код е потенциално бъги. 

Оказва се, че GET низ и някои други функции в живота Не е задължително винаги се върне това, което очаквах. Знаем от клас последно време в това, че се низ е трябвало да се върне низ. Но какво, ако видовете потребителски такива Дълго дума, или параграф, или есе че там просто не е достатъчно памет в компютъра, за да се побере. 

Подобно на това, което, ако нещо се погрешно под капака? Тя може и да не се случва често, но това може да се случи веднъж от време на време, много рядко. И така се оказва, че GET низ и функции като това не е задължително винаги се върне струни. Те биха могли да се върнат някои стойност на грешката, някои страж стойност така да се каже, които показват, че нещо не е наред. И вие ще знаете само това от които са го научили в клас сега, или след като прочетох някои повече документация. Оказва се, че GET низ може да върне стойност, наречена нулев. Null е специална стойност, която ние ще да се върне в бъдещ седмица. Но за сега, просто знам, че ако искам да бъде наистина правилно в движение напред използване GET низ, I Не трябва просто да го наричаме, и сляпо използва неговото връщане стойност, доверявайки се, че това е един низ. 

Аз трябва първо да кажа, Ей, чакай малко, само процедира, ако и не е равно нищожна, където нула, отново, е просто някаква особена стойност. И това е единственият специален стойността, която нужда да се притеснявате за за GET низ. Вземете низ е или ще да се върне низ или нула. 

И този удивителен знак знак за равенство може би знаете от може би клас по математика че може да се направи знак за равенство с линия през него за да покаже, не е равно. Това не е обикновено символ можете да въведете на клавиатурата. И така, в повечето езици за програмиране, когато искате да се каже, не е равна, използвате удивителен знак, иначе известни като взрив. Значи вие казвате взрив е равен, което означава не е равно, логично. Това е точно като там не е по-голям от, или равна на или по-малко от или равен на клавиатурата си че прави всичко това в един символ. Така че това е защо, в последните примери, нали отворена скоба, и след това знак за равенство, за да се направи по-голяма от или, да речем, по-малко от. 

Така че това, което е храна за вкъщи тук? Това е просто начин сега на въвеждане на този синтаксис, тази функция, итерации върху индивидуалното знаци в низ. И точно като тези, квадратна скоби позволяват да се получи при тях, разгледа тези квадратни скоби като вид натъртва на този базов дизайн, при който всеки характер вътре в низ е вид опаковка в някъде отдолу качулката в паметта на компютъра ви. 

Но нека да направим един вариант на това. Оказва се, че този програма е правилна. Така че на оси CS50 за оценяване код, това е вярно сега. Особено сега, че аз съм проверка за нула, тази програма не трябва никога да се срине. И аз просто знам, че от опит. Но няма нищо друго, което ние наистина може да се обърка тук. Но това не е много добре проектирана, защото нека се върнем към основите. 

Първо, principles-- какво прави за контур направя? А за контур прави три неща. Той инициализира някои стойност, ако го помоля да. Тя проверява състояние. И след това, след всеки итерация, след всеки цикъл, да увеличи стойноста на някои стойност, или ценности, тук. 

И така, какво означава това? Ние се инициализира аз до 0. Ние проверяваме и се уверете, че аз е по-малко от дължината на S, което е Z-A-М-Y-L-A, така, което е по-малко от 6. И наистина, 0 като по-малко от 6. 

Ние разпечатате Z от името Zamyla му. След това ние увеличаваме и 0-1. Ние след това се провери, е 1 по-малко от дължината на S? Дължината на S е 6. Да, така е. 

Така че ние отпечата в името Zamyla е, ZA. Ние нарастване и от 0, 1, 2. Ние след това се провери, е 2 по-малко от дължината на името Zamyla му. 6- така 2 е по-малко от 6. Да, нека да разпечатате сега M в име Zamyla му, третият знак. 

Ключът тук е, че на всяка повторение на историята, аз съм проверка, е аз по-малко от дължината на Zamyla? Но уловката е, че Стърлинг не е собственост. Тези от вас, които са програмирани преди в Java или други езици може да знае дължината на низ е имот, само някои само за четене стойност. 

В С В този случай, ако това е функция, която е буквално преброяване на броя на символи в Zamyla всеки път ние наричаме тази функция. Всеки път, когато поиска от компютъра, за да използвате Стърлинг, това е като погледнете Zamyla, и каза: Z-A-M-Y-L-A, 6. И тя се връща 6. Следващият път, когато се обадя то вътре, че за контур, това ще разгледаме Zamyla отново, казват Z-A-М-Y-L-A, 6. И това се случва, за да се върне 6. Така че това, което е глупаво за този проект? 

Защо е моя код не на 5 от 5 за проектиране точно сега, така да се каже? Е, аз питам въпрос ненужно. Правя повече работа, отколкото имам нужда да. 

Така че, въпреки че отговор е правилен, аз съм иска компютъра, това, което е дължината на Zamyla отново, и отново и отново и отново? И този отговор е никога няма да се промени. Тя винаги ще бъде 6. 

Така че по-добро решение от това би било това следващата версия. Нека да вървим напред и да го постави в отделен файл, наречен string1.c, просто за да го разделят. И се оказва, в за контур, всъщност можете да Декларирам, множество променливи наведнъж. 

Така че аз ще държа аз и тя трябва да е 0. Но аз също отивам да добавите запетая, и да кажа, дайте ми една променлива, наречена N, чиято стойност е равна на дължината низ от с. И сега, моля, направете състоянието ми толкова дълго, колкото мога по-малко от п. 

Така по този начин, логиката е идентичен в края на деня. Но аз съм си спомни стойност 6, в този случай. Каква е продължителността на име Zamyla е? И аз съм го поставя в п. 

И аз съм все още проверка състоянието всеки път. Е 0 по-малко от 6? Е 1 по-малко от 6? Е 2 по-малко от 6, и така нататък? 

Но аз не съм иска компютъра отново, и отново, това, което е дължината на името Zamyla е? Каква е продължителността на име Zamyla е? Каква е дължината на името на този Zamyla е? Аз буквално се забравя, че първата и отговоря само в тази втора променлива п. Така че това вече ще бъде не само правилно, но и добре проектирана. 

Сега, какво да кажем за стил? Аз съм кръстен моите променливи доста добре, бих казал. Те са супер стегнато точно сега. И това е напълно наред. 

Ако имате само един низ в една програма, може би, както го наричат ​​е за низ. Ако имате само една променлива за броене в програма, че може и да го наричаме аз. Ако имате дължина, п е супер общ, както добре. Но аз не съм коментира някой от моя код. 

Аз не съм информиран за reader-- дали това е моят TF, или TA, или просто colleague-- това, което се предполага, че да се случва в тази програма. И така, за да се получи добър стил, това, което аз ще искам да направя е this-- нещо като питам потребител за вход. И аз може да се пренапише това всяка редица начини. 

Уверете се, че s-- направи сигурни, GET низ се връща низ. И тогава в here-- и това е може би най-важният comment-- обхождане над героите в и един по един. И аз може да използва всеки избор на английски език тук, за да опише всеки на тези парчета код. 

Забележете, че не съм се сложи коментирам всеки ред код, наистина само по-интересните такива, тези, които има някакъв смисъл, че бих могъл искаме да направим супер ясно на някой четене моя код. И защо се обаждаш получите низ попитам потребител за вход? Дори, че човек не е задължително всичко, което описателно. Но тя помага разкажа една история, понеже втора линия в историята е, уверете се, получите низ се връща низ. 

И на третия ред в историята е, обхождане на героите в а един на време. И сега просто за добра мярка, Отивам да вървим напред и да добавите още един коментар, който току-що казва печат-тото характер в с. Сега, това, което съм направил в края на деня? 

Имам добавят някои английски думи под формата на коментари. Символът на наклонена черта черта означава, хей, компютър, това е за човека, не за вас, на компютъра. Така че те са игнорирани логично. Те са просто там. 

И наистина, CS50 IDE ги показва като сиво, като полезни, но не основен на програмата. Забележете, това, което сега можете да направите. Дали знаете C програмиране или не, вие може просто да стоя назад в тази програма, и обезмаслено коментарите. Попитайте потребител за вход, се уверете, получите низ се връща низ, обхождане на героите в S един по един, отпечатване на характера -тото характер в s-- не го направите дори трябва да погледнете кода да се разбере това, което прави тази програма. И, още по-добре, ако се погледне по тази програма в една или две седмици, или един месец, или една година, вие също не разполагат с да се взират в кода, опитвайки се да си спомня, какво е аз се опитвам да направя с този код? 

Ти сам каза. Ти го описва за себе си, или някои колега, или TA, или TF. И така, това вече би било правилно, и добър дизайн, и в крайна сметка добър стил, както добре. Така правят имайте това предвид. 

Така че има един друг нещо, което аз ще направя тук че сега може да разкрие какво точно е става под предния капак. Така че има тази функция в C, и други езици, наречен освободи от стереотипа че или косвено или изрично ви позволява да конвертирате от един тип данни към друга. Ние сме били, занимаващи така Доколкото днес с низове. 

И струни са герои. Но припомни от седмица 0, какви са героите? Знаците са само една абстракция на върха на numbers-- десетични числа, и десетични числа са наистина само един абстракция на върха на двоични числа, тъй като ние я определя. 

Така че герои са числа. И номера са герои, само в зависимост от контекста. И се оказва, че вътре на компютърна програма, може ли да посочите как искате да изглежда в битовете на тази програма? 

Спомнете си от седмица 0, че имахме Ascii, който е само този код картографиране писма до номера. И ние казахме, капитали А е 65. Capital B е 66, и така нататък. 

И известие, ние по същество има символа на най-горния ред тук, тъй като C ще им се обадя, символи, и след това цели числа на втория ред. И се оказва, можете да конвертирате безпроблемно между двете, обикновено. И ако искаме да направим това нарочно, ние Може би искате да се справи нещо като това. 

Ние може да искате да конвертирате горния случай да се намали случай, или малки букви в главни букви. И се оказва, че има всъщност един модел тук ние можем да прегърнем в един момент. Но нека да погледнем първо на по- Пример за това прави изрично. 

Отивам да се върне обратно в CS50 IDE. Отивам да се създаде файл, наречен Ascii 0.c. И аз ще отида напред и да добавите ми стандарт io.h в горната част, INT главната нищожно в горната част на моята функция. И тогава аз съм просто ще да направи following-- а за линия от I е равен, да речем, 65. 

И тогава аз ще бъде по-малко от 65, плюс 26 букви в азбуката. Така че аз ще позволи на компютъра направи по математика за мен там. И след това вътре в този цикъл, това, което съм аз ще отпечата? 

% В е и обратно наклонена черта н%. И сега искам да се включите в две стойности. Аз бях временно постави въпрос бележи там, за да покани на въпроса. 

Искам да обхождане от 65 нататък в продължение на 26 букви от азбуката, отпечатване на всяка итерация, че неразделна еквивалентен характер. С други думи, искам да обхождане над 26 номера печат какъв е характера Ascii, писмото, и какво is-- съответния номер наистина само пресъздаване графиката от този слайд. Така че това, което трябва да бъдат тези въпросителни знаци? 

Е, оказва се, че вторият човек трябва просто да бъде променлива аз. Искам да видя, че като брой. И средният аргумента тук, мога да кажа на компютъра за лечение на това число аз като характер, така че да го замени тук за процента В. 

С други думи, ако Аз, човешкото програмист, знам това са само цифри в края на деня. И знам, че 65 трябва Карта за някои характер. С това изрично гласове, с скоби, Името на вида на данните, които искате да трансформирате, и затворена скоба, Можете да кажете на компютър, хей, компютър, превръщане на тази число на Чар. 

Така че, когато аз тичам този програма след съставянето, нека да видим какво мога get-- направи Ascii 0. Проклета го, какво съм направил погрешно тук? Използването на недекларирания идентификатор, Всичко е наред, не умишлено, но нека да видим дали не можем причина през тази. 

Така линия five-- така че аз не се получи много далеч преди да се издъних. Това е добре. Така линия 5 за аз се равнява 65-- виждам. Така че не забравяйте, че в C, за разлика от някои езици, ако имат предварително програмиране опит, че имате да каже на компютъра, за разлика от нулата, това, което тип променлива е то. 

И аз забравих ключова фраза тук. В съответствие пет, аз започнах да използвам аз. Но аз не съм казал C какви данни тип е тя. Така че аз ще отида в тук и се каже, ах, да я направи цяло число. 

Сега аз ще отида напред и да прекомпилирате. Това фиксира това. ./ascii0 Enter, че е нещо готино. Не само, че е супер бързо, за да поиска от компютъра на този въпрос, вместо да го погледна върху предметно стъкло, той отпечатва по един на ред, А е 65, B е 66, по целия път down-- откакто Направихме това 26 times-- на писма Z, което е 90. И в действителност, леко по интелигентен би са били за мен да не се разчита на компютъра, за да добавите 26. Аз може просто да се направи 90, както и, доколкото както аз не направи същата грешка два пъти. Искам да отида през Z, а не само нагоре през ш. 

Така че това е изрично гласове. Оказва се, че този дори не е необходимо. Нека да вървим напред и да преиграва това компилатор, и разясняване Ascii 0. Оказва се, че C е доста умен. 

И ФОРМАТ, по-специално, е доста умен. Ако просто преминат аз два пъти за двете контейнери, ФОРМАТ ще осъзнае, ох, добре те познавам ми даде една integer-- някои номер, като 65, или 90, или нещо такова. Но виждам, че ти искаш да форматирате този номер като герой. И така ФОРМАТ може имплицитно хвърли на INT към Чар за вас, както и. Така че това не е проблем на всички. 

Но забележете, защото на тази еквивалентност ние всъщност може да направите това, както добре. Нека да вървим напред и да се направи една друга версия на this-- Ascii 1.c. И вместо повтаряне над числа, наистина могат да ви оставят без дъх от итерации върху символа. Ако Чар в получава капитал A, I искаме да вървим напред и да направи това, доколкото С е по-малко от или равно до капитал Z. И на всяка итерация Искам да увеличите C, което мога Сега в моя ФОРМАТ линия тук да речем, на сто C е процента аз отново, запетая C. 

И сега, мога да отида другата посока, леене характера изрично на цяло число. Така че, отново, защо го направи това? Това е малко странно да се справи с брои по отношение на героите. 

Но ако сте разбрали това, което е става под капака на двигателя, там наистина няма магия. Ти си просто казвам, хей, компютър даде ме променлива, наречена C от типа Чар. тя се инициализира с капитал А. И забележите единични кавички въпрос. 

За герои в C, припомнят от миналата седмица, вие използвате единични кавички. За низове, думи, фрази, които използвате двойни кавички. ОК, компютър, продължаваш да правиш това, така че Докато характер е по-малко от или равна на Z. И аз знам от моя Ascii маса, че всички на тези ASCII кодове са съседни. 

Има без пропуски. Така че това е просто чрез Z, разделени от един номер на всеки. И тогава мога да увеличите пепел, ако наистина искате. В края на деня, това е просто едно число. Знам това. Така че аз може просто да се предположи, за да добавите 1 към него. 

И след това време, аз отпечата в, и след това неразделна еквивалент. А аз дори не е необходимо изричното гласове. Аз да оставите ФОРМАТ и компютър оправя нещата, така че сега, ако аз тичам направи Ascii1./ascii1, Получавам точно същото нещо, както добре. 

Безполезни програма, though-- никой ще всъщност пишат софтуер за да разбера, какво е било номер, който съпоставя с A, или B, или Z? Вие просто ще го в Google, или го гледам онлайн, или го гледам върху предметно стъкло, или други подобни. Така че, когато се оказа получите полезна? 

Е, като стана дума за това слайд, забележите, че има действителен модел тук между главни и с малки букви, че не е случайно. Забележете, че капитал А е 65. Малки букви а е 97. И колко далеч е по-ниска случай? 

Така че 65 е колко крачки от 97? Така 97 минус 65 е 32. Така капитал на е 65. Ако добавите 32 до това, можете да получите малки букви а. И, което е същото, ако извадим 32, можете да се върнем към капитала A-- същото с B за малко б, голям C до малко в. 

Всички тези пропуски са 32 парчета. Сега, това би било да ни позволи да направя нещо като Microsoft Word, или Google Docs разполагат, където можете може да изберете всичко и след това казват, промени всичко в малки букви, или промени всичко в главни букви, или променят само първата дума на присъда до горния случай. всъщност можем да направим нещо като че самите себе си. 

Нека да вървим напред и да запишете файл тук се нарича възползва 0.c. И да вървим напред и да привличам програма че прави точно това, както следва. Така че да включва CS50 библиотеката. И включва стандартен I / O. 

И знам, че това е скоро. Така че аз ще го постави в там вече, string.h, така че да има достъп до неща като Стърлинг, и след това INT главната нищожно, както обикновено. И тогава аз ще отида напред и направи струни получава получите низ, само за да получите низ от страна на потребителя. И тогава аз ще направя моя чек здрав разум. Ако низ не прави равен нула, след това, че е безопасно да се процедира. И това, което искам да направя? Отивам да обхождане от I е равна на 0, и п до дължината низ от с. 

И аз ще направя това толкова дълго, колкото е аз е по-малко от п, и аз плюс плюс. Досега аз съм наистина само назаем идеи от преди. И сега аз отивам да се въведе клон. 

Така че мисля, обратно към нулата, където имахме тези вилици в пътя, и миналата седмица в C. Отивам да Казвам това, ако аз-ти характер в S е по-голяма от или равно на по-ниски случай, and-- в Scratch бихте буквално се каже и, но в C, което казвате амперсанд, ampersand-- и аз-ти характер в S е по-малко от или равно на малки букви Z, нека да направим нещо интересно. Нека всъщност отпечатате характер, без нов ред това е знак в низа, -тото характер в низа. 

Но нека да вървим напред и да изважда 32 от него. Иначе, ако героя в низ, че ние не търсим не е между малко по- и малко по-Z, давай и просто да го отпечата непроменен. Така че ние въведохме този скоби нотация за нашите струни, за да получите най- -тото характер в низа. 

Добавих някои условно логика, като Scratch в последната седмица на седмица един, където Аз съм само с помощта на моя фундаментален разбиране на това, което е става под предния капак. Е-тото характер на S по-голяма от или равна на? Подобно, е, че 97 или 98, или 99, и така нататък? 

Но също така е по-малко от или равно към стойността на малки букви Z? И ако е така, какво прави този ред означава? 14, това е нещо като кълнове на цялата идея, капитализира писмото от просто изваждане 32 от него, в този случай, защото знам, на които диаграма, как са представени номера ми. Така че нека да вървим напред и да стартирате тази, след съставянето възползва 0.c, и тичам възползва 0. 

Нека напишете нещо подобно Zamyla във всички малки букви влиза. И сега имаме Zamyla във всички главни букви. Нека да въведете Роб във всички малки букви. Нека се опитаме Jason във всички малки букви. И ние продължаваме получаване на принудени капитализация. Има малка грешка, която аз вид не очаквахме. Забележете новия ми бързо се завършва на същата линия като имената им, който се чувства малко разхвърлян. 

Така че аз ще отида тук, и всъщност в края на тази програма разпечатате символ за нов ред. Това е всичко. С ФОРМАТ, че не е нужно да премине в променливи или код формат. Вие буквално може просто да отпечатате нещо като нов ред. 

Така че нека да вървим напред и да се направи капитализира 0 отново, тя преиграва, Zamyla. И сега това е малко по-хубава. Сега, моето бързо е по своя нов ред. Така че всичко е наред и добра. Така че това е един добър пример. Но аз дори не е задължително Трябва да твърди код на 32. Знаеш ли какво? Мога да say-- аз не всякога помня каква е разликата. 

Но аз знам, че ако съм има малка буква, Аз по същество иска да се изважда от независимо от разстоянието е между малко а и голяма A, защото ако се предположи, че всички други букви са еднакви, че трябва да се свърши работата. Но вместо да направи това, знаеш ли какво? Има и друг начин, все още. 

Ако това е капитализира 1.c-- ако бях да сложи това в отделен файл. Нека да направим възползва 2.c както следва. Отивам да наистина се чисти тази тук. И вместо да дори да се налага да знае или се грижи за тези, ниско ниво детайли по изпълнението, аз съм вместо просто ще отпечатате характер, цитат цитата, процента C, и След това се обади и друга функция, която съществува, че приема аргумент, което е знак, като този. 

Оказва се, в C, има друга функция повикване до горния, които тъй като името му подсказва, отнема характер и го прави за неговата горна съдебна еквивалент, и след това се връща така че ФОРМАТ да го включите в там. И така, за да направите това, все пак, аз Трябва да се въведе един друг файл. Оказва се, има и друг файл че вие ​​ще знаете само от класа, или учебник, или онлайн препратка, наречен C type.h. 

Така че, ако мога да добавя, че до сред моята заглавна файлове, а сега отново се съберат тази програма, capitalize2, ./capitalize2 Enter. Нека да въведете в Zamyla във всички с малки букви, все още работи по същия начин. Но знаете ли какво? Оказва се, че до горната има някаква друга функция. 

И нека представим този командва тук, някак неловко име, но човек за употреба. Оказва се, че повечето Linux компютри, както ние използваме here-- Linux операционна system-- има команда нарича човек, който казва, хей, компютър, дай ми ръководство на компютъра. какво искаш да погледнете в това ръководство? 

Искам да гледам на функцията призовани да горен, Enter. И това е малко загадъчен да се чете понякога. Но забележете, че сме в наръчник Linux програмист. И всичко това е текст. И забележи, че там е най- името на функцията до тук. Оказва се, че има братовчед, наречен да се намали, което прави обратното. И предизвестие по конспект, за да използвате този функционира на страницата на човек, така да се каже, ми казва, че аз Трябва да включва в type.h. И знаех, че от практиката. 

Ето, това е ми показва двамата прототипи за функцията, така че ако някога искате да използвате тази Знам, че това, което те вземат като вход, и това, което те се връщат като продукция. И след това, ако чета описанието, виждам по-подробно, което прави функцията. Но по-важно, ако Гледам при завръщането стойност, тя казва, стойността връща че на преобразуваната писмото, или С, оригиналния входен, ако преобразуването не е било възможно. 

С други думи, за да горен ще се опита да я превърне в писмо до горния случай. И ако е така, то се случва да го върне. Но ако тя не може за някои reason-- може би това е вече горния случай, може би това е удивителен знак или някаква друга punctuation-- това е просто ще връщане на оригинала, C, което означава, че може да направи моя код по-добре проектирани, както следва. 

Аз не се нуждаят всички тези дяволски реда код. Всички линии аз съм просто подчерта може се срина в само една проста линия, която е this-- ФОРМАТ процента С до горната S скоба аз. И това ще бъде Пример за по-добър дизайн. 

Защо приложат в 7 или 8 линии на код, каквото и да е просто заличава, когато можете да вместо колапс всички от тази логика и вземане на решения в една единствена линия, 13 сега, че разчита на библиотека function-- функция, която идва с C, но това прави точно това, което искате да направите. И, честно казано, дори и ако тя не дойде с C, бихте могли да го въведе себе си, като сме виждали, с получите отрицателен инт и да получите положителен инт миналата седмица, както добре. 

Този код сега е много по-разбираемо. И наистина, ако ние превъртете нагоре, погледнете колко по-компактен тази версия на програмата ми е. Това е малко отгоре тежко сега, с всичко това включва. Но това е ОК, защото сега съм застанал върху раменете на програмисти преди мен. И който и да беше, които приложени към горния наистина ми направи услуга, подобно на този, който осъществява Stirling наистина ми направи услуга преди известно време. И така, сега имаме по-добър дизайн програма който реализира точно същата логика. 

Говорейки на Стърлинг, нека ми давай напред и да направим това. Нека да вървим напред и да спаси този файл като stirling.c. И се оказва, ние можем да се бели назад един друг слой доста просто сега. Отивам да се продължи напред и камшик до друга програма в главната тук, че просто се внедрява Дължина на низ, както следва. Така че тук е ред на код, който ми получава низ от страна на потребителя. Ние продължаваме да използвате това отново и отново. Позволете ми да се даде една променлива, наречена п от тип INT, че съхранява номер. 

И нека да вървим напред и да направя следната логика. Докато върши п-ия характер в S Не равно наклонена черта 0, давай и нарастване п. И после разпечата ФОРМАТ процента аз п. Аз твърдя, че тази програма тук, без да се поставя дължина низ, разбере, дължината на низ. 

И магията е изцяло капсулирани в линия 8 тук с това, което изглежда като нов синтаксис, тази наклонена черта 0 в единични кавички. Но защо е така? Е, помисли какво е било случва през цялото това време. 

И като се отмени преди да забравя, да разбере, също, че в допълнение към човека страници които идват с типичен Linux система като CS50 IDE, осъзнаят, че ние, персонала, разбира се, трябва също направи един сайт версия на същата тази идея, наречена reference.cs50.net, която има всички тези същите човека страници, Всички същата документация, както и малко поле в горната част, която позволява можете да конвертирате всички от сравнително Arcane език на по-малко удобни режим, където ние, преподавателите, са преминали през и се опита да се опрости някои от езика, за да пазят нещата фокусирано върху идеите, а не някои от техническите подробности. Така че имайте предвид, reference.cs50.net като друг ресурс, както добре. 

Но защо не работи дължина низ в Между другото аз предложих преди малко? Ето отново име Zamyla му. И тук е име Zamyla на в опаковка, както аз не правиш, да нарисува картина на това е, Наистина, просто поредица от символи. Но Zamyla не съществува в изолация в една програма. 

Когато пишете и стартирате програмата, който използвате вашия Mac или вашия компютър като памет, или RAM така да се каже. И вие може да се мисли за вашия компютър като имащи много гигабайта памет в наши дни. И концерт означава милиарди, така милиарди байтове. 

Но нека се върнем назад във времето. И предполагам, че ние сме с помощта на един много стар компютър, който има само 32 байта памет. Можех, на екрана на компютъра ми, просто направи това по следния начин. 

Мога да кажа само, че ми компютър има всичко това с памет. И това е като дърво на паметта, ако Ако си спомняте нашата картина от последния път. И ако аз просто се разделят това в достатъчно пъти, Аз твърдя, че имам 32 байта памет на екрана. 

Сега, в действителност, мога само да изготвят досега на този екран тук. Така че аз ще отида напред, и само по силата на споразумение, изготвят памет на моя компютър като решетка, а не само като една права линия. По-конкретно, аз твърдя, че сега тази мрежа, това 8 от 4 решетка, точно представлява всички 32 байта налична памет в моя Mac, или на разположение в моя компютър. И те опаковане по две линии, просто защото тя се вписва повече на екрана. Но това е първият байт. Това е втората байт. Това е третият байт. 

И това е 32-ия байт. Или, ако си мислим, като компютър учен, това е байт 0, 1, 2, 3, 31. Така че имате 0 до 31, ако да започнете да се брои при 0. 

Така че, ако ние използваме една програма че разговори се низ, и ние се низ от човека както направих аз, наречен Zamyla, Z-A-M-Y-L-A, как в света прави компютър Следете които байт, което парче от паметта, принадлежи към която низ? С други думи, ако ние се пристъпи към въведете друго име в компютъра, като този Andi, наричайки получите низ за втори път, A-N-D-I трябва да се свърши в памет на компютъра, както и. Но как? 

Е, оказва се, че под качулка, какво C върши когато съхраняване струни че човешките видове в, или че идват от някакъв друг източник, е, че очертава края на тях с специален character-- наклонена черта 0, което е само по специален начин да се каже, 80 бита в един ред. 

Така A-- това е изтеглянето номер 97. Така че някои модел на 8 бита представлява десетичната номер 97. Тази наклонена черта 0 е буквално на броя 0, познат още като Nul, N-U-L, за разлика от по-рано, N-U-L-L, който ние говорихме. Но за сега, просто знам, че този наклонена черта 0 е само на 80 бита в един ред. 

И това е само тази линия в пясък, който казва, че нищо в ляво принадлежи към една струна, или един вид данни. И нищо в дясно принадлежи към нещо друго. името Andi, междувременно, които просто визуално се случва да приключи към другата линия, но това е само естетически детайли, По същия начин се прекратява Nul. 

Тя е низ от един символи A-N-D-I, плюс една пета секретен характер, всички 0 бита, които просто определя границите В края на име Анди, както и. И ако ние наричаме получите низ за трети път в компютъра, за да получите низ като Maria, М-A-R-I-A, подобно е Мария име Nul прекратен с наклонена черта 0. 

Това е коренно различна от това как един компютър би типично съхранява цяло число, или с плаваща запетая, или друга типове данни все още, тъй като припомни, цяло число обикновено е 32 бита, или 4 байта, или може би дори 64 бита, или осем байта. Но много примитиви в компютър в един език за програмиране имат фиксиран брой байта под hood-- може би една, може би две, може би 4, може би 8. 

Но струни, с дизайн, имат динамичен брой символи. Вие не знаете предварително, докато видовете човека в Z-A-М-Y-L-A, или М-A-R-I-A или A-N-D-I. Вие не знаете колко пъти потребителят ще удари клавиатурата. Поради това, че не знаете как много герои в аванс започваш да се наложи. 

И така C просто вид на листа като тайна трохи под капака в края на низа. След съхраняване на Z-A-М-Y-L-A в паметта, тя също така просто поставя еквивалент на определен период. В края на изречението, го поставя 80 бита, така че да си спомня къде Zamyla започва и завършва. 

Така че това, което е връзката, След това, с тази програма? Тази програма тук, Стърлинг, е просто механизъм за получаване на низ от страна на потребителя, линия 6. Line 7, аз декларирам променлива нарича н и я определя като равна на 0. 

И тогава в линия 8, аз просто попитах въпрос, докато N-тия символ прави не е равно на всички 0 bits-- С други думи, не равна на тази специална характер, наклонена черта 0, което беше само, че специален Nul character-- давай напред и просто нарастване п. 

И да го прави и пази да го прави, и да го правиш. И така, въпреки че в миналото сме използвали аз, това е съвършено глоба семантично да използват п, ако сте просто се опитва да брои този път умишлено, и просто искате да го наричат ​​п. Така че това просто продължава да си зададе въпроса, е п-ия характер и само 0? Ако не, гледам към следващия вид, погледнем към следващия, гледаме към следващия, погледнем към следващия. 

Но веднага след като те видя наклонена черта 0, това loop-- линия 9 чрез 11-- спира. Можете да се измъкнат от време контур, оставяйки вътре на тази променлива п с общ брой на всички от символи в низа си видял, като по този начин да ги извежда. Така че нека се опитаме това. 

Нека да вървим напред и, без да се използване на функцията на Стърлинг, но само с помощта на собствената си доморасли версия тук се нарича Stirling, нека да вървим напред и серия Stirling, тип в нещо като Zamyla, което аз знам предварително е шест символа. Да видим дали ще работи. В действителност, това е шест. Нека се опитаме с Роб, три символа, три символа, както и, и така нататък. Така че това е всичко, което се случва за под предния капак. И забележи връзките, След това, с първата седмица на класа, когато говорихме за нещо като абстракция, което е само това наслояване на идеи, или сложност, на върха на основни принципи. Ето, ние сме нещо като гледам под капака на Стърлинг, така да се каже, за да разбера, как ще го бъде изпълнена? 

И бихме могли отново да го приложат себе си. Но ние никога отново ще за повторно прилагане на Стърлинг. Ние просто ще използвате Стърлинг, за да се получи в действителност някои дължина струни. 

Но няма магия под предния капак. Ако знаете, че отдолу качулката, низ е просто поредица от символи. И, че поредица от символи всички могат да бъдат адресирани числено с конзола 0, скоба 1, скоба 2, и вие знам, че в края на низ е специален символ, можете да разбера как да се направи почти всичко в едно програма, защото всичко се свежда до е четене и писане на паметта. Това означава, че се променя и търси в паметта, или движещи се неща около в паметта, печат неща на екрана, и така нататък. 

Така че нека сега използвам тази новооткрита разбиране на това, което струни всъщност са под предния капак, и Отлепете един друг слой че до този момент ние сме е взел предвид факта. По-специално, по всяко време въведохме една програма, сме имали този ред на код близо до върха обявяване главната. И зададохме INT главната невалидни. 

И тази празнина в скобите има казваме през цялото това време, че основният самата не взема никакви аргументи. Всеки вход, че основната е ще получите от потребителя трябва да дойде от някой друг механизъм, като GET INT, или да получите плувка, или да получите низ, или някаква друга функция. Но се оказва, че когато се напише програма, всъщност можете да укажете че тази програма предприеме входове от човека в командния самата линия. 

С други думи, въпреки че досега са били работи само ./hello здравей или други подобни програми, всички от други програми, които сме били използване, че ние самите не пиша, са като, изглежда, командния ред arguments-- неща като грим. Вие казвате нещо като изработка, и след това втора дума. Или трясък, което казвате звън, и след това втора дума, на името на файла. 

Или дори RM или CP, като може да се съм виждал или използва вече за да се отстрани или копиране на файлове. Всички тези, които вземат т.нар командния ред arguments-- допълнителни думи в терминален прозорец. Но до сега, ние себе си не са имали този лукс на приема принос от страна на потребителя, когато той или тя всъщност работи самата програма в командния ред. 

Но ние можем да направим това чрез повторно обявяване Основната движи напред, а не като имащи анулира в скоби, но тези два аргумента instead-- първото цяло число, и втората нещо ново, нещо, което ние ще наричаме масив, нещо подобно в дух за това, което видяхме в Scratch като списък, но масив от низове, тъй като ние скоро ще видите. Но нека видим това, като Така например, преди да сме разграничи точно какво означава това. 

Така че, ако аз отида в CS50 IDE тук, аз съм отишъл напред и обявен във файл, наречен argv0.c следния модел. И забележи единственото нещо, това е различно, доколкото е, че съм се променил нищожно да Int argc струнен argv отворена скоба, близо скоба. И забележи, за сега, има нищо вътре на тези скоби. 

Няма по брой. И няма аз, или N, или всяко друго писмо. Аз съм само с помощта на квадратни скоби за сега, по причини, ние ще дойдем обратно в един момент. 

И сега това, което аз ще направя, е това. Ако argc равнява равнява 2-- и припомни, че е равно на равни е оператор на равенство сравняване отляво и отдясно за равенство. Това не е заданието оператор, което е знак за равенство единствен, което означава, копие от дясно на ляво някаква стойност. 

Ако argc равнява е равно на 2, искам да да речем, ФОРМАТ, здравей, проценти, нов ред, и след това включете in-- и тук е новото trick-- argv скоба 1, по причини, че ще се върнем в един миг. Иначе ако argc не прави равно 2, знаете ли какво? Нека просто отидете напред и, както обикновено, печат от Здравей, свят, без смяна. 

Така изглежда, че ако argc, които щандове за броене аргумент, е равно на 2, Отивам да разпечатате здравей едно или друго нещо. В противен случай, по подразбиране, аз съм ще отпечата здравей свят. И така, какво означава това? 

Е, нека да вървим напред и да спаси този файл, и след това направете направи argv0, и след това ./argv0, Enter. И той казва здравей свят. Сега, защо е това? 

Е, оказва се, по всяко време стартирате програмата в командния ред, попълвате това, което ние ще обикновено наричаме аргумент вектор. С други думи, автоматично компютър, операционната система, ще предаде на вашата програма Самият списък на всички думи че човекът напечатани в ред, в случай, че програмист искате да направите, нещо с тази информация. И в този случай, единствената дума, Аз бях въведен в командния ред е ./argv0. 

И така броят на аргументи, че е да се прехвърлят към моята програма е само един. С други думи, аргументът брои, иначе известни като argc тук като цяло число, е само един. Един, разбира се, не го прави равен на две. И така, това е, което се отпечатва, здравей свят. 

Но нека да се възползвам от тази някъде. Позволете ми да кажа, argv0. И тогава какво ще кажеш за Мария? И след това се удари Enter. 

И забележи какво магически се случва тук. Сега, вместо здравей свят, имам до промяна в поведението на тази програма чрез вземане на входа не от GET низ или някаква друга функция, но от очевидно, моята команда себе си, това, което аз първоначално написан инча И мога да играя тази игра отново от тя се променя, за да Стелиос, например. 

И сега виждам друго име все още. И тук, мога да кажа, Анди. И мога да кажа Zamyla. И ние може да играе тази игра през целия ден, Просто включвате в различни стойности, толкова дълго, колкото аз се осигури точно две думи в командния ред, такава, че argc, моя аргумент брои, е 2. 

Да виждам, че името включен в ФОРМАТ, на това условие тук? Така че ние като че ли са сега експресивната способност на вземане вход от друг механизъм, от т.нар командния ред, вместо да се налага да чакат докато потребителят работи програмата, и след него подкани използвайки нещо като GET низ. 

И така, какво е това? Argc, отново, е просто число, броят на words-- arguments-- че потребителят е предвидено в бързо, по прозореца на терминала, включително името на програмата. Така че нашата ./argv0 е, ефективно, името на програмата, или как се стартира програмата. 

Това се смята за една дума. Така argc ще бъде 1. Но когато пиша Стелиос, или Andi, или Zamyla, или Мария, това означава, че броят на аргумент е две. И така, сега има две думи преминали инча 

И известие, че можем да продължим тази логика. Ако аз всъщност се каже, нещо като Zamyla Chan, пълно име, като по този начин, минаваща три аргумента общо, Сега той казва по подразбиране отново, защото, разбира се, 3 не прави равен 2. 

И така, по този начин, трябва да съм, достъп чрез argv този нов аргумент че бихме могли технически наричаме нещо, което искаме. Но по силата на споразумение, това е argv и argc, съответно. Argv, аргумент вектор, е вид на синоним за програмиране функция в C наречен масив. 

Масивът е даден списък на подобни ценности обратно, за да архивирате, за да архивирате, да върне. С други думи, ако един е точно тук, в RAM, следващата е в непосредствена близост до него, и в непосредствена близост до него. Те не са по цялото място. И последната сценарий, където нещата са по цялото място в паметта, всъщност може да бъде мощен функция. Но ние ще се върнем към това, когато ние говорим за красиви структури от данни. За сега, масив е просто парче от непрекъсната памет, всеки от чиито елементи са обратно, за да архивирате, за да архивирате, за да архивирате, и обикновено от същия тип. 

Така че, ако мислите, че за, от една преди момент, това, което е низ? Е, низ, като Zamyla, Z-A-M-Y-L-A, е, технически, само масив. Това е набор от символи. 

И така, ако ние наистина се направи това, тъй като съм направи по-рано, като парче памет, Оказва се, че всеки един от тях знаци заема един байт. И тогава там е, че специален Сентинел характер, наклонената черта 0, или всичките осем 0 бита, че разграничава края на тази струна. Така низ, се оказва, навън, цитирам цитата низ, е просто набор от chara-- Чар е действително тип данни. 

И сега argv, meanwhile-- нека се върнем към програмата. Argv, въпреки че ние виждаме думата низ тук, не е сам по себе си низ. Argv, аргумент вектор, е масив от низове. 

Така че, точно както можете да имате масив от символи, можете да имат по-високо ниво, масив от strings-- така, например, когато написах преди малко ./argv0 argv0, пространство Z-A-M-Y-L-A, I твърди, че argv имаше две струни в it-- ./argv0, и Z-A-М-Y-L-A. в С други думи, argc е 2. Защо така? 

Е, ефективно, което се случва на е, че всяка от тези струни е, разбира се, набор от символи Както и преди, всеки от чиито герои заема един байт. И не бъркайте действителната 0 в името на програмата на 0, което означава, че всички 80 бита. И Zamyla, междувременно, е все още и набор от символи. 

Така в края на деня, тя наистина изглежда по този начин под предния капак. Но argv, от природата на това как главната произведения, ми позволява да приключи всичко това нагоре в, ако щете, по-голяма масив че, ако ние малко над опрости това, което на снимката прилича и не доста го направи, за да мащабирате до там, този масив е само на размер 2, първият елемент от които съдържа низ, Вторият елемент на който съдържа низ. И, от своя страна, ако вид фокусирам върху всеки на тези струни, това, което виж под капака е, че всяка струна е просто набор от символи. 

Сега, точно както с низове, ние бяхме в състояние да получите достъп на I-ия знак в низ използване че квадратна скоба нотация. По същия начин, с масиви Като цяло, можем използвате квадратна скоба нотация, за да получите във всеки брой на низове в масив? Например, нека давай напред и да направим това. 

Нека да вървим напред и да се създаде argv1.c, което е малко по-различно този път. Вместо проверка за argc2, Отивам да вместо да направите това. За инт получавам 0, I е по-малко от argc, аз плюс плюс, и след това се отпечата вътре на това, процента ите, нов ред, и след това argv скоба аз. 

Така че, с други думи, аз не съм се занимават с отделните герои в момента. Argv, както се подразбира от тях празно квадратче скоби за правото на argv на име, означава argv е масив от низове. И argc е само едно цяло число. 

Тази линия тук, 6, е казвайки набор аз равна на 0. Преброяване по целия път до, но не включително, argc. И след това на всяка итерация, разпечатате низ. Какво низ? 

-тото низ в argv. Така че докато преди бях използване на квадратен скоба нотация, за да получите най-İth знак в низ, сега Аз съм с квадратна скоба нотация за да получите най-низа Ith в масив. Така че това е вид на един слой по-горе, концептуално. 

И така, какво е чист за това програма сега, ако аз съставят argv1, и след това направете ./argv1, и след това въведете в нещо като Foo бар Баз, които са трите стандартни такива думи, които компютърен учен достига за всяко време той или тя се нуждае от някои заместващи думи, и натиснете Enter, всяка от тези думи, включително името на програмата, която е в argv в първото място, озовава се отпечатва един по един. И ако мога да променя това, и аз да кажа нещо като argv1 Zamyla Chan, ние получаваме всички три от тези, думи, което е argv0, argv1, argv2, защото в този При argc, графът, е 3. 

Но това, което е чист е, ако се разбере че argv е просто масив от низове, и вие разбирате, че низ е масив от символи, ние можем действително вид използвате тази квадратна скоба за обозначаване на няколко пъти да изберете низ, и след това изберете характер в рамките на низ, гмуркане в по-дълбоко, както следва. В този пример, да ме пусне напред и да наричаме това argv2.c. И в този пример, нека да вървим напред и направете following-- за инт да получа 0, аз е по-малко от argc, аз плюс плюс, точно както преди. Така че в друг words-- и сега това получава достатъчно сложно. Тогава аз ще кажа, обхождане струни в argv, като коментар към себе си. И тогава аз ще имам вложени за линия, която най-вероятно са направили, или считат правене, в Scratch, където Отивам да кажа int-- съм не ще да се използва отново, защото аз не искам да се сянка, или сортиране на замени съществуващата аз. 

Отивам да, вместо да, казват й, защото това е моят Отидете на променлива, след като, когато Аз просто се опитвам да брои прости числа. За й получава 0-- и също, п, ще получите на кърмата дължината на argv скоба аз, доколкото й е по-малко от m, й плюс плюс, направете следното. И тук е интересната част. 

Разпечатайте характер и нова линия, включване в argv скоба аз, скоба й. ОК, така че нека да се добавят някои коментари тук. Преминаване през герои в текущия низ, печат й-ия характер в I-ия низ. Така че сега, нека да разгледаме какво означават тези коментари. 

Преминаване през струните в argv-- колко струни са в argv, който е масив? Argc много, така че аз съм итерации от I равнява 0 до argc. В същото време, колко символа са в I-ия низ в argv? 

Е, за да получите този отговор, Току-що се обади дължина низ на грижите на текущия низ I около, която е argv скоба аз. И аз отивам да се съхранява временно, че стойност в N, само за целите на кеширане, да го запомнят за ефективност. И тогава аз ще се инициализира й до 0, продължавай така дълго, колкото й е по-малък от N, и на всяко нарастване итерация й. 

И тогава в тук, за моя коментар по линия 12, разпечатате характер, последвано от нов ред, специално argv скоба аз ми дава-тото низ в argv-- така първата дума, за втората дума, третата дума, каквото. И след това й се гмурка в по-дълбок и получава ми на к-ия характер на тази дума. И така, в смисъл, вие може да лекува argv като многоизмерен, като двуизмерен, масив, при което всяка дума вид на външен вид като се има предвид това си око, и всеки герой е вид състои в колона, ако това помага. 

В действителност, когато ние дразни това освен в бъдещите седмици, това ще бъде малко по- по-сложни от това. Но наистина може да се мисля за това, за сега, като само тази двумерен масив, при която едно ниво на него е всичко, на струните. И след това, ако се потопите в дълбок, вие може да се получи при отделните герои в него с помощта на тази система за означаване тук. 

Така че това, което е нетният ефект? Нека да вървим напред и да направи argv2-- дяволски. Направих грешка тук. Безусловно обявяване на библиотека функция Стърлинг. Така че през цялото това време, това е може би е уместно че ние сме нещо като довършителни точно там, откъдето започнахме. 

Аз прецаках, неявно обявяване библиотека функция Стърлинг. ОК, чакай малко. Спомням си, че, особено тъй като това е точно тук. Имам нужда да се включат string.h в тази версия на програмата. 

Нека да вървим напред и да включва string.h, освен че, давай напред и прекомпилирате argv2. И сега, ето го, направи argv2, Enter. И макар че е малко загадъчен на пръв поглед, забележите, че, наистина, какво се отпечатва е точка argv2. 

Но ако напишете няколко думи след бързо, като argv2 Zamyla Chan, Въведете, също малко загадъчен на пръв поглед. Но ако ние превъртите обратно нагоре, ./argv2 Z-A-М-Y-L-A C-H-A-N. Така че ние сме повтори над всяка дума. И, от своя страна, сме повтори над всеки герой в рамките на една дума. 

Сега, след всичко това, осъзнае, че има една друга подробност сме били вид в пренебрегване на цялото това време. Ние просто дразни, освен това, входове основните може да бъде? Какво ще кажете за изход основната си? 

Всичко това време, ние сме били просто копиране и поставяне Думата INT пред основната, че може да се види онлайн, понякога неправилно в по-старите версии на C и компилатори, че те казват, нищожен, или нищо. Но, наистина, за версията на C, който използваме, C 11, или 2011 г., осъзнавам че тя трябва да бъде вътр. И това трябва да бъде или невалидни или argc и argv тук. 

Но защо INT главната? Какво е тя всъщност връщане? Е, оказва се, всичко това време, всеки път, когато съм писал програма Основната винаги се връщат нещо. Но това е било това тайно. 

Това нещо е INT, като линия 5 подсказва. Но това, което инт? Е, има тази конвенция в програмирането, при което, ако нищо не е объркало и всичко е добре, програми и функции обикновено return-- донякъде counterintuitively-- 0. 0 обикновено означава, че всичко е наред. Така че дори и да се мисли за то като фалшиво в много контексти, тя всъщност обикновено означава нещо добро 

Междувременно, ако програмата се връща 1, или отрицателна 1, или 5, или отрицателна 42, или който и да е не-0 стойност, че обикновено означава, че нещо не е наред. В действителност, на собствения си Mac или PC, може да сте виждали съобщение за грешка, което тя казва едно или друго нещо, грешка код отрицателен 42, или грешка код 23, или нещо подобно. Този брой е обикновено просто намек за програмист, или компанията че прави софтуера, какво се обърка и защо, така че те да могат да гледат през тяхната документация или код, и да разбера какво грешка всъщност означава. Това по принцип не е полезно за нас крайните потребители. 

Но когато основните връща 0, всичко е наред. И ако не укажете какво главната трябва да се върне, това ще стане само автоматично върнете 0 за вас. Но завръщането нещо друго е действително полезно. 

В този последен програма, нека давай напред и да наричаме това exit.c, и въвеждане на последната от днес теми, известни като код за грешка. Нека да вървим напред и да включва нашата познатите файлове до върха, правят INT главната. И този път, нека да направим INT argc, низ argv, и с моите скоби да се предполага, че това е в масива. И тогава нека просто направи проверка на здрав разум. Този път, ако argc не прави равно 2, тогава знаете ли какво? Забрави. Аз отивам да се каже, че, хей, ръководство, ви липсва аргумент на командния ред наклонена черта п. 

И след това е всичко. Искам да излезете. Аз отивам да изпреварващо, и преждевременно наистина, връщане нещо различно от номер 1. Отиди на стойност за първите грешка, която може да се случи е 1. Ако имате някаква друга погрешна ситуация, която може да се случи, може да се каже връщане 2 или връщане 3, или може би дори отрицателен 1 или отрицателна 2. 

Това са само изходните кодове които са, по принцип, само полезно за програмист, или на компания, която доставя софтуер. Но фактът, че това е Не 0 е това, което е важно. Така че, ако в тази програма, аз искам да гарантира, че тази програма само работи, ако потребителят ми дава с брой на аргумент на две, името на програмата, както и някои други дума, мога да наложат толкова, както следва, крещи на потребителя с ФОРМАТ поговорка, липсва аргумент на командния ред, върне 1. Това просто ще незабавно спиране на програмата. 

Само ако argc е равно на 2, ще получим надолу тук, в този момент аз отивам да се каже, здравей процента ите, наклонена черта п, argv1. С други думи, аз съм Не става след argv 0, който е само името на програмата. Искам да разпечатате здравей, запетая, втората дума, че човекът въвели. И в този случай на линия 13, всичко е наред. 

Аз знам, че argc е 2 логично от тази програма. Отивам да вървим напред и да се върне 0. Като настрана, имайте предвид, че това е вярно в Scratch, както добре. 

Логично е, че може да направи това и капсулиране на тези редове на код в този друг клауза тук. Но това е нещо като ненужно редовете на моя код. И аз искам да се направи супер ясно, че без значение какво, по подразбиране, здравей нещо ще се отпечатва, толкова дълго, колкото потребителят сътрудничи. 

Така че това е много често да се използва състояние, само ако, за улов на някои погрешни ситуация, а след това излизане. И след това, толкова дълго, всичко е добре, не разполага с друг, но просто трябва кода извън това, ако, защото това е еквивалент в тази конкретен случай, логично. Така че аз съм се върне 0, само за да изрично да означава всичко е добре. 

Ако се пропусне завръщането 0, би автоматично се приема за мен. Но сега, че аз съм връщане един от най-малко този случай, Отивам да, за добра мярка и яснота, върнете 0 в този случай. Така че сега нека да вървим напред и да излезете, който е перфектен Segue да напусне просто. 

Но да излезете, за да си отида напред и ./exit направя, Enter. И програмата извика към мен, липсва команден ред аргумент. ОК, нека да си сътрудничат. 

Позволете ми, вместо да се направи ./exit, Дейвид, Enter. И сега той казва, здравей Дейвид. И обикновено не би видите това. 

Но се оказва, че има специален начин в Linux действително да видим с какво излизане код програма излезе. Понякога в графичен свят като Mac OS или Windows, вие виждате само тези номера, когато един съобщение за грешка се появи на екрана и програмист ви показва, че редица. Но ако искаме да видим каква грешка съобщение е, можем да го направим here-- така ./exit, Enter, за печат липсва команден ред аргумент. 

Ако аз сега правя ехо $ ?, което е абсурдно загадъчен търсите. Но $? е магическо заклинание който казва, хей, компютър, кажи ми какво предишното код за изход програма беше. И аз се удари Enter. Виждам 1, защото това е, което аз каза моята основна функция да се върне. 

В същото време, ако го направя ./exit Дейвид, и натиснете Enter, виждам, здравей Дейвид. И ако сега правя ехо $ ?, виждам здравей 0. И така, това действително ще да бъде ценна информация в контекста на дебъгер, не толкова много, че вие, човекът, ще се грижи. Но дебъгер и другият програми ще използват този семестър често ще разгледаме този номер, Въпреки че това е нещо като скрит освен ако не го търсим, за да се определи дали дадена програма или не изпълнение е правилно или неправилно. 

И така, това ни води до това, в края на деня. Ние започнахме днес, като погледнете в отстраняване на грешки, и на свой ред в хода себе си, и след това по-интересно, технически под капака при какви струни са, което продължи седмица ние просто взех за даденост, и със сигурност ги взех за даденост в Scratch. 

След това погледна как можем да имаме достъп отделните символи в низ, и след това отново пое по-високо ниво гледам на нещата, гледайки как well-- ако искаме да получим по индивидуален елементи в списък като структура, Не можем да направим това с няколко струни? И ние можем да с аргументи на командния ред. Но тази снимка тук на само на кутии е демонстративен на тази обща идея на масив, или списък, или вектор. И в зависимост от контекст, всички тези думи означава малко по-различни неща. Така че в C, ние само ще да се говори за масив. И масив е парче памет, всеки от които е елементи са съседни, обратно, да архивирате, за да архивирате, да върне. 

И тези елементи са, обикновено, от същия тип данни, характер, характер, характер, характер, или низ, низ, низ, низ, или INT, INT, INT, каквото и да е ние се опитваме да магазин. Но в края на деня, това е как изглежда концептуално. Вие сте като вашия памет или RAM на компютъра. И ти го дерогиране в идентичен размер кутии, в които се завръщат, за да архивирате, да обратно, за да направите резервно по този начин. 

И това, което е хубаво за тази идея, както и факта, че можем да изразим стойности по този начин с първия от нашите структури от данни в класа, означава, че ние може да започне за решаване на проблеми с код че дойде толкова интуитивно в седмица 0. Ще припомним телефона книга например, където ние използвахме разделяй и владей, или двоично търсене алгоритъм, да се пресее през цяло куп имена и номера. Но ние приехме, изземване, че това телефонен указател е вече подредени, че някой друг вече е имал фигурни out-- даден списък с имена и numbers-- как да ги азбучен ред. И сега, че в C ние, също имат способността да се неща, не физически в телефонен указател но на практика в един компютър памет, ще бъдем в състояние следващата седмица да се въведе отново this-- първият на нашите структури от данни в една array-- но по-важно, действителната компютър научни алгоритми, изпълнявани в код, с който можем да се съхранява данни в структури като тази, и след това започнете да го манипулира, и действително да реши проблемите с него, и да се изгради в началото на това, в крайна сметка, програми в C, в Python, в JavaScript, заявки бази данни с SQL? 

И ние ще видим, че всички от тях различни идеи блокировка. Но за сега, припомни, че домейн, който представихме днес е това нещо тук, и света на криптографията. И сред следващите вие ​​сами проблемите ще реши е изкуството на криптографията, кодиране и де-кодиране информация и кодиране и дешифрирането на текст, и ако се приеме в крайна сметка че вие ​​вече знаете какво е под капака така че, когато видите или получавате подобно съобщение, можете себе си може да го разчете. Всичко това, както и по-следващия път. 

[Възпроизвеждане на видео] 

-Mover Току-що пристигна. Отивам да отида посещение си професор в колеж. Да. Здравейте. Ти си. Изчакайте! Дейвид. Аз просто се опитвам да разбера какво се е случило с теб. Моля, всичко може да се помогне. Вие бяхте си колеж съквартирант, не бяха ли? Ти беше там с него, когато той завърши проекта на CS50? 

[МУЗИКА] 

-Това Е CS50. 

Обичам това място. 

-Изяждам. Ние ще излязат от бизнеса. 

[END PLAYBACK] 