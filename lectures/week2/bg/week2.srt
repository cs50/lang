1
00:00:00,000 --> 00:00:02,970
>> [МУЗИКА]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> Дейвид Дж Малан: Добре.

4
00:00:15,700 --> 00:00:18,832
Това е и това CS50
е началото на седмица 2.

5
00:00:18,832 --> 00:00:21,040
И вие ще припомним, че през
През последните няколко седмици,

6
00:00:21,040 --> 00:00:24,490
ние сме били въвеждане на компютър
наука и, на свой ред, програмиране.

7
00:00:24,490 --> 00:00:27,640
>> И ние започнахме историята по пътя на
Scratch, че графичен език

8
00:00:27,640 --> 00:00:28,990
от Media Lab на Масачузетския технологичен институт.

9
00:00:28,990 --> 00:00:30,780
И тогава най-скоро,
миналата седмица, направихме ние

10
00:00:30,780 --> 00:00:34,450
въведе higher-- на
език-ниско ниво познат

11
00:00:34,450 --> 00:00:36,770
като C, нещо, което е чисто текстова.

12
00:00:36,770 --> 00:00:39,440
И наистина, за последен път сме
проучени в рамките на този контекст

13
00:00:39,440 --> 00:00:40,450
редица концепции.

14
00:00:40,450 --> 00:00:43,010
>> Това, изземване, е самото
първата програма ще погледна.

15
00:00:43,010 --> 00:00:45,710
И тази програма, просто,
отпечатва, "Здравей, свят".

16
00:00:45,710 --> 00:00:47,730
Но има толкова много
сякаш магия става.

17
00:00:47,730 --> 00:00:51,460
Има тази #include
с тези ъглови скоби.

18
00:00:51,460 --> 00:00:52,170
Има вътр.

19
00:00:52,170 --> 00:00:53,020
Има (недействителни).

20
00:00:53,020 --> 00:00:56,330
Има скоби, фигурни скоби,
точка и запетая, и много повече.

21
00:00:56,330 --> 00:00:58,480
>> И така, припомни, че
ние въведохме Scratch

22
00:00:58,480 --> 00:01:02,110
така че бихме могли, в идеалния случай, вижте минало
че синтаксис, неща, които наистина не е

23
00:01:02,110 --> 00:01:04,590
всичко, което интелектуално
Интересно, но в началото на деня

24
00:01:04,590 --> 00:01:07,700
е, абсолютно, малко сложно
да приключи ума си наоколо.

25
00:01:07,700 --> 00:01:10,860
И наистина, един от най-често срещаните
неща в началото на деня в един клас програмиране,

26
00:01:10,860 --> 00:01:13,443
особено за тези, които по-малко
удобно, е да се разочароват от

27
00:01:13,443 --> 00:01:17,460
и спънал от определена синтактична
грешки, да не говорим за логически грешки.

28
00:01:17,460 --> 00:01:19,800
И така сред нашите цели
днес, всъщност, ще

29
00:01:19,800 --> 00:01:23,280
да бъде да ви снабди с някои
решаване на проблеми техники за това как

30
00:01:23,280 --> 00:01:26,705
за по-добро решаване на проблемите си
под формата на отстраняване на грешки.

31
00:01:26,705 --> 00:01:29,330
И вие ще си припомним също, че
среда, ние въведохме

32
00:01:29,330 --> 00:01:31,780
последно време се нарича CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Това е уеб-базиран софтуер, който
ви позволява да програмирате в облака,

34
00:01:34,850 --> 00:01:38,450
така да се каже, като същевременно запазят всичките си
файлове заедно, тъй като ние отново ще се днес.

35
00:01:38,450 --> 00:01:41,480
И припомни, че ние
преразгледани тези теми тук,

36
00:01:41,480 --> 00:01:44,480
сред тях функции, както и примки, и
променливи и булеви изрази,

37
00:01:44,480 --> 00:01:45,110
и условия.

38
00:01:45,110 --> 00:01:49,190
И всъщност още няколко, които ние
преведено от света на Scratch

39
00:01:49,190 --> 00:01:50,800
в света на C.

40
00:01:50,800 --> 00:01:53,220
>> Но основната сграда
блокове, така да се каже,

41
00:01:53,220 --> 00:01:55,150
бяха наистина все още същото миналата седмица.

42
00:01:55,150 --> 00:01:57,900
В действителност, ние наистина просто имаше
различен пъзел парче, ако щете.

43
00:01:57,900 --> 00:02:00,300
Вместо това лилаво
запишете блок, ние вместо

44
00:02:00,300 --> 00:02:02,940
бе ФОРМАТ, което е
тази функция в C, че

45
00:02:02,940 --> 00:02:05,890
ви позволява да отпечатате нещо
и да го форматирате на екрана.

46
00:02:05,890 --> 00:02:07,950
Ние въведохме CS50
Библиотека, където можете

47
00:02:07,950 --> 00:02:11,420
имаме сега на свой get_char обезвреждане,
и get_int, и get_string,

48
00:02:11,420 --> 00:02:14,610
и няколко други функции,
добре, чрез които можете да получите вход

49
00:02:14,610 --> 00:02:16,260
от собствена клавиатура на потребителя.

50
00:02:16,260 --> 00:02:20,640
И ние също се погледнете на нещата
като these- булев, и Чар,

51
00:02:20,640 --> 00:02:22,490
и двойно, поплавък,
INT, long_long низ.

52
00:02:22,490 --> 00:02:25,170
А има и още други типове данни в C.

53
00:02:25,170 --> 00:02:28,560
>> С други думи, когато се декларират
променлива за съхраняване на някои стойност,

54
00:02:28,560 --> 00:02:32,600
или когато се изпълнява функция
който връща някаква стойност,

55
00:02:32,600 --> 00:02:35,290
можете да определите какво
тип на стойност, която е.

56
00:02:35,290 --> 00:02:37,310
Дали това е низ, като
последователност от символи?

57
00:02:37,310 --> 00:02:39,490
Дали това е номер, като цяло число?

58
00:02:39,490 --> 00:02:41,390
Дали това е плаваща запетая
стойност, или други подобни?

59
00:02:41,390 --> 00:02:46,180
Така че в C, за разлика от нулата, ние всъщност
започна да се уточни какъв вид данни

60
00:02:46,180 --> 00:02:48,330
ние се връщат или използване.

61
00:02:48,330 --> 00:02:51,910
>> Но, разбира се, ние също се блъсна в
някои основни граници на изчислителната техника.

62
00:02:51,910 --> 00:02:54,100
И по-специално,
този език C, изземване

63
00:02:54,100 --> 00:02:57,070
че ние разгледахме
число преливник, реалността

64
00:02:57,070 --> 00:03:00,460
че, ако имате само един
ограничен размер на паметта

65
00:03:00,460 --> 00:03:04,600
или, по-конкретно, краен брой
на бита, можете само да разчитаме толкова висока.

66
00:03:04,600 --> 00:03:08,460
И така, ние погледна този пример тук
при което брояч в самолет,,

67
00:03:08,460 --> 00:03:13,510
всъщност, ако работи достатъчно дълго, за да
прелее и да доведе до софтуер

68
00:03:13,510 --> 00:03:15,560
действителен физически потенциал грешка.

69
00:03:15,560 --> 00:03:18,600
>> Ние също погледна към плаващ
точка неточност, реалността

70
00:03:18,600 --> 00:03:22,280
че само с ограничен брой
на бита, независимо дали е на 32 или 64,

71
00:03:22,280 --> 00:03:27,330
можете да посочите само толкова много номера
след десетичната запетая, след което

72
00:03:27,330 --> 00:03:29,110
започне да се неточно.

73
00:03:29,110 --> 00:03:32,360
Така например, една трета в
свят тук, в нашия човешки свят,

74
00:03:32,360 --> 00:03:35,360
Знаем, че е просто един безкраен брой
от 3s след десетичната запетая.

75
00:03:35,360 --> 00:03:38,820
Но един компютър не може непременно
представлява безкраен брой числа

76
00:03:38,820 --> 00:03:42,590
ако само му позволи някои
ограничен обем информация.

77
00:03:42,590 --> 00:03:45,900
>> Така че не само, че ние ви снабди
с по-голяма мощност от гледна

78
00:03:45,900 --> 00:03:49,280
как можете да изразите себе си в
клавиатура от гледна точка на програмиране,

79
00:03:49,280 --> 00:03:51,430
Ние също така ограничава какво
всъщност можете да направите.

80
00:03:51,430 --> 00:03:55,790
И наистина, бъгове и грешки могат
възникнат от тези видове проблеми.

81
00:03:55,790 --> 00:03:59,900
И наистина, сред темите днес
ще бъдат теми като отстраняване на грешки

82
00:03:59,900 --> 00:04:03,699
и всъщност търсят под капака
как бяха въведени неща миналата седмица

83
00:04:03,699 --> 00:04:05,490
действително са приложени
така че да можете по-добре

84
00:04:05,490 --> 00:04:10,530
разбирам и двете възможности на и
ограниченията на език, като C.

85
00:04:10,530 --> 00:04:14,770
>> И в действителност, ние ще се лющи обратно слоевете
от най-простите на структурата на данните,

86
00:04:14,770 --> 00:04:17,756
нещо, наречено масив, който
Scratch случва да наречем "списък."

87
00:04:17,756 --> 00:04:19,589
Това е малко по-
различно в този контекст.

88
00:04:19,589 --> 00:04:23,340
И тогава ние ще се представим един от най-
първо на нашите домейни специфични проблеми

89
00:04:23,340 --> 00:04:26,790
в CS50, в света на
криптография, изкуството на кодиране

90
00:04:26,790 --> 00:04:29,650
или в шифриране на информация, така че
че можете да изпратите тайни послания

91
00:04:29,650 --> 00:04:34,520
и декодира тайни послания
между две лица, A и B.

92
00:04:34,520 --> 00:04:37,490
>> Така че, преди да сме преход
да, че нов свят,

93
00:04:37,490 --> 00:04:42,059
нека се опитаме да ви снабди с някои
техники, с които можете да се елиминират

94
00:04:42,059 --> 00:04:43,850
или намаляване на поне някои
на отчаянието

95
00:04:43,850 --> 00:04:46,630
че най-вероятно са се сблъсквали
над сам изминалата седмица.

96
00:04:46,630 --> 00:04:50,830
В действителност, пред вас се such-- някои от
Първите си проблеми в C. И шансовете са,

97
00:04:50,830 --> 00:04:54,010
ако сте като мен, за първи път
опитате да напишете програма,

98
00:04:54,010 --> 00:04:57,330
дори и ако мислите логически
програмата е доста проста,

99
00:04:57,330 --> 00:05:01,200
може много добре се удари в стената, и
компилаторът няма да си сътрудничат.

100
00:05:01,200 --> 00:05:03,940
Уверете или звън не се случва
действително да вършат работата си.

101
00:05:03,940 --> 00:05:05,450
>> И защо би могло да бъде това?

102
00:05:05,450 --> 00:05:07,950
Е, нека да погледнем,
може би, една проста програма.

103
00:05:07,950 --> 00:05:11,190
Отивам да вървим напред и да спаси това в
файл умишлено нарича buggy0.c,

104
00:05:11,190 --> 00:05:13,590
защото аз го знам, за да
бъде опорочен предварително.

105
00:05:13,590 --> 00:05:17,400
Но аз може да не осъзнават, че ако тази
е първата или втората или третата програма

106
00:05:17,400 --> 00:05:18,830
че аз съм всъщност прави себе си.

107
00:05:18,830 --> 00:05:23,820
Така че аз ще отида напред и
напишете, INT главната (недействителни).

108
00:05:23,820 --> 00:05:28,130
И тогава вътре от моите големи скоби,
много запознат ( "Здравей, world--

109
00:05:28,130 --> 00:05:30,980
наклонена черта, п ") - и точка и запетая.

110
00:05:30,980 --> 00:05:32,360
>> Аз бях спасен файла.

111
00:05:32,360 --> 00:05:34,850
Сега аз ще сляза
до терминал моя прозорец

112
00:05:34,850 --> 00:05:40,340
и тип грим buggy0, защото, отново,
името на файла, днес е buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Така че аз въведете направи buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> И, о, Боже, припомнят от последния път
че няма съобщения за грешки е нещо добро.

115
00:05:48,200 --> 00:05:49,740
Така че без изход е нещо добро.

116
00:05:49,740 --> 00:05:52,920
Но тук имам ясно
някои брой грешки.

117
00:05:52,920 --> 00:05:56,470
>> Така че на първа линия на изхода
след въвеждане направи buggy0, изземване,

118
00:05:56,470 --> 00:05:59,540
е доста подробния изход звън е.

119
00:05:59,540 --> 00:06:02,067
Под предния капак,
CS50 IDE е конфигуриран

120
00:06:02,067 --> 00:06:04,150
да използват цял ​​куп
опции с този компилатор

121
00:06:04,150 --> 00:06:05,941
така че не е нужно
да се мисли за тях.

122
00:06:05,941 --> 00:06:08,840
И това е всичко, че на първа линия
средства, която започва с трясък.

123
00:06:08,840 --> 00:06:11,720
>> Но след това, проблемите,
започват да се правят външния им вид.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c на ред 3, характер
5, там е голям, червен грешка.

125
00:06:17,390 --> 00:06:18,380
Какво е това?

126
00:06:18,380 --> 00:06:23,562
Безусловно обявяване библиотека функция
ФОРМАТ с тип INT (Конст Чар *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Искам да кажа, че е много бързо
става много мистериозен.

129
00:06:28,379 --> 00:06:30,170
И разбира се, на първо
поглед, ние не бихме

130
00:06:30,170 --> 00:06:32,380
Очаквам да се разбере
цялост на това съобщение.

131
00:06:32,380 --> 00:06:34,213
И така, един от уроците
за днес ще

132
00:06:34,213 --> 00:06:36,919
да бъде да се опита да се забележи
модели или подобни неща,

133
00:06:36,919 --> 00:06:38,960
за грешки може да се наложи
срещани в миналото.

134
00:06:38,960 --> 00:06:41,335
Така че нека да дразни с изключение само
тези думи, които изглеждат познати.

135
00:06:41,335 --> 00:06:44,290
Големият, червено Грешката е ясно
символ на нещо е погрешно.

136
00:06:44,290 --> 00:06:47,940
>> Безусловно обявяване
библиотека функция ФОРМАТ.

137
00:06:47,940 --> 00:06:51,680
Така че дори и да не ми е ясно какво
неявно обявяване библиотека функция

138
00:06:51,680 --> 00:06:54,900
средства, проблемът със сигурност
се отнася до ФОРМАТ някак.

139
00:06:54,900 --> 00:06:59,130
А източникът на този въпрос
има нещо общо с него се обявява.

140
00:06:59,130 --> 00:07:02,440
>> Деклариране на функция е
тя се споменава за първи път.

141
00:07:02,440 --> 00:07:06,210
И ние използвахме терминологията миналата седмица
на обявяване на функционални прототипи,

142
00:07:06,210 --> 00:07:11,860
или с една линия в горната част на вашия
собствен файл или в така наречената заглавния файл.

143
00:07:11,860 --> 00:07:15,300
И в какво файл направихме ние казваме
миналата седмица, че ФОРМАТ е цитат,

144
00:07:15,300 --> 00:07:17,080
край на цитата, обявена?

145
00:07:17,080 --> 00:07:20,950
В какво файл е негов прототип?

146
00:07:20,950 --> 00:07:24,640
>> Така че, ако си спомняте, първото нещо, което аз
напечатан, почти всяка програма миналата time--

147
00:07:24,640 --> 00:07:30,790
и случайно преди малко започна
писането myself-- е този един here--

148
00:07:30,790 --> 00:07:38,630
hash-- # включват <stio-- за
вход / output-- точка з И наистина,

149
00:07:38,630 --> 00:07:41,860
ако сега запазите този файл, аз ще съм
да вървим напред и да изчистите екрана ми,

150
00:07:41,860 --> 00:07:44,740
които можете да направите, като въведете
Ясно, или да задържите Control L,

151
00:07:44,740 --> 00:07:47,680
само за да изчистите терминален прозорец
само за да се премахнат някои елементарно.

152
00:07:47,680 --> 00:07:51,370
>> Отивам да се продължи напред и
ре-тип грим buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
И готово, аз все още се види, че
дълга команда от звън,

154
00:07:53,790 --> 00:07:55,470
но няма съобщение за грешка, този път.

155
00:07:55,470 --> 00:07:58,800
И наистина, ако аз ./buggy0 направя,
точно като за последен път,

156
00:07:58,800 --> 00:08:01,860
където точка означава това
директория, Слаш просто означава,

157
00:08:01,860 --> 00:08:05,040
тук идва и името на програмата и
че името на програмата е buggy0,

158
00:08:05,040 --> 00:08:07,340
Въведете, "Здравей, свят".

159
00:08:07,340 --> 00:08:09,440
>> Сега, как може да имате
придобит този разтвор

160
00:08:09,440 --> 00:08:12,017
без непременно
признаване на колкото се може повече думи

161
00:08:12,017 --> 00:08:14,350
както направих аз, разбира се, като
направил това за толкова много години?

162
00:08:14,350 --> 00:08:18,720
Е, да разбере, на първия проблем
набор, ще ви запозная с една команда

163
00:08:18,720 --> 00:08:21,175
че собствения персонал CS50 е
пише нарича help50.

164
00:08:21,175 --> 00:08:24,300
И наистина, C прави спецификация за
проблемът определен за това как да използвате тази.

165
00:08:24,300 --> 00:08:27,210
>> Но help50 същество
програма, която персонал CS50 е

166
00:08:27,210 --> 00:08:30,850
пише, че ви позволява да стартирате
команда или изпълнение на програма,

167
00:08:30,850 --> 00:08:36,169
и ако ти не разбираш неговата
изход, за да премине производството си, за да help50,

168
00:08:36,169 --> 00:08:38,890
при което софтуера
че персоналът на курса е написал

169
00:08:38,890 --> 00:08:42,429
Ще разгледаме изход на вашата програма
ред по ред, знак по знак.

170
00:08:42,429 --> 00:08:46,000
И ако ние, служителите, да признае
съобщение за грешка, че сте изпитват,

171
00:08:46,000 --> 00:08:50,580
ние ще се опитаме да ви провокират с някои
риторични въпроси, с някои съвети,

172
00:08:50,580 --> 00:08:54,890
много прилича на TF или CA или себе си
ще направи лично в офис часа.

173
00:08:54,890 --> 00:08:58,320
>> Така че изглежда да help50 ако не го направите
непременно признае проблем.

174
00:08:58,320 --> 00:09:00,790
Но не се разчита на него
твърде много като патерица.

175
00:09:00,790 --> 00:09:03,990
Разбира се опитаме да разберем неговата
изход и след това се поучим от него

176
00:09:03,990 --> 00:09:07,571
така че само веднъж или два пъти, което правите
някога тече help50 за конкретна грешка

177
00:09:07,571 --> 00:09:08,070
съобщение.

178
00:09:08,070 --> 00:09:10,660
След това, вие трябва да бъдете
по-добре оборудвана себе си

179
00:09:10,660 --> 00:09:13,180
за да разбера какво е в действителност.

180
00:09:13,180 --> 00:09:14,350
>> Нека да направим един друг тук.

181
00:09:14,350 --> 00:09:20,410
Нека да вървим напред, а в друг
файл ще наричаме това buggy1.c.

182
00:09:20,410 --> 00:09:23,110
И в този файл съм
Ще deliberately--

183
00:09:23,110 --> 00:09:26,330
но се правя, че не го правят
разбере какво грешка съм направил.

184
00:09:26,330 --> 00:09:31,420
>> Отивам да вървим напред и да направим this--
# включват, тъй като съм

185
00:09:31,420 --> 00:09:33,660
научих урока от преди малко.

186
00:09:33,660 --> 00:09:36,220
Int основни (свободен), както и преди.

187
00:09:36,220 --> 00:09:40,880
И тогава в тук Отивам
да се направи струнни ите - get_string.

188
00:09:40,880 --> 00:09:43,770
И припомнят от последния път, че
този път, хей, компютър,

189
00:09:43,770 --> 00:09:48,280
дайте ми една променлива, наричаме го е, и
направи вида на тази променлива низ

190
00:09:48,280 --> 00:09:50,150
така че може да се съхранява една или повече думи в него.

191
00:09:50,150 --> 00:09:52,191
>> И след това в дясната ръка
страна на знака за равенство

192
00:09:52,191 --> 00:09:54,980
се get_string, което е
функция в библиотеката CS50

193
00:09:54,980 --> 00:09:55,980
че прави точно това.

194
00:09:55,980 --> 00:09:59,740
Той получава функция и след това
ИТ ръце от дясно на ляво.

195
00:09:59,740 --> 00:10:02,670
Така че този знак за равенство не означава,
"Равнява", както бихме могли да мислим по математика.

196
00:10:02,670 --> 00:10:04,750
Това означава прехвърляне от дясно на ляво.

197
00:10:04,750 --> 00:10:09,640
Така че това означава, вземете низ от
потребителя и да го съхранява вътре в с.

198
00:10:09,640 --> 00:10:10,460
>> Сега нека да го използвате.

199
00:10:10,460 --> 00:10:13,820
Нека вървим напред сега и като втори
линия, нека да вървим напред и да кажа "здрасти" -

200
00:10:13,820 --> 00:10:19,330
не "свят", но "здравей,% s--
който е наш заместител, запетая и,

201
00:10:19,330 --> 00:10:22,030
което е нашата променлива,
и след това запетая.

202
00:10:22,030 --> 00:10:26,070
Така че, ако аз не се притеснявам твърде много
тук, това изглежда като правилния код.

203
00:10:26,070 --> 00:10:28,090
>> И инстинктите си сега трябва да я компилирате.

204
00:10:28,090 --> 00:10:30,400
Файлът се нарича buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Така че аз ще направя направи buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
И дяволски-то, ако не съществува
дори повече грешки, отколкото преди.

207
00:10:36,377 --> 00:10:38,210
Искам да кажа, има още
съобщения за грешка, че ще

208
00:10:38,210 --> 00:10:40,400
Изглежда, отколкото действителните линии в тази програма.

209
00:10:40,400 --> 00:10:42,730
>> Но Takeaway тук е,
дори ако сте претоварени

210
00:10:42,730 --> 00:10:45,040
с две или три, или
още четири съобщения за грешки,

211
00:10:45,040 --> 00:10:48,340
съсредоточи винаги на самия
Първата от тези съобщения.

212
00:10:48,340 --> 00:10:52,220
С поглед към най-много един,
превъртане назад, както е необходимо.

213
00:10:52,220 --> 00:10:53,930
Така че тук аз напечатани изработка buggy1.

214
00:10:53,930 --> 00:10:55,700
Ето, че изход звън, както се очаква.

215
00:10:55,700 --> 00:10:57,290
>> И тук е първият червен грешката.

216
00:10:57,290 --> 00:11:02,370
Използването на недекларирания идентификатор
низ, е имам предвид стандарт в?

217
00:11:02,370 --> 00:11:04,260
Така стандарт в е
всъщност нещо друго.

218
00:11:04,260 --> 00:11:06,240
Това се отнася за потребителя
клавиатура, по същество.

219
00:11:06,240 --> 00:11:08,080
>> Но това не е това, което имах предвид.

220
00:11:08,080 --> 00:11:11,770
Имах предвид, низ, и имах предвид get_string.

221
00:11:11,770 --> 00:11:16,200
Така че това, което е, че аз
Забравих да направя този път?

222
00:11:16,200 --> 00:11:20,230
Какво липсва това време?

223
00:11:20,230 --> 00:11:23,600
Имам си # включват,
така че да има достъп до ФОРМАТ.

224
00:11:23,600 --> 00:11:26,090
>> Но това, което мога да не трябва
достъп до просто все още?

225
00:11:26,090 --> 00:11:29,420
Е, точно като за последен път,
Трябва да се каже на компилатора

226
00:11:29,420 --> 00:11:31,691
Звън какво тези функции са.

227
00:11:31,691 --> 00:11:33,940
Get_string не идва
с C. И по-специално, тя

228
00:11:33,940 --> 00:11:38,160
не идва в
заглавния файл,.

229
00:11:38,160 --> 00:11:40,770
Той вместо да идва в
нещо персонала пише,

230
00:11:40,770 --> 00:11:44,176
който е различен файл
назове но ловко име.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Така че, просто като добави, че един ред
на code-- изземване от последния път

233
00:11:50,861 --> 00:11:53,610
че когато звън работи, то се случва
да погледнем код ми горе до долу,

234
00:11:53,610 --> 00:11:54,193
Отляво надясно.

235
00:11:54,193 --> 00:11:57,200
Това ще забележите,
О, вие искате.

236
00:11:57,200 --> 00:11:59,900
Нека да отидем и да откриете, че,
където и да е на сървъра,

237
00:11:59,900 --> 00:12:03,090
копирате и да го поставите, по същество,
в горната част на вашия собствен файл

238
00:12:03,090 --> 00:12:06,820
така че в този момент в историята,
линия 1, до края на програмата

239
00:12:06,820 --> 00:12:11,651
да, наистина, да се използва някоя от функциите
там, сред тях get_string.

240
00:12:11,651 --> 00:12:13,650
Така че аз отивам да се игнорира
останалата част от тези грешки,

241
00:12:13,650 --> 00:12:17,190
защото, наистина, подозирам, че само
първият действително има значение.

242
00:12:17,190 --> 00:12:20,780
И аз ще отида напред и разясняване,
след спестяване на файла ми направи buggy1.

243
00:12:20,780 --> 00:12:22,580
И готово, го е направил труд.

244
00:12:22,580 --> 00:12:29,200
И ако го направя ./buggy1 и напишете, за
Например, Zamyla, аз сега ще получите здравей,

245
00:12:29,200 --> 00:12:32,000
Zamyla, вместо здравей, свят.

246
00:12:32,000 --> 00:12:32,550
>> Добре.

247
00:12:32,550 --> 00:12:35,890
Така че на храна за вкъщи тук тогава да,
един, се опита да събере колкото се може

248
00:12:35,890 --> 00:12:39,140
от съобщенията за грешки, сами по себе си, търси
в някои от най-разпознаваемите думите.

249
00:12:39,140 --> 00:12:43,070
Пречи, че използвате help50 на
проблема определя спецификация.

250
00:12:43,070 --> 00:12:46,500
Но за блокиране, които също винаги гледам
в горната грешка само, най-малко

251
00:12:46,500 --> 00:12:50,051
първоначално, за да видите каква информация
тя може в действителност да се получи.

252
00:12:50,051 --> 00:12:52,300
Но се оказва, че има
още повече функционалност вградена

253
00:12:52,300 --> 00:12:55,030
в библиотеката CS50 да помогне
вие в началото на семестъра

254
00:12:55,030 --> 00:12:57,580
и в началото на програмния
разбера какво не е наред.

255
00:12:57,580 --> 00:12:59,840
Така че нека да направим още един пример тук.

256
00:12:59,840 --> 00:13:04,350
Отивам да наричаме това buggy2, които,
отново, ще бъде опорочено от

257
00:13:04,350 --> 00:13:05,650
на портата, по дизайн.

258
00:13:05,650 --> 00:13:09,980
>> И аз ще отида напред
и направи #include.

259
00:13:09,980 --> 00:13:12,580
И тогава аз ще направя INT главната (недействителни).

260
00:13:12,580 --> 00:13:14,840
И тогава аз ще направя за контур.

261
00:13:14,840 --> 00:13:16,690
За (INT I _ 0.

262
00:13:16,690 --> 00:13:18,750
I е по-малко от или равно на 10.

263
00:13:18,750 --> 00:13:24,260
аз ++, и след това в големи скоби, аз ще съм
да разпечатате само символ маркер диез тук

264
00:13:24,260 --> 00:13:25,920
и нова линия характер.

265
00:13:25,920 --> 00:13:29,220
>> Така че моето намерение с този
програма е доста просто

266
00:13:29,220 --> 00:13:33,150
да повторите 10 пъти
и за всяка итерация

267
00:13:33,150 --> 00:13:35,260
на които контур всеки път
чрез цикъл,

268
00:13:35,260 --> 00:13:37,660
разпечатате маркер диез,
маркер диез, маркер диез.

269
00:13:37,660 --> 00:13:40,480
Един на ред, защото аз
Трябва новата линия там.

270
00:13:40,480 --> 00:13:42,787
И припомни, че за
линия, на последния week--

271
00:13:42,787 --> 00:13:44,620
и ще получите повече
запознат с синтаксис

272
00:13:44,620 --> 00:13:47,170
като тя се използва с практика
преди long-- това ми дава

273
00:13:47,170 --> 00:13:49,740
променлива, наречена аз и го поставя на 0.

274
00:13:49,740 --> 00:13:52,650
>> Това увеличи стойноста аз на
всяка итерация от 1.

275
00:13:52,650 --> 00:13:54,940
Така че отива до 1 към 2 до 3.

276
00:13:54,940 --> 00:13:57,690
И след това състояние в
средната между точка и запетая

277
00:13:57,690 --> 00:14:03,010
получава проверява на всеки итерация да се направи
сигурен, че ние все още сме в обхват.

278
00:14:03,010 --> 00:14:06,830
Така че аз искам да повторите 10 пъти, така че аз
има нещо много интуитивно просто

279
00:14:06,830 --> 00:14:09,070
сложи 10 като горната ми граница там.

280
00:14:09,070 --> 00:14:14,310
>> И все пак, когато пускам това, след
създаване, то с грим buggy2--

281
00:14:14,310 --> 00:14:15,440
и тя се компилира OK.

282
00:14:15,440 --> 00:14:17,980
Така че аз не разполагат с
синтактична грешка този път.

283
00:14:17,980 --> 00:14:20,940
Нека вървим напред сега
и тичам buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
А сега превъртете нагоре.

285
00:14:22,620 --> 00:14:24,890
И нека да се увеличи
размера на прозореца.

286
00:14:24,890 --> 00:14:33,720
>> Аз като че ли 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Така че има 11 маркери диез, въпреки че
Аз ясно поставени 10 вътре в този цикъл.

288
00:14:38,891 --> 00:14:42,140
Сега, някои от които може да видите веднага
което грешката е така, защото, наистина, този

289
00:14:42,140 --> 00:14:43,720
Не е много трудно грешка да се направи.

290
00:14:43,720 --> 00:14:46,070
Но това е много често
направи много рано.

291
00:14:46,070 --> 00:14:49,820
>> Това, което искам да посоча, че,
е, как бих могъл да разбера това?

292
00:14:49,820 --> 00:14:52,300
Е, оказва се, че
на CS50 библиотека идва

293
00:14:52,300 --> 00:14:55,380
с не само get_string и get_int
и get_float и други функции.

294
00:14:55,380 --> 00:14:59,980
Той също идва със специална функция
наречен eprintf, или, ФОРМАТ грешка.

295
00:14:59,980 --> 00:15:03,270
И той съществува единствено, за да се направи
тя е малко по-лесно за вас

296
00:15:03,270 --> 00:15:06,310
когато отстранявате грешки в кода, за да просто
отпечата съобщение за грешка на екрана

297
00:15:06,310 --> 00:15:07,850
и знам от къде идва.

298
00:15:07,850 --> 00:15:11,000
>> Така например, едно нещо, което биха могли
направите тук с тази функция е this--

299
00:15:11,000 --> 00:15:20,230
eprintf, и тогава аз ще отида напред
и да кажа сега аз се% аз, наклонена черта, п.

300
00:15:20,230 --> 00:15:22,330
И аз ще се включи в стойността на аз.

301
00:15:22,330 --> 00:15:25,400
И до върха, защото това
е в библиотеката CS50,

302
00:15:25,400 --> 00:15:27,580
Отивам да се продължи напред
и включва

303
00:15:27,580 --> 00:15:29,169
така че да има достъп до тази функция.

304
00:15:29,169 --> 00:15:31,460
Но нека да разгледаме какво линия
9 е трябвало да се прави.

305
00:15:31,460 --> 00:15:32,670
Отивам да изтриете това в крайна сметка.

306
00:15:32,670 --> 00:15:34,670
Това няма нищо общо
с моята висша цел.

307
00:15:34,670 --> 00:15:39,090
Но eprintf, ФОРМАТ грешка, е просто означаваше
да ми даде някаква информация за диагностика.

308
00:15:39,090 --> 00:15:42,460
Когато стартирам програмата ми, искам да
виж това на екрана временно

309
00:15:42,460 --> 00:15:44,550
както и просто да се разбере
какво става.

310
00:15:44,550 --> 00:15:47,330
>> И наистина, на всеки
итерация тук на линия 9

311
00:15:47,330 --> 00:15:49,260
Искам да видя, каква е стойността на аз?

312
00:15:49,260 --> 00:15:50,290
Каква е стойността на аз?

313
00:15:50,290 --> 00:15:51,280
Каква е стойността на аз?

314
00:15:51,280 --> 00:15:55,650
И, надявам се, аз само трябва
видим, че съобщение, също, 10 пъти.

315
00:15:55,650 --> 00:15:57,780
>> Така че нека да вървим напред и да
компилирате програмата си,

316
00:15:57,780 --> 00:15:59,905
като трябва да направя всяко време
Аз се направи промяна. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
И now-- OK.

319
00:16:03,640 --> 00:16:04,820
Има много по-става.

320
00:16:04,820 --> 00:16:07,610
Така че нека да се придвижите нагоре в
още по-голям прозорец.

321
00:16:07,610 --> 00:16:10,190
>> И ще видите, че всеки един от
на Hashtags все още се печата.

322
00:16:10,190 --> 00:16:15,270
Но в между всеки от тях сега това е
диагностичен изход форматиран както следва.

323
00:16:15,270 --> 00:16:17,960
Името на програмата ми тук е buggy2.

324
00:16:17,960 --> 00:16:20,432
Името на файла е buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Номерът на реда, от които
това е отпечатана е линия 9.

326
00:16:24,080 --> 00:16:27,500
И след това в дясно от които е
съобщение за грешка, че съм очаквал.

327
00:16:27,500 --> 00:16:30,701
>> И това, което е хубаво за това е, че
Сега не е нужно да е задължително да се брои

328
00:16:30,701 --> 00:16:32,200
в главата ми какво ми програма се прави.

329
00:16:32,200 --> 00:16:34,240
Виждам, че на
Първото повторение I е 0,

330
00:16:34,240 --> 00:16:39,420
след 1, след това 2, след това 3, след това 4, след това
5, след това 6, след това 7, след това 8, след това 9, тогава

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Така че чакай малко.

333
00:16:42,050 --> 00:16:43,740
Какво става тук?

334
00:16:43,740 --> 00:16:48,190
Аз все още като че ли се брои
по предназначение до 10.

335
00:16:48,190 --> 00:16:50,550
>> Но откъде да започнем?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

337
00:16:53,240 --> 00:16:58,040
Така 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11 пръста

338
00:16:58,040 --> 00:16:59,990
е показателно за проблема.

339
00:16:59,990 --> 00:17:02,850
Изглежда съм преброени
неправилно в моята линия.

340
00:17:02,850 --> 00:17:06,599
Вместо да отидат 10 повторения,
Аз съм се започне от 0,

341
00:17:06,599 --> 00:17:09,550
Аз съм завършващ в и чрез 10.

342
00:17:09,550 --> 00:17:12,030
Но тъй като компютър,
Аз съм се започне преброяване на 0,

343
00:17:12,030 --> 00:17:15,250
Аз трябва да се брои
, но не чрез, 10.

344
00:17:15,250 --> 00:17:18,510
>> И така уговорката, че в крайна сметка
реализира тук, е едно от двете неща.

345
00:17:18,510 --> 00:17:22,430
Аз може би просто се каже,
брои до по-малко от 10.

346
00:17:22,430 --> 00:17:27,260
Така 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, което е, наистина, правилно,

347
00:17:27,260 --> 00:17:28,900
макар и да звучи малко погрешно.

348
00:17:28,900 --> 00:17:35,070
Или мога да направя по-малко или равно
до 9, така че стига да започне в 0.

349
00:17:35,070 --> 00:17:40,056
Или ако наистина не ми харесва, че сте
може да разчита нагоре през 10, но започват от 1.

350
00:17:40,056 --> 00:17:41,680
Но отново, това просто не е, че общата.

351
00:17:41,680 --> 00:17:43,977
В programming-- макар и
не толкова в Scratch--

352
00:17:43,977 --> 00:17:45,810
но в програмирането в
C и други езици,

353
00:17:45,810 --> 00:17:47,670
като JavaScript и
Python и други, това е

354
00:17:47,670 --> 00:17:49,880
Просто много често за
нашата дискусия на двоичен

355
00:17:49,880 --> 00:17:53,450
просто да започнете да броим в
най-малък брой можете, която е 0.

356
00:17:53,450 --> 00:17:53,950
Добре.

357
00:17:53,950 --> 00:17:55,160
Така че това е eprintf.

358
00:17:55,160 --> 00:17:58,600
И отново, сега, че съм разбрал ми
проблем, и аз ще се върна към 0

359
00:17:58,600 --> 00:18:01,470
чрез по-малко от 10, аз ще съм
да ида и да изтрие eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Тя не трябва да бъде там, когато аз
кораб моя код или изпратете ми код

361
00:18:04,580 --> 00:18:05,800
или го покаже на някой друг.

362
00:18:05,800 --> 00:18:07,980
Това е наистина просто означаваше
да се използва за временно.

363
00:18:07,980 --> 00:18:11,650
Но сега съм фиксиран това
конкретен проблем, както добре.

364
00:18:11,650 --> 00:18:16,780
>> Е, нека да направим още един пример тук
че аз отивам да привличам, както следва.

365
00:18:16,780 --> 00:18:22,850
Отивам да се продължи напред и
# включват. $ 50

366
00:18:22,850 --> 00:18:25,580
И аз ще отида напред
и #include.

367
00:18:25,580 --> 00:18:29,030
>> И аз ще се спаси
този файл като buggy3.c.

368
00:18:29,030 --> 00:18:31,740
И аз ще отида напред
и декларира INT главната (недействителни).

369
00:18:31,740 --> 00:18:34,186
И тогава вътре има
Отивам да направя INT I _ -

370
00:18:34,186 --> 00:18:36,435
Искам да се приложи програма
с get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Това не е функция, която съществува все още.

373
00:18:40,770 --> 00:18:42,870
Така че ние ще се приложат
то в един момент.

374
00:18:42,870 --> 00:18:45,541
Но ние ще се види защо
това е бъгав при първо преминаване.

375
00:18:45,541 --> 00:18:47,290
И след като съм намерила
пад от потребителя,

376
00:18:47,290 --> 00:18:53,365
Аз съм просто ще отпечатате% и е отрицателен
число, наклонена черта, п, запетая, аз.

377
00:18:53,365 --> 00:18:55,240
С други думи, всичко, което
Искам тази програма, за да се направи

378
00:18:55,240 --> 00:18:58,000
се получи отрицателен инт от
на потребителя и след това отпечатайте

379
00:18:58,000 --> 00:18:59,980
че такъв и такъв е отрицателен вътр.

380
00:18:59,980 --> 00:19:02,080
>> Сега трябва да се приложи тази функция.

381
00:19:02,080 --> 00:19:05,740
Така че по-късно в досието ми, аз ще отида
напред и декларира функция, наречена

382
00:19:05,740 --> 00:19:10,670
get_negative_int (свободен) - и ние ще
се върна към това, което означава отново тази линия

383
00:19:10,670 --> 00:19:18,790
в moment-- INT N; do-- задачи
following-- ФОРМАТ п е :.

384
00:19:18,790 --> 00:19:26,210
И тогава аз ще направя п - get_int,
и направи това, докато п е по-голямо от 0.

385
00:19:26,210 --> 00:19:28,310
И след това се върнете н ;.

386
00:19:28,310 --> 00:19:31,730
>> Така че има много неща се случват в
това, но нито един от които не е

387
00:19:31,730 --> 00:19:33,710
погледнете миналата седмица, поне за кратко.

388
00:19:33,710 --> 00:19:36,980
Така че по линия 10 тук съм обявен за
функция, наречена get_negative_int,

389
00:19:36,980 --> 00:19:39,620
и аз сме поставени (свободен), в
скоби, Причината е тази

390
00:19:39,620 --> 00:19:40,950
не взема един вход.

391
00:19:40,950 --> 00:19:42,910
Аз не съм преминаване нищо
за тази функция.

392
00:19:42,910 --> 00:19:44,690
Аз съм просто се нещо обратно от него.

393
00:19:44,690 --> 00:19:47,270
>> И това, което аз съм с надеждата да
се върна е цяло число.

394
00:19:47,270 --> 00:19:50,040
Не е тип данни в
С нарича negative_int.

395
00:19:50,040 --> 00:19:52,880
Това е просто INT, така че ще
да бъде на нас, за да се уверите,

396
00:19:52,880 --> 00:19:55,340
че стойността, която е действително
Върнато е не само инт

397
00:19:55,340 --> 00:19:56,380
но също е отрицателно.

398
00:19:56,380 --> 00:20:02,150
>> На линия 12 Аз съм за обявяване на променлива
нарича н и я направи на тип Int.

399
00:20:02,150 --> 00:20:07,500
И след това в ред 13 до 18 съм
прави нещо, докато нещо не е вярно.

400
00:20:07,500 --> 00:20:11,040
Отивам напред и печат
п е, дебелото черво, и след това пространство,

401
00:20:11,040 --> 00:20:12,800
като изисква от потребителя.

402
00:20:12,800 --> 00:20:16,410
>> след това се обаждам get_int и
съхраняване на така наречените връщане стойност

403
00:20:16,410 --> 00:20:18,130
в тази променлива п.

404
00:20:18,130 --> 00:20:22,600
Но аз ще продължавам
това, докато п е по-голямо от 0.

405
00:20:22,600 --> 00:20:27,960
С други думи, ако потребителят ми дава
Int и този брой е по-голям от 0,

406
00:20:27,960 --> 00:20:31,180
Ergo, положително, аз ще
просто да reprompting на потребителя,

407
00:20:31,180 --> 00:20:37,160
запази reprompting, като ги принуждава да
сътрудничат и да ми даде отрицателен вътр.

408
00:20:37,160 --> 00:20:41,640
>> И след като п е всъщност negative--
Предполагам, че потребителят накрая видове -50,

409
00:20:41,640 --> 00:20:46,710
След тази линия, докато вече не е вярно,
защото -50 е не по-голямо от 0.

410
00:20:46,710 --> 00:20:51,140
Така че ние се измъкнат от това
контур логично и да се върнат п.

411
00:20:51,140 --> 00:20:53,520
>> Но има и един друг
нещо, което трябва да направите.

412
00:20:53,520 --> 00:20:56,190
И аз може просто да направите това
от копиране и поставяне

413
00:20:56,190 --> 00:20:58,540
един ред код в началото на файла.

414
00:20:58,540 --> 00:21:01,630
Трябва да се научи звън,
или обещават да звън,

415
00:21:01,630 --> 00:21:04,630
изрично, че ще го направя,
Наистина, отидете и да приложат

416
00:21:04,630 --> 00:21:06,020
тази функция get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Той може просто да бъде по-ниска в файла.

418
00:21:07,674 --> 00:21:09,840
Отново, припомни, че звън
чете неща горе до долу,

419
00:21:09,840 --> 00:21:12,330
от ляво на дясно, така че не може
извикате функция, ако звън

420
00:21:12,330 --> 00:21:15,330
не знае, че ще съществува.

421
00:21:15,330 --> 00:21:18,430
>> Сега, за съжаление, тази програма,
Както някои от вас може би сте забелязали,

422
00:21:18,430 --> 00:21:19,590
е вече бъги.

423
00:21:19,590 --> 00:21:21,400
Нека да вървим напред и да направи buggy3.

424
00:21:21,400 --> 00:21:26,904
Той съставя, така че моят проблем сега не е
синтактична грешка, като грешка текстова,

425
00:21:26,904 --> 00:21:29,570
това е всъщност ще бъде логична
грешка, която съм умишлено

426
00:21:29,570 --> 00:21:32,450
направена като възможност за
преминете през това, което се случва.

427
00:21:32,450 --> 00:21:35,540
>> Отивам да се продължи напред
Сега и тече buggy3.

428
00:21:35,540 --> 00:21:37,490
И аз ще отида
напред и да не сътрудничи.

429
00:21:37,490 --> 00:21:39,494
Отивам да го дам номер 1.

430
00:21:39,494 --> 00:21:41,410
Тя не го харесва, така че
Това ме накара отново.

431
00:21:41,410 --> 00:21:42,147
>> Какво ще кажете за 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Нито един от тези, които работят.

435
00:21:44,740 --> 00:21:46,890
Как около -50?

436
00:21:46,890 --> 00:21:48,560
И програмата изглежда да работи.

437
00:21:48,560 --> 00:21:49,970
>> Нека се опитаме още веднъж.

438
00:21:49,970 --> 00:21:53,400
Нека се опитам -1, изглежда да работи.

439
00:21:53,400 --> 00:21:56,380
Нека се опитам -2, изглежда да работи.

440
00:21:56,380 --> 00:21:59,640
Нека се опитам 0.

441
00:21:59,640 --> 00:22:01,684
Хм, това е неправилно.

442
00:22:01,684 --> 00:22:03,350
Сега, ние сме в малко педантичен тук.

443
00:22:03,350 --> 00:22:07,090
Но това е, наистина, при които 0
не е нито положително, нито отрицателно.

444
00:22:07,090 --> 00:22:11,150
И така факта, че моята програма е
казвайки, че 0 е отрицателно число,

445
00:22:11,150 --> 00:22:12,820
това не е технически правилно.

446
00:22:12,820 --> 00:22:15,180
>> Сега, защо се прави това?

447
00:22:15,180 --> 00:22:16,270
Е, това може да е очевидно.

448
00:22:16,270 --> 00:22:18,110
И наистина, програмата е
трябвало да бъде доста проста

449
00:22:18,110 --> 00:22:19,670
Така че ние имаме нещо да се изследват.

450
00:22:19,670 --> 00:22:25,870
>> Но нека да се въведе трета отстраняване на грешки
Техниката тук наречен debug50.

451
00:22:25,870 --> 00:22:27,750
Така че това е програма,
че ние току-що създадена

452
00:22:27,750 --> 00:22:30,770
тази година, наречен debug50
който ще ви позволи

453
00:22:30,770 --> 00:22:34,130
да използват това, което се нарича вграден
графичен дебъгер в CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
И за корекция на грешки е просто една програма, която
обикновено ви позволява да стартирате програмата

455
00:22:38,400 --> 00:22:44,050
но стъпка по стъпка по стъпка, линия
от ред по ред, спирайки, изпълзяват

456
00:22:44,050 --> 00:22:47,626
наоколо, погледнете в променливи, така че
програмата не само взриви покрай вас

457
00:22:47,626 --> 00:22:49,750
и бързо отпечатване на нещо
или не отпечата нещо.

458
00:22:49,750 --> 00:22:53,250
Тя ви дава възможност, при
човешки скорост, да взаимодейства с него.

459
00:22:53,250 --> 00:22:55,470
>> И за да направите това, вие
просто направете следното.

460
00:22:55,470 --> 00:22:58,479
След съставянето на кода си,
което аз вече направих, buggy3,

461
00:22:58,479 --> 00:23:00,020
отидете напред и да тичам debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Така че много прилича help50 има изпълнявате
help50 и след командата,

464
00:23:06,760 --> 00:23:10,120
debug50 има ли тече debug50 и
след името на командата.

465
00:23:10,120 --> 00:23:14,440
>> Сега гледам какво се случва на екрана си,
на дясната ръка и по-специално.

466
00:23:14,440 --> 00:23:19,400
Когато удари Run, всички от
внезапна този десен панел

467
00:23:19,400 --> 00:23:20,419
отваря на екрана.

468
00:23:20,419 --> 00:23:22,210
А има и много неща се случват
на пръв поглед.

469
00:23:22,210 --> 00:23:25,110
Но там не е твърде
много да се притеснявате за още.

470
00:23:25,110 --> 00:23:28,570
>> Това ми показва всичко
което се случва вътре в моята програма

471
00:23:28,570 --> 00:23:31,130
точно сега и чрез тях
копчета до върха е след това

472
00:23:31,130 --> 00:23:35,910
че ми позволи да се засили чрез моя код
в крайна сметка стъпка по стъпка по стъпка.

473
00:23:35,910 --> 00:23:37,140
Но не, просто все още.

474
00:23:37,140 --> 00:23:38,060
Забележете какво се случва.

475
00:23:38,060 --> 00:23:40,600
На терминал моя прозорец
Аз съм се появи подкана за п.

476
00:23:40,600 --> 00:23:44,560
И аз ще отида напред и
сътрудничат това време и тип в -1.

477
00:23:44,560 --> 00:23:48,770
И макар и малко загадъчно, -1
е отрицателно число, както се очаква.

478
00:23:48,770 --> 00:23:52,020
>> И тогава детето излезе с
статус 0 GDBserver излизане.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, е името
на базовия софтуер

480
00:23:55,180 --> 00:23:56,620
който реализира тази дебъгер.

481
00:23:56,620 --> 00:24:00,500
Но всичко това наистина означава, дебъгер
си отиде, защото програмата ми откажат

482
00:24:00,500 --> 00:24:01,710
и всичко е наред.

483
00:24:01,710 --> 00:24:06,020
Ако искам наистина да трасира моята програма,
Аз трябва да изпреварващо да кажа debug50,

484
00:24:06,020 --> 00:24:08,920
Къде мога да искате да започнете
засилване през моя код?

485
00:24:08,920 --> 00:24:11,750
>> И може би най-простият начин
да се направи това е, както следва.

486
00:24:11,750 --> 00:24:15,300
Ако мишката върху
канавката на моя редактор тук,

487
00:24:15,300 --> 00:24:19,090
така наистина само в страничната лента тук,
от лявата страна на номера на реда,

488
00:24:19,090 --> 00:24:21,870
Забележете, че ако аз просто кликнете
веднъж, сложих малко червена точка.

489
00:24:21,870 --> 00:24:24,460
И това малко червена точка,
като знак стоп, означава, хей,

490
00:24:24,460 --> 00:24:29,430
debug50, изпълнение пауза на моя код
точно там, когато стартирате тази програма.

491
00:24:29,430 --> 00:24:30,260
>> Така че нека да направим това.

492
00:24:30,260 --> 00:24:37,340
Нека да вървим напред и да стартирате програмата си
отново с debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
И сега, известие, нещо
различно се е случило.

494
00:24:40,110 --> 00:24:42,440
Аз не съм питане
Все още в терминал моя прозорец

495
00:24:42,440 --> 00:24:45,430
за нищо, защото не съм
намерила там все още в моята програма.

496
00:24:45,430 --> 00:24:47,950
Забележете, че по линия 8
които сега се освети,

497
00:24:47,950 --> 00:24:51,720
и там е малко по-стрелка в
лявото поговорка, която се спря тук.

498
00:24:51,720 --> 00:24:55,030
Тази линия на код, линия
8, все още не е изпълнена.

499
00:24:55,030 --> 00:24:58,940
>> И това, което е любопитно, ако аз гледам
тук на дясната ръка,

500
00:24:58,940 --> 00:25:03,530
Забележете, че е местен
променлива, местно, в смисъл,

501
00:25:03,530 --> 00:25:05,450
че това е в рамките на текущата функция.

502
00:25:05,450 --> 00:25:08,920
И неговата стойност, очевидно по подразбиране,
и нещо удобно, е 0.

503
00:25:08,920 --> 00:25:10,260
Но аз не се объркате 0.

504
00:25:10,260 --> 00:25:13,410
Това просто се случва да бъде неговата
стойност по подразбиране в момента.

505
00:25:13,410 --> 00:25:15,490
>> Така че нека да вървим напред и да направим това сега.

506
00:25:15,490 --> 00:25:18,680
Нека да вървим напред и на
на върха точно тук, аз съм

507
00:25:18,680 --> 00:25:20,970
ще отида напред и
кликнете тази първа икона, която

508
00:25:20,970 --> 00:25:25,360
означава стъпка над което означава, не пропускай
го, но се оттегли през тази линия на код,

509
00:25:25,360 --> 00:25:27,770
тя изпълнява по протежение на пътя.

510
00:25:27,770 --> 00:25:30,710
>> И сега, забележете, ми
бързо е просто променен.

511
00:25:30,710 --> 00:25:31,380
Защо така?

512
00:25:31,380 --> 00:25:33,639
Казах debug50,
изпълня този ред код.

513
00:25:33,639 --> 00:25:34,930
Какво прави този ред код направя?

514
00:25:34,930 --> 00:25:35,960
ме пита за едно цяло число.

515
00:25:35,960 --> 00:25:36,460
ДОБРЕ.

516
00:25:36,460 --> 00:25:37,400
Нека да си сътрудничат.

517
00:25:37,400 --> 00:25:41,340
Нека вървим напред сега и въведете -1, Enter.

518
00:25:41,340 --> 00:25:42,920
И сега забележи какво се е променило.

519
00:25:42,920 --> 00:25:46,060
На дясната ръка,
моята локална променлива аз

520
00:25:46,060 --> 00:25:48,200
е показан като -1 сега.

521
00:25:48,200 --> 00:25:49,810
И все пак е от тип Int.

522
00:25:49,810 --> 00:25:53,102
>> И известие, също ми т.нар
наричаме стак, където се поставя на пауза?

523
00:25:53,102 --> 00:25:54,810
Ще говорим повече за това
това в бъдеще.

524
00:25:54,810 --> 00:25:58,620
Но стека повикване просто се отнася до това, което
функции в момента са в движение.

525
00:25:58,620 --> 00:26:00,040
Точно сега това е просто основна.

526
00:26:00,040 --> 00:26:03,590
И точно сега единственото местно
променлива е и със стойност 1.

527
00:26:03,590 --> 00:26:09,840
>> И когато най-накрая се оттегли през тази линия
тук, с които същата икона горе в дясно,

528
00:26:09,840 --> 00:26:11,410
-1 Е отрицателно число.

529
00:26:11,410 --> 00:26:13,580
Сега се спираше върху които фигурна скоба.

530
00:26:13,580 --> 00:26:14,740
Нека позволим на това, че направи нещо.

531
00:26:14,740 --> 00:26:17,300
I стъпка над тази линия, и готово.

532
00:26:17,300 --> 00:26:20,240
>> Така че не всичко, което ужасно
поучително още,

533
00:26:20,240 --> 00:26:23,550
но това ми позволи да направите пауза
и мисля, че чрез логически

534
00:26:23,550 --> 00:26:24,870
това, което тази програма се прави.

535
00:26:24,870 --> 00:26:26,890
Но това не е най-погрешното случая.

536
00:26:26,890 --> 00:26:28,510
Нека да направим това отново, както следва.

537
00:26:28,510 --> 00:26:31,340
>> Отивам да напуснат тази точка на прекъсване
по линия 8 с червена точка.

538
00:26:31,340 --> 00:26:32,830
Отивам да се преиграва debug50.

539
00:26:32,830 --> 00:26:34,400
Тя автоматично се спря тук.

540
00:26:34,400 --> 00:26:37,660
Но този път, вместо да
прекрачи тази линия,

541
00:26:37,660 --> 00:26:42,290
нека действително да влезем вътре на
get_negative_int и да разбера,

542
00:26:42,290 --> 00:26:45,530
защо се приема 0 като валиден отговор?

543
00:26:45,530 --> 00:26:47,990
>> Така че вместо да кликнете Step Over.

544
00:26:47,990 --> 00:26:50,630
Отивам да се продължи напред
и кликнете Step Into.

545
00:26:50,630 --> 00:26:54,030
И забележете, че линията 8, която е
Сега подчерта сега изведнъж

546
00:26:54,030 --> 00:26:56,900
става линия 17.

547
00:26:56,900 --> 00:26:59,947
>> Сега, това не е толкова дебъгер
е пропуснато линии 14 и 15 и 16.

548
00:26:59,947 --> 00:27:01,780
Това е просто няма нищо
да ви покаже там.

549
00:27:01,780 --> 00:27:04,050
Тези, които са само за обявяване променливи,
И тогава там е думата Смятате

550
00:27:04,050 --> 00:27:05,390
и след това отворен фигурна скоба.

551
00:27:05,390 --> 00:27:09,227
Единствената функционална линия, която е
сочен наистина е този тук, 17.

552
00:27:09,227 --> 00:27:11,060
И това е, когато ние сме
замълча автоматично.

553
00:27:11,060 --> 00:27:13,870
>> Така ФОРМАТ ( "n.is:") ;, така
че не се е случило все още.

554
00:27:13,870 --> 00:27:18,250
Така че нека да вървим напред и да кликнете прекрача.

555
00:27:18,250 --> 00:27:20,326
Сега ми бързо, наистина,
променен на ( "п").

556
00:27:20,326 --> 00:27:22,450
Сега get_int, аз няма
да се притеснява засилване в,

557
00:27:22,450 --> 00:27:24,750
защото тази функция е
направено от CS50 в библиотеката.

558
00:27:24,750 --> 00:27:25,750
Това е вероятно правилно.

559
00:27:25,750 --> 00:27:28,440
>> Така че аз ще отида напред и
сортиране на сътрудничат, като му дава

560
00:27:28,440 --> 00:27:30,590
пад, но не отрицателно вътр.

561
00:27:30,590 --> 00:27:32,870
Така че нека да вървим напред и да се удари 0.

562
00:27:32,870 --> 00:27:39,460
И сега какво се случва тук
когато се прибера до ред 21?

563
00:27:39,460 --> 00:27:40,890
Аз не съм повтори отново.

564
00:27:40,890 --> 00:27:43,320
Аз не изглежда да се залепи в тази линия.

565
00:27:43,320 --> 00:27:45,990
С други думи, тази жълто
бар не продължавай наоколо,

566
00:27:45,990 --> 00:27:47,130
и наоколо, и наоколо.

567
00:27:47,130 --> 00:27:48,340
>> Сега, защо е това?

568
00:27:48,340 --> 00:27:49,920
Е, п, какво е N точно сега?

569
00:27:49,920 --> 00:27:53,280
Мога да погледна на местно
променливи в дебъгер.

570
00:27:53,280 --> 00:27:53,816
п е 0.

571
00:27:53,816 --> 00:27:55,190
Добре, какво е състоянието ми?

572
00:27:55,190 --> 00:27:58,700
>> 20-- линия 20 е, добре,
0 е по-голямо от 0.

573
00:27:58,700 --> 00:27:59,500
Това не е вярно.

574
00:27:59,500 --> 00:28:01,020
0 е не по-голямо от 0.

575
00:28:01,020 --> 00:28:02,820
И така, аз се измъкна от това.

576
00:28:02,820 --> 00:28:06,370
>> И така, ето защо на линия
21, ако аз действително да продължи,

577
00:28:06,370 --> 00:28:10,370
Отивам да се върне 0, дори
макар че е трябвало да отхвърли 0

578
00:28:10,370 --> 00:28:12,484
като всъщност не е отрицателен.

579
00:28:12,484 --> 00:28:14,650
Така че сега, аз наистина не дори
грижа за дебъгер.

580
00:28:14,650 --> 00:28:16,900
Ясно, че не е нужно да се
знам какво още се случва.

581
00:28:16,900 --> 00:28:19,233
>> Така че аз ще отида напред и
Просто кликнете върху бутона за възпроизвеждане,

582
00:28:19,233 --> 00:28:20,240
и нека този финал нагоре.

583
00:28:20,240 --> 00:28:23,440
Сега, аз осъзнах, че ми
бъг е очевидно по линия 20.

584
00:28:23,440 --> 00:28:25,160
Това ми е логическа грешка.

585
00:28:25,160 --> 00:28:28,100
>> И така, това, което искам
да направя, за да се промени това?

586
00:28:28,100 --> 00:28:32,500
Ако проблемът е, че аз не съм
улов 0, това е просто една логическа грешка.

587
00:28:32,500 --> 00:28:35,910
И мога да кажа, а п е
по-голямо от или равно на 0,

588
00:28:35,910 --> 00:28:38,330
запази накара потребителят отново и отново.

589
00:28:38,330 --> 00:28:41,050
>> Така че, отново, просто грешка, може би
дори очевидни, когато ме видя,

590
00:28:41,050 --> 00:28:42,410
го напиша само преди няколко минути.

591
00:28:42,410 --> 00:28:44,570
Но Takeaway тук
е, че с отстраняване на грешки 50,

592
00:28:44,570 --> 00:28:46,850
и с отстраняване на грешки
софтуер по-общо,

593
00:28:46,850 --> 00:28:51,370
имате тази нова намери сила да
разходка из собствения си код, изглежда

594
00:28:51,370 --> 00:28:55,590
чрез които десен панел ръка какво
променливите стойности са.

595
00:28:55,590 --> 00:28:57,700
Така че не е задължително
Трябва да се използва нещо

596
00:28:57,700 --> 00:29:00,630
като теб eprintf да отпечатате тези стойности.

597
00:29:00,630 --> 00:29:04,430
Всъщност можете да ги видите
визуално на екрана.

598
00:29:04,430 --> 00:29:08,920
>> Сега, след това, че си струва да се отбележи,
че има и друга техника, която е

599
00:29:08,920 --> 00:29:09,890
всъщност супер общ.

600
00:29:09,890 --> 00:29:13,120
И може да се чудя защо този малък
човек тук е седял на сцената.

601
00:29:13,120 --> 00:29:16,490
Така че има тази техника, като цяло
известен като гумено пате отстраняване на грешки,

602
00:29:16,490 --> 00:29:18,786
което наистина е просто
свидетелство за факта,

603
00:29:18,786 --> 00:29:20,660
които често, когато програмисти
пишете код,

604
00:29:20,660 --> 00:29:22,650
те не са непременно
сътрудничество с други,

605
00:29:22,650 --> 00:29:24,030
или работят в обща среда.

606
00:29:24,030 --> 00:29:25,050
>> Те са нещо като у дома си.

607
00:29:25,050 --> 00:29:25,910
Може би това е късно през нощта.

608
00:29:25,910 --> 00:29:28,190
Те се опитват да фигура
някои бъгове в своя код.

609
00:29:28,190 --> 00:29:29,330
И те просто не го виждам.

610
00:29:29,330 --> 00:29:30,329
>> И няма съквартирант.

611
00:29:30,329 --> 00:29:31,250
Не е TF.

612
00:29:31,250 --> 00:29:32,680
Не е около СА.

613
00:29:32,680 --> 00:29:36,440
Всички те имат за своя рафт
е тази малка гумена пиленце.

614
00:29:36,440 --> 00:29:39,030
>> И така, друже отстраняване на грешки
е точно тази покана

615
00:29:39,030 --> 00:29:42,780
да се мисли за нещо като глупав
тъй като това като реален създание,

616
00:29:42,780 --> 00:29:46,940
и всъщност ходят чрез своя код
устно на този неодушевен предмет.

617
00:29:46,940 --> 00:29:49,230
Така, например, ако
това е моят пример here--

618
00:29:49,230 --> 00:29:52,470
и припомни, че по-рано
проблема е този,

619
00:29:52,470 --> 00:29:58,140
ако изтрия тази първа линия на код,
и аз отида напред и да направи бъги 0 отново,

620
00:29:58,140 --> 00:30:01,220
Припомняме, че имах тези
съобщения за грешки тук.

621
00:30:01,220 --> 00:30:05,997
Така че идеята тук, смешно, че аз
чувствам в момента прави това публично,

622
00:30:05,997 --> 00:30:06,580
е, че грешка.

623
00:30:06,580 --> 00:30:10,910
>> ОК, така че моят проблем е, че аз съм
имплицитно обявен функция библиотека.

624
00:30:10,910 --> 00:30:12,610
И тази функция библиотека е ФОРМАТ.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, декларират
ми напомня на прототипа.

626
00:30:15,290 --> 00:30:18,930
>> Това означава, че трябва да всъщност
кажете на компилатора предварително какво

627
00:30:18,930 --> 00:30:19,980
функцията изглежда така.

628
00:30:19,980 --> 00:30:20,930
Чакай малко.

629
00:30:20,930 --> 00:30:23,580
Не съм имал стандарт io.h.

630
00:30:23,580 --> 00:30:24,530
Благодаря ти много.

631
00:30:24,530 --> 00:30:27,330
>> Така че просто този процес of-- ви
не е нужно да имаме всъщност патица.

632
00:30:27,330 --> 00:30:29,819
Но тази идея за ходене
себе си чрез своя собствен код

633
00:30:29,819 --> 00:30:31,610
така че можете дори чуете
себе си, така че да

634
00:30:31,610 --> 00:30:35,620
осъзнават, пропуски в собствения си
забележки, по принцип е идеята.

635
00:30:35,620 --> 00:30:38,910
>> И, може би по-логично, не толкова
много от това, но на по-голямо участие

636
00:30:38,910 --> 00:30:44,220
Например ние просто направихме в бъги 3.В,
може да се преведе през него

637
00:30:44,220 --> 00:30:45,310
както следва.

638
00:30:45,310 --> 00:30:49,190
Така че всичко е наред, каучук
пиленце, DDB, ако щете.

639
00:30:49,190 --> 00:30:52,350
Тук имаме в моята основна функция,
Обаждам се отрицателната вътр.

640
00:30:52,350 --> 00:30:54,660
>> И аз съм се върнатата стойност.

641
00:30:54,660 --> 00:31:00,410
Аз съм го съхраняване на лявата ръка
по линия 8 в променлива наречена аз.

642
00:31:00,410 --> 00:31:02,380
ОК, но изчакайте, как е
че се получи, че стойността?

643
00:31:02,380 --> 00:31:04,130
Нека да разгледаме функцията в ред 12.

644
00:31:04,130 --> 00:31:05,760
>> В ред 12, ние имаме получите отрицателен вътр.

645
00:31:05,760 --> 00:31:08,190
Не се предприемат никакви входове,
се връща едно цяло число, OK.

646
00:31:08,190 --> 00:31:10,929
Декларирам, по линия 14 с променлива п.

647
00:31:10,929 --> 00:31:12,220
Това ще съхранява цяло число.

648
00:31:12,220 --> 00:31:13,760
Това е, което искам.

649
00:31:13,760 --> 00:31:18,480
>> Така че направете следното, докато п is-- нека
ми отмените какво уговорката аз вече направени.

650
00:31:18,480 --> 00:31:22,710
Така че, докато п е по-голямо от
0, разпечатате п е ОК.

651
00:31:22,710 --> 00:31:25,170
И след това се обадете се инт съхранява в п.

652
00:31:25,170 --> 00:31:30,160
И след това проверете дали п е 0,
п е not-- там е.

653
00:31:30,160 --> 00:31:31,910
Така че, отново, не е
нужда от действителната патица.

654
00:31:31,910 --> 00:31:35,650
Но просто ходене себе си чрез
кода си като интелектуално упражнение

655
00:31:35,650 --> 00:31:37,720
често ще ви помогне
осъзнават какво се случва,

656
00:31:37,720 --> 00:31:41,170
за разлика от просто прави нещо
като този, взирайки се в екрана,

657
00:31:41,170 --> 00:31:43,720
и не говорим себе си чрез
това, което честно казано не е

658
00:31:43,720 --> 00:31:46,270
толкова ефективна техника.

659
00:31:46,270 --> 00:31:48,620
Така че има ли го, а
няколко различни техники

660
00:31:48,620 --> 00:31:52,102
за действително коригирането на грешките в кода
и укорява, всички от които

661
00:31:52,102 --> 00:31:54,810
трябва да са инструменти във вашия инструментариум
така че не си късно през нощта,

662
00:31:54,810 --> 00:31:57,660
особено, вие сте в трапезарията
зали, или в работно време,

663
00:31:57,660 --> 00:32:00,368
Блъскането на главата на
стена, се опитва да реши някакъв проблем.

664
00:32:00,368 --> 00:32:02,020
Осъзнайте, че има софтуерни инструменти.

665
00:32:02,020 --> 00:32:03,720
Има гумени инструменти патица.

666
00:32:03,720 --> 00:32:09,630
И там е цяло персонала на
подкрепа, чакащи да подадат ръка.

667
00:32:09,630 --> 00:32:13,120
>> Така че сега, и дума по проблема
комплекти, и на това, което ние с вас с надеждата

668
00:32:13,120 --> 00:32:15,620
да излезе от тях, и как
отиваме за оценяване.

669
00:32:15,620 --> 00:32:17,680
Per учебната програма на курса,
проблемни комплекти CS50 е

670
00:32:17,680 --> 00:32:22,320
се оценяват по четири основни оси, така че
да speak-- обхват, коректност, дизайн,

671
00:32:22,320 --> 00:32:23,060
и стил.

672
00:32:23,060 --> 00:32:25,910
И обхват просто се отнася до това колко
на парчето са ви отхапал?

673
00:32:25,910 --> 00:32:28,080
Как кой знае какъв проблем сте опитвали?

674
00:32:28,080 --> 00:32:30,110
Какво ниво на усилие
са ви проявява?

675
00:32:30,110 --> 00:32:35,750
>> Коректността е, върши работата на програмата, както е
това е трябвало да спецификация CS50

676
00:32:35,750 --> 00:32:38,640
когато ви предостави някои входове
или някои изходи се върне?

677
00:32:38,640 --> 00:32:41,130
Design е най-субективният от тях.

678
00:32:41,130 --> 00:32:43,360
И това е този, който ще
вземе най-дълго, за да научите

679
00:32:43,360 --> 00:32:47,220
и най-дълго, за да научи, в
доколкото то се свежда до това,

680
00:32:47,220 --> 00:32:49,530
колко добре написан е кода си?

681
00:32:49,530 --> 00:32:52,920
>> Това е едно нещо просто да отпечатате правилно
изходи или връщане на точните стойности.

682
00:32:52,920 --> 00:32:55,400
Но го правиш като
ефективно възможно, тъй като?

683
00:32:55,400 --> 00:32:58,210
Възможно ли е да го прави разделение
и владей, или двоичен

684
00:32:58,210 --> 00:33:01,500
търсене, тъй като ние скоро ще видите, че ние направихме
преди две седмици с телефонния указател?

685
00:33:01,500 --> 00:33:04,670
Има по-добри начини за решаване на
проблем, отколкото в момента имате тук?

686
00:33:04,670 --> 00:33:06,380
Това е една възможност за по-добър дизайн.

687
00:33:06,380 --> 00:33:08,530
>> И тогава style-- как
доста е кода си?

688
00:33:08,530 --> 00:33:12,370
Ще забележите, че аз съм доста
специално за редовете на моя код,

689
00:33:12,370 --> 00:33:15,300
и като се уверите, моите променливи
са разумни име. N,

690
00:33:15,300 --> 00:33:19,660
докато кратко, е добро име за
номер, аз за броене число,

691
00:33:19,660 --> 00:33:20,727
ите за низ.

692
00:33:20,727 --> 00:33:22,560
И ние можем да имаме по-дълго
променлива имена стил.

693
00:33:22,560 --> 00:33:25,500
Style е точно колко добър
изглежда кода си?

694
00:33:25,500 --> 00:33:26,600
И как се чете, че е?

695
00:33:26,600 --> 00:33:29,650
>> И с течение на времето, това, което си TAS
и TFS ще правят в хода

696
00:33:29,650 --> 00:33:31,870
е ви осигури, че
вид качествена обратна връзка

697
00:33:31,870 --> 00:33:34,330
така че да получите по-добре
при тези различни аспекти.

698
00:33:34,330 --> 00:33:37,510
И по отношение на начина, по който
оцени всяка от тези оси,

699
00:33:37,510 --> 00:33:40,080
това е обикновено с много малко
кофи, така че вие, като цяло,

700
00:33:40,080 --> 00:33:41,680
се получи усещане за това колко добре сте прави.

701
00:33:41,680 --> 00:33:45,680
И наистина, ако получите резултат на
всяко от тези axes-- коректност, дизайн

702
00:33:45,680 --> 00:33:49,659
и стил especially-- този брой
обикновено ще бъде между 1 и 5.

703
00:33:49,659 --> 00:33:52,450
И, буквално, ако сте се
3 е в началото на семестъра,

704
00:33:52,450 --> 00:33:53,977
това е много добро нещо.

705
00:33:53,977 --> 00:33:55,810
Това означава, че все още има
Стая за подобрения,

706
00:33:55,810 --> 00:33:58,490
които ще се надяваме за в
като клас за първи път.

707
00:33:58,490 --> 00:34:01,820
Има надяваме някои малко на таван
към която сте се стремят към постигане.

708
00:34:01,820 --> 00:34:03,970
И така става 3 относно
най-ранните парчета,

709
00:34:03,970 --> 00:34:06,550
ако не някои 2 и 4 се,
е, наистина, е нещо добро.

710
00:34:06,550 --> 00:34:08,880
Това е добре в рамките на диапазон,
и в рамките на очакванията.

711
00:34:08,880 --> 00:34:11,421
>> И ако съзнанието ти се състезава, изчакайте
една минута, три от пет.

712
00:34:11,421 --> 00:34:12,620
Това е наистина една 6 от 10.

713
00:34:12,620 --> 00:34:13,560
Това е 60%.

714
00:34:13,560 --> 00:34:14,830
Боже мой, това е F.

715
00:34:14,830 --> 00:34:15,870
>> Не е.

716
00:34:15,870 --> 00:34:17,600
Това не е, в действителност, че.

717
00:34:17,600 --> 00:34:22,710
По-скоро, това е една възможност да се подобри
в течение на семестъра.

718
00:34:22,710 --> 00:34:25,580
И ако сте се някои
Poors, те са възможност

719
00:34:25,580 --> 00:34:29,199
да се възползват от работното време,
със сигурност секции и други ресурси.

720
00:34:29,199 --> 00:34:32,840
>> Най-добър е възможност, наистина,
да се гордеем с това колко далеч сте

721
00:34:32,840 --> 00:34:34,520
дойде в течение на семестъра.

722
00:34:34,520 --> 00:34:38,199
Така че си дават сметка, ако нищо
друго, три е добър.

723
00:34:38,199 --> 00:34:40,179
И това позволява място за растеж в течение на времето.

724
00:34:40,179 --> 00:34:43,090
>> Що се отнася до това как тези оси са
претеглена, реалистично ли сте

725
00:34:43,090 --> 00:34:46,745
ще прекарват по-голямата част от времето си удар
неща да работят, да не говорим за правилно.

726
00:34:46,745 --> 00:34:49,120
И така, коректност има тенденция да
се претегля най-много, тъй като с

727
00:34:49,120 --> 00:34:51,360
това мултипликативен коефициент три.

728
00:34:51,360 --> 00:34:54,659
Дизайнът е също важно, но
нещо, което не е задължително

729
00:34:54,659 --> 00:34:58,220
харчат всички тези часове
опитвайки се да получите нещата просто да работят.

730
00:34:58,220 --> 00:35:00,019
>> И така, това е претеглен
малко по-леко.

731
00:35:00,019 --> 00:35:01,560
И тогава стил се претегля най-малко.

732
00:35:01,560 --> 00:35:03,710
Въпреки че това не по-малко е
важно фундаментално,

733
00:35:03,710 --> 00:35:05,990
това е просто, може би,
Най-лесният нещо да направя така,

734
00:35:05,990 --> 00:35:08,440
имитират ние примери
направя в лекция и раздел,

735
00:35:08,440 --> 00:35:11,080
с нещата добре
разчленена, и коментира,

736
00:35:11,080 --> 00:35:14,320
и така нататък, е сред най-лесните
неща за вършене и се прави.

737
00:35:14,320 --> 00:35:16,960
Така че като такива, да разбере,
че тези, които са точки

738
00:35:16,960 --> 00:35:19,000
които са сравнително лесно да се разбере.

739
00:35:19,000 --> 00:35:22,360
>> А сега няколко думи за
this-- академична честност.

740
00:35:22,360 --> 00:35:25,150
Така че на на курса
учебната програма, ще видите,

741
00:35:25,150 --> 00:35:27,630
че по време има доста
малко на език около това.

742
00:35:27,630 --> 00:35:31,380
И по време отнема издаването на
академична честност доста сериозно.

743
00:35:31,380 --> 00:35:33,450
>> Имаме разграничението,
за добро или за лошо,

744
00:35:33,450 --> 00:35:36,570
на които са изпратени всяка година повече
студенти за дисциплинарни действия

745
00:35:36,570 --> 00:35:39,670
от най-всяка друга
Разбира се, че съм запознат.

746
00:35:39,670 --> 00:35:42,580
Това не е непременно
показателни за факта,

747
00:35:42,580 --> 00:35:46,340
че CS студенти, или CS50 студенти, са
всяко по-малко честен от съучениците си.

748
00:35:46,340 --> 00:35:49,090
Но реалността, че в този
свят, по електронен път, ние просто

749
00:35:49,090 --> 00:35:50,990
имат технологично
средства за откриване на това.

750
00:35:50,990 --> 00:35:53,360
>> Това е важно за нас, за
справедливост в целия клас

751
00:35:53,360 --> 00:35:58,550
че правим открие това, и да се повиши
въпросът, когато виждаме нещата.

752
00:35:58,550 --> 00:36:01,980
И само за да нарисува картина, и наистина
да помогне нещо подобно мивка в,

753
00:36:01,980 --> 00:36:04,600
това са номерата на
студенти през последните 10 години

754
00:36:04,600 --> 00:36:07,610
че са били замесени в някои
такива въпроси на академичната честност,

755
00:36:07,610 --> 00:36:10,990
с около 32 ученици
от есента 2015 г., което

756
00:36:10,990 --> 00:36:13,760
е да се каже, че ние не приемайте
въпроса много сериозно.

757
00:36:13,760 --> 00:36:18,380
И, в крайна сметка, тези номера съставят,
Съвсем наскоро около 3%, 4%, или

758
00:36:18,380 --> 00:36:19,120
на класа.

759
00:36:19,120 --> 00:36:25,220
>> Така че за супер-голямата част от учениците
изглежда, че линиите са ясни.

760
00:36:25,220 --> 00:36:27,940
Но имайте това
против, особено късно

761
00:36:27,940 --> 00:36:32,080
през нощта, когато се борят с
някакво решение по отношение на набор проблем,

762
00:36:32,080 --> 00:36:34,830
че са налице механизми
за себе си все по-добре

763
00:36:34,830 --> 00:36:37,870
подкрепа, отколкото може да
мисля, дори и в този час.

764
00:36:37,870 --> 00:36:40,514
Осъзнайте, че когато получим
студентски изявления, ние пресичат

765
00:36:40,514 --> 00:36:43,430
сравни всяко представяне тази година
срещу всеки представяне миналата година,

766
00:36:43,430 --> 00:36:47,590
срещу всеки представяне от 2007 г.,
и тъй, като гледаше, както и,

767
00:36:47,590 --> 00:36:49,931
код хранилищата онлайн,
дискусионни форуми, сайтове за работа.

768
00:36:49,931 --> 00:36:51,806
И ние говорим за това,
Наистина, всичко заради

769
00:36:51,806 --> 00:36:56,040
на пълно разкриване, че ако
някой друг може да го намерите онлайн,

770
00:36:56,040 --> 00:36:57,880
със сигурност, така че можем курса.

771
00:36:57,880 --> 00:37:00,100
Но, наистина, на духа
на курса се свежда

772
00:37:00,100 --> 00:37:01,650
за тази клауза в учебната програма.

773
00:37:01,650 --> 00:37:03,670
Това наистина е просто, да бъдат разумни.

774
00:37:03,670 --> 00:37:06,680
>> И ако ние трябваше да се изработи по този
с малко повече езика,

775
00:37:06,680 --> 00:37:09,770
осъзнават, че същността на всички
работа, която ви представя този курс

776
00:37:09,770 --> 00:37:10,954
трябва да бъде вашата собствена.

777
00:37:10,954 --> 00:37:13,870
Но в рамките на това, има със сигурност
възможности, както и насърчаване,

778
00:37:13,870 --> 00:37:17,300
и педагогическа стойност в превръщането на
others-- себе си, на TFS, КО,

779
00:37:17,300 --> 00:37:20,760
на TAS, и останалите в този клас,
за подкрепа, да не говорим за приятели

780
00:37:20,760 --> 00:37:23,547
и съквартиранти, които са учили
CS и програмиране преди.

781
00:37:23,547 --> 00:37:25,130
И така, има надбавка за това.

782
00:37:25,130 --> 00:37:28,180
А общото правило на палеца
е this-- когато с молба за помощ,

783
00:37:28,180 --> 00:37:31,470
може да покаже кода си на другите,
но вие не може да видите техните.

784
00:37:31,470 --> 00:37:34,880
Така че, дори ако сте на работното време,
или в D зала, или някъде другаде

785
00:37:34,880 --> 00:37:37,450
работи върху някои парче набор,
работи заедно с един приятел, който

786
00:37:37,450 --> 00:37:40,160
е напълно глоба, в
край на работата си за деня

787
00:37:40,160 --> 00:37:43,034
трябва в крайна сметка да принадлежат към всеки
на вас, съответно, и не

788
00:37:43,034 --> 00:37:45,700
бъдат някои съвместни усилия,
с изключение на крайния проект, където

789
00:37:45,700 --> 00:37:47,410
това е позволено и насърчава.

790
00:37:47,410 --> 00:37:49,830
>> Осъзнайте, че ако сте
борейки се с нещо

791
00:37:49,830 --> 00:37:52,520
и твоят приятел просто се случва
да бъде по-добре в това тогава,

792
00:37:52,520 --> 00:37:55,130
или по-добре в този проблем, отколкото сте,
или малко по-напред от вас,

793
00:37:55,130 --> 00:37:57,330
това е напълно логично да се включите
да си приятел и да кажа, хей,

794
00:37:57,330 --> 00:38:00,480
Имате ли нещо против погледнете в моя код тук,
помогнете ми забележи какво е моя въпрос?

795
00:38:00,480 --> 00:38:03,760
И, надявам се, в
интерес на педагогическа стойност

796
00:38:03,760 --> 00:38:07,040
че приятел не само
кажа, о, правя това, а по-скоро,

797
00:38:07,040 --> 00:38:09,917
какво липсва на линия
6, или нещо подобно?

798
00:38:09,917 --> 00:38:12,000
Но решението не е
за приятел до теб

799
00:38:12,000 --> 00:38:15,617
да се каже, ох, добре, тук, нека да дръпне
това нагоре, и да се покаже моето решение за вас.

800
00:38:15,617 --> 00:38:16,450
Така че е линията.

801
00:38:16,450 --> 00:38:18,670
Вие показвате вашия код за
други, но не можете да

802
00:38:18,670 --> 00:38:22,350
видите техните, при спазване на останалите
ограничения в учебната програма на курса.

803
00:38:22,350 --> 00:38:24,760
>> Така че имайте предвид това
така наречената клауза съжаление

804
00:38:24,760 --> 00:38:27,560
в учебната програма на курса, както и,
че ако се ангажират някои акт, който

805
00:38:27,560 --> 00:38:30,476
Не е разумно, но това доведе до
На вниманието на ръководителите на курса

806
00:38:30,476 --> 00:38:34,240
в рамките на 72 часа, по време
могат да налагат местни санкции, които

807
00:38:34,240 --> 00:38:37,380
може да включва незадоволителен или
негативна оценка за работата представен.

808
00:38:37,380 --> 00:38:41,410
Но разбира се, не ще се позовават на
значение за по-нататъшното дисциплинарни действия,

809
00:38:41,410 --> 00:38:43,010
освен в случаите на многократни актове.

810
00:38:43,010 --> 00:38:46,632
С други думи, ако го направите, да направи някои
глупаво, особено късно вечер, решение

811
00:38:46,632 --> 00:38:49,340
че следващата сутрин или два дни
по-късно, се събуждаш и осъзнаваш,

812
00:38:49,340 --> 00:38:50,870
това, което си мислех?

813
00:38:50,870 --> 00:38:53,890
Можете да направите в CS50 имат излаз
за определяне на този проблем

814
00:38:53,890 --> 00:38:57,170
и е собственик до него, така че да можем
Ще се срещнем по средата и да се справят

815
00:38:57,170 --> 00:39:01,500
с това е въпрос, който е едновременно
образователна и ценно за вас,

816
00:39:01,500 --> 00:39:04,200
но все още наказателна по някакъв начин.

817
00:39:04,200 --> 00:39:08,590
И сега, за да се вземат ръба на разстояние, това.

818
00:39:08,590 --> 00:39:10,570
>> [Възпроизвеждане на видео]

819
00:39:10,570 --> 00:39:13,540
>> [МУЗИКА]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END PLAYBACK]

822
00:39:58,866 --> 00:40:00,490
Дейвид Дж Малан: Добре, ние сме назад.

823
00:40:00,490 --> 00:40:03,680
И сега ние гледаме на един от най-
първо на нашите реалния свят домейни

824
00:40:03,680 --> 00:40:08,720
в CS50, изкуството на криптографията,
изкуството на изпращане и получаване на

825
00:40:08,720 --> 00:40:11,840
тайни послания, криптирана
съобщения, ако щете,

826
00:40:11,840 --> 00:40:17,060
които могат да бъдат разчетени само ако имате
някои ключова съставка че подателят има

827
00:40:17,060 --> 00:40:18,030
както добре.

828
00:40:18,030 --> 00:40:22,120
Така че, за да мотивира това ние ще се
Един поглед към това нещо тук,

829
00:40:22,120 --> 00:40:26,750
което е пример за
тайна декодер пръстен, който

830
00:40:26,750 --> 00:40:34,042
може да се използва, за да разбера
какво всъщност е тайно послание.

831
00:40:34,042 --> 00:40:35,750
Всъщност, обратно в
ден в началното училище,

832
00:40:35,750 --> 00:40:38,787
ако някога изпрати тайни съобщения до
някой приятел или някой влюбен в клас,

833
00:40:38,787 --> 00:40:40,620
може би си помислил
сте умен

834
00:40:40,620 --> 00:40:46,530
от по парче си за промяна на хартия,
като, от А до Б, и В, за да C и C до D,

835
00:40:46,530 --> 00:40:47,590
и т.н.

836
00:40:47,590 --> 00:40:50,300
Но вие всъщност криптиране
вашата информация, дори

837
00:40:50,300 --> 00:40:53,300
ако беше малко по-тривиално, не беше
че трудно за учителя да се реализира,

838
00:40:53,300 --> 00:40:55,675
добре, ако просто се промени
B към A и C до точка Б,

839
00:40:55,675 --> 00:40:57,550
всъщност разбера
какво е посланието,

840
00:40:57,550 --> 00:40:59,700
но сте били в шифриране на информация.

841
00:40:59,700 --> 00:41:03,420
>> Можете просто да го прави
просто, много прилича Ралфи тук

842
00:41:03,420 --> 00:41:07,934
в известен филм, който играе
доста много реклама nauseum всяка зима.

843
00:41:07,934 --> 00:41:08,600
[Възпроизвеждане на видео]

844
00:41:08,600 --> 00:41:11,180
Бензен-то известно на всички, че
Ралф Паркър е тук

845
00:41:11,180 --> 00:41:14,070
назначен за член на малката
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
и има право на всички почести
и ползи, настъпили към него.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Annie сираци,
контра-подписан Пиер Андре, с мастило.

848
00:41:24,340 --> 00:41:27,160
Honors и ползи,
вече на възраст от девет.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Крещеше]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Хайде.

853
00:41:34,250 --> 00:41:35,210
Нека се заемем с него.

854
00:41:35,210 --> 00:41:39,530
Нямам нужда от всичко, което джаз
за контрабандисти и пирати.

855
00:41:39,530 --> 00:41:41,660
>> -Listen Утре вечер за
заключителната приключението

856
00:41:41,660 --> 00:41:43,880
на черен пиратския кораб.

857
00:41:43,880 --> 00:41:46,650
Сега е време за
тайно съобщение на Ани

858
00:41:46,650 --> 00:41:49,840
за вас, членовете на Тайният кръг.

859
00:41:49,840 --> 00:41:53,570
Помнете, деца, само за членове
на Secret Circle Ани

860
00:41:53,570 --> 00:41:56,140
може да декодира тайно съобщение на Ани.

861
00:41:56,140 --> 00:42:00,340
>> Не забравяйте, че Ани е в зависимост от вас.

862
00:42:00,340 --> 00:42:02,880
Задайте вашите игли за B2.

863
00:42:02,880 --> 00:42:05,230
Ето съобщението.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Аз Съм в, първата ми тайна среща.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Беше в силен глас тази вечер.

868
00:42:15,780 --> 00:42:19,000
Мога да кажа, че тази вечер
съобщение е наистина важно.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, това е съобщение
от себе си Ани.

870
00:42:22,694 --> 00:42:23,860
Не забравяйте, не казвай на никого.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Секунди по-късно, аз съм в единствения
стая в къщата, в която едно момче на девет

873
00:42:32,930 --> 00:42:37,040
може да седне в личния живот и декодиране.

874
00:42:37,040 --> 00:42:39,730
Аха, B!

875
00:42:39,730 --> 00:42:42,360
Отидох до следващия, Е.

876
00:42:42,360 --> 00:42:44,520
>> Първата дума е било.

877
00:42:44,520 --> 00:42:49,032
S, то щеше да дойде по-лесно сега, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -О, Хайде, Ралфи, аз трябва да отида!

879
00:42:51,733 --> 00:42:53,688
>> -Ще Бъде чак, Ма!

880
00:42:53,688 --> 00:42:54,188
Gee факир!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -Т, О, бъдете сигурни, to-- бъде сигурен с какво?

883
00:43:04,060 --> 00:43:05,970
Какво е Little Orphan
Ани се опитвам да кажа?

884
00:43:05,970 --> 00:43:07,264
Бъдете сигурни с какво?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Анди има да
отида, ще ви моля да излезе?

886
00:43:09,634 --> 00:43:10,480
>> -Всички Полето, Ma!

887
00:43:10,480 --> 00:43:12,880
Аз ще бъда прав вън!

888
00:43:12,880 --> 00:43:14,550
>> -I Е все по-близо сега.

889
00:43:14,550 --> 00:43:16,620
Напрежението беше ужасно.

890
00:43:16,620 --> 00:43:17,720
Какво беше?

891
00:43:17,720 --> 00:43:20,170
Съдбата на планетата
може да виси на косъм.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Трябва Анди вървим!

894
00:43:23,170 --> 00:43:26,890
>> -Ще Бъда прав вън, за да плаче на глас!

895
00:43:26,890 --> 00:43:32,680
>> -Almost Там, пръстите ми летяха, съзнанието ми
Беше стомана капан, всяка пора вибрира.

896
00:43:32,680 --> 00:43:37,198
Това беше почти ясно, да, да, да.

897
00:43:37,198 --> 00:43:43,091
>> Бензен-забравяйте да пиете си Овалтин.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
А калпав търговски?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Кучи син.

903
00:43:54,227 --> 00:43:54,810
[END PLAYBACK]

904
00:43:54,810 --> 00:43:57,390
Дейвид Дж Малан: ОК, така че
че е много дълъг път

905
00:43:57,390 --> 00:44:00,660
за въвеждане на криптографията,
и също Овалтин.

906
00:44:00,660 --> 00:44:04,470
В действителност, от тази стара обява
тук, защо е Овалтин толкова добър?

907
00:44:04,470 --> 00:44:09,470
Тя е концентрирана извличане на зрели
ечемичен малц, чист кремообразна краве мляко,

908
00:44:09,470 --> 00:44:14,360
и специално приготвени какао, заедно
с естествени фосфатиди и витамини.

909
00:44:14,360 --> 00:44:18,240
Освен това той се обогатява с
допълнителни витамини от група В и D, Yum.

910
00:44:18,240 --> 00:44:21,600
И все пак можете да го получите, както изглежда,
на Amazon, както направихме тук.

911
00:44:21,600 --> 00:44:24,810
>> Но мотивацията тук е да се
въведат криптография, по-специално

912
00:44:24,810 --> 00:44:28,340
тип криптография познат
като секретен ключ, криптография.

913
00:44:28,340 --> 00:44:34,284
И както подсказва и името, като цяло
сигурност на таен ключ система крипто,

914
00:44:34,284 --> 00:44:36,200
ако щете, методология
само за кодиране

915
00:44:36,200 --> 00:44:40,960
информация между двама души, е, че
само на подателя и получателя само

916
00:44:40,960 --> 00:44:46,980
знаете таен key-- някаква стойност, някои
тайна фраза, някакъв таен номер, че

917
00:44:46,980 --> 00:44:50,660
им позволява да и двете криптиране
и декриптира информация.

918
00:44:50,660 --> 00:44:53,470
И криптография, наистина,
е точно това, от седмица 0.

919
00:44:53,470 --> 00:44:56,715
>> Това е проблем, когато има входове,
като действителната съобщение на английски език

920
00:44:56,715 --> 00:44:59,340
или какъвто и език, които можете
искате да изпратите на някого в клас,

921
00:44:59,340 --> 00:45:00,580
или в интернет.

922
00:45:00,580 --> 00:45:03,840
Има някои изход, което се случва
да бъде кодирано съобщение, че сте

923
00:45:03,840 --> 00:45:05,250
искате получателят да получи.

924
00:45:05,250 --> 00:45:07,405
И дори, ако някой в
средна, която получава прекалено,

925
00:45:07,405 --> 00:45:09,780
не ги искат да
е задължително да бъде в състояние да го разшифровате,

926
00:45:09,780 --> 00:45:12,840
защото вътре в този
черна кутия, или алгоритъм,

927
00:45:12,840 --> 00:45:17,650
е някакъв механизъм, някои стъпка по стъпка
инструкции, за вземане на този вход

928
00:45:17,650 --> 00:45:20,710
и превръщането му в
изход, в надявам се по сигурен начин.

929
00:45:20,710 --> 00:45:23,640
>> И, всъщност, има някои
лексика в този свят, както следва.

930
00:45:23,640 --> 00:45:26,100
Обикновен текст е дума
компютърен учен би

931
00:45:26,100 --> 00:45:28,449
използва, за да опише на входа
съобщение, като англичаните

932
00:45:28,449 --> 00:45:31,240
или каквото и да език всъщност
искате да изпратите на някой друг човек.

933
00:45:31,240 --> 00:45:35,450
И тогава ciphertext е надпреварата
до кодирана, или криптирани,

934
00:45:35,450 --> 00:45:36,520
версия за това.

935
00:45:36,520 --> 00:45:38,750
>> Но има и една друга съставка тук.

936
00:45:38,750 --> 00:45:43,200
Има един друг вход, за да
таен ключ криптография.

937
00:45:43,200 --> 00:45:45,200
И това е самият ключ,
което е, обикновено,

938
00:45:45,200 --> 00:45:48,930
както ще видим, номер, или
писмо, или дума, каквото

939
00:45:48,930 --> 00:45:51,980
алгоритъм е всъщност очаква.

940
00:45:51,980 --> 00:45:53,870
>> И как да декриптира информация?

941
00:45:53,870 --> 00:45:55,110
Как да го разшифровам?

942
00:45:55,110 --> 00:45:57,950
Е, ти просто се обърне
изходи и входове.

943
00:45:57,950 --> 00:46:00,900
>> С други думи, след като някой
получава вашата криптирани съобщения,

944
00:46:00,900 --> 00:46:03,740
той или тя просто има
да се знае, че един и същ ключ.

945
00:46:03,740 --> 00:46:05,700
Те са получили ciphertext.

946
00:46:05,700 --> 00:46:09,530
И като включите тези две
вложения в системата на крипто,

947
00:46:09,530 --> 00:46:14,260
алгоритъма, тази черна кутия, изложени
трябва да дойде оригиналния прав текст.

948
00:46:14,260 --> 00:46:17,830
И така, това е много високо ниво
Предвид на това, което криптография е всъщност

949
00:46:17,830 --> 00:46:18,590
всичко за.

950
00:46:18,590 --> 00:46:20,030
>> Така че нека да стигнем до там.

951
00:46:20,030 --> 00:46:22,700
Нека сега да разгледаме под
капака на нещо

952
00:46:22,700 --> 00:46:26,000
ние сме били като за даденост, за
изминалата седмица, и за тази сесия

953
00:46:26,000 --> 00:46:27,629
here-- низа.

954
00:46:27,629 --> 00:46:30,295
Низ в края на деня
е просто поредица от символи.

955
00:46:30,295 --> 00:46:33,610
>> То може да бъде здравей свят, или
здравей Zamyla, или каквото.

956
00:46:33,610 --> 00:46:37,050
Но какво означава това за
да бъде последователност от символи?

957
00:46:37,050 --> 00:46:41,520
В действителност, библиотеката CS50 дава
ни един тип данни, наречен низ.

958
00:46:41,520 --> 00:46:45,140
>> Но там е всъщност не
такова нещо като низ в C.

959
00:46:45,140 --> 00:46:49,450
Това наистина е просто поредица от
характер, характер, характер,

960
00:46:49,450 --> 00:46:52,180
характер, обратно, за да архивирате, да
обратно, за да архивирате, за да направите резервно вътре

961
00:46:52,180 --> 00:46:54,650
от паметта на компютъра, или RAM.

962
00:46:54,650 --> 00:46:58,940
И ние ще разгледаме по-дълбоко в това, че в
бъдеще, когато се вгледаме в себе си памет,

963
00:46:58,940 --> 00:47:02,030
и оползотворяването и
заплахи, които са включени.

964
00:47:02,030 --> 00:47:04,100
>> Но нека разгледаме низа Zamyla.

965
00:47:04,100 --> 00:47:07,480
Така че просто името на
човекът тук, Zamyla,

966
00:47:07,480 --> 00:47:12,030
че е последователност от
символи, Z-A-М-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
А сега нека да предположим, че името Zamyla на
се съхранява вътре в компютър

968
00:47:16,020 --> 00:47:16,880
програма.

969
00:47:16,880 --> 00:47:20,830
>> Е, очевидно е, че ние трябва да
да е в състояние да погледнете тези символи

970
00:47:20,830 --> 00:47:21,590
индивидуално.

971
00:47:21,590 --> 00:47:24,710
Така че аз съм просто ще направи малко
каре около името Zamyla тук.

972
00:47:24,710 --> 00:47:31,580
И това е така в C, че когато
има низ, като Zamyla-- и може би

973
00:47:31,580 --> 00:47:34,940
че низ се е върнал от
функция като GET низ,

974
00:47:34,940 --> 00:47:38,540
всъщност може да се манипулира
то знак по знак.

975
00:47:38,540 --> 00:47:42,070
>> Сега, това е уместен за
разговор в ръка, защото

976
00:47:42,070 --> 00:47:46,420
в криптографията, ако искате да се промени
А към Б и В на С и С до D,

977
00:47:46,420 --> 00:47:49,650
и така нататък, което трябва да бъде в състояние
да разгледаме отделните герои

978
00:47:49,650 --> 00:47:50,190
в низ.

979
00:47:50,190 --> 00:47:52,695
Трябва да бъде в състояние да се промени
на Z към нещо друго, А

980
00:47:52,695 --> 00:47:55,280
за нещо друго, на м
нещо друго, и така нататък.

981
00:47:55,280 --> 00:47:58,000
И така, ние се нуждаем от по начин,
програмно, така

982
00:47:58,000 --> 00:48:03,020
да се каже, в C, за да може да се промени
и погледнете в отделни писма.

983
00:48:03,020 --> 00:48:05,690
И ние можем да направим това, както следва.

984
00:48:05,690 --> 00:48:08,340
>> Оставете ме да се насочват обратно в CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
И нека да вървим напред
и да се създаде нов файл

986
00:48:11,130 --> 00:48:16,134
че ще се обадя този път string0,
като първата ни като например точка, гр.

987
00:48:16,134 --> 00:48:18,300
И аз ще отида напред
и го привличам, както следва.

988
00:48:18,300 --> 00:48:22,870
>> Така че да включва CS50.h, и
След това включва стандартен io.h,

989
00:48:22,870 --> 00:48:25,990
което аз съм почти винаги ще
да бъде използване в моите програми, най-малко

990
00:48:25,990 --> 00:48:26,780
първоначално.

991
00:48:26,780 --> 00:48:32,180
INT главната нищожен, а след това в тук съм
ще направим струни получава получите низ.

992
00:48:32,180 --> 00:48:35,260
И тогава аз ще
давай напред и да направим това.

993
00:48:35,260 --> 00:48:37,460
Искам да отида напред
и, като проверка на здрав разум,

994
00:48:37,460 --> 00:48:43,607
само да кажа, здравей, процента ите,
точка и запетая, прави низ 0.

995
00:48:43,607 --> 00:48:44,690
Ъъъ, това, което съм направил тук?

996
00:48:44,690 --> 00:48:45,930
О, аз не го включите.

997
00:48:45,930 --> 00:48:48,120
Така урок научих, че
не беше умишлено.

998
00:48:48,120 --> 00:48:52,480
>> Така че грешка, повече процента
реализации, отколкото аргументи данни.

999
00:48:52,480 --> 00:48:54,940
И това е мястото, където, в
Онлайн 7-- ОК, така че аз нямам,

1000
00:48:54,940 --> 00:48:56,690
цитат цитата, че е
низ ми да ФОРМАТ.

1001
00:48:56,690 --> 00:48:58,151
Имам един знак за процент.

1002
00:48:58,151 --> 00:48:59,650
Но аз съм липсва втория аргумент.

1003
00:48:59,650 --> 00:49:03,190
>> Аз съм липсва запетая S, който
Аз нямаше в предишните примери.

1004
00:49:03,190 --> 00:49:06,650
Така че по-добра възможност да се определи
още една грешка, случайно.

1005
00:49:06,650 --> 00:49:09,950
А сега нека да тече
string0, тип в Zamyla.

1006
00:49:09,950 --> 00:49:10,970
ОК, здравей Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Така че ние сме тече този вид програма
няколко различни времена сега.

1008
00:49:14,144 --> 00:49:16,310
Но нека да се направи нещо по-
малко по-различно този път.

1009
00:49:16,310 --> 00:49:19,450
Вместо просто да печатате Zamyla на
Цялата име с ФОРМАТ,

1010
00:49:19,450 --> 00:49:21,350
нека го направим знак по знак.

1011
00:49:21,350 --> 00:49:22,700
>> Отивам да се използва за линия.

1012
00:49:22,700 --> 00:49:26,160
И аз ще се предам
променлива броене, наречена I.

1013
00:49:26,160 --> 00:49:33,530
И аз ще се запази следващите стъпки, така че
стига да е по-малка от дължината на S.

1014
00:49:33,530 --> 00:49:35,930
>> Оказва се, че не е направил
направим това последно време,

1015
00:49:35,930 --> 00:49:39,100
че в идва с
функция, наречена Стърлинг.

1016
00:49:39,100 --> 00:49:42,690
Обратно, в деня, и като цяло
още при изпълнението на функции,

1017
00:49:42,690 --> 00:49:45,405
хората често ще избират много
кратки имена, че вид на звук

1018
00:49:45,405 --> 00:49:48,280
като това, което искате, въпреки че е
липсват няколко гласни или букви.

1019
00:49:48,280 --> 00:49:50,660
Така Stirling е
име на функция, която

1020
00:49:50,660 --> 00:49:53,880
приема аргумент между
скоби, които трябва да бъдат низ.

1021
00:49:53,880 --> 00:49:56,910
И то просто се връща цяло число,
Продължителността на този низ.

1022
00:49:56,910 --> 00:50:00,580
>> Така че това за линия по линия 7 се случва
да започне преброяване на I е равна на 0.

1023
00:50:00,580 --> 00:50:02,530
Това ще увеличите
и на всяка итерация

1024
00:50:02,530 --> 00:50:04,350
от 1, тъй като ние сме били прави няколко пъти.

1025
00:50:04,350 --> 00:50:06,780
Но това се случва само правя
това, докато точката

1026
00:50:06,780 --> 00:50:09,660
когато е дължината
на самия низ.

1027
00:50:09,660 --> 00:50:14,520
>> Така че това е начин да се, в крайна сметка,
итерации над героите

1028
00:50:14,520 --> 00:50:17,430
в низа като Е. следва.

1029
00:50:17,430 --> 00:50:20,670
Отивам да разпечатате не
целият низ, но процента в,

1030
00:50:20,670 --> 00:50:22,860
един символ
последвано от нов ред.

1031
00:50:22,860 --> 00:50:24,880
И тогава аз ще
давай, и имам нужда

1032
00:50:24,880 --> 00:50:29,080
да кажем, че искате да отпечатате
Ith характер на лидер.

1033
00:50:29,080 --> 00:50:33,450
>> Така че, ако аз е променлива, която показва,
индекса на низа, където

1034
00:50:33,450 --> 00:50:37,230
Вие сте в това, че трябва да бъде в състояние да
се каже, дай ми Ith характер на лидер.

1035
00:50:37,230 --> 00:50:40,390
И в има начин за правене
това с квадратни скоби.

1036
00:50:40,390 --> 00:50:43,679
Можете просто да каже името на
низ, който в този случай е лидер.

1037
00:50:43,679 --> 00:50:46,970
След това можете да използвате квадратни скоби, които са
Обикновено точно над вашия Return или Enter

1038
00:50:46,970 --> 00:50:48,110
клавиш от клавиатурата.

1039
00:50:48,110 --> 00:50:52,410
И тогава ще ви постави на индекса на
характер, които искате да отпечатате.

1040
00:50:52,410 --> 00:50:55,960
Така че индексът ще бъде
number-- 0, или 1, или 2, или 3, или точка,

1041
00:50:55,960 --> 00:50:57,590
точка, DOT, някакъв друг номер.

1042
00:50:57,590 --> 00:51:00,920
>> И ние се гарантира, че това ще
е правилният номер, защото аз

1043
00:51:00,920 --> 00:51:02,360
започне броенето при 0.

1044
00:51:02,360 --> 00:51:07,020
И по подразбиране, първият знак
в низ по условие е 0.

1045
00:51:07,020 --> 00:51:09,230
И вторият символ е скоба 1.

1046
00:51:09,230 --> 00:51:11,120
И третият знак е скоба 2.

1047
00:51:11,120 --> 00:51:13,630
А вие не искате да отидете твърде
до момента, но ние ще не защото ние сме

1048
00:51:13,630 --> 00:51:17,780
Ще увеличим аз само докато го
е равна на дължината на низа.

1049
00:51:17,780 --> 00:51:20,210
И в този момент,
това за цикъл ще спре.

1050
00:51:20,210 --> 00:51:25,550
>> Така че нека да вървим напред и да спаси това
програма, и тичам да низ 0.

1051
00:51:25,550 --> 00:51:28,400
Но аз прецаках.

1052
00:51:28,400 --> 00:51:35,390
Безусловно обявяване библиотека функция
Стърлинг с тип като и such-- сега,

1053
00:51:35,390 --> 00:51:36,430
това звучи познато.

1054
00:51:36,430 --> 00:51:37,440
Но това не е ФОРМАТ.

1055
00:51:37,440 --> 00:51:38,540
И това не е получите низ.

1056
00:51:38,540 --> 00:51:40,480
>> Аз не се притеснявам в
по същия начин, този път.

1057
00:51:40,480 --> 00:51:45,100
Но забележете тук малко надолу
допълнително, включва заглавна string.h,

1058
00:51:45,100 --> 00:51:47,210
изрично предоставя на
декларация за Стърлинг.

1059
00:51:47,210 --> 00:51:48,820
Така че там всъщност е улика в там.

1060
00:51:48,820 --> 00:51:51,670
>> И наистина се оказва,
има и друг файл заглавието

1061
00:51:51,670 --> 00:51:53,970
че ние не сме използвали
в клас все още, но това е

1062
00:51:53,970 --> 00:51:56,480
измежду наличните
за вас, наречен string.h.

1063
00:51:56,480 --> 00:52:00,930
И в този файл, string.h
е Stirling обявена.

1064
00:52:00,930 --> 00:52:05,220
Така че нека да вървим напред и да
освен това, да низ

1065
00:52:05,220 --> 00:52:08,040
0-- хубаво, няма съобщения за грешки и този път.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, и
Аз съм на път да удари Enter,

1067
00:52:12,290 --> 00:52:16,710
в който момент getstring се случва
да се върне низа, слага се в с.

1068
00:52:16,710 --> 00:52:21,890
След това в продължение на линия ще обхождане
над знака S е един по един,

1069
00:52:21,890 --> 00:52:28,420
и да ги отпечатате по един на ред, защото
Имах че наклонена черта н в края.

1070
00:52:28,420 --> 00:52:34,530
Така че може да се пропусне, че наклонена черта
п, и след това просто да отпечатате Zamyla всички

1071
00:52:34,530 --> 00:52:37,460
в една и съща линия,
ефективно reimplementing

1072
00:52:37,460 --> 00:52:38,999
ФОРМАТ, което не е всичко, което полезно.

1073
00:52:38,999 --> 00:52:40,540
Но в този случай, аз не съм направил това.

1074
00:52:40,540 --> 00:52:43,610
Аз всъщност отпечатан един
характер в даден момент, по един на ред,

1075
00:52:43,610 --> 00:52:45,400
така че да можем действително да видите ефекта.

1076
00:52:45,400 --> 00:52:46,900
>> Но трябва да се отбележи едно нещо тук.

1077
00:52:46,900 --> 00:52:48,930
И ние ще се върнем към
това в бъдеще седмица.

1078
00:52:48,930 --> 00:52:52,650
Оказва се, че този
код е потенциално бъги.

1079
00:52:52,650 --> 00:52:56,560
>> Оказва се, че GET низ
и някои други функции в живота

1080
00:52:56,560 --> 00:53:00,280
Не е задължително винаги
се върне това, което очаквах.

1081
00:53:00,280 --> 00:53:03,010
Знаем от клас последно
време в това, че се

1082
00:53:03,010 --> 00:53:04,960
низ е трябвало да се върне низ.

1083
00:53:04,960 --> 00:53:09,900
Но какво, ако видовете потребителски такива
Дълго дума, или параграф, или есе

1084
00:53:09,900 --> 00:53:13,010
че там просто не е достатъчно
памет в компютъра, за да се побере.

1085
00:53:13,010 --> 00:53:15,410
>> Подобно на това, което, ако нещо се
погрешно под капака?

1086
00:53:15,410 --> 00:53:18,400
Тя може и да не се случва често,
но това може да се случи веднъж

1087
00:53:18,400 --> 00:53:21,520
от време на време, много рядко.

1088
00:53:21,520 --> 00:53:25,460
И така се оказва, че GET низ
и функции като това не е задължително

1089
00:53:25,460 --> 00:53:26,380
винаги се върне струни.

1090
00:53:26,380 --> 00:53:30,680
Те биха могли да се върнат някои стойност на грешката,
някои страж стойност така да се каже,

1091
00:53:30,680 --> 00:53:32,612
които показват, че
нещо не е наред.

1092
00:53:32,612 --> 00:53:35,320
И вие ще знаете само това от
които са го научили в клас сега,

1093
00:53:35,320 --> 00:53:37,700
или след като прочетох някои повече документация.

1094
00:53:37,700 --> 00:53:43,120
Оказва се, че GET низ
може да върне стойност, наречена нулев.

1095
00:53:43,120 --> 00:53:46,220
Null е специална стойност, която ние ще
да се върне в бъдещ седмица.

1096
00:53:46,220 --> 00:53:50,420
Но за сега, просто знам, че ако искам
да бъде наистина правилно в движение напред

1097
00:53:50,420 --> 00:53:52,650
използване GET низ, I
Не трябва просто да го наричаме,

1098
00:53:52,650 --> 00:53:56,870
и сляпо използва неговото връщане стойност,
доверявайки се, че това е един низ.

1099
00:53:56,870 --> 00:53:59,420
>> Аз трябва първо да кажа,
Ей, чакай малко, само

1100
00:53:59,420 --> 00:54:03,380
процедира, ако и не е равно
нищожна, където нула, отново,

1101
00:54:03,380 --> 00:54:04,660
е просто някаква особена стойност.

1102
00:54:04,660 --> 00:54:07,770
И това е единственият специален стойността, която
нужда да се притеснявате за за GET низ.

1103
00:54:07,770 --> 00:54:10,900
Вземете низ е или ще
да се върне низ или нула.

1104
00:54:10,900 --> 00:54:17,219
>> И този удивителен знак знак за равенство
може би знаете от може би клас по математика

1105
00:54:17,219 --> 00:54:20,510
че може да се направи знак за равенство с
линия през него за да покаже, не е равно.

1106
00:54:20,510 --> 00:54:23,135
Това не е обикновено символ
можете да въведете на клавиатурата.

1107
00:54:23,135 --> 00:54:26,480
И така, в повечето езици за програмиране,
когато искате да се каже, не е равна,

1108
00:54:26,480 --> 00:54:29,160
използвате удивителен знак,
иначе известни като взрив.

1109
00:54:29,160 --> 00:54:33,180
Значи вие казвате взрив е равен, което
означава не е равно, логично.

1110
00:54:33,180 --> 00:54:38,060
Това е точно като там не е по-голям
от, или равна на или по-малко от

1111
00:54:38,060 --> 00:54:41,270
или равен на клавиатурата си
че прави всичко това в един символ.

1112
00:54:41,270 --> 00:54:44,020
Така че това е защо, в последните примери,
нали отворена скоба, и след това

1113
00:54:44,020 --> 00:54:48,670
знак за равенство, за да се направи
по-голяма от или, да речем, по-малко от.

1114
00:54:48,670 --> 00:54:49,910
>> Така че това, което е храна за вкъщи тук?

1115
00:54:49,910 --> 00:54:53,880
Това е просто начин сега на
въвеждане на този синтаксис, тази функция,

1116
00:54:53,880 --> 00:54:57,390
итерации върху индивидуалното
знаци в низ.

1117
00:54:57,390 --> 00:55:00,260
И точно като тези, квадратна
скоби позволяват да се получи при тях,

1118
00:55:00,260 --> 00:55:03,790
разгледа тези квадратни скоби като
вид натъртва на този базов

1119
00:55:03,790 --> 00:55:06,040
дизайн, при който всеки
характер вътре в низ

1120
00:55:06,040 --> 00:55:10,180
е вид опаковка в някъде отдолу
качулката в паметта на компютъра ви.

1121
00:55:10,180 --> 00:55:12,340
>> Но нека да направим един вариант на това.

1122
00:55:12,340 --> 00:55:14,880
Оказва се, че този
програма е правилна.

1123
00:55:14,880 --> 00:55:18,810
Така че на оси CS50 за оценяване
код, това е вярно сега.

1124
00:55:18,810 --> 00:55:22,959
Особено сега, че аз съм проверка за
нула, тази програма не трябва никога да се срине.

1125
00:55:22,959 --> 00:55:24,500
И аз просто знам, че от опит.

1126
00:55:24,500 --> 00:55:28,040
Но няма нищо друго, което
ние наистина може да се обърка тук.

1127
00:55:28,040 --> 00:55:31,860
Но това не е много добре проектирана,
защото нека се върнем към основите.

1128
00:55:31,860 --> 00:55:34,450
>> Първо, principles--
какво прави за контур направя?

1129
00:55:34,450 --> 00:55:36,290
А за контур прави три неща.

1130
00:55:36,290 --> 00:55:39,340
Той инициализира някои
стойност, ако го помоля да.

1131
00:55:39,340 --> 00:55:41,770
Тя проверява състояние.

1132
00:55:41,770 --> 00:55:45,380
И след това, след всеки
итерация, след всеки цикъл,

1133
00:55:45,380 --> 00:55:49,330
да увеличи стойноста на някои
стойност, или ценности, тук.

1134
00:55:49,330 --> 00:55:50,600
>> И така, какво означава това?

1135
00:55:50,600 --> 00:55:52,940
Ние се инициализира аз до 0.

1136
00:55:52,940 --> 00:55:58,610
Ние проверяваме и се уверете, че аз е по-малко от
дължината на S, което е Z-A-М-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
така, което е по-малко от 6.

1138
00:55:59,900 --> 00:56:02,590
И наистина, 0 като по-малко от 6.

1139
00:56:02,590 --> 00:56:05,580
>> Ние разпечатате Z от името Zamyla му.

1140
00:56:05,580 --> 00:56:08,080
След това ние увеличаваме и 0-1.

1141
00:56:08,080 --> 00:56:11,290
Ние след това се провери, е 1 по-малко
от дължината на S?

1142
00:56:11,290 --> 00:56:13,270
Дължината на S е 6.

1143
00:56:13,270 --> 00:56:13,950
Да, така е.

1144
00:56:13,950 --> 00:56:16,880
>> Така че ние отпечата в името Zamyla е, ZA.

1145
00:56:16,880 --> 00:56:20,090
Ние нарастване и от 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Ние след това се провери, е 2 по-малко от
дължината на името Zamyla му.

1147
00:56:23,720 --> 00:56:25,380
6- така 2 е по-малко от 6.

1148
00:56:25,380 --> 00:56:30,460
Да, нека да разпечатате сега M в
име Zamyla му, третият знак.

1149
00:56:30,460 --> 00:56:34,110
>> Ключът тук е, че на всяка
повторение на историята, аз съм проверка,

1150
00:56:34,110 --> 00:56:37,810
е аз по-малко от дължината на Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Но уловката е, че
Стърлинг не е собственост.

1152
00:56:40,350 --> 00:56:43,100
Тези от вас, които са програмирани
преди в Java или други езици

1153
00:56:43,100 --> 00:56:46,310
може да знае дължината на низ е
имот, само някои само за четене стойност.

1154
00:56:46,310 --> 00:56:50,220
>> В С В този случай, ако това е
функция, която е буквално

1155
00:56:50,220 --> 00:56:53,520
преброяване на броя на
символи в Zamyla всеки път

1156
00:56:53,520 --> 00:56:54,740
ние наричаме тази функция.

1157
00:56:54,740 --> 00:56:58,500
Всеки път, когато поиска от компютъра, за да използвате
Стърлинг, това е като погледнете Zamyla,

1158
00:56:58,500 --> 00:57:01,960
и каза: Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
И тя се връща 6.

1160
00:57:02,962 --> 00:57:04,920
Следващият път, когато се обадя
то вътре, че за контур,

1161
00:57:04,920 --> 00:57:08,610
това ще разгледаме Zamyla
отново, казват Z-A-М-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
И това се случва, за да се върне 6.

1163
00:57:10,320 --> 00:57:12,980
Така че това, което е глупаво за този проект?

1164
00:57:12,980 --> 00:57:17,700
>> Защо е моя код не на 5 от 5
за проектиране точно сега, така да се каже?

1165
00:57:17,700 --> 00:57:20,600
Е, аз питам
въпрос ненужно.

1166
00:57:20,600 --> 00:57:23,030
Правя повече работа, отколкото имам нужда да.

1167
00:57:23,030 --> 00:57:25,370
>> Така че, въпреки че
отговор е правилен, аз съм

1168
00:57:25,370 --> 00:57:29,560
иска компютъра, това, което е
дължината на Zamyla отново,

1169
00:57:29,560 --> 00:57:31,380
и отново и отново и отново?

1170
00:57:31,380 --> 00:57:33,980
И този отговор е
никога няма да се промени.

1171
00:57:33,980 --> 00:57:35,900
Тя винаги ще бъде 6.

1172
00:57:35,900 --> 00:57:39,730
>> Така че по-добро решение от това
би било това следващата версия.

1173
00:57:39,730 --> 00:57:43,390
Нека да вървим напред и да го постави в
отделен файл, наречен string1.c,

1174
00:57:43,390 --> 00:57:44,990
просто за да го разделят.

1175
00:57:44,990 --> 00:57:47,260
И се оказва, в за
контур, всъщност можете да

1176
00:57:47,260 --> 00:57:50,210
Декларирам, множество променливи наведнъж.

1177
00:57:50,210 --> 00:57:53,460
>> Така че аз ще държа аз и тя трябва да е 0.

1178
00:57:53,460 --> 00:57:56,190
Но аз също отивам да
добавите запетая, и да кажа,

1179
00:57:56,190 --> 00:58:01,050
дайте ми една променлива, наречена N, чиято
стойност е равна на дължината низ от с.

1180
00:58:01,050 --> 00:58:09,410
И сега, моля, направете състоянието ми
толкова дълго, колкото мога по-малко от п.

1181
00:58:09,410 --> 00:58:14,140
>> Така по този начин, логиката е
идентичен в края на деня.

1182
00:58:14,140 --> 00:58:18,280
Но аз съм си спомни
стойност 6, в този случай.

1183
00:58:18,280 --> 00:58:19,780
Каква е продължителността на име Zamyla е?

1184
00:58:19,780 --> 00:58:20,860
И аз съм го поставя в п.

1185
00:58:20,860 --> 00:58:23,050
>> И аз съм все още проверка
състоянието всеки път.

1186
00:58:23,050 --> 00:58:24,300
Е 0 по-малко от 6?

1187
00:58:24,300 --> 00:58:25,600
Е 1 по-малко от 6?

1188
00:58:25,600 --> 00:58:28,600
Е 2 по-малко от 6, и така нататък?

1189
00:58:28,600 --> 00:58:31,914
>> Но аз не съм иска компютъра
отново, и отново, това, което е

1190
00:58:31,914 --> 00:58:33,080
дължината на името Zamyla е?

1191
00:58:33,080 --> 00:58:34,320
Каква е продължителността на име Zamyla е?

1192
00:58:34,320 --> 00:58:35,986
Каква е дължината на името на този Zamyla е?

1193
00:58:35,986 --> 00:58:40,440
Аз буквално се забравя, че първата и
отговоря само в тази втора променлива п.

1194
00:58:40,440 --> 00:58:45,280
Така че това вече ще бъде не само
правилно, но и добре проектирана.

1195
00:58:45,280 --> 00:58:46,670
>> Сега, какво да кажем за стил?

1196
00:58:46,670 --> 00:58:48,866
Аз съм кръстен моите променливи
доста добре, бих казал.

1197
00:58:48,866 --> 00:58:50,240
Те са супер стегнато точно сега.

1198
00:58:50,240 --> 00:58:52,090
И това е напълно наред.

1199
00:58:52,090 --> 00:58:55,120
>> Ако имате само един
низ в една програма,

1200
00:58:55,120 --> 00:58:56,860
може би, както го наричат ​​е за низ.

1201
00:58:56,860 --> 00:58:59,370
Ако имате само една променлива
за броене в програма,

1202
00:58:59,370 --> 00:59:00,710
че може и да го наричаме аз.

1203
00:59:00,710 --> 00:59:03,500
Ако имате дължина, п
е супер общ, както добре.

1204
00:59:03,500 --> 00:59:05,800
Но аз не съм коментира някой от моя код.

1205
00:59:05,800 --> 00:59:09,200
>> Аз не съм информиран за reader--
дали това е моят TF, или TA,

1206
00:59:09,200 --> 00:59:12,460
или просто colleague-- това, което се предполага, че
да се случва в тази програма.

1207
00:59:12,460 --> 00:59:15,760
И така, за да се получи добър стил,
това, което аз ще искам да направя

1208
00:59:15,760 --> 00:59:24,580
е this-- нещо
като питам потребител за вход.

1209
00:59:24,580 --> 00:59:26,670
И аз може да се пренапише
това всяка редица начини.

1210
00:59:26,670 --> 00:59:35,630
>> Уверете се, че s-- направи сигурни, GET
низ се връща низ.

1211
00:59:35,630 --> 00:59:40,280
И тогава в here-- и това е може би
най-важният comment-- обхождане

1212
00:59:40,280 --> 00:59:44,450
над героите в и един по един.

1213
00:59:44,450 --> 00:59:47,060
И аз може да използва всеки
избор на английски език

1214
00:59:47,060 --> 00:59:49,650
тук, за да опише всеки
на тези парчета код.

1215
00:59:49,650 --> 00:59:52,740
>> Забележете, че не съм се сложи
коментирам всеки ред код,

1216
00:59:52,740 --> 00:59:55,690
наистина само по-интересните
такива, тези, които

1217
00:59:55,690 --> 00:59:59,460
има някакъв смисъл, че бих могъл
искаме да направим супер ясно на някой

1218
00:59:59,460 --> 01:00:00,460
четене моя код.

1219
01:00:00,460 --> 01:00:02,920
И защо се обаждаш получите
низ попитам потребител за вход?

1220
01:00:02,920 --> 01:00:05,450
Дори, че човек не е задължително
всичко, което описателно.

1221
01:00:05,450 --> 01:00:09,340
Но тя помага разкажа една история, понеже
втора линия в историята е, уверете се,

1222
01:00:09,340 --> 01:00:10,740
получите низ се връща низ.

1223
01:00:10,740 --> 01:00:14,260
>> И на третия ред в историята е,
обхождане на героите в а един

1224
01:00:14,260 --> 01:00:15,380
на време.

1225
01:00:15,380 --> 01:00:17,920
И сега просто за добра мярка,
Отивам да вървим напред и да добавите

1226
01:00:17,920 --> 01:00:24,560
още един коментар, който току-що
казва печат-тото характер в с.

1227
01:00:24,560 --> 01:00:26,520
Сега, това, което съм направил
в края на деня?

1228
01:00:26,520 --> 01:00:29,190
>> Имам добавят някои английски
думи под формата на коментари.

1229
01:00:29,190 --> 01:00:32,700
Символът на наклонена черта черта означава, хей,
компютър, това е за човека,

1230
01:00:32,700 --> 01:00:33,820
не за вас, на компютъра.

1231
01:00:33,820 --> 01:00:35,119
Така че те са игнорирани логично.

1232
01:00:35,119 --> 01:00:35,910
Те са просто там.

1233
01:00:35,910 --> 01:00:39,830
>> И наистина, CS50 IDE ги показва като
сиво, като полезни, но не основен

1234
01:00:39,830 --> 01:00:41,000
на програмата.

1235
01:00:41,000 --> 01:00:42,570
Забележете, това, което сега можете да направите.

1236
01:00:42,570 --> 01:00:44,950
Дали знаете C
програмиране или не, вие

1237
01:00:44,950 --> 01:00:47,722
може просто да стоя назад в тази
програма, и обезмаслено коментарите.

1238
01:00:47,722 --> 01:00:50,180
Попитайте потребител за вход, се уверете,
получите низ се връща низ,

1239
01:00:50,180 --> 01:00:53,009
обхождане на героите в S
един по един, отпечатване на характера

1240
01:00:53,009 --> 01:00:55,550
-тото характер в s-- не го направите
дори трябва да погледнете кода

1241
01:00:55,550 --> 01:00:57,270
да се разбере това, което прави тази програма.

1242
01:00:57,270 --> 01:01:00,280
И, още по-добре, ако се погледне
по тази програма в една или две седмици,

1243
01:01:00,280 --> 01:01:02,280
или един месец, или една година,
вие също не разполагат с

1244
01:01:02,280 --> 01:01:04,420
да се взират в кода,
опитвайки се да си спомня,

1245
01:01:04,420 --> 01:01:06,630
какво е аз се опитвам да направя с този код?

1246
01:01:06,630 --> 01:01:07,770
>> Ти сам каза.

1247
01:01:07,770 --> 01:01:11,660
Ти го описва за себе си,
или някои колега, или TA, или TF.

1248
01:01:11,660 --> 01:01:14,860
И така, това вече би било
правилно, и добър дизайн,

1249
01:01:14,860 --> 01:01:18,210
и в крайна сметка добър стил, както добре.

1250
01:01:18,210 --> 01:01:19,990
Така правят имайте това предвид.

1251
01:01:19,990 --> 01:01:22,200
>> Така че има един друг
нещо, което аз ще направя тук

1252
01:01:22,200 --> 01:01:28,240
че сега може да разкрие какво точно е
става под предния капак.

1253
01:01:28,240 --> 01:01:30,390
Така че има тази функция
в C, и други езици,

1254
01:01:30,390 --> 01:01:33,010
наречен освободи от стереотипа
че или косвено

1255
01:01:33,010 --> 01:01:37,250
или изрично ви позволява да конвертирате
от един тип данни към друга.

1256
01:01:37,250 --> 01:01:39,800
Ние сме били, занимаващи така
Доколкото днес с низове.

1257
01:01:39,800 --> 01:01:41,250
>> И струни са герои.

1258
01:01:41,250 --> 01:01:44,910
Но припомни от седмица
0, какви са героите?

1259
01:01:44,910 --> 01:01:49,334
Знаците са само една абстракция
на върха на numbers-- десетични числа,

1260
01:01:49,334 --> 01:01:52,500
и десетични числа са наистина само един
абстракция на върха на двоични числа,

1261
01:01:52,500 --> 01:01:53,720
тъй като ние я определя.

1262
01:01:53,720 --> 01:01:55,540
>> Така че герои са числа.

1263
01:01:55,540 --> 01:01:58,410
И номера са герои,
само в зависимост от контекста.

1264
01:01:58,410 --> 01:02:01,250
И се оказва, че вътре
на компютърна програма,

1265
01:02:01,250 --> 01:02:06,830
може ли да посочите как искате да изглежда
в битовете на тази програма?

1266
01:02:06,830 --> 01:02:10,400
>> Спомнете си от седмица 0, че имахме
Ascii, който е само този код

1267
01:02:10,400 --> 01:02:11,620
картографиране писма до номера.

1268
01:02:11,620 --> 01:02:13,660
И ние казахме, капитали А е 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B е 66, и така нататък.

1270
01:02:15,860 --> 01:02:20,500
>> И известие, ние по същество има символа на
най-горния ред тук, тъй като C ще им се обадя,

1271
01:02:20,500 --> 01:02:23,400
символи, и след това
цели числа на втория ред.

1272
01:02:23,400 --> 01:02:28,180
И се оказва, можете да конвертирате
безпроблемно между двете, обикновено.

1273
01:02:28,180 --> 01:02:30,042
И ако искаме да направим
това нарочно, ние

1274
01:02:30,042 --> 01:02:31,750
Може би искате да се справи
нещо като това.

1275
01:02:31,750 --> 01:02:33,590
>> Ние може да искате да конвертирате
горния случай да се намали

1276
01:02:33,590 --> 01:02:35,330
случай, или малки букви в главни букви.

1277
01:02:35,330 --> 01:02:38,000
И се оказва, че има
всъщност един модел тук

1278
01:02:38,000 --> 01:02:39,900
ние можем да прегърнем в един момент.

1279
01:02:39,900 --> 01:02:44,120
Но нека да погледнем първо на по-
Пример за това прави изрично.

1280
01:02:44,120 --> 01:02:46,340
>> Отивам да се върне обратно в CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Отивам да се създаде
файл, наречен Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
И аз ще отида напред и да добавите ми
стандарт io.h в горната част, INT главната нищожно

1283
01:02:55,960 --> 01:02:57,370
в горната част на моята функция.

1284
01:02:57,370 --> 01:03:02,700
И тогава аз съм просто ще да направи
following-- а за линия от I е равен,

1285
01:03:02,700 --> 01:03:04,610
да речем, 65.

1286
01:03:04,610 --> 01:03:10,460
>> И тогава аз ще бъде по-малко от
65, плюс 26 букви в азбуката.

1287
01:03:10,460 --> 01:03:12,640
Така че аз ще позволи на компютъра
направи по математика за мен там.

1288
01:03:12,640 --> 01:03:15,100
И след това вътре в този цикъл,
това, което съм аз ще отпечата?

1289
01:03:15,100 --> 01:03:19,230
>> % В е и обратно наклонена черта н%.

1290
01:03:19,230 --> 01:03:21,290
И сега искам да се включите в две стойности.

1291
01:03:21,290 --> 01:03:24,530
Аз бях временно постави въпрос
бележи там, за да покани на въпроса.

1292
01:03:24,530 --> 01:03:29,940
>> Искам да обхождане от 65 нататък
в продължение на 26 букви от азбуката,

1293
01:03:29,940 --> 01:03:35,190
отпечатване на всяка итерация, че
неразделна еквивалентен характер.

1294
01:03:35,190 --> 01:03:38,299
С други думи, искам да
обхождане над 26 номера печат

1295
01:03:38,299 --> 01:03:41,590
какъв е характера Ascii, писмото,
и какво is-- съответния номер

1296
01:03:41,590 --> 01:03:44,650
наистина само пресъздаване
графиката от този слайд.

1297
01:03:44,650 --> 01:03:47,010
Така че това, което трябва да бъдат тези въпросителни знаци?

1298
01:03:47,010 --> 01:03:51,760
>> Е, оказва се, че вторият
човек трябва просто да бъде променлива аз.

1299
01:03:51,760 --> 01:03:53,860
Искам да видя, че като брой.

1300
01:03:53,860 --> 01:03:58,920
И средният аргумента
тук, мога да кажа на компютъра

1301
01:03:58,920 --> 01:04:03,470
за лечение на това число
аз като характер, така че

1302
01:04:03,470 --> 01:04:05,880
да го замени тук за процента В.

1303
01:04:05,880 --> 01:04:07,990
>> С други думи, ако Аз,
човешкото програмист, знам

1304
01:04:07,990 --> 01:04:09,865
това са само цифри
в края на деня.

1305
01:04:09,865 --> 01:04:12,500
И знам, че 65 трябва
Карта за някои характер.

1306
01:04:12,500 --> 01:04:15,310
С това изрично гласове,
с скоби,

1307
01:04:15,310 --> 01:04:18,840
Името на вида на данните, които искате да
трансформирате, и затворена скоба,

1308
01:04:18,840 --> 01:04:21,200
Можете да кажете на
компютър, хей, компютър,

1309
01:04:21,200 --> 01:04:24,130
превръщане на тази число на Чар.

1310
01:04:24,130 --> 01:04:26,250
>> Така че, когато аз тичам този
програма след съставянето,

1311
01:04:26,250 --> 01:04:29,740
нека да видим какво мога get-- направи Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Проклета го, какво съм направил погрешно тук?

1313
01:04:33,020 --> 01:04:35,884
Използването на недекларирания идентификатор,
Всичко е наред, не умишлено,

1314
01:04:35,884 --> 01:04:37,800
но нека да видим дали не можем
причина през тази.

1315
01:04:37,800 --> 01:04:41,220
>> Така линия five-- така че аз не се получи
много далеч преди да се издъних.

1316
01:04:41,220 --> 01:04:42,140
Това е добре.

1317
01:04:42,140 --> 01:04:46,560
Така линия 5 за аз се равнява 65-- виждам.

1318
01:04:46,560 --> 01:04:50,130
Така че не забравяйте, че в C, за разлика от някои
езици, ако имат предварително програмиране

1319
01:04:50,130 --> 01:04:52,190
опит, че имате
да каже на компютъра,

1320
01:04:52,190 --> 01:04:55,040
за разлика от нулата, това, което
тип променлива е то.

1321
01:04:55,040 --> 01:04:56,860
>> И аз забравих ключова фраза тук.

1322
01:04:56,860 --> 01:04:59,200
В съответствие пет, аз започнах да използвам аз.

1323
01:04:59,200 --> 01:05:01,560
Но аз не съм казал C
какви данни тип е тя.

1324
01:05:01,560 --> 01:05:04,570
Така че аз ще отида в тук и
се каже, ах, да я направи цяло число.

1325
01:05:04,570 --> 01:05:07,050
>> Сега аз ще отида напред и да прекомпилирате.

1326
01:05:07,050 --> 01:05:08,080
Това фиксира това.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, че е нещо готино.

1328
01:05:12,660 --> 01:05:15,360
Не само, че е супер бързо, за да
поиска от компютъра на този въпрос,

1329
01:05:15,360 --> 01:05:18,885
вместо да го погледна върху предметно стъкло,
той отпечатва по един на ред, А е 65,

1330
01:05:18,885 --> 01:05:24,860
B е 66, по целия път down-- откакто
Направихме това 26 times-- на писма Z,

1331
01:05:24,860 --> 01:05:25,630
което е 90.

1332
01:05:25,630 --> 01:05:27,790
И в действителност, леко
по интелигентен би

1333
01:05:27,790 --> 01:05:31,030
са били за мен да не се разчита
на компютъра, за да добавите 26.

1334
01:05:31,030 --> 01:05:34,060
Аз може просто да се направи
90, както и, доколкото

1335
01:05:34,060 --> 01:05:37,390
както аз не направи същата грешка два пъти.

1336
01:05:37,390 --> 01:05:41,880
Искам да отида през
Z, а не само нагоре през ш.

1337
01:05:41,880 --> 01:05:44,000
>> Така че това е изрично гласове.

1338
01:05:44,000 --> 01:05:47,860
Оказва се, че този
дори не е необходимо.

1339
01:05:47,860 --> 01:05:52,480
Нека да вървим напред и да преиграва това
компилатор, и разясняване Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Оказва се, че C е доста умен.

1341
01:05:54,940 --> 01:05:57,150
>> И ФОРМАТ, по-специално,
е доста умен.

1342
01:05:57,150 --> 01:06:01,260
Ако просто преминат аз два пъти
за двете контейнери, ФОРМАТ

1343
01:06:01,260 --> 01:06:04,510
ще осъзнае, ох, добре те познавам
ми даде една integer-- някои номер,

1344
01:06:04,510 --> 01:06:06,380
като 65, или 90, или нещо такова.

1345
01:06:06,380 --> 01:06:10,170
Но виждам, че ти искаш да
форматирате този номер като герой.

1346
01:06:10,170 --> 01:06:16,460
И така ФОРМАТ може имплицитно хвърли
на INT към Чар за вас, както и.

1347
01:06:16,460 --> 01:06:19,360
Така че това не е проблем на всички.

1348
01:06:19,360 --> 01:06:23,100
>> Но забележете, защото на тази еквивалентност
ние всъщност може да направите това, както добре.

1349
01:06:23,100 --> 01:06:26,520
Нека да вървим напред и да се направи една
друга версия на this-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
И вместо повтаряне над
числа, наистина могат да ви оставят без дъх

1351
01:06:31,800 --> 01:06:33,610
от итерации върху символа.

1352
01:06:33,610 --> 01:06:37,660
Ако Чар в получава капитал A, I
искаме да вървим напред и да направи това,

1353
01:06:37,660 --> 01:06:41,740
доколкото С е по-малко от или равно
до капитал Z. И на всяка итерация

1354
01:06:41,740 --> 01:06:45,690
Искам да увеличите C, което мога
Сега в моя ФОРМАТ линия тук

1355
01:06:45,690 --> 01:06:51,320
да речем, на сто C е
процента аз отново, запетая C.

1356
01:06:51,320 --> 01:06:57,200
>> И сега, мога да отида другата посока,
леене характера изрично

1357
01:06:57,200 --> 01:06:58,500
на цяло число.

1358
01:06:58,500 --> 01:07:00,560
Така че, отново, защо го направи това?

1359
01:07:00,560 --> 01:07:03,830
Това е малко странно да се справи с
брои по отношение на героите.

1360
01:07:03,830 --> 01:07:07,430
>> Но ако сте разбрали това, което е
става под капака на двигателя,

1361
01:07:07,430 --> 01:07:08,430
там наистина няма магия.

1362
01:07:08,430 --> 01:07:13,060
Ти си просто казвам, хей, компютър даде
ме променлива, наречена C от типа Чар.

1363
01:07:13,060 --> 01:07:16,520
тя се инициализира с капитал А. И
забележите единични кавички въпрос.

1364
01:07:16,520 --> 01:07:19,580
>> За герои в C, припомнят от
миналата седмица, вие използвате единични кавички.

1365
01:07:19,580 --> 01:07:23,720
За низове, думи,
фрази, които използвате двойни кавички.

1366
01:07:23,720 --> 01:07:27,210
ОК, компютър, продължаваш да правиш това, така че
Докато характер е по-малко от

1367
01:07:27,210 --> 01:07:28,050
или равна на Z.

1368
01:07:28,050 --> 01:07:32,640
И аз знам от моя Ascii маса, че всички
на тези ASCII кодове са съседни.

1369
01:07:32,640 --> 01:07:33,400
>> Има без пропуски.

1370
01:07:33,400 --> 01:07:36,737
Така че това е просто чрез Z,
разделени от един номер на всеки.

1371
01:07:36,737 --> 01:07:38,820
И тогава мога да увеличите
пепел, ако наистина искате.

1372
01:07:38,820 --> 01:07:40,390
В края на деня,
това е просто едно число.

1373
01:07:40,390 --> 01:07:41,030
Знам това.

1374
01:07:41,030 --> 01:07:43,670
Така че аз може просто да се предположи, за да добавите 1 към него.

1375
01:07:43,670 --> 01:07:46,940
>> И след това време, аз отпечата в,
и след това неразделна еквивалент.

1376
01:07:46,940 --> 01:07:50,170
А аз дори не е необходимо изричното гласове.

1377
01:07:50,170 --> 01:07:52,680
Аз да оставите ФОРМАТ и
компютър оправя нещата,

1378
01:07:52,680 --> 01:07:57,300
така че сега, ако аз тичам
направи Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Получавам точно същото нещо, както добре.

1380
01:08:01,520 --> 01:08:04,530
>> Безполезни програма, though-- никой
ще всъщност пишат софтуер

1381
01:08:04,530 --> 01:08:07,549
за да разбера, какво е било
номер, който съпоставя с A, или B, или Z?

1382
01:08:07,549 --> 01:08:10,340
Вие просто ще го в Google, или
го гледам онлайн, или го гледам

1383
01:08:10,340 --> 01:08:11,650
върху предметно стъкло, или други подобни.

1384
01:08:11,650 --> 01:08:13,520
Така че, когато се оказа получите полезна?

1385
01:08:13,520 --> 01:08:15,960
>> Е, като стана дума за това
слайд, забележите, че има

1386
01:08:15,960 --> 01:08:20,890
действителен модел тук между главни
и с малки букви, че не е случайно.

1387
01:08:20,890 --> 01:08:23,760
Забележете, че капитал А е 65.

1388
01:08:23,760 --> 01:08:25,830
Малки букви а е 97.

1389
01:08:25,830 --> 01:08:29,649
И колко далеч е по-ниска случай?

1390
01:08:29,649 --> 01:08:32,649
>> Така че 65 е колко крачки от 97?

1391
01:08:32,649 --> 01:08:36,210
Така 97 минус 65 е 32.

1392
01:08:36,210 --> 01:08:37,910
Така капитал на е 65.

1393
01:08:37,910 --> 01:08:39,939
Ако добавите 32 до това,
можете да получите малки букви а.

1394
01:08:39,939 --> 01:08:43,729
И, което е същото, ако извадим 32,
можете да се върнем към капитала A-- същото с B

1395
01:08:43,729 --> 01:08:46,380
за малко б, голям C до малко в.

1396
01:08:46,380 --> 01:08:50,670
>> Всички тези пропуски са 32 парчета.

1397
01:08:50,670 --> 01:08:54,450
Сега, това би било да ни позволи да
направя нещо като Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
или Google Docs разполагат, където можете
може да изберете всичко и след това казват,

1399
01:08:57,729 --> 01:09:00,520
промени всичко в малки букви, или
промени всичко в главни букви,

1400
01:09:00,520 --> 01:09:03,840
или променят само първата дума
на присъда до горния случай.

1401
01:09:03,840 --> 01:09:07,390
всъщност можем да направим нещо
като че самите себе си.

1402
01:09:07,390 --> 01:09:12,645
>> Нека да вървим напред и да запишете файл
тук се нарича възползва 0.c.

1403
01:09:12,645 --> 01:09:15,770
И да вървим напред и да привличам програма
че прави точно това, както следва.

1404
01:09:15,770 --> 01:09:18,460
Така че да включва CS50 библиотеката.

1405
01:09:18,460 --> 01:09:21,430
И включва стандартен I / O.

1406
01:09:21,430 --> 01:09:22,787
>> И знам, че това е скоро.

1407
01:09:22,787 --> 01:09:24,870
Така че аз ще го постави в
там вече, string.h,

1408
01:09:24,870 --> 01:09:26,960
така че да има достъп до
неща като Стърлинг,

1409
01:09:26,960 --> 01:09:29,620
и след това INT главната нищожно, както обикновено.

1410
01:09:29,620 --> 01:09:33,420
И тогава аз ще отида напред
и направи струни получава получите низ,

1411
01:09:33,420 --> 01:09:35,032
само за да получите низ от страна на потребителя.

1412
01:09:35,032 --> 01:09:36,740
И тогава аз ще
направя моя чек здрав разум.

1413
01:09:36,740 --> 01:09:40,510
Ако низ не прави равен нула,
след това, че е безопасно да се процедира.

1414
01:09:40,510 --> 01:09:42,000
И това, което искам да направя?

1415
01:09:42,000 --> 01:09:48,700
Отивам да обхождане от I е равна на 0,
и п до дължината низ от с.

1416
01:09:48,700 --> 01:09:51,899
>> И аз ще направя това толкова дълго, колкото е
аз е по-малко от п, и аз плюс плюс.

1417
01:09:51,899 --> 01:09:55,060
Досега аз съм наистина само
назаем идеи от преди.

1418
01:09:55,060 --> 01:09:57,010
И сега аз отивам да се въведе клон.

1419
01:09:57,010 --> 01:09:59,635
>> Така че мисля, обратно към нулата, където
имахме тези вилици в пътя,

1420
01:09:59,635 --> 01:10:05,110
и миналата седмица в C. Отивам да
Казвам това, ако аз-ти характер в S

1421
01:10:05,110 --> 01:10:09,250
е по-голяма от или
равно на по-ниски случай,

1422
01:10:09,250 --> 01:10:13,340
and-- в Scratch бихте буквално
се каже и, но в C, което казвате амперсанд,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- и аз-ти характер в S
е по-малко от или равно на малки букви Z,

1424
01:10:19,830 --> 01:10:21,780
нека да направим нещо интересно.

1425
01:10:21,780 --> 01:10:27,020
Нека всъщност отпечатате
характер, без нов ред

1426
01:10:27,020 --> 01:10:31,760
това е знак в низа,
-тото характер в низа.

1427
01:10:31,760 --> 01:10:37,420
>> Но нека да вървим напред и да
изважда 32 от него.

1428
01:10:37,420 --> 01:10:42,120
Иначе, ако героя в
низ, че ние не търсим

1429
01:10:42,120 --> 01:10:45,950
не е между малко по-
и малко по-Z, давай

1430
01:10:45,950 --> 01:10:48,610
и просто да го отпечата непроменен.

1431
01:10:48,610 --> 01:10:50,840
Така че ние въведохме
този скоби нотация

1432
01:10:50,840 --> 01:10:53,560
за нашите струни, за да получите най-
-тото характер в низа.

1433
01:10:53,560 --> 01:10:57,520
>> Добавих някои условно логика, като
Scratch в последната седмица на седмица един, където

1434
01:10:57,520 --> 01:10:59,880
Аз съм само с помощта на моя фундаментален
разбиране на това, което е

1435
01:10:59,880 --> 01:11:01,130
става под предния капак.

1436
01:11:01,130 --> 01:11:04,190
Е-тото характер на S
по-голяма от или равна на?

1437
01:11:04,190 --> 01:11:08,290
Подобно, е, че 97 или 98,
или 99, и така нататък?

1438
01:11:08,290 --> 01:11:11,940
>> Но също така е по-малко от или равно
към стойността на малки букви Z?

1439
01:11:11,940 --> 01:11:16,210
И ако е така, какво прави този ред означава?

1440
01:11:16,210 --> 01:11:20,250
14, това е нещо като
кълнове на цялата идея,

1441
01:11:20,250 --> 01:11:23,840
капитализира писмото от
просто изваждане 32 от него,

1442
01:11:23,840 --> 01:11:29,370
в този случай, защото знам, на които
диаграма, как са представени номера ми.

1443
01:11:29,370 --> 01:11:33,925
Така че нека да вървим напред и да стартирате тази,
след съставянето възползва 0.c,

1444
01:11:33,925 --> 01:11:36,210
и тичам възползва 0.

1445
01:11:36,210 --> 01:11:40,300
>> Нека напишете нещо подобно
Zamyla във всички малки букви влиза.

1446
01:11:40,300 --> 01:11:42,780
И сега имаме Zamyla във всички главни букви.

1447
01:11:42,780 --> 01:11:45,050
Нека да въведете Роб във всички малки букви.

1448
01:11:45,050 --> 01:11:46,674
Нека се опитаме Jason във всички малки букви.

1449
01:11:46,674 --> 01:11:48,590
И ние продължаваме получаване на
принудени капитализация.

1450
01:11:48,590 --> 01:11:50,960
Има малка грешка, която аз
вид не очаквахме.

1451
01:11:50,960 --> 01:11:54,050
Забележете новия ми бързо се завършва
на същата линия като имената им,

1452
01:11:54,050 --> 01:11:55,520
който се чувства малко разхвърлян.

1453
01:11:55,520 --> 01:11:59,170
>> Така че аз ще отида тук, и
всъщност в края на тази програма

1454
01:11:59,170 --> 01:12:02,110
разпечатате символ за нов ред.

1455
01:12:02,110 --> 01:12:03,160
Това е всичко.

1456
01:12:03,160 --> 01:12:06,120
С ФОРМАТ, че не е нужно да
премине в променливи или код формат.

1457
01:12:06,120 --> 01:12:08,460
Вие буквално може просто да отпечатате
нещо като нов ред.

1458
01:12:08,460 --> 01:12:13,529
>> Така че нека да вървим напред и да се направи
капитализира 0 отново, тя преиграва, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
И сега това е малко по-хубава.

1460
01:12:14,820 --> 01:12:17,274
Сега, моето бързо е по своя нов ред.

1461
01:12:17,274 --> 01:12:18,440
Така че всичко е наред и добра.

1462
01:12:18,440 --> 01:12:19,910
Така че това е един добър пример.

1463
01:12:19,910 --> 01:12:22,700
Но аз дори не е задължително
Трябва да твърди код на 32.

1464
01:12:22,700 --> 01:12:23,350
Знаеш ли какво?

1465
01:12:23,350 --> 01:12:26,350
Мога да say-- аз не всякога
помня каква е разликата.

1466
01:12:26,350 --> 01:12:29,330
>> Но аз знам, че ако съм
има малка буква,

1467
01:12:29,330 --> 01:12:34,430
Аз по същество иска да се изважда от
независимо от разстоянието е между малко

1468
01:12:34,430 --> 01:12:39,160
а и голяма A, защото ако се предположи, че
всички други букви са еднакви,

1469
01:12:39,160 --> 01:12:41,045
че трябва да се свърши работата.

1470
01:12:41,045 --> 01:12:42,670
Но вместо да направи това, знаеш ли какво?

1471
01:12:42,670 --> 01:12:44,240
Има и друг начин, все още.

1472
01:12:44,240 --> 01:12:48,090
>> Ако това е капитализира 1.c-- ако бях
да сложи това в отделен файл.

1473
01:12:48,090 --> 01:12:51,030
Нека да направим възползва 2.c както следва.

1474
01:12:51,030 --> 01:12:53,060
Отивам да наистина се чисти тази тук.

1475
01:12:53,060 --> 01:12:57,420
И вместо да дори да се налага да
знае или се грижи за тези, ниско ниво

1476
01:12:57,420 --> 01:13:01,090
детайли по изпълнението, аз съм вместо
просто ще отпечатате характер,

1477
01:13:01,090 --> 01:13:04,610
цитат цитата, процента C, и
След това се обади и друга функция, която

1478
01:13:04,610 --> 01:13:09,950
съществува, че приема аргумент,
което е знак, като този.

1479
01:13:09,950 --> 01:13:12,630
>> Оказва се, в C, има
друга функция повикване

1480
01:13:12,630 --> 01:13:15,550
до горния, които тъй като името му
подсказва, отнема характер

1481
01:13:15,550 --> 01:13:19,350
и го прави за неговата горна съдебна
еквивалент, и след това се връща

1482
01:13:19,350 --> 01:13:21,410
така че ФОРМАТ да го включите в там.

1483
01:13:21,410 --> 01:13:25,484
И така, за да направите това, все пак, аз
Трябва да се въведе един друг файл.

1484
01:13:25,484 --> 01:13:28,400
Оказва се, има и друг файл
че вие ​​ще знаете само от класа,

1485
01:13:28,400 --> 01:13:33,020
или учебник, или онлайн
препратка, наречен C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Така че, ако мога да добавя, че до сред моята заглавна
файлове, а сега отново се съберат тази програма,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Нека да въведете в Zamyla във всички
с малки букви, все още работи по същия начин.

1489
01:13:46,690 --> 01:13:48,040
Но знаете ли какво?

1490
01:13:48,040 --> 01:13:55,590
Оказва се, че до горната
има някаква друга функция.

1491
01:13:55,590 --> 01:13:58,410
>> И нека представим този
командва тук, някак неловко

1492
01:13:58,410 --> 01:14:00,250
име, но човек за употреба.

1493
01:14:00,250 --> 01:14:03,960
Оказва се, че повечето Linux компютри,
както ние използваме here-- Linux операционна

1494
01:14:03,960 --> 01:14:06,270
system-- има команда
нарича човек, който казва,

1495
01:14:06,270 --> 01:14:08,530
хей, компютър, дай ми
ръководство на компютъра.

1496
01:14:08,530 --> 01:14:10,680
какво искаш да
погледнете в това ръководство?

1497
01:14:10,680 --> 01:14:13,840
>> Искам да гледам на функцията
призовани да горен, Enter.

1498
01:14:13,840 --> 01:14:16,070
И това е малко загадъчен
да се чете понякога.

1499
01:14:16,070 --> 01:14:18,780
Но забележете, че сме в
наръчник Linux програмист.

1500
01:14:18,780 --> 01:14:19,530
И всичко това е текст.

1501
01:14:19,530 --> 01:14:21,905
И забележи, че там е най-
името на функцията до тук.

1502
01:14:21,905 --> 01:14:25,030
Оказва се, че има братовчед, наречен
да се намали, което прави обратното.

1503
01:14:25,030 --> 01:14:29,710
И предизвестие по конспект, за да използвате този
функционира на страницата на човек, така да се каже,

1504
01:14:29,710 --> 01:14:32,220
ми казва, че аз
Трябва да включва в type.h.

1505
01:14:32,220 --> 01:14:33,630
И знаех, че от практиката.

1506
01:14:33,630 --> 01:14:36,210
>> Ето, това е ми показва двамата
прототипи за функцията,

1507
01:14:36,210 --> 01:14:39,070
така че ако някога искате да използвате тази
Знам, че това, което те вземат като вход,

1508
01:14:39,070 --> 01:14:40,652
и това, което те се връщат като продукция.

1509
01:14:40,652 --> 01:14:42,360
И след това, ако чета
описанието, виждам

1510
01:14:42,360 --> 01:14:44,820
по-подробно, което прави функцията.

1511
01:14:44,820 --> 01:14:48,100
Но по-важно, ако
Гледам при завръщането стойност,

1512
01:14:48,100 --> 01:14:51,710
тя казва, стойността връща
че на преобразуваната писмото,

1513
01:14:51,710 --> 01:14:57,880
или С, оригиналния входен, ако
преобразуването не е било възможно.

1514
01:14:57,880 --> 01:15:01,992
>> С други думи, за да горен ще се опита
да я превърне в писмо до горния случай.

1515
01:15:01,992 --> 01:15:03,450
И ако е така, то се случва да го върне.

1516
01:15:03,450 --> 01:15:07,010
Но ако тя не може за някои reason--
може би това е вече горния случай,

1517
01:15:07,010 --> 01:15:09,550
може би това е удивителен знак
или някаква друга punctuation--

1518
01:15:09,550 --> 01:15:12,200
това е просто ще
връщане на оригинала, C,

1519
01:15:12,200 --> 01:15:17,340
което означава, че може да направи моя код
по-добре проектирани, както следва.

1520
01:15:17,340 --> 01:15:20,580
>> Аз не се нуждаят всички
тези дяволски реда код.

1521
01:15:20,580 --> 01:15:22,610
Всички линии аз съм
просто подчерта може

1522
01:15:22,610 --> 01:15:28,700
се срина в само една проста
линия, която е this-- ФОРМАТ процента

1523
01:15:28,700 --> 01:15:33,510
С до горната S скоба аз.

1524
01:15:33,510 --> 01:15:36,090
И това ще бъде
Пример за по-добър дизайн.

1525
01:15:36,090 --> 01:15:40,040
>> Защо приложат в 7 или 8 линии
на код, каквото и да е просто

1526
01:15:40,040 --> 01:15:44,960
заличава, когато можете да вместо колапс
всички от тази логика и вземане на решения

1527
01:15:44,960 --> 01:15:49,620
в една единствена линия, 13 сега, че
разчита на библиотека function--

1528
01:15:49,620 --> 01:15:53,430
функция, която идва с C, но това
прави точно това, което искате да направите.

1529
01:15:53,430 --> 01:15:55,295
И, честно казано, дори и ако
тя не дойде с C,

1530
01:15:55,295 --> 01:15:58,880
бихте могли да го въведе себе си, като
сме виждали, с получите отрицателен инт

1531
01:15:58,880 --> 01:16:01,700
и да получите положителен инт миналата седмица, както добре.

1532
01:16:01,700 --> 01:16:03,470
>> Този код сега е много по-разбираемо.

1533
01:16:03,470 --> 01:16:06,670
И наистина, ако ние превъртете нагоре,
погледнете колко по-компактен

1534
01:16:06,670 --> 01:16:08,360
тази версия на програмата ми е.

1535
01:16:08,360 --> 01:16:11,230
Това е малко отгоре тежко сега,
с всичко това включва.

1536
01:16:11,230 --> 01:16:14,380
Но това е ОК, защото сега съм застанал
върху раменете на програмисти

1537
01:16:14,380 --> 01:16:15,300
преди мен.

1538
01:16:15,300 --> 01:16:18,440
И който и да беше, които
приложени към горния наистина

1539
01:16:18,440 --> 01:16:21,470
ми направи услуга, подобно на този, който
осъществява Stirling наистина

1540
01:16:21,470 --> 01:16:24,790
ми направи услуга преди известно време.

1541
01:16:24,790 --> 01:16:26,970
И така, сега имаме
по-добър дизайн програма

1542
01:16:26,970 --> 01:16:31,680
който реализира точно същата логика.

1543
01:16:31,680 --> 01:16:35,580
>> Говорейки на Стърлинг, нека
ми давай напред и да направим това.

1544
01:16:35,580 --> 01:16:38,320
Нека да вървим напред и да спаси
този файл като stirling.c.

1545
01:16:38,320 --> 01:16:43,255
И се оказва, ние можем да се бели назад
един друг слой доста просто сега.

1546
01:16:43,255 --> 01:16:45,630
Отивам да се продължи напред и камшик
до друга програма в главната

1547
01:16:45,630 --> 01:16:49,759
тук, че просто се внедрява
Дължина на низ, както следва.

1548
01:16:49,759 --> 01:16:52,300
Така че тук е ред на код, който
ми получава низ от страна на потребителя.

1549
01:16:52,300 --> 01:16:53,910
Ние продължаваме да използвате това отново и отново.

1550
01:16:53,910 --> 01:16:58,900
Позволете ми да се даде една променлива, наречена
п от тип INT, че съхранява номер.

1551
01:16:58,900 --> 01:17:02,490
>> И нека да вървим напред и да
направя следната логика.

1552
01:17:02,490 --> 01:17:15,610
Докато върши п-ия характер в S
Не равно наклонена черта 0, давай

1553
01:17:15,610 --> 01:17:17,930
и нарастване п.

1554
01:17:17,930 --> 01:17:23,506
И после разпечата ФОРМАТ процента аз п.

1555
01:17:23,506 --> 01:17:29,200
Аз твърдя, че тази програма тук,
без да се поставя дължина низ,

1556
01:17:29,200 --> 01:17:31,150
разбере, дължината на низ.

1557
01:17:31,150 --> 01:17:34,600
>> И магията е изцяло
капсулирани в линия 8

1558
01:17:34,600 --> 01:17:39,830
тук с това, което изглежда като нов синтаксис,
тази наклонена черта 0 в единични кавички.

1559
01:17:39,830 --> 01:17:41,360
Но защо е така?

1560
01:17:41,360 --> 01:17:44,100
Е, помисли какво е било
случва през цялото това време.

1561
01:17:44,100 --> 01:17:47,990
>> И като се отмени преди да забравя, да разбере,
също, че в допълнение към човека страници

1562
01:17:47,990 --> 01:17:50,920
които идват с типичен
Linux система като CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
осъзнаят, че ние,
персонала, разбира се, трябва също

1564
01:17:53,770 --> 01:17:56,030
направи един сайт версия
на същата тази идея, наречена

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, която има
всички тези същите човека страници,

1566
01:17:59,940 --> 01:18:02,020
Всички същата
документация, както и

1567
01:18:02,020 --> 01:18:05,730
малко поле в горната част, която позволява
можете да конвертирате всички от сравнително

1568
01:18:05,730 --> 01:18:09,025
Arcane език на по-малко удобни
режим, където ние, преподавателите,

1569
01:18:09,025 --> 01:18:12,150
са преминали през и се опита да се опрости
някои от езика, за да пазят нещата

1570
01:18:12,150 --> 01:18:14,830
фокусирано върху идеите, а не
някои от техническите подробности.

1571
01:18:14,830 --> 01:18:20,070
Така че имайте предвид, reference.cs50.net
като друг ресурс, както добре.

1572
01:18:20,070 --> 01:18:23,800
>> Но защо не работи дължина низ в
Между другото аз предложих преди малко?

1573
01:18:23,800 --> 01:18:25,160
Ето отново име Zamyla му.

1574
01:18:25,160 --> 01:18:27,690
И тук е име Zamyla на
в опаковка, както аз не правиш,

1575
01:18:27,690 --> 01:18:31,360
да нарисува картина на това е,
Наистина, просто поредица от символи.

1576
01:18:31,360 --> 01:18:34,260
Но Zamyla не съществува
в изолация в една програма.

1577
01:18:34,260 --> 01:18:37,420
>> Когато пишете и стартирате програмата,
който използвате вашия Mac или вашия компютър

1578
01:18:37,420 --> 01:18:40,010
като памет, или RAM така да се каже.

1579
01:18:40,010 --> 01:18:42,620
И вие може да се мисли за
вашия компютър като имащи

1580
01:18:42,620 --> 01:18:44,730
много гигабайта памет в наши дни.

1581
01:18:44,730 --> 01:18:47,700
И концерт означава милиарди,
така милиарди байтове.

1582
01:18:47,700 --> 01:18:48,910
>> Но нека се върнем назад във времето.

1583
01:18:48,910 --> 01:18:51,530
И предполагам, че ние сме с помощта на
един много стар компютър, който

1584
01:18:51,530 --> 01:18:55,150
има само 32 байта памет.

1585
01:18:55,150 --> 01:18:59,310
Можех, на екрана на компютъра ми,
просто направи това по следния начин.

1586
01:18:59,310 --> 01:19:05,240
>> Мога да кажа само, че ми
компютър има всичко това с памет.

1587
01:19:05,240 --> 01:19:08,830
И това е като дърво на паметта, ако
Ако си спомняте нашата картина от последния път.

1588
01:19:08,830 --> 01:19:11,670
И ако аз просто се разделят
това в достатъчно пъти,

1589
01:19:11,670 --> 01:19:15,040
Аз твърдя, че имам 32 байта
памет на екрана.

1590
01:19:15,040 --> 01:19:18,239
>> Сега, в действителност, мога само да
изготвят досега на този екран тук.

1591
01:19:18,239 --> 01:19:20,280
Така че аз ще отида напред,
и само по силата на споразумение,

1592
01:19:20,280 --> 01:19:24,050
изготвят памет на моя компютър като
решетка, а не само като една права линия.

1593
01:19:24,050 --> 01:19:28,190
По-конкретно, аз твърдя, че сега
тази мрежа, това 8 от 4 решетка,

1594
01:19:28,190 --> 01:19:31,800
точно представлява всички 32 байта
налична памет в моя Mac,

1595
01:19:31,800 --> 01:19:33,030
или на разположение в моя компютър.

1596
01:19:33,030 --> 01:19:34,780
И те опаковане
по две линии, просто

1597
01:19:34,780 --> 01:19:38,030
защото тя се вписва повече на екрана.

1598
01:19:38,030 --> 01:19:40,800
Но това е първият байт.

1599
01:19:40,800 --> 01:19:41,990
Това е втората байт.

1600
01:19:41,990 --> 01:19:43,300
Това е третият байт.

1601
01:19:43,300 --> 01:19:45,310
>> И това е 32-ия байт.

1602
01:19:45,310 --> 01:19:52,910
Или, ако си мислим, като компютър
учен, това е байт 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Така че имате 0 до 31, ако
да започнете да се брои при 0.

1604
01:19:55,950 --> 01:19:59,830
>> Така че, ако ние използваме една програма
че разговори се низ,

1605
01:19:59,830 --> 01:20:05,280
и ние се низ от човека
както направих аз, наречен Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
как в света прави
компютър Следете които байт,

1607
01:20:09,430 --> 01:20:12,230
което парче от паметта,
принадлежи към която низ?

1608
01:20:12,230 --> 01:20:16,270
С други думи, ако ние се пристъпи към
въведете друго име в компютъра,

1609
01:20:16,270 --> 01:20:19,890
като този Andi, наричайки
получите низ за втори път,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I трябва да се свърши в
памет на компютъра, както и.

1611
01:20:23,030 --> 01:20:23,850
Но как?

1612
01:20:23,850 --> 01:20:29,700
>> Е, оказва се, че под
качулка, какво C върши когато съхраняване струни

1613
01:20:29,700 --> 01:20:35,080
че човешките видове в, или че
идват от някакъв друг източник, е, че

1614
01:20:35,080 --> 01:20:39,190
очертава края на тях с
специален character-- наклонена черта

1615
01:20:39,190 --> 01:20:44,750
0, което е само по специален начин
да се каже, 80 бита в един ред.

1616
01:20:44,750 --> 01:20:47,950
>> Така A-- това е изтеглянето номер 97.

1617
01:20:47,950 --> 01:20:51,770
Така че някои модел на 8 бита
представлява десетичната номер 97.

1618
01:20:51,770 --> 01:20:58,070
Тази наклонена черта 0 е буквално на броя
0, познат още като Nul, N-U-L, за разлика от по-рано,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, който ние говорихме.

1620
01:20:59,630 --> 01:21:05,700
Но за сега, просто знам, че този
наклонена черта 0 е само на 80 бита в един ред.

1621
01:21:05,700 --> 01:21:09,810
>> И това е само тази линия в
пясък, който казва, че нищо в ляво

1622
01:21:09,810 --> 01:21:12,610
принадлежи към една струна, или един вид данни.

1623
01:21:12,610 --> 01:21:15,480
И нищо в дясно
принадлежи към нещо друго.

1624
01:21:15,480 --> 01:21:17,440
името Andi, междувременно,
които просто визуално

1625
01:21:17,440 --> 01:21:21,310
се случва да приключи към другата линия,
но това е само естетически детайли,

1626
01:21:21,310 --> 01:21:23,990
По същия начин се прекратява Nul.

1627
01:21:23,990 --> 01:21:29,290
>> Тя е низ от един символи A-N-D-I,
плюс една пета секретен характер,

1628
01:21:29,290 --> 01:21:33,560
всички 0 бита, които просто определя границите
В края на име Анди, както и.

1629
01:21:33,560 --> 01:21:37,120
И ако ние наричаме получите низ за трети път
в компютъра, за да получите низ като

1630
01:21:37,120 --> 01:21:44,210
Maria, М-A-R-I-A, подобно е Мария
име Nul прекратен с наклонена черта 0.

1631
01:21:44,210 --> 01:21:47,170
>> Това е коренно различна
от това как един компютър би типично

1632
01:21:47,170 --> 01:21:51,850
съхранява цяло число, или с плаваща запетая, или друга
типове данни все още, тъй като припомни,

1633
01:21:51,850 --> 01:21:57,420
цяло число обикновено е 32 бита, или
4 байта, или може би дори 64 бита,

1634
01:21:57,420 --> 01:21:59,100
или осем байта.

1635
01:21:59,100 --> 01:22:02,620
Но много примитиви в компютър
в един език за програмиране

1636
01:22:02,620 --> 01:22:05,550
имат фиксиран брой
байта под hood--

1637
01:22:05,550 --> 01:22:08,100
може би една, може би две, може би 4, може би 8.

1638
01:22:08,100 --> 01:22:13,250
>> Но струни, с дизайн, имат
динамичен брой символи.

1639
01:22:13,250 --> 01:22:16,980
Вие не знаете предварително, докато
видовете човека в Z-A-М-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
или М-A-R-I-A или A-N-D-I. Вие не знаете
колко пъти потребителят ще удари

1641
01:22:21,400 --> 01:22:22,070
клавиатурата.

1642
01:22:22,070 --> 01:22:26,490
Поради това, че не знаете как
много герои в аванс

1643
01:22:26,490 --> 01:22:27,540
започваш да се наложи.

1644
01:22:27,540 --> 01:22:31,840
>> И така C просто вид на листа като
тайна трохи под капака

1645
01:22:31,840 --> 01:22:32,960
в края на низа.

1646
01:22:32,960 --> 01:22:39,280
След съхраняване на Z-A-М-Y-L-A в паметта,
тя също така просто поставя еквивалент

1647
01:22:39,280 --> 01:22:40,210
на определен период.

1648
01:22:40,210 --> 01:22:45,060
В края на изречението,
го поставя 80 бита, така че

1649
01:22:45,060 --> 01:22:49,120
да си спомня къде
Zamyla започва и завършва.

1650
01:22:49,120 --> 01:22:51,490
>> Така че това, което е връзката,
След това, с тази програма?

1651
01:22:51,490 --> 01:22:55,190
Тази програма тук, Стърлинг,
е просто механизъм

1652
01:22:55,190 --> 01:22:57,970
за получаване на низ
от страна на потребителя, линия 6.

1653
01:22:57,970 --> 01:23:01,160
Line 7, аз декларирам променлива
нарича н и я определя като равна на 0.

1654
01:23:01,160 --> 01:23:08,680
>> И тогава в линия 8, аз просто попитах
въпрос, докато N-тия символ прави

1655
01:23:08,680 --> 01:23:12,120
не е равно на всички 0 bits--
С други думи, не

1656
01:23:12,120 --> 01:23:14,500
равна на тази специална
характер, наклонена черта 0, което

1657
01:23:14,500 --> 01:23:18,470
беше само, че специален Nul character--
давай напред и просто нарастване п.

1658
01:23:18,470 --> 01:23:21,460
>> И да го прави и пази
да го прави, и да го правиш.

1659
01:23:21,460 --> 01:23:23,430
И така, въпреки че в
миналото сме използвали аз,

1660
01:23:23,430 --> 01:23:25,181
това е съвършено глоба
семантично да използват п,

1661
01:23:25,181 --> 01:23:27,430
ако сте просто се опитва да
брои този път умишлено,

1662
01:23:27,430 --> 01:23:28,720
и просто искате да го наричат ​​п.

1663
01:23:28,720 --> 01:23:34,720
Така че това просто продължава да си зададе въпроса,
е п-ия характер и само 0?

1664
01:23:34,720 --> 01:23:38,470
Ако не, гледам към следващия вид,
погледнем към следващия, гледаме към следващия,

1665
01:23:38,470 --> 01:23:39,460
погледнем към следващия.

1666
01:23:39,460 --> 01:23:45,540
>> Но веднага след като те видя наклонена черта 0,
това loop-- линия 9 чрез 11-- спира.

1667
01:23:45,540 --> 01:23:49,640
Можете да се измъкнат от време контур,
оставяйки вътре на тази променлива п

1668
01:23:49,640 --> 01:23:54,530
с общ брой на всички от
символи в низа си видял,

1669
01:23:54,530 --> 01:23:55,660
като по този начин да ги извежда.

1670
01:23:55,660 --> 01:23:56,760
Така че нека се опитаме това.

1671
01:23:56,760 --> 01:23:59,500
>> Нека да вървим напред и, без да се
използване на функцията на Стърлинг,

1672
01:23:59,500 --> 01:24:04,240
но само с помощта на собствената си доморасли версия
тук се нарича Stirling, нека да вървим напред

1673
01:24:04,240 --> 01:24:07,700
и серия Stirling, тип в нещо
като Zamyla, което аз знам предварително

1674
01:24:07,700 --> 01:24:08,670
е шест символа.

1675
01:24:08,670 --> 01:24:10,080
Да видим дали ще работи.

1676
01:24:10,080 --> 01:24:10,920
В действителност, това е шест.

1677
01:24:10,920 --> 01:24:15,257
Нека се опитаме с Роб, три символа,
три символа, както и, и така нататък.

1678
01:24:15,257 --> 01:24:17,340
Така че това е всичко, което се случва
за под предния капак.

1679
01:24:17,340 --> 01:24:19,548
И забележи връзките,
След това, с първата седмица

1680
01:24:19,548 --> 01:24:22,370
на класа, когато говорихме за
нещо като абстракция,

1681
01:24:22,370 --> 01:24:26,960
което е само това наслояване на идеи, или
сложност, на върха на основни принципи.

1682
01:24:26,960 --> 01:24:30,710
Ето, ние сме нещо като гледам
под капака на Стърлинг,

1683
01:24:30,710 --> 01:24:33,510
така да се каже, за да разбера,
как ще го бъде изпълнена?

1684
01:24:33,510 --> 01:24:35,232
>> И бихме могли отново да го приложат себе си.

1685
01:24:35,232 --> 01:24:37,440
Но ние никога отново ще
за повторно прилагане на Стърлинг.

1686
01:24:37,440 --> 01:24:39,780
Ние просто ще
използвате Стърлинг, за

1687
01:24:39,780 --> 01:24:42,100
да се получи в действителност някои дължина струни.

1688
01:24:42,100 --> 01:24:44,200
>> Но няма магия
под предния капак.

1689
01:24:44,200 --> 01:24:46,716
Ако знаете, че отдолу
качулката, низ

1690
01:24:46,716 --> 01:24:48,090
е просто поредица от символи.

1691
01:24:48,090 --> 01:24:51,090
И, че поредица от символи
всички могат да бъдат адресирани числено

1692
01:24:51,090 --> 01:24:53,330
с конзола 0, скоба
1, скоба 2, и вие

1693
01:24:53,330 --> 01:24:57,420
знам, че в края на низ е
специален символ, можете да разбера

1694
01:24:57,420 --> 01:25:01,710
как да се направи почти всичко в едно
програма, защото всичко се свежда до

1695
01:25:01,710 --> 01:25:03,400
е четене и писане на паметта.

1696
01:25:03,400 --> 01:25:06,130
Това означава, че се променя и търси
в паметта, или движещи се неща

1697
01:25:06,130 --> 01:25:10,940
около в паметта, печат неща
на екрана, и така нататък.

1698
01:25:10,940 --> 01:25:14,800
>> Така че нека сега използвам тази новооткрита
разбиране на това, което струни всъщност

1699
01:25:14,800 --> 01:25:17,910
са под предния капак, и
Отлепете един друг слой

1700
01:25:17,910 --> 01:25:20,080
че до този момент ние сме
е взел предвид факта.

1701
01:25:20,080 --> 01:25:22,650
По-специално, по всяко време
въведохме една програма,

1702
01:25:22,650 --> 01:25:25,930
сме имали този ред на код
близо до върха обявяване главната.

1703
01:25:25,930 --> 01:25:27,810
И зададохме INT главната невалидни.

1704
01:25:27,810 --> 01:25:31,240
>> И тази празнина в скобите
има казваме през цялото това време, че основният

1705
01:25:31,240 --> 01:25:33,440
самата не взема никакви аргументи.

1706
01:25:33,440 --> 01:25:36,210
Всеки вход, че основната е
ще получите от потребителя

1707
01:25:36,210 --> 01:25:39,020
трябва да дойде от някой друг
механизъм, като GET INT,

1708
01:25:39,020 --> 01:25:42,040
или да получите плувка, или да получите низ,
или някаква друга функция.

1709
01:25:42,040 --> 01:25:44,710
Но се оказва, че
когато се напише програма,

1710
01:25:44,710 --> 01:25:47,690
всъщност можете да укажете
че тази програма

1711
01:25:47,690 --> 01:25:51,730
предприеме входове от човека
в командния самата линия.

1712
01:25:51,730 --> 01:25:56,310
>> С други думи, въпреки че досега
са били работи само ./hello здравей

1713
01:25:56,310 --> 01:26:00,312
или други подобни програми, всички от
други програми, които сме били използване,

1714
01:26:00,312 --> 01:26:02,770
че ние самите не пиша,
са като, изглежда,

1715
01:26:02,770 --> 01:26:05,210
командния ред arguments--
неща като грим.

1716
01:26:05,210 --> 01:26:07,450
Вие казвате нещо като изработка,
и след това втора дума.

1717
01:26:07,450 --> 01:26:10,950
Или трясък, което казвате звън, и след това
втора дума, на името на файла.

1718
01:26:10,950 --> 01:26:14,410
>> Или дори RM или CP, като може да се
съм виждал или използва вече

1719
01:26:14,410 --> 01:26:15,880
за да се отстрани или копиране на файлове.

1720
01:26:15,880 --> 01:26:18,920
Всички тези, които вземат т.нар
командния ред arguments--

1721
01:26:18,920 --> 01:26:21,130
допълнителни думи в терминален прозорец.

1722
01:26:21,130 --> 01:26:23,260
Но до сега, ние
себе си не са имали

1723
01:26:23,260 --> 01:26:27,080
този лукс на приема принос от страна на
потребителя, когато той или тя всъщност работи

1724
01:26:27,080 --> 01:26:29,120
самата програма в командния ред.

1725
01:26:29,120 --> 01:26:33,710
>> Но ние можем да направим това чрез повторно обявяване
Основната движи напред, а не като имащи

1726
01:26:33,710 --> 01:26:36,750
анулира в скоби,
но тези два аргумента

1727
01:26:36,750 --> 01:26:40,600
instead-- първото цяло число,
и втората нещо

1728
01:26:40,600 --> 01:26:44,170
ново, нещо, което ние ще наричаме
масив, нещо подобно в дух

1729
01:26:44,170 --> 01:26:49,220
за това, което видяхме в Scratch като списък, но
масив от низове, тъй като ние скоро ще видите.

1730
01:26:49,220 --> 01:26:51,790
Но нека видим това, като
Така например, преди да сме

1731
01:26:51,790 --> 01:26:53,690
разграничи точно какво означава това.

1732
01:26:53,690 --> 01:26:56,520
>> Така че, ако аз отида в CS50 IDE
тук, аз съм отишъл напред

1733
01:26:56,520 --> 01:27:01,840
и обявен във файл, наречен
argv0.c следния модел.

1734
01:27:01,840 --> 01:27:04,120
И забележи единственото нещо,
това е различно, доколкото

1735
01:27:04,120 --> 01:27:08,570
е, че съм се променил нищожно да Int
argc струнен argv отворена скоба, близо

1736
01:27:08,570 --> 01:27:09,070
скоба.

1737
01:27:09,070 --> 01:27:11,730
И забележи, за сега, има
нищо вътре на тези скоби.

1738
01:27:11,730 --> 01:27:12,620
>> Няма по брой.

1739
01:27:12,620 --> 01:27:15,070
И няма аз, или
N, или всяко друго писмо.

1740
01:27:15,070 --> 01:27:17,010
Аз съм само с помощта на
квадратни скоби за сега,

1741
01:27:17,010 --> 01:27:19,510
по причини, ние ще дойдем
обратно в един момент.

1742
01:27:19,510 --> 01:27:21,330
>> И сега това, което аз ще направя, е това.

1743
01:27:21,330 --> 01:27:26,680
Ако argc равнява равнява 2--
и припомни, че е равно на равни

1744
01:27:26,680 --> 01:27:30,040
е оператор на равенство сравняване
отляво и отдясно за равенство.

1745
01:27:30,040 --> 01:27:31,790
Това не е заданието
оператор, което е

1746
01:27:31,790 --> 01:27:36,510
знак за равенство единствен, което означава, копие
от дясно на ляво някаква стойност.

1747
01:27:36,510 --> 01:27:42,840
>> Ако argc равнява е равно на 2, искам да
да речем, ФОРМАТ, здравей, проценти, нов ред,

1748
01:27:42,840 --> 01:27:47,340
и след това включете in-- и тук е новото
trick-- argv скоба 1, по причини,

1749
01:27:47,340 --> 01:27:48,840
че ще се върнем в един миг.

1750
01:27:48,840 --> 01:27:52,110
Иначе ако argc не прави
равно 2, знаете ли какво?

1751
01:27:52,110 --> 01:27:57,400
Нека просто отидете напред и, както обикновено, печат
от Здравей, свят, без смяна.

1752
01:27:57,400 --> 01:28:02,710
>> Така изглежда, че ако argc, които
щандове за броене аргумент, е равно на 2,

1753
01:28:02,710 --> 01:28:04,740
Отивам да разпечатате
здравей едно или друго нещо.

1754
01:28:04,740 --> 01:28:07,560
В противен случай, по подразбиране, аз съм
ще отпечата здравей свят.

1755
01:28:07,560 --> 01:28:08,770
И така, какво означава това?

1756
01:28:08,770 --> 01:28:15,550
>> Е, нека да вървим напред и да спаси
този файл, и след това направете направи argv0,

1757
01:28:15,550 --> 01:28:18,940
и след това ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
И той казва здравей свят.

1759
01:28:20,300 --> 01:28:21,260
Сега, защо е това?

1760
01:28:21,260 --> 01:28:24,730
>> Е, оказва се, по всяко време
стартирате програмата в командния ред,

1761
01:28:24,730 --> 01:28:29,570
попълвате това, което ние ще
обикновено наричаме аргумент вектор.

1762
01:28:29,570 --> 01:28:33,100
С други думи, автоматично
компютър, операционната система,

1763
01:28:33,100 --> 01:28:38,340
ще предаде на вашата програма
Самият списък на всички думи

1764
01:28:38,340 --> 01:28:40,850
че човекът напечатани в
ред, в случай, че

1765
01:28:40,850 --> 01:28:43,790
програмист искате да направите,
нещо с тази информация.

1766
01:28:43,790 --> 01:28:48,540
И в този случай, единствената дума,
Аз бях въведен в командния ред е ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> И така броят на аргументи, че е
да се прехвърлят към моята програма е само един.

1768
01:28:55,420 --> 01:28:58,880
С други думи, аргументът
брои, иначе известни като argc

1769
01:28:58,880 --> 01:29:00,970
тук като цяло число, е само един.

1770
01:29:00,970 --> 01:29:03,000
Един, разбира се, не го прави равен на две.

1771
01:29:03,000 --> 01:29:05,980
И така, това е, което се отпечатва, здравей свят.

1772
01:29:05,980 --> 01:29:08,170
>> Но нека да се възползвам от тази някъде.

1773
01:29:08,170 --> 01:29:09,930
Позволете ми да кажа, argv0.

1774
01:29:09,930 --> 01:29:12,740
И тогава какво ще кажеш за Мария?

1775
01:29:12,740 --> 01:29:14,990
И след това се удари Enter.

1776
01:29:14,990 --> 01:29:18,020
>> И забележи какво магически се случва тук.

1777
01:29:18,020 --> 01:29:22,640
Сега, вместо здравей свят, имам
до промяна в поведението на тази програма

1778
01:29:22,640 --> 01:29:26,310
чрез вземане на входа не от GET
низ или някаква друга функция,

1779
01:29:26,310 --> 01:29:30,570
но от очевидно, моята команда
себе си, това, което аз първоначално написан инча

1780
01:29:30,570 --> 01:29:35,720
И мога да играя тази игра отново от
тя се променя, за да Стелиос, например.

1781
01:29:35,720 --> 01:29:38,400
>> И сега виждам друго име все още.

1782
01:29:38,400 --> 01:29:40,540
И тук, мога да кажа, Анди.

1783
01:29:40,540 --> 01:29:42,137
И мога да кажа Zamyla.

1784
01:29:42,137 --> 01:29:45,220
И ние може да играе тази игра през целия ден,
Просто включвате в различни стойности,

1785
01:29:45,220 --> 01:29:49,550
толкова дълго, колкото аз се осигури точно
две думи в командния ред,

1786
01:29:49,550 --> 01:29:52,260
такава, че argc, моя аргумент брои, е 2.

1787
01:29:52,260 --> 01:29:57,240
>> Да виждам, че името включен в
ФОРМАТ, на това условие тук?

1788
01:29:57,240 --> 01:30:00,550
Така че ние като че ли са сега
експресивната способност

1789
01:30:00,550 --> 01:30:04,410
на вземане вход от друг механизъм,
от т.нар командния ред,

1790
01:30:04,410 --> 01:30:07,000
вместо да се налага да чакат
докато потребителят работи програмата,

1791
01:30:07,000 --> 01:30:10,220
и след него подкани
използвайки нещо като GET низ.

1792
01:30:10,220 --> 01:30:11,230
>> И така, какво е това?

1793
01:30:11,230 --> 01:30:15,010
Argc, отново, е просто число,
броят на words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
че потребителят е предвидено в
бързо, по прозореца на терминала,

1795
01:30:18,540 --> 01:30:20,110
включително името на програмата.

1796
01:30:20,110 --> 01:30:23,340
Така че нашата ./argv0 е, ефективно,
името на програмата,

1797
01:30:23,340 --> 01:30:24,520
или как се стартира програмата.

1798
01:30:24,520 --> 01:30:25,810
>> Това се смята за една дума.

1799
01:30:25,810 --> 01:30:27,080
Така argc ще бъде 1.

1800
01:30:27,080 --> 01:30:29,750
Но когато пиша Стелиос, или
Andi, или Zamyla, или Мария,

1801
01:30:29,750 --> 01:30:31,660
това означава, че броят на аргумент е две.

1802
01:30:31,660 --> 01:30:33,910
И така, сега има две думи преминали инча

1803
01:30:33,910 --> 01:30:36,070
>> И известие, че можем да продължим тази логика.

1804
01:30:36,070 --> 01:30:39,050
Ако аз всъщност се каже,
нещо като Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
пълно име, като по този начин, минаваща
три аргумента общо,

1806
01:30:42,200 --> 01:30:47,410
Сега той казва по подразбиране отново,
защото, разбира се, 3 не прави равен 2.

1807
01:30:47,410 --> 01:30:54,080
>> И така, по този начин, трябва да съм,
достъп чрез argv този нов аргумент

1808
01:30:54,080 --> 01:30:56,080
че бихме могли технически
наричаме нещо, което искаме.

1809
01:30:56,080 --> 01:30:58,940
Но по силата на споразумение, това е
argv и argc, съответно.

1810
01:30:58,940 --> 01:31:04,470
Argv, аргумент вектор, е вид
на синоним за програмиране

1811
01:31:04,470 --> 01:31:07,140
функция в C наречен масив.

1812
01:31:07,140 --> 01:31:14,410
>> Масивът е даден списък на подобни ценности
обратно, за да архивирате, за да архивирате, да върне.

1813
01:31:14,410 --> 01:31:17,810
С други думи, ако един е точно тук, в
RAM, следващата е в непосредствена близост до него,

1814
01:31:17,810 --> 01:31:18,800
и в непосредствена близост до него.

1815
01:31:18,800 --> 01:31:20,101
Те не са по цялото място.

1816
01:31:20,101 --> 01:31:23,100
И последната сценарий, където нещата
са по цялото място в паметта,

1817
01:31:23,100 --> 01:31:25,082
всъщност може да бъде мощен функция.

1818
01:31:25,082 --> 01:31:28,040
Но ние ще се върнем към това, когато ние
говорим за красиви структури от данни.

1819
01:31:28,040 --> 01:31:32,260
За сега, масив е просто
парче от непрекъсната памет,

1820
01:31:32,260 --> 01:31:36,520
всеки от чиито елементи са
обратно, за да архивирате, за да архивирате, за да архивирате,

1821
01:31:36,520 --> 01:31:38,050
и обикновено от същия тип.

1822
01:31:38,050 --> 01:31:42,630
>> Така че, ако мислите, че за, от една
преди момент, това, което е низ?

1823
01:31:42,630 --> 01:31:50,460
Е, низ, като Zamyla,
Z-A-M-Y-L-A, е, технически,

1824
01:31:50,460 --> 01:31:51,400
само масив.

1825
01:31:51,400 --> 01:31:53,700
Това е набор от символи.

1826
01:31:53,700 --> 01:31:59,250
>> И така, ако ние наистина се направи това, тъй като съм
направи по-рано, като парче памет,

1827
01:31:59,250 --> 01:32:04,510
Оказва се, че всеки един от тях
знаци заема един байт.

1828
01:32:04,510 --> 01:32:07,630
И тогава там е, че специален
Сентинел характер, наклонената черта 0,

1829
01:32:07,630 --> 01:32:12,360
или всичките осем 0 бита, че
разграничава края на тази струна.

1830
01:32:12,360 --> 01:32:15,090
Така низ, се оказва,
навън, цитирам цитата низ,

1831
01:32:15,090 --> 01:32:20,580
е просто набор от chara--
Чар е действително тип данни.

1832
01:32:20,580 --> 01:32:24,560
>> И сега argv, meanwhile--
нека се върнем към програмата.

1833
01:32:24,560 --> 01:32:29,582
Argv, въпреки че ние виждаме думата
низ тук, не е сам по себе си низ.

1834
01:32:29,582 --> 01:32:33,640
Argv, аргумент вектор,
е масив от низове.

1835
01:32:33,640 --> 01:32:37,620
>> Така че, точно както можете да имате масив от
символи, можете да имат по-високо ниво,

1836
01:32:37,620 --> 01:32:46,279
масив от strings-- така, например,
когато написах преди малко ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, пространство Z-A-M-Y-L-A, I твърди, че
argv имаше две струни в it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
и Z-A-М-Y-L-A. в
С други думи, argc е 2.

1839
01:33:03,185 --> 01:33:03,980
Защо така?

1840
01:33:03,980 --> 01:33:08,370
>> Е, ефективно, което се случва
на е, че всяка от тези струни

1841
01:33:08,370 --> 01:33:13,990
е, разбира се, набор от символи
Както и преди, всеки от чиито герои

1842
01:33:13,990 --> 01:33:15,670
заема един байт.

1843
01:33:15,670 --> 01:33:19,720
И не бъркайте действителната 0
в името на програмата на 0,

1844
01:33:19,720 --> 01:33:22,040
което означава, че всички 80 бита.

1845
01:33:22,040 --> 01:33:27,140
И Zamyla, междувременно, е все още
и набор от символи.

1846
01:33:27,140 --> 01:33:31,450
>> Така в края на деня, тя наистина
изглежда по този начин под предния капак.

1847
01:33:31,450 --> 01:33:38,800
Но argv, от природата на това как главната
произведения, ми позволява да приключи всичко това

1848
01:33:38,800 --> 01:33:44,810
нагоре в, ако щете, по-голяма масив
че, ако ние малко над опрости

1849
01:33:44,810 --> 01:33:48,180
това, което на снимката прилича и не
доста го направи, за да мащабирате до там,

1850
01:33:48,180 --> 01:33:56,720
този масив е само на размер 2, първият
елемент от които съдържа низ,

1851
01:33:56,720 --> 01:33:59,230
Вторият елемент на
който съдържа низ.

1852
01:33:59,230 --> 01:34:01,687
И, от своя страна, ако
вид фокусирам върху всеки

1853
01:34:01,687 --> 01:34:03,770
на тези струни, това, което
виж под капака

1854
01:34:03,770 --> 01:34:07,190
е, че всяка струна е просто
набор от символи.

1855
01:34:07,190 --> 01:34:11,680
>> Сега, точно както с низове,
ние бяхме в състояние да получите достъп

1856
01:34:11,680 --> 01:34:15,260
на I-ия знак в низ
използване че квадратна скоба нотация.

1857
01:34:15,260 --> 01:34:17,320
По същия начин, с масиви
Като цяло, можем

1858
01:34:17,320 --> 01:34:22,700
използвате квадратна скоба нотация, за да получите
във всеки брой на низове в масив?

1859
01:34:22,700 --> 01:34:25,100
Например, нека
давай напред и да направим това.

1860
01:34:25,100 --> 01:34:32,420
>> Нека да вървим напред и да се създаде argv1.c,
което е малко по-различно този път.

1861
01:34:32,420 --> 01:34:35,635
Вместо проверка за argc2,
Отивам да вместо да направите това.

1862
01:34:35,635 --> 01:34:41,270
За инт получавам 0, I е по-малко
от argc, аз плюс плюс,

1863
01:34:41,270 --> 01:34:47,920
и след това се отпечата вътре на това,
процента ите, нов ред, и след това

1864
01:34:47,920 --> 01:34:50,740
argv скоба аз.

1865
01:34:50,740 --> 01:34:55,220
>> Така че, с други думи, аз не съм се занимават с
отделните герои в момента.

1866
01:34:55,220 --> 01:35:00,190
Argv, както се подразбира от тях празно квадратче
скоби за правото на argv на име,

1867
01:35:00,190 --> 01:35:03,320
означава argv е масив от низове.

1868
01:35:03,320 --> 01:35:04,870
И argc е само едно цяло число.

1869
01:35:04,870 --> 01:35:08,800
>> Тази линия тук, 6, е
казвайки набор аз равна на 0.

1870
01:35:08,800 --> 01:35:11,980
Преброяване по целия път до,
но не включително, argc.

1871
01:35:11,980 --> 01:35:14,010
И след това на всяка итерация,
разпечатате низ.

1872
01:35:14,010 --> 01:35:14,800
Какво низ?

1873
01:35:14,800 --> 01:35:17,270
>> -тото низ в argv.

1874
01:35:17,270 --> 01:35:19,530
Така че докато преди бях
използване на квадратен скоба

1875
01:35:19,530 --> 01:35:22,180
нотация, за да получите най-İth
знак в низ, сега

1876
01:35:22,180 --> 01:35:27,240
Аз съм с квадратна скоба нотация
за да получите най-низа Ith в масив.

1877
01:35:27,240 --> 01:35:30,310
Така че това е вид на един слой
по-горе, концептуално.

1878
01:35:30,310 --> 01:35:35,390
>> И така, какво е чист за това
програма сега, ако аз съставят argv1,

1879
01:35:35,390 --> 01:35:42,067
и след това направете ./argv1, и след това въведете
в нещо като Foo бар Баз,

1880
01:35:42,067 --> 01:35:45,400
които са трите стандартни такива думи, които
компютърен учен достига за всяко време

1881
01:35:45,400 --> 01:35:51,010
той или тя се нуждае от някои заместващи думи,
и натиснете Enter, всяка от тези думи,

1882
01:35:51,010 --> 01:35:54,980
включително името на програмата, която
е в argv в първото място,

1883
01:35:54,980 --> 01:35:58,320
озовава се отпечатва един по един.

1884
01:35:58,320 --> 01:36:05,290
И ако мога да променя това, и аз да кажа
нещо като argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
ние получаваме всички три от тези,
думи, което е argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, защото в този
При argc, графът, е 3.

1887
01:36:14,400 --> 01:36:20,020
>> Но това, което е чист е, ако се разбере
че argv е просто масив от низове,

1888
01:36:20,020 --> 01:36:24,910
и вие разбирате, че низ
е масив от символи,

1889
01:36:24,910 --> 01:36:29,470
ние можем действително вид използвате тази
квадратна скоба за обозначаване на няколко пъти

1890
01:36:29,470 --> 01:36:33,320
да изберете низ, и след това изберете
характер в рамките на низ,

1891
01:36:33,320 --> 01:36:35,730
гмуркане в по-дълбоко, както следва.

1892
01:36:35,730 --> 01:36:40,100
В този пример, да ме пусне
напред и да наричаме това argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
И в този пример, нека да вървим напред
и направете following-- за инт да получа 0,

1895
01:36:50,180 --> 01:36:53,286
аз е по-малко от argc, аз плюс
плюс, точно както преди.

1896
01:36:53,286 --> 01:36:55,910
Така че в друг words-- и сега това
получава достатъчно сложно.

1897
01:36:55,910 --> 01:36:59,940
Тогава аз ще кажа,
обхождане струни в argv,

1898
01:36:59,940 --> 01:37:01,294
като коментар към себе си.

1899
01:37:01,294 --> 01:37:03,960
И тогава аз ще имам
вложени за линия, която най-вероятно

1900
01:37:03,960 --> 01:37:06,290
са направили, или считат
правене, в Scratch, където

1901
01:37:06,290 --> 01:37:08,600
Отивам да кажа int-- съм
не ще да се използва отново,

1902
01:37:08,600 --> 01:37:12,590
защото аз не искам да се сянка, или
сортиране на замени съществуващата аз.

1903
01:37:12,590 --> 01:37:15,780
>> Отивам да, вместо да, казват й, защото
това е моят Отидете на променлива, след като,

1904
01:37:15,780 --> 01:37:18,590
когато Аз просто се опитвам да
брои прости числа.

1905
01:37:18,590 --> 01:37:28,850
За й получава 0-- и също, п, ще
получите на кърмата дължината на argv скоба аз,

1906
01:37:28,850 --> 01:37:36,030
доколкото й е по-малко от m,
й плюс плюс, направете следното.

1907
01:37:36,030 --> 01:37:37,500
И тук е интересната част.

1908
01:37:37,500 --> 01:37:46,330
>> Разпечатайте характер и нова линия,
включване в argv скоба аз, скоба й.

1909
01:37:46,330 --> 01:37:47,940
ОК, така че нека да се добавят някои коментари тук.

1910
01:37:47,940 --> 01:37:54,820
Преминаване през герои
в текущия низ,

1911
01:37:54,820 --> 01:38:02,290
печат й-ия характер в I-ия низ.

1912
01:38:02,290 --> 01:38:04,630
Така че сега, нека да разгледаме
какво означават тези коментари.

1913
01:38:04,630 --> 01:38:06,750
>> Преминаване през струните
в argv-- колко

1914
01:38:06,750 --> 01:38:09,300
струни са в argv, който е масив?

1915
01:38:09,300 --> 01:38:13,420
Argc много, така че аз съм итерации
от I равнява 0 до argc.

1916
01:38:13,420 --> 01:38:20,020
В същото време, колко символа
са в I-ия низ в argv?

1917
01:38:20,020 --> 01:38:22,880
>> Е, за да получите този отговор,
Току-що се обади дължина низ

1918
01:38:22,880 --> 01:38:26,810
на грижите на текущия низ I
около, която е argv скоба аз.

1919
01:38:26,810 --> 01:38:30,090
И аз отивам да се съхранява временно, че
стойност в N, само за целите на кеширане,

1920
01:38:30,090 --> 01:38:31,590
да го запомнят за ефективност.

1921
01:38:31,590 --> 01:38:36,330
И тогава аз ще се инициализира й до 0,
продължавай така дълго, колкото й е по-малък от N,

1922
01:38:36,330 --> 01:38:38,430
и на всяко нарастване итерация й.

1923
01:38:38,430 --> 01:38:41,030
>> И тогава в тук, за
моя коментар по линия 12,

1924
01:38:41,030 --> 01:38:43,390
разпечатате характер,
последвано от нов ред,

1925
01:38:43,390 --> 01:38:48,140
специално argv скоба
аз ми дава-тото низ

1926
01:38:48,140 --> 01:38:51,690
в argv-- така първата дума, за
втората дума, третата дума, каквото.

1927
01:38:51,690 --> 01:38:57,370
И след това й се гмурка в по-дълбок и получава
ми на к-ия характер на тази дума.

1928
01:38:57,370 --> 01:39:02,200
И така, в смисъл, вие може да лекува
argv като многоизмерен,

1929
01:39:02,200 --> 01:39:06,050
като двуизмерен, масив,
при което всяка дума вид на външен вид

1930
01:39:06,050 --> 01:39:08,580
като се има предвид това си
око, и всеки герой

1931
01:39:08,580 --> 01:39:10,930
е вид състои в
колона, ако това помага.

1932
01:39:10,930 --> 01:39:13,260
>> В действителност, когато ние дразни
това освен в бъдещите седмици,

1933
01:39:13,260 --> 01:39:15,580
това ще бъде малко по-
по-сложни от това.

1934
01:39:15,580 --> 01:39:17,800
Но наистина може да се
мисля за това, за сега,

1935
01:39:17,800 --> 01:39:22,110
като само тази двумерен
масив, при която едно ниво на него

1936
01:39:22,110 --> 01:39:23,260
е всичко, на струните.

1937
01:39:23,260 --> 01:39:26,760
И след това, ако се потопите в дълбок, вие
може да се получи при отделните герои

1938
01:39:26,760 --> 01:39:29,600
в него с помощта на тази система за означаване тук.

1939
01:39:29,600 --> 01:39:31,620
>> Така че това, което е нетният ефект?

1940
01:39:31,620 --> 01:39:34,970
Нека да вървим напред и да
направи argv2-- дяволски.

1941
01:39:34,970 --> 01:39:36,210
Направих грешка тук.

1942
01:39:36,210 --> 01:39:40,160
Безусловно обявяване на
библиотека функция Стърлинг.

1943
01:39:40,160 --> 01:39:42,190
Така че през цялото това време, това е
може би е уместно

1944
01:39:42,190 --> 01:39:45,130
че ние сме нещо като довършителни
точно там, откъдето започнахме.

1945
01:39:45,130 --> 01:39:48,160
>> Аз прецаках, неявно обявяване
библиотека функция Стърлинг.

1946
01:39:48,160 --> 01:39:48,987
ОК, чакай малко.

1947
01:39:48,987 --> 01:39:51,070
Спомням си, че, особено
тъй като това е точно тук.

1948
01:39:51,070 --> 01:39:54,490
Имам нужда да се включат string.h в
тази версия на програмата.

1949
01:39:54,490 --> 01:40:00,050
>> Нека да вървим напред и да включва
string.h, освен че, давай напред

1950
01:40:00,050 --> 01:40:04,460
и прекомпилирате argv2.

1951
01:40:04,460 --> 01:40:08,390
И сега, ето го, направи argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
И макар че е малко
загадъчен на пръв поглед,

1953
01:40:10,590 --> 01:40:15,690
забележите, че, наистина, какво
се отпечатва е точка argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Но ако напишете няколко думи след
бързо, като argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Въведете, също малко
загадъчен на пръв поглед.

1956
01:40:22,560 --> 01:40:30,540
Но ако ние превъртите обратно нагоре,
./argv2 Z-A-М-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Така че ние сме повтори над всяка дума.

1958
01:40:32,190 --> 01:40:37,770
И, от своя страна, сме повтори над
всеки герой в рамките на една дума.

1959
01:40:37,770 --> 01:40:40,040
>> Сега, след всичко това,
осъзнае, че има

1960
01:40:40,040 --> 01:40:43,120
една друга подробност сме били вид
в пренебрегване на цялото това време.

1961
01:40:43,120 --> 01:40:46,180
Ние просто дразни, освен това,
входове основните може да бъде?

1962
01:40:46,180 --> 01:40:47,780
Какво ще кажете за изход основната си?

1963
01:40:47,780 --> 01:40:50,540
>> Всичко това време, ние сме били
просто копиране и поставяне

1964
01:40:50,540 --> 01:40:53,870
Думата INT пред основната,
че може да се види онлайн,

1965
01:40:53,870 --> 01:40:58,340
понякога неправилно в по-старите версии
на C и компилатори, че те казват, нищожен,

1966
01:40:58,340 --> 01:40:59,410
или нищо.

1967
01:40:59,410 --> 01:41:01,580
Но, наистина, за версията
на C, който използваме,

1968
01:41:01,580 --> 01:41:06,180
C 11, или 2011 г., осъзнавам
че тя трябва да бъде вътр.

1969
01:41:06,180 --> 01:41:09,300
И това трябва да бъде или
невалидни или argc и argv тук.

1970
01:41:09,300 --> 01:41:10,790
>> Но защо INT главната?

1971
01:41:10,790 --> 01:41:12,480
Какво е тя всъщност връщане?

1972
01:41:12,480 --> 01:41:16,280
Е, оказва се, всичко това време,
всеки път, когато съм писал програма Основната

1973
01:41:16,280 --> 01:41:18,440
винаги се връщат нещо.

1974
01:41:18,440 --> 01:41:19,960
Но това е било това тайно.

1975
01:41:19,960 --> 01:41:23,350
>> Това нещо е
INT, като линия 5 подсказва.

1976
01:41:23,350 --> 01:41:24,225
Но това, което инт?

1977
01:41:24,225 --> 01:41:26,100
Е, има тази
конвенция в програмирането,

1978
01:41:26,100 --> 01:41:29,790
при което, ако нищо не е
объркало и всичко е добре,

1979
01:41:29,790 --> 01:41:34,250
програми и функции обикновено
return-- донякъде counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 обикновено означава, че всичко е наред.

1982
01:41:38,070 --> 01:41:40,610
Така че дори и да се мисли за
то като фалшиво в много контексти,

1983
01:41:40,610 --> 01:41:42,930
тя всъщност обикновено означава нещо добро

1984
01:41:42,930 --> 01:41:49,560
>> Междувременно, ако програмата се връща 1,
или отрицателна 1, или 5, или отрицателна 42,

1985
01:41:49,560 --> 01:41:52,941
или който и да е не-0 стойност,
че обикновено означава,

1986
01:41:52,941 --> 01:41:54,190
че нещо не е наред.

1987
01:41:54,190 --> 01:41:56,700
В действителност, на собствения си Mac или PC,
може да сте виждали

1988
01:41:56,700 --> 01:42:01,050
съобщение за грешка, което тя
казва едно или друго нещо, грешка

1989
01:42:01,050 --> 01:42:04,940
код отрицателен 42, или грешка код
23, или нещо подобно.

1990
01:42:04,940 --> 01:42:08,980
Този брой е обикновено просто намек
за програмист, или компанията

1991
01:42:08,980 --> 01:42:11,174
че прави софтуера,
какво се обърка и защо,

1992
01:42:11,174 --> 01:42:13,590
така че те да могат да гледат през
тяхната документация или код,

1993
01:42:13,590 --> 01:42:15,465
и да разбера какво
грешка всъщност означава.

1994
01:42:15,465 --> 01:42:18,400
Това по принцип не е
полезно за нас крайните потребители.

1995
01:42:18,400 --> 01:42:20,550
>> Но когато основните връща 0, всичко е наред.

1996
01:42:20,550 --> 01:42:23,770
И ако не укажете
какво главната трябва да се върне,

1997
01:42:23,770 --> 01:42:26,950
това ще стане само автоматично
върнете 0 за вас.

1998
01:42:26,950 --> 01:42:30,870
Но завръщането нещо
друго е действително полезно.

1999
01:42:30,870 --> 01:42:34,660
>> В този последен програма, нека
давай напред и да наричаме това exit.c,

2000
01:42:34,660 --> 01:42:38,630
и въвеждане на последната от днес
теми, известни като код за грешка.

2001
01:42:38,630 --> 01:42:42,930
Нека да вървим напред и да включва нашата
познатите файлове до върха, правят INT главната.

2002
01:42:42,930 --> 01:42:49,500
И този път, нека да направим INT argc,
низ argv, и с моите скоби

2003
01:42:49,500 --> 01:42:50,836
да се предполага, че това е в масива.

2004
01:42:50,836 --> 01:42:52,460
И тогава нека просто направи проверка на здрав разум.

2005
01:42:52,460 --> 01:42:56,640
Този път, ако argc не прави
равно 2, тогава знаете ли какво?

2006
01:42:56,640 --> 01:42:57,520
Забрави.

2007
01:42:57,520 --> 01:43:03,170
Аз отивам да се каже, че, хей, ръководство,
ви липсва аргумент на командния ред

2008
01:43:03,170 --> 01:43:04,210
наклонена черта п.

2009
01:43:04,210 --> 01:43:05,230
>> И след това е всичко.

2010
01:43:05,230 --> 01:43:06,130
Искам да излезете.

2011
01:43:06,130 --> 01:43:11,030
Аз отивам да изпреварващо,
и преждевременно наистина, връщане

2012
01:43:11,030 --> 01:43:12,810
нещо различно от номер 1.

2013
01:43:12,810 --> 01:43:15,360
Отиди на стойност за първите
грешка, която може да се случи е 1.

2014
01:43:15,360 --> 01:43:17,860
Ако имате някаква друга погрешна
ситуация, която може да се случи,

2015
01:43:17,860 --> 01:43:21,390
може да се каже връщане 2 или връщане 3, или
може би дори отрицателен 1 или отрицателна 2.

2016
01:43:21,390 --> 01:43:23,750
>> Това са само изходните кодове
които са, по принцип,

2017
01:43:23,750 --> 01:43:27,770
само полезно за програмист, или на
компания, която доставя софтуер.

2018
01:43:27,770 --> 01:43:30,500
Но фактът, че това е
Не 0 е това, което е важно.

2019
01:43:30,500 --> 01:43:34,310
Така че, ако в тази програма, аз искам да
гарантира, че тази програма само

2020
01:43:34,310 --> 01:43:38,190
работи, ако потребителят ми дава
с брой на аргумент на две,

2021
01:43:38,190 --> 01:43:42,880
името на програмата, както и някои други
дума, мога да наложат толкова, както следва,

2022
01:43:42,880 --> 01:43:46,110
крещи на потребителя с ФОРМАТ поговорка,
липсва аргумент на командния ред,

2023
01:43:46,110 --> 01:43:46,970
върне 1.

2024
01:43:46,970 --> 01:43:49,940
Това просто ще незабавно
спиране на програмата.

2025
01:43:49,940 --> 01:43:55,840
>> Само ако argc е равно на 2, ще получим надолу
тук, в този момент аз отивам да се каже,

2026
01:43:55,840 --> 01:44:00,410
здравей процента ите, наклонена черта п, argv1.

2027
01:44:00,410 --> 01:44:03,827
С други думи, аз съм
Не става след argv 0,

2028
01:44:03,827 --> 01:44:05,410
който е само името на програмата.

2029
01:44:05,410 --> 01:44:09,450
Искам да разпечатате здравей, запетая,
втората дума, че човекът въвели.

2030
01:44:09,450 --> 01:44:12,580
И в този случай на
линия 13, всичко е наред.

2031
01:44:12,580 --> 01:44:15,920
>> Аз знам, че argc е 2
логично от тази програма.

2032
01:44:15,920 --> 01:44:17,770
Отивам да вървим напред и да се върне 0.

2033
01:44:17,770 --> 01:44:21,230
Като настрана, имайте предвид, че
това е вярно в Scratch, както добре.

2034
01:44:21,230 --> 01:44:24,760
>> Логично е, че може да направи това
и капсулиране на тези редове

2035
01:44:24,760 --> 01:44:27,020
на код в този друг клауза тук.

2036
01:44:27,020 --> 01:44:29,420
Но това е нещо като
ненужно редовете на моя код.

2037
01:44:29,420 --> 01:44:31,800
И аз искам да се направи супер
ясно, че без значение какво,

2038
01:44:31,800 --> 01:44:34,670
по подразбиране, здравей
нещо ще се отпечатва,

2039
01:44:34,670 --> 01:44:36,050
толкова дълго, колкото потребителят сътрудничи.

2040
01:44:36,050 --> 01:44:39,360
>> Така че това е много често да се използва
състояние, само ако,

2041
01:44:39,360 --> 01:44:41,870
за улов на някои погрешни
ситуация, а след това излизане.

2042
01:44:41,870 --> 01:44:45,690
И след това, толкова дълго, всичко е
добре, не разполага с друг,

2043
01:44:45,690 --> 01:44:48,060
но просто трябва кода
извън това, ако, защото това е

2044
01:44:48,060 --> 01:44:51,060
еквивалент в тази
конкретен случай, логично.

2045
01:44:51,060 --> 01:44:54,480
Така че аз съм се върне 0, само за да
изрично да означава всичко е добре.

2046
01:44:54,480 --> 01:44:58,480
>> Ако се пропусне завръщането 0, би
автоматично се приема за мен.

2047
01:44:58,480 --> 01:45:00,890
Но сега, че аз съм връщане
един от най-малко този случай,

2048
01:45:00,890 --> 01:45:04,940
Отивам да, за добра мярка и
яснота, върнете 0 в този случай.

2049
01:45:04,940 --> 01:45:09,690
Така че сега нека да вървим напред и да излезете,
който е перфектен Segue да напусне просто.

2050
01:45:09,690 --> 01:45:14,401
>> Но да излезете, за да си отида
напред и ./exit направя, Enter.

2051
01:45:14,401 --> 01:45:16,900
И програмата извика към мен,
липсва команден ред аргумент.

2052
01:45:16,900 --> 01:45:18,120
ОК, нека да си сътрудничат.

2053
01:45:18,120 --> 01:45:23,810
>> Позволете ми, вместо да се направи ./exit, Дейвид, Enter.

2054
01:45:23,810 --> 01:45:25,190
И сега той казва, здравей Дейвид.

2055
01:45:25,190 --> 01:45:27,300
И обикновено не би видите това.

2056
01:45:27,300 --> 01:45:30,650
>> Но се оказва, че има
специален начин в Linux действително да видим

2057
01:45:30,650 --> 01:45:34,470
с какво излизане код програма излезе.

2058
01:45:34,470 --> 01:45:37,184
Понякога в графичен
свят като Mac OS или Windows,

2059
01:45:37,184 --> 01:45:40,100
вие виждате само тези номера, когато един
съобщение за грешка се появи на екрана

2060
01:45:40,100 --> 01:45:41,940
и програмист
ви показва, че редица.

2061
01:45:41,940 --> 01:45:44,773
Но ако искаме да видим каква грешка
съобщение е, можем да го направим here--

2062
01:45:44,773 --> 01:45:48,100
така ./exit, Enter, за печат
липсва команден ред аргумент.

2063
01:45:48,100 --> 01:45:54,590
>> Ако аз сега правя ехо $ ?, което е
абсурдно загадъчен търсите.

2064
01:45:54,590 --> 01:45:56,590
Но $?

2065
01:45:56,590 --> 01:45:59,220
е магическо заклинание
който казва, хей, компютър,

2066
01:45:59,220 --> 01:46:01,900
кажи ми какво предишното
код за изход програма беше.

2067
01:46:01,900 --> 01:46:03,410
И аз се удари Enter.

2068
01:46:03,410 --> 01:46:07,520
Виждам 1, защото това е, което аз
каза моята основна функция да се върне.

2069
01:46:07,520 --> 01:46:12,310
>> В същото време, ако го направя ./exit Дейвид,
и натиснете Enter, виждам, здравей Дейвид.

2070
01:46:12,310 --> 01:46:16,800
И ако сега правя ехо $ ?, виждам здравей 0.

2071
01:46:16,800 --> 01:46:19,080
И така, това действително ще
да бъде ценна информация

2072
01:46:19,080 --> 01:46:23,420
в контекста на дебъгер, не толкова
много, че вие, човекът, ще се грижи.

2073
01:46:23,420 --> 01:46:26,060
Но дебъгер и другият
програми ще използват този семестър

2074
01:46:26,060 --> 01:46:29,420
често ще разгледаме този номер,
Въпреки че това е нещо като скрит

2075
01:46:29,420 --> 01:46:32,780
освен ако не го търсим, за да
се определи дали дадена програма или не

2076
01:46:32,780 --> 01:46:37,050
изпълнение е правилно или неправилно.

2077
01:46:37,050 --> 01:46:40,450
>> И така, това ни води до
това, в края на деня.

2078
01:46:40,450 --> 01:46:43,917
Ние започнахме днес, като погледнете в
отстраняване на грешки, и на свой ред в хода

2079
01:46:43,917 --> 01:46:46,750
себе си, и след това по-интересно,
технически под капака

2080
01:46:46,750 --> 01:46:49,490
при какви струни са, което продължи
седмица ние просто взех за даденост,

2081
01:46:49,490 --> 01:46:51,900
и със сигурност ги взех
за даденост в Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> След това погледна как можем да имаме достъп
отделните символи в низ,

2083
01:46:56,040 --> 01:47:00,310
и след това отново пое по-високо ниво
гледам на нещата, гледайки как well--

2084
01:47:00,310 --> 01:47:04,226
ако искаме да получим по индивидуален
елементи в списък като структура,

2085
01:47:04,226 --> 01:47:05,850
Не можем да направим това с няколко струни?

2086
01:47:05,850 --> 01:47:08,050
И ние можем да с аргументи на командния ред.

2087
01:47:08,050 --> 01:47:12,800
Но тази снимка тук на само на кутии
е демонстративен на тази обща идея

2088
01:47:12,800 --> 01:47:14,451
на масив, или списък, или вектор.

2089
01:47:14,451 --> 01:47:16,450
И в зависимост от
контекст, всички тези думи

2090
01:47:16,450 --> 01:47:17,880
означава малко по-различни неща.

2091
01:47:17,880 --> 01:47:20,060
Така че в C, ние само ще
да се говори за масив.

2092
01:47:20,060 --> 01:47:23,840
И масив е парче
памет, всеки от които е

2093
01:47:23,840 --> 01:47:27,720
елементи са съседни, обратно,
да архивирате, за да архивирате, да върне.

2094
01:47:27,720 --> 01:47:31,970
>> И тези елементи са, обикновено,
от същия тип данни, характер,

2095
01:47:31,970 --> 01:47:35,966
характер, характер, характер, или
низ, низ, низ, низ, или INT,

2096
01:47:35,966 --> 01:47:38,600
INT, INT, каквото и да е
ние се опитваме да магазин.

2097
01:47:38,600 --> 01:47:42,540
Но в края на деня, това е
как изглежда концептуално.

2098
01:47:42,540 --> 01:47:44,530
Вие сте като вашия
памет или RAM на компютъра.

2099
01:47:44,530 --> 01:47:48,590
И ти го дерогиране в
идентичен размер кутии, в които

2100
01:47:48,590 --> 01:47:50,920
се завръщат, за да архивирате, да
обратно, за да направите резервно по този начин.

2101
01:47:50,920 --> 01:47:53,200
>> И това, което е хубаво за
тази идея, както и факта,

2102
01:47:53,200 --> 01:47:58,580
че можем да изразим стойности по този начин
с първия от нашите структури от данни

2103
01:47:58,580 --> 01:48:02,520
в класа, означава, че ние може да започне
за решаване на проблеми с код

2104
01:48:02,520 --> 01:48:04,079
че дойде толкова интуитивно в седмица 0.

2105
01:48:04,079 --> 01:48:05,870
Ще припомним телефона
книга например, където

2106
01:48:05,870 --> 01:48:09,110
ние използвахме разделяй и владей,
или двоично търсене алгоритъм,

2107
01:48:09,110 --> 01:48:13,220
да се пресее през цяло
куп имена и номера.

2108
01:48:13,220 --> 01:48:18,220
Но ние приехме, изземване, че това
телефонен указател е вече подредени,

2109
01:48:18,220 --> 01:48:21,630
че някой друг вече е имал
фигурни out-- даден списък с имена

2110
01:48:21,630 --> 01:48:24,430
и numbers-- как да ги азбучен ред.

2111
01:48:24,430 --> 01:48:26,950
И сега, че в C ние,
също имат способността

2112
01:48:26,950 --> 01:48:30,290
да се неща, не
физически в телефонен указател

2113
01:48:30,290 --> 01:48:34,220
но на практика в един компютър
памет, ще бъдем в състояние следващата седмица

2114
01:48:34,220 --> 01:48:38,470
да се въведе отново this-- първият
на нашите структури от данни в една array--

2115
01:48:38,470 --> 01:48:43,530
но по-важно, действителната компютър
научни алгоритми, изпълнявани

2116
01:48:43,530 --> 01:48:47,720
в код, с който можем да се съхранява
данни в структури като тази,

2117
01:48:47,720 --> 01:48:50,730
и след това започнете да го манипулира, и
действително да реши проблемите с него,

2118
01:48:50,730 --> 01:48:53,570
и да се изгради в началото на това,
в крайна сметка, програми в C,

2119
01:48:53,570 --> 01:48:56,730
в Python, в JavaScript,
заявки бази данни с SQL?

2120
01:48:56,730 --> 01:48:59,980
>> И ние ще видим, че всички от тях
различни идеи блокировка.

2121
01:48:59,980 --> 01:49:04,100
Но за сега, припомни, че
домейн, който представихме днес

2122
01:49:04,100 --> 01:49:06,920
е това нещо тук, и
света на криптографията.

2123
01:49:06,920 --> 01:49:11,200
И сред следващите вие ​​сами проблемите
ще реши е изкуството на криптографията,

2124
01:49:11,200 --> 01:49:13,630
кодиране и де-кодиране
информация и кодиране

2125
01:49:13,630 --> 01:49:15,930
и дешифрирането на текст,
и ако се приеме в крайна сметка

2126
01:49:15,930 --> 01:49:18,970
че вие ​​вече знаете какво
е под капака

2127
01:49:18,970 --> 01:49:21,860
така че, когато видите или получавате
подобно съобщение, можете

2128
01:49:21,860 --> 01:49:24,060
себе си може да го разчете.

2129
01:49:24,060 --> 01:49:26,740
Всичко това, както и по-следващия път.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [Възпроизвеждане на видео]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Току-що пристигна.

2133
01:49:32,970 --> 01:49:35,146
Отивам да отида посещение
си професор в колеж.

2134
01:49:35,146 --> 01:49:37,611
Да.

2135
01:49:37,611 --> 01:49:40,080
Здравейте.

2136
01:49:40,080 --> 01:49:40,660
Ти си.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Изчакайте!

2139
01:49:45,110 --> 01:49:45,610
Дейвид.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Аз просто се опитвам да разбера
какво се е случило с теб.

2142
01:49:56,060 --> 01:49:58,130
Моля, всичко може да се помогне.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Вие бяхте си колеж
съквартирант, не бяха ли?

2145
01:50:08,354 --> 01:50:10,770
Ти беше там с него, когато
той завърши проекта на CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [МУЗИКА]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Това Е CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Обичам това място.

2152
01:50:44,770 --> 01:50:45,854
>> -Изяждам.

2153
01:50:45,854 --> 01:50:47,020
Ние ще излязат от бизнеса.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END PLAYBACK]

