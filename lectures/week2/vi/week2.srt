1
00:00:00,000 --> 00:00:02,970
>> [NHẠC]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Malan: Tất cả các quyền.

4
00:00:15,700 --> 00:00:18,832
Đây là CS50 và điều này
là sự bắt đầu của tuần 2.

5
00:00:18,832 --> 00:00:21,040
Và bạn sẽ nhớ lại rằng hơn
quá khứ vài tuần,

6
00:00:21,040 --> 00:00:24,490
chúng tôi đã giới thiệu máy tính
khoa học và, lần lượt, lập trình.

7
00:00:24,490 --> 00:00:27,640
>> Và chúng tôi bắt đầu câu chuyện bằng cách
Scratch, mà ngôn ngữ đồ họa

8
00:00:27,640 --> 00:00:28,990
từ Media Lab của MIT'S.

9
00:00:28,990 --> 00:00:30,780
Và sau đó gần đây nhất,
tuần trước, chúng tôi đã làm

10
00:00:30,780 --> 00:00:34,450
giới thiệu một higher-- một
ngôn ngữ cấp thấp hơn được biết đến

11
00:00:34,450 --> 00:00:36,770
như C, một cái gì đó hoàn toàn là văn bản.

12
00:00:36,770 --> 00:00:39,440
Và, quả thật vậy, thời gian qua chúng tôi
khám phá trong bối cảnh

13
00:00:39,440 --> 00:00:40,450
một số khái niệm.

14
00:00:40,450 --> 00:00:43,010
>> , Thu hồi này, là rất
Chương trình đầu tiên chúng ta nhìn vào.

15
00:00:43,010 --> 00:00:45,710
Và chương trình này, khá đơn giản,
in ra, "hello, thế giới."

16
00:00:45,710 --> 00:00:47,730
Nhưng có rất nhiều
dường như kỳ diệu xảy ra.

17
00:00:47,730 --> 00:00:51,460
Có #include này
với các dấu ngoặc nhọn.

18
00:00:51,460 --> 00:00:52,170
Có int.

19
00:00:52,170 --> 00:00:53,020
Có (void).

20
00:00:53,020 --> 00:00:56,330
Có dấu ngoặc đơn, dấu ngoặc,
dấu chấm phẩy, và nhiều hơn nữa.

21
00:00:56,330 --> 00:00:58,480
>> Và như vậy, nhớ lại rằng
chúng tôi giới thiệu Scratch

22
00:00:58,480 --> 00:01:02,110
để chúng tôi có thể, tốt nhất, xem qua
rằng cú pháp, những thứ đó thực sự không

23
00:01:02,110 --> 00:01:04,590
tất cả những trí tuệ
thú vị, nhưng sớm

24
00:01:04,590 --> 00:01:07,700
là, hoàn toàn, một chút khéo léo
để hết tâm trí bạn.

25
00:01:07,700 --> 00:01:10,860
Và, quả thật vậy, một trong những phổ biến nhất
điều sớm trong một lớp học lập trình,

26
00:01:10,860 --> 00:01:13,443
đặc biệt là cho những người kém
thoải mái, là để có được thất vọng bởi

27
00:01:13,443 --> 00:01:17,460
vấp ngã bởi cú pháp nhất định
lỗi, chưa kể đến các lỗi logic.

28
00:01:17,460 --> 00:01:19,800
Và như vậy giữa các mục tiêu của chúng tôi
ngày hôm nay, thực sự, sẽ

29
00:01:19,800 --> 00:01:23,280
được trang bị cho bạn với một số
kỹ thuật giải quyết vấn đề như thế nào cho

30
00:01:23,280 --> 00:01:26,705
để giải quyết tốt hơn những vấn đề bản thân
trong các hình thức gỡ lỗi.

31
00:01:26,705 --> 00:01:29,330
Và bạn sẽ nhớ lại, quá, mà các
môi trường mà chúng tôi giới thiệu

32
00:01:29,330 --> 00:01:31,780
Lần cuối cùng được gọi là CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Đây là phần mềm dựa trên web
cho phép bạn để chương trình trong các đám mây,

34
00:01:34,850 --> 00:01:38,450
vậy để nói chuyện, trong khi vẫn giữ tất cả các bạn
tập tin với nhau, như chúng ta sẽ một lần nữa ngày hôm nay.

35
00:01:38,450 --> 00:01:41,480
Và nhớ lại chúng tôi rằng
xem xét lại các chủ đề này ở đây,

36
00:01:41,480 --> 00:01:44,480
trong đó có chức năng, và các vòng lặp, và
biến và biểu thức Boolean

37
00:01:44,480 --> 00:01:45,110
và điều kiện.

38
00:01:45,110 --> 00:01:49,190
Và trên thực tế một vài chi tiết mà chúng ta
dịch từ thế giới của Scratch

39
00:01:49,190 --> 00:01:50,800
với thế giới của C.

40
00:01:50,800 --> 00:01:53,220
>> Nhưng việc xây dựng cơ bản
khối, có thể nói,

41
00:01:53,220 --> 00:01:55,150
đã thực sự vẫn như nhau vào tuần trước.

42
00:01:55,150 --> 00:01:57,900
Trong thực tế, chúng tôi thực sự chỉ có một
khác nhau mảnh ghép, nếu bạn muốn.

43
00:01:57,900 --> 00:02:00,300
Thay vào đó màu tím
tiết kiệm khối, chúng tôi thay vì

44
00:02:00,300 --> 00:02:02,940
đã printf, đó là
chức năng này trong C

45
00:02:02,940 --> 00:02:05,890
cho phép bạn in một cái gì đó
và định dạng nó trên màn hình.

46
00:02:05,890 --> 00:02:07,950
Chúng tôi giới thiệu CS50
Thư viện, nơi bạn

47
00:02:07,950 --> 00:02:11,420
có tại get_char ý của bạn,
và get_int, và get_string,

48
00:02:11,420 --> 00:02:14,610
và một vài chức năng khác như
tốt, thông qua đó bạn có thể nhận được đầu vào

49
00:02:14,610 --> 00:02:16,260
từ bàn phím riêng của người dùng.

50
00:02:16,260 --> 00:02:20,640
Và chúng tôi cũng đã xem xét mọi thứ
như these- bool và char,

51
00:02:20,640 --> 00:02:22,490
và double, float,
int, string long_long.

52
00:02:22,490 --> 00:02:25,170
Và thậm chí còn có các kiểu dữ liệu khác trong C.

53
00:02:25,170 --> 00:02:28,560
>> Nói cách khác, khi bạn khai báo
một biến để lưu trữ một số giá trị,

54
00:02:28,560 --> 00:02:32,600
hoặc khi bạn thực hiện một chức năng
mà trả về một số giá trị,

55
00:02:32,600 --> 00:02:35,290
bạn có thể chỉ định những gì
loại của giá trị đó là.

56
00:02:35,290 --> 00:02:37,310
Nó là một chuỗi, như một
chuỗi các ký tự?

57
00:02:37,310 --> 00:02:39,490
Có một số, giống như một số nguyên?

58
00:02:39,490 --> 00:02:41,390
Có một điểm nổi
giá trị, hoặc như thế nào?

59
00:02:41,390 --> 00:02:46,180
Vì vậy, trong C, không giống như Scratch, chúng tôi thực sự
bắt đầu để xác định loại dữ liệu

60
00:02:46,180 --> 00:02:48,330
chúng tôi đã trở về hoặc sử dụng.

61
00:02:48,330 --> 00:02:51,910
>> Nhưng, tất nhiên, chúng tôi cũng chạy vào
một số giới hạn cơ bản của máy tính.

62
00:02:51,910 --> 00:02:54,100
Và đặc biệt,
này ngôn ngữ C, thu hồi

63
00:02:54,100 --> 00:02:57,070
mà chúng ta đã xem xét
tràn số nguyên, thực tế

64
00:02:57,070 --> 00:03:00,460
rằng nếu bạn chỉ có một
số lượng hữu hạn của bộ nhớ

65
00:03:00,460 --> 00:03:04,600
hay cụ thể, một số hữu hạn
bit, bạn chỉ có thể đếm quá cao.

66
00:03:04,600 --> 00:03:08,460
Và vì vậy chúng tôi đã xem xét ví dụ này đây
theo đó một truy cập trong một chiếc máy bay,,

67
00:03:08,460 --> 00:03:13,510
trên thực tế, nếu chạy đủ lâu sẽ
tràn và kết quả trong một phần mềm

68
00:03:13,510 --> 00:03:15,560
một lỗi tiềm năng vật lý thực tế.

69
00:03:15,560 --> 00:03:18,600
>> Chúng tôi cũng nhìn nổi
điểm không chính xác, thực tế

70
00:03:18,600 --> 00:03:22,280
mà chỉ có một số hữu hạn
bit, cho dù đó là 32 hoặc 64,

71
00:03:22,280 --> 00:03:27,330
bạn chỉ có thể chỉ định nhiều số
sau khi một điểm thập phân, sau đó bạn

72
00:03:27,330 --> 00:03:29,110
bắt đầu để có được chính xác.

73
00:03:29,110 --> 00:03:32,360
Vì vậy, ví dụ, một phần ba trong
thế giới ở đây, trong thế giới của con người,

74
00:03:32,360 --> 00:03:35,360
chúng ta biết chỉ là một số lượng vô hạn
của 3s sau dấu thập phân.

75
00:03:35,360 --> 00:03:38,820
Tuy nhiên, một máy tính có thể không nhất thiết phải
đại diện một số vô hạn các số

76
00:03:38,820 --> 00:03:42,590
nếu bạn chỉ cho phép nó một số
số lượng hữu hạn của thông tin.

77
00:03:42,590 --> 00:03:45,900
>> Vì vậy, chúng tôi không chỉ trang bị cho bạn
với sức mạnh lớn hơn trong điều kiện

78
00:03:45,900 --> 00:03:49,280
làm thế nào bạn có thể thể hiện chính mình tại
một bàn phím về lập trình,

79
00:03:49,280 --> 00:03:51,430
chúng tôi cũng giới hạn những gì
bạn thực sự có thể làm.

80
00:03:51,430 --> 00:03:55,790
Và quả thực, lỗi và những sai lầm có thể
phát sinh từ những loại vấn đề.

81
00:03:55,790 --> 00:03:59,900
Và quả thực, trong số các chủ đề hiện nay
sẽ được các chủ đề như gỡ lỗi

82
00:03:59,900 --> 00:04:03,699
và thực sự tìm kiếm bên dưới mui xe
cách điều đã được giới thiệu tuần trước

83
00:04:03,699 --> 00:04:05,490
đang thực sự thực hiện
để bạn tốt hơn

84
00:04:05,490 --> 00:04:10,530
hiểu cả những khả năng và
những hạn chế của một ngôn ngữ như C.

85
00:04:10,530 --> 00:04:14,770
>> Và trên thực tế, chúng tôi sẽ bóc lại các lớp
trong những đơn giản của cấu trúc dữ liệu,

86
00:04:14,770 --> 00:04:17,756
một cái gì đó gọi là một mảng, mà
Scratch xảy ra để gọi một "danh sách."

87
00:04:17,756 --> 00:04:19,589
Đó là một chút
khác nhau trong bối cảnh đó.

88
00:04:19,589 --> 00:04:23,340
Và sau đó chúng tôi cũng sẽ giới thiệu một trong những
đầu tiên của các vấn đề tên miền cụ thể của chúng tôi

89
00:04:23,340 --> 00:04:26,790
trong CS50, thế giới
mật mã học, nghệ thuật xáo trộn

90
00:04:26,790 --> 00:04:29,650
hoặc trong mã hoá thông tin để
bạn có thể gửi tin nhắn bí mật

91
00:04:29,650 --> 00:04:34,520
và giải mã thông điệp bí mật
giữa hai người, A và B.

92
00:04:34,520 --> 00:04:37,490
>> Vì vậy, trước khi chuyển chúng tôi
cho rằng thế giới mới,

93
00:04:37,490 --> 00:04:42,059
chúng ta hãy cố gắng trang bị cho bạn với một số
kỹ thuật mà bạn có thể loại bỏ

94
00:04:42,059 --> 00:04:43,850
hoặc ít nhất là giảm số
những nỗi thất vọng

95
00:04:43,850 --> 00:04:46,630
mà bạn có thể gặp phải
trong tuần vừa qua.

96
00:04:46,630 --> 00:04:50,830
Trong thực tế, trước mắt của bạn được such-- một số
vấn đề đầu tiên của bạn trong C. Và tỷ lệ cược là,

97
00:04:50,830 --> 00:04:54,010
nếu bạn đang như tôi, lần đầu tiên
bạn cố gắng để loại ra một chương trình,

98
00:04:54,010 --> 00:04:57,330
thậm chí nếu bạn suy nghĩ logic
chương trình khá đơn giản,

99
00:04:57,330 --> 00:05:01,200
bạn rất tốt có thể đánh một bức tường, và
trình biên dịch sẽ không hợp tác.

100
00:05:01,200 --> 00:05:03,940
Thực hiện hoặc Clang sẽ không
để thực sự làm đấu thầu của bạn.

101
00:05:03,940 --> 00:05:05,450
>> Và tại sao điều đó có thể được?

102
00:05:05,450 --> 00:05:07,950
Vâng, chúng ta hãy nhìn vào,
có lẽ, một chương trình đơn giản.

103
00:05:07,950 --> 00:05:11,190
Tôi sẽ đi trước và lưu này trong
một tập tin gọi là cố tình buggy0.c,

104
00:05:11,190 --> 00:05:13,590
bởi vì tôi biết nó đến
có những thiếu sót trước.

105
00:05:13,590 --> 00:05:17,400
Nhưng tôi có thể không nhận ra rằng nếu điều này
là chương trình đầu tiên hoặc thứ hai hoặc thứ ba

106
00:05:17,400 --> 00:05:18,830
rằng tôi thực sự làm cho bản thân mình.

107
00:05:18,830 --> 00:05:23,820
Vì vậy, tôi sẽ đi trước và
loại ra, int main (void).

108
00:05:23,820 --> 00:05:28,130
Và sau đó bên trong các dấu ngoặc nhọn của tôi,
rất quen thuộc ( "hello, world--

109
00:05:28,130 --> 00:05:30,980
xuyệc ngược, n ") - và một dấu chấm phẩy.

110
00:05:30,980 --> 00:05:32,360
>> Tôi đã lưu tập tin.

111
00:05:32,360 --> 00:05:34,850
Bây giờ tôi sẽ đi xuống
đến cửa sổ thiết bị đầu cuối của tôi

112
00:05:34,850 --> 00:05:40,340
và kiểu make buggy0, bởi vì, một lần nữa,
tên của tập tin hôm nay là buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Vì vậy, tôi gõ làm buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Và, ồ, trời ơi, nhớ lại từ lần cuối cùng
mà không có thông báo lỗi là một điều tốt.

115
00:05:48,200 --> 00:05:49,740
Vì vậy, không có đầu ra là một điều tốt.

116
00:05:49,740 --> 00:05:52,920
Nhưng ở đây tôi có rõ ràng
một số số những sai lầm.

117
00:05:52,920 --> 00:05:56,470
>> Vì vậy, dòng đầu tiên của đầu ra
sau khi nhập làm buggy0, thu hồi,

118
00:05:56,470 --> 00:05:59,540
là đầu ra khá dài dòng Clang của.

119
00:05:59,540 --> 00:06:02,067
Bên dưới mui xe,
CS50 IDE được cấu hình

120
00:06:02,067 --> 00:06:04,150
sử dụng một bó toàn bộ
tùy chọn với trình biên dịch này

121
00:06:04,150 --> 00:06:05,941
do đó bạn không có
để suy nghĩ về chúng.

122
00:06:05,941 --> 00:06:08,840
Và đó là tất cả những dòng đầu tiên
phương tiện bắt đầu với Clang.

123
00:06:08,840 --> 00:06:11,720
>> Nhưng sau đó, những vấn đề
bắt đầu làm cho sự xuất hiện của họ.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c trên dòng 3, nhân vật
5, có một lỗi lớn màu đỏ.

125
00:06:17,390 --> 00:06:18,380
Đó là gì?

126
00:06:18,380 --> 00:06:23,562
Ngầm tuyên bố chức năng thư viện
printf với kiểu int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Ý tôi là, nó rất nhanh chóng
sẽ rất phức tạp.

129
00:06:28,379 --> 00:06:30,170
Và chắc chắn, lần đầu tiên
Trong nháy mắt, chúng tôi sẽ không

130
00:06:30,170 --> 00:06:32,380
mong bạn hiểu được
toàn bộ các tin nhắn đó.

131
00:06:32,380 --> 00:06:34,213
Và vì vậy một trong những bài học
cho ngày hôm nay sẽ

132
00:06:34,213 --> 00:06:36,919
để được thử để ý
mô hình, hoặc những điều tương tự,

133
00:06:36,919 --> 00:06:38,960
lỗi bạn có thể có
gặp phải trong quá khứ.

134
00:06:38,960 --> 00:06:41,335
Vì vậy, hãy trêu chọc nhau chỉ
những từ mà trông quen thuộc.

135
00:06:41,335 --> 00:06:44,290
Việc lớn, báo lỗi màu đỏ rõ ràng là
biểu tượng của một cái gì đó là sai.

136
00:06:44,290 --> 00:06:47,940
>> ngầm tuyên bố
Thư viện hàm printf.

137
00:06:47,940 --> 00:06:51,680
Vì vậy, ngay cả khi tôi không hoàn toàn hiểu những gì
ngầm tuyên bố chức năng thư viện

138
00:06:51,680 --> 00:06:54,900
phương tiện, vấn đề chắc chắn
liên quan đến printf bằng cách nào đó.

139
00:06:54,900 --> 00:06:59,130
Và nguồn gốc của vấn đề đó
đã làm với tuyên bố nó.

140
00:06:59,130 --> 00:07:02,440
>> Khai báo một chức năng là
nhắc đến nó lần đầu tiên.

141
00:07:02,440 --> 00:07:06,210
Và chúng tôi sử dụng các thuật ngữ tuần trước
khai báo nguyên mẫu của một chức năng,

142
00:07:06,210 --> 00:07:11,860
hoặc với một dòng ở đầu của bạn
tập tin riêng hoặc trong một tập tin tiêu đề cái gọi là.

143
00:07:11,860 --> 00:07:15,300
Và trong những tập tin đã làm chúng ta nói
Tuần trước, printf là báo giá,

144
00:07:15,300 --> 00:07:17,080
unquote, tuyên bố?

145
00:07:17,080 --> 00:07:20,950
Trong tập tin những gì là nguyên mẫu của nó?

146
00:07:20,950 --> 00:07:24,640
>> Vì vậy, nếu bạn gọi lại, điều đầu tiên tôi
đánh máy, hầu hết các chương trình time-- cuối cùng

147
00:07:24,640 --> 00:07:30,790
và vô tình một thời điểm trước đây bắt đầu
gõ myself-- là này một đây--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- cho
đầu vào / output-- dot h Và quả thực,

149
00:07:38,630 --> 00:07:41,860
nếu bây giờ tôi lưu tập tin này, tôi sẽ
đi trước và xóa màn hình của tôi,

150
00:07:41,860 --> 00:07:44,740
mà bạn có thể làm bằng cách gõ
Rõ ràng, hoặc bạn có thể giữ Control L,

151
00:07:44,740 --> 00:07:47,680
chỉ để xóa sổ terminal của bạn
chỉ để loại bỏ một số lộn xộn.

152
00:07:47,680 --> 00:07:51,370
>> Tôi sẽ đi trước và
tái kiểu make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Và đây rồi, tôi vẫn nhận thấy rằng
lệnh dài từ Clang,

154
00:07:53,790 --> 00:07:55,470
nhưng không có thông báo lỗi thời gian này.

155
00:07:55,470 --> 00:07:58,800
Và quả thực, nếu tôi làm ./buggy0,
giống như thời gian qua,

156
00:07:58,800 --> 00:08:01,860
nơi dot nghĩa này
thư mục, Slash chỉ có nghĩa là,

157
00:08:01,860 --> 00:08:05,040
ở đây có tên của chương trình và
rằng tên của chương trình là buggy0,

158
00:08:05,040 --> 00:08:07,340
Nhập, "hello, thế giới."

159
00:08:07,340 --> 00:08:09,440
>> Bây giờ, làm thế nào bạn có thể có
lượm lặt giải pháp này

160
00:08:09,440 --> 00:08:12,017
mà không nhất thiết phải
công nhận càng nhiều từ

161
00:08:12,017 --> 00:08:14,350
như tôi đã làm, chắc chắn, có
làm điều này trong nhiều năm?

162
00:08:14,350 --> 00:08:18,720
Vâng, nhận ra mỗi vấn đề đầu tiên
thiết lập, chúng tôi giới thiệu bạn đến một lệnh

163
00:08:18,720 --> 00:08:21,175
rằng nhân viên của CS50 của
đã viết gọi là help50.

164
00:08:21,175 --> 00:08:24,300
Và quả thực, C không đặc điểm kỹ thuật
vấn đề thiết lập như thế nào để sử dụng này.

165
00:08:24,300 --> 00:08:27,210
>> Nhưng về cơ bản là help50
một chương trình mà nhân viên của CS50

166
00:08:27,210 --> 00:08:30,850
đã viết cho phép bạn chạy
một lệnh hoặc chạy một chương trình,

167
00:08:30,850 --> 00:08:36,169
và nếu bạn không hiểu nó
đầu ra, để vượt qua sản lượng của nó để help50,

168
00:08:36,169 --> 00:08:38,890
điểm mà tại đó các phần mềm
rằng nhân viên của khóa học đã viết

169
00:08:38,890 --> 00:08:42,429
sẽ xem xét đầu ra của chương trình của bạn
từng dòng, từng ký tự.

170
00:08:42,429 --> 00:08:46,000
Và nếu chúng tôi, các nhân viên, công nhận
thông báo lỗi mà bạn đang gặp phải,

171
00:08:46,000 --> 00:08:50,580
chúng tôi sẽ cố gắng để gây cho bạn một số
câu hỏi tu từ, với một số lời khuyên,

172
00:08:50,580 --> 00:08:54,890
giống như một TF hoặc một CA hoặc bản thân mình
sẽ làm trực tiếp tại văn phòng giờ.

173
00:08:54,890 --> 00:08:58,320
>> Vì vậy, nhìn vào help50 nếu bạn không
nhất thiết phải nhận ra một vấn đề.

174
00:08:58,320 --> 00:09:00,790
Nhưng đừng dựa vào nó
quá nhiều như một cái nạng.

175
00:09:00,790 --> 00:09:03,990
Chắc chắn cố gắng hiểu nó
đầu ra và sau đó học hỏi từ nó

176
00:09:03,990 --> 00:09:07,571
do đó chỉ một lần hoặc hai lần làm bạn
bao giờ chạy help50 cho một lỗi cụ thể

177
00:09:07,571 --> 00:09:08,070
thông điệp.

178
00:09:08,070 --> 00:09:10,660
Sau đó, bạn nên có
trang bị tốt hơn cho mình

179
00:09:10,660 --> 00:09:13,180
để tìm ra những gì nó thực sự là.

180
00:09:13,180 --> 00:09:14,350
>> Hãy làm một khác ở đây.

181
00:09:14,350 --> 00:09:20,410
Hãy để tôi đi trước, và trong một
tập tin chúng tôi sẽ gọi buggy1.c này.

182
00:09:20,410 --> 00:09:23,110
Và trong tập tin này tôi
sẽ deliberately--

183
00:09:23,110 --> 00:09:26,330
nhưng giả vờ rằng tôi không
hiểu những gì sai lầm tôi đã thực hiện.

184
00:09:26,330 --> 00:09:31,420
>> Tôi sẽ đi trước và làm này--
#include, kể từ khi tôi đã

185
00:09:31,420 --> 00:09:33,660
học được bài học của tôi từ lúc nãy.

186
00:09:33,660 --> 00:09:36,220
Int main (void), như trước đây.

187
00:09:36,220 --> 00:09:40,880
Và sau đó ở đây tôi sẽ
để làm chuỗi s - get_string.

188
00:09:40,880 --> 00:09:43,770
Và nhớ lại từ lần cuối cùng
phương tiện này, hey, máy tính,

189
00:09:43,770 --> 00:09:48,280
cho tôi một biến, gọi nó là, và
làm kiểu của biến mà một chuỗi

190
00:09:48,280 --> 00:09:50,150
vì vậy tôi có thể lưu trữ một hoặc nhiều từ trong đó.

191
00:09:50,150 --> 00:09:52,191
>> Và sau đó vào cánh tay phải
bên của dấu bằng

192
00:09:52,191 --> 00:09:54,980
được get_string, mà là một
chức năng trong thư viện CS50

193
00:09:54,980 --> 00:09:55,980
thực hiện chính xác đó.

194
00:09:55,980 --> 00:09:59,740
Nó được một chức năng và sau đó
tay nó từ phải sang trái.

195
00:09:59,740 --> 00:10:02,670
Vì vậy, dấu bằng này không có nghĩa là
"Bằng" như chúng ta có thể nghĩ rằng trong toán học.

196
00:10:02,670 --> 00:10:04,750
Nó có nghĩa là chuyển nhượng từ phải sang trái.

197
00:10:04,750 --> 00:10:09,640
Vì vậy, điều này có nghĩa, lấy chuỗi từ
người sử dụng và lưu trữ nó bên trong của s.

198
00:10:09,640 --> 00:10:10,460
>> Bây giờ chúng ta hãy sử dụng nó.

199
00:10:10,460 --> 00:10:13,820
Hãy để tôi đi trước bây giờ và như một thứ hai
dòng, hãy để tôi đi trước và nói "xin chào" -

200
00:10:13,820 --> 00:10:19,330
không phải là "thế giới", nhưng "hello,% s--
đó là giữ chỗ của chúng tôi, dấu phẩy s,

201
00:10:19,330 --> 00:10:22,030
đó là biến của chúng tôi,
và sau đó là một dấu chấm phẩy.

202
00:10:22,030 --> 00:10:26,070
Vì vậy, nếu tôi không vít lên quá nhiều
ở đây, điều này trông giống như mã đúng.

203
00:10:26,070 --> 00:10:28,090
>> Và bản năng của tôi bây giờ là để biên dịch nó.

204
00:10:28,090 --> 00:10:30,400
Các tập tin được gọi là buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Vì vậy, tôi sẽ làm làm cho buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Và darn-nó, nếu không có
thậm chí lỗi nhiều hơn so với trước đây.

207
00:10:36,377 --> 00:10:38,210
Ý tôi là, có nhiều
thông báo lỗi nó sẽ

208
00:10:38,210 --> 00:10:40,400
vẻ hơn dòng thực tế trong chương trình này.

209
00:10:40,400 --> 00:10:42,730
>> Nhưng takeaway ở đây là,
ngay cả khi bạn đang bị choáng ngợp

210
00:10:42,730 --> 00:10:45,040
với hai hoặc ba hoặc
bốn thông điệp báo lỗi hơn,

211
00:10:45,040 --> 00:10:48,340
tập trung luôn trên rất
đầu tiên của những tin nhắn.

212
00:10:48,340 --> 00:10:52,220
Nhìn vào top-nhất một,
di chuyển trở lại lên nếu thấy cần thiết.

213
00:10:52,220 --> 00:10:53,930
Vì vậy, ở đây tôi gõ make buggy1.

214
00:10:53,930 --> 00:10:55,700
Dưới đây là sản lượng Clang như mong đợi.

215
00:10:55,700 --> 00:10:57,290
>> Và đây là lỗi màu đỏ đầu tiên.

216
00:10:57,290 --> 00:11:02,370
Sử dụng định không khai báo
chuỗi, đã làm tôi có nghĩa là tiêu chuẩn trong?

217
00:11:02,370 --> 00:11:04,260
Vì vậy, trong các ý kiến
thực sự cái gì khác.

218
00:11:04,260 --> 00:11:06,240
Nó đề cập đến những người sử dụng của
bàn phím, về cơ bản.

219
00:11:06,240 --> 00:11:08,080
>> Nhưng đó không phải là những gì tôi muốn nói.

220
00:11:08,080 --> 00:11:11,770
Tôi có nghĩa là chuỗi, và tôi có nghĩa là get_string.

221
00:11:11,770 --> 00:11:16,200
Vì vậy, nó là những gì mà tôi
quên để làm thời gian này?

222
00:11:16,200 --> 00:11:20,230
Những gì còn thiếu thời gian này?

223
00:11:20,230 --> 00:11:23,600
Tôi có #include của tôi,
vì vậy tôi có quyền truy cập vào printf.

224
00:11:23,600 --> 00:11:26,090
>> Nhưng những gì tôi không có
truy cập vào chỉ chưa?

225
00:11:26,090 --> 00:11:29,420
Vâng, giống như thời gian qua,
Tôi cần phải nói với trình biên dịch

226
00:11:29,420 --> 00:11:31,691
Clang những gì các chức năng này.

227
00:11:31,691 --> 00:11:33,940
Get_string không đến
C. Và đặc biệt, nó

228
00:11:33,940 --> 00:11:38,160
không đến ở
tiêu đề tập tin,.

229
00:11:38,160 --> 00:11:40,770
Nó thay vì đi kèm trong
một cái gì đó các nhân viên đã viết,

230
00:11:40,770 --> 00:11:44,176
mà là một tập tin khác nhau
tên nhưng đã khéo léo đặt tên.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Vì vậy, chỉ đơn giản bằng cách thêm vào đó một dòng
thu hồi code-- từ lần cuối cùng

233
00:11:50,861 --> 00:11:53,610
rằng khi Clang chạy, nó sẽ
để xem mã hàng đầu của tôi xuống dưới,

234
00:11:53,610 --> 00:11:54,193
trái sang phải.

235
00:11:54,193 --> 00:11:57,200
Nó sẽ để ý,
oh, bạn muốn.

236
00:11:57,200 --> 00:11:59,900
Hãy để tôi đi và thấy rằng,
bất cứ nơi nào nó là trên máy chủ,

237
00:11:59,900 --> 00:12:03,090
sao chép và dán nó, về cơ bản,
vào đầu tập tin riêng của bạn

238
00:12:03,090 --> 00:12:06,820
vì vậy mà vào thời điểm này trong câu chuyện,
dòng 1, phần còn lại của chương trình

239
00:12:06,820 --> 00:12:11,651
có thể, thực sự, sử dụng bất kỳ chức năng
trong đó, trong đó get_string.

240
00:12:11,651 --> 00:12:13,650
Vì vậy, tôi sẽ bỏ qua
phần còn lại của những sai sót,

241
00:12:13,650 --> 00:12:17,190
bởi vì tôi, thực sự, nghi ngờ rằng chỉ
người đầu tiên thực sự quan trọng.

242
00:12:17,190 --> 00:12:20,780
Và tôi sẽ đi trước và chạy lại,
sau khi lưu file của tôi làm cho buggy1.

243
00:12:20,780 --> 00:12:22,580
Và đây rồi, nó đã làm việc.

244
00:12:22,580 --> 00:12:29,200
Và nếu tôi làm ./buggy1 và gõ, cho
Ví dụ, Zamyla, bây giờ tôi sẽ nhận được hello,

245
00:12:29,200 --> 00:12:32,000
Zamyla, thay vì xin chào, thế giới.

246
00:12:32,000 --> 00:12:32,550
>> Tất cả các quyền.

247
00:12:32,550 --> 00:12:35,890
Vì vậy, các takeaways ở đây sau đó là tới,
một, cố gắng thu thập càng nhiều như bạn có thể

248
00:12:35,890 --> 00:12:39,140
từ các thông báo lỗi một mình, nhìn
ở một số từ dễ nhận biết.

249
00:12:39,140 --> 00:12:43,070
Chặn điều đó, sử dụng help50 mỗi
vấn đề thiết lập đặc điểm kỹ thuật.

250
00:12:43,070 --> 00:12:46,500
Nhưng chặn điều đó, quá, luôn luôn tìm
tại các lỗi trên chỉ, ít nhất

251
00:12:46,500 --> 00:12:50,051
Ban đầu, để xem thông tin
nó thực sự có thể mang lại.

252
00:12:50,051 --> 00:12:52,300
Nhưng hóa ra có của
nhiều chức năng hơn được xây dựng

253
00:12:52,300 --> 00:12:55,030
vào thư viện để giúp CS50
bạn sớm trong học kỳ

254
00:12:55,030 --> 00:12:57,580
và sớm trong lập trình
tìm ra những gì đang xảy ra sai.

255
00:12:57,580 --> 00:12:59,840
Vì vậy, chúng ta hãy làm một ví dụ khác ở đây.

256
00:12:59,840 --> 00:13:04,350
Tôi sẽ gọi buggy2 này, trong đó,
một lần nữa, sẽ có những thiếu sót ra

257
00:13:04,350 --> 00:13:05,650
của các cửa khẩu, do thiết kế.

258
00:13:05,650 --> 00:13:09,980
>> Và tôi sẽ đi trước
và làm #include.

259
00:13:09,980 --> 00:13:12,580
Và sau đó tôi sẽ làm int main (void).

260
00:13:12,580 --> 00:13:14,840
Và sau đó tôi sẽ làm cho vòng lặp.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i nhỏ hơn hoặc bằng 10.

263
00:13:18,750 --> 00:13:24,260
i ++, và sau đó trong dấu ngoặc, tôi sẽ
để in ra chỉ là một biểu tượng hashtag đây

264
00:13:24,260 --> 00:13:25,920
và một ký tự dòng mới.

265
00:13:25,920 --> 00:13:29,220
>> Vì vậy, ý định của tôi với điều này
chương trình khá đơn giản

266
00:13:29,220 --> 00:13:33,150
để lặp 10 lần
và trên mỗi lần lặp

267
00:13:33,150 --> 00:13:35,260
vòng lặp đó mỗi lần
thông qua các chu kỳ,

268
00:13:35,260 --> 00:13:37,660
in ra một hashtag,
hashtag, hashtag.

269
00:13:37,660 --> 00:13:40,480
Một dòng mỗi vì tôi
có dòng mới có.

270
00:13:40,480 --> 00:13:42,787
Và nhớ lại rằng cho
vòng lặp, mỗi week-- cuối cùng

271
00:13:42,787 --> 00:13:44,620
và bạn sẽ nhận được nhiều hơn
quen thuộc với cú pháp

272
00:13:44,620 --> 00:13:47,170
bằng cách sử dụng nó với thực tế
trước long-- này mang lại cho tôi

273
00:13:47,170 --> 00:13:49,740
một biến gọi tôi và đặt nó vào 0.

274
00:13:49,740 --> 00:13:52,650
>> Đây increments i trên
mỗi lần lặp bằng 1.

275
00:13:52,650 --> 00:13:54,940
Vì vậy, tôi đi đến 1 đến 2-3.

276
00:13:54,940 --> 00:13:57,690
Và sau đó tình trạng này ở các
trung gian giữa các dấu chấm phẩy

277
00:13:57,690 --> 00:14:03,010
được kiểm tra mỗi lần lặp để làm cho
chắc chắn rằng chúng tôi vẫn còn trong phạm vi.

278
00:14:03,010 --> 00:14:06,830
Vì vậy, tôi muốn lặp 10 lần, vì vậy tôi
có loại rất trực giác chỉ

279
00:14:06,830 --> 00:14:09,070
đưa 10 như ràng buộc trên của tôi ở đó.

280
00:14:09,070 --> 00:14:14,310
>> Thế nhưng, khi tôi chạy này, sau khi
biên dịch nó với make buggy2--

281
00:14:14,310 --> 00:14:15,440
và nó biên dịch OK.

282
00:14:15,440 --> 00:14:17,980
Vì vậy, tôi không có một
lỗi cú pháp lần này.

283
00:14:17,980 --> 00:14:20,940
Hãy để tôi đi trước nay
và chạy buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Và bây giờ di chuyển lên.

285
00:14:22,620 --> 00:14:24,890
Và hãy để tôi tăng
kích thước của cửa sổ.

286
00:14:24,890 --> 00:14:33,720
>> Tôi dường như có 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Vì vậy, có 11 hashtags, mặc dù
Tôi đặt rõ 10 bên trong vòng lặp này.

288
00:14:38,891 --> 00:14:42,140
Bây giờ, một số bạn có thể thấy ngay lập tức
những gì lỗi là bởi vì, thực sự, điều này

289
00:14:42,140 --> 00:14:43,720
không phải là một lỗi rất khó để thực hiện.

290
00:14:43,720 --> 00:14:46,070
Nhưng nó rất phổ biến
thực hiện rất sớm.

291
00:14:46,070 --> 00:14:49,820
>> Những gì tôi muốn chỉ ra, mặc dù,
là, làm thế nào tôi có thể con số này ra?

292
00:14:49,820 --> 00:14:52,300
Vâng, nó chỉ ra rằng
Thư viện CS50 đến

293
00:14:52,300 --> 00:14:55,380
với không chỉ get_string và get_int
và get_float và các chức năng khác.

294
00:14:55,380 --> 00:14:59,980
Nó cũng đi kèm với một chức năng đặc biệt
gọi eprintf, hoặc, lỗi printf.

295
00:14:59,980 --> 00:15:03,270
Và nó tồn tại chỉ để làm cho
nó một chút dễ dàng hơn cho bạn

296
00:15:03,270 --> 00:15:06,310
khi gỡ lỗi mã của bạn để chỉ
in một thông báo lỗi trên màn hình

297
00:15:06,310 --> 00:15:07,850
và biết nó đến từ đâu.

298
00:15:07,850 --> 00:15:11,000
>> Vì vậy, ví dụ, có một điều tôi có thể
làm ở đây với chức năng này là này--

299
00:15:11,000 --> 00:15:20,230
eprintf, và sau đó tôi sẽ đi trước
và nói rằng tôi bây giờ là% i, dấu gạch chéo, n.

300
00:15:20,230 --> 00:15:22,330
Và tôi sẽ cắm vào giá trị của i.

301
00:15:22,330 --> 00:15:25,400
Và lên hàng đầu, bởi vì đây
là trong Thư viện CS50,

302
00:15:25,400 --> 00:15:27,580
Tôi sẽ đi trước
và bao gồm

303
00:15:27,580 --> 00:15:29,169
vì vậy tôi có quyền truy cập vào chức năng này.

304
00:15:29,169 --> 00:15:31,460
Nhưng chúng ta hãy xem xét những gì dòng
9 là vụ phải được làm.

305
00:15:31,460 --> 00:15:32,670
Tôi sẽ xóa này cuối cùng.

306
00:15:32,670 --> 00:15:34,670
Điều này không có gì để làm
với mục tiêu bao trùm của tôi.

307
00:15:34,670 --> 00:15:39,090
Nhưng eprintf, lỗi printf, chỉ là nghĩa
để cung cấp cho tôi một số thông tin chẩn đoán.

308
00:15:39,090 --> 00:15:42,460
Khi tôi chạy chương trình của tôi, tôi muốn
thấy điều này trên màn hình tạm thời

309
00:15:42,460 --> 00:15:44,550
cũng chỉ để hiểu
những gì đang xảy ra.

310
00:15:44,550 --> 00:15:47,330
>> Và, quả thật vậy, trên mỗi
lặp đi lặp lại ở đây của dòng 9

311
00:15:47,330 --> 00:15:49,260
Tôi muốn nhìn thấy, giá trị của tôi là gì?

312
00:15:49,260 --> 00:15:50,290
giá trị của tôi là gì?

313
00:15:50,290 --> 00:15:51,280
giá trị của tôi là gì?

314
00:15:51,280 --> 00:15:55,650
Và, hy vọng, tôi chỉ nên
thấy rằng thông điệp, cũng, gấp 10 lần.

315
00:15:55,650 --> 00:15:57,780
>> Vì vậy, hãy để tôi đi trước và
biên dịch lại chương trình của tôi,

316
00:15:57,780 --> 00:15:59,905
như tôi phải làm bất cứ lúc nào
Tôi làm cho một sự thay đổi. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Và now-- OK.

319
00:16:03,640 --> 00:16:04,820
Có rất nhiều nhiều đang xảy ra.

320
00:16:04,820 --> 00:16:07,610
Vì vậy, hãy để tôi di chuyển lên trong
một cửa sổ lớn hơn.

321
00:16:07,610 --> 00:16:10,190
>> Và bạn sẽ thấy rằng mỗi
các hashtags vẫn in.

322
00:16:10,190 --> 00:16:15,270
Nhưng ở giữa mỗi trong số họ giờ đây là
chẩn đoán sản lượng được định dạng như sau.

323
00:16:15,270 --> 00:16:17,960
Tên của chương trình của tôi ở đây là buggy2.

324
00:16:17,960 --> 00:16:20,432
Tên của tập tin là buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Số đường mà từ đó
này đã được in là dòng 9.

326
00:16:24,080 --> 00:16:27,500
Và sau đó bên phải đó là
thông báo lỗi mà tôi đang mong đợi.

327
00:16:27,500 --> 00:16:30,701
>> Và những gì là tốt đẹp về việc này là
bây giờ tôi không phải nhất thiết phải đếm

328
00:16:30,701 --> 00:16:32,200
trong đầu của tôi những gì chương trình của tôi đang làm.

329
00:16:32,200 --> 00:16:34,240
Tôi có thể thấy rằng trên
Phiên đầu tiên tôi là 0,

330
00:16:34,240 --> 00:16:39,420
sau đó 1, sau đó 2, sau đó 3, sau đó 4, sau đó
5, sau đó 6, sau đó 7, sau đó 8, sau đó 9, sau đó

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Vì vậy, chờ một phút.

333
00:16:42,050 --> 00:16:43,740
Những gì đang xảy ra ở đây?

334
00:16:43,740 --> 00:16:48,190
Tôi dường như vẫn được đếm
như dự định lên đến 10.

335
00:16:48,190 --> 00:16:50,550
>> Nhưng mà tôi lại bắt đầu?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Vì vậy, 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- ngón tay thứ 11

338
00:16:58,040 --> 00:16:59,990
là biểu hiện của vấn đề.

339
00:16:59,990 --> 00:17:02,850
Tôi dường như đã tính
không đúng trong vòng lặp của tôi.

340
00:17:02,850 --> 00:17:06,599
Thay vì đi 10 lần lặp lại,
Tôi đang bắt đầu từ 0,

341
00:17:06,599 --> 00:17:09,550
Tôi kết thúc tại và thông qua 10.

342
00:17:09,550 --> 00:17:12,030
Nhưng bởi vì, giống như một máy tính,
Tôi bắt đầu đếm từ 0,

343
00:17:12,030 --> 00:17:15,250
Tôi nên đếm lên
để, nhưng không thông qua, 10.

344
00:17:15,250 --> 00:17:18,510
>> Và vì vậy việc sửa chữa, tôi cuối cùng
nhận ra ở đây, là một trong hai điều.

345
00:17:18,510 --> 00:17:22,430
Tôi có thể rất đơn giản nói
đếm đến nhỏ hơn 10.

346
00:17:22,430 --> 00:17:27,260
Vì vậy, 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, đó là, trên thực tế, chính xác,

347
00:17:27,260 --> 00:17:28,900
mặc dù nó có vẻ một chút sai.

348
00:17:28,900 --> 00:17:35,070
Hoặc tôi có thể làm nhỏ hơn hoặc bằng
đến 9, miễn là tôi bắt đầu từ 0.

349
00:17:35,070 --> 00:17:40,056
Hoặc nếu bạn thực sự không thích điều đó, bạn
có thể đếm lên qua 10 nhưng bắt đầu từ 1.

350
00:17:40,056 --> 00:17:41,680
Nhưng một lần nữa, điều này chỉ là không phải là phổ biến.

351
00:17:41,680 --> 00:17:43,977
Trong programming-- dù
không quá nhiều trong Scratch--

352
00:17:43,977 --> 00:17:45,810
nhưng trong lập trình
C và các ngôn ngữ khác,

353
00:17:45,810 --> 00:17:47,670
như JavaScript và
Python và những người khác, đó là

354
00:17:47,670 --> 00:17:49,880
chỉ rất phổ biến cho
thảo luận của chúng ta về nhị phân

355
00:17:49,880 --> 00:17:53,450
chỉ bắt đầu đếm tại
số thấp nhất bạn có thể, mà là 0.

356
00:17:53,450 --> 00:17:53,950
Tất cả các quyền.

357
00:17:53,950 --> 00:17:55,160
Vì vậy, đó là eprintf.

358
00:17:55,160 --> 00:17:58,600
Và một lần nữa, bây giờ mà tôi đã tìm ra tôi
vấn đề, và tôi sẽ trở về 0

359
00:17:58,600 --> 00:18:01,470
qua ít hơn 10, tôi sẽ
để đi vào và xóa eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Nó không nên có khi tôi
tàu mã của tôi hoặc gửi mã của tôi

361
00:18:04,580 --> 00:18:05,800
hoặc hiển thị nó cho bất cứ ai khác.

362
00:18:05,800 --> 00:18:07,980
Nó thực sự chỉ có nghĩa là
được sử dụng tạm thời.

363
00:18:07,980 --> 00:18:11,650
Nhưng bây giờ tôi đã cố định này
vấn đề cụ thể là tốt.

364
00:18:11,650 --> 00:18:16,780
>> Vâng, chúng ta hãy làm một ví dụ nữa đây
rằng tôi sẽ whip lên như sau.

365
00:18:16,780 --> 00:18:22,850
Tôi sẽ đi trước và
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
Và tôi sẽ đi trước
và #include.

367
00:18:25,580 --> 00:18:29,030
>> Và tôi sẽ tiết kiệm
tập tin này như buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Và tôi sẽ đi trước
và tuyên bố int main (void).

369
00:18:31,740 --> 00:18:34,186
Và sau đó bên trong có
Tôi sẽ làm int i _ -

370
00:18:34,186 --> 00:18:36,435
Tôi muốn thực hiện một chương trình
với một get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Đây không phải là một chức năng mà tồn tại chưa.

373
00:18:40,770 --> 00:18:42,870
Vì vậy, chúng ta sẽ thực hiện
nó chỉ trong một khoảnh khắc.

374
00:18:42,870 --> 00:18:45,541
Nhưng chúng ta sẽ thấy tại sao
đó là lỗi tại đầu tiên vượt qua.

375
00:18:45,541 --> 00:18:47,290
Và một khi tôi đã nhận được
một int từ người sử dụng,

376
00:18:47,290 --> 00:18:53,365
Tôi chỉ cần đi để in% i là tiêu cực
số nguyên, dấu gạch chéo, n, dấu phẩy, i.

377
00:18:53,365 --> 00:18:55,240
Nói cách khác, tất cả tôi
muốn chương trình này để làm

378
00:18:55,240 --> 00:18:58,000
là có được một int tiêu cực từ
người sử dụng và sau đó in ra

379
00:18:58,000 --> 00:18:59,980
mà như vậy và như vậy là một int tiêu cực.

380
00:18:59,980 --> 00:19:02,080
>> Bây giờ tôi cần phải thực hiện chức năng này.

381
00:19:02,080 --> 00:19:05,740
Vì vậy, sau này trong tập tin của tôi, tôi sẽ đi
trước và tuyên bố một chức năng gọi là

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - và chúng tôi sẽ
trở về với những dòng đó có nghĩa là một lần nữa

383
00:19:10,670 --> 00:19:18,790
trong một moment-- int n; do-- làm
các following-- printf n là :.

384
00:19:18,790 --> 00:19:26,210
Và sau đó tôi sẽ làm n - get_int,
và làm trong khi n này là lớn hơn 0.

385
00:19:26,210 --> 00:19:28,310
Và sau đó trở n ;.

386
00:19:28,310 --> 00:19:31,730
>> Vì vậy, có rất nhiều xảy ra trong
này, nhưng không ai trong số đó chúng tôi đã không

387
00:19:31,730 --> 00:19:33,710
nhìn vào tuần trước, ít nhất một thời gian ngắn.

388
00:19:33,710 --> 00:19:36,980
Vì vậy, trên đường 10 ở đây tôi đã tuyên bố một
chức năng gọi get_negative_int,

389
00:19:36,980 --> 00:19:39,620
và tôi đã đặt (void), trong
dấu ngoặc đơn, lý do là đây

390
00:19:39,620 --> 00:19:40,950
không mất một đầu vào.

391
00:19:40,950 --> 00:19:42,910
Tôi không đi qua bất cứ điều gì
chức năng này.

392
00:19:42,910 --> 00:19:44,690
Tôi chỉ nhận được một cái gì đó trở lại từ nó.

393
00:19:44,690 --> 00:19:47,270
>> Và những gì tôi hy vọng
được trở lại là một số nguyên.

394
00:19:47,270 --> 00:19:50,040
Không có kiểu dữ liệu trong
C được gọi là negative_int.

395
00:19:50,040 --> 00:19:52,880
Nó chỉ là int, vì vậy nó sẽ
để trên chúng tôi để đảm bảo

396
00:19:52,880 --> 00:19:55,340
rằng giá trị đó là thực sự
trở lại không chỉ một int

397
00:19:55,340 --> 00:19:56,380
nhưng cũng là tiêu cực.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 Tôi đang khai báo một biến
gọi n và làm cho nó có kiểu int.

399
00:20:02,150 --> 00:20:07,500
Và sau đó trong dòng 13 đến 18 Tôi
làm một cái gì đó trong khi một cái gì đó là sự thật.

400
00:20:07,500 --> 00:20:11,040
Tôi đi trước và in ấn
n là, ruột kết, và sau đó là một không gian,

401
00:20:11,040 --> 00:20:12,800
như một nhắc nhở cho người sử dụng.

402
00:20:12,800 --> 00:20:16,410
>> Tôi sau đó gọi get_int và
lưu trữ được gọi là giá trị trả về của nó

403
00:20:16,410 --> 00:20:18,130
trong đó biến n.

404
00:20:18,130 --> 00:20:22,600
Nhưng tôi sẽ tiếp tục làm
trong khi n này là lớn hơn 0.

405
00:20:22,600 --> 00:20:27,960
Nói cách khác, nếu người sử dụng mang lại cho tôi một
int và con số này lớn hơn 0,

406
00:20:27,960 --> 00:20:31,180
ergo, tích cực, tôi sẽ
chỉ cần giữ reprompting người sử dụng,

407
00:20:31,180 --> 00:20:37,160
giữ reprompting, bằng cách buộc chúng
hợp tác và cung cấp cho tôi một int tiêu cực.

408
00:20:37,160 --> 00:20:41,640
>> Và một khi n là thực sự negative--
giả sử người sử dụng cuối cùng loại -50,

409
00:20:41,640 --> 00:20:46,710
sau đó vòng lặp trong khi điều này không còn đúng
vì -50 là không lớn hơn 0.

410
00:20:46,710 --> 00:20:51,140
Vì vậy, chúng ta thoát ra khỏi đó
vòng lặp một cách hợp lý và trả lại n.

411
00:20:51,140 --> 00:20:53,520
>> Nhưng có một khác
điều tôi phải làm.

412
00:20:53,520 --> 00:20:56,190
Và tôi chỉ có thể làm điều này
bằng cách sao chép và dán

413
00:20:56,190 --> 00:20:58,540
một dòng mã ở trên cùng của tập tin.

414
00:20:58,540 --> 00:21:01,630
Tôi cần dạy Clang,
hoặc hứa sẽ kêu vang,

415
00:21:01,630 --> 00:21:04,630
một cách rõ ràng rằng tôi sẽ,
thực sự, hãy đi và thực hiện

416
00:21:04,630 --> 00:21:06,020
Chức năng này get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Nó chỉ có thể là thấp hơn trong tập tin.

418
00:21:07,674 --> 00:21:09,840
Một lần nữa, nhớ lại rằng Clang
đọc những thứ trên xuống dưới,

419
00:21:09,840 --> 00:21:12,330
trái sang phải, vì vậy bạn có thể không
gọi một chức năng nếu Clang

420
00:21:12,330 --> 00:21:15,330
không biết nó sẽ tồn tại.

421
00:21:15,330 --> 00:21:18,430
>> Bây giờ, không may, chương trình này,
như một số bạn có thể thấy,

422
00:21:18,430 --> 00:21:19,590
là đã có lỗi.

423
00:21:19,590 --> 00:21:21,400
Hãy để tôi đi trước và thực hiện buggy3.

424
00:21:21,400 --> 00:21:26,904
Nó biên dịch, vì vậy vấn đề của tôi bây giờ không phải là
lỗi cú pháp, giống như một lỗi văn bản,

425
00:21:26,904 --> 00:21:29,570
nó thực sự sẽ là một logic
lỗi mà tôi đã cố tình

426
00:21:29,570 --> 00:21:32,450
thực hiện như một cơ hội để
bước qua những gì đang xảy ra.

427
00:21:32,450 --> 00:21:35,540
>> Tôi sẽ đi trước
bây giờ và chạy buggy3.

428
00:21:35,540 --> 00:21:37,490
Và tôi sẽ đi
trước và không hợp tác.

429
00:21:37,490 --> 00:21:39,494
Tôi sẽ cung cấp cho nó số 1.

430
00:21:39,494 --> 00:21:41,410
Nó không thích nó, vì vậy
nó khiến tôi một lần nữa.

431
00:21:41,410 --> 00:21:42,147
>> Làm thế nào về 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Không ai trong số những người đang làm việc.

435
00:21:44,740 --> 00:21:46,890
Làm thế nào về -50?

436
00:21:46,890 --> 00:21:48,560
Và chương trình dường như làm việc.

437
00:21:48,560 --> 00:21:49,970
>> Hãy để tôi thử nó một lần nữa.

438
00:21:49,970 --> 00:21:53,400
Hãy để tôi thử -1, dường như làm việc.

439
00:21:53,400 --> 00:21:56,380
Hãy để tôi thử -2, dường như làm việc.

440
00:21:56,380 --> 00:21:59,640
Hãy để tôi thử 0.

441
00:21:59,640 --> 00:22:01,684
Huh, đó là không chính xác.

442
00:22:01,684 --> 00:22:03,350
Bây giờ, chúng tôi đang được một chút mô phạm ở đây.

443
00:22:03,350 --> 00:22:07,090
Nhưng đó là, thực sự, những trường hợp đó 0
không phải là tích cực hay tiêu cực.

444
00:22:07,090 --> 00:22:11,150
Và do đó, thực tế là chương trình của tôi là
nói rằng 0 là một số nguyên âm,

445
00:22:11,150 --> 00:22:12,820
đó không phải là kỹ thuật chính xác.

446
00:22:12,820 --> 00:22:15,180
>> Bây giờ, tại sao nó làm điều này?

447
00:22:15,180 --> 00:22:16,270
Vâng, nó có thể được rõ ràng.

448
00:22:16,270 --> 00:22:18,110
Và, quả thật vậy, chương trình là
có nghĩa là để được khá đơn giản

449
00:22:18,110 --> 00:22:19,670
vì vậy chúng tôi có một cái gì đó để khám phá.

450
00:22:19,670 --> 00:22:25,870
>> Nhưng chúng ta hãy giới thiệu một gỡ lỗi thứ ba
kỹ thuật ở đây gọi là debug50.

451
00:22:25,870 --> 00:22:27,750
Vì vậy, đây là một chương trình
mà chúng ta vừa tạo

452
00:22:27,750 --> 00:22:30,770
năm được gọi là debug50 này
mà sẽ cho phép bạn

453
00:22:30,770 --> 00:22:34,130
sử dụng những gì được gọi là một built-in
debugger đồ họa trong CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Và một trình gỡ lỗi chỉ là một chương trình mà
thường cho phép bạn chạy chương trình của bạn

455
00:22:38,400 --> 00:22:44,050
nhưng từng bước từng bước, dòng
bởi từng dòng, tạm dừng, chọc

456
00:22:44,050 --> 00:22:47,626
xung quanh, nhìn vào các biến để
chương trình không chỉ thổi qua bạn

457
00:22:47,626 --> 00:22:49,750
và nhanh chóng in một cái gì đó
hoặc không in cái gì.

458
00:22:49,750 --> 00:22:53,250
Nó cung cấp cho bạn một cơ hội, tại
tốc độ của con người, để tương tác với nó.

459
00:22:53,250 --> 00:22:55,470
>> Và để làm được điều này, bạn
chỉ đơn giản là làm như sau.

460
00:22:55,470 --> 00:22:58,479
Sau khi biên dịch mã của bạn,
mà tôi đã làm, buggy3,

461
00:22:58,479 --> 00:23:00,020
bạn đi trước và chạy debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Vì vậy, nhiều như help50 có bạn chạy
help50 và sau đó các lệnh,

464
00:23:06,760 --> 00:23:10,120
debug50 có bạn chạy debug50 và
sau đó tên của lệnh.

465
00:23:10,120 --> 00:23:14,440
>> Bây giờ xem những gì xảy ra trên màn hình của tôi,
ở phía bên tay phải đặc biệt.

466
00:23:14,440 --> 00:23:19,400
Khi tôi nhấn Run, tất cả các
bảng điều khiển bên phải này đột ngột

467
00:23:19,400 --> 00:23:20,419
mở ra trên màn hình.

468
00:23:20,419 --> 00:23:22,210
Và có rất nhiều đi
trên ở cái nhìn đầu tiên.

469
00:23:22,210 --> 00:23:25,110
Nhưng không có quá
nhiều lo lắng về chưa.

470
00:23:25,110 --> 00:23:28,570
>> Điều này được hiển thị cho tôi tất cả mọi thứ
đang xảy ra bên trong các chương trình của tôi

471
00:23:28,570 --> 00:23:31,130
ngay bây giờ và thông qua các
nút lên hàng đầu là sau đó

472
00:23:31,130 --> 00:23:35,910
cho phép tôi để bước qua mã của tôi
cuối cùng là từng bước từng bước một.

473
00:23:35,910 --> 00:23:37,140
Nhưng không chỉ được nêu ra.

474
00:23:37,140 --> 00:23:38,060
Chú ý những gì sẽ xảy ra.

475
00:23:38,060 --> 00:23:40,600
Tại cửa sổ thiết bị đầu cuối của tôi
Tôi bị nhắc nhở cho n.

476
00:23:40,600 --> 00:23:44,560
Và tôi sẽ đi trước và
hợp tác lần này và gõ vào -1.

477
00:23:44,560 --> 00:23:48,770
Và mặc dù một chút khó hiểu, -1
là một số nguyên âm, như mong đợi.

478
00:23:48,770 --> 00:23:52,020
>> Và sau đó con đã thoát với
trạng thái 0 gdbserver thoát.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, là tên
của các phần mềm cơ bản

480
00:23:55,180 --> 00:23:56,620
mà thực hiện sửa lỗi này.

481
00:23:56,620 --> 00:24:00,500
Nhưng tất cả những điều này thực sự có nghĩa là, các trình gỡ lỗi
ra đi vì chương trình của tôi bỏ

482
00:24:00,500 --> 00:24:01,710
và tất cả đều tốt đẹp.

483
00:24:01,710 --> 00:24:06,020
Nếu tôi muốn thực sự gỡ lỗi chương trình của tôi,
Tôi có làm việc tạm thời cho debug50,

484
00:24:06,020 --> 00:24:08,920
nơi nào tôi muốn bắt đầu
bước qua mã của tôi?

485
00:24:08,920 --> 00:24:11,750
>> Và có lẽ cách đơn giản nhất
để làm điều đó là như sau.

486
00:24:11,750 --> 00:24:15,300
Nếu tôi đưa chuột qua
máng xối của biên tập viên của tôi ở đây,

487
00:24:15,300 --> 00:24:19,090
như vậy thực sự chỉ trong thanh bên đây,
bên trái của số dòng,

488
00:24:19,090 --> 00:24:21,870
việc thông báo rằng nếu tôi chỉ cần nhấp
một lần, tôi đặt một chấm nhỏ màu đỏ.

489
00:24:21,870 --> 00:24:24,460
Và đó là chấm nhỏ màu đỏ,
như một dấu hiệu dừng lại, có nghĩa là, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, thực hiện tạm dừng mã của tôi
ngay khi tôi chạy chương trình này.

491
00:24:29,430 --> 00:24:30,260
>> Vì vậy, hãy làm điều đó.

492
00:24:30,260 --> 00:24:37,340
Hãy để tôi đi trước và chạy chương trình của tôi
một lần nữa với debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Và bây giờ, thông báo, một cái gì đó
khác nhau đã xảy ra.

494
00:24:40,110 --> 00:24:42,440
Tôi không bị nhắc nhở
nhưng trong cửa sổ thiết bị đầu cuối của tôi

495
00:24:42,440 --> 00:24:45,430
cho bất cứ điều gì, bởi vì tôi có không
nhận có được nêu trong chương trình của tôi.

496
00:24:45,430 --> 00:24:47,950
Chú ý rằng trên dòng 8
mà hiện nay được đánh dấu,

497
00:24:47,950 --> 00:24:51,720
và có một mũi tên nhỏ ở
câu nói trái, bạn đang dừng lại ở đây.

498
00:24:51,720 --> 00:24:55,030
dòng mã này, dòng
8, đã không được thực hiện.

499
00:24:55,030 --> 00:24:58,940
>> Và điều tò mò, nếu tôi nhìn
ở đây ở phía bên tay phải,

500
00:24:58,940 --> 00:25:03,530
nhận thấy rằng tôi là một địa phương
biến, địa phương theo nghĩa

501
00:25:03,530 --> 00:25:05,450
rằng đó là bên trong các chức năng hiện nay.

502
00:25:05,450 --> 00:25:08,920
Và giá trị của nó, rõ ràng bởi mặc định,
và loại thuận tiện, là 0.

503
00:25:08,920 --> 00:25:10,260
Nhưng tôi đã không đánh 0.

504
00:25:10,260 --> 00:25:13,410
Điều đó chỉ xảy ra được nó
Giá trị mặc định vào lúc này.

505
00:25:13,410 --> 00:25:15,490
>> Vì vậy, hãy để tôi đi trước và làm điều này ngay bây giờ.

506
00:25:15,490 --> 00:25:18,680
Hãy để tôi đi trước và trên
phía trên bên phải ở đây, tôi

507
00:25:18,680 --> 00:25:20,970
sẽ đi trước và
nhấp vào biểu tượng đầu tiên này mà

508
00:25:20,970 --> 00:25:25,360
có nghĩa là bước trên có nghĩa là không bỏ qua
nó nhưng bước qua dòng mã này,

509
00:25:25,360 --> 00:25:27,770
thực hiện nó trên đường đi.

510
00:25:27,770 --> 00:25:30,710
>> Và bây giờ, để ý, tôi
nhắc vừa thay đổi.

511
00:25:30,710 --> 00:25:31,380
Tại sao vậy?

512
00:25:31,380 --> 00:25:33,639
Tôi đã nói với debug50,
chạy dòng mã này.

513
00:25:33,639 --> 00:25:34,930
không dòng này dùng để làm gì?

514
00:25:34,930 --> 00:25:35,960
Nhắc tôi cho một int.

515
00:25:35,960 --> 00:25:36,460
ĐƯỢC.

516
00:25:36,460 --> 00:25:37,400
Hãy để tôi hợp tác.

517
00:25:37,400 --> 00:25:41,340
Hãy để tôi đi trước bây giờ và gõ -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Và bây giờ chú ý những gì đã thay đổi.

519
00:25:42,920 --> 00:25:46,060
Bên phía tay phải,
biến địa phương của tôi

520
00:25:46,060 --> 00:25:48,200
được chỉ định như là -1 bây giờ.

521
00:25:48,200 --> 00:25:49,810
Và nó vẫn còn có kiểu int.

522
00:25:49,810 --> 00:25:53,102
>> Và thông báo, quá, tôi được gọi là
gọi chồng, nơi mà tôi tạm dừng?

523
00:25:53,102 --> 00:25:54,810
Chúng tôi sẽ nói thêm về
này trong tương lai.

524
00:25:54,810 --> 00:25:58,620
Nhưng các cuộc gọi stack chỉ đề cập đến những gì
chức năng hiện đang chuyển động.

525
00:25:58,620 --> 00:26:00,040
Ngay bây giờ nó chỉ là chính.

526
00:26:00,040 --> 00:26:03,590
Và ngay bây giờ chỉ có các địa phương
biến là i với giá trị là 1.

527
00:26:03,590 --> 00:26:09,840
>> Và khi cuối cùng tôi bước qua dòng này
ở đây, với cùng một biểu tượng ở góc trên bên phải,

528
00:26:09,840 --> 00:26:11,410
-1 Là một số nguyên âm.

529
00:26:11,410 --> 00:26:13,580
Bây giờ nó đang tạm dừng hơn mà đôi xoăn.

530
00:26:13,580 --> 00:26:14,740
Hãy để cho nó làm việc của nó.

531
00:26:14,740 --> 00:26:17,300
Tôi bước qua dòng, và thì đấy.

532
00:26:17,300 --> 00:26:20,240
>> Vì vậy, không phải tất cả những gì khủng khiếp
khai sáng nào,

533
00:26:20,240 --> 00:26:23,550
nhưng nó đã cho tôi tạm dừng
và suy nghĩ logic

534
00:26:23,550 --> 00:26:24,870
những gì chương trình này đang làm.

535
00:26:24,870 --> 00:26:26,890
Nhưng đó không phải là trường hợp có sai sót.

536
00:26:26,890 --> 00:26:28,510
Hãy làm điều này một lần nữa như sau.

537
00:26:28,510 --> 00:26:31,340
>> Tôi sẽ để lại breakpoint mà
trên dòng 8 với các chấm đỏ.

538
00:26:31,340 --> 00:26:32,830
Tôi sẽ chạy lại debug50.

539
00:26:32,830 --> 00:26:34,400
Nó sẽ tự động dừng lại ở đây.

540
00:26:34,400 --> 00:26:37,660
Nhưng lần này, thay vì
bước qua dòng này,

541
00:26:37,660 --> 00:26:42,290
hãy để tôi thực sự đi vào bên trong của
get_negative_int và tìm ra,

542
00:26:42,290 --> 00:26:45,530
tại sao nó được chấp nhận 0 như là một câu trả lời hợp lệ?

543
00:26:45,530 --> 00:26:47,990
>> Vì vậy, thay vì nhấn Step Over.

544
00:26:47,990 --> 00:26:50,630
Tôi sẽ đi trước
và bấm Bước vào.

545
00:26:50,630 --> 00:26:54,030
Và nhận thấy rằng các dòng 8 đó là
hiện nay nhấn mạnh bây giờ đột nhiên

546
00:26:54,030 --> 00:26:56,900
trở thành dòng 17.

547
00:26:56,900 --> 00:26:59,947
>> Bây giờ, nó không phải là chương trình gỡ rối
đã bỏ qua dòng 14 và 15 và 16.

548
00:26:59,947 --> 00:27:01,780
Nó chỉ là không có gì là
để cho bạn có.

549
00:27:01,780 --> 00:27:04,050
Những người được chỉ cần khai báo các biến,
và sau đó là từ Do

550
00:27:04,050 --> 00:27:05,390
và sau đó là một cú đúp xoăn mở.

551
00:27:05,390 --> 00:27:09,227
Các chỉ dòng chức năng đó là
ngon ngọt thực sự là một trong những điều này ở đây, 17.

552
00:27:09,227 --> 00:27:11,060
Và đó là nơi chúng tôi đã
dừng tự động.

553
00:27:11,060 --> 00:27:13,870
>> Vì vậy, printf ( "n.is:") ;, vậy
đó vẫn chưa xảy ra.

554
00:27:13,870 --> 00:27:18,250
Vì vậy, chúng ta hãy đi trước và bấm Step Over.

555
00:27:18,250 --> 00:27:20,326
Bây giờ dấu nhắc của tôi, thực sự,
thay đổi ( "n là:").

556
00:27:20,326 --> 00:27:22,450
Bây giờ get_int, tôi sẽ không
bận tâm bước vào,

557
00:27:22,450 --> 00:27:24,750
bởi vì chức năng đó là
do CS50 trong Library.

558
00:27:24,750 --> 00:27:25,750
Đó có lẽ là đúng.

559
00:27:25,750 --> 00:27:28,440
>> Vì vậy, tôi sẽ đi trước và
loại hợp tác bằng cách cho nó

560
00:27:28,440 --> 00:27:30,590
một int, nhưng không phải là một int tiêu cực.

561
00:27:30,590 --> 00:27:32,870
Vì vậy, hãy để tôi đi trước và đạt 0.

562
00:27:32,870 --> 00:27:39,460
Và bây giờ những gì xảy ra ở đây
khi tôi nhận được đến dòng 21?

563
00:27:39,460 --> 00:27:40,890
Tôi đã không lặp lại.

564
00:27:40,890 --> 00:27:43,320
Tôi dường như không bị mắc kẹt trong vòng lặp đó.

565
00:27:43,320 --> 00:27:45,990
Nói cách khác, đây vàng
thanh không tiếp tục đi xung quanh,

566
00:27:45,990 --> 00:27:47,130
và xung quanh, và xung quanh.

567
00:27:47,130 --> 00:27:48,340
>> Bây giờ, tại sao vậy?

568
00:27:48,340 --> 00:27:49,920
Vâng, n, những gì được n ngay bây giờ?

569
00:27:49,920 --> 00:27:53,280
Tôi có thể nhìn vào các địa phương
biến trong các trình gỡ lỗi.

570
00:27:53,280 --> 00:27:53,816
n là 0.

571
00:27:53,816 --> 00:27:55,190
Tất cả các quyền, tình trạng của tôi là gì?

572
00:27:55,190 --> 00:27:58,700
>> 20-- dòng 20 là, tốt,
0 là lớn hơn 0.

573
00:27:58,700 --> 00:27:59,500
Đó không phải là sự thật.

574
00:27:59,500 --> 00:28:01,020
0 là không lớn hơn 0.

575
00:28:01,020 --> 00:28:02,820
Và vì vậy tôi đã phá vỡ ra điều này.

576
00:28:02,820 --> 00:28:06,370
>> Và đó là lý do tại sao trên đường
21, nếu tôi thực sự tiếp tục,

577
00:28:06,370 --> 00:28:10,370
Tôi sẽ trở về 0, thậm chí
mặc dù tôi nên đã từ chối 0

578
00:28:10,370 --> 00:28:12,484
như không thực sự là tiêu cực.

579
00:28:12,484 --> 00:28:14,650
Vì vậy, bây giờ, tôi không thực sự thậm chí
quan tâm đến các chương trình gỡ rối.

580
00:28:14,650 --> 00:28:16,900
Chấn nó, tôi không cần phải
biết nhiều hơn những gì đang xảy ra.

581
00:28:16,900 --> 00:28:19,233
>> Vì vậy, tôi sẽ đi trước và
chỉ cần nhấp vào nút Play,

582
00:28:19,233 --> 00:28:20,240
và để kết thúc này lên.

583
00:28:20,240 --> 00:28:23,440
Bây giờ, tôi đã nhận ra rằng tôi
lỗi là rõ ràng trên dòng 20.

584
00:28:23,440 --> 00:28:25,160
Đó là lỗi logic của tôi.

585
00:28:25,160 --> 00:28:28,100
>> Và vì vậy những gì tôi muốn
phải làm gì để thay đổi điều này?

586
00:28:28,100 --> 00:28:32,500
Nếu vấn đề là tôi không
bắt 0, nó chỉ là một lỗi logic.

587
00:28:32,500 --> 00:28:35,910
Và tôi có thể nói rằng trong khi n là
lớn hơn hoặc bằng 0,

588
00:28:35,910 --> 00:28:38,330
giữ khiến người sử dụng một lần nữa và một lần nữa.

589
00:28:38,330 --> 00:28:41,050
>> Vì vậy, một lần nữa, sai lầm đơn giản, có lẽ
thậm chí rõ ràng khi bạn nhìn thấy tôi

590
00:28:41,050 --> 00:28:42,410
viết nó chỉ là một vài phút trước đây.

591
00:28:42,410 --> 00:28:44,570
Nhưng takeaway đây
là với debug 50,

592
00:28:44,570 --> 00:28:46,850
và với lỗi
phần mềm nói chung,

593
00:28:46,850 --> 00:28:51,370
bạn có khả năng này mới được tìm thấy để
đi bộ qua mã riêng của bạn, hãy tìm

594
00:28:51,370 --> 00:28:55,590
qua đó bảng điều khiển tay phải những gì
giá trị các biến của bạn.

595
00:28:55,590 --> 00:28:57,700
Vì vậy, bạn không nhất thiết phải
phải sử dụng một cái gì đó

596
00:28:57,700 --> 00:29:00,630
như bạn eprintf để in những giá trị.

597
00:29:00,630 --> 00:29:04,430
Bạn thực sự có thể nhìn thấy chúng
trực quan trên màn hình.

598
00:29:04,430 --> 00:29:08,920
>> Bây giờ, ngoài này, nó là đáng chú ý
rằng có một kỹ thuật đó là

599
00:29:08,920 --> 00:29:09,890
thực sự siêu phổ biến.

600
00:29:09,890 --> 00:29:13,120
Và bạn có thể tự hỏi tại sao điều này chút
chàng trai ở đây đã được ngồi trên sân khấu.

601
00:29:13,120 --> 00:29:16,490
Vì vậy, có kỹ thuật này, nói chung
được gọi là cao su gỡ lỗi vịt,

602
00:29:16,490 --> 00:29:18,786
mà thực sự chỉ là một
minh chứng cho thực tế

603
00:29:18,786 --> 00:29:20,660
mà các lập trình thường khi
đang viết code,

604
00:29:20,660 --> 00:29:22,650
họ không nhất thiết
cộng tác với những người khác,

605
00:29:22,650 --> 00:29:24,030
hoặc làm việc trong một môi trường chia sẻ.

606
00:29:24,030 --> 00:29:25,050
>> Họ là loại tại nhà.

607
00:29:25,050 --> 00:29:25,910
Có lẽ đó là đêm khuya.

608
00:29:25,910 --> 00:29:28,190
Họ đang cố gắng để con số
ra một số lỗi trong mã của họ.

609
00:29:28,190 --> 00:29:29,330
Và họ chỉ không nhìn thấy nó.

610
00:29:29,330 --> 00:29:30,329
>> Và không có bạn cùng phòng.

611
00:29:30,329 --> 00:29:31,250
Không có TF.

612
00:29:31,250 --> 00:29:32,680
Không có CA xung quanh.

613
00:29:32,680 --> 00:29:36,440
Tất cả họ có trên kệ của họ
là người chăn nuôi cao su nhỏ này.

614
00:29:36,440 --> 00:29:39,030
>> Và do đó, gỡ lỗi vịt cao su
chỉ là lời mời này

615
00:29:39,030 --> 00:29:42,780
nghĩ về một cái gì đó như ngớ ngẩn
vì đây là một sinh vật thực,

616
00:29:42,780 --> 00:29:46,940
và thực sự đi qua mã của bạn
bằng lời nói đến đối tượng vô tri vô giác này.

617
00:29:46,940 --> 00:29:49,230
Vì vậy, ví dụ, nếu
đây là ví dụ của tôi tại đây--

618
00:29:49,230 --> 00:29:52,470
và nhớ lại rằng trước đó
vấn đề là điều này,

619
00:29:52,470 --> 00:29:58,140
nếu tôi xóa dòng đầu tiên của mã,
và tôi đi trước và làm cho buggy 0 một lần nữa,

620
00:29:58,140 --> 00:30:01,220
nhớ lại rằng tôi đã có những
thông báo lỗi ở đây.

621
00:30:01,220 --> 00:30:05,997
Vì vậy, ý tưởng ở đây, mặc dù tôi vô lý
cảm thấy vào lúc này làm điều này công khai,

622
00:30:05,997 --> 00:30:06,580
là lỗi đó.

623
00:30:06,580 --> 00:30:10,910
>> OK, vì vậy vấn đề của tôi là tôi đã
ngầm tuyên bố một chức năng thư viện.

624
00:30:10,910 --> 00:30:12,610
Và đó là chức năng thư viện là printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, kê khai
nhắc nhở tôi về nguyên mẫu.

626
00:30:15,290 --> 00:30:18,930
>> Điều đó có nghĩa là tôi cần phải thực sự
cho trình biên dịch trước những gì

627
00:30:18,930 --> 00:30:19,980
các chức năng như thế nào.

628
00:30:19,980 --> 00:30:20,930
Chờ một chút.

629
00:30:20,930 --> 00:30:23,580
Tôi không có io.h. chuẩn

630
00:30:23,580 --> 00:30:24,530
Cảm ơn nhiều.

631
00:30:24,530 --> 00:30:27,330
>> Vì vậy, chỉ quá trình này lượng-- bạn
không cần phải thực sự có một con vịt.

632
00:30:27,330 --> 00:30:29,819
Nhưng ý tưởng này đi bộ
mình thông qua mã của riêng bạn

633
00:30:29,819 --> 00:30:31,610
do đó bạn thậm chí nghe
mình, vì vậy mà bạn

634
00:30:31,610 --> 00:30:35,620
nhận ra thiếu sót của chính mình
nhận xét, nói chung là ý tưởng.

635
00:30:35,620 --> 00:30:38,910
>> Và, có lẽ hợp lý hơn, không quá
nhiều với ai nhưng tham gia nhiều hơn

636
00:30:38,910 --> 00:30:44,220
Ví dụ chúng ta chỉ cần làm trong 3.c lỗi,
bạn có thể đi bộ mình thông qua nó

637
00:30:44,220 --> 00:30:45,310
như sau.

638
00:30:45,310 --> 00:30:49,190
Vì vậy, tất cả các quyền, cao su
người chăn nuôi, DDB, nếu bạn muốn.

639
00:30:49,190 --> 00:30:52,350
Ở đây chúng tôi có trong chức năng chính của tôi,
Tôi gọi được int tiêu cực.

640
00:30:52,350 --> 00:30:54,660
>> Và tôi nhận được các giá trị trả về.

641
00:30:54,660 --> 00:31:00,410
Tôi đang lưu trữ nó ở phía bên tay trái
trên dòng 8 trong một biến gọi là i.

642
00:31:00,410 --> 00:31:02,380
OK, nhưng chờ đợi, làm thế nào đã
mà có được giá trị đó?

643
00:31:02,380 --> 00:31:04,130
Hãy để tôi nhìn vào các chức năng trong dòng 12.

644
00:31:04,130 --> 00:31:05,760
>> Trong dòng 12, chúng tôi đã nhận được int tiêu cực.

645
00:31:05,760 --> 00:31:08,190
Không có bất kỳ đầu vào,
không trả lại một int, OK.

646
00:31:08,190 --> 00:31:10,929
Tôi tuyên bố trên dòng 14 một biến n.

647
00:31:10,929 --> 00:31:12,220
Nó sẽ lưu trữ một số nguyên.

648
00:31:12,220 --> 00:31:13,760
Đó là điều tôi muốn.

649
00:31:13,760 --> 00:31:18,480
>> Vì vậy, làm như sau trong khi n hợp-- phép
tôi hoàn tác những gì sửa chữa tôi đã thực hiện.

650
00:31:18,480 --> 00:31:22,710
Vì vậy, trong khi n lớn hơn
0, in ra n là, OK.

651
00:31:22,710 --> 00:31:25,170
Và sau đó gọi được lưu trữ trong int n.

652
00:31:25,170 --> 00:31:30,160
Và sau đó kiểm tra nếu n là 0,
n là not-- có nó được.

653
00:31:30,160 --> 00:31:31,910
Vì vậy, một lần nữa, bạn không
cần con vịt thực tế.

654
00:31:31,910 --> 00:31:35,650
Nhưng chỉ đi bộ qua chính mình
code của bạn như một bài tập trí tuệ

655
00:31:35,650 --> 00:31:37,720
thường xuyên sẽ giúp bạn
nhận ra những gì đang xảy ra,

656
00:31:37,720 --> 00:31:41,170
như trái ngược với chỉ làm điều gì đó
như thế này, nhìn chằm chằm vào màn hình,

657
00:31:41,170 --> 00:31:43,720
và không nói cho mình thông qua
nó, trung thực mà không phải là

658
00:31:43,720 --> 00:31:46,270
gần như là một kỹ thuật hiệu quả.

659
00:31:46,270 --> 00:31:48,620
Vì vậy, có bạn có nó, một
số kỹ thuật khác nhau

660
00:31:48,620 --> 00:31:52,102
cho thực gỡ lỗi mã của bạn
và tìm lỗi, tất cả đều

661
00:31:52,102 --> 00:31:54,810
nên là công cụ trong bộ công cụ của bạn
do đó bạn không phải là muộn vào ban đêm,

662
00:31:54,810 --> 00:31:57,660
đặc biệt là, bạn đang ở trong phòng ăn
hội trường, hoặc ít giờ hành chính,

663
00:31:57,660 --> 00:32:00,368
đập đầu của bạn chống lại các
tường, cố gắng để giải quyết một số vấn đề.

664
00:32:00,368 --> 00:32:02,020
Nhận ra rằng có những công cụ phần mềm.

665
00:32:02,020 --> 00:32:03,720
Có những công cụ vịt cao su.

666
00:32:03,720 --> 00:32:09,630
Và có một đội ngũ nhân viên toàn bộ
hỗ trợ chờ đợi để giúp một tay.

667
00:32:09,630 --> 00:32:13,120
>> Vì vậy, bây giờ, một lời về vấn đề này
bộ, và về những gì chúng tôi hy vọng bạn

668
00:32:13,120 --> 00:32:15,620
có được ra khỏi họ, và làm thế nào
chúng tôi đi về đánh giá.

669
00:32:15,620 --> 00:32:17,680
Mỗi giáo trình của khóa học,
bộ vấn đề của CS50

670
00:32:17,680 --> 00:32:22,320
được đánh giá trên bốn trục chính, do đó
để speak-- phạm vi, đúng đắn, thiết kế,

671
00:32:22,320 --> 00:32:23,060
và phong cách.

672
00:32:23,060 --> 00:32:25,910
Và phạm vi chỉ đề cập đến bao nhiêu
của mảnh bạn đã bị cắn đứt?

673
00:32:25,910 --> 00:32:28,080
Làm thế nào nhiều của một vấn đề có bạn đã thử?

674
00:32:28,080 --> 00:32:30,110
độ gì của nỗ lực
bạn đã thể hiện?

675
00:32:30,110 --> 00:32:35,750
>> Chính xác là, hiện các chương trình làm việc như
đó là nghĩa vụ mỗi đặc điểm kỹ thuật CS50

676
00:32:35,750 --> 00:32:38,640
khi bạn cung cấp đầu vào nhất định
hoặc kết quả đầu ra nhất định quay trở lại?

677
00:32:38,640 --> 00:32:41,130
Thiết kế là sự chủ quan nhất của họ.

678
00:32:41,130 --> 00:32:43,360
Và đó là một trong đó sẽ
đi dài nhất để học

679
00:32:43,360 --> 00:32:47,220
và dài nhất để giảng dạy, trong
xa như vậy nó nắm xuống,

680
00:32:47,220 --> 00:32:49,530
viết như thế nào là mã của bạn?

681
00:32:49,530 --> 00:32:52,920
>> Đó là một điều chỉ in đúng
kết quả đầu ra, hoặc trả lại những giá trị đúng.

682
00:32:52,920 --> 00:32:55,400
Nhưng bạn làm việc đó như
hiệu quả nhất có thể?

683
00:32:55,400 --> 00:32:58,210
bạn đang làm nó phân chia
và chinh phục, hoặc nhị phân

684
00:32:58,210 --> 00:33:01,500
tìm kiếm như chúng ta sẽ sớm thấy rằng chúng tôi đã làm
hai tuần trước với các cuốn sách điện thoại?

685
00:33:01,500 --> 00:33:04,670
Có cách nào tốt hơn để giải quyết
vấn đề hơn bạn đang có ở đây?

686
00:33:04,670 --> 00:33:06,380
Đó là một cơ hội cho các thiết kế tốt hơn.

687
00:33:06,380 --> 00:33:08,530
>> Và sau đó style-- cách
khá là mã của bạn?

688
00:33:08,530 --> 00:33:12,370
Bạn sẽ nhận thấy rằng tôi khá
cụ thể về thụt mã của tôi,

689
00:33:12,370 --> 00:33:15,300
và đảm bảo các biến của tôi
được đặt tên một cách hợp lý. n,

690
00:33:15,300 --> 00:33:19,660
thời gian ngắn, là một tên tốt cho một
số, tôi cho một số nguyên đếm,

691
00:33:19,660 --> 00:33:20,727
s cho một chuỗi.

692
00:33:20,727 --> 00:33:22,560
Và chúng ta có thể còn
biến tên phong cách.

693
00:33:22,560 --> 00:33:25,500
Phong cách là như thế nào tốt
không mã của bạn tìm?

694
00:33:25,500 --> 00:33:26,600
Và làm thế nào có thể đọc được là nó?

695
00:33:26,600 --> 00:33:29,650
>> Và theo thời gian, những gì hỗ trợ kỹ thuật của bạn
và TF sẽ làm gì trong khóa học

696
00:33:29,650 --> 00:33:31,870
được cung cấp cho bạn với điều đó
loại thông tin phản hồi về chất lượng

697
00:33:31,870 --> 00:33:34,330
để bạn có được tốt hơn
ở những khía cạnh khác nhau.

698
00:33:34,330 --> 00:33:37,510
Và trong điều kiện như thế nào chúng tôi
đánh giá từng trục,

699
00:33:37,510 --> 00:33:40,080
nó thường có rất ít
xô để bạn, nói chung,

700
00:33:40,080 --> 00:33:41,680
có được một cảm giác như thế nào bạn đang làm.

701
00:33:41,680 --> 00:33:45,680
Và, quả thật vậy, nếu bạn nhận được một số điểm trên
bất kỳ của những xác axes--, thiết kế

702
00:33:45,680 --> 00:33:49,659
và phong cách especially-- số đó
nói chung sẽ là từ 1 đến 5.

703
00:33:49,659 --> 00:33:52,450
Và, theo nghĩa đen, nếu bạn đang nhận được
3 nhân vào đầu học kỳ,

704
00:33:52,450 --> 00:33:53,977
Đây là một điều rất tốt.

705
00:33:53,977 --> 00:33:55,810
Nó có nghĩa là vẫn còn
phòng để cải thiện,

706
00:33:55,810 --> 00:33:58,490
mà bạn sẽ hy vọng cho trong
tham gia một lớp cho lần đầu tiên.

707
00:33:58,490 --> 00:34:01,820
Có hy vọng một số bit của trần
mà bạn đang khao khát đạt.

708
00:34:01,820 --> 00:34:03,970
Và để nhận được trên 3 của
các mảnh sớm nhất,

709
00:34:03,970 --> 00:34:06,550
nếu không một số của 2 và 4,
là, thực sự, một điều tốt.

710
00:34:06,550 --> 00:34:08,880
Nó cũng trong phạm vi,
cũng nằm trong sự mong đợi.

711
00:34:08,880 --> 00:34:11,421
>> Và nếu tâm trí của bạn đang chạy đua, chờ đợi
một phút, ba trong số năm.

712
00:34:11,421 --> 00:34:12,620
Đó thực sự là một hiện 6 của 10.

713
00:34:12,620 --> 00:34:13,560
Đó là 60%.

714
00:34:13,560 --> 00:34:14,830
Thiên Chúa của tôi, đó là một F.

715
00:34:14,830 --> 00:34:15,870
>> Nó không phải.

716
00:34:15,870 --> 00:34:17,600
Đó không phải là, trên thực tế, điều đó.

717
00:34:17,600 --> 00:34:22,710
Thay vào đó, nó là một cơ hội để cải thiện
trong quá trình của học kỳ.

718
00:34:22,710 --> 00:34:25,580
Và nếu bạn đang nhận được một số
sự cằn cỏi, đây là một cơ hội

719
00:34:25,580 --> 00:34:29,199
để tận dụng giờ làm việc,
chắc chắn phần và các nguồn lực khác.

720
00:34:29,199 --> 00:34:32,840
>> Tốt nhất là một cơ hội, thực sự,
đáng tự hào như thế nào đến nay bạn đã

721
00:34:32,840 --> 00:34:34,520
đi qua các khóa học của học kỳ.

722
00:34:34,520 --> 00:34:38,199
Vì vậy, nhận ra, nếu không có gì
khác, ba là tốt.

723
00:34:38,199 --> 00:34:40,179
Và nó cho phép phòng cho sự phát triển theo thời gian.

724
00:34:40,179 --> 00:34:43,090
>> Như thế nào những trục là
trọng, thực tế bạn

725
00:34:43,090 --> 00:34:46,745
sẽ dành phần lớn thời gian của bạn nhận được
điều cần làm, hãy để một mình một cách chính xác.

726
00:34:46,745 --> 00:34:49,120
Và như vậy có đúng không có xu hướng
được trọng nhất, như với

727
00:34:49,120 --> 00:34:51,360
tố chất nhân này của ba.

728
00:34:51,360 --> 00:34:54,659
Thiết kế cũng là quan trọng, nhưng
một cái gì đó mà bạn không nhất thiết phải

729
00:34:54,659 --> 00:34:58,220
dành tất cả những giờ trên
cố gắng để có được những thứ chỉ để làm việc.

730
00:34:58,220 --> 00:35:00,019
>> Và do đó, nó có trọng
một chút nhẹ nhàng hơn.

731
00:35:00,019 --> 00:35:01,560
Và sau đó phong cách là trọng ít nhất.

732
00:35:01,560 --> 00:35:03,710
Mặc dù nó không kém
quan trọng về cơ bản,

733
00:35:03,710 --> 00:35:05,990
nó chỉ là, có lẽ,
Điều dễ nhất để làm đúng,

734
00:35:05,990 --> 00:35:08,440
bắt chước các ví dụ chúng tôi
làm trong bài giảng và phần,

735
00:35:08,440 --> 00:35:11,080
với những thứ độc đáo
thụt vào, và nhận xét,

736
00:35:11,080 --> 00:35:14,320
và vv là một trong những đơn giản nhất
Những việc cần làm và có được quyền.

737
00:35:14,320 --> 00:35:16,960
Vì vậy, như vậy, nhận ra
đó là những điểm

738
00:35:16,960 --> 00:35:19,000
là tương đối dễ dàng nắm bắt.

739
00:35:19,000 --> 00:35:22,360
>> Và bây giờ là một từ trên
này-- trung thực trong học tập.

740
00:35:22,360 --> 00:35:25,150
Vì vậy, mỗi quá trình của
giáo trình, bạn sẽ thấy

741
00:35:25,150 --> 00:35:27,630
khoá học đó có khá
chút về ngôn ngữ xung quanh này.

742
00:35:27,630 --> 00:35:31,380
Và tất nhiên có vấn đề
trung thực học tập khá nghiêm túc.

743
00:35:31,380 --> 00:35:33,450
>> Chúng tôi có sự phân biệt,
Cho tốt hơn hoặc tồi tệ hơn,

744
00:35:33,450 --> 00:35:36,570
là đã gửi đi mỗi năm hơn
cho học sinh bị kỷ luật

745
00:35:36,570 --> 00:35:39,670
hơn hầu hết bất kỳ khác
Tất nhiên, là tôi biết.

746
00:35:39,670 --> 00:35:42,580
Đây không phải là nhất thiết
thấy một thực tế

747
00:35:42,580 --> 00:35:46,340
sinh viên CS, hoặc sinh viên CS50, là
ít hơn bất kỳ trung thực hơn so với các bạn cùng lớp của bạn.

748
00:35:46,340 --> 00:35:49,090
Nhưng thực tế rằng trong này
thế giới, điện tử, chúng tôi chỉ

749
00:35:49,090 --> 00:35:50,990
có công nghệ
nghĩa của phát hiện này.

750
00:35:50,990 --> 00:35:53,360
>> Điều quan trọng là chúng tôi cho
sự công bằng giữa các lớp

751
00:35:53,360 --> 00:35:58,550
mà chúng ta làm phát hiện này, và nâng cao
vấn đề khi chúng ta nhìn thấy mọi thứ.

752
00:35:58,550 --> 00:36:01,980
Và chỉ để vẽ một bức tranh, và thực sự
để giúp một cái gì đó giống như bồn rửa này trong,

753
00:36:01,980 --> 00:36:04,600
đây là những con số của
sinh viên trong vòng 10 năm qua

754
00:36:04,600 --> 00:36:07,610
đã được tham gia vào một số
những vấn đề như sự trung thực của học tập,

755
00:36:07,610 --> 00:36:10,990
với một số 32 học sinh
từ mùa thu năm 2015, trong đó

756
00:36:10,990 --> 00:36:13,760
là để nói rằng chúng ta mất
vấn đề rất nghiêm trọng.

757
00:36:13,760 --> 00:36:18,380
Và, cuối cùng, những con số sáng tác,
Gần đây nhất, khoảng 3%, 4% hoặc hơn

758
00:36:18,380 --> 00:36:19,120
của lớp.

759
00:36:19,120 --> 00:36:25,220
>> Vì vậy, đối với phần lớn siêu của sinh viên
có vẻ như các dòng là rõ ràng.

760
00:36:25,220 --> 00:36:27,940
Tuy nhiên cần lưu này trong
quan tâm, đặc biệt là vào cuối

761
00:36:27,940 --> 00:36:32,080
vào ban đêm khi đấu tranh với
một số giải pháp cho một bộ vấn đề,

762
00:36:32,080 --> 00:36:34,830
rằng có những cơ chế
để nhận bản thân tốt hơn

763
00:36:34,830 --> 00:36:37,870
hỗ trợ hơn có lẽ bạn
nghĩ rằng, ngay cả vào giờ đó.

764
00:36:37,870 --> 00:36:40,514
Nhận ra rằng khi chúng tôi nhận được
đệ trình của sinh viên, chúng tôi băng qua

765
00:36:40,514 --> 00:36:43,430
so sánh mọi trình năm nay
chống lại mọi trình năm ngoái,

766
00:36:43,430 --> 00:36:47,590
chống lại mọi trình từ năm 2007,
và kể từ đó, nhìn vào, cũng như,

767
00:36:47,590 --> 00:36:49,931
Mã kho lưu trữ trực tuyến,
diễn đàn thảo luận, các trang web việc làm.

768
00:36:49,931 --> 00:36:51,806
Và chúng tôi đề cập đến điều này,
thực sự, tất cả vì lợi ích

769
00:36:51,806 --> 00:36:56,040
công bố thông tin đầy đủ, mà nếu
người khác có thể tìm thấy nó trực tuyến,

770
00:36:56,040 --> 00:36:57,880
chắc chắn, vì vậy chúng ta có thể học.

771
00:36:57,880 --> 00:37:00,100
Nhưng, thực sự, tinh thần
tất nhiên là nắm

772
00:37:00,100 --> 00:37:01,650
quy định tại khoản này trong giáo trình.

773
00:37:01,650 --> 00:37:03,670
Nó thực sự chỉ là, hợp lý.

774
00:37:03,670 --> 00:37:06,680
>> Và nếu chúng tôi phải xây dựng trên đó
chỉ với một ngôn ngữ nhiều hơn một chút,

775
00:37:06,680 --> 00:37:09,770
nhận ra rằng bản chất của tất cả
công việc mà bạn gửi cho khóa học này

776
00:37:09,770 --> 00:37:10,954
phải là của riêng của bạn.

777
00:37:10,954 --> 00:37:13,870
Nhưng trong đó, chắc chắn có
cơ hội, và khuyến khích,

778
00:37:13,870 --> 00:37:17,300
và giá trị sư phạm trong chuyển sang
others-- bản thân mình, TF, CA,

779
00:37:17,300 --> 00:37:20,760
các hỗ trợ kỹ thuật, và những người khác trong lớp,
hỗ trợ, cho bạn bè của mình

780
00:37:20,760 --> 00:37:23,547
và bạn cùng phòng, người đã nghiên cứu
CS và lập trình trước.

781
00:37:23,547 --> 00:37:25,130
Và do đó, có một khoản chi cho điều đó.

782
00:37:25,130 --> 00:37:28,180
Và quy luật chung của ngón tay cái
được này-- khi yêu cầu giúp đỡ,

783
00:37:28,180 --> 00:37:31,470
bạn có thể hiển thị mã của bạn cho người khác,
nhưng bạn có thể không xem của họ.

784
00:37:31,470 --> 00:37:34,880
Vì vậy, ngay cả khi bạn đang ở giờ văn phòng,
hoặc trong hội trường D, hoặc ở một nơi khác

785
00:37:34,880 --> 00:37:37,450
làm việc trên một số bộ mảnh,
làm việc cùng với một người bạn, mà

786
00:37:37,450 --> 00:37:40,160
là hoàn toàn tốt, tại
cuối ngày làm việc của bạn

787
00:37:40,160 --> 00:37:43,034
cuối cùng phải thuộc về nhau
của bạn tương ứng, và không

788
00:37:43,034 --> 00:37:45,700
có một số nỗ lực hợp tác,
trừ các dự án cuối cùng, nơi

789
00:37:45,700 --> 00:37:47,410
nó cho phép và khuyến khích.

790
00:37:47,410 --> 00:37:49,830
>> Nhận ra rằng nếu bạn là
đấu tranh với một cái gì đó

791
00:37:49,830 --> 00:37:52,520
và bạn của bạn chỉ xảy ra
được tốt hơn lúc này sau đó bạn,

792
00:37:52,520 --> 00:37:55,130
hoặc tốt hơn vấn đề đó hơn bạn,
hoặc xa hơn một chút về phía trước hơn bạn,

793
00:37:55,130 --> 00:37:57,330
nó hoàn toàn hợp lý để biến
cho bạn bè của bạn và nói, hey,

794
00:37:57,330 --> 00:38:00,480
Bạn có phiền nhìn vào code của tôi ở đây,
Giúp tôi tại chỗ những gì vấn đề của tôi là gì?

795
00:38:00,480 --> 00:38:03,760
Và, hy vọng, trong
quan tâm của các giá trị sư phạm

796
00:38:03,760 --> 00:38:07,040
người bạn rằng không chỉ
nói, oh, làm điều này, nhưng đúng hơn,

797
00:38:07,040 --> 00:38:09,917
những gì bạn đang mất tích trên đường
6, hoặc một cái gì đó như thế?

798
00:38:09,917 --> 00:38:12,000
Nhưng giải pháp không phải là
cho những người bạn bên cạnh bạn

799
00:38:12,000 --> 00:38:15,617
để nói, oh, tốt, ở đây, hãy để tôi kéo
này, và cho thấy giải pháp của tôi cho bạn.

800
00:38:15,617 --> 00:38:16,450
Vì vậy, đó là dòng.

801
00:38:16,450 --> 00:38:18,670
Bạn chỉ cho mã của bạn để
những người khác, nhưng bạn có thể không

802
00:38:18,670 --> 00:38:22,350
xem họ, chịu sự khác
hạn chế trong giáo trình của khóa học.

803
00:38:22,350 --> 00:38:24,760
>> Vì vậy, hãy nhớ này
cái gọi là khoản hối tiếc

804
00:38:24,760 --> 00:38:27,560
trong giáo trình của khóa học là tốt,
rằng nếu bạn cam kết một số hành động mà

805
00:38:27,560 --> 00:38:30,476
là không hợp lý, nhưng mang nó đến
sự chú ý của người đứng đầu của khóa học

806
00:38:30,476 --> 00:38:34,240
trong vòng 72 giờ, khóa học
có thể áp đặt lệnh trừng phạt địa phương

807
00:38:34,240 --> 00:38:37,380
có thể bao gồm một hoặc không đạt yêu cầu
không cấp cho các công việc nộp.

808
00:38:37,380 --> 00:38:41,410
Nhưng tất nhiên sẽ không tham khảo các
quan trọng cho hành động kỷ luật hơn nữa,

809
00:38:41,410 --> 00:38:43,010
ngoại trừ trong trường hợp hành vi lặp đi lặp lại.

810
00:38:43,010 --> 00:38:46,632
Nói cách khác, nếu bạn làm một số
ngu ngốc, đặc biệt là đêm cuối, quyết định

811
00:38:46,632 --> 00:38:49,340
mà sáng hôm sau hoặc hai ngày
sau đó, bạn thức dậy và nhận ra,

812
00:38:49,340 --> 00:38:50,870
đã được tôi nghĩ gì?

813
00:38:50,870 --> 00:38:53,890
Bạn làm gì trong CS50 có một lối thoát
để sửa chữa các vấn đề mà

814
00:38:53,890 --> 00:38:57,170
và sở hữu lên đến nó, vì vậy mà chúng ta
sẽ đáp ứng bạn nửa chừng và đối phó

815
00:38:57,170 --> 00:39:01,500
với nó trong một vấn đề đó là cả hai
giáo dục và có giá trị cho bạn,

816
00:39:01,500 --> 00:39:04,200
nhưng vẫn mang tính trừng phạt một cách nào đó.

817
00:39:04,200 --> 00:39:08,590
Và bây giờ, để giúp bạn bắt, điều này.

818
00:39:08,590 --> 00:39:10,570
>> [XEM LẠI VIDEO]

819
00:39:10,570 --> 00:39:13,540
>> [NHẠC]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END PLAYBACK]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Malan: Được rồi, chúng ta trở lại.

823
00:40:00,490 --> 00:40:03,680
Và bây giờ chúng ta nhìn vào một trong những
đầu tiên của lĩnh thế giới thực của chúng tôi

824
00:40:03,680 --> 00:40:08,720
trong CS50, nghệ thuật mật mã,
nghệ thuật của việc gửi và nhận

825
00:40:08,720 --> 00:40:11,840
tin nhắn bí mật, mã hóa
tin nhắn nếu bạn sẽ,

826
00:40:11,840 --> 00:40:17,060
mà chỉ có thể được giải mã nếu bạn có
một số thành phần quan trọng mà người gửi có

827
00:40:17,060 --> 00:40:18,030
cũng.

828
00:40:18,030 --> 00:40:22,120
Vì vậy, để tạo động lực này, chúng tôi sẽ đưa
một nhìn vào điều này ở đây,

829
00:40:22,120 --> 00:40:26,750
đó là một ví dụ về một
nhẫn giải mã bí mật mà

830
00:40:26,750 --> 00:40:34,042
có thể được sử dụng để tìm ra
những gì một thông điệp bí mật thực sự.

831
00:40:34,042 --> 00:40:35,750
Trong thực tế, trở lại trong
ngày đi học,

832
00:40:35,750 --> 00:40:38,787
nếu bạn đã bao giờ gửi tin nhắn bí mật đến
một số người bạn hay một số lòng trong lớp,

833
00:40:38,787 --> 00:40:40,620
bạn có thể đã nghĩ
bạn đã bị thông minh

834
00:40:40,620 --> 00:40:46,530
bởi trên mảnh của bạn thay đổi giấy,
như, A đến B, và B đến C, và C đến D,

835
00:40:46,530 --> 00:40:47,590
và kể từ đó trở đi.

836
00:40:47,590 --> 00:40:50,300
Nhưng bạn đã thực sự mã hóa
thông tin của bạn, thậm chí

837
00:40:50,300 --> 00:40:53,300
nếu nó là một chút tầm thường, không phải là
rằng khó khăn cho giáo viên để nhận ra,

838
00:40:53,300 --> 00:40:55,675
tốt, nếu bạn chỉ cần thay đổi
B đến A và C đến B,

839
00:40:55,675 --> 00:40:57,550
bạn thực sự tìm ra
những gì được thông báo là,

840
00:40:57,550 --> 00:40:59,700
nhưng bạn đang ở trong mật mã thông tin.

841
00:40:59,700 --> 00:41:03,420
>> Bạn đã được chỉ làm việc đó
đơn giản, giống như Ralphie đây

842
00:41:03,420 --> 00:41:07,934
trong một bộ phim nổi tiếng mà chơi
nauseum quảng cáo khá nhiều mỗi mùa đông.

843
00:41:07,934 --> 00:41:08,600
[XEM LẠI VIDEO]

844
00:41:08,600 --> 00:41:11,180
-Be Nó biết là tất cả mà
Ralph Parker là hướng

845
00:41:11,180 --> 00:41:14,070
bổ nhiệm một thành viên của Little
Orphan Annie bí mật mối

846
00:41:14,070 --> 00:41:17,700
và được hưởng tất cả các danh hiệu
và lợi ích xảy ra kèm theo.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
phản ký Pierre Andre, bằng mực.

848
00:41:24,340 --> 00:41:27,160
Danh dự và lợi ích,
đã ở tuổi chín.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Hét]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Thôi nào.

853
00:41:34,250 --> 00:41:35,210
Hãy về với nó.

854
00:41:35,210 --> 00:41:39,530
Tôi không cần tất cả những nhạc jazz
về buôn lậu và cướp biển.

855
00:41:39,530 --> 00:41:41,660
>> tối mai -Listen cho
cuộc phiêu lưu kết luận

856
00:41:41,660 --> 00:41:43,880
của con tàu cướp biển đen.

857
00:41:43,880 --> 00:41:46,650
Bây giờ, đó là thời gian cho
thông điệp bí mật của Annie

858
00:41:46,650 --> 00:41:49,840
cho bạn thành viên của Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Hãy nhớ rằng, trẻ em, chỉ các thành viên
Secret Vòng Annie

860
00:41:53,570 --> 00:41:56,140
có thể giải mã thông điệp bí mật của Annie.

861
00:41:56,140 --> 00:42:00,340
>> Hãy nhớ rằng, Annie là tùy thuộc vào bạn.

862
00:42:00,340 --> 00:42:02,880
Đặt chân của bạn B2.

863
00:42:02,880 --> 00:42:05,230
Dưới đây là thông điệp.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Tôi Đang ở, cuộc họp bí mật đầu tiên của tôi.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Là trong đêm nay giọng hát tuyệt vời.

868
00:42:15,780 --> 00:42:19,000
Tôi có thể nói rằng tối nay
tin là thực sự quan trọng.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25 tuổi, đó là một thông điệp
từ Annie mình.

870
00:42:22,694 --> 00:42:23,860
Hãy nhớ rằng, đừng nói cho bất cứ ai.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Giây sau, tôi đang ở chỉ
các phòng trong nhà, nơi một cậu bé chín

873
00:42:32,930 --> 00:42:37,040
có thể ngồi trong sự riêng tư và giải mã.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Tôi đã đi đến tiếp theo, E.

876
00:42:42,360 --> 00:42:44,520
>> Từ đầu tiên là được.

877
00:42:44,520 --> 00:42:49,032
S, nó đã đến dễ dàng hơn bây giờ, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -Oh, Come on, Ralphie, tôi phải đi đây!

879
00:42:51,733 --> 00:42:53,688
>> -I'll Được phải xuống, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee whiz!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, hãy chắc chắn đối với: hãy chắc chắn những gì?

883
00:43:04,060 --> 00:43:05,970
Ít Orphan là gì
Annie cố gắng để nói?

884
00:43:05,970 --> 00:43:07,264
Hãy chắc chắn với những gì?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy đã nhận
đi, bạn sẽ vui lòng đi ra?

886
00:43:09,634 --> 00:43:10,480
>> -Tất Cả các quyền, Ma!

887
00:43:10,480 --> 00:43:12,880
Tôi sẽ ra ngay!

888
00:43:12,880 --> 00:43:14,550
>> -Tôi Đã nhận được gần gũi hơn với doanh nghiệp.

889
00:43:14,550 --> 00:43:16,620
Sự căng thẳng là khủng khiếp.

890
00:43:16,620 --> 00:43:17,720
Nó là cái gì vậy?

891
00:43:17,720 --> 00:43:20,170
Số phận của hành tinh
có thể treo trong sự cân bằng.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
gotta Andy đi!

894
00:43:23,170 --> 00:43:26,890
>> -I'll Ra ngay, buồn thì thôi!

895
00:43:26,890 --> 00:43:32,680
>> -Almost Đó, ngón tay của tôi đã bay, tâm trí của tôi
là một cái bẫy thép, mỗi lỗ chân lông rung.

896
00:43:32,680 --> 00:43:37,198
Đó là gần như rõ ràng, vâng, vâng, vâng.

897
00:43:37,198 --> 00:43:43,091
>> -Be Chắc chắn để uống Ovaltine của bạn.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Một thương mại dể thương?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Con trai của một chó cái.

903
00:43:54,227 --> 00:43:54,810
[END PLAYBACK]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Malan: OK, vậy
đó là một chặng đường rất dài

905
00:43:57,390 --> 00:44:00,660
giới thiệu mật mã,
và cũng Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Trong thực tế, từ quảng cáo cũ này
ở đây, tại sao là Ovaltine tốt như vậy?

907
00:44:04,470 --> 00:44:09,470
Nó là một chiết xuất tập trung của chín
mạch nha lúa mạch, sữa nguyên chất kem bò,

908
00:44:09,470 --> 00:44:14,360
và đặc biệt chuẩn bị ca cao, cùng
với phosphatides tự nhiên và các vitamin.

909
00:44:14,360 --> 00:44:18,240
Đó là tiếp tục củng cố bằng
bổ sung vitamin B và D, yum.

910
00:44:18,240 --> 00:44:21,600
Và bạn vẫn có thể có được nó, rõ ràng,
trên Amazon, như chúng ta đã làm ở đây.

911
00:44:21,600 --> 00:44:24,810
>> Nhưng động lực ở đây là để
giới thiệu mật mã, cụ thể

912
00:44:24,810 --> 00:44:28,340
một loại mật mã được biết đến
như mật mã khóa bí mật.

913
00:44:28,340 --> 00:44:34,284
Và như tên cho thấy, toàn bộ
an ninh của một hệ thống mật mã khóa bí mật,

914
00:44:34,284 --> 00:44:36,200
nếu bạn sẽ, một phương pháp luận
chỉ xáo trộn

915
00:44:36,200 --> 00:44:40,960
thông tin giữa hai người, là
chỉ người gửi và chỉ những người nhận

916
00:44:40,960 --> 00:44:46,980
biết một bí mật key-- một số giá trị, một số
cụm từ bí mật, một số con số bí mật, mà

917
00:44:46,980 --> 00:44:50,660
cho phép họ cả mã hóa
và giải mã thông tin.

918
00:44:50,660 --> 00:44:53,470
Và mật mã, thực sự,
chỉ này từ tuần 0 là.

919
00:44:53,470 --> 00:44:56,715
>> Đó là một vấn đề mà có đầu vào,
như tin nhắn thực tế bằng tiếng Anh

920
00:44:56,715 --> 00:44:59,340
hoặc bất cứ ngôn ngữ mà bạn
muốn gửi đến một ai đó trong lớp,

921
00:44:59,340 --> 00:45:00,580
hoặc trên internet.

922
00:45:00,580 --> 00:45:03,840
Có một số sản lượng, mà là có
là thông điệp hỗn độn mà bạn

923
00:45:03,840 --> 00:45:05,250
muốn người nhận nhận được.

924
00:45:05,250 --> 00:45:07,405
Và thậm chí nếu ai đó trong
giữa nhận nó quá,

925
00:45:07,405 --> 00:45:09,780
bạn không muốn họ
nhất thiết phải có khả năng giải mã nó,

926
00:45:09,780 --> 00:45:12,840
vì bên trong này
hộp đen, hoặc thuật toán,

927
00:45:12,840 --> 00:45:17,650
một số cơ chế, một số từng bước
hướng dẫn, để lấy đầu vào mà

928
00:45:17,650 --> 00:45:20,710
và chuyển đổi nó vào
đầu ra, trong hy vọng một cách an toàn.

929
00:45:20,710 --> 00:45:23,640
>> Và, trên thực tế, có một số
từ vựng trong thế giới này như sau.

930
00:45:23,640 --> 00:45:26,100
Đồng bằng văn bản là một từ
khoa học máy tính sẽ

931
00:45:26,100 --> 00:45:28,449
sử dụng để mô tả các đầu vào
tin nhắn, như tiếng Anh

932
00:45:28,449 --> 00:45:31,240
hoặc bất cứ ngôn ngữ bạn thực sự
muốn gửi đến một số người khác.

933
00:45:31,240 --> 00:45:35,450
Và sau đó các bản mã là tranh giành
đến enciphered, hoặc mật mã,

934
00:45:35,450 --> 00:45:36,520
phiên bản hiện.

935
00:45:36,520 --> 00:45:38,750
>> Nhưng có một thành phần khác ở đây.

936
00:45:38,750 --> 00:45:43,200
Có một đầu vào khác
bí mật mật mã khóa.

937
00:45:43,200 --> 00:45:45,200
Và đó chính là chìa khóa riêng của mình,
đó là, nói chung,

938
00:45:45,200 --> 00:45:48,930
như chúng ta sẽ thấy, một số, hoặc
lá thư, hoặc từ, bất cứ điều gì

939
00:45:48,930 --> 00:45:51,980
các thuật toán đó là thực sự hy vọng.

940
00:45:51,980 --> 00:45:53,870
>> Và làm thế nào để bạn giải mã thông tin?

941
00:45:53,870 --> 00:45:55,110
Làm thế nào để bạn xắp xếp lại nó?

942
00:45:55,110 --> 00:45:57,950
Vâng, bạn chỉ cần đảo ngược
kết quả đầu ra và đầu vào.

943
00:45:57,950 --> 00:46:00,900
>> Nói cách khác, một khi một người nào đó
nhận được tin nhắn mã hóa của bạn,

944
00:46:00,900 --> 00:46:03,740
anh ta hoặc cô chỉ đơn giản là có
để biết rằng cùng một chìa khóa.

945
00:46:03,740 --> 00:46:05,700
Họ đã nhận được bản mã.

946
00:46:05,700 --> 00:46:09,530
Và bằng cách cắm hai
đầu vào cho hệ thống mật,

947
00:46:09,530 --> 00:46:14,260
các thuật toán, hộp đen này, trên
nên đến các bản rõ ban đầu.

948
00:46:14,260 --> 00:46:17,830
Và đó là mức độ rất cao
xem những gì thực sự là mật mã

949
00:46:17,830 --> 00:46:18,590
tất cả về.

950
00:46:18,590 --> 00:46:20,030
>> Vì vậy, chúng ta hãy đến đó.

951
00:46:20,030 --> 00:46:22,700
Giờ hãy xem bên dưới
mui xe của một cái gì đó

952
00:46:22,700 --> 00:46:26,000
chúng tôi đã thực hiện trong nhiều cấp cho
tuần qua, và cho phần này

953
00:46:26,000 --> 00:46:27,629
đây-- chuỗi.

954
00:46:27,629 --> 00:46:30,295
Một chuỗi vào cuối ngày
chỉ là một chuỗi các ký tự.

955
00:46:30,295 --> 00:46:33,610
>> Nó có thể là hello thế giới, hoặc
xin chào Zamyla, hoặc bất cứ điều gì.

956
00:46:33,610 --> 00:46:37,050
Nhưng điều đó có nghĩa là
là một chuỗi các ký tự?

957
00:46:37,050 --> 00:46:41,520
Trong thực tế, thư viện CS50 cho
chúng ta một loại dữ liệu được gọi là chuỗi.

958
00:46:41,520 --> 00:46:45,140
>> Nhưng có thật là không
những điều như một chuỗi trong C.

959
00:46:45,140 --> 00:46:49,450
Nó thực sự chỉ là một chuỗi các
nhân vật, nhân vật, nhân vật,

960
00:46:49,450 --> 00:46:52,180
nhân vật, trở lại, trở lại, để
trở lại, trở lại, để trở lại bên trong

961
00:46:52,180 --> 00:46:54,650
bộ nhớ của máy tính, hoặc bộ nhớ RAM.

962
00:46:54,650 --> 00:46:58,940
Và chúng ta sẽ tìm hiểu sâu hơn rằng trong
tương lai khi chúng ta nhìn vào bộ nhớ chính nó,

963
00:46:58,940 --> 00:47:02,030
và việc sử dụng, và
các mối đe dọa có liên quan.

964
00:47:02,030 --> 00:47:04,100
>> Nhưng chúng ta hãy xem xét các chuỗi Zamyla.

965
00:47:04,100 --> 00:47:07,480
Vì vậy, chỉ là tên của
những con người ở đây, Zamyla,

966
00:47:07,480 --> 00:47:12,030
đó là một chuỗi các
ký tự, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Và bây giờ chúng ta hãy giả sử rằng tên của Zamyla
đang được lưu trữ bên trong của một máy tính

968
00:47:16,020 --> 00:47:16,880
chương trình.

969
00:47:16,880 --> 00:47:20,830
>> Vâng, nó đứng vào lý do đó chúng ta nên
có thể nhìn vào những nhân vật

970
00:47:20,830 --> 00:47:21,590
cá nhân.

971
00:47:21,590 --> 00:47:24,710
Vì vậy, tôi chỉ cần đi để vẽ một chút
hộp xung quanh tên Zamyla ở đây.

972
00:47:24,710 --> 00:47:31,580
Và đó là trường hợp trong C mà khi bạn
có một chuỗi, như Zamyla-- và có thể

973
00:47:31,580 --> 00:47:34,940
chuỗi đó đã trở lại từ
một chức năng như get chuỗi,

974
00:47:34,940 --> 00:47:38,540
bạn thực sự có thể thao tác
nó từng ký tự.

975
00:47:38,540 --> 00:47:42,070
>> Bây giờ, đây là Gecman cho
chuyện ở bàn tay, bởi vì

976
00:47:42,070 --> 00:47:46,420
trong mật mã nếu bạn muốn thay đổi
A đến B, và B đến C, và C đến D,

977
00:47:46,420 --> 00:47:49,650
và vv, bạn cần để có thể
để xem xét các đặc điểm cá nhân

978
00:47:49,650 --> 00:47:50,190
trong một chuỗi.

979
00:47:50,190 --> 00:47:52,695
Bạn cần để có thể thay đổi
Z đến cái gì khác, A

980
00:47:52,695 --> 00:47:55,280
cái gì khác, M để
cái gì khác, và như vậy.

981
00:47:55,280 --> 00:47:58,000
Và như vậy chúng ta cần có một cách,
lập trình, vì vậy

982
00:47:58,000 --> 00:48:03,020
để nói chuyện, trong C để có thể thay đổi
và nhìn vào bức thư cá nhân.

983
00:48:03,020 --> 00:48:05,690
Và chúng ta có thể làm điều này như sau.

984
00:48:05,690 --> 00:48:08,340
>> Hãy để tôi đi quay trở lại trong CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Và hãy để tôi đi trước
và tạo ra một tập tin mới

986
00:48:11,130 --> 00:48:16,134
mà tôi sẽ gọi thời gian string0 này,
như đầu tiên ví dụ như chúng tôi, chấm c.

987
00:48:16,134 --> 00:48:18,300
Và tôi sẽ đi trước
và quất nó lên như sau.

988
00:48:18,300 --> 00:48:22,870
>> Vì vậy, bao gồm CS50.h, và
sau đó bao gồm io.h tiêu chuẩn,

989
00:48:22,870 --> 00:48:25,990
mà tôi gần như luôn luôn
được sử dụng trong các chương trình của tôi, ít nhất

990
00:48:25,990 --> 00:48:26,780
ban đầu.

991
00:48:26,780 --> 00:48:32,180
int void main, và sau đó ở đây tôi
sẽ làm dây bị nhận được chuỗi.

992
00:48:32,180 --> 00:48:35,260
Và sau đó tôi sẽ
đi trước và làm điều này.

993
00:48:35,260 --> 00:48:37,460
Tôi muốn đi trước
và, như một kiểm tra sự tỉnh táo,

994
00:48:37,460 --> 00:48:43,607
chỉ nói, chào hỏi, phần trăm s,
dấu chấm phẩy, làm cho chuỗi 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, tôi đã làm gì ở đây?

996
00:48:44,690 --> 00:48:45,930
Oh, tôi không cắm nó vào.

997
00:48:45,930 --> 00:48:48,120
Vì vậy, bài học kinh nghiệm, đó
không cố ý.

998
00:48:48,120 --> 00:48:52,480
>> Vì vậy, lỗi, hơn trăm
chuyển đổi hơn so với đối số dữ liệu.

999
00:48:52,480 --> 00:48:54,940
Và đây là nơi mà, trong
dòng 7-- OK, vì vậy tôi có,

1000
00:48:54,940 --> 00:48:56,690
quote unquote, đó là
chuỗi của tôi printf.

1001
00:48:56,690 --> 00:48:58,151
Tôi đã có một dấu phần trăm.

1002
00:48:58,151 --> 00:48:59,650
Nhưng tôi là thiếu số thứ hai.

1003
00:48:59,650 --> 00:49:03,190
>> Tôi đang thiếu các dấu phẩy s,
Tôi đã có trong ví dụ trước.

1004
00:49:03,190 --> 00:49:06,650
Vì vậy, một cơ hội tốt để sửa chữa
thêm một sai lầm, vô tình.

1005
00:49:06,650 --> 00:49:09,950
Và bây giờ hãy để tôi chạy
string0, gõ Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, xin chào Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Vì vậy, chúng tôi đã chạy loại chương trình
một vài lần khác bây giờ.

1008
00:49:14,144 --> 00:49:16,310
Nhưng chúng ta hãy làm một cái gì đó
chút khác nhau thời gian này.

1009
00:49:16,310 --> 00:49:19,450
Thay vì chỉ cần in Zamyla của
toàn bộ tên với printf,

1010
00:49:19,450 --> 00:49:21,350
chúng ta hãy làm điều đó từng ký tự.

1011
00:49:21,350 --> 00:49:22,700
>> Tôi sẽ sử dụng một vòng lặp for.

1012
00:49:22,700 --> 00:49:26,160
Và tôi sẽ cung cấp cho bản thân mình
một biến đếm, gọi tôi.

1013
00:49:26,160 --> 00:49:33,530
Và tôi sẽ giữ iterating, vì vậy
khi i nhỏ hơn chiều dài của s.

1014
00:49:33,530 --> 00:49:35,930
>> Hóa ra, chúng tôi đã không
làm này thời gian qua,

1015
00:49:35,930 --> 00:49:39,100
mà c đi kèm với một
chức năng gọi là Stirling.

1016
00:49:39,100 --> 00:49:42,690
Quay lại trong ngày, và nói chung
vẫn còn khi thực hiện chức năng,

1017
00:49:42,690 --> 00:49:45,405
con người thường sẽ chọn rất
tên ngắn gọn rằng loại âm thanh

1018
00:49:45,405 --> 00:49:48,280
giống như những gì bạn muốn, mặc dù nó
thiếu một vài nguyên âm hoặc chữ cái.

1019
00:49:48,280 --> 00:49:50,660
Vì vậy, Stirling là
tên của một hàm

1020
00:49:50,660 --> 00:49:53,880
có một đối giữa
ngoặc đơn mà phải là một chuỗi.

1021
00:49:53,880 --> 00:49:56,910
Và nó chỉ trả về một số nguyên,
chiều dài của chuỗi.

1022
00:49:56,910 --> 00:50:00,580
>> Vì vậy, điều này cho vòng lặp trên dòng 7 sẽ
để bắt đầu đếm tại i bằng 0.

1023
00:50:00,580 --> 00:50:02,530
Nó sẽ tăng
i trên mỗi lần lặp

1024
00:50:02,530 --> 00:50:04,350
1, như chúng tôi đã làm một vài lần.

1025
00:50:04,350 --> 00:50:06,780
Nhưng nó sẽ chỉ làm
up này cho đến khi các điểm

1026
00:50:06,780 --> 00:50:09,660
khi tôi là chiều dài
của chuỗi chính nó.

1027
00:50:09,660 --> 00:50:14,520
>> Vì vậy, đây là một cách, cuối cùng,
iterating trên các ký tự

1028
00:50:14,520 --> 00:50:17,430
trong chuỗi như là sau.

1029
00:50:17,430 --> 00:50:20,670
Tôi sẽ in ra không phải là một
toàn bộ chuỗi, nhưng tỷ lệ c,

1030
00:50:20,670 --> 00:50:22,860
một nhân vật duy nhất
theo sau là một dòng mới.

1031
00:50:22,860 --> 00:50:24,880
Và sau đó tôi sẽ
đi trước, và tôi cần

1032
00:50:24,880 --> 00:50:29,080
để nói rằng tôi muốn in
nhân vật thứ i của s.

1033
00:50:29,080 --> 00:50:33,450
>> Vì vậy, nếu tôi là biến mà chỉ
chỉ số của chuỗi, nơi

1034
00:50:33,450 --> 00:50:37,230
bạn đang ở trong đó, tôi cần để có thể
nói, đưa cho tôi nhân vật thứ i của s.

1035
00:50:37,230 --> 00:50:40,390
Và c có một cách làm
này với dấu ngoặc vuông.

1036
00:50:40,390 --> 00:50:43,679
Bạn chỉ cần nói tên của
chuỗi, mà trong trường hợp này là s.

1037
00:50:43,679 --> 00:50:46,970
Sau đó, bạn sử dụng dấu ngoặc vuông, đó là
thường chỉ trên Return hoặc Enter của bạn

1038
00:50:46,970 --> 00:50:48,110
phím trên bàn phím.

1039
00:50:48,110 --> 00:50:52,410
Và sau đó bạn đưa các chỉ số của các
nhân vật mà bạn muốn in.

1040
00:50:52,410 --> 00:50:55,960
Vì vậy, các chỉ số sẽ là một
number-- 0 hoặc 1, hoặc 2, hoặc 3, hoặc dấu chấm,

1041
00:50:55,960 --> 00:50:57,590
dấu chấm, dấu chấm, một số số khác.

1042
00:50:57,590 --> 00:51:00,920
>> Và chúng tôi đảm bảo rằng nó sẽ
là số đúng, bởi vì tôi

1043
00:51:00,920 --> 00:51:02,360
bắt đầu đếm từ 0.

1044
00:51:02,360 --> 00:51:07,020
Và theo mặc định, các ký tự đầu tiên
trong một chuỗi là do quy ước 0.

1045
00:51:07,020 --> 00:51:09,230
Và nhân vật thứ hai là khung 1.

1046
00:51:09,230 --> 00:51:11,120
Và nhân vật thứ ba là khung 2.

1047
00:51:11,120 --> 00:51:13,630
Và bạn không muốn đi quá
đến nay, nhưng chúng ta sẽ không phải vì chúng tôi

1048
00:51:13,630 --> 00:51:17,780
sẽ chỉ tăng i cho đến khi nó
bằng với chiều dài của chuỗi.

1049
00:51:17,780 --> 00:51:20,210
Và tại thời điểm đó,
điều này cho vòng lặp sẽ dừng lại.

1050
00:51:20,210 --> 00:51:25,550
>> Vì vậy, hãy để tôi đi trước và lưu này
chương trình, và chạy làm cho chuỗi 0.

1051
00:51:25,550 --> 00:51:28,400
Nhưng tôi hơi say lên.

1052
00:51:28,400 --> 00:51:35,390
Ngầm tuyên bố chức năng thư viện
Stirling với loại như vậy và such-- bây giờ,

1053
00:51:35,390 --> 00:51:36,430
điều này có vẻ quen thuộc.

1054
00:51:36,430 --> 00:51:37,440
Nhưng nó không printf.

1055
00:51:37,440 --> 00:51:38,540
Và nó không nhận được chuỗi.

1056
00:51:38,540 --> 00:51:40,480
>> Tôi không vít lên trong
cách cùng thời gian này.

1057
00:51:40,480 --> 00:51:45,100
Nhưng chú ý xuống đây một chút xuống
hơn nữa, bao gồm string.h tiêu đề,

1058
00:51:45,100 --> 00:51:47,210
một cách rõ ràng cung cấp
khai Stirling.

1059
00:51:47,210 --> 00:51:48,820
Vì vậy, có thực sự là một đầu mối trong đó.

1060
00:51:48,820 --> 00:51:51,670
>> Và thực sự nó quay ra
có một tập tin tiêu đề

1061
00:51:51,670 --> 00:51:53,970
mà chúng tôi đã không được sử dụng
trong lớp, nhưng nó

1062
00:51:53,970 --> 00:51:56,480
trong số những người có sẵn
cho bạn, gọi là string.h.

1063
00:51:56,480 --> 00:52:00,930
Và trong tập tin, string.h
là Stirling tuyên bố.

1064
00:52:00,930 --> 00:52:05,220
Vì vậy, hãy để tôi đi trước và
tiết kiệm này, làm cho chuỗi

1065
00:52:05,220 --> 00:52:08,040
0-- tốt đẹp, không có thông báo lỗi thời gian này.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, và
Tôi về để nhấn Enter,

1067
00:52:12,290 --> 00:52:16,710
tại thời điểm đó getString sẽ
để trả lại chuỗi, đặt nó trong s.

1068
00:52:16,710 --> 00:52:21,890
Sau đó, mà cho vòng lặp sẽ lặp
nhân vật của S cùng một lúc,

1069
00:52:21,890 --> 00:52:28,420
và in chúng trên mỗi dòng, bởi vì
Tôi đã có n dấu chéo ngược ở cuối.

1070
00:52:28,420 --> 00:52:34,530
Vì vậy, tôi có thể bỏ qua dấu chéo ngược mà
n, và sau đó chỉ cần in Zamyla tất cả

1071
00:52:34,530 --> 00:52:37,460
trong cùng một dòng,
reimplementing hiệu quả

1072
00:52:37,460 --> 00:52:38,999
printf, đó không phải là tất cả những gì có ích.

1073
00:52:38,999 --> 00:52:40,540
Nhưng trong trường hợp này, tôi đã không làm điều đó.

1074
00:52:40,540 --> 00:52:43,610
Tôi đã thực sự in một
nhân vật tại một thời điểm, mỗi dòng,

1075
00:52:43,610 --> 00:52:45,400
để chúng tôi thực sự thấy hiệu quả.

1076
00:52:45,400 --> 00:52:46,900
>> Nhưng tôi cần phải lưu ý một điều ở đây.

1077
00:52:46,900 --> 00:52:48,930
Và chúng tôi sẽ trở lại
này trong một tuần trong tương lai.

1078
00:52:48,930 --> 00:52:52,650
Nó chỉ ra rằng điều này
đang có khả năng lỗi.

1079
00:52:52,650 --> 00:52:56,560
>> Nó chỉ ra rằng get chuỗi
và một số chức năng khác trong cuộc sống

1080
00:52:56,560 --> 00:53:00,280
không nhất thiết phải luôn luôn
trả lại những gì bạn đang mong đợi.

1081
00:53:00,280 --> 00:53:03,010
Chúng tôi biết từ lớp cuối cùng
Hiện tại này mà có được

1082
00:53:03,010 --> 00:53:04,960
chuỗi là vụ phải trả lại một chuỗi.

1083
00:53:04,960 --> 00:53:09,900
Nhưng nếu sử dụng các loại ra như vậy
một từ lâu, hoặc đoạn, hoặc bài luận

1084
00:53:09,900 --> 00:53:13,010
rằng có chỉ là không đủ
bộ nhớ trong máy tính để phù hợp với nó.

1085
00:53:13,010 --> 00:53:15,410
>> Giống như, nếu có điều gì
sai bên dưới mui xe?

1086
00:53:15,410 --> 00:53:18,400
Nó có thể không xảy ra thường xuyên,
nhưng nó có thể xảy ra một lần

1087
00:53:18,400 --> 00:53:21,520
trong một thời gian, rất thường xuyên.

1088
00:53:21,520 --> 00:53:25,460
Và do đó, nó chỉ ra rằng get chuỗi
và các chức năng như nó không nhất thiết phải

1089
00:53:25,460 --> 00:53:26,380
luôn luôn trở về chuỗi.

1090
00:53:26,380 --> 00:53:30,680
Họ có thể trở lại một số giá trị lỗi,
một số giá trị trọng điểm như vậy để nói chuyện,

1091
00:53:30,680 --> 00:53:32,612
mà chỉ ra rằng
một cái gì đó đã đi sai.

1092
00:53:32,612 --> 00:53:35,320
Và bạn sẽ chỉ biết điều này từ
đã học được nó trong lớp bây giờ,

1093
00:53:35,320 --> 00:53:37,700
hoặc khi đọc một số tài liệu hơn.

1094
00:53:37,700 --> 00:53:43,120
Nó chỉ ra rằng get chuỗi
có thể trả về một giá trị gọi là null.

1095
00:53:43,120 --> 00:53:46,220
Null là một giá trị đặc biệt mà chúng tôi sẽ
trở lại trong một tuần trong tương lai.

1096
00:53:46,220 --> 00:53:50,420
Nhưng bây giờ, chỉ biết rằng nếu tôi muốn
phải thực sự thích hợp trong việc di chuyển về phía trước

1097
00:53:50,420 --> 00:53:52,650
sử dụng get chuỗi, tôi
không nên chỉ gọi nó,

1098
00:53:52,650 --> 00:53:56,870
và mù quáng sử dụng giá trị trả về của nó,
tin tưởng rằng đó là một chuỗi.

1099
00:53:56,870 --> 00:53:59,420
>> đầu tiên tôi nên nói,
hey, chờ một chút, chỉ

1100
00:53:59,420 --> 00:54:03,380
tiến hành nếu s không bằng
null, nơi null, một lần nữa,

1101
00:54:03,380 --> 00:54:04,660
chỉ là một số giá trị đặc biệt.

1102
00:54:04,660 --> 00:54:07,770
Và nó chỉ có giá trị đặc biệt của bạn
cần phải lo lắng về cho get chuỗi.

1103
00:54:07,770 --> 00:54:10,900
Nhận chuỗi là hoặc sẽ
trả về một chuỗi hoặc null.

1104
00:54:10,900 --> 00:54:17,219
>> Và dấu chấm than này dấu bằng
bạn có thể biết từ có lẽ lớp toán học

1105
00:54:17,219 --> 00:54:20,510
mà bạn có thể vẽ một dấu bằng với
một dòng qua nó để chỉ ra không bằng nhau.

1106
00:54:20,510 --> 00:54:23,135
Đó không phải là một nhân vật thường
bạn có thể gõ trên bàn phím của bạn.

1107
00:54:23,135 --> 00:54:26,480
Và do đó, trong hầu hết các ngôn ngữ lập trình,
khi bạn muốn nói không bằng nhau,

1108
00:54:26,480 --> 00:54:29,160
bạn sử dụng một dấu chấm than,
hay còn gọi là nổ.

1109
00:54:29,160 --> 00:54:33,180
Vì vậy, bạn nói nổ bình đẳng là
có nghĩa là không bằng, hợp lý.

1110
00:54:33,180 --> 00:54:38,060
Nó giống như không có một lớn hơn
hơn, hoặc bằng, hoặc ít hơn

1111
00:54:38,060 --> 00:54:41,270
hoặc bằng chìa khóa trên bàn phím của bạn
mà sẽ làm tất cả trong một biểu tượng.

1112
00:54:41,270 --> 00:54:44,020
Vì vậy, đó là lý do tại sao, trong các ví dụ trước đây,
bạn đã làm một khung mở, và sau đó

1113
00:54:44,020 --> 00:54:48,670
một dấu bằng, để làm
lớn hơn hoặc, nói, ít hơn.

1114
00:54:48,670 --> 00:54:49,910
>> Vì vậy, các takeaway những gì ở đây?

1115
00:54:49,910 --> 00:54:53,880
Điều này chỉ đơn giản là một cách bây giờ của
giới thiệu cú pháp này, tính năng này,

1116
00:54:53,880 --> 00:54:57,390
iterating trên cá nhân
ký tự trong một chuỗi.

1117
00:54:57,390 --> 00:55:00,260
Và cũng giống như những vuông
dấu ngoặc đơn cho phép bạn để có được ở họ,

1118
00:55:00,260 --> 00:55:03,790
xem xét những dấu ngoặc vuông như
loại gián tiếp tại cơ bản này

1119
00:55:03,790 --> 00:55:06,040
thiết kế, theo đó mỗi
nhân vật bên trong của một chuỗi

1120
00:55:06,040 --> 00:55:10,180
là loại đóng hộp ở đâu đó bên dưới
mui xe trong bộ nhớ của máy tính của bạn.

1121
00:55:10,180 --> 00:55:12,340
>> Nhưng chúng ta hãy làm một biến thể của này.

1122
00:55:12,340 --> 00:55:14,880
Nó chỉ ra rằng điều này
chương trình là đúng.

1123
00:55:14,880 --> 00:55:18,810
Vì vậy, mỗi trục CS50 của để đánh giá
code, điều này là đúng ngay bây giờ.

1124
00:55:18,810 --> 00:55:22,959
Đặc biệt là bây giờ mà tôi đang kiểm tra cho
null, chương trình này không bao giờ sụp đổ.

1125
00:55:22,959 --> 00:55:24,500
Và tôi chỉ biết rằng từ kinh nghiệm.

1126
00:55:24,500 --> 00:55:28,040
Nhưng không có gì khác mà
chúng tôi thực sự có thể đi sai ở đây.

1127
00:55:28,040 --> 00:55:31,860
Nhưng nó không phải là rất được thiết kế tốt,
bởi vì chúng ta hãy quay trở lại vấn đề cơ bản.

1128
00:55:31,860 --> 00:55:34,450
>> Đầu tiên, principles--
những gì hiện một vòng lặp làm gì?

1129
00:55:34,450 --> 00:55:36,290
Một vòng lặp hiện ba điều.

1130
00:55:36,290 --> 00:55:39,340
Nó khởi tạo một số
giá trị, nếu bạn yêu cầu.

1131
00:55:39,340 --> 00:55:41,770
Nó kiểm tra một điều kiện.

1132
00:55:41,770 --> 00:55:45,380
Và sau mỗi
lặp đi lặp lại, sau mỗi chu kỳ,

1133
00:55:45,380 --> 00:55:49,330
nó increments số
giá trị, hoặc giá trị, ở đây.

1134
00:55:49,330 --> 00:55:50,600
>> Vậy điều đó có nghĩa là gì?

1135
00:55:50,600 --> 00:55:52,940
Chúng tôi khởi tạo i đến 0.

1136
00:55:52,940 --> 00:55:58,610
Chúng tôi kiểm tra và chắc chắn rằng tôi là ít hơn
chiều dài của s, đó là Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
như vậy mà là ít hơn 6.

1138
00:55:59,900 --> 00:56:02,590
Và, quả thật vậy, 0 là ít hơn 6.

1139
00:56:02,590 --> 00:56:05,580
>> Chúng tôi in ra Z từ tên Zamyla của.

1140
00:56:05,580 --> 00:56:08,080
Sau đó, chúng tôi tăng i 0-1.

1141
00:56:08,080 --> 00:56:11,290
Sau đó chúng tôi kiểm tra, là 1 ít
so với chiều dài của s?

1142
00:56:11,290 --> 00:56:13,270
Chiều dài của s là 6.

1143
00:56:13,270 --> 00:56:13,950
Vâng, đó là.

1144
00:56:13,950 --> 00:56:16,880
>> Vì vậy, chúng tôi in một tên Zamyla của, ZA.

1145
00:56:16,880 --> 00:56:20,090
Chúng tôi tăng i từ 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Sau đó chúng tôi kiểm tra, là 2 ít hơn
chiều dài của tên Zamyla của.

1147
00:56:23,720 --> 00:56:25,380
6- do đó, 2 là ít hơn 6.

1148
00:56:25,380 --> 00:56:30,460
Vâng, chúng ta hãy in ra tại M trong
Tên Zamyla của, nhân vật thứ ba.

1149
00:56:30,460 --> 00:56:34,110
>> Chìa khóa ở đây là trên mỗi
lặp đi lặp lại của câu chuyện, tôi đang kiểm tra,

1150
00:56:34,110 --> 00:56:37,810
là tôi ít hơn độ dài của Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Nhưng nắm bắt được rằng
Stirling không phải là một tài sản.

1152
00:56:40,350 --> 00:56:43,100
Những người bạn của những người đã được lập trình
trước ở Java hoặc các ngôn ngữ khác

1153
00:56:43,100 --> 00:56:46,310
có thể biết chiều dài của một chuỗi là
một tài sản, chỉ cần một số chỉ đọc giá trị.

1154
00:56:46,310 --> 00:56:50,220
>> Trong C trong trường hợp này, nếu điều này là
một chức năng mà là nghĩa đen

1155
00:56:50,220 --> 00:56:53,520
đếm số lượng
nhân vật trong Zamyla mỗi lần

1156
00:56:53,520 --> 00:56:54,740
chúng tôi gọi là chức năng.

1157
00:56:54,740 --> 00:56:58,500
Mỗi khi bạn yêu cầu máy tính để sử dụng
Stirling, nó lấy một cái nhìn tại Zamyla,

1158
00:56:58,500 --> 00:57:01,960
và nói Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Và nó trả 6.

1160
00:57:02,962 --> 00:57:04,920
Lần sau khi bạn gọi
nó bên trong vòng lặp for,

1161
00:57:04,920 --> 00:57:08,610
nó sẽ nhìn vào Zamyla
một lần nữa, nói Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Và nó sẽ trở lại 6.

1163
00:57:10,320 --> 00:57:12,980
Vậy điều gì ngu ngốc về thiết kế này?

1164
00:57:12,980 --> 00:57:17,700
>> Tại sao mã của tôi không phải là một 5 trong 5
cho thiết kế ngay bây giờ, có thể nói?

1165
00:57:17,700 --> 00:57:20,600
Vâng, tôi đang hỏi một
câu hỏi không cần thiết.

1166
00:57:20,600 --> 00:57:23,030
Tôi đang làm việc nhiều hơn tôi cần.

1167
00:57:23,030 --> 00:57:25,370
>> Vì vậy, mặc dù
Câu trả lời là đúng, tôi

1168
00:57:25,370 --> 00:57:29,560
yêu cầu máy tính, những gì là
chiều dài của Zamyla một lần nữa,

1169
00:57:29,560 --> 00:57:31,380
và một lần nữa, và một lần nữa, và một lần nữa?

1170
00:57:31,380 --> 00:57:33,980
Và câu trả lời là
sẽ không bao giờ thay đổi.

1171
00:57:33,980 --> 00:57:35,900
Nó luôn luôn có được 6.

1172
00:57:35,900 --> 00:57:39,730
>> Vì vậy, một giải pháp tốt hơn thế này
sẽ là phiên bản tiếp theo này.

1173
00:57:39,730 --> 00:57:43,390
Hãy để tôi đi trước và đặt nó trong một
file riêng biệt gọi là string1.c,

1174
00:57:43,390 --> 00:57:44,990
chỉ để giữ cho nó tách biệt.

1175
00:57:44,990 --> 00:57:47,260
Và hóa ra trong một cho
vòng lặp, bạn có thể thực sự

1176
00:57:47,260 --> 00:57:50,210
khai báo nhiều biến cùng một lúc.

1177
00:57:50,210 --> 00:57:53,460
>> Vì vậy, tôi sẽ giữ tôi và đặt nó vào 0.

1178
00:57:53,460 --> 00:57:56,190
Nhưng tôi cũng sẽ đến
thêm một dấu phẩy, và nói,

1179
00:57:56,190 --> 00:58:01,050
cho tôi một biến gọi là n, có
giá trị bằng với chiều dài chuỗi s.

1180
00:58:01,050 --> 00:58:09,410
Và bây giờ, xin hãy làm cho tình trạng của tôi
miễn là tôi là nhỏ hơn n.

1181
00:58:09,410 --> 00:58:14,140
>> Vì vậy, theo cách này, logic là
giống hệt nhau vào cuối ngày.

1182
00:58:14,140 --> 00:58:18,280
Nhưng tôi nhớ lại
giá trị 6, trong trường hợp này.

1183
00:58:18,280 --> 00:58:19,780
chiều dài của tên Zamyla là gì?

1184
00:58:19,780 --> 00:58:20,860
Và tôi đặt nó ở n.

1185
00:58:20,860 --> 00:58:23,050
>> Và tôi vẫn đang kiểm tra
điều kiện mỗi lần.

1186
00:58:23,050 --> 00:58:24,300
Là 0 ít hơn 6?

1187
00:58:24,300 --> 00:58:25,600
Là 1 ít hơn 6?

1188
00:58:25,600 --> 00:58:28,600
Là 2 ít hơn 6, và vân vân?

1189
00:58:28,600 --> 00:58:31,914
>> Nhưng tôi không yêu cầu máy tính
một lần nữa, và một lần nữa, có chuyện gì

1190
00:58:31,914 --> 00:58:33,080
chiều dài của tên Zamyla của?

1191
00:58:33,080 --> 00:58:34,320
chiều dài của tên Zamyla của là gì?

1192
00:58:34,320 --> 00:58:35,986
chiều dài của tên của Zamyla này là gì?

1193
00:58:35,986 --> 00:58:40,440
Tôi nghĩa đen nhớ rằng đầu tiên và
chỉ trả lời trong n biến thứ hai này.

1194
00:58:40,440 --> 00:58:45,280
Vì vậy, đây bây giờ sẽ là không chỉ
chính xác, nhưng cũng được thiết kế tốt.

1195
00:58:45,280 --> 00:58:46,670
>> Bây giờ, những gì về phong cách?

1196
00:58:46,670 --> 00:58:48,866
Tôi đã đặt tên biến của tôi
khá tốt, tôi sẽ nói.

1197
00:58:48,866 --> 00:58:50,240
Họ là siêu gọn gàng ngay bây giờ.

1198
00:58:50,240 --> 00:58:52,090
Và đó là hoàn toàn tốt đẹp.

1199
00:58:52,090 --> 00:58:55,120
>> Nếu bạn chỉ có một
chuỗi trong một chương trình,

1200
00:58:55,120 --> 00:58:56,860
bạn cũng có thể gọi nó là cho chuỗi.

1201
00:58:56,860 --> 00:58:59,370
Nếu bạn chỉ có một biến
đếm trong một chương trình,

1202
00:58:59,370 --> 00:59:00,710
bạn cũng có thể gọi nó là i.

1203
00:59:00,710 --> 00:59:03,500
Nếu bạn có một chiều dài, n
là siêu chung là tốt.

1204
00:59:03,500 --> 00:59:05,800
Nhưng tôi đã không nhận xét bất kỳ mã của tôi.

1205
00:59:05,800 --> 00:59:09,200
>> Tôi đã không thông báo reader--
cho dù đó là TF của tôi, hoặc hỗ trợ kỹ thuật,

1206
00:59:09,200 --> 00:59:12,460
hoặc chỉ colleague-- những gì được mong
được diễn ra trong chương trình này.

1207
00:59:12,460 --> 00:59:15,760
Và như vậy để có được phong cách tốt,
những gì tôi muốn làm

1208
00:59:15,760 --> 00:59:24,580
là một cái gì đó này--
như yêu cầu người sử dụng cho đầu vào.

1209
00:59:24,580 --> 00:59:26,670
Và tôi có thể viết lại
này nhiều cách.

1210
00:59:26,670 --> 00:59:35,630
>> Hãy chắc chắn rằng s-- đảm bảo get
chuỗi trả lại một chuỗi.

1211
00:59:35,630 --> 00:59:40,280
Và sau đó trong đây-- và điều này có lẽ là
sự lặp comment-- quan trọng nhất

1212
00:59:40,280 --> 00:59:44,450
qua các nhân vật trong s cùng một lúc.

1213
00:59:44,450 --> 00:59:47,060
Và tôi có thể sử dụng bất kỳ
lựa chọn ngôn ngữ tiếng Anh

1214
00:59:47,060 --> 00:59:49,650
đây để mô tả mỗi
các khối mã.

1215
00:59:49,650 --> 00:59:52,740
>> Chú ý rằng tôi đã không đặt một
nhận xét về tất cả các dòng mã,

1216
00:59:52,740 --> 00:59:55,690
thực sự chỉ là trên thú
những người thân, những người mà

1217
00:59:55,690 --> 00:59:59,460
có một số ý nghĩa mà tôi có thể
muốn làm siêu rõ ràng cho người

1218
00:59:59,460 --> 01:00:00,460
đọc mã của tôi.

1219
01:00:00,460 --> 01:00:02,920
Và tại sao bạn gọi được
chuỗi hỏi người dùng cho đầu vào?

1220
01:00:02,920 --> 01:00:05,450
Thậm chí có một không nhất thiết phải là
tất cả những gì mô tả.

1221
01:00:05,450 --> 01:00:09,340
Nhưng nó giúp kể một câu chuyện, bởi vì
dòng thứ hai trong câu chuyện, chắc chắn

1222
01:00:09,340 --> 01:00:10,740
nhận được chuỗi trả về một chuỗi.

1223
01:00:10,740 --> 01:00:14,260
>> Và dòng thứ ba trong câu chuyện là,
lặp qua các nhân vật trong s một

1224
01:00:14,260 --> 01:00:15,380
tại một thời điểm.

1225
01:00:15,380 --> 01:00:17,920
Và bây giờ chỉ cần cho các biện pháp tốt,
Tôi sẽ đi trước và thêm

1226
01:00:17,920 --> 01:00:24,560
một bình luận thêm rằng chỉ
nói in thứ i tính bằng s.

1227
01:00:24,560 --> 01:00:26,520
Bây giờ, những gì tôi đã thực hiện
vào cuối ngày?

1228
01:00:26,520 --> 01:00:29,190
>> Tôi đã thêm một số tiếng Anh
từ trong hình thức bình luận.

1229
01:00:29,190 --> 01:00:32,700
Các biểu tượng dấu gạch chéo slash nghĩa, hey,
máy tính này là dành cho con người,

1230
01:00:32,700 --> 01:00:33,820
không dành cho bạn, máy tính.

1231
01:00:33,820 --> 01:00:35,119
Vì vậy, họ đang bỏ qua một cách hợp lý.

1232
01:00:35,119 --> 01:00:35,910
Họ chỉ ở đó.

1233
01:00:35,910 --> 01:00:39,830
>> Và, quả thật vậy, CS50 IDE cho thấy chúng là
màu xám, như là hữu ích, nhưng không quan trọng

1234
01:00:39,830 --> 01:00:41,000
vào chương trình.

1235
01:00:41,000 --> 01:00:42,570
Chú ý những gì bạn có thể làm.

1236
01:00:42,570 --> 01:00:44,950
Cho dù bạn biết C
lập trình hay không, bạn

1237
01:00:44,950 --> 01:00:47,722
chỉ có thể đứng lại tại đây
chương trình, và lướt qua các ý kiến.

1238
01:00:47,722 --> 01:00:50,180
Yêu cầu người dùng nhập vào, đảm bảo
nhận được chuỗi trả về một chuỗi,

1239
01:00:50,180 --> 01:00:53,009
lặp qua các nhân vật trong s
một lúc, in các nhân vật

1240
01:00:53,009 --> 01:00:55,550
nhân vật thứ i trong s-- bạn không
thậm chí phải nhìn vào mã

1241
01:00:55,550 --> 01:00:57,270
để hiểu những gì chương trình này không.

1242
01:00:57,270 --> 01:01:00,280
Và, tốt hơn, nếu bạn tự mình tìm
tại chương trình này trong một hoặc hai tuần,

1243
01:01:00,280 --> 01:01:02,280
hay một tháng, hoặc một năm,
bạn quá không có

1244
01:01:02,280 --> 01:01:04,420
nhìn chằm chằm vào các mã,
cố nhớ lại,

1245
01:01:04,420 --> 01:01:06,630
những gì đã được tôi cố gắng để làm với mã này?

1246
01:01:06,630 --> 01:01:07,770
>> Bạn đã nói với chính mình.

1247
01:01:07,770 --> 01:01:11,660
Bạn đã mô tả nó cho chính mình,
hoặc một số đồng nghiệp, hoặc hỗ trợ kỹ thuật, hoặc TF.

1248
01:01:11,660 --> 01:01:14,860
Và do đó, đây bây giờ sẽ là
chính xác, và thiết kế tốt,

1249
01:01:14,860 --> 01:01:18,210
và cuối cùng là tốt phong cách là tốt.

1250
01:01:18,210 --> 01:01:19,990
Vì vậy, giữ cho rằng trong tâm trí.

1251
01:01:19,990 --> 01:01:22,200
>> Vì vậy, có một khác
điều tôi sẽ làm ở đây

1252
01:01:22,200 --> 01:01:28,240
mà bây giờ có thể tiết lộ chính xác những gì
xảy ra dưới mui xe.

1253
01:01:28,240 --> 01:01:30,390
Vì vậy, có tính năng này
trong C, và các ngôn ngữ khác,

1254
01:01:30,390 --> 01:01:33,010
gọi typecasting
đó hoặc là ngầm

1255
01:01:33,010 --> 01:01:37,250
hoặc một cách rõ ràng cho phép bạn chuyển đổi
từ một loại dữ liệu khác.

1256
01:01:37,250 --> 01:01:39,800
Chúng tôi đã được xử lý để
nay ngày hôm nay với chuỗi.

1257
01:01:39,800 --> 01:01:41,250
>> Và dây là ký tự.

1258
01:01:41,250 --> 01:01:44,910
Nhưng nhớ lại từ tuần
0 ký tự là gì?

1259
01:01:44,910 --> 01:01:49,334
Nhân vật chỉ là một khái niệm trừu tượng
trên đầu trang của các số thập phân numbers--,

1260
01:01:49,334 --> 01:01:52,500
và số thập phân là thực sự chỉ là một
trừu tượng trên đầu trang của các số nhị phân,

1261
01:01:52,500 --> 01:01:53,720
như chúng ta định nghĩa nó.

1262
01:01:53,720 --> 01:01:55,540
>> Vì vậy, nhân vật là những con số.

1263
01:01:55,540 --> 01:01:58,410
Và con số này là các nhân vật,
chỉ phụ thuộc vào ngữ cảnh.

1264
01:01:58,410 --> 01:02:01,250
Và nó chỉ ra rằng bên trong
của một chương trình máy tính,

1265
01:02:01,250 --> 01:02:06,830
bạn có thể chỉ định cách bạn muốn tìm
tại các bit bên trong của chương trình đó?

1266
01:02:06,830 --> 01:02:10,400
>> Nhớ lại từ tuần 0 mà chúng tôi đã có
Ascii, mà chỉ là mã này

1267
01:02:10,400 --> 01:02:11,620
chữ để lập bản đồ số.

1268
01:02:11,620 --> 01:02:13,660
Và chúng tôi đã nói, vốn A là 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B là 66, và vv.

1270
01:02:15,860 --> 01:02:20,500
>> Và thông báo, chúng tôi về cơ bản có ký tự trên
hàng đầu ở đây, như C sẽ gọi cho họ,

1271
01:02:20,500 --> 01:02:23,400
ký tự, và sau đó
ints vào hàng thứ hai.

1272
01:02:23,400 --> 01:02:28,180
Và hóa ra bạn có thể chuyển đổi
liền mạch giữa hai, thông thường.

1273
01:02:28,180 --> 01:02:30,042
Và nếu chúng ta muốn làm
này cố ý, chúng tôi

1274
01:02:30,042 --> 01:02:31,750
có thể muốn giải quyết
một cái gì đó như thế này.

1275
01:02:31,750 --> 01:02:33,590
>> Chúng tôi có thể muốn chuyển đổi
trường hợp trên để giảm

1276
01:02:33,590 --> 01:02:35,330
trường hợp, hoặc trường hợp thấp hơn trường hợp trên.

1277
01:02:35,330 --> 01:02:38,000
Và hóa ra có của
thực sự là một mô hình ở đây

1278
01:02:38,000 --> 01:02:39,900
chúng ta có thể nắm lấy chỉ trong một khoảnh khắc.

1279
01:02:39,900 --> 01:02:44,120
Nhưng chúng ta hãy xem xét đầu tiên tại một
Ví dụ để làm điều này một cách rõ ràng.

1280
01:02:44,120 --> 01:02:46,340
>> Tôi sẽ quay trở lại vào CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Tôi sẽ tạo ra một
tập tin gọi là Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Và tôi sẽ đi trước và thêm tôi
io.h tiêu chuẩn ở đầu trang, int void main

1283
01:02:55,960 --> 01:02:57,370
ở đầu chức năng của tôi.

1284
01:02:57,370 --> 01:03:02,700
Và sau đó tôi chỉ cần đi để làm
following-- một vòng lặp từ i bằng,

1285
01:03:02,700 --> 01:03:04,610
hãy nói, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Và sau đó tôi sẽ được ít hơn
65, cộng với 26 chữ cái trong bảng chữ cái.

1287
01:03:10,460 --> 01:03:12,640
Vì vậy, tôi sẽ cho máy tính
làm toán cho tôi ở đó.

1288
01:03:12,640 --> 01:03:15,100
Và sau đó bên trong vòng lặp này,
những gì tôi sẽ in?

1289
01:03:15,100 --> 01:03:19,230
>> C% là% i backslash n.

1290
01:03:19,230 --> 01:03:21,290
Và bây giờ tôi muốn cắm trong hai giá trị.

1291
01:03:21,290 --> 01:03:24,530
Tôi đã tạm thời đặt câu hỏi
đánh dấu có mời các câu hỏi.

1292
01:03:24,530 --> 01:03:29,940
>> Tôi muốn lặp từ 65 trở đi
cho 26 chữ cái trong bảng chữ cái,

1293
01:03:29,940 --> 01:03:35,190
in ra trên mỗi lần lặp đó
nhân vật tương đương không thể thiếu.

1294
01:03:35,190 --> 01:03:38,299
Nói cách khác, tôi muốn
lặp trên 26 số in ấn

1295
01:03:38,299 --> 01:03:41,590
những gì các nhân vật Ascii là chữ cái,
và những gì các số tương ứng hợp--

1296
01:03:41,590 --> 01:03:44,650
thực sự chỉ là tái tạo
các biểu đồ từ slide đó.

1297
01:03:44,650 --> 01:03:47,010
Vì vậy, những gì nên những dấu hỏi được?

1298
01:03:47,010 --> 01:03:51,760
>> Vâng, nó quay ra rằng thứ hai
một trong những chỉ nên là tôi biến.

1299
01:03:51,760 --> 01:03:53,860
Tôi muốn xem đó như là một con số.

1300
01:03:53,860 --> 01:03:58,920
Và cuộc tranh luận giữa
ở đây, tôi có thể nói cho máy tính

1301
01:03:58,920 --> 01:04:03,470
để điều trị số nguyên
tôi như một nhân vật, như vậy là

1302
01:04:03,470 --> 01:04:05,880
để thay thế nó ở đây cho phần trăm C.

1303
01:04:05,880 --> 01:04:07,990
>> Nói cách khác, nếu tôi, các
lập trình của con người, biết

1304
01:04:07,990 --> 01:04:09,865
đây là những chỉ số
vào cuối ngày.

1305
01:04:09,865 --> 01:04:12,500
Và tôi biết rằng 65 nên
bản đồ cho một số nhân vật.

1306
01:04:12,500 --> 01:04:15,310
Với diễn viên rõ ràng này,
với một dấu ngoặc đơn,

1307
01:04:15,310 --> 01:04:18,840
tên của các loại dữ liệu mà bạn muốn
chuyển đổi, và một dấu ngoặc đóng,

1308
01:04:18,840 --> 01:04:21,200
bạn có thể nói
máy tính, hey, máy tính,

1309
01:04:21,200 --> 01:04:24,130
chuyển đổi số nguyên này cho một char.

1310
01:04:24,130 --> 01:04:26,250
>> Vì vậy, khi tôi chạy này
chương trình sau khi biên dịch,

1311
01:04:26,250 --> 01:04:29,740
chúng ta hãy xem những gì tôi làm cho get-- Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Darn nó, tôi đã làm gì sai ở đây?

1313
01:04:33,020 --> 01:04:35,884
Sử dụng các định danh không khai báo,
tất cả các bên phải, không cố ý,

1314
01:04:35,884 --> 01:04:37,800
nhưng chúng ta hãy xem nếu chúng ta có thể không
Lý do thông qua này.

1315
01:04:37,800 --> 01:04:41,220
>> Vì vậy, dòng five-- vì vậy tôi đã không nhận được
rất xa trước khi điều chỉnh các.

1316
01:04:41,220 --> 01:04:42,140
Vậy là được rồi.

1317
01:04:42,140 --> 01:04:46,560
Vì vậy, dòng 5 cho tôi bằng 65-- tôi nhìn thấy.

1318
01:04:46,560 --> 01:04:50,130
Vì vậy, hãy nhớ rằng trong C, không giống như một số
ngôn ngữ nếu bạn có chương trình trước

1319
01:04:50,130 --> 01:04:52,190
kinh nghiệm, bạn có
để nói với máy tính,

1320
01:04:52,190 --> 01:04:55,040
không giống như Scratch, những gì
loại biến nó được.

1321
01:04:55,040 --> 01:04:56,860
>> Và tôi quên một cụm từ khóa ở đây.

1322
01:04:56,860 --> 01:04:59,200
Cùng năm, tôi đã bắt đầu sử dụng i.

1323
01:04:59,200 --> 01:05:01,560
Nhưng tôi đã không nói với C
những kiểu dữ liệu của nó.

1324
01:05:01,560 --> 01:05:04,570
Vì vậy, tôi sẽ đi ở đây và
nói, ah, làm cho nó một số nguyên.

1325
01:05:04,570 --> 01:05:07,050
>> Bây giờ tôi sẽ đi trước và biên dịch lại.

1326
01:05:07,050 --> 01:05:08,080
Đó là cố định đó.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, đó là loại mát mẻ.

1328
01:05:12,660 --> 01:05:15,360
Không chỉ là nó siêu nhanh
yêu cầu máy tính câu hỏi này,

1329
01:05:15,360 --> 01:05:18,885
chứ không phải là tìm kiếm nó lên trên một slide,
nó được in ra mỗi dòng, A là 65,

1330
01:05:18,885 --> 01:05:24,860
B là 66, tất cả các cách down-- kể từ khi tôi
đã làm điều này 26 times-- để các chữ z,

1331
01:05:24,860 --> 01:05:25,630
đó là 90.

1332
01:05:25,630 --> 01:05:27,790
Và, trên thực tế, hơi
thông minh hơn sẽ

1333
01:05:27,790 --> 01:05:31,030
đã được cho tôi không phải dựa
trên máy tính để thêm 26.

1334
01:05:31,030 --> 01:05:34,060
Tôi có thể chỉ cần thực hiện
90 là tốt, quá lâu

1335
01:05:34,060 --> 01:05:37,390
như tôi không mắc phải sai lầm tương tự hai lần.

1336
01:05:37,390 --> 01:05:41,880
Tôi muốn đi lên qua
z, không chỉ lên thông qua y.

1337
01:05:41,880 --> 01:05:44,000
>> Vì vậy, đó là một diễn viên rõ ràng.

1338
01:05:44,000 --> 01:05:47,860
Nó chỉ ra rằng điều này
là không còn cần thiết.

1339
01:05:47,860 --> 01:05:52,480
Hãy để tôi đi trước và chạy lại này
biên dịch và chạy lại Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Nó chỉ ra rằng C là khá thông minh.

1341
01:05:54,940 --> 01:05:57,150
>> Và printf, đặc biệt,
là khá thông minh.

1342
01:05:57,150 --> 01:06:01,260
Nếu bạn chỉ cần vượt qua một hai lần tôi
cho cả placeholders, printf

1343
01:06:01,260 --> 01:06:04,510
sẽ nhận ra, oh, tôi cũng biết bạn
đã cho tôi một integer-- một số,

1344
01:06:04,510 --> 01:06:06,380
như 65, hoặc 90, hoặc bất cứ điều gì.

1345
01:06:06,380 --> 01:06:10,170
Nhưng tôi thấy rằng bạn muốn tôi
định dạng mà số giống như một nhân vật.

1346
01:06:10,170 --> 01:06:16,460
Và như vậy printf ngầm có thể cast
các int đến một char cho bạn là tốt.

1347
01:06:16,460 --> 01:06:19,360
Vì vậy, đó không phải là vấn đề gì cả.

1348
01:06:19,360 --> 01:06:23,100
>> Nhưng chú ý, vì tính tương đương này
chúng tôi thực sự có thể làm được điều này là tốt.

1349
01:06:23,100 --> 01:06:26,520
Hãy để tôi đi trước và thực hiện một
Phiên bản khác của này-- 1.c. Ascii

1350
01:06:26,520 --> 01:06:31,800
Và thay vì lặp qua
số nguyên, thực sự có thể thổi tâm trí của bạn

1351
01:06:31,800 --> 01:06:33,610
bằng cách duyệt qua các nhân vật.

1352
01:06:33,610 --> 01:06:37,660
Nếu một char c được vốn A, tôi
muốn đi trước và làm điều này,

1353
01:06:37,660 --> 01:06:41,740
miễn là C là nhỏ hơn hoặc bằng
đến Z. vốn Và trên mỗi lần lặp

1354
01:06:41,740 --> 01:06:45,690
Tôi muốn tăng C, tôi có thể
bây giờ trong dòng printf của tôi ở đây

1355
01:06:45,690 --> 01:06:51,320
nói, phần trăm C là
phần trăm tôi một lần nữa, dấu phẩy C.

1356
01:06:51,320 --> 01:06:57,200
>> Và bây giờ, tôi có thể đi theo một hướng khác,
đúc các nhân vật một cách rõ ràng

1357
01:06:57,200 --> 01:06:58,500
để một số nguyên.

1358
01:06:58,500 --> 01:07:00,560
Vì vậy, một lần nữa, tại sao bạn làm điều này?

1359
01:07:00,560 --> 01:07:03,830
Đó là một chút lạ để sắp xếp của
đếm về nhân vật.

1360
01:07:03,830 --> 01:07:07,430
>> Nhưng nếu bạn hiểu những gì
xảy ra dưới mui xe,

1361
01:07:07,430 --> 01:07:08,430
có thực sự không có phép thuật.

1362
01:07:08,430 --> 01:07:13,060
Bạn chỉ cần nói, hey, máy tính bỏ
tôi một biến gọi là C kiểu char.

1363
01:07:13,060 --> 01:07:16,520
Khởi tạo nó vốn A. Và
nhận báo giá duy nhất vấn đề.

1364
01:07:16,520 --> 01:07:19,580
>> Đối với các nhân vật trong C, nhớ lại từ
tuần cuối cùng, bạn sử dụng dấu ngoặc đơn.

1365
01:07:19,580 --> 01:07:23,720
Đối với dây, các từ,
cụm từ, bạn sử dụng dấu ngoặc kép.

1366
01:07:23,720 --> 01:07:27,210
OK, máy tính, tiếp tục làm điều này, vì vậy
miễn là nhân vật ít hơn

1367
01:07:27,210 --> 01:07:28,050
hoặc bằng z.

1368
01:07:28,050 --> 01:07:32,640
Và tôi biết từ bảng Ascii của tôi rằng tất cả
các mã Ascii liền kề nhau.

1369
01:07:32,640 --> 01:07:33,400
>> Không có khoảng trống.

1370
01:07:33,400 --> 01:07:36,737
Vì vậy, nó chỉ là từ A đến Z,
ngăn cách bởi một số lượng mỗi loại.

1371
01:07:36,737 --> 01:07:38,820
Và sau đó tôi có thể tăng
một char, nếu tôi thực sự muốn.

1372
01:07:38,820 --> 01:07:40,390
Vào cuối ngày,
nó chỉ là một con số.

1373
01:07:40,390 --> 01:07:41,030
Tôi biết cái này.

1374
01:07:41,030 --> 01:07:43,670
Vì vậy, tôi chỉ có thể đoán thêm 1 đến nó.

1375
01:07:43,670 --> 01:07:46,940
>> Và rồi thời gian này, tôi in c,
và sau đó là tương đương không thể thiếu.

1376
01:07:46,940 --> 01:07:50,170
Và tôi thậm chí không cần diễn viên rõ ràng.

1377
01:07:50,170 --> 01:07:52,680
Tôi có thể cho printf và
hình máy tính những điều trên,

1378
01:07:52,680 --> 01:07:57,300
vì vậy mà bây giờ nếu tôi chạy
làm Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Tôi nhận được một điều chính xác là tốt.

1380
01:08:01,520 --> 01:08:04,530
>> chương trình vô dụng, không có ai though--
sẽ thực sự viết phần mềm

1381
01:08:04,530 --> 01:08:07,549
để tìm ra, những gì là
số mà các bản đồ với A, hoặc B, hoặc Z?

1382
01:08:07,549 --> 01:08:10,340
Bạn chỉ cần đi để Google nó, hoặc
nhìn nó lên trực tuyến, hoặc xem nó lên

1383
01:08:10,340 --> 01:08:11,650
trên một slide, hoặc tương tự.

1384
01:08:11,650 --> 01:08:13,520
Vì vậy, nơi thực hiện điều này thực sự có được hữu ích?

1385
01:08:13,520 --> 01:08:15,960
>> Vâng, nói rằng
slide, nhận thấy có

1386
01:08:15,960 --> 01:08:20,890
một mô hình thực tế ở đây giữa chữ hoa
và chữ thường đó không phải là tình cờ.

1387
01:08:20,890 --> 01:08:23,760
Chú ý rằng vốn A là 65.

1388
01:08:23,760 --> 01:08:25,830
Chữ thường một là 97.

1389
01:08:25,830 --> 01:08:29,649
Và làm thế nào xa là trường hợp thấp hơn?

1390
01:08:29,649 --> 01:08:32,649
>> Vì vậy, 65 là bao nhiêu bước đi từ 97?

1391
01:08:32,649 --> 01:08:36,210
Vì vậy, 97 trừ đi 65 là 32.

1392
01:08:36,210 --> 01:08:37,910
Vì vậy, vốn một là 65.

1393
01:08:37,910 --> 01:08:39,939
Nếu bạn thêm 32 đến đó,
bạn sẽ có được chữ thường a.

1394
01:08:39,939 --> 01:08:43,729
Và, tương đương, nếu bạn trừ đi 32,
bạn trở lại với vốn là-- cùng với B

1395
01:08:43,729 --> 01:08:46,380
để ít b, lớn C để ít c.

1396
01:08:46,380 --> 01:08:50,670
>> Tất cả những khoảng trống là 32 ngoài.

1397
01:08:50,670 --> 01:08:54,450
Bây giờ, điều này có vẻ như để cho phép chúng tôi
làm một cái gì đó giống như Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
hoặc Google Docs tính năng này, nơi bạn
có thể chọn tất cả mọi thứ và sau đó nói rằng,

1399
01:08:57,729 --> 01:09:00,520
thay đổi tất cả thành chữ thường, hoặc
thay đổi tất cả thành chữ hoa,

1400
01:09:00,520 --> 01:09:03,840
hoặc chỉ thay đổi từ đầu tiên
trong câu để trường hợp trên.

1401
01:09:03,840 --> 01:09:07,390
Chúng tôi thực sự có thể làm điều gì đó
như thế mình.

1402
01:09:07,390 --> 01:09:12,645
>> Hãy để tôi đi trước và lưu một tập tin
đây gọi là tận 0.c.

1403
01:09:12,645 --> 01:09:15,770
Và chúng ta hãy đi trước và whip lên một chương trình
thực hiện chính xác đó như sau.

1404
01:09:15,770 --> 01:09:18,460
Vì vậy, bao gồm các thư viện CS50.

1405
01:09:18,460 --> 01:09:21,430
Và bao gồm tiêu chuẩn I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Và tôi biết điều này là đến sớm.

1407
01:09:22,787 --> 01:09:24,870
Vì vậy, tôi sẽ đặt nó trong
đã có, string.h,

1408
01:09:24,870 --> 01:09:26,960
vì vậy tôi có quyền truy cập vào
những thứ như Stirling,

1409
01:09:26,960 --> 01:09:29,620
và sau đó int void main, như thường lệ.

1410
01:09:29,620 --> 01:09:33,420
Và sau đó tôi sẽ đi trước
và làm các chuỗi được nhận được chuỗi,

1411
01:09:33,420 --> 01:09:35,032
chỉ để có được một chuỗi từ người sử dụng.

1412
01:09:35,032 --> 01:09:36,740
Và sau đó tôi sẽ
thực hiện kiểm tra sự tỉnh táo của tôi.

1413
01:09:36,740 --> 01:09:40,510
Nếu chuỗi không làm rỗng bằng nhau,
sau đó nó an toàn để tiến hành.

1414
01:09:40,510 --> 01:09:42,000
Và làm những gì tôi muốn làm gì?

1415
01:09:42,000 --> 01:09:48,700
Tôi sẽ lặp từ i bằng 0,
và n lên với chiều dài chuỗi s.

1416
01:09:48,700 --> 01:09:51,899
>> Và tôi sẽ làm điều này miễn là
i nhỏ hơn n, và tôi cộng cộng.

1417
01:09:51,899 --> 01:09:55,060
Cho đến nay, tôi thực sự chỉ
mượn ý tưởng từ trước.

1418
01:09:55,060 --> 01:09:57,010
Và bây giờ tôi sẽ giới thiệu một chi nhánh.

1419
01:09:57,010 --> 01:09:59,635
>> Vì vậy, suy nghĩ lại về Scratch, nơi
chúng tôi đã có những ngã ba đường,

1420
01:09:59,635 --> 01:10:05,110
và tuần cuối cùng trong C. Tôi sẽ
nói điều này, nếu nhân vật thứ i trong s

1421
01:10:05,110 --> 01:10:09,250
là lớn hơn hoặc
bình đẳng để giảm trường hợp một,

1422
01:10:09,250 --> 01:10:13,340
và- trong Scratch bạn sẽ theo nghĩa đen
nói và, nhưng trong C bạn nói dấu và,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- và nhân vật thứ i trong s
là nhỏ hơn hoặc bằng để giảm trường hợp z,

1424
01:10:19,830 --> 01:10:21,780
chúng ta hãy làm một cái gì đó thú vị.

1425
01:10:21,780 --> 01:10:27,020
Hãy thực sự in ra một
nhân vật không có xuống dòng

1426
01:10:27,020 --> 01:10:31,760
đó là các nhân vật trong chuỗi,
nhân vật thứ i trong chuỗi.

1427
01:10:31,760 --> 01:10:37,420
>> Nhưng chúng ta hãy đi trước và
trừ đi 32 từ nó.

1428
01:10:37,420 --> 01:10:42,120
Khác nếu các nhân vật trong
chuỗi mà chúng tôi đang tìm kiếm

1429
01:10:42,120 --> 01:10:45,950
không phải là giữa một chút
và ít z, đi trước

1430
01:10:45,950 --> 01:10:48,610
và chỉ cần in ra không thay đổi.

1431
01:10:48,610 --> 01:10:50,840
Vì vậy, chúng tôi đã giới thiệu
ký hiệu trong ngoặc vuông này

1432
01:10:50,840 --> 01:10:53,560
cho chuỗi của chúng tôi để có được ở các
thứ i nhân vật trong chuỗi.

1433
01:10:53,560 --> 01:10:57,520
>> Tôi đã thêm một số logic điều kiện, như
Scratch trong một tuần của tuần trước, nơi

1434
01:10:57,520 --> 01:10:59,880
Tôi chỉ sử dụng cơ bản của tôi
sự hiểu biết về những gì

1435
01:10:59,880 --> 01:11:01,130
xảy ra dưới mui xe.

1436
01:11:01,130 --> 01:11:04,190
Là nhân vật thứ i của s
lớn hơn hoặc bằng một?

1437
01:11:04,190 --> 01:11:08,290
Giống như, nó là 97, hay 98,
hoặc 99, và vân vân?

1438
01:11:08,290 --> 01:11:11,940
>> Nhưng là nó cũng nhỏ hơn hoặc bằng
với giá trị của chữ thường z?

1439
01:11:11,940 --> 01:11:16,210
Và nếu như vậy, những gì hiện dòng này nghĩa là gì?

1440
01:11:16,210 --> 01:11:20,250
14, đây là hai yếu tố
mầm mống của toàn bộ ý tưởng,

1441
01:11:20,250 --> 01:11:23,840
hoa chữ bằng
chỉ đơn giản là trừ đi 32 từ nó,

1442
01:11:23,840 --> 01:11:29,370
trong trường hợp này, bởi vì tôi biết, mỗi mà
biểu đồ, làm thế nào con số của tôi được đại diện.

1443
01:11:29,370 --> 01:11:33,925
Vì vậy, chúng ta hãy đi trước và chạy này,
sau khi biên dịch tận 0.c,

1444
01:11:33,925 --> 01:11:36,210
và chạy tận 0.

1445
01:11:36,210 --> 01:11:40,300
>> Hãy cùng đánh vào một cái gì đó như
Zamyla trong tất cả các chữ thường nhập.

1446
01:11:40,300 --> 01:11:42,780
Và bây giờ chúng tôi có Zamyla trong tất cả các chữ hoa.

1447
01:11:42,780 --> 01:11:45,050
Hãy gõ Rob trong tất cả các chữ thường.

1448
01:11:45,050 --> 01:11:46,674
Hãy thử Jason trong tất cả các chữ thường.

1449
01:11:46,674 --> 01:11:48,590
Và chúng tôi tiếp tục nhận được
buộc vốn.

1450
01:11:48,590 --> 01:11:50,960
Có một lỗi nhỏ mà tôi
loại đã không lường trước được.

1451
01:11:50,960 --> 01:11:54,050
Chú ý nhắc nhở mới của tôi là kết thúc
trên cùng một dòng như tên của họ,

1452
01:11:54,050 --> 01:11:55,520
mà cảm thấy một chút lộn xộn.

1453
01:11:55,520 --> 01:11:59,170
>> Vì vậy, tôi sẽ đi đây, và
thực sự vào cuối chương trình này

1454
01:11:59,170 --> 01:12:02,110
in ra một ký tự xuống dòng.

1455
01:12:02,110 --> 01:12:03,160
Đó là tất cả.

1456
01:12:03,160 --> 01:12:06,120
Với printf, bạn không cần phải
vượt qua trong các biến hoặc mã định dạng.

1457
01:12:06,120 --> 01:12:08,460
Bạn có thể theo nghĩa đen chỉ in
một cái gì đó giống như một dòng mới.

1458
01:12:08,460 --> 01:12:13,529
>> Vì vậy, chúng ta hãy đi trước và thực hiện
tận 0 một lần nữa, chạy lại nó, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Và bây giờ nó là một xinh đẹp hơn chút.

1460
01:12:14,820 --> 01:12:17,274
Bây giờ, nhắc tôi là trên dòng riêng.

1461
01:12:17,274 --> 01:12:18,440
Vì vậy, đó là tất cả tốt và tốt.

1462
01:12:18,440 --> 01:12:19,910
Vì vậy, đó là một ví dụ tốt.

1463
01:12:19,910 --> 01:12:22,700
Nhưng tôi thậm chí không nhất thiết
cần cứng mã 32.

1464
01:12:22,700 --> 01:12:23,350
Bạn biết những gì?

1465
01:12:23,350 --> 01:12:26,350
Tôi có thể say-- tôi không bao giờ
nhớ những gì là sự khác biệt.

1466
01:12:26,350 --> 01:12:29,330
>> Nhưng tôi biết rằng nếu tôi
có một chữ thường,

1467
01:12:29,330 --> 01:12:34,430
Tôi về cơ bản muốn trừ đi tắt
bất cứ điều gì là khoảng cách giữa nhỏ

1468
01:12:34,430 --> 01:12:39,160
a và lớn A, bởi vì nếu tôi giả định rằng
tất cả các chữ cái khác đều giống nhau,

1469
01:12:39,160 --> 01:12:41,045
rằng sẽ nhận được công việc làm.

1470
01:12:41,045 --> 01:12:42,670
Nhưng thay vì làm điều đó, bạn biết những gì?

1471
01:12:42,670 --> 01:12:44,240
Có một cách khác vẫn còn.

1472
01:12:44,240 --> 01:12:48,090
>> Nếu đó là tận 1.c-- nếu tôi là
để đưa vào một tập tin riêng biệt.

1473
01:12:48,090 --> 01:12:51,030
chúng ta hãy làm tận 2.c như sau.

1474
01:12:51,030 --> 01:12:53,060
Tôi sẽ thực sự làm sạch này lên đây.

1475
01:12:53,060 --> 01:12:57,420
Và thay vì thậm chí phải
biết hoặc quan tâm về những mức thấp

1476
01:12:57,420 --> 01:13:01,090
chi tiết thực hiện, tôi thay
chỉ cần đi để in một nhân vật,

1477
01:13:01,090 --> 01:13:04,610
quote unquote, phần trăm C, và
sau đó gọi hàm khác mà

1478
01:13:04,610 --> 01:13:09,950
tồn tại mà có một đối số,
mà là một nhân vật, như thế này.

1479
01:13:09,950 --> 01:13:12,630
>> Hóa ra trong C, có
một cuộc gọi chức năng

1480
01:13:12,630 --> 01:13:15,550
để phía trên, như tên gọi của nó
cho thấy có một nhân vật

1481
01:13:15,550 --> 01:13:19,350
và làm cho nó vào trường hợp trên của nó
tương đương, và sau đó trở về

1482
01:13:19,350 --> 01:13:21,410
để printf mà có thể cắm nó trong đó.

1483
01:13:21,410 --> 01:13:25,484
Và như vậy để làm được điều này, tuy nhiên, tôi
cần phải giới thiệu một tập tin khác.

1484
01:13:25,484 --> 01:13:28,400
Hóa ra có một tập tin khác
rằng bạn sẽ chỉ biết đến lớp,

1485
01:13:28,400 --> 01:13:33,020
hoặc một cuốn sách giáo khoa, hoặc trực tuyến
tài liệu tham khảo, được gọi là C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Vì vậy, nếu tôi thêm rằng lên giữa phần đầu của tôi
tập tin, và lập lại chương trình này,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Hãy gõ Zamyla trong tất cả
chữ thường, vẫn làm việc như nhau.

1489
01:13:46,690 --> 01:13:48,040
Nhưng bạn biết những gì?

1490
01:13:48,040 --> 01:13:55,590
Nó chỉ ra rằng để trên
có một số chức năng khác.

1491
01:13:55,590 --> 01:13:58,410
>> Và hãy để tôi giới thiệu này
chỉ huy ở đây, loại lúng túng

1492
01:13:58,410 --> 01:14:00,250
đặt tên, nhưng người đàn ông để làm bằng tay.

1493
01:14:00,250 --> 01:14:03,960
Nó chỉ ra rằng hầu hết các máy tính Linux,
như chúng ta đang sử dụng đây-- điều hành Linux

1494
01:14:03,960 --> 01:14:06,270
system-- có một lệnh
gọi là người đàn ông, trong đó nói rằng,

1495
01:14:06,270 --> 01:14:08,530
hey, máy tính, cho tôi
nhãn hiệu của máy tính.

1496
01:14:08,530 --> 01:14:10,680
Những gì bạn muốn đến
tìm trong sách hướng dẫn đó?

1497
01:14:10,680 --> 01:14:13,840
>> Tôi muốn tìm kiếm các chức năng
kêu gọi trên, Enter.

1498
01:14:13,840 --> 01:14:16,070
Và đó là một chút khó hiểu
đọc đôi khi.

1499
01:14:16,070 --> 01:14:18,780
Nhưng nhận thấy chúng ta đang ở
nhãn Linux lập trình viên của.

1500
01:14:18,780 --> 01:14:19,530
Và đó là tất cả các văn bản.

1501
01:14:19,530 --> 01:14:21,905
Và nhận thấy rằng có những
tên của các chức năng ở đây.

1502
01:14:21,905 --> 01:14:25,030
Hóa ra nó có một người anh họ gọi là
hạ, mà làm ngược lại.

1503
01:14:25,030 --> 01:14:29,710
Và thông báo theo tóm tắt, sử dụng này
chức năng trang người đàn ông, có thể nói,

1504
01:14:29,710 --> 01:14:32,220
là nói cho tôi rằng tôi
cần phải bao gồm c type.h.

1505
01:14:32,220 --> 01:14:33,630
Và tôi biết rằng từ thực tiễn.

1506
01:14:33,630 --> 01:14:36,210
>> Ở đây, nó hiển thị cho tôi hai
nguyên mẫu cho các chức năng,

1507
01:14:36,210 --> 01:14:39,070
do đó nếu tôi muốn sử dụng này
Tôi biết những gì họ đưa như đầu vào,

1508
01:14:39,070 --> 01:14:40,652
và những gì họ trở lại như đầu ra.

1509
01:14:40,652 --> 01:14:42,360
Và sau đó nếu tôi đọc
mô tả, tôi thấy

1510
01:14:42,360 --> 01:14:44,820
chi tiết hơn những gì các chức năng nào.

1511
01:14:44,820 --> 01:14:48,100
Nhưng quan trọng hơn, nếu
Tôi nhìn theo giá trị trả về,

1512
01:14:48,100 --> 01:14:51,710
nó nói giá trị trả về là
rằng các bức thư được chuyển đổi,

1513
01:14:51,710 --> 01:14:57,880
hoặc C, đầu vào ban đầu, nếu
việc chuyển đổi là không thể.

1514
01:14:57,880 --> 01:15:01,992
>> Nói cách khác, để phía trên sẽ thử
để chuyển đổi một bức thư cho trường hợp trên.

1515
01:15:01,992 --> 01:15:03,450
Và nếu như vậy, nó sẽ trả lại nó.

1516
01:15:03,450 --> 01:15:07,010
Nhưng nếu nó không thể đối với một số reason--
có lẽ đó là trường hợp đã được phía trên,

1517
01:15:07,010 --> 01:15:09,550
có lẽ đó là một dấu chấm than
hoặc một số punctuation-- khác

1518
01:15:09,550 --> 01:15:12,200
nó chỉ cần đi
trả lại C ban đầu,

1519
01:15:12,200 --> 01:15:17,340
có nghĩa là tôi có thể làm cho mã của tôi
thiết kế tốt hơn như sau.

1520
01:15:17,340 --> 01:15:20,580
>> Tôi không cần tất cả
những dòng darn mã.

1521
01:15:20,580 --> 01:15:22,610
Tất cả những dòng tôi đã
chỉ nhấn mạnh có thể

1522
01:15:22,610 --> 01:15:28,700
được sụp đổ vào chỉ là một đơn giản
dòng, đó là này-- printf phần trăm

1523
01:15:28,700 --> 01:15:33,510
c để trên khung S i.

1524
01:15:33,510 --> 01:15:36,090
Và đây sẽ là một
ví dụ về thiết kế tốt hơn.

1525
01:15:36,090 --> 01:15:40,040
>> Tại sao thực hiện trong 7 hoặc 8 dòng
mã, bất cứ điều gì đó là tôi chỉ

1526
01:15:40,040 --> 01:15:44,960
xóa, khi bạn thay vì có thể sụp đổ
tất cả các logic và ra quyết định

1527
01:15:44,960 --> 01:15:49,620
thành một dòng duy nhất, 13 bây giờ, đó
dựa trên một thư viện function--

1528
01:15:49,620 --> 01:15:53,430
một chức năng mà đi kèm với C, nhưng đó
thực hiện chính xác những gì bạn muốn nó làm.

1529
01:15:53,430 --> 01:15:55,295
Và, thẳng thắn, thậm chí nếu
nó đã không đến với C,

1530
01:15:55,295 --> 01:15:58,880
bạn có thể thực hiện điều đó cho mình, như
chúng tôi đã nhìn thấy, với nhận int tiêu cực

1531
01:15:58,880 --> 01:16:01,700
và nhận được dương int tuần trước là tốt.

1532
01:16:01,700 --> 01:16:03,470
>> Mã này hiện nay là nhiều hơn nữa có thể đọc được.

1533
01:16:03,470 --> 01:16:06,670
Và, quả thật vậy, nếu chúng ta di chuyển lên,
xem có bao nhiêu nhỏ gọn hơn

1534
01:16:06,670 --> 01:16:08,360
phiên bản này của chương trình của tôi là.

1535
01:16:08,360 --> 01:16:11,230
Đó là một chút nặng hàng đầu hiện nay,
với tất cả các bao gồm.

1536
01:16:11,230 --> 01:16:14,380
Nhưng đó là OK, vì bây giờ tôi đang đứng
trên vai của các lập trình viên

1537
01:16:14,380 --> 01:16:15,300
trước tôi.

1538
01:16:15,300 --> 01:16:18,440
Và ai đó là ai
thực hiện để thực sự trên

1539
01:16:18,440 --> 01:16:21,470
đã làm cho tôi một việc, giống như bất cứ ai
thực hiện Stirling thực sự

1540
01:16:21,470 --> 01:16:24,790
đã làm cho tôi một việc một số thời gian trước đây.

1541
01:16:24,790 --> 01:16:26,970
Và vì vậy bây giờ chúng ta có một
Chương trình thiết kế tốt hơn

1542
01:16:26,970 --> 01:16:31,680
mà thực hiện cùng một logic chính xác.

1543
01:16:31,680 --> 01:16:35,580
>> Phát biểu của stirling, hãy
tôi đi trước và làm điều này.

1544
01:16:35,580 --> 01:16:38,320
Hãy để tôi đi trước và tiết kiệm
tập tin này như stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Và hóa ra, chúng ta có thể bóc lại
một lớp khác khá đơn giản bây giờ.

1546
01:16:43,255 --> 01:16:45,630
Tôi sẽ đi trước và roi
lên một chương trình khác trong chính

1547
01:16:45,630 --> 01:16:49,759
ở đây mà chỉ đơn giản tái cụ
chuỗi dài như sau.

1548
01:16:49,759 --> 01:16:52,300
Vì vậy, đây là một dòng mã
được tôi một chuỗi từ người sử dụng.

1549
01:16:52,300 --> 01:16:53,910
Chúng tôi tiếp tục sử dụng này một lần nữa và một lần nữa.

1550
01:16:53,910 --> 01:16:58,900
Hãy để tôi cung cấp cho bản thân mình một biến gọi là
n kiểu int để lưu một số.

1551
01:16:58,900 --> 01:17:02,490
>> Và hãy để tôi đi trước và
làm logic sau đây.

1552
01:17:02,490 --> 01:17:15,610
Trong khi nhân vật thứ n trong s làm
không bằng xuyệc ngược 0, đi trước

1553
01:17:15,610 --> 01:17:17,930
và tăng n.

1554
01:17:17,930 --> 01:17:23,506
Và sau đó in ra printf trăm i n.

1555
01:17:23,506 --> 01:17:29,200
Tôi cho rằng chương trình này ở đây,
mà không gọi chiều dài chuỗi,

1556
01:17:29,200 --> 01:17:31,150
con số ra chiều dài của một chuỗi.

1557
01:17:31,150 --> 01:17:34,600
>> Và sự kỳ diệu là hoàn toàn
gói gọn trong dòng 8

1558
01:17:34,600 --> 01:17:39,830
ở đây với những gì trông giống như cú pháp mới,
dấu chéo ngược này 0 trong dấu ngoặc đơn.

1559
01:17:39,830 --> 01:17:41,360
Nhưng tại sao vậy?

1560
01:17:41,360 --> 01:17:44,100
Vâng, hãy xem xét những gì đang được
đi trên tất cả các thời gian này.

1561
01:17:44,100 --> 01:17:47,990
>> Và như một sang một bên trước khi tôi quên, nhận ra
quá, mà thêm vào các trang con người

1562
01:17:47,990 --> 01:17:50,920
đi kèm với một điển hình
hệ thống Linux như CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
nhận ra rằng chúng ta, những
nhân viên của khóa học, cũng đã

1564
01:17:53,770 --> 01:17:56,030
thực hiện một phiên bản trang web
của ý tưởng này cùng được gọi là

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, trong đó có
tất cả các trang cùng một người đàn ông,

1566
01:17:59,940 --> 01:18:02,020
tất cả điều đó cùng
tài liệu, cũng như

1567
01:18:02,020 --> 01:18:05,730
một hộp nhỏ ở phía trên cho phép
bạn chuyển đổi tất cả các khá

1568
01:18:05,730 --> 01:18:09,025
ngôn ngữ phức tạp vào ít thoải mái
chế độ, nơi chúng tôi, đội ngũ giáo viên,

1569
01:18:09,025 --> 01:18:12,150
đã đi qua và cố gắng đơn giản hóa
một số ngôn ngữ để giữ cho mọi thứ

1570
01:18:12,150 --> 01:18:14,830
tập trung vào những ý tưởng, và không
một số các vấn đề chuyên môn.

1571
01:18:14,830 --> 01:18:20,070
Vì vậy, giữ trong tâm trí, reference.cs50.net
như tài nguyên khác là tốt.

1572
01:18:20,070 --> 01:18:23,800
>> Nhưng tại sao không làm việc chiều dài chuỗi trong
cách tôi đề xuất một thời gian trước đây?

1573
01:18:23,800 --> 01:18:25,160
Dưới đây là tên Zamyla nữa.

1574
01:18:25,160 --> 01:18:27,690
Và đây là tên của Zamyla
đóng hộp, như tôi tiếp tục làm,

1575
01:18:27,690 --> 01:18:31,360
để vẽ một hình ảnh của nó được,
thực sự, chỉ là một chuỗi các ký tự.

1576
01:18:31,360 --> 01:18:34,260
Nhưng Zamyla không tồn tại
cách ly trong một chương trình.

1577
01:18:34,260 --> 01:18:37,420
>> Khi bạn viết và chạy một chương trình,
bạn đang sử dụng máy Mac hoặc máy PC của bạn

1578
01:18:37,420 --> 01:18:40,010
như bộ nhớ, hoặc bộ nhớ RAM như vậy để nói chuyện.

1579
01:18:40,010 --> 01:18:42,620
Và bạn có thể nghĩ
máy tính của bạn là có

1580
01:18:42,620 --> 01:18:44,730
nhiều gigabyte bộ nhớ những ngày này.

1581
01:18:44,730 --> 01:18:47,700
Và một buổi biểu diễn có nghĩa là tỷ,
nên tỷ byte.

1582
01:18:47,700 --> 01:18:48,910
>> Nhưng chúng ta hãy quay lại trong thời gian.

1583
01:18:48,910 --> 01:18:51,530
Và giả sử rằng chúng ta đang sử dụng
một máy tính thực sự cũ

1584
01:18:51,530 --> 01:18:55,150
chỉ có 32 byte của bộ nhớ.

1585
01:18:55,150 --> 01:18:59,310
Tôi có thể, trên màn hình máy tính của tôi,
chỉ cần vẽ này như sau.

1586
01:18:59,310 --> 01:19:05,240
>> Tôi chỉ có thể nói rằng tôi
máy tính có tất cả các bộ nhớ này.

1587
01:19:05,240 --> 01:19:08,830
Và điều này cũng giống như một thanh bộ nhớ, nếu
bạn nhớ lại hình ảnh của chúng tôi từ lần cuối cùng.

1588
01:19:08,830 --> 01:19:11,670
Và nếu tôi chỉ chia
này trong lần đủ,

1589
01:19:11,670 --> 01:19:15,040
Tôi cho rằng tôi có 32 byte
bộ nhớ trên màn hình.

1590
01:19:15,040 --> 01:19:18,239
>> Bây giờ, trong thực tế, tôi chỉ có thể
vẽ cho đến nay trên màn hình này ở đây.

1591
01:19:18,239 --> 01:19:20,280
Vì vậy, tôi sẽ đi trước,
và chỉ bằng cách quy ước,

1592
01:19:20,280 --> 01:19:24,050
vẽ bộ nhớ máy tính của tôi như là một
lưới, không chỉ là một đường thẳng.

1593
01:19:24,050 --> 01:19:28,190
Cụ thể, tôi cho rằng bây giờ mà
lưới này, 8 4 lưới này,

1594
01:19:28,190 --> 01:19:31,800
chỉ đại diện cho tất cả 32 byte
bộ nhớ có sẵn trong máy Mac của tôi,

1595
01:19:31,800 --> 01:19:33,030
hoặc có sẵn trong máy tính của tôi.

1596
01:19:33,030 --> 01:19:34,780
Và họ đang gói
vào hai dòng, chỉ cần

1597
01:19:34,780 --> 01:19:38,030
bởi vì nó phù hợp hơn trên màn hình.

1598
01:19:38,030 --> 01:19:40,800
Nhưng đây là byte đầu tiên.

1599
01:19:40,800 --> 01:19:41,990
Đây là byte thứ hai.

1600
01:19:41,990 --> 01:19:43,300
Đây là byte thứ ba.

1601
01:19:43,300 --> 01:19:45,310
>> Và đây là lần thứ 32 byte.

1602
01:19:45,310 --> 01:19:52,910
Hoặc, nếu chúng ta suy nghĩ như một máy tính
nhà khoa học, đây là byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Vì vậy, bạn có 0-31, nếu
bạn bắt đầu đếm từ 0.

1604
01:19:55,950 --> 01:19:59,830
>> Vì vậy, nếu chúng ta sử dụng một chương trình
các cuộc gọi nhận được chuỗi,

1605
01:19:59,830 --> 01:20:05,280
và chúng tôi nhận được một chuỗi từ con người
như tôi đã gọi Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
như thế nào trong thế giới hiện
máy tính giữ dấu vết của các byte,

1607
01:20:09,430 --> 01:20:12,230
mà đoạn bộ nhớ,
thuộc mà chuỗi?

1608
01:20:12,230 --> 01:20:16,270
Nói cách khác, nếu chúng ta tiến hành
gõ tên khác vào máy tính,

1609
01:20:16,270 --> 01:20:19,890
như Andi này, gọi
nhận được chuỗi một lần thứ hai,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I đã kết thúc trong
bộ nhớ của máy tính là tốt.

1611
01:20:23,030 --> 01:20:23,850
Nhưng bằng cách nào?

1612
01:20:23,850 --> 01:20:29,700
>> Vâng, nó chỉ ra rằng bên dưới
mui xe, những gì C không khi lưu trữ xâu

1613
01:20:29,700 --> 01:20:35,080
rằng các loại của con người trong, hoặc là
đến từ một số nguồn khác, là nó

1614
01:20:35,080 --> 01:20:39,190
phác họa hết trong số họ với
một dấu chéo ngược character-- đặc biệt

1615
01:20:39,190 --> 01:20:44,750
0, mà chỉ là một cách đặc biệt
nói 80 ​​bit trong một hàng.

1616
01:20:44,750 --> 01:20:47,950
>> Vì vậy là-- này là số 97 thu hồi.

1617
01:20:47,950 --> 01:20:51,770
Vì vậy, một số mô hình của 8 bit
đại diện cho số thập phân số 97.

1618
01:20:51,770 --> 01:20:58,070
Đây backslash 0 là thật sự là số
0, còn được gọi là nul, N-U-L, không giống như trước đây,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, mà chúng tôi nói chuyện về.

1620
01:20:59,630 --> 01:21:05,700
Nhưng bây giờ, chỉ biết rằng đây
backslash 0 chỉ là 80 bit trong một hàng.

1621
01:21:05,700 --> 01:21:09,810
>> Và nó chỉ là dòng này trong
cát nói bất cứ điều gì bên trái

1622
01:21:09,810 --> 01:21:12,610
thuộc về một chuỗi, hoặc một kiểu dữ liệu.

1623
01:21:12,610 --> 01:21:15,480
Và bất cứ điều gì về bên phải
thuộc về một cái gì đó khác.

1624
01:21:15,480 --> 01:21:17,440
Tên của Andi, trong khi đó,
mà chỉ cần trực quan

1625
01:21:17,440 --> 01:21:21,310
xảy ra để bọc vào đầu dây bên kia,
nhưng đó chỉ là một chi tiết thẩm mỹ,

1626
01:21:21,310 --> 01:21:23,990
tương tự là nul chấm dứt.

1627
01:21:23,990 --> 01:21:29,290
>> Đó là một chuỗi của một ký tự A-N-D-I,
cộng với một nhân vật bí mật thứ năm,

1628
01:21:29,290 --> 01:21:33,560
tất cả 0 bit, mà chỉ demarcates
cuối tên Andi là tốt.

1629
01:21:33,560 --> 01:21:37,120
Và nếu chúng ta gọi nhận được chuỗi lần thứ ba
trong máy tính để có được một chuỗi như thế

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, tương tự là Maria
Tên nul chấm dứt với dấu chéo ngược 0.

1631
01:21:44,210 --> 01:21:47,170
>> Điều này về cơ bản là khác nhau
từ làm thế nào một máy tính sẽ thường

1632
01:21:47,170 --> 01:21:51,850
lưu trữ một số nguyên, hoặc một phao, hoặc khác
kiểu dữ liệu vẫn còn, vì nhớ lại,

1633
01:21:51,850 --> 01:21:57,420
một số nguyên thường là 32 bit, hoặc
4 byte, hoặc thậm chí có thể 64 bit,

1634
01:21:57,420 --> 01:21:59,100
hay tám byte.

1635
01:21:59,100 --> 01:22:02,620
Nhưng nhiều nguyên thủy trong một máy tính
trong một ngôn ngữ lập trình

1636
01:22:02,620 --> 01:22:05,550
có một số cố định của
byte bên dưới hood--

1637
01:22:05,550 --> 01:22:08,100
có thể 1, có thể 2, có thể 4, có lẽ 8.

1638
01:22:08,100 --> 01:22:13,250
>> Nhưng chuỗi, theo thiết kế, có một
số năng động của nhân vật.

1639
01:22:13,250 --> 01:22:16,980
Bạn không biết trước, cho đến khi
các loại của con người trong Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
hoặc M-A-R-I-A, hoặc A-N-D-I. Bạn không biết
bao nhiêu lần người dùng sẽ nhấn

1641
01:22:21,400 --> 01:22:22,070
bàn phím.

1642
01:22:22,070 --> 01:22:26,490
Do đó, bạn không biết làm thế nào
nhiều nhân vật trước

1643
01:22:26,490 --> 01:22:27,540
bạn sẽ cần.

1644
01:22:27,540 --> 01:22:31,840
>> Và do đó, C chỉ loại lá như một
mẩu bánh mì bí mật bên dưới mui xe

1645
01:22:31,840 --> 01:22:32,960
ở phần cuối của chuỗi.

1646
01:22:32,960 --> 01:22:39,280
Sau khi lưu trữ Z-A-M-Y-L-A trong bộ nhớ,
nó cũng chỉ đặt tương đương

1647
01:22:39,280 --> 01:22:40,210
của một thời kỳ.

1648
01:22:40,210 --> 01:22:45,060
Vào cuối của một câu,
nó đặt 80 bit, do đó như

1649
01:22:45,060 --> 01:22:49,120
để ghi nhớ nơi
Zamyla bắt đầu và kết thúc.

1650
01:22:49,120 --> 01:22:51,490
>> Vì vậy, các kết nối là những gì,
sau đó, để chương trình này?

1651
01:22:51,490 --> 01:22:55,190
Chương trình này ở đây, Stirling,
chỉ đơn giản là một cơ chế

1652
01:22:55,190 --> 01:22:57,970
để nhận được một chuỗi
từ người sử dụng, dòng 6.

1653
01:22:57,970 --> 01:23:01,160
Dòng 7, tôi tuyên bố một biến
gọi n và thiết lập nó bằng 0.

1654
01:23:01,160 --> 01:23:08,680
>> Và sau đó trong dòng 8, tôi chỉ cần hỏi những
câu hỏi, trong khi các nhân vật n-thứ làm

1655
01:23:08,680 --> 01:23:12,120
không bằng tất cả 0 bits--
nói cách khác, không

1656
01:23:12,120 --> 01:23:14,500
bình đẳng đặc biệt này
nhân vật, dấu chéo ngược 0,

1657
01:23:14,500 --> 01:23:18,470
Chỉ là character-- nul đặc biệt
đi trước và chỉ tăng n.

1658
01:23:18,470 --> 01:23:21,460
>> Và tiếp tục làm nó, và giữ
làm việc đó, và tiếp tục làm nó.

1659
01:23:21,460 --> 01:23:23,430
Và do đó, mặc dù trong
quá khứ, chúng tôi đã sử dụng i,

1660
01:23:23,430 --> 01:23:25,181
nó hoàn toàn tốt đẹp
ngữ nghĩa sử dụng n,

1661
01:23:25,181 --> 01:23:27,430
nếu bạn chỉ cần cố gắng để
đếm thời gian này cố tình,

1662
01:23:27,430 --> 01:23:28,720
và chỉ muốn gọi nó là n.

1663
01:23:28,720 --> 01:23:34,720
Vì vậy, điều này chỉ giữ đặt câu hỏi,
là nhân vật thứ n của s tất cả các số 0?

1664
01:23:34,720 --> 01:23:38,470
Nếu không, nhìn vào giao diện tiếp theo,
tìm đến tiếp theo, nhìn đến tiếp theo,

1665
01:23:38,470 --> 01:23:39,460
tìm đến tiếp theo.

1666
01:23:39,460 --> 01:23:45,540
>> Nhưng ngay khi bạn thấy dấu chéo ngược 0,
dòng loop-- này 9 thông qua 11-- dừng.

1667
01:23:45,540 --> 01:23:49,640
Bạn thoát ra khỏi vòng lặp while,
để lại bên trong rằng biến n

1668
01:23:49,640 --> 01:23:54,530
tổng số của tất cả các
ký tự trong chuỗi bạn đã thấy,

1669
01:23:54,530 --> 01:23:55,660
do đó in nó ra.

1670
01:23:55,660 --> 01:23:56,760
Vì vậy, hãy cố gắng này.

1671
01:23:56,760 --> 01:23:59,500
>> Hãy để tôi đi trước và không có
bằng cách sử dụng chức năng stirling,

1672
01:23:59,500 --> 01:24:04,240
nhưng chỉ sử dụng phiên bản cây nhà lá vườn của riêng tôi
đây gọi là stirling, hãy để tôi đi trước

1673
01:24:04,240 --> 01:24:07,700
và chạy stirling, gõ vào một cái gì đó
như Zamyla, mà tôi biết trước

1674
01:24:07,700 --> 01:24:08,670
là sáu ký tự.

1675
01:24:08,670 --> 01:24:10,080
Hãy xem nếu nó hoạt động.

1676
01:24:10,080 --> 01:24:10,920
Thật vậy, đó là sáu.

1677
01:24:10,920 --> 01:24:15,257
Hãy thử với Rob, ba nhân vật,
ba nhân vật là tốt, và vân vân.

1678
01:24:15,257 --> 01:24:17,340
Vì vậy, đó là tất cả những gì đang diễn ra
trên dưới mui xe.

1679
01:24:17,340 --> 01:24:19,548
Và nhận thấy các kết nối,
sau đó, với những tuần đầu tiên

1680
01:24:19,548 --> 01:24:22,370
lớp học, nơi mà chúng tôi đã nói chuyện về
một cái gì đó giống như trừu tượng,

1681
01:24:22,370 --> 01:24:26,960
mà chỉ là lớp này của các ý tưởng, hoặc
phức tạp, trên nguyên tắc cơ bản.

1682
01:24:26,960 --> 01:24:30,710
Ở đây, chúng tôi đang tìm kiếm loại
bên dưới mui xe của stirling,

1683
01:24:30,710 --> 01:24:33,510
vậy để nói chuyện, để tìm ra,
làm thế nào nó sẽ được thực hiện?

1684
01:24:33,510 --> 01:24:35,232
>> Và chúng ta có thể tái thực hiện nó chính mình.

1685
01:24:35,232 --> 01:24:37,440
Nhưng chúng ta sẽ không bao giờ một lần nữa đi
để tái thực hiện stirling.

1686
01:24:37,440 --> 01:24:39,780
Chúng tôi chỉ đi
sử dụng để stirling

1687
01:24:39,780 --> 01:24:42,100
để thực sự có được một số chiều dài chuỗi.

1688
01:24:42,100 --> 01:24:44,200
>> Nhưng không có phép thuật
bên dưới mui xe.

1689
01:24:44,200 --> 01:24:46,716
Nếu bạn biết rằng bên dưới
mui xe, một chuỗi

1690
01:24:46,716 --> 01:24:48,090
chỉ là một chuỗi các ký tự.

1691
01:24:48,090 --> 01:24:51,090
Và đó là chuỗi các ký tự
tất cả có thể được giải quyết bằng số

1692
01:24:51,090 --> 01:24:53,330
với khung 0, khung
1, khung 2, và bạn

1693
01:24:53,330 --> 01:24:57,420
biết rằng vào cuối của một chuỗi là một
ký tự đặc biệt, bạn có thể tìm ra

1694
01:24:57,420 --> 01:25:01,710
làm thế nào để làm bất cứ điều gì nhất trong một
chương trình, bởi vì tất cả nó nắm tới

1695
01:25:01,710 --> 01:25:03,400
được đọc và viết bộ nhớ.

1696
01:25:03,400 --> 01:25:06,130
Đó là, thay đổi và tìm kiếm
tại bộ nhớ, hoặc di chuyển những thứ

1697
01:25:06,130 --> 01:25:10,940
xung quanh trong bộ nhớ, mọi thứ in
trên màn hình, và vv.

1698
01:25:10,940 --> 01:25:14,800
>> Vì vậy, bây giờ chúng ta sử dụng mới được phát hiện này
sự hiểu biết về những gì thực sự Strings

1699
01:25:14,800 --> 01:25:17,910
là dưới mui xe, và
bóc lại một lớp khác

1700
01:25:17,910 --> 01:25:20,080
cho đến bây giờ chúng tôi đã
được bỏ qua hoàn toàn.

1701
01:25:20,080 --> 01:25:22,650
Cụ thể, bất cứ lúc nào
chúng tôi đã thực hiện một chương trình,

1702
01:25:22,650 --> 01:25:25,930
chúng tôi đã có dòng mã này
gần đầu tuyên bố chính.

1703
01:25:25,930 --> 01:25:27,810
Và chúng tôi đã chỉ định int void main.

1704
01:25:27,810 --> 01:25:31,240
>> Và đó void bên trong dấu ngoặc đơn
có được nói bao nhiêu thời gian chính

1705
01:25:31,240 --> 01:25:33,440
tự nó không có bất kỳ đối số.

1706
01:25:33,440 --> 01:25:36,210
Bất kỳ đầu vào đó chính là
sẽ nhận được từ người sử dụng

1707
01:25:36,210 --> 01:25:39,020
phải đến từ một số khác
cơ chế, như get int,

1708
01:25:39,020 --> 01:25:42,040
hoặc nhận được phao, hoặc nhận được chuỗi,
hoặc một số chức năng khác.

1709
01:25:42,040 --> 01:25:44,710
Nhưng nó chỉ ra rằng
khi bạn viết một chương trình,

1710
01:25:44,710 --> 01:25:47,690
bạn thực sự có thể chỉ định
rằng chương trình này thì

1711
01:25:47,690 --> 01:25:51,730
có đầu vào từ con người
tại dòng lệnh riêng của mình.

1712
01:25:51,730 --> 01:25:56,310
>> Nói cách khác, mặc dù chúng tôi vậy, đến nay
có được chạy chỉ ./hello chào

1713
01:25:56,310 --> 01:26:00,312
hoặc các chương trình tương tự, tất cả các
các chương trình khác mà chúng tôi đã sử dụng,

1714
01:26:00,312 --> 01:26:02,770
mà chính chúng ta đã không viết,
có được tham gia, có vẻ như,

1715
01:26:02,770 --> 01:26:05,210
arguments-- dòng lệnh
những thứ như làm.

1716
01:26:05,210 --> 01:26:07,450
Bạn nói điều gì đó như make,
và sau đó một từ thứ hai.

1717
01:26:07,450 --> 01:26:10,950
Hoặc kêu vang, bạn nói Clang, và sau đó
một từ thứ hai, tên của một tập tin.

1718
01:26:10,950 --> 01:26:14,410
>> Hoặc thậm chí RM hoặc CP, như bạn có thể
đã nhìn thấy hoặc sử dụng đã

1719
01:26:14,410 --> 01:26:15,880
để loại bỏ hoặc sao chép các tập tin.

1720
01:26:15,880 --> 01:26:18,920
Tất cả những mất cái gọi là
arguments-- dòng lệnh

1721
01:26:18,920 --> 01:26:21,130
Nói cách thêm tại dấu nhắc thiết bị đầu cuối.

1722
01:26:21,130 --> 01:26:23,260
Nhưng cho đến bây giờ, chúng tôi
mình đã không có

1723
01:26:23,260 --> 01:26:27,080
sang trọng này lấy đầu vào từ
người sử dụng khi họ thực sự chạy

1724
01:26:27,080 --> 01:26:29,120
chương trình chính nó tại dòng lệnh.

1725
01:26:29,120 --> 01:26:33,710
>> Nhưng chúng ta có thể làm điều đó bằng cách tái tuyên bố
chính di chuyển về phía trước, không phải là có

1726
01:26:33,710 --> 01:26:36,750
làm mất hiệu lực trong dấu ngoặc đơn,
nhưng hai đối số này

1727
01:26:36,750 --> 01:26:40,600
instead-- đầu tiên một số nguyên,
và một cái gì đó thứ hai

1728
01:26:40,600 --> 01:26:44,170
mới, một cái gì đó mà chúng ta sẽ gọi
một mảng, một cái gì đó tương tự như trong tinh thần

1729
01:26:44,170 --> 01:26:49,220
những gì chúng ta đã thấy trong Scratch là một danh sách, nhưng
một mảng các chuỗi, như chúng ta sẽ thấy ngay.

1730
01:26:49,220 --> 01:26:51,790
Nhưng chúng ta thấy điều này bằng
một ví dụ, trước khi chúng tôi

1731
01:26:51,790 --> 01:26:53,690
phân biệt chính xác những gì có nghĩa là.

1732
01:26:53,690 --> 01:26:56,520
>> Vì vậy, nếu tôi đi vào CS50 IDE
ở đây, tôi đã đi trước

1733
01:26:56,520 --> 01:27:01,840
và tuyên bố trong một tập tin gọi là
argv0.c mẫu sau đây.

1734
01:27:01,840 --> 01:27:04,120
Và nhận thấy điều duy nhất
đó là khác nhau cho đến nay

1735
01:27:04,120 --> 01:27:08,570
được rằng tôi đã thay đổi khoảng trống để int
argc chuỗi argv khung mở, đóng

1736
01:27:08,570 --> 01:27:09,070
giá đỡ.

1737
01:27:09,070 --> 01:27:11,730
Và thông báo cho bây giờ, có
không có gì bên trong những dấu ngoặc đơn.

1738
01:27:11,730 --> 01:27:12,620
>> Không có con số.

1739
01:27:12,620 --> 01:27:15,070
Và không có tôi, hoặc
n, hoặc bất kỳ thư khác.

1740
01:27:15,070 --> 01:27:17,010
Tôi chỉ sử dụng các
dấu ngoặc vuông cho bây giờ,

1741
01:27:17,010 --> 01:27:19,510
vì lý do chúng tôi sẽ đến
trở lại chỉ trong một khoảnh khắc.

1742
01:27:19,510 --> 01:27:21,330
>> Và bây giờ những gì tôi sẽ làm được điều này.

1743
01:27:21,330 --> 01:27:26,680
Nếu argc bằng bằng 2--
và nhớ lại rằng bằng bình đẳng

1744
01:27:26,680 --> 01:27:30,040
là toán tử bằng cách so sánh
bên trái và bên phải bình đẳng.

1745
01:27:30,040 --> 01:27:31,790
Đó không phải là sự phân công
điều hành, đó là

1746
01:27:31,790 --> 01:27:36,510
các dấu bằng, có nghĩa là bản sao
từ bên phải sang bên trái một số giá trị.

1747
01:27:36,510 --> 01:27:42,840
>> Nếu argc bằng bằng 2, tôi muốn
nói, printf, hello, phần trăm, xuống dòng,

1748
01:27:42,840 --> 01:27:47,340
và sau đó cắm in-- và đây là mới
trick-- khung argv 1, vì lý do

1749
01:27:47,340 --> 01:27:48,840
rằng chúng tôi sẽ trở lại trong một thời điểm.

1750
01:27:48,840 --> 01:27:52,110
Else if argc không
bằng 2, bạn biết những gì?

1751
01:27:52,110 --> 01:27:57,400
Hãy chỉ cần đi trước và, như thường lệ, in
ra hello thế giới có thay thế không.

1752
01:27:57,400 --> 01:28:02,710
>> Vì vậy, nó sẽ có vẻ rằng nếu argc, mà
là viết tắt của số đối số, bằng 2,

1753
01:28:02,710 --> 01:28:04,740
Tôi sẽ in ra
xin chào một cái gì đó hoặc khác.

1754
01:28:04,740 --> 01:28:07,560
Nếu không, theo mặc định, tôi
sẽ in hello thế giới.

1755
01:28:07,560 --> 01:28:08,770
Vì vậy, điều này có nghĩa là gì?

1756
01:28:08,770 --> 01:28:15,550
>> Vâng, hãy để tôi đi trước và tiết kiệm
tập tin này, và sau đó làm làm argv0,

1757
01:28:15,550 --> 01:28:18,940
và sau đó ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Và nó nói hello thế giới.

1759
01:28:20,300 --> 01:28:21,260
Bây giờ, tại sao vậy?

1760
01:28:21,260 --> 01:28:24,730
>> Vâng, nó quay ra bất cứ lúc nào bạn
chạy một chương trình tại các dòng lệnh,

1761
01:28:24,730 --> 01:28:29,570
bạn điền vào những gì chúng tôi sẽ
thường gọi một vector tham số.

1762
01:28:29,570 --> 01:28:33,100
Nói cách khác, tự động
máy tính, hệ điều hành,

1763
01:28:33,100 --> 01:28:38,340
sẽ trao cho chương trình của bạn
tự nó là một danh sách của tất cả các từ

1764
01:28:38,340 --> 01:28:40,850
rằng con người đánh máy ở
dấu nhắc, trong trường hợp bạn

1765
01:28:40,850 --> 01:28:43,790
các lập trình viên muốn làm
một cái gì đó với thông tin đó.

1766
01:28:43,790 --> 01:28:48,540
Và trong trường hợp này, các từ ngữ chỉ
Tôi đã gõ tại dấu nhắc là ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Và do đó, số lượng các đối số đó là
được truyền cho chương trình của tôi chỉ có một.

1768
01:28:55,420 --> 01:28:58,880
Nói cách khác, đối số
đếm, nếu không được biết đến như argc

1769
01:28:58,880 --> 01:29:00,970
đây là một số nguyên, chỉ có một.

1770
01:29:00,970 --> 01:29:03,000
Một, tất nhiên, không bằng hai.

1771
01:29:03,000 --> 01:29:05,980
Và đây là những gì in, xin chào thế giới.

1772
01:29:05,980 --> 01:29:08,170
>> Nhưng hãy để tôi đi một nơi nào đó.

1773
01:29:08,170 --> 01:29:09,930
Hãy để tôi nói, argv0.

1774
01:29:09,930 --> 01:29:12,740
Và sau đó làm thế nào về Maria?

1775
01:29:12,740 --> 01:29:14,990
Và sau đó nhấn Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Và chú ý những gì kỳ diệu xảy ra ở đây.

1777
01:29:18,020 --> 01:29:22,640
Bây giờ, thay vì chào thế giới, tôi có
thay đổi hành vi của các chương trình này

1778
01:29:22,640 --> 01:29:26,310
bằng cách lấy đầu vào không phải từ get
chuỗi hoặc một số chức năng khác,

1779
01:29:26,310 --> 01:29:30,570
nhưng từ, rõ ràng, chỉ huy của tôi
chính nó, những gì tôi ban đầu gõ vào.

1780
01:29:30,570 --> 01:29:35,720
Và tôi có thể chơi trò chơi này một lần nữa bởi
thay đổi nó để Stelios, ví dụ.

1781
01:29:35,720 --> 01:29:38,400
>> Và bây giờ tôi thấy một tên khác vẫn còn.

1782
01:29:38,400 --> 01:29:40,540
Và ở đây, tôi có thể nói Andi.

1783
01:29:40,540 --> 01:29:42,137
Và tôi có thể nói Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Và chúng tôi có thể chơi trò chơi này cả ngày dài,
chỉ cần cắm vào các giá trị khác nhau,

1785
01:29:45,220 --> 01:29:49,550
chừng nào tôi còn cung cấp chính xác
hai chữ tại dấu nhắc,

1786
01:29:49,550 --> 01:29:52,260
mà argc, lập luận của tôi đếm, là 2.

1787
01:29:52,260 --> 01:29:57,240
>> Tôi thấy rằng tên cắm vào
printf, mỗi tình trạng này đây?

1788
01:29:57,240 --> 01:30:00,550
Vì vậy, chúng ta dường như có bây giờ
khả năng biểu cảm

1789
01:30:00,550 --> 01:30:04,410
lấy đầu vào từ một cơ chế khác,
từ dòng lệnh để gọi là,

1790
01:30:04,410 --> 01:30:07,000
thay vì phải chờ đợi
cho đến khi người dùng chạy các chương trình,

1791
01:30:07,000 --> 01:30:10,220
và sau đó nhắc anh ta hoặc cô
sử dụng một cái gì đó như get chuỗi.

1792
01:30:10,220 --> 01:30:11,230
>> Vì vậy, đây là những gì?

1793
01:30:11,230 --> 01:30:15,010
Argc, một lần nữa, chỉ là một số nguyên,
số lượng words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
mà người sử dụng cung cấp tại
nhanh chóng, tại cửa sổ thiết bị đầu cuối,

1795
01:30:18,540 --> 01:30:20,110
bao gồm cả tên của chương trình.

1796
01:30:20,110 --> 01:30:23,340
Vì vậy ./argv0 của chúng tôi là, có hiệu quả,
Tên của chương trình,

1797
01:30:23,340 --> 01:30:24,520
hoặc làm thế nào tôi chạy chương trình.

1798
01:30:24,520 --> 01:30:25,810
>> Mà đếm như một từ.

1799
01:30:25,810 --> 01:30:27,080
Vì vậy, argc sẽ là 1.

1800
01:30:27,080 --> 01:30:29,750
Nhưng khi tôi viết Stelios, hoặc
Andi, hoặc Zamyla, hoặc Maria,

1801
01:30:29,750 --> 01:30:31,660
đó có nghĩa là số lượng đối số là hai.

1802
01:30:31,660 --> 01:30:33,910
Và vì vậy bây giờ có hai từ thông qua tại.

1803
01:30:33,910 --> 01:30:36,070
>> Và thông báo, chúng tôi có thể tiếp tục logic này.

1804
01:30:36,070 --> 01:30:39,050
Nếu tôi thực sự nói
một cái gì đó giống như Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
tên đầy đủ, do đó đi qua
ba đối số trong tổng số,

1806
01:30:42,200 --> 01:30:47,410
bây giờ nó nói mặc định một lần nữa,
bởi vì, tất nhiên, 3 không bằng 2.

1807
01:30:47,410 --> 01:30:54,080
>> Và vì vậy theo cách này, tôi có
truy cập thông qua argv luận mới

1808
01:30:54,080 --> 01:30:56,080
rằng chúng ta có thể về mặt kỹ thuật
gọi bất cứ điều gì chúng ta muốn.

1809
01:30:56,080 --> 01:30:58,940
Nhưng theo quy ước, đó là
argv và argc, tương ứng.

1810
01:30:58,940 --> 01:31:04,470
Argv, vector tham số, là loại
của một từ đồng nghĩa với một lập trình

1811
01:31:04,470 --> 01:31:07,140
tính năng trong C được gọi là một mảng.

1812
01:31:07,140 --> 01:31:14,410
>> Một mảng là một danh sách các giá trị tương tự
trở lại, trở lại, trở lại, trở lại.

1813
01:31:14,410 --> 01:31:17,810
Nói cách khác, nếu một người ở ngay trong
RAM, tiếp theo là ngay bên cạnh nó,

1814
01:31:17,810 --> 01:31:18,800
và ngay bên cạnh nó.

1815
01:31:18,800 --> 01:31:20,101
Chúng không phải tất cả các nơi.

1816
01:31:20,101 --> 01:31:23,100
Và đó là kịch bản thứ hai, nơi mà mọi thứ
là tất cả các nơi trong bộ nhớ,

1817
01:31:23,100 --> 01:31:25,082
thực sự có thể là một tính năng mạnh mẽ.

1818
01:31:25,082 --> 01:31:28,040
Nhưng chúng tôi sẽ quay trở lại khi chúng ta
nói về cấu trúc dữ liệu fancier.

1819
01:31:28,040 --> 01:31:32,260
Để bây giờ, một mảng chỉ là
đoạn bộ nhớ tiếp giáp,

1820
01:31:32,260 --> 01:31:36,520
mỗi người có yếu tố này là
trở lại, trở lại, trở lại, trở lại,

1821
01:31:36,520 --> 01:31:38,050
và thường cùng loại.

1822
01:31:38,050 --> 01:31:42,630
>> Vì vậy, nếu bạn nghĩ về, từ một
thời điểm trước đây, một chuỗi là gì?

1823
01:31:42,630 --> 01:31:50,460
Vâng, một chuỗi, như Zamyla,
Z-A-M-Y-L-A, là, về mặt kỹ thuật,

1824
01:31:50,460 --> 01:31:51,400
chỉ là một mảng.

1825
01:31:51,400 --> 01:31:53,700
Đây là một mảng ký tự.

1826
01:31:53,700 --> 01:31:59,250
>> Và như vậy, nếu chúng ta thực sự thu hút này, như tôi
đã làm trước đó, như một đoạn bộ nhớ,

1827
01:31:59,250 --> 01:32:04,510
nó chỉ ra rằng mỗi người trong các
nhân vật chiếm một byte.

1828
01:32:04,510 --> 01:32:07,630
Và sau đó là người đặc biệt
nhân vật trọng điểm, dấu chéo ngược 0,

1829
01:32:07,630 --> 01:32:12,360
hoặc tất cả tám 0 bit, mà
demarcates cuối chuỗi.

1830
01:32:12,360 --> 01:32:15,090
Vì vậy, một chuỗi, nó quay
ra, trích dẫn chuỗi unquote,

1831
01:32:15,090 --> 01:32:20,580
chỉ là một mảng của chara--
char là một kiểu dữ liệu thực tế.

1832
01:32:20,580 --> 01:32:24,560
>> Và bây giờ argv, meanwhile--
chúng ta hãy quay trở lại với chương trình.

1833
01:32:24,560 --> 01:32:29,582
Argv, mặc dù chúng ta thấy từ
chuỗi ở đây, không phải là một chuỗi chính nó.

1834
01:32:29,582 --> 01:32:33,640
Argv, vector tham số,
là một mảng của chuỗi.

1835
01:32:33,640 --> 01:32:37,620
>> Vì vậy, cũng giống như bạn có thể có một mảng của
ký tự, bạn có thể có mức độ cao hơn,

1836
01:32:37,620 --> 01:32:46,279
một mảng của strings-- như vậy, ví dụ,
khi tôi đánh lúc nãy ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, không gian Z-A-M-Y-L-A, tôi tuyên bố rằng
argv có hai chuỗi trong ./argv0 it--,

1838
01:33:00,150 --> 01:33:03,185
và Z-A-M-Y-L-A. Trong
Nói cách khác, argc là 2.

1839
01:33:03,185 --> 01:33:03,980
Tại sao vậy?

1840
01:33:03,980 --> 01:33:08,370
>> Vâng, có hiệu quả, những gì đang diễn ra
được rằng mỗi một trong các chuỗi

1841
01:33:08,370 --> 01:33:13,990
là, tất nhiên, là một mảng ký tự
như trước đây, mỗi nhân vật có

1842
01:33:13,990 --> 01:33:15,670
chiếm một byte.

1843
01:33:15,670 --> 01:33:19,720
Và đừng nhầm lẫn giữa 0 thực tế
trong tên của chương trình với 0,

1844
01:33:19,720 --> 01:33:22,040
có nghĩa là tất cả 80 bit.

1845
01:33:22,040 --> 01:33:27,140
Và Zamyla, trong khi đó, vẫn còn
cũng là một mảng ký tự.

1846
01:33:27,140 --> 01:33:31,450
>> Vì vậy, vào cuối ngày, nó thực sự
trông như thế này bên dưới mui xe.

1847
01:33:31,450 --> 01:33:38,800
Nhưng argv, bởi bản chất của cách chính
công trình, cho phép tôi để bọc tất cả những điều này

1848
01:33:38,800 --> 01:33:44,810
thành, nếu bạn sẽ, một mảng lớn hơn
rằng, nếu chúng ta hơn một chút đơn giản hóa

1849
01:33:44,810 --> 01:33:48,180
những hình ảnh trông giống như và không
khá vẽ nó để mở rộng quy mô lên ở đó,

1850
01:33:48,180 --> 01:33:56,720
mảng này là chỉ có kích thước 2, đầu tiên
yếu tố trong đó có chứa một chuỗi,

1851
01:33:56,720 --> 01:33:59,230
yếu tố thứ hai của
trong đó có chứa một chuỗi.

1852
01:33:59,230 --> 01:34:01,687
Và, lần lượt, nếu bạn
loại zoom vào từng

1853
01:34:01,687 --> 01:34:03,770
của những chuỗi, những gì bạn
thấy bên dưới mui xe

1854
01:34:03,770 --> 01:34:07,190
là mỗi chuỗi chỉ là
một mảng ký tự.

1855
01:34:07,190 --> 01:34:11,680
>> Bây giờ, cũng như với các chuỗi,
chúng tôi đã có thể để có được quyền truy cập

1856
01:34:11,680 --> 01:34:15,260
với nhân vật thứ i trong một chuỗi
sử dụng mà ký hiệu khung vuông.

1857
01:34:15,260 --> 01:34:17,320
Tương tự như vậy, với mảng
nói chung, có thể chúng tôi

1858
01:34:17,320 --> 01:34:22,700
sử dụng ký hiệu khung vuông để có được
tại bất kỳ số lượng các chuỗi trong một mảng?

1859
01:34:22,700 --> 01:34:25,100
Ví dụ, hãy để tôi
đi trước và làm điều này.

1860
01:34:25,100 --> 01:34:32,420
>> Hãy để tôi đi trước và tạo argv1.c,
mà là một khác nhau chút thời gian này.

1861
01:34:32,420 --> 01:34:35,635
Thay vì kiểm tra cho argc2,
Tôi sẽ thay vì làm điều này.

1862
01:34:35,635 --> 01:34:41,270
Đối với int tôi nhận được 0, I ít
hơn argc, tôi cộng cộng,

1863
01:34:41,270 --> 01:34:47,920
và sau đó in ra bên trong này,
phần trăm s, dòng mới, và sau đó

1864
01:34:47,920 --> 01:34:50,740
argv khung i.

1865
01:34:50,740 --> 01:34:55,220
>> Vì vậy, nói cách khác, tôi không phải đối phó với
đặc điểm cá nhân tại thời điểm này.

1866
01:34:55,220 --> 01:35:00,190
Argv, như ngụ ý của những vuông rỗng
niềng răng bên phải của tên argv,

1867
01:35:00,190 --> 01:35:03,320
có nghĩa là argv là một mảng của chuỗi.

1868
01:35:03,320 --> 01:35:04,870
Và argc chỉ là một int.

1869
01:35:04,870 --> 01:35:08,800
>> Dòng này ở đây, 6, là
nói bộ i bằng 0.

1870
01:35:08,800 --> 01:35:11,980
Đếm tất cả các con đường lên,
nhưng không bao gồm, argc.

1871
01:35:11,980 --> 01:35:14,010
Và sau đó trên mỗi lần lặp,
in ra một chuỗi.

1872
01:35:14,010 --> 01:35:14,800
chuỗi gì?

1873
01:35:14,800 --> 01:35:17,270
>> Chuỗi thứ i trong argv.

1874
01:35:17,270 --> 01:35:19,530
Vì vậy, trong khi trước đó tôi đã
bằng cách sử dụng khung vuông

1875
01:35:19,530 --> 01:35:22,180
ký hiệu để có được thứ i
ký tự trong chuỗi, bây giờ

1876
01:35:22,180 --> 01:35:27,240
Tôi đang sử dụng các ký hiệu khung vuông
để có được ở các chuỗi thứ i trong một mảng.

1877
01:35:27,240 --> 01:35:30,310
Vì vậy, nó là loại một lớp
trên, khái niệm.

1878
01:35:30,310 --> 01:35:35,390
>> Và vì vậy những gì gọn về điều này
chương trình bây giờ, nếu tôi lập argv1,

1879
01:35:35,390 --> 01:35:42,067
và sau đó làm ./argv1, và sau đó gõ
trong một cái gì đó giống như foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
đó là ba chữ mặc định rằng một
khoa học máy tính đến cho bất cứ lúc nào

1881
01:35:45,400 --> 01:35:51,010
em cần một số lời giữ chỗ,
và nhấn Enter, mỗi của những từ ngữ,

1882
01:35:51,010 --> 01:35:54,980
bao gồm cả tên của chương trình, trong đó
là trong argv ở vị trí đầu tiên,

1883
01:35:54,980 --> 01:35:58,320
kết thúc lên được in cùng một lúc.

1884
01:35:58,320 --> 01:36:05,290
Và nếu tôi thay đổi điều này, và tôi nói
một cái gì đó giống như argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
chúng tôi nhận được tất cả ba trong số những
lời nói, mà là argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, bởi vì trong này
trường hợp argc, số lượng là 3.

1887
01:36:14,400 --> 01:36:20,020
>> Nhưng những gì là gọn gàng là nếu bạn hiểu
argv đó chỉ là một mảng của chuỗi,

1888
01:36:20,020 --> 01:36:24,910
và bạn hiểu rằng một chuỗi
là một mảng kí tự,

1889
01:36:24,910 --> 01:36:29,470
chúng ta có thể thực sự sử dụng loại này
khung ký hiệu vuông nhiều lần

1890
01:36:29,470 --> 01:36:33,320
để lựa chọn một chuỗi, và sau đó chọn
một ký tự trong chuỗi,

1891
01:36:33,320 --> 01:36:35,730
lặn sâu hơn như sau.

1892
01:36:35,730 --> 01:36:40,100
Trong ví dụ này, hãy để tôi đi
trước và gọi argv2.c này.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Và trong ví dụ này, hãy để tôi đi trước
và làm following-- cho int i nhận được 0,

1895
01:36:50,180 --> 01:36:53,286
i nhỏ hơn argc, tôi cộng
cộng, giống như trước đây.

1896
01:36:53,286 --> 01:36:55,910
Vì vậy, trong words-- khác và bây giờ điều này
là nhận được đủ phức tạp.

1897
01:36:55,910 --> 01:36:59,940
Sau đó, tôi sẽ nói
lặp qua chuỗi trong argv,

1898
01:36:59,940 --> 01:37:01,294
như một bình luận cho bản thân mình.

1899
01:37:01,294 --> 01:37:03,960
Và sau đó tôi sẽ có một
lồng cho vòng lặp, mà có thể bạn

1900
01:37:03,960 --> 01:37:06,290
đã làm, hoặc xem xét
làm, trong Scratch, nơi

1901
01:37:06,290 --> 01:37:08,600
Tôi sẽ nói int-- tôi
không sử dụng tôi một lần nữa,

1902
01:37:08,600 --> 01:37:12,590
bởi vì tôi không muốn để bóng, hoặc
loại ghi đè lên tôi hiện có.

1903
01:37:12,590 --> 01:37:15,780
>> Tôi sẽ, thay vào đó, nói j, vì
đó là đi của tôi để biến sau khi tôi,

1904
01:37:15,780 --> 01:37:18,590
khi tôi chỉ cố gắng để
đếm số đơn giản.

1905
01:37:18,590 --> 01:37:28,850
Đối với j được 0-- và cũng có, n, sẽ
có chiều dài đuôi của khung argv i,

1906
01:37:28,850 --> 01:37:36,030
miễn là j là ít hơn m,
j cộng cộng, làm như sau.

1907
01:37:36,030 --> 01:37:37,500
Và đây là một phần thú vị.

1908
01:37:37,500 --> 01:37:46,330
>> In ra một nhân vật và một dòng mới,
cắm trong argv khung i, khung j.

1909
01:37:46,330 --> 01:37:47,940
OK, vậy cho tôi thêm một số ý kiến ​​tại đây.

1910
01:37:47,940 --> 01:37:54,820
Lặp trên ký tự
trong chuỗi hiện tại,

1911
01:37:54,820 --> 01:38:02,290
in j-thứ nhân vật trong chuỗi thứ i.

1912
01:38:02,290 --> 01:38:04,630
Vì vậy, bây giờ, chúng ta hãy xem xét
những gì những ý kiến ​​có ý nghĩa.

1913
01:38:04,630 --> 01:38:06,750
>> Lặp qua các chuỗi
trong argv-- bao nhiêu

1914
01:38:06,750 --> 01:38:09,300
dây là trong argv, mà là một mảng?

1915
01:38:09,300 --> 01:38:13,420
Argc nhiều, vì vậy tôi lặp
từ i bằng 0 lên tới argc.

1916
01:38:13,420 --> 01:38:20,020
Trong khi đó, có bao nhiêu ký tự
là trong chuỗi thứ i trong argv?

1917
01:38:20,020 --> 01:38:22,880
>> Vâng, để có được câu trả lời rằng,
Tôi chỉ cần gọi dài chuỗi

1918
01:38:22,880 --> 01:38:26,810
vào chuỗi hiện chăm sóc tôi
về, đó là argv khung i.

1919
01:38:26,810 --> 01:38:30,090
Và tôi sẽ tạm thời lưu trữ mà
giá trị trong n, chỉ cho mục đích bộ nhớ đệm,

1920
01:38:30,090 --> 01:38:31,590
để ghi nhớ nó cho hiệu quả.

1921
01:38:31,590 --> 01:38:36,330
Và sau đó tôi sẽ khởi tạo j đến 0,
tiếp tục đi miễn là j nhỏ hơn n,

1922
01:38:36,330 --> 01:38:38,430
và trên mỗi increment lặp j.

1923
01:38:38,430 --> 01:38:41,030
>> Và sau đó ở đây, mỗi
nhận xét của tôi về dòng 12,

1924
01:38:41,030 --> 01:38:43,390
in ra một nhân vật,
theo sau là một dòng mới,

1925
01:38:43,390 --> 01:38:48,140
khung đặc biệt argv
tôi mang lại cho tôi những chuỗi thứ i

1926
01:38:48,140 --> 01:38:51,690
trong argv-- vậy từ đầu tiên, các
Từ thứ hai, từ thứ ba, bất cứ điều gì.

1927
01:38:51,690 --> 01:38:57,370
Và sau đó lặn j vào sâu hơn, và được
tôi nhân vật j-thứ của từ đó.

1928
01:38:57,370 --> 01:39:02,200
Và như vậy, trong thực tế, bạn có thể điều trị
argv là một đa chiều,

1929
01:39:02,200 --> 01:39:06,050
như là một hai chiều, mảng,
theo đó mỗi từ loại hình

1930
01:39:06,050 --> 01:39:08,580
như thế này trong tâm trí của bạn
mắt, và mỗi nhân vật

1931
01:39:08,580 --> 01:39:10,930
là loại sáng tác
một cột, nếu giúp.

1932
01:39:10,930 --> 01:39:13,260
>> Trong thực tế, khi chúng tôi trêu chọc
này ngoài trong tuần tương lai,

1933
01:39:13,260 --> 01:39:15,580
nó sẽ là một chút
phức tạp hơn đó.

1934
01:39:15,580 --> 01:39:17,800
Nhưng bạn có thể thực sự
nghĩ rằng, bây giờ,

1935
01:39:17,800 --> 01:39:22,110
như chỉ này hai chiều
mảng, trong đó một mức độ của nó

1936
01:39:22,110 --> 01:39:23,260
là tất cả các dây.

1937
01:39:23,260 --> 01:39:26,760
Và sau đó nếu bạn lặn sâu hơn, bạn
có thể có được ở các đặc điểm cá nhân

1938
01:39:26,760 --> 01:39:29,600
trong đó bằng cách sử dụng ký hiệu này ở đây.

1939
01:39:29,600 --> 01:39:31,620
>> Vì vậy, ảnh hưởng thực là gì?

1940
01:39:31,620 --> 01:39:34,970
Hãy để tôi đi trước và
làm cho darn argv2-- nó.

1941
01:39:34,970 --> 01:39:36,210
Tôi đã làm sai ở đây.

1942
01:39:36,210 --> 01:39:40,160
Ngầm tuyên bố
thư viện chức năng stirling.

1943
01:39:40,160 --> 01:39:42,190
Vì vậy, tất cả các thời gian này, đó là
có lẽ thích hợp

1944
01:39:42,190 --> 01:39:45,130
rằng chúng ta đang loại kết thúc
chính xác nơi chúng tôi bắt đầu.

1945
01:39:45,130 --> 01:39:48,160
>> Tôi hơi say lên, ngầm tuyên bố
thư viện chức năng stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, chờ một phút.

1947
01:39:48,987 --> 01:39:51,070
Tôi nhớ rằng, đặc biệt
vì nó ở ngay đây.

1948
01:39:51,070 --> 01:39:54,490
Tôi cần phải bao gồm string.h trong
phiên bản này của chương trình.

1949
01:39:54,490 --> 01:40:00,050
>> Hãy để tôi đi trước và bao gồm
string.h, tiết kiệm mà, đi trước

1950
01:40:00,050 --> 01:40:04,460
và biên dịch lại argv2.

1951
01:40:04,460 --> 01:40:08,390
Và bây giờ, ở đây chúng tôi đi, làm cho argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Và mặc dù nó là một chút
khó hiểu ở cái nhìn đầu tiên,

1953
01:40:10,590 --> 01:40:15,690
nhận thấy rằng, trên thực tế, những gì
được in là dấu chấm argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Nhưng nếu tôi gõ một số từ sau khi
nhanh chóng, như argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Nhập, cũng là một chút
khó hiểu ở cái nhìn đầu tiên.

1956
01:40:22,560 --> 01:40:30,540
Nhưng nếu chúng ta di chuyển trở lại,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Vì vậy, chúng tôi đã lặp qua từng lời.

1958
01:40:32,190 --> 01:40:37,770
Và, lần lượt, chúng tôi đã lặp hơn
mỗi nhân vật trong một từ.

1959
01:40:37,770 --> 01:40:40,040
>> Bây giờ, sau khi tất cả những điều này,
nhận ra rằng có

1960
01:40:40,040 --> 01:40:43,120
một chi tiết khác mà chúng tôi đã loại
bỏ qua toàn bộ thời gian này.

1961
01:40:43,120 --> 01:40:46,180
Chúng tôi chỉ trêu chọc nhau những gì
đầu vào chính có thể được?

1962
01:40:46,180 --> 01:40:47,780
Còn đầu ra chính của?

1963
01:40:47,780 --> 01:40:50,540
>> Tất cả thời gian này, chúng tôi đã
chỉ cần sao chép và dán

1964
01:40:50,540 --> 01:40:53,870
int từ trước của chính,
mặc dù bạn có thể xem trực tuyến,

1965
01:40:53,870 --> 01:40:58,340
đôi khi không đúng trong các phiên bản cũ
C và trình biên dịch, mà họ cho rằng có hiệu lực,

1966
01:40:58,340 --> 01:40:59,410
hoặc không có gì cả.

1967
01:40:59,410 --> 01:41:01,580
Nhưng, thực sự, cho các phiên bản
của C mà chúng tôi đang sử dụng,

1968
01:41:01,580 --> 01:41:06,180
C 11, hoặc 2011, nhận ra
rằng nó phải là int.

1969
01:41:06,180 --> 01:41:09,300
Và nó, hoặc nên
trị hoặc argc và argv đây.

1970
01:41:09,300 --> 01:41:10,790
>> Nhưng tại sao int main?

1971
01:41:10,790 --> 01:41:12,480
Những gì được nó thực sự trở lại?

1972
01:41:12,480 --> 01:41:16,280
Vâng, nó quay ra tất cả các thời gian này,
bất cứ lúc nào bạn đã viết một chương trình chính

1973
01:41:16,280 --> 01:41:18,440
luôn luôn trở về một cái gì đó.

1974
01:41:18,440 --> 01:41:19,960
Nhưng nó được làm như vậy bí mật.

1975
01:41:19,960 --> 01:41:23,350
>> cái gì đó là một
int, như dòng 5 gợi ý.

1976
01:41:23,350 --> 01:41:24,225
Nhưng những gì int?

1977
01:41:24,225 --> 01:41:26,100
Vâng, có này
ước trong lập trình,

1978
01:41:26,100 --> 01:41:29,790
theo đó nếu không có gì có
đi sai và tất cả là tốt,

1979
01:41:29,790 --> 01:41:34,250
chương trình và các chức năng thông thường
return-- hơi counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 thường có nghĩa tất cả là tốt.

1982
01:41:38,070 --> 01:41:40,610
Vì vậy, ngay cả khi bạn nghĩ
nó như là sai trong nhiều ngữ cảnh,

1983
01:41:40,610 --> 01:41:42,930
nó thực sự thường có nghĩa là một điều tốt

1984
01:41:42,930 --> 01:41:49,560
>> Trong khi đó, nếu một chương trình trả về 1,
hay tiêu cực 1, hoặc 5, hoặc âm 42,

1985
01:41:49,560 --> 01:41:52,941
hay-0 không giá trị bất kỳ,
mà thường có nghĩa

1986
01:41:52,941 --> 01:41:54,190
cái gì đó đã đi sai.

1987
01:41:54,190 --> 01:41:56,700
Trong thực tế, trên Mac của bạn hoặc máy tính,
bạn có thể đã thực sự nhìn thấy

1988
01:41:56,700 --> 01:42:01,050
một thông báo lỗi, nhờ đó mà nó
nói một cái gì đó hoặc khác, lỗi

1989
01:42:01,050 --> 01:42:04,940
đang âm 42, hoặc mã lỗi
23, hoặc một cái gì đó như thế.

1990
01:42:04,940 --> 01:42:08,980
Con số này nói chung chỉ là một gợi ý
để các lập trình viên, hoặc công ty

1991
01:42:08,980 --> 01:42:11,174
mà thực hiện các phần mềm,
những gì đã đi sai và tại sao,

1992
01:42:11,174 --> 01:42:13,590
để họ có thể xem xét thông qua
tài liệu hướng dẫn hoặc mã của họ,

1993
01:42:13,590 --> 01:42:15,465
và tìm ra những gì
lỗi thực sự có nghĩa.

1994
01:42:15,465 --> 01:42:18,400
Nó thường không
hữu ích cho chúng tôi người dùng cuối.

1995
01:42:18,400 --> 01:42:20,550
>> Nhưng khi trở về chính 0, tất cả là tốt.

1996
01:42:20,550 --> 01:42:23,770
Và nếu bạn không xác định
những gì chính nên trở về,

1997
01:42:23,770 --> 01:42:26,950
nó sẽ chỉ tự động
trở về 0 cho bạn.

1998
01:42:26,950 --> 01:42:30,870
Nhưng trở về một cái gì đó
khác là thực sự hữu ích.

1999
01:42:30,870 --> 01:42:34,660
>> Trong chương trình cuối cùng này, cho tôi
đi trước và gọi exit.c này,

2000
01:42:34,660 --> 01:42:38,630
và giới thiệu cuối cùng của ngày hôm nay
chủ đề, được biết đến như là một mã lỗi.

2001
01:42:38,630 --> 01:42:42,930
Hãy để tôi đi trước và bao gồm của chúng tôi
file lên hàng đầu quen thuộc, làm int main.

2002
01:42:42,930 --> 01:42:49,500
Và lần này, chúng ta hãy làm int argc,
chuỗi argv, và với dấu ngoặc của tôi

2003
01:42:49,500 --> 01:42:50,836
ngụ ý rằng nó là trong mảng.

2004
01:42:50,836 --> 01:42:52,460
Và sau đó hãy để tôi làm một kiểm tra sự tỉnh táo.

2005
01:42:52,460 --> 01:42:56,640
Lần này, nếu argc không
bằng 2, sau đó bạn biết những gì?

2006
01:42:56,640 --> 01:42:57,520
Kệ nó.

2007
01:42:57,520 --> 01:43:03,170
Tôi sẽ nói rằng, hey, người dùng,
bạn đang thiếu đối số dòng lệnh

2008
01:43:03,170 --> 01:43:04,210
n dấu chéo ngược.

2009
01:43:04,210 --> 01:43:05,230
>> Và sau đó đó là nó.

2010
01:43:05,230 --> 01:43:06,130
Tôi muốn thoát ra.

2011
01:43:06,130 --> 01:43:11,030
Tôi sẽ làm việc tạm thời,
và sớm thực sự, trở lại

2012
01:43:11,030 --> 01:43:12,810
một cái gì đó khác hơn là số 1.

2013
01:43:12,810 --> 01:43:15,360
Việc đi đến giá trị cho các đầu tiên
lỗi có thể xảy ra là 1.

2014
01:43:15,360 --> 01:43:17,860
Nếu bạn có một số khác có sai sót
tình hình có thể xảy ra,

2015
01:43:17,860 --> 01:43:21,390
bạn có thể nói trở lại 2 hoặc trả lại 3, hoặc
thậm chí có tiêu cực hay tiêu cực 1 2.

2016
01:43:21,390 --> 01:43:23,750
>> Đây chỉ là mã lối ra
đó là, nói chung,

2017
01:43:23,750 --> 01:43:27,770
chỉ hữu ích cho các lập trình viên, hoặc
công ty nào vận chuyển các phần mềm.

2018
01:43:27,770 --> 01:43:30,500
Nhưng thực tế là nó
không phải 0 là điều quan trọng.

2019
01:43:30,500 --> 01:43:34,310
Vì vậy, nếu trong chương trình này, tôi muốn
đảm bảo rằng chương trình này chỉ

2020
01:43:34,310 --> 01:43:38,190
hoạt động nếu người sử dụng cung cấp cho tôi
với một số đối số của hai,

2021
01:43:38,190 --> 01:43:42,880
tên của chương trình, và một số khác
từ, tôi có thể thực thi nhiều như sau,

2022
01:43:42,880 --> 01:43:46,110
mắng cho người dùng printf câu nói,
thiếu đối số dòng lệnh,

2023
01:43:46,110 --> 01:43:46,970
trở về 1.

2024
01:43:46,970 --> 01:43:49,940
Điều đó sẽ chỉ ngay lập tức
thoát khỏi chương trình.

2025
01:43:49,940 --> 01:43:55,840
>> Chỉ khi argc bằng 2, chúng ta sẽ có được xuống
ở đây, và lúc đó tôi sẽ nói,

2026
01:43:55,840 --> 01:44:00,410
xin chào trăm s, dấu chéo ngược n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Nói cách khác, tôi
không đi sau khi argv 0,

2028
01:44:03,827 --> 01:44:05,410
mà chỉ là tên của chương trình.

2029
01:44:05,410 --> 01:44:09,450
Tôi muốn in ra chào hỏi, dấu phẩy,
từ thứ hai mà con người gõ.

2030
01:44:09,450 --> 01:44:12,580
Và trong trường hợp này trên
dòng 13, tất cả là tốt.

2031
01:44:12,580 --> 01:44:15,920
>> Tôi biết rằng argc là 2
logic từ chương trình này.

2032
01:44:15,920 --> 01:44:17,770
Tôi sẽ đi trước và trở về 0.

2033
01:44:17,770 --> 01:44:21,230
Là một sang một bên, giữ trong tâm trí rằng
điều này là đúng trong Scratch là tốt.

2034
01:44:21,230 --> 01:44:24,760
>> Một cách logic, tôi có thể làm điều này
và gói gọn những dòng này

2035
01:44:24,760 --> 01:44:27,020
các mã trong khác quy định tại khoản này ở đây.

2036
01:44:27,020 --> 01:44:29,420
Nhưng đó là loại
không cần thiết thụt mã của tôi.

2037
01:44:29,420 --> 01:44:31,800
Và tôi muốn làm siêu
rõ ràng rằng không có vấn đề gì,

2038
01:44:31,800 --> 01:44:34,670
theo mặc định, hello
một cái gì đó sẽ được in,

2039
01:44:34,670 --> 01:44:36,050
miễn là người sử dụng hợp tác.

2040
01:44:36,050 --> 01:44:39,360
>> Vì vậy, nó rất phổ biến để sử dụng
một điều kiện, chỉ cần một khi,

2041
01:44:39,360 --> 01:44:41,870
để nắm bắt một số sai lầm
tình hình, và sau đó thoát ra.

2042
01:44:41,870 --> 01:44:45,690
Và sau đó, miễn là tất cả
tốt, không có một người nào khác,

2043
01:44:45,690 --> 01:44:48,060
nhưng chỉ có mã
bên ngoài mà nếu, bởi vì nó

2044
01:44:48,060 --> 01:44:51,060
tương đương trong này
trường hợp cụ thể, hợp lý.

2045
01:44:51,060 --> 01:44:54,480
Vì vậy, tôi trở về 0, chỉ để
một cách rõ ràng biểu hiện tất cả là tốt.

2046
01:44:54,480 --> 01:44:58,480
>> Nếu tôi bỏ qua sự trở lại 0, nó sẽ
được tự động giả định cho tôi.

2047
01:44:58,480 --> 01:45:00,890
Nhưng bây giờ tôi trở lại
một trong ít nhất là trường hợp này,

2048
01:45:00,890 --> 01:45:04,940
Tôi sẽ cho các biện pháp tốt và
rõ ràng, trở về 0 trong trường hợp này.

2049
01:45:04,940 --> 01:45:09,690
Vì vậy, bây giờ để tôi đi trước và thực xuất cảnh,
mà là một segue hoàn hảo để chỉ để lại.

2050
01:45:09,690 --> 01:45:14,401
>> Nhưng làm cho lối ra, và cho tôi đi
trước và làm ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Và chương trình mắng tôi,
thiếu đối số dòng lệnh.

2052
01:45:16,900 --> 01:45:18,120
OK, tôi hợp tác.

2053
01:45:18,120 --> 01:45:23,810
>> Hãy để tôi thay vì làm ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Và bây giờ nó nói, hello David.

2055
01:45:25,190 --> 01:45:27,300
Và bạn sẽ không bình thường thấy điều này.

2056
01:45:27,300 --> 01:45:30,650
>> Nhưng nó chỉ ra rằng có một
cách đặc biệt trong Linux để thực sự thấy

2057
01:45:30,650 --> 01:45:34,470
với những gì xuất cảnh mã một chương trình thoát.

2058
01:45:34,470 --> 01:45:37,184
Đôi khi trong một đồ họa
thế giới như Mac OS hay Windows,

2059
01:45:37,184 --> 01:45:40,100
bạn chỉ nhìn thấy những con số khi một
thông báo lỗi hiện lên trên màn hình

2060
01:45:40,100 --> 01:45:41,940
và các lập trình viên
cho bạn thấy con số đó.

2061
01:45:41,940 --> 01:45:44,773
Nhưng nếu chúng ta muốn nhìn thấy những gì các lỗi
tin là, chúng ta có thể làm điều đó đây--

2062
01:45:44,773 --> 01:45:48,100
nên ./exit, Enter, in
thiếu đối số dòng lệnh.

2063
01:45:48,100 --> 01:45:54,590
>> Nếu bây giờ tôi làm $ echo ?, đó là
ridiculously khó hiểu nhìn.

2064
01:45:54,590 --> 01:45:56,590
Nhưng $?

2065
01:45:56,590 --> 01:45:59,220
là câu thần chú ma thuật
mà nói, hey, máy tính,

2066
01:45:59,220 --> 01:46:01,900
cho tôi biết những gì trước đó
exit code chương trình là.

2067
01:46:01,900 --> 01:46:03,410
Và tôi nhấn Enter.

2068
01:46:03,410 --> 01:46:07,520
Tôi thấy 1, bởi vì đó là những gì tôi
nói với chức năng chính của tôi để trở lại.

2069
01:46:07,520 --> 01:46:12,310
>> Trong khi đó, nếu tôi làm ./exit David,
và nhấn Enter, tôi nhìn thấy, xin chào David.

2070
01:46:12,310 --> 01:46:16,800
Và nếu bây giờ tôi làm $ echo ?, tôi thấy chào 0.

2071
01:46:16,800 --> 01:46:19,080
Và do đó, điều này sẽ thực sự
được thông tin có giá trị

2072
01:46:19,080 --> 01:46:23,420
trong bối cảnh của các trình gỡ lỗi, không quá
nhiều mà bạn, những con người, sẽ quan tâm.

2073
01:46:23,420 --> 01:46:26,060
Nhưng các trình gỡ lỗi và khác
các chương trình, chúng tôi sẽ sử dụng trong học kỳ này

2074
01:46:26,060 --> 01:46:29,420
thường sẽ nhìn vào con số đó,
mặc dù nó loại ẩn đi

2075
01:46:29,420 --> 01:46:32,780
trừ khi bạn tìm nó, để
xác định có hay không một chương trình của

2076
01:46:32,780 --> 01:46:37,050
thực hiện là đúng hay sai.

2077
01:46:37,050 --> 01:46:40,450
>> Và vì vậy mà chúng tôi mang đến
này, vào cuối ngày.

2078
01:46:40,450 --> 01:46:43,917
Chúng tôi bắt đầu ngày hôm nay bằng cách nhìn vào
gỡ lỗi, và lần lượt tại khóa học

2079
01:46:43,917 --> 01:46:46,750
chính nó, và sau đó thú vị hơn,
kỹ thuật bên dưới mui xe

2080
01:46:46,750 --> 01:46:49,490
vào những gì là chuỗi, mà kéo dài
tuần, chúng tôi chỉ mất cho các cấp,

2081
01:46:49,490 --> 01:46:51,900
và chắc chắn đã đưa họ
cho các cấp trong Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Sau đó chúng ta nhìn như thế nào chúng ta có thể truy cập
ký tự đặc biệt trong một chuỗi,

2083
01:46:56,040 --> 01:47:00,310
và sau đó lại mất một mức độ cao hơn
nhìn vào những thứ, nhìn vào cách well--

2084
01:47:00,310 --> 01:47:04,226
nếu chúng ta muốn nhận được ở cá nhân
các yếu tố trong một danh sách như cấu trúc,

2085
01:47:04,226 --> 01:47:05,850
chúng ta không thể làm điều đó với nhiều dây?

2086
01:47:05,850 --> 01:47:08,050
Và chúng ta có thể có đối số dòng lệnh.

2087
01:47:08,050 --> 01:47:12,800
Nhưng hình ảnh này ở đây chỉ hộp
là minh chứng của ý tưởng này nói chung

2088
01:47:12,800 --> 01:47:14,451
của một mảng, hoặc một danh sách, hoặc một vector.

2089
01:47:14,451 --> 01:47:16,450
Và tùy thuộc vào
bối cảnh, tất cả những lời này

2090
01:47:16,450 --> 01:47:17,880
có nghĩa là những điều hơi khác nhau.

2091
01:47:17,880 --> 01:47:20,060
Vì vậy, trong C, chúng tôi sẽ chỉ
để nói về một mảng.

2092
01:47:20,060 --> 01:47:23,840
Và một mảng là một đoạn
của bộ nhớ, mỗi người trong số đó là

2093
01:47:23,840 --> 01:47:27,720
yếu tố này là tiếp giáp, trở lại,
trở lại, trở lại, trở lại.

2094
01:47:27,720 --> 01:47:31,970
>> Và những yếu tố này, nói chung,
của các kiểu dữ liệu, nhân vật,

2095
01:47:31,970 --> 01:47:35,966
nhân vật, nhân vật, nhân vật hoặc
string, string, string, string, int,

2096
01:47:35,966 --> 01:47:38,600
int, int, bất kể nó là
chúng tôi đang cố gắng để lưu trữ.

2097
01:47:38,600 --> 01:47:42,540
Nhưng vào cuối ngày, đây là
những gì nó trông giống như khái niệm.

2098
01:47:42,540 --> 01:47:44,530
Bạn đang dùng của bạn
bộ nhớ hoặc bộ nhớ RAM của máy tính.

2099
01:47:44,530 --> 01:47:48,590
Và bạn đang khắc nó ra vào
hộp hệt kích thước, tất cả đều

2100
01:47:48,590 --> 01:47:50,920
đang trở lại, trở lại, để
trở lại, để trở lại theo cách này.

2101
01:47:50,920 --> 01:47:53,200
>> Và những gì tốt đẹp về
ý tưởng này, và thực tế

2102
01:47:53,200 --> 01:47:58,580
chúng tôi có thể thể hiện các giá trị theo cách này
với sự đầu tiên của cấu trúc dữ liệu của chúng tôi

2103
01:47:58,580 --> 01:48:02,520
trong lớp, có nghĩa là chúng ta có thể bắt đầu
để giải quyết vấn đề với mã

2104
01:48:02,520 --> 01:48:04,079
mà đến để trực giác trong tuần 0.

2105
01:48:04,079 --> 01:48:05,870
Bạn sẽ gọi lại điện thoại
ví dụ cuốn sách, nơi

2106
01:48:05,870 --> 01:48:09,110
chúng tôi sử dụng một phân chia và chinh phục,
hoặc một thuật toán tìm kiếm nhị phân,

2107
01:48:09,110 --> 01:48:13,220
để sàng lọc thông qua một toàn
loạt các tên và số.

2108
01:48:13,220 --> 01:48:18,220
Nhưng chúng tôi cho rằng, thu hồi, mà đó
Danh bạ điện thoại đã được sắp xếp,

2109
01:48:18,220 --> 01:48:21,630
mà người khác đã đã
đặn out-- cấp một danh sách các tên

2110
01:48:21,630 --> 01:48:24,430
và làm thế nào để numbers-- alphabetize họ.

2111
01:48:24,430 --> 01:48:26,950
Và bây giờ mà trong C chúng ta,
quá, có khả năng

2112
01:48:26,950 --> 01:48:30,290
để đặt những điều trên, không
thể chất trong một cuốn sách điện thoại

2113
01:48:30,290 --> 01:48:34,220
nhưng hầu như trong một máy tính
bộ nhớ, chúng ta sẽ có thể vào tuần tới

2114
01:48:34,220 --> 01:48:38,470
giới thiệu một lần nữa này-- đầu tiên
cấu trúc dữ liệu của chúng tôi trong một array--

2115
01:48:38,470 --> 01:48:43,530
nhưng quan trọng hơn, máy tính thực tế
các thuật toán khoa học thực hiện

2116
01:48:43,530 --> 01:48:47,720
trong mã, mà chúng ta có thể lưu trữ
dữ liệu trong cấu trúc như thế này,

2117
01:48:47,720 --> 01:48:50,730
và sau đó bắt đầu để vận dụng nó, và
để thực sự giải quyết vấn đề với nó,

2118
01:48:50,730 --> 01:48:53,570
và để xây dựng trên đó,
cuối cùng, chương trình trong C,

2119
01:48:53,570 --> 01:48:56,730
trong Python, JavaScript,
truy vấn cơ sở dữ liệu với SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Và chúng ta sẽ thấy rằng tất cả các
ý tưởng khác nhau interlock.

2121
01:48:59,980 --> 01:49:04,100
Nhưng bây giờ, nhớ lại rằng
miền mà chúng tôi giới thiệu hôm nay

2122
01:49:04,100 --> 01:49:06,920
là điều này ở đây, và
thế giới của mật mã.

2123
01:49:06,920 --> 01:49:11,200
Và trong số những vấn đề tiếp theo bạn mình
sẽ giải quyết là nghệ thuật mật mã,

2124
01:49:11,200 --> 01:49:13,630
xáo trộn và de-xáo trộn
thông tin và mã hoá

2125
01:49:13,630 --> 01:49:15,930
và giải mã văn bản,
và giả định cuối cùng

2126
01:49:15,930 --> 01:49:18,970
mà bây giờ bạn biết những gì
là dưới mui xe

2127
01:49:18,970 --> 01:49:21,860
để khi bạn nhìn thấy hoặc nhận được
một tin nhắn như thế này, bạn

2128
01:49:21,860 --> 01:49:24,060
mình có thể giải mã nó.

2129
01:49:24,060 --> 01:49:26,740
Tất cả điều này, và lần sau nữa.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [XEM LẠI VIDEO]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Vừa đến.

2133
01:49:32,970 --> 01:49:35,146
Tôi sẽ đi thăm
giáo sư đại học của mình.

2134
01:49:35,146 --> 01:49:37,611
Vâng.

2135
01:49:37,611 --> 01:49:40,080
Chào.

2136
01:49:40,080 --> 01:49:40,660
Đó là bạn.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Chờ đợi!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Tôi chỉ cố gắng tìm
ra những gì đã xảy ra với bạn.

2142
01:49:56,060 --> 01:49:58,130
Xin vui lòng, bất cứ điều gì có thể giúp đỡ.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Bạn là đại học của mình
bạn cùng phòng, không bạn?

2145
01:50:08,354 --> 01:50:10,770
Bạn đã có với anh ta khi
ông đã hoàn thành dự án CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [NHẠC]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -đó Là CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Tôi yêu nơi này.

2152
01:50:44,770 --> 01:50:45,854
>> -Ăn nhiều lên.

2153
01:50:45,854 --> 01:50:47,020
Chúng tôi đang đi ra khỏi kinh doanh.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END PLAYBACK]

