1
00:00:00,000 --> 00:00:02,970
>> [Speel van musiek]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> David J. MALAN: Goed.

4
00:00:15,700 --> 00:00:18,832
Dit is CS50, en dit
is die begin van Week 2.

5
00:00:18,832 --> 00:00:21,040
En jy sal dit oor te herroep
Die afgelope paar weke,

6
00:00:21,040 --> 00:00:24,490
Ons het al die bekendstelling van die rekenaar
wetenskap en het op sy beurt, programmering.

7
00:00:24,490 --> 00:00:27,640
>> En ons het die storie by wyse van
Kras, wat grafiese taal

8
00:00:27,640 --> 00:00:28,990
van MIT se media Lab.

9
00:00:28,990 --> 00:00:30,780
En dan meer onlangs,
verlede week, het ons

10
00:00:30,780 --> 00:00:34,450
stel 'n higher-- n
laer-vlak taal bekend

11
00:00:34,450 --> 00:00:36,770
soos C, iets wat suiwer tekstuele.

12
00:00:36,770 --> 00:00:39,440
En, inderdaad, laaste keer dat ons
verken binne daardie konteks

13
00:00:39,440 --> 00:00:40,450
'n aantal konsepte.

14
00:00:40,450 --> 00:00:43,010
>> Dit, onthou, was die heel
eerste program het ons gekyk na.

15
00:00:43,010 --> 00:00:45,710
En hierdie program, eenvoudig,
druk uit, "Hallo, wêreld."

16
00:00:45,710 --> 00:00:47,730
Maar daar is so baie
oënskynlike magie aangaan.

17
00:00:47,730 --> 00:00:51,460
Daar is dié # include
met hierdie hoek tussen hakies.

18
00:00:51,460 --> 00:00:52,170
Daar is Int.

19
00:00:52,170 --> 00:00:53,020
Daar is (void).

20
00:00:53,020 --> 00:00:56,330
Daar is tussen hakies, krullerige draadjies,
semi-dubbele punte, en soveel meer.

21
00:00:56,330 --> 00:00:58,480
>> En so, onthou dat
ons bekendgestel Scratch

22
00:00:58,480 --> 00:01:02,110
sodat ons kan, verkieslik, sien verby
dat sintaksis, die dinge wat regtig nie

23
00:01:02,110 --> 00:01:04,590
alles wat intellektueel
interessante, maar vroeg

24
00:01:04,590 --> 00:01:07,700
is, absoluut, 'n bietjie lastig
om te draai jou gedagtes rondom.

25
00:01:07,700 --> 00:01:10,860
En, inderdaad, een van die mees algemene
dinge vroeg in 'n programmeertaal klas,

26
00:01:10,860 --> 00:01:13,443
veral vir diegene wat minder
gemaklik, is om ontslae te gefrustreerd deur

27
00:01:13,443 --> 00:01:17,460
en geskakel deur sekere sintaktiese
foute, nie om logiese foute te noem.

28
00:01:17,460 --> 00:01:19,800
En so tussen ons doelwitte
vandag, in werklikheid, sal

29
00:01:19,800 --> 00:01:23,280
wees om jou toe te rus met 'n paar
probleemoplossing tegnieke vir hoe

30
00:01:23,280 --> 00:01:26,705
om hulself beter te los probleme
in die vorm van debugging.

31
00:01:26,705 --> 00:01:29,330
En jy sal onthou ook dat die
omgewing wat ons bekendgestel

32
00:01:29,330 --> 00:01:31,780
laaste keer genoem CS50 IO.

33
00:01:31,780 --> 00:01:34,850
Dit is web-gebaseerde sagteware wat
kan 'n program in die wolk,

34
00:01:34,850 --> 00:01:38,450
om so te praat, terwyl al jou
lêers tesame, as ons weer vandag.

35
00:01:38,450 --> 00:01:41,480
En onthou dat ons
herbesoek hierdie onderwerpe hier,

36
00:01:41,480 --> 00:01:44,480
onder hulle funksies, en loops, en
veranderlikes, en Boolse uitdrukkings,

37
00:01:44,480 --> 00:01:45,110
en voorwaardes.

38
00:01:45,110 --> 00:01:49,190
En eintlik nog 'n paar wat ons
vertaal uit die wêreld van Scratch

39
00:01:49,190 --> 00:01:50,800
om die wêreld van C.

40
00:01:50,800 --> 00:01:53,220
>> Maar die fundamentele gebou
blokke, so te sê,

41
00:01:53,220 --> 00:01:55,150
was regtig nog steeds dieselfde verlede week.

42
00:01:55,150 --> 00:01:57,900
Trouens, ons regtig net 'n
verskillende legkaart stuk, as jy wil.

43
00:01:57,900 --> 00:02:00,300
In plaas van dat pers
red blok, ons plaas

44
00:02:00,300 --> 00:02:02,940
het printf, wat
hierdie funksie in C wat

45
00:02:02,940 --> 00:02:05,890
laat jou toe om iets te druk
en formateer dit op die skerm.

46
00:02:05,890 --> 00:02:07,950
Ons lei die CS50
Biblioteek, waar jy

47
00:02:07,950 --> 00:02:11,420
het nou tot jou beskikking get_char,
en get_int, en get_string,

48
00:02:11,420 --> 00:02:14,610
en 'n paar ander funksies soos
Wel, via wat jy kan kry insette

49
00:02:14,610 --> 00:02:16,260
uit eie sleutelbord van die gebruiker.

50
00:02:16,260 --> 00:02:20,640
So het ons dan ook 'n blik op dinge
soos these- Bool, en kar,

51
00:02:20,640 --> 00:02:22,490
en dubbel, vlot,
int, long_long string.

52
00:02:22,490 --> 00:02:25,170
En daar is selfs ander soorte data in C.

53
00:02:25,170 --> 00:02:28,560
>> Met ander woorde, as jy verklaar
'n veranderlike om 'n paar waarde te stoor,

54
00:02:28,560 --> 00:02:32,600
of wanneer jy implementeer 'n funksie
wat terug 'n bietjie waarde,

55
00:02:32,600 --> 00:02:35,290
jy kan wat spesifiseer
tipe waarde wat.

56
00:02:35,290 --> 00:02:37,310
Is dit 'n string, soos 'n
volgorde van die karakters?

57
00:02:37,310 --> 00:02:39,490
Is dit 'n nommer, soos 'n heelgetal?

58
00:02:39,490 --> 00:02:41,390
Is dit 'n drywende punt
waarde, en dies meer?

59
00:02:41,390 --> 00:02:46,180
So in C, in teenstelling met nuuts af, het ons eintlik
begin om te spesifiseer watter soort data

60
00:02:46,180 --> 00:02:48,330
ons terugkeer of die gebruik van.

61
00:02:48,330 --> 00:02:51,910
>> Maar, natuurlik, ons het ook in
sommige fundamentele grense van die rekenaar.

62
00:02:51,910 --> 00:02:54,100
En in die besonder,
hierdie taal C, onthou

63
00:02:54,100 --> 00:02:57,070
dat ons het 'n blik op
heelgetal oorloop, die werklikheid

64
00:02:57,070 --> 00:03:00,460
As jy net 'n
eindige hoeveelheid geheue

65
00:03:00,460 --> 00:03:04,600
of, in die besonder, 'n beperkte aantal
bisse, kan jy net tel so hoog.

66
00:03:04,600 --> 00:03:08,460
En so het ons gekyk na die voorbeeld hier
waardeur 'n toonbank in 'n vliegtuig,,

67
00:03:08,460 --> 00:03:13,510
eintlik, as lank genoeg hardloop sou
oorloop en lei tot 'n sagteware

68
00:03:13,510 --> 00:03:15,560
'n werklike fisiese potensiaal fout.

69
00:03:15,560 --> 00:03:18,600
>> Ons het ook gekyk na drywende
punt onakkuraatheid, die werklikheid

70
00:03:18,600 --> 00:03:22,280
wat met net 'n beperkte aantal
bisse, of dit nou 32 of 64,

71
00:03:22,280 --> 00:03:27,330
jy kan net spesifiseer soveel nommers
na 'n desimale punt waarna jy

72
00:03:27,330 --> 00:03:29,110
begin vaag te kry.

73
00:03:29,110 --> 00:03:32,360
So byvoorbeeld, een-derde in die
wêreld hier, in ons menslike wêreld,

74
00:03:32,360 --> 00:03:35,360
ons weet, is net 'n oneindige aantal
van 3s nadat die desimale punt.

75
00:03:35,360 --> 00:03:38,820
Maar 'n rekenaar kan nie noodwendig
verteenwoordig 'n oneindige aantal getalle

76
00:03:38,820 --> 00:03:42,590
As jy net toelaat dat dit 'n
eindige hoeveelheid inligting.

77
00:03:42,590 --> 00:03:45,900
>> So nie net het ons toerus
met 'n groter krag in terme

78
00:03:45,900 --> 00:03:49,280
van hoe jy kan druk jouself op
'n sleutelbord in terme van ontwikkeling,

79
00:03:49,280 --> 00:03:51,430
Ons beperk ook wat
jy kan eintlik doen.

80
00:03:51,430 --> 00:03:55,790
En inderdaad, foute en foute kan
ontstaan ​​as gevolg van hierdie soort kwessies.

81
00:03:55,790 --> 00:03:59,900
En inderdaad, onder die onderwerpe vandag
gaan onderwerpe soos ontfouting wees

82
00:03:59,900 --> 00:04:03,699
en eintlik op soek onder die enjinkap
hoe dinge is ingestel verlede week

83
00:04:03,699 --> 00:04:05,490
is eintlik geïmplementeer
sodat jy 'n beter

84
00:04:05,490 --> 00:04:10,530
verstaan ​​beide die vermoëns van en
die beperkings van 'n taal soos C.

85
00:04:10,530 --> 00:04:14,770
>> En in die waarheid, sal ons skil terug die lae
van die eenvoudigste van datastruktuur,

86
00:04:14,770 --> 00:04:17,756
iets genaamd 'n skikking, wat
Kras gebeur met 'n skakel "lys."

87
00:04:17,756 --> 00:04:19,589
Dit is 'n bietjie
anders in daardie konteks.

88
00:04:19,589 --> 00:04:23,340
En dan sal ons ook in te voer een van die
eerste van ons domein-spesifieke probleme

89
00:04:23,340 --> 00:04:26,790
in CS50, die wêreld van
kriptografie, die kuns van die skommeling

90
00:04:26,790 --> 00:04:29,650
of in syfering inligting so
dat jy geheime boodskappe kan stuur

91
00:04:29,650 --> 00:04:34,520
en ontsyfer geheime boodskappe
tussen twee persone, A en B.

92
00:04:34,520 --> 00:04:37,490
>> So voordat ons oorgang
om daardie nuwe wêreld,

93
00:04:37,490 --> 00:04:42,059
Kom ons probeer om jou toe te rus met 'n paar
tegnieke waarmee jy kan skakel

94
00:04:42,059 --> 00:04:43,850
of te verminder ten minste 'n paar
van die frustrasies

95
00:04:43,850 --> 00:04:46,630
dat jy waarskynlik ondervind
oor die afgelope week alleen.

96
00:04:46,630 --> 00:04:50,830
Trouens, voor jy such-- sommige van
jou eerste probleme in C. En die kans is,

97
00:04:50,830 --> 00:04:54,010
As jy soos ek, die eerste keer
jy probeer om uit te voer 'n program,

98
00:04:54,010 --> 00:04:57,330
selfs as jy dink logies
die program is eenvoudig,

99
00:04:57,330 --> 00:05:01,200
jy dalk baie goed getref 'n muur, en
die samesteller is nie van plan om saam te werk.

100
00:05:01,200 --> 00:05:03,940
Maak of klang is nie van plan
om werklik te doen jou bied.

101
00:05:03,940 --> 00:05:05,450
>> En hoekom sou dit wees?

102
00:05:05,450 --> 00:05:07,950
Wel, laat ons 'n blik op,
miskien, 'n eenvoudige program.

103
00:05:07,950 --> 00:05:11,190
Ek gaan om voort te gaan en behalwe hierdie in
'n lêer met opset genoem buggy0.c,

104
00:05:11,190 --> 00:05:13,590
want ek weet dat dit
word gebrekkig in advance.

105
00:05:13,590 --> 00:05:17,400
Maar ek kan nie besef dat as hierdie
is die eerste of tweede of derde program

106
00:05:17,400 --> 00:05:18,830
dat ek eintlik maak myself.

107
00:05:18,830 --> 00:05:23,820
So ek gaan om voort te gaan en
tik, int main (void).

108
00:05:23,820 --> 00:05:28,130
En dan binnekant van my krullerige draadjies,
'n baie bekende ( "hallo, world--

109
00:05:28,130 --> 00:05:30,980
agteroorskuinsstreep, N ") - en 'n kommapunt.

110
00:05:30,980 --> 00:05:32,360
>> Ek het die lêer gestoor.

111
00:05:32,360 --> 00:05:34,850
Nou gaan ek om te gaan
om my terminale venster

112
00:05:34,850 --> 00:05:40,340
en tipe make buggy0, want weer,
die naam van die lêer vandag buggy0.c.

113
00:05:40,340 --> 00:05:43,660
So ek tik te maak buggy0, Tik.

114
00:05:43,660 --> 00:05:48,200
>> En, o, gosh, onthou van verlede tyd
dat geen fout boodskappe is 'n goeie ding.

115
00:05:48,200 --> 00:05:49,740
Sodat daar geen produksie is 'n goeie ding.

116
00:05:49,740 --> 00:05:52,920
Maar hier het ek duidelik
sommige aantal foute.

117
00:05:52,920 --> 00:05:56,470
>> Dus is die eerste lyn van uitset
nadat tik maak buggy0, onthou,

118
00:05:56,470 --> 00:05:59,540
is redelik uitgebreide uitset klang se.

119
00:05:59,540 --> 00:06:02,067
Onder die enjinkap,
CS50 IO is ingestel

120
00:06:02,067 --> 00:06:04,150
'n hele klomp van die gebruik
opsies met hierdie samesteller

121
00:06:04,150 --> 00:06:05,941
sodat jy nie hoef
om te dink oor hulle.

122
00:06:05,941 --> 00:06:08,840
En dit is al wat eerste reël
middel wat begin met klang.

123
00:06:08,840 --> 00:06:11,720
>> Maar daarna het die probleme
begin om hul verskyning maak.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c op lyn 3, karakter
5 Daar is 'n groot, rooi fout.

125
00:06:17,390 --> 00:06:18,380
Wat is dit?

126
00:06:18,380 --> 00:06:23,562
Implisiet verklaar biblioteek funksie
printf met tipe int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Ek bedoel, is dit baie vinnig
kry baie arcane.

129
00:06:28,379 --> 00:06:30,170
En in elk geval, op die eerste
oogopslag, sou ons nie

130
00:06:30,170 --> 00:06:32,380
verwag dat jy die verstaan
geheel van die boodskap.

131
00:06:32,380 --> 00:06:34,213
En so een van die lesse
vir vandag gaan

132
00:06:34,213 --> 00:06:36,919
te wees om te probeer aan om in kennis
patrone, of 'n soortgelyke dinge,

133
00:06:36,919 --> 00:06:38,960
om foute wat jy mag hê
teëgekom in die verlede.

134
00:06:38,960 --> 00:06:41,335
So laat ons net terg uitmekaar
daardie woorde wat vertroud te kyk.

135
00:06:41,335 --> 00:06:44,290
Die groot, rooi fout is duidelik
simbolies van iets verkeerd.

136
00:06:44,290 --> 00:06:47,940
>> implisiet verklaar
biblioteek funksie printf.

137
00:06:47,940 --> 00:06:51,680
So selfs as ek nie heeltemal verstaan ​​wat
implisiet verklaar biblioteek funksie

138
00:06:51,680 --> 00:06:54,900
middel, die probleem sekerlik
betrekking het op een of ander manier printf.

139
00:06:54,900 --> 00:06:59,130
En die bron van die probleem
het te doen met verklaar dit.

140
00:06:59,130 --> 00:07:02,440
>> Waarby 'n funksie is
noem dit vir die eerste keer.

141
00:07:02,440 --> 00:07:06,210
En ons gebruik die terminologie verlede week
verklaar prototipe n funksie se

142
00:07:06,210 --> 00:07:11,860
óf met een lyn aan die bokant van jou
eie lêer of in 'n sogenaamde kop lêer.

143
00:07:11,860 --> 00:07:15,300
En in watter lêer het ons sê
verlede week dat printf is quote,

144
00:07:15,300 --> 00:07:17,080
unquote, verklaar?

145
00:07:17,080 --> 00:07:20,950
In watter lêer is sy prototipe?

146
00:07:20,950 --> 00:07:24,640
>> So as jy onthou, die heel eerste ding wat ek
getikte, byna elke program laaste time--

147
00:07:24,640 --> 00:07:30,790
en per ongeluk 'n oomblik gelede begin
tik myself-- was hierdie een here--

148
00:07:30,790 --> 00:07:38,630
hash-- # include <stio-- vir
toevoer / output-- dot h En inderdaad,

149
00:07:38,630 --> 00:07:41,860
As ek nou hierdie lêer, ek gaan
om voort te gaan en my skerm skoon te maak,

150
00:07:41,860 --> 00:07:44,740
wat jy kan doen deur te tik
Duidelik, of jy kan hou beheer L,

151
00:07:44,740 --> 00:07:47,680
net om jou terminale venster skoon te maak
net 'n paar rommel uit te skakel.

152
00:07:47,680 --> 00:07:51,370
>> Ek gaan om voort te gaan en
Tik weer make buggy0, Tik.

153
00:07:51,370 --> 00:07:53,790
En siedaar, ek sien steeds dat
lang opdrag van klang,

154
00:07:53,790 --> 00:07:55,470
maar daar is geen fout boodskap hierdie tyd.

155
00:07:55,470 --> 00:07:58,800
En inderdaad, as ek dit doen ./buggy0,
net soos die vorige keer,

156
00:07:58,800 --> 00:08:01,860
waar dot beteken dit
gids, Sny net beteken,

157
00:08:01,860 --> 00:08:05,040
hier kom die naam van die program en
daardie naam van die program is buggy0,

158
00:08:05,040 --> 00:08:07,340
Gee, "hallo, wêreld."

159
00:08:07,340 --> 00:08:09,440
>> Nou, hoe kan jy
verkry hierdie oplossing

160
00:08:09,440 --> 00:08:12,017
sonder om noodwendig
erkenning soveel woorde

161
00:08:12,017 --> 00:08:14,350
soos ek gedoen het, beslis, met
gedoen het vir soveel jare?

162
00:08:14,350 --> 00:08:18,720
Wel, besef per die eerste probleem
stel, stel ons jou 'n opdrag

163
00:08:18,720 --> 00:08:21,175
wat eie personeel CS50 se
geskryf genaamd help50.

164
00:08:21,175 --> 00:08:24,300
En inderdaad, C doen spesifikasie vir
die probleem stel oor hoe om dit te gebruik.

165
00:08:24,300 --> 00:08:27,210
>> Maar help50 is in wese
'n program wat personeel CS50 se

166
00:08:27,210 --> 00:08:30,850
geskryf wat jou toelaat om te hardloop
'n opdrag of 'n program,

167
00:08:30,850 --> 00:08:36,169
en as jy nie verstaan ​​nie sy
uitset, om sy produksie te slaag om help50,

168
00:08:36,169 --> 00:08:38,890
op watter punt die sagteware
dat personeel die kursus se geskryf

169
00:08:38,890 --> 00:08:42,429
sal kyk na uitset jou program
reël vir reël, karakter deur karakter.

170
00:08:42,429 --> 00:08:46,000
En as ons, die personeel, erken die
fout boodskap wat jy ervaar,

171
00:08:46,000 --> 00:08:50,580
Ons sal probeer om jou uit te lok met 'n paar
retoriese vrae, met 'n paar advies,

172
00:08:50,580 --> 00:08:54,890
baie soos 'n TF of 'n CA of myself
sou doen in die persoon by kantoorure.

173
00:08:54,890 --> 00:08:58,320
>> So kyk na help50 as jy dit nie doen nie
noodwendig 'n probleem te erken.

174
00:08:58,320 --> 00:09:00,790
Maar nie staatmaak op dit
te veel as 'n kruk.

175
00:09:00,790 --> 00:09:03,990
Seker probeer om te verstaan ​​sy
uitset en dan daaruit leer

176
00:09:03,990 --> 00:09:07,571
sodat net een of twee keer doen jy
ooit hardloop help50 vir 'n spesifieke fout

177
00:09:07,571 --> 00:09:08,070
boodskap.

178
00:09:08,070 --> 00:09:10,660
Daarna moet jy in
beter toegerus jouself

179
00:09:10,660 --> 00:09:13,180
om uit te vind wat dit werklik is.

180
00:09:13,180 --> 00:09:14,350
>> Kom ons doen 'n ander hier.

181
00:09:14,350 --> 00:09:20,410
Laat my voort te gaan, en in 'n ander
lêer sal ons hierdie buggy1.c noem.

182
00:09:20,410 --> 00:09:23,110
En in hierdie lêer Ek is
gaan deliberately--

183
00:09:23,110 --> 00:09:26,330
maar voorgee dat ek nie
verstaan ​​wat fout wat ek gemaak het.

184
00:09:26,330 --> 00:09:31,420
>> Ek gaan om voort te gaan en te doen this--
# include, want ek het

185
00:09:31,420 --> 00:09:33,660
my les geleer uit 'n oomblik gelede.

186
00:09:33,660 --> 00:09:36,220
Int main (void), soos voorheen.

187
00:09:36,220 --> 00:09:40,880
En dan hier gaan ek
om te doen string s - get_string.

188
00:09:40,880 --> 00:09:43,770
En onthou van verlede tyd wat
Dit beteken hey, rekenaar,

189
00:09:43,770 --> 00:09:48,280
Gee my 'n veranderlike, noem dit, en
maak die tipe wat veranderlike 'n string

190
00:09:48,280 --> 00:09:50,150
sodat ek kan een of meer woorde te slaan in dit.

191
00:09:50,150 --> 00:09:52,191
>> En dan op die regterkantste
kant van die gelykaanteken

192
00:09:52,191 --> 00:09:54,980
is get_string, wat 'n
funksie in die CS50 biblioteek

193
00:09:54,980 --> 00:09:55,980
wat doen presies dit.

194
00:09:55,980 --> 00:09:59,740
Dit raak 'n funksie en dan
hande dit van regs na links.

195
00:09:59,740 --> 00:10:02,670
So dit gelyk teken beteken nie
"Gelyk" soos ons dalk dink in wiskunde.

196
00:10:02,670 --> 00:10:04,750
Dit beteken opdrag van regs na links.

197
00:10:04,750 --> 00:10:09,640
So dit beteken, neem die tou uit
die gebruiker en stoor dit in art.

198
00:10:09,640 --> 00:10:10,460
>> Nou laat ons dit gebruik.

199
00:10:10,460 --> 00:10:13,820
Laat my nou en gaan voort as 'n tweede
lyn, laat my gaan voort en sê "hallo" -

200
00:10:13,820 --> 00:10:19,330
nie "wêreld" nie, maar "hallo,% s--
wat ons plekhouer, komma s,

201
00:10:19,330 --> 00:10:22,030
wat ons veranderlike,
en dan 'n kommapunt.

202
00:10:22,030 --> 00:10:26,070
So as ek nie skroef te veel
hier, dit lyk soos regte-kode.

203
00:10:26,070 --> 00:10:28,090
>> En my instink is nou om dit saam te stel.

204
00:10:28,090 --> 00:10:30,400
Die lêer genoem buggy1.c.

205
00:10:30,400 --> 00:10:33,770
So ek gaan doen maak buggy1, Tik.

206
00:10:33,770 --> 00:10:36,377
En darn-dit, indien daar nie
selfs meer foute as voorheen.

207
00:10:36,377 --> 00:10:38,210
Ek bedoel, daar is meer
foutboodskappe dit sou

208
00:10:38,210 --> 00:10:40,400
lyk as werklike lyne in hierdie program.

209
00:10:40,400 --> 00:10:42,730
>> Maar die afhaal hier is,
selfs as jy oorweldig is

210
00:10:42,730 --> 00:10:45,040
met twee of drie of
vier fout boodskappe,

211
00:10:45,040 --> 00:10:48,340
fokus altyd op die baie
eerste van die boodskappe.

212
00:10:48,340 --> 00:10:52,220
As ons kyk na die top-mees een,
blaai terug as dit nodig sou wees.

213
00:10:52,220 --> 00:10:53,930
So hier het ek getik maak buggy1.

214
00:10:53,930 --> 00:10:55,700
Hier is wat klang uitset as wat verwag is.

215
00:10:55,700 --> 00:10:57,290
>> En hier is die eerste rooi fout.

216
00:10:57,290 --> 00:11:02,370
Gebruik van onverklaarde identifiseerder
string, het ek bedoel standaard in?

217
00:11:02,370 --> 00:11:04,260
So standaard in is
eintlik iets anders.

218
00:11:04,260 --> 00:11:06,240
Dit verwys na die gebruiker se
sleutelbord, in wese.

219
00:11:06,240 --> 00:11:08,080
>> Maar dis nie wat ek bedoel.

220
00:11:08,080 --> 00:11:11,770
Ek bedoel string, en ek bedoel get_string.

221
00:11:11,770 --> 00:11:16,200
So, wat is dit wat ek
vergeet om hierdie tyd te doen?

222
00:11:16,200 --> 00:11:20,230
Wat ontbreek hierdie tyd?

223
00:11:20,230 --> 00:11:23,600
Ek het my # include,
so ek het toegang tot printf.

224
00:11:23,600 --> 00:11:26,090
>> Maar wat ek het nie
toegang tot net nog nie?

225
00:11:26,090 --> 00:11:29,420
Wel, net soos die vorige keer,
Ek moet die samesteller vertel

226
00:11:29,420 --> 00:11:31,691
Klang wat hierdie funksies is.

227
00:11:31,691 --> 00:11:33,940
Get_string kom nie
met C. En in die besonder, is dit

228
00:11:33,940 --> 00:11:38,160
kom nie in die
header lêer,.

229
00:11:38,160 --> 00:11:40,770
Dit kom in plaas in
iets wat die personeel het,

230
00:11:40,770 --> 00:11:44,176
wat is 'n ander lêer
noem maar welverdiende naam.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> So eenvoudig deur die toevoeging dat 'n reël
van code-- herroeping van die vorige keer

233
00:11:50,861 --> 00:11:53,610
dat wanneer klang loop, gaan dit
om te kyk na my kode bo na onder,

234
00:11:53,610 --> 00:11:54,193
links na regs.

235
00:11:54,193 --> 00:11:57,200
Dit gaan aan om in kennis,
Ag, wil jy.

236
00:11:57,200 --> 00:11:59,900
Laat my gaan en vind dat,
waar dit op die bediener,

237
00:11:59,900 --> 00:12:03,090
kopieer en plak dit in wese,
in die top van jou eie lêer

238
00:12:03,090 --> 00:12:06,820
sodat op hierdie punt in die verhaal,
lyn 1, die res van die program

239
00:12:06,820 --> 00:12:11,651
kan inderdaad gebruik enige van die funksies
daarin, onder hulle get_string.

240
00:12:11,651 --> 00:12:13,650
So ek gaan om te ignoreer
die res van die foute,

241
00:12:13,650 --> 00:12:17,190
want ek inderdaad vermoed dat slegs
die eerste een eintlik saak gemaak.

242
00:12:17,190 --> 00:12:20,780
En ek gaan voort en tik gaan,
na my lêer spaar maak buggy1.

243
00:12:20,780 --> 00:12:22,580
En siedaar, dit werk begin.

244
00:12:22,580 --> 00:12:29,200
En as ek doen ./buggy1 en tik in, vir
Byvoorbeeld, Zamyla, ek sal nou hallo te kry,

245
00:12:29,200 --> 00:12:32,000
Zamyla, in plaas van hallo, wêreld.

246
00:12:32,000 --> 00:12:32,550
>> Alles reg.

247
00:12:32,550 --> 00:12:35,890
So het die wegneemetes hier dan is om,
een, probeer om so veel as wat jy kan optel

248
00:12:35,890 --> 00:12:39,140
vanaf alleen die fout boodskappe, soek
by 'n paar van die herkenbare woorde.

249
00:12:39,140 --> 00:12:43,070
Behalwe dat, gebruik help50 per
die probleem stel spesifikasie.

250
00:12:43,070 --> 00:12:46,500
Maar behalwe dat ook altyd kyk
aan die bokant fout nie, ten minste

251
00:12:46,500 --> 00:12:50,051
aanvanklik, om te sien watter inligting
Dit kan eintlik oplewer.

252
00:12:50,051 --> 00:12:52,300
Maar dit blyk daar is
selfs meer funksies gebou

253
00:12:52,300 --> 00:12:55,030
in die CS50 biblioteek te help
jy vroeg in die semester

254
00:12:55,030 --> 00:12:57,580
en vroeg in programmering
uit te vind wat verkeerd gaan.

255
00:12:57,580 --> 00:12:59,840
So kom ons doen nog 'n voorbeeld hier.

256
00:12:59,840 --> 00:13:04,350
Ek gaan hierdie buggy2 noem, wat,
weer gaan word gebrekkig uit

257
00:13:04,350 --> 00:13:05,650
van die hek, deur ontwerp.

258
00:13:05,650 --> 00:13:09,980
>> En ek gaan om voort te gaan
en doen # include.

259
00:13:09,980 --> 00:13:12,580
En dan gaan ek int main (void) doen.

260
00:13:12,580 --> 00:13:14,840
En dan gaan ek 'n doen vir lus.

261
00:13:14,840 --> 00:13:16,690
Vir (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
Ek is minder as of gelyk aan 10.

263
00:13:18,750 --> 00:13:24,260
I ++, en dan tussen krulhakies, ek gaan
om uit te druk net 'n hashtag simbool hier

264
00:13:24,260 --> 00:13:25,920
en 'n nuwe lyn karakter.

265
00:13:25,920 --> 00:13:29,220
>> So my bedoeling met hierdie
program is eenvoudig

266
00:13:29,220 --> 00:13:33,150
10 keer Itereer
en op elke iterasie

267
00:13:33,150 --> 00:13:35,260
van daardie lus elke keer
deur die siklus,

268
00:13:35,260 --> 00:13:37,660
druk 'n hashtag,
'n hashtag, 'n hashtag.

269
00:13:37,660 --> 00:13:40,480
Een per lyn, want ek
het die nuwe lyn is daar.

270
00:13:40,480 --> 00:13:42,787
En onthou dat die vir
lus, per laaste week--

271
00:13:42,787 --> 00:13:44,620
en jy sal meer kry
vertroud te wees met die sintaks

272
00:13:44,620 --> 00:13:47,170
deur dit met die praktyk
voordat long-- gee hierdie my

273
00:13:47,170 --> 00:13:49,740
'n veranderlike genaamd ek en sit dit aan 0.

274
00:13:49,740 --> 00:13:52,650
>> Dit vermeerderings ek op
elke iterasie deur 1.

275
00:13:52,650 --> 00:13:54,940
So ek gaan tot 1 tot 2 tot 3.

276
00:13:54,940 --> 00:13:57,690
En dan hierdie toestand in die
middel tussen die semi-dubbelpunte

277
00:13:57,690 --> 00:14:03,010
kry nagegaan op elke iterasie te maak
seker dat ons nog binne die omvang.

278
00:14:03,010 --> 00:14:06,830
So ek wil 10 maal Itereer, so ek
het soort van 'n baie intuïtief net

279
00:14:06,830 --> 00:14:09,070
sit 10 as my bogrens daar.

280
00:14:09,070 --> 00:14:14,310
>> En tog, toe ek hierdie hardloop, nadat
die opstel van dit met make buggy2--

281
00:14:14,310 --> 00:14:15,440
en dit stel OK.

282
00:14:15,440 --> 00:14:17,980
So ek het nie 'n
sintaksfout hierdie tyd.

283
00:14:17,980 --> 00:14:20,940
Laat my tog gaan voort
en hardloop buggy2, Tik.

284
00:14:20,940 --> 00:14:22,620
En nou Scroll up.

285
00:14:22,620 --> 00:14:24,890
En laat ek verhoog
die grootte van die venster.

286
00:14:24,890 --> 00:14:33,720
>> Dit lyk asof ek het 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Daar is dus 11 hashtags, selfs al
Ek duidelik gestel 10 binnekant van hierdie lus.

288
00:14:38,891 --> 00:14:42,140
Nou, 'n paar van wat jy dalk dadelik sien
wat die fout is omdat, ja, dit

289
00:14:42,140 --> 00:14:43,720
is nie 'n baie harde fout te maak.

290
00:14:43,720 --> 00:14:46,070
Maar dit is baie algemeen
baie vroeg op gemaak.

291
00:14:46,070 --> 00:14:49,820
>> Wat ek wil uitwys, al is,
is, hoe kan ek uitvind dit uit?

292
00:14:49,820 --> 00:14:52,300
Wel, dit blyk dat
die CS50 biblioteek kom

293
00:14:52,300 --> 00:14:55,380
met nie net get_string en get_int
en get_float en ander funksies.

294
00:14:55,380 --> 00:14:59,980
Dit kom ook met 'n spesiale funksie
genoem eprintf, of, fout printf.

295
00:14:59,980 --> 00:15:03,270
En dit bestaan ​​uitsluitlik te maak
dit 'n bietjie makliker vir jou

296
00:15:03,270 --> 00:15:06,310
wanneer debugging jou kode om net
druk 'n fout boodskap op die skerm

297
00:15:06,310 --> 00:15:07,850
en weet waar dit vandaan kom.

298
00:15:07,850 --> 00:15:11,000
>> So byvoorbeeld, een ding wat ek mag
doen hier met hierdie funksie is this--

299
00:15:11,000 --> 00:15:20,230
eprintf, en dan gaan ek voort te gaan
en sê ek is nou% i, agteroorskuinsstreep, N.

300
00:15:20,230 --> 00:15:22,330
En ek gaan prop in die waarde van i.

301
00:15:22,330 --> 00:15:25,400
En op die top, want dit
is in die CS50 biblioteek,

302
00:15:25,400 --> 00:15:27,580
Ek gaan om voort te gaan
en sluit

303
00:15:27,580 --> 00:15:29,169
so ek het toegang tot hierdie funksie.

304
00:15:29,169 --> 00:15:31,460
Maar laat ons kyk wat lyn
9 veronderstel is om te doen.

305
00:15:31,460 --> 00:15:32,670
Ek gaan dit uiteindelik verwyder.

306
00:15:32,670 --> 00:15:34,670
Dit het niks te doen
met my oorkoepelende doel te bereik.

307
00:15:34,670 --> 00:15:39,090
Maar eprintf, fout printf, is net bedoel
vir my 'n paar diagnostiese inligting te gee.

308
00:15:39,090 --> 00:15:42,460
Toe ek my program uit te voer, ek wil
sien dit op die skerm tydelik

309
00:15:42,460 --> 00:15:44,550
sowel net om te verstaan
wat gaan aan.

310
00:15:44,550 --> 00:15:47,330
>> En, inderdaad, op elke
iterasie hier van reël 9

311
00:15:47,330 --> 00:15:49,260
Ek wil sien, wat is die waarde van i?

312
00:15:49,260 --> 00:15:50,290
Wat is die waarde van i?

313
00:15:50,290 --> 00:15:51,280
Wat is die waarde van i?

314
00:15:51,280 --> 00:15:55,650
En hopelik kan ek net
sien dat die boodskap ook, 10 keer.

315
00:15:55,650 --> 00:15:57,780
>> So laat ek gaan voort en
heropstel my program,

316
00:15:57,780 --> 00:15:59,905
as ek enige tyd doen
Ek maak 'n verandering. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
En now-- OK.

319
00:16:03,640 --> 00:16:04,820
Daar is 'n baie meer aan die gang.

320
00:16:04,820 --> 00:16:07,610
So laat ek blaai in
'n nog groter venster.

321
00:16:07,610 --> 00:16:10,190
>> En jy sal sien dat elkeen van
die hashtags steeds druk.

322
00:16:10,190 --> 00:16:15,270
Maar in tussen elkeen van hulle is nou hierdie
diagnostiese uitset formaat soos volg.

323
00:16:15,270 --> 00:16:17,960
Die naam van my program hier is buggy2.

324
00:16:17,960 --> 00:16:20,432
Die naam van die lêer is buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Die lyn nommer waaruit
hierdie gedruk is reël 9.

326
00:16:24,080 --> 00:16:27,500
En dan aan die regterkant van wat die
fout boodskap dat ek verwag het nie.

327
00:16:27,500 --> 00:16:30,701
>> En wat is lekker oor hierdie is dat
nou ek het nie noodwendig tel

328
00:16:30,701 --> 00:16:32,200
in my kop wat my program doen.

329
00:16:32,200 --> 00:16:34,240
Ek kan sien dat op die
eerste iterasie Ek is 0,

330
00:16:34,240 --> 00:16:39,420
dan 1, dan 2 dan 3, dan 4, dan
5, dan 6, dan 7, dan 8, dan 9, dan

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
So wag 'n minuut.

333
00:16:42,050 --> 00:16:43,740
Wat gaan hier aan?

334
00:16:43,740 --> 00:16:48,190
Dit lyk asof ek nog tel
soos bedoel tot 10.

335
00:16:48,190 --> 00:16:50,550
>> Maar waar het ek begin?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
So 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- die 11de vinger

338
00:16:58,040 --> 00:16:59,990
is 'n aanduiding van die probleem.

339
00:16:59,990 --> 00:17:02,850
Dit lyk asof ek het getel
verkeerd in my lus.

340
00:17:02,850 --> 00:17:06,599
Eerder as om te gaan 10 iterasies,
Ek begin by 0,

341
00:17:06,599 --> 00:17:09,550
Ek eindig by en deur 10.

342
00:17:09,550 --> 00:17:12,030
Maar omdat, soos 'n rekenaar,
Ek begin toe by 0,

343
00:17:12,030 --> 00:17:15,250
Ek moet tel tot
om, maar nie deur, 10.

344
00:17:15,250 --> 00:17:18,510
>> En so het die oplossing, ek uiteindelik
hier besef, is een van twee dinge.

345
00:17:18,510 --> 00:17:22,430
Ek kan baie eenvoudig sê
tel tot minstens 10.

346
00:17:22,430 --> 00:17:27,260
So 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, wat is inderdaad korrek is,

347
00:17:27,260 --> 00:17:28,900
selfs al is dit klink 'n bietjie verkeerd.

348
00:17:28,900 --> 00:17:35,070
Of ek kon doen minder as of gelyk
tot 9, so lank as ek begin by 0.

349
00:17:35,070 --> 00:17:40,056
Of as jy regtig wil nie dat jy
kan tel tot 10, maar begin by 1.

350
00:17:40,056 --> 00:17:41,680
Maar weereens, dit is net nie so algemeen.

351
00:17:41,680 --> 00:17:43,977
In programming-- hoewel
nie soseer in Scratch--

352
00:17:43,977 --> 00:17:45,810
maar in programmering in
C en ander tale,

353
00:17:45,810 --> 00:17:47,670
soos JavaScript en
Python en ander, is dit

354
00:17:47,670 --> 00:17:49,880
net baie algemeen vir
Die bespreking van binêre

355
00:17:49,880 --> 00:17:53,450
om net te begin tel by die
laagste getal wat jy kan, wat is 0.

356
00:17:53,450 --> 00:17:53,950
Alles reg.

357
00:17:53,950 --> 00:17:55,160
So dit is eprintf.

358
00:17:55,160 --> 00:17:58,600
En weer, noudat ek uitgepluis het my
probleem, en ek gaan om terug te gaan na 0

359
00:17:58,600 --> 00:18:01,470
deur minder as 10, ek gaan
om in te gaan en eprintf verwyder.

360
00:18:01,470 --> 00:18:04,580
>> Dit moet nie daar wees wanneer ek
skip my kode of my kode in te dien

361
00:18:04,580 --> 00:18:05,800
of wys dit aan iemand anders.

362
00:18:05,800 --> 00:18:07,980
Dit is regtig net bedoel
tydelik gebruik word.

363
00:18:07,980 --> 00:18:11,650
Maar nou het ek hierdie vaste
spesifieke probleem so goed.

364
00:18:11,650 --> 00:18:16,780
>> Wel, laat ons doen nog 'n voorbeeld hier
dat ek gaan sweep soos volg.

365
00:18:16,780 --> 00:18:22,850
Ek gaan om voort te gaan en
# include. $ 50

366
00:18:22,850 --> 00:18:25,580
En ek gaan om voort te gaan
en # include.

367
00:18:25,580 --> 00:18:29,030
>> En ek gaan om te spaar
hierdie lêer as buggy3.c.

368
00:18:29,030 --> 00:18:31,740
En ek gaan om voort te gaan
en verklaar int main (void).

369
00:18:31,740 --> 00:18:34,186
En dan binnekant van daar
Ek gaan doen int i _ -

370
00:18:34,186 --> 00:18:36,435
Ek wil 'n program te implementeer
met 'n get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Dit is nie 'n funksie wat nog bestaan.

373
00:18:40,770 --> 00:18:42,870
So ons gaan implementeer
dit in net 'n oomblik.

374
00:18:42,870 --> 00:18:45,541
Maar ons gaan om te sien waarom
dis karretjie op die eerste pas.

375
00:18:45,541 --> 00:18:47,290
En sodra ek gekry
'n int van die gebruiker,

376
00:18:47,290 --> 00:18:53,365
Ek gaan net om% i druk is 'n negatiewe
heelgetal, agteroorskuinsstreep, N, komma, ek.

377
00:18:53,365 --> 00:18:55,240
Met ander woorde, al wat ek
wil hierdie program om te doen

378
00:18:55,240 --> 00:18:58,000
is kry 'n negatiewe int uit
die gebruiker en dan uit te druk

379
00:18:58,000 --> 00:18:59,980
dat so en so is ook 'n negatiewe Int.

380
00:18:59,980 --> 00:19:02,080
>> Nou moet ek om hierdie funksie te implementeer.

381
00:19:02,080 --> 00:19:05,740
So later in my lêer, ek gaan om te gaan
voort en verklaar 'n funksie genoem

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - en ons sal
kom terug na wat daardie lyn weer beteken

383
00:19:10,670 --> 00:19:18,790
in 'n moment-- int N; do-- do
die following-- printf N is :.

384
00:19:18,790 --> 00:19:26,210
En dan gaan ek n doen - get_int,
en doen dit terwyl N groter as 0.

385
00:19:26,210 --> 00:19:28,310
En dan terug N ;.

386
00:19:28,310 --> 00:19:31,730
>> Daar is dus 'n baie gaan op in
hierdie, maar nie een van ons nie gedoen

387
00:19:31,730 --> 00:19:33,710
kyk na verlede week, ten minste kortliks.

388
00:19:33,710 --> 00:19:36,980
So op die lyn 10 hier Ek het verklaar dat 'n
funksie genoem get_negative_int,

389
00:19:36,980 --> 00:19:39,620
en Ek het sit (void), in
hakies, die rede hiervoor is hierdie

390
00:19:39,620 --> 00:19:40,950
nie 'n inset te neem.

391
00:19:40,950 --> 00:19:42,910
Ek is niks verby
om hierdie funksie.

392
00:19:42,910 --> 00:19:44,690
Ek is net om iets terug daaruit.

393
00:19:44,690 --> 00:19:47,270
>> En wat ek hoop om
terug te kry 'n heelgetal is.

394
00:19:47,270 --> 00:19:50,040
Daar is geen tipe data in
C genoem negative_int.

395
00:19:50,040 --> 00:19:52,880
Dis net int, so dit gaan
te wees op ons om seker te maak

396
00:19:52,880 --> 00:19:55,340
dat die waarde wat eintlik
Returned is nie net 'n int

397
00:19:55,340 --> 00:19:56,380
maar is ook negatief.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 Ek is waarby 'n veranderlike
genoem N en maak dit van tipe int.

399
00:20:02,150 --> 00:20:07,500
En dan in lyn 13 deur 18 Ek is
om iets te doen, terwyl iets waar is.

400
00:20:07,500 --> 00:20:11,040
Ek is voor en druk gaan
N is, kolon, en dan 'n spasie,

401
00:20:11,040 --> 00:20:12,800
soos 'n vinnige vir die gebruiker.

402
00:20:12,800 --> 00:20:16,410
>> Ek is dan 'n beroep get_int en
stoor die sogenaamde terugkeer waarde

403
00:20:16,410 --> 00:20:18,130
in daardie veranderlike N.

404
00:20:18,130 --> 00:20:22,600
Maar ek gaan hou doen
dit terwyl N groter as 0.

405
00:20:22,600 --> 00:20:27,960
Met ander woorde, indien die gebruiker gee vir my 'n
int en dat die getal is groter as 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positiewe, ek gaan
hou net reprompting die gebruiker,

407
00:20:31,180 --> 00:20:37,160
hou reprompting, deur hulle te dwing om
saam te werk en gee my 'n negatiewe Int.

408
00:20:37,160 --> 00:20:41,640
>> En sodra N eintlik negative--
veronderstel die gebruiker uiteindelik tipes -50,

409
00:20:41,640 --> 00:20:46,710
dan is dit while lus is nie meer waar
omdat -50 is nie groter as 0.

410
00:20:46,710 --> 00:20:51,140
So breek ons ​​uit daardie
lus logies en terugkeer N.

411
00:20:51,140 --> 00:20:53,520
>> Maar daar is een ander
ding wat ek moet doen.

412
00:20:53,520 --> 00:20:56,190
En ek kan net dit te doen
deur kopieer en plak

413
00:20:56,190 --> 00:20:58,540
een lyn van kode aan die bokant van die lêer.

414
00:20:58,540 --> 00:21:01,630
Ek moet klang leer,
of belowe om klang,

415
00:21:01,630 --> 00:21:04,630
uitdruklik dat Ek wil nie,
inderdaad, gaan en te implementeer

416
00:21:04,630 --> 00:21:06,020
hierdie funksie get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Dit mag dalk net 'n laer in die lêer wees.

418
00:21:07,674 --> 00:21:09,840
Weereens, onthou dat klang
lees dinge bo na onder,

419
00:21:09,840 --> 00:21:12,330
links na regs, sodat jy kan nie
noem 'n funksie as klang

420
00:21:12,330 --> 00:21:15,330
weet nie dit gaan om te bestaan.

421
00:21:15,330 --> 00:21:18,430
>> Nou, ongelukkig, is hierdie program,
soos sommige van julle dalk opgemerk het,

422
00:21:18,430 --> 00:21:19,590
is reeds karretjie.

423
00:21:19,590 --> 00:21:21,400
Laat my gaan voort en maak buggy3.

424
00:21:21,400 --> 00:21:26,904
Dit stel, sodat my probleem is nou nie
'n sintaksfout, soos 'n tekstuele foute,

425
00:21:26,904 --> 00:21:29,570
dit is eintlik van plan om 'n logiese wees
fout wat ek doelbewus

426
00:21:29,570 --> 00:21:32,450
gemaak as 'n geleentheid om
stap vir stap deur wat aangaan.

427
00:21:32,450 --> 00:21:35,540
>> Ek gaan om voort te gaan
nou en hardloop buggy3.

428
00:21:35,540 --> 00:21:37,490
En ek gaan om te gaan
voor en nie saam te werk.

429
00:21:37,490 --> 00:21:39,494
Ek gaan dit gee die nommer 1.

430
00:21:39,494 --> 00:21:41,410
Dit het nie daarvan hou nie, sodat
dit weer te vra vir my.

431
00:21:41,410 --> 00:21:42,147
>> Hoe gaan dit met 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Nie een van dié werk.

435
00:21:44,740 --> 00:21:46,890
Hoe gaan dit -50?

436
00:21:46,890 --> 00:21:48,560
En die program blyk te werk.

437
00:21:48,560 --> 00:21:49,970
>> Laat ek probeer dit weer.

438
00:21:49,970 --> 00:21:53,400
Laat ek probeer -1, blyk te werk.

439
00:21:53,400 --> 00:21:56,380
Laat ek probeer -2, blyk te werk.

440
00:21:56,380 --> 00:21:59,640
Laat ek probeer 0.

441
00:21:59,640 --> 00:22:01,684
Huh, dit is nie korrek nie.

442
00:22:01,684 --> 00:22:03,350
Nou, ons wat hier 'n bietjie pedanties.

443
00:22:03,350 --> 00:22:07,090
Maar dit is inderdaad die geval dat 0
is nie positief nie negatief.

444
00:22:07,090 --> 00:22:11,150
En so het die feit dat my program is
sê dat 0 is 'n negatiewe heelgetal,

445
00:22:11,150 --> 00:22:12,820
dit is nie tegnies korrek.

446
00:22:12,820 --> 00:22:15,180
>> Nou, hoekom is dit om dit te doen?

447
00:22:15,180 --> 00:22:16,270
Wel, dalk is dit voor die hand liggend te wees.

448
00:22:16,270 --> 00:22:18,110
En, inderdaad, die program is
bedoel redelik eenvoudig te wees

449
00:22:18,110 --> 00:22:19,670
so ons het iets om te verken.

450
00:22:19,670 --> 00:22:25,870
>> Maar laat ons voer 'n derde ontfouting
tegniek hier genoem debug50.

451
00:22:25,870 --> 00:22:27,750
So dit is 'n program
dat ons nou net gemaak het

452
00:22:27,750 --> 00:22:30,770
vanjaar genoem debug50
wat sal toelaat dat jy

453
00:22:30,770 --> 00:22:34,130
te gebruik wat bekend as 'n ingeboude
grafiese debugger in CS50 IO.

454
00:22:34,130 --> 00:22:38,400
En 'n debugger is net 'n program wat
oor die algemeen kan jy jou program uit te voer

455
00:22:38,400 --> 00:22:44,050
maar stap vir stap vir stap, lyn
deur reël vir reël, pousering, skeer

456
00:22:44,050 --> 00:22:47,626
rond, op soek na veranderlikes sodat
die program nie net blaas jou verby

457
00:22:47,626 --> 00:22:49,750
en vinnig iets te druk
of nie iets te druk.

458
00:22:49,750 --> 00:22:53,250
Dit gee jou 'n geleentheid, by
menslike spoed, om met dit.

459
00:22:53,250 --> 00:22:55,470
>> En om dit te doen, jy
eenvoudig die volgende doen.

460
00:22:55,470 --> 00:22:58,479
Na die opstel van jou kode,
wat ek reeds gedoen het, buggy3,

461
00:22:58,479 --> 00:23:00,020
jy gaan voort en hardloop debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Soveel soos help50 het jy hardloop
help50 en dan die bevel,

464
00:23:06,760 --> 00:23:10,120
debug50 het jy debug50 hardloop en
dan is die naam van die opdrag.

465
00:23:10,120 --> 00:23:14,440
>> Nou kyk wat gebeur op my skerm,
op die regterkant in die besonder.

466
00:23:14,440 --> 00:23:19,400
Toe ek getref Run, al die
skielike hierdie regterkantste paneel

467
00:23:19,400 --> 00:23:20,419
open op die skerm.

468
00:23:20,419 --> 00:23:22,210
En daar is 'n baie gaan
op die eerste oogopslag.

469
00:23:22,210 --> 00:23:25,110
Maar daar is nie te
veel te bekommer oor nog.

470
00:23:25,110 --> 00:23:28,570
>> Dit is wat my alles
wat gaan aan die binnekant van my program

471
00:23:28,570 --> 00:23:31,130
nou en via hierdie
knoppies op die top is dan

472
00:23:31,130 --> 00:23:35,910
die feit dat ek stap deur my kode
uiteindelik stap vir stap vir stap.

473
00:23:35,910 --> 00:23:37,140
Maar dit is nie net nog nie.

474
00:23:37,140 --> 00:23:38,060
Let op wat gebeur.

475
00:23:38,060 --> 00:23:40,600
Op my terminale venster
Ek word gevra vir n.

476
00:23:40,600 --> 00:23:44,560
En ek gaan om voort te gaan en
saam hierdie tyd en tik -1.

477
00:23:44,560 --> 00:23:48,770
En al is dit 'n bietjie kripties, -1
is 'n negatiewe heelgetal, soos verwag.

478
00:23:48,770 --> 00:23:52,020
>> En dan kind opgewonde met
status 0 GDBserver verlaat.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, is die naam
van die onderliggende sagteware

480
00:23:55,180 --> 00:23:56,620
wat implemente die debugger.

481
00:23:56,620 --> 00:24:00,500
Maar dit alles beteken eintlik, die debugger
weggegaan, want my program op te hou

482
00:24:00,500 --> 00:24:01,710
en al was goed.

483
00:24:01,710 --> 00:24:06,020
As ek wil werklik ontfout my program,
Ek moet preemptively vertel debug50,

484
00:24:06,020 --> 00:24:08,920
Waar kry ek wil om te begin
versterking deur middel van my kode?

485
00:24:08,920 --> 00:24:11,750
>> En miskien die eenvoudigste manier
om dit te doen is soos volg.

486
00:24:11,750 --> 00:24:15,300
As ek Beweeg oor die
geut van my redakteur hier,

487
00:24:15,300 --> 00:24:19,090
so eintlik net in die sidebar hier,
aan die linkerkant van die lyn nommer,

488
00:24:19,090 --> 00:24:21,870
Let daarop dat as ek kliek net
een keer, het ek 'n bietjie rooi dot.

489
00:24:21,870 --> 00:24:24,460
En daardie klein rooi dot,
soos 'n stopstraat, beteken, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, breek uitvoering van my kode
net daar wanneer ek loop hierdie program.

491
00:24:29,430 --> 00:24:30,260
>> So laat ons dit doen.

492
00:24:30,260 --> 00:24:37,340
Laat my gaan voort en hardloop my program
weer met debug50 ./buggy3, Tik.

493
00:24:37,340 --> 00:24:40,110
En nou, kennisgewing, iets
verskillende gebeur.

494
00:24:40,110 --> 00:24:42,440
Ek is nie gevra
nog in my terminale venster

495
00:24:42,440 --> 00:24:45,430
vir enigiets nie, want ek het nie
gekry daar nog in my program.

496
00:24:45,430 --> 00:24:47,950
Let daarop dat op die lyn 8
wat nou na vore,

497
00:24:47,950 --> 00:24:51,720
en daar is 'n bietjie pyl op
links gesegde, maak jy hier gestop.

498
00:24:51,720 --> 00:24:55,030
Hierdie lyn van kode, lyn
8, het nog nie uitgevoer word.

499
00:24:55,030 --> 00:24:58,940
>> En wat is nuuskierig, as ek kyk
hier op die regterkant,

500
00:24:58,940 --> 00:25:03,530
sien dat ek 'n plaaslike
veranderlike, plaaslike in die sin

501
00:25:03,530 --> 00:25:05,450
dat dit in die huidige funksie.

502
00:25:05,450 --> 00:25:08,920
En die waarde daarvan, blykbaar by verstek,
en soort gerieflik, is 0.

503
00:25:08,920 --> 00:25:10,260
Maar ek het nie tik 0.

504
00:25:10,260 --> 00:25:13,410
Dit gebeur net te wees sy
standaard waarde op die oomblik.

505
00:25:13,410 --> 00:25:15,490
>> So laat ek gaan voort en doen dit nou.

506
00:25:15,490 --> 00:25:18,680
Laat my gaan voort en op
die regter boonste hier, ek is

507
00:25:18,680 --> 00:25:20,970
gaan om voort te gaan en
Klik die eerste ikoon wat

508
00:25:20,970 --> 00:25:25,360
beteken stap waaroor beteken nie slaan
dit maar stap oor die lyn van kode,

509
00:25:25,360 --> 00:25:27,770
uitvoering van dit langs die pad.

510
00:25:27,770 --> 00:25:30,710
>> En nou, let op, my
vinnige pas verander.

511
00:25:30,710 --> 00:25:31,380
Hoekom is dit?

512
00:25:31,380 --> 00:25:33,639
Ek het debug50 het,
hardloop hierdie reël van die kode.

513
00:25:33,639 --> 00:25:34,930
Wat beteken hierdie reël van die kode te doen?

514
00:25:34,930 --> 00:25:35,960
Vra my vir 'n int.

515
00:25:35,960 --> 00:25:36,460
OK.

516
00:25:36,460 --> 00:25:37,400
Laat my saam.

517
00:25:37,400 --> 00:25:41,340
Laat my tog gaan voort en tik -1, Tik.

518
00:25:41,340 --> 00:25:42,920
En nou sien wat verander het.

519
00:25:42,920 --> 00:25:46,060
Op die regterkant,
my plaaslike veranderlike i

520
00:25:46,060 --> 00:25:48,200
aangedui as -1 nou.

521
00:25:48,200 --> 00:25:49,810
En dit is nog steeds van tipe int.

522
00:25:49,810 --> 00:25:53,102
>> En Let ook op my sogenaamde
noem stapel, waar het ek breek?

523
00:25:53,102 --> 00:25:54,810
Ons sal meer oor praat
hierdie in die toekoms.

524
00:25:54,810 --> 00:25:58,620
Maar die oproep stapel net verwys na wat
funksies is tans aan die gang.

525
00:25:58,620 --> 00:26:00,040
Op die oomblik is dit net belangrikste.

526
00:26:00,040 --> 00:26:03,590
En nou die enigste plaaslike
veranderlike is ek met 'n waarde van 1.

527
00:26:03,590 --> 00:26:09,840
>> Toe ek uiteindelik stap oor die lyn
hier, met dieselfde ikoon regs bo,

528
00:26:09,840 --> 00:26:11,410
-1 Is 'n negatiewe heelgetal.

529
00:26:11,410 --> 00:26:13,580
Nou is dit pousering oor wat krullerige brace.

530
00:26:13,580 --> 00:26:14,740
Kom ons laat dit sy ding te doen.

531
00:26:14,740 --> 00:26:17,300
Ek stap oor die lyn, en voila.

532
00:26:17,300 --> 00:26:20,240
>> So nie alles wat vreeslik
verhelderend nie,

533
00:26:20,240 --> 00:26:23,550
maar dit het my laat stilstaan
en deurdink logies

534
00:26:23,550 --> 00:26:24,870
wat hierdie program is om te doen.

535
00:26:24,870 --> 00:26:26,890
Maar dit was nie die verkeerde saak.

536
00:26:26,890 --> 00:26:28,510
Kom ons doen dit weer soos volg.

537
00:26:28,510 --> 00:26:31,340
>> Ek gaan dit breekpunt verlaat
On line 8 met die rooi dot.

538
00:26:31,340 --> 00:26:32,830
Ek gaan debug50 tik.

539
00:26:32,830 --> 00:26:34,400
Dit is hier outomaties gestop.

540
00:26:34,400 --> 00:26:37,660
Maar hierdie keer, in plaas van
versterking oor hierdie lyn,

541
00:26:37,660 --> 00:26:42,290
laat my eintlik gaan binne
get_negative_int en uit te vind,

542
00:26:42,290 --> 00:26:45,530
Hoekom is dit die aanvaarding van 0 as 'n geldige antwoord?

543
00:26:45,530 --> 00:26:47,990
>> So in plaas van te kliek stap oor.

544
00:26:47,990 --> 00:26:50,630
Ek gaan om voort te gaan
en klik Stap in.

545
00:26:50,630 --> 00:26:54,030
En sien dat die lyn 8 dis
nou uitgelig nou skielik

546
00:26:54,030 --> 00:26:56,900
raak lyn 17.

547
00:26:56,900 --> 00:26:59,947
>> Nou, dit is nie dat die debugger
het oorgeslaan lyne 14 en 15 en 16.

548
00:26:59,947 --> 00:27:01,780
Dis net daar is niks
om jou daar te sien.

549
00:27:01,780 --> 00:27:04,050
Dit is net te verklaar veranderlikes,
En dan is daar die woord Doen

550
00:27:04,050 --> 00:27:05,390
en dan 'n oop krullerige brace.

551
00:27:05,390 --> 00:27:09,227
Die enigste funksionele lyn wat
sappige is regtig hierdie een hier, 17.

552
00:27:09,227 --> 00:27:11,060
En dit is waar ons het
outomaties gestop.

553
00:27:11,060 --> 00:27:13,870
>> So printf ( "n.is:") ;, so
wat nog nie gebeur het nie.

554
00:27:13,870 --> 00:27:18,250
So laat ons gaan voort en klik stap oor.

555
00:27:18,250 --> 00:27:20,326
Nou is my vinnige, inderdaad,
verander na ( "N is:").

556
00:27:20,326 --> 00:27:22,450
Nou get_int, ek gaan nie
pla versterking in,

557
00:27:22,450 --> 00:27:24,750
want daardie funksie was
gemaak deur CS50 in die Biblioteek.

558
00:27:24,750 --> 00:27:25,750
Dit is vermoedelik korrek is.

559
00:27:25,750 --> 00:27:28,440
>> So ek gaan om voort te gaan en
soort van saam deur dit

560
00:27:28,440 --> 00:27:30,590
'n int, maar nie 'n negatiewe Int.

561
00:27:30,590 --> 00:27:32,870
So laat ek gaan voort en tref 0.

562
00:27:32,870 --> 00:27:39,460
En nou wat gebeur hier
wanneer ek af te reël 21?

563
00:27:39,460 --> 00:27:40,890
Ek het nie weer herhaal.

564
00:27:40,890 --> 00:27:43,320
Ek het nie blyk te wees vas in wat lus.

565
00:27:43,320 --> 00:27:45,990
Met ander woorde, hierdie geel
bar nie voort te gaan rond,

566
00:27:45,990 --> 00:27:47,130
en rondom, en rondom.

567
00:27:47,130 --> 00:27:48,340
>> Nou, hoekom is dit?

568
00:27:48,340 --> 00:27:49,920
Wel, N, wat N nou?

569
00:27:49,920 --> 00:27:53,280
Ek kan kyk na die plaaslike
veranderlikes in die debugger.

570
00:27:53,280 --> 00:27:53,816
N is 0.

571
00:27:53,816 --> 00:27:55,190
Goed, wat was my toestand?

572
00:27:55,190 --> 00:27:58,700
>> 20-- lyn 20 is, wel,
0 groter as 0.

573
00:27:58,700 --> 00:27:59,500
Dit is nie waar nie.

574
00:27:59,500 --> 00:28:01,020
0 is nie groter as 0.

575
00:28:01,020 --> 00:28:02,820
En so het ek gebreek uit hierdie.

576
00:28:02,820 --> 00:28:06,370
>> En so dit is hoekom op die lyn
21 As ek eintlik voortgaan,

577
00:28:06,370 --> 00:28:10,370
Ek gaan terug 0, selfs
al sou ek ook verwerp 0

578
00:28:10,370 --> 00:28:12,484
as nie eintlik negatief.

579
00:28:12,484 --> 00:28:14,650
So nou, ek het nie regtig selfs
omgee vir die debugger.

580
00:28:14,650 --> 00:28:16,900
Het jy dit, ek hoef nie
weet wat meer aan die gang is.

581
00:28:16,900 --> 00:28:19,233
>> So ek gaan om voort te gaan en
kliek net op die knoppie Speel,

582
00:28:19,233 --> 00:28:20,240
en laat dit klaarmaak.

583
00:28:20,240 --> 00:28:23,440
Nou, ek het besef dat my
fout is blykbaar op die lyn 20.

584
00:28:23,440 --> 00:28:25,160
Dit is my logiese fout.

585
00:28:25,160 --> 00:28:28,100
>> En so Wat wil ek
om te doen om dit te verander?

586
00:28:28,100 --> 00:28:32,500
As die probleem is dat ek nie
vang 0, dit is net 'n logiese fout.

587
00:28:32,500 --> 00:28:35,910
En ek kan sê, terwyl N is
groter as of gelyk aan 0,

588
00:28:35,910 --> 00:28:38,330
hou weer en weer waarna die gebruiker.

589
00:28:38,330 --> 00:28:41,050
>> So, weereens, eenvoudige fout, miskien
selfs voor die hand liggend as jy my sien

590
00:28:41,050 --> 00:28:42,410
skryf dit net 'n paar minute gelede.

591
00:28:42,410 --> 00:28:44,570
Maar die afhaal hier
is dat met debug 50,

592
00:28:44,570 --> 00:28:46,850
en met ontfouting
sagteware meer algemeen,

593
00:28:46,850 --> 00:28:51,370
jy het hierdie nuwe gevind krag tot
loop deur jou eie kode, kyk

594
00:28:51,370 --> 00:28:55,590
via dat regterhand paneel wat
jou veranderlikes waardes is.

595
00:28:55,590 --> 00:28:57,700
So jy hoef nie noodwendig
iets te gebruik

596
00:28:57,700 --> 00:29:00,630
soos jy eprintf om daardie waardes te druk.

597
00:29:00,630 --> 00:29:04,430
Jy kan dit eintlik sien
visueel op die skerm.

598
00:29:04,430 --> 00:29:08,920
>> Nou, as hierdie, dit is opmerklik
dat daar 'n ander tegniek wat

599
00:29:08,920 --> 00:29:09,890
eintlik super algemeen.

600
00:29:09,890 --> 00:29:13,120
En jy kan dalk wonder waarom hierdie klein
man hier is op die verhoog gesit.

601
00:29:13,120 --> 00:29:16,490
Daar is dus hierdie tegniek, oor die algemeen
bekend as rubberboot ontfouting,

602
00:29:16,490 --> 00:29:18,786
wat eintlik net 'n
getuig van die feit

603
00:29:18,786 --> 00:29:20,660
wat dikwels as programmeerders
skryf kode,

604
00:29:20,660 --> 00:29:22,650
hulle is nie noodwendig
saam met ander,

605
00:29:22,650 --> 00:29:24,030
of besig om in 'n gedeelde omgewing.

606
00:29:24,030 --> 00:29:25,050
>> Hulle is soort van die huis af.

607
00:29:25,050 --> 00:29:25,910
Miskien is dit laat in die nag.

608
00:29:25,910 --> 00:29:28,190
Hulle het probeer om figuur
'n paar fout in hul kode.

609
00:29:28,190 --> 00:29:29,330
En hulle is net nie sien nie.

610
00:29:29,330 --> 00:29:30,329
>> En daar is geen kamermaat.

611
00:29:30,329 --> 00:29:31,250
Daar is geen TF.

612
00:29:31,250 --> 00:29:32,680
Daar is geen CA rond.

613
00:29:32,680 --> 00:29:36,440
Al wat hulle op hul rak
is hierdie klein rubber snoes.

614
00:29:36,440 --> 00:29:39,030
>> En so rubberboot ontfouting
is net hierdie uitnodiging

615
00:29:39,030 --> 00:29:42,780
om te dink aan iets soos dom
aangesien dit as 'n ware wese,

616
00:29:42,780 --> 00:29:46,940
en eintlik loop deur jou kode
mondelings by hierdie lewelose voorwerp.

617
00:29:46,940 --> 00:29:49,230
So, byvoorbeeld, as
dit is my voorbeeld here--

618
00:29:49,230 --> 00:29:52,470
en onthou dat vroeër
die probleem was hierdie,

619
00:29:52,470 --> 00:29:58,140
As ek hierdie eerste reël van die kode te verwyder,
en ek gaan voort en maak karretjie 0 weer,

620
00:29:58,140 --> 00:30:01,220
onthou dat ek hierdie
foutboodskappe hier.

621
00:30:01,220 --> 00:30:05,997
Dus is die idee hier, belaglik maar ek
voel op die oomblik om dit te doen in die openbaar,

622
00:30:05,997 --> 00:30:06,580
is die fout.

623
00:30:06,580 --> 00:30:10,910
>> OK, so my probleem is dat ek
implisiet verklaar 'n biblioteek funksie.

624
00:30:10,910 --> 00:30:12,610
En dit biblioteek funksie is printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, verklaar
herinner my aan prototipes.

626
00:30:15,290 --> 00:30:18,930
>> Dit beteken dat ek moet eintlik
vertel die samesteller vooraf wat

627
00:30:18,930 --> 00:30:19,980
die funksie lyk.

628
00:30:19,980 --> 00:30:20,930
Wag 'n minuut.

629
00:30:20,930 --> 00:30:23,580
Ek het nie 'n standaard io.h.

630
00:30:23,580 --> 00:30:24,530
Baie dankie.

631
00:30:24,530 --> 00:30:27,330
>> Dus net hierdie proses of-- jy
hoef nie eintlik 'n eend.

632
00:30:27,330 --> 00:30:29,819
Maar hierdie idee van die loop
jouself deur jou eie kode

633
00:30:29,819 --> 00:30:31,610
sodat jy selfs hoor
jouself, sodat jy

634
00:30:31,610 --> 00:30:35,620
besef weglatings in jou eie
opmerkings, is oor die algemeen die idee.

635
00:30:35,620 --> 00:30:38,910
>> En, miskien meer logies, nie so
veel met wat 'n mens maar hoe meer betrokke

636
00:30:38,910 --> 00:30:44,220
Byvoorbeeld ons nou net gedoen het in karretjie 3.c,
jy dalk jouself deur hardloop

637
00:30:44,220 --> 00:30:45,310
soos volg.

638
00:30:45,310 --> 00:30:49,190
So was dan al reg, rubber
snoes, DDB, as jy wil.

639
00:30:49,190 --> 00:30:52,350
Hier het ons in my hooffunksie,
Ek bel kry negatiewe Int.

640
00:30:52,350 --> 00:30:54,660
>> En ek kry die terugkeer waarde.

641
00:30:54,660 --> 00:31:00,410
Ek is dit stoor op die linkerkant
On line 8 in 'n veranderlike genaamd i.

642
00:31:00,410 --> 00:31:02,380
OK, maar om te wag, hoe het
wat kry wat waarde?

643
00:31:02,380 --> 00:31:04,130
Laat my kyk na die funksie in lyn 12.

644
00:31:04,130 --> 00:31:05,760
>> In lyn 12, ons het kry negatiewe Int.

645
00:31:05,760 --> 00:31:08,190
Maak enige insette nie neem,
beteken terugkeer 'n int, OK.

646
00:31:08,190 --> 00:31:10,929
Ek verklaar op lyn 14 'n veranderlike N.

647
00:31:10,929 --> 00:31:12,220
Dit gaan 'n heelgetal te stoor.

648
00:31:12,220 --> 00:31:13,760
Dit is wat ek wil hê.

649
00:31:13,760 --> 00:31:18,480
>> So doen die volgende terwyl N is-- laat
my ongedaan te maak wat die fix ek reeds gemaak.

650
00:31:18,480 --> 00:31:22,710
Dus, terwyl N groter is as
0, druk N is, OK.

651
00:31:22,710 --> 00:31:25,170
En dan noem ontslae int gestoor in n.

652
00:31:25,170 --> 00:31:30,160
En dan kyk of n '0,
N is not-- daar is dit.

653
00:31:30,160 --> 00:31:31,910
So, weer, het jy nie
moet die werklike eend.

654
00:31:31,910 --> 00:31:35,650
Maar net loop jouself deur middel van
jou kode as 'n intellektuele oefening

655
00:31:35,650 --> 00:31:37,720
sal dikwels help
besef wat aangaan,

656
00:31:37,720 --> 00:31:41,170
in teenstelling met net om iets te doen
soos hierdie, staar na die skerm,

657
00:31:41,170 --> 00:31:43,720
en praat nie jouself deur middel van
dit wat eerlik is nie

658
00:31:43,720 --> 00:31:46,270
naastenby so 'n effektiewe tegniek.

659
00:31:46,270 --> 00:31:48,620
So daar het jy dit, 'n
aantal verskillende tegnieke

660
00:31:48,620 --> 00:31:52,102
vir eintlik ontfouting jou kode
en berispe, wat almal

661
00:31:52,102 --> 00:31:54,810
moet wees gereedskap in jou toolkit
sodat jy nie laat in die nag,

662
00:31:54,810 --> 00:31:57,660
veral, is jy in die eetkamer
sale, of by kantoorure,

663
00:31:57,660 --> 00:32:00,368
gebons jou kop teen die
muur, probeer om 'n probleem op te los.

664
00:32:00,368 --> 00:32:02,020
Besef dat daar sagteware gereedskap.

665
00:32:02,020 --> 00:32:03,720
Daar is rubberboot gereedskap.

666
00:32:03,720 --> 00:32:09,630
En daar is 'n hele personeel van
ondersteun wag om hand by te sit.

667
00:32:09,630 --> 00:32:13,120
>> So nou, 'n woord oor die probleem
stelle, en op wat ons julle hoop

668
00:32:13,120 --> 00:32:15,620
kry uit hulle, en hoe
ons gaan oor die evaluering.

669
00:32:15,620 --> 00:32:17,680
Per leerplan die kursus se
CS50 se probleem stelle

670
00:32:17,680 --> 00:32:22,320
geëvalueer op vier primêre asse, sodat
omvang speak--, korrektheid, ontwerp,

671
00:32:22,320 --> 00:32:23,060
en styl.

672
00:32:23,060 --> 00:32:25,910
En omvang net verwys na hoeveel
van die stuk het jy afgebyt?

673
00:32:25,910 --> 00:32:28,080
Hoeveel van 'n probleem het jy probeer?

674
00:32:28,080 --> 00:32:30,110
Wat is die vlak van inspanning
het jy gemanifesteer?

675
00:32:30,110 --> 00:32:35,750
>> Korrektheid is, doen die program werk as
dit veronderstel is om per CS50 spesifikasie

676
00:32:35,750 --> 00:32:38,640
wanneer jy 'n sekere insette
of sekere uitsette terug te kom?

677
00:32:38,640 --> 00:32:41,130
Ontwerp is die mees subjektiewe van hulle.

678
00:32:41,130 --> 00:32:43,360
En dit is die een wat sal
neem die langste om te leer

679
00:32:43,360 --> 00:32:47,220
en die langste om te leer, in
vir sover dit kom neer op,

680
00:32:47,220 --> 00:32:49,530
hoe goed geskryf is jou kode?

681
00:32:49,530 --> 00:32:52,920
>> Dit is een ding om net te druk die regte
uitsette of die standaard van die reg waardes.

682
00:32:52,920 --> 00:32:55,400
Maar jy doen dit as
doeltreffend as moontlik?

683
00:32:55,400 --> 00:32:58,210
Is jy dit doen kloof
en oorwin, of binêre

684
00:32:58,210 --> 00:33:01,500
soek soos ons binnekort sal sien dat ons het
twee weke gelede met die telefoon boek?

685
00:33:01,500 --> 00:33:04,670
Is daar beter maniere om die los
probleem as wat jy tans het hier?

686
00:33:04,670 --> 00:33:06,380
Dit is 'n geleentheid vir 'n beter ontwerp.

687
00:33:06,380 --> 00:33:08,530
>> En dan style-- hoe
mooi is jou kode?

688
00:33:08,530 --> 00:33:12,370
Jy sal sien dat ek is redelik
veral oor insp my kode,

689
00:33:12,370 --> 00:33:15,300
en om seker te maak my veranderlikes
is redelik genoem. N,

690
00:33:15,300 --> 00:33:19,660
terwyl kort, is 'n goeie naam vir 'n
nommer, ek vir 'n telling heelgetal,

691
00:33:19,660 --> 00:33:20,727
s vir 'n string.

692
00:33:20,727 --> 00:33:22,560
En ons kan langer
veranderlike name styl.

693
00:33:22,560 --> 00:33:25,500
Styl is net hoe goed
beteken jou kode te kyk?

694
00:33:25,500 --> 00:33:26,600
En hoe leesbare is dit?

695
00:33:26,600 --> 00:33:29,650
>> En met verloop van tyd, wat jou Tas
en TFS sal doen in die loop

696
00:33:29,650 --> 00:33:31,870
word u voorsien dat
soort kwalitatiewe terugvoer

697
00:33:31,870 --> 00:33:34,330
sodat jy 'n beter
by die verskeie aspekte.

698
00:33:34,330 --> 00:33:37,510
En in terme van hoe ons
evalueer elk van hierdie asse,

699
00:33:37,510 --> 00:33:40,080
dis tipies met baie min
emmers, sodat jy, oor die algemeen,

700
00:33:40,080 --> 00:33:41,680
kry 'n gevoel van hoe goed jy doen.

701
00:33:41,680 --> 00:33:45,680
En, inderdaad, as jy kry 'n telling op
enige van daardie axes-- korrektheid, ontwerp

702
00:33:45,680 --> 00:33:49,659
en styl especially-- dat die getal
sal oor die algemeen tussen 1 en 5.

703
00:33:49,659 --> 00:33:52,450
En, letterlik, as jy kry
3 se aan die begin van die semester,

704
00:33:52,450 --> 00:33:53,977
dit is 'n baie goeie ding.

705
00:33:53,977 --> 00:33:55,810
Dit beteken daar is nog
ruimte vir verbetering,

706
00:33:55,810 --> 00:33:58,490
wat jy hoop in
Loop klas vir die eerste keer.

707
00:33:58,490 --> 00:34:01,820
Daar is hopelik 'n paar stukkie plafon
waaraan jy streef na die bereiking van.

708
00:34:01,820 --> 00:34:03,970
En so kry 3 se
die vroegste stukke,

709
00:34:03,970 --> 00:34:06,550
Indien nie sowat 2 en 4 se
is inderdaad 'n goeie ding.

710
00:34:06,550 --> 00:34:08,880
Dit is goed binne die omvang,
goed binne verwagtinge.

711
00:34:08,880 --> 00:34:11,421
>> En as jou gedagtes is wedrenne, wag
'n minuut, drie uit vyf.

712
00:34:11,421 --> 00:34:12,620
Dit is regtig 'n 6 uit 10.

713
00:34:12,620 --> 00:34:13,560
Dit is 60%.

714
00:34:13,560 --> 00:34:14,830
My God, dis 'n F.

715
00:34:14,830 --> 00:34:15,870
>> Dit is nie.

716
00:34:15,870 --> 00:34:17,600
Dit is nie, in die feit dat.

717
00:34:17,600 --> 00:34:22,710
Inteendeel, dit is 'n geleentheid om te verbeter
in die loop van die semester.

718
00:34:22,710 --> 00:34:25,580
En as jy kry 'n paar
Poors, dit is 'n geleentheid

719
00:34:25,580 --> 00:34:29,199
om voordeel te trek uit kantoorure,
beslis artikels en ander hulpbronne.

720
00:34:29,199 --> 00:34:32,840
>> Beste is 'n geleentheid, regtig,
trots op hoe ver jy wees

721
00:34:32,840 --> 00:34:34,520
kom in die loop van die semester.

722
00:34:34,520 --> 00:34:38,199
So besef, as daar niks
anders, drie goed.

723
00:34:38,199 --> 00:34:40,179
En dit laat ruimte vir groei met verloop van tyd.

724
00:34:40,179 --> 00:34:43,090
>> Ten opsigte van hoe die asse is
geweegde, realisties jy

725
00:34:43,090 --> 00:34:46,745
gaan die meeste van jou tyd spandeer om
dinge om te werk, wat nog te sê korrek.

726
00:34:46,745 --> 00:34:49,120
En so korrektheid is geneig om
geweeg die meeste, soos met

727
00:34:49,120 --> 00:34:51,360
hierdie multiplikatiewe faktor van drie.

728
00:34:51,360 --> 00:34:54,659
Ontwerp is ook belangrik, maar
iets wat jy noodwendig doen nie

729
00:34:54,659 --> 00:34:58,220
spandeer al daardie ure op
probeer om te kry dinge net om te werk.

730
00:34:58,220 --> 00:35:00,019
>> En so is dit geweeg
'n bietjie meer lig.

731
00:35:00,019 --> 00:35:01,560
En dan styl is die minste geweeg.

732
00:35:01,560 --> 00:35:03,710
Selfs al is dit nie minder
belangrik fundamenteel,

733
00:35:03,710 --> 00:35:05,990
dit is net, miskien, die
maklikste ding om reg te doen,

734
00:35:05,990 --> 00:35:08,440
naboots die voorbeelde wat ons
doen lesing en artikel,

735
00:35:08,440 --> 00:35:11,080
met dinge mooi
ingekeep, en gedraai,

736
00:35:11,080 --> 00:35:14,320
en dies meer is onder die maklikste
dinge om te doen en reg te kry.

737
00:35:14,320 --> 00:35:16,960
So as sodanig, besef
dat diegene is punte

738
00:35:16,960 --> 00:35:19,000
wat relatief maklik om te verstaan.

739
00:35:19,000 --> 00:35:22,360
>> En nou 'n woord op
this-- akademiese eerlikheid.

740
00:35:22,360 --> 00:35:25,150
So per die kursus se
leerplan, sal jy sien

741
00:35:25,150 --> 00:35:27,630
wat die kursus het 'n hele
bietjie van taal om hierdie.

742
00:35:27,630 --> 00:35:31,380
En die kursus neem die kwessie van
akademiese eerlikheid baie ernstig.

743
00:35:31,380 --> 00:35:33,450
>> Ons het die onderskeiding,
vir 'n beter of vir slegter,

744
00:35:33,450 --> 00:35:36,570
dat hy gestuur elke jaar meer
studente vir dissiplinêre optrede

745
00:35:36,570 --> 00:35:39,670
as die meeste ander
Natuurlik, dat ek bewus is van.

746
00:35:39,670 --> 00:35:42,580
Dit is nie noodwendig
'n aanduiding van die feit

747
00:35:42,580 --> 00:35:46,340
dat CS studente, of CS50 studente, is
minder eerlik as jou klasmaats.

748
00:35:46,340 --> 00:35:49,090
Maar die werklikheid dat ons in hierdie
wêreld, elektronies, het ons net

749
00:35:49,090 --> 00:35:50,990
het tegnologiese
beteken van die opsporing van hierdie.

750
00:35:50,990 --> 00:35:53,360
>> Dit is vir ons belangrik vir
regverdigheid regoor die klas

751
00:35:53,360 --> 00:35:58,550
wat ons doen nie opspoor nie, en in te samel
die probleem wanneer ons sien dinge.

752
00:35:58,550 --> 00:36:01,980
En net 'n prentjie verf, en regtig
om iets te help hou hiervan sink in,

753
00:36:01,980 --> 00:36:04,600
dit was hulle getal van
studente oor die afgelope 10 jaar

754
00:36:04,600 --> 00:36:07,610
wat betrokke is in 'n
sulke kwessies van akademiese eerlikheid,

755
00:36:07,610 --> 00:36:10,990
met 'n paar 32 studente
uit val 2015, wat

756
00:36:10,990 --> 00:36:13,760
Dit wil sê dat ons neem
die saak baie ernstig op.

757
00:36:13,760 --> 00:36:18,380
En, uiteindelik, hierdie getalle te komponeer,
mees onlangs, sowat 3%, 4% of so

758
00:36:18,380 --> 00:36:19,120
van die klas.

759
00:36:19,120 --> 00:36:25,220
>> So vir die super meerderheid van studente
blyk dit dat die lyne is duidelik.

760
00:36:25,220 --> 00:36:27,940
Maar moenie Hou dit in
omgee, veral laat

761
00:36:27,940 --> 00:36:32,080
in die nag wanneer sukkel met
sommige oplossing vir 'n probleem stel,

762
00:36:32,080 --> 00:36:34,830
dat daar meganismes
vir die kry jouself beter

763
00:36:34,830 --> 00:36:37,870
ondersteuning as wat jy dalk
dink, selfs teen daardie uur af.

764
00:36:37,870 --> 00:36:40,514
Besef dat wanneer ons ontvang
student voorleggings, steek ons

765
00:36:40,514 --> 00:36:43,430
vergelyk elke voorlegging vanjaar
teen elke voorlegging verlede jaar,

766
00:36:43,430 --> 00:36:47,590
teen elke voorlegging van 2007,
en sedert, kyk na, asook,

767
00:36:47,590 --> 00:36:49,931
-bewaarplekke aanlyn,
gespreksforums, werk webwerwe.

768
00:36:49,931 --> 00:36:51,806
En ons noem dit,
regtig, alles ter wille

769
00:36:51,806 --> 00:36:56,040
van volle bekendmaking, dat indien
iemand anders kan dit aanlyn te vind,

770
00:36:56,040 --> 00:36:57,880
Sekerlik, so kan ons die kursus.

771
00:36:57,880 --> 00:37:00,100
Maar, regtig, die gees
van die kursus kom neer

772
00:37:00,100 --> 00:37:01,650
hierdie klousule in die leerplan.

773
00:37:01,650 --> 00:37:03,670
Dit is regtig net, wees redelik.

774
00:37:03,670 --> 00:37:06,680
>> En as ons het om uit te brei op daardie
met net 'n bietjie meer taal,

775
00:37:06,680 --> 00:37:09,770
besef dat die essensie van alle
werk wat jy aan hierdie kursus

776
00:37:09,770 --> 00:37:10,954
moet jou eie wees.

777
00:37:10,954 --> 00:37:13,870
Maar in daardie, is daar beslis
geleenthede, en aanmoediging,

778
00:37:13,870 --> 00:37:17,300
en opvoedkundige waarde in te draai om
others-- myself, die TFS, die Cas,

779
00:37:17,300 --> 00:37:20,760
die Tas, en ander in die klas,
vir ondersteuning, wat nog te sê vriende

780
00:37:20,760 --> 00:37:23,547
en kamermaats wat bestudeer
CS en ontwikkeling voor.

781
00:37:23,547 --> 00:37:25,130
En so is daar 'n toelae vir daardie.

782
00:37:25,130 --> 00:37:28,180
En die algemene reël
is this-- toe om hulp te vra,

783
00:37:28,180 --> 00:37:31,470
jy kan jou kode te wys aan ander,
maar jy kan hulle s'n nie sien.

784
00:37:31,470 --> 00:37:34,880
So selfs as jy op kantoorure,
of in die D saal, of iewers anders

785
00:37:34,880 --> 00:37:37,450
werk op 'n stuk stel,
werk saam met 'n vriend, wat

786
00:37:37,450 --> 00:37:40,160
is heeltemal fyn, by die
einde van die dag jou werk

787
00:37:40,160 --> 00:37:43,034
moet uiteindelik aan elke
julle onderskeidelik, en nie

788
00:37:43,034 --> 00:37:45,700
'n paar gesamentlike poging,
behalwe vir die finale projek waar

789
00:37:45,700 --> 00:37:47,410
dit toegelaat en aangemoedig.

790
00:37:47,410 --> 00:37:49,830
>> Besef dat as jy
sukkel met iets

791
00:37:49,830 --> 00:37:52,520
en jou vriend net gebeur
beter op hierdie wees dan kan jy,

792
00:37:52,520 --> 00:37:55,130
of beter op daardie probleem as jy,
of 'n bietjie verder vooruit as jy,

793
00:37:55,130 --> 00:37:57,330
dit is heeltemal redelik om te draai
aan jou vriend en sê: hey,

794
00:37:57,330 --> 00:38:00,480
Gee jy om te kyk na my kode hier,
om my te help sien wat my probleem is?

795
00:38:00,480 --> 00:38:03,760
En hopelik in die
belang van opvoedkundige waarde

796
00:38:03,760 --> 00:38:07,040
wat n vriend nie net
sê: Ag, doen dit nie, maar eerder,

797
00:38:07,040 --> 00:38:09,917
wat mis jy op die lyn
6, of iets soos dit?

798
00:38:09,917 --> 00:38:12,000
Maar die oplossing is nie
vir die vriend langs jou

799
00:38:12,000 --> 00:38:15,617
om te sê: Ag, wel, hier, laat my toe
hierdie up, en wys my oplossing vir jou.

800
00:38:15,617 --> 00:38:16,450
So dit is die lyn.

801
00:38:16,450 --> 00:38:18,670
Jy wys jou kode te
ander, maar jy kan nie

802
00:38:18,670 --> 00:38:22,350
sien hulle s'n, onderhewig aan die ander
beperkinge in leerplan die kursus se.

803
00:38:22,350 --> 00:38:24,760
>> So moenie in gedagte hou hierdie
sogenaamde spyt klousule

804
00:38:24,760 --> 00:38:27,560
in leerplan die kursus se so goed,
dat as jy pleeg 'n daad wat

805
00:38:27,560 --> 00:38:30,476
is nie redelik nie, maar bring dit na
onder die aandag van die hoofde van die kursus se

806
00:38:30,476 --> 00:38:34,240
binne 72 uur, die kursus
kan plaaslike sanksies wat

807
00:38:34,240 --> 00:38:37,380
mag 'n onbevredigende sluit of
versuim graad vir die ingelewerde werk.

808
00:38:37,380 --> 00:38:41,410
Maar die kursus sal nie verwys die
saak vir verdere dissiplinêre optrede,

809
00:38:41,410 --> 00:38:43,010
behalwe in gevalle van herhaalde dade.

810
00:38:43,010 --> 00:38:46,632
Met ander woorde, as jy dit doen maak 'n paar
dom, veral laataand, besluit

811
00:38:46,632 --> 00:38:49,340
dat die volgende oggend of twee dae
later, jy wakker word en besef,

812
00:38:49,340 --> 00:38:50,870
wat ek dink?

813
00:38:50,870 --> 00:38:53,890
Jy doen in CS50 het 'n uitlaat
vir die vasstelling van die probleem

814
00:38:53,890 --> 00:38:57,170
en die besit van tot dit, sodat ons
sal jy halfpad ontmoet en handel

815
00:38:57,170 --> 00:39:01,500
daarmee in 'n kwessie wat beide
opvoedkundige en waardevol vir jou,

816
00:39:01,500 --> 00:39:04,200
maar nog steeds strafmaatreëls in een of ander manier.

817
00:39:04,200 --> 00:39:08,590
En nou, aan die rand af te neem, hierdie.

818
00:39:08,590 --> 00:39:10,570
>> [Video speel]

819
00:39:10,570 --> 00:39:13,540
>> [Speel van musiek]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [Einde TERUGSPEEL]

822
00:39:58,866 --> 00:40:00,490
David J. MALAN: Goed, ons is terug.

823
00:40:00,490 --> 00:40:03,680
En nou kyk ons ​​na een van die
eerste van ons werklike wêreld domeine

824
00:40:03,680 --> 00:40:08,720
in CS50, die kuns van kriptografie,
die kuns van die stuur en ontvang

825
00:40:08,720 --> 00:40:11,840
geheime boodskappe, geïnkripteer
boodskappe as jy wil,

826
00:40:11,840 --> 00:40:17,060
wat kan slegs ontsyfer as jy
'n paar belangrike bestanddeel wat die sender het

827
00:40:17,060 --> 00:40:18,030
ook.

828
00:40:18,030 --> 00:40:22,120
So om hierdie motiveer ons sal neem
'n blik op hierdie ding hier,

829
00:40:22,120 --> 00:40:26,750
wat is 'n voorbeeld van 'n
geheime dekodeerder ring wat

830
00:40:26,750 --> 00:40:34,042
kan gebruik word om uit te vind
wat 'n geheime boodskap eintlik is.

831
00:40:34,042 --> 00:40:35,750
Trouens, terug in die
dag in graad skool,

832
00:40:35,750 --> 00:40:38,787
As jy al ooit geheime boodskappe aan
sommige vriend of 'n drukgang in die klas,

833
00:40:38,787 --> 00:40:40,620
jy dalk gedink het
jy is om slim

834
00:40:40,620 --> 00:40:46,530
deur op jou stuk papier verandering,
soos, A na B en B tot C en C tot D,

835
00:40:46,530 --> 00:40:47,590
en dies meer.

836
00:40:47,590 --> 00:40:50,300
Maar jy is eintlik versleutelen
jou inligting, selfs

837
00:40:50,300 --> 00:40:53,300
As dit was 'n bietjie triviale, was nie
wat moeilik vir die onderwyser om te besef,

838
00:40:53,300 --> 00:40:55,675
Wel, as jy net verander
B na A en C na B,

839
00:40:55,675 --> 00:40:57,550
jy eintlik uitvind
wat die boodskap was,

840
00:40:57,550 --> 00:40:59,700
maar jy was in syfering inligting.

841
00:40:59,700 --> 00:41:03,420
>> Jy is net om dit te doen
eenvoudig, baie soos Ralphie hier

842
00:41:03,420 --> 00:41:07,934
in 'n bekende film wat speel
pretty much ad nauseum elke winter.

843
00:41:07,934 --> 00:41:08,600
[Video speel]

844
00:41:08,600 --> 00:41:11,180
-Wees Dit bekend wees aan alles wat
Ralph Parker word hierby

845
00:41:11,180 --> 00:41:14,070
aangestel as lid van die Klein
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
en die reg tot al die louere
en voordele wat daarmee gebeur.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
-Toonbank onderteken Pierre André, in ink.

848
00:41:24,340 --> 00:41:27,160
Honneurs en voordele,
reeds op die ouderdom van nege.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Geskree]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Come Op.

853
00:41:34,250 --> 00:41:35,210
Kom ons gaan met dit.

854
00:41:35,210 --> 00:41:39,530
Ek het nie alles wat jazz nodig
oor smokkelaars en Pirates.

855
00:41:39,530 --> 00:41:41,660
>> -Listen Môreaand vir
die sluiting avontuur

856
00:41:41,660 --> 00:41:43,880
van die swart seerower skip.

857
00:41:43,880 --> 00:41:46,650
Nou, dit is tyd vir
geheime boodskap Annie se

858
00:41:46,650 --> 00:41:49,840
vir jou lede van die Geheime Circle.

859
00:41:49,840 --> 00:41:53,570
Onthou, kinders, net lede
van Annie's Secret Circle

860
00:41:53,570 --> 00:41:56,140
kan Annie se geheime boodskap te ontsyfer.

861
00:41:56,140 --> 00:42:00,340
>> Onthou, Annie is na gelang van jou.

862
00:42:00,340 --> 00:42:02,880
Stel jou penne te B2.

863
00:42:02,880 --> 00:42:05,230
Hier is die boodskap.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Ek Is in my eerste geheime vergadering.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Was in 'n groot stem vanaand.

868
00:42:15,780 --> 00:42:19,000
Ek kon vertel dat vanaand se
boodskap was regtig belangrik.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, dit is 'n boodskap
van Annie haarself.

870
00:42:22,694 --> 00:42:23,860
Onthou, moenie iemand vertel nie.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekondes later, is ek in die enigste
kamer in die huis waar 'n seun van nege

873
00:42:32,930 --> 00:42:37,040
in privaatheid en dekodeer kon sit.

874
00:42:37,040 --> 00:42:39,730
Ha, B!

875
00:42:39,730 --> 00:42:42,360
Ek het na die volgende, E.

876
00:42:42,360 --> 00:42:44,520
>> Die eerste woord is nie.

877
00:42:44,520 --> 00:42:49,032
S, is dit kom makliker nou, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -OH, Kom op, Ralphie, ek moet gaan!

879
00:42:51,733 --> 00:42:53,688
>> -I'll Regs af wees, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee gefluit!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, seker wees aan- seker wees om what?

883
00:43:04,060 --> 00:43:05,970
Wat was Little Orphan
Annie probeer sê?

884
00:43:05,970 --> 00:43:07,264
Maak seker dat jy wat?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy het te
gaan, sal jy asseblief kom uit?

886
00:43:09,634 --> 00:43:10,480
>> -Alle Regte, Ma!

887
00:43:10,480 --> 00:43:12,880
Ek kom gou uit wees!

888
00:43:12,880 --> 00:43:14,550
>> -Ek Is nou nader om.

889
00:43:14,550 --> 00:43:16,620
Die spanning was verskriklik.

890
00:43:16,620 --> 00:43:17,720
Wat was dit?

891
00:43:17,720 --> 00:43:20,170
Die lot van die planeet
kan hang in die weegskaal.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy se moet gaan!

894
00:43:23,170 --> 00:43:26,890
>> -I'll Reg uit nie, want huil hardop!

895
00:43:26,890 --> 00:43:32,680
>> -Almost Daar, gevlieg my vingers, my gedagtes
was 'n staal strik elke porie vibreer.

896
00:43:32,680 --> 00:43:37,198
Dit was amper helder, ja, ja, ja.

897
00:43:37,198 --> 00:43:43,091
>> -Wees Seker dat jou Ovaltine drink.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
'N morsige kommersiële?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Seun van 'n teef.

903
00:43:54,227 --> 00:43:54,810
[Einde TERUGSPEEL]

904
00:43:54,810 --> 00:43:57,390
David J. MALAN: OK, so
dit was 'n baie lang pad

905
00:43:57,390 --> 00:44:00,660
van die bekendstelling van kriptografie,
en ook Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Trouens, van hierdie ou advertensie
hier, hoekom is Ovaltine so goed?

907
00:44:04,470 --> 00:44:09,470
Dit is 'n gekonsentreerde onttrekking van ryp
gars mout, melk suiwer romerige koei se

908
00:44:09,470 --> 00:44:14,360
en spesiaal voorberei kakao saam
met natuurlike phosphatides en vitamiene.

909
00:44:14,360 --> 00:44:18,240
Daar word verder versterk met
addisionele vitamiene B en D, yum.

910
00:44:18,240 --> 00:44:21,600
En jy kan nog steeds dit glo,
op Amazon, soos ons gedoen het hier.

911
00:44:21,600 --> 00:44:24,810
>> Maar die motivering hier was om
stel kriptografie, spesifiek

912
00:44:24,810 --> 00:44:28,340
'n soort van kriptografie bekend
as geheime sleutel kriptografie.

913
00:44:28,340 --> 00:44:34,284
En soos die naam aandui, die hele
sekuriteit van 'n geheime sleutel crypto stelsel,

914
00:44:34,284 --> 00:44:36,200
as jy wil, 'n metode
vir net skommeling

915
00:44:36,200 --> 00:44:40,960
inligting tussen twee mense, is dat
net die sender en net die ontvanger

916
00:44:40,960 --> 00:44:46,980
weet 'n geheime key-- n bietjie waarde, sommige
geheime frase, 'n geheime nommer, wat

917
00:44:46,980 --> 00:44:50,660
hulle in staat stel om beide enkripteer
en decrypt inligting.

918
00:44:50,660 --> 00:44:53,470
En kriptografie, regtig,
is net die van week 0.

919
00:44:53,470 --> 00:44:56,715
>> Dit is 'n probleem waar daar insette,
soos die werklike boodskap in Engels

920
00:44:56,715 --> 00:44:59,340
of wat ook al taal wat jy
wil stuur na iemand in die klas,

921
00:44:59,340 --> 00:45:00,580
of oor die internet.

922
00:45:00,580 --> 00:45:03,840
Daar is 'n paar uitset, wat gaan
om die roer boodskap wees dat jy

923
00:45:03,840 --> 00:45:05,250
wil die ontvanger ontvang.

924
00:45:05,250 --> 00:45:07,405
En selfs as iemand in die
middel ontvang dit ook

925
00:45:07,405 --> 00:45:09,780
jy dit nie wil
noodwendig in staat wees om dit te dekripteer,

926
00:45:09,780 --> 00:45:12,840
omdat binnekant van hierdie
black box, of algoritme,

927
00:45:12,840 --> 00:45:17,650
is 'n meganisme, 'n stap vir stap
instruksies, vir die neem van daardie insette

928
00:45:17,650 --> 00:45:20,710
en sit in die
uitset, in hopelik 'n veilige manier.

929
00:45:20,710 --> 00:45:23,640
>> En, in werklikheid, is daar 'n paar
woordeskat in hierdie wêreld soos volg.

930
00:45:23,640 --> 00:45:26,100
Gewone teks is die woord 'n
rekenaarwetenskaplike sou

931
00:45:26,100 --> 00:45:28,449
gebruik om die insette te beskryf
boodskap, soos die Engelse

932
00:45:28,449 --> 00:45:31,240
of wat ook al taal wat jy eintlik
wil stuur na 'n ander mens.

933
00:45:31,240 --> 00:45:35,450
En dan die kriptoteks is die geskarrel
om die enciphered, of geïnkripteer,

934
00:45:35,450 --> 00:45:36,520
weergawe daarvan.

935
00:45:36,520 --> 00:45:38,750
>> Maar daar is een ander bestanddeel hier.

936
00:45:38,750 --> 00:45:43,200
Daar is 'n ander insette te
geheime sleutel kriptografie.

937
00:45:43,200 --> 00:45:45,200
En dit is die sleutel self,
wat is, oor die algemeen,

938
00:45:45,200 --> 00:45:48,930
soos ons sal sien, 'n nommer, of
brief, of 'n woord, wat ook al

939
00:45:48,930 --> 00:45:51,980
die algoritme is dit eintlik verwag.

940
00:45:51,980 --> 00:45:53,870
>> En hoe kan jy inligting dekripteer?

941
00:45:53,870 --> 00:45:55,110
Hoe kan jy dit ontleden?

942
00:45:55,110 --> 00:45:57,950
Wel, jy moet net om te keer die
uitsette en insette.

943
00:45:57,950 --> 00:46:00,900
>> Met ander woorde, wanneer iemand
ontvang jou geïnkripteer boodskap,

944
00:46:00,900 --> 00:46:03,740
hy of sy net
tot op dié sleutel ken.

945
00:46:03,740 --> 00:46:05,700
Hulle het die kriptoteks ontvang.

946
00:46:05,700 --> 00:46:09,530
En gesit deur die twee
insette in die crypto stelsel,

947
00:46:09,530 --> 00:46:14,260
die algoritme, hierdie swart boks, uit
moet die oorspronklike skoonteks kom.

948
00:46:14,260 --> 00:46:17,830
En so dit is die baie hoë vlak
die lig van wat kriptografie is eintlik

949
00:46:17,830 --> 00:46:18,590
alles oor.

950
00:46:18,590 --> 00:46:20,030
>> So laat ons daar te kom.

951
00:46:20,030 --> 00:46:22,700
Kom ons kyk nou na onder
die kap van iets

952
00:46:22,700 --> 00:46:26,000
ons het al neem as vanselfsprekend aanvaar vir
die afgelope week, en vir hierdie sessie

953
00:46:26,000 --> 00:46:27,629
here-- die string.

954
00:46:27,629 --> 00:46:30,295
'N string aan die einde van die dag
is net 'n reeks karakters.

955
00:46:30,295 --> 00:46:33,610
>> Dit mag dalk hello world wees, of
hallo Zamyla, of wat ook al.

956
00:46:33,610 --> 00:46:37,050
Maar wat beteken dit om
'n reeks van karakters?

957
00:46:37,050 --> 00:46:41,520
Trouens, die CS50 biblioteek gee
ons 'n datatipe genoem string.

958
00:46:41,520 --> 00:46:45,140
>> Maar daar is eintlik geen
so iets soos 'n string in C.

959
00:46:45,140 --> 00:46:49,450
Dit is eintlik net 'n reeks
karakter, karakter, karakter,

960
00:46:49,450 --> 00:46:52,180
karakter, terug, na agter, om
terug, na agter, na binne terug

961
00:46:52,180 --> 00:46:54,650
van jou rekenaar se geheue, of RAM.

962
00:46:54,650 --> 00:46:58,940
En ons sal dieper kyk na wat in die
toekoms wanneer ons kyk na die geheue self,

963
00:46:58,940 --> 00:47:02,030
en die benutting, en die
bedreigings wat betrokke is.

964
00:47:02,030 --> 00:47:04,100
>> Maar laat ons kyk na die string Zamyla.

965
00:47:04,100 --> 00:47:07,480
Dus net die naam van
die menslike hier, Zamyla,

966
00:47:07,480 --> 00:47:12,030
dit is 'n reeks
karakters, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
En nou kom ons veronderstel dat naam Zamyla se
word gestoor binnekant van 'n rekenaar

968
00:47:16,020 --> 00:47:16,880
program.

969
00:47:16,880 --> 00:47:20,830
>> Wel, dit spreek vanself dat ons moet
in staat wees om te kyk na die karakters

970
00:47:20,830 --> 00:47:21,590
individueel.

971
00:47:21,590 --> 00:47:24,710
Dus is ek net gaan om 'n bietjie te trek
kassie rondom naam Zamyla se hier.

972
00:47:24,710 --> 00:47:31,580
En dit is die geval in C dat wanneer jy
'n string, soos Zamyla-- en miskien

973
00:47:31,580 --> 00:47:34,940
dat string het terug uit kom
'n funksie soos get string,

974
00:47:34,940 --> 00:47:38,540
jy kan eintlik manipuleer
Dit karakter deur karakter.

975
00:47:38,540 --> 00:47:42,070
>> Nou, dit is related vir die
gesprek op hande, want

976
00:47:42,070 --> 00:47:46,420
in kriptografie as jy wil verander
A na B en B tot C en C tot D,

977
00:47:46,420 --> 00:47:49,650
ensovoorts, moet jy in staat wees
om te kyk na die individuele karakters

978
00:47:49,650 --> 00:47:50,190
in 'n string.

979
00:47:50,190 --> 00:47:52,695
Jy moet in staat wees om te verander
die Z tot iets anders, die A

980
00:47:52,695 --> 00:47:55,280
om iets anders, die M aan
iets anders, en so aan.

981
00:47:55,280 --> 00:47:58,000
En so het ons behoefte aan 'n manier,
programmaties, sodat

982
00:47:58,000 --> 00:48:03,020
te praat, in C om in staat wees om te verander
en kyk na individuele briewe.

983
00:48:03,020 --> 00:48:05,690
En ons kan dit doen soos volg.

984
00:48:05,690 --> 00:48:08,340
>> Laat my gaan kop terug in CS50 IO.

985
00:48:08,340 --> 00:48:11,130
En laat ek gaan voort
en die skep van 'n nuwe lêer

986
00:48:11,130 --> 00:48:16,134
dat ek hierdie keer string0 sal noem,
as ons eerste so 'n voorbeeld, dot c.

987
00:48:16,134 --> 00:48:18,300
En ek gaan om voort te gaan
en sweep dit soos volg.

988
00:48:18,300 --> 00:48:22,870
>> So sluit CS50.h, en
dan sluit standaard io.h,

989
00:48:22,870 --> 00:48:25,990
wat ek byna altyd gaan
wees met behulp van my programme, ten minste

990
00:48:25,990 --> 00:48:26,780
aanvanklik.

991
00:48:26,780 --> 00:48:32,180
int main leemte, en dan hier Ek is
gaan snare doen kry kry string.

992
00:48:32,180 --> 00:48:35,260
En dan gaan ek
gaan voort en doen dit.

993
00:48:35,260 --> 00:48:37,460
Ek wil om voort te gaan
en, as 'n gesonde verstand tjek,

994
00:48:37,460 --> 00:48:43,607
net sê, hello, persent s,
kommapunt, maak string 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, wat het ek gedoen hier?

996
00:48:44,690 --> 00:48:45,930
O, ek het nie prop dit in.

997
00:48:45,930 --> 00:48:48,120
So les geleer, wat
was nie opsetlike.

998
00:48:48,120 --> 00:48:52,480
>> So fout, meer persent
doelskoppe as data argumente.

999
00:48:52,480 --> 00:48:54,940
En dit is waar, in
lyn 7-- OK, so ek het,

1000
00:48:54,940 --> 00:48:56,690
kwotasie unquote, dis
my string om printf.

1001
00:48:56,690 --> 00:48:58,151
Ek het 'n persent teken.

1002
00:48:58,151 --> 00:48:59,650
Maar ek die tweede argument ontbreek.

1003
00:48:59,650 --> 00:49:03,190
>> Ek mis die komma is, wat
Ek het nie in die vorige voorbeelde.

1004
00:49:03,190 --> 00:49:06,650
So 'n goeie geleentheid om vas te stel
nog 'n fout gemaak het, per ongeluk.

1005
00:49:06,650 --> 00:49:09,950
Laat My dan nou hardloop
string0, tipe in Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, hallo Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> So het ons hierdie soort van program uit te voer
'n paar verskillende tye nou.

1008
00:49:14,144 --> 00:49:16,310
Maar laat ons nie iets wat 'n
bietjie anders hierdie keer.

1009
00:49:16,310 --> 00:49:19,450
In plaas van net die druk van Zamyla se
geheel naam met printf,

1010
00:49:19,450 --> 00:49:21,350
Kom ons doen dit karakter deur karakter.

1011
00:49:21,350 --> 00:49:22,700
>> Ek gaan 'n gebruik vir lus.

1012
00:49:22,700 --> 00:49:26,160
En ek gaan om myself te gee
n telling veranderlike, het ek.

1013
00:49:26,160 --> 00:49:33,530
En ek gaan iterating hou, sodat
Solank as wat ek is minder as die lengte van s.

1014
00:49:33,530 --> 00:49:35,930
>> Dit blyk, het ons nie
doen dit die laaste keer,

1015
00:49:35,930 --> 00:49:39,100
dat c kom met 'n
funksie genoem Stirling.

1016
00:49:39,100 --> 00:49:42,690
Terug in die dag, en in die algemeen
nog by die uitvoering van funksies,

1017
00:49:42,690 --> 00:49:45,405
mense sal dikwels kies baie
bondige name daardie soort van klank

1018
00:49:45,405 --> 00:49:48,280
soos wat jy wil, selfs al is dit
ontbreek 'n paar vokale of letters.

1019
00:49:48,280 --> 00:49:50,660
So Stirling is die
naam van 'n funksie wat

1020
00:49:50,660 --> 00:49:53,880
neem 'n argument tussen
tussen hakies dat 'n string moet wees.

1021
00:49:53,880 --> 00:49:56,910
En dit net terug 'n heelgetal,
die lengte van daardie string.

1022
00:49:56,910 --> 00:50:00,580
>> So dit vir lus op lyn 7 gaan
om te begin tel by i gelyk 0.

1023
00:50:00,580 --> 00:50:02,530
Dit gaan 'inkrementeer
Ek op elke iterasie

1024
00:50:02,530 --> 00:50:04,350
deur 1, soos ons is besig met 'n paar keer.

1025
00:50:04,350 --> 00:50:06,780
Maar dit gaan net
hierdie tot die punt

1026
00:50:06,780 --> 00:50:09,660
toe ek is die lengte
van die string self.

1027
00:50:09,660 --> 00:50:14,520
>> So dit is 'n manier om uiteindelik
iterating oor die karakters

1028
00:50:14,520 --> 00:50:17,430
in die tou soos dit is volg.

1029
00:50:17,430 --> 00:50:20,670
Ek gaan nie uit te druk 'n
hele string, maar persent c,

1030
00:50:20,670 --> 00:50:22,860
'n enkele karakter
gevolg deur 'n nuwe reël.

1031
00:50:22,860 --> 00:50:24,880
En dan gaan ek
voort te gaan, en ek moet

1032
00:50:24,880 --> 00:50:29,080
om te sê ek wil druk
et karakter van s.

1033
00:50:29,080 --> 00:50:33,450
>> So as ek is die veranderlike wat aandui
die indeks van die string, waar

1034
00:50:33,450 --> 00:50:37,230
jy daarin, ek moet in staat wees om
sê, gee my die et karakter van s.

1035
00:50:37,230 --> 00:50:40,390
En C het 'n manier om dit te doen
dit met vierkantige hakies.

1036
00:50:40,390 --> 00:50:43,679
Jy sê net die naam van die
string, wat in hierdie geval is s.

1037
00:50:43,679 --> 00:50:46,970
Dan vierkantige hakies, wat gebruik jy
gewoonlik net bokant jou Enter

1038
00:50:46,970 --> 00:50:48,110
sleutel op die sleutelbord.

1039
00:50:48,110 --> 00:50:52,410
En dan sit jy die indeks van die
karakter wat jy wil druk.

1040
00:50:52,410 --> 00:50:55,960
So het die indeks gaan 'n wees
number-- 0, of 1, of 2, of 3, of dot,

1041
00:50:55,960 --> 00:50:57,590
dot, dot, 'n ander nommer.

1042
00:50:57,590 --> 00:51:00,920
>> En ons sien dat dit gaan
wees die regte hoeveelheid, want ek

1043
00:51:00,920 --> 00:51:02,360
begin tel by 0.

1044
00:51:02,360 --> 00:51:07,020
En by verstek, die eerste karakter
in 'n string is deur konvensie 0.

1045
00:51:07,020 --> 00:51:09,230
En die tweede karakter is bracket 1.

1046
00:51:09,230 --> 00:51:11,120
En die derde karakter is bracket 2.

1047
00:51:11,120 --> 00:51:13,630
En jy wil nie te gaan
ver, maar ons sal nie, want ons is

1048
00:51:13,630 --> 00:51:17,780
gaan net ek inkrementeer totdat dit
gelyk is aan die lengte van die string.

1049
00:51:17,780 --> 00:51:20,210
En op watter punt,
hierdie vir lus sal ophou.

1050
00:51:20,210 --> 00:51:25,550
>> So laat ek gaan voort en behalwe hierdie
program, en run te maak string 0.

1051
00:51:25,550 --> 00:51:28,400
Maar ek verfrommeld.

1052
00:51:28,400 --> 00:51:35,390
Implisiet verklaar biblioteek funksie
Stirling met tipe sulke en such-- nou,

1053
00:51:35,390 --> 00:51:36,430
dit klink bekend.

1054
00:51:36,430 --> 00:51:37,440
Maar dit is nie printf.

1055
00:51:37,440 --> 00:51:38,540
En dit is nie tou te kry.

1056
00:51:38,540 --> 00:51:40,480
>> Ek het nie skroef in
Net so hierdie tyd.

1057
00:51:40,480 --> 00:51:45,100
Maar let down hier 'n bietjie af
verder, sluit die kop string.h,

1058
00:51:45,100 --> 00:51:47,210
uitdruklik voorsien die
verklaring vir Stirling.

1059
00:51:47,210 --> 00:51:48,820
Daar is dus eintlik 'n idee in daar.

1060
00:51:48,820 --> 00:51:51,670
>> En inderdaad is dit blyk
daar is 'n ander kop lêer

1061
00:51:51,670 --> 00:51:53,970
dat ons nie gebruik het
in die klas nie, maar dit is

1062
00:51:53,970 --> 00:51:56,480
onder andere beskikbaar
vir julle geroep string.h.

1063
00:51:56,480 --> 00:52:00,930
En in daardie lêer, string.h
is Stirling verklaar.

1064
00:52:00,930 --> 00:52:05,220
So laat ek gaan voort en
behalwe hierdie, maak string

1065
00:52:05,220 --> 00:52:08,040
0-- mooi, geen fout boodskappe hierdie tyd.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, en
Ek is op die punt om druk Enter,

1067
00:52:12,290 --> 00:52:16,710
op watter punt getstring gaan
om die string terug, sit dit in s.

1068
00:52:16,710 --> 00:52:21,890
Dan wat vir lus gaan Itereer
oor S se karakters een op 'n tyd,

1069
00:52:21,890 --> 00:52:28,420
en druk 'n per reël, want
Ek het dit agteroorskuinsstreep N aan die einde.

1070
00:52:28,420 --> 00:52:34,530
So kan ek dit agteroorskuinsstreep laat
N, en dan net te druk Zamyla al

1071
00:52:34,530 --> 00:52:37,460
in dieselfde lyn,
effektief reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, wat nie alles wat nuttig.

1073
00:52:38,999 --> 00:52:40,540
Maar in hierdie geval, het ek nie gedoen het nie.

1074
00:52:40,540 --> 00:52:43,610
Ek het eintlik gedruk een
karakter op 'n slag, een per lyn,

1075
00:52:43,610 --> 00:52:45,400
sodat ons werklik sien wat die effek.

1076
00:52:45,400 --> 00:52:46,900
>> Maar ek moet een ding hier daarop.

1077
00:52:46,900 --> 00:52:48,930
En ons sal terug te kom na
dit in 'n toekomstige week.

1078
00:52:48,930 --> 00:52:52,650
Dit blyk dat hierdie
kode is potensieel karretjie.

1079
00:52:52,650 --> 00:52:56,560
>> Dit blyk dat get string
en 'n paar ander funksies in die lewe

1080
00:52:56,560 --> 00:53:00,280
hoef nie noodwendig
terugkeer wat jy verwag.

1081
00:53:00,280 --> 00:53:03,010
Ons weet uit die klas laaste
tyd in hierdie wat kry

1082
00:53:03,010 --> 00:53:04,960
string is veronderstel om 'n string terug te keer.

1083
00:53:04,960 --> 00:53:09,900
Maar wat as die gebruiker uit so '
'n lang woord, of paragraaf, of opstel

1084
00:53:09,900 --> 00:53:13,010
dat daar is net nie genoeg
geheue in die rekenaar om dit aan te pas.

1085
00:53:13,010 --> 00:53:15,410
>> Soos wat as daar iets gaan
verkeerde onder die enjinkap?

1086
00:53:15,410 --> 00:53:18,400
Dit mag dalk nie dikwels gebeur nie,
maar dit kon keer gebeur

1087
00:53:18,400 --> 00:53:21,520
in 'n tyd, baie selde.

1088
00:53:21,520 --> 00:53:25,460
En so is dit blyk dat get string
en funksies soos dit nie noodwendig

1089
00:53:25,460 --> 00:53:26,380
altyd terugkeer snare.

1090
00:53:26,380 --> 00:53:30,680
Hulle kan terugkeer sommige fout waarde,
sommige brandwag waarde om so te praat,

1091
00:53:30,680 --> 00:53:32,612
wat daarop dui dat
iets verkeerd geloop het.

1092
00:53:32,612 --> 00:53:35,320
En jy sal net weet van
dit omdat ek verneem het in die klas nou,

1093
00:53:35,320 --> 00:53:37,700
of 'n meer dokumentasie gelees.

1094
00:53:37,700 --> 00:53:43,120
Dit blyk dat get string
kan 'n waarde genoem nul terugkeer.

1095
00:53:43,120 --> 00:53:46,220
Nul is 'n spesiale waarde wat ons sal
kom terug na 'n toekomstige week.

1096
00:53:46,220 --> 00:53:50,420
Maar vir nou, weet net dat as ek wil
werklik behoorlike in 'n stap vorentoe te wees

1097
00:53:50,420 --> 00:53:52,650
gebruik van get string, ek
moet nie net noem dit,

1098
00:53:52,650 --> 00:53:56,870
en blindelings gebruik sy terugkeer waarde,
vertrou dat dit 'n string.

1099
00:53:56,870 --> 00:53:59,420
>> Ek moet julle eerste woorde wees
hey, wag 'n minuut, net

1100
00:53:59,420 --> 00:54:03,380
voortgaan as e is nie gelyk aan
nul, waar nul, weer,

1101
00:54:03,380 --> 00:54:04,660
is net 'n paar spesiale waarde.

1102
00:54:04,660 --> 00:54:07,770
En dit is die enigste spesiale waarde wat jy
nodig om te bekommer oor vir get string.

1103
00:54:07,770 --> 00:54:10,900
Kry string is óf gaan
'n tou of nul terugkeer.

1104
00:54:10,900 --> 00:54:17,219
>> En dit uitroepteken gelyk teken
jy dalk weet van miskien wiskunde klas

1105
00:54:17,219 --> 00:54:20,510
dat jy 'n gelykaanteken kan trek met
'n streep deur dit te nie gelyk te dui.

1106
00:54:20,510 --> 00:54:23,135
Dit is oor die algemeen nie 'n karakter
jy kan tik op u sleutelbord.

1107
00:54:23,135 --> 00:54:26,480
En so in die meeste programmeertale,
wanneer jy wil nie gelyk te sê,

1108
00:54:26,480 --> 00:54:29,160
jy gebruik 'n uitroepteken,
andersins bekend as knal.

1109
00:54:29,160 --> 00:54:33,180
So jy sê knal gelykes, wat
beteken nie gelyk, logies.

1110
00:54:33,180 --> 00:54:38,060
Dis net asof daar nie 'n groter
as, of gelyk aan of minder as

1111
00:54:38,060 --> 00:54:41,270
of gelyk aan sleutel op u sleutelbord
wat doen dit alles in een simbool.

1112
00:54:41,270 --> 00:54:44,020
So dit is waarom, in die verlede voorbeelde,
jy het 'n oop bracket, en dan

1113
00:54:44,020 --> 00:54:48,670
'n gelykaanteken, ten einde te doen
groter as of, sê, minder as.

1114
00:54:48,670 --> 00:54:49,910
>> So, wat is die afhaal hier?

1115
00:54:49,910 --> 00:54:53,880
Dit is bloot 'n manier nou van
bekendstelling van hierdie sintaksis, hierdie funksie,

1116
00:54:53,880 --> 00:54:57,390
iterating oor individuele
karakters in 'n string.

1117
00:54:57,390 --> 00:55:00,260
En net soos die vierkant
hakies toelaat by hulle uit te kom,

1118
00:55:00,260 --> 00:55:03,790
oorweeg die vierkantige hakies as
soort sinspeel op hierdie onderliggende

1119
00:55:03,790 --> 00:55:06,040
ontwerp, waardeur elke
karakter binnekant van 'n string

1120
00:55:06,040 --> 00:55:10,180
is soort doos in iewers onder
die enjinkap in die geheue van u rekenaar.

1121
00:55:10,180 --> 00:55:12,340
>> Maar laat ons 'n variant van hierdie.

1122
00:55:12,340 --> 00:55:14,880
Dit blyk dat hierdie
program is korrek.

1123
00:55:14,880 --> 00:55:18,810
So per byle CS50 se vir die evaluering
kode, dit is nou reg.

1124
00:55:18,810 --> 00:55:22,959
Veral noudat ek keur vir
nul, hierdie program moet nooit crash.

1125
00:55:22,959 --> 00:55:24,500
En ek weet net dat uit ondervinding.

1126
00:55:24,500 --> 00:55:28,040
Maar daar is niks anders wat
Ons kan verkeerd hier werklik gaan.

1127
00:55:28,040 --> 00:55:31,860
Maar dit is nie baie goed ontwerpte,
want laat ons teruggaan na die basiese dinge.

1128
00:55:31,860 --> 00:55:34,450
>> In die eerste plek principles--
Wat doen 'n for-lus te doen?

1129
00:55:34,450 --> 00:55:36,290
A vir lus doen drie dinge.

1130
00:55:36,290 --> 00:55:39,340
Dit initialisatie paar
waarde, as jy dit vra om.

1131
00:55:39,340 --> 00:55:41,770
Dit tjeks n toestand.

1132
00:55:41,770 --> 00:55:45,380
En dan na elke
iterasie, na elke siklus,

1133
00:55:45,380 --> 00:55:49,330
dit vermeerderings paar
waarde, of waardes, hier.

1134
00:55:49,330 --> 00:55:50,600
>> So wat beteken dit?

1135
00:55:50,600 --> 00:55:52,940
Ons inisialiseer ek tot 0.

1136
00:55:52,940 --> 00:55:58,610
Ons kyk en seker te maak ek is minder as
die lengte van s, wat is Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
so wat is minder as 6.

1138
00:55:59,900 --> 00:56:02,590
En, inderdaad, 0 as minder as 6.

1139
00:56:02,590 --> 00:56:05,580
>> Ons druk Z van name Zamyla se.

1140
00:56:05,580 --> 00:56:08,080
Dan inkrementeer ons i 0-1.

1141
00:56:08,080 --> 00:56:11,290
Ons het toe gaan, is 1 minder
as die lengte van s?

1142
00:56:11,290 --> 00:56:13,270
Die lengte van s is 6.

1143
00:56:13,270 --> 00:56:13,950
Ja dit is.

1144
00:56:13,950 --> 00:56:16,880
>> So druk ons ​​'n naam Zamyla se ZA.

1145
00:56:16,880 --> 00:56:20,090
Ons inkrementeer ek van 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Ons het toe gaan, is 2 minder as
die lengte van naam Zamyla se.

1147
00:56:23,720 --> 00:56:25,380
6- so 2 is minder as 6.

1148
00:56:25,380 --> 00:56:30,460
Ja, kom ons druk nou M in
Zamyla se naam, die derde karakter.

1149
00:56:30,460 --> 00:56:34,110
>> Die sleutel hier is dat elke
iterasie van die storie, ek keur,

1150
00:56:34,110 --> 00:56:37,810
is ek minder as die lengte van Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Maar die catch is dat
Stirling is nie 'n eiendom.

1152
00:56:40,350 --> 00:56:43,100
Diegene van julle wat geprogrammeer
voor in Java of ander tale

1153
00:56:43,100 --> 00:56:46,310
kan die lengte weet van 'n string is
'n eiendom, net 'n paar te lees net waarde.

1154
00:56:46,310 --> 00:56:50,220
>> In C in hierdie geval, indien dit
'n funksie wat letterlik

1155
00:56:50,220 --> 00:56:53,520
tel die aantal
karakters in Zamyla elke keer

1156
00:56:53,520 --> 00:56:54,740
Ons noem daardie funksie.

1157
00:56:54,740 --> 00:56:58,500
Elke keer as jy vra die rekenaar te gebruik
Stirling, dit neem 'n blik op Zamyla,

1158
00:56:58,500 --> 00:57:01,960
en gesê Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
En dit gee 6.

1160
00:57:02,962 --> 00:57:04,920
Die volgende keer wat jy noem
dit binne daardie lus,

1161
00:57:04,920 --> 00:57:08,610
dit gaan om te kyk na Zamyla
weer, sê Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
En dit gaan om terug te keer 6.

1163
00:57:10,320 --> 00:57:12,980
So, wat is dom oor hierdie ontwerp?

1164
00:57:12,980 --> 00:57:17,700
>> Hoekom is my kode nie 'n 5 out of 5
vir die ontwerp op die oomblik, om so te praat?

1165
00:57:17,700 --> 00:57:20,600
Wel, ek vra 'n
vraag onnodig.

1166
00:57:20,600 --> 00:57:23,030
Ek doen meer werk as wat ek nodig het om te.

1167
00:57:23,030 --> 00:57:25,370
>> So selfs al is die
antwoord korrek, ek

1168
00:57:25,370 --> 00:57:29,560
vra die rekenaar, wat
die lengte van Zamyla weer,

1169
00:57:29,560 --> 00:57:31,380
en weer, en weer, en weer?

1170
00:57:31,380 --> 00:57:33,980
En die antwoord is
nooit gaan verander.

1171
00:57:33,980 --> 00:57:35,900
Dit was nog altyd gaan wees 6.

1172
00:57:35,900 --> 00:57:39,730
>> So 'n beter oplossing as dit
sou hierdie volgende weergawe wees.

1173
00:57:39,730 --> 00:57:43,390
Laat my gaan voort en sit dit in 'n
aparte lêer genaamd string1.c,

1174
00:57:43,390 --> 00:57:44,990
net om te hou dit skei.

1175
00:57:44,990 --> 00:57:47,260
En dit blyk in 'n vir
lus, kan jy eintlik

1176
00:57:47,260 --> 00:57:50,210
verklaar verskeie veranderlikes in 'n keer.

1177
00:57:50,210 --> 00:57:53,460
>> So ek gaan Ek hou en sit dit aan 0.

1178
00:57:53,460 --> 00:57:56,190
Maar ek gaan ook
voeg 'n komma, en sê:

1179
00:57:56,190 --> 00:58:01,050
Gee my 'n veranderlike N geroep, wie se
waarde gelyk aan die string lengte van s.

1180
00:58:01,050 --> 00:58:09,410
En nou, maak asseblief my toestand
so lank as wat ek is minder as N.

1181
00:58:09,410 --> 00:58:14,140
>> So op hierdie manier, die logika is
identies aan die einde van die dag.

1182
00:58:14,140 --> 00:58:18,280
Maar ek onthou die
waarde 6, in hierdie geval.

1183
00:58:18,280 --> 00:58:19,780
Wat is die lengte van naam Zamyla se?

1184
00:58:19,780 --> 00:58:20,860
En ek sit dit op n.

1185
00:58:20,860 --> 00:58:23,050
>> En ek is nog steeds die nagaan
die toestand elke keer.

1186
00:58:23,050 --> 00:58:24,300
Is 0 minder as 6?

1187
00:58:24,300 --> 00:58:25,600
Is 1 minder as 6?

1188
00:58:25,600 --> 00:58:28,600
Is 2 minder as 6, en dies meer?

1189
00:58:28,600 --> 00:58:31,914
>> Maar Ek vra nie die rekenaar
weer en weer, wat

1190
00:58:31,914 --> 00:58:33,080
die lengte van naam Zamyla se?

1191
00:58:33,080 --> 00:58:34,320
Wat is die lengte van naam Zamyla se?

1192
00:58:34,320 --> 00:58:35,986
Wat is die lengte van die naam van hierdie Zamyla?

1193
00:58:35,986 --> 00:58:40,440
Ek is letterlik om te onthou dat die eerste en
beantwoord slegs in die tweede veranderlike N.

1194
00:58:40,440 --> 00:58:45,280
So dit nou nie net sou wees
korrek is, maar ook goed ontwerpte.

1195
00:58:45,280 --> 00:58:46,670
>> Nou, wat van styl?

1196
00:58:46,670 --> 00:58:48,866
Ek het my veranderlikes genoem
baie goed, sou ek sê.

1197
00:58:48,866 --> 00:58:50,240
Hulle is nou super bondige.

1198
00:58:50,240 --> 00:58:52,090
En dit is heeltemal fyn.

1199
00:58:52,090 --> 00:58:55,120
>> As jy net een
string in 'n program,

1200
00:58:55,120 --> 00:58:56,860
jy kan net so goed noem dit is vir string.

1201
00:58:56,860 --> 00:58:59,370
As jy net een veranderlike
vir die tel van 'n program,

1202
00:58:59,370 --> 00:59:00,710
jy kan net so goed noem dit ek.

1203
00:59:00,710 --> 00:59:03,500
As jy 'n lengte, N
is super algemene sowel.

1204
00:59:03,500 --> 00:59:05,800
Maar ek het nie kommentaar gelewer enige van my kode.

1205
00:59:05,800 --> 00:59:09,200
>> Ek het nie die reader-- ingelig
of dit is my TF, of TA,

1206
00:59:09,200 --> 00:59:12,460
of net colleague-- wat veronderstel
moet aangaan in hierdie program.

1207
00:59:12,460 --> 00:59:15,760
En so 'n goeie styl te kry,
wat ek wil doen

1208
00:59:15,760 --> 00:59:24,580
is this-- iets
soos vra gebruikers om insette.

1209
00:59:24,580 --> 00:59:26,670
En ek kon herskryf
hierdie 'n aantal van maniere.

1210
00:59:26,670 --> 00:59:35,630
>> Maak seker s-- seker te kry
string teruggekeer 'n string.

1211
00:59:35,630 --> 00:59:40,280
En dan in here-- en dit is dalk
die belangrikste comment-- iteraat

1212
00:59:40,280 --> 00:59:44,450
oor die karakters in s een op 'n slag.

1213
00:59:44,450 --> 00:59:47,060
En ek kon enige gebruik
keuse van die Engelse taal

1214
00:59:47,060 --> 00:59:49,650
hier aan elke beskryf
van hierdie stukke van die kode.

1215
00:59:49,650 --> 00:59:52,740
>> Let daarop dat ek nie sit 'n
kommentaar te lewer op elke reël van die kode,

1216
00:59:52,740 --> 00:59:55,690
eintlik net op die interessante
kinders, die een wat

1217
00:59:55,690 --> 00:59:59,460
het 'n paar betekenis dat ek
wil super duidelik aan iemand te maak

1218
00:59:59,460 --> 01:00:00,460
lees my kode.

1219
01:00:00,460 --> 01:00:02,920
En hoekom is jy 'n beroep te kry
string vra gebruikers om insette?

1220
01:00:02,920 --> 01:00:05,450
Selfs dat 'n mens nie noodwendig
alles wat beskrywende.

1221
01:00:05,450 --> 01:00:09,340
Maar dit help vertel 'n storie, want die
tweede lyn in die storie is, maak seker

1222
01:00:09,340 --> 01:00:10,740
kry string teruggekeer 'n string.

1223
01:00:10,740 --> 01:00:14,260
>> En die derde reël in die verhaal is,
Itereer oor die karakters in s een

1224
01:00:14,260 --> 01:00:15,380
op 'n slag.

1225
01:00:15,380 --> 01:00:17,920
En nou net vir 'n Goeie maat,
Ek gaan om voort te gaan en voeg

1226
01:00:17,920 --> 01:00:24,560
nog 'n opmerking wat net
sê druk i-de karakter in s.

1227
01:00:24,560 --> 01:00:26,520
Nou, wat het ek gedoen
aan die einde van die dag?

1228
01:00:26,520 --> 01:00:29,190
>> Ek het 'n paar Engelse bygevoeg
woorde in die vorm van kommentaar.

1229
01:00:29,190 --> 01:00:32,700
Die streep streep simbool beteken, hey,
rekenaar dit is vir die mens,

1230
01:00:32,700 --> 01:00:33,820
nie vir jou, die rekenaar.

1231
01:00:33,820 --> 01:00:35,119
So hulle is logies geïgnoreer.

1232
01:00:35,119 --> 01:00:35,910
Hulle is net daar.

1233
01:00:35,910 --> 01:00:39,830
>> En, inderdaad, CS50 IO toon hulle as
grys, as nuttig, maar nie die sleutel

1234
01:00:39,830 --> 01:00:41,000
tot die program.

1235
01:00:41,000 --> 01:00:42,570
Let op wat jy nou kan doen.

1236
01:00:42,570 --> 01:00:44,950
Of jy weet C
ontwikkeling of nie, jy

1237
01:00:44,950 --> 01:00:47,722
kan net terug te staan ​​in hierdie
program, en vlugtig die kommentaar.

1238
01:00:47,722 --> 01:00:50,180
Vra die gebruiker vir insette, maak seker
kry string teruggekeer 'n string,

1239
01:00:50,180 --> 01:00:53,009
Itereer oor die karakters in s
een op 'n tyd, druk die karakter

1240
01:00:53,009 --> 01:00:55,550
i-de karakter in s-- doen jy nie
selfs om te kyk na die kode

1241
01:00:55,550 --> 01:00:57,270
om te verstaan ​​wat hierdie program nie.

1242
01:00:57,270 --> 01:01:00,280
En, nog beter, as jy jouself sien
by hierdie program in 'n week of twee,

1243
01:01:00,280 --> 01:01:02,280
of 'n maand of 'n jaar,
jy ook nie

1244
01:01:02,280 --> 01:01:04,420
om te staar teen die kode,
probeer om te onthou,

1245
01:01:04,420 --> 01:01:06,630
wat ek probeer om te doen met hierdie kode?

1246
01:01:06,630 --> 01:01:07,770
>> Jy het jouself vertel.

1247
01:01:07,770 --> 01:01:11,660
Jy het dit beskryf vir jouself,
of 'n kollega, of TA, of TF.

1248
01:01:11,660 --> 01:01:14,860
En so sou dit nou wees
korrekte en goeie ontwerp,

1249
01:01:14,860 --> 01:01:18,210
en uiteindelik 'n goeie styl sowel.

1250
01:01:18,210 --> 01:01:19,990
So doen dit in gedagte hou.

1251
01:01:19,990 --> 01:01:22,200
>> Daar is dus 'n ander
ding gaan ek hier doen

1252
01:01:22,200 --> 01:01:28,240
wat kan nou openbaar presies wat
aangaan onder die enjinkap.

1253
01:01:28,240 --> 01:01:30,390
Daar is dus hierdie funksie
in C, en ander tale,

1254
01:01:30,390 --> 01:01:33,010
genoem typecasting
wat óf implisiet

1255
01:01:33,010 --> 01:01:37,250
of uitdruklik laat jou toe om te skakel
van 'n tipe data na 'n ander.

1256
01:01:37,250 --> 01:01:39,800
Ons het al te doen sodat
ver vandag met snare.

1257
01:01:39,800 --> 01:01:41,250
>> En snare is karakters.

1258
01:01:41,250 --> 01:01:44,910
Maar onthou van week
0, wat karakters?

1259
01:01:44,910 --> 01:01:49,334
Karakters is net 'n abstraksie
bo-op numbers-- desimale getalle,

1260
01:01:49,334 --> 01:01:52,500
en desimale getalle is eintlik net 'n
onttrekking op die top van binêre getalle,

1261
01:01:52,500 --> 01:01:53,720
soos ons gedefinieer nie.

1262
01:01:53,720 --> 01:01:55,540
>> So karakters getalle.

1263
01:01:55,540 --> 01:01:58,410
En getalle is karakters,
net na gelang van die konteks.

1264
01:01:58,410 --> 01:02:01,250
En dit blyk dat die binnekant
van 'n rekenaarprogram,

1265
01:02:01,250 --> 01:02:06,830
kan jy presies weet hoe jy wil om te kyk
by die stukkies binnekant van die program?

1266
01:02:06,830 --> 01:02:10,400
>> Onthou vanaf week 0 wat ons gehad het
ASCII, wat net hierdie kode

1267
01:02:10,400 --> 01:02:11,620
kartering briewe aan getalle.

1268
01:02:11,620 --> 01:02:13,660
Daarom het ons gedink, kapitaal A is 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B is 66, en so meer.

1270
01:02:15,860 --> 01:02:20,500
>> En kennis, ons het in wese karakters op
die boonste ry hier, soos C hulle sou noem,

1271
01:02:20,500 --> 01:02:23,400
karakters, en dan
SY op die tweede ry.

1272
01:02:23,400 --> 01:02:28,180
En dit blyk jy kan omskep
moeiteloos tussen die twee, tipies.

1273
01:02:28,180 --> 01:02:30,042
En as ons wil doen
hierdie opset, ons

1274
01:02:30,042 --> 01:02:31,750
dalk wil pak
iets soos hierdie.

1275
01:02:31,750 --> 01:02:33,590
>> Ons wil dalk omskep
hoofletters te verlaag

1276
01:02:33,590 --> 01:02:35,330
geval, of kleinletters te hoofletters.

1277
01:02:35,330 --> 01:02:38,000
En dit blyk daar is
eintlik 'n patroon hier

1278
01:02:38,000 --> 01:02:39,900
ons kan omhels in net 'n oomblik.

1279
01:02:39,900 --> 01:02:44,120
Maar kom ons kyk eers na 'n
voorbeeld hiervan doen uitdruklik.

1280
01:02:44,120 --> 01:02:46,340
>> Ek gaan om terug te gaan na CS50 IO.

1281
01:02:46,340 --> 01:02:50,640
Ek gaan 'n te skep
lêer genaamd Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
En ek gaan om voort te gaan en voeg my
standaard io.h aan die bokant, int main leemte

1283
01:02:55,960 --> 01:02:57,370
aan die bokant van my funksie.

1284
01:02:57,370 --> 01:03:02,700
En dan is ek net gaan die doen
following-- n for-lus uit Ek is gelyk,

1285
01:03:02,700 --> 01:03:04,610
kom ons sê, 65.

1286
01:03:04,610 --> 01:03:10,460
>> En dan is ek gaan minder wees as
65, plus 26 letters in die alfabet.

1287
01:03:10,460 --> 01:03:12,640
So ek sal die rekenaar laat
doen die wiskunde vir my daar.

1288
01:03:12,640 --> 01:03:15,100
En dan binne hierdie lus,
wat gaan ek om te druk?

1289
01:03:15,100 --> 01:03:19,230
>> % C is% i agteroorskuinsstreep N.

1290
01:03:19,230 --> 01:03:21,290
En nou wil ek prop in twee waardes.

1291
01:03:21,290 --> 01:03:24,530
Ek het tydelik vraag
punte is daar op die vraag uit te nooi.

1292
01:03:24,530 --> 01:03:29,940
>> Ek wil verder Itereer van 65
vir 26 letters van die alfabet,

1293
01:03:29,940 --> 01:03:35,190
druk uit op elke iterasie dat
karakter se integrale ekwivalent.

1294
01:03:35,190 --> 01:03:38,299
Met ander woorde, ek wil
Itereer oor 26 nommers druk

1295
01:03:38,299 --> 01:03:41,590
wat die Ascii karakter is, die brief,
en wat die ooreenstemmende nommer is--

1296
01:03:41,590 --> 01:03:44,650
eintlik net herskep
die grafiek van dié skyfie.

1297
01:03:44,650 --> 01:03:47,010
So, wat moet hierdie vraagtekens wees?

1298
01:03:47,010 --> 01:03:51,760
>> Wel, dit blyk dat die tweede
'n mens moet net die veranderlike ek.

1299
01:03:51,760 --> 01:03:53,860
Ek wil sien dat 'n aantal.

1300
01:03:53,860 --> 01:03:58,920
En die middelste argument
hier, kan ek die rekenaar vertel

1301
01:03:58,920 --> 01:04:03,470
te behandel wat heelgetal
Ek as 'n karakter, sodat

1302
01:04:03,470 --> 01:04:05,880
om dit hier vervang persent C.

1303
01:04:05,880 --> 01:04:07,990
>> Met ander woorde, as ek, die
menslike programmeerder, weet

1304
01:04:07,990 --> 01:04:09,865
En dit is net nommers
aan die einde van die dag.

1305
01:04:09,865 --> 01:04:12,500
En ek weet dat 65 behoort
karteer 'n paar karakter.

1306
01:04:12,500 --> 01:04:15,310
Met hierdie eksplisiete cast,
met 'n hakies,

1307
01:04:15,310 --> 01:04:18,840
die naam van die tipe data wat jy wil
skakel na, en 'n geslote hakies,

1308
01:04:18,840 --> 01:04:21,200
jy kan vertel die
rekenaar, hey, rekenaar,

1309
01:04:21,200 --> 01:04:24,130
omskep hierdie heelgetal 'n kar.

1310
01:04:24,130 --> 01:04:26,250
>> So wanneer ek loop hierdie
program na die samestelling,

1311
01:04:26,250 --> 01:04:29,740
Kom ons kyk wat Ek daaraan Ascii 0 get-- maak.

1312
01:04:29,740 --> 01:04:33,020
Darn dit, wat het ek gedoen verkeerd hier?

1313
01:04:33,020 --> 01:04:35,884
Gebruik van swart identifiseerder,
Goed, nie opsetlike,

1314
01:04:35,884 --> 01:04:37,800
maar laat ons kyk of ons kan nie
rede deur hierdie.

1315
01:04:37,800 --> 01:04:41,220
>> So lyn five-- so ek het nie
baie ver voor skroefwerk.

1316
01:04:41,220 --> 01:04:42,140
Dit is OK.

1317
01:04:42,140 --> 01:04:46,560
So reël 5 want ek gelyk 65-- ek sien.

1318
01:04:46,560 --> 01:04:50,130
So onthou dat in C, in teenstelling met sommige
tale as jy voor programmering

1319
01:04:50,130 --> 01:04:52,190
ervaring, jy
om die rekenaar te vertel,

1320
01:04:52,190 --> 01:04:55,040
In teenstelling met nuuts af, wat
tipe veranderlike dit.

1321
01:04:55,040 --> 01:04:56,860
>> En ek het vergeet 'n sleutelfrase hier.

1322
01:04:56,860 --> 01:04:59,200
In ooreenstemming vyf, het ek begin met i.

1323
01:04:59,200 --> 01:05:01,560
Maar ek het nie gesê C
wat datatipe dit.

1324
01:05:01,560 --> 01:05:04,570
So ek gaan hier in te gaan en
sê: Ag, maak dit 'n heelgetal.

1325
01:05:04,570 --> 01:05:07,050
>> Nou gaan ek voort te gaan en heropstel.

1326
01:05:07,050 --> 01:05:08,080
Dit vaste dat.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Gee, dis gaaf.

1328
01:05:12,660 --> 01:05:15,360
Nie net is dit super vinnig om
vra die rekenaar hierdie vraag,

1329
01:05:15,360 --> 01:05:18,885
eerder as op soek dit op 'n skyfie,
dit uitgedruk een per lyn, 'n 65,

1330
01:05:18,885 --> 01:05:24,860
B is 66, al die pad down-- want ek
het dit 26 times-- om die letters z,

1331
01:05:24,860 --> 01:05:25,630
wat is 90.

1332
01:05:25,630 --> 01:05:27,790
En, in werklikheid, 'n bietjie
meer intelligente sou

1333
01:05:27,790 --> 01:05:31,030
het vir my nie om te vertrou
op die rekenaar by te voeg 26.

1334
01:05:31,030 --> 01:05:34,060
Ek kon net gedoen
90 so goed, so lank

1335
01:05:34,060 --> 01:05:37,390
as ek nie twee keer dieselfde fout te maak.

1336
01:05:37,390 --> 01:05:41,880
Ek wil om te gaan deur middel van
Z, nie net op deur y.

1337
01:05:41,880 --> 01:05:44,000
>> So dit is 'n eksplisiete cast.

1338
01:05:44,000 --> 01:05:47,860
Dit blyk dat hierdie
is nie eens nodig nie.

1339
01:05:47,860 --> 01:05:52,480
Laat my gaan voort en tik hierdie
samesteller, en tik Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Dit blyk dat C is redelik slim.

1341
01:05:54,940 --> 01:05:57,150
>> En printf, in die besonder,
is redelik slim.

1342
01:05:57,150 --> 01:06:01,260
As jy net slaag 'n B twee keer
vir beide plekhouers, printf

1343
01:06:01,260 --> 01:06:04,510
sal besef, o, en ek weet dat jy
het my 'n integer-- paar nommer,

1344
01:06:04,510 --> 01:06:06,380
soos 65 of 90, of wat ook al.

1345
01:06:06,380 --> 01:06:10,170
Maar ek sien dat jy my wil
formaat dat die getal soos 'n karakter.

1346
01:06:10,170 --> 01:06:16,460
En so printf kan implisiet gooi
die int 'n kar vir jou so goed.

1347
01:06:16,460 --> 01:06:19,360
So dit is nie 'n probleem nie.

1348
01:06:19,360 --> 01:06:23,100
>> Maar let op, as gevolg van hierdie ekwivalensie
Ons kan dit werklik te doen as goed.

1349
01:06:23,100 --> 01:06:26,520
Laat my gaan voort en maak 'n mens
ander weergawe van this-- Ascii 1.C.

1350
01:06:26,520 --> 01:06:31,800
En in plaas van iterating oor
heelgetalle, kan regtig blaas jou gedagtes

1351
01:06:31,800 --> 01:06:33,610
deur iterating oor karakters.

1352
01:06:33,610 --> 01:06:37,660
As 'n kar c kry kapitaal A, ek
wil om voort te gaan en dit te doen,

1353
01:06:37,660 --> 01:06:41,740
so lank as C is minder as of gelyk
om kapitaal Z. En op elke iterasie

1354
01:06:41,740 --> 01:06:45,690
Ek wil C inkrementeer, ek kan
nou in my printf lyn hier

1355
01:06:45,690 --> 01:06:51,320
Sê persent C is
persent ek weer, komma C.

1356
01:06:51,320 --> 01:06:57,200
>> En nou, kan ek gaan die ander rigting,
beslissende die karakter uitdruklik

1357
01:06:57,200 --> 01:06:58,500
om 'n heelgetal.

1358
01:06:58,500 --> 01:07:00,560
So, weer, hoekom sou jy dit doen?

1359
01:07:00,560 --> 01:07:03,830
Dit is 'n bietjie vreemd om te sorteer van
tel in terme van karakters.

1360
01:07:03,830 --> 01:07:07,430
>> Maar as jy verstaan ​​wat
aangaan onder die enjinkap,

1361
01:07:07,430 --> 01:07:08,430
daar is regtig geen magic.

1362
01:07:08,430 --> 01:07:13,060
Jy is net te sê, hey, rekenaar gee
vir my 'n veranderlike genaamd C van tipe char.

1363
01:07:13,060 --> 01:07:16,520
Inisialiseer dit om kapitaal A. En
sien aanhalingstekens saak.

1364
01:07:16,520 --> 01:07:19,580
>> Vir karakters in C, onthou uit
verlede week, gebruik jy aanhalingstekens.

1365
01:07:19,580 --> 01:07:23,720
Vir snare, vir woorde,
frases, dubbele aanhalingstekens gebruik jy.

1366
01:07:23,720 --> 01:07:27,210
OK, rekenaar, bewaar dit doen, sodat
Solank as wat die karakter is minder as

1367
01:07:27,210 --> 01:07:28,050
of gelyk aan Z.

1368
01:07:28,050 --> 01:07:32,640
En ek weet van my Ascii tafel dat alle
van hierdie Ascii kodes is aangrensend.

1369
01:07:32,640 --> 01:07:33,400
>> Daar is geen gapings.

1370
01:07:33,400 --> 01:07:36,737
Dit is dus net 'n deur Z,
geskei deur elkeen getal.

1371
01:07:36,737 --> 01:07:38,820
En dan kan ek inkrementeer
'n kar, as ek regtig wil.

1372
01:07:38,820 --> 01:07:40,390
Aan die einde van die dag,
dit is net 'n paar.

1373
01:07:40,390 --> 01:07:41,030
Ek weet dit.

1374
01:07:41,030 --> 01:07:43,670
So kan ek net aanneem om by te voeg 1 tot dit.

1375
01:07:43,670 --> 01:07:46,940
>> En dan is dit tyd, ek druk c,
en dan die integrale ekwivalent.

1376
01:07:46,940 --> 01:07:50,170
En ek het nie eens die eksplisiete cast nodig.

1377
01:07:50,170 --> 01:07:52,680
Ek kan printf en die laat
rekenaar figuur dinge uit,

1378
01:07:52,680 --> 01:07:57,300
sodat nou as ek hardloop
maak Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Ek kry presies dieselfde ding as well.

1380
01:08:01,520 --> 01:08:04,530
>> Nutteloos program, though-- niemand
gaan eintlik sagteware te skryf

1381
01:08:04,530 --> 01:08:07,549
ten einde uit te vind, wat die
getal wat kaarte om 'n, of B, of Z?

1382
01:08:07,549 --> 01:08:10,340
Jy is net gaan om dit te Google, of
kyk dit aanlyn, of kyk dit

1383
01:08:10,340 --> 01:08:11,650
op 'n skyfie, en dies meer.

1384
01:08:11,650 --> 01:08:13,520
So waar laat dit eintlik nuttig?

1385
01:08:13,520 --> 01:08:15,960
>> Wel, praat van daardie
skyfie, sien daar

1386
01:08:15,960 --> 01:08:20,890
'n werklike patroon hier tussen hoofletters
en klein wat nie was toevallig.

1387
01:08:20,890 --> 01:08:23,760
Let daarop dat kapitaal A is 65.

1388
01:08:23,760 --> 01:08:25,830
Kleine letters is 97.

1389
01:08:25,830 --> 01:08:29,649
En hoe ver is kleinletters n?

1390
01:08:29,649 --> 01:08:32,649
>> So 65 is hoeveel stappe weg van 97?

1391
01:08:32,649 --> 01:08:36,210
So 97 minus 65 is 32.

1392
01:08:36,210 --> 01:08:37,910
So kapitaal 'n 65.

1393
01:08:37,910 --> 01:08:39,939
As jy 32 voeg by dat,
jy kleinletter a.

1394
01:08:39,939 --> 01:08:43,729
En, anders gestel as jy 32 aftrek,
jy kom terug na kapitaal A-- dieselfde met B

1395
01:08:43,729 --> 01:08:46,380
min b, groot C te min c.

1396
01:08:46,380 --> 01:08:50,670
>> Al hierdie gapings is 32 uitmekaar.

1397
01:08:50,670 --> 01:08:54,450
Nou, dit sou lyk ons ​​toelaat om
doen iets soos Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
of Google Docs funksie, waar jy
kan alles kies en dan sê:

1399
01:08:57,729 --> 01:09:00,520
verander al na kleinletters, of
verander al na hoofletters,

1400
01:09:00,520 --> 01:09:03,840
of verander slegs die eerste woord
van 'n sin om hoofletters.

1401
01:09:03,840 --> 01:09:07,390
Ons kan eintlik iets te doen
soos wat onsself.

1402
01:09:07,390 --> 01:09:12,645
>> Laat my gaan voort en 'n lêer te stoor
hier genoem kapitaliseer 0.c.

1403
01:09:12,645 --> 01:09:15,770
En laat ons gaan voort en sweep 'n program
wat doen presies wat soos volg.

1404
01:09:15,770 --> 01:09:18,460
So sluit die CS50 biblioteek.

1405
01:09:18,460 --> 01:09:21,430
En sluit standaard I / O.

1406
01:09:21,430 --> 01:09:22,787
>> En ek weet dit is binnekort beskikbaar.

1407
01:09:22,787 --> 01:09:24,870
So ek gaan dit in te sit
daar reeds, string.h,

1408
01:09:24,870 --> 01:09:26,960
so ek het toegang tot
dinge soos Stirling,

1409
01:09:26,960 --> 01:09:29,620
en dan int main leemte, soos gewoonlik.

1410
01:09:29,620 --> 01:09:33,420
En dan gaan ek voort te gaan
en doen snare kry kry string,

1411
01:09:33,420 --> 01:09:35,032
net 'n string van die gebruiker te kry.

1412
01:09:35,032 --> 01:09:36,740
En dan gaan ek
doen my gesonde verstand tjek.

1413
01:09:36,740 --> 01:09:40,510
As string is nie gelyk aan nul,
dan is dit veilig om voort te gaan.

1414
01:09:40,510 --> 01:09:42,000
En wat doen wat ek wil doen?

1415
01:09:42,000 --> 01:09:48,700
Ek gaan Itereer van i gelyk 0,
en N tot die string lengte van s.

1416
01:09:48,700 --> 01:09:51,899
>> En ek gaan om dit te doen so lank as
Ek is minder as N, en ek plus plus.

1417
01:09:51,899 --> 01:09:55,060
Tot dusver, ek is regtig net
leen idees voor.

1418
01:09:55,060 --> 01:09:57,010
En nou gaan ek 'n tak in te voer.

1419
01:09:57,010 --> 01:09:59,635
>> So dink terug te krap, waar
Ons het die vurk in die pad,

1420
01:09:59,635 --> 01:10:05,110
en verlede week in C. Ek gaan
sê dit, indien die i-de karakter in s

1421
01:10:05,110 --> 01:10:09,250
is groter as of
gelyk aan laer geval 'n,

1422
01:10:09,250 --> 01:10:13,340
and-- in Scratch sou jy letterlik
sê en nie, maar in C julle sê ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- en die i-de karakter in s
minder as of gelyk aan geval Z te verlaag,

1424
01:10:19,830 --> 01:10:21,780
Kom ons iets interessant doen.

1425
01:10:21,780 --> 01:10:27,020
Kom ons eintlik druk 'n
karakter met geen NEWLINE

1426
01:10:27,020 --> 01:10:31,760
dit is die karakter in die string,
die i-de karakter in die string.

1427
01:10:31,760 --> 01:10:37,420
>> Maar laat ons gaan voort en
aftrek 32 daaruit.

1428
01:10:37,420 --> 01:10:42,120
Anders as die karakter in die
string wat ons is op soek

1429
01:10:42,120 --> 01:10:45,950
is nie tussen bietjie 'n
en min Z, gaan voort

1430
01:10:45,950 --> 01:10:48,610
en net gedruk dit onveranderd.

1431
01:10:48,610 --> 01:10:50,840
Dus het ons bekendgestel
hierdie ingeperk notasie

1432
01:10:50,840 --> 01:10:53,560
vir ons snare te kry by die
i-de karakter in die string.

1433
01:10:53,560 --> 01:10:57,520
>> Ek het 'n paar voorwaardelike logika bygevoeg, soos
Scratch in verlede week se week een, waar

1434
01:10:57,520 --> 01:10:59,880
Ek is net die gebruik van my fundamentele
begrip van wat

1435
01:10:59,880 --> 01:11:01,130
aangaan onder die enjinkap.

1436
01:11:01,130 --> 01:11:04,190
Is die i-de karakter van s
groter as of gelyk aan 'n?

1437
01:11:04,190 --> 01:11:08,290
Soos, is dit 97 of 98,
of 99, en so meer?

1438
01:11:08,290 --> 01:11:11,940
>> Maar is dit ook minder as of gelyk
ter waarde van klein Z?

1439
01:11:11,940 --> 01:11:16,210
En indien wel, wat beteken dit line beteken?

1440
01:11:16,210 --> 01:11:20,250
14 Dit is 'n soort van die
kiem van die hele idee,

1441
01:11:20,250 --> 01:11:23,840
kapitaliseer die brief deur
eenvoudig trek 32 daaruit,

1442
01:11:23,840 --> 01:11:29,370
in hierdie geval, want ek weet, per dat
grafiek, hoe my getalle verteenwoordig.

1443
01:11:29,370 --> 01:11:33,925
So laat ons gaan voort en loop dit,
nadat die opstel kapitaliseer 0.C,

1444
01:11:33,925 --> 01:11:36,210
en hardloop kapitaliseer 0.

1445
01:11:36,210 --> 01:11:40,300
>> Kom ons tik in iets soos
Zamyla in alle klein betree.

1446
01:11:40,300 --> 01:11:42,780
En nou het ons Zamyla in hoofletters.

1447
01:11:42,780 --> 01:11:45,050
Kom ons tik in Rob in alle klein.

1448
01:11:45,050 --> 01:11:46,674
Kom ons probeer Jason in alle klein.

1449
01:11:46,674 --> 01:11:48,590
En ons hou aan om die
gedwing hoofletters.

1450
01:11:48,590 --> 01:11:50,960
Daar is 'n klein fout wat ek
soort het nie verwag.

1451
01:11:50,960 --> 01:11:54,050
Let my nuwe vinnige is eindig
op dieselfde lyn as hul name,

1452
01:11:54,050 --> 01:11:55,520
wat voel 'n bietjie slordig.

1453
01:11:55,520 --> 01:11:59,170
>> So ek gaan hier gaan, en
eintlik aan die einde van hierdie program

1454
01:11:59,170 --> 01:12:02,110
druk 'n NEWLINE karakter.

1455
01:12:02,110 --> 01:12:03,160
Dis al.

1456
01:12:03,160 --> 01:12:06,120
Met printf, het jy nie nodig het om te
slaag in veranderlikes of formaat kode.

1457
01:12:06,120 --> 01:12:08,460
Jy kan letterlik net druk
iets soos 'n NEWLINE.

1458
01:12:08,460 --> 01:12:13,529
>> So laat ons gaan voort en maak
kapitaliseer 0 weer, tik dit, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
En nou is dit 'n bietjie mooier.

1460
01:12:14,820 --> 01:12:17,274
Nou, my vinnige is op sy eie nuwe lyn.

1461
01:12:17,274 --> 01:12:18,440
So dit is alles goed en wel.

1462
01:12:18,440 --> 01:12:19,910
So dit is 'n goeie voorbeeld.

1463
01:12:19,910 --> 01:12:22,700
Maar ek doen nie eens noodwendig
moet hard-kode die 32.

1464
01:12:22,700 --> 01:12:23,350
Jy weet wat?

1465
01:12:23,350 --> 01:12:26,350
Ek kon say-- ek doen nie ooit
onthou wat die verskil is.

1466
01:12:26,350 --> 01:12:29,330
>> Maar ek weet dat as ek
'n kleinletter,

1467
01:12:29,330 --> 01:12:34,430
Ek wil in wese om af te trek
ongeag die afstand tussen bietjie

1468
01:12:34,430 --> 01:12:39,160
a en 'n groot, want as ek aanvaar dat
al die ander briewe is dieselfde,

1469
01:12:39,160 --> 01:12:41,045
dat indien die werk gedoen te kry.

1470
01:12:41,045 --> 01:12:42,670
Maar eerder as om dit te doen, jy weet wat?

1471
01:12:42,670 --> 01:12:44,240
Daar is 'n ander manier nog steeds.

1472
01:12:44,240 --> 01:12:48,090
>> As dit kapitaliseer 1.c-- as ek
om te sit wat in 'n aparte lêer.

1473
01:12:48,090 --> 01:12:51,030
Kom ons doen kapitaliseer 2.C soos volg.

1474
01:12:51,030 --> 01:12:53,060
Ek gaan dit regtig skoon te maak hier.

1475
01:12:53,060 --> 01:12:57,420
En in plaas van selfs om te
weet of omgee wat lae vlak

1476
01:12:57,420 --> 01:13:01,090
implementering besonderhede, ek is in plaas
net gaan om 'n karakter te druk,

1477
01:13:01,090 --> 01:13:04,610
kwotasie unquote, persent C, en
dan roep 'n ander funksie wat

1478
01:13:04,610 --> 01:13:09,950
bestaan ​​dat neem 'n argument,
wat 'n karakter, soos hierdie.

1479
01:13:09,950 --> 01:13:12,630
>> Dit blyk in C, daar is
'n ander funksie oproep

1480
01:13:12,630 --> 01:13:15,550
na die boonste, wat soos sy naam
dui daarop neem 'n karakter

1481
01:13:15,550 --> 01:13:19,350
en maak dit aan die hoofletters
ekwivalent, en dan terug dit

1482
01:13:19,350 --> 01:13:21,410
sodat printf kan dit sluit in daar.

1483
01:13:21,410 --> 01:13:25,484
En so om dit te doen, al is, ek
moet een ander lêer in te voer.

1484
01:13:25,484 --> 01:13:28,400
Dit blyk daar is 'n ander lêer
dat jy net sal weet van die klas,

1485
01:13:28,400 --> 01:13:33,020
of 'n handboek, of 'n aanlyn
verwysing, genaamd C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> So as ek byvoeg dat tot onder my kop
lêers, en nou weer saam te stel hierdie program,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Kom ons tik in Zamyla in alle
klein, werk nog steeds dieselfde.

1489
01:13:46,690 --> 01:13:48,040
Maar jy weet wat?

1490
01:13:48,040 --> 01:13:55,590
Dit blyk dat om bo
het 'n paar ander funksies.

1491
01:13:55,590 --> 01:13:58,410
>> En laat ek dit stel
beveel hier, soort ongemaklik

1492
01:13:58,410 --> 01:14:00,250
genoem word, maar die mens vir die handleiding.

1493
01:14:00,250 --> 01:14:03,960
Dit blyk dat die meeste Linux rekenaars,
soos ons gebruik here-- Linux bedryfstelsel

1494
01:14:03,960 --> 01:14:06,270
system-- 'n opdrag
genoem man, wat sê:

1495
01:14:06,270 --> 01:14:08,530
hey, rekenaar, gee my
handleiding van die rekenaar.

1496
01:14:08,530 --> 01:14:10,680
Wat wil jy
opkyk in daardie handleiding?

1497
01:14:10,680 --> 01:14:13,840
>> Ek wil om te kyk die funksie
genoem na die boonste, Tik.

1498
01:14:13,840 --> 01:14:16,070
En dit is 'n bietjie kripties
om soms te lees.

1499
01:14:16,070 --> 01:14:18,780
Maar let op dat ons in die
handleiding Linux programmeerder se.

1500
01:14:18,780 --> 01:14:19,530
En dit is alles teks.

1501
01:14:19,530 --> 01:14:21,905
En agterkom dat daar is die
Naam van die funksie hier.

1502
01:14:21,905 --> 01:14:25,030
Dit blyk dit 'n neef genoem
te verlaag, wat die teenoorgestelde doen.

1503
01:14:25,030 --> 01:14:29,710
En kennisgewing kragtens samevatting, om dit te gebruik
funksioneer die man bladsy, om so te praat,

1504
01:14:29,710 --> 01:14:32,220
vertel my dat ek
moet c type.h. sluit

1505
01:14:32,220 --> 01:14:33,630
En Ek het geweet dat uit die praktyk.

1506
01:14:33,630 --> 01:14:36,210
>> Hier is dit wat my die twee
prototipes vir die funksie,

1507
01:14:36,210 --> 01:14:39,070
sodat as ek ooit wil om dit te gebruik
Ek weet wat hulle neem as toevoer,

1508
01:14:39,070 --> 01:14:40,652
en wat hulle moet terugkeer as uitset.

1509
01:14:40,652 --> 01:14:42,360
En dan as ek lees
die beskrywing, sien ek

1510
01:14:42,360 --> 01:14:44,820
in meer detail wat die funksie doen.

1511
01:14:44,820 --> 01:14:48,100
Maar meer belangrik, as
Ek kyk onder terugkeer waarde,

1512
01:14:48,100 --> 01:14:51,710
Dit sê die waarde teruggekeer is
dié van die bekeerde brief,

1513
01:14:51,710 --> 01:14:57,880
of C, die oorspronklike insette, indien
die omskakeling was nie moontlik nie.

1514
01:14:57,880 --> 01:15:01,992
>> Met ander woorde, na die boonste sal probeer
om 'n brief te skakel na hoofletters.

1515
01:15:01,992 --> 01:15:03,450
En indien wel, dit gaan om dit terug te keer.

1516
01:15:03,450 --> 01:15:07,010
Maar as dit kan nie vir 'n paar reason--
Miskien is dit reeds hoofletters,

1517
01:15:07,010 --> 01:15:09,550
Miskien is dit 'n uitroepteken
of 'n ander punctuation--

1518
01:15:09,550 --> 01:15:12,200
dit is net gaan
stuur die oorspronklike C,

1519
01:15:12,200 --> 01:15:17,340
wat beteken dat ek kan my kode maak
beter ontwerp as volg.

1520
01:15:17,340 --> 01:15:20,580
>> Ek het nie al nodig
hierdie darn reëls van die kode.

1521
01:15:20,580 --> 01:15:22,610
Al die lyne Ek het
net uitgelig kan

1522
01:15:22,610 --> 01:15:28,700
word in duie gestort in net 'n eenvoudige
lyn, wat is this-- printf persent

1523
01:15:28,700 --> 01:15:33,510
c na die boonste S bracket i.

1524
01:15:33,510 --> 01:15:36,090
En dit sal 'n wees
voorbeeld van 'n beter ontwerp.

1525
01:15:36,090 --> 01:15:40,040
>> Hoekom implementeer in 7 of 8 lyne
van kode, wat dit ook al was ek net

1526
01:15:40,040 --> 01:15:44,960
verwyder, as jy plaas kan in duie stort
al wat logika en besluitneming

1527
01:15:44,960 --> 01:15:49,620
in 'n enkele lyn, 13 nou, wat
staatmaak op 'n biblioteek function--

1528
01:15:49,620 --> 01:15:53,430
'n funksie wat kom met C, maar dit
doen presies wat jy wil om dit te doen.

1529
01:15:53,430 --> 01:15:55,295
En, eerlik, selfs al
dit het nie gekom met C,

1530
01:15:55,295 --> 01:15:58,880
jy kan dit self te implementeer, soos
ons gesien het, met kry negatiewe int

1531
01:15:58,880 --> 01:16:01,700
en kry positiewe int verlede week so goed.

1532
01:16:01,700 --> 01:16:03,470
>> Hierdie kode is nou baie meer leesbare.

1533
01:16:03,470 --> 01:16:06,670
En, inderdaad, as ons Scroll up,
kyk hoeveel meer kompak

1534
01:16:06,670 --> 01:16:08,360
hierdie weergawe van my program is.

1535
01:16:08,360 --> 01:16:11,230
Dit is 'n bietjie bo swaar nou,
met al hierdie sluit.

1536
01:16:11,230 --> 01:16:14,380
Maar dis OK, want nou staan ​​ek
op die skouers van programmeerders

1537
01:16:14,380 --> 01:16:15,300
eerder as ek.

1538
01:16:15,300 --> 01:16:18,440
En elkeen wat dit was wat
geïmplementeer om die boonste regtig

1539
01:16:18,440 --> 01:16:21,470
het my 'n guns, net soos elkeen
geïmplementeer Stirling regtig

1540
01:16:21,470 --> 01:16:24,790
het my 'n guns 'n geruime tyd gelede.

1541
01:16:24,790 --> 01:16:26,970
En so nou het ons 'n
beter ontwerp program

1542
01:16:26,970 --> 01:16:31,680
wat implemente die presiese dieselfde logika.

1543
01:16:31,680 --> 01:16:35,580
>> Praat van Stirling, laat
my gaan voort en doen dit.

1544
01:16:35,580 --> 01:16:38,320
Laat my gaan voort en red
hierdie lêer as stirling.c.

1545
01:16:38,320 --> 01:16:43,255
En dit blyk, kan ons terug skil
een ander laag bloot nou mooi.

1546
01:16:43,255 --> 01:16:45,630
Ek gaan voort en sweep gaan
'n ander program in die belangrikste

1547
01:16:45,630 --> 01:16:49,759
hier wat net weer implemente
string lengte soos volg.

1548
01:16:49,759 --> 01:16:52,300
So hier is 'n reël van die kode wat
kry vir my 'n string van die gebruiker.

1549
01:16:52,300 --> 01:16:53,910
Ons hou die gebruik van hierdie weer en weer.

1550
01:16:53,910 --> 01:16:58,900
Kom ek gee myself 'n veranderlike genoem
N van tipe int dat 'n aantal winkels.

1551
01:16:58,900 --> 01:17:02,490
>> En laat ek gaan voort en
doen die volgende logika.

1552
01:17:02,490 --> 01:17:15,610
Terwyl die n-de karakter in s doen
nie gelyk agteroorskuinsstreep 0, gaan voort

1553
01:17:15,610 --> 01:17:17,930
en inkrementeer N.

1554
01:17:17,930 --> 01:17:23,506
En dan druk printf persent i n.

1555
01:17:23,506 --> 01:17:29,200
Ek beweer dat hierdie program hier,
sonder om tou lengte,

1556
01:17:29,200 --> 01:17:31,150
figure uit die lengte van 'n string.

1557
01:17:31,150 --> 01:17:34,600
>> En die magie is geheel en al
vervat in reël 8

1558
01:17:34,600 --> 01:17:39,830
hier met wat lyk soos 'n nuwe sintaksis,
hierdie agteroorskuinsstreep 0 in aanhalingstekens.

1559
01:17:39,830 --> 01:17:41,360
Maar hoekom is dit?

1560
01:17:41,360 --> 01:17:44,100
Wel, kyk wat was
aangaan al hierdie tyd.

1561
01:17:44,100 --> 01:17:47,990
>> En as 'n eenkant voor ek vergeet, besef
Ook dat bykomend tot die man bladsye

1562
01:17:47,990 --> 01:17:50,920
wat kom met 'n tipiese
Linux stelsel soos CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
besef dat ons, die
personeel loop se, het ook

1564
01:17:53,770 --> 01:17:56,030
het 'n webwerf weergawe
van hierdie selfde idee genoem

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, wat het
al daardie selfde man bladsye,

1566
01:17:59,940 --> 01:18:02,020
al daardie selfde
dokumentasie, asook

1567
01:18:02,020 --> 01:18:05,730
'n bietjie boks aan die bokant wat dit moontlik maak
dankie aan al die redelik omskep

1568
01:18:05,730 --> 01:18:09,025
arcane taal in minder gemaklik
af, waar ons, die dosente,

1569
01:18:09,025 --> 01:18:12,150
deurgemaak en probeer om te vereenvoudig
sommige van die taal om dinge te hou

1570
01:18:12,150 --> 01:18:14,830
gefokus op die idees, en nie
sommige van die tegniese.

1571
01:18:14,830 --> 01:18:20,070
So hou in gedagte, reference.cs50.net
as 'n ander bron as well.

1572
01:18:20,070 --> 01:18:23,800
>> Maar hoekom doen string lengte werk in
die manier waarop ek 'n oomblik gelede voorgestel?

1573
01:18:23,800 --> 01:18:25,160
Hier is die naam Zamyla se weer.

1574
01:18:25,160 --> 01:18:27,690
En hier is die naam Zamyla se
doos in, soos ek hou doen,

1575
01:18:27,690 --> 01:18:31,360
om 'n foto te verf van dit wat,
werklik, net 'n reeks karakters.

1576
01:18:31,360 --> 01:18:34,260
Maar Zamyla bestaan ​​nie
in isolasie in 'n program.

1577
01:18:34,260 --> 01:18:37,420
>> Wanneer jy skryf en hardloop 'n program,
jy gebruik jou Mac of jou rekenaar

1578
01:18:37,420 --> 01:18:40,010
soos geheue, of RAM so te praat.

1579
01:18:40,010 --> 01:18:42,620
En jy kan dink
jou rekenaar as '

1580
01:18:42,620 --> 01:18:44,730
baie GB geheue deesdae.

1581
01:18:44,730 --> 01:18:47,700
En 'n gig beteken biljoene,
sodat miljarde grepe.

1582
01:18:47,700 --> 01:18:48,910
>> Maar laat ons rewind tyd.

1583
01:18:48,910 --> 01:18:51,530
En veronderstel dat ons gebruik
'n baie ou rekenaar wat

1584
01:18:51,530 --> 01:18:55,150
het slegs 32 grepe van die geheue.

1585
01:18:55,150 --> 01:18:59,310
Ek kon, op my rekenaar skerm,
hierdie eenvoudig trek uit soos volg.

1586
01:18:59,310 --> 01:19:05,240
>> Ek kon net sê dat my
rekenaar het al hierdie dinge geheue.

1587
01:19:05,240 --> 01:19:08,830
En dit is soos 'n stok van geheue, indien
jy onthou ons prentjie van die vorige keer.

1588
01:19:08,830 --> 01:19:11,670
En as ek net verdeel
dit in genoeg keer,

1589
01:19:11,670 --> 01:19:15,040
Ek eis dat ek 32 grepe
geheue op die skerm.

1590
01:19:15,040 --> 01:19:18,239
>> Nou, in werklikheid, ek kan net
trek tot dusver op hierdie skerm hier.

1591
01:19:18,239 --> 01:19:20,280
So ek gaan om voort te gaan,
en net deur konvensie,

1592
01:19:20,280 --> 01:19:24,050
trek geheue my rekenaar se as 'n
rooster, nie net as een reguit lyn.

1593
01:19:24,050 --> 01:19:28,190
Spesifiek, ek eis nou dat
hierdie rooster, hierdie 8 deur 4 rooster,

1594
01:19:28,190 --> 01:19:31,800
net verteenwoordig al 32 grepe
geheue beskikbaar in my Mac,

1595
01:19:31,800 --> 01:19:33,030
of in my rekenaar.

1596
01:19:33,030 --> 01:19:34,780
En hulle wikkel
op twee lyne, net

1597
01:19:34,780 --> 01:19:38,030
want dit pas meer op die skerm.

1598
01:19:38,030 --> 01:19:40,800
Maar dit is die eerste byte.

1599
01:19:40,800 --> 01:19:41,990
Dit is die tweede greep.

1600
01:19:41,990 --> 01:19:43,300
Dit is die derde byte.

1601
01:19:43,300 --> 01:19:45,310
>> En dit is die 32 byte.

1602
01:19:45,310 --> 01:19:52,910
Of, as ons dink soos 'n rekenaar
wetenskaplike, dit is byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
So jy het 0-31, indien
jy begin tel by 0.

1604
01:19:55,950 --> 01:19:59,830
>> So as ons 'n program gebruik
dat oproepe kry string,

1605
01:19:59,830 --> 01:20:05,280
en ons kry 'n string van die menslike
soos ek het Zamyla genoem, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
hoe in die wêreld werk die
rekenaar Bly op hoogte van wat byte,

1607
01:20:09,430 --> 01:20:12,230
wat deel van die geheue,
behoort aan watter string?

1608
01:20:12,230 --> 01:20:16,270
Met ander woorde, as ons voortgaan om
tik 'n ander naam in die rekenaar,

1609
01:20:16,270 --> 01:20:19,890
soos hierdie Andi, roep
kry string 'n tweede keer,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-ek het om te eindig in die
rekenaar se geheue sowel.

1611
01:20:23,030 --> 01:20:23,850
Maar hoe?

1612
01:20:23,850 --> 01:20:29,700
>> Wel, dit blyk dat onder die
kap, wat C doen wanneer die stoor van snare

1613
01:20:29,700 --> 01:20:35,080
dat die menslike tipes in, of wat
kom uit 'n ander bron, is dit

1614
01:20:35,080 --> 01:20:39,190
skets die einde van hulle met
'n spesiale character-- agteroorskuinsstreep

1615
01:20:39,190 --> 01:20:44,750
0, wat net 'n manier
sê 80 stukkies in 'n ry.

1616
01:20:44,750 --> 01:20:47,950
>> So A-- is hierdie die getal 97 herroep.

1617
01:20:47,950 --> 01:20:51,770
So 'n paar patroon van 8 bisse
verteenwoordig desimale getal 97.

1618
01:20:51,770 --> 01:20:58,070
Dit agteroorskuinsstreep 0 is letterlik die getal
0, ook bekend as nul, N-U-L, in teenstelling met vroeër,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, wat ons gepraat oor.

1620
01:20:59,630 --> 01:21:05,700
Maar vir nou, net weet dat dit
agteroorskuinsstreep 0 is net 80 stukkies in 'n ry.

1621
01:21:05,700 --> 01:21:09,810
>> En dit is net hierdie lyn in die
sand wat niks sê aan die linkerkant

1622
01:21:09,810 --> 01:21:12,610
behoort aan een string, of een datatipe.

1623
01:21:12,610 --> 01:21:15,480
En enigiets tot die reg
behoort aan iets anders.

1624
01:21:15,480 --> 01:21:17,440
Andi se naam, intussen,
wat net visueel

1625
01:21:17,440 --> 01:21:21,310
gebeur met op draai na die ander lyn,
maar dit is net 'n estetiese detail,

1626
01:21:21,310 --> 01:21:23,990
Net so is nul beëindig.

1627
01:21:23,990 --> 01:21:29,290
>> Dit is 'n string van 'n A-N-D-Ek karakters,
plus 'n vyfde geheime karakter,

1628
01:21:29,290 --> 01:21:33,560
alle 0 stukkies, wat net afbaken
die einde van naam Andi se sowel.

1629
01:21:33,560 --> 01:21:37,120
En as ons 'n beroep te kry string 'n derde keer
in die rekenaar na 'n string soos kry

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-ek-A, insgelyks is Maria se
naam nul beëindig met agteroorskuinsstreep 0.

1631
01:21:44,210 --> 01:21:47,170
>> Dit is fundamenteel verskil
van hoe 'n rekenaar sou tipies

1632
01:21:47,170 --> 01:21:51,850
stoor 'n heelgetal, of 'n vlot, of ander
datatipes nog, want onthou,

1633
01:21:51,850 --> 01:21:57,420
'n heelgetal is gewoonlik 32 stukkies, of
4 grepe, of miskien selfs 64 stukkies,

1634
01:21:57,420 --> 01:21:59,100
of agt grepe.

1635
01:21:59,100 --> 01:22:02,620
Maar baie primitiewe in 'n rekenaar
in 'n programmeertaal

1636
01:22:02,620 --> 01:22:05,550
'n vaste aantal
grepe onder die hood--

1637
01:22:05,550 --> 01:22:08,100
Miskien 1, miskien 2, miskien 4, miskien 8.

1638
01:22:08,100 --> 01:22:13,250
>> Maar snare, deur ontwerp, 'n
dinamiese aantal karakters.

1639
01:22:13,250 --> 01:22:16,980
Jy hoef nie vooraf weet, totdat
die menslike tipes in Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
of M-A-R-ek-A, of A-N-D-ek. Jy weet nie
hoeveel keer die gebruiker gaan tref

1641
01:22:21,400 --> 01:22:22,070
die sleutelbord.

1642
01:22:22,070 --> 01:22:26,490
Daarom, het jy nie weet hoe
baie karakters by voorbaat

1643
01:22:26,490 --> 01:22:27,540
jy gaan benodig.

1644
01:22:27,540 --> 01:22:31,840
>> En so C net soort van blare soos 'n
geheime bread onder die enjinkap

1645
01:22:31,840 --> 01:22:32,960
aan die einde van die tou.

1646
01:22:32,960 --> 01:22:39,280
Na stoor Z-A-M-Y-L-A in die geheue,
dit ook sit net die ekwivalent

1647
01:22:39,280 --> 01:22:40,210
van 'n tydperk.

1648
01:22:40,210 --> 01:22:45,060
Aan die einde van 'n sin,
dit sit 80 stukkies, sodat

1649
01:22:45,060 --> 01:22:49,120
om te onthou waar
Zamyla begin en eindig.

1650
01:22:49,120 --> 01:22:51,490
>> So, wat is die verband,
dan, om hierdie program?

1651
01:22:51,490 --> 01:22:55,190
Hierdie program hier, Stirling,
is bloot 'n meganisme

1652
01:22:55,190 --> 01:22:57,970
vir die kry van 'n string
van die gebruiker, reël 6.

1653
01:22:57,970 --> 01:23:01,160
Line 7, Ek verklaar 'n veranderlike
genoem N en stel dit gelyk aan 0.

1654
01:23:01,160 --> 01:23:08,680
>> En dan in reël 8, ek net vra die
vraag, terwyl die n-de karakter doen

1655
01:23:08,680 --> 01:23:12,120
nie gelyk al 0 bits--
Met ander woorde, nie

1656
01:23:12,120 --> 01:23:14,500
gelyke hierdie spesiale
karakter, agteroorskuinsstreep 0, wat

1657
01:23:14,500 --> 01:23:18,470
was net daardie spesiale nul character--
gaan voort en net inkrementeer N.

1658
01:23:18,470 --> 01:23:21,460
>> En hou om dit te doen, en hou
doen dit, en hou om dit te doen.

1659
01:23:21,460 --> 01:23:23,430
En so selfs al in
die verlede het ons het ek gebruik,

1660
01:23:23,430 --> 01:23:25,181
dit is heeltemal fyn
semanties na N gebruik,

1661
01:23:25,181 --> 01:23:27,430
as jy net probeer om
tel dié keer met opset,

1662
01:23:27,430 --> 01:23:28,720
en net wil om dit N bel.

1663
01:23:28,720 --> 01:23:34,720
So dit hou net vra die vraag,
is die n-de karakter van alles 0e?

1664
01:23:34,720 --> 01:23:38,470
Indien nie, kyk na die volgende kyk,
kyk na die volgende, kyk na die volgende,

1665
01:23:38,470 --> 01:23:39,460
kyk na die volgende.

1666
01:23:39,460 --> 01:23:45,540
>> Maar so gou as wat jy sien agteroorskuinsstreep 0,
hierdie loop-- reël 9 deur 11-- stop.

1667
01:23:45,540 --> 01:23:49,640
Jy breek uit die while lus,
verlaat binnekant van daardie veranderlike N

1668
01:23:49,640 --> 01:23:54,530
'n totale telling van al die
karakters in die string wat jy gesien het,

1669
01:23:54,530 --> 01:23:55,660
sodoende druk dit uit.

1670
01:23:55,660 --> 01:23:56,760
So kom ons probeer dit.

1671
01:23:56,760 --> 01:23:59,500
>> Laat my gaan voort en sonder
met behulp van die Stirling funksie,

1672
01:23:59,500 --> 01:24:04,240
maar net met my eie bodem weergawe
hier genoem Stirling, laat my gaan voort

1673
01:24:04,240 --> 01:24:07,700
en hardloop Stirling, tik in iets
soos Zamyla, wat ek weet by voorbaat

1674
01:24:07,700 --> 01:24:08,670
is ses karakters.

1675
01:24:08,670 --> 01:24:10,080
Kom ons kyk of dit werk.

1676
01:24:10,080 --> 01:24:10,920
Inteendeel, dit is ses.

1677
01:24:10,920 --> 01:24:15,257
Kom ons probeer met Rob, drie karakters,
drie karakters so goed, en so meer.

1678
01:24:15,257 --> 01:24:17,340
So dit is al wat gaan
op onder die enjinkap.

1679
01:24:17,340 --> 01:24:19,548
En let op die verbindings,
dan, met die eerste week

1680
01:24:19,548 --> 01:24:22,370
van die klas, waar het ons gepraat oor
iets soos abstraksie,

1681
01:24:22,370 --> 01:24:26,960
wat net hierdie lae van idees, of
kompleksiteit, op die top van basiese beginsels.

1682
01:24:26,960 --> 01:24:30,710
Hier is ons soort soek
onder die enjinkap van Stirling,

1683
01:24:30,710 --> 01:24:33,510
om so te praat, om uit te vind,
hoe sou dit geïmplementeer word?

1684
01:24:33,510 --> 01:24:35,232
>> En ons kan weer implementeer dit self.

1685
01:24:35,232 --> 01:24:37,440
Maar ons het nooit weer aan die gang
om weer te implementeer Stirling.

1686
01:24:37,440 --> 01:24:39,780
Ons is net gaan
gebruik Stirling ten einde

1687
01:24:39,780 --> 01:24:42,100
om werklik kry 'n paar snare lengte.

1688
01:24:42,100 --> 01:24:44,200
>> Maar daar is geen magic
onder die enjinkap.

1689
01:24:44,200 --> 01:24:46,716
As jy weet dat onder
die enjinkap, 'n string

1690
01:24:46,716 --> 01:24:48,090
is net 'n reeks karakters.

1691
01:24:48,090 --> 01:24:51,090
En daardie volgorde van karakters
al kan numeries word

1692
01:24:51,090 --> 01:24:53,330
met bracket 0, bracket
1, bracket 2, en jy

1693
01:24:53,330 --> 01:24:57,420
weet dat aan die einde van 'n string is 'n
spesiale karakter, kan jy uitvind

1694
01:24:57,420 --> 01:25:01,710
hoe om die meeste enigiets in 'n doen
program, want al is dit kom neer op

1695
01:25:01,710 --> 01:25:03,400
lees en skryf geheue.

1696
01:25:03,400 --> 01:25:06,130
Dit is, verander en soek
op geheue, of beweeg dinge

1697
01:25:06,130 --> 01:25:10,940
rond in die geheue, druk dinge
op die skerm, en dies meer.

1698
01:25:10,940 --> 01:25:14,800
>> So laat ons nou hierdie nuutgevonde gebruik
begrip van wat eintlik snare

1699
01:25:14,800 --> 01:25:17,910
is onder die enjinkap, en
skil terug een ander laag

1700
01:25:17,910 --> 01:25:20,080
wat tot nou toe het ons
is ignoreer geheel en al.

1701
01:25:20,080 --> 01:25:22,650
In die besonder, enige tyd
Ons het 'n program geïmplementeer word,

1702
01:25:22,650 --> 01:25:25,930
Ons het hierdie reël van die kode het
naby die top verklaar belangrikste.

1703
01:25:25,930 --> 01:25:27,810
En ons het int main leemte verskaf.

1704
01:25:27,810 --> 01:25:31,240
>> En daardie leemte binne die hakies
is gesê al die tyd wat hoof

1705
01:25:31,240 --> 01:25:33,440
self nie enige argumente te neem.

1706
01:25:33,440 --> 01:25:36,210
Enige insette wat hoof is
gaan van die gebruiker te kry

1707
01:25:36,210 --> 01:25:39,020
het van 'n ander te kom
meganisme, soos get int,

1708
01:25:39,020 --> 01:25:42,040
of kry vlot, of kry string,
of 'n ander funksie.

1709
01:25:42,040 --> 01:25:44,710
Maar dit blyk dat
wanneer jy skryf 'n program,

1710
01:25:44,710 --> 01:25:47,690
jy kan eintlik spesifiseer
dat hierdie program sal

1711
01:25:47,690 --> 01:25:51,730
neem insette van die menslike
op die command line self.

1712
01:25:51,730 --> 01:25:56,310
>> Met ander woorde, selfs al het ons tot dusver
is net hardloop ./hello hallo

1713
01:25:56,310 --> 01:26:00,312
of soortgelyke programme, al die
ander programme wat ons het al met behulp,

1714
01:26:00,312 --> 01:26:02,770
dat ons onsself nie te skryf,
gewees het om, dit lyk,

1715
01:26:02,770 --> 01:26:05,210
command line arguments--
dinge soos te maak.

1716
01:26:05,210 --> 01:26:07,450
Jy sê iets soos make,
en dan 'n tweede woord.

1717
01:26:07,450 --> 01:26:10,950
Of klang, sê jy kletteren, en dan
'n tweede woord, die naam van 'n lêer.

1718
01:26:10,950 --> 01:26:14,410
>> Of selfs RM of CP, as jy dalk
gesien of reeds gebruik

1719
01:26:14,410 --> 01:26:15,880
om te verwyder of 'n afskrif lêers.

1720
01:26:15,880 --> 01:26:18,920
Al diegene neem sogenaamde
command line arguments--

1721
01:26:18,920 --> 01:26:21,130
addisionele woorde op die terminale vinnige.

1722
01:26:21,130 --> 01:26:23,260
Maar tot nou toe, ons
onsself het nie

1723
01:26:23,260 --> 01:26:27,080
hierdie luukse van die neem van die insette van die
gebruiker wanneer hy of sy eintlik loop

1724
01:26:27,080 --> 01:26:29,120
die program self by die command line.

1725
01:26:29,120 --> 01:26:33,710
>> Maar ons kan dit doen deur weer verklaar
hoof vorentoe beweeg, nie as '

1726
01:26:33,710 --> 01:26:36,750
leemte in hakies,
maar hierdie twee argumente

1727
01:26:36,750 --> 01:26:40,600
instead-- die eerste 'n heelgetal,
en die tweede iets

1728
01:26:40,600 --> 01:26:44,170
nuwe, iets wat ons gaan om te bel
'n skikking, iets soortgelyks in die gees

1729
01:26:44,170 --> 01:26:49,220
wat ons gesien het in Scratch as 'n lys, maar
'n verskeidenheid van snare, soos ons sal gou sien.

1730
01:26:49,220 --> 01:26:51,790
Maar laat ons sien dit deur
Ter illustrasie, voordat ons

1731
01:26:51,790 --> 01:26:53,690
onderskei presies wat dit beteken.

1732
01:26:53,690 --> 01:26:56,520
>> So as ek gaan in CS50 IDE
hier het ek vooruit gegaan

1733
01:26:56,520 --> 01:27:01,840
en verklaar in 'n lêer met die naam
argv0.c die volgende sjabloon.

1734
01:27:01,840 --> 01:27:04,120
En sien die enigste ding
dit is verskillende dusver

1735
01:27:04,120 --> 01:27:08,570
is dat ek leemte het verander na int
argc string argv oop bracket, naby

1736
01:27:08,570 --> 01:27:09,070
bracket.

1737
01:27:09,070 --> 01:27:11,730
En sien vir nou, is daar '
niks binnekant van die hakies.

1738
01:27:11,730 --> 01:27:12,620
>> Daar is ontelbaar.

1739
01:27:12,620 --> 01:27:15,070
En daar is geen Ek, of
N, of enige ander brief.

1740
01:27:15,070 --> 01:27:17,010
Ek is net die gebruik van die
vierkantige hakies vir nou,

1741
01:27:17,010 --> 01:27:19,510
om redes wat ons sal kom
terug in net 'n oomblik.

1742
01:27:19,510 --> 01:27:21,330
>> En nou wat ek gaan doen, is hierdie.

1743
01:27:21,330 --> 01:27:26,680
As argc gelyk gelyk 2--
en onthou dat gelykes gelyk

1744
01:27:26,680 --> 01:27:30,040
is die operateur gelykheid te vergelyk
links en regs vir gelykheid.

1745
01:27:30,040 --> 01:27:31,790
Dit is nie die opdrag
operateur, wat

1746
01:27:31,790 --> 01:27:36,510
die enkele gelykaanteken wat afskrif beteken
van die reg om links bietjie waarde.

1747
01:27:36,510 --> 01:27:42,840
>> As argc gelyk gelyk 2, ek wil
sê, printf, hello, Procenten, nuwe lyn,

1748
01:27:42,840 --> 01:27:47,340
en dan prop in-- en hier is die nuwe
trick-- argv bracket 1, vir redes

1749
01:27:47,340 --> 01:27:48,840
dat ons terug in 'n oomblik sal kom.

1750
01:27:48,840 --> 01:27:52,110
Anders as argc nie doen
gelyke 2, jy weet wat?

1751
01:27:52,110 --> 01:27:57,400
Kom ons gaan voort en, soos gewoonlik, druk
uit hello world met geen vervanging.

1752
01:27:57,400 --> 01:28:02,710
>> So dit blyk dat indien argc, wat
staan ​​vir argument tel, is gelyk aan 2,

1753
01:28:02,710 --> 01:28:04,740
Ek gaan om uit te druk
hallo iets of ander.

1754
01:28:04,740 --> 01:28:07,560
Andersins, by verstek, ek is
gaan hallo druk wêreld.

1755
01:28:07,560 --> 01:28:08,770
So wat beteken dit?

1756
01:28:08,770 --> 01:28:15,550
>> Wel, laat ek gaan voort en red
hierdie lêer, en dan doen maak argv0,

1757
01:28:15,550 --> 01:28:18,940
en dan ./argv0, Tik.

1758
01:28:18,940 --> 01:28:20,300
En dit sê hello world.

1759
01:28:20,300 --> 01:28:21,260
Nou, hoekom is dit?

1760
01:28:21,260 --> 01:28:24,730
>> Wel, dit blyk wanneer jy
hardloop 'n program na die command line,

1761
01:28:24,730 --> 01:28:29,570
jy vul wat ons sal
oor die algemeen noem 'n argument vektor.

1762
01:28:29,570 --> 01:28:33,100
Met ander woorde, outomaties die
rekenaar, die bedryfstelsel,

1763
01:28:33,100 --> 01:28:38,340
gaan hand aan jou program
self 'n lys van al die woorde

1764
01:28:38,340 --> 01:28:40,850
dat die menslike getik op
die vinnige, in die geval dat jy

1765
01:28:40,850 --> 01:28:43,790
die programmeerder wil doen
iets met daardie inligting.

1766
01:28:43,790 --> 01:28:48,540
En in hierdie geval, die enigste woord
Ek het getik op die instruksielyn is ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> En so het die aantal argumente wat
oorgedra word na my program is net een.

1768
01:28:55,420 --> 01:28:58,880
Met ander woorde, die argument
tel, andersins bekend as argc

1769
01:28:58,880 --> 01:29:00,970
hier as 'n heelgetal, is net een.

1770
01:29:00,970 --> 01:29:03,000
Een, natuurlik, is nie gelyk aan twee.

1771
01:29:03,000 --> 01:29:05,980
En so dit is wat druk, hello world.

1772
01:29:05,980 --> 01:29:08,170
>> Maar laat ek dit iewers te neem.

1773
01:29:08,170 --> 01:29:09,930
Laat my sê, argv0.

1774
01:29:09,930 --> 01:29:12,740
En dan hoe oor Maria?

1775
01:29:12,740 --> 01:29:14,990
En dan druk Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Kyk wat mettertyd gebeur hier.

1777
01:29:18,020 --> 01:29:22,640
Nou, in plaas van Hello World, ek het
verander die gedrag van hierdie program

1778
01:29:22,640 --> 01:29:26,310
deur die neem van die insette nie uit kry
tou of 'n ander funksie,

1779
01:29:26,310 --> 01:29:30,570
maar uit, blykbaar, my opdrag
self, wat ek oorspronklik getik.

1780
01:29:30,570 --> 01:29:35,720
En ek kan dit spel te speel deur
om dit te verander na Stelios, byvoorbeeld.

1781
01:29:35,720 --> 01:29:38,400
>> En nou sien ek nog 'n ander naam.

1782
01:29:38,400 --> 01:29:40,540
En hier, kan ek sê Andi.

1783
01:29:40,540 --> 01:29:42,137
En ek kan sê Zamyla.

1784
01:29:42,137 --> 01:29:45,220
En ons kan hierdie spel te speel die hele dag lank,
net steek in verskillende waardes,

1785
01:29:45,220 --> 01:29:49,550
so lank as wat ek gee presies
twee woorde op die instruksielyn,

1786
01:29:49,550 --> 01:29:52,260
sodanig dat argc, my argument tel, is 2.

1787
01:29:52,260 --> 01:29:57,240
>> Sien ek daardie naam ingeprop
printf, per hierdie toestand hier?

1788
01:29:57,240 --> 01:30:00,550
So lyk ons ​​nou
die ekspressiewe vermoë

1789
01:30:00,550 --> 01:30:04,410
van die neem van die insette van 'n ander meganisme,
van die sogenaamde command line,

1790
01:30:04,410 --> 01:30:07,000
eerder as om te wag
totdat die gebruiker die program,

1791
01:30:07,000 --> 01:30:10,220
en dan gevra hom of haar
die gebruik van so iets kry string.

1792
01:30:10,220 --> 01:30:11,230
>> So, wat is dit?

1793
01:30:11,230 --> 01:30:15,010
Argc, weer, is net 'n heelgetal,
die aantal words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
dat die gebruiker verskaf aan die
vinnige, by die venster terminale,

1795
01:30:18,540 --> 01:30:20,110
insluitend die naam van die program.

1796
01:30:20,110 --> 01:30:23,340
So ons ./argv0 is, effektief,
naam van die program,

1797
01:30:23,340 --> 01:30:24,520
of hoe ek hardloop die program.

1798
01:30:24,520 --> 01:30:25,810
>> Dit tel as 'n woord.

1799
01:30:25,810 --> 01:30:27,080
So argc sou wees 1.

1800
01:30:27,080 --> 01:30:29,750
Maar toe ek skryf Stelios, of
Andi, of Zamyla, of Maria,

1801
01:30:29,750 --> 01:30:31,660
dit beteken dat die argument telling is twee.

1802
01:30:31,660 --> 01:30:33,910
En so nou is daar twee woorde geslaag.

1803
01:30:33,910 --> 01:30:36,070
>> En kennis, kan ons hierdie logika voortgaan.

1804
01:30:36,070 --> 01:30:39,050
As ek eintlik sê
iets soos Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
'n volle naam en sodoende verby
drie argumente in totaal,

1806
01:30:42,200 --> 01:30:47,410
Nou is dit sê die verstek weer,
want, natuurlik, 3 is nie gelyk aan 2.

1807
01:30:47,410 --> 01:30:54,080
>> En so op hierdie manier, moet ek
toegang via argv hierdie nuwe argument

1808
01:30:54,080 --> 01:30:56,080
dat ons kan tegnies
noem enigiets wat ons wil.

1809
01:30:56,080 --> 01:30:58,940
Maar deur konvensie, dis
argv en argc, onderskeidelik.

1810
01:30:58,940 --> 01:31:04,470
Argv, argument vektor, is 'n soort
van 'n sinoniem vir 'n programmeertaal

1811
01:31:04,470 --> 01:31:07,140
funksie in C genoem 'n skikking.

1812
01:31:07,140 --> 01:31:14,410
>> 'N skikking is 'n lys van soortgelyke waardes
terug, na agter, na agter, om terug te.

1813
01:31:14,410 --> 01:31:17,810
Met ander woorde, as 'n mens hier in is
RAM, die volgende een is reg langs dit,

1814
01:31:17,810 --> 01:31:18,800
en reg langs dit.

1815
01:31:18,800 --> 01:31:20,101
Hulle is nie oor die hele plek.

1816
01:31:20,101 --> 01:31:23,100
En dat laasgenoemde scenario, waar dinge
is oor die hele plek in die geheue,

1817
01:31:23,100 --> 01:31:25,082
kan eintlik 'n kragtige funksie wees.

1818
01:31:25,082 --> 01:31:28,040
Maar ons sal terug te kom na dat wanneer ons
praat oor liefhebber datastrukture.

1819
01:31:28,040 --> 01:31:32,260
Vir nou, 'n skikking is net 'n
stuk van aangrensende geheue,

1820
01:31:32,260 --> 01:31:36,520
elkeen van wie elemente
terug, na agter, na agter, na agter,

1821
01:31:36,520 --> 01:31:38,050
en oor die algemeen dieselfde tipe.

1822
01:31:38,050 --> 01:31:42,630
>> So as jy dink oor, uit 'n
oomblik gelede, wat is 'n string?

1823
01:31:42,630 --> 01:31:50,460
Wel, 'n string, soos Zamyla,
Z-A-M-Y-L-A, is, tegnies,

1824
01:31:50,460 --> 01:31:51,400
net 'n skikking.

1825
01:31:51,400 --> 01:31:53,700
Dit is 'n verskeidenheid van karakters.

1826
01:31:53,700 --> 01:31:59,250
>> En so as ons regtig hierdie teken, soos ek
het vroeër, as 'n deel van die geheue,

1827
01:31:59,250 --> 01:32:04,510
dit blyk dat elkeen van hierdie
karakters neem 'n greep.

1828
01:32:04,510 --> 01:32:07,630
En dan is daar daardie spesiale
Sentinel karakter, die agteroorskuinsstreep 0,

1829
01:32:07,630 --> 01:32:12,360
of al agt 0 stukkies, wat
afbaken die einde van daardie string.

1830
01:32:12,360 --> 01:32:15,090
So 'n string, dit blyk
uit, haal unquote string,

1831
01:32:15,090 --> 01:32:20,580
is net 'n verskeidenheid van chara--
char wat 'n werklike data tipe.

1832
01:32:20,580 --> 01:32:24,560
>> En nou argv, meanwhile--
Kom ons terug na die program gaan.

1833
01:32:24,560 --> 01:32:29,582
Argv, selfs al het ons die woord sien
string hier, is nie 'n string self.

1834
01:32:29,582 --> 01:32:33,640
Argv, argument vektor,
is 'n verskeidenheid van snare.

1835
01:32:33,640 --> 01:32:37,620
>> So net soos jy 'n verskeidenheid van kan hê
karakters, kan jy 'n hoër vlak te hê,

1836
01:32:37,620 --> 01:32:46,279
'n verskeidenheid van strings-- so, byvoorbeeld,
toe ek getik n oomblik gelede ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, ruimte Z-A-M-Y-L-A, ek het beweer dat
argv het twee stringe in it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
en Z-A-M-Y-L-A. in
ander woorde, argc was 2.

1839
01:33:03,185 --> 01:33:03,980
Hoekom is dit?

1840
01:33:03,980 --> 01:33:08,370
>> Wel, effektief, wat gaan
op dat elk van hierdie snare

1841
01:33:08,370 --> 01:33:13,990
is, natuurlik, 'n verskeidenheid van karakters
soos voorheen, elkeen van wie karakters

1842
01:33:13,990 --> 01:33:15,670
neem een ​​byte.

1843
01:33:15,670 --> 01:33:19,720
En moenie verwar die werklike 0
in die naam van die program se aan die 0,

1844
01:33:19,720 --> 01:33:22,040
wat beteken al 80 stukkies.

1845
01:33:22,040 --> 01:33:27,140
En Zamyla, intussen, is nog steeds
ook 'n verskeidenheid van karakters.

1846
01:33:27,140 --> 01:33:31,450
>> So aan die einde van die dag, is dit regtig
lyk soos volg onder die enjinkap.

1847
01:33:31,450 --> 01:33:38,800
Maar argv, deur die natuur van hoe groot
werke, laat my toe om al hierdie dinge te draai

1848
01:33:38,800 --> 01:33:44,810
up in, as jy wil, 'n groter verskeidenheid
dat, as ons 'n bietjie meer as vereenvoudig

1849
01:33:44,810 --> 01:33:48,180
wat die prentjie lyk en doen nie
nogal trek dit volgens skaal tot daar,

1850
01:33:48,180 --> 01:33:56,720
hierdie verskeidenheid is slegs van grootte 2, die eerste
element waarvan 'n string bevat,

1851
01:33:56,720 --> 01:33:59,230
die tweede element van
wat bevat 'n string.

1852
01:33:59,230 --> 01:34:01,687
En op sy beurt, as jy
soort zoom in op elke

1853
01:34:01,687 --> 01:34:03,770
van daardie snare, wat jy
sien onder die enjinkap

1854
01:34:03,770 --> 01:34:07,190
is dat elke string is net
'n verskeidenheid van karakters.

1855
01:34:07,190 --> 01:34:11,680
>> Nou, net soos met snare,
ons was in staat om toegang te kry

1856
01:34:11,680 --> 01:34:15,260
om die i-de karakter in 'n string
die gebruik van daardie vierkantige hakienotasie.

1857
01:34:15,260 --> 01:34:17,320
Net so, met skikkings
In die algemeen kan ons

1858
01:34:17,320 --> 01:34:22,700
gebruik vierkante hakienotasie te kry
te eniger aantal snare in 'n skikking?

1859
01:34:22,700 --> 01:34:25,100
Byvoorbeeld, laat my
gaan voort en doen dit.

1860
01:34:25,100 --> 01:34:32,420
>> Laat my gaan voort en skep argv1.c,
wat is 'n bietjie anders hierdie keer.

1861
01:34:32,420 --> 01:34:35,635
In plaas daarvan om die nagaan vir argc2,
Ek gaan hierdie plaas doen.

1862
01:34:35,635 --> 01:34:41,270
Vir int ek 0, ek is minder
as argc, ek plus plus,

1863
01:34:41,270 --> 01:34:47,920
en dan druk binnekant van hierdie,
persent s, nuwe lyn, en dan

1864
01:34:47,920 --> 01:34:50,740
argv bracket i.

1865
01:34:50,740 --> 01:34:55,220
>> So met ander woorde, ek is nie die hantering van
individuele karakters op die oomblik.

1866
01:34:55,220 --> 01:35:00,190
Argv, soos geïmpliseer deur hierdie leë vierkant
draadjies aan die regterkant van die naam argv,

1867
01:35:00,190 --> 01:35:03,320
beteken argv is 'n verskeidenheid van snare.

1868
01:35:03,320 --> 01:35:04,870
En argc is net 'n int.

1869
01:35:04,870 --> 01:35:08,800
>> Hierdie reël hier, 6, is
sê stel ek gelyk aan 0.

1870
01:35:08,800 --> 01:35:11,980
Tel al die pad tot by,
maar nie insluitend, argc.

1871
01:35:11,980 --> 01:35:14,010
En dan op elke iterasie,
druk 'n string.

1872
01:35:14,010 --> 01:35:14,800
Wat string?

1873
01:35:14,800 --> 01:35:17,270
>> Die i-de string in argv.

1874
01:35:17,270 --> 01:35:19,530
So terwyl voordat ek was
met behulp van die vierkante hakies

1875
01:35:19,530 --> 01:35:22,180
notasie te kry by die ith
karakter in 'n string, nou

1876
01:35:22,180 --> 01:35:27,240
Ek gebruik die bracket vierkante notasie
uit te kom by die et string in 'n skikking.

1877
01:35:27,240 --> 01:35:30,310
So dit is soort van 'n laag
bo, konseptueel.

1878
01:35:30,310 --> 01:35:35,390
>> En so wat is netjies oor hierdie
program nou, as ek stel argv1,

1879
01:35:35,390 --> 01:35:42,067
en dan doen ./argv1 en tik
in iets soos cat bar Baz,

1880
01:35:42,067 --> 01:35:45,400
wat die drie standaard woorde wat 'n is
rekenaarwetenskaplike bereik vir enige tyd

1881
01:35:45,400 --> 01:35:51,010
hy of sy moet 'n paar tydelike woorde,
en druk Enter, elk van hierdie woorde,

1882
01:35:51,010 --> 01:35:54,980
insluitend die naam van die program se, wat
is in argv op die eerste plek,

1883
01:35:54,980 --> 01:35:58,320
beland gedruk een op 'n slag.

1884
01:35:58,320 --> 01:36:05,290
En as ek dit verander, en ek sê
iets soos argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
Ons kry al drie van dié
woorde, wat is argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, want in hierdie
geval argc, die telling, is 3.

1887
01:36:14,400 --> 01:36:20,020
>> Maar wat is netjies is as jy verstaan
dat argv is net 'n verskeidenheid van snare,

1888
01:36:20,020 --> 01:36:24,910
en jy verstaan ​​dat 'n string
is 'n verskeidenheid van karakters,

1889
01:36:24,910 --> 01:36:29,470
Ons kan eintlik soort van hierdie gebruik
vierkante hakienotasie verskeie kere

1890
01:36:29,470 --> 01:36:33,320
'n string te kies, en kies dan
'n karakter in die string,

1891
01:36:33,320 --> 01:36:35,730
duik in dieper as volg.

1892
01:36:35,730 --> 01:36:40,100
In hierdie voorbeeld, dat ek kan gaan
voort en noem dit argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
En in hierdie voorbeeld, laat my gaan voort
en doen die following-- vir int i kry 0,

1895
01:36:50,180 --> 01:36:53,286
Ek is minder as argc, ek plus
plus, net soos voorheen.

1896
01:36:53,286 --> 01:36:55,910
So met ander words-- en nou hierdie
raak ingewikkeld genoeg.

1897
01:36:55,910 --> 01:36:59,940
Toe ek gaan om te sê
Itereer oor snare in argv,

1898
01:36:59,940 --> 01:37:01,294
as 'n kommentaar by myself.

1899
01:37:01,294 --> 01:37:03,960
En dan gaan ek 'n moet
geneste for-lus, wat jy waarskynlik

1900
01:37:03,960 --> 01:37:06,290
gedoen het, of oorweeg
doen, in Scratch, waar

1901
01:37:06,290 --> 01:37:08,600
Ek gaan om te sê int-- Ek is
nie van plan om ek weer gebruik,

1902
01:37:08,600 --> 01:37:12,590
want ek wil nie skaduwee, of
soort vervang die bestaande ek.

1903
01:37:12,590 --> 01:37:15,780
>> Ek gaan, in plaas daarvan, sê j, omdat
dit is my go om veranderlike nadat ek,

1904
01:37:15,780 --> 01:37:18,590
wanneer ek net probeer om
tel eenvoudige getalle.

1905
01:37:18,590 --> 01:37:28,850
Vir j kry 0-- en ook, N, gaan
kry die Stern lengte van argv bracket ek,

1906
01:37:28,850 --> 01:37:36,030
so lank as wat j is minder as m,
j plus plus, doen die volgende.

1907
01:37:36,030 --> 01:37:37,500
En hier is die interessante deel.

1908
01:37:37,500 --> 01:37:46,330
>> Druk 'n karakter en 'n nuwe lyn,
steek in argv bracket ek, bracket j.

1909
01:37:46,330 --> 01:37:47,940
OK, so laat my 'n paar opmerkings hier by te voeg.

1910
01:37:47,940 --> 01:37:54,820
Itereer oor karakters
in die huidige reeks,

1911
01:37:54,820 --> 01:38:02,290
Druk j-de karakter in i-de string.

1912
01:38:02,290 --> 01:38:04,630
So nou, laat ons kyk na
wat hierdie kommentaar beteken.

1913
01:38:04,630 --> 01:38:06,750
>> Itereer oor die snare
in argv-- hoeveel

1914
01:38:06,750 --> 01:38:09,300
snare is in argv, wat is 'n skikking?

1915
01:38:09,300 --> 01:38:13,420
Argc baie, so ek iterating
uit dat Ek net so 0 tot argc.

1916
01:38:13,420 --> 01:38:20,020
Intussen het hoeveel karakters
is in die i-de string in argv?

1917
01:38:20,020 --> 01:38:22,880
>> Wel, om die antwoord te kry,
Ek bel string lengte

1918
01:38:22,880 --> 01:38:26,810
op die huidige string Ek sorg
oor wat argv bracket i.

1919
01:38:26,810 --> 01:38:30,090
En ek gaan om tydelik te stoor wat
waarde in N, net vir caching doeleindes,

1920
01:38:30,090 --> 01:38:31,590
om dit te onthou vir doeltreffendheid.

1921
01:38:31,590 --> 01:38:36,330
En dan gaan ek inisialiseer j tot 0,
die gang te hou so lank as j is minder as N,

1922
01:38:36,330 --> 01:38:38,430
en op elke iterasie inkrement j.

1923
01:38:38,430 --> 01:38:41,030
>> En dan hier, per
my kommentaar op die lyn 12,

1924
01:38:41,030 --> 01:38:43,390
druk 'n karakter,
gevolg deur 'n nuwe lyn,

1925
01:38:43,390 --> 01:38:48,140
spesifiek argv bracket
Ek gee my die i-de string

1926
01:38:48,140 --> 01:38:51,690
in argv-- so die eerste woord, die
tweede woord, die derde woord, wat ook al.

1927
01:38:51,690 --> 01:38:57,370
En dan j duik dieper en kry
my die j-de karakter van daardie woord.

1928
01:38:57,370 --> 01:39:02,200
En so, in effek, jy kan hanteer
argv as 'n multi-dimensionele,

1929
01:39:02,200 --> 01:39:06,050
as 'n twee-dimensionele, skikking,
waardeur elke woord soort lyk

1930
01:39:06,050 --> 01:39:08,580
soos dit in jou geestesoog
oog, en elke karakter

1931
01:39:08,580 --> 01:39:10,930
is 'n soort van bestaan ​​in
'n kolom, as dit help.

1932
01:39:10,930 --> 01:39:13,260
>> In werklikheid, as ons terg
hierdie uitmekaar in die toekoms weke,

1933
01:39:13,260 --> 01:39:15,580
dit gaan 'n bietjie wees
meer gesofistikeerd as dit.

1934
01:39:15,580 --> 01:39:17,800
Maar jy kan regtig
dink dat, vir nou,

1935
01:39:17,800 --> 01:39:22,110
as net hierdie twee-dimensionele
skikking, waar een vlak daarvan

1936
01:39:22,110 --> 01:39:23,260
is al die snare.

1937
01:39:23,260 --> 01:39:26,760
En dan as jy duik in dieper, jy
kan kry by die individuele karakters

1938
01:39:26,760 --> 01:39:29,600
daarop is deur die gebruik van hierdie notasie hier.

1939
01:39:29,600 --> 01:39:31,620
>> So, wat is die netto effek?

1940
01:39:31,620 --> 01:39:34,970
Laat my gaan voort en
maak argv2-- darn dit.

1941
01:39:34,970 --> 01:39:36,210
Ek het 'n fout hier.

1942
01:39:36,210 --> 01:39:40,160
Implisiet verklaar die
biblioteek funksie Stirling.

1943
01:39:40,160 --> 01:39:42,190
So was dan al hierdie tyd, is dit
miskien gepas

1944
01:39:42,190 --> 01:39:45,130
dat ons soort afwerking
presies waar ons begin het.

1945
01:39:45,130 --> 01:39:48,160
>> Ek verfrommeld, implisiet verklaar
biblioteek funksie Stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, wag 'n minuut.

1947
01:39:48,987 --> 01:39:51,070
Ek onthou dat, veral
want dit is reg hier.

1948
01:39:51,070 --> 01:39:54,490
Ek moet string.h sluit in
hierdie weergawe van die program.

1949
01:39:54,490 --> 01:40:00,050
>> Laat my gaan voort en sluit
string.h, behalwe dat, gaan voort

1950
01:40:00,050 --> 01:40:04,460
en heropstel argv2.

1951
01:40:04,460 --> 01:40:08,390
En nou, hier gaan ons, maak argv2, Tik.

1952
01:40:08,390 --> 01:40:10,590
En al is dit 'n bietjie
kriptiese met die eerste oogopslag,

1953
01:40:10,590 --> 01:40:15,690
agterkom dat, wel, wat
gedruk is dot argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Maar as ek tik 'n paar woorde na die
vinnige, soos argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Gee ook 'n bietjie
kriptiese met die eerste oogopslag.

1956
01:40:22,560 --> 01:40:30,540
Maar as ons blaai terug,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
So ons het herhaal oor elke woord.

1958
01:40:32,190 --> 01:40:37,770
En op sy beurt, het ons herhaal oor
elke karakter binne 'n woord.

1959
01:40:37,770 --> 01:40:40,040
>> Nou, na al hierdie dinge,
besef dat daar '

1960
01:40:40,040 --> 01:40:43,120
een ander besonderhede wat ons vriendelik
ignoreer hierdie hele tyd.

1961
01:40:43,120 --> 01:40:46,180
Ons gespot net uitmekaar wat
insette hoof se kan wees?

1962
01:40:46,180 --> 01:40:47,780
Wat van uitset hoof se?

1963
01:40:47,780 --> 01:40:50,540
>> Al hierdie tyd, het ons
net kopieer en plak

1964
01:40:50,540 --> 01:40:53,870
die woord Int voor belangrikste,
al is jy online kan sien,

1965
01:40:53,870 --> 01:40:58,340
soms verkeerdelik in ouer weergawes
van C en opstellers, dat hulle sê leemte,

1966
01:40:58,340 --> 01:40:59,410
of glad niks nie.

1967
01:40:59,410 --> 01:41:01,580
Maar, inderdaad, vir die weergawe
van C wat ons gebruik,

1968
01:41:01,580 --> 01:41:06,180
C 11, of 2011, besef
dat dit int moet wees.

1969
01:41:06,180 --> 01:41:09,300
En dit moet óf
nietig of argc en argv hier.

1970
01:41:09,300 --> 01:41:10,790
>> Maar hoekom int main?

1971
01:41:10,790 --> 01:41:12,480
Wat is dit nou eintlik terugkeer?

1972
01:41:12,480 --> 01:41:16,280
Wel, dit blyk al hierdie tyd,
enige tyd wat jy het 'n program belangrikste geskryf

1973
01:41:16,280 --> 01:41:18,440
is altyd terugkeer iets.

1974
01:41:18,440 --> 01:41:19,960
Maar dit is so in die geheim doen.

1975
01:41:19,960 --> 01:41:23,350
>> Dat daar iets is 'n
int, as reël 5 dui.

1976
01:41:23,350 --> 01:41:24,225
Maar wat int?

1977
01:41:24,225 --> 01:41:26,100
Wel, daar is hierdie
konvensie in programmering,

1978
01:41:26,100 --> 01:41:29,790
waardeur daar niks
verkeerd geloop en alles goed,

1979
01:41:29,790 --> 01:41:34,250
programme en funksies in die algemeen
return-- ietwat counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 gee te kenne dat die algemeen alles goed.

1982
01:41:38,070 --> 01:41:40,610
So selfs al is jy dink
dit as vals in baie kontekste,

1983
01:41:40,610 --> 01:41:42,930
dit eintlik beteken oor die algemeen 'n goeie ding

1984
01:41:42,930 --> 01:41:49,560
>> Intussen, as 'n program terug 1,
of negatiewe 1, of 5, of negatief 42,

1985
01:41:49,560 --> 01:41:52,941
of enige nie-0 waarde,
wat oor die algemeen beteken

1986
01:41:52,941 --> 01:41:54,190
dat iets verkeerd geloop het.

1987
01:41:54,190 --> 01:41:56,700
Trouens, op jou eie Mac of PC,
jy kan eintlik sien

1988
01:41:56,700 --> 01:42:01,050
'n fout boodskap, waardeur dit
sê iets of ander, fout

1989
01:42:01,050 --> 01:42:04,940
-kode negatiewe 42, of fout kode
23, of iets soos dit.

1990
01:42:04,940 --> 01:42:08,980
Dat die getal is oor die algemeen net 'n wenk
om die programmeerder, of die maatskappy

1991
01:42:08,980 --> 01:42:11,174
dat die sagteware gemaak,
wat verkeerd en hoekom het,

1992
01:42:11,174 --> 01:42:13,590
sodat hulle kan kyk deur
hul dokumentasie of kode,

1993
01:42:13,590 --> 01:42:15,465
en uit te vind wat die
fout beteken eintlik.

1994
01:42:15,465 --> 01:42:18,400
Dit is oor die algemeen nie
nuttig om ons eindgebruikers.

1995
01:42:18,400 --> 01:42:20,550
>> Maar toe hoof opbrengste 0, alles goed.

1996
01:42:20,550 --> 01:42:23,770
En as jy nie spesifiseer
wat hoof moes neerkom,

1997
01:42:23,770 --> 01:42:26,950
Dit sal net outomaties
terugkeer 0 vir jou.

1998
01:42:26,950 --> 01:42:30,870
Maar terug iets
anders is eintlik nuttig.

1999
01:42:30,870 --> 01:42:34,660
>> In hierdie laaste program, laat my
gaan voort en noem dit exit.c,

2000
01:42:34,660 --> 01:42:38,630
en stel die laaste van vandag se
onderwerpe, wat bekend staan ​​as 'n fout kode.

2001
01:42:38,630 --> 01:42:42,930
Laat my gaan voort en sluit ons
vertroud lêers op die top, doen int main.

2002
01:42:42,930 --> 01:42:49,500
En hierdie keer, laat ons doen int argc,
string argv, en met my hakies

2003
01:42:49,500 --> 01:42:50,836
om te impliseer dat dit in die skikking.

2004
01:42:50,836 --> 01:42:52,460
En dan wil ek net doen 'n gesonde verstand tjek.

2005
01:42:52,460 --> 01:42:56,640
Hierdie keer, as argc nie doen
gelyke 2, dan weet jy wat?

2006
01:42:56,640 --> 01:42:57,520
Vergeet dit.

2007
01:42:57,520 --> 01:43:03,170
Ek gaan om te sê dat, hey, gebruiker,
jy mis command line argument

2008
01:43:03,170 --> 01:43:04,210
agteroorskuinsstreep N.

2009
01:43:04,210 --> 01:43:05,230
>> En dan is dit dit.

2010
01:43:05,230 --> 01:43:06,130
Ek wil verlaat.

2011
01:43:06,130 --> 01:43:11,030
Ek gaan preemptively,
en voortydig regtig, terugkeer

2012
01:43:11,030 --> 01:43:12,810
iets anders as die nommer 1.

2013
01:43:12,810 --> 01:43:15,360
Die pad is om waarde vir die eerste
fout wat kan gebeur is 1.

2014
01:43:15,360 --> 01:43:17,860
As jy 'n paar ander foutiewe
situasie wat mag voorkom,

2015
01:43:17,860 --> 01:43:21,390
jy kan sê terugkeer 2 of terugkeer 3, of
miskien selfs negatiewe 1 of negatiewe 2.

2016
01:43:21,390 --> 01:43:23,750
>> Dit is slegs uitgang kodes
wat, in die algemeen,

2017
01:43:23,750 --> 01:43:27,770
net nuttig vir die programmeerder, of die
maatskappy wat gestuur die sagteware.

2018
01:43:27,770 --> 01:43:30,500
Maar die feit dat dit
nie 0 is wat belangrik is.

2019
01:43:30,500 --> 01:43:34,310
So as in hierdie program, ek wil
waarborg dat hierdie program net

2020
01:43:34,310 --> 01:43:38,190
werk as die gebruiker my bied
met 'n argument Telling van twee,

2021
01:43:38,190 --> 01:43:42,880
die naam van die program, en 'n paar ander
woord, ek kan net soveel soos volg af te dwing,

2022
01:43:42,880 --> 01:43:46,110
gil op die gebruiker met printf gesegde,
ontbreek command line argument,

2023
01:43:46,110 --> 01:43:46,970
terug 1.

2024
01:43:46,970 --> 01:43:49,940
Dit sal net onmiddellik
sluit die program.

2025
01:43:49,940 --> 01:43:55,840
>> Slegs indien argc gelyk 2 sal ons kry af
hier, op watter punt wat ek gaan om te sê,

2026
01:43:55,840 --> 01:44:00,410
hallo persent s, agteroorskuinsstreep N, argv1.

2027
01:44:00,410 --> 01:44:03,827
Met ander woorde, ek is
nie gaan na argv 0,

2028
01:44:03,827 --> 01:44:05,410
wat net die naam van die program.

2029
01:44:05,410 --> 01:44:09,450
Ek wil uit te druk hello, komma,
die tweede woord wat die menslike getik.

2030
01:44:09,450 --> 01:44:12,580
En in hierdie geval op
lyn 13, alles goed.

2031
01:44:12,580 --> 01:44:15,920
>> Ek weet dat argc is 2
logies uit hierdie program.

2032
01:44:15,920 --> 01:44:17,770
Ek gaan om voort te gaan en terug te keer 0.

2033
01:44:17,770 --> 01:44:21,230
As 'n eenkant, in gedagte hou dat
dit is waar in Scratch sowel.

2034
01:44:21,230 --> 01:44:24,760
>> Logies, kan ek dit doen
en omsluit hierdie lyne

2035
01:44:24,760 --> 01:44:27,020
van kode in hierdie anders klousule hier.

2036
01:44:27,020 --> 01:44:29,420
Maar dit is soort van
onnodig insp my kode.

2037
01:44:29,420 --> 01:44:31,800
En ek wil super maak
duidelik dat maak nie saak wat,

2038
01:44:31,800 --> 01:44:34,670
by verstek, hello
iets sal kry gedruk,

2039
01:44:34,670 --> 01:44:36,050
so lank as wat die gebruiker saam.

2040
01:44:36,050 --> 01:44:39,360
>> Dit is dus baie algemeen om te gebruik
'n toestand, net 'n as,

2041
01:44:39,360 --> 01:44:41,870
'n paar verkeerde vang
situasie, en dan uitgang.

2042
01:44:41,870 --> 01:44:45,690
En dan, so lank al is
Wel, nie 'n ander het,

2043
01:44:45,690 --> 01:44:48,060
maar net die kode
buite dat indien, want dit is

2044
01:44:48,060 --> 01:44:51,060
ekwivalent in hierdie
spesifieke geval, logies.

2045
01:44:51,060 --> 01:44:54,480
Dus is ek terug 0, net om
uitdruklik dui alles goed.

2046
01:44:54,480 --> 01:44:58,480
>> As ek die terugkeer 0 uitgelaat, sou dit
word outomaties aanvaar vir my.

2047
01:44:58,480 --> 01:45:00,890
Maar noudat ek terug
een in ten minste hierdie geval,

2048
01:45:00,890 --> 01:45:04,940
Ek gaan vir 'n Goeie maat en
duidelikheid, terugkeer 0 in hierdie geval.

2049
01:45:04,940 --> 01:45:09,690
So nou laat ek gaan voort en maak die uitgang,
wat is 'n perfekte segue om net te verlaat.

2050
01:45:09,690 --> 01:45:14,401
>> Maar maak uitgang, dat ek kan gaan
voort en doen ./exit, Tik.

2051
01:45:14,401 --> 01:45:16,900
En die program het op my geskree,
ontbreek command line argument.

2052
01:45:16,900 --> 01:45:18,120
OK, laat my saam.

2053
01:45:18,120 --> 01:45:23,810
>> Laat my plaas doen ./exit, Dawid, Tik.

2054
01:45:23,810 --> 01:45:25,190
En nou is dit sê, hallo Dawid.

2055
01:45:25,190 --> 01:45:27,300
En jy sal nie normaalweg sien.

2056
01:45:27,300 --> 01:45:30,650
>> Maar dit blyk dat daar 'n
manier in Linux om werklik te sien

2057
01:45:30,650 --> 01:45:34,470
met wat uitgang-kode 'n program opgewonde.

2058
01:45:34,470 --> 01:45:37,184
Soms in 'n grafiese
wêreld soos Mac OS of Windows,

2059
01:45:37,184 --> 01:45:40,100
jy sien net hierdie getalle wanneer 'n
fout boodskap verskyn op die skerm

2060
01:45:40,100 --> 01:45:41,940
en die programmeerder
wys jou dat die getal.

2061
01:45:41,940 --> 01:45:44,773
Maar as ons wil wat die fout sien
boodskap is, kan ons dit doen here--

2062
01:45:44,773 --> 01:45:48,100
sodat ./exit, Tik, druk
ontbreek command line argument.

2063
01:45:48,100 --> 01:45:54,590
>> As ek nou doen echo $ ?, wat
belaglik kriptiese soek.

2064
01:45:54,590 --> 01:45:56,590
Maar $?

2065
01:45:56,590 --> 01:45:59,220
is die magiese inkantasie
wat sê, hey, rekenaar,

2066
01:45:59,220 --> 01:46:01,900
vertel my wat die vorige
program se uitgang kode was.

2067
01:46:01,900 --> 01:46:03,410
En ek druk Enter.

2068
01:46:03,410 --> 01:46:07,520
Ek sien 1, want dit is wat ek
vertel my hooffunksie om terug te keer.

2069
01:46:07,520 --> 01:46:12,310
>> Intussen, as ek doen ./exit Dawid,
en druk Enter, ek sien, hallo Dawid.

2070
01:46:12,310 --> 01:46:16,800
En as ek nou doen echo $ ?, ek sien hallo 0.

2071
01:46:16,800 --> 01:46:19,080
En dus sal dit eintlik
wees waardevolle inligting

2072
01:46:19,080 --> 01:46:23,420
in die konteks van die debugger, nie so
veel dat jy, die mens, sal sorg.

2073
01:46:23,420 --> 01:46:26,060
Maar die debugger en ander
programme sal ons hierdie semester gebruik

2074
01:46:26,060 --> 01:46:29,420
sal dikwels kyk na dat die getal,
selfs al is dit soort van verborge weg

2075
01:46:29,420 --> 01:46:32,780
tensy jy kyk vir dit, om
vas te stel of 'n program se

2076
01:46:32,780 --> 01:46:37,050
uitvoering was reg of verkeerd.

2077
01:46:37,050 --> 01:46:40,450
>> En sodat bring ons by
hierdie, aan die einde van die dag.

2078
01:46:40,450 --> 01:46:43,917
Ons het vandag begin deur te kyk na
ontfouting, en op sy beurt by die kursus

2079
01:46:43,917 --> 01:46:46,750
self, en dan meer interessant,
tegnies onder die enjinkap

2080
01:46:46,750 --> 01:46:49,490
teen watter snare is, wat verlede
week het ons net as vanselfsprekend aanvaar,

2081
01:46:49,490 --> 01:46:51,900
en beslis het hulle
as vanselfsprekend aanvaar in Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Ons het toe gekyk na hoe ons kan toegang
individuele karakters in 'n string,

2083
01:46:56,040 --> 01:47:00,310
en dan weer het 'n hoër vlak
kyk na dinge, kyk na hoe well--

2084
01:47:00,310 --> 01:47:04,226
As ons wil hê op individuele te kry
elemente in 'n lys agtige struktuur,

2085
01:47:04,226 --> 01:47:05,850
Ons kan dit nie doen nie met verskeie snare?

2086
01:47:05,850 --> 01:47:08,050
En ons kan met command line argumente.

2087
01:47:08,050 --> 01:47:12,800
Maar hierdie foto hier van net bokse
is demonstratiewe van hierdie algemene idee

2088
01:47:12,800 --> 01:47:14,451
van 'n skikking, of 'n lys, of 'n vektor.

2089
01:47:14,451 --> 01:47:16,450
En afhangende van die
konteks, al hierdie woorde

2090
01:47:16,450 --> 01:47:17,880
beteken effens verskillende dinge.

2091
01:47:17,880 --> 01:47:20,060
So in C, ons net gaan
om te praat oor 'n skikking.

2092
01:47:20,060 --> 01:47:23,840
En 'n skikking is 'n stuk
geheue, elkeen van wie is

2093
01:47:23,840 --> 01:47:27,720
elemente is aangrensend, terug,
na agter, na agter, om terug te.

2094
01:47:27,720 --> 01:47:31,970
>> En die elemente is, oor die algemeen,
van dieselfde tipe data, karakter,

2095
01:47:31,970 --> 01:47:35,966
karakter, karakter, karakter, of
string, string, string, string, of int,

2096
01:47:35,966 --> 01:47:38,600
int, int, wat dit ookal is
ons probeer om te slaan.

2097
01:47:38,600 --> 01:47:42,540
Maar aan die einde van die dag, dit is
hoe dit lyk konseptueel.

2098
01:47:42,540 --> 01:47:44,530
Jy neem jou
geheue of RAM rekenaar se.

2099
01:47:44,530 --> 01:47:48,590
En jy sny dit uit in
identies grootte bokse, wat almal

2100
01:47:48,590 --> 01:47:50,920
is terug, om terug te
terug, om terug op hierdie manier.

2101
01:47:50,920 --> 01:47:53,200
>> En wat is lekker oor
hierdie idee, en die feit

2102
01:47:53,200 --> 01:47:58,580
dat ons waardes op hierdie manier kan uitdruk
met die eerste van ons datastrukture

2103
01:47:58,580 --> 01:48:02,520
in die klas, beteken dat ons kan begin
om probleme met kode op te los

2104
01:48:02,520 --> 01:48:04,079
wat gekom het sodat intuïtief in week 0.

2105
01:48:04,079 --> 01:48:05,870
Jy sal die telefoon herinner
boek byvoorbeeld waar

2106
01:48:05,870 --> 01:48:09,110
Ons gebruik 'n verdeel en heers,
of 'n binêre soek algoritme,

2107
01:48:09,110 --> 01:48:13,220
om te sif deur 'n hele
n klomp van die name en nommers.

2108
01:48:13,220 --> 01:48:18,220
Maar ons aanvaar, onthou, dat dit
telefoon boek is reeds gesorteer,

2109
01:48:18,220 --> 01:48:21,630
dat iemand anders reeds
uitgepluis out-- kry 'n lys van name

2110
01:48:21,630 --> 01:48:24,430
en numbers-- hoe om dit te alphabetize.

2111
01:48:24,430 --> 01:48:26,950
En noudat in C ons,
Ook het die vermoë

2112
01:48:26,950 --> 01:48:30,290
om dinge uit te lê, nie
fisies in 'n telefoon boek

2113
01:48:30,290 --> 01:48:34,220
maar feitlik in 'n rekenaar se
geheue, sal ons in staat wees om volgende week

2114
01:48:34,220 --> 01:48:38,470
weer in te voer this-- die eerste
van ons datastrukture in 'n array--

2115
01:48:38,470 --> 01:48:43,530
maar meer belangrik, werklike rekenaar
wetenskap algoritmes geïmplementeer

2116
01:48:43,530 --> 01:48:47,720
in kode, waarmee ons kan stoor
data in strukture soos hierdie,

2117
01:48:47,720 --> 01:48:50,730
en dan begin om dit te manipuleer, en
om werklik op te los met dit,

2118
01:48:50,730 --> 01:48:53,570
en voort te bou op die top van dat,
Uiteindelik programme in C,

2119
01:48:53,570 --> 01:48:56,730
in Python, in JavaScript,
bevraagteken databasisse met SQL?

2120
01:48:56,730 --> 01:48:59,980
>> En ons sal sien dat al hierdie
verskillende idees gekoppel.

2121
01:48:59,980 --> 01:49:04,100
Maar vir nou, onthou dat die
domein wat ons vandag bekendgestel

2122
01:49:04,100 --> 01:49:06,920
was hierdie ding hier, en
die wêreld van kriptografie.

2123
01:49:06,920 --> 01:49:11,200
En onder die volgende probleme wat jy jouself
sal los is die kuns van kriptografie,

2124
01:49:11,200 --> 01:49:13,630
skommeling en de-skommeling
inligting en ontsyfering

2125
01:49:13,630 --> 01:49:15,930
en ontsyfer teks,
en die aanvaarding uiteindelik

2126
01:49:15,930 --> 01:49:18,970
dat jy nou weet wat
is onder die enjinkap

2127
01:49:18,970 --> 01:49:21,860
sodat wanneer jy sien of te ontvang
'n boodskap soos hierdie, jy

2128
01:49:21,860 --> 01:49:24,060
jouself kan dit ontsyfer.

2129
01:49:24,060 --> 01:49:26,740
Dit alles en meer volgende keer.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [Video speel]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Net aangekom.

2133
01:49:32,970 --> 01:49:35,146
Ek gaan besoek gaan
sy kollege professor.

2134
01:49:35,146 --> 01:49:37,611
Yep.

2135
01:49:37,611 --> 01:49:40,080
Hi.

2136
01:49:40,080 --> 01:49:40,660
Dis jy.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Wag!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Ek is net probeer om uit te
uit te vind wat met jou gebeur het.

2142
01:49:56,060 --> 01:49:58,130
Asseblief, enigiets kan help.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Jy was sy kollege
kamermaat, was jy nie?

2145
01:50:08,354 --> 01:50:10,770
Jy was daar saam met hom toe
Hy klaar die CS50 projek?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [Speel van musiek]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -dat Was CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Ek is lief vir hierdie plek.

2152
01:50:44,770 --> 01:50:45,854
>> -Eet op.

2153
01:50:45,854 --> 01:50:47,020
Ons gaan uit van die besigheid.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [Einde TERUGSPEEL]

