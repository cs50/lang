1
00:00:00,000 --> 00:00:02,970
>> [MUSIC PLAYING]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Malan: Très bien.

4
00:00:15,700 --> 00:00:18,832
Ceci est CS50 et ce
est le début de la semaine 2.

5
00:00:18,832 --> 00:00:21,040
Et vous vous souviendrez que sur
les deux dernières semaines,

6
00:00:21,040 --> 00:00:24,490
nous avons été l'introduction ordinateur
la science et, à son tour, de la programmation.

7
00:00:24,490 --> 00:00:27,640
>> Et nous avons commencé l'histoire par le biais de
Scratch, ce langage graphique

8
00:00:27,640 --> 00:00:28,990
du Media Lab du MIT.

9
00:00:28,990 --> 00:00:30,780
Et puis, plus récemment,
la semaine dernière, ne nous

10
00:00:30,780 --> 00:00:34,450
introduire un higher-- un
langue de niveau inférieur connu

11
00:00:34,450 --> 00:00:36,770
comme C, quelque chose qui est purement textuelle.

12
00:00:36,770 --> 00:00:39,440
Et, en effet, nous la dernière fois
explorée dans ce contexte,

13
00:00:39,440 --> 00:00:40,450
un certain nombre de concepts.

14
00:00:40,450 --> 00:00:43,010
>> Ce rappel, a été le tout
premier programme, nous avons examiné.

15
00:00:43,010 --> 00:00:45,710
Et ce programme, tout simplement,
imprime, "bonjour, monde."

16
00:00:45,710 --> 00:00:47,730
Mais il y a tellement
magie apparente passe.

17
00:00:47,730 --> 00:00:51,460
Il y a cette #include
avec ces crochets.

18
00:00:51,460 --> 00:00:52,170
Il y a int.

19
00:00:52,170 --> 00:00:53,020
Il y a (void).

20
00:00:53,020 --> 00:00:56,330
Il y a des parenthèses, des accolades,
des points-virgules, et bien plus encore.

21
00:00:56,330 --> 00:00:58,480
>> Et donc, rappeler que
nous avons introduit Scratch

22
00:00:58,480 --> 00:01:02,110
afin que nous puissions, idéalement, voir au-delà
cette syntaxe, le truc qui est vraiment pas

23
00:01:02,110 --> 00:01:04,590
tout ce qui intellectuellement
intéressant, mais dès le début

24
00:01:04,590 --> 00:01:07,700
est, absolument, un peu délicat
pour envelopper votre esprit autour.

25
00:01:07,700 --> 00:01:10,860
Et, en effet, l'une des plus courantes
les choses tôt dans une classe de programmation,

26
00:01:10,860 --> 00:01:13,443
en particulier pour ceux qui sont moins
confortable, est d'être frustré par

27
00:01:13,443 --> 00:01:17,460
et déclenché par certains syntaxique
erreurs, sans parler des erreurs logiques.

28
00:01:17,460 --> 00:01:19,800
Et parmi nos objectifs
aujourd'hui, en fait, sera

29
00:01:19,800 --> 00:01:23,280
être de vous doter d'une certaine
techniques de résolution de problèmes pour savoir comment

30
00:01:23,280 --> 00:01:26,705
afin de mieux résoudre les problèmes eux-mêmes
sous la forme de débogage.

31
00:01:26,705 --> 00:01:29,330
Et vous vous souviendrez aussi que le
environnement qui nous avons introduit

32
00:01:29,330 --> 00:01:31,780
la dernière fois a été appelé CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Ce logiciel est basé sur le Web qui
vous permet de programmer dans le nuage,

34
00:01:34,850 --> 00:01:38,450
pour ainsi dire, tout en gardant tous vos
les fichiers ensemble, comme nous le ferons à nouveau aujourd'hui.

35
00:01:38,450 --> 00:01:41,480
Et rappeler que nous
revisité ces sujets ici,

36
00:01:41,480 --> 00:01:44,480
parmi eux, des fonctions et des boucles, et
les variables et les expressions booléennes,

37
00:01:44,480 --> 00:01:45,110
et les conditions.

38
00:01:45,110 --> 00:01:49,190
Et en réalité un peu plus que nous
traduit du monde de Scratch

39
00:01:49,190 --> 00:01:50,800
dans le monde de C.

40
00:01:50,800 --> 00:01:53,220
>> Mais la construction fondamentale
blocs, pour ainsi dire,

41
00:01:53,220 --> 00:01:55,150
étaient vraiment toujours le même la semaine dernière.

42
00:01:55,150 --> 00:01:57,900
En fait, nous avons vraiment juste eu un
pièce de puzzle différente, si vous voulez.

43
00:01:57,900 --> 00:02:00,300
Au lieu de cela pourpre
sauver bloc, nous avons la place

44
00:02:00,300 --> 00:02:02,940
avait printf, qui est
cette fonction en C qui

45
00:02:02,940 --> 00:02:05,890
vous permet d'imprimer quelque chose
et le formater à l'écran.

46
00:02:05,890 --> 00:02:07,950
Nous avons introduit le CS50
Bibliothèque, où vous

47
00:02:07,950 --> 00:02:11,420
ont maintenant à votre disposition get_char,
et get_int et get_string,

48
00:02:11,420 --> 00:02:14,610
et quelques autres fonctions
ainsi, par l'intermédiaire duquel vous pouvez obtenir entrée

49
00:02:14,610 --> 00:02:16,260
du propre clavier de l'utilisateur.

50
00:02:16,260 --> 00:02:20,640
Et nous avons aussi pris un regard sur les choses
comme ces-bool et char,

51
00:02:20,640 --> 00:02:22,490
et double, float,
int, string long_long.

52
00:02:22,490 --> 00:02:25,170
Et il y a même d'autres types de données dans C.

53
00:02:25,170 --> 00:02:28,560
>> En d'autres termes, lorsque vous déclarez
une variable pour stocker une certaine valeur,

54
00:02:28,560 --> 00:02:32,600
ou lorsque vous implémentez une fonction
qui retourne une certaine valeur,

55
00:02:32,600 --> 00:02:35,290
vous pouvez spécifier
type de valeur qui est.

56
00:02:35,290 --> 00:02:37,310
Est-ce une chaîne, comme un
une séquence de caractères?

57
00:02:37,310 --> 00:02:39,490
Est-il un certain nombre, comme un nombre entier?

58
00:02:39,490 --> 00:02:41,390
Est-ce une virgule flottante
valeur, ou similaire?

59
00:02:41,390 --> 00:02:46,180
Donc, en C, contrairement à Scratch, nous avons en fait
a commencé à préciser quel type de données

60
00:02:46,180 --> 00:02:48,330
nous revenions ou l'utilisation.

61
00:02:48,330 --> 00:02:51,910
>> Mais, bien sûr, nous avons également couru dans
certaines limites fondamentales de l'informatique.

62
00:02:51,910 --> 00:02:54,100
En particulier,
cette langue C, le rappel

63
00:02:54,100 --> 00:02:57,070
que nous avons pris un coup d'oeil
débordement d'entier, la réalité

64
00:02:57,070 --> 00:03:00,460
que si vous avez seulement un
quantité finie de mémoire

65
00:03:00,460 --> 00:03:04,600
ou, plus précisément, un nombre fini
de bits, vous ne pouvez compter si haut.

66
00:03:04,600 --> 00:03:08,460
Et donc nous avons examiné cet exemple ici
dans lequel un compteur dans un avion,

67
00:03:08,460 --> 00:03:13,510
en fait, en cas d'exécution assez longtemps serait
déborder et entraîner un logiciel

68
00:03:13,510 --> 00:03:15,560
une réelle erreur potentiel physique.

69
00:03:15,560 --> 00:03:18,600
>> Nous avons également examiné flottante
point de l'imprécision, la réalité

70
00:03:18,600 --> 00:03:22,280
que, avec un nombre fini
de bits, que ce soit 32 ou 64,

71
00:03:22,280 --> 00:03:27,330
vous ne pouvez spécifier autant de numéros
après un point décimal, après quoi vous

72
00:03:27,330 --> 00:03:29,110
commencer à obtenir imprécis.

73
00:03:29,110 --> 00:03:32,360
Ainsi, par exemple, un tiers de la
monde ici, dans notre monde humain,

74
00:03:32,360 --> 00:03:35,360
nous savons est juste un nombre infini
de 3s après la virgule.

75
00:03:35,360 --> 00:03:38,820
Mais un ordinateur ne peut pas nécessairement
représentent un nombre infini de nombres

76
00:03:38,820 --> 00:03:42,590
si vous permettez que cela certains
quantité limitée d'informations.

77
00:03:42,590 --> 00:03:45,900
>> Ainsi, non seulement nous vous équipons
avec une plus grande puissance en termes

78
00:03:45,900 --> 00:03:49,280
de la façon dont vous pourriez vous exprimer au
un clavier en termes de programmation,

79
00:03:49,280 --> 00:03:51,430
nous avons aussi limité que
vous pouvez réellement faire.

80
00:03:51,430 --> 00:03:55,790
Et en effet, les bugs et les erreurs peuvent
découler de ce genre de questions.

81
00:03:55,790 --> 00:03:59,900
Et en effet, parmi les sujets d'aujourd'hui
vont être des sujets tels que le débogage

82
00:03:59,900 --> 00:04:03,699
et effectivement regarder sous le capot
comment les choses ont été introduites la semaine dernière

83
00:04:03,699 --> 00:04:05,490
sont effectivement mis en œuvre
de sorte que vous mieux

84
00:04:05,490 --> 00:04:10,530
comprendre à la fois les capacités de et
les limites d'une langue comme le C.

85
00:04:10,530 --> 00:04:14,770
>> Et en fait, nous allons peler les couches
la plus simple de structure de données,

86
00:04:14,770 --> 00:04:17,756
ce qu'on appelle un tableau, qui
Scratch arrive à appeler une "liste."

87
00:04:17,756 --> 00:04:19,589
Il est un peu
Dans ce contexte différent.

88
00:04:19,589 --> 00:04:23,340
Et puis nous allons aussi présenter l'un des
premier de nos problèmes spécifiques au domaine

89
00:04:23,340 --> 00:04:26,790
en CS50, le monde de la
la cryptographie, l'art de brouillage

90
00:04:26,790 --> 00:04:29,650
ou chiffrer des informations afin
que vous pouvez envoyer des messages secrets

91
00:04:29,650 --> 00:04:34,520
et décoder des messages secrets
entre deux personnes, A et B.

92
00:04:34,520 --> 00:04:37,490
>> Donc, avant la transition de nous
à ce nouveau monde,

93
00:04:37,490 --> 00:04:42,059
nous allons essayer de vous équiper avec un certain
techniques avec lesquelles vous pouvez éliminer

94
00:04:42,059 --> 00:04:43,850
ou réduire au moins certains
des frustrations

95
00:04:43,850 --> 00:04:46,630
que vous avez probablement rencontré
au cours de la seule semaine dernière.

96
00:04:46,630 --> 00:04:50,830
En fait, avant de vous sont such-- certains
vos premiers problèmes en C. Et les chances sont,

97
00:04:50,830 --> 00:04:54,010
si vous êtes comme moi, la première fois
vous essayez de taper un programme,

98
00:04:54,010 --> 00:04:57,330
même si vous pensez logiquement
le programme est assez simple,

99
00:04:57,330 --> 00:05:01,200
vous pourriez très bien frapper un mur, et
le compilateur ne va pas coopérer.

100
00:05:01,200 --> 00:05:03,940
Faire ou Clang ne va pas
pour réellement faire votre appel d'offres.

101
00:05:03,940 --> 00:05:05,450
>> Et pourquoi pourrait-il être?

102
00:05:05,450 --> 00:05:07,950
Eh bien, nous allons jeter un oeil à,
peut-être, un programme simple.

103
00:05:07,950 --> 00:05:11,190
Je vais aller de l'avant et de sauvegarder ce dans
un fichier délibérément appelé buggy0.c,

104
00:05:11,190 --> 00:05:13,590
parce que je sais que ce
être viciée à l'avance.

105
00:05:13,590 --> 00:05:17,400
Mais je ne pourrais pas réaliser que si cette
est le premier ou le deuxième ou le troisième programme

106
00:05:17,400 --> 00:05:18,830
que je suis en train de me faire.

107
00:05:18,830 --> 00:05:23,820
Je vais donc aller de l'avant et
taper, int main (void).

108
00:05:23,820 --> 00:05:28,130
Et puis à l'intérieur de mes accolades,
un très familier ( "bonjour, monde--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - et un point-virgule.

110
00:05:30,980 --> 00:05:32,360
>> Je l'ai enregistré le fichier.

111
00:05:32,360 --> 00:05:34,850
Maintenant, je vais aller vers le bas
à ma fenêtre de terminal

112
00:05:34,850 --> 00:05:40,340
et tapez make buggy0, parce que, encore une fois,
le nom du fichier est aujourd'hui buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Donc je tape faire buggy0, Entrée.

114
00:05:43,660 --> 00:05:48,200
>> Et, oh, ça alors, rappeler de la dernière fois
qu'aucun message d'erreur est une bonne chose.

115
00:05:48,200 --> 00:05:49,740
Donc, pas de sortie est une bonne chose.

116
00:05:49,740 --> 00:05:52,920
Mais ici, j'ai clairement
un certain nombre d'erreurs.

117
00:05:52,920 --> 00:05:56,470
>> Ainsi, la première ligne de sortie
après avoir tapé faire buggy0, rappel,

118
00:05:56,470 --> 00:05:59,540
est sortie assez verbeux de Clang.

119
00:05:59,540 --> 00:06:02,067
Sous le capot,
CS50 IDE est configuré

120
00:06:02,067 --> 00:06:04,150
d'utiliser tout un tas de
options avec ce compilateur

121
00:06:04,150 --> 00:06:05,941
de sorte que vous n'avez pas
de penser à eux.

122
00:06:05,941 --> 00:06:08,840
Et voilà tout ce que la première ligne
des moyens qui commence par Clang.

123
00:06:08,840 --> 00:06:11,720
>> Mais après cela, les problèmes
commencer à faire leur apparition.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c sur la ligne 3, le caractère
5, il y a une grande erreur rouge.

125
00:06:17,390 --> 00:06:18,380
Qu'est-ce que c'est?

126
00:06:18,380 --> 00:06:23,562
déclarant Implicitement fonction de bibliothèque
printf avec le type int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Je veux dire, très rapidement
devient très obscur.

129
00:06:28,379 --> 00:06:30,170
Et certainement, dans un premier temps
coup d'oeil, nous ne serions pas

130
00:06:30,170 --> 00:06:32,380
attendez-vous à comprendre la
intégralité de ce message.

131
00:06:32,380 --> 00:06:34,213
Et l'une des leçons
pour aujourd'hui va

132
00:06:34,213 --> 00:06:36,919
être pour essayer de remarquer
modèles, ou des choses semblables,

133
00:06:36,919 --> 00:06:38,960
aux erreurs que vous pourriez avoir
rencontré dans le passé.

134
00:06:38,960 --> 00:06:41,335
Donc, nous allons taquiner dehors seulement
ces mots qui semblent familiers.

135
00:06:41,335 --> 00:06:44,290
La grande erreur rouge est clairement
symbolique de quelque chose qui est faux.

136
00:06:44,290 --> 00:06:47,940
>> déclarant Implicitement
bibliothèque fonction printf.

137
00:06:47,940 --> 00:06:51,680
Donc, même si je ne comprends pas ce que
déclarant implicitement fonction de bibliothèque

138
00:06:51,680 --> 00:06:54,900
des moyens, le problème sûrement
concerne printf en quelque sorte.

139
00:06:54,900 --> 00:06:59,130
Et la source de cette question
a à voir avec le déclarant.

140
00:06:59,130 --> 00:07:02,440
>> Déclarant une fonction est
mentionnant pour la première fois.

141
00:07:02,440 --> 00:07:06,210
Et nous avons utilisé la terminologie la semaine dernière
de déclarer le prototype d'une fonction,

142
00:07:06,210 --> 00:07:11,860
soit avec une ligne en haut de votre
propre fichier ou dans un fichier que l'on appelle en-tête.

143
00:07:11,860 --> 00:07:15,300
Et dans ce dossier ne nous disons
la semaine dernière que printf est citation,

144
00:07:15,300 --> 00:07:17,080
unquote, déclarée?

145
00:07:17,080 --> 00:07:20,950
Dans ce fichier est son prototype?

146
00:07:20,950 --> 00:07:24,640
>> Donc, si vous vous souvenez, la première chose que je
dactylographiée, presque tous les programmes dernière time--

147
00:07:24,640 --> 00:07:30,790
et accidentellement il y a un instant commencé
myself-- tapant était celui ici--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- pour
entrée / dot output-- h Et en effet,

149
00:07:38,630 --> 00:07:41,860
si je sauve maintenant ce fichier, je vais
pour aller de l'avant et effacer mon écran,

150
00:07:41,860 --> 00:07:44,740
que vous pouvez faire en tapant
Effacer, ou vous pouvez maintenir le contrôle L,

151
00:07:44,740 --> 00:07:47,680
juste pour effacer votre fenêtre de terminal
juste pour éliminer tout encombrement.

152
00:07:47,680 --> 00:07:51,370
>> Je vais aller de l'avant et
re-tapez make buggy0, Entrée.

153
00:07:51,370 --> 00:07:53,790
Et voila, je vois toujours que
commande longue de Clang,

154
00:07:53,790 --> 00:07:55,470
mais il n'y a aucun message d'erreur cette fois.

155
00:07:55,470 --> 00:07:58,800
Et en effet, si je fais ./buggy0,
comme la dernière fois,

156
00:07:58,800 --> 00:08:01,860
où point signifie cette
répertoire, Slash signifie simplement,

157
00:08:01,860 --> 00:08:05,040
voici le nom du programme et
ce nom du programme est buggy0,

158
00:08:05,040 --> 00:08:07,340
Entrez, "bonjour, monde."

159
00:08:07,340 --> 00:08:09,440
>> Maintenant, comment pourriez-vous avoir
glanée cette solution

160
00:08:09,440 --> 00:08:12,017
sans nécessairement
reconnaissant que beaucoup de mots

161
00:08:12,017 --> 00:08:14,350
comme je l'ai fait, bien sûr, avoir
fait cela pendant tant d'années?

162
00:08:14,350 --> 00:08:18,720
Eh bien, réaliser par le premier problème
ensemble, nous vous présentons une commande

163
00:08:18,720 --> 00:08:21,175
que le personnel de CS50
écrit appelé help50.

164
00:08:21,175 --> 00:08:24,300
Et en effet, C ne spécification pour
le problème réglé sur la façon de l'utiliser.

165
00:08:24,300 --> 00:08:27,210
>> Mais est essentiellement help50
un programme qui du personnel de CS50

166
00:08:27,210 --> 00:08:30,850
vous avez écrit qui permet d'exécuter
une commande ou exécuter un programme,

167
00:08:30,850 --> 00:08:36,169
et si vous ne comprenez pas son
sortie, de passer sa sortie à help50,

168
00:08:36,169 --> 00:08:38,890
à quel point le logiciel
que le personnel du cours écrit

169
00:08:38,890 --> 00:08:42,429
se penchera sur la sortie de votre programme
ligne par ligne, caractère par caractère.

170
00:08:42,429 --> 00:08:46,000
Et si nous, le personnel, reconnaître la
message d'erreur que vous rencontrez,

171
00:08:46,000 --> 00:08:50,580
nous allons essayer de vous provoquer avec certains
questions rhétoriques, avec quelques conseils,

172
00:08:50,580 --> 00:08:54,890
un peu comme un TF ou d'un CA ou moi-même
ferait en personne à des heures de bureau.

173
00:08:54,890 --> 00:08:58,320
>> Alors regardez à help50 si vous ne le faites pas
reconnaître nécessairement un problème.

174
00:08:58,320 --> 00:09:00,790
Mais ne comptez pas sur elle
trop comme une béquille.

175
00:09:00,790 --> 00:09:03,990
essayez certainement de comprendre sa
sortie, puis en tirer des leçons

176
00:09:03,990 --> 00:09:07,571
de sorte que seulement une ou deux fois que vous faites
jamais couru help50 pour une erreur particulière

177
00:09:07,571 --> 00:09:08,070
message.

178
00:09:08,070 --> 00:09:10,660
Après cela, vous devriez être
mieux vous équipé

179
00:09:10,660 --> 00:09:13,180
de comprendre ce qu'il est réellement.

180
00:09:13,180 --> 00:09:14,350
>> Faisons un autre ici.

181
00:09:14,350 --> 00:09:20,410
Laissez-moi aller de l'avant, et dans un autre
fichier que nous appellerons ce buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Et dans ce dossier, je suis
va deliberately--

183
00:09:23,110 --> 00:09:26,330
mais prétendre que je ne le fais pas
comprendre quelle erreur je l'ai fait.

184
00:09:26,330 --> 00:09:31,420
>> Je vais aller de l'avant et de faire this--
#include, depuis que je suis

185
00:09:31,420 --> 00:09:33,660
appris ma leçon il y a un moment.

186
00:09:33,660 --> 00:09:36,220
Int principal (void), comme avant.

187
00:09:36,220 --> 00:09:40,880
Et puis ici, je vais
faire string s - get_string.

188
00:09:40,880 --> 00:09:43,770
Et rappeler de la dernière fois que
ce moyen, hé, ordinateur,

189
00:09:43,770 --> 00:09:48,280
me donner une variable, appelez-s, et
faire le type de cette variable une chaîne

190
00:09:48,280 --> 00:09:50,150
donc je peux stocker un ou plusieurs mots en elle.

191
00:09:50,150 --> 00:09:52,191
>> Et puis sur la droite
côté du signe égal

192
00:09:52,191 --> 00:09:54,980
est get_string, qui est un
fonction dans la bibliothèque CS50

193
00:09:54,980 --> 00:09:55,980
qui fait exactement cela.

194
00:09:55,980 --> 00:09:59,740
Il obtient une fonction, puis
les mains de droite à gauche.

195
00:09:59,740 --> 00:10:02,670
Donc, ce signe égal ne signifie pas
«Égaux» que nous pourrions penser en mathématiques.

196
00:10:02,670 --> 00:10:04,750
Cela signifie cession de droite à gauche.

197
00:10:04,750 --> 00:10:09,640
Donc, cela signifie, prendre la chaîne de
l'utilisateur et le stocker à l'intérieur de l'art.

198
00:10:09,640 --> 00:10:10,460
>> Maintenant, nous allons l'utiliser.

199
00:10:10,460 --> 00:10:13,820
Laissez-moi aller de l'avant maintenant et comme une seconde
ligne, laissez-moi aller de l'avant et de dire "bonjour" -

200
00:10:13,820 --> 00:10:19,330
pas «monde», mais «bonjour,% S-
qui est notre espace réservé, virgule s,

201
00:10:19,330 --> 00:10:22,030
qui est notre variable,
puis un point-virgule.

202
00:10:22,030 --> 00:10:26,070
Donc, si je ne visse trop
ici, cela ressemble à un code correct.

203
00:10:26,070 --> 00:10:28,090
>> Et mes instincts sont maintenant de le compiler.

204
00:10:28,090 --> 00:10:30,400
Le fichier est appelé buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Donc, je vais faire faire buggy1, Entrée.

206
00:10:33,770 --> 00:10:36,377
Et repriser-, s'il n'y a pas
même plus d'erreurs que par le passé.

207
00:10:36,377 --> 00:10:38,210
Je veux dire, il y a plus
les messages d'erreur ce serait

208
00:10:38,210 --> 00:10:40,400
semble que les lignes réelles dans ce programme.

209
00:10:40,400 --> 00:10:42,730
>> Mais la livraison est ici,
même si vous êtes submergé

210
00:10:42,730 --> 00:10:45,040
avec deux ou trois ou
quatre messages plus d'erreur,

211
00:10:45,040 --> 00:10:48,340
toujours se concentrer sur la très
premier de ces messages.

212
00:10:48,340 --> 00:10:52,220
En regardant le haut plus un,
défilement arrière comme nécessaire.

213
00:10:52,220 --> 00:10:53,930
Donc ici, je tapé make buggy1.

214
00:10:53,930 --> 00:10:55,700
Voici que la production de Clang comme prévu.

215
00:10:55,700 --> 00:10:57,290
>> Et voici la première erreur rouge.

216
00:10:57,290 --> 00:11:02,370
Utilisation d'identificateur non déclaré
chaîne, que je voulais dire standard?

217
00:11:02,370 --> 00:11:04,260
Donc, dans la norme est
en fait autre chose.

218
00:11:04,260 --> 00:11:06,240
Il se réfère à l'utilisateur de
Clavier, pour l'essentiel.

219
00:11:06,240 --> 00:11:08,080
>> Mais ce n'est pas ce que je voulais dire.

220
00:11:08,080 --> 00:11:11,770
Je voulais dire la chaîne, et je voulais get_string.

221
00:11:11,770 --> 00:11:16,200
Alors qu'est-ce que je
oublié de faire cette fois?

222
00:11:16,200 --> 00:11:20,230
Ce qui manque cette fois-ci?

223
00:11:20,230 --> 00:11:23,600
J'ai mon #include,
donc j'ai accès à printf.

224
00:11:23,600 --> 00:11:26,090
>> Mais qu'est-ce que j'ai pas
l'accès à l'instant?

225
00:11:26,090 --> 00:11:29,420
Eh bien, comme la dernière fois,
Je dois dire au compilateur

226
00:11:29,420 --> 00:11:31,691
Clang ce que ces fonctions sont.

227
00:11:31,691 --> 00:11:33,940
Get_string ne vient pas
avec C. Et en particulier, il

228
00:11:33,940 --> 00:11:38,160
ne vient pas dans la
header fichier.

229
00:11:38,160 --> 00:11:40,770
Il vient à la place de
quelque chose que le personnel a écrit,

230
00:11:40,770 --> 00:11:44,176
qui est un fichier différent
nom, mais bien nommé.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Donc, simplement en ajoutant qu'une ligne
de rappel code-- de la dernière fois

233
00:11:50,861 --> 00:11:53,610
que lorsque Clang court, ça va
à regarder mon code de haut en bas,

234
00:11:53,610 --> 00:11:54,193
de gauche à droite.

235
00:11:54,193 --> 00:11:57,200
Il va remarquer,
oh, vous voulez.

236
00:11:57,200 --> 00:11:59,900
Laisse-moi aller et trouve que,
où que ce soit sur le serveur,

237
00:11:59,900 --> 00:12:03,090
copier et coller, essentiellement,
dans le haut de votre propre fichier

238
00:12:03,090 --> 00:12:06,820
de telle sorte que, à ce stade de l'histoire,
ligne 1, le reste du programme

239
00:12:06,820 --> 00:12:11,651
peut, en effet, utiliser l'une des fonctions
celui-ci, parmi eux get_string.

240
00:12:11,651 --> 00:12:13,650
Je vais donc d'ignorer
le reste de ces erreurs,

241
00:12:13,650 --> 00:12:17,190
parce que je, en effet, soupçonner que seulement
le premier fait d'importance.

242
00:12:17,190 --> 00:12:20,780
Et je vais aller de l'avant et relancez,
après avoir sauvé mon dossier faire buggy1.

243
00:12:20,780 --> 00:12:22,580
Et voila, cela n'a pas fonctionné.

244
00:12:22,580 --> 00:12:29,200
Et si je fais ./buggy1 et tapez, pour
exemple, Zamyla, je va maintenant obtenir bonjour,

245
00:12:29,200 --> 00:12:32,000
Zamyla, au lieu de bonjour, monde.

246
00:12:32,000 --> 00:12:32,550
>> D'accord.

247
00:12:32,550 --> 00:12:35,890
Donc, les plats à emporter ici sont alors,
un, essayez de glaner autant que vous le pouvez

248
00:12:35,890 --> 00:12:39,140
des messages d'erreur seul, à la recherche
quelques-uns des mots reconnaissables.

249
00:12:39,140 --> 00:12:43,070
Sauf que, utiliser help50 par
le problème réglé spécification.

250
00:12:43,070 --> 00:12:46,500
Mais à défaut, aussi, toujours regarder
à l'erreur supérieure uniquement, au moins

251
00:12:46,500 --> 00:12:50,051
d'abord, pour voir quelles informations
il pourrait effectivement céder.

252
00:12:50,051 --> 00:12:52,300
Mais il se trouve qu'il y a
encore plus de fonctionnalités intégré

253
00:12:52,300 --> 00:12:55,030
dans la bibliothèque CS50 pour aider
vous dès le début du semestre

254
00:12:55,030 --> 00:12:57,580
et au début de la programmation
comprendre ce qui se passe mal.

255
00:12:57,580 --> 00:12:59,840
Alors, faisons un autre exemple ici.

256
00:12:59,840 --> 00:13:04,350
Je vais appeler ce buggy2, qui,
à nouveau, va être viciée out

257
00:13:04,350 --> 00:13:05,650
de la porte, par la conception.

258
00:13:05,650 --> 00:13:09,980
>> Et je vais aller de l'avant
et faire #include.

259
00:13:09,980 --> 00:13:12,580
Et puis je vais faire int main (void).

260
00:13:12,580 --> 00:13:14,840
Et puis je vais faire une boucle.

261
00:13:14,840 --> 00:13:16,690
Pour (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i est inférieur ou égal à 10.

263
00:13:18,750 --> 00:13:24,260
i ++, puis des accolades, je vais
pour imprimer seulement un symbole de hashtag ici

264
00:13:24,260 --> 00:13:25,920
et un caractère de nouvelle ligne.

265
00:13:25,920 --> 00:13:29,220
>> Donc, mon intention avec cette
programme est tout simplement

266
00:13:29,220 --> 00:13:33,150
itérer 10 fois
et à chaque itération

267
00:13:33,150 --> 00:13:35,260
de cette boucle à chaque fois que
à travers le cycle,

268
00:13:35,260 --> 00:13:37,660
imprimer un hashtag,
un hashtag, un hashtag.

269
00:13:37,660 --> 00:13:40,480
Une ligne par parce que je
avoir la nouvelle ligne là.

270
00:13:40,480 --> 00:13:42,787
Et rappeler que le pour
boucle, par dernière week--

271
00:13:42,787 --> 00:13:44,620
et vous aurez plus
familier avec la syntaxe

272
00:13:44,620 --> 00:13:47,170
en l'utilisant à la pratique
avant long-- cela me donne

273
00:13:47,170 --> 00:13:49,740
une variable appelée i et met à 0.

274
00:13:49,740 --> 00:13:52,650
>> Cette incrémente i sur
chaque itération de 1.

275
00:13:52,650 --> 00:13:54,940
Donc, je passe à 1 à 2 à 3.

276
00:13:54,940 --> 00:13:57,690
Et puis cette condition dans le
milieu entre les points-virgules

277
00:13:57,690 --> 00:14:03,010
est vérifié à chaque itération pour faire
sûr que nous sommes toujours à portée.

278
00:14:03,010 --> 00:14:06,830
Je tiens donc à itérer 10 fois, donc je
ont sorte de manière très intuitive juste

279
00:14:06,830 --> 00:14:09,070
mettre 10 car il ma limite supérieure.

280
00:14:09,070 --> 00:14:14,310
>> Et pourtant, quand je lance ce, après
compiler avec make buggy2--

281
00:14:14,310 --> 00:14:15,440
et il ne compile OK.

282
00:14:15,440 --> 00:14:17,980
Donc, je n'ai pas
erreur de syntaxe cette fois.

283
00:14:17,980 --> 00:14:20,940
Laissez-moi aller de l'avant maintenant
et exécuter buggy2, Entrée.

284
00:14:20,940 --> 00:14:22,620
Et faites défiler jusqu'à maintenant.

285
00:14:22,620 --> 00:14:24,890
Et laissez-moi augmenter
la taille de la fenêtre.

286
00:14:24,890 --> 00:14:33,720
>> Il me semble avoir 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Donc, il y a 11 hashtags, même si
Je clairement mis 10 à l'intérieur de cette boucle.

288
00:14:38,891 --> 00:14:42,140
Maintenant, certains d'entre vous pourraient voir immédiatement
ce que l'erreur est parce que, en effet, cette

289
00:14:42,140 --> 00:14:43,720
est pas une erreur très difficile à faire.

290
00:14:43,720 --> 00:14:46,070
Mais il est très souvent
fait très tôt.

291
00:14:46,070 --> 00:14:49,820
>> Ce que je veux souligner, cependant,
est, comment pourrais-je comprendre cela?

292
00:14:49,820 --> 00:14:52,300
Eh bien, il se trouve que
la Bibliothèque CS50 vient

293
00:14:52,300 --> 00:14:55,380
non seulement get_string et get_int
et get_float et d'autres fonctions.

294
00:14:55,380 --> 00:14:59,980
Il est également livré avec une fonction spéciale
appelé eprintf, ou, erreur printf.

295
00:14:59,980 --> 00:15:03,270
Et il existe uniquement pour faire
un peu plus facile pour vous

296
00:15:03,270 --> 00:15:06,310
lors du débogage de votre code juste
imprimer un message d'erreur sur l'écran

297
00:15:06,310 --> 00:15:07,850
et de savoir d'où il vient.

298
00:15:07,850 --> 00:15:11,000
>> Ainsi, par exemple, une chose que je pourrais
faire ici avec cette fonction est this--

299
00:15:11,000 --> 00:15:20,230
eprintf, et puis je vais aller de l'avant
et dire i est maintenant% i, backslash, n.

300
00:15:20,230 --> 00:15:22,330
Et je vais brancher la valeur de i.

301
00:15:22,330 --> 00:15:25,400
Et là-haut, parce que cette
est dans la bibliothèque CS50,

302
00:15:25,400 --> 00:15:27,580
Je vais aller de l'avant
et comprennent

303
00:15:27,580 --> 00:15:29,169
donc j'ai accès à cette fonction.

304
00:15:29,169 --> 00:15:31,460
Mais nous allons examiner ce que la ligne
9 est censé faire.

305
00:15:31,460 --> 00:15:32,670
Je vais supprimer cette suite.

306
00:15:32,670 --> 00:15:34,670
Cela n'a rien à voir
avec mon objectif primordial.

307
00:15:34,670 --> 00:15:39,090
Mais eprintf, erreur printf, est seulement destiné
de me donner quelques informations de diagnostic.

308
00:15:39,090 --> 00:15:42,460
Quand je lance mon programme, je veux
voir cela sur l'écran temporairement

309
00:15:42,460 --> 00:15:44,550
ainsi que de comprendre
Qu'est-ce qui se passe.

310
00:15:44,550 --> 00:15:47,330
>> Et, en effet, sur chaque
itération ici de la ligne 9

311
00:15:47,330 --> 00:15:49,260
Je veux voir, quelle est la valeur de i?

312
00:15:49,260 --> 00:15:50,290
Quelle est la valeur de i?

313
00:15:50,290 --> 00:15:51,280
Quelle est la valeur de i?

314
00:15:51,280 --> 00:15:55,650
Et, espérons-le, je devrais seulement
voir ce message, aussi, 10 fois.

315
00:15:55,650 --> 00:15:57,780
>> Alors laissez-moi aller de l'avant et
recompiler mon programme,

316
00:15:57,780 --> 00:15:59,905
comme je dois le faire en tout temps
Je fais un changement. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Et maintenant-- OK.

319
00:16:03,640 --> 00:16:04,820
Il y a beaucoup plus de choses.

320
00:16:04,820 --> 00:16:07,610
Alors permettez-moi de faire défiler dans
une fenêtre encore plus grand.

321
00:16:07,610 --> 00:16:10,190
>> Et vous verrez que chacune des
l'hashtags est toujours l'impression.

322
00:16:10,190 --> 00:16:15,270
Mais entre chacun d'eux est maintenant cette
sortie de diagnostic formaté comme suit.

323
00:16:15,270 --> 00:16:17,960
Le nom de mon programme ici est buggy2.

324
00:16:17,960 --> 00:16:20,432
Le nom du fichier est buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Le numéro de la ligne à partir de laquelle
ce fut imprimé est la ligne 9.

326
00:16:24,080 --> 00:16:27,500
Et puis à la droite de ce qui est le
message d'erreur que je me attends.

327
00:16:27,500 --> 00:16:30,701
>> Et ce qui est bien à ce sujet est que
maintenant je ne dois pas nécessairement compter

328
00:16:30,701 --> 00:16:32,200
dans ma tête ce que mon programme est en train de faire.

329
00:16:32,200 --> 00:16:34,240
Je peux voir que sur le
première itération i est 0,

330
00:16:34,240 --> 00:16:39,420
puis 1, puis 2, puis 3, puis 4, puis
5, puis 6, puis 7, puis 8, puis 9, puis

331
00:16:39,420 --> 00:16:40,980
dix.

332
00:16:40,980 --> 00:16:42,050
Donc, attendez une minute.

333
00:16:42,050 --> 00:16:43,740
Que se passe t-il ici?

334
00:16:43,740 --> 00:16:48,190
Il me semble encore être compter
comme prévu jusqu'à 10.

335
00:16:48,190 --> 00:16:50,550
>> Mais où ai-je commencer?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Donc, 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- le 11 doigt

338
00:16:58,040 --> 00:16:59,990
est une indication du problème.

339
00:16:59,990 --> 00:17:02,850
Il me semble avoir compté
à tort dans ma boucle.

340
00:17:02,850 --> 00:17:06,599
Plutôt que d'aller 10 itérations,
Je commence à 0,

341
00:17:06,599 --> 00:17:09,550
Je termine à et à travers 10.

342
00:17:09,550 --> 00:17:12,030
Mais parce que, comme un ordinateur,
Je compte à partir de 0,

343
00:17:12,030 --> 00:17:15,250
Je compterai jusqu'à
, mais pas à travers, 10.

344
00:17:15,250 --> 00:17:18,510
>> Et donc le correctif, je finis
réalisé ici, est l'une des deux choses.

345
00:17:18,510 --> 00:17:22,430
Je pourrais très simplement dire
compter jusqu'à moins de 10.

346
00:17:22,430 --> 00:17:27,260
Donc, 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, qui est, en effet, correct,

347
00:17:27,260 --> 00:17:28,900
même si cela semble un peu mal.

348
00:17:28,900 --> 00:17:35,070
Ou je pouvais faire inférieur ou égal
à 9, aussi longtemps que je commence à 0.

349
00:17:35,070 --> 00:17:40,056
Ou si vous ne voulez vraiment pas, vous
peut compter jusqu'à à 10, mais commencer à 1.

350
00:17:40,056 --> 00:17:41,680
Mais encore une fois, ceci est juste pas commun.

351
00:17:41,680 --> 00:17:43,977
En programming-- bien
non pas tant dans Scratch--

352
00:17:43,977 --> 00:17:45,810
mais dans la programmation en
C et d'autres langues,

353
00:17:45,810 --> 00:17:47,670
comme JavaScript et
Python et d'autres, il est

354
00:17:47,670 --> 00:17:49,880
juste très commun pour
notre discussion de binaire

355
00:17:49,880 --> 00:17:53,450
juste de commencer à compter à la
le plus petit nombre possible, qui est 0.

356
00:17:53,450 --> 00:17:53,950
D'accord.

357
00:17:53,950 --> 00:17:55,160
Voilà eprintf.

358
00:17:55,160 --> 00:17:58,600
Et encore une fois, maintenant que j'ai compris mon
problème, et je vais revenir à 0

359
00:17:58,600 --> 00:18:01,470
par moins de 10, je vais
d'aller et supprimer eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Il ne devrait pas être là quand je
expédier mon code ou soumettre mon code

361
00:18:04,580 --> 00:18:05,800
ou le montrer à quelqu'un d'autre.

362
00:18:05,800 --> 00:18:07,980
Il est vraiment juste signifiait
pour être utilisé temporairement.

363
00:18:07,980 --> 00:18:11,650
Mais maintenant, j'ai fixé cette
problème particulier aussi bien.

364
00:18:11,650 --> 00:18:16,780
>> Eh bien, nous allons faire un exemple de plus ici
que je vais fouetter comme suit.

365
00:18:16,780 --> 00:18:22,850
Je vais aller de l'avant et
#comprendre . 50 $

366
00:18:22,850 --> 00:18:25,580
Et je vais aller de l'avant
et #include.

367
00:18:25,580 --> 00:18:29,030
>> Et je vais sauver
ce fichier comme buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Et je vais aller de l'avant
et déclarer int main (void).

369
00:18:31,740 --> 00:18:34,186
Et puis à l'intérieur de là
Je vais faire int i _ -

370
00:18:34,186 --> 00:18:36,435
Je veux mettre en œuvre un programme
avec un get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Ce n'est pas une fonction qui existe encore.

373
00:18:40,770 --> 00:18:42,870
Nous allons donc mettre en œuvre
en un instant.

374
00:18:42,870 --> 00:18:45,541
Mais nous allons voir pourquoi
il est buggé au premier passage.

375
00:18:45,541 --> 00:18:47,290
Et une fois que je suis devenu
un int de l'utilisateur,

376
00:18:47,290 --> 00:18:53,365
Je vais juste pour l'impression% i est un négatif
entier, backslash, n, virgule, i.

377
00:18:53,365 --> 00:18:55,240
En d'autres termes, tout ce que
veulent ce programme pour faire

378
00:18:55,240 --> 00:18:58,000
est d'obtenir un int négatif de
l'utilisateur, puis imprimer

379
00:18:58,000 --> 00:18:59,980
que tel ou tel est un int négatif.

380
00:18:59,980 --> 00:19:02,080
>> Maintenant, je dois mettre en œuvre cette fonction.

381
00:19:02,080 --> 00:19:05,740
Donc, plus tard dans mon dossier, je vais aller
avant et déclarer une fonction appelée

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - et nous allons
revenir à ce que signifie encore une fois que la ligne

383
00:19:10,670 --> 00:19:18,790
dans un moment-- int n; do-- do
le following-- printf n est :.

384
00:19:18,790 --> 00:19:26,210
Et puis je vais faire n - get_int,
et faire cela alors que n est supérieur à 0.

385
00:19:26,210 --> 00:19:28,310
Et puis revenir n ;.

386
00:19:28,310 --> 00:19:31,730
>> Donc, il y a beaucoup de choses dans
cela, mais aucun d'entre eux, nous ne l'avons pas

387
00:19:31,730 --> 00:19:33,710
regarder la semaine dernière, au moins brièvement.

388
00:19:33,710 --> 00:19:36,980
Ainsi, sur la ligne 10 ici, j'ai déclaré un
fonction appelée get_negative_int,

389
00:19:36,980 --> 00:19:39,620
et je l'ai mis (void), en
entre parenthèses, la raison étant cette

390
00:19:39,620 --> 00:19:40,950
ne prend pas une entrée.

391
00:19:40,950 --> 00:19:42,910
Je ne passe rien
à cette fonction.

392
00:19:42,910 --> 00:19:44,690
Je suis juste quelque chose de lui.

393
00:19:44,690 --> 00:19:47,270
>> Et ce que je suis l'espoir de
revenir est un entier.

394
00:19:47,270 --> 00:19:50,040
Il n'y a pas de type de données dans
C appelé negative_int.

395
00:19:50,040 --> 00:19:52,880
Il est juste int, donc ça va
être sur nous pour vous

396
00:19:52,880 --> 00:19:55,340
que la valeur qui est en fait
retourné est non seulement un int

397
00:19:55,340 --> 00:19:56,380
mais est également négative.

398
00:19:56,380 --> 00:20:02,150
>> Sur la ligne 12, je déclare une variable
appelé n et de le rendre de type int.

399
00:20:02,150 --> 00:20:07,500
Et puis, dans la ligne 13 à 18 je suis
faire quelque chose alors quelque chose est vrai.

400
00:20:07,500 --> 00:20:11,040
Je vais de l'avant et l'impression
n est, du côlon, puis un espace,

401
00:20:11,040 --> 00:20:12,800
comme une invite pour l'utilisateur.

402
00:20:12,800 --> 00:20:16,410
>> Je puis en appelant get_int et
stocker sa valeur soi-disant retour

403
00:20:16,410 --> 00:20:18,130
en ce que la variable n.

404
00:20:18,130 --> 00:20:22,600
Mais je vais continuer à faire
alors que ce n est supérieur à 0.

405
00:20:22,600 --> 00:20:27,960
En d'autres termes, si l'utilisateur donne une me
int et ce nombre est supérieur à 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positif, je vais
juste garder reprompting l'utilisateur,

407
00:20:31,180 --> 00:20:37,160
garder reprompting, en les forçant à
coopérer et me donner un int négatif.

408
00:20:37,160 --> 00:20:41,640
>> Et une fois n est en fait negative--
supposons que l'utilisateur enfin types -50,

409
00:20:41,640 --> 00:20:46,710
alors cette boucle while est plus vrai
car -50 ne soit pas supérieur à 0.

410
00:20:46,710 --> 00:20:51,140
Donc nous sortir de cette
boucle logique et retour n.

411
00:20:51,140 --> 00:20:53,520
>> Mais il y a une autre
chose que je dois faire.

412
00:20:53,520 --> 00:20:56,190
Et je peux tout simplement faire
en copiant et collant

413
00:20:56,190 --> 00:20:58,540
une ligne de code en haut du fichier.

414
00:20:58,540 --> 00:21:01,630
Je dois apprendre à Clang,
ou une promesse de Clang,

415
00:21:01,630 --> 00:21:04,630
explicitement que je veux,
en effet, aller et mettre en œuvre

416
00:21:04,630 --> 00:21:06,020
cette fonction get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Il pourrait juste être plus faible dans le fichier.

418
00:21:07,674 --> 00:21:09,840
Encore une fois, rappelons que Clang
lit les choses de haut en bas,

419
00:21:09,840 --> 00:21:12,330
de gauche à droite, de sorte que vous ne pouvez pas
appeler une fonction si Clang

420
00:21:12,330 --> 00:21:15,330
ne sait pas qu'il va exister.

421
00:21:15,330 --> 00:21:18,430
>> Maintenant, malheureusement, ce programme,
comme certains d'entre vous ont remarqué,

422
00:21:18,430 --> 00:21:19,590
est déjà buggy.

423
00:21:19,590 --> 00:21:21,400
Laissez-moi aller de l'avant et faire buggy3.

424
00:21:21,400 --> 00:21:26,904
Il compile, donc mon problème maintenant est pas
une erreur de syntaxe, comme une erreur de texte,

425
00:21:26,904 --> 00:21:29,570
il est en fait va être une logique
erreur que j'ai délibérément

426
00:21:29,570 --> 00:21:32,450
faite comme une occasion de
étape à travers ce qui se passe.

427
00:21:32,450 --> 00:21:35,540
>> Je vais aller de l'avant
maintenant et exécuter buggy3.

428
00:21:35,540 --> 00:21:37,490
Et je vais aller
avant et ne pas coopérer.

429
00:21:37,490 --> 00:21:39,494
Je vais donner le numéro 1.

430
00:21:39,494 --> 00:21:41,410
Il n'a pas aimé, donc
ça me incite à nouveau.

431
00:21:41,410 --> 00:21:42,147
>> Que diriez-vous 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Aucun de ceux qui travaillent.

435
00:21:44,740 --> 00:21:46,890
Comment environ -50?

436
00:21:46,890 --> 00:21:48,560
Et le programme semble fonctionner.

437
00:21:48,560 --> 00:21:49,970
>> Permettez-moi d'essayer une fois de plus.

438
00:21:49,970 --> 00:21:53,400
Je vais essayer -1, semble fonctionner.

439
00:21:53,400 --> 00:21:56,380
Je vais essayer -2, semble fonctionner.

440
00:21:56,380 --> 00:21:59,640
Je vais essayer 0.

441
00:21:59,640 --> 00:22:01,684
Huh, qui est incorrect.

442
00:22:01,684 --> 00:22:03,350
Maintenant, nous allons être un peu pédant ici.

443
00:22:03,350 --> 00:22:07,090
Mais il est, en effet, le cas que 0
est ni positif ni négatif.

444
00:22:07,090 --> 00:22:11,150
Et donc le fait que mon programme est
dire que 0 est un entier négatif,

445
00:22:11,150 --> 00:22:12,820
ce n'est pas techniquement correcte.

446
00:22:12,820 --> 00:22:15,180
>> Maintenant, pourquoi est-il fait cela?

447
00:22:15,180 --> 00:22:16,270
Eh bien, il pourrait être évident.

448
00:22:16,270 --> 00:22:18,110
Et, en effet, le programme est
destiné à être assez simple

449
00:22:18,110 --> 00:22:19,670
de sorte que nous avons quelque chose à explorer.

450
00:22:19,670 --> 00:22:25,870
>> Mais nous allons introduire un troisième débogage
technique appelée ici debug50.

451
00:22:25,870 --> 00:22:27,750
Donc, ceci est un programme
que nous venons de créer

452
00:22:27,750 --> 00:22:30,770
cette année appelé debug50
qui vous permettra

453
00:22:30,770 --> 00:22:34,130
d'utiliser ce qu'on appelle un haut-
débogueur graphique dans CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Et un débogueur est juste un programme qui
permet généralement vous exécutez votre programme

455
00:22:38,400 --> 00:22:44,050
mais étape par étape par étape, la ligne
par ligne par ligne, pause, piquer

456
00:22:44,050 --> 00:22:47,626
autour, en regardant les variables de telle sorte que
le programme ne vient pas souffler devant vous

457
00:22:47,626 --> 00:22:49,750
et imprimer rapidement quelque chose
ou non imprimer quelque chose.

458
00:22:49,750 --> 00:22:53,250
Il vous donne l'occasion, à
vitesse humaine, d'interagir avec elle.

459
00:22:53,250 --> 00:22:55,470
>> Et pour ce faire, vous
tout simplement faire ce qui suit.

460
00:22:55,470 --> 00:22:58,479
Après la compilation de votre code,
qui je l'ai déjà fait, buggy3,

461
00:22:58,479 --> 00:23:00,020
aller de l'avant et exécutez debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Donc, un peu comme help50 a vous exécutez
help50 puis la commande,

464
00:23:06,760 --> 00:23:10,120
debug50 a vous exécutez debug50 et
puis le nom de la commande.

465
00:23:10,120 --> 00:23:14,440
>> Maintenant, regardez ce qui se passe sur mon écran,
sur le côté droit en particulier.

466
00:23:14,440 --> 00:23:19,400
Quand je frappe Run, tous les
Panneau cette-droite soudaine

467
00:23:19,400 --> 00:23:20,419
ouvre sur l'écran.

468
00:23:20,419 --> 00:23:22,210
Et il y a beaucoup de choses
sur au premier coup d'œil.

469
00:23:22,210 --> 00:23:25,110
Mais il n'y a pas trop
bien à vous soucier encore.

470
00:23:25,110 --> 00:23:28,570
>> Ce me montre tout
qui va à l'intérieur de mon programme

471
00:23:28,570 --> 00:23:31,130
en ce moment et via ces
boutons en haut sommet est alors

472
00:23:31,130 --> 00:23:35,910
me permettant de parcourir mon code
en fin de compte, étape par étape par étape.

473
00:23:35,910 --> 00:23:37,140
Mais pas encore.

474
00:23:37,140 --> 00:23:38,060
Remarquez ce qui se passe.

475
00:23:38,060 --> 00:23:40,600
À ma fenêtre de terminal
J'étant incité pour n.

476
00:23:40,600 --> 00:23:44,560
Et je vais aller de l'avant et
coopérer cette fois et tapez -1.

477
00:23:44,560 --> 00:23:48,770
Et bien qu'un peu cryptique, -1
est un entier négatif, comme prévu.

478
00:23:48,770 --> 00:23:52,020
>> Et puis l'enfant est sorti avec
état 0 gdbserver sortant.

479
00:23:52,020 --> 00:23:55,180
GDB, débogueur GNU, est le nom
du logiciel sous-jacent

480
00:23:55,180 --> 00:23:56,620
qui met en œuvre ce débogueur.

481
00:23:56,620 --> 00:24:00,500
Mais tout cela signifie vraiment, le débogueur
alla parce que mon programme quit

482
00:24:00,500 --> 00:24:01,710
et tout allait bien.

483
00:24:01,710 --> 00:24:06,020
Si je veux déboguer vraiment mon programme,
Je dois dire préemptive debug50,

484
00:24:06,020 --> 00:24:08,920
où je veux commencer
pas à pas dans mon code?

485
00:24:08,920 --> 00:24:11,750
>> Et peut-être la façon la plus simple
de le faire est la suivante.

486
00:24:11,750 --> 00:24:15,300
Si je plane sur
gouttière de mon rédacteur en chef ici,

487
00:24:15,300 --> 00:24:19,090
donc vraiment juste dans la barre latérale ici,
à gauche du numéro de ligne,

488
00:24:19,090 --> 00:24:21,870
Notez que si je viens de cliquer sur
une fois, je mets un petit point rouge.

489
00:24:21,870 --> 00:24:24,460
Et ce petit point rouge,
comme un panneau d'arrêt, signifie, hé,

490
00:24:24,460 --> 00:24:29,430
debug50, l'exécution de pause de mon code
là quand je lance ce programme.

491
00:24:29,430 --> 00:24:30,260
>> Alors, faisons cela.

492
00:24:30,260 --> 00:24:37,340
Laissez-moi aller de l'avant et d'exécuter mon programme
à nouveau avec debug50 ./buggy3, Entrée.

493
00:24:37,340 --> 00:24:40,110
Et maintenant, un avis, quelque chose
différent est arrivé.

494
00:24:40,110 --> 00:24:42,440
Je ne suis pas d'être invité
encore dans ma fenêtre de terminal

495
00:24:42,440 --> 00:24:45,430
pour quoi que ce soit, parce que je n'ai pas
il encore obtenu dans mon programme.

496
00:24:45,430 --> 00:24:47,950
Notez que la ligne 8
qui est maintenant mis en évidence,

497
00:24:47,950 --> 00:24:51,720
et il y a une petite flèche à
disant gauche, vous êtes en pause ici.

498
00:24:51,720 --> 00:24:55,030
Cette ligne de code, ligne
8, n'a pas encore exécuté.

499
00:24:55,030 --> 00:24:58,940
>> Et ce qui est curieux, si je regarde
ici sur le côté droit,

500
00:24:58,940 --> 00:25:03,530
remarque que i est une locale
variable locale dans le sens

501
00:25:03,530 --> 00:25:05,450
qu'il est à l'intérieur de la fonction actuelle.

502
00:25:05,450 --> 00:25:08,920
Et sa valeur, apparemment par défaut,
et une sorte de pratique, est 0.

503
00:25:08,920 --> 00:25:10,260
Mais je ne tape 0.

504
00:25:10,260 --> 00:25:13,410
Cela arrive juste pour être son
valeur par défaut pour le moment.

505
00:25:13,410 --> 00:25:15,490
>> Alors laissez-moi aller de l'avant et de faire cela maintenant.

506
00:25:15,490 --> 00:25:18,680
Laissez-moi aller de l'avant et sur
en haut à droite ici, je suis

507
00:25:18,680 --> 00:25:20,970
aller de l'avant et
cliquez sur cette première icône qui

508
00:25:20,970 --> 00:25:25,360
signifie pas sur ce qui signifie ne pas sauter
mais pas au-dessus de cette ligne de code,

509
00:25:25,360 --> 00:25:27,770
exécuter le long du chemin.

510
00:25:27,770 --> 00:25:30,710
>> Et maintenant, remarquez, mon
invite vient de changer.

511
00:25:30,710 --> 00:25:31,380
Pourquoi donc?

512
00:25:31,380 --> 00:25:33,639
Je l'ai dit debug50,
exécuter cette ligne de code.

513
00:25:33,639 --> 00:25:34,930
Qu'est-ce que cette ligne de code do?

514
00:25:34,930 --> 00:25:35,960
me Invites pour un int.

515
00:25:35,960 --> 00:25:36,460
D'ACCORD.

516
00:25:36,460 --> 00:25:37,400
Permettez-moi de coopérer.

517
00:25:37,400 --> 00:25:41,340
Laissez-moi aller de l'avant maintenant et tapez -1, entrez.

518
00:25:41,340 --> 00:25:42,920
Et maintenant remarquer ce qui a changé.

519
00:25:42,920 --> 00:25:46,060
Sur le côté droit,
ma variable locale i

520
00:25:46,060 --> 00:25:48,200
est indiqué comme étant -1 maintenant.

521
00:25:48,200 --> 00:25:49,810
Et il est toujours de type int.

522
00:25:49,810 --> 00:25:53,102
>> Et remarquez aussi, mon soi-disant
appeler pile, où ai-je fais une pause?

523
00:25:53,102 --> 00:25:54,810
Nous parlerons plus
à l'avenir.

524
00:25:54,810 --> 00:25:58,620
Mais la pile d'appel se réfère simplement à ce que
fonctions sont actuellement en mouvement.

525
00:25:58,620 --> 00:26:00,040
À l'heure actuelle, il est juste principal.

526
00:26:00,040 --> 00:26:03,590
Et maintenant la seule locale
variable est i avec une valeur de 1.

527
00:26:03,590 --> 00:26:09,840
>> Et quand je fais un pas enfin terminée cette ligne
ici, avec cette même icône en haut à droite,

528
00:26:09,840 --> 00:26:11,410
-1 Est un entier négatif.

529
00:26:11,410 --> 00:26:13,580
Maintenant, il est une pause au cours de cette accolade.

530
00:26:13,580 --> 00:26:14,740
Laissons-le faire sa chose.

531
00:26:14,740 --> 00:26:17,300
Je fais un pas sur cette ligne, et le tour est joué.

532
00:26:17,300 --> 00:26:20,240
>> Donc, pas tout ce que terriblement
éclairant encore,

533
00:26:20,240 --> 00:26:23,550
mais il ne m'a laissé une pause
et réfléchir logiquement

534
00:26:23,550 --> 00:26:24,870
ce que ce programme est en train de faire.

535
00:26:24,870 --> 00:26:26,890
Mais cela n'a pas été le cas erronée.

536
00:26:26,890 --> 00:26:28,510
Faisons-le à nouveau comme suit.

537
00:26:28,510 --> 00:26:31,340
>> Je vais laisser ce point d'arrêt
sur la ligne 8 avec le point rouge.

538
00:26:31,340 --> 00:26:32,830
Je vais relancer debug50.

539
00:26:32,830 --> 00:26:34,400
Il est automatiquement en pause ici.

540
00:26:34,400 --> 00:26:37,660
Mais cette fois, au lieu de
enjambant cette ligne,

541
00:26:37,660 --> 00:26:42,290
laissez-moi aller effectivement à l'intérieur de
get_negative_int et comprendre,

542
00:26:42,290 --> 00:26:45,530
pourquoi est-il accepter 0 comme une réponse valable?

543
00:26:45,530 --> 00:26:47,990
>> Ainsi, au lieu de cliquer sur Step Over.

544
00:26:47,990 --> 00:26:50,630
Je vais aller de l'avant
et cliquez sur Step Into.

545
00:26:50,630 --> 00:26:54,030
Et remarquez que la ligne 8 qui est
maintenant mis en évidence soudain

546
00:26:54,030 --> 00:26:56,900
devient la ligne 17.

547
00:26:56,900 --> 00:26:59,947
>> Maintenant, il est pas que le débogueur
a sauté les lignes 14 et 15 et 16.

548
00:26:59,947 --> 00:27:01,780
Il est juste il n'y a rien
vous montrer là.

549
00:27:01,780 --> 00:27:04,050
Ceux-ci sont tout simplement déclarer des variables,
Et puis il y a le mot Do

550
00:27:04,050 --> 00:27:05,390
puis une accolade ouverte.

551
00:27:05,390 --> 00:27:09,227
La seule ligne fonctionnelle qui est
juteuse est vraiment celui-là, 17.

552
00:27:09,227 --> 00:27:11,060
Et voilà où nous avons
pause automatiquement.

553
00:27:11,060 --> 00:27:13,870
>> Alors printf ( "n.is:") ;, donc
qui n'a pas encore eu lieu.

554
00:27:13,870 --> 00:27:18,250
Donc, nous allons aller de l'avant et cliquez sur Step Over.

555
00:27:18,250 --> 00:27:20,326
Maintenant, mon invite, en effet,
changé ( «n est égal à:").

556
00:27:20,326 --> 00:27:22,450
Maintenant get_int, je ne vais pas
à peine d'entrer dans,

557
00:27:22,450 --> 00:27:24,750
parce que cette fonction était
faite par CS50 dans la bibliothèque.

558
00:27:24,750 --> 00:27:25,750
Il est probablement correct.

559
00:27:25,750 --> 00:27:28,440
>> Je vais donc aller de l'avant et
sorte de coopérer en lui donnant

560
00:27:28,440 --> 00:27:30,590
un int, mais pas un int négatif.

561
00:27:30,590 --> 00:27:32,870
Alors laissez-moi aller de l'avant et a frappé 0.

562
00:27:32,870 --> 00:27:39,460
Et maintenant ce qui se passe ici
quand je descends à la ligne 21?

563
00:27:39,460 --> 00:27:40,890
Je ne l'ai pas réitéré à nouveau.

564
00:27:40,890 --> 00:27:43,320
Je ne semble pas être coincé dans cette boucle.

565
00:27:43,320 --> 00:27:45,990
En d'autres termes, cette jaune
bar n'a pas empêché d'aller autour,

566
00:27:45,990 --> 00:27:47,130
et autour, et autour.

567
00:27:47,130 --> 00:27:48,340
>> Maintenant, pourquoi est-ce?

568
00:27:48,340 --> 00:27:49,920
Eh bien, n, ce qui est n en ce moment?

569
00:27:49,920 --> 00:27:53,280
Je peux regarder à l'échelle locale
variables dans le débogueur.

570
00:27:53,280 --> 00:27:53,816
n est égal à 0.

571
00:27:53,816 --> 00:27:55,190
Très bien, quel était mon état?

572
00:27:55,190 --> 00:27:58,700
>> 20-- ligne 20 est, ainsi,
0 est supérieur à 0.

573
00:27:58,700 --> 00:27:59,500
Ce n'est pas vrai.

574
00:27:59,500 --> 00:28:01,020
0 est inférieure ou égale à 0.

575
00:28:01,020 --> 00:28:02,820
Et donc je me suis cassé dehors de ça.

576
00:28:02,820 --> 00:28:06,370
>> Et voilà pourquoi on line
21, si je continue en fait,

577
00:28:06,370 --> 00:28:10,370
Je vais retourner 0, même
bien que je l'aurais rejeté 0

578
00:28:10,370 --> 00:28:12,484
ne pas être réellement négatif.

579
00:28:12,484 --> 00:28:14,650
Alors maintenant, je ne sais pas vraiment même
soucier du débogueur.

580
00:28:14,650 --> 00:28:16,900
Got it, je n'a pas besoin de
savoir ce qui se passe plus.

581
00:28:16,900 --> 00:28:19,233
>> Je vais donc aller de l'avant et
cliquez simplement sur le bouton de lecture,

582
00:28:19,233 --> 00:28:20,240
et laisser cette finition vers le haut.

583
00:28:20,240 --> 00:28:23,440
Maintenant, je me suis rendu compte que mon
bug est apparemment sur la ligne 20.

584
00:28:23,440 --> 00:28:25,160
Voilà mon erreur logique.

585
00:28:25,160 --> 00:28:28,100
>> Et qu'est-ce que je veux
à faire pour changer cela?

586
00:28:28,100 --> 00:28:32,500
Si le problème est que je ne suis pas
attraper 0, il est juste une erreur de logique.

587
00:28:32,500 --> 00:28:35,910
Et je peux dire tout n est
supérieur ou égal à 0,

588
00:28:35,910 --> 00:28:38,330
garder invite encore et encore à l'utilisateur.

589
00:28:38,330 --> 00:28:41,050
>> Donc, encore une fois, simple erreur, peut-être
même évident quand vous me voyiez

590
00:28:41,050 --> 00:28:42,410
écrire il y a seulement quelques minutes.

591
00:28:42,410 --> 00:28:44,570
Mais les plats à emporter ici
est que, avec mise au point 50,

592
00:28:44,570 --> 00:28:46,850
et avec le débogage
logiciels plus généralement,

593
00:28:46,850 --> 00:28:51,370
vous avez ce nouveau pouvoir à
marcher à travers votre propre code, regardez

594
00:28:51,370 --> 00:28:55,590
via ce panneau de droite ce
vos valeurs variables sont.

595
00:28:55,590 --> 00:28:57,700
Donc, vous ne faites pas nécessairement
avoir à utiliser quelque chose

596
00:28:57,700 --> 00:29:00,630
comme vous eprintf d'imprimer ces valeurs.

597
00:29:00,630 --> 00:29:04,430
Vous pouvez réellement les voir
visuellement sur l'écran.

598
00:29:04,430 --> 00:29:08,920
>> Maintenant, au-delà de cela, il est intéressant de noter
qu'il ya une autre technique qui est

599
00:29:08,920 --> 00:29:09,890
effectivement super-commune.

600
00:29:09,890 --> 00:29:13,120
Et on peut se demander pourquoi ce petit
guy ici a été assis sur la scène.

601
00:29:13,120 --> 00:29:16,490
Donc, il y a cette technique, généralement
connu sous le nom de caoutchouc canard débogage,

602
00:29:16,490 --> 00:29:18,786
qui est vraiment juste un
témoigne du fait

603
00:29:18,786 --> 00:29:20,660
que, souvent, lorsque les programmeurs
sont l'écriture de code,

604
00:29:20,660 --> 00:29:22,650
ils ne sont pas nécessairement
collaborer avec les autres,

605
00:29:22,650 --> 00:29:24,030
ou de travailler dans un environnement partagé.

606
00:29:24,030 --> 00:29:25,050
>> Ils sont en quelque sorte à la maison.

607
00:29:25,050 --> 00:29:25,910
Peut-être qu'il est tard dans la nuit.

608
00:29:25,910 --> 00:29:28,190
Ils essaient de chiffre
certains bug dans leur code.

609
00:29:28,190 --> 00:29:29,330
Et ils sont tout simplement pas le voir.

610
00:29:29,330 --> 00:29:30,329
>> Et il n'y a pas de colocataire.

611
00:29:30,329 --> 00:29:31,250
Il n'y a pas TF.

612
00:29:31,250 --> 00:29:32,680
Il n'y a pas de CA autour.

613
00:29:32,680 --> 00:29:36,440
Tout ce qu'ils ont sur leur plateau
est ce petit canard en caoutchouc.

614
00:29:36,440 --> 00:29:39,030
>> Et canard en caoutchouc débogage
est juste cette invitation

615
00:29:39,030 --> 00:29:42,780
de penser à quelque chose d'aussi stupide
car cela comme une véritable créature,

616
00:29:42,780 --> 00:29:46,940
et fait marcher à travers votre code
verbalement à cet objet inanimé.

617
00:29:46,940 --> 00:29:49,230
Ainsi, par exemple, si
ceci est mon exemple ici--

618
00:29:49,230 --> 00:29:52,470
et de rappeler que plus tôt
le problème était présent,

619
00:29:52,470 --> 00:29:58,140
si je supprime cette première ligne de code,
et je vais de l'avant et de faire à nouveau Buggy 0,

620
00:29:58,140 --> 00:30:01,220
rappeler que je devais ces
les messages d'erreur ici.

621
00:30:01,220 --> 00:30:05,997
Donc, l'idée ici, ridicule si je
sentir au moment de faire publiquement,

622
00:30:05,997 --> 00:30:06,580
est cette erreur.

623
00:30:06,580 --> 00:30:10,910
>> OK, donc mon problème est que je l'ai
implicitement déclaré une fonction de bibliothèque.

624
00:30:10,910 --> 00:30:12,610
Et que la fonction de bibliothèque est printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, déclarer
me rappelle de prototypes.

626
00:30:15,290 --> 00:30:18,930
>> Cela signifie que je dois effectivement
dire au compilateur à l'avance ce

627
00:30:18,930 --> 00:30:19,980
la fonction ressemble.

628
00:30:19,980 --> 00:30:20,930
Attends une minute.

629
00:30:20,930 --> 00:30:23,580
Je n'ai pas io.h. norme

630
00:30:23,580 --> 00:30:24,530
Merci beaucoup.

631
00:30:24,530 --> 00:30:27,330
>> Il suffit donc de ce processus de-- vous
ne pas besoin d'avoir fait un canard.

632
00:30:27,330 --> 00:30:29,819
Mais cette idée de la marche
vous-même par votre propre code

633
00:30:29,819 --> 00:30:31,610
de sorte que vous entendez même
vous-même, de sorte que vous

634
00:30:31,610 --> 00:30:35,620
réaliser des omissions dans votre propre
remarques, est généralement l'idée.

635
00:30:35,620 --> 00:30:38,910
>> Et, peut-être plus logique, non pas
bien avec celui-là, mais le plus impliqué

636
00:30:38,910 --> 00:30:44,220
exemple, nous venons de le faire en 3.c buggy
vous pourriez vous promener à travers elle

637
00:30:44,220 --> 00:30:45,310
comme suit.

638
00:30:45,310 --> 00:30:49,190
Donc, tout droit, le caoutchouc
Ducky, DDB, si vous voulez.

639
00:30:49,190 --> 00:30:52,350
Ici, nous avons dans ma fonction principale,
J'appelle obtenir int négatif.

640
00:30:52,350 --> 00:30:54,660
>> Et je reçois la valeur de retour.

641
00:30:54,660 --> 00:31:00,410
Je stocker sur le côté gauche
sur la ligne 8 dans une variable appelée i.

642
00:31:00,410 --> 00:31:02,380
OK, mais attendez, comment avez
qui obtiennent cette valeur?

643
00:31:02,380 --> 00:31:04,130
Permettez-moi de regarder la fonction dans la ligne 12.

644
00:31:04,130 --> 00:31:05,760
>> Dans la ligne 12, nous avons obtenir int négatif.

645
00:31:05,760 --> 00:31:08,190
Ne prend pas toutes les entrées,
ne retourne un int, OK.

646
00:31:08,190 --> 00:31:10,929
Je déclare sur la ligne 14 une variable n.

647
00:31:10,929 --> 00:31:12,220
Il va stocker un nombre entier.

648
00:31:12,220 --> 00:31:13,760
C'est ce que je veux.

649
00:31:13,760 --> 00:31:18,480
>> Donc, faire ce qui suit tout en n est-- laissez
me défais ce que le correctif je l'ai déjà fait.

650
00:31:18,480 --> 00:31:22,710
Ainsi, alors n est supérieur à
0, imprimez n est, OK.

651
00:31:22,710 --> 00:31:25,170
Et puis appelez se int stockée dans n.

652
00:31:25,170 --> 00:31:30,160
Et puis vérifier si n est 0,
n est pas-- il est là.

653
00:31:30,160 --> 00:31:31,910
Donc, encore une fois, vous ne
besoin le canard réelle.

654
00:31:31,910 --> 00:31:35,650
Mais vous marcher à travers
votre code comme un exercice intellectuel

655
00:31:35,650 --> 00:31:37,720
sera souvent vous aider
réaliser ce qui se passe,

656
00:31:37,720 --> 00:31:41,170
plutôt que de simplement faire quelque chose
comme ça, à regarder l'écran,

657
00:31:41,170 --> 00:31:43,720
et ne pas vous parler à travers
, ce qui est franchement pas

658
00:31:43,720 --> 00:31:46,270
à peu près comme une technique efficace.

659
00:31:46,270 --> 00:31:48,620
Donc là vous l'avez, un
nombre de techniques différentes

660
00:31:48,620 --> 00:31:52,102
pour le débogage effectivement votre code
et trouver la faute, qui

661
00:31:52,102 --> 00:31:54,810
devraient être des outils dans votre boîte à outils
de sorte que vous n'êtes pas tard dans la nuit,

662
00:31:54,810 --> 00:31:57,660
en particulier, vous êtes dans la salle
salles, ou à des heures de bureau,

663
00:31:57,660 --> 00:32:00,368
cogner la tête contre le
mur, essayant de résoudre un problème.

664
00:32:00,368 --> 00:32:02,020
Sachez qu'il existe des outils logiciels.

665
00:32:02,020 --> 00:32:03,720
Il existe des outils de canard en caoutchouc.

666
00:32:03,720 --> 00:32:09,630
Et il y a toute une équipe de
soutenir en attendant de donner un coup de main.

667
00:32:09,630 --> 00:32:13,120
>> Alors maintenant, un mot sur le problème
ensembles, et sur ce que nous vous en espérant

668
00:32:13,120 --> 00:32:15,620
sortir d'eux, et comment
nous allons sur l'évaluation.

669
00:32:15,620 --> 00:32:17,680
Par le programme de cours,
Les ensembles de problèmes de CS50

670
00:32:17,680 --> 00:32:22,320
sont évaluées sur quatre axes primaires, de sorte que
à speak-- portée, l'exactitude, la conception,

671
00:32:22,320 --> 00:32:23,060
et le style.

672
00:32:23,060 --> 00:32:25,910
Et la portée se réfère simplement à combien
de la pièce que vous avez mordu?

673
00:32:25,910 --> 00:32:28,080
Combien d'un problème avez-vous essayé?

674
00:32:28,080 --> 00:32:30,110
Quel niveau d'effort
avez-vous manifesté?

675
00:32:30,110 --> 00:32:35,750
>> Exactitude est, fait le travail de programme
il est censé selon les spécifications du CS50

676
00:32:35,750 --> 00:32:38,640
lorsque vous fournissez certaines entrées
ou certaines sorties à revenir?

677
00:32:38,640 --> 00:32:41,130
Le design est le plus subjectif d'entre eux.

678
00:32:41,130 --> 00:32:43,360
Et il est celui qui sera
le plus long d'apprendre

679
00:32:43,360 --> 00:32:47,220
et la plus longue pour enseigner, en
pour autant que cela se résume à,

680
00:32:47,220 --> 00:32:49,530
comment bien écrit est votre code?

681
00:32:49,530 --> 00:32:52,920
>> Il est une chose de simplement imprimer le bon
sorties ou retourner les bonnes valeurs.

682
00:32:52,920 --> 00:32:55,400
Mais faites-vous comme
efficacement que possible?

683
00:32:55,400 --> 00:32:58,210
Est-ce que vous faites fracture
et conquérir, ou binaire

684
00:32:58,210 --> 00:33:01,500
recherche comme nous le verrons bientôt que nous avons fait
il y a deux semaines avec le livre de téléphone?

685
00:33:01,500 --> 00:33:04,670
Y at-il de meilleures façons de résoudre le
problème que vous avez actuellement ici?

686
00:33:04,670 --> 00:33:06,380
Voilà une occasion pour une meilleure conception.

687
00:33:06,380 --> 00:33:08,530
>> Et puis comment style--
jolie est votre code?

688
00:33:08,530 --> 00:33:12,370
Vous remarquerez que je suis assez
notamment à propos de l'indentation mon code,

689
00:33:12,370 --> 00:33:15,300
et faire en sorte mes variables
sont raisonnablement nommé. n,

690
00:33:15,300 --> 00:33:19,660
tout court, est un bon nom pour un
nombre, i pour un nombre entier de comptage,

691
00:33:19,660 --> 00:33:20,727
s pour une chaîne.

692
00:33:20,727 --> 00:33:22,560
Et nous pouvons avoir plus
variable de style noms.

693
00:33:22,560 --> 00:33:25,500
Le style est à quel point
ne regarde votre code?

694
00:33:25,500 --> 00:33:26,600
Et comment est-il lisible?

695
00:33:26,600 --> 00:33:29,650
>> Et au fil du temps, ce que votre PS
et TFs feront au cours

696
00:33:29,650 --> 00:33:31,870
est vous fournir cette
genre de rétroaction qualitative

697
00:33:31,870 --> 00:33:34,330
de sorte que vous obtenez une meilleure
à ces différents aspects.

698
00:33:34,330 --> 00:33:37,510
Et en termes de la façon dont nous
évaluer chacun de ces axes,

699
00:33:37,510 --> 00:33:40,080
il est généralement avec très peu
seaux pour que vous, en général,

700
00:33:40,080 --> 00:33:41,680
avoir une idée de la façon dont vous faites.

701
00:33:41,680 --> 00:33:45,680
Et, en effet, si vous recevez un score
aucun de ceux exactitude axes--, conception

702
00:33:45,680 --> 00:33:49,659
et le style especially-- ce nombre
sera généralement compris entre 1 et 5.

703
00:33:49,659 --> 00:33:52,450
Et, littéralement, si vous obtenez
3 est au début du semestre,

704
00:33:52,450 --> 00:33:53,977
C'est une très bonne chose.

705
00:33:53,977 --> 00:33:55,810
Cela signifie qu'il ya encore
marge d'amélioration,

706
00:33:55,810 --> 00:33:58,490
qui vous espérer dans
prendre une classe pour la première fois.

707
00:33:58,490 --> 00:34:01,820
Il y a, espérons quelque peu de plafond
à laquelle vous êtes aspirant à atteindre.

708
00:34:01,820 --> 00:34:03,970
Et ainsi obtenir la sur de 3
les premières pièces,

709
00:34:03,970 --> 00:34:06,550
sinon de quelque 2 et de 4,
est, en effet, une bonne chose.

710
00:34:06,550 --> 00:34:08,880
Il est bien à portée,
bien en deçà des attentes.

711
00:34:08,880 --> 00:34:11,421
>> Et si votre esprit est la course, attendez
une minute, trois sur cinq.

712
00:34:11,421 --> 00:34:12,620
C'est vraiment un sur 10 6.

713
00:34:12,620 --> 00:34:13,560
C'est de 60%.

714
00:34:13,560 --> 00:34:14,830
Mon Dieu, qui est un F.

715
00:34:14,830 --> 00:34:15,870
>> Ce n'est pas.

716
00:34:15,870 --> 00:34:17,600
Elle l'est pas, en effet, que.

717
00:34:17,600 --> 00:34:22,710
Au contraire, il est l'occasion d'améliorer
au cours du semestre.

718
00:34:22,710 --> 00:34:25,580
Et si vous obtenez un certain
poors, ce sont une occasion

719
00:34:25,580 --> 00:34:29,199
pour profiter des heures de bureau,
certainement sections et d'autres ressources.

720
00:34:29,199 --> 00:34:32,840
>> Le mieux est l'occasion, vraiment,
d'être fiers de savoir jusqu'où vous avez

721
00:34:32,840 --> 00:34:34,520
venir au cours du semestre.

722
00:34:34,520 --> 00:34:38,199
Donc, ne réalisent, si rien
d'autre, trois est bonne.

723
00:34:38,199 --> 00:34:40,179
Et il laisse place à la croissance au fil du temps.

724
00:34:40,179 --> 00:34:43,090
>> En ce qui concerne la façon dont les axes sont
pondérée, réaliste vous êtes

725
00:34:43,090 --> 00:34:46,745
va passer plus de temps à
des choses à travailler, et encore moins correctement.

726
00:34:46,745 --> 00:34:49,120
Et exactitude tend à
pondérer le plus, comme avec

727
00:34:49,120 --> 00:34:51,360
ce facteur multiplicatif de trois.

728
00:34:51,360 --> 00:34:54,659
La conception est également important, mais
quelque chose que vous ne faites pas nécessairement

729
00:34:54,659 --> 00:34:58,220
passer toutes ces heures
essayer d'obtenir les choses à travailler.

730
00:34:58,220 --> 00:35:00,019
>> Et il est donc pondéré
un peu plus légère.

731
00:35:00,019 --> 00:35:01,560
Et puis le style est pondéré le moins.

732
00:35:01,560 --> 00:35:03,710
Même si elle est pas moins
importante fondamentalement,

733
00:35:03,710 --> 00:35:05,990
il est juste, peut-être, la
chose la plus facile à faire droit,

734
00:35:05,990 --> 00:35:08,440
imitant les exemples que nous
faire en lecture et de l'article,

735
00:35:08,440 --> 00:35:11,080
avec des choses joliment
indenté, et commenté,

736
00:35:11,080 --> 00:35:14,320
et est ainsi de suite parmi les plus faciles
choses à faire et obtenir droite.

737
00:35:14,320 --> 00:35:16,960
Donc, en tant que telle, réaliser
que ce sont des points

738
00:35:16,960 --> 00:35:19,000
qui sont relativement faciles à saisir.

739
00:35:19,000 --> 00:35:22,360
>> Et maintenant un mot sur
this-- honnêteté académique.

740
00:35:22,360 --> 00:35:25,150
Donc, par le cours de
syllabus, vous verrez

741
00:35:25,150 --> 00:35:27,630
que le cours a assez
peu de la langue autour de cela.

742
00:35:27,630 --> 00:35:31,380
Et le cours prend la question de la
l'honnêteté intellectuelle très au sérieux.

743
00:35:31,380 --> 00:35:33,450
>> Nous avons la distinction,
pour le meilleur ou pour le pire,

744
00:35:33,450 --> 00:35:36,570
d'avoir envoyé chaque année plus
les étudiants à des mesures disciplinaires

745
00:35:36,570 --> 00:35:39,670
que la plupart de tout autre
Bien sûr, que je suis au courant.

746
00:35:39,670 --> 00:35:42,580
Cela ne veut pas nécessairement
indicative du fait

747
00:35:42,580 --> 00:35:46,340
que les étudiants CS ou étudiants CS50, sont
pas moins honnête que vos camarades de classe.

748
00:35:46,340 --> 00:35:49,090
Mais la réalité que dans ce
monde, par voie électronique, nous venons de

749
00:35:49,090 --> 00:35:50,990
ont technologique
des moyens de détecter cela.

750
00:35:50,990 --> 00:35:53,360
>> Il est important pour nous
l'équité entre la classe

751
00:35:53,360 --> 00:35:58,550
que nous faisons détecter ce, et augmenter
la question quand nous voyons les choses.

752
00:35:58,550 --> 00:36:01,980
Et juste pour peindre un tableau, et vraiment
pour aider à quelque chose comme ce puits dans,

753
00:36:01,980 --> 00:36:04,600
ceux-ci sont les nombres de
les étudiants au cours des 10 dernières années

754
00:36:04,600 --> 00:36:07,610
qui ont été impliqués dans une
ces questions d'honnêteté académique,

755
00:36:07,610 --> 00:36:10,990
avec quelques 32 étudiants
de l'automne 2015, ce qui

756
00:36:10,990 --> 00:36:13,760
est-à-dire que nous ne prenons
la question très au sérieux.

757
00:36:13,760 --> 00:36:18,380
Et, en fin de compte, ces chiffres composent,
plus récemment, d'environ 3%, 4%, ou

758
00:36:18,380 --> 00:36:19,120
de la classe.

759
00:36:19,120 --> 00:36:25,220
>> Donc, pour le super majorité des étudiants
il semble que les lignes sont claires.

760
00:36:25,220 --> 00:36:27,940
Mais ne gardez cela à
l'esprit, en particulier la fin

761
00:36:27,940 --> 00:36:32,080
la nuit quand aux prises avec
une solution à un ensemble de problèmes,

762
00:36:32,080 --> 00:36:34,830
qu'il existe des mécanismes
pour vous-même de mieux en mieux

763
00:36:34,830 --> 00:36:37,870
soutien que vous pourriez
penser, même à cette heure.

764
00:36:37,870 --> 00:36:40,514
Sachez que lorsque nous recevons
soumissions d'étudiants, nous traversons

765
00:36:40,514 --> 00:36:43,430
comparer chaque présentation cette année
contre toute présentation de l'année dernière,

766
00:36:43,430 --> 00:36:47,590
contre toute soumission à partir de 2007,
et depuis, en regardant, ainsi,

767
00:36:47,590 --> 00:36:49,931
Code référentiels en ligne,
forums de discussion, des sites d'emploi.

768
00:36:49,931 --> 00:36:51,806
Et nous mentionnons cela,
vraiment, tout pour le bien

769
00:36:51,806 --> 00:36:56,040
de la divulgation complète, que si
quelqu'un d'autre peut le trouver en ligne,

770
00:36:56,040 --> 00:36:57,880
certes, nous le pouvons aussi le cours.

771
00:36:57,880 --> 00:37:00,100
Mais, vraiment, l'esprit
du cours se résume

772
00:37:00,100 --> 00:37:01,650
à cette clause dans le programme.

773
00:37:01,650 --> 00:37:03,670
Il est vraiment juste, raisonnable.

774
00:37:03,670 --> 00:37:06,680
>> Et si nous devions expliquer cela
avec juste un peu plus la langue,

775
00:37:06,680 --> 00:37:09,770
se rendre compte que l'essence de tout
le travail que vous soumettez à ce cours

776
00:37:09,770 --> 00:37:10,954
doit être votre propre.

777
00:37:10,954 --> 00:37:13,870
Mais dans ce contexte, il y a certainement
opportunités et encouragement,

778
00:37:13,870 --> 00:37:17,300
et la valeur pédagogique en se tournant vers
moi others--, TFS, les CA,

779
00:37:17,300 --> 00:37:20,760
les agences de voyages, et d'autres dans la classe,
pour le soutien, que vos amis seuls

780
00:37:20,760 --> 00:37:23,547
et colocataires qui ont étudié
CS et de la programmation avant.

781
00:37:23,547 --> 00:37:25,130
Et donc il y a une allocation pour cela.

782
00:37:25,130 --> 00:37:28,180
Et la règle générale
est this-- quand demander de l'aide,

783
00:37:28,180 --> 00:37:31,470
vous pouvez montrer votre code à d'autres,
mais vous ne pouvez pas voir le leur.

784
00:37:31,470 --> 00:37:34,880
Donc, même si vous êtes à des heures de bureau,
ou dans le hall D, ou ailleurs

785
00:37:34,880 --> 00:37:37,450
travailler sur un certain ensemble de pièces,
travaillant aux côtés d'un ami, qui

786
00:37:37,450 --> 00:37:40,160
est tout à fait bien, à la
fin de la journée de votre travail

787
00:37:40,160 --> 00:37:43,034
devrait finalement appartenir à chaque
vous respectivement, et non

788
00:37:43,034 --> 00:37:45,700
être un effort de collaboration,
sauf pour le projet final où

789
00:37:45,700 --> 00:37:47,410
il est autorisé et encouragé.

790
00:37:47,410 --> 00:37:49,830
>> Sachez que si vous êtes
aux prises avec quelque chose

791
00:37:49,830 --> 00:37:52,520
et votre ami arrive juste
être mieux à cela, alors vous,

792
00:37:52,520 --> 00:37:55,130
ou mieux à ce problème que vous,
ou un peu plus loin que vous,

793
00:37:55,130 --> 00:37:57,330
il est tout à fait raisonnable de tourner
à votre ami et dire, hey,

794
00:37:57,330 --> 00:38:00,480
ne vous dérangerait regarder mon code ici,
me aider repère ce que ma question est?

795
00:38:00,480 --> 00:38:03,760
Et, espérons-le, dans le
intérêt de la valeur pédagogique

796
00:38:03,760 --> 00:38:07,040
cet ami n'a pas seulement
dire, oh, faire cela, mais plutôt,

797
00:38:07,040 --> 00:38:09,917
ce qui vous manque en ligne
6, ou quelque chose comme ça?

798
00:38:09,917 --> 00:38:12,000
Mais la solution ne consiste pas
pour l'ami à côté de vous

799
00:38:12,000 --> 00:38:15,617
à-dire, oh, eh bien, ici, permettez-moi de tirer
cette place, et de montrer ma solution pour vous.

800
00:38:15,617 --> 00:38:16,450
Voilà donc la ligne.

801
00:38:16,450 --> 00:38:18,670
Vous montrez votre code
d'autres, mais vous ne pouvez pas

802
00:38:18,670 --> 00:38:22,350
voir les leurs, sous réserve de l'autre
contraintes dans le programme du cours.

803
00:38:22,350 --> 00:38:24,760
>> Donc, gardez à l'esprit cette
clause dite de regret

804
00:38:24,760 --> 00:38:27,560
dans le programme de cours ainsi,
que si vous commettez un acte qui

805
00:38:27,560 --> 00:38:30,476
est pas raisonnable, mais l'amener à
l'attention des chefs du cours

806
00:38:30,476 --> 00:38:34,240
dans les 72 heures, au cours
peut imposer des sanctions locales

807
00:38:34,240 --> 00:38:37,380
peut comprendre un ou insatisfaisant
note d'échec pour le travail présenté.

808
00:38:37,380 --> 00:38:41,410
Mais le cours ne renverra pas le
la matière pour d'autres mesures disciplinaires,

809
00:38:41,410 --> 00:38:43,010
sauf en cas d'actes répétés.

810
00:38:43,010 --> 00:38:46,632
En d'autres termes, si vous faites un peu
stupide, surtout tard le soir, la décision

811
00:38:46,632 --> 00:38:49,340
que le lendemain ou deux jours
plus tard, vous vous réveillez et réalisez,

812
00:38:49,340 --> 00:38:50,870
à quoi je pensais?

813
00:38:50,870 --> 00:38:53,890
Vous faire CS50 avoir une sortie
pour la fixation de ce problème

814
00:38:53,890 --> 00:38:57,170
et de posséder à la hauteur, de sorte que nous
vous rencontrer à mi-chemin et de faire face

815
00:38:57,170 --> 00:39:01,500
avec elle dans une affaire qui est à la fois
éducatif et précieux pour vous,

816
00:39:01,500 --> 00:39:04,200
mais toujours punitive d'une certaine façon.

817
00:39:04,200 --> 00:39:08,590
Et maintenant, pour prendre le bord, ce.

818
00:39:08,590 --> 00:39:10,570
>> [LECTURE VIDÉO]

819
00:39:10,570 --> 00:39:13,540
>> [MUSIC PLAYING]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [FIN LECTURE]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Malan: Très bien, nous sommes de retour.

823
00:40:00,490 --> 00:40:03,680
Et maintenant, nous regardons l'un des
premier de nos domaines du monde réel

824
00:40:03,680 --> 00:40:08,720
en CS50, l'art de la cryptographie,
l'art d'envoyer et de recevoir

825
00:40:08,720 --> 00:40:11,840
des messages secrets, crypté
messages si vous voulez,

826
00:40:11,840 --> 00:40:17,060
qui ne peut être déchiffré si vous avez
un ingrédient essentiel que l'expéditeur dispose

827
00:40:17,060 --> 00:40:18,030
aussi bien.

828
00:40:18,030 --> 00:40:22,120
Donc, pour motiver ce que nous allons prendre
un coup d'oeil à cette chose ici,

829
00:40:22,120 --> 00:40:26,750
qui est un exemple d'
anneau secret décodeur

830
00:40:26,750 --> 00:40:34,042
peut être utilisé afin de comprendre
quel message secret est en réalité.

831
00:40:34,042 --> 00:40:35,750
En fait, de retour dans la
jour à l'école primaire,

832
00:40:35,750 --> 00:40:38,787
si jamais vous avez envoyé des messages secrets
quelque ami ou un écrasement en classe,

833
00:40:38,787 --> 00:40:40,620
vous pourriez avoir pensé
vous étiez intelligent

834
00:40:40,620 --> 00:40:46,530
par votre morceau de changement de papier,
comme, A à B et B à C, et C à D,

835
00:40:46,530 --> 00:40:47,590
et ainsi de suite.

836
00:40:47,590 --> 00:40:50,300
Mais vous étiez réellement cryptez
vos informations, même

837
00:40:50,300 --> 00:40:53,300
si elle était un peu trivial, n'a pas été
si difficile pour l'enseignant de se rendre compte,

838
00:40:53,300 --> 00:40:55,675
ainsi, si vous venez de changer
B à A et C à B,

839
00:40:55,675 --> 00:40:57,550
vous figurez effectivement sur
ce que le message était,

840
00:40:57,550 --> 00:40:59,700
mais vous étiez à chiffrer l'information.

841
00:40:59,700 --> 00:41:03,420
>> Vous venez de le faites
tout simplement, un peu comme Ralphie ici

842
00:41:03,420 --> 00:41:07,934
dans un film célèbre qui joue
à peu près ad nauseam chaque hiver.

843
00:41:07,934 --> 00:41:08,600
[LECTURE VIDÉO]

844
00:41:08,600 --> 00:41:11,180
-Soyez Connaître à tout ce qui
Ralph Parker est par les présentes

845
00:41:11,180 --> 00:41:14,070
nommé membre de la Petite
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
et a droit à tous les honneurs
et les avantages survenant à celle-ci.

847
00:41:17,700 --> 00:41:24,340
>> Signé: Little Orphan Annie,
contre-signé Pierre André, à l'encre.

848
00:41:24,340 --> 00:41:27,160
Honneurs et avantages,
déjà à l'âge de neuf ans.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [EN CRIANT]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Allons.

853
00:41:34,250 --> 00:41:35,210
Allons-y avec elle.

854
00:41:35,210 --> 00:41:39,530
Je ne pas besoin de tout ce que le jazz
sur les passeurs et les pirates.

855
00:41:39,530 --> 00:41:41,660
>> demain soir -listen pour
l'aventure finale

856
00:41:41,660 --> 00:41:43,880
du bateau pirate noir.

857
00:41:43,880 --> 00:41:46,650
Maintenant, il est temps pour
message secret d'Annie

858
00:41:46,650 --> 00:41:49,840
pour vous membres du Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Rappelez-vous, les enfants, seuls les membres
du Cercle Secret Annie

860
00:41:53,570 --> 00:41:56,140
peut décoder message secret d'Annie.

861
00:41:56,140 --> 00:42:00,340
>> Rappelez-vous, Annie dépend de vous.

862
00:42:00,340 --> 00:42:02,880
Définissez vos broches à B2.

863
00:42:02,880 --> 00:42:05,230
Voici le message.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Je Suis dans ma première réunion secrète.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Était en grande voix ce soir.

868
00:42:15,780 --> 00:42:19,000
Je pourrais dire que ce soir
message était vraiment important.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, qui est un message
de Annie elle-même.

870
00:42:22,694 --> 00:42:23,860
Rappelez-vous, ne dites à personne.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Secondes plus tard, je suis le seul
chambre dans la maison où un garçon de neuf ans

873
00:42:32,930 --> 00:42:37,040
pourrait rester dans l'intimité et le décodage.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Je suis allé à l'autre, E.

876
00:42:42,360 --> 00:42:44,520
>> Le premier mot est d'être.

877
00:42:44,520 --> 00:42:49,032
S, il arrivait plus facile maintenant, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -Oh, Allez, Ralphie, je dois y aller!

879
00:42:51,733 --> 00:42:53,688
>> -Je Vais être juste en bas, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee whiz!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, assurez-vous to-- être sûr de quoi?

883
00:43:04,060 --> 00:43:05,970
Quelle était la petite orpheline
Annie essaie de dire?

884
00:43:05,970 --> 00:43:07,264
Assurez-vous de quoi?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy a eu à
allez, allez-vous s'il vous plaît venir?

886
00:43:09,634 --> 00:43:10,480
>> -Tous droit, Ma!

887
00:43:10,480 --> 00:43:12,880
Je serai à droite!

888
00:43:12,880 --> 00:43:14,550
>> -I Se rapprochait maintenant.

889
00:43:14,550 --> 00:43:16,620
La tension était terrible.

890
00:43:16,620 --> 00:43:17,720
Qu'est-ce que c'était?

891
00:43:17,720 --> 00:43:20,170
Le sort de la planète
peut se bloquer dans la balance.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
gotta Andy aller!

894
00:43:23,170 --> 00:43:26,890
>> -Je Vais être juste dehors, pour pleurer à haute voix!

895
00:43:26,890 --> 00:43:32,680
>> -Près Là, mes doigts ont volé, mon esprit
était un piège en acier, tous les pores vibrait.

896
00:43:32,680 --> 00:43:37,198
Il était presque clair, oui, oui, oui.

897
00:43:37,198 --> 00:43:43,091
>> -Soyez Sûr de boire votre ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovomaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Une publicité minable?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Fils de pute.

903
00:43:54,227 --> 00:43:54,810
[FIN LECTURE]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Malan: OK,
qui était un très long chemin

905
00:43:57,390 --> 00:44:00,660
d'introduire la cryptographie,
et aussi Ovomaltine.

906
00:44:00,660 --> 00:44:04,470
En fait, à partir de cette vieille annonce
ici, pourquoi est ovaltine si bon?

907
00:44:04,470 --> 00:44:09,470
Il est une extraction concentrée de mûre
malt d'orge, le lait pur crémeuse vache,

908
00:44:09,470 --> 00:44:14,360
et spécialement préparé le cacao, ainsi que
avec des phosphatides naturels et les vitamines.

909
00:44:14,360 --> 00:44:18,240
Il est en outre enrichi avec
vitamines supplémentaires B et D, yum.

910
00:44:18,240 --> 00:44:21,600
Et vous pouvez toujours le faire, apparemment,
sur Amazon, comme nous l'avons fait ici.

911
00:44:21,600 --> 00:44:24,810
>> Mais la motivation ici était de
introduire la cryptographie, en particulier

912
00:44:24,810 --> 00:44:28,340
un type de cryptographie connue
comme la cryptographie à clé secrète.

913
00:44:28,340 --> 00:44:34,284
Et comme son nom l'indique, l'ensemble
la sécurité d'un système de chiffrement à clé secrète,

914
00:44:34,284 --> 00:44:36,200
si vous voulez, une méthodologie
pour seulement brouillage

915
00:44:36,200 --> 00:44:40,960
informations entre deux personnes, est que
que l'expéditeur et le destinataire que

916
00:44:40,960 --> 00:44:46,980
connaître un KEY-- secret, une certaine valeur, certains
phrase secrète, un certain nombre secret, que

917
00:44:46,980 --> 00:44:50,660
leur permet de crypter
et déchiffrer les informations.

918
00:44:50,660 --> 00:44:53,470
Et la cryptographie, vraiment,
est tout cela à la semaine 0.

919
00:44:53,470 --> 00:44:56,715
>> Il est un problème là où il y a des entrées,
comme le message réel en anglais

920
00:44:56,715 --> 00:44:59,340
ou quelle que soit la langue que vous
voulez envoyer à quelqu'un en classe,

921
00:44:59,340 --> 00:45:00,580
ou à travers l'Internet.

922
00:45:00,580 --> 00:45:03,840
Il y a une sortie, qui va
être le message brouillé que vous

923
00:45:03,840 --> 00:45:05,250
veulent que le destinataire de recevoir.

924
00:45:05,250 --> 00:45:07,405
Et même si quelqu'un dans la
milieu reçoit aussi,

925
00:45:07,405 --> 00:45:09,780
vous ne voulez pas qu'ils
nécessairement être en mesure de le déchiffrer,

926
00:45:09,780 --> 00:45:12,840
car à l'intérieur de cette
boîte noire, ou d'un algorithme,

927
00:45:12,840 --> 00:45:17,650
est un mécanisme, une certaine étape par étape
instructions, pour prendre cette entrée

928
00:45:17,650 --> 00:45:20,710
et le convertir en le
sortie, dans l'espérons de façon sécurisée.

929
00:45:20,710 --> 00:45:23,640
>> Et, en fait, il existe un certain
vocabulaire dans ce monde comme suit.

930
00:45:23,640 --> 00:45:26,100
Le texte brut est le mot d'un
informaticien serait

931
00:45:26,100 --> 00:45:28,449
utiliser pour décrire l'entrée
message, comme les Anglais

932
00:45:28,449 --> 00:45:31,240
ou quelle que soit la langue que vous avez réellement
vouloir envoyer à un autre humain.

933
00:45:31,240 --> 00:45:35,450
Et puis le cryptogramme est la ruée
le chiffré ou crypté,

934
00:45:35,450 --> 00:45:36,520
la version de celui-ci.

935
00:45:36,520 --> 00:45:38,750
>> Mais il y a un autre ingrédient ici.

936
00:45:38,750 --> 00:45:43,200
Il y a une autre entrée
cryptographie à clé secrète.

937
00:45:43,200 --> 00:45:45,200
Et qui est la clé elle-même,
qui est, en général,

938
00:45:45,200 --> 00:45:48,930
comme nous le verrons, un certain nombre, ou
lettre, ou un mot, quel que soit

939
00:45:48,930 --> 00:45:51,980
l'algorithme, il est en réalité attend.

940
00:45:51,980 --> 00:45:53,870
>> Et comment voulez-vous décrypter l'information?

941
00:45:53,870 --> 00:45:55,110
Comment pouvez-vous déchiffrer?

942
00:45:55,110 --> 00:45:57,950
Eh bien, il vous suffit d'inverser la
sorties et les entrées.

943
00:45:57,950 --> 00:46:00,900
>> En d'autres termes, une fois que quelqu'un
reçoit votre message crypté,

944
00:46:00,900 --> 00:46:03,740
il ou elle a simplement
à savoir que même clé.

945
00:46:03,740 --> 00:46:05,700
Ils ont reçu le cryptogramme.

946
00:46:05,700 --> 00:46:09,530
Et en branchant ces deux
entrées dans le système de chiffrement,

947
00:46:09,530 --> 00:46:14,260
l'algorithme, cette boîte noire, sur
devrait venir le clair original.

948
00:46:14,260 --> 00:46:17,830
Et donc c'est le niveau très élevé
vue de ce que la cryptographie est en fait

949
00:46:17,830 --> 00:46:18,590
tout sur.

950
00:46:18,590 --> 00:46:20,030
>> Donc, nous allons y arriver.

951
00:46:20,030 --> 00:46:22,700
Voyons maintenant sous
le capot de quelque chose

952
00:46:22,700 --> 00:46:26,000
nous avons pris pour acquis
la semaine dernière, et pour cette session

953
00:46:26,000 --> 00:46:27,629
ici-- la chaîne.

954
00:46:27,629 --> 00:46:30,295
Une chaîne à la fin de la journée
est tout simplement une séquence de caractères.

955
00:46:30,295 --> 00:46:33,610
>> Il pourrait être Bonjour tout le monde, ou
bonjour Zamyla, ou autre chose.

956
00:46:33,610 --> 00:46:37,050
Mais qu'est-ce que cela signifie pour
une séquence de caractères?

957
00:46:37,050 --> 00:46:41,520
En effet, la bibliothèque donne CS50
nous un type de données appelé chaîne.

958
00:46:41,520 --> 00:46:45,140
>> Mais il est en fait pas
une telle chose comme une chaîne en C.

959
00:46:45,140 --> 00:46:49,450
Il est vraiment juste une séquence de
caractère, caractère, caractère,

960
00:46:49,450 --> 00:46:52,180
caractère, le dos, à dos, à
retour, vers l'arrière, vers l'arrière à l'intérieur

961
00:46:52,180 --> 00:46:54,650
de la mémoire, ou RAM de votre ordinateur.

962
00:46:54,650 --> 00:46:58,940
Et nous verrons plus loin dans ce que dans le
avenir quand on regarde la mémoire elle-même,

963
00:46:58,940 --> 00:47:02,030
et l'utilisation, et
les menaces qui sont impliqués.

964
00:47:02,030 --> 00:47:04,100
>> Mais considérons la chaîne Zamyla.

965
00:47:04,100 --> 00:47:07,480
Donc, juste le nom de
l'être humain ici Zamyla,

966
00:47:07,480 --> 00:47:12,030
qui est une séquence d'
caractères, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Et maintenant, supposons que le nom de Zamyla
est stockée à l'intérieur d'un ordinateur

968
00:47:16,020 --> 00:47:16,880
programme.

969
00:47:16,880 --> 00:47:20,830
>> Eh bien, il va de soi que nous devrions
être en mesure de regarder ces personnages

970
00:47:20,830 --> 00:47:21,590
individuellement.

971
00:47:21,590 --> 00:47:24,710
Donc, je vais juste tirer un peu
boîte autour du nom de Zamyla ici.

972
00:47:24,710 --> 00:47:31,580
Et il est le cas en C que lorsque vous
avoir une chaîne, comme Zamyla-- et peut-être

973
00:47:31,580 --> 00:47:34,940
cette chaîne est revenu de
une fonction comme chaîne de get,

974
00:47:34,940 --> 00:47:38,540
vous pouvez réellement manipuler
ce caractère par caractère.

975
00:47:38,540 --> 00:47:42,070
>> Maintenant, cela est pertinent pour le
conversation à la main, parce que

976
00:47:42,070 --> 00:47:46,420
en cryptographie si vous voulez changer
A à B et B à C, et C à D,

977
00:47:46,420 --> 00:47:49,650
et ainsi de suite, vous devez être en mesure
de regarder les caractères individuels

978
00:47:49,650 --> 00:47:50,190
dans une chaîne.

979
00:47:50,190 --> 00:47:52,695
Vous devez être en mesure de changer
Z à autre chose, l'A

980
00:47:52,695 --> 00:47:55,280
à autre chose, le M
d'autre, et ainsi de suite quelque chose.

981
00:47:55,280 --> 00:47:58,000
Et donc nous avons besoin d'un moyen,
programme, de sorte

982
00:47:58,000 --> 00:48:03,020
prendre la parole, en C pour pouvoir changer
et de regarder les lettres individuelles.

983
00:48:03,020 --> 00:48:05,690
Et nous pouvons le faire de la manière suivante.

984
00:48:05,690 --> 00:48:08,340
>> Laisse-moi aller dans la tête vers CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Et laissez-moi aller de l'avant
et créer un nouveau fichier

986
00:48:11,130 --> 00:48:16,134
que je vais appeler cette fois string0,
comme notre premier exemple, dot c.

987
00:48:16,134 --> 00:48:18,300
Et je vais aller de l'avant
et le fouetter comme suit.

988
00:48:18,300 --> 00:48:22,870
>> Donc inclure CS50.h, et
puis inclure io.h standard,

989
00:48:22,870 --> 00:48:25,990
que je suis presque toujours aller
être en utilisant dans mes programmes, au moins

990
00:48:25,990 --> 00:48:26,780
initialement.

991
00:48:26,780 --> 00:48:32,180
int void main, puis ici je suis
va faire des chaînes obtient obtenir chaîne.

992
00:48:32,180 --> 00:48:35,260
Et puis je vais
aller de l'avant et le faire.

993
00:48:35,260 --> 00:48:37,460
Je veux aller de l'avant
et, comme une vérification de la santé mentale,

994
00:48:37,460 --> 00:48:43,607
juste dire bonjour, pour cent s,
point-virgule, rend la chaîne 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, qu'est-ce que je fais ici?

996
00:48:44,690 --> 00:48:45,930
Oh, je ne suis pas le brancher.

997
00:48:45,930 --> 00:48:48,120
Donc, leçon apprise, que
n'a pas été intentionnelle.

998
00:48:48,120 --> 00:48:52,480
>> Si une erreur, et plus pour cent
conversions que les arguments de données.

999
00:48:52,480 --> 00:48:54,940
Et c'est là, dans
ligne 7XX OK, donc je dois,

1000
00:48:54,940 --> 00:48:56,690
entre guillemets, qui est
ma chaîne à printf.

1001
00:48:56,690 --> 00:48:58,151
J'ai un signe pour cent.

1002
00:48:58,151 --> 00:48:59,650
Mais il me manque le second argument.

1003
00:48:59,650 --> 00:49:03,190
>> Il me manque la virgule s, qui
Je n'ai dans les exemples précédents.

1004
00:49:03,190 --> 00:49:06,650
Donc, une bonne occasion de fixer
encore une erreur, accidentellement.

1005
00:49:06,650 --> 00:49:09,950
Et maintenant, permettez-moi de courir
string0, tapez Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, bonjour Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Donc, nous avons exécuté ce genre de programme
quelques fois différents maintenant.

1008
00:49:14,144 --> 00:49:16,310
Mais nous allons faire quelque chose d'un
peu différent cette fois.

1009
00:49:16,310 --> 00:49:19,450
Au lieu de simplement l'impression Zamyla de
nom complet avec printf,

1010
00:49:19,450 --> 00:49:21,350
faisons-le caractère par caractère.

1011
00:49:21,350 --> 00:49:22,700
>> Je vais utiliser une boucle for.

1012
00:49:22,700 --> 00:49:26,160
Et je vais me donner
une variable de comptage, appelé i.

1013
00:49:26,160 --> 00:49:33,530
Et je vais continuer à itérer, de sorte
Tant que i est inférieur à la longueur de l'art.

1014
00:49:33,530 --> 00:49:35,930
>> Il se trouve, nous ne l'avons pas
faire la dernière fois,

1015
00:49:35,930 --> 00:49:39,100
que c est livré avec un
fonction appelée Stirling.

1016
00:49:39,100 --> 00:49:42,690
Retour dans la journée, et en général
encore la mise en œuvre des fonctions,

1017
00:49:42,690 --> 00:49:45,405
les humains choisissent souvent très
noms succincts ce genre de son

1018
00:49:45,405 --> 00:49:48,280
comme ce que vous voulez, même si elle est
manque quelques voyelles ou des lettres.

1019
00:49:48,280 --> 00:49:50,660
Donc, Stirling est le
le nom d'une fonction qui

1020
00:49:50,660 --> 00:49:53,880
prend un argument entre
entre parenthèses qui doit être une chaîne.

1021
00:49:53,880 --> 00:49:56,910
Et elle retourne juste un nombre entier,
la longueur de cette chaîne.

1022
00:49:56,910 --> 00:50:00,580
>> Donc, cette boucle sur la ligne 7 va
pour commencer à compter à i est égal à 0.

1023
00:50:00,580 --> 00:50:02,530
Il va incrémenter
i à chaque itération

1024
00:50:02,530 --> 00:50:04,350
par 1, comme nous l'avons fait à quelques reprises.

1025
00:50:04,350 --> 00:50:06,780
Mais il va seulement faire
ce jusqu'au point

1026
00:50:06,780 --> 00:50:09,660
lorsque i est la longueur
de la chaîne elle-même.

1027
00:50:09,660 --> 00:50:14,520
>> Donc, cela est une manière de, en fin de compte,
itérer sur les personnages

1028
00:50:14,520 --> 00:50:17,430
dans la chaîne suivante tel quel.

1029
00:50:17,430 --> 00:50:20,670
Je vais imprimer pas
chaîne entière, mais pour cent c,

1030
00:50:20,670 --> 00:50:22,860
un seul caractère
suivie d'une nouvelle ligne.

1031
00:50:22,860 --> 00:50:24,880
Et puis je vais
aller de l'avant, et je dois

1032
00:50:24,880 --> 00:50:29,080
dire que je veux imprimer
ième caractère de l'art.

1033
00:50:29,080 --> 00:50:33,450
>> Donc, si i est la variable qui indique
l'indice de la chaîne,

1034
00:50:33,450 --> 00:50:37,230
vous êtes en elle, je dois être en mesure de
dire, donnez-moi le caractère i de s.

1035
00:50:37,230 --> 00:50:40,390
Et c a une façon de faire
ce avec des crochets.

1036
00:50:40,390 --> 00:50:43,679
Vous dites tout simplement le nom de la
chaîne, qui dans ce cas est s.

1037
00:50:43,679 --> 00:50:46,970
Ensuite, vous utilisez des crochets, qui sont
habituellement juste au-dessus de votre Retour ou Entrée

1038
00:50:46,970 --> 00:50:48,110
des touches du clavier.

1039
00:50:48,110 --> 00:50:52,410
Et puis vous mettez l'index de la
caractère que vous souhaitez imprimer.

1040
00:50:52,410 --> 00:50:55,960
Donc, l'indice va être un
number-- 0 ou 1, ou 2, ou 3, ou un point,

1041
00:50:55,960 --> 00:50:57,590
dot, dot, un autre numéro.

1042
00:50:57,590 --> 00:51:00,920
>> Et nous veillons à ce que ça va
être le bon numéro, parce que je

1043
00:51:00,920 --> 00:51:02,360
commencer à compter à 0.

1044
00:51:02,360 --> 00:51:07,020
Et par défaut, le premier caractère
dans une chaîne est par convention 0.

1045
00:51:07,020 --> 00:51:09,230
Et le deuxième caractère est le support 1.

1046
00:51:09,230 --> 00:51:11,120
Et le troisième caractère est le support 2.

1047
00:51:11,120 --> 00:51:13,630
Et vous ne voulez pas aller trop
loin, mais nous ne serons pas parce que nous sommes

1048
00:51:13,630 --> 00:51:17,780
va augmenter seulement i jusqu'à ce qu'il
est égale à la longueur de la chaîne.

1049
00:51:17,780 --> 00:51:20,210
Et à quel point,
cette boucle va arrêter.

1050
00:51:20,210 --> 00:51:25,550
>> Alors laissez-moi aller de l'avant et de sauver cette
programme, et lancez faire chaîne 0.

1051
00:51:25,550 --> 00:51:28,400
Mais je merdé.

1052
00:51:28,400 --> 00:51:35,390
déclarant Implicitement fonction de bibliothèque
Stirling de type tel et such-- maintenant,

1053
00:51:35,390 --> 00:51:36,430
cela semble familier.

1054
00:51:36,430 --> 00:51:37,440
Mais ça ne printf.

1055
00:51:37,440 --> 00:51:38,540
Et ça ne se string.

1056
00:51:38,540 --> 00:51:40,480
>> Je ne visse dans
De même moment.

1057
00:51:40,480 --> 00:51:45,100
Mais remarquez ici un peu plus bas
en outre, inclure l'en-tête string.h,

1058
00:51:45,100 --> 00:51:47,210
prévoir explicitement la
déclaration de Stirling.

1059
00:51:47,210 --> 00:51:48,820
Donc, il est en fait un indice là-dedans.

1060
00:51:48,820 --> 00:51:51,670
>> Et en effet, il se trouve
il y a un autre fichier d'en-tête

1061
00:51:51,670 --> 00:51:53,970
que nous avons pas l'habitude
en classe encore, mais il est

1062
00:51:53,970 --> 00:51:56,480
parmi celles disponibles
à vous, appelé string.h.

1063
00:51:56,480 --> 00:52:00,930
Et dans ce fichier, string.h
Stirling est déclarée.

1064
00:52:00,930 --> 00:52:05,220
Alors laissez-moi aller de l'avant et
enregistrer ce, faire chaîne

1065
00:52:05,220 --> 00:52:08,040
0-- nice, aucun message d'erreur cette fois.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla et
Je suis sur le appuyez sur Entrée,

1067
00:52:12,290 --> 00:52:16,710
à quel point getString va
pour retourner la chaîne, le mettre dans l'art.

1068
00:52:16,710 --> 00:52:21,890
Alors que pour la boucle va itérer
sur les personnages de S un à la fois,

1069
00:52:21,890 --> 00:52:28,420
et les imprimer un par ligne, parce que
J'avais que backslash n à la fin.

1070
00:52:28,420 --> 00:52:34,530
Donc, je ne pouvais omettre que backslash
n, et puis juste imprimer Zamyla tous

1071
00:52:34,530 --> 00:52:37,460
dans la même ligne,
réimplémentant efficacement

1072
00:52:37,460 --> 00:52:38,999
printf, qui ne sont pas d'une grande utilité.

1073
00:52:38,999 --> 00:52:40,540
Mais dans ce cas, je ne l'ai pas fait cela.

1074
00:52:40,540 --> 00:52:43,610
Je l'ai effectivement imprimé un
caractère à la fois, une par ligne,

1075
00:52:43,610 --> 00:52:45,400
de sorte que nous voyons effectivement l'effet.

1076
00:52:45,400 --> 00:52:46,900
>> Mais je tiens à souligner une chose ici.

1077
00:52:46,900 --> 00:52:48,930
Et nous reviendrons
ceci en une semaine futur.

1078
00:52:48,930 --> 00:52:52,650
Il se trouve que ce
le code est potentiellement buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Il se trouve que la chaîne get
et quelques autres fonctions dans la vie

1080
00:52:56,560 --> 00:53:00,280
ne sont pas nécessairement toujours
retournez ce que vous attendez.

1081
00:53:00,280 --> 00:53:03,010
Nous savons de dernière classe
temps dans ce qui se

1082
00:53:03,010 --> 00:53:04,960
chaîne est censée renvoyer une chaîne.

1083
00:53:04,960 --> 00:53:09,900
Mais si les types de tels utilisateurs
un mot long ou du paragraphe, ou un essai

1084
00:53:09,900 --> 00:53:13,010
qu'il n'y a tout simplement pas assez
La mémoire dans l'ordinateur pour l'adapter.

1085
00:53:13,010 --> 00:53:15,410
>> Comme, si quelque chose va
mal sous le capot?

1086
00:53:15,410 --> 00:53:18,400
Il pourrait ne pas arriver souvent,
mais il pourrait se produire une fois

1087
00:53:18,400 --> 00:53:21,520
dans un certain temps, très rarement.

1088
00:53:21,520 --> 00:53:25,460
Et il se trouve que la chaîne get
et fonctionne comme il ne le font pas nécessairement

1089
00:53:25,460 --> 00:53:26,380
revenir toujours des chaînes.

1090
00:53:26,380 --> 00:53:30,680
Ils pourraient retourner une valeur d'erreur,
une valeur sentinelle pour ainsi dire,

1091
00:53:30,680 --> 00:53:32,612
cela indique que
quelque chose a mal tourné.

1092
00:53:32,612 --> 00:53:35,320
Et vous ne sauriez cela de
ayant appris en classe maintenant,

1093
00:53:35,320 --> 00:53:37,700
ou avoir lu plus de documentation.

1094
00:53:37,700 --> 00:53:43,120
Il se trouve que la chaîne get
peut retourner une valeur appelée null.

1095
00:53:43,120 --> 00:53:46,220
Null est une valeur spéciale que nous allons
revenir dans une semaine future.

1096
00:53:46,220 --> 00:53:50,420
Mais pour l'instant, sachez simplement que si je veux
pour être vraiment bon pour faire avancer

1097
00:53:50,420 --> 00:53:52,650
en utilisant la chaîne de get, je
ne devrait pas simplement l'appeler,

1098
00:53:52,650 --> 00:53:56,870
et utiliser aveuglément sa valeur de retour,
en espérant que c'est une chaîne.

1099
00:53:56,870 --> 00:53:59,420
>> Je dois d'abord dire,
hé, attendez une minute, seulement

1100
00:53:59,420 --> 00:54:03,380
procéder si s ne est pas égal
null, null où, encore une fois,

1101
00:54:03,380 --> 00:54:04,660
est juste une valeur spéciale.

1102
00:54:04,660 --> 00:54:07,770
Et il est la seule valeur spéciale vous
besoin de se soucier de la chaîne get.

1103
00:54:07,770 --> 00:54:10,900
Obtenez chaîne est soit va
pour retourner une chaîne ou nulle.

1104
00:54:10,900 --> 00:54:17,219
>> Et ce point d'exclamation signe égal
vous savez peut-être de peut-être la classe de mathématiques

1105
00:54:17,219 --> 00:54:20,510
que vous pouvez dessiner un signe d'égalité avec
une ligne à travers elle pour indiquer pas égal.

1106
00:54:20,510 --> 00:54:23,135
C'est généralement pas un caractère
vous pouvez taper sur votre clavier.

1107
00:54:23,135 --> 00:54:26,480
Et dans la plupart des langages de programmation,
quand vous voulez dire pas égal,

1108
00:54:26,480 --> 00:54:29,160
vous utilisez un point d'exclamation,
autrement connu comme bang.

1109
00:54:29,160 --> 00:54:33,180
Donc, vous dites-bang est égal, ce qui
ne signifie pas égale, logiquement.

1110
00:54:33,180 --> 00:54:38,060
Il est juste comme il n'y a pas une plus grande
que, ou inférieur ou égal, ou

1111
00:54:38,060 --> 00:54:41,270
ou égale à la clé de votre clavier
qui fait tout en un seul symbole.

1112
00:54:41,270 --> 00:54:44,020
Voilà pourquoi, dans les exemples passés,
vous avez fait une parenthèse ouverte, puis

1113
00:54:44,020 --> 00:54:48,670
un signe égal, afin de faire
supérieur ou, disons, moins.

1114
00:54:48,670 --> 00:54:49,910
>> Alors, quel est l'emporter ici?

1115
00:54:49,910 --> 00:54:53,880
Ceci est simplement un moyen maintenant de
l'introduction de cette syntaxe, cette fonctionnalité,

1116
00:54:53,880 --> 00:54:57,390
itérer individuelle
caractères dans une chaîne.

1117
00:54:57,390 --> 00:55:00,260
Et tout comme les carrés
supports vous permettent d'obtenir à eux,

1118
00:55:00,260 --> 00:55:03,790
considérer ces crochets comme
sorte de faire allusion à ce sous-jacent

1119
00:55:03,790 --> 00:55:06,040
la conception, dans lequel chaque
caractère à l'intérieur d'une chaîne

1120
00:55:06,040 --> 00:55:10,180
est une sorte de boîte quelque part au-dessous
le capot dans la mémoire de votre ordinateur.

1121
00:55:10,180 --> 00:55:12,340
>> Mais nous allons faire une variante de ce.

1122
00:55:12,340 --> 00:55:14,880
Il se trouve que ce
programme est correct.

1123
00:55:14,880 --> 00:55:18,810
Donc, selon les axes de CS50 pour évaluer
code, cela est correct maintenant.

1124
00:55:18,810 --> 00:55:22,959
Surtout maintenant que je vérifie pour
null, ce programme ne doit jamais tomber en panne.

1125
00:55:22,959 --> 00:55:24,500
Et je sais juste que de l'expérience.

1126
00:55:24,500 --> 00:55:28,040
Mais il n'y a rien d'autre que
nous pouvons vraiment aller mal ici.

1127
00:55:28,040 --> 00:55:31,860
Mais il est pas très bien conçu,
parce que nous allons revenir à l'essentiel.

1128
00:55:31,860 --> 00:55:34,450
>> Tout d'abord, principles--
qu'est-ce une boucle do?

1129
00:55:34,450 --> 00:55:36,290
Une boucle for fait trois choses.

1130
00:55:36,290 --> 00:55:39,340
Il initialise certaines
valeur, si vous lui demandez.

1131
00:55:39,340 --> 00:55:41,770
Il vérifie une condition.

1132
00:55:41,770 --> 00:55:45,380
Et puis après chaque
itération, après chaque cycle,

1133
00:55:45,380 --> 00:55:49,330
il incrémente un certain
la valeur ou les valeurs, ici.

1134
00:55:49,330 --> 00:55:50,600
>> Alors qu'est-ce que cela signifie?

1135
00:55:50,600 --> 00:55:52,940
On initialise i à 0.

1136
00:55:52,940 --> 00:55:58,610
Nous vérifions et assurez-vous i est inférieur à
la longueur de l'art, ce qui est Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
donc ce qui est inférieur à 6.

1138
00:55:59,900 --> 00:56:02,590
En effet, comme 0 à moins de 6.

1139
00:56:02,590 --> 00:56:05,580
>> Nous imprimons sur Z du nom de Zamyla.

1140
00:56:05,580 --> 00:56:08,080
Ensuite, on incrémente i 0-1.

1141
00:56:08,080 --> 00:56:11,290
Nous avons ensuite vérifier, est 1 moins
que la longueur de l'art?

1142
00:56:11,290 --> 00:56:13,270
La longueur de s est 6.

1143
00:56:13,270 --> 00:56:13,950
Oui, ça l'est.

1144
00:56:13,950 --> 00:56:16,880
>> Donc, nous imprimons un au nom de Zamyla, ZA.

1145
00:56:16,880 --> 00:56:20,090
Nous i incrémente de 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Nous avons ensuite vérifier, est inférieure à 2
la longueur du nom de Zamyla.

1147
00:56:23,720 --> 00:56:25,380
6- la figure 2 est donc inférieur à 6.

1148
00:56:25,380 --> 00:56:30,460
Oui, nous allons imprimer maintenant M
le nom de Zamyla, le troisième caractère.

1149
00:56:30,460 --> 00:56:34,110
>> La clé ici est que sur chaque
itération de l'histoire, je contrôle,

1150
00:56:34,110 --> 00:56:37,810
i est inférieure à la longueur de Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Mais le hic est que
Stirling est pas une propriété.

1152
00:56:40,350 --> 00:56:43,100
Ceux d'entre vous qui ont programmé
avant en Java ou d'autres langues

1153
00:56:43,100 --> 00:56:46,310
pourrait connaître la longueur d'une chaîne est
une propriété, quelques-unes en lecture seule valeur.

1154
00:56:46,310 --> 00:56:50,220
>> En C, dans ce cas, si cela est
une fonction qui est littéralement

1155
00:56:50,220 --> 00:56:53,520
compter le nombre d'
Zamyla caractères à chaque fois

1156
00:56:53,520 --> 00:56:54,740
nous appelons cette fonction.

1157
00:56:54,740 --> 00:56:58,500
Chaque fois que vous demandez l'ordinateur à utiliser
Stirling, il prend un coup d'oeil à Zamyla,

1158
00:56:58,500 --> 00:57:01,960
et dire Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Et il renvoie 6.

1160
00:57:02,962 --> 00:57:04,920
La prochaine fois que vous appelez
à l'intérieur de cette boucle,

1161
00:57:04,920 --> 00:57:08,610
il va regarder Zamyla
à nouveau, dire Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Et ça va revenir 6.

1163
00:57:10,320 --> 00:57:12,980
Donc, ce qui est stupide sur cette conception?

1164
00:57:12,980 --> 00:57:17,700
>> Pourquoi mon code pas un 5 sur 5
pour la conception en ce moment, pour ainsi dire?

1165
00:57:17,700 --> 00:57:20,600
Eh bien, je pose une
question inutilement.

1166
00:57:20,600 --> 00:57:23,030
Je fais plus de travail que je dois.

1167
00:57:23,030 --> 00:57:25,370
>> Ainsi, même si la
réponse est correcte, je suis

1168
00:57:25,370 --> 00:57:29,560
demander à l'ordinateur, ce qui est
la longueur de Zamyla à nouveau,

1169
00:57:29,560 --> 00:57:31,380
et encore, et encore, et encore?

1170
00:57:31,380 --> 00:57:33,980
Et cette réponse est
ne changera jamais.

1171
00:57:33,980 --> 00:57:35,900
Il va toujours être 6.

1172
00:57:35,900 --> 00:57:39,730
>> Donc, une meilleure solution que ce
serait cette version suivante.

1173
00:57:39,730 --> 00:57:43,390
Laissez-moi aller de l'avant et de le mettre dans un
fichier séparé appelé string1.c,

1174
00:57:43,390 --> 00:57:44,990
juste pour les maintenir séparés.

1175
00:57:44,990 --> 00:57:47,260
Et il se trouve dans un pour
boucle, vous pouvez réellement

1176
00:57:47,260 --> 00:57:50,210
déclarer plusieurs variables à la fois.

1177
00:57:50,210 --> 00:57:53,460
>> Donc, je vais continuer à i et le mettre à 0.

1178
00:57:53,460 --> 00:57:56,190
Mais je vais aussi
ajouter une virgule, et dire,

1179
00:57:56,190 --> 00:58:01,050
me donner une variable appelée n, dont
la valeur est égale à la longueur de la chaîne de l'art.

1180
00:58:01,050 --> 00:58:09,410
Et maintenant, s'il vous plaît faire ma condition
aussi longtemps que i est inférieur à n.

1181
00:58:09,410 --> 00:58:14,140
>> Donc, de cette manière, la logique est
identique à la fin de la journée.

1182
00:58:14,140 --> 00:58:18,280
Mais je me souviens de la
valeur 6, dans ce cas.

1183
00:58:18,280 --> 00:58:19,780
Quelle est la longueur du nom de Zamyla?

1184
00:58:19,780 --> 00:58:20,860
Et je le mettre au n.

1185
00:58:20,860 --> 00:58:23,050
>> Et je suis toujours vérifier
la condition à chaque fois.

1186
00:58:23,050 --> 00:58:24,300
Est 0 à moins de 6?

1187
00:58:24,300 --> 00:58:25,600
Est-1 inférieur à 6?

1188
00:58:25,600 --> 00:58:28,600
Est 2 à moins de 6, et ainsi de suite?

1189
00:58:28,600 --> 00:58:31,914
>> Mais je ne demande pas l'ordinateur
encore, et encore, ce qui est

1190
00:58:31,914 --> 00:58:33,080
la longueur du nom de Zamyla?

1191
00:58:33,080 --> 00:58:34,320
Quelle est la longueur du nom de Zamyla?

1192
00:58:34,320 --> 00:58:35,986
Quelle est la longueur du nom de cette Zamyla?

1193
00:58:35,986 --> 00:58:40,440
Je littéralement rappeler que la première et
seulement répondre à cette deuxième variable n.

1194
00:58:40,440 --> 00:58:45,280
Donc, ce serait maintenant non seulement
correct, mais aussi bien conçu.

1195
00:58:45,280 --> 00:58:46,670
>> Maintenant, qu'en est-style?

1196
00:58:46,670 --> 00:58:48,866
J'ai appelé mes variables
assez bien, je dirais.

1197
00:58:48,866 --> 00:58:50,240
Ils sont super succinct en ce moment.

1198
00:58:50,240 --> 00:58:52,090
Et c'est tout à fait bien.

1199
00:58:52,090 --> 00:58:55,120
>> Si vous avez un seul
chaîne dans un programme,

1200
00:58:55,120 --> 00:58:56,860
vous pourriez aussi bien l'appeler s pour une chaîne.

1201
00:58:56,860 --> 00:58:59,370
Si vous avez seulement une variable
pour compter dans un programme,

1202
00:58:59,370 --> 00:59:00,710
vous pourriez aussi bien l'appeler i.

1203
00:59:00,710 --> 00:59:03,500
Si vous avez une longueur, n
est super commun aussi bien.

1204
00:59:03,500 --> 00:59:05,800
Mais je ne l'ai pas commenté aucun de mon code.

1205
00:59:05,800 --> 00:59:09,200
>> Je ne l'ai pas informé le reader--
que ce soit mon TF, ou TA,

1206
00:59:09,200 --> 00:59:12,460
ou colleague-- tout ce qui est censé
être en cours dans ce programme.

1207
00:59:12,460 --> 00:59:15,760
Et pour obtenir un bon style,
ce que je voudrais faire

1208
00:59:15,760 --> 00:59:24,580
est this-- quelque chose
comme demander à l'utilisateur pour l'entrée.

1209
00:59:24,580 --> 00:59:26,670
Et je pourrais réécrire
ce numéro une des façons.

1210
00:59:26,670 --> 00:59:35,630
>> Assurez-vous que s-- assurez-get
chaîne retournée une chaîne.

1211
00:59:35,630 --> 00:59:40,280
Et puis dans ici-- et cela est peut-être
le plus important iterate comment--

1212
00:59:40,280 --> 00:59:44,450
sur les caractères dans l une à la fois.

1213
00:59:44,450 --> 00:59:47,060
Et je pourrais utiliser tout
choix de la langue anglaise

1214
00:59:47,060 --> 00:59:49,650
ici pour décrire chaque
de ces morceaux de code.

1215
00:59:49,650 --> 00:59:52,740
>> Remarquez que je ne l'ai pas mis un
commenter chaque ligne de code,

1216
00:59:52,740 --> 00:59:55,690
vraiment juste sur le intéressant
ceux, celles qui

1217
00:59:55,690 --> 00:59:59,460
avoir un sens que je pourrais
vouloir faire super clair à quelqu'un

1218
00:59:59,460 --> 01:00:00,460
lire mon code.

1219
01:00:00,460 --> 01:00:02,920
Et pourquoi appelez-vous obtenir
chaîne demander à l'utilisateur pour l'entrée?

1220
01:00:02,920 --> 01:00:05,450
Même que l'on est pas nécessairement
tout ce descriptif.

1221
01:00:05,450 --> 01:00:09,340
Mais il aide à raconter une histoire, parce que le
deuxième ligne dans l'histoire est, assurez-vous

1222
01:00:09,340 --> 01:00:10,740
obtenir chaîne retournée une chaîne.

1223
01:00:10,740 --> 01:00:14,260
>> Et la troisième ligne de l'histoire est,
itérer sur les personnages dans une s

1224
01:00:14,260 --> 01:00:15,380
à la fois.

1225
01:00:15,380 --> 01:00:17,920
Et maintenant, pour faire bonne mesure,
Je vais aller de l'avant et d'ajouter

1226
01:00:17,920 --> 01:00:24,560
un autre commentaire qui vient
dit print caractère i-ième s.

1227
01:00:24,560 --> 01:00:26,520
Maintenant, qu'est-ce que je fait
à la fin de la journée?

1228
01:00:26,520 --> 01:00:29,190
>> J'ai ajouté un peu d'anglais
mots sous la forme de commentaires.

1229
01:00:29,190 --> 01:00:32,700
Le symbole signifie slash slash, hey,
ordinateur est pour l'homme,

1230
01:00:32,700 --> 01:00:33,820
pas pour vous, l'ordinateur.

1231
01:00:33,820 --> 01:00:35,119
Donc, ils sont ignorés logiquement.

1232
01:00:35,119 --> 01:00:35,910
Ils sont juste là.

1233
01:00:35,910 --> 01:00:39,830
>> Et, en effet, CS50 IDE montre que les
gris, comme étant utile, mais pas la clé

1234
01:00:39,830 --> 01:00:41,000
au programme.

1235
01:00:41,000 --> 01:00:42,570
Remarquez ce que vous pouvez faire maintenant.

1236
01:00:42,570 --> 01:00:44,950
Que vous connaissez C
programmation ou non, vous

1237
01:00:44,950 --> 01:00:47,722
peut simplement prendre du recul à ce
programme, et écumer les commentaires.

1238
01:00:47,722 --> 01:00:50,180
Demander à l'utilisateur pour l'entrée, assurez-vous
obtenir chaîne retournée une chaîne,

1239
01:00:50,180 --> 01:00:53,009
itérer sur les caractères dans s
une à la fois, imprimer le caractère

1240
01:00:53,009 --> 01:00:55,550
i-ième caractère dans s-- vous ne
même avoir à regarder le code

1241
01:00:55,550 --> 01:00:57,270
de comprendre ce que ce programme fait.

1242
01:00:57,270 --> 01:01:00,280
Et, mieux encore, si vous vous regardez
à ce programme en une semaine ou deux,

1243
01:01:00,280 --> 01:01:02,280
ou un mois, ou un an,
vous n'avez pas trop

1244
01:01:02,280 --> 01:01:04,420
à regarder le code,
essayant de se rappeler,

1245
01:01:04,420 --> 01:01:06,630
qu'est-ce que je cherche à faire avec ce code?

1246
01:01:06,630 --> 01:01:07,770
>> Vous avez vous-même dit.

1247
01:01:07,770 --> 01:01:11,660
Vous l'avez décrit pour vous-même,
ou d'un collègue, ou TA, ou TF.

1248
01:01:11,660 --> 01:01:14,860
Et donc ce serait maintenant
correct, et une bonne conception,

1249
01:01:14,860 --> 01:01:18,210
et, finalement, un bon style aussi bien.

1250
01:01:18,210 --> 01:01:19,990
Donc, ne gardez cela à l'esprit.

1251
01:01:19,990 --> 01:01:22,200
>> Donc, il y a un autre
chose que je vais faire ici

1252
01:01:22,200 --> 01:01:28,240
qui peut maintenant révéler exactement ce qui est
passe sous le capot.

1253
01:01:28,240 --> 01:01:30,390
Donc, il y a cette fonctionnalité
en C, et d'autres langues,

1254
01:01:30,390 --> 01:01:33,010
appelé transtypage
que soit implicitement

1255
01:01:33,010 --> 01:01:37,250
ou permet explicitement de convertir
d'un type de données à un autre.

1256
01:01:37,250 --> 01:01:39,800
Nous avons eu affaire afin
loin aujourd'hui avec des cordes.

1257
01:01:39,800 --> 01:01:41,250
>> Et les chaînes sont des caractères.

1258
01:01:41,250 --> 01:01:44,910
Mais rappeler de la semaine
0, ce sont des personnages?

1259
01:01:44,910 --> 01:01:49,334
Les caractères sont juste une abstraction
sur le dessus de nombres décimaux numbers--,

1260
01:01:49,334 --> 01:01:52,500
et les nombres décimaux sont vraiment juste une
abstraction au-dessus des nombres binaires,

1261
01:01:52,500 --> 01:01:53,720
comme nous l'avons défini.

1262
01:01:53,720 --> 01:01:55,540
>> Donc caractères sont des nombres.

1263
01:01:55,540 --> 01:01:58,410
Et les numéros sont des personnages,
juste en fonction du contexte.

1264
01:01:58,410 --> 01:02:01,250
Et il se trouve que l'intérieur
d'un programme informatique,

1265
01:02:01,250 --> 01:02:06,830
pouvez-vous préciser comment vous voulez regarder
à des bits à l'intérieur de ce programme?

1266
01:02:06,830 --> 01:02:10,400
>> Rappel de la semaine 0 que nous avions
Ascii, qui est juste ce code

1267
01:02:10,400 --> 01:02:11,620
cartographie des lettres aux chiffres.

1268
01:02:11,620 --> 01:02:13,660
Et nous avons dit, le capital A est 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B est 66, et ainsi de suite.

1270
01:02:15,860 --> 01:02:20,500
>> Et remarquez, nous avons essentiellement sur les caractères
la rangée supérieure ici, comme C les appellerait,

1271
01:02:20,500 --> 01:02:23,400
caractères, puis
ints sur la deuxième rangée.

1272
01:02:23,400 --> 01:02:28,180
Et il se trouve que vous pouvez convertir
de façon transparente entre les deux, en général.

1273
01:02:28,180 --> 01:02:30,042
Et si nous voulons faire
ce dessein, nous

1274
01:02:30,042 --> 01:02:31,750
pourrait vouloir attaquer
quelque chose comme ça.

1275
01:02:31,750 --> 01:02:33,590
>> Nous pourrions vouloir convertir
majuscules pour abaisser

1276
01:02:33,590 --> 01:02:35,330
cas, ou en minuscules en majuscules.

1277
01:02:35,330 --> 01:02:38,000
Et il se trouve qu'il y a
en fait un modèle ici

1278
01:02:38,000 --> 01:02:39,900
nous pouvons embrasser dans un instant.

1279
01:02:39,900 --> 01:02:44,120
Mais regardons d'abord à un
exemple de le faire explicitement.

1280
01:02:44,120 --> 01:02:46,340
>> Je vais retourner dans CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Je vais créer un
fichier appelé Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Et je vais aller de l'avant et d'ajouter mon
io.h standard en haut, void main int

1283
01:02:55,960 --> 01:02:57,370
au sommet de ma fonction.

1284
01:02:57,370 --> 01:03:02,700
Et puis, je vais juste faire la
following-- une boucle de i est égal,

1285
01:03:02,700 --> 01:03:04,610
disons, 65 ans.

1286
01:03:04,610 --> 01:03:10,460
>> Et puis i va être inférieure à
65, plus 26 lettres dans l'alphabet.

1287
01:03:10,460 --> 01:03:12,640
Donc, je vais laisser l'ordinateur
faire le calcul pour moi là-bas.

1288
01:03:12,640 --> 01:03:15,100
Et puis à l'intérieur de cette boucle,
que vais-je imprimer?

1289
01:03:15,100 --> 01:03:19,230
>> % C est% i Backslash n.

1290
01:03:19,230 --> 01:03:21,290
Et maintenant, je veux brancher deux valeurs.

1291
01:03:21,290 --> 01:03:24,530
J'ai temporairement mis question
marque là pour inviter la question.

1292
01:03:24,530 --> 01:03:29,940
>> Je veux itérer à partir de 65 en avant
pour 26 lettres de l'alphabet,

1293
01:03:29,940 --> 01:03:35,190
l'impression sur chaque itération
équivalent intégrante de caractère.

1294
01:03:35,190 --> 01:03:38,299
En d'autres termes, je veux
itérer l'impression de plus de 26 numéros

1295
01:03:38,299 --> 01:03:41,590
ce que le personnage de Ascii est, la lettre,
et ce que le nombre correspondant est--

1296
01:03:41,590 --> 01:03:44,650
vraiment juste recréer
le tableau de cette diapositive.

1297
01:03:44,650 --> 01:03:47,010
Alors, que si ces points d'interrogation être?

1298
01:03:47,010 --> 01:03:51,760
>> Eh bien, il se trouve que la seconde
on devrait juste être la variable i.

1299
01:03:51,760 --> 01:03:53,860
Je veux voir que comme un nombre.

1300
01:03:53,860 --> 01:03:58,920
Et l'argument milieu
ici, je peux dire à l'ordinateur

1301
01:03:58,920 --> 01:04:03,470
pour traiter cet entier
i en tant que caractère, de sorte que

1302
01:04:03,470 --> 01:04:05,880
de substituer ici pour pour cent C.

1303
01:04:05,880 --> 01:04:07,990
>> En d'autres termes, si je le
programmeur humain, savoir

1304
01:04:07,990 --> 01:04:09,865
ce ne sont que des numéros
à la fin de la journée.

1305
01:04:09,865 --> 01:04:12,500
Et je sais que 65 devrait
la carte à un personnage.

1306
01:04:12,500 --> 01:04:15,310
Avec ce casting explicite,
avec une parenthèse,

1307
01:04:15,310 --> 01:04:18,840
le nom du type de données que vous voulez
convertir, et une parenthèse fermée,

1308
01:04:18,840 --> 01:04:21,200
vous pouvez dire au
ordinateur, hé, ordinateur,

1309
01:04:21,200 --> 01:04:24,130
convertir cet entier en char.

1310
01:04:24,130 --> 01:04:26,250
>> Alors, quand je lance ce
programme après la compilation,

1311
01:04:26,250 --> 01:04:29,740
nous allons voir ce que je fais get-- Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Darn il, qu'est-ce que je fais mal ici?

1313
01:04:33,020 --> 01:04:35,884
Utilisez de l'identificateur non déclaré,
tout droit, pas intentionnel,

1314
01:04:35,884 --> 01:04:37,800
mais nous allons voir si nous ne pouvons pas
raison par ce biais.

1315
01:04:37,800 --> 01:04:41,220
>> Donc, la ligne five-- donc je ne comprends pas
très loin avant vissage.

1316
01:04:41,220 --> 01:04:42,140
C'est bon.

1317
01:04:42,140 --> 01:04:46,560
Donc, la ligne 5 pour i est égal à 65-- je vois.

1318
01:04:46,560 --> 01:04:50,130
Alors rappelez-vous que, dans C, contrairement à certains
langues si vous avez la programmation avant

1319
01:04:50,130 --> 01:04:52,190
expérience, vous avez
dire l'ordinateur,

1320
01:04:52,190 --> 01:04:55,040
contrairement aux rayures, ce qui
type de variable il est.

1321
01:04:55,040 --> 01:04:56,860
>> Et j'oublié une phrase clé ici.

1322
01:04:56,860 --> 01:04:59,200
En ligne de cinq, j'ai commencé à utiliser i.

1323
01:04:59,200 --> 01:05:01,560
Mais je ne l'ai pas dit C
ce type de données, il est.

1324
01:05:01,560 --> 01:05:04,570
Donc, je vais aller ici et
dire, ah, faire un entier.

1325
01:05:04,570 --> 01:05:07,050
>> Maintenant, je vais aller de l'avant et de recompiler.

1326
01:05:07,050 --> 01:05:08,080
Ce fixé cela.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Entrez, que ce genre de frais.

1328
01:05:12,660 --> 01:05:15,360
Non seulement il est super rapide à
demander à l'ordinateur cette question,

1329
01:05:15,360 --> 01:05:18,885
plutôt que de regarder vers le haut sur une diapositive,
il imprimé un par ligne, A est 65,

1330
01:05:18,885 --> 01:05:24,860
B est 66, tout le chemin depuis que je down--
a fait cela 26 times-- aux lettres z,

1331
01:05:24,860 --> 01:05:25,630
qui est 90.

1332
01:05:25,630 --> 01:05:27,790
Et, en fait, légèrement
plus intelligent serait

1333
01:05:27,790 --> 01:05:31,030
ont été pour moi de ne pas compter
sur l'ordinateur pour ajouter 26.

1334
01:05:31,030 --> 01:05:34,060
Je pourrais viens de le faire
90 aussi bien, aussi longtemps

1335
01:05:34,060 --> 01:05:37,390
comme je ne fais pas la même erreur deux fois.

1336
01:05:37,390 --> 01:05:41,880
Je veux aller à travers
z, non seulement à travers y.

1337
01:05:41,880 --> 01:05:44,000
>> Voilà donc un casting explicite.

1338
01:05:44,000 --> 01:05:47,860
Il se trouve que ce
est même pas nécessaire.

1339
01:05:47,860 --> 01:05:52,480
Laissez-moi aller de l'avant et relancez cette
compilateur, et relancez Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Il se trouve que C est assez intelligent.

1341
01:05:54,940 --> 01:05:57,150
>> Et printf, en particulier,
est assez intelligent.

1342
01:05:57,150 --> 01:06:01,260
Si vous venez de passer deux fois un i
pour les deux espaces réservés, printf

1343
01:06:01,260 --> 01:06:04,510
réalisera, oh, eh bien je vous connais
m'a donné un integer-- un certain nombre,

1344
01:06:04,510 --> 01:06:06,380
comme 65, ou 90, ou autre chose.

1345
01:06:06,380 --> 01:06:10,170
Mais je vois que vous me voulez
formater ce nombre comme un personnage.

1346
01:06:10,170 --> 01:06:16,460
Et printf peut implicitement jeté
l'int en char pour vous aussi.

1347
01:06:16,460 --> 01:06:19,360
Donc, ce n'est pas un problème du tout.

1348
01:06:19,360 --> 01:06:23,100
>> Mais remarquez, à cause de cette équivalence
nous pouvons le faire aussi bien.

1349
01:06:23,100 --> 01:06:26,520
Laissez-moi aller de l'avant et de faire un
autre version this-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
Et au lieu de itérer
entiers, peut vraiment souffler votre esprit

1351
01:06:31,800 --> 01:06:33,610
par itération sur les caractères.

1352
01:06:33,610 --> 01:06:37,660
Si un char c obtient majuscule, je
veulent aller de l'avant et de le faire,

1353
01:06:37,660 --> 01:06:41,740
à condition que C est inférieure ou égale
à Z. en capital et à chaque itération

1354
01:06:41,740 --> 01:06:45,690
Je veux incrémenter C, je peux
maintenant dans ma ligne printf ici

1355
01:06:45,690 --> 01:06:51,320
disons, pour cent C est
pour cent i nouveau, virgule C.

1356
01:06:51,320 --> 01:06:57,200
>> Et maintenant, je peux aller dans l'autre direction,
la coulée du caractère explicite

1357
01:06:57,200 --> 01:06:58,500
à un nombre entier.

1358
01:06:58,500 --> 01:07:00,560
Donc, encore une fois, pourquoi voudriez-vous faire cela?

1359
01:07:00,560 --> 01:07:03,830
Il est un peu bizarre pour trier des
compter en termes de caractères.

1360
01:07:03,830 --> 01:07:07,430
>> Mais si vous comprenez ce qui est
passe sous le capot,

1361
01:07:07,430 --> 01:07:08,430
il n'y a vraiment pas de magie.

1362
01:07:08,430 --> 01:07:13,060
Tu dis, hé, l'ordinateur donne
moi une variable appelée C de type char.

1363
01:07:13,060 --> 01:07:16,520
Initialisation à capitaux A. Et
remarquer apostrophes matière.

1364
01:07:16,520 --> 01:07:19,580
>> Pour les caractères en C, rappeler à partir
la semaine dernière, vous utilisez des guillemets simples.

1365
01:07:19,580 --> 01:07:23,720
Pour les chaînes, pour les mots,
phrases, vous utilisez des guillemets.

1366
01:07:23,720 --> 01:07:27,210
OK, ordinateur, continuez à faire cela, alors
Tant que le caractère est inférieure à

1367
01:07:27,210 --> 01:07:28,050
ou égal à z.

1368
01:07:28,050 --> 01:07:32,640
Et je sais de ma table Ascii que tous
de ces codes Ascii sont contiguës.

1369
01:07:32,640 --> 01:07:33,400
>> Il n'y a pas les lacunes.

1370
01:07:33,400 --> 01:07:36,737
Donc, il est juste de A à Z,
séparés par un numéro chacun.

1371
01:07:36,737 --> 01:07:38,820
Et puis je peux incrémenter
un char, si je veux vraiment.

1372
01:07:38,820 --> 01:07:40,390
À la fin de la journée,
il est juste un nombre.

1373
01:07:40,390 --> 01:07:41,030
Je sais ça.

1374
01:07:41,030 --> 01:07:43,670
Donc, je ne peux présumer d'ajouter 1 à elle.

1375
01:07:43,670 --> 01:07:46,940
>> Et puis cette fois, j'imprime c,
puis l'équivalent intégral.

1376
01:07:46,940 --> 01:07:50,170
Et je ne suis même pas besoin de la distribution explicite.

1377
01:07:50,170 --> 01:07:52,680
Je peux laisser printf et
chiffre informatique choses,

1378
01:07:52,680 --> 01:07:57,300
de sorte que maintenant si je cours
faire Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Je reçois exactement la même chose aussi.

1380
01:08:01,520 --> 01:08:04,530
>> programme Inutile, though-- ne
va effectivement écrire un logiciel

1381
01:08:04,530 --> 01:08:07,549
afin de comprendre, quelle était la
nombre qui correspond à A, ou B ou Z?

1382
01:08:07,549 --> 01:08:10,340
Vous allez juste à Google, ou
consulter en ligne ou regarder vers le haut

1383
01:08:10,340 --> 01:08:11,650
sur une lame, ou similaire.

1384
01:08:11,650 --> 01:08:13,520
Alors, où est-ce réellement obtenir utile?

1385
01:08:13,520 --> 01:08:15,960
>> Eh bien, en parlant de ça
diapositive, notez qu'il ya

1386
01:08:15,960 --> 01:08:20,890
un motif réel ici entre les majuscules
et minuscules qui n'a pas été accidentelle.

1387
01:08:20,890 --> 01:08:23,760
Notez que le capital A est 65.

1388
01:08:23,760 --> 01:08:25,830
Minuscules a est 97.

1389
01:08:25,830 --> 01:08:29,649
Et à quelle distance est minuscule un?

1390
01:08:29,649 --> 01:08:32,649
>> Donc, 65 est le nombre de pas de 97?

1391
01:08:32,649 --> 01:08:36,210
Donc, 97 moins 65 est 32.

1392
01:08:36,210 --> 01:08:37,910
Donc, le capital est un 65.

1393
01:08:37,910 --> 01:08:39,939
Si vous ajoutez 32 à cela,
vous obtenez une minuscule.

1394
01:08:39,939 --> 01:08:43,729
Et, ce qui revient, si vous soustrayez 32,
vous revenez au capital A-- même avec B

1395
01:08:43,729 --> 01:08:46,380
à peu b, grand C à peu c.

1396
01:08:46,380 --> 01:08:50,670
>> Toutes ces lacunes sont 32 en dehors.

1397
01:08:50,670 --> 01:08:54,450
Maintenant, cela semble nous permettre de
faire quelque chose comme Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
ou Google Docs disposent, où vous
peut tout sélectionner puis dire,

1399
01:08:57,729 --> 01:09:00,520
changer tout en minuscules, ou
changer tout en majuscules,

1400
01:09:00,520 --> 01:09:03,840
ou modifier seul le premier mot
d'une phrase en majuscules.

1401
01:09:03,840 --> 01:09:07,390
Nous pouvons faire quelque chose
comme nous-mêmes.

1402
01:09:07,390 --> 01:09:12,645
>> Laissez-moi aller de l'avant et enregistrer un fichier
appelé ici capitaliser 0.c.

1403
01:09:12,645 --> 01:09:15,770
Et nous allons aller de l'avant et le fouet en place un programme
qui fait exactement cela comme suit.

1404
01:09:15,770 --> 01:09:18,460
Donc inclure la bibliothèque CS50.

1405
01:09:18,460 --> 01:09:21,430
Et inclure I / O standard.

1406
01:09:21,430 --> 01:09:22,787
>> Et je sais que cela arrive bientôt.

1407
01:09:22,787 --> 01:09:24,870
Donc, je vais le mettre dans
déjà là, string.h,

1408
01:09:24,870 --> 01:09:26,960
donc j'ai accès à
des choses comme Stirling,

1409
01:09:26,960 --> 01:09:29,620
puis int void main, comme d'habitude.

1410
01:09:29,620 --> 01:09:33,420
Et puis je vais aller de l'avant
et faire des chaînes obtient obtenir chaîne,

1411
01:09:33,420 --> 01:09:35,032
juste pour obtenir une chaîne de l'utilisateur.

1412
01:09:35,032 --> 01:09:36,740
Et puis je vais
faire mon test de cohérence.

1413
01:09:36,740 --> 01:09:40,510
Si la chaîne ne correspond pas à null,
alors il est sûr de continuer.

1414
01:09:40,510 --> 01:09:42,000
Et qu'est-ce que je veux faire?

1415
01:09:42,000 --> 01:09:48,700
Je vais itérer de i est égal à 0,
et n à la longueur de la chaîne de l'art.

1416
01:09:48,700 --> 01:09:51,899
>> Et je vais le faire aussi longtemps que
i est inférieur à n, et i plus plus.

1417
01:09:51,899 --> 01:09:55,060
Jusqu'à présent, je suis vraiment juste
empruntant des idées d'avant.

1418
01:09:55,060 --> 01:09:57,010
Et maintenant, je vais vous présenter une branche.

1419
01:09:57,010 --> 01:09:59,635
>> Donc, penser à Scratch, où
nous avions ces fourches de la route,

1420
01:09:59,635 --> 01:10:05,110
et la semaine dernière en C. Je vais
dire, si le caractère i-ième s

1421
01:10:05,110 --> 01:10:09,250
est supérieur ou
égal à un minuscule,

1422
01:10:09,250 --> 01:10:13,340
et-- dans Scratch vous le feriez littéralement
dites et, mais en C vous dites esperluette,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- et le caractère de rang i en s
est inférieur ou égal à z minuscules,

1424
01:10:19,830 --> 01:10:21,780
nous allons faire quelque chose d'intéressant.

1425
01:10:21,780 --> 01:10:27,020
Nous allons effectivement imprimer un
caractère sans newline

1426
01:10:27,020 --> 01:10:31,760
tel est le caractère de la chaîne,
le caractère i-ème dans la chaîne.

1427
01:10:31,760 --> 01:10:37,420
>> Mais nous allons aller de l'avant et
soustraire 32 de celle-ci.

1428
01:10:37,420 --> 01:10:42,120
Sinon, si le caractère de la
chaîne que nous sommes à la recherche

1429
01:10:42,120 --> 01:10:45,950
est pas entre peu une
et peu de z, aller de l'avant

1430
01:10:45,950 --> 01:10:48,610
et juste imprimé dehors inchangé.

1431
01:10:48,610 --> 01:10:50,840
Nous avons donc introduit
cette notation entre crochets

1432
01:10:50,840 --> 01:10:53,560
pour nos cordes pour obtenir au
i-ième caractère dans la chaîne.

1433
01:10:53,560 --> 01:10:57,520
>> J'ai ajouté de la logique conditionnelle, comme
Scratch de la semaine celui de la semaine dernière, où

1434
01:10:57,520 --> 01:10:59,880
Je suis juste en utilisant mon fondamentale
la compréhension de ce qui est

1435
01:10:59,880 --> 01:11:01,130
passe sous le capot.

1436
01:11:01,130 --> 01:11:04,190
Est-ce le caractère i-ème de s
supérieur ou égal à un?

1437
01:11:04,190 --> 01:11:08,290
Comme, est-il 97 ou 98,
ou 99, et ainsi de suite?

1438
01:11:08,290 --> 01:11:11,940
>> Mais est-il aussi inférieur ou égal
la valeur de z minuscule?

1439
01:11:11,940 --> 01:11:16,210
Et si oui, qu'est-ce que cette ligne signifie?

1440
01:11:16,210 --> 01:11:20,250
14, cela est en quelque sorte le
germe de l'idée,

1441
01:11:20,250 --> 01:11:23,840
tirer la lettre
tout simplement en soustrayant 32 de celui-ci,

1442
01:11:23,840 --> 01:11:29,370
dans ce cas, parce que je sais, par ce que
tableau, comment mes nombres sont représentés.

1443
01:11:29,370 --> 01:11:33,925
Donc, nous allons aller de l'avant et exécuter cela,
après la compilation de capitaliser 0.c,

1444
01:11:33,925 --> 01:11:36,210
et exécuter capitaliser 0.

1445
01:11:36,210 --> 01:11:40,300
>> Tapons dans quelque chose comme
Zamyla en minuscules entrer.

1446
01:11:40,300 --> 01:11:42,780
Et maintenant nous avons Zamyla en majuscules.

1447
01:11:42,780 --> 01:11:45,050
Tapons dans Rob en minuscules.

1448
01:11:45,050 --> 01:11:46,674
Essayons Jason en minuscules.

1449
01:11:46,674 --> 01:11:48,590
Et nous continuons à obtenir le
capitalisation forcée.

1450
01:11:48,590 --> 01:11:50,960
Il y a un bug mineur que je
sorte de ne pas anticiper.

1451
01:11:50,960 --> 01:11:54,050
Notez mon nouveau message est de se retrouver
sur la même ligne que leurs noms,

1452
01:11:54,050 --> 01:11:55,520
qui se sent un peu désordonné.

1453
01:11:55,520 --> 01:11:59,170
>> Donc, je vais aller ici, et
en fait, à la fin de ce programme,

1454
01:11:59,170 --> 01:12:02,110
imprimer un caractère de nouvelle ligne.

1455
01:12:02,110 --> 01:12:03,160
C'est tout.

1456
01:12:03,160 --> 01:12:06,120
Avec printf, vous ne devez pas
passer des variables ou code de format.

1457
01:12:06,120 --> 01:12:08,460
Vous pouvez littéralement juste imprimer
quelque chose comme un saut de ligne.

1458
01:12:08,460 --> 01:12:13,529
>> Donc, nous allons aller de l'avant et de faire
capitaliser 0 à nouveau, le relancer, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Et maintenant, il est un peu plus joli.

1460
01:12:14,820 --> 01:12:17,274
Maintenant, mon invite est sur sa propre nouvelle ligne.

1461
01:12:17,274 --> 01:12:18,440
Donc, c'est tout beau et bon.

1462
01:12:18,440 --> 01:12:19,910
Voilà un bon exemple.

1463
01:12:19,910 --> 01:12:22,700
Mais je fais même pas nécessairement
besoin de coder en dur le 32.

1464
01:12:22,700 --> 01:12:23,350
Vous savez quoi?

1465
01:12:23,350 --> 01:12:26,350
Je pourrais say-- je ne jamais
rappelez-vous quelle est la différence.

1466
01:12:26,350 --> 01:12:29,330
>> Mais je sais que si je
une lettre minuscule,

1467
01:12:29,330 --> 01:12:34,430
Je veux essentiellement soustraire au large
quelle que soit la distance est comprise entre peu

1468
01:12:34,430 --> 01:12:39,160
a et grand A, parce que si je suppose que
toutes les autres lettres sont les mêmes,

1469
01:12:39,160 --> 01:12:41,045
qui devrait faire le travail.

1470
01:12:41,045 --> 01:12:42,670
Mais plutôt que de le faire, vous savez quoi?

1471
01:12:42,670 --> 01:12:44,240
Il y a une autre façon encore.

1472
01:12:44,240 --> 01:12:48,090
>> Si ce capitalisons 1.c-- si je
de mettre cela dans un fichier séparé.

1473
01:12:48,090 --> 01:12:51,030
Faisons capitaliser 2.c comme suit.

1474
01:12:51,030 --> 01:12:53,060
Je vais vraiment nettoyer cette place ici.

1475
01:12:53,060 --> 01:12:57,420
Et au lieu de même avoir à
savoir ou se soucier de ceux à faible niveau

1476
01:12:57,420 --> 01:13:01,090
les détails de mise en œuvre, je suis à la place
aller juste pour imprimer un caractère,

1477
01:13:01,090 --> 01:13:04,610
entre guillemets, pour cent C, et
puis appeler une autre fonction qui

1478
01:13:04,610 --> 01:13:09,950
existe qui prend un argument,
qui est un caractère, comme celui-ci.

1479
01:13:09,950 --> 01:13:12,630
>> Il se trouve dans C, il y a
un autre appel de fonction

1480
01:13:12,630 --> 01:13:15,550
à supérieure, qui comme son nom
suggère prend un caractère

1481
01:13:15,550 --> 01:13:19,350
et le rend à son boîtier supérieur
équivalent, puis le renvoie

1482
01:13:19,350 --> 01:13:21,410
de telle sorte que printf peut le brancher là.

1483
01:13:21,410 --> 01:13:25,484
Et pour ce faire, cependant, je
besoin d'introduire un autre fichier.

1484
01:13:25,484 --> 01:13:28,400
Il se trouve qu'il ya un autre fichier
que vous ne sauriez de la classe,

1485
01:13:28,400 --> 01:13:33,020
ou un manuel, ou un en ligne
référence, appelé C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Donc, si j'ajoute que jusqu'à ma tête parmi
fichiers, et maintenant re-compiler ce programme,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Entrée.

1488
01:13:43,040 --> 01:13:46,690
Tapons dans Zamyla dans tous les
minuscules, travaille toujours le même.

1489
01:13:46,690 --> 01:13:48,040
Mais tu sais quoi?

1490
01:13:48,040 --> 01:13:55,590
Il se trouve que la partie supérieure
a une autre fonctionnalité.

1491
01:13:55,590 --> 01:13:58,410
>> Et permettez-moi de vous présenter cette
commander ici, en quelque sorte maladroitement

1492
01:13:58,410 --> 01:14:00,250
nommé, mais l'homme pour le manuel.

1493
01:14:00,250 --> 01:14:03,960
Il se trouve que la plupart des ordinateurs Linux,
que nous utilisons ici-- exploitation Linux

1494
01:14:03,960 --> 01:14:06,270
system-- une commande
appelé homme, qui dit,

1495
01:14:06,270 --> 01:14:08,530
hey, ordinateur, donnez-moi
le manuel de l'ordinateur.

1496
01:14:08,530 --> 01:14:10,680
Qu'est-ce que vous voulez
rechercher dans ce manuel?

1497
01:14:10,680 --> 01:14:13,840
>> Je veux regarder la fonction
appelée à supérieure, Entrée.

1498
01:14:13,840 --> 01:14:16,070
Et il est un peu cryptique
lire parfois.

1499
01:14:16,070 --> 01:14:18,780
Mais remarquons que nous sommes dans la
manuel de programmeur Linux.

1500
01:14:18,780 --> 01:14:19,530
Et il est tout le texte.

1501
01:14:19,530 --> 01:14:21,905
Et remarquez qu'il ya la
le nom de la fonction ici.

1502
01:14:21,905 --> 01:14:25,030
Il se trouve qu'il a un cousin appelé
pour abaisser, ce qui fait le contraire.

1503
01:14:25,030 --> 01:14:29,710
Et remarquez sous synopsis, d'utiliser cette
fonctionner la page de manuel, pour ainsi dire,

1504
01:14:29,710 --> 01:14:32,220
me disant que je
besoin d'inclure c type.h.

1505
01:14:32,220 --> 01:14:33,630
Et je savais que de la pratique.

1506
01:14:33,630 --> 01:14:36,210
>> Ici, il me montrant les deux
prototypes pour la fonction,

1507
01:14:36,210 --> 01:14:39,070
de sorte que si jamais je veux utiliser cette
Je sais ce qu'ils prennent comme entrée,

1508
01:14:39,070 --> 01:14:40,652
et ce qu'ils reviennent en sortie.

1509
01:14:40,652 --> 01:14:42,360
Et puis si je lis
la description, je vois

1510
01:14:42,360 --> 01:14:44,820
plus en détail ce que fait la fonction.

1511
01:14:44,820 --> 01:14:48,100
Mais plus important encore, si
Je regarde sous la valeur de retour,

1512
01:14:48,100 --> 01:14:51,710
il dit que la valeur retournée est
celle de la lettre convertie,

1513
01:14:51,710 --> 01:14:57,880
ou C, l'entrée originale, si
la conversion n'a pas été possible.

1514
01:14:57,880 --> 01:15:01,992
>> En d'autres termes, supérieure va essayer
pour convertir une lettre en majuscule.

1515
01:15:01,992 --> 01:15:03,450
Et si oui, il va retourner.

1516
01:15:03,450 --> 01:15:07,010
Mais si elle ne peut pas pour certains reason--
il est peut être le cas déjà supérieure,

1517
01:15:07,010 --> 01:15:09,550
peut-être qu'il est un point d'exclamation
ou un autre punctuation--

1518
01:15:09,550 --> 01:15:12,200
il va juste
retourner le C original,

1519
01:15:12,200 --> 01:15:17,340
qui signifie que je peux faire mon code
mieux conçu de la manière suivante.

1520
01:15:17,340 --> 01:15:20,580
>> Je ne veux pas tous
ces lignes darn de code.

1521
01:15:20,580 --> 01:15:22,610
Toutes les lignes que j'ai
juste en surbrillance peut

1522
01:15:22,610 --> 01:15:28,700
être effondré dans un seul simple,
ligne, qui est this-- pour cent de printf

1523
01:15:28,700 --> 01:15:33,510
c à S support supérieur i.

1524
01:15:33,510 --> 01:15:36,090
Et ce serait un
exemple de meilleure conception.

1525
01:15:36,090 --> 01:15:40,040
>> Pourquoi mettre en œuvre dans 7 ou 8 lignes
du code, quoi qu'il en soit je viens

1526
01:15:40,040 --> 01:15:44,960
supprimé, lorsque vous pouvez plutôt effondrer
tous que la logique et la prise de décision

1527
01:15:44,960 --> 01:15:49,620
en une seule ligne, 13 maintenant, que
repose sur une bibliothèque function--

1528
01:15:49,620 --> 01:15:53,430
une fonction qui est fourni avec C, mais que
fait exactement ce que vous voulez qu'il fasse.

1529
01:15:53,430 --> 01:15:55,295
Et, franchement, même si
il ne vient pas avec C,

1530
01:15:55,295 --> 01:15:58,880
vous pourriez mettre en œuvre vous-même, comme
nous avons vu, avec obtenir int négatif

1531
01:15:58,880 --> 01:16:01,700
et obtenir positif int la semaine dernière aussi bien.

1532
01:16:01,700 --> 01:16:03,470
>> Ce code est maintenant beaucoup plus lisible.

1533
01:16:03,470 --> 01:16:06,670
Et, en effet, si nous faisons défiler jusqu'à,
regardez comment beaucoup plus compact

1534
01:16:06,670 --> 01:16:08,360
cette version de mon programme est.

1535
01:16:08,360 --> 01:16:11,230
Il est un peu lourd top maintenant,
avec tous ces comprend.

1536
01:16:11,230 --> 01:16:14,380
Mais c'est OK, parce que maintenant je suis debout
sur les épaules des programmeurs

1537
01:16:14,380 --> 01:16:15,300
avant moi.

1538
01:16:15,300 --> 01:16:18,440
Et qui que ce soit qui
mis en œuvre pour vraiment supérieure

1539
01:16:18,440 --> 01:16:21,470
m'a fait une faveur, un peu comme celui qui
mis en œuvre Stirling vraiment

1540
01:16:21,470 --> 01:16:24,790
m'a fait une faveur il y a quelque temps.

1541
01:16:24,790 --> 01:16:26,970
Et maintenant nous avons un
meilleur programme de conception

1542
01:16:26,970 --> 01:16:31,680
qui met en œuvre la même logique exacte.

1543
01:16:31,680 --> 01:16:35,580
>> En parlant de stirling, laissez
moi aller de l'avant et faire cela.

1544
01:16:35,580 --> 01:16:38,320
Laissez-moi aller de l'avant et sauver
ce fichier comme stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Et il se trouve, on peut peler
une autre couche assez simplement maintenant.

1546
01:16:43,255 --> 01:16:45,630
Je vais aller de l'avant et le fouet
un autre programme principal

1547
01:16:45,630 --> 01:16:49,759
ici que re-outils tout simplement
longueur de chaîne comme suit.

1548
01:16:49,759 --> 01:16:52,300
Alors, voici une ligne de code qui
moi obtient une chaîne de l'utilisateur.

1549
01:16:52,300 --> 01:16:53,910
Nous continuons à utiliser encore et encore.

1550
01:16:53,910 --> 01:16:58,900
Permettez-moi de me donner une variable appelée
n de type int qui stocke un certain nombre.

1551
01:16:58,900 --> 01:17:02,490
>> Et laissez-moi aller de l'avant et
faire la logique suivante.

1552
01:17:02,490 --> 01:17:15,610
Bien que le caractère n-ième de l'art fait
pas égal backslash 0, aller de l'avant

1553
01:17:15,610 --> 01:17:17,930
et incrémenter n.

1554
01:17:17,930 --> 01:17:23,506
Et ensuite imprimer printf pour cent i n.

1555
01:17:23,506 --> 01:17:29,200
Je prétends que ce programme ici,
sans appeler longueur de la chaîne,

1556
01:17:29,200 --> 01:17:31,150
chiffres sur la longueur d'une chaîne.

1557
01:17:31,150 --> 01:17:34,600
>> Et la magie est tout à fait
encapsulé dans la ligne 8

1558
01:17:34,600 --> 01:17:39,830
ici avec ce qui ressemble à une nouvelle syntaxe,
ce backslash 0 apostrophes.

1559
01:17:39,830 --> 01:17:41,360
Mais pourquoi est-ce?

1560
01:17:41,360 --> 01:17:44,100
Eh bien, pensez à ce qui a été
passe tout ce temps.

1561
01:17:44,100 --> 01:17:47,990
>> Et comme un côté avant de l'oublier, réaliser
aussi que, en plus des pages de manuel

1562
01:17:47,990 --> 01:17:50,920
qui viennent avec un typique
système Linux comme CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
se rendre compte que nous,
Le personnel bien sûr, ont aussi

1564
01:17:53,770 --> 01:17:56,030
fait une version du site
de cette même idée appelée

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, qui a
toutes ces mêmes pages de manuel,

1566
01:17:59,940 --> 01:18:02,020
tout cela même
documentation, ainsi que

1567
01:18:02,020 --> 01:18:05,730
une petite boîte en haut qui permet
de convertir tous les assez

1568
01:18:05,730 --> 01:18:09,025
langue arcane en moins à l'aise
Mode, où nous, le personnel enseignant,

1569
01:18:09,025 --> 01:18:12,150
ont vécu et essayé de simplifier
certains de la langue pour garder les choses

1570
01:18:12,150 --> 01:18:14,830
mis l'accent sur les idées, et non
quelques-uns des aspects techniques.

1571
01:18:14,830 --> 01:18:20,070
Donc, gardez à l'esprit, reference.cs50.net
comme une autre ressource aussi bien.

1572
01:18:20,070 --> 01:18:23,800
>> Mais pourquoi le travail de longueur de chaîne dans le fait
la façon dont je proposais il y a un instant?

1573
01:18:23,800 --> 01:18:25,160
Voici à nouveau le nom de Zamyla.

1574
01:18:25,160 --> 01:18:27,690
Et voici le nom de Zamyla
enfermée, que je continue à faire,

1575
01:18:27,690 --> 01:18:31,360
pour peindre une image de celui-ci étant,
en réalité, il suffit d'une séquence de caractères.

1576
01:18:31,360 --> 01:18:34,260
Mais n'existe Zamyla
de manière isolée dans un programme.

1577
01:18:34,260 --> 01:18:37,420
>> Lorsque vous écrivez et exécutez un programme,
vous utilisez votre Mac ou votre PC

1578
01:18:37,420 --> 01:18:40,010
que la mémoire, ou RAM pour ainsi dire.

1579
01:18:40,010 --> 01:18:42,620
Et vous pouvez penser
votre ordinateur comme ayant

1580
01:18:42,620 --> 01:18:44,730
beaucoup de giga-octets de mémoire ces jours.

1581
01:18:44,730 --> 01:18:47,700
Et un concert signifie des milliards,
de sorte que des milliards d'octets.

1582
01:18:47,700 --> 01:18:48,910
>> Mais nous allons rembobiner dans le temps.

1583
01:18:48,910 --> 01:18:51,530
Et supposons que nous utilisons
un ordinateur vraiment vieux que

1584
01:18:51,530 --> 01:18:55,150
a seulement 32 octets de mémoire.

1585
01:18:55,150 --> 01:18:59,310
Je pourrais, sur mon écran d'ordinateur,
simplement dessiner ceci comme suit.

1586
01:18:59,310 --> 01:19:05,240
>> Je ne pouvais tout simplement dire que mon
l'ordinateur a tout de cette mémoire.

1587
01:19:05,240 --> 01:19:08,830
Et cela est comme un bâton de mémoire, si
Vous souvenez-vous de notre image à partir de la dernière fois.

1588
01:19:08,830 --> 01:19:11,670
Et si je divise simplement
ceci dans un nombre suffisant de fois,

1589
01:19:11,670 --> 01:19:15,040
Je prétends que j'ai 32 octets
de la mémoire à l'écran.

1590
01:19:15,040 --> 01:19:18,239
>> Maintenant, en réalité, je ne peux que
dessiner jusqu'à présent sur cet écran ici.

1591
01:19:18,239 --> 01:19:20,280
Je vais donc aller de l'avant,
et juste par convention,

1592
01:19:20,280 --> 01:19:24,050
dessiner la mémoire de l'ordinateur en tant
grille, non pas seulement comme une ligne droite.

1593
01:19:24,050 --> 01:19:28,190
Plus précisément, je prétends maintenant que
cette grille, ce 8 par 4 grille,

1594
01:19:28,190 --> 01:19:31,800
représente à peine les 32 octets
de mémoire disponible dans mon Mac,

1595
01:19:31,800 --> 01:19:33,030
ou disponibles dans mon PC.

1596
01:19:33,030 --> 01:19:34,780
Et ils l'emballage
sur deux lignes, il suffit

1597
01:19:34,780 --> 01:19:38,030
car il correspond plus à l'écran.

1598
01:19:38,030 --> 01:19:40,800
Mais ceci est le premier octet.

1599
01:19:40,800 --> 01:19:41,990
Ceci est le deuxième octet.

1600
01:19:41,990 --> 01:19:43,300
Ceci est le troisième octet.

1601
01:19:43,300 --> 01:19:45,310
>> Et ceci est l'octet 32e.

1602
01:19:45,310 --> 01:19:52,910
Ou, si l'on pense comme un ordinateur
scientifique, ceci est l'octet 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Donc, vous avez 0 à 31, si
vous commencez à compter à 0.

1604
01:19:55,950 --> 01:19:59,830
>> Donc, si nous utilisons un programme
que les appels reçoivent chaîne,

1605
01:19:59,830 --> 01:20:05,280
et nous obtenons une chaîne de l'humain
comme je n'appelé Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
comment dans le monde ne le
piste ordinateur donjon de l'octet,

1607
01:20:09,430 --> 01:20:12,230
qui morceau de mémoire,
appartient à quelle chaîne?

1608
01:20:12,230 --> 01:20:16,270
En d'autres termes, si l'on procède à
tapez un autre nom dans l'ordinateur,

1609
01:20:16,270 --> 01:20:19,890
comme cela Andi, appelant
obtenir string une deuxième fois,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I doit se retrouver dans la
la mémoire de l'ordinateur aussi bien.

1611
01:20:23,030 --> 01:20:23,850
Mais comment?

1612
01:20:23,850 --> 01:20:29,700
>> Eh bien, il se trouve que sous la
capot, ce qui fait quand C stocker des chaînes

1613
01:20:29,700 --> 01:20:35,080
que les types humains, ou que
viennent d'une autre source, est-il

1614
01:20:35,080 --> 01:20:39,190
délimite la fin d'entre eux avec
une barre oblique inverse character-- spéciale

1615
01:20:39,190 --> 01:20:44,750
0, ce qui est juste une façon spéciale
de dire 80 bits dans une rangée.

1616
01:20:44,750 --> 01:20:47,950
>> Donc A-- ceci est le rappel numéro 97.

1617
01:20:47,950 --> 01:20:51,770
Donc, un certain modèle de 8 bits
représente un nombre décimal 97.

1618
01:20:51,770 --> 01:20:58,070
Ce backslash 0 est littéralement le nombre
0, NUL a.k.a., N-U-L, à la différence plus tôt,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, dont nous avons parlé.

1620
01:20:59,630 --> 01:21:05,700
Mais pour l'instant, il suffit de savoir que cette
backslash 0 est à seulement 80 bits dans une rangée.

1621
01:21:05,700 --> 01:21:09,810
>> Et il est juste cette ligne dans le
sable qui dit quoi que ce soit à la gauche

1622
01:21:09,810 --> 01:21:12,610
appartient à une chaîne ou un type de données.

1623
01:21:12,610 --> 01:21:15,480
Et quoi que ce soit à la droite
appartient à autre chose.

1624
01:21:15,480 --> 01:21:17,440
son nom Andi, quant à lui,
qui vient visuellement

1625
01:21:17,440 --> 01:21:21,310
arrive à envelopper sur l'autre ligne,
mais c'est juste un détail esthétique,

1626
01:21:21,310 --> 01:21:23,990
similaire est nul terminé.

1627
01:21:23,990 --> 01:21:29,290
>> Il est une chaîne de caractères d'un A-N-D-I,
plus un cinquième caractère secret

1628
01:21:29,290 --> 01:21:33,560
tous les bits 0, qui délimite seulement
la fin du nom de Andi ainsi.

1629
01:21:33,560 --> 01:21:37,120
Et si nous appelons obtenir string une troisième fois
dans l'ordinateur pour obtenir une chaîne comme

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, est similaire Maria
nom nul terminé avec backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Ceci est fondamentalement différent
de la façon dont un ordinateur serait généralement

1632
01:21:47,170 --> 01:21:51,850
stocker un nombre entier, ou un flotteur, ou autre
types encore de données, parce que le rappel,

1633
01:21:51,850 --> 01:21:57,420
un nombre entier est généralement 32 bits, ou
4 octets, ou peut-être même 64 bits,

1634
01:21:57,420 --> 01:21:59,100
ou huit octets.

1635
01:21:59,100 --> 01:22:02,620
Mais beaucoup de primitives dans un ordinateur
dans un langage de programmation

1636
01:22:02,620 --> 01:22:05,550
un nombre fixe de
octets sous la hood--

1637
01:22:05,550 --> 01:22:08,100
peut-être 1, peut-être 2, 4 peut-être, peut-être 8.

1638
01:22:08,100 --> 01:22:13,250
>> Mais les chaînes, par la conception, ont un
nombre dynamique de caractères.

1639
01:22:13,250 --> 01:22:16,980
Vous ne savez pas à l'avance, jusqu'à ce que
les types humains Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
ou M-A-R-I-A ou A-N-D-I. Vous ne savez pas
Combien de fois l'utilisateur va frapper

1641
01:22:21,400 --> 01:22:22,070
le clavier.

1642
01:22:22,070 --> 01:22:26,490
Par conséquent, vous ne savez pas comment
de nombreux personnages à l'avance

1643
01:22:26,490 --> 01:22:27,540
vous allez avoir besoin.

1644
01:22:27,540 --> 01:22:31,840
>> Et C juste genre de feuilles comme un
breadcrumb secrète sous le capot

1645
01:22:31,840 --> 01:22:32,960
à la fin de la chaîne.

1646
01:22:32,960 --> 01:22:39,280
Après le stockage Z-A-M-Y-L-A dans la mémoire,
il met aussi à seulement l'équivalent

1647
01:22:39,280 --> 01:22:40,210
d'une période.

1648
01:22:40,210 --> 01:22:45,060
A la fin d'une phrase,
il met 80 bits, de sorte que

1649
01:22:45,060 --> 01:22:49,120
de se rappeler où
Zamyla commence et se termine.

1650
01:22:49,120 --> 01:22:51,490
>> Alors, quelle est la connexion,
puis, à ce programme?

1651
01:22:51,490 --> 01:22:55,190
Ce programme ici, Stirling,
est simplement un mécanisme

1652
01:22:55,190 --> 01:22:57,970
pour obtenir une chaîne
de l'utilisateur, la ligne 6.

1653
01:22:57,970 --> 01:23:01,160
Ligne 7, je déclare une variable
appelé n et le mettre égal à 0.

1654
01:23:01,160 --> 01:23:08,680
>> Et puis, dans la ligne 8, j'ai simplement demandé à la
question, tandis que le caractère n-ième fait

1655
01:23:08,680 --> 01:23:12,120
pas égal tout 0 bits--
autrement dit, ne pas

1656
01:23:12,120 --> 01:23:14,500
égale cette spéciale
caractère, backslash 0, ce qui

1657
01:23:14,500 --> 01:23:18,470
était juste que character-- NUL spéciale
aller de l'avant et juste incrémenter n.

1658
01:23:18,470 --> 01:23:21,460
>> Et continuer à le faire, et de garder
le faire, et continuer à le faire.

1659
01:23:21,460 --> 01:23:23,430
Et même si, dans
le passé, nous avons utilisé i,

1660
01:23:23,430 --> 01:23:25,181
il est parfaitement bien
sémantiquement à utiliser n,

1661
01:23:25,181 --> 01:23:27,430
si vous êtes juste essayer de
compter cette fois volontairement,

1662
01:23:27,430 --> 01:23:28,720
et vous voulez juste de l'appeler n.

1663
01:23:28,720 --> 01:23:34,720
Donc, ce ne cesse de poser la question,
est le caractère de n-ième s tous les 0?

1664
01:23:34,720 --> 01:23:38,470
Sinon, regardez à l'apparence suivante,
chercher à l'autre, chercher à l'autre,

1665
01:23:38,470 --> 01:23:39,460
chercher à l'autre.

1666
01:23:39,460 --> 01:23:45,540
>> Mais dès que vous voyez backslash 0,
cette ligne loop-- 9 à 11-- arrête.

1667
01:23:45,540 --> 01:23:49,640
Vous cassez hors de la boucle while,
en laissant à l'intérieur de cette variable n

1668
01:23:49,640 --> 01:23:54,530
un nombre total de tous les
caractères de la chaîne que vous avez vu,

1669
01:23:54,530 --> 01:23:55,660
imprimant ainsi it out.

1670
01:23:55,660 --> 01:23:56,760
Essayons donc cela.

1671
01:23:56,760 --> 01:23:59,500
>> Laissez-moi aller de l'avant et, sans
en utilisant la fonction de stirling,

1672
01:23:59,500 --> 01:24:04,240
mais juste en utilisant ma propre version Homegrown
ici appelé stirling, laissez-moi aller de l'avant

1673
01:24:04,240 --> 01:24:07,700
et exécuter stirling, tapez quelque chose
comme Zamyla, que je connais à l'avance

1674
01:24:07,700 --> 01:24:08,670
est de six caractères.

1675
01:24:08,670 --> 01:24:10,080
Voyons voir si cela fonctionne.

1676
01:24:10,080 --> 01:24:10,920
En effet, il est six.

1677
01:24:10,920 --> 01:24:15,257
Essayons avec Rob, trois personnages,
trois personnages aussi bien, et ainsi de suite.

1678
01:24:15,257 --> 01:24:17,340
Voilà donc tout ce qui se passe
au-dessous du capot.

1679
01:24:17,340 --> 01:24:19,548
Et remarquez les connexions,
puis, avec la première semaine

1680
01:24:19,548 --> 01:24:22,370
de la classe, où nous avons parlé
quelque chose comme l'abstraction,

1681
01:24:22,370 --> 01:24:26,960
qui est juste cette superposition d'idées, ou
complexité, au-dessus des principes de base.

1682
01:24:26,960 --> 01:24:30,710
Ici, nous sommes en quelque sorte à la recherche
sous le capot de stirling,

1683
01:24:30,710 --> 01:24:33,510
pour ainsi dire, de comprendre,
comment serait-il mis en œuvre?

1684
01:24:33,510 --> 01:24:35,232
>> Et nous pourrions ré-implémenter nous-mêmes.

1685
01:24:35,232 --> 01:24:37,440
Mais nous allons jamais à nouveau
à remettre en oeuvre stirling.

1686
01:24:37,440 --> 01:24:39,780
Nous allons juste
utiliser stirling pour

1687
01:24:39,780 --> 01:24:42,100
pour obtenir réellement une certaine longueur des cordes.

1688
01:24:42,100 --> 01:24:44,200
>> Mais il n'y a pas de magie
sous la hotte.

1689
01:24:44,200 --> 01:24:46,716
Si vous savez que sous
le capot, une chaîne

1690
01:24:46,716 --> 01:24:48,090
est tout simplement une séquence de caractères.

1691
01:24:48,090 --> 01:24:51,090
Et cette séquence de caractères
tous peuvent être numériquement adressée

1692
01:24:51,090 --> 01:24:53,330
avec support 0, support
1, le support 2, et vous

1693
01:24:53,330 --> 01:24:57,420
savoir que, à la fin d'une chaîne est un
caractère spécial, vous pouvez comprendre

1694
01:24:57,420 --> 01:25:01,710
comment faire plus quoi que ce soit dans un
programme, parce que tout cela se résume à

1695
01:25:01,710 --> 01:25:03,400
est la lecture et de la mémoire écrit.

1696
01:25:03,400 --> 01:25:06,130
Autrement dit, l'évolution et à la recherche
à la mémoire, ou bouger les choses

1697
01:25:06,130 --> 01:25:10,940
autour de la mémoire, des choses d'impression
sur l'écran, et ainsi de suite.

1698
01:25:10,940 --> 01:25:14,800
>> Donc, nous allons utiliser maintenant cette retrouvée
compréhension de ce howto fait

1699
01:25:14,800 --> 01:25:17,910
sont sous le capot, et
peler une autre couche

1700
01:25:17,910 --> 01:25:20,080
que jusqu'à présent, nous avons
été en ignorant complètement.

1701
01:25:20,080 --> 01:25:22,650
En particulier, tout le temps
nous avons mis en place un programme,

1702
01:25:22,650 --> 01:25:25,930
nous avons eu cette ligne de code
près du sommet déclarant principal.

1703
01:25:25,930 --> 01:25:27,810
Et nous avons spécifié void main int.

1704
01:25:27,810 --> 01:25:31,240
>> Et ce vide à l'intérieur des parenthèses
a été dit tout ce temps que le principal

1705
01:25:31,240 --> 01:25:33,440
lui-même ne prend pas d'arguments.

1706
01:25:33,440 --> 01:25:36,210
Toute entrée qui est principale
va obtenir de l'utilisateur

1707
01:25:36,210 --> 01:25:39,020
doit venir de quelque autre
mécanisme, comme get int,

1708
01:25:39,020 --> 01:25:42,040
ou obtenir float, ou d'obtenir la chaîne,
ou une autre fonction.

1709
01:25:42,040 --> 01:25:44,710
Mais il se trouve que
lorsque vous écrivez un programme,

1710
01:25:44,710 --> 01:25:47,690
vous pouvez réellement spécifier
que ce programme doit

1711
01:25:47,690 --> 01:25:51,730
prendre les entrées de l'humain
à la ligne de commande elle-même.

1712
01:25:51,730 --> 01:25:56,310
>> En d'autres termes, même si nous jusqu'ici
ont été en cours d'exécution juste ./hello bonjour

1713
01:25:56,310 --> 01:26:00,312
ou des programmes similaires, tous les
d'autres programmes que nous avons utilisé,

1714
01:26:00,312 --> 01:26:02,770
que nous nous n'avons pas écrit,
ont pris, il semble,

1715
01:26:02,770 --> 01:26:05,210
ligne de commande arguments--
des choses comme make.

1716
01:26:05,210 --> 01:26:07,450
Vous dites quelque chose comme marque,
puis un second mot.

1717
01:26:07,450 --> 01:26:10,950
Ou clang, clang vous dites, puis
un second mot, le nom d'un fichier.

1718
01:26:10,950 --> 01:26:14,410
>> Ou même RM ou CP, comme vous pouvez
ont vu ou déjà utilisé

1719
01:26:14,410 --> 01:26:15,880
de supprimer ou de copier des fichiers.

1720
01:26:15,880 --> 01:26:18,920
Tous ceux qui prennent soi-disant
ligne de commande arguments--

1721
01:26:18,920 --> 01:26:21,130
mots supplémentaires à l'invite du terminal.

1722
01:26:21,130 --> 01:26:23,260
Mais jusqu'à présent, nous
nous ont pas eu

1723
01:26:23,260 --> 01:26:27,080
ce luxe de prendre l'entrée de la
l'utilisateur quand il ou elle dirige effectivement

1724
01:26:27,080 --> 01:26:29,120
le programme lui-même à la ligne de commande.

1725
01:26:29,120 --> 01:26:33,710
>> Mais nous pouvons le faire en re-déclarer
principal aller de l'avant, et non pas comme ayant

1726
01:26:33,710 --> 01:26:36,750
annuler entre parenthèses,
mais ces deux arguments

1727
01:26:36,750 --> 01:26:40,600
instead-- le premier un nombre entier,
et la deuxième chose

1728
01:26:40,600 --> 01:26:44,170
nouveau, quelque chose que nous allons appeler
un tableau, quelque chose de semblable dans l'esprit

1729
01:26:44,170 --> 01:26:49,220
à ce que nous avons vu dans Scratch comme une liste, mais
un tableau de chaînes, comme nous allons bientôt voir.

1730
01:26:49,220 --> 01:26:51,790
Mais nous allons voir cela en
A titre d'exemple, avant d'

1731
01:26:51,790 --> 01:26:53,690
distinguer exactement ce que cela signifie.

1732
01:26:53,690 --> 01:26:56,520
>> Donc, si je vais dans CS50 IDE
ici, je suis allé de l'avant

1733
01:26:56,520 --> 01:27:01,840
et a déclaré dans un fichier appelé
argv0.c le modèle suivant.

1734
01:27:01,840 --> 01:27:04,120
Et remarquez la seule chose
qui est différent à ce jour

1735
01:27:04,120 --> 01:27:08,570
est que j'ai changé vide int
chaîne argc argv support ouvert, à proximité

1736
01:27:08,570 --> 01:27:09,070
support.

1737
01:27:09,070 --> 01:27:11,730
Et remarquez pour l'instant, il n'y a
rien à l'intérieur de ces supports.

1738
01:27:11,730 --> 01:27:12,620
>> Il n'y a pas le numéro.

1739
01:27:12,620 --> 01:27:15,070
Et il n'y a pas i, ou
n, ou toute autre lettre.

1740
01:27:15,070 --> 01:27:17,010
Je suis juste en utilisant le
crochets pour le moment,

1741
01:27:17,010 --> 01:27:19,510
pour des raisons que nous allons venir
retour à un moment.

1742
01:27:19,510 --> 01:27:21,330
>> Et maintenant ce que je vais faire est la suivante.

1743
01:27:21,330 --> 01:27:26,680
Si argc est égal à égal à 2--
et rappelons que égaux égaux

1744
01:27:26,680 --> 01:27:30,040
est l'égalité opérateur comparant
gauche et à droite pour l'égalité.

1745
01:27:30,040 --> 01:27:31,790
Il est pas l'affectation
opérateur, qui est

1746
01:27:31,790 --> 01:27:36,510
le signe égal unique, ce qui signifie copie
de la droite vers la gauche une certaine valeur.

1747
01:27:36,510 --> 01:27:42,840
>> Si argc est égal à égal à 2, je veux
disons, printf, bonjour, pourcentages, nouvelle ligne,

1748
01:27:42,840 --> 01:27:47,340
puis branchez in-- et voici la nouvelle
trick-- support de argv 1, pour des raisons

1749
01:27:47,340 --> 01:27:48,840
que nous y reviendrons dans un instant.

1750
01:27:48,840 --> 01:27:52,110
Sinon, si argc ne
égale 2, vous savez quoi?

1751
01:27:52,110 --> 01:27:57,400
Disons simplement aller de l'avant et, comme d'habitude, print
out bonjour monde sans substitution.

1752
01:27:57,400 --> 01:28:02,710
>> Ainsi, il semblerait que si argc, qui
signifie un nombre d'arguments, est égal à 2,

1753
01:28:02,710 --> 01:28:04,740
Je vais imprimer
bonjour quelque chose ou autre.

1754
01:28:04,740 --> 01:28:07,560
Sinon, par défaut, je suis
va imprimer Bonjour tout le monde.

1755
01:28:07,560 --> 01:28:08,770
Qu'est-ce que cela signifie?

1756
01:28:08,770 --> 01:28:15,550
>> Eh bien, laissez-moi aller de l'avant et sauve
ce fichier, puis faire faire argv0,

1757
01:28:15,550 --> 01:28:18,940
puis ./argv0, Entrée.

1758
01:28:18,940 --> 01:28:20,300
Et il dit bonjour monde.

1759
01:28:20,300 --> 01:28:21,260
Maintenant, pourquoi est-ce?

1760
01:28:21,260 --> 01:28:24,730
>> Eh bien, il se trouve à tout moment vous
exécuter un programme à la ligne de commande,

1761
01:28:24,730 --> 01:28:29,570
vous remplissez ce que nous allons
appeler généralement un vecteur d'argument.

1762
01:28:29,570 --> 01:28:33,100
En d'autres termes, automatiquement la
ordinateur, le système d'exploitation,

1763
01:28:33,100 --> 01:28:38,340
va remettre à votre programme
lui-même une liste de tous les mots

1764
01:28:38,340 --> 01:28:40,850
que l'homme a tapé à
l'invite, au cas où vous

1765
01:28:40,850 --> 01:28:43,790
le programmeur veut faire
quelque chose avec cette information.

1766
01:28:43,790 --> 01:28:48,540
Et dans ce cas, le seul mot
J'ai tapé à l'invite est ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Et le nombre d'arguments qui est
étant passé à mon programme est juste un.

1768
01:28:55,420 --> 01:28:58,880
En d'autres termes, l'argument
compter, autrement connu comme argc

1769
01:28:58,880 --> 01:29:00,970
ici comme un entier, est juste un.

1770
01:29:00,970 --> 01:29:03,000
Un, bien sûr, ne pas deux.

1771
01:29:03,000 --> 01:29:05,980
Et voici ce que imprime, bonjour monde.

1772
01:29:05,980 --> 01:29:08,170
>> Mais laissez-moi prendre cela quelque part.

1773
01:29:08,170 --> 01:29:09,930
Laissez-moi vous dire, argv0.

1774
01:29:09,930 --> 01:29:12,740
Et puis comment à propos de Maria?

1775
01:29:12,740 --> 01:29:14,990
Et puis appuyez sur Entrée.

1776
01:29:14,990 --> 01:29:18,020
>> Et remarquez ce qui se passe ici par magie.

1777
01:29:18,020 --> 01:29:22,640
Maintenant, au lieu de Bonjour tout le monde, je dois
modifié le comportement de ce programme

1778
01:29:22,640 --> 01:29:26,310
en prenant l'entrée pas de get
chaîne ou une autre fonction,

1779
01:29:26,310 --> 01:29:30,570
mais à partir de, apparemment, mon commandement
lui-même, ce que je initialement tapé.

1780
01:29:30,570 --> 01:29:35,720
Et je peux jouer à ce jeu à nouveau par
changer Stelios, par exemple.

1781
01:29:35,720 --> 01:29:38,400
>> Et maintenant je vois un autre nom encore.

1782
01:29:38,400 --> 01:29:40,540
Et ici, je pourrais dire Andi.

1783
01:29:40,540 --> 01:29:42,137
Et je pourrais dire Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Et nous pouvons jouer à ce jeu toute la journée,
juste de brancher des valeurs différentes,

1785
01:29:45,220 --> 01:29:49,550
aussi longtemps que je donne exactement
deux mots à l'invite,

1786
01:29:49,550 --> 01:29:52,260
de telle sorte que argc, mon argumentation compte, est 2.

1787
01:29:52,260 --> 01:29:57,240
>> Est-ce que je vois ce nom branché
printf, par cette condition ici?

1788
01:29:57,240 --> 01:30:00,550
Donc, il semble que nous avons maintenant
la capacité expressive

1789
01:30:00,550 --> 01:30:04,410
de prendre l'entrée d'un autre mécanisme,
à partir de la ligne dite de commande,

1790
01:30:04,410 --> 01:30:07,000
plutôt que d'avoir à attendre
jusqu'à ce que l'utilisateur exécute le programme,

1791
01:30:07,000 --> 01:30:10,220
et invite ensuite lui
en utilisant quelque chose comme chaîne de get.

1792
01:30:10,220 --> 01:30:11,230
>> Alors qu'est-ce?

1793
01:30:11,230 --> 01:30:15,010
Argc, encore une fois, est juste un nombre entier,
le nombre de words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
que l'utilisateur a fourni à la
invite, à la fenêtre de terminal,

1795
01:30:18,540 --> 01:30:20,110
y compris le nom du programme.

1796
01:30:20,110 --> 01:30:23,340
Donc, notre ./argv0 est, effectivement,
le nom du programme,

1797
01:30:23,340 --> 01:30:24,520
ou comment je lance le programme.

1798
01:30:24,520 --> 01:30:25,810
>> Cela compte comme un mot.

1799
01:30:25,810 --> 01:30:27,080
Donc argc serait 1.

1800
01:30:27,080 --> 01:30:29,750
Mais quand j'écris Stelios, ou
Andi, ou Zamyla, ou Maria,

1801
01:30:29,750 --> 01:30:31,660
cela signifie que le nombre d'arguments est de deux.

1802
01:30:31,660 --> 01:30:33,910
Et maintenant, il y a deux mots transmis.

1803
01:30:33,910 --> 01:30:36,070
>> Et remarquez, nous pouvons continuer cette logique.

1804
01:30:36,070 --> 01:30:39,050
Si je dis effectivement
quelque chose comme Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
un nom complet, en passant par là
trois arguments au total,

1806
01:30:42,200 --> 01:30:47,410
maintenant, il dit encore la valeur par défaut,
parce que, bien sûr, 3 ne égale 2.

1807
01:30:47,410 --> 01:30:54,080
>> Et de cette façon, je dois
accès par argv ce nouvel argument

1808
01:30:54,080 --> 01:30:56,080
que nous pourrions techniquement
appeler tout ce que nous voulons.

1809
01:30:56,080 --> 01:30:58,940
Mais par convention, il est
argv et argc, respectivement.

1810
01:30:58,940 --> 01:31:04,470
Argv argument vecteur, est une sorte
d'un synonyme pour une programmation

1811
01:31:04,470 --> 01:31:07,140
fonctionnalité dans C appelé un tableau.

1812
01:31:07,140 --> 01:31:14,410
>> Un tableau est une liste de valeurs similaires
dos, à dos, à dos, à dos.

1813
01:31:14,410 --> 01:31:17,810
En d'autres termes, si l'on est ici dans
RAM, le prochain est juste à côté,

1814
01:31:17,810 --> 01:31:18,800
et juste à côté.

1815
01:31:18,800 --> 01:31:20,101
Ils ne sont pas partout.

1816
01:31:20,101 --> 01:31:23,100
Et ce dernier scénario, où les choses
sont tous sur la place en mémoire,

1817
01:31:23,100 --> 01:31:25,082
peut effectivement être une fonctionnalité puissante.

1818
01:31:25,082 --> 01:31:28,040
Mais nous y reviendrons lorsque nous
parler de structures de données fantaisistes.

1819
01:31:28,040 --> 01:31:32,260
Pour l'instant, un tableau est juste un
morceau de mémoire contiguë,

1820
01:31:32,260 --> 01:31:36,520
chacun dont les éléments sont
arrière, en arrière, à l'arrière, à l'arrière,

1821
01:31:36,520 --> 01:31:38,050
et plus généralement du même type.

1822
01:31:38,050 --> 01:31:42,630
>> Donc, si vous pensez, à partir d'un
il y a moment, ce qui est une chaîne?

1823
01:31:42,630 --> 01:31:50,460
Eh bien, une chaîne, comme Zamyla,
Z-A-M-Y-L-A, est, techniquement,

1824
01:31:50,460 --> 01:31:51,400
juste un tableau.

1825
01:31:51,400 --> 01:31:53,700
Il est un tableau de caractères.

1826
01:31:53,700 --> 01:31:59,250
>> Et donc, si nous tirons vraiment, comme je
a fait plus tôt, comme un morceau de la mémoire,

1827
01:31:59,250 --> 01:32:04,510
il se trouve que chacun d'entre eux
caractères prend un octet.

1828
01:32:04,510 --> 01:32:07,630
Et puis il y a de spécial
caractère sentinelle, le backslash 0,

1829
01:32:07,630 --> 01:32:12,360
ou tous les huit bits 0, que
délimite la fin de cette chaîne.

1830
01:32:12,360 --> 01:32:15,090
Donc, une chaîne, il se
out, citer chaîne unquote,

1831
01:32:15,090 --> 01:32:20,580
est tout simplement un tableau de chara--
carboniser étant un type de données réel.

1832
01:32:20,580 --> 01:32:24,560
>> Et maintenant argv, meanwhile--
Revenons au programme.

1833
01:32:24,560 --> 01:32:29,582
Argv, même si nous voyons le mot
chaîne ici, est pas une chaîne elle-même.

1834
01:32:29,582 --> 01:32:33,640
Argv argument vecteur,
est un tableau de chaînes.

1835
01:32:33,640 --> 01:32:37,620
>> Donc, comme vous pouvez avoir un tableau de
caractères, vous pouvez avoir un niveau plus élevé,

1836
01:32:37,620 --> 01:32:46,279
un tableau de strings-- ainsi, par exemple,
quand je tapais un moment il y a ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, l'espace Z-A-M-Y-L-A, I a affirmé que
argv avait deux cordes dans ./argv0 it--,

1838
01:33:00,150 --> 01:33:03,185
et Z-A-M-Y-L-A. Dans
Autrement dit, argc était 2.

1839
01:33:03,185 --> 01:33:03,980
Pourquoi donc?

1840
01:33:03,980 --> 01:33:08,370
>> Eh bien, effectivement, ce qui se passe
sur est que chacune de ces chaînes

1841
01:33:08,370 --> 01:33:13,990
est, bien entendu, un tableau de caractères
comme auparavant, des personnages dont chacun des

1842
01:33:13,990 --> 01:33:15,670
prend un octet.

1843
01:33:15,670 --> 01:33:19,720
Et ne pas confondre le 0 réelle
au nom du programme avec le 0,

1844
01:33:19,720 --> 01:33:22,040
ce qui signifie que tous les 80 bits.

1845
01:33:22,040 --> 01:33:27,140
Et Zamyla, quant à lui, est toujours
également un tableau de caractères.

1846
01:33:27,140 --> 01:33:31,450
>> Ainsi, à la fin de la journée, il a vraiment
ressemble à ceci sous le capot.

1847
01:33:31,450 --> 01:33:38,800
Mais argv, par la nature de la façon principale
travaux, me permet d'envelopper tout cela

1848
01:33:38,800 --> 01:33:44,810
vers le haut dans, si vous voulez, un plus grand tableau
que, si nous simplifions un peu plus

1849
01:33:44,810 --> 01:33:48,180
ce que l'image ressemble et ne pas
tout à fait dessiner à l'échelle là-haut,

1850
01:33:48,180 --> 01:33:56,720
ce tableau est seulement de taille 2, la première
élément qui contient une chaîne de caractères,

1851
01:33:56,720 --> 01:33:59,230
le second élément du
qui contient une chaîne.

1852
01:33:59,230 --> 01:34:01,687
Et, à son tour, si vous
sorte de zoomer sur chaque

1853
01:34:01,687 --> 01:34:03,770
de ces chaînes, ce que vous
voir sous le capot

1854
01:34:03,770 --> 01:34:07,190
est que chaque chaîne est juste
un tableau de caractères.

1855
01:34:07,190 --> 01:34:11,680
>> Maintenant, tout comme avec des cordes,
nous avons été en mesure d'obtenir l'accès

1856
01:34:11,680 --> 01:34:15,260
le caractère i-ième dans une chaîne
en utilisant cette notation entre crochets.

1857
01:34:15,260 --> 01:34:17,320
De même, avec les tableaux
en général, pouvons-nous

1858
01:34:17,320 --> 01:34:22,700
utiliser la notation crochet pour obtenir
à un certain nombre de chaînes dans un tableau?

1859
01:34:22,700 --> 01:34:25,100
Par exemple, laissez-moi
aller de l'avant et le faire.

1860
01:34:25,100 --> 01:34:32,420
>> Laissez-moi aller de l'avant et de créer argv1.c,
qui est un peu différent cette fois.

1861
01:34:32,420 --> 01:34:35,635
Au lieu de vérifier pour argc2,
Je vais plutôt faire cela.

1862
01:34:35,635 --> 01:34:41,270
Pour int je reçois 0, I est moins
que argc, je plus plus,

1863
01:34:41,270 --> 01:34:47,920
puis imprimer à l'intérieur de cela,
pour cent s, nouvelle ligne, puis

1864
01:34:47,920 --> 01:34:50,740
argv support i.

1865
01:34:50,740 --> 01:34:55,220
>> Donc, en d'autres termes, je ne suis pas traiter avec
caractères individuels pour le moment.

1866
01:34:55,220 --> 01:35:00,190
Argv, comme le laisse entendre par ces case vide
accolades à la droite du nom argv,

1867
01:35:00,190 --> 01:35:03,320
signifie argv est un tableau de chaînes.

1868
01:35:03,320 --> 01:35:04,870
Et argc est juste un int.

1869
01:35:04,870 --> 01:35:08,800
>> Cette ligne ici, 6, est
dire ensemble i égal à 0.

1870
01:35:08,800 --> 01:35:11,980
Comptez tout le chemin jusqu'à,
mais ne comprenant pas, argc.

1871
01:35:11,980 --> 01:35:14,010
Et puis à chaque itération,
imprimer une chaîne de caractères.

1872
01:35:14,010 --> 01:35:14,800
Quelle chaîne?

1873
01:35:14,800 --> 01:35:17,270
>> La chaîne i-ième argv.

1874
01:35:17,270 --> 01:35:19,530
Ainsi, alors que avant que je
en utilisant le support carré

1875
01:35:19,530 --> 01:35:22,180
notation pour obtenir au ième
caractère dans une chaîne, maintenant

1876
01:35:22,180 --> 01:35:27,240
Je suis en utilisant la notation de support carré
pour obtenir à la chaîne i dans un tableau.

1877
01:35:27,240 --> 01:35:30,310
Donc, il est en quelque sorte d'une couche
ci-dessus, sur le plan conceptuel.

1878
01:35:30,310 --> 01:35:35,390
>> Et ce qui est propre à ce sujet
programme maintenant, si je compile argv1,

1879
01:35:35,390 --> 01:35:42,067
puis faire ./argv1, puis tapez
dans quelque chose comme foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
qui sont les trois mots par défaut qui a
informaticien atteint pour tout le temps

1881
01:35:45,400 --> 01:35:51,010
il ou elle a besoin de quelques mots d'espace réservé,
et appuyez sur Entrée, chacun de ces mots,

1882
01:35:51,010 --> 01:35:54,980
y compris le nom du programme, qui
argv est au premier emplacement,

1883
01:35:54,980 --> 01:35:58,320
finit par être imprimés un à la fois.

1884
01:35:58,320 --> 01:36:05,290
Et si je change cela, et je dis
quelque chose comme argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
nous obtenons les trois personnes
mots, ce qui est argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, parce que dans ce
cas argc, le comte, est 3.

1887
01:36:14,400 --> 01:36:20,020
>> Mais ce qui est pur est si vous comprenez
que argv est juste un tableau de chaînes,

1888
01:36:20,020 --> 01:36:24,910
et vous comprenez qu'une chaîne
est un tableau de caractères,

1889
01:36:24,910 --> 01:36:29,470
nous pouvons en fait plutôt utiliser cette
notation crochet plusieurs fois

1890
01:36:29,470 --> 01:36:33,320
de choisir une chaîne, puis choisissez
un caractère dans la chaîne,

1891
01:36:33,320 --> 01:36:35,730
la plongée en plus profonde de la façon suivante.

1892
01:36:35,730 --> 01:36:40,100
Dans cet exemple, laissez-moi aller
avant et appeler ce argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Et dans cet exemple, laissez-moi aller de l'avant
et faire le following-- pour int i obtenir 0,

1895
01:36:50,180 --> 01:36:53,286
i est inférieur à argc, i plus
en plus, comme avant.

1896
01:36:53,286 --> 01:36:55,910
Donc, dans d'autres words-- et maintenant cette
est d'obtenir assez compliqué.

1897
01:36:55,910 --> 01:36:59,940
Alors je vais dire
itérer sur les chaînes dans argv,

1898
01:36:59,940 --> 01:37:01,294
comme un commentaire à moi-même.

1899
01:37:01,294 --> 01:37:03,960
Et puis je vais avoir un
imbriqué pour la boucle, que vous avez probablement

1900
01:37:03,960 --> 01:37:06,290
ont fait, ou considéré
faire, dans Scratch, où

1901
01:37:06,290 --> 01:37:08,600
Je vais dire int-- je suis
ne va pas utiliser i nouveau,

1902
01:37:08,600 --> 01:37:12,590
parce que je ne veux pas l'ombre, ou
sorte de remplacer le i existant.

1903
01:37:12,590 --> 01:37:15,780
>> Je vais plutôt dire j, parce
c'est mon aller à la variable après i,

1904
01:37:15,780 --> 01:37:18,590
quand je suis juste essayer de
compter des nombres simples.

1905
01:37:18,590 --> 01:37:28,850
Pour j obtient 0-- et aussi, n, va
obtenir la longueur arrière du support argv i,

1906
01:37:28,850 --> 01:37:36,030
à condition que j est inférieur à m,
j plus plus, procédez comme suit.

1907
01:37:36,030 --> 01:37:37,500
Et voici la partie intéressante.

1908
01:37:37,500 --> 01:37:46,330
>> Imprimez un caractère et une nouvelle ligne,
brancher argv support i, support j.

1909
01:37:46,330 --> 01:37:47,940
OK, alors permettez-moi d'ajouter quelques commentaires ici.

1910
01:37:47,940 --> 01:37:54,820
Itérer sur les caractères
dans la chaîne actuelle,

1911
01:37:54,820 --> 01:38:02,290
print caractère j-ième chaîne i-ème.

1912
01:38:02,290 --> 01:38:04,630
Alors maintenant, nous allons examiner
ce que ces commentaires signifient.

1913
01:38:04,630 --> 01:38:06,750
>> Itérer sur les cordes
dans argv-- combien

1914
01:38:06,750 --> 01:38:09,300
chaînes sont en argv, qui est un tableau?

1915
01:38:09,300 --> 01:38:13,420
Argc beaucoup, donc je suis itérer
de i égal 0 à argc.

1916
01:38:13,420 --> 01:38:20,020
Pendant ce temps, le nombre de caractères
sont dans la chaîne i-ème dans argv?

1917
01:38:20,020 --> 01:38:22,880
>> Eh bien, pour obtenir cette réponse,
Je viens d'appeler longueur de la chaîne

1918
01:38:22,880 --> 01:38:26,810
sur la I soins de chaîne en cours
à propos, qui est argv support i.

1919
01:38:26,810 --> 01:38:30,090
Et je vais stocker temporairement que
la valeur n, juste à des fins de mise en cache,

1920
01:38:30,090 --> 01:38:31,590
en souvenir de l'efficacité.

1921
01:38:31,590 --> 01:38:36,330
Et puis je vais initialiser j à 0,
continuer aussi longtemps que j est inférieur à n,

1922
01:38:36,330 --> 01:38:38,430
et chaque incrément d'itération j.

1923
01:38:38,430 --> 01:38:41,030
>> Et puis ici, par
mon commentaire sur la ligne 12,

1924
01:38:41,030 --> 01:38:43,390
imprimer un caractère,
suivie d'une nouvelle ligne,

1925
01:38:43,390 --> 01:38:48,140
support spécifiquement argv
i me donne la chaîne i-ème

1926
01:38:48,140 --> 01:38:51,690
en argv-- de sorte que le premier mot, la
deuxième mot, le troisième mot, quel que soit.

1927
01:38:51,690 --> 01:38:57,370
Et puis plongées j en plus profond, et obtient
moi le caractère j-ème de ce mot.

1928
01:38:57,370 --> 01:39:02,200
Et donc, en effet, vous pouvez traiter
argv comme multidimensionnel,

1929
01:39:02,200 --> 01:39:06,050
en deux dimensions, tableau,
de sorte que chaque mot genre de regards

1930
01:39:06,050 --> 01:39:08,580
comme cela dans votre esprit de
oeil, et chaque personnage

1931
01:39:08,580 --> 01:39:10,930
est une sorte de composé en
une colonne, si cela aide.

1932
01:39:10,930 --> 01:39:13,260
>> En réalité, lorsque nous taquinons
cette part dans les semaines à venir,

1933
01:39:13,260 --> 01:39:15,580
ça va être un peu
plus sophistiqué que cela.

1934
01:39:15,580 --> 01:39:17,800
Mais vous pouvez vraiment
penser que, pour l'instant,

1935
01:39:17,800 --> 01:39:22,110
comme tout cela en deux dimensions
tableau, dans lequel un niveau de celui-ci

1936
01:39:22,110 --> 01:39:23,260
est l'ensemble des chaînes.

1937
01:39:23,260 --> 01:39:26,760
Et puis si vous plongez dans plus profond, vous
peut obtenir les caractères individuels

1938
01:39:26,760 --> 01:39:29,600
dans celui-ci en utilisant cette notation ici.

1939
01:39:29,600 --> 01:39:31,620
>> Alors, quel est l'effet net?

1940
01:39:31,620 --> 01:39:34,970
Laissez-moi aller de l'avant et
faire sacrément argv2-- il.

1941
01:39:34,970 --> 01:39:36,210
J'ai fait une erreur ici.

1942
01:39:36,210 --> 01:39:40,160
déclarant Implicitement la
bibliothèque stirling fonction.

1943
01:39:40,160 --> 01:39:42,190
Donc tout ce temps, il est
peut-être approprié

1944
01:39:42,190 --> 01:39:45,130
que nous sorte de finition
exactement là où nous avons commencé.

1945
01:39:45,130 --> 01:39:48,160
>> Je merdé, déclarant implicitement
bibliothèque stirling fonction.

1946
01:39:48,160 --> 01:39:48,987
OK attends une minute.

1947
01:39:48,987 --> 01:39:51,070
Je me souviens que, en particulier
car il est juste ici.

1948
01:39:51,070 --> 01:39:54,490
Je dois inclure dans string.h
cette version du programme.

1949
01:39:54,490 --> 01:40:00,050
>> Laissez-moi aller de l'avant et inclure
string.h, sauf que, aller de l'avant

1950
01:40:00,050 --> 01:40:04,460
et recompiler argv2.

1951
01:40:04,460 --> 01:40:08,390
Et maintenant, nous allons, faire argv2, Entrée.

1952
01:40:08,390 --> 01:40:10,590
Et si elle est un peu
cryptique au premier coup d'œil,

1953
01:40:10,590 --> 01:40:15,690
remarquer que, en effet, ce que
est imprimé est argv2 dot.

1954
01:40:15,690 --> 01:40:19,970
>> Mais si je tape quelques mots après la
invite, comme argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Entrez, aussi un peu
cryptique au premier coup d'œil.

1956
01:40:22,560 --> 01:40:30,540
Mais si nous faisons défiler back up,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Nous avons donc répétées sur chaque mot.

1958
01:40:32,190 --> 01:40:37,770
Et, à son tour, nous avons itéré
chaque caractère dans un mot.

1959
01:40:37,770 --> 01:40:40,040
>> Maintenant, après tout cela,
se rendent compte qu'il ya

1960
01:40:40,040 --> 01:40:43,120
un autre détail que nous avons été genre
d'ignorer tout ce temps.

1961
01:40:43,120 --> 01:40:46,180
Nous venons taquiné dehors ce
Les entrées de principales peuvent être?

1962
01:40:46,180 --> 01:40:47,780
Qu'en est-il la sortie principale?

1963
01:40:47,780 --> 01:40:50,540
>> Tout ce temps, nous avons été
simplement copier et coller

1964
01:40:50,540 --> 01:40:53,870
le mot int devant principal,
si vous pouvez voir en ligne,

1965
01:40:53,870 --> 01:40:58,340
parfois à tort dans les anciennes versions
des compilateurs C et, ce qu'ils disent vide,

1966
01:40:58,340 --> 01:40:59,410
ou rien du tout.

1967
01:40:59,410 --> 01:41:01,580
Mais, en effet, pour la version
C que nous utilisons,

1968
01:41:01,580 --> 01:41:06,180
C 11, ou 2011, réaliser
qu'il devrait être un entier.

1969
01:41:06,180 --> 01:41:09,300
Et il devrait être soit
nulle ou argc et argv ici.

1970
01:41:09,300 --> 01:41:10,790
>> Mais pourquoi int main?

1971
01:41:10,790 --> 01:41:12,480
Qu'est-ce qu'il fait retour?

1972
01:41:12,480 --> 01:41:16,280
Eh bien, il se trouve tout ce temps,
chaque fois que vous avez écrit un principal de programme

1973
01:41:16,280 --> 01:41:18,440
est toujours quelque chose de retour.

1974
01:41:18,440 --> 01:41:19,960
Mais il a été fait si secrètement.

1975
01:41:19,960 --> 01:41:23,350
>> Ce quelque chose est un
int, comme la ligne 5 suggère.

1976
01:41:23,350 --> 01:41:24,225
Mais ce qui int?

1977
01:41:24,225 --> 01:41:26,100
Eh bien, il y a cette
convention dans la programmation,

1978
01:41:26,100 --> 01:41:29,790
de sorte que si rien n'a
allé mal et tout va bien,

1979
01:41:29,790 --> 01:41:34,250
programmes et fonctions généralement
return-- peu counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 signifie généralement que tout va bien.

1982
01:41:38,070 --> 01:41:40,610
Donc, même si vous pensez
comme fausse dans de nombreux contextes,

1983
01:41:40,610 --> 01:41:42,930
il signifie en fait généralement une bonne chose

1984
01:41:42,930 --> 01:41:49,560
>> Pendant ce temps, si un programme retourne 1,
ou négatif 1, ou 5, ou négative 42,

1985
01:41:49,560 --> 01:41:52,941
ou tout-0 non valeur,
qui signifie généralement

1986
01:41:52,941 --> 01:41:54,190
que quelque chose a mal tourné.

1987
01:41:54,190 --> 01:41:56,700
En fait, sur votre propre Mac ou PC,
vous pourriez avoir réellement vu

1988
01:41:56,700 --> 01:42:01,050
un message d'erreur, ce par quoi il
dit quelque chose ou une autre, l'erreur

1989
01:42:01,050 --> 01:42:04,940
Code négative 42, ou code d'erreur
23, ou quelque chose comme ça.

1990
01:42:04,940 --> 01:42:08,980
Ce nombre est généralement juste un soupçon
pour le programmeur, ou la société

1991
01:42:08,980 --> 01:42:11,174
qui a fait le logiciel,
ce qui a mal et pourquoi,

1992
01:42:11,174 --> 01:42:13,590
de sorte qu'ils puissent regarder à travers
leur documentation ou code,

1993
01:42:13,590 --> 01:42:15,465
et comprendre ce que le
erreur signifie réellement.

1994
01:42:15,465 --> 01:42:18,400
Il est en général pas
utile pour nous les utilisateurs finaux.

1995
01:42:18,400 --> 01:42:20,550
>> Mais quand les principaux rendements 0, tout va bien.

1996
01:42:20,550 --> 01:42:23,770
Et si vous ne spécifiez pas
ce principal devrait revenir,

1997
01:42:23,770 --> 01:42:26,950
il sera tout simplement automatiquement
retourner 0 pour vous.

1998
01:42:26,950 --> 01:42:30,870
Mais quelque chose de retour
le reste est réellement utile.

1999
01:42:30,870 --> 01:42:34,660
>> Dans ce programme final, laissez-moi
allez-y et appelez ce exit.c,

2000
01:42:34,660 --> 01:42:38,630
et d'introduire le dernier aujourd'hui
sujets, connu comme un code d'erreur.

2001
01:42:38,630 --> 01:42:42,930
Laissez-moi aller de l'avant et inclure notre
fichiers familiers en haut, font int main.

2002
01:42:42,930 --> 01:42:49,500
Et cette fois, nous allons faire int argc,
chaîne argv, et avec mes crochets

2003
01:42:49,500 --> 01:42:50,836
impliquer que ce soit dans le tableau.

2004
01:42:50,836 --> 01:42:52,460
Et puis laissez-moi juste faire une vérification de la santé mentale.

2005
01:42:52,460 --> 01:42:56,640
Cette fois, si argc ne
égale 2, alors vous savez quoi?

2006
01:42:56,640 --> 01:42:57,520
Oublie.

2007
01:42:57,520 --> 01:43:03,170
Je vais dire que, hé, utilisateur,
vous manquez commande argument de ligne

2008
01:43:03,170 --> 01:43:04,210
backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> Et puis voilà.

2010
01:43:05,230 --> 01:43:06,130
Je veux sortir.

2011
01:43:06,130 --> 01:43:11,030
Je vais préemptive,
et prématurément vraiment, le retour

2012
01:43:11,030 --> 01:43:12,810
autre chose que le numéro 1.

2013
01:43:12,810 --> 01:43:15,360
Le déplacement à la valeur pour la première
erreur qui peut se produire est 1.

2014
01:43:15,360 --> 01:43:17,860
Si vous avez une autre erreur
situation qui pourrait se produire,

2015
01:43:17,860 --> 01:43:21,390
vous pourriez dire le retour 2 ou revenir 3, ou
peut-être même négative 1 ou 2 négative.

2016
01:43:21,390 --> 01:43:23,750
>> Ce ne sont que des codes de sortie
qui sont, en général,

2017
01:43:23,750 --> 01:43:27,770
seulement utile pour le programmeur, ou
entreprise qui l'expédition du logiciel.

2018
01:43:27,770 --> 01:43:30,500
Mais le fait que ce soit
pas 0 est ce qui est important.

2019
01:43:30,500 --> 01:43:34,310
Donc, si dans ce programme, je veux
garantir que ce programme ne

2020
01:43:34,310 --> 01:43:38,190
fonctionne si l'utilisateur me fournit
avec un nombre d'arguments de deux,

2021
01:43:38,190 --> 01:43:42,880
le nom du programme, et d'autres
mot, je peux appliquer autant comme suit,

2022
01:43:42,880 --> 01:43:46,110
crier à l'utilisateur avec printf dit,
commande argument de ligne manquante,

2023
01:43:46,110 --> 01:43:46,970
retour 1.

2024
01:43:46,970 --> 01:43:49,940
Ce sera tout de suite
quitter le programme.

2025
01:43:49,940 --> 01:43:55,840
>> Seulement si argc est égal à 2 va nous descendre
ici, à quel point je vais dire,

2026
01:43:55,840 --> 01:44:00,410
bonjour pour cent s, backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
En d'autres termes, je suis
ne va pas après argv 0,

2028
01:44:03,827 --> 01:44:05,410
qui est juste le nom du programme.

2029
01:44:05,410 --> 01:44:09,450
Je veux imprimer bonjour, virgule,
le deuxième mot que l'homme a tapé.

2030
01:44:09,450 --> 01:44:12,580
Et dans ce cas sur
ligne 13, tout va bien.

2031
01:44:12,580 --> 01:44:15,920
>> Je sais que argc est 2
logiquement de ce programme.

2032
01:44:15,920 --> 01:44:17,770
Je vais aller de l'avant et revenir 0.

2033
01:44:17,770 --> 01:44:21,230
En aparté, gardez à l'esprit que
cela est vrai dans Scratch ainsi.

2034
01:44:21,230 --> 01:44:24,760
>> Logiquement, je pouvais le faire
et encapsuler ces lignes

2035
01:44:24,760 --> 01:44:27,020
du code dans cet autre article ici.

2036
01:44:27,020 --> 01:44:29,420
Mais que ce genre de
indentation inutilement mon code.

2037
01:44:29,420 --> 01:44:31,800
Et je veux faire de super
clair que peu importe ce que,

2038
01:44:31,800 --> 01:44:34,670
par défaut, bonjour
quelque chose va s'imprimé,

2039
01:44:34,670 --> 01:44:36,050
tant que l'utilisateur coopère.

2040
01:44:36,050 --> 01:44:39,360
>> Donc, il est très fréquent d'utiliser
une condition, juste un si,

2041
01:44:39,360 --> 01:44:41,870
pour attraper un peu erronée
situation et puis sortir.

2042
01:44:41,870 --> 01:44:45,690
Et puis, si longtemps tout est
bien, pas d'autre chose,

2043
01:44:45,690 --> 01:44:48,060
mais ont simplement le code
à l'extérieur que si, parce qu'il est

2044
01:44:48,060 --> 01:44:51,060
équivalent en ce
cas particulier, logiquement.

2045
01:44:51,060 --> 01:44:54,480
Donc je retourne 0, juste pour
signifient explicitement tout va bien.

2046
01:44:54,480 --> 01:44:58,480
>> Si j'omis le retour 0, il serait
être automatiquement pris pour moi.

2047
01:44:58,480 --> 01:45:00,890
Mais maintenant que je suis de retour
l'un au moins ce cas,

2048
01:45:00,890 --> 01:45:04,940
Je vais, pour faire bonne mesure et
clarté, retour 0 dans ce cas.

2049
01:45:04,940 --> 01:45:09,690
Alors maintenant, laissez-moi aller de l'avant et de faire la sortie,
qui est un enchaînement parfait pour partir juste.

2050
01:45:09,690 --> 01:45:14,401
>> Mais assurez-sortie, et laissez-moi aller
avant et faire ./exit, Entrée.

2051
01:45:14,401 --> 01:45:16,900
Et le programme m'a crié dessus,
manquant argument de ligne de commande.

2052
01:45:16,900 --> 01:45:18,120
OK, laissez-moi coopérer.

2053
01:45:18,120 --> 01:45:23,810
>> Permettez-moi plutôt faire ./exit, David, Entrée.

2054
01:45:23,810 --> 01:45:25,190
Et maintenant, il dit bonjour David.

2055
01:45:25,190 --> 01:45:27,300
Et vous ne verriez pas normalement cela.

2056
01:45:27,300 --> 01:45:30,650
>> Mais il se trouve qu'il y a un
manière particulière dans Linux de voir réellement

2057
01:45:30,650 --> 01:45:34,470
avec ce que le code de sortie d'un programme est sorti.

2058
01:45:34,470 --> 01:45:37,184
Parfois, dans un graphique
monde comme Mac OS ou Windows,

2059
01:45:37,184 --> 01:45:40,100
vous ne voyez que ces chiffres quand un
message d'erreur apparaît sur l'écran

2060
01:45:40,100 --> 01:45:41,940
et le programmeur
vous montre ce numéro.

2061
01:45:41,940 --> 01:45:44,773
Mais si nous voulons voir ce que l'erreur
message est, nous pouvons le faire ici--

2062
01:45:44,773 --> 01:45:48,100
donc ./exit, Entrez, imprimer
manquant argument de ligne de commande.

2063
01:45:48,100 --> 01:45:54,590
>> Si je fais maintenant $ echo ?, qui est
ridiculement cryptique.

2064
01:45:54,590 --> 01:45:56,590
Mais $?

2065
01:45:56,590 --> 01:45:59,220
est l'incantation magique
qui dit, hé, ordinateur,

2066
01:45:59,220 --> 01:46:01,900
dites-moi ce que le précédent
Le code de sortie du programme était.

2067
01:46:01,900 --> 01:46:03,410
Et je frappe Entrée.

2068
01:46:03,410 --> 01:46:07,520
Je vois 1, parce que ce que je
dit ma principale fonction de revenir.

2069
01:46:07,520 --> 01:46:12,310
>> Pendant ce temps, si je fais ./exit David,
et appuyez sur Entrée, je vois, bonjour David.

2070
01:46:12,310 --> 01:46:16,800
Et si je fais maintenant $ echo ?, Je vois bonjour 0.

2071
01:46:16,800 --> 01:46:19,080
Et donc ce sera effectivement
être des informations précieuses

2072
01:46:19,080 --> 01:46:23,420
dans le cadre du débogueur, non pas
bien que vous, l'humain, voulez bien.

2073
01:46:23,420 --> 01:46:26,060
Mais le débogueur et d'autres
programmes que nous allons utiliser ce semestre

2074
01:46:26,060 --> 01:46:29,420
sera souvent regarder ce nombre,
même si elle est en quelque sorte caché

2075
01:46:29,420 --> 01:46:32,780
à moins que vous cherchez, à
déterminer si un programme de ou non

2076
01:46:32,780 --> 01:46:37,050
exécution était correcte ou incorrecte.

2077
01:46:37,050 --> 01:46:40,450
>> Et cela nous amène à
ceci, à la fin de la journée.

2078
01:46:40,450 --> 01:46:43,917
Nous avons commencé aujourd'hui en regardant
le débogage, et à son tour sur le parcours

2079
01:46:43,917 --> 01:46:46,750
lui-même, puis de façon plus intéressante,
techniquement sous le capot

2080
01:46:46,750 --> 01:46:49,490
à ce que les chaînes sont, qui durent
semaine, nous avons juste pris pour acquis,

2081
01:46:49,490 --> 01:46:51,900
et certainement les a pris
pour acquis dans Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Nous avons ensuite examiné comment nous pouvons accéder
caractères individuels dans une chaîne,

2083
01:46:56,040 --> 01:47:00,310
puis à nouveau pris un niveau plus élevé
regarder les choses, en regardant comment well--

2084
01:47:00,310 --> 01:47:04,226
si nous voulons obtenir au niveau individuel
éléments d'une liste comme la structure,

2085
01:47:04,226 --> 01:47:05,850
ne pouvons-nous faire avec plusieurs chaînes?

2086
01:47:05,850 --> 01:47:08,050
Et nous pouvons avec les arguments de ligne de commande.

2087
01:47:08,050 --> 01:47:12,800
Mais cette image ici de seulement boîtes
est démonstratif de cette idée générale

2088
01:47:12,800 --> 01:47:14,451
d'un tableau ou d'une liste, ou un vecteur.

2089
01:47:14,451 --> 01:47:16,450
Et en fonction de la
contexte, tous ces mots

2090
01:47:16,450 --> 01:47:17,880
dire des choses légèrement différentes.

2091
01:47:17,880 --> 01:47:20,060
Donc, en C, nous allons seulement
pour parler d'un tableau.

2092
01:47:20,060 --> 01:47:23,840
Et un tableau est un morceau
de la mémoire, dont chacun est

2093
01:47:23,840 --> 01:47:27,720
éléments sont contigus, le dos,
à dos, à dos, à dos.

2094
01:47:27,720 --> 01:47:31,970
>> Et que ces éléments sont, en général,
du même type de données, caractère,

2095
01:47:31,970 --> 01:47:35,966
caractère, caractère, caractère, ou
string, string, string, string ou int,

2096
01:47:35,966 --> 01:47:38,600
int, int, quel qu'il soit
nous essayons de magasin.

2097
01:47:38,600 --> 01:47:42,540
Mais à la fin de la journée, ceci est
à quoi il ressemble sur le plan conceptuel.

2098
01:47:42,540 --> 01:47:44,530
Vous prenez votre
la mémoire ou la mémoire vive de l'ordinateur.

2099
01:47:44,530 --> 01:47:48,590
Et vous sculpter dehors dans
des boîtes de dimensions identiques, toutes

2100
01:47:48,590 --> 01:47:50,920
sont de retour, à l'arrière, à
dos à dos de cette manière.

2101
01:47:50,920 --> 01:47:53,200
>> Et ce qui est agréable au sujet
cette idée, et le fait

2102
01:47:53,200 --> 01:47:58,580
que nous pouvons exprimer les valeurs de cette façon
la première de ses structures de données

2103
01:47:58,580 --> 01:48:02,520
dans la classe, signifie que nous pouvons commencer
pour résoudre les problèmes avec le code

2104
01:48:02,520 --> 01:48:04,079
qui est venu de façon intuitive dans la semaine 0.

2105
01:48:04,079 --> 01:48:05,870
Vous vous souviendrez le téléphone
exemple du livre, où

2106
01:48:05,870 --> 01:48:09,110
nous avons utilisé un diviser pour régner,
ou un algorithme de recherche binaire,

2107
01:48:09,110 --> 01:48:13,220
passer au crible l'ensemble
tas de noms et numéros.

2108
01:48:13,220 --> 01:48:18,220
Mais nous avons supposé, le rappel, que ce
répertoire téléphonique est déjà trié,

2109
01:48:18,220 --> 01:48:21,630
que quelqu'un d'autre avait déjà
Façonnés out-- donné une liste de noms

2110
01:48:21,630 --> 01:48:24,430
et numbers-- comment les alphabétiser.

2111
01:48:24,430 --> 01:48:26,950
Et maintenant que C nous,
aussi, avoir la capacité

2112
01:48:26,950 --> 01:48:30,290
de jeter les choses, pas
physiquement dans un annuaire téléphonique

2113
01:48:30,290 --> 01:48:34,220
mais pratiquement dans un ordinateur de
la mémoire, que nous pourrons la semaine prochaine

2114
01:48:34,220 --> 01:48:38,470
d'introduire à nouveau la première this--
de nos structures de données dans un array--

2115
01:48:38,470 --> 01:48:43,530
mais plus important encore, l'ordinateur réel
algorithmes scientifiques mis en œuvre

2116
01:48:43,530 --> 01:48:47,720
dans le code, avec laquelle nous pouvons stocker
données dans des structures comme celle-ci,

2117
01:48:47,720 --> 01:48:50,730
et puis commencer à le manipuler, et
pour résoudre réellement les problèmes avec elle,

2118
01:48:50,730 --> 01:48:53,570
et de construire au-dessus de cela,
en fin de compte, les programmes en C,

2119
01:48:53,570 --> 01:48:56,730
en Python, en JavaScript,
l'interrogation des bases de données avec SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Et nous verrons que tous ces
différentes idées verrouillage.

2121
01:48:59,980 --> 01:49:04,100
Mais pour l'instant, rappelons que la
domaine que nous avons présenté aujourd'hui

2122
01:49:04,100 --> 01:49:06,920
était cette chose ici, et
le monde de la cryptographie.

2123
01:49:06,920 --> 01:49:11,200
Et parmi les prochaines vous-même les problèmes
résoudra est l'art de la cryptographie,

2124
01:49:11,200 --> 01:49:13,630
embrouillage et de désembrouillage
informations et chiffrement

2125
01:49:13,630 --> 01:49:15,930
et le déchiffrage du texte,
et en supposant que finalement

2126
01:49:15,930 --> 01:49:18,970
que vous savez maintenant ce que
est sous le capot

2127
01:49:18,970 --> 01:49:21,860
de sorte que lorsque vous voyez ou recevez
un message comme celui-ci, vous

2128
01:49:21,860 --> 01:49:24,060
vous pouvez le déchiffrer.

2129
01:49:24,060 --> 01:49:26,740
Tout cela, et plus la prochaine fois.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [LECTURE VIDÉO]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Vient d'arriver.

2133
01:49:32,970 --> 01:49:35,146
Je vais aller visiter
son professeur de collège.

2134
01:49:35,146 --> 01:49:37,611
Oui.

2135
01:49:37,611 --> 01:49:40,080
Salut.

2136
01:49:40,080 --> 01:49:40,660
C'est toi.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Attendez!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Je suis juste essayer de comprendre
ce qui vous est arrivé.

2142
01:49:56,060 --> 01:49:58,130
S'il vous plaît, quelque chose pourrait aider.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Vous étiez son collège
colocataire, étiez-vous pas?

2145
01:50:08,354 --> 01:50:10,770
Vous y étiez avec lui quand
il a terminé le projet de CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUSIC PLAYING]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Que Était CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> J'adore cet endroit.

2152
01:50:44,770 --> 01:50:45,854
>> -Dévorer.

2153
01:50:45,854 --> 01:50:47,020
Nous allons sortir de l'entreprise.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [FIN LECTURE]

