[MUSIC Duke luajtur] 

DAVID J. Malan: Të gjithë të drejtë. Kjo është CS50 dhe ky është fillimi i Javës 2. Dhe ju do të kujtojnë se mbi çifti kaluara javë, ne kemi qenë të futur kompjuter shkencës dhe, nga ana tjetër, programimi. 

Dhe kemi filluar historinë me anë të Scratch, se gjuha grafike nga Media Lab MIT'S. Dhe pastaj më të fundit, javën e kaluar, e bëri ne futur një higher-- a Gjuha e nivelit të ulët të njohur si C, diçka që është tërësisht tekstuale. Dhe, me të vërtetë, hera e fundit që ne hulumtohen në këtë kontekst një numër i koncepteve. 

Kjo, kujtojnë, ishte shumë i programi i parë pamë. Dhe ky program, thjesht, kopje nga "hello, botën." Por nuk ka aq shumë gjoja magjike ndodh. Nuk është kjo #include me këto kllapa kënd. Ka int. Ka (i pavlefshëm). Ka kllapa, formatimin e teksteve kaçurrel, gjysmë-colons, dhe shumë më tepër. 

Dhe kështu, kujtojmë se ne kemi prezantuar Scratch në mënyrë që ne mund të, në mënyrë ideale, shikoni të kaluarën se sintaksa, sende që nuk është e vërtetë të gjitha që intelektualisht interesante, por më herët është, absolutisht, pak i ndërlikuar për të përfunduar mendjen tuaj rreth. Dhe, me të vërtetë, një nga më të zakonshme gjëra më herët në një klasë të programimit, sidomos për ata më pak të rehatshme, është për të marrë të frustruar nga dhe morën nga sintaktik të caktuar gabime, për të mos përmendur gabime logjike. Dhe kështu në mesin e qëllimeve tona Sot, në fakt, do të të jenë të pajisur ju me disa Teknikat e zgjidhjes së problemeve për mënyrën se si për të zgjidhur më mirë problemet veten në formën e debugging. Dhe ju do të kujtojnë, gjithashtu, se Mjedisi që ne kemi prezantuar Herën e fundit është quajtur CS50 IDE. Kjo është software web-bazuar se ju lejon të programit në një re, kështu që të flasin, duke i mbajtur të gjitha tuaj fotografi së bashku, si ne përsëri do sot. Dhe kujtojnë se ne rishqyrtohet këto tema ketu, në mesin e tyre, funksionet dhe sythe, dhe variabla, dhe shprehjet Boolean, dhe kushtet. Dhe në fakt një pak më shumë se ne përkthyer nga bota e Scratch në botën e C. 

Por ndërtimi themelore blloqe, kështu që të flasin, ishin me të vërtetë ende e njëjtë javën e kaluar. Në fakt, ne me të vërtetë kishte vetëm një pjesë të ndryshme mister, nëse ju do. Në vend të që të purpurt shpëtuar bllok, ne vend kishte printf, e cila është ky funksion në C që ju lejon për të shkruar diçka dhe format atë në ekran. Ne kemi prezantuar CS50 Library, ku ju kanë tani në get_char dispozicionin tuaj, dhe get_int dhe get_string, dhe disa funksione të tjera si disa mirë, me anë të të cilit ju mund të merrni të dhëna nga tastierë të plotë të përdoruesit. Dhe ne gjithashtu mori një vështrim në gjëra si these- bool, dhe char, dhe të dyfishtë, noton, int, string long_long. Dhe ka edhe lloje të tjera të të dhënave në C. 

Me fjalë të tjera, kur ju të deklarojë një variabël për të ruajtur disa vlera, ose kur ju të zbatojë një funksion që kthehet disa vlera, ju mund të specifikoni se çfarë lloji i vlerës që është. A është kjo një varg, si një sekuenca e karaktereve? A është kjo një numër, si një numër të plotë? A është kjo një pikë lundrues vlera, ose si? Pra në C, ndryshe nga Scratch, ne fakt filloi të përcaktojë se çfarë lloj të të dhënave ne ishim kthyer ose duke përdorur. 

Por, natyrisht, ne gjithashtu u përplas disa kufizime themelore të informatikës. Dhe në mënyrë të veçantë, kjo gjuhë C, risjell që kemi marrë një vështrim në del nga shtrati integer, realiteti se në qoftë se ju keni vetëm një Shuma e fundme e kujtesës ose, në mënyrë të veçantë, një numër i caktuar i bit, ju vetëm mund të mbështeteni aq e lartë. Dhe kështu që ne shikuar në këtë shembull këtu ku një counter në një aeroplan,, në fakt, në qoftë se duke kohë të mjaftueshme do të del nga shtrati dhe të rezultojë në një software një fizik aktual gabim të mundshëm. 

Ne gjithashtu shikuar në lundrues Pika pasaktësi, realiteti që me vetëm një numër i caktuar i bit, nëse është 32 apo 64, ju mund të specifikoni vetëm kaq shumë numra pas një presjes dhjetore, pas së cilës ju të fillojë të marrë të pasakta. Kështu për shembull, një e treta në bota këtu, në botën tonë njerëzore, ne e dimë është vetëm një numër i pafund i 3s pas presjes dhjetore. Por një kompjuteri nuk mund domosdoshmërisht përfaqësojnë një numër të pafund të numrave në qoftë se ju vetëm të lejojë që disa Shuma e fundme e informacionit. 

Pra, jo vetëm që ne t'ju pajisë me fuqi më të madhe në aspektin se si ju mund të shprehë veten në një tastierë në aspektin e programimit, ne gjithashtu e kufizuar atë në të vërtetë ju mund të bëni. Dhe me të vërtetë, bugs dhe gabime mund të lindin nga këto lloj çështjesh. Dhe në të vërtetë, në mesin e temave sot do të jetë tema si debugging dhe në të vërtetë në kërkim nën kapuç se si janë futur gjëra të javës së fundit janë zbatuar në fakt kështu që ju më mirë kuptojnë të dyja aftësitë e dhe kufizimet e një gjuhë si C 

Dhe në fakt, ne do të zhvishem përsëri shtresa e thjeshte e strukturës së të dhënave, diçka që quhet një grup, i cili Scratch ndodh për të thirrur një "listë". Është pak ndryshe në këtë kontekst. Dhe pastaj ne do të prezantoj një nga e parë e problemeve tona domain-e të Caktuar në CS50, bota e cryptography, arti i përpiqen ose në ciphering informacion në mënyrë që ju mund të dërgoni mesazhe sekrete dhe deshifroj mesazhe sekrete në mes të dy personave, A dhe B. 

Pra, para se të tranzicionit në atë botë të re, le të përpiqemi për të pajisur ju me disa teknikat me të cilat ju mund të eliminojnë ose reduktimin e te pakten disa nga frustrimet që ju keni hasur ndoshta gjatë javës së kaluar vetëm. Në të vërtetë, para teje janë such-- disa Problemet tuaja të para në C. Dhe shanset janë, në qoftë se ju jeni si mua, hera e parë ju përpiqeni të shkruani një program, edhe në qoftë se ju mendoni logjikisht Programi është shumë e thjeshtë, ju mund shumë mirë të goditur një mur, dhe përpiluesi nuk do të bashkëpunojnë. Bëni ose tingëllimë nuk do që në fakt urdhrat e tua. 

Dhe pse mund që të jetë? E pra, le të marrin një vështrim në, ndoshta, një program i thjeshtë. Unë jam duke shkuar për të shkuar përpara dhe për të shpëtuar këtë në një file i quajtur qëllimisht buggy0.c, sepse unë e di që ajo të të meta paraprakisht. Por unë nuk mund të kuptojnë se në qoftë se kjo është programi i parë apo të dytë ose të tretë se unë jam në të vërtetë duke e bërë veten time. Kështu që unë jam duke shkuar për të shkuar përpara dhe lloji jashtë, int kryesor (i pavlefshëm). Dhe pastaj brenda formatimin e teksteve kaçurrel e mia, një shumë të njohur ( "hello, world-- backslash, n ") - dhe një gjysmë-zorrës së trashë. 

Unë e kam ruajtur file. Tani unë jam duke shkuar për të shkuar poshtë në dritaren time terminal dhe llojin e make buggy0, sepse, përsëri, Emri i skedarit sot është buggy0.c. Kështu që unë lloji të buggy0, Enter. 

Dhe, oh, Zot, kujtohet nga hera e fundit se pa mesazhet e gabimit është një gjë e mirë. Kështu që nuk ka dalje është një gjë e mirë. Por këtu kam të qartë disa numër i gabimeve. 

Pra, rreshtin e parë të prodhimit pas shtypni të buggy0, kujtojnë, del mjaft e fjalëshumë tingëllimë së. Nën kapuç, CS50 IDE është konfiguruar për të përdorur një bandë e tërë e Opsionet me këtë përpilues në mënyrë që ju nuk keni për të menduar rreth tyre. Dhe kjo është e gjitha që vija e parë do të thotë se fillon me tingëllimë. 

Por pas kësaj, problemet të fillojë për të bërë paraqitjen e tyre. Buggy0.c në linjë 3, karakterin 5, nuk është një, gabim i madh i kuq. Cfare eshte ajo? Implicite deklaruar funksionin e bibliotekës printf me lloj int (char * const, ...) [-Werror]. Unë do të thotë, se shumë shpejt merr shumë misterioze. Dhe sigurisht, në fillim shikim, ne nuk do të presin që ju të kuptoni tërësia e atij mesazhi. Dhe kështu një nga mësimet sepse sot do të jetë për të provoni në njoftim modele, apo gjëra të ngjashme, për gabimet që mund të keni hasur në të kaluarën. Pra, le të të vë në lojë përveç vetëm ato fjalë që duken të njohura. I madh, gabim e kuqe është e qartë simbol i diçkaje të gabuar. 

implicite deklaruar Funksioni printf bibliotekë. Pra, edhe në qoftë se unë nuk e kuptojnë fare se çfarë implicite deklaruar funksionin e bibliotekës do të thotë, problemi me siguri ka të bëjë me printf disi. Dhe burimi i kësaj çështjeje ka të bëjë me shpalljen atë. 

Deklaruar një funksion është përmendur atë për herë të parë. Dhe kemi qenë terminologjinë javën e kaluar i deklaruar prototip një funksion së, ose me një linjë në krye tuaj Dosja e vet ose në një të ashtuquajtur skedar header. Dhe në atë fotografi u themi javën e kaluar se printf është quote, mbyll thonjëzat, ka deklaruar? Në çfarë skedë është prototipi i saj? 

Pra, nëse ju kujtohet, gjëja e parë I typed, pothuajse çdo program time-- fundit dhe aksidentalisht një moment më parë ka filluar shtypja myself-- ishte kjo here-- hash-- # Include <stio-- për input / output-- dot h Dhe me të vërtetë, në qoftë se unë tani ruani këtë fotografi, unë jam duke shkuar të shkojnë përpara dhe të qartë ekranin tim, të cilat ju mund të bëni duke shtypur Qartë, ose ju mund të mbajë Kontrollit L, vetëm për të pastruar dritaren tuaj terminali vetëm për të eliminuar disa rrëmujë. 

Unë jam duke shkuar për të shkuar përpara dhe të ri-lloj make buggy0, Enter. Dhe voila, unë ende të shihni se Komanda gjatë nga tingëllimë, por nuk ka asnjë mesazh gabimi këtë herë. Dhe me të vërtetë, në qoftë se unë bëj ./buggy0, ashtu si herën e fundit, ku dot të thotë kjo Lista, Slash thjesht do të thotë, këtu vjen emri i programit dhe se emri i programit është buggy0, Enter, "hello, botën." 

Tani, se si mund të keni mbledhur këtë zgjidhje pa domosdoshmërisht duke njohur sa më shumë fjalë si unë, me siguri, duke pasur bërë këtë për kaq shumë vite? E pra, të realizuar në problemin e parë set, ne ju prezantoj me një komandë që stafin e vet CS50 e shkroi quajtur help50. Dhe me të vërtetë, C nuk specifikimet për problemi të vendosur se si të përdorin këtë. 

Por help50 është në thelb një program që stafi CS50-së ju ka shkruajtur që lejon për të drejtuar një komandë ose të drejtuar një program, dhe në qoftë se ju nuk e kuptoni e saj prodhimit, për të kaluar prodhimin e saj të help50, në të cilën pikë software që stafi kursit të shkruar do të shikojmë në prodhim programit tuaj rresht pas rreshti, karakter nga karakteri. Dhe në qoftë se ne, stafi, njohin mesazh gabimi që ju jeni duke përjetuar, ne do të përpiqemi për të provokuar ju me disa pyetje retorike, me disa këshilla, shumë si një TF ose AK ose veten time do të bëjë personalisht në orarit të punës. 

Kështu që shikoni për help50 në qoftë se ju nuk e bëni domosdoshmërisht të njohin një problem. Por nuk do të mbështetet në atë shumë si një shtrat. Sigurisht përpiqet për të kuptuar e saj Prodhimi dhe pastaj të mësojnë prej saj kështu që vetëm një herë ose dy herë bëni ju ndonjëherë të kandidojë help50 për një gabim të caktuar Mesazhi. Pas kësaj, ju duhet të jetë pajisur më mirë veten të kuptoj se çfarë në të vërtetë është. 

Le të bëjmë një tjetër këtu. Më lejoni të shkojnë përpara, dhe në një tjetër Dosja ne do të thërrasë këtë buggy1.c. Dhe në këtë skedë Jam do të deliberately-- por pretendojë se unë nuk kuptuar se çfarë gabimi kam bërë. 

Unë jam duke shkuar për të shkuar përpara dhe të bëjë this-- #include, pasi që unë kam mësuar mësimin tim nga një moment më parë. Int main (void), si më parë. Dhe pastaj në këtu unë jam duke shkuar për të bërë s string - get_string. Dhe kujtoni nga hera e fundit që kjo do të thotë, hej, kompjuter, më jepni një ndryshore, thirrje ajo s, dhe të bëjë llojin e kësaj variable një varg kështu që unë mund të ruajë një ose më shumë fjalë në të. 

Dhe pastaj në të djathtë anë e shenjë të barabartë është get_string, i cili është Funksioni në Bibliotekën CS50 që bën pikërisht këtë. Ajo merr një funksion dhe pastaj Duart e saj nga djathta në të majtë. Pra, kjo shenjë të barabartë nuk do të thotë "Barabartë" si ne mund të mendojmë në matematikë. Kjo do të thotë detyrë nga djathta në të majtë. Pra kjo do të thotë, të marrë varg nga përdoruesi dhe ruajtur atë brenda s. 

Tani le të përdorin atë. Më lejoni të shkojnë përpara dhe tani si një të dytë line, më lejoni të shkoj përpara dhe të thonë "hello" - jo "botën", por "hello,% s-- e cila është placeholder ynë, presje s, e cila është e ndryshueshme ynë, dhe pastaj një gjysmë-zorrës së trashë. Pra, nëse unë nuk e vidhos deri shumë këtu, kjo duket si kod të saktë. 

Dhe instinktet e mia tani janë për të hartuar atë. Dosja është quajtur buggy1.c. Kështu që unë jam duke shkuar për të bërë të buggy1, Enter. Dhe mallkuar-it, nëse nuk ka edhe gabime më shumë se më parë. Unë do të thotë, ka më shumë mesazhet e gabimit kjo do të duket se linja aktuale në këtë program. 

Por takeaway këtu është, edhe në qoftë se ju jeni të tronditur me dy ose tre ose katër mesazhet e gabimit më shumë, përqëndrohet gjithmonë në shumë e parë e këtyre mesazheve. Duke parë në krye-më një, Scroll mbrapa si duhet të jetë. Kështu që këtu unë shtypur make buggy1. Ja se prodhimi tingëllimë siç pritet. 

Dhe këtu është gabimi i parë i kuq. Përdorimi i identifikues padeklaruar string, nuk dua të them standarde në? Pra, në standarde është në fakt diçka tjetër. Ajo i referohet përdoruesit e keyboard, në thelb. 

Por kjo nuk është ajo që unë do të thotë. Unë do të thotë varg, dhe unë do të thotë get_string. Pra, çfarë është ajo që unë harruar për të bërë këtë herë? Çfarë është zhdukur këtë kohë? Unë kam #include tim, kështu që unë kam qasje në printf. 

Por ajo që nuk kam qasje në vetëm ende? E pra, ashtu si herën e fundit, Unë kam nevojë për të të treguar përpiluesit Tingëllimë që këto funksione janë. Get_string nuk vjen me C. Dhe në veçanti, atë nuk vjen në header fotografi,. Ajo në vend vjen në diçka që stafi ka shkruar, e cila është një fotografi e ndryshme emrin por quajtur me vend. 

Pra, thjesht duke shtuar se një rresht e kujtojnë code-- nga hera e fundit se kur tingëllimë shkon, ajo do për të parë në krye tim kodin e deri në fund, majta në të djathtë. Ajo do të vini re, oh, ju dëshironi. Më lër të shkoj dhe për të gjetur atë, ku ajo është në server, kopjoni dhe ngjisni atë, në thelb, në krye të dosjes tuaj në mënyrë që në këtë pikë në histori, Linja 1, pjesa tjetër e programit mund, në fakt, të përdorni ndonjë nga funksionet aty, në mesin e tyre get_string. Kështu që unë jam duke shkuar për të injorojë pjesa tjetër e këtyre gabimeve, sepse unë, me të vërtetë, dyshoj se vetëm e para në fakt rëndësi. Dhe unë jam duke shkuar për të shkuar përpara dhe përsëritje, pas kursimit dosjen time të buggy1. Dhe voila, ajo e bëri punën. Dhe në qoftë se unë bëj ./buggy1 dhe shtypni, për shembull, Zamyla, unë tani do të merrni hello, Zamyla, në vend të hello, bota. 

Në rregull. Kështu takeaways këtu, atëherë do të, një, të përpiqet për të grumbulloj pak nga pak sa më shumë si ju mund të nga mesazhet e gabimeve vetëm, duke kërkuar në disa nga fjalët e njohura. Me përjashtim të kësaj, përdorni help50 per problemi vendosur specifikim. Por veç kësaj, gjithashtu, gjithmonë të shikoni me humbje të lartë të vetëm të paktën fillimisht, për të parë se çfarë informacioni ai në fakt mund të japin. Por kjo rezulton se ka edhe më shumë funksionalitetin e ndërtuar në Bibliotekën CS50 për të ndihmuar që në fillim të semestrit dhe më herët në programimin kuptoj se çfarë po ndodh gabuar. Pra, le të bëjmë një shembull tjetër këtu. Unë jam duke shkuar për të thirrur këtë buggy2, e cila, përsëri, do të jetë me të meta jashtë e portës, me dizajn. 

Dhe unë jam duke shkuar për të shkuar përpara dhe të bëjë #include. Dhe atëherë unë jam duke shkuar për të bërë int kryesor (i pavlefshëm). Dhe atëherë unë jam duke shkuar për të bërë një për lak. Për (int i _ 0. i është më pak se ose te barabarte me 10. i ++, dhe më pas në formatimin e teksteve kaçurrel, unë jam duke shkuar të shtypura nga vetëm një simbol hashtag këtu dhe një karakter të ri linjë. 

Pra qëllimit tim me këtë Programi është mjaft e thjesht të iterate 10 herë dhe në çdo përsëritje e atij lak çdo kohë përmes ciklit, shtypura nga një hashtag, një hashtag, një hashtag. Një linjë për shkak se unë të kenë linjë të re atje. Dhe kujtoj se për loop, per week-- fundit dhe ju do të merrni më shumë njohur me sintaksë duke e përdorur atë me praktikën para long-- kjo i jep më një variabël i kërkova dhe vendos atë në 0. 

Kjo increments I në çdo përsëritje nga 1. Kaq i shkon me 1 deri në 2 deri 3. Dhe pastaj ky kusht në mesme mes gjysmë-colons merr kontrolluar në çdo përsëritje të bërë i sigurt se ne jemi ende brenda rrezes. Kështu që unë dua të iterate 10 herë, kështu që unë kanë lloj shumë intuitive vetëm vënë 10 si të lidhur ime sipërme atje. 

Dhe akoma, kur kam drejtuar këtë, pasi hartimin atë me make buggy2-- dhe kjo do të hartojnë OK. Kështu që unë nuk kanë një gabim sintakse këtë herë. Më lejoni të shkojnë përpara tani dhe të drejtuar buggy2, Enter. Dhe tani lëvizni lart. Dhe më lejoni të rritet madhësia e dritares. 

I duket të kenë 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Pra, ka 11 hashtags, edhe pse I qartë vënë 10 brenda këtij lak. Tani, disa nga ju mund të shihni menjëherë ajo që është gabim, sepse, në të vërtetë, kjo nuk është një gabim shumë e vështirë për të bërë. Por është shumë i zakonshëm bërë shumë më herët. 

Ajo që unë dua të theksoj, edhe pse, po, si mund unë kuptoj këtë? E pra, ajo rezulton se Biblioteka CS50 vjen me jo vetëm get_string dhe get_int dhe get_float dhe funksionet e tjera. Ajo gjithashtu vjen me një funksion të veçantë quajtur eprintf, ose, gabim printf. Dhe ajo ekziston vetëm për të bërë atë një pak më e lehtë për ju kur debugging kodin tuaj të vetëm të shkruar një mesazh gabimi në ekran dhe e di se ku ajo erdhi nga. 

Kështu për shembull, një gjë unë mund të bëjmë këtu me këtë funksion është this-- eprintf, dhe atëherë unë jam duke shkuar për të shkuar përpara dhe thonë se i tani është% i, backslash, n. Dhe unë jam duke shkuar për të plug në vlerën e i. Dhe deri të lartë, sepse kjo është në Bibliotekën CS50, Unë jam duke shkuar për të shkuar përpara dhe përfshijnë kështu që unë kam qasje në këtë funksion. Por le të marrin në konsideratë se çfarë linjë 9 është menduar të jetë bërë. Unë jam duke shkuar për të fshirë këtë përfundimisht. Kjo nuk ka të bëjë me qëllimin tim gjithëpërfshirës. Por eprintf, gabimi printf, është vetëm të thotë të më jepni disa informacione diagnostik. Kur kam drejtuar programin tim, unë dua të shohin këtë në ekran përkohësisht si dhe vetëm për të kuptuar çfarë po ndodh. 

Dhe, në të vërtetë, në secilën përsëritje këtu e linjës 9 Unë dua të shoh, se çfarë është vlera e i? Cila është vlera e i? Cila është vlera e i? Dhe, me shpresë, unë duhet vetëm shihni këtë mesazh, gjithashtu, 10 herë. 

Pra më lejoni të shkoj përpara dhe të përpiluar programin tim, si unë duhet të bëni çdo kohë Unë të bëjë një ndryshim. ./buggy2. Dhe now-- OK. Ka shumë më tepër në vazhdim e sipër. Pra më lejoni të lëvizni lart në një dritare edhe më të mëdha. 

Dhe ju do të shihni se, secila nga hashtags është ende shtypjen. Por në mes njëri prej tyre është tani kjo prodhimit diagnostike formatuar si më poshtë. Emri i programit tim këtu është buggy2. Emri i skedarit është buggy2.c. Numri linjës nga i cili kjo është shtypur është linjë 9. Dhe pastaj në të djathtë e që është mesazh gabimi që unë jam duke pritur. 

Dhe çfarë është e mirë për këtë është se tani unë nuk kam për të numëruar domosdoshmërisht në kokën time se çfarë programi im është duke bërë. Unë mund të shoh se nga ana përsëritje të parë i është 0, atëherë 1, pastaj 2, pastaj 3, pastaj 4, pastaj 5, pra 6, pastaj 7, pastaj 8, pastaj 9, atëherë 10. Pra, prit një minutë. Cfare po ndodh ketu? Unë ende duket të jenë numëruar si qëllim deri ne 10. 

Por kur kam filluar? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Kështu 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- gishti 11 është tregues i problemit. Unë duket se kanë numëruar gabimisht në lak tim. Në vend se të shkojnë 10 përsëritjeve, Unë jam duke filluar në 0, Unë jam duke i dhënë fund në dhe përmes 10. Por për shkak se, si një kompjuter, Unë jam duke filluar numërimin në 0, I duhen numëruar deri për të, por jo me, 10. 

Dhe kështu fix, unë përfundimisht realizuar këtu, është një nga dy gjëra. I shumë thjesht mund të them numëruar deri në më pak se 10. Kështu 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, e cila është, me të vërtetë, i saktë, edhe pse kjo tingëllon një gabim të vogël. Ose unë mund të bëj më pak se ose e barabartë në 9, për sa kohë që unë të fillojë në 0. Ose në qoftë se ju me të vërtetë nuk e pëlqen atë, ju mund të llogarisë deri me 10, por të fillojë në 1. Por përsëri, kjo thjesht nuk është se e zakonshme. Në programming-- megjithëse jo aq shumë në Scratch-- por në programimin në C dhe gjuhë të tjera, si dhe JavaScript Python dhe të tjerët, është e vetëm shumë e zakonshme për Diskutimi ynë i binary të vetëm të fillojë numërimi në nivel Numri më i ulët ju mund të, e cila është 0. Në rregull. Pra, kjo është eprintf. Dhe përsëri, tani që unë kam realizuar artistikisht tim problem, dhe unë jam duke shkuar për të shkuar mbrapa në 0 me më pak se 10, unë jam duke shkuar për të shkuar në dhe të fshini eprintf. 

Ajo nuk duhet të jetë atje, kur unë anije kodin tim ose të dorëzojë kodin tim ose të tregojë atë për të gjithë të tjerët. Është me të vërtetë vetëm për qëllim për t'u përdorur perkohesisht. Por tani unë kam fiksuar këtë problem i veçantë si. 

E pra, le të bëjmë një shembull më shumë këtu se unë jam duke shkuar për të nxitur si më poshtë. Unë jam duke shkuar për të shkuar përpara dhe të #include. $ 50 Dhe unë jam duke shkuar për të shkuar përpara dhe #include. 

Dhe unë jam duke shkuar për të shpëtuar kjo skedë si buggy3.c. Dhe unë jam duke shkuar për të shkuar përpara dhe të deklarojë int kryesor (i pavlefshëm). Dhe pastaj brenda ka Unë jam duke shkuar për të bërë int i _ - Unë dua për të zbatuar një program me një get_negative_int. Kjo nuk është një funksion që ekziston ende. Pra, ne jemi duke shkuar për të zbatuar në një moment të vetëm. Por, ne jemi duke shkuar për të parë pse kjo është buggy në pasim të parë. Dhe një herë unë kam marrë një int nga përdoruesi, Unë jam vetëm duke shkuar për të shtypur% i është negative integer, backslash, n, comma, i. Me fjalë të tjera, të gjitha unë duan këtë program për të bërë është marrë një int negativ nga përdoruesit dhe pastaj të shtypura nga se filan është një int negative. 

Tani kam nevojë për të zbatuar këtë funksion. Pra, më vonë në dosjen time, unë jam duke shkuar për të shkuar përpara dhe të deklarojë një funksion të quajtur get_negative_int (void) - dhe ne do të të kthehen në atë që vijë të thotë përsëri në një moment-- int n; do-- bëni following-- printf n është :. Dhe atëherë unë jam duke shkuar për të bërë n - get_int, dhe e bëjnë këtë, ndërsa n është më e madhe se 0. Dhe pastaj të kthehen n ;. 

Pra, nuk është një shumë në vazhdim e sipër në këtë, por asnjë nga të cilat ne nuk kemi shikoni në javën e kaluar, të paktën për pak kohë. Pra, në linjë 10 këtu e kam deklaruar një Funksioni i quajtur get_negative_int, dhe unë kam vënë (i pavlefshëm), në kllapa, arsyeja është kjo nuk merr një të dhënë. Unë nuk jam duke kaluar asgjë për këtë funksion. Unë jam vetëm duke marrë diçka prapa. 

Dhe çfarë unë jam duke shpresuar për të marrë përsëri është një numër të plotë. Nuk ka asnjë lloj të dhënave në C quajtur negative_int. Kjo është vetëm int, kështu që ajo do të jetë mbi ne për të siguruar se vlera që është në të vërtetë i kthyer nuk është vetëm një int por edhe negative. 

On line 12 Unë jam deklaruar një ndryshore quajtur n dhe duke e bërë atë të tipit int. Dhe pastaj në linjë 13 deri 18 jam duke bërë diçka, ndërsa diçka është e vërtetë. Unë jam duke shkuar përpara dhe shtypje n është, zorrës së trashë, dhe pastaj një hapësirë, si një të shpejtë për përdoruesit. 

Unë pastaj duke e quajtur get_int dhe ruajtjen ashtuquajturën vlerën e saj të kthimit në atë të ndryshueshme n. Por unë do të vazhdojmë të bëjmë kjo ndërsa n është më i madh se 0. Me fjalë të tjera, në qoftë se përdoruesi më jep një int dhe se numri është më i madh se 0, ergo, pozitive, unë jam duke shkuar për të vetëm i mbajnë reprompting përdoruesit, mbajtur reprompting, duke i detyruar ata që të bashkëpunojnë dhe të më jepni një int negativ. 

Dhe një herë n fakt është negative-- mendoj përdorues në fund lloje -50, atëherë kjo loop, ndërsa nuk është e vërtetë pasi -50 nuk është më i madh se 0. Pra, ne të thyer nga të cilat loop logjikisht dhe të kthehet n. 

Por ka një tjetër gjë që unë duhet të bëni. Dhe unë thjesht mund ta bëjë këtë nga kopjimi dhe pasting një linjë e kodit në krye të file. Unë kam nevojë për të mësuar tingëllimë, ose premtim për tingëllimë, në mënyrë të qartë që unë do të, në të vërtetë, shkoni dhe të zbatojë kjo get_negative_int funksion. Ajo vetëm mund të jetë më e ulët në dosje. Përsëri, kujtojmë se tingëllimë lexon gjëra të lartë e deri në fund, majta në të djathtë, kështu që ju nuk mund të thërrasë një funksion nëse tingëllimë nuk e di se do të ekzistojë. 

Tani, për fat të keq, ky program, si disa nga ju mund të keni vënë re, tashmë është buggy. Më lejoni të shkojnë përpara dhe të bëjë buggy3. Harton, kështu që problemi im tani nuk është ndonjë gabim sintakse, si një gabim tekstuale, kjo është në të vërtetë do të jetë një logjike gabim që unë kam qëllim bërë si një mundësi për të hap me atë që po ndodh. 

Unë jam duke shkuar për të shkuar përpara tani dhe drejtuar buggy3. Dhe unë jam duke shkuar për të shkuar përpara dhe të mos bashkëpunojnë. Unë jam duke shkuar për të dhënë atë numrin 1. Ajo nuk e pëlqen atë, kështu që ajo është bërë më përsëri. 

Si rreth 2? 3? 50? Asnjë nga ata që janë duke punuar. Si në lidhje me -50? Dhe programi duket për të punuar. 

Më lejoni të provoni edhe një herë. Më lejoni të provoni -1, duket për të punuar. Më lejoni të provoni -2, duket për të punuar. Më lejoni të provoni 0. Huh, kjo është e gabuar. Tani, ne jemi duke qenë pak pedant këtu. Por kjo është, në të vërtetë, rasti se 0 nuk është as pozitive, as negative. Dhe kështu fakti që programi im është i duke thënë se 0 është një numër i plotë negativ, kjo nuk është teknikisht të saktë. 

Tani, pse është bërë kjo? E pra, ajo mund të jetë e qartë. Dhe, me të vërtetë, programi është për qëllim të jetë mjaft e thjeshtë kështu që ne kemi diçka për të eksploruar. 

Por le të futur një debugging të tretë Teknika këtu quhet debug50. Pra, ky është një program që ne kemi krijuar vetëm këtë vit e quajti debug50 që do të ju lejojnë të përdorin atë që quhet një ndërtuar-në Rregullues grafike në CS50 IDE. Dhe një Rregullues është vetëm një program që në përgjithësi ju lejon të drejtuar programin tuaj por hap pas hap pas hapi, linjë nga rresht pas rreshti, duke pushuar, poking rreth, duke kërkuar në variablat që programi nuk ka vetëm goditje e kaluara ju dhe shpejt shkruar diçka apo jo shkruar diçka. Kjo ju jep një mundësi, në Shpejtësia e njeriut, për të bashkëvepruar me të. 

Dhe për të bërë këtë, ju thjesht të bëjë të mëposhtme. Pas hartimin kodin tuaj, të cilën unë tashmë e bëri, buggy3, të shkojnë përpara dhe të drejtuar debug50 ./buggy. Aq shumë si help50 ka ju drejtuar help50 dhe pastaj komanda, debug50 ka ju drejtuar debug50 dhe atëherë emri i komandës. 

Tani shikojnë se çfarë ndodh në ekran e mia, në anën e djathtë në veçanti. Kur kam goditur Run, të gjitha të papritur panel kjo djathtë hap në ekran. Dhe ka shumë ndodh në në shikim të parë. Por nuk është shumë e shumë për t'u shqetësuar rreth ende. 

Kjo tregon mua çdo gjë që po ndodh brenda programin tim tani dhe me anë të këtyre buttons up top është atëherë duke lejuar mua për të hap deri kodin tim në fund të fundit hap pas hap pas hapi. Por jo vetëm ende. Vini re se çfarë ndodh. Në dritaren time terminal Unë jam duke u nxitur për n. Dhe unë jam duke shkuar për të shkuar përpara dhe bashkëpunuar këtë herë dhe shkruani -1. Dhe megjithëse pak cryptically, -1 është një numër i plotë negative, siç pritej. 

Dhe pastaj fëmija doli me Statusi 0 GDBserver daljes. GDB, GNU Debugger, është emri e software themelor që zbaton këtë Rregullues. Por e gjithë kjo do të thotë me të vërtetë, Rregullues u largua për shkak se programi im të lë dhe të gjitha ishte mirë. Nëse unë dua të të vërtetë të korrigjoj programin tim, Unë duhet të them preemptively debug50, ku mund të duan të fillojnë shkelën me kodin tim? 

Dhe ndoshta mënyra më e thjeshtë për të bërë këtë është si më poshtë. Nëse unë rri pezull mbi të hendek i redaktor tim këtu, kështu që me të vërtetë vetëm në sidebar këtu, në të majtë të numrit të linjës, Vini re se në qoftë se unë vetëm të klikoni një herë, kam vënë një pikë të vogël të kuqe. Dhe se dot të vogël të kuqe, si një shenjë të ndaluar, do të thotë, hej, debug50, ekzekutimi pauzë të kodit tim ka të drejtë kur kam drejtuar këtë program. 

Pra, le ta bëjmë këtë. Më lejoni të shkojnë përpara dhe të drejtuar programin tim përsëri me debug50 ./buggy3, Enter. Dhe tani, njoftim, diçka ndryshe ka ndodhur. Unë nuk jam duke u nxitur por në dritaren time terminal për çdo gjë, sepse nuk kanë marrë ende atje në programin tim. Vini re se në linjë 8 e cila është theksuar tashmë, dhe ka një shigjetë pak në duke thënë majtë, ju jeni të ndaluar këtu. Kjo linjë e kodit, linjë 8, nuk është ekzekutuar ende. 

Dhe çfarë është kurioz, nëse unë shoh mbi këtu në anën e djathtë, vini re se i është një lokal ndryshueshme, lokale në kuptimin se është brenda funksionit aktual. Dhe vlera e tij, me sa duket nga default, dhe lloj të përshtatshme, është 0. Por unë nuk e tipit 0. Që vetëm ndodh të jetë e saj Vlera e parazgjedhur në këtë moment. 

Pra më lejoni të shkoj përpara dhe të bëjë këtë tani. Më lejoni të shkojnë përpara dhe të të lartë të drejtë këtu, unë jam i do të shkojnë përpara dhe të klikoni këtë ikonë parë që do të thotë hap mbi të cilin do të thotë mos kaloni ajo po hap mbi këtë linjë të kodit, ekzekutimin e tij gjatë rrugës. 

Dhe tani, vini re, my shpejtë ka ndryshuar vetëm. Pse eshte ajo? Unë e kam thënë debug50, drejtuar këtë linjë të kodit. Çfarë e bën këtë linjë e kodit të bëjë? Bën mua për një int. NE RREGULL. Më lejoni të bashkëpunojnë. Më lejoni të shkojnë përpara dhe tani shkruani -1, Enter. Dhe tani vini re se çfarë ka ndryshuar. Në anën e djathtë, variabël lokale im i tregohet si -1 tani. Dhe kjo është ende e tipit int. 

Dhe vini re, gjithashtu, my ashtuquajturi quajnë rafte, ku e kam pushim? Ne do të flasim më shumë për këtë në të ardhmen. Por thirrja rafte vetëm i referohet asaj që Funksionet janë aktualisht në lëvizje. Tani për tani kjo është vetëm kryesor. Dhe tani vetëm Lokale variabël është i me një vlerë prej 1. 

Dhe kur më në fund hap mbi këtë linjë këtu, me të njëjtën ikonë në krye të drejtë, -1 Është një numër i plotë negativ. Tani ajo është duke pushuar mbi këtë mbajtëse kaçurrel. Le të le të bëjë gjë e saj. I hap mbi këtë linjë, dhe voila. 

Pra, jo të gjithë që tmerrësisht shkolluar ende, por ajo nuk më lejoni të bëj një pauzë dhe mendoj se përmes logjikisht çfarë ky program është duke bërë. Por kjo nuk ishte rasti i gabuar. Le ta bëjmë këtë përsëri si më poshtë. 

Unë jam duke shkuar për të lënë atë breakpoint on line 8 me të kuqe dot. Unë jam duke shkuar për përsëritje debug50. Është e ndaluar automatikisht këtu. Por këtë herë, në vend të shkelën mbi këtë linjë, më lejoni në fakt shkojnë në brendësi të get_negative_int dhe të kuptoj se, pse është pranuar 0 si një përgjigje të vlefshme? 

Pra, në vend të klikuar Hapi Over. Unë jam duke shkuar për të shkuar përpara dhe klikoni hap në. Dhe vini re se linja 8 kjo është tani theksuar tani papritmas bëhet e linjës 17. 

Tani, nuk është se Rregullues ka skipped linjat 14 dhe 15 dhe 16. Kjo është vetëm nuk ka asgjë për të treguar atje. Ata janë vetëm duke deklaruar variablave, dhe pastaj nuk është fjala A dhe pastaj një mbajtëse të hapur kaçurrel. E vetmja Linja funksionale që është lëng të vërtetë është kjo këtu, 17. Dhe kjo është ajo ku ne kemi ndaluar automatikisht. 

Pra printf ( "n.is:") ;, kështu që ende nuk ka ndodhur. Pra, le të shkojnë përpara dhe klikoni Hapi Over. Tani të shpejtë im, me të vërtetë, ndryshuar në ( "n është:"). Tani get_int, unë nuk jam duke shkuar të shqetësojë shkelën në, për shkak se funksioni i bërë nga CS50 në Bibliotekën. Kjo është me sa duket e saktë. 

Kështu që unë jam duke shkuar për të shkuar përpara dhe lloj të bashkëpunojnë duke i dhënë atë një int, por jo një int negative. Pra më lejoni të shkoj përpara dhe e goditi 0. Dhe tani çfarë ndodh këtu kur unë të marrë poshtë për të vijë 21? Unë nuk e kam përsëritur edhe një herë. Unë nuk duket të jenë të mbërthyer në atë lak. Me fjalë të tjera, kjo verdhë bar nuk do të mbajë rreth, dhe rreth, dhe rreth. 

Tani, pse është kjo? E pra, n, çfarë n tani? Unë mund të shikoni në lokal Variablat në Rregullues. n është 0. Të gjithë të drejtë, çfarë ishte gjendja ime? 

20-- linja 20 është, gjithashtu, 0 është më i madh se 0. Kjo nuk është e vërtetë. 0 nuk është më i madh se 0. Dhe kështu shpërtheu këtë. 

Dhe kështu kjo është arsyeja pse në linjë 21, në qoftë se unë në fakt të vazhdojë, Unë do të kthehen 0, edhe edhe pse unë duhet të ketë refuzuar 0 pasi në të vërtetë nuk qenë negative. Deri tani, unë nuk të vërtetë edhe intereson Rregullues. Got atë, unë nuk kam nevojë për të e di se çfarë më tepër po ndodh. 

Kështu që unë jam duke shkuar për të shkuar përpara dhe vetëm klikoni butonin Play, dhe le të këtë përfundojë deri. Tani, unë e kam kuptuar se my bug është me sa duket në linjë 20. Ky është gabimi im logjik. 

Dhe kështu që ajo që unë dua për të bërë për të ndryshuar këtë? Nëse problemi është se unë nuk jam infektues 0, kjo është vetëm një gabim logjik. Dhe unë mund të them, ndërsa n është më e madhe se ose e barabartë me 0, mbani duke bërë që përdoruesit përsëri dhe përsëri. 

Pra, përsëri, gabim i thjeshtë, ndoshta edhe e qartë kur më pa shkruar atë vetëm pak minuta më parë. Por takeaway këtu është se me debug 50, dhe me debugging software në përgjithësi, ju e keni këtë fuqi të re që gjendet në ecin nëpër kodin tuaj, shikojeni nëpërmjet këtij paneli të dorës së djathtë që variablat vlerat tuaja. Pra, ju nuk domosdoshmërisht duhet të përdorin diçka si ju eprintf për të shkruar këto vlera. Ju në fakt mund të shihni ato vizualisht në ekran. 

Tani, përtej kësaj, ia vlen të përmendet se ka një tjetër teknikë që është e në fakt super të përbashkët. Dhe ju mund të pyes veten pse kjo pak guy këtu ka qenë i ulur në skenë. Pra, nuk është kjo teknikë, në përgjithësi i njohur si gome duck debugging, e cila me të vërtetë është vetëm një testament për faktin që shpesh kur programuesit janë shkruar kodin, ata nuk janë domosdoshmërisht bashkëpunim me të tjerët, ose duke punuar në një mjedis të përbashkët. 

Ata janë lloj në shtëpi. Ndoshta kjo është natën vonë. Ata janë duke u përpjekur të kuptoj nga një bug në kodin e tyre. Dhe ata janë jo vetëm duke parë atë. 

Dhe nuk ka shokun. Nuk ka TF. Nuk ka CA rreth. Të gjithë ata kanë në shelfin e tyre është kjo Ducky vogël gome. 

Dhe kështu debugging duck gome është vetëm kjo ftesë të mendoj për diçka si pa kuptim pasi kjo si një krijesë e vërtetë, dhe në fakt ecin nëpër kodin tuaj me gojë për këtë objekt pajetë. Kështu, për shembull, në qoftë se ky është shembulli im here-- dhe kujtojmë se më herët problemi ishte kjo, në qoftë se unë të fshini këtë linjë të parë të kodit, dhe unë të shkojnë përpara dhe të bëjë buggy 0 përsëri, kujtojnë se kam pasur këto mesazhet e gabimit këtu. Pra, ideja këtu, qesharake edhe pse unë të ndjehen në momentin bërë këtë publikisht, është se gabim. 

OK, kështu që problemi im është se unë kam implicite deklaroi një funksion të bibliotekës. Dhe se funksioni i bibliotekës është printf. Declare-- OK, mund të deklarojë më kujton prototipa. 

Kjo do të thotë unë duhet të vërtetë tregoni përpiluesit më parë se çfarë funksioni duket si. Prit një minutë. Unë nuk kanë io.h. standarde Faleminderit shumë. 

Pra, vetëm ky proces of-- ju nuk duhet të vërtetë kanë një rosë. Por kjo ide e këmbë veten nëpërmjet kodit tuaj në mënyrë që edhe ju të dëgjoni veten, në mënyrë që ju realizuar lëshime në tuaj Vërejtjet, në përgjithësi është ideja. 

Dhe, ndoshta më logjikisht, jo aq shumë me se një, por më shumë i përfshirë Shembulli ne vetëm e bëri në 3.c buggy, ju mund të ecin nëpër atë veten si në vazhdim. Pra, të gjithë të drejtë, gome zogëz, DDB, nëse ju do. Këtu kemi në funksion tim kryesor, Unë jam duke e quajtur të int negative. 

Dhe unë jam duke marrë vlerën e kthimit. Unë jam ruajtjen atë në anën e majtë on line 8 në një variabël të quajtur i. OK, por të presim, si e bëri që të marrë këtë vlerë? Më lejoni të shikoni në funksion në linjë 12. 

Në linjë 12, ne kemi marrë int negative. A nuk merrni ndonjë inputeve, kthen një int, OK. Unë deklaroj on line 14 a n ndryshueshme. Ajo do të ruajë një numër të plotë. Kjo është ajo që unë dua. 

Pra, të bëjë të mëposhtme, ndërsa n is-- le me të ndrequr atë që fix kam bërë tashmë. Kështu ndërsa n eshte me e madhe se 0, të shtypura nga n është, OK. Dhe pastaj e quajnë të ruhet int në n. Dhe pastaj kontrolluar nëse n është 0, n është not-- nuk është. Pra, përsëri, ju nuk e bëni duhet duck aktuale. Por vetëm në këmbë veten me Kodi juaj si një ushtrim intelektual shpesh do të ju ndihmojë kuptojnë se çfarë po ndodh, në krahasim me vetëm duke bërë diçka si kjo, ndezur në ekran, dhe jo duke folur me veten ai, i cili sinqerisht nuk është gati si një teknikë efektive. Pra, nuk keni atë, një Numri i teknikave të ndryshme për të vërtetë debugging kodin tuaj dhe qortuar, të cilat duhet të jenë mjete në veglën tuaj në mënyrë që ju nuk jeni natën vonë, sidomos, ju jeni në ngrënie salla, ose të orarit të punës, banging kokën tuaj kundër mur, duke u përpjekur për të zgjidhur disa probleme. Të kuptojë se ka mjete software. Nuk janë mjete rosë gome. Dhe ka një staf të tërë të mbështetur në pritje të japë një dorë. 

Deri tani, një fjalë në problemin grupe, dhe në atë që ne jemi duke shpresuar të të marrë prej tyre, dhe si ne do të shkojmë në lidhje me vlerësimin. Per planin mësimor të kursit, grupe problematike CS50-së janë vlerësuar në katër akset kryesore, kështu që të speak-- qëllimin, korrektësia, dizajn, dhe stil. Dhe qëllimin vetëm i referohet sa e copë keni kafshuar off? Sa shumë e një problemi keni provuar? Çfarë niveli i përpjekjeve keni manifestuar? 

Korrektësia është, e bën punën e programit si është menduar për të sipas specifikimeve CS50 kur ju ofrojnë informata të caktuara ose rezultate të caktuara të vijnë? Dizajni është më subjektiv i tyre. Dhe kjo është ajo që do të të marrë më të gjatë për të mësuar dhe të gjatë për të mësuar, në aq sa boils poshtë për të, sa mirë e shkruar është kodi juaj? 

Kjo është një gjë për të shkruar vetëm e saktë Rezultatet ose kthimin e vlerave të vërteta. Por jeni duke bërë atë si me efikasitet të jetë e mundur? A jeni duke bërë atë ndarje dhe të pushtuar, ose binary kërkim si ne së shpejti do të shihni se ne e bëmë dy javë më parë me librin e telefonit? A ka mënyra më të mira për të zgjidhur Problemi se ju tashmë keni këtu? Kjo është një mundësi për dizajnin më të mirë. 

Dhe pastaj style-- si mjaft është kodi juaj? Ju do të vëreni se unë jam goxha të veçantë në lidhje indenting kodin tim, dhe duke u siguruar variablave mia janë quajtur të arsyeshme. n, ndërkohë të shkurtër, është një emër i mirë për një numrin, i për një numër të plotë të numërimit, s për një varg. Dhe ne mund të kemi më emrat e ndryshueshme style. Style është vetëm si e mirë duket kodin tuaj? Dhe si i lexueshëm është ajo? 

Dhe me kalimin e kohës, çfarë tas tuaj dhe NGP do të bëjë gjatë është t'ju ofrojë me atë lloj feedback cilësor në mënyrë që ju të merrni më të mirë në ato aspekte të ndryshme. Dhe për sa i përket se si ne vlerësojë secili prej këtyre akseve, kjo është në mënyrë tipike me shumë pak kova në mënyrë që ju, në përgjithësi, marrë një kuptim të se sa mirë jeni duke bërë. Dhe, me të vërtetë, në qoftë se ju merrni një rezultat për ndonjë nga ato saktësinë axes--, dizajn dhe stil especially-- se numri i në përgjithësi do të jetë midis 1 dhe 5. Dhe, fjalë për fjalë, në qoftë se ju jeni duke marrë 3-së në fillim të semestrit, kjo është një gjë shumë e mirë. Kjo do të thotë se ka ende vend për përmirësim, të cilat ju do të shpresojnë në duke marrë një klasë për herë të parë. Ka shpresë disa pak e tavanit për të cilën ju jeni që aspirojnë për të arritur. Dhe kështu që duke marrë në 3-së copat më të hershme, nëse jo disa 2-të dhe 4-së, është me të vërtetë një gjë e mirë. Është mirë brenda rrezes, edhe brenda pritshmërive. 

Dhe në qoftë se mendjen tuaj është gara, prisni një minutë, tre nga pesë. Kjo është me të vërtetë një nga 6 10. Kjo është 60%. Perëndia im, kjo është një F. 

Nuk eshte. Kjo nuk është, në fakt, se. Përkundrazi, kjo është një mundësi për të përmirësuar gjatë semestrit. Dhe në qoftë se ju jeni duke marrë disa Poors, këto janë një mundësi për të përfituar nga orarit të punës, sigurisht seksionet dhe burime të tjera. 

Më e mirë është një mundësi, me të vërtetë, të jetë krenar se sa larg ju keni vijnë gjatë semestrit. Pra e kuptojnë, nëse asgjë tjetër, tre është e mirë. Dhe kjo i lejon vend për rritje me kalimin e kohës. 

Se si ato janë akset ponderuar, realisht je do të kalojnë shumicën e kohës tuaj duke gjëra në punë, e lëre më të saktë. Dhe kështu korrektësinë tenton të të ponderuar më, si me ky faktor multiplicative e tre. Dizajni është gjithashtu e rëndësishme, por diçka që ju nuk domosdoshmërisht shpenzojnë të gjitha ato orë në duke u përpjekur për të marrë gjërat e vetëm për të punuar. 

Dhe kështu që është e ponderuar pak më lehtë. Dhe pastaj style është peshuar më pak. Edhe pse kjo nuk është më pak e rëndësishme në thelb, kjo është vetëm, ndoshta, gjë e lehtë për të bërë të drejtë, imituar shembujt që bëni në leksion dhe seksion, me gjëra të bukur prerë, dhe komentoi, dhe kështu me radhë është ndër më të lehtë gjëra për të bërë dhe për të marrë të drejtë. Pra, si e tillë, e kupton se ata janë pika që janë relativisht të lehtë për t'u kuptuar. 

Dhe tani një fjalë të this-- ndershmërinë akademike. Pra, per kursin e plani mësimor, ju do të shihni se kursi ka mjaft bit të gjuhës rreth kësaj. Dhe sigurisht e merr çështjen e Ndershmëria akademike mjaft seriozisht. 

Ne kemi dallimin, për mirë apo për keq, i ka dërguar çdo vit më shumë studentët për masa disiplinore se më çdo tjetër Natyrisht, se unë jam i vetëdijshëm. Kjo nuk është domosdoshmërisht tregues i faktit që nxënësit CS, ose studentë CS50, janë më pak i ndershëm se shokët e klasës tuaj. Por realiteti se në këtë Bota, në mënyrë elektronike, ne vetëm kanë teknologjike do të thotë për zbulimin e kësaj. 

Është e rëndësishme për ne për drejtësi në të gjithë klasën që ne bëjmë zbuluar këtë, dhe për të rritur çështja kur shohim gjërat. Dhe vetëm për të pikturuar një foto, dhe me të vërtetë për të ndihmuar në diçka si kjo lavaman në, Ky është numri i Studentët gjatë 10 viteve të fundit që kanë qenë të përfshirë në disa çështje të tilla të ndershmërisë akademike, me disa 32 studentë nga rënia 2015, e cila do të thotë se ne do të marrë çështje shumë seriozisht. Dhe, në fund të fundit, këto shifra shkruaj, më të fundit, rreth 3%, 4% apo më shumë të klasës. 

Kështu që për shumicën super e studentëve duket se linjat janë të qarta. Por mbani këtë në mendje, sidomos në fund në natën kur duke luftuar me disa zgjidhje për një problem grup, se ka mekanizma për të marrë veten më mirë Mbështetja se ju mund të mendojnë, madje edhe në atë orë. Kuptojnë se kur marrim aplikimet e studentëve, kalojmë krahasoni çdo nënshtrim këtë vit kundër çdo dorëzimit të vitit të kaluar, kundër çdo dorëzimit nga viti 2007, dhe që, duke kërkuar në, si dhe, Kodi depove online, forume diskutimi, vende pune. Dhe e kemi përmendur këtë, me të vërtetë, të gjitha për hir e zbulimin e plotë, se në qoftë se dikush tjetër mund ta gjeni online, me siguri, kështu që mund të kemi kurs. Por, me të vërtetë, fryma e natyrisht boils poshtë të kësaj pike në planin mësimor. Me të vërtetë është vetëm, të jenë të arsyeshme. 

Dhe në qoftë se ne kishim për të përpunuar në të cilat me vetëm një gjuhë pak më shumë, kuptojnë se thelbi i të gjithë Puna që ju të paraqesë në këtë kurs duhet të jenë tuajat. Por brenda kësaj, sigurisht që ka mundësitë dhe inkurajim, dhe vlera pedagogjike, duke iu drejtuar others-- veten time, nga NGP, CAS, e Tas, dhe të tjerët në klasë, për mbështetje, le të vetëm miq dhe roommates të cilët kanë studiuar CS dhe programimi para. Dhe kështu që nuk është një kompensim për këtë. Dhe rregulli i përgjithshëm i gishtit është this-- kur kërkojnë ndihmë, ju mund të tregojnë kodin tuaj për të tjerët, por ju nuk mund të shihni të tyret. Pra, edhe në qoftë se ju jeni në të orarit të punës, ose në sallën D, apo diku tjetër duke punuar në një copë grup, punuar së bashku me një mik, i cili është krejtësisht në rregull, më së fund të ditës së punës tuaj duhet në fund të fundit i përkasin njëri- ju respektivisht, dhe jo të jetë një përpjekje e përbashkët, me përjashtim të projektit final ku është e lejuar dhe inkurajuar. 

Të kuptojë se në qoftë se jeni duke luftuar me diçka dhe shoku juaj vetëm ndodh të jetë më mirë në këtë atëherë ju, ose më mirë në atë problem se ju, ose pak më përpara se ju, kjo është krejtësisht e arsyeshme të kthehet një shoku dhe të thonë, hej, A keni parasysh duke kërkuar në kodin tim këtu, duke ndihmuar me vend që çështja ime? Dhe, me shpresë, në Interesi i vlerës pedagogjike se shoku nuk ka vetëm thonë, oh, e bëjnë këtë, por më tepër, çfarë jeni duke humbur në linjë 6, ose diçka të tillë? Por zgjidhja nuk është për mik të ardhshëm për ju për të thënë, oh, edhe, këtu, më lejoni të tërheq këtë ide, dhe të tregojnë zgjidhje time për ju. Pra, kjo është linja. Ju shfaqur kodin tuaj për të tjerë, por ju nuk mund të të parë të tyret, subjekt tjetër kufizimet në planin mësimor të kursit. 

Kështu që mbani në mend këtë ashtuquajtura klauzolë keqardhje në planin mësimor të kursit, si dhe, se në qoftë se keni kryer një akt që Nuk është e arsyeshme, por ta sjellë atë në vëmendja e krerëve kursit të brenda 72 orëve, sigurisht mund të vendosë sanksione lokale që mund të përfshijnë një pakënaqshëm ose dështuar klasën për punën e paraqitur. Por sigurisht nuk do t'ia referojë rëndësi për veprime të mëtejshme disiplinore, përveç në rastet e veprimeve të përsëritura. Me fjalë të tjera, nëse ju bëni disa stupid, natën sidomos në fund, vendimi që të nesërmen në mëngjes ose dy ditë më vonë, ju zgjoheni dhe të kuptojë, çfarë kam menduar? Ju bëni në CS50 kanë një prizë për fiksimin e atë problem dhe mbajnë deri në atë, në mënyrë që të do të takohen në gjysmë të rrugës dhe të merren me atë në një çështje që është edhe arsimore dhe të vlefshme për ju, por ende ndëshkuese në një farë mënyre. Dhe tani, për të marrë buzë off, kjo. 

[VIDEO rishikim] 

[MUSIC Duke luajtur] 

[END rishikim] DAVID J. Malan: Mirë, ne jemi të kthyer. Dhe tani ne shikojmë në një nga e parë e fushave botën tonë reale në CS50, arti i kriptografisë, arti i dërgimit dhe pranimit Mesazhet sekrete, Encrypted Mesazhet nëse do, që mund të deshifruar vetëm nëse ju keni disa përbërës kyç që dërguesi ka gjithashtu. Pra, për të motivuar këtë ne do të marrin një vështrim në këtë gjë këtu, e cila është një shembull i një unaza sekret decoder që mund të përdoret në mënyrë që të kuptoj atë që një mesazh të fshehtë të vërtetë është. Në fakt, përsëri në ditë në klasën e shkollës, në qoftë se ju ka dërguar ndonjëherë mesazhe sekrete të disa mik apo ndonjë shtypur në klasë, ju mund të keni menduar ju jeni duke u zgjuar nga në copë tuaj të ndryshimit letër, si, A tek B, dhe B te C, dhe C tek D, dhe kështu me radhë. Por ishin në fakt encrypting Informacioni juaj: në qoftë se ajo ishte e vogël pak, nuk ishte e vështirë për mësuesi për të realizuar, mirë, në qoftë se ju vetëm të ndryshojë B në A dhe C në B, në të vërtetë ju kuptoj çfarë mesazhi ishte, por ju keni qenë në ciphering informacion. 

Ju keni qenë vetëm duke bërë atë thjesht, ashtu si Ralphie këtu në një film të famshëm që luan pretty much ad nauseum çdo dimër. [VIDEO rishikim] -Të Jetë të njohur për të gjithë se Ralph Parker me anë të kësaj emëruar anëtarin e vogël Orphan Annie Secret Circle dhe ka të drejtë të të gjitha nderimet dhe përfitime ndodhin me to. 

-Signed, Little Orphan Annie, kundër-firmosur Pierre Andre, në bojë. Nderon dhe përfitimet, tashmë në moshën nëntë vjeçare. 

[Bërtasin] -Eja. Le të merrni më me të. Unë nuk kam nevojë të gjitha që jazz për kontrabandistët dhe piratët. 

natë -Listen nesër për aventurë përmbyllës i anijes pirate zi. Tani, është koha për të Mesazhi sekret Annie për ju anëtarë të rrethit Sekret. Mos harroni, fëmijët, vetëm anëtarët i Sekret Rrethi Annie mund të deshifroj mesazhin e fshehtë Annie. 

Mbani mend, Annie është në varësi të ju. Set këmbët tuaja në B2. Këtu është mesazhi. 12, 11-- 

-Unë Jam në, mbledhjen time të parë të fshehtë. 

-14, 11, 18, 16. 

-Pierre Ishte sonte madhe zë. Unë mund të them që sonte Mesazhi ishte me të vërtetë e rëndësishme. 

-3, 25, kjo është një mesazh nga Annie vetë. Mbani mend, mos i thoni askujt. 

-90 Sekonda më vonë, unë jam në vetmi dhomë në shtëpi, ku një djalë i nëntë mund të ulen në jetën private dhe deshifroj. Ah, B! Unë shkova në tjetër, E. 

Fjala e parë është jetë. S, ajo po vinte lehtë tani, U, 25-- 

Oh, eja, Ralphie, unë duhet të shkoj! 

-I'll Të jetë e drejtë poshtë, Ma! Gee kampion! 

-T, O, të jetë i sigurt to-- jetë i sigurt për çfarë? Cili ishte pak Orphan Annie duke u përpjekur për të thënë? Të jetë i sigurt për çfarë? 

-Ralphie, Andy ka marrë për shkoni, do ju lutem të dalë? 

drejtë -Të gjitha, Ma! Unë do të jetë jashtë të drejtë! 

-I Është duke iu afruar tani. Tensioni ishte e tmerrshme. Çfarë ishte ajo? Fati i planetit mund të ul receptorin e telefonit në bilancin. 

-Ralphie! Gotta Andy shkojnë! 

-I'll Të jetë e drejtë jashtë, për të qarë me zë të lartë! 

-Almost Atje, gishtat e mi fluturoi, mendjen time ishte një kurth çeliku, çdo pore vibrated. Ajo ishte pothuajse e qartë, po, po, po. 

-Të Jetë i sigurt për të pirë Ovaltine tuaj. Ovaltine? A komerciale pavlerë? Bir i një kurvë. [END rishikim] DAVID J. Malan: OK, kështu kjo ishte një mënyrë shumë e gjatë e futjes kriptografi, dhe gjithashtu Ovaltine. Në fakt, nga kjo referohem vjetër këtu, pse është Ovaltine aq i mirë? Është nxjerrja e përqendruar e pjekur malt elb, qumësht të pastër e lopës butë-së, dhe posaçërisht të përgatitur kakao, së bashku me phosphatides natyrore dhe vitamina. Ajo është e fortifikuar më tej me vitamina shtesë B dhe D, yum. Dhe ju prapë mund të merrni atë, me sa duket, në Amazon, siç bëmë këtu. 

Por motivimi këtu ishte për futur kriptografi, në mënyrë të veçantë një lloj i cryptography njohur si kriptografisë sekrete kyçe. Dhe si emri sugjeron, të gjithë sigurinë e një sistemi të fshehtë kyç kripto, në qoftë se ju do të, një metodologji për vetëm përpiqen informacioni mes dy njerëzve, është se vetëm dërguesi dhe vetëm marrësi e di një key-- sekret në disa vlera, disa fraza sekrete, disa numër të fshehtë, që lejon ata të dy Encrypt dhe decrypt informacion. Dhe cryptography, me të vërtetë, është vetëm kjo që nga java 0. 

Është një problem ku ka inputeve, si mesazh aktuale në anglisht apo çfarëdo gjuhë që ju dëshironi të dërgoni dikujt në klasë, ose në të gjithë internetit. Ka disa dalje, e cila do të jetë mesazhin fërguara që ju dëshironi marrësit për të marrë. Dhe edhe në qoftë se dikush në e mesme e merr atë shumë, ju nuk doni ata që të domosdoshmërisht të jetë në gjendje për të decrypt atë, sepse brenda kësaj kutia e zezë, ose algorithm, është një mekanizëm, disa hap pas hapi udhëzime, për të marrë këtë të dhëna dhe konvertimin e saj në të prodhimit, në shpresë mënyrë të sigurt. 

Dhe, në fakt, ka disa Fjalori në këtë botë si më poshtë. Tekst i thjeshtë është fjala një shkencëtar kompjuteri do përdorin për të përshkruar të dhëna Mesazhi, si anglisht ose çfarëdo gjuhe ju në të vërtetë dëshironi të dërgoni në një tjetër njeri. Dhe pastaj ciphertext është përleshje me enciphered ose koduar, version saj. 

Por ka një përbërës të tjera këtu. Ka një input të tjera të sekret cryptography kryesore. Dhe kjo është çelësi në vetvete, e cila është, në përgjithësi, si ne do të shohim, një numër, ose letër ose fjalë, çdo gjë algoritmi ajo është në fakt pret. 

Dhe si mund të decrypt informacion? Si mund të deshifruar atë? E pra, ju vetëm kundërt rezultatet dhe inputet. 

Me fjalë të tjera, sapo dikush merr mesazhin tuaj Encrypted, ai ose ajo thjesht ka të dini se njëjtin kyç. Ata kanë marrë koduar. Dhe me mbylljen ato dy inputet në sistemin kripto, algoritmi, kjo kuti e zezë, nga duhet të vijë plaintext origjinale. Dhe kështu që është niveli shumë i lartë pamje e asaj që është në fakt cryptography mbi të gjitha. 

Pra, le të marrë atje. Le të shohim tani nën individualitet e diçka ne kemi qenë duke marrë për të dhënë për javën e kaluar, dhe për këtë sesion here-- string. Nje varg në fund të ditës është vetëm një sekuencë e karaktereve. 

Ajo mund të jetë Hello World, ose përshëndetje Zamyla, ose çfarëdo. Por çfarë do të thotë të jetë një rend të karaktereve? Në fakt, biblioteka CS50 jep ne një lloj i të dhënave të quajtur string. 

Por nuk ka të vërtetë nuk ka gjë të tillë si një varg në C. Me të vërtetë është vetëm një sekuencë e Karakteri, karakteri, karakterin, Karakteri, përsëri, për të mbështetur, për të përsëri, për të mbështetur, për të mbështetur brenda e kujtesës e kompjuterit tuaj, ose RAM. Dhe ne do të shikojmë më thellë në se në ardhmja, kur ne shikojmë në kujtesën e vet, dhe shfrytëzimin, dhe Kërcënimet që janë të përfshirë. 

Por le të konsiderojmë string Zamyla. Pra, vetëm emri i njerëzore këtu, Zamyla, që është një sekuencë e karaktere, Z-A-M-Y-L-A. Dhe tani le të supozojmë se emri Zamyla-së është duke u ruajtur në brendësi të një kompjuter program. 

E pra, ajo qëndron për arsye se ne duhet të jetë në gjendje për të parë në këto karaktere individualisht. Kështu që unë jam vetëm duke shkuar për të nxjerrë pak kuti rreth emrit Zamyla këtu. Dhe kjo është rasti në C se kur ju të ketë një varg, si Zamyla-- dhe ndoshta që string është kthyer nga një funksion si get varg, në të vërtetë ju mund të manipulojnë ajo karakter nga karakteri. 

Tani, kjo është i lidhur ngushtë për Biseda në dorë, sepse në cryptography në qoftë se ju doni të ndryshojë A në B dhe B te C, dhe C tek D, e kështu me radhë, duhet të jenë në gjendje të shikojmë në karaktere të veçanta në një varg. Ju duhet të jetë në gjendje të ndryshojë Z për diçka tjetër, një për diçka tjetër, për të m diçka tjetër, dhe kështu me radhë. Dhe kështu që ne kemi nevojë për një mënyrë, programuar, kështu për të folur, në C të jetë në gjendje për të ndryshuar dhe të kërkoni në letra individuale. Dhe ne mund të bëjmë këtë si më poshtë. 

Më lejoni të shkojnë kokë mbrapa në CS50 IDE. Dhe më lejoni të shkoj përpara dhe për të krijuar një skedë të re se unë do të thërrasë këtë kohë string0, si shembull tonë të parë të tillë, dot c. Dhe unë jam duke shkuar për të shkuar përpara dhe nxit atë si më poshtë. 

Pra përfshijnë CS50.h, dhe pastaj përfshijnë io.h standarde, të cilën unë jam pothuajse gjithmonë do të të jetë përdorur në programet e mia, të paktën fillimisht. int pavlefshëm kryesore, dhe pastaj në këtu unë jam i do të bëjë vargjet merr marrë string. Dhe atëherë unë jam duke shkuar për të shkojnë përpara dhe të bëjë këtë. Unë dua të shkoj përpara dhe, si një kontroll mendje e shëndoshë, vetëm thonë, hello, për qind s, gjysmë-zorrës së trashë, e bën vargun 0. Uh oh, çfarë bëj unë këtu? Oh, unë nuk e atë në prizë. Pra mësim mësuar, që nuk ishte i qëllimshëm. 

Pra gabimi, më shumë për qind conversions se argumentet e të dhënave. Dhe ky është vendi ku, në Linja 7-- OK, kështu që unë kam, quote mbyll thonjëzat, kjo është string tim të printf. Unë kam marrë një shenjë për qind. Por unë jam i humbur argumentin e dytë. 

Unë jam i humbur presje s, i cili I kanë në shembujt e mëparshëm. Pra, një mundësi e mirë për të rregulluar edhe një gabim, aksidentalisht. Dhe tani më lejoni të drejtuar string0, shkruani Zamyla. OK, përshëndetje Zamyla. 

Pra, ne kemi drejtuar këtë lloj të programit disa herë të ndryshme tani. Por le të bëjmë diçka pak më ndryshe këtë herë. Në vend të vetëm shtypjes Zamyla-së tërë emri me printf, le ta bëjmë atë karakter nga karakteri. 

Unë jam duke shkuar për të përdorur një për lak. Dhe unë jam duke shkuar për të dhënë veten një variabël i numërimit, i quajtur i. Dhe unë jam duke shkuar për të mbajtur iterating, kështu kohë që i është më pak se gjatësia e s. 

Ajo rezulton, ne nuk kemi bërë këtë për herë të fundit, se c vjen me një Funksioni quhet Stirling. Kthehu në ditë, dhe në përgjithësi ende gjatë zbatimit të funksioneve, njerëzit shpesh do të zgjedhin shumë Emrat e ngjeshur se lloj i shëndoshë si ajo që ju doni, edhe pse është e mungon një zanore ose disa letra. Pra Stirling është emri i një funksion që merr një argument mes kllapa që duhet të jetë një varg. Dhe vetëm ajo kthehet një numër të plotë, gjatësia e atë varg. 

Pra, këtë për lak në linjë 7 po shkon të fillojë numërimi në i barabartë me 0. Ajo do të ardhura i në çdo përsëritje me 1, si ne kemi qenë duke bërë disa herë. Por ajo do të bëjë vetëm kjo deri në pikën kur i është gjatësia e vetë vargut. 

Kështu që kjo është një mënyrë për të, në fund të fundit, iterating mbi personazhet në vargun si është më poshtë. Unë jam duke shkuar për të shkruar nuk është një vargut të tërë, por për qind c, një karakter të vetëm i ndjekur nga një linjë të re. Dhe atëherë unë jam duke shkuar për të shkojnë përpara, dhe kam nevojë për të thonë se unë dua të shtypura Karakteri ith e s. 

Pra, nëse i është variabli që tregon indeksi i vargut, ku ju jeni në të, duhet të jenë në gjendje të thonë, më jep karakterin ith të s. Dhe c ka një mënyrë për të bërë kjo me kllapa katrore. Ju thjesht të thonë emrin e të string, e cila në këtë rast është s. Pastaj ju përdorni kllapa katrore, të cilat janë zakonisht vetëm mbi Kthimin apo Shkruani kyç në tastierë. Dhe pastaj të vendosni indeksin e të karakter që ju doni të shtypura. Kështu indeksi do të jetë një number-- 0, ose 1, ose 2, ose 3, ose pikë, dot, dot, një numër tjetër. 

Dhe ne kemi siguruar që ajo do të të jetë numrin e drejtë, sepse unë fillojë numërimi në 0. Dhe nga default, karakteri i parë në një varg është nga konventa 0. Dhe karakteri i dytë është kllapa 1. Dhe karakteri i tretë është kllapa 2. Dhe ju nuk doni të shkoni shumë tani, por ne nuk do të sepse ne jemi do të vetëm ardhura unë deri në atë është e barabartë me gjatësinë e vargut. Dhe në të cilën pikë, këtë për lak do të ndalet. 

Pra më lejoni të shkoj përpara dhe të ruani këtë program, dhe të drejtuar të string 0. Por unë dehur. Implicite deklaruar funksionin e bibliotekës Stirling me llojin e tillë dhe such-- tani, kjo tingëllon e njohur. Por kjo nuk është printf. Dhe kjo nuk është marrë string. 

Unë nuk e vidhos deri në në të njëjtën mënyrë këtë herë. Por vini re këtu poshtë pak më poshtë më tej, përfshijnë string header, shprehimisht sigurojë Deklarata për Stirling. Pra, nuk është në fakt një çelës në atje. 

Dhe me të vërtetë kjo rezulton ka një tjetër fotografi header se ne nuk kemi përdorur në klasë, por është e në mesin e atyre në dispozicion për ju, të quajtur string. Dhe në atë fotografi, string është Stirling deklaruar. Pra më lejoni të shkoj përpara dhe të ruani këtë, të bëjë string 0-- bukur, pa mesazhe gabimi këtë herë. 

./string0 Zamyla, dhe Unë jam gati për të goditur Enter, në të cilën pikë getString do për t'u kthyer string, e vënë atë në s. Atëherë kjo për lak do të iterate mbi personazhet e S në një kohë, dhe printoni ato një për rresht, sepse Unë kisha këtë backslash n në fund. Kështu që unë mund të harroj atë backslash n, dhe pastaj vetëm të shtypura Zamyla gjithë në të njëjtën linjë, në mënyrë efektive reimplementing printf, e cila nuk është e gjitha që e dobishme. Por në këtë rast, unë nuk e kam bërë këtë. Unë e kam shtypur në fakt një karakter në një kohë, një për rresht, kështu që ne në fakt të parë efektin. 

Por unë duhet të kini parasysh një gjë këtu. Dhe ne do të kthehen në këtë në një javë në të ardhmen. Ajo rezulton se kjo Kodi është potencialisht buggy. 

Ajo rezulton se të marrë varg dhe disa funksione të tjera në jetën e jo domosdoshmërisht gjithmonë kthehen çfarë jeni duke pritur. Ne e dimë nga klasa e fundit kohë në këtë që të merrni string është menduar për t'u kthyer një varg. Por, çfarë nëse llojet e përdoruesve nga të tilla një fjalë të gjatë, ose paragrafi, apo ese se nuk është vetëm nuk është e mjaftueshme kujtesës në kompjuter për të përshtaten atë. 

Si, çfarë nëse diçka shkon gabuar nën kapuç? Kjo nuk mund të ndodhë shpesh, por kjo mund të ndodhë një herë për një kohë, shumë rrallë. Dhe kështu kjo rezulton që të merrni varg dhe funksionon si ai nuk domosdoshmërisht gjithmonë kthehen strings. Ata mund të kthehen disa vlera gabimi, disa vlera sentinel mënyrë që të flasin, që tregon se diçka ka shkuar keq. Dhe ju do të dini vetëm këtë nga ka mësuar atë në klasë tani, ose që ka lexuar disa dokumente shumë. Ajo rezulton se të marrë varg mund të kthehen një vlerë të quajtur null. Null është një vlerë e veçantë që ne do të kthehen në një javë në të ardhmen. Por tani për tani, vetëm e di se në qoftë se unë dua të jetë me të vërtetë e duhur për të ecur përpara duke marrë varg, I nuk duhet të vetëm e quajti atë, dhe verbërisht të përdorë vlerën e saj të kthimit, duke besuar se kjo është një string. 

I pari duhet të them, hej, prit një minutë, vetëm të vazhdojë në qoftë se s nuk të barabartë null, ku null, përsëri, është vetëm disa vlera të veçanta. Dhe kjo është e vetmja vlerë të veçantë të duhet të shqetësohen për për të marrë varg. Get string është ose do për t'u kthyer një varg apo null. 

Dhe kjo pikë thirrje është e barabartë me shenjë ju mund të dini nga ndoshta klasën e matematikës që ju mund të tërheqë një shenjë të barabartë me një linjë me atë për të treguar jo të barabartë. Kjo nuk është në përgjithësi një karakter ju mund të shtypni në tastierën tuaj. Dhe kështu në shumicën e gjuhëve të programimit, kur ju doni të thoni jo të barabartë, ju përdorni një pikë thirrje, i njohur ndryshe si zhurmë. Pra, ju thoni zhurmë barabartë, i cili do të thotë nuk është e barabartë, logjikisht. Është vetëm si nuk është një i madh se, ose e barabarte me ose me pak se ose e barabartë me kyç në tastierën tuaj që e bën të gjitha në një simbol. Pra, kjo është arsyeja pse, në shembujt e fundit, keni bërë një parantezë të hapur, dhe më pas një shenjë të barabartë, në mënyrë për të bërë më e madhe se ose thotë, më pak se. 

Pra, çfarë është takeaway këtu? Kjo është thjesht një mënyrë tashmë e futur këtë sintaksë, ky tipar, iterating mbi individual karaktere në një varg. Dhe ashtu si ato shesh kllapa t'ju lejojë të merrni me ta, konsiderojnë këto kllapa katrore si lloj nënkupton në këtë themelor dizajn, ku çdo Karakteri brenda një varg është lloj i boxed në diku nën individualitet në kujtesën e kompjuterit tuaj. 

Por le të bëjë një variant të kësaj. Ajo rezulton se kjo program është i saktë. Pra per akset CS50-së për vlerësimin e kodi, kjo është e saktë tani. Sidomos tani që unë jam duke kontrolluar për null, ky program nuk duhet rrëzuar. Dhe unë vetëm e di se nga përvoja. Por nuk ka asgjë tjetër që ne mund të vërtetë të shkojnë keq këtu. Por kjo nuk është shumë e mirë-projektuar, sepse le të kthehemi në bazat. 

Së pari, principles-- çfarë një për lak të bëjë? Një për lak bën tre gjëra. Ajo initializes disa vlera, nëse ti i pyet atë për të. Ajo kontrollon një kusht. Dhe pastaj pas çdo përsëritje, pas çdo cikli, ajo increments disa vlera, apo vlerat, këtu. 

Pra, çfarë do të thotë kjo? Ne nisja i të 0. Ne kontrolluar dhe të sigurt i është më pak se gjatësia e s, e cila është Z-A-M-Y-L-A, kështu që është më pak se 6. Dhe, me të vërtetë, 0, kur më pak se 6. 

Ne të shtypura nga Z nga emri Zamyla së. Pastaj ne ardhura i nga 0 deri 1. Ne atëherë kontrolloni, është 1 më pak se gjatësia e s? Gjatësia e s është 6. Po kjo është. 

Pra, ne të shtypura një në emër të Zamyla së, ZA. Ne rrisim i nga 0, 1, në 2. Ne atëherë kontrolloni, është më pak se 2 gjatësia e emrit të Zamyla së. 6- kështu 2 është më pak se 6. Po, le të shtypura nga tani M në Emri Zamyla-së, karakteri i tretë. 

Çështja kryesore këtu është se në çdo përsëritje e historisë, unë jam duke kontrolluar, është i më pak se gjatësia e Zamyla? Por kapur është se Stirling nuk është një pronë. Ata prej jush që kanë programuar para në Java apo gjuhë të tjera mund të dini gjatësinë e një varg është një pronë, vetëm disa lexuar vetëm vlerë. 

Në C në këtë rast, nëse kjo është e një funksion që është fjalë për fjalë numëruar numrin e karaktere në Zamyla çdo kohë ne e quajmë atë funksion. Çdo herë që të pyesni kompjuterin për të përdorur Stirling, ajo është duke marrë një vështrim në Zamyla, dhe thënë Z-A-M-Y-L-A, 6. Dhe kthehet 6. Herën tjetër që ju të telefononi është brenda që për lak, ajo do të shikojmë në Zamyla përsëri, të thënë Z-A-M-Y-L-A, 6. Dhe ajo do të kthehet 6. Pra, çfarë është e trashë në lidhje me këtë dizajn? 

Pse është kodi im nuk është me 5 nga 5 për dizajn tani, kështu që të flasin? E pra, unë jam duke kërkuar një pyetje të panevojshme. Unë jam duke bërë më shumë punë se sa kam nevojë për të. 

Pra, edhe pse Përgjigja është e saktë, unë jam duke i kërkuar në kompjuter, ajo që është gjatësia e Zamyla përsëri, dhe përsëri, dhe përsëri, dhe përsëri? Dhe kjo përgjigje është kurrë nuk do të ndryshojë. Është gjithmonë do të jetë 6. 

Pra, një zgjidhje më të mirë se sa kjo do të jetë ky versioni i ardhshëm. Më lejoni të shkojnë përpara dhe të vënë atë në një Skedari i veçantë i quajtur string1.c, vetëm për të mbajtur atë të veçantë. Dhe kjo rezulton në një për loop, ju mund të vërtetë deklarojë variablave të shumta në të njëjtën kohë. 

Kështu që unë jam duke shkuar për të mbajtur I dhe e vendosi atë në 0. Por unë jam gjithashtu do të shtoni një presje dhe thuaj: më jepni një ndryshore të quajtur n, të cilit Vlera është e barabartë me gjatësinë e string s. Dhe tani, ju lutem sigurohuni gjendjen time për sa kohë që i është më pak se n. 

Pra, në këtë mënyrë, logjika është identike në fund të ditë. Por unë jam duke kujtuar vlera 6, në këtë rast. Çfarë është gjatësia e emrit të Zamyla-së? Dhe unë jam vënë atë në n. 

Dhe unë jam ende duke kontrolluar gjendja çdo kohë. 0 më pak se 6? Është 1 më pak se 6? Është 2 më pak se 6, e kështu me radhë? 

Por unë nuk jam duke kërkuar kompjuterin përsëri, dhe përsëri, çfarë është gjatësia e emrit të Zamyla-së? Çfarë është gjatësia e emrit të Zamyla-së? Çfarë është gjatësia e emrit të këtij Zamyla-së? Unë fjalë për fjalë të kujtohet se për herë të parë dhe vetëm përgjigjem në këtë n e dytë të ndryshueshme. Pra, kjo tani do të jetë jo vetëm e saktë, por edhe të mirë-projektuar. 

Tani, ajo që për stilin e? Unë e kam quajtur variabla e mia mjaft mirë, unë do të thoja. Ata janë super ngjeshur tani. Dhe kjo është krejtësisht në rregull. 

Nëse keni vetëm një të tillë string në një program, si edhe ju mund të telefononi ajo s për varg. Nëse keni vetëm një variabël për numërim në një program, si edhe ju mund të telefononi atë i. Nëse ju keni një gjatësi, n është super e zakonshme si. Por unë nuk kam komentuar asnjë kodin tim. 

Unë nuk e kam informuar reader-- nëse kjo është TF ime, ose TA, ose vetëm colleague-- atë që është menduar të ndodh në këtë program. Dhe kështu për të marrë stil të mirë, ajo që unë do të duan të bëjnë është diçka this-- si kërkojë përdoruesit për të dhëna. Dhe unë mund të rishkruaj kjo ndonjë numër të mënyra. 

Sigurohuni s-- të siguruar get string kthyer një varg. Dhe pastaj në here-- dhe kjo është ndoshta iterate më e rëndësishme comment-- mbi personazhet në s një në një kohë. Dhe unë mund të përdorni ndonjë Zgjedhja e gjuhës angleze këtu për të përshkruar njëri- nga këto chunks të kodit. 

Vini re se unë nuk kam vënë një komentuar mbi çdo linjë të kodit, me të vërtetë vetëm në anën interesante ato të, ato që kanë disa domethënie që unë mund të duan të bëjnë super të qartë për dikë duke lexuar kodin tim. Dhe pse jeni duke e quajtur të string pyesni përdorues të dhëna? Edhe kjo nuk është domosdoshmërisht të gjitha që përshkrues. Por ajo ndihmon tregoj një histori, për shkak se Linja e dytë në histori është, sigurohuni që marrë string kthyer një varg. 

Dhe vija e tretë në histori është, iterate mbi personazhet në një s ne nje kohe. Dhe tani vetëm për masë të mirë, Unë jam duke shkuar për të shkuar përpara dhe për të shtuar një koment më shumë se vetëm të thotë print karakter i-th në s. Tani, çfarë të kam bërë në fund të ditës? 

Unë kam shtuar disa English fjalë në formën e komenteve. Simboli plagë plagë do të thotë, hej, kompjuter kjo eshte per njeriut, jo për ty, kompjuter. Pra, ata janë injoruar në mënyrë logjike. Ata janë vetëm atje. 

Dhe, me të vërtetë, CS50 IDE tregon ato si gri, si të dobishëm, por jo kryesore me programin. Vini re atë që ju tani mund të bëni. Nëse ju e dini C programimi apo jo, ju vetëm mund të qëndrojë prapa në këtë program, dhe cek komentet. Pyetni përdoruesit për të dhëna, të sigurt marrë string kthyer një varg, iterate mbi personazhet në s një në një kohë, të shtypura karakterin Karakteri i-th në s-- ju nuk e bëni edhe duhet të shikoni në kodin për të kuptuar se çfarë ky program bën. Dhe, më mirë akoma, në qoftë se ju vetë shikoni në këtë program në një javë ose dy, ose një muaj, apo një vit, edhe ju nuk keni për të ia ngul sytë në kodin, duke u përpjekur për të kujtuar, çfarë po unë duke u përpjekur të bëjë me këtë kod? 

Ju keni thënë vetes. Ju keni përshkruar atë për veten tuaj, apo ndonjë koleg apo AT, ose TF. Dhe kështu që kjo tani do të jetë saktë, dhe dizajn të mirë, dhe përfundimisht style mirë po ashtu. Pra, bëni të mbani në mend. 

Pra, ka një tjetër gjë që unë jam duke shkuar për të bërë këtu se tani mund të zbulojë saktësisht se çfarë është ndodh nën kapuç. Pra, nuk ka ky tipar në C, dhe në gjuhë të tjera, quajtur typecasting se ose implicite ose në mënyrë të qartë ju lejon të konvertohet nga një lloj të dhënave në një tjetër. Ne kemi qenë që kanë të bëjnë në mënyrë tani sot me vargjet. 

Dhe vargjet janë karaktere. Por kujtoj që nga java e 0, cilat janë personazhet? Personazhet janë vetëm një abstraksion në krye të numrave numbers-- dhjetore, dhe numrat dhjetore janë me të vërtetë vetëm një Nxjerrja në krye të numrave binare, si ne përkufizuar atë. 

Pra, personazhet janë numra. Dhe numrat janë karaktere, vetëm në varësi të kontekstit. Dhe kjo rezulton se brenda e një programi kompjuterik, mund të specifikoni se si ju dëshironi të shikoni në copa brenda e këtij programi? 

Recall nga java 0 që kemi pasur Ascii, e cila është vetëm ky kod Letrat e hartës për numrat. Dhe ne thamë, kryeqyteti A është 65. Capital B është 66, e kështu me radhë. 

Dhe vini re, ne thelb kemi chars në në radhën e lartë këtu, si C do të thërrasë ato, karaktere, dhe pastaj Ints në rreshtin e dytë. Dhe kjo rezulton se ju mund të konvertohet seamlessly në mes të dy, në mënyrë tipike. Dhe në qoftë se ne duam të bëjmë këtë qëllim, ne mund të dëshironi për të trajtuar diçka si kjo. 

Ne mund të dëshironi për të kthyer Rasti sipërme të ulët rast, ose rasti më i ulët në rastin e sipërm. Dhe kjo rezulton se ka në fakt një model këtu ne mund të përqafojë në një moment të vetëm. Por le të shohim së pari në një Shembull për të bërë këtë në mënyrë eksplicite. 

Unë jam duke shkuar për të shkuar mbrapa në CS50 IDE. Unë jam duke shkuar për të krijuar një file i quajtur Ascii 0.c. Dhe unë jam duke shkuar për të shkuar përpara dhe për të shtuar tim io.h standarde në krye, e pavlefshme int main në majë të funksionit tim. Dhe atëherë unë jam vetëm duke shkuar për të bërë të following-- një për lak nga i barabartë, le të themi, 65. 

Dhe pastaj i do të jetë më pak se 65, plus 26 shkronja në alfabetin. Kështu që unë do të le kompjuterin bëjë matematikë për mua atje. Dhe pastaj brenda këtij loop, çfarë jam unë do të shtypura? 

% C është% i backslash n. Dhe tani unë dua të plug në dy vlera. Unë e kam vënë përkohësisht pyetje shënon atje për të ftuar pyetje. 

Dua të iterate nga 65 e tutje për 26 shkronjat e alfabetit, shtypjen jashtë në çdo përsëritje që ekuivalente integrale karakter. Me fjalë të tjera, unë dua të iterate mbi 26 numra printim çfarë karakteri Ascii është, letra, dhe çfarë is-- numri korrespondues me të vërtetë vetëm rikrijimin grafiku nga kjo rrëshqitje. Pra, çfarë duhet të jenë këto pikëpyetje? 

E pra, ajo rezulton se të dytë duhet të jetë vetëm i ndryshueshëm. Unë dua të shoh se si një numër. Dhe argumenti mesme këtu, unë mund të them kompjuterin për të trajtuar atë numër i plotë i si një karakter, në mënyrë që ta zëvendësojnë atë këtu për qind C. 

Me fjalë të tjera, në qoftë se unë, programues të njeriut, e di këto janë vetëm numra në fund të ditës. Dhe unë e di se 65 duhet hartë të një karakter. Me këtë cast të qartë, me kllapa, emri i tipit të të dhënave që ju doni të konvertohet në dhe një kllapa mbyllur, ju mund të them kompjuter, hey, kompjuter, kthyer këtë numër të plotë në një char. 

Kështu që kur kam drejtuar këtë program pas përpilimit, le të shohim se çfarë kam bërë get-- ascii 0. Mallkuar atë, ajo që ka të bëj gabim këtu? Përdorni të identifikues padeklaruar, të gjithë të drejtë, jo të qëllimshme, por le të shohim nëse ne nuk mund të Arsyeja me këtë. 

Pra, linja five-- kështu që unë nuk e kam marrë shumë larg para vidhosje deri. Eshte ne rregull. Kështu Linja 5 për i barabartë 65-- shoh. Pra, mos harroni se në C, ndryshe nga disa Gjuhët në qoftë se ju keni programimit paraprak Përvoja, ju keni për të të treguar kompjuterin, ndryshe nga Scratch, çfarë lloji i variablit është. 

Dhe kam harruar një frazë kyçe këtu. Në përputhje pesë, unë kam filluar përdorimin i. Por unë nuk e kam thënë C çfarë të dhënat lloji është. Kështu që unë jam duke shkuar për të shkuar në këtu dhe thonë, ah, e bëjnë atë një numër të plotë. 

Tani unë jam duke shkuar për të shkuar përpara dhe të përpiluar. Kjo fikse se. ./ascii0 Enter, kjo është lloj i ftohtë. Jo vetëm që është e super të shpejtë për pyesni kompjuterin këtë pyetje, në vend se duke kërkuar atë në një rrëshqitje, të shtypur një për çdo rresht, A është 65, B është 66, të gjithë rrugën që down-- I e bëri këtë 26 Times-- me shkronja z, që është 90. Dhe, në fakt, pak më inteligjente do të kanë qenë për mua të mos mbështeten në kompjuter për të shtuar 26. Unë mund të ketë bërë vetëm 90 si edhe, për aq kohë si unë nuk do të bëjë të njëjtin gabim dy herë. Unë dua të shkoj deri me z, jo vetëm deri me y. 

Pra, kjo është një cast qartë. Ajo rezulton se kjo nuk është edhe e nevojshme. Më lejoni të shkojnë përpara dhe përsëritje kjo përpilues, dhe përsëritje Ascii 0. Ajo rezulton se C është shumë e zgjuar. 

Dhe printf, në veçanti, është shumë e zgjuar. Nëse ju vetëm të kalojë një I dy herë për të dy placeholders, printf do të kuptojë, oh, edhe unë ju njoh i dha mua një integer-- një numër, si 65, ose 90, ose çfarëdo. Por unë shoh se ju doni mua për të format këtë numër si një karakter. Dhe kështu printf mund të hedhin në mënyrë implicite int në një char për ju si. Pra, kjo nuk është një problem në të gjitha. 

Por vini re, për shkak të këtij ekuivalencë ne fakt mund ta bëjë këtë si. Më lejoni të shkojnë përpara dhe të bëjë një të tillë version tjetër i this-- 1.c. ascii Dhe në vend të iterating mbi integers, të vërtetë mund të fryj mendjen tuaj nga iterating mbi karaktere. Në qoftë se një char c merr kapital A, I duan të shkojnë përpara dhe të bëjë këtë, aq sa C është më e vogël se ose e barabartë në Z. e kapitalit dhe në çdo përsëritje Dua të ardhura C, unë mund të tani në përputhje tim printf këtu të themi, për qind C është për qind i përsëri, presje C. 

Dhe tani, unë mund të shkojnë në drejtimin tjetër, hedh karakterin në mënyrë të qartë në një numër të plotë. Pra, përsëri, pse do të bëni këtë? Kjo është një çuditshëm pak për të zgjidhur të llogarisin në aspektin e karaktereve. 

Por në qoftë se ju e kuptoni se çfarë është ndodh nën kapuç, nuk ka të vërtetë ka magji. Ju jeni vetëm duke thënë, hej, kompjuteri japin me një ndryshore të quajtur C e tipit char. Nisja atë të kapitalit A. And vëreni vetëm çështje quotes. 

Për personazhet në C, kujtohet nga javën e kaluar, se ju përdorni këto apostrofa. Për vargjet, për fjalë, frazat, ju përdorni kuotat e dyfishtë. OK, kompjuteri, të vazhdojmë të bëjmë këtë, kështu që gjatë si karakter është më pak se ose e barabartë me z. Dhe unë e di nga tryezën time ascii që të gjithë nga këto kode ASCII janë puqur. 

Nuk ka boshllëqe. Pra, kjo është vetëm një anë Z, të ndara nga një numër secili. Dhe atëherë unë mund të rrisim një char, në qoftë se unë me të vërtetë dëshironi. Në fund të ditës, kjo është vetëm një numër. Unë e di këtë. Kështu që unë vetëm mund të marr me mend për të shtuar 1 për të. 

Dhe pastaj kjo kohë, unë të shtypura c, dhe pastaj ekuivalente integrale. Dhe unë nuk duhet edhe të hedhura qartë. Unë mund të le printf dhe figura kompjuter gjëra jashtë, kështu që tani, nëse unë të drejtuar të Ascii1./ascii1, Unë të marrë të njëjtën gjë e saktë si. 

Programi i kotë, though-- askënd do të në fakt të shkruar software në mënyrë që të kuptoj, çfarë ishte numër që harta të A ose B, ose Z? Ju jeni vetëm duke shkuar për të Google atë, ose shikoni atë deri në internet, apo të shikoni atë në një rrëshqitje, apo të tjera si këto. Pra, ku e bën këtë të vërtetë të dobishme? 

E pra, duke folur për këtë rrëshqitje, vini re ka një model i vërtetë këtu në mes të uppercase dhe të vogla që nuk ishte aksidentale. Vini re se kapitali A është 65. Vogle a është 97. Dhe sa larg është rasti më i ulët një? 

Pra, 65 është se si shumë hapa larg nga 97? Pra, 97 minus 65 është 32. Pra, një kapital është 65. Nëse ju shtoni 32 të kësaj, ju merrni vogle a. Dhe, në mënyrë ekuivalente, në qoftë se ju zbres 32, që ju të merrni përsëri në kryeqytetin A-- njëjtë me B për pak b, C e madhe për pak c. 

Të gjitha këto boshllëqe janë 32 veç e veç. Tani, kjo do të duket të na lejojë që të të bëjë diçka si Microsoft Word, ose Google Docs funksion, ku ju mund të zgjidhni çdo gjë e pastaj thonë: ndryshojë të gjitha jo kapitale, ose ndryshojë të gjitha në rastin e sipërm, ose të ndryshojë vetëm fjalën e parë të dënimit me rastin e sipërme. Ne në fakt mund të bëjë diçka si kjo veten. 

Më lejoni të shkojnë përpara dhe për të ruajtur një skedar këtu quhet germa 0.c. Dhe le të shkojnë përpara dhe nxit një program që bën pikërisht këtë si më poshtë. Kështu që përfshijnë bibliotekën CS50. Dhe përfshijnë standarde I / O. 

Dhe unë e di se kjo po vjen së shpejti. Kështu që unë jam duke shkuar për të vënë atë në atje tashmë, string, kështu që unë të kenë qasje në gjëra të tilla si Stirling, dhe pastaj int pavlefshme kryesore, si zakonisht. Dhe atëherë unë jam duke shkuar për të shkuar përpara dhe të bëjë vargjet merr marrë varg, vetëm për të marrë një varg nga përdoruesit. Dhe atëherë unë jam duke shkuar për të bëjë kontroll time mendje e shëndoshë. Nëse string nuk ka null barabartë, atëherë është e sigurt për të vazhduar. Dhe çfarë unë dua të bëj? Unë do të iterate nga i barabartë me 0, dhe n deri në gjatësinë varg të s. 

Dhe unë jam duke shkuar për të bërë këtë për aq kohë sa i është më pak se n dhe i plus plus. Deri më tani, unë jam me të vërtetë vetëm huazuar ide nga më parë. Dhe tani unë jam duke shkuar për të futur një degë. 

Pra, mendoj se përsëri në Scratch, ku kemi pasur këto forks në rrugë, dhe javën e kaluar në C. Unë do të E them këtë, në qoftë se karakteri i-th në s është më e madhe se ose e e barabartë me rastin e një të ulët, and-- në Scratch ju do të vërtetë thonë dhe, por në C ju thonë simbol, ampersand-- dhe karakteri i-th në s është më pak se ose e barabartë për të ulur rast z, le të bëjë diçka interesante. Le të në fakt të shtypura nga një Karakteri pa NEWLINE që është karakter në varg, karakteri i-th në varg. 

Por le të shkojnë përpara dhe të zbres 32 nga ajo. Tjetër në qoftë se karakteri në string se ne jemi duke kërkuar nuk është mes pak a dhe pak z, të shkojnë përpara dhe vetëm të shtypura it out pandryshuar. Pra, ne kemi prezantuar ky simbol kllapa për vargjet tona për të marrë më së i-th karakter në varg. 

Unë kam shtuar disa logjikën e kushtëzuar, si Scratch në një javë e javës së kaluar, ku Unë jam vetëm duke përdorur themelore im kuptim të asaj që është ndodh nën kapuç. Është karakteri i-th es më e madhe se ose e barabartë me një? Si, a është 97 apo 98, ose 99, e kështu me radhë? 

Por ajo është edhe më pak se ose e barabartë me vlerën e z vogle? Dhe nëse po, çfarë do të thotë kjo linjë? 14, kjo është lloj i embrion i tërë idesë, germa letrën me thjesht zbritur 32 prej saj, në këtë rast, sepse unë e di, per se tabelë, si numrat e mi janë të përfaqësuara. Pra, le të shkojnë përpara dhe të drejtuar këtë, pas përpilimit germa 0.c, dhe drejtuar germa 0. 

Le të shkruani diçka si Zamyla në të gjitha Fjala hyjnë. Dhe tani ne kemi Zamyla në të gjitha uppercase. Le të shkruani Rob në të gjitha Fjala. Le të përpiqemi në të gjitha Jason Fjala. Dhe do të vazhdojmë duke marrë kapitalizimit të detyruar. Ka një bug të vogla që unë lloj nuk e parashikojnë. Njoftim të shpejtë im i ri është duke përfunduar në të njëjtën linjë si emrat e tyre, i cili ndjen një çrregullt pak. 

Kështu që unë jam duke shkuar për të shkuar këtu, dhe në fakt, në fund të këtij programi shtypura nga një karakter NEWLINE. Kjo eshte e gjitha. Me printf, ju nuk keni nevojë të të kalojë në variablat ose kodin format. Ju mund të vërtetë vetëm të shtypura diçka si një newline. 

Pra, le të shkojnë përpara dhe të bëjë germa 0 herë, përsëritje atë, Zamyla. Dhe tani kjo është një prettier pak. Tani, të shpejtë im është në linjë e saj të ri. Pra, kjo është e gjitha mirë dhe të mirë. Kështu që është një shembull i mirë. Por unë nuk e bëj edhe domosdoshmërisht duhet të kodit të vështirë 32. Ju e dini se çfarë? Unë mund të say-- unë nuk kurrë mbani mend se çfarë është dallimi. 

Por unë e di se në qoftë se unë kanë një germë të vogël, Unë në thelb dua të zbres off çfarëdo që distanca është mes pak një dhe të mëdha A, sepse në qoftë se unë të supozojmë se të gjithë nga letra e tjera janë të njëjtë, që duhet të marrë punë të bërë. Por në vend se të bëni këtë, ju e dini se çfarë? Ka një mënyrë tjetër akoma. 

Nëse kjo është germa 1.c-- nëse unë për të vënë atë në një skedar të veçantë. le të mos germa 2.c si më poshtë. Unë do të të vërtetë të pastruar këtë deri këtu. Dhe në vend të pasur nevojë të di ose kujdesen për ato nivel të ulët Detajet e zbatimit, unë jam në vend vetëm duke shkuar për të shkruar një karakter, quote mbyll thonjëzat, qind C, dhe atëherë telefononi një funksion që ekziston që merr një argument, i cili është një karakter, si kjo. 

Kjo rezulton në C, nuk ka një tjetër telefonatë funksion të sipërme, e cila si emrin e saj sugjeron merr një karakter dhe e bën atë në rastin e saj e sipërme ekuivalente, dhe pastaj kthen në mënyrë që printf mund të plug atë në atje. Dhe kështu për të bërë këtë, edhe pse, unë nevojë për të futur një fotografi të tjera. Ajo rezulton se ka një tjetër fotografi që ju do të dini vetëm nga klasa, ose një tekst, ose një në internet reference, i quajtur type.h. C 

Pra, nëse unë shtoj se deri në mesin e kokë tim fotografi, dhe tani ri-hartojnë këtë program, capitalize2, ./capitalize2 Enter. Le të shkruani në Zamyla në të gjitha të vogla, ende punon njëjtë. Por ju e dini se çfarë? Ajo rezulton se të sipërme ka disa funksionalitetin tjetër. 

Dhe më lejoni të prezantoj këtë urdhëroj këtu, lloj dyluftimi në ajër emrin, por njeriu për manual. Ajo rezulton se shumica e kompjuterëve Linux, si ne jemi duke përdorur here-- operativ Linux system-- kanë një komandë quajtur njeri, i cili thotë: hey, kompjuter, jepni manual e kompjuterit. Qfare deshironi kërkoni në këtë manual? 

Unë dua të shikoni funksionin quajtur të sipërme, Enter. Dhe kjo është pak i fshehtë për të lexuar ndonjëherë. Por vini re ne jemi në manual programues Linux. Dhe kjo është e gjitha tekst. Dhe vini re se nuk është emri i funksionit deri këtu. Ajo rezulton se ka një kushëri të quajtur për të ulur, i cili bën të kundërtën. Dhe njoftimi në përmbledhje, për të përdorur këtë funksionojë faqen njeri, kështu që të flasin, është thënë mua se unë duhet të përfshijë c type.h. Dhe e dija se nga praktika. 

Këtu, ajo është treguar mua dy prototipa për funksionin, kështu që nëse unë ndonjëherë të dëshironi të përdorni këtë Unë e di se çfarë ata e marrin si të dhëna, dhe atë që ata kthehen si output. Dhe pastaj, nëse kam lexuar përshkrimi, unë shoh më në detaje çfarë funksioni. Por më e rëndësishmja, në qoftë se I shikoni nën vlerën e kthimit, ai thotë se vlera e kthyer është atë të letrës konvertuar, ose C, të dhëna origjinale, në qoftë se konvertimi nuk ishte e mundur. 

Me fjalë të tjera, për të sipërme do të përpiqet për të kthyer një letër për rastin e sipërme. Dhe nëse është kështu, ajo do të kthejë atë. Por në qoftë se nuk mund të për disa reason-- ndoshta është rasti tashmë e sipërme, ndoshta kjo është një pikë thirrje apo ndonjë punctuation-- tjera ajo është vetëm do të kthehen C origjinale, që do të thotë unë mund të bëjë kodin tim projektuar mirë si më poshtë. 

Unë nuk kanë nevojë për të gjithë këto rreshta të kodit mallkuar. Të gjitha linjat e kam vetëm theksuar mund të të shembur në vetëm një të thjeshtë line, e cila është this-- printf për qind c për S kllapa sipërme i. Dhe kjo do të ishte një shembull i dizajnit të mirë. 

Pse zbatuar në 7 ose 8 rreshta e kodit, çfarëdo qoftë ajo ishte I vetëm fshihet, kur ju mund të rënies në vend të gjithë këtë logjikë dhe vendimmarrje në një linjë të vetme, 13 tani, që mbështetet në një bibliotekë function-- një funksion që vjen me C, por bën pikërisht ajo që ju doni të bëni. Dhe, sinqerisht, edhe në qoftë se ajo nuk ka ardhur me C, ju mund të zbatojë atë vetë, si ne kemi parë, me të marrë int negative dhe për të marrë pozitiv int javën e kaluar, si dhe. 

Ky kod është tani shumë më i lexueshëm. Dhe, me të vërtetë, në qoftë se ne lëvizni lart, duken sa më kompakte ky version i programit tim është. Kjo është një e rëndë pak të lartë tani, me të gjitha këto përfshin. Por kjo është në rregull, sepse tani unë jam duke qëndruar mbi supet e programuesit para meje. Dhe kushdo që ishte ai që zbatuar të sipërme të vërtetë më bëri një nder, ashtu si ai që zbatuar Stirling vërtetë më bëri një nder disa kohë më parë. Dhe kështu që tani ne kemi një Programi më të mirë të projektimit që zbaton të njëjtën logjikë të saktë. 

Duke folur për Stirling, le të shkoj përpara dhe të bëjë këtë. Më lejoni të shkojnë përpara dhe për të shpëtuar kjo skedë si stirling.c. Dhe kjo rezulton, ne mund të zhvishem përsëri një shtresë tjetër shumë e thjeshtë tani. Unë jam duke shkuar për të shkuar përpara dhe Kryetari i grupit parlamentar up një tjetër program në kryesore këtu se thjesht ri-zbaton gjatësia string si më poshtë. Kështu që këtu është një linjë e kodit që merr me një varg nga përdoruesit. Ne vazhdojmë të përdorur këtë përsëri dhe përsëri. Më lejoni të jap vetes një ndryshore të quajtur n të tipit int që ruan një numër. 

Dhe më lejoni të shkoj përpara dhe të bëjë logjikën e mëposhtme. Ndërsa karakteri n-të në s bën Nuk backslash barabartë 0, të shkojnë përpara dhe rritje n. Dhe pastaj të shtypura nga printf për qind ni. I thonë se ky program këtu, pa e quajtur gjatësi varg, shifra se gjatësinë e një varg. 

Dhe magjia është plotësisht encapsulated në linjë 8 këtu me atë që duket si sintaksë të re, kjo backslash 0 në thonjëza të vetme. Por pse është kjo? E pra, e konsiderojnë atë që ka qenë duke shkuar në të gjithë këtë kohë. 

Dhe si një mënjanë, para se të harroj, të kuptojë shumë, se përveç faqet njeriu që vijnë me një tipik sistem Linux si CS50 IDE, kuptojnë se ne, të Stafi kurs të, kanë edhe bëri një version të internetit e kësaj ideje të njëjtë të quajtur reference.cs50.net, e cila ka të gjitha ato faqe njëjti njeri, të gjithë të njëjtën dokumentacionit, si dhe një kuti të vogël në krye që lejon ju për të kthyer të gjitha të drejtë Gjuha e errët në më pak të rehatshme mode, ku ne, personeli mësimor, kanë kaluar nëpër dhe u përpoq për të lehtësuar disa të gjuhës që të mbani gjërat përqendruar në idetë, dhe jo disa prej teknike. Pra, mbani në mend, reference.cs50.net si një burim si. 

Por pse e bën punën gjatësi string në mënyrën se si unë propozoi një moment më parë? Ja emri Zamyla përsëri. Dhe këtu është emri Zamyla-së boxed në, si unë të vazhdojmë të bëjmë, për të pikturuar një foto e të qenit, me të vërtetë, vetëm një sekuencë e karaktereve. Por Zamyla nuk ekziston në mënyrë të izoluar, në një program. 

Kur ju shkruani dhe të drejtuar një program, ju jeni duke përdorur Mac apo PC tuaj si kujtim, ose RAM mënyrë që të flasin. Dhe ju mund të mendoni kompjuterin tuaj si ka shumë gigabajt të memories këto ditë. Dhe një koncert të thotë miliarda, kështu miliarda bytes. 

Por le të Rewind në kohë. Dhe mendoj se ne jemi duke përdorur një kompjuter të vërtetë e vjetër që ka vetëm 32 byte memorje. Unë mund të, në ekranin e kompjuterit tim, thjesht të tërheqë këtë, si më poshtë. 

Unë thjesht mund të them se tim kompjuter ka gjithë këtë kujtesë. Dhe kjo është si një shkop të kujtesës, në qoftë se ju kujtohet foto tonë nga hera e fundit. Dhe në qoftë se unë vetëm të ndarë këtë në kohë të mjaftueshme, I thonë se unë kam 32 bytes e kujtesës në ekran. 

Tani, në të vërtetë, unë vetëm mund të nxjerrë deri më tani në këtë ekran këtu. Kështu që unë jam duke shkuar për të shkuar përpara, dhe vetëm nga Konventa, nxjerrë kujtesën e kompjuterit tim si grid, jo vetëm si një vijë e drejtë. Në mënyrë të veçantë, unë pretendojnë tani që këtë rrjet, kjo 8 nga 4 grid, vetëm përfaqëson të gjithë 32 bytes e kujtesës në dispozicion në Mac tim, ose në dispozicion në PC tim. Dhe ata janë duke i dhënë në të dy linja, vetëm sepse kjo i përshtatet më shumë në ekran. Por kjo është byte parë. Kjo është bajt dytë. Kjo është byte tretë. 

Dhe kjo është byte 32. Ose, në qoftë se ne mendojmë si një kompjuter shkencëtar, kjo është bajt 0, 1, 2, 3, 31. Kështu që ju duhet 0 në 31, në qoftë se të fillojë numërimi në 0. 

Pra, nëse ne përdorim një program se thirrjet merrni string, dhe ne kemi marrë një varg nga njeriu si I e quajtur Zamyla, Z-A-M-Y-L-A, si në botë bën mbani kompjuterin udhë e cila byte, e cila copë e kujtesës, takon cilat string? Me fjalë të tjera, në qoftë se ne të vazhdojë të shtypni një emër tjetër në kompjuter, si ky Andi, duke e quajtur marrë string për herë të dytë, A-N-D-I duhet të përfundojë deri në memorie kompjuteri, si dhe. Por si? 

E pra, ajo rezulton se nën të individualitet, çfarë bën kur C ruajtjen strings se llojet e njeriut, ose atë vijnë nga ndonjë burim tjetër, është ajo përcakton fundin e tyre me një backslash veçantë character-- 0, e cila është vetëm një mënyrë të veçantë për të thënë 80 bit në një rresht. 

Pra A-- ky është kujtojnë numrin 97. Pra, disa model i 8 bit paraqet numrin decimal 97. Kjo backslash 0 është fjalë për fjalë numri 0, nul alias, N-U-L, ndryshe nga më parë, N-U-L-L, të cilën kemi biseduar rreth. Por tani për tani, vetëm e di se kjo backslash 0 është vetëm 80 bit në një rresht. 

Dhe kjo është vetëm kjo linjë në rërë që thotë se asgjë në të majtë i takon një varg, apo një lloj të dhënave. Dhe çdo gjë në të djathtë takon diçka tjetër. emri Andi, ndërkohë, e cila sapo visually ndodh për të përfunduar për në linjën tjetër, por kjo është vetëm një detaj estetike, në mënyrë të ngjashme është nul ndërpritet. 

Kjo është një varg i një karaktere A-N-D-I, plus një karakter të fshehtë i pestë, të gjitha 0 bit, që vetëm Në kufirin në fund të emrit të andi si. Dhe në qoftë se ne e quajmë të string për të tretën herë në kompjuter për të marrë një varg të tillë Maria, M-A-R-I-A, në mënyrë të ngjashme është Maria së Emri nul ndërpritet me backslash 0. 

Kjo është krejtësisht e ndryshme nga se si një kompjuter do të zakonisht ruajtur një numër të plotë ose një noton, ose tjetër Llojet e të dhënave ende, sepse kujtojnë, një numër i plotë është zakonisht 32 bit, ose 4 bytes, ose ndoshta edhe 64 bit, ose tetë bytes. Por shumë primitives në një kompjuter në një gjuhë programimi kanë një numër të caktuar të bytes nën hood-- ndoshta 1, ndoshta 2, ndoshta 4, ndoshta 8. 

Por vargjet, me dashje, kanë një Numri dinamike e karaktereve. Ju nuk e dini që më parë, deri në llojet e njeriut në Z-A-M-Y-L-A, ose M-A-R-I-A, ose A-N-D-I. Ju nuk e dini sa herë përdoruesi është duke shkuar për të goditur tastierë. Prandaj, ju nuk e dini se si shumë karaktere paraprakisht ju do të jeni nevojë. 

Dhe kështu C vetëm lloji i lë si një Breadcrumb sekret nën kapuç ne fund te vargut. Pas ruajtjes Z-A-M-Y-L-A në memories, ajo gjithashtu vetëm vë ekuivalentin e një periudhë. Në fund të dënimit, kjo e vë 80 pjesë, në mënyrë që të mbani mend se ku Zamyla fillon dhe mbaron. 

Pra, çfarë është lidhja, pra, për këtë program? Ky program këtu, Stirling, është thjesht një mekanizëm për marrjen e një varg nga ana e përdoruesit, linjë 6. Linja 7, unë deklaroj një ndryshore quajtur n dhe vendosur ajo e barabartë me 0. 

Dhe pastaj në linjë 8, unë thjesht e pyeti Pyetja, ndërsa karakteri N-th bën jo të barabartë të gjithë 0 bits-- me fjalë të tjera, nuk ka barabartë kjo special Karakteri, backslash 0, e cila ishte vetëm se character-- veçantë nul të shkojnë përpara dhe vetëm ardhura n. 

Dhe vazhdojmë të bëjmë atë, dhe për të mbajtur duke e bërë atë, dhe për të mbajtur duke bërë atë. Dhe kështu, edhe pse në e kaluara ne kemi përdorur i, është e përkryer gjobë semantikisht për të përdorur n, në qoftë se ju jeni vetëm duke u përpjekur për numërimin këtë herë me qëllim, dhe vetëm dëshironi të telefononi atë n. Pra, kjo vetëm e mban duke i kërkuar pyetjen, është karakteri N-th e s të gjitha 0s? Nëse jo, shikoni me sy tjetër, shikoni të ardhshëm, të shohim në një tjetër, shikoni të ardhshëm. 

Por, sa më shpejt që ju shihni backslash 0, kjo linjë loop-- 9 nëpërmjet 11-- ndalet. Ju thyer nga lak, ndërsa, duke lënë brenda asaj n ndryshueshme një akuzë total prej të gjitha të karaktere në vargun e keni parë, duke shtypjen atë. Pra, le të provoni këtë. 

Më lejoni të shkojnë përpara dhe, pa duke përdorur funksionin Stirling, por vetëm duke përdorur versionin tim homegrown këtu quhet Stirling, më lejoni të shkoj përpara dhe të drejtuar Stirling, shkruani diçka si Zamyla, të cilën unë e di që më parë është gjashtë karaktere. Le të shohim nëse ajo punon. Në të vërtetë, kjo është gjashtë. Le të përpiqemi me Rob, tre karaktere, tre karaktere, si edhe, dhe kështu me radhë. Pra, kjo është e gjitha që po ndodh në nën kapuç. Dhe vini re lidhjet, pastaj me jave parë e klasës, ku kemi biseduar për diçka si abstraksion, e cila është vetëm ky layering e ideve, ose kompleksitetin, në krye të parimeve themelore. Këtu, ne jemi lloj i kërkuar nën kapuç e Stirling, kështu që të flasin, të kuptoj se, si do të zbatohet? 

Dhe ne mund të ri-zbatuar atë vetë. Por ne jemi duke shkuar kurrë të ri-zbatuar Stirling. Ne jemi vetëm duke shkuar për të përdorin Stirling në mënyrë që në fakt të marrë disa strings gjatësi. 

Por nuk ka asnjë magji nën kapuç. Nëse ju e dini se nën individualitet, një varg është vetëm një sekuencë e karaktereve. Dhe kjo sekuencë e karaktere të gjithë mund të adresohen numerikisht me kllapa 0, kllapa 1, 2 kllapa, dhe ju e di që në fund të një varg është një karakter të veçantë, ju mund të kuptoj se se si të bëjë më asgjë në një program, pasi të gjitha ajo boils poshtë për është lexim dhe shkrim kujtesës. Kjo është, duke ndryshuar dhe duke kërkuar në kujtesë, ose duke lëvizur gjërat rreth në kujtesë, shtypjen gjëra në ekran, e kështu me radhë. 

Pra, tani le të përdorim këtë newfound të kuptuarit e asaj që në fakt vargjet janë nën kapuç, dhe zhvishem përsëri një shtresë tjetër se deri tani ne kemi janë injoruar krejtësisht. Në veçanti, çdo kohë ne kemi zbatuar një program, ne kemi pasur këtë linjë të kodit pranë krye deklaruar kryesore. Dhe ne kemi specifikuar pavlefshme int kryesore. 

Dhe kjo pavlefshëm brenda kllapa ka qenë duke thënë gjithë këtë kohë që kryesore vetë nuk ka marrë ndonjë argumente. Çdo input që kryesor është do të marrë nga përdoruesi duhet të vijë nga disa të tjera mekanizëm, si get int, ose të merrni noton, ose të merrni varg, apo ndonjë funksion tjetër. Por kjo rezulton se Kur ju shkruani një program, në të vërtetë ju mund të specifikoni se ky program do të marrë inpute nga njeriu në vetë rreshtin e komandave. 

Me fjalë të tjera, edhe pse deri tani kanë qenë në drejtimin e vetëm ./hello përshëndetje ose programe të ngjashme, të gjithë e programe të tjera që ne kemi qenë duke përdorur, që ne vetë nuk ka shkruar, kanë qenë duke marrë, me sa duket, command line argumente të gjëra të tilla si make. Ju thoni diçka si make, dhe pastaj një fjalë të dytë. Ose tingëllimë, që thonë tingëllimë, dhe pastaj një fjalë të dytë, emri i një file. 

Ose edhe RM, ose CP, si ju mund të kanë parë ose përdorur tashmë të fshijnë ose kopje fotografi. Të gjithë ata që marrin të ashtuquajturit command line argumente të fjalë të tjera në ftim terminal. Por deri tani, ne vetë nuk kanë pasur ky luks të marrë të dhëna nga Përdorues kur ai ose ajo në fakt shkon programi vetë në rreshtin e komandave. 

Por ne mund ta bëjmë këtë duke ri-deklaruar kryesore duke shkuar përpara, jo si ka pavlefshme në kllapa, por këto dy argumente instead-- parë një numër të plotë, dhe diçka e dytë e re, diçka që ne jemi duke shkuar për të thirrur një grup, diçka e ngjashme në frymë me atë që pamë në Scratch si një listë, por një grup i vargjeve, si ne së shpejti do të shohim. Por le të shohim këtë duke Për shembull, para se ne dallojë saktësisht se çfarë do të thotë. 

Pra, nëse unë shkoj në CS50 IDE këtu, unë kam shkuar përpara dhe ka deklaruar në një skedar të quajtur argv0.c template në vijim. Dhe vini re e vetmja gjë kjo është e ndryshme deri tani është që unë kam ndryshuar pavlefshme të int argc string argv kllapa të hapur, të ngushtë kllapa. Dhe vini re tani për tani, nuk ka asgjë brenda këtyre kllapa. 

Nuk ka asnjë numër. Dhe nuk ka asnjë i, ose n, apo ndonjë letër tjetër. Unë jam vetëm duke përdorur kllapa katrore për tani, për arsye ne do të vijnë kthehet në një moment të vetëm. 

Dhe tani ajo që unë jam duke shkuar për të bërë është kjo. Nëse argc barabartë barabartë 2-- dhe kujtojnë se është e barabartë është e barabartë është operatori barazia krahasuar të majtë dhe të djathtë për barazi. Kjo nuk është detyrë operator, i cili është shenja e vetme të barabartë, që do të thotë kopje nga e drejta për të majtë disa vlera. 

Nëse argc barabartë është e barabartë me 2, unë dua të të themi, printf, hello, për qind, linjë e re, dhe pastaj plug in-- dhe këtu është e re bracket trick-- argv 1, për arsye që ne do të kthehen në një moment. Tjetër në qoftë se nuk ka argc të barabartë 2, ju e dini se çfarë? Le të shkojnë përpara dhe, si zakonisht, të shtypura nga Hello World pa zëvendësim. 

Pra, kjo do të duket se në qoftë se argc, e cila qëndron për numërimin e argumentit, është e barabartë me 2, Unë jam duke shkuar për të shkruar përshëndetje diçka ose të tjera. Përndryshe, si parazgjedhje, unë jam do të shtypura përshëndetje botën. Pra, çfarë do të thotë kjo? 

E pra, më lejoni të shkojnë përpara dhe për të shpëtuar këtë fotografi, dhe pastaj të bëjë të argv0, dhe pastaj ./argv0, Enter. Dhe ai thotë Hello World. Tani, pse është kjo? 

E pra, ajo rezulton çdo kohë që ju drejtuar një program në rreshtin e komandave, ju jeni të mbushur në atë që ne do të në përgjithësi e quajnë një vektor argumentin. Me fjalë të tjera, automatikisht kompjuter, sistemi operativ, do të dorëzojë për programin tuaj në vetvete një listë e të gjitha fjalët se njeriut shtypur në e shpejtë, në rast se ju programues doni të bëni diçka me këtë informacion. Dhe në këtë rast, vetëm fjalë Unë e kam shtypur në ftim është ./argv0. 

Dhe kështu që numri i argumenteve që është duke kaluar në programin tim është vetëm një. Me fjalë të tjera, argumenti numërimin, i njohur ndryshe si argc këtu si një numër i plotë, është vetëm një. Një, natyrisht, nuk ka të barabartë me dy. Dhe kështu kjo është ajo që shtyp, përshëndetje botën. 

Por më lejoni të përfitoj nga ky diku. Më lejoni të them, argv0. Dhe pastaj si për Maria? Dhe pastaj goditi Enter. 

Dhe njoftim se çfarë magjike ndodh këtu. Tani, në vend të botës përshëndetje, unë kam ndryshuar sjelljen e këtij programi duke marrë të dhëna jo nga get string apo ndonjë funksion tjetër, por nga, me sa duket, komandën e mia në vetvete, atë që unë fillimisht shtypur në. Dhe unë mund të luajë këtë lojë përsëri ndryshuar atë për Stelios, për shembull. 

Dhe tani shoh një emër tjetër ende. Dhe këtu, unë mund të them Andi. Dhe unë mund të them Zamyla. Dhe ne mund të luajnë këtë lojë gjatë gjithë ditës, vetëm me mbylljen në vlera të ndryshme, deri sa do të sigurojë tamam dy fjalë në e shpejtë, të tilla që argc, argumenti im numërimin, është 2. 

A shihni se emri i mbyllën në printf, për këtë gjendje këtu? Pra, ne duket se kanë tani aftësia ekspresive të marrë të dhëna nga një tjetër mekanizëm, nga e ashtuquajtura command line, në vend që të presin derisa përdoruesi shkon programi, dhe pastaj të shpejtë atij ose asaj duke përdorur diçka si get varg. 

Pra, çfarë është kjo? Argc, përsëri, është vetëm një numër të plotë, numri i words-- argumente të që përdoruesi dhënë më së shpejtë, në dritaren e terminalit, duke përfshirë edhe emrin e programit. Pra ./argv0 ynë është, në mënyrë efektive, emri i programit, ose si unë të drejtuar programin. 

Që ka rëndësi si një fjalë. Pra argc do të jetë 1. Por, kur unë shkruaj Stelios, ose Andi, ose Zamyla, apo Maria, kjo do të thotë numërimi argumenti është dy. Dhe kështu që tani ka dy fjalë kaluar në. 

Dhe njoftimi, ne mund të vazhdojmë këtë logjikë. Nëse unë them në fakt diçka si Zamyla Chan, një emër i plotë, duke kaluar tre argumente në total, tani ajo thotë parazgjedhur përsëri, sepse, natyrisht, 3 nuk ka të barabartë 2. 

Dhe kështu në këtë mënyrë, nuk kam qasje nëpërmjet argv këtë argument të ri që ne mund teknikisht të telefononi çdo gjë që duam. Por nga Konventa, është e argv dhe argc, respektivisht. Argv, argumenti vektoriale, është lloji e një sinonim për një programim funksion në C quhet një grup. 

Një grup është një listë e vlerave të ngjashme përsëri, për të mbështetur, për të mbështetur, për të pasme. Me fjalë të tjera, në qoftë se një është e drejtë këtu në RAM, një tjetër është e drejtë tjetër për të, dhe të drejtë tjetër për të. Ata nuk janë të gjithë vendin. Dhe se skenari i fundit, ku gjëra janë në të gjithë vendin në kujtesë, në fakt mund të jetë një tipar i fuqishëm. Por ne do të kthehen për të se kur flasim për strukturat e njohës të dhënave. Tani për tani, një grup është vetëm një copë e kujtesës afërt, secila nga elementet e të cilit janë përsëri, për të mbështetur, për të mbështetur, për të mbështetur, dhe në përgjithësi të të njëjtit lloj. 

Pra, nëse ju mendoni rreth, nga një moment më parë, ajo është një varg? E pra, një varg, si Zamyla, Z-A-M-Y-L-A është, teknikisht, vetëm një grup. Është një grup të karaktereve. 

Dhe kështu që nëse ne me të vërtetë të tërheqë këtë, si unë bëri më parë, si një copë e kujtesës, rezulton se secili prej tyre Karakteret merr një bajt. Dhe pastaj nuk ka që të veçantë Karakteri sentinel, backslash 0, ose të gjitha tetë 0 bit, që Në kufirin fundin e atë varg. Pra, një string, ajo kthehet jashtë, të japin kuotën varg siç janë quajtur ato, është vetëm një grup i chara-- char qenë një lloj aktuale e të dhënave. 

Dhe tani argv, meanwhile-- le të kthehemi në program. Argv, edhe pse ne shohim fjalën string këtu, nuk është një varg në vetvete. Argv, argumenti vector, është një grup i strings. 

Pra, ashtu si ju mund të ketë një rrjet të karaktere, ju mund të ketë nivel më të lartë, një grup i strings-- kështu, për shembull, kur kam shtypur një moment më parë ./argv0 argv0, hapësirë ​​Z-A-M-Y-L-A, I pretendohet se argv kishte dy vargje në ./argv0 arsyetimet tuaja, dhe Z-A-M-Y-L-A. Në fjalë të tjera, argc ishte 2. Pse eshte ajo? 

E pra, në mënyrë efektive, çfarë po ndodh në është se secili nga këto vargjet është, natyrisht, një grup të karaktereve si më parë, secili e të cilit karaktere merr një byte. Dhe mos ngatërruar 0 aktual në emrin e programit me 0, që do të thotë të gjitha 80 bit. Dhe Zamyla, ndërkohë, është ende edhe një grup të karaktereve. 

Pra, në fund të ditës, me të vërtetë duket si ky nën kapuç. Por argv, nga natyra se si kryesore Punimet, lejon mua për të përfunduar të gjithë këtë deri në, nëse ju do të, një grup më të madh se, në qoftë se ne pak më shumë se të lehtësuar ajo foto duket si dhe nuk mjaft të nxjerrë atë në shkallë deri atje, ky grup është vetëm i madhësisë 2, i pari element i cili përmban një varg, elementi i dytë i i cili përmban një varg. Dhe, nga ana tjetër, në qoftë se ju lloj i zoom në çdo nga ato vargjet, çfarë shikoni nën kapuç është se çdo string është vetëm një grup të karaktereve. 

Tani, ashtu si me vargjet, ne ishim në gjendje për të marrë qasje për karakterin e i-të në një varg përdorur atë kllapa katrore simbol. Në mënyrë të ngjashme, me vargjeve në përgjithësi, mund të presim përdorin katror kllapa simbol për të marrë në çdo numër të strings në një grup? Për shembull, le të më të shkojnë përpara dhe të bëjë këtë. 

Më lejoni të shkojnë përpara dhe për të krijuar argv1.c, e cila është pak më ndryshe këtë herë. Në vend të kontrolluar për argc2, Unë jam duke shkuar për të bërë këtë vend. Për int marr 0, I është më pak se argc, unë plus plus, dhe pastaj të shtypura nga brenda të kësaj, qind s, linjë e re, dhe pastaj argv kllapa i. 

Pra, me fjalë të tjera, unë nuk jam që kanë të bëjnë me karaktere të veçanta në këtë moment. Argv, siç kuptohet nga këto shesh bosh formatimin e teksteve në të djathtë të emrit të argv, do të thotë argv është një grup i strings. Dhe argc është vetëm një int. 

Kjo linjë këtu, 6, është duke thënë grup i barabartë me 0. Numërimi të gjithë rrugën deri në, por duke mos përfshirë, argc. Dhe pastaj në çdo përsëritje, shtypura nga një varg. Çfarë string? 

Vargu i-th në argv. Pra, ndërsa para se unë kam qenë duke përdorur kllapa katrore simbol për të marrë në lth karakter në një varg, tani Unë jam duke përdorur simbol kllapa katrore për të marrë në varg ith në një rrjet. Pra, kjo është lloj i një shtresë më sipër, konceptualisht. 

Dhe kështu që çfarë është zoti në lidhje me këtë Programi tani, në qoftë se unë përpilojnë argv1, dhe pastaj të bëjë ./argv1, dhe pastaj shtypni në diçka si foo bar Baz, të cilat janë tre fjalët parazgjedhur që një shkencëtar kompjuteri arrin për çdo kohë ai ose ajo ka nevojë për disa fjalë placeholder, dhe hit Enter, secila prej këtyre fjalëve, duke përfshirë edhe emrin e programit, e cila është në argv në vendin e parë, përfundon duke u shtypur në një kohë. Dhe në qoftë se kam ndryshuar këtë, dhe unë them diçka si argv1 Zamyla Chan, ne kemi marrë të tre nga ata fjalë, e cila është argv0, argv1, argv2, sepse në këtë Rasti argc, numërimi, është 3. 

Por ajo që është i zoti është në qoftë se ju e kuptoni që argv është vetëm një grup i vargjeve, dhe ju e kuptoni se një varg është një grup i karaktereve, ne mund të vërtetë lloji i përdorin këtë square bracket Shënim i herë të shumta për të zgjedhur një varg, dhe pastaj zgjidhni një karakter në varg, zhytjen në thellë si më poshtë. Në këtë shembull, më lejoni të shkoj përpara dhe e quajmë këtë argv2.c. Dhe në këtë shembull, më lejoni të shkoj përpara dhe të bëjë following-- për int i merrni 0, i është më pak se argc, i plus plus, ashtu si më parë. Pra, në words-- tjera dhe tani kjo po bëhet mjaft e komplikuar. Atëherë unë jam duke shkuar për të thënë iterate mbi vargjet në argv, si një koment për veten time. Dhe atëherë unë jam duke shkuar të ketë një mbivendosur për lak, të cilat ju ndoshta kanë bërë, ose konsiderohet duke bërë, në Scratch, ku Unë jam duke shkuar për të thënë int-- Jam nuk do të përdorin, përsëri, sepse unë nuk dua të hije, ose lloj prishësh I ekzistues. 

Unë jam duke shkuar për të, në vend të kësaj, thonë j, sepse kjo është go ime për ndryshore pas i, kur unë jam vetëm duke u përpjekur për të numërimin e numrave të thjeshtë. Për j merr 0-- dhe gjithashtu, n, do të marrë gjatësinë ashpër e kllapa argv i, aq sa j është më pak se m, j plus plus, të bëjë të mëposhtme. Dhe këtu është pjesa interesante. 

Shtypura nga një karakter dhe një linjë të re, mbylljen në kllapa argv i, j kllapa. OK, kështu që më lejoni të shtoj disa komente ketu. Iterate mbi karaktere në vargun e tanishëm, print karakter j-th në vargun e i-të. Pra, tani, le të konsiderojmë çfarë do të thotë këto komente. 

Iterate mbi vargjet në argv-- sa vargjet janë në argv, e cila është një grup? Argc shumë, kështu që unë jam iterating nga i barabartë 0 deri në argc. Ndërkohë, sa karaktere janë në vargun e i-të në argv? 

E pra, për të marrë këtë përgjigje, I vetëm thirrje gjatësi string në aktuale string I kujdesit lidhje, e cila është argv kllapa i. Dhe unë jam duke shkuar për të ruajtur përkohësisht që Vlera në n, vetëm për qëllime caching, për të kujtuar atë për efikasitet. Dhe atëherë unë jam duke shkuar nisja j në 0, do të mbajë për aq kohë sa j është më pak se n, dhe në çdo j përsëritje rritje. 

Dhe pastaj në këtu, për komenti im on line 12, shtypura nga një karakter, i ndjekur nga një vijë e re, kllapa specifike argv i më jep varg i-th në argv-- kështu fjalën e parë, Fjala e dytë, fjala e tretë, çfarëdo. Dhe pastaj zhytet j në të thella, dhe merr me karakter j-th e asaj fjale. Dhe kështu, në fakt, ju mund të trajtoni argv si një multi-dimensional, si një dy-dimensionale, grup, ku çdo fjalë lloj duket si kjo në mendjen e juaj sy, dhe çdo karakter është lloj i përbërë në një kolonë, në qoftë se ndihmon. 

Në të vërtetë, kur ne vë në lojë kjo përveç në javët e ardhshme, ajo do të jetë pak më të sofistikuara se kaq. Por ju mund të vërtetë mendojnë se, tani për tani, pasi vetëm këtë dy-dimensionale array, ku një nivel i saj është e gjitha vargjet. Dhe pastaj nëse ju zhyten në më të thellë, ju mund të merrni në karaktere të veçanta aty duke përdorur këtë simbol këtu. 

Pra, çfarë është efekti neto? Më lejoni të shkojnë përpara dhe të mallkuar argv2-- atë. Kam bërë një gabim këtu. Implicite shpalljen e Funksioni Biblioteka Stirling. Pra, të gjithë këtë kohë, është e ndoshta e përshtatshme që ne jemi lloj i përfunduar pikërisht aty ku kemi filluar. 

I dehur, në mënyrë implicite deklaruar Funksioni Biblioteka Stirling. OK, prit një minutë. Mbaj mend se, në veçanti që është e drejtë këtu. Unë kam nevojë për të përfshirë string në ky version i programit. 

Më lejoni të shkojnë përpara dhe të përfshijë string, përveç kësaj, të shkojnë përpara dhe përpiluar argv2. Dhe tani, këtu ne do të shkojmë, të argv2, Enter. Dhe pse kjo është pak fshehtë në shikim të parë, vini re se, në të vërtetë, ajo që është shtypur është dot argv2. 

Por në qoftë se unë lloji disa fjalë pas të shpejtë, si argv2 Zamyla Chan, Enter, edhe pak fshehtë në shikim të parë. Por nëse ne lëviz back up, ./argv2 Z-A-M-Y-L-A C-H-A-N. Pra, ne kemi përsëritur shumë se çdo fjalë. Dhe, nga ana tjetër, ne kemi përsëritur gjatë çdo karakter në një fjalë. 

Tani, pas gjithë kësaj, të kuptojë se nuk ka një detaj tjetër që kemi qenë e llojit e injoruar këtë herë të gjithë. Ne vetëm ngacmohem përveç asaj që inputet kryesore mund të jetë? Po në lidhje me prodhimin kryesor të? 

E gjithë kjo kohë, ne kemi qenë vetëm kopjimi dhe pasting int fjala para kryesore, edhe pse ju mund të shihni online, nganjëherë gabimisht në versionet më të vjetra e C dhe hartuesit, që ata thonë se i pavlefshëm, ose asgjë në të gjitha. Por, në të vërtetë, për versioni i C që ne jemi duke përdorur, C 11, apo 2011 të realizuar se ajo duhet të jetë int. Dhe kjo duhet të jetë ose pavlefshme ose argc dhe argv këtu. 

Por pse int main? Çfarë është ajo në të vërtetë kthyer? E pra, ajo rezulton të gjithë këtë kohë, çdo herë që ju keni shkruar një kryesore të programit është gjithmonë e kthyer diçka. Por ajo është bërë në mënyrë të fshehtë. 

Kjo gjë është një int, si linjë 5 sugjeron. Por çfarë int? E pra, nuk është kjo konventë në programimin, ku në qoftë se asgjë nuk ka shkuar keq dhe të gjithë është i mirë, Programet dhe funksionet në përgjithësi return-- disi counterintuitively-- 0. 0 në përgjithësi nënkupton gjithë është i mirë. Pra, edhe pse ju mendoni se e atë si false në shumë kontekste, ai në fakt në përgjithësi do të thotë një gjë e mirë 

Ndërkohë, nëse një program kthehet 1, ose negative 1, ose 5, ose negative 42, ose çdo non-0 vlerë, që në përgjithësi nënkupton se diçka ka shkuar keq. Në fakt, në tuaj Mac ose PC, ju mund të keni parë në të vërtetë një mesazh gabimi, ku atë thotë diçka apo të tjera, gabim Kodi negative 42, apo gabim kodin 23, ose diçka të tillë. Ky numër është zakonisht vetëm një aluzion për programues, ose në kompani që e bëri software, çfarë shkoi keq dhe pse, në mënyrë që ata mund të shikojnë nëpërmjet Dokumentacioni ose kodi i tyre, dhe të kuptoj se çfarë Gabim në fakt do të thotë. Kjo nuk është në përgjithësi e dobishme për ne fund përdoruesit. 

Por kur kthehet kryesore 0, gjithçka është mirë. Dhe në qoftë se ju nuk e specifikon çfarë kryesor duhet të kthehen, ajo do vetëm automatikisht kthehet 0 për ju. Por, duke u kthyer diçka tjetër fakt është e dobishme. 

Në këtë program të fundit, më lejoni të shkojnë përpara dhe të quajmë këtë exit.c, dhe futjen e fundit të sotme tema, i njohur si një kod gabimi. Më lejoni të shkojnë përpara dhe të përfshijë tonë njohur files deri të lartë, të bëjë int main. Dhe këtë herë, le ta bëjmë int argc, string argv, dhe me kllapa e mia të thotë se kjo është në rrjet. Dhe pastaj më lejoni vetëm të bëjë një kontroll mendje e shëndoshë. Këtë herë, në qoftë se nuk ka argc të barabartë 2, atëherë ju e dini se çfarë? Harroje. Unë jam duke shkuar për të thënë se, hej, user, ju jeni të humbur argumentin linjë komandës n backslash. 

Dhe pastaj kjo është ajo. Unë dua të dalë. Unë jam duke shkuar për të preemptively, dhe para kohe me të vërtetë, kthimi diçka tjetër se sa numri 1. Go vlerës për herë të parë gabim që mund të ndodhë është 1. Nëse ju keni disa të tjera të gabuara situata që mund të ndodhë, ju mund të thoni kthimin 2 ose kthimin 3, ose ndoshta edhe negative 1 ose negative 2. 

Këto janë vetëm kodet e daljes që janë, në përgjithësi, vetëm të dobishme për programuese, ose Kompania që është anijeve software. Por fakti që kjo është Nuk 0 është ajo që është e rëndësishme. Pra, nëse në këtë program, unë dua të të garantojë se ky program vetëm punon në qoftë se përdoruesi jep mua me një akuzë e argumentit të dy, emri i programit, dhe disa të tjera fjalë, unë mund të zbatojë sa më shumë si më poshtë, çirrem në përdorues me printf thënë, humbur argumentin command line, kthehen 1. Kjo thjesht do të menjëherë lë programin. 

Vetëm në qoftë se argc është e barabartë me 2 do të merrni poshtë këtu, në të cilën pikë unë jam duke shkuar për të thënë, përshëndetje për qind s, backslash n, argv1. Me fjalë të tjera, unë jam mos shkuar pas argv 0, e cila është vetëm emri i programit. Unë dua të shtypura nga hello, presje, fjala e dytë që njeriu shtypur. Dhe në këtë rast në line 13, gjithçka është mirë. 

Unë e di se argc është 2 logjikisht nga ky program. Unë jam duke shkuar për të shkuar përpara dhe të kthehet 0. Si një mënjanë, mbani në mend se kjo është e vërtetë në Scratch si. 

Logjikisht, unë mund ta bëjë këtë dhe encapsulate këto rreshta i kodit në këtë klauzolë tjetër këtu. Por kjo është lloj i panevojshme indenting kodin tim. Dhe unë dua të bëjë super qartë se pa marrë parasysh se çfarë, nga default, përshëndetje diçka do të shtypura, për aq kohë sa përdoruesi bashkëpunon. 

Kështu që është shumë e zakonshme për të përdorur një kusht, vetëm një rast, për të kapur disa të gabuar Situata, dhe pastaj dalje. Dhe pastaj, për sa kohë të gjitha është mirë, nuk kanë një tjetër, por vetëm të ketë kodin e jashtë se në qoftë se, për shkak se është ekuivalente në këtë rast i veçantë, logjikisht. Kështu që unë jam kthyer 0, vetëm për të në mënyrë të qartë tregon gjithë është i mirë. 

Nëse unë harruar kthimin 0, kjo do të të supozohet automatikisht për mua. Por tani që unë jam kthyer një në të paktën këtë rast, Unë jam duke shkuar për të, për masë të mirë dhe qartësia, kthehet 0 në këtë rast. Kështu që tani më lejoni të shkoj përpara dhe të bëjë dalje, e cila është një Segue përkryer për të lënë vetëm. 

Por të bëjë dalje, dhe më lejoni të shkoj përpara dhe të bëjë ./exit, Enter. Dhe programi yelled në mua, humbur argumentin command line. OK, më lejoni të bashkëpunojnë. 

Më lejoni në vend të bëjë ./exit, David, Enter. Dhe tani ai thotë, përshëndetje David. Dhe normalisht ju nuk do të shihni këtë. 

Por kjo rezulton se ka një mënyrë të veçantë në Linux që në fakt të parë me atë dalje code një program exited. Ndonjëherë në një grafik Bota si Mac OS ose Windows, ju shikoni vetëm këto numra kur një mesazh gabimi pops up në ekran dhe programues ju tregon këtë numër. Por në qoftë se ne duam të shohim se çfarë gabimi mesazhi është, ne mund të bëjmë atë here-- kështu ./exit, Enter, print humbur argumentin command line. 

Nëse unë tani të bëjë $ echo ?, e cila është ridiculously fshehtë kërkim. Por $? është yshtje magjike që thotë, hej, kompjuter, më tregoni se çfarë të mëparshme Kodi dalja programit ishte. Dhe unë hit Enter. Shoh 1, sepse kjo është ajo që unë tha funksionin tim kryesor për t'u kthyer. 

Ndërkohë, në qoftë se unë bëj ./exit Davidin, dhe hit Enter, unë shoh, Hello Davidin. Dhe në qoftë se unë tani bëj $ echo ?, shoh përshëndetje 0. Dhe kështu kjo në fakt do të jetë informacion të vlefshëm në kontekstin e Rregullues, jo kështu më shumë se ju, njeriu, do të kujdesit. Por Rregullues dhe të tjera Programet ne do të përdorim këtë semestër shpesh do të shikojmë në atë numër, edhe pse është e fshehur lloj larg nëse ju shikoni për atë, për të të përcaktuar nëse një program të apo jo Ekzekutimi i saktë apo i pasaktë. 

Dhe kështu që na sjell në kjo, në fund të ditë. Ne kemi filluar sot duke shikuar në debugging, dhe nga ana tjetër në kurs në vetvete, dhe pastaj shumë interesant, teknikisht nën kapuç në atë vargjet janë, të cilat zgjasin Javën ne vetëm mori për të dhënë, dhe sigurisht mori me vete për të dhënë në Scratch. 

Ne pastaj shikoi se si ne mund të hyni karaktere individuale në një varg, dhe pastaj përsëri mori një nivel më të lartë shikoni në gjëra, duke kërkuar se si well-- në qoftë se ne duam që të merrni në individuale elemente në një listë si strukturë, Nuk mund ta bëjmë këtë me vargjet e shumta? Dhe ne mund të me argumente command line. Por kjo foto këtu i vetëm kuti është demonstrative e kësaj ideje të përgjithshme e një grup, ose një lista, ose nje vektor. Dhe në varësi të konteksti, të gjitha këto fjalë thotë gjëra paksa të ndryshme. Pra në C, ne jemi vetëm duke shkuar për të folur për një grup. Dhe një koleksion është një copë e memories, secili prej të cilëve është Elementet janë puqur, mbrapa, për të mbështetur, për të mbështetur, për të pasme. 

Dhe këto elemente janë, në përgjithësi, të të njëjtit lloj të të dhënave, karakteri, karakter, karakter, karakter, ose string, string, string, string, ose int, int, int, çfarëdo qoftë ajo ne jemi duke u përpjekur për të ruajtur. Por në fund të ditës, kjo eshte ajo që duket si konceptualisht. Ju jeni duke marrë tuaj memorie kompjuteri ose RAM. Dhe ju jeni gdhendje atë në kuti identike mesme, të cilat janë kthyer, për të mbështetur, për të përsëri, për të mbështetur në këtë mënyrë. 

Dhe çfarë është e bukur për kjo ide, dhe fakti që ne mund të shprehin vlerat në këtë mënyrë me të parë të strukturave tona të të dhënave në klasë, do të thotë që ne mund të fillojë për të zgjidhur problemet me kodin që erdhi në mënyrë intuitive në javë 0. Ju do të kujtojnë në telefon shembull libër, ku kemi përdorur një ndarje dhe të pushtuar, ose një kërkim algorithm binar, të analizoj me një e tërë bandë e emra dhe numra. Por ne supozuar, risjell, se kjo Libri i telefonit është renditur tashmë, se dikush tjetër kishte tashmë artistikisht dhënë out-- një listë të emrave dhe numbers-- si të rendin alfabetik ato. Dhe tani që në C ne, gjithashtu, kanë aftësinë për të hedhur gjërat, të mos fizikisht në një libër telefoni por praktikisht në një kompjuter të kujtesës, do të jemi në gjendje javën e ardhshme për të futur përsëri this-- parë e strukturave tona të të dhënave në një array-- por më e rëndësishmja, kompjuter aktuale algoritme shkenca zbatuar në kod, me të cilat ne mund të ruajë të dhëna në strukturat si kjo, dhe pastaj të fillojë për të manipuluar atë, dhe që në fakt zgjidhjen e problemeve me të, dhe për të ndërtuar në krye të kësaj, në fund të fundit, programe në C, në Python, në JavaScript, querying bazat e të dhënave me SQL? 

Dhe ne do të shohim se të gjitha këto ide të ndryshme bashkoj. Por tani për tani, kujtojnë se domain që ne kemi prezantuar sot ishte kjo gjë këtu, dhe botën e kriptografisë. Dhe në mesin e problemeve të ardhshme ju veten do të zgjidhë është arti i kriptografisë, përpiqen dhe të përpiqen de- informacionit dhe ciphering dhe deshifrimin tekst, dhe duke marrë në fund të fundit se ju tani e dini se çfarë është nën kapuç kështu që kur ju shikoni ose për të marrë një mesazh si ky, ju vetë mund të deshifroj atë. E gjithë kjo, dhe koha më e ardhshme. 

[VIDEO rishikim] 

-Mover Vetëm arriti. Unë jam duke shkuar për të shkuar vizitë profesor i tij kolegj. Yep. Hi. Kjo është që ju. Prisni! David. Unë jam vetëm duke u përpjekur të kuptoj se çfarë ka ndodhur me ju. Ju lutemi, çdo gjë mund të ndihmojë. Ju keni qenë kolegji i tij shokun, apo jo? Ti ishe aty me të kur ai përfundoi projektin CS50? 

[MUSIC Duke luajtur] 

-Kjo Ishte CS50. 

Unë e dua këtë vend. 

-Eat Up. Ne jemi duke shkuar nga biznesi. 

[END rishikim] 