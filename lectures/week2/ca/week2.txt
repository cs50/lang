[MÚSICA] 

DAVID J. Malan: Està bé. Això és CS50 i això és l'inici de la Setmana 2. I et recordo que durant l'últim parell de setmanes, hem estat la introducció de l'ordinador la ciència i, al seu torn, la programació. 

I vam començar la història per mitjà de Scratch, que llenguatge gràfic del Laboratori de Mitjans del MIT. I després, més recentment, la setmana passada, oi introduir un higher-- 1 llenguatge de baix nivell conegut com C, cosa que és purament textual. I, de fet, l'última vegada que explorat dins d'aquest context una sèrie de conceptes. 

Això, recordo, va ser el primer programa mirem. I aquest programa, simplement, imprimeix, "hola, món". Però hi ha tant màgia aparent passant. Hi ha aquesta #include amb aquests suports d'angle. Hi ha int. Hi ha (void). Hi ha parèntesis, claudàtors, punt i coma, i molt més. 

I així, cal recordar que vam introduir les ratllades perquè poguéssim, si pot ser, veure més enllà que la sintaxi, les coses que en realitat no és tot el que intel·lectualment interessant, però des del principi és, en absolut, una mica complicat per embolicar la seva ment voltant. I, de fet, un dels més comuns les coses des del principi en una classe de programació, especialment per als menys còmode i sentir-se frustrat per i disparat per cert sintàctica errors, per no parlar dels errors lògics. I així entre els nostres objectius avui en dia, de fet, la voluntat ser per equipar-lo amb una mica tècniques de resolució de problemes per saber com per resoldre millor els problemes propis en forma de depuració. I com es recordarà, també, que el ambient que vam introduir última vegada que es diu CS50 IDE. Aquest és un programari basat en web que Li permet programar en el núvol, per així dir-ho, mentre es manté la totalitat del seu arxius junts, ja que novament serà avui. I recordar que ens revisited aquests temes aquí, entre ells, les funcions i bucles, i variables i expressions booleanes, i condicions. I en realitat una mica més que nosaltres traduït del món de les ratllades al món de la C. 

Però la construcció fonamental blocs, per així dir-ho, eren realment segueix sent el mateix la setmana passada. De fet, en realitat només vam tenir una diferents peça del trencaclosques, si es vol. En lloc que porpra guardar bloc, que en comptes havia printf, que és aquesta funció en C que li permet imprimir alguna cosa i el format de la pantalla. Vam introduir el CS50 Biblioteca, on es tenen ara a la seva disposició get_char, i get_int, i get_string, i algunes altres funcions com així, a través del qual es pot obtenir d'entrada de propi teclat de l'usuari. I també fem una ullada a les coses com aquestes: bool, i la carbonissa, i el doble, flotador, int, string LONG_LONG. I hi ha fins i tot altres tipus de dades en C. 

En altres paraules, quan es declara una variable per emmagatzemar algun valor, o quan s'implementa una funció que retorna algun valor, pot especificar quins tipus de valor que és. És una cadena, com una seqüència de caràcters? És un nombre, com un sencer? És un punt flotant valor, o similar? Així que a C, a diferència de les ratllades, que en realitat començar a especificar quin tipus de dades estàvem tornant o l'ús. 

Però, per descomptat, també ens trobem amb alguns límits fonamentals de la computació. I, en particular, aquest llenguatge C, el record que ens vam donar un cop d'ull a desbordament de sencers, la realitat que si només té una quantitat finita de memòria o, específicament, un nombre finit de bits, només es pot comptar tan alt. I així ens fixem en aquest exemple aquí pel qual un comptador en un avió ,, En realitat, si s'executa el temps suficient es desbordar i resultar en un programari un error potencial físic real. 

També ens fixem en flotant punt d'imprecisió, la realitat que amb només un nombre finit de bits, ja sigui 32 o 64, només pot especificar tants números després d'un punt decimal, després de la qual cosa es començar a tenir imprecisa. Així, per exemple, un terç en el món aquí, al nostre món humà, sabem que és només un nombre infinit de 3s després del punt decimal. No obstant això, un equip no pot necessàriament representar un nombre infinit de nombres si únicament permet que alguns quantitat finita d'informació. 

Així que no només hem de equipar amb més poder en termes de com pot expressar-se en un teclat en termes de programació, També ens limitem el en realitat es pot fer. I de fet, els errors i els errors poden sorgir d'aquest tipus de qüestions. I, en efecte, un dels temes d'avui van a ser temes com la depuració i en realitat mirant sota el capó la forma en què es van introduir les coses la setmana passada estan efectivament en pràctica de manera que és millor entendre tant les capacitats de les i les limitacions d'un llenguatge com C 

I de fet, anem a pelar les capes de la més simple d'estructura de dades, cosa que es diu una matriu, la qual De zero passa a anomenar una "llista". És una mica diferent en aquest context. I llavors també introduirem una de les primer dels nostres problemes específics de domini en CS50, el món de criptografia, l'art de l'aleatorització oa la informació de xifrat pel que pot enviar missatges secrets i descodificar missatges secrets entre dues persones, A i B. 

Així que abans que la transició a aquest nou món, tractarem de equipar-lo amb una mica tècniques amb les que es poden eliminar o reduir almenys alguns de les frustracions que és probable que hagi trobat durant l'última setmana només. De fet, abans que es tal-- alguns seus primers problemes en C. I les probabilitats són, Si ets com jo, el primer cop intenta escriure un programa, fins i tot si vostè pensa lògicament el programa és bastant simple, És molt possible que colpejar una paret, i el compilador no va a ajudar. Fer o no va Clang per fer realitat el seu fer una oferta. 

I per què podria ser? Bé, anem a fer una ullada a, potser, un programa senzill. Vaig a seguir endavant i guardar això en un arxiu anomenat deliberadament buggy0.c, perquè sé que a viciat per endavant. Però podria no adonar-se que si això és la primera o segona o tercera programa que en realitat estic fent a mi mateix. Així que seguiré endavant i escriure a màquina, int main (void). I després dins de les meves claus, una molt familiar ( "hola, món-- barra invertida, n ") - i un punt i coma. 

He guardat l'arxiu. Ara vaig a baixar al meu finestra de terminal i el tipus de maquillatge buggy0, perquè, de nou, el nom del fitxer d'avui és buggy0.c. Així que escric fer buggy0, Retorn. 

I, oh, Déu, recordar de l'última vegada que no hi ha missatges d'error és una bona cosa. Així que no hi ha sortida és una bona cosa. Però aquí tinc clarament cert nombre d'errors. 

Així que la primera línia de sortida després d'escriure fa buggy0, recordo, s'emet bastant detallat de So metàl·lic. Sota el capó, IDE CS50 està configurat utilitzar un munt de opcions amb aquest compilador de manera que vostè no ha pensar en ells. I això és tot el que la primera línia de mitjans que s'inicia amb Clang. 

Però després d'això, els problemes comencen a fer la seva aparició. Buggy0.c en la línia 3, caràcter 5, hi ha un gran error, vermell. Què és això? Declarant implícitament funció de biblioteca printf amb el tipus int (const char *, ...) [-Werror]. És a dir, és molt ràpid es posa molt arcà. I, per descomptat, en un primer moment vista, que no ho faria espero que ho entengui el totalitat d'aquest missatge. I el que una de les lliçons avui va a ser tractar de notar patrons, o coses similars, als errors que pugui tenir trobat en el passat. Així que anem a esmicolar només aquestes paraules que semblen familiars. El gran, vermell d'error és clarament simbòlic que alguna cosa va malament. 

declarant implícitament printf funció de biblioteca. Així que fins i tot si jo no entenc molt bé el declarant implícitament funció de biblioteca mitjans, el problema segurament es refereix a printf d'alguna manera. I la font d'aquesta qüestió té a veure amb el que es declara. 

La declaració d'una funció és esmentar que per a la primera vegada. I es va utilitzar la terminologia de la setmana passada de declarar el prototip d'una funció, ja sigui amb una línia a la part superior de la seva arxiu o incorporada a un fitxer de capçalera trucada. I en el que va fer que diem arxiu la setmana passada que printf és cita, Fi de la cita, declarada? En què fitxer és el seu prototip? 

Així que si vostè recorda, la primera cosa que em amb tipus, gairebé tots els programes última vegada-- i accidentalment fa un moment va començar escrivint myself-- era aquest aquí-- hash-- # include <stio-- de entrada / h output-- punt I, en efecte, si ara puc guardar aquest arxiu, vaig per seguir endavant i netejar la meva pantalla, que es pot fer escrivint És clar, o pot mantenir control L, només per aclarir la finestra de terminal només per eliminar alguns obstacles. 

Vaig a seguir endavant i Tipus de re-make buggy0, Retorn. I ja està, encara veig que comandament llarg de So metàl·lic, però no hi ha cap missatge d'error aquesta vegada. I de fet, si ho faig ./buggy0, com l'última vegada, on els punts que això significa directori, Slash només significa, aquí ve el nom del programa i que el nom del programa és buggy0, Introduir, "hola, món". 

Ara, com podria tenir aquesta solució obtinguda sense necessàriament reconeixent tantes paraules com ho vaig fer, sens dubte, tenir aquest fet durant tants anys? Bé, donar-se compte pel primer problema conjunt, li presentem una ordre que el propi personal de l'CS50 va escriure anomenada help50. I de fet, ho fa C plec de condicions de el problema establert quant a com usar això. 

Però help50 és essencialment un programa que el personal de l'CS50 va escriure que li permet executar una ordre o executar un programa, i si vostè no entén la seva de sortida, passi a la seva sortida a help50, en el punt el programari que el personal del suposat escriure es veurà a la sortida del seu programa línia per línia, caràcter per caràcter. I si nosaltres, el personal, reconeix el missatge d'error que està experimentant, anem a tractar de provocar-amb alguna preguntes retòriques, amb alguns consells, de la mateixa manera que un TF o una CA o jo faria en persona en horari d'oficina. 

Així que mira a help50 si no ho fa necessàriament reconèixer un problema. Però no confiï en ell massa com una crossa. Per descomptat tractar de comprendre el seu de sortida i després aprendre d'ella de manera que ho fan només una vegada o dues vegades help50 vegada s'ha quedat a un error particular missatge. Després d'això, vostè ha d'estar millor a tu mateix equipat per esbrinar el que realment és. 

Anem a fer una altra aquí. Déjame anar per davant, i en un altre arxiu que anomenarem aquest buggy1.c. I en aquest arxiu que sóc anar a deliberately-- però pretendre que no ho faig entenc el error que he comès. 

Vaig a seguir endavant i fer això- # Include, ja que he après la lliçó de fa un moment. Int principal (void), com abans. I llavors aquí vaig fer cordes s - get_string. I recordar l'última vegada que aquest mitjà, bé, equip, dóna'm una variable, en diuen S i fer que el tipus d'aquesta variable d'una cadena pel que pot emmagatzemar una o més paraules en el mateix. 

I després en el de la dreta costat del signe igual es get_string, que és una funció a la biblioteca CS50 que fa exactament això. Es posa una funció i després mans de dreta a esquerra. Pel que aquest signe igual no vol dir "Iguals" com podríem pensar en matemàtiques. Això vol dir que l'assignació de dreta a esquerra. Així que això significa, prendre la cadena de l'usuari i l'emmagatzema a l'interior del s. 

Ara utilitzarem la mateixa. Déjame anar endavant ara i com a segon línia, deixa anar per davant i dir "hola" - No "món", però "Hola,% S-- que és el nostre marcador de posició, coma s, que és la nostra variable, i després un punt i coma. Així que si no m'equivoco massa aquí, això es veu com codi correcte. 

I els meus instints són ara per compilar-lo. L'arxiu es diu buggy1.c. Així que vaig a fer que buggy1, Retorn. I donaran-it, si no hi ha fins i tot més errors que abans. És a dir, hi ha més Seria missatges d'error Sembla que les línies reals en aquest programa. 

Però el menjar per emportar és aquí, fins i tot si vostè està aclaparat amb dos o tres o 4 més missatges d'error, centrar-se sempre en el mateix primer d'aquests missatges. Quant a la part superior més un, desplaçant-se cap enrere fins que és necessari. Així que aquí he escrit maquillatge buggy1. Així és que la producció Clang com s'esperava. 

I aquí està el primer error vermell. L'ús de l'identificador no declarat cadena, el que vull dir estàndard en? Així que en estàndard és de en realitat una altra cosa. Es refereix a l'usuari de teclat, essencialment. 

Però això no és el que volia dir. Em refereixo a la seqüència, i ho deia get_string. Llavors, què és el que em es va oblidar de fer aquest cop? El que falta en aquesta ocasió? Tinc el meu # include, així que no tinc accés a printf. 

Però què és el que no tinc l'accés a de moment? Doncs bé, de la mateixa manera que l'última vegada, He de dir-li al compilador Clang el que aquestes funcions són. Get_string no ve amb C. I en particular, es no s'ajusta a la capçalera de l'arxiu ,. En el seu lloc, es presenta a cosa que el personal va escriure, que és un arxiu diferent nomenar però ben anomenat. 

Així que simplement afegint una línia code-- de record de l'última vegada Clang que quan s'executa, es va per mirar la meva part superior de codi a sota, d'esquerra a dreta. Es notarà, oh, que desitja. Déjame anar i trobar que, sempre que sigui al servidor, copiar i enganxar, en essència, a la part superior del seu propi arxiu de manera que en aquest moment de la història, línia 1, la resta del programa pot, de fet, utilitzar qualsevol de les funcions en la mateixa, entre ells get_string. Així que vaig a ignorar la resta dels errors, perquè, de fet, sospito que només el primer d'ells en realitat importava. I vaig a seguir endavant i tornar a executar, després de guardar el meu arxiu que buggy1. I llest, ho va fer el treball. I si ho faig ./buggy1 i escrigui, per exemple, Zamyla, ara obtindrà hola, Zamyla, en lloc de hola, món. 

Tot bé. Així que el menjar per emportar aquí a continuació són per a, un, tractar de recollir tant com sigui possible a partir dels missatges d'error per si soles, mirant En algunes de les paraules recognoscibles. A part d'això, utilitzeu per help50 el problema conjunt d'especificacions. Però tret això, també, sempre es veuen a la part superior d'error només, almenys inicialment, per veure quina informació que en realitat podria cedir. Però resulta que hi ha encara més funcionalitat integrada a la Biblioteca CS50 per ajudar que des del principi en el semestre i al començament de la programació esbrinar el que va malament. Així que farem aquí un altre exemple. Vaig a trucar a aquest buggy2, que, de nou, va ser defectuós a terme de la porta, per disseny. 

I seguiré endavant i fer # include. I després vaig a fer int main (void). I llavors em vaig a fer un bucle. For (int i _ 0. i és menor que o igual a 10. i ++, i després entre claus, vaig imprimir només un símbol hashtag aquí i un caràcter de nova línia. 

Així que la meva intenció amb aquest programa és, senzillament, per repetir 10 vegades i en cada iteració d'aquest bucle cada vegada a través del cicle, imprimir un hashtag, un hashtag, un hashtag. Una línia per perquè tenir la nova línia allà. I per recordar que la llaç, per última setmana-- i obtindrà més familiaritzat amb la sintaxi usant-ho amb la pràctica abans d'això em dóna long-- una variable que es diu i ho estableix en 0. 

Això incrementa i en cada iteració per 1. Així que va a 1 a 2 a 3. I llavors aquesta condició en el mitjà entre els punts i comes aconsegueix comprovat en cada iteració per fer Segur que encara estem dins de l'abast. Per això vull repetir 10 vegades, de manera que tenen una mena de manera molt intuïtiva només lloc 10 com el meu límit superior allà. 

I, però, quan va executar això, després d' compilar amb maquillatge buggy2-- i es compila a D'acord. Així que no tinc una error de sintaxi en aquesta ocasió. Déjame anar per davant ara i executar buggy2, Retorn. I ara desplaçar-se cap amunt. I permetin-me augment la mida de la finestra. 

Em sembla que tenen 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Així que hi ha 11 hashtags, tot i que Poso clarament 10 en l'interior d'aquest bucle. Ara, alguns de vostès podrien veure immediatament el que l'error és degut al fet que, de fet, aquesta No és un error molt difícil de fer. Però és molt comunament fet molt d'hora. 

El que vull assenyalar, però, És a dir, com podria jo a resoldre això? Doncs bé, resulta que la Biblioteca CS50 ve no només amb get_string i get_int i get_float i altres funcions. També ve amb una funció especial EPRINTF trucada, o, printf error. I és que existeix solament per fer és una mica més fàcil per a vostè a depurar el codi per simplement imprimir un missatge d'error a la pantalla i saber d'on vi. 

Així, per exemple, una cosa que podria fer aquí amb aquesta funció és això- EPRINTF, i després vaig a seguir endavant i dir que ara és de% i, la barra invertida, n. I vaig a endollar en el valor de i. I al capdamunt, ja que aquest està a la Biblioteca CS50, Vaig a seguir endavant i incloure així que no tinc accés a aquesta funció. Però considerarem quina línia 9 se suposa que han de fer. Vaig a esborrar aquest temps. Això no té res a veure amb el meu objectiu primordial. Però EPRINTF, printf error, és només la intenció donar-me alguna informació de diagnòstic. Quan executo el meu programa, vull veure això a la pantalla temporalment que també acaba d'entendre què està passant. 

I, de fet, en cada iteració aquí de la línia 9 Vull veure, quin és el valor d'i? Quin és el valor d'i? Quin és el valor d'i? I, amb sort, només ha de veure aquest missatge, també, 10 vegades. 

Així que permetin-me seguir endavant i recompilar el meu programa, ja que he de fer en qualsevol moment Faig un canvi. ./buggy2. I ara-- OK. Hi ha molt més en joc. Així que permetin-me desplaçar-se cap amunt en una finestra encara més gran. 

I veurà que cadascun la hashtags està imprimint. Però entre cada un d'ells és ara això sortida de diagnòstic el següent format. El nom del meu programa aquí és buggy2. El nom de l'arxiu és buggy2.c. El nombre de línia de la qual aquest va ser imprès és la línia 9. I després a la dreta que és la missatge d'error que estic esperant. 

I el bo d'això és que Ara no he de comptar necessàriament en el meu cap el que el meu programa està fent. Puc veure que en el primera iteració i és 0, després 1, després 2, després 3, després 4, a continuació, 5, a continuació, 6, a continuació, 7, a continuació, 8, 9 a continuació, a continuació, 10. Així que esperi un minut. Que està passant aquí? Encara em sembla estar explicant segons el previst fins a 10. 

Però, d'on començo? 0, 1, 2, 3, 4, 5, 6, 7, 8, 10 set. Així 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- el dit 11 és indicatiu del problema. Em sembla que han comptat incorrectament en el meu bucle. En lloc d'anar 10 iteracions, Estic començant a 0, Estic acabant en ia través de 10. Però com que, com un ordinador, Estic començant a comptar a 0, Hauria d'estar explicant fins a, però no a través de, 10. 

I així, la solució, que finalment adonat que aquí, és una de dues coses. Podria dir simplement molt comptar fins a menys de 10. Així 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, que és, de fet, correcta, encara que soni una mica malament. O podria fer menys que o igual a 9, sempre i quan començo a 0. O si realment no li agrada això, pot comptar cap amunt a través de 10 però comencen en 1. Però, de nou, això no és tan comú. En programming-- encara no tant en Scratch-- però en la programació en C i altres idiomes, com JavaScript i Python i altres, és simplement molt comú per la nostra discussió sobre binària que acaba de començar a comptar en el nombre més baix que pugui, que és 0. Tot bé. Així que això és EPRINTF. I de nou, ara que he descobert el meu problema, i ho vaig a tornar a 0 a través de menys de 10, vaig per entrar i eliminar EPRINTF. 

No hauria de ser-hi quan enviar el meu codi o enviar el meu codi o mostrar-la a ningú més. És realment només la intenció per a ser utilitzades temporalment. Però ara m'he fixat aquest en particular problema també. 

Bé, farem un exemple més aquí que vaig a assotar sobre de la següent manera. Vaig a seguir endavant i #incloure . 50 $ I seguiré endavant i # include. 

I vaig a estalviar aquesta imatge com buggy3.c. I seguiré endavant i declarar int main (void). I després dins d'allà Vaig a fer int i _ - Vull posar en pràctica un programa d' amb un get_negative_int. Això no és una funció que existeix encara. Així que anem a posar en pràctica en un moment. Però anem a veure per què és amb errors a la primera passada. I una vegada que he rebut 1 int l'usuari, Jo només vaig a imprimir% i és un negatiu nombre sencer, la barra invertida, n, coma, i. En altres paraules, tot el desitja que aquest programa per fer s'obtindrà una int negativa de l'usuari i després imprimir que tal i tal és un int negatiu. 

Ara necessito per implementar aquesta funció. Així que més endavant en el meu arxiu, aniré endavant i declarar una funció anomenada get_negative_int (void) - i anem a tornar al que significa una vegada més que la línia en un moment-- int n; fer-- do la following-- printf n és:. I després vaig a fer n - get_int, i fer això mentre que n és més gran que 0. I després tornar n;. 

Així que hi ha molt a fer en això, però cap dels quals no ho vam fer mirar la setmana passada, almenys breument. Així que en la línia 10 aquí he declarat una funció anomenada get_negative_int, i jo he posat (void), en parèntesi, la raó de ser d'aquest no té una entrada. No estic passant res a aquesta funció. M'estic fent alguna cosa a canvi d'ella. 

I el que estic esperant tornar és un nombre sencer. No hi ha cap tipus de dades en C diu negative_int. És només int, així que va per estar en nosaltres per assegurar que el valor que en realitat retornada és no només un int però també és negatiu. 

A la línia 12 que estic declarant una variable n trucada i el que és de tipus int. I després, en la línia 13 fins al 18 de Soy fer alguna cosa, mentre que alguna cosa és veritat. Vaig per davant i impressió n és a dir, còlon, i després un espai, com un indicador per a l'usuari. 

llavors jo estic trucant i get_int emmagatzemar el seu denominat valor de retorn en aquesta variable n. Però seguiré fent això mentre que n és més gran que 0. En altres paraules, si l'usuari dona una em int i aquest nombre és més gran que 0, ergo, positiu, vaig a només mantenir reprompting l'usuari, mantenir reprompting, obligant-los a cooperar i fes-me un int negatiu. 

I una vegada que n és en realitat negative-- Suposem que l'usuari finalment tipus -50, llavors aquest bucle while ja no és cert perquè -50 no és més gran que 0. Així que sortir d'aquest lògicament bucle i tornar n. 

Però hi ha una altra El que he de fer. I jo simplement puc fer això per copiar i enganxar una línia de codi a la part superior de l'arxiu. He de ensenyar a Clang, o promesa de so metàl·lic, explícitament que jo vull, de fet, anar i posar en pràctica aquesta funció get_negative_int. Potser només sigui inferior a l'arxiu. Un cop més, recordar que Clang llegeix coses de dalt a baix, d'esquerra a dreta, de manera que no pot cridar a una funció si Clang no sap que va a existir. 

Ara, per desgràcia, aquest programa, com alguns de vostès s'hauran adonat, Ja és buggy. Déjame seguir endavant i fer buggy3. Compila, pel que el meu problema ara no és un error de sintaxi, com un error textual, que és en realitat serà una lògica error que he deliberadament fet com una oportunitat per pas a través del que està passant. 

Vaig a seguir endavant ara i funcionament buggy3. I vaig a anar davant i no cooperar. Vaig a donar-li el número 1. Que no li va agradar, per la qual m'està provocant de nou. 

Què hi ha de 2? 3? 50? Cap dels que estan treballant. Què hi ha de -50? I el programa sembla funcionar. 

Déjame intentar-ho una vegada més. Permetin-me tractar -1, sembla que funciona. Permetin-me tractar -2, sembla que funciona. Permetin-me tractar de 0. Ei, això és incorrecte. Ara, estem sent una mica pedant aquí. Però és, de fet, el cas que 0 no és ni positiu ni negatiu. I així, el fet que el meu programa és dient que 0 és un enter negatiu, això no és tècnicament correcte. 

Ara, per què està fent això? Bé, pot ser que sigui obvi. I, de fet, el programa és destinat a ser bastant senzill així que tenim alguna cosa per explorar. 

Però anem a introduir un tercer depuració aquí es diu tècnica de debug50. Així que aquest és un programa que simplement hem creat aquest any es diu debug50 que li permetrà utilitzar el que s'anomena un predefinit depurador gràfic en IDE CS50. I un depurador és simplement un programa que en general, li permet executar el seu programa però pas a pas a pas, la línia per línia per línia, fent una pausa, furgant voltant, mirant a les variables de manera que el programa no es limita a bufar més enllà de vostè i imprimir ràpidament alguna cosa o no imprimir alguna cosa. Se li dóna una oportunitat, per la qual la velocitat humana, per interactuar amb ell. 

I per a això, simplement fer el següent. Després de compilar el codi, que ja vaig fer, buggy3, seguir endavant i executar debug50 ./buggy. Tant com help50 ha d'executar help50 i llavors la comanda, debug50 ha d'executar i debug50 llavors el nom de la comanda. 

Ara observin el que passa a la meva pantalla, al costat dret en particular. Quan colpeig Executar, tota la panell de cop i volta aquest dret s'obre a la pantalla. I hi ha molt a fer en a primera vista. Però no hi ha massa molt de què preocupar-se encara. 

Això m'està mostrant tot que està passant dins del meu programa en aquest moment ia través d'aquests botons sobre de la tapa és llavors el que em permet el pas a través del meu codi en última instància, pas a pas a pas. Però no de moment. Observi el que passa. En la meva finestra de terminal Jo estic sent incitat per an. I vaig a seguir endavant i cooperar en aquesta ocasió i tipus de -1. I encara que una mica crípticament, -1 és un enter negatiu, com s'esperava. 

I llavors fill va acabar amb estat 0 gdbserver sortir. BGF, depurador de GNU, és el nom del programari subjacent que implementa aquest depurador. Però tot això significa en realitat, el depurador se'n va anar perquè el meu programa de deixar de fumar i tot estava bé. Si vull depurar realment el meu programa, He de dir-li preventivament debug50, on vull per començar passant a través del meu codi? 

I potser la forma més senzilla fer això és com segueix. Si hi ha sobre el canaleta del meu editor d'aquí, pel que en realitat només a la barra lateral aquí, a l'esquerra del nombre de línia, Recordeu que si només clic una vegada, vaig posar un petit punt vermell. I aquest petit punt vermell, com un senyal d'alt, mig, bé, debug50, pausa en l'execució de la meva codi just allà quan va executar aquest programa. 

Així que anem a fer això. Déjame anar per davant i córrer el meu programa de nou amb debug50 ./buggy3, Retorn. I ara, avís, alguna cosa diferent ha succeït. No estic que se li demani però, en la meva finestra de terminal per a res, perquè jo no tinc arribat allà encara en el meu programa. Cal notar que en la línia 8 que ara es posa en relleu, i hi ha una petita fletxa en dit esquerra, que es va aturar aquí. Aquesta línia de codi, la línia 8, encara no s'ha executat. 

I el que és curiós, si miro aquí al costat dret, adonar que i és un local de variable local en el sentit que hi ha dins de la funció actual. I el seu valor, pel que sembla, per defecte, i en certa manera convenientment, és 0. Però no em escrigui 0. Això només passa a ser el seu valor per defecte en el moment. 

Així que permetin-me seguir endavant i fer això ara. Déjame anar endavant i en la part superior dreta aquí, estic seguirà endavant i feu clic en aquesta icona dels primers quals significa passar per sobre del que significa no se salti però passar per sobre d'aquesta línia de codi, executar en el camí. 

I ara, compte, el meu ràpida acaba de canviar. Perquè és això? Li he dit a debug50, executar aquesta línia de codi. Què fa aquesta línia de codi fa? em porta a un int. D'ACORD. Permetin-me cooperar. Déjame anar endavant ara i escrigui -1, ENTER. I ara compte del que ha canviat. A la banda de la dreta, el meu variable local i s'indica com -1 ara. I segueix sent de tipus int. 

I avís, també, el meu anomenat la pila de trucades, on vaig fer una pausa? Parlarem més sobre això en el futur. Però la pila de trucades simplement es refereix al que funcions estan actualment en moviment. En aquest moment és simplement principal. I en aquest moment l'únic local de variable és i amb un valor d'1. 

I quan finalment passar per sobre d'aquesta línia aquí, amb aquest mateix icona a la part superior dreta, -1 És un enter negatiu. Ara s'està fent una pausa durant aquest claudàtor. Anem a deixar que faci la seva cosa. Dono un pas més d'aquesta línia, i llest. 

Així que no tot el que terriblement aclaridor però, però em va deixar una pausa i pensar amb lògica el que aquest programa està fent. Però aquest no va ser el cas errònia. Anem a fer això de nou de la següent manera. 

Vaig a sortir d'aquest punt d'interrupció en la línia 8 amb el punt vermell. Vaig a tornar a executar debug50. Es va fer una pausa automàticament aquí. Però aquesta vegada, en lloc de passant per sobre d'aquesta línia, me n'aniré en realitat dins get_negative_int i esbrinar, ¿Per què està acceptant 0 com una resposta vàlida? 

Així que en lloc de fer clic a Pas a pas per. Vaig a seguir endavant i feu clic a Pas a pas. I observi que la línia 8 que és Ara ressaltat ara de cop i volta es converteix en la línia 17. 

Ara, no és que el depurador ha saltat les línies 14 i 15 i 16. És que no hi ha res per mostrar-hi. Aquestes són només la declaració de variables, I després hi ha la paraula fer i després una clau d'obertura. L'única línia que és funcional sucosa realment és aquest d'aquí, 17. I aquí és on ens hem una pausa automàticament. 

Així printf ( "n.is:");, per la qual que encara no ha succeït. Així que seguirem endavant i feu clic a Pas a pas per. Ara el meu sistema, de fet, canviat a ( "n és:"). Ara get_int, no vaig molestar a entrar en, perquè que la funció era feta per CS50 a la Biblioteca. És presumiblement correcta. 

Així que seguiré endavant i tipus de cooperar donant-li un int, però no és un int negatiu. Així que permetin-me anar per davant i va colpejar 0. I ara el que passa aquí quan arribi fins a la línia 21? No he iterat de nou. No sembla que hi hagi encallat en aquest bucle. En altres paraules, aquest groc bar no seguir endavant voltant, i al voltant i voltant. 

Ara, per què? Bé, n, el que està n en aquest moment? Puc mirar a nivell local variables en el depurador. n és 0. Molt bé, quin era el meu condició? 

20-- línia 20 és, així, 0 és més gran que 0. Això no és cert. 0 no és més gran que 0. I pel que va sortir d'això. 

I per això és que en la línia 21, si realment continuo, Vaig a tornar 0, fins i tot tot i que hauria d'haver rebutjat 0 que no sigui negatiu. Així que ara, realment no té ni es preocupen pel depurador. Tinc, el que no cal saber què més està passant. 

Així que seguiré endavant i només cal fer clic al botó Reproduir, i deixar que aquest acabat cap amunt. Ara, m'he adonat que la meva insecte és pel que sembla en la línia 20. Aquesta és la meva error lògic. 

I així ho vull de fer per canviar això? Si el problema és que no estic la captura de 0, que és només un error lògic. I puc dir, mentre que n és més gran que o igual a 0, mantenir a preguntar a l'usuari una vegada i una altra. 

Així, de nou, simple error, potser fins i tot òbvia quan em vas veure escriure-ho fa tan sols uns minuts. Però aquí el menjar per emportar és que amb depuració 50, i amb la depuració programari de manera més general, vostè té aquest nou poder de caminar a través del seu propi codi, mira a través d'aquest panell de la dreta ho els valors de les variables són. Pel que no necessàriament haver de fer servir alguna cosa com si EPRINTF per imprimir aquests valors. En realitat es pot veure visualment a la pantalla. 

Ara, més enllà d'això, val la pena assenyalar que no és altra tècnica que és en realitat molt comú. I un es pregunta per què aquesta petita tipus aquí s'ha assegut a l'escenari. Així que hi ha aquesta tècnica, en general, conegut com cautxú depuració d'ànec, que en realitat és només una testimoni del fet que sovint quan els programadors està escrivint codi, que no són necessàriament col·laborar amb els altres, o treballar en un entorn compartit. 

Són una espècie de a casa. Potser és tard a la nit. Estan tractant de figura a terme alguns errors en el seu codi. I no només estan veient. 

I no hi ha cap company de quart. No hi ha TF. No hi ha CA voltant. Tot el que tenen en la seva plataforma és aquest petit aneguet de goma. 

I així depuració ànec de goma és només aquesta invitació pensar en una cosa tan ximple ja que això com una criatura real i, de fet caminar a través del seu codi verbalment a aquest objecte inanimat. Així, per exemple, si aquest és el meu exemple aquí-- i recordar que abans el problema era això, si elimino aquesta primera línia de codi, i jo seguir endavant i fer buggy de 0 de nou, recordar que tenia aquests missatges d'error aquí. Així que la idea aquí, encara que ridícula sentir en el moment de fer això públicament, és que l'error. 

D'acord, pel que el meu problema és que tinc declarat implícitament una funció de biblioteca. I que la funció de biblioteca és printf. Declare-- bé, declarar em recorda de prototips. 

Això vol dir que necessito en realitat indicar al compilador per endavant el la funció es sembla. Espera un minut. No tenia io.h. norma Moltes gràcies. 

Pel que només aquest procés es de-- no cal tenir en realitat un ànec. Però aquesta idea de caminar a si mateix a través del seu propi codi de manera que fins se sent vostè mateix, de manera que vostè adonar-omissions en el seu propi observacions, és en general la idea. 

I, potser més lògicament, no tan amb molt a un, però el més implicat exemple que acabem de fer en 3.c amb errors, pot caminar a si mateix a través d'ell com segueix. Així bé, el cautxú aneguet, DDB, si es vol. Aquí tenim en la meva funció principal, Vaig a trucar a aconseguir int negatiu. 

I estic aconseguint el valor de retorn. Estic emmagatzemant a la banda esquerra en la línia 8 en una variable anomenada i. OK, però espera, com que reben aquest valor? Deixa que et miri la funció en la línia 12. 

En la línia 12, hem d'aconseguir int negatiu. No es necessita cap input, no retornar un int, OK. Declaro en la línia 14 una variable n. Es va a emmagatzemar un nombre sencer. Això és el que vull. 

El mateix passa amb la següent, mentre que n és-- va deixar Em desfer el que el punt de referència que ja va fer. Així, mentre que n és més gran que 0, imprimiu n és, a D'acord. I després trucar a quedar emmagatzemat int n. I a continuació, comprovar si n és 0, n és no-- aquí està. Així, de nou, no ho fa necessitarà l'ànec real. Però només caminar vostè mateix a través el seu codi com un exercici intel·lectual sovint l'ajudarà adonar-se del que està passant, en lloc de només fer alguna cosa així, mirant a la pantalla, i no parlar-se a si mateix a través ell, que sincerament no és gairebé com una tècnica eficaç. Així que aquí ho tenen, un nombre de diferents tècniques de fet la depuració del seu codi i la recerca d'errors, tots els quals han de ser eines en la seva caixa d'eines de manera que vostè no és tard a la nit, sobretot, que ets al menjador passadissos, o en horari d'oficina, un cop al cap contra la paret, tractant de resoldre algun problema. S'adonen que hi ha eines de programari. Hi eines d'ànec de goma. I hi ha tota una plantilla de donar suport a l'espera de donar un cop de mà. 

Així que ara, unes paraules sobre el problema conjunts, i en el que vostè està esperant sortir d'ells, i com ens ocupem de l'avaluació. Per programa del curs, butlletins de problemes de CS50 són avaluats en quatre eixos primaris, per la qual speak-- a l'àmbit d'aplicació, correcció, disseny, i l'estil. I abast només es refereix a la quantitat de de la peça que ha mossegat? Quant d'un problema ha intentat? Quin nivell d'esforç ¿Ha manifestat? 

La correcció és, funciona el programa com se suposa que segons l'especificació CS50 quan es proporciona certes entrades o certes sortides a tornar? El disseny és el més subjectiu d'ells. I és el que es que més triguen a aprendre i el més llarg per ensenyar, en la mesura que es redueix a, el ben escrit és el codi? 

És una cosa que acaba d'imprimir la correcta sortides o retornen els valors correctes. Però ho fas com eficientment com sigui possible? ¿Ho està fent bretxa i conquerir, o binari cerca com aviat veurem que vam fer Fa dues setmanes, amb la guia telefònica? Hi ha millors maneres de resoldre el problema que actualment té aquí? Això és una oportunitat per a un millor disseny. 

I llavors style-- com bonic és el codi? Es donarà compte de que estic bastant en particular sobre la sagnia meu codi, i assegurant-se que la meva variables es nomenen raonable. n, mentre resum, és un bon nom per a una nombre, i per un nombre enter de comptatge, s per a una cadena. I podem tenir més llarg estil dels noms de variables. L'estil és el bo Com es veu el codi? I com llegible és? 

I amb el temps, quina és la seva TA i TFS van a fer en el curs que es proporcionarà amb aquest tipus de retroalimentació qualitativa de manera que s'obté una millor en aquests diversos aspectes. I pel que fa a la forma en què avaluar cada un d'aquests eixos, que és típicament amb molt pocs cubs perquè, en general, tenir una idea de com està fent. I, de fet, si rep una puntuació en qualsevol dels axes-- correcció, disseny i l'estil especially-- aquest nombre generalment serà d'entre 1 i 5. I, literalment, si vostè està rebent 3 de l'inici del semestre, això és una cosa molt bona. Això vol dir que encara hi ha marge de millora, la qual és d'esperar en el prendre una classe per primera vegada. No és d'esperar algun fragment de sostre a la qual està aspirant a assolir. I així aconseguir el de 3 les primeres peces, si no un 2 i de 4 de, és, de fet, una bona cosa. És també dins de l'abast, bé dins del que s'esperava. 

I si la seva ment està corrent, esperi un minut, tres de cada cinc. Això és realment una sortida 6 oct. Això és 60%. Déu meu, que és una F. 

No és. No és, de fet, que. Més aviat, és una oportunitat per millorar en el transcurs del semestre. I si vostè està rebent alguna Poors, es tracta d'una oportunitat per aprofitar les hores d'oficina, certament, seccions i altres recursos. 

El millor és l'oportunitat, de veritat, per estar orgullosos del que lluny que ha arribat en el transcurs del semestre. Així que adonar-se, si res la resta, tres és bona. I permet espai per al creixement en el temps. 

Pel que fa a la forma en què aquests eixos són ponderada, de manera realista que estiguis passarà la major part del seu temps aconseguir coses per treballar, per no parlar correctament. I així tendeix a la correcció ponderar el més, com amb aquest factor multiplicador de tres. El disseny també és important, però cosa que no necessàriament passar totes aquestes hores en tractant d'aconseguir coses per treballar. 

I així es pondera una mica més lleugera. I a continuació, l'estil es pondera el menys. Tot i que no és menys fonamentalment important, És que, potser, el El més fàcil de fer el bé, imitant els exemples que fer en la conferència i la secció, amb les coses Nicely sangria, i va comentar: i així successivament està entre els més fàcils coses a fer i fer-ho bé. Així que, com a tal, s'adonen que aquestes són punts que són relativament fàcils d'entendre. 

I ara una paraula de esto-- honestedat acadèmica. Així pel curs de programa, veurà que el curs té un bon mica de llenguatge d'evitar això. I el curs es porta a la qüestió de la honestedat acadèmica molt seriosament. 

Tenim la distinció, per bé o per mal, d'haver enviat cada any més estudiants per prendre mesures disciplinàries que la majoria de qualsevol altre Per descomptat, que jo sàpiga. Això no és necessàriament indicatiu del fet que els estudiants CS, o els estudiants, són CS50 menys honest que els seus companys de classe. Però la realitat que en aquest món, per via electrònica, només tenen tecnològica mitjans de detecció d'aquest. 

És important per a nosaltres per equitat a través de la classe el que fem detectar això, i elevar la qüestió quan veiem coses. I només per pintar un quadre, i realment per ajudar a alguna cosa com això a la pica, aquests són els números de estudiants en els últims 10 anys que han estat involucrats en alguns aquestes qüestions d'honestedat acadèmica, amb uns 32 estudiants des de la tardor de 2015, que és a dir que nosaltres vam prendre l'assumpte molt seriosament. I, en última instància, aquests números componen, més recentment, al voltant de 3%, 4% o menys de la classe. 

Així que per a la majoria absoluta dels estudiants sembla que les línies estan clares. Però tingui això en ment, particularment tard a la nit quan lluita amb alguna solució a un conjunt de problemes, l'existència de mecanismes per arribar millor a si mateix el suport del que es pensar, fins i tot a aquesta hora. Adonar-se que quan vam rebre enviaments dels estudiants, que es creuen comparar cada presentació aquest any en contra de cada presentació l'any passat, contra tots els enviaments a partir del 2007, i des de, mirant, així, codi dels repositoris en línia, fòrums de discussió, llocs de treball. I esmentem això, Realment, tot en nom de la divulgació completa, que si una altra persona pot trobar en línia, sens dubte, per la qual cosa pot ser que el curs. Però, en realitat, l'esperit del curs es redueix a aquesta clàusula en el programa d'estudis. Realment és just, sigui raonable. 

I si haguéssim d'elaborar en això amb només una mica més la llengua, adonar-se que l'essència de tot el treball que enviï a aquest curs ha de ser la seva. Però dins d'això, sens dubte hi ha oportunitats i l'estímul, i el valor pedagògic en la transformació de altres-- mi mateix, el TFS, les entitats emissores, les AT, i altres a la classe, per al suport, que els seus amics sols i companys que han estudiat CS i programació abans. I pel que hi ha un marge per a això. I la regla general del polze es això- quan es demana ajuda, vostè pot mostrar el seu codi als altres, però vostè no pot veure la seva. Així que fins i tot si vostè està en horari d'oficina, oa la sala D, o en un altre lloc treballant en algun conjunt peça, treballant al costat d'un amic, que és totalment bé, en el final del dia el seu treball en última instància, han de pertànyer a cada que, respectivament, i no haver algun esforç de col·laboració, excepte per al projecte final on es permet i s'anima. 

Adonar-se que si estàs lluitant amb alguna cosa i el seu amic només passa per ser millor en això, llavors, o millor en aquest problema que tu, o una mica més endavant que vostè, que és totalment raonable per activar al seu amic i dir, hey, ¿Li importa mirant el meu codi aquí, ajudar-me albiro el que el meu problema és? I, amb sort, al interès del valor pedagògic aquest amic ho fa no només a dir, oh, fer això, sinó més aviat, el que li falta a la línia 6, o alguna cosa per l'estil? No obstant això, la solució no és per l'amic al teu costat a dir, oh, bé, aquí, deixa, trobaré això, i mostrar la meva solució per a vostè. Així que aquesta és la línia. Vostè mostra el seu codi de altres, però no es pot veure els seus, sense perjudici de l'altra restriccions en el curs del programa. 

Així que tenir en compte aquesta així anomenada clàusula de penediment en el programa del curs, així, que si comet algun acte que No és raonable, però portar-lo a l'atenció dels caps del curs dins de les 72 hores, el curs pot imposar sancions locals que pot incloure un insatisfactori o el grau d'fall per al treball presentat. Però el curs no es referirà al matèria de noves mesures disciplinàries, excepte en els casos d'actes repetits. En altres paraules, si vostè fa alguns estúpida, nit especialment al final, la decisió que al matí següent o dos dies més tard, es desperta i s'adona, ¿Què estava pensant? Vostè pot fer en CS50 tenir una sortida per a la fixació d'aquest problema i ser amo de l'altura, de manera que l'esperarà fins a la meitat i tractar amb ell en un assumpte que és alhora educatiu i valuós per a vostè, però encara punitiu d'alguna manera. I ara, en arribar al límit, això. 

[REPRODUCCIÓ DE VÍDEO] 

[MÚSICA] 

[FI DE REPRODUCCIÓ] DAVID J. Malan: Molt bé, estem de tornada. I ara ens fixem en una de les primer dels nostres dominis del món real en CS50, l'art de la criptografia, l'art d'enviar i rebre missatges secrets, xifrada missatges si es vol, que només pot ser desxifrat si té alguns ingredient clau que el remitent té tant be. Així que per motivar això anem a prendre Un cop d'ull a aquesta cosa aquí, que és un exemple d'una anell descodificador que secreta es pot utilitzar per tal d'esbrinar el que és un missatge secret en realitat és. De fet, de tornada al dia a l'escola primària, si alguna vegada has enviat missatges secrets a algun amic o algun aixafament a classe, que podria haver pensat estaves sent intel·ligent pel canvi del seu tros de paper, de la mateixa manera que, d'A a B i de B a C i C a D, i així successivament. Però ja han estat realment xifrant seva informació, fins i tot si era una mica trivial, no era que dura perquè el professor s'adona, així, si vostè acaba de canviar B a A i C a B, que en realitat esbrinar el que el missatge era, però estaves en la informació de xifrat. 

Només estaves fent Simplement, igual que Ralphie aquí en una famosa pel·lícula que juga més o menys fins a la sacietat cada hivern. [REPRODUCCIÓ DE VÍDEO] -ja Sigui sabut per tots que Ralph Parker està present nomenat membre de la Petita Orphan Annie cercle secret i té dret a tots els honors i beneficis es produeixen a la mateixa. 

-signat, Little Orphan Annie, ratificat Pierre Andre, en tinta. Honors i beneficis, Ja a l'edat de nou anys. 

[CRIT] -Vinga. Seguirem endavant amb ella. No necessito tot aquest jazz sobre contrabandistes i pirates. 

demà a la nit per -listen l'aventura de conclusió del vaixell pirata negre. Ara, és el moment de missatge secret d'Annie per a vosaltres, els membres del Cercle Secret. Recordeu, els nens, els únics membres del cercle secret d'Annie pot descodificar el missatge secret d'Annie. 

Recordeu, Annie depèn de tu. Establir les seves passadors a B2. Aquí està el missatge. 12, 11-- 

-Estic En la meva primera reunió secreta. 

-14, 11, 18, 16. 

-Pierre Va ser en gran veu aquesta nit. Podria dir que aquesta nit missatge era realment important. 

-3, 25, això és un missatge Annie de si mateixa. Recordeu, no dir-li a ningú. 

-90 Segons més tard, estic en l'únic habitació de la casa on un nen de nou anys podria seure a la privacitat i la descodificació. Aha, B! Vaig anar a la següent, I. 

La primera paraula és ser. S, que havia de venir més fàcil ara, U, 25-- 

Oh, anem, Ralphie, me n'he d'anar! 

-Vaig A estar ben baix, Ma! Caram! 

-T, O, asseguri A-- estar segur de què? Quina va ser la huerfanita Annie tractant de dir? Assegureu-vos que? 

-Ralphie, Andy ha de GO, feu el favor de sortir? 

-Tots Dreta, Ma! Vaig a estar bé! 

-I Estava més a prop ara. La tensió era terrible. Què era això? El destí del planeta pot penjar d'un fil. 

-Ralphie! Ha d'anar d'Andy! 

-Vaig A estar a la dreta, per amor de Déu! 

-gairebé Allà, els meus dits volaven, la meva ment Era un parany d'acer, cada porus va vibrar. Era gairebé clara, sí, sí, sí. 

-Assegureu-Vos De beure la seva Ovaltine. Ovaltine? Un comercial de mala mort? Fill de puta. [FI DE REPRODUCCIÓ] DAVID J. Malan: OK, llavors que era un camí molt llarg de la introducció de la criptografia, i també Ovaltine. De fet, a partir d'aquest anunci d'edat aquí, per què és tan bo Ovaltine? És una extracció concentrada d'madur malta d'ordi, llet pura de vaca cremós, i especialment preparat de cacau, juntament amb fosfats naturals i vitamines. Està fortificada amb major vitamines addicionals B i D, nyam. I encara es pot aconseguir que, segons sembla, a Amazon, com ho vam fer aquí. 

Però la motivació aquí era introduir la criptografia, en concret un tipus de criptografia coneguda com criptografia de clau secreta. I com el seu nom indica, el conjunt la seguretat d'un sistema de criptografia de clau secreta, si es vol, una metodologia per només aleatorització informació entre dues persones, és que només el remitent i només el destinatari saber un secret key-- algun valor, alguns frase secreta, un número secret, que els permet xifrar i desxifrar la informació. I la criptografia, en realitat, és només això des de la setmana 0. 

És un problema on no hi ha entrades, de la mateixa manera que el missatge real en Anglès o qualsevol altre idioma que es voleu enviar a algú de la classe, oa través d'internet. Hi ha una mica de sortida, que es va sent el missatge codificat que vol que el destinatari rebre. I fins i tot si algú en el mitjà rep també, vostè no vol que es necessàriament serà capaç de desxifrar-lo, perquè dins d'aquest quadre negre, o algoritme, és algun mecanisme, alguns pas a pas instruccions, per prendre aquesta entrada i convertir-lo en el de sortida, és d'esperar en una forma segura. 

I, de fet, hi ha una certa Vocabulari en aquest món de la següent manera. El text pla és la paraula d'una informàtic faria utilitzar per descriure l'entrada missatge, com l'anglès o qualsevol idioma que en realitat voler enviar a algun altre ésser humà. I a continuació, el text xifrat és la lluita a xifrada o encriptada, versió de la mateixa. 

Però hi ha un altre ingredient aquí. Hi ha una altra entrada al La criptografia de clau secreta. I aquesta és la clau, que és, en general, com veurem, un nombre, o lletra o paraula, qualsevol que sigui l'algoritme que és en realitat espera. 

I com desxifrar la informació? Com es pot desxifrar? Bé, només inverteix el les sortides i les entrades. 

En altres paraules, una vegada que algú rep el missatge xifrat, ell o ella simplement ha conèixer la mateixa clau. Han rebut el text xifrat. I connectant els dos entrades en el sistema de xifrat, l'algoritme, aquesta caixa de negre, fora ha de venir del text clar original. I això és el molt alt nivell Tenint en compte del que és en realitat la criptografia tot sobre. 

Així que anem a arribar-hi. Vegem ara per sota el capó d'alguna cosa ens hem donat per fet la setmana passada, i per aquesta sessió aquí-- la cadena. Una cadena a l'extrem del dia és simplement una seqüència de caràcters. 

Pot ser que sigui hola món, o hola Zamyla, o el que sigui. Però, què significa això per a ser una seqüència de caràcters? De fet, la biblioteca CS50 dóna nosaltres un tipus de dades anomenat cadena. 

Però en realitat no hi ha tal cosa com una cadena en C. Realment és una seqüència de caràcter, caràcters, caràcter, caràcter, cap enrere, cap enrere, a cap enrere, cap enrere, cap enrere a l'interior de la memòria de l'ordinador, o RAM. I veurem més que en el futur, quan ens fixem en la memòria mateixa, i la utilització, i el amenaces que estan involucrats. 

Però considerarem la cadena Zamyla. Pel que només el nom de l'ésser humà aquí, Zamyla, que és una seqüència de caràcters, Z-A-M-I-L-A. I ara anem a suposar que el nom de Zamyla està sent emmagatzemat a l'interior d'un ordinador programa. 

Bé, és lògic pensar que hauríem ser capaç de mirar a aquests personatges individualment. Així que només vaig a dibuixar una mica caixa al voltant el nom de Zamyla aquí. I és el cas en C que quan es tenir una cadena, com Zamyla-- i potser aquesta cadena ha tornat de una funció com a cadena GET, en realitat es pot manipular que caràcter per caràcter. 

Ara, això és pertinent per a la conversa en part, perquè en la criptografia si voleu canviar De A a B i de B a C i C a D, i així successivament, el que necessita per poder mirar els caràcters individuals en una cadena. Has de ser capaç de canviar la Z a una altra cosa, l'A a una altra cosa, el M de una altra cosa, i així successivament. I pel que necessitem una manera, programació, per la per parlar, en C per ser capaç de canviar i mirar les lletres individuals. I podem fer això de la següent manera. 

Déjame anar el cap cap enrere en el IDE CS50. I m'ho dius a mi anar per davant i crear un nou arxiu que vaig a trucar a aquest temps string0, com el nostre primer exemple d'això, punt c. I seguiré endavant i el fuet de la següent manera. 

Pel que inclouen CS50.h, i a continuació, incloure io.h estàndard, el qual gairebé sempre vaig a a utilitzar en els meus programes, almenys inicialment. int buit principal, i després aquí estic va a fer cordes aconsegueix arribar cadena. I després vaig a seguir endavant i fer-ho. Vull anar per davant i, com una comprovació de validesa, acaba de dir, hola, s per cent, punt i coma, fa que la cadena 0. Uh oh, què he fet aquí? Oh, no em connecto. Així lliçó apresa, que No va ser intencional. 

Així error, més cent conversions que els arguments de dades. I aquí és on, en 7-- línia OK, pel que tinc, entre cometes, això és la meva cadena de printf. Tinc un signe de percentatge. Però em falta el segon argument. 

Em falta la coma s, que Jo tenia en els exemples anteriors. Així que una bona oportunitat de corregir una més error, per accident. I ara em deixa córrer string0, el tipus de Zamyla. OK, hola Zamyla. 

Així que ens hem quedat aquest tipus de programa un parell de vegades diferents ara. Però farem alguna cosa 1 mica diferent aquesta vegada. En lloc de només la impressió de Zamyla Nom del conjunt amb printf, ho farem caràcter per caràcter. 

Vaig a utilitzar un bucle. I vaig a lliurar-me una variable de comptatge, anomenat i. I vaig a mantenir la iteració, per la qual sempre i quan i és menor que la longitud de s. 

Resulta, no ho vam fer fer aquesta última vegada, que c ve amb una funció anomenada Stirling. De tornada en el dia, i en general tot i que l'aplicació de funcions, els éssers humans sovint es tria molt noms succintes aquest tipus de so de la mateixa manera que el que vol, encara que és falten algunes vocals o lletres. Així Stirling és el el nom d'una funció que pren una discussió entre parèntesi que ha de ser una cadena. I que només es retorna un enter, la longitud d'aquesta cadena. 

Pel que aquest bucle en la línia 7 que està passant per començar a comptar a i és igual a 0. Es va a incrementar I en cada iteració per 1, tal com ho hem estat fent un parell de vegades. Però va fer només això fins al punt quan i és la longitud de la mateixa cadena. 

Així que aquest és una manera de, en última instància, iterar sobre els caràcters a la cadena com és la següent. Vaig a imprimir no és una cadena sencera, però per cent c, un sol caràcter seguit d'una nova línia. I després vaig a vagi per davant, i necessito dir Vull imprimir caràcter d'ordre i del s. 

Així que si i és la variable que indica l'índex de la cadena, on que està en ella, necessita ser capaç de a dir, dóna'm el caràcter d'ordre i del s. I c té una forma de fer això amb claudàtors. Només cal que digui el nom de la cadena, que en aquest cas és s. A continuació, utilitzeu claudàtors, que són en general just per sobre del Retorn o Intro tecla en el teclat. I a continuació, posar l'índex de la caràcter que voleu imprimir. Així que l'índex es va a ser una number-- 0, o 1, o 2, o 3, o de punt, punt, punt, algun altre número. 

I ens assegurem que es va a ser el número correcte, perquè jo començarà a comptar a 0. I per defecte, el primer caràcter en una cadena és per convenció 0. I el segon caràcter és el suport gener. I el tercer és el suport febrer. I no vol anar massa ara, però no anem perquè som anar només per incrementar i fins que es és igual a la longitud de la cadena. I en aquest moment, Aquest bucle s'aturarà. 

Així que permetin-me anar endavant i guardar aquesta programa i executa make cadena de 0. Però l'he cagada. Declarant implícitament funció de biblioteca Stirling amb tal tipus i tal-- ara, això sona familiar. Però no és printf. I no és arribar cadena. 

No m'equivoco en de la mateixa manera aquest temps. Però notar aquí una mica més avall a més, incloure la capçalera string.h, proporcionar explícitament el declaració de Stirling. Així que en realitat hi ha una pista en aquest país. 

I de fet resulta hi ha un altre arxiu de capçalera que nosaltres no hem fet servir però, a la classe, però és entre els disponibles a vostè, anomenada string.h. I en aquest arxiu, string.h Stirling és declarada. Així que permetin-me seguir endavant i guardar aquesta, fer cordes 0-- agradable, no hi ha missatges d'error aquesta vegada. 

./string0 Zamyla, i Estic a punt de colpejar Enter, moment en el qual es va getString per tornar la cadena, el va posar en s. Després que per el bucle es repetirà sobre els personatges de S d'una en una, i hi imprimeixi una per línia, perquè Havia de n barra invertida al final. Així que podria ometre que la barra invertida n, i després simplement imprimir tota Zamyla en la mateixa línia, reimplementar amb eficàcia printf, que no és del tot útil. Però en aquest cas, jo no he fet això. De fet, he imprès 1 caràcter alhora, un per línia, pel que veiem en realitat l'efecte. 

No obstant això, he d'assenyalar una cosa aquí. I tornarem a això en una setmana futur. Resulta que aquest codi és potencialment defectuós. 

Resulta que la cadena get i algunes altres funcions en la vida no necessàriament sempre torni el que estàs esperant. Sabem per última classe en aquest moment d'arribar cadena se suposa que ha de tornar una cadena. Però el que si l'usuari escriu a terme tals una paraula llarga, o un paràgraf, o un assaig que simplement no hi ha prou memòria a l'ordinador per adaptar-s'hi. 

Igual, ¿i si alguna cosa va mal sota de la campana? Pot ser que no passa sovint, però podria succeir un cop des de fa temps, amb molt poca freqüència. I així resulta que la cadena get i funciona com ho fan no necessàriament sempre tornen cadenes. Podrien tornar algun valor d'error, algun valor sentinella per així dir-ho, que indica que alguna cosa ha anat malament. I només se sabria això des després d'haver après a classe ara, o d'haver llegit algunes més documentació. Resulta que la cadena get pot retornar un valor anomenat nul. Nul és un valor especial que anem a tornar en una setmana futur. Però per ara, només sé que si vull a ser molt adequat per avançar utilitzant cadena GET, em No només ha de cridar-ho, i cegament utilitzar el seu valor de retorn, confiant que es tracta d'una cadena. 

He de dir en primer lloc, Hey, espera un minut, només es procedir si s no és igual null, on null, de nou, és només un valor especial. I és l'únic valor especial ha de preocupar d'aconseguir per a la cadena. Obtenir cadena és ben va per retornar una cadena o nul·la. 

I aquest punt d'exclamació signe d'igual és possible saber de tal classe de matemàtiques que pot dibuixar amb un signe igual una línia a través d'ell per indicar no és igual. Això no és en general un caràcter pot escriure en el seu teclat. I així, en la majoria dels llenguatges de programació, quan es vol dir que no és igual, s'utilitza un signe d'exclamació, també conegut com a explosió. Així que vostè diu és igual a l'explosió, la qual vol dir que no és igual, lògicament. És igual que no hi ha un major que, o igual a, o menys de o igual a la clau en el teclat que ho fa tot en un sol símbol. Per això és que, en els exemples anteriors, que va fer un parèntesi obert, i després un signe d'igualtat, amb la finalitat de fer més gran que o, per exemple, menys de. 

Quina és el menjar per emportar en aquesta llista? Això és simplement una manera d'ara la introducció d'aquesta sintaxi, aquesta característica, iteració en persona caràcters d'una cadena. I de la mateixa manera que els quadrats suports li permeten obtenir en ells, considerar els claudàtors de la manera tipus d'al·lusió a aquest subjacent disseny, de manera que cada caràcter dins d'una cadena és una espècie de caixa en algun lloc sota la campana a la memòria de l'equip. 

Però farem una variant d'aquest. Resulta que aquest programa és correcte. Així per eixos de CS50 per avaluar codi, això és correcte ara. Sobretot ara que estic comprovant null, aquest programa mai ha de bloquejar-se. I jo només sé que a partir de l'experiència. Però no hi ha res més que realment podem equivocar aquí. Però no és molt ben dissenyat, perquè anem a tornar al bàsic. 

En primer lloc, principles-- el que fa un bucle for fer? Un bucle fa tres coses. S'inicialitza alguns valor, si se li pregunta a. Es comprova una condició. I a continuació, després de cada iteració, després de cada cicle, s'incrementa alguns valor o valors, aquí. 

Llavors, què vol dir això? Inicialitzem i a 0. Vam comprovar i ens assegurem i és menor que la longitud d's, que és Z-A-M-I-L-A, pel que és menys de 6. I, de fet, 0 quan menys de 6. 

Imprimim Z del nom de Zamyla. Llavors vam incrementar i 0-1. A continuació, comprovar, és almenys 1 que la longitud de s? La longitud de s és 6. Si, ho és. 

Així és la impressió d'una a nom de Zamyla, ZA. Incrementem i des de 0, a 1, a 2. A continuació, comprovar, és inferior a 2 la longitud del nom de Zamyla. 6- 2 és almenys de 6. Sí, anem a imprimir ara en M El nom de Zamyla, el tercer personatge. 

La clau aquí és que en cada iteració de la història, estic comprovant, és i menor que la longitud d'Zamyla? Però el problema és que Stirling no és una propietat. Aquells de vostès que han programat abans en Java o en altres idiomes pot conèixer la longitud d'una cadena és una propietat, només algunes de només lectura valor. 

En C, en aquest cas, si això és una funció que és, literalment, comptant el nombre de personatges de Zamyla cada vegada cridem a aquesta funció. Cada vegada que es demani l'equip per utilitzar Stirling, que és fer una ullada a Zamyla, i dient Z-A-H-I-L-A, 6. I torna juny. La propera vegada que truqui que dins d'aquest bucle, que va a mirar a Zamyla de nou, per exemple Z-A-M-I-L-A, 6. I es va a tornar juny. Quin és tan estúpida sobre aquest disseny? 

Per què el meu codi no un 5 sobre 5 per al disseny en aquest moment, per dir-ho? Bé, jo estic fent una pregunta innecessàriament. Estic fent més feina del que necessito. 

Així que, encara que la resposta és correcta, estic demanant a l'ordinador, el que és la longitud d'Zamyla de nou, i una altra, i una altra, i una altra? I la resposta és mai canviarà. Sempre va a ser 6. 

Així que una solució millor que això seria aquesta propera versió. Déjame anar per davant i el va posar en una arxiu separat anomenat string1.c, només per mantenir-lo separat. I resulta que en una de llaç, en realitat es pot declarar múltiples variables alhora. 

Així que seguiré I i posar-lo a 0. Però també vaig a afegir una coma, i dir: dóna'm una variable anomenada n, la valor és igual a la longitud de la cadena del s. I ara, si us plau faci la meva condició sempre que i és menor que n. 

Així d'aquesta manera, la lògica és idèntics al final del dia. Però estic recordant la valor 6, en aquest cas. Quina és la longitud del nom de Zamyla? I ho estic posant en el n. 

I encara estic comprovant la condició cada vegada. És de 0 a menys de 6? 1 és inferior a 6? És de 2 a menys de 6, i així successivament? 

Però jo no estic demanant a l'equip de nou, i una altra, el que és la longitud del nom de Zamyla? Quina és la longitud del nom de Zamyla? Quina és la longitud del nom d'aquesta Zamyla? Estic literalment, recordant que el primer i Només respondre a aquesta segona variable n. Així que això ara seria no només correcta, sinó també ben dissenyat. 

Ara, què passa amb l'estil? He nomenat meu variables força bé, diria jo. Són súper succinta en aquest moment. I això és totalment bé. 

Si només té una cadena en un programa, que també podria anomenar-s per cadenes. Si només té una variable per explicar en un programa, que també podria anomenar-i. Si vostè té una longitud, n és super comuns també. Però no he comentat res de la meva codi. 

No he informat a la reader-- si aquest és el meu TF, o TA, o simplement colleague-- el que se suposa a estar passant en aquest programa. I així aconseguir un bon estil, el que jo vull fer és una cosa això- com demanar usuari per a l'entrada. I podria reescriure aquesta qualsevol nombre de maneres. 

Assegureu-vos de S-- assegurar get string retorna una cadena. I després, en aquí-- i això és potser la iterate comment-- més important sobre els personatges de s un alhora. I podria utilitzar qualsevol elecció de l'idioma Anglès aquí per descriure cada d'aquests trossos de codi. 

Cal notar que no he posat una observacions sobre cada línia de codi, en realitat només en la interessant uns, els que tenir algun sentit que podria voler fer molt clar per a algú la lectura del meu codi. I per què diu arribar pregunta a l'usuari per la cadena d'entrada? Fins i tot que un no és necessàriament tot el que descriptiu. Però ajuda a explicar una història, perquè el segona línia de la història és, asseguri obtenir una cadena de retorna una cadena. 

I la tercera línia de la història és, iterar sobre els personatges d'un s en un moment. I ara només per si de cas, Vaig a seguir endavant i afegir un comentari més que simplement diu impressió caràcter i-èsim al s. Ara, què he fet al final del dia? 

He afegit una mica d'anglès paraules en forma de comentaris. significa el símbol de barra barra, hey, ordinador és per a l'ésser humà, no per a vostè, el seu equip. Així que, lògicament, són ignorats. Ells hi són. 

I, de fet, CS50 IDE els mostra com gris, que són útils, però no clau al programa. Observi el que pot fer ara. Si vostè sap C programació o no, simplement es posen d'esquena a aquest programa i descremada els comentaris. Preguntar a l'usuari per a l'entrada, vos arribar cadena retorna una cadena, iterar sobre els personatges de s un alhora, imprimir el caràcter i-èsim caràcter en S-- no ho fa fins i tot haver de mirar el codi per entendre el que fa aquest programa. I, millor encara, si vostè mira en aquest programa d'una setmana o dues, o un mes, o un any, vostè també no té per mirar el codi, tractant de recordar, Què estava tractant de fer amb aquest codi? 

Vostè mateix ha dit. Ho has descrit per si mateix, o algun col·lega, o TA, o TF. I així, aquest seria ara correcta, i el bon disseny, i, finalment, un bon estil també. El mateix passa amb tenir això en ment. 

Així que hi ha una altra El que vaig a fer aquí que ara poden revelar exactament el que està passant per sota el capó. Així que hi ha aquesta característica en C, i altres idiomes, anomenada encasellament que, o bé implícitament o explícitament permet convertir d'un tipus de dades a un altre. Hem estat tractant pel la data d'avui amb cordes. 

I les seqüències són caràcters. Però recordar des de la setmana 0, ¿quins són els caràcters? Els personatges són simplement una abstracció a la part superior dels nombres decimals numbers--, i els números decimals són en realitat una l'abstracció en la part superior dels nombres binaris, com el definim. 

Així caràcters són nombres. I els números són caràcters, simplement en funció del context. I resulta que a l'interior d'un programa d'ordinador, es pot especificar la forma en què voleu cercar en els bits dins d'aquest programa? 

Recordeu que en la setmana 0 que teníem Ascii, que és només el codi cartes d'assignació als nombres. I vam dir, el capital A és 65. Capital B és 66, i així successivament. 

I avís, que essencialment tenim en caràcters la fila superior aquí, com els anomenaria C, caràcters, i després enters en la segona fila. I resulta que es pot convertir sense problemes entre els dos, en general. I si volem fer això deliberadament, es pot ser que desitgi per fer front alguna cosa com això. 

El que es vol convertir majúscula per baixar cas, o minúscules a majúscules. I resulta que no hi ha en realitat un patró ací podem abastar en un moment. Però anem a veure per primera vegada en una exemple de fer això explícitament. 

Vaig a tornar al IDE CS50. Vaig a crear una arxiu anomenat ASCII 0.c. I vaig a seguir endavant i afegir el meu io.h estàndard en la part superior, nul·la principal int a la part superior de la meva funció. I a continuació, només vaig a fer el following-- un bucle d'i és igual, diguem, 65. 

I llavors va a ser inferior a 65, a més de 26 lletres en l'alfabet. Així que vaig a deixar que l'ordinador fer els càlculs per a mi no. I després dins d'aquest bucle, ho vaig a imprimir? 

% C és n% i barra invertida. I ara vull endollar dos valors. He posat temporalment pregunta marca allà per convidar a la pregunta. 

Vull repetir des del 65 en endavant durant 26 lletres de l'alfabet, impressió que en cada iteració equivalent integrant del caràcter. En altres paraules, vull iterar impressió de més de 26 números el que és el caràcter ASCII, la carta, i ho és-- el número corresponent en realitat només recreant el gràfic d'aquesta diapositiva. Llavors, què haurien de ser aquests signes d'interrogació? 

Doncs bé, resulta que el segon un de sol ha de ser la variable i. Vull veure que a mesura que un nombre. I l'argument de mitja aquí, puc dir-li a l'ordinador per tractar aquest sencer I com un caràcter, de manera que per substituir-aquí per cent C. 

En altres paraules, si jo, el programador humà, saber aquests són només números al final del dia. I sé que el 65 ha de assignar a una mica de caràcter. Amb aquesta conversió explícita, amb un parèntesi, el nom del tipus de dades que voleu convertir, i un parèntesi tancat, vostè pot dir la equip, hey, ordinador, convertir aquest sencer en un char. 

Així que quan corro aquesta programa després de compilar, anem a veure el que faig get-- ASCII 0. Maleïda sigui, què he fet malament? Utilitzeu d'identificador no declarat, bé, no intencional, però veurem si no podem raó per això. 

Així five-- línia, així que no entenc molt lluny abans de ficar la pota. Està bé. Així la línia 5 per a i és igual a 65-- veig. Així que recorda que en C, a diferència d'alguns idiomes si vostè té la programació prèvia experiència, vostè té per indicar a l'ordinador, a diferència de les ratllades, el tipus de variable que és. 

I es va oblidar una contrasenya aquí. A la línia cinc, He començat a utilitzar i. Però no li he dit C les dades que tipus és. Així que em vaig a anar d'aquí i dir, ah, fan que sigui un nombre sencer. 

Ara vaig a seguir endavant i tornar a compilar. Que fixa que. ./ascii0 Enter, seria una mena de fresc. No només és súper ràpid a demanar-li a l'ordinador aquesta pregunta, en lloc de mirar cap amunt sobre un portaobjectes, s'imprimeix una per línia, A és 65, B és 66, tot el camí des que down-- va fer això 26 vegades-- de les lletres Z, que és 90. I, de fet, lleugerament més intel·ligent faria han estat per a mi no confiar a l'ordinador per afegir 26. Em podria haver fet 90, així, sempre ja que no cometre el mateix error dues vegades. Vull anar cap amunt a través z, no només a través de i. 

Així que aquesta és una conversió explícita. Resulta que aquest Ni tan sols cal. Déjame anar per davant i tornar a executar aquest compilador, i torneu a executar ASCII 0. Resulta que C és molt intel·ligent. 

I printf, en particular, és molt intel·ligent. Si vostè només ha de passar un i dos cops per a tots dos marcadors de posició, printf es donarà compte, oh, així que et conec em va donar un integer-- algun número, igual que 65, o 90, o el que sigui. Però veig que vostè em vol donar format a aquest nombre com un personatge. I així implícitament printf pot llançar l'int a char per a vostè també. Així que això no és un problema en absolut. 

Però noti, a causa d'aquesta equivalència que realment podem fer això també. Déjame seguir endavant i fer una una altra versió de això- 1.c ASCII I en comptes d'una iteració sencers, realment pot volar la teva ment iterant sobre els personatges. Si un char c aconsegueix el capital A, I vulgui seguir endavant i fer això, sempre i quan C és menor que o igual A a la Z. capital i en cada iteració Vull incrementar C, que pugui Ara en la meva línia printf aquí per exemple, el percentatge de C és i per cent més, coma C. 

I ara, puc anar a l'altra direcció, fosa el caràcter explícitament a un sencer. Així, de nou, per què fas això? És una mica estrany per ordenar de explicar en termes de caràcters. 

Però si vostè entén el que està passant per sota de la campana, en realitat no hi ha màgia. Només ho dius, bé, equip donen em una variable anomenada C de tipus char. Inicialitzar al capital A. I notar única qüestió cometes. 

Per als caràcters en C, retirar de la la setmana passada, s'utilitzen cometes simples. Per cadenes, per a les paraules, frases, s'utilitzen cometes dobles. OK, ordinador, seguir fent això, per la sempre que el personatge és menor que o igual a z. I sé de la meva taula ASCII que tots d'aquests codis ASCII són contigües. 

No hi ha cap buit. Així que és només l'A a la Z, separats per un nombre cada un. I llavors puc incrementar un char, si realment vull. Al final del dia, és només un número. Sé que això. Així que només puc suposar afegir 1 a la mateixa. 

I després d'aquest temps, puc imprimir c, i després l'equivalent integral. I ni tan sols necessita la conversió explícita. Puc deixar printf i la Figura ordinador les coses, de manera que ara si em quedo fer Ascii1./ascii1, Em surt exactament el mateix també. 

programa inútil, ningú aunque-- en realitat es va a escriure programari per tal d'esbrinar, el que va ser el nombre que s'assigna a A, o B, o Z? Només vas a Google, o buscar-la en línia, o busqueu- en una diapositiva, o similars. Llavors, on aquesta realitat obtenir útil? 

Bé, parlant d'aquest diapositiva, observi que hi ha un patró real aquí entre majúscules i minúscules que no va ser accidental. Observi que el capital A és 65. A minúscula és 97. I a quina distància és menor cas una? 

Així que 65 és el nombre de passos de 97? Almenys el 97 65 és 32. Així que el capital és un 65. Si s'agrega 32 al fet que, s'obté a minúscula. I, el que és equivalent, si es resta 32, a tornar al capital A-- mateix amb B a poc B, C gran a poc c. 

Totes aquestes deficiències són 32 a part. Ara, això semblaria que ens permeti fer alguna cosa com Microsoft Word, o Google Docs compten, on pot seleccionar tot i després dir, canviar tot en minúscules, o canviar tot en majúscules, o canviar només la primera paraula d'una oració a majúscules. De fet, podem fer alguna cosa de la mateixa manera que a nosaltres mateixos. 

Déjame anar per davant i desar un fitxer aquí es diu capitalitzar 0.c. I seguirem endavant i preparar ràpidament un programa que fa exactament això de la següent manera. Pel que inclouen la biblioteca CS50. I inclouen E / S estàndard. 

I sé que això és molt aviat. Així que vaig a posar-lo en ja, string.h, així que no tinc accés a coses com Stirling, i després int buit principal, com de costum. I després vaig a seguir endavant i fer cordes aconsegueix obtenir la seqüència, només per obtenir una cadena de l'usuari. I després vaig a fer la meva comprovació de validesa. Si cadena no és igual a un valor nul, llavors és segur procedir. I què és el que vull fer? Vaig a repetir des i és igual a 0, i n fins a la longitud de cadena del s. 

I vaig a fer això, sempre que i és menor que n, i jo i més. Fins al moment, estic realment només préstecs idees d'abans. I ara vaig a introduir una branca. 

Així que pensar en tornar a les ratllades, on vam tenir aquestes bifurcacions en el camí, i la setmana passada a C. vaig a dir això, si el caràcter i-èsim en s és major o igual a minúscules a, i- en Scratch que, literalment, ho faria diu i, però en C dius signe, ampersand-- i el caràcter i-èsim en s és menor que o igual a minúscules z, farem alguna cosa interessant. Anem a imprimir una realitat caràcter de nova línia sense aquest és el caràcter de la cadena, el caràcter i-èsim en la cadena. 

Però seguirem endavant i restar 32 d'ella. Perquè si el personatge de la cadena que estem buscant No està entre una mica i poc z, endavant i acaba d'imprimir a terme sense canvis. Així que hem introduït aquesta notació entre claudàtors per als nostres fils perquè en el i-èsim caràcter de la cadena. 

He afegit una mica de lògica condicional, igual Zero en la primera setmana de la setmana passada, on Només estic fent servir el meu fonamental comprensió del que és passant per sota el capó. És el caràcter i de s major o igual a un? Igual, que és 97 o 98, o 99, i així successivament? 

Però és també menor que o igual al valor de z en minúscules? I si és així, què significa aquesta línia? 14, això és una espècie de la germen de la idea, capitalitzar la carta simplement restant 32 d'ella, en aquest cas, perquè sé, per això carta, com es representen els meus números. Així que seguirem endavant i executar aquest, després de compilar capitalitzar 0.c, i córrer capitalitzar 0. 

Escriurem una mena Zamyla entrar en minúscules. I ara tenim Zamyla en majúscules. Anem escrigui en Rob en minúscules. Tractarem de Jason en minúscules. I seguim aconseguir el capitalització forçada. Hi ha un error menor que jo tipus de no anticipar. Observi el meu nou símbol és acabar en la mateixa línia que els seus noms, que se sent una mica desordenat. 

Així que vaig a anar-hi, i en realitat al final d'aquest programa imprimir un caràcter de nova línia. Això és tot. Amb printf, que no cal passar variables o codi de format. Vostè pot, literalment, només imprimir una mena de nova línia. 

Així que seguirem endavant i fer 0 capitalitzar de nou, tornar a executar-lo, Zamyla. I ara és una mica més bonic. Ara, el meu indicador està en la seva pròpia línia nova. Així que això és tot fi i bo. Així que és un bon exemple. Però no ho sé si més no necessàriament necessitarà codificar el 32. Tu saps que? Podria dir-- no ho faig mai recordi quina és la diferència. 

Però sé que si jo tenir una lletra minúscula, Jo vull restar essencialment fora qualsevol que sigui la distància és d'entre poc una de gran i A, perquè si jo suposo que totes les altres cartes són els mateixos, que ha de fer la feina. Però en lloc de fer això, saps què? Hi ha una altra manera encara. 

Si això és capitalitzar 1.c-- si fos per posar això en un arxiu separat. Farem capitalitzar 2.c de la següent manera. Vaig a netejar realment és aquí. I en comptes d'haver de sap ni li importa sobre aquells baix nivell detalls d'implementació, sóc vegada només va a imprimir un caràcter, entre cometes, C cent, i a continuació, trucar a una altra funció que hi ha que pren un argument, que és un personatge, com aquest. 

Resulta que en C, hi ha una altra crida a la funció a superior, que com el seu nom suggereix pren un caràcter i ho fa al seu majúscules equivalent, i després el torna de manera que printf pot connectar-hi. I així, per fer això, però, em que hagi d'introduir un altre arxiu. Resulta que hi ha un altre arxiu que només se sabria de la classe, o un llibre de text o una línia referència, anomenat type.h. C 

Així que si afegeixo que fins entre els de la meva capçalera arxius, i ara tornar a compilar aquest programa, capitalize2, ./capitalize2 Retorn. Anem escrigui a Zamyla en tot minúscula, segueix funcionant de la mateixa. Però saps què? Resulta que a la part superior té alguna altra funcionalitat. 

I vaig a presentar aquesta comandar aquí, una mena de malaptesa anomenat, però l'home per al manual. Resulta que la majoria dels sistemes Linux, com estem utilitzant aquí-- operatiu Linux system-- tenir un domini anomenat home, que diu: Hey, ordinador, dóna'm el manual de l'equip. Què és el que desitja mirar cap amunt en aquest manual? 

Vull veure la funció cridats a superior, Retorn. I és una mica críptic llegir de vegades. Però Recordeu que estem en el Manual del Programador de Linux. I és tot el text. I l'avís que hi ha la nom de la funció aquí. Resulta que té un cosí anomenat per baixar, el que fa el contrari. I la notificació esmentada en resum, per utilitzar aquesta funcionar la pàgina del manual, per així dir-ho, M'està dient que jo d'incloure c type.h. I sabia que a partir de la pràctica. 

Aquí, m'està mostrant els dos prototips per a la funció, pel que si alguna vegada vull fer servir aquest Jo sé el que prenen com a entrada, i el tornen com a sortida. I llavors si llegeixo la descripció, veig amb més detall el que fa la funció. Però el més important, si Miro baix valor de retorn, es diu que el valor retornat és la de la lletra convertit, o C, l'entrada original, si la conversió no era possible. 

En altres paraules, a superior a tractar per convertir una lletra en majúscules. I si és així, que va a tornar-lo. Però si no pot per alguna reason-- potser és el cas ja superior, potser és un signe d'exclamació o alguna altra punctuation-- que només va a tornar el C original, que vol dir que puc fer que el meu codi millor dissenyat de la següent manera. 

No necessito tots aquestes línies de codi maleït. Totes les línies que he Només pot ressaltat col·lapsar-se en un senzill línia, que és això- cent printf c per suport superior S i. I això seria una exemple d'un millor disseny. 

Per què implementar en 7 o 8 línies de codi, el que fos que acabo suprimit, quan en el seu lloc pot col·lapsar tots els que la lògica i la presa de decisions en una sola línia, ara 13, que es basa en una biblioteca function-- una funció que ve amb C, però que fa exactament el que vol que faci. I, francament, fins i tot si que no va venir amb C, es podria aplicar a mà com es que hem vist, amb arribar int negatiu i obtenir positius int la setmana passada també. 

Aquest codi ara és molt més fàcil de llegir. I, de fet, si ens desplacem cap amunt, mira com molt més compacte aquesta versió del meu programa és. És una mica pesat sobre ara, Amb tot això inclou. Però això està bé, perquè ara estic de peu sobre les espatlles dels programadors abans que jo. I qualsevol que implementat per realment superior em va fer un favor, igual que qualsevol implementat realment Stirling em va fer un favor fa algun temps. I pel que ara tenim una millor programa de disseny que implementa exactament la mateixa lògica. 

Parlant de Stirling, va deixar Em seguir endavant i fer això. Déjame anar per davant i guardar aquesta imatge com stirling.c. I resulta que, podem pelar una altra capa bastant simple ara. Vaig a seguir endavant i fuet un altre programa en el principal aquí que simplement re-eines longitud de la cadena de la següent manera. Així que aquí hi ha una línia de codi que Me per crear una cadena de l'usuari. Seguim fent servir una vegada i una altra. Déjame posar-me una variable anomenada n de tipus int que emmagatzema un nombre. 

I em va deixar anar endavant i fer el següent lògica. Mentre que el personatge fa enèsim en s és igual a 0 barra invertida, endavant i incrementar n. I després imprimir printf cent i n. Jo reclamo que aquest programa aquí, sense cridar l'longitud de la cadena, s'adona de la longitud d'una cadena. 

I la màgia és enterament encapsulat en la línia 8 aquí amb el que sembla ser una nova sintaxi, aquesta barra invertida 0 cometes simples. Però ¿per què és això? Bé, tingui en compte el que ha estat passant tot aquest temps. 

I com una banda abans que m'oblidi, s'adonen també, que, a més de les pàgines man que vénen amb un típic sistema Linux com CS50 IDE, adonar-se que nosaltres, els El personal de l'descomptat, també fet un lloc Versió d'aquesta mateixa idea anomenada reference.cs50.net, que té totes aquestes mateixes pàgines del manual, tot d'aquest mateix documentació, així com una petita caixa a la part superior que permet a convertir tota la justa llenguatge arcà en menys còmode la manera, en el qual, el professorat, han passat per i tractat de simplificar alguna cosa de la llengua per mantenir les coses centrat en les idees, i no alguns dels aspectes tècnics. Així que tenir en compte, reference.cs50.net com un altre recurs també. 

Però ¿per què funciona la longitud de la cadena de la forma en què vaig proposar fa un moment? Aquí hi ha el nom de Zamyla nou. I aquí hi ha el nom de Zamyla encaixonat, com segueixo fent, per pintar un quadre d'ell que és, en realitat, només una seqüència de caràcters. Però Zamyla no existeix en l'aïllament en un programa. 

Quan s'escriu i executa un programa, vostè està utilitzant el seu Mac o PC com la memòria, o RAM per així dir-ho. I que es pugui imaginar l'ordinador com tenir una gran quantitat de gigabytes de memòria en aquests dies. I un concert significa milers de milions, per la qual cosa milers de milions de bytes. 

Però anem a retrocedir en el temps. I suposem que estem utilitzant un equip molt vell que només té 32 bytes de memòria. Vaig poder, en la meva pantalla d'ordinador, simplement dibuixar això de la següent manera. 

Jo podria simplement dir que el meu equip té tota aquesta memòria. I això és com un pal de memòria, si Recordes la nostra imatge de l'última vegada. I si em divideixo en aquest número suficient de vegades, Puc reclamar que tinc 32 bytes de la memòria a la pantalla. 

Ara, en realitat, només puc dibuixar fins el moment en aquesta pantalla aquí. Així que seguiré endavant, i just per convenció, cridar la memòria de l'ordinador com reixeta, no només com una línia recta. En concret, reclam ara que aquesta reixeta, aquest 8 per 4 reixeta, simplement representa els 32 bytes de memòria disponible al meu Mac, o disposar d'un PC. I estan embolicant en dues línies, just perquè s'ajusta més a la pantalla. Però aquest és el primer byte. Aquest és el segon byte. Aquesta és la tercera byte. 

I aquest és el byte número 32. O bé, si pensem com un ordinador científic, és a dir byte 0, 1, 2, 3, 31. Pel que té de 0 a 31, si es comença a comptar a 0. 

Així que si fem servir un programa que les trucades queden cadena, i obtenim una cadena humana des de la com jo ho vaig fer anomenat Zamyla, Z-A-H-I-L-A, com en el món fa el no perdre l'ordinador dels quals bytes, el qual tros de memòria, pertany a quina seqüència? En altres paraules, si es procedeix a escriure un altre nom a l'ordinador, com això Andi, trucant obtenir una cadena d'una segona vegada, A-N-D-I ha d'acabar al la memòria de l'ordinador també. Però com? 

Doncs bé, resulta que per sota de la capó, el que fa C a l'emmagatzemar cadenes que els tipus humans a, o que provenen d'alguna altra font, que és delinea la finalitat d'ells amb una barra invertida character-- especial 0, que és només una forma especial de dir 80 bits en una fila. 

Així A-- aquest és el record el nombre 97. Així algun patró de 8 bits representa el nombre decimal 97. Aquesta barra invertida 0 és, literalment, el nombre 0, nul àlies, N-O-L, a diferència d'abans, N-O-L-L, que hem parlat. Però per ara, només sé que aquest 0 barra invertida es troba a 80 bits en una fila. 

I és només aquesta línia en el sorra que es diu res a l'esquerra pertany a una cadena, o un tipus de dades. I qualsevol cosa a la dreta pertany a una altra cosa. Nom d'Andi, per la seva banda, que acaba visualment succeeix per embolicar a l'altra línia, però això és només un detall estètic, De la mateixa manera s'acaba nul. 

És una cadena de caràcters d'un A-N-D-I, a més d'un cinquè caràcter secret, tots els bits 0, que simplement demarca al final del nom d'Andi també. I si cridem a obtenir una cadena d'una tercera vegada a l'ordinador per obtenir una cadena com Maria, H-A-R-I-A, de manera similar és Maria de nul nom acaba amb una barra invertida 0. 

Aquesta és fonamentalment diferent des de com un ordinador faria normalment emmagatzemar un nombre enter o un flotador o un altre tipus de dades tranquils, en el record, un enter és en general de 32 bits, o 4 bytes, o potser fins i tot 64 bits, o vuit bytes. No obstant això, molts primitives en un ordinador en un llenguatge de programació tenir un nombre fix de bytes sota de la hood-- potser 1, 2 potser, potser 4, potser 8. 

Però les cadenes, per disseny, tenen una Nombre dinàmica de caràcters. No sap per endavant, fins els tipus humans en Z-A-M-I-L-A, o M-A-R-I-A, o A-N-D-I. Vostè no sap el nombre de vegades que l'usuari va a colpejar el teclat. Per tant, vostè no sap com molts personatges d'antelació necessitaràs. 

I el que C només tipus de fulles com una molla de pa secreta sota de la campana al final de la cadena. Després d'emmagatzemar Z-A-M-I-L-A en la memòria, també només posa l'equivalent d'un període. Al final d'una frase, que posa 80 bits, per tal de recordar on Zamyla comença i acaba. 

Llavors, quin és la connexió, llavors, per a aquest programa? Aquest programa aquí, Stirling, és simplement un mecanisme per aconseguir una cadena per part de l'usuari, la línia 6. Línia 7, declaro una variable n trucada i la va posar igual a 0. 

I després, en la línia 8, simplement li vaig preguntar la qüestió, mentre que el caràcter n-èsim fa no és igual tot 0 bits-- en altres paraules, no fa igualtat d'aquest especial caràcter, la barra invertida 0, que era només que character-- nul especial seguir endavant i només s'incrementa n. 

I seguir fent-ho, i mantenir fent-ho, i seguir fent-ho. I així, tot i que en el passat hem utilitzat i, que està perfectament bé semànticament utilitzar n, si vostè està tractant de comptar aquest temps deliberadament, i només volen cridar n. Així que això només segueix fent la pregunta, és el caràcter d'ordre n de s tots 0s? Si no és així, busqui en l'aspecte, mirar cap al costat, mira a la següent, mirar a la següent. 

Però tan aviat com vostè veu barra invertida 0, aquesta línia loop-- 9 a 11-- s'atura. Es trenca fora del bucle while, deixant a l'interior d'aquesta variable n un recompte total de tota la caràcters de la cadena que el va veure, d'aquesta manera la impressió cap a fora. Així que anem a provar això. 

Déjame anar per davant i, sense utilitzant la funció de stirling, però només fent servir la meva pròpia versió de collita pròpia aquí es diu stirling, deixa anar per davant i córrer stirling, escrigui alguna cosa com Zamyla, que sé per endavant és de sis caràcters. Ja veurem si funciona. De fet, són les sis. Anem a provar amb Rob, tres personatges, tres caràcters, així, i així successivament. Així que això és tot el que està passant de sota el capó. I notar les connexions, Després, amb la primera setmana de la classe, on vam parlar sobre una mena de l'abstracció, el qual és només aquesta estratificació de les idees, o complexitat, a la part superior dels principis bàsics. En aquest cas, estem buscant una mena de sota el capó de Stirling, per així dir-ho, d'esbrinar, com seria posat en pràctica? 

I podríem executar-la de nou nosaltres mateixos. Però estem mai més va per tornar a posar en pràctica Stirling. Només anem a stirling utilitzar per tal per aconseguir realment certa extensió cordes. 

Però no hi ha màgia sota de la campana. Si sap que sota el capó, una cadena és simplement una seqüència de caràcters. I aquesta seqüència de caràcters tots poden ser tractats numèricament 0 amb el suport, suport 1, suport 2, i saber que al final d'una cadena és una caràcter especial, es pot esbrinar com fer gairebé qualsevol cosa en una programa, perquè tot es redueix a és la lectura i escriptura de la memòria. És a dir, el canvi i mirant en la memòria, o moure coses al voltant de la memòria, coses d'impressió a la pantalla, i així successivament. 

Així que ara utilitzarem aquesta recent descoberta comprensió del que en realitat cordes estan sota la campana, i pelar una altra capa que fins ara hem estat ignorant per complet. En particular, qualsevol moment hem implementat un programa, que hem tingut aquesta línia de codi prop de la part superior declarant principal. I hem especificat int void main. 

I aquest buit dins dels parèntesis ha estat dient tot aquest temps que la principal per si mateix no té cap argument. Qualsevol entrada que el principal és va a obtenir dels usuaris ha de venir d'alguna altra mecanisme, com get int, o aconseguir flotador, o obtenir la seqüència, o alguna altra funció. Però resulta que quan s'escriu un programa, en realitat es pot especificar que aquest programa està prendre les entrades de la humana en la pròpia línia d'ordres. 

En altres paraules, tot i que fins al moment han estat funcionant només ./hola hola o programes similars, tots de la altres programes que hem estat utilitzant, que nosaltres mateixos no escrivim, ha estat prenent, segons sembla, arguments-- línia d'ordres coses com el maquillatge. Vostè diu alguna cosa així com maquillatge, i després una segona paraula. O so metàl·lic, dius so metàl·lic, i després una segona paraula, el nom d'un arxiu. 

O fins i tot RM o CP, com es pot han vist o ja utilitzat per eliminar o copiar arxius. Tots els que prenen els anomenats arguments-- línia d'ordres paraules addicionals en la línia d'ordres. Però fins ara, ens nosaltres mateixos no han tingut aquest luxe de prendre l'entrada de la usuari quan ell o ella realment funciona el propi programa a la línia d'ordres. 

Però podem fer que en tornar a declarar principal cap endavant, no com tenir anul·lar entre parèntesis, però aquests dos arguments instead-- el primer un nombre sencer, i la segona una mica nou, una cosa que anomenarem una matriu, alguna cosa similar en esperit al que vam veure en Scratch com una llista, però una matriu de cadenes, com aviat veurem. Però anem a veure això A tall d'exemple, abans que distingir exactament el que això significa. 

Així que si entro a CS50 IDE aquí, m'he anat per davant i va declarar en un arxiu anomenat argv0.c la següent plantilla. I noti l'única això és diferent en el que va és que he canviat buit a int argc cadena argv suport d'obrir, tancar suport. I l'avís per ara, no hi ha res dins d'aquests suports. 

No hi ha un nombre. I no hi ha i, o n, o qualsevol altra lletra. Només estic fent servir el claudàtors, per ara, per raons anem a venir tornar en un moment. 

I ara el que vaig a fer és el següent. Si argc és igual a igual 2-- i recorden que és igual als iguals és l'operador d'igualtat comparar l'esquerra i la dreta per la igualtat. No és l'assignació operador, que és el signe igual única, el que significa que la còpia des de la dreta a l'esquerra un cert valor. 

Si argc és igual a igual a 2, vull per exemple, printf, hola, percentatges, nova línia, i després connecti en-- i aquí està la nova suport de argv trick-- 1, per raons que anem a tornar en un moment. Perquè si no ho fa argc igual a 2, saps què? Seguirem endavant i, com de costum, imprimir terme hola món sense substitució. 

Per tant, semblaria que si argc, que representa el nombre d'arguments, és igual a 2, Vaig a imprimir hola una cosa o una altra. Altrament, per defecte, estic va a imprimir hola món. Llavors, què vol dir això? 

Bé, deixa anar per davant i guardar aquesta imatge i, a continuació, fer que argv0, i després ./argv0, Retorn. I diu hola món. Ara, per què? 

Doncs bé, resulta que en qualsevol moment que executar un programa a la línia d'ordres, s'està omplint en el que anem a en general, trucar a un vector d'argument. En altres paraules, de forma automàtica la ordinador, el sistema operatiu, es va a lliurar al seu programa si mateix una llista de totes les paraules que l'ésser humà ha teclejat en el símbol, en cas que el programador vol fer alguna cosa amb aquesta informació. I en aquest cas, l'única paraula M'he teclejat en l'indicador és ./argv0. 

I pel que el nombre d'arguments que es es passa al meu programa és només un. En altres paraules, l'argument comptar, també conegut com argc aquí com un sencer, és només un. Un, per descomptat, no és igual a dos. I així que això és el que imprimeix, hola món. 

Però m'ho dius a mi prendre això en algun lloc. Permetin-me dir, argv0. I llavors què hi ha de Maria? I a continuació, premeu la tecla Enter. 

I adonar-se del que passa aquí màgicament. Ara, en comptes de hola món, no tinc canviat el comportament d'aquest programa mitjançant l'adopció de l'entrada no des get cadena o alguna altra funció, però a partir de, pel que sembla, el meu comandament en si, el que originalment escrit en. I puc jugar a aquest joc de nou pel canviant-a Stelios, per exemple. 

I ara veig un altre nom encara. I aquí, podria dir Andi. I podria dir Zamyla. I podem jugar a aquest joc durant tot el dia, acaba de connectar diferents valors, sempre que proporciono exactament dues paraules en l'indicador, de tal manera que argc, compti el meu argument, és 2. 

Veig que el nom endollat ​​a printf, per aquesta condició en aquesta llista? Per tant, sembla que tenim ara la capacitat expressiva de prendre l'aportació d'un altre mecanisme, des de la línia d'ordres trucada, en lloc d'haver d'esperar fins que l'usuari executa el programa, i després li demanarà utilitzen una part com a cadena GET. 

Així que Què és això? Argc, de nou, és només un nombre sencer, el nombre de paraules- arguments-- que l'usuari proporcionada en el símbol, a la finestra de terminal, incloent-hi el nom del programa. Així que la nostra ./argv0 és, efectivament, el nom del programa, o com executar el programa. 

Això explica com una paraula. Així argc seria 1. Però quan escric Stelios, o Andi, o Zamyla, o Maria, això vol dir que el nombre d'arguments és de dos. I pel que ara hi ha dues paraules s'ha passat. 

I avís, podem continuar amb aquesta lògica. Si en realitat dic una mena de Zamyla Chan, un nom complet, passant d'aquesta manera 03:00 arguments en total, Ara es diu que el defecte de nou, perquè, per descomptat, 3 no és igual a 2. 

I així, d'aquesta manera, he accés a través d'aquest nou argument argv que tècnicament podria trucar a qualsevol cosa que vulguem. No obstant això, per convenció, és argv i argc, respectivament. Argv, vector argument, és una espècie d'un sinònim d'una programació característica de C diu una matriu. 

Una matriu és una llista de valors similars cap enrere, cap enrere, cap enrere, cap enrere. En altres paraules, si un és just aquí, a RAM, el següent és just al costat d'ella, i just al costat d'ella. No són per tot el lloc. I que aquest últim escenari, on les coses són per tot el lloc en la memòria, en realitat pot ser una característica de gran abast. Però anem a tornar a això quan ens parlar d'estructures de dades més elegants. Per ara, una matriu és només una tros de memòria contigua, cada un dels elements són cap enrere, cap enrere, cap enrere, cap enrere, i generalment del mateix tipus. 

Així que si es pensa, a partir d'una Fa moment, el que és una cadena? Bé, una cadena, com Zamyla, Z-A-H-I-L-A, és, tècnicament, simplement una matriu. És un conjunt de caràcters. 

I així, si és que realment traiem això, com he ho va fer abans, com un tros de memòria, resulta que cada un d'aquests personatges reprèn un byte. I després hi ha aquest especial caràcter sentinella, la barra invertida 0, o els vuit bits de 0, que es demarca al final d'aquesta cadena. Així que una cadena, es converteix terme, citar cadena de tancament de cometes, és simplement un conjunt de chara-- xerrada ser un tipus de dades real. 

I ara argv, meanwhile-- anirem de nou al programa. Argv, tot i que veiem la paraula cadena aquí, no és una cadena en si. Argv, l'argument del vector, és una matriu de cadenes. 

Així mateixa manera que pot tenir una gran varietat de caràcters, que poden tenir un nivell més alt, una matriu de strings-- així, per exemple, quan vaig escriure fa un moment ./argv0 argv0, l'espai Z-A-H-I-L-A, que va afirmar que argv tenia dues cadenes en ./argv0 it--, i Z-A-M-I-L-A. a altres paraules, argc era 2. Perquè és això? 

Bé, efectivament, el que està passant és en què cadascuna d'aquestes cadenes és, per descomptat, una matriu de caràcters Com abans, cada un dels personatges ocupa un byte. I no cal confondre el 0 real en el nom del programa amb el 0, el que significa que els 80 bits. I Zamyla, per la seva banda, segueix sent També una sèrie de caràcters. 

Així que al final del dia, el que realment sembla que aquesta sota de la campana. Però argv, per la naturalesa de la forma principal obres, em permet embolicar tot això per obtenir, si es vol, un arranjament més gran que, si una mica més de simplificar el que la imatge s'assembla i no fer bastant dibuixar a escala allà, aquesta matriu és només de mida 2, la primera element dels quals conté una cadena, el segon element de que conté una cadena. I, al seu torn, si tipus de zoom en cada d'aquestes cadenes, el que veure sota la campana és que cada cadena és només una matriu de caràcters. 

Ara, igual que amb les cadenes, hem estat capaços d'aconseguir l'accés al caràcter i-èsim d'una sèrie usant aquesta notació de claudàtors. De la mateixa manera, amb matrius en general, podem utilitzar notació de claudàtors per obtenir en qualsevol nombre de cadenes en una matriu? Per exemple, em va deixar seguir endavant i fer-ho. 

Déjame seguir endavant i crear argv1.c, que és una mica diferent aquesta vegada. En lloc de la comprovació de argc2, Vaig a fer això al seu lloc. Per int amb si 0, i és menor que argc, jo i més, i després imprimir a l'interior d'aquesta, cent s, nova línia, i després argv suport de i. 

Així, en altres paraules, no estic tractant amb caràcters individuals en el moment. Argv, com es dedueix d'aquests casella buida els suports a la dreta del nom de argv, significa argv és una matriu de cadenes. I argc és només un int. 

Aquesta línia aquí, 6, és dient conjunt i igual a 0. Comptar tot el camí fins, però no incloent-hi, argc. I a continuació, en cada iteració, imprimir una cadena. El corda? 

La cadena d'ordre i en argv. Així que, abans que fos utilitzant el claudàtor notació per arribar a la i-èsima caràcter d'una cadena, ara Estic usant la notació de claudàtors per arribar a la cadena i-èsima d'una matriu. Així que és una cosa d'una capa anteriorment, conceptualment. 

I així, el que és bo d'aquest programa d'ara, si puc compilar argv1, i després fer ./argv1 i escriviu en una mena foo bar baz, que són les tres paraules que un defecte Informàtic arriba per a qualsevol moment ell o ella necessita algunes paraules de marcador de posició, i premeu la tecla Enter, cadascuna d'aquestes paraules, incloent el nom del programa, el qual està en argv a la primera ubicació, acaba sent impreses d'una en una. I si canvi d'això, i dic una mena de argv1 Zamyla Chan, obtenim els tres dels paraules, que és argv0, argv1, argv2, ja que en aquest argc cas, el recompte, es 3. 

Però el que és interessant és si s'entén argv que és només una matriu de cadenes, i entén que una cadena és un conjunt de caràcters, en realitat podem utilitzar aquest tipus de notació de claudàtors diverses vegades per triar una cadena, i després triar un caràcter dins de la cadena, busseig en el més profund de la següent manera. En aquest exemple, em va deixar anar endavant i cridar a aquest argv2.c. I en aquest exemple, deixa anar per davant i fer el following-- per int i obtenir 0, i és menor que argc, i més a més, igual que abans. Així, en una altra paraules-- i ara això està aconseguint bastant complicat. A continuació vaig a dir iterar sobre cadenes en argv, com un comentari a mi mateix. I després vaig a tenir una niat per al llaç, que és probable ho han fet, o es considera fent, en Scratch, on Vaig a dir que sóc int-- no es va a utilitzar de nou i, perquè jo no vull a l'ombra, o tipus de sobreescriure l'i existent. 

Vaig a, en lloc de, diguem j, perquè això és el meu anar a la variable després que, quan jo només intento comptar nombres simples. Per j aconsegueix 0-- i també, n, va obtenir la longitud de popa del suport de argv I, sempre que j és inferior a m, j plus plus, feu el següent. I aquí hi ha la part interessant. 

Imprimir un caràcter i una nova línia, endollar el suport argv i, j suport. OK, així que permetin-me afegir alguns comentaris aquí. Iterar sobre personatges a la cadena actual, impressió de caràcters j-èsim en la cadena d'ordre i. Així que ara, considerarem el que signifiquen aquests comentaris. 

Iterar sobre les cordes en argv-- quants cadenes estan en argv, que és una matriu? Argc molts, així que estic iterant des i és igual a 0 fins argc. Mentrestant, el nombre de caràcters es troben a la cadena d'ordre i en argv? 

Doncs bé, per obtenir aquesta resposta, Acabo de trucar longitud de la cadena en la cura de cadena actual I aproximadament, que és argv suport de i. I vaig a emmagatzemar temporalment que valor de n, només per a fins d'emmagatzematge en memòria cau, recordar que per a l'eficiència. I després vaig inicialitzar j a 0, seguir endavant, sempre que j és menor que n, i en cada increment iteració j. 

I llavors aquí, per meu comentari en la línia 12, imprimir un caràcter, seguit d'una nova línia, suport específicament argv i em dóna la cadena i-èsim en argv-- pel que la primera paraula, la segona paraula, la tercera paraula, el que sigui. I cau en picat en j més profund, i obté jo el caràcter j-èsim de la paraula. I així, en efecte, es pot tractar argv com un multi-dimensional, com una de dues dimensions, matriu, de manera que cada paraula amable de mirades com aquest en la seva ment de ull, i cada personatge és una espècie de compost en una columna, si això ajuda. 

En realitat, quan ens burlem aquesta separació, en les setmanes següents, que va a ser una mica més sofisticat que això. Però el que realment pot pensar que, per ara, tan sols per aquesta bidimensional matriu, de manera que un nivell d'ella és tot de les cordes. I llavors si busseig al més profund, pot arribar als caràcters individuals en ella mitjançant l'ús d'aquesta notació aquí. 

Llavors, quin és l'efecte net? Déjame anar endavant i fer rematadament argv2-- ella. He comès un error aquí. Declarant implícitament la stirling funció de biblioteca. Així que tot aquest temps, és potser apropiada que estem tipus d'acabat exactament on vam començar. 

Vaig cometre un error, declarant implícitament stirling funció de biblioteca. OK, espera un minut. Recordo que, sobretot ja que està just aquí. Necessito incloure en string.h aquesta versió del programa. 

Déjame anar endavant i incloc string.h, llevat que, endavant i recompilar argv2. I ara, aquí anem, que argv2, Retorn. I encara que és una mica críptica a primera vista, notar que, en efecte, el s'imprimeix és argv2 punt. 

Però si escric algunes paraules després de la símbol, com argv2 Zamyla Chan, Introdueix, també una mica críptica a primera vista. Però si ens desplacem cap amunt, ./argv2 Z-A-M-I-L-A C-H-A-N. Per a això hem repeteixen al llarg de cada paraula. I, al seu torn, hem repeteixen al llarg tots els personatges dins d'una paraula. 

Ara, després de tot això, s'adonen que hi ha un altre detall que hem estat espècie fent cas omís de tot aquest temps. Simplement, se separen el les entrades del principal pot ser? Què passa amb la producció del principal? 

Tot aquest temps, hem estat només copiar i enganxar la paraula int front principal, encara que és possible veure en línia, de vegades incorrectament en les versions anteriors de C i compiladors, que diuen buit, o gens en absolut. Però, de fet, per a la versió de C que estem utilitzant, C 11, o 2011, compta que ha de ser int. I ha de ser o bé nul·la o argc i argv aquí. 

Però per què int main? Com és en realitat tornant? Doncs bé, resulta que tot aquest temps, qualsevol moment vostè ha escrit un programa principal Sempre està tornant alguna cosa. Però ha estat fent en secret. 

Aquest alguna cosa és una int, com suggereix la línia 5. Però el int? Bé, hi ha una convenció en la programació, pel que si no té sortit malament i tot està bé, programes i funcions en general return-- alguna cosa counterintuitively-- 0. 0 vol dir generalment que tot està bé. Així que, encara que es pensa en com a falsa en molts contextos, que en realitat vol dir generalment una bona cosa 

Mentrestant, si un programa torna 1, o negatiu 1, o 5, o negatiu 42, o qualsevol valor que no sigui 0, això significa generalment que alguna cosa ha anat malament. De fet, en el seu propi Mac o PC, és possible que hagi vist realment un missatge d'error, mitjançant la qual diu una cosa o una altra, l'error codi negatiu 42, o codi d'error 23, o alguna cosa per l'estil. Aquest nombre és en general només un toc per al programador, o l'empresa Això va fer que el programari, el que va sortir malament i per què, de manera que puguin mirar a través la seva documentació o codi, i esbrinar quin és el d'error realment significa. En general, no és útil per a nosaltres els usuaris finals. 

Però quan principals retorna 0, tot està bé. I si no s'especifica el principal ha de retornar, s'acaba de forma automàtica retornar 0 per a vostè. Però tornant una mica la resta és realment útil. 

En aquest programa final, em va deixar seguir endavant i cridar a aquest exit.c, i introduir l'últim d'avui temes, conegut com un codi d'error. Déjame anar per davant i inclou la nostra arxius coneguts fins a la part superior, fan int principal. I aquesta vegada, farem int argc, argv cadena, i amb els meus suports donar a entendre que està en la matriu. I llavors em van deixar de fer una comprovació de validesa. Aquest cop, si no ho fa argc igual a 2, llavors saps què? Oblida-ho. Vaig a dir que, bé, usuari, es troba a faltar l'argument de línia d'ordres n barra invertida. 

I llavors això és tot. Desitjo sortir. Vaig a manera preventiva, i prematurament realment, el retorn alguna cosa que no sigui el número 1. El lloc on anar per al primer valor error que pot passar és 1. Si té alguna altra errònia situació que pugui produir-se, es podria dir de retorn de 2 o retornar 3, o potser fins i tot negatiu o negatiu febrer 1. 

Aquests són només els codis de sortida que són, en general, només és útil per al programador, o el companyia que ha d'enviar el programari. Però el fet que és No 0 és l'important. Així que si en aquest programa, vull garantir que aquest programa només funciona si l'usuari m'ofereix amb un nombre d'arguments de dos, el nom del programa, i algun altre paraula, que pot valer tant com segueix, cridar a l'usuari amb dit printf, falten arguments de línia de comandes, tornar 1. Que s'acaba immediatament sortir del programa. 

Només si argc és igual a 2 caldrà baixar aquí, en aquest moment em vaig a dir, hola cent s, la barra invertida n, argv1. En altres paraules, estic No va després de argv 0, que és només el nom del programa. Vull imprimir hola, coma, la segona paraula que va escriure l'ésser humà. I en aquest cas a línia 13, tot està bé. 

Sé que argc es 2 lògicament d'aquest programa. Vaig a seguir endavant i tornar 0. Sigui dit de passada, tenir en compte que això és cert en Scratch també. 

Lògicament, podria fer això i encapsular aquestes línies del codi d'aquesta altra clàusula aquí. Però això és una mena de innecessàriament sagnia meu codi. I vull fer súper clar que no importa què, per defecte, hola alguna cosa va a aconseguir imprès, sempre que l'usuari coopera. 

Així que és molt comú l'ús de una condició, només un cas, per agafar una mica errònia situació, i després sortir. I després, sempre és tot així, no tenir una cosa, però només tenen el codi a part que si, perquè és equivalents en aquest Cas particular, lògicament. Així que estic tornant un 0, només per signifiquen explícitament que tot està bé. 

Si he omès el retorn 0, ho faria ser assumida de forma automàtica per a mi. Però ara que estic tornant un almenys en aquest cas, Vaig a, per si de cas, i claredat, tornen 0 en aquest cas. Així que ara vull seguir endavant i fer la sortida, que és una transició perfecta per deixar només. 

Però fer la sortida, i em va deixar anar endavant i fer ./exit, Retorn. I el programa em va cridar, falta argument de línia d'ordres. OK, deixa cooperar. 

Permetin-me fer lloc ./exit, David, Enter. I ara es diu, hola David. I que normalment no veure això. 

Però resulta que hi ha una de manera especial en Linux per veure realment de manera que la sortida codi d'un programa es tanca. A vegades en un gràfic món com Mac OS o Windows, només es veu aquests números quan una missatge d'error apareix a la pantalla i el programador que mostra que el nombre. Però si volem veure el que l'error el missatge és, podem fer-ho aquí-- pel ./exit, Enter, imprimir falta argument de línia d'ordres. 

Si ara ho faig ressò $?, Que és ridículament críptica buscant. Però $? és l'encantament màgic que diu, escolta, ordinador, digues-me el que l'anterior codi de sortida del programa era. I vaig arribar a Enter. Veig a 1, perquè això és el que jo dit a la meva funció principal per tornar. 

Mentrestant, si faig ./exit David, i prem enter, veig, hola David. I si ara ho faig ressò $?, Veig hola 0. I així això va ser informació valuosa en el context de l'depurador, no tan tant que, l'ésser humà, li faria res. No obstant això, el depurador i una altra els programes que farem servir en aquest semestre sovint mirar a aquest nombre, tot i que és una espècie de amagat llevat que vostè ho busca, a determinar si un programa d'o no execució va ser correcta o incorrecta. 

I pel que ens porta a això, al final del dia. Comencem avui examinat depuració, i al seu torn en el curs sí, i després més interessant, tècnicament sota de la campana en quines cadenes són, que va durar setmana ens ho prenem per fet, i per descomptat els va portar per fet a Scratch. 

Seguidament, examinem com podem accedir caràcters individuals en una cadena, i després va tornar a prendre un nivell més alt mirar les coses, mirant com bé-- Si volem arribar a nivell individual elements d'una llista com l'estructura, no podem fer això amb diverses cadenes? I que podem amb els arguments de línia de comandes. Però aquesta imatge d'aquí només caixes és demostrativa d'aquesta idea general d'una matriu o una llista o un vector. I depenent de la context, totes aquestes paraules significats lleugerament diferents. Així que en C, només anem parlar d'una matriu. I una matriu és un tros de la memòria, cada un dels quals és elements són contigus, de nou, cap enrere, cap enrere, cap enrere. 

I aquests elements són, en general, del mateix tipus de dades, caràcter, caràcter, caràcters, caràcter, o cadena, cadena, cadena, cadena, o int, int, int, sigui el que sigui estem tractant d'emmagatzemar. Però al final del dia, això és el que sembla conceptualment. Vostè està prenent el seu memòria o RAM de l'ordinador. I que està tallat a terme en caixes de la mateixa mida, tots els quals estan de tornada, cap enrere, a de nou, a la part posterior d'aquesta manera. 

I el que és bo de aquesta idea, i el fet que podem expressar els valors d'aquesta manera amb la primera de les nostres estructures de dades a la classe, vol dir que podem començar per resoldre problemes amb el codi que van arribar de manera intuïtiva en la setmana 0. Vostè recordarà el telèfon exemple llibre, on es va utilitzar un divideix i venceràs, o un algoritme de recerca binari, per tamisar a través d'un conjunt munt de noms i números. Però hem suposat, recordar, que aquesta llibreta de telèfons que ja es va solucionar, que una altra persona ja tenia Robust out-- donat una llista de noms i numbers-- com alfabèticament ells. I ara que estem en C, també, tenir la capacitat per posar les coses, no es físicament en una llibreta de telèfons però pràcticament en un ordinador de memòria, serem capaços setmana que introduir de nou la primera esto-- de les nostres estructures de dades en un array-- però el més important, equip real algoritmes implementats ciència en el codi, amb el qual podem emmagatzemar les dades en les estructures d'aquest tipus, i després començar a manipular-la, i per resoldre efectivament els problemes amb ella, i construir sobre d'això, en última instància, els programes en C, en Python, en JavaScript, la consulta de bases de dades amb SQL? 

I veurem que tots aquests idees diferents d'enclavament. Però per ara, recordar que la domini que presentem avui Va ser aquesta cosa aquí, i el món de la criptografia. I entre els següents problemes que vostè mateix resoldrà és l'art de la criptografia, aleatorització i desaleatorización informació, i de xifrat i desxifrar el text, i suposant que en última instància que ara sap el que hi ha sota el capó de manera que quan es veu o rep un missatge com aquest, vostè mateix pot desxifrar-lo. Tot això, i més la propera vegada. 

[REPRODUCCIÓ DE VÍDEO] 

-Moure Acaba d'arribar. Vaig a anar a visitar el seu professor de la universitat. Sí. Hola. Ets tu. Esperi! David. Només estic intentant entendre el que li va passar. Si us plau, qualsevol cosa podria ajudar. Eres la seva universitat company de pis, oi? Vostè hi era amb ell quan acabar el projecte CS50? 

[MÚSICA] 

Això va ser CS50. 

M'encanta aquest lloc. 

-Menjar-se. Anem a sortir dels negocis. 

[FI DE REPRODUCCIÓ] 