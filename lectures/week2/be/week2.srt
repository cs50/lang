1
00:00:00,000 --> 00:00:02,970
>> [МУЗЫКА]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. малая: Добра.

4
00:00:15,700 --> 00:00:18,832
Гэта CS50 і гэта
з'яўляецца пачаткам 2-й тыдні.

5
00:00:18,832 --> 00:00:21,040
І вы памятаеце, што больш
апошнія пару тыдняў,

6
00:00:21,040 --> 00:00:24,490
мы прадставілі кампутар
навука і, у сваю чаргу, праграмаванне.

7
00:00:24,490 --> 00:00:27,640
>> І мы пачалі аповяд шляхам
Драпіна, што графічную мову

8
00:00:27,640 --> 00:00:28,990
з медыя-лабараторыі Масачусецкага тэхналагічнага інстытута.

9
00:00:28,990 --> 00:00:30,780
А потым зусім нядаўна,
На мінулым тыдні, мы зрабілі

10
00:00:30,780 --> 00:00:34,450
ўвесці higher-- A
мова больш нізкага ўзроўню вядомыя

11
00:00:34,450 --> 00:00:36,770
як З, тое, што гэта чыста тэкстава.

12
00:00:36,770 --> 00:00:39,440
І, сапраўды, апошні раз, калі мы
вывучыць ў гэтым кантэксце

13
00:00:39,440 --> 00:00:40,450
шэраг паняццяў.

14
00:00:40,450 --> 00:00:43,010
>> Гэта, нагадаем, быў вельмі
Першая праграма мы разгледзелі.

15
00:00:43,010 --> 00:00:45,710
І гэтая праграма, даволі проста,
друкуе "Прывітанне, свет."

16
00:00:45,710 --> 00:00:47,730
Але ёсць так шмат
ўяўнай магіі адбываецца.

17
00:00:47,730 --> 00:00:51,460
Там гэтая #include
з гэтых кутніх дужках.

18
00:00:51,460 --> 00:00:52,170
Там у инт.

19
00:00:52,170 --> 00:00:53,020
Там у (анулююцца).

20
00:00:53,020 --> 00:00:56,330
Там у круглыя ​​дужкі, фігурныя дужкі,
кропка з коскі, і многае іншае.

21
00:00:56,330 --> 00:00:58,480
>> Так, нагадаем, што
мы ўвялі драпіна

22
00:00:58,480 --> 00:01:02,110
так што мы маглі б, у ідэале, убачыць мінулае
што сінтаксіс, матэрыял, які сапраўды ня

23
00:01:02,110 --> 00:01:04,590
усё, што інтэлектуальна
цікава, але на ранніх стадыях

24
00:01:04,590 --> 00:01:07,700
гэта, безумоўна, крыху больш складана
каб абгарнуць ваш розум вакол.

25
00:01:07,700 --> 00:01:10,860
І на самай справе, адно з самых распаўсюджаных
рэчы на ​​раннім этапе ў класе праграмавання,

26
00:01:10,860 --> 00:01:13,443
асабліва для тых, хто менш
зручна, каб зламацца,

27
00:01:13,443 --> 00:01:17,460
і падстаўлялі некаторымі сінтаксічнымі
памылкі, не кажучы ўжо пра лагічных памылак.

28
00:01:17,460 --> 00:01:19,800
І таму сярод нашых мэтаў
сёння, на самай справе, будзе

29
00:01:19,800 --> 00:01:23,280
будзе абсталёўваць вас з некаторымі
метады вырашэння праблем для таго, як

30
00:01:23,280 --> 00:01:26,705
каб лепш вырашаць праблемы самі
ў выглядзе адладкі.

31
00:01:26,705 --> 00:01:29,330
І вы памятаеце, таксама, што
серада, мы ўвялі

32
00:01:29,330 --> 00:01:31,780
апошні раз быў названы CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Гэта вэб-праграмнае забеспячэнне,
дазваляе праграмаваць ў воблаку,

34
00:01:34,850 --> 00:01:38,450
так бы мовіць, захоўваючы пры гэтым усе вашыя
файлы разам, як мы зноў будзем сёння.

35
00:01:38,450 --> 00:01:41,480
І нагадаем, што мы
перагледзець гэтыя тэмы тут,

36
00:01:41,480 --> 00:01:44,480
сярод іх функцый, а таксама завесы, і
зменныя і лагічныя выразы,

37
00:01:44,480 --> 00:01:45,110
і ўмовы.

38
00:01:45,110 --> 00:01:49,190
І на самай справе некалькі больш, што мы
у перакладзе з нуля свету

39
00:01:49,190 --> 00:01:50,800
да міру C.

40
00:01:50,800 --> 00:01:53,220
>> Але асноўны будынак
блокі, так бы мовіць,

41
00:01:53,220 --> 00:01:55,150
сапраўды былі ўсе тыя ж на мінулым тыдні.

42
00:01:55,150 --> 00:01:57,900
На самай справе, мы сапраўды толькі мелі
розныя кавалак галаваломкі, калі вы будзеце.

43
00:01:57,900 --> 00:02:00,300
Замест таго, што фіялетавы
захаваць блок, мы замест таго, каб

44
00:02:00,300 --> 00:02:02,940
быў PRINTF, які
гэтая функцыя ў С,

45
00:02:02,940 --> 00:02:05,890
дазваляе надрукаваць што-небудзь
і адфарматаваць яго на экране.

46
00:02:05,890 --> 00:02:07,950
Мы ўвялі CS50
Бібліятэка, дзе вы

47
00:02:07,950 --> 00:02:11,420
ёсць зараз у вашым распараджэнні get_char,
і get_int і get_string,

48
00:02:11,420 --> 00:02:14,610
і некалькі іншых функцый, як
ну, з дапамогай якога вы можаце атрымаць ўвод

49
00:02:14,610 --> 00:02:16,260
ад уласнай клавіятуры карыстальніка.

50
00:02:16,260 --> 00:02:20,640
І мы таксама ўзялі погляд на рэчы
як these- BOOL і паўкокс,

51
00:02:20,640 --> 00:02:22,490
і двайныя, з якая плавае кропкай,
INT, long_long радок.

52
00:02:22,490 --> 00:02:25,170
І ёсць нават іншыя тыпы дадзеных у C.

53
00:02:25,170 --> 00:02:28,560
>> Іншымі словамі, калі вы аб'яўляеце
зменная для захоўвання некаторага значэння,

54
00:02:28,560 --> 00:02:32,600
або пры рэалізацыі функцыі
якая вяртае некаторы значэнне,

55
00:02:32,600 --> 00:02:35,290
Вы можаце паказаць, што
тып значэння, якое.

56
00:02:35,290 --> 00:02:37,310
Гэта радок, падобна
паслядоўнасць знакаў?

57
00:02:37,310 --> 00:02:39,490
Гэты лік, як цэлы лік?

58
00:02:39,490 --> 00:02:41,390
Ці з'яўляецца гэта з якая плавае кропкай
значэнне, ці таму падобнае?

59
00:02:41,390 --> 00:02:46,180
Такім чынам, у C, у адрозненне ад нуля, мы на самай справе
пачаў паказваць, які тып дадзеных

60
00:02:46,180 --> 00:02:48,330
мы вярталіся або выкарыстання.

61
00:02:48,330 --> 00:02:51,910
>> Але, вядома, мы таксама сутыкнуліся з
некаторыя фундаментальныя межы вылічэнняў.

62
00:02:51,910 --> 00:02:54,100
І ў прыватнасці,
гэтая мова C, нагадаем

63
00:02:54,100 --> 00:02:57,070
што мы глядзелі на
Цэлалікавымі перапаўненне, рэальнасць

64
00:02:57,070 --> 00:03:00,460
што калі ў вас ёсць толькі
канчатковае колькасць памяці

65
00:03:00,460 --> 00:03:04,600
ці, у прыватнасці, канчатковае лік
бітаў, вы можаце разлічваць толькі так высока.

66
00:03:04,600 --> 00:03:08,460
І такім чынам, мы глядзелі на гэты прыклад тут
у выніку чаго лічыльнік у самалёце ,,

67
00:03:08,460 --> 00:03:13,510
на самай справе, калі працуе дастаткова доўга будзе
перапаўненне і вынік у праграмным забеспячэнні

68
00:03:13,510 --> 00:03:15,560
фактычны фізічны патэнцыял памылкі.

69
00:03:15,560 --> 00:03:18,600
>> Мы таксама разгледзелі плавае
кропка недакладнасцяў, рэальнасць

70
00:03:18,600 --> 00:03:22,280
што толькі з канчатковым лікам
бітаў, няхай гэта будзе 32 або 64,

71
00:03:22,280 --> 00:03:27,330
вы можаце паказаць толькі так шмат лікаў
пасля дзесятковай кропкі, пасля чаго вы

72
00:03:27,330 --> 00:03:29,110
пачынаюць атрымліваць недакладным.

73
00:03:29,110 --> 00:03:32,360
Так, напрыклад, адна трэць ў
свет тут, у нашым чалавечым свеце,

74
00:03:32,360 --> 00:03:35,360
мы ведаем, гэта проста бясконцую колькасць
3 сек пасля дзесятковай кропкі.

75
00:03:35,360 --> 00:03:38,820
Але кампутар не абавязкова
ўяўляюць сабой бясконцую колькасць лічбаў

76
00:03:38,820 --> 00:03:42,590
калі вы толькі дайце яму некаторыя
канчатковае колькасць інфармацыі.

77
00:03:42,590 --> 00:03:45,900
>> Так што мы не толькі узброіць вас
з большай сілай у плане

78
00:03:45,900 --> 00:03:49,280
як Вы маглі б выказаць сябе ў
клавіятура з пункту гледжання праграмавання,

79
00:03:49,280 --> 00:03:51,430
мы таксама абмежаваныя, што
вы можаце рэальна зрабіць.

80
00:03:51,430 --> 00:03:55,790
І на самай справе, памылкі і памылкі могуць
ўзнікаюць з гэтых відаў пытанняў.

81
00:03:55,790 --> 00:03:59,900
І сапраўды, сярод тым сёння
будуць такія тэмы, як адладкі

82
00:03:59,900 --> 00:04:03,699
і на самай справе, гледзячы пад капотам
на тое, як былі ўведзеныя рэчы на ​​мінулым тыдні

83
00:04:03,699 --> 00:04:05,490
на самай справе рэалізаваны
так што вам лепш

84
00:04:05,490 --> 00:04:10,530
зразумець, як магчымасцяў і
абмежаванні мовы як C.

85
00:04:10,530 --> 00:04:14,770
>> І на самай справе, мы адхіліце пласты
з найпростых структуры дадзеных,

86
00:04:14,770 --> 00:04:17,756
тое, што называецца масіў, які
Драпіна здараецца называць "спіс."

87
00:04:17,756 --> 00:04:19,589
гэта крыху
адрозніваецца ў гэтым кантэксце.

88
00:04:19,589 --> 00:04:23,340
І тады мы будзем таксама ўвесці адно з
першы з нашых праблем прадметна-арыентаваных

89
00:04:23,340 --> 00:04:26,790
у CS50, свет
крыптаграфія, мастацтва караскацца

90
00:04:26,790 --> 00:04:29,650
або ў шыфраванні інфармацыі, так
што вы можаце адпраўляць сакрэтныя паведамленні

91
00:04:29,650 --> 00:04:34,520
і дэкадаваць сакрэтныя паведамленні
паміж двума асобамі, А і В.

92
00:04:34,520 --> 00:04:37,490
>> Таму, перш чым мы пераходу
да гэтага новага свеце,

93
00:04:37,490 --> 00:04:42,059
давайце паспрабуем забяспечыць вас з некаторымі
метады, з якімі вы можаце ліквідаваць

94
00:04:42,059 --> 00:04:43,850
або паменшыць па меншай меры, некаторыя
расчараванняў

95
00:04:43,850 --> 00:04:46,630
што вы, верагодна, сутыкаліся
Толькі за мінулы тыдзень.

96
00:04:46,630 --> 00:04:50,830
На самай справе, наперадзе вас such-- некаторыя з
вашы першыя праблемы ў С і форы,

97
00:04:50,830 --> 00:04:54,010
калі вы падобныя на мяне, у першы раз
вы спрабуеце ўдрукуешся праграму,

98
00:04:54,010 --> 00:04:57,330
нават калі вы думаеце, лагічна
Праграма даволі простая,

99
00:04:57,330 --> 00:05:01,200
вы можаце вельмі добра урэзаўся ў сцяну, і
кампілятар не збіраецца супрацоўнічаць.

100
00:05:01,200 --> 00:05:03,940
Робяць або Clang не збіраецца
на самай справе зрабіць вашыя стаўкі.

101
00:05:03,940 --> 00:05:05,450
>> І чаму гэта можа быць?

102
00:05:05,450 --> 00:05:07,950
Што ж, давайце паглядзім на,
можа быць, простая праграма.

103
00:05:07,950 --> 00:05:11,190
Я збіраюся ісці наперад і захаваць гэта ў
файл наўмысна называюць buggy0.c,

104
00:05:11,190 --> 00:05:13,590
таму што я ведаю яго
быць сапсаваны загадзя.

105
00:05:13,590 --> 00:05:17,400
Але я не мог зразумець, што калі гэта
першы ці другі ці трэцяй праграмы

106
00:05:17,400 --> 00:05:18,830
што я на самой справе робіць сам.

107
00:05:18,830 --> 00:05:23,820
Так што я збіраюся ісці наперад і
ўдрукуешся, Int асноўны (вакуум).

108
00:05:23,820 --> 00:05:28,130
І тады ўнутры маіх фігурныя дужкі,
вельмі знаёмы ( "прывітанне, world--

109
00:05:28,130 --> 00:05:30,980
зваротнай касой рысы, п ") - і кропка з коскі.

110
00:05:30,980 --> 00:05:32,360
>> Я захаваў файл.

111
00:05:32,360 --> 00:05:34,850
Цяпер я збіраюся пайсці ўніз
да майго акне тэрмінала

112
00:05:34,850 --> 00:05:40,340
і тып робяць buggy0, таму што, зноў жа,
імя файла сёння buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Так што я тыпу зрабіць buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> І, о, божа, памятаеце з апошняга часу
што без якіх-небудзь паведамленняў пра памылкі гэта добрая рэч.

115
00:05:48,200 --> 00:05:49,740
Так што выснова не з'яўляецца добрай рэччу.

116
00:05:49,740 --> 00:05:52,920
Але тут я ясна
некаторы колькасць памылак.

117
00:05:52,920 --> 00:05:56,470
>> Такім чынам, у першым радку вываду
пасля ўводу робяць buggy0, нагадаем,

118
00:05:56,470 --> 00:05:59,540
даволі падрабязны выснову звонам ст.

119
00:05:59,540 --> 00:06:02,067
Пад капотам,
CS50 IDE настроены

120
00:06:02,067 --> 00:06:04,150
выкарыстоўваць цэлую кучу
Варыянты з гэтым кампілятарам

121
00:06:04,150 --> 00:06:05,941
так што ў вас няма
думаць пра іх.

122
00:06:05,941 --> 00:06:08,840
І гэта ўсё, што першая лінія
азначае, што пачынаецца з Clang.

123
00:06:08,840 --> 00:06:11,720
>> Але пасля гэтага, праблемы
пачаць рабіць іх знешні выгляд.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c на лініі 3, характар
5, ёсць вялікая, чырвоная памылка.

125
00:06:17,390 --> 00:06:18,380
Што гэта?

126
00:06:18,380 --> 00:06:23,562
Ўскосна абвяшчаючы функцыі бібліятэкі
PRINTF з тыпам Int (сопзЬ сЬаг *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Я маю на ўвазе, гэта вельмі хутка
становіцца вельмі аркан.

129
00:06:28,379 --> 00:06:30,170
І, вядома ж, у першую чаргу
погляд, мы не будзем

130
00:06:30,170 --> 00:06:32,380
чакаюць, што вы разумееце
паўната гэтага паведамлення.

131
00:06:32,380 --> 00:06:34,213
І вось адзін з урокаў
на сённяшні дзень адбываецца

132
00:06:34,213 --> 00:06:36,919
каб паспрабаваць заўважыць
ўзоры, або падобныя рэчы,

133
00:06:36,919 --> 00:06:38,960
да памылак вы можаце мець
сутыкнуліся ў мінулым.

134
00:06:38,960 --> 00:06:41,335
Так што давайце дражніць толькі адзін ад аднаго
тыя словы, якія выглядаюць знаёмымі.

135
00:06:41,335 --> 00:06:44,290
Вялікі, чырвоны памылка відавочна
сімвалам чагосьці памыліцца.

136
00:06:44,290 --> 00:06:47,940
>> безумоўнае прызнанне
Бібліятэка функцый Printf.

137
00:06:47,940 --> 00:06:51,680
Так што нават калі я не зусім разумею, што
няяўна абвяшчаючы функцыі бібліятэкі

138
00:06:51,680 --> 00:06:54,900
Значыць, праблема, вядома,
ставіцца да PRINTF нейкім чынам.

139
00:06:54,900 --> 00:06:59,130
І крыніца гэтага пытання
мае справу з абвясціўшы яго.

140
00:06:59,130 --> 00:07:02,440
>> Аб'яву функцыі з'яўляецца
згадкі пра яго ў першы раз.

141
00:07:02,440 --> 00:07:06,210
І мы выкарыстоўвалі тэрміналогію на мінулым тыдні
таго, каб абвясціць прататып функцыі ва,

142
00:07:06,210 --> 00:07:11,860
альбо з адной лініяй у верхняй частцы вашага
уласны файл або ў так званым файле загалоўка.

143
00:07:11,860 --> 00:07:15,300
І ў якім файле зрабіў мы гаворым
на мінулым тыдні, што Printf цытата,

144
00:07:15,300 --> 00:07:17,080
Unquote, заявіў?

145
00:07:17,080 --> 00:07:20,950
У якім файле знаходзіцца яго прататып?

146
00:07:20,950 --> 00:07:24,640
>> Так што, калі вы памятаеце, самае першае, што я
тыпізаваных, амаль кожная праграма ў мінулым time--

147
00:07:24,640 --> 00:07:30,790
і выпадкова хвіліну таму пачалася
набраўшы myself-- быў адзін here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- для
уваход / output-- кропка ч І сапраўды,

149
00:07:38,630 --> 00:07:41,860
калі я цяпер захаваць гэты файл, я збіраюся
ісці наперад і ачысціць экран,

150
00:07:41,860 --> 00:07:44,740
якія вы можаце зрабіць, увёўшы
Ясна, ці вы можаце трымаць кіравання L,

151
00:07:44,740 --> 00:07:47,680
проста ачысціць акно тэрмінала
проста каб ліквідаваць некаторыя перашкоды.

152
00:07:47,680 --> 00:07:51,370
>> Я збіраюся ісці наперад і
паўторна тыпу робяць buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
І вуаля, я да гэтага часу бачу, што
доўгі час каманда з Clang,

154
00:07:53,790 --> 00:07:55,470
але няма ніякага паведамлення пра памылку на гэты раз.

155
00:07:55,470 --> 00:07:58,800
І на самай справе, калі я ./buggy0,
гэтак жа, як у мінулы раз,

156
00:07:58,800 --> 00:08:01,860
дзе кропка азначае гэта
каталог, Слэш проста азначае,

157
00:08:01,860 --> 00:08:05,040
тут ідзе назва праграмы і
што назва праграмы buggy0,

158
00:08:05,040 --> 00:08:07,340
Калі ласка, увядзіце, "Прывітанне, свет."

159
00:08:07,340 --> 00:08:09,440
>> Зараз, як вы, магчыма,
запазычаныя гэтае рашэнне

160
00:08:09,440 --> 00:08:12,017
не абавязкова
прызнаючы, як шмат слоў,

161
00:08:12,017 --> 00:08:14,350
як і я, вядома ж, маючы
зрабілі гэта на працягу многіх гадоў?

162
00:08:14,350 --> 00:08:18,720
Ну, рэалізаваць у першай задачы
набор, мы пазнаёмім вас з камандай

163
00:08:18,720 --> 00:08:21,175
што ўласны персанал CS50 ў
напісаў пад назвай help50.

164
00:08:21,175 --> 00:08:24,300
І на самай справе, C робіць спецыфікацыю
праблема ўсталяваць адносна таго, як выкарыстоўваць гэтую функцыю.

165
00:08:24,300 --> 00:08:27,210
>> Але, па сутнасці, help50
праграма, якая супрацоўнікі CS50 ў

166
00:08:27,210 --> 00:08:30,850
пісаў, што дазваляе запускаць
каманда або запусціць праграму,

167
00:08:30,850 --> 00:08:36,169
і калі вы не разумееце яго
выхад, каб перадаць свой выхад help50,

168
00:08:36,169 --> 00:08:38,890
і ў гэты момант праграмнае забеспячэнне
што супрацоўнікі вядома пісаў

169
00:08:38,890 --> 00:08:42,429
будзе выглядаць на выхадзе вашай праграмы
радок за радком, па адным знаку.

170
00:08:42,429 --> 00:08:46,000
І калі мы, супрацоўнікі, прызнаюць
паведамленне пра памылку, што вы выпрабоўваеце,

171
00:08:46,000 --> 00:08:50,580
мы будзем старацца, каб справакаваць вас з некаторымі
рытарычныя пытанні, з некаторымі парадамі,

172
00:08:50,580 --> 00:08:54,890
гэтак жа, як TF або CA ці сябе
будзе рабіць асабіста ў працоўны час.

173
00:08:54,890 --> 00:08:58,320
>> Так што глядзіце, каб help50, калі вы гэтага не зробіце
абавязкова прызнаюць праблему.

174
00:08:58,320 --> 00:09:00,790
Але не спадзявацца на яго
занадта шмат, як мыліца.

175
00:09:00,790 --> 00:09:03,990
Вядома, паспрабаваць зразумець яго
вываду, а затым атрымаць з яго

176
00:09:03,990 --> 00:09:07,571
так што толькі адзін ці два разы ці не так
калі-небудзь запусціць help50 для канкрэтнай памылкі

177
00:09:07,571 --> 00:09:08,070
паведамленне.

178
00:09:08,070 --> 00:09:10,660
Пасля гэтага, вы павінны быць
лепш абсталяваныя сябе

179
00:09:10,660 --> 00:09:13,180
каб высветліць, што гэта на самай справе.

180
00:09:13,180 --> 00:09:14,350
>> Давайце зробім адзін іншы тут.

181
00:09:14,350 --> 00:09:20,410
Дазвольце мне ісці наперад, а ў іншым
файл, які мы будзем называць гэты buggy1.c.

182
00:09:20,410 --> 00:09:23,110
І ў гэтым файле я
збіраецца deliberately--

183
00:09:23,110 --> 00:09:26,330
але рабіць выгляд, што я не раблю
зразумець, што памылка, якую я зрабіў.

184
00:09:26,330 --> 00:09:31,420
>> Я збіраюся ісці наперад і рабіць this--
#include, так як я

185
00:09:31,420 --> 00:09:33,660
даведаўся, што мой ўрок з хвіліну таму.

186
00:09:33,660 --> 00:09:36,220
Int асноўных (несапраўднымі), як і раней.

187
00:09:36,220 --> 00:09:40,880
І тады тут я іду
зрабіць радок з - get_string.

188
00:09:40,880 --> 00:09:43,770
І памятаеце з апошняга часу,
гэта азначае, эй, кампутар,

189
00:09:43,770 --> 00:09:48,280
дайце мне зменную, называем гэта S, і
зрабіць тып гэтай зменнай радковыя

190
00:09:48,280 --> 00:09:50,150
так што я магу захоўваць адно або некалькі слоў у ім.

191
00:09:50,150 --> 00:09:52,191
>> А потым на правай руцэ
бок знака роўнасці

192
00:09:52,191 --> 00:09:54,980
з'яўляецца get_string, якая з'яўляецца
функцыя ў бібліятэцы CS50

193
00:09:54,980 --> 00:09:55,980
што робіць менавіта гэта.

194
00:09:55,980 --> 00:09:59,740
Ён атрымлівае функцыю, а затым
рукі яго справа налева.

195
00:09:59,740 --> 00:10:02,670
Так што гэты знак роўнасці не азначае,
"Роўна", як мы маглі б думаць у матэматыцы.

196
00:10:02,670 --> 00:10:04,750
Гэта азначае прызначэнне справа налева.

197
00:10:04,750 --> 00:10:09,640
Такім чынам, гэта азначае, узяць радок з
карыстальнік і захоўваць яго ўнутры с.

198
00:10:09,640 --> 00:10:10,460
>> Зараз давайце выкарыстоўваць яго.

199
00:10:10,460 --> 00:10:13,820
Дазвольце мне ісці наперад цяпер і ў якасці другога
лінія, дазвольце мне ісці наперад і сказаць "прывітанне" -

200
00:10:13,820 --> 00:10:19,330
ня "свет", але "Прывітанне,% S--
якая з'яўляецца нашым запаўняльнікам, коска s,

201
00:10:19,330 --> 00:10:22,030
якая з'яўляецца нашай зменнай,
а затым кропка з коскі.

202
00:10:22,030 --> 00:10:26,070
Так што, калі я не закручваць занадта шмат
тут, гэта выглядае як правільны код.

203
00:10:26,070 --> 00:10:28,090
>> І мае інстынкты цяпер скампіляваць яго.

204
00:10:28,090 --> 00:10:30,400
Файл называецца buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Так што я збіраюся зрабіць зрабіць buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
І цыраваць-то, калі няма
нават больш памылак, чым раней.

207
00:10:36,377 --> 00:10:38,210
Я маю на ўвазе, ёсць больш
Паведамленні пра памылкі гэта было

208
00:10:38,210 --> 00:10:40,400
здаецца, чым фактычныя лініі ў гэтай праграме.

209
00:10:40,400 --> 00:10:42,730
>> Але ежа на дом тут,
нават калі вы перагружаныя

210
00:10:42,730 --> 00:10:45,040
з двума ці трыма ці
яшчэ чатыры паведамленні пра памылкі,

211
00:10:45,040 --> 00:10:48,340
фокус заўсёды на вельмі
Першы з гэтых паведамленняў.

212
00:10:48,340 --> 00:10:52,220
Гледзячы на ​​самы верхні адзін,
пракруткі назад уверх, як гэта будзе неабходна.

213
00:10:52,220 --> 00:10:53,930
Дык вось я надрукаваў касметыку buggy1.

214
00:10:53,930 --> 00:10:55,700
Вось што выхад Clang, як і чакалася.

215
00:10:55,700 --> 00:10:57,290
>> І вось першая чырвоная памылка.

216
00:10:57,290 --> 00:11:02,370
Выкарыстанне неаб'яўленай ідэнтыфікатара
Радок, я маю на ўвазе стандарт у?

217
00:11:02,370 --> 00:11:04,260
Так стандарт з'яўляецца
на самай справе нешта іншае.

218
00:11:04,260 --> 00:11:06,240
Гэта ставіцца да карыстальніка
клавіятура, па сутнасці.

219
00:11:06,240 --> 00:11:08,080
>> Але гэта не тое, што я меў на ўвазе.

220
00:11:08,080 --> 00:11:11,770
Я меў на ўвазе радок, і я меў на ўвазе get_string.

221
00:11:11,770 --> 00:11:16,200
Дык што ж гэта, што я
забыўся зрабіць на гэты раз?

222
00:11:16,200 --> 00:11:20,230
Чаго не хапае на гэты раз?

223
00:11:20,230 --> 00:11:23,600
У мяне ёсць #include,
таму ў мяне ёсць доступ да Printf.

224
00:11:23,600 --> 00:11:26,090
>> Але што ў мяне няма
доступ да толькі што яшчэ?

225
00:11:26,090 --> 00:11:29,420
Ну, гэтак жа, як у мінулы раз,
Я павінен сказаць кампілятар

226
00:11:29,420 --> 00:11:31,691
Ляскам, што гэтыя функцыі.

227
00:11:31,691 --> 00:11:33,940
Get_string не прыходзіць
з С. І ў прыватнасці, яго

228
00:11:33,940 --> 00:11:38,160
не прыходзіць у
загалоўку файла.

229
00:11:38,160 --> 00:11:40,770
Замест гэтага ён прыходзіць у
нешта супрацоўнікі пісалі,

230
00:11:40,770 --> 00:11:44,176
які ўяўляе сабой іншы файл
імя, але трапна назваў.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Так, проста дадаўшы, што адной лініі
з code-- адклікання ад апошняга часу

233
00:11:50,861 --> 00:11:53,610
што пры запуску Clang, гэта будзе
паглядзець на мой код зверху ўніз,

234
00:11:53,610 --> 00:11:54,193
злева направа.

235
00:11:54,193 --> 00:11:57,200
Гэта будзе заўважыць,
Ах, вы хочаце.

236
00:11:57,200 --> 00:11:59,900
Дазвольце мне пайсці і знайсці, што,
ўсюды, дзе ён знаходзіцца на сэрвэры,

237
00:11:59,900 --> 00:12:03,090
скапіяваць і ўставіць яго, па сутнасці,
у верхняй частцы вашага ўласнага файла

238
00:12:03,090 --> 00:12:06,820
так што ў гэты момант у гісторыі,
лінія 1, астатняя частка праграмы

239
00:12:06,820 --> 00:12:11,651
можа, на самай справе, можна выкарыстоўваць любы з функцый
у ім, сярод іх get_string.

240
00:12:11,651 --> 00:12:13,650
Так што я збіраюся ігнараваць
астатнія з гэтых памылак,

241
00:12:13,650 --> 00:12:17,190
таму што я, на самай справе, падазраю, што толькі
першы на самай справе мела значэнне.

242
00:12:17,190 --> 00:12:20,780
І я збіраюся ісці наперад і перакладка,
пасля захавання майго файла зрабіць buggy1.

243
00:12:20,780 --> 00:12:22,580
І вуаля, ён зрабіў працу.

244
00:12:22,580 --> 00:12:29,200
А калі я ./buggy1 і ўвядзіце, для
асобнік, Zamyla, я зараз атрымаць прывітанне,

245
00:12:29,200 --> 00:12:32,000
Zamyla, а не прывітанне, свет.

246
00:12:32,000 --> 00:12:32,550
>> Добра.

247
00:12:32,550 --> 00:12:35,890
Дык вось тады вынас павінны,
адзін, старайцеся падбіраць столькі, колькі вы можаце

248
00:12:35,890 --> 00:12:39,140
ад паведамленняў пра памылкі ў адзіночку, гледзячы
на некаторых з распазнаюцца слоў.

249
00:12:39,140 --> 00:12:43,070
Калі выключыць, што выкарыстоўваць help50 за
праблема ўсталяваць спецыфікацыі.

250
00:12:43,070 --> 00:12:46,500
Але за выключэннем гэтага таксама, заўсёды звяртайце ўвагу
толькі ў верхняй памылкі, па меншай меры,

251
00:12:46,500 --> 00:12:50,051
на пачатковым этапе, каб убачыць, якую інфармацыю
ён можа на самай справе выхад.

252
00:12:50,051 --> 00:12:52,300
Але аказваецца, што ёсць
нават больш функцыянальных магчымасцяў убудаванай

253
00:12:52,300 --> 00:12:55,030
у бібліятэку CS50, каб дапамагчы
вы на раннім этапе ў семестр

254
00:12:55,030 --> 00:12:57,580
і на ранняй стадыі ў праграмаванні
высветліць, што адбываецца не так.

255
00:12:57,580 --> 00:12:59,840
Дык давайце зробім яшчэ адзін прыклад.

256
00:12:59,840 --> 00:13:04,350
Я буду называць гэта buggy2, які,
зноў жа, будзе сапсаваны з

257
00:13:04,350 --> 00:13:05,650
варот, па дызайне.

258
00:13:05,650 --> 00:13:09,980
>> І я збіраюся ісці наперад
і рабіць #include.

259
00:13:09,980 --> 00:13:12,580
А потым я збіраюся зрабіць Int асноўны (вакуум).

260
00:13:12,580 --> 00:13:14,840
А потым я збіраюся зрабіць цыкл.

261
00:13:14,840 --> 00:13:16,690
Для (INT I _ 0.

262
00:13:16,690 --> 00:13:18,750
Я менш або роўна 10.

263
00:13:18,750 --> 00:13:24,260
я ++, а затым у фігурныя дужкі, я іду
раздрукаваць толькі сімвал хэштэгу тут

264
00:13:24,260 --> 00:13:25,920
і сімвал новага радка.

265
00:13:25,920 --> 00:13:29,220
>> Такім чынам, мой намер з гэтым
Праграма дастаткова проста

266
00:13:29,220 --> 00:13:33,150
ітэрацыю ў 10 разоў
і на кожнай ітэрацыі

267
00:13:33,150 --> 00:13:35,260
з гэтага цыклу кожны раз
праз цыкл,

268
00:13:35,260 --> 00:13:37,660
раздрукаваць хэштэгу,
хэштэгу, хэштэгу.

269
00:13:37,660 --> 00:13:40,480
Па адным у радку, таму што я
маюць новую лінію там.

270
00:13:40,480 --> 00:13:42,787
І нагадаем, што для
пятля, за апошні week--

271
00:13:42,787 --> 00:13:44,620
і вы атрымаеце больш
знаёмы з сінтаксісам

272
00:13:44,620 --> 00:13:47,170
выкарыстоўваючы яго з практыкай
Перад long-- гэта дае мне

273
00:13:47,170 --> 00:13:49,740
пераменная называецца I і ўстанаўлівае яго ў 0.

274
00:13:49,740 --> 00:13:52,650
>> Гэта павялічвае I на
кожнай ітэрацыі на 1.

275
00:13:52,650 --> 00:13:54,940
Так што я ідзе да 1 да 2 да 3.

276
00:13:54,940 --> 00:13:57,690
І тады гэта ўмова ў
пасярэдзіне паміж кропкамі з коскі

277
00:13:57,690 --> 00:14:03,010
атрымлівае правяраецца на кожнай ітэрацыі, каб зрабіць
упэўнены, што мы ўсё яшчэ ў межах дыяпазону.

278
00:14:03,010 --> 00:14:06,830
Так што я хачу ітэрацыю ў 10 разоў, так што я
маюць выгляд вельмі інтуітыўна проста

279
00:14:06,830 --> 00:14:09,070
пакласці 10, як мая верхняя мяжа там.

280
00:14:09,070 --> 00:14:14,310
>> І ўсё ж, калі я запускаю гэта, пасля таго, як
кампіляцыі з указаннем маркі buggy2--

281
00:14:14,310 --> 00:14:15,440
і яна кампілюецца ОК.

282
00:14:15,440 --> 00:14:17,980
Так што я не маюць
памылка сінтаксісу ў гэты раз.

283
00:14:17,980 --> 00:14:20,940
Дазвольце мне ісці наперад прама цяпер
і запусціць buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
А цяпер выканайце прагортку уверх.

285
00:14:22,620 --> 00:14:24,890
І дазвольце мне павялічыць
памер акна.

286
00:14:24,890 --> 00:14:33,720
>> Я, здаецца, ёсць 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Так што 11 хештегов, нягледзячы на ​​тое,
Я выразна паставіў 10 ўнутры гэтага цыклу.

288
00:14:38,891 --> 00:14:42,140
Зараз, некаторыя з вас могуць убачыць адразу
што памылка адбываецца таму, што, на самай справе, гэта

289
00:14:42,140 --> 00:14:43,720
гэта не вельмі цяжка памылка зрабіць.

290
00:14:43,720 --> 00:14:46,070
Але гэта вельмі часта
зрабіў вельмі рана.

291
00:14:46,070 --> 00:14:49,820
>> Тое, што я хачу адзначыць, аднак,
у тым, як я мог бы зразумець гэта?

292
00:14:49,820 --> 00:14:52,300
Што ж, атрымліваецца, што
CS50 бібліятэка прыходзіць

293
00:14:52,300 --> 00:14:55,380
з не толькі get_string і get_int
і get_float і іншыя функцыі.

294
00:14:55,380 --> 00:14:59,980
Ён таксама пастаўляецца са спецыяльнай функцыяй
называецца eprintf, або, памылка Printf.

295
00:14:59,980 --> 00:15:03,270
І існуе толькі зрабіць
гэта крыху прасцей для вас

296
00:15:03,270 --> 00:15:06,310
пры адладцы кода проста
выводзіць паведамленне пра памылку на экране

297
00:15:06,310 --> 00:15:07,850
і ведаю, адкуль яна ўзялася.

298
00:15:07,850 --> 00:15:11,000
>> Так, напрыклад, адна рэч, якую я мог бы
тут рабіць з гэтай функцыяй з'яўляецца this--

299
00:15:11,000 --> 00:15:20,230
eprintf, а затым я збіраюся ісці наперад
і сказаць, што я цяпер% я, зваротны слэш, п.

300
00:15:20,230 --> 00:15:22,330
І я збіраюся падключыць да значэння I.

301
00:15:22,330 --> 00:15:25,400
І наверсе, таму што гэты
знаходзіцца ў бібліятэцы CS50,

302
00:15:25,400 --> 00:15:27,580
Я збіраюся ісці наперад
і ўключаюць у сябе

303
00:15:27,580 --> 00:15:29,169
таму ў мяне ёсць доступ да гэтай функцыі.

304
00:15:29,169 --> 00:15:31,460
Але давайце разгледзім, што лінія
9 мяркуецца рабіць.

305
00:15:31,460 --> 00:15:32,670
Я збіраюся выдаліць гэта ў рэшце рэшт.

306
00:15:32,670 --> 00:15:34,670
Гэта не мае нічога агульнага
з маёй галоўнай мэты.

307
00:15:34,670 --> 00:15:39,090
Але eprintf, памылка Printf, проста азначае,
каб даць мне некаторую дыягнастычную інфармацыю.

308
00:15:39,090 --> 00:15:42,460
Калі я запускаю маю праграму, я хачу
ўбачыць гэта на экране часова

309
00:15:42,460 --> 00:15:44,550
а проста зразумець,
што адбываецца.

310
00:15:44,550 --> 00:15:47,330
>> І на самай справе, на кожным
ітэрацыя тут лініі 9

311
00:15:47,330 --> 00:15:49,260
Я хачу бачыць, якая велічыня I?

312
00:15:49,260 --> 00:15:50,290
Што такое значэнне I?

313
00:15:50,290 --> 00:15:51,280
Што такое значэнне I?

314
00:15:51,280 --> 00:15:55,650
І, спадзяюся, я павінен толькі
бачыць, што паведамленне, акрамя таго, у 10 разоў.

315
00:15:55,650 --> 00:15:57,780
>> Такім чынам, дазвольце мне ісці наперад і
перакампіляваць маю праграму,

316
00:15:57,780 --> 00:15:59,905
як я павінен рабіць у любы час
Я ўнесці змены. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
І now-- OK.

319
00:16:03,640 --> 00:16:04,820
Там вельмі шмат больш адбываецца.

320
00:16:04,820 --> 00:16:07,610
Такім чынам, дазвольце мне прагартаць уверх
яшчэ большае акно.

321
00:16:07,610 --> 00:16:10,190
>> І вы ўбачыце, што кожны з
Hashtags па-ранейшаму друку.

322
00:16:10,190 --> 00:16:15,270
Але паміж кожным з іх у цяперашні час гэты
дыягнастычны выснову адфарматаваны наступным чынам.

323
00:16:15,270 --> 00:16:17,960
Назва маёй праграмы тут з'яўляецца buggy2.

324
00:16:17,960 --> 00:16:20,432
Імя файла buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Нумар радка, з якой
гэта было надрукавана ў радку 9.

326
00:16:24,080 --> 00:16:27,500
А потым справа, што з'яўляецца
паведамленне пра памылку, што я чакаў.

327
00:16:27,500 --> 00:16:30,701
>> І што прыемна пра гэта заключаецца ў тым, што
Цяпер я не павінен абавязкова разлічваць

328
00:16:30,701 --> 00:16:32,200
ў маёй галаве, што мая праграма робіць.

329
00:16:32,200 --> 00:16:34,240
Я бачу, што на
Першая ітэрацыя я = 0,

330
00:16:34,240 --> 00:16:39,420
затым 1, затым 2, затым 3, затым 4, затым
5, затым 6, затым 7, затым 8, то 9, то,

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Так, пачакайце хвіліну.

333
00:16:42,050 --> 00:16:43,740
Што тут адбываецца?

334
00:16:43,740 --> 00:16:48,190
Я да гэтага часу, здаецца, лічачы
як задумана да 10.

335
00:16:48,190 --> 00:16:50,550
>> Але дзе ж мне пачаць?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

337
00:16:53,240 --> 00:16:58,040
Такім чынам, 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11-й палец

338
00:16:58,040 --> 00:16:59,990
сведчыць аб праблеме.

339
00:16:59,990 --> 00:17:02,850
Я, здаецца, падлічылі
няправільна ў маім цыкле.

340
00:17:02,850 --> 00:17:06,599
Замест таго, каб ісці 10 ітэрацый,
Я пачынаючы з 0,

341
00:17:06,599 --> 00:17:09,550
Я і заканчваючы праз 10.

342
00:17:09,550 --> 00:17:12,030
Але, так як, як кампутар,
Я пачынаю адлік з 0,

343
00:17:12,030 --> 00:17:15,250
Я павінен быць падлічваючы
да, але не да канца, 10.

344
00:17:15,250 --> 00:17:18,510
>> І таму выпраўленне, я ў рэшце рэшт
тут рэалізуецца, з'яўляецца адной з двух рэчаў.

345
00:17:18,510 --> 00:17:22,430
Я мог бы вельмі проста сказаць,
злічыць да менш за 10.

346
00:17:22,430 --> 00:17:27,260
Такім чынам, 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, якая з'яўляецца, па сутнасці, дакладна,

347
00:17:27,260 --> 00:17:28,900
нягледзячы на ​​тое, што гэта гучыць трохі няправільна.

348
00:17:28,900 --> 00:17:35,070
Ці я мог бы зрабіць менш або роўна
да 9, да таго часу, як я пачынаю з 0.

349
00:17:35,070 --> 00:17:40,056
Ці, калі вы сапраўды не падабаецца, што ты
можа разлічваць праз 10, але пачынаюцца з 1.

350
00:17:40,056 --> 00:17:41,680
Але зноў жа, гэта проста не так часта.

351
00:17:41,680 --> 00:17:43,977
У programming-- хоць і
не столькі ў Scratch--

352
00:17:43,977 --> 00:17:45,810
але пры праграмаванні ў
C і іншых мовах,

353
00:17:45,810 --> 00:17:47,670
як JavaScript і
Python і іншыя, гэта

354
00:17:47,670 --> 00:17:49,880
проста вельмі часта для
наша абмеркаванне бінарная

355
00:17:49,880 --> 00:17:53,450
каб проста пачаць адлік на
найменшая колькасць вы можаце, што 0.

356
00:17:53,450 --> 00:17:53,950
Добра.

357
00:17:53,950 --> 00:17:55,160
Дык вось eprintf.

358
00:17:55,160 --> 00:17:58,600
І зноў жа, зараз, калі я зразумеў, што я
Праблема, і я збіраюся вярнуцца да 0

359
00:17:58,600 --> 00:18:01,470
праз менш чым 10, я збіраюся
пайсці і выдаліць eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Яно не павінна быць там, калі я
адправіць мой код або адправіць свой код

361
00:18:04,580 --> 00:18:05,800
або паказаць яго каму-небудзь яшчэ.

362
00:18:05,800 --> 00:18:07,980
Гэта сапраўды проста меў на ўвазе
якія будуць выкарыстоўвацца часова.

363
00:18:07,980 --> 00:18:11,650
Але цяпер я гэта выправіў
Асаблівай праблемай, а таксама.

364
00:18:11,650 --> 00:18:16,780
>> Што ж, давайце зробім яшчэ адзін прыклад тут
што я буду нагнятаць наступным чынам.

365
00:18:16,780 --> 00:18:22,850
Я збіраюся ісці наперад і
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
І я збіраюся ісці наперад
і #include.

367
00:18:25,580 --> 00:18:29,030
>> І я збіраюся захаваць
гэты файл у якасці buggy3.c.

368
00:18:29,030 --> 00:18:31,740
І я збіраюся ісці наперад
і аб'явіць Int асноўны (вакуум).

369
00:18:31,740 --> 00:18:34,186
А потым ўнутры там
Я збіраюся зрабіць INT I _ -

370
00:18:34,186 --> 00:18:36,435
Я хачу, каб рэалізаваць праграму
з get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Гэта не функцыя, якая існуе да гэтага часу.

373
00:18:40,770 --> 00:18:42,870
Такім чынам, мы збіраемся рэалізаваць
гэта ўсяго імгненне.

374
00:18:42,870 --> 00:18:45,541
Але мы будзем бачыць, чаму
ён памылковы на першым праходзе.

375
00:18:45,541 --> 00:18:47,290
І як толькі я атрымаў
выклічце перапыненне ад карыстальніка,

376
00:18:47,290 --> 00:18:53,365
Я проста хачу, каб надрукаваць% I з'яўляецца адмоўным
цэлым лікам, патрэбна ўжыць зваротны слэш, п, коска, я.

377
00:18:53,365 --> 00:18:55,240
Іншымі словамі, усё, што я
хачу гэтую праграму, каб зрабіць

378
00:18:55,240 --> 00:18:58,000
гэта атрымаць адмоўнае Int з
карыстальнік, а затым раздрукаваць

379
00:18:58,000 --> 00:18:59,980
што такі негатыўны Int.

380
00:18:59,980 --> 00:19:02,080
>> Цяпер мне трэба рэалізаваць гэтую функцыю.

381
00:19:02,080 --> 00:19:05,740
Так што пазней у маім файле, я збіраюся пайсці
наперад і абвясціць функцыю пад назвай

382
00:19:05,740 --> 00:19:10,670
get_negative_int (пустата) - і мы
вярнуцца да таго, што азначае, што лінія зноў

383
00:19:10,670 --> 00:19:18,790
у moment-- Int N; do-- рабіць
following-- Printf п:.

384
00:19:18,790 --> 00:19:26,210
А потым я збіраюся зрабіць п - get_int,
і зрабіць гэта ў той час як п больш 0.

385
00:19:26,210 --> 00:19:28,310
А потым вярнуцца п;.

386
00:19:28,310 --> 00:19:31,730
>> Так што ёсць шмат адбываецца ў
не гэта, але ні адзін з якіх мы не рабілі

387
00:19:31,730 --> 00:19:33,710
паглядзіце на апошні тыдзень, па меншай меры, на кароткі час.

388
00:19:33,710 --> 00:19:36,980
Так што ў радку 10 тут я аб'яўлены
Функцыя называецца get_negative_int,

389
00:19:36,980 --> 00:19:39,620
і я паставіў (пустата), у
круглыя ​​дужкі, па той прычыне, гэта

390
00:19:39,620 --> 00:19:40,950
ня прымае ўваходны сігнал.

391
00:19:40,950 --> 00:19:42,910
Я нічога не прапускаючы
да гэтай функцыі.

392
00:19:42,910 --> 00:19:44,690
Я проста атрымліваю нешта ад яго.

393
00:19:44,690 --> 00:19:47,270
>> А што я спадзяюся
атрымаць назад цэлае.

394
00:19:47,270 --> 00:19:50,040
Там няма тып дадзеных
C называецца negative_int.

395
00:19:50,040 --> 00:19:52,880
Гэта проста Int, так што гэта будзе
каб быць на нас, каб пераканацца,

396
00:19:52,880 --> 00:19:55,340
што значэнне, якое на самай справе
Вяртаецца не толькі INT

397
00:19:55,340 --> 00:19:56,380
але таксама адмоўна.

398
00:19:56,380 --> 00:20:02,150
>> У радку 12 я абвяшчаю зменную
называецца п і робіць яго тыпу Int.

399
00:20:02,150 --> 00:20:07,500
А затым у радку 13 да 18 Я
рабіць што-то ў той час як-то дакладна.

400
00:20:07,500 --> 00:20:11,040
Я іду наперад і друк
п, двукроп'е, а затым прабел,

401
00:20:11,040 --> 00:20:12,800
як падказку для карыстальніка.

402
00:20:12,800 --> 00:20:16,410
>> Я затым выклікаць get_int і
захоўваць яго так званае вяртаецца значэнне

403
00:20:16,410 --> 00:20:18,130
ў гэтай зменнай п.

404
00:20:18,130 --> 00:20:22,600
Але я буду працягваць рабіць
гэта ў той час як п больш 0.

405
00:20:22,600 --> 00:20:27,960
Іншымі словамі, калі карыстальнік дае мне
Int і гэта лік больш 0,

406
00:20:27,960 --> 00:20:31,180
эрга, станоўчы, я збіраюся
проста трымаць reprompting карыстальніка,

407
00:20:31,180 --> 00:20:37,160
трымаць reprompting, прымушаючы іх
супрацоўнічаць і дайце мне адмоўны вынік Int.

408
00:20:37,160 --> 00:20:41,640
>> І як толькі п на самай справе negative--
Выкажам здагадку, што карыстальнік нарэшце тыпу -50,

409
00:20:41,640 --> 00:20:46,710
то гэта не ў той час як цыкл ўжо не так
таму што -50 не больш за 0.

410
00:20:46,710 --> 00:20:51,140
Такім чынам, мы парушаем з гэтага
пятля лагічна і вярнуцца п.

411
00:20:51,140 --> 00:20:53,520
>> Але ёсць яшчэ адна
што я павінен рабіць.

412
00:20:53,520 --> 00:20:56,190
І я магу проста зрабіць гэта
шляхам капіявання і ўстаўкі

413
00:20:56,190 --> 00:20:58,540
Адзін радок кода ў верхняй частцы файла.

414
00:20:58,540 --> 00:21:01,630
Мне трэба, каб навучыць Clang,
або абяцанне ляскам,

415
00:21:01,630 --> 00:21:04,630
відавочна, што я буду,
на самай справе, пайсці і ажыццявіць

416
00:21:04,630 --> 00:21:06,020
гэтая функцыя get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Гэта можа быць проста ніжэй у файле.

418
00:21:07,674 --> 00:21:09,840
Зноў жа, нагадаем, што Clang
чытае рэчы зверху ўніз,

419
00:21:09,840 --> 00:21:12,330
злева направа, так што вы не можаце
выклікаць функцыю, калі Clang

420
00:21:12,330 --> 00:21:15,330
не ведае, што гэта будзе існаваць.

421
00:21:15,330 --> 00:21:18,430
>> Цяпер, на жаль, гэтая праграма,
так як некаторыя з вас маглі заўважыць,

422
00:21:18,430 --> 00:21:19,590
ўжо глючыць.

423
00:21:19,590 --> 00:21:21,400
Дазвольце мне ісці наперад і зрабіць buggy3.

424
00:21:21,400 --> 00:21:26,904
Ён збірае, так што мая праблема цяпер не
памылка сінтаксісу, як тэкставай памылкі,

425
00:21:26,904 --> 00:21:29,570
гэта на самай справе будзе лагічным
памылка, што я наўмысна

426
00:21:29,570 --> 00:21:32,450
зрабіў як магчымасць
пакрокава, што адбываецца.

427
00:21:32,450 --> 00:21:35,540
>> Я збіраюся ісці наперад
Цяпер і запусціць buggy3.

428
00:21:35,540 --> 00:21:37,490
І я збіраюся пайсці
наперад, а не супрацоўнічаць.

429
00:21:37,490 --> 00:21:39,494
Я збіраюся даць яму нумар 1.

430
00:21:39,494 --> 00:21:41,410
Гэта не спадабалася, так
гэта мяне зноў абуджаючы.

431
00:21:41,410 --> 00:21:42,147
>> Як наконт 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Ні адзін з іх не працуюць.

435
00:21:44,740 --> 00:21:46,890
Як наконт -50?

436
00:21:46,890 --> 00:21:48,560
І праграма, здаецца, працуе.

437
00:21:48,560 --> 00:21:49,970
>> Дазвольце мне паспрабаваць яшчэ раз.

438
00:21:49,970 --> 00:21:53,400
Дазвольце мне паспрабаваць -1, здаецца, працуе.

439
00:21:53,400 --> 00:21:56,380
Дазвольце мне паспрабаваць -2, здаецца, працуе.

440
00:21:56,380 --> 00:21:59,640
Дазвольце мне паспрабаваць 0.

441
00:21:59,640 --> 00:22:01,684
Так, гэта няправільна.

442
00:22:01,684 --> 00:22:03,350
Цяпер мы, будучы трохі педантычным тут.

443
00:22:03,350 --> 00:22:07,090
Але гэта, на самой справе, так што 0
не з'яўляецца ні станоўчым, ні адмоўным.

444
00:22:07,090 --> 00:22:11,150
І таму той факт, што мая праграма
кажучы, што 0 з'яўляецца адмоўным цэлым лікам,

445
00:22:11,150 --> 00:22:12,820
гэта не тэхнічна правільна.

446
00:22:12,820 --> 00:22:15,180
>> Цяпер, чаму ён гэта робіць?

447
00:22:15,180 --> 00:22:16,270
Ну, гэта можа быць відавочным.

448
00:22:16,270 --> 00:22:18,110
І, сапраўды, праграма
меў на ўвазе, каб быць досыць простым

449
00:22:18,110 --> 00:22:19,670
таму ў нас ёсць што-то, каб даследаваць.

450
00:22:19,670 --> 00:22:25,870
>> Але давайце ўвядзем трэцюю адладку
Тэхніка тут называецца debug50.

451
00:22:25,870 --> 00:22:27,750
Так што гэта праграма
што мы толькі што стварылі

452
00:22:27,750 --> 00:22:30,770
У гэтым годзе пад назвай debug50
што дазволіць вам

453
00:22:30,770 --> 00:22:34,130
выкарыстоўваць тое, што называецца убудаваным
графічны адладчык ў CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
І адладчык проста праграма, якая
як правіла, дазваляе запускаць праграму

455
00:22:38,400 --> 00:22:44,050
але крок за крокам за крокам, лініі
па лініі па лініі, робячы паўзу, тыкаючы

456
00:22:44,050 --> 00:22:47,626
вакол, гледзячы на ​​пераменныя, так што
праграма не проста ўдар міма вас

457
00:22:47,626 --> 00:22:49,750
і хутка надрукаваць што-небудзь
ці не надрукаваць што-небудзь.

458
00:22:49,750 --> 00:22:53,250
Гэта дае магчымасць, у
чалавечая хуткасць, каб ўзаемадзейнічаць з ім.

459
00:22:53,250 --> 00:22:55,470
>> І зрабіць гэта, вы
проста зрабіце наступнае.

460
00:22:55,470 --> 00:22:58,479
Пасля кампіляцыі кода,
якія я ўжо зрабіў, buggy3,

461
00:22:58,479 --> 00:23:00,020
вы ідзяце наперад і запусціць debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Гэтак жа, як help50 мае запуску
help50, а затым каманда,

464
00:23:06,760 --> 00:23:10,120
debug50 мае запусціць debug50 і
то імя каманды.

465
00:23:10,120 --> 00:23:14,440
>> Цяпер паглядзім, што адбываецца на маім экране,
на правай баку, у прыватнасці.

466
00:23:14,440 --> 00:23:19,400
Калі я ударыў Выканаць, усё
раптоўная панэль гэтая правая

467
00:23:19,400 --> 00:23:20,419
адкрывае на экране.

468
00:23:20,419 --> 00:23:22,210
І ёсць шмат чаго адбываецца
на на першы погляд.

469
00:23:22,210 --> 00:23:25,110
Але есці не занадта
шмат прычын для турботы пакуль няма.

470
00:23:25,110 --> 00:23:28,570
>> Гэта паказвае мне ўсё
што адбываецца ўнутры маёй праграмы

471
00:23:28,570 --> 00:23:31,130
прама зараз, і праз іх
Кнопкі уверх верхняй затым

472
00:23:31,130 --> 00:23:35,910
што дазволіла мне прайсці праз мой код
у канчатковым выніку крок за крокам за крокам.

473
00:23:35,910 --> 00:23:37,140
Але не толькі пакуль.

474
00:23:37,140 --> 00:23:38,060
Звярніце ўвагу на тое, што адбываецца.

475
00:23:38,060 --> 00:23:40,600
У маім акне тэрмінала
Я запыту на ўвод п.

476
00:23:40,600 --> 00:23:44,560
І я збіраюся ісці наперад і
супрацоўніцтва на гэты раз і ўвядзіце -1.

477
00:23:44,560 --> 00:23:48,770
І хоць і трохі загадкава, -1
з'яўляецца адмоўным цэлым лікам, як і варта было чакаць.

478
00:23:48,770 --> 00:23:52,020
>> І тады дзіця выйшаў з
Статус 0 GDBserver выхаду.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, гэтае імя
Яно ляжыць у аснове праграмнага забеспячэння

480
00:23:55,180 --> 00:23:56,620
які рэалізуе гэты адладчык.

481
00:23:56,620 --> 00:24:00,500
Але ўсё гэта на самай справе азначае, адладчык
пайшоў, таму што мая праграма кінуць паліць

482
00:24:00,500 --> 00:24:01,710
і ўсё было добра.

483
00:24:01,710 --> 00:24:06,020
Калі я хачу, каб сапраўды адладжваць праграму,
Я павінен сказаць, прэвентыўна debug50,

484
00:24:06,020 --> 00:24:08,920
дзе я хачу, каб пачаць
пакрокавага мой код?

485
00:24:08,920 --> 00:24:11,750
>> І, мабыць, самы просты спосаб
зрабіць гэта наступным чынам.

486
00:24:11,750 --> 00:24:15,300
Калі я лунаць над
Жолаб майго рэдактара тут,

487
00:24:15,300 --> 00:24:19,090
так на самой справе проста ў бакавой панэлі тут,
злева ад нумара радка,

488
00:24:19,090 --> 00:24:21,870
Звярніце ўвагу, што, калі я проста націсніце
адзін раз, я стаўлю маленькую чырвоную кропку.

489
00:24:21,870 --> 00:24:24,460
І гэтая маленькая чырвоная кропка,
як знак прыпынку, значыць, эй,

490
00:24:24,460 --> 00:24:29,430
debug50, выкананне паўзы майго кода
прама там, калі я запусціць гэтую праграму.

491
00:24:29,430 --> 00:24:30,260
>> Дык давайце зробім гэта.

492
00:24:30,260 --> 00:24:37,340
Дазвольце мне ісці наперад і запусціць маю праграму
зноў з debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
А цяпер, звярніце ўвагу, што-то
інакш адбылося.

494
00:24:40,110 --> 00:24:42,440
Я не запыт
ўсё ж у маім акне тэрмінала

495
00:24:42,440 --> 00:24:45,430
ні за што, таму што ў мяне няма
атрымаў там яшчэ ў маёй праграме.

496
00:24:45,430 --> 00:24:47,950
Звярніце ўвагу на тое, што ў радку 8
які ў цяперашні час выдзелены,

497
00:24:47,950 --> 00:24:51,720
і ёсць маленькая стрэлка
левая выслоўе, ты спыніўся тут.

498
00:24:51,720 --> 00:24:55,030
Гэты радок кода, радкі
8, да гэтага часу не выканана.

499
00:24:55,030 --> 00:24:58,940
>> І што цікава, калі я гляджу
тут на правай баку,

500
00:24:58,940 --> 00:25:03,530
звярніце ўвагу, што я з'яўляецца лакальным
зменная, лакальная у тым сэнсе,

501
00:25:03,530 --> 00:25:05,450
што ён унутры бягучай функцыі.

502
00:25:05,450 --> 00:25:08,920
І яго значэнне, па-відаць, па змаўчанні,
і быццам зручна, роўна 0.

503
00:25:08,920 --> 00:25:10,260
Але я не тып 0.

504
00:25:10,260 --> 00:25:13,410
Гэта як раз здараецца быць яго
Значэнне па змаўчанні ў дадзены момант.

505
00:25:13,410 --> 00:25:15,490
>> Такім чынам, дазвольце мне ісці наперад і рабіць гэта зараз.

506
00:25:15,490 --> 00:25:18,680
Дазвольце мне ісці наперад і на
у правым верхнім куце тут, я

507
00:25:18,680 --> 00:25:20,970
ісці наперад і
націсніце гэтую першую абразок, якая

508
00:25:20,970 --> 00:25:25,360
азначае крок, над якім азначае не прапусціць
гэта, але пераступіць гэты радок кода,

509
00:25:25,360 --> 00:25:27,770
выконваючы яго па шляху.

510
00:25:27,770 --> 00:25:30,710
>> А цяпер звярніце ўвагу, што я
хуткае толькі што змяніў.

511
00:25:30,710 --> 00:25:31,380
Чаму гэта?

512
00:25:31,380 --> 00:25:33,639
Я сказаў debug50,
запусціць гэты радок кода.

513
00:25:33,639 --> 00:25:34,930
Што робіць гэты радок кода рабіць?

514
00:25:34,930 --> 00:25:35,960
Запытвае мяне на міжнар.

515
00:25:35,960 --> 00:25:36,460
ДОБРА.

516
00:25:36,460 --> 00:25:37,400
Дазвольце мне супрацоўнічаць.

517
00:25:37,400 --> 00:25:41,340
Дазвольце мне ісці наперад зараз і ўвядзіце -1, Enter.

518
00:25:41,340 --> 00:25:42,920
А цяпер звярніце ўвагу, што змянілася.

519
00:25:42,920 --> 00:25:46,060
З правага боку,
мая лакальная пераменная я

520
00:25:46,060 --> 00:25:48,200
пазначаецца як -1 ў цяперашні час.

521
00:25:48,200 --> 00:25:49,810
І гэта ўсё ж такі тыпу Int.

522
00:25:49,810 --> 00:25:53,102
>> І заўважце, таксама, мой так званы
стэк выклікаў, дзе ж я паўзу?

523
00:25:53,102 --> 00:25:54,810
Мы будзем казаць больш пра
гэта ў будучыні.

524
00:25:54,810 --> 00:25:58,620
Але стэк выклікаў проста спасылаецца на тое, што
функцыі ў цяперашні час у руху.

525
00:25:58,620 --> 00:26:00,040
Цяпер гэта проста галоўны.

526
00:26:00,040 --> 00:26:03,590
І цяпер адзіны мясцовы
пераменная I са значэннем 1.

527
00:26:03,590 --> 00:26:09,840
>> І калі я, нарэшце, крок па гэтай лініі
тут, з той жа значок у правым верхнім куце,

528
00:26:09,840 --> 00:26:11,410
-1 З'яўляецца адмоўным цэлым лікам.

529
00:26:11,410 --> 00:26:13,580
Цяпер ён затрымаўшыся над гэтым фігурнай дужкай.

530
00:26:13,580 --> 00:26:14,740
Давайце хай гэта робяць сваю справу.

531
00:26:14,740 --> 00:26:17,300
Я пераступіць гэты радок, і вуаля.

532
00:26:17,300 --> 00:26:20,240
>> Так што не ўсё, што жудасна
павучальна ўсё ж,

533
00:26:20,240 --> 00:26:23,550
але гэта дазвольце мне зрабіць паўзу
і думаю, што праз лагічна

534
00:26:23,550 --> 00:26:24,870
што гэтая праграма робіць.

535
00:26:24,870 --> 00:26:26,890
Але гэта не было памылковым выпадкам.

536
00:26:26,890 --> 00:26:28,510
Давайце зробім гэта зноў наступным чынам.

537
00:26:28,510 --> 00:26:31,340
>> Я збіраюся пакінуць гэты пункт супыну
у радку 8 з чырвонай кропкай.

538
00:26:31,340 --> 00:26:32,830
Я збіраюся паўторна запусціць debug50.

539
00:26:32,830 --> 00:26:34,400
Гэта аўтаматычна прыпыняецца тут.

540
00:26:34,400 --> 00:26:37,660
Але на гэты раз, замест таго,
пераступаючы праз гэтую лінію,

541
00:26:37,660 --> 00:26:42,290
дазвольце мне на самай справе ісці ўнутры
get_negative_int і высветліць,

542
00:26:42,290 --> 00:26:45,530
чаму гэта прыняцце 0 ў якасці сапраўднага адказу?

543
00:26:45,530 --> 00:26:47,990
>> Такім чынам, замест таго, каб націснуць Step Over.

544
00:26:47,990 --> 00:26:50,630
Я збіраюся ісці наперад
і націсніце кнопку Step Into.

545
00:26:50,630 --> 00:26:54,030
І да вашага ведама, што лінія 8 гэта
цяпер вылучаецца зараз раптам

546
00:26:54,030 --> 00:26:56,900
становіцца радок 17.

547
00:26:56,900 --> 00:26:59,947
>> Цяпер, гэта не значыць, што адладчык
прапусціў лініі 14 і 15, і 16.

548
00:26:59,947 --> 00:27:01,780
Гэта не проста там нічога
каб паказаць вам там.

549
00:27:01,780 --> 00:27:04,050
Тыя аб'явы зменных,
а затым там слова Do

550
00:27:04,050 --> 00:27:05,390
а затым адкрытая фігурная дужка.

551
00:27:05,390 --> 00:27:09,227
Толькі функцыянальная лінія, гэта
сакавіты сапраўды гэты тут, 17.

552
00:27:09,227 --> 00:27:11,060
І вось дзе мы
аўтаматычна прыпыняецца.

553
00:27:11,060 --> 00:27:13,870
>> Так што Е ( "n.is:");, так
што да гэтага часу не адбылося.

554
00:27:13,870 --> 00:27:18,250
Так што давайце ісці наперад і націсніце кнопку Step Over.

555
00:27:18,250 --> 00:27:20,326
Цяпер мой запыт, на самай справе,
зменены ( "п:").

556
00:27:20,326 --> 00:27:22,450
Цяпер get_int, я не збіраюся
турбаваць ўступаем,

557
00:27:22,450 --> 00:27:24,750
таму што функцыя была
зробленыя CS50 ў бібліятэцы.

558
00:27:24,750 --> 00:27:25,750
Гэта, верагодна, правільна.

559
00:27:25,750 --> 00:27:28,440
>> Так што я збіраюся ісці наперад і
свайго роду супрацоўніцтва, надаўшы яму

560
00:27:28,440 --> 00:27:30,590
выклічце перапыненне, але не з'яўляецца адмоўным Int.

561
00:27:30,590 --> 00:27:32,870
Такім чынам, дазвольце мне ісці наперад і ўдарыў 0.

562
00:27:32,870 --> 00:27:39,460
А цяпер, што адбываецца тут
калі я атрымліваю ўніз да лініі 21?

563
00:27:39,460 --> 00:27:40,890
Я не итерироваться зноў.

564
00:27:40,890 --> 00:27:43,320
Я, здаецца, не затрымаецца ў гэтым цыкле.

565
00:27:43,320 --> 00:27:45,990
Іншымі словамі, гэты жоўты
бар ня будзе трымаць вакол,

566
00:27:45,990 --> 00:27:47,130
і вакол, і вакол яго.

567
00:27:47,130 --> 00:27:48,340
>> Цяпер, чаму гэта?

568
00:27:48,340 --> 00:27:49,920
Што ж, п, што роўна п прама цяпер?

569
00:27:49,920 --> 00:27:53,280
Я магу глядзець на мясцовым
Зменныя ў адладчык.

570
00:27:53,280 --> 00:27:53,816
п роўна 0.

571
00:27:53,816 --> 00:27:55,190
Добра, што гэта было маё стан?

572
00:27:55,190 --> 00:27:58,700
>> 20-- лінія 20, ну,
0 больш 0.

573
00:27:58,700 --> 00:27:59,500
Гэта не так.

574
00:27:59,500 --> 00:28:01,020
0 не больш за 0.

575
00:28:01,020 --> 00:28:02,820
І таму я вырвалася з гэтага.

576
00:28:02,820 --> 00:28:06,370
>> І вось чаму на лініі
21, калі я на самай справе па-ранейшаму,

577
00:28:06,370 --> 00:28:10,370
Я збіраюся вярнуць 0, нават
хоць я павінен быў адпрэчана 0

578
00:28:10,370 --> 00:28:12,484
а на самой справе не з'яўляецца адмоўным.

579
00:28:12,484 --> 00:28:14,650
Так што цяпер, я не вельмі нават
клапаціцца аб адладчыка.

580
00:28:14,650 --> 00:28:16,900
Зразумеў, я не трэба
ведаю, што яшчэ адбываецца.

581
00:28:16,900 --> 00:28:19,233
>> Так што я збіраюся ісці наперад і
проста націсніце кнопку прайгравання,

582
00:28:19,233 --> 00:28:20,240
і хай гэта скончыць.

583
00:28:20,240 --> 00:28:23,440
Цяпер я зразумеў, што мой
памылка па-відаць, у радку 20.

584
00:28:23,440 --> 00:28:25,160
Гэта мая лагічная памылка.

585
00:28:25,160 --> 00:28:28,100
>> І вось, што я хачу
трэба зрабіць, каб змяніць гэта?

586
00:28:28,100 --> 00:28:32,500
Калі праблема заключаецца ў тым, што я не
лавіць 0, гэта проста лагічная памылка.

587
00:28:32,500 --> 00:28:35,910
І я магу сказаць, у той час як у я
больш або роўна 0,

588
00:28:35,910 --> 00:28:38,330
трымаць зноў і зноў запытваючы карыстальніка.

589
00:28:38,330 --> 00:28:41,050
>> Так што, зноў жа, простая памылка, магчыма,
нават відавочна, калі вы бачылі мяне

590
00:28:41,050 --> 00:28:42,410
напісаць гэта ўсяго некалькі хвілін таму.

591
00:28:42,410 --> 00:28:44,570
Але тут вынас
з'яўляецца тое, што пры адладцы 50,

592
00:28:44,570 --> 00:28:46,850
і з адладкай
праграмнае забеспячэнне ў больш агульным плане,

593
00:28:46,850 --> 00:28:51,370
ў вас ёсць гэта новае харчаванне
прайсці праз свой уласны код, глядзіце

594
00:28:51,370 --> 00:28:55,590
з дапамогай гэтай правай панэлі, што
зменныя значэння.

595
00:28:55,590 --> 00:28:57,700
Такім чынам, вы не абавязкова
павінны выкарыстоўваць нешта

596
00:28:57,700 --> 00:29:00,630
як вы eprintf друкаваць гэтыя значэння.

597
00:29:00,630 --> 00:29:04,430
Вы можаце ўбачыць іх
візуальна на экране.

598
00:29:04,430 --> 00:29:08,920
>> Цяпер, апроч гэтага, варта адзначыць,
што ёсць іншая тэхніка, якая

599
00:29:08,920 --> 00:29:09,890
на самай справе вельмі распаўсюджанай з'явай.

600
00:29:09,890 --> 00:29:13,120
І вы маглі б задацца пытаннем, чаму гэты маленькі
хлопец тут сядзеў на сцэне.

601
00:29:13,120 --> 00:29:16,490
Так што ёсць гэтая тэхніка, як правіла,
вядомы як метад качаняці,

602
00:29:16,490 --> 00:29:18,786
які на самай справе гэта проста
сведчаннем таго,

603
00:29:18,786 --> 00:29:20,660
што часта, калі праграмісты
напісанні кода,

604
00:29:20,660 --> 00:29:22,650
яны не абавязкова
супрацоўнічаючы з іншымі,

605
00:29:22,650 --> 00:29:24,030
або працаваць у агульнай асяроддзі.

606
00:29:24,030 --> 00:29:25,050
>> Яны накшталт дома.

607
00:29:25,050 --> 00:29:25,910
Можа быць, гэта позна ўначы.

608
00:29:25,910 --> 00:29:28,190
Яны спрабуюць фігуры
некаторыя памылкі ў сваім кодзе.

609
00:29:28,190 --> 00:29:29,330
І яны проста не бачыць.

610
00:29:29,330 --> 00:29:30,329
>> І няма ніякага суседа па пакоі.

611
00:29:30,329 --> 00:29:31,250
Там няма TF.

612
00:29:31,250 --> 00:29:32,680
Там няма CA вакол.

613
00:29:32,680 --> 00:29:36,440
Усе яны маюць на сваёй паліцы
гэтая маленькая гумавая уточка.

614
00:29:36,440 --> 00:29:39,030
>> І таму адладка гумавая качка
проста гэта запрашэнне

615
00:29:39,030 --> 00:29:42,780
думаць пра што-то, як па-дурному
так як гэта як рэальнае істота,

616
00:29:42,780 --> 00:29:46,940
і на самай справе прайсці праз ваш код
ў вуснай форме да гэтага неадушаўлёны аб'ект.

617
00:29:46,940 --> 00:29:49,230
Так, напрыклад, калі
гэта мой прыклад here--

618
00:29:49,230 --> 00:29:52,470
і нагадаем, што раней
праблема была ў гэтым,

619
00:29:52,470 --> 00:29:58,140
калі я выдалю гэтую першую радок кода,
і я іду наперад і зрабіць багі 0 раз,

620
00:29:58,140 --> 00:30:01,220
Нагадаем, што ў мяне былі гэтыя
Паведамленні пра памылкі тут.

621
00:30:01,220 --> 00:30:05,997
Так што ідэя тут, смешна, хоць я
адчуваю ў дадзены момант робіць гэта публічна,

622
00:30:05,997 --> 00:30:06,580
з'яўляецца тое, што памылка.

623
00:30:06,580 --> 00:30:10,910
>> ОК, так што мая праблема ў тым, што я
няяўна бібліятэчную функцыю.

624
00:30:10,910 --> 00:30:12,610
І гэтая функцыя бібліятэкі Printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, абвясціць
нагадвае мне пра прататыпах.

626
00:30:15,290 --> 00:30:18,930
>> Гэта азначае, што мне трэба на самай справе
паведаміць кампілятару загадзя, што

627
00:30:18,930 --> 00:30:19,980
функцыя выглядае наступным чынам.

628
00:30:19,980 --> 00:30:20,930
Пачакай хвіліну.

629
00:30:20,930 --> 00:30:23,580
У мяне не было стандартнага io.h.

630
00:30:23,580 --> 00:30:24,530
Вялікі дзякуй.

631
00:30:24,530 --> 00:30:27,330
>> Так што гэты працэс of-- вас
ня трэба на самой справе ёсць качка.

632
00:30:27,330 --> 00:30:29,819
Але гэтая ідэя хадзіць
самастойна праз свой уласны код

633
00:30:29,819 --> 00:30:31,610
так што вы нават чуць
самастойна, так што вы

634
00:30:31,610 --> 00:30:35,620
рэалізаваць хібы ў свой уласны
заўвагі, як правіла, ідэя.

635
00:30:35,620 --> 00:30:38,910
>> І, магчыма, больш лагічна, не так
шмат з гэтым адзін, але больш актыўны ўдзел

636
00:30:38,910 --> 00:30:44,220
Прыклад, які мы толькі што зрабілі ў багі 3.c,
Вы маглі б хадзіць сябе праз яго

637
00:30:44,220 --> 00:30:45,310
наступным чынам.

638
00:30:45,310 --> 00:30:49,190
Так што ўсё ў парадку, гума
душка, DDB, калі вы будзеце.

639
00:30:49,190 --> 00:30:52,350
Тут мы маем на сваёй асноўнай функцыі,
Я тэлефаную атрымаць адмоўны вынік Int.

640
00:30:52,350 --> 00:30:54,660
>> І я атрымліваю вяртаецца значэнне.

641
00:30:54,660 --> 00:31:00,410
Я захоўваць яго на левым баку
у радку 8 у зменнай называецца I.

642
00:31:00,410 --> 00:31:02,380
Добра, але чакаць, як зрабіў
што атрымаць гэта значэнне?

643
00:31:02,380 --> 00:31:04,130
Дазвольце мне зірнуць на функцыі ў радку 12.

644
00:31:04,130 --> 00:31:05,760
>> У радку 12 мы маем атрымаць адмоўную Int.

645
00:31:05,760 --> 00:31:08,190
Не прымаць якія-небудзь матэрыялы,
гэта вяртае Int, OK.

646
00:31:08,190 --> 00:31:10,929
Я заяўляю, у радку 14 пераменная п.

647
00:31:10,929 --> 00:31:12,220
Гэта будзе захоўваць цэлы лік.

648
00:31:12,220 --> 00:31:13,760
Вось што я хачу.

649
00:31:13,760 --> 00:31:18,480
>> Так зрабіце наступнае: Калі п is-- хай
мне адмяніць тое, што выпраўленне я ўжо зрабіў.

650
00:31:18,480 --> 00:31:22,710
Такім чынам, у той час як у я больш
0, раздрукаваць п, OK.

651
00:31:22,710 --> 00:31:25,170
А затым выклічце атрымаць INT захоўваецца ў п.

652
00:31:25,170 --> 00:31:30,160
А затым праверце, калі п = 0,
п не-- там.

653
00:31:30,160 --> 00:31:31,910
Так што, зноў жа, вы гэтага не зробіце
патрэбен фактычны качка.

654
00:31:31,910 --> 00:31:35,650
Але проста хадзіць самастойна праз
ваш код як інтэлектуальнае практыкаванне

655
00:31:35,650 --> 00:31:37,720
часта дапаможа вам
ўсвядоміць, што адбываецца,

656
00:31:37,720 --> 00:31:41,170
а не проста рабіць нешта
як гэта, гледзячы на ​​экран,

657
00:31:41,170 --> 00:31:43,720
і не казаць сябе праз
тое, што гэта не сумленна

658
00:31:43,720 --> 00:31:46,270
амаль як эфектыўны метад.

659
00:31:46,270 --> 00:31:48,620
Так што ў вас ёсць, A
колькасць розных метадаў

660
00:31:48,620 --> 00:31:52,102
для фактычна адладкі кода
і прыдзірацца, усе з якіх

661
00:31:52,102 --> 00:31:54,810
павінны быць інструменты ў ваш інструментар
так што вы не позна ўначы,

662
00:31:54,810 --> 00:31:57,660
асабліва, вы ў сталовай
залы, або ў непрацоўны час,

663
00:31:57,660 --> 00:32:00,368
б'ешся галавой супраць
сцены, спрабуючы вырашыць некаторыя праблемы.

664
00:32:00,368 --> 00:32:02,020
Разумеюць, што ёсць праграмныя сродкі.

665
00:32:02,020 --> 00:32:03,720
Ёсць гумовая качка інструменты.

666
00:32:03,720 --> 00:32:09,630
І ёсць цэлы штат
падтрымкі чакаюць, каб працягнуць руку дапамогі.

667
00:32:09,630 --> 00:32:13,120
>> Так што цяпер, слова па праблеме
наборы, а таксама на тое, што мы спадзяемся, што вам

668
00:32:13,120 --> 00:32:15,620
выйсці з іх, і як
мы ідзем аб ацэнцы.

669
00:32:15,620 --> 00:32:17,680
За навучальны план Курсу,
CS50 мноства праблем у

670
00:32:17,680 --> 00:32:22,320
ацэньваюцца па чатырох асноўных восях, так
каб speak-- сферу, карэктнасць, дызайн,

671
00:32:22,320 --> 00:32:23,060
і стыль.

672
00:32:23,060 --> 00:32:25,910
І сфера проста ставіцца да таго, колькі
кавалка вы адкусілі?

673
00:32:25,910 --> 00:32:28,080
Колькі праблемы вы спрабавалі?

674
00:32:28,080 --> 00:32:30,110
Які ўзровень намаганняў
Вы выяўлялася?

675
00:32:30,110 --> 00:32:35,750
>> Карэктнасць, працуе праграма, як
ён павінен паводле спецыфікацыі CS50

676
00:32:35,750 --> 00:32:38,640
калі вы дае пэўныя ўваходы
або пэўныя выхады вяртаюцца?

677
00:32:38,640 --> 00:32:41,130
Дызайн з'яўляецца найбольш суб'ектыўным з іх.

678
00:32:41,130 --> 00:32:43,360
І гэта той, які будзе
ўзяць самы доўгі, каб даведацца,

679
00:32:43,360 --> 00:32:47,220
і самы доўгі, каб выкладаць у
да гэтага часу, як гэта зводзіцца да таго,

680
00:32:47,220 --> 00:32:49,530
як добра напісана ваш код?

681
00:32:49,530 --> 00:32:52,920
>> Гэта адна рэч, каб проста надрукаваць правільны
выхады або вяртаць правільныя значэння.

682
00:32:52,920 --> 00:32:55,400
Але вы робіце гэта як
эфектыўна, наколькі гэта магчыма?

683
00:32:55,400 --> 00:32:58,210
Вы робіце гэта разрыў
і ўладар, або двайковы

684
00:32:58,210 --> 00:33:01,500
Пошук, як мы хутка ўбачым, што мы зрабілі
два тыдні таму з тэлефоннай кнігай?

685
00:33:01,500 --> 00:33:04,670
Ці існуюць больш эфектыўныя спосабы вырашэння
праблема, чым цяпер у вас тут?

686
00:33:04,670 --> 00:33:06,380
Гэта магчымасць для лепшага дызайну.

687
00:33:06,380 --> 00:33:08,530
>> А потым, як style--
даволі ваш код?

688
00:33:08,530 --> 00:33:12,370
Вы заўважыце, што я даволі
прыватнасці аб водступаў мой код,

689
00:33:12,370 --> 00:33:15,300
і пераканаўшыся, што мае зменныя
абгрунтавана названыя. п,

690
00:33:15,300 --> 00:33:19,660
у той час як кароткія, добрае імя для
нумар, я для падліку ліку,

691
00:33:19,660 --> 00:33:20,727
s для радка.

692
00:33:20,727 --> 00:33:22,560
І мы можам мець больш
імёны зменных стылю.

693
00:33:22,560 --> 00:33:25,500
Стыль, наколькі добра
выглядае ваш код?

694
00:33:25,500 --> 00:33:26,600
А як чытаны гэта?

695
00:33:26,600 --> 00:33:29,650
>> І з цягам часу, чым вашы TAs
і ТФ будзе рабіць у працэсе

696
00:33:29,650 --> 00:33:31,870
гэта прадаставіць вам, што
выгляд якаснай зваротнай сувязі

697
00:33:31,870 --> 00:33:34,330
так што вы атрымаеце лепш
ў гэтых розных аспектах.

698
00:33:34,330 --> 00:33:37,510
І з пункту гледжання таго, як мы
ацаніць кожную з гэтых восяў,

699
00:33:37,510 --> 00:33:40,080
гэта, як правіла, з вельмі нямногімі
вядра, так што вы, як правіла,

700
00:33:40,080 --> 00:33:41,680
атрымаць уяўленне аб тым, наколькі добра вы робіце.

701
00:33:41,680 --> 00:33:45,680
І сапраўды, калі вы атрымаеце рахунак на
любы з гэтых axes-- правільнасць, дызайн

702
00:33:45,680 --> 00:33:49,659
і стыль especially--, што колькасць
як правіла, складае ад 1 да 5 балаў.

703
00:33:49,659 --> 00:33:52,450
І, у літаральным сэнсе, калі вы атрымліваеце
3-х у пачатку семестра,

704
00:33:52,450 --> 00:33:53,977
гэта вельмі добрая рэч.

705
00:33:53,977 --> 00:33:55,810
Гэта азначае, што ёсць яшчэ
магчымасці для паляпшэння,

706
00:33:55,810 --> 00:33:58,490
які вы б спадзявацца ў
прымаючы клас у першы раз.

707
00:33:58,490 --> 00:34:01,820
Там у нейкі, спадзяюся, трохі столі
да якога вы імкнуцца да дасягнення.

708
00:34:01,820 --> 00:34:03,970
І таму атрыманне 3 па
самыя раннія п'есы,

709
00:34:03,970 --> 00:34:06,550
калі не які-то 2-х і 4-х,
гэта, сапраўды, вельмі добрая рэч.

710
00:34:06,550 --> 00:34:08,880
Гэта добра ў межах дыяпазону,
добра ў межах чаканняў.

711
00:34:08,880 --> 00:34:11,421
>> І калі ваш розум імчыцца, пачакайце
хвіліну, тры з пяці.

712
00:34:11,421 --> 00:34:12,620
Гэта сапраўды 6 з 10.

713
00:34:12,620 --> 00:34:13,560
Гэта 60%.

714
00:34:13,560 --> 00:34:14,830
Божа мой, гэта на літару F.

715
00:34:14,830 --> 00:34:15,870
>> Гэта не.

716
00:34:15,870 --> 00:34:17,600
Гэта не так, на самай справе, гэта.

717
00:34:17,600 --> 00:34:22,710
Хутчэй за ўсё, гэта магчымасць палепшыць
на працягу семестра.

718
00:34:22,710 --> 00:34:25,580
І калі вы атрымліваеце некаторыя
Poors, гэта магчымасць

719
00:34:25,580 --> 00:34:29,199
каб скарыстацца офіснымі гадзінамі,
вядома ж раздзелы і іншыя рэсурсы.

720
00:34:29,199 --> 00:34:32,840
>> Лепш гэта магчымасць, на самай справе,
можна ганарыцца, наколькі далёка вы

721
00:34:32,840 --> 00:34:34,520
прыходзяць на працягу семестра.

722
00:34:34,520 --> 00:34:38,199
Гэтак жа разумееш, калі нічога
яшчэ тры добра.

723
00:34:38,199 --> 00:34:40,179
І гэта дазваляе для росту з цягам часу.

724
00:34:40,179 --> 00:34:43,090
>> Што тычыцца таго, як гэтыя восі
узважанае, рэальна вы

725
00:34:43,090 --> 00:34:46,745
збіраецца выдаткаваць большую частку свайго часу атрымання
рэчы, каб працаваць, не кажучы ўжо правільна.

726
00:34:46,745 --> 00:34:49,120
І таму, як правіла, карэктнасць
узважвацца больш за ўсё, як і з

727
00:34:49,120 --> 00:34:51,360
гэты мультыплікатыўны фактар ​​трох.

728
00:34:51,360 --> 00:34:54,659
Дызайн таксама мае важнае значэнне, але
тое, што вы не абавязкова

729
00:34:54,659 --> 00:34:58,220
марнаваць ўсё тыя гадзіны, на
спрабуючы атрымаць рэчы проста працаваць.

730
00:34:58,220 --> 00:35:00,019
>> І такім чынам гэта ўзважаны
крыху больш за злёгку.

731
00:35:00,019 --> 00:35:01,560
А потым стыль важыцца па меншай меры.

732
00:35:01,560 --> 00:35:03,710
Нягледзячы на ​​тое, што гэта не менш
важна фундаментальна,

733
00:35:03,710 --> 00:35:05,990
гэта проста, можа быць,
Прасцей за ўсё зрабіць правільна,

734
00:35:05,990 --> 00:35:08,440
імітуючы прыклады, якія мы
рабіць у лекцыі і секцыі,

735
00:35:08,440 --> 00:35:11,080
з рэчамі прыгожа
водступам, і пракаментаваў,

736
00:35:11,080 --> 00:35:14,320
і гэтак далей з'яўляецца адным з самых простых
рэчы, каб зрабіць і атрымаць права.

737
00:35:14,320 --> 00:35:16,960
Так як такія, рэалізаваць
што тыя кропкі

738
00:35:16,960 --> 00:35:19,000
што адносна лёгка зразумець.

739
00:35:19,000 --> 00:35:22,360
>> А цяпер слова на
this-- акадэмічнай сумленнасці.

740
00:35:22,360 --> 00:35:25,150
Такім чынам, за Курса
навучальны план, вы ўбачыце

741
00:35:25,150 --> 00:35:27,630
што курс мае даволі
трохі мовы вакол гэтага.

742
00:35:27,630 --> 00:35:31,380
І вядома ж бярэ пытанне
акадэмічная сумленнасць цалкам сур'ёзна.

743
00:35:31,380 --> 00:35:33,450
>> У нас ёсць адрозненні,
да лепшага ці да горшага,

744
00:35:33,450 --> 00:35:36,570
з даслаўшы кожны год больш
студэнтаў для прыняцця дысцыплінарных мер

745
00:35:36,570 --> 00:35:39,670
чым большасць любы іншы
Вядома ж, што я ведаю.

746
00:35:39,670 --> 00:35:42,580
Гэта не абавязкова
сведчыць пра тое,

747
00:35:42,580 --> 00:35:46,340
што студэнты CS або CS50 студэнтаў, з'яўляюцца
менш больш сумленна сваіх аднакласнікаў.

748
00:35:46,340 --> 00:35:49,090
Але рэальнасць, што ў гэтым
свет, у электронным выглядзе, мы проста

749
00:35:49,090 --> 00:35:50,990
ёсць тэхналагічная
сродак выяўлення гэтага.

750
00:35:50,990 --> 00:35:53,360
>> Гэта вельмі важна для нас для
справядлівасць па класе

751
00:35:53,360 --> 00:35:58,550
што мы робім гэта выявіць і падняць
пытанне, калі мы бачым рэчы.

752
00:35:58,550 --> 00:36:01,980
І як раз, каб намаляваць карціну, а на самай справе
каб дапамагчы нешта накшталт гэтага ў ракавіне,

753
00:36:01,980 --> 00:36:04,600
гэты лік
Студэнты на працягу апошніх 10 гадоў

754
00:36:04,600 --> 00:36:07,610
якія былі ўцягнутыя ў некаторыя
такія пытанні акадэмічнай сумленнасці,

755
00:36:07,610 --> 00:36:10,990
з некаторымі 32 студэнтаў
з восені 2015 года, якая

756
00:36:10,990 --> 00:36:13,760
павінен сказаць, што мы прымаем
справа вельмі сур'ёзна.

757
00:36:13,760 --> 00:36:18,380
І, у канчатковым рахунку, гэтыя лічбы складаюць,
Зусім нядаўна, каля 3%, 4% або каля таго

758
00:36:18,380 --> 00:36:19,120
класа.

759
00:36:19,120 --> 00:36:25,220
>> Так што для супер большасці студэнтаў
здаецца, што лініі выразныя.

760
00:36:25,220 --> 00:36:27,940
Але майце гэта на
розум, асабліва позна

761
00:36:27,940 --> 00:36:32,080
ў начны час, калі змагаецца з
нейкае рашэнне для мноства праблем,

762
00:36:32,080 --> 00:36:34,830
што існуюць механізмы
для атрымання сябе лепш

763
00:36:34,830 --> 00:36:37,870
падтрымка, чым вы маглі б
думаю, нават у тую ж гадзіну.

764
00:36:37,870 --> 00:36:40,514
Разумеюць, што, калі мы атрымліваем
студэнцкія прадстаўлення, мы перасякаем

765
00:36:40,514 --> 00:36:43,430
параўнаць усе прадстаўлення ў гэтым годзе
супраць кожнага прадстаўлення ў мінулым годзе,

766
00:36:43,430 --> 00:36:47,590
супраць кожнага прадстаўлення з 2007 года,
і так як, гледзячы на, а таксама,

767
00:36:47,590 --> 00:36:49,931
код рэпазітароў онлайн,
дыскусійных форумах, праца сайтаў.

768
00:36:49,931 --> 00:36:51,806
І мы адзначым гэта,
на самай справе, усё дзеля

769
00:36:51,806 --> 00:36:56,040
поўнага раскрыцця, што калі
хто-то можа знайсці яго ў Інтэрнэце,

770
00:36:56,040 --> 00:36:57,880
вядома ж, так што мы можам курс.

771
00:36:57,880 --> 00:37:00,100
Але, на самой справе, дух
з курсу зводзіцца

772
00:37:00,100 --> 00:37:01,650
да гэтай артыкуле ў вучэбнай праграме.

773
00:37:01,650 --> 00:37:03,670
Гэта сапраўды проста, разумна.

774
00:37:03,670 --> 00:37:06,680
>> І калі мы павінны былі спыніцца на гэтым
з толькі трохі больш мовы,

775
00:37:06,680 --> 00:37:09,770
ўсвядоміць, што сутнасць усіх
Праца, якую вы ўявіць гэты курс

776
00:37:09,770 --> 00:37:10,954
павінен быць свой уласны.

777
00:37:10,954 --> 00:37:13,870
Але ў тым, што ёсць, вядома,
магчымасцяў і заахвочванне,

778
00:37:13,870 --> 00:37:17,300
і педагагічная каштоўнасць у ператварэнні ў
others-- сябе, ССТ, КАС,

779
00:37:17,300 --> 00:37:20,760
Тас і іншыя ў класе,
для падтрымкі, не кажучы ўжо пра сяброў

780
00:37:20,760 --> 00:37:23,547
і суседзі па пакоі, хто вывучаў
CS і праграмаванне раней.

781
00:37:23,547 --> 00:37:25,130
І таму ёсць дапаможнік для гэтага.

782
00:37:25,130 --> 00:37:28,180
А агульнае правіла
з'яўляецца this--, калі просяць аб дапамозе,

783
00:37:28,180 --> 00:37:31,470
Вы можаце паказаць свой код іншым,
але вы не можаце праглядаць іх.

784
00:37:31,470 --> 00:37:34,880
Так што нават калі вы ў працоўны час,
або ў зале D, ці дзе-небудзь яшчэ

785
00:37:34,880 --> 00:37:37,450
працуе над нейкі кавалак набору,
працуючы разам з сябрам, які

786
00:37:37,450 --> 00:37:40,160
гэта цалкам нармальна, на
Канец дня вашай працы

787
00:37:40,160 --> 00:37:43,034
у канчатковым выніку павінна належаць кожнаму
з вас, адпаведна, і ня

788
00:37:43,034 --> 00:37:45,700
быць некаторыя сумесныя намаганні,
для канчатковага праекта, дзе акрамя

789
00:37:45,700 --> 00:37:47,410
гэта дазваляецца і заахвочваецца.

790
00:37:47,410 --> 00:37:49,830
>> Зразумейце, што калі вы
змагаецца з чымсьці

791
00:37:49,830 --> 00:37:52,520
і ваш сябар толькі што адбываецца
каб быць лепш у гэтым, то вы,

792
00:37:52,520 --> 00:37:55,130
або лепш на гэтую праблему, чым вы,
ці крыху далей наперад, чым вы,

793
00:37:55,130 --> 00:37:57,330
гэта цалкам разумна, каб ператварыць
свайму сябру і сказаць, эй,

794
00:37:57,330 --> 00:38:00,480
Вы не пярэчыце, гледзячы на ​​мой код тут,
каб дапамагчы мне вызначыць, што маё пытанне?

795
00:38:00,480 --> 00:38:03,760
І, спадзяюся, у
Цікавасць педагагічнай каштоўнасці

796
00:38:03,760 --> 00:38:07,040
што Віктар не проста
кажуць, ах, зрабіць гэта, але, хутчэй,

797
00:38:07,040 --> 00:38:09,917
тое, што вы зніклі без вестак на лініі
6, ці нешта падобнае?

798
00:38:09,917 --> 00:38:12,000
Але гэтае рашэнне не
для сябра побач з вамі

799
00:38:12,000 --> 00:38:15,617
сказаць, ой, ну, вось, дазвольце мне цягнуць
гэта, і паказаць маё рашэнне для вас.

800
00:38:15,617 --> 00:38:16,450
Так што гэта лінія.

801
00:38:16,450 --> 00:38:18,670
Вы паказваеце свой код у
іншыя, але вы не можаце

802
00:38:18,670 --> 00:38:22,350
паглядзець у іх, у адпаведнасці з іншымі
абмежаванні ў навучальны план Курса.

803
00:38:22,350 --> 00:38:24,760
>> Так што майце на ўвазе, што гэта
так званы пункт шкадавання

804
00:38:24,760 --> 00:38:27,560
у ходзе вучэбнага плана, а таксама,
што калі вы здзейсніце нейкі акт,

805
00:38:27,560 --> 00:38:30,476
не з'яўляецца разумным, але давесці яго да
увагу кіраўнікоў Курса

806
00:38:30,476 --> 00:38:34,240
на працягу 72 гадзін, курс
можа накладаць санкцыі, мясцовыя

807
00:38:34,240 --> 00:38:37,380
можа ўключаць у сябе нездавальняючым або
правальную ацэнку для працы, прадстаўленыя.

808
00:38:37,380 --> 00:38:41,410
Але, вядома, не перадасць
важна для далейшага прыняцця дысцыплінарных мер,

809
00:38:41,410 --> 00:38:43,010
за выключэннем выпадкаў паўторных актаў.

810
00:38:43,010 --> 00:38:46,632
Іншымі словамі, калі вы робіце некаторыя
па-дурному, асабліва позна ўвечары, рашэнне

811
00:38:46,632 --> 00:38:49,340
што на наступную раніцу або праз два дні
пазней, вы абудзіцца і ўсвядоміць,

812
00:38:49,340 --> 00:38:50,870
пра што я думаў?

813
00:38:50,870 --> 00:38:53,890
Вы робіце ў CS50 маюць выхад
для фіксацыі гэтай праблемы

814
00:38:53,890 --> 00:38:57,170
і валодаць да яго, так што мы
сустрэне вас на паўдарогі і справа

815
00:38:57,170 --> 00:39:01,500
з ім у пытанні, які з'яўляецца адначасова
адукацыйных і каштоўным для вас,

816
00:39:01,500 --> 00:39:04,200
але да гэтага часу карны ў некаторым родзе.

817
00:39:04,200 --> 00:39:08,590
І зараз, каб замарыць, гэта.

818
00:39:08,590 --> 00:39:10,570
>> [ВИДЕОВОСПРОИЗВЕДЕНИЕ]

819
00:39:10,570 --> 00:39:13,540
>> [МУЗЫКА]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [КАНЕЦ засьпяваю]

822
00:39:58,866 --> 00:40:00,490
DAVID J. малая: Добра, мы вярнуліся.

823
00:40:00,490 --> 00:40:03,680
А зараз мы паглядзім на адзін з
першы з нашых рэальных даменаў

824
00:40:03,680 --> 00:40:08,720
у CS50, мастацтва крыптаграфіі,
мастацтва адпраўкі і атрымання

825
00:40:08,720 --> 00:40:11,840
сакрэтныя паведамленні, зашыфраванага
паведамленні, калі вы будзеце,

826
00:40:11,840 --> 00:40:17,060
якія могуць быць расшыфраваны толькі калі ў вас ёсць
некаторыя з ключавых элементаў, што адпраўнік

827
00:40:17,060 --> 00:40:18,030
а.

828
00:40:18,030 --> 00:40:22,120
Такім чынам, каб матываваць гэтага мы возьмем
Паглядзіце на гэтую рэч тут,

829
00:40:22,120 --> 00:40:26,750
якая з'яўляецца Примердлительногопребывания
сакрэт дэкодэр кольца,

830
00:40:26,750 --> 00:40:34,042
можа быць выкарыстаны для таго, каб высветліць,
тое, што сакрэтнае паведамленне на самай справе.

831
00:40:34,042 --> 00:40:35,750
На самай справе, яшчэ ў
дзень у пачатковай школе,

832
00:40:35,750 --> 00:40:38,787
калі вы калі-небудзь паслаў сакрэтныя паведамленні
некаторыя сябар ці некаторыя цісканіна ў класе,

833
00:40:38,787 --> 00:40:40,620
Вы маглі б падумаць,
вы былі разумнымі

834
00:40:40,620 --> 00:40:46,530
шляхам на вашай частцы замены паперы,
як, А да В, і В да С, В і С да D,

835
00:40:46,530 --> 00:40:47,590
і гэтак далей.

836
00:40:47,590 --> 00:40:50,300
Але вы былі на самай справе шыфравання
Ваша інфармацыя, нават

837
00:40:50,300 --> 00:40:53,300
калі гэта было трохі трывіяльна, не было
што цяжка для настаўніка, каб зразумець,

838
00:40:53,300 --> 00:40:55,675
добра, калі вы проста змяніць
У да А і С да В,

839
00:40:55,675 --> 00:40:57,550
вы на самой справе высветліць,
што было паведамленне,

840
00:40:57,550 --> 00:40:59,700
але вы былі ў шыфраванні інфармацыі.

841
00:40:59,700 --> 00:41:03,420
>> Вы проста рабілі гэта
проста, гэтак жа, як Ральф тут

842
00:41:03,420 --> 00:41:07,934
у вядомым фільме, які гуляе
даволі шмат аб'яў кожную зіму да млоснасці.

843
00:41:07,934 --> 00:41:08,600
[ВИДЕОВОСПРОИЗВЕДЕНИЕ]

844
00:41:08,600 --> 00:41:11,180
-Будьте Гэта ўсім вядома, што
Ральф Паркер Сапраўдным

845
00:41:11,180 --> 00:41:14,070
прызначаны членам Маленькай
Сіротка Эні Secret Circle

846
00:41:14,070 --> 00:41:17,700
і мае права на ўсе ўшанаванні
і выгады адбываецца з ім.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Сіротка Эні,
сустрэчнае падпісаў П'ер Андрэ, ў чарніла.

848
00:41:24,340 --> 00:41:27,160
Ўшанаванні і выгады,
ўжо ва ўзросце дзевяці гадоў.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Крычучы]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Давай.

853
00:41:34,250 --> 00:41:35,210
Давайце скончым з гэтым.

854
00:41:35,210 --> 00:41:39,530
Мне не трэба ўсё, што джаз
аб кантрабандыстаў і піратаў.

855
00:41:39,530 --> 00:41:41,660
>> -Слухай Заўтра ноч
завяршальным прыгоды

856
00:41:41,660 --> 00:41:43,880
чорнага пірацкага карабля.

857
00:41:43,880 --> 00:41:46,650
Цяпер прыйшоў час для
сакрэтнае паведамленне Эні

858
00:41:46,650 --> 00:41:49,840
для вас члены тайнага гуртка.

859
00:41:49,840 --> 00:41:53,570
Памятаеце, дзеці, толькі сябры
Эні Сакрэтнай Circle

860
00:41:53,570 --> 00:41:56,140
можа расшыфраваць сакрэтнае паведамленне Эні.

861
00:41:56,140 --> 00:42:00,340
>> Памятаеце, што Эні залежыць ад вас.

862
00:42:00,340 --> 00:42:02,880
Усталюйце штыфты B2.

863
00:42:02,880 --> 00:42:05,230
Вось пасланьне.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Я Знаходжуся ў, сваю першую сакрэтную сустрэчу.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Быў гучны голас сёння.

868
00:42:15,780 --> 00:42:19,000
Я мог бы сказаць, што сёння ўвечары
паведамленне было сапраўды важна.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, гэта паведамленне
ад самой Эні.

870
00:42:22,694 --> 00:42:23,860
Памятаеце, што не кажы нікому.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Секунд праз, я знаходжуся ў адзінай
пакой у доме, дзе дзевяцігадовы хлопчык

873
00:42:32,930 --> 00:42:37,040
мог сядзець у адзіноце і дэкадаваннем.

874
00:42:37,040 --> 00:42:39,730
Ага, B!

875
00:42:39,730 --> 00:42:42,360
Я пайшоў да наступнага, Е.

876
00:42:42,360 --> 00:42:44,520
>> Першае слова будзе.

877
00:42:44,520 --> 00:42:49,032
S, ён ішоў лягчэй зараз, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -О, Давай, Ральф, я павінен ісці!

879
00:42:51,733 --> 00:42:53,688
>> -Я Зараз спушчуся, Ма!

880
00:42:53,688 --> 00:42:54,188
Ну і справы свісту!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -Т, O, абавязкова пераканайцеся, што, мэтай якіх да чаго?

883
00:43:04,060 --> 00:43:05,970
што сіротка
Эні спрабуе сказаць?

884
00:43:05,970 --> 00:43:07,264
Пераканайцеся, што да чаго?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Эндзі трапіў
ісці, то, калі ласка, выйсці?

886
00:43:09,634 --> 00:43:10,480
>> -Добра, Мама!

887
00:43:10,480 --> 00:43:12,880
Я буду прама!

888
00:43:12,880 --> 00:43:14,550
>> -Я Становіцца бліжэй.

889
00:43:14,550 --> 00:43:16,620
Напружанне было жудасна.

890
00:43:16,620 --> 00:43:17,720
Што гэта было?

891
00:43:17,720 --> 00:43:20,170
лёс планеты
можа вісець на валаску.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Эндзі павінен ісці!

894
00:43:23,170 --> 00:43:26,890
>> -Я Зараз выйду, для заклікаюць гучна!

895
00:43:26,890 --> 00:43:32,680
>> -почти Там, мае пальцы лёталі, мой розум
была сталёвая пастка, кожная пара вібраваць.

896
00:43:32,680 --> 00:43:37,198
Гэта было амаль ясна, так, так, так.

897
00:43:37,198 --> 00:43:43,091
>> -Будьте Абавязкова піць Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Вашывага камерцыйны?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Сукін сын.

903
00:43:54,227 --> 00:43:54,810
[КАНЕЦ засьпяваю]

904
00:43:54,810 --> 00:43:57,390
DAVID J. малая: ОК, так што
гэта быў вельмі доўгі шлях

905
00:43:57,390 --> 00:44:00,660
ўвядзення крыптаграфію,
а таксама Ovaltine.

906
00:44:00,660 --> 00:44:04,470
На самай справе, ад гэтага старога аб'яваў
тут, чаму Ovaltine так добра?

907
00:44:04,470 --> 00:44:09,470
Гэта канцэнтраванае выманне саспелыя
ячменны солад, чыстае сметанковае з каровінага малака,

908
00:44:09,470 --> 00:44:14,360
і спецыяльна падрыхтаваныя какава разам
з прыроднымі фасфатыдаў і вітамінаў.

909
00:44:14,360 --> 00:44:18,240
далей узбагачаныя
дадатковыя вітаміны групы В і D, ням.

910
00:44:18,240 --> 00:44:21,600
І вы ўсё яшчэ можаце атрымаць яго, відаць,
на Амазонцы, як мы рабілі тут.

911
00:44:21,600 --> 00:44:24,810
>> Але матывацыя тут была
ўвесці крыптаграфію, у прыватнасці,

912
00:44:24,810 --> 00:44:28,340
тып крыптаграфіі вядомы
у якасці сакрэтнага ключа шыфравання.

913
00:44:28,340 --> 00:44:34,284
І, як вынікае з назвы, увесь
бяспека сакрэтнага ключа сістэмы крыптаграфічнай,

914
00:44:34,284 --> 00:44:36,200
калі вы будзеце, метадалогія
для скремблирования проста

915
00:44:36,200 --> 00:44:40,960
інфармацыя паміж двума людзьмі, у тым, што
толькі адпраўнік і атрымальнік толькі

916
00:44:40,960 --> 00:44:46,980
ведаць сакрэт key-- нейкую каштоўнасць, некаторыя
ўмоўную фразу, нейкі сакрэт лік, што

917
00:44:46,980 --> 00:44:50,660
дазваляе ім як зашыфраваць
і расшыфраваць інфармацыю.

918
00:44:50,660 --> 00:44:53,470
І крыптаграфія, на самай справе,
як раз гэта ад тыдня 0.

919
00:44:53,470 --> 00:44:56,715
>> Гэта праблема, дзе ёсць ўваходы,
як рэальнае паведамленне на англійскай мове

920
00:44:56,715 --> 00:44:59,340
або любы іншы мову, які вы
хочаце паслаць камусьці ў класе,

921
00:44:59,340 --> 00:45:00,580
або праз Інтэрнэт.

922
00:45:00,580 --> 00:45:03,840
Існуе некаторы выйсце, якое збіраецца
каб быць скремблированный паведамленне, што вы

923
00:45:03,840 --> 00:45:05,250
хоча атрымальнік атрымаць.

924
00:45:05,250 --> 00:45:07,405
І нават калі нехта ў
сярэдні атрымлівае яго таксама,

925
00:45:07,405 --> 00:45:09,780
вы не хочаце, каб яны
абавязкова быць у стане расшыфраваць яго,

926
00:45:09,780 --> 00:45:12,840
таму што ўнутры гэтага
чорны скрыню, або алгарытм,

927
00:45:12,840 --> 00:45:17,650
гэта нейкі механізм, некаторыя крок за крокам
інструкцыі, для прыняцця гэтага ўваходу

928
00:45:17,650 --> 00:45:20,710
і ператварэнне яго ў
выхад, у спадзяюся бяспечным спосабам.

929
00:45:20,710 --> 00:45:23,640
>> І на самай справе, ёсць некаторыя
слоўнікавы запас у гэтым свеце наступным чынам.

930
00:45:23,640 --> 00:45:26,100
Звычайны тэкст з'яўляецца слова а
вучоны будзе

931
00:45:26,100 --> 00:45:28,449
выкарыстоўваць для апісання ўваходных
паведамленне, як на англійскай

932
00:45:28,449 --> 00:45:31,240
або любы іншы мову вы на самай справе
хочаце адправіць у нейкі іншы чалавек.

933
00:45:31,240 --> 00:45:35,450
І тады шифротекст з'яўляецца звалка
да шыфраваных або зашыфраваныя,

934
00:45:35,450 --> 00:45:36,520
яго версія.

935
00:45:36,520 --> 00:45:38,750
>> Але ёсць яшчэ адзін інгрэдыент тут.

936
00:45:38,750 --> 00:45:43,200
Там адзін іншы ўваход
Сакрэтны ключ шыфравання.

937
00:45:43,200 --> 00:45:45,200
І гэта сам ключ,
які, як правіла,

938
00:45:45,200 --> 00:45:48,930
як мы ўбачым, лік або
літара або слова, незалежна ад

939
00:45:48,930 --> 00:45:51,980
алгарытм гэта на самай справе чакае.

940
00:45:51,980 --> 00:45:53,870
>> І як вы расшыфраваць інфармацыю?

941
00:45:53,870 --> 00:45:55,110
Як вы расшыфроўваць яго?

942
00:45:55,110 --> 00:45:57,950
Ну, вы проста павярнуць назад
выхады і ўваходы.

943
00:45:57,950 --> 00:46:00,900
>> Іншымі словамі, як толькі хто-то
атрымлівае ваша зашыфраванае паведамленне,

944
00:46:00,900 --> 00:46:03,740
ён ці яна проста мае
каб ведаць, што той жа ключ.

945
00:46:03,740 --> 00:46:05,700
Яны атрымалі шифротекста.

946
00:46:05,700 --> 00:46:09,530
А падлучыўшы гэтыя два
ўваходы ў сістэму крыптаграфічнай,

947
00:46:09,530 --> 00:46:14,260
алгарытм, гэта чорны скрыню, з
павінен прыйсці зыходны адкрыты тэкст.

948
00:46:14,260 --> 00:46:17,830
І так што гэта вельмі высокі ўзровень
выгляд, што на самой справе крыптаграфія

949
00:46:17,830 --> 00:46:18,590
ўсё аб.

950
00:46:18,590 --> 00:46:20,030
>> Так што давайце там.

951
00:46:20,030 --> 00:46:22,700
Давайце зараз паглядзім пад
капот чагосьці

952
00:46:22,700 --> 00:46:26,000
мы прымалі як само сабой разумеецца для
на мінулым тыдні, і на гэтай сесіі

953
00:46:26,000 --> 00:46:27,629
here-- радок.

954
00:46:27,629 --> 00:46:30,295
Радок у канцы дня
гэта проста паслядоўнасць знакаў.

955
00:46:30,295 --> 00:46:33,610
>> Гэта можа быць прывітанне свет, або
прывітанне Zamyla, або любы іншы.

956
00:46:33,610 --> 00:46:37,050
Але што гэта значыць, што
паслядоўнасць знакаў?

957
00:46:37,050 --> 00:46:41,520
На самай справе, бібліятэка CS50 дае
нам тып дадзеных называецца радком.

958
00:46:41,520 --> 00:46:45,140
>> Але ёсць на самой справе няма
такая рэч як радок у C.

959
00:46:45,140 --> 00:46:49,450
Гэта сапраўды проста паслядоўнасць
характар, характар, характар,

960
00:46:49,450 --> 00:46:52,180
характар, спіна, да спіны, каб
назад, да спіны, каб унутр

961
00:46:52,180 --> 00:46:54,650
памяці кампутара ці АЗП.

962
00:46:54,650 --> 00:46:58,940
І мы будзем глядзець глыбей, што ў
будучыню, калі мы глядзім на саму памяць,

963
00:46:58,940 --> 00:47:02,030
і выкарыстанне, і
пагрозы, якія ўдзельнічаюць.

964
00:47:02,030 --> 00:47:04,100
>> Але давайце разгледзім радок Zamyla.

965
00:47:04,100 --> 00:47:07,480
Так што назва
чалавек тут, Zamyla,

966
00:47:07,480 --> 00:47:12,030
то ёсць паслядоўнасць
сімвалы, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
А цяпер давайце выкажам здагадку, што імя Zamyla ў
Падчас захавання ўнутры кампутара

968
00:47:16,020 --> 00:47:16,880
Праграма.

969
00:47:16,880 --> 00:47:20,830
>> Ну, само сабой зразумела, што мы павінны
быць у стане глядзець на гэтых персанажаў

970
00:47:20,830 --> 00:47:21,590
ў індывідуальным парадку.

971
00:47:21,590 --> 00:47:24,710
Так што я проста хачу, каб намаляваць трохі
рамку вакол імя Zamyla тут.

972
00:47:24,710 --> 00:47:31,580
І гэта адбываецца ў C, што, калі вы
ёсць радок, як Zamyla-- і, магчыма,

973
00:47:31,580 --> 00:47:34,940
гэты радок вярнулася з
функцыя як атрымання радкі,

974
00:47:34,940 --> 00:47:38,540
вы можаце маніпуляваць
гэта сімвал за сімвалам.

975
00:47:38,540 --> 00:47:42,070
>> Цяпер, гэта рэлевантнасці для
Размова пад рукой, таму што

976
00:47:42,070 --> 00:47:46,420
у крыптаграфіі, калі вы хочаце змяніць
А ў У, і В да С, В і С да D,

977
00:47:46,420 --> 00:47:49,650
і гэтак далей, вы павінны быць у стане
глядзець на асобныя знакі

978
00:47:49,650 --> 00:47:50,190
у радку.

979
00:47:50,190 --> 00:47:52,695
Вы павінны быць у стане змяніць
Зэт да чаго-то яшчэ, А

980
00:47:52,695 --> 00:47:55,280
да чаго-то яшчэ, каб М
нешта яшчэ, і гэтак далей.

981
00:47:55,280 --> 00:47:58,000
І таму нам патрэбен спосаб,
праграмным спосабам, так

982
00:47:58,000 --> 00:48:03,020
казаць, у C, каб мець магчымасць змяніць
і паглядзець на асобныя літары.

983
00:48:03,020 --> 00:48:05,690
І мы можам зрабіць гэта наступным чынам.

984
00:48:05,690 --> 00:48:08,340
>> Пусці галаву назад у CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
І дазвольце мне ісці наперад
і стварыць новы файл

986
00:48:11,130 --> 00:48:16,134
што я буду называць гэты раз string0,
як наш першы такі прыклад, кропка с.

987
00:48:16,134 --> 00:48:18,300
І я збіраюся ісці наперад
і ўзбіць яго наступным чынам.

988
00:48:18,300 --> 00:48:22,870
>> Так ўключаюць CS50.h, і
затым уключаюць у сябе стандартныя io.h,

989
00:48:22,870 --> 00:48:25,990
які я амаль заўсёды будзе
выкарыстоўваць у сваіх праграмах, па меншай меры,

990
00:48:25,990 --> 00:48:26,780
на пачатковым этапе.

991
00:48:26,780 --> 00:48:32,180
INT галоўную пустэчу, а затым тут я
збіраецца рабіць радкі атрымлівае атрымаць радок.

992
00:48:32,180 --> 00:48:35,260
А потым я збіраюся
ісці наперад і рабіць гэта.

993
00:48:35,260 --> 00:48:37,460
Я хачу, каб ісці наперад
і, у якасці праверкі наяўнасці свядомасці,

994
00:48:37,460 --> 00:48:43,607
проста сказаць, прывітанне, адсоткаў s,
коскі, робіць радок 0.

995
00:48:43,607 --> 00:48:44,690
Ой, што ж я зрабіў тут?

996
00:48:44,690 --> 00:48:45,930
О, я не падключыць яго.

997
00:48:45,930 --> 00:48:48,120
Так ўрок, што
ня быў наўмысным.

998
00:48:48,120 --> 00:48:52,480
>> Так памылка, больш працэнтаў
пераўтварэнні, чым аргументы дадзеных.

999
00:48:52,480 --> 00:48:54,940
І тут, у
лінія 7-- ОК, так што ў мяне ёсць,

1000
00:48:54,940 --> 00:48:56,690
цытата Unquote, гэта
мая радок PRINTF.

1001
00:48:56,690 --> 00:48:58,151
У мяне ёсць знак адсотка.

1002
00:48:58,151 --> 00:48:59,650
Але я прапускаю другі аргумент.

1003
00:48:59,650 --> 00:49:03,190
>> Я прапускаю коскі с, што
Я маю на папярэдніх прыкладах.

1004
00:49:03,190 --> 00:49:06,650
Так добрая магчымасць выправіць
яшчэ адна памылка, выпадкова.

1005
00:49:06,650 --> 00:49:09,950
А цяпер дазвольце мне бегчы
string0, тып у Zamyla.

1006
00:49:09,950 --> 00:49:10,970
Добра, прывітанне Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Такім чынам, мы запускаем гэты від праграмы
некалькі розных раз цяпер.

1008
00:49:14,144 --> 00:49:16,310
Але давайце рабіць нешта
крыху па-іншаму ў гэты раз.

1009
00:49:16,310 --> 00:49:19,450
Замест таго каб проста друк Zamyla-х
поўная назва з Printf,

1010
00:49:19,450 --> 00:49:21,350
давайце зробім гэта сімвал за сімвалам.

1011
00:49:21,350 --> 00:49:22,700
>> Я збіраюся выкарыстоўваць для цыклу.

1012
00:49:22,700 --> 00:49:26,160
І я думаю аддаць сябе
пераменная падліку, называецца I.

1013
00:49:26,160 --> 00:49:33,530
І я буду трымаць перабіраюць, так
Пакуль я менш, чым даўжыня с.

1014
00:49:33,530 --> 00:49:35,930
>> Аказваецца, мы не зрабілі
зрабіць гэта ў апошні раз,

1015
00:49:35,930 --> 00:49:39,100
што з пастаўляецца з
Функцыя называецца Стырлінга.

1016
00:49:39,100 --> 00:49:42,690
Назад у дзень, а ў цэлым
да гэтага часу пры выкананні функцыяў,

1017
00:49:42,690 --> 00:49:45,405
людзі часта выбіраюць вельмі
ёмістыя імёны, свайго роду гук

1018
00:49:45,405 --> 00:49:48,280
як тое, што вы хочаце, нават калі гэта
не хапае некалькіх галосных гукаў або літар.

1019
00:49:48,280 --> 00:49:50,660
Так Стырлінга з'яўляецца
імя функцыі, якая

1020
00:49:50,660 --> 00:49:53,880
прымае аргумент паміж
круглыя ​​дужкі, якія павінны быць радком.

1021
00:49:53,880 --> 00:49:56,910
І гэта як раз вяртае цэлы лік,
даўжыня гэтага радка.

1022
00:49:56,910 --> 00:50:00,580
>> Так што гэты цыкл на лініі 7 адбываецца
Каб пачаць зваротны адлік на я роўная 0.

1023
00:50:00,580 --> 00:50:02,530
Гэта будзе павялічвацца
я на кожнай ітэрацыі

1024
00:50:02,530 --> 00:50:04,350
на 1, як мы рабілі некалькі разоў.

1025
00:50:04,350 --> 00:50:06,780
Але гэта будзе толькі рабіць
гэта да кропкі

1026
00:50:06,780 --> 00:50:09,660
калі я даўжыня
з самой радка.

1027
00:50:09,660 --> 00:50:14,520
>> Так што гэта шлях, у канчатковым рахунку,
перабірае персанажаў

1028
00:50:14,520 --> 00:50:17,430
у радку А як след.

1029
00:50:17,430 --> 00:50:20,670
Я збіраюся раздрукаваць ня
ўвесь радок, але працэнт с,

1030
00:50:20,670 --> 00:50:22,860
адзін сімвал
а затым новай лініі.

1031
00:50:22,860 --> 00:50:24,880
А потым я збіраюся
ісці наперад, і мне трэба

1032
00:50:24,880 --> 00:50:29,080
сказаць, што я хачу надрукаваць
Ith характар ​​с.

1033
00:50:29,080 --> 00:50:33,450
>> Так што, калі я гэта зменная, якая паказвае
індэкс радкі, дзе

1034
00:50:33,450 --> 00:50:37,230
вы ў ім, мне трэба, каб мець магчымасць
кажуць, дайце мне ю характар ​​с.

1035
00:50:37,230 --> 00:50:40,390
І з мае спосаб зрабіць
гэта квадратныя дужкі.

1036
00:50:40,390 --> 00:50:43,679
Вы проста кажаце ад імя
радок, якая ў дадзеным выпадку з'яўляецца s.

1037
00:50:43,679 --> 00:50:46,970
Затым вы карыстаецеся квадратныя дужкі, якія з'яўляюцца
як правіла, крыху вышэй Return або Enter

1038
00:50:46,970 --> 00:50:48,110
клавіша на клавіятуры.

1039
00:50:48,110 --> 00:50:52,410
І тады вы паклалі індэкс
сімвал, які вы хочаце надрукаваць.

1040
00:50:52,410 --> 00:50:55,960
Такім чынам, індэкс будзе
number-- 0, або 1, або 2, або 3, або кропка,

1041
00:50:55,960 --> 00:50:57,590
кропка, кропка, некаторы іншае лік.

1042
00:50:57,590 --> 00:51:00,920
>> І мы гарантуем, што гэта будзе
быць правільны нумар, таму што я

1043
00:51:00,920 --> 00:51:02,360
пачаць адлік з 0.

1044
00:51:02,360 --> 00:51:07,020
І па змаўчанні, першы сімвал
у радку з'яўляецца канвенцыяй 0.

1045
00:51:07,020 --> 00:51:09,230
І другі персанаж кранштэйны 1.

1046
00:51:09,230 --> 00:51:11,120
І трэці персанаж кранштэйн 2.

1047
00:51:11,120 --> 00:51:13,630
І вы не хочаце ісці занадта
далёка, але мы не будзем, таму што мы

1048
00:51:13,630 --> 00:51:17,780
адбываецца не толькі прырашчэнне I да яго
роўная даўжыні радка.

1049
00:51:17,780 --> 00:51:20,210
І ў гэты момант,
гэты цыкл спыніцца.

1050
00:51:20,210 --> 00:51:25,550
>> Такім чынам, дазвольце мне ісці наперад і захаваць гэты
праграма, і запусціць зрабіць радок 0.

1051
00:51:25,550 --> 00:51:28,400
Але я аблажаўся.

1052
00:51:28,400 --> 00:51:35,390
Ўскосна абвяшчаючы функцыі бібліятэкі
Stirling з тыпам такі і such-- зараз,

1053
00:51:35,390 --> 00:51:36,430
гэта гучыць знаёма.

1054
00:51:36,430 --> 00:51:37,440
Але гэта не PRINTF.

1055
00:51:37,440 --> 00:51:38,540
І гэта не атрымаць радок.

1056
00:51:38,540 --> 00:51:40,480
>> Я не ўкруціць ў
гэтак жа, як у гэты раз.

1057
00:51:40,480 --> 00:51:45,100
Але зьвярніце ўвагу, тут трохі ўніз
акрамя таго, ўключаць string.h загалоўка,

1058
00:51:45,100 --> 00:51:47,210
відавочнай выявай даць
дэкларацыя Стэрлінга.

1059
00:51:47,210 --> 00:51:48,820
Так што на самай справе ключ там.

1060
00:51:48,820 --> 00:51:51,670
>> І на самай справе аказваецца,
ёсць яшчэ адзін файл загалоўка

1061
00:51:51,670 --> 00:51:53,970
што мы не выкарыстоўвалі
у класе ўсё ж, але гэта

1062
00:51:53,970 --> 00:51:56,480
сярод тых, даступныя
да вас, завецца string.h.

1063
00:51:56,480 --> 00:52:00,930
І ў гэтым файле, string.h
з'яўляецца Стырлінга абвешчаная.

1064
00:52:00,930 --> 00:52:05,220
Такім чынам, дазвольце мне ісці наперад і
захаваць гэта, зрабіць радок

1065
00:52:05,220 --> 00:52:08,040
0-- прыемна, ніякіх паведамленняў пра памылкі на гэты раз.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, і
Я збіраюся націснуць кнопку ўводу,

1067
00:52:12,290 --> 00:52:16,710
у які момант адбываецца GetString
каб вярнуць радок, змесціце яе ў с.

1068
00:52:16,710 --> 00:52:21,890
Тады, што цыкл будзе перабіраць
над сімвалаў S адзін у той час,

1069
00:52:21,890 --> 00:52:28,420
і друкаваць іх па адным у кожнай радку, таму што
У мяне было, што зваротнай касой п ў канцы.

1070
00:52:28,420 --> 00:52:34,530
Так што я мог бы апусціць, што зваротны слэш
п, а затым проста раздрукаваць ўсе Zamyla

1071
00:52:34,530 --> 00:52:37,460
у той жа радку,
эфектыўна пераазначэнне

1072
00:52:37,460 --> 00:52:38,999
Printf, што не ўсё, што карысна.

1073
00:52:38,999 --> 00:52:40,540
Але ў дадзеным выпадку, я не зрабіў гэтага.

1074
00:52:40,540 --> 00:52:43,610
Я на самой справе раздрукоўваюцца
характар, у той час, па адным у кожнай радку,

1075
00:52:43,610 --> 00:52:45,400
так што мы на самай справе ўбачыць эфект.

1076
00:52:45,400 --> 00:52:46,900
>> Але я павінен адзначыць адну рэч тут.

1077
00:52:46,900 --> 00:52:48,930
І мы вернемся да
гэта ў будучым тыдні.

1078
00:52:48,930 --> 00:52:52,650
Аказваецца, што гэта
код патэнцыйна глючны.

1079
00:52:52,650 --> 00:52:56,560
>> Аказваецца, што атрымаць радок
і некаторыя іншыя функцыі ў жыцці

1080
00:52:56,560 --> 00:53:00,280
не абавязкова заўсёды
вярнуць тое, што вы чакалі.

1081
00:53:00,280 --> 00:53:03,010
Мы ведаем з класа апошняга
Час у гэтым, што атрымаць

1082
00:53:03,010 --> 00:53:04,960
радок павінна вяртаць радок.

1083
00:53:04,960 --> 00:53:09,900
Але што, калі карыстальнік друкуе такія
доўгае слова або абзац, ці эсэ

1084
00:53:09,900 --> 00:53:13,010
што там проста не хапае
памяці ў кампутары, каб адпавядаць яго.

1085
00:53:13,010 --> 00:53:15,410
>> Як і тое, што калі нешта ідзе
няправільна пад капотам?

1086
00:53:15,410 --> 00:53:18,400
Гэта не можа адбыцца часта,
але гэта можа адбыцца адзін раз

1087
00:53:18,400 --> 00:53:21,520
у той час, вельмі рэдка.

1088
00:53:21,520 --> 00:53:25,460
І так атрымліваецца, што атрымаць радок
і функцыі падобныя яму не абавязкова

1089
00:53:25,460 --> 00:53:26,380
заўсёды вяртаць радка.

1090
00:53:26,380 --> 00:53:30,680
Яны могуць вяртаць некаторы значэнне памылкі,
некаторы значэнне вартавога так бы мовіць,

1091
00:53:30,680 --> 00:53:32,612
што паказвае на тое, што
нешта пайшло не так.

1092
00:53:32,612 --> 00:53:35,320
І вы б ведалі толькі гэта з
пазнаўшы яго ў класе зараз,

1093
00:53:35,320 --> 00:53:37,700
ці прачытаўшы некаторую дадатковую дакументацыю.

1094
00:53:37,700 --> 00:53:43,120
Аказваецца, што атрымаць радок
можа вяртаць значэнне, званае нулявым.

1095
00:53:43,120 --> 00:53:46,220
Null гэта асаблівая каштоўнасць, якую мы будзем
вярнуцца ў будучага тыдня.

1096
00:53:46,220 --> 00:53:50,420
Але цяпер, проста ведаю, што калі я хачу
каб быць сапраўды ўласна ў прасоўванні наперад

1097
00:53:50,420 --> 00:53:52,650
з дапамогай атрымання радкі, я
не павінны проста назваць яго,

1098
00:53:52,650 --> 00:53:56,870
і слепа выкарыстоўваць вяртаецца значэнне,
мяркуючы, што гэта радок.

1099
00:53:56,870 --> 00:53:59,420
>> Я павінен спачатку сказаць,
Эй, пачакайце хвіліну, толькі

1100
00:53:59,420 --> 00:54:03,380
дзейнічаць, калі s ня роўнае
нуль, дзе нуль, зноў жа,

1101
00:54:03,380 --> 00:54:04,660
гэта проста нейкае асаблівае значэнне.

1102
00:54:04,660 --> 00:54:07,770
І гэта адзінае спецыяльнае значэнне, якое вы
трэба турбавацца аб для атрымання радка.

1103
00:54:07,770 --> 00:54:10,900
Атрымаць радок альбо збіраецца
вяртаць радок або NULL.

1104
00:54:10,900 --> 00:54:17,219
>> І гэтая кропка клічнік роўнасці
вы маглі б ведаць, ад магчыма матэматычным класе

1105
00:54:17,219 --> 00:54:20,510
што вы маглі б намаляваць знак роўнасці з
лінія, якая праходзіць праз яго, каб паказаць, не роўныя.

1106
00:54:20,510 --> 00:54:23,135
Гэта наогул не персанаж
вы можаце набраць на клавіятуры.

1107
00:54:23,135 --> 00:54:26,480
І таму ў большасці моў праграмавання,
калі вы хочаце сказаць, не роўныя,

1108
00:54:26,480 --> 00:54:29,160
вы карыстаецеся клічнік,
інакш вядомы як выбух.

1109
00:54:29,160 --> 00:54:33,180
Дык вы кажаце, челка роўна, што
азначае не роўна, па логіцы рэчаў.

1110
00:54:33,180 --> 00:54:38,060
Гэта так жа, як там не больш
чым, ці роўнае або менш

1111
00:54:38,060 --> 00:54:41,270
або роўна клавішу на клавіятуры
што робіць усё гэта ў адным сімвале.

1112
00:54:41,270 --> 00:54:44,020
Ня дзіва, што, у мінулых прыкладах,
вы зрабілі адкрыты кранштэйны, а затым

1113
00:54:44,020 --> 00:54:48,670
знак роўнасці, для таго, каб зрабіць
больш ці, скажам, менш.

1114
00:54:48,670 --> 00:54:49,910
>> Так што вынас тут?

1115
00:54:49,910 --> 00:54:53,880
Гэта проста спосаб цяпер
ўвядзенне гэтага сінтаксісу, гэтая функцыя,

1116
00:54:53,880 --> 00:54:57,390
перабірае прыватных асоб
знакаў у радку.

1117
00:54:57,390 --> 00:55:00,260
І сапраўды гэтак жа, як тыя плошчы
кранштэйны дазваляюць атрымаць на іх,

1118
00:55:00,260 --> 00:55:03,790
разгледзець гэтыя квадратныя дужкі
выгляд намякаючы на ​​гэта асноўны

1119
00:55:03,790 --> 00:55:06,040
дызайн, у выніку чаго кожны
сімвал ўнутры радка

1120
00:55:06,040 --> 00:55:10,180
з'яўляецца свайго роду заціснуты ў дзесьці ўнізе
капот у памяці вашага кампутара.

1121
00:55:10,180 --> 00:55:12,340
>> Але давайце зробім варыянт гэтага.

1122
00:55:12,340 --> 00:55:14,880
Аказваецца, што гэта
праграма дакладная.

1123
00:55:14,880 --> 00:55:18,810
Такім чынам, на восі CS50 для ацэнкі
код, цяпер гэта правільна.

1124
00:55:18,810 --> 00:55:22,959
Асабліва цяпер, калі я праверка
нуль, гэтая праграма ніколі не павінна ўрэзацца.

1125
00:55:22,959 --> 00:55:24,500
І я проста ведаю, што з вопыту.

1126
00:55:24,500 --> 00:55:28,040
Але няма нічога, што
мы можам сапраўды пайсці не так тут.

1127
00:55:28,040 --> 00:55:31,860
Але гэта не вельмі добра прадуманыя,
таму што давайце вернемся да асноў.

1128
00:55:31,860 --> 00:55:34,450
>> Па-першае, principles--
што робіць цыкл рабіць?

1129
00:55:34,450 --> 00:55:36,290
Для цыклу робіць тры рэчы.

1130
00:55:36,290 --> 00:55:39,340
Яна ініцыялізуе некаторыя
значэнне, калі вы папытаеце яго.

1131
00:55:39,340 --> 00:55:41,770
Ён правярае стан.

1132
00:55:41,770 --> 00:55:45,380
А потым пасля кожнага
ітэрацыі, пасля кожнага цыклу,

1133
00:55:45,380 --> 00:55:49,330
ён павялічвае некаторыя
значэнне або значэння, тут.

1134
00:55:49,330 --> 00:55:50,600
>> Дык што ж гэта значыць?

1135
00:55:50,600 --> 00:55:52,940
Мы ініцыялізуючы я да 0.

1136
00:55:52,940 --> 00:55:58,610
Мы правяраем і пераканайцеся, што я менш
даўжыня з, што Z-А-М-У-Л-А,

1137
00:55:58,610 --> 00:55:59,900
так што менш 6.

1138
00:55:59,900 --> 00:56:02,590
І на самай справе, 0, як менш за 6.

1139
00:56:02,590 --> 00:56:05,580
>> Мы раздрукаваць Z ад імя Zamyla ст.

1140
00:56:05,580 --> 00:56:08,080
Тады мы павялічваем I ад 0 да 1.

1141
00:56:08,080 --> 00:56:11,290
Затым мы правяраем, 1 менш
чым даўжыня S?

1142
00:56:11,290 --> 00:56:13,270
Даўжыня S складае 6.

1143
00:56:13,270 --> 00:56:13,950
Так.

1144
00:56:13,950 --> 00:56:16,880
>> Такім чынам, мы друкуем у імя Zamyla, у ZA.

1145
00:56:16,880 --> 00:56:20,090
Мы павялічваем I ад 0, 1, да 2.

1146
00:56:20,090 --> 00:56:23,720
Затым мы правяраем, на 2 менш
даўжыня імя Zamyla ст.

1147
00:56:23,720 --> 00:56:25,380
6- так 2 складае менш за 6.

1148
00:56:25,380 --> 00:56:30,460
Так, давайце раздрукаваць прама зараз M ў
імя Zamyla, у трэці сімвал.

1149
00:56:30,460 --> 00:56:34,110
>> Ключавым момантам тут з'яўляецца тое, што на кожным
ітэрацыя гэтай гісторыі, я правяраю,

1150
00:56:34,110 --> 00:56:37,810
гэта я менш, чым даўжыня Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Але загваздка ў тым, што
Stirling не з'яўляецца уласцівасцю.

1152
00:56:40,350 --> 00:56:43,100
Тыя з вас, хто праграмаваў
да гэтага ў Java або іншых мовах

1153
00:56:43,100 --> 00:56:46,310
можа ведаць даўжыню радка з'яўляецца
ўласцівасць, толькі некаторыя толькі для чытання значэнне.

1154
00:56:46,310 --> 00:56:50,220
>> У С у гэтым выпадку, калі гэта
функцыя, якая ў літаральным сэнсе

1155
00:56:50,220 --> 00:56:53,520
падліку колькасці
сімвалы ў Zamyla кожны раз, калі

1156
00:56:53,520 --> 00:56:54,740
мы называем гэтую функцыю.

1157
00:56:54,740 --> 00:56:58,500
Кожны раз, калі вы просіце кампутар, каб выкарыстоўваць
Stirling, гэта зірнуць на Zamyla,

1158
00:56:58,500 --> 00:57:01,960
і кажучы: Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
І гэта вяртае 6.

1160
00:57:02,962 --> 00:57:04,920
У наступны раз, калі вы тэлефануеце
то ўнутры, што цыкл,

1161
00:57:04,920 --> 00:57:08,610
гэта будзе глядзець на Zamyla
зноў, скажам Z-А-М-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
І ён збіраецца вярнуцца 6.

1163
00:57:10,320 --> 00:57:12,980
Так што па-дурному пра гэты праект?

1164
00:57:12,980 --> 00:57:17,700
>> Чаму мой код не 5 з 5
для дызайну прама цяпер, так бы мовіць?

1165
00:57:17,700 --> 00:57:20,600
Ну, Я пытаюся
пытанне залішне.

1166
00:57:20,600 --> 00:57:23,030
Я раблю больш працы, чым мне трэба.

1167
00:57:23,030 --> 00:57:25,370
>> Такім чынам, нават нягледзячы на ​​тое,
адказ правільны, я

1168
00:57:25,370 --> 00:57:29,560
пытаючыся кампутар, што такое
даўжыня Zamyla зноў,

1169
00:57:29,560 --> 00:57:31,380
і зноў, і зноў, і зноў?

1170
00:57:31,380 --> 00:57:33,980
І гэты адказ
ніколі не зменіцца.

1171
00:57:33,980 --> 00:57:35,900
Гэта заўсёды будзе 6.

1172
00:57:35,900 --> 00:57:39,730
>> Такім чынам, лепшае рашэнне, чым гэта
будзе гэта наступная версія.

1173
00:57:39,730 --> 00:57:43,390
Дазвольце мне ісці наперад і пакласці яго ў
асобны файл з імем string1.c,

1174
00:57:43,390 --> 00:57:44,990
проста трымаць яго асобна.

1175
00:57:44,990 --> 00:57:47,260
І атрымліваецца, на працягу
цыкл, вы можаце на самой справе

1176
00:57:47,260 --> 00:57:50,210
аб'явіць некалькі зменных адначасова.

1177
00:57:50,210 --> 00:57:53,460
>> Так што я буду трымаць я і ўсталяваць яго ў 0.

1178
00:57:53,460 --> 00:57:56,190
Але я таксама збіраюся
дадайце коску, і сказаць,

1179
00:57:56,190 --> 00:58:01,050
дайце мне зменную п, у якога
значэнне роўна значэнню даўжыню радка с.

1180
00:58:01,050 --> 00:58:09,410
А цяпер, калі ласка, мой стан
да таго часу, як я менш п.

1181
00:58:09,410 --> 00:58:14,140
>> Такім чынам, такім чынам, логіка
ідэнтычныя ў канцы дня.

1182
00:58:14,140 --> 00:58:18,280
Але я успамінаючы
значэнне 6, у гэтым выпадку.

1183
00:58:18,280 --> 00:58:19,780
Якая даўжыня імя Zamyla ў?

1184
00:58:19,780 --> 00:58:20,860
І я стаўлю яго ў п.

1185
00:58:20,860 --> 00:58:23,050
>> І я да гэтага часу праверкі
ўмова кожны раз.

1186
00:58:23,050 --> 00:58:24,300
З'яўляецца 0 менш, чым 6?

1187
00:58:24,300 --> 00:58:25,600
1 менш, чым 6?

1188
00:58:25,600 --> 00:58:28,600
Ёсць 2 менш, чым 6, і гэтак далей?

1189
00:58:28,600 --> 00:58:31,914
>> Але я не патрабую кампутар
зноў і зноў, што

1190
00:58:31,914 --> 00:58:33,080
даўжыня імя Zamyla ў?

1191
00:58:33,080 --> 00:58:34,320
Што даўжыня імя Zamyla ў?

1192
00:58:34,320 --> 00:58:35,986
Што даўжыня імя гэтага Zamyla ў?

1193
00:58:35,986 --> 00:58:40,440
Я літаральна памятаць, што першы і
адказаць толькі ў гэтай другой зменнай п.

1194
00:58:40,440 --> 00:58:45,280
Так што гэта зараз было б не толькі
правільна, але і добра прадуманыя.

1195
00:58:45,280 --> 00:58:46,670
>> Цяпер, што тычыцца стылю?

1196
00:58:46,670 --> 00:58:48,866
Я назваў мае зменныя
вельмі добра, я б сказаў.

1197
00:58:48,866 --> 00:58:50,240
цяпер яны супер лаканічным.

1198
00:58:50,240 --> 00:58:52,090
І гэта цалкам нармальна.

1199
00:58:52,090 --> 00:58:55,120
>> Калі ў вас ёсць толькі адзін
радок у праграме,

1200
00:58:55,120 --> 00:58:56,860
Вы маглі б таксама назваць гэта S для радка.

1201
00:58:56,860 --> 00:58:59,370
Калі ў вас ёсць толькі адна зменная
для падліку у праграме,

1202
00:58:59,370 --> 00:59:00,710
Вы маглі б таксама назваць гэта я.

1203
00:59:00,710 --> 00:59:03,500
Калі ў вас ёсць даўжыня, п
супер часта, як добра.

1204
00:59:03,500 --> 00:59:05,800
Але я не заўважыў які-небудзь з майго кода.

1205
00:59:05,800 --> 00:59:09,200
>> Я не паведаміў reader--
што будзь мая TF, або TA,

1206
00:59:09,200 --> 00:59:12,460
ці проста colleague-- тое, што, як мяркуецца,
каб ісці далей у гэтай праграме.

1207
00:59:12,460 --> 00:59:15,760
І так, каб атрымаць добры стыль,
тое, што я хацеў бы зрабіць

1208
00:59:15,760 --> 00:59:24,580
гэта нешта this--
як спытаць карыстальніка для ўваходу.

1209
00:59:24,580 --> 00:59:26,670
І я мог бы перапісаць
гэта любую колькасць спосабаў.

1210
00:59:26,670 --> 00:59:35,630
>> Пераканайцеся, што S-- пераканайцеся атрымліваеш
Радок, якая вяртаецца радок.

1211
00:59:35,630 --> 00:59:40,280
А потым у here--, і гэта, магчыма,
самым важным comment-- ітэрацыя

1212
00:59:40,280 --> 00:59:44,450
над персанажамі з аднаго адначасова.

1213
00:59:44,450 --> 00:59:47,060
І я мог бы выкарыстаць любы
Выбар англійскай мовы

1214
00:59:47,060 --> 00:59:49,650
тут, каб апісаць кожны
з гэтых кавалкаў кода.

1215
00:59:49,650 --> 00:59:52,740
>> Звярніце ўвагу на тое, што я не пакідаецца
каментаваць кожную радок кода,

1216
00:59:52,740 --> 00:59:55,690
на самай справе проста на цікавы
з іх, тыя,

1217
00:59:55,690 --> 00:59:59,460
ёсць нейкі сэнс, што я мог бы
хочуць, каб зрабіць супер ясны камусьці

1218
00:59:59,460 --> 01:00:00,460
чытанне майго кода.

1219
01:00:00,460 --> 01:00:02,920
А чаму ты тэлефануеш атрымаць
радок запытвае ў карыстальніка для ўваходу?

1220
01:00:02,920 --> 01:00:05,450
Нават тое, што адзін не абавязкова
усё, што апісальны характар.

1221
01:00:05,450 --> 01:00:09,340
Але гэта дапамагае распавесці гісторыю, таму што
Другі радок у гісторыі ёсць, пераканайцеся,

1222
01:00:09,340 --> 01:00:10,740
атрымаць радкі, вернутай радок.

1223
01:00:10,740 --> 01:00:14,260
>> І трэцяя радок у гэтай гісторыі,
перабіраць знакаў у адным амі

1224
01:00:14,260 --> 01:00:15,380
ў той час.

1225
01:00:15,380 --> 01:00:17,920
А зараз проста для добрай мерай,
Я збіраюся ісці наперад і дадаць

1226
01:00:17,920 --> 01:00:24,560
яшчэ адзін каментар, які як раз
кажа друк I-й знак у с.

1227
01:00:24,560 --> 01:00:26,520
Цяпер, што я зрабіў
ў канцы дня?

1228
01:00:26,520 --> 01:00:29,190
>> Я дадаў некаторыя ангельскія
Слова ў выглядзе каментароў.

1229
01:00:29,190 --> 01:00:32,700
Сімвал касая рыса азначае, эй,
Кампутар гэта для чалавека,

1230
01:00:32,700 --> 01:00:33,820
не для вас, кампутар.

1231
01:00:33,820 --> 01:00:35,119
Такім чынам, яны ігнаруюцца лагічна.

1232
01:00:35,119 --> 01:00:35,910
Яны проста ёсць.

1233
01:00:35,910 --> 01:00:39,830
>> І сапраўды, CS50 IDE паказвае іх як
шэры, як карысныя, але не ключ

1234
01:00:39,830 --> 01:00:41,000
да праграмы.

1235
01:00:41,000 --> 01:00:42,570
Звярніце ўвагу на тое, што цяпер вы можаце зрабіць.

1236
01:00:42,570 --> 01:00:44,950
Ці ведаеце вы C
праграмавання або няма,

1237
01:00:44,950 --> 01:00:47,722
можа проста стаяць у баку ў гэтым
Праграма, і абястлушчанае каментары.

1238
01:00:47,722 --> 01:00:50,180
Папытаеце карыстальніка для ўводу, пераканайцеся,
атрымаць радкі, вернутай радок,

1239
01:00:50,180 --> 01:00:53,009
перабіраць знакаў у сек
па адным за раз, надрукаваць сімвал

1240
01:00:53,009 --> 01:00:55,550
I-й знак у S-- вы гэтага не зробіце
нават глядзець на код

1241
01:00:55,550 --> 01:00:57,270
каб зразумець, што робіць гэтая праграма.

1242
01:00:57,270 --> 01:01:00,280
І яшчэ лепш, калі вы самі глядзіце
у гэтай праграме на працягу тыдня або двух,

1243
01:01:00,280 --> 01:01:02,280
ці месяц, ці год,
вы таксама не маеце

1244
01:01:02,280 --> 01:01:04,420
глядзець на код,
спрабуючы ўспомніць,

1245
01:01:04,420 --> 01:01:06,630
што я спрабую зрабіць з гэтым кодам?

1246
01:01:06,630 --> 01:01:07,770
>> Вы сказалі сабе.

1247
01:01:07,770 --> 01:01:11,660
Вы апісалі гэта для сябе,
ці які-небудзь калега або ТАЯ, або TF.

1248
01:01:11,660 --> 01:01:14,860
І так гэта цяпер будзе
правільна, і добры дызайн,

1249
01:01:14,860 --> 01:01:18,210
і ў канчатковым рахунку, добры стыль, а таксама.

1250
01:01:18,210 --> 01:01:19,990
Так што майце гэта на ўвазе.

1251
01:01:19,990 --> 01:01:22,200
>> Так што ёсць яшчэ адна
што я збіраюся зрабіць тут

1252
01:01:22,200 --> 01:01:28,240
што зараз можа паказаць менавіта тое, што
адбываецца пад капотам.

1253
01:01:28,240 --> 01:01:30,390
Так што гэтая функцыя
у C і іншых мовах,

1254
01:01:30,390 --> 01:01:33,010
называецца тыпажоў
што альбо няяўна

1255
01:01:33,010 --> 01:01:37,250
ці відавочна дазваляе канвертаваць
ад аднаго тыпу дадзеных у іншы.

1256
01:01:37,250 --> 01:01:39,800
Мы маем справу так
далёка сёння з радкамі.

1257
01:01:39,800 --> 01:01:41,250
>> І радка знакаў.

1258
01:01:41,250 --> 01:01:44,910
Але памятайце з тыдня
0, якія сімвалы?

1259
01:01:44,910 --> 01:01:49,334
Сімвалы проста абстракцыя
на вяршыні numbers-- дзесятковых лікаў,

1260
01:01:49,334 --> 01:01:52,500
і дзесятковых лікаў сапраўды проста
абстракцыя на вяршыні двайковых лікаў,

1261
01:01:52,500 --> 01:01:53,720
як мы вызначылі яе.

1262
01:01:53,720 --> 01:01:55,540
>> Так сімвалы нумары.

1263
01:01:55,540 --> 01:01:58,410
І лічбы сімвалаў,
толькі ў залежнасці ад кантэксту.

1264
01:01:58,410 --> 01:02:01,250
І атрымліваецца, што ўнутры
кампутарнай праграмы,

1265
01:02:01,250 --> 01:02:06,830
Вы можаце паказаць, як вы хочаце выглядаць
у біты ўнутры гэтай праграмы?

1266
01:02:06,830 --> 01:02:10,400
>> Нагадаем, ад тыдня 0, што ў нас было
Ascii, што менавіта гэты код

1267
01:02:10,400 --> 01:02:11,620
адлюстраванне літар да лічбаў.

1268
01:02:11,620 --> 01:02:13,660
І мы сказалі, капітал А 65.

1269
01:02:13,660 --> 01:02:15,860
Капітал Б 66, і гэтак далей.

1270
01:02:15,860 --> 01:02:20,500
>> І заўважце, мы, па сутнасці ёсць знакі на
верхні шэраг тут, як C назаве іх,

1271
01:02:20,500 --> 01:02:23,400
сімвалаў, а затым
Інтс на другім шэрагу.

1272
01:02:23,400 --> 01:02:28,180
І атрымліваецца, вы можаце канвертаваць
бясшвовых паміж імі, як правіла.

1273
01:02:28,180 --> 01:02:30,042
І калі мы хочам зрабіць
гэта свядома, мы

1274
01:02:30,042 --> 01:02:31,750
можа спатрэбіцца для вырашэння
нешта накшталт гэтага.

1275
01:02:31,750 --> 01:02:33,590
>> Мы маглі б хацець, каб пераўтварыць
верхні рэгістр, каб панізіць

1276
01:02:33,590 --> 01:02:35,330
выпадак, ці ніжні рэгістр ў верхні рэгістр.

1277
01:02:35,330 --> 01:02:38,000
І атрымліваецца, што ёсць
на самай справе карціна тут

1278
01:02:38,000 --> 01:02:39,900
мы можам ахапіць усяго хвіліну.

1279
01:02:39,900 --> 01:02:44,120
Але давайце спачатку паглядзім на
Прыклад выканання гэтага ў відавочным выглядзе.

1280
01:02:44,120 --> 01:02:46,340
>> Я збіраюся вярнуцца ў CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Я збіраюся стварыць
файл з імем Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
І я збіраюся ісці наперад і дадаць мой
стандарт io.h у верхняй частцы, INT Асноўная пустата

1283
01:02:55,960 --> 01:02:57,370
у верхняй частцы маёй функцыі.

1284
01:02:57,370 --> 01:03:02,700
А потым я проста буду рабіць
following-- для цыклу ад я роўная,

1285
01:03:02,700 --> 01:03:04,610
скажам, 65 гадоў.

1286
01:03:04,610 --> 01:03:10,460
>> І тады я будзе менш
65, плюс 26 літар у алфавіце.

1287
01:03:10,460 --> 01:03:12,640
Так што я дам кампутар
рабіць матэматыку для мяне там.

1288
01:03:12,640 --> 01:03:15,100
А потым ўнутры гэтай завесы,
што я буду друкаваць?

1289
01:03:15,100 --> 01:03:19,230
>> % З з'яўляецца% я ўжыць зваротны слэш п.

1290
01:03:19,230 --> 01:03:21,290
А цяпер я хачу, каб падключыць два значэння.

1291
01:03:21,290 --> 01:03:24,530
Я часова паставіў пытанне
Ацэнкі там запрасіць на гэтае пытанне.

1292
01:03:24,530 --> 01:03:29,940
>> Я хачу ітэрацыю ад 65 наперад
для 26 літар алфавіту,

1293
01:03:29,940 --> 01:03:35,190
друк на кожнай ітэрацыі, што
інтэгральны эквівалент персанажа.

1294
01:03:35,190 --> 01:03:38,299
Іншымі словамі, я хачу
перабраць 26 нумароў друку

1295
01:03:38,299 --> 01:03:41,590
што Ascii сімвал, літара,
і што адпаведнае лік is--

1296
01:03:41,590 --> 01:03:44,650
на самай справе проста аднаўленне
Дыяграма з гэтага слайда.

1297
01:03:44,650 --> 01:03:47,010
Дык што ж гэтыя знакі пытання быць?

1298
01:03:47,010 --> 01:03:51,760
>> Што ж, атрымліваецца, што другі
трэба проста быць зменнай я.

1299
01:03:51,760 --> 01:03:53,860
Я хачу бачыць, што як лік.

1300
01:03:53,860 --> 01:03:58,920
А сярэдні аргумент
тут, я магу сказаць кампутара

1301
01:03:58,920 --> 01:04:03,470
для лячэння, што колькасць
я як характар, так

1302
01:04:03,470 --> 01:04:05,880
замяніць яго тут адсоткаў C.

1303
01:04:05,880 --> 01:04:07,990
>> Іншымі словамі, калі я, то
чалавек праграміст, ведаю,

1304
01:04:07,990 --> 01:04:09,865
гэта проста лічбы
ў канцы дня.

1305
01:04:09,865 --> 01:04:12,500
І я ведаю, што 65 павінен
карта ў нейкі характар.

1306
01:04:12,500 --> 01:04:15,310
З дапамогай гэтага яўнага прывядзення тыпаў,
з дужкай,

1307
01:04:15,310 --> 01:04:18,840
імя тыпу дадзеных, які вы хочаце
канвертаваць, і закрытым дужка,

1308
01:04:18,840 --> 01:04:21,200
Вы можаце сказаць
кампутар, эй, кампутар,

1309
01:04:21,200 --> 01:04:24,130
пераўтварыць гэты лік у знак.

1310
01:04:24,130 --> 01:04:26,250
>> Так што, калі я запускаю гэта
праграма пасля кампіляцыі,

1311
01:04:26,250 --> 01:04:29,740
давайце паглядзім, што я get-- зрабіць Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Чорт гэта, што я зрабіў няправільна тут?

1313
01:04:33,020 --> 01:04:35,884
Выкарыстанне незаяўленых ідэнтыфікатара,
усё ў парадку, ці ня наўмысна,

1314
01:04:35,884 --> 01:04:37,800
але давайце паглядзім, калі мы не можам
Прычына праз гэта.

1315
01:04:37,800 --> 01:04:41,220
>> Так лінія five-- так што я не атрымаў
вельмі далёка, перш чым зашрубоўвання.

1316
01:04:41,220 --> 01:04:42,140
Гэта добра.

1317
01:04:42,140 --> 01:04:46,560
Такім чынам, лінія 5 для г роўная 65-- я бачу.

1318
01:04:46,560 --> 01:04:50,130
Так што памятаеце, што ў C, у адрозненне ад некаторых
мовы, калі ў вас ёсць папярэдняе праграмаванне

1319
01:04:50,130 --> 01:04:52,190
вопыт, у вас ёсць
каб сказаць кампутара,

1320
01:04:52,190 --> 01:04:55,040
у адрозненне ад нуля, то,
тып зменнай яна.

1321
01:04:55,040 --> 01:04:56,860
>> І я забыўся ключавую фразу тут.

1322
01:04:56,860 --> 01:04:59,200
У радку пяць, я пачаў выкарыстоўваць I.

1323
01:04:59,200 --> 01:05:01,560
Але я не сказаў C
якія дадзеныя тыпу гэта.

1324
01:05:01,560 --> 01:05:04,570
Так што я збіраюся ісці сюды і
кажуць, ах, зрабіць гэта цэлы лік.

1325
01:05:04,570 --> 01:05:07,050
>> Цяпер я збіраюся ісці наперад і перакампіляваць.

1326
01:05:07,050 --> 01:05:08,080
Гэта зафіксавана, што.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, гэта свайго роду прахалодны.

1328
01:05:12,660 --> 01:05:15,360
Мала таго, што гэта супер хутка
спытаць кампутар на гэтае пытанне,

1329
01:05:15,360 --> 01:05:18,885
а не глядзець яго на слайд,
яна выдае па адным у кожнай радку, А 65,

1330
01:05:18,885 --> 01:05:24,860
B 66, ўсе шляхі down--, так як я
зрабіў гэта 26 times-- з літарамі г,

1331
01:05:24,860 --> 01:05:25,630
што складае 90.

1332
01:05:25,630 --> 01:05:27,790
І на самай справе, трохі
больш разумным будзе

1333
01:05:27,790 --> 01:05:31,030
былі для мяне не спадзявацца
на кампутары, каб дадаць 26.

1334
01:05:31,030 --> 01:05:34,060
Я мог бы проста зрабіць
90, а таксама, да таго часу,

1335
01:05:34,060 --> 01:05:37,390
як я не робяць тую ж памылку двойчы.

1336
01:05:37,390 --> 01:05:41,880
Я хачу, каб ісці праз
г, а не толькі праз у.

1337
01:05:41,880 --> 01:05:44,000
>> Так што гэта відавочнае прывядзенне.

1338
01:05:44,000 --> 01:05:47,860
Аказваецца, што гэта
нават няма неабходнасці.

1339
01:05:47,860 --> 01:05:52,480
Дазвольце мне ісці наперад і паўторна запусціць гэты
кампілятар, і перакладка Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Аказваецца, што C з'яўляецца даволі разумны.

1341
01:05:54,940 --> 01:05:57,150
>> І Printf, у прыватнасці,
даволі разумны.

1342
01:05:57,150 --> 01:06:01,260
Калі вы проста прайсці я двойчы
для абодвух запаўняльнікаў, Printf

1343
01:06:01,260 --> 01:06:04,510
зразумеюць, ой, ну я цябе ведаю
даў мне integer-- некаторы лік,

1344
01:06:04,510 --> 01:06:06,380
як 65, або 90, або любы іншы.

1345
01:06:06,380 --> 01:06:10,170
Але я бачу, што вы хочаце, каб я
фарматавання гэты лік як сімвал.

1346
01:06:10,170 --> 01:06:16,460
І таму Printf можа няяўна прыведзены
ИНТ да паўкокс для вас.

1347
01:06:16,460 --> 01:06:19,360
Так што гэта не праблема наогул.

1348
01:06:19,360 --> 01:06:23,100
>> Але зьвярніце ўвагу, з-за гэтай эквівалентнасці
мы можам на самай справе зрабіць гэта, як добра.

1349
01:06:23,100 --> 01:06:26,520
Дазвольце мне ісці наперад і зрабіць адзін
іншая версія this-- Ascii 1.C.

1350
01:06:26,520 --> 01:06:31,800
І замест таго, каб перабірае
цэлыя лікі, сапраўды можа падарваць ваш розум

1351
01:06:31,800 --> 01:06:33,610
перабірае знакаў.

1352
01:06:33,610 --> 01:06:37,660
Калі сімвал з атрымлівае капітал A, I
хочуць, каб ісці наперад і рабіць гэта,

1353
01:06:37,660 --> 01:06:41,740
да таго часу, З менш або роўна
для капіталу Z. І на кожнай ітэрацыі

1354
01:06:41,740 --> 01:06:45,690
Я хачу, каб павялічыць C, я магу
Цяпер у маім PRINTF лініі тут

1355
01:06:45,690 --> 01:06:51,320
скажам, адсоткаў З
адсоткаў я зноў, падзеленыя C.

1356
01:06:51,320 --> 01:06:57,200
>> А цяпер, я магу пайсці ў іншым накірунку,
ліццё характар ​​відавочна

1357
01:06:57,200 --> 01:06:58,500
у цэлы лік.

1358
01:06:58,500 --> 01:07:00,560
Так што, зноў жа, навошта вы гэта робіце?

1359
01:07:00,560 --> 01:07:03,830
Гэта крыху дзіўна роду
разлічваць з пункту гледжання персанажаў.

1360
01:07:03,830 --> 01:07:07,430
>> Але калі вы разумееце, што гэта
адбываецца пад капотам,

1361
01:07:07,430 --> 01:07:08,430
няма нават ніякай магіі.

1362
01:07:08,430 --> 01:07:13,060
Ты кажаш, эй, кампутар дасць
мяне пераменная называецца C тыпу паўкокс.

1363
01:07:13,060 --> 01:07:16,520
Ініцыялізаваць яго капіталу А. І
заўважыць адзінкавыя двукоссі матэрыі.

1364
01:07:16,520 --> 01:07:19,580
>> Для знакаў у C, памятаеце з
На мінулым тыдні, вы карыстаецеся адзінкавыя двукоссі.

1365
01:07:19,580 --> 01:07:23,720
Для радкоў, слоў,
фразы, вы карыстаецеся падвойныя двукоссі.

1366
01:07:23,720 --> 01:07:27,210
OK, кампутар, працягвайце рабіць гэта, так
Пакуль сімвал менш

1367
01:07:27,210 --> 01:07:28,050
або роўная г.

1368
01:07:28,050 --> 01:07:32,640
І я ведаю, што ад майго Ascii табліцы, што ўсе
з гэтых кодаў ASCII з'яўляюцца сумежнымі.

1369
01:07:32,640 --> 01:07:33,400
>> Там няма ніякіх прабелаў.

1370
01:07:33,400 --> 01:07:36,737
Так што гэта проста ад А да Z,
падзеленых адным нумарам кожнага.

1371
01:07:36,737 --> 01:07:38,820
І тады я магу павялічваць
паўкокс, калі я сапраўды хачу.

1372
01:07:38,820 --> 01:07:40,390
У рэшце рэшт,
гэта проста лік.

1373
01:07:40,390 --> 01:07:41,030
Я ведаю гэта.

1374
01:07:41,030 --> 01:07:43,670
Так што я магу толькі выказаць здагадку, каб дадаць да яго 1.

1375
01:07:43,670 --> 01:07:46,940
>> А потым на гэты раз, я друкую з,
а затым інтэгральны эквівалент.

1376
01:07:46,940 --> 01:07:50,170
І я нават не трэба відавочнае прывядзенне.

1377
01:07:50,170 --> 01:07:52,680
Я магу дазволіць Printf і таму
кампутар зразумець рэчы,

1378
01:07:52,680 --> 01:07:57,300
так што цяпер, калі я бягу
зрабіць Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Я атрымліваю сапраўды такую ​​ж рэч, як добра.

1380
01:08:01,520 --> 01:08:04,530
>> Бескарысная праграма, ня though-- ніводнага
збіраецца на самай справе напісаць праграмнае забеспячэнне

1381
01:08:04,530 --> 01:08:07,549
для таго, каб высветліць, што было
лік, якое адлюстроўваецца ў А ці У, або Z?

1382
01:08:07,549 --> 01:08:10,340
Ты проста гугліць гэта, ці
паглядзець яго ў Інтэрнэце, або паглядзець яго

1383
01:08:10,340 --> 01:08:11,650
на слайдзе, ці таму падобнае.

1384
01:08:11,650 --> 01:08:13,520
Дык дзе ж гэта на самай справе атрымаць карысна?

1385
01:08:13,520 --> 01:08:15,960
>> Ну, калі казаць пра тое, што
слайд, звярніце ўвагу, што ёсць

1386
01:08:15,960 --> 01:08:20,890
фактычная карціна тут паміж загалоўнымі літарамі
і ў ніжнім рэгістры, што не было выпадковым.

1387
01:08:20,890 --> 01:08:23,760
Звярніце ўвагу на тое, што капітал А 65.

1388
01:08:23,760 --> 01:08:25,830
Малыя а з'яўляецца 97.

1389
01:08:25,830 --> 01:08:29,649
І як далёка ніжэй выпадак а?

1390
01:08:29,649 --> 01:08:32,649
>> Такім чынам, 65 колькі крокаў ад 97?

1391
01:08:32,649 --> 01:08:36,210
Такім чынам, 97 мінус 65 роўна 32.

1392
01:08:36,210 --> 01:08:37,910
Такім чынам, капітал 65 а ёсць.

1393
01:08:37,910 --> 01:08:39,939
Пры даданні 32 да гэтага,
Вы атрымліваеце ў ніжнім рэгістры а.

1394
01:08:39,939 --> 01:08:43,729
І, што тое ж самае, калі адняць 32,
вы атрымаеце назад у сталіцу A-- ж з B

1395
01:08:43,729 --> 01:08:46,380
маленькаму б, вялікі С да мала с.

1396
01:08:46,380 --> 01:08:50,670
>> Усе гэтыя зазоры 32 адзін ад аднаго.

1397
01:08:50,670 --> 01:08:54,450
Цяпер, гэта, здавалася б, каб дазволіць нам
зрабіць нешта накшталт Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
ці Google Docs ёсць, дзе вы
Можна выбраць усе, а затым сказаць,

1399
01:08:57,729 --> 01:09:00,520
змяніць усё ў ніжнім рэгістры, або
змяніць усё ў верхні рэгістр,

1400
01:09:00,520 --> 01:09:03,840
ці змяніць толькі першае слова
прысуду да верхняга рэгістра.

1401
01:09:03,840 --> 01:09:07,390
Мы можам зрабіць нешта
як і мы самі.

1402
01:09:07,390 --> 01:09:12,645
>> Дазвольце мне ісці наперад і захаваць файл
тут называецца капіталізаваць 0.c.

1403
01:09:12,645 --> 01:09:15,770
І давайце ісці наперад і нагнятаць праграму
што робіць менавіта тое, што наступным чынам.

1404
01:09:15,770 --> 01:09:18,460
Так ўключаюць у сябе бібліятэку CS50.

1405
01:09:18,460 --> 01:09:21,430
І ўключаюць у сябе стандартныя ўваходы / выхады.

1406
01:09:21,430 --> 01:09:22,787
>> І я ведаю, што гэта ў бліжэйшы час.

1407
01:09:22,787 --> 01:09:24,870
Так што я збіраюся паставіць яго ў
там ужо, string.h,

1408
01:09:24,870 --> 01:09:26,960
таму ў мяне ёсць доступ да
такія рэчы, як Сцірлінг,

1409
01:09:26,960 --> 01:09:29,620
а затым INT галоўную пустэчу, як звычайна.

1410
01:09:29,620 --> 01:09:33,420
А потым я збіраюся ісці наперад
і рабіць радкі атрымлівае атрымаць радок,

1411
01:09:33,420 --> 01:09:35,032
проста, каб атрымаць радок ад карыстальніка.

1412
01:09:35,032 --> 01:09:36,740
А потым я збіраюся
зрабіць мой чэк стан сьвядомасьці.

1413
01:09:36,740 --> 01:09:40,510
Калі радок не роўная нуля,
то гэта бяспечна працягнуць працу.

1414
01:09:40,510 --> 01:09:42,000
І тое, што я хачу зрабіць?

1415
01:09:42,000 --> 01:09:48,700
Я збіраюся перабіраць ад я роўны 0,
і п да даўжыня радка с.

1416
01:09:48,700 --> 01:09:51,899
>> І я збіраюся зрабіць гэта да таго часу,
я менш п, і я плюс плюс.

1417
01:09:51,899 --> 01:09:55,060
Да гэтага часу, я на самой справе проста
запазычанне ідэі раней.

1418
01:09:55,060 --> 01:09:57,010
А цяпер я збіраюся ўвесці філіял.

1419
01:09:57,010 --> 01:09:59,635
>> Так што думайце зноў чухаць, дзе
мы мелі тыя развілкі,

1420
01:09:59,635 --> 01:10:05,110
а на мінулым тыдні ў C. Я збіраюся
казаць пра гэта, калі я-й знак у секундах

1421
01:10:05,110 --> 01:10:09,250
больш ці
роўна ніжнім рэгістра а,

1422
01:10:09,250 --> 01:10:13,340
и-- ў пустым месцы вы б у літаральным сэнсе
кажуць, і, але ў C вы кажаце Ампэрсанд,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- і I-й сімвал ў секундах
менш або роўны малыя г,

1424
01:10:19,830 --> 01:10:21,780
давайце зробім штосьці цікавае.

1425
01:10:21,780 --> 01:10:27,020
Давайце на самай справе раздрукаваць
характар, без пераходу на новы радок

1426
01:10:27,020 --> 01:10:31,760
то ёсць знак у радку,
I-й знак у радку.

1427
01:10:31,760 --> 01:10:37,420
>> Але давайце ісці наперад і
адняць 32 з яго.

1428
01:10:37,420 --> 01:10:42,120
Інакш, калі знак у
Радок, мы шукаем

1429
01:10:42,120 --> 01:10:45,950
не паміж Трохі
і трохі г, ісці наперад

1430
01:10:45,950 --> 01:10:48,610
і проста распячатала яго без зменаў.

1431
01:10:48,610 --> 01:10:50,840
Такім чынам, мы ўвялі
гэта абазначэнне ў квадратных дужках

1432
01:10:50,840 --> 01:10:53,560
для нашых радкоў, каб атрымаць на
I-й знак у радку.

1433
01:10:53,560 --> 01:10:57,520
>> Я дадаў некаторую ўмоўную логіку, як
Драпіны на мінулым тыдні тыдні адзін, дзе

1434
01:10:57,520 --> 01:10:59,880
Я проста выкарыстоўваю мой фундаментальны
разуменне таго, што

1435
01:10:59,880 --> 01:11:01,130
адбываецца пад капотам.

1436
01:11:01,130 --> 01:11:04,190
Ці з'яўляецца I-ы сімвал S
больш або роўна а?

1437
01:11:04,190 --> 01:11:08,290
Маўляў, гэта 97, ці 98,
ці 99, і гэтак далей?

1438
01:11:08,290 --> 01:11:11,940
>> Але гэта таксама менш або роўна
да значэння ў ніжнім рэгістры г?

1439
01:11:11,940 --> 01:11:16,210
І калі так, то што гэта значыць гэтая лінія?

1440
01:11:16,210 --> 01:11:20,250
14, гэта з'яўляецца свайго роду
парастак ўсёй ідэі,

1441
01:11:20,250 --> 01:11:23,840
загалоўнай ліст па
проста адняць 32 з яго,

1442
01:11:23,840 --> 01:11:29,370
у дадзеным выпадку, таму што я ведаю, за што
дыяграмы, як прадстаўлены мае нумары.

1443
01:11:29,370 --> 01:11:33,925
Так што давайце ісці наперад і кіраваць гэтым,
пасля кампіляцыі капіталізаваць 0.c,

1444
01:11:33,925 --> 01:11:36,210
і запусціць капіталізаваць 0.

1445
01:11:36,210 --> 01:11:40,300
>> Давайце увесці нешта накшталт
Zamyla ў ніжнім рэгістры ўводу.

1446
01:11:40,300 --> 01:11:42,780
І зараз мы маем Zamyla ў верхнім рэгістры.

1447
01:11:42,780 --> 01:11:45,050
Давайце ўвесці Роба ў ніжнім рэгістры.

1448
01:11:45,050 --> 01:11:46,674
Давайце паспрабуем Джэйсана ў ніжнім рэгістры.

1449
01:11:46,674 --> 01:11:48,590
І мы працягваем атрыманне
вымушаныя капіталізацыі.

1450
01:11:48,590 --> 01:11:50,960
Там ёсць невялікая памылка, што я
выгляд не чакаў.

1451
01:11:50,960 --> 01:11:54,050
Звярніце ўвагу на мой новы запыт асядае
на тым жа радку, іх імёны,

1452
01:11:54,050 --> 01:11:55,520
які адчувае сябе крыху брудным.

1453
01:11:55,520 --> 01:11:59,170
>> Так што я збіраюся ехаць сюды, і
на самай справе ў канцы гэтай праграмы

1454
01:11:59,170 --> 01:12:02,110
раздрукаваць сімвал новага радка.

1455
01:12:02,110 --> 01:12:03,160
Гэта ўсе.

1456
01:12:03,160 --> 01:12:06,120
З Printf, вам не трэба
перайсці ў зменных або кодзе фармату.

1457
01:12:06,120 --> 01:12:08,460
Вы можаце ў літаральным сэнсе проста раздрукаваць
нешта накшталт новага радка.

1458
01:12:08,460 --> 01:12:13,529
>> Так што давайце ісці наперад і зрабіць
капіталізаваць 0 раз, паўторна запусціць яго, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
А цяпер гэта крыху сімпотней.

1460
01:12:14,820 --> 01:12:17,274
Цяпер, мой запыт на сваёй уласнай новай лініі.

1461
01:12:17,274 --> 01:12:18,440
Так што гэта ўсё выдатна і добра.

1462
01:12:18,440 --> 01:12:19,910
Так што гэта добры прыклад.

1463
01:12:19,910 --> 01:12:22,700
Але я нават не абавязкова
неабходна жорстка закадаваць 32.

1464
01:12:22,700 --> 01:12:23,350
Вы ведаеце, што?

1465
01:12:23,350 --> 01:12:26,350
Я мог бы say-- я ніколі не
памятаеце, у чым розніца.

1466
01:12:26,350 --> 01:12:29,330
>> Але я ведаю, што калі я
маюць малой літары,

1467
01:12:29,330 --> 01:12:34,430
Я па сутнасці хачу, каб адняць ад
незалежна ад адлегласці паміж мала

1468
01:12:34,430 --> 01:12:39,160
а і вялікі А, таму што, калі я мяркую, што
ўсе астатнія літары аднолькавыя,

1469
01:12:39,160 --> 01:12:41,045
якія павінны атрымаць працу.

1470
01:12:41,045 --> 01:12:42,670
Але замест таго каб зрабіць гэта, вы ведаеце, што?

1471
01:12:42,670 --> 01:12:44,240
Там яшчэ адзін спосаб да гэтага часу.

1472
01:12:44,240 --> 01:12:48,090
>> Калі гэта капіталізаваць 1.c-- калі б я быў
каб змясціць гэта ў асобны файл.

1473
01:12:48,090 --> 01:12:51,030
давайце зробім капіталізаваць 2.C наступным чынам.

1474
01:12:51,030 --> 01:12:53,060
Я збіраюся сапраўды ачысціць гэта тут.

1475
01:12:53,060 --> 01:12:57,420
І замест таго, каб нават не маючы
ведаць ці клапаціцца пра тых нізкім узроўні

1476
01:12:57,420 --> 01:13:01,090
дэталі рэалізацыі, я замест таго, каб
толькі збіраецца надрукаваць сімвал,

1477
01:13:01,090 --> 01:13:04,610
цытата канец цытаты, адсотка C, і
затым выклікаць іншую функцыю, якая

1478
01:13:04,610 --> 01:13:09,950
існуе, што прымае аргумент,
які з'яўляецца сімвалам, як гэта.

1479
01:13:09,950 --> 01:13:12,630
>> Аказваецца, у C, ёсць
іншы выклік функцыі

1480
01:13:12,630 --> 01:13:15,550
да верхняй, якая, як яго імя
мяркуе, прымае характар

1481
01:13:15,550 --> 01:13:19,350
і робіць яго ў верхні рэгістр
эквівалент, а затым вяртае яго

1482
01:13:19,350 --> 01:13:21,410
так што Printf можаце падключыць яго там.

1483
01:13:21,410 --> 01:13:25,484
І так, каб зрабіць гэта, хоць, я
неабходна ўвесці яшчэ адзін файл.

1484
01:13:25,484 --> 01:13:28,400
Аказваецца, ёсць яшчэ адзін файл
што вы толькі ведаеце з класа,

1485
01:13:28,400 --> 01:13:33,020
або падручнік, ці інтэрнэт
спасылка, называецца C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Так што, калі я дадам, што да майго сярод загалоўка
файлы, а цяпер зноўку кампіляваць гэтую праграму,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Давайце ўвесці Zamyla за ўсё
у ніжнім рэгістры, па-ранейшаму працуе гэтак жа.

1489
01:13:46,690 --> 01:13:48,040
Але вы ведаеце, што?

1490
01:13:48,040 --> 01:13:55,590
Аказваецца, што ў верхняй
мае некаторыя іншыя функцыянальныя магчымасці.

1491
01:13:55,590 --> 01:13:58,410
>> І дазвольце мне прадставіць гэта
камандаваць усімі, накшталт няёмка

1492
01:13:58,410 --> 01:14:00,250
па імені, але чалавек для кіраўніцтва.

1493
01:14:00,250 --> 01:14:03,960
Аказваецца, што большасць кампутараў Linux,
як мы выкарыстоўваем here-- аперацыйную Linux

1494
01:14:03,960 --> 01:14:06,270
система-- ёсць каманда
называецца чалавек, які кажа,

1495
01:14:06,270 --> 01:14:08,530
эй, кампутар, дайце мне
па эксплуатацыі кампутара.

1496
01:14:08,530 --> 01:14:10,680
Што вы хочаце
шукаць у гэтым кіраўніцтве?

1497
01:14:10,680 --> 01:14:13,840
>> Я хачу паглядзець функцыю
адкрываецца верхні, Enter.

1498
01:14:13,840 --> 01:14:16,070
І гэта крыху загадкавае
чытаць часам.

1499
01:14:16,070 --> 01:14:18,780
Але зьвярніце ўвагу, што мы ў
кіраўніцтва па Linux праграміста.

1500
01:14:18,780 --> 01:14:19,530
І гэта ўвесь тэкст.

1501
01:14:19,530 --> 01:14:21,905
І заўважце, што гэта
імя функцыі тут.

1502
01:14:21,905 --> 01:14:25,030
Аказваецца, у яго ёсць стрыечны брат пад назвай
знізіць, якая робіць супрацьлеглае.

1503
01:14:25,030 --> 01:14:29,710
І заўважце пад сінопсіс, каб выкарыстоўваць гэтую функцыю
функцыянаваць старонкі чалавека, так бы мовіць,

1504
01:14:29,710 --> 01:14:32,220
кажа мне, што я
неабходна ўключыць гр type.h.

1505
01:14:32,220 --> 01:14:33,630
І я ведаў, што з практыкі.

1506
01:14:33,630 --> 01:14:36,210
>> Вось, ён паказвае мне два
прататыпы для функцыі,

1507
01:14:36,210 --> 01:14:39,070
так што калі я калі-небудзь хачу, каб выкарыстоўваць гэтую функцыю
Я ведаю, што яны прымаюць у якасці ўваходных дадзеных,

1508
01:14:39,070 --> 01:14:40,652
і тое, што яны вяртаюцца ў якасці выхаднога сігналу.

1509
01:14:40,652 --> 01:14:42,360
І потым, калі я чытаю
апісанне, я бачу

1510
01:14:42,360 --> 01:14:44,820
больш падрабязна, што функцыя робіць.

1511
01:14:44,820 --> 01:14:48,100
Але што больш важна, калі
Я гляджу пад вяртаецца значэння,

1512
01:14:48,100 --> 01:14:51,710
ён кажа, вернутае значэнне
што ператворанага лісты,

1513
01:14:51,710 --> 01:14:57,880
або З, зыходны уваходнай, калі
пераўтварэнне не ўдалося.

1514
01:14:57,880 --> 01:15:01,992
>> Іншымі словамі, верхні будзе спрабаваць
пераўтварыць ліст у верхні рэгістр.

1515
01:15:01,992 --> 01:15:03,450
І калі так, то ён збіраецца вярнуць яе.

1516
01:15:03,450 --> 01:15:07,010
Але калі ён не можа для некаторых reason--
можа быць, гэта ўжо ў верхнім рэгістры,

1517
01:15:07,010 --> 01:15:09,550
можа быць, гэта клічнік
ці якой-небудзь іншай punctuation--

1518
01:15:09,550 --> 01:15:12,200
гэта проста будзе
вярнуць зыходны C,

1519
01:15:12,200 --> 01:15:17,340
а гэта значыць, што я магу зрабіць мой код
лепш распрацаваны наступным чынам.

1520
01:15:17,340 --> 01:15:20,580
>> Мне не патрэбныя ўсе
гэтыя цыраваць радкі кода.

1521
01:15:20,580 --> 01:15:22,610
Усе радкі я
толькі вылучаны можа

1522
01:15:22,610 --> 01:15:28,700
быць згорнутыя ў толькі адзін просты
лінія, якая з'яўляецца this-- Printf адсотка

1523
01:15:28,700 --> 01:15:33,510
з да верхняга кранштэйна I S.

1524
01:15:33,510 --> 01:15:36,090
І гэта было б
прыклад лепшага дызайну.

1525
01:15:36,090 --> 01:15:40,040
>> Чаму рэалізаваць у 7 або 8 ліній
кода, якім бы ён быў я проста

1526
01:15:40,040 --> 01:15:44,960
выдалены, калі вы можаце замест таго, каб згарнуць
усё, што логіка і прыняцце рашэнняў

1527
01:15:44,960 --> 01:15:49,620
ў адну лінію, 13, што ў цяперашні час
абапіраецца на бібліятэку function--

1528
01:15:49,620 --> 01:15:53,430
функцыя, якая пастаўляецца з C, але гэта
робіць менавіта тое, што вы хочаце, каб гэта зрабіць.

1529
01:15:53,430 --> 01:15:55,295
І, шчыра кажучы, нават калі
ён не прыйшоў з C,

1530
01:15:55,295 --> 01:15:58,880
вы маглі б рэалізаваць яго самастойна, так як
мы ўжо бачылі, з Int атрымаеце адмоўны вынік

1531
01:15:58,880 --> 01:16:01,700
і атрымаць станоўчы INT на мінулым тыдні.

1532
01:16:01,700 --> 01:16:03,470
>> Гэты код у цяперашні час значна больш зручным для чытання.

1533
01:16:03,470 --> 01:16:06,670
І сапраўды, калі мы пракруткі уверх,
Паглядзіце, наколькі больш кампактны

1534
01:16:06,670 --> 01:16:08,360
гэтая версія маёй праграмы.

1535
01:16:08,360 --> 01:16:11,230
Гэта крыху грувасткай зараз,
з усімі гэтымі ўключае ў сябе.

1536
01:16:11,230 --> 01:16:14,380
Але гэта нармальна, таму што цяпер я стаю
на плечы праграмістаў

1537
01:16:14,380 --> 01:16:15,300
перада мной.

1538
01:16:15,300 --> 01:16:18,440
І хто б гэта ні быў, хто
рэалізаваны ў верхняй сапраўды

1539
01:16:18,440 --> 01:16:21,470
зрабіў мне ласку, гэтак жа, як той, хто
рэалізаваны Стырлінга сапраўды

1540
01:16:21,470 --> 01:16:24,790
зрабіў мне ласку некаторы час таму.

1541
01:16:24,790 --> 01:16:26,970
І вось цяпер у нас ёсць
лепш дызайн праграмы

1542
01:16:26,970 --> 01:16:31,680
які рэалізуе тую ж самую логіку.

1543
01:16:31,680 --> 01:16:35,580
>> Гаворачы аб Стэрлінга, хай
мне ісці наперад і рабіць гэта.

1544
01:16:35,580 --> 01:16:38,320
Дазвольце мне ісці наперад і захаваць
гэты файл у якасці stirling.c.

1545
01:16:38,320 --> 01:16:43,255
І атрымліваецца, мы можам адхіліце
адзін іншы пласт даволі проста прама цяпер.

1546
01:16:43,255 --> 01:16:45,630
Я збіраюся ісці наперад і пугу
да іншай праграмы ў галоўным

1547
01:16:45,630 --> 01:16:49,759
тут проста паўторна прылады
даўжыня радка наступным чынам.

1548
01:16:49,759 --> 01:16:52,300
Дык вось радок кода, якая
атрымлівае мяне радок ад карыстальніка.

1549
01:16:52,300 --> 01:16:53,910
Мы працягваем выкарыстоўваць гэта зноў і зноў.

1550
01:16:53,910 --> 01:16:58,900
Дазвольце мне даць сабе зменную
п тыпу Int, які захоўвае нумар.

1551
01:16:58,900 --> 01:17:02,490
>> І дазвольце мне ісці наперад і
зрабіць наступную логіку.

1552
01:17:02,490 --> 01:17:15,610
У той час як у я-й знак у S робіць
ня роўны 0 ўжыць зваротны слэш, ісці наперад

1553
01:17:15,610 --> 01:17:17,930
і прырашчэнне п.

1554
01:17:17,930 --> 01:17:23,506
І затым раздрукаваць Printf адсотка I N.

1555
01:17:23,506 --> 01:17:29,200
Я сцвярджаю, што гэтая праграма тут,
без выкліку даўжыні радка,

1556
01:17:29,200 --> 01:17:31,150
высвятляе даўжыню радка.

1557
01:17:31,150 --> 01:17:34,600
>> І магія цалкам
увасоблены ў радку 8

1558
01:17:34,600 --> 01:17:39,830
вось з чым выглядае як новы сінтаксіс,
гэта адваротны слэш 0 на адзінарныя двукоссі.

1559
01:17:39,830 --> 01:17:41,360
Але чаму?

1560
01:17:41,360 --> 01:17:44,100
Ну, падумайце, што было
адбываецца ўвесь гэты час.

1561
01:17:44,100 --> 01:17:47,990
>> І, як у бок, перш чым я забыўся, разумею,
таксама, што ў дадатак да чалавека старонак

1562
01:17:47,990 --> 01:17:50,920
якія прыходзяць з тыповым
Сістэма Linux як CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
разумець, што мы,
Персанал вядома, у ёсць таксама

1564
01:17:53,770 --> 01:17:56,030
зрабіў версію сайта
гэтай жа ідэі пад назвай

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, якая мае
усё тыя ж чалавека-старонак,

1566
01:17:59,940 --> 01:18:02,020
усё той жа
дакументацыі, а таксама

1567
01:18:02,020 --> 01:18:05,730
маленькая скрыначка у верхняй частцы, што дазваляе
канвертаваць усе з даволі

1568
01:18:05,730 --> 01:18:09,025
аркан мова ў менш камфортна
рэжым, у якім мы, выкладчыцкі склад,

1569
01:18:09,025 --> 01:18:12,150
прайшлі і паспрабаваў спрасціць
частка мовы, каб трымаць рэчы

1570
01:18:12,150 --> 01:18:14,830
сканцэнтраваны на ідэях, а не
некаторыя тонкасці.

1571
01:18:14,830 --> 01:18:20,070
Так што майце на ўвазе, reference.cs50.net
у якасці яшчэ аднаго рэсурсу, а таксама.

1572
01:18:20,070 --> 01:18:23,800
>> Але чаму даўжыня радка ў працу
як я прапанаваў некалькі хвілін таму?

1573
01:18:23,800 --> 01:18:25,160
Вось імя Zamyla зноў.

1574
01:18:25,160 --> 01:18:27,690
А вось імя Zamyla ў
заціснуты ў, як я працягваць рабіць,

1575
01:18:27,690 --> 01:18:31,360
каб намаляваць карціну яго быцця,
на самай справе, проста паслядоўнасць знакаў.

1576
01:18:31,360 --> 01:18:34,260
Але Zamyla не існуе
ў ізаляцыі ў праграме.

1577
01:18:34,260 --> 01:18:37,420
>> Калі вы пішаце і запусціць праграму,
вы карыстаецеся ваш Mac або ПК

1578
01:18:37,420 --> 01:18:40,010
як памяць, або RAM, так бы мовіць.

1579
01:18:40,010 --> 01:18:42,620
І вы можаце думаць аб
ваш кампутар як мае

1580
01:18:42,620 --> 01:18:44,730
шмат гігабайт памяці ў гэтыя дні.

1581
01:18:44,730 --> 01:18:47,700
І гіг азначае мільярды,
таму мільярды байт.

1582
01:18:47,700 --> 01:18:48,910
>> Але давайце перамотваць ў часе.

1583
01:18:48,910 --> 01:18:51,530
І выкажам здагадку, што мы выкарыстоўваем
вельмі стары кампутар,

1584
01:18:51,530 --> 01:18:55,150
мае толькі 32 байта памяці.

1585
01:18:55,150 --> 01:18:59,310
Я мог бы, на экране кампутара,
проста звярнуць на гэта наступным чынам.

1586
01:18:59,310 --> 01:19:05,240
>> Я мог бы проста сказаць, што мой
Кампутар мае ўся гэтая памяць.

1587
01:19:05,240 --> 01:19:08,830
І гэта, як палка памяці, калі
Вы памятаеце нашу карціну ў мінулы раз.

1588
01:19:08,830 --> 01:19:11,670
А калі я проста падзяліць
гэта столькі разоў,

1589
01:19:11,670 --> 01:19:15,040
Я сцвярджаю, што ў мяне ёсць 32 байта
памяці на экране.

1590
01:19:15,040 --> 01:19:18,239
>> Цяпер, на самай справе, я магу толькі
маляваць да гэтага часу на гэтым экране тут.

1591
01:19:18,239 --> 01:19:20,280
Так што я збіраюся ісці наперад,
і толькі па пагадненні,

1592
01:19:20,280 --> 01:19:24,050
маляваць памяці майго кампутара ў якасці
сеткі, а не толькі як адна прамая лінія.

1593
01:19:24,050 --> 01:19:28,190
У прыватнасці, я сцвярджаю, што ў цяперашні час
гэтая сетка, гэта 8 па 4 сеткі,

1594
01:19:28,190 --> 01:19:31,800
проста прадстаўляе ўсе 32 байта
даступнай памяці ў маім Mac,

1595
01:19:31,800 --> 01:19:33,030
ці даступныя ў маім кампутары.

1596
01:19:33,030 --> 01:19:34,780
І яны абгортачная
на дзве лініі, проста

1597
01:19:34,780 --> 01:19:38,030
так як ён падыходзіць больш на экране.

1598
01:19:38,030 --> 01:19:40,800
Але гэта першы байт.

1599
01:19:40,800 --> 01:19:41,990
Гэта другі байт.

1600
01:19:41,990 --> 01:19:43,300
Гэта трэці байт.

1601
01:19:43,300 --> 01:19:45,310
>> І гэта 32-й байт.

1602
01:19:45,310 --> 01:19:52,910
Ці, калі мы думаем, як кампутар
вучоны, гэта байт 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Так што ў вас ёсць ад 0 да 31, калі
Вы пачынаеце адлік з 0.

1604
01:19:55,950 --> 01:19:59,830
>> Так што, калі мы выкарыстоўваем праграму
што званкі атрымаць радок,

1605
01:19:59,830 --> 01:20:05,280
і мы атрымліваем радок з чалавечага
як я назваў Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
як у свеце робіць
кампутар адсочваць, які байт,

1607
01:20:09,430 --> 01:20:12,230
які кавалак памяці,
належыць какая радок?

1608
01:20:12,230 --> 01:20:16,270
Іншымі словамі, калі мы пераходзім да
увядзіце іншае імя ў кампутар,

1609
01:20:16,270 --> 01:20:19,890
як гэты Andi, называючы
атрымаць радок ў другі раз,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-я павінен скончыць у
памяць кампутара, а таксама.

1611
01:20:23,030 --> 01:20:23,850
Але якім чынам?

1612
01:20:23,850 --> 01:20:29,700
>> Што ж, атрымліваецца, што пад
капот, тое, што C робіць пры захоўванні радкоў

1613
01:20:29,700 --> 01:20:35,080
што чалавечыя тыпы ў, або што
адбываюцца з якога-небудзь іншай крыніцы, з'яўляецца яго

1614
01:20:35,080 --> 01:20:39,190
акрэслівае канец іх з
спецыяльны character-- ўжыць зваротны слэш

1615
01:20:39,190 --> 01:20:44,750
0, што гэта проста асаблівы спосаб
сказаць 80 біт запар.

1616
01:20:44,750 --> 01:20:47,950
>> Так A-- гэты лік 97 водгук.

1617
01:20:47,950 --> 01:20:51,770
Такім чынам, некаторыя мадэлі з 8 бітаў
ўяўляе дзесятковы лік 97.

1618
01:20:51,770 --> 01:20:58,070
Гэты зваротны слэш 0 літаральна лік
0, а.к.а. NUL, N-U-L, у адрозненне ад раней,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, які мы казалі.

1620
01:20:59,630 --> 01:21:05,700
Але цяпер, проста ведаю, што гэта
зваротная касая 0 усяго 80 біт запар.

1621
01:21:05,700 --> 01:21:09,810
>> І гэта як раз гэты радок у
пясок, які кажа, што нічога злева

1622
01:21:09,810 --> 01:21:12,610
належыць да адной радку ці аднаго тыпу дадзеных.

1623
01:21:12,610 --> 01:21:15,480
І нічога направа
належыць да чаго-то яшчэ.

1624
01:21:15,480 --> 01:21:17,440
найменне Andi, тым часам,
які толькі візуальна

1625
01:21:17,440 --> 01:21:21,310
здараецца, каб абгарнуць на іншай лініі,
але гэта толькі эстэтычная дэталь,

1626
01:21:21,310 --> 01:21:23,990
Аналагічным чынам завяршаецца NUL.

1627
01:21:23,990 --> 01:21:29,290
>> Гэта струна сімвалаў A-N-D-I,
плюс пяты сакрэтны характар,

1628
01:21:29,290 --> 01:21:33,560
усе 0 біты, якія проста размяжоўвае
канец імя Andi, а таксама.

1629
01:21:33,560 --> 01:21:37,120
І калі мы называем атрымаць радок у трэці раз
ў кампутары, каб атрымаць радок выгляду

1630
01:21:37,120 --> 01:21:44,210
Марыя, М-А-Р-I-А, гэтак жа з'яўляецца Марыі
Імя NUL завяршаецца з зваротнай касой рысай 0.

1631
01:21:44,210 --> 01:21:47,170
>> Гэта прынцыпова адрозніваецца
ад таго, як кампутар, як правіла,

1632
01:21:47,170 --> 01:21:51,850
захоўваць цэлы лік або лік з якая плавае кропкай, ці іншы
тыпы дадзеных да гэтага часу, таму што ўспомніць,

1633
01:21:51,850 --> 01:21:57,420
цэлы лік, як правіла, 32 біта, або
4 байта, ці магчыма нават 64 біта,

1634
01:21:57,420 --> 01:21:59,100
ці восем байт.

1635
01:21:59,100 --> 01:22:02,620
Але многія прымітывы ў кампутары
на мове праграмавання

1636
01:22:02,620 --> 01:22:05,550
маюць фіксаваны лік
байт пад hood--

1637
01:22:05,550 --> 01:22:08,100
можа быць 1, 2, можа быць, можа быць 4, можа быць 8.

1638
01:22:08,100 --> 01:22:13,250
>> Але радкі, па дызайне, маюць
дынамічнае колькасць знакаў.

1639
01:22:13,250 --> 01:22:16,980
Вы ніколі не ведаеце загадзя, да таго часу,
чалавечыя тыпы ў Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
або М-А-Р-І-А ці А-Н-Д-І. Вы не ведаеце,
колькі разоў карыстальнік збіраецца стукнуць

1641
01:22:21,400 --> 01:22:22,070
клавіятура.

1642
01:22:22,070 --> 01:22:26,490
Такім чынам, вы не ведаеце, як
шмат знакаў у загадзя

1643
01:22:26,490 --> 01:22:27,540
вы будзеце мець патрэбу.

1644
01:22:27,540 --> 01:22:31,840
>> І так С проста выгляд лісця, як у
сакрэт дробка пад капотам

1645
01:22:31,840 --> 01:22:32,960
у канцы радка.

1646
01:22:32,960 --> 01:22:39,280
Пасля захоўвання Z-А-М-Y-L-A ў памяці,
ён таксама проста ставіць эквівалент

1647
01:22:39,280 --> 01:22:40,210
на працягу перыяду.

1648
01:22:40,210 --> 01:22:45,060
У канцы прапановы,
ён змяшчае 80 біт, такім чынам,

1649
01:22:45,060 --> 01:22:49,120
каб успомніць, дзе
Zamyla пачынаецца і заканчваецца.

1650
01:22:49,120 --> 01:22:51,490
>> Так што сувязь,
Затым, да гэтай праграме?

1651
01:22:51,490 --> 01:22:55,190
Гэтая праграма тут, Стырлінга,
гэта проста механізм

1652
01:22:55,190 --> 01:22:57,970
для атрымання радкі
ад карыстальніка, радок 6.

1653
01:22:57,970 --> 01:23:01,160
Радок 7, я абвясціць зменную
называецца п і ўсталюйце яго роўным 0.

1654
01:23:01,160 --> 01:23:08,680
>> А потым у радку 8, я проста спытаў
пытанне, у той час як у я-й сімвал робіць

1655
01:23:08,680 --> 01:23:12,120
не роўныя 0 ўсё bits--
іншымі словамі, не робіць

1656
01:23:12,120 --> 01:23:14,500
роўна гэты спецыяльны
сімвал, зваротная касая 0,

1657
01:23:14,500 --> 01:23:18,470
быў толькі што адмысловы NUL character--
ісці наперад і проста павялічваць п.

1658
01:23:18,470 --> 01:23:21,460
>> І працягваць рабіць гэта, і трымаць
робячы гэта, і працягваць рабіць гэта.

1659
01:23:21,460 --> 01:23:23,430
І таму, нават калі ў
мінулае мы выкарыстоўвалі I,

1660
01:23:23,430 --> 01:23:25,181
гэта выдатна
семантычна выкарыстоўваць п,

1661
01:23:25,181 --> 01:23:27,430
калі вы проста спрабуеце
разлічваць на гэты раз свядома,

1662
01:23:27,430 --> 01:23:28,720
і проста хочаце назваць гэта н.

1663
01:23:28,720 --> 01:23:34,720
Так што гэта проста працягвае задаваць пытанне,
з'яўляецца н-ы сімвал з усё 0s?

1664
01:23:34,720 --> 01:23:38,470
Калі няма, паглядзіце на наступны выгляд,
паглядзіце на наступны, паглядзіце на наступны,

1665
01:23:38,470 --> 01:23:39,460
паглядзіце на наступны.

1666
01:23:39,460 --> 01:23:45,540
>> Але як толькі вы бачыце зваротную касую 0,
гэта loop-- лінія 9 праз 11-- спыняецца.

1667
01:23:45,540 --> 01:23:49,640
Вы вырвацца з цыклу ў той час,
пакідаючы ўнутры гэтай зменнай п

1668
01:23:49,640 --> 01:23:54,530
у агульнай складанасці колькасць ўсіх з
знакаў у радку, якую вы бачылі,

1669
01:23:54,530 --> 01:23:55,660
такім чынам, вывадзе на друк.

1670
01:23:55,660 --> 01:23:56,760
Дык давайце паспрабуем гэта.

1671
01:23:56,760 --> 01:23:59,500
>> Дазвольце мне ісці наперад і без
з дапамогай функцыі Стырлінга,

1672
01:23:59,500 --> 01:24:04,240
а проста выкарыстоўваючы сваю ўласную версію дамарослыя
тут называецца Стырлінга, дазвольце мне ісці наперад

1673
01:24:04,240 --> 01:24:07,700
і запусціць Стырлінга, тыпу ў чымсьці
як Zamyla, які я ведаю загадзя

1674
01:24:07,700 --> 01:24:08,670
складае шэсць знакаў.

1675
01:24:08,670 --> 01:24:10,080
Давайце паглядзім, ці працуе ён.

1676
01:24:10,080 --> 01:24:10,920
На самай справе, гэта шэсць.

1677
01:24:10,920 --> 01:24:15,257
Давайце паспрабуем з Робом, тры сімвала,
тры сімвала, а таксама, і гэтак далей.

1678
01:24:15,257 --> 01:24:17,340
Так што ўсё, што адбываецца
на пад капотам.

1679
01:24:17,340 --> 01:24:19,548
І да вашага ведама, злучэння,
затым, пачынаючы з першага тыдня

1680
01:24:19,548 --> 01:24:22,370
класа, дзе мы гаварылі пра
нешта накшталт абстракцыі,

1681
01:24:22,370 --> 01:24:26,960
што менавіта гэта напластаванне ідэй, або
складанасць, на вяршыні асноўных прынцыпаў.

1682
01:24:26,960 --> 01:24:30,710
Тут мы накшталт глядзець
пад капотам Стэрлінга,

1683
01:24:30,710 --> 01:24:33,510
так бы мовіць, каб высветліць,
як бы гэта рэалізаваць?

1684
01:24:33,510 --> 01:24:35,232
>> І мы маглі б паўторна рэалізаваць яго самі.

1685
01:24:35,232 --> 01:24:37,440
Але мы ніколі зноў збіраецца
паўторна рэалізаваць Стырлінга.

1686
01:24:37,440 --> 01:24:39,780
Мы проста збіраемся
выкарыстоўваць Стырлінга ў парадку

1687
01:24:39,780 --> 01:24:42,100
на самой справе атрымаць некаторыя радкі даўжыні.

1688
01:24:42,100 --> 01:24:44,200
>> Але няма ніякай магіі
пад капотам.

1689
01:24:44,200 --> 01:24:46,716
Калі вы ведаеце, што пад
капот, радок

1690
01:24:46,716 --> 01:24:48,090
гэта проста паслядоўнасць знакаў.

1691
01:24:48,090 --> 01:24:51,090
І гэта паслядоўнасць знакаў
усе яны могуць быць колькасна разгледжаны

1692
01:24:51,090 --> 01:24:53,330
з кранштэйнам 0, кранштэйны
1, кранштэйн 2, і вы

1693
01:24:53,330 --> 01:24:57,420
вядома, што ў канцы радка з'яўляецца
спецыяльны сімвал, вы можаце высветліць,

1694
01:24:57,420 --> 01:25:01,710
як зрабіць большасць нічога ў
Праграма, таму што ўсё гэта зводзіцца да таго,

1695
01:25:01,710 --> 01:25:03,400
чытае і піша памяць.

1696
01:25:03,400 --> 01:25:06,130
Гэта значыць, мяняецца і шукае
ў памяці, або перасоўванне рэчаў

1697
01:25:06,130 --> 01:25:10,940
вакол у памяці, друкаваныя рэчы
на экране, і гэтак далей.

1698
01:25:10,940 --> 01:25:14,800
>> Так давайце цяпер выкарыстоўваць гэтую зноў здабытую
разуменне таго, якія радкі на самай справе

1699
01:25:14,800 --> 01:25:17,910
знаходзяцца пад капотам, і
адхіліце адзін іншы пласт

1700
01:25:17,910 --> 01:25:20,080
што да гэтага часу мы
ігнараваў ў цэлым.

1701
01:25:20,080 --> 01:25:22,650
У прыватнасці, любы час
мы рэалізавалі праграму,

1702
01:25:22,650 --> 01:25:25,930
мы мелі гэты радок кода
паблізу верхняй абвяшчаючы галоўнай.

1703
01:25:25,930 --> 01:25:27,810
І мы паказалі INT галоўную пустэчу.

1704
01:25:27,810 --> 01:25:31,240
>> І гэтая пустата ўнутры дужак
казаў ўвесь гэты час, што асноўная

1705
01:25:31,240 --> 01:25:33,440
сама па сабе не прымае якіх-небудзь аргументаў.

1706
01:25:33,440 --> 01:25:36,210
Любы ўклад, што галоўнае,
збіраецца атрымаць ад карыстальніка

1707
01:25:36,210 --> 01:25:39,020
павінна зыходзіць ад нейкай іншай
механізм, як Get INT,

1708
01:25:39,020 --> 01:25:42,040
або атрымаць з якая плавае кропкай, ці атрымаць радок,
ці якой-небудзь іншай функцыі.

1709
01:25:42,040 --> 01:25:44,710
Але аказваецца, што
калі вы пішаце праграму,

1710
01:25:44,710 --> 01:25:47,690
вы можаце паказаць
што гэтая праграма павінна

1711
01:25:47,690 --> 01:25:51,730
прымаюць ўваходныя сігналы ад чалавека
у самой камандным радку.

1712
01:25:51,730 --> 01:25:56,310
>> Іншымі словамі, нават калі мы да гэтага часу
былі працуе толькі ./hello прывітанне

1713
01:25:56,310 --> 01:26:00,312
ці падобныя праграмы, усе
іншыя праграмы, якія мы выкарыстоўвалі,

1714
01:26:00,312 --> 01:26:02,770
што мы самі не пісалі,
прымалі, па-відаць,

1715
01:26:02,770 --> 01:26:05,210
каманднага радка arguments--
такія рэчы, як зрабіць.

1716
01:26:05,210 --> 01:26:07,450
Вы кажаце, што нешта накшталт марка,
а затым другое слова.

1717
01:26:07,450 --> 01:26:10,950
Або ляск, вы кажаце ляск, а затым
другое слова, імя файла.

1718
01:26:10,950 --> 01:26:14,410
>> Ці нават RM або СР, як можна было б
бачылі ці выкарыстоўваць ужо

1719
01:26:14,410 --> 01:26:15,880
выдаляць або капіяваць файлы.

1720
01:26:15,880 --> 01:26:18,920
Усе тыя прымаюць так званыя
каманднага радка arguments--

1721
01:26:18,920 --> 01:26:21,130
дадатковыя слова ў радку тэрмінала.

1722
01:26:21,130 --> 01:26:23,260
Але да гэтага часу, мы
самі не мелі

1723
01:26:23,260 --> 01:26:27,080
Гэты шыкоўны прымаць ўваходны сігнал ад
карыстальніка, калі ён ці яна на самай справе працуе

1724
01:26:27,080 --> 01:26:29,120
сама праграма ў камандным радку.

1725
01:26:29,120 --> 01:26:33,710
>> Але мы можам зрабіць гэта шляхам паўторнага дэкларавання
Асноўны рухацца наперад, а не як якія маюць

1726
01:26:33,710 --> 01:26:36,750
несапраўдным у дужках,
але гэтыя два аргументу

1727
01:26:36,750 --> 01:26:40,600
instead-- першае цэлы лік,
а другі нешта

1728
01:26:40,600 --> 01:26:44,170
новае, тое, што мы будзем называць
масіў, нешта падобнае ў духу

1729
01:26:44,170 --> 01:26:49,220
да таго, што мы бачылі ў пустым выглядзе спісу, але
масіў радкоў, як мы хутка ўбачым.

1730
01:26:49,220 --> 01:26:51,790
Але давайце паглядзім на гэта
У якасці прыкладу, перш чым мы

1731
01:26:51,790 --> 01:26:53,690
адрозніваюць менавіта тое, што гэта значыць.

1732
01:26:53,690 --> 01:26:56,520
>> Так што, калі я іду ў CS50 IDE
тут, я пайшоў наперад

1733
01:26:56,520 --> 01:27:01,840
і абвешчаны ў файле з імем
argv0.c наступны шаблон.

1734
01:27:01,840 --> 01:27:04,120
І заўважце, адзінае,
што па-іншаму да гэтага часу

1735
01:27:04,120 --> 01:27:08,570
з'яўляецца тое, што я змяніў нікчэмным Int
ARGC радок ARGV адкрыты кранштэйны, блізка

1736
01:27:08,570 --> 01:27:09,070
кранштэйн.

1737
01:27:09,070 --> 01:27:11,730
І звярніце ўвагу на дадзены момант, ёсць
нічога не ўнутры гэтых дужак.

1738
01:27:11,730 --> 01:27:12,620
>> Там няма ліку.

1739
01:27:12,620 --> 01:27:15,070
І няма я, або
N, або любое іншае ліст.

1740
01:27:15,070 --> 01:27:17,010
Я проста з дапамогай
квадратныя дужкі на дадзены момант,

1741
01:27:17,010 --> 01:27:19,510
па прычынах, мы прыедзем
назад у імгненне.

1742
01:27:19,510 --> 01:27:21,330
>> А цяпер, што я збіраюся зрабіць гэта.

1743
01:27:21,330 --> 01:27:26,680
Калі ARGC роўны роўны 2--
і нагадаем, што складае роўных

1744
01:27:26,680 --> 01:27:30,040
з'яўляецца аператарам параўнання роўнасці
левы і правы для роўнасці.

1745
01:27:30,040 --> 01:27:31,790
Гэта не саступка
аператар, які

1746
01:27:31,790 --> 01:27:36,510
адзіны знак роўнасці, што азначае копію
ад справа налева нейкае значэнне.

1747
01:27:36,510 --> 01:27:42,840
>> Калі ARGC роўны роўны 2, я хачу
скажам, Printf, прывітанне, працэнты, новая лінія,

1748
01:27:42,840 --> 01:27:47,340
а затым падлучыць in-- і вось новы
trick-- ARGV кранштэйны 1, па прычынах

1749
01:27:47,340 --> 01:27:48,840
што мы вернемся ў хвіліну.

1750
01:27:48,840 --> 01:27:52,110
Інакш, калі ARGC ня
роўна 2, вы ведаеце, што?

1751
01:27:52,110 --> 01:27:57,400
Давайце проста ісці наперад і, як звычайна, друк
па-за прывітанне свет, без замены.

1752
01:27:57,400 --> 01:28:02,710
>> Так што, здавалася б, што калі ARGC, які
выступае за колькасцю аргументаў, раўняецца 2,

1753
01:28:02,710 --> 01:28:04,740
Я збіраюся раздрукаваць
прывітанне што-небудзь ці іншае.

1754
01:28:04,740 --> 01:28:07,560
У адваротным выпадку, па змаўчанні, я
збіраецца надрукаваць прывітанне свет.

1755
01:28:07,560 --> 01:28:08,770
Дык што ж гэта азначае?

1756
01:28:08,770 --> 01:28:15,550
>> Што ж, дазвольце мне ісці наперад і захаваць
гэты файл, а затым робяць argv0,

1757
01:28:15,550 --> 01:28:18,940
а затым ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
І гэта кажа прывітанне свет.

1759
01:28:20,300 --> 01:28:21,260
Цяпер, чаму гэта?

1760
01:28:21,260 --> 01:28:24,730
>> Што ж, атрымліваецца, у любы час вы
запусціць праграму ў камандным радку,

1761
01:28:24,730 --> 01:28:29,570
вы запаўняеце у тым, што мы будзем
звычайна называем вектар аргументаў.

1762
01:28:29,570 --> 01:28:33,100
Іншымі словамі, аўтаматычна
кампутар, аперацыйная сістэма,

1763
01:28:33,100 --> 01:28:38,340
збіраецца перадаць вашай праграме
Сам спіс усіх слоў

1764
01:28:38,340 --> 01:28:40,850
што чалавек набраў на
падказка, у выпадку, калі

1765
01:28:40,850 --> 01:28:43,790
праграміст хоча зрабіць
нешта з гэтай інфармацыяй.

1766
01:28:43,790 --> 01:28:48,540
І ў гэтым выпадку адзінае слова,
Я набраў у радку з'яўляецца ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> І таму лік аргументаў, з'яўляецца
перадаецца ў маёй праграме толькі адзін.

1768
01:28:55,420 --> 01:28:58,880
Іншымі словамі, аргумент
разлічваць, інакш вядомы як ARGC

1769
01:28:58,880 --> 01:29:00,970
тут як цэлы лік, гэта толькі адзін.

1770
01:29:00,970 --> 01:29:03,000
Адзін з іх, вядома, не роўна двум.

1771
01:29:03,000 --> 01:29:05,980
І так гэта тое, што друкуе, прывітанне свет.

1772
01:29:05,980 --> 01:29:08,170
>> Але дазвольце мне ўзяць гэта недзе.

1773
01:29:08,170 --> 01:29:09,930
Дазвольце мне сказаць, argv0.

1774
01:29:09,930 --> 01:29:12,740
А потым, як пра Марыю?

1775
01:29:12,740 --> 01:29:14,990
А затым націсніце клавішу Enter.

1776
01:29:14,990 --> 01:29:18,020
>> І да вашага ведама, што чароўным чынам тут адбываецца.

1777
01:29:18,020 --> 01:29:22,640
Цяпер, замест прывітанне свет, у мяне ёсць
змяніў паводзіны гэтай праграмы

1778
01:29:22,640 --> 01:29:26,310
прымаючы ўваход не ад Get
радок або якой-небудзь іншай функцыі,

1779
01:29:26,310 --> 01:29:30,570
але з, па-відаць, мая каманда
Сам, што я першапачаткова надрукаваў.

1780
01:29:30,570 --> 01:29:35,720
І я магу гуляць у гэтую гульню зноў
змяняючы яго Стелиос, напрыклад.

1781
01:29:35,720 --> 01:29:38,400
>> А цяпер я бачу іншае імя да гэтага часу.

1782
01:29:38,400 --> 01:29:40,540
І тут, я мог бы сказаць, Анди.

1783
01:29:40,540 --> 01:29:42,137
І я мог бы сказаць Zamyla.

1784
01:29:42,137 --> 01:29:45,220
І мы можам гуляць у гэтую гульню на працягу ўсяго дня,
проста затыкаць ў розных значэннях,

1785
01:29:45,220 --> 01:29:49,550
да таго часу, як я даць менавіта
два словы ў камандным радку

1786
01:29:49,550 --> 01:29:52,260
такім чынам, што ARGC, граф мой аргумент, 2.

1787
01:29:52,260 --> 01:29:57,240
>> Бачу я, што імя падлучаны да
Printf, у гэтым стане тут?

1788
01:29:57,240 --> 01:30:00,550
Такім чынам, мы, здаецца, у цяперашні час
выразны патэнцыял

1789
01:30:00,550 --> 01:30:04,410
прымаць ўваходны сігнал ад іншага механізму,
ад так званай каманднага радка,

1790
01:30:04,410 --> 01:30:07,000
замест таго, каб чакаць
да таго часу, пакуль карыстач не запускае праграму,

1791
01:30:07,000 --> 01:30:10,220
а затым заахвоціць яго ці яе
выкарыстоўваючы нешта накшталт атрымання радка.

1792
01:30:10,220 --> 01:30:11,230
>> Дык што ж гэта?

1793
01:30:11,230 --> 01:30:15,010
ARGC, зноў жа, гэта ўсяго толькі цэлы лік,
колькасць words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
што карыстач пры ўмове, на
падкажыце, у акне тэрмінала,

1795
01:30:18,540 --> 01:30:20,110
у тым ліку назва праграмы.

1796
01:30:20,110 --> 01:30:23,340
Такім чынам, наша ./argv0 з'яўляецца, па сутнасці,
назва праграмы,

1797
01:30:23,340 --> 01:30:24,520
ці як я запусціць праграму.

1798
01:30:24,520 --> 01:30:25,810
>> Гэта лічыцца як слова.

1799
01:30:25,810 --> 01:30:27,080
Так ARGC будзе 1.

1800
01:30:27,080 --> 01:30:29,750
Але калі я пішу Стелиос, або
Andi або Zamyla, або Марыя,

1801
01:30:29,750 --> 01:30:31,660
гэта азначае, што колькасць аргументаў роўна двум.

1802
01:30:31,660 --> 01:30:33,910
І вось зараз ёсць два словы, якія перадаюцца ст.

1803
01:30:33,910 --> 01:30:36,070
>> І заўважце, мы можам працягнуць гэтую логіку.

1804
01:30:36,070 --> 01:30:39,050
Калі б я на самой справе сказаць
нешта накшталт Zamyla Чан,

1805
01:30:39,050 --> 01:30:42,200
поўнае імя, тым самым перадаўшы
тры аргументу ў агульнай складанасці,

1806
01:30:42,200 --> 01:30:47,410
Цяпер ён зноў гаворыць па змаўчанні,
таму што, вядома ж, 3. ня роўна 2.

1807
01:30:47,410 --> 01:30:54,080
>> І вось такім чынам, у мяне ёсць
доступ праз ARGV гэты новы аргумент

1808
01:30:54,080 --> 01:30:56,080
што мы маглі б тэхнічна
называць усё, што заўгодна.

1809
01:30:56,080 --> 01:30:58,940
Але ў адпаведнасці з пагадненнем, гэта
ARGV і ARGC адпаведна.

1810
01:30:58,940 --> 01:31:04,470
ARGV, вектар аргументаў, з'яўляецца свайго роду
сіноніма для праграмавання

1811
01:31:04,470 --> 01:31:07,140
функцыя ў C называецца масіў.

1812
01:31:07,140 --> 01:31:14,410
>> Масіў ўяўляе спіс значэнняў аналагічных
назад, да спіны, да спіны, да спіны.

1813
01:31:14,410 --> 01:31:17,810
Іншымі словамі, калі хтосьці тут, у
RAM, наступны прама побач з ім,

1814
01:31:17,810 --> 01:31:18,800
і побач з ім.

1815
01:31:18,800 --> 01:31:20,101
Яны не паўсюль.

1816
01:31:20,101 --> 01:31:23,100
І гэта апошні сцэнар, дзе рэчы
знаходзяцца паўсюль у памяці,

1817
01:31:23,100 --> 01:31:25,082
можа быць на самой справе магутная функцыя.

1818
01:31:25,082 --> 01:31:28,040
Але мы вернемся да таго, што, калі мы
казаць аб мудрагелістых структур дадзеных.

1819
01:31:28,040 --> 01:31:32,260
На дадзены момант, масіў проста
кавалак бесперапыннай памяці,

1820
01:31:32,260 --> 01:31:36,520
кожны з якіх элементы
назад, да спіны, да спіны, да спіны,

1821
01:31:36,520 --> 01:31:38,050
і, як правіла той жа самы тып.

1822
01:31:38,050 --> 01:31:42,630
>> Так што калі вы думаеце пра тое, ад А
хвіліну назад, што такое радок?

1823
01:31:42,630 --> 01:31:50,460
Ну, радок, як Zamyla,
Z-А-М-У-Л-А, гэта, тэхнічна,

1824
01:31:50,460 --> 01:31:51,400
проста масіў.

1825
01:31:51,400 --> 01:31:53,700
Гэта масіў знакаў.

1826
01:31:53,700 --> 01:31:59,250
>> І таму, калі мы сапраўды зрабіць гэта, як я
зрабіў раней, як кавалак памяці,

1827
01:31:59,250 --> 01:32:04,510
атрымліваецца, што кожны з іх
сімвалаў займае байт.

1828
01:32:04,510 --> 01:32:07,630
А тут што асаблівая
вартавога сімвал, зваротная касая 0,

1829
01:32:07,630 --> 01:32:12,360
ці ўсе восем біт 0, што
размяжоўвае канец гэтага радка.

1830
01:32:12,360 --> 01:32:15,090
Так радок, атрымліваецца
па-за, цытуюць Unquote радок,

1831
01:32:15,090 --> 01:32:20,580
гэта проста масіў chara--
асмальваецца быўшы фактычным тыпам дадзеных.

1832
01:32:20,580 --> 01:32:24,560
>> А цяпер ARGV, meanwhile--
давайце вернемся да праграмы.

1833
01:32:24,560 --> 01:32:29,582
ARGV, хоць мы бачым, слова
Радок тут, не з'яўляецца сама радок.

1834
01:32:29,582 --> 01:32:33,640
ARGV, вектар аргументаў,
ўяўляе сабой масіў радкоў.

1835
01:32:33,640 --> 01:32:37,620
>> Гэтак жа, як вы можаце мець масіў
сімвалаў, вы можаце мець больш высокі ўзровень,

1836
01:32:37,620 --> 01:32:46,279
масіў strings-- так, напрыклад,
калі я набраў хвіліну назад ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, прастору Z-A-M-Y-L-A, я сцвярджаў, што
ARGV меў два радкі ў it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
і Z-A-M-Y-L-A. ў
Іншымі словамі, ARGC было 2.

1839
01:33:03,185 --> 01:33:03,980
Чаму гэта?

1840
01:33:03,980 --> 01:33:08,370
>> Ну, па сутнасці, тое, што адбываецца
на тым, што кожная з гэтых радкоў

1841
01:33:08,370 --> 01:33:13,990
гэта, вядома, масіў сімвалаў
як і раней, кожны з якіх персанажы

1842
01:33:13,990 --> 01:33:15,670
займае адзін байт.

1843
01:33:15,670 --> 01:33:19,720
І не блытайце фактычную 0
у назве праграмы з 0,

1844
01:33:19,720 --> 01:33:22,040
што азначае ўсе 80 біт.

1845
01:33:22,040 --> 01:33:27,140
І Zamyla, тым часам, па-ранейшаму
таксама масіў знакаў.

1846
01:33:27,140 --> 01:33:31,450
>> Такім чынам, у рэшце рэшт, гэта на самай справе
выглядае наступным чынам пад капотам.

1847
01:33:31,450 --> 01:33:38,800
Але ARGV, па сваёй прыродзе, як галоўны
працы, дазваляе мне абгарнуць усё гэта

1848
01:33:38,800 --> 01:33:44,810
да ў, калі вы будзеце, большы масіў
што, калі мы крыху больш спрасціць

1849
01:33:44,810 --> 01:33:48,180
што карціна выглядае і ня
дастаткова намаляваць яе ў маштабе там,

1850
01:33:48,180 --> 01:33:56,720
Гэты масіў з'яўляецца толькі памерам 2, першы
элемент якога змяшчае радок,

1851
01:33:56,720 --> 01:33:59,230
другі элемент
якая змяшчае радок.

1852
01:33:59,230 --> 01:34:01,687
І, у сваю чаргу, калі вы
выгляд павелічэння на кожным

1853
01:34:01,687 --> 01:34:03,770
з гэтых радкоў, што вы
гл пад капотам

1854
01:34:03,770 --> 01:34:07,190
з'яўляецца тое, што кожны радок проста
масіў знакаў.

1855
01:34:07,190 --> 01:34:11,680
>> Цяпер, гэтак жа, як са радкамі,
мы былі ў стане атрымаць доступ

1856
01:34:11,680 --> 01:34:15,260
да сп-га знака ў радку
з дапамогай гэтай квадратнай дужкі абазначэння.

1857
01:34:15,260 --> 01:34:17,320
Сапраўды гэтак жа, з масівамі
увогуле, мы можам

1858
01:34:17,320 --> 01:34:22,700
выкарыстоўваць квадратныя дужкі, абазначэння, каб атрымаць
на любую колькасць радкоў у масіве?

1859
01:34:22,700 --> 01:34:25,100
Напрыклад, дазвольце мне
ісці наперад і рабіць гэта.

1860
01:34:25,100 --> 01:34:32,420
>> Дазвольце мне ісці наперад і стварыць argv1.c,
які трохі адрозніваецца на гэты раз.

1861
01:34:32,420 --> 01:34:35,635
Замест праверкі для argc2,
Я буду замест гэтага.

1862
01:34:35,635 --> 01:34:41,270
Для инт я атрымліваю 0, я менш
чым ARGC, я плюс плюс,

1863
01:34:41,270 --> 01:34:47,920
а затым раздрукаваць ўнутры гэтага,
адсоткаў s, новая лінія, а затым

1864
01:34:47,920 --> 01:34:50,740
ARGV кранштэйны я.

1865
01:34:50,740 --> 01:34:55,220
>> Такім чынам, іншымі словамі, я не маем справу з
асобныя знакі ў дадзены момант.

1866
01:34:55,220 --> 01:35:00,190
ARGV, як вынікае з гэтых пусты квадрат
брекет справа ад імя ARGV,

1867
01:35:00,190 --> 01:35:03,320
азначае ARGV масіў радкоў.

1868
01:35:03,320 --> 01:35:04,870
І ARGC гэта проста инт.

1869
01:35:04,870 --> 01:35:08,800
>> Гэтая лінія тут, 6, з'яўляецца
кажучы набор я роўным 0.

1870
01:35:08,800 --> 01:35:11,980
Граф ўвесь шлях да,
але не уключаючы, ARGC.

1871
01:35:11,980 --> 01:35:14,010
І пасля на кожнай ітэрацыі,
раздрукаваць радок.

1872
01:35:14,010 --> 01:35:14,800
Якая радок?

1873
01:35:14,800 --> 01:35:17,270
>> I-га радка ў ARGV.

1874
01:35:17,270 --> 01:35:19,530
Так што ў той час, перш чым я быў
выкарыстоўваючы квадратныя дужкі

1875
01:35:19,530 --> 01:35:22,180
абазначэння, каб атрымаць у г-й
знак у радку, цяпер

1876
01:35:22,180 --> 01:35:27,240
Я выкарыстоўваю квадратныя дужкі, абазначэння
каб атрымаць у радку й у масіве.

1877
01:35:27,240 --> 01:35:30,310
Так што гэта свайго роду адзін пласт
вышэй, канцэптуальна.

1878
01:35:30,310 --> 01:35:35,390
>> Так што акуратным пра гэта
Праграма цяпер, калі я кампілюецца argv1,

1879
01:35:35,390 --> 01:35:42,067
а затым зрабіць ./argv1, а затым увядзіце
у чымсьці накшталт бара Baz Foo,

1880
01:35:42,067 --> 01:35:45,400
якія з'яўляюцца тры стандартныя словы, якія
вучоны дасягае на працягу любога часу

1881
01:35:45,400 --> 01:35:51,010
ён ці яна мае патрэбу ў некаторых шаблонныя словы,
і націсніце Enter, кожнае з гэтых слоў,

1882
01:35:51,010 --> 01:35:54,980
у тым ліку назва праграмы, якая
знаходзіцца ў ARGV на першым месцы,

1883
01:35:54,980 --> 01:35:58,320
заканчваецца друкуецца па адным за раз.

1884
01:35:58,320 --> 01:36:05,290
І калі я змяніць гэта, і я кажу:
нешта накшталт argv1 Zamyla Чан,

1885
01:36:05,290 --> 01:36:08,800
мы атрымліваем ўсе тры з іх
словы, што з'яўляецца argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, таму што ў гэтым
выпадак ARGC, лічыльнік, 3.

1887
01:36:14,400 --> 01:36:20,020
>> Але што акуратны, калі вы разумееце,
што ARGV проста масіў радкоў,

1888
01:36:20,020 --> 01:36:24,910
і вы разумееце, што радок
ўяўляе сабой масіў сімвалаў,

1889
01:36:24,910 --> 01:36:29,470
мы можам на самай справе выгляд выкарыстоўваць гэтую функцыю
квадратныя дужкі абазначэння некалькі разоў

1890
01:36:29,470 --> 01:36:33,320
каб выбраць радок, а затым выберыце
знак у радку,

1891
01:36:33,320 --> 01:36:35,730
дайвінг глыбей наступным чынам.

1892
01:36:35,730 --> 01:36:40,100
У гэтым прыкладзе, адпусьці мяне
наперад і назваць гэтую argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
І ў гэтым прыкладзе, дазвольце мне ісці наперад
і зрабіць following-- для INT я атрымліваю 0,

1895
01:36:50,180 --> 01:36:53,286
я менш ARGC, я плюс
плюс, гэтак жа, як і раней.

1896
01:36:53,286 --> 01:36:55,910
Такім чынам, у іншым words-- і зараз гэты
становіцца досыць складанай.

1897
01:36:55,910 --> 01:36:59,940
Тады я збіраюся сказаць,
перабіраць струны ў ARGV,

1898
01:36:59,940 --> 01:37:01,294
у якасці каментара да сябе.

1899
01:37:01,294 --> 01:37:03,960
І тады я буду мець
укладзены цыкл, які вы, верагодна,

1900
01:37:03,960 --> 01:37:06,290
зрабілі ці лічацца
рабіць у пустым месцы, дзе

1901
01:37:06,290 --> 01:37:08,600
Я хачу сказаць, я int--
не збіраецца выкарыстоўваць я зноў,

1902
01:37:08,600 --> 01:37:12,590
таму што я не хачу, каб цень, або
свайго роду перапісаць існуючы I.

1903
01:37:12,590 --> 01:37:15,780
>> Я збіраюся, а не, скажам, J, так як
гэта мая перайсці да зменнай пасля таго як я,

1904
01:37:15,780 --> 01:37:18,590
калі я проста спрабую
разлічваць простыя лікі.

1905
01:37:18,590 --> 01:37:28,850
Для J атрымлівае 0--, а таксама, п, збіраецца
атрымаць кармавой даўжыню ARGV кранштэйна I,

1906
01:37:28,850 --> 01:37:36,030
да таго часу, J менш т,
J плюс плюс, зрабіце наступнае.

1907
01:37:36,030 --> 01:37:37,500
А вось цікавая частка.

1908
01:37:37,500 --> 01:37:46,330
>> Раздрукуйце характар ​​і новую лінію,
падлучыўшы ARGV кранштэйн I, кранштэйн J.

1909
01:37:46,330 --> 01:37:47,940
ОК, так што дазвольце мне дадаць некаторыя каментары тут.

1910
01:37:47,940 --> 01:37:54,820
перабраць сімвалы
у бягучай радку,

1911
01:37:54,820 --> 01:38:02,290
друк J-й знак у г-м радку.

1912
01:38:02,290 --> 01:38:04,630
Так што цяпер, давайце разгледзім
Што азначаюць гэтыя каментары.

1913
01:38:04,630 --> 01:38:06,750
>> Перабор па струнах
у argv-- колькі

1914
01:38:06,750 --> 01:38:09,300
радкі ў ARGV, які з'яўляецца масівам?

1915
01:38:09,300 --> 01:38:13,420
ARGC шмат, таму я ітэрацыя
ад я роўна 0 да ARGC.

1916
01:38:13,420 --> 01:38:20,020
У той жа час, колькі знакаў
у г-га радка ў ARGV?

1917
01:38:20,020 --> 01:38:22,880
>> Ну, каб атрымаць гэты адказ,
Я проста называю даўжыню радка

1918
01:38:22,880 --> 01:38:26,810
на I догляд бягучай радкі
о, што ARGV кранштэйны я.

1919
01:38:26,810 --> 01:38:30,090
І я збіраюся часова захоўваць, што
значэнне п, толькі для мэт кэшавання,

1920
01:38:30,090 --> 01:38:31,590
памятаць яго эфектыўнасці.

1921
01:38:31,590 --> 01:38:36,330
І тады я буду ініцыялізаваць J 0,
працягваць ісці так доўга, як J менш п,

1922
01:38:36,330 --> 01:38:38,430
і на кожны крок ітэрацыі J.

1923
01:38:38,430 --> 01:38:41,030
>> А потым тут, у
мой каментар у радку 12,

1924
01:38:41,030 --> 01:38:43,390
раздрукаваць сімвал,
а затым новай лініі,

1925
01:38:43,390 --> 01:38:48,140
спецыяльна ARGV кранштэйны
я дае мне I-га радка

1926
01:38:48,140 --> 01:38:51,690
у argv-- так што першае слова, то
Другое слова, трэцяе слова, што заўгодна.

1927
01:38:51,690 --> 01:38:57,370
А потым J нырае глыбей і атрымлівае
я J-й сімвал гэтага слова.

1928
01:38:57,370 --> 01:39:02,200
І так, у сутнасці, вы можаце звяртацца
ARGV як мнагамернае,

1929
01:39:02,200 --> 01:39:06,050
у якасці двухмернага масіва ,,
прычым кожнае слова выгляд выглядае

1930
01:39:06,050 --> 01:39:08,580
як гэта ў вашым уяўленні
вочы, і кожны знак

1931
01:39:08,580 --> 01:39:10,930
з'яўляецца свайго роду складаецца ў
слупок, калі гэта дапамагае.

1932
01:39:10,930 --> 01:39:13,260
>> На самай справе, калі мы дражніць
гэта адзін ад аднаго ў будучых тыдняў,

1933
01:39:13,260 --> 01:39:15,580
гэта будзе трохі
больш складанай, чым гэта.

1934
01:39:15,580 --> 01:39:17,800
Але вы можаце рэальна
думаць пра тое, што на дадзены момант,

1935
01:39:17,800 --> 01:39:22,110
як толькі што гэта двухмерная
Масіў, у выніку чаго адзін узровень яго

1936
01:39:22,110 --> 01:39:23,260
гэта ўсё радка.

1937
01:39:23,260 --> 01:39:26,760
І потым, калі вы нырае ў глыбей, вы
можа атрымаць у асобных сімвалаў

1938
01:39:26,760 --> 01:39:29,600
у ім, выкарыстоўваючы гэтыя абазначэння тут.

1939
01:39:29,600 --> 01:39:31,620
>> Дык што ж такое чысты эфект?

1940
01:39:31,620 --> 01:39:34,970
Дазвольце мне ісці наперад і
зрабіць argv2-- цыраваць яго.

1941
01:39:34,970 --> 01:39:36,210
Я зрабіў памылку тут.

1942
01:39:36,210 --> 01:39:40,160
ўскосна абвясціўшы
бібліятэка функцый Стырлінга.

1943
01:39:40,160 --> 01:39:42,190
Так што ўвесь гэты час, гэта
магчыма, мэтазгодна

1944
01:39:42,190 --> 01:39:45,130
што мы накшталт аздаблення
менавіта там, дзе мы пачалі.

1945
01:39:45,130 --> 01:39:48,160
>> Я аблажаўся, безумоўнае прызнанне
бібліятэка функцый Стырлінга.

1946
01:39:48,160 --> 01:39:48,987
Добра, пачакайце хвіліну.

1947
01:39:48,987 --> 01:39:51,070
Я памятаю, што, асабліва
так як гэта прама тут.

1948
01:39:51,070 --> 01:39:54,490
Мне трэба, каб уключыць string.h ў
гэтая версія праграмы.

1949
01:39:54,490 --> 01:40:00,050
>> Дазвольце мне ісці наперад і ўключаюць у сябе
string.h, акрамя таго, што, ісці наперад

1950
01:40:00,050 --> 01:40:04,460
і перасабраць argv2.

1951
01:40:04,460 --> 01:40:08,390
І цяпер, тут мы ідзем, зрабіць argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
І хоць гэта крыху
загадкавыя на першы погляд,

1953
01:40:10,590 --> 01:40:15,690
звярніце ўвагу, што, на самай справе, тое, што
раздрукоўваецца з'яўляецца кропка argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Але калі я ўвесці некаторыя словы за
падкажыце, як argv2 Zamyla Чан,

1955
01:40:19,970 --> 01:40:22,560
Калі ласка, увядзіце, таксама трохі
загадкавыя на першы погляд.

1956
01:40:22,560 --> 01:40:30,540
Але калі мы пракручваем назад уверх,
./argv2 Z-А-М-У-Л-З-Н-А-Н.

1957
01:40:30,540 --> 01:40:32,190
Такім чынам, мы ітэрацыю над кожным словам.

1958
01:40:32,190 --> 01:40:37,770
І, у сваю чаргу, мы ітэрацыі
кожны знак у слове.

1959
01:40:37,770 --> 01:40:40,040
>> Цяпер, пасля таго, як усё гэта,
разумею, што ёсць

1960
01:40:40,040 --> 01:40:43,120
адна дэталь мы былі свайго роду
ігнараваць ўвесь гэты час.

1961
01:40:43,120 --> 01:40:46,180
Мы проста дражняць адзін ад аднаго, што
Ўваходы галоўных можа быць?

1962
01:40:46,180 --> 01:40:47,780
Як наконт выхаду галоўных у?

1963
01:40:47,780 --> 01:40:50,540
>> Увесь гэты час мы былі
проста капіяванне і ўстаўка

1964
01:40:50,540 --> 01:40:53,870
слова INT перад галоўным чынам,
хоць вы можаце ўбачыць у Інтэрнэце,

1965
01:40:53,870 --> 01:40:58,340
часам няправільна ў больш ранніх версіях
С і кампілятараў, што яны кажуць, што пустэча,

1966
01:40:58,340 --> 01:40:59,410
ці ўвогуле нічога.

1967
01:40:59,410 --> 01:41:01,580
Але, на самой справе, для версіі
З, што мы выкарыстоўваем,

1968
01:41:01,580 --> 01:41:06,180
C 11, ці 2011, рэалізаваць
што яно павінна быць инт.

1969
01:41:06,180 --> 01:41:09,300
І гэта павінна быць альбо
несапраўдным або ARGC і ARGV тут.

1970
01:41:09,300 --> 01:41:10,790
>> Але чаму INT галоўны?

1971
01:41:10,790 --> 01:41:12,480
Што гэта на самай справе вяртанне?

1972
01:41:12,480 --> 01:41:16,280
Што ж, аказваецца, увесь гэты час,
у любы час вы напісалі праграма галоўная

1973
01:41:16,280 --> 01:41:18,440
заўсёды вяртаецца нешта.

1974
01:41:18,440 --> 01:41:19,960
Але гэта было рабіць гэта таемна.

1975
01:41:19,960 --> 01:41:23,350
>> Гэта нешта ёсць
INT, у радку 5 прапаноўвае.

1976
01:41:23,350 --> 01:41:24,225
Але што INT?

1977
01:41:24,225 --> 01:41:26,100
Ну, ёсць такая
канвенцыі ў галіне праграмавання,

1978
01:41:26,100 --> 01:41:29,790
прычым, калі нічога не мае
пайшло не так, і ўсё добра,

1979
01:41:29,790 --> 01:41:34,250
праграмы і функцыі ў цэлым
return-- некалькі counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 ў цэлым азначае, што ўсё добра.

1982
01:41:38,070 --> 01:41:40,610
Так што нават калі вы думаеце
гэта як хлусня ў многіх кантэкстах,

1983
01:41:40,610 --> 01:41:42,930
гэта на самай справе азначае, як правіла, добрая рэч

1984
01:41:42,930 --> 01:41:49,560
>> У той жа час, калі праграма вяртае 1,
ці адмоўны 1, або 5, або адмоўны 42,

1985
01:41:49,560 --> 01:41:52,941
або любы ня-0 значэнне,
што ў цэлым азначае

1986
01:41:52,941 --> 01:41:54,190
што нешта пайшло не так.

1987
01:41:54,190 --> 01:41:56,700
На самай справе, на вашым ўласным Mac ці PC,
Вы, магчыма, на самай справе бачыў

1988
01:41:56,700 --> 01:42:01,050
паведамленне пра памылку, у выніку чаго яго
кажа што-небудзь ці іншае, памылка

1989
01:42:01,050 --> 01:42:04,940
код адмоўны 42, ці код памылкі
23, ці нешта ў гэтым родзе.

1990
01:42:04,940 --> 01:42:08,980
Гэты лік, як правіла, толькі намёк
праграмісту або кампаніі

1991
01:42:08,980 --> 01:42:11,174
што зрабіў праграмнае забеспячэнне,
што пайшло не так і чаму,

1992
01:42:11,174 --> 01:42:13,590
такім чынам, каб яны маглі глядзець праз
іх дакументацыя ці код,

1993
01:42:13,590 --> 01:42:15,465
і высветліць, што
памылка на самай справе азначае.

1994
01:42:15,465 --> 01:42:18,400
Як правіла, не
карысным для нас канчатковых карыстальнікаў.

1995
01:42:18,400 --> 01:42:20,550
>> Але калі асноўныя вяртае 0, усё добра.

1996
01:42:20,550 --> 01:42:23,770
І калі вы не пакажаце
якія асноўныя павінны вярнуцца,

1997
01:42:23,770 --> 01:42:26,950
ён проста будзе аўтаматычна
вяртае значэнне 0 для вас.

1998
01:42:26,950 --> 01:42:30,870
Але, вяртаючыся нешта
яшчэ на самай справе карысна.

1999
01:42:30,870 --> 01:42:34,660
>> У гэтай заключнай праграме, дайце мне
ісці наперад і назваць гэтую exit.c,

2000
01:42:34,660 --> 01:42:38,630
і ўвесці апошні з сённяшніх
тэмы, вядомыя як код памылкі.

2001
01:42:38,630 --> 01:42:42,930
Дазвольце мне ісці наперад і ўключаюць у сябе нашы
знаёмыя файлы Наверсе, зрабіце INT галоўны.

2002
01:42:42,930 --> 01:42:49,500
І на гэты раз, давайце рабіць Int ARGC,
Радок ARGV, і з маіх дужках

2003
01:42:49,500 --> 01:42:50,836
мае на ўвазе, што гэта ў масіве.

2004
01:42:50,836 --> 01:42:52,460
І тады дазвольце мне зрабіць праверку наяўнасці свядомасці.

2005
01:42:52,460 --> 01:42:56,640
На гэты раз, калі ARGC ня
роўна 2, то вы ведаеце, што?

2006
01:42:56,640 --> 01:42:57,520
Забудзь.

2007
01:42:57,520 --> 01:43:03,170
Я хачу сказаць, што, эй, карыстальнік,
вам не хапае аргумент каманднага радка

2008
01:43:03,170 --> 01:43:04,210
зваротная касая п.

2009
01:43:04,210 --> 01:43:05,230
>> А потым гэта ўсё.

2010
01:43:05,230 --> 01:43:06,130
Я хачу, каб выйсці.

2011
01:43:06,130 --> 01:43:11,030
Я збіраюся прэвентыўна,
і заўчасна сапраўды, вяртанне

2012
01:43:11,030 --> 01:43:12,810
нешта іншае, чым колькасць 1.

2013
01:43:12,810 --> 01:43:15,360
Перайсці да значэння для першага
памылка, якая можа адбыцца 1.

2014
01:43:15,360 --> 01:43:17,860
Калі ў вас ёсць нейкі іншы памылковы
сітуацыя, якая можа адбыцца,

2015
01:43:17,860 --> 01:43:21,390
Вы маглі б сказаць, вяртанне 2 ці вяртанне 3, або
можа быць, нават адмоўны 1 ці адмоўны 2.

2016
01:43:21,390 --> 01:43:23,750
>> Гэта толькі коды завяршэння
якія з'яўляюцца, як правіла,

2017
01:43:23,750 --> 01:43:27,770
толькі карысна для праграміста, або
кампанія, суднаходная праграмнае забеспячэнне.

2018
01:43:27,770 --> 01:43:30,500
Але той факт, што гэта
ня 0, што важна.

2019
01:43:30,500 --> 01:43:34,310
Так што, калі ў гэтай праграме, я хачу
гарантаваць, што гэтая праграма толькі

2020
01:43:34,310 --> 01:43:38,190
працуе, калі карыстальнік дае мне
з колькасцю аргументаў, з двух,

2021
01:43:38,190 --> 01:43:42,880
назва праграмы, а таксама некаторыя іншыя
слова, я магу ўжываць столькі, колькі варта,

2022
01:43:42,880 --> 01:43:46,110
крычаць на карыстальніка з PRINTF прымаўцы,
адсутнічае аргумент каманднага радка,

2023
01:43:46,110 --> 01:43:46,970
вяртае 1.

2024
01:43:46,970 --> 01:43:49,940
Гэта будзе проста неадкладна
выйсці з праграмы.

2025
01:43:49,940 --> 01:43:55,840
>> Толькі калі ARGC роўны 2 мы атрымаем ўніз
тут, у які момант я збіраюся сказаць,

2026
01:43:55,840 --> 01:44:00,410
прывітанне адсоткаў s, зваротны слэш н, argv1.

2027
01:44:00,410 --> 01:44:03,827
Іншымі словамі, я
ня будзе пасьля таго, як ARGV 0,

2028
01:44:03,827 --> 01:44:05,410
які з'яўляецца толькі назва праграмы.

2029
01:44:05,410 --> 01:44:09,450
Я хачу, каб надрукаваць Прывітанне, коска,
другое слова, якое надрукаваў чалавек.

2030
01:44:09,450 --> 01:44:12,580
І ў гэтым выпадку на
радок 13, усё добра.

2031
01:44:12,580 --> 01:44:15,920
>> Я ведаю, што ARGC 2
лагічна выцякае з гэтай праграмы.

2032
01:44:15,920 --> 01:44:17,770
Я збіраюся ісці наперад і вяртаць 0.

2033
01:44:17,770 --> 01:44:21,230
Як і ў бок, майце на ўвазе, што
гэта дакладна ў пустым месцы, а таксама.

2034
01:44:21,230 --> 01:44:24,760
>> Па логіцы рэчаў, я мог бы гэта зрабіць
і інкапсуляваць гэтыя радкі

2035
01:44:24,760 --> 01:44:27,020
кода ў гэтым пункце астатняе тут.

2036
01:44:27,020 --> 01:44:29,420
Але гэта свайго роду
залішне водступы мой код.

2037
01:44:29,420 --> 01:44:31,800
І я хачу, каб зрабіць супер
ясна, што незалежна ад таго,

2038
01:44:31,800 --> 01:44:34,670
па змаўчанні, прывітанне
нешта і будзе надрукаваны,

2039
01:44:34,670 --> 01:44:36,050
да таго часу, пакуль карыстальнік ўзаемадзейнічае.

2040
01:44:36,050 --> 01:44:39,360
>> Так што гэта вельмі распаўсюджана выкарыстанне
стан, проста калі,

2041
01:44:39,360 --> 01:44:41,870
злавіць некаторыя памылковыя
сітуацыя, а затым выйсці.

2042
01:44:41,870 --> 01:44:45,690
І тады, да таго часу, усё
ну, не маюць іншага,

2043
01:44:45,690 --> 01:44:48,060
але проста код
звонку, што, калі, таму што гэта

2044
01:44:48,060 --> 01:44:51,060
эквівалент у гэтым
прыватны выпадак, лагічна.

2045
01:44:51,060 --> 01:44:54,480
Так што я вяртаюся 0, проста
відавочна азначае, што ўсё добра.

2046
01:44:54,480 --> 01:44:58,480
>> Калі я прапусціў вяртанне 0, было б
аўтаматычна мяркуецца, для мяне.

2047
01:44:58,480 --> 01:45:00,890
Але цяпер, калі я вяртаюся
адзін, па меншай меры гэтым выпадку,

2048
01:45:00,890 --> 01:45:04,940
Я збіраюся, для добрай мерай і
яснасць, вяртае 0 ў гэтым выпадку.

2049
01:45:04,940 --> 01:45:09,690
Так што цяпер дазвольце мне ісці наперад і зрабіць выхад,
які з'яўляецца ідэальным Segue проста сысці.

2050
01:45:09,690 --> 01:45:14,401
>> Але зрабіць выхад, і адпусціць мяне
наперад і рабіць ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
І праграма закрычаў на мяне,
адсутнічае аргумент каманднага радка.

2052
01:45:16,900 --> 01:45:18,120
Добра, дазвольце мне супрацоўнічаць.

2053
01:45:18,120 --> 01:45:23,810
>> Дазвольце мне замест таго, каб рабіць ./exit, Дэвід, Enter.

2054
01:45:23,810 --> 01:45:25,190
А цяпер ён кажа, прывітанне Дэвід.

2055
01:45:25,190 --> 01:45:27,300
І вы звычайна не бачыце гэта.

2056
01:45:27,300 --> 01:45:30,650
>> Але аказваецца, што ёсць
асаблівы шлях у Linux на самай справе ўбачыць

2057
01:45:30,650 --> 01:45:34,470
з тым, што код завяршэння праграмы завяршаецца.

2058
01:45:34,470 --> 01:45:37,184
Часам у графічным
свет, як Mac OS або Windows,

2059
01:45:37,184 --> 01:45:40,100
вы бачыце толькі гэтыя лічбы, калі
паведамленне пра памылку з'яўляецца на экране

2060
01:45:40,100 --> 01:45:41,940
і праграміст
паказвае, што лік.

2061
01:45:41,940 --> 01:45:44,773
Але калі мы хочам, каб убачыць, што памылка
паведамленне, мы можам зрабіць гэта here--

2062
01:45:44,773 --> 01:45:48,100
так ./exit, Enter, друк
адсутнічае аргумент каманднага радка.

2063
01:45:48,100 --> 01:45:54,590
>> Калі я цяпер рабіць рэха $?, Які
смешна загадкавыя гледзячы.

2064
01:45:54,590 --> 01:45:56,590
Але $?

2065
01:45:56,590 --> 01:45:59,220
з'яўляецца магічным загаворам
што кажа, эй, кампутар,

2066
01:45:59,220 --> 01:46:01,900
скажыце мне, што папярэдні
код выхаду праграмы быў.

2067
01:46:01,900 --> 01:46:03,410
І я ўдарыў Enter.

2068
01:46:03,410 --> 01:46:07,520
Я бачу 1, таму што гэта тое, што я
сказаў сваёй асноўнай функцыі, каб вярнуцца.

2069
01:46:07,520 --> 01:46:12,310
>> У той жа час, калі я ./exit Давіда,
і націсніце Enter, я бачу, прывітанне Давіда.

2070
01:46:12,310 --> 01:46:16,800
І калі я цяпер рабіць рэха $?, Я бачу прывітанне 0.

2071
01:46:16,800 --> 01:46:19,080
І такім чынам гэта будзе на самой справе
быць каштоўнай інфармацыі

2072
01:46:19,080 --> 01:46:23,420
у кантэксце адладчыка, не так
шмат, што вы, чалавек, будзе клапаціцца.

2073
01:46:23,420 --> 01:46:26,060
Але адладчык і іншыя
праграмы, якія мы будзем выкарыстоўваць у гэтым семестры

2074
01:46:26,060 --> 01:46:29,420
будзе часта глядзець на гэты лік,
нягледзячы на ​​тое, што гэта свайго роду схаваны

2075
01:46:29,420 --> 01:46:32,780
калі не шукаць яго, каб
вызначыць, ці сапраўды програмы

2076
01:46:32,780 --> 01:46:37,050
выкананне было правільным ці няправільным.

2077
01:46:37,050 --> 01:46:40,450
>> І так, што прыводзіць нас да
гэта, у канцы дня.

2078
01:46:40,450 --> 01:46:43,917
Мы пачалі сёння, гледзячы на
адладкі, і ў сваю чаргу, у ходзе

2079
01:46:43,917 --> 01:46:46,750
сама па сабе, а затым больш цікава,
тэхнічна пад капотам

2080
01:46:46,750 --> 01:46:49,490
на тое, што радкі, якія доўжацца
тыдзень мы проста ўзялі нешта само сабой разумеецца,

2081
01:46:49,490 --> 01:46:51,900
і, вядома, узяў іх
як само сабой разумеецца ў пустым месцы.

2082
01:46:51,900 --> 01:46:56,040
>> Затым мы разгледзелі, як мы можам атрымаць доступ
асобныя сімвалы ў радку,

2083
01:46:56,040 --> 01:47:00,310
а затым зноў узяў на больш высокі ўзровень
глядзець на рэчы, гледзячы на ​​тое, як well--

2084
01:47:00,310 --> 01:47:04,226
калі мы хочам атрымаць на індывідуальным
элементы ў спісе, як структура,

2085
01:47:04,226 --> 01:47:05,850
мы не можам зрабіць гэта з некалькімі радкамі?

2086
01:47:05,850 --> 01:47:08,050
І мы можам з аргументамі каманднага радка.

2087
01:47:08,050 --> 01:47:12,800
Але гэтая карціна тут проста скрынкі
Паказальна ў гэтай агульнай ідэі

2088
01:47:12,800 --> 01:47:14,451
масіва або спісу або вектара.

2089
01:47:14,451 --> 01:47:16,450
І ў залежнасці ад
кантэкст, усе гэтыя словы

2090
01:47:16,450 --> 01:47:17,880
азначаюць трохі розныя рэчы.

2091
01:47:17,880 --> 01:47:20,060
Такім чынам, у C, мы толькі збіраемся
казаць аб масіве.

2092
01:47:20,060 --> 01:47:23,840
І масіў ўяўляе сабой кавалак
памяці, кожны з якіх гэта

2093
01:47:23,840 --> 01:47:27,720
элементы з'яўляюцца сумежнымі, назад,
да спіны, да спіны, да спіны.

2094
01:47:27,720 --> 01:47:31,970
>> І гэтыя элементы, як правіла,
аднаго і таго ж тыпу дадзеных, сімвалаў,

2095
01:47:31,970 --> 01:47:35,966
характар, характар, характар, або
радок, радок, радок, радок, або INT,

2096
01:47:35,966 --> 01:47:38,600
INT, INT, тое, што гэта
мы спрабуем захаваць.

2097
01:47:38,600 --> 01:47:42,540
Але ў рэшце рэшт, гэта
як гэта выглядае канцэптуальна.

2098
01:47:42,540 --> 01:47:44,530
Вы бераце ваш
памяці або АЗП кампутара.

2099
01:47:44,530 --> 01:47:48,590
І вы выразаючы яго ў
аднолькавага памеру скрынкі, усе з якіх

2100
01:47:48,590 --> 01:47:50,920
вярнуліся, да спіны, каб
назад, да спіны такім чынам.

2101
01:47:50,920 --> 01:47:53,200
>> І што прыемна аб
гэтая ідэя, і той факт,

2102
01:47:53,200 --> 01:47:58,580
што мы можам выказаць значэння ў гэтым выпадку
з першым з нашых структур дадзеных

2103
01:47:58,580 --> 01:48:02,520
у класе, азначае, што мы можам пачаць
вырашыць праблемы з кодам

2104
01:48:02,520 --> 01:48:04,079
што прыйшло так інтуітыўна у тыдзень 0.

2105
01:48:04,079 --> 01:48:05,870
Вы памятаеце, тэлефон
Прыклад кнігі, дзе

2106
01:48:05,870 --> 01:48:09,110
мы выкарыстоўвалі падзяляй і ўладар,
або двайковы алгарытм пошуку,

2107
01:48:09,110 --> 01:48:13,220
прасейваць ў цэлым
куча імёнаў і нумароў.

2108
01:48:13,220 --> 01:48:18,220
Але мы меркавалі, нагадаем, што гэта
Тэлефонная кніга была ўжо адсартаваны,

2109
01:48:18,220 --> 01:48:21,630
што хтосьці ўжо
фігурны out-- дадзены спіс імёнаў

2110
01:48:21,630 --> 01:48:24,430
і numbers--, як у алфавітным парадку іх.

2111
01:48:24,430 --> 01:48:26,950
І зараз, калі ў C мы,
таксама ёсць магчымасць

2112
01:48:26,950 --> 01:48:30,290
закласці рэчы, а не
фізічна ў тэлефоннай кнізе

2113
01:48:30,290 --> 01:48:34,220
але практычна ў кампутара
памяць, мы зможам на наступным тыдні

2114
01:48:34,220 --> 01:48:38,470
ўвесці зноў this-- першы
нашых структур дадзеных у array--

2115
01:48:38,470 --> 01:48:43,530
але што больш важна, фактычны кампутар
Алгарытмы навукі рэалізаваны

2116
01:48:43,530 --> 01:48:47,720
у кодзе, з дапамогай якога мы можам захоўваць
дадзеныя ў структурах, як гэта,

2117
01:48:47,720 --> 01:48:50,730
а затым пачынаюць маніпуляваць ёю, і
на самай справе вырашыць праблемы, звязаныя з ім,

2118
01:48:50,730 --> 01:48:53,570
і пабудаваць на вяршыні гэтага,
у канчатковым рахунку, праграмы ў C,

2119
01:48:53,570 --> 01:48:56,730
у Python, у JavaScript,
запытаў да баз дадзеных з SQL?

2120
01:48:56,730 --> 01:48:59,980
>> І мы бачым, што ўсе гэтыя
розныя ідэі блакіроўкі.

2121
01:48:59,980 --> 01:49:04,100
Але цяпер, нагадаем, што
Дамен, які мы ўвялі сёння

2122
01:49:04,100 --> 01:49:06,920
была гэтая рэч тут, і
свет крыптаграфіі.

2123
01:49:06,920 --> 01:49:11,200
А сярод наступных праблем вы самі
будзе вырашаць гэта мастацтва крыптаграфіі,

2124
01:49:11,200 --> 01:49:13,630
скремблирования і дескремблирования
інфармацыя, і шифрации

2125
01:49:13,630 --> 01:49:15,930
і расшыфроўка тэксту,
і мяркуючы, у канчатковым рахунку,

2126
01:49:15,930 --> 01:49:18,970
што цяпер вы ведаеце, што
знаходзіцца пад капотам

2127
01:49:18,970 --> 01:49:21,860
так што, калі вы бачыце ці атрымаць
паведамленне как это, вы

2128
01:49:21,860 --> 01:49:24,060
самі можаце расшыфраваць яго.

2129
01:49:24,060 --> 01:49:26,740
Усё гэта, і больш у наступны раз.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [ВИДЕОВОСПРОИЗВЕДЕНИЕ]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Толькі што прыбыў.

2133
01:49:32,970 --> 01:49:35,146
Я збіраюся ісці візіт
яго прафесар каледжа.

2134
01:49:35,146 --> 01:49:37,611
Так.

2135
01:49:37,611 --> 01:49:40,080
Прывітанне.

2136
01:49:40,080 --> 01:49:40,660
Гэта ты.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Пачакайце!

2139
01:49:45,110 --> 01:49:45,610
Дэвід.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Я проста спрабую зразумець
што здарылася з вамі.

2142
01:49:56,060 --> 01:49:58,130
Калі ласка, што-небудзь можа дапамагчы.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Вы былі яго каледж
сусед па пакоі, ці не так?

2145
01:50:08,354 --> 01:50:10,770
Вы былі там з ім, калі
ён завяршыў праект CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [МУЗЫКА]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -вот Быў CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Я люблю гэтае месца.

2152
01:50:44,770 --> 01:50:45,854
>> -Eat Уверх.

2153
01:50:45,854 --> 01:50:47,020
Мы збіраемся з бізнэсу.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [КАНЕЦ засьпяваю]

