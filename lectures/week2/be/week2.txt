[МУЗЫКА] 

DAVID J. малая: Добра. Гэта CS50 і гэта з'яўляецца пачаткам 2-й тыдні. І вы памятаеце, што больш апошнія пару тыдняў, мы прадставілі кампутар навука і, у сваю чаргу, праграмаванне. 

І мы пачалі аповяд шляхам Драпіна, што графічную мову з медыя-лабараторыі Масачусецкага тэхналагічнага інстытута. А потым зусім нядаўна, На мінулым тыдні, мы зрабілі ўвесці higher-- A мова больш нізкага ўзроўню вядомыя як З, тое, што гэта чыста тэкстава. І, сапраўды, апошні раз, калі мы вывучыць ў гэтым кантэксце шэраг паняццяў. 

Гэта, нагадаем, быў вельмі Першая праграма мы разгледзелі. І гэтая праграма, даволі проста, друкуе "Прывітанне, свет." Але ёсць так шмат ўяўнай магіі адбываецца. Там гэтая #include з гэтых кутніх дужках. Там у инт. Там у (анулююцца). Там у круглыя ​​дужкі, фігурныя дужкі, кропка з коскі, і многае іншае. 

Так, нагадаем, што мы ўвялі драпіна так што мы маглі б, у ідэале, убачыць мінулае што сінтаксіс, матэрыял, які сапраўды ня усё, што інтэлектуальна цікава, але на ранніх стадыях гэта, безумоўна, крыху больш складана каб абгарнуць ваш розум вакол. І на самай справе, адно з самых распаўсюджаных рэчы на ​​раннім этапе ў класе праграмавання, асабліва для тых, хто менш зручна, каб зламацца, і падстаўлялі некаторымі сінтаксічнымі памылкі, не кажучы ўжо пра лагічных памылак. І таму сярод нашых мэтаў сёння, на самай справе, будзе будзе абсталёўваць вас з некаторымі метады вырашэння праблем для таго, як каб лепш вырашаць праблемы самі ў выглядзе адладкі. І вы памятаеце, таксама, што серада, мы ўвялі апошні раз быў названы CS50 IDE. Гэта вэб-праграмнае забеспячэнне, дазваляе праграмаваць ў воблаку, так бы мовіць, захоўваючы пры гэтым усе вашыя файлы разам, як мы зноў будзем сёння. І нагадаем, што мы перагледзець гэтыя тэмы тут, сярод іх функцый, а таксама завесы, і зменныя і лагічныя выразы, і ўмовы. І на самай справе некалькі больш, што мы у перакладзе з нуля свету да міру C. 

Але асноўны будынак блокі, так бы мовіць, сапраўды былі ўсе тыя ж на мінулым тыдні. На самай справе, мы сапраўды толькі мелі розныя кавалак галаваломкі, калі вы будзеце. Замест таго, што фіялетавы захаваць блок, мы замест таго, каб быў PRINTF, які гэтая функцыя ў С, дазваляе надрукаваць што-небудзь і адфарматаваць яго на экране. Мы ўвялі CS50 Бібліятэка, дзе вы ёсць зараз у вашым распараджэнні get_char, і get_int і get_string, і некалькі іншых функцый, як ну, з дапамогай якога вы можаце атрымаць ўвод ад уласнай клавіятуры карыстальніка. І мы таксама ўзялі погляд на рэчы як these- BOOL і паўкокс, і двайныя, з якая плавае кропкай, INT, long_long радок. І ёсць нават іншыя тыпы дадзеных у C. 

Іншымі словамі, калі вы аб'яўляеце зменная для захоўвання некаторага значэння, або пры рэалізацыі функцыі якая вяртае некаторы значэнне, Вы можаце паказаць, што тып значэння, якое. Гэта радок, падобна паслядоўнасць знакаў? Гэты лік, як цэлы лік? Ці з'яўляецца гэта з якая плавае кропкай значэнне, ці таму падобнае? Такім чынам, у C, у адрозненне ад нуля, мы на самай справе пачаў паказваць, які тып дадзеных мы вярталіся або выкарыстання. 

Але, вядома, мы таксама сутыкнуліся з некаторыя фундаментальныя межы вылічэнняў. І ў прыватнасці, гэтая мова C, нагадаем што мы глядзелі на Цэлалікавымі перапаўненне, рэальнасць што калі ў вас ёсць толькі канчатковае колькасць памяці ці, у прыватнасці, канчатковае лік бітаў, вы можаце разлічваць толькі так высока. І такім чынам, мы глядзелі на гэты прыклад тут у выніку чаго лічыльнік у самалёце ,, на самай справе, калі працуе дастаткова доўга будзе перапаўненне і вынік у праграмным забеспячэнні фактычны фізічны патэнцыял памылкі. 

Мы таксама разгледзелі плавае кропка недакладнасцяў, рэальнасць што толькі з канчатковым лікам бітаў, няхай гэта будзе 32 або 64, вы можаце паказаць толькі так шмат лікаў пасля дзесятковай кропкі, пасля чаго вы пачынаюць атрымліваць недакладным. Так, напрыклад, адна трэць ў свет тут, у нашым чалавечым свеце, мы ведаем, гэта проста бясконцую колькасць 3 сек пасля дзесятковай кропкі. Але кампутар не абавязкова ўяўляюць сабой бясконцую колькасць лічбаў калі вы толькі дайце яму некаторыя канчатковае колькасць інфармацыі. 

Так што мы не толькі узброіць вас з большай сілай у плане як Вы маглі б выказаць сябе ў клавіятура з пункту гледжання праграмавання, мы таксама абмежаваныя, што вы можаце рэальна зрабіць. І на самай справе, памылкі і памылкі могуць ўзнікаюць з гэтых відаў пытанняў. І сапраўды, сярод тым сёння будуць такія тэмы, як адладкі і на самай справе, гледзячы пад капотам на тое, як былі ўведзеныя рэчы на ​​мінулым тыдні на самай справе рэалізаваны так што вам лепш зразумець, як магчымасцяў і абмежаванні мовы як C. 

І на самай справе, мы адхіліце пласты з найпростых структуры дадзеных, тое, што называецца масіў, які Драпіна здараецца называць "спіс." гэта крыху адрозніваецца ў гэтым кантэксце. І тады мы будзем таксама ўвесці адно з першы з нашых праблем прадметна-арыентаваных у CS50, свет крыптаграфія, мастацтва караскацца або ў шыфраванні інфармацыі, так што вы можаце адпраўляць сакрэтныя паведамленні і дэкадаваць сакрэтныя паведамленні паміж двума асобамі, А і В. 

Таму, перш чым мы пераходу да гэтага новага свеце, давайце паспрабуем забяспечыць вас з некаторымі метады, з якімі вы можаце ліквідаваць або паменшыць па меншай меры, некаторыя расчараванняў што вы, верагодна, сутыкаліся Толькі за мінулы тыдзень. На самай справе, наперадзе вас such-- некаторыя з вашы першыя праблемы ў С і форы, калі вы падобныя на мяне, у першы раз вы спрабуеце ўдрукуешся праграму, нават калі вы думаеце, лагічна Праграма даволі простая, вы можаце вельмі добра урэзаўся ў сцяну, і кампілятар не збіраецца супрацоўнічаць. Робяць або Clang не збіраецца на самай справе зрабіць вашыя стаўкі. 

І чаму гэта можа быць? Што ж, давайце паглядзім на, можа быць, простая праграма. Я збіраюся ісці наперад і захаваць гэта ў файл наўмысна называюць buggy0.c, таму што я ведаю яго быць сапсаваны загадзя. Але я не мог зразумець, што калі гэта першы ці другі ці трэцяй праграмы што я на самой справе робіць сам. Так што я збіраюся ісці наперад і ўдрукуешся, Int асноўны (вакуум). І тады ўнутры маіх фігурныя дужкі, вельмі знаёмы ( "прывітанне, world-- зваротнай касой рысы, п ") - і кропка з коскі. 

Я захаваў файл. Цяпер я збіраюся пайсці ўніз да майго акне тэрмінала і тып робяць buggy0, таму што, зноў жа, імя файла сёння buggy0.c. Так што я тыпу зрабіць buggy0, Enter. 

І, о, божа, памятаеце з апошняга часу што без якіх-небудзь паведамленняў пра памылкі гэта добрая рэч. Так што выснова не з'яўляецца добрай рэччу. Але тут я ясна некаторы колькасць памылак. 

Такім чынам, у першым радку вываду пасля ўводу робяць buggy0, нагадаем, даволі падрабязны выснову звонам ст. Пад капотам, CS50 IDE настроены выкарыстоўваць цэлую кучу Варыянты з гэтым кампілятарам так што ў вас няма думаць пра іх. І гэта ўсё, што першая лінія азначае, што пачынаецца з Clang. 

Але пасля гэтага, праблемы пачаць рабіць іх знешні выгляд. Buggy0.c на лініі 3, характар 5, ёсць вялікая, чырвоная памылка. Што гэта? Ўскосна абвяшчаючы функцыі бібліятэкі PRINTF з тыпам Int (сопзЬ сЬаг *, ...) [-Werror]. Я маю на ўвазе, гэта вельмі хутка становіцца вельмі аркан. І, вядома ж, у першую чаргу погляд, мы не будзем чакаюць, што вы разумееце паўната гэтага паведамлення. І вось адзін з урокаў на сённяшні дзень адбываецца каб паспрабаваць заўважыць ўзоры, або падобныя рэчы, да памылак вы можаце мець сутыкнуліся ў мінулым. Так што давайце дражніць толькі адзін ад аднаго тыя словы, якія выглядаюць знаёмымі. Вялікі, чырвоны памылка відавочна сімвалам чагосьці памыліцца. 

безумоўнае прызнанне Бібліятэка функцый Printf. Так што нават калі я не зусім разумею, што няяўна абвяшчаючы функцыі бібліятэкі Значыць, праблема, вядома, ставіцца да PRINTF нейкім чынам. І крыніца гэтага пытання мае справу з абвясціўшы яго. 

Аб'яву функцыі з'яўляецца згадкі пра яго ў першы раз. І мы выкарыстоўвалі тэрміналогію на мінулым тыдні таго, каб абвясціць прататып функцыі ва, альбо з адной лініяй у верхняй частцы вашага уласны файл або ў так званым файле загалоўка. І ў якім файле зрабіў мы гаворым на мінулым тыдні, што Printf цытата, Unquote, заявіў? У якім файле знаходзіцца яго прататып? 

Так што, калі вы памятаеце, самае першае, што я тыпізаваных, амаль кожная праграма ў мінулым time-- і выпадкова хвіліну таму пачалася набраўшы myself-- быў адзін here-- hash-- #include <stio-- для уваход / output-- кропка ч І сапраўды, калі я цяпер захаваць гэты файл, я збіраюся ісці наперад і ачысціць экран, якія вы можаце зрабіць, увёўшы Ясна, ці вы можаце трымаць кіравання L, проста ачысціць акно тэрмінала проста каб ліквідаваць некаторыя перашкоды. 

Я збіраюся ісці наперад і паўторна тыпу робяць buggy0, Enter. І вуаля, я да гэтага часу бачу, што доўгі час каманда з Clang, але няма ніякага паведамлення пра памылку на гэты раз. І на самай справе, калі я ./buggy0, гэтак жа, як у мінулы раз, дзе кропка азначае гэта каталог, Слэш проста азначае, тут ідзе назва праграмы і што назва праграмы buggy0, Калі ласка, увядзіце, "Прывітанне, свет." 

Зараз, як вы, магчыма, запазычаныя гэтае рашэнне не абавязкова прызнаючы, як шмат слоў, як і я, вядома ж, маючы зрабілі гэта на працягу многіх гадоў? Ну, рэалізаваць у першай задачы набор, мы пазнаёмім вас з камандай што ўласны персанал CS50 ў напісаў пад назвай help50. І на самай справе, C робіць спецыфікацыю праблема ўсталяваць адносна таго, як выкарыстоўваць гэтую функцыю. 

Але, па сутнасці, help50 праграма, якая супрацоўнікі CS50 ў пісаў, што дазваляе запускаць каманда або запусціць праграму, і калі вы не разумееце яго выхад, каб перадаць свой выхад help50, і ў гэты момант праграмнае забеспячэнне што супрацоўнікі вядома пісаў будзе выглядаць на выхадзе вашай праграмы радок за радком, па адным знаку. І калі мы, супрацоўнікі, прызнаюць паведамленне пра памылку, што вы выпрабоўваеце, мы будзем старацца, каб справакаваць вас з некаторымі рытарычныя пытанні, з некаторымі парадамі, гэтак жа, як TF або CA ці сябе будзе рабіць асабіста ў працоўны час. 

Так што глядзіце, каб help50, калі вы гэтага не зробіце абавязкова прызнаюць праблему. Але не спадзявацца на яго занадта шмат, як мыліца. Вядома, паспрабаваць зразумець яго вываду, а затым атрымаць з яго так што толькі адзін ці два разы ці не так калі-небудзь запусціць help50 для канкрэтнай памылкі паведамленне. Пасля гэтага, вы павінны быць лепш абсталяваныя сябе каб высветліць, што гэта на самай справе. 

Давайце зробім адзін іншы тут. Дазвольце мне ісці наперад, а ў іншым файл, які мы будзем называць гэты buggy1.c. І ў гэтым файле я збіраецца deliberately-- але рабіць выгляд, што я не раблю зразумець, што памылка, якую я зрабіў. 

Я збіраюся ісці наперад і рабіць this-- #include, так як я даведаўся, што мой ўрок з хвіліну таму. Int асноўных (несапраўднымі), як і раней. І тады тут я іду зрабіць радок з - get_string. І памятаеце з апошняга часу, гэта азначае, эй, кампутар, дайце мне зменную, называем гэта S, і зрабіць тып гэтай зменнай радковыя так што я магу захоўваць адно або некалькі слоў у ім. 

А потым на правай руцэ бок знака роўнасці з'яўляецца get_string, якая з'яўляецца функцыя ў бібліятэцы CS50 што робіць менавіта гэта. Ён атрымлівае функцыю, а затым рукі яго справа налева. Так што гэты знак роўнасці не азначае, "Роўна", як мы маглі б думаць у матэматыцы. Гэта азначае прызначэнне справа налева. Такім чынам, гэта азначае, узяць радок з карыстальнік і захоўваць яго ўнутры с. 

Зараз давайце выкарыстоўваць яго. Дазвольце мне ісці наперад цяпер і ў якасці другога лінія, дазвольце мне ісці наперад і сказаць "прывітанне" - ня "свет", але "Прывітанне,% S-- якая з'яўляецца нашым запаўняльнікам, коска s, якая з'яўляецца нашай зменнай, а затым кропка з коскі. Так што, калі я не закручваць занадта шмат тут, гэта выглядае як правільны код. 

І мае інстынкты цяпер скампіляваць яго. Файл называецца buggy1.c. Так што я збіраюся зрабіць зрабіць buggy1, Enter. І цыраваць-то, калі няма нават больш памылак, чым раней. Я маю на ўвазе, ёсць больш Паведамленні пра памылкі гэта было здаецца, чым фактычныя лініі ў гэтай праграме. 

Але ежа на дом тут, нават калі вы перагружаныя з двума ці трыма ці яшчэ чатыры паведамленні пра памылкі, фокус заўсёды на вельмі Першы з гэтых паведамленняў. Гледзячы на ​​самы верхні адзін, пракруткі назад уверх, як гэта будзе неабходна. Дык вось я надрукаваў касметыку buggy1. Вось што выхад Clang, як і чакалася. 

І вось першая чырвоная памылка. Выкарыстанне неаб'яўленай ідэнтыфікатара Радок, я маю на ўвазе стандарт у? Так стандарт з'яўляецца на самай справе нешта іншае. Гэта ставіцца да карыстальніка клавіятура, па сутнасці. 

Але гэта не тое, што я меў на ўвазе. Я меў на ўвазе радок, і я меў на ўвазе get_string. Дык што ж гэта, што я забыўся зрабіць на гэты раз? Чаго не хапае на гэты раз? У мяне ёсць #include, таму ў мяне ёсць доступ да Printf. 

Але што ў мяне няма доступ да толькі што яшчэ? Ну, гэтак жа, як у мінулы раз, Я павінен сказаць кампілятар Ляскам, што гэтыя функцыі. Get_string не прыходзіць з С. І ў прыватнасці, яго не прыходзіць у загалоўку файла. Замест гэтага ён прыходзіць у нешта супрацоўнікі пісалі, які ўяўляе сабой іншы файл імя, але трапна назваў. 

Так, проста дадаўшы, што адной лініі з code-- адклікання ад апошняга часу што пры запуску Clang, гэта будзе паглядзець на мой код зверху ўніз, злева направа. Гэта будзе заўважыць, Ах, вы хочаце. Дазвольце мне пайсці і знайсці, што, ўсюды, дзе ён знаходзіцца на сэрвэры, скапіяваць і ўставіць яго, па сутнасці, у верхняй частцы вашага ўласнага файла так што ў гэты момант у гісторыі, лінія 1, астатняя частка праграмы можа, на самай справе, можна выкарыстоўваць любы з функцый у ім, сярод іх get_string. Так што я збіраюся ігнараваць астатнія з гэтых памылак, таму што я, на самай справе, падазраю, што толькі першы на самай справе мела значэнне. І я збіраюся ісці наперад і перакладка, пасля захавання майго файла зрабіць buggy1. І вуаля, ён зрабіў працу. А калі я ./buggy1 і ўвядзіце, для асобнік, Zamyla, я зараз атрымаць прывітанне, Zamyla, а не прывітанне, свет. 

Добра. Дык вось тады вынас павінны, адзін, старайцеся падбіраць столькі, колькі вы можаце ад паведамленняў пра памылкі ў адзіночку, гледзячы на некаторых з распазнаюцца слоў. Калі выключыць, што выкарыстоўваць help50 за праблема ўсталяваць спецыфікацыі. Але за выключэннем гэтага таксама, заўсёды звяртайце ўвагу толькі ў верхняй памылкі, па меншай меры, на пачатковым этапе, каб убачыць, якую інфармацыю ён можа на самай справе выхад. Але аказваецца, што ёсць нават больш функцыянальных магчымасцяў убудаванай у бібліятэку CS50, каб дапамагчы вы на раннім этапе ў семестр і на ранняй стадыі ў праграмаванні высветліць, што адбываецца не так. Дык давайце зробім яшчэ адзін прыклад. Я буду называць гэта buggy2, які, зноў жа, будзе сапсаваны з варот, па дызайне. 

І я збіраюся ісці наперад і рабіць #include. А потым я збіраюся зрабіць Int асноўны (вакуум). А потым я збіраюся зрабіць цыкл. Для (INT I _ 0. Я менш або роўна 10. я ++, а затым у фігурныя дужкі, я іду раздрукаваць толькі сімвал хэштэгу тут і сімвал новага радка. 

Такім чынам, мой намер з гэтым Праграма дастаткова проста ітэрацыю ў 10 разоў і на кожнай ітэрацыі з гэтага цыклу кожны раз праз цыкл, раздрукаваць хэштэгу, хэштэгу, хэштэгу. Па адным у радку, таму што я маюць новую лінію там. І нагадаем, што для пятля, за апошні week-- і вы атрымаеце больш знаёмы з сінтаксісам выкарыстоўваючы яго з практыкай Перад long-- гэта дае мне пераменная называецца I і ўстанаўлівае яго ў 0. 

Гэта павялічвае I на кожнай ітэрацыі на 1. Так што я ідзе да 1 да 2 да 3. І тады гэта ўмова ў пасярэдзіне паміж кропкамі з коскі атрымлівае правяраецца на кожнай ітэрацыі, каб зрабіць упэўнены, што мы ўсё яшчэ ў межах дыяпазону. Так што я хачу ітэрацыю ў 10 разоў, так што я маюць выгляд вельмі інтуітыўна проста пакласці 10, як мая верхняя мяжа там. 

І ўсё ж, калі я запускаю гэта, пасля таго, як кампіляцыі з указаннем маркі buggy2-- і яна кампілюецца ОК. Так што я не маюць памылка сінтаксісу ў гэты раз. Дазвольце мне ісці наперад прама цяпер і запусціць buggy2, Enter. А цяпер выканайце прагортку уверх. І дазвольце мне павялічыць памер акна. 

Я, здаецца, ёсць 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Так што 11 хештегов, нягледзячы на ​​тое, Я выразна паставіў 10 ўнутры гэтага цыклу. Зараз, некаторыя з вас могуць убачыць адразу што памылка адбываецца таму, што, на самай справе, гэта гэта не вельмі цяжка памылка зрабіць. Але гэта вельмі часта зрабіў вельмі рана. 

Тое, што я хачу адзначыць, аднак, у тым, як я мог бы зразумець гэта? Што ж, атрымліваецца, што CS50 бібліятэка прыходзіць з не толькі get_string і get_int і get_float і іншыя функцыі. Ён таксама пастаўляецца са спецыяльнай функцыяй называецца eprintf, або, памылка Printf. І існуе толькі зрабіць гэта крыху прасцей для вас пры адладцы кода проста выводзіць паведамленне пра памылку на экране і ведаю, адкуль яна ўзялася. 

Так, напрыклад, адна рэч, якую я мог бы тут рабіць з гэтай функцыяй з'яўляецца this-- eprintf, а затым я збіраюся ісці наперад і сказаць, што я цяпер% я, зваротны слэш, п. І я збіраюся падключыць да значэння I. І наверсе, таму што гэты знаходзіцца ў бібліятэцы CS50, Я збіраюся ісці наперад і ўключаюць у сябе таму ў мяне ёсць доступ да гэтай функцыі. Але давайце разгледзім, што лінія 9 мяркуецца рабіць. Я збіраюся выдаліць гэта ў рэшце рэшт. Гэта не мае нічога агульнага з маёй галоўнай мэты. Але eprintf, памылка Printf, проста азначае, каб даць мне некаторую дыягнастычную інфармацыю. Калі я запускаю маю праграму, я хачу ўбачыць гэта на экране часова а проста зразумець, што адбываецца. 

І на самай справе, на кожным ітэрацыя тут лініі 9 Я хачу бачыць, якая велічыня I? Што такое значэнне I? Што такое значэнне I? І, спадзяюся, я павінен толькі бачыць, што паведамленне, акрамя таго, у 10 разоў. 

Такім чынам, дазвольце мне ісці наперад і перакампіляваць маю праграму, як я павінен рабіць у любы час Я ўнесці змены. ./buggy2. І now-- OK. Там вельмі шмат больш адбываецца. Такім чынам, дазвольце мне прагартаць уверх яшчэ большае акно. 

І вы ўбачыце, што кожны з Hashtags па-ранейшаму друку. Але паміж кожным з іх у цяперашні час гэты дыягнастычны выснову адфарматаваны наступным чынам. Назва маёй праграмы тут з'яўляецца buggy2. Імя файла buggy2.c. Нумар радка, з якой гэта было надрукавана ў радку 9. А потым справа, што з'яўляецца паведамленне пра памылку, што я чакаў. 

І што прыемна пра гэта заключаецца ў тым, што Цяпер я не павінен абавязкова разлічваць ў маёй галаве, што мая праграма робіць. Я бачу, што на Першая ітэрацыя я = 0, затым 1, затым 2, затым 3, затым 4, затым 5, затым 6, затым 7, затым 8, то 9, то, 10. Так, пачакайце хвіліну. Што тут адбываецца? Я да гэтага часу, здаецца, лічачы як задумана да 10. 

Але дзе ж мне пачаць? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. Такім чынам, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11-й палец сведчыць аб праблеме. Я, здаецца, падлічылі няправільна ў маім цыкле. Замест таго, каб ісці 10 ітэрацый, Я пачынаючы з 0, Я і заканчваючы праз 10. Але, так як, як кампутар, Я пачынаю адлік з 0, Я павінен быць падлічваючы да, але не да канца, 10. 

І таму выпраўленне, я ў рэшце рэшт тут рэалізуецца, з'яўляецца адной з двух рэчаў. Я мог бы вельмі проста сказаць, злічыць да менш за 10. Такім чынам, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, якая з'яўляецца, па сутнасці, дакладна, нягледзячы на ​​тое, што гэта гучыць трохі няправільна. Ці я мог бы зрабіць менш або роўна да 9, да таго часу, як я пачынаю з 0. Ці, калі вы сапраўды не падабаецца, што ты можа разлічваць праз 10, але пачынаюцца з 1. Але зноў жа, гэта проста не так часта. У programming-- хоць і не столькі ў Scratch-- але пры праграмаванні ў C і іншых мовах, як JavaScript і Python і іншыя, гэта проста вельмі часта для наша абмеркаванне бінарная каб проста пачаць адлік на найменшая колькасць вы можаце, што 0. Добра. Дык вось eprintf. І зноў жа, зараз, калі я зразумеў, што я Праблема, і я збіраюся вярнуцца да 0 праз менш чым 10, я збіраюся пайсці і выдаліць eprintf. 

Яно не павінна быць там, калі я адправіць мой код або адправіць свой код або паказаць яго каму-небудзь яшчэ. Гэта сапраўды проста меў на ўвазе якія будуць выкарыстоўвацца часова. Але цяпер я гэта выправіў Асаблівай праблемай, а таксама. 

Што ж, давайце зробім яшчэ адзін прыклад тут што я буду нагнятаць наступным чынам. Я збіраюся ісці наперад і #include. $ 50 І я збіраюся ісці наперад і #include. 

І я збіраюся захаваць гэты файл у якасці buggy3.c. І я збіраюся ісці наперад і аб'явіць Int асноўны (вакуум). А потым ўнутры там Я збіраюся зрабіць INT I _ - Я хачу, каб рэалізаваць праграму з get_negative_int. Гэта не функцыя, якая існуе да гэтага часу. Такім чынам, мы збіраемся рэалізаваць гэта ўсяго імгненне. Але мы будзем бачыць, чаму ён памылковы на першым праходзе. І як толькі я атрымаў выклічце перапыненне ад карыстальніка, Я проста хачу, каб надрукаваць% I з'яўляецца адмоўным цэлым лікам, патрэбна ўжыць зваротны слэш, п, коска, я. Іншымі словамі, усё, што я хачу гэтую праграму, каб зрабіць гэта атрымаць адмоўнае Int з карыстальнік, а затым раздрукаваць што такі негатыўны Int. 

Цяпер мне трэба рэалізаваць гэтую функцыю. Так што пазней у маім файле, я збіраюся пайсці наперад і абвясціць функцыю пад назвай get_negative_int (пустата) - і мы вярнуцца да таго, што азначае, што лінія зноў у moment-- Int N; do-- рабіць following-- Printf п:. А потым я збіраюся зрабіць п - get_int, і зрабіць гэта ў той час як п больш 0. А потым вярнуцца п;. 

Так што ёсць шмат адбываецца ў не гэта, але ні адзін з якіх мы не рабілі паглядзіце на апошні тыдзень, па меншай меры, на кароткі час. Так што ў радку 10 тут я аб'яўлены Функцыя называецца get_negative_int, і я паставіў (пустата), у круглыя ​​дужкі, па той прычыне, гэта ня прымае ўваходны сігнал. Я нічога не прапускаючы да гэтай функцыі. Я проста атрымліваю нешта ад яго. 

А што я спадзяюся атрымаць назад цэлае. Там няма тып дадзеных C называецца negative_int. Гэта проста Int, так што гэта будзе каб быць на нас, каб пераканацца, што значэнне, якое на самай справе Вяртаецца не толькі INT але таксама адмоўна. 

У радку 12 я абвяшчаю зменную называецца п і робіць яго тыпу Int. А затым у радку 13 да 18 Я рабіць што-то ў той час як-то дакладна. Я іду наперад і друк п, двукроп'е, а затым прабел, як падказку для карыстальніка. 

Я затым выклікаць get_int і захоўваць яго так званае вяртаецца значэнне ў гэтай зменнай п. Але я буду працягваць рабіць гэта ў той час як п больш 0. Іншымі словамі, калі карыстальнік дае мне Int і гэта лік больш 0, эрга, станоўчы, я збіраюся проста трымаць reprompting карыстальніка, трымаць reprompting, прымушаючы іх супрацоўнічаць і дайце мне адмоўны вынік Int. 

І як толькі п на самай справе negative-- Выкажам здагадку, што карыстальнік нарэшце тыпу -50, то гэта не ў той час як цыкл ўжо не так таму што -50 не больш за 0. Такім чынам, мы парушаем з гэтага пятля лагічна і вярнуцца п. 

Але ёсць яшчэ адна што я павінен рабіць. І я магу проста зрабіць гэта шляхам капіявання і ўстаўкі Адзін радок кода ў верхняй частцы файла. Мне трэба, каб навучыць Clang, або абяцанне ляскам, відавочна, што я буду, на самай справе, пайсці і ажыццявіць гэтая функцыя get_negative_int. Гэта можа быць проста ніжэй у файле. Зноў жа, нагадаем, што Clang чытае рэчы зверху ўніз, злева направа, так што вы не можаце выклікаць функцыю, калі Clang не ведае, што гэта будзе існаваць. 

Цяпер, на жаль, гэтая праграма, так як некаторыя з вас маглі заўважыць, ўжо глючыць. Дазвольце мне ісці наперад і зрабіць buggy3. Ён збірае, так што мая праблема цяпер не памылка сінтаксісу, як тэкставай памылкі, гэта на самай справе будзе лагічным памылка, што я наўмысна зрабіў як магчымасць пакрокава, што адбываецца. 

Я збіраюся ісці наперад Цяпер і запусціць buggy3. І я збіраюся пайсці наперад, а не супрацоўнічаць. Я збіраюся даць яму нумар 1. Гэта не спадабалася, так гэта мяне зноў абуджаючы. 

Як наконт 2? 3? 50? Ні адзін з іх не працуюць. Як наконт -50? І праграма, здаецца, працуе. 

Дазвольце мне паспрабаваць яшчэ раз. Дазвольце мне паспрабаваць -1, здаецца, працуе. Дазвольце мне паспрабаваць -2, здаецца, працуе. Дазвольце мне паспрабаваць 0. Так, гэта няправільна. Цяпер мы, будучы трохі педантычным тут. Але гэта, на самой справе, так што 0 не з'яўляецца ні станоўчым, ні адмоўным. І таму той факт, што мая праграма кажучы, што 0 з'яўляецца адмоўным цэлым лікам, гэта не тэхнічна правільна. 

Цяпер, чаму ён гэта робіць? Ну, гэта можа быць відавочным. І, сапраўды, праграма меў на ўвазе, каб быць досыць простым таму ў нас ёсць што-то, каб даследаваць. 

Але давайце ўвядзем трэцюю адладку Тэхніка тут называецца debug50. Так што гэта праграма што мы толькі што стварылі У гэтым годзе пад назвай debug50 што дазволіць вам выкарыстоўваць тое, што называецца убудаваным графічны адладчык ў CS50 IDE. І адладчык проста праграма, якая як правіла, дазваляе запускаць праграму але крок за крокам за крокам, лініі па лініі па лініі, робячы паўзу, тыкаючы вакол, гледзячы на ​​пераменныя, так што праграма не проста ўдар міма вас і хутка надрукаваць што-небудзь ці не надрукаваць што-небудзь. Гэта дае магчымасць, у чалавечая хуткасць, каб ўзаемадзейнічаць з ім. 

І зрабіць гэта, вы проста зрабіце наступнае. Пасля кампіляцыі кода, якія я ўжо зрабіў, buggy3, вы ідзяце наперад і запусціць debug50 ./buggy. Гэтак жа, як help50 мае запуску help50, а затым каманда, debug50 мае запусціць debug50 і то імя каманды. 

Цяпер паглядзім, што адбываецца на маім экране, на правай баку, у прыватнасці. Калі я ударыў Выканаць, усё раптоўная панэль гэтая правая адкрывае на экране. І ёсць шмат чаго адбываецца на на першы погляд. Але есці не занадта шмат прычын для турботы пакуль няма. 

Гэта паказвае мне ўсё што адбываецца ўнутры маёй праграмы прама зараз, і праз іх Кнопкі уверх верхняй затым што дазволіла мне прайсці праз мой код у канчатковым выніку крок за крокам за крокам. Але не толькі пакуль. Звярніце ўвагу на тое, што адбываецца. У маім акне тэрмінала Я запыту на ўвод п. І я збіраюся ісці наперад і супрацоўніцтва на гэты раз і ўвядзіце -1. І хоць і трохі загадкава, -1 з'яўляецца адмоўным цэлым лікам, як і варта было чакаць. 

І тады дзіця выйшаў з Статус 0 GDBserver выхаду. GDB, GNU Debugger, гэтае імя Яно ляжыць у аснове праграмнага забеспячэння які рэалізуе гэты адладчык. Але ўсё гэта на самай справе азначае, адладчык пайшоў, таму што мая праграма кінуць паліць і ўсё было добра. Калі я хачу, каб сапраўды адладжваць праграму, Я павінен сказаць, прэвентыўна debug50, дзе я хачу, каб пачаць пакрокавага мой код? 

І, мабыць, самы просты спосаб зрабіць гэта наступным чынам. Калі я лунаць над Жолаб майго рэдактара тут, так на самой справе проста ў бакавой панэлі тут, злева ад нумара радка, Звярніце ўвагу, што, калі я проста націсніце адзін раз, я стаўлю маленькую чырвоную кропку. І гэтая маленькая чырвоная кропка, як знак прыпынку, значыць, эй, debug50, выкананне паўзы майго кода прама там, калі я запусціць гэтую праграму. 

Дык давайце зробім гэта. Дазвольце мне ісці наперад і запусціць маю праграму зноў з debug50 ./buggy3, Enter. А цяпер, звярніце ўвагу, што-то інакш адбылося. Я не запыт ўсё ж у маім акне тэрмінала ні за што, таму што ў мяне няма атрымаў там яшчэ ў маёй праграме. Звярніце ўвагу на тое, што ў радку 8 які ў цяперашні час выдзелены, і ёсць маленькая стрэлка левая выслоўе, ты спыніўся тут. Гэты радок кода, радкі 8, да гэтага часу не выканана. 

І што цікава, калі я гляджу тут на правай баку, звярніце ўвагу, што я з'яўляецца лакальным зменная, лакальная у тым сэнсе, што ён унутры бягучай функцыі. І яго значэнне, па-відаць, па змаўчанні, і быццам зручна, роўна 0. Але я не тып 0. Гэта як раз здараецца быць яго Значэнне па змаўчанні ў дадзены момант. 

Такім чынам, дазвольце мне ісці наперад і рабіць гэта зараз. Дазвольце мне ісці наперад і на у правым верхнім куце тут, я ісці наперад і націсніце гэтую першую абразок, якая азначае крок, над якім азначае не прапусціць гэта, але пераступіць гэты радок кода, выконваючы яго па шляху. 

А цяпер звярніце ўвагу, што я хуткае толькі што змяніў. Чаму гэта? Я сказаў debug50, запусціць гэты радок кода. Што робіць гэты радок кода рабіць? Запытвае мяне на міжнар. ДОБРА. Дазвольце мне супрацоўнічаць. Дазвольце мне ісці наперад зараз і ўвядзіце -1, Enter. А цяпер звярніце ўвагу, што змянілася. З правага боку, мая лакальная пераменная я пазначаецца як -1 ў цяперашні час. І гэта ўсё ж такі тыпу Int. 

І заўважце, таксама, мой так званы стэк выклікаў, дзе ж я паўзу? Мы будзем казаць больш пра гэта ў будучыні. Але стэк выклікаў проста спасылаецца на тое, што функцыі ў цяперашні час у руху. Цяпер гэта проста галоўны. І цяпер адзіны мясцовы пераменная I са значэннем 1. 

І калі я, нарэшце, крок па гэтай лініі тут, з той жа значок у правым верхнім куце, -1 З'яўляецца адмоўным цэлым лікам. Цяпер ён затрымаўшыся над гэтым фігурнай дужкай. Давайце хай гэта робяць сваю справу. Я пераступіць гэты радок, і вуаля. 

Так што не ўсё, што жудасна павучальна ўсё ж, але гэта дазвольце мне зрабіць паўзу і думаю, што праз лагічна што гэтая праграма робіць. Але гэта не было памылковым выпадкам. Давайце зробім гэта зноў наступным чынам. 

Я збіраюся пакінуць гэты пункт супыну у радку 8 з чырвонай кропкай. Я збіраюся паўторна запусціць debug50. Гэта аўтаматычна прыпыняецца тут. Але на гэты раз, замест таго, пераступаючы праз гэтую лінію, дазвольце мне на самай справе ісці ўнутры get_negative_int і высветліць, чаму гэта прыняцце 0 ў якасці сапраўднага адказу? 

Такім чынам, замест таго, каб націснуць Step Over. Я збіраюся ісці наперад і націсніце кнопку Step Into. І да вашага ведама, што лінія 8 гэта цяпер вылучаецца зараз раптам становіцца радок 17. 

Цяпер, гэта не значыць, што адладчык прапусціў лініі 14 і 15, і 16. Гэта не проста там нічога каб паказаць вам там. Тыя аб'явы зменных, а затым там слова Do а затым адкрытая фігурная дужка. Толькі функцыянальная лінія, гэта сакавіты сапраўды гэты тут, 17. І вось дзе мы аўтаматычна прыпыняецца. 

Так што Е ( "n.is:");, так што да гэтага часу не адбылося. Так што давайце ісці наперад і націсніце кнопку Step Over. Цяпер мой запыт, на самай справе, зменены ( "п:"). Цяпер get_int, я не збіраюся турбаваць ўступаем, таму што функцыя была зробленыя CS50 ў бібліятэцы. Гэта, верагодна, правільна. 

Так што я збіраюся ісці наперад і свайго роду супрацоўніцтва, надаўшы яму выклічце перапыненне, але не з'яўляецца адмоўным Int. Такім чынам, дазвольце мне ісці наперад і ўдарыў 0. А цяпер, што адбываецца тут калі я атрымліваю ўніз да лініі 21? Я не итерироваться зноў. Я, здаецца, не затрымаецца ў гэтым цыкле. Іншымі словамі, гэты жоўты бар ня будзе трымаць вакол, і вакол, і вакол яго. 

Цяпер, чаму гэта? Што ж, п, што роўна п прама цяпер? Я магу глядзець на мясцовым Зменныя ў адладчык. п роўна 0. Добра, што гэта было маё стан? 

20-- лінія 20, ну, 0 больш 0. Гэта не так. 0 не больш за 0. І таму я вырвалася з гэтага. 

І вось чаму на лініі 21, калі я на самай справе па-ранейшаму, Я збіраюся вярнуць 0, нават хоць я павінен быў адпрэчана 0 а на самой справе не з'яўляецца адмоўным. Так што цяпер, я не вельмі нават клапаціцца аб адладчыка. Зразумеў, я не трэба ведаю, што яшчэ адбываецца. 

Так што я збіраюся ісці наперад і проста націсніце кнопку прайгравання, і хай гэта скончыць. Цяпер я зразумеў, што мой памылка па-відаць, у радку 20. Гэта мая лагічная памылка. 

І вось, што я хачу трэба зрабіць, каб змяніць гэта? Калі праблема заключаецца ў тым, што я не лавіць 0, гэта проста лагічная памылка. І я магу сказаць, у той час як у я больш або роўна 0, трымаць зноў і зноў запытваючы карыстальніка. 

Так што, зноў жа, простая памылка, магчыма, нават відавочна, калі вы бачылі мяне напісаць гэта ўсяго некалькі хвілін таму. Але тут вынас з'яўляецца тое, што пры адладцы 50, і з адладкай праграмнае забеспячэнне ў больш агульным плане, ў вас ёсць гэта новае харчаванне прайсці праз свой уласны код, глядзіце з дапамогай гэтай правай панэлі, што зменныя значэння. Такім чынам, вы не абавязкова павінны выкарыстоўваць нешта як вы eprintf друкаваць гэтыя значэння. Вы можаце ўбачыць іх візуальна на экране. 

Цяпер, апроч гэтага, варта адзначыць, што ёсць іншая тэхніка, якая на самай справе вельмі распаўсюджанай з'явай. І вы маглі б задацца пытаннем, чаму гэты маленькі хлопец тут сядзеў на сцэне. Так што ёсць гэтая тэхніка, як правіла, вядомы як метад качаняці, які на самай справе гэта проста сведчаннем таго, што часта, калі праграмісты напісанні кода, яны не абавязкова супрацоўнічаючы з іншымі, або працаваць у агульнай асяроддзі. 

Яны накшталт дома. Можа быць, гэта позна ўначы. Яны спрабуюць фігуры некаторыя памылкі ў сваім кодзе. І яны проста не бачыць. 

І няма ніякага суседа па пакоі. Там няма TF. Там няма CA вакол. Усе яны маюць на сваёй паліцы гэтая маленькая гумавая уточка. 

І таму адладка гумавая качка проста гэта запрашэнне думаць пра што-то, як па-дурному так як гэта як рэальнае істота, і на самай справе прайсці праз ваш код ў вуснай форме да гэтага неадушаўлёны аб'ект. Так, напрыклад, калі гэта мой прыклад here-- і нагадаем, што раней праблема была ў гэтым, калі я выдалю гэтую першую радок кода, і я іду наперад і зрабіць багі 0 раз, Нагадаем, што ў мяне былі гэтыя Паведамленні пра памылкі тут. Так што ідэя тут, смешна, хоць я адчуваю ў дадзены момант робіць гэта публічна, з'яўляецца тое, што памылка. 

ОК, так што мая праблема ў тым, што я няяўна бібліятэчную функцыю. І гэтая функцыя бібліятэкі Printf. Declare-- OK, абвясціць нагадвае мне пра прататыпах. 

Гэта азначае, што мне трэба на самай справе паведаміць кампілятару загадзя, што функцыя выглядае наступным чынам. Пачакай хвіліну. У мяне не было стандартнага io.h. Вялікі дзякуй. 

Так што гэты працэс of-- вас ня трэба на самой справе ёсць качка. Але гэтая ідэя хадзіць самастойна праз свой уласны код так што вы нават чуць самастойна, так што вы рэалізаваць хібы ў свой уласны заўвагі, як правіла, ідэя. 

І, магчыма, больш лагічна, не так шмат з гэтым адзін, але больш актыўны ўдзел Прыклад, які мы толькі што зрабілі ў багі 3.c, Вы маглі б хадзіць сябе праз яго наступным чынам. Так што ўсё ў парадку, гума душка, DDB, калі вы будзеце. Тут мы маем на сваёй асноўнай функцыі, Я тэлефаную атрымаць адмоўны вынік Int. 

І я атрымліваю вяртаецца значэнне. Я захоўваць яго на левым баку у радку 8 у зменнай называецца I. Добра, але чакаць, як зрабіў што атрымаць гэта значэнне? Дазвольце мне зірнуць на функцыі ў радку 12. 

У радку 12 мы маем атрымаць адмоўную Int. Не прымаць якія-небудзь матэрыялы, гэта вяртае Int, OK. Я заяўляю, у радку 14 пераменная п. Гэта будзе захоўваць цэлы лік. Вось што я хачу. 

Так зрабіце наступнае: Калі п is-- хай мне адмяніць тое, што выпраўленне я ўжо зрабіў. Такім чынам, у той час як у я больш 0, раздрукаваць п, OK. А затым выклічце атрымаць INT захоўваецца ў п. А затым праверце, калі п = 0, п не-- там. Так што, зноў жа, вы гэтага не зробіце патрэбен фактычны качка. Але проста хадзіць самастойна праз ваш код як інтэлектуальнае практыкаванне часта дапаможа вам ўсвядоміць, што адбываецца, а не проста рабіць нешта як гэта, гледзячы на ​​экран, і не казаць сябе праз тое, што гэта не сумленна амаль як эфектыўны метад. Так што ў вас ёсць, A колькасць розных метадаў для фактычна адладкі кода і прыдзірацца, усе з якіх павінны быць інструменты ў ваш інструментар так што вы не позна ўначы, асабліва, вы ў сталовай залы, або ў непрацоўны час, б'ешся галавой супраць сцены, спрабуючы вырашыць некаторыя праблемы. Разумеюць, што ёсць праграмныя сродкі. Ёсць гумовая качка інструменты. І ёсць цэлы штат падтрымкі чакаюць, каб працягнуць руку дапамогі. 

Так што цяпер, слова па праблеме наборы, а таксама на тое, што мы спадзяемся, што вам выйсці з іх, і як мы ідзем аб ацэнцы. За навучальны план Курсу, CS50 мноства праблем у ацэньваюцца па чатырох асноўных восях, так каб speak-- сферу, карэктнасць, дызайн, і стыль. І сфера проста ставіцца да таго, колькі кавалка вы адкусілі? Колькі праблемы вы спрабавалі? Які ўзровень намаганняў Вы выяўлялася? 

Карэктнасць, працуе праграма, як ён павінен паводле спецыфікацыі CS50 калі вы дае пэўныя ўваходы або пэўныя выхады вяртаюцца? Дызайн з'яўляецца найбольш суб'ектыўным з іх. І гэта той, які будзе ўзяць самы доўгі, каб даведацца, і самы доўгі, каб выкладаць у да гэтага часу, як гэта зводзіцца да таго, як добра напісана ваш код? 

Гэта адна рэч, каб проста надрукаваць правільны выхады або вяртаць правільныя значэння. Але вы робіце гэта як эфектыўна, наколькі гэта магчыма? Вы робіце гэта разрыў і ўладар, або двайковы Пошук, як мы хутка ўбачым, што мы зрабілі два тыдні таму з тэлефоннай кнігай? Ці існуюць больш эфектыўныя спосабы вырашэння праблема, чым цяпер у вас тут? Гэта магчымасць для лепшага дызайну. 

А потым, як style-- даволі ваш код? Вы заўважыце, што я даволі прыватнасці аб водступаў мой код, і пераканаўшыся, што мае зменныя абгрунтавана названыя. п, у той час як кароткія, добрае імя для нумар, я для падліку ліку, s для радка. І мы можам мець больш імёны зменных стылю. Стыль, наколькі добра выглядае ваш код? А як чытаны гэта? 

І з цягам часу, чым вашы TAs і ТФ будзе рабіць у працэсе гэта прадаставіць вам, што выгляд якаснай зваротнай сувязі так што вы атрымаеце лепш ў гэтых розных аспектах. І з пункту гледжання таго, як мы ацаніць кожную з гэтых восяў, гэта, як правіла, з вельмі нямногімі вядра, так што вы, як правіла, атрымаць уяўленне аб тым, наколькі добра вы робіце. І сапраўды, калі вы атрымаеце рахунак на любы з гэтых axes-- правільнасць, дызайн і стыль especially--, што колькасць як правіла, складае ад 1 да 5 балаў. І, у літаральным сэнсе, калі вы атрымліваеце 3-х у пачатку семестра, гэта вельмі добрая рэч. Гэта азначае, што ёсць яшчэ магчымасці для паляпшэння, які вы б спадзявацца ў прымаючы клас у першы раз. Там у нейкі, спадзяюся, трохі столі да якога вы імкнуцца да дасягнення. І таму атрыманне 3 па самыя раннія п'есы, калі не які-то 2-х і 4-х, гэта, сапраўды, вельмі добрая рэч. Гэта добра ў межах дыяпазону, добра ў межах чаканняў. 

І калі ваш розум імчыцца, пачакайце хвіліну, тры з пяці. Гэта сапраўды 6 з 10. Гэта 60%. Божа мой, гэта на літару F. 

Гэта не. Гэта не так, на самай справе, гэта. Хутчэй за ўсё, гэта магчымасць палепшыць на працягу семестра. І калі вы атрымліваеце некаторыя Poors, гэта магчымасць каб скарыстацца офіснымі гадзінамі, вядома ж раздзелы і іншыя рэсурсы. 

Лепш гэта магчымасць, на самай справе, можна ганарыцца, наколькі далёка вы прыходзяць на працягу семестра. Гэтак жа разумееш, калі нічога яшчэ тры добра. І гэта дазваляе для росту з цягам часу. 

Што тычыцца таго, як гэтыя восі узважанае, рэальна вы збіраецца выдаткаваць большую частку свайго часу атрымання рэчы, каб працаваць, не кажучы ўжо правільна. І таму, як правіла, карэктнасць узважвацца больш за ўсё, як і з гэты мультыплікатыўны фактар ​​трох. Дызайн таксама мае важнае значэнне, але тое, што вы не абавязкова марнаваць ўсё тыя гадзіны, на спрабуючы атрымаць рэчы проста працаваць. 

І такім чынам гэта ўзважаны крыху больш за злёгку. А потым стыль важыцца па меншай меры. Нягледзячы на ​​тое, што гэта не менш важна фундаментальна, гэта проста, можа быць, Прасцей за ўсё зрабіць правільна, імітуючы прыклады, якія мы рабіць у лекцыі і секцыі, з рэчамі прыгожа водступам, і пракаментаваў, і гэтак далей з'яўляецца адным з самых простых рэчы, каб зрабіць і атрымаць права. Так як такія, рэалізаваць што тыя кропкі што адносна лёгка зразумець. 

А цяпер слова на this-- акадэмічнай сумленнасці. Такім чынам, за Курса навучальны план, вы ўбачыце што курс мае даволі трохі мовы вакол гэтага. І вядома ж бярэ пытанне акадэмічная сумленнасць цалкам сур'ёзна. 

У нас ёсць адрозненні, да лепшага ці да горшага, з даслаўшы кожны год больш студэнтаў для прыняцця дысцыплінарных мер чым большасць любы іншы Вядома ж, што я ведаю. Гэта не абавязкова сведчыць пра тое, што студэнты CS або CS50 студэнтаў, з'яўляюцца менш больш сумленна сваіх аднакласнікаў. Але рэальнасць, што ў гэтым свет, у электронным выглядзе, мы проста ёсць тэхналагічная сродак выяўлення гэтага. 

Гэта вельмі важна для нас для справядлівасць па класе што мы робім гэта выявіць і падняць пытанне, калі мы бачым рэчы. І як раз, каб намаляваць карціну, а на самай справе каб дапамагчы нешта накшталт гэтага ў ракавіне, гэты лік Студэнты на працягу апошніх 10 гадоў якія былі ўцягнутыя ў некаторыя такія пытанні акадэмічнай сумленнасці, з некаторымі 32 студэнтаў з восені 2015 года, якая павінен сказаць, што мы прымаем справа вельмі сур'ёзна. І, у канчатковым рахунку, гэтыя лічбы складаюць, Зусім нядаўна, каля 3%, 4% або каля таго класа. 

Так што для супер большасці студэнтаў здаецца, што лініі выразныя. Але майце гэта на розум, асабліва позна ў начны час, калі змагаецца з нейкае рашэнне для мноства праблем, што існуюць механізмы для атрымання сябе лепш падтрымка, чым вы маглі б думаю, нават у тую ж гадзіну. Разумеюць, што, калі мы атрымліваем студэнцкія прадстаўлення, мы перасякаем параўнаць усе прадстаўлення ў гэтым годзе супраць кожнага прадстаўлення ў мінулым годзе, супраць кожнага прадстаўлення з 2007 года, і так як, гледзячы на, а таксама, код рэпазітароў онлайн, дыскусійных форумах, праца сайтаў. І мы адзначым гэта, на самай справе, усё дзеля поўнага раскрыцця, што калі хто-то можа знайсці яго ў Інтэрнэце, вядома ж, так што мы можам курс. Але, на самой справе, дух з курсу зводзіцца да гэтай артыкуле ў вучэбнай праграме. Гэта сапраўды проста, разумна. 

І калі мы павінны былі спыніцца на гэтым з толькі трохі больш мовы, ўсвядоміць, што сутнасць усіх Праца, якую вы ўявіць гэты курс павінен быць свой уласны. Але ў тым, што ёсць, вядома, магчымасцяў і заахвочванне, і педагагічная каштоўнасць у ператварэнні ў others-- сябе, ССТ, КАС, Тас і іншыя ў класе, для падтрымкі, не кажучы ўжо пра сяброў і суседзі па пакоі, хто вывучаў CS і праграмаванне раней. І таму ёсць дапаможнік для гэтага. А агульнае правіла з'яўляецца this--, калі просяць аб дапамозе, Вы можаце паказаць свой код іншым, але вы не можаце праглядаць іх. Так што нават калі вы ў працоўны час, або ў зале D, ці дзе-небудзь яшчэ працуе над нейкі кавалак набору, працуючы разам з сябрам, які гэта цалкам нармальна, на Канец дня вашай працы у канчатковым выніку павінна належаць кожнаму з вас, адпаведна, і ня быць некаторыя сумесныя намаганні, для канчатковага праекта, дзе акрамя гэта дазваляецца і заахвочваецца. 

Зразумейце, што калі вы змагаецца з чымсьці і ваш сябар толькі што адбываецца каб быць лепш у гэтым, то вы, або лепш на гэтую праблему, чым вы, ці крыху далей наперад, чым вы, гэта цалкам разумна, каб ператварыць свайму сябру і сказаць, эй, Вы не пярэчыце, гледзячы на ​​мой код тут, каб дапамагчы мне вызначыць, што маё пытанне? І, спадзяюся, у Цікавасць педагагічнай каштоўнасці што Віктар не проста кажуць, ах, зрабіць гэта, але, хутчэй, тое, што вы зніклі без вестак на лініі 6, ці нешта падобнае? Але гэтае рашэнне не для сябра побач з вамі сказаць, ой, ну, вось, дазвольце мне цягнуць гэта, і паказаць маё рашэнне для вас. Так што гэта лінія. Вы паказваеце свой код у іншыя, але вы не можаце паглядзець у іх, у адпаведнасці з іншымі абмежаванні ў навучальны план Курса. 

Так што майце на ўвазе, што гэта так званы пункт шкадавання у ходзе вучэбнага плана, а таксама, што калі вы здзейсніце нейкі акт, не з'яўляецца разумным, але давесці яго да увагу кіраўнікоў Курса на працягу 72 гадзін, курс можа накладаць санкцыі, мясцовыя можа ўключаць у сябе нездавальняючым або правальную ацэнку для працы, прадстаўленыя. Але, вядома, не перадасць важна для далейшага прыняцця дысцыплінарных мер, за выключэннем выпадкаў паўторных актаў. Іншымі словамі, калі вы робіце некаторыя па-дурному, асабліва позна ўвечары, рашэнне што на наступную раніцу або праз два дні пазней, вы абудзіцца і ўсвядоміць, пра што я думаў? Вы робіце ў CS50 маюць выхад для фіксацыі гэтай праблемы і валодаць да яго, так што мы сустрэне вас на паўдарогі і справа з ім у пытанні, які з'яўляецца адначасова адукацыйных і каштоўным для вас, але да гэтага часу карны ў некаторым родзе. І зараз, каб замарыць, гэта. 

[ВИДЕОВОСПРОИЗВЕДЕНИЕ] 

[МУЗЫКА] 

[КАНЕЦ засьпяваю] DAVID J. малая: Добра, мы вярнуліся. А зараз мы паглядзім на адзін з першы з нашых рэальных даменаў у CS50, мастацтва крыптаграфіі, мастацтва адпраўкі і атрымання сакрэтныя паведамленні, зашыфраванага паведамленні, калі вы будзеце, якія могуць быць расшыфраваны толькі калі ў вас ёсць некаторыя з ключавых элементаў, што адпраўнік а. Такім чынам, каб матываваць гэтага мы возьмем Паглядзіце на гэтую рэч тут, якая з'яўляецца Примердлительногопребывания сакрэт дэкодэр кольца, можа быць выкарыстаны для таго, каб высветліць, тое, што сакрэтнае паведамленне на самай справе. На самай справе, яшчэ ў дзень у пачатковай школе, калі вы калі-небудзь паслаў сакрэтныя паведамленні некаторыя сябар ці некаторыя цісканіна ў класе, Вы маглі б падумаць, вы былі разумнымі шляхам на вашай частцы замены паперы, як, А да В, і В да С, В і С да D, і гэтак далей. Але вы былі на самай справе шыфравання Ваша інфармацыя, нават калі гэта было трохі трывіяльна, не было што цяжка для настаўніка, каб зразумець, добра, калі вы проста змяніць У да А і С да В, вы на самой справе высветліць, што было паведамленне, але вы былі ў шыфраванні інфармацыі. 

Вы проста рабілі гэта проста, гэтак жа, як Ральф тут у вядомым фільме, які гуляе даволі шмат аб'яў кожную зіму да млоснасці. [ВИДЕОВОСПРОИЗВЕДЕНИЕ] -Будьте Гэта ўсім вядома, што Ральф Паркер Сапраўдным прызначаны членам Маленькай Сіротка Эні Secret Circle і мае права на ўсе ўшанаванні і выгады адбываецца з ім. 

-Signed, Сіротка Эні, сустрэчнае падпісаў П'ер Андрэ, ў чарніла. Ўшанаванні і выгады, ўжо ва ўзросце дзевяці гадоў. 

[Крычучы] -Давай. Давайце скончым з гэтым. Мне не трэба ўсё, што джаз аб кантрабандыстаў і піратаў. 

-Слухай Заўтра ноч завяршальным прыгоды чорнага пірацкага карабля. Цяпер прыйшоў час для сакрэтнае паведамленне Эні для вас члены тайнага гуртка. Памятаеце, дзеці, толькі сябры Эні Сакрэтнай Circle можа расшыфраваць сакрэтнае паведамленне Эні. 

Памятаеце, што Эні залежыць ад вас. Усталюйце штыфты B2. Вось пасланьне. 12, 11-- 

-Я Знаходжуся ў, сваю першую сакрэтную сустрэчу. 

-14, 11, 18, 16. 

-Pierre Быў гучны голас сёння. Я мог бы сказаць, што сёння ўвечары паведамленне было сапраўды важна. 

-3, 25, гэта паведамленне ад самой Эні. Памятаеце, што не кажы нікому. 

-90 Секунд праз, я знаходжуся ў адзінай пакой у доме, дзе дзевяцігадовы хлопчык мог сядзець у адзіноце і дэкадаваннем. Ага, B! Я пайшоў да наступнага, Е. 

Першае слова будзе. S, ён ішоў лягчэй зараз, U, 25-- 

-О, Давай, Ральф, я павінен ісці! 

-Я Зараз спушчуся, Ма! Ну і справы свісту! 

-Т, O, абавязкова пераканайцеся, што, мэтай якіх да чаго? што сіротка Эні спрабуе сказаць? Пераканайцеся, што да чаго? 

-Ralphie, Эндзі трапіў ісці, то, калі ласка, выйсці? 

-Добра, Мама! Я буду прама! 

-Я Становіцца бліжэй. Напружанне было жудасна. Што гэта было? лёс планеты можа вісець на валаску. 

-Ralphie! Эндзі павінен ісці! 

-Я Зараз выйду, для заклікаюць гучна! 

-почти Там, мае пальцы лёталі, мой розум была сталёвая пастка, кожная пара вібраваць. Гэта было амаль ясна, так, так, так. 

-Будьте Абавязкова піць Ovaltine. Ovaltine? Вашывага камерцыйны? Сукін сын. [КАНЕЦ засьпяваю] DAVID J. малая: ОК, так што гэта быў вельмі доўгі шлях ўвядзення крыптаграфію, а таксама Ovaltine. На самай справе, ад гэтага старога аб'яваў тут, чаму Ovaltine так добра? Гэта канцэнтраванае выманне саспелыя ячменны солад, чыстае сметанковае з каровінага малака, і спецыяльна падрыхтаваныя какава разам з прыроднымі фасфатыдаў і вітамінаў. далей узбагачаныя дадатковыя вітаміны групы В і D, ням. І вы ўсё яшчэ можаце атрымаць яго, відаць, на Амазонцы, як мы рабілі тут. 

Але матывацыя тут была ўвесці крыптаграфію, у прыватнасці, тып крыптаграфіі вядомы у якасці сакрэтнага ключа шыфравання. І, як вынікае з назвы, увесь бяспека сакрэтнага ключа сістэмы крыптаграфічнай, калі вы будзеце, метадалогія для скремблирования проста інфармацыя паміж двума людзьмі, у тым, што толькі адпраўнік і атрымальнік толькі ведаць сакрэт key-- нейкую каштоўнасць, некаторыя ўмоўную фразу, нейкі сакрэт лік, што дазваляе ім як зашыфраваць і расшыфраваць інфармацыю. І крыптаграфія, на самай справе, як раз гэта ад тыдня 0. 

Гэта праблема, дзе ёсць ўваходы, як рэальнае паведамленне на англійскай мове або любы іншы мову, які вы хочаце паслаць камусьці ў класе, або праз Інтэрнэт. Існуе некаторы выйсце, якое збіраецца каб быць скремблированный паведамленне, што вы хоча атрымальнік атрымаць. І нават калі нехта ў сярэдні атрымлівае яго таксама, вы не хочаце, каб яны абавязкова быць у стане расшыфраваць яго, таму што ўнутры гэтага чорны скрыню, або алгарытм, гэта нейкі механізм, некаторыя крок за крокам інструкцыі, для прыняцця гэтага ўваходу і ператварэнне яго ў выхад, у спадзяюся бяспечным спосабам. 

І на самай справе, ёсць некаторыя слоўнікавы запас у гэтым свеце наступным чынам. Звычайны тэкст з'яўляецца слова а вучоны будзе выкарыстоўваць для апісання ўваходных паведамленне, як на англійскай або любы іншы мову вы на самай справе хочаце адправіць у нейкі іншы чалавек. І тады шифротекст з'яўляецца звалка да шыфраваных або зашыфраваныя, яго версія. 

Але ёсць яшчэ адзін інгрэдыент тут. Там адзін іншы ўваход Сакрэтны ключ шыфравання. І гэта сам ключ, які, як правіла, як мы ўбачым, лік або літара або слова, незалежна ад алгарытм гэта на самай справе чакае. 

І як вы расшыфраваць інфармацыю? Як вы расшыфроўваць яго? Ну, вы проста павярнуць назад выхады і ўваходы. 

Іншымі словамі, як толькі хто-то атрымлівае ваша зашыфраванае паведамленне, ён ці яна проста мае каб ведаць, што той жа ключ. Яны атрымалі шифротекста. А падлучыўшы гэтыя два ўваходы ў сістэму крыптаграфічнай, алгарытм, гэта чорны скрыню, з павінен прыйсці зыходны адкрыты тэкст. І так што гэта вельмі высокі ўзровень выгляд, што на самой справе крыптаграфія ўсё аб. 

Так што давайце там. Давайце зараз паглядзім пад капот чагосьці мы прымалі як само сабой разумеецца для на мінулым тыдні, і на гэтай сесіі here-- радок. Радок у канцы дня гэта проста паслядоўнасць знакаў. 

Гэта можа быць прывітанне свет, або прывітанне Zamyla, або любы іншы. Але што гэта значыць, што паслядоўнасць знакаў? На самай справе, бібліятэка CS50 дае нам тып дадзеных называецца радком. 

Але ёсць на самой справе няма такая рэч як радок у C. Гэта сапраўды проста паслядоўнасць характар, характар, характар, характар, спіна, да спіны, каб назад, да спіны, каб унутр памяці кампутара ці АЗП. І мы будзем глядзець глыбей, што ў будучыню, калі мы глядзім на саму памяць, і выкарыстанне, і пагрозы, якія ўдзельнічаюць. 

Але давайце разгледзім радок Zamyla. Так што назва чалавек тут, Zamyla, то ёсць паслядоўнасць сімвалы, Z-A-M-Y-L-A. А цяпер давайце выкажам здагадку, што імя Zamyla ў Падчас захавання ўнутры кампутара Праграма. 

Ну, само сабой зразумела, што мы павінны быць у стане глядзець на гэтых персанажаў ў індывідуальным парадку. Так што я проста хачу, каб намаляваць трохі рамку вакол імя Zamyla тут. І гэта адбываецца ў C, што, калі вы ёсць радок, як Zamyla-- і, магчыма, гэты радок вярнулася з функцыя як атрымання радкі, вы можаце маніпуляваць гэта сімвал за сімвалам. 

Цяпер, гэта рэлевантнасці для Размова пад рукой, таму што у крыптаграфіі, калі вы хочаце змяніць А ў У, і В да С, В і С да D, і гэтак далей, вы павінны быць у стане глядзець на асобныя знакі у радку. Вы павінны быць у стане змяніць Зэт да чаго-то яшчэ, А да чаго-то яшчэ, каб М нешта яшчэ, і гэтак далей. І таму нам патрэбен спосаб, праграмным спосабам, так казаць, у C, каб мець магчымасць змяніць і паглядзець на асобныя літары. І мы можам зрабіць гэта наступным чынам. 

Пусці галаву назад у CS50 IDE. І дазвольце мне ісці наперад і стварыць новы файл што я буду называць гэты раз string0, як наш першы такі прыклад, кропка с. І я збіраюся ісці наперад і ўзбіць яго наступным чынам. 

Так ўключаюць CS50.h, і затым уключаюць у сябе стандартныя io.h, які я амаль заўсёды будзе выкарыстоўваць у сваіх праграмах, па меншай меры, на пачатковым этапе. INT галоўную пустэчу, а затым тут я збіраецца рабіць радкі атрымлівае атрымаць радок. А потым я збіраюся ісці наперад і рабіць гэта. Я хачу, каб ісці наперад і, у якасці праверкі наяўнасці свядомасці, проста сказаць, прывітанне, адсоткаў s, коскі, робіць радок 0. Ой, што ж я зрабіў тут? О, я не падключыць яго. Так ўрок, што ня быў наўмысным. 

Так памылка, больш працэнтаў пераўтварэнні, чым аргументы дадзеных. І тут, у лінія 7-- ОК, так што ў мяне ёсць, цытата Unquote, гэта мая радок PRINTF. У мяне ёсць знак адсотка. Але я прапускаю другі аргумент. 

Я прапускаю коскі с, што Я маю на папярэдніх прыкладах. Так добрая магчымасць выправіць яшчэ адна памылка, выпадкова. А цяпер дазвольце мне бегчы string0, тып у Zamyla. Добра, прывітанне Zamyla. 

Такім чынам, мы запускаем гэты від праграмы некалькі розных раз цяпер. Але давайце рабіць нешта крыху па-іншаму ў гэты раз. Замест таго каб проста друк Zamyla-х поўная назва з Printf, давайце зробім гэта сімвал за сімвалам. 

Я збіраюся выкарыстоўваць для цыклу. І я думаю аддаць сябе пераменная падліку, называецца I. І я буду трымаць перабіраюць, так Пакуль я менш, чым даўжыня с. 

Аказваецца, мы не зрабілі зрабіць гэта ў апошні раз, што з пастаўляецца з Функцыя называецца Стырлінга. Назад у дзень, а ў цэлым да гэтага часу пры выкананні функцыяў, людзі часта выбіраюць вельмі ёмістыя імёны, свайго роду гук як тое, што вы хочаце, нават калі гэта не хапае некалькіх галосных гукаў або літар. Так Стырлінга з'яўляецца імя функцыі, якая прымае аргумент паміж круглыя ​​дужкі, якія павінны быць радком. І гэта як раз вяртае цэлы лік, даўжыня гэтага радка. 

Так што гэты цыкл на лініі 7 адбываецца Каб пачаць зваротны адлік на я роўная 0. Гэта будзе павялічвацца я на кожнай ітэрацыі на 1, як мы рабілі некалькі разоў. Але гэта будзе толькі рабіць гэта да кропкі калі я даўжыня з самой радка. 

Так што гэта шлях, у канчатковым рахунку, перабірае персанажаў у радку А як след. Я збіраюся раздрукаваць ня ўвесь радок, але працэнт с, адзін сімвал а затым новай лініі. А потым я збіраюся ісці наперад, і мне трэба сказаць, што я хачу надрукаваць Ith характар ​​с. 

Так што, калі я гэта зменная, якая паказвае індэкс радкі, дзе вы ў ім, мне трэба, каб мець магчымасць кажуць, дайце мне ю характар ​​с. І з мае спосаб зрабіць гэта квадратныя дужкі. Вы проста кажаце ад імя радок, якая ў дадзеным выпадку з'яўляецца s. Затым вы карыстаецеся квадратныя дужкі, якія з'яўляюцца як правіла, крыху вышэй Return або Enter клавіша на клавіятуры. І тады вы паклалі індэкс сімвал, які вы хочаце надрукаваць. Такім чынам, індэкс будзе number-- 0, або 1, або 2, або 3, або кропка, кропка, кропка, некаторы іншае лік. 

І мы гарантуем, што гэта будзе быць правільны нумар, таму што я пачаць адлік з 0. І па змаўчанні, першы сімвал у радку з'яўляецца канвенцыяй 0. І другі персанаж кранштэйны 1. І трэці персанаж кранштэйн 2. І вы не хочаце ісці занадта далёка, але мы не будзем, таму што мы адбываецца не толькі прырашчэнне I да яго роўная даўжыні радка. І ў гэты момант, гэты цыкл спыніцца. 

Такім чынам, дазвольце мне ісці наперад і захаваць гэты праграма, і запусціць зрабіць радок 0. Але я аблажаўся. Ўскосна абвяшчаючы функцыі бібліятэкі Stirling з тыпам такі і such-- зараз, гэта гучыць знаёма. Але гэта не PRINTF. І гэта не атрымаць радок. 

Я не ўкруціць ў гэтак жа, як у гэты раз. Але зьвярніце ўвагу, тут трохі ўніз акрамя таго, ўключаць string.h загалоўка, відавочнай выявай даць дэкларацыя Стэрлінга. Так што на самай справе ключ там. 

І на самай справе аказваецца, ёсць яшчэ адзін файл загалоўка што мы не выкарыстоўвалі у класе ўсё ж, але гэта сярод тых, даступныя да вас, завецца string.h. І ў гэтым файле, string.h з'яўляецца Стырлінга абвешчаная. Такім чынам, дазвольце мне ісці наперад і захаваць гэта, зрабіць радок 0-- прыемна, ніякіх паведамленняў пра памылкі на гэты раз. 

./string0 Zamyla, і Я збіраюся націснуць кнопку ўводу, у які момант адбываецца GetString каб вярнуць радок, змесціце яе ў с. Тады, што цыкл будзе перабіраць над сімвалаў S адзін у той час, і друкаваць іх па адным у кожнай радку, таму што У мяне было, што зваротнай касой п ў канцы. Так што я мог бы апусціць, што зваротны слэш п, а затым проста раздрукаваць ўсе Zamyla у той жа радку, эфектыўна пераазначэнне Printf, што не ўсё, што карысна. Але ў дадзеным выпадку, я не зрабіў гэтага. Я на самой справе раздрукоўваюцца характар, у той час, па адным у кожнай радку, так што мы на самай справе ўбачыць эфект. 

Але я павінен адзначыць адну рэч тут. І мы вернемся да гэта ў будучым тыдні. Аказваецца, што гэта код патэнцыйна глючны. 

Аказваецца, што атрымаць радок і некаторыя іншыя функцыі ў жыцці не абавязкова заўсёды вярнуць тое, што вы чакалі. Мы ведаем з класа апошняга Час у гэтым, што атрымаць радок павінна вяртаць радок. Але што, калі карыстальнік друкуе такія доўгае слова або абзац, ці эсэ што там проста не хапае памяці ў кампутары, каб адпавядаць яго. 

Як і тое, што калі нешта ідзе няправільна пад капотам? Гэта не можа адбыцца часта, але гэта можа адбыцца адзін раз у той час, вельмі рэдка. І так атрымліваецца, што атрымаць радок і функцыі падобныя яму не абавязкова заўсёды вяртаць радка. Яны могуць вяртаць некаторы значэнне памылкі, некаторы значэнне вартавога так бы мовіць, што паказвае на тое, што нешта пайшло не так. І вы б ведалі толькі гэта з пазнаўшы яго ў класе зараз, ці прачытаўшы некаторую дадатковую дакументацыю. Аказваецца, што атрымаць радок можа вяртаць значэнне, званае нулявым. Null гэта асаблівая каштоўнасць, якую мы будзем вярнуцца ў будучага тыдня. Але цяпер, проста ведаю, што калі я хачу каб быць сапраўды ўласна ў прасоўванні наперад з дапамогай атрымання радкі, я не павінны проста назваць яго, і слепа выкарыстоўваць вяртаецца значэнне, мяркуючы, што гэта радок. 

Я павінен спачатку сказаць, Эй, пачакайце хвіліну, толькі дзейнічаць, калі s ня роўнае нуль, дзе нуль, зноў жа, гэта проста нейкае асаблівае значэнне. І гэта адзінае спецыяльнае значэнне, якое вы трэба турбавацца аб для атрымання радка. Атрымаць радок альбо збіраецца вяртаць радок або NULL. 

І гэтая кропка клічнік роўнасці вы маглі б ведаць, ад магчыма матэматычным класе што вы маглі б намаляваць знак роўнасці з лінія, якая праходзіць праз яго, каб паказаць, не роўныя. Гэта наогул не персанаж вы можаце набраць на клавіятуры. І таму ў большасці моў праграмавання, калі вы хочаце сказаць, не роўныя, вы карыстаецеся клічнік, інакш вядомы як выбух. Дык вы кажаце, челка роўна, што азначае не роўна, па логіцы рэчаў. Гэта так жа, як там не больш чым, ці роўнае або менш або роўна клавішу на клавіятуры што робіць усё гэта ў адным сімвале. Ня дзіва, што, у мінулых прыкладах, вы зрабілі адкрыты кранштэйны, а затым знак роўнасці, для таго, каб зрабіць больш ці, скажам, менш. 

Так што вынас тут? Гэта проста спосаб цяпер ўвядзенне гэтага сінтаксісу, гэтая функцыя, перабірае прыватных асоб знакаў у радку. І сапраўды гэтак жа, як тыя плошчы кранштэйны дазваляюць атрымаць на іх, разгледзець гэтыя квадратныя дужкі выгляд намякаючы на ​​гэта асноўны дызайн, у выніку чаго кожны сімвал ўнутры радка з'яўляецца свайго роду заціснуты ў дзесьці ўнізе капот у памяці вашага кампутара. 

Але давайце зробім варыянт гэтага. Аказваецца, што гэта праграма дакладная. Такім чынам, на восі CS50 для ацэнкі код, цяпер гэта правільна. Асабліва цяпер, калі я праверка нуль, гэтая праграма ніколі не павінна ўрэзацца. І я проста ведаю, што з вопыту. Але няма нічога, што мы можам сапраўды пайсці не так тут. Але гэта не вельмі добра прадуманыя, таму што давайце вернемся да асноў. 

Па-першае, principles-- што робіць цыкл рабіць? Для цыклу робіць тры рэчы. Яна ініцыялізуе некаторыя значэнне, калі вы папытаеце яго. Ён правярае стан. А потым пасля кожнага ітэрацыі, пасля кожнага цыклу, ён павялічвае некаторыя значэнне або значэння, тут. 

Дык што ж гэта значыць? Мы ініцыялізуючы я да 0. Мы правяраем і пераканайцеся, што я менш даўжыня з, што Z-А-М-У-Л-А, так што менш 6. І на самай справе, 0, як менш за 6. 

Мы раздрукаваць Z ад імя Zamyla ст. Тады мы павялічваем I ад 0 да 1. Затым мы правяраем, 1 менш чым даўжыня S? Даўжыня S складае 6. Так. 

Такім чынам, мы друкуем у імя Zamyla, у ZA. Мы павялічваем I ад 0, 1, да 2. Затым мы правяраем, на 2 менш даўжыня імя Zamyla ст. 6- так 2 складае менш за 6. Так, давайце раздрукаваць прама зараз M ў імя Zamyla, у трэці сімвал. 

Ключавым момантам тут з'яўляецца тое, што на кожным ітэрацыя гэтай гісторыі, я правяраю, гэта я менш, чым даўжыня Zamyla? Але загваздка ў тым, што Stirling не з'яўляецца уласцівасцю. Тыя з вас, хто праграмаваў да гэтага ў Java або іншых мовах можа ведаць даўжыню радка з'яўляецца ўласцівасць, толькі некаторыя толькі для чытання значэнне. 

У С у гэтым выпадку, калі гэта функцыя, якая ў літаральным сэнсе падліку колькасці сімвалы ў Zamyla кожны раз, калі мы называем гэтую функцыю. Кожны раз, калі вы просіце кампутар, каб выкарыстоўваць Stirling, гэта зірнуць на Zamyla, і кажучы: Z-A-M-Y-L-A, 6. І гэта вяртае 6. У наступны раз, калі вы тэлефануеце то ўнутры, што цыкл, гэта будзе глядзець на Zamyla зноў, скажам Z-А-М-Y-L-A, 6. І ён збіраецца вярнуцца 6. Так што па-дурному пра гэты праект? 

Чаму мой код не 5 з 5 для дызайну прама цяпер, так бы мовіць? Ну, Я пытаюся пытанне залішне. Я раблю больш працы, чым мне трэба. 

Такім чынам, нават нягледзячы на ​​тое, адказ правільны, я пытаючыся кампутар, што такое даўжыня Zamyla зноў, і зноў, і зноў, і зноў? І гэты адказ ніколі не зменіцца. Гэта заўсёды будзе 6. 

Такім чынам, лепшае рашэнне, чым гэта будзе гэта наступная версія. Дазвольце мне ісці наперад і пакласці яго ў асобны файл з імем string1.c, проста трымаць яго асобна. І атрымліваецца, на працягу цыкл, вы можаце на самой справе аб'явіць некалькі зменных адначасова. 

Так што я буду трымаць я і ўсталяваць яго ў 0. Але я таксама збіраюся дадайце коску, і сказаць, дайце мне зменную п, у якога значэнне роўна значэнню даўжыню радка с. А цяпер, калі ласка, мой стан да таго часу, як я менш п. 

Такім чынам, такім чынам, логіка ідэнтычныя ў канцы дня. Але я успамінаючы значэнне 6, у гэтым выпадку. Якая даўжыня імя Zamyla ў? І я стаўлю яго ў п. 

І я да гэтага часу праверкі ўмова кожны раз. З'яўляецца 0 менш, чым 6? 1 менш, чым 6? Ёсць 2 менш, чым 6, і гэтак далей? 

Але я не патрабую кампутар зноў і зноў, што даўжыня імя Zamyla ў? Што даўжыня імя Zamyla ў? Што даўжыня імя гэтага Zamyla ў? Я літаральна памятаць, што першы і адказаць толькі ў гэтай другой зменнай п. Так што гэта зараз было б не толькі правільна, але і добра прадуманыя. 

Цяпер, што тычыцца стылю? Я назваў мае зменныя вельмі добра, я б сказаў. цяпер яны супер лаканічным. І гэта цалкам нармальна. 

Калі ў вас ёсць толькі адзін радок у праграме, Вы маглі б таксама назваць гэта S для радка. Калі ў вас ёсць толькі адна зменная для падліку у праграме, Вы маглі б таксама назваць гэта я. Калі ў вас ёсць даўжыня, п супер часта, як добра. Але я не заўважыў які-небудзь з майго кода. 

Я не паведаміў reader-- што будзь мая TF, або TA, ці проста colleague-- тое, што, як мяркуецца, каб ісці далей у гэтай праграме. І так, каб атрымаць добры стыль, тое, што я хацеў бы зрабіць гэта нешта this-- як спытаць карыстальніка для ўваходу. І я мог бы перапісаць гэта любую колькасць спосабаў. 

Пераканайцеся, што S-- пераканайцеся атрымліваеш Радок, якая вяртаецца радок. А потым у here--, і гэта, магчыма, самым важным comment-- ітэрацыя над персанажамі з аднаго адначасова. І я мог бы выкарыстаць любы Выбар англійскай мовы тут, каб апісаць кожны з гэтых кавалкаў кода. 

Звярніце ўвагу на тое, што я не пакідаецца каментаваць кожную радок кода, на самай справе проста на цікавы з іх, тыя, ёсць нейкі сэнс, што я мог бы хочуць, каб зрабіць супер ясны камусьці чытанне майго кода. А чаму ты тэлефануеш атрымаць радок запытвае ў карыстальніка для ўваходу? Нават тое, што адзін не абавязкова усё, што апісальны характар. Але гэта дапамагае распавесці гісторыю, таму што Другі радок у гісторыі ёсць, пераканайцеся, атрымаць радкі, вернутай радок. 

І трэцяя радок у гэтай гісторыі, перабіраць знакаў у адным амі ў той час. А зараз проста для добрай мерай, Я збіраюся ісці наперад і дадаць яшчэ адзін каментар, які як раз кажа друк I-й знак у с. Цяпер, што я зрабіў ў канцы дня? 

Я дадаў некаторыя ангельскія Слова ў выглядзе каментароў. Сімвал касая рыса азначае, эй, Кампутар гэта для чалавека, не для вас, кампутар. Такім чынам, яны ігнаруюцца лагічна. Яны проста ёсць. 

І сапраўды, CS50 IDE паказвае іх як шэры, як карысныя, але не ключ да праграмы. Звярніце ўвагу на тое, што цяпер вы можаце зрабіць. Ці ведаеце вы C праграмавання або няма, можа проста стаяць у баку ў гэтым Праграма, і абястлушчанае каментары. Папытаеце карыстальніка для ўводу, пераканайцеся, атрымаць радкі, вернутай радок, перабіраць знакаў у сек па адным за раз, надрукаваць сімвал I-й знак у S-- вы гэтага не зробіце нават глядзець на код каб зразумець, што робіць гэтая праграма. І яшчэ лепш, калі вы самі глядзіце у гэтай праграме на працягу тыдня або двух, ці месяц, ці год, вы таксама не маеце глядзець на код, спрабуючы ўспомніць, што я спрабую зрабіць з гэтым кодам? 

Вы сказалі сабе. Вы апісалі гэта для сябе, ці які-небудзь калега або ТАЯ, або TF. І так гэта цяпер будзе правільна, і добры дызайн, і ў канчатковым рахунку, добры стыль, а таксама. Так што майце гэта на ўвазе. 

Так што ёсць яшчэ адна што я збіраюся зрабіць тут што зараз можа паказаць менавіта тое, што адбываецца пад капотам. Так што гэтая функцыя у C і іншых мовах, называецца тыпажоў што альбо няяўна ці відавочна дазваляе канвертаваць ад аднаго тыпу дадзеных у іншы. Мы маем справу так далёка сёння з радкамі. 

І радка знакаў. Але памятайце з тыдня 0, якія сімвалы? Сімвалы проста абстракцыя на вяршыні numbers-- дзесятковых лікаў, і дзесятковых лікаў сапраўды проста абстракцыя на вяршыні двайковых лікаў, як мы вызначылі яе. 

Так сімвалы нумары. І лічбы сімвалаў, толькі ў залежнасці ад кантэксту. І атрымліваецца, што ўнутры кампутарнай праграмы, Вы можаце паказаць, як вы хочаце выглядаць у біты ўнутры гэтай праграмы? 

Нагадаем, ад тыдня 0, што ў нас было Ascii, што менавіта гэты код адлюстраванне літар да лічбаў. І мы сказалі, капітал А 65. Капітал Б 66, і гэтак далей. 

І заўважце, мы, па сутнасці ёсць знакі на верхні шэраг тут, як C назаве іх, сімвалаў, а затым Інтс на другім шэрагу. І атрымліваецца, вы можаце канвертаваць бясшвовых паміж імі, як правіла. І калі мы хочам зрабіць гэта свядома, мы можа спатрэбіцца для вырашэння нешта накшталт гэтага. 

Мы маглі б хацець, каб пераўтварыць верхні рэгістр, каб панізіць выпадак, ці ніжні рэгістр ў верхні рэгістр. І атрымліваецца, што ёсць на самай справе карціна тут мы можам ахапіць усяго хвіліну. Але давайце спачатку паглядзім на Прыклад выканання гэтага ў відавочным выглядзе. 

Я збіраюся вярнуцца ў CS50 IDE. Я збіраюся стварыць файл з імем Ascii 0.c. І я збіраюся ісці наперад і дадаць мой стандарт io.h у верхняй частцы, INT Асноўная пустата у верхняй частцы маёй функцыі. А потым я проста буду рабіць following-- для цыклу ад я роўная, скажам, 65 гадоў. 

І тады я будзе менш 65, плюс 26 літар у алфавіце. Так што я дам кампутар рабіць матэматыку для мяне там. А потым ўнутры гэтай завесы, што я буду друкаваць? 

% З з'яўляецца% я ўжыць зваротны слэш п. А цяпер я хачу, каб падключыць два значэння. Я часова паставіў пытанне Ацэнкі там запрасіць на гэтае пытанне. 

Я хачу ітэрацыю ад 65 наперад для 26 літар алфавіту, друк на кожнай ітэрацыі, што інтэгральны эквівалент персанажа. Іншымі словамі, я хачу перабраць 26 нумароў друку што Ascii сімвал, літара, і што адпаведнае лік is-- на самай справе проста аднаўленне Дыяграма з гэтага слайда. Дык што ж гэтыя знакі пытання быць? 

Што ж, атрымліваецца, што другі трэба проста быць зменнай я. Я хачу бачыць, што як лік. А сярэдні аргумент тут, я магу сказаць кампутара для лячэння, што колькасць я як характар, так замяніць яго тут адсоткаў C. 

Іншымі словамі, калі я, то чалавек праграміст, ведаю, гэта проста лічбы ў канцы дня. І я ведаю, што 65 павінен карта ў нейкі характар. З дапамогай гэтага яўнага прывядзення тыпаў, з дужкай, імя тыпу дадзеных, які вы хочаце канвертаваць, і закрытым дужка, Вы можаце сказаць кампутар, эй, кампутар, пераўтварыць гэты лік у знак. 

Так што, калі я запускаю гэта праграма пасля кампіляцыі, давайце паглядзім, што я get-- зрабіць Ascii 0. Чорт гэта, што я зрабіў няправільна тут? Выкарыстанне незаяўленых ідэнтыфікатара, усё ў парадку, ці ня наўмысна, але давайце паглядзім, калі мы не можам Прычына праз гэта. 

Так лінія five-- так што я не атрымаў вельмі далёка, перш чым зашрубоўвання. Гэта добра. Такім чынам, лінія 5 для г роўная 65-- я бачу. Так што памятаеце, што ў C, у адрозненне ад некаторых мовы, калі ў вас ёсць папярэдняе праграмаванне вопыт, у вас ёсць каб сказаць кампутара, у адрозненне ад нуля, то, тып зменнай яна. 

І я забыўся ключавую фразу тут. У радку пяць, я пачаў выкарыстоўваць I. Але я не сказаў C якія дадзеныя тыпу гэта. Так што я збіраюся ісці сюды і кажуць, ах, зрабіць гэта цэлы лік. 

Цяпер я збіраюся ісці наперад і перакампіляваць. Гэта зафіксавана, што. ./ascii0 Enter, гэта свайго роду прахалодны. Мала таго, што гэта супер хутка спытаць кампутар на гэтае пытанне, а не глядзець яго на слайд, яна выдае па адным у кожнай радку, А 65, B 66, ўсе шляхі down--, так як я зрабіў гэта 26 times-- з літарамі г, што складае 90. І на самай справе, трохі больш разумным будзе былі для мяне не спадзявацца на кампутары, каб дадаць 26. Я мог бы проста зрабіць 90, а таксама, да таго часу, як я не робяць тую ж памылку двойчы. Я хачу, каб ісці праз г, а не толькі праз у. 

Так што гэта відавочнае прывядзенне. Аказваецца, што гэта нават няма неабходнасці. Дазвольце мне ісці наперад і паўторна запусціць гэты кампілятар, і перакладка Ascii 0. Аказваецца, што C з'яўляецца даволі разумны. 

І Printf, у прыватнасці, даволі разумны. Калі вы проста прайсці я двойчы для абодвух запаўняльнікаў, Printf зразумеюць, ой, ну я цябе ведаю даў мне integer-- некаторы лік, як 65, або 90, або любы іншы. Але я бачу, што вы хочаце, каб я фарматавання гэты лік як сімвал. І таму Printf можа няяўна прыведзены ИНТ да паўкокс для вас. Так што гэта не праблема наогул. 

Але зьвярніце ўвагу, з-за гэтай эквівалентнасці мы можам на самай справе зрабіць гэта, як добра. Дазвольце мне ісці наперад і зрабіць адзін іншая версія this-- Ascii 1.C. І замест таго, каб перабірае цэлыя лікі, сапраўды можа падарваць ваш розум перабірае знакаў. Калі сімвал з атрымлівае капітал A, I хочуць, каб ісці наперад і рабіць гэта, да таго часу, З менш або роўна для капіталу Z. І на кожнай ітэрацыі Я хачу, каб павялічыць C, я магу Цяпер у маім PRINTF лініі тут скажам, адсоткаў З адсоткаў я зноў, падзеленыя C. 

А цяпер, я магу пайсці ў іншым накірунку, ліццё характар ​​відавочна у цэлы лік. Так што, зноў жа, навошта вы гэта робіце? Гэта крыху дзіўна роду разлічваць з пункту гледжання персанажаў. 

Але калі вы разумееце, што гэта адбываецца пад капотам, няма нават ніякай магіі. Ты кажаш, эй, кампутар дасць мяне пераменная называецца C тыпу паўкокс. Ініцыялізаваць яго капіталу А. І заўважыць адзінкавыя двукоссі матэрыі. 

Для знакаў у C, памятаеце з На мінулым тыдні, вы карыстаецеся адзінкавыя двукоссі. Для радкоў, слоў, фразы, вы карыстаецеся падвойныя двукоссі. OK, кампутар, працягвайце рабіць гэта, так Пакуль сімвал менш або роўная г. І я ведаю, што ад майго Ascii табліцы, што ўсе з гэтых кодаў ASCII з'яўляюцца сумежнымі. 

Там няма ніякіх прабелаў. Так што гэта проста ад А да Z, падзеленых адным нумарам кожнага. І тады я магу павялічваць паўкокс, калі я сапраўды хачу. У рэшце рэшт, гэта проста лік. Я ведаю гэта. Так што я магу толькі выказаць здагадку, каб дадаць да яго 1. 

А потым на гэты раз, я друкую з, а затым інтэгральны эквівалент. І я нават не трэба відавочнае прывядзенне. Я магу дазволіць Printf і таму кампутар зразумець рэчы, так што цяпер, калі я бягу зрабіць Ascii1./ascii1, Я атрымліваю сапраўды такую ​​ж рэч, як добра. 

Бескарысная праграма, ня though-- ніводнага збіраецца на самай справе напісаць праграмнае забеспячэнне для таго, каб высветліць, што было лік, якое адлюстроўваецца ў А ці У, або Z? Ты проста гугліць гэта, ці паглядзець яго ў Інтэрнэце, або паглядзець яго на слайдзе, ці таму падобнае. Дык дзе ж гэта на самай справе атрымаць карысна? 

Ну, калі казаць пра тое, што слайд, звярніце ўвагу, што ёсць фактычная карціна тут паміж загалоўнымі літарамі і ў ніжнім рэгістры, што не было выпадковым. Звярніце ўвагу на тое, што капітал А 65. Малыя а з'яўляецца 97. І як далёка ніжэй выпадак а? 

Такім чынам, 65 колькі крокаў ад 97? Такім чынам, 97 мінус 65 роўна 32. Такім чынам, капітал 65 а ёсць. Пры даданні 32 да гэтага, Вы атрымліваеце ў ніжнім рэгістры а. І, што тое ж самае, калі адняць 32, вы атрымаеце назад у сталіцу A-- ж з B маленькаму б, вялікі С да мала с. 

Усе гэтыя зазоры 32 адзін ад аднаго. Цяпер, гэта, здавалася б, каб дазволіць нам зрабіць нешта накшталт Microsoft Word, ці Google Docs ёсць, дзе вы Можна выбраць усе, а затым сказаць, змяніць усё ў ніжнім рэгістры, або змяніць усё ў верхні рэгістр, ці змяніць толькі першае слова прысуду да верхняга рэгістра. Мы можам зрабіць нешта як і мы самі. 

Дазвольце мне ісці наперад і захаваць файл тут называецца капіталізаваць 0.c. І давайце ісці наперад і нагнятаць праграму што робіць менавіта тое, што наступным чынам. Так ўключаюць у сябе бібліятэку CS50. І ўключаюць у сябе стандартныя ўваходы / выхады. 

І я ведаю, што гэта ў бліжэйшы час. Так што я збіраюся паставіць яго ў там ужо, string.h, таму ў мяне ёсць доступ да такія рэчы, як Сцірлінг, а затым INT галоўную пустэчу, як звычайна. А потым я збіраюся ісці наперад і рабіць радкі атрымлівае атрымаць радок, проста, каб атрымаць радок ад карыстальніка. А потым я збіраюся зрабіць мой чэк стан сьвядомасьці. Калі радок не роўная нуля, то гэта бяспечна працягнуць працу. І тое, што я хачу зрабіць? Я збіраюся перабіраць ад я роўны 0, і п да даўжыня радка с. 

І я збіраюся зрабіць гэта да таго часу, я менш п, і я плюс плюс. Да гэтага часу, я на самой справе проста запазычанне ідэі раней. А цяпер я збіраюся ўвесці філіял. 

Так што думайце зноў чухаць, дзе мы мелі тыя развілкі, а на мінулым тыдні ў C. Я збіраюся казаць пра гэта, калі я-й знак у секундах больш ці роўна ніжнім рэгістра а, и-- ў пустым месцы вы б у літаральным сэнсе кажуць, і, але ў C вы кажаце Ампэрсанд, ampersand-- і I-й сімвал ў секундах менш або роўны малыя г, давайце зробім штосьці цікавае. Давайце на самай справе раздрукаваць характар, без пераходу на новы радок то ёсць знак у радку, I-й знак у радку. 

Але давайце ісці наперад і адняць 32 з яго. Інакш, калі знак у Радок, мы шукаем не паміж Трохі і трохі г, ісці наперад і проста распячатала яго без зменаў. Такім чынам, мы ўвялі гэта абазначэнне ў квадратных дужках для нашых радкоў, каб атрымаць на I-й знак у радку. 

Я дадаў некаторую ўмоўную логіку, як Драпіны на мінулым тыдні тыдні адзін, дзе Я проста выкарыстоўваю мой фундаментальны разуменне таго, што адбываецца пад капотам. Ці з'яўляецца I-ы сімвал S больш або роўна а? Маўляў, гэта 97, ці 98, ці 99, і гэтак далей? 

Але гэта таксама менш або роўна да значэння ў ніжнім рэгістры г? І калі так, то што гэта значыць гэтая лінія? 14, гэта з'яўляецца свайго роду парастак ўсёй ідэі, загалоўнай ліст па проста адняць 32 з яго, у дадзеным выпадку, таму што я ведаю, за што дыяграмы, як прадстаўлены мае нумары. Так што давайце ісці наперад і кіраваць гэтым, пасля кампіляцыі капіталізаваць 0.c, і запусціць капіталізаваць 0. 

Давайце увесці нешта накшталт Zamyla ў ніжнім рэгістры ўводу. І зараз мы маем Zamyla ў верхнім рэгістры. Давайце ўвесці Роба ў ніжнім рэгістры. Давайце паспрабуем Джэйсана ў ніжнім рэгістры. І мы працягваем атрыманне вымушаныя капіталізацыі. Там ёсць невялікая памылка, што я выгляд не чакаў. Звярніце ўвагу на мой новы запыт асядае на тым жа радку, іх імёны, які адчувае сябе крыху брудным. 

Так што я збіраюся ехаць сюды, і на самай справе ў канцы гэтай праграмы раздрукаваць сімвал новага радка. Гэта ўсе. З Printf, вам не трэба перайсці ў зменных або кодзе фармату. Вы можаце ў літаральным сэнсе проста раздрукаваць нешта накшталт новага радка. 

Так што давайце ісці наперад і зрабіць капіталізаваць 0 раз, паўторна запусціць яго, Zamyla. А цяпер гэта крыху сімпотней. Цяпер, мой запыт на сваёй уласнай новай лініі. Так што гэта ўсё выдатна і добра. Так што гэта добры прыклад. Але я нават не абавязкова неабходна жорстка закадаваць 32. Вы ведаеце, што? Я мог бы say-- я ніколі не памятаеце, у чым розніца. 

Але я ведаю, што калі я маюць малой літары, Я па сутнасці хачу, каб адняць ад незалежна ад адлегласці паміж мала а і вялікі А, таму што, калі я мяркую, што ўсе астатнія літары аднолькавыя, якія павінны атрымаць працу. Але замест таго каб зрабіць гэта, вы ведаеце, што? Там яшчэ адзін спосаб да гэтага часу. 

Калі гэта капіталізаваць 1.c-- калі б я быў каб змясціць гэта ў асобны файл. давайце зробім капіталізаваць 2.C наступным чынам. Я збіраюся сапраўды ачысціць гэта тут. І замест таго, каб нават не маючы ведаць ці клапаціцца пра тых нізкім узроўні дэталі рэалізацыі, я замест таго, каб толькі збіраецца надрукаваць сімвал, цытата канец цытаты, адсотка C, і затым выклікаць іншую функцыю, якая існуе, што прымае аргумент, які з'яўляецца сімвалам, як гэта. 

Аказваецца, у C, ёсць іншы выклік функцыі да верхняй, якая, як яго імя мяркуе, прымае характар і робіць яго ў верхні рэгістр эквівалент, а затым вяртае яго так што Printf можаце падключыць яго там. І так, каб зрабіць гэта, хоць, я неабходна ўвесці яшчэ адзін файл. Аказваецца, ёсць яшчэ адзін файл што вы толькі ведаеце з класа, або падручнік, ці інтэрнэт спасылка, называецца C type.h. 

Так што, калі я дадам, што да майго сярод загалоўка файлы, а цяпер зноўку кампіляваць гэтую праграму, capitalize2, ./capitalize2 Enter. Давайце ўвесці Zamyla за ўсё у ніжнім рэгістры, па-ранейшаму працуе гэтак жа. Але вы ведаеце, што? Аказваецца, што ў верхняй мае некаторыя іншыя функцыянальныя магчымасці. 

І дазвольце мне прадставіць гэта камандаваць усімі, накшталт няёмка па імені, але чалавек для кіраўніцтва. Аказваецца, што большасць кампутараў Linux, як мы выкарыстоўваем here-- аперацыйную Linux система-- ёсць каманда называецца чалавек, які кажа, эй, кампутар, дайце мне па эксплуатацыі кампутара. Што вы хочаце шукаць у гэтым кіраўніцтве? 

Я хачу паглядзець функцыю адкрываецца верхні, Enter. І гэта крыху загадкавае чытаць часам. Але зьвярніце ўвагу, што мы ў кіраўніцтва па Linux праграміста. І гэта ўвесь тэкст. І заўважце, што гэта імя функцыі тут. Аказваецца, у яго ёсць стрыечны брат пад назвай знізіць, якая робіць супрацьлеглае. І заўважце пад сінопсіс, каб выкарыстоўваць гэтую функцыю функцыянаваць старонкі чалавека, так бы мовіць, кажа мне, што я неабходна ўключыць гр type.h. І я ведаў, што з практыкі. 

Вось, ён паказвае мне два прататыпы для функцыі, так што калі я калі-небудзь хачу, каб выкарыстоўваць гэтую функцыю Я ведаю, што яны прымаюць у якасці ўваходных дадзеных, і тое, што яны вяртаюцца ў якасці выхаднога сігналу. І потым, калі я чытаю апісанне, я бачу больш падрабязна, што функцыя робіць. Але што больш важна, калі Я гляджу пад вяртаецца значэння, ён кажа, вернутае значэнне што ператворанага лісты, або З, зыходны уваходнай, калі пераўтварэнне не ўдалося. 

Іншымі словамі, верхні будзе спрабаваць пераўтварыць ліст у верхні рэгістр. І калі так, то ён збіраецца вярнуць яе. Але калі ён не можа для некаторых reason-- можа быць, гэта ўжо ў верхнім рэгістры, можа быць, гэта клічнік ці якой-небудзь іншай punctuation-- гэта проста будзе вярнуць зыходны C, а гэта значыць, што я магу зрабіць мой код лепш распрацаваны наступным чынам. 

Мне не патрэбныя ўсе гэтыя цыраваць радкі кода. Усе радкі я толькі вылучаны можа быць згорнутыя ў толькі адзін просты лінія, якая з'яўляецца this-- Printf адсотка з да верхняга кранштэйна I S. І гэта было б прыклад лепшага дызайну. 

Чаму рэалізаваць у 7 або 8 ліній кода, якім бы ён быў я проста выдалены, калі вы можаце замест таго, каб згарнуць усё, што логіка і прыняцце рашэнняў ў адну лінію, 13, што ў цяперашні час абапіраецца на бібліятэку function-- функцыя, якая пастаўляецца з C, але гэта робіць менавіта тое, што вы хочаце, каб гэта зрабіць. І, шчыра кажучы, нават калі ён не прыйшоў з C, вы маглі б рэалізаваць яго самастойна, так як мы ўжо бачылі, з Int атрымаеце адмоўны вынік і атрымаць станоўчы INT на мінулым тыдні. 

Гэты код у цяперашні час значна больш зручным для чытання. І сапраўды, калі мы пракруткі уверх, Паглядзіце, наколькі больш кампактны гэтая версія маёй праграмы. Гэта крыху грувасткай зараз, з усімі гэтымі ўключае ў сябе. Але гэта нармальна, таму што цяпер я стаю на плечы праграмістаў перада мной. І хто б гэта ні быў, хто рэалізаваны ў верхняй сапраўды зрабіў мне ласку, гэтак жа, як той, хто рэалізаваны Стырлінга сапраўды зрабіў мне ласку некаторы час таму. І вось цяпер у нас ёсць лепш дызайн праграмы які рэалізуе тую ж самую логіку. 

Гаворачы аб Стэрлінга, хай мне ісці наперад і рабіць гэта. Дазвольце мне ісці наперад і захаваць гэты файл у якасці stirling.c. І атрымліваецца, мы можам адхіліце адзін іншы пласт даволі проста прама цяпер. Я збіраюся ісці наперад і пугу да іншай праграмы ў галоўным тут проста паўторна прылады даўжыня радка наступным чынам. Дык вось радок кода, якая атрымлівае мяне радок ад карыстальніка. Мы працягваем выкарыстоўваць гэта зноў і зноў. Дазвольце мне даць сабе зменную п тыпу Int, які захоўвае нумар. 

І дазвольце мне ісці наперад і зрабіць наступную логіку. У той час як у я-й знак у S робіць ня роўны 0 ўжыць зваротны слэш, ісці наперад і прырашчэнне п. І затым раздрукаваць Printf адсотка I N. Я сцвярджаю, што гэтая праграма тут, без выкліку даўжыні радка, высвятляе даўжыню радка. 

І магія цалкам увасоблены ў радку 8 вось з чым выглядае як новы сінтаксіс, гэта адваротны слэш 0 на адзінарныя двукоссі. Але чаму? Ну, падумайце, што было адбываецца ўвесь гэты час. 

І, як у бок, перш чым я забыўся, разумею, таксама, што ў дадатак да чалавека старонак якія прыходзяць з тыповым Сістэма Linux як CS50 IDE, разумець, што мы, Персанал вядома, у ёсць таксама зрабіў версію сайта гэтай жа ідэі пад назвай reference.cs50.net, якая мае усё тыя ж чалавека-старонак, усё той жа дакументацыі, а таксама маленькая скрыначка у верхняй частцы, што дазваляе канвертаваць усе з даволі аркан мова ў менш камфортна рэжым, у якім мы, выкладчыцкі склад, прайшлі і паспрабаваў спрасціць частка мовы, каб трымаць рэчы сканцэнтраваны на ідэях, а не некаторыя тонкасці. Так што майце на ўвазе, reference.cs50.net у якасці яшчэ аднаго рэсурсу, а таксама. 

Але чаму даўжыня радка ў працу як я прапанаваў некалькі хвілін таму? Вось імя Zamyla зноў. А вось імя Zamyla ў заціснуты ў, як я працягваць рабіць, каб намаляваць карціну яго быцця, на самай справе, проста паслядоўнасць знакаў. Але Zamyla не існуе ў ізаляцыі ў праграме. 

Калі вы пішаце і запусціць праграму, вы карыстаецеся ваш Mac або ПК як памяць, або RAM, так бы мовіць. І вы можаце думаць аб ваш кампутар як мае шмат гігабайт памяці ў гэтыя дні. І гіг азначае мільярды, таму мільярды байт. 

Але давайце перамотваць ў часе. І выкажам здагадку, што мы выкарыстоўваем вельмі стары кампутар, мае толькі 32 байта памяці. Я мог бы, на экране кампутара, проста звярнуць на гэта наступным чынам. 

Я мог бы проста сказаць, што мой Кампутар мае ўся гэтая памяць. І гэта, як палка памяці, калі Вы памятаеце нашу карціну ў мінулы раз. А калі я проста падзяліць гэта столькі разоў, Я сцвярджаю, што ў мяне ёсць 32 байта памяці на экране. 

Цяпер, на самай справе, я магу толькі маляваць да гэтага часу на гэтым экране тут. Так што я збіраюся ісці наперад, і толькі па пагадненні, маляваць памяці майго кампутара ў якасці сеткі, а не толькі як адна прамая лінія. У прыватнасці, я сцвярджаю, што ў цяперашні час гэтая сетка, гэта 8 па 4 сеткі, проста прадстаўляе ўсе 32 байта даступнай памяці ў маім Mac, ці даступныя ў маім кампутары. І яны абгортачная на дзве лініі, проста так як ён падыходзіць больш на экране. Але гэта першы байт. Гэта другі байт. Гэта трэці байт. 

І гэта 32-й байт. Ці, калі мы думаем, як кампутар вучоны, гэта байт 0, 1, 2, 3, 31. Так што ў вас ёсць ад 0 да 31, калі Вы пачынаеце адлік з 0. 

Так што, калі мы выкарыстоўваем праграму што званкі атрымаць радок, і мы атрымліваем радок з чалавечага як я назваў Zamyla, Z-A-M-Y-L-A, як у свеце робіць кампутар адсочваць, які байт, які кавалак памяці, належыць какая радок? Іншымі словамі, калі мы пераходзім да увядзіце іншае імя ў кампутар, як гэты Andi, называючы атрымаць радок ў другі раз, A-N-D-я павінен скончыць у памяць кампутара, а таксама. Але якім чынам? 

Што ж, атрымліваецца, што пад капот, тое, што C робіць пры захоўванні радкоў што чалавечыя тыпы ў, або што адбываюцца з якога-небудзь іншай крыніцы, з'яўляецца яго акрэслівае канец іх з спецыяльны character-- ўжыць зваротны слэш 0, што гэта проста асаблівы спосаб сказаць 80 біт запар. 

Так A-- гэты лік 97 водгук. Такім чынам, некаторыя мадэлі з 8 бітаў ўяўляе дзесятковы лік 97. Гэты зваротны слэш 0 літаральна лік 0, а.к.а. NUL, N-U-L, у адрозненне ад раней, N-U-L-L, які мы казалі. Але цяпер, проста ведаю, што гэта зваротная касая 0 усяго 80 біт запар. 

І гэта як раз гэты радок у пясок, які кажа, што нічога злева належыць да адной радку ці аднаго тыпу дадзеных. І нічога направа належыць да чаго-то яшчэ. найменне Andi, тым часам, які толькі візуальна здараецца, каб абгарнуць на іншай лініі, але гэта толькі эстэтычная дэталь, Аналагічным чынам завяршаецца NUL. 

Гэта струна сімвалаў A-N-D-I, плюс пяты сакрэтны характар, усе 0 біты, якія проста размяжоўвае канец імя Andi, а таксама. І калі мы называем атрымаць радок у трэці раз ў кампутары, каб атрымаць радок выгляду Марыя, М-А-Р-I-А, гэтак жа з'яўляецца Марыі Імя NUL завяршаецца з зваротнай касой рысай 0. 

Гэта прынцыпова адрозніваецца ад таго, як кампутар, як правіла, захоўваць цэлы лік або лік з якая плавае кропкай, ці іншы тыпы дадзеных да гэтага часу, таму што ўспомніць, цэлы лік, як правіла, 32 біта, або 4 байта, ці магчыма нават 64 біта, ці восем байт. Але многія прымітывы ў кампутары на мове праграмавання маюць фіксаваны лік байт пад hood-- можа быць 1, 2, можа быць, можа быць 4, можа быць 8. 

Але радкі, па дызайне, маюць дынамічнае колькасць знакаў. Вы ніколі не ведаеце загадзя, да таго часу, чалавечыя тыпы ў Z-A-M-Y-L-A, або М-А-Р-І-А ці А-Н-Д-І. Вы не ведаеце, колькі разоў карыстальнік збіраецца стукнуць клавіятура. Такім чынам, вы не ведаеце, як шмат знакаў у загадзя вы будзеце мець патрэбу. 

І так С проста выгляд лісця, як у сакрэт дробка пад капотам у канцы радка. Пасля захоўвання Z-А-М-Y-L-A ў памяці, ён таксама проста ставіць эквівалент на працягу перыяду. У канцы прапановы, ён змяшчае 80 біт, такім чынам, каб успомніць, дзе Zamyla пачынаецца і заканчваецца. 

Так што сувязь, Затым, да гэтай праграме? Гэтая праграма тут, Стырлінга, гэта проста механізм для атрымання радкі ад карыстальніка, радок 6. Радок 7, я абвясціць зменную называецца п і ўсталюйце яго роўным 0. 

А потым у радку 8, я проста спытаў пытанне, у той час як у я-й сімвал робіць не роўныя 0 ўсё bits-- іншымі словамі, не робіць роўна гэты спецыяльны сімвал, зваротная касая 0, быў толькі што адмысловы NUL character-- ісці наперад і проста павялічваць п. 

І працягваць рабіць гэта, і трымаць робячы гэта, і працягваць рабіць гэта. І таму, нават калі ў мінулае мы выкарыстоўвалі I, гэта выдатна семантычна выкарыстоўваць п, калі вы проста спрабуеце разлічваць на гэты раз свядома, і проста хочаце назваць гэта н. Так што гэта проста працягвае задаваць пытанне, з'яўляецца н-ы сімвал з усё 0s? Калі няма, паглядзіце на наступны выгляд, паглядзіце на наступны, паглядзіце на наступны, паглядзіце на наступны. 

Але як толькі вы бачыце зваротную касую 0, гэта loop-- лінія 9 праз 11-- спыняецца. Вы вырвацца з цыклу ў той час, пакідаючы ўнутры гэтай зменнай п у агульнай складанасці колькасць ўсіх з знакаў у радку, якую вы бачылі, такім чынам, вывадзе на друк. Дык давайце паспрабуем гэта. 

Дазвольце мне ісці наперад і без з дапамогай функцыі Стырлінга, а проста выкарыстоўваючы сваю ўласную версію дамарослыя тут называецца Стырлінга, дазвольце мне ісці наперад і запусціць Стырлінга, тыпу ў чымсьці як Zamyla, які я ведаю загадзя складае шэсць знакаў. Давайце паглядзім, ці працуе ён. На самай справе, гэта шэсць. Давайце паспрабуем з Робом, тры сімвала, тры сімвала, а таксама, і гэтак далей. Так што ўсё, што адбываецца на пад капотам. І да вашага ведама, злучэння, затым, пачынаючы з першага тыдня класа, дзе мы гаварылі пра нешта накшталт абстракцыі, што менавіта гэта напластаванне ідэй, або складанасць, на вяршыні асноўных прынцыпаў. Тут мы накшталт глядзець пад капотам Стэрлінга, так бы мовіць, каб высветліць, як бы гэта рэалізаваць? 

І мы маглі б паўторна рэалізаваць яго самі. Але мы ніколі зноў збіраецца паўторна рэалізаваць Стырлінга. Мы проста збіраемся выкарыстоўваць Стырлінга ў парадку на самой справе атрымаць некаторыя радкі даўжыні. 

Але няма ніякай магіі пад капотам. Калі вы ведаеце, што пад капот, радок гэта проста паслядоўнасць знакаў. І гэта паслядоўнасць знакаў усе яны могуць быць колькасна разгледжаны з кранштэйнам 0, кранштэйны 1, кранштэйн 2, і вы вядома, што ў канцы радка з'яўляецца спецыяльны сімвал, вы можаце высветліць, як зрабіць большасць нічога ў Праграма, таму што ўсё гэта зводзіцца да таго, чытае і піша памяць. Гэта значыць, мяняецца і шукае ў памяці, або перасоўванне рэчаў вакол у памяці, друкаваныя рэчы на экране, і гэтак далей. 

Так давайце цяпер выкарыстоўваць гэтую зноў здабытую разуменне таго, якія радкі на самай справе знаходзяцца пад капотам, і адхіліце адзін іншы пласт што да гэтага часу мы ігнараваў ў цэлым. У прыватнасці, любы час мы рэалізавалі праграму, мы мелі гэты радок кода паблізу верхняй абвяшчаючы галоўнай. І мы паказалі INT галоўную пустэчу. 

І гэтая пустата ўнутры дужак казаў ўвесь гэты час, што асноўная сама па сабе не прымае якіх-небудзь аргументаў. Любы ўклад, што галоўнае, збіраецца атрымаць ад карыстальніка павінна зыходзіць ад нейкай іншай механізм, як Get INT, або атрымаць з якая плавае кропкай, ці атрымаць радок, ці якой-небудзь іншай функцыі. Але аказваецца, што калі вы пішаце праграму, вы можаце паказаць што гэтая праграма павінна прымаюць ўваходныя сігналы ад чалавека у самой камандным радку. 

Іншымі словамі, нават калі мы да гэтага часу былі працуе толькі ./hello прывітанне ці падобныя праграмы, усе іншыя праграмы, якія мы выкарыстоўвалі, што мы самі не пісалі, прымалі, па-відаць, каманднага радка arguments-- такія рэчы, як зрабіць. Вы кажаце, што нешта накшталт марка, а затым другое слова. Або ляск, вы кажаце ляск, а затым другое слова, імя файла. 

Ці нават RM або СР, як можна было б бачылі ці выкарыстоўваць ужо выдаляць або капіяваць файлы. Усе тыя прымаюць так званыя каманднага радка arguments-- дадатковыя слова ў радку тэрмінала. Але да гэтага часу, мы самі не мелі Гэты шыкоўны прымаць ўваходны сігнал ад карыстальніка, калі ён ці яна на самай справе працуе сама праграма ў камандным радку. 

Але мы можам зрабіць гэта шляхам паўторнага дэкларавання Асноўны рухацца наперад, а не як якія маюць несапраўдным у дужках, але гэтыя два аргументу instead-- першае цэлы лік, а другі нешта новае, тое, што мы будзем называць масіў, нешта падобнае ў духу да таго, што мы бачылі ў пустым выглядзе спісу, але масіў радкоў, як мы хутка ўбачым. Але давайце паглядзім на гэта У якасці прыкладу, перш чым мы адрозніваюць менавіта тое, што гэта значыць. 

Так што, калі я іду ў CS50 IDE тут, я пайшоў наперад і абвешчаны ў файле з імем argv0.c наступны шаблон. І заўважце, адзінае, што па-іншаму да гэтага часу з'яўляецца тое, што я змяніў нікчэмным Int ARGC радок ARGV адкрыты кранштэйны, блізка кранштэйн. І звярніце ўвагу на дадзены момант, ёсць нічога не ўнутры гэтых дужак. 

Там няма ліку. І няма я, або N, або любое іншае ліст. Я проста з дапамогай квадратныя дужкі на дадзены момант, па прычынах, мы прыедзем назад у імгненне. 

А цяпер, што я збіраюся зрабіць гэта. Калі ARGC роўны роўны 2-- і нагадаем, што складае роўных з'яўляецца аператарам параўнання роўнасці левы і правы для роўнасці. Гэта не саступка аператар, які адзіны знак роўнасці, што азначае копію ад справа налева нейкае значэнне. 

Калі ARGC роўны роўны 2, я хачу скажам, Printf, прывітанне, працэнты, новая лінія, а затым падлучыць in-- і вось новы trick-- ARGV кранштэйны 1, па прычынах што мы вернемся ў хвіліну. Інакш, калі ARGC ня роўна 2, вы ведаеце, што? Давайце проста ісці наперад і, як звычайна, друк па-за прывітанне свет, без замены. 

Так што, здавалася б, што калі ARGC, які выступае за колькасцю аргументаў, раўняецца 2, Я збіраюся раздрукаваць прывітанне што-небудзь ці іншае. У адваротным выпадку, па змаўчанні, я збіраецца надрукаваць прывітанне свет. Дык што ж гэта азначае? 

Што ж, дазвольце мне ісці наперад і захаваць гэты файл, а затым робяць argv0, а затым ./argv0, Enter. І гэта кажа прывітанне свет. Цяпер, чаму гэта? 

Што ж, атрымліваецца, у любы час вы запусціць праграму ў камандным радку, вы запаўняеце у тым, што мы будзем звычайна называем вектар аргументаў. Іншымі словамі, аўтаматычна кампутар, аперацыйная сістэма, збіраецца перадаць вашай праграме Сам спіс усіх слоў што чалавек набраў на падказка, у выпадку, калі праграміст хоча зрабіць нешта з гэтай інфармацыяй. І ў гэтым выпадку адзінае слова, Я набраў у радку з'яўляецца ./argv0. 

І таму лік аргументаў, з'яўляецца перадаецца ў маёй праграме толькі адзін. Іншымі словамі, аргумент разлічваць, інакш вядомы як ARGC тут як цэлы лік, гэта толькі адзін. Адзін з іх, вядома, не роўна двум. І так гэта тое, што друкуе, прывітанне свет. 

Але дазвольце мне ўзяць гэта недзе. Дазвольце мне сказаць, argv0. А потым, як пра Марыю? А затым націсніце клавішу Enter. 

І да вашага ведама, што чароўным чынам тут адбываецца. Цяпер, замест прывітанне свет, у мяне ёсць змяніў паводзіны гэтай праграмы прымаючы ўваход не ад Get радок або якой-небудзь іншай функцыі, але з, па-відаць, мая каманда Сам, што я першапачаткова надрукаваў. І я магу гуляць у гэтую гульню зноў змяняючы яго Стелиос, напрыклад. 

А цяпер я бачу іншае імя да гэтага часу. І тут, я мог бы сказаць, Анди. І я мог бы сказаць Zamyla. І мы можам гуляць у гэтую гульню на працягу ўсяго дня, проста затыкаць ў розных значэннях, да таго часу, як я даць менавіта два словы ў камандным радку такім чынам, што ARGC, граф мой аргумент, 2. 

Бачу я, што імя падлучаны да Printf, у гэтым стане тут? Такім чынам, мы, здаецца, у цяперашні час выразны патэнцыял прымаць ўваходны сігнал ад іншага механізму, ад так званай каманднага радка, замест таго, каб чакаць да таго часу, пакуль карыстач не запускае праграму, а затым заахвоціць яго ці яе выкарыстоўваючы нешта накшталт атрымання радка. 

Дык што ж гэта? ARGC, зноў жа, гэта ўсяго толькі цэлы лік, колькасць words-- arguments-- што карыстач пры ўмове, на падкажыце, у акне тэрмінала, у тым ліку назва праграмы. Такім чынам, наша ./argv0 з'яўляецца, па сутнасці, назва праграмы, ці як я запусціць праграму. 

Гэта лічыцца як слова. Так ARGC будзе 1. Але калі я пішу Стелиос, або Andi або Zamyla, або Марыя, гэта азначае, што колькасць аргументаў роўна двум. І вось зараз ёсць два словы, якія перадаюцца ст. 

І заўважце, мы можам працягнуць гэтую логіку. Калі б я на самой справе сказаць нешта накшталт Zamyla Чан, поўнае імя, тым самым перадаўшы тры аргументу ў агульнай складанасці, Цяпер ён зноў гаворыць па змаўчанні, таму што, вядома ж, 3. ня роўна 2. 

І вось такім чынам, у мяне ёсць доступ праз ARGV гэты новы аргумент што мы маглі б тэхнічна называць усё, што заўгодна. Але ў адпаведнасці з пагадненнем, гэта ARGV і ARGC адпаведна. ARGV, вектар аргументаў, з'яўляецца свайго роду сіноніма для праграмавання функцыя ў C называецца масіў. 

Масіў ўяўляе спіс значэнняў аналагічных назад, да спіны, да спіны, да спіны. Іншымі словамі, калі хтосьці тут, у RAM, наступны прама побач з ім, і побач з ім. Яны не паўсюль. І гэта апошні сцэнар, дзе рэчы знаходзяцца паўсюль у памяці, можа быць на самой справе магутная функцыя. Але мы вернемся да таго, што, калі мы казаць аб мудрагелістых структур дадзеных. На дадзены момант, масіў проста кавалак бесперапыннай памяці, кожны з якіх элементы назад, да спіны, да спіны, да спіны, і, як правіла той жа самы тып. 

Так што калі вы думаеце пра тое, ад А хвіліну назад, што такое радок? Ну, радок, як Zamyla, Z-А-М-У-Л-А, гэта, тэхнічна, проста масіў. Гэта масіў знакаў. 

І таму, калі мы сапраўды зрабіць гэта, як я зрабіў раней, як кавалак памяці, атрымліваецца, што кожны з іх сімвалаў займае байт. А тут што асаблівая вартавога сімвал, зваротная касая 0, ці ўсе восем біт 0, што размяжоўвае канец гэтага радка. Так радок, атрымліваецца па-за, цытуюць Unquote радок, гэта проста масіў chara-- асмальваецца быўшы фактычным тыпам дадзеных. 

А цяпер ARGV, meanwhile-- давайце вернемся да праграмы. ARGV, хоць мы бачым, слова Радок тут, не з'яўляецца сама радок. ARGV, вектар аргументаў, ўяўляе сабой масіў радкоў. 

Гэтак жа, як вы можаце мець масіў сімвалаў, вы можаце мець больш высокі ўзровень, масіў strings-- так, напрыклад, калі я набраў хвіліну назад ./argv0 argv0, прастору Z-A-M-Y-L-A, я сцвярджаў, што ARGV меў два радкі ў it-- ./argv0, і Z-A-M-Y-L-A. ў Іншымі словамі, ARGC было 2. Чаму гэта? 

Ну, па сутнасці, тое, што адбываецца на тым, што кожная з гэтых радкоў гэта, вядома, масіў сімвалаў як і раней, кожны з якіх персанажы займае адзін байт. І не блытайце фактычную 0 у назве праграмы з 0, што азначае ўсе 80 біт. І Zamyla, тым часам, па-ранейшаму таксама масіў знакаў. 

Такім чынам, у рэшце рэшт, гэта на самай справе выглядае наступным чынам пад капотам. Але ARGV, па сваёй прыродзе, як галоўны працы, дазваляе мне абгарнуць усё гэта да ў, калі вы будзеце, большы масіў што, калі мы крыху больш спрасціць што карціна выглядае і ня дастаткова намаляваць яе ў маштабе там, Гэты масіў з'яўляецца толькі памерам 2, першы элемент якога змяшчае радок, другі элемент якая змяшчае радок. І, у сваю чаргу, калі вы выгляд павелічэння на кожным з гэтых радкоў, што вы гл пад капотам з'яўляецца тое, што кожны радок проста масіў знакаў. 

Цяпер, гэтак жа, як са радкамі, мы былі ў стане атрымаць доступ да сп-га знака ў радку з дапамогай гэтай квадратнай дужкі абазначэння. Сапраўды гэтак жа, з масівамі увогуле, мы можам выкарыстоўваць квадратныя дужкі, абазначэння, каб атрымаць на любую колькасць радкоў у масіве? Напрыклад, дазвольце мне ісці наперад і рабіць гэта. 

Дазвольце мне ісці наперад і стварыць argv1.c, які трохі адрозніваецца на гэты раз. Замест праверкі для argc2, Я буду замест гэтага. Для инт я атрымліваю 0, я менш чым ARGC, я плюс плюс, а затым раздрукаваць ўнутры гэтага, адсоткаў s, новая лінія, а затым ARGV кранштэйны я. 

Такім чынам, іншымі словамі, я не маем справу з асобныя знакі ў дадзены момант. ARGV, як вынікае з гэтых пусты квадрат брекет справа ад імя ARGV, азначае ARGV масіў радкоў. І ARGC гэта проста инт. 

Гэтая лінія тут, 6, з'яўляецца кажучы набор я роўным 0. Граф ўвесь шлях да, але не уключаючы, ARGC. І пасля на кожнай ітэрацыі, раздрукаваць радок. Якая радок? 

I-га радка ў ARGV. Так што ў той час, перш чым я быў выкарыстоўваючы квадратныя дужкі абазначэння, каб атрымаць у г-й знак у радку, цяпер Я выкарыстоўваю квадратныя дужкі, абазначэння каб атрымаць у радку й у масіве. Так што гэта свайго роду адзін пласт вышэй, канцэптуальна. 

Так што акуратным пра гэта Праграма цяпер, калі я кампілюецца argv1, а затым зрабіць ./argv1, а затым увядзіце у чымсьці накшталт бара Baz Foo, якія з'яўляюцца тры стандартныя словы, якія вучоны дасягае на працягу любога часу ён ці яна мае патрэбу ў некаторых шаблонныя словы, і націсніце Enter, кожнае з гэтых слоў, у тым ліку назва праграмы, якая знаходзіцца ў ARGV на першым месцы, заканчваецца друкуецца па адным за раз. І калі я змяніць гэта, і я кажу: нешта накшталт argv1 Zamyla Чан, мы атрымліваем ўсе тры з іх словы, што з'яўляецца argv0, argv1, argv2, таму што ў гэтым выпадак ARGC, лічыльнік, 3. 

Але што акуратны, калі вы разумееце, што ARGV проста масіў радкоў, і вы разумееце, што радок ўяўляе сабой масіў сімвалаў, мы можам на самай справе выгляд выкарыстоўваць гэтую функцыю квадратныя дужкі абазначэння некалькі разоў каб выбраць радок, а затым выберыце знак у радку, дайвінг глыбей наступным чынам. У гэтым прыкладзе, адпусьці мяне наперад і назваць гэтую argv2.c. І ў гэтым прыкладзе, дазвольце мне ісці наперад і зрабіць following-- для INT я атрымліваю 0, я менш ARGC, я плюс плюс, гэтак жа, як і раней. Такім чынам, у іншым words-- і зараз гэты становіцца досыць складанай. Тады я збіраюся сказаць, перабіраць струны ў ARGV, у якасці каментара да сябе. І тады я буду мець укладзены цыкл, які вы, верагодна, зрабілі ці лічацца рабіць у пустым месцы, дзе Я хачу сказаць, я int-- не збіраецца выкарыстоўваць я зноў, таму што я не хачу, каб цень, або свайго роду перапісаць існуючы I. 

Я збіраюся, а не, скажам, J, так як гэта мая перайсці да зменнай пасля таго як я, калі я проста спрабую разлічваць простыя лікі. Для J атрымлівае 0--, а таксама, п, збіраецца атрымаць кармавой даўжыню ARGV кранштэйна I, да таго часу, J менш т, J плюс плюс, зрабіце наступнае. А вось цікавая частка. 

Раздрукуйце характар ​​і новую лінію, падлучыўшы ARGV кранштэйн I, кранштэйн J. ОК, так што дазвольце мне дадаць некаторыя каментары тут. перабраць сімвалы у бягучай радку, друк J-й знак у г-м радку. Так што цяпер, давайце разгледзім Што азначаюць гэтыя каментары. 

Перабор па струнах у argv-- колькі радкі ў ARGV, які з'яўляецца масівам? ARGC шмат, таму я ітэрацыя ад я роўна 0 да ARGC. У той жа час, колькі знакаў у г-га радка ў ARGV? 

Ну, каб атрымаць гэты адказ, Я проста называю даўжыню радка на I догляд бягучай радкі о, што ARGV кранштэйны я. І я збіраюся часова захоўваць, што значэнне п, толькі для мэт кэшавання, памятаць яго эфектыўнасці. І тады я буду ініцыялізаваць J 0, працягваць ісці так доўга, як J менш п, і на кожны крок ітэрацыі J. 

А потым тут, у мой каментар у радку 12, раздрукаваць сімвал, а затым новай лініі, спецыяльна ARGV кранштэйны я дае мне I-га радка у argv-- так што першае слова, то Другое слова, трэцяе слова, што заўгодна. А потым J нырае глыбей і атрымлівае я J-й сімвал гэтага слова. І так, у сутнасці, вы можаце звяртацца ARGV як мнагамернае, у якасці двухмернага масіва ,, прычым кожнае слова выгляд выглядае як гэта ў вашым уяўленні вочы, і кожны знак з'яўляецца свайго роду складаецца ў слупок, калі гэта дапамагае. 

На самай справе, калі мы дражніць гэта адзін ад аднаго ў будучых тыдняў, гэта будзе трохі больш складанай, чым гэта. Але вы можаце рэальна думаць пра тое, што на дадзены момант, як толькі што гэта двухмерная Масіў, у выніку чаго адзін узровень яго гэта ўсё радка. І потым, калі вы нырае ў глыбей, вы можа атрымаць у асобных сімвалаў у ім, выкарыстоўваючы гэтыя абазначэння тут. 

Дык што ж такое чысты эфект? Дазвольце мне ісці наперад і зрабіць argv2-- цыраваць яго. Я зрабіў памылку тут. ўскосна абвясціўшы бібліятэка функцый Стырлінга. Так што ўвесь гэты час, гэта магчыма, мэтазгодна што мы накшталт аздаблення менавіта там, дзе мы пачалі. 

Я аблажаўся, безумоўнае прызнанне бібліятэка функцый Стырлінга. Добра, пачакайце хвіліну. Я памятаю, што, асабліва так як гэта прама тут. Мне трэба, каб уключыць string.h ў гэтая версія праграмы. 

Дазвольце мне ісці наперад і ўключаюць у сябе string.h, акрамя таго, што, ісці наперад і перасабраць argv2. І цяпер, тут мы ідзем, зрабіць argv2, Enter. І хоць гэта крыху загадкавыя на першы погляд, звярніце ўвагу, што, на самай справе, тое, што раздрукоўваецца з'яўляецца кропка argv2. 

Але калі я ўвесці некаторыя словы за падкажыце, як argv2 Zamyla Чан, Калі ласка, увядзіце, таксама трохі загадкавыя на першы погляд. Але калі мы пракручваем назад уверх, ./argv2 Z-А-М-У-Л-З-Н-А-Н. Такім чынам, мы ітэрацыю над кожным словам. І, у сваю чаргу, мы ітэрацыі кожны знак у слове. 

Цяпер, пасля таго, як усё гэта, разумею, што ёсць адна дэталь мы былі свайго роду ігнараваць ўвесь гэты час. Мы проста дражняць адзін ад аднаго, што Ўваходы галоўных можа быць? Як наконт выхаду галоўных у? 

Увесь гэты час мы былі проста капіяванне і ўстаўка слова INT перад галоўным чынам, хоць вы можаце ўбачыць у Інтэрнэце, часам няправільна ў больш ранніх версіях С і кампілятараў, што яны кажуць, што пустэча, ці ўвогуле нічога. Але, на самой справе, для версіі З, што мы выкарыстоўваем, C 11, ці 2011, рэалізаваць што яно павінна быць инт. І гэта павінна быць альбо несапраўдным або ARGC і ARGV тут. 

Але чаму INT галоўны? Што гэта на самай справе вяртанне? Што ж, аказваецца, увесь гэты час, у любы час вы напісалі праграма галоўная заўсёды вяртаецца нешта. Але гэта было рабіць гэта таемна. 

Гэта нешта ёсць INT, у радку 5 прапаноўвае. Але што INT? Ну, ёсць такая канвенцыі ў галіне праграмавання, прычым, калі нічога не мае пайшло не так, і ўсё добра, праграмы і функцыі ў цэлым return-- некалькі counterintuitively-- 0. 0 ў цэлым азначае, што ўсё добра. Так што нават калі вы думаеце гэта як хлусня ў многіх кантэкстах, гэта на самай справе азначае, як правіла, добрая рэч 

У той жа час, калі праграма вяртае 1, ці адмоўны 1, або 5, або адмоўны 42, або любы ня-0 значэнне, што ў цэлым азначае што нешта пайшло не так. На самай справе, на вашым ўласным Mac ці PC, Вы, магчыма, на самай справе бачыў паведамленне пра памылку, у выніку чаго яго кажа што-небудзь ці іншае, памылка код адмоўны 42, ці код памылкі 23, ці нешта ў гэтым родзе. Гэты лік, як правіла, толькі намёк праграмісту або кампаніі што зрабіў праграмнае забеспячэнне, што пайшло не так і чаму, такім чынам, каб яны маглі глядзець праз іх дакументацыя ці код, і высветліць, што памылка на самай справе азначае. Як правіла, не карысным для нас канчатковых карыстальнікаў. 

Але калі асноўныя вяртае 0, усё добра. І калі вы не пакажаце якія асноўныя павінны вярнуцца, ён проста будзе аўтаматычна вяртае значэнне 0 для вас. Але, вяртаючыся нешта яшчэ на самай справе карысна. 

У гэтай заключнай праграме, дайце мне ісці наперад і назваць гэтую exit.c, і ўвесці апошні з сённяшніх тэмы, вядомыя як код памылкі. Дазвольце мне ісці наперад і ўключаюць у сябе нашы знаёмыя файлы Наверсе, зрабіце INT галоўны. І на гэты раз, давайце рабіць Int ARGC, Радок ARGV, і з маіх дужках мае на ўвазе, што гэта ў масіве. І тады дазвольце мне зрабіць праверку наяўнасці свядомасці. На гэты раз, калі ARGC ня роўна 2, то вы ведаеце, што? Забудзь. Я хачу сказаць, што, эй, карыстальнік, вам не хапае аргумент каманднага радка зваротная касая п. 

А потым гэта ўсё. Я хачу, каб выйсці. Я збіраюся прэвентыўна, і заўчасна сапраўды, вяртанне нешта іншае, чым колькасць 1. Перайсці да значэння для першага памылка, якая можа адбыцца 1. Калі ў вас ёсць нейкі іншы памылковы сітуацыя, якая можа адбыцца, Вы маглі б сказаць, вяртанне 2 ці вяртанне 3, або можа быць, нават адмоўны 1 ці адмоўны 2. 

Гэта толькі коды завяршэння якія з'яўляюцца, як правіла, толькі карысна для праграміста, або кампанія, суднаходная праграмнае забеспячэнне. Але той факт, што гэта ня 0, што важна. Так што, калі ў гэтай праграме, я хачу гарантаваць, што гэтая праграма толькі працуе, калі карыстальнік дае мне з колькасцю аргументаў, з двух, назва праграмы, а таксама некаторыя іншыя слова, я магу ўжываць столькі, колькі варта, крычаць на карыстальніка з PRINTF прымаўцы, адсутнічае аргумент каманднага радка, вяртае 1. Гэта будзе проста неадкладна выйсці з праграмы. 

Толькі калі ARGC роўны 2 мы атрымаем ўніз тут, у які момант я збіраюся сказаць, прывітанне адсоткаў s, зваротны слэш н, argv1. Іншымі словамі, я ня будзе пасьля таго, як ARGV 0, які з'яўляецца толькі назва праграмы. Я хачу, каб надрукаваць Прывітанне, коска, другое слова, якое надрукаваў чалавек. І ў гэтым выпадку на радок 13, усё добра. 

Я ведаю, што ARGC 2 лагічна выцякае з гэтай праграмы. Я збіраюся ісці наперад і вяртаць 0. Як і ў бок, майце на ўвазе, што гэта дакладна ў пустым месцы, а таксама. 

Па логіцы рэчаў, я мог бы гэта зрабіць і інкапсуляваць гэтыя радкі кода ў гэтым пункце астатняе тут. Але гэта свайго роду залішне водступы мой код. І я хачу, каб зрабіць супер ясна, што незалежна ад таго, па змаўчанні, прывітанне нешта і будзе надрукаваны, да таго часу, пакуль карыстальнік ўзаемадзейнічае. 

Так што гэта вельмі распаўсюджана выкарыстанне стан, проста калі, злавіць некаторыя памылковыя сітуацыя, а затым выйсці. І тады, да таго часу, усё ну, не маюць іншага, але проста код звонку, што, калі, таму што гэта эквівалент у гэтым прыватны выпадак, лагічна. Так што я вяртаюся 0, проста відавочна азначае, што ўсё добра. 

Калі я прапусціў вяртанне 0, было б аўтаматычна мяркуецца, для мяне. Але цяпер, калі я вяртаюся адзін, па меншай меры гэтым выпадку, Я збіраюся, для добрай мерай і яснасць, вяртае 0 ў гэтым выпадку. Так што цяпер дазвольце мне ісці наперад і зрабіць выхад, які з'яўляецца ідэальным Segue проста сысці. 

Але зрабіць выхад, і адпусціць мяне наперад і рабіць ./exit, Enter. І праграма закрычаў на мяне, адсутнічае аргумент каманднага радка. Добра, дазвольце мне супрацоўнічаць. 

Дазвольце мне замест таго, каб рабіць ./exit, Дэвід, Enter. А цяпер ён кажа, прывітанне Дэвід. І вы звычайна не бачыце гэта. 

Але аказваецца, што ёсць асаблівы шлях у Linux на самай справе ўбачыць з тым, што код завяршэння праграмы завяршаецца. Часам у графічным свет, як Mac OS або Windows, вы бачыце толькі гэтыя лічбы, калі паведамленне пра памылку з'яўляецца на экране і праграміст паказвае, што лік. Але калі мы хочам, каб убачыць, што памылка паведамленне, мы можам зрабіць гэта here-- так ./exit, Enter, друк адсутнічае аргумент каманднага радка. 

Калі я цяпер рабіць рэха $?, Які смешна загадкавыя гледзячы. Але $? з'яўляецца магічным загаворам што кажа, эй, кампутар, скажыце мне, што папярэдні код выхаду праграмы быў. І я ўдарыў Enter. Я бачу 1, таму што гэта тое, што я сказаў сваёй асноўнай функцыі, каб вярнуцца. 

У той жа час, калі я ./exit Давіда, і націсніце Enter, я бачу, прывітанне Давіда. І калі я цяпер рабіць рэха $?, Я бачу прывітанне 0. І такім чынам гэта будзе на самой справе быць каштоўнай інфармацыі у кантэксце адладчыка, не так шмат, што вы, чалавек, будзе клапаціцца. Але адладчык і іншыя праграмы, якія мы будзем выкарыстоўваць у гэтым семестры будзе часта глядзець на гэты лік, нягледзячы на ​​тое, што гэта свайго роду схаваны калі не шукаць яго, каб вызначыць, ці сапраўды програмы выкананне было правільным ці няправільным. 

І так, што прыводзіць нас да гэта, у канцы дня. Мы пачалі сёння, гледзячы на адладкі, і ў сваю чаргу, у ходзе сама па сабе, а затым больш цікава, тэхнічна пад капотам на тое, што радкі, якія доўжацца тыдзень мы проста ўзялі нешта само сабой разумеецца, і, вядома, узяў іх як само сабой разумеецца ў пустым месцы. 

Затым мы разгледзелі, як мы можам атрымаць доступ асобныя сімвалы ў радку, а затым зноў узяў на больш высокі ўзровень глядзець на рэчы, гледзячы на ​​тое, як well-- калі мы хочам атрымаць на індывідуальным элементы ў спісе, як структура, мы не можам зрабіць гэта з некалькімі радкамі? І мы можам з аргументамі каманднага радка. Але гэтая карціна тут проста скрынкі Паказальна ў гэтай агульнай ідэі масіва або спісу або вектара. І ў залежнасці ад кантэкст, усе гэтыя словы азначаюць трохі розныя рэчы. Такім чынам, у C, мы толькі збіраемся казаць аб масіве. І масіў ўяўляе сабой кавалак памяці, кожны з якіх гэта элементы з'яўляюцца сумежнымі, назад, да спіны, да спіны, да спіны. 

І гэтыя элементы, як правіла, аднаго і таго ж тыпу дадзеных, сімвалаў, характар, характар, характар, або радок, радок, радок, радок, або INT, INT, INT, тое, што гэта мы спрабуем захаваць. Але ў рэшце рэшт, гэта як гэта выглядае канцэптуальна. Вы бераце ваш памяці або АЗП кампутара. І вы выразаючы яго ў аднолькавага памеру скрынкі, усе з якіх вярнуліся, да спіны, каб назад, да спіны такім чынам. 

І што прыемна аб гэтая ідэя, і той факт, што мы можам выказаць значэння ў гэтым выпадку з першым з нашых структур дадзеных у класе, азначае, што мы можам пачаць вырашыць праблемы з кодам што прыйшло так інтуітыўна у тыдзень 0. Вы памятаеце, тэлефон Прыклад кнігі, дзе мы выкарыстоўвалі падзяляй і ўладар, або двайковы алгарытм пошуку, прасейваць ў цэлым куча імёнаў і нумароў. Але мы меркавалі, нагадаем, што гэта Тэлефонная кніга была ўжо адсартаваны, што хтосьці ўжо фігурны out-- дадзены спіс імёнаў і numbers--, як у алфавітным парадку іх. І зараз, калі ў C мы, таксама ёсць магчымасць закласці рэчы, а не фізічна ў тэлефоннай кнізе але практычна ў кампутара памяць, мы зможам на наступным тыдні ўвесці зноў this-- першы нашых структур дадзеных у array-- але што больш важна, фактычны кампутар Алгарытмы навукі рэалізаваны у кодзе, з дапамогай якога мы можам захоўваць дадзеныя ў структурах, як гэта, а затым пачынаюць маніпуляваць ёю, і на самай справе вырашыць праблемы, звязаныя з ім, і пабудаваць на вяршыні гэтага, у канчатковым рахунку, праграмы ў C, у Python, у JavaScript, запытаў да баз дадзеных з SQL? 

І мы бачым, што ўсе гэтыя розныя ідэі блакіроўкі. Але цяпер, нагадаем, што Дамен, які мы ўвялі сёння была гэтая рэч тут, і свет крыптаграфіі. А сярод наступных праблем вы самі будзе вырашаць гэта мастацтва крыптаграфіі, скремблирования і дескремблирования інфармацыя, і шифрации і расшыфроўка тэксту, і мяркуючы, у канчатковым рахунку, што цяпер вы ведаеце, што знаходзіцца пад капотам так што, калі вы бачыце ці атрымаць паведамленне как это, вы самі можаце расшыфраваць яго. Усё гэта, і больш у наступны раз. 

[ВИДЕОВОСПРОИЗВЕДЕНИЕ] 

-Mover Толькі што прыбыў. Я збіраюся ісці візіт яго прафесар каледжа. Так. Прывітанне. Гэта ты. Пачакайце! Дэвід. Я проста спрабую зразумець што здарылася з вамі. Калі ласка, што-небудзь можа дапамагчы. Вы былі яго каледж сусед па пакоі, ці не так? Вы былі там з ім, калі ён завяршыў праект CS50? 

[МУЗЫКА] 

-вот Быў CS50. 

Я люблю гэтае месца. 

-Eat Уверх. Мы збіраемся з бізнэсу. 

[КАНЕЦ засьпяваю] 