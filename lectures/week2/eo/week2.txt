[MUZIKO Ludanta] 

DAVID J. Malan: Bone. Tiu estas CS50 kaj ĉi estas la komenco de Semajno 2. Kaj vi memoras ke super la pasinta paro de semajnoj, ni estis enkondukante komputilo scienco kaj, siavice, programado. 

Kaj ni komencis la rakonton tra Nulo, ke grafikan lingvo MIT'S Media Lab. Kaj tiam laste, pasintsemajne, ĉu ni enkonduki higher-- a malalta nivelo lingvo konata kiel C, iu kiu estas pure teksta. Kaj cetere, lastan fojon ni esploris ene de tiu kunteksto kelkaj konceptoj. 

Tiu, revokon, estis la tre unua programo ni rigardis. Kaj ĉi programo, tute simple, presas el "saluton, mondo." Sed estas tiel ŝajna magio okazas. Ekzistas tiu #include kun tiuj angulajn krampojn. Estas int. Ekzistas (void). Ekzistas krampoj, krispa krampoj, punktokomoj, kaj tiel plu. 

Kaj tiel, memoru ke ni enkondukis Scratch tiel ke ni povus, ideale, vidu pasinteco ke sintakso, la aĵoj kiuj vere ne ĉiuj kiuj intelekte Interesa sed frue estas, absolute, iom malfacila envolver vian menson ĉirkaŭe. Kaj cetere, unu el la plej komunaj aferojn frue en programado klaso, speciale por tiuj malpli komforta, estas akiri frustrita de kaj stumblis supren per certaj sintaksaj eraroj, ne mencii logikaj eraroj. Kaj do inter niaj celoj hodiaŭ, fakte, volo esti ekipi vin kun iuj problemo-solvanta teknikoj por kiom better solvi problemojn sin en la formo de depuración. Kaj vi memoras, ankaŭ, ke la medio kiu nin enkondukis lasta tempo oni nomis CS50 IDE. Jen ttt-bazita softvaro kiu permesas plani en la nubo, tiel diri, konservante cxiujn viajn dosierojn kune, ni denove volas hodiaŭ. Kaj memoru ke ni revizitita tiuj temoj ĉi tie, inter ili funkciojn kaj maŝojn kaj variabloj, kaj Buleaj esprimoj, kaj kondiĉojn. Kaj fakte kelkaj pli ke ni tradukite de la mondo de Scratch al la mondo de C. 

Sed la fundamenta konstruaĵo blokoj, tiel diri, estis vere ankoraŭ la sama pasintsemajne. Fakte, ni vere nur havis malsamaj enigmo pecon, se vi volas. Anstataŭ ke purpuraj savi bloko, ni anstataŭe estis printf, kiu estas tiu funkcio en C kiu permesas presi ion kaj formati ĝin sur la ekrano. Ni enkondukis la CS50 Biblioteko, kie vi havas nun je via dispono get_char, kaj get_int kaj get_string, kaj kelkaj aliaj funkcioj kiel bone, per kiu vi povas akiri enigo de la uzanto propra klavaro. Kaj ni prenis rigardu aferoj kiel these- bool, kaj char, kaj duobla, kaleŝego, int, long_long ŝnuro. Kaj ekzistas eĉ aliajn datumtipoj en C. 

Alivorte, kiam vi deklaras ŝanĝiĝema stoki iu valoro, aŭ kiam vi apliki funkcio kiu revenas iun valoron, vi povas specifi kion tipo de valoro kiu estas. Estas ĝi ŝnureto, kiel sekvenco de karakteroj? Cxu estas nombro, kiel entjero? Cxu estas glitpunktaj valoro, aŭ similaj? Do en C, kontraste Scratch, ni reale komencis specifi kia datumoj ni returniĝo aŭ uzante. 

Sed, kompreneble, ni ankaŭ renkontis kelkaj fundamentaj limoj de komputado. Kaj precipe, tiu lingvo C, revokon ke ni prenis rigardu entjero overflow, la realaĵo ke se vi nur havas finia kvanto de memoro aŭ, specife, finia nombro de bitoj, vi povas nur kalkuli tiel alta. Kaj tiel ni rigardis tiun ekzemplon tie per kontraŭrevolucio en aviadilo,, fakte, se kurante sufiĉe longe estus inunda kaj rezulti en programaro fakta fizika potencialo eraro. 

Ni ankaŭ rigardis flosanta punkto imprecision, la realaĵo ke nur finia nombro de bitoj, ĉu ĝi estas 32 aŭ 64, Vi nur povas specifi multaj nombroj post dekuma punkto, post kiu vi komencu akiri malpreciza. Do ekzemple, triono en la mondo tie, en nia homa mondo, ni scias estas nur malfinia nombro de 3s post la dekuma punkto. Sed komputilo ne povas nepre reprezentas senfinan nombron de ciferoj se vi nur permesas iun finia kvanto de informo. 

Tial ne nur ni ekipi vin kun granda potenco en terminoj de kiel vi povus esprimi sin ĉe klavaro en terminoj de programado, ni ankaŭ limigita kio vi povas reale fari. Kaj efektive, cimoj kaj eraroj povas ekesti de tiuj specoj de aferoj. Kaj fakte, inter la temoj hodiaŭ tuj estos temoj kiel depuración kaj fakte rigardis sub la kapuĉo ĉe kiel aferoj estis lanĉita lastan semajnon efektive implementado por ke vi pli bone kompreni ambaŭ la kapablojn de kaj la limigoj de lingvo kiel C. 

Kaj fakte, ni senŝeligas reen la tavolojn de la plej simpla de datumstrukturo, iu nomita tabelo, kiu Nulo okazas nomi "listo." Estas iomete malsama en tiu kunteksto. Kaj tiam ni ankaŭ enkonduki unu el la unua de nia domajno-specifa problemojn en CS50, la mondo de ĉifriko, la arto de grimpadi aŭ en ciphering informo tiel ke vi povas sendi sekretajn mesaĝojn kaj malkodi sekretajn mesaĝojn inter du personoj, A kaj B. 

Do antaŭ ol ni transiro al tiu nova mondo, ni provu ekipi vin kun iuj teknikoj per kiu vi povas forigi aŭ redukti almenaŭ iuj de la frustraciones ke vi probable renkontis dum la pasinta semajno sole. Fakte, antaŭ vi such-- kelkaj via unua problemoj en C. Kaj probablecoj estas, Se vi estas kiel mi, la unuan fojon Vi provu tajpi ekster programo, eĉ se vi pensas logike la programo estas sufiĉe simpla, vi eble tre bone trafis muron, kaj la tradukilo ne tuj kunlabori. Fari aŭ Clang ne tuj efektive fari vian peton. 

Kaj kial povus esti? Nu, ni rigardu, eble, simpla programo. Mi tuj iros antaŭen kaj savi ĉi en dosiero intence nomita buggy0.c, ĉar mi konas ĝin esti mankhava anticipe. Sed mi ne rimarkas ke se tiu estas la unua aŭ dua aŭ tria programo ke mi fakte farante min. Do mi tuj iros antaŭen kaj tajpi eksteren, int main (void). Kaj tiam ene de mia krispa krampoj, tre familiara ( "saluton, world-- backslash, n ") - kaj semi-dupunkto. 

Mi savis la dosieron. Nun mi tuj iros malsupren al mia fina fenestro kaj tipo ŝminko buggy0, ĉar, denove, la nomo de la dosiero hodiaŭ estas buggy0.c. Do mi tajpas fari buggy0, Enter. 

Kaj, ho, ho, memoras de lasta horo ke neniu erarmesaĝojn estas bona afero. Do neniu eligo estas bona afero. Sed tie mi havas klare iu nombro da eraroj. 

Tiel la unua linio de produktado post tajpado fari buggy0, revokon, estas Clang estas sufiĉe abundajn eligo. Sub la kapuĉo, CS50 IDE estas agordita uzi tutan faskon da ebloj kun ĉi tradukilo por ke vi ne havas pensi pri ili. Kaj tio estas ĉio, kion unuan linion per kiu komenciĝas kun Clang. 

Sed post tio, la problemoj komencas faras lian aperon. Buggy0.c sur linio 3, karaktero 5, estas granda, ruĝa eraro. Kio estas tio? Implice deklari biblioteko funkcio printf kun tipo int (const char *, ...) [-Werror]. Mi volas diri, ĝi tre rapide ricevas tre arkaikaj. Kaj certe, unue rigardo, ni ne volis atendas vin kompreni la tuteco de tiu mesaĝo. Kaj tiel unu el la lecionoj hodiaŭ tuj esti provi rimarkos ŝablonoj, aŭ similaj aferoj, al eraroj vi havu renkontis en la pasinteco. Do ni turmentus aparte nur tiuj vortoj kiuj aspektas familiara. La grandaj, ruĝaj eraro estas klare simbolon esti erara. 

implice deklari biblioteko funkcio printf. Do eĉ se mi ne bone komprenas kion implice deklari biblioteko funkcio rimedoj, la problemo certe rilatas al printf iel. Kaj la fonto de tiu temo devas vidi kun deklarante ĝin. 

Deklarante funkcio estas mencii ĝin por la unua fojo. Kaj ni uzis la terminologion lasta semajno de deklari funkcia prototipo, ĉu per unu linio je la supro de via propra dosiero aŭ en tn kaplinio dosiero. Kaj en kio dosiero faris ni diras lasta semajno ke printf estas citaĵo, unquote, deklaris? En kio dosiero estas ĝia prototipo? 

Do se vi memoras, la unua afero, kiun mi tajpita, preskaŭ ĉiu programo lasta time-- kaj hazarde antaŭ momento komenciĝis tajpado mia volo estis tiun here-- hash-- #include <stio-- por enigo / output-- skalara h Kaj efektive, se mi nun savu tiu dosiero, mi tuj iri antaŭen kaj liberigi mian ekranon, kiun vi povas fari tajpante Klara, aŭ vi povas teni Kontrolo L, nur malbari vian terminalfenestro nur forigi iun malordon. 

Mi tuj iros antaŭen kaj re-tipo ŝminko buggy0, Enter. Kaj voila, mi ankoraŭ vidas ke longa komando de Clang, sed estas nenia erarmesaĝo tiu tempo. Kaj efektive, se mi faras ./buggy0, samkiel lasta fojo, kie skalara signifas tiu dosierujo, Slash simple signifas, tie venas la nomon de la programo kaj ke nomo de la programo estas buggy0, Eniri, "saluton, mondo." 

Nun, kiel povus vi havas kolektadis ĉi solvo sen nepre rekonante kiel multaj vortoj kiel mi agis, certe, havanta farante tiun dum tiom da jaroj? Nu, realigi po la unua problemo aro, ni konigu vin al ordono ke CS50 propra stabo skribis nomitan help50. Kaj efektive, C faras specifo por la problemo aro kiel al kiel uzi tiun. 

Sed help50 estas esence programo kiu CS50 bastonon skribis ke permesas kuri iu komando aŭ kuri programon, kaj se vi ne komprenas liajn eligo, pasi lian eliron al help50, ĉe kiu punkto la programaro ke la kurson bastono skribis rigardos via programo eligo linio por linio, karaktero por karaktero. Kaj se ni, la personaro, rekoni la erarmesaĝo ke vi spertas, ni provos instigi vin kun iuj retorika demandoj, kun iuj konsiloj, multe kiel TF aŭ CA aŭ mem farus en persono ĉe oficejo horoj. 

Do rigardu al help50 se vi ne nepre rekoni problemo. Sed ne fidi lin tro multe kiel lambastono. Certe provi kompreni lian eligo kaj lerni de ĝi tiel ke nur unu-dufoje faros vin iam kuri help50 por aparta eraro mesaĝo. Post tio, vi devas esti bone ekipitaj mem elkompreni kio reale estas. 

Ni faru unu alia tie. Lasu min antaŭeniri kaj en alia dosiero ni nomas tiun buggy1.c. Kaj en la dosiero mi tuj deliberately-- sed ŝajnigi, ke mi ne kompreni kion eraro mi faris. 

Mi tuj iros antaŭen kaj fari this-- #include, ekde mi havas lernis mian lecionon de antaŭ momento. Int main (void), kiel antaŭe. Kaj tiam en ĉi tie mi iras fari ĉenon s - get_string. Kaj memoras de lasta tempo ke tio signifas, hej, Komputilo, donu al mi variablo, nomas ĝin s, kaj fari la tipo de tiu variablo kordo do mi povas stoki unu aŭ pli vortoj en ĝi. 

Kaj tiam dekstre-mana flanko de la egalsigno Estas get_string, kiu estas funkcio en la CS50 biblioteko kiu faras ĝuste tion. Ĝi ricevas funkcio kaj tiam manoj ĝin de dekstre maldekstren. Do ĉi egalsigno ne signifas "Egalas" kiel ni povus pensi en matematiko. Signifas asigno de dekstre maldekstren. Do tiu signifas, preni la kordo de la uzanto kaj gardi ŝin ene de s. 

Nun ni uzas ĝin. Lasu min nun kaj kiel dua linio, lasu min antaŭeniri kaj diru "saluton" - ne "mondo", sed "Saluton,% s-- kiu estas nia lokokupilo, komo s, kiu estas nia varia, kaj tiam semi-dupunkto. Do se mi ne ŝraŭbi supren tro multe tie, tio aspektas kiel korekta kodo. 

Kaj mia instinkto nun kompili ĝin. La dosiero nomata buggy1.c. Do mi tuj faru fari buggy1, Enter. Kaj Darn-ĝi, se oni ne eĉ pli eraroj ol antaŭe. Mi volas diri, estas pli erarmesaĝojn ĝi farus ŝajnas ol fakta linioj en tiu programo. 

Sed la takeaway tie estas, eĉ se vi estas premita kun du aŭ tri aŭ kvar pli erarmesaĝojn, enfokusigi ĉiam sur la tre unua de tiuj mesaĝoj. Rigardante la supro-plej unu, movo reen kiel necese. Do jen mi tajpis konsiston buggy1. Jen ke Clang eligo kiel atendis. 

Kaj jen la unua ruĝa eraro. Uzo de nedeklarita ensalutilo kordo, ĉu mi signifas normon en? Tiel normo en estas vere io alia. Ĝi raportas al la uzanto klavaro, esence. 

Sed tio ne estas kion mi volis diri. Mi signifis ŝnuro, kaj mi intencis get_string. Do kio estas tio, kion mi forgesis fari tiun tempon? Kio mankas cxi tiun tempon? Mi havas mian #include, do mi havas aliron al printf. 

Sed kion mi ne havas aliro al nur ankoraŭ? Nu, ĝuste kiel lasta fojo, Mi devas diri la tradukilo Clang kion tiuj funkcioj estas. Get_string ne venas kun C. Kaj en aparta, ĝi ne venas en la header dosiero,. Ĝi anstataŭe envenas ion la bastonon skribis, kiu estas malsama dosiero nomi sed trafe nomita. 

Do simple aldonante ke unu linio de code-- revokon de lasta horo ke kiam Clang kuras, ĝi tuj rigardi mian kodo supre sube, maldekstre dekstren. Ĝi tuj rimarkas, ho, vi deziras. Mi volas iri kaj trovi ke, kie ajn ĝi estas sur la servilo, kopiu kaj algluu ĝin, esence, en la pinto de via propra dosiero tiel ke ĉe tiu punkto en la rakonto, linio 1, la resto de la programo povas ja uzi iun el la funkcioj gxi, inter ili get_string. Do mi tuj ignori la resto de tiuj eraroj, ĉar mi ja suspektas ke nur la unua vere gravis. Kaj mi tuj iros antaŭen kaj rerun, post savi mian dosieron fari buggy1. Kaj voilà, ĝi faris laboron. Kaj se mi faras ./buggy1 kaj entajpu, cxar Ekzemple, Zamyla, mi nun ricevos saluton, Zamyla, anstataŭ saluton, mondo. 

Bone. Tial la takeaways tie tiam devas, unu, provu kolektu kiom vi povas el la erarmesaĝojn sole, rigardante en iu el la rekoneblaj vortoj. Barante ke uzu help50 po la problemo aro specifo. Barante ke ankaŭ ĉiam aspektas ĉe la supro eraro nur, almenaŭ komence, por vidi kion informo ĝi efektive povus cedi. Sed rezultu ke la eĉ pli funcionalidad konstruita en la CS50 biblioteko por helpi vi frue en la semestro kaj frue en programado eltrovi kio okazas erara. Do ni faru alian ekzemplon tie. Mi tuj nomas tiun buggy2, kiu, denove, tuj estos mankhava eksteren de la pordego, por dezajno. 

Kaj mi tuj iros antaŭen kaj do # include. Kaj tiam mi iros fari int main (void). Kaj tiam mi iros fari por buklo. Por (int i _ 0. i estas malpli ol aŭ egala al 10. i ++, kaj tiam en buklaj krampoj, mi tuj presi nur hashtag simbolo tie kaj nova linio karaktero. 

Do mia intenco kun ĉi programo estas tute simple persisti 10 fojojn kaj sur ĉiu ripeto de tiu buklo ĉiufoje tra la ciklo, elprinti hashtag, etiketon, etiketon. Unu po linio, ĉar mi havas la novan linion tie. Kaj memoras ke la por buklo, po lasta week-- kaj vi ricevos pli konas la sintakson uzante ŝin kun praktiko antaŭ long-- tio donas al mi variablon nomis i kaj fiksas ĝin al 0. 

Tio pliigas i sur ĉiu ripeto de 1. Tial mi iras al 1 al 2 al 3. Kaj tiam ĉi tiu kondiĉo en la mezo inter la punktokomoj iĝas kontrolis sur ĉiu ripeto fari certa, ke ni estas ankoraŭ ene gamo. Do mi volas persisti 10 fojojn, do mi havi ian tre intuicie ĝuste metu 10 kiel mia supera baro tie. 

Kaj tamen, kiam mi kuros ĉi, post kompili ĝin kun ŝminko buggy2-- kaj ĝi kompilas OK. Do mi ne havas Sintakseraro tiu tempo. Lasu min nun kaj kuri buggy2, Enter. Kaj nun rulumu supren. Kaj mi pliigas la grandeco de la fenestro. 

Mi ŝajnas havi 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Do ekzistas 11 hashtags, kvankam Mi klare metita 10 ene de ĉi buklo. Nun, iuj el vi povus vidi tuj kion la eraro estas ĉar ja tiu ne estas tre malfacile eraro fari. Sed estas tre komune faris tre frue. 

Kion mi volas atentigi, tamen, estas, kiel povus mi eltrovis tion? Nu, Ĝi rezultas ke la CS50 biblioteko venas kun ne nur get_string kaj get_int kaj get_float kaj aliaj funkcioj. Ĝi ankaŭ venas kun speciala funkcio nomita eprintf, aŭ, eraro printf. Kaj ekzistas nur fari ĝi iomete pli facila por vi kiam elpurigi vian kodon por ĝuste presi erarmesagxon sur la ekrano kaj scii kie gxi estis. 

Do ekzemple, unu aferon mi povus faru ĉi tie kun tiu funkcio estas this-- eprintf, kaj tiam mi iros por antaŭeniri kaj diri mi estas nun% i, backslash, n. Kaj mi tuj konekti la valoro de i. Kaj ĝis supro, ĉar tiu estas en la CS50 biblioteko, Mi tuj iros antaŭen kaj inkluzivi do mi havas aliron al ĉi tiu funkcio. Sed ni pripensu kion linio 9 supozas esti faranta. Mi tuj forviŝi tiun eventuale. Ĉi havas nenion komunan kun mia komunajn celo. Sed eprintf, eraro printf, estas nur signifita doni al mi iom diagnozaj informoj. Kiam mi kuros mia programo, mi volas vidu ĉi sur la ekrano temporalmente tiel nur por kompreni kio okazas. 

Kaj cetere, en ĉiu iteracio tie de la linio 9 Mi volas vidi, kio estas la valoro de i? Kio estas la valoro de i? Kio estas la valoro de i? Kaj, espereble, mi devus nur vidi ke mesaĝo, ankaŭ 10 fojojn. 

Do lasu min antaŭeniri kaj rekompili mian programon, kiel mi devas fari ajnan tempon Mi fari ŝanĝon. ./buggy2. Kaj now-- OK. Ekzistas multe pli okazas. Do lasu min rulumi supren en ankoraŭ pli granda fenestro. 

Kaj vi vidos ke ĉiu el la hashtags estas ankoraŭ presi. Sed intere ĉiu el ili estas nun ĉi diagnozaj eligo formatitan jene. La nomo de mia programo tie estas buggy2. La nomo de la dosiero buggy2.c. La numero de linioj de kiu tio estis presita estas linio 9. Kaj tiam dekstre de kiu estas la erarmesaĝo ke mi atendis. 

Kaj kio estas agrable pri tio estas ke nun mi ne devas nepre kalkuli en mia kapo: kion mia programo faras. Mi povas vidi ke en la unua ripeto i estas 0, tiam 1, tiam 2, tiam 3, tiam 4, tiam 5, tiam 6, tiam 7, tiam 8, tiam 9, tiam 10. Do atendi minuton. Kio okazas ĉi tie? Mi ankoraŭ ŝajnas esti rakonti kiel intencita ĝis 10. 

Sed kie mi komencu? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Do 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- la 11a fingro estas indika de la problemo. Mi ŝajnas esti rakontita malĝuste en mia banto. Anstataŭ iri 10 ripetoj, Mi startanta je 0, Mi finiĝante ĉe kaj tra 10. Sed ĉar, kiel komputilo, Mi startanta nombrado ĉe 0, Mi devas rakonti supren al, sed ne tra 10. 

Kaj tial la solvon, mi fine rimarkis tie, estas unu el du aferoj. Mi povis tre simple diri rakonti ĝis malpli ol 10. Do 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, kiu estas ja ĝusta, kvankam ĝi sonas iom malĝusta. Aŭ mi povus fari malpli ol aŭ egala 9, kiam mi komencas je 0. Aŭ se vi vere ne ŝatas tion, vi povas kalkuli tra 10 sed komencu je 1. Sed denove, ĉi nur ne ke komuna. En programming-- kvankam Ne tiel en Scratch-- sed en programado en C kaj aliaj lingvoj, kiel JavaScript kaj Python kaj aliaj, estas nur tre komuna por nia diskuto de duuma simple komenci kalkulon je la plej malalta nombro povas, kio estas 0. Bone. Do jen eprintf. Kaj denove, nun ke mi eltrovis mian problemo, kaj mi tuj iros reen al 0 tra malpli ol 10, mi tuj iru kaj forviŝi eprintf. 

Ĝi ne devus esti tie, kiam mi ekspedi mia kodo aŭ submetiĝi mian kodo aŭ montri ĝin al iu alia. Ĝi estas vere nur signifis esti uzita temporalmente. Sed nun mi fiksis tiun aparta problemo ankaŭ. 

Nu, ni faru unu pli ekzemplo tie ke mi tuj vipi supren jene. Mi tuj iros antaŭen kaj #include. $ 50 Kaj mi tuj iros antaŭen kaj #include. 

Kaj mi tuj savi dosiero kiel buggy3.c. Kaj mi tuj iros antaŭen kaj deklari int main (void). Kaj tiam ene de tie Mi tuj faros int i _ - Mi volas implementar programon kun get_negative_int. Tio ne estas funkcio kiu ekzistas ankoraŭ. Do ni tuj apliki en nur momento. Sed ni tuj vidos kial ĝi estas kalesxon unue enirpermesilo. Kaj unufoje mi akiris int de la uzanto, Mi simple tuj presi% i estas negativa entjera, backslash, n, komo, i. Alivorte, ĉiuj mi volas tiun programon fari estas atingi negativan int de la uzanto kaj tiam presi ke tia kaj tia estas negativa int. 

Nun mi devas plenumi la funkcion. Tial poste en mian dosieron, mi tuj iros antaŭeniri kaj deklari funkcio nomita get_negative_int (void) - kaj ni revenu al kion tiu linio signifas denove en moment-- int n; do-- do la following-- printf n estas :. Kaj tiam mi iros fari n - get_int, kaj fari ĉi dum n estas pli granda ol 0. Kaj tiam reveni n ;. 

Do ekzistas multe okazas en tio sed neniu el kiu ni ne rigardi pasintsemajne, almenaŭ mallonge. Tiel sur linio 10 tie Mi deklarita funkcio nomita get_negative_int, kaj mi metis (void), en krampoj, la kialo estanta tiu ne prenas enigo. Mi ne pasante ion al tiu funkcio. Mi nur nun io reprenos gxin. 

Kaj kion mi esperante reiri estas entjero. Ne estas datumtipo en C nomita negative_int. Ĝi simple int, do ĝi estas tuj esti sur ni certigi ke la valoro kiu estas fakte Revenita ne nur int sed estas ankaŭ negativaj. 

Sur linio 12 Mi deklaras variablon nomis n kaj tial estas de tipo int. Kaj tiam en linio 13 tra 18 Mi fari ion dum io estas vera. Mi tuj antaŭen kaj presi n estas, dupunkto kaj tiam spaco, kiel prompto por la uzanto. 

Mi tiam nomante get_int kaj stokante lia tn reveno valoro en tiu variablo n. Sed mi iros por daŭre fari ĉi dum n estas pli granda ol 0. En aliaj vortoj, se la uzanto donas al mi int kaj tiu nombro estas pli granda ol 0, ergo, pozitiva, mi tuj simple observu reprompting la uzanto, teni reprompting, devigante ilin al kunlaboru kaj donu al mi negativan int. 

Kaj unufoje n estas reale negative-- supozas la uzanto fine tipoj -50, tiam tiu dum buklo ne plu vera ĉar -50 ne estas pli granda ol 0. Do ni rompi el tiu buklo logike kaj reveni n. 

Sed ekzistas unu alia kion mi devas fari. Kaj mi povas simple fari tion per kopii kaj alglui unu linio de kodo ĉe la supro de la dosiero. Mi devas instrui Clang, aŭ promesas Clang, eksplicite ke mi volas, ja, iru kaj apliki tiu funkcio get_negative_int. Ĝi nur povus esti pli malalta en la dosiero. Denove memoras ke Clang legas aferojn supre sube, maldekstre dekstren, do vi ne povas nomas funkcio se Clang ne scias ĝi tuj ekzistas. 

Nun, bedaŭrinde, tiu programo, kiel kelkaj el vi eble rimarkis, Jam kalesxon. Lasu min antaŭeniri kaj fari buggy3. Ĝi kompilas, do mia problemo nun ne estas sintaksa eraro, kiel teksta eraro, ĝi estas vere tuj esti logika eraro kiun mi havas intence faris kiel ŝanco paŝi tra kio okazas. 

Mi tuj iros antaŭen nun kaj kuri buggy3. Kaj mi tuj iros antaŭen kaj ne kunlabori. Mi tuj donos la numeron 1. Li ne ŝatis ĝin, do ĝi instigante min. 

Kiom proksimume 2? 3? 50? Neniu el tiuj laboras. Kiom proksimume -50? Kaj la programo ŝajnas funkcii. 

Lasu min provi ĝin refoje. Mi provu -1, ŝajnas funkcii. Mi provu -2, ŝajnas funkcii. Mi provu 0. Huh, jen malĝusta. Nun, ni estas iom pedanta tie. Sed estas ja la kazo ke 0 estas nek pozitiva nek negativa. Do la fakto ke mia programo estas dirante ke 0 estas negativa entjero, tio ne teknike korekta. 

Nun, kial faras tion? Nu, ĝi povus esti evidenta. Kaj, efektive, la programo estas intencita esti sufiĉe simplaj do ni havos ion esplori. 

Sed ni enkonduki trian depuración teknikon nomita debug50. Do tiu estas programo ke ni ĵus kreita tiu jaro nomita debug50 kiu permesos vin uzi kio nomiĝas korpigita grafika erarserĉilo en CS50 IDE. Kaj erarserĉilo estas simple programo kiu ĝenerale permesas kuri vian programon sed paŝon post paŝo post paŝo, linio por linio por linio, paŭzante, ŝovas ĉirkaŭe kaj rigardis variabloj por ke la programo ne nur blovi preter vi kaj rapide presi ion aŭ ne presi ion. Ĝi donas al vi la ŝancon, ĉe homaj rapido, interagi kun ĝi. 

Kaj por fari tion, vi simple fari la sekvan. Post kompilado vian kodon, kion mi jam faris, buggy3, Vi iru antaŭen kaj kuri debug50 ./buggy. Tiel kiel help50 havas vi kuros help50 kaj tiam la komando, debug50 havas vi kuras debug50 kaj tiam la nomo de la komando. 

Nun spekti kio okazas sur mia ekrano, sur la dekstra flanko aparte. Kiam mi batis Run, ĉiuj Subite tiu dekstra panelo malfermas sur la ekrano. Kaj ekzistas multe irante sur unuavide. Sed estas ne tro multajn zorgojn ankoraŭ. 

Tio montras min io ke okazas interne de mia programo nun kaj tra tiuj butonoj supren supro estas tiam permesi min paŝi tra mia kodo finfine paŝon post paŝo post paŝo. Sed ne ĝuste nun. Rimarki kio okazas. En mia fina fenestro Mi estanta instigita por n. Kaj mi tuj iros antaŭen kaj kunlaboru tiu tempo kaj tajpu -1. Kaj kvankam iom crípticamente, -1 estas negativa entjero, kiel atendita. 

Kaj tiam infano finiĝis kun statuso 0 GDBserver eliranta. GDB, GDB, estas la nomo de la subesta softvaro kiu implementa ĉi erarserĉilo. Sed ĉiuj ĉi vere signifas, la erarserĉilo foriris pro mia programo forlasis kaj ĉiuj estis bone. Se mi volas vere elpurigi mia programo, Mi devas preventa diri debug50, kie mi volas komenci tretante per mia kodo? 

Kaj eble la plej simpla formo fari tion estas kiel sekvas. Se mi ŝvebi super la defluilo de mia eldonisto tie, tiel vere nur en la ilobreto tie, maldekstren de la linio numeron, Rimarku ke se mi simple alklaku iam, mi metos iom ruĝa punkto. Kaj kiu iom ruĝa punkto, kiel halta signo, signifas, hej, debug50, paŭzo ekzekuto de mia kodo Dekstre kiam mi kuros ĉi programo. 

Do ni faru tion. Lasu min antaŭeniri kaj kuri mia programo denove kun debug50 ./buggy3, Enter. Kaj nun, avizo, io malsama okazis. Mi ne estanta instigita ankoraux en mia fina fenestro por nenio, ĉar mi ne alveninta ankoraux en mia programo. Rimarku ke la linio 8 kiu nun reliefigis, kaj tie estas iom sago ĉe maldekstra parolo vi paŭzis tie. Ĉi tiu linio de kodo, linio 8, ankoraŭ ne ekzekutitaj. 

Kaj kio estas kurioza, se mi rigardas super tie sur la dekstra flanko, rimarki ke i estas loka variablo, loka en la senco ke ĝi estas ene la nuna funkcio. Kaj lia valoro, ŝajne defaŭlte, kaj ia oportune, estas 0. Sed mi ne tajpi 0. Ke nur hazarde estas lia defaŭlta valoro nuntempe. 

Do lasu min antaŭeniri kaj fari tion nun. Lasu min antaŭeniri kaj sur la supro tie, mi tuj iros antaŭen kaj klaku ĉi unua ikono kiu signifas paŝon super kiu signifas ne skip ĝi sed transpaŝas tiun linion de kodo, ekzekuti ĝin survoje. 

Kaj nun, rimarki, mia prompto ĵus ŝanĝis. Kial estas tio? Mi rakontis al debug50, kuri ĉi tiu linio de kodo. Kion ĉi tiu linio de kodo fari? Instigas min por int. BONE. Lasu min kunlabori. Lasu min nun kaj tajpu -1, Enter. Kaj nun rimarkas kion ŝanĝis. Sur la dekstra flanko, mia loka variablo i estas indikita kiel estante -1 nun. Kaj ĝi estas ankoraŭ de tipo int. 

Kaj avizo ankaŭ mia tn nomas pilo kien mi paŭzi? Ni parolos pli pri tio en la estonteco. Sed la alvoko pilo nur rilatas al kio funkcioj estas nuntempe en moviĝo. Nun ĝi estas nur ĉefaj. Kaj nun la sola loka variablo estas i kun valoro de 1. 

Kaj kiam mi finfine transpaŝas tiun linion tie, kun tiu sama ikono ĉe supra dekstra, -1 Estas negativa entjero. Nun ĝi paŭzante dum tiu krispa krampoj. Ni lasu lin fari lian aferon. Mi transpaŝas tiun linion, kaj voila. 

Do ne cxio, kion terure iluminanta tamen, sed lasu min paŭzo kaj pensi tra logike kion tiu programo faras. Sed tio ne estis la erara kazo. Ni faru ĉi denove jene. 

Mi tuj lasos ke Haltpunkto sur la linio 8 de la ruĝa punkto. Mi tuj rerun debug50. Ĝi estas aŭtomate paŭzis tie. Sed ĉifoje, anstataŭ tretante sur tiu linio, mi vere iras ene de get_negative_int kaj diveni, kial akcepti 0 kiel validan respondon? 

Do anstataŭ klakanta Paŝo Super. Mi tuj iros antaŭen kaj klaku Step Into. Kaj rimarki ke la linio 8 jen nun emfazita nun subite iĝas linio 17. 

Nun, ĝi ne estas ke la erarserĉilo jam saltis linioj 14 kaj 15 kaj 16. Ĝi simple estas nenio montri vin tie. Tiuj estas nur deklarante variabloj, kaj tiam tie estas la vorto u kaj tiam malfermita krispa streĉa. La nura funkcia linio kiu estas sukaj vere estas ĉi tie, 17. Kaj tio estas kie ni havas paŭzis aŭtomate. 

Do printf ( "n.is:") ;, tiel ke ne okazis ankoraŭ. Do ni iru antaŭen kaj klaku Paŝo Super. Nun mia prompto ja ŝanĝis al ( 'n estas: "). Nun get_int, mi ne tuj tedi tretante en, ĉar tiu funkcio estis faritaj de CS50 en la Biblioteko. Ĝi estas supozeble ĝusta. 

Do mi tuj iros antaŭen kaj ia kunlabori donante lin int, sed ne negativa int. Do lasu min antaŭeniri kaj batis 0. Kaj nun kio okazas ĉi tie kiam mi akiras malsupren al linio 21? Mi ne ripetis denove. Ne ŝajnas esti ŝtopita en tiu ciklo. Alivorte, tiu flava trinkejo ne plu iri ĉirkaŭe, kaj ĉirkaŭe, kaj ĉirkaŭe. 

Nun, kial do? Nu, n, kio estas n nun? Mi povas rigardi la loka variablojn en la erarserĉilo. n estas 0. Bone, kio estis mia kondiĉo? 

20-- linio 20 estas, nu, 0 estas pli granda ol 0. Tio ne veras. 0 ne estas pli granda ol 0. Do mi ekis de tiu. 

Kaj tial estas kial la linio 21, se mi efektive daŭrigi, Mi tuj revenos 0, eĉ kvankam mi malsxatas 0 kiel ne reale esti negativa. Do nun, mi ne vere eĉ zorgi pri la erarserĉilo. Got ĝin, mi ne bezonas scias kion pli daŭriĝas. 

Do mi tuj iros antaŭen kaj simple alklaku la Play butonon, Kaj gxi finas tion. Nun, mi rimarkis ke mia cimo estas ŝajne sur linio 20. Jen mia logika eraro. 

Do kion mi volas fari ŝanĝi tion? Se la problemo estas ke mi ne kaptante 0, estas nur logika eraro. Kaj mi povas diri dum n estas pli granda ol aŭ egala al 0, teni instigante la uzanto denove kaj denove. 

Do, denove, simpla eraro, eble eĉ evidenta, kiam vi vidis min skribi ĝin nur kelkaj minutoj. Sed la takeaway tie estas ke kun debug 50, kaj kun debugging programaro pli ĝenerale, vi havas tiun novan trovita povon trairu vian propran kodon, rigardu tra kiuj dekstren panelo kio via variabloj valoroj. Do vi ne nepre devas uzi ion kiel vi eprintf presi tiujn valorojn. Vi povas fakte vidi ilin vide sur la ekrano. 

Nun, ekster tiu, ĝi valoras notanta ke estas alia tekniko kiu estas fakte super komuna. Kaj vi eble miras kial tiu malgranda ulon tie estis sidantaj sur la scenejo. Do ekzistas tiu tekniko, ĝenerale konata kiel kaŭĉuko anaso depuración, kiu vere estas nur testamento al la fakto ke ofte kiam programistoj skribas kodo, ili ne estas nepre kunlabori kun aliaj, aŭ labori en komuna medio. 

Ili estas speco de hejme. Eble estas malfrua nokto. Ili provas figuro el iuj cimoj en ilia kodo. Kaj ili estas simple ne vidas. 

Kaj ekzistas neniu kompano. Ne ekzistas TF. Ne ekzistas CA ĉirkaŭe. Ĉiuj ili havas sur sia breto Estas ĉi tiu malgranda kaŭĉuko Ducky. 

Kaj tiel kaŭĉuko anaso depuración Estas ĝuste tiu invito pensi pri io tiel malsaĝa kiel tion kiel reala estaĵo, kaj efektive iradas tra via kodo parole al tiu senviva objekto. Do, ekzemple, se tio estas mia ekzemplo here-- kaj memoras ke frue la problemo estis tiu, se mi forigas tiun unuan linion de kodo, kaj mi iras antaŭen kaj fari kalesxo 0 denove, memoras ke mi havis tiujn erarmesaĝojn tie. Do la ideo tie, ridindaj se mi sentas en la momento fari ĉi publike, estas tiu eraro. 

Bone, do mia problemo estas ke mi havas implicite deklaris biblioteko funkcio. Kaj ke biblioteko funkcio printf. Declare-- OK, deklari memorigas min de prototipoj. 

Tio signifas mi devas reale diru la tradukilo anticipe kion la funkcio aspektas. Atendu minuton. Mi ne havis normon io.h. Dankegon. 

Do ĝuste ĉi procezo of-- vin ne bezonas efektive havas anaso. Sed tiu ideo de marŝi mem, per viaj propraj kodo por ke vi eĉ aŭdas mem, por ke vi realigi preterlasoj en via propra rimarkoj, estas ĝenerale la ideo. 

Kaj, eble pli logike, ne tiel multe kun tiu sed la pli implikitaj ekzemple ni ĵus faris en kalesxo 3.c, vi iradu mem tra ĝi jene. Do bone, kaŭĉuko Ducky, DDB, se vi volas. Tie ni havas en mia ĉefa funkcio, Mi vokas akiri negativan int. 

Kaj mi estas akiranta la reveno valoro. Mi stokante ĝin en la maldekstra flanko sur linio 8 en variablo vokis mi. Okej, sed atendu, kiel faris ke atingi tiun valoron? Lasu min rigardi la funkcio en linio 12. 

En linio 12, ni havas atingi negativan int. Ne prenas ajnan enigoj, ne revenos int, OK. Mi deklaras sur linio 14 variablon n. Ĝi tuj stoki entjero. Tion mi volas. 

Do faru la sekvajn dum n is-- lasu mi malfari kion la solvon mi jam faris. Do dum n estas pli granda ol 0, presi n estas, OK. Kaj tiam voki akiri int stokitaj en n. Kaj tiam kontrolu se n estas 0, n estas not-- tie ĝi estas. Do, denove, vi ne bezonas la reala anaso. Sed nur irante mem per vian kodo kiel intelekta ekzerco ofte helpas vin rimarkas kio okazas, kontraste al simple fari ion tiel, rigardante la ekrano, kaj ne parolas mem per ĝin, kiu honeste ne preskaŭ tiel efika tekniko. Tiel tie vi havas ĝin, kiel nombro de malsamaj teknikoj cxar vere elpurigi vian kodon kaj riprocxante, ĉiuj el kiuj devus esti iloj en via ilaro por ke vi ne malfrunokte, speciale, vi estas en la manĝoĉambro salonoj, aŭ ĉe oficejo horoj, batante vian kapon kontraŭ la muro, klopodante solvi iun problemon. Rimarkas ke estas programaro iloj. Ekzistas kaŭĉuko anaso iloj. Kaj ekzistas tuta personaro de apogas atendanta helpi. 

Tial nun, vorto pri la problemo aroj, kaj sur kio ni estas esperantaj vi forlasi ilin, kaj kiel ni iros sur taksi. Po la kurso Syllabus, CS50 problemo aroj estas taksitaj sur kvar primaraj aksoj, tiel al speak-- amplekso, korekteco, dezajno, kaj stilo. Kaj amplekso nur rilatas al kiom de la peco vi mordis ekstere? Kiom multe de problemo vi provis? Kion nivelo de penado ĉu vi aperos? 

Praveco estas, ĉu la programo laboro kiel ĝi estas supozeble por CS50 specifo kiam vi provizis certa enigoj aŭ certaj eligoj revenis? Dezajno estas la plej subjektiva ili. Kaj ĝi estas la unu kiu volas preni la plej longan lerni kaj la plej longa instrui, en kiom ĝi bolas malsupren al, kiel bone skribita estas via kodo? 

Ĝi estas unu afero al simple presi la korekta eliroj aŭ reveni dekstren valoroj. Sed vi faras lin kiel kompetente kiel ebla? Vi faras lin dividi kaj konkeri, aŭ duuma serĉo kiel ni baldaŭ vidos, ke ni faris du semajnoj kun la telefono libro? Ĉu estas pli bone manieroj solvi la problemo ol vi nun havas tie? Ke estas ŝanco por pli bona dezajno. 

Kaj tiam style-- kiom bela estas via kodo? Vi rimarkos ke mi estas sufiĉe aparta pri deŝovante mia kodo, kaj certigante mian variabloj estas prudente nomita. n, dum mallonga, estas bona nomo por nombro, i por kalkula entjero, s por ŝnuro. Kaj ni povas havi plu variablo nomoj stilo. Stilo estas nur kiel bona faras vian kodo aspektas? Kaj kiel legebla estas? 

Kaj dum tempo, kion via TAS kaj TFS faros en la kurso estas provizi vin kun tio ia kvalita sugestoj tiel ke vi ricevas bone ĉe tiuj diversaj aspektoj. Kaj en terminoj de kiel ni taksi ĉiu de ĉi tiuj aksoj, ĝi estas tipe kun tre malmultaj siteloj por ke vi, ĝenerale, akiri senton de kiom bone vi faras. Kaj cetere, se vi ricevas poentaron sur neniu el tiuj axes-- korektecon dezajno kaj stilo especially-- tiu numero ĝenerale estas inter 1 kaj 5. Kaj, laŭlitere, se vi fariĝas 3-a ĉe la komenco de la semestro, tio estas tre bona afero. Ĝi signifas ke estas ankoraŭ spaco por plibonigo, kion vi esperas en prenante klasoj unuafoje. Estas espereble iuj iom de plafono al kiuj vi aspiras atingi. Kaj tiel atingi 3 de sur la unuaj pecoj, se ne iuj 2-a kaj 4-a, estas ja bona afero. Ĝi estas bone ene gamo, bone ene atendojn. 

Kaj se via menso estas kuradanta, atendu minuto, tri el kvin. Ke estas vere 6 el 10. Tio 60%. Mia Dio, jen F. 

Ĝi ne estas. Ĝi ne estas, fakte, ke. Prefere, ĝi estas ŝanco por plibonigi super la kurso de la semestro. Kaj se vi fariĝas iom Poors, tiuj estas ŝanco utiligi oficejo horoj, certe sekcioj kaj aliaj rimedoj. 

Bona estas ŝanco, vere, esti fiera de kiom multe vi havas transiris la kurson de la semestro. Do realigi, se nenio alie, tri estas bona. Kaj ĝi permesas spacon por kresko super tempo. 

Kiel al kiel tiuj aksoj estas pezita, realisme vi tuj pasas plej parton de via tempo ricevas aferojn al laboro, des malpli korekte. Kaj tiel ĝustecon inklinas esti pezita la plej, kiel kun ĉi multiplika faktoro de tri. Dezajno estas ankaŭ grava, sed iu kiu vi ne nepre elspezi ĉiujn de tiuj horoj provas akiri aferojn ĝuste funkcii. 

Kaj tiel ĝi estas pezbalancita iom pli malpeze. Kaj tiam stilo pezis la malgranda. Kvankam ĝi estas ne malpli grava fundamente, ĝi estas nur, eble, la facila afero por fari ĝuste, imitante la ekzemploj faros en prelego kaj sekcio, kun aĵoj bele dentado, kaj komentis, kaj tiel plu estas inter la plej facilaj farendaĵojn kaj akiri rajton. Tiel kiel tia, realigi ke tiuj estas punktoj ke estas relative facile kompreni. 

Kaj nun unu vorton sur this-- akademia honesteco. Tiel por la kurso Syllabus, vi vidos ke la kurso havas sufiĉe iom de lingvo ĉirkaŭ ĉi. Kaj la kurso prenas la temon de akademia honesteco tute serioze. 

Ni havas la distingon, por bone aŭ por malbone, de sendinte ĉiujare pli studentojn por disciplina ago ol plej ajna alia Kompreneble, ke mi estas konscia de. Tio ne nepre indika de la fakto ke CS studentoj, aŭ CS50 studentoj, estas ajna malpli honesta ol via samklasanoj. Sed la realaĵo kiu en tiu mondo, elektronike, ni nur havi teknologia signifas de detekti ĉi. 

Ĝi estas grava por ni por justeco tra la klaso ke ni detektas ĉi kaj restarigu la demando kiam oni vidas aferojn. Kaj simple pentri bildon, kaj vere helpi io tiamaniere profundiĝi en, Jen estas la nombro de studentoj dum la pasintaj 10 jaroj kiuj estis implikitaj en kelkaj tiajn aferojn de akademia honesteco, kun iuj 32 studentoj de aŭtuno 2015, kiu estas ke ni prenos la afero tre serioze. Kaj, fine, tiuj nombroj formi, plej ĵuse, proksimume 3%, 4% aŭ tiel de la klaso. 

Tiel por la super plimulto de studentoj ĝi similas ke la linioj estas klara. Sed daŭru en gravas, aparte malfrue nokte kiam luktas kun iu solvo al problemo aro, ke estas mekanismoj por akiranta vin pli subteno ol vi eble pensas, eĉ en tiu horo. Rimarkas ke kiam ni ricevas studento submetadoj, ni transiras kompari ĉiun submetiĝo tiu jaro kontraŭ ĉiu submetiĝo pasintjare, kontraŭ ĉiu submetiĝo de 2007, kaj tiam, rigardante, kiel bone, kodo deponejoj rete, diskuto forumoj, laboron lokoj. Kaj ni mencias ĉi, vere, ĉiuj pro de plena rivelo, ke se iu alia povas trovi ĝin en linio, Certe, tiel povas ni la kurson. Sed, vere, la spirito de la kurso abscesoj malsupren al tiu klaŭzo en la Syllabus. Vere estas justa, racia. 

Kaj se ni devis ellabori sur tiu kun nur iom pli lingvon, rimarkas ke la esenco de ĉiuj laboro kiu vin submetiĝi al tiu kurso devas esti via propra. Sed ene de tiu, estas certe ŝancojn kaj konsilon kaj pedagogia valoro en turnante al others-- mem, la TFS, la CAS, la TAS, kaj aliaj en la klaso, por subteno, des malpli amikojn kaj ĉambrokunuloj kiuj studis CS kaj programado antaŭe. Kaj do estas gratifiko por tiu. Kaj la ĝenerala regulo de dikfingro Estas this-- kiam petanta helpon, vi povas montri vian kodon por aliaj, sed vi povas ne vidi ilian. Do eĉ se vi estas en oficejo horoj, aŭ en la D halo, aŭ alie laborante sur iu peco aro, laborante apud amiko, kiu Estas tute bone, ĉe la Fine de la tago via laboro devus finfine apartenas unu vi respektive, kaj ne esti iu collaborative peno, krom la fina projekto kie ĝi estas permesita kaj kuraĝigis. 

Rimarkas ke se vi estas luktante kun io kaj via amiko ĵus okazas esti pli bona ĉe tiu tiam vi, aŭ pli bone en tiu problemo ol vi, aŭ iom pli for antaŭen ol vi, ĝi estas tute racia turni al via amiko kaj diri, hej, Ĉu ĝenas vin rigardi mian kodo tie, helpanta min ekvidi kio mia problemo estas? Kaj, espereble, en la intereso de pedagogia valoro ke amiko ne nur diru, ho, tion fari, sed prefere, kion vi mankas sur linio 6, aŭ io simila? Sed la solvo ne cxar la amiko apud vi diri, ho, nu, tie, lasu min eltiri ĉi kaj rakontos mian solvon por vi. Tiel ke estas la linio. Vi montros vian kodon por aliaj, sed vi ne vidi apartenos temo al la alia limigoj en la kurso Syllabus. 

Do memoru tio tn bedaŭro klaŭzo en la paso de syllabus tiel, ke se vi faras iun akton kiu ne racia, sed alportu al la atenton de la kurso la kapojn ene 72 horoj, la kurso eble trudi loka sankcioj kiuj povas inkludi nekontentiga aŭ malsukcesanta grado por la laboro farita. Sed la kurso ne rilatas la gravas por plua disciplina ago, krom en kazoj de ripetaj agoj. Alivorte, se vi ja faras iun stulta, precipe malfrue nokte, decido ke sekvamatene aŭ du tagoj poste, vi vekiĝos kaj rimarkos, kio mi pensas? Vi faras en CS50 havas ellasejon por fiksi tiun problemon kaj posedi supren al ĝi, tiel ke ni renkontos vin duonvoje kaj trakti per ĝi en demando kiu estas ambaŭ instrua kaj valora por vi, sed ankoraŭ punaj iel. Kaj nun, por preni la rando ekstere, tiu. 

[VIDEO reprodukto] 

[MUZIKO Ludanta] 

[FINO reprodukto] DAVID J. Malan: Bone, ni estas dorso. Nun ni rigardas unu el la unua de nia reala mondo domajnoj en CS50, la arto de ĉifriko, la arto de sendo kaj ricevanta sekretajn mesaĝojn, ĉifrita mesaĝojn se vi volas, kiu povas nur esti deĉifrita se vi havas iuj ŝlosilaj ingredienco ke la sendinto havas ankaŭ. Tiel motivi ĉi ni prenos oni rigardas tiun aferon ĉi tie, kiu estas ekzemplo de sekreta deĉifrilo ringo kiu povas esti uzata por eltrovi kion sekreta mesaĝo vere estas. Fakte, reen en la tago en grado lernejo, se vi iam sendis sekretajn mesaĝojn al iu amiko aŭ iu enamiĝo en klaso, vi eble pensis vi estas saĝa por sur via paperpeco sxangxado, kiel, A al B kaj B al C, kaj C al D, kaj tiel plu. Sed vi vere kodi via informo, eĉ se ĝi estis iom triviala, ne tiel malfacila por la instruisto por realigi, bone, se vi nur ŝanĝi B al A kaj C al B, vi fakte elkompreni kion la mesaĝo estis, sed vi estis en ciphering informo. 

Vi nur faranta ĝin simple, multe kiel Ralphie tie en fama filmo kiu ludas preskaux ad nauseum ĉiu vintro. [VIDEO reprodukto] -Be Sciate al tio Ralph Parker maniere enoficigita membro de la Malgranda Orfa Annie Sekreta Rondo kaj povas postuli la tutan la honoroj kaj profitoj okazanta tio. 

-Signed, Little Orphan Annie, counter-subskribita Pierre Andre, en inko. Honorojn kaj profitojn, Jam en la aĝo de naŭ. 

[Kriante] -Come Plu. Ni iru sur ĝi. Mi ne bezonas ĉion, kion ĵazo pri kontrabandistoj kaj piratoj. 

-Listen Morgaŭ nokte por la konkluda aventuro de la nigra ŝipo pirato. Nun, estas tempo por Annie la sekreta mesaĝo cxar vi membroj de la Sekreta Rondo. Memoru, infanoj, nur membroj de Annie La Sekreta Rondo povas malkodi Annie la sekreta mesaĝo. 

Memoru, Annie estas dependanta sur vi. Ŝanĝu vian pingloj al B2. Jen la mesaĝo. 12, 11-- 

-mi Estas en mia unua sekreta kunveno. 

-14, 11, 18, 16. 

-Pierre Estis en granda vocxo ĉinokte. Mi povus diri ke ĉinokte la mesaĝo estis vere grava. 

-3, 25, tio estas mesaĝo de Annie sin. Memoru, ne diru al iu ajn. 

-90 Sekundoj poste, mi estas en la sola ĉambro en la domo kie knabo de naŭ povis sidi en privateco kaj malkodi. Aha, B! Mi iris al la sekva, E. 

La unua vorto estas esti. S, ĝi venas pli facile nun, U, 25-- 

-Ho, Venu, Ralphie, mi devas iri! 

-I'll Pravi malsupren, Ma! Gee Whiz! 

-T Ho, nepre to-- nepre kio? Kio estis Little Orphan Annie provas diri? Nepre kio? 

-Ralphie, Andy atingis iras, vi bonvolu eliros? 

-All Dekstra, Ma! Mi tuj ekstere! 

-mi Estis proksimiĝas nun. La streĉiĝo estis terura. Kio estis tio? La sorto de la planedo eble pendas en la ekvilibro. 

-Ralphie! Andy gotta go! 

-I'll Pravi eksteren, por laŭte ploris! 

-Almost Tie, miaj fingroj flugis, mia menso estis ŝtalo kaptilo, ĉiu poro vibris. Estis preskaŭ klara, jes, jes, jes. 

-Be Nepre trinku vian ovaltine. Ovaltine? A malbona morto komerca? Filo de putino. [FINO reprodukto] DAVID J. Malan: Bone, do kiu estis tre longa vojo enkonduki ĉifriko, kaj ankaŭ ovaltine. Fakte, de tiu malnova anonco tie, kial estas ovaltine tiel bona? Estas koncentrita eltiro de matura hordeo malton, pura cremoso bovino lakto, kaj speciale preparita kakao, kune kun natura phosphatides kaj vitaminoj. Ĝi estas plue fortikigitaj per aldonaj vitaminoj B kaj D, yum. Kaj vi ankoraŭ povas akiri ĝin, ŝajne, sur Amazono, kiel ni faris ĉi tie. 

Sed la motivación tie estis enkonduki ĉifriko, specife tipo de ĉifriko konata kiel sekreta ŝlosila ĉifriko. Kaj kiel la nomo sugestas, la tuta sekureco de sekreta ŝlosilo kripto sistemo, se vi volas, metodiko por nur grimpadi informo inter du personoj, estas ke nur la sendanto kaj nur la ricevonto konas sekretan key-- iu valoro, iuj sekreta frazo, iu sekreta numero, tio permesas ambaŭ ĉifri kaj deĉifri informon. Kaj ĉifriko, vere, Estas ĝuste tiu de semajno 0. 

Estas problemo kie ekzistas enigoj, kiel la reala mesaĝo en la angla aŭ kion ajn lingvo kiun vi deziras sendi al iu en klaso, aŭ tra la interreto. Ekzistas iuj eligo, kiu tuj esti la kirlitaj mesaĝon ke vi volas la ricevanto ricevi. Kaj eĉ se iu en la meza ricevas ĝin, vi ne volas ilin nepre povos malĉifri ĝin, ĉar ene de tiu nigra skatolo, aŭ algoritmo, estas iu mekanismo, iuj paŝo post paŝo instrukcioj, por porti tiun enigo kaj konvertante ĝin en la eligo, en espereble sekuran vojon. 

Kaj, fakte, ekzistas iuj vortprovizo en tiu mondo kiel sekvas. Plata teksto estas la vorto de komputila sciencisto farus uzas por priskribi la enigo mesaĝo, same kiel la angla aŭ kion ajn lingvo vi reale deziras sendi al iu alia homo. Kaj tiam la ĉifrita teksto estas la scramble al la enĉifrita, aŭ ĉifrita, versio de gxi. 

Sed ekzistas unu alia ingredienco tie. Ekzistas unu alia enigo al sekreta ŝlosila ĉifriko. Kaj kiu estas la ŝlosilo mem, kiu estas, ĝenerale, kiel ni vidos, numero, aŭ letero, aŭ vorto, kio ajn la algoritmo estas vere atendas. 

Kaj kiel vi deĉifri informon? Kiel vi unscramble ĝi? Nu, vi nur inversigi la eliroj kaj la enigoj. 

Alivorte, iam iu ricevas via ĉifrita mesaĝo, li aŭ ŝi simple havas scii ke sama ŝlosilo. Ili ricevis la ĉifrita teksto. Kaj per ŝtopanta tiuj du enigoj en la kripto sistemo, la algoritmo, ĉi nigra skatolo, ekstere venu la originala teksto. Kaj do tio estas la tre alta nivelo Konsiderante kio ĉifriko estas reale ĉiuj proksimume. 

Do ni ricevas tie. Ni nun rigardu sube la kapuĉo de io ni estis prenante por donita por la pasinta semajno, kaj por tiu sesio here-- la kordo. Kordo fine de la tago estas nur vico de signoj. 

Gxi estu saluton mondo, aŭ saluton Zamyla, aŭ kion ajn. Sed kion tio signifas por esti sekvenco de karakteroj? Fakte, la CS50 biblioteko donas ni datumtipo nomata ŝnuro. 

Sed estas vere neniu tia afero kiel linio en C. Ĝi vere estas nur vico de karaktero, trajto, karaktero, karaktero, dorso, apogi, por dorso, apogi, subteni ene de via komputilo la memoro, aŭ RAM. Kaj ni rigardu pli profunden en kiuj en la estonteco kiam ni rigardas memoro mem, kaj la utiligo kaj la minacoj kiuj estas implikitaj. 

Sed ni konsideru la kordo Zamyla. Tiel nur la nomo de la homa tie, Zamyla, ke estas vico de karakteroj, Z-Al-M-Kaj-L-A. Nun ni supozu ke Zamyla nomon estas stokitaj ene de komputilo programo. 

Nu, ĝi staras rezoni, ke ni devus povos rigardi tiujn signojn individue. Do mi simple tuj tiri iom skatolo ĉirkaŭ Zamyla nomon tie. Kaj tio estas la kazo en C ke kiam vi havas ĉenon, kiel Zamyla-- kaj eble ke kordo revenis el funkcio kiel get kordoj, vi povas reale manipuli ĝi karaktero por karaktero. 

Nu, temas germane por la konversacio ĉe mano, ĉar en ĉifriko se vi volas ŝanĝi A al B, kaj B al C, kaj C al D, kaj tiel plu, vi bezonas por povi rigardi la individuajn karakterojn en ĉeno. Vi bezonas por povi ŝanĝi Z por io alia, la A al io alia, la M al io alia, kaj tiel plu. Kaj do ni bezonas manieron, programmatically, do paroli, en C por povi ŝanĝi kaj rigardi individuajn literojn. Kaj ni povas fari tion kiel sekvas. 

Mi iros gvidi reen en CS50 IDE. Kaj lasu min antaŭeniri kaj krei novan dosieron Mi vokos tiu tempo string0, kiel nia unua tia ekzemplo, dot c. Kaj mi tuj iros antaŭen kaj vipi ĝin jene. 

Tiel inkluzivi CS50.h kaj tiam inkludas normon io.h, kiun mi preskaŭ ĉiam tuj esti uzante en mia programoj, almenaŭ komence. int ĉefa malplenon, kaj tiam en ĉi tie mi estas faros kordoj ricevas atingi ŝnuron. Kaj tiam mi tuj antaŭeniri kaj fari tion. Mi volas iri antaŭen kaj, kiel prudento ĉeko, nur diri, saluton, procento s, duon-dupunkto, faras ĉenon 0. Uh oh, kion mi faras ĉi tie? Ho, mi ne ŝtopi ĝin en. Tiel leciono lernis, ke ne intenca. 

Do eraro, pli procento konvertiĝoj ol datumoj argumentoj. Kaj tio estas kie, linio 7-- Bone, do mi havas, citaĵo unquote, jen mian ŝnuron al printf. Mi havas procentsigno. Sed mi mankas la dua argumento. 

Mi mankas la komo s, kiu Mi havas en antaŭaj ekzemploj. Do bonan ŝancon ripari pli eraro, hazarde. Kaj nun mi kuros string0, tipo en Zamyla. OK, saluton Zamyla. 

Do ni ne plu havas tian programon kelkaj malsamaj tempoj nun. Sed ni faru ion iom malsama ĉi tiu tempo. Anstataŭ ĝuste presi Zamyla la plena nomo kun printf, ni faru ĝin karaktero por karaktero. 

Mi tuj uzi por buklo. Kaj mi tuj doni min oni kalkula variablo, nomita I. Kaj mi tuj teni ripetanta, do longe kiel i estas malpli ol la longo de s. 

Rezultas, ni ne fari tiun lastan fojon, ke c venas kun funkcio nomita Stirling. Reen en la tago, kaj ĝenerale ankoraŭ kiam efektiviganta funkcioj, homoj ofte elektas tre konciza nomoj tian sonon kiel kion vi volas, eĉ se ĝi estas mankas kelkaj vokaloj aŭ literoj. Tiel Stirling estas la nomo de funkcio kiu prenas argumenton inter krampoj kiuj devus esti ŝnuro. Kaj ĝi nur revenas entjero, la longo de tiu linio. 

Do ĉi por buklo sur linio 7 tuj por komenci kalkulon je i egalas 0. Ĝi tuj pliigo i sur ĉiu ripeto de 1, kiel ni estis farante kelkajn fojojn. Sed ĝi tuj nur fari tio supren ĝis la punkto Kiam i estas la longo de la kordo mem. 

Do tiu estas maniero, finfine, ripetanta super la karakteroj en la kordo kiel estas sekvas. Mi tuj presi ne tuta ĉeno, sed procento c, sola karaktero sekvata de nova linio. Kaj tiam mi tuj antaŭeniri, kaj mi bezonas diri mi volas presi Ith karaktero de s. 

Do se mi estas la variablo kiu indikas la indekso de la kordo, kie vi en ĝi, mi bezonas por povi diri, donu al mi la Ith karaktero de s. Kaj c havas maniero fari tiu kun kvadrataj krampoj. Vi simple diru la nomon de la kordo, kiu en ĉi tiu kazo estas s. Tiam vi uzas kvadrataj krampoj, kio estas kutime ĵus super via Reveno aŭ Enter ŝlosilo sur la klavaro. Kaj tiam vi metu la indekso de la karaktero kiun vi volas presi. Tiel la indekso tuj esti number-- 0 aŭ 1, aŭ 2, aŭ 3, aŭ streketo streketo pentras, iu alia nombro. 

Kaj ni certigos ke ĝi tuj esti la ĝusta nombro, ĉar mi komenci kalkulon je 0. Kaj implicite, la unua karaktero en cxeno estas per konvencio 0. Kaj la dua karaktero estas krampo 1. Kaj la tria karaktero estas krampo 2. Kaj vi ne volas iri tro nun, sed ni ne cxar ni estas tuj nur pliigo i ĝis egalas la longon de la kordo. Kaj ĉe kiu punkto, ĉi por buklo ĉesos. 

Do lasu min antaŭeniri kaj savi ĉi programo kaj kuri fari ĉenon 0. Sed mi ŝraŭbita supren. Implice deklari biblioteko funkcio Stirling kun tipo tia kaj such-- nun, tio sonas familiara. Sed ĝi ne estas printf. Kaj ĝi ne ricevas ŝnuro. 

Mi ne ŝraŭbi supre en same tiu tempo. Sed rimarki cxi tie iom malsupren plue, inkluzivas la kaplinio string.h, eksplicite provizas la deklaro por Stirling. Do estas fakte aŭtoveturejon en tie. 

Kaj ja rezultas ekzistas alia kaplinio dosiero ke ni ne uzas en klaso ankoraŭ, sed ĝi estas inter tiuj disponeblaj al vi, nomata string.h. Kaj en tiu dosiero, string.h Estas Stirling deklaris. Do lasu min antaŭeniri kaj krom tio, fari ĉenon 0-- bela, neniu erarmesaĝojn tiu tempo. 

./string0 Zamyla, kaj Mi volis batis Enter, ĉe kiu punkto getstring tuj redoni la kordo, metis ĝin en s. Tiam tiu por buklo tuj persisti super S gravuloj unuope, kaj presi ilin unu po linio, ĉar Mi havis tiun backslash n je la fino. Do mi povis preterlasi ke backslash n, kaj tiam simple presi Zamyla ĉiuj en la sama linio, efike reimplementing printf, kio ne ĉiuj tiom utila. Sed en ĉi tiu kazo, mi ne faris tion. Mi fakte presitaj unu karakteron je fojo, unu po linio, por ke ni reale vidi la efikon. 

Sed mi devus noti unu aferon ĉi tie. Kaj ni revenos al tiu en estonta semajno. Ĝi rezultas ke ĉi poŝtkodo estas potenciale kalesxo. 

Ĝi rezultas ke get kordoj kaj iuj aliaj funkcioj de la vivo ne nepre ĉiam reveni kion vi atendas. Ni scias el klaso lasta tempo en ĉi tiu akiras ŝnuro supozas reveni kordo. Sed kion se la uzanto tajpas el tia longa vorto, aŭ paragrafo, aŭ eseo ke estas simple ne sufiĉas memoro en la komputilo por ĝustigi ĝin. 

Kiel, se iu eliras malĝusta sub la kapuĉo? Povus okazi ofte, sed povus okazi iam en momento, tre malofte. Kaj tial ĝi rezultas ke get kordoj kaj funkciojn kiel ĝi faras ne nepre ĉiam reveni kordoj. Ili povus reveni iun eraran valoro, iu gardostaranto valoro tiel diri, kiu indikas ke io iris malĝuste. Kaj vi nur scias tion el sciigxinte ĝin en klaso nun aŭ leginte iom pli dokumentado. Ĝi rezultas ke get kordoj povas redoni valoro nomita nula. Null estas speciala valoro kiu ni revenu al la estonta semajno. Sed nuntempe, nur scias, ke se mi volas esti vere konvena en movanta antaŭen uzante get kordoj, mi ne simple nomas ĝin, kaj blinde uzi lian revenon valoro, konfidante ke ĝi estas ĉeno. 

Mi unue diru, hej, atendu minuton, nur procedi se s ne egala nula, kie nula, denove, estas nur iuj specialaj valoro. Kaj ĝi estas la nura speciala valoro vi bezonas zorgi pri por akiri string. Akiri string estas aŭ irante reveni ŝnuro aŭ nula. 

Kaj ĉi ekkrion punkto egalas signo vi eble scias el eble math klaso ke vi povus desegni egalan signon per linion tra ĝi por indiki ne egalaj. Tio ne ĝenerale gravulo vi povas tajpi sur via klavaro. Kaj tial en plej programlingvoj, kiam vi volas diri ne egala, vi uzas ekkrion punkto, alie konata kiel bang. Do vi diras bang egalas, kio signifas ne egalas, logike. Estas nur kiel ekzistas neniu pli granda ol, aŭ egalaj al, aŭ malpli ol aŭ egala tajpi sur via klavaro kiu faras ĉion en unu simbolo. Tial do, en pasinteco ekzemploj, vi faris malferma krampo, kaj poste egala signo, por fari pli granda ol aŭ, diru, malpli ol. 

Do kio estas la takeaway tie? Tio estas simple vojo nun de enkondukante tiu sintakso, ĉi trajto, ripetanta super individua karakteroj en cxeno. Kaj ĝuste kiel tiuj kvadrata krampoj permesas vin akiri ilin, konsideri tiujn kvadrataj krampoj kiel ia sugestante tiun subkuŝanta dezajno, per kiu ĉiu karaktero ene de kordoj estas speco de skatolo en ie sub la kapuĉo en via komputilo la memoro. 

Sed ni faros varianto de tio. Ĝi rezultas ke ĉi programo estas korekta. Tiel por CS50 la aksoj por taksi kodo, tio estas ĝusta nun. Precipe nun ke mi kontrolas por nula, tiu programo devus neniam frakasi. Kaj mi nur scias ke de sperto. Sed estas nenio alia ke ni povas vere iri malbone tie. Sed ĝi ne estas tre bone desegnita, ĉar ni revenu al basics. 

Unue principles-- kion por buklo faras? A por buklo faras tri aferojn. Ĝi inicializa iuj valoro, se vi demandas lin al. Ĝi kontrolas kondiĉo. Kaj tiam post ĉiu ripeto, post ĉiu ciklo, ĝi pliigas iom valoro, aŭ valoroj, tie. 

Do kion tio signifas? Ni pravalorizi i al 0. Ni kontrolu kaj certigi i estas malpli ol la longo de s, kiu estas Z-Al-M-Kaj-L-A, tiel ke estas malpli ol 6. Kaj ja, 0 kiel malpli ol 6. 

Ni presi Z de Zamyla nomo. Tiam ni pliigo i de 0 al 1. Ni tiam kontrolu, estas 1 malpli ol la longo de s? La longo de s estas 6. Jes estas. 

Tiel ni presi en Zamyla nomo, ZA. Ni pliigo i de 0 al 1, al 2. Ni tiam kontrolu, estas 2 malpli ol la longo de Zamyla nomo. 6- ĝis 2 estas malpli ol 6. Jes, ni presi nun M en Zamyla nomo, la tria karaktero. 

La ŝlosilo tie estas ke en ĉiu ripeto de la rakonto, mi kontrolas, Estas i malpli ol la longo de Zamyla? Sed la ruzo estas ke Stirling ne propraĵo. Tiuj el vi kiuj programis antaŭe en Java aŭ aliaj lingvoj eksciu la longo de kordo estas propraĵo, nur iuj nurlegebla valoro. 

En C en ĉi tiu kazo, se ĉi tiu estas funkcio kiu estas laŭvorte kalkulante la nombron de karakteroj en Zamyla ĉiufoje ni nomas tiun funkcion. Ĉiufoje kiam vi demandas la komputilo por uzi Stirling, ĝi estas prenanta rigardi Zamyla, kaj dirante Z-Al-M-Kaj-L-A, 6. Kaj ĝi revenas 6. La sekvanta tempo vi vokas ĝi ene ol por ciklo, ĝi tuj rigardi Zamyla denove diru Z-Al-M-Kaj-L-A, 6. Kaj ĝi tuj revenas 6. Do kio estas stultaj pri tiu dezajno? 

Kial mia kodo ne 5 el 5 por dezajno nun, por tiel diri? Nu, mi petas de demando nenecese. Mi faras pli da laboro, ol mi bezonas. 

Do eĉ se la respondo estas korekta, mi estas petante la komputilo, kio estas la longo de Zamyla denove, kaj denove, kaj denove, kaj denove? Kaj ke respondo estas neniam tuj ŝanĝos. Ĝi estas ĉiam tuj estos 6. 

Do pli bona solvo ol tiu estus tiu proksima versio. Lasu min antaŭeniri kaj metis ĝin en aparta dosiero nomata string1.c, nur teni ĝin apartigu. Kaj ĝi rezultas en por buklo, vi povas reale deklari plurajn variablojn samtempe. 

Do mi tuj teni i kaj metis gxin al 0. Sed mi ankaŭ tuj aldoni komon, kaj diru: donu al mi variablo nomis n, kies valoro egalas la kordo longo de s. Nun bonvolu fari mia kondiĉo tiel longe kiel i estas malpli ol n. 

Do en ĉi tiu maniero, la logiko estas identaj ĉe la fino de la tago. Sed mi rememorante la valoro 6, tiukaze. Kiel longa de Zamyla nomo? Kaj mi metis ĝin en n. 

Kaj mi ankoraŭ kontrolanta la kondiĉo ĉiufoje. Estas 0 malpli ol 6? Estas 1 malpli ol 6? Estas 2 malpli ol 6, kaj tiel plu? 

Sed mi ne petas la komputilon denove kaj denove, kio estas la longo de Zamyla nomo? Kio estas la longo de Zamyla nomo? Kio estas la longo de tiu Zamyla nomo? Mi laŭvorte memorante ke unue kaj nur respondi en tiu dua variablo n. Do ĉi nun estus ne nur korekta, sed ankaŭ bone desegnita. 

Nun, kio pri stilo? Mi nomis mian variabloj sufiĉe bone, mi dirus. Ili estas súper konciza nun. Kaj tio estas tute bone. 

Se vi nur havas unu ŝnuro en programo, vi eble tiel nomas ĝin s por kordoj. Se vi nur havas unu variablo por rakonti en programo, vi eble tiel nomas ĝin I. Se vi havas longon n Estas súper komunaj ankaŭ. Sed mi ne diris iun el mia kodo. 

Mi ne informis la reader-- ĉu tio estas mia Tf, aŭ TA: aŭ simple colleague-- kio supozas esti okazanta en tiu programo. Kaj tiel akiri bonan stilon, kion mi volas fari Estas this-- ion kiel demandi uzanto por enigo. Kaj mi povus reverki tiun ajna nombro de manieroj. 

Certiĝu s-- certigi get ŝnuro revenis kordo. Kaj tiam en here-- kaj tio estas eble la plej grava comment-- ripeti super la karakteroj en s unuope. Kaj mi povus uzi ajnan elekto de la angla lingvo tie priskribi ĉiun de tiuj blokoj de kodo. 

Rimarku ke mi ne metis komenti ĉiun linion de kodo, vere nur sur la interesa tiuj, tiuj kiuj havas iun signifon ke mi deziras fari super klara al iu legante mian kodon. Kaj kial vi vokas akiri ŝnuro demandi uzanto por enigo? Eĉ ke oni ne nepre ĉiuj kiuj priskriba. Sed helpas rakonti rakonton, ĉar la dua linio en la rakonto estas, certigi akiri string revenis kordo. 

Kaj la tria linio en la rakonto estas, persisti super la karakteroj en s unu samtempe. Kaj nun nur por bonan mezuron, Mi tuj iros antaŭen kaj aldoni pli komenton kiuj ĵus diras print ia karaktero en s. Nun, kion mi faris ĉe la fino de la tago? 

Mi aldonis iom da la angla vortoj en la formo de komentoj. La oblikvo oblikvo simbolo signifas, hej, komputila ĉi estas por la homa, Ne vi, la komputilo. Do oni ignoris logike. Ili estas nur tie. 

Kaj ja CS50 IDE montras ilin kiel griza, kiel esti utila, sed ne klavon al la programo. Rimarki kion vi povas nun fari. Ĉu vi scias C programado aŭ ne, vi povas simple staras reen ĉe tiu programo kaj skim la komentoj. Petu uzanto por enigo, certigu akiri string revenis ĉenon, persisti super la karakteroj en s unuope, montri la karakteron ia karaktero en s-- vi ne eĉ devas rigardi la kodo kompreni kion tiu programo faras. Kaj, pli bona ankoraŭ, se vi mem rigardu en tiu programo en semajno aŭ du, aux monaton aux jaro, vi tro ne havas fiksrigardi la kodon, provante memori, kio mi provis fari kun tiu kodo? 

Vi diris mem. Vi priskribis lin mem, aŭ iu kolego, aŭ TA aŭ TF. Kaj tial ĉi tio estas nun ĝusta kaj bona dezajno, kaj finfine bona stilo ankaŭ. Do ja tenas ke en menso. 

Do ekzistas unu alia kion mi tuj faros ĉi tie kiu povas nun malkaŝas ĝuste kio estas okazas sub la kapuĉo. Do ekzistas tiu funkcio en C, kaj aliaj lingvoj, nomita typecasting ke aŭ implice aŭ eksplicite permesas konverti de unu datumtipo al alia. Ni estis kontraktanta tiel malproksime hodiaŭ kun kordoj. 

Kaj kordoj estas karakteroj. Sed memoras de semajno 0, kio estas signoj? Karakteroj estas nur abstraktaĵo aldone numbers-- dekumaj nombroj, kaj dekumaj nombroj estas vere nur abstraktado aldone duumaj nombroj, kiel ni difinis. 

Tiel karakteroj estas nombroj. Kaj ciferoj estas signoj, nur depende de la kunteksto. Kaj ĝi rezultas ke ene de komputila programo, vi povas specifi kiom vi volas rigardi ĉe la bitoj ene de tiu programo? 

Revokon de semajno 0 kiu ni havis Ascii, kiu estas ĝuste tiu kodo surĵeto leteroj al nombroj. Tial ni diris: ĉefurbo A estas 65. Ĉefurbo B estas 66, kaj tiel plu. 

Kaj avizo, ni esence havas signoj sur la supro vico tie, kiel C nomos ilin, karakteroj, kaj tiam ints en la dua vico. Kaj ĝi rezultas vi povas konverti perfekte inter la du, tipe. Kaj se ni volas fari tiun intence, ni eble volas pritrakti io tiamaniere. 

Ni eble volas konverti majuskla malaltigi kazo, aŭ minuskla al majuskla. Kaj ĝi rezultas ke la fakte mastro tie Ni povas ampleksi en nur momento. Sed ni rigardu unua je Ekzemple fari tion eksplicite. 

Mi tuj iros reen en CS50 IDE. Mi tuj kreos dosiero nomata Ascii 0.c. Kaj mi tuj iros antaŭen kaj aldoni miajn norma io.h ĉe la supro, int ĉefa malplenon ĉe la supro de mia funkcio. Kaj tiam mi simple tuj fari la following-- por ciklo de i egalas, diru, 65. 

Kaj tiam mi tuj estos malpli ol 65, plus 26 literoj en la alfabeto. Do mi lasos la komputilo fari la math por mi tie. Kaj tiam ene ĉi maŝo, kion mi povos presi? 

% C estas% i backslash n. Kaj nun mi volas ŝtopi en du valoroj. Mi provizore metis demandon markas tie inviti la demando. 

Mi volas persisti de 65 pluen por 26 literoj de la alfabeto, presi sur ĉiu ripeto ke rolulo integra ekvivalento. Alivorte, mi volas persisti super 26 numerojn printado kion la Ascii karaktero estas, la litero, kaj kia la respondan numeron is-- vere nur amuzante la diagramo de tiu diapozitivo. Do kion devus tiujn demandosignojn esti? 

Nu, tio rezultas ke la dua oni devus simple esti la variablo i. Mi volas vidi, ke kiel nombro. Kaj la meza argumento tie, mi povas diri al la komputilo trakti ke entjero I kiel gravulo, tiel kiel anstataŭigi ĝin ĉi tie por procento C. 

Alivorte, se mi, la homa programisto, scii tiuj estas nur nombroj fine de la tago. Kaj mi scias ke 65 devas mapi al iu karaktero. Kun tiu eksplicita rolantaro, kun paréntesis, la nomo de la datumtipo vi volas konverti al kaj fermita parentezo, vi povas diri la komputilo, hej, Komputilo, konverti ĉi entjero al char. 

Do kiam mi kuros ĉi programo post kompilado, ni vidu kion mi get-- fari Ascii 0. Darn ĝi, kion mi faris malĝuste tie? Uzo de nedeklarita ensalutilo, bone, ne intenca, sed ni vidu se ni ne povas kialo tra tiu. 

Do linio five-- tiel mi ne ricevis tre malproksime antaŭ tedas supren. Estas bone. Do linio 5 por i egalas 65-- vidas. Do memoru, ke en C, kontraste iuj lingvoj se vi havas antaŭan programado sperto, vi havas diri la komputilo, kontraste Scratch, kion tipo de variablo estas. 

Kaj mi forgesis ŝlosilan frazon ĉi tie. En linio kvin, Mi komencis uzanta i. Sed mi ne diris C kion datumtipo estas. Do mi tuj iros tien kaj diru, ha, faru gxin entjero. 

Nun mi tuj iros antaŭen kaj rekompili. Kiu riparis tion. ./ascii0 Enter, jen speco de malvarmeta. Ne nur estas ĝi súper rapida al demandas la komputilo ĉi demandon, anstataŭ rigardante ĝin sur tobogano, ĝi presas el unu po linio, A 65, B estas 66, la tutan vojon down-- kiam mi faris 26 times-- al la literoj z, kiu estas 90. Kaj, fakte, iomete pli inteligenta farus estis por mi ne fidi sur la komputilo aldoni 26. Mi povus esti simple farita 90 tiel, tiom longe kiel mi ne faras la saman eraron dufoje. Mi volas iri tra z, ne nur tra y. 

Do jen eksplicita rolantaro. Ĝi rezultas ke ĉi estas eĉ necesa. Lasu min antaŭeniri kaj rerun ĉi tradukilo kaj rerun Ascii 0. Ĝi rezultas ke C estas sufiĉe inteligenta. 

Kaj printf, precipe, estas sufiĉe inteligenta. Se vi simple preterpasas i dufoje por ambaŭ anstataŭaĵojn, printf konstatos, ho, bone mi konas vin donis al mi integer-- iun numeron, kiel 65 aŭ 90, aŭ kion ajn. Sed mi vidas ke vi volas ke mi formati tiun ciferon kiel karaktero. Kaj do printf povas implice jxetis la int al char por vi ankaŭ. Do tio ne estas problemo ĉe ĉiuj. 

Sed rimarki, pro tio ekvivalenteco ni povas efektive fari ĉi tiel. Lasu min antaŭeniri kaj fari unu alia versio de this-- Ascii 1.c. Kaj anstataŭ ripetanta super entjeroj povas vere blovi vian menson per ripetanta super karakteroj. Se char c ricevas ĉefurbo A Mi deziras antaŭeniri kaj fari tion, tiel longe kiel C estas malpli ol aŭ egala al ĉefurbo Z. Kaj en ĉiu ripeto Mi volas pliigo C, mi povas nun mia printf linion tie diru, procento C procento i denove, komo C. 

Kaj nun, mi povas iri la alia direkto, elfandi la karaktero eksplicite al entjero. Do, denove, kial vi faras tion? Ĝi estas iom stranga por ordigi de kalkuli laŭ karakteroj. 

Sed se vi komprenas kion estas okazas sub la kapuĉo, Tie estas vere neniu magio. Vi nur diras, hey, komputilo donu mi variablo nomis C de tipo char. Pravalorizi ĝin al ĉefurbo A. Tiam rimarki solan citaĵoj afero. 

Por karakteroj en C, memoras de pasintsemajne, vi uzas solan citaĵoj. Por kordoj, por vortoj, frazoj, vi uzas duoblan citaĵoj. OK, komputilo, daǔre faras tion, do Dum la karaktero estas malpli ol aŭ egala al z. Kaj mi scias el mia Ascii tablo, ke ĉiuj de tiuj Ascii kodoj estas apudaj. 

Mankas breĉoj. Do estas nur A tra Z, apartigitaj per unu numeron ĉiu. Kaj tiam mi povas pliigo char, se mi vere volas. Fine de la tago, ĝi estas nur nombro. Mi scias tion. Do mi povas nur supozi aldoni 1 al ĝi. 

Kaj tiam ĉi tiu tempo, Mi presi c, kaj tiam la integralo ekvivalento. Kaj mi eĉ ne bezonas la eksplicitan rolantaro. Mi povas lasi printf kaj la komputilo figuro aferojn, por ke nun se mi kuros fari Ascii1./ascii1, Mi alvenas la ĝusta sama aĵo kiel bone. 

Senutila programo, though-- neniu tuj reale skribi programaron por eltrovi, kio estis la nombro kiu mapas al A, aŭ B, aŭ Z? Vi simple tuj Guglas ĝin, aŭ rigardi ĝin supre enreta, aŭ rigardi ĝin sur diapozitivoj, aŭ similaj. Do kie tio ĉi reale preni utila? 

Nu, parolante pri tio diapozitivoj, rimarki ekzistas fakta padrono tie inter majuskla kaj minuskla ke ne estis hazarda. Rimarku ke ĉefurbo A estas 65. Minuskla a estas 97. Kaj kiel malproksime estas minuskla a? 

Do 65 estas kiom da paŝoj for de 97? Do 97 minus 65 estas 32. Tial ĉefurbo de 65. Se vi aldonas 32 al tiu, vi ricevas minuskla a. Kaj, ekvivalente, se vi subtrahi 32, vi revenas al ĉefurbo A-- sama kun B por iom b, granda C por iom c. 

Ĉiuj tiuj mankoj estas 32 dise. Nun, ĉi tio ŝajnas permesi nin fari ion kiel Microsoft Word, aŭ Google Docs trajto, kie vi povas elekti ĉiun kaj tiam diru, ŝanĝi ĉiujn al minuskla, aŭ ŝanĝi ĉiujn al majuskla, aŭ ŝanĝi nur la unuan vorton de frazo al majusklo. Ni povas efektive fari ion kiel tiu mem. 

Lasu min antaŭeniri kaj savi dosieron tie nomita kapitaligi 0.c. Kaj ni iru antaŭen kaj vipi programon kiu faras ĝuste tion jene. Tiel inkluzivi la CS50 biblioteko. Kaj inkludi normo / S. 

Kaj mi scias ĉi estas venanta baldaŭ. Do mi tuj metis ĝin en tie jam, string.h, do mi havas aliron al aĵoj kiel Stirling, kaj tiam int ĉefa malplenon, kiel kutime. Kaj tiam mi iros por antaŭeniri kaj fari fadenojn ricevas akiri string, nur akiri ĉenon de la uzanto. Kaj tiam mi tuj do mia prudento ĉeko. Se ŝnuro ne egala nula, tiam ĝi estas sekure daŭrigi. Kaj kion mi volas fari? Mi tuj persisti de i egalas 0, kaj n ĝis la kordo longo de s. 

Kaj mi tuj faros tion tiel longe kiel i estas malpli ol n, kaj i plus plus. Ĝis nun, mi estas vere nur pruntado ideoj de antaŭe. Kaj nun mi tuj enkonduki branĉo. 

Do pensas reen al Scratch, kie ni havis tiujn forkoj en la vojo, kaj lastan semajnon en C. Mi tuj diras, se la ia karaktero en s estas pli granda ol aŭ egala malaltigi kazo, kaj- en Scratch vi volus laŭvorte diras kaj, sed en C vi diras ampersand, ampersand-- kaj la ia karaktero en s estas malpli ol aŭ egala al minuskla z, ni faru ion interesan. Ni vere elprinti karaktero kun neniu lino kiu estas la karaktero en la kordo, la ia karaktero en la kordo. 

Sed ni iru antaŭen kaj subtrahi 32 el ĝi. Alie se la karaktero en la ĉeno kiu ni serĉas ne inter iom pli kaj iom z, antaŭeniri kaj simple presas ĝin neŝanĝita. Do ni enkondukis ĉi bracketed notacio por nia kordoj akiri ĉe la ia karaktero en la kordo. 

Mi aldonis iom kondiĉa logiko, kiel Nulo pasintsemajne la semajno, kie Mi nur uzas mian fundamenta komprenon de kio estas okazas sub la kapuĉo. Estas la ia karaktero de s pli granda ol aŭ egala al a? Kiel, ĉu 97 aŭ 98, aŭ 99, kaj tiel plu? 

Sed estas ankaŭ malpli ol aŭ egala al la valoro de minuskla z? Kaj se jes, kion signifas ĉi tiu linio signifas? 14, tio estas speco de la ĝermon de la tuta ideo, kapitaligi la leteron per simple subtrahanta 32 de ĝi, en tiu kazo, ĉar mi scias, por ke abako, kiel mia nombroj estas reprezentitaj. Do ni iru antaŭen kaj kuri ĉi, post kompilado kapitaligi 0.c, kaj kuri kapitaligi 0. 

Ni entajpi ion kiel Zamyla en ĉiuj minuskla eniri. Kaj nun ni havas Zamyla en ĉiuj majuskle. Ni entajpu Rob en ĉiuj minuskla. Ni provu Jason en ĉiuj minuskla. Kaj ni daŭre ricevas la devigita kapitaligo. Ekzistas negravaj cimoj mi ia ne anticipis. Rimarkos mian novan prompto estas fini sur la sama linio kiel iliaj nomoj, kiu sentas iom senorda. 

Do mi tuj iros tien, kaj fakte fine de tiu ĉi programo presi novan linion karaktero. Tio estas ĉio. Kun printf, vi ne bezonas En variabloj aŭ formato kodo. Vi povas laŭvorte nur presi iu kiel lino. 

Do ni iru antaŭen kaj fari kapitaligi 0 denove, rerun ĝin, Zamyla. Kaj nun ĝi estas iom pli bela. Nun, mia prompto estas sur lia propra nova linio. Do jen ĉio bone kaj bona. Do tio estas bona ekzemplo. Sed mi eĉ ne bezone bezonas forte kodo la 32. Vi scias kion? Mi povus say-- mi ne iam memori kio la diferenco estas. 

Sed mi scias ke se mi havas minuskla letero, Mi esence volas subtrahi for ajn la distanco estas inter iom a kaj granda A, ĉar se mi supozas ke ĉiuj aliaj literoj estas samaj, ke devus akiri la laborpostenon farita. Sed anstataŭ fari tion, vi scias kion? Ekzistas alia vojo ankoraŭ. 

Se tio estas kapitaligi 1.c-- se mi estus meti tiun en aparta dosiero. ni ja kapitaligi 2.c jene. Mi tuj vere purigi ĉi supre. Kaj anstataŭ eĉ devi scias aŭ zorgas pri tiuj malaltaj nivelo efektivigo detaloj, mi anstataŭe nur tuj presi karaktero, citaĵo unquote, procento C, kaj tiam nomita alia funkcio kiu ekzistas kiu prenas argumenton, kiu estas karaktero, kiel tiu. 

Rezultas en C, estas alia funkcio alvoko al supra, kiu kiel lia nomo sugestas prenas karaktero kaj faras liajn majusklo ekvivalento, kaj tiam revenas por ke printf povas ŝtopi ĝin en tie. Kaj tiel fari tion, kvankam mi bezonas enkonduki unu alia dosiero. Ĝi rezultas tie estas alia dosiero ke vi nur scias de klaso, aŭ lernolibron, aŭ reta referenco, nomata C type.h. 

Do se mi aldonas ke en Mia kaplinio dosierojn, kaj nun re-kompili tiun programon, capitalize2, ./capitalize2 Enter. Ni entajpu Zamyla en ĉiuj minuskle, ankoraŭ funkcias same. Sed vi scias kion? Ĝi rezultas ke al supra havas alian funkcion. 

Kaj lasu min enkonduki tiun ordonas tie, ia mallerte nomata, sed viro por manlibro. Ĝi rezultas ke la plimulto Linukso komputiloj, kiel ni uzas here-- Linukso mastruma system-- havas komandon nomita viro, kiu diras: hej, komputilo, donu al mi la komputilo manlibro. Kion vi volas serĉi en tiu manlibro? 

Mi volas serĉi la funkcio vokis supra, Enter. Kaj ĝi estas iom kamufla legi foje. Sed rimarkas ke ni estas en la Linukso programisto manlibro. Kaj ĝi estas ĉiuj tekstoj. Kaj rimarki ke estas la nomo de la funkcio ĝis tie. Rezultas ĝi havas kuzon nomitan malaltigi, kiuj faras la malon. Kaj avizo sub sinopsis, uzi tiun funkcii la viro paĝo, por tiel diri, diras al mi ke mi bezonas inkluzivi c type.h. Kaj mi sciis, ke de praktiko. 

Tie, ĝi montras al mi la du prototipoj por la funkcio, tiel ke se mi iam volas uzi tiun Mi scias, kion ili faras kiel enigo, kaj kion ili revenas kiel eligo. Kaj tiam se mi legas la priskribo, mi vidas pli detale kion la funkcio faras. Sed pli grave, se Mi rigardas sub reveno valoro, diras la valoro revenis estas ke de la konvertita leteron, aŭ C, la origina enigo, se la konvertiĝo ne estis ebla. 

Alivorte, al supra provos konverti letero al majusklo. Kaj se jes, ĝi estas tuj revenos ĝin. Sed se ĝi ne povas por iu reason-- eble estas jam majuskla, Eble estas ekkrion punkto aŭ alian punctuation-- ĝi estas nur tuj reveni la originalan C, kio signifas mi povas fari mian kodo bone desegnitaj kiel sekvas. 

Mi ne bezonas ĉiujn tiuj Darn linioj de kodo. Ĉiuj linioj mi havas nur reliefigis povas esti kaŝata en nur unu simplan linio, kiu estas this-- printf procento c al supra S krampo i. Kaj tio estus ekzemplo de bona desegno. 

Kial apliki en 7 aŭ 8 linioj de kodo, kio ajn ĝi estis, mi ĵus forigita, kiam vi povas anstataŭe kolapsi ĉiuj ke logiko kaj decidado en unu sola linio, 13 nun, ke dependas biblioteko function-- funkcio kiu venas kun C, sed ke faras precize kion vi volas fari. Kaj, sincere, eĉ se ĝi ne venas kun C, vi povus apliki ĝin mem, kiel ni vidis, per akiri negativan int kaj akiri pozitivajn int lasta semajno ankaŭ. 

Tiu kodo nun estas multe pli legebla. Kaj cetere, se ni rulumu supren, aspektas kiel multe pli kompakta tiu versio de mia programo estas. Estas iom pintaj pezaj nun, kun ĉiuj tiuj inkludas. Sed tio estas bone, ĉar nun mi staras sur la ŝultroj de programistoj antaŭ mi. Kaj kiu estis kiu implementado por supra vere faris al mi komplezon, tre kiel ajn implementado Stirling vere faris al mi komplezon iun tempon. Kaj do nun ni havas bona dezajno programo kiu implementa la ĝusta sama logiko. 

Parolante de Stirling, lasu min antaŭeniri kaj fari tion. Lasu min antaŭeniri kaj savi dosiero kiel stirling.c. Kaj ĝi rezultas, ni povas senŝeligi reen unu alia tavolo bela simple nun. Mi tuj iros antaŭen kaj vipo alian programon en ĉefa tie kiu simple re-ilojn string longo jene. Do jen linion de kodo ke akiras min ĉenon de la uzanto. Ni daǔre uzante ĉi denove kaj denove. Lasu min donu min variablon nomata n de tipo int kiu stokas kelkajn. 

Kaj lasu min antaŭeniri kaj fari la sekvan logiko. Dum la n-a karaktero en s faras Ne valoregalas backslash 0, antaŭeniri kaj pliigo n. Kaj tiam presi printf procento i n. Mi asertas ke tiu programo tie, sen nomi ĉenon longo, figuroj el la longo de kordo. 

Kaj la magio estas tute encapsulada en linio 8 tie kun kio aspektas kiel nova sintakso, ĉi backslash 0 en simpla citaĵoj. Sed kial estas tio? Nu, pripensu kion estas estita irante sur tiu tuta tempo. 

Kaj kiel flanken, antaŭ ol mi forgesas, realigi tro, ke krom la viro paĝoj kiuj venas kun tipa Linuksa sistemo kiel CS50 IDE, rimarkas ke ni, la Kompreneble stabo, havas ankaŭ faris retpaĝaro versio de tiu sama ideo nomita reference.cs50.net, kiu havas ĉiuj el tiuj samaj paĝoj de man, ĉiuj de tiu sama dokumentado, tiel kiel iom skatolo ĉe la supro kiuj permesas vi konverti ĉiujn sufiĉe arcano lingvo en malpli komforta reĝimo, kie ni, la instruisteco, trairos kaj provis simpligi iuj de la lingvo por teni aferojn temigis la ideojn kaj ne iuj de la tecnicismos. Do memoru, reference.cs50.net kiel alia rimedo tiel. 

Sed por kio string longo laboro en la vojo mi proponis antaŭ momento? Jen Zamyla nomon denove. Kaj jen Zamyla nomon boksis en, kiel mi daŭre fari, pentri bildon de ĝi estante, vere, nur vico de signoj. Sed Zamyla ne ekzistas izole en programo. 

Kiam vi skribas kaj ruli programon, vi uzas via Mac aŭ via PC kiel memoro, aŭ RAM tiel diri. Kaj vi povas pensi vian komputilon kiel havado multaj gigabajtoj de memoro tiujn tagojn. Kaj koncerton signifas miliardoj, do miliardoj da bajtoj. 

Sed ni malantaŭenigi ĝustatempe. Kaj supozu ke ni uzas vere malnova komputilo kiu nur havas 32 bajtoj de memoro. Mi povus, sur mia komputila ekrano, simple desegni ĉi ekstere kiel sekvas. 

Mi povis simple diri ke mia komputilo havas ĉiujn ĉi memoro. Kaj tio estas simila al peco da memoro, se vi memoras nian bildon de lasta tempo. Kaj se mi simple dividi ĉi en sufiĉe tempo, Mi asertas ke mi havas 32 bajtoj de memoro sur la ekrano. 

Nun, en realo, mi povas nur tiri ĝis nun sur ĉi tiu ekrano tie. Do mi tuj iros antaŭen, kaj kun nur konvencio, desegni mia komputilo memoro kiel krado, ne nur kiel unu rekto. Specife, mi asertas nun ke tiu krado, tiu 8 de 4 krado, nur reprezentas ĉiuj 32 bajtoj de disponebla memoro en mia Mac, aŭ disponeblaj en mia PC. Kaj ili estas ĉirkaŭvolvinte sur du linioj, nur ĉar ĝi persvadas pli sur la ekrano. Sed tiu estas la unua bitoko. Tio estas la dua bajto. Tiu estas la tria bitoko. 

Kaj tio estas la 32-a bitoko. Aŭ, se ni pensas kiel komputilo sciencisto, tiu estas bajto 0, 1, 2, 3, 31. Do vi havas 0 al 31, se vi komencas rakontante 0. 

Do se ni uzas programon ke alvokoj akiri string, kaj ni preni ĉenon de la homa kiel mi nomis Zamyla, Z-Al-M-Kaj-L-A, kiom en la mondo faras la komputilo sekvigi kiu bajto, kiun eron de memoro, apartenas al kiuj kordoj? Alivorte, se ni plue tajpi alian nomon en la komputilo, tiel Andi, nomante akiri string duafoje, A-N-D-Mi devas fini en la komputila memoro same. Sed kiel? 

Nu, tio rezultas ke sub la kapuĉo, kio C faras kiam stokante kordoj ke la homaj tipoj en, aŭ ke venis el iu alia fonto, estas konturas la finon kun speciala character-- backslash 0, kiu estas nur speciala maniero diri 80 bitoj en vico. 

Tiel A-- tiu estas la nombro 97 revokon. Do iu mastro de 8 bitoj reprezentas du ciferoj 97. Ĉi backslash 0 estas laŭvorte la numeron 0, a.k.a. nul, N-U-L, kontraste antaŭe, N-U-L-L, kiun ni parolis. Sed nuntempe, nur scias, ke tiu backslash 0 estas nur 80 bitoj en vico. 

Kaj ĝi estas nur jena linio en la sablo diros ion al la maldekstra apartenas al unu ŝnuro, aŭ unu datumtipo. Kaj ion dekstren apartenas al io alia. Andi nomo, dume, kiu nur vide okazas volvi sur la alia linio, sed tio estas nur estetika detalo, simile estas nul finita. 

Ĝi estas ĉeno de Al-N-D-Mi karakteroj, plus kvina sekreta karaktero, ĉiuj 0 bitoj, ke nur demarca Fine de Andi nomo ankaŭ. Kaj se ni nomas akiri string trian fojon en la komputilo por akiri ĉenon kiel Maria, G-Al-R-mi-A, simile estas Maria nomo nul finita kun backslash 0. 

Tio estas fundamente malsama de kiel komputilo estus tipe stoki entjero aŭ kaleŝego, aŭ aliaj datumtipoj ankoraŭ, ĉar revokon, entjero estas ĝenerale 32 bitoj, aŭ 4 bajtoj, aŭ eble eĉ 64 bitoj, aŭ ok bajtoj. Sed multaj primitivoj en komputilo en programlingvo havas fiksan nombron de bajtoj sub la hood-- eble 1, eble 2, eble 4, eble 8. 

Sed kordojn, per dezajno, havi dinamika nombro de karakteroj. Vi ne scias anticipe, gxis la homaj tipoj en Z-Al-M-Kaj-L-A, aŭ M-A-R-mi-A, aŭ A-N-D-Mi. Vi ne konas kiom da fojoj la uzanto tuj trafis la klavaro. Tial vi ne scipovas multaj karakteroj anticipe Vi tuj bezonas. 

Kaj do C nur speco de folioj kiel sekreta breadcrumb sub la kapuĉo fine de la kordo. Post stokante Z-Al-M-Kaj-L-A en memoro, ĝi ankaŭ simple metas la ekvivalenta de periodo. Fine de frazo, ĝi metas 80 bitoj, tiel kiel memori kie Zamyla komenciĝas kaj finiĝas. 

Do kio estas la rilato, tiam, por tiu programo? Tiu programo tie, Stirling, estas simple mekanismo por interesigi kordo de la uzanto, la linio 6. Linio 7, mi deklaras variablon nomis n kaj starigis ĝin egala al 0. 

Kaj tiam en linio 8, mi simple demandis la demando, dum la n-a karaktero faras Ne valoregalas ĉiuj 0 bits-- alivorte, ne egala tiu speciala karaktero, backslash 0, kiu Estis ĝuste tiu speciala nul character-- iri antaŭen kaj nur pliigo n. 

Kaj daŭre fari ĝin, kaj konservi farante ĝin, kaj daŭre fari ĝin. Kaj tial, kvankam en la pasinteco ni uzis i, ĝi estas perfekte bone semantike uzi n, se vi nur provas kalkuli ĉi tempo intence, kaj nur volas nomi ĝin n. Do ĉi nur tenas demandanta la demandon, estas la n-a karaktero de s ĉiuj _0s_? Se ne, rigardu al la sekva rigardo, rigardi al la sekva, rigardi al la proksima, rigardi al la sekva. 

Sed tuj kiam vi vidos backslash 0, ĉi loop-- linio 9 tra 11-- haltas. Vi rompi la dum buklo, lasante ene de tiu variablo n tuta grafo de ĉiuj karakterojn en la kordo vi vidis, tiel videbligi ĝin. Do ni provu tion. 

Lasu min antaŭeniri kaj, sen uzante la Stirling funkcio, sed nur per mia propra memfarita versio tie nomita Stirling, lasu min antaŭeniri kaj kuri Stirling, tajpu ion kiel Zamyla, kion mi scias anticipe Estas ses karakteroj. Ni vidu se tio funkcias. Efektive, ĝi estas ses. Ni provu kun Rob, tri karakteroj, tri karakteroj tiel, kaj tiel plu. Do jen ĉio tio okazas sur sub la kapuĉo. Kaj rimarki la rilatoj, tiam, kun la unua semajno de klaso, kie ni parolis pri io kiel abstraktado, kiu estas ĝuste ĉi layering de ideoj, aŭ komplekseco, aldone bazajn principojn. Tie, ni ia rigardanta sub la kapuĉo de Stirling, por tiel diri, por eltrovi, Kiel volus i esti implementado? 

Kaj ni povus re-apliki ĝin mem. Sed ni ne plu iros re-apliki Stirling. Ni nur tuj uzi Stirling por por fakte atingi iuj kordoj longo. 

Sed estas nenia magio sub la kapuĉo. Se vi scias, ke sub la kapuĉo, ŝnuro estas nur vico de signoj. Kaj ke sekvenco de karakteroj ĉiuj povas ciferece adresita kun krampo 0, krampo 1, krampo 2, kaj vi scias ke fine de ŝnuro estas speciala karaktero, vi povas diveni kiel fari preskaŭ kion ajn en programo, ĉar ĉiuj bolas malsupren al legas kaj skribas memoron. Te, ŝanĝanta kaj rigardanta en memoro, aŭ rampajxoj ĉirkaŭe en memoro, presanta aferojn sur la ekrano, kaj tiel plu. 

Do ni nun uzas ĉi ĵus trovita kompreno de kio cenoj reale estas sub la kapuĉo, kaj senŝeligi reen alia tavolo ke ĝis nun ni havas estis ignorante entute. Precipe ajn ni implementado programon, ni havis tiun linion de kodo proksime de la pinto deklarante ĉefa. Kaj ni specifis int ĉefa malplenon. 

Kaj ke malplenon ene la parantezoj estis dirante ĉiuj ĉi tempo, ke ĉefa mem ne prenas neniun argumentoj. Ajna enigo ke ĉefa estas tuj preni de la uzanto devas veni de iu alia mekanismo, kiel get int, aŭ akiri kaleŝego, aŭ akiri kordo, aŭ alian funkcion. Sed rezultu ke kiam vi skribas programon, Vi povas fakte specifi ke tiu programo estos preni enigoj de la homa ĉe la komandlinio mem. 

Alivorte, kvankam ni ĝis nun havas kuris nur ./hello saluton aŭ similaj programoj, ĉiuj aliaj programoj kiuj ni estis uzante, ke ni mem ne skribis, havi estita prenanta, ŝajnas, komandlinio arguments-- aĵoj kiel ŝminko. Vi diras ion kiel ŝminko, kaj tiam duan vorton. Aŭ tin, vi diras Clang, kaj tiam dua vorto, la nomo de dosiero. 

Aŭ eĉ RM aŭ CP, kiel vi povus vidis aŭ uzis jam forigi aŭ kopii dosierojn. Ĉiuj tiuj preni tn komandlinio arguments-- aldona vortoj en la terminalo prompto. Sed ĝis nun, ni mem ne havis tiun lukson de preni enigo de la uzanto kiam li aŭ ŝi vere kuras la programo mem ĉe la komandlinio. 

Sed ni povas fari tion per re-deklarante ĉefa movanta antaŭen, ne havanta void en krampoj, sed tiuj du argumentoj instead-- la unua entjero, kaj la dua io nova, iu kiun ni iras por voki tabelo, io simila en spirito al kion ni vidis en Scratch kiel listo, sed tabelo de kordoj, kiel ni baldaŭ vidos. Sed ni vidu tion vojo de ekzemplo, antaŭ ni distingi precize kion tio signifas. 

Do se mi iros en CS50 IDE tie, mi antaŭeniris kaj deklaris en dosiero nomata argv0.c la sekvan ŝablonon. Kaj rimarki la sola jen malsamaj ĝis nun estas ke mi ŝanĝis malplenon al int argc ŝnuro argv malferma krampo, fermi krampo. Kaj rimarki nun, ekzistas nenio ene de tiuj krampoj. 

Ekzistas neniu nombro. Kaj ekzistas neniu i, aŭ n, aŭ ajna alia letero. Mi nur uzis la rektaj krampoj por nun, pro kialoj ni venis reen al en nur momento. 

Kaj nun kion mi tuj faros estas tio. Se argc egalas egalas 2-- kaj memoras ke egalas egaluloj estas la egaleco operatoro komparante maldekstre kaj dekstre por egaleco. Ĝi ne estas la asigno operatoro, kiu estas la sola egalsigno, kiu signifas ekzempleron de dekstre maldekstren iu valoro. 

Se argc egalas egalas 2, mi volas diru printf, saluton, cent, nova linio, kaj tiam plug in-- kaj jen la nova trick-- argv krampo 1, por kialoj ke ni revenos al en momento. Alie se argc ne egala 2, vi scias kion? Ni nur iri antaŭen kaj, kiel kutime, presaĵo eksteren saluton mondo sen anstataŭigo. 

Tiel similus ke se argc, kiu signifas argumento grafo, egalas 2, Mi tuj presi saluton io aŭ alia. Alie, implicite, mi estas presigos saluton mondo. Do kion tio signifas? 

Nu, lasu min antaŭeniri kaj savi dosiero, kaj tiam ja faras argv0, kaj tiam ./argv0, Enter. Kaj ĝi diras saluton mondo. Nun, kial do? 

Nu, tio rezultas anytime vi ruli programon ĉe la komandlinio, vi plenigas en kio ni ĝenerale nomas argumento vektoro. Alivorte, aŭtomate la komputilo, la mastruma sistemo, tuj transdonos al via programo mem liston de ĉiuj el la vortoj ke la homa tajpita ĉe la prompto, en kazo vi la programisto volas fari ion kun tiu informo. Kaj en tiu kazo, la sola vorto Mi tajpis ĉe la prompto estas ./argv0. 

Kaj tiel la nombro de argumentoj kiuj estas aprobotaj al mia programo estas ĝuste tiu. Alivorte, la argumento rakonti, alie konata kiel argc tie kiel entjero, estas nur unu. Oni kompreneble ne egalas du. Kaj tial ĉi tio estas kion presas, saluton mondo. 

Sed lasu min forigi tiun ie. Mi diru, argv0. Kaj tiam kion pri Maria? Kaj tiam batis Enter. 

Kaj rimarki kio magie okazas tie. Nun, anstataŭ saluton mondo, mi havas ŝanĝis la konduton de tiu programo prenante la enigo ne de akiri ŝnuro aŭ alian funkcion, sed el, ŝajne, mia komando mem, kion mi origine tajpitaj. Kaj mi povas ludi ĉi tiun ludon denove ŝanĝi ĝin al Stelios, ekzemple. 

Kaj nun mi vidas alian nomon ankoraŭ. Kaj tie, mi povus diri Andi. Kaj mi dirus Zamyla. Kaj ni povas ludi ĉi tiun ludon tutan tagon, nur ŝtopanta en malsamaj valoroj, tiel longe kiel mi provizas ĝuste du vortoj en la prompto, tia ke argc, mia argumento grafo, estas 2. 

Mi vidas ke nomo ŝtopita en printf, por tiu kondiĉo tie? Do ni ŝajnas havi nun la esprima kapablo preni enigo de alia mekanismo, de la tn komandlinio, anstataŭ devi atendi ĝis la uzanto kuras la programon, kaj tiam instigas lin aŭ ŝin uzante ion kiel get kordoj. 

Do kio estas tio? Argc, denove, estas nur entjero, la nombro de words-- arguments-- ke la uzanto provizita je la prompto, ĉe la fina fenestro, Inkluzivanta la programo nomo. Tiel niaj ./argv0 estas, efektive, la programo nomo, aŭ kiom mi kuros la programo. 

Kiu rakontas kiel unu vorton. Do argc estus 1. Sed kiam mi skribas Stelios aŭ Andi, aŭ Zamyla, aŭ Maria, kiu signifas la argumento grafo estas du. Kaj tiel nun ekzistas du vortoj pasis en. 

Kaj avizo, ni povas daŭrigi tiun logikon. Se mi efektive diras, io kiel Zamyla Chan, plena nomo, tiel pasanta tri argumentojn en tuta, Nun diras la defaŭlta denove, ĉar, kompreneble, 3 ne egalas 2. 

Kaj tiel ili, do mi havas aliro tra argv tiu nova argumento ke ni povis teknike nomas ion ni volas. Sed per konvencio, ĝi estas argv kaj argc, respektive. Argv, argumento vektoro, estas speco de sinonimo por programado trajto en C nomita tabelo. 

Tabelo estas listo de similaj valoroj dorso, apogi, subteni, por dorso. Alivorte, se oni estas ĝuste ĉi tie en RAM, la venonta unu estas tuj apud ĝi, kaj tuj apud ĝi. Ili ne estas ĉiuj super la loko. Kaj ke ĉi-lasta scenaro, kie aferoj estas ĉiuj super la loko en memoro, povas efektive esti potenca trajto. Sed ni revenos al tio kiam ni paroli pri amatoro datumstrukturoj. Nuntempe, tabelo estas nur eron de apudaj memoro, ĉiu el kies elementoj estas dorso, apogi, subteni, apogi, kaj ĝenerale la sama tipo. 

Sekve se vi pensas pri, de Antaŭ momento, kio estas kordo? Nu, ŝnuro, kiel Zamyla, Z-Al-M-Kaj-L-Al, estas, teknike, nur tabelo. Ĝi estas tabelo de signoj. 

Kaj do se ni vere desegni ĉi, kiel mi faris antaŭe, kiel eron de memoro, ĝi rezultas ke ĉiu el tiuj karakteroj okupas bajton. Kaj tiam tie estas tio specialan sentinelo karaktero, la backslash 0, aŭ ok 0 bitoj, ke demarca la fino de tiu ĉeno. Do ŝnuro, rezultas eksteren, citi unquote ŝnuro, estas nur tabelo de chara-- char esti reala datumtipo. 

Kaj nun argv, meanwhile-- ni revenu al la programo. Argv, kvankam ni vidas la vorton ĉeno tie, ne estas signoĉeno mem. Argv, argumento vektoro, estas tabelo de kordoj. 

Tiel same vi povas havi tabelo de karakteroj, vi povas havi pli altan nivelon, tabelo de strings-- tiel, ekzemple, kiam mi tajpas antaŭ momento ./argv0 argv0, spaco Z-Al-M-Kaj-L-A, mi asertis ke argv havis du kordoj en it-- ./argv0, kaj Z-Al-M-Kaj-L-A. en Alivorte, argc estis 2. Kial estas tio? 

Nu, efektive, kio okazas estas ke ĉiu el tiuj kordoj estas, kompreneble, tabelo de signoj kiel antaŭe, ĉiu el kies karakteroj okupas unu bajto. Kaj ne konfuzi la fakta 0 en la programo nomo kun la 0, kio signifas ĉiuj 80 bitoj. Kaj Zamyla, dume, estas ankoraŭ ankaŭ aron da karakteroj. 

Do fine de la tago, ĝi vere aspektas kiel ĉi sube la kapuĉo. Sed argv, nature de kiel ĉefa verkoj, min permesas enpaki ĉion ĉi sur, se vi volas, pli granda tabelo ke, se ni iomete super simpligi kion la bildo aspektas kaj ne tute desegni ĝin grimpi supren tie, ĉi tabelo estas nur de grandeco 2, la unua elemento de kiu enhavas ĉenon, la dua elemento de kiu enhavas kordo. Kaj, en victurno, se vi ia zomi je sur ĉiu de tiuj kordoj, kion vi vidu sube la kapuĉo estas ke ĉiu linio estas simple tabelo de signoj. 

Nun, kiel kun kordoj, ni povis akiri aliron al la ia karaktero en ĉeno uzante tiu kvadrata krampo skribmaniero. Simile, kun tabeloj ĝenerale, povas nin uzi kvadrata krampo skribmaniero akiri en ajna nombro de kordoj en tabelo? Ekzemple, lasu min antaŭeniri kaj fari tion. 

Lasu min antaŭeniri kaj krei argv1.c, kiu estas iom malsama ĉi tiu tempo. Anstataŭ kontrolanta por argc2, Mi tuj anstataŭ fari tion. Por int mi ricevas 0, mi estas malpli ol argc, mi plus plus, kaj tiam presi ene de tiu, procento s, nova linio, kaj poste argv krampo i. 

Do alivorte, mi ne pritraktas individuajn karakterojn nuntempe. Argv, kiel implicita per tiuj malplenaj kvadrato krampoj dekstre de la nomo argv, signifas argv estas tabelo de kordoj. Kaj argc estas simple int. 

Tiu linio tie, 6, estas dirante aro i egalas al 0. Grafo tutan vojon ĝis, sed ne inkluzive de, argc. Kaj tiam ĉiu ripeto, presi kordo. Kio kordo? 

La ia ŝnuro en argv. Do dum antaŭ mi iris uzanta la kvadrata krampo notacion por atingi la Ith karaktero en ĉeno, nun Mi uzas la kvadrata krampo skribmaniero por atingi la Ith ĉenon en tabelo. Do ĝi estas speco de unu tavolo supre, koncepte. 

Do kio estas neta pri tio programo nun, se mi kompili argv1, kaj tiam fari ./argv1, kaj poste tajpi en io kiel foo trinkejo rabado, kiu estas la tri defaŭlta vortoj ke komputila sciencisto atingas por ajna momento li aŭ ŝi bezonas iun lokokupilo vortoj, kaj batis Enter, ĉiu el tiuj vortoj, Inkluzivanta la programo nomo, kiun Estas en argv antauxe loko, finas estante presita unuope. Kaj se mi ŝanĝi tion, kaj mi diras io kiel argv1 Zamyla Chan, ni akiri ĉiujn tri el tiuj vortoj, kiuj estas argv0, argv1, argv2, ĉar en tiu kazo argc, la grafo, estas 3. 

Sed kio estas neta estas, se vi komprenas ke argv estas nur tabelo de kordoj, kaj vi komprenas ke kordo estas tabelo de signoj, ni povas fakte speco de uzi ĉi kvadrata krampo skribmaniero plurfoje elekti kordo, kaj tiam elektu gravulo ene de la kordoj, plonĝado en profunda jene. En ĉi tiu ekzemplo, mi iros antaŭen kaj nomas tiun argv2.c. Kaj en ĉi tiu ekzemplo, lasu min antaŭeniri kaj fari la following-- por int i ricevas 0, i estas malpli ol argc, i plus plus, samkiel antaŭe. Tiel en aliaj words-- kaj nun tiu iĝas komplika sufiĉe. Tiam mi tuj diros persisti super kordoj en argv, kiel komento al mi mem. Kaj tiam mi iros al havi neston por ciklo, kiun vi probable faris, aŭ konsiderata faras, en Scratch, kie Mi tuj diru int-- mi ne tuj uzos mi denove, ĉar mi ne volas postsekvi aŭ ia anstataŭigi la ekzistantan i. 

Mi tuj, anstataŭe, diru j, ĉar jen mia go al variablo post i, kiam mi nur provas kalkuli simplaj nombroj. Por j ricevas 0-- kaj ankaŭ, n, tuj akiri la sxiplmalantauxo longo de argv krampo i, tiel longe kiel j estas malpli ol m, j plus plus, faru la sekvajn. Kaj jen la interesa parto. 

Presi karaktero kaj nova linio, ŝtopanta en argv krampo i, krampo j. Bone, do lasu min aldoni kelkajn komentojn tie. Persisti super karakteroj en nuna ŝnuro, presaĵo j ia karaktero en ia ŝnuro. Do nun, ni konsideru kion tiuj komentoj signifi. 

Persisti super la kordoj en argv-- kiom kordoj estas en argv, kiuj estas tabelo? Argc multaj, do mi ripetanta de i egalas 0 ĝis argc. Dume, kiom da karakteroj estas en la ia ŝnuro en argv? 

Nu, por atingi tiun respondon, Mi simple nomas string longo sur la aktuala ĉeno Mi prizorgo pri kiu estas argv krampo i. Kaj mi tuj provizore stoki ke valoro en n, nur por caching celoj, memori ĝin por efikeco. Kaj tiam mi iros pravalorizi j al 0, plu iri tiel longe kiel j estas malpli ol n, kaj sur ĉiu ripeto pliigo j. 

Kaj tiam ĉi tien, por mia komento sur linio 12, presi karaktero, sekvata de nova linio, specife argv krampo i donas min la ia ŝnuro en argv-- tiel la unua vorto, la dua vorto, la tria vorto ajn. Kaj tiam j plonĝas en profundan, kaj ricevas Min la j-a karaktero de tiu vorto. Kaj tiel, en efekto, ili povas trakti argv kiel multi-dimensia, kiel dudimensia tabelo, per ĉiu vorto ia aspekto kiel tiu en via menso okulo, kaj ĉiu karaktero estas speco de komponaĵo en kolumno, se tio helpas. 

En realo, kiam ni turmentus ĉi dise en estonteco semajnoj, ĝi tuj estos iom pli kompleksa ol tio. Sed vi povas vere pensi ke, de momento, kiel ĵus tiu dudimensia tabelo, per unu nivelon de ĝi Estas tuta de la kordoj. Kaj tiam se vi plonĝi en pli profundaj, vi povas atingi la individuaj karakteroj en gxi uzante tiu notacio tie. 

Do kio estas la pura efekto? Lasu min antaŭeniri kaj fari argv2-- Darn ĝin. Mi eraris tie. Implice deklari la biblioteko funkcio Stirling. Do ĉio ĉi momento, ĝi estas eble konvenajn ke ni ia fini ĝuste kie ni komencis. 

Mi ŝraŭbita supren, implice deklari biblioteko funkcio Stirling. Okej, atendu momenton. Mi memoras ke, speciale ĉar ĝi estas ĝuste ĉi tie. Mi bezonas inkluzivi string.h en tiu versio de la programo. 

Lasu min antaŭeniri kaj inkluzivi string.h, savi tion, antaŭeniri kaj rekompili argv2. Kaj nun, tie ni iru, faru argv2, Enter. Kaj kvankam ĝi estas iom kamufla unuavide, rimarki ke, fakte, kion estas presita estas skalara argv2. 

Sed se mi tajpas iun vortoj post la prompto, kiel argv2 Zamyla Chan, Eniros, ankaŭ iom kamufla unuavide. Sed se ni rulumu reen supren, ./argv2 Z-Al-M-Kaj-L-A C-H-Al-N. Do ni ripetis super ĉiu vorto. Kaj, siavice, ni ripetis super ĉiu karaktero ene de vorto. 

Nun, post ĉio ĉi, rimarkas ke estas unu alian detalon ni estis speco ignori tiun tutan tempon. Ni nur incitetis dise kio ĉefa la enigoj povas esti? Kio pri ĉefa eligo? 

Ĉiuj ĉi tempo, ni estis kopii kaj alglui la vorto int antaŭ ĉefa, Kvankam vi povas vidi en linio, foje neĝuste en malnovaj versioj de C kaj compiladores, ke ili diru malplenon, aŭ nenio ajn. Sed ja por la versio de C ke ni uzas, C 11, aŭ 2011, realigi ke plenumigxu int. Kaj ĝi devus aŭ esti malplena aŭ argc kaj argv tie. 

Sed kial int main? Kio ĝi efektive reveni? Nu, tio rezultas ĉiuj ĉi tempo, ajna tempo vi skribis programon ĉefa ĉiam revenanta ion. Sed estis farante tiel sekrete. 

Ke io estas int, kiel linio 5 sugestas. Sed kion int? Nu, tie estas tio konvencio en programado, per kiu se nenio fuŝiĝis kaj ĉiuj estas bone, programoj kaj funkcioj ĝenerale return-- iom counterintuitively-- 0. 0 ĝenerale signifas ĉio estas bone. Do eĉ se vi pensas pri kiel malvera en multaj kuntekstoj, ĝi efektive ĝenerale signifas bonan aferon 

Dume, se programo redonas 1, aŭ negativa 1, aŭ 5, aŭ negativaj 42, aŭ ajna ne-0 valoron, kiu ĝenerale signifas ke io iris malĝuste. Fakte, en via propra Mac aŭ PC, vi eble efektive vidis erarmesagxon, per tio diras ion aŭ alian, eraro kodo negativa 42, aŭ eraro kodo 23, aŭ io simila. Tiu nombro estas ĝenerale nur aludo al la programisto, aŭ la entrepreno kiu faris la programaro, kio eliris malbone kaj kial, por ke ili povu rigardi tra ilian dokumentaron aŭ kodo, kaj elkompreni la eraro fakte signifas. Ĝi estas ĝenerale ne utila al ni fini uzantojn. 

Sed kiam ĉefa revenas 0, ĉio bonas. Kaj se vi ne specifas kion ĉefa revenos, i volas nur aŭtomate reveni 0 por vi. Sed reveninte ion alia estas vere utila. 

En tiu lasta programo, lasu min antaŭeniri kaj nomas tiun exit.c, kaj enkonduki la lasta de la hodiaŭa temoj, konata kiel eraro kodo. Lasu min antaŭeniri kaj inkludas nia familiara dosierojn ĝis supro, do int ĉefa. Kaj ĉi tiu tempo, ni faros int argc, ŝnuro argv, kaj kun miaj krampoj implici ke ĝi estas en la tabelo. Kaj tiam mi simple fari prudento ĉeko. Tiu tempo, se argc ne egala 2, tiam vi scias kion? Forgesu ĝin. Mi intencis diri ke, hey, uzanto, vi mankas komandlinio argumento backslash n. 

Kaj tiam tio estas ĝi. Mi volas eliri. Mi iras al preventa, kaj antaŭtempe vere, reveno io alia ol la numero 1. La iri al valoro por la unua eraro kiu povas okazi estas 1. Se vi havas alian erara situacio kiu povus okazi, vi eble dirus reveno 2 aŭ reveni 3, aŭ eble eĉ negativa 1 aŭ negativa 2. 

Tiuj estas nur eliro kodoj kiu estas, ĝenerale, nur utila al la programisto, aŭ la kompanio kiu estas ekspedanta la programaron. Sed la fakto ke ĝi estas ne 0 estas kio estas grava. Do se en tiu programo, mi volas garantii ke tiu programo nur funkcias se la uzanto donas min kun argumento grafo de du, la nomo de la programo, kaj kelkaj aliaj vorto, mi povas plenumi tiel kiel sekvas: krias al la uzanto kun printf parolo mankas komandlinio argumento, revenu 1. Ke volo ĵus tuj forlasi la programon. 

Nur se argc egalas 2, ni akiras malsupren tie, ĉe kiu punkto mi tuj diru, saluton procento s, backslash n, argv1. Alivorte, mi estas ne tuj post argv 0, kiu estas nur la nomo de la programo. Mi volas presi saluton, komo, la dua vorto, kiun la homa tajpita. Kaj en ĉi tiu kazo sur linio 13, ĉiuj estas bone. 

Mi scias ke argc estas 2 logike el tiu programo. Mi tuj iros antaŭen kaj reveni 0. Kiel flanken, memoru ke tio estas vera en Scratch tiel. 

Logike, mi povus fari tion kaj encapsular tiujn liniojn de kodo en tiu alia klaŭzo tie. Sed tio estas ia nenecese deŝovante mia kodo. Kaj mi volas fari la super certe ke ne gravas, defaŭlte, saluton io estos get presita, tiel longe kiel la uzanto kunlaboras. 

Do ĝi estas tre komune uzi kondiĉo, nur se, kapti iun erara situacio, kaj tiam eliro. Kaj tiam, tiel longe ĉiuj estas bone, vi ne havas alian, sed nur havas la kodon ekster tio se, ĉar ĝi estas ekvivalenta en tiu aparta kazo, logike. Do mi revenas 0, nur por eksplicite signifas ĉio estas bone. 

Se mi preterlasis la reveno 0, ĝi farus aŭtomate supozis por mi. Sed nun, kiam mi estas revenanta en almenaŭ tiu kazo, Mi tuj, por bonan mezuron kaj klareco, reveno 0 en ĉi tiu kazo. Do nun lasu min antaŭeniri kaj fari eliron, kiu estas perfekta segue al simple forlasi. 

Sed fari eliro, kaj mi iros antaŭen kaj fari ./exit, Enter. Kaj la programo kriis al mi, mankas komandlinio argumento. OK, mi kunlaboras. 

Lasu min anstataŭ fari ./exit David, Enter. Kaj nun diras, saluton David. Kaj vi ne normale vidas ĉi. 

Sed rezultu ke ekzistas speciala maniero en Linukso por fakte vidi kun kion eliron kodo programo eliris. Kelkfoje en grafika mondo kiel Mac OS aŭ Vindozo, vi nur vidas tiujn numerojn kiam erarmesaĝo krevas supre sur la ekrano kaj la programisto montras vin tiom. Sed se ni volas vidi kion la eraro mesaĝo estas, ni povas fari ĝin here-- tiel ./exit, Enter, presaĵo mankas komandlinio argumento. 

Se mi nun faras eĥo $ ?, kiu estas ridinde kamufla rigardas. Sed $? estas la magia sorcxkanto kiu diras, hey, Komputilo, diru al mi kio la antaŭa programo eliro kodo estis. Kaj mi batis Enter. Mi vidas 1, ĉar tion mi diris mia ĉefa funkcio reveni. 

Dume, se mi faras ./exit David kaj batis Enter, mi vidas, saluton David. Kaj se mi nun faras eĥo $ ?, mi vidas saluton 0. Kaj tiel tiu volo reale esti valora informo en la kunteksto de la erarserĉilo, ne tiel multe ke vi, la homo, zorgus. Sed la debugger kaj aliaj programoj ni uzos ĉi semestro ofte rigardi tiun numeron, kvankam ĝi estas ia kaŝita for se vi serĉos ĝin, al determini ĉu aŭ ne programo ekzekuto estis ĝusta aŭ malĝusta. 

Kaj tial alportas nin tiun, fine de la tago. Ni komencis hodiaŭ per rigardado depuración kaj siavice en la kurso mem, kaj tiam pli interese, teknike sub la kapuĉo ĉe kio kordoj estas, kiu daŭris semajno simple prenis por koncedis, kaj certe prenis ilin por donita en Scratch. 

Ni tiam rigardis kiel ni povas aliri individuaj karakteroj en cxeno, kaj tiam denove prenis pli altan nivelon rigardi aferojn, rigardante kiel well-- se ni volas atingi individuajn elementoj en lerta kiel strukturo, ne ni faros tion kun multoblaj kordoj? Kaj ni povas kun komandlinio argumentoj. Sed ĉi bildo tie de simple skatoloj estas demonstrativo de ĉi ĝenerala ideo de tabelo aŭ listo, aŭ vektoro. Kaj depende de la kunteksto, ĉiuj tiuj vortoj signifas iomete malsamajn aferojn. Do en C, ni nur iri paroli tabelo. Kaj tabelo estas eron de memoro, ĉiu el kiuj estas elementoj estas apudaj, reen, subteni, apogi, por dorso. 

Kaj tiuj elementoj estas, ĝenerale, de la sama datumtipo, karaktero, karaktero, trajto, karaktero, aŭ kordo, ŝnuro, ĉeno, ĉeno, aŭ int, int, int, kio ajn ĝi estas ni provas vendejo. Sed fine de la tago, tio estas kion ĝi aspektas kiel koncepte. Vi prenas vian komputila memoro aŭ RAM. Kaj vi tranĉas ĝin en idente grandeco skatoloj, ĉiu el kiuj Estas reen por malantaŭeniri, por dorso, subteni tiamaniere. 

Kaj kio estas agrable pri tiun ideon, kaj la fakto ke ni povas esprimi valorojn tiamaniere kun la unua de nia datumstrukturoj en la klaso, signifas ni povas komenci solvi problemojn kun kodo kiu venis tiel intuicie en semajno 0. Vi memoras la telefonon libro ekzemplo, kie ni uzis dividu kaj regu, aŭ duuma serĉo algoritmo, kribri tra tuto faskon de nomoj kaj numeroj. Sed ni supozis, revokon, ke tio telefono libro estis jam ordo, ke iu alia jam Figurita fjordon donita listo de nomoj kaj numbers-- kiom alfabetizar ilin. Kaj nun kiam en C ni, Ankaŭ havas la kapablon meti aferojn, ne fizike en telefono libro sed virtuale en komputilo memoro, ni povos venontsemajne enkonduki denove this-- la unua de nia datumstrukturoj en tabelo sed pli grave, reala komputilo scienco algoritmoj implementado en kodo, kun kiu povos stoki datumoj en strukturoj kiel tiu, kaj tiam komenci manipuli ĝin, kaj efektive solvi problemojn kun ĝi, kaj konstrui sur supro de tiu, finfine, programoj en C, en Python, en JavaScript, informpeti datumbazoj kun SQLa? 

Kaj ni vidos, ke ĉiuj el tiuj malsamaj ideoj interplektiĝas. Sed nuntempe, memoras ke la regado kiun ni enkondukis hodiaŭ Estis tiu afero tie, kaj la mondo de ĉifriko. Kaj inter la proksimaj problemoj vi mem solvos estas la arto de ĉifriko, grimpadi kaj de-grimpanta informo kaj ciphering kaj deĉifri teksto, kaj supozante finfine ke vi nun scias kion estas sub la kapuĉo tiel ke kiam vi vidas aŭ ricevi mesaĝon tiel, vi mem povas deĉifri ĝin. Ĉiuj ĉi, kaj pli proksima tempo. 

[VIDEO reprodukto] 

-Mover Ĵus alvenis. Mi tuj iros vizito lia kolegiprofesoro. Yep. Hi. Estas vi. Atendi! David. Mi nur provas diveni kio okazis al vi. Bonvolu, io povus helpi. Vi estis lia kolegio kvara, estis ne? Vi estis tie kun li kiam Li finis la CS50 projekto? 

[MUZIKO Ludanta] 

-Tio Estis CS50. 

Mi amas tiun lokon. 

-Eat Supren. Ni iras for el komerco. 

[FINO reprodukto] 