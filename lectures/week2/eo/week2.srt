1
00:00:00,000 --> 00:00:02,970
>> [MUZIKO Ludanta]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Malan: Bone.

4
00:00:15,700 --> 00:00:18,832
Tiu estas CS50 kaj ĉi
estas la komenco de Semajno 2.

5
00:00:18,832 --> 00:00:21,040
Kaj vi memoras ke super
la pasinta paro de semajnoj,

6
00:00:21,040 --> 00:00:24,490
ni estis enkondukante komputilo
scienco kaj, siavice, programado.

7
00:00:24,490 --> 00:00:27,640
>> Kaj ni komencis la rakonton tra
Nulo, ke grafikan lingvo

8
00:00:27,640 --> 00:00:28,990
MIT'S Media Lab.

9
00:00:28,990 --> 00:00:30,780
Kaj tiam laste,
pasintsemajne, ĉu ni

10
00:00:30,780 --> 00:00:34,450
enkonduki higher-- a
malalta nivelo lingvo konata

11
00:00:34,450 --> 00:00:36,770
kiel C, iu kiu estas pure teksta.

12
00:00:36,770 --> 00:00:39,440
Kaj cetere, lastan fojon ni
esploris ene de tiu kunteksto

13
00:00:39,440 --> 00:00:40,450
kelkaj konceptoj.

14
00:00:40,450 --> 00:00:43,010
>> Tiu, revokon, estis la tre
unua programo ni rigardis.

15
00:00:43,010 --> 00:00:45,710
Kaj ĉi programo, tute simple,
presas el "saluton, mondo."

16
00:00:45,710 --> 00:00:47,730
Sed estas tiel
ŝajna magio okazas.

17
00:00:47,730 --> 00:00:51,460
Ekzistas tiu #include
kun tiuj angulajn krampojn.

18
00:00:51,460 --> 00:00:52,170
Estas int.

19
00:00:52,170 --> 00:00:53,020
Ekzistas (void).

20
00:00:53,020 --> 00:00:56,330
Ekzistas krampoj, krispa krampoj,
punktokomoj, kaj tiel plu.

21
00:00:56,330 --> 00:00:58,480
>> Kaj tiel, memoru ke
ni enkondukis Scratch

22
00:00:58,480 --> 00:01:02,110
tiel ke ni povus, ideale, vidu pasinteco
ke sintakso, la aĵoj kiuj vere ne

23
00:01:02,110 --> 00:01:04,590
ĉiuj kiuj intelekte
Interesa sed frue

24
00:01:04,590 --> 00:01:07,700
estas, absolute, iom malfacila
envolver vian menson ĉirkaŭe.

25
00:01:07,700 --> 00:01:10,860
Kaj cetere, unu el la plej komunaj
aferojn frue en programado klaso,

26
00:01:10,860 --> 00:01:13,443
speciale por tiuj malpli
komforta, estas akiri frustrita de

27
00:01:13,443 --> 00:01:17,460
kaj stumblis supren per certaj sintaksaj
eraroj, ne mencii logikaj eraroj.

28
00:01:17,460 --> 00:01:19,800
Kaj do inter niaj celoj
hodiaŭ, fakte, volo

29
00:01:19,800 --> 00:01:23,280
esti ekipi vin kun iuj
problemo-solvanta teknikoj por kiom

30
00:01:23,280 --> 00:01:26,705
better solvi problemojn sin
en la formo de depuración.

31
00:01:26,705 --> 00:01:29,330
Kaj vi memoras, ankaŭ, ke la
medio kiu nin enkondukis

32
00:01:29,330 --> 00:01:31,780
lasta tempo oni nomis CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Jen ttt-bazita softvaro kiu
permesas plani en la nubo,

34
00:01:34,850 --> 00:01:38,450
tiel diri, konservante cxiujn viajn
dosierojn kune, ni denove volas hodiaŭ.

35
00:01:38,450 --> 00:01:41,480
Kaj memoru ke ni
revizitita tiuj temoj ĉi tie,

36
00:01:41,480 --> 00:01:44,480
inter ili funkciojn kaj maŝojn kaj
variabloj, kaj Buleaj esprimoj,

37
00:01:44,480 --> 00:01:45,110
kaj kondiĉojn.

38
00:01:45,110 --> 00:01:49,190
Kaj fakte kelkaj pli ke ni
tradukite de la mondo de Scratch

39
00:01:49,190 --> 00:01:50,800
al la mondo de C.

40
00:01:50,800 --> 00:01:53,220
>> Sed la fundamenta konstruaĵo
blokoj, tiel diri,

41
00:01:53,220 --> 00:01:55,150
estis vere ankoraŭ la sama pasintsemajne.

42
00:01:55,150 --> 00:01:57,900
Fakte, ni vere nur havis
malsamaj enigmo pecon, se vi volas.

43
00:01:57,900 --> 00:02:00,300
Anstataŭ ke purpuraj
savi bloko, ni anstataŭe

44
00:02:00,300 --> 00:02:02,940
estis printf, kiu estas
tiu funkcio en C kiu

45
00:02:02,940 --> 00:02:05,890
permesas presi ion
kaj formati ĝin sur la ekrano.

46
00:02:05,890 --> 00:02:07,950
Ni enkondukis la CS50
Biblioteko, kie vi

47
00:02:07,950 --> 00:02:11,420
havas nun je via dispono get_char,
kaj get_int kaj get_string,

48
00:02:11,420 --> 00:02:14,610
kaj kelkaj aliaj funkcioj kiel
bone, per kiu vi povas akiri enigo

49
00:02:14,610 --> 00:02:16,260
de la uzanto propra klavaro.

50
00:02:16,260 --> 00:02:20,640
Kaj ni prenis rigardu aferoj
kiel these- bool, kaj char,

51
00:02:20,640 --> 00:02:22,490
kaj duobla, kaleŝego,
int, long_long ŝnuro.

52
00:02:22,490 --> 00:02:25,170
Kaj ekzistas eĉ aliajn datumtipoj en C.

53
00:02:25,170 --> 00:02:28,560
>> Alivorte, kiam vi deklaras
ŝanĝiĝema stoki iu valoro,

54
00:02:28,560 --> 00:02:32,600
aŭ kiam vi apliki funkcio
kiu revenas iun valoron,

55
00:02:32,600 --> 00:02:35,290
vi povas specifi kion
tipo de valoro kiu estas.

56
00:02:35,290 --> 00:02:37,310
Estas ĝi ŝnureto, kiel
sekvenco de karakteroj?

57
00:02:37,310 --> 00:02:39,490
Cxu estas nombro, kiel entjero?

58
00:02:39,490 --> 00:02:41,390
Cxu estas glitpunktaj
valoro, aŭ similaj?

59
00:02:41,390 --> 00:02:46,180
Do en C, kontraste Scratch, ni reale
komencis specifi kia datumoj

60
00:02:46,180 --> 00:02:48,330
ni returniĝo aŭ uzante.

61
00:02:48,330 --> 00:02:51,910
>> Sed, kompreneble, ni ankaŭ renkontis
kelkaj fundamentaj limoj de komputado.

62
00:02:51,910 --> 00:02:54,100
Kaj precipe,
tiu lingvo C, revokon

63
00:02:54,100 --> 00:02:57,070
ke ni prenis rigardu
entjero overflow, la realaĵo

64
00:02:57,070 --> 00:03:00,460
ke se vi nur havas
finia kvanto de memoro

65
00:03:00,460 --> 00:03:04,600
aŭ, specife, finia nombro
de bitoj, vi povas nur kalkuli tiel alta.

66
00:03:04,600 --> 00:03:08,460
Kaj tiel ni rigardis tiun ekzemplon tie
per kontraŭrevolucio en aviadilo,,

67
00:03:08,460 --> 00:03:13,510
fakte, se kurante sufiĉe longe estus
inunda kaj rezulti en programaro

68
00:03:13,510 --> 00:03:15,560
fakta fizika potencialo eraro.

69
00:03:15,560 --> 00:03:18,600
>> Ni ankaŭ rigardis flosanta
punkto imprecision, la realaĵo

70
00:03:18,600 --> 00:03:22,280
ke nur finia nombro
de bitoj, ĉu ĝi estas 32 aŭ 64,

71
00:03:22,280 --> 00:03:27,330
Vi nur povas specifi multaj nombroj
post dekuma punkto, post kiu vi

72
00:03:27,330 --> 00:03:29,110
komencu akiri malpreciza.

73
00:03:29,110 --> 00:03:32,360
Do ekzemple, triono en la
mondo tie, en nia homa mondo,

74
00:03:32,360 --> 00:03:35,360
ni scias estas nur malfinia nombro
de 3s post la dekuma punkto.

75
00:03:35,360 --> 00:03:38,820
Sed komputilo ne povas nepre
reprezentas senfinan nombron de ciferoj

76
00:03:38,820 --> 00:03:42,590
se vi nur permesas iun
finia kvanto de informo.

77
00:03:42,590 --> 00:03:45,900
>> Tial ne nur ni ekipi vin
kun granda potenco en terminoj

78
00:03:45,900 --> 00:03:49,280
de kiel vi povus esprimi sin ĉe
klavaro en terminoj de programado,

79
00:03:49,280 --> 00:03:51,430
ni ankaŭ limigita kio
vi povas reale fari.

80
00:03:51,430 --> 00:03:55,790
Kaj efektive, cimoj kaj eraroj povas
ekesti de tiuj specoj de aferoj.

81
00:03:55,790 --> 00:03:59,900
Kaj fakte, inter la temoj hodiaŭ
tuj estos temoj kiel depuración

82
00:03:59,900 --> 00:04:03,699
kaj fakte rigardis sub la kapuĉo
ĉe kiel aferoj estis lanĉita lastan semajnon

83
00:04:03,699 --> 00:04:05,490
efektive implementado
por ke vi pli bone

84
00:04:05,490 --> 00:04:10,530
kompreni ambaŭ la kapablojn de kaj
la limigoj de lingvo kiel C.

85
00:04:10,530 --> 00:04:14,770
>> Kaj fakte, ni senŝeligas reen la tavolojn
de la plej simpla de datumstrukturo,

86
00:04:14,770 --> 00:04:17,756
iu nomita tabelo, kiu
Nulo okazas nomi "listo."

87
00:04:17,756 --> 00:04:19,589
Estas iomete
malsama en tiu kunteksto.

88
00:04:19,589 --> 00:04:23,340
Kaj tiam ni ankaŭ enkonduki unu el la
unua de nia domajno-specifa problemojn

89
00:04:23,340 --> 00:04:26,790
en CS50, la mondo de
ĉifriko, la arto de grimpadi

90
00:04:26,790 --> 00:04:29,650
aŭ en ciphering informo tiel
ke vi povas sendi sekretajn mesaĝojn

91
00:04:29,650 --> 00:04:34,520
kaj malkodi sekretajn mesaĝojn
inter du personoj, A kaj B.

92
00:04:34,520 --> 00:04:37,490
>> Do antaŭ ol ni transiro
al tiu nova mondo,

93
00:04:37,490 --> 00:04:42,059
ni provu ekipi vin kun iuj
teknikoj per kiu vi povas forigi

94
00:04:42,059 --> 00:04:43,850
aŭ redukti almenaŭ iuj
de la frustraciones

95
00:04:43,850 --> 00:04:46,630
ke vi probable renkontis
dum la pasinta semajno sole.

96
00:04:46,630 --> 00:04:50,830
Fakte, antaŭ vi such-- kelkaj
via unua problemoj en C. Kaj probablecoj estas,

97
00:04:50,830 --> 00:04:54,010
Se vi estas kiel mi, la unuan fojon
Vi provu tajpi ekster programo,

98
00:04:54,010 --> 00:04:57,330
eĉ se vi pensas logike
la programo estas sufiĉe simpla,

99
00:04:57,330 --> 00:05:01,200
vi eble tre bone trafis muron, kaj
la tradukilo ne tuj kunlabori.

100
00:05:01,200 --> 00:05:03,940
Fari aŭ Clang ne tuj
efektive fari vian peton.

101
00:05:03,940 --> 00:05:05,450
>> Kaj kial povus esti?

102
00:05:05,450 --> 00:05:07,950
Nu, ni rigardu,
eble, simpla programo.

103
00:05:07,950 --> 00:05:11,190
Mi tuj iros antaŭen kaj savi ĉi en
dosiero intence nomita buggy0.c,

104
00:05:11,190 --> 00:05:13,590
ĉar mi konas ĝin
esti mankhava anticipe.

105
00:05:13,590 --> 00:05:17,400
Sed mi ne rimarkas ke se tiu
estas la unua aŭ dua aŭ tria programo

106
00:05:17,400 --> 00:05:18,830
ke mi fakte farante min.

107
00:05:18,830 --> 00:05:23,820
Do mi tuj iros antaŭen kaj
tajpi eksteren, int main (void).

108
00:05:23,820 --> 00:05:28,130
Kaj tiam ene de mia krispa krampoj,
tre familiara ( "saluton, world--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - kaj semi-dupunkto.

110
00:05:30,980 --> 00:05:32,360
>> Mi savis la dosieron.

111
00:05:32,360 --> 00:05:34,850
Nun mi tuj iros malsupren
al mia fina fenestro

112
00:05:34,850 --> 00:05:40,340
kaj tipo ŝminko buggy0, ĉar, denove,
la nomo de la dosiero hodiaŭ estas buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Do mi tajpas fari buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Kaj, ho, ho, memoras de lasta horo
ke neniu erarmesaĝojn estas bona afero.

115
00:05:48,200 --> 00:05:49,740
Do neniu eligo estas bona afero.

116
00:05:49,740 --> 00:05:52,920
Sed tie mi havas klare
iu nombro da eraroj.

117
00:05:52,920 --> 00:05:56,470
>> Tiel la unua linio de produktado
post tajpado fari buggy0, revokon,

118
00:05:56,470 --> 00:05:59,540
estas Clang estas sufiĉe abundajn eligo.

119
00:05:59,540 --> 00:06:02,067
Sub la kapuĉo,
CS50 IDE estas agordita

120
00:06:02,067 --> 00:06:04,150
uzi tutan faskon da
ebloj kun ĉi tradukilo

121
00:06:04,150 --> 00:06:05,941
por ke vi ne havas
pensi pri ili.

122
00:06:05,941 --> 00:06:08,840
Kaj tio estas ĉio, kion unuan linion
per kiu komenciĝas kun Clang.

123
00:06:08,840 --> 00:06:11,720
>> Sed post tio, la problemoj
komencas faras lian aperon.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c sur linio 3, karaktero
5, estas granda, ruĝa eraro.

125
00:06:17,390 --> 00:06:18,380
Kio estas tio?

126
00:06:18,380 --> 00:06:23,562
Implice deklari biblioteko funkcio
printf kun tipo int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Mi volas diri, ĝi tre rapide
ricevas tre arkaikaj.

129
00:06:28,379 --> 00:06:30,170
Kaj certe, unue
rigardo, ni ne volis

130
00:06:30,170 --> 00:06:32,380
atendas vin kompreni la
tuteco de tiu mesaĝo.

131
00:06:32,380 --> 00:06:34,213
Kaj tiel unu el la lecionoj
hodiaŭ tuj

132
00:06:34,213 --> 00:06:36,919
esti provi rimarkos
ŝablonoj, aŭ similaj aferoj,

133
00:06:36,919 --> 00:06:38,960
al eraroj vi havu
renkontis en la pasinteco.

134
00:06:38,960 --> 00:06:41,335
Do ni turmentus aparte nur
tiuj vortoj kiuj aspektas familiara.

135
00:06:41,335 --> 00:06:44,290
La grandaj, ruĝaj eraro estas klare
simbolon esti erara.

136
00:06:44,290 --> 00:06:47,940
>> implice deklari
biblioteko funkcio printf.

137
00:06:47,940 --> 00:06:51,680
Do eĉ se mi ne bone komprenas kion
implice deklari biblioteko funkcio

138
00:06:51,680 --> 00:06:54,900
rimedoj, la problemo certe
rilatas al printf iel.

139
00:06:54,900 --> 00:06:59,130
Kaj la fonto de tiu temo
devas vidi kun deklarante ĝin.

140
00:06:59,130 --> 00:07:02,440
>> Deklarante funkcio estas
mencii ĝin por la unua fojo.

141
00:07:02,440 --> 00:07:06,210
Kaj ni uzis la terminologion lasta semajno
de deklari funkcia prototipo,

142
00:07:06,210 --> 00:07:11,860
ĉu per unu linio je la supro de via
propra dosiero aŭ en tn kaplinio dosiero.

143
00:07:11,860 --> 00:07:15,300
Kaj en kio dosiero faris ni diras
lasta semajno ke printf estas citaĵo,

144
00:07:15,300 --> 00:07:17,080
unquote, deklaris?

145
00:07:17,080 --> 00:07:20,950
En kio dosiero estas ĝia prototipo?

146
00:07:20,950 --> 00:07:24,640
>> Do se vi memoras, la unua afero, kiun mi
tajpita, preskaŭ ĉiu programo lasta time--

147
00:07:24,640 --> 00:07:30,790
kaj hazarde antaŭ momento komenciĝis
tajpado mia volo estis tiun here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- por
enigo / output-- skalara h Kaj efektive,

149
00:07:38,630 --> 00:07:41,860
se mi nun savu tiu dosiero, mi tuj
iri antaŭen kaj liberigi mian ekranon,

150
00:07:41,860 --> 00:07:44,740
kiun vi povas fari tajpante
Klara, aŭ vi povas teni Kontrolo L,

151
00:07:44,740 --> 00:07:47,680
nur malbari vian terminalfenestro
nur forigi iun malordon.

152
00:07:47,680 --> 00:07:51,370
>> Mi tuj iros antaŭen kaj
re-tipo ŝminko buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Kaj voila, mi ankoraŭ vidas ke
longa komando de Clang,

154
00:07:53,790 --> 00:07:55,470
sed estas nenia erarmesaĝo tiu tempo.

155
00:07:55,470 --> 00:07:58,800
Kaj efektive, se mi faras ./buggy0,
samkiel lasta fojo,

156
00:07:58,800 --> 00:08:01,860
kie skalara signifas tiu
dosierujo, Slash simple signifas,

157
00:08:01,860 --> 00:08:05,040
tie venas la nomon de la programo kaj
ke nomo de la programo estas buggy0,

158
00:08:05,040 --> 00:08:07,340
Eniri, "saluton, mondo."

159
00:08:07,340 --> 00:08:09,440
>> Nun, kiel povus vi havas
kolektadis ĉi solvo

160
00:08:09,440 --> 00:08:12,017
sen nepre
rekonante kiel multaj vortoj

161
00:08:12,017 --> 00:08:14,350
kiel mi agis, certe, havanta
farante tiun dum tiom da jaroj?

162
00:08:14,350 --> 00:08:18,720
Nu, realigi po la unua problemo
aro, ni konigu vin al ordono

163
00:08:18,720 --> 00:08:21,175
ke CS50 propra stabo
skribis nomitan help50.

164
00:08:21,175 --> 00:08:24,300
Kaj efektive, C faras specifo por
la problemo aro kiel al kiel uzi tiun.

165
00:08:24,300 --> 00:08:27,210
>> Sed help50 estas esence
programo kiu CS50 bastonon

166
00:08:27,210 --> 00:08:30,850
skribis ke permesas kuri
iu komando aŭ kuri programon,

167
00:08:30,850 --> 00:08:36,169
kaj se vi ne komprenas liajn
eligo, pasi lian eliron al help50,

168
00:08:36,169 --> 00:08:38,890
ĉe kiu punkto la programaro
ke la kurson bastono skribis

169
00:08:38,890 --> 00:08:42,429
rigardos via programo eligo
linio por linio, karaktero por karaktero.

170
00:08:42,429 --> 00:08:46,000
Kaj se ni, la personaro, rekoni la
erarmesaĝo ke vi spertas,

171
00:08:46,000 --> 00:08:50,580
ni provos instigi vin kun iuj
retorika demandoj, kun iuj konsiloj,

172
00:08:50,580 --> 00:08:54,890
multe kiel TF aŭ CA aŭ mem
farus en persono ĉe oficejo horoj.

173
00:08:54,890 --> 00:08:58,320
>> Do rigardu al help50 se vi ne
nepre rekoni problemo.

174
00:08:58,320 --> 00:09:00,790
Sed ne fidi lin
tro multe kiel lambastono.

175
00:09:00,790 --> 00:09:03,990
Certe provi kompreni lian
eligo kaj lerni de ĝi

176
00:09:03,990 --> 00:09:07,571
tiel ke nur unu-dufoje faros vin
iam kuri help50 por aparta eraro

177
00:09:07,571 --> 00:09:08,070
mesaĝo.

178
00:09:08,070 --> 00:09:10,660
Post tio, vi devas esti
bone ekipitaj mem

179
00:09:10,660 --> 00:09:13,180
elkompreni kio reale estas.

180
00:09:13,180 --> 00:09:14,350
>> Ni faru unu alia tie.

181
00:09:14,350 --> 00:09:20,410
Lasu min antaŭeniri kaj en alia
dosiero ni nomas tiun buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Kaj en la dosiero mi
tuj deliberately--

183
00:09:23,110 --> 00:09:26,330
sed ŝajnigi, ke mi ne
kompreni kion eraro mi faris.

184
00:09:26,330 --> 00:09:31,420
>> Mi tuj iros antaŭen kaj fari this--
#include, ekde mi havas

185
00:09:31,420 --> 00:09:33,660
lernis mian lecionon de antaŭ momento.

186
00:09:33,660 --> 00:09:36,220
Int main (void), kiel antaŭe.

187
00:09:36,220 --> 00:09:40,880
Kaj tiam en ĉi tie mi iras
fari ĉenon s - get_string.

188
00:09:40,880 --> 00:09:43,770
Kaj memoras de lasta tempo ke
tio signifas, hej, Komputilo,

189
00:09:43,770 --> 00:09:48,280
donu al mi variablo, nomas ĝin s, kaj
fari la tipo de tiu variablo kordo

190
00:09:48,280 --> 00:09:50,150
do mi povas stoki unu aŭ pli vortoj en ĝi.

191
00:09:50,150 --> 00:09:52,191
>> Kaj tiam dekstre-mana
flanko de la egalsigno

192
00:09:52,191 --> 00:09:54,980
Estas get_string, kiu estas
funkcio en la CS50 biblioteko

193
00:09:54,980 --> 00:09:55,980
kiu faras ĝuste tion.

194
00:09:55,980 --> 00:09:59,740
Ĝi ricevas funkcio kaj tiam
manoj ĝin de dekstre maldekstren.

195
00:09:59,740 --> 00:10:02,670
Do ĉi egalsigno ne signifas
"Egalas" kiel ni povus pensi en matematiko.

196
00:10:02,670 --> 00:10:04,750
Signifas asigno de dekstre maldekstren.

197
00:10:04,750 --> 00:10:09,640
Do tiu signifas, preni la kordo de
la uzanto kaj gardi ŝin ene de s.

198
00:10:09,640 --> 00:10:10,460
>> Nun ni uzas ĝin.

199
00:10:10,460 --> 00:10:13,820
Lasu min nun kaj kiel dua
linio, lasu min antaŭeniri kaj diru "saluton" -

200
00:10:13,820 --> 00:10:19,330
ne "mondo", sed "Saluton,% s--
kiu estas nia lokokupilo, komo s,

201
00:10:19,330 --> 00:10:22,030
kiu estas nia varia,
kaj tiam semi-dupunkto.

202
00:10:22,030 --> 00:10:26,070
Do se mi ne ŝraŭbi supren tro multe
tie, tio aspektas kiel korekta kodo.

203
00:10:26,070 --> 00:10:28,090
>> Kaj mia instinkto nun kompili ĝin.

204
00:10:28,090 --> 00:10:30,400
La dosiero nomata buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Do mi tuj faru fari buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Kaj Darn-ĝi, se oni ne
eĉ pli eraroj ol antaŭe.

207
00:10:36,377 --> 00:10:38,210
Mi volas diri, estas pli
erarmesaĝojn ĝi farus

208
00:10:38,210 --> 00:10:40,400
ŝajnas ol fakta linioj en tiu programo.

209
00:10:40,400 --> 00:10:42,730
>> Sed la takeaway tie estas,
eĉ se vi estas premita

210
00:10:42,730 --> 00:10:45,040
kun du aŭ tri aŭ
kvar pli erarmesaĝojn,

211
00:10:45,040 --> 00:10:48,340
enfokusigi ĉiam sur la tre
unua de tiuj mesaĝoj.

212
00:10:48,340 --> 00:10:52,220
Rigardante la supro-plej unu,
movo reen kiel necese.

213
00:10:52,220 --> 00:10:53,930
Do jen mi tajpis konsiston buggy1.

214
00:10:53,930 --> 00:10:55,700
Jen ke Clang eligo kiel atendis.

215
00:10:55,700 --> 00:10:57,290
>> Kaj jen la unua ruĝa eraro.

216
00:10:57,290 --> 00:11:02,370
Uzo de nedeklarita ensalutilo
kordo, ĉu mi signifas normon en?

217
00:11:02,370 --> 00:11:04,260
Tiel normo en estas
vere io alia.

218
00:11:04,260 --> 00:11:06,240
Ĝi raportas al la uzanto
klavaro, esence.

219
00:11:06,240 --> 00:11:08,080
>> Sed tio ne estas kion mi volis diri.

220
00:11:08,080 --> 00:11:11,770
Mi signifis ŝnuro, kaj mi intencis get_string.

221
00:11:11,770 --> 00:11:16,200
Do kio estas tio, kion mi
forgesis fari tiun tempon?

222
00:11:16,200 --> 00:11:20,230
Kio mankas cxi tiun tempon?

223
00:11:20,230 --> 00:11:23,600
Mi havas mian #include,
do mi havas aliron al printf.

224
00:11:23,600 --> 00:11:26,090
>> Sed kion mi ne havas
aliro al nur ankoraŭ?

225
00:11:26,090 --> 00:11:29,420
Nu, ĝuste kiel lasta fojo,
Mi devas diri la tradukilo

226
00:11:29,420 --> 00:11:31,691
Clang kion tiuj funkcioj estas.

227
00:11:31,691 --> 00:11:33,940
Get_string ne venas
kun C. Kaj en aparta, ĝi

228
00:11:33,940 --> 00:11:38,160
ne venas en la
header dosiero,.

229
00:11:38,160 --> 00:11:40,770
Ĝi anstataŭe envenas
ion la bastonon skribis,

230
00:11:40,770 --> 00:11:44,176
kiu estas malsama dosiero
nomi sed trafe nomita.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Do simple aldonante ke unu linio
de code-- revokon de lasta horo

233
00:11:50,861 --> 00:11:53,610
ke kiam Clang kuras, ĝi tuj
rigardi mian kodo supre sube,

234
00:11:53,610 --> 00:11:54,193
maldekstre dekstren.

235
00:11:54,193 --> 00:11:57,200
Ĝi tuj rimarkas,
ho, vi deziras.

236
00:11:57,200 --> 00:11:59,900
Mi volas iri kaj trovi ke,
kie ajn ĝi estas sur la servilo,

237
00:11:59,900 --> 00:12:03,090
kopiu kaj algluu ĝin, esence,
en la pinto de via propra dosiero

238
00:12:03,090 --> 00:12:06,820
tiel ke ĉe tiu punkto en la rakonto,
linio 1, la resto de la programo

239
00:12:06,820 --> 00:12:11,651
povas ja uzi iun el la funkcioj
gxi, inter ili get_string.

240
00:12:11,651 --> 00:12:13,650
Do mi tuj ignori
la resto de tiuj eraroj,

241
00:12:13,650 --> 00:12:17,190
ĉar mi ja suspektas ke nur
la unua vere gravis.

242
00:12:17,190 --> 00:12:20,780
Kaj mi tuj iros antaŭen kaj rerun,
post savi mian dosieron fari buggy1.

243
00:12:20,780 --> 00:12:22,580
Kaj voilà, ĝi faris laboron.

244
00:12:22,580 --> 00:12:29,200
Kaj se mi faras ./buggy1 kaj entajpu, cxar
Ekzemple, Zamyla, mi nun ricevos saluton,

245
00:12:29,200 --> 00:12:32,000
Zamyla, anstataŭ saluton, mondo.

246
00:12:32,000 --> 00:12:32,550
>> Bone.

247
00:12:32,550 --> 00:12:35,890
Tial la takeaways tie tiam devas,
unu, provu kolektu kiom vi povas

248
00:12:35,890 --> 00:12:39,140
el la erarmesaĝojn sole, rigardante
en iu el la rekoneblaj vortoj.

249
00:12:39,140 --> 00:12:43,070
Barante ke uzu help50 po
la problemo aro specifo.

250
00:12:43,070 --> 00:12:46,500
Barante ke ankaŭ ĉiam aspektas
ĉe la supro eraro nur, almenaŭ

251
00:12:46,500 --> 00:12:50,051
komence, por vidi kion informo
ĝi efektive povus cedi.

252
00:12:50,051 --> 00:12:52,300
Sed rezultu ke la
eĉ pli funcionalidad konstruita

253
00:12:52,300 --> 00:12:55,030
en la CS50 biblioteko por helpi
vi frue en la semestro

254
00:12:55,030 --> 00:12:57,580
kaj frue en programado
eltrovi kio okazas erara.

255
00:12:57,580 --> 00:12:59,840
Do ni faru alian ekzemplon tie.

256
00:12:59,840 --> 00:13:04,350
Mi tuj nomas tiun buggy2, kiu,
denove, tuj estos mankhava eksteren

257
00:13:04,350 --> 00:13:05,650
de la pordego, por dezajno.

258
00:13:05,650 --> 00:13:09,980
>> Kaj mi tuj iros antaŭen
kaj do # include.

259
00:13:09,980 --> 00:13:12,580
Kaj tiam mi iros fari int main (void).

260
00:13:12,580 --> 00:13:14,840
Kaj tiam mi iros fari por buklo.

261
00:13:14,840 --> 00:13:16,690
Por (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i estas malpli ol aŭ egala al 10.

263
00:13:18,750 --> 00:13:24,260
i ++, kaj tiam en buklaj krampoj, mi tuj
presi nur hashtag simbolo tie

264
00:13:24,260 --> 00:13:25,920
kaj nova linio karaktero.

265
00:13:25,920 --> 00:13:29,220
>> Do mia intenco kun ĉi
programo estas tute simple

266
00:13:29,220 --> 00:13:33,150
persisti 10 fojojn
kaj sur ĉiu ripeto

267
00:13:33,150 --> 00:13:35,260
de tiu buklo ĉiufoje
tra la ciklo,

268
00:13:35,260 --> 00:13:37,660
elprinti hashtag,
etiketon, etiketon.

269
00:13:37,660 --> 00:13:40,480
Unu po linio, ĉar mi
havas la novan linion tie.

270
00:13:40,480 --> 00:13:42,787
Kaj memoras ke la por
buklo, po lasta week--

271
00:13:42,787 --> 00:13:44,620
kaj vi ricevos pli
konas la sintakson

272
00:13:44,620 --> 00:13:47,170
uzante ŝin kun praktiko
antaŭ long-- tio donas al mi

273
00:13:47,170 --> 00:13:49,740
variablon nomis i kaj fiksas ĝin al 0.

274
00:13:49,740 --> 00:13:52,650
>> Tio pliigas i sur
ĉiu ripeto de 1.

275
00:13:52,650 --> 00:13:54,940
Tial mi iras al 1 al 2 al 3.

276
00:13:54,940 --> 00:13:57,690
Kaj tiam ĉi tiu kondiĉo en la
mezo inter la punktokomoj

277
00:13:57,690 --> 00:14:03,010
iĝas kontrolis sur ĉiu ripeto fari
certa, ke ni estas ankoraŭ ene gamo.

278
00:14:03,010 --> 00:14:06,830
Do mi volas persisti 10 fojojn, do mi
havi ian tre intuicie ĝuste

279
00:14:06,830 --> 00:14:09,070
metu 10 kiel mia supera baro tie.

280
00:14:09,070 --> 00:14:14,310
>> Kaj tamen, kiam mi kuros ĉi, post
kompili ĝin kun ŝminko buggy2--

281
00:14:14,310 --> 00:14:15,440
kaj ĝi kompilas OK.

282
00:14:15,440 --> 00:14:17,980
Do mi ne havas
Sintakseraro tiu tempo.

283
00:14:17,980 --> 00:14:20,940
Lasu min nun
kaj kuri buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Kaj nun rulumu supren.

285
00:14:22,620 --> 00:14:24,890
Kaj mi pliigas
la grandeco de la fenestro.

286
00:14:24,890 --> 00:14:33,720
>> Mi ŝajnas havi 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Do ekzistas 11 hashtags, kvankam
Mi klare metita 10 ene de ĉi buklo.

288
00:14:38,891 --> 00:14:42,140
Nun, iuj el vi povus vidi tuj
kion la eraro estas ĉar ja tiu

289
00:14:42,140 --> 00:14:43,720
ne estas tre malfacile eraro fari.

290
00:14:43,720 --> 00:14:46,070
Sed estas tre komune
faris tre frue.

291
00:14:46,070 --> 00:14:49,820
>> Kion mi volas atentigi, tamen,
estas, kiel povus mi eltrovis tion?

292
00:14:49,820 --> 00:14:52,300
Nu, Ĝi rezultas ke
la CS50 biblioteko venas

293
00:14:52,300 --> 00:14:55,380
kun ne nur get_string kaj get_int
kaj get_float kaj aliaj funkcioj.

294
00:14:55,380 --> 00:14:59,980
Ĝi ankaŭ venas kun speciala funkcio
nomita eprintf, aŭ, eraro printf.

295
00:14:59,980 --> 00:15:03,270
Kaj ekzistas nur fari
ĝi iomete pli facila por vi

296
00:15:03,270 --> 00:15:06,310
kiam elpurigi vian kodon por ĝuste
presi erarmesagxon sur la ekrano

297
00:15:06,310 --> 00:15:07,850
kaj scii kie gxi estis.

298
00:15:07,850 --> 00:15:11,000
>> Do ekzemple, unu aferon mi povus
faru ĉi tie kun tiu funkcio estas this--

299
00:15:11,000 --> 00:15:20,230
eprintf, kaj tiam mi iros por antaŭeniri
kaj diri mi estas nun% i, backslash, n.

300
00:15:20,230 --> 00:15:22,330
Kaj mi tuj konekti la valoro de i.

301
00:15:22,330 --> 00:15:25,400
Kaj ĝis supro, ĉar tiu
estas en la CS50 biblioteko,

302
00:15:25,400 --> 00:15:27,580
Mi tuj iros antaŭen
kaj inkluzivi

303
00:15:27,580 --> 00:15:29,169
do mi havas aliron al ĉi tiu funkcio.

304
00:15:29,169 --> 00:15:31,460
Sed ni pripensu kion linio
9 supozas esti faranta.

305
00:15:31,460 --> 00:15:32,670
Mi tuj forviŝi tiun eventuale.

306
00:15:32,670 --> 00:15:34,670
Ĉi havas nenion komunan
kun mia komunajn celo.

307
00:15:34,670 --> 00:15:39,090
Sed eprintf, eraro printf, estas nur signifita
doni al mi iom diagnozaj informoj.

308
00:15:39,090 --> 00:15:42,460
Kiam mi kuros mia programo, mi volas
vidu ĉi sur la ekrano temporalmente

309
00:15:42,460 --> 00:15:44,550
tiel nur por kompreni
kio okazas.

310
00:15:44,550 --> 00:15:47,330
>> Kaj cetere, en ĉiu
iteracio tie de la linio 9

311
00:15:47,330 --> 00:15:49,260
Mi volas vidi, kio estas la valoro de i?

312
00:15:49,260 --> 00:15:50,290
Kio estas la valoro de i?

313
00:15:50,290 --> 00:15:51,280
Kio estas la valoro de i?

314
00:15:51,280 --> 00:15:55,650
Kaj, espereble, mi devus nur
vidi ke mesaĝo, ankaŭ 10 fojojn.

315
00:15:55,650 --> 00:15:57,780
>> Do lasu min antaŭeniri kaj
rekompili mian programon,

316
00:15:57,780 --> 00:15:59,905
kiel mi devas fari ajnan tempon
Mi fari ŝanĝon. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Kaj now-- OK.

319
00:16:03,640 --> 00:16:04,820
Ekzistas multe pli okazas.

320
00:16:04,820 --> 00:16:07,610
Do lasu min rulumi supren en
ankoraŭ pli granda fenestro.

321
00:16:07,610 --> 00:16:10,190
>> Kaj vi vidos ke ĉiu el
la hashtags estas ankoraŭ presi.

322
00:16:10,190 --> 00:16:15,270
Sed intere ĉiu el ili estas nun ĉi
diagnozaj eligo formatitan jene.

323
00:16:15,270 --> 00:16:17,960
La nomo de mia programo tie estas buggy2.

324
00:16:17,960 --> 00:16:20,432
La nomo de la dosiero buggy2.c.

325
00:16:20,432 --> 00:16:24,080
La numero de linioj de kiu
tio estis presita estas linio 9.

326
00:16:24,080 --> 00:16:27,500
Kaj tiam dekstre de kiu estas la
erarmesaĝo ke mi atendis.

327
00:16:27,500 --> 00:16:30,701
>> Kaj kio estas agrable pri tio estas ke
nun mi ne devas nepre kalkuli

328
00:16:30,701 --> 00:16:32,200
en mia kapo: kion mia programo faras.

329
00:16:32,200 --> 00:16:34,240
Mi povas vidi ke en la
unua ripeto i estas 0,

330
00:16:34,240 --> 00:16:39,420
tiam 1, tiam 2, tiam 3, tiam 4, tiam
5, tiam 6, tiam 7, tiam 8, tiam 9, tiam

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Do atendi minuton.

333
00:16:42,050 --> 00:16:43,740
Kio okazas ĉi tie?

334
00:16:43,740 --> 00:16:48,190
Mi ankoraŭ ŝajnas esti rakonti
kiel intencita ĝis 10.

335
00:16:48,190 --> 00:16:50,550
>> Sed kie mi komencu?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Do 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- la 11a fingro

338
00:16:58,040 --> 00:16:59,990
estas indika de la problemo.

339
00:16:59,990 --> 00:17:02,850
Mi ŝajnas esti rakontita
malĝuste en mia banto.

340
00:17:02,850 --> 00:17:06,599
Anstataŭ iri 10 ripetoj,
Mi startanta je 0,

341
00:17:06,599 --> 00:17:09,550
Mi finiĝante ĉe kaj tra 10.

342
00:17:09,550 --> 00:17:12,030
Sed ĉar, kiel komputilo,
Mi startanta nombrado ĉe 0,

343
00:17:12,030 --> 00:17:15,250
Mi devas rakonti supren
al, sed ne tra 10.

344
00:17:15,250 --> 00:17:18,510
>> Kaj tial la solvon, mi fine
rimarkis tie, estas unu el du aferoj.

345
00:17:18,510 --> 00:17:22,430
Mi povis tre simple diri
rakonti ĝis malpli ol 10.

346
00:17:22,430 --> 00:17:27,260
Do 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, kiu estas ja ĝusta,

347
00:17:27,260 --> 00:17:28,900
kvankam ĝi sonas iom malĝusta.

348
00:17:28,900 --> 00:17:35,070
Aŭ mi povus fari malpli ol aŭ egala
9, kiam mi komencas je 0.

349
00:17:35,070 --> 00:17:40,056
Aŭ se vi vere ne ŝatas tion, vi
povas kalkuli tra 10 sed komencu je 1.

350
00:17:40,056 --> 00:17:41,680
Sed denove, ĉi nur ne ke komuna.

351
00:17:41,680 --> 00:17:43,977
En programming-- kvankam
Ne tiel en Scratch--

352
00:17:43,977 --> 00:17:45,810
sed en programado en
C kaj aliaj lingvoj,

353
00:17:45,810 --> 00:17:47,670
kiel JavaScript kaj
Python kaj aliaj, estas

354
00:17:47,670 --> 00:17:49,880
nur tre komuna por
nia diskuto de duuma

355
00:17:49,880 --> 00:17:53,450
simple komenci kalkulon je la
plej malalta nombro povas, kio estas 0.

356
00:17:53,450 --> 00:17:53,950
Bone.

357
00:17:53,950 --> 00:17:55,160
Do jen eprintf.

358
00:17:55,160 --> 00:17:58,600
Kaj denove, nun ke mi eltrovis mian
problemo, kaj mi tuj iros reen al 0

359
00:17:58,600 --> 00:18:01,470
tra malpli ol 10, mi tuj
iru kaj forviŝi eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Ĝi ne devus esti tie, kiam mi
ekspedi mia kodo aŭ submetiĝi mian kodo

361
00:18:04,580 --> 00:18:05,800
aŭ montri ĝin al iu alia.

362
00:18:05,800 --> 00:18:07,980
Ĝi estas vere nur signifis
esti uzita temporalmente.

363
00:18:07,980 --> 00:18:11,650
Sed nun mi fiksis tiun
aparta problemo ankaŭ.

364
00:18:11,650 --> 00:18:16,780
>> Nu, ni faru unu pli ekzemplo tie
ke mi tuj vipi supren jene.

365
00:18:16,780 --> 00:18:22,850
Mi tuj iros antaŭen kaj
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
Kaj mi tuj iros antaŭen
kaj #include.

367
00:18:25,580 --> 00:18:29,030
>> Kaj mi tuj savi
dosiero kiel buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Kaj mi tuj iros antaŭen
kaj deklari int main (void).

369
00:18:31,740 --> 00:18:34,186
Kaj tiam ene de tie
Mi tuj faros int i _ -

370
00:18:34,186 --> 00:18:36,435
Mi volas implementar programon
kun get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Tio ne estas funkcio kiu ekzistas ankoraŭ.

373
00:18:40,770 --> 00:18:42,870
Do ni tuj apliki
en nur momento.

374
00:18:42,870 --> 00:18:45,541
Sed ni tuj vidos kial
ĝi estas kalesxon unue enirpermesilo.

375
00:18:45,541 --> 00:18:47,290
Kaj unufoje mi akiris
int de la uzanto,

376
00:18:47,290 --> 00:18:53,365
Mi simple tuj presi% i estas negativa
entjera, backslash, n, komo, i.

377
00:18:53,365 --> 00:18:55,240
Alivorte, ĉiuj mi
volas tiun programon fari

378
00:18:55,240 --> 00:18:58,000
estas atingi negativan int de
la uzanto kaj tiam presi

379
00:18:58,000 --> 00:18:59,980
ke tia kaj tia estas negativa int.

380
00:18:59,980 --> 00:19:02,080
>> Nun mi devas plenumi la funkcion.

381
00:19:02,080 --> 00:19:05,740
Tial poste en mian dosieron, mi tuj iros
antaŭeniri kaj deklari funkcio nomita

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - kaj ni
revenu al kion tiu linio signifas denove

383
00:19:10,670 --> 00:19:18,790
en moment-- int n; do-- do
la following-- printf n estas :.

384
00:19:18,790 --> 00:19:26,210
Kaj tiam mi iros fari n - get_int,
kaj fari ĉi dum n estas pli granda ol 0.

385
00:19:26,210 --> 00:19:28,310
Kaj tiam reveni n ;.

386
00:19:28,310 --> 00:19:31,730
>> Do ekzistas multe okazas en
tio sed neniu el kiu ni ne

387
00:19:31,730 --> 00:19:33,710
rigardi pasintsemajne, almenaŭ mallonge.

388
00:19:33,710 --> 00:19:36,980
Tiel sur linio 10 tie Mi deklarita
funkcio nomita get_negative_int,

389
00:19:36,980 --> 00:19:39,620
kaj mi metis (void), en
krampoj, la kialo estanta tiu

390
00:19:39,620 --> 00:19:40,950
ne prenas enigo.

391
00:19:40,950 --> 00:19:42,910
Mi ne pasante ion
al tiu funkcio.

392
00:19:42,910 --> 00:19:44,690
Mi nur nun io reprenos gxin.

393
00:19:44,690 --> 00:19:47,270
>> Kaj kion mi esperante
reiri estas entjero.

394
00:19:47,270 --> 00:19:50,040
Ne estas datumtipo en
C nomita negative_int.

395
00:19:50,040 --> 00:19:52,880
Ĝi simple int, do ĝi estas tuj
esti sur ni certigi

396
00:19:52,880 --> 00:19:55,340
ke la valoro kiu estas fakte
Revenita ne nur int

397
00:19:55,340 --> 00:19:56,380
sed estas ankaŭ negativaj.

398
00:19:56,380 --> 00:20:02,150
>> Sur linio 12 Mi deklaras variablon
nomis n kaj tial estas de tipo int.

399
00:20:02,150 --> 00:20:07,500
Kaj tiam en linio 13 tra 18 Mi
fari ion dum io estas vera.

400
00:20:07,500 --> 00:20:11,040
Mi tuj antaŭen kaj presi
n estas, dupunkto kaj tiam spaco,

401
00:20:11,040 --> 00:20:12,800
kiel prompto por la uzanto.

402
00:20:12,800 --> 00:20:16,410
>> Mi tiam nomante get_int kaj
stokante lia tn reveno valoro

403
00:20:16,410 --> 00:20:18,130
en tiu variablo n.

404
00:20:18,130 --> 00:20:22,600
Sed mi iros por daŭre fari
ĉi dum n estas pli granda ol 0.

405
00:20:22,600 --> 00:20:27,960
En aliaj vortoj, se la uzanto donas al mi
int kaj tiu nombro estas pli granda ol 0,

406
00:20:27,960 --> 00:20:31,180
ergo, pozitiva, mi tuj
simple observu reprompting la uzanto,

407
00:20:31,180 --> 00:20:37,160
teni reprompting, devigante ilin al
kunlaboru kaj donu al mi negativan int.

408
00:20:37,160 --> 00:20:41,640
>> Kaj unufoje n estas reale negative--
supozas la uzanto fine tipoj -50,

409
00:20:41,640 --> 00:20:46,710
tiam tiu dum buklo ne plu vera
ĉar -50 ne estas pli granda ol 0.

410
00:20:46,710 --> 00:20:51,140
Do ni rompi el tiu
buklo logike kaj reveni n.

411
00:20:51,140 --> 00:20:53,520
>> Sed ekzistas unu alia
kion mi devas fari.

412
00:20:53,520 --> 00:20:56,190
Kaj mi povas simple fari tion
per kopii kaj alglui

413
00:20:56,190 --> 00:20:58,540
unu linio de kodo ĉe la supro de la dosiero.

414
00:20:58,540 --> 00:21:01,630
Mi devas instrui Clang,
aŭ promesas Clang,

415
00:21:01,630 --> 00:21:04,630
eksplicite ke mi volas,
ja, iru kaj apliki

416
00:21:04,630 --> 00:21:06,020
tiu funkcio get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Ĝi nur povus esti pli malalta en la dosiero.

418
00:21:07,674 --> 00:21:09,840
Denove memoras ke Clang
legas aferojn supre sube,

419
00:21:09,840 --> 00:21:12,330
maldekstre dekstren, do vi ne povas
nomas funkcio se Clang

420
00:21:12,330 --> 00:21:15,330
ne scias ĝi tuj ekzistas.

421
00:21:15,330 --> 00:21:18,430
>> Nun, bedaŭrinde, tiu programo,
kiel kelkaj el vi eble rimarkis,

422
00:21:18,430 --> 00:21:19,590
Jam kalesxon.

423
00:21:19,590 --> 00:21:21,400
Lasu min antaŭeniri kaj fari buggy3.

424
00:21:21,400 --> 00:21:26,904
Ĝi kompilas, do mia problemo nun ne estas
sintaksa eraro, kiel teksta eraro,

425
00:21:26,904 --> 00:21:29,570
ĝi estas vere tuj esti logika
eraro kiun mi havas intence

426
00:21:29,570 --> 00:21:32,450
faris kiel ŝanco
paŝi tra kio okazas.

427
00:21:32,450 --> 00:21:35,540
>> Mi tuj iros antaŭen
nun kaj kuri buggy3.

428
00:21:35,540 --> 00:21:37,490
Kaj mi tuj iros
antaŭen kaj ne kunlabori.

429
00:21:37,490 --> 00:21:39,494
Mi tuj donos la numeron 1.

430
00:21:39,494 --> 00:21:41,410
Li ne ŝatis ĝin, do
ĝi instigante min.

431
00:21:41,410 --> 00:21:42,147
>> Kiom proksimume 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Neniu el tiuj laboras.

435
00:21:44,740 --> 00:21:46,890
Kiom proksimume -50?

436
00:21:46,890 --> 00:21:48,560
Kaj la programo ŝajnas funkcii.

437
00:21:48,560 --> 00:21:49,970
>> Lasu min provi ĝin refoje.

438
00:21:49,970 --> 00:21:53,400
Mi provu -1, ŝajnas funkcii.

439
00:21:53,400 --> 00:21:56,380
Mi provu -2, ŝajnas funkcii.

440
00:21:56,380 --> 00:21:59,640
Mi provu 0.

441
00:21:59,640 --> 00:22:01,684
Huh, jen malĝusta.

442
00:22:01,684 --> 00:22:03,350
Nun, ni estas iom pedanta tie.

443
00:22:03,350 --> 00:22:07,090
Sed estas ja la kazo ke 0
estas nek pozitiva nek negativa.

444
00:22:07,090 --> 00:22:11,150
Do la fakto ke mia programo estas
dirante ke 0 estas negativa entjero,

445
00:22:11,150 --> 00:22:12,820
tio ne teknike korekta.

446
00:22:12,820 --> 00:22:15,180
>> Nun, kial faras tion?

447
00:22:15,180 --> 00:22:16,270
Nu, ĝi povus esti evidenta.

448
00:22:16,270 --> 00:22:18,110
Kaj, efektive, la programo estas
intencita esti sufiĉe simplaj

449
00:22:18,110 --> 00:22:19,670
do ni havos ion esplori.

450
00:22:19,670 --> 00:22:25,870
>> Sed ni enkonduki trian depuración
teknikon nomita debug50.

451
00:22:25,870 --> 00:22:27,750
Do tiu estas programo
ke ni ĵus kreita

452
00:22:27,750 --> 00:22:30,770
tiu jaro nomita debug50
kiu permesos vin

453
00:22:30,770 --> 00:22:34,130
uzi kio nomiĝas korpigita
grafika erarserĉilo en CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Kaj erarserĉilo estas simple programo kiu
ĝenerale permesas kuri vian programon

455
00:22:38,400 --> 00:22:44,050
sed paŝon post paŝo post paŝo, linio
por linio por linio, paŭzante, ŝovas

456
00:22:44,050 --> 00:22:47,626
ĉirkaŭe kaj rigardis variabloj por ke
la programo ne nur blovi preter vi

457
00:22:47,626 --> 00:22:49,750
kaj rapide presi ion
aŭ ne presi ion.

458
00:22:49,750 --> 00:22:53,250
Ĝi donas al vi la ŝancon, ĉe
homaj rapido, interagi kun ĝi.

459
00:22:53,250 --> 00:22:55,470
>> Kaj por fari tion, vi
simple fari la sekvan.

460
00:22:55,470 --> 00:22:58,479
Post kompilado vian kodon,
kion mi jam faris, buggy3,

461
00:22:58,479 --> 00:23:00,020
Vi iru antaŭen kaj kuri debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Tiel kiel help50 havas vi kuros
help50 kaj tiam la komando,

464
00:23:06,760 --> 00:23:10,120
debug50 havas vi kuras debug50 kaj
tiam la nomo de la komando.

465
00:23:10,120 --> 00:23:14,440
>> Nun spekti kio okazas sur mia ekrano,
sur la dekstra flanko aparte.

466
00:23:14,440 --> 00:23:19,400
Kiam mi batis Run, ĉiuj
Subite tiu dekstra panelo

467
00:23:19,400 --> 00:23:20,419
malfermas sur la ekrano.

468
00:23:20,419 --> 00:23:22,210
Kaj ekzistas multe irante
sur unuavide.

469
00:23:22,210 --> 00:23:25,110
Sed estas ne tro
multajn zorgojn ankoraŭ.

470
00:23:25,110 --> 00:23:28,570
>> Tio montras min io
ke okazas interne de mia programo

471
00:23:28,570 --> 00:23:31,130
nun kaj tra tiuj
butonoj supren supro estas tiam

472
00:23:31,130 --> 00:23:35,910
permesi min paŝi tra mia kodo
finfine paŝon post paŝo post paŝo.

473
00:23:35,910 --> 00:23:37,140
Sed ne ĝuste nun.

474
00:23:37,140 --> 00:23:38,060
Rimarki kio okazas.

475
00:23:38,060 --> 00:23:40,600
En mia fina fenestro
Mi estanta instigita por n.

476
00:23:40,600 --> 00:23:44,560
Kaj mi tuj iros antaŭen kaj
kunlaboru tiu tempo kaj tajpu -1.

477
00:23:44,560 --> 00:23:48,770
Kaj kvankam iom crípticamente, -1
estas negativa entjero, kiel atendita.

478
00:23:48,770 --> 00:23:52,020
>> Kaj tiam infano finiĝis kun
statuso 0 GDBserver eliranta.

479
00:23:52,020 --> 00:23:55,180
GDB, GDB, estas la nomo
de la subesta softvaro

480
00:23:55,180 --> 00:23:56,620
kiu implementa ĉi erarserĉilo.

481
00:23:56,620 --> 00:24:00,500
Sed ĉiuj ĉi vere signifas, la erarserĉilo
foriris pro mia programo forlasis

482
00:24:00,500 --> 00:24:01,710
kaj ĉiuj estis bone.

483
00:24:01,710 --> 00:24:06,020
Se mi volas vere elpurigi mia programo,
Mi devas preventa diri debug50,

484
00:24:06,020 --> 00:24:08,920
kie mi volas komenci
tretante per mia kodo?

485
00:24:08,920 --> 00:24:11,750
>> Kaj eble la plej simpla formo
fari tion estas kiel sekvas.

486
00:24:11,750 --> 00:24:15,300
Se mi ŝvebi super la
defluilo de mia eldonisto tie,

487
00:24:15,300 --> 00:24:19,090
tiel vere nur en la ilobreto tie,
maldekstren de la linio numeron,

488
00:24:19,090 --> 00:24:21,870
Rimarku ke se mi simple alklaku
iam, mi metos iom ruĝa punkto.

489
00:24:21,870 --> 00:24:24,460
Kaj kiu iom ruĝa punkto,
kiel halta signo, signifas, hej,

490
00:24:24,460 --> 00:24:29,430
debug50, paŭzo ekzekuto de mia kodo
Dekstre kiam mi kuros ĉi programo.

491
00:24:29,430 --> 00:24:30,260
>> Do ni faru tion.

492
00:24:30,260 --> 00:24:37,340
Lasu min antaŭeniri kaj kuri mia programo
denove kun debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Kaj nun, avizo, io
malsama okazis.

494
00:24:40,110 --> 00:24:42,440
Mi ne estanta instigita
ankoraux en mia fina fenestro

495
00:24:42,440 --> 00:24:45,430
por nenio, ĉar mi ne
alveninta ankoraux en mia programo.

496
00:24:45,430 --> 00:24:47,950
Rimarku ke la linio 8
kiu nun reliefigis,

497
00:24:47,950 --> 00:24:51,720
kaj tie estas iom sago ĉe
maldekstra parolo vi paŭzis tie.

498
00:24:51,720 --> 00:24:55,030
Ĉi tiu linio de kodo, linio
8, ankoraŭ ne ekzekutitaj.

499
00:24:55,030 --> 00:24:58,940
>> Kaj kio estas kurioza, se mi rigardas
super tie sur la dekstra flanko,

500
00:24:58,940 --> 00:25:03,530
rimarki ke i estas loka
variablo, loka en la senco

501
00:25:03,530 --> 00:25:05,450
ke ĝi estas ene la nuna funkcio.

502
00:25:05,450 --> 00:25:08,920
Kaj lia valoro, ŝajne defaŭlte,
kaj ia oportune, estas 0.

503
00:25:08,920 --> 00:25:10,260
Sed mi ne tajpi 0.

504
00:25:10,260 --> 00:25:13,410
Ke nur hazarde estas lia
defaŭlta valoro nuntempe.

505
00:25:13,410 --> 00:25:15,490
>> Do lasu min antaŭeniri kaj fari tion nun.

506
00:25:15,490 --> 00:25:18,680
Lasu min antaŭeniri kaj sur
la supro tie, mi

507
00:25:18,680 --> 00:25:20,970
tuj iros antaŭen kaj
klaku ĉi unua ikono kiu

508
00:25:20,970 --> 00:25:25,360
signifas paŝon super kiu signifas ne skip
ĝi sed transpaŝas tiun linion de kodo,

509
00:25:25,360 --> 00:25:27,770
ekzekuti ĝin survoje.

510
00:25:27,770 --> 00:25:30,710
>> Kaj nun, rimarki, mia
prompto ĵus ŝanĝis.

511
00:25:30,710 --> 00:25:31,380
Kial estas tio?

512
00:25:31,380 --> 00:25:33,639
Mi rakontis al debug50,
kuri ĉi tiu linio de kodo.

513
00:25:33,639 --> 00:25:34,930
Kion ĉi tiu linio de kodo fari?

514
00:25:34,930 --> 00:25:35,960
Instigas min por int.

515
00:25:35,960 --> 00:25:36,460
BONE.

516
00:25:36,460 --> 00:25:37,400
Lasu min kunlabori.

517
00:25:37,400 --> 00:25:41,340
Lasu min nun kaj tajpu -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Kaj nun rimarkas kion ŝanĝis.

519
00:25:42,920 --> 00:25:46,060
Sur la dekstra flanko,
mia loka variablo i

520
00:25:46,060 --> 00:25:48,200
estas indikita kiel estante -1 nun.

521
00:25:48,200 --> 00:25:49,810
Kaj ĝi estas ankoraŭ de tipo int.

522
00:25:49,810 --> 00:25:53,102
>> Kaj avizo ankaŭ mia tn
nomas pilo kien mi paŭzi?

523
00:25:53,102 --> 00:25:54,810
Ni parolos pli pri
tio en la estonteco.

524
00:25:54,810 --> 00:25:58,620
Sed la alvoko pilo nur rilatas al kio
funkcioj estas nuntempe en moviĝo.

525
00:25:58,620 --> 00:26:00,040
Nun ĝi estas nur ĉefaj.

526
00:26:00,040 --> 00:26:03,590
Kaj nun la sola loka
variablo estas i kun valoro de 1.

527
00:26:03,590 --> 00:26:09,840
>> Kaj kiam mi finfine transpaŝas tiun linion
tie, kun tiu sama ikono ĉe supra dekstra,

528
00:26:09,840 --> 00:26:11,410
-1 Estas negativa entjero.

529
00:26:11,410 --> 00:26:13,580
Nun ĝi paŭzante dum tiu krispa krampoj.

530
00:26:13,580 --> 00:26:14,740
Ni lasu lin fari lian aferon.

531
00:26:14,740 --> 00:26:17,300
Mi transpaŝas tiun linion, kaj voila.

532
00:26:17,300 --> 00:26:20,240
>> Do ne cxio, kion terure
iluminanta tamen,

533
00:26:20,240 --> 00:26:23,550
sed lasu min paŭzo
kaj pensi tra logike

534
00:26:23,550 --> 00:26:24,870
kion tiu programo faras.

535
00:26:24,870 --> 00:26:26,890
Sed tio ne estis la erara kazo.

536
00:26:26,890 --> 00:26:28,510
Ni faru ĉi denove jene.

537
00:26:28,510 --> 00:26:31,340
>> Mi tuj lasos ke Haltpunkto
sur la linio 8 de la ruĝa punkto.

538
00:26:31,340 --> 00:26:32,830
Mi tuj rerun debug50.

539
00:26:32,830 --> 00:26:34,400
Ĝi estas aŭtomate paŭzis tie.

540
00:26:34,400 --> 00:26:37,660
Sed ĉifoje, anstataŭ
tretante sur tiu linio,

541
00:26:37,660 --> 00:26:42,290
mi vere iras ene de
get_negative_int kaj diveni,

542
00:26:42,290 --> 00:26:45,530
kial akcepti 0 kiel validan respondon?

543
00:26:45,530 --> 00:26:47,990
>> Do anstataŭ klakanta Paŝo Super.

544
00:26:47,990 --> 00:26:50,630
Mi tuj iros antaŭen
kaj klaku Step Into.

545
00:26:50,630 --> 00:26:54,030
Kaj rimarki ke la linio 8 jen
nun emfazita nun subite

546
00:26:54,030 --> 00:26:56,900
iĝas linio 17.

547
00:26:56,900 --> 00:26:59,947
>> Nun, ĝi ne estas ke la erarserĉilo
jam saltis linioj 14 kaj 15 kaj 16.

548
00:26:59,947 --> 00:27:01,780
Ĝi simple estas nenio
montri vin tie.

549
00:27:01,780 --> 00:27:04,050
Tiuj estas nur deklarante variabloj,
kaj tiam tie estas la vorto u

550
00:27:04,050 --> 00:27:05,390
kaj tiam malfermita krispa streĉa.

551
00:27:05,390 --> 00:27:09,227
La nura funkcia linio kiu estas
sukaj vere estas ĉi tie, 17.

552
00:27:09,227 --> 00:27:11,060
Kaj tio estas kie ni havas
paŭzis aŭtomate.

553
00:27:11,060 --> 00:27:13,870
>> Do printf ( "n.is:") ;, tiel
ke ne okazis ankoraŭ.

554
00:27:13,870 --> 00:27:18,250
Do ni iru antaŭen kaj klaku Paŝo Super.

555
00:27:18,250 --> 00:27:20,326
Nun mia prompto ja
ŝanĝis al ( 'n estas: ").

556
00:27:20,326 --> 00:27:22,450
Nun get_int, mi ne tuj
tedi tretante en,

557
00:27:22,450 --> 00:27:24,750
ĉar tiu funkcio estis
faritaj de CS50 en la Biblioteko.

558
00:27:24,750 --> 00:27:25,750
Ĝi estas supozeble ĝusta.

559
00:27:25,750 --> 00:27:28,440
>> Do mi tuj iros antaŭen kaj
ia kunlabori donante lin

560
00:27:28,440 --> 00:27:30,590
int, sed ne negativa int.

561
00:27:30,590 --> 00:27:32,870
Do lasu min antaŭeniri kaj batis 0.

562
00:27:32,870 --> 00:27:39,460
Kaj nun kio okazas ĉi tie
kiam mi akiras malsupren al linio 21?

563
00:27:39,460 --> 00:27:40,890
Mi ne ripetis denove.

564
00:27:40,890 --> 00:27:43,320
Ne ŝajnas esti ŝtopita en tiu ciklo.

565
00:27:43,320 --> 00:27:45,990
Alivorte, tiu flava
trinkejo ne plu iri ĉirkaŭe,

566
00:27:45,990 --> 00:27:47,130
kaj ĉirkaŭe, kaj ĉirkaŭe.

567
00:27:47,130 --> 00:27:48,340
>> Nun, kial do?

568
00:27:48,340 --> 00:27:49,920
Nu, n, kio estas n nun?

569
00:27:49,920 --> 00:27:53,280
Mi povas rigardi la loka
variablojn en la erarserĉilo.

570
00:27:53,280 --> 00:27:53,816
n estas 0.

571
00:27:53,816 --> 00:27:55,190
Bone, kio estis mia kondiĉo?

572
00:27:55,190 --> 00:27:58,700
>> 20-- linio 20 estas, nu,
0 estas pli granda ol 0.

573
00:27:58,700 --> 00:27:59,500
Tio ne veras.

574
00:27:59,500 --> 00:28:01,020
0 ne estas pli granda ol 0.

575
00:28:01,020 --> 00:28:02,820
Do mi ekis de tiu.

576
00:28:02,820 --> 00:28:06,370
>> Kaj tial estas kial la linio
21, se mi efektive daŭrigi,

577
00:28:06,370 --> 00:28:10,370
Mi tuj revenos 0, eĉ
kvankam mi malsxatas 0

578
00:28:10,370 --> 00:28:12,484
kiel ne reale esti negativa.

579
00:28:12,484 --> 00:28:14,650
Do nun, mi ne vere eĉ
zorgi pri la erarserĉilo.

580
00:28:14,650 --> 00:28:16,900
Got ĝin, mi ne bezonas
scias kion pli daŭriĝas.

581
00:28:16,900 --> 00:28:19,233
>> Do mi tuj iros antaŭen kaj
simple alklaku la Play butonon,

582
00:28:19,233 --> 00:28:20,240
Kaj gxi finas tion.

583
00:28:20,240 --> 00:28:23,440
Nun, mi rimarkis ke mia
cimo estas ŝajne sur linio 20.

584
00:28:23,440 --> 00:28:25,160
Jen mia logika eraro.

585
00:28:25,160 --> 00:28:28,100
>> Do kion mi volas
fari ŝanĝi tion?

586
00:28:28,100 --> 00:28:32,500
Se la problemo estas ke mi ne
kaptante 0, estas nur logika eraro.

587
00:28:32,500 --> 00:28:35,910
Kaj mi povas diri dum n estas
pli granda ol aŭ egala al 0,

588
00:28:35,910 --> 00:28:38,330
teni instigante la uzanto denove kaj denove.

589
00:28:38,330 --> 00:28:41,050
>> Do, denove, simpla eraro, eble
eĉ evidenta, kiam vi vidis min

590
00:28:41,050 --> 00:28:42,410
skribi ĝin nur kelkaj minutoj.

591
00:28:42,410 --> 00:28:44,570
Sed la takeaway tie
estas ke kun debug 50,

592
00:28:44,570 --> 00:28:46,850
kaj kun debugging
programaro pli ĝenerale,

593
00:28:46,850 --> 00:28:51,370
vi havas tiun novan trovita povon
trairu vian propran kodon, rigardu

594
00:28:51,370 --> 00:28:55,590
tra kiuj dekstren panelo kio
via variabloj valoroj.

595
00:28:55,590 --> 00:28:57,700
Do vi ne nepre
devas uzi ion

596
00:28:57,700 --> 00:29:00,630
kiel vi eprintf presi tiujn valorojn.

597
00:29:00,630 --> 00:29:04,430
Vi povas fakte vidi ilin
vide sur la ekrano.

598
00:29:04,430 --> 00:29:08,920
>> Nun, ekster tiu, ĝi valoras notanta
ke estas alia tekniko kiu estas

599
00:29:08,920 --> 00:29:09,890
fakte super komuna.

600
00:29:09,890 --> 00:29:13,120
Kaj vi eble miras kial tiu malgranda
ulon tie estis sidantaj sur la scenejo.

601
00:29:13,120 --> 00:29:16,490
Do ekzistas tiu tekniko, ĝenerale
konata kiel kaŭĉuko anaso depuración,

602
00:29:16,490 --> 00:29:18,786
kiu vere estas nur
testamento al la fakto

603
00:29:18,786 --> 00:29:20,660
ke ofte kiam programistoj
skribas kodo,

604
00:29:20,660 --> 00:29:22,650
ili ne estas nepre
kunlabori kun aliaj,

605
00:29:22,650 --> 00:29:24,030
aŭ labori en komuna medio.

606
00:29:24,030 --> 00:29:25,050
>> Ili estas speco de hejme.

607
00:29:25,050 --> 00:29:25,910
Eble estas malfrua nokto.

608
00:29:25,910 --> 00:29:28,190
Ili provas figuro
el iuj cimoj en ilia kodo.

609
00:29:28,190 --> 00:29:29,330
Kaj ili estas simple ne vidas.

610
00:29:29,330 --> 00:29:30,329
>> Kaj ekzistas neniu kompano.

611
00:29:30,329 --> 00:29:31,250
Ne ekzistas TF.

612
00:29:31,250 --> 00:29:32,680
Ne ekzistas CA ĉirkaŭe.

613
00:29:32,680 --> 00:29:36,440
Ĉiuj ili havas sur sia breto
Estas ĉi tiu malgranda kaŭĉuko Ducky.

614
00:29:36,440 --> 00:29:39,030
>> Kaj tiel kaŭĉuko anaso depuración
Estas ĝuste tiu invito

615
00:29:39,030 --> 00:29:42,780
pensi pri io tiel malsaĝa
kiel tion kiel reala estaĵo,

616
00:29:42,780 --> 00:29:46,940
kaj efektive iradas tra via kodo
parole al tiu senviva objekto.

617
00:29:46,940 --> 00:29:49,230
Do, ekzemple, se
tio estas mia ekzemplo here--

618
00:29:49,230 --> 00:29:52,470
kaj memoras ke frue
la problemo estis tiu,

619
00:29:52,470 --> 00:29:58,140
se mi forigas tiun unuan linion de kodo,
kaj mi iras antaŭen kaj fari kalesxo 0 denove,

620
00:29:58,140 --> 00:30:01,220
memoras ke mi havis tiujn
erarmesaĝojn tie.

621
00:30:01,220 --> 00:30:05,997
Do la ideo tie, ridindaj se mi
sentas en la momento fari ĉi publike,

622
00:30:05,997 --> 00:30:06,580
estas tiu eraro.

623
00:30:06,580 --> 00:30:10,910
>> Bone, do mia problemo estas ke mi havas
implicite deklaris biblioteko funkcio.

624
00:30:10,910 --> 00:30:12,610
Kaj ke biblioteko funkcio printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, deklari
memorigas min de prototipoj.

626
00:30:15,290 --> 00:30:18,930
>> Tio signifas mi devas reale
diru la tradukilo anticipe kion

627
00:30:18,930 --> 00:30:19,980
la funkcio aspektas.

628
00:30:19,980 --> 00:30:20,930
Atendu minuton.

629
00:30:20,930 --> 00:30:23,580
Mi ne havis normon io.h.

630
00:30:23,580 --> 00:30:24,530
Dankegon.

631
00:30:24,530 --> 00:30:27,330
>> Do ĝuste ĉi procezo of-- vin
ne bezonas efektive havas anaso.

632
00:30:27,330 --> 00:30:29,819
Sed tiu ideo de marŝi
mem, per viaj propraj kodo

633
00:30:29,819 --> 00:30:31,610
por ke vi eĉ aŭdas
mem, por ke vi

634
00:30:31,610 --> 00:30:35,620
realigi preterlasoj en via propra
rimarkoj, estas ĝenerale la ideo.

635
00:30:35,620 --> 00:30:38,910
>> Kaj, eble pli logike, ne tiel
multe kun tiu sed la pli implikitaj

636
00:30:38,910 --> 00:30:44,220
ekzemple ni ĵus faris en kalesxo 3.c,
vi iradu mem tra ĝi

637
00:30:44,220 --> 00:30:45,310
jene.

638
00:30:45,310 --> 00:30:49,190
Do bone, kaŭĉuko
Ducky, DDB, se vi volas.

639
00:30:49,190 --> 00:30:52,350
Tie ni havas en mia ĉefa funkcio,
Mi vokas akiri negativan int.

640
00:30:52,350 --> 00:30:54,660
>> Kaj mi estas akiranta la reveno valoro.

641
00:30:54,660 --> 00:31:00,410
Mi stokante ĝin en la maldekstra flanko
sur linio 8 en variablo vokis mi.

642
00:31:00,410 --> 00:31:02,380
Okej, sed atendu, kiel faris
ke atingi tiun valoron?

643
00:31:02,380 --> 00:31:04,130
Lasu min rigardi la funkcio en linio 12.

644
00:31:04,130 --> 00:31:05,760
>> En linio 12, ni havas atingi negativan int.

645
00:31:05,760 --> 00:31:08,190
Ne prenas ajnan enigoj,
ne revenos int, OK.

646
00:31:08,190 --> 00:31:10,929
Mi deklaras sur linio 14 variablon n.

647
00:31:10,929 --> 00:31:12,220
Ĝi tuj stoki entjero.

648
00:31:12,220 --> 00:31:13,760
Tion mi volas.

649
00:31:13,760 --> 00:31:18,480
>> Do faru la sekvajn dum n is-- lasu
mi malfari kion la solvon mi jam faris.

650
00:31:18,480 --> 00:31:22,710
Do dum n estas pli granda ol
0, presi n estas, OK.

651
00:31:22,710 --> 00:31:25,170
Kaj tiam voki akiri int stokitaj en n.

652
00:31:25,170 --> 00:31:30,160
Kaj tiam kontrolu se n estas 0,
n estas not-- tie ĝi estas.

653
00:31:30,160 --> 00:31:31,910
Do, denove, vi ne
bezonas la reala anaso.

654
00:31:31,910 --> 00:31:35,650
Sed nur irante mem per
vian kodo kiel intelekta ekzerco

655
00:31:35,650 --> 00:31:37,720
ofte helpas vin
rimarkas kio okazas,

656
00:31:37,720 --> 00:31:41,170
kontraste al simple fari ion
tiel, rigardante la ekrano,

657
00:31:41,170 --> 00:31:43,720
kaj ne parolas mem per
ĝin, kiu honeste ne

658
00:31:43,720 --> 00:31:46,270
preskaŭ tiel efika tekniko.

659
00:31:46,270 --> 00:31:48,620
Tiel tie vi havas ĝin, kiel
nombro de malsamaj teknikoj

660
00:31:48,620 --> 00:31:52,102
cxar vere elpurigi vian kodon
kaj riprocxante, ĉiuj el kiuj

661
00:31:52,102 --> 00:31:54,810
devus esti iloj en via ilaro
por ke vi ne malfrunokte,

662
00:31:54,810 --> 00:31:57,660
speciale, vi estas en la manĝoĉambro
salonoj, aŭ ĉe oficejo horoj,

663
00:31:57,660 --> 00:32:00,368
batante vian kapon kontraŭ la
muro, klopodante solvi iun problemon.

664
00:32:00,368 --> 00:32:02,020
Rimarkas ke estas programaro iloj.

665
00:32:02,020 --> 00:32:03,720
Ekzistas kaŭĉuko anaso iloj.

666
00:32:03,720 --> 00:32:09,630
Kaj ekzistas tuta personaro de
apogas atendanta helpi.

667
00:32:09,630 --> 00:32:13,120
>> Tial nun, vorto pri la problemo
aroj, kaj sur kio ni estas esperantaj vi

668
00:32:13,120 --> 00:32:15,620
forlasi ilin, kaj kiel
ni iros sur taksi.

669
00:32:15,620 --> 00:32:17,680
Po la kurso Syllabus,
CS50 problemo aroj

670
00:32:17,680 --> 00:32:22,320
estas taksitaj sur kvar primaraj aksoj, tiel
al speak-- amplekso, korekteco, dezajno,

671
00:32:22,320 --> 00:32:23,060
kaj stilo.

672
00:32:23,060 --> 00:32:25,910
Kaj amplekso nur rilatas al kiom
de la peco vi mordis ekstere?

673
00:32:25,910 --> 00:32:28,080
Kiom multe de problemo vi provis?

674
00:32:28,080 --> 00:32:30,110
Kion nivelo de penado
ĉu vi aperos?

675
00:32:30,110 --> 00:32:35,750
>> Praveco estas, ĉu la programo laboro kiel
ĝi estas supozeble por CS50 specifo

676
00:32:35,750 --> 00:32:38,640
kiam vi provizis certa enigoj
aŭ certaj eligoj revenis?

677
00:32:38,640 --> 00:32:41,130
Dezajno estas la plej subjektiva ili.

678
00:32:41,130 --> 00:32:43,360
Kaj ĝi estas la unu kiu volas
preni la plej longan lerni

679
00:32:43,360 --> 00:32:47,220
kaj la plej longa instrui, en
kiom ĝi bolas malsupren al,

680
00:32:47,220 --> 00:32:49,530
kiel bone skribita estas via kodo?

681
00:32:49,530 --> 00:32:52,920
>> Ĝi estas unu afero al simple presi la korekta
eliroj aŭ reveni dekstren valoroj.

682
00:32:52,920 --> 00:32:55,400
Sed vi faras lin kiel
kompetente kiel ebla?

683
00:32:55,400 --> 00:32:58,210
Vi faras lin dividi
kaj konkeri, aŭ duuma

684
00:32:58,210 --> 00:33:01,500
serĉo kiel ni baldaŭ vidos, ke ni faris
du semajnoj kun la telefono libro?

685
00:33:01,500 --> 00:33:04,670
Ĉu estas pli bone manieroj solvi la
problemo ol vi nun havas tie?

686
00:33:04,670 --> 00:33:06,380
Ke estas ŝanco por pli bona dezajno.

687
00:33:06,380 --> 00:33:08,530
>> Kaj tiam style-- kiom
bela estas via kodo?

688
00:33:08,530 --> 00:33:12,370
Vi rimarkos ke mi estas sufiĉe
aparta pri deŝovante mia kodo,

689
00:33:12,370 --> 00:33:15,300
kaj certigante mian variabloj
estas prudente nomita. n,

690
00:33:15,300 --> 00:33:19,660
dum mallonga, estas bona nomo por
nombro, i por kalkula entjero,

691
00:33:19,660 --> 00:33:20,727
s por ŝnuro.

692
00:33:20,727 --> 00:33:22,560
Kaj ni povas havi plu
variablo nomoj stilo.

693
00:33:22,560 --> 00:33:25,500
Stilo estas nur kiel bona
faras vian kodo aspektas?

694
00:33:25,500 --> 00:33:26,600
Kaj kiel legebla estas?

695
00:33:26,600 --> 00:33:29,650
>> Kaj dum tempo, kion via TAS
kaj TFS faros en la kurso

696
00:33:29,650 --> 00:33:31,870
estas provizi vin kun tio
ia kvalita sugestoj

697
00:33:31,870 --> 00:33:34,330
tiel ke vi ricevas bone
ĉe tiuj diversaj aspektoj.

698
00:33:34,330 --> 00:33:37,510
Kaj en terminoj de kiel ni
taksi ĉiu de ĉi tiuj aksoj,

699
00:33:37,510 --> 00:33:40,080
ĝi estas tipe kun tre malmultaj
siteloj por ke vi, ĝenerale,

700
00:33:40,080 --> 00:33:41,680
akiri senton de kiom bone vi faras.

701
00:33:41,680 --> 00:33:45,680
Kaj cetere, se vi ricevas poentaron sur
neniu el tiuj axes-- korektecon dezajno

702
00:33:45,680 --> 00:33:49,659
kaj stilo especially-- tiu numero
ĝenerale estas inter 1 kaj 5.

703
00:33:49,659 --> 00:33:52,450
Kaj, laŭlitere, se vi fariĝas
3-a ĉe la komenco de la semestro,

704
00:33:52,450 --> 00:33:53,977
tio estas tre bona afero.

705
00:33:53,977 --> 00:33:55,810
Ĝi signifas ke estas ankoraŭ
spaco por plibonigo,

706
00:33:55,810 --> 00:33:58,490
kion vi esperas en
prenante klasoj unuafoje.

707
00:33:58,490 --> 00:34:01,820
Estas espereble iuj iom de plafono
al kiuj vi aspiras atingi.

708
00:34:01,820 --> 00:34:03,970
Kaj tiel atingi 3 de sur
la unuaj pecoj,

709
00:34:03,970 --> 00:34:06,550
se ne iuj 2-a kaj 4-a,
estas ja bona afero.

710
00:34:06,550 --> 00:34:08,880
Ĝi estas bone ene gamo,
bone ene atendojn.

711
00:34:08,880 --> 00:34:11,421
>> Kaj se via menso estas kuradanta, atendu
minuto, tri el kvin.

712
00:34:11,421 --> 00:34:12,620
Ke estas vere 6 el 10.

713
00:34:12,620 --> 00:34:13,560
Tio 60%.

714
00:34:13,560 --> 00:34:14,830
Mia Dio, jen F.

715
00:34:14,830 --> 00:34:15,870
>> Ĝi ne estas.

716
00:34:15,870 --> 00:34:17,600
Ĝi ne estas, fakte, ke.

717
00:34:17,600 --> 00:34:22,710
Prefere, ĝi estas ŝanco por plibonigi
super la kurso de la semestro.

718
00:34:22,710 --> 00:34:25,580
Kaj se vi fariĝas iom
Poors, tiuj estas ŝanco

719
00:34:25,580 --> 00:34:29,199
utiligi oficejo horoj,
certe sekcioj kaj aliaj rimedoj.

720
00:34:29,199 --> 00:34:32,840
>> Bona estas ŝanco, vere,
esti fiera de kiom multe vi havas

721
00:34:32,840 --> 00:34:34,520
transiris la kurson de la semestro.

722
00:34:34,520 --> 00:34:38,199
Do realigi, se nenio
alie, tri estas bona.

723
00:34:38,199 --> 00:34:40,179
Kaj ĝi permesas spacon por kresko super tempo.

724
00:34:40,179 --> 00:34:43,090
>> Kiel al kiel tiuj aksoj estas
pezita, realisme vi

725
00:34:43,090 --> 00:34:46,745
tuj pasas plej parton de via tempo ricevas
aferojn al laboro, des malpli korekte.

726
00:34:46,745 --> 00:34:49,120
Kaj tiel ĝustecon inklinas
esti pezita la plej, kiel kun

727
00:34:49,120 --> 00:34:51,360
ĉi multiplika faktoro de tri.

728
00:34:51,360 --> 00:34:54,659
Dezajno estas ankaŭ grava, sed
iu kiu vi ne nepre

729
00:34:54,659 --> 00:34:58,220
elspezi ĉiujn de tiuj horoj
provas akiri aferojn ĝuste funkcii.

730
00:34:58,220 --> 00:35:00,019
>> Kaj tiel ĝi estas pezbalancita
iom pli malpeze.

731
00:35:00,019 --> 00:35:01,560
Kaj tiam stilo pezis la malgranda.

732
00:35:01,560 --> 00:35:03,710
Kvankam ĝi estas ne malpli
grava fundamente,

733
00:35:03,710 --> 00:35:05,990
ĝi estas nur, eble, la
facila afero por fari ĝuste,

734
00:35:05,990 --> 00:35:08,440
imitante la ekzemploj
faros en prelego kaj sekcio,

735
00:35:08,440 --> 00:35:11,080
kun aĵoj bele
dentado, kaj komentis,

736
00:35:11,080 --> 00:35:14,320
kaj tiel plu estas inter la plej facilaj
farendaĵojn kaj akiri rajton.

737
00:35:14,320 --> 00:35:16,960
Tiel kiel tia, realigi
ke tiuj estas punktoj

738
00:35:16,960 --> 00:35:19,000
ke estas relative facile kompreni.

739
00:35:19,000 --> 00:35:22,360
>> Kaj nun unu vorton sur
this-- akademia honesteco.

740
00:35:22,360 --> 00:35:25,150
Tiel por la kurso
Syllabus, vi vidos

741
00:35:25,150 --> 00:35:27,630
ke la kurso havas sufiĉe
iom de lingvo ĉirkaŭ ĉi.

742
00:35:27,630 --> 00:35:31,380
Kaj la kurso prenas la temon de
akademia honesteco tute serioze.

743
00:35:31,380 --> 00:35:33,450
>> Ni havas la distingon,
por bone aŭ por malbone,

744
00:35:33,450 --> 00:35:36,570
de sendinte ĉiujare pli
studentojn por disciplina ago

745
00:35:36,570 --> 00:35:39,670
ol plej ajna alia
Kompreneble, ke mi estas konscia de.

746
00:35:39,670 --> 00:35:42,580
Tio ne nepre
indika de la fakto

747
00:35:42,580 --> 00:35:46,340
ke CS studentoj, aŭ CS50 studentoj, estas
ajna malpli honesta ol via samklasanoj.

748
00:35:46,340 --> 00:35:49,090
Sed la realaĵo kiu en tiu
mondo, elektronike, ni nur

749
00:35:49,090 --> 00:35:50,990
havi teknologia
signifas de detekti ĉi.

750
00:35:50,990 --> 00:35:53,360
>> Ĝi estas grava por ni por
justeco tra la klaso

751
00:35:53,360 --> 00:35:58,550
ke ni detektas ĉi kaj restarigu
la demando kiam oni vidas aferojn.

752
00:35:58,550 --> 00:36:01,980
Kaj simple pentri bildon, kaj vere
helpi io tiamaniere profundiĝi en,

753
00:36:01,980 --> 00:36:04,600
Jen estas la nombro de
studentoj dum la pasintaj 10 jaroj

754
00:36:04,600 --> 00:36:07,610
kiuj estis implikitaj en kelkaj
tiajn aferojn de akademia honesteco,

755
00:36:07,610 --> 00:36:10,990
kun iuj 32 studentoj
de aŭtuno 2015, kiu

756
00:36:10,990 --> 00:36:13,760
estas ke ni prenos
la afero tre serioze.

757
00:36:13,760 --> 00:36:18,380
Kaj, fine, tiuj nombroj formi,
plej ĵuse, proksimume 3%, 4% aŭ tiel

758
00:36:18,380 --> 00:36:19,120
de la klaso.

759
00:36:19,120 --> 00:36:25,220
>> Tiel por la super plimulto de studentoj
ĝi similas ke la linioj estas klara.

760
00:36:25,220 --> 00:36:27,940
Sed daŭru en
gravas, aparte malfrue

761
00:36:27,940 --> 00:36:32,080
nokte kiam luktas kun
iu solvo al problemo aro,

762
00:36:32,080 --> 00:36:34,830
ke estas mekanismoj
por akiranta vin pli

763
00:36:34,830 --> 00:36:37,870
subteno ol vi eble
pensas, eĉ en tiu horo.

764
00:36:37,870 --> 00:36:40,514
Rimarkas ke kiam ni ricevas
studento submetadoj, ni transiras

765
00:36:40,514 --> 00:36:43,430
kompari ĉiun submetiĝo tiu jaro
kontraŭ ĉiu submetiĝo pasintjare,

766
00:36:43,430 --> 00:36:47,590
kontraŭ ĉiu submetiĝo de 2007,
kaj tiam, rigardante, kiel bone,

767
00:36:47,590 --> 00:36:49,931
kodo deponejoj rete,
diskuto forumoj, laboron lokoj.

768
00:36:49,931 --> 00:36:51,806
Kaj ni mencias ĉi,
vere, ĉiuj pro

769
00:36:51,806 --> 00:36:56,040
de plena rivelo, ke se
iu alia povas trovi ĝin en linio,

770
00:36:56,040 --> 00:36:57,880
Certe, tiel povas ni la kurson.

771
00:36:57,880 --> 00:37:00,100
Sed, vere, la spirito
de la kurso abscesoj malsupren

772
00:37:00,100 --> 00:37:01,650
al tiu klaŭzo en la Syllabus.

773
00:37:01,650 --> 00:37:03,670
Vere estas justa, racia.

774
00:37:03,670 --> 00:37:06,680
>> Kaj se ni devis ellabori sur tiu
kun nur iom pli lingvon,

775
00:37:06,680 --> 00:37:09,770
rimarkas ke la esenco de ĉiuj
laboro kiu vin submetiĝi al tiu kurso

776
00:37:09,770 --> 00:37:10,954
devas esti via propra.

777
00:37:10,954 --> 00:37:13,870
Sed ene de tiu, estas certe
ŝancojn kaj konsilon

778
00:37:13,870 --> 00:37:17,300
kaj pedagogia valoro en turnante al
others-- mem, la TFS, la CAS,

779
00:37:17,300 --> 00:37:20,760
la TAS, kaj aliaj en la klaso,
por subteno, des malpli amikojn

780
00:37:20,760 --> 00:37:23,547
kaj ĉambrokunuloj kiuj studis
CS kaj programado antaŭe.

781
00:37:23,547 --> 00:37:25,130
Kaj do estas gratifiko por tiu.

782
00:37:25,130 --> 00:37:28,180
Kaj la ĝenerala regulo de dikfingro
Estas this-- kiam petanta helpon,

783
00:37:28,180 --> 00:37:31,470
vi povas montri vian kodon por aliaj,
sed vi povas ne vidi ilian.

784
00:37:31,470 --> 00:37:34,880
Do eĉ se vi estas en oficejo horoj,
aŭ en la D halo, aŭ alie

785
00:37:34,880 --> 00:37:37,450
laborante sur iu peco aro,
laborante apud amiko, kiu

786
00:37:37,450 --> 00:37:40,160
Estas tute bone, ĉe la
Fine de la tago via laboro

787
00:37:40,160 --> 00:37:43,034
devus finfine apartenas unu
vi respektive, kaj ne

788
00:37:43,034 --> 00:37:45,700
esti iu collaborative peno,
krom la fina projekto kie

789
00:37:45,700 --> 00:37:47,410
ĝi estas permesita kaj kuraĝigis.

790
00:37:47,410 --> 00:37:49,830
>> Rimarkas ke se vi estas
luktante kun io

791
00:37:49,830 --> 00:37:52,520
kaj via amiko ĵus okazas
esti pli bona ĉe tiu tiam vi,

792
00:37:52,520 --> 00:37:55,130
aŭ pli bone en tiu problemo ol vi,
aŭ iom pli for antaŭen ol vi,

793
00:37:55,130 --> 00:37:57,330
ĝi estas tute racia turni
al via amiko kaj diri, hej,

794
00:37:57,330 --> 00:38:00,480
Ĉu ĝenas vin rigardi mian kodo tie,
helpanta min ekvidi kio mia problemo estas?

795
00:38:00,480 --> 00:38:03,760
Kaj, espereble, en la
intereso de pedagogia valoro

796
00:38:03,760 --> 00:38:07,040
ke amiko ne nur
diru, ho, tion fari, sed prefere,

797
00:38:07,040 --> 00:38:09,917
kion vi mankas sur linio
6, aŭ io simila?

798
00:38:09,917 --> 00:38:12,000
Sed la solvo ne
cxar la amiko apud vi

799
00:38:12,000 --> 00:38:15,617
diri, ho, nu, tie, lasu min eltiri
ĉi kaj rakontos mian solvon por vi.

800
00:38:15,617 --> 00:38:16,450
Tiel ke estas la linio.

801
00:38:16,450 --> 00:38:18,670
Vi montros vian kodon por
aliaj, sed vi ne

802
00:38:18,670 --> 00:38:22,350
vidi apartenos temo al la alia
limigoj en la kurso Syllabus.

803
00:38:22,350 --> 00:38:24,760
>> Do memoru tio
tn bedaŭro klaŭzo

804
00:38:24,760 --> 00:38:27,560
en la paso de syllabus tiel,
ke se vi faras iun akton kiu

805
00:38:27,560 --> 00:38:30,476
ne racia, sed alportu al
la atenton de la kurso la kapojn

806
00:38:30,476 --> 00:38:34,240
ene 72 horoj, la kurso
eble trudi loka sankcioj kiuj

807
00:38:34,240 --> 00:38:37,380
povas inkludi nekontentiga aŭ
malsukcesanta grado por la laboro farita.

808
00:38:37,380 --> 00:38:41,410
Sed la kurso ne rilatas la
gravas por plua disciplina ago,

809
00:38:41,410 --> 00:38:43,010
krom en kazoj de ripetaj agoj.

810
00:38:43,010 --> 00:38:46,632
Alivorte, se vi ja faras iun
stulta, precipe malfrue nokte, decido

811
00:38:46,632 --> 00:38:49,340
ke sekvamatene aŭ du tagoj
poste, vi vekiĝos kaj rimarkos,

812
00:38:49,340 --> 00:38:50,870
kio mi pensas?

813
00:38:50,870 --> 00:38:53,890
Vi faras en CS50 havas ellasejon
por fiksi tiun problemon

814
00:38:53,890 --> 00:38:57,170
kaj posedi supren al ĝi, tiel ke ni
renkontos vin duonvoje kaj trakti

815
00:38:57,170 --> 00:39:01,500
per ĝi en demando kiu estas ambaŭ
instrua kaj valora por vi,

816
00:39:01,500 --> 00:39:04,200
sed ankoraŭ punaj iel.

817
00:39:04,200 --> 00:39:08,590
Kaj nun, por preni la rando ekstere, tiu.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO reprodukto]

819
00:39:10,570 --> 00:39:13,540
>> [MUZIKO Ludanta]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [FINO reprodukto]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Malan: Bone, ni estas dorso.

823
00:40:00,490 --> 00:40:03,680
Nun ni rigardas unu el la
unua de nia reala mondo domajnoj

824
00:40:03,680 --> 00:40:08,720
en CS50, la arto de ĉifriko,
la arto de sendo kaj ricevanta

825
00:40:08,720 --> 00:40:11,840
sekretajn mesaĝojn, ĉifrita
mesaĝojn se vi volas,

826
00:40:11,840 --> 00:40:17,060
kiu povas nur esti deĉifrita se vi havas
iuj ŝlosilaj ingredienco ke la sendinto havas

827
00:40:17,060 --> 00:40:18,030
ankaŭ.

828
00:40:18,030 --> 00:40:22,120
Tiel motivi ĉi ni prenos
oni rigardas tiun aferon ĉi tie,

829
00:40:22,120 --> 00:40:26,750
kiu estas ekzemplo de
sekreta deĉifrilo ringo kiu

830
00:40:26,750 --> 00:40:34,042
povas esti uzata por eltrovi
kion sekreta mesaĝo vere estas.

831
00:40:34,042 --> 00:40:35,750
Fakte, reen en la
tago en grado lernejo,

832
00:40:35,750 --> 00:40:38,787
se vi iam sendis sekretajn mesaĝojn al
iu amiko aŭ iu enamiĝo en klaso,

833
00:40:38,787 --> 00:40:40,620
vi eble pensis
vi estas saĝa

834
00:40:40,620 --> 00:40:46,530
por sur via paperpeco sxangxado,
kiel, A al B kaj B al C, kaj C al D,

835
00:40:46,530 --> 00:40:47,590
kaj tiel plu.

836
00:40:47,590 --> 00:40:50,300
Sed vi vere kodi
via informo, eĉ

837
00:40:50,300 --> 00:40:53,300
se ĝi estis iom triviala, ne
tiel malfacila por la instruisto por realigi,

838
00:40:53,300 --> 00:40:55,675
bone, se vi nur ŝanĝi
B al A kaj C al B,

839
00:40:55,675 --> 00:40:57,550
vi fakte elkompreni
kion la mesaĝo estis,

840
00:40:57,550 --> 00:40:59,700
sed vi estis en ciphering informo.

841
00:40:59,700 --> 00:41:03,420
>> Vi nur faranta ĝin
simple, multe kiel Ralphie tie

842
00:41:03,420 --> 00:41:07,934
en fama filmo kiu ludas
preskaux ad nauseum ĉiu vintro.

843
00:41:07,934 --> 00:41:08,600
[VIDEO reprodukto]

844
00:41:08,600 --> 00:41:11,180
-Be Sciate al tio
Ralph Parker maniere

845
00:41:11,180 --> 00:41:14,070
enoficigita membro de la Malgranda
Orfa Annie Sekreta Rondo

846
00:41:14,070 --> 00:41:17,700
kaj povas postuli la tutan la honoroj
kaj profitoj okazanta tio.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
counter-subskribita Pierre Andre, en inko.

848
00:41:24,340 --> 00:41:27,160
Honorojn kaj profitojn,
Jam en la aĝo de naŭ.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Kriante]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Come Plu.

853
00:41:34,250 --> 00:41:35,210
Ni iru sur ĝi.

854
00:41:35,210 --> 00:41:39,530
Mi ne bezonas ĉion, kion ĵazo
pri kontrabandistoj kaj piratoj.

855
00:41:39,530 --> 00:41:41,660
>> -Listen Morgaŭ nokte por
la konkluda aventuro

856
00:41:41,660 --> 00:41:43,880
de la nigra ŝipo pirato.

857
00:41:43,880 --> 00:41:46,650
Nun, estas tempo por
Annie la sekreta mesaĝo

858
00:41:46,650 --> 00:41:49,840
cxar vi membroj de la Sekreta Rondo.

859
00:41:49,840 --> 00:41:53,570
Memoru, infanoj, nur membroj
de Annie La Sekreta Rondo

860
00:41:53,570 --> 00:41:56,140
povas malkodi Annie la sekreta mesaĝo.

861
00:41:56,140 --> 00:42:00,340
>> Memoru, Annie estas dependanta sur vi.

862
00:42:00,340 --> 00:42:02,880
Ŝanĝu vian pingloj al B2.

863
00:42:02,880 --> 00:42:05,230
Jen la mesaĝo.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -mi Estas en mia unua sekreta kunveno.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Estis en granda vocxo ĉinokte.

868
00:42:15,780 --> 00:42:19,000
Mi povus diri ke ĉinokte la
mesaĝo estis vere grava.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, tio estas mesaĝo
de Annie sin.

870
00:42:22,694 --> 00:42:23,860
Memoru, ne diru al iu ajn.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekundoj poste, mi estas en la sola
ĉambro en la domo kie knabo de naŭ

873
00:42:32,930 --> 00:42:37,040
povis sidi en privateco kaj malkodi.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Mi iris al la sekva, E.

876
00:42:42,360 --> 00:42:44,520
>> La unua vorto estas esti.

877
00:42:44,520 --> 00:42:49,032
S, ĝi venas pli facile nun, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -Ho, Venu, Ralphie, mi devas iri!

879
00:42:51,733 --> 00:42:53,688
>> -I'll Pravi malsupren, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee Whiz!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T Ho, nepre to-- nepre kio?

883
00:43:04,060 --> 00:43:05,970
Kio estis Little Orphan
Annie provas diri?

884
00:43:05,970 --> 00:43:07,264
Nepre kio?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy atingis
iras, vi bonvolu eliros?

886
00:43:09,634 --> 00:43:10,480
>> -All Dekstra, Ma!

887
00:43:10,480 --> 00:43:12,880
Mi tuj ekstere!

888
00:43:12,880 --> 00:43:14,550
>> -mi Estis proksimiĝas nun.

889
00:43:14,550 --> 00:43:16,620
La streĉiĝo estis terura.

890
00:43:16,620 --> 00:43:17,720
Kio estis tio?

891
00:43:17,720 --> 00:43:20,170
La sorto de la planedo
eble pendas en la ekvilibro.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy gotta go!

894
00:43:23,170 --> 00:43:26,890
>> -I'll Pravi eksteren, por laŭte ploris!

895
00:43:26,890 --> 00:43:32,680
>> -Almost Tie, miaj fingroj flugis, mia menso
estis ŝtalo kaptilo, ĉiu poro vibris.

896
00:43:32,680 --> 00:43:37,198
Estis preskaŭ klara, jes, jes, jes.

897
00:43:37,198 --> 00:43:43,091
>> -Be Nepre trinku vian ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
A malbona morto komerca?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Filo de putino.

903
00:43:54,227 --> 00:43:54,810
[FINO reprodukto]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Malan: Bone, do
kiu estis tre longa vojo

905
00:43:57,390 --> 00:44:00,660
enkonduki ĉifriko,
kaj ankaŭ ovaltine.

906
00:44:00,660 --> 00:44:04,470
Fakte, de tiu malnova anonco
tie, kial estas ovaltine tiel bona?

907
00:44:04,470 --> 00:44:09,470
Estas koncentrita eltiro de matura
hordeo malton, pura cremoso bovino lakto,

908
00:44:09,470 --> 00:44:14,360
kaj speciale preparita kakao, kune
kun natura phosphatides kaj vitaminoj.

909
00:44:14,360 --> 00:44:18,240
Ĝi estas plue fortikigitaj per
aldonaj vitaminoj B kaj D, yum.

910
00:44:18,240 --> 00:44:21,600
Kaj vi ankoraŭ povas akiri ĝin, ŝajne,
sur Amazono, kiel ni faris ĉi tie.

911
00:44:21,600 --> 00:44:24,810
>> Sed la motivación tie estis
enkonduki ĉifriko, specife

912
00:44:24,810 --> 00:44:28,340
tipo de ĉifriko konata
kiel sekreta ŝlosila ĉifriko.

913
00:44:28,340 --> 00:44:34,284
Kaj kiel la nomo sugestas, la tuta
sekureco de sekreta ŝlosilo kripto sistemo,

914
00:44:34,284 --> 00:44:36,200
se vi volas, metodiko
por nur grimpadi

915
00:44:36,200 --> 00:44:40,960
informo inter du personoj, estas ke
nur la sendanto kaj nur la ricevonto

916
00:44:40,960 --> 00:44:46,980
konas sekretan key-- iu valoro, iuj
sekreta frazo, iu sekreta numero, tio

917
00:44:46,980 --> 00:44:50,660
permesas ambaŭ ĉifri
kaj deĉifri informon.

918
00:44:50,660 --> 00:44:53,470
Kaj ĉifriko, vere,
Estas ĝuste tiu de semajno 0.

919
00:44:53,470 --> 00:44:56,715
>> Estas problemo kie ekzistas enigoj,
kiel la reala mesaĝo en la angla

920
00:44:56,715 --> 00:44:59,340
aŭ kion ajn lingvo kiun vi
deziras sendi al iu en klaso,

921
00:44:59,340 --> 00:45:00,580
aŭ tra la interreto.

922
00:45:00,580 --> 00:45:03,840
Ekzistas iuj eligo, kiu tuj
esti la kirlitaj mesaĝon ke vi

923
00:45:03,840 --> 00:45:05,250
volas la ricevanto ricevi.

924
00:45:05,250 --> 00:45:07,405
Kaj eĉ se iu en la
meza ricevas ĝin,

925
00:45:07,405 --> 00:45:09,780
vi ne volas ilin
nepre povos malĉifri ĝin,

926
00:45:09,780 --> 00:45:12,840
ĉar ene de tiu
nigra skatolo, aŭ algoritmo,

927
00:45:12,840 --> 00:45:17,650
estas iu mekanismo, iuj paŝo post paŝo
instrukcioj, por porti tiun enigo

928
00:45:17,650 --> 00:45:20,710
kaj konvertante ĝin en la
eligo, en espereble sekuran vojon.

929
00:45:20,710 --> 00:45:23,640
>> Kaj, fakte, ekzistas iuj
vortprovizo en tiu mondo kiel sekvas.

930
00:45:23,640 --> 00:45:26,100
Plata teksto estas la vorto de
komputila sciencisto farus

931
00:45:26,100 --> 00:45:28,449
uzas por priskribi la enigo
mesaĝo, same kiel la angla

932
00:45:28,449 --> 00:45:31,240
aŭ kion ajn lingvo vi reale
deziras sendi al iu alia homo.

933
00:45:31,240 --> 00:45:35,450
Kaj tiam la ĉifrita teksto estas la scramble
al la enĉifrita, aŭ ĉifrita,

934
00:45:35,450 --> 00:45:36,520
versio de gxi.

935
00:45:36,520 --> 00:45:38,750
>> Sed ekzistas unu alia ingredienco tie.

936
00:45:38,750 --> 00:45:43,200
Ekzistas unu alia enigo al
sekreta ŝlosila ĉifriko.

937
00:45:43,200 --> 00:45:45,200
Kaj kiu estas la ŝlosilo mem,
kiu estas, ĝenerale,

938
00:45:45,200 --> 00:45:48,930
kiel ni vidos, numero, aŭ
letero, aŭ vorto, kio ajn

939
00:45:48,930 --> 00:45:51,980
la algoritmo estas vere atendas.

940
00:45:51,980 --> 00:45:53,870
>> Kaj kiel vi deĉifri informon?

941
00:45:53,870 --> 00:45:55,110
Kiel vi unscramble ĝi?

942
00:45:55,110 --> 00:45:57,950
Nu, vi nur inversigi la
eliroj kaj la enigoj.

943
00:45:57,950 --> 00:46:00,900
>> Alivorte, iam iu
ricevas via ĉifrita mesaĝo,

944
00:46:00,900 --> 00:46:03,740
li aŭ ŝi simple havas
scii ke sama ŝlosilo.

945
00:46:03,740 --> 00:46:05,700
Ili ricevis la ĉifrita teksto.

946
00:46:05,700 --> 00:46:09,530
Kaj per ŝtopanta tiuj du
enigoj en la kripto sistemo,

947
00:46:09,530 --> 00:46:14,260
la algoritmo, ĉi nigra skatolo, ekstere
venu la originala teksto.

948
00:46:14,260 --> 00:46:17,830
Kaj do tio estas la tre alta nivelo
Konsiderante kio ĉifriko estas reale

949
00:46:17,830 --> 00:46:18,590
ĉiuj proksimume.

950
00:46:18,590 --> 00:46:20,030
>> Do ni ricevas tie.

951
00:46:20,030 --> 00:46:22,700
Ni nun rigardu sube
la kapuĉo de io

952
00:46:22,700 --> 00:46:26,000
ni estis prenante por donita por
la pasinta semajno, kaj por tiu sesio

953
00:46:26,000 --> 00:46:27,629
here-- la kordo.

954
00:46:27,629 --> 00:46:30,295
Kordo fine de la tago
estas nur vico de signoj.

955
00:46:30,295 --> 00:46:33,610
>> Gxi estu saluton mondo, aŭ
saluton Zamyla, aŭ kion ajn.

956
00:46:33,610 --> 00:46:37,050
Sed kion tio signifas por
esti sekvenco de karakteroj?

957
00:46:37,050 --> 00:46:41,520
Fakte, la CS50 biblioteko donas
ni datumtipo nomata ŝnuro.

958
00:46:41,520 --> 00:46:45,140
>> Sed estas vere neniu
tia afero kiel linio en C.

959
00:46:45,140 --> 00:46:49,450
Ĝi vere estas nur vico de
karaktero, trajto, karaktero,

960
00:46:49,450 --> 00:46:52,180
karaktero, dorso, apogi, por
dorso, apogi, subteni ene

961
00:46:52,180 --> 00:46:54,650
de via komputilo la memoro, aŭ RAM.

962
00:46:54,650 --> 00:46:58,940
Kaj ni rigardu pli profunden en kiuj en la
estonteco kiam ni rigardas memoro mem,

963
00:46:58,940 --> 00:47:02,030
kaj la utiligo kaj la
minacoj kiuj estas implikitaj.

964
00:47:02,030 --> 00:47:04,100
>> Sed ni konsideru la kordo Zamyla.

965
00:47:04,100 --> 00:47:07,480
Tiel nur la nomo de
la homa tie, Zamyla,

966
00:47:07,480 --> 00:47:12,030
ke estas vico de
karakteroj, Z-Al-M-Kaj-L-A.

967
00:47:12,030 --> 00:47:16,020
Nun ni supozu ke Zamyla nomon
estas stokitaj ene de komputilo

968
00:47:16,020 --> 00:47:16,880
programo.

969
00:47:16,880 --> 00:47:20,830
>> Nu, ĝi staras rezoni, ke ni devus
povos rigardi tiujn signojn

970
00:47:20,830 --> 00:47:21,590
individue.

971
00:47:21,590 --> 00:47:24,710
Do mi simple tuj tiri iom
skatolo ĉirkaŭ Zamyla nomon tie.

972
00:47:24,710 --> 00:47:31,580
Kaj tio estas la kazo en C ke kiam vi
havas ĉenon, kiel Zamyla-- kaj eble

973
00:47:31,580 --> 00:47:34,940
ke kordo revenis el
funkcio kiel get kordoj,

974
00:47:34,940 --> 00:47:38,540
vi povas reale manipuli
ĝi karaktero por karaktero.

975
00:47:38,540 --> 00:47:42,070
>> Nu, temas germane por la
konversacio ĉe mano, ĉar

976
00:47:42,070 --> 00:47:46,420
en ĉifriko se vi volas ŝanĝi
A al B, kaj B al C, kaj C al D,

977
00:47:46,420 --> 00:47:49,650
kaj tiel plu, vi bezonas por povi
rigardi la individuajn karakterojn

978
00:47:49,650 --> 00:47:50,190
en ĉeno.

979
00:47:50,190 --> 00:47:52,695
Vi bezonas por povi ŝanĝi
Z por io alia, la A

980
00:47:52,695 --> 00:47:55,280
al io alia, la M al
io alia, kaj tiel plu.

981
00:47:55,280 --> 00:47:58,000
Kaj do ni bezonas manieron,
programmatically, do

982
00:47:58,000 --> 00:48:03,020
paroli, en C por povi ŝanĝi
kaj rigardi individuajn literojn.

983
00:48:03,020 --> 00:48:05,690
Kaj ni povas fari tion kiel sekvas.

984
00:48:05,690 --> 00:48:08,340
>> Mi iros gvidi reen en CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Kaj lasu min antaŭeniri
kaj krei novan dosieron

986
00:48:11,130 --> 00:48:16,134
Mi vokos tiu tempo string0,
kiel nia unua tia ekzemplo, dot c.

987
00:48:16,134 --> 00:48:18,300
Kaj mi tuj iros antaŭen
kaj vipi ĝin jene.

988
00:48:18,300 --> 00:48:22,870
>> Tiel inkluzivi CS50.h kaj
tiam inkludas normon io.h,

989
00:48:22,870 --> 00:48:25,990
kiun mi preskaŭ ĉiam tuj
esti uzante en mia programoj, almenaŭ

990
00:48:25,990 --> 00:48:26,780
komence.

991
00:48:26,780 --> 00:48:32,180
int ĉefa malplenon, kaj tiam en ĉi tie mi estas
faros kordoj ricevas atingi ŝnuron.

992
00:48:32,180 --> 00:48:35,260
Kaj tiam mi tuj
antaŭeniri kaj fari tion.

993
00:48:35,260 --> 00:48:37,460
Mi volas iri antaŭen
kaj, kiel prudento ĉeko,

994
00:48:37,460 --> 00:48:43,607
nur diri, saluton, procento s,
duon-dupunkto, faras ĉenon 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, kion mi faras ĉi tie?

996
00:48:44,690 --> 00:48:45,930
Ho, mi ne ŝtopi ĝin en.

997
00:48:45,930 --> 00:48:48,120
Tiel leciono lernis, ke
ne intenca.

998
00:48:48,120 --> 00:48:52,480
>> Do eraro, pli procento
konvertiĝoj ol datumoj argumentoj.

999
00:48:52,480 --> 00:48:54,940
Kaj tio estas kie,
linio 7-- Bone, do mi havas,

1000
00:48:54,940 --> 00:48:56,690
citaĵo unquote, jen
mian ŝnuron al printf.

1001
00:48:56,690 --> 00:48:58,151
Mi havas procentsigno.

1002
00:48:58,151 --> 00:48:59,650
Sed mi mankas la dua argumento.

1003
00:48:59,650 --> 00:49:03,190
>> Mi mankas la komo s, kiu
Mi havas en antaŭaj ekzemploj.

1004
00:49:03,190 --> 00:49:06,650
Do bonan ŝancon ripari
pli eraro, hazarde.

1005
00:49:06,650 --> 00:49:09,950
Kaj nun mi kuros
string0, tipo en Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, saluton Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Do ni ne plu havas tian programon
kelkaj malsamaj tempoj nun.

1008
00:49:14,144 --> 00:49:16,310
Sed ni faru ion
iom malsama ĉi tiu tempo.

1009
00:49:16,310 --> 00:49:19,450
Anstataŭ ĝuste presi Zamyla la
plena nomo kun printf,

1010
00:49:19,450 --> 00:49:21,350
ni faru ĝin karaktero por karaktero.

1011
00:49:21,350 --> 00:49:22,700
>> Mi tuj uzi por buklo.

1012
00:49:22,700 --> 00:49:26,160
Kaj mi tuj doni min
oni kalkula variablo, nomita I.

1013
00:49:26,160 --> 00:49:33,530
Kaj mi tuj teni ripetanta, do
longe kiel i estas malpli ol la longo de s.

1014
00:49:33,530 --> 00:49:35,930
>> Rezultas, ni ne
fari tiun lastan fojon,

1015
00:49:35,930 --> 00:49:39,100
ke c venas kun
funkcio nomita Stirling.

1016
00:49:39,100 --> 00:49:42,690
Reen en la tago, kaj ĝenerale
ankoraŭ kiam efektiviganta funkcioj,

1017
00:49:42,690 --> 00:49:45,405
homoj ofte elektas tre
konciza nomoj tian sonon

1018
00:49:45,405 --> 00:49:48,280
kiel kion vi volas, eĉ se ĝi estas
mankas kelkaj vokaloj aŭ literoj.

1019
00:49:48,280 --> 00:49:50,660
Tiel Stirling estas la
nomo de funkcio kiu

1020
00:49:50,660 --> 00:49:53,880
prenas argumenton inter
krampoj kiuj devus esti ŝnuro.

1021
00:49:53,880 --> 00:49:56,910
Kaj ĝi nur revenas entjero,
la longo de tiu linio.

1022
00:49:56,910 --> 00:50:00,580
>> Do ĉi por buklo sur linio 7 tuj
por komenci kalkulon je i egalas 0.

1023
00:50:00,580 --> 00:50:02,530
Ĝi tuj pliigo
i sur ĉiu ripeto

1024
00:50:02,530 --> 00:50:04,350
de 1, kiel ni estis farante kelkajn fojojn.

1025
00:50:04,350 --> 00:50:06,780
Sed ĝi tuj nur fari
tio supren ĝis la punkto

1026
00:50:06,780 --> 00:50:09,660
Kiam i estas la longo
de la kordo mem.

1027
00:50:09,660 --> 00:50:14,520
>> Do tiu estas maniero, finfine,
ripetanta super la karakteroj

1028
00:50:14,520 --> 00:50:17,430
en la kordo kiel estas sekvas.

1029
00:50:17,430 --> 00:50:20,670
Mi tuj presi ne
tuta ĉeno, sed procento c,

1030
00:50:20,670 --> 00:50:22,860
sola karaktero
sekvata de nova linio.

1031
00:50:22,860 --> 00:50:24,880
Kaj tiam mi tuj
antaŭeniri, kaj mi bezonas

1032
00:50:24,880 --> 00:50:29,080
diri mi volas presi
Ith karaktero de s.

1033
00:50:29,080 --> 00:50:33,450
>> Do se mi estas la variablo kiu indikas
la indekso de la kordo, kie

1034
00:50:33,450 --> 00:50:37,230
vi en ĝi, mi bezonas por povi
diri, donu al mi la Ith karaktero de s.

1035
00:50:37,230 --> 00:50:40,390
Kaj c havas maniero fari
tiu kun kvadrataj krampoj.

1036
00:50:40,390 --> 00:50:43,679
Vi simple diru la nomon de la
kordo, kiu en ĉi tiu kazo estas s.

1037
00:50:43,679 --> 00:50:46,970
Tiam vi uzas kvadrataj krampoj, kio estas
kutime ĵus super via Reveno aŭ Enter

1038
00:50:46,970 --> 00:50:48,110
ŝlosilo sur la klavaro.

1039
00:50:48,110 --> 00:50:52,410
Kaj tiam vi metu la indekso de la
karaktero kiun vi volas presi.

1040
00:50:52,410 --> 00:50:55,960
Tiel la indekso tuj esti
number-- 0 aŭ 1, aŭ 2, aŭ 3, aŭ streketo

1041
00:50:55,960 --> 00:50:57,590
streketo pentras, iu alia nombro.

1042
00:50:57,590 --> 00:51:00,920
>> Kaj ni certigos ke ĝi tuj
esti la ĝusta nombro, ĉar mi

1043
00:51:00,920 --> 00:51:02,360
komenci kalkulon je 0.

1044
00:51:02,360 --> 00:51:07,020
Kaj implicite, la unua karaktero
en cxeno estas per konvencio 0.

1045
00:51:07,020 --> 00:51:09,230
Kaj la dua karaktero estas krampo 1.

1046
00:51:09,230 --> 00:51:11,120
Kaj la tria karaktero estas krampo 2.

1047
00:51:11,120 --> 00:51:13,630
Kaj vi ne volas iri tro
nun, sed ni ne cxar ni estas

1048
00:51:13,630 --> 00:51:17,780
tuj nur pliigo i ĝis
egalas la longon de la kordo.

1049
00:51:17,780 --> 00:51:20,210
Kaj ĉe kiu punkto,
ĉi por buklo ĉesos.

1050
00:51:20,210 --> 00:51:25,550
>> Do lasu min antaŭeniri kaj savi ĉi
programo kaj kuri fari ĉenon 0.

1051
00:51:25,550 --> 00:51:28,400
Sed mi ŝraŭbita supren.

1052
00:51:28,400 --> 00:51:35,390
Implice deklari biblioteko funkcio
Stirling kun tipo tia kaj such-- nun,

1053
00:51:35,390 --> 00:51:36,430
tio sonas familiara.

1054
00:51:36,430 --> 00:51:37,440
Sed ĝi ne estas printf.

1055
00:51:37,440 --> 00:51:38,540
Kaj ĝi ne ricevas ŝnuro.

1056
00:51:38,540 --> 00:51:40,480
>> Mi ne ŝraŭbi supre en
same tiu tempo.

1057
00:51:40,480 --> 00:51:45,100
Sed rimarki cxi tie iom malsupren
plue, inkluzivas la kaplinio string.h,

1058
00:51:45,100 --> 00:51:47,210
eksplicite provizas la
deklaro por Stirling.

1059
00:51:47,210 --> 00:51:48,820
Do estas fakte aŭtoveturejon en tie.

1060
00:51:48,820 --> 00:51:51,670
>> Kaj ja rezultas
ekzistas alia kaplinio dosiero

1061
00:51:51,670 --> 00:51:53,970
ke ni ne uzas
en klaso ankoraŭ, sed ĝi estas

1062
00:51:53,970 --> 00:51:56,480
inter tiuj disponeblaj
al vi, nomata string.h.

1063
00:51:56,480 --> 00:52:00,930
Kaj en tiu dosiero, string.h
Estas Stirling deklaris.

1064
00:52:00,930 --> 00:52:05,220
Do lasu min antaŭeniri kaj
krom tio, fari ĉenon

1065
00:52:05,220 --> 00:52:08,040
0-- bela, neniu erarmesaĝojn tiu tempo.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, kaj
Mi volis batis Enter,

1067
00:52:12,290 --> 00:52:16,710
ĉe kiu punkto getstring tuj
redoni la kordo, metis ĝin en s.

1068
00:52:16,710 --> 00:52:21,890
Tiam tiu por buklo tuj persisti
super S gravuloj unuope,

1069
00:52:21,890 --> 00:52:28,420
kaj presi ilin unu po linio, ĉar
Mi havis tiun backslash n je la fino.

1070
00:52:28,420 --> 00:52:34,530
Do mi povis preterlasi ke backslash
n, kaj tiam simple presi Zamyla ĉiuj

1071
00:52:34,530 --> 00:52:37,460
en la sama linio,
efike reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, kio ne ĉiuj tiom utila.

1073
00:52:38,999 --> 00:52:40,540
Sed en ĉi tiu kazo, mi ne faris tion.

1074
00:52:40,540 --> 00:52:43,610
Mi fakte presitaj unu
karakteron je fojo, unu po linio,

1075
00:52:43,610 --> 00:52:45,400
por ke ni reale vidi la efikon.

1076
00:52:45,400 --> 00:52:46,900
>> Sed mi devus noti unu aferon ĉi tie.

1077
00:52:46,900 --> 00:52:48,930
Kaj ni revenos al
tiu en estonta semajno.

1078
00:52:48,930 --> 00:52:52,650
Ĝi rezultas ke ĉi
poŝtkodo estas potenciale kalesxo.

1079
00:52:52,650 --> 00:52:56,560
>> Ĝi rezultas ke get kordoj
kaj iuj aliaj funkcioj de la vivo

1080
00:52:56,560 --> 00:53:00,280
ne nepre ĉiam
reveni kion vi atendas.

1081
00:53:00,280 --> 00:53:03,010
Ni scias el klaso lasta
tempo en ĉi tiu akiras

1082
00:53:03,010 --> 00:53:04,960
ŝnuro supozas reveni kordo.

1083
00:53:04,960 --> 00:53:09,900
Sed kion se la uzanto tajpas el tia
longa vorto, aŭ paragrafo, aŭ eseo

1084
00:53:09,900 --> 00:53:13,010
ke estas simple ne sufiĉas
memoro en la komputilo por ĝustigi ĝin.

1085
00:53:13,010 --> 00:53:15,410
>> Kiel, se iu eliras
malĝusta sub la kapuĉo?

1086
00:53:15,410 --> 00:53:18,400
Povus okazi ofte,
sed povus okazi iam

1087
00:53:18,400 --> 00:53:21,520
en momento, tre malofte.

1088
00:53:21,520 --> 00:53:25,460
Kaj tial ĝi rezultas ke get kordoj
kaj funkciojn kiel ĝi faras ne nepre

1089
00:53:25,460 --> 00:53:26,380
ĉiam reveni kordoj.

1090
00:53:26,380 --> 00:53:30,680
Ili povus reveni iun eraran valoro,
iu gardostaranto valoro tiel diri,

1091
00:53:30,680 --> 00:53:32,612
kiu indikas ke
io iris malĝuste.

1092
00:53:32,612 --> 00:53:35,320
Kaj vi nur scias tion el
sciigxinte ĝin en klaso nun

1093
00:53:35,320 --> 00:53:37,700
aŭ leginte iom pli dokumentado.

1094
00:53:37,700 --> 00:53:43,120
Ĝi rezultas ke get kordoj
povas redoni valoro nomita nula.

1095
00:53:43,120 --> 00:53:46,220
Null estas speciala valoro kiu ni
revenu al la estonta semajno.

1096
00:53:46,220 --> 00:53:50,420
Sed nuntempe, nur scias, ke se mi volas
esti vere konvena en movanta antaŭen

1097
00:53:50,420 --> 00:53:52,650
uzante get kordoj, mi
ne simple nomas ĝin,

1098
00:53:52,650 --> 00:53:56,870
kaj blinde uzi lian revenon valoro,
konfidante ke ĝi estas ĉeno.

1099
00:53:56,870 --> 00:53:59,420
>> Mi unue diru,
hej, atendu minuton, nur

1100
00:53:59,420 --> 00:54:03,380
procedi se s ne egala
nula, kie nula, denove,

1101
00:54:03,380 --> 00:54:04,660
estas nur iuj specialaj valoro.

1102
00:54:04,660 --> 00:54:07,770
Kaj ĝi estas la nura speciala valoro vi
bezonas zorgi pri por akiri string.

1103
00:54:07,770 --> 00:54:10,900
Akiri string estas aŭ irante
reveni ŝnuro aŭ nula.

1104
00:54:10,900 --> 00:54:17,219
>> Kaj ĉi ekkrion punkto egalas signo
vi eble scias el eble math klaso

1105
00:54:17,219 --> 00:54:20,510
ke vi povus desegni egalan signon per
linion tra ĝi por indiki ne egalaj.

1106
00:54:20,510 --> 00:54:23,135
Tio ne ĝenerale gravulo
vi povas tajpi sur via klavaro.

1107
00:54:23,135 --> 00:54:26,480
Kaj tial en plej programlingvoj,
kiam vi volas diri ne egala,

1108
00:54:26,480 --> 00:54:29,160
vi uzas ekkrion punkto,
alie konata kiel bang.

1109
00:54:29,160 --> 00:54:33,180
Do vi diras bang egalas, kio
signifas ne egalas, logike.

1110
00:54:33,180 --> 00:54:38,060
Estas nur kiel ekzistas neniu pli granda
ol, aŭ egalaj al, aŭ malpli ol

1111
00:54:38,060 --> 00:54:41,270
aŭ egala tajpi sur via klavaro
kiu faras ĉion en unu simbolo.

1112
00:54:41,270 --> 00:54:44,020
Tial do, en pasinteco ekzemploj,
vi faris malferma krampo, kaj poste

1113
00:54:44,020 --> 00:54:48,670
egala signo, por fari
pli granda ol aŭ, diru, malpli ol.

1114
00:54:48,670 --> 00:54:49,910
>> Do kio estas la takeaway tie?

1115
00:54:49,910 --> 00:54:53,880
Tio estas simple vojo nun de
enkondukante tiu sintakso, ĉi trajto,

1116
00:54:53,880 --> 00:54:57,390
ripetanta super individua
karakteroj en cxeno.

1117
00:54:57,390 --> 00:55:00,260
Kaj ĝuste kiel tiuj kvadrata
krampoj permesas vin akiri ilin,

1118
00:55:00,260 --> 00:55:03,790
konsideri tiujn kvadrataj krampoj kiel
ia sugestante tiun subkuŝanta

1119
00:55:03,790 --> 00:55:06,040
dezajno, per kiu ĉiu
karaktero ene de kordoj

1120
00:55:06,040 --> 00:55:10,180
estas speco de skatolo en ie sub
la kapuĉo en via komputilo la memoro.

1121
00:55:10,180 --> 00:55:12,340
>> Sed ni faros varianto de tio.

1122
00:55:12,340 --> 00:55:14,880
Ĝi rezultas ke ĉi
programo estas korekta.

1123
00:55:14,880 --> 00:55:18,810
Tiel por CS50 la aksoj por taksi
kodo, tio estas ĝusta nun.

1124
00:55:18,810 --> 00:55:22,959
Precipe nun ke mi kontrolas por
nula, tiu programo devus neniam frakasi.

1125
00:55:22,959 --> 00:55:24,500
Kaj mi nur scias ke de sperto.

1126
00:55:24,500 --> 00:55:28,040
Sed estas nenio alia ke
ni povas vere iri malbone tie.

1127
00:55:28,040 --> 00:55:31,860
Sed ĝi ne estas tre bone desegnita,
ĉar ni revenu al basics.

1128
00:55:31,860 --> 00:55:34,450
>> Unue principles--
kion por buklo faras?

1129
00:55:34,450 --> 00:55:36,290
A por buklo faras tri aferojn.

1130
00:55:36,290 --> 00:55:39,340
Ĝi inicializa iuj
valoro, se vi demandas lin al.

1131
00:55:39,340 --> 00:55:41,770
Ĝi kontrolas kondiĉo.

1132
00:55:41,770 --> 00:55:45,380
Kaj tiam post ĉiu
ripeto, post ĉiu ciklo,

1133
00:55:45,380 --> 00:55:49,330
ĝi pliigas iom
valoro, aŭ valoroj, tie.

1134
00:55:49,330 --> 00:55:50,600
>> Do kion tio signifas?

1135
00:55:50,600 --> 00:55:52,940
Ni pravalorizi i al 0.

1136
00:55:52,940 --> 00:55:58,610
Ni kontrolu kaj certigi i estas malpli ol
la longo de s, kiu estas Z-Al-M-Kaj-L-A,

1137
00:55:58,610 --> 00:55:59,900
tiel ke estas malpli ol 6.

1138
00:55:59,900 --> 00:56:02,590
Kaj ja, 0 kiel malpli ol 6.

1139
00:56:02,590 --> 00:56:05,580
>> Ni presi Z de Zamyla nomo.

1140
00:56:05,580 --> 00:56:08,080
Tiam ni pliigo i de 0 al 1.

1141
00:56:08,080 --> 00:56:11,290
Ni tiam kontrolu, estas 1 malpli
ol la longo de s?

1142
00:56:11,290 --> 00:56:13,270
La longo de s estas 6.

1143
00:56:13,270 --> 00:56:13,950
Jes estas.

1144
00:56:13,950 --> 00:56:16,880
>> Tiel ni presi en Zamyla nomo, ZA.

1145
00:56:16,880 --> 00:56:20,090
Ni pliigo i de 0 al 1, al 2.

1146
00:56:20,090 --> 00:56:23,720
Ni tiam kontrolu, estas 2 malpli ol
la longo de Zamyla nomo.

1147
00:56:23,720 --> 00:56:25,380
6- ĝis 2 estas malpli ol 6.

1148
00:56:25,380 --> 00:56:30,460
Jes, ni presi nun M en
Zamyla nomo, la tria karaktero.

1149
00:56:30,460 --> 00:56:34,110
>> La ŝlosilo tie estas ke en ĉiu
ripeto de la rakonto, mi kontrolas,

1150
00:56:34,110 --> 00:56:37,810
Estas i malpli ol la longo de Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Sed la ruzo estas ke
Stirling ne propraĵo.

1152
00:56:40,350 --> 00:56:43,100
Tiuj el vi kiuj programis
antaŭe en Java aŭ aliaj lingvoj

1153
00:56:43,100 --> 00:56:46,310
eksciu la longo de kordo estas
propraĵo, nur iuj nurlegebla valoro.

1154
00:56:46,310 --> 00:56:50,220
>> En C en ĉi tiu kazo, se ĉi tiu estas
funkcio kiu estas laŭvorte

1155
00:56:50,220 --> 00:56:53,520
kalkulante la nombron de
karakteroj en Zamyla ĉiufoje

1156
00:56:53,520 --> 00:56:54,740
ni nomas tiun funkcion.

1157
00:56:54,740 --> 00:56:58,500
Ĉiufoje kiam vi demandas la komputilo por uzi
Stirling, ĝi estas prenanta rigardi Zamyla,

1158
00:56:58,500 --> 00:57:01,960
kaj dirante Z-Al-M-Kaj-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Kaj ĝi revenas 6.

1160
00:57:02,962 --> 00:57:04,920
La sekvanta tempo vi vokas
ĝi ene ol por ciklo,

1161
00:57:04,920 --> 00:57:08,610
ĝi tuj rigardi Zamyla
denove diru Z-Al-M-Kaj-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Kaj ĝi tuj revenas 6.

1163
00:57:10,320 --> 00:57:12,980
Do kio estas stultaj pri tiu dezajno?

1164
00:57:12,980 --> 00:57:17,700
>> Kial mia kodo ne 5 el 5
por dezajno nun, por tiel diri?

1165
00:57:17,700 --> 00:57:20,600
Nu, mi petas de
demando nenecese.

1166
00:57:20,600 --> 00:57:23,030
Mi faras pli da laboro, ol mi bezonas.

1167
00:57:23,030 --> 00:57:25,370
>> Do eĉ se la
respondo estas korekta, mi estas

1168
00:57:25,370 --> 00:57:29,560
petante la komputilo, kio estas
la longo de Zamyla denove,

1169
00:57:29,560 --> 00:57:31,380
kaj denove, kaj denove, kaj denove?

1170
00:57:31,380 --> 00:57:33,980
Kaj ke respondo estas
neniam tuj ŝanĝos.

1171
00:57:33,980 --> 00:57:35,900
Ĝi estas ĉiam tuj estos 6.

1172
00:57:35,900 --> 00:57:39,730
>> Do pli bona solvo ol tiu
estus tiu proksima versio.

1173
00:57:39,730 --> 00:57:43,390
Lasu min antaŭeniri kaj metis ĝin en
aparta dosiero nomata string1.c,

1174
00:57:43,390 --> 00:57:44,990
nur teni ĝin apartigu.

1175
00:57:44,990 --> 00:57:47,260
Kaj ĝi rezultas en por
buklo, vi povas reale

1176
00:57:47,260 --> 00:57:50,210
deklari plurajn variablojn samtempe.

1177
00:57:50,210 --> 00:57:53,460
>> Do mi tuj teni i kaj metis gxin al 0.

1178
00:57:53,460 --> 00:57:56,190
Sed mi ankaŭ tuj
aldoni komon, kaj diru:

1179
00:57:56,190 --> 00:58:01,050
donu al mi variablo nomis n, kies
valoro egalas la kordo longo de s.

1180
00:58:01,050 --> 00:58:09,410
Nun bonvolu fari mia kondiĉo
tiel longe kiel i estas malpli ol n.

1181
00:58:09,410 --> 00:58:14,140
>> Do en ĉi tiu maniero, la logiko estas
identaj ĉe la fino de la tago.

1182
00:58:14,140 --> 00:58:18,280
Sed mi rememorante la
valoro 6, tiukaze.

1183
00:58:18,280 --> 00:58:19,780
Kiel longa de Zamyla nomo?

1184
00:58:19,780 --> 00:58:20,860
Kaj mi metis ĝin en n.

1185
00:58:20,860 --> 00:58:23,050
>> Kaj mi ankoraŭ kontrolanta
la kondiĉo ĉiufoje.

1186
00:58:23,050 --> 00:58:24,300
Estas 0 malpli ol 6?

1187
00:58:24,300 --> 00:58:25,600
Estas 1 malpli ol 6?

1188
00:58:25,600 --> 00:58:28,600
Estas 2 malpli ol 6, kaj tiel plu?

1189
00:58:28,600 --> 00:58:31,914
>> Sed mi ne petas la komputilon
denove kaj denove, kio estas

1190
00:58:31,914 --> 00:58:33,080
la longo de Zamyla nomo?

1191
00:58:33,080 --> 00:58:34,320
Kio estas la longo de Zamyla nomo?

1192
00:58:34,320 --> 00:58:35,986
Kio estas la longo de tiu Zamyla nomo?

1193
00:58:35,986 --> 00:58:40,440
Mi laŭvorte memorante ke unue kaj
nur respondi en tiu dua variablo n.

1194
00:58:40,440 --> 00:58:45,280
Do ĉi nun estus ne nur
korekta, sed ankaŭ bone desegnita.

1195
00:58:45,280 --> 00:58:46,670
>> Nun, kio pri stilo?

1196
00:58:46,670 --> 00:58:48,866
Mi nomis mian variabloj
sufiĉe bone, mi dirus.

1197
00:58:48,866 --> 00:58:50,240
Ili estas súper konciza nun.

1198
00:58:50,240 --> 00:58:52,090
Kaj tio estas tute bone.

1199
00:58:52,090 --> 00:58:55,120
>> Se vi nur havas unu
ŝnuro en programo,

1200
00:58:55,120 --> 00:58:56,860
vi eble tiel nomas ĝin s por kordoj.

1201
00:58:56,860 --> 00:58:59,370
Se vi nur havas unu variablo
por rakonti en programo,

1202
00:58:59,370 --> 00:59:00,710
vi eble tiel nomas ĝin I.

1203
00:59:00,710 --> 00:59:03,500
Se vi havas longon n
Estas súper komunaj ankaŭ.

1204
00:59:03,500 --> 00:59:05,800
Sed mi ne diris iun el mia kodo.

1205
00:59:05,800 --> 00:59:09,200
>> Mi ne informis la reader--
ĉu tio estas mia Tf, aŭ TA:

1206
00:59:09,200 --> 00:59:12,460
aŭ simple colleague-- kio supozas
esti okazanta en tiu programo.

1207
00:59:12,460 --> 00:59:15,760
Kaj tiel akiri bonan stilon,
kion mi volas fari

1208
00:59:15,760 --> 00:59:24,580
Estas this-- ion
kiel demandi uzanto por enigo.

1209
00:59:24,580 --> 00:59:26,670
Kaj mi povus reverki
tiun ajna nombro de manieroj.

1210
00:59:26,670 --> 00:59:35,630
>> Certiĝu s-- certigi get
ŝnuro revenis kordo.

1211
00:59:35,630 --> 00:59:40,280
Kaj tiam en here-- kaj tio estas eble
la plej grava comment-- ripeti

1212
00:59:40,280 --> 00:59:44,450
super la karakteroj en s unuope.

1213
00:59:44,450 --> 00:59:47,060
Kaj mi povus uzi ajnan
elekto de la angla lingvo

1214
00:59:47,060 --> 00:59:49,650
tie priskribi ĉiun
de tiuj blokoj de kodo.

1215
00:59:49,650 --> 00:59:52,740
>> Rimarku ke mi ne metis
komenti ĉiun linion de kodo,

1216
00:59:52,740 --> 00:59:55,690
vere nur sur la interesa
tiuj, tiuj kiuj

1217
00:59:55,690 --> 00:59:59,460
havas iun signifon ke mi
deziras fari super klara al iu

1218
00:59:59,460 --> 01:00:00,460
legante mian kodon.

1219
01:00:00,460 --> 01:00:02,920
Kaj kial vi vokas akiri
ŝnuro demandi uzanto por enigo?

1220
01:00:02,920 --> 01:00:05,450
Eĉ ke oni ne nepre
ĉiuj kiuj priskriba.

1221
01:00:05,450 --> 01:00:09,340
Sed helpas rakonti rakonton, ĉar la
dua linio en la rakonto estas, certigi

1222
01:00:09,340 --> 01:00:10,740
akiri string revenis kordo.

1223
01:00:10,740 --> 01:00:14,260
>> Kaj la tria linio en la rakonto estas,
persisti super la karakteroj en s unu

1224
01:00:14,260 --> 01:00:15,380
samtempe.

1225
01:00:15,380 --> 01:00:17,920
Kaj nun nur por bonan mezuron,
Mi tuj iros antaŭen kaj aldoni

1226
01:00:17,920 --> 01:00:24,560
pli komenton kiuj ĵus
diras print ia karaktero en s.

1227
01:00:24,560 --> 01:00:26,520
Nun, kion mi faris
ĉe la fino de la tago?

1228
01:00:26,520 --> 01:00:29,190
>> Mi aldonis iom da la angla
vortoj en la formo de komentoj.

1229
01:00:29,190 --> 01:00:32,700
La oblikvo oblikvo simbolo signifas, hej,
komputila ĉi estas por la homa,

1230
01:00:32,700 --> 01:00:33,820
Ne vi, la komputilo.

1231
01:00:33,820 --> 01:00:35,119
Do oni ignoris logike.

1232
01:00:35,119 --> 01:00:35,910
Ili estas nur tie.

1233
01:00:35,910 --> 01:00:39,830
>> Kaj ja CS50 IDE montras ilin kiel
griza, kiel esti utila, sed ne klavon

1234
01:00:39,830 --> 01:00:41,000
al la programo.

1235
01:00:41,000 --> 01:00:42,570
Rimarki kion vi povas nun fari.

1236
01:00:42,570 --> 01:00:44,950
Ĉu vi scias C
programado aŭ ne, vi

1237
01:00:44,950 --> 01:00:47,722
povas simple staras reen ĉe tiu
programo kaj skim la komentoj.

1238
01:00:47,722 --> 01:00:50,180
Petu uzanto por enigo, certigu
akiri string revenis ĉenon,

1239
01:00:50,180 --> 01:00:53,009
persisti super la karakteroj en s
unuope, montri la karakteron

1240
01:00:53,009 --> 01:00:55,550
ia karaktero en s-- vi ne
eĉ devas rigardi la kodo

1241
01:00:55,550 --> 01:00:57,270
kompreni kion tiu programo faras.

1242
01:00:57,270 --> 01:01:00,280
Kaj, pli bona ankoraŭ, se vi mem rigardu
en tiu programo en semajno aŭ du,

1243
01:01:00,280 --> 01:01:02,280
aux monaton aux jaro,
vi tro ne havas

1244
01:01:02,280 --> 01:01:04,420
fiksrigardi la kodon,
provante memori,

1245
01:01:04,420 --> 01:01:06,630
kio mi provis fari kun tiu kodo?

1246
01:01:06,630 --> 01:01:07,770
>> Vi diris mem.

1247
01:01:07,770 --> 01:01:11,660
Vi priskribis lin mem,
aŭ iu kolego, aŭ TA aŭ TF.

1248
01:01:11,660 --> 01:01:14,860
Kaj tial ĉi tio estas nun
ĝusta kaj bona dezajno,

1249
01:01:14,860 --> 01:01:18,210
kaj finfine bona stilo ankaŭ.

1250
01:01:18,210 --> 01:01:19,990
Do ja tenas ke en menso.

1251
01:01:19,990 --> 01:01:22,200
>> Do ekzistas unu alia
kion mi tuj faros ĉi tie

1252
01:01:22,200 --> 01:01:28,240
kiu povas nun malkaŝas ĝuste kio estas
okazas sub la kapuĉo.

1253
01:01:28,240 --> 01:01:30,390
Do ekzistas tiu funkcio
en C, kaj aliaj lingvoj,

1254
01:01:30,390 --> 01:01:33,010
nomita typecasting
ke aŭ implice

1255
01:01:33,010 --> 01:01:37,250
aŭ eksplicite permesas konverti
de unu datumtipo al alia.

1256
01:01:37,250 --> 01:01:39,800
Ni estis kontraktanta tiel
malproksime hodiaŭ kun kordoj.

1257
01:01:39,800 --> 01:01:41,250
>> Kaj kordoj estas karakteroj.

1258
01:01:41,250 --> 01:01:44,910
Sed memoras de semajno
0, kio estas signoj?

1259
01:01:44,910 --> 01:01:49,334
Karakteroj estas nur abstraktaĵo
aldone numbers-- dekumaj nombroj,

1260
01:01:49,334 --> 01:01:52,500
kaj dekumaj nombroj estas vere nur
abstraktado aldone duumaj nombroj,

1261
01:01:52,500 --> 01:01:53,720
kiel ni difinis.

1262
01:01:53,720 --> 01:01:55,540
>> Tiel karakteroj estas nombroj.

1263
01:01:55,540 --> 01:01:58,410
Kaj ciferoj estas signoj,
nur depende de la kunteksto.

1264
01:01:58,410 --> 01:02:01,250
Kaj ĝi rezultas ke ene
de komputila programo,

1265
01:02:01,250 --> 01:02:06,830
vi povas specifi kiom vi volas rigardi
ĉe la bitoj ene de tiu programo?

1266
01:02:06,830 --> 01:02:10,400
>> Revokon de semajno 0 kiu ni havis
Ascii, kiu estas ĝuste tiu kodo

1267
01:02:10,400 --> 01:02:11,620
surĵeto leteroj al nombroj.

1268
01:02:11,620 --> 01:02:13,660
Tial ni diris: ĉefurbo A estas 65.

1269
01:02:13,660 --> 01:02:15,860
Ĉefurbo B estas 66, kaj tiel plu.

1270
01:02:15,860 --> 01:02:20,500
>> Kaj avizo, ni esence havas signoj sur
la supro vico tie, kiel C nomos ilin,

1271
01:02:20,500 --> 01:02:23,400
karakteroj, kaj tiam
ints en la dua vico.

1272
01:02:23,400 --> 01:02:28,180
Kaj ĝi rezultas vi povas konverti
perfekte inter la du, tipe.

1273
01:02:28,180 --> 01:02:30,042
Kaj se ni volas fari
tiun intence, ni

1274
01:02:30,042 --> 01:02:31,750
eble volas pritrakti
io tiamaniere.

1275
01:02:31,750 --> 01:02:33,590
>> Ni eble volas konverti
majuskla malaltigi

1276
01:02:33,590 --> 01:02:35,330
kazo, aŭ minuskla al majuskla.

1277
01:02:35,330 --> 01:02:38,000
Kaj ĝi rezultas ke la
fakte mastro tie

1278
01:02:38,000 --> 01:02:39,900
Ni povas ampleksi en nur momento.

1279
01:02:39,900 --> 01:02:44,120
Sed ni rigardu unua je
Ekzemple fari tion eksplicite.

1280
01:02:44,120 --> 01:02:46,340
>> Mi tuj iros reen en CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Mi tuj kreos
dosiero nomata Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Kaj mi tuj iros antaŭen kaj aldoni miajn
norma io.h ĉe la supro, int ĉefa malplenon

1283
01:02:55,960 --> 01:02:57,370
ĉe la supro de mia funkcio.

1284
01:02:57,370 --> 01:03:02,700
Kaj tiam mi simple tuj fari la
following-- por ciklo de i egalas,

1285
01:03:02,700 --> 01:03:04,610
diru, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Kaj tiam mi tuj estos malpli ol
65, plus 26 literoj en la alfabeto.

1287
01:03:10,460 --> 01:03:12,640
Do mi lasos la komputilo
fari la math por mi tie.

1288
01:03:12,640 --> 01:03:15,100
Kaj tiam ene ĉi maŝo,
kion mi povos presi?

1289
01:03:15,100 --> 01:03:19,230
>> % C estas% i backslash n.

1290
01:03:19,230 --> 01:03:21,290
Kaj nun mi volas ŝtopi en du valoroj.

1291
01:03:21,290 --> 01:03:24,530
Mi provizore metis demandon
markas tie inviti la demando.

1292
01:03:24,530 --> 01:03:29,940
>> Mi volas persisti de 65 pluen
por 26 literoj de la alfabeto,

1293
01:03:29,940 --> 01:03:35,190
presi sur ĉiu ripeto ke
rolulo integra ekvivalento.

1294
01:03:35,190 --> 01:03:38,299
Alivorte, mi volas
persisti super 26 numerojn printado

1295
01:03:38,299 --> 01:03:41,590
kion la Ascii karaktero estas, la litero,
kaj kia la respondan numeron is--

1296
01:03:41,590 --> 01:03:44,650
vere nur amuzante
la diagramo de tiu diapozitivo.

1297
01:03:44,650 --> 01:03:47,010
Do kion devus tiujn demandosignojn esti?

1298
01:03:47,010 --> 01:03:51,760
>> Nu, tio rezultas ke la dua
oni devus simple esti la variablo i.

1299
01:03:51,760 --> 01:03:53,860
Mi volas vidi, ke kiel nombro.

1300
01:03:53,860 --> 01:03:58,920
Kaj la meza argumento
tie, mi povas diri al la komputilo

1301
01:03:58,920 --> 01:04:03,470
trakti ke entjero
I kiel gravulo, tiel kiel

1302
01:04:03,470 --> 01:04:05,880
anstataŭigi ĝin ĉi tie por procento C.

1303
01:04:05,880 --> 01:04:07,990
>> Alivorte, se mi, la
homa programisto, scii

1304
01:04:07,990 --> 01:04:09,865
tiuj estas nur nombroj
fine de la tago.

1305
01:04:09,865 --> 01:04:12,500
Kaj mi scias ke 65 devas
mapi al iu karaktero.

1306
01:04:12,500 --> 01:04:15,310
Kun tiu eksplicita rolantaro,
kun paréntesis,

1307
01:04:15,310 --> 01:04:18,840
la nomo de la datumtipo vi volas
konverti al kaj fermita parentezo,

1308
01:04:18,840 --> 01:04:21,200
vi povas diri la
komputilo, hej, Komputilo,

1309
01:04:21,200 --> 01:04:24,130
konverti ĉi entjero al char.

1310
01:04:24,130 --> 01:04:26,250
>> Do kiam mi kuros ĉi
programo post kompilado,

1311
01:04:26,250 --> 01:04:29,740
ni vidu kion mi get-- fari Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Darn ĝi, kion mi faris malĝuste tie?

1313
01:04:33,020 --> 01:04:35,884
Uzo de nedeklarita ensalutilo,
bone, ne intenca,

1314
01:04:35,884 --> 01:04:37,800
sed ni vidu se ni ne povas
kialo tra tiu.

1315
01:04:37,800 --> 01:04:41,220
>> Do linio five-- tiel mi ne ricevis
tre malproksime antaŭ tedas supren.

1316
01:04:41,220 --> 01:04:42,140
Estas bone.

1317
01:04:42,140 --> 01:04:46,560
Do linio 5 por i egalas 65-- vidas.

1318
01:04:46,560 --> 01:04:50,130
Do memoru, ke en C, kontraste iuj
lingvoj se vi havas antaŭan programado

1319
01:04:50,130 --> 01:04:52,190
sperto, vi havas
diri la komputilo,

1320
01:04:52,190 --> 01:04:55,040
kontraste Scratch, kion
tipo de variablo estas.

1321
01:04:55,040 --> 01:04:56,860
>> Kaj mi forgesis ŝlosilan frazon ĉi tie.

1322
01:04:56,860 --> 01:04:59,200
En linio kvin, Mi komencis uzanta i.

1323
01:04:59,200 --> 01:05:01,560
Sed mi ne diris C
kion datumtipo estas.

1324
01:05:01,560 --> 01:05:04,570
Do mi tuj iros tien kaj
diru, ha, faru gxin entjero.

1325
01:05:04,570 --> 01:05:07,050
>> Nun mi tuj iros antaŭen kaj rekompili.

1326
01:05:07,050 --> 01:05:08,080
Kiu riparis tion.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, jen speco de malvarmeta.

1328
01:05:12,660 --> 01:05:15,360
Ne nur estas ĝi súper rapida al
demandas la komputilo ĉi demandon,

1329
01:05:15,360 --> 01:05:18,885
anstataŭ rigardante ĝin sur tobogano,
ĝi presas el unu po linio, A 65,

1330
01:05:18,885 --> 01:05:24,860
B estas 66, la tutan vojon down-- kiam mi
faris 26 times-- al la literoj z,

1331
01:05:24,860 --> 01:05:25,630
kiu estas 90.

1332
01:05:25,630 --> 01:05:27,790
Kaj, fakte, iomete
pli inteligenta farus

1333
01:05:27,790 --> 01:05:31,030
estis por mi ne fidi
sur la komputilo aldoni 26.

1334
01:05:31,030 --> 01:05:34,060
Mi povus esti simple farita
90 tiel, tiom longe

1335
01:05:34,060 --> 01:05:37,390
kiel mi ne faras la saman eraron dufoje.

1336
01:05:37,390 --> 01:05:41,880
Mi volas iri tra
z, ne nur tra y.

1337
01:05:41,880 --> 01:05:44,000
>> Do jen eksplicita rolantaro.

1338
01:05:44,000 --> 01:05:47,860
Ĝi rezultas ke ĉi
estas eĉ necesa.

1339
01:05:47,860 --> 01:05:52,480
Lasu min antaŭeniri kaj rerun ĉi
tradukilo kaj rerun Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Ĝi rezultas ke C estas sufiĉe inteligenta.

1341
01:05:54,940 --> 01:05:57,150
>> Kaj printf, precipe,
estas sufiĉe inteligenta.

1342
01:05:57,150 --> 01:06:01,260
Se vi simple preterpasas i dufoje
por ambaŭ anstataŭaĵojn, printf

1343
01:06:01,260 --> 01:06:04,510
konstatos, ho, bone mi konas vin
donis al mi integer-- iun numeron,

1344
01:06:04,510 --> 01:06:06,380
kiel 65 aŭ 90, aŭ kion ajn.

1345
01:06:06,380 --> 01:06:10,170
Sed mi vidas ke vi volas ke mi
formati tiun ciferon kiel karaktero.

1346
01:06:10,170 --> 01:06:16,460
Kaj do printf povas implice jxetis
la int al char por vi ankaŭ.

1347
01:06:16,460 --> 01:06:19,360
Do tio ne estas problemo ĉe ĉiuj.

1348
01:06:19,360 --> 01:06:23,100
>> Sed rimarki, pro tio ekvivalenteco
ni povas efektive fari ĉi tiel.

1349
01:06:23,100 --> 01:06:26,520
Lasu min antaŭeniri kaj fari unu
alia versio de this-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
Kaj anstataŭ ripetanta super
entjeroj povas vere blovi vian menson

1351
01:06:31,800 --> 01:06:33,610
per ripetanta super karakteroj.

1352
01:06:33,610 --> 01:06:37,660
Se char c ricevas ĉefurbo A Mi
deziras antaŭeniri kaj fari tion,

1353
01:06:37,660 --> 01:06:41,740
tiel longe kiel C estas malpli ol aŭ egala
al ĉefurbo Z. Kaj en ĉiu ripeto

1354
01:06:41,740 --> 01:06:45,690
Mi volas pliigo C, mi povas
nun mia printf linion tie

1355
01:06:45,690 --> 01:06:51,320
diru, procento C
procento i denove, komo C.

1356
01:06:51,320 --> 01:06:57,200
>> Kaj nun, mi povas iri la alia direkto,
elfandi la karaktero eksplicite

1357
01:06:57,200 --> 01:06:58,500
al entjero.

1358
01:06:58,500 --> 01:07:00,560
Do, denove, kial vi faras tion?

1359
01:07:00,560 --> 01:07:03,830
Ĝi estas iom stranga por ordigi de
kalkuli laŭ karakteroj.

1360
01:07:03,830 --> 01:07:07,430
>> Sed se vi komprenas kion estas
okazas sub la kapuĉo,

1361
01:07:07,430 --> 01:07:08,430
Tie estas vere neniu magio.

1362
01:07:08,430 --> 01:07:13,060
Vi nur diras, hey, komputilo donu
mi variablo nomis C de tipo char.

1363
01:07:13,060 --> 01:07:16,520
Pravalorizi ĝin al ĉefurbo A. Tiam
rimarki solan citaĵoj afero.

1364
01:07:16,520 --> 01:07:19,580
>> Por karakteroj en C, memoras de
pasintsemajne, vi uzas solan citaĵoj.

1365
01:07:19,580 --> 01:07:23,720
Por kordoj, por vortoj,
frazoj, vi uzas duoblan citaĵoj.

1366
01:07:23,720 --> 01:07:27,210
OK, komputilo, daǔre faras tion, do
Dum la karaktero estas malpli ol

1367
01:07:27,210 --> 01:07:28,050
aŭ egala al z.

1368
01:07:28,050 --> 01:07:32,640
Kaj mi scias el mia Ascii tablo, ke ĉiuj
de tiuj Ascii kodoj estas apudaj.

1369
01:07:32,640 --> 01:07:33,400
>> Mankas breĉoj.

1370
01:07:33,400 --> 01:07:36,737
Do estas nur A tra Z,
apartigitaj per unu numeron ĉiu.

1371
01:07:36,737 --> 01:07:38,820
Kaj tiam mi povas pliigo
char, se mi vere volas.

1372
01:07:38,820 --> 01:07:40,390
Fine de la tago,
ĝi estas nur nombro.

1373
01:07:40,390 --> 01:07:41,030
Mi scias tion.

1374
01:07:41,030 --> 01:07:43,670
Do mi povas nur supozi aldoni 1 al ĝi.

1375
01:07:43,670 --> 01:07:46,940
>> Kaj tiam ĉi tiu tempo, Mi presi c,
kaj tiam la integralo ekvivalento.

1376
01:07:46,940 --> 01:07:50,170
Kaj mi eĉ ne bezonas la eksplicitan rolantaro.

1377
01:07:50,170 --> 01:07:52,680
Mi povas lasi printf kaj la
komputilo figuro aferojn,

1378
01:07:52,680 --> 01:07:57,300
por ke nun se mi kuros
fari Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Mi alvenas la ĝusta sama aĵo kiel bone.

1380
01:08:01,520 --> 01:08:04,530
>> Senutila programo, though-- neniu
tuj reale skribi programaron

1381
01:08:04,530 --> 01:08:07,549
por eltrovi, kio estis la
nombro kiu mapas al A, aŭ B, aŭ Z?

1382
01:08:07,549 --> 01:08:10,340
Vi simple tuj Guglas ĝin, aŭ
rigardi ĝin supre enreta, aŭ rigardi ĝin

1383
01:08:10,340 --> 01:08:11,650
sur diapozitivoj, aŭ similaj.

1384
01:08:11,650 --> 01:08:13,520
Do kie tio ĉi reale preni utila?

1385
01:08:13,520 --> 01:08:15,960
>> Nu, parolante pri tio
diapozitivoj, rimarki ekzistas

1386
01:08:15,960 --> 01:08:20,890
fakta padrono tie inter majuskla
kaj minuskla ke ne estis hazarda.

1387
01:08:20,890 --> 01:08:23,760
Rimarku ke ĉefurbo A estas 65.

1388
01:08:23,760 --> 01:08:25,830
Minuskla a estas 97.

1389
01:08:25,830 --> 01:08:29,649
Kaj kiel malproksime estas minuskla a?

1390
01:08:29,649 --> 01:08:32,649
>> Do 65 estas kiom da paŝoj for de 97?

1391
01:08:32,649 --> 01:08:36,210
Do 97 minus 65 estas 32.

1392
01:08:36,210 --> 01:08:37,910
Tial ĉefurbo de 65.

1393
01:08:37,910 --> 01:08:39,939
Se vi aldonas 32 al tiu,
vi ricevas minuskla a.

1394
01:08:39,939 --> 01:08:43,729
Kaj, ekvivalente, se vi subtrahi 32,
vi revenas al ĉefurbo A-- sama kun B

1395
01:08:43,729 --> 01:08:46,380
por iom b, granda C por iom c.

1396
01:08:46,380 --> 01:08:50,670
>> Ĉiuj tiuj mankoj estas 32 dise.

1397
01:08:50,670 --> 01:08:54,450
Nun, ĉi tio ŝajnas permesi nin
fari ion kiel Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
aŭ Google Docs trajto, kie vi
povas elekti ĉiun kaj tiam diru,

1399
01:08:57,729 --> 01:09:00,520
ŝanĝi ĉiujn al minuskla, aŭ
ŝanĝi ĉiujn al majuskla,

1400
01:09:00,520 --> 01:09:03,840
aŭ ŝanĝi nur la unuan vorton
de frazo al majusklo.

1401
01:09:03,840 --> 01:09:07,390
Ni povas efektive fari ion
kiel tiu mem.

1402
01:09:07,390 --> 01:09:12,645
>> Lasu min antaŭeniri kaj savi dosieron
tie nomita kapitaligi 0.c.

1403
01:09:12,645 --> 01:09:15,770
Kaj ni iru antaŭen kaj vipi programon
kiu faras ĝuste tion jene.

1404
01:09:15,770 --> 01:09:18,460
Tiel inkluzivi la CS50 biblioteko.

1405
01:09:18,460 --> 01:09:21,430
Kaj inkludi normo / S.

1406
01:09:21,430 --> 01:09:22,787
>> Kaj mi scias ĉi estas venanta baldaŭ.

1407
01:09:22,787 --> 01:09:24,870
Do mi tuj metis ĝin en
tie jam, string.h,

1408
01:09:24,870 --> 01:09:26,960
do mi havas aliron al
aĵoj kiel Stirling,

1409
01:09:26,960 --> 01:09:29,620
kaj tiam int ĉefa malplenon, kiel kutime.

1410
01:09:29,620 --> 01:09:33,420
Kaj tiam mi iros por antaŭeniri
kaj fari fadenojn ricevas akiri string,

1411
01:09:33,420 --> 01:09:35,032
nur akiri ĉenon de la uzanto.

1412
01:09:35,032 --> 01:09:36,740
Kaj tiam mi tuj
do mia prudento ĉeko.

1413
01:09:36,740 --> 01:09:40,510
Se ŝnuro ne egala nula,
tiam ĝi estas sekure daŭrigi.

1414
01:09:40,510 --> 01:09:42,000
Kaj kion mi volas fari?

1415
01:09:42,000 --> 01:09:48,700
Mi tuj persisti de i egalas 0,
kaj n ĝis la kordo longo de s.

1416
01:09:48,700 --> 01:09:51,899
>> Kaj mi tuj faros tion tiel longe kiel
i estas malpli ol n, kaj i plus plus.

1417
01:09:51,899 --> 01:09:55,060
Ĝis nun, mi estas vere nur
pruntado ideoj de antaŭe.

1418
01:09:55,060 --> 01:09:57,010
Kaj nun mi tuj enkonduki branĉo.

1419
01:09:57,010 --> 01:09:59,635
>> Do pensas reen al Scratch, kie
ni havis tiujn forkoj en la vojo,

1420
01:09:59,635 --> 01:10:05,110
kaj lastan semajnon en C. Mi tuj
diras, se la ia karaktero en s

1421
01:10:05,110 --> 01:10:09,250
estas pli granda ol aŭ
egala malaltigi kazo,

1422
01:10:09,250 --> 01:10:13,340
kaj- en Scratch vi volus laŭvorte
diras kaj, sed en C vi diras ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- kaj la ia karaktero en s
estas malpli ol aŭ egala al minuskla z,

1424
01:10:19,830 --> 01:10:21,780
ni faru ion interesan.

1425
01:10:21,780 --> 01:10:27,020
Ni vere elprinti
karaktero kun neniu lino

1426
01:10:27,020 --> 01:10:31,760
kiu estas la karaktero en la kordo,
la ia karaktero en la kordo.

1427
01:10:31,760 --> 01:10:37,420
>> Sed ni iru antaŭen kaj
subtrahi 32 el ĝi.

1428
01:10:37,420 --> 01:10:42,120
Alie se la karaktero en la
ĉeno kiu ni serĉas

1429
01:10:42,120 --> 01:10:45,950
ne inter iom pli
kaj iom z, antaŭeniri

1430
01:10:45,950 --> 01:10:48,610
kaj simple presas ĝin neŝanĝita.

1431
01:10:48,610 --> 01:10:50,840
Do ni enkondukis
ĉi bracketed notacio

1432
01:10:50,840 --> 01:10:53,560
por nia kordoj akiri ĉe la
ia karaktero en la kordo.

1433
01:10:53,560 --> 01:10:57,520
>> Mi aldonis iom kondiĉa logiko, kiel
Nulo pasintsemajne la semajno, kie

1434
01:10:57,520 --> 01:10:59,880
Mi nur uzas mian fundamenta
komprenon de kio estas

1435
01:10:59,880 --> 01:11:01,130
okazas sub la kapuĉo.

1436
01:11:01,130 --> 01:11:04,190
Estas la ia karaktero de s
pli granda ol aŭ egala al a?

1437
01:11:04,190 --> 01:11:08,290
Kiel, ĉu 97 aŭ 98,
aŭ 99, kaj tiel plu?

1438
01:11:08,290 --> 01:11:11,940
>> Sed estas ankaŭ malpli ol aŭ egala
al la valoro de minuskla z?

1439
01:11:11,940 --> 01:11:16,210
Kaj se jes, kion signifas ĉi tiu linio signifas?

1440
01:11:16,210 --> 01:11:20,250
14, tio estas speco de la
ĝermon de la tuta ideo,

1441
01:11:20,250 --> 01:11:23,840
kapitaligi la leteron per
simple subtrahanta 32 de ĝi,

1442
01:11:23,840 --> 01:11:29,370
en tiu kazo, ĉar mi scias, por ke
abako, kiel mia nombroj estas reprezentitaj.

1443
01:11:29,370 --> 01:11:33,925
Do ni iru antaŭen kaj kuri ĉi,
post kompilado kapitaligi 0.c,

1444
01:11:33,925 --> 01:11:36,210
kaj kuri kapitaligi 0.

1445
01:11:36,210 --> 01:11:40,300
>> Ni entajpi ion kiel
Zamyla en ĉiuj minuskla eniri.

1446
01:11:40,300 --> 01:11:42,780
Kaj nun ni havas Zamyla en ĉiuj majuskle.

1447
01:11:42,780 --> 01:11:45,050
Ni entajpu Rob en ĉiuj minuskla.

1448
01:11:45,050 --> 01:11:46,674
Ni provu Jason en ĉiuj minuskla.

1449
01:11:46,674 --> 01:11:48,590
Kaj ni daŭre ricevas la
devigita kapitaligo.

1450
01:11:48,590 --> 01:11:50,960
Ekzistas negravaj cimoj mi
ia ne anticipis.

1451
01:11:50,960 --> 01:11:54,050
Rimarkos mian novan prompto estas fini
sur la sama linio kiel iliaj nomoj,

1452
01:11:54,050 --> 01:11:55,520
kiu sentas iom senorda.

1453
01:11:55,520 --> 01:11:59,170
>> Do mi tuj iros tien, kaj
fakte fine de tiu ĉi programo

1454
01:11:59,170 --> 01:12:02,110
presi novan linion karaktero.

1455
01:12:02,110 --> 01:12:03,160
Tio estas ĉio.

1456
01:12:03,160 --> 01:12:06,120
Kun printf, vi ne bezonas
En variabloj aŭ formato kodo.

1457
01:12:06,120 --> 01:12:08,460
Vi povas laŭvorte nur presi
iu kiel lino.

1458
01:12:08,460 --> 01:12:13,529
>> Do ni iru antaŭen kaj fari
kapitaligi 0 denove, rerun ĝin, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Kaj nun ĝi estas iom pli bela.

1460
01:12:14,820 --> 01:12:17,274
Nun, mia prompto estas sur lia propra nova linio.

1461
01:12:17,274 --> 01:12:18,440
Do jen ĉio bone kaj bona.

1462
01:12:18,440 --> 01:12:19,910
Do tio estas bona ekzemplo.

1463
01:12:19,910 --> 01:12:22,700
Sed mi eĉ ne bezone
bezonas forte kodo la 32.

1464
01:12:22,700 --> 01:12:23,350
Vi scias kion?

1465
01:12:23,350 --> 01:12:26,350
Mi povus say-- mi ne iam
memori kio la diferenco estas.

1466
01:12:26,350 --> 01:12:29,330
>> Sed mi scias ke se mi
havas minuskla letero,

1467
01:12:29,330 --> 01:12:34,430
Mi esence volas subtrahi for
ajn la distanco estas inter iom

1468
01:12:34,430 --> 01:12:39,160
a kaj granda A, ĉar se mi supozas ke
ĉiuj aliaj literoj estas samaj,

1469
01:12:39,160 --> 01:12:41,045
ke devus akiri la laborpostenon farita.

1470
01:12:41,045 --> 01:12:42,670
Sed anstataŭ fari tion, vi scias kion?

1471
01:12:42,670 --> 01:12:44,240
Ekzistas alia vojo ankoraŭ.

1472
01:12:44,240 --> 01:12:48,090
>> Se tio estas kapitaligi 1.c-- se mi estus
meti tiun en aparta dosiero.

1473
01:12:48,090 --> 01:12:51,030
ni ja kapitaligi 2.c jene.

1474
01:12:51,030 --> 01:12:53,060
Mi tuj vere purigi ĉi supre.

1475
01:12:53,060 --> 01:12:57,420
Kaj anstataŭ eĉ devi
scias aŭ zorgas pri tiuj malaltaj nivelo

1476
01:12:57,420 --> 01:13:01,090
efektivigo detaloj, mi anstataŭe
nur tuj presi karaktero,

1477
01:13:01,090 --> 01:13:04,610
citaĵo unquote, procento C, kaj
tiam nomita alia funkcio kiu

1478
01:13:04,610 --> 01:13:09,950
ekzistas kiu prenas argumenton,
kiu estas karaktero, kiel tiu.

1479
01:13:09,950 --> 01:13:12,630
>> Rezultas en C, estas
alia funkcio alvoko

1480
01:13:12,630 --> 01:13:15,550
al supra, kiu kiel lia nomo
sugestas prenas karaktero

1481
01:13:15,550 --> 01:13:19,350
kaj faras liajn majusklo
ekvivalento, kaj tiam revenas

1482
01:13:19,350 --> 01:13:21,410
por ke printf povas ŝtopi ĝin en tie.

1483
01:13:21,410 --> 01:13:25,484
Kaj tiel fari tion, kvankam mi
bezonas enkonduki unu alia dosiero.

1484
01:13:25,484 --> 01:13:28,400
Ĝi rezultas tie estas alia dosiero
ke vi nur scias de klaso,

1485
01:13:28,400 --> 01:13:33,020
aŭ lernolibron, aŭ reta
referenco, nomata C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Do se mi aldonas ke en Mia kaplinio
dosierojn, kaj nun re-kompili tiun programon,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Ni entajpu Zamyla en ĉiuj
minuskle, ankoraŭ funkcias same.

1489
01:13:46,690 --> 01:13:48,040
Sed vi scias kion?

1490
01:13:48,040 --> 01:13:55,590
Ĝi rezultas ke al supra
havas alian funkcion.

1491
01:13:55,590 --> 01:13:58,410
>> Kaj lasu min enkonduki tiun
ordonas tie, ia mallerte

1492
01:13:58,410 --> 01:14:00,250
nomata, sed viro por manlibro.

1493
01:14:00,250 --> 01:14:03,960
Ĝi rezultas ke la plimulto Linukso komputiloj,
kiel ni uzas here-- Linukso mastruma

1494
01:14:03,960 --> 01:14:06,270
system-- havas komandon
nomita viro, kiu diras:

1495
01:14:06,270 --> 01:14:08,530
hej, komputilo, donu al mi
la komputilo manlibro.

1496
01:14:08,530 --> 01:14:10,680
Kion vi volas
serĉi en tiu manlibro?

1497
01:14:10,680 --> 01:14:13,840
>> Mi volas serĉi la funkcio
vokis supra, Enter.

1498
01:14:13,840 --> 01:14:16,070
Kaj ĝi estas iom kamufla
legi foje.

1499
01:14:16,070 --> 01:14:18,780
Sed rimarkas ke ni estas en la
Linukso programisto manlibro.

1500
01:14:18,780 --> 01:14:19,530
Kaj ĝi estas ĉiuj tekstoj.

1501
01:14:19,530 --> 01:14:21,905
Kaj rimarki ke estas la
nomo de la funkcio ĝis tie.

1502
01:14:21,905 --> 01:14:25,030
Rezultas ĝi havas kuzon nomitan
malaltigi, kiuj faras la malon.

1503
01:14:25,030 --> 01:14:29,710
Kaj avizo sub sinopsis, uzi tiun
funkcii la viro paĝo, por tiel diri,

1504
01:14:29,710 --> 01:14:32,220
diras al mi ke mi
bezonas inkluzivi c type.h.

1505
01:14:32,220 --> 01:14:33,630
Kaj mi sciis, ke de praktiko.

1506
01:14:33,630 --> 01:14:36,210
>> Tie, ĝi montras al mi la du
prototipoj por la funkcio,

1507
01:14:36,210 --> 01:14:39,070
tiel ke se mi iam volas uzi tiun
Mi scias, kion ili faras kiel enigo,

1508
01:14:39,070 --> 01:14:40,652
kaj kion ili revenas kiel eligo.

1509
01:14:40,652 --> 01:14:42,360
Kaj tiam se mi legas
la priskribo, mi vidas

1510
01:14:42,360 --> 01:14:44,820
pli detale kion la funkcio faras.

1511
01:14:44,820 --> 01:14:48,100
Sed pli grave, se
Mi rigardas sub reveno valoro,

1512
01:14:48,100 --> 01:14:51,710
diras la valoro revenis estas
ke de la konvertita leteron,

1513
01:14:51,710 --> 01:14:57,880
aŭ C, la origina enigo, se
la konvertiĝo ne estis ebla.

1514
01:14:57,880 --> 01:15:01,992
>> Alivorte, al supra provos
konverti letero al majusklo.

1515
01:15:01,992 --> 01:15:03,450
Kaj se jes, ĝi estas tuj revenos ĝin.

1516
01:15:03,450 --> 01:15:07,010
Sed se ĝi ne povas por iu reason--
eble estas jam majuskla,

1517
01:15:07,010 --> 01:15:09,550
Eble estas ekkrion punkto
aŭ alian punctuation--

1518
01:15:09,550 --> 01:15:12,200
ĝi estas nur tuj
reveni la originalan C,

1519
01:15:12,200 --> 01:15:17,340
kio signifas mi povas fari mian kodo
bone desegnitaj kiel sekvas.

1520
01:15:17,340 --> 01:15:20,580
>> Mi ne bezonas ĉiujn
tiuj Darn linioj de kodo.

1521
01:15:20,580 --> 01:15:22,610
Ĉiuj linioj mi havas
nur reliefigis povas

1522
01:15:22,610 --> 01:15:28,700
esti kaŝata en nur unu simplan
linio, kiu estas this-- printf procento

1523
01:15:28,700 --> 01:15:33,510
c al supra S krampo i.

1524
01:15:33,510 --> 01:15:36,090
Kaj tio estus
ekzemplo de bona desegno.

1525
01:15:36,090 --> 01:15:40,040
>> Kial apliki en 7 aŭ 8 linioj
de kodo, kio ajn ĝi estis, mi ĵus

1526
01:15:40,040 --> 01:15:44,960
forigita, kiam vi povas anstataŭe kolapsi
ĉiuj ke logiko kaj decidado

1527
01:15:44,960 --> 01:15:49,620
en unu sola linio, 13 nun, ke
dependas biblioteko function--

1528
01:15:49,620 --> 01:15:53,430
funkcio kiu venas kun C, sed ke
faras precize kion vi volas fari.

1529
01:15:53,430 --> 01:15:55,295
Kaj, sincere, eĉ se
ĝi ne venas kun C,

1530
01:15:55,295 --> 01:15:58,880
vi povus apliki ĝin mem, kiel
ni vidis, per akiri negativan int

1531
01:15:58,880 --> 01:16:01,700
kaj akiri pozitivajn int lasta semajno ankaŭ.

1532
01:16:01,700 --> 01:16:03,470
>> Tiu kodo nun estas multe pli legebla.

1533
01:16:03,470 --> 01:16:06,670
Kaj cetere, se ni rulumu supren,
aspektas kiel multe pli kompakta

1534
01:16:06,670 --> 01:16:08,360
tiu versio de mia programo estas.

1535
01:16:08,360 --> 01:16:11,230
Estas iom pintaj pezaj nun,
kun ĉiuj tiuj inkludas.

1536
01:16:11,230 --> 01:16:14,380
Sed tio estas bone, ĉar nun mi staras
sur la ŝultroj de programistoj

1537
01:16:14,380 --> 01:16:15,300
antaŭ mi.

1538
01:16:15,300 --> 01:16:18,440
Kaj kiu estis kiu
implementado por supra vere

1539
01:16:18,440 --> 01:16:21,470
faris al mi komplezon, tre kiel ajn
implementado Stirling vere

1540
01:16:21,470 --> 01:16:24,790
faris al mi komplezon iun tempon.

1541
01:16:24,790 --> 01:16:26,970
Kaj do nun ni havas
bona dezajno programo

1542
01:16:26,970 --> 01:16:31,680
kiu implementa la ĝusta sama logiko.

1543
01:16:31,680 --> 01:16:35,580
>> Parolante de Stirling, lasu
min antaŭeniri kaj fari tion.

1544
01:16:35,580 --> 01:16:38,320
Lasu min antaŭeniri kaj savi
dosiero kiel stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Kaj ĝi rezultas, ni povas senŝeligi reen
unu alia tavolo bela simple nun.

1546
01:16:43,255 --> 01:16:45,630
Mi tuj iros antaŭen kaj vipo
alian programon en ĉefa

1547
01:16:45,630 --> 01:16:49,759
tie kiu simple re-ilojn
string longo jene.

1548
01:16:49,759 --> 01:16:52,300
Do jen linion de kodo ke
akiras min ĉenon de la uzanto.

1549
01:16:52,300 --> 01:16:53,910
Ni daǔre uzante ĉi denove kaj denove.

1550
01:16:53,910 --> 01:16:58,900
Lasu min donu min variablon nomata
n de tipo int kiu stokas kelkajn.

1551
01:16:58,900 --> 01:17:02,490
>> Kaj lasu min antaŭeniri kaj
fari la sekvan logiko.

1552
01:17:02,490 --> 01:17:15,610
Dum la n-a karaktero en s faras
Ne valoregalas backslash 0, antaŭeniri

1553
01:17:15,610 --> 01:17:17,930
kaj pliigo n.

1554
01:17:17,930 --> 01:17:23,506
Kaj tiam presi printf procento i n.

1555
01:17:23,506 --> 01:17:29,200
Mi asertas ke tiu programo tie,
sen nomi ĉenon longo,

1556
01:17:29,200 --> 01:17:31,150
figuroj el la longo de kordo.

1557
01:17:31,150 --> 01:17:34,600
>> Kaj la magio estas tute
encapsulada en linio 8

1558
01:17:34,600 --> 01:17:39,830
tie kun kio aspektas kiel nova sintakso,
ĉi backslash 0 en simpla citaĵoj.

1559
01:17:39,830 --> 01:17:41,360
Sed kial estas tio?

1560
01:17:41,360 --> 01:17:44,100
Nu, pripensu kion estas estita
irante sur tiu tuta tempo.

1561
01:17:44,100 --> 01:17:47,990
>> Kaj kiel flanken, antaŭ ol mi forgesas, realigi
tro, ke krom la viro paĝoj

1562
01:17:47,990 --> 01:17:50,920
kiuj venas kun tipa
Linuksa sistemo kiel CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
rimarkas ke ni, la
Kompreneble stabo, havas ankaŭ

1564
01:17:53,770 --> 01:17:56,030
faris retpaĝaro versio
de tiu sama ideo nomita

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, kiu havas
ĉiuj el tiuj samaj paĝoj de man,

1566
01:17:59,940 --> 01:18:02,020
ĉiuj de tiu sama
dokumentado, tiel kiel

1567
01:18:02,020 --> 01:18:05,730
iom skatolo ĉe la supro kiuj permesas
vi konverti ĉiujn sufiĉe

1568
01:18:05,730 --> 01:18:09,025
arcano lingvo en malpli komforta
reĝimo, kie ni, la instruisteco,

1569
01:18:09,025 --> 01:18:12,150
trairos kaj provis simpligi
iuj de la lingvo por teni aferojn

1570
01:18:12,150 --> 01:18:14,830
temigis la ideojn kaj ne
iuj de la tecnicismos.

1571
01:18:14,830 --> 01:18:20,070
Do memoru, reference.cs50.net
kiel alia rimedo tiel.

1572
01:18:20,070 --> 01:18:23,800
>> Sed por kio string longo laboro en
la vojo mi proponis antaŭ momento?

1573
01:18:23,800 --> 01:18:25,160
Jen Zamyla nomon denove.

1574
01:18:25,160 --> 01:18:27,690
Kaj jen Zamyla nomon
boksis en, kiel mi daŭre fari,

1575
01:18:27,690 --> 01:18:31,360
pentri bildon de ĝi estante,
vere, nur vico de signoj.

1576
01:18:31,360 --> 01:18:34,260
Sed Zamyla ne ekzistas
izole en programo.

1577
01:18:34,260 --> 01:18:37,420
>> Kiam vi skribas kaj ruli programon,
vi uzas via Mac aŭ via PC

1578
01:18:37,420 --> 01:18:40,010
kiel memoro, aŭ RAM tiel diri.

1579
01:18:40,010 --> 01:18:42,620
Kaj vi povas pensi
vian komputilon kiel havado

1580
01:18:42,620 --> 01:18:44,730
multaj gigabajtoj de memoro tiujn tagojn.

1581
01:18:44,730 --> 01:18:47,700
Kaj koncerton signifas miliardoj,
do miliardoj da bajtoj.

1582
01:18:47,700 --> 01:18:48,910
>> Sed ni malantaŭenigi ĝustatempe.

1583
01:18:48,910 --> 01:18:51,530
Kaj supozu ke ni uzas
vere malnova komputilo kiu

1584
01:18:51,530 --> 01:18:55,150
nur havas 32 bajtoj de memoro.

1585
01:18:55,150 --> 01:18:59,310
Mi povus, sur mia komputila ekrano,
simple desegni ĉi ekstere kiel sekvas.

1586
01:18:59,310 --> 01:19:05,240
>> Mi povis simple diri ke mia
komputilo havas ĉiujn ĉi memoro.

1587
01:19:05,240 --> 01:19:08,830
Kaj tio estas simila al peco da memoro, se
vi memoras nian bildon de lasta tempo.

1588
01:19:08,830 --> 01:19:11,670
Kaj se mi simple dividi
ĉi en sufiĉe tempo,

1589
01:19:11,670 --> 01:19:15,040
Mi asertas ke mi havas 32 bajtoj
de memoro sur la ekrano.

1590
01:19:15,040 --> 01:19:18,239
>> Nun, en realo, mi povas nur
tiri ĝis nun sur ĉi tiu ekrano tie.

1591
01:19:18,239 --> 01:19:20,280
Do mi tuj iros antaŭen,
kaj kun nur konvencio,

1592
01:19:20,280 --> 01:19:24,050
desegni mia komputilo memoro kiel
krado, ne nur kiel unu rekto.

1593
01:19:24,050 --> 01:19:28,190
Specife, mi asertas nun ke
tiu krado, tiu 8 de 4 krado,

1594
01:19:28,190 --> 01:19:31,800
nur reprezentas ĉiuj 32 bajtoj
de disponebla memoro en mia Mac,

1595
01:19:31,800 --> 01:19:33,030
aŭ disponeblaj en mia PC.

1596
01:19:33,030 --> 01:19:34,780
Kaj ili estas ĉirkaŭvolvinte
sur du linioj, nur

1597
01:19:34,780 --> 01:19:38,030
ĉar ĝi persvadas pli sur la ekrano.

1598
01:19:38,030 --> 01:19:40,800
Sed tiu estas la unua bitoko.

1599
01:19:40,800 --> 01:19:41,990
Tio estas la dua bajto.

1600
01:19:41,990 --> 01:19:43,300
Tiu estas la tria bitoko.

1601
01:19:43,300 --> 01:19:45,310
>> Kaj tio estas la 32-a bitoko.

1602
01:19:45,310 --> 01:19:52,910
Aŭ, se ni pensas kiel komputilo
sciencisto, tiu estas bajto 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Do vi havas 0 al 31, se
vi komencas rakontante 0.

1604
01:19:55,950 --> 01:19:59,830
>> Do se ni uzas programon
ke alvokoj akiri string,

1605
01:19:59,830 --> 01:20:05,280
kaj ni preni ĉenon de la homa
kiel mi nomis Zamyla, Z-Al-M-Kaj-L-A,

1606
01:20:05,280 --> 01:20:09,430
kiom en la mondo faras la
komputilo sekvigi kiu bajto,

1607
01:20:09,430 --> 01:20:12,230
kiun eron de memoro,
apartenas al kiuj kordoj?

1608
01:20:12,230 --> 01:20:16,270
Alivorte, se ni plue
tajpi alian nomon en la komputilo,

1609
01:20:16,270 --> 01:20:19,890
tiel Andi, nomante
akiri string duafoje,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-Mi devas fini en la
komputila memoro same.

1611
01:20:23,030 --> 01:20:23,850
Sed kiel?

1612
01:20:23,850 --> 01:20:29,700
>> Nu, tio rezultas ke sub la
kapuĉo, kio C faras kiam stokante kordoj

1613
01:20:29,700 --> 01:20:35,080
ke la homaj tipoj en, aŭ ke
venis el iu alia fonto, estas

1614
01:20:35,080 --> 01:20:39,190
konturas la finon kun
speciala character-- backslash

1615
01:20:39,190 --> 01:20:44,750
0, kiu estas nur speciala maniero
diri 80 bitoj en vico.

1616
01:20:44,750 --> 01:20:47,950
>> Tiel A-- tiu estas la nombro 97 revokon.

1617
01:20:47,950 --> 01:20:51,770
Do iu mastro de 8 bitoj
reprezentas du ciferoj 97.

1618
01:20:51,770 --> 01:20:58,070
Ĉi backslash 0 estas laŭvorte la numeron
0, a.k.a. nul, N-U-L, kontraste antaŭe,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, kiun ni parolis.

1620
01:20:59,630 --> 01:21:05,700
Sed nuntempe, nur scias, ke tiu
backslash 0 estas nur 80 bitoj en vico.

1621
01:21:05,700 --> 01:21:09,810
>> Kaj ĝi estas nur jena linio en la
sablo diros ion al la maldekstra

1622
01:21:09,810 --> 01:21:12,610
apartenas al unu ŝnuro, aŭ unu datumtipo.

1623
01:21:12,610 --> 01:21:15,480
Kaj ion dekstren
apartenas al io alia.

1624
01:21:15,480 --> 01:21:17,440
Andi nomo, dume,
kiu nur vide

1625
01:21:17,440 --> 01:21:21,310
okazas volvi sur la alia linio,
sed tio estas nur estetika detalo,

1626
01:21:21,310 --> 01:21:23,990
simile estas nul finita.

1627
01:21:23,990 --> 01:21:29,290
>> Ĝi estas ĉeno de Al-N-D-Mi karakteroj,
plus kvina sekreta karaktero,

1628
01:21:29,290 --> 01:21:33,560
ĉiuj 0 bitoj, ke nur demarca
Fine de Andi nomo ankaŭ.

1629
01:21:33,560 --> 01:21:37,120
Kaj se ni nomas akiri string trian fojon
en la komputilo por akiri ĉenon kiel

1630
01:21:37,120 --> 01:21:44,210
Maria, G-Al-R-mi-A, simile estas Maria
nomo nul finita kun backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Tio estas fundamente malsama
de kiel komputilo estus tipe

1632
01:21:47,170 --> 01:21:51,850
stoki entjero aŭ kaleŝego, aŭ aliaj
datumtipoj ankoraŭ, ĉar revokon,

1633
01:21:51,850 --> 01:21:57,420
entjero estas ĝenerale 32 bitoj, aŭ
4 bajtoj, aŭ eble eĉ 64 bitoj,

1634
01:21:57,420 --> 01:21:59,100
aŭ ok bajtoj.

1635
01:21:59,100 --> 01:22:02,620
Sed multaj primitivoj en komputilo
en programlingvo

1636
01:22:02,620 --> 01:22:05,550
havas fiksan nombron de
bajtoj sub la hood--

1637
01:22:05,550 --> 01:22:08,100
eble 1, eble 2, eble 4, eble 8.

1638
01:22:08,100 --> 01:22:13,250
>> Sed kordojn, per dezajno, havi
dinamika nombro de karakteroj.

1639
01:22:13,250 --> 01:22:16,980
Vi ne scias anticipe, gxis
la homaj tipoj en Z-Al-M-Kaj-L-A,

1640
01:22:16,980 --> 01:22:21,400
aŭ M-A-R-mi-A, aŭ A-N-D-Mi. Vi ne konas
kiom da fojoj la uzanto tuj trafis

1641
01:22:21,400 --> 01:22:22,070
la klavaro.

1642
01:22:22,070 --> 01:22:26,490
Tial vi ne scipovas
multaj karakteroj anticipe

1643
01:22:26,490 --> 01:22:27,540
Vi tuj bezonas.

1644
01:22:27,540 --> 01:22:31,840
>> Kaj do C nur speco de folioj kiel
sekreta breadcrumb sub la kapuĉo

1645
01:22:31,840 --> 01:22:32,960
fine de la kordo.

1646
01:22:32,960 --> 01:22:39,280
Post stokante Z-Al-M-Kaj-L-A en memoro,
ĝi ankaŭ simple metas la ekvivalenta

1647
01:22:39,280 --> 01:22:40,210
de periodo.

1648
01:22:40,210 --> 01:22:45,060
Fine de frazo,
ĝi metas 80 bitoj, tiel kiel

1649
01:22:45,060 --> 01:22:49,120
memori kie
Zamyla komenciĝas kaj finiĝas.

1650
01:22:49,120 --> 01:22:51,490
>> Do kio estas la rilato,
tiam, por tiu programo?

1651
01:22:51,490 --> 01:22:55,190
Tiu programo tie, Stirling,
estas simple mekanismo

1652
01:22:55,190 --> 01:22:57,970
por interesigi kordo
de la uzanto, la linio 6.

1653
01:22:57,970 --> 01:23:01,160
Linio 7, mi deklaras variablon
nomis n kaj starigis ĝin egala al 0.

1654
01:23:01,160 --> 01:23:08,680
>> Kaj tiam en linio 8, mi simple demandis la
demando, dum la n-a karaktero faras

1655
01:23:08,680 --> 01:23:12,120
Ne valoregalas ĉiuj 0 bits--
alivorte, ne

1656
01:23:12,120 --> 01:23:14,500
egala tiu speciala
karaktero, backslash 0, kiu

1657
01:23:14,500 --> 01:23:18,470
Estis ĝuste tiu speciala nul character--
iri antaŭen kaj nur pliigo n.

1658
01:23:18,470 --> 01:23:21,460
>> Kaj daŭre fari ĝin, kaj konservi
farante ĝin, kaj daŭre fari ĝin.

1659
01:23:21,460 --> 01:23:23,430
Kaj tial, kvankam en
la pasinteco ni uzis i,

1660
01:23:23,430 --> 01:23:25,181
ĝi estas perfekte bone
semantike uzi n,

1661
01:23:25,181 --> 01:23:27,430
se vi nur provas
kalkuli ĉi tempo intence,

1662
01:23:27,430 --> 01:23:28,720
kaj nur volas nomi ĝin n.

1663
01:23:28,720 --> 01:23:34,720
Do ĉi nur tenas demandanta la demandon,
estas la n-a karaktero de s ĉiuj _0s_?

1664
01:23:34,720 --> 01:23:38,470
Se ne, rigardu al la sekva rigardo,
rigardi al la sekva, rigardi al la proksima,

1665
01:23:38,470 --> 01:23:39,460
rigardi al la sekva.

1666
01:23:39,460 --> 01:23:45,540
>> Sed tuj kiam vi vidos backslash 0,
ĉi loop-- linio 9 tra 11-- haltas.

1667
01:23:45,540 --> 01:23:49,640
Vi rompi la dum buklo,
lasante ene de tiu variablo n

1668
01:23:49,640 --> 01:23:54,530
tuta grafo de ĉiuj
karakterojn en la kordo vi vidis,

1669
01:23:54,530 --> 01:23:55,660
tiel videbligi ĝin.

1670
01:23:55,660 --> 01:23:56,760
Do ni provu tion.

1671
01:23:56,760 --> 01:23:59,500
>> Lasu min antaŭeniri kaj, sen
uzante la Stirling funkcio,

1672
01:23:59,500 --> 01:24:04,240
sed nur per mia propra memfarita versio
tie nomita Stirling, lasu min antaŭeniri

1673
01:24:04,240 --> 01:24:07,700
kaj kuri Stirling, tajpu ion
kiel Zamyla, kion mi scias anticipe

1674
01:24:07,700 --> 01:24:08,670
Estas ses karakteroj.

1675
01:24:08,670 --> 01:24:10,080
Ni vidu se tio funkcias.

1676
01:24:10,080 --> 01:24:10,920
Efektive, ĝi estas ses.

1677
01:24:10,920 --> 01:24:15,257
Ni provu kun Rob, tri karakteroj,
tri karakteroj tiel, kaj tiel plu.

1678
01:24:15,257 --> 01:24:17,340
Do jen ĉio tio okazas
sur sub la kapuĉo.

1679
01:24:17,340 --> 01:24:19,548
Kaj rimarki la rilatoj,
tiam, kun la unua semajno

1680
01:24:19,548 --> 01:24:22,370
de klaso, kie ni parolis pri
io kiel abstraktado,

1681
01:24:22,370 --> 01:24:26,960
kiu estas ĝuste ĉi layering de ideoj, aŭ
komplekseco, aldone bazajn principojn.

1682
01:24:26,960 --> 01:24:30,710
Tie, ni ia rigardanta
sub la kapuĉo de Stirling,

1683
01:24:30,710 --> 01:24:33,510
por tiel diri, por eltrovi,
Kiel volus i esti implementado?

1684
01:24:33,510 --> 01:24:35,232
>> Kaj ni povus re-apliki ĝin mem.

1685
01:24:35,232 --> 01:24:37,440
Sed ni ne plu iros
re-apliki Stirling.

1686
01:24:37,440 --> 01:24:39,780
Ni nur tuj
uzi Stirling por

1687
01:24:39,780 --> 01:24:42,100
por fakte atingi iuj kordoj longo.

1688
01:24:42,100 --> 01:24:44,200
>> Sed estas nenia magio
sub la kapuĉo.

1689
01:24:44,200 --> 01:24:46,716
Se vi scias, ke sub
la kapuĉo, ŝnuro

1690
01:24:46,716 --> 01:24:48,090
estas nur vico de signoj.

1691
01:24:48,090 --> 01:24:51,090
Kaj ke sekvenco de karakteroj
ĉiuj povas ciferece adresita

1692
01:24:51,090 --> 01:24:53,330
kun krampo 0, krampo
1, krampo 2, kaj vi

1693
01:24:53,330 --> 01:24:57,420
scias ke fine de ŝnuro estas
speciala karaktero, vi povas diveni

1694
01:24:57,420 --> 01:25:01,710
kiel fari preskaŭ kion ajn en
programo, ĉar ĉiuj bolas malsupren al

1695
01:25:01,710 --> 01:25:03,400
legas kaj skribas memoron.

1696
01:25:03,400 --> 01:25:06,130
Te, ŝanĝanta kaj rigardanta
en memoro, aŭ rampajxoj

1697
01:25:06,130 --> 01:25:10,940
ĉirkaŭe en memoro, presanta aferojn
sur la ekrano, kaj tiel plu.

1698
01:25:10,940 --> 01:25:14,800
>> Do ni nun uzas ĉi ĵus trovita
kompreno de kio cenoj reale

1699
01:25:14,800 --> 01:25:17,910
estas sub la kapuĉo, kaj
senŝeligi reen alia tavolo

1700
01:25:17,910 --> 01:25:20,080
ke ĝis nun ni havas
estis ignorante entute.

1701
01:25:20,080 --> 01:25:22,650
Precipe ajn
ni implementado programon,

1702
01:25:22,650 --> 01:25:25,930
ni havis tiun linion de kodo
proksime de la pinto deklarante ĉefa.

1703
01:25:25,930 --> 01:25:27,810
Kaj ni specifis int ĉefa malplenon.

1704
01:25:27,810 --> 01:25:31,240
>> Kaj ke malplenon ene la parantezoj
estis dirante ĉiuj ĉi tempo, ke ĉefa

1705
01:25:31,240 --> 01:25:33,440
mem ne prenas neniun argumentoj.

1706
01:25:33,440 --> 01:25:36,210
Ajna enigo ke ĉefa estas
tuj preni de la uzanto

1707
01:25:36,210 --> 01:25:39,020
devas veni de iu alia
mekanismo, kiel get int,

1708
01:25:39,020 --> 01:25:42,040
aŭ akiri kaleŝego, aŭ akiri kordo,
aŭ alian funkcion.

1709
01:25:42,040 --> 01:25:44,710
Sed rezultu ke
kiam vi skribas programon,

1710
01:25:44,710 --> 01:25:47,690
Vi povas fakte specifi
ke tiu programo estos

1711
01:25:47,690 --> 01:25:51,730
preni enigoj de la homa
ĉe la komandlinio mem.

1712
01:25:51,730 --> 01:25:56,310
>> Alivorte, kvankam ni ĝis nun
havas kuris nur ./hello saluton

1713
01:25:56,310 --> 01:26:00,312
aŭ similaj programoj, ĉiuj
aliaj programoj kiuj ni estis uzante,

1714
01:26:00,312 --> 01:26:02,770
ke ni mem ne skribis,
havi estita prenanta, ŝajnas,

1715
01:26:02,770 --> 01:26:05,210
komandlinio arguments--
aĵoj kiel ŝminko.

1716
01:26:05,210 --> 01:26:07,450
Vi diras ion kiel ŝminko,
kaj tiam duan vorton.

1717
01:26:07,450 --> 01:26:10,950
Aŭ tin, vi diras Clang, kaj tiam
dua vorto, la nomo de dosiero.

1718
01:26:10,950 --> 01:26:14,410
>> Aŭ eĉ RM aŭ CP, kiel vi povus
vidis aŭ uzis jam

1719
01:26:14,410 --> 01:26:15,880
forigi aŭ kopii dosierojn.

1720
01:26:15,880 --> 01:26:18,920
Ĉiuj tiuj preni tn
komandlinio arguments--

1721
01:26:18,920 --> 01:26:21,130
aldona vortoj en la terminalo prompto.

1722
01:26:21,130 --> 01:26:23,260
Sed ĝis nun, ni
mem ne havis

1723
01:26:23,260 --> 01:26:27,080
tiun lukson de preni enigo de la
uzanto kiam li aŭ ŝi vere kuras

1724
01:26:27,080 --> 01:26:29,120
la programo mem ĉe la komandlinio.

1725
01:26:29,120 --> 01:26:33,710
>> Sed ni povas fari tion per re-deklarante
ĉefa movanta antaŭen, ne havanta

1726
01:26:33,710 --> 01:26:36,750
void en krampoj,
sed tiuj du argumentoj

1727
01:26:36,750 --> 01:26:40,600
instead-- la unua entjero,
kaj la dua io

1728
01:26:40,600 --> 01:26:44,170
nova, iu kiun ni iras por voki
tabelo, io simila en spirito

1729
01:26:44,170 --> 01:26:49,220
al kion ni vidis en Scratch kiel listo, sed
tabelo de kordoj, kiel ni baldaŭ vidos.

1730
01:26:49,220 --> 01:26:51,790
Sed ni vidu tion
vojo de ekzemplo, antaŭ ni

1731
01:26:51,790 --> 01:26:53,690
distingi precize kion tio signifas.

1732
01:26:53,690 --> 01:26:56,520
>> Do se mi iros en CS50 IDE
tie, mi antaŭeniris

1733
01:26:56,520 --> 01:27:01,840
kaj deklaris en dosiero nomata
argv0.c la sekvan ŝablonon.

1734
01:27:01,840 --> 01:27:04,120
Kaj rimarki la sola
jen malsamaj ĝis nun

1735
01:27:04,120 --> 01:27:08,570
estas ke mi ŝanĝis malplenon al int
argc ŝnuro argv malferma krampo, fermi

1736
01:27:08,570 --> 01:27:09,070
krampo.

1737
01:27:09,070 --> 01:27:11,730
Kaj rimarki nun, ekzistas
nenio ene de tiuj krampoj.

1738
01:27:11,730 --> 01:27:12,620
>> Ekzistas neniu nombro.

1739
01:27:12,620 --> 01:27:15,070
Kaj ekzistas neniu i, aŭ
n, aŭ ajna alia letero.

1740
01:27:15,070 --> 01:27:17,010
Mi nur uzis la
rektaj krampoj por nun,

1741
01:27:17,010 --> 01:27:19,510
pro kialoj ni venis
reen al en nur momento.

1742
01:27:19,510 --> 01:27:21,330
>> Kaj nun kion mi tuj faros estas tio.

1743
01:27:21,330 --> 01:27:26,680
Se argc egalas egalas 2--
kaj memoras ke egalas egaluloj

1744
01:27:26,680 --> 01:27:30,040
estas la egaleco operatoro komparante
maldekstre kaj dekstre por egaleco.

1745
01:27:30,040 --> 01:27:31,790
Ĝi ne estas la asigno
operatoro, kiu estas

1746
01:27:31,790 --> 01:27:36,510
la sola egalsigno, kiu signifas ekzempleron
de dekstre maldekstren iu valoro.

1747
01:27:36,510 --> 01:27:42,840
>> Se argc egalas egalas 2, mi volas
diru printf, saluton, cent, nova linio,

1748
01:27:42,840 --> 01:27:47,340
kaj tiam plug in-- kaj jen la nova
trick-- argv krampo 1, por kialoj

1749
01:27:47,340 --> 01:27:48,840
ke ni revenos al en momento.

1750
01:27:48,840 --> 01:27:52,110
Alie se argc ne
egala 2, vi scias kion?

1751
01:27:52,110 --> 01:27:57,400
Ni nur iri antaŭen kaj, kiel kutime, presaĵo
eksteren saluton mondo sen anstataŭigo.

1752
01:27:57,400 --> 01:28:02,710
>> Tiel similus ke se argc, kiu
signifas argumento grafo, egalas 2,

1753
01:28:02,710 --> 01:28:04,740
Mi tuj presi
saluton io aŭ alia.

1754
01:28:04,740 --> 01:28:07,560
Alie, implicite, mi estas
presigos saluton mondo.

1755
01:28:07,560 --> 01:28:08,770
Do kion tio signifas?

1756
01:28:08,770 --> 01:28:15,550
>> Nu, lasu min antaŭeniri kaj savi
dosiero, kaj tiam ja faras argv0,

1757
01:28:15,550 --> 01:28:18,940
kaj tiam ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Kaj ĝi diras saluton mondo.

1759
01:28:20,300 --> 01:28:21,260
Nun, kial do?

1760
01:28:21,260 --> 01:28:24,730
>> Nu, tio rezultas anytime vi
ruli programon ĉe la komandlinio,

1761
01:28:24,730 --> 01:28:29,570
vi plenigas en kio ni
ĝenerale nomas argumento vektoro.

1762
01:28:29,570 --> 01:28:33,100
Alivorte, aŭtomate la
komputilo, la mastruma sistemo,

1763
01:28:33,100 --> 01:28:38,340
tuj transdonos al via programo
mem liston de ĉiuj el la vortoj

1764
01:28:38,340 --> 01:28:40,850
ke la homa tajpita ĉe
la prompto, en kazo vi

1765
01:28:40,850 --> 01:28:43,790
la programisto volas fari
ion kun tiu informo.

1766
01:28:43,790 --> 01:28:48,540
Kaj en tiu kazo, la sola vorto
Mi tajpis ĉe la prompto estas ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Kaj tiel la nombro de argumentoj kiuj estas
aprobotaj al mia programo estas ĝuste tiu.

1768
01:28:55,420 --> 01:28:58,880
Alivorte, la argumento
rakonti, alie konata kiel argc

1769
01:28:58,880 --> 01:29:00,970
tie kiel entjero, estas nur unu.

1770
01:29:00,970 --> 01:29:03,000
Oni kompreneble ne egalas du.

1771
01:29:03,000 --> 01:29:05,980
Kaj tial ĉi tio estas kion presas, saluton mondo.

1772
01:29:05,980 --> 01:29:08,170
>> Sed lasu min forigi tiun ie.

1773
01:29:08,170 --> 01:29:09,930
Mi diru, argv0.

1774
01:29:09,930 --> 01:29:12,740
Kaj tiam kion pri Maria?

1775
01:29:12,740 --> 01:29:14,990
Kaj tiam batis Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Kaj rimarki kio magie okazas tie.

1777
01:29:18,020 --> 01:29:22,640
Nun, anstataŭ saluton mondo, mi havas
ŝanĝis la konduton de tiu programo

1778
01:29:22,640 --> 01:29:26,310
prenante la enigo ne de akiri
ŝnuro aŭ alian funkcion,

1779
01:29:26,310 --> 01:29:30,570
sed el, ŝajne, mia komando
mem, kion mi origine tajpitaj.

1780
01:29:30,570 --> 01:29:35,720
Kaj mi povas ludi ĉi tiun ludon denove
ŝanĝi ĝin al Stelios, ekzemple.

1781
01:29:35,720 --> 01:29:38,400
>> Kaj nun mi vidas alian nomon ankoraŭ.

1782
01:29:38,400 --> 01:29:40,540
Kaj tie, mi povus diri Andi.

1783
01:29:40,540 --> 01:29:42,137
Kaj mi dirus Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Kaj ni povas ludi ĉi tiun ludon tutan tagon,
nur ŝtopanta en malsamaj valoroj,

1785
01:29:45,220 --> 01:29:49,550
tiel longe kiel mi provizas ĝuste
du vortoj en la prompto,

1786
01:29:49,550 --> 01:29:52,260
tia ke argc, mia argumento grafo, estas 2.

1787
01:29:52,260 --> 01:29:57,240
>> Mi vidas ke nomo ŝtopita en
printf, por tiu kondiĉo tie?

1788
01:29:57,240 --> 01:30:00,550
Do ni ŝajnas havi nun
la esprima kapablo

1789
01:30:00,550 --> 01:30:04,410
preni enigo de alia mekanismo,
de la tn komandlinio,

1790
01:30:04,410 --> 01:30:07,000
anstataŭ devi atendi
ĝis la uzanto kuras la programon,

1791
01:30:07,000 --> 01:30:10,220
kaj tiam instigas lin aŭ ŝin
uzante ion kiel get kordoj.

1792
01:30:10,220 --> 01:30:11,230
>> Do kio estas tio?

1793
01:30:11,230 --> 01:30:15,010
Argc, denove, estas nur entjero,
la nombro de words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
ke la uzanto provizita je la
prompto, ĉe la fina fenestro,

1795
01:30:18,540 --> 01:30:20,110
Inkluzivanta la programo nomo.

1796
01:30:20,110 --> 01:30:23,340
Tiel niaj ./argv0 estas, efektive,
la programo nomo,

1797
01:30:23,340 --> 01:30:24,520
aŭ kiom mi kuros la programo.

1798
01:30:24,520 --> 01:30:25,810
>> Kiu rakontas kiel unu vorton.

1799
01:30:25,810 --> 01:30:27,080
Do argc estus 1.

1800
01:30:27,080 --> 01:30:29,750
Sed kiam mi skribas Stelios aŭ
Andi, aŭ Zamyla, aŭ Maria,

1801
01:30:29,750 --> 01:30:31,660
kiu signifas la argumento grafo estas du.

1802
01:30:31,660 --> 01:30:33,910
Kaj tiel nun ekzistas du vortoj pasis en.

1803
01:30:33,910 --> 01:30:36,070
>> Kaj avizo, ni povas daŭrigi tiun logikon.

1804
01:30:36,070 --> 01:30:39,050
Se mi efektive diras,
io kiel Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
plena nomo, tiel pasanta
tri argumentojn en tuta,

1806
01:30:42,200 --> 01:30:47,410
Nun diras la defaŭlta denove,
ĉar, kompreneble, 3 ne egalas 2.

1807
01:30:47,410 --> 01:30:54,080
>> Kaj tiel ili, do mi havas
aliro tra argv tiu nova argumento

1808
01:30:54,080 --> 01:30:56,080
ke ni povis teknike
nomas ion ni volas.

1809
01:30:56,080 --> 01:30:58,940
Sed per konvencio, ĝi estas
argv kaj argc, respektive.

1810
01:30:58,940 --> 01:31:04,470
Argv, argumento vektoro, estas speco
de sinonimo por programado

1811
01:31:04,470 --> 01:31:07,140
trajto en C nomita tabelo.

1812
01:31:07,140 --> 01:31:14,410
>> Tabelo estas listo de similaj valoroj
dorso, apogi, subteni, por dorso.

1813
01:31:14,410 --> 01:31:17,810
Alivorte, se oni estas ĝuste ĉi tie en
RAM, la venonta unu estas tuj apud ĝi,

1814
01:31:17,810 --> 01:31:18,800
kaj tuj apud ĝi.

1815
01:31:18,800 --> 01:31:20,101
Ili ne estas ĉiuj super la loko.

1816
01:31:20,101 --> 01:31:23,100
Kaj ke ĉi-lasta scenaro, kie aferoj
estas ĉiuj super la loko en memoro,

1817
01:31:23,100 --> 01:31:25,082
povas efektive esti potenca trajto.

1818
01:31:25,082 --> 01:31:28,040
Sed ni revenos al tio kiam ni
paroli pri amatoro datumstrukturoj.

1819
01:31:28,040 --> 01:31:32,260
Nuntempe, tabelo estas nur
eron de apudaj memoro,

1820
01:31:32,260 --> 01:31:36,520
ĉiu el kies elementoj estas
dorso, apogi, subteni, apogi,

1821
01:31:36,520 --> 01:31:38,050
kaj ĝenerale la sama tipo.

1822
01:31:38,050 --> 01:31:42,630
>> Sekve se vi pensas pri, de
Antaŭ momento, kio estas kordo?

1823
01:31:42,630 --> 01:31:50,460
Nu, ŝnuro, kiel Zamyla,
Z-Al-M-Kaj-L-Al, estas, teknike,

1824
01:31:50,460 --> 01:31:51,400
nur tabelo.

1825
01:31:51,400 --> 01:31:53,700
Ĝi estas tabelo de signoj.

1826
01:31:53,700 --> 01:31:59,250
>> Kaj do se ni vere desegni ĉi, kiel mi
faris antaŭe, kiel eron de memoro,

1827
01:31:59,250 --> 01:32:04,510
ĝi rezultas ke ĉiu el tiuj
karakteroj okupas bajton.

1828
01:32:04,510 --> 01:32:07,630
Kaj tiam tie estas tio specialan
sentinelo karaktero, la backslash 0,

1829
01:32:07,630 --> 01:32:12,360
aŭ ok 0 bitoj, ke
demarca la fino de tiu ĉeno.

1830
01:32:12,360 --> 01:32:15,090
Do ŝnuro, rezultas
eksteren, citi unquote ŝnuro,

1831
01:32:15,090 --> 01:32:20,580
estas nur tabelo de chara--
char esti reala datumtipo.

1832
01:32:20,580 --> 01:32:24,560
>> Kaj nun argv, meanwhile--
ni revenu al la programo.

1833
01:32:24,560 --> 01:32:29,582
Argv, kvankam ni vidas la vorton
ĉeno tie, ne estas signoĉeno mem.

1834
01:32:29,582 --> 01:32:33,640
Argv, argumento vektoro,
estas tabelo de kordoj.

1835
01:32:33,640 --> 01:32:37,620
>> Tiel same vi povas havi tabelo de
karakteroj, vi povas havi pli altan nivelon,

1836
01:32:37,620 --> 01:32:46,279
tabelo de strings-- tiel, ekzemple,
kiam mi tajpas antaŭ momento ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, spaco Z-Al-M-Kaj-L-A, mi asertis ke
argv havis du kordoj en it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
kaj Z-Al-M-Kaj-L-A. en
Alivorte, argc estis 2.

1839
01:33:03,185 --> 01:33:03,980
Kial estas tio?

1840
01:33:03,980 --> 01:33:08,370
>> Nu, efektive, kio okazas
estas ke ĉiu el tiuj kordoj

1841
01:33:08,370 --> 01:33:13,990
estas, kompreneble, tabelo de signoj
kiel antaŭe, ĉiu el kies karakteroj

1842
01:33:13,990 --> 01:33:15,670
okupas unu bajto.

1843
01:33:15,670 --> 01:33:19,720
Kaj ne konfuzi la fakta 0
en la programo nomo kun la 0,

1844
01:33:19,720 --> 01:33:22,040
kio signifas ĉiuj 80 bitoj.

1845
01:33:22,040 --> 01:33:27,140
Kaj Zamyla, dume, estas ankoraŭ
ankaŭ aron da karakteroj.

1846
01:33:27,140 --> 01:33:31,450
>> Do fine de la tago, ĝi vere
aspektas kiel ĉi sube la kapuĉo.

1847
01:33:31,450 --> 01:33:38,800
Sed argv, nature de kiel ĉefa
verkoj, min permesas enpaki ĉion ĉi

1848
01:33:38,800 --> 01:33:44,810
sur, se vi volas, pli granda tabelo
ke, se ni iomete super simpligi

1849
01:33:44,810 --> 01:33:48,180
kion la bildo aspektas kaj ne
tute desegni ĝin grimpi supren tie,

1850
01:33:48,180 --> 01:33:56,720
ĉi tabelo estas nur de grandeco 2, la unua
elemento de kiu enhavas ĉenon,

1851
01:33:56,720 --> 01:33:59,230
la dua elemento de
kiu enhavas kordo.

1852
01:33:59,230 --> 01:34:01,687
Kaj, en victurno, se vi
ia zomi je sur ĉiu

1853
01:34:01,687 --> 01:34:03,770
de tiuj kordoj, kion vi
vidu sube la kapuĉo

1854
01:34:03,770 --> 01:34:07,190
estas ke ĉiu linio estas simple
tabelo de signoj.

1855
01:34:07,190 --> 01:34:11,680
>> Nun, kiel kun kordoj,
ni povis akiri aliron

1856
01:34:11,680 --> 01:34:15,260
al la ia karaktero en ĉeno
uzante tiu kvadrata krampo skribmaniero.

1857
01:34:15,260 --> 01:34:17,320
Simile, kun tabeloj
ĝenerale, povas nin

1858
01:34:17,320 --> 01:34:22,700
uzi kvadrata krampo skribmaniero akiri
en ajna nombro de kordoj en tabelo?

1859
01:34:22,700 --> 01:34:25,100
Ekzemple, lasu min
antaŭeniri kaj fari tion.

1860
01:34:25,100 --> 01:34:32,420
>> Lasu min antaŭeniri kaj krei argv1.c,
kiu estas iom malsama ĉi tiu tempo.

1861
01:34:32,420 --> 01:34:35,635
Anstataŭ kontrolanta por argc2,
Mi tuj anstataŭ fari tion.

1862
01:34:35,635 --> 01:34:41,270
Por int mi ricevas 0, mi estas malpli
ol argc, mi plus plus,

1863
01:34:41,270 --> 01:34:47,920
kaj tiam presi ene de tiu,
procento s, nova linio, kaj poste

1864
01:34:47,920 --> 01:34:50,740
argv krampo i.

1865
01:34:50,740 --> 01:34:55,220
>> Do alivorte, mi ne pritraktas
individuajn karakterojn nuntempe.

1866
01:34:55,220 --> 01:35:00,190
Argv, kiel implicita per tiuj malplenaj kvadrato
krampoj dekstre de la nomo argv,

1867
01:35:00,190 --> 01:35:03,320
signifas argv estas tabelo de kordoj.

1868
01:35:03,320 --> 01:35:04,870
Kaj argc estas simple int.

1869
01:35:04,870 --> 01:35:08,800
>> Tiu linio tie, 6, estas
dirante aro i egalas al 0.

1870
01:35:08,800 --> 01:35:11,980
Grafo tutan vojon ĝis,
sed ne inkluzive de, argc.

1871
01:35:11,980 --> 01:35:14,010
Kaj tiam ĉiu ripeto,
presi kordo.

1872
01:35:14,010 --> 01:35:14,800
Kio kordo?

1873
01:35:14,800 --> 01:35:17,270
>> La ia ŝnuro en argv.

1874
01:35:17,270 --> 01:35:19,530
Do dum antaŭ mi iris
uzanta la kvadrata krampo

1875
01:35:19,530 --> 01:35:22,180
notacion por atingi la Ith
karaktero en ĉeno, nun

1876
01:35:22,180 --> 01:35:27,240
Mi uzas la kvadrata krampo skribmaniero
por atingi la Ith ĉenon en tabelo.

1877
01:35:27,240 --> 01:35:30,310
Do ĝi estas speco de unu tavolo
supre, koncepte.

1878
01:35:30,310 --> 01:35:35,390
>> Do kio estas neta pri tio
programo nun, se mi kompili argv1,

1879
01:35:35,390 --> 01:35:42,067
kaj tiam fari ./argv1, kaj poste tajpi
en io kiel foo trinkejo rabado,

1880
01:35:42,067 --> 01:35:45,400
kiu estas la tri defaŭlta vortoj ke
komputila sciencisto atingas por ajna momento

1881
01:35:45,400 --> 01:35:51,010
li aŭ ŝi bezonas iun lokokupilo vortoj,
kaj batis Enter, ĉiu el tiuj vortoj,

1882
01:35:51,010 --> 01:35:54,980
Inkluzivanta la programo nomo, kiun
Estas en argv antauxe loko,

1883
01:35:54,980 --> 01:35:58,320
finas estante presita unuope.

1884
01:35:58,320 --> 01:36:05,290
Kaj se mi ŝanĝi tion, kaj mi diras
io kiel argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
ni akiri ĉiujn tri el tiuj
vortoj, kiuj estas argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, ĉar en tiu
kazo argc, la grafo, estas 3.

1887
01:36:14,400 --> 01:36:20,020
>> Sed kio estas neta estas, se vi komprenas
ke argv estas nur tabelo de kordoj,

1888
01:36:20,020 --> 01:36:24,910
kaj vi komprenas ke kordo
estas tabelo de signoj,

1889
01:36:24,910 --> 01:36:29,470
ni povas fakte speco de uzi ĉi
kvadrata krampo skribmaniero plurfoje

1890
01:36:29,470 --> 01:36:33,320
elekti kordo, kaj tiam elektu
gravulo ene de la kordoj,

1891
01:36:33,320 --> 01:36:35,730
plonĝado en profunda jene.

1892
01:36:35,730 --> 01:36:40,100
En ĉi tiu ekzemplo, mi iros
antaŭen kaj nomas tiun argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Kaj en ĉi tiu ekzemplo, lasu min antaŭeniri
kaj fari la following-- por int i ricevas 0,

1895
01:36:50,180 --> 01:36:53,286
i estas malpli ol argc, i plus
plus, samkiel antaŭe.

1896
01:36:53,286 --> 01:36:55,910
Tiel en aliaj words-- kaj nun tiu
iĝas komplika sufiĉe.

1897
01:36:55,910 --> 01:36:59,940
Tiam mi tuj diros
persisti super kordoj en argv,

1898
01:36:59,940 --> 01:37:01,294
kiel komento al mi mem.

1899
01:37:01,294 --> 01:37:03,960
Kaj tiam mi iros al havi
neston por ciklo, kiun vi probable

1900
01:37:03,960 --> 01:37:06,290
faris, aŭ konsiderata
faras, en Scratch, kie

1901
01:37:06,290 --> 01:37:08,600
Mi tuj diru int-- mi
ne tuj uzos mi denove,

1902
01:37:08,600 --> 01:37:12,590
ĉar mi ne volas postsekvi aŭ
ia anstataŭigi la ekzistantan i.

1903
01:37:12,590 --> 01:37:15,780
>> Mi tuj, anstataŭe, diru j, ĉar
jen mia go al variablo post i,

1904
01:37:15,780 --> 01:37:18,590
kiam mi nur provas
kalkuli simplaj nombroj.

1905
01:37:18,590 --> 01:37:28,850
Por j ricevas 0-- kaj ankaŭ, n, tuj
akiri la sxiplmalantauxo longo de argv krampo i,

1906
01:37:28,850 --> 01:37:36,030
tiel longe kiel j estas malpli ol m,
j plus plus, faru la sekvajn.

1907
01:37:36,030 --> 01:37:37,500
Kaj jen la interesa parto.

1908
01:37:37,500 --> 01:37:46,330
>> Presi karaktero kaj nova linio,
ŝtopanta en argv krampo i, krampo j.

1909
01:37:46,330 --> 01:37:47,940
Bone, do lasu min aldoni kelkajn komentojn tie.

1910
01:37:47,940 --> 01:37:54,820
Persisti super karakteroj
en nuna ŝnuro,

1911
01:37:54,820 --> 01:38:02,290
presaĵo j ia karaktero en ia ŝnuro.

1912
01:38:02,290 --> 01:38:04,630
Do nun, ni konsideru
kion tiuj komentoj signifi.

1913
01:38:04,630 --> 01:38:06,750
>> Persisti super la kordoj
en argv-- kiom

1914
01:38:06,750 --> 01:38:09,300
kordoj estas en argv, kiuj estas tabelo?

1915
01:38:09,300 --> 01:38:13,420
Argc multaj, do mi ripetanta
de i egalas 0 ĝis argc.

1916
01:38:13,420 --> 01:38:20,020
Dume, kiom da karakteroj
estas en la ia ŝnuro en argv?

1917
01:38:20,020 --> 01:38:22,880
>> Nu, por atingi tiun respondon,
Mi simple nomas string longo

1918
01:38:22,880 --> 01:38:26,810
sur la aktuala ĉeno Mi prizorgo
pri kiu estas argv krampo i.

1919
01:38:26,810 --> 01:38:30,090
Kaj mi tuj provizore stoki ke
valoro en n, nur por caching celoj,

1920
01:38:30,090 --> 01:38:31,590
memori ĝin por efikeco.

1921
01:38:31,590 --> 01:38:36,330
Kaj tiam mi iros pravalorizi j al 0,
plu iri tiel longe kiel j estas malpli ol n,

1922
01:38:36,330 --> 01:38:38,430
kaj sur ĉiu ripeto pliigo j.

1923
01:38:38,430 --> 01:38:41,030
>> Kaj tiam ĉi tien, por
mia komento sur linio 12,

1924
01:38:41,030 --> 01:38:43,390
presi karaktero,
sekvata de nova linio,

1925
01:38:43,390 --> 01:38:48,140
specife argv krampo
i donas min la ia ŝnuro

1926
01:38:48,140 --> 01:38:51,690
en argv-- tiel la unua vorto, la
dua vorto, la tria vorto ajn.

1927
01:38:51,690 --> 01:38:57,370
Kaj tiam j plonĝas en profundan, kaj ricevas
Min la j-a karaktero de tiu vorto.

1928
01:38:57,370 --> 01:39:02,200
Kaj tiel, en efekto, ili povas trakti
argv kiel multi-dimensia,

1929
01:39:02,200 --> 01:39:06,050
kiel dudimensia tabelo,
per ĉiu vorto ia aspekto

1930
01:39:06,050 --> 01:39:08,580
kiel tiu en via menso
okulo, kaj ĉiu karaktero

1931
01:39:08,580 --> 01:39:10,930
estas speco de komponaĵo en
kolumno, se tio helpas.

1932
01:39:10,930 --> 01:39:13,260
>> En realo, kiam ni turmentus
ĉi dise en estonteco semajnoj,

1933
01:39:13,260 --> 01:39:15,580
ĝi tuj estos iom
pli kompleksa ol tio.

1934
01:39:15,580 --> 01:39:17,800
Sed vi povas vere
pensi ke, de momento,

1935
01:39:17,800 --> 01:39:22,110
kiel ĵus tiu dudimensia
tabelo, per unu nivelon de ĝi

1936
01:39:22,110 --> 01:39:23,260
Estas tuta de la kordoj.

1937
01:39:23,260 --> 01:39:26,760
Kaj tiam se vi plonĝi en pli profundaj, vi
povas atingi la individuaj karakteroj

1938
01:39:26,760 --> 01:39:29,600
en gxi uzante tiu notacio tie.

1939
01:39:29,600 --> 01:39:31,620
>> Do kio estas la pura efekto?

1940
01:39:31,620 --> 01:39:34,970
Lasu min antaŭeniri kaj
fari argv2-- Darn ĝin.

1941
01:39:34,970 --> 01:39:36,210
Mi eraris tie.

1942
01:39:36,210 --> 01:39:40,160
Implice deklari la
biblioteko funkcio Stirling.

1943
01:39:40,160 --> 01:39:42,190
Do ĉio ĉi momento, ĝi estas
eble konvenajn

1944
01:39:42,190 --> 01:39:45,130
ke ni ia fini
ĝuste kie ni komencis.

1945
01:39:45,130 --> 01:39:48,160
>> Mi ŝraŭbita supren, implice deklari
biblioteko funkcio Stirling.

1946
01:39:48,160 --> 01:39:48,987
Okej, atendu momenton.

1947
01:39:48,987 --> 01:39:51,070
Mi memoras ke, speciale
ĉar ĝi estas ĝuste ĉi tie.

1948
01:39:51,070 --> 01:39:54,490
Mi bezonas inkluzivi string.h en
tiu versio de la programo.

1949
01:39:54,490 --> 01:40:00,050
>> Lasu min antaŭeniri kaj inkluzivi
string.h, savi tion, antaŭeniri

1950
01:40:00,050 --> 01:40:04,460
kaj rekompili argv2.

1951
01:40:04,460 --> 01:40:08,390
Kaj nun, tie ni iru, faru argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Kaj kvankam ĝi estas iom
kamufla unuavide,

1953
01:40:10,590 --> 01:40:15,690
rimarki ke, fakte, kion
estas presita estas skalara argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Sed se mi tajpas iun vortoj post la
prompto, kiel argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Eniros, ankaŭ iom
kamufla unuavide.

1956
01:40:22,560 --> 01:40:30,540
Sed se ni rulumu reen supren,
./argv2 Z-Al-M-Kaj-L-A C-H-Al-N.

1957
01:40:30,540 --> 01:40:32,190
Do ni ripetis super ĉiu vorto.

1958
01:40:32,190 --> 01:40:37,770
Kaj, siavice, ni ripetis super
ĉiu karaktero ene de vorto.

1959
01:40:37,770 --> 01:40:40,040
>> Nun, post ĉio ĉi,
rimarkas ke estas

1960
01:40:40,040 --> 01:40:43,120
unu alian detalon ni estis speco
ignori tiun tutan tempon.

1961
01:40:43,120 --> 01:40:46,180
Ni nur incitetis dise kio
ĉefa la enigoj povas esti?

1962
01:40:46,180 --> 01:40:47,780
Kio pri ĉefa eligo?

1963
01:40:47,780 --> 01:40:50,540
>> Ĉiuj ĉi tempo, ni estis
kopii kaj alglui

1964
01:40:50,540 --> 01:40:53,870
la vorto int antaŭ ĉefa,
Kvankam vi povas vidi en linio,

1965
01:40:53,870 --> 01:40:58,340
foje neĝuste en malnovaj versioj
de C kaj compiladores, ke ili diru malplenon,

1966
01:40:58,340 --> 01:40:59,410
aŭ nenio ajn.

1967
01:40:59,410 --> 01:41:01,580
Sed ja por la versio
de C ke ni uzas,

1968
01:41:01,580 --> 01:41:06,180
C 11, aŭ 2011, realigi
ke plenumigxu int.

1969
01:41:06,180 --> 01:41:09,300
Kaj ĝi devus aŭ esti
malplena aŭ argc kaj argv tie.

1970
01:41:09,300 --> 01:41:10,790
>> Sed kial int main?

1971
01:41:10,790 --> 01:41:12,480
Kio ĝi efektive reveni?

1972
01:41:12,480 --> 01:41:16,280
Nu, tio rezultas ĉiuj ĉi tempo,
ajna tempo vi skribis programon ĉefa

1973
01:41:16,280 --> 01:41:18,440
ĉiam revenanta ion.

1974
01:41:18,440 --> 01:41:19,960
Sed estis farante tiel sekrete.

1975
01:41:19,960 --> 01:41:23,350
>> Ke io estas
int, kiel linio 5 sugestas.

1976
01:41:23,350 --> 01:41:24,225
Sed kion int?

1977
01:41:24,225 --> 01:41:26,100
Nu, tie estas tio
konvencio en programado,

1978
01:41:26,100 --> 01:41:29,790
per kiu se nenio
fuŝiĝis kaj ĉiuj estas bone,

1979
01:41:29,790 --> 01:41:34,250
programoj kaj funkcioj ĝenerale
return-- iom counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 ĝenerale signifas ĉio estas bone.

1982
01:41:38,070 --> 01:41:40,610
Do eĉ se vi pensas pri
kiel malvera en multaj kuntekstoj,

1983
01:41:40,610 --> 01:41:42,930
ĝi efektive ĝenerale signifas bonan aferon

1984
01:41:42,930 --> 01:41:49,560
>> Dume, se programo redonas 1,
aŭ negativa 1, aŭ 5, aŭ negativaj 42,

1985
01:41:49,560 --> 01:41:52,941
aŭ ajna ne-0 valoron,
kiu ĝenerale signifas

1986
01:41:52,941 --> 01:41:54,190
ke io iris malĝuste.

1987
01:41:54,190 --> 01:41:56,700
Fakte, en via propra Mac aŭ PC,
vi eble efektive vidis

1988
01:41:56,700 --> 01:42:01,050
erarmesagxon, per tio
diras ion aŭ alian, eraro

1989
01:42:01,050 --> 01:42:04,940
kodo negativa 42, aŭ eraro kodo
23, aŭ io simila.

1990
01:42:04,940 --> 01:42:08,980
Tiu nombro estas ĝenerale nur aludo
al la programisto, aŭ la entrepreno

1991
01:42:08,980 --> 01:42:11,174
kiu faris la programaro,
kio eliris malbone kaj kial,

1992
01:42:11,174 --> 01:42:13,590
por ke ili povu rigardi tra
ilian dokumentaron aŭ kodo,

1993
01:42:13,590 --> 01:42:15,465
kaj elkompreni la
eraro fakte signifas.

1994
01:42:15,465 --> 01:42:18,400
Ĝi estas ĝenerale ne
utila al ni fini uzantojn.

1995
01:42:18,400 --> 01:42:20,550
>> Sed kiam ĉefa revenas 0, ĉio bonas.

1996
01:42:20,550 --> 01:42:23,770
Kaj se vi ne specifas
kion ĉefa revenos,

1997
01:42:23,770 --> 01:42:26,950
i volas nur aŭtomate
reveni 0 por vi.

1998
01:42:26,950 --> 01:42:30,870
Sed reveninte ion
alia estas vere utila.

1999
01:42:30,870 --> 01:42:34,660
>> En tiu lasta programo, lasu min
antaŭeniri kaj nomas tiun exit.c,

2000
01:42:34,660 --> 01:42:38,630
kaj enkonduki la lasta de la hodiaŭa
temoj, konata kiel eraro kodo.

2001
01:42:38,630 --> 01:42:42,930
Lasu min antaŭeniri kaj inkludas nia
familiara dosierojn ĝis supro, do int ĉefa.

2002
01:42:42,930 --> 01:42:49,500
Kaj ĉi tiu tempo, ni faros int argc,
ŝnuro argv, kaj kun miaj krampoj

2003
01:42:49,500 --> 01:42:50,836
implici ke ĝi estas en la tabelo.

2004
01:42:50,836 --> 01:42:52,460
Kaj tiam mi simple fari prudento ĉeko.

2005
01:42:52,460 --> 01:42:56,640
Tiu tempo, se argc ne
egala 2, tiam vi scias kion?

2006
01:42:56,640 --> 01:42:57,520
Forgesu ĝin.

2007
01:42:57,520 --> 01:43:03,170
Mi intencis diri ke, hey, uzanto,
vi mankas komandlinio argumento

2008
01:43:03,170 --> 01:43:04,210
backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> Kaj tiam tio estas ĝi.

2010
01:43:05,230 --> 01:43:06,130
Mi volas eliri.

2011
01:43:06,130 --> 01:43:11,030
Mi iras al preventa,
kaj antaŭtempe vere, reveno

2012
01:43:11,030 --> 01:43:12,810
io alia ol la numero 1.

2013
01:43:12,810 --> 01:43:15,360
La iri al valoro por la unua
eraro kiu povas okazi estas 1.

2014
01:43:15,360 --> 01:43:17,860
Se vi havas alian erara
situacio kiu povus okazi,

2015
01:43:17,860 --> 01:43:21,390
vi eble dirus reveno 2 aŭ reveni 3, aŭ
eble eĉ negativa 1 aŭ negativa 2.

2016
01:43:21,390 --> 01:43:23,750
>> Tiuj estas nur eliro kodoj
kiu estas, ĝenerale,

2017
01:43:23,750 --> 01:43:27,770
nur utila al la programisto, aŭ la
kompanio kiu estas ekspedanta la programaron.

2018
01:43:27,770 --> 01:43:30,500
Sed la fakto ke ĝi estas
ne 0 estas kio estas grava.

2019
01:43:30,500 --> 01:43:34,310
Do se en tiu programo, mi volas
garantii ke tiu programo nur

2020
01:43:34,310 --> 01:43:38,190
funkcias se la uzanto donas min
kun argumento grafo de du,

2021
01:43:38,190 --> 01:43:42,880
la nomo de la programo, kaj kelkaj aliaj
vorto, mi povas plenumi tiel kiel sekvas:

2022
01:43:42,880 --> 01:43:46,110
krias al la uzanto kun printf parolo
mankas komandlinio argumento,

2023
01:43:46,110 --> 01:43:46,970
revenu 1.

2024
01:43:46,970 --> 01:43:49,940
Ke volo ĵus tuj
forlasi la programon.

2025
01:43:49,940 --> 01:43:55,840
>> Nur se argc egalas 2, ni akiras malsupren
tie, ĉe kiu punkto mi tuj diru,

2026
01:43:55,840 --> 01:44:00,410
saluton procento s, backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Alivorte, mi estas
ne tuj post argv 0,

2028
01:44:03,827 --> 01:44:05,410
kiu estas nur la nomo de la programo.

2029
01:44:05,410 --> 01:44:09,450
Mi volas presi saluton, komo,
la dua vorto, kiun la homa tajpita.

2030
01:44:09,450 --> 01:44:12,580
Kaj en ĉi tiu kazo sur
linio 13, ĉiuj estas bone.

2031
01:44:12,580 --> 01:44:15,920
>> Mi scias ke argc estas 2
logike el tiu programo.

2032
01:44:15,920 --> 01:44:17,770
Mi tuj iros antaŭen kaj reveni 0.

2033
01:44:17,770 --> 01:44:21,230
Kiel flanken, memoru ke
tio estas vera en Scratch tiel.

2034
01:44:21,230 --> 01:44:24,760
>> Logike, mi povus fari tion
kaj encapsular tiujn liniojn

2035
01:44:24,760 --> 01:44:27,020
de kodo en tiu alia klaŭzo tie.

2036
01:44:27,020 --> 01:44:29,420
Sed tio estas ia
nenecese deŝovante mia kodo.

2037
01:44:29,420 --> 01:44:31,800
Kaj mi volas fari la super
certe ke ne gravas,

2038
01:44:31,800 --> 01:44:34,670
defaŭlte, saluton
io estos get presita,

2039
01:44:34,670 --> 01:44:36,050
tiel longe kiel la uzanto kunlaboras.

2040
01:44:36,050 --> 01:44:39,360
>> Do ĝi estas tre komune uzi
kondiĉo, nur se,

2041
01:44:39,360 --> 01:44:41,870
kapti iun erara
situacio, kaj tiam eliro.

2042
01:44:41,870 --> 01:44:45,690
Kaj tiam, tiel longe ĉiuj estas
bone, vi ne havas alian,

2043
01:44:45,690 --> 01:44:48,060
sed nur havas la kodon
ekster tio se, ĉar ĝi estas

2044
01:44:48,060 --> 01:44:51,060
ekvivalenta en tiu
aparta kazo, logike.

2045
01:44:51,060 --> 01:44:54,480
Do mi revenas 0, nur por
eksplicite signifas ĉio estas bone.

2046
01:44:54,480 --> 01:44:58,480
>> Se mi preterlasis la reveno 0, ĝi farus
aŭtomate supozis por mi.

2047
01:44:58,480 --> 01:45:00,890
Sed nun, kiam mi estas revenanta
en almenaŭ tiu kazo,

2048
01:45:00,890 --> 01:45:04,940
Mi tuj, por bonan mezuron kaj
klareco, reveno 0 en ĉi tiu kazo.

2049
01:45:04,940 --> 01:45:09,690
Do nun lasu min antaŭeniri kaj fari eliron,
kiu estas perfekta segue al simple forlasi.

2050
01:45:09,690 --> 01:45:14,401
>> Sed fari eliro, kaj mi iros
antaŭen kaj fari ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Kaj la programo kriis al mi,
mankas komandlinio argumento.

2052
01:45:16,900 --> 01:45:18,120
OK, mi kunlaboras.

2053
01:45:18,120 --> 01:45:23,810
>> Lasu min anstataŭ fari ./exit David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Kaj nun diras, saluton David.

2055
01:45:25,190 --> 01:45:27,300
Kaj vi ne normale vidas ĉi.

2056
01:45:27,300 --> 01:45:30,650
>> Sed rezultu ke ekzistas
speciala maniero en Linukso por fakte vidi

2057
01:45:30,650 --> 01:45:34,470
kun kion eliron kodo programo eliris.

2058
01:45:34,470 --> 01:45:37,184
Kelkfoje en grafika
mondo kiel Mac OS aŭ Vindozo,

2059
01:45:37,184 --> 01:45:40,100
vi nur vidas tiujn numerojn kiam
erarmesaĝo krevas supre sur la ekrano

2060
01:45:40,100 --> 01:45:41,940
kaj la programisto
montras vin tiom.

2061
01:45:41,940 --> 01:45:44,773
Sed se ni volas vidi kion la eraro
mesaĝo estas, ni povas fari ĝin here--

2062
01:45:44,773 --> 01:45:48,100
tiel ./exit, Enter, presaĵo
mankas komandlinio argumento.

2063
01:45:48,100 --> 01:45:54,590
>> Se mi nun faras eĥo $ ?, kiu estas
ridinde kamufla rigardas.

2064
01:45:54,590 --> 01:45:56,590
Sed $?

2065
01:45:56,590 --> 01:45:59,220
estas la magia sorcxkanto
kiu diras, hey, Komputilo,

2066
01:45:59,220 --> 01:46:01,900
diru al mi kio la antaŭa
programo eliro kodo estis.

2067
01:46:01,900 --> 01:46:03,410
Kaj mi batis Enter.

2068
01:46:03,410 --> 01:46:07,520
Mi vidas 1, ĉar tion mi
diris mia ĉefa funkcio reveni.

2069
01:46:07,520 --> 01:46:12,310
>> Dume, se mi faras ./exit David
kaj batis Enter, mi vidas, saluton David.

2070
01:46:12,310 --> 01:46:16,800
Kaj se mi nun faras eĥo $ ?, mi vidas saluton 0.

2071
01:46:16,800 --> 01:46:19,080
Kaj tiel tiu volo reale
esti valora informo

2072
01:46:19,080 --> 01:46:23,420
en la kunteksto de la erarserĉilo, ne tiel
multe ke vi, la homo, zorgus.

2073
01:46:23,420 --> 01:46:26,060
Sed la debugger kaj aliaj
programoj ni uzos ĉi semestro

2074
01:46:26,060 --> 01:46:29,420
ofte rigardi tiun numeron,
kvankam ĝi estas ia kaŝita for

2075
01:46:29,420 --> 01:46:32,780
se vi serĉos ĝin, al
determini ĉu aŭ ne programo

2076
01:46:32,780 --> 01:46:37,050
ekzekuto estis ĝusta aŭ malĝusta.

2077
01:46:37,050 --> 01:46:40,450
>> Kaj tial alportas nin
tiun, fine de la tago.

2078
01:46:40,450 --> 01:46:43,917
Ni komencis hodiaŭ per rigardado
depuración kaj siavice en la kurso

2079
01:46:43,917 --> 01:46:46,750
mem, kaj tiam pli interese,
teknike sub la kapuĉo

2080
01:46:46,750 --> 01:46:49,490
ĉe kio kordoj estas, kiu daŭris
semajno simple prenis por koncedis,

2081
01:46:49,490 --> 01:46:51,900
kaj certe prenis ilin
por donita en Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Ni tiam rigardis kiel ni povas aliri
individuaj karakteroj en cxeno,

2083
01:46:56,040 --> 01:47:00,310
kaj tiam denove prenis pli altan nivelon
rigardi aferojn, rigardante kiel well--

2084
01:47:00,310 --> 01:47:04,226
se ni volas atingi individuajn
elementoj en lerta kiel strukturo,

2085
01:47:04,226 --> 01:47:05,850
ne ni faros tion kun multoblaj kordoj?

2086
01:47:05,850 --> 01:47:08,050
Kaj ni povas kun komandlinio argumentoj.

2087
01:47:08,050 --> 01:47:12,800
Sed ĉi bildo tie de simple skatoloj
estas demonstrativo de ĉi ĝenerala ideo

2088
01:47:12,800 --> 01:47:14,451
de tabelo aŭ listo, aŭ vektoro.

2089
01:47:14,451 --> 01:47:16,450
Kaj depende de la
kunteksto, ĉiuj tiuj vortoj

2090
01:47:16,450 --> 01:47:17,880
signifas iomete malsamajn aferojn.

2091
01:47:17,880 --> 01:47:20,060
Do en C, ni nur iri
paroli tabelo.

2092
01:47:20,060 --> 01:47:23,840
Kaj tabelo estas eron
de memoro, ĉiu el kiuj estas

2093
01:47:23,840 --> 01:47:27,720
elementoj estas apudaj, reen,
subteni, apogi, por dorso.

2094
01:47:27,720 --> 01:47:31,970
>> Kaj tiuj elementoj estas, ĝenerale,
de la sama datumtipo, karaktero,

2095
01:47:31,970 --> 01:47:35,966
karaktero, trajto, karaktero, aŭ
kordo, ŝnuro, ĉeno, ĉeno, aŭ int,

2096
01:47:35,966 --> 01:47:38,600
int, int, kio ajn ĝi estas
ni provas vendejo.

2097
01:47:38,600 --> 01:47:42,540
Sed fine de la tago, tio estas
kion ĝi aspektas kiel koncepte.

2098
01:47:42,540 --> 01:47:44,530
Vi prenas vian
komputila memoro aŭ RAM.

2099
01:47:44,530 --> 01:47:48,590
Kaj vi tranĉas ĝin en
idente grandeco skatoloj, ĉiu el kiuj

2100
01:47:48,590 --> 01:47:50,920
Estas reen por malantaŭeniri, por
dorso, subteni tiamaniere.

2101
01:47:50,920 --> 01:47:53,200
>> Kaj kio estas agrable pri
tiun ideon, kaj la fakto

2102
01:47:53,200 --> 01:47:58,580
ke ni povas esprimi valorojn tiamaniere
kun la unua de nia datumstrukturoj

2103
01:47:58,580 --> 01:48:02,520
en la klaso, signifas ni povas komenci
solvi problemojn kun kodo

2104
01:48:02,520 --> 01:48:04,079
kiu venis tiel intuicie en semajno 0.

2105
01:48:04,079 --> 01:48:05,870
Vi memoras la telefonon
libro ekzemplo, kie

2106
01:48:05,870 --> 01:48:09,110
ni uzis dividu kaj regu,
aŭ duuma serĉo algoritmo,

2107
01:48:09,110 --> 01:48:13,220
kribri tra tuto
faskon de nomoj kaj numeroj.

2108
01:48:13,220 --> 01:48:18,220
Sed ni supozis, revokon, ke tio
telefono libro estis jam ordo,

2109
01:48:18,220 --> 01:48:21,630
ke iu alia jam
Figurita fjordon donita listo de nomoj

2110
01:48:21,630 --> 01:48:24,430
kaj numbers-- kiom alfabetizar ilin.

2111
01:48:24,430 --> 01:48:26,950
Kaj nun kiam en C ni,
Ankaŭ havas la kapablon

2112
01:48:26,950 --> 01:48:30,290
meti aferojn, ne
fizike en telefono libro

2113
01:48:30,290 --> 01:48:34,220
sed virtuale en komputilo
memoro, ni povos venontsemajne

2114
01:48:34,220 --> 01:48:38,470
enkonduki denove this-- la unua
de nia datumstrukturoj en tabelo

2115
01:48:38,470 --> 01:48:43,530
sed pli grave, reala komputilo
scienco algoritmoj implementado

2116
01:48:43,530 --> 01:48:47,720
en kodo, kun kiu povos stoki
datumoj en strukturoj kiel tiu,

2117
01:48:47,720 --> 01:48:50,730
kaj tiam komenci manipuli ĝin, kaj
efektive solvi problemojn kun ĝi,

2118
01:48:50,730 --> 01:48:53,570
kaj konstrui sur supro de tiu,
finfine, programoj en C,

2119
01:48:53,570 --> 01:48:56,730
en Python, en JavaScript,
informpeti datumbazoj kun SQLa?

2120
01:48:56,730 --> 01:48:59,980
>> Kaj ni vidos, ke ĉiuj el tiuj
malsamaj ideoj interplektiĝas.

2121
01:48:59,980 --> 01:49:04,100
Sed nuntempe, memoras ke la
regado kiun ni enkondukis hodiaŭ

2122
01:49:04,100 --> 01:49:06,920
Estis tiu afero tie, kaj
la mondo de ĉifriko.

2123
01:49:06,920 --> 01:49:11,200
Kaj inter la proksimaj problemoj vi mem
solvos estas la arto de ĉifriko,

2124
01:49:11,200 --> 01:49:13,630
grimpadi kaj de-grimpanta
informo kaj ciphering

2125
01:49:13,630 --> 01:49:15,930
kaj deĉifri teksto,
kaj supozante finfine

2126
01:49:15,930 --> 01:49:18,970
ke vi nun scias kion
estas sub la kapuĉo

2127
01:49:18,970 --> 01:49:21,860
tiel ke kiam vi vidas aŭ ricevi
mesaĝon tiel, vi

2128
01:49:21,860 --> 01:49:24,060
mem povas deĉifri ĝin.

2129
01:49:24,060 --> 01:49:26,740
Ĉiuj ĉi, kaj pli proksima tempo.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO reprodukto]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Ĵus alvenis.

2133
01:49:32,970 --> 01:49:35,146
Mi tuj iros vizito
lia kolegiprofesoro.

2134
01:49:35,146 --> 01:49:37,611
Yep.

2135
01:49:37,611 --> 01:49:40,080
Hi.

2136
01:49:40,080 --> 01:49:40,660
Estas vi.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Atendi!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Mi nur provas diveni
kio okazis al vi.

2142
01:49:56,060 --> 01:49:58,130
Bonvolu, io povus helpi.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Vi estis lia kolegio
kvara, estis ne?

2145
01:50:08,354 --> 01:50:10,770
Vi estis tie kun li kiam
Li finis la CS50 projekto?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUZIKO Ludanta]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Tio Estis CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Mi amas tiun lokon.

2152
01:50:44,770 --> 01:50:45,854
>> -Eat Supren.

2153
01:50:45,854 --> 01:50:47,020
Ni iras for el komerco.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [FINO reprodukto]

