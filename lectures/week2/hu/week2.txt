[ZENE] 

David J. MALAN: Rendben. Ez CS50 és ez a 2. hét elején. És emlékezzünk csak vissza, hogy több mint Az elmúlt pár hét, vezettünk be a számítógép tudomány és viszont, programozás. 

És elkezdtük a történetet útján Scratch, hogy grafikus nyelv a MIT Media Lab. Aztán legutóbb, A múlt héten, ahogy mi bevezetni higher-- egy alacsonyabb szintű nyelvi ismert a C, valamit, ami tisztán szöveges. És valóban, utoljára feltárni ebben az összefüggésben számos fogalmat. 

Ez, visszahívás, volt az első program néztük. És ez a program, egyszerűen, kiírja, "hello, világ". De olyan sok mintha varázslat folyik. Van ez a #include ezekkel hegyes zárójelek. Van int. Van (void). Van zárójelben, kapcsos zárójelek félig kettőspont, és így sokkal több. 

És így, emlékeztetni arra, hogy bevezettük Scratch így tudtuk, ideális, lásd múlt hogy szintaxis, a dolgokat, hogy tényleg nem minden szellemileg érdekes, de korán van, teljesen, egy kicsit trükkös hogy lezárja az elméd köré. És valóban, az egyik leggyakoribb dolgok elején egy programozási osztály, különösen azok számára, kevésbé kényelmes, az, hogy csalódott és gáncsot bizonyos szintaktikai hibák, nem is beszélve a logikai hibák. És így Céljaink között ma, valójában, majd lehet, hogy felvértezzük Önt néhány problémamegoldó technikák, hogy hogyan hogy jobban megoldani a problémákat maguknak formájában hibakeresés. És akkor felidézni azt is, hogy a környezet, hogy mi vezetett utoljára hívták CS50 IDE. Ez a web-alapú szoftver, amely programozhatja a felhő, hogy úgy mondjam, miközben az összes fájlokat együtt, ahogy ismét a mai napon. És emlékszem, hogy mi felülvizsgálata ezeket a témákat itt, köztük a funkciót, hurkok, változók és logikai kifejezések, és feltételeket. És valójában még néhány, hogy mi lefordítva a világ a semmiből a világ C. 

De az alapvető épület blokkok, hogy úgy mondjam, valóban még mindig ugyanaz a múlt héten. Sőt, igazán csak volt egy különböző puzzle-darab, ha úgy tetszik. Ahelyett, hogy a lila menteni blokk, akkor helyette volna printf, ami Ezt a funkciót a C, hogy lehetővé teszi, hogy nyomtatni valamit és formázza meg a képernyőn. Bemutattuk a CS50 Könyvtár, ahol Van most az Ön rendelkezésére get_char, és get_int és get_string, és néhány egyéb funkciót, Nos, amelyen keresztül lehet kapni bemenet a felhasználó saját billentyűzettel. És mi is szemügyre vette a dolgokat mint these- bool, és char, és dupla, úszó, int, long_long húr. És van még más adattípusokat C. 

Más szóval, ha kijelentem, a változó tárolja néhány érték, vagy ha végre egy funkciót hogy visszatér valamilyen érték, megadhatja, hogy mit típusú érték, hogy van. Ez egy string, mint egy karakterek sorozata? Ez több, mint egy egész? Ez egy lebegőpontos érték, vagy hasonlók? Tehát C, ellentétben Scratch, valójában kezdte meg, milyen adatokat voltunk visszatérő vagy használ. 

De, persze, mi is ütközött néhány alapvető korlátait számítástechnika. És különösen annak ezen a nyelven C, visszahívás hogy vettünk egy pillantást integer túlcsordulás, a valóság hogy ha csak egy véges mennyiségű memóriát vagy, pontosabban, véges számú bitek, akkor csak akkor számíthat ilyen magas. És így nézett ez a példa itt amellyel a számláló egy repülőgép,, valóban, ha fut elég hosszú lenne túlcsordulás és az eredmény egy szoftver tényleges fizikai potenciál hiba. 

Megnéztük úszó pont pontatlanság, a valóság hogy csak véges számú bitek, legyen az 32 vagy 64, akkor csak azokat annyi szám után egy tizedespont, ami után elkezdi, hogy pontatlan. Így például, egyharmadát a világ itt, a mi emberi világban, tudjuk, hogy ez csak egy végtelen számú 3s tizedesvessző után. De a számítógép nem feltétlenül képviselnek végtelen számú számok ha csak azt teszik lehetővé, hogy néhány véges mennyiségű információt. 

Tehát nem csak mi felállítja nagyobb teljesítmény szempontjából arra, hogyan lehet kifejezni magát a billentyűzet a programozás, mi is csak mi akkor valóban nem. És valóban, a hibákat és hibák adódnak az ilyen jellegű kérdéseket. És valóban, a témák között ma lesznek témák, mint a hibakeresés és valóban keresi a motorháztető alatt A dolgok kerültek bevezetésre a múlt héten tényleges megvalósítása, úgy, hogy a jobb tisztában vannak mind a képességeit és A korlátozások a nyelv, mint a C. 

És valóban, mi húzza vissza a rétegek A legegyszerűbb adatszerkezet, egy úgynevezett tömb, amely Scratch történik, hogy hívja a "listán". Ez egy kicsit különböző ebben az összefüggésben. És akkor mi is be az egyik Először a terület-specifikus problémák a CS50, a világ kriptográfia, a művészet rejtjelező vagy rejtjelezés információt, hogy küldhetünk titkos üzeneteket és dekódolja a titkos üzenetek két személy között, az A és B 

Szóval mielőtt átmenet az, hogy az új világ, próbáljuk, hogy felvértezzük Önt néhány technikákat, amelyek segítségével megszünteti vagy csökkentse legalább néhány A frusztráció hogy már valószínűleg találkozott Az elmúlt héten egyedül. Tény, hogy előttünk van such-- néhány Az első probléma a C. És esély, Ha te, mint én, az első alkalommal megpróbál írja ki a program akkor is, ha úgy gondolja, logikusan A program nagyon egyszerű, Ön is nagyon jól megüt egy fal, és a fordító nem fog együttműködni. Tedd, vagy csenget nem megy hogy ténylegesen az ajánlattételt. 

És miért lenne az? Nos, vessünk egy pillantást, talán egy egyszerű program. Megyek, hogy menjen előre, és mentse ezt a Fájl szándékosan nevű buggy0.c, mert tudom, hogy kifogásolható előre. De lehet, hogy nem veszik észre, hogy ha ez a az első vagy második vagy harmadik program hogy igazából így magam. Így fogok menni előre, és írja ki, int main (void). Aztán belső én kapcsos zárójelek egy nagyon ismerős ( "hello, world-- backslash, n ") - és egy félig kettőspont. 

Már mentette a fájlt. Most fogok lemenni az én terminál ablak és adjuk ki a make buggy0, mert megint a fájl nevét ma buggy0.c. Szóval írd be: make buggy0, Enter. 

És, ó, istenem, előhívni utoljára hogy nincs hibaüzenet egy jó dolog. Tehát nem kimenet egy jó dolog. De itt van világosan Egyes hibák számát. 

Tehát az első sorban a termelés beírása után teszi buggy0, visszahívás, az csenget a meglehetősen bőbeszédű kimenet. A motorháztető alatt, CS50 IDE van konfigurálva hogy egy csomó opciók ezzel fordító így nem kell gondolkodni róluk. És ez minden, ami első sorban azt jelenti, hogy kezdődik csenget. 

De azután, hogy a problémák kezdődik, hogy a megjelenésüket. Buggy0.c a 3. sorban, karakter 5, van egy nagy, vörös hiba. Mi az? Burkoltan kijelentette könyvtár funkciója printf típusú int (const char *, ...) [-Werror]. Úgy értem, hogy nagyon gyorsan mindig nagyon misztikus. És természetesen, az első pillantásra, mi nem elvárják, hogy megértsék a teljes egészében az adott üzenetet. És így az egyik tanulság, ma megy hogy próbálja észrevenni minták, vagy hasonló dolgok, hibák lehet, hogy a múltban tapasztalt. Tehát lássuk ugratni egymástól csak ezeket a szavakat, ismerős. A nagy, vörös hiba egyértelműen szimbolikus, hogy valami baj van. 

hallgatólagosan nyilvánításáról könyvtári függvény a printf. Tehát akkor is, ha nem egészen értem, hogy mit burkoltan kijelentette könyvtár funkciója eszközöket, a probléma biztosan tárgya printf valahogy. És a forrás, hogy a kérdés köze nyilvánította. 

Nyilvánító funkció megemlíteni, hogy az első alkalommal. És mi használt terminológia a múlt héten deklarálási függvény prototípus, akár csak egy sort a tetején a saját fájlt vagy egy úgynevezett header fájlt. És milyen fájl nem mondunk a múlt héten, hogy a printf az idézet, idézet vége, kijelentette? Milyen fájl prototípus? 

Tehát, ha emlékeznek rá, a legelső dolog, amit gépelt, szinte minden program utolsó time-- és véletlenül egy pillanattal ezelőtt kezdődött gépelés myself-- volt ez here-- hash-- #include <stio-- számára input / output-- dot h És valóban, Ha most menteni a fájlt, megyek hogy menjen előre, és törölje a képernyő, amit tehetünk beírásával Tiszta, vagy tudod tartani Ellenőrző L, csak azért, hogy törölje a terminál ablakban csak azért, hogy megszüntesse néhány sűrűjébe. 

Megyek megy előre, és újbóli típusú make buggy0, Enter. És íme, még mindig látni, hogy hosszú parancsot csenget, de nincs hibaüzenet ebben az időben. És valóban, ha én ./buggy0, mint legutóbb, ahol dot jelent ez könyvtár, Slash csak azt jelenti, itt jön a program nevét és hogy a program neve is buggy0, Enter "hello, világ". 

Most, hogy lehet, hogy van félretett ez a megoldás anélkül, hogy feltétlenül felismerve annyi szó mint én, biztosan, amelynek tette ezt oly sok éven át? Nos, észre per az első probléma set, azt bemutatni, hogy egy parancs hogy CS50 saját személyzete írta nevű help50. És valóban, a C-nek specifikációja A probléma van beállítva, hogy hogyan kell használni ezt. 

De help50 lényegében olyan program, amely CS50 személyzete azt írta, hogy lehetővé teszi, hogy futtatni egy parancs vagy program futtatásához és ha nem érti a kimenet, hogy adja át a kimenetét help50, amely pontnál a szoftver hogy a pálya személyzete írta akkor nézd meg a program kimenetét soronként, karakterenként. És ha mi, a személyzet, felismeri a hibaüzenetet amit tapasztal, megpróbáljuk provokálni az Ön számára néhány költői kérdések, néhány tanácsot, mint egy TF vagy CA vagy magam tenne személyesen munkaidőben. 

Így néz ki a help50 ha nem feltétlenül ismeri fel a problémát. De nem hivatkozhat rá túl sok, mint egy mankó. Bizonnyal megpróbálja megérteni, hogy kimenet majd tanulni belőle úgy, hogy csak egyszer vagy kétszer mit botlott help50 egy adott hiba üzenet. Ezt követően, ha kell jobban felszerelt magad hogy kitaláljuk, mi valójában. 

Csináljunk egy másik itt. Hadd menjek előre, és egy másik fájlt fogjuk hívni ezt buggy1.c. És ebben a fájlban vagyok fog deliberately-- de úgy, mintha én nem megérteni, mi hibát csináltam. 

Megyek, hogy menjen előre, és nem this-- #include, amióta Megtanultam a leckét egy perce. Int main (void), mint korábban. És akkor itt fogok tenni s karakterlánc - get_string. És emlékszem az utolsó alkalom, hogy ez azt jelenti, hé, számítógép, adj egy változó, nevezzük s, és hogy milyen típusú a változónak egy karakterlánc így tudok tárolni egy vagy több szót is. 

Majd a jobb oldali oldalán az egyenlőségjel van get_string, amely egy funkciót a CS50 Könyvtár hogy pontosan ezt teszi. Kap egy funkciót, majd átadja jobbról balra. Tehát ez egyenlőségjel nem jelenti azt, "Egyenlő", mint gondolnánk a matematika. Ez azt jelenti, hozzárendelés jobbról balra. Tehát ez azt jelenti, hogy a string A felhasználó és tárolja belsejében s. 

Most használja. Hadd menjen előre, és most, mint a második vonal, hadd menjen előre, és azt mondják, "szia" - Nem "világ", hanem a "hello,% S- ami a mi helyőrzővel vessző s, ami a mi változó, majd pontosvessző. Tehát, ha nem csavarja fel túl sok Itt, ez úgy néz ki, mint a helyes kódot. 

És én ösztönök most már az összeállításhoz. A fájl neve buggy1.c. Így fogok tenni, hogy buggy1, Enter. És stoppol-IT, ha nincs még több hiba, mint korábban. Úgy értem, van még hibaüzenetek akkor lenne Úgy tűnik, mint a tényleges vonalak ebben a programban. 

De az elvihető itt, akkor is, ha túlterheltek két vagy három, vagy Négy további hibaüzeneteket, hangsúly mindig a nagyon Először ezeket az üzeneteket. Nézzük a legfelső egy, görgetés vissza, mint szükséges. Tehát itt beírtam make buggy1. Itt van az Clang kimenet, mint várták. 

És itt van az első piros hiba. A be nem azonosító húr, nem értem szabvány? Tehát szabvány van valójában valami mást. Arra utal, hogy a felhasználó billentyűzet, lényegében. 

De ez nem így értettem. Úgy értettem húr, és azt jelentette, get_string. Tehát mi az, hogy én elfelejtette megtenni ebben az időben? Mi hiányzik ebben az időben? Ott van a #include, így van, hogy a printf. 

De mit is nincs hozzáférés csak még? Nos, mint legutóbb, Azt kell mondani, a fordító Csengés, amit ezek a funkciók. Get_string nem jön C. És Különösen azt nem jön a header fájlt,. Ez helyett jön valamit a személyzet írt, amely egy másik fájl nevét, de találóan. 

Tehát egyszerűen, hozzátéve, hogy egy sort A code-- visszahívással utoljára hogy amikor csenget fut, ez lesz hogy nézd meg a kód fentről lefelé, balról jobbra. Meg fog észrevenni, ó, amit akar. Hadd menjen, és állapítsa meg, ahol ez a szerveren, és másolja, lényegében a tetején a saját file így ezen a ponton a történet, 1. sor, a többi a program lehet, sőt, használja a funkciót abban, köztük get_string. Így fogok figyelmen kívül hagyni a többi ilyen hibák, mert én, sőt, azt gyanítják, hogy csak Az első valóban számít. És én megyek előre, és futtassa újra, mentése után a fájlt, hogy buggy1. És íme, ez nem működik. És ha én ./buggy1 és írja be, mert Például Zamyla, most lesz hello, Zamyla helyett hello, világ. 

Rendben. Tehát a takeaways itt akkor kell, egyet, próbáld, hogy szed, amennyit csak tudsz A hibaüzenetek egyedül keres néhány a felismerhető szavakat. Korlátozó hogy használja help50 per A probléma meghatározott specifikáció. De korlátozó ez is mindig meg a tetején a hiba csak, legalább kezdetben, hogy milyen információkat ez talán valóban így. De kiderül, ott a még több funkciót épített a CS50 Könyvtár segíteni Ön korán a félévben és korán programozás kitalálni, hogy mi folyik itt baj. Tehát lássuk egy másik példát itt. Azt fogom hívni ezt buggy2, amely ismét meg fog hibás ki A kapu, a design. 

És én megyek előre és nem #include. És akkor fogok csinálni int main (void). És akkor fogok csinálni egy hurok. (Int i _ 0. i kisebb vagy egyenlő, mint 10. i ++, majd kapcsos zárójelek, megyek kinyomtatni csak egy hashtag szimbólum itt és egy új sor karakter. 

Tehát a célom ezzel a program nagyon egyszerűen iterálására 10-szer és minden egyes iteráció E hurok minden alkalommal át a ciklusban, nyomtassa ki a hashtag, Hashtag, a hashtag. Soronként, mert hogy az új vonal van. És emlékszem, hogy a vonatkozó hurok, egy utolsó week-- és akkor még több ismeri a szintaxis segítségével ez a gyakorlattal előtt long-- ez ad nekem változó az i, és beállítja 0. 

Ez megnöveli az I. Minden iteráció 1. Tehát én megy 1-2 3-ra. És akkor ez a feltétel az között középen félig kettőspont lesz ellenőrizni minden iterációban, hogy arról, hogy még mindig tartományon belül. Ezért szeretném iterálására 10-szer, így Van valami nagyon intuitív módon éppen tedd 10-én felső korlát van. 

És mégis, amikor futtatom ezt követően fordítanunk make buggy2-- és ez összeállítja az OK gombra. Szóval nincs szintaktikai hiba ebben az időben. Hadd menjek előre most és fuss buggy2, Enter. És most lépjünk fel. És hadd növelje a méret az ablak. 

Úgy tűnik, hogy az 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Tehát van 11 hashtags, bár Egyértelműen fel 10 belül ez a hurok. Nos, néhányan lehet látni azonnal mi a hiba azért van, mert valóban, ez nem egy nagyon nehéz hibát tenni. De ez nagyon gyakran tette nagyon korán. 

Amit én szeretnék rámutatni, bár, az, hogy hogyan lehet azt kiderítjük? Nos, kiderült, hogy A CS50 könyvtár jön nem csak get_string és get_int és get_float és egyéb funkciók. Meg is jön egy speciális funkcióval nevezett eprintf, vagy hiba printf. És ez csak és kizárólag tenni ez egy kicsit könnyebb amikor hibakeresés a kódot, hogy csak hibaüzenetet küld a képernyőn és tudom, honnan jött. 

Így például az egyik dolog, amit talán itt csinálni ezzel a funkcióval this-- eprintf, aztán megyek előre és mondom most% i, backslash, n. És megyek, hogy csatlakoztassa az i értékét. És fel tetején, mert ez a van a CS50 Library, Megyek, hogy menjen előre és tartalmazzák így van, hogy ezt a funkciót. De nézzük meg, mi vonal 9. kéne csinálnia. Megyek törölni ezt végül. Ennek semmi köze az én legfőbb cél. De eprintf, hiba printf, csak azt jelentette, hogy adjon nekem néhány diagnosztikai információkat. Amikor elindítom a programot, szeretnék lássa a képernyőn ideiglenesen valamint csak megérteni mi történik. 

És valóban, az egyes iterációs itt a 9-es vonal Látni akarom, mi az i értéke? Mi az i értéke? Mi az i értéke? És remélhetőleg én csak látja az üzenetet is, 10-szer. 

Tehát hadd menjen előre, és újrafordítod programom, ahogy azt kell tennie, bármikor Azt, hogy a változás. ./buggy2. És now-- OK. Van sokkal több folyik. Tehát hadd lépjünk fel még nagyobb ablakot. 

És látni fogod, hogy minden A hashtags még nyomtat. De mindegyik közé most ezt diagnosztikai kimeneti formátuma a következő. A név az én programot itt buggy2. A név a fájl buggy2.c. A vonal száma, ahonnan ez volt nyomtatva a 9-es vonal. , Majd a jobb oldalán van a hibaüzenet várok. 

És mi szép ez, hogy most már nem kell feltétlenül számolni a fejemben, amit a program csinál. Azt láthatjuk, hogy a első iteráció i értéke 0, majd 1, majd a 2, majd 3, majd 4, majd 5, majd 6, majd 7, majd 8, majd 9, majd 10. Tehát egy pillanat. Mi folyik itt? Még mindig úgy tűnik, hogy számlálás rendeltetésszerűen 10. 

De hol is kezdjem? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Így a 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11 ujj jelzi a problémát. Úgy tűnik, hogy számít tévesen az én hurok. Ahelyett, hogy menjen 10 ismétléseket Kezdek 0, Én végződő keresztül 10. De mivel, mint egy számítógép, Kezdek számlálás 0, Azt kell számolni fel , de nem keresztül, 10. 

És így a fix, végül is rájött itt, egy két dolgot. Tudtam nagyon egyszerűen azt mondják, számolni akár kisebb, mint 10. Így a 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ami valóban helyes, annak ellenére, hogy hangzik egy kicsit rossz. Vagy tehettem kisebb vagy egyenlő 9, mindaddig, amíg I 0-val kezdődnek. Vagy ha nagyon nem tetszik, hogy te számíthat fel a 10, de indul a 1. De ismétlem, ez csak nem az, hogy gyakori. In programming-- jóllehet nem annyira Scratch-- de a programozás C és más nyelveken, mint a JavaScript és Python és mások, ez Csak nagyon gyakori vitánk a bináris hogy csak elkezd számolni a legkevesebb tudsz, ami 0. Rendben. Tehát ez eprintf. És ismét, most, hogy kitaláltam én probléma, és én megyek vissza 0 keresztül kevesebb, mint 10, megyek menni, és törölni eprintf. 

Nem szabad ott lenni, amikor én szállítani a kód vagy elküldöm a kódot vagy azt mutatják, hogy bárki másnak. Ez tényleg csak azt jelentette, ideiglenes használatát. De most már kijavítottuk ezt sajátos problémát is. 

Nos, lenne még egy példa itt hogy megyek, hogy felkap a következő. Megyek megy előre, és #include. $ 50 És én megyek előre és #include. 

És én fogom megmenteni ezt a fájlt buggy3.c. És én megyek előre és állapítsa meg, int main (void). Aztán belsejében van Azt fogom csinálni, int i _ - Szeretnék végre egy programot egy get_negative_int. Ez nem egy függvény, amely nem létezik még. Így fogunk végrehajtani ez csak egy pillanatra. De megyünk, hogy miért ez hibás az első menetben. És ha egyszer már ütött int a felhasználó, Csak megyek nyomtatni% i negatív integer, backslash, n, vessző, i. Más szóval, minden, amit szeretné ezt a programot csinálni van, hogy egy negatív int a felhasználót, majd nyomtassa ki hogy ilyen és ilyen negatív int. 

Most kell végrehajtani ezt a feladatot. Így később az én fájlban fogok menni előre, és állapítsa meg a nevezett funkció get_negative_int (void) - és mi gyere vissza, hogy ez mit jelent vonal ismét egy moment-- int n; do-- do A following-- printf n :. És akkor fogok csinálni n - get_int, és ezt míg n értéke 0-nál nagyobb. Majd vissza n ;. 

Tehát van egy csomó folyik ezt, de egyik sem mi nem nézd meg a múlt héten, legalább röviden. Tehát on line 10; itt nyilvánították nevű függvény get_negative_int, és tettem (void), a zárójelben, az oka, hogy ez a nem veszi bemenet. Én nem halad semmit ezt a funkciót. Épp most valamit belőle. 

És amit remélem, hogy vissza az egész. Nincs adat típus C nevű negative_int. Ez csak int, így fog hogy a számunkra, hogy győződjön meg arról, hogy az érték, amely valójában visszaküldött nemcsak int de az is negatív. 

A 12. sorban én nyilvánító változó úgynevezett n, és így int típusú. Aztán a sorban 13 és 18 vagyok csinál valamit, amíg valami igaz. Megyek előre, és a nyomtatás n, vastagbél, majd egy szóközt, mint egy prompt a felhasználó számára. 

Én akkor még get_int és tárolása az úgynevezett visszatérési értéke hogy n változó. De megyek csinálom ez míg n értéke 0-nál nagyobb. Más szóval, ha a felhasználó ad én egy int és ez a szám nagyobb, mint 0, ergo, pozitív, megyek Csak ne reprompting a felhasználó, tartsa reprompting, arra kényszerítve őket, hogy együttműködnek, és adj egy negatív int. 

És ha n valójában negative-- Gondolom a felhasználó végül típusok -50, akkor ez a while ciklus már nem igaz mert -50 nem nagyobb, mint 0. Így kitörni, hogy loop logikusan és vissza n. 

De van egy másik dolog, amit meg kell csinálni. És én egyszerűen ezt a másolás és beillesztés egy sor kód tetején a fájlt. Meg kell tanítani csenget, vagy ígéretet zengés, kifejezetten, hogy én, Valóban, menj és végrehajtása Ezt a funkciót get_negative_int. Azt, hogy csak alacsonyabb a fájlban. Ismét emlékeztetni arra, hogy csenget olvasás dolgok fentről lefelé, balról jobbra, így nem lehet hívja a funkciót, ha csenget nem tudom, hogy fog létezni. 

Most, sajnos, ez a program, mint néhányan talán észrevették, már hibás. Hadd menjek előre, és a buggy3. Lefordítja, így a probléma most nem szintaktikai hiba, mint egy szöveges hiba, ez valójában lesz a logikai hiba, hogy én már szándékosan tette a lehetőséget, hogy átléphető, mi folyik. 

Megyek, hogy menjen előre és most fut buggy3. És én megyek előre, és nem működnek együtt. Megyek, hogy ez a szám 1. Nem tetszik, így ez megkérdezése megint. 

Hogyan körülbelül 2? 3? 50? Egyik ilyen dolgoznak. Hogyan -50? És a program úgy tűnik, működik. 

Hadd próbáljam meg még egyszer. Hadd próbáljam -1, úgy tűnik, működik. Hadd próbáljam -2, úgy tűnik, működik. Hadd próbáljam 0. Huh, ez helytelen. Most mi vagyunk, hogy egy kicsit pedáns itt. De ez valóban igaz, hogy 0 sem pozitív, sem negatív. És így az a tény, hogy a program mondván, hogy a 0 negatív egész szám, ez technikailag nem helyes. 

Most, hogy miért csinálja ezt? Nos, lehet, hogy nyilvánvaló. És valóban, a program azt jelentette, hogy viszonylag egyszerű így van valami, hogy tárja fel. 

De szeretnénk bemutatni egy harmadik hibakeresés technika itt az úgynevezett debug50. Tehát ez egy olyan program, hogy éppen most létrehozott ebben az évben az úgynevezett debug50 amely lehetővé teszi, használni az úgynevezett beépített grafikus debugger CS50 IDE. És egy debugger csak egy program, amely általában lehetővé teszi, hogy a program futtatása de lépésről lépésről lépésre, vonal által soronként, szüneteltetését dugta körül nézett változókat úgy, hogy A program nem csak fúj múltban és gyorsan nyomtasson valamit vagy nem nyomtat valamit. Ez lehetőséget ad arra, a emberi sebességgel, hogy kölcsönhatásba lépnek vele. 

És ezt, akkor Egyszerűen tegye a következőket. Összeállítása után a kódot, amely már nem, buggy3, megy előre, és futtassa debug50 ./buggy. Annyira, mint help50 van futtatása help50 majd a parancs, debug50 van futtatja debug50 és akkor a parancs neve. 

Most nézzük, mi történik az én képernyőn a jobb oldali, különösen. Amikor megüt Run, mind a Hirtelen ez a jobb oldali panel nyit meg a képernyőn. És van egy csomó folyik A első pillantásra. De nincs túl sokat aggódni még. 

Ez mutatja meg mindenre hogy folyik odabent programom és most ezeken keresztül gombok fel tetején van, akkor amely lehetővé teszi, hogy lépjek át a kódomat végül lépésről lépésről lépésre. De nem csak még. Figyeljük meg, mi történik. Az én terminál ablak Én is kéri n. És én megyek előre, és együtt ez idő típusú -1. És bár egy kicsit rejtélyesen, -1 negatív egész szám, mint az várható volt. 

És akkor a gyermek kilépni állapota 0 GDBserver kilépés. GDB, GNU Debugger, a neve Az alapul szolgáló szoftver megvalósító debugger. De mindez valójában azt jelenti, a hibakereső ment el, mert a programot kilép és minden rendben volt. Ha szeretné, hogy valóban hibakeresést a programot, Azt kell mondani preemptively debug50, ahol akarok kezdeni átlépett a kód? 

És talán a legegyszerűbb módja erre a következő. Ha az egérmutatót a ereszcsatorna én szerkesztő itt, így tényleg csak az oldalsávon itt, balra a sor számát, Figyeljük meg, hogy ha én csak kattintson Egyszer tettem egy kis piros pont. És az a kis piros pont, mint egy stoptábla, azt jelenti, hé, debug50, szünet végrehajtását kódomat ott, amikor elindul a program. 

Tehát lássuk, hogy. Hadd menjen előre, és futtassa a programot ismét debug50 ./buggy3, Enter. És most, értesítést, valami különböző történt. Én nem kéri még az én terminál ablakban semmit, mert nincs ütött ott még a programot. Figyeljük meg, hogy a 8-as vonal amely most kiemelt, és van egy kis nyíl bal mondás, akkor megállt itt. Ezt a kódsort, vonal 8, még nem teljesített. 

És mi furcsa, ha nézek itt a jobb oldali, észre, hogy én egy helyi változó, a helyi abban az értelemben, hogy van benne az aktuális funkciót. És annak értékét, látszólag alapértelmezés szerint és valami kényelmes, 0. De nem írja 0. Ez most történik, hogy a alapértelmezett értéke abban a pillanatban. 

Tehát hadd menjen előre, és ezt most. Hadd menjek előre, és a A jobb felső sarokban van, én fog menni előre, és kattintson az első ikonra olyan lépés alatt, ami azt jelenti, hogy ne hagyd ez azonban átlépik ezt a kódsort, futtatása az út mentén. 

És most, észre, én prompt nemrég megváltozott. Miert van az? Megmondtam debug50, futtatni ezt a kódsort. Mit jelent ez a kódsort csinálni? Késztet egy int. RENDBEN. Hadd együttműködnek. Hadd menjen előre, és most írja -1, Enter. És most észre, hogy mi változott. A jobb oldali, a helyi változó i jelzi, hogy a -1 most. És ez még mindig int típusú. 

És értesítést is, én úgynevezett hívja verem, hol én szünetet? Majd még beszélni ez a jövőben. De a hívási verem csak arra vonatkozik, amit funkciók jelenleg mozgásban. Most ez csak a fő. És most az egyetlen helyi változó i-1 értéket. 

És amikor végre átlépni ezt a sort itt, hogy ugyanaz az ikon a jobb felső sarokban, -1 Negatív egész szám. Most ez szüneteltetése alatt, hogy zárójel. Hagyjuk meg ezt a dolgot. Lépek a sor végén, és íme. 

Tehát egyáltalán nem olyan rettenetesen felvilágosító még, de ez nem hadd szünet és gondolja végig logikusan mi ez a program csinál. De nem ez volt a hibás helyzet. Csináljuk újra a következő. 

Megyek, hogy hagyja, hogy a töréspont 8. sor a piros pont. Megyek futtassa debug50. Ez automatikusan szünetel itt. De ez alkalommal, ahelyett, átlépve ezt a sort, hadd valójában bemenni a get_negative_int és kitalálni, miért van az elfogadó 0 érvényes válasz? 

Tehát ahelyett, hogy rákattint Step Over. Megyek, hogy menjen előre és kattintson Step Into. Azt tapasztaljuk, hogy a 8-as vonal, ami most kiemelt most hirtelen válik a 17. sorban. 

Most, hogy ez nem az a debugger már kimarad vonalak a 14 és a 15 és 16. Ez csak semmi hogy mutassa meg ott. Ezek csak nyilvánító változók, és akkor ott van a szó Do majd egy nyitott zárójel. Az egyetlen funkcionális sor, ami lédús tényleg ez itt, 17. És ez az, ahol voltunk szünetel automatikusan. 

Tehát printf ( "n.is:") ;, így hogy még nem történt meg. Szóval menjünk előre, és kattintson átlépni. Most a gyors, sőt, változott ( "n"). Most get_int, nem megyek zavarni lépve, mert a függvény volt által CS50 a Könyvtárban. Ez feltehetően helyes. 

Így fogok menni előre, és egyfajta együttműködést azáltal, hogy int, de nem negatív int. Tehát hadd menjen előre, és nyomja le a 0. És most mi történik itt ha kapok le a sorban a 21.? Már nem iterált újra. Úgy tűnik, nem kell ragasztani, hogy hurok. Más szavakkal, ez a sárga bár nem folyamatosan megy körbe, és környékén, és fordítva. 

Nos, miért van ez? Nos, n, mi n most? Azt nézd meg a helyi változók a debugger. n értéke 0. Rendben, mi volt az állapotom? 

20-- 20 sor, nos, 0 nagyobb, mint 0. Ez nem igaz. 0 nem nagyobb, mint 0. És így tört ki ebből. 

És ez az, amiért online 21, ha tényleg folytatni, Megyek return 0, még bár kellett volna utasítani 0 mivel valójában nem lehet negatív. Tehát most, én nem is igazán törődnek a debugger. Értem, nem kell tudja, mi több folyik. 

Így fogok menni előre, és Csak kattintson a Lejátszás gombra, és hagyja, hogy ezt befejezni. Most rájöttem, hogy az én hiba látszólag on line 20. Ez az én logikai hiba. 

És így mit akarok tenni, hogy ez megváltozzon? Ha a probléma az, hogy nem vagyok fogása 0, ez csak egy logikai hiba. És azt lehet mondani, míg n nagyobb vagy egyenlő 0, tartsa a felhasználó megkérdezése újra és újra. 

Szóval, megint egyszerű hiba, talán még nyilvánvaló, amikor meglátott írd csak néhány perce. De az elvihető itt az, hogy a hibakeresési 50, és hibakeresés szoftverek általában Van ez az új hatalom talált séta a saját kódját, nézd keresztül, hogy a jobb oldali panelen, amit A változók értékei. Szóval nem feltétlenül kell használni valamit mint te eprintf nyomtatni ezeket az értékeket. Akkor valóban látni őket vizuálisan a képernyőn. 

Most, ezen túl, érdemes megjegyezni, hogy van egy másik módszer, ami valóban szuper gyakori. És akkor felmerül a kérdés, hogy miért ez a kis fickó már ül a színpadon. Tehát itt van ez a technika, általában néven gumi kacsa hibakeresés, amely valójában csak egy tanúskodik, hogy az a tény, hogy gyakran, amikor a programozók írunk kódot, ők nem feltétlenül másokkal együttműködik, vagy dolgozik egy közös környezetben. 

Ők egyfajta otthon. Lehet, hogy késő este. Megpróbálnak alak néhány hiba a saját kódját. És ők csak nem látta azt. 

És nincs szobatársam. Nincs TF. Nincs CA körül. Minden ezek a termékek megfelelő eltarthatósági ez a kis gumi aranyom. 

És így gumi kacsa hibakeresés csak ezt a meghívást gondolni valami buta mivel ez, mint egy igazi lény, és valóban séta a kódot szóban erre élettelen tárgyat. Így például, ha ez az én példa here-- és emlékszem, hogy korábban A probléma az volt, ezt, ha törlöm az első kódsor és megyek előre, és a buggy ismét 0 Emlékeztetünk arra, hogy volt ilyen hibaüzenetek itt. Tehát az ötlet, nevetséges bár úgy érzi, ebben a pillanatban ezt nyilvánosan, hogy hiba. 

OK, így a probléma az, hogy én már hallgatólagosan nyilvánították könyvtári függvény. És, hogy a könyvtári funkció printf. Declare-- OK, állapítsa emlékeztet a prototípusok. 

Ez azt jelenti, kell, hogy ténylegesen mondja a fordító előre, hogy milyen A függvény így néz ki. Várj egy percet. Nem szabványos io.h. Nagyon szépen köszönjük. 

Tehát csak ez a folyamat of-- te Nem kell, hogy ténylegesen van egy kacsa. De ez az ötlet, séta Ön is saját kódját úgy, hogy még hallani magad, úgy, hogy megvalósítani kihagyások saját megjegyzések, általában az ötlet. 

És ami talán még értelemszerűen nem annyira sokat, hogy az egyik, de a nagyobb részt Például mi csak tette buggy 3.c, lehet járni magad rajta alábbiak szerint. Tehát minden rendben, gumi aranyom, DDB, ha úgy tetszik. Itt van az én fő funkciója, Hívom kap negatív int. 

És kapok a visszatérési érték. Én tárol a bal oldali 8. sor a változó az i. OK, de várj, hogyan sikerült kap, hogy ezt az értéket? Hadd nézzem meg a függvény 12-es vonal. 

Összhangban 12, már kap negatív int. Nem vállal bemenet, nem tér vissza int, OK. Kijelentem on line 14 változó n. Meg fog tárolni egy egész szám. Ez az amit akarok. 

Tehát nem a következő, míg n is-- hagyja nekem visszavonni, amit a fix én már. Tehát míg n nagyobb, mint 0, kinyomtatni n van, az OK gombra. Majd hívja kap int tárolt n. És akkor ellenőrizze, ha n értéke 0, n nem-- ez van. Szóval, megint, akkor nem szükség a tényleges kacsa. De csak séta ki magad A kód szellemi gyakorlatként Gyakran segít észre, mi folyik itt, szemben a csak csinál valamit mint ez, bámulja a képernyőt, és nem beszél ki magad azt, ami őszintén nem majdnem olyan hatásos technika. Így van ez, a Számos különböző technikák a tényleges hibakeresés a kódot és találni hibát, amelyek mindegyike kell az eszközöket a eszközkészlet így, hogy te nem késő este, különösen, te vagy az étkező csarnokok, vagy munkaidőn, dörömböl a fejét a fal, próbálják megoldani a problémát. Ismerd fel, hogy vannak olyan szoftverek. Vannak gumi kacsa eszközöket. És van egy egész személyzete támogatja vár, hogy megadja a kezét. 

Tehát most, egy szó a probléma készletek, és amit mi abban a reményben, kap ki őket, és hogyan megyünk kiértékeléséhez. Per a tanfolyam tananyag, CS50 probléma készletek értékelik négy elsődleges tengely, így a speak-- körét, korrektség, tervezés, és a stílus. És hatálya csak arra vonatkozik, hogy mennyi A darab már akkor harapta le? Mekkora problémát próbálta már? Milyen szintű erőfeszítéseket már akkor nyilvánul? 

Helyesség, nem az a program működik, mint ez állítólag egy CS50 specifikáció ha megadja az egyes bemenetek vagy bizonyos kimenetek jön vissza? Design a szubjektív őket. És ez az egyik, hogy a leghosszabb tanulni és a leghosszabb tanítani, a amennyiben ez csapódik le, milyen jól leírtam a kódot? 

Ez az egyik dolog, hogy csak nyomtatni a megfelelő kimenetek, vagy vissza a megfelelő értékeket. De csinálod, mint lehető leghatékonyabban? Csinálod szakadék és uralkodj, vagy bináris keresés ahogy hamarosan látni, hogy mi Két héttel ezelőtt a telefonkönyv? Van jobb mód, hogy megoldja a probléma, mint jelenleg van itt? Ez lehetőséget a jobb design. 

És akkor hogyan style-- szép az a kód? Észre fogod venni, hogy én vagyok elég különösen arról beljebb a kód, és gondoskodjanak arról, én változók ésszerűen elemzi. N, míg a rövid, egy jó név egy szám, én egy számláló értéke, s egy húr. És mi lehet hosszabb változó nevek stílusban. A stílus, hogy milyen jó nak a kódot néz? És hogyan olvasható ez? 

És idővel, amit a TA és TF fog tenni a tanfolyam van az Ön számára, hogy fajta minőségi visszajelzést úgy, hogy jobban azokon különböző aspektusait. És tekintve, hogy mi értékeli mindegyik tengelyen ez általában nagyon kevés vödrök, így általában hogy egyfajta milyen jól csinálsz. És valóban, ha kap egy pontszámot bármely olyan axes-- helyességét, design és stílus especially-- ezt a számot általában 1 és 5 között. És szó szerint, ha kapok 3-as elején a félév, ez egy nagyon jó dolog. Ez azt jelenti, hogy még mindig javítani, amely akkor remény a vesz egy osztály az első alkalommal. Van remélhetőleg néhány kis mennyezeti amelyhez te törekvő elérése. És így egyre 3-ek A legkorábbi darabok, ha nem egy 2-es és 4-es, Valóban, egy jó dolog. Ez jól tartományon belül, valamint a várakozásokat. 

És ha az elméd a versenyzés, várjon Egy perc, ötből három. Ez tényleg egy 10-ből 6. Ez 60% -os. Istenem, ez egy F. 

Ez nem. Nem, sőt, hogy. Inkább ez egy lehetőség, hogy javítsa során a félév. És ha kapok néhány Poors, ezek lehetőséget kihasználni munkaidejében biztosan szakaszok és egyéb források. 

A legjobb egy olyan lehetőség, tényleg, büszke lehet csak, hogy épp jöjjön során a félév. Tehát ezt észre, ha semmi mást, három jó. És ez lehetővé teszi szobában a növekedés idővel. 

Ami hogyan kell e tengelyek súlyozott, reálisan te fogja tölteni a legtöbb időt kapok dolgokat munka, nemhogy helyesen. És így helyességét hajlamos súlyozzák a leginkább, mint a ez multiplikatív háromszoros. Design is fontos, de valami, amit nem feltétlenül tölteni az összes ilyen órát megpróbál a dolgok csak a munka. 

És ez így van súlyozva egy kicsit könnyedebb. És akkor stílus súlyozott legkisebb. Annak ellenére, hogy ez nem kevésbé Fontos alapvetően, ez csak talán, a legegyszerűbb dolog jobb, utánozva a példák itt előadás és részben A dolgok szépen tagolt, és megjegyezte, és így tovább az egyik legegyszerűbb dolgom, és rögtön. Tehát mint ilyen, észre hogy ezek pont amelyek viszonylag könnyen megfogható. 

És most egy szót this-- akadémiai őszinteség. Tehát egy a pálya tananyag, látni fogja hogy a tanfolyam már elég kis nyelv körül ez. És persze komolyan veszi az akadémiai őszinteség elég komolyan. 

Megvan a különbséget, jobb vagy rosszabb, A elküldvén évente több hallgatók fegyelmi eljárást mint a legtöbb más Persze, hogy én vagyok tisztában. Ez nem feltétlenül utal az a tény, hogy a CS diákok, illetve CS50 diákok, amelyek kevésbé őszinte, mint az osztálytársai. A valóság azonban az, hogy ebben a világ, elektronikus úton, mi csak van technológiai eszközök felismerésére. 

Fontos, hogy velünk méltányosság az egész osztály hogy mi ezt észre, és emelje A kérdés, ha látjuk a dolgokat. És csak festeni egy képet, és tényleg hogy segítsen valami ehhez hasonló mosogató, Ezek a számok a diákok az elmúlt 10 évben hogy részt vettek valamilyen ilyen kérdések akadémiai őszinteség, A mintegy 32 diák ősztől 2015, ami azt jelenti, hogy mi fog az ügyet nagyon komolyan. És végül, ezek a számok össze, Legutóbb, mintegy 3%, 4%, vagy úgy az osztály. 

Így a szuper hallgatók többsége úgy tűnik, hogy a vonalak világos. De ezt tartsd Mindegy, különösen későn éjszaka, amikor küzd néhány megoldást a problémára sor, hogy vannak mechanizmusok szerzés magát jobban támogatást, mint ti úgy gondolja, még abban az órában. Ismerd fel, hogy amikor megkapjuk hallgató beadványát, átkelünk össze minden beküldött idén ellen minden beküldött tavaly, ellen minden beadvány 2007 és mivel, nézi, valamint, kódtáraihoz online vitafórumok, munka oldalak. És mi említem ezt, tényleg, az összes kedvéért A teljes körű tájékoztatás, hogy ha valaki megtalálja az interneten, természetesen, így lehet azt a tanfolyamot. De tényleg, a szellem A kurzus csapódik le e záradék a tananyag. Ez tényleg csak, ésszerűnek. 

És ha lenne, hogy dolgozza ki, hogy csak egy kicsit több nyelven, észre, hogy a lényege az összes munka, hogy nyújtson be a tanfolyamra kell lennie a saját. De ezen belül is vannak természetesen lehetőségeket, és bátorítást, és pedagógiai érték fordul others-- magam, a TF, a CA, a TA, és mások az osztályban, támogatásra, nemhogy barátok és a szobatársak, akik tanulmányozták CS és a programozás előtt. És így van egy ráhagyás ezt. És az általános ökölszabály A this-- ha segítséget kérsz, akkor mutatják be a kódot, hogy mások, de lehet, hogy nem tekintheti az övék. Tehát akkor is, ha a munkaidejében vagy a D csarnokban, vagy valahol máshol dolgozunk néhány darabos készlet, dolgozik együtt egy barát, ami teljesen rendben van, a A nap végén a munka végső soron tartozó minden Az Ön esetében, és nem néhány közös munka kivéve az utolsó projekt, ahol ez megengedett és bátorított. 

Ismerd fel, hogy ha küzd valami és a barátja épp, hogy jobban megy, akkor, vagy jobb, hogy a probléma, mint te, vagy egy kicsit előrébb, mint te, ez teljesen ésszerű, hogy kapcsolja hogy a barátja, és azt mondják, hé, Nem bánja, néztem a kódot ide, segített észrevenni, mi a probléma? És remélhetőleg a érdeke pedagógiai értékkel a barát nem csak mondjuk, ó, erre, hanem, mit hiányzik on-line 6, vagy valami ilyesmi? De a megoldás nem A barát melletted mondani, ó, nos, itt, hadd vessem ezt fel, és jelenjen meg a megoldást az Ön számára. Tehát ez a vonal. Mutassa kódot mások, de nem lehet megtekintheti az övék, feltéve, hogy a többi megszorítások során a tananyag. 

Tehát ne feledje, ez a úgynevezett sajnálom záradék során a tananyag is, hogy ha elkövetni néhány cselekmény nem ésszerű, hanem hogy azt a figyelmet a pálya fejek 72 órán belül, a természetesen szabhat helyi szankciókat tartalmazhat egy kielégítő, vagy elégtelen osztályzatot a beadott munkát. De a tanfolyam nem utalja számít a további fegyelmi eljárás eseteket kivéve ismétlődő cselekmények. Más szóval, ha nem, hogy néhány buta, különösen a késő éjszakai, döntés hogy a következő reggel vagy két nap Később, felébredsz, és rájönnek, mit gondoltam? Ön itt van CS50 aljzathoz rögzítésére, hogy a probléma és a tulajdonos akár azt, hogy mi találkozunk félúton, és foglalkozik vele egy ügyben, amely egyszerre oktatási és értékes az Ön számára, de még mindig büntető valamilyen módon. És most, hogy a szélén le, ezt. 

[VIDEO LEJÁTSZÁS] 

[ZENE] 

[END LEJÁTSZÁS] David J. MALAN: Rendben, vissza. És most nézzük az egyik először a valódi világ domainek a CS50, a művészet a kriptográfia, A szakterületen küldésére és fogadására titkos üzeneteket, titkosított üzenetet, ha úgy tetszik, hogy csak akkor értelmezhetőek, ha van Néhány kulcsfontosságú összetevője, hogy a feladó is. Tehát, hogy motiválja ezt elvisszük nézd meg ezt a dolgot itt, amely egy példa a titkos dekóder gyűrűt lehet használni annak érdekében, hogy kitalálni milyen titkos üzenetet valójában. Tény, hogy vissza a nap az iskolában, ha valaha is küldött titkos üzeneteket Néhány barát vagy egy összetörni az osztályban, Ön gondolta volna te, hogy okos által a papírlapot változó, mint például, a B, A és B a C, és a C-D, és így tovább. De valóban titkosítása Tájékoztatásul közöljük, hogy még ha ez egy kicsit triviális, nem volt hogy a kemény, hogy a tanár észre, Nos, ha csak változtatni B-A és C-ből B, ténylegesen kitalálni mi volt az üzenet, de volt rejtjelezés információkat. 

Te csak csinálja Egyszerűen, ugyanúgy, mint Ralphie itt egy híres film, játszik nagyjából csömörig minden télen. [VIDEO LEJÁTSZÁS] -be Azt mindenki által ismert, hogy a Ralph Parker ezennel kinevezett tagja a Kis Orphan Annie Secret Circle és jogosult a kitüntetés és előnyök előforduló hozzá. 

-Signed, Little Orphan Annie, counter aláírt Pierre Andre, tintával. Kitüntetések és előnyök, Már kilenc évesen. 

[KIABÁLÁS] -Gyerünk. Lássunk hozzá. Nem kell ez a jazz körülbelül csempészek és kalózok. 

-Listen Holnap este A záró kaland A fekete kalózhajó. Most, hogy itt az ideje Annie titkos üzenete Önnek tagjai a titkos kör. Ne felejtsük el, a gyerekek, csak a tagok Annie Secret Circle dekódolni tudja Annie titkos üzenetet. 

Ne felejtsük el, Annie függ. Állítsa be csap a B2. Itt van az üzenet. 12, 11-- 

-I Vagyok, az első titkos találkozón. 

-14, 11, 18, 16. 

-Pierre Volt nagy hangja ma este. Elmondhatom, hogy a ma esti üzenet igazán fontos volt. 

-3, 25, ez egy üzenet Annie magát. Emlékezz, ne mondd el senkinek. 

-90 Másodperccel később, én vagyok az egyetlen szoba a házban, ahol egy fiú kilenc tudott ülni adatvédelmi és dekódolni. Aha, B! Elmentem a következő, E. 

Az első szó lesz. S, hogy jön könnyebb most, U, 25-- 

-Ó, Gyerünk, Ralphie, mennem kell! 

-I'll Lehet jobbra le, Ma! Ez zseniális! 

-T, O, biztos az alábbiakra: biztos, hogy mit? Mi volt kis árva Annie mondani? Ügyeljen arra, hogy mit? 

-Ralphie, Andy kapott, hogy megy, kérem jöjjön ki? 

Rendben, Ma! Hamarosan ki! 

-I Egyre közelebb van. A feszültség szörnyű volt. Mi volt az? A sorsa a bolygó lefagy az egyensúlyt. 

-Ralphie! Andy mennie kell! 

-I'll Hamarosan ki, az isten szerelmére! 

-Almost Ott, ujjaim repült, az elmém volt egy acél csapda, minden pórus vibrált. Már majdnem tiszta, igen, igen, igen. 

-be Fogyasszon el Ovaltine. Ovaltine? A ciki kereskedelmi? A kurva életbe. [END LEJÁTSZÁS] David J. MALAN: OK, így ez egy nagyon hosszú út bevezetésének kriptográfia, és Ovaltine. Tény, hogy ebből a régi hirdetés Itt miért Ovaltine olyan jó? Ez egy koncentrált extrakció érett maláta, tiszta krémes tehéntej, és speciálisan előkészített kakaós, együtt természetes foszfatidokat és vitaminok. Ez tovább dúsítva további vitaminokat B és D yum. És akkor még mindig meg, úgy tűnik, az Amazon, mint mi itt. 

De a motiváció az volt, hogy bevezetni kriptográfia, kifejezetten olyan típusú kriptográfiai ismert titkos kulcsú titkosítás. És ahogy a neve is sugallja, az egész biztonságát titkos kulcs titkosítási rendszer, ha úgy tetszik, a módszer mindössze rejtjelező információk két ember között, hogy csak a feladó és a címzett csak egy titkot key-- némi értéke, néhány titkos mondat, néhány titkos szám, hogy lehetővé teszi számukra, hogy mindkét titkosítani és visszafejteni adatokat. És a kriptográfia, tényleg, Csak ez van hétről 0. 

Ez egy probléma, ha van bemenet, mint a tényleges üzenetet angolul vagy bármilyen nyelvet, amit szeretnénk küldeni valakinek az osztályban, vagy az interneten keresztül. Van némi teljesítmény, ami megy hogy a kódolt üzenetet, amelyet meg szeretnénk, hogy a címzett megkapja. És akkor is, ha valaki a közepén kapja is, nem akarja, hogy feltétlenül lesz képes visszafejteni, mert belülről ennek fekete doboz, vagy algoritmus, van néhány olyan mechanizmust, néhány lépésről lépésre utasítások, a figyelembe, hogy a bemeneti és átalakítása a kimenete remélhetőleg biztonságos módon. 

És valóban, van némi szókincs ebben a világban az alábbiak szerint. Egyszerű szöveg a szó egy számítógép tudós lenne használja, hogy leírja a bemeneti üzenet, mint az angol vagy bármilyen nyelvet ténylegesen szeretnénk küldeni egy másik ember. És akkor a rejtjelezett a tülekedés A titkosított, vagy titkosított, verziójára. 

De van egy másik összetevő van. Van egy másik bemenet titkos kulcsú titkosítást. És ez a kulcs is, amely általában mint látni fogjuk, számos, vagy levél, vagy szó, bármi Az algoritmus valójában elvárja. 

És hogyan dekódolja az információt? Hogyan megfejt ez? Nos, csak fordított a kimenetek és a bemenetek. 

Más szóval, ha valaki megkapja a titkosított üzenetet, ő egyszerűen Fontos tudni, hogy ugyanazt a kulcsot. Kaptak a rejtjelezett. És dugulás a két bemenetek a titkosítási rendszer, Az algoritmus a fekete doboz, ki jöjjön az eredeti nyílt szöveg. És ez az a nagyon magas szintet vélekedik kriptográfia valójában szól. 

Tehát menjünk oda. Nézzük most meg alatta A motorháztető valami mi már szedett nyújtott Az elmúlt héten, és ezen az ülésen here-- a húr. Egy karakterlánc végén a nap csak egy karaktersorozat. 

Lehet, hogy hello world, vagy szia Zamyla, vagy bármi más. De mit jelent ez a egy karaktersorozat? Tény, hogy a CS50 könyvtár ad nekünk egy adattípust nevű karakterlánc. 

De valójában nincs olyan dolog, mint egy húr a C. Ez tényleg csak egy sorozata karakter, karakter, karakter, karakter, vissza, vissza, hogy vissza, vissza, vissza belsejében a számítógép memóriájában, vagy a RAM. És akkor nézd mélyebbre, hogy a jövőben, amikor megnézzük a memória is, és a hasznosítás, valamint a fenyegetések, melyek részt vesznek. 

De nézzük meg a húr Zamyla. Tehát csak a nevét Az emberi itt Zamyla, hogy egy sorozata karakterek, Z-A-M-Y-L-A. Most tegyük fel, hogy Zamyla neve a tárolás belsejében egy számítógép program. 

Nos, magától értetődik, hogy mi kell tudja nézni ezeket a karaktereket egyénileg. Tehát én csak fog felhívni egy kicsit doboz körül Zamyla nevét itt. És ez a helyzet a C, hogy amikor van egy szöveg, mint Zamyla-- és talán ez a karakterlánc jött vissza hasonló függvény get húr, akkor valóban manipulálni ez betűnként. 

Nos, ez illenek a beszélgetés kéznél, mert kriptográfiai ha meg akarja változtatni A-B és B-C, és a C-D, és így tovább, akkor képesnek kell lennie nézni az egyes karakterek a szövegben. Be kell, hogy képes megváltoztatni Z másra, az A valami mást, az M valami mást, és így tovább. És így kell a módját, programból, így beszélni, C-ben, hogy képes legyen megváltoztatni és nézd meg az egyes betűk. És ezt meg tudjuk tenni a következő. 

Hadd menjen térjen vissza a CS50 IDE. És hadd menjen előre és hozzon létre egy új fájlt hogy hívom ezúttal string0, például az első ilyen példa, pont c. És én megyek előre és ostor fel az alábbiak szerint. 

Így többek között CS50.h, és majd közé tartoznak a standard io.h, amely már majdnem mindig lesz használja az én programok, legalább alapvetően. int fő érvénytelen, és aztán itt vagyok csinálni húrok lesz kap húr. És akkor megyek megy előre, és erre a célra. Azt akarom, hogy menjen előre és, mint egy alapvető ellenőrzést, Csak azt mondják, hello, százalék s, pontosvessző teszi húr 0. Ajjaj, mit csináltam itt? Ó, én nem dugja be. Tehát tanulság, hogy Nem volt szándékos. 

Tehát a hiba, nagyobb százalék konverziót, mint az adatok érveket. És ez az, ahol, vonal 7-- OK, úgyhogy, idézet idézőjel bezárva, ez én húr a printf. Van egy százalék jelet. De én eltűnt a második érv. 

Hiányzik a vessző s, amely Én már az előző példákban. Tehát egy jó lehetőség, hogy rögzítse Még egy hiba, véletlenül. És most hadd futni string0 írja be Zamyla. OK, helló Zamyla. 

Így már fut ez a fajta program néhány különböző időpontokban most. De csináljunk valamit a kicsit más ebben az időben. Ahelyett, hogy csak a nyomtatást Zamyla a teljes név ki printf, csináljuk karakterenként. 

Megyek, hogy egy hurok. És én adok magamnak a számláló változó, az i. És én fogom tartani iterációjával, így amíg én kisebb, mint a hossza s. 

Kiderült, mi nem Ehhez utoljára, hogy c jön egy nevű függvény Stirling. Vissza a nap, és általában még ha a végrehajtási funkciók, emberek gyakran dönt, nagyon tömör nevek a fajta hang mint amit szeretne, annak ellenére, hogy hiányzik néhány magánhangzók vagy betűket. Tehát Stirling az Íme egy függvény, amely vesz egy érv között zárójelben, hogy legyen egy string. És ez csak vissza egy egész, hosszát, hogy a húr. 

Tehát ez a hurok on line 7 megy kezdeni a számlálást i értéke 0. Meg fog növelni i minden iterációban 1, mivel mi már ennek egy párszor. De ez meg fog csak ezt ez egészen a pontig mikor a hossza A húr is. 

Tehát ez az egyik módja annak, végül, iterációt a karakterek a húr, ahogy van a következő. Megyek, hogy nyomtassa ki nem egész szöveg, de százalékkal c, egyetlen karaktert majd egy új sort. És akkor megyek megy előre, és azt kell azt mondani, hogy a nyomtatni kívánt edik karaktere s. 

Tehát, ha az i változót, ami azt jelzi, Az index a húr, ahol van benne, azt kell, hogy képes legyen mondani, hogy nekem az i-edik karaktere s. És c egy módja a ezt szögletes zárójelben. Egyszerűen mondja ki a nevét húr, amely ebben az esetben az, s. Akkor használja szögletes zárójelben, amelyek Általában csak a fenti a Return vagy Enter gombot a billentyűzeten. És akkor tedd az index az kívánt karaktert nyomtatni. Így az index lesz number-- 0, vagy 1, vagy 2, vagy 3, vagy DOT, dot, dot, egy másik számot. 

És mi biztosítja, hogy ez meg fog a helyes számot, mert elkezd számolás 0. És alapértelmezés szerint az első karakter Egy karakterlánc közmegegyezés 0. És a második karakter konzol 1. És a harmadik karakter konzol 2. És akkor nem érdemes túl sokat messze, de nem fogunk, mert mi vagyunk fog csak akkor növekszik, amíg én megegyezik a karakterlánc hossza. És ahol a ponton, Ez a for ciklus leáll. 

Tehát hadd menjen előre, és mentse ezt programot, és fuss String 0. De elcsesztem. Burkoltan kijelentette könyvtár funkciója Stirling típusú ilyen és such-- most, ez ismerősen hangzik. De ez nem printf. És ez nem fog sor. 

Nem csavarja fel Ugyanígy ebben az időben. De észre le ide egy kicsit le továbbá, tartalmazza a fejléc string.h, kifejezetten biztosítja a nyilatkozat Stirling. Tehát tulajdonképpen egy nyom van. 

És valóban kiderül, van egy másik header file hogy már nem használt osztályban még, de ez között rendelkezésre álló neked, az úgynevezett string.h. És abban a fájlban, string.h a Stirling nyilvánított. Tehát hadd menjen előre, és menteni ezt, hogy húr 0-- szép, hibaüzenet nélkül ebben az időben. 

./string0 Zamyla, és Mindjárt megüt Belép, ekkor getstring megy vissza a húr, betette s. Aztán, hogy a hurok fog hajtogat felett S karaktereket egyesével, és nyomtassa ki őket soronként, mert Volt, hogy a fordított perjel n a végén. Így tudtam kihagyni, hogy backslash n, majd csak nyomtatni Zamyla összes az ugyanabban a sorban, hatékonyan reimplementing printf, ami egyáltalán nem olyan hasznos. De ebben az esetben, azt még nem tette ezt. Már tényleg nyomtatott változattal karakter egy időben, soronként, hogy mi valójában a hatás. 

De figyelembe kell venni, egy dolog van. És mi jön vissza ez egy jövőbeli héten. Kiderült, hogy ez a kód potenciálisan hibás. 

Kiderült, hogy get húr és néhány egyéb funkciók az életben nem feltétlenül mindig visszatérni, amit várt. Tudjuk osztály utolsó alkalommal ebben kap, hogy karakterlánc volna vissza a húr. De mi van, ha a felhasználó az ilyen Hosszú szó vagy bekezdés, vagy esszé hogy ott van csak nem elég memória a számítógépben, hogy illeszkedjen. 

Mint, mi van, ha valami nem megy rossz a motorháztető alatt? Lehet, hogy nem fordul elő gyakran, de ez megtörténhet egyszer egy darabig, nagyon ritkán. És így kiderül, hogy get húr és úgy működik, mint ez nem feltétlenül mindig visszatér szálakat. Lehet, hogy visszatér némi hibával, Néhány sentinel értéket úgy mondjam, amely jelzi, hogy valami nincs rendben. És akkor csak tudjuk ezt a miután megtanulta az osztályban most, vagy olvastam néhány dokumentációt. Kiderült, hogy get húr lehet visszatérési értéke az úgynevezett null. Null külön értéke, hogy fogunk jöjjön vissza egy későbbi héten. De most, csak tudom, hogy ha akarom, hogy valóban a megfelelő halad előre használatával get húr, azt ne csak nevezni, és vakon használni a visszatérési érték, bízva abban, hogy ez egy húr. 

Azt kell először mondani, hé, várj egy percet, csak eljárni, ha s nem egyenlő null, ahol null ismét csak néhány különleges értéket. És ez az egyetlen különleges értéket kell aggódnia get húr. Get stringet sem megy hogy visszatérjen egy string vagy null. 

És ez a felkiáltójel egyenlőségjel talán tudják talán, matekórán hogy lehet felhívni egy egyenlőségjelet a egy sort, jelezve nem egyenlő. Ez általában nem egy karakter beírhatja a billentyűzeten. És így a legtöbb programozási nyelvben, ha azt akarom mondani nem egyenlő, használ egy felkiáltójel, más néven bumm. Tehát azt mondod, bumm egyenlő, amely jelenti, hogy nem felel meg, logikusan. Olyan ez, mint ott nem nagyobb mint, vagy egyenlő, vagy kisebb, mint vagy egyenlő a billentyűzeten hogy nem az egészet egy szimbólum. Tehát ezért, az elmúlt példák, te egy nyitott zárójel, majd egyenlőségjel, annak érdekében, hogy ezt nagyobb vagy, mondjuk, kevesebb. 

Tehát mi a elvihető itt? Ez egy egyszerű módja a most a bevezetésével ezt a szintaxist, ezt a funkciót, iterációt egyéni karakterre. És csakúgy, mint azok, szögletes zárójelben lehetővé teszi, hogy őket, figyelembe vennie azokat szögletes zárójelek fajta sejteti ezt az alapvető design, amellyel minden karakter belsejében egy húr A fajta dobozos valahol alatta A motorháztető a számítógép memóriájában. 

De nézzük, hogy egy változata ennek. Kiderült, hogy ez a program helyes. Tehát egy CS50 a tengely értékeléséhez kód, ez most már megfelelő. Különösen most, hogy én vagyok ellenőrzése null, ez a program soha nem összeomlik. És én tudom, hogy a tapasztalatokból. De nincs semmi más, akkor tényleg baj van. De ez nem nagyon jól megtervezett, mert menjünk vissza az alapokhoz. 

Először is, Elvei mit csinál egy hurok csinálni? A hurok három dolgot. Ez inicializálja néhány értéket, ha kéred, hogy. Ez ellenőrzi a feltételt. És azután minden iteráció után minden ciklusban, ez megnöveli néhány érték, vagy értékek, itt. 

Tehát mit jelent? Inicializáljuk i 0. Mi ellenõrzésére, i-nél kisebb a hossza s, ami Z-A-M-Y-L-A, így, ami kevesebb, mint 6. És valóban, 0 a kevesebb, mint 6. 

Kinyomtatjuk Z-re Zamyla nevét. Ezután növeljük i 0-1. Ezután ellenőrizze, 1 kisebb mint a hossza s? A hossza s 6. Igen ez az. 

Így nyomtasson a Zamyla nevét, ZA. Mi növekmény I 0, 1, 2. Ezután ellenőrizze, 2-nél kisebb hossza Zamyla nevét. 6- SO 2 kisebb, mint 6. Igen, most ki kell nyomtatni most M Zamyla nevét, a harmadik karakter. 

A legfontosabb az, hogy az egyes iteráció a történet, én ellenőrzése, jelentése i kisebb, mint a hossza Zamyla? De a fogást, hogy Stirling nem tulajdonság. Azok, akik programoztak mielőtt a Java vagy más nyelven Lehet tudni, hogy a karakterlánc hosszát is ingatlan, csak néhány, csak olvasható érték. 

A C-ben ebben az esetben, ha ez az egy függvény, amely a szó szoros értelmében megszámlálásával karakterek Zamyla minden alkalommal hívjuk ezt a funkciót. Minden alkalommal, amikor kérdezni a számítógép használatához Stirling, ez egy pillantást Zamyla, és azt mondja Z-A-M-Y-L-A, 6. És visszatér 6. A következő alkalommal, amikor hívást belsejébe, hogy hurok, ez fog nézni Zamyla ismét, mondjuk Z-A-M-Y-L-A, 6. És ez meg fog visszatérni 6. Tehát mi hülye erről design? 

Miért van a kód nem egy 5 out of 5 tervezés most, hogy úgy mondjam? Nos, én kérek kérdés feleslegesen. Csinálok több munka, mint azt kell. 

Tehát annak ellenére, hogy a válasz helyes, én kérdezi a számítógép, mi a hossza Zamyla ismét, és újra, és újra, és újra? És ez válasz Soha nem fog megváltozni. Mindig lesz 6. 

Tehát jobb megoldás, mint ez a lenne ez a következő verzió. Hadd menjen előre, és betette egy külön nevű fájlt string1.c, csak hogy tartsa elkülönítve. És kiderül, egy a hurok, akkor valójában állapítsa több változó egyszerre. 

Így fogok tartani i és állítsa 0-ra. De én is fog vesszőt, és azt mondják, adj egy változó nevű n, akinek értéke megegyezik a karakterlánc hosszát s. És most, kérjük, hogy az állapotom amíg i kisebb, mint n. 

Tehát ily módon, a logika azonos a végén a nap. De én emlékezve érték 6, ebben az esetben. Mi a hossza Zamyla nevét? És én amivel azt n. 

És én még mindig ellenőrzése a feltétel minden alkalommal. Jelentése 0 kevesebb, mint 6? 1 kisebb, mint 6? 2 kevesebb, mint 6, és így tovább? 

De én nem azt kéri a számítógép újra, és újra, mi hossza Zamyla nevét? Mi a hossza Zamyla nevét? Mi a hossza a Zamyla nevét? Én szó szerint megjegyezni, hogy az első és csak a válasz ebben a második változó n. Tehát ez lenne most nemcsak helyes, hanem a jól megtervezett. 

De mi a helyzet a stílus? Már elemzi én változók elég jól, azt mondanám. Ők szuper tömör most. És ez teljesen rendben van. 

Ha csak egy húr a program, akár meg is nevezni s karakterlánc. Ha csak egy változót számlálására a program, akár meg is nevezni i. Ha van egy hosszú, n szuper közös is. De én nem kommentálta bármely kódomat. 

Már nem tájékoztatta a reader-- hogy ez az én TF, vagy TA, vagy csak colleague-- mit kéne hogy folyik ebben a programban. És így, hogy jó stílusban, mit szeretne csinálni van valami this-- mint kérnie az input. És tudtam átírni ezt számos módon. 

Győződjön meg arról, hogy győződjön meg arról S- get húr vissza a húr. Majd here-- és talán ez a legfontosabb comment-- hajtogat át a karaktereket s egyesével. És jól jönne bármilyen választható angol nyelv ide le minden Ezen darabokat kódot. 

Figyeljük meg, hogy én nem tesz egy megjegyzést minden sor kódot, tényleg csak az érdekes is, az is, hogy Van valami jelentősége, hogy én is szeretnénk, hogy szuper tiszta valakinek olvassa a kódot. És miért hívsz, hogy húr felhasználótól az input? Még hogy az ember nem feltétlenül minden leíró jellegű. De segít elmondani a történetet, mert a második sor a történet, győződjön meg róla, A string vissza a húr. 

És a harmadik sor a történet, végighaladni a karakter s egy egy időben. És már csak a jó intézkedés, Megyek, hogy menjen előre, és adjunk hozzá Még egy megjegyzés, hogy csak mondja print i-edik karaktere s. Most, mit tettem a nap végén? 

Van hozzá egy kis angol szavak formájában megjegyzéseket. A perjel perjel szimbólum azt jelenti, hé, számítógép ez az emberi, nem neked, a számítógép. Tehát ők figyelmen kívül logikusan. Ők csak ott. 

És valóban, CS50 IDE megjeleníti azokat szürke, mint hasznos, de nem kulcsfontosságú a program. Figyeljük meg, mit lehet tenni most. Akár tudod C programozási vagy sem, egyszerűen hátrébb ebben programot, és sovány a megjegyzéseket. Felhasználótól az input, győződjön meg róla, A string visszatért egy string, végighaladni a karaktereket s egyesével, nyomtassa ki a karaktert i-edik karaktere S- te nem még meg kell nézni a kódot megérteni, hogy mi ez a program teszi. És még jobb, ha magad nézni ez a program egy-két héten belül, vagy egy hónap vagy egy év, te is nem bámult a kódot, próbál emlékezni, amit én akar csinálni ezzel a kóddal? 

Te mondtad magadnak. Már le magad, vagy valamilyen kolléga, vagy TA, vagy TF. És így ez most helyes, és a jó design, és végül jó stílusban is. Tehát nem hogy tartsa szem előtt. 

Tehát van egy másik dolog, amit tenni fogok itt hogy most felfedi pontosan mi folyik a motorháztető alatt. Tehát itt van ez a funkció C, és más nyelveken, úgynevezett typecasting hogy akár implicit vagy kifejezetten lehetővé teszi, hogy convert egy adattípust a másikra. Már évek óta foglalkozik, így amennyire ma szálakat. 

És húrok karakter. De emlékszem hétről 0, mik karaktereket? Karakterek csak egy absztrakció tetején numbers-- egész szám, és decimális számok tényleg csak egy absztrakció tetején bináris számokat, ahogy határozta meg. 

Tehát karakterek számát. És a számok karakterek, csak a szövegkörnyezettől függően. És kiderül, hogy belül A számítógépi program, meg tudja határozni, hogy hogyan szeretné nézni A bitek belsejében a program? 

Emlékezzünk hétről 0, hogy mi volt ASCII, ami csak ezt a kódot mapping betűk számok. És mi azt mondtuk, a tőke A 65. Capital B 66, és így tovább. 

És vegyük észre, mi kell főként karakter on A felső sorban van, mint a C nevezné, karaktereket, majd ints a második sorban. És kiderül, hogy lehet konvertálni zökkenőmentesen a kettő között, jellemzően. És ha azt akarjuk, hogy ezt tudatosan, mi Lehet, hogy kezelni valami ilyesmi. 

Talán szeretné konvertálni nagybetű alacsonyabb esetben, illetve alacsonyabb a nagybetűkkel. És kiderül, ott a valójában egy mintát ide tudjuk ölelés csak egy pillanatra. De nézzük először egy példája ezt explicit módon. 

Megyek, hogy menjen vissza a CS50 IDE. Megyek, hogy egy nevű fájlt ASCII 0.c. És én megyek előre, és hozzá a szabvány io.h tetején, int main void a tetején én funkciót. És akkor én csak csinálni a following-- for ciklus az i értéke, mondjuk, 65. 

És akkor én lesz kevesebb 65, plusz 26 betű az ábécé. Úgyhogy hagyja, hogy a számítógép a matek, hogy ott legyek. Aztán belül a hurok, mit fogok nyomtatni? 

% C% i backslash n. És most szeretnék csatlakoztatni a két érték. Már átmenetileg fel kérdését jelek vannak, hogy meghívja a kérdést. 

Azt akarom, hogy ismételget 65-től 26 az ábécé betűit, nyomtat ki minden egyes iteráció hogy karakter szerves egyenértékű. Más szóval, azt akarom, hogy végighaladni 26 szám nyomtatás mi az ASCII karakter, a levél, és mi a megfelelő számot is-- tényleg csak felüdítő A diagram azt a diát. Tehát mit kell ezeket kérdőjelek lenni? 

Nos, kiderült, hogy a második Egy kell csak lenni az i változó. Szeretném látni, hogy a számot. És a középső érv Itt azt lehet mondani, a számítógép kezelésére, hogy egész i, mint egy karaktert, így például helyettesítjük, ide százalékos C. 

Más szavakkal, ha én, a emberi programozó, tudom ezek csak számok a nap végén. És tudom, hogy a 65 kellene Térkép néhány karaktert. Ezzel explicit öntött, a zárójel, a neve a kívánt adattípust, hogy konvertálni, és egy zárt zárójel, meg tudja mondani a számítógép, hé, számítógép, átalakítani ezt az egész, hogy a char. 

Tehát amikor futtatni ezt programot, miután összeállítása, lássuk, mit get-- hogy ASCII 0. Fene egye meg, mit csináltam rosszul van? A be nem azonosító, rendben, nem szándékos, de lássuk, ha nem tudjuk ok ezen keresztül. 

Így a vezetékben five-- így nem kap nagyon messze előtt csavarja fel. Rendben van. Így sor 5 i értéke 65-- látok. Úgy emlékszem, hogy a C, ellentétben néhány nyelvek, ha van korábbi programozási tapasztalat, hogy van közöljük a számítógéppel, ellentétben Scratch, milyen típusú változó van. 

És elfelejtettem kulcsfontosságú kifejezést itt. Összhangban az öt, amit elkezdtem használni az i. De én nem mondtam C milyen adattípus van. Így fogok menni ide, és mondjuk, ah, hogy ez egy egész szám. 

Most megyek, hogy menjen előre és újrafordítani. Ez a fix ezt. ./ascii0 megadása, ez egyfajta hűvös. Nem csak ez szuper gyors kérje a számítógép ezt a kérdést, ahelyett fel a dia, ez kinyomtatható soronként, A 65, B 66, egészen down-- mióta tette ezt 26 times-- a betűk z, , amely 90. És valóban, enyhén intelligensebb lenne már értem, hogy nem hivatkozhat A számítógép hozzá 26. Azt lehetett volna csak tenni 90 is, így hosszú mivel nem teszi ugyanazt a hibát kétszer. Azt akarom, hogy menjen fel a z, nem csak egészen y. 

Tehát ez egy explicit öntött. Kiderült, hogy ez a nem is szükséges. Hadd menjek előre, és futtassa újra ezt a fordítóprogram, és újra ASCII 0. Kiderült, hogy a C elég okos. 

És a printf, különösen, elég okos. Ha csak át egy i kétszer mindkét helyőrzők printf rájönnek, ó, jól tudom, hogy Adott egy integer-- néhány számot, mint 65, vagy 90, vagy bármi más. De látom, hogy azt akarja, hogy formázza azt a számot, mint egy karaktert. És így printf is implicit cast Az int, hogy a char az Ön számára is. Tehát ez nem probléma egyáltalán. 

De észre, mert ez az egyenértékűség mi is valójában ezt is. Hadd menjek előre, és egy Más változat this-- ASCII 1.c. És ahelyett, hogy az iterációt egészek, tényleg szédítően iterációjával át karaktereket. Ha egy char c kap tőke A, I akar menni előre, és ezt, mindaddig, amíg a C-nél kisebb vagy egyenlő, tőke Z. És minden egyes iteráció Szeretnék növelni C, tudok most már az én printf sorban itt mondjuk százalék C százalékkal megint, vessző C. 

És most, mehetek a másik irányba, öntés a karakter kifejezetten hogy egy egész szám. Szóval, megint, miért teszed ezt? Ez egy kicsit furcsa, hogy egyfajta száma tekintetében karaktereket. 

De ha megérted, mi folyik a motorháztető alatt, már tényleg nincs varázslat. Csak azt, hogy, hé, számítógép ad nekem egy változó nevű C típusú char. Inicializálás tőke A. és észre aposztrófot számít. 

Karakterek C, előhívni múlt héten, akkor egyszerű idézőjeleket. Vonósokra, a szavakat, mondatok, akkor használja dupla idézőjelek közé. OK, számítógép, csinálom ezt, így mindaddig, amíg a karakter kevesebb mint vagy egyenlő részt. És tudom, hogy az én ASCII tábla, hogy minden Az ASCII kódok összefüggőek. 

Nincs hiányosságok. Tehát csak A-Z, elválasztva egy szám minden. És akkor én is növelni char, ha igazán akar. A nap végén, ez csak egy szám. Tudom ezt. Így én is csak feltételezik, hogy adjunk 1-et. 

És akkor ez az idő, tudok nyomtatni c, majd a szerves egyenértékű. És nem is kell az explicit öntött. Azt is hagyja printf és a számítógép kitalálni a dolgokat, így ha most futni hogy Ascii1./ascii1, Kapok pontosan ugyanaz a dolog is. 

Haszontalan program though-- senki fog valójában írni szoftver annak érdekében, hogy kitaláljuk, mi volt a szám, amely leképezi az A, vagy B, vagy Z? Te csak majd a Google, vagy keresse ki az interneten, vagy keresse ki a dia, vagy hasonlók. Szóval, ha ez tényleg csak hasznos? 

Nos, beszél, hogy csúszda, észre van tényleges minta itt nagybetű közötti és kisbetű, hogy nem volt véletlen. Figyeljük meg, hogy a tőke egy 65. Kisbetűs egy 97. És milyen messze van kisbetűvel egy? 

Tehát 65 hány lépésre a 97? Tehát 97 -65 32. Tehát a tőke a 65. Ha hozzá 32 e, kapsz egy kisbetűs. És ami ezzel egyenértékű, ha kivonni 32, kapsz vissza tőke egy-- azonos B a kis b, nagy C kis c. 

Mindezek a hiányosságok 32 egymástól. Nos, ez úgy tűnik, hogy lehetővé teszik számunkra, hogy tenni valamit, mint a Microsoft Word, vagy a Google Docs szolgáltatás, ahol kiválaszthatja mindent, majd azt mondják, változtatni az összes kisbetű, vagy változtatni nagybetűs, vagy módosítsa csak az első szó Egy mondat a nagybetűs. Mi valóban tenni valamit mint hogy magunkat. 

Hadd menjen előre, és mentse a fájlt Itt az úgynevezett tőkét 0.c. És menjünk előre, és felkap egy programot hogy pontosan ezt az alábbiak szerint. Így többek között a CS50 könyvtár. És közé tartoznak a standard I / O. 

És tudom, hogy ez hamarosan. Így fogok tenni, hogy a ott már, string.h, így van, hogy dolgok, mint Stirling, majd int fő érvénytelen, a szokásos módon. Aztán megyek előre és nem kap húrok kap húr, csak azért, hogy egy string a felhasználótól. És akkor megyek csinálni a biztonsági ellenőrzést. Ha a string nem egyenlő nulla, akkor ez biztos, hogy folytassa. És mit akarok? Megyek iterálására re az i értéke 0, és n egészen a húr hossza s. 

És én fogom ezt mindaddig, amíg i kisebb mint n, és én plusz plusz. Eddig én tényleg csak hitelfelvétel ötletek előtt. És most megyek, hogy vezessenek be egy ág. 

Tehát úgy gondolja, vissza Scratch, ahol mi volt az említett villa az úton, és a múlt héten a C. fogok mondani, ha az i-edik karaktert s nagyobb vagy egyenlő kisbetűs egy, és-- a Scratch tenné szó hangoztatták, de a C-jel azt mondja, ampersand-- és az i-edik karaktert s kisebb, vagy egyenlő, mint az alacsonyabb esetben Z, csináljunk valami érdekeset. Nézzük ténylegesen ki kell nyomtatni egy karakter nem új sor ez a karakterhez, az i-edik karakterhez. 

De menjünk előre, és vonjuk 32 belőle. Különben, ha a karaktert a karakterlánc, amit keresünk nem közötti kicsiny és a kis z, megy előre és csak kinyomtatta változatlan. Így már bevezetett ez zárójeles jelölés mi húrok, hogy a i-edik karakterhez. 

Adtam néhány feltételes logika, mint a Scratch a múlt heti első héten, ahol Csak az általam alapvető megértheti, hogy mit folyik a motorháztető alatt. Az i-edik karaktere s nagyobb vagy egyenlő, mint egy? Mint, ez 97, illetve 98, vagy 99, és így tovább? 

De ez is kisebb vagy egyenlő az értéke kisbetűs Z? És ha igen, mit jelent ez a vonal jelent? 14, ez a fajta a csírája az egész ötlet, nagybetűvel levelét egyszerűen kivonjuk 32 belőle, ebben az esetben, mert tudom, hogy a per chart, milyen a számok képviselik. Szóval menjünk előre, és futtatni ezt, fordítás után tőkét 0.c, és futás tőkét 0. 

Nézzük írja be valami hasonló Zamyla minden kisbetűvel adja. És most már Zamyla minden nagybetűs. Nézzük írja Rob minden kisbetűvel. Próbáljuk Jason csupa kisbetűvel. És folyton a kénytelen nagybetűk. Van egy kisebb hiba, ami azt fajta nem számítottak. Figyeljük meg az új prompt kiöntött ugyanazon a vonalon, mint a nevüket, ami egy kicsit rendetlen. 

Így fogok menni itt, és valójában a végén ez a program kinyomtatni egy újsor karaktert. Ez minden. A printf, akkor nem kell, hogy át a változókat, illetve formátumban kódot. Akkor szó csak nyomtatni olyasmi, mint egy új sort. 

Szóval menjünk előre, és tőkét ismét 0, futtassa meg, Zamyla. És most ez egy kicsit szebb. Most, a prompt saját új sort. Szóval ez mind szép és jó. Tehát ez egy jó példa. De én nem is feltétlenül kell keményen kódot a 32. Tudod mit? Tudtam say-- én soha nem emlékszem, mi a különbség. 

De azt tudom, hogy ha Van egy kisbetű, Azt lényegében kivonni kívánt off a távolságtól függetlenül között kevés egy, nagy A, mert ha azt feltételezem, hogy az összes többi betű azonos, hogy kell a munkát. De ahelyett, hogy erre, tudod mit? Van egy másik út is. 

Ha ez tőkét 1.c-- ha én tenni, hogy egy külön fájlba. Csináljuk kihasználni 2.c a következő. Megyek igazán tiszta ez itt. És ahelyett, hogy is kelljen tudja, vagy érdekel az alacsony szintű végrehajtásának részleteit, én inkább csak fog nyomtatni egy karaktert, idézet idézőjel bezárva, százalék C, és majd hívja a másik funkciója, hogy van arra, hogy vesz egy érv, amely egy karakter, mint ez. 

Kiderül a C, van Egy másik funkció hívás A felső, amely mint a neve javasolja, vesz egy karakter és teszi, hogy a felső eset egyenértékű, majd visszaadja így printf dugja be oda. És így, hogy ezt is, azt kell bevezetni egy másik fájlt. Kiderült, van egy másik fájl hogy csak tudjuk, osztály, vagy egy tankönyv, vagy egy online hivatkozás, az úgynevezett C type.h. 

Tehát ha én hozzá, hogy többek között az én fejléc fájlokat, és most újra fordítani ezt a programot, capitalize2, ./capitalize2 Enter. Nézzük írja Zamyla minden kisbetűs is ugyanúgy működik. De tudod mit? Kiderül, hogy a felső van néhány egyéb funkciókat. 

És hadd mutassam be ezt a parancs van, egyfajta ügyetlenül elemzi, de az ember a kézi. Kiderült, hogy a legtöbb Linux számítógépen, mint mi használ here-- Linux operációs system-- bírni nevű ember, ami azt mondja, hé, számítógép, adj A számítógép kézikönyvében. mit szeretnél felnéz, hogy a kézi? 

Azt akarom, hogy néz ki a funkciót az úgynevezett felső, Enter. És ez egy kicsit rejtélyes olvasni néha. De észre mi vagyunk a Linux programozó kézikönyvében. És ez az egész szöveget. És észre, hogy ott van a függvény nevét itt. Kiderült, hogy van egy unokatestvére úgynevezett alacsonyabb, ami az ellenkezőjét teszi. És értesítés mellett szinopszis, hogy használja ezt a működni a man oldalon, hogy úgy mondjam, azt mondja, hogy én tartalmazniuk kell c type.h. És tudtam, hogy a gyakorlat során. 

Itt, ez megmutatta a két prototípusok a funkció, így ha valaha szeretné használni ezt a Tudom, hogy mit tegyen a bemenet, és mit visszatérni a kibocsátás. És aztán, ha elolvastam A leírás, látom részletesebben, amit a függvény. De még ennél is fontosabb, ha Nézek alatt visszatérési értéke, azt mondja, a visszaadott érték hogy a konvertált levél, vagy C, az eredeti input, ha az átalakítás nem volt lehetséges. 

Más szóval, a felső megpróbálja átalakítani írni nagybetűs. És ha igen, ez meg fog visszaadni. De ha nem sikerül valami reason-- Talán ez már nagybetű, talán ez egy felkiáltójel vagy valamilyen más punctuation-- ez csak fog vissza az eredeti C, ami azt jelenti, lehet, hogy az én-kód jobban megtervezett az alábbiak szerint. 

Nem kell az összes ezek rohadt sornyi kódot. Összes vonalat I ve Csak kiemelt lehet összecsukható kis csak egy egyszerű vonal, amely a this-- printf százalék c felső S konzol i. És ez lenne egy Például a jobb tervezés. 

Miért végre 7 vagy 8 sor A kód, bármi is volt csak törölve, ha lehet inkább összeomlik minden, hogy a logika és a döntéshozatal egyetlen tétel, 13 most, hogy támaszkodik a könyvtár function-- függvényében, hogy jön a C, de ez pontosan mit szeretne csinálni. És, őszintén szólva, még ha ez nem jött a C, akkor végre magad, mint láttunk, és kap negatív int és kap pozitív int a múlt héten is. 

Ez a kód most is sokkal olvashatóbb. És valóban, ha felfelé, nézd, milyen sokkal kompaktabb ez a verzió az én program. Ez egy kicsit fejnehéz most, mindezeket magában foglalja. De ez rendben van, mert most én állok a vállán programozók előttem. És bárki is volt, aki végrehajtani, hogy a felső igazán tett nekem egy szívességet, ugyanúgy, mint bárki megvalósított Stirling igazán tett nekem egy szívességet néhány évvel ezelőtt. És így most van egy jobb tervezési program amely végrehajtja a pontos ugyanaz a logika. 

Apropó Stirling, hadd menjek előre, és erre a célra. Hadd menjek előre, és mentse ezt a fájlt stirling.c. És kiderül, mi is húzza vissza Egy másik réteg elég egyszerűen most. Megyek, hogy menjen előre és ostor egy másik program fő hogy itt egyszerűen újra munkagépek karakterlánchossz a következő. Tehát itt egy sor kód, amely elkap egy húr a felhasználótól. Tartjuk használja ezt újra és újra. Hadd hozzak magamnak egy változó nevű n int típusú, hogy egy számot tárol. 

És hadd menjen előre, és hajtsa végre a következő logika. Míg az N-edik karaktert s tesz nem egyenlő backslash 0, megy előre megnöveli eggyel n. Majd nyomtassa ki a printf százalék i n. Azt állítják, hogy ez a program itt anélkül húr hossza, kitalálja a karakterlánc hosszát. 

És a varázslat teljesen kapszulázott sor 8 Itt a mi újszerű szintaxis, ez backslash 0 aposztrófok. De miért van ez? Nos, fontolja meg, milyen volt folyik ebben az időben. 

És félre mielőtt elfelejtem, észre is, hogy amellett, hogy a man oldalakat hogy jön egy tipikus Linux rendszer, mint a CS50 IDE, észre, hogy mi, a Természetesen munkatársai, szintén tett egy weboldal verzió Ugyanennek a gondolat az úgynevezett reference.cs50.net, amely hogy ezekben az ember oldalakat, minden, hogy ugyanazon dokumentáció, valamint a egy kis doboz tetején, amely lehetővé teszi hogy konvertálni az összes meglehetősen misztikus nyelvről kevésbé kényelmes mód, ahol mi, a nevelőtestület, mentek keresztül, és megpróbálta, hogy egyszerűsítse egyes nyelvi tartani a dolgokat összpontosított gondolatok, és nem néhány technikai részletekkel. Tehát ne feledje, reference.cs50.net mint egy másik forrás is. 

De miért húr hossza munka ahogy én javasolt egy perce? Itt Zamyla nevét újra. És itt van Zamyla neve dobozos, ahogy csinálom, festeni egy képet róla, hogy, tényleg, csak egy karaktersorozat. De Zamyla nem létezik elszigetelten a programban. 

Amikor írsz, és futtatni egy programot, Ön használja a Mac vagy a PC például a memória, vagy a RAM úgy mondjam. És azt lehet gondolni A számítógép, mint amelyek sok gigabájt memóriával ezekben a napokban. És egy koncert jelenti milliárd, így több milliárd bájt. 

De nézzük a visszatekerés az időben. És tegyük fel, hogy mi használ egy nagyon régi számítógépen csak 32 bájt memóriát. Tudtam, az én számítógép képernyőjén, egyszerűen felhívni a következőképpen. 

Tudtam csak mondani, hogy az én számítógép mindezt memóriát. És ez olyan, mint egy bottal a memória, ha Emlékszik a képet utoljára. És ha én csak osztani ezt elégszer Azt állítják, hogy van 32 bájt memória a képernyőn. 

Most, a valóságban, én csak felhívni eddig ezen a képernyőn van. Így fogok menni előre, és csak a konvenció, felhívni a számítógép memóriájában, mint a rács, nem csak egy egyenes vonal. Konkrétan azt állítják, hogy most ez a rács, ez 8 x 4 rács, csak képviseli az összes 32 byte a rendelkezésre álló memóriának a Mac, vagy elérhető a PC. És ők csomagolópapír A két sorban, csak mert illik jobban a képernyőn. De ez az első bájt. Ez a második byte. Ez a harmadik bájt. 

És ez a 32. byte. Vagy, ha azt gondoljuk, mint egy számítógép tudós, ez bájt 0, 1, 2, 3, 31. Így van, 0-31, ha elkezdi a számlálást 0. 

Tehát, ha egy program használatához hogy a hívások kap húr, és kapunk egy stringet az emberi mint én az úgynevezett Zamyla, Z-A-M-Y-L-A, hogy a világ nem a számítógép, hogy melyik byte, amely darab memória, tartozik, amely húr? Más szóval, ha folytassa írjon be egy másik nevet a számítógéphez, így Andi, amelyben A string másodszor, A-N-D-I, hogy a végén a számítógép memóriája is. De hogyan? 

Nos, kiderült, hogy alatta a motorháztető, mit csinál, amikor C tárolására húrok hogy az emberi típusok in, vagy azt, hogy származik más forrásból, ez Ismerteti a végén őket különleges character-- backslash 0, ami csak egy speciális módon mondván 80 bites egy sorban. 

Tehát egy-- ez a szám 97 visszahívás. Így néhány mintát a 8 bit jelentése decimális szám 97. Ez backslash 0 szó száma 0, más néven nul, N-U-L, ellentétben a korábbi, N-U-L-L, amit beszéltünk. De most, csak tudom, hogy ez a backslash 0 mindössze 80 bit egy sorban. 

És ez csak ebben a sorban a homok, hogy nem mond semmit, hogy a bal oldali tartozik egy húr, vagy egy adattípust. És bármi jobbra tartozik valami mást. Andi nevét, eközben amelyek csak vizuálisan előfordul, hogy lezárja be a másik vonalon, de ez csak esztétikai részlet, Hasonlóan van nul megszűnik. 

Ez egy sor egy A-N-D-I karakterek, és egy ötödik titkos karakter, minden 0 bit, hogy csak behatároló vége Andi nevét is. És ha hívjuk kap húr harmadik alkalommal a számítógép kap egy string, mint Maria, M-A-R-I-A, hasonlóan a Maria név nul végződő backslash 0. 

Ez alapvetően eltérő attól, ahogy a számítógép jellemzően tárolni egy egész, vagy egy úszó vagy egyéb adattípusok is, mert emlékszem, egy egész általában 32 bit, vagy 4 byte, vagy akár 64 bit, vagy nyolc byte. De sok primitívek egy számítógépes egy programozási nyelv Van egy meghatározott számú byte alatt hood-- talán 1, talán 2, talán 4, talán 8. 

De húrok, a design, van egy dinamikus karakterek száma. Nem tudja előre, amíg az emberi típusok in Z-A-M-Y-L-A, vagy M-A-R-I-A, vagy A-N-D-I. Nem tudod, hányszor a felhasználó fog ütni a billentyűzet. Ezért nem tudom, hogyan sok karaktert előre te lesz szüksége. 

És így a C csak egyfajta hagy, mint egy titkos morzsa a motorháztető alatt a végén a húr. Tárolása után Z-A-M-Y-L-A memóriában ez is csak hozza az egyenértékű időszak. Végén egy mondat, ez hozza a 80 bit, így visszaemlékezni, hol Zamyla kezdődik és végződik. 

Tehát mi a kapcsolat, majd, hogy ez a program? Ez a program itt, Stirling, egyszerűen egy mechanizmus kapok egy húr a felhasználó, 6. sor. 7. sor, azt, hogy egy változót úgynevezett n és állítsa 0-val egyenlő. 

És akkor a 8. sorban, egyszerűen kérték, a kérdés, míg az N-edik karakter nem nem egyenlő az összes 0 bits-- Más szavakkal, nem egyenlő ez a különleges karakter, backslash 0, ami éppen, hogy különleges nul character-- megy előre, és csak növelni n. 

És folyamatosan csinálja, és tartsa csinálja, és csinálom azt. És még akkor is a A múltban már használt i, ez tökéletesen szemantikailag használni n, ha csak próbál gróf ezúttal szándékosan, és csak akar nevezni n. Tehát ez csak folyamatosan kérdezi a kérdést, az N-edik karaktere s minden 0s? Ha nem, akkor nézd a következő megjelenés, meg, hogy a következő, meg a következő, meg, hogy a következő. 

De amint látod backslash 0, ez loop-- sor 9-től 11-- leáll. Akkor kitör a while ciklus, így aztán az n változó teljes száma az összes érintett sztring karaktereinek láttál, ezáltal a nyomtatást ki. Tehát próbáljuk meg. 

Hadd menjek előre, és anélkül, a Stirling funkció, de csak a saját házi verzió Itt az úgynevezett Stirling, hadd menjen előre és fuss Stirling, írja be valamit mint Zamyla, ami tudom, hogy előre hat karakter. Nézzük meg, hogy működik. Valóban, ez hat. Próbáljuk Rob, a három karakter, három karakter is, és így tovább. Annak érdekében, hogy minden, ami megy az alatt a motorháztető. És észre a kapcsolatot, Aztán, az első héten osztály, ahol beszélgettünk olyasmi, mint absztrakció, ami csak ezt a réteg a gondolatok, vagy komplexitás, a tetején alapelvek. Itt vagyunk a fajta keres a motorháztető alatt a Stirling, hogy úgy mondjam, hogy kitaláljuk, hogyan lenne megvalósítható? 

És nem tudtuk újra végrehajtani magunk. De mi soha többé megy hogy újra végrehajtani Stirling. Mi csak most fog használja Stirling érdekében hogy valóban kap néhány szálat hosszát. 

De nincs mágikus a motorháztető alatt. Ha tudja, hogy alatta A motorháztető, a húr csak egy karaktersorozat. És ez a karaktersorozat minden lehet számszerűen foglalkozni tartóval 0, konzol 1, 2 merevítő, és tudom, hogy a végén egy string egy speciális karakter, akkor kitaláljuk, hogyan kell csinálni a legtöbb semmit egy programot, mert minden csapódik le, hogy olvas és ír memóriát. Azaz, a változó és keres A memória, vagy a mozgó dolgokat körül a memóriában, nyomdai dolgok a képernyőn, és így tovább. 

Szóval, most már ezzel az újonnan megértésének húrok ténylegesen vannak a motorháztető alatt, és húzza vissza egy másik réteggel hogy mostanáig voltunk már nem vette figyelembe. Különösen bármikor már végre egy programot, ezt már a kódsort felső nyilvánító fő. És mi meg int main semmis. 

És hogy semmis a zárójelek van is mondtam ebben az időben fő önmagában nem hoz érveket. Bármely ráfordítás hogy fő az fog kapni a felhasználó kell származnia más mechanizmus, mint például get int, vagy kap float, vagy kap húr, vagy más funkció. De kiderül, hogy ha írsz egy programot, akkor valóban meghatározza hogy ez a program kell vegye bemenetek az emberi a parancssorban is. 

Más szóval, még akkor is, eddig már fut csak ./hello szia vagy hasonló programokkal, az összes Más programok, amin felhasználásával, hogy mi magunk nem írni, megtették, úgy tűnik, parancssor arguments-- dolgok, mint a make. Azt mondják, valami hasonló gyártmányú, majd egy másik szót. Vagy csengés, azt mondják csenget, majd A második szó, a fájl neve. 

Vagy még RM vagy CP, ahogy az látott vagy felhasznált már eltávolításához vagy fájlokat másolni. Az összes ilyen vesz úgynevezett parancssor arguments-- további szavakat a parancsot. De egészen mostanáig, mi magunk nem volt ez a luxus figyelembe bemenet az felhasználó, ha ő valóban fut A program maga a parancssorban. 

De nem tehetünk, hogy az újbóli nyilvánításáról Fő halad előre, nem rendelkező semmissé zárójelben, de ez a két érv instead-- az első egész szám, és a második valami új, amit mi fogunk hívni tömb, valami hasonló szellemben hogy mit láttunk Scratch listaként, hanem egy tömböt, ahogy hamarosan látni. De nézzük ezt Példaképpen, mielőtt megkülönböztetni, hogy pontosan mit is jelent. 

Tehát ha bemegyek CS50 IDE Itt Bátorkodtam és kijelentette nevű fájlt argv0.c a következő sablont. És vegyük észre az egyetlen dolog, ez más eddig az, hogy én változtam void int argc húr az argv nyitva tartó, szoros zárójel. És észre most, van benne semmi ilyen zárójelben. 

Nincs több. És nincs i, vagy N, vagy bármely más, levelet. Én csak a szögletes zárójelben most, okokból jövünk vissza csak egy pillanatra. 

És most mit fogok csinálni ez. Ha argc egyenlő egyenlő 2-- és emlékszem, hogy egyenlő az egyenlők az operátorral összehasonlításával A bal és jobb egyenlőségre. Ez nem a feladat operátor, amely Az egységes egyenlőségjel, ami azt jelenti, másolás jobbról balra valamilyen értéket. 

Ha argc értéke = 2, szeretnék mondjuk, printf, hello, százalék, az új vonal, majd csatlakoztassa in-- és itt az új trick-- argv konzol 1 okok miatt hogy mi jön vissza egy pillanatra. Más, ha nem argc egyenlő 2, tudod mit? Nézzük csak megy előre, és mint mindig, a nyomtatási ki hello world nélkül cserélni. 

Nagyon úgy tűnik, hogy ha argc, ami jelentése érv száma, értéke 2, Megyek kinyomtatni szia vagy valami más. Ellenkező esetben, alapértelmezés vagyok nyomdába kerülés hello world. Tehát mit jelent ez? 

Nos, hadd menjen előre, és mentse ezt a fájlt, majd megcsináljuk argv0, majd ./argv0, Enter. És azt mondja, hello world. Nos, miért van ez? 

Nos, kiderült, hogy bármikor futtatni egy programot a parancssorban, kitöltésekor mit fogunk általában hívni egy érv vektor. Más szóval, automatikusan a számítógépet, az operációs rendszer, fog átadni a programot Maga egy listát az összes szót hogy az emberi begépelt A prompt az esetre, ha A programozó akarok valamit az információt. És ebben az esetben, az egyetlen szó Azt írtad a prompt ./argv0. 

És így a több érv, hogy az átadottként én program csak egy. Más szavakkal, az érv számítanak, más néven argc itt egy egész, csak egy. Az egyik természetesen nem egyenlő kettő. És így ez az, amit nyomtat, hello world. 

De engedjék meg, hogy ezt valahol. Hadd mondjam, argv0. És akkor mi a helyzet Maria? Majd nyomja meg az Entert. 

És vegyük észre, mi történik varázslatosan itt. Most ahelyett, hello world, van megváltoztatta a viselkedését a program azáltal, hogy a bemenet nem származó get húr, vagy más funkciót, de úgy tűnik, az én parancs maga, amit eredetileg beírt. És én is játszani ezt a játékot újra megváltoztatják, hogy Stelios, például. 

És most látom a másik nevet is. És itt, azt mondhatnánk Andi. És azt mondhatnánk Zamyla. És mi lehet játszani ezt a játékot, egész nap, csak csatlakoztatni a különböző értékek, amíg én hogy pontosan két szó a gyors, oly módon, hogy argc, érvem számítanak, 2. 

Látok, hogy név dugva printf, per ez a feltétel itt? Tehát úgy tűnik, hogy most A kifejező képesség figyelembe bemenet egy másik mechanizmus, Az úgynevezett parancssor, ahelyett, hogy várjon amíg a felhasználó futtatja a programot, , majd kéri őt felhasználásával valami hasonló get húr. 

Szóval mi ez? ARGC megint csak egész szám, száma words-- arguments-- hogy a felhasználó rendelkezésre a prompt, a terminál ablak, beleértve a program nevét. Tehát mi ./argv0 van, hatékonyan, a program nevét, vagy hogyan fut a program. 

Számít, mint egy szó. Tehát argc lenne 1. De amikor írok Stelios, vagy Andi, vagy Zamyla, vagy Maria, azt jelenti, hogy az érvelés száma kettő. És így most van két szó telt el. 

És vegyük észre, mi továbbra is ezt a logikát. Ha valóban azt mondják, valami hasonló Zamyla Chan, teljes név, ezzel átadva három érv összesen most azt mondja, az alapértelmezett ismét mert, természetesen, 3 nem egyenlő 2. 

És így ezen a módon, nem tudom hozzáférés argv ezt az új érvet hogy mi lehet technikailag hívja, amit csak akarunk. De a hagyomány, ez argv és argc, ill. Argv, érvelés vektor, kedves A szinonimája a programozási jellemző C nevű tömböt. 

Egy tömb listát a hasonló értékeket vissza, vissza, vissza, hogy vissza. Más szóval, ha valaki itt a RAM, a következő egy közvetlenül mellette, és közvetlenül mellette. Ők nem az egész hely. És ez utóbbi forgatókönyv, ahol a dolgok van az egész hely a memóriában, is lehet egy erőteljes funkció. De mi jön vissza, hogy amikor beszélni szakértő adatszerkezeteket. Most, egy tömb csak egy darab összefüggő memória, mindegyik, amelynek elemei vissza, vissza, vissza, vissza, és általában ugyanolyan típusú. 

Tehát, ha belegondolsz, egy perce, mi az a húr? Nos, egy string, mint Zamyla, Z-A-M-Y-L-A, nem, technikailag, Csak egy tömbben. Ez egy sor karakter. 

És így, ha igazán felhívni ezt, ahogy én tette korábban, mint egy darab memória, kiderül, hogy minden egyes ilyen karakterek vesz fel egy byte. És akkor ott van, hogy a különleges sentinel karakter, a backslash 0, vagy mind a nyolc 0 bit, hogy kijelölte a végén, hogy a húr. Tehát egy húr, kiderül ki, idézzük idézet vége húr, csak egy sor chara-- char hogy egy tényleges adatok típusát. 

És most argv, meanwhile-- menjünk vissza a program. Argv, bár látjuk a szót húr itt, nem karakterlánc is. Argv, érvelés vektor, egy tömböt. 

Ahogyan tehát akkor van egy sor karakterekből magasabb szintű, egy sor strings-- Így például, mikor beírtam egy perce ./argv0 argv0, tér Z-A-M-Y-L-A, azt állítottam, hogy argv két húrok it-- ./argv0, és Z-A-M-Y-L-A. Ban ben Más szavakkal, ARGC volt 2. Miert van az? 

Nos, hatékonyan, mi folyik A az, hogy minden ilyen húrok Természetesen, egy sor karakterek mint korábban, minden egyes akiknek karakterek vesz fel egy bájt. És ne keverjük össze a tényleges 0 a program nevét a 0, ami azt jelenti, mind a 80 bit. És Zamyla, eközben továbbra is továbbá egy sor karakter. 

Így a végén a nap, ez tényleg úgy néz ki, mint ez a motorháztető alatt. De az argv, a természet, hogyan fő munkák, lehetővé teszi számomra, hogy lezárja mindezt fel, ha úgy tetszik, egy nagyobb tömb hogy ha valamivel több egyszerűsítése mi a kép néz ki, és nem elég felhívni, hogy a skála ott, ez a tömb csak a 2-es méret, az első eleme, amely tartalmaz egy string, A második elem amely tartalmaz egy húr. És viszont, ha fajta nagyítás minden e húrok, amit lásd a motorháztető alatt hogy minden húr csak egy sor karakter. 

Most, csakúgy, mint a húrok, tudtuk, hogy hozzáférjen az i-edik karakter egy húr használ, hogy a szögletes zárójel jelöléssel. Hasonlóképpen, tömbök általában is mi szögletes zárójel jelölést kap bármely számú húrok a tömb? Például, hadd megy előre, és erre a célra. 

Hadd menjen előre, és hozzon létre argv1.c, ami egy kicsit más ebben az időben. Ahelyett, hogy ellenőrzése argc2, Megyek inkább erre. Mert int kapok 0, I kevesebb mint argc, én plus plus, majd nyomtassa ki belseje, százalék s, új sort, majd argv konzol i. 

Más szóval, én nem foglalkozik egyes karakterek az adott pillanatban. Argv szerint közvetlenül az ilyen üres tér melles jobbra a név argv, azt jelenti, argv egy tömböt. És argc csak egy int. 

Ez a sor itt, a 6., a mondván set i értéke 0. Gróf egészen az, de nem tartalmazza argc. És akkor minden iterációban nyomtassa ki a húr. Mi húr? 

Az i-edik string argv. Tehát míg korábban voltam a szögletes zárójel jelölés, hogy a i-edik karakter egy húr, most Én használ a szögletes zárójel jelölés hogy a i-edik sztringet egy tömbbe. Tehát ez a fajta egy rétegben felett, fogalmilag. 

És mi ügyes erről programból, ha fordítsam argv1, majd tegye ./argv1, majd írja olyasmi, mint foo bar BAZ, amelyek a három alapértelmezett szó, hogy a számítógép tudós nyúl bármikor ő kell egy kis helykitöltő szó, és nyomja meg az Enter, egyes szavakat, beleértve a program nevét, amely van argv az első helyen, végül is a nyomtatott egyesével. És ha ezen változtatni, és azt mondom, olyasmi, mint argv1 Zamyla Chan, megkapjuk az itt felsorolt ​​három szóval, ami argv0, argv1, argv2, mert ebben az esetben argc, a gróf, 3. 

De mi a szép az, ha érti hogy argv csak egy tömböt, és megérted, hogy egy húr egy tömb karakterekből mi is valójában milyen használatához szögletes zárójel jelölés többször hogy válasszon egy húr, majd válassza a képességgel a húr, búvárkodás mélyebb a következő. Ebben a példában, hadd menjen előre, és hívja ezt argv2.c. És ebben a példában, hadd menjen előre és nem a following-- az int i kap 0, i-nél kisebb argc, i plus plusz, mint azelőtt. Tehát más words-- és most ez a egyre bonyolultabb elég. Akkor fogok mondani végighaladni húrok argv, mint egy megjegyzést, hogy magam. Aztán megyek egy beágyazott hurok, amit valószínűleg volna, vagy figyelembe venni csinál, a Scratch, ahol Azt fogom mondani int-- vagyok nem fogja használni megint, mert nem akarom, hogy az árnyék, vagy fajta felülírja a meglévő i. 

Megyek, hanem, mondjuk j, mert ez az én megy a változó után én, amikor én csak próbál számolni egyszerű számokat. J kap 0-- és n, fog kap a far hossza argv tartó i, mindaddig, amíg j értéke kisebb, mint m, j plus plus, tegye a következőket. És itt jön az érdekes rész. 

Nyomtassa ki egy karaktert és egy új vonal, dugulás argv konzol i, j konzol. OK, hadd adjunk néhány megjegyzést itt. Végighaladni karakterek a jelenlegi szöveg, print j-edik karaktere i-edik sor. Tehát most, nézzük meg amit ezek a megjegyzések jelent. 

Végighaladni a húrok a argv-- hány húrok vannak argv, amellyel egy tömb? ARGC sok, úgyhogy iterációjával az i egyenlő 0-ig argc. Közben, hogy hány karakter vannak az i-edik string argv? 

Nos, hogy ezt a választ, Én csak hívja string-hossz A jelenlegi szöveg azt ellátás kb, ami argv konzol i. És megyek, hogy ideiglenesen tárolja, hogy értéke n, csak caching célokra, emlékszik rá a hatékonyságot. És akkor fogok inicializálása j 0, folyamatosan megy, amíg j n-nél kisebb, és minden egyes iteráció növekmény j. 

És akkor itt egy én comment on line 12 nyomtassa ki a karaktert, majd egy új vonal, kifejezetten argv konzol i ad nekem az i-edik sor a argv-- így az első szót, a második szó, a harmadik szó, bármi. És akkor j merülés mélyebb, és megkapja nekem a j-edik karaktere ezt a szót. És így, a hatás, akkor lehet kezelni argv egy többdimenziós, mint egy kétdimenziós, tömb, amelyben minden szó egyfajta néz mint ez a lelki szem, és minden karakter A fajta komponált egy oszlopot, ha ez segít. 

A valóságban, amikor ugratni ezt leszámítva a jövőben hét, ez lesz egy kicsit kifinomultabb ennél. De akkor tényleg gondolni, hogy most, mivel csak ez a két dimenziós tömb, ahol egy szintet is minden a húrok. És akkor, ha merülés mélyebbre, akkor lehet kapni az egyes karakterek mellékhatásuk ezzel a jelöléssel van. 

Tehát mi a nettó hatása? Hadd menjek előre, és hogy argv2-- fene egye meg. Hibáztam itt. Hallgatólagosan nyilvánító könyvtári függvény Stirling. Tehát ebben az időben, ez talán helyénvaló hogy mi fajta befejező Pontosan, ahol elkezdtük. 

Elcsesztem, hallgatólagosan nyilvánításáról könyvtári függvény Stirling. OK, várj egy percet. Emlékszem, hogy különösen hiszen itt van. Azt kell, hogy tartalmazza a string.h ez a változat a program. 

Hadd menjek előre, és tartalmaznia string.h, kivéve, hogy menjen előre és újrafordítani argv2. És most itt tartunk, hogy argv2, Enter. És bár ez egy kicsit rejtélyes első pillantásra, észre, hogy az, ami ténylegesen kinyomtatja a dot argv2. 

De ha be is szó után prompt, mint argv2 Zamyla Chan, Enter, még egy kicsit rejtélyes első pillantásra. De ha görgetni vissza, ./argv2 Z-A-M-Y-L-A C-H-A-N. Így már végigjárt át minden szót. És viszont, most már több mint iterált minden karakter egy szón belül. 

Most, miután mindezt, észre, hogy ott van Egy másik részlet voltunk fajta figyelmen kívül hagyja ezt az egész idő alatt. Mi csak ugratta egymástól milyen fő bemenetei lehetnek? Mi a helyzet a fő kimeneti? 

Mindez idő, voltunk csak a másolás és beillesztés a szó int előtt fő, bár lehet látni az interneten, néha helytelenül a régebbi C és fordítóprogramok, hogy azt mondják érvénytelen, vagy semmit. De valóban, a version C, hogy mi használ, C 11, vagy 2011, észre hogy meg kell Int. És meg kell vagy lehet érvénytelennek vagy argc és az argv itt. 

De miért int main? Mi ez valójában visszatér? Nos, kiderült, hogy mindezt az időben, minden alkalommal, amikor írtam egy programot fő mindig visszatér valamit. De ez már ezzel titokban. 

Ez a valami egy int, mivel az 5. sorban sugallja. De mi int? Nos, itt van ez a egyezmény programozás, ahol, ha semmi sem rosszul sikerül, és minden rendben van, programok és funkciók általában return-- kissé counterintuitively-- 0. 0 általában azt jelenti, minden rendben van. Így, bár úgy gondolja, azt a hamis számos helyzetben, valójában általában azt jelenti, jó dolog 

Közben, ha egy program visszatér 1, vagy negatív 1, vagy 5, vagy negatív a 42., vagy bármely, nem-0 értékű, amely általában jelenti hogy valami nincs rendben. Tény, hogy a saját Mac vagy PC, lehet, hogy valóban láttam egy hibaüzenet, amely révén mond valamit, vagy más, a hiba kód negatív 42, vagy hibakódot 23, vagy valami ilyesmi. Ez a szám általában csak egy csipetnyi a programozó, vagy a vállalat tette a szoftver, mit rontottam, és miért, hogy így átnéz a dokumentációban vagy kódja, és kitalálni, mi a hiba valójában jelent. Ez általában nem hasznosak számunkra a végfelhasználók számára. 

De amikor a fő visszatér 0, minden rendben van. És ha nem adja meg mi fő, vissza kell adnia, akkor csak automatikusan return 0 az Ön számára. De visszatérve valami mást valóban hasznos. 

Ebben az utolsó programot, hadd megy előre, és hívja ezt exit.c, és vezessen be az utolsó a mai témák, más néven a hibakódot. Hadd menjek előre, és tartalmazza a ismerős fájlokat akár felső, nem int main. És ezúttal, csináljuk int argc, húr argv, és én konzolok arra utal, hogy ez a tömbben. És akkor hadd tegye a biztonsági ellenőrzést. Ez az idő, ha argc nem egyenlő 2, akkor tudod mit? Felejtsd el. Fogok mondani, hogy, hé, a felhasználó, ha hiányzik parancssori argumentum backslash n. 

És akkor ez az. Ki szeretnék lépni. Fogok preemptively, és idő előtt tényleg, visszatérés valami más, mint az 1-es. A go, hogy érték az első hiba, ami megtörténhet, 1. Ha van egy másik hibás helyzet, hogy előfordulhat, mondhatnánk vissza 2 vagy vissza 3, vagy talán még negatív 1. vagy negatív 2. 

Ezek csak kilépési kódok amelyek általában Csak akkor hasznos, a programozó, vagy a cég, ami hajózás a szoftvert. De az a tény, hogy ez az nem 0, ami fontos. Tehát ha ez a program, szeretnék Garantáljuk, hogy ez a program csak akkor működik, ha a felhasználó megadja nekem egy érv száma kettő, a program nevét, és néhány egyéb szó, tudom érvényesíteni, mint az alábbiak, kiabálni a felhasználó printf mondás, hiányzik parancssori argumentum return 1. Hogy majd csak közvetlenül kilép a programból. 

Csak akkor, ha argc = 2 jutunk le Itt, ezen a ponton fogom mondani, szia százalék s, backslash n, argv1. Más szavakkal, én Nem fog után argv 0, ami csak a program nevét. Szeretnék kinyomtatni hello, vessző, A második szó, hogy az emberi gépelt. És ebben az esetben a 13. sor, minden rendben van. 

Tudom, hogy ARGC 2 logikusan ebből a programból. Megyek, hogy menjen előre és vissza 0-ra. Mellesleg, tartsd észben, hogy ez igaz a karcolással is. 

Logikusan tudnám ezt és ezt párosítani ezeket a sorokat A kód ezen else itt. De ez a fajta szükségtelenül beljebb kódomat. És azt akarom, hogy szuper Egyértelmű, hogy nem számít, mit, alapértelmezés szerint, helló valamit kap nyomtatott, mindaddig, amíg a felhasználó együttműködik. 

Tehát ez nagyon gyakori használata feltétel, csak egy, ha elkapni néhány hibás helyzetet, majd kilép. Aztán, amíg minden rendben van Nos, nincs más, de csak azt a kódot kívül, hogy ha, mert egyenértékű az e konkrét esetben logikailag. Úgyhogy visszatérő 0, csak azért, hogy kifejezetten jelezve, minden rendben van. 

Ha elhagyjuk a return 0, akkor lenne automatikusan feltételezni nekem. De most, hogy én visszatér egy legalább ebben az esetben, Megyek, jó intézkedés és egyértelműség return 0 ebben az esetben. Tehát most hadd menjen előre, és a kijárat, amely tökéletes váltása, hogy csak hagyja. 

De hogy exit, és hadd menjen előre, és nem ./exit, Enter. És a program kiabált velem, hiányzik parancssori argumentum. OK, hadd működjenek. 

Hadd helyett csinálni ./exit, David, Enter. És most azt mondja, helló David. És akkor általában nem látja ezt. 

De kiderül, hogy van egy különleges módon Linux, hogy ténylegesen milyen kilépési kód program kilép. Néha egy grafikus világban, mint a Mac OS vagy Windows, csak látni ezeket a számokat, amikor egy hibaüzenet jelenik meg a képernyőn és a programozó azt mutatja, hogy a számot. De ha azt akarjuk, hogy mi a hiba üzenet, meg tudjuk csinálni here-- így ./exit, Enter, nyomtatás hiányzik parancssori argumentum. 

Ha én most nem echo $ ?, amely nevetségesen rejtélyes keres. De $? a mágikus ráolvasás amely azt mondja, hé, számítógép, mondja meg, mi az előző program kilépési kódja. És megütöttem az Enter billentyűt. Látom 1, mert ez az, amit én azt mondta a fő funkciója, hogy visszatérjen. 

Közben, ha én ./exit David, és nyomja meg az Enter, látom, helló David. És ha most nem echo $ ?, látom szia 0. És így ez ténylegesen értékes információkat keretében a debugger, nem annyira sokat, hogy te, az ember, akkor érdekel. De a hibakereső és más programok fogjuk használni ebben a félévben gyakran megnézi azt a számot, bár ez a fajta rejtett el ha nem néz rá, hogy határozza meg, hogy egy program végrehajtás volt helyes vagy helytelen. 

És így, hogy elvezet minket ezt, a végén a nap. Elkezdtük ma nézi hibakeresés, és viszont, a pálya is, és akkor több Érdekes, technikailag a motorháztető alatt hogy milyen húrok, amely a múlt héten csak biztosra vett, és minden bizonnyal elvitte őket értetődőnek Scratch. 

Ezután megnéztük, hogyan tudjuk elérni egyes karakterre, majd ismét vett egy magasabb szintű nézni a dolgokat, és megnézzük, hogyan well-- Ha azt akarjuk, hogy az egyes a lista elemeit, mint a szerkezet, nem tudunk csinálni, hogy több húrok? És tudjuk a parancssori paramétereket. De ez a kép itt csak dobozok hogy demonstrálják ezt a közvélekedést Egy tömb, vagy egy lista, vagy egy vektort. És attól függően, hogy összefüggésben minden ezeket a szavakat némileg különböző dolgokat. Tehát C, mi csak megy beszélni egy tömbben. És egy sor egy bonyolult memória, akik mindegyike az elemek összefüggőek, vissza, vissza, vissza, hogy vissza. 

És ezek az elemek, általában az azonos típusú adatok, jellege, karakter, karakter, karakter, vagy húr, húr, húr, húr, vagy int, int, int, bármi legyen is az próbálunk tárolni. De a végén a nap, ez hogyan néz ki fogalmilag. Te szedését számítógép memóriájában vagy RAM. És te faragott ki a azonos méretű dobozok, amelyek mindegyike vissza, vissza, hogy vissza, hogy vissza ezen a módon. 

És mi szép a ezt az elképzelést, és az a tény, hogy tudjuk kifejezni értékek ebben módon az első a mi adatstruktúrák az osztályban, azt jelenti, kezdhetjük megoldani a problémákat a kódot hogy jött így ösztönösen héten 0. Majd visszahívja a telefont könyv például, ha mi használt oszd meg és uralkodj, vagy egy bináris keresési algoritmust, szitál keresztül egy egész csomó nevek és számok. De azt feltételeztük, visszahívás, hogy ez a telefonkönyvét már rendezve, hogy valaki más már Figurális out-- adott névjegyzékének és numbers-- hogyan átrendezhetne őket. És most, hogy a C-mi, is, képesek feküdt a dolgokat, nem fizikailag a telefonkönyvben de gyakorlatilag a számítógép memória, képesek leszünk a jövő héten bevezetni újra this-- az első mi adatstruktúrák egy array-- de ami még fontosabb, a tényleges számítógép tudomány algoritmusok a kód, amivel lehet tárolni adatok struktúrák, mint ez, majd elkezd manipulálni, és hogy valóban megoldani a problémákat vele, és építeni a tetején, hogy, végül, programok C, Python, JavaScript, lekérdezésével adatbázisok SQL? 

És látni fogjuk, hogy az összes ilyen különböző ötleteket retesz. De most, felidézni, hogy az tartományban, hogy mi vezetett a mai volt ez a dolog itt, és A világ titkosítani. És azok között a következő problémák te magad megoldja a művészet kriptográfia, keverésnél és de-kódolási információkat, és rejtjelezés és megfejteni a szöveget, és feltételezve, hogy végül hogy most már tudja, mit van a motorháztető alatt így ha látni vagy fogadni egy ilyen üzenetet, akkor magad is megfejteni. Mindez, és még a következő alkalommal. 

[VIDEO LEJÁTSZÁS] 

-Mover Most érkezett. Megyek meglátogatom főiskolai tanár. Igen. Szia. Te vagy. Várjon! David. Csak próbálom kitalálni hogy mi történt veled. Kérjük, bármi segíthet. Te voltál az egyetemen szobatársam, ugye? Te is ott voltál vele, amikor már befejezte a CS50 projekt? 

[ZENE] 

-Ez Volt CS50. 

Imádom ezt a helyet. 

-Edd meg. Megyünk ki az üzletből. 

[END LEJÁTSZÁS] 