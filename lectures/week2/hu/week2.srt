1
00:00:00,000 --> 00:00:02,970
>> [ZENE]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> David J. MALAN: Rendben.

4
00:00:15,700 --> 00:00:18,832
Ez CS50 és ez
a 2. hét elején.

5
00:00:18,832 --> 00:00:21,040
És emlékezzünk csak vissza, hogy több mint
Az elmúlt pár hét,

6
00:00:21,040 --> 00:00:24,490
vezettünk be a számítógép
tudomány és viszont, programozás.

7
00:00:24,490 --> 00:00:27,640
>> És elkezdtük a történetet útján
Scratch, hogy grafikus nyelv

8
00:00:27,640 --> 00:00:28,990
a MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
Aztán legutóbb,
A múlt héten, ahogy mi

10
00:00:30,780 --> 00:00:34,450
bevezetni higher-- egy
alacsonyabb szintű nyelvi ismert

11
00:00:34,450 --> 00:00:36,770
a C, valamit, ami tisztán szöveges.

12
00:00:36,770 --> 00:00:39,440
És valóban, utoljára
feltárni ebben az összefüggésben

13
00:00:39,440 --> 00:00:40,450
számos fogalmat.

14
00:00:40,450 --> 00:00:43,010
>> Ez, visszahívás, volt az
első program néztük.

15
00:00:43,010 --> 00:00:45,710
És ez a program, egyszerűen,
kiírja, "hello, világ".

16
00:00:45,710 --> 00:00:47,730
De olyan sok
mintha varázslat folyik.

17
00:00:47,730 --> 00:00:51,460
Van ez a #include
ezekkel hegyes zárójelek.

18
00:00:51,460 --> 00:00:52,170
Van int.

19
00:00:52,170 --> 00:00:53,020
Van (void).

20
00:00:53,020 --> 00:00:56,330
Van zárójelben, kapcsos zárójelek
félig kettőspont, és így sokkal több.

21
00:00:56,330 --> 00:00:58,480
>> És így, emlékeztetni arra, hogy
bevezettük Scratch

22
00:00:58,480 --> 00:01:02,110
így tudtuk, ideális, lásd múlt
hogy szintaxis, a dolgokat, hogy tényleg nem

23
00:01:02,110 --> 00:01:04,590
minden szellemileg
érdekes, de korán

24
00:01:04,590 --> 00:01:07,700
van, teljesen, egy kicsit trükkös
hogy lezárja az elméd köré.

25
00:01:07,700 --> 00:01:10,860
És valóban, az egyik leggyakoribb
dolgok elején egy programozási osztály,

26
00:01:10,860 --> 00:01:13,443
különösen azok számára, kevésbé
kényelmes, az, hogy csalódott

27
00:01:13,443 --> 00:01:17,460
és gáncsot bizonyos szintaktikai
hibák, nem is beszélve a logikai hibák.

28
00:01:17,460 --> 00:01:19,800
És így Céljaink között
ma, valójában, majd

29
00:01:19,800 --> 00:01:23,280
lehet, hogy felvértezzük Önt néhány
problémamegoldó technikák, hogy hogyan

30
00:01:23,280 --> 00:01:26,705
hogy jobban megoldani a problémákat maguknak
formájában hibakeresés.

31
00:01:26,705 --> 00:01:29,330
És akkor felidézni azt is, hogy a
környezet, hogy mi vezetett

32
00:01:29,330 --> 00:01:31,780
utoljára hívták CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Ez a web-alapú szoftver, amely
programozhatja a felhő,

34
00:01:34,850 --> 00:01:38,450
hogy úgy mondjam, miközben az összes
fájlokat együtt, ahogy ismét a mai napon.

35
00:01:38,450 --> 00:01:41,480
És emlékszem, hogy mi
felülvizsgálata ezeket a témákat itt,

36
00:01:41,480 --> 00:01:44,480
köztük a funkciót, hurkok,
változók és logikai kifejezések,

37
00:01:44,480 --> 00:01:45,110
és feltételeket.

38
00:01:45,110 --> 00:01:49,190
És valójában még néhány, hogy mi
lefordítva a világ a semmiből

39
00:01:49,190 --> 00:01:50,800
a világ C.

40
00:01:50,800 --> 00:01:53,220
>> De az alapvető épület
blokkok, hogy úgy mondjam,

41
00:01:53,220 --> 00:01:55,150
valóban még mindig ugyanaz a múlt héten.

42
00:01:55,150 --> 00:01:57,900
Sőt, igazán csak volt egy
különböző puzzle-darab, ha úgy tetszik.

43
00:01:57,900 --> 00:02:00,300
Ahelyett, hogy a lila
menteni blokk, akkor helyette

44
00:02:00,300 --> 00:02:02,940
volna printf, ami
Ezt a funkciót a C, hogy

45
00:02:02,940 --> 00:02:05,890
lehetővé teszi, hogy nyomtatni valamit
és formázza meg a képernyőn.

46
00:02:05,890 --> 00:02:07,950
Bemutattuk a CS50
Könyvtár, ahol

47
00:02:07,950 --> 00:02:11,420
Van most az Ön rendelkezésére get_char,
és get_int és get_string,

48
00:02:11,420 --> 00:02:14,610
és néhány egyéb funkciót,
Nos, amelyen keresztül lehet kapni bemenet

49
00:02:14,610 --> 00:02:16,260
a felhasználó saját billentyűzettel.

50
00:02:16,260 --> 00:02:20,640
És mi is szemügyre vette a dolgokat
mint these- bool, és char,

51
00:02:20,640 --> 00:02:22,490
és dupla, úszó,
int, long_long húr.

52
00:02:22,490 --> 00:02:25,170
És van még más adattípusokat C.

53
00:02:25,170 --> 00:02:28,560
>> Más szóval, ha kijelentem,
a változó tárolja néhány érték,

54
00:02:28,560 --> 00:02:32,600
vagy ha végre egy funkciót
hogy visszatér valamilyen érték,

55
00:02:32,600 --> 00:02:35,290
megadhatja, hogy mit
típusú érték, hogy van.

56
00:02:35,290 --> 00:02:37,310
Ez egy string, mint egy
karakterek sorozata?

57
00:02:37,310 --> 00:02:39,490
Ez több, mint egy egész?

58
00:02:39,490 --> 00:02:41,390
Ez egy lebegőpontos
érték, vagy hasonlók?

59
00:02:41,390 --> 00:02:46,180
Tehát C, ellentétben Scratch, valójában
kezdte meg, milyen adatokat

60
00:02:46,180 --> 00:02:48,330
voltunk visszatérő vagy használ.

61
00:02:48,330 --> 00:02:51,910
>> De, persze, mi is ütközött
néhány alapvető korlátait számítástechnika.

62
00:02:51,910 --> 00:02:54,100
És különösen annak
ezen a nyelven C, visszahívás

63
00:02:54,100 --> 00:02:57,070
hogy vettünk egy pillantást
integer túlcsordulás, a valóság

64
00:02:57,070 --> 00:03:00,460
hogy ha csak egy
véges mennyiségű memóriát

65
00:03:00,460 --> 00:03:04,600
vagy, pontosabban, véges számú
bitek, akkor csak akkor számíthat ilyen magas.

66
00:03:04,600 --> 00:03:08,460
És így nézett ez a példa itt
amellyel a számláló egy repülőgép,,

67
00:03:08,460 --> 00:03:13,510
valóban, ha fut elég hosszú lenne
túlcsordulás és az eredmény egy szoftver

68
00:03:13,510 --> 00:03:15,560
tényleges fizikai potenciál hiba.

69
00:03:15,560 --> 00:03:18,600
>> Megnéztük úszó
pont pontatlanság, a valóság

70
00:03:18,600 --> 00:03:22,280
hogy csak véges számú
bitek, legyen az 32 vagy 64,

71
00:03:22,280 --> 00:03:27,330
akkor csak azokat annyi szám
után egy tizedespont, ami után

72
00:03:27,330 --> 00:03:29,110
elkezdi, hogy pontatlan.

73
00:03:29,110 --> 00:03:32,360
Így például, egyharmadát a
világ itt, a mi emberi világban,

74
00:03:32,360 --> 00:03:35,360
tudjuk, hogy ez csak egy végtelen számú
3s tizedesvessző után.

75
00:03:35,360 --> 00:03:38,820
De a számítógép nem feltétlenül
képviselnek végtelen számú számok

76
00:03:38,820 --> 00:03:42,590
ha csak azt teszik lehetővé, hogy néhány
véges mennyiségű információt.

77
00:03:42,590 --> 00:03:45,900
>> Tehát nem csak mi felállítja
nagyobb teljesítmény szempontjából

78
00:03:45,900 --> 00:03:49,280
arra, hogyan lehet kifejezni magát
a billentyűzet a programozás,

79
00:03:49,280 --> 00:03:51,430
mi is csak mi
akkor valóban nem.

80
00:03:51,430 --> 00:03:55,790
És valóban, a hibákat és hibák
adódnak az ilyen jellegű kérdéseket.

81
00:03:55,790 --> 00:03:59,900
És valóban, a témák között ma
lesznek témák, mint a hibakeresés

82
00:03:59,900 --> 00:04:03,699
és valóban keresi a motorháztető alatt
A dolgok kerültek bevezetésre a múlt héten

83
00:04:03,699 --> 00:04:05,490
tényleges megvalósítása,
úgy, hogy a jobb

84
00:04:05,490 --> 00:04:10,530
tisztában vannak mind a képességeit és
A korlátozások a nyelv, mint a C.

85
00:04:10,530 --> 00:04:14,770
>> És valóban, mi húzza vissza a rétegek
A legegyszerűbb adatszerkezet,

86
00:04:14,770 --> 00:04:17,756
egy úgynevezett tömb, amely
Scratch történik, hogy hívja a "listán".

87
00:04:17,756 --> 00:04:19,589
Ez egy kicsit
különböző ebben az összefüggésben.

88
00:04:19,589 --> 00:04:23,340
És akkor mi is be az egyik
Először a terület-specifikus problémák

89
00:04:23,340 --> 00:04:26,790
a CS50, a világ
kriptográfia, a művészet rejtjelező

90
00:04:26,790 --> 00:04:29,650
vagy rejtjelezés információt,
hogy küldhetünk titkos üzeneteket

91
00:04:29,650 --> 00:04:34,520
és dekódolja a titkos üzenetek
két személy között, az A és B

92
00:04:34,520 --> 00:04:37,490
>> Szóval mielőtt átmenet
az, hogy az új világ,

93
00:04:37,490 --> 00:04:42,059
próbáljuk, hogy felvértezzük Önt néhány
technikákat, amelyek segítségével megszünteti

94
00:04:42,059 --> 00:04:43,850
vagy csökkentse legalább néhány
A frusztráció

95
00:04:43,850 --> 00:04:46,630
hogy már valószínűleg találkozott
Az elmúlt héten egyedül.

96
00:04:46,630 --> 00:04:50,830
Tény, hogy előttünk van such-- néhány
Az első probléma a C. És esély,

97
00:04:50,830 --> 00:04:54,010
Ha te, mint én, az első alkalommal
megpróbál írja ki a program

98
00:04:54,010 --> 00:04:57,330
akkor is, ha úgy gondolja, logikusan
A program nagyon egyszerű,

99
00:04:57,330 --> 00:05:01,200
Ön is nagyon jól megüt egy fal, és
a fordító nem fog együttműködni.

100
00:05:01,200 --> 00:05:03,940
Tedd, vagy csenget nem megy
hogy ténylegesen az ajánlattételt.

101
00:05:03,940 --> 00:05:05,450
>> És miért lenne az?

102
00:05:05,450 --> 00:05:07,950
Nos, vessünk egy pillantást,
talán egy egyszerű program.

103
00:05:07,950 --> 00:05:11,190
Megyek, hogy menjen előre, és mentse ezt a
Fájl szándékosan nevű buggy0.c,

104
00:05:11,190 --> 00:05:13,590
mert tudom, hogy
kifogásolható előre.

105
00:05:13,590 --> 00:05:17,400
De lehet, hogy nem veszik észre, hogy ha ez a
az első vagy második vagy harmadik program

106
00:05:17,400 --> 00:05:18,830
hogy igazából így magam.

107
00:05:18,830 --> 00:05:23,820
Így fogok menni előre, és
írja ki, int main (void).

108
00:05:23,820 --> 00:05:28,130
Aztán belső én kapcsos zárójelek
egy nagyon ismerős ( "hello, world--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - és egy félig kettőspont.

110
00:05:30,980 --> 00:05:32,360
>> Már mentette a fájlt.

111
00:05:32,360 --> 00:05:34,850
Most fogok lemenni
az én terminál ablak

112
00:05:34,850 --> 00:05:40,340
és adjuk ki a make buggy0, mert megint
a fájl nevét ma buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Szóval írd be: make buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> És, ó, istenem, előhívni utoljára
hogy nincs hibaüzenet egy jó dolog.

115
00:05:48,200 --> 00:05:49,740
Tehát nem kimenet egy jó dolog.

116
00:05:49,740 --> 00:05:52,920
De itt van világosan
Egyes hibák számát.

117
00:05:52,920 --> 00:05:56,470
>> Tehát az első sorban a termelés
beírása után teszi buggy0, visszahívás,

118
00:05:56,470 --> 00:05:59,540
az csenget a meglehetősen bőbeszédű kimenet.

119
00:05:59,540 --> 00:06:02,067
A motorháztető alatt,
CS50 IDE van konfigurálva

120
00:06:02,067 --> 00:06:04,150
hogy egy csomó
opciók ezzel fordító

121
00:06:04,150 --> 00:06:05,941
így nem kell
gondolkodni róluk.

122
00:06:05,941 --> 00:06:08,840
És ez minden, ami első sorban
azt jelenti, hogy kezdődik csenget.

123
00:06:08,840 --> 00:06:11,720
>> De azután, hogy a problémák
kezdődik, hogy a megjelenésüket.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c a 3. sorban, karakter
5, van egy nagy, vörös hiba.

125
00:06:17,390 --> 00:06:18,380
Mi az?

126
00:06:18,380 --> 00:06:23,562
Burkoltan kijelentette könyvtár funkciója
printf típusú int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Úgy értem, hogy nagyon gyorsan
mindig nagyon misztikus.

129
00:06:28,379 --> 00:06:30,170
És természetesen, az első
pillantásra, mi nem

130
00:06:30,170 --> 00:06:32,380
elvárják, hogy megértsék a
teljes egészében az adott üzenetet.

131
00:06:32,380 --> 00:06:34,213
És így az egyik tanulság,
ma megy

132
00:06:34,213 --> 00:06:36,919
hogy próbálja észrevenni
minták, vagy hasonló dolgok,

133
00:06:36,919 --> 00:06:38,960
hibák lehet, hogy
a múltban tapasztalt.

134
00:06:38,960 --> 00:06:41,335
Tehát lássuk ugratni egymástól csak
ezeket a szavakat, ismerős.

135
00:06:41,335 --> 00:06:44,290
A nagy, vörös hiba egyértelműen
szimbolikus, hogy valami baj van.

136
00:06:44,290 --> 00:06:47,940
>> hallgatólagosan nyilvánításáról
könyvtári függvény a printf.

137
00:06:47,940 --> 00:06:51,680
Tehát akkor is, ha nem egészen értem, hogy mit
burkoltan kijelentette könyvtár funkciója

138
00:06:51,680 --> 00:06:54,900
eszközöket, a probléma biztosan
tárgya printf valahogy.

139
00:06:54,900 --> 00:06:59,130
És a forrás, hogy a kérdés
köze nyilvánította.

140
00:06:59,130 --> 00:07:02,440
>> Nyilvánító funkció
megemlíteni, hogy az első alkalommal.

141
00:07:02,440 --> 00:07:06,210
És mi használt terminológia a múlt héten
deklarálási függvény prototípus,

142
00:07:06,210 --> 00:07:11,860
akár csak egy sort a tetején a
saját fájlt vagy egy úgynevezett header fájlt.

143
00:07:11,860 --> 00:07:15,300
És milyen fájl nem mondunk
a múlt héten, hogy a printf az idézet,

144
00:07:15,300 --> 00:07:17,080
idézet vége, kijelentette?

145
00:07:17,080 --> 00:07:20,950
Milyen fájl prototípus?

146
00:07:20,950 --> 00:07:24,640
>> Tehát, ha emlékeznek rá, a legelső dolog, amit
gépelt, szinte minden program utolsó time--

147
00:07:24,640 --> 00:07:30,790
és véletlenül egy pillanattal ezelőtt kezdődött
gépelés myself-- volt ez here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- számára
input / output-- dot h És valóban,

149
00:07:38,630 --> 00:07:41,860
Ha most menteni a fájlt, megyek
hogy menjen előre, és törölje a képernyő,

150
00:07:41,860 --> 00:07:44,740
amit tehetünk beírásával
Tiszta, vagy tudod tartani Ellenőrző L,

151
00:07:44,740 --> 00:07:47,680
csak azért, hogy törölje a terminál ablakban
csak azért, hogy megszüntesse néhány sűrűjébe.

152
00:07:47,680 --> 00:07:51,370
>> Megyek megy előre, és
újbóli típusú make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
És íme, még mindig látni, hogy
hosszú parancsot csenget,

154
00:07:53,790 --> 00:07:55,470
de nincs hibaüzenet ebben az időben.

155
00:07:55,470 --> 00:07:58,800
És valóban, ha én ./buggy0,
mint legutóbb,

156
00:07:58,800 --> 00:08:01,860
ahol dot jelent ez
könyvtár, Slash csak azt jelenti,

157
00:08:01,860 --> 00:08:05,040
itt jön a program nevét és
hogy a program neve is buggy0,

158
00:08:05,040 --> 00:08:07,340
Enter "hello, világ".

159
00:08:07,340 --> 00:08:09,440
>> Most, hogy lehet, hogy van
félretett ez a megoldás

160
00:08:09,440 --> 00:08:12,017
anélkül, hogy feltétlenül
felismerve annyi szó

161
00:08:12,017 --> 00:08:14,350
mint én, biztosan, amelynek
tette ezt oly sok éven át?

162
00:08:14,350 --> 00:08:18,720
Nos, észre per az első probléma
set, azt bemutatni, hogy egy parancs

163
00:08:18,720 --> 00:08:21,175
hogy CS50 saját személyzete
írta nevű help50.

164
00:08:21,175 --> 00:08:24,300
És valóban, a C-nek specifikációja
A probléma van beállítva, hogy hogyan kell használni ezt.

165
00:08:24,300 --> 00:08:27,210
>> De help50 lényegében
olyan program, amely CS50 személyzete

166
00:08:27,210 --> 00:08:30,850
azt írta, hogy lehetővé teszi, hogy futtatni
egy parancs vagy program futtatásához

167
00:08:30,850 --> 00:08:36,169
és ha nem érti a
kimenet, hogy adja át a kimenetét help50,

168
00:08:36,169 --> 00:08:38,890
amely pontnál a szoftver
hogy a pálya személyzete írta

169
00:08:38,890 --> 00:08:42,429
akkor nézd meg a program kimenetét
soronként, karakterenként.

170
00:08:42,429 --> 00:08:46,000
És ha mi, a személyzet, felismeri a
hibaüzenetet amit tapasztal,

171
00:08:46,000 --> 00:08:50,580
megpróbáljuk provokálni az Ön számára néhány
költői kérdések, néhány tanácsot,

172
00:08:50,580 --> 00:08:54,890
mint egy TF vagy CA vagy magam
tenne személyesen munkaidőben.

173
00:08:54,890 --> 00:08:58,320
>> Így néz ki a help50 ha nem
feltétlenül ismeri fel a problémát.

174
00:08:58,320 --> 00:09:00,790
De nem hivatkozhat rá
túl sok, mint egy mankó.

175
00:09:00,790 --> 00:09:03,990
Bizonnyal megpróbálja megérteni, hogy
kimenet majd tanulni belőle

176
00:09:03,990 --> 00:09:07,571
úgy, hogy csak egyszer vagy kétszer mit
botlott help50 egy adott hiba

177
00:09:07,571 --> 00:09:08,070
üzenet.

178
00:09:08,070 --> 00:09:10,660
Ezt követően, ha kell
jobban felszerelt magad

179
00:09:10,660 --> 00:09:13,180
hogy kitaláljuk, mi valójában.

180
00:09:13,180 --> 00:09:14,350
>> Csináljunk egy másik itt.

181
00:09:14,350 --> 00:09:20,410
Hadd menjek előre, és egy másik
fájlt fogjuk hívni ezt buggy1.c.

182
00:09:20,410 --> 00:09:23,110
És ebben a fájlban vagyok
fog deliberately--

183
00:09:23,110 --> 00:09:26,330
de úgy, mintha én nem
megérteni, mi hibát csináltam.

184
00:09:26,330 --> 00:09:31,420
>> Megyek, hogy menjen előre, és nem this--
#include, amióta

185
00:09:31,420 --> 00:09:33,660
Megtanultam a leckét egy perce.

186
00:09:33,660 --> 00:09:36,220
Int main (void), mint korábban.

187
00:09:36,220 --> 00:09:40,880
És akkor itt fogok
tenni s karakterlánc - get_string.

188
00:09:40,880 --> 00:09:43,770
És emlékszem az utolsó alkalom, hogy
ez azt jelenti, hé, számítógép,

189
00:09:43,770 --> 00:09:48,280
adj egy változó, nevezzük s, és
hogy milyen típusú a változónak egy karakterlánc

190
00:09:48,280 --> 00:09:50,150
így tudok tárolni egy vagy több szót is.

191
00:09:50,150 --> 00:09:52,191
>> Majd a jobb oldali
oldalán az egyenlőségjel

192
00:09:52,191 --> 00:09:54,980
van get_string, amely egy
funkciót a CS50 Könyvtár

193
00:09:54,980 --> 00:09:55,980
hogy pontosan ezt teszi.

194
00:09:55,980 --> 00:09:59,740
Kap egy funkciót, majd
átadja jobbról balra.

195
00:09:59,740 --> 00:10:02,670
Tehát ez egyenlőségjel nem jelenti azt,
"Egyenlő", mint gondolnánk a matematika.

196
00:10:02,670 --> 00:10:04,750
Ez azt jelenti, hozzárendelés jobbról balra.

197
00:10:04,750 --> 00:10:09,640
Tehát ez azt jelenti, hogy a string
A felhasználó és tárolja belsejében s.

198
00:10:09,640 --> 00:10:10,460
>> Most használja.

199
00:10:10,460 --> 00:10:13,820
Hadd menjen előre, és most, mint a második
vonal, hadd menjen előre, és azt mondják, "szia" -

200
00:10:13,820 --> 00:10:19,330
Nem "világ", hanem a "hello,% S-
ami a mi helyőrzővel vessző s,

201
00:10:19,330 --> 00:10:22,030
ami a mi változó,
majd pontosvessző.

202
00:10:22,030 --> 00:10:26,070
Tehát, ha nem csavarja fel túl sok
Itt, ez úgy néz ki, mint a helyes kódot.

203
00:10:26,070 --> 00:10:28,090
>> És én ösztönök most már az összeállításhoz.

204
00:10:28,090 --> 00:10:30,400
A fájl neve buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Így fogok tenni, hogy buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
És stoppol-IT, ha nincs
még több hiba, mint korábban.

207
00:10:36,377 --> 00:10:38,210
Úgy értem, van még
hibaüzenetek akkor lenne

208
00:10:38,210 --> 00:10:40,400
Úgy tűnik, mint a tényleges vonalak ebben a programban.

209
00:10:40,400 --> 00:10:42,730
>> De az elvihető itt,
akkor is, ha túlterheltek

210
00:10:42,730 --> 00:10:45,040
két vagy három, vagy
Négy további hibaüzeneteket,

211
00:10:45,040 --> 00:10:48,340
hangsúly mindig a nagyon
Először ezeket az üzeneteket.

212
00:10:48,340 --> 00:10:52,220
Nézzük a legfelső egy,
görgetés vissza, mint szükséges.

213
00:10:52,220 --> 00:10:53,930
Tehát itt beírtam make buggy1.

214
00:10:53,930 --> 00:10:55,700
Itt van az Clang kimenet, mint várták.

215
00:10:55,700 --> 00:10:57,290
>> És itt van az első piros hiba.

216
00:10:57,290 --> 00:11:02,370
A be nem azonosító
húr, nem értem szabvány?

217
00:11:02,370 --> 00:11:04,260
Tehát szabvány van
valójában valami mást.

218
00:11:04,260 --> 00:11:06,240
Arra utal, hogy a felhasználó
billentyűzet, lényegében.

219
00:11:06,240 --> 00:11:08,080
>> De ez nem így értettem.

220
00:11:08,080 --> 00:11:11,770
Úgy értettem húr, és azt jelentette, get_string.

221
00:11:11,770 --> 00:11:16,200
Tehát mi az, hogy én
elfelejtette megtenni ebben az időben?

222
00:11:16,200 --> 00:11:20,230
Mi hiányzik ebben az időben?

223
00:11:20,230 --> 00:11:23,600
Ott van a #include,
így van, hogy a printf.

224
00:11:23,600 --> 00:11:26,090
>> De mit is nincs
hozzáférés csak még?

225
00:11:26,090 --> 00:11:29,420
Nos, mint legutóbb,
Azt kell mondani, a fordító

226
00:11:29,420 --> 00:11:31,691
Csengés, amit ezek a funkciók.

227
00:11:31,691 --> 00:11:33,940
Get_string nem jön
C. És Különösen azt

228
00:11:33,940 --> 00:11:38,160
nem jön a
header fájlt,.

229
00:11:38,160 --> 00:11:40,770
Ez helyett jön
valamit a személyzet írt,

230
00:11:40,770 --> 00:11:44,176
amely egy másik fájl
nevét, de találóan.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Tehát egyszerűen, hozzátéve, hogy egy sort
A code-- visszahívással utoljára

233
00:11:50,861 --> 00:11:53,610
hogy amikor csenget fut, ez lesz
hogy nézd meg a kód fentről lefelé,

234
00:11:53,610 --> 00:11:54,193
balról jobbra.

235
00:11:54,193 --> 00:11:57,200
Meg fog észrevenni,
ó, amit akar.

236
00:11:57,200 --> 00:11:59,900
Hadd menjen, és állapítsa meg,
ahol ez a szerveren,

237
00:11:59,900 --> 00:12:03,090
és másolja, lényegében
a tetején a saját file

238
00:12:03,090 --> 00:12:06,820
így ezen a ponton a történet,
1. sor, a többi a program

239
00:12:06,820 --> 00:12:11,651
lehet, sőt, használja a funkciót
abban, köztük get_string.

240
00:12:11,651 --> 00:12:13,650
Így fogok figyelmen kívül hagyni
a többi ilyen hibák,

241
00:12:13,650 --> 00:12:17,190
mert én, sőt, azt gyanítják, hogy csak
Az első valóban számít.

242
00:12:17,190 --> 00:12:20,780
És én megyek előre, és futtassa újra,
mentése után a fájlt, hogy buggy1.

243
00:12:20,780 --> 00:12:22,580
És íme, ez nem működik.

244
00:12:22,580 --> 00:12:29,200
És ha én ./buggy1 és írja be, mert
Például Zamyla, most lesz hello,

245
00:12:29,200 --> 00:12:32,000
Zamyla helyett hello, világ.

246
00:12:32,000 --> 00:12:32,550
>> Rendben.

247
00:12:32,550 --> 00:12:35,890
Tehát a takeaways itt akkor kell,
egyet, próbáld, hogy szed, amennyit csak tudsz

248
00:12:35,890 --> 00:12:39,140
A hibaüzenetek egyedül keres
néhány a felismerhető szavakat.

249
00:12:39,140 --> 00:12:43,070
Korlátozó hogy használja help50 per
A probléma meghatározott specifikáció.

250
00:12:43,070 --> 00:12:46,500
De korlátozó ez is mindig meg
a tetején a hiba csak, legalább

251
00:12:46,500 --> 00:12:50,051
kezdetben, hogy milyen információkat
ez talán valóban így.

252
00:12:50,051 --> 00:12:52,300
De kiderül, ott a
még több funkciót épített

253
00:12:52,300 --> 00:12:55,030
a CS50 Könyvtár segíteni
Ön korán a félévben

254
00:12:55,030 --> 00:12:57,580
és korán programozás
kitalálni, hogy mi folyik itt baj.

255
00:12:57,580 --> 00:12:59,840
Tehát lássuk egy másik példát itt.

256
00:12:59,840 --> 00:13:04,350
Azt fogom hívni ezt buggy2, amely
ismét meg fog hibás ki

257
00:13:04,350 --> 00:13:05,650
A kapu, a design.

258
00:13:05,650 --> 00:13:09,980
>> És én megyek előre
és nem #include.

259
00:13:09,980 --> 00:13:12,580
És akkor fogok csinálni int main (void).

260
00:13:12,580 --> 00:13:14,840
És akkor fogok csinálni egy hurok.

261
00:13:14,840 --> 00:13:16,690
(Int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i kisebb vagy egyenlő, mint 10.

263
00:13:18,750 --> 00:13:24,260
i ++, majd kapcsos zárójelek, megyek
kinyomtatni csak egy hashtag szimbólum itt

264
00:13:24,260 --> 00:13:25,920
és egy új sor karakter.

265
00:13:25,920 --> 00:13:29,220
>> Tehát a célom ezzel a
program nagyon egyszerűen

266
00:13:29,220 --> 00:13:33,150
iterálására 10-szer
és minden egyes iteráció

267
00:13:33,150 --> 00:13:35,260
E hurok minden alkalommal
át a ciklusban,

268
00:13:35,260 --> 00:13:37,660
nyomtassa ki a hashtag,
Hashtag, a hashtag.

269
00:13:37,660 --> 00:13:40,480
Soronként, mert
hogy az új vonal van.

270
00:13:40,480 --> 00:13:42,787
És emlékszem, hogy a vonatkozó
hurok, egy utolsó week--

271
00:13:42,787 --> 00:13:44,620
és akkor még több
ismeri a szintaxis

272
00:13:44,620 --> 00:13:47,170
segítségével ez a gyakorlattal
előtt long-- ez ad nekem

273
00:13:47,170 --> 00:13:49,740
változó az i, és beállítja 0.

274
00:13:49,740 --> 00:13:52,650
>> Ez megnöveli az I.
Minden iteráció 1.

275
00:13:52,650 --> 00:13:54,940
Tehát én megy 1-2 3-ra.

276
00:13:54,940 --> 00:13:57,690
És akkor ez a feltétel az
között középen félig kettőspont

277
00:13:57,690 --> 00:14:03,010
lesz ellenőrizni minden iterációban, hogy
arról, hogy még mindig tartományon belül.

278
00:14:03,010 --> 00:14:06,830
Ezért szeretném iterálására 10-szer, így
Van valami nagyon intuitív módon éppen

279
00:14:06,830 --> 00:14:09,070
tedd 10-én felső korlát van.

280
00:14:09,070 --> 00:14:14,310
>> És mégis, amikor futtatom ezt követően
fordítanunk make buggy2--

281
00:14:14,310 --> 00:14:15,440
és ez összeállítja az OK gombra.

282
00:14:15,440 --> 00:14:17,980
Szóval nincs
szintaktikai hiba ebben az időben.

283
00:14:17,980 --> 00:14:20,940
Hadd menjek előre most
és fuss buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
És most lépjünk fel.

285
00:14:22,620 --> 00:14:24,890
És hadd növelje
a méret az ablak.

286
00:14:24,890 --> 00:14:33,720
>> Úgy tűnik, hogy az 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Tehát van 11 hashtags, bár
Egyértelműen fel 10 belül ez a hurok.

288
00:14:38,891 --> 00:14:42,140
Nos, néhányan lehet látni azonnal
mi a hiba azért van, mert valóban, ez

289
00:14:42,140 --> 00:14:43,720
nem egy nagyon nehéz hibát tenni.

290
00:14:43,720 --> 00:14:46,070
De ez nagyon gyakran
tette nagyon korán.

291
00:14:46,070 --> 00:14:49,820
>> Amit én szeretnék rámutatni, bár,
az, hogy hogyan lehet azt kiderítjük?

292
00:14:49,820 --> 00:14:52,300
Nos, kiderült, hogy
A CS50 könyvtár jön

293
00:14:52,300 --> 00:14:55,380
nem csak get_string és get_int
és get_float és egyéb funkciók.

294
00:14:55,380 --> 00:14:59,980
Meg is jön egy speciális funkcióval
nevezett eprintf, vagy hiba printf.

295
00:14:59,980 --> 00:15:03,270
És ez csak és kizárólag tenni
ez egy kicsit könnyebb

296
00:15:03,270 --> 00:15:06,310
amikor hibakeresés a kódot, hogy csak
hibaüzenetet küld a képernyőn

297
00:15:06,310 --> 00:15:07,850
és tudom, honnan jött.

298
00:15:07,850 --> 00:15:11,000
>> Így például az egyik dolog, amit talán
itt csinálni ezzel a funkcióval this--

299
00:15:11,000 --> 00:15:20,230
eprintf, aztán megyek előre
és mondom most% i, backslash, n.

300
00:15:20,230 --> 00:15:22,330
És megyek, hogy csatlakoztassa az i értékét.

301
00:15:22,330 --> 00:15:25,400
És fel tetején, mert ez a
van a CS50 Library,

302
00:15:25,400 --> 00:15:27,580
Megyek, hogy menjen előre
és tartalmazzák

303
00:15:27,580 --> 00:15:29,169
így van, hogy ezt a funkciót.

304
00:15:29,169 --> 00:15:31,460
De nézzük meg, mi vonal
9. kéne csinálnia.

305
00:15:31,460 --> 00:15:32,670
Megyek törölni ezt végül.

306
00:15:32,670 --> 00:15:34,670
Ennek semmi köze
az én legfőbb cél.

307
00:15:34,670 --> 00:15:39,090
De eprintf, hiba printf, csak azt jelentette,
hogy adjon nekem néhány diagnosztikai információkat.

308
00:15:39,090 --> 00:15:42,460
Amikor elindítom a programot, szeretnék
lássa a képernyőn ideiglenesen

309
00:15:42,460 --> 00:15:44,550
valamint csak megérteni
mi történik.

310
00:15:44,550 --> 00:15:47,330
>> És valóban, az egyes
iterációs itt a 9-es vonal

311
00:15:47,330 --> 00:15:49,260
Látni akarom, mi az i értéke?

312
00:15:49,260 --> 00:15:50,290
Mi az i értéke?

313
00:15:50,290 --> 00:15:51,280
Mi az i értéke?

314
00:15:51,280 --> 00:15:55,650
És remélhetőleg én csak
látja az üzenetet is, 10-szer.

315
00:15:55,650 --> 00:15:57,780
>> Tehát hadd menjen előre, és
újrafordítod programom,

316
00:15:57,780 --> 00:15:59,905
ahogy azt kell tennie, bármikor
Azt, hogy a változás. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
És now-- OK.

319
00:16:03,640 --> 00:16:04,820
Van sokkal több folyik.

320
00:16:04,820 --> 00:16:07,610
Tehát hadd lépjünk fel
még nagyobb ablakot.

321
00:16:07,610 --> 00:16:10,190
>> És látni fogod, hogy minden
A hashtags még nyomtat.

322
00:16:10,190 --> 00:16:15,270
De mindegyik közé most ezt
diagnosztikai kimeneti formátuma a következő.

323
00:16:15,270 --> 00:16:17,960
A név az én programot itt buggy2.

324
00:16:17,960 --> 00:16:20,432
A név a fájl buggy2.c.

325
00:16:20,432 --> 00:16:24,080
A vonal száma, ahonnan
ez volt nyomtatva a 9-es vonal.

326
00:16:24,080 --> 00:16:27,500
, Majd a jobb oldalán van a
hibaüzenet várok.

327
00:16:27,500 --> 00:16:30,701
>> És mi szép ez, hogy
most már nem kell feltétlenül számolni

328
00:16:30,701 --> 00:16:32,200
a fejemben, amit a program csinál.

329
00:16:32,200 --> 00:16:34,240
Azt láthatjuk, hogy a
első iteráció i értéke 0,

330
00:16:34,240 --> 00:16:39,420
majd 1, majd a 2, majd 3, majd 4, majd
5, majd 6, majd 7, majd 8, majd 9, majd

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Tehát egy pillanat.

333
00:16:42,050 --> 00:16:43,740
Mi folyik itt?

334
00:16:43,740 --> 00:16:48,190
Még mindig úgy tűnik, hogy számlálás
rendeltetésszerűen 10.

335
00:16:48,190 --> 00:16:50,550
>> De hol is kezdjem?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Így a 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11 ujj

338
00:16:58,040 --> 00:16:59,990
jelzi a problémát.

339
00:16:59,990 --> 00:17:02,850
Úgy tűnik, hogy számít
tévesen az én hurok.

340
00:17:02,850 --> 00:17:06,599
Ahelyett, hogy menjen 10 ismétléseket
Kezdek 0,

341
00:17:06,599 --> 00:17:09,550
Én végződő keresztül 10.

342
00:17:09,550 --> 00:17:12,030
De mivel, mint egy számítógép,
Kezdek számlálás 0,

343
00:17:12,030 --> 00:17:15,250
Azt kell számolni fel
, de nem keresztül, 10.

344
00:17:15,250 --> 00:17:18,510
>> És így a fix, végül is
rájött itt, egy két dolgot.

345
00:17:18,510 --> 00:17:22,430
Tudtam nagyon egyszerűen azt mondják,
számolni akár kisebb, mint 10.

346
00:17:22,430 --> 00:17:27,260
Így a 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, ami valóban helyes,

347
00:17:27,260 --> 00:17:28,900
annak ellenére, hogy hangzik egy kicsit rossz.

348
00:17:28,900 --> 00:17:35,070
Vagy tehettem kisebb vagy egyenlő
9, mindaddig, amíg I 0-val kezdődnek.

349
00:17:35,070 --> 00:17:40,056
Vagy ha nagyon nem tetszik, hogy te
számíthat fel a 10, de indul a 1.

350
00:17:40,056 --> 00:17:41,680
De ismétlem, ez csak nem az, hogy gyakori.

351
00:17:41,680 --> 00:17:43,977
In programming-- jóllehet
nem annyira Scratch--

352
00:17:43,977 --> 00:17:45,810
de a programozás
C és más nyelveken,

353
00:17:45,810 --> 00:17:47,670
mint a JavaScript és
Python és mások, ez

354
00:17:47,670 --> 00:17:49,880
Csak nagyon gyakori
vitánk a bináris

355
00:17:49,880 --> 00:17:53,450
hogy csak elkezd számolni a
legkevesebb tudsz, ami 0.

356
00:17:53,450 --> 00:17:53,950
Rendben.

357
00:17:53,950 --> 00:17:55,160
Tehát ez eprintf.

358
00:17:55,160 --> 00:17:58,600
És ismét, most, hogy kitaláltam én
probléma, és én megyek vissza 0

359
00:17:58,600 --> 00:18:01,470
keresztül kevesebb, mint 10, megyek
menni, és törölni eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Nem szabad ott lenni, amikor én
szállítani a kód vagy elküldöm a kódot

361
00:18:04,580 --> 00:18:05,800
vagy azt mutatják, hogy bárki másnak.

362
00:18:05,800 --> 00:18:07,980
Ez tényleg csak azt jelentette,
ideiglenes használatát.

363
00:18:07,980 --> 00:18:11,650
De most már kijavítottuk ezt
sajátos problémát is.

364
00:18:11,650 --> 00:18:16,780
>> Nos, lenne még egy példa itt
hogy megyek, hogy felkap a következő.

365
00:18:16,780 --> 00:18:22,850
Megyek megy előre, és
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
És én megyek előre
és #include.

367
00:18:25,580 --> 00:18:29,030
>> És én fogom megmenteni
ezt a fájlt buggy3.c.

368
00:18:29,030 --> 00:18:31,740
És én megyek előre
és állapítsa meg, int main (void).

369
00:18:31,740 --> 00:18:34,186
Aztán belsejében van
Azt fogom csinálni, int i _ -

370
00:18:34,186 --> 00:18:36,435
Szeretnék végre egy programot
egy get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Ez nem egy függvény, amely nem létezik még.

373
00:18:40,770 --> 00:18:42,870
Így fogunk végrehajtani
ez csak egy pillanatra.

374
00:18:42,870 --> 00:18:45,541
De megyünk, hogy miért
ez hibás az első menetben.

375
00:18:45,541 --> 00:18:47,290
És ha egyszer már ütött
int a felhasználó,

376
00:18:47,290 --> 00:18:53,365
Csak megyek nyomtatni% i negatív
integer, backslash, n, vessző, i.

377
00:18:53,365 --> 00:18:55,240
Más szóval, minden, amit
szeretné ezt a programot csinálni

378
00:18:55,240 --> 00:18:58,000
van, hogy egy negatív int
a felhasználót, majd nyomtassa ki

379
00:18:58,000 --> 00:18:59,980
hogy ilyen és ilyen negatív int.

380
00:18:59,980 --> 00:19:02,080
>> Most kell végrehajtani ezt a feladatot.

381
00:19:02,080 --> 00:19:05,740
Így később az én fájlban fogok menni
előre, és állapítsa meg a nevezett funkció

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - és mi
gyere vissza, hogy ez mit jelent vonal ismét

383
00:19:10,670 --> 00:19:18,790
egy moment-- int n; do-- do
A following-- printf n :.

384
00:19:18,790 --> 00:19:26,210
És akkor fogok csinálni n - get_int,
és ezt míg n értéke 0-nál nagyobb.

385
00:19:26,210 --> 00:19:28,310
Majd vissza n ;.

386
00:19:28,310 --> 00:19:31,730
>> Tehát van egy csomó folyik
ezt, de egyik sem mi nem

387
00:19:31,730 --> 00:19:33,710
nézd meg a múlt héten, legalább röviden.

388
00:19:33,710 --> 00:19:36,980
Tehát on line 10; itt nyilvánították
nevű függvény get_negative_int,

389
00:19:36,980 --> 00:19:39,620
és tettem (void), a
zárójelben, az oka, hogy ez a

390
00:19:39,620 --> 00:19:40,950
nem veszi bemenet.

391
00:19:40,950 --> 00:19:42,910
Én nem halad semmit
ezt a funkciót.

392
00:19:42,910 --> 00:19:44,690
Épp most valamit belőle.

393
00:19:44,690 --> 00:19:47,270
>> És amit remélem, hogy
vissza az egész.

394
00:19:47,270 --> 00:19:50,040
Nincs adat típus
C nevű negative_int.

395
00:19:50,040 --> 00:19:52,880
Ez csak int, így fog
hogy a számunkra, hogy győződjön meg arról,

396
00:19:52,880 --> 00:19:55,340
hogy az érték, amely valójában
visszaküldött nemcsak int

397
00:19:55,340 --> 00:19:56,380
de az is negatív.

398
00:19:56,380 --> 00:20:02,150
>> A 12. sorban én nyilvánító változó
úgynevezett n, és így int típusú.

399
00:20:02,150 --> 00:20:07,500
Aztán a sorban 13 és 18 vagyok
csinál valamit, amíg valami igaz.

400
00:20:07,500 --> 00:20:11,040
Megyek előre, és a nyomtatás
n, vastagbél, majd egy szóközt,

401
00:20:11,040 --> 00:20:12,800
mint egy prompt a felhasználó számára.

402
00:20:12,800 --> 00:20:16,410
>> Én akkor még get_int és
tárolása az úgynevezett visszatérési értéke

403
00:20:16,410 --> 00:20:18,130
hogy n változó.

404
00:20:18,130 --> 00:20:22,600
De megyek csinálom
ez míg n értéke 0-nál nagyobb.

405
00:20:22,600 --> 00:20:27,960
Más szóval, ha a felhasználó ad én egy
int és ez a szám nagyobb, mint 0,

406
00:20:27,960 --> 00:20:31,180
ergo, pozitív, megyek
Csak ne reprompting a felhasználó,

407
00:20:31,180 --> 00:20:37,160
tartsa reprompting, arra kényszerítve őket, hogy
együttműködnek, és adj egy negatív int.

408
00:20:37,160 --> 00:20:41,640
>> És ha n valójában negative--
Gondolom a felhasználó végül típusok -50,

409
00:20:41,640 --> 00:20:46,710
akkor ez a while ciklus már nem igaz
mert -50 nem nagyobb, mint 0.

410
00:20:46,710 --> 00:20:51,140
Így kitörni, hogy
loop logikusan és vissza n.

411
00:20:51,140 --> 00:20:53,520
>> De van egy másik
dolog, amit meg kell csinálni.

412
00:20:53,520 --> 00:20:56,190
És én egyszerűen ezt
a másolás és beillesztés

413
00:20:56,190 --> 00:20:58,540
egy sor kód tetején a fájlt.

414
00:20:58,540 --> 00:21:01,630
Meg kell tanítani csenget,
vagy ígéretet zengés,

415
00:21:01,630 --> 00:21:04,630
kifejezetten, hogy én,
Valóban, menj és végrehajtása

416
00:21:04,630 --> 00:21:06,020
Ezt a funkciót get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Azt, hogy csak alacsonyabb a fájlban.

418
00:21:07,674 --> 00:21:09,840
Ismét emlékeztetni arra, hogy csenget
olvasás dolgok fentről lefelé,

419
00:21:09,840 --> 00:21:12,330
balról jobbra, így nem lehet
hívja a funkciót, ha csenget

420
00:21:12,330 --> 00:21:15,330
nem tudom, hogy fog létezni.

421
00:21:15,330 --> 00:21:18,430
>> Most, sajnos, ez a program,
mint néhányan talán észrevették,

422
00:21:18,430 --> 00:21:19,590
már hibás.

423
00:21:19,590 --> 00:21:21,400
Hadd menjek előre, és a buggy3.

424
00:21:21,400 --> 00:21:26,904
Lefordítja, így a probléma most nem
szintaktikai hiba, mint egy szöveges hiba,

425
00:21:26,904 --> 00:21:29,570
ez valójában lesz a logikai
hiba, hogy én már szándékosan

426
00:21:29,570 --> 00:21:32,450
tette a lehetőséget, hogy
átléphető, mi folyik.

427
00:21:32,450 --> 00:21:35,540
>> Megyek, hogy menjen előre
és most fut buggy3.

428
00:21:35,540 --> 00:21:37,490
És én megyek
előre, és nem működnek együtt.

429
00:21:37,490 --> 00:21:39,494
Megyek, hogy ez a szám 1.

430
00:21:39,494 --> 00:21:41,410
Nem tetszik, így
ez megkérdezése megint.

431
00:21:41,410 --> 00:21:42,147
>> Hogyan körülbelül 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Egyik ilyen dolgoznak.

435
00:21:44,740 --> 00:21:46,890
Hogyan -50?

436
00:21:46,890 --> 00:21:48,560
És a program úgy tűnik, működik.

437
00:21:48,560 --> 00:21:49,970
>> Hadd próbáljam meg még egyszer.

438
00:21:49,970 --> 00:21:53,400
Hadd próbáljam -1, úgy tűnik, működik.

439
00:21:53,400 --> 00:21:56,380
Hadd próbáljam -2, úgy tűnik, működik.

440
00:21:56,380 --> 00:21:59,640
Hadd próbáljam 0.

441
00:21:59,640 --> 00:22:01,684
Huh, ez helytelen.

442
00:22:01,684 --> 00:22:03,350
Most mi vagyunk, hogy egy kicsit pedáns itt.

443
00:22:03,350 --> 00:22:07,090
De ez valóban igaz, hogy 0
sem pozitív, sem negatív.

444
00:22:07,090 --> 00:22:11,150
És így az a tény, hogy a program
mondván, hogy a 0 negatív egész szám,

445
00:22:11,150 --> 00:22:12,820
ez technikailag nem helyes.

446
00:22:12,820 --> 00:22:15,180
>> Most, hogy miért csinálja ezt?

447
00:22:15,180 --> 00:22:16,270
Nos, lehet, hogy nyilvánvaló.

448
00:22:16,270 --> 00:22:18,110
És valóban, a program
azt jelentette, hogy viszonylag egyszerű

449
00:22:18,110 --> 00:22:19,670
így van valami, hogy tárja fel.

450
00:22:19,670 --> 00:22:25,870
>> De szeretnénk bemutatni egy harmadik hibakeresés
technika itt az úgynevezett debug50.

451
00:22:25,870 --> 00:22:27,750
Tehát ez egy olyan program,
hogy éppen most létrehozott

452
00:22:27,750 --> 00:22:30,770
ebben az évben az úgynevezett debug50
amely lehetővé teszi,

453
00:22:30,770 --> 00:22:34,130
használni az úgynevezett beépített
grafikus debugger CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
És egy debugger csak egy program, amely
általában lehetővé teszi, hogy a program futtatása

455
00:22:38,400 --> 00:22:44,050
de lépésről lépésről lépésre, vonal
által soronként, szüneteltetését dugta

456
00:22:44,050 --> 00:22:47,626
körül nézett változókat úgy, hogy
A program nem csak fúj múltban

457
00:22:47,626 --> 00:22:49,750
és gyorsan nyomtasson valamit
vagy nem nyomtat valamit.

458
00:22:49,750 --> 00:22:53,250
Ez lehetőséget ad arra, a
emberi sebességgel, hogy kölcsönhatásba lépnek vele.

459
00:22:53,250 --> 00:22:55,470
>> És ezt, akkor
Egyszerűen tegye a következőket.

460
00:22:55,470 --> 00:22:58,479
Összeállítása után a kódot,
amely már nem, buggy3,

461
00:22:58,479 --> 00:23:00,020
megy előre, és futtassa debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Annyira, mint help50 van futtatása
help50 majd a parancs,

464
00:23:06,760 --> 00:23:10,120
debug50 van futtatja debug50 és
akkor a parancs neve.

465
00:23:10,120 --> 00:23:14,440
>> Most nézzük, mi történik az én képernyőn
a jobb oldali, különösen.

466
00:23:14,440 --> 00:23:19,400
Amikor megüt Run, mind a
Hirtelen ez a jobb oldali panel

467
00:23:19,400 --> 00:23:20,419
nyit meg a képernyőn.

468
00:23:20,419 --> 00:23:22,210
És van egy csomó folyik
A első pillantásra.

469
00:23:22,210 --> 00:23:25,110
De nincs túl
sokat aggódni még.

470
00:23:25,110 --> 00:23:28,570
>> Ez mutatja meg mindenre
hogy folyik odabent programom

471
00:23:28,570 --> 00:23:31,130
és most ezeken keresztül
gombok fel tetején van, akkor

472
00:23:31,130 --> 00:23:35,910
amely lehetővé teszi, hogy lépjek át a kódomat
végül lépésről lépésről lépésre.

473
00:23:35,910 --> 00:23:37,140
De nem csak még.

474
00:23:37,140 --> 00:23:38,060
Figyeljük meg, mi történik.

475
00:23:38,060 --> 00:23:40,600
Az én terminál ablak
Én is kéri n.

476
00:23:40,600 --> 00:23:44,560
És én megyek előre, és
együtt ez idő típusú -1.

477
00:23:44,560 --> 00:23:48,770
És bár egy kicsit rejtélyesen, -1
negatív egész szám, mint az várható volt.

478
00:23:48,770 --> 00:23:52,020
>> És akkor a gyermek kilépni
állapota 0 GDBserver kilépés.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, a neve
Az alapul szolgáló szoftver

480
00:23:55,180 --> 00:23:56,620
megvalósító debugger.

481
00:23:56,620 --> 00:24:00,500
De mindez valójában azt jelenti, a hibakereső
ment el, mert a programot kilép

482
00:24:00,500 --> 00:24:01,710
és minden rendben volt.

483
00:24:01,710 --> 00:24:06,020
Ha szeretné, hogy valóban hibakeresést a programot,
Azt kell mondani preemptively debug50,

484
00:24:06,020 --> 00:24:08,920
ahol akarok kezdeni
átlépett a kód?

485
00:24:08,920 --> 00:24:11,750
>> És talán a legegyszerűbb módja
erre a következő.

486
00:24:11,750 --> 00:24:15,300
Ha az egérmutatót a
ereszcsatorna én szerkesztő itt,

487
00:24:15,300 --> 00:24:19,090
így tényleg csak az oldalsávon itt,
balra a sor számát,

488
00:24:19,090 --> 00:24:21,870
Figyeljük meg, hogy ha én csak kattintson
Egyszer tettem egy kis piros pont.

489
00:24:21,870 --> 00:24:24,460
És az a kis piros pont,
mint egy stoptábla, azt jelenti, hé,

490
00:24:24,460 --> 00:24:29,430
debug50, szünet végrehajtását kódomat
ott, amikor elindul a program.

491
00:24:29,430 --> 00:24:30,260
>> Tehát lássuk, hogy.

492
00:24:30,260 --> 00:24:37,340
Hadd menjen előre, és futtassa a programot
ismét debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
És most, értesítést, valami
különböző történt.

494
00:24:40,110 --> 00:24:42,440
Én nem kéri
még az én terminál ablakban

495
00:24:42,440 --> 00:24:45,430
semmit, mert nincs
ütött ott még a programot.

496
00:24:45,430 --> 00:24:47,950
Figyeljük meg, hogy a 8-as vonal
amely most kiemelt,

497
00:24:47,950 --> 00:24:51,720
és van egy kis nyíl
bal mondás, akkor megállt itt.

498
00:24:51,720 --> 00:24:55,030
Ezt a kódsort, vonal
8, még nem teljesített.

499
00:24:55,030 --> 00:24:58,940
>> És mi furcsa, ha nézek
itt a jobb oldali,

500
00:24:58,940 --> 00:25:03,530
észre, hogy én egy helyi
változó, a helyi abban az értelemben,

501
00:25:03,530 --> 00:25:05,450
hogy van benne az aktuális funkciót.

502
00:25:05,450 --> 00:25:08,920
És annak értékét, látszólag alapértelmezés szerint
és valami kényelmes, 0.

503
00:25:08,920 --> 00:25:10,260
De nem írja 0.

504
00:25:10,260 --> 00:25:13,410
Ez most történik, hogy a
alapértelmezett értéke abban a pillanatban.

505
00:25:13,410 --> 00:25:15,490
>> Tehát hadd menjen előre, és ezt most.

506
00:25:15,490 --> 00:25:18,680
Hadd menjek előre, és a
A jobb felső sarokban van, én

507
00:25:18,680 --> 00:25:20,970
fog menni előre, és
kattintson az első ikonra

508
00:25:20,970 --> 00:25:25,360
olyan lépés alatt, ami azt jelenti, hogy ne hagyd
ez azonban átlépik ezt a kódsort,

509
00:25:25,360 --> 00:25:27,770
futtatása az út mentén.

510
00:25:27,770 --> 00:25:30,710
>> És most, észre, én
prompt nemrég megváltozott.

511
00:25:30,710 --> 00:25:31,380
Miert van az?

512
00:25:31,380 --> 00:25:33,639
Megmondtam debug50,
futtatni ezt a kódsort.

513
00:25:33,639 --> 00:25:34,930
Mit jelent ez a kódsort csinálni?

514
00:25:34,930 --> 00:25:35,960
Késztet egy int.

515
00:25:35,960 --> 00:25:36,460
RENDBEN.

516
00:25:36,460 --> 00:25:37,400
Hadd együttműködnek.

517
00:25:37,400 --> 00:25:41,340
Hadd menjen előre, és most írja -1, Enter.

518
00:25:41,340 --> 00:25:42,920
És most észre, hogy mi változott.

519
00:25:42,920 --> 00:25:46,060
A jobb oldali,
a helyi változó i

520
00:25:46,060 --> 00:25:48,200
jelzi, hogy a -1 most.

521
00:25:48,200 --> 00:25:49,810
És ez még mindig int típusú.

522
00:25:49,810 --> 00:25:53,102
>> És értesítést is, én úgynevezett
hívja verem, hol én szünetet?

523
00:25:53,102 --> 00:25:54,810
Majd még beszélni
ez a jövőben.

524
00:25:54,810 --> 00:25:58,620
De a hívási verem csak arra vonatkozik, amit
funkciók jelenleg mozgásban.

525
00:25:58,620 --> 00:26:00,040
Most ez csak a fő.

526
00:26:00,040 --> 00:26:03,590
És most az egyetlen helyi
változó i-1 értéket.

527
00:26:03,590 --> 00:26:09,840
>> És amikor végre átlépni ezt a sort
itt, hogy ugyanaz az ikon a jobb felső sarokban,

528
00:26:09,840 --> 00:26:11,410
-1 Negatív egész szám.

529
00:26:11,410 --> 00:26:13,580
Most ez szüneteltetése alatt, hogy zárójel.

530
00:26:13,580 --> 00:26:14,740
Hagyjuk meg ezt a dolgot.

531
00:26:14,740 --> 00:26:17,300
Lépek a sor végén, és íme.

532
00:26:17,300 --> 00:26:20,240
>> Tehát egyáltalán nem olyan rettenetesen
felvilágosító még,

533
00:26:20,240 --> 00:26:23,550
de ez nem hadd szünet
és gondolja végig logikusan

534
00:26:23,550 --> 00:26:24,870
mi ez a program csinál.

535
00:26:24,870 --> 00:26:26,890
De nem ez volt a hibás helyzet.

536
00:26:26,890 --> 00:26:28,510
Csináljuk újra a következő.

537
00:26:28,510 --> 00:26:31,340
>> Megyek, hogy hagyja, hogy a töréspont
8. sor a piros pont.

538
00:26:31,340 --> 00:26:32,830
Megyek futtassa debug50.

539
00:26:32,830 --> 00:26:34,400
Ez automatikusan szünetel itt.

540
00:26:34,400 --> 00:26:37,660
De ez alkalommal, ahelyett,
átlépve ezt a sort,

541
00:26:37,660 --> 00:26:42,290
hadd valójában bemenni a
get_negative_int és kitalálni,

542
00:26:42,290 --> 00:26:45,530
miért van az elfogadó 0 érvényes válasz?

543
00:26:45,530 --> 00:26:47,990
>> Tehát ahelyett, hogy rákattint Step Over.

544
00:26:47,990 --> 00:26:50,630
Megyek, hogy menjen előre
és kattintson Step Into.

545
00:26:50,630 --> 00:26:54,030
Azt tapasztaljuk, hogy a 8-as vonal, ami
most kiemelt most hirtelen

546
00:26:54,030 --> 00:26:56,900
válik a 17. sorban.

547
00:26:56,900 --> 00:26:59,947
>> Most, hogy ez nem az a debugger
már kimarad vonalak a 14 és a 15 és 16.

548
00:26:59,947 --> 00:27:01,780
Ez csak semmi
hogy mutassa meg ott.

549
00:27:01,780 --> 00:27:04,050
Ezek csak nyilvánító változók,
és akkor ott van a szó Do

550
00:27:04,050 --> 00:27:05,390
majd egy nyitott zárójel.

551
00:27:05,390 --> 00:27:09,227
Az egyetlen funkcionális sor, ami
lédús tényleg ez itt, 17.

552
00:27:09,227 --> 00:27:11,060
És ez az, ahol voltunk
szünetel automatikusan.

553
00:27:11,060 --> 00:27:13,870
>> Tehát printf ( "n.is:") ;, így
hogy még nem történt meg.

554
00:27:13,870 --> 00:27:18,250
Szóval menjünk előre, és kattintson átlépni.

555
00:27:18,250 --> 00:27:20,326
Most a gyors, sőt,
változott ( "n").

556
00:27:20,326 --> 00:27:22,450
Most get_int, nem megyek
zavarni lépve,

557
00:27:22,450 --> 00:27:24,750
mert a függvény volt
által CS50 a Könyvtárban.

558
00:27:24,750 --> 00:27:25,750
Ez feltehetően helyes.

559
00:27:25,750 --> 00:27:28,440
>> Így fogok menni előre, és
egyfajta együttműködést azáltal, hogy

560
00:27:28,440 --> 00:27:30,590
int, de nem negatív int.

561
00:27:30,590 --> 00:27:32,870
Tehát hadd menjen előre, és nyomja le a 0.

562
00:27:32,870 --> 00:27:39,460
És most mi történik itt
ha kapok le a sorban a 21.?

563
00:27:39,460 --> 00:27:40,890
Már nem iterált újra.

564
00:27:40,890 --> 00:27:43,320
Úgy tűnik, nem kell ragasztani, hogy hurok.

565
00:27:43,320 --> 00:27:45,990
Más szavakkal, ez a sárga
bár nem folyamatosan megy körbe,

566
00:27:45,990 --> 00:27:47,130
és környékén, és fordítva.

567
00:27:47,130 --> 00:27:48,340
>> Nos, miért van ez?

568
00:27:48,340 --> 00:27:49,920
Nos, n, mi n most?

569
00:27:49,920 --> 00:27:53,280
Azt nézd meg a helyi
változók a debugger.

570
00:27:53,280 --> 00:27:53,816
n értéke 0.

571
00:27:53,816 --> 00:27:55,190
Rendben, mi volt az állapotom?

572
00:27:55,190 --> 00:27:58,700
>> 20-- 20 sor, nos,
0 nagyobb, mint 0.

573
00:27:58,700 --> 00:27:59,500
Ez nem igaz.

574
00:27:59,500 --> 00:28:01,020
0 nem nagyobb, mint 0.

575
00:28:01,020 --> 00:28:02,820
És így tört ki ebből.

576
00:28:02,820 --> 00:28:06,370
>> És ez az, amiért online
21, ha tényleg folytatni,

577
00:28:06,370 --> 00:28:10,370
Megyek return 0, még
bár kellett volna utasítani 0

578
00:28:10,370 --> 00:28:12,484
mivel valójában nem lehet negatív.

579
00:28:12,484 --> 00:28:14,650
Tehát most, én nem is igazán
törődnek a debugger.

580
00:28:14,650 --> 00:28:16,900
Értem, nem kell
tudja, mi több folyik.

581
00:28:16,900 --> 00:28:19,233
>> Így fogok menni előre, és
Csak kattintson a Lejátszás gombra,

582
00:28:19,233 --> 00:28:20,240
és hagyja, hogy ezt befejezni.

583
00:28:20,240 --> 00:28:23,440
Most rájöttem, hogy az én
hiba látszólag on line 20.

584
00:28:23,440 --> 00:28:25,160
Ez az én logikai hiba.

585
00:28:25,160 --> 00:28:28,100
>> És így mit akarok
tenni, hogy ez megváltozzon?

586
00:28:28,100 --> 00:28:32,500
Ha a probléma az, hogy nem vagyok
fogása 0, ez csak egy logikai hiba.

587
00:28:32,500 --> 00:28:35,910
És azt lehet mondani, míg n
nagyobb vagy egyenlő 0,

588
00:28:35,910 --> 00:28:38,330
tartsa a felhasználó megkérdezése újra és újra.

589
00:28:38,330 --> 00:28:41,050
>> Szóval, megint egyszerű hiba, talán
még nyilvánvaló, amikor meglátott

590
00:28:41,050 --> 00:28:42,410
írd csak néhány perce.

591
00:28:42,410 --> 00:28:44,570
De az elvihető itt
az, hogy a hibakeresési 50,

592
00:28:44,570 --> 00:28:46,850
és hibakeresés
szoftverek általában

593
00:28:46,850 --> 00:28:51,370
Van ez az új hatalom talált
séta a saját kódját, nézd

594
00:28:51,370 --> 00:28:55,590
keresztül, hogy a jobb oldali panelen, amit
A változók értékei.

595
00:28:55,590 --> 00:28:57,700
Szóval nem feltétlenül
kell használni valamit

596
00:28:57,700 --> 00:29:00,630
mint te eprintf nyomtatni ezeket az értékeket.

597
00:29:00,630 --> 00:29:04,430
Akkor valóban látni őket
vizuálisan a képernyőn.

598
00:29:04,430 --> 00:29:08,920
>> Most, ezen túl, érdemes megjegyezni,
hogy van egy másik módszer, ami

599
00:29:08,920 --> 00:29:09,890
valóban szuper gyakori.

600
00:29:09,890 --> 00:29:13,120
És akkor felmerül a kérdés, hogy miért ez a kis
fickó már ül a színpadon.

601
00:29:13,120 --> 00:29:16,490
Tehát itt van ez a technika, általában
néven gumi kacsa hibakeresés,

602
00:29:16,490 --> 00:29:18,786
amely valójában csak egy
tanúskodik, hogy az a tény,

603
00:29:18,786 --> 00:29:20,660
hogy gyakran, amikor a programozók
írunk kódot,

604
00:29:20,660 --> 00:29:22,650
ők nem feltétlenül
másokkal együttműködik,

605
00:29:22,650 --> 00:29:24,030
vagy dolgozik egy közös környezetben.

606
00:29:24,030 --> 00:29:25,050
>> Ők egyfajta otthon.

607
00:29:25,050 --> 00:29:25,910
Lehet, hogy késő este.

608
00:29:25,910 --> 00:29:28,190
Megpróbálnak alak
néhány hiba a saját kódját.

609
00:29:28,190 --> 00:29:29,330
És ők csak nem látta azt.

610
00:29:29,330 --> 00:29:30,329
>> És nincs szobatársam.

611
00:29:30,329 --> 00:29:31,250
Nincs TF.

612
00:29:31,250 --> 00:29:32,680
Nincs CA körül.

613
00:29:32,680 --> 00:29:36,440
Minden ezek a termékek megfelelő eltarthatósági
ez a kis gumi aranyom.

614
00:29:36,440 --> 00:29:39,030
>> És így gumi kacsa hibakeresés
csak ezt a meghívást

615
00:29:39,030 --> 00:29:42,780
gondolni valami buta
mivel ez, mint egy igazi lény,

616
00:29:42,780 --> 00:29:46,940
és valóban séta a kódot
szóban erre élettelen tárgyat.

617
00:29:46,940 --> 00:29:49,230
Így például, ha
ez az én példa here--

618
00:29:49,230 --> 00:29:52,470
és emlékszem, hogy korábban
A probléma az volt, ezt,

619
00:29:52,470 --> 00:29:58,140
ha törlöm az első kódsor
és megyek előre, és a buggy ismét 0

620
00:29:58,140 --> 00:30:01,220
Emlékeztetünk arra, hogy volt ilyen
hibaüzenetek itt.

621
00:30:01,220 --> 00:30:05,997
Tehát az ötlet, nevetséges bár
úgy érzi, ebben a pillanatban ezt nyilvánosan,

622
00:30:05,997 --> 00:30:06,580
hogy hiba.

623
00:30:06,580 --> 00:30:10,910
>> OK, így a probléma az, hogy én már
hallgatólagosan nyilvánították könyvtári függvény.

624
00:30:10,910 --> 00:30:12,610
És, hogy a könyvtári funkció printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, állapítsa
emlékeztet a prototípusok.

626
00:30:15,290 --> 00:30:18,930
>> Ez azt jelenti, kell, hogy ténylegesen
mondja a fordító előre, hogy milyen

627
00:30:18,930 --> 00:30:19,980
A függvény így néz ki.

628
00:30:19,980 --> 00:30:20,930
Várj egy percet.

629
00:30:20,930 --> 00:30:23,580
Nem szabványos io.h.

630
00:30:23,580 --> 00:30:24,530
Nagyon szépen köszönjük.

631
00:30:24,530 --> 00:30:27,330
>> Tehát csak ez a folyamat of-- te
Nem kell, hogy ténylegesen van egy kacsa.

632
00:30:27,330 --> 00:30:29,819
De ez az ötlet, séta
Ön is saját kódját

633
00:30:29,819 --> 00:30:31,610
úgy, hogy még hallani
magad, úgy, hogy

634
00:30:31,610 --> 00:30:35,620
megvalósítani kihagyások saját
megjegyzések, általában az ötlet.

635
00:30:35,620 --> 00:30:38,910
>> És ami talán még értelemszerűen nem annyira
sokat, hogy az egyik, de a nagyobb részt

636
00:30:38,910 --> 00:30:44,220
Például mi csak tette buggy 3.c,
lehet járni magad rajta

637
00:30:44,220 --> 00:30:45,310
alábbiak szerint.

638
00:30:45,310 --> 00:30:49,190
Tehát minden rendben, gumi
aranyom, DDB, ha úgy tetszik.

639
00:30:49,190 --> 00:30:52,350
Itt van az én fő funkciója,
Hívom kap negatív int.

640
00:30:52,350 --> 00:30:54,660
>> És kapok a visszatérési érték.

641
00:30:54,660 --> 00:31:00,410
Én tárol a bal oldali
8. sor a változó az i.

642
00:31:00,410 --> 00:31:02,380
OK, de várj, hogyan sikerült
kap, hogy ezt az értéket?

643
00:31:02,380 --> 00:31:04,130
Hadd nézzem meg a függvény 12-es vonal.

644
00:31:04,130 --> 00:31:05,760
>> Összhangban 12, már kap negatív int.

645
00:31:05,760 --> 00:31:08,190
Nem vállal bemenet,
nem tér vissza int, OK.

646
00:31:08,190 --> 00:31:10,929
Kijelentem on line 14 változó n.

647
00:31:10,929 --> 00:31:12,220
Meg fog tárolni egy egész szám.

648
00:31:12,220 --> 00:31:13,760
Ez az amit akarok.

649
00:31:13,760 --> 00:31:18,480
>> Tehát nem a következő, míg n is-- hagyja
nekem visszavonni, amit a fix én már.

650
00:31:18,480 --> 00:31:22,710
Tehát míg n nagyobb, mint
0, kinyomtatni n van, az OK gombra.

651
00:31:22,710 --> 00:31:25,170
Majd hívja kap int tárolt n.

652
00:31:25,170 --> 00:31:30,160
És akkor ellenőrizze, ha n értéke 0,
n nem-- ez van.

653
00:31:30,160 --> 00:31:31,910
Szóval, megint, akkor nem
szükség a tényleges kacsa.

654
00:31:31,910 --> 00:31:35,650
De csak séta ki magad
A kód szellemi gyakorlatként

655
00:31:35,650 --> 00:31:37,720
Gyakran segít
észre, mi folyik itt,

656
00:31:37,720 --> 00:31:41,170
szemben a csak csinál valamit
mint ez, bámulja a képernyőt,

657
00:31:41,170 --> 00:31:43,720
és nem beszél ki magad
azt, ami őszintén nem

658
00:31:43,720 --> 00:31:46,270
majdnem olyan hatásos technika.

659
00:31:46,270 --> 00:31:48,620
Így van ez, a
Számos különböző technikák

660
00:31:48,620 --> 00:31:52,102
a tényleges hibakeresés a kódot
és találni hibát, amelyek mindegyike

661
00:31:52,102 --> 00:31:54,810
kell az eszközöket a eszközkészlet
így, hogy te nem késő este,

662
00:31:54,810 --> 00:31:57,660
különösen, te vagy az étkező
csarnokok, vagy munkaidőn,

663
00:31:57,660 --> 00:32:00,368
dörömböl a fejét a
fal, próbálják megoldani a problémát.

664
00:32:00,368 --> 00:32:02,020
Ismerd fel, hogy vannak olyan szoftverek.

665
00:32:02,020 --> 00:32:03,720
Vannak gumi kacsa eszközöket.

666
00:32:03,720 --> 00:32:09,630
És van egy egész személyzete
támogatja vár, hogy megadja a kezét.

667
00:32:09,630 --> 00:32:13,120
>> Tehát most, egy szó a probléma
készletek, és amit mi abban a reményben,

668
00:32:13,120 --> 00:32:15,620
kap ki őket, és hogyan
megyünk kiértékeléséhez.

669
00:32:15,620 --> 00:32:17,680
Per a tanfolyam tananyag,
CS50 probléma készletek

670
00:32:17,680 --> 00:32:22,320
értékelik négy elsődleges tengely, így
a speak-- körét, korrektség, tervezés,

671
00:32:22,320 --> 00:32:23,060
és a stílus.

672
00:32:23,060 --> 00:32:25,910
És hatálya csak arra vonatkozik, hogy mennyi
A darab már akkor harapta le?

673
00:32:25,910 --> 00:32:28,080
Mekkora problémát próbálta már?

674
00:32:28,080 --> 00:32:30,110
Milyen szintű erőfeszítéseket
már akkor nyilvánul?

675
00:32:30,110 --> 00:32:35,750
>> Helyesség, nem az a program működik, mint
ez állítólag egy CS50 specifikáció

676
00:32:35,750 --> 00:32:38,640
ha megadja az egyes bemenetek
vagy bizonyos kimenetek jön vissza?

677
00:32:38,640 --> 00:32:41,130
Design a szubjektív őket.

678
00:32:41,130 --> 00:32:43,360
És ez az egyik, hogy
a leghosszabb tanulni

679
00:32:43,360 --> 00:32:47,220
és a leghosszabb tanítani, a
amennyiben ez csapódik le,

680
00:32:47,220 --> 00:32:49,530
milyen jól leírtam a kódot?

681
00:32:49,530 --> 00:32:52,920
>> Ez az egyik dolog, hogy csak nyomtatni a megfelelő
kimenetek, vagy vissza a megfelelő értékeket.

682
00:32:52,920 --> 00:32:55,400
De csinálod, mint
lehető leghatékonyabban?

683
00:32:55,400 --> 00:32:58,210
Csinálod szakadék
és uralkodj, vagy bináris

684
00:32:58,210 --> 00:33:01,500
keresés ahogy hamarosan látni, hogy mi
Két héttel ezelőtt a telefonkönyv?

685
00:33:01,500 --> 00:33:04,670
Van jobb mód, hogy megoldja a
probléma, mint jelenleg van itt?

686
00:33:04,670 --> 00:33:06,380
Ez lehetőséget a jobb design.

687
00:33:06,380 --> 00:33:08,530
>> És akkor hogyan style--
szép az a kód?

688
00:33:08,530 --> 00:33:12,370
Észre fogod venni, hogy én vagyok elég
különösen arról beljebb a kód,

689
00:33:12,370 --> 00:33:15,300
és gondoskodjanak arról, én változók
ésszerűen elemzi. N,

690
00:33:15,300 --> 00:33:19,660
míg a rövid, egy jó név egy
szám, én egy számláló értéke,

691
00:33:19,660 --> 00:33:20,727
s egy húr.

692
00:33:20,727 --> 00:33:22,560
És mi lehet hosszabb
változó nevek stílusban.

693
00:33:22,560 --> 00:33:25,500
A stílus, hogy milyen jó
nak a kódot néz?

694
00:33:25,500 --> 00:33:26,600
És hogyan olvasható ez?

695
00:33:26,600 --> 00:33:29,650
>> És idővel, amit a TA
és TF fog tenni a tanfolyam

696
00:33:29,650 --> 00:33:31,870
van az Ön számára, hogy
fajta minőségi visszajelzést

697
00:33:31,870 --> 00:33:34,330
úgy, hogy jobban
azokon különböző aspektusait.

698
00:33:34,330 --> 00:33:37,510
És tekintve, hogy mi
értékeli mindegyik tengelyen

699
00:33:37,510 --> 00:33:40,080
ez általában nagyon kevés
vödrök, így általában

700
00:33:40,080 --> 00:33:41,680
hogy egyfajta milyen jól csinálsz.

701
00:33:41,680 --> 00:33:45,680
És valóban, ha kap egy pontszámot
bármely olyan axes-- helyességét, design

702
00:33:45,680 --> 00:33:49,659
és stílus especially-- ezt a számot
általában 1 és 5 között.

703
00:33:49,659 --> 00:33:52,450
És szó szerint, ha kapok
3-as elején a félév,

704
00:33:52,450 --> 00:33:53,977
ez egy nagyon jó dolog.

705
00:33:53,977 --> 00:33:55,810
Ez azt jelenti, hogy még mindig
javítani,

706
00:33:55,810 --> 00:33:58,490
amely akkor remény a
vesz egy osztály az első alkalommal.

707
00:33:58,490 --> 00:34:01,820
Van remélhetőleg néhány kis mennyezeti
amelyhez te törekvő elérése.

708
00:34:01,820 --> 00:34:03,970
És így egyre 3-ek
A legkorábbi darabok,

709
00:34:03,970 --> 00:34:06,550
ha nem egy 2-es és 4-es,
Valóban, egy jó dolog.

710
00:34:06,550 --> 00:34:08,880
Ez jól tartományon belül,
valamint a várakozásokat.

711
00:34:08,880 --> 00:34:11,421
>> És ha az elméd a versenyzés, várjon
Egy perc, ötből három.

712
00:34:11,421 --> 00:34:12,620
Ez tényleg egy 10-ből 6.

713
00:34:12,620 --> 00:34:13,560
Ez 60% -os.

714
00:34:13,560 --> 00:34:14,830
Istenem, ez egy F.

715
00:34:14,830 --> 00:34:15,870
>> Ez nem.

716
00:34:15,870 --> 00:34:17,600
Nem, sőt, hogy.

717
00:34:17,600 --> 00:34:22,710
Inkább ez egy lehetőség, hogy javítsa
során a félév.

718
00:34:22,710 --> 00:34:25,580
És ha kapok néhány
Poors, ezek lehetőséget

719
00:34:25,580 --> 00:34:29,199
kihasználni munkaidejében
biztosan szakaszok és egyéb források.

720
00:34:29,199 --> 00:34:32,840
>> A legjobb egy olyan lehetőség, tényleg,
büszke lehet csak, hogy épp

721
00:34:32,840 --> 00:34:34,520
jöjjön során a félév.

722
00:34:34,520 --> 00:34:38,199
Tehát ezt észre, ha semmi
mást, három jó.

723
00:34:38,199 --> 00:34:40,179
És ez lehetővé teszi szobában a növekedés idővel.

724
00:34:40,179 --> 00:34:43,090
>> Ami hogyan kell e tengelyek
súlyozott, reálisan te

725
00:34:43,090 --> 00:34:46,745
fogja tölteni a legtöbb időt kapok
dolgokat munka, nemhogy helyesen.

726
00:34:46,745 --> 00:34:49,120
És így helyességét hajlamos
súlyozzák a leginkább, mint a

727
00:34:49,120 --> 00:34:51,360
ez multiplikatív háromszoros.

728
00:34:51,360 --> 00:34:54,659
Design is fontos, de
valami, amit nem feltétlenül

729
00:34:54,659 --> 00:34:58,220
tölteni az összes ilyen órát
megpróbál a dolgok csak a munka.

730
00:34:58,220 --> 00:35:00,019
>> És ez így van súlyozva
egy kicsit könnyedebb.

731
00:35:00,019 --> 00:35:01,560
És akkor stílus súlyozott legkisebb.

732
00:35:01,560 --> 00:35:03,710
Annak ellenére, hogy ez nem kevésbé
Fontos alapvetően,

733
00:35:03,710 --> 00:35:05,990
ez csak talán, a
legegyszerűbb dolog jobb,

734
00:35:05,990 --> 00:35:08,440
utánozva a példák
itt előadás és részben

735
00:35:08,440 --> 00:35:11,080
A dolgok szépen
tagolt, és megjegyezte,

736
00:35:11,080 --> 00:35:14,320
és így tovább az egyik legegyszerűbb
dolgom, és rögtön.

737
00:35:14,320 --> 00:35:16,960
Tehát mint ilyen, észre
hogy ezek pont

738
00:35:16,960 --> 00:35:19,000
amelyek viszonylag könnyen megfogható.

739
00:35:19,000 --> 00:35:22,360
>> És most egy szót
this-- akadémiai őszinteség.

740
00:35:22,360 --> 00:35:25,150
Tehát egy a pálya
tananyag, látni fogja

741
00:35:25,150 --> 00:35:27,630
hogy a tanfolyam már elég
kis nyelv körül ez.

742
00:35:27,630 --> 00:35:31,380
És persze komolyan veszi az
akadémiai őszinteség elég komolyan.

743
00:35:31,380 --> 00:35:33,450
>> Megvan a különbséget,
jobb vagy rosszabb,

744
00:35:33,450 --> 00:35:36,570
A elküldvén évente több
hallgatók fegyelmi eljárást

745
00:35:36,570 --> 00:35:39,670
mint a legtöbb más
Persze, hogy én vagyok tisztában.

746
00:35:39,670 --> 00:35:42,580
Ez nem feltétlenül
utal az a tény,

747
00:35:42,580 --> 00:35:46,340
hogy a CS diákok, illetve CS50 diákok, amelyek
kevésbé őszinte, mint az osztálytársai.

748
00:35:46,340 --> 00:35:49,090
A valóság azonban az, hogy ebben a
világ, elektronikus úton, mi csak

749
00:35:49,090 --> 00:35:50,990
van technológiai
eszközök felismerésére.

750
00:35:50,990 --> 00:35:53,360
>> Fontos, hogy velünk
méltányosság az egész osztály

751
00:35:53,360 --> 00:35:58,550
hogy mi ezt észre, és emelje
A kérdés, ha látjuk a dolgokat.

752
00:35:58,550 --> 00:36:01,980
És csak festeni egy képet, és tényleg
hogy segítsen valami ehhez hasonló mosogató,

753
00:36:01,980 --> 00:36:04,600
Ezek a számok a
diákok az elmúlt 10 évben

754
00:36:04,600 --> 00:36:07,610
hogy részt vettek valamilyen
ilyen kérdések akadémiai őszinteség,

755
00:36:07,610 --> 00:36:10,990
A mintegy 32 diák
ősztől 2015, ami

756
00:36:10,990 --> 00:36:13,760
azt jelenti, hogy mi fog
az ügyet nagyon komolyan.

757
00:36:13,760 --> 00:36:18,380
És végül, ezek a számok össze,
Legutóbb, mintegy 3%, 4%, vagy úgy

758
00:36:18,380 --> 00:36:19,120
az osztály.

759
00:36:19,120 --> 00:36:25,220
>> Így a szuper hallgatók többsége
úgy tűnik, hogy a vonalak világos.

760
00:36:25,220 --> 00:36:27,940
De ezt tartsd
Mindegy, különösen későn

761
00:36:27,940 --> 00:36:32,080
éjszaka, amikor küzd
néhány megoldást a problémára sor,

762
00:36:32,080 --> 00:36:34,830
hogy vannak mechanizmusok
szerzés magát jobban

763
00:36:34,830 --> 00:36:37,870
támogatást, mint ti
úgy gondolja, még abban az órában.

764
00:36:37,870 --> 00:36:40,514
Ismerd fel, hogy amikor megkapjuk
hallgató beadványát, átkelünk

765
00:36:40,514 --> 00:36:43,430
össze minden beküldött idén
ellen minden beküldött tavaly,

766
00:36:43,430 --> 00:36:47,590
ellen minden beadvány 2007
és mivel, nézi, valamint,

767
00:36:47,590 --> 00:36:49,931
kódtáraihoz online
vitafórumok, munka oldalak.

768
00:36:49,931 --> 00:36:51,806
És mi említem ezt,
tényleg, az összes kedvéért

769
00:36:51,806 --> 00:36:56,040
A teljes körű tájékoztatás, hogy ha
valaki megtalálja az interneten,

770
00:36:56,040 --> 00:36:57,880
természetesen, így lehet azt a tanfolyamot.

771
00:36:57,880 --> 00:37:00,100
De tényleg, a szellem
A kurzus csapódik le

772
00:37:00,100 --> 00:37:01,650
e záradék a tananyag.

773
00:37:01,650 --> 00:37:03,670
Ez tényleg csak, ésszerűnek.

774
00:37:03,670 --> 00:37:06,680
>> És ha lenne, hogy dolgozza ki, hogy
csak egy kicsit több nyelven,

775
00:37:06,680 --> 00:37:09,770
észre, hogy a lényege az összes
munka, hogy nyújtson be a tanfolyamra

776
00:37:09,770 --> 00:37:10,954
kell lennie a saját.

777
00:37:10,954 --> 00:37:13,870
De ezen belül is vannak természetesen
lehetőségeket, és bátorítást,

778
00:37:13,870 --> 00:37:17,300
és pedagógiai érték fordul
others-- magam, a TF, a CA,

779
00:37:17,300 --> 00:37:20,760
a TA, és mások az osztályban,
támogatásra, nemhogy barátok

780
00:37:20,760 --> 00:37:23,547
és a szobatársak, akik tanulmányozták
CS és a programozás előtt.

781
00:37:23,547 --> 00:37:25,130
És így van egy ráhagyás ezt.

782
00:37:25,130 --> 00:37:28,180
És az általános ökölszabály
A this-- ha segítséget kérsz,

783
00:37:28,180 --> 00:37:31,470
akkor mutatják be a kódot, hogy mások,
de lehet, hogy nem tekintheti az övék.

784
00:37:31,470 --> 00:37:34,880
Tehát akkor is, ha a munkaidejében
vagy a D csarnokban, vagy valahol máshol

785
00:37:34,880 --> 00:37:37,450
dolgozunk néhány darabos készlet,
dolgozik együtt egy barát, ami

786
00:37:37,450 --> 00:37:40,160
teljesen rendben van, a
A nap végén a munka

787
00:37:40,160 --> 00:37:43,034
végső soron tartozó minden
Az Ön esetében, és nem

788
00:37:43,034 --> 00:37:45,700
néhány közös munka
kivéve az utolsó projekt, ahol

789
00:37:45,700 --> 00:37:47,410
ez megengedett és bátorított.

790
00:37:47,410 --> 00:37:49,830
>> Ismerd fel, hogy ha
küzd valami

791
00:37:49,830 --> 00:37:52,520
és a barátja épp,
hogy jobban megy, akkor,

792
00:37:52,520 --> 00:37:55,130
vagy jobb, hogy a probléma, mint te,
vagy egy kicsit előrébb, mint te,

793
00:37:55,130 --> 00:37:57,330
ez teljesen ésszerű, hogy kapcsolja
hogy a barátja, és azt mondják, hé,

794
00:37:57,330 --> 00:38:00,480
Nem bánja, néztem a kódot ide,
segített észrevenni, mi a probléma?

795
00:38:00,480 --> 00:38:03,760
És remélhetőleg a
érdeke pedagógiai értékkel

796
00:38:03,760 --> 00:38:07,040
a barát nem csak
mondjuk, ó, erre, hanem,

797
00:38:07,040 --> 00:38:09,917
mit hiányzik on-line
6, vagy valami ilyesmi?

798
00:38:09,917 --> 00:38:12,000
De a megoldás nem
A barát melletted

799
00:38:12,000 --> 00:38:15,617
mondani, ó, nos, itt, hadd vessem
ezt fel, és jelenjen meg a megoldást az Ön számára.

800
00:38:15,617 --> 00:38:16,450
Tehát ez a vonal.

801
00:38:16,450 --> 00:38:18,670
Mutassa kódot
mások, de nem lehet

802
00:38:18,670 --> 00:38:22,350
megtekintheti az övék, feltéve, hogy a többi
megszorítások során a tananyag.

803
00:38:22,350 --> 00:38:24,760
>> Tehát ne feledje, ez a
úgynevezett sajnálom záradék

804
00:38:24,760 --> 00:38:27,560
során a tananyag is,
hogy ha elkövetni néhány cselekmény

805
00:38:27,560 --> 00:38:30,476
nem ésszerű, hanem hogy azt
a figyelmet a pálya fejek

806
00:38:30,476 --> 00:38:34,240
72 órán belül, a természetesen
szabhat helyi szankciókat

807
00:38:34,240 --> 00:38:37,380
tartalmazhat egy kielégítő, vagy
elégtelen osztályzatot a beadott munkát.

808
00:38:37,380 --> 00:38:41,410
De a tanfolyam nem utalja
számít a további fegyelmi eljárás

809
00:38:41,410 --> 00:38:43,010
eseteket kivéve ismétlődő cselekmények.

810
00:38:43,010 --> 00:38:46,632
Más szóval, ha nem, hogy néhány
buta, különösen a késő éjszakai, döntés

811
00:38:46,632 --> 00:38:49,340
hogy a következő reggel vagy két nap
Később, felébredsz, és rájönnek,

812
00:38:49,340 --> 00:38:50,870
mit gondoltam?

813
00:38:50,870 --> 00:38:53,890
Ön itt van CS50 aljzathoz
rögzítésére, hogy a probléma

814
00:38:53,890 --> 00:38:57,170
és a tulajdonos akár azt, hogy mi
találkozunk félúton, és foglalkozik

815
00:38:57,170 --> 00:39:01,500
vele egy ügyben, amely egyszerre
oktatási és értékes az Ön számára,

816
00:39:01,500 --> 00:39:04,200
de még mindig büntető valamilyen módon.

817
00:39:04,200 --> 00:39:08,590
És most, hogy a szélén le, ezt.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO LEJÁTSZÁS]

819
00:39:10,570 --> 00:39:13,540
>> [ZENE]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END LEJÁTSZÁS]

822
00:39:58,866 --> 00:40:00,490
David J. MALAN: Rendben, vissza.

823
00:40:00,490 --> 00:40:03,680
És most nézzük az egyik
először a valódi világ domainek

824
00:40:03,680 --> 00:40:08,720
a CS50, a művészet a kriptográfia,
A szakterületen küldésére és fogadására

825
00:40:08,720 --> 00:40:11,840
titkos üzeneteket, titkosított
üzenetet, ha úgy tetszik,

826
00:40:11,840 --> 00:40:17,060
hogy csak akkor értelmezhetőek, ha van
Néhány kulcsfontosságú összetevője, hogy a feladó

827
00:40:17,060 --> 00:40:18,030
is.

828
00:40:18,030 --> 00:40:22,120
Tehát, hogy motiválja ezt elvisszük
nézd meg ezt a dolgot itt,

829
00:40:22,120 --> 00:40:26,750
amely egy példa a
titkos dekóder gyűrűt

830
00:40:26,750 --> 00:40:34,042
lehet használni annak érdekében, hogy kitalálni
milyen titkos üzenetet valójában.

831
00:40:34,042 --> 00:40:35,750
Tény, hogy vissza a
nap az iskolában,

832
00:40:35,750 --> 00:40:38,787
ha valaha is küldött titkos üzeneteket
Néhány barát vagy egy összetörni az osztályban,

833
00:40:38,787 --> 00:40:40,620
Ön gondolta volna
te, hogy okos

834
00:40:40,620 --> 00:40:46,530
által a papírlapot változó,
mint például, a B, A és B a C, és a C-D,

835
00:40:46,530 --> 00:40:47,590
és így tovább.

836
00:40:47,590 --> 00:40:50,300
De valóban titkosítása
Tájékoztatásul közöljük, hogy még

837
00:40:50,300 --> 00:40:53,300
ha ez egy kicsit triviális, nem volt
hogy a kemény, hogy a tanár észre,

838
00:40:53,300 --> 00:40:55,675
Nos, ha csak változtatni
B-A és C-ből B,

839
00:40:55,675 --> 00:40:57,550
ténylegesen kitalálni
mi volt az üzenet,

840
00:40:57,550 --> 00:40:59,700
de volt rejtjelezés információkat.

841
00:40:59,700 --> 00:41:03,420
>> Te csak csinálja
Egyszerűen, ugyanúgy, mint Ralphie itt

842
00:41:03,420 --> 00:41:07,934
egy híres film, játszik
nagyjából csömörig minden télen.

843
00:41:07,934 --> 00:41:08,600
[VIDEO LEJÁTSZÁS]

844
00:41:08,600 --> 00:41:11,180
-be Azt mindenki által ismert, hogy a
Ralph Parker ezennel

845
00:41:11,180 --> 00:41:14,070
kinevezett tagja a Kis
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
és jogosult a kitüntetés
és előnyök előforduló hozzá.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
counter aláírt Pierre Andre, tintával.

848
00:41:24,340 --> 00:41:27,160
Kitüntetések és előnyök,
Már kilenc évesen.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [KIABÁLÁS]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Gyerünk.

853
00:41:34,250 --> 00:41:35,210
Lássunk hozzá.

854
00:41:35,210 --> 00:41:39,530
Nem kell ez a jazz
körülbelül csempészek és kalózok.

855
00:41:39,530 --> 00:41:41,660
>> -Listen Holnap este
A záró kaland

856
00:41:41,660 --> 00:41:43,880
A fekete kalózhajó.

857
00:41:43,880 --> 00:41:46,650
Most, hogy itt az ideje
Annie titkos üzenete

858
00:41:46,650 --> 00:41:49,840
Önnek tagjai a titkos kör.

859
00:41:49,840 --> 00:41:53,570
Ne felejtsük el, a gyerekek, csak a tagok
Annie Secret Circle

860
00:41:53,570 --> 00:41:56,140
dekódolni tudja Annie titkos üzenetet.

861
00:41:56,140 --> 00:42:00,340
>> Ne felejtsük el, Annie függ.

862
00:42:00,340 --> 00:42:02,880
Állítsa be csap a B2.

863
00:42:02,880 --> 00:42:05,230
Itt van az üzenet.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -I Vagyok, az első titkos találkozón.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Volt nagy hangja ma este.

868
00:42:15,780 --> 00:42:19,000
Elmondhatom, hogy a ma esti
üzenet igazán fontos volt.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, ez egy üzenet
Annie magát.

870
00:42:22,694 --> 00:42:23,860
Emlékezz, ne mondd el senkinek.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Másodperccel később, én vagyok az egyetlen
szoba a házban, ahol egy fiú kilenc

873
00:42:32,930 --> 00:42:37,040
tudott ülni adatvédelmi és dekódolni.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Elmentem a következő, E.

876
00:42:42,360 --> 00:42:44,520
>> Az első szó lesz.

877
00:42:44,520 --> 00:42:49,032
S, hogy jön könnyebb most, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -Ó, Gyerünk, Ralphie, mennem kell!

879
00:42:51,733 --> 00:42:53,688
>> -I'll Lehet jobbra le, Ma!

880
00:42:53,688 --> 00:42:54,188
Ez zseniális!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, biztos az alábbiakra: biztos, hogy mit?

883
00:43:04,060 --> 00:43:05,970
Mi volt kis árva
Annie mondani?

884
00:43:05,970 --> 00:43:07,264
Ügyeljen arra, hogy mit?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy kapott, hogy
megy, kérem jöjjön ki?

886
00:43:09,634 --> 00:43:10,480
>> Rendben, Ma!

887
00:43:10,480 --> 00:43:12,880
Hamarosan ki!

888
00:43:12,880 --> 00:43:14,550
>> -I Egyre közelebb van.

889
00:43:14,550 --> 00:43:16,620
A feszültség szörnyű volt.

890
00:43:16,620 --> 00:43:17,720
Mi volt az?

891
00:43:17,720 --> 00:43:20,170
A sorsa a bolygó
lefagy az egyensúlyt.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy mennie kell!

894
00:43:23,170 --> 00:43:26,890
>> -I'll Hamarosan ki, az isten szerelmére!

895
00:43:26,890 --> 00:43:32,680
>> -Almost Ott, ujjaim repült, az elmém
volt egy acél csapda, minden pórus vibrált.

896
00:43:32,680 --> 00:43:37,198
Már majdnem tiszta, igen, igen, igen.

897
00:43:37,198 --> 00:43:43,091
>> -be Fogyasszon el Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
A ciki kereskedelmi?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
A kurva életbe.

903
00:43:54,227 --> 00:43:54,810
[END LEJÁTSZÁS]

904
00:43:54,810 --> 00:43:57,390
David J. MALAN: OK, így
ez egy nagyon hosszú út

905
00:43:57,390 --> 00:44:00,660
bevezetésének kriptográfia,
és Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Tény, hogy ebből a régi hirdetés
Itt miért Ovaltine olyan jó?

907
00:44:04,470 --> 00:44:09,470
Ez egy koncentrált extrakció érett
maláta, tiszta krémes tehéntej,

908
00:44:09,470 --> 00:44:14,360
és speciálisan előkészített kakaós, együtt
természetes foszfatidokat és vitaminok.

909
00:44:14,360 --> 00:44:18,240
Ez tovább dúsítva
további vitaminokat B és D yum.

910
00:44:18,240 --> 00:44:21,600
És akkor még mindig meg, úgy tűnik,
az Amazon, mint mi itt.

911
00:44:21,600 --> 00:44:24,810
>> De a motiváció az volt, hogy
bevezetni kriptográfia, kifejezetten

912
00:44:24,810 --> 00:44:28,340
olyan típusú kriptográfiai ismert
titkos kulcsú titkosítás.

913
00:44:28,340 --> 00:44:34,284
És ahogy a neve is sugallja, az egész
biztonságát titkos kulcs titkosítási rendszer,

914
00:44:34,284 --> 00:44:36,200
ha úgy tetszik, a módszer
mindössze rejtjelező

915
00:44:36,200 --> 00:44:40,960
információk két ember között, hogy
csak a feladó és a címzett csak

916
00:44:40,960 --> 00:44:46,980
egy titkot key-- némi értéke, néhány
titkos mondat, néhány titkos szám, hogy

917
00:44:46,980 --> 00:44:50,660
lehetővé teszi számukra, hogy mindkét titkosítani
és visszafejteni adatokat.

918
00:44:50,660 --> 00:44:53,470
És a kriptográfia, tényleg,
Csak ez van hétről 0.

919
00:44:53,470 --> 00:44:56,715
>> Ez egy probléma, ha van bemenet,
mint a tényleges üzenetet angolul

920
00:44:56,715 --> 00:44:59,340
vagy bármilyen nyelvet, amit
szeretnénk küldeni valakinek az osztályban,

921
00:44:59,340 --> 00:45:00,580
vagy az interneten keresztül.

922
00:45:00,580 --> 00:45:03,840
Van némi teljesítmény, ami megy
hogy a kódolt üzenetet, amelyet meg

923
00:45:03,840 --> 00:45:05,250
szeretnénk, hogy a címzett megkapja.

924
00:45:05,250 --> 00:45:07,405
És akkor is, ha valaki a
közepén kapja is,

925
00:45:07,405 --> 00:45:09,780
nem akarja, hogy
feltétlenül lesz képes visszafejteni,

926
00:45:09,780 --> 00:45:12,840
mert belülről ennek
fekete doboz, vagy algoritmus,

927
00:45:12,840 --> 00:45:17,650
van néhány olyan mechanizmust, néhány lépésről lépésre
utasítások, a figyelembe, hogy a bemeneti

928
00:45:17,650 --> 00:45:20,710
és átalakítása a
kimenete remélhetőleg biztonságos módon.

929
00:45:20,710 --> 00:45:23,640
>> És valóban, van némi
szókincs ebben a világban az alábbiak szerint.

930
00:45:23,640 --> 00:45:26,100
Egyszerű szöveg a szó egy
számítógép tudós lenne

931
00:45:26,100 --> 00:45:28,449
használja, hogy leírja a bemeneti
üzenet, mint az angol

932
00:45:28,449 --> 00:45:31,240
vagy bármilyen nyelvet ténylegesen
szeretnénk küldeni egy másik ember.

933
00:45:31,240 --> 00:45:35,450
És akkor a rejtjelezett a tülekedés
A titkosított, vagy titkosított,

934
00:45:35,450 --> 00:45:36,520
verziójára.

935
00:45:36,520 --> 00:45:38,750
>> De van egy másik összetevő van.

936
00:45:38,750 --> 00:45:43,200
Van egy másik bemenet
titkos kulcsú titkosítást.

937
00:45:43,200 --> 00:45:45,200
És ez a kulcs is,
amely általában

938
00:45:45,200 --> 00:45:48,930
mint látni fogjuk, számos, vagy
levél, vagy szó, bármi

939
00:45:48,930 --> 00:45:51,980
Az algoritmus valójában elvárja.

940
00:45:51,980 --> 00:45:53,870
>> És hogyan dekódolja az információt?

941
00:45:53,870 --> 00:45:55,110
Hogyan megfejt ez?

942
00:45:55,110 --> 00:45:57,950
Nos, csak fordított a
kimenetek és a bemenetek.

943
00:45:57,950 --> 00:46:00,900
>> Más szóval, ha valaki
megkapja a titkosított üzenetet,

944
00:46:00,900 --> 00:46:03,740
ő egyszerűen
Fontos tudni, hogy ugyanazt a kulcsot.

945
00:46:03,740 --> 00:46:05,700
Kaptak a rejtjelezett.

946
00:46:05,700 --> 00:46:09,530
És dugulás a két
bemenetek a titkosítási rendszer,

947
00:46:09,530 --> 00:46:14,260
Az algoritmus a fekete doboz, ki
jöjjön az eredeti nyílt szöveg.

948
00:46:14,260 --> 00:46:17,830
És ez az a nagyon magas szintet
vélekedik kriptográfia valójában

949
00:46:17,830 --> 00:46:18,590
szól.

950
00:46:18,590 --> 00:46:20,030
>> Tehát menjünk oda.

951
00:46:20,030 --> 00:46:22,700
Nézzük most meg alatta
A motorháztető valami

952
00:46:22,700 --> 00:46:26,000
mi már szedett nyújtott
Az elmúlt héten, és ezen az ülésen

953
00:46:26,000 --> 00:46:27,629
here-- a húr.

954
00:46:27,629 --> 00:46:30,295
Egy karakterlánc végén a nap
csak egy karaktersorozat.

955
00:46:30,295 --> 00:46:33,610
>> Lehet, hogy hello world, vagy
szia Zamyla, vagy bármi más.

956
00:46:33,610 --> 00:46:37,050
De mit jelent ez a
egy karaktersorozat?

957
00:46:37,050 --> 00:46:41,520
Tény, hogy a CS50 könyvtár ad
nekünk egy adattípust nevű karakterlánc.

958
00:46:41,520 --> 00:46:45,140
>> De valójában nincs
olyan dolog, mint egy húr a C.

959
00:46:45,140 --> 00:46:49,450
Ez tényleg csak egy sorozata
karakter, karakter, karakter,

960
00:46:49,450 --> 00:46:52,180
karakter, vissza, vissza, hogy
vissza, vissza, vissza belsejében

961
00:46:52,180 --> 00:46:54,650
a számítógép memóriájában, vagy a RAM.

962
00:46:54,650 --> 00:46:58,940
És akkor nézd mélyebbre, hogy a
jövőben, amikor megnézzük a memória is,

963
00:46:58,940 --> 00:47:02,030
és a hasznosítás, valamint a
fenyegetések, melyek részt vesznek.

964
00:47:02,030 --> 00:47:04,100
>> De nézzük meg a húr Zamyla.

965
00:47:04,100 --> 00:47:07,480
Tehát csak a nevét
Az emberi itt Zamyla,

966
00:47:07,480 --> 00:47:12,030
hogy egy sorozata
karakterek, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Most tegyük fel, hogy Zamyla neve
a tárolás belsejében egy számítógép

968
00:47:16,020 --> 00:47:16,880
program.

969
00:47:16,880 --> 00:47:20,830
>> Nos, magától értetődik, hogy mi kell
tudja nézni ezeket a karaktereket

970
00:47:20,830 --> 00:47:21,590
egyénileg.

971
00:47:21,590 --> 00:47:24,710
Tehát én csak fog felhívni egy kicsit
doboz körül Zamyla nevét itt.

972
00:47:24,710 --> 00:47:31,580
És ez a helyzet a C, hogy amikor
van egy szöveg, mint Zamyla-- és talán

973
00:47:31,580 --> 00:47:34,940
ez a karakterlánc jött vissza
hasonló függvény get húr,

974
00:47:34,940 --> 00:47:38,540
akkor valóban manipulálni
ez betűnként.

975
00:47:38,540 --> 00:47:42,070
>> Nos, ez illenek a
beszélgetés kéznél, mert

976
00:47:42,070 --> 00:47:46,420
kriptográfiai ha meg akarja változtatni
A-B és B-C, és a C-D,

977
00:47:46,420 --> 00:47:49,650
és így tovább, akkor képesnek kell lennie
nézni az egyes karakterek

978
00:47:49,650 --> 00:47:50,190
a szövegben.

979
00:47:50,190 --> 00:47:52,695
Be kell, hogy képes megváltoztatni
Z másra, az A

980
00:47:52,695 --> 00:47:55,280
valami mást, az M
valami mást, és így tovább.

981
00:47:55,280 --> 00:47:58,000
És így kell a módját,
programból, így

982
00:47:58,000 --> 00:48:03,020
beszélni, C-ben, hogy képes legyen megváltoztatni
és nézd meg az egyes betűk.

983
00:48:03,020 --> 00:48:05,690
És ezt meg tudjuk tenni a következő.

984
00:48:05,690 --> 00:48:08,340
>> Hadd menjen térjen vissza a CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
És hadd menjen előre
és hozzon létre egy új fájlt

986
00:48:11,130 --> 00:48:16,134
hogy hívom ezúttal string0,
például az első ilyen példa, pont c.

987
00:48:16,134 --> 00:48:18,300
És én megyek előre
és ostor fel az alábbiak szerint.

988
00:48:18,300 --> 00:48:22,870
>> Így többek között CS50.h, és
majd közé tartoznak a standard io.h,

989
00:48:22,870 --> 00:48:25,990
amely már majdnem mindig lesz
használja az én programok, legalább

990
00:48:25,990 --> 00:48:26,780
alapvetően.

991
00:48:26,780 --> 00:48:32,180
int fő érvénytelen, és aztán itt vagyok
csinálni húrok lesz kap húr.

992
00:48:32,180 --> 00:48:35,260
És akkor megyek
megy előre, és erre a célra.

993
00:48:35,260 --> 00:48:37,460
Azt akarom, hogy menjen előre
és, mint egy alapvető ellenőrzést,

994
00:48:37,460 --> 00:48:43,607
Csak azt mondják, hello, százalék s,
pontosvessző teszi húr 0.

995
00:48:43,607 --> 00:48:44,690
Ajjaj, mit csináltam itt?

996
00:48:44,690 --> 00:48:45,930
Ó, én nem dugja be.

997
00:48:45,930 --> 00:48:48,120
Tehát tanulság, hogy
Nem volt szándékos.

998
00:48:48,120 --> 00:48:52,480
>> Tehát a hiba, nagyobb százalék
konverziót, mint az adatok érveket.

999
00:48:52,480 --> 00:48:54,940
És ez az, ahol,
vonal 7-- OK, úgyhogy,

1000
00:48:54,940 --> 00:48:56,690
idézet idézőjel bezárva, ez
én húr a printf.

1001
00:48:56,690 --> 00:48:58,151
Van egy százalék jelet.

1002
00:48:58,151 --> 00:48:59,650
De én eltűnt a második érv.

1003
00:48:59,650 --> 00:49:03,190
>> Hiányzik a vessző s, amely
Én már az előző példákban.

1004
00:49:03,190 --> 00:49:06,650
Tehát egy jó lehetőség, hogy rögzítse
Még egy hiba, véletlenül.

1005
00:49:06,650 --> 00:49:09,950
És most hadd futni
string0 írja be Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, helló Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Így már fut ez a fajta program
néhány különböző időpontokban most.

1008
00:49:14,144 --> 00:49:16,310
De csináljunk valamit a
kicsit más ebben az időben.

1009
00:49:16,310 --> 00:49:19,450
Ahelyett, hogy csak a nyomtatást Zamyla a
teljes név ki printf,

1010
00:49:19,450 --> 00:49:21,350
csináljuk karakterenként.

1011
00:49:21,350 --> 00:49:22,700
>> Megyek, hogy egy hurok.

1012
00:49:22,700 --> 00:49:26,160
És én adok magamnak
a számláló változó, az i.

1013
00:49:26,160 --> 00:49:33,530
És én fogom tartani iterációjával, így
amíg én kisebb, mint a hossza s.

1014
00:49:33,530 --> 00:49:35,930
>> Kiderült, mi nem
Ehhez utoljára,

1015
00:49:35,930 --> 00:49:39,100
hogy c jön egy
nevű függvény Stirling.

1016
00:49:39,100 --> 00:49:42,690
Vissza a nap, és általában
még ha a végrehajtási funkciók,

1017
00:49:42,690 --> 00:49:45,405
emberek gyakran dönt, nagyon
tömör nevek a fajta hang

1018
00:49:45,405 --> 00:49:48,280
mint amit szeretne, annak ellenére, hogy
hiányzik néhány magánhangzók vagy betűket.

1019
00:49:48,280 --> 00:49:50,660
Tehát Stirling az
Íme egy függvény, amely

1020
00:49:50,660 --> 00:49:53,880
vesz egy érv között
zárójelben, hogy legyen egy string.

1021
00:49:53,880 --> 00:49:56,910
És ez csak vissza egy egész,
hosszát, hogy a húr.

1022
00:49:56,910 --> 00:50:00,580
>> Tehát ez a hurok on line 7 megy
kezdeni a számlálást i értéke 0.

1023
00:50:00,580 --> 00:50:02,530
Meg fog növelni
i minden iterációban

1024
00:50:02,530 --> 00:50:04,350
1, mivel mi már ennek egy párszor.

1025
00:50:04,350 --> 00:50:06,780
De ez meg fog csak ezt
ez egészen a pontig

1026
00:50:06,780 --> 00:50:09,660
mikor a hossza
A húr is.

1027
00:50:09,660 --> 00:50:14,520
>> Tehát ez az egyik módja annak, végül,
iterációt a karakterek

1028
00:50:14,520 --> 00:50:17,430
a húr, ahogy van a következő.

1029
00:50:17,430 --> 00:50:20,670
Megyek, hogy nyomtassa ki nem
egész szöveg, de százalékkal c,

1030
00:50:20,670 --> 00:50:22,860
egyetlen karaktert
majd egy új sort.

1031
00:50:22,860 --> 00:50:24,880
És akkor megyek
megy előre, és azt kell

1032
00:50:24,880 --> 00:50:29,080
azt mondani, hogy a nyomtatni kívánt
edik karaktere s.

1033
00:50:29,080 --> 00:50:33,450
>> Tehát, ha az i változót, ami azt jelzi,
Az index a húr, ahol

1034
00:50:33,450 --> 00:50:37,230
van benne, azt kell, hogy képes legyen
mondani, hogy nekem az i-edik karaktere s.

1035
00:50:37,230 --> 00:50:40,390
És c egy módja a
ezt szögletes zárójelben.

1036
00:50:40,390 --> 00:50:43,679
Egyszerűen mondja ki a nevét
húr, amely ebben az esetben az, s.

1037
00:50:43,679 --> 00:50:46,970
Akkor használja szögletes zárójelben, amelyek
Általában csak a fenti a Return vagy Enter

1038
00:50:46,970 --> 00:50:48,110
gombot a billentyűzeten.

1039
00:50:48,110 --> 00:50:52,410
És akkor tedd az index az
kívánt karaktert nyomtatni.

1040
00:50:52,410 --> 00:50:55,960
Így az index lesz
number-- 0, vagy 1, vagy 2, vagy 3, vagy DOT,

1041
00:50:55,960 --> 00:50:57,590
dot, dot, egy másik számot.

1042
00:50:57,590 --> 00:51:00,920
>> És mi biztosítja, hogy ez meg fog
a helyes számot, mert

1043
00:51:00,920 --> 00:51:02,360
elkezd számolás 0.

1044
00:51:02,360 --> 00:51:07,020
És alapértelmezés szerint az első karakter
Egy karakterlánc közmegegyezés 0.

1045
00:51:07,020 --> 00:51:09,230
És a második karakter konzol 1.

1046
00:51:09,230 --> 00:51:11,120
És a harmadik karakter konzol 2.

1047
00:51:11,120 --> 00:51:13,630
És akkor nem érdemes túl sokat
messze, de nem fogunk, mert mi vagyunk

1048
00:51:13,630 --> 00:51:17,780
fog csak akkor növekszik, amíg én
megegyezik a karakterlánc hossza.

1049
00:51:17,780 --> 00:51:20,210
És ahol a ponton,
Ez a for ciklus leáll.

1050
00:51:20,210 --> 00:51:25,550
>> Tehát hadd menjen előre, és mentse ezt
programot, és fuss String 0.

1051
00:51:25,550 --> 00:51:28,400
De elcsesztem.

1052
00:51:28,400 --> 00:51:35,390
Burkoltan kijelentette könyvtár funkciója
Stirling típusú ilyen és such-- most,

1053
00:51:35,390 --> 00:51:36,430
ez ismerősen hangzik.

1054
00:51:36,430 --> 00:51:37,440
De ez nem printf.

1055
00:51:37,440 --> 00:51:38,540
És ez nem fog sor.

1056
00:51:38,540 --> 00:51:40,480
>> Nem csavarja fel
Ugyanígy ebben az időben.

1057
00:51:40,480 --> 00:51:45,100
De észre le ide egy kicsit le
továbbá, tartalmazza a fejléc string.h,

1058
00:51:45,100 --> 00:51:47,210
kifejezetten biztosítja a
nyilatkozat Stirling.

1059
00:51:47,210 --> 00:51:48,820
Tehát tulajdonképpen egy nyom van.

1060
00:51:48,820 --> 00:51:51,670
>> És valóban kiderül,
van egy másik header file

1061
00:51:51,670 --> 00:51:53,970
hogy már nem használt
osztályban még, de ez

1062
00:51:53,970 --> 00:51:56,480
között rendelkezésre álló
neked, az úgynevezett string.h.

1063
00:51:56,480 --> 00:52:00,930
És abban a fájlban, string.h
a Stirling nyilvánított.

1064
00:52:00,930 --> 00:52:05,220
Tehát hadd menjen előre, és
menteni ezt, hogy húr

1065
00:52:05,220 --> 00:52:08,040
0-- szép, hibaüzenet nélkül ebben az időben.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, és
Mindjárt megüt Belép,

1067
00:52:12,290 --> 00:52:16,710
ekkor getstring megy
vissza a húr, betette s.

1068
00:52:16,710 --> 00:52:21,890
Aztán, hogy a hurok fog hajtogat
felett S karaktereket egyesével,

1069
00:52:21,890 --> 00:52:28,420
és nyomtassa ki őket soronként, mert
Volt, hogy a fordított perjel n a végén.

1070
00:52:28,420 --> 00:52:34,530
Így tudtam kihagyni, hogy backslash
n, majd csak nyomtatni Zamyla összes

1071
00:52:34,530 --> 00:52:37,460
az ugyanabban a sorban,
hatékonyan reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, ami egyáltalán nem olyan hasznos.

1073
00:52:38,999 --> 00:52:40,540
De ebben az esetben, azt még nem tette ezt.

1074
00:52:40,540 --> 00:52:43,610
Már tényleg nyomtatott változattal
karakter egy időben, soronként,

1075
00:52:43,610 --> 00:52:45,400
hogy mi valójában a hatás.

1076
00:52:45,400 --> 00:52:46,900
>> De figyelembe kell venni, egy dolog van.

1077
00:52:46,900 --> 00:52:48,930
És mi jön vissza
ez egy jövőbeli héten.

1078
00:52:48,930 --> 00:52:52,650
Kiderült, hogy ez a
kód potenciálisan hibás.

1079
00:52:52,650 --> 00:52:56,560
>> Kiderült, hogy get húr
és néhány egyéb funkciók az életben

1080
00:52:56,560 --> 00:53:00,280
nem feltétlenül mindig
visszatérni, amit várt.

1081
00:53:00,280 --> 00:53:03,010
Tudjuk osztály utolsó
alkalommal ebben kap, hogy

1082
00:53:03,010 --> 00:53:04,960
karakterlánc volna vissza a húr.

1083
00:53:04,960 --> 00:53:09,900
De mi van, ha a felhasználó az ilyen
Hosszú szó vagy bekezdés, vagy esszé

1084
00:53:09,900 --> 00:53:13,010
hogy ott van csak nem elég
memória a számítógépben, hogy illeszkedjen.

1085
00:53:13,010 --> 00:53:15,410
>> Mint, mi van, ha valami nem megy
rossz a motorháztető alatt?

1086
00:53:15,410 --> 00:53:18,400
Lehet, hogy nem fordul elő gyakran,
de ez megtörténhet egyszer

1087
00:53:18,400 --> 00:53:21,520
egy darabig, nagyon ritkán.

1088
00:53:21,520 --> 00:53:25,460
És így kiderül, hogy get húr
és úgy működik, mint ez nem feltétlenül

1089
00:53:25,460 --> 00:53:26,380
mindig visszatér szálakat.

1090
00:53:26,380 --> 00:53:30,680
Lehet, hogy visszatér némi hibával,
Néhány sentinel értéket úgy mondjam,

1091
00:53:30,680 --> 00:53:32,612
amely jelzi, hogy
valami nincs rendben.

1092
00:53:32,612 --> 00:53:35,320
És akkor csak tudjuk ezt a
miután megtanulta az osztályban most,

1093
00:53:35,320 --> 00:53:37,700
vagy olvastam néhány dokumentációt.

1094
00:53:37,700 --> 00:53:43,120
Kiderült, hogy get húr
lehet visszatérési értéke az úgynevezett null.

1095
00:53:43,120 --> 00:53:46,220
Null külön értéke, hogy fogunk
jöjjön vissza egy későbbi héten.

1096
00:53:46,220 --> 00:53:50,420
De most, csak tudom, hogy ha akarom,
hogy valóban a megfelelő halad előre

1097
00:53:50,420 --> 00:53:52,650
használatával get húr, azt
ne csak nevezni,

1098
00:53:52,650 --> 00:53:56,870
és vakon használni a visszatérési érték,
bízva abban, hogy ez egy húr.

1099
00:53:56,870 --> 00:53:59,420
>> Azt kell először mondani,
hé, várj egy percet, csak

1100
00:53:59,420 --> 00:54:03,380
eljárni, ha s nem egyenlő
null, ahol null ismét

1101
00:54:03,380 --> 00:54:04,660
csak néhány különleges értéket.

1102
00:54:04,660 --> 00:54:07,770
És ez az egyetlen különleges értéket
kell aggódnia get húr.

1103
00:54:07,770 --> 00:54:10,900
Get stringet sem megy
hogy visszatérjen egy string vagy null.

1104
00:54:10,900 --> 00:54:17,219
>> És ez a felkiáltójel egyenlőségjel
talán tudják talán, matekórán

1105
00:54:17,219 --> 00:54:20,510
hogy lehet felhívni egy egyenlőségjelet a
egy sort, jelezve nem egyenlő.

1106
00:54:20,510 --> 00:54:23,135
Ez általában nem egy karakter
beírhatja a billentyűzeten.

1107
00:54:23,135 --> 00:54:26,480
És így a legtöbb programozási nyelvben,
ha azt akarom mondani nem egyenlő,

1108
00:54:26,480 --> 00:54:29,160
használ egy felkiáltójel,
más néven bumm.

1109
00:54:29,160 --> 00:54:33,180
Tehát azt mondod, bumm egyenlő, amely
jelenti, hogy nem felel meg, logikusan.

1110
00:54:33,180 --> 00:54:38,060
Olyan ez, mint ott nem nagyobb
mint, vagy egyenlő, vagy kisebb, mint

1111
00:54:38,060 --> 00:54:41,270
vagy egyenlő a billentyűzeten
hogy nem az egészet egy szimbólum.

1112
00:54:41,270 --> 00:54:44,020
Tehát ezért, az elmúlt példák,
te egy nyitott zárójel, majd

1113
00:54:44,020 --> 00:54:48,670
egyenlőségjel, annak érdekében, hogy ezt
nagyobb vagy, mondjuk, kevesebb.

1114
00:54:48,670 --> 00:54:49,910
>> Tehát mi a elvihető itt?

1115
00:54:49,910 --> 00:54:53,880
Ez egy egyszerű módja a most a
bevezetésével ezt a szintaxist, ezt a funkciót,

1116
00:54:53,880 --> 00:54:57,390
iterációt egyéni
karakterre.

1117
00:54:57,390 --> 00:55:00,260
És csakúgy, mint azok, szögletes
zárójelben lehetővé teszi, hogy őket,

1118
00:55:00,260 --> 00:55:03,790
figyelembe vennie azokat szögletes zárójelek
fajta sejteti ezt az alapvető

1119
00:55:03,790 --> 00:55:06,040
design, amellyel minden
karakter belsejében egy húr

1120
00:55:06,040 --> 00:55:10,180
A fajta dobozos valahol alatta
A motorháztető a számítógép memóriájában.

1121
00:55:10,180 --> 00:55:12,340
>> De nézzük, hogy egy változata ennek.

1122
00:55:12,340 --> 00:55:14,880
Kiderült, hogy ez a
program helyes.

1123
00:55:14,880 --> 00:55:18,810
Tehát egy CS50 a tengely értékeléséhez
kód, ez most már megfelelő.

1124
00:55:18,810 --> 00:55:22,959
Különösen most, hogy én vagyok ellenőrzése
null, ez a program soha nem összeomlik.

1125
00:55:22,959 --> 00:55:24,500
És én tudom, hogy a tapasztalatokból.

1126
00:55:24,500 --> 00:55:28,040
De nincs semmi más,
akkor tényleg baj van.

1127
00:55:28,040 --> 00:55:31,860
De ez nem nagyon jól megtervezett,
mert menjünk vissza az alapokhoz.

1128
00:55:31,860 --> 00:55:34,450
>> Először is, Elvei
mit csinál egy hurok csinálni?

1129
00:55:34,450 --> 00:55:36,290
A hurok három dolgot.

1130
00:55:36,290 --> 00:55:39,340
Ez inicializálja néhány
értéket, ha kéred, hogy.

1131
00:55:39,340 --> 00:55:41,770
Ez ellenőrzi a feltételt.

1132
00:55:41,770 --> 00:55:45,380
És azután minden
iteráció után minden ciklusban,

1133
00:55:45,380 --> 00:55:49,330
ez megnöveli néhány
érték, vagy értékek, itt.

1134
00:55:49,330 --> 00:55:50,600
>> Tehát mit jelent?

1135
00:55:50,600 --> 00:55:52,940
Inicializáljuk i 0.

1136
00:55:52,940 --> 00:55:58,610
Mi ellenõrzésére, i-nél kisebb
a hossza s, ami Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
így, ami kevesebb, mint 6.

1138
00:55:59,900 --> 00:56:02,590
És valóban, 0 a kevesebb, mint 6.

1139
00:56:02,590 --> 00:56:05,580
>> Kinyomtatjuk Z-re Zamyla nevét.

1140
00:56:05,580 --> 00:56:08,080
Ezután növeljük i 0-1.

1141
00:56:08,080 --> 00:56:11,290
Ezután ellenőrizze, 1 kisebb
mint a hossza s?

1142
00:56:11,290 --> 00:56:13,270
A hossza s 6.

1143
00:56:13,270 --> 00:56:13,950
Igen ez az.

1144
00:56:13,950 --> 00:56:16,880
>> Így nyomtasson a Zamyla nevét, ZA.

1145
00:56:16,880 --> 00:56:20,090
Mi növekmény I 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Ezután ellenőrizze, 2-nél kisebb
hossza Zamyla nevét.

1147
00:56:23,720 --> 00:56:25,380
6- SO 2 kisebb, mint 6.

1148
00:56:25,380 --> 00:56:30,460
Igen, most ki kell nyomtatni most M
Zamyla nevét, a harmadik karakter.

1149
00:56:30,460 --> 00:56:34,110
>> A legfontosabb az, hogy az egyes
iteráció a történet, én ellenőrzése,

1150
00:56:34,110 --> 00:56:37,810
jelentése i kisebb, mint a hossza Zamyla?

1151
00:56:37,810 --> 00:56:40,350
De a fogást, hogy
Stirling nem tulajdonság.

1152
00:56:40,350 --> 00:56:43,100
Azok, akik programoztak
mielőtt a Java vagy más nyelven

1153
00:56:43,100 --> 00:56:46,310
Lehet tudni, hogy a karakterlánc hosszát is
ingatlan, csak néhány, csak olvasható érték.

1154
00:56:46,310 --> 00:56:50,220
>> A C-ben ebben az esetben, ha ez az
egy függvény, amely a szó szoros értelmében

1155
00:56:50,220 --> 00:56:53,520
megszámlálásával
karakterek Zamyla minden alkalommal

1156
00:56:53,520 --> 00:56:54,740
hívjuk ezt a funkciót.

1157
00:56:54,740 --> 00:56:58,500
Minden alkalommal, amikor kérdezni a számítógép használatához
Stirling, ez egy pillantást Zamyla,

1158
00:56:58,500 --> 00:57:01,960
és azt mondja Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
És visszatér 6.

1160
00:57:02,962 --> 00:57:04,920
A következő alkalommal, amikor hívást
belsejébe, hogy hurok,

1161
00:57:04,920 --> 00:57:08,610
ez fog nézni Zamyla
ismét, mondjuk Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
És ez meg fog visszatérni 6.

1163
00:57:10,320 --> 00:57:12,980
Tehát mi hülye erről design?

1164
00:57:12,980 --> 00:57:17,700
>> Miért van a kód nem egy 5 out of 5
tervezés most, hogy úgy mondjam?

1165
00:57:17,700 --> 00:57:20,600
Nos, én kérek
kérdés feleslegesen.

1166
00:57:20,600 --> 00:57:23,030
Csinálok több munka, mint azt kell.

1167
00:57:23,030 --> 00:57:25,370
>> Tehát annak ellenére, hogy a
válasz helyes, én

1168
00:57:25,370 --> 00:57:29,560
kérdezi a számítógép, mi
a hossza Zamyla ismét,

1169
00:57:29,560 --> 00:57:31,380
és újra, és újra, és újra?

1170
00:57:31,380 --> 00:57:33,980
És ez válasz
Soha nem fog megváltozni.

1171
00:57:33,980 --> 00:57:35,900
Mindig lesz 6.

1172
00:57:35,900 --> 00:57:39,730
>> Tehát jobb megoldás, mint ez a
lenne ez a következő verzió.

1173
00:57:39,730 --> 00:57:43,390
Hadd menjen előre, és betette egy
külön nevű fájlt string1.c,

1174
00:57:43,390 --> 00:57:44,990
csak hogy tartsa elkülönítve.

1175
00:57:44,990 --> 00:57:47,260
És kiderül, egy a
hurok, akkor valójában

1176
00:57:47,260 --> 00:57:50,210
állapítsa több változó egyszerre.

1177
00:57:50,210 --> 00:57:53,460
>> Így fogok tartani i és állítsa 0-ra.

1178
00:57:53,460 --> 00:57:56,190
De én is fog
vesszőt, és azt mondják,

1179
00:57:56,190 --> 00:58:01,050
adj egy változó nevű n, akinek
értéke megegyezik a karakterlánc hosszát s.

1180
00:58:01,050 --> 00:58:09,410
És most, kérjük, hogy az állapotom
amíg i kisebb, mint n.

1181
00:58:09,410 --> 00:58:14,140
>> Tehát ily módon, a logika
azonos a végén a nap.

1182
00:58:14,140 --> 00:58:18,280
De én emlékezve
érték 6, ebben az esetben.

1183
00:58:18,280 --> 00:58:19,780
Mi a hossza Zamyla nevét?

1184
00:58:19,780 --> 00:58:20,860
És én amivel azt n.

1185
00:58:20,860 --> 00:58:23,050
>> És én még mindig ellenőrzése
a feltétel minden alkalommal.

1186
00:58:23,050 --> 00:58:24,300
Jelentése 0 kevesebb, mint 6?

1187
00:58:24,300 --> 00:58:25,600
1 kisebb, mint 6?

1188
00:58:25,600 --> 00:58:28,600
2 kevesebb, mint 6, és így tovább?

1189
00:58:28,600 --> 00:58:31,914
>> De én nem azt kéri a számítógép
újra, és újra, mi

1190
00:58:31,914 --> 00:58:33,080
hossza Zamyla nevét?

1191
00:58:33,080 --> 00:58:34,320
Mi a hossza Zamyla nevét?

1192
00:58:34,320 --> 00:58:35,986
Mi a hossza a Zamyla nevét?

1193
00:58:35,986 --> 00:58:40,440
Én szó szerint megjegyezni, hogy az első és
csak a válasz ebben a második változó n.

1194
00:58:40,440 --> 00:58:45,280
Tehát ez lenne most nemcsak
helyes, hanem a jól megtervezett.

1195
00:58:45,280 --> 00:58:46,670
>> De mi a helyzet a stílus?

1196
00:58:46,670 --> 00:58:48,866
Már elemzi én változók
elég jól, azt mondanám.

1197
00:58:48,866 --> 00:58:50,240
Ők szuper tömör most.

1198
00:58:50,240 --> 00:58:52,090
És ez teljesen rendben van.

1199
00:58:52,090 --> 00:58:55,120
>> Ha csak egy
húr a program,

1200
00:58:55,120 --> 00:58:56,860
akár meg is nevezni s karakterlánc.

1201
00:58:56,860 --> 00:58:59,370
Ha csak egy változót
számlálására a program,

1202
00:58:59,370 --> 00:59:00,710
akár meg is nevezni i.

1203
00:59:00,710 --> 00:59:03,500
Ha van egy hosszú, n
szuper közös is.

1204
00:59:03,500 --> 00:59:05,800
De én nem kommentálta bármely kódomat.

1205
00:59:05,800 --> 00:59:09,200
>> Már nem tájékoztatta a reader--
hogy ez az én TF, vagy TA,

1206
00:59:09,200 --> 00:59:12,460
vagy csak colleague-- mit kéne
hogy folyik ebben a programban.

1207
00:59:12,460 --> 00:59:15,760
És így, hogy jó stílusban,
mit szeretne csinálni

1208
00:59:15,760 --> 00:59:24,580
van valami this--
mint kérnie az input.

1209
00:59:24,580 --> 00:59:26,670
És tudtam átírni
ezt számos módon.

1210
00:59:26,670 --> 00:59:35,630
>> Győződjön meg arról, hogy győződjön meg arról S- get
húr vissza a húr.

1211
00:59:35,630 --> 00:59:40,280
Majd here-- és talán ez
a legfontosabb comment-- hajtogat

1212
00:59:40,280 --> 00:59:44,450
át a karaktereket s egyesével.

1213
00:59:44,450 --> 00:59:47,060
És jól jönne bármilyen
választható angol nyelv

1214
00:59:47,060 --> 00:59:49,650
ide le minden
Ezen darabokat kódot.

1215
00:59:49,650 --> 00:59:52,740
>> Figyeljük meg, hogy én nem tesz egy
megjegyzést minden sor kódot,

1216
00:59:52,740 --> 00:59:55,690
tényleg csak az érdekes
is, az is, hogy

1217
00:59:55,690 --> 00:59:59,460
Van valami jelentősége, hogy én is
szeretnénk, hogy szuper tiszta valakinek

1218
00:59:59,460 --> 01:00:00,460
olvassa a kódot.

1219
01:00:00,460 --> 01:00:02,920
És miért hívsz, hogy
húr felhasználótól az input?

1220
01:00:02,920 --> 01:00:05,450
Még hogy az ember nem feltétlenül
minden leíró jellegű.

1221
01:00:05,450 --> 01:00:09,340
De segít elmondani a történetet, mert a
második sor a történet, győződjön meg róla,

1222
01:00:09,340 --> 01:00:10,740
A string vissza a húr.

1223
01:00:10,740 --> 01:00:14,260
>> És a harmadik sor a történet,
végighaladni a karakter s egy

1224
01:00:14,260 --> 01:00:15,380
egy időben.

1225
01:00:15,380 --> 01:00:17,920
És már csak a jó intézkedés,
Megyek, hogy menjen előre, és adjunk hozzá

1226
01:00:17,920 --> 01:00:24,560
Még egy megjegyzés, hogy csak
mondja print i-edik karaktere s.

1227
01:00:24,560 --> 01:00:26,520
Most, mit tettem
a nap végén?

1228
01:00:26,520 --> 01:00:29,190
>> Van hozzá egy kis angol
szavak formájában megjegyzéseket.

1229
01:00:29,190 --> 01:00:32,700
A perjel perjel szimbólum azt jelenti, hé,
számítógép ez az emberi,

1230
01:00:32,700 --> 01:00:33,820
nem neked, a számítógép.

1231
01:00:33,820 --> 01:00:35,119
Tehát ők figyelmen kívül logikusan.

1232
01:00:35,119 --> 01:00:35,910
Ők csak ott.

1233
01:00:35,910 --> 01:00:39,830
>> És valóban, CS50 IDE megjeleníti azokat
szürke, mint hasznos, de nem kulcsfontosságú

1234
01:00:39,830 --> 01:00:41,000
a program.

1235
01:00:41,000 --> 01:00:42,570
Figyeljük meg, mit lehet tenni most.

1236
01:00:42,570 --> 01:00:44,950
Akár tudod C
programozási vagy sem,

1237
01:00:44,950 --> 01:00:47,722
egyszerűen hátrébb ebben
programot, és sovány a megjegyzéseket.

1238
01:00:47,722 --> 01:00:50,180
Felhasználótól az input, győződjön meg róla,
A string visszatért egy string,

1239
01:00:50,180 --> 01:00:53,009
végighaladni a karaktereket s
egyesével, nyomtassa ki a karaktert

1240
01:00:53,009 --> 01:00:55,550
i-edik karaktere S- te nem
még meg kell nézni a kódot

1241
01:00:55,550 --> 01:00:57,270
megérteni, hogy mi ez a program teszi.

1242
01:00:57,270 --> 01:01:00,280
És még jobb, ha magad nézni
ez a program egy-két héten belül,

1243
01:01:00,280 --> 01:01:02,280
vagy egy hónap vagy egy év,
te is nem

1244
01:01:02,280 --> 01:01:04,420
bámult a kódot,
próbál emlékezni,

1245
01:01:04,420 --> 01:01:06,630
amit én akar csinálni ezzel a kóddal?

1246
01:01:06,630 --> 01:01:07,770
>> Te mondtad magadnak.

1247
01:01:07,770 --> 01:01:11,660
Már le magad,
vagy valamilyen kolléga, vagy TA, vagy TF.

1248
01:01:11,660 --> 01:01:14,860
És így ez most
helyes, és a jó design,

1249
01:01:14,860 --> 01:01:18,210
és végül jó stílusban is.

1250
01:01:18,210 --> 01:01:19,990
Tehát nem hogy tartsa szem előtt.

1251
01:01:19,990 --> 01:01:22,200
>> Tehát van egy másik
dolog, amit tenni fogok itt

1252
01:01:22,200 --> 01:01:28,240
hogy most felfedi pontosan mi
folyik a motorháztető alatt.

1253
01:01:28,240 --> 01:01:30,390
Tehát itt van ez a funkció
C, és más nyelveken,

1254
01:01:30,390 --> 01:01:33,010
úgynevezett typecasting
hogy akár implicit

1255
01:01:33,010 --> 01:01:37,250
vagy kifejezetten lehetővé teszi, hogy convert
egy adattípust a másikra.

1256
01:01:37,250 --> 01:01:39,800
Már évek óta foglalkozik, így
amennyire ma szálakat.

1257
01:01:39,800 --> 01:01:41,250
>> És húrok karakter.

1258
01:01:41,250 --> 01:01:44,910
De emlékszem hétről
0, mik karaktereket?

1259
01:01:44,910 --> 01:01:49,334
Karakterek csak egy absztrakció
tetején numbers-- egész szám,

1260
01:01:49,334 --> 01:01:52,500
és decimális számok tényleg csak egy
absztrakció tetején bináris számokat,

1261
01:01:52,500 --> 01:01:53,720
ahogy határozta meg.

1262
01:01:53,720 --> 01:01:55,540
>> Tehát karakterek számát.

1263
01:01:55,540 --> 01:01:58,410
És a számok karakterek,
csak a szövegkörnyezettől függően.

1264
01:01:58,410 --> 01:02:01,250
És kiderül, hogy belül
A számítógépi program,

1265
01:02:01,250 --> 01:02:06,830
meg tudja határozni, hogy hogyan szeretné nézni
A bitek belsejében a program?

1266
01:02:06,830 --> 01:02:10,400
>> Emlékezzünk hétről 0, hogy mi volt
ASCII, ami csak ezt a kódot

1267
01:02:10,400 --> 01:02:11,620
mapping betűk számok.

1268
01:02:11,620 --> 01:02:13,660
És mi azt mondtuk, a tőke A 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B 66, és így tovább.

1270
01:02:15,860 --> 01:02:20,500
>> És vegyük észre, mi kell főként karakter on
A felső sorban van, mint a C nevezné,

1271
01:02:20,500 --> 01:02:23,400
karaktereket, majd
ints a második sorban.

1272
01:02:23,400 --> 01:02:28,180
És kiderül, hogy lehet konvertálni
zökkenőmentesen a kettő között, jellemzően.

1273
01:02:28,180 --> 01:02:30,042
És ha azt akarjuk, hogy
ezt tudatosan, mi

1274
01:02:30,042 --> 01:02:31,750
Lehet, hogy kezelni
valami ilyesmi.

1275
01:02:31,750 --> 01:02:33,590
>> Talán szeretné konvertálni
nagybetű alacsonyabb

1276
01:02:33,590 --> 01:02:35,330
esetben, illetve alacsonyabb a nagybetűkkel.

1277
01:02:35,330 --> 01:02:38,000
És kiderül, ott a
valójában egy mintát ide

1278
01:02:38,000 --> 01:02:39,900
tudjuk ölelés csak egy pillanatra.

1279
01:02:39,900 --> 01:02:44,120
De nézzük először egy
példája ezt explicit módon.

1280
01:02:44,120 --> 01:02:46,340
>> Megyek, hogy menjen vissza a CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Megyek, hogy egy
nevű fájlt ASCII 0.c.

1282
01:02:50,640 --> 01:02:55,960
És én megyek előre, és hozzá a
szabvány io.h tetején, int main void

1283
01:02:55,960 --> 01:02:57,370
a tetején én funkciót.

1284
01:02:57,370 --> 01:03:02,700
És akkor én csak csinálni a
following-- for ciklus az i értéke,

1285
01:03:02,700 --> 01:03:04,610
mondjuk, 65.

1286
01:03:04,610 --> 01:03:10,460
>> És akkor én lesz kevesebb
65, plusz 26 betű az ábécé.

1287
01:03:10,460 --> 01:03:12,640
Úgyhogy hagyja, hogy a számítógép
a matek, hogy ott legyek.

1288
01:03:12,640 --> 01:03:15,100
Aztán belül a hurok,
mit fogok nyomtatni?

1289
01:03:15,100 --> 01:03:19,230
>> % C% i backslash n.

1290
01:03:19,230 --> 01:03:21,290
És most szeretnék csatlakoztatni a két érték.

1291
01:03:21,290 --> 01:03:24,530
Már átmenetileg fel kérdését
jelek vannak, hogy meghívja a kérdést.

1292
01:03:24,530 --> 01:03:29,940
>> Azt akarom, hogy ismételget 65-től
26 az ábécé betűit,

1293
01:03:29,940 --> 01:03:35,190
nyomtat ki minden egyes iteráció hogy
karakter szerves egyenértékű.

1294
01:03:35,190 --> 01:03:38,299
Más szóval, azt akarom, hogy
végighaladni 26 szám nyomtatás

1295
01:03:38,299 --> 01:03:41,590
mi az ASCII karakter, a levél,
és mi a megfelelő számot is--

1296
01:03:41,590 --> 01:03:44,650
tényleg csak felüdítő
A diagram azt a diát.

1297
01:03:44,650 --> 01:03:47,010
Tehát mit kell ezeket kérdőjelek lenni?

1298
01:03:47,010 --> 01:03:51,760
>> Nos, kiderült, hogy a második
Egy kell csak lenni az i változó.

1299
01:03:51,760 --> 01:03:53,860
Szeretném látni, hogy a számot.

1300
01:03:53,860 --> 01:03:58,920
És a középső érv
Itt azt lehet mondani, a számítógép

1301
01:03:58,920 --> 01:04:03,470
kezelésére, hogy egész
i, mint egy karaktert, így például

1302
01:04:03,470 --> 01:04:05,880
helyettesítjük, ide százalékos C.

1303
01:04:05,880 --> 01:04:07,990
>> Más szavakkal, ha én, a
emberi programozó, tudom

1304
01:04:07,990 --> 01:04:09,865
ezek csak számok
a nap végén.

1305
01:04:09,865 --> 01:04:12,500
És tudom, hogy a 65 kellene
Térkép néhány karaktert.

1306
01:04:12,500 --> 01:04:15,310
Ezzel explicit öntött,
a zárójel,

1307
01:04:15,310 --> 01:04:18,840
a neve a kívánt adattípust, hogy
konvertálni, és egy zárt zárójel,

1308
01:04:18,840 --> 01:04:21,200
meg tudja mondani a
számítógép, hé, számítógép,

1309
01:04:21,200 --> 01:04:24,130
átalakítani ezt az egész, hogy a char.

1310
01:04:24,130 --> 01:04:26,250
>> Tehát amikor futtatni ezt
programot, miután összeállítása,

1311
01:04:26,250 --> 01:04:29,740
lássuk, mit get-- hogy ASCII 0.

1312
01:04:29,740 --> 01:04:33,020
Fene egye meg, mit csináltam rosszul van?

1313
01:04:33,020 --> 01:04:35,884
A be nem azonosító,
rendben, nem szándékos,

1314
01:04:35,884 --> 01:04:37,800
de lássuk, ha nem tudjuk
ok ezen keresztül.

1315
01:04:37,800 --> 01:04:41,220
>> Így a vezetékben five-- így nem kap
nagyon messze előtt csavarja fel.

1316
01:04:41,220 --> 01:04:42,140
Rendben van.

1317
01:04:42,140 --> 01:04:46,560
Így sor 5 i értéke 65-- látok.

1318
01:04:46,560 --> 01:04:50,130
Úgy emlékszem, hogy a C, ellentétben néhány
nyelvek, ha van korábbi programozási

1319
01:04:50,130 --> 01:04:52,190
tapasztalat, hogy van
közöljük a számítógéppel,

1320
01:04:52,190 --> 01:04:55,040
ellentétben Scratch, milyen
típusú változó van.

1321
01:04:55,040 --> 01:04:56,860
>> És elfelejtettem kulcsfontosságú kifejezést itt.

1322
01:04:56,860 --> 01:04:59,200
Összhangban az öt, amit elkezdtem használni az i.

1323
01:04:59,200 --> 01:05:01,560
De én nem mondtam C
milyen adattípus van.

1324
01:05:01,560 --> 01:05:04,570
Így fogok menni ide, és
mondjuk, ah, hogy ez egy egész szám.

1325
01:05:04,570 --> 01:05:07,050
>> Most megyek, hogy menjen előre és újrafordítani.

1326
01:05:07,050 --> 01:05:08,080
Ez a fix ezt.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 megadása, ez egyfajta hűvös.

1328
01:05:12,660 --> 01:05:15,360
Nem csak ez szuper gyors
kérje a számítógép ezt a kérdést,

1329
01:05:15,360 --> 01:05:18,885
ahelyett fel a dia,
ez kinyomtatható soronként, A 65,

1330
01:05:18,885 --> 01:05:24,860
B 66, egészen down-- mióta
tette ezt 26 times-- a betűk z,

1331
01:05:24,860 --> 01:05:25,630
, amely 90.

1332
01:05:25,630 --> 01:05:27,790
És valóban, enyhén
intelligensebb lenne

1333
01:05:27,790 --> 01:05:31,030
már értem, hogy nem hivatkozhat
A számítógép hozzá 26.

1334
01:05:31,030 --> 01:05:34,060
Azt lehetett volna csak tenni
90 is, így hosszú

1335
01:05:34,060 --> 01:05:37,390
mivel nem teszi ugyanazt a hibát kétszer.

1336
01:05:37,390 --> 01:05:41,880
Azt akarom, hogy menjen fel a
z, nem csak egészen y.

1337
01:05:41,880 --> 01:05:44,000
>> Tehát ez egy explicit öntött.

1338
01:05:44,000 --> 01:05:47,860
Kiderült, hogy ez a
nem is szükséges.

1339
01:05:47,860 --> 01:05:52,480
Hadd menjek előre, és futtassa újra ezt a
fordítóprogram, és újra ASCII 0.

1340
01:05:52,480 --> 01:05:54,940
Kiderült, hogy a C elég okos.

1341
01:05:54,940 --> 01:05:57,150
>> És a printf, különösen,
elég okos.

1342
01:05:57,150 --> 01:06:01,260
Ha csak át egy i kétszer
mindkét helyőrzők printf

1343
01:06:01,260 --> 01:06:04,510
rájönnek, ó, jól tudom, hogy
Adott egy integer-- néhány számot,

1344
01:06:04,510 --> 01:06:06,380
mint 65, vagy 90, vagy bármi más.

1345
01:06:06,380 --> 01:06:10,170
De látom, hogy azt akarja, hogy
formázza azt a számot, mint egy karaktert.

1346
01:06:10,170 --> 01:06:16,460
És így printf is implicit cast
Az int, hogy a char az Ön számára is.

1347
01:06:16,460 --> 01:06:19,360
Tehát ez nem probléma egyáltalán.

1348
01:06:19,360 --> 01:06:23,100
>> De észre, mert ez az egyenértékűség
mi is valójában ezt is.

1349
01:06:23,100 --> 01:06:26,520
Hadd menjek előre, és egy
Más változat this-- ASCII 1.c.

1350
01:06:26,520 --> 01:06:31,800
És ahelyett, hogy az iterációt
egészek, tényleg szédítően

1351
01:06:31,800 --> 01:06:33,610
iterációjával át karaktereket.

1352
01:06:33,610 --> 01:06:37,660
Ha egy char c kap tőke A, I
akar menni előre, és ezt,

1353
01:06:37,660 --> 01:06:41,740
mindaddig, amíg a C-nél kisebb vagy egyenlő,
tőke Z. És minden egyes iteráció

1354
01:06:41,740 --> 01:06:45,690
Szeretnék növelni C, tudok
most már az én printf sorban itt

1355
01:06:45,690 --> 01:06:51,320
mondjuk százalék C
százalékkal megint, vessző C.

1356
01:06:51,320 --> 01:06:57,200
>> És most, mehetek a másik irányba,
öntés a karakter kifejezetten

1357
01:06:57,200 --> 01:06:58,500
hogy egy egész szám.

1358
01:06:58,500 --> 01:07:00,560
Szóval, megint, miért teszed ezt?

1359
01:07:00,560 --> 01:07:03,830
Ez egy kicsit furcsa, hogy egyfajta
száma tekintetében karaktereket.

1360
01:07:03,830 --> 01:07:07,430
>> De ha megérted, mi
folyik a motorháztető alatt,

1361
01:07:07,430 --> 01:07:08,430
már tényleg nincs varázslat.

1362
01:07:08,430 --> 01:07:13,060
Csak azt, hogy, hé, számítógép ad
nekem egy változó nevű C típusú char.

1363
01:07:13,060 --> 01:07:16,520
Inicializálás tőke A. és
észre aposztrófot számít.

1364
01:07:16,520 --> 01:07:19,580
>> Karakterek C, előhívni
múlt héten, akkor egyszerű idézőjeleket.

1365
01:07:19,580 --> 01:07:23,720
Vonósokra, a szavakat,
mondatok, akkor használja dupla idézőjelek közé.

1366
01:07:23,720 --> 01:07:27,210
OK, számítógép, csinálom ezt, így
mindaddig, amíg a karakter kevesebb mint

1367
01:07:27,210 --> 01:07:28,050
vagy egyenlő részt.

1368
01:07:28,050 --> 01:07:32,640
És tudom, hogy az én ASCII tábla, hogy minden
Az ASCII kódok összefüggőek.

1369
01:07:32,640 --> 01:07:33,400
>> Nincs hiányosságok.

1370
01:07:33,400 --> 01:07:36,737
Tehát csak A-Z,
elválasztva egy szám minden.

1371
01:07:36,737 --> 01:07:38,820
És akkor én is növelni
char, ha igazán akar.

1372
01:07:38,820 --> 01:07:40,390
A nap végén,
ez csak egy szám.

1373
01:07:40,390 --> 01:07:41,030
Tudom ezt.

1374
01:07:41,030 --> 01:07:43,670
Így én is csak feltételezik, hogy adjunk 1-et.

1375
01:07:43,670 --> 01:07:46,940
>> És akkor ez az idő, tudok nyomtatni c,
majd a szerves egyenértékű.

1376
01:07:46,940 --> 01:07:50,170
És nem is kell az explicit öntött.

1377
01:07:50,170 --> 01:07:52,680
Azt is hagyja printf és a
számítógép kitalálni a dolgokat,

1378
01:07:52,680 --> 01:07:57,300
így ha most futni
hogy Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Kapok pontosan ugyanaz a dolog is.

1380
01:08:01,520 --> 01:08:04,530
>> Haszontalan program though-- senki
fog valójában írni szoftver

1381
01:08:04,530 --> 01:08:07,549
annak érdekében, hogy kitaláljuk, mi volt a
szám, amely leképezi az A, vagy B, vagy Z?

1382
01:08:07,549 --> 01:08:10,340
Te csak majd a Google, vagy
keresse ki az interneten, vagy keresse ki

1383
01:08:10,340 --> 01:08:11,650
a dia, vagy hasonlók.

1384
01:08:11,650 --> 01:08:13,520
Szóval, ha ez tényleg csak hasznos?

1385
01:08:13,520 --> 01:08:15,960
>> Nos, beszél, hogy
csúszda, észre van

1386
01:08:15,960 --> 01:08:20,890
tényleges minta itt nagybetű közötti
és kisbetű, hogy nem volt véletlen.

1387
01:08:20,890 --> 01:08:23,760
Figyeljük meg, hogy a tőke egy 65.

1388
01:08:23,760 --> 01:08:25,830
Kisbetűs egy 97.

1389
01:08:25,830 --> 01:08:29,649
És milyen messze van kisbetűvel egy?

1390
01:08:29,649 --> 01:08:32,649
>> Tehát 65 hány lépésre a 97?

1391
01:08:32,649 --> 01:08:36,210
Tehát 97 -65 32.

1392
01:08:36,210 --> 01:08:37,910
Tehát a tőke a 65.

1393
01:08:37,910 --> 01:08:39,939
Ha hozzá 32 e,
kapsz egy kisbetűs.

1394
01:08:39,939 --> 01:08:43,729
És ami ezzel egyenértékű, ha kivonni 32,
kapsz vissza tőke egy-- azonos B

1395
01:08:43,729 --> 01:08:46,380
a kis b, nagy C kis c.

1396
01:08:46,380 --> 01:08:50,670
>> Mindezek a hiányosságok 32 egymástól.

1397
01:08:50,670 --> 01:08:54,450
Nos, ez úgy tűnik, hogy lehetővé teszik számunkra, hogy
tenni valamit, mint a Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
vagy a Google Docs szolgáltatás, ahol
kiválaszthatja mindent, majd azt mondják,

1399
01:08:57,729 --> 01:09:00,520
változtatni az összes kisbetű, vagy
változtatni nagybetűs,

1400
01:09:00,520 --> 01:09:03,840
vagy módosítsa csak az első szó
Egy mondat a nagybetűs.

1401
01:09:03,840 --> 01:09:07,390
Mi valóban tenni valamit
mint hogy magunkat.

1402
01:09:07,390 --> 01:09:12,645
>> Hadd menjen előre, és mentse a fájlt
Itt az úgynevezett tőkét 0.c.

1403
01:09:12,645 --> 01:09:15,770
És menjünk előre, és felkap egy programot
hogy pontosan ezt az alábbiak szerint.

1404
01:09:15,770 --> 01:09:18,460
Így többek között a CS50 könyvtár.

1405
01:09:18,460 --> 01:09:21,430
És közé tartoznak a standard I / O.

1406
01:09:21,430 --> 01:09:22,787
>> És tudom, hogy ez hamarosan.

1407
01:09:22,787 --> 01:09:24,870
Így fogok tenni, hogy a
ott már, string.h,

1408
01:09:24,870 --> 01:09:26,960
így van, hogy
dolgok, mint Stirling,

1409
01:09:26,960 --> 01:09:29,620
majd int fő érvénytelen, a szokásos módon.

1410
01:09:29,620 --> 01:09:33,420
Aztán megyek előre
és nem kap húrok kap húr,

1411
01:09:33,420 --> 01:09:35,032
csak azért, hogy egy string a felhasználótól.

1412
01:09:35,032 --> 01:09:36,740
És akkor megyek
csinálni a biztonsági ellenőrzést.

1413
01:09:36,740 --> 01:09:40,510
Ha a string nem egyenlő nulla,
akkor ez biztos, hogy folytassa.

1414
01:09:40,510 --> 01:09:42,000
És mit akarok?

1415
01:09:42,000 --> 01:09:48,700
Megyek iterálására re az i értéke 0,
és n egészen a húr hossza s.

1416
01:09:48,700 --> 01:09:51,899
>> És én fogom ezt mindaddig, amíg
i kisebb mint n, és én plusz plusz.

1417
01:09:51,899 --> 01:09:55,060
Eddig én tényleg csak
hitelfelvétel ötletek előtt.

1418
01:09:55,060 --> 01:09:57,010
És most megyek, hogy vezessenek be egy ág.

1419
01:09:57,010 --> 01:09:59,635
>> Tehát úgy gondolja, vissza Scratch, ahol
mi volt az említett villa az úton,

1420
01:09:59,635 --> 01:10:05,110
és a múlt héten a C. fogok
mondani, ha az i-edik karaktert s

1421
01:10:05,110 --> 01:10:09,250
nagyobb vagy
egyenlő kisbetűs egy,

1422
01:10:09,250 --> 01:10:13,340
és-- a Scratch tenné szó
hangoztatták, de a C-jel azt mondja,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- és az i-edik karaktert s
kisebb, vagy egyenlő, mint az alacsonyabb esetben Z,

1424
01:10:19,830 --> 01:10:21,780
csináljunk valami érdekeset.

1425
01:10:21,780 --> 01:10:27,020
Nézzük ténylegesen ki kell nyomtatni egy
karakter nem új sor

1426
01:10:27,020 --> 01:10:31,760
ez a karakterhez,
az i-edik karakterhez.

1427
01:10:31,760 --> 01:10:37,420
>> De menjünk előre, és
vonjuk 32 belőle.

1428
01:10:37,420 --> 01:10:42,120
Különben, ha a karaktert a
karakterlánc, amit keresünk

1429
01:10:42,120 --> 01:10:45,950
nem közötti kicsiny
és a kis z, megy előre

1430
01:10:45,950 --> 01:10:48,610
és csak kinyomtatta változatlan.

1431
01:10:48,610 --> 01:10:50,840
Így már bevezetett
ez zárójeles jelölés

1432
01:10:50,840 --> 01:10:53,560
mi húrok, hogy a
i-edik karakterhez.

1433
01:10:53,560 --> 01:10:57,520
>> Adtam néhány feltételes logika, mint a
Scratch a múlt heti első héten, ahol

1434
01:10:57,520 --> 01:10:59,880
Csak az általam alapvető
megértheti, hogy mit

1435
01:10:59,880 --> 01:11:01,130
folyik a motorháztető alatt.

1436
01:11:01,130 --> 01:11:04,190
Az i-edik karaktere s
nagyobb vagy egyenlő, mint egy?

1437
01:11:04,190 --> 01:11:08,290
Mint, ez 97, illetve 98,
vagy 99, és így tovább?

1438
01:11:08,290 --> 01:11:11,940
>> De ez is kisebb vagy egyenlő
az értéke kisbetűs Z?

1439
01:11:11,940 --> 01:11:16,210
És ha igen, mit jelent ez a vonal jelent?

1440
01:11:16,210 --> 01:11:20,250
14, ez a fajta a
csírája az egész ötlet,

1441
01:11:20,250 --> 01:11:23,840
nagybetűvel levelét
egyszerűen kivonjuk 32 belőle,

1442
01:11:23,840 --> 01:11:29,370
ebben az esetben, mert tudom, hogy a per
chart, milyen a számok képviselik.

1443
01:11:29,370 --> 01:11:33,925
Szóval menjünk előre, és futtatni ezt,
fordítás után tőkét 0.c,

1444
01:11:33,925 --> 01:11:36,210
és futás tőkét 0.

1445
01:11:36,210 --> 01:11:40,300
>> Nézzük írja be valami hasonló
Zamyla minden kisbetűvel adja.

1446
01:11:40,300 --> 01:11:42,780
És most már Zamyla minden nagybetűs.

1447
01:11:42,780 --> 01:11:45,050
Nézzük írja Rob minden kisbetűvel.

1448
01:11:45,050 --> 01:11:46,674
Próbáljuk Jason csupa kisbetűvel.

1449
01:11:46,674 --> 01:11:48,590
És folyton a
kénytelen nagybetűk.

1450
01:11:48,590 --> 01:11:50,960
Van egy kisebb hiba, ami azt
fajta nem számítottak.

1451
01:11:50,960 --> 01:11:54,050
Figyeljük meg az új prompt kiöntött
ugyanazon a vonalon, mint a nevüket,

1452
01:11:54,050 --> 01:11:55,520
ami egy kicsit rendetlen.

1453
01:11:55,520 --> 01:11:59,170
>> Így fogok menni itt, és
valójában a végén ez a program

1454
01:11:59,170 --> 01:12:02,110
kinyomtatni egy újsor karaktert.

1455
01:12:02,110 --> 01:12:03,160
Ez minden.

1456
01:12:03,160 --> 01:12:06,120
A printf, akkor nem kell, hogy
át a változókat, illetve formátumban kódot.

1457
01:12:06,120 --> 01:12:08,460
Akkor szó csak nyomtatni
olyasmi, mint egy új sort.

1458
01:12:08,460 --> 01:12:13,529
>> Szóval menjünk előre, és
tőkét ismét 0, futtassa meg, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
És most ez egy kicsit szebb.

1460
01:12:14,820 --> 01:12:17,274
Most, a prompt saját új sort.

1461
01:12:17,274 --> 01:12:18,440
Szóval ez mind szép és jó.

1462
01:12:18,440 --> 01:12:19,910
Tehát ez egy jó példa.

1463
01:12:19,910 --> 01:12:22,700
De én nem is feltétlenül
kell keményen kódot a 32.

1464
01:12:22,700 --> 01:12:23,350
Tudod mit?

1465
01:12:23,350 --> 01:12:26,350
Tudtam say-- én soha nem
emlékszem, mi a különbség.

1466
01:12:26,350 --> 01:12:29,330
>> De azt tudom, hogy ha
Van egy kisbetű,

1467
01:12:29,330 --> 01:12:34,430
Azt lényegében kivonni kívánt off
a távolságtól függetlenül között kevés

1468
01:12:34,430 --> 01:12:39,160
egy, nagy A, mert ha azt feltételezem, hogy
az összes többi betű azonos,

1469
01:12:39,160 --> 01:12:41,045
hogy kell a munkát.

1470
01:12:41,045 --> 01:12:42,670
De ahelyett, hogy erre, tudod mit?

1471
01:12:42,670 --> 01:12:44,240
Van egy másik út is.

1472
01:12:44,240 --> 01:12:48,090
>> Ha ez tőkét 1.c-- ha én
tenni, hogy egy külön fájlba.

1473
01:12:48,090 --> 01:12:51,030
Csináljuk kihasználni 2.c a következő.

1474
01:12:51,030 --> 01:12:53,060
Megyek igazán tiszta ez itt.

1475
01:12:53,060 --> 01:12:57,420
És ahelyett, hogy is kelljen
tudja, vagy érdekel az alacsony szintű

1476
01:12:57,420 --> 01:13:01,090
végrehajtásának részleteit, én inkább
csak fog nyomtatni egy karaktert,

1477
01:13:01,090 --> 01:13:04,610
idézet idézőjel bezárva, százalék C, és
majd hívja a másik funkciója, hogy

1478
01:13:04,610 --> 01:13:09,950
van arra, hogy vesz egy érv,
amely egy karakter, mint ez.

1479
01:13:09,950 --> 01:13:12,630
>> Kiderül a C, van
Egy másik funkció hívás

1480
01:13:12,630 --> 01:13:15,550
A felső, amely mint a neve
javasolja, vesz egy karakter

1481
01:13:15,550 --> 01:13:19,350
és teszi, hogy a felső eset
egyenértékű, majd visszaadja

1482
01:13:19,350 --> 01:13:21,410
így printf dugja be oda.

1483
01:13:21,410 --> 01:13:25,484
És így, hogy ezt is, azt
kell bevezetni egy másik fájlt.

1484
01:13:25,484 --> 01:13:28,400
Kiderült, van egy másik fájl
hogy csak tudjuk, osztály,

1485
01:13:28,400 --> 01:13:33,020
vagy egy tankönyv, vagy egy online
hivatkozás, az úgynevezett C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Tehát ha én hozzá, hogy többek között az én fejléc
fájlokat, és most újra fordítani ezt a programot,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Nézzük írja Zamyla minden
kisbetűs is ugyanúgy működik.

1489
01:13:46,690 --> 01:13:48,040
De tudod mit?

1490
01:13:48,040 --> 01:13:55,590
Kiderül, hogy a felső
van néhány egyéb funkciókat.

1491
01:13:55,590 --> 01:13:58,410
>> És hadd mutassam be ezt a
parancs van, egyfajta ügyetlenül

1492
01:13:58,410 --> 01:14:00,250
elemzi, de az ember a kézi.

1493
01:14:00,250 --> 01:14:03,960
Kiderült, hogy a legtöbb Linux számítógépen,
mint mi használ here-- Linux operációs

1494
01:14:03,960 --> 01:14:06,270
system-- bírni
nevű ember, ami azt mondja,

1495
01:14:06,270 --> 01:14:08,530
hé, számítógép, adj
A számítógép kézikönyvében.

1496
01:14:08,530 --> 01:14:10,680
mit szeretnél
felnéz, hogy a kézi?

1497
01:14:10,680 --> 01:14:13,840
>> Azt akarom, hogy néz ki a funkciót
az úgynevezett felső, Enter.

1498
01:14:13,840 --> 01:14:16,070
És ez egy kicsit rejtélyes
olvasni néha.

1499
01:14:16,070 --> 01:14:18,780
De észre mi vagyunk a
Linux programozó kézikönyvében.

1500
01:14:18,780 --> 01:14:19,530
És ez az egész szöveget.

1501
01:14:19,530 --> 01:14:21,905
És észre, hogy ott van a
függvény nevét itt.

1502
01:14:21,905 --> 01:14:25,030
Kiderült, hogy van egy unokatestvére úgynevezett
alacsonyabb, ami az ellenkezőjét teszi.

1503
01:14:25,030 --> 01:14:29,710
És értesítés mellett szinopszis, hogy használja ezt a
működni a man oldalon, hogy úgy mondjam,

1504
01:14:29,710 --> 01:14:32,220
azt mondja, hogy én
tartalmazniuk kell c type.h.

1505
01:14:32,220 --> 01:14:33,630
És tudtam, hogy a gyakorlat során.

1506
01:14:33,630 --> 01:14:36,210
>> Itt, ez megmutatta a két
prototípusok a funkció,

1507
01:14:36,210 --> 01:14:39,070
így ha valaha szeretné használni ezt a
Tudom, hogy mit tegyen a bemenet,

1508
01:14:39,070 --> 01:14:40,652
és mit visszatérni a kibocsátás.

1509
01:14:40,652 --> 01:14:42,360
És aztán, ha elolvastam
A leírás, látom

1510
01:14:42,360 --> 01:14:44,820
részletesebben, amit a függvény.

1511
01:14:44,820 --> 01:14:48,100
De még ennél is fontosabb, ha
Nézek alatt visszatérési értéke,

1512
01:14:48,100 --> 01:14:51,710
azt mondja, a visszaadott érték
hogy a konvertált levél,

1513
01:14:51,710 --> 01:14:57,880
vagy C, az eredeti input, ha
az átalakítás nem volt lehetséges.

1514
01:14:57,880 --> 01:15:01,992
>> Más szóval, a felső megpróbálja
átalakítani írni nagybetűs.

1515
01:15:01,992 --> 01:15:03,450
És ha igen, ez meg fog visszaadni.

1516
01:15:03,450 --> 01:15:07,010
De ha nem sikerül valami reason--
Talán ez már nagybetű,

1517
01:15:07,010 --> 01:15:09,550
talán ez egy felkiáltójel
vagy valamilyen más punctuation--

1518
01:15:09,550 --> 01:15:12,200
ez csak fog
vissza az eredeti C,

1519
01:15:12,200 --> 01:15:17,340
ami azt jelenti, lehet, hogy az én-kód
jobban megtervezett az alábbiak szerint.

1520
01:15:17,340 --> 01:15:20,580
>> Nem kell az összes
ezek rohadt sornyi kódot.

1521
01:15:20,580 --> 01:15:22,610
Összes vonalat I ve
Csak kiemelt lehet

1522
01:15:22,610 --> 01:15:28,700
összecsukható kis csak egy egyszerű
vonal, amely a this-- printf százalék

1523
01:15:28,700 --> 01:15:33,510
c felső S konzol i.

1524
01:15:33,510 --> 01:15:36,090
És ez lenne egy
Például a jobb tervezés.

1525
01:15:36,090 --> 01:15:40,040
>> Miért végre 7 vagy 8 sor
A kód, bármi is volt csak

1526
01:15:40,040 --> 01:15:44,960
törölve, ha lehet inkább összeomlik
minden, hogy a logika és a döntéshozatal

1527
01:15:44,960 --> 01:15:49,620
egyetlen tétel, 13 most, hogy
támaszkodik a könyvtár function--

1528
01:15:49,620 --> 01:15:53,430
függvényében, hogy jön a C, de ez
pontosan mit szeretne csinálni.

1529
01:15:53,430 --> 01:15:55,295
És, őszintén szólva, még ha
ez nem jött a C,

1530
01:15:55,295 --> 01:15:58,880
akkor végre magad, mint
láttunk, és kap negatív int

1531
01:15:58,880 --> 01:16:01,700
és kap pozitív int a múlt héten is.

1532
01:16:01,700 --> 01:16:03,470
>> Ez a kód most is sokkal olvashatóbb.

1533
01:16:03,470 --> 01:16:06,670
És valóban, ha felfelé,
nézd, milyen sokkal kompaktabb

1534
01:16:06,670 --> 01:16:08,360
ez a verzió az én program.

1535
01:16:08,360 --> 01:16:11,230
Ez egy kicsit fejnehéz most,
mindezeket magában foglalja.

1536
01:16:11,230 --> 01:16:14,380
De ez rendben van, mert most én állok
a vállán programozók

1537
01:16:14,380 --> 01:16:15,300
előttem.

1538
01:16:15,300 --> 01:16:18,440
És bárki is volt, aki
végrehajtani, hogy a felső igazán

1539
01:16:18,440 --> 01:16:21,470
tett nekem egy szívességet, ugyanúgy, mint bárki
megvalósított Stirling igazán

1540
01:16:21,470 --> 01:16:24,790
tett nekem egy szívességet néhány évvel ezelőtt.

1541
01:16:24,790 --> 01:16:26,970
És így most van egy
jobb tervezési program

1542
01:16:26,970 --> 01:16:31,680
amely végrehajtja a pontos ugyanaz a logika.

1543
01:16:31,680 --> 01:16:35,580
>> Apropó Stirling, hadd
menjek előre, és erre a célra.

1544
01:16:35,580 --> 01:16:38,320
Hadd menjek előre, és mentse
ezt a fájlt stirling.c.

1545
01:16:38,320 --> 01:16:43,255
És kiderül, mi is húzza vissza
Egy másik réteg elég egyszerűen most.

1546
01:16:43,255 --> 01:16:45,630
Megyek, hogy menjen előre és ostor
egy másik program fő

1547
01:16:45,630 --> 01:16:49,759
hogy itt egyszerűen újra munkagépek
karakterlánchossz a következő.

1548
01:16:49,759 --> 01:16:52,300
Tehát itt egy sor kód, amely
elkap egy húr a felhasználótól.

1549
01:16:52,300 --> 01:16:53,910
Tartjuk használja ezt újra és újra.

1550
01:16:53,910 --> 01:16:58,900
Hadd hozzak magamnak egy változó nevű
n int típusú, hogy egy számot tárol.

1551
01:16:58,900 --> 01:17:02,490
>> És hadd menjen előre, és
hajtsa végre a következő logika.

1552
01:17:02,490 --> 01:17:15,610
Míg az N-edik karaktert s tesz
nem egyenlő backslash 0, megy előre

1553
01:17:15,610 --> 01:17:17,930
megnöveli eggyel n.

1554
01:17:17,930 --> 01:17:23,506
Majd nyomtassa ki a printf százalék i n.

1555
01:17:23,506 --> 01:17:29,200
Azt állítják, hogy ez a program itt
anélkül húr hossza,

1556
01:17:29,200 --> 01:17:31,150
kitalálja a karakterlánc hosszát.

1557
01:17:31,150 --> 01:17:34,600
>> És a varázslat teljesen
kapszulázott sor 8

1558
01:17:34,600 --> 01:17:39,830
Itt a mi újszerű szintaxis,
ez backslash 0 aposztrófok.

1559
01:17:39,830 --> 01:17:41,360
De miért van ez?

1560
01:17:41,360 --> 01:17:44,100
Nos, fontolja meg, milyen volt
folyik ebben az időben.

1561
01:17:44,100 --> 01:17:47,990
>> És félre mielőtt elfelejtem, észre
is, hogy amellett, hogy a man oldalakat

1562
01:17:47,990 --> 01:17:50,920
hogy jön egy tipikus
Linux rendszer, mint a CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
észre, hogy mi, a
Természetesen munkatársai, szintén

1564
01:17:53,770 --> 01:17:56,030
tett egy weboldal verzió
Ugyanennek a gondolat az úgynevezett

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, amely
hogy ezekben az ember oldalakat,

1566
01:17:59,940 --> 01:18:02,020
minden, hogy ugyanazon
dokumentáció, valamint a

1567
01:18:02,020 --> 01:18:05,730
egy kis doboz tetején, amely lehetővé teszi
hogy konvertálni az összes meglehetősen

1568
01:18:05,730 --> 01:18:09,025
misztikus nyelvről kevésbé kényelmes
mód, ahol mi, a nevelőtestület,

1569
01:18:09,025 --> 01:18:12,150
mentek keresztül, és megpróbálta, hogy egyszerűsítse
egyes nyelvi tartani a dolgokat

1570
01:18:12,150 --> 01:18:14,830
összpontosított gondolatok, és nem
néhány technikai részletekkel.

1571
01:18:14,830 --> 01:18:20,070
Tehát ne feledje, reference.cs50.net
mint egy másik forrás is.

1572
01:18:20,070 --> 01:18:23,800
>> De miért húr hossza munka
ahogy én javasolt egy perce?

1573
01:18:23,800 --> 01:18:25,160
Itt Zamyla nevét újra.

1574
01:18:25,160 --> 01:18:27,690
És itt van Zamyla neve
dobozos, ahogy csinálom,

1575
01:18:27,690 --> 01:18:31,360
festeni egy képet róla, hogy,
tényleg, csak egy karaktersorozat.

1576
01:18:31,360 --> 01:18:34,260
De Zamyla nem létezik
elszigetelten a programban.

1577
01:18:34,260 --> 01:18:37,420
>> Amikor írsz, és futtatni egy programot,
Ön használja a Mac vagy a PC

1578
01:18:37,420 --> 01:18:40,010
például a memória, vagy a RAM úgy mondjam.

1579
01:18:40,010 --> 01:18:42,620
És azt lehet gondolni
A számítógép, mint amelyek

1580
01:18:42,620 --> 01:18:44,730
sok gigabájt memóriával ezekben a napokban.

1581
01:18:44,730 --> 01:18:47,700
És egy koncert jelenti milliárd,
így több milliárd bájt.

1582
01:18:47,700 --> 01:18:48,910
>> De nézzük a visszatekerés az időben.

1583
01:18:48,910 --> 01:18:51,530
És tegyük fel, hogy mi használ
egy nagyon régi számítógépen

1584
01:18:51,530 --> 01:18:55,150
csak 32 bájt memóriát.

1585
01:18:55,150 --> 01:18:59,310
Tudtam, az én számítógép képernyőjén,
egyszerűen felhívni a következőképpen.

1586
01:18:59,310 --> 01:19:05,240
>> Tudtam csak mondani, hogy az én
számítógép mindezt memóriát.

1587
01:19:05,240 --> 01:19:08,830
És ez olyan, mint egy bottal a memória, ha
Emlékszik a képet utoljára.

1588
01:19:08,830 --> 01:19:11,670
És ha én csak osztani
ezt elégszer

1589
01:19:11,670 --> 01:19:15,040
Azt állítják, hogy van 32 bájt
memória a képernyőn.

1590
01:19:15,040 --> 01:19:18,239
>> Most, a valóságban, én csak
felhívni eddig ezen a képernyőn van.

1591
01:19:18,239 --> 01:19:20,280
Így fogok menni előre,
és csak a konvenció,

1592
01:19:20,280 --> 01:19:24,050
felhívni a számítógép memóriájában, mint a
rács, nem csak egy egyenes vonal.

1593
01:19:24,050 --> 01:19:28,190
Konkrétan azt állítják, hogy most
ez a rács, ez 8 x 4 rács,

1594
01:19:28,190 --> 01:19:31,800
csak képviseli az összes 32 byte
a rendelkezésre álló memóriának a Mac,

1595
01:19:31,800 --> 01:19:33,030
vagy elérhető a PC.

1596
01:19:33,030 --> 01:19:34,780
És ők csomagolópapír
A két sorban, csak

1597
01:19:34,780 --> 01:19:38,030
mert illik jobban a képernyőn.

1598
01:19:38,030 --> 01:19:40,800
De ez az első bájt.

1599
01:19:40,800 --> 01:19:41,990
Ez a második byte.

1600
01:19:41,990 --> 01:19:43,300
Ez a harmadik bájt.

1601
01:19:43,300 --> 01:19:45,310
>> És ez a 32. byte.

1602
01:19:45,310 --> 01:19:52,910
Vagy, ha azt gondoljuk, mint egy számítógép
tudós, ez bájt 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Így van, 0-31, ha
elkezdi a számlálást 0.

1604
01:19:55,950 --> 01:19:59,830
>> Tehát, ha egy program használatához
hogy a hívások kap húr,

1605
01:19:59,830 --> 01:20:05,280
és kapunk egy stringet az emberi
mint én az úgynevezett Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
hogy a világ nem a
számítógép, hogy melyik byte,

1607
01:20:09,430 --> 01:20:12,230
amely darab memória,
tartozik, amely húr?

1608
01:20:12,230 --> 01:20:16,270
Más szóval, ha folytassa
írjon be egy másik nevet a számítógéphez,

1609
01:20:16,270 --> 01:20:19,890
így Andi, amelyben
A string másodszor,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I, hogy a végén a
számítógép memóriája is.

1611
01:20:23,030 --> 01:20:23,850
De hogyan?

1612
01:20:23,850 --> 01:20:29,700
>> Nos, kiderült, hogy alatta a
motorháztető, mit csinál, amikor C tárolására húrok

1613
01:20:29,700 --> 01:20:35,080
hogy az emberi típusok in, vagy azt, hogy
származik más forrásból, ez

1614
01:20:35,080 --> 01:20:39,190
Ismerteti a végén őket
különleges character-- backslash

1615
01:20:39,190 --> 01:20:44,750
0, ami csak egy speciális módon
mondván 80 bites egy sorban.

1616
01:20:44,750 --> 01:20:47,950
>> Tehát egy-- ez a szám 97 visszahívás.

1617
01:20:47,950 --> 01:20:51,770
Így néhány mintát a 8 bit
jelentése decimális szám 97.

1618
01:20:51,770 --> 01:20:58,070
Ez backslash 0 szó száma
0, más néven nul, N-U-L, ellentétben a korábbi,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, amit beszéltünk.

1620
01:20:59,630 --> 01:21:05,700
De most, csak tudom, hogy ez a
backslash 0 mindössze 80 bit egy sorban.

1621
01:21:05,700 --> 01:21:09,810
>> És ez csak ebben a sorban a
homok, hogy nem mond semmit, hogy a bal oldali

1622
01:21:09,810 --> 01:21:12,610
tartozik egy húr, vagy egy adattípust.

1623
01:21:12,610 --> 01:21:15,480
És bármi jobbra
tartozik valami mást.

1624
01:21:15,480 --> 01:21:17,440
Andi nevét, eközben
amelyek csak vizuálisan

1625
01:21:17,440 --> 01:21:21,310
előfordul, hogy lezárja be a másik vonalon,
de ez csak esztétikai részlet,

1626
01:21:21,310 --> 01:21:23,990
Hasonlóan van nul megszűnik.

1627
01:21:23,990 --> 01:21:29,290
>> Ez egy sor egy A-N-D-I karakterek,
és egy ötödik titkos karakter,

1628
01:21:29,290 --> 01:21:33,560
minden 0 bit, hogy csak behatároló
vége Andi nevét is.

1629
01:21:33,560 --> 01:21:37,120
És ha hívjuk kap húr harmadik alkalommal
a számítógép kap egy string, mint

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, hasonlóan a Maria
név nul végződő backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Ez alapvetően eltérő
attól, ahogy a számítógép jellemzően

1632
01:21:47,170 --> 01:21:51,850
tárolni egy egész, vagy egy úszó vagy egyéb
adattípusok is, mert emlékszem,

1633
01:21:51,850 --> 01:21:57,420
egy egész általában 32 bit, vagy
4 byte, vagy akár 64 bit,

1634
01:21:57,420 --> 01:21:59,100
vagy nyolc byte.

1635
01:21:59,100 --> 01:22:02,620
De sok primitívek egy számítógépes
egy programozási nyelv

1636
01:22:02,620 --> 01:22:05,550
Van egy meghatározott számú
byte alatt hood--

1637
01:22:05,550 --> 01:22:08,100
talán 1, talán 2, talán 4, talán 8.

1638
01:22:08,100 --> 01:22:13,250
>> De húrok, a design, van egy
dinamikus karakterek száma.

1639
01:22:13,250 --> 01:22:16,980
Nem tudja előre, amíg
az emberi típusok in Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
vagy M-A-R-I-A, vagy A-N-D-I. Nem tudod,
hányszor a felhasználó fog ütni

1641
01:22:21,400 --> 01:22:22,070
a billentyűzet.

1642
01:22:22,070 --> 01:22:26,490
Ezért nem tudom, hogyan
sok karaktert előre

1643
01:22:26,490 --> 01:22:27,540
te lesz szüksége.

1644
01:22:27,540 --> 01:22:31,840
>> És így a C csak egyfajta hagy, mint egy
titkos morzsa a motorháztető alatt

1645
01:22:31,840 --> 01:22:32,960
a végén a húr.

1646
01:22:32,960 --> 01:22:39,280
Tárolása után Z-A-M-Y-L-A memóriában
ez is csak hozza az egyenértékű

1647
01:22:39,280 --> 01:22:40,210
időszak.

1648
01:22:40,210 --> 01:22:45,060
Végén egy mondat,
ez hozza a 80 bit, így

1649
01:22:45,060 --> 01:22:49,120
visszaemlékezni, hol
Zamyla kezdődik és végződik.

1650
01:22:49,120 --> 01:22:51,490
>> Tehát mi a kapcsolat,
majd, hogy ez a program?

1651
01:22:51,490 --> 01:22:55,190
Ez a program itt, Stirling,
egyszerűen egy mechanizmus

1652
01:22:55,190 --> 01:22:57,970
kapok egy húr
a felhasználó, 6. sor.

1653
01:22:57,970 --> 01:23:01,160
7. sor, azt, hogy egy változót
úgynevezett n és állítsa 0-val egyenlő.

1654
01:23:01,160 --> 01:23:08,680
>> És akkor a 8. sorban, egyszerűen kérték, a
kérdés, míg az N-edik karakter nem

1655
01:23:08,680 --> 01:23:12,120
nem egyenlő az összes 0 bits--
Más szavakkal, nem

1656
01:23:12,120 --> 01:23:14,500
egyenlő ez a különleges
karakter, backslash 0, ami

1657
01:23:14,500 --> 01:23:18,470
éppen, hogy különleges nul character--
megy előre, és csak növelni n.

1658
01:23:18,470 --> 01:23:21,460
>> És folyamatosan csinálja, és tartsa
csinálja, és csinálom azt.

1659
01:23:21,460 --> 01:23:23,430
És még akkor is a
A múltban már használt i,

1660
01:23:23,430 --> 01:23:25,181
ez tökéletesen
szemantikailag használni n,

1661
01:23:25,181 --> 01:23:27,430
ha csak próbál
gróf ezúttal szándékosan,

1662
01:23:27,430 --> 01:23:28,720
és csak akar nevezni n.

1663
01:23:28,720 --> 01:23:34,720
Tehát ez csak folyamatosan kérdezi a kérdést,
az N-edik karaktere s minden 0s?

1664
01:23:34,720 --> 01:23:38,470
Ha nem, akkor nézd a következő megjelenés,
meg, hogy a következő, meg a következő,

1665
01:23:38,470 --> 01:23:39,460
meg, hogy a következő.

1666
01:23:39,460 --> 01:23:45,540
>> De amint látod backslash 0,
ez loop-- sor 9-től 11-- leáll.

1667
01:23:45,540 --> 01:23:49,640
Akkor kitör a while ciklus,
így aztán az n változó

1668
01:23:49,640 --> 01:23:54,530
teljes száma az összes érintett
sztring karaktereinek láttál,

1669
01:23:54,530 --> 01:23:55,660
ezáltal a nyomtatást ki.

1670
01:23:55,660 --> 01:23:56,760
Tehát próbáljuk meg.

1671
01:23:56,760 --> 01:23:59,500
>> Hadd menjek előre, és anélkül,
a Stirling funkció,

1672
01:23:59,500 --> 01:24:04,240
de csak a saját házi verzió
Itt az úgynevezett Stirling, hadd menjen előre

1673
01:24:04,240 --> 01:24:07,700
és fuss Stirling, írja be valamit
mint Zamyla, ami tudom, hogy előre

1674
01:24:07,700 --> 01:24:08,670
hat karakter.

1675
01:24:08,670 --> 01:24:10,080
Nézzük meg, hogy működik.

1676
01:24:10,080 --> 01:24:10,920
Valóban, ez hat.

1677
01:24:10,920 --> 01:24:15,257
Próbáljuk Rob, a három karakter,
három karakter is, és így tovább.

1678
01:24:15,257 --> 01:24:17,340
Annak érdekében, hogy minden, ami megy
az alatt a motorháztető.

1679
01:24:17,340 --> 01:24:19,548
És észre a kapcsolatot,
Aztán, az első héten

1680
01:24:19,548 --> 01:24:22,370
osztály, ahol beszélgettünk
olyasmi, mint absztrakció,

1681
01:24:22,370 --> 01:24:26,960
ami csak ezt a réteg a gondolatok, vagy
komplexitás, a tetején alapelvek.

1682
01:24:26,960 --> 01:24:30,710
Itt vagyunk a fajta keres
a motorháztető alatt a Stirling,

1683
01:24:30,710 --> 01:24:33,510
hogy úgy mondjam, hogy kitaláljuk,
hogyan lenne megvalósítható?

1684
01:24:33,510 --> 01:24:35,232
>> És nem tudtuk újra végrehajtani magunk.

1685
01:24:35,232 --> 01:24:37,440
De mi soha többé megy
hogy újra végrehajtani Stirling.

1686
01:24:37,440 --> 01:24:39,780
Mi csak most fog
használja Stirling érdekében

1687
01:24:39,780 --> 01:24:42,100
hogy valóban kap néhány szálat hosszát.

1688
01:24:42,100 --> 01:24:44,200
>> De nincs mágikus
a motorháztető alatt.

1689
01:24:44,200 --> 01:24:46,716
Ha tudja, hogy alatta
A motorháztető, a húr

1690
01:24:46,716 --> 01:24:48,090
csak egy karaktersorozat.

1691
01:24:48,090 --> 01:24:51,090
És ez a karaktersorozat
minden lehet számszerűen foglalkozni

1692
01:24:51,090 --> 01:24:53,330
tartóval 0, konzol
1, 2 merevítő, és

1693
01:24:53,330 --> 01:24:57,420
tudom, hogy a végén egy string egy
speciális karakter, akkor kitaláljuk,

1694
01:24:57,420 --> 01:25:01,710
hogyan kell csinálni a legtöbb semmit egy
programot, mert minden csapódik le, hogy

1695
01:25:01,710 --> 01:25:03,400
olvas és ír memóriát.

1696
01:25:03,400 --> 01:25:06,130
Azaz, a változó és keres
A memória, vagy a mozgó dolgokat

1697
01:25:06,130 --> 01:25:10,940
körül a memóriában, nyomdai dolgok
a képernyőn, és így tovább.

1698
01:25:10,940 --> 01:25:14,800
>> Szóval, most már ezzel az újonnan
megértésének húrok ténylegesen

1699
01:25:14,800 --> 01:25:17,910
vannak a motorháztető alatt, és
húzza vissza egy másik réteggel

1700
01:25:17,910 --> 01:25:20,080
hogy mostanáig voltunk
már nem vette figyelembe.

1701
01:25:20,080 --> 01:25:22,650
Különösen bármikor
már végre egy programot,

1702
01:25:22,650 --> 01:25:25,930
ezt már a kódsort
felső nyilvánító fő.

1703
01:25:25,930 --> 01:25:27,810
És mi meg int main semmis.

1704
01:25:27,810 --> 01:25:31,240
>> És hogy semmis a zárójelek
van is mondtam ebben az időben fő

1705
01:25:31,240 --> 01:25:33,440
önmagában nem hoz érveket.

1706
01:25:33,440 --> 01:25:36,210
Bármely ráfordítás hogy fő az
fog kapni a felhasználó

1707
01:25:36,210 --> 01:25:39,020
kell származnia más
mechanizmus, mint például get int,

1708
01:25:39,020 --> 01:25:42,040
vagy kap float, vagy kap húr,
vagy más funkció.

1709
01:25:42,040 --> 01:25:44,710
De kiderül, hogy
ha írsz egy programot,

1710
01:25:44,710 --> 01:25:47,690
akkor valóban meghatározza
hogy ez a program kell

1711
01:25:47,690 --> 01:25:51,730
vegye bemenetek az emberi
a parancssorban is.

1712
01:25:51,730 --> 01:25:56,310
>> Más szóval, még akkor is, eddig
már fut csak ./hello szia

1713
01:25:56,310 --> 01:26:00,312
vagy hasonló programokkal, az összes
Más programok, amin felhasználásával,

1714
01:26:00,312 --> 01:26:02,770
hogy mi magunk nem írni,
megtették, úgy tűnik,

1715
01:26:02,770 --> 01:26:05,210
parancssor arguments--
dolgok, mint a make.

1716
01:26:05,210 --> 01:26:07,450
Azt mondják, valami hasonló gyártmányú,
majd egy másik szót.

1717
01:26:07,450 --> 01:26:10,950
Vagy csengés, azt mondják csenget, majd
A második szó, a fájl neve.

1718
01:26:10,950 --> 01:26:14,410
>> Vagy még RM vagy CP, ahogy az
látott vagy felhasznált már

1719
01:26:14,410 --> 01:26:15,880
eltávolításához vagy fájlokat másolni.

1720
01:26:15,880 --> 01:26:18,920
Az összes ilyen vesz úgynevezett
parancssor arguments--

1721
01:26:18,920 --> 01:26:21,130
további szavakat a parancsot.

1722
01:26:21,130 --> 01:26:23,260
De egészen mostanáig, mi
magunk nem volt

1723
01:26:23,260 --> 01:26:27,080
ez a luxus figyelembe bemenet az
felhasználó, ha ő valóban fut

1724
01:26:27,080 --> 01:26:29,120
A program maga a parancssorban.

1725
01:26:29,120 --> 01:26:33,710
>> De nem tehetünk, hogy az újbóli nyilvánításáról
Fő halad előre, nem rendelkező

1726
01:26:33,710 --> 01:26:36,750
semmissé zárójelben,
de ez a két érv

1727
01:26:36,750 --> 01:26:40,600
instead-- az első egész szám,
és a második valami

1728
01:26:40,600 --> 01:26:44,170
új, amit mi fogunk hívni
tömb, valami hasonló szellemben

1729
01:26:44,170 --> 01:26:49,220
hogy mit láttunk Scratch listaként, hanem
egy tömböt, ahogy hamarosan látni.

1730
01:26:49,220 --> 01:26:51,790
De nézzük ezt
Példaképpen, mielőtt

1731
01:26:51,790 --> 01:26:53,690
megkülönböztetni, hogy pontosan mit is jelent.

1732
01:26:53,690 --> 01:26:56,520
>> Tehát ha bemegyek CS50 IDE
Itt Bátorkodtam

1733
01:26:56,520 --> 01:27:01,840
és kijelentette nevű fájlt
argv0.c a következő sablont.

1734
01:27:01,840 --> 01:27:04,120
És vegyük észre az egyetlen dolog,
ez más eddig

1735
01:27:04,120 --> 01:27:08,570
az, hogy én változtam void int
argc húr az argv nyitva tartó, szoros

1736
01:27:08,570 --> 01:27:09,070
zárójel.

1737
01:27:09,070 --> 01:27:11,730
És észre most, van
benne semmi ilyen zárójelben.

1738
01:27:11,730 --> 01:27:12,620
>> Nincs több.

1739
01:27:12,620 --> 01:27:15,070
És nincs i, vagy
N, vagy bármely más, levelet.

1740
01:27:15,070 --> 01:27:17,010
Én csak a
szögletes zárójelben most,

1741
01:27:17,010 --> 01:27:19,510
okokból jövünk
vissza csak egy pillanatra.

1742
01:27:19,510 --> 01:27:21,330
>> És most mit fogok csinálni ez.

1743
01:27:21,330 --> 01:27:26,680
Ha argc egyenlő egyenlő 2--
és emlékszem, hogy egyenlő az egyenlők

1744
01:27:26,680 --> 01:27:30,040
az operátorral összehasonlításával
A bal és jobb egyenlőségre.

1745
01:27:30,040 --> 01:27:31,790
Ez nem a feladat
operátor, amely

1746
01:27:31,790 --> 01:27:36,510
Az egységes egyenlőségjel, ami azt jelenti, másolás
jobbról balra valamilyen értéket.

1747
01:27:36,510 --> 01:27:42,840
>> Ha argc értéke = 2, szeretnék
mondjuk, printf, hello, százalék, az új vonal,

1748
01:27:42,840 --> 01:27:47,340
majd csatlakoztassa in-- és itt az új
trick-- argv konzol 1 okok miatt

1749
01:27:47,340 --> 01:27:48,840
hogy mi jön vissza egy pillanatra.

1750
01:27:48,840 --> 01:27:52,110
Más, ha nem argc
egyenlő 2, tudod mit?

1751
01:27:52,110 --> 01:27:57,400
Nézzük csak megy előre, és mint mindig, a nyomtatási
ki hello world nélkül cserélni.

1752
01:27:57,400 --> 01:28:02,710
>> Nagyon úgy tűnik, hogy ha argc, ami
jelentése érv száma, értéke 2,

1753
01:28:02,710 --> 01:28:04,740
Megyek kinyomtatni
szia vagy valami más.

1754
01:28:04,740 --> 01:28:07,560
Ellenkező esetben, alapértelmezés vagyok
nyomdába kerülés hello world.

1755
01:28:07,560 --> 01:28:08,770
Tehát mit jelent ez?

1756
01:28:08,770 --> 01:28:15,550
>> Nos, hadd menjen előre, és mentse
ezt a fájlt, majd megcsináljuk argv0,

1757
01:28:15,550 --> 01:28:18,940
majd ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
És azt mondja, hello world.

1759
01:28:20,300 --> 01:28:21,260
Nos, miért van ez?

1760
01:28:21,260 --> 01:28:24,730
>> Nos, kiderült, hogy bármikor
futtatni egy programot a parancssorban,

1761
01:28:24,730 --> 01:28:29,570
kitöltésekor mit fogunk
általában hívni egy érv vektor.

1762
01:28:29,570 --> 01:28:33,100
Más szóval, automatikusan a
számítógépet, az operációs rendszer,

1763
01:28:33,100 --> 01:28:38,340
fog átadni a programot
Maga egy listát az összes szót

1764
01:28:38,340 --> 01:28:40,850
hogy az emberi begépelt
A prompt az esetre, ha

1765
01:28:40,850 --> 01:28:43,790
A programozó akarok
valamit az információt.

1766
01:28:43,790 --> 01:28:48,540
És ebben az esetben, az egyetlen szó
Azt írtad a prompt ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> És így a több érv, hogy az
átadottként én program csak egy.

1768
01:28:55,420 --> 01:28:58,880
Más szavakkal, az érv
számítanak, más néven argc

1769
01:28:58,880 --> 01:29:00,970
itt egy egész, csak egy.

1770
01:29:00,970 --> 01:29:03,000
Az egyik természetesen nem egyenlő kettő.

1771
01:29:03,000 --> 01:29:05,980
És így ez az, amit nyomtat, hello world.

1772
01:29:05,980 --> 01:29:08,170
>> De engedjék meg, hogy ezt valahol.

1773
01:29:08,170 --> 01:29:09,930
Hadd mondjam, argv0.

1774
01:29:09,930 --> 01:29:12,740
És akkor mi a helyzet Maria?

1775
01:29:12,740 --> 01:29:14,990
Majd nyomja meg az Entert.

1776
01:29:14,990 --> 01:29:18,020
>> És vegyük észre, mi történik varázslatosan itt.

1777
01:29:18,020 --> 01:29:22,640
Most ahelyett, hello world, van
megváltoztatta a viselkedését a program

1778
01:29:22,640 --> 01:29:26,310
azáltal, hogy a bemenet nem származó get
húr, vagy más funkciót,

1779
01:29:26,310 --> 01:29:30,570
de úgy tűnik, az én parancs
maga, amit eredetileg beírt.

1780
01:29:30,570 --> 01:29:35,720
És én is játszani ezt a játékot újra
megváltoztatják, hogy Stelios, például.

1781
01:29:35,720 --> 01:29:38,400
>> És most látom a másik nevet is.

1782
01:29:38,400 --> 01:29:40,540
És itt, azt mondhatnánk Andi.

1783
01:29:40,540 --> 01:29:42,137
És azt mondhatnánk Zamyla.

1784
01:29:42,137 --> 01:29:45,220
És mi lehet játszani ezt a játékot, egész nap,
csak csatlakoztatni a különböző értékek,

1785
01:29:45,220 --> 01:29:49,550
amíg én hogy pontosan
két szó a gyors,

1786
01:29:49,550 --> 01:29:52,260
oly módon, hogy argc, érvem számítanak, 2.

1787
01:29:52,260 --> 01:29:57,240
>> Látok, hogy név dugva
printf, per ez a feltétel itt?

1788
01:29:57,240 --> 01:30:00,550
Tehát úgy tűnik, hogy most
A kifejező képesség

1789
01:30:00,550 --> 01:30:04,410
figyelembe bemenet egy másik mechanizmus,
Az úgynevezett parancssor,

1790
01:30:04,410 --> 01:30:07,000
ahelyett, hogy várjon
amíg a felhasználó futtatja a programot,

1791
01:30:07,000 --> 01:30:10,220
, majd kéri őt
felhasználásával valami hasonló get húr.

1792
01:30:10,220 --> 01:30:11,230
>> Szóval mi ez?

1793
01:30:11,230 --> 01:30:15,010
ARGC megint csak egész szám,
száma words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
hogy a felhasználó rendelkezésre a
prompt, a terminál ablak,

1795
01:30:18,540 --> 01:30:20,110
beleértve a program nevét.

1796
01:30:20,110 --> 01:30:23,340
Tehát mi ./argv0 van, hatékonyan,
a program nevét,

1797
01:30:23,340 --> 01:30:24,520
vagy hogyan fut a program.

1798
01:30:24,520 --> 01:30:25,810
>> Számít, mint egy szó.

1799
01:30:25,810 --> 01:30:27,080
Tehát argc lenne 1.

1800
01:30:27,080 --> 01:30:29,750
De amikor írok Stelios, vagy
Andi, vagy Zamyla, vagy Maria,

1801
01:30:29,750 --> 01:30:31,660
azt jelenti, hogy az érvelés száma kettő.

1802
01:30:31,660 --> 01:30:33,910
És így most van két szó telt el.

1803
01:30:33,910 --> 01:30:36,070
>> És vegyük észre, mi továbbra is ezt a logikát.

1804
01:30:36,070 --> 01:30:39,050
Ha valóban azt mondják,
valami hasonló Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
teljes név, ezzel átadva
három érv összesen

1806
01:30:42,200 --> 01:30:47,410
most azt mondja, az alapértelmezett ismét
mert, természetesen, 3 nem egyenlő 2.

1807
01:30:47,410 --> 01:30:54,080
>> És így ezen a módon, nem tudom
hozzáférés argv ezt az új érvet

1808
01:30:54,080 --> 01:30:56,080
hogy mi lehet technikailag
hívja, amit csak akarunk.

1809
01:30:56,080 --> 01:30:58,940
De a hagyomány, ez
argv és argc, ill.

1810
01:30:58,940 --> 01:31:04,470
Argv, érvelés vektor, kedves
A szinonimája a programozási

1811
01:31:04,470 --> 01:31:07,140
jellemző C nevű tömböt.

1812
01:31:07,140 --> 01:31:14,410
>> Egy tömb listát a hasonló értékeket
vissza, vissza, vissza, hogy vissza.

1813
01:31:14,410 --> 01:31:17,810
Más szóval, ha valaki itt a
RAM, a következő egy közvetlenül mellette,

1814
01:31:17,810 --> 01:31:18,800
és közvetlenül mellette.

1815
01:31:18,800 --> 01:31:20,101
Ők nem az egész hely.

1816
01:31:20,101 --> 01:31:23,100
És ez utóbbi forgatókönyv, ahol a dolgok
van az egész hely a memóriában,

1817
01:31:23,100 --> 01:31:25,082
is lehet egy erőteljes funkció.

1818
01:31:25,082 --> 01:31:28,040
De mi jön vissza, hogy amikor
beszélni szakértő adatszerkezeteket.

1819
01:31:28,040 --> 01:31:32,260
Most, egy tömb csak egy
darab összefüggő memória,

1820
01:31:32,260 --> 01:31:36,520
mindegyik, amelynek elemei
vissza, vissza, vissza, vissza,

1821
01:31:36,520 --> 01:31:38,050
és általában ugyanolyan típusú.

1822
01:31:38,050 --> 01:31:42,630
>> Tehát, ha belegondolsz, egy
perce, mi az a húr?

1823
01:31:42,630 --> 01:31:50,460
Nos, egy string, mint Zamyla,
Z-A-M-Y-L-A, nem, technikailag,

1824
01:31:50,460 --> 01:31:51,400
Csak egy tömbben.

1825
01:31:51,400 --> 01:31:53,700
Ez egy sor karakter.

1826
01:31:53,700 --> 01:31:59,250
>> És így, ha igazán felhívni ezt, ahogy én
tette korábban, mint egy darab memória,

1827
01:31:59,250 --> 01:32:04,510
kiderül, hogy minden egyes ilyen
karakterek vesz fel egy byte.

1828
01:32:04,510 --> 01:32:07,630
És akkor ott van, hogy a különleges
sentinel karakter, a backslash 0,

1829
01:32:07,630 --> 01:32:12,360
vagy mind a nyolc 0 bit, hogy
kijelölte a végén, hogy a húr.

1830
01:32:12,360 --> 01:32:15,090
Tehát egy húr, kiderül
ki, idézzük idézet vége húr,

1831
01:32:15,090 --> 01:32:20,580
csak egy sor chara--
char hogy egy tényleges adatok típusát.

1832
01:32:20,580 --> 01:32:24,560
>> És most argv, meanwhile--
menjünk vissza a program.

1833
01:32:24,560 --> 01:32:29,582
Argv, bár látjuk a szót
húr itt, nem karakterlánc is.

1834
01:32:29,582 --> 01:32:33,640
Argv, érvelés vektor,
egy tömböt.

1835
01:32:33,640 --> 01:32:37,620
>> Ahogyan tehát akkor van egy sor
karakterekből magasabb szintű,

1836
01:32:37,620 --> 01:32:46,279
egy sor strings-- Így például,
mikor beírtam egy perce ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, tér Z-A-M-Y-L-A, azt állítottam, hogy
argv két húrok it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
és Z-A-M-Y-L-A. Ban ben
Más szavakkal, ARGC volt 2.

1839
01:33:03,185 --> 01:33:03,980
Miert van az?

1840
01:33:03,980 --> 01:33:08,370
>> Nos, hatékonyan, mi folyik
A az, hogy minden ilyen húrok

1841
01:33:08,370 --> 01:33:13,990
Természetesen, egy sor karakterek
mint korábban, minden egyes akiknek karakterek

1842
01:33:13,990 --> 01:33:15,670
vesz fel egy bájt.

1843
01:33:15,670 --> 01:33:19,720
És ne keverjük össze a tényleges 0
a program nevét a 0,

1844
01:33:19,720 --> 01:33:22,040
ami azt jelenti, mind a 80 bit.

1845
01:33:22,040 --> 01:33:27,140
És Zamyla, eközben továbbra is
továbbá egy sor karakter.

1846
01:33:27,140 --> 01:33:31,450
>> Így a végén a nap, ez tényleg
úgy néz ki, mint ez a motorháztető alatt.

1847
01:33:31,450 --> 01:33:38,800
De az argv, a természet, hogyan fő
munkák, lehetővé teszi számomra, hogy lezárja mindezt

1848
01:33:38,800 --> 01:33:44,810
fel, ha úgy tetszik, egy nagyobb tömb
hogy ha valamivel több egyszerűsítése

1849
01:33:44,810 --> 01:33:48,180
mi a kép néz ki, és nem
elég felhívni, hogy a skála ott,

1850
01:33:48,180 --> 01:33:56,720
ez a tömb csak a 2-es méret, az első
eleme, amely tartalmaz egy string,

1851
01:33:56,720 --> 01:33:59,230
A második elem
amely tartalmaz egy húr.

1852
01:33:59,230 --> 01:34:01,687
És viszont, ha
fajta nagyítás minden

1853
01:34:01,687 --> 01:34:03,770
e húrok, amit
lásd a motorháztető alatt

1854
01:34:03,770 --> 01:34:07,190
hogy minden húr csak
egy sor karakter.

1855
01:34:07,190 --> 01:34:11,680
>> Most, csakúgy, mint a húrok,
tudtuk, hogy hozzáférjen

1856
01:34:11,680 --> 01:34:15,260
az i-edik karakter egy húr
használ, hogy a szögletes zárójel jelöléssel.

1857
01:34:15,260 --> 01:34:17,320
Hasonlóképpen, tömbök
általában is mi

1858
01:34:17,320 --> 01:34:22,700
szögletes zárójel jelölést kap
bármely számú húrok a tömb?

1859
01:34:22,700 --> 01:34:25,100
Például, hadd
megy előre, és erre a célra.

1860
01:34:25,100 --> 01:34:32,420
>> Hadd menjen előre, és hozzon létre argv1.c,
ami egy kicsit más ebben az időben.

1861
01:34:32,420 --> 01:34:35,635
Ahelyett, hogy ellenőrzése argc2,
Megyek inkább erre.

1862
01:34:35,635 --> 01:34:41,270
Mert int kapok 0, I kevesebb
mint argc, én plus plus,

1863
01:34:41,270 --> 01:34:47,920
majd nyomtassa ki belseje,
százalék s, új sort, majd

1864
01:34:47,920 --> 01:34:50,740
argv konzol i.

1865
01:34:50,740 --> 01:34:55,220
>> Más szóval, én nem foglalkozik
egyes karakterek az adott pillanatban.

1866
01:34:55,220 --> 01:35:00,190
Argv szerint közvetlenül az ilyen üres tér
melles jobbra a név argv,

1867
01:35:00,190 --> 01:35:03,320
azt jelenti, argv egy tömböt.

1868
01:35:03,320 --> 01:35:04,870
És argc csak egy int.

1869
01:35:04,870 --> 01:35:08,800
>> Ez a sor itt, a 6., a
mondván set i értéke 0.

1870
01:35:08,800 --> 01:35:11,980
Gróf egészen az,
de nem tartalmazza argc.

1871
01:35:11,980 --> 01:35:14,010
És akkor minden iterációban
nyomtassa ki a húr.

1872
01:35:14,010 --> 01:35:14,800
Mi húr?

1873
01:35:14,800 --> 01:35:17,270
>> Az i-edik string argv.

1874
01:35:17,270 --> 01:35:19,530
Tehát míg korábban voltam
a szögletes zárójel

1875
01:35:19,530 --> 01:35:22,180
jelölés, hogy a i-edik
karakter egy húr, most

1876
01:35:22,180 --> 01:35:27,240
Én használ a szögletes zárójel jelölés
hogy a i-edik sztringet egy tömbbe.

1877
01:35:27,240 --> 01:35:30,310
Tehát ez a fajta egy rétegben
felett, fogalmilag.

1878
01:35:30,310 --> 01:35:35,390
>> És mi ügyes erről
programból, ha fordítsam argv1,

1879
01:35:35,390 --> 01:35:42,067
majd tegye ./argv1, majd írja
olyasmi, mint foo bar BAZ,

1880
01:35:42,067 --> 01:35:45,400
amelyek a három alapértelmezett szó, hogy a
számítógép tudós nyúl bármikor

1881
01:35:45,400 --> 01:35:51,010
ő kell egy kis helykitöltő szó,
és nyomja meg az Enter, egyes szavakat,

1882
01:35:51,010 --> 01:35:54,980
beleértve a program nevét, amely
van argv az első helyen,

1883
01:35:54,980 --> 01:35:58,320
végül is a nyomtatott egyesével.

1884
01:35:58,320 --> 01:36:05,290
És ha ezen változtatni, és azt mondom,
olyasmi, mint argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
megkapjuk az itt felsorolt ​​három
szóval, ami argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, mert ebben az
esetben argc, a gróf, 3.

1887
01:36:14,400 --> 01:36:20,020
>> De mi a szép az, ha érti
hogy argv csak egy tömböt,

1888
01:36:20,020 --> 01:36:24,910
és megérted, hogy egy húr
egy tömb karakterekből

1889
01:36:24,910 --> 01:36:29,470
mi is valójában milyen használatához
szögletes zárójel jelölés többször

1890
01:36:29,470 --> 01:36:33,320
hogy válasszon egy húr, majd válassza
a képességgel a húr,

1891
01:36:33,320 --> 01:36:35,730
búvárkodás mélyebb a következő.

1892
01:36:35,730 --> 01:36:40,100
Ebben a példában, hadd menjen
előre, és hívja ezt argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
És ebben a példában, hadd menjen előre
és nem a following-- az int i kap 0,

1895
01:36:50,180 --> 01:36:53,286
i-nél kisebb argc, i plus
plusz, mint azelőtt.

1896
01:36:53,286 --> 01:36:55,910
Tehát más words-- és most ez a
egyre bonyolultabb elég.

1897
01:36:55,910 --> 01:36:59,940
Akkor fogok mondani
végighaladni húrok argv,

1898
01:36:59,940 --> 01:37:01,294
mint egy megjegyzést, hogy magam.

1899
01:37:01,294 --> 01:37:03,960
Aztán megyek egy
beágyazott hurok, amit valószínűleg

1900
01:37:03,960 --> 01:37:06,290
volna, vagy figyelembe venni
csinál, a Scratch, ahol

1901
01:37:06,290 --> 01:37:08,600
Azt fogom mondani int-- vagyok
nem fogja használni megint,

1902
01:37:08,600 --> 01:37:12,590
mert nem akarom, hogy az árnyék, vagy
fajta felülírja a meglévő i.

1903
01:37:12,590 --> 01:37:15,780
>> Megyek, hanem, mondjuk j, mert
ez az én megy a változó után én,

1904
01:37:15,780 --> 01:37:18,590
amikor én csak próbál
számolni egyszerű számokat.

1905
01:37:18,590 --> 01:37:28,850
J kap 0-- és n, fog
kap a far hossza argv tartó i,

1906
01:37:28,850 --> 01:37:36,030
mindaddig, amíg j értéke kisebb, mint m,
j plus plus, tegye a következőket.

1907
01:37:36,030 --> 01:37:37,500
És itt jön az érdekes rész.

1908
01:37:37,500 --> 01:37:46,330
>> Nyomtassa ki egy karaktert és egy új vonal,
dugulás argv konzol i, j konzol.

1909
01:37:46,330 --> 01:37:47,940
OK, hadd adjunk néhány megjegyzést itt.

1910
01:37:47,940 --> 01:37:54,820
Végighaladni karakterek
a jelenlegi szöveg,

1911
01:37:54,820 --> 01:38:02,290
print j-edik karaktere i-edik sor.

1912
01:38:02,290 --> 01:38:04,630
Tehát most, nézzük meg
amit ezek a megjegyzések jelent.

1913
01:38:04,630 --> 01:38:06,750
>> Végighaladni a húrok
a argv-- hány

1914
01:38:06,750 --> 01:38:09,300
húrok vannak argv, amellyel egy tömb?

1915
01:38:09,300 --> 01:38:13,420
ARGC sok, úgyhogy iterációjával
az i egyenlő 0-ig argc.

1916
01:38:13,420 --> 01:38:20,020
Közben, hogy hány karakter
vannak az i-edik string argv?

1917
01:38:20,020 --> 01:38:22,880
>> Nos, hogy ezt a választ,
Én csak hívja string-hossz

1918
01:38:22,880 --> 01:38:26,810
A jelenlegi szöveg azt ellátás
kb, ami argv konzol i.

1919
01:38:26,810 --> 01:38:30,090
És megyek, hogy ideiglenesen tárolja, hogy
értéke n, csak caching célokra,

1920
01:38:30,090 --> 01:38:31,590
emlékszik rá a hatékonyságot.

1921
01:38:31,590 --> 01:38:36,330
És akkor fogok inicializálása j 0,
folyamatosan megy, amíg j n-nél kisebb,

1922
01:38:36,330 --> 01:38:38,430
és minden egyes iteráció növekmény j.

1923
01:38:38,430 --> 01:38:41,030
>> És akkor itt egy
én comment on line 12

1924
01:38:41,030 --> 01:38:43,390
nyomtassa ki a karaktert,
majd egy új vonal,

1925
01:38:43,390 --> 01:38:48,140
kifejezetten argv konzol
i ad nekem az i-edik sor

1926
01:38:48,140 --> 01:38:51,690
a argv-- így az első szót, a
második szó, a harmadik szó, bármi.

1927
01:38:51,690 --> 01:38:57,370
És akkor j merülés mélyebb, és megkapja
nekem a j-edik karaktere ezt a szót.

1928
01:38:57,370 --> 01:39:02,200
És így, a hatás, akkor lehet kezelni
argv egy többdimenziós,

1929
01:39:02,200 --> 01:39:06,050
mint egy kétdimenziós, tömb,
amelyben minden szó egyfajta néz

1930
01:39:06,050 --> 01:39:08,580
mint ez a lelki
szem, és minden karakter

1931
01:39:08,580 --> 01:39:10,930
A fajta komponált
egy oszlopot, ha ez segít.

1932
01:39:10,930 --> 01:39:13,260
>> A valóságban, amikor ugratni
ezt leszámítva a jövőben hét,

1933
01:39:13,260 --> 01:39:15,580
ez lesz egy kicsit
kifinomultabb ennél.

1934
01:39:15,580 --> 01:39:17,800
De akkor tényleg
gondolni, hogy most,

1935
01:39:17,800 --> 01:39:22,110
mivel csak ez a két dimenziós
tömb, ahol egy szintet is

1936
01:39:22,110 --> 01:39:23,260
minden a húrok.

1937
01:39:23,260 --> 01:39:26,760
És akkor, ha merülés mélyebbre, akkor
lehet kapni az egyes karakterek

1938
01:39:26,760 --> 01:39:29,600
mellékhatásuk ezzel a jelöléssel van.

1939
01:39:29,600 --> 01:39:31,620
>> Tehát mi a nettó hatása?

1940
01:39:31,620 --> 01:39:34,970
Hadd menjek előre, és
hogy argv2-- fene egye meg.

1941
01:39:34,970 --> 01:39:36,210
Hibáztam itt.

1942
01:39:36,210 --> 01:39:40,160
Hallgatólagosan nyilvánító
könyvtári függvény Stirling.

1943
01:39:40,160 --> 01:39:42,190
Tehát ebben az időben, ez
talán helyénvaló

1944
01:39:42,190 --> 01:39:45,130
hogy mi fajta befejező
Pontosan, ahol elkezdtük.

1945
01:39:45,130 --> 01:39:48,160
>> Elcsesztem, hallgatólagosan nyilvánításáról
könyvtári függvény Stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, várj egy percet.

1947
01:39:48,987 --> 01:39:51,070
Emlékszem, hogy különösen
hiszen itt van.

1948
01:39:51,070 --> 01:39:54,490
Azt kell, hogy tartalmazza a string.h
ez a változat a program.

1949
01:39:54,490 --> 01:40:00,050
>> Hadd menjek előre, és tartalmaznia
string.h, kivéve, hogy menjen előre

1950
01:40:00,050 --> 01:40:04,460
és újrafordítani argv2.

1951
01:40:04,460 --> 01:40:08,390
És most itt tartunk, hogy argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
És bár ez egy kicsit
rejtélyes első pillantásra,

1953
01:40:10,590 --> 01:40:15,690
észre, hogy az, ami ténylegesen
kinyomtatja a dot argv2.

1954
01:40:15,690 --> 01:40:19,970
>> De ha be is szó után
prompt, mint argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Enter, még egy kicsit
rejtélyes első pillantásra.

1956
01:40:22,560 --> 01:40:30,540
De ha görgetni vissza,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Így már végigjárt át minden szót.

1958
01:40:32,190 --> 01:40:37,770
És viszont, most már több mint iterált
minden karakter egy szón belül.

1959
01:40:37,770 --> 01:40:40,040
>> Most, miután mindezt,
észre, hogy ott van

1960
01:40:40,040 --> 01:40:43,120
Egy másik részlet voltunk fajta
figyelmen kívül hagyja ezt az egész idő alatt.

1961
01:40:43,120 --> 01:40:46,180
Mi csak ugratta egymástól milyen
fő bemenetei lehetnek?

1962
01:40:46,180 --> 01:40:47,780
Mi a helyzet a fő kimeneti?

1963
01:40:47,780 --> 01:40:50,540
>> Mindez idő, voltunk
csak a másolás és beillesztés

1964
01:40:50,540 --> 01:40:53,870
a szó int előtt fő,
bár lehet látni az interneten,

1965
01:40:53,870 --> 01:40:58,340
néha helytelenül a régebbi
C és fordítóprogramok, hogy azt mondják érvénytelen,

1966
01:40:58,340 --> 01:40:59,410
vagy semmit.

1967
01:40:59,410 --> 01:41:01,580
De valóban, a version
C, hogy mi használ,

1968
01:41:01,580 --> 01:41:06,180
C 11, vagy 2011, észre
hogy meg kell Int.

1969
01:41:06,180 --> 01:41:09,300
És meg kell vagy lehet
érvénytelennek vagy argc és az argv itt.

1970
01:41:09,300 --> 01:41:10,790
>> De miért int main?

1971
01:41:10,790 --> 01:41:12,480
Mi ez valójában visszatér?

1972
01:41:12,480 --> 01:41:16,280
Nos, kiderült, hogy mindezt az időben,
minden alkalommal, amikor írtam egy programot fő

1973
01:41:16,280 --> 01:41:18,440
mindig visszatér valamit.

1974
01:41:18,440 --> 01:41:19,960
De ez már ezzel titokban.

1975
01:41:19,960 --> 01:41:23,350
>> Ez a valami egy
int, mivel az 5. sorban sugallja.

1976
01:41:23,350 --> 01:41:24,225
De mi int?

1977
01:41:24,225 --> 01:41:26,100
Nos, itt van ez a
egyezmény programozás,

1978
01:41:26,100 --> 01:41:29,790
ahol, ha semmi sem
rosszul sikerül, és minden rendben van,

1979
01:41:29,790 --> 01:41:34,250
programok és funkciók általában
return-- kissé counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 általában azt jelenti, minden rendben van.

1982
01:41:38,070 --> 01:41:40,610
Így, bár úgy gondolja,
azt a hamis számos helyzetben,

1983
01:41:40,610 --> 01:41:42,930
valójában általában azt jelenti, jó dolog

1984
01:41:42,930 --> 01:41:49,560
>> Közben, ha egy program visszatér 1,
vagy negatív 1, vagy 5, vagy negatív a 42.,

1985
01:41:49,560 --> 01:41:52,941
vagy bármely, nem-0 értékű,
amely általában jelenti

1986
01:41:52,941 --> 01:41:54,190
hogy valami nincs rendben.

1987
01:41:54,190 --> 01:41:56,700
Tény, hogy a saját Mac vagy PC,
lehet, hogy valóban láttam

1988
01:41:56,700 --> 01:42:01,050
egy hibaüzenet, amely révén
mond valamit, vagy más, a hiba

1989
01:42:01,050 --> 01:42:04,940
kód negatív 42, vagy hibakódot
23, vagy valami ilyesmi.

1990
01:42:04,940 --> 01:42:08,980
Ez a szám általában csak egy csipetnyi
a programozó, vagy a vállalat

1991
01:42:08,980 --> 01:42:11,174
tette a szoftver,
mit rontottam, és miért,

1992
01:42:11,174 --> 01:42:13,590
hogy így átnéz
a dokumentációban vagy kódja,

1993
01:42:13,590 --> 01:42:15,465
és kitalálni, mi a
hiba valójában jelent.

1994
01:42:15,465 --> 01:42:18,400
Ez általában nem
hasznosak számunkra a végfelhasználók számára.

1995
01:42:18,400 --> 01:42:20,550
>> De amikor a fő visszatér 0, minden rendben van.

1996
01:42:20,550 --> 01:42:23,770
És ha nem adja meg
mi fő, vissza kell adnia,

1997
01:42:23,770 --> 01:42:26,950
akkor csak automatikusan
return 0 az Ön számára.

1998
01:42:26,950 --> 01:42:30,870
De visszatérve valami
mást valóban hasznos.

1999
01:42:30,870 --> 01:42:34,660
>> Ebben az utolsó programot, hadd
megy előre, és hívja ezt exit.c,

2000
01:42:34,660 --> 01:42:38,630
és vezessen be az utolsó a mai
témák, más néven a hibakódot.

2001
01:42:38,630 --> 01:42:42,930
Hadd menjek előre, és tartalmazza a
ismerős fájlokat akár felső, nem int main.

2002
01:42:42,930 --> 01:42:49,500
És ezúttal, csináljuk int argc,
húr argv, és én konzolok

2003
01:42:49,500 --> 01:42:50,836
arra utal, hogy ez a tömbben.

2004
01:42:50,836 --> 01:42:52,460
És akkor hadd tegye a biztonsági ellenőrzést.

2005
01:42:52,460 --> 01:42:56,640
Ez az idő, ha argc nem
egyenlő 2, akkor tudod mit?

2006
01:42:56,640 --> 01:42:57,520
Felejtsd el.

2007
01:42:57,520 --> 01:43:03,170
Fogok mondani, hogy, hé, a felhasználó,
ha hiányzik parancssori argumentum

2008
01:43:03,170 --> 01:43:04,210
backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> És akkor ez az.

2010
01:43:05,230 --> 01:43:06,130
Ki szeretnék lépni.

2011
01:43:06,130 --> 01:43:11,030
Fogok preemptively,
és idő előtt tényleg, visszatérés

2012
01:43:11,030 --> 01:43:12,810
valami más, mint az 1-es.

2013
01:43:12,810 --> 01:43:15,360
A go, hogy érték az első
hiba, ami megtörténhet, 1.

2014
01:43:15,360 --> 01:43:17,860
Ha van egy másik hibás
helyzet, hogy előfordulhat,

2015
01:43:17,860 --> 01:43:21,390
mondhatnánk vissza 2 vagy vissza 3, vagy
talán még negatív 1. vagy negatív 2.

2016
01:43:21,390 --> 01:43:23,750
>> Ezek csak kilépési kódok
amelyek általában

2017
01:43:23,750 --> 01:43:27,770
Csak akkor hasznos, a programozó, vagy a
cég, ami hajózás a szoftvert.

2018
01:43:27,770 --> 01:43:30,500
De az a tény, hogy ez az
nem 0, ami fontos.

2019
01:43:30,500 --> 01:43:34,310
Tehát ha ez a program, szeretnék
Garantáljuk, hogy ez a program csak

2020
01:43:34,310 --> 01:43:38,190
akkor működik, ha a felhasználó megadja nekem
egy érv száma kettő,

2021
01:43:38,190 --> 01:43:42,880
a program nevét, és néhány egyéb
szó, tudom érvényesíteni, mint az alábbiak,

2022
01:43:42,880 --> 01:43:46,110
kiabálni a felhasználó printf mondás,
hiányzik parancssori argumentum

2023
01:43:46,110 --> 01:43:46,970
return 1.

2024
01:43:46,970 --> 01:43:49,940
Hogy majd csak közvetlenül
kilép a programból.

2025
01:43:49,940 --> 01:43:55,840
>> Csak akkor, ha argc = 2 jutunk le
Itt, ezen a ponton fogom mondani,

2026
01:43:55,840 --> 01:44:00,410
szia százalék s, backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Más szavakkal, én
Nem fog után argv 0,

2028
01:44:03,827 --> 01:44:05,410
ami csak a program nevét.

2029
01:44:05,410 --> 01:44:09,450
Szeretnék kinyomtatni hello, vessző,
A második szó, hogy az emberi gépelt.

2030
01:44:09,450 --> 01:44:12,580
És ebben az esetben a
13. sor, minden rendben van.

2031
01:44:12,580 --> 01:44:15,920
>> Tudom, hogy ARGC 2
logikusan ebből a programból.

2032
01:44:15,920 --> 01:44:17,770
Megyek, hogy menjen előre és vissza 0-ra.

2033
01:44:17,770 --> 01:44:21,230
Mellesleg, tartsd észben, hogy
ez igaz a karcolással is.

2034
01:44:21,230 --> 01:44:24,760
>> Logikusan tudnám ezt
és ezt párosítani ezeket a sorokat

2035
01:44:24,760 --> 01:44:27,020
A kód ezen else itt.

2036
01:44:27,020 --> 01:44:29,420
De ez a fajta
szükségtelenül beljebb kódomat.

2037
01:44:29,420 --> 01:44:31,800
És azt akarom, hogy szuper
Egyértelmű, hogy nem számít, mit,

2038
01:44:31,800 --> 01:44:34,670
alapértelmezés szerint, helló
valamit kap nyomtatott,

2039
01:44:34,670 --> 01:44:36,050
mindaddig, amíg a felhasználó együttműködik.

2040
01:44:36,050 --> 01:44:39,360
>> Tehát ez nagyon gyakori használata
feltétel, csak egy, ha

2041
01:44:39,360 --> 01:44:41,870
elkapni néhány hibás
helyzetet, majd kilép.

2042
01:44:41,870 --> 01:44:45,690
Aztán, amíg minden rendben van
Nos, nincs más,

2043
01:44:45,690 --> 01:44:48,060
de csak azt a kódot
kívül, hogy ha, mert

2044
01:44:48,060 --> 01:44:51,060
egyenértékű az e
konkrét esetben logikailag.

2045
01:44:51,060 --> 01:44:54,480
Úgyhogy visszatérő 0, csak azért, hogy
kifejezetten jelezve, minden rendben van.

2046
01:44:54,480 --> 01:44:58,480
>> Ha elhagyjuk a return 0, akkor lenne
automatikusan feltételezni nekem.

2047
01:44:58,480 --> 01:45:00,890
De most, hogy én visszatér
egy legalább ebben az esetben,

2048
01:45:00,890 --> 01:45:04,940
Megyek, jó intézkedés és
egyértelműség return 0 ebben az esetben.

2049
01:45:04,940 --> 01:45:09,690
Tehát most hadd menjen előre, és a kijárat,
amely tökéletes váltása, hogy csak hagyja.

2050
01:45:09,690 --> 01:45:14,401
>> De hogy exit, és hadd menjen
előre, és nem ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
És a program kiabált velem,
hiányzik parancssori argumentum.

2052
01:45:16,900 --> 01:45:18,120
OK, hadd működjenek.

2053
01:45:18,120 --> 01:45:23,810
>> Hadd helyett csinálni ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
És most azt mondja, helló David.

2055
01:45:25,190 --> 01:45:27,300
És akkor általában nem látja ezt.

2056
01:45:27,300 --> 01:45:30,650
>> De kiderül, hogy van egy
különleges módon Linux, hogy ténylegesen

2057
01:45:30,650 --> 01:45:34,470
milyen kilépési kód program kilép.

2058
01:45:34,470 --> 01:45:37,184
Néha egy grafikus
világban, mint a Mac OS vagy Windows,

2059
01:45:37,184 --> 01:45:40,100
csak látni ezeket a számokat, amikor egy
hibaüzenet jelenik meg a képernyőn

2060
01:45:40,100 --> 01:45:41,940
és a programozó
azt mutatja, hogy a számot.

2061
01:45:41,940 --> 01:45:44,773
De ha azt akarjuk, hogy mi a hiba
üzenet, meg tudjuk csinálni here--

2062
01:45:44,773 --> 01:45:48,100
így ./exit, Enter, nyomtatás
hiányzik parancssori argumentum.

2063
01:45:48,100 --> 01:45:54,590
>> Ha én most nem echo $ ?, amely
nevetségesen rejtélyes keres.

2064
01:45:54,590 --> 01:45:56,590
De $?

2065
01:45:56,590 --> 01:45:59,220
a mágikus ráolvasás
amely azt mondja, hé, számítógép,

2066
01:45:59,220 --> 01:46:01,900
mondja meg, mi az előző
program kilépési kódja.

2067
01:46:01,900 --> 01:46:03,410
És megütöttem az Enter billentyűt.

2068
01:46:03,410 --> 01:46:07,520
Látom 1, mert ez az, amit én
azt mondta a fő funkciója, hogy visszatérjen.

2069
01:46:07,520 --> 01:46:12,310
>> Közben, ha én ./exit David,
és nyomja meg az Enter, látom, helló David.

2070
01:46:12,310 --> 01:46:16,800
És ha most nem echo $ ?, látom szia 0.

2071
01:46:16,800 --> 01:46:19,080
És így ez ténylegesen
értékes információkat

2072
01:46:19,080 --> 01:46:23,420
keretében a debugger, nem annyira
sokat, hogy te, az ember, akkor érdekel.

2073
01:46:23,420 --> 01:46:26,060
De a hibakereső és más
programok fogjuk használni ebben a félévben

2074
01:46:26,060 --> 01:46:29,420
gyakran megnézi azt a számot,
bár ez a fajta rejtett el

2075
01:46:29,420 --> 01:46:32,780
ha nem néz rá, hogy
határozza meg, hogy egy program

2076
01:46:32,780 --> 01:46:37,050
végrehajtás volt helyes vagy helytelen.

2077
01:46:37,050 --> 01:46:40,450
>> És így, hogy elvezet minket
ezt, a végén a nap.

2078
01:46:40,450 --> 01:46:43,917
Elkezdtük ma nézi
hibakeresés, és viszont, a pálya

2079
01:46:43,917 --> 01:46:46,750
is, és akkor több Érdekes,
technikailag a motorháztető alatt

2080
01:46:46,750 --> 01:46:49,490
hogy milyen húrok, amely a múlt
héten csak biztosra vett,

2081
01:46:49,490 --> 01:46:51,900
és minden bizonnyal elvitte őket
értetődőnek Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Ezután megnéztük, hogyan tudjuk elérni
egyes karakterre,

2083
01:46:56,040 --> 01:47:00,310
majd ismét vett egy magasabb szintű
nézni a dolgokat, és megnézzük, hogyan well--

2084
01:47:00,310 --> 01:47:04,226
Ha azt akarjuk, hogy az egyes
a lista elemeit, mint a szerkezet,

2085
01:47:04,226 --> 01:47:05,850
nem tudunk csinálni, hogy több húrok?

2086
01:47:05,850 --> 01:47:08,050
És tudjuk a parancssori paramétereket.

2087
01:47:08,050 --> 01:47:12,800
De ez a kép itt csak dobozok
hogy demonstrálják ezt a közvélekedést

2088
01:47:12,800 --> 01:47:14,451
Egy tömb, vagy egy lista, vagy egy vektort.

2089
01:47:14,451 --> 01:47:16,450
És attól függően, hogy
összefüggésben minden ezeket a szavakat

2090
01:47:16,450 --> 01:47:17,880
némileg különböző dolgokat.

2091
01:47:17,880 --> 01:47:20,060
Tehát C, mi csak megy
beszélni egy tömbben.

2092
01:47:20,060 --> 01:47:23,840
És egy sor egy bonyolult
memória, akik mindegyike az

2093
01:47:23,840 --> 01:47:27,720
elemek összefüggőek, vissza,
vissza, vissza, hogy vissza.

2094
01:47:27,720 --> 01:47:31,970
>> És ezek az elemek, általában
az azonos típusú adatok, jellege,

2095
01:47:31,970 --> 01:47:35,966
karakter, karakter, karakter, vagy
húr, húr, húr, húr, vagy int,

2096
01:47:35,966 --> 01:47:38,600
int, int, bármi legyen is az
próbálunk tárolni.

2097
01:47:38,600 --> 01:47:42,540
De a végén a nap, ez
hogyan néz ki fogalmilag.

2098
01:47:42,540 --> 01:47:44,530
Te szedését
számítógép memóriájában vagy RAM.

2099
01:47:44,530 --> 01:47:48,590
És te faragott ki a
azonos méretű dobozok, amelyek mindegyike

2100
01:47:48,590 --> 01:47:50,920
vissza, vissza, hogy
vissza, hogy vissza ezen a módon.

2101
01:47:50,920 --> 01:47:53,200
>> És mi szép a
ezt az elképzelést, és az a tény,

2102
01:47:53,200 --> 01:47:58,580
hogy tudjuk kifejezni értékek ebben módon
az első a mi adatstruktúrák

2103
01:47:58,580 --> 01:48:02,520
az osztályban, azt jelenti, kezdhetjük
megoldani a problémákat a kódot

2104
01:48:02,520 --> 01:48:04,079
hogy jött így ösztönösen héten 0.

2105
01:48:04,079 --> 01:48:05,870
Majd visszahívja a telefont
könyv például, ha

2106
01:48:05,870 --> 01:48:09,110
mi használt oszd meg és uralkodj,
vagy egy bináris keresési algoritmust,

2107
01:48:09,110 --> 01:48:13,220
szitál keresztül egy egész
csomó nevek és számok.

2108
01:48:13,220 --> 01:48:18,220
De azt feltételeztük, visszahívás, hogy ez a
telefonkönyvét már rendezve,

2109
01:48:18,220 --> 01:48:21,630
hogy valaki más már
Figurális out-- adott névjegyzékének

2110
01:48:21,630 --> 01:48:24,430
és numbers-- hogyan átrendezhetne őket.

2111
01:48:24,430 --> 01:48:26,950
És most, hogy a C-mi,
is, képesek

2112
01:48:26,950 --> 01:48:30,290
feküdt a dolgokat, nem
fizikailag a telefonkönyvben

2113
01:48:30,290 --> 01:48:34,220
de gyakorlatilag a számítógép
memória, képesek leszünk a jövő héten

2114
01:48:34,220 --> 01:48:38,470
bevezetni újra this-- az első
mi adatstruktúrák egy array--

2115
01:48:38,470 --> 01:48:43,530
de ami még fontosabb, a tényleges számítógép
tudomány algoritmusok

2116
01:48:43,530 --> 01:48:47,720
a kód, amivel lehet tárolni
adatok struktúrák, mint ez,

2117
01:48:47,720 --> 01:48:50,730
majd elkezd manipulálni, és
hogy valóban megoldani a problémákat vele,

2118
01:48:50,730 --> 01:48:53,570
és építeni a tetején, hogy,
végül, programok C,

2119
01:48:53,570 --> 01:48:56,730
Python, JavaScript,
lekérdezésével adatbázisok SQL?

2120
01:48:56,730 --> 01:48:59,980
>> És látni fogjuk, hogy az összes ilyen
különböző ötleteket retesz.

2121
01:48:59,980 --> 01:49:04,100
De most, felidézni, hogy az
tartományban, hogy mi vezetett a mai

2122
01:49:04,100 --> 01:49:06,920
volt ez a dolog itt, és
A világ titkosítani.

2123
01:49:06,920 --> 01:49:11,200
És azok között a következő problémák te magad
megoldja a művészet kriptográfia,

2124
01:49:11,200 --> 01:49:13,630
keverésnél és de-kódolási
információkat, és rejtjelezés

2125
01:49:13,630 --> 01:49:15,930
és megfejteni a szöveget,
és feltételezve, hogy végül

2126
01:49:15,930 --> 01:49:18,970
hogy most már tudja, mit
van a motorháztető alatt

2127
01:49:18,970 --> 01:49:21,860
így ha látni vagy fogadni
egy ilyen üzenetet, akkor

2128
01:49:21,860 --> 01:49:24,060
magad is megfejteni.

2129
01:49:24,060 --> 01:49:26,740
Mindez, és még a következő alkalommal.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO LEJÁTSZÁS]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Most érkezett.

2133
01:49:32,970 --> 01:49:35,146
Megyek meglátogatom
főiskolai tanár.

2134
01:49:35,146 --> 01:49:37,611
Igen.

2135
01:49:37,611 --> 01:49:40,080
Szia.

2136
01:49:40,080 --> 01:49:40,660
Te vagy.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Várjon!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Csak próbálom kitalálni
hogy mi történt veled.

2142
01:49:56,060 --> 01:49:58,130
Kérjük, bármi segíthet.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Te voltál az egyetemen
szobatársam, ugye?

2145
01:50:08,354 --> 01:50:10,770
Te is ott voltál vele, amikor
már befejezte a CS50 projekt?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [ZENE]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Ez Volt CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Imádom ezt a helyet.

2152
01:50:44,770 --> 01:50:45,854
>> -Edd meg.

2153
01:50:45,854 --> 01:50:47,020
Megyünk ki az üzletből.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END LEJÁTSZÁS]

