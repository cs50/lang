[음악 재생] 

데이비드 J. 마란 : 좋습니다. 이 CS50이있다 주 (2)의 시작이다. 그리고 당신은 그 이상 기억합니다 지난 몇 주, 우리는 컴퓨터를 도입했습니다 과학, 차례로, 프로그래밍. 

그리고 우리는의 방법으로 이야기를 시작 스크래치, 그 그래픽 언어 MIT의 미디어 랩에서. 그리고 가장 최근에, 지난 주, 우리했다 higher-- a를 소개합니다 낮은 레벨의 언어 공지 C, 순수하게 텍스트 뭔가있다. 그리고, 참으로, 지난 시간 우리 그 맥락에서 탐구 개념의 수입니다. 

이, 리콜은 매우이었다 첫 번째 프로그램 우리는 보았다. 그리고이 프로그램을 아주 간단하게, "안녕하세요, 세상을."출력한다 그러나 너무 많이있다 보이는 마법에 가고. 이 사용법 #include가있다 이러한 꺾쇠 괄호와 함께. INT가있다. (무효)가있다. 괄호, 중괄호가있다, 세미콜론, 그리고 훨씬 더. 

그리고, 리콜 우리는 스크래치를 도입 우리는 이상적으로, 과거를 볼 수 있도록 그 구문, 정말 아니에요 물건 모든 지적 흥미로운하지만 초기에 절대적으로, 조금 까다 롭습니다 당신의 마음을 주위에 포장합니다. 그리고, 실제로 가장 일반적인 한 초기에 프로그래밍 클래스의 것, 특히 적은을위한 편안 의해 좌절하는 것입니다 특정 구문에 의해 트립 오류, 논리적 오류를 언급하지 않기 위하여. 그리고 우리의 목표 중 오늘, 실제로 것 일부를 장비하는 방법에 대한 문제 해결 기술 더 문제 자체를 해결하기 위해 디버깅의 형태 일 수있다. 그리고 당신은, 너무, 기억하는거야 우리가 도입 환경 마지막으로는 CS50 IDE 불렀다. 이 웹 기반 소프트웨어 인 것을 클라우드로 프로그래밍 할 수 있습니다, 모두 유지하면서 그렇게 말을하는 방법 우리가 오늘 다시 것, 파일 등. 그리고 우리를 기억 여기에이 주제를 재 방문, 그 (것)들의 사이에서 함수, 루프, 변수 및 부울 식, 조건. 그리고 실제로 몇 스크래치의 세계에서 번역 C.의 세계 

그러나 기본적인 빌딩 블록은, 그래서, 말하자면 정말 여전히 같은 지난 주에 있었다. 사실, 우리가 정말 있었던 다른 퍼즐 조각, 당신이됩니다. 그 대신 보라색의 블록을 저장, 우리 대신 인는 printf했다 C에서이 기능이 당신이 뭔가를 인쇄 할 수 있습니다 화면에 포맷. 우리는 CS50 소개 도서관, 어디를 귀하의 처분에 get_char에 지금있다, 및 GET_INT 및에서는 get_string, 그리고 몇 가지 다른 기능으로 물론, 어떤을 통해 당신은 입력을받을 수 있습니다 사용자 고유의 키보드. 그리고 우리는 또한 가지를 살펴했다 these- 부울 및 문자 등, 두 번, 플로트, INT, long_long 문자열입니다. 그리고 C. 심지어 다른 데이터 유형을 거기에 

당신이 선언 즉, 변수는 어떤 값을 저장하고, 또는 당신은 기능을 구현할 때 그 어떤 값을 반환 당신은 무엇을 지정할 수 있습니다 인 값의 유형입니다. 이 문자열은 같은가요 문자의 순서? 그것은 정수처럼 수 있습니까? 그것은 부동 소수점입니다 값 등? 그래서 C에서, 스크래치는 달리, 우리는 실제로 데이터의 종류를 지정하기 시작했다 우리는 반환 또는 사용 하였다. 

하지만, 물론, 우리는 만났다 컴퓨팅의 근본적인 한계. 특히, 이 언어 C, 리콜 우리는 한 번 봐 걸렸다 정수 오버 플로우, 현실 당신은 단지이있는 경우 그 메모리의 유한 한 양 또는, 특히, 제한된 개수 비트, 당신은 너무 높은 셀 수 있습니다. 그래서 우리는 여기 예를 보았다 이에 비행기에서 카운터, 실제로, 충분히 경우를 것입니다 실행 오버 플로우 및 소프트웨어 결과 실제 물리적 잠재적 인 오류가 발생했습니다. 

우리는 또한 떠 보았다 포인트 부정확, 현실 만 유한 한 개수 비트, 그것은 32 또는 64인지, 당신은 너무 많은 숫자를 지정할 수 있습니다 소수점 후 어느 한 후 부정확 얻을 시작합니다. 예를 들어, 1/3 그래서 여기에 세계, 우리 인간 세계에서, 우리는 무한한 알고 소수점 -3의. 그러나 컴퓨터가 필요 없습니다 숫자의 무한한 수를 나타냅니다 만 허용하는 경우 그 일부 정보의 유한 한 양. 

그래서뿐만 아니라 우리는 당신을 장비 않았다 측면에서 더 큰 힘을 가진 의 당신은 자신을 표현하는 방법 프로그래밍의 관점에서 키보드 우리는 또한 제한 내용 당신은 실제로 할 수 있습니다. 그리고 실제로, 버그와 실수는 할 수 문제의 그 종류에서 발생한다. 그리고 실제로, 항목 중 오늘 디버깅 같은 주제로 가고있다 실제로 후드 아래에보고 물건이 소개 된 방법을 지난 주에 실제로 구현 당신이 더 잘되도록 이해 양쪽의 기능 및 C.와 같은 언어의 제한 

사실, 우리는 계층을 벗겨 것 데이터 구조의 단순한의 배열이라는 것을, 어떤 스크래치는 호출하는 일 "목록을." 그것은 약간의 그 상황에서 다른. 그리고 우리는 또한 중 하나를 소개합니다 우리의 도메인 관련 문제의 첫 번째 CS50에서의 세계 암호화, 스크램블링 기술 분야 또는 그렇게 정보를 암호 처리 당신은 비밀 메시지를 보낼 수 있음 비밀 메시지를 디코딩 두 사람 A와 B 사이 

그래서 우리는 전환 전 그 새로운 세계에, 의 일부에 당신을 갖추기 위해 노력하자 기술이있는 당신은 제거 할 수 있습니다 적어도 일부를 감소 좌절감의 당신은 아마 발생했는지 혼자 지난 주에 걸쳐. 사실, 앞서의 일부를 such--된다 C. 그리고 확률의 첫 번째 문제입니다 당신이 나 같은 경우, 처음 당신은 프로그램을 입력하려고, 당신은 논리적으로 생각하는 경우에도 프로그램은 매우 간단하다 당신은 매우 잘 벽에 충돌하고 있습니다 컴파일러는 협조하지 않을. 확인 또는 연타는 않을 것이다 실제로 입찰을 할 수 있습니다. 

그리고 그 이유가 될 수 있을까요? 음, 그럼 살펴 보자 아마도 간단한 프로그램. 내가 가서이 저장거야 의도적으로 buggy0.c라는 파일, 나는 그것을 알고 있기 때문에 사전에 결함이 될 수있다. 하지만 그 경우이 실현되지 않을 수도 있습니다 제 1, 제 2 또는 제 3 프로그램은 있다는 사실은 자신을 만들고있어. 그래서 앞서 갈거야 및 , INT 주 (무효)를 밖으로 입력합니다. 그리고 내 중괄호의 내부, 안녕하세요,을 전 세계 ( "매우 잘 알고 백 슬래시, N ") - 그리고 세미콜론. 

나는 파일을 저장했습니다. 지금은 내려 갈거야 내 터미널 창에 입력을 확인합니다 buggy0 때문에, 다시, 파일명 오늘날 buggy0.c이다. 그래서 입력 buggy0을 입력합니다. 

그리고, 오, 이런, 마지막에서 리콜 오류 메시지 것이 좋은 일이다. 그래서 출력이 좋은 일입니다. 그러나 여기에서 나는 분명히해야 실수의 일부 번호. 

출력의 첫 번째 줄 그래서 buggy0을 입력 한 후, 리콜, 연타의 매우 자세한 출력이다. 후드 아래, CS50의 IDE가 구성되어 의 모두를 사용하는 이 컴파일러 옵션 그래서, 당신은하지 않는 것이 그들에 대해 생각합니다. 그리고 그 모든 것을 첫 번째 줄이야 연타로 시작을 의미합니다. 

그러나 그 후, 문제 자신의 모습을 시작합니다. 라인 3 자에 Buggy0.c 5, 큰, 빨간색 오류가 있습니다. 그 무엇입니까? 암시 라이브러리 함수를 선언 int 형 (const를 숯불 *로는 printf, ...) [-Werror]. 나는 매우 빨리, 그것을 의미 매우 모호한 가져옵니다. 그리고 확실히, 처음 눈에, 우리는 않을 것 당신은 이해 것으로 예상 해당 메시지의 전체. 교훈 그래서 하나 오늘가는에 대한 통지하려고 할 수 있습니다 패턴 또는 이와 유사한 것들 오류가있을 수 있습니다 과거에 발생했습니다. 그래서 단지 떨어져 애타게하자 익숙 그 단어. 큰, 빨간색 오류는 분명히 무언가의 상징이 잘못되고. 

암시 적 선언 라이브러리 함수의 printf. 그래서 나는 아주 이해하지 못하는 경우에도 무엇 암시 적으로 라이브러리 함수를 선언 수단, 확실히 문제 어떻게 든는 printf에 관한 것이다. 그리고 그 문제의 원인 그것을 선언과 관련이있다. 

함수가 선언 처음으로 언급. 그리고 우리는 지난 주 용어를 사용 함수의 프로토 타입을 선언, 하나의 상단에 하나의 라인과의 자신의 파일이나 소위 헤더 파일입니다. 그리고 무엇에 파일은 우리가 말을했다 지난 주 printf의가 견적입니다, 인용을 끝내 선언? 어떤 파일에서 프로토 타입은? 

그래서 만약 당신이 매우 먼저 I 리콜 입력 된 거의 모든 프로그램 마지막으로 .. 실수로 잠시 전 시작 myself--를 입력하면이 일 here--했다 hash-- 사용법 #include <stio--에 대한 입력 / output-- 도트 시간 그리고 실제로, 지금이 파일을 저장하면, 내가 갈거야 가서 내 화면을 취소하고, 당신은 입력 할 수있는 클리어하거나, 제어 L를 보유 할 수 있습니다 당신의 터미널 창을 취소합니다 단지 약간의 혼란을 제거합니다. 

내가 가서거야 및 다시 입력 메이크업의 buggy0 입력합니다. 그리고 짜잔, 난 여전히 볼 연타에서 긴 명령, 하지만 오류 메시지가이 시간이 없습니다. 그리고 사실, 내가 ./buggy0을 할 경우, 단지 지난 번처럼, 여기서 점은이 의미 디렉토리는 슬래시는 의미 여기에 프로그램의 이름이 온다 프로그램의 이름은 buggy0입니다 "안녕하세요, 세상을."입력 

지금, 당신은 어떻게해야 할 수도 있습니다 이 솔루션을 수집 없이 반드시 많은 단어를 인식 내가 그랬던 것처럼, 확실히 갖는 이 때문에 몇 년 동안 수행? 음, 첫 번째 문제에 따라 실현 세트, 우리는이 명령에 소개 CS50 자신의 직원이 라는 help50을 썼다. 그리고 실제로, C는 대한 사양을한다 이 문제는 사용하는 방법에 관하여 설정한다. 

그러나 본질적으로 help50입니다 프로그램 CS50의 직원 그 허용 쓴 당신은 실행 명령하거나, 프로그램을 실행 당신이 이해하지 않는 경우에 그 출력은, help50에 출력을 전달하는 있는 소프트웨어를 가리 과정의 직원이 쓴 프로그램의 출력을 볼 것이다 라인으로 라인, 문자로 문자. 그리고 우리 경우, 직원은 인식 발생한 오류 메시지, 우리는 몇 가지 당신을 자극하려고합니다 몇 가지 조언과 수사 학적 질문, TF 또는 CA 또는 자신과 같은 많은 근무 시간에 직접 할 것. 

그렇게하지 ​​않으면 그래서 help50에보고 반드시 문제를 인식하고 있습니다. 그러나에 의존하지 않는 버팀목으로 너무 많이. 확실히 이해하려고 노력의 출력 후 배우 그래서 한 번 또는 두 번 당신을 수행하는 것이 어느 특정 오류에 대한 help50 실행 메시지. 그 후, 당신은해야한다 더 나은 자신을 장착 실제로 무엇인지 알아낼 수 있습니다. 

의 여기에 다른 하나를 수행 할 수 있습니다. 내가 다른 앞서 가서 보자 파일을 우리는이 buggy1.c를 호출 할 수 있습니다. 그리고이 파일에 난 deliberately-- 것 하지만 그렇게하지 ​​척 내가 만든 한 내용을 잘못 이해하고 있습니다. 

내가 가서이 항아리 할거야 사용법 #include, 나는했습니다 이후 잠시 전에서 내 교훈을 배웠습니다. INT 주 (무효), 이전. 그리고 여기에서 나는거야 문자열의 할 일 -에서는 get_string합니다. 그리고 마지막에서 기억이 이 수단, 헤이, 컴퓨터, 나에게 변수를 줄 것이에요 호출하고 그 변수 문자열의 유형을 그래서 나는 거기에 하나 이상의 단어를 저장할 수 있습니다. 

그리고 오른쪽에 등호의 측면 을 인에서는 get_string된다 CS50 라이브러리 함수 그게 정확히 않습니다. 그런 다음 기능을 가져 오른쪽 손이 왼쪽으로. 그래서이 등호는 뜻은 아닙니다 우리가 수학 생각으로 "동일". 그것은 오른쪽에서 왼쪽으로 할당을 의미한다. 그래서 이것은로부터 문자열을 의미 사용자는 (S)의 내부에 보관하고. 

이제 사용할 수 있습니다. 내가 두 번째로 현재와 앞으로 가자 라인, 내가 가서 "안녕하세요"라고하자 - 하지 "세계"하지만 "안녕하세요, % s-- 이는 우리의 자리, 쉼표들입니다, 이는 우리의 변수가, 다음 세미​​콜론. 그래서 너무 엉망하지 않은 경우 여기에, 이것은 올바른 코드처럼 보인다. 

그리고 내 본능은 지금 컴파일한다. 이 파일은 buggy1.c이라고합니다. 그래서 입력 buggy1을 할거야. 그리고 터무니 - 그것, 존재하지 않는 경우 이전보다 더 많은 오류. 나는 더있어, 의미 오류 메시지는 것 이 프로그램의 실제 라인보다 같다. 

그러나 테이크 아웃은 여기입니다 당신은 압도 경우에도 두 개 또는 세와 네 이상의 오류 메시지, 아주 항상 초점 해당 메시지의 첫 번째. 최상위 하나를 보면, 수 백업으로 필요 스크롤. 그래서 여기에 나는 메이크업의 buggy1를 입력했습니다. 여기에 예상대로 연타 출력입니다. 

그리고 여기에 첫 번째 빨간색 오류입니다. 선언되지 않은 식별자의 사용 문자열, 나는 표준을 의미 했습니까? 그래서 표준입니다 실제로 뭔가. 이것은 사용자를 의미 키보드, 기본적으로. 

하지만 그게 무슨 의미가 아니다. 나는 문자열을 의미, 나는에서는 get_string을 의미했다. 그래서 있다는 것입니다 I 이 시간을 어떻게 잊어? 어떻게이 시간을 누락? 나는 나의 사용법 #include을 가지고, 그래서 printf의에 액세스 할 수 있습니다. 

그러나 나는 무엇을 필요가 없습니다 아직 액세스? 음, 그냥 지난 번처럼, 나는 컴파일러 말할 필요 이러한 기능이 무엇인지 그 소리. 에서는 get_string는 오지 않는다 C. 함께 특히 그것을 에 오지 않는다 파일 헤더. 대신에 온다 어떤 직원 썼다, 이는 다른 파일입니다 이름하지만 적절하게 이름. 

그래서 단순히 한 줄 것을 추가하여 마지막에서 code-- 리콜 연타가 실행될 때, 그것은거야 바닥에 내 코드 상단에보고하고, 왼쪽에서 오른쪽으로. 그것은 알거야 오, 당신은 할 수 있습니다. 내가 가서 그을 찾을 수 있습니다, 는 서버에있는 곳, 본질적으로, 복사 및 붙여 넣기, 자신의 파일의 상단에 그래서 이야기를이 시점에서 그, 라인 (1) 프로그램의 나머지 실제로, 기능을 사용할 수 거기에, 그 (것)들의 사이에서는 get_string. 그래서 나는 무시하는거야 이러한 오류의 나머지 나는 때문에, 참으로, 만 의심 첫번째는 실제로 중요. 그리고, 앞서 다시 실행 갈거야 내 파일을 저장 한 후 buggy1을합니다. 그리고 짜잔, 그것은 일을했다. 그리고 ./buggy1을하고 경우에 대해, 입력 인스턴스는, Zamyla는, 지금, 안녕하세요 얻을 것이다 Zamyla 대신 안녕하세요, 세계. 

괜찮아. 그래서 여기 집에 사 가지고가는 요리는 다음과 같다, 하나, 많은 당신이 할 수 이삭하려고 혼자 오류 메시지에서 찾고 인식 가능한 단어의 일부에서. 이 없다면, 당 help50를 사용 문제는 사양을 설정합니다. 하지만를 금지하는 것은, 너무, 항상 봐 가기 오류에서만 적어도 처음에 볼 수있는 정보 실제로 얻을 수 있습니다. 하지만이의를 밝혀 더 많은 기능을 내장 CS50 라이브러리로 도움 학기 초기에 당신 초기에 프로그래밍 잘못된 무슨 일이 일어나고 있는지 알아낼. 그래서 여기에 또 다른 예를 수행 할 수 있습니다. 나는 어떤이 buggy2를 호출하는거야, 다시 밖으로 결함이 될 것입니다 디자인에 의해 게이트,의. 

그리고 앞서 갈거야 및 사용법 #include을한다. 그리고 나는 INT 주 (무효)를 할거야. 그리고 나는 루프를 할거야. 들어 (_ 0 난을 int로. 난은 10 이하이다. 나는 ++, 다음 중괄호, 내가 갈거야 여기에 단지 해시 태그 기호 인쇄하기 새 라인 문자. 

이 내 의도 그래서 프로그램은 매우 간단 10 회 반복합니다 각 반복에 그 루프마다의 사이클을 통해, 해시 태그를 인쇄, 해시 태그, 해시 태그. 하나 당 라인 I 때문에 거기에 새로운 라인을 가지고있다. 그리고에 대한 리콜 마지막 week-- 당 루프, 당신은 더 많은 것을 얻을 것이다 구문을 잘 알고 연습을 사용하여 long-- 전에이 날 수 있습니다 변수 내가 전화는 0으로 설정합니다. 

이 난을에 증가 (1)에 의해 모든 반복. 그래서 난 3 2 1로 이동합니다. 그리고이 상태에서 세미 콜론 사이의 중간 수 있도록 모든 반복에 확인됩니다 우리는 범위 내에서 여전히 있는지 확인하십시오. 그래서 10 번 반복 할, 그래서 이 종류의 매우 직관적 단지 거기에 내 상한으로 10했습니다. 

그럼에도 불구하고, 나는이 프로그램을 실행할 때, 후 메이크업으로 컴파일 buggy2-- 그리고 OK 컴파일 않습니다. 그래서 나는이 없습니다 구문 오류이 시간. 내가 지금 앞서 가자 및 입력 buggy2를 실행합니다. 그리고 지금까지 스크롤합니다. 그리고 나 증가하자 창의 크기. 

I 가질 것 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. 그래서, 비록 11 해시 태그있다 나는 분명히이 루프의 내부 (10)를 넣습니다. 지금, 당신의 일부는 즉시 볼 수 있습니다 오류가 있기 때문에, 실제로이 무엇인지 만들 수있는 매우 어려운 오류가 아닙니다. 그러나 그것은 매우 일반적이다 초기에했다. 

내가 지적하고자하지만, 어떻게이 알아낼 수 있습니까? 글쎄, 그것은 밝혀 CS50 라이브러리 제공 뿐만에서는 get_string 및 GET_INT와 get_float 및 기타 기능을합니다. 또한 특별한 기능이 있습니다 라는 eprintf, 또는 오류의 printf. 그리고 그것은 만들기 위해 단독으로 존재 그것은 당신을 위해 조금 더 쉽게 단지를에 코드를 디버깅 할 때 화면 상에 에러 메시지를 출력 그것이 어디에서 왔는지과 알​​고있다. 

그래서 예를 들어, 한 가지 내가 수도 이 기능이 항아리입니다과 여기에서 eprintf, 그리고, 나는 앞서 갈거야 그리고 난 내가, 백 슬래시, n은 지금 % 말한다. 그리고 나는 i 값을 연결하겠습니다. 그리고 상단까지,이 때문에 의 CS50 라이브러리에 나는 앞서 갈거야 및 포함 그래서 나는이 기능에 액세스 할 수 있습니다. 하지만 이제 생각 해보자 무엇 라인 9 일을 할 예정이다. 나는 결국이 삭제하겠습니다. 이것은 할 수 없다 내 지배적 인 목표. 그러나 eprintf, 오류의 printf, 그냥 의미 나에게 약간의 진단 정보를 제공합니다. 내 프로그램을 실행하면, 내가 원하는 일시적으로 화면이 표시 뿐만 아니라 단지 이해하기 무슨 일이야. 

그리고, 참으로, 각 여기에 9 호선의 반복 내가보고 싶은, i 값은 무엇인가? i 값은 무엇인가? i 값은 무엇인가? 그리고, 희망, 나는 단지해야 해당 메시지, 또한, 10 배를 참조하십시오. 

그래서 내가 가서 보자 내 프로그램을 다시 컴파일, 나는 모든 시간을 할 필요가로 나는 변경합니다. ./buggy2. 그리고 now-- OK. 더 진행이 많이 있습니다. 그래서 나에 스크롤 할 수 더 큰 창. 

그리고 당신의 각을 볼 수 있습니다 해시 태그는 여전히 인쇄됩니다. 그러나 그 사이에 그들 각각은 지금이다 다음과 같이 진단 출력 포맷. 여기 내 프로그램의 이름은 buggy2입니다. 파일의 이름은 buggy2.c입니다. 행 번호 이로부터 인쇄 된이 라인 9입니다. 그리고 그 오른쪽에있는 내가 기대하고 있습니다 오류 메시지. 

그리고이 있다는 것입니다에 대한 좋은거야 지금은 반드시 계산 할 필요가 없습니다 내 머리에 내 프로그램은 무엇을하고 있는지. 내가 온 것을 볼 수 있습니다 내가 0 첫 번째 반복, 다음 1, 다음 2, 다음 3, 다음 4 다음 5, 다음 6 다음 7, 다음 8 다음 9 다음 10. 그래서 분을 기다립니다. 여기 무슨 일이야? 나는 아직도 계산 된 것 같습니다 로 10 개까지 구성. 

하지만 어디서부터 시작 했습니까? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. 따라서 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11 손가락 문제를 나타낸다. 내가 계산 한 것 잘못 내 루프입니다. 10 반복을 이동하기보다는, 나는 0에서 시작 해요 나는에 10을 종료하고 있습니다. 그러나 때문에, 컴퓨터 등 나는 0에서 계산을 시작 해요 나는까지 계산해야한다 행 아닌 10 내지. 

그리고 수정, 나는 결국 여기에 실현, 두 가지 중 하나입니다. 나는 아주 간단하게 말할 수 10 이하까지 계산합니다. 따라서 0, 1, 2, 3, 4, 5, 6, 7, 8, 실제로, 올 9, 심지어 약간의 잘못을 소리 불구하고. 아니면 내가 할 수있는보다 작거나 같음 9, 너무 오래 나는 0에서 시작으로. 아니면 정말 마음에 들지 않으면, 당신을 (10)를 통해 계산하지만 1에서 시작할 수 있습니다. 그러나 다시, 이것은 단지 일반적인 아니다. programming--이기는에서 Scratch--에 너무 많이하지 하지만 프로그래밍에 C와 다른 언어, 자바 스크립트와 같은 파이썬과 다른, 그것은이다 단지 아주 일반적인 이진의 논의 단지에서 계산을 시작합니다 0 당신이 할 수있는 가장 낮은 숫자입니다. 괜찮아. 그래서 eprintf입니다. 그리고 또, 지금은 알아 냈으니 내 문제는 내가 0으로 돌아갈거야 10 미만을 통해, 내가 갈거야 가서 eprintf를 삭제합니다. 

때 그것은 거기 안 코드를 제공하거나 코드를 제출 또는 다른 사람에게 보여. 그것은 정말 의미있어 임시로 사용할 수 있습니다. 하지만 지금은이 문제를 해결했습니다 뿐만 아니라 특정 문제. 

음, 여기에 하나 더 예를하자 본인은 다음과 같은 채찍거야있다. 내가 가서거야 및 #포함 . $ (50) 그리고 앞서 갈거야 및 사용법 #include. 

그리고 저장거야 buggy3.c으로이 파일. 그리고 앞서 갈거야 및 INT 주 (무효)를 선언합니다. 그리고 내부가의 나는 내가 INT 할거야 _ - 나는 프로그램을 구현하려면 get_negative_int와. 이 아직 존재하는 함수가 아닙니다. 그래서 우리는 구현하는거야 그것은 단지 순간입니다. 그러나 우리는 왜 보게 될 것입니다 그것은 첫 번째 패스에서 버그가 있습니다. 내가 받고 나면 사용자로부터의 int, 난 그냥 %의 난을 인쇄 할거야 것은 부정적이다 정수, 백 슬래시, N, 쉼표, 난. 즉, 모든 I 어떻게이 프로그램을 원하는 에서 음의 INT를 얻을 수있다 사용자는 다음 인쇄 그러한 이러한 부정적인 INT이다. 

지금은이 기능을 구현해야합니다. 그래서 나중에 내 파일에, 내가 갈거야 앞서와라는 함수를 선언 get_negative_int (무효) - 우리 것 그 선이 다시 무엇을 의미하는지에 돌아온다 moment--의 INT n에서; do-- 할 일 following--의의 printf n은 :. , GET_INT - 그리고 나는 N을 할거야 이 동안의 n은 0보다 큰 않습니다. 그리고 n은 반환 ;. 

그래서에서 진행이 많이있다 우리가하지 않았다있는이 있지만 없음 적어도 잠시, 지난 주에 봐. 그래서 여기에 라인 (10)에 I 선언 한 get_negative_int 호출 된 함수, 나는에, (무효) 넣었습니다 괄호는 원인이되는 입력을지지 않습니다. 난 아무것도 통과하고 있지 않다 이 함수. 난 그냥 다시 뭔가를 얻고있다. 

그리고 난에 무엇을 바라고 있어요 돌아 가야하는 정수입니다. 데이터 타입이 없다 C는 negative_int을했다. 그냥 int로, 그래서 그것은거야 확인하기 위해 우리에 있어야합니다 실제로의 값 반환뿐만 아니라 int 형이다 뿐만 아니라 부정적이다. 

라인 (12)에 나는 변수를 선언하고있어 n 및 int 타입을 제작했다. 그리고 라인 (13) (18)를 통해 난 일을하는 것이 사실입니다있다. 나는 앞서 인쇄거야 n은, 콜론 다음에 공백, 사용자에 대한 메시지 등을들 수있다. 

그때 GET_INT를 호출하고있어 이른바 리턴 값을 기억 그 변수 n을한다. 그러나 나는 일을 계속하려고 해요 이 동안의 n은 0보다 크다. 즉, 사용자는 저을 준다면 int로 그 숫자가 0보다 큰 경우, ERGO는, 긍정적 인, 내가 갈거야 단지 사용자 reprompting 유지, 그들을 강제로, reprompting을 유지 협력과 나에게 부정적인 INT를 제공합니다. 

n은 실제로 negative--되면 마지막 유형 -50 사용자 가정 다음이 while 루프는 더 이상 사실입니다 -50 0보다 크지 않기 때문에. 그래서 우리는 탈옥 루프는 논리적이고 n 반환합니다. 

그러나 다른 하나는있다 일은 내가해야한다. 그리고 간단히 말해서 나는이 작업을 수행 할 수 있습니다 복사 및 붙여 넣기로 파일의 맨 위에 한 줄의 코드. 나는 연타를 가르 칠 필요 또는 그 소리 약속, 명시 적으로 나는 것, 실제로, 이동 및 구현 이 기능 get_negative_int. 그것은 단지 파일의 낮은 수 있습니다. 다시, 리콜 연타 , 위에서 아래로 물건을 읽고 왼쪽에서 오른쪽으로, 그래서 당신은 할 수 없습니다 연타하면 함수를 호출 존재하는거야 알 수 없습니다. 

지금, 불행하게도,이 프로그램, 당신의 일부는 눈치 챘을 수도 이미 버그입니다. 내가 가서 buggy3을 만들어 보자. 내 문제는 지금되지 않도록 그것은 컴파일 구문 오류, 텍스트 오류 등, 실제로 논리를 될 것 내가 의도적으로했습니다 오류 를 기회로 만든 무슨 일이 일어나고 있는지를 단계별로. 

나는 앞서 갈거야 지금 buggy3를 실행합니다. 그리고 난 갈거야 앞서이 아닌 협력한다. 나는 그것을 숫자 1을 줄거야. 너무 그것을 좋아하지 않았다 그것은 나를 다시하라는거야. 

방법 2? 삼? 50? 그 중 어느 것도 작동하지 않습니다. 어떻게 -50 어떻습니까? 그리고 프로그램이 작동하는 것 같다. 

나를 한 번 더 시도해 보자. 나 -1을 시도하자 작동하는 것 같다. 나 -2 해보자, 작동하는 것 같다. 내가 공을 해보자. 허, 그 잘못이다. 이제, 우리는 여기에 약간 현학적 인 것입니다. 그러나 경우 0이, 참으로,의 긍정적이나 부정적인 아닙니다. 그래서 내 프로그램은 사실이다 0은 음의 정수라고 말하는 즉, 기술적으로 정확하지 않습니다. 

지금, 왜 이런 일을합니까? 글쎄, 그것은 분명 수 있습니다. 그리고, 실제로는, 프로그램 매우 간단 될 운명 그래서 우리는 탐험하는 뭔가가있다. 

그러나의 제 3 디버깅을 소개하자 기술은 여기 debug50했다. 따라서이 프로그램은 우리는 방금 만든 것을 올해이라고 debug50 그것은 당신에게 수 내장 불리는 것을 사용 CS50의 IDE에서 그래픽 디버거. 그리고 디버거는 프로그램입니다 일반적으로이 프로그램을 실행할 수 있습니다 하지만, 단계, 라인별로 단계적으로 라인으로 라인으로, 파고, 일시 중지 주변 변수를 찾고 있기 때문에 프로그램은 그냥지나 려하지 않습니다 빨리 뭔가를 인쇄 또는 뭔가를 인쇄 할 수 없습니다. 그것은에서 당신에게 기회를 제공합니다 인간의 속도는, 그것과 상호 작용할 수 있습니다. 

그리고이 작업을 수행하려면 단순히 다음을 수행하십시오. 코드를 컴파일 한 후, 이는 이미 한, buggy3, 당신은 가서 debug50 ./buggy를 실행합니다. 그래서 많은 help50 당신이 실행이 같은 help50하고 명령, debug50 당신이 debug50을 실행 가지고 있으며, 다음 명령의 이름. 

지금 내 화면에 어떻게되는지보고, 특히 우측. 나는 실행을, 모든 공격 갑자기이 오른쪽 패널 화면에 열립니다. 그리고가는 많은이있다 첫눈에. 그러나 너무이 아니다 아직 걱정 많이. 

이것은 나에게 모든 것을 보여주고있다 그건 내 프로그램의 내부에 무슨 일 지금 이러한 통해 버튼 상단이 다음이다 최대 내 코드를 단계별로 날 수 있도록 궁극적으로 단계별로 단계. 하지만 아직. 무슨 알 수 있습니다. 내 터미널 창에서 나는 N를 입력하라는 메시지가되고 있어요. 그리고 앞서 갈 예정하고있어 -1에서이 시간과 유형을 협력한다. 그리고이기는하지만 약간 비밀스럽게, -1 예상대로 음의 정수이다. 

그리고 아이로 종료 상태 0 GDBserver는 종료. GDB, GNU 디버거는 이름입니다 기본 소프트웨어 즉,이 디버거를 구현합니다. 그러나이 모든 것이 정말 디버거를 의미한다 내 프로그램 종료하기 때문에 멀리 갔다 모두 잘했다. 내가 진정으로 내 프로그램을 디버깅 할 경우, 나는, 선제 debug50 말할 필요 어디서 시작할까요 내 코드를 단계별로? 

그리고 아마도 가장 간단한 방법 다음과 같이 즉해야 할 일. 나는 위에 마우스를 올려 놓으면 여기 내 편집기의 거터, 그래서 정말 여기에 사이드 바에서, 행 번호의 왼쪽에, 있음을 그냥 클릭 통지하는 경우 일단, 나는 작은 빨간 점을 넣어. 그리고 그 작은 빨간 점, 정지 신호처럼, 헤이, 의미, debug50, 내 코드의 일시 정지 실행 바로 내가이 프로그램을 실행할 때. 

그럼 그렇게하자. 내가 가서 내 프로그램을 실행하자 다시 debug50 ./buggy3에 입력합니다. 그리고 지금, 통지, 뭔가 다른이 일어났다. 나는 묻지 않을거야 아직 내 터미널 창에서 아무것도, 때문에하지 않은 내 프로그램에서 아직 얻었다. 라인 8 것을 알 수 있습니다 현재 하이라이트되는, 그리고 약간의 화살표에있다 왼쪽 말은, 당신은 여기에 일시 중지됩니다. 코드 라인이 선 8, 아직 실행되지 않았습니다. 

내가 보면 그리고, 호기심 무엇 오른쪽에 여기에, 내가 로컬 것을 알 의미에서 지역 변수, 것이 현재의 함수 내에서입니다. 그리고 그 값 분명히 기본적으로, 및 종류의 편리 0입니다. 하지만 0을 입력하지 않았다. 그건 그냥 될 일이 그 순간 기본값. 

그래서 내가 가서 지금이 작업을 수행 할 수 있습니다. 내가 미리와에 가자 여기 상단, 난 앞서 갈과 이 첫 번째 아이콘을 클릭하는 이상의 단계는 생략하지 않는 수단 그것은하지만이 코드 라인을 통해 단계, 길을 따라 그것을 실행. 

그리고 지금, 주목 내 프롬프트는 변경되었습니다. 그 이유는 무엇입니까? 나는 debug50 말 했어요, 이 코드 줄을 실행합니다. 이 코드 줄은 무엇입니까? 하는 int 날 메시지를 표시합니다. 승인. 내가 협력 할 수 있습니다. 내가 지금 가서 -1을 입력, 입력 할 수 있습니다. 그리고 지금의 변경 사항을 알 수 있습니다. 오른쪽에, 내 지역 변수 내가 인 -1 해주기로 표시됩니다. 그리고 int 형의 여전히. 

그리고주의 사항, 너무, 내 소위 스택을 호출, 어디 일시 중지 했습니까? 우리에 대해 더 얘기하자 앞으로이. 그러나 호출 스택은 무엇을 의미 기능은 모션 현재. 지금은 그냥 기본입니다. 그리고 지금 로컬을 변수는 1의 값을 전합니다. 

그리고 마지막으로이 라인을 통해 단계 때 여기에, 오른쪽 상단에 같은 아이콘, -1 음의 정수입니다. 지금은 그 중괄호를 통해 일시 중지합니다. 의는 그 일을 할 수 있습니다. 나는 그 라인, 그리고 짜잔을 통해 단계. 

그래서 모든 것을 몹시 , 계몽 아직 하지만 그것은 나를 일시 중지 할 수 않았다 논리적를 통해 생각 이 프로그램은 무엇을하고있다. 그러나 그것은 잘못된 경우 아니었다. 다음의 다시이 작업을 수행 할 수 있습니다. 

그 중단 점을 떠날거야 빨간 점과 선 8. 나는 debug50를 다시 실행거야. 그것은 여기에 자동으로 일시 정지합니다. 하지만이 시간, 대신 이 라인을 통해 스테핑, 내가 실제로 내부에 가자 get_negative_int 및 파악, 왜 유효한 답변으로 0을 받고있다? 

그래서 대신 이상의 단계를 클릭. 나는 앞서 갈거야 그리고 한 단계를 클릭합니다. 그리고 라인 (8)의 그 것을 알 수 지금 갑자기 지금 강조 라인 (17)이된다. 

지금, 그것은 디버거 것이 아니다 라인 (14) 및 (15, 16) 생략하고있다. 그냥 거기에 아무것도 있어요 거기를 표시합니다. 사람들은 그냥 변수를 선언하는, 다음 단어가 수행 있어요 다음 오픈 중괄호. 의 유일한 기능 라인 육즙이 정말 여기 하나, (17)이다. 우리가했습니다 곳 그리고 그건 자동으로 일시 중지되었습니다. 

그래서의 printf ( "n.is :"); 이렇게 즉, 아직 일어나지 않았습니다. 그럼 가서 스텝 오버를 클릭 할 수 있습니다. 지금 내 프롬프트, 참으로, 로 변경 ( "n은"). 지금은 않을거야, GET_INT 단계 씩 귀찮게하고, 그 기능 이었기 때문에 도서관에서 CS50로했다. 그것은 아마도 맞습니다. 

그래서 앞서 갈거야 및 일종의을 제공함으로써 협력 하는 int 있지만 부정적인 INT. 그래서 내가 가서 공을 칠 수 있습니다. 그리고 지금 무슨 일이 발생 내가 내려 할 때 21 선에? 나는 다시 반복하지했습니다. 그 루프에 갇혀 것 같습니다하지 않습니다. 즉,이 노란색 바는, 주위에 계속하지 않았다 주위, 주변. 

이제, 그 이유는 무엇입니까? 음, N, 지금 무엇을 n은? 나는 지방에서 볼 수 있습니다 디버거의 변수. n은 0입니다. 좋아, 내 조건은 무엇인가? 

20-- 라인 (20)이 잘된다, 0은 0보다 크다. 그건 사실이 아니다. 0은 0보다 크다. 그래서 나는이 밖으로 끊었다. 

그리고 그 이유를 줄입니다 21 내가 실제로 계속하면, 난, 0을 반환거야 나는 공을 거부해야하지만 로 실제로 부정적 없습니다. 그래서 지금, 난 정말조차하지 않습니다 디버거에 관심. 그것은, 내가 할 필요가 없습니다 당함 무슨 일이 일어나고 있는지 더 알고있다. 

그래서 앞서 갈거야 및 그냥 재생 버튼을 클릭, 이 끝을 위로 할 수 있습니다. 지금, 나는 것을 깨달았다 내 버그 라인 (20)에 분명히있다. 그건 내 논리 오류입니다. 

그래서 내가 원하는 수행 이 위치를 변경 할까? 문제는 내가 아니에요 경우 0 잡기, 그것은 단지 논리적 인 오류입니다. n은 동안 내가 말할 수있는 0보다 크거나 같은, 또 다시 사용자에게 메시지를 보관합니다. 

그래서, 다시, 단순한 실수, 아마도 당신이 나를보고도 분명 불과 몇 분 전을 작성합니다. 그러나 여기 테이크 아웃 이다 디버그 (50)이, 및 디버깅 소프트웨어보다 일반적 이 새로운 발견 전원이 보고, 자신의 코드를 살펴 그 오른쪽 패널을 통해 무엇을 당신의 변수 값은 다음과 같습니다. 그래서 당신은 필요하지 않습니다 무언가를 사용해야 같은 당신은 그 값을 인쇄 할 수 eprintf. 당신은 실제로 그들을 볼 수 있습니다 시각적으로 화면에. 

자,이 이상, 그것은 주목할 가치가있다 의 또 다른 기술이 있다고 실제로 슈퍼 일반적인. 그리고 당신은 왜이 조금 궁금 할 것이다 여기에 사람이 무대에 앉아있다. 따라서이 기술은 일반적으로, 거기 고무 오리 디버깅으로 알려진, 이는 정말로 단지입니다 사실 입증 그 종종 프로그래머 코드를 작성, 그들은 반드시 아니에요 다른 사람과 협력, 또는 공유 환경에서 작업. 

그들은 집에서 일종의입니다. 아마 밤에 늦었어요. 그들은 그림을 시도하고 자신의 코드에 약간의 버그 아웃. 그리고 그들은 단지 그것을보고 아닙니다. 

그리고 더 룸메이트가 없습니다. 더 TF가 없습니다. 주위에 CA가 없습니다. 그들의 선반에있는 모든 이 작은 고무 오리입니다. 

그리고 고무 오리 디버깅 그냥이 초대 같은 바보 뭔가 생각하는 실제 생물로이 같은 실제로 코드를 살펴 구두이 생명이없는 객체. 그래서, 예를 들면, 이 내 예입니다 here-- 그 이전 리콜 문제는이 있었다 나는이 코드 첫 줄을 삭제하는 경우, 내가 가서 다시 버그는 0, 나는이 있었다는 것을 기억 여기에 오류 메시지. 그래서 비록 말도 여기에 아이디어, 공개적으로이 일 순간에 느낌 해당 오류입니다. 

OK, 그래서 내 문제는 내가했습니다 것입니다 암시 적으로 라이브러리 함수를 선언했다. 그리고 그 라이브러리 함수의 printf입니다. OK Declare-- 선언 프로토 타입의 저를 생각 나게한다. 

그게 내가 실제로 필요 의미 미리 컴파일러에게 무엇을 이 함수는 것 같습니다. 분을 기다립니다. 나는 표준 io.h.이 없었다 대단히 감사합니다. 

당신 동행입니다 그래서 그냥이 과정 실제로 오리를 할 필요가 없습니다. 그러나 걷는이 아이디어 자신의 코드를 통해 자신 그래서 당신도들을 수 있음 자신 때문에 그 자신의 누락을 실현 말은 일반적으로 생각입니다. 

그리고, 아마도 더 논리적으로, 그리 하나하지만 더 많은 참여와 많은 예를 들어 우리는 단지, 버그 3.C에서 한 당신은 그것을 통해 자신을 걸을 수 있습니다 으로는 다음과 같습니다. 그래서 모든 권리, 고무 오리, DDB, 당신이됩니다. 여기에 우리가 내 주요 기능에있다, 나는 부정적인 INT를 얻을 전화 드렸습니다. 

그리고는 반환 값을 얻고있다. I는 왼쪽에 기억하고있어 변수에 선 8 전을했다. OK,하지만 잠깐, 어떻게했다 즉, 그 값을 얻을? 나 라인 (12)의 기능을 살펴 보자. 

라인 12에서, 우리는 부정적인 INT를 얻을 수 있습니다. 어떤 입력을하지 않는다, OK, int를 반환 않습니다. 나는 선 (14) 변수 (n)에 선언합니다. 정수를 저장하는 것입니다. 그게 내가 원하는거야. 

n은 할 수 is-- 동안 그래서 다음을 수행 나 수정 이미 만들어진 것을 취소. N보다 큰 동안 그래서 0, OK, n은 인쇄. 그리고 INT N에 저장 얻을 호출합니다. n이 0 인 경우, 그리고, 확인 여기서 n은 이것도 아니고 ... 거기가입니다. 그래서, 다시, 당신은하지 않습니다 실제 오리가 필요합니다. 그러나 단지 자신을 통해 산책 지적 운동으로 코드 종종 당신을 도울 것입니다 , 무슨 일이 일어나고 있는지 실현 그냥 뭔가를하고 반대로 이 같은 화면을보고, 자신을 통해 이야기하고 있지 정직하지 않습니다 그것은, 거의 효과적인 기술로서. 그래서 당신이 원해야하는 다른 기술의 수 실제로 코드를 디버깅 하고, 오류를 찾는 모두의 당신의 도구 키트 도구해야한다 당신이 밤 늦게 아니에요 너무 특히, 당신은 식사에있어 홀, 또는 근무 시간에, 에 대하여 당신의 머리를 두드리는 벽, 일부 문제를 해결하려고. 소프트웨어 도구가 있다는 것을 알고 있습니다. 고무 오리 도구가 있습니다. 그리고의 전체 직원있다 손을 빌려 기다리고 지원합니다. 

이 문제에 그래서 지금, 단어 세트, 우리는 당신을 희망하는지에 그들 나가, 어떻게 우리는 평가에 대해 이동합니다. 과정의 강의 당, CS50의 문제 세트 그래서, 4 개의 축에 평가 범위를 speak--하고, 정확성, 디자인, 스타일. 그리고 범위는 얼마나을 말한다 조각의 당신은 떨어져 물린했다? 당신은 어떻게 문제의 대부분을 시도했다? 노력의 수준을 당신은 명시했다? 

정확성은 그대로 프로그램 작업을 수행 그것은 CS50 사양 당에 뜻이야 당신은 어떤 입력을 제공 할 때 또는 특정 출력은 돌아 오지? 디자인은 그들의 가장 주관적이다. 그리고 하나는 것입니다 배우는 가장 긴을 가장 긴은에서 가르쳐 지금까지 그 귀결로서, 코드가 얼마나 잘 작성입니까? 

그것은 단지 올바른을 인쇄 할 한 가지 출력 또는 오른쪽 값을 반환합니다. 하지만 당신은으로하고있다 효율적으로? 당신은 그것을 나누기를하고있다 정복, 또는 이진 우리는 곧 우리가했던 것을 볼 수 있습니다로 검색 2 주 전 전화 번호부와? 를 해결하기 위해 더 나은 방법이있다 현재 여기에있는 것보다 문제? 즉, 더 나은 디자인을위한 기회입니다. 

그리고 어떻게 style-- 꽤 코드는? 당신은 내가 꽤 있어요 것을 알 수 있습니다 내 코드 들여 쓰기를 고집, 있는지 내 변수를 만들기 합리적으로 이름이 지정됩니다. 엔, 짧은 동안,에 대한 좋은 이름입니다 번호, 계산 정수 난, 문자열에 대한의. 그리고 우리는 더 이상 할 수 있습니다 변수 이름 스타일. 스타일은 얼마나 좋은 코드가 보입니까? 그리고 그것은 어떻게 읽을? 

그리고 시간이 지남에, 어떤 당신의 조교 및 TF가이 과정에서 할 것 그 당신에게 제공한다 질적 인 피드백의 종류 당신은 더 나은 얻을 수 있도록 그 다양한 측면에서. 그리고 방법의 측면에서 이들 각 축의 평가 그것은 거의 전형적이다 버킷 당신이 있기 때문에, 일반적으로, 당신이하고있는 얼마나 잘 감각을 얻을. 그리고, 참으로, 당신은 점수에 나타날 경우 그 axes-- 정확성, 디자인의 스타일 especially-- 그 숫자가 일반적으로 1에서 5 사이에있을 것입니다. 그리고, 문자 그대로 당신은 점점하는 경우 학기의 시작 3의, 이것은 매우 좋은 일이있다. 그것은 여전히​​ 의미합니다 개선의 여지, 당신의 희망 것이다 처음 클래스 복용. 천장의 일부 비트는 희망이있다 이는 당신이 도달에 주목하고 있습니다. 그리고 3의에 점점 초기 조각, 그렇지 않으면 일부 2의 4의, 참으로 좋은 일입니다. 그것은 잘 범위 내에서의 잘 기대 이내. 

당신의 마음이 경주되는 경우, 대기 분, 3 ~ 5 중. 그건 정말 (10)의 6 아웃입니다. 즉 60 %입니다. F.의 나의 하나님, 

그것은 아니다. 그것은 사실이 아니다. 오히려 향상시킬 수있는 기회의 학기의 과정을 통해. 그리고 당신은 어떤을 받고하는 경우 푸어스, 이러한 기회입니다 근무 시간을 활용하기 위해, 확실히 섹션 및 기타 리소스. 

베스트는 정말 기회입니다 당신이했습니다 얼마나 멀리 자랑하는 학기의 과정을 통해 제공됩니다. 그래서 실현 않는, 아무것도 경우 다른 세 좋다. 그리고 시간이 지남에 따라 성장을위한 공간을 할 수 있습니다. 

그 축이 방법으로 가중, 현실적으로 당신이있어 점점 대부분의 시간을 보낼 예정 작업에 일이 제대로 혼자 할 수 있습니다. 그리고 정확성는 경향이있다 와 같이, 대부분의 가중 될 셋이 곱셈 요인. 디자인도 중요하지만 당신이 필요하지 뭔가 에 그 시간을 모두 소비 일이 그냥 작동려고. 

그리고 그것은 가중있어 더 가볍게 조금. 그리고 스타일은 적어도 가중된다. 심지어 더 적은의 생각 근본적으로 중요한 것은, 그것은 그냥, 아마의 가장 쉬운 방법은 바로해야 할 일 예 우리를 흉내 낸 강의와 절에서 수행 잘 것들로 들여 쓰기 및 댓글, 등 가장 쉬운 방법 중 하나입니다 일이 이렇게 오른쪽 얻을 수 있습니다. 같은 그래서 실현 그 포인트는 것을 그 파악하기가 비교적 쉽다. 

그리고 지금 단어에 학문적 정직이 항아리. 과정의 당 그래서 강의 계획서, 당신은 볼 것이다 코스가 가지고있는 꽤 이 주위 언어의 비트. 그리고 과정의 문제를 소요 아주 심각하게 학문적 정직. 

우리는 차이를 가지고, 더 나은 또는 더 나쁜, 전송 한의 매년 더 징계 조치에 대한 학생 대부분의 어떤 다른 것보다 물론, 나는의 알고있다. 이것은 필요하지 않다 사실을 나타내는 CS 학생, 또는 CS50 학생들이 있음 덜 반 친구들보다 정직. 그러나 현실이이 세계, 전자, 우리 단지 기술이 이 검출 수단. 

그것은 우리에게 중요하다 클래스에서 공정성 우리가 할 것을이를 감지하고, 인상 문제 우리는 사물을 볼 때. 단지 그림을 그릴, 정말하기 이 싱크 같은 것을 돕기 위해, 이들의 숫자 지난 10 년 동안 학생들 일부에 관여 한 그 학문적 정직 등의 문제, 일부 (32) 학생 가을 2015 년에서하는 우리가 걸릴 않는 말을하는 것입니다 문제 매우 심각. 그리고, 궁극적으로,이 숫자는 구성, 최근, 3 %, 4 % 정도 클래스의. 

학생의 슈퍼 대부분 그래서 선이 분명한 것 같다. 그러나이 유지 않는다 특히 후반, 마음 밤에 고민 할 때 문제 세트에 몇 가지 솔루션, 메커니즘이 있음 더 나은 자신을 얻기를위한 당신보다 지원이 수도 심지어 그 시간에, 생각한다. 우리가받을 때 실현 학생의 제출, 우리는 교차 올해 모든 제출을 비교 모든 제출 작년에 대하여, 2007 년 모든 제출에 대하여, 뿐만 아니라,보고, 이후, 코드는 온라인 레포지토리 토론 포럼, 작업 현장. 그리고 우리는이 문제를 언급, 정말로 위해서 모든 전체 공개의 경우 그 다른 사람이 온라인을 찾을 수 있습니다 확실히, 우리 과정 수 있습니다. 하지만, 정말 정신 과정은 종기의 강의 계획서에서이 절에. 정말 그냥 합리적이다. 

그리고 우리는이 있다면 것을에 정교한하기 조금 더 언어, 실현 모두의 본질 이 과정에 제출 작업 자신의해야합니다. 하지만 내 확실히있다 기회와 격려, 에 의존와 교육적 가치 자신을 others--,하여 TFS는 CA에, 클래스에서 조교 등, 지원, 혼자 친구하자 룸메이트가 공부 한 자 전에 CS 및 프로그래밍. 그리고 그에 대한 수당이있다. 그리고 엄지 손가락의 일반적인 규칙 도움이 항아리 요청하는 경우, 당신은 다른 사람에게 코드를 표시 할 수 있습니다, 하지만 당신은 그들의를 볼 수 있습니다. 그래서 당신은 근무 시간에있을 경우에도, 또는 D 홀, 또는 다른 곳에서 일부 종 세트 작업, 친구와 함께 작업하는 상기 완전히 괜찮습니다 하루 작업의 끝 궁극적으로 각에 속해야 당신의 각각, 그리고 일부 공동 노력 수, 최종 프로젝트의 경우를 제외하고 그것은 허용하고 권장합니다. 

당신이 경우 실현 뭔가 고민 당신의 친구는 발생 다음이 더 잘 될 당신, 또는 당신보다 그 문제에 더 나은, 또는 더 멀리 앞서보다 조금, 이 켜 완전히 합리적인 당신의 친구에는, 헤이 말 여기에 내 코드를보고 줄래 않습니다, 내가 내 문제가 무엇인지 발견 돕는? 그리고, 희망,의 교육학 값의 관심 그 친구는 그냥 않습니다 아, 이렇게 말하는 것이 아니라 당신은 무엇을 행에 누락 6, 뭐 그런? 그러나 해결책은 아니다 당신 옆에있는 친구 오, 음, 여기, 내가 당겨 보자, 대답 이 위로, 그리고 당신에게 내 솔루션을 보여줍니다. 그래서 선이다. 당신은 당신의 코드를 표시 다른 사람,하지만 당신은하지 않을 수 있습니다 다른에 따라 그들의를 볼 수 과정의 강의에서 제약. 

그래서 마음이 유지 않는다 후회 절 소위 뿐만 아니라 과정의 강의에서, 당신은 어떤 행위를하는 경우 그 합리적인 아니지만으로 가져 과정의 머리의 관심 72 시간 내에 코스 지역의 제재를 부과 할 수 불만족을 포함하거나 제출 된 작업에 실패 학년. 그러나 과정은 참조하지 않습니다 추가 징계 조치에 대한 문제, 반복 행위의 경우를 제외하고. 즉, 당신이 경우에 어떤을 바보, 특히 늦은 밤, 결정 그 다음 날 아침에 이틀 나중에, 당신은 일어나 실현, 내가 무엇을 생각했다? 당신은 출구를 가지고 CS50에서 할 이 문제를 해결하기위한 그 그래서, 최대 소유 우리 중간 당신을 만나고 다룰 것이다 즉, 둘 다 그 문제에서와 교육 및 당신을 위해 가치, 하지만 어떤 방법으로 여전히 처벌. 그리고 지금,이 가장자리를 촬영합니다. 

[VIDEO 재생] 

[음악 재생] 

[END 재생] 데이비드 J. 마란 : 좋아, 우리는 다시 수 있습니다. 그리고 지금 우리는 하나 봐 우리 실제 도메인 제 CS50에서, 암호화의 예술, 전송 및 수신의 예술 비밀 메시지 암호화 메시지 만약에 당신, 당신이있는 경우에 그 만 해독 할 수 있습니다 발신자가 가지고있는 몇 가지 주요 성분 게다가. 우리가 할게요 그래서이 동기를 부여하기 A, 여기에이 일을보고 이는 예이다 비밀 디코더 링이 파악하기 위해 사용될 수있다 비밀 메시지가 실제로 무엇인지. 사실, 뒤쪽에 초등학교에서의 하루, 혹시에 비밀 메시지를 보낸 경우 어떤 친구 또는 클래스의 일부 호감, 당신이 생각했을 수 있습니다 당신은 영리되고 있었다 종이 변화의 당신의 조각에 의해, 같은 A B, 그리고 B C, 그리고 C D에, 기타 등등. 그러나 실제로 암호화 된 정보도 조금 사소한 되었다면 아니었다 어려운 교사 실현하기 위해, 물론, 당신은 단지 변경하는 경우 A와 C에 B는 B로, 당신은 실제로 파악 메시지가 무엇이고, 하지만 당신은 정보를 암호 처리에 있었다. 

당신은 그 일을했다 단순히 많은 Ralphie처럼 여기 재생 유명한 영화 거의 광고 nauseum 각각의 겨울. [VIDEO 재생] 이 모든 것을 알고 -bE 랄프 파커는 이로써입니다 리틀의 일원으로 임명 고아 애니 비밀 서클 모든 명예를받을 권리가있다 및 혜택은 이에 발생. 

-Signed, 리틀 고아 애니, 반대 서명 잉크, 피에르 앙드레. 명예와 이익, 이미 아홉의 나이에. 

[외침] - 어서. 의 그것과에하자. 나는 모든 재즈 필요하지 않습니다 밀수꾼과 해적에 대한. 

에 대해 들어 봐요 내일 밤 결론 모험 검은 해적선. 지금, 그것은 시간이다 애니의 비밀 메시지 비밀 서클의 당신 회원. , 아이, 회원 만 기억 애니의 비밀 서클의 애니의 비밀 메시지를 디코딩 할 수있다. 

기억, 애니 당신에 따라된다. B2에 핀을 설정합니다. 여기서 메시지이다. 12, 11-- 

- 난, 내 첫 번째 비밀 회의입니다. 

-14, 11, 18, 16. 

-Pierre은 큰 음성 오늘 밤에 있었다. 나는 오늘의 말할 수 메시지가 정말 중요했다. 

-3, 25, 즉 메시지의 애니 자신의. 아무에게도 말하지 않는 기억하십시오. 

-90 초 후에, 나는 단지에있어 집에 방 어디 아홉의 소년 개인 정보 보호 및 디코딩에 앉아 있었다. 아하, B! 나는 다음, E. 갔다 

첫 번째 단어가 될 것입니다. S, 지금 쉽게오고, U, 25-- 

오, 나는 가야겠다, Ralphie를 어서! 

오른쪽으로 오티스, 엄마! 맙소사! 

-T는, O, 무엇을해야 이러시면해야? 어린 고아가 무엇인지 애니 말하려고? 무엇을해야? 

-Ralphie, 앤디는에 도착했다 , 당신은 나와하시기 바랍니다 것입니다 가서? 

- 모든 권리, 엄마! 금방 나올거야! 

- 난 가까이 지금지고 있었다. 긴장은 끔찍했다. 그것은 무엇입니까? 행성의 운명 균형에 응답하지 않을 수 있습니다. 

-Ralphie! 앤디 돼 간다! 

큰소리로 우는 위해 바로 나올 할께! 

이 - 지하, 내 손가락은 내 마음을 날아 강철 함정이었다, 모든 구멍은 진동. 그것은 그래, 그래, 그래, 거의 분명했다. 

당신의 ovaltine 음료해야 -bE. Ovaltine? 싸구려 상업? 개자식. [END 재생] 데이비드 J. 마란 : OK, 그래서 그것은 매우 긴 길이었다 암호화를 도입, 또한 ovaltine. 사실,이 오래된 고라에서 여기에, 왜 ovaltine 너무 좋다? 그것은 잘 익은 농축 추출입니다 보리 맥아, 순수한 크림 우유, 특별히 함께, 코코아 준비 천연 인지질 및 비타민. 그것은 추가로 강화된다 추가 비타민 B와 D, 냠. 그리고 당신은 아직도 분명히 그것을 얻을 수 아마존에, 우리는 여기에 그랬던 것처럼. 

그러나 동기는 여기에 있었다 특히, 암호화를 소개합니다 알려진 암호화의 유형 비밀 키 암호로. 상기 이름은 전체 건의 비밀 키 암호 시스템의 보안, , 방법론 만약에 당신 다만 스크램블링 두 사람 정보는 것입니다 오직 송신자와 수신자 만 비밀 key--에게 약간의 가치를 알고, 일부 비밀 문구, 일부 비밀 번호, 그 모두 암호화에게 허용 정보를 해독. 그리고 암호화, 정말, 다만 이번 주 0입니다. 

그것은 입력을 거기에 문제의 영어로 실제 메시지 등 또는 어떤 언어로 당신을 클래스에서 다른 사람에게 보내려면, 또는 인터넷을 통해. 것입니다 일부 출력은있다 스크램블 메시지가 될 당신을 수신자가 수신 할 수 있습니다. 그리고 경우에도 누군가 중간, 그것도 수신 당신이 그들을 원하지 않는 반드시 암호를 해독 할 수 있습니다, 이 내부에 있기 때문에 블랙 박스, 또는 알고리즘, 어떤 메커니즘을 단계별로 몇 가지 단계입니다 그 입력을 복용에 대한 지침, 상기로 변환 희망 안전한 방법으로 출력. 

그리고, 사실,이 몇 가지 이 세상에서 어휘로 다음과 같습니다. 일반 텍스트는 단어 A는 컴퓨터 과학자 것 입력을 설명하는 데 사용 영어와 같은 메시지, 또는 무엇이든 실제로 언어를 다른 사람에게 보내려고합니다. 그리고 암호문은 스크램블입니다 암호화하거나, 암호화, 그 버전입니다. 

그러나 여기에 다른 성분이있다. 다른 하나의 입력이있다 비밀 키 암호. 그리고는 키 자체입니다, 이는 일반적이며 우리가 볼 수 있습니다로, 숫자, 또는 문자 또는 단어, 어떤 실제로되는 알고리즘은 기대한다. 

그리고 당신은 어떻게 정보를 해독합니까? 어떻게 당신은 그것을 해독합니까? 글쎄, 당신은 단지 역 출력 및 입력한다. 

즉, 사람이 한번 암호화 된 메시지를 수신하여 그 또는 그녀는 단순히 보유 같은 키를 알 수 있습니다. 그들은 암호문을 받았습니다. 그리고 그 둘을 연결하여 크립토 시스템에 입력, 알고리즘, 아웃이 블랙 박스, 원래 일반 텍스트를 제공해야합니다. 그리고 그것은 매우 높은 수준이다 암호가 실제로 무엇인지보기 모든 약. 

그럼 거기에 도착 할 수 있습니다. 의 지금 아래를 살펴 보자 뭔가의 후드 부여를 위해 우리가 복용 한 지난 주, 그리고이 세션 문자열을 here--. 하루의 끝에 문자열 문자 단지 순서입니다. 

그것은 안녕하세요 세계, 또는 수 안녕하세요 Zamyla, 또는 무엇이든. 그러나 그것은 무엇을 의미 하는가 일련의 문자 수? 사실, CS50 라이브러리 준다 우리 캐릭터라는 데이터 유형입니다. 

하지만 실제로이 C. 문자열과 같은 것 정말 그냥 순서입니다 문자, 캐릭터, 캐릭터 문자는, 다시,에, 백업하기 다시 내부 백업, 백업하기 컴퓨터의 메모리 또는 RAM의. 그리고 우리는에 그 더 깊이 살펴 보겠습니다 앞으로 우리는 메모리 자체를 볼 때 이용하고 및 관련된 위협. 

그러나의 문자열 Zamyla을 생각해 보자. 의, 그래서 그냥 이름 여기에 인간의, Zamyla, 그의 순서입니다 자, Z-A-M-Y-L-A. 그리고 지금의이 가정하자 그 Zamyla의 이름 컴퓨터 내에 저장되고 프로그램. 

음, 우리가해야 있음을 추론하기 위하여 서 그 문자를 볼 수 있습니다 개별적으로. 그래서 나는 조금을 그릴거야 여기 Zamyla의 이름 주위에 상자. 그리고 C의 경우 때를 그 어쩌면 Zamyla--과 같은 문자열이 그 문자열에서 돌아왔다 GET 문자열과 같은 기능, 당신은 실제로 조작 할 수 있습니다 문자로 그 문자. 

이제,이 대 밀접한 대화 손 때문에 암호화에 당신은 변경하려는 경우 D에 대한 B, 그리고 B C, 그리고 C, 등, 당신은 할 수 있어야합니다 개별 문자를보고 문자열입니다. 사용자가 변경할 수 있어야 뭔가는 A에 Z 에 뭔가의 M에 다른 등 뭔가. 그래서 우리는 방법이 필요합니다, 프로그래밍, 그래서 C에서, 말을하면 변경할 수 있도록 및 개별 문자 본다. 다음과 같이 우리는이 작업을 수행 할 수 있습니다. 

나를 다시 CS50의 IDE에 머리를 가자. 그리고 내가 앞서 가자 새로운 파일을 생성 나는이 시간 string0를 호출거야, 우리의 최초의 예를 들어, C 점을 찍는다. 그리고 앞서 갈거야 다음과 같이 그것을 채찍. 

그래서 CS50.h을 포함하고, 다음 표준 io.h를 포함, 어느 나는 거의 항상 갈거야 적어도, 내 프로그램에서 사용하고있을 처음에. 주요 무효를 int로하고 여기에 난 문자열을하기 위하여려고하는 문자열을 얻을 가져옵니다. 그리고 내가 갈거야 가서 이렇게. 나는 앞서 가고 싶어 그리고, 전성 검사로, 그냥 말, 안녕하세요, 퍼센트의, 세미콜론은 문자열 0을합니다. 어 오, 내가 여기에 무슨 짓을 한거야? 아, 나는 그것을 연결하지 않았다. 그래서 교훈은, 배운 의도적이 아니었다. 

그래서 오류, 더 퍼센트 데이터 인수보다 전환. 그리고 이것은에, 어디 라인 전하는 바에 좋아, 그럼 내가 가지고, 인용을 끝내 인용, 그건 내 문자열의 printf합니다. 나는 퍼센트 기호를 가지고있다. 하지만 두 번째 인수를 누락하고 있습니다. 

나는 쉼표들, 실종 해요있는 나는 앞의 예에있는 않았다. 그래서 좋은 기회가 해결합니다 또 하나의 실수, 실수. 그리고 지금 저를 실행하자 Zamyla에서 string0을 입력합니다. Zamyla 안녕하세요, OK. 

그래서 우리는 프로그램의이 종류를 실행했습니다 이제 몇 가지 다른 시간. 그러나의 뭔가 a를하자 이 때 다른 작은. 대신 Zamyla의 인쇄의 printf와 함께 밖으로 전체 이름, 의 문자에 의해 그것을 문자를 할 수 있습니다. 

나는 루프를 사용하겠습니다. 그리고 나는 나 자신을 줄거야 카운트 변수는, 내가 불렀다. 그리고 나는 그렇게 반복하는 유지하는거야 난 (S)의 길이보다 짧은만큼. 

그것은 밝혀, 우리는하지 않았다 이 마지막 시간을, 그 C는 함께 제공 함수는 스털링을했다. 위로 하루에, 그리고 일반적으로 정지 기능을 구현할 때 인간은 종종 매우 선택합니다 소리의 간결한 이름 종류 당신이 비록, 원하는 등 몇 모음 또는 문자 A가 없습니다. 따라서 스털링 인 함수의 이름이 사이의 인수를 문자열이어야한다 괄호. 그리고 그것은 단지 정수를 반환, 그 문자열의 길이. 

라인 7 루프이 그래서 것입니다 내가 0 같다에서 계산을 시작합니다. 그것은 증가 것 각 반복에 난 1, 우리는 몇 번 해 봤는데있다. 그러나 그것은 단지 할 것 포인트까지이 최대 나는 길이 인 경우 문자열 자체의. 

그래서 이것은 궁극적으로하는 방법 문자 반복 문자열에 그대로 따른다. 나는하지 인쇄 할거야 전체 문자열하지만 퍼센트 다, 단일 문자 새 행 하였다. 그리고 내가 갈거야 가서, 내가 필요 나는 인쇄 할 말을 S의 i 번째 문자. 

내가 나타내는 변수 있다면 문자열의 인덱스 당신은 거기에, 나는 할 수 있어야된다 나에게 S의 i 번째 문자를주고 말한다. C는하기의 방식이있다 대괄호이. 당신은 단순히 이름을 말 이 경우 s의 문자열. 그럼 당신은 대괄호를 사용 일반적으로 당신의 반환 또는 Enter 위 키보드의 키를 누릅니다. 그리고 당신은의 인덱스를 넣어 인쇄 할 문자. 따라서 인덱스는 될 것입니다 number-- 0 또는 1 또는 2 또는 3 또는 도트 점은, 다른 수를 점. 

그리고 우리는거야 있는지 확인 오른쪽 번호를 수 I 때문에 0 카운트 시작합니다. 그리고 기본적으로, 첫 번째 문자 문자열 컨벤션 0입니다. 그리고 두 번째 문자는 브래킷 1입니다. 그리고 세 번째 문자는 브래킷 2입니다. 그리고 당신도 가고 싶지 않아 지금까지, 그러나 우리는 우리가있어하지 않기 때문에 만 때까지를 증가 예정 문자열의 길이가 같다. 그리고 어느 시점에서, 루프이 중지됩니다. 

그래서 내가 가서이를 저장할 수 프로그램 및 실행 문자열 0을합니다. 하지만 망쳐. 암시 라이브러리 함수를 선언 유형 등으로 스털링 지금 such--, 이 익숙한 소리. 그러나는 printf 아니에요. 그리고 문자열을 얻을 아​​니에요. 

나는에 나사를하지 않았다 동일한 방법이 시간. 하지만 여기까지 조금을 알 또한, 상기 헤더 string.h를 포함 명시 적으로 제공 스털링에 대한 선언. 그래서 실제로 거기에 단서가있다. 

그리고 사실이 밝혀 다른 헤더 파일이있다 우리는 사용되지으니 클래스에 아직, 그것은하지만입니다 사용할 수있는 중 당신에게, string.h를했다. 그리고 그 파일 string.h에 스털링 선언이다. 그래서 내가 가서 보자 문자열을,이 저장 0-- 좋은, 아니 오류 메시지가이 시간. 

./string0 Zamyla하고, 나는, Enter 키를 누르려고 해요 하는 점에는 getString는 것입니다 문자열을 반환,의에 넣어. 루프 반복하는 것입니다 그 한 번에 하나의 S의 문자를 통해, 하기 때문에, 그들에게 한 줄에 하나씩 인쇄 나는 끝이 백 슬래시 n을했다. 그래서 나는 백 슬래시를 생략 할 수있다 N, 다음 그냥 모든 Zamyla를 인쇄 같은 줄에, 효율적으로 재 구현 모두 유용하지 않습니다 printf와. 그러나이 경우, 나는 그것을하지했습니다. 사실 하나를 인쇄했습니다 한 번에 문자 한 줄에 하나씩, 그래서 우리는 실제로 효과를 볼 수있다. 

그러나 나는 여기서 한 가지주의해야한다. 그리고 우리는 다시 올 것이다 미래의 주에서이. 그것은이 밝혀 코드는 잠재적 버그입니다. 

그것은 그 GET 문자열을 밝혀 삶의 일부 다른 기능 반드시 항상하지 않습니다 당신이 기대하는지 돌아갑니다. 우리는 지난 시간 알고 얻을이이 시간 문자열은 문자열을 반환 할 예정이다. 그러나 이러한 아웃 사용자 유형의 경우 긴 단어, 또는 단락, 또는 에세이 충분하지가 있음 컴퓨터의 메모리가 적합합니다. 

마찬가지로, 무슨 일이 가면 후드 아래에 잘못? 그것은 자주 발생하지 않을 수 있습니다 그러나 한번 일어날 수 한 동안 매우 드물게. 그리고 그것은 그 GET 문자열을 밝혀 과 같은 기능을 반드시 수행 항상 문자열을 반환합니다. 그들은 일부 오류 값을 반환 할 수 있습니다, 일부 감시 값 때문에, 말하자면 그는 것을 나타냅니다 뭔가 잘못왔다. 그리고 당신은 단지에서 이것을 알 것 이제 클래스에서 배운 데, 또는 좀 더 문서를 읽은. 그것은 그 GET 문자열을 밝혀 널 (null)라는 값을 반환 할 수 있습니다. 널은 우리가 거​​ 특수 값입니다 미래의 주에 되돌아 온다. 하지만 지금은, 그냥 내가 원하는 경우 알고 전진 정말 적절한 될 수 있습니다 GET 문자열을 사용하여, I 그냥 전화 안, 그리고 맹목적으로 반환 값을 사용하여, 이 문자열 있다는 신뢰. 

내가 먼저 말을해야 헤이 만, 잠깐 s는 동일하지 않으면 계속 널 여기서 널 다시, 그냥 몇 가지 특별한 값입니다. 그리고 그것은 유일한 특수 값입니다 당신 GET 문자열을 걱정해야합니다. 문자열 중 하나를 것입니다 오기 문자열 또는 null을 반환합니다. 

그리고이 느낌표 등호 당신은 아마 수학 클래스에서 알 수 있습니다 당신과 등호를 그릴 수 있음 그것을 통해 선이 동일하지 나타냅니다. 즉, 일반적으로 성격이 아니다 당신은 당신의 키보드에서 입력 할 수 있습니다. 그리고 대부분의 프로그래밍 언어에서, 당신이 동일하지 않은 말을 할 때, 당신은 느낌표를 사용, 그렇지 않으면 탕으로 알려져 있습니다. 그래서 당신은 강타가, 동일 말을하는 하지 논리적으로 같음을 의미합니다. 그것은 더 큰 거기 그냥처럼 이상, 또는 동일하거나보다 같거나 키보드의 키 입력하기 즉, 하나의 심볼에서 모든 작업을 수행합니다. 그래서 그 이유는, 과거의 예에서, 당신은 오픈 브래킷을 한 후 등호는 순서대로해야 할 일 보다 크거나보다 작 말한다. 

그래서 테이크 아웃은 여기에 무엇입니까? 이것은 현재의 방법으로 단순히 이 구문을 도입,이 기능, 개별 반복 문자열의 문자. 그리고 바로 그 광장 등 브래킷은, 당신이 그들을 얻을 수 있습니다 로 그 대괄호를 고려 종류의이 기본 암시 디자인, 이에 모든 문자열의 내부 문자 가지 아래 어딘가에 박스입니다 컴퓨터의 메모리에 후드. 

그러나 이제이의 변형을 만들 수 있습니다. 그것은이 밝혀 프로그램은 올바른 것입니다. CS50의 축 당 그래서 평가 코드는이 지금은 올바른 것입니다. 특히 지금은 검사거야 것을 null의 경우,이 프로그램이 충돌해서는 안됩니다. 그리고 난 그냥 경험으로부터 알고있다. 그러나 아무것도가 없습니다 우리가 정말 잘못 여기에 갈 수 있습니다. 그러나 그것은 매우 잘 설계된 아니에요 때문에하는 것은 이제 기본으로 돌아 가자. 

첫째, principles-- for 루프는 무엇을합니까? 루프에 대한 세 가지 작업을 수행합니다. 그것은 몇 가지를 초기화 값, 당신이 그것을 요​​구하는 경우. 그것은 상태를 확인합니다. 그리고 그 후 각 반복, 각주기 후, 그것은 일부를 증가 여기에 값 또는 값. 

그래서 무엇을 의미합니까? 우리는 i가 0에 초기화합니다. 우리는 확인하고 있는지 확인 난 미만 Z-A-M-Y-L-A 인 (S)의 길이, 그래서 미만 6이다. 그리고, 참으로, 0 미만 6있다. 

우리는 Zamyla의 이름에서 Z를 인쇄 할 수 있습니다. 그 다음 우리는 0에서 1로 전을 증가. 우리는 그 다음 1 이하, 확인 (S)의 길이보다? (S)의 길이는 6이다. 네, 그렇습니다. 

그래서 우리는 Zamyla의 이름, ZA에 인쇄 할 수 있습니다. 우리는 2, 1, 0에서 난을 증가. 우리는 그 다음 2보다 작 확인 Zamyla의 이름의 길이. 6- 그래서 2 6 미만이다. 네, 그럼 이제 M을 인쇄 할 수 Zamyla의 이름, 세 번째 문자. 

열쇠는 여기에 각 해당 인 이야기의 반복, 나는 확인하고있어, 내가 Zamyla의 길이보다 작은? 그러나 캐치이다 스털링은 등록하지 않습니다. 프로그래밍 한 분들 자바 나 다른 언어로 이전 문자열 인의 길이를 알 수 있습니다 속성은, 그냥은 값을 읽습니다. 

이 경우 C에서,이이면 문자 그대로 함수 개수를 세고 때마다 Zamyla의 문자 우리는 그 함수를 호출합니다. 마다가 사용하는 컴퓨터를 요청할 스털링, 그것은, Zamyla에 모습을 복용 하고 말하는 Z-A-M-Y-L-A, 6. 그리고 6을 반환합니다. 당신이 전화를 다음 번에 루프 그 안에 그것은, Zamyla 볼 것 다시, Z-A-M-Y-L-A, (6)을 말한다. 그리고 6을 반환 할 것입니다. 그래서이 디자인에 대한 바보 무엇입니까? 

왜 내 코드가 아닌 5 개 만점에 5 점입니다 지금 디자인, 말하자면? 글쎄, 내가 부탁 해요 불필요하게 질문입니다. I가 필요한 것보다 내가 더 많은 일을하고 있어요. 

그럼에도 불구하고 대답은 내가, 정확 컴퓨터를 묻는 것입니다 다시 Zamyla의 길이, 그리고 또 다시, 다시? 그리고 그 대답은 결코 변경하려고합니다. 항상 6 될 것입니다. 

이보다 그래서 더 나은 솔루션 이 다음 버전이 될 것이다. 내가 앞서 가자와에 넣어 string1.c라는 별도의 파일, 그냥 분리 유지합니다. 그리고 그것은의에서 밝혀 루프, 당신은 실제로 수 한 번에 여러 변수를 선언합니다. 

그래서 난을 유지하고 0으로 설정하겠습니다. 그러나 나는 또한 갈거야 쉼표를 추가하고, 말, 나에게 그 N이라는 변수를 제공 값의의 문자열 길이와 같습니다. 그리고 지금, 내 상태를 확인하십시오 너무 오래 전 n보다 작은있다. 

따라서 이러한 방식으로, 논리는 하루의 끝에서 동일합니다. 그러나 나는 기억하고있다 이 경우에는 값 6. Zamyla 이름의 길이는 무엇입니까? 그리고 N에서 퍼팅하고있다. 

그리고 난 아직 확인 해요 조건마다. 0 6 이하인가? 1 6 이하인가? 등이 6 미만 및인가? 

하지만 컴퓨터를 요구하고 있지 않다 다시, 다시, 무슨 일이야 Zamyla 이름의 길이? Zamyla 이름의 길이는 얼마입니까? 이 Zamyla 이름의 길이는 얼마입니까? 말 그대로 기억하고있어 그 제 단지이 두 번째 변수 (n)에 대한 답변. 그래서 지금뿐만 아니라 것 올바른뿐만 아니라, 잘 설계된. 

자, 어떤 스타일은 어떻습니까? 내 변수를 명명 한 꽤 잘, 나는 말할 것입니다. 그들은 지금 매우 간결입니다. 그리고 완전히 괜찮아요. 

당신은 단지 하나가있는 경우 프로그램에서 문자열, 당신은뿐만 아니라 그것을 문자열 s의 호출 할 수 있습니다. 당신은 단지 하나의 변수가있는 경우 프로그램의 카운트, 당신은뿐만 아니라 그것을 내가 전화 할 수 있습니다. 만약 길이를 갖는 경우, N 뿐만 아니라 슈퍼 일반적입니다. 하지만 내 코드의 댓글을 달았하지 않았습니다. 

나는 reader--을 통보하지했습니다 그건 내 TF, 또는 TA 여부, 아니면 그냥 가정 무엇 colleague-- 에이 프로그램에서 진행된다. 그래서 좋은 스타일을 얻으려면, 내가하고 싶은 것이 무엇 이 항아리 무언가가있다 같은 입력을 사용자에게 요청합니다. 그리고 나는 다시 수 방법이 임의의 수. 

확인 GET을 s-- 확인 문자열은 문자열을 반환했습니다. 그리고 here--에서 이것은 아마도 가장 중요한 comment-- 반복 처리 한 번에의 하나의 문자를 통해. 그리고 나는 어떤을 사용할 수 있습니다 영어의 선택 여기에서 설명하는 각 이러한 코드 청크. 

내가 넣어하지 않았 음을 주목하라 코드의 모든 라인에 대한 의견, 정말 흥미에 사람, 사람이 어떤 의미가 그 나는 수도 사람에게 매우 명확하게 할 코드를 읽고. 왜 당신은 얻을 호출 문자열 입력을 사용자에게? 심지어 하나 반드시 없다 모든 것을 설명. 하지만, 이야기를하는 데 도움이 있기 때문에 이야기의 두 번째 줄이 있는지 확인한다 얻을 문자열은 문자열을 반환했습니다. 

그리고 이야기의 세 번째 줄입니다 의 하나의 문자 반복 한번에. 그리고 지금은 그냥 좋은 측정을위한, 내가 가서 추가 할거야 한 번 더 설명이 단지 의에 인쇄 i 번째 문자는 말한다. 자, 내가 수행 한 하루의 끝에서? 

나는 약간의 영어 추가 댓글의 형태로 단어. 슬래시 슬래시 기호 야, 의미, 이 인간을위한 컴퓨터, 아니 당신을 위해, 컴퓨터. 그래서 그들은 논리적으로 무시하고있다. 그들은 단지 거기. 

그리고, 참으로, CS50 IDE는 그들을 보여줍니다 회색 유용하지만, 키가 아닌 것으로 프로그램에. 당신은 지금 무엇을 할 수 있는지 알 수 있습니다. 당신은 C를 알고 있는지 여부 프로그램 또는 아니라, 그냥이 다시 설 수 프로그램은과 주석을 탈지. 확인, 입력을 사용자에게 문의 문자열이 문자열을 반환받을 S의 문자 반복 한 번에 하나의 문자를 인쇄 i 번째 문자 s-- 당신은하지 않습니다 심지어 코드를보고있다 이 프로그램이 무엇을하는지 이해합니다. 그리고, 더 나은 아직, 당신 자신을 보면 한 두 주에서이 프로그램에서, 또는 한 달, 또는 년, 당신도이 없습니다 코드를 응시하는, 기억하려고, 내가이 코드와 함께 일을하려고했다? 

당신은 자신을 말 했어요. 당신은 자신을 위해 그것을 설명했습니다, 일부 동료, 또는 TA, 또는 TF 나. 그리고이 이제 것 올바른, 디자인 좋은, 궁극적으로 스타일 좋은뿐만 아니라. 그래서 명심 않습니다. 

그래서 다른 하나는있다 일이 여기 할거야 즉, 지금 정확히 무엇을 밝힐 수 후드 아래에 계속. 따라서이 기능이있다 C 및 기타 언어, 라는 타입 캐스팅 그 암시 또는 명시 적으로 변환 할 수 있습니다 다른 하나의 데이터 유형에서. 우리는 그렇게 처리했습니다 문자열까지 오늘. 

그리고 문자열은 문자입니다. 그러나 주부터 리콜 0, 문자는 무엇인가? 문자는 추상이다 numbers-- 진수의 상단에, 그리고 진수는 정말로 단지입니다 이진수 위에 추상화, 우리는 그것을 정의. 

그래서 문자는 숫자입니다. 그리고 번호는 문자는, 다만 상황에 따라. 그리고 그 안에 밝혀 컴퓨터 프로그램, 당신은 당신이보고 싶은 방법을 지정할 수 있습니다 해당 프로그램의 내부 비트에서? 

우리가 가진 주 0에서 리콜 그냥이 코드는 아스키, 숫자에 매핑 문자. 그리고 우리는 자본 A는 65 말했다. 자본 B는 등 66합니다. 

그리고 통지, 우리는 본질적에 문자가 여기에 맨 위 행, C가 그들에게 전화하는 것처럼, 문자하고 두 번째 행에 정수. 그리고 그것은 당신이 변환 할 수 있습니다 밝혀 원활 일반적으로이 사이. 그리고 우리는 수행하려는 경우 이 의도적으로, 우리 해결하기 위해 할 수 있습니다 이 같은. 

우리는 변환 할 수 있습니다 대문자는 낮추는 경우, 또는 대문자로 소문자. 그리고 거기의 밝혀 여기에 실제로 패턴 우리는 단지 한 순간에 받아 들일 수 있습니다. 그러나의는에 처음으로 살펴 보자 명시 적으로이 일을 예. 

나는 CS50의 IDE로 돌아갈거야. 나는를 만들거야 파일 아스키 0.c.라고 내가 가서 추가하는거야 내 상단에 표준 io.h, INT 주요 무효 내 함수의 상단. 그리고 난 그냥 할거야 내가 같음에서 for 루프 following--, 이제, 65 가정 해 봅시다. 

그리고 내가 미만이 될 것입니다 알파벳 65, 플러스 26 문자. 그래서 컴퓨터를 드리겠습니다 거기에 나를 위해 수학을. 그리고이 루프 내부, 내가 인쇄 하겠어? 

% C는 i가 n 개의 백 슬래시 %이다. 그리고 지금은 두 값을 연결하려고합니다. 나는 일시적으로 질문을 넣었습니다 질문을 초대가 표시합니다. 

나는 이후 65에서 반복 할 알파벳의 26 글자를 들면, 각 반복에 밖으로 인쇄하는 캐릭터의 필수적인 것과 같습니다. 즉, 내가 원하는 이상 26 번호 인쇄를 반복 ASCII 문자가 무엇인지, 편지, 상기 해당 번호가 무엇 is-- 정말 다시 해당 슬라이드의 차트입니다. 그래서이 물음표는 무엇을해야 하는가? 

음, 제 2 밝혀 하나는 변수 내가해야한다. 나는 숫자로 그것을보고 싶어요. 그리고 중간에 인수 여기에, 나는 컴퓨터를 알 수 있습니다 그 정수를 치료하는 내가 문자로, 그래서 퍼센트 C. 여기를 대체하는 

즉, 만약 I의 인간의 프로그래머, 알고 이 단지 숫자 하루의 끝에서. 그리고 65해야 알아 일부 문자에 매핑됩니다. 이 명시 적 캐스트와 함께, 괄호와 함께, 당신이 원하는 데이터 유형의 이름 변환 및 닫힌 괄호 당신은 말할 수 컴퓨터, 헤이, 컴퓨터, 숯불이 정수를 변환합니다. 

그래서 나는이 프로그램을 실행할 때 프로그램 컴파일 후, 의 내가 아스키는 0이거나 먹어을 확인 할 수 있습니다. 그것은 이놈, 내가 잘못 여기에 무슨 짓을 한거야? 선언되지 않은 식별자의 사용 모든 의도적 인, 옳지 않아, 그러나 보자 경우 우리는 할 수 없습니다 이를 통해 이유. 

그래서 라인은 내가하지 않았다 five-- 아주 멀리 망쳐 전에. 괜찮아. 그래서 난에 대한 선 (5)에 해당 65-- 난을 참조하십시오. 그래서 일부는 달리, C에서 그 기억 당신이 이전에 프로그램이있는 경우 언어 경험, 당신은 컴퓨터를 이야기하고, 스크래치는 달리, 무엇을 변수의 종류가있다. 

그리고 여기에서 중요한 어구를 잊어 버렸습니다. 라인 오, 나는 내가 사용하기 시작했습니다. 하지만 C를 말하지 않았다 어떤 데이터 유형이있다. 그래서 내가 여기에 갈거야 및 아, 그것은 정수 확인 말한다. 

지금은 가서 다시 컴파일거야. 즉, 그 고정. 입력 ./ascii0, 그 종류의 멋진입니다. 뿐만 아니라 그것은 슈퍼 빠른 컴퓨터이 질문을 오히려 슬라이드를 보는 것보다, 그것은, A가 65, 한 줄에 하나씩 인쇄 B는 I 이후 down-- (66), 모든 방법입니다 , 문자 z를이 26 times--했다 이는 90입니다. 그리고, 사실, 약간 보다 지능적인 것 나를 위해 없었을 의존하는 컴퓨터에 26를 추가합니다. 난 그냥 할 수 있었다 (90)뿐만 아니라, 너무 오래 내가 두 번 같은 실수를하지 않는 한. 나는 통해 가고 싶어 Z가 아닌 그냥 y를 통해. 

그래서 명시 적 캐스트입니다. 그것은이 밝혀 도 필요하지 않습니다. 내가 가서이를 다시 실행하자 컴파일러, 다시 실행 아스키 0. 그것은 C 꽤 똑똑 것으로 나타났다. 

그리고 printf와, 특히, 꽤 똑똑하다. 당신은 단지 두번 난을 전달하는 경우 모두 자리에 대한, printf의 실현합니다 오, 잘 난 당신을 알고 내게는 어떤 수를 integer-- 준, 65, 90, 또는 무엇이든 등을들 수있다. 그러나 나는 당신이 저를 원하는 참조 문자처럼 그 번호를 포맷합니다. 그리고 printf의 암시 적으로 변환 할 수 있습니다 뿐만 아니라 당신을 위해 문자를 int로. 그래서 전혀 문제가되지 않습니다. 

그러나이 때문에 등가의, 통지 우리는 실제로뿐만 아니라이 작업을 수행 할 수 있습니다. 내가 가서 하나를 만들어 보자 이 항아리 아스키 1.c.의 다른 버전 그리고 대신에 걸쳐 반복 정수, 정말 당신의 마음을 날려 버릴 수 있습니다 문자 반복에 의해. 숯불 c를 대문자 A를 얻을 수 있다면, 가서이 작업을 수행하려면, 오랫동안 C는 이하와 같이 자본 Z.에 그리고 각 반복에 나는 내가 할 수있는, C를 증가 할 지금 여기 내 printf의 라인 말하자면, %의 C이다 퍼센트 난 다시, 쉼표 C. 

그리고 지금, 나는 다른 방향으로 갈 수 있습니다, 명시 적 캐릭터 캐스팅 정수로. 그래서, 다시, 왜 이런 짓을 했을까? 그것은으로 정렬하려면 좀 이상해 문자의 관점에서 계산합니다. 

하지만 당신은 무엇을 이해한다면 후드 아래에 가고, 마술은 정말 없습니다. 당신은 헤이, 컴퓨터주고, 말을하는지 나 char 형의 C라는 변수. 자본 A.로 초기화하고 작은 따옴표 물질을 알 수 있습니다. 

C에서 문자의 경우,에서 기억 지난 주, 당신은 작은 따옴표를 사용합니다. 문자열, 단어, 문구는 큰 따옴표를 사용합니다. OK, 컴퓨터, 그래서이 일을 계속 문자만큼 미만 또는 z와 동일. 그리고 내 아스키 테이블에서 알고있는 모든 이 아스키 코드의 연속이다. 

틈이 없습니다. 그래서, 그냥 Z를 통해입니다 하나의 번호 각각에 의해 분리된다. 그리고 내가 증가 할 수 있습니다 숯불, 내가 정말 원하는 경우. 하루의 끝에서, 그것은 단지 숫자입니다. 나는이 사실을 알고. 그래서 난 그냥 1을 추가 추정 할 수 있습니다. 

그리고이 시간, 나는 C를 인쇄, 다음 적분 것과 같습니다. 그리고 난 명시 적 캐스트가 필요하지 않습니다. 나는 printf의과를하도록 할 수 있습니다 컴퓨터 그림 것들을 밖으로, 그래서 지금은 실행하는 경우 , Ascii1./ascii1을 나뿐만 아니라 동일한 일을 찾으실 수 있습니다. 

쓸모없는 프로그램, 아무도 though-- 없습니다 실제로 소프​​트웨어를 작성하는 것입니다 파악하기 위해, 무엇을했다 (A)에 맵핑 번호 또는 B, 또는 Z? 당신은 그냥 Google에 가고, 나하고 온라인을 찾아, 또는 그것을 찾아 슬라이드 등을합니다. 어디이 실제로 도움이 나올까요? 

글쎄, 그건 말하고 슬라이드, 거기에 알 대문자와 여기에 실제 패턴 소문자 실수하지 않았다 그. 그 자본 A는 65 알 수 있습니다. 소문자 a는 97입니다. 그리고 얼마나 멀리 떨어져 낮은 경우입니까? 

그래서 (65)는 몇 걸음 거리에 97인가? 그래서 97을 뺀 65 (32)이다. 그래서 자본 a는 65입니다. 당신은 32를 추가하는 경우, 당신은 소문자 얻을. 그리고, 동등하게, 당신은 32 빼기 경우, 당신은 자본으로 돌아 가야 할까 .. B와 동일 거의 다 거의 나에게 큰 C. 

이러한 갭은 모두 떨어져 32이다. 지금,이에 우리를 허용 할 것 같다 마이크로 소프트 워드 같은 것을 할, 또는 구글 문서 도구, 어디를 갖추고 있습니다 모든 것을 선택하고 말할 수있는, 소문자로 모두 변경하거나 대문자로 모든 변경, 또는 첫 번째 단어를 변경 대문자로 문장의. 우리는 실제로 뭔가를 할 수 자신처럼. 

내가 가서 보자하고 파일을 저장 여기 0.c.를 대문자로 불리는 그리고 이제 가서 프로그램을 채찍질하자 즉, 정확하게는 다음 있다고한다. 그래서 CS50 라이브러리를 포함한다. 그리고 표준 I / O를 포함한다. 

그리고 나는 이것이 곧 제공 될 예정입니다 알고있다. 그래서 난에 넣어 갈거야 거기에 이미, string.h, 그래서에 액세스 할 수 있습니다 스털링 같은 것들, 다음 평소와 같이, 메인 공백을 int로. 그리고 내가 가서거야 문자열을하는 문자열을 얻을 도착, 단지 사용자로부터 문자열을 얻을 수 있습니다. 그리고 내가 갈거야 내 정신 검사를 수행. 문자열이 동일 널 (null)이되지 않으면, 다음은 진행하는 것이 안전합니다. 그리고 내가 무엇을 하시겠습니까? 나는, 내가 0 같다에서 반복하는거야 n은 S의 문자열 길이까지. 

그리고 나는 너무 오래로이 작업을 수행하는거야 내가 플러스 플러스 n보다 작은합니다. 지금까지, 나는 정말이야 전에에서 아이디어를 빌려. 그리고 지금은 나뭇 가지를 소개하겠습니다. 

그래서 스크래치, 다시 생각한다 우리는 길에서 그 포크를했다 그리고 지난 주 C.에 나는 갈거야 이 말을하는 경우들에서 i 번째 문자 인 이상의 경우을 낮출 동일, 그리고 - 스크래치에서 당신은 말 그대로 것 그리고,하지만 C에서 당신이 앰퍼샌드 말 말 ampersand-- 및 S의 i 번째 문자 보다 작거나 케이스 Z 낮은 같음 의 흥미로운 뭔가를 할 수 있습니다. 의는 사실을 출력하자 없는 줄 바꿈과 문자 그 문자열의 문자입니다, 문자열의 i 번째 문자. 

그러나의를 진행하자 그것에서 32을 뺍니다. 다른 경우의 문자 우리가 찾고있는 것을 문자열 , 조금 사이 아니다 작은 Z, 진행 단지 변화를 인쇄. 그래서 우리는 도입했습니다 이 괄호 표기 우리의 문자열은에서 얻을 수에 대한 문자열에서 내가 번째 문자. 

내가 좋아하는 몇 가지 조건부 논리를 추가했습니다 지난 주 주 하나에 스크래치 난 그냥 내 기본을 사용하고 있습니다 무엇의 이해 후드 아래에 계속. S의 i 번째 문자 인 (A)에 이상인? 마찬가지로, 97, 또는 98 또는 99 등? 

그러나 그것은 또한 이하인 소문자 Z의 값? 그렇다면,이 라인은 무엇을 의미합니까? (14)이 일종의 전체 아이디어의 세균, 하여 문자를 대문자로 단순히, 그것에서 32을 뺀 이 경우, 나는 알고 있기 때문에, 그 당 내 번호가 표시되는 방법을 차트. 그럼 가서 이것을 실행하자, 0.c를 대문자로 컴파일 한 후, 및 실행은 (는) 0 투자. 

뭔가를 입력하자 모든 소문자 Zamyla을 입력합니다. 그리고 지금 우리는 모두 대문자로 Zamyla 있습니다. 의 모든 소문자 롭을 입력 할 수 있습니다. 의 모든 소문자로 제이슨을 해보자. 그리고 우리는 점점 계속 강제 대문자. 사소한 버그가 있습니다 그 I 가지 예상하지 않았다. 나의 새로운 메시지가 종료되어 주목 자신의 이름과 같은 줄에, 하는 약간의 혼란을 느낀다. 

그래서 여기에 갈 예정하고있어 실제로,이 프로그램의 끝 개행 문자를 인쇄 할 수 있습니다. 그게 다야. printf와 함께, 당신은 할 필요가 없습니다 변수 또는 형식 코드를 전달합니다. 당신은 말 그대로 그냥 인쇄 할 수 있습니다 줄 바꿈 같은. 

그럼 가서 만들어 보자 , Zamyla을 다시 실행, 다시 0을 활용. 그리고 지금은 조금 더 예뻐이다. 지금, 내 메시지가 자신의 새로운 라인입니다. 그래서 모든 벌금과 좋은입니다. 그래서 그 좋은 예입니다. 하지만 난 필요하지 않습니다 하드 코드 32이 필요합니다. 당신 그거 알아? 나는 내가하지 say-- 수 그 차이가 무엇인지 기억한다. 

하지만 내가 알고있는 경우 I 소문자를 가지고, 나는 기본적으로 해제 빼기 할 어떤 거리가 조금 사이 a와 큰 A, 때문에 가정하면 다른 모든 문자는 동일 그 작업을 완수해야한다. 그러나 그렇게하기보다는, 그거 알아? 또 다른 방법이있다. 

내가 있다면 그 1.c-- 투자 인 경우 별도의 파일에 그것을 넣어. 다음의이 2.C을 활용하자. 난 정말 여기를 정리하겠습니다. 그리고 대신에도를 갖는 알거나 그 낮은 수준에 관심 구현 세부 사항은, 내가 대신 해요 그냥 문자를 인쇄하는 것, 인용 인용을 끝내, %의 C 및 다음 다른 함수를 호출하는 그 인수를 취 존재, 이는 같은 캐릭터입니다. 

그것은 거기에, C에서 밝혀 다른 함수 호출 상부에있는 그것의 이름으로 건의 문자를한다 그 대문자로 만든다 등가하고 리턴 그래서 printf와 거기에 연결할 수 있습니다. 그래서 난,하지만이 작업을 수행하는 다른 하나의 파일을 도입 할 필요가있다. 다른 파일 거기에서 그것은집니다 당신은 단지 클래스에서 알고있는 것, 교과서, 또는 온라인 또는 참조, 호출 C의 type.h. 

내 헤더 사이에 그를 추가 그래서 경우 파일은 이제 다시 컴파일이 프로그램을, capitalize2는 입력 ./capitalize2. 의 모든에 Zamyla를 입력하자 소문자, 여전히 동일하게 작동합니다. 하지만 당신은 알아? 그것은 상단에 해당 밝혀 다른 기능이 있습니다. 

그리고 날이를 소개하자 일종의 가벼운 부상을 입, 여기에 명령 이름,하지만 설명서 남자. 그것은 대부분의 리눅스 컴퓨터를 밝혀 우리는 리눅스 운영을 here-- 사용하는 등 명령이 외 시스템 라고 불리는 사람, 이봐, 컴퓨터, 줘 컴퓨터의 사용 설명서. 당신이 원하는 작업 이 설명서에서 찾아 볼? 

나는 기능을보고 싶지 상단에 부름을 입력합니다. 그리고 약간의 비밀입니다 때로는 읽을 수 있습니다. 그러나 우리가에있어주의 리눅스 프로그래머 매뉴얼. 그리고 그것은 모든 텍스트입니다. 그리고 거기에 알 여기까지 함수의 이름을 지정합니다. 그것은이라는 사촌이 밝혀 반대를 수행하는 낮 춥니 다. 그리고 시놉시스에서 통지, 이것을 사용하기 , 말하자면, 그 사람 페이지를 작동 나에게 그 I를 말하고있다 ㄴ type.h.을 포함해야 그리고 연습에서 것을 알고 있었다. 

여기서, 나에게 두 가지를 보여주는 것 함수의 프로토 타입, 그래서 나는 지금이 사용하려는 경우 나는 그들이 입력으로 취 무엇인지, 그들은 출력으로 반환 할 것을. 그리고 나는 읽으면 설명, 내가 참조 보다 상세 기능은 무엇. 하지만 더 중요한 것은, 만약 나는, 반환 값에 따라보고 그것은 반환 값이 말한다 변환 된 편지의, 또는 C, 원래의 입력, 경우 변환이 불가능했다. 

즉, 상부하려고합니다합니다 대문자로 편지를 변환합니다. 그리고 만약 그렇다면, 그것을 반환 할 것입니다. 하지만 일부 reason--에 대한이 할 수있는 경우 어쩌면 이미 대문자가있어, 어쩌면 느낌표입니다 또는 다른 punctuation-- 그냥가는거야 원래 C를 반환 내 코드를 만들 수 있음을 의미 다음과 같이 더 나은 디자인했다. 

나는 모든 필요하지 않습니다 이러한 코드 이놈 라인. 나는했습니다 라인의 모든 그냥 강조 할 수 하나의 간단한로 축소 할 이 항아리의 printf 퍼센트 인 라인, 상단 S 브라켓 난에 다. 그리고 이것은이 될 것입니다 더 나은 디자인의 예. 

왜 7 항 또는 제 8 라인 구현 코드, 그것은 그냥 어떤했다 대신 축소 할 수 있습니다 때, 삭제 그 논리 및 의사 결정의 모든 지금은 하나의 라인 (13)에 그 라이브러리에 의존 function-- 는 C와 함께 제공 기능,하지만 당신이 뭘 원하는지 정확히 않습니다. 그리고, 솔직히 경우에도 그것은 C와 함께 제공되지 않은, 당신은, 스스로를 구현할 수 우리는 부정적인 INT를 얻을 수와 봤어요 뿐만 아니라 긍정적 인 INT 지난 주 얻을. 

이 코드는 훨씬 더 읽을 수 있습니다. 그리고, 참으로, 우리가 이동하면, 얼마나 훨씬 더 컴팩트 보면 내 프로그램의 버전입니다. 그것은, 지금은 조금 위에 무거운 모든 포함와. 지금 내가 서있는거야 때문에하지만, 괜찮아요 프로그래머의 어깨에 내 앞에. 그리고 그것은 누구 누구 정말 상단에 구현 많은처럼, 나에게 부탁을했다 누구 구현 스털링 정말 얼마 전에 나에게 부탁을했다. 그래서 지금 우리는이 더 나은 디자인 프로그램 즉, 동일한 로직을 구현한다. 

스털링의 말하기,하자 나 가서 이렇게. 내가 가서 저장하자 stirling.c으로이 파일. 그리고 그것은 밝혀, 우리는 다시 벗겨 수 아주 간단하게 지금 하나의 다른 층을 포함한다. 나는 앞과 채찍 갈거야 메인에서 다른 프로그램까지 여기에 단순히-구현을 다시 것을 문자열 길이는 다음과 같이. 그래서 여기에 코드 줄이야 그 나에게 사용자로부터 문자열을 가져옵니다. 우리는 또 다시이 문제를 계속 사용. 나 자신에게라는 변수를 줘 보자 번호를 저장하는 int 형의 n은. 

그리고 내가 가서 보자 다음 로직을한다. 의에서 n 번째 문자는 않지만 같지 백 슬래시 0, 진행 n은 증가. 그리고 printf의 %의 내가 없음을 인쇄 할 수 있습니다. 나는 그 프로그램이 여기에 주장 문자열 길이를 호출하지 않고, 문자열의 길이를 파악. 

그리고 마법은 전적으로 라인 (8)에 캡슐화 여기에 새 구문의 모습과, 따옴표에서이 백 슬래시 0. 그러나 그 이유는 무엇입니까? 음,되어 있는지 고려 이 모든 시간에가는. 

나는 잊어 버리기 전에 그리고로에게 옆으로 실현 도, 그 사람 페이지에 추가 그 전형적인 함께 CS50 IDE와 같은 리눅스 시스템, 실현이 우리의 물론 직원도 있습니다 웹 사이트 버전을 만든 라는이 같은 생각의 이 reference.cs50.net, 그 같은 사람의 모든 페이지, 같은 모든 문서뿐만 아니라 수 있습니다 상단에 작은 상자 당신은 매우 모든 변환 적은 편안한에 비밀 언어 모드, 어디서, 교원, 를 통과하고 단순화하기 위해 노력했다 물건을 유지하는 언어의 일부 아이디어에 초점을 맞추고, 그리고 교칙의 일부. 그래서 명심 reference.cs50.net 뿐만 아니라 다른 자원으로. 

그런데 왜 문자열 길이의 작품을 수행 내가 전에 잠시 시간을 제안한 방법은? 여기 Zamyla의 이름은 다시입니다. 그리고 여기 Zamyla의 이름입니다 나는이 일을 계속 같이에서 박스, 이 인의 사진을 칠하고, 정말, 문자 단지 순서. 그러나 Zamyla가 존재하지 않습니다 프로그램에서 분리한다. 

당신이 작성하고 프로그램을 실행하면, 당신은 당신의 Mac 또는 PC를 사용하는 메모리 또는 RAM으로 말하자면. 그리고 당신은 생각할 수 필요로 컴퓨터 메모리의 기가 바이트 요즘 많이. 그리고 공연은 수십억을 의미 바이트 그래서 수십억. 

그러나의 시간에 되감기 할 수 있습니다. 우리가 사용하고 있다고 가정 정말 오래된 컴퓨터가 전용 메모리의 32 바이트가 있습니다. I 수, 내 컴퓨터 화면에, 다음과 같이 간단하게이를 그립니다. 

나는 단순히 말할 수 내 컴퓨터는이 모든 메모리가 있습니다. 그리고이 경우, 메모리 스틱처럼 당신은 마지막에서 우리의 사진을 기억합니다. 그리고 난 그냥 분할하는 경우 충분한 시간이, 나는 32 바이트를 가지고 있다고 주장 화면에 메모리. 

지금, 현실에서 내가 할 수있는 유일한 여기에이 화면에 지금까지 그립니다. 그래서 앞서 갈거야 그냥 규칙에 의해, 로 내 컴퓨터의 메모리를 그려 그리드, 단지 하나의 직선. 특히, 지금은 그 주장 이 그리드이 8로 4 그리드, 다만 모든 32 바이트를 나타냅니다 내 맥에서 사용 가능한 메모리, 또는 내 PC에서 사용할 수있는. 그리고 그들은 포장하고 에 두 라인, 단지 이를 화면에 더 적합하기 때문이다. 그러나 이것은 첫번째 바이트이다. 이것은 두 번째 바이트이다. 이 제 3 바이트이다. 

그리고 이것은 32 바이트이다. 아니면, 우리는 컴퓨터처럼 생각하는 경우 과학자 이것은 바이트 0, 1, 2, 3, 31이다. 그래서, 만약 31에 0이 당신은 0으로 계산 시작합니다. 

우리가 프로그램을 사용한다면 통화 문자열 얻을, 우리는 인간에서 문자열을 얻을 , 내가 Zamyla라고했던 것처럼 Z-A-M-Y-L-A, 어떻게 세상이 수행에 컴퓨터 킵 추적하는 바이트, 메모리의 어떤 덩어리, 어떤 문자열에 속해? 즉, 우리는에 진행하는 경우 컴퓨터에 다른 이름을 입력 이 앤디처럼 호출 문자열 두 번째 시간을 가져, A-N-D-I는에서 생을 마감합니다 컴퓨터의 메모리뿐만 아니라. 하지만 어떻게? 

글쎄, 그것은 아래에 밝혀 문자열을 저장할 때 후드, 무슨 C 것은 않습니다 인간의 종류, 또는 그 그것이, 다른 소스에서 온 그들의 끝을 묘사 특별한 character-- 백 슬래시 그냥 특별한 방법 0, 행 80 비트 말. 

그래서 할까 ..이 숫자 97 리콜이다. 8 비트 그래서 몇 가지 패턴 진수 97를 나타냅니다. 이 백 슬래시 0 문자 수입니다 0, 일명 NUL, N-U-L, 이전과는 달리, N-U-L-L, 우리가 이야기했다. 하지만 지금은, 그냥이 알고 백 슬래시 0 행의 단지 80 비트이다. 

그리고 그것은 단지이 줄이야 왼쪽에있는 것을 말한다 모래 하나의 문자열, 또는 하나의 데이터 유형에 속한다. 오른쪽에 아무것도 뭔가에 속한다. 앤디의 이름, 한편, 이는 단지 시각적 다른 라인에 포장하는 일, 하지만, 단지 미적 세부 사항입니다 유사 NUL 종료한다. 

그것은는 A-N-D-I 문자의 문자열입니다 플러스 다섯 번째 비밀 문자, 단지 구분한다 모든 0 비트, 뿐만 아니라 앤디의 이름의 끝. 그리고 우리가 호출하는 경우 문자열을 세 번째를 얻을 수 컴퓨터에서 같은 문자열을 얻을 수 마리아, M-A-R-I-A는 유사 마리아의입니다 이름 NUL은 백 슬래시 0으로 종료되었습니다. 

이것은 근본적으로 다르​​다 방법에서 컴퓨터는 일반적으로 것 정수 또는 부동 소수점 또는 다른 저장 아직 데이터 형식, 리콜 때문에, 정수 일반적으로 32 비트 또는 4 바이트, 또는 어쩌면 64 비트, 또는 8 바이트. 그러나 컴퓨터에 많은 프리미티브 프로그래밍 언어 고정 된 수를 가지고 hood-- 아래 바이트 아마 1, 어쩌면 2, 아마 네, 아마 8. 

그러나 문자열, 디자인함으로써,이 문자의 동적 수입니다. 당신은 때까지, 사전에 몰라 Z-A-M-Y-L-A에서 인간 유형 또는 M-A-R-I-A 또는 A-N-I-D. 당신은 몰라 얼마나 많은 시간을 사용자가 칠 것입니다 키보드. 따라서, 당신은 방법을 모른다 사전에 많은 문자 당신이 필요 해요. 

그래서 C는 종류의 같은 잎 후드 아래에 비밀 이동 경로 문자열의 끝에서. 메모리에 Z-​​A-M-Y-L-A를 저장 한 후, 또한 단지 동등한를두고 기간의. 문장의 마지막 그것은 수 있도록 80 비트를 둔다 여기서 기억해야 할 Zamyla이 시작되고 끝납니다. 

그래서 연결은 무엇인가, 다음,이 프로그램에? 여기에이 프로그램, 스털링, 메커니즘은 단순히 문자열을 얻기를위한 사용자로부터, 라인 6. 7 호선, 나는 변수를 선언 N이라고는 0과 동일하게 설정. 

그리고 라인 8, 단순히 물어 질문, n 번째 문자가하는 동안 동일하지 않은 모든 0 bits-- 즉하지 않는다 동일이 특별한 문자, 백 슬래시 0, 어떤 그냥 특별한 NUL character--했다 가서 그냥 N 증가. 

그리고 그 일을 유지하고 유지 그 일을 한 것은 일을 계속. 그래서도에서 비록 우리는 내가 사용했습니다 과거, 완벽하게 괜찮아요 의미 N 사용하는, 당신은 단지하려고하는 경우 의도적으로이 시간을 계산, 그냥 N을 호출 할 수 있습니다. 그래서 그냥 질문을 유지, 모두 0 (S)의 n 번째 문자는 무엇입니까? 그렇지 않은 경우, 다음 모양을 보면, 다음에 보면 다음에 보면, 다음에 봐. 

그러나 바로이 백 슬래시 0을 참조로, 11-- 통해이 loop-- 라인 (9)이 중지됩니다. 당신은, while 루프의 탈옥 그 변수 (n)의 내부 떠나 의 모든 총 개수 당신이 본 문자열의 문자, 따라서 그것을 밖으로 인쇄. 그래서이 시도 할 수 있습니다. 

없이, 내가 가서 보자 스털링 함수를 사용하여, 하지만 내 자신의 자체 개발 버전을 사용 여기 스털링라고, 내가 앞서 가자 뭔가 및 실행 스털링, 유형 내가 미리 알고 Zamyla, 같은 6 자이다. 그것이 작동하는지 보자. 실제로, 여섯이다. 의 롭 함께 해보자, 세 문자, 세 문자뿐만 아니라, 등등. 그래서 무슨 일이 전부입니다 후드 아래에. 그리고 연결을 발견, 다음, 첫 주에 클래스, 우리는 이야기 경우 추상화 같은, 어떤 아이디어가 바로이 레이어는, 또는 복잡성, 기본 원칙의 상단에. 여기, 우리는 일종의 찾고 스털링의 후드 아래, 그래서 알아 내기 위해, 이야기하기, 그것은 어떻게 구현 될 것인가? 

그리고 우리는 그것을 자신을 다시 구현할 수 있습니다. 그러나 우리는 다시는 않을거야 하는 스털링를 다시 구현. 우리는 단지에가는거야 위해 스털링를 사용 실제로 일부 문자열 길이를 얻을 수 있습니다. 

하지만 마법이 없다 후드 아래에. 당신이 알고있는 경우 아래 그 후드, 문자열 문자 단지 순서입니다. 그리고 문자의 순서 모든 수치 해결할 수 있습니다 브래킷 0, 브래킷 1 브래킷 (2), 그리고 문자열의 끝에를 것을 알고 특수 문자, 당신은 알아낼 수 A의 대부분의 작업을 수행하는 방법 프로그램은 모든 있기 때문에 아래로 비등 읽고 메모리를 쓰고있다. 즉, 변경하고 찾고 있습니다 메모리에, 또는 물건을 이동 주위에 메모리에, 인쇄 것들 등 스크린과에. 

그래서 지금이 새로 발견을 사용하자 사실을 문자열 무엇인지에 대한 이해 후드 아래에 있으며, 하나의 다른 층을 다시 껍질 지금까지 우리가했습니다까지 그 모두 무시되었다. 특히, 어떤 시간에 우리는 프로그램을 구현했습니다, 우리는이 코드 줄을 했어 상단 메인 선언. 그리고 우리는 INT의 주요 공백​​을 지정했습니다. 

그리고 괄호 안에 그 보이드 이이 모든 시간을 말한 것을 주 자체 인수를하지 않습니다. 주요임을 모든 입력 사용자로부터 얻을 것 다른에서 온합니다 메커니즘, 같은 GET INT, 또는 플로트를 얻을, 또는 문자열을 얻을, 또는 다른 기능. 그러나 그것은 밝혀 당신은 프로그램을 작성할 때, 실제로 지정할 수 있습니다 이 프로그램하여야한다 인간로부터의 입력을 명령 행 자체에서. 

즉, 비록 우리가 지금까지 안녕하세요 ./hello 단지 운영하고 있습니다 또는 이와 유사한 프로그램의 모든 우리가 사용했던 다른 프로그램 우리 자신이 작성하지 않은 그 이, 그것은 보인다, 복용 명령 줄 arguments-- 메이크업 같은 것들. 당신은 메이크업과 같은 말을, 다음 제 2 워드. 또는 그 소리는, 당신은 그 때 그 소리와 말 제 2 워드, 파일의 이름입니다. 

당신은 수도, 또는 RM 또는 CP 알 나 이미 사용하고 있습니다 제거하거나 파일을 복사합니다. 이들 모두는 소위 취할 명령 줄 arguments-- 터미널 프롬프트에서 추가 단어. 그러나 지금까지, 우리 자신은 없었어요 로부터 입력을 복용이 럭셔리 사용자가 그 또는 그녀가 실제로 실행될 명령 줄에서 프로그램 자체. 

그러나 우리는에 의해 다시 선언하는 것을 할 수있다 메인 것으로, 앞으로하지 이동 괄호 안에 무효, 그러나이 두 개의 인수 첫 번째 정수 instead--, 두 번째 것을 우리가 전화를 겁니다 새로운, 뭔가 배열, 정신 비슷한 우리가 목록으로 스크래치에서 본 것과하지만, 문자열의 배열, 우리는 곧 볼 수있다. 그러나 이제 이것을 보자 예로서, 우리는 이전 그 의미를 정확하게 구분합니다. 

내가 CS50 IDE로 이동한다면 여기에, 나는 앞으로 갔어요 와라는 파일에 선언 다음 템플릿을 argv0.c. 그리고 유일한 통지 즉, 지금까지 다르다 나는 int로 무효 변경 한 것을 는 argc 문자열은 가까운 오픈 브래킷을 argv를 까치발. 그리고 거기에, 지금 주목 그 괄호 안에 아무것도 없습니다. 

어떤 수는 없습니다. 그리고, 더 나는 없다 또는 N, 또는 다른 문자. 난 그냥 사용하고 있습니다 지금은 대괄호, 이유로 우리는 올 것이다 다시 그냥 순간입니다. 

그리고 지금 내가 할거야 것은 이것입니다. 는 argc가 동일한 경우에 해당 2-- 그리고 그 같음과 동일 리콜 비교 항등 연산자이다 평등의 왼쪽과 오른쪽. 그것은 할당 아니다 이다 운영자, 사본을 의미하는 하나의 등호, 오른쪽에서 어떤 값을 왼쪽으로. 

는 argc와 같이 동일한 경우, 내가 원하는 말, printf와, 안녕하세요, 퍼센트, 새로운 라인, 다음 in-- 연결하고 여기에 새로운 기능 이유 trick-- argv를 브래킷 1 우리는 다시에 잠시 들어올거야. 는 argc하지 않는 경우는 다른 2 동일, 그거 알아? 평소, 인쇄로, 그냥 진행하자 아니 대체와 아웃 안녕하세요 세계. 

그래서 보이는 것이라고는 argc,하는 경우 ,, 인수 수를 의미 2와 동일 나는 인쇄 할거야 안녕하세요 뭔가 다른. 그렇지 않으면, 기본적으로 난 안녕하세요 세상을 인쇄하는 것. 그래서 이것은 무엇을 의미합니까? 

글쎄, 내가 가서 저장할 수 있습니다 이 파일 다음 argv0을 수행 다음 ./argv0 입력합니다. 그리고 세계는 안부. 이제, 그 이유는 무엇입니까? 

글쎄, 당신은 언제 밝혀 명령 줄에서 프로그램을 실행, 당신은 우리가 거​​에서 작성된다 일반적으로 인수 벡터를 호출합니다. 자동 즉, 컴퓨터 운영 체제 프로그램에 손을 것입니다 자체 모든 단어의 목록 인간은 입력했는지 경우에 프롬프트, 당신 프로그래머가 수행 할 정보 뭔가. 이 경우, 유일한 단어 내가 프롬프트에서 입력 한 것은 ./argv0입니다. 

그리고 인수의 수입니다 내 프로그램에 전달되는 단지이다. 즉, 인수 다르게는 argc라고도 간주 여기에 정수로, 단지 하나입니다. 하나는 물론 두 동등하지 않는다. 그리고이 안녕하세요, 세상을 인쇄하는 것입니다. 

그러나 내가이 곳을 보자. 저 말 argv0하자. 그리고 어떻게 마리아는 어떻습니까? 그런 다음 Enter 키를 누릅니다. 

그리고 마술 여기에 무슨 알 수 있습니다. 자, 대신 안녕하세요 세계, 나는이 이 프로그램의 동작을 변경 GET에서하지 입력을 취함으로써 문자열이나 다른 기능, 하지만, 분명히, 내 명령 자체, 내가 처음에 입력 한 내용. 그리고 다시이 게임을 재생할 수 있습니다 예를 들어 스텔 리오스로 변경. 

그리고 지금은 또 다른 이름을 참조하십시오. 그리고 여기, 나는 앤디 말할 수 있습니다. 그리고 나는 Zamyla 말할 수 있습니다. 그리고 우리는 하루 종일이 게임을 재생할 수 있습니다 단지 다른 값에 연결, 너무 오래 내가 정확하게 제공으로 프롬프트에서 두 단어, 는 argc, 내 인수가 계산되도록, 2입니다. 

나는 이름에 연결되어 있음을 볼 수 있나요 printf와, 여기에이 조건 당? 그래서 우리는 지금 것 같다 표현 적 기능 다른기구로부터 입력을 복용, 소위 명령 줄에서, 오히려 기다릴 필요보다 사용자가 프로그램을 실행할 때까지 다음 그 또는 그녀의 메시지를 표시 GET 문자열 같은 것을 사용. 

그래서 이것은 무엇입니까? ARGC 다시, 단지 정수이고, 글자 네요 arguments--의 수 그 사용자에 제공 프롬프트 단자 창에서, 프로그램의 이름을 포함. 그래서 우리 ./argv0 효과적으로이며, 프로그램의 이름, 또는 어떻게 프로그램을 실행합니다. 

즉 단어로 계산합니다. 그래서는 argc는 1이 될 것이다. 하지만 스텔 리오스를 작성하거나 앤디, 또는 Zamyla, 또는 마리아, 즉, 인수 개수가 두 의미합니다. 그리고 지금에 전달 된 두 단어가있다. 

그리고 통지, 우리는이 논리를 계속할 수 있습니다. 내가 실제로 말할 경우 Zamyla 찬과 같이, 전체 이름하여 전달 총 세 개의 인수, 지금은 기본을 다시 말한다, 물론, 3이 동일하지 않기 때문에. 

그래서 이런 식으로, 내가해야합니까 변수는 argv이 새로운 인수를 통해 액세스 우리는 기술적으로 수 우리가 원하는 무엇이든을 호출합니다. 그러나 관례, 그건 각각 변수는 argv와는 argc. ARGV, 인수 벡터, 종류 프로그래밍의 동의어의 C의 기능은 배열을했다. 

배열은 비슷한 값의 목록입니다 뒤로, 뒤로, 백업, 백업합니다. 즉, 만약 하나는 바로 여기에있다 RAM, 다음 하나, 그것은 바로 옆에 오른쪽 옆에. 그들은 도처에 아니에요. 그리고 후자의 시나리오, 일 모든 메모리에 여기 저기 있습니다, 실제로 강력한 기능이 될 수 있습니다. 때 그러나 우리는 그에게 돌아올 것이다 애호가 데이터 구조에 대해 이야기. 지금은 배열 단지입니다 연속 메모리의 덩어리, 요소가 각각 다시, 다시, 다시, 다시하고, 일반적으로 동일한 유형. 

그래서 당신은에서 생각해 보면 순간 전, 문자열은 무엇인가? 음, 문자열, Zamyla 등, Z-A-M-Y-L-A는 기술적 인 그냥 배열입니다. 그것은 문자의 배열입니다. 

그래서 우리는 정말이로 그릴 경우 I 메모리의 덩어리로, 이전했다 이들의 각을 밝혀 문자는 바이트를 차지합니다. 그리고 그 특별한있다 센티넬 문자, 백 슬래시 0, 또는 모두 여덟 0 비트, 그 해당 문자열의 끝을 구분한다. 그래서 문자열, 그것은집니다 아웃, 인용을 끝내 문자열을 인용 chara-- 단지 배열입니다 실제 데이터 형식 인을 char. 

이제 변수는 argv, meanwhile-- 의 다시 프로그램에 가자. 우리가 말씀을 참조하더라도 ARGV, 문자열은 여기에, 문자열 자체가 아닙니다. ARGV, 인수 벡터, 문자열의 배열입니다. 

당신의 배열을 가질 수 있도록 단지로 자, 당신은 높은 수준을 가질 수 있습니다, strings--의 배열 때문에, 예를 들면, 나는이 순간을 전 입력 할 때 ./argv0 argv0, 공간 Z-A는-M-Y-L-A, 나는 주장 변수는 argv는, 그건 ... ./argv0에서 두 문자열을했다 및 Z-A-M-Y-L-A. 에서 다른 단어는 argc는 2였다. 그 이유는 무엇입니까? 

음, 효율적으로, 무슨 일이야 에는 이러한 문자열의 각 그 물론, 문자의 배열 이전과 같이, 각각 그 문자 한 바이트까지 소요됩니다. 그리고 실제 공을 혼동하지 마십시오 0과 프로그램의 이름, 이는 모든 80 비트를 의미한다. 그리고 Zamyla 한편, 여전히 또한 문자의 배열. 

하루의 끝에 그래서, 실제로 후드 아래에 다음과 같습니다. 하지만 어떻게 메인의 자연, argv를 작품은, 내가이 모든 것을 포장 할 수 있습니다 , 만약에 당신, 더 큰 배열에 최대 우리가 약간 이상 단순화 경우, 그 사진이 좋아하고 안 모습 아주 거기 확장을 그려, 이 배열은, 단지 크기 2의 첫 번째입니다 문자열이 포함되어있는 요소, 의 두 번째 요소 어떤 문자열이 포함되어 있습니다. 그리고, 차례로, 당신의 경우 종류의 각각 확대 그 문자열의 무엇을 후드 아래에 참조 각 문자열은 그냥이다 문자의 배열. 

자, 그냥 문자열로, 우리는 액세스를 얻을 수 있었다 문자열의 i 번째 문자 그 대괄호 표기법을 사용. 마찬가지로, 배열과 일반적으로, 우리를 수 얻을 대괄호 표기법을 사용 배열의 문자열의 수에? 예를 들어, 저를 보자 가서 이렇게. 

내가 가서 argv1.c을 만들어 보자, 이는 조금 다른이 시간이다. 대신 argc2 검사의, 내가 대신 이렇게하는거야. 내가 공을받을 INT, 나는 작 는 argc보다, 내가 플러스 플러스, 다음,이 내부에 프린트 퍼센트의 새로운 라인, 다음 argv를 브래킷 난. 

즉 그래서, 내가 다루고 있지 않다 순간 개별 문자. ARGV,이 빈 사각형에 의해 묵시적으로 이름 argv를 오른쪽 중괄호, 문자열의 배열입니다 argv를 의​​미한다. 그리고는 argc는 int 형입니다. 

여기이 선, 6이며, 세트 말을 내가 공에 동일. , 최대 모든 방법을 계산 그러나는 argc, 포함하지 않음. 그리고 각각의 반복에, 문자열을 인쇄 할 수 있습니다. 어떤 캐릭터? 

변수는 argv의 i 번째 문자열입니다. 내가되기 전에 반면 그래서 대괄호를 사용하여 표기는 i 번째에 도착 지금은 문자열에서 문자, 나는 광장 브래킷 표기법을 사용하고 있습니다 배열의 i 번째 문자열에서 얻을 수 있습니다. 그래서 하나의 층의 종류입니다 위의 개념. 

그리고 이것에 대해 깔끔한 무엇 지금 프로그램, 내가 argv1 컴파일하는 경우, 다음 ./argv1을 수행 한 다음 입력 foo는 바 바즈 같은에서, 세 가지 기본 단어 a는하는 수 있습니다 컴퓨터 과학자는 시간에 도달 그 또는 그녀가 어떤 자리 워드를 필요 Enter 키를 누르, 그 단어의 각, 프로그램의 이름을 포함하는 상기 제 1 위치에서 argv를 인 끝은 한 번에 하나의 프린트된다. 그리고 나는 이것을 변경하고, 내가 말할 경우 argv1 Zamyla 찬과 같이, 우리는 그 중 세 가지 얻을 argv0입니다 즉, argv1, argv2,이에 있기 때문에 케이스는 argc는 수는 3입니다. 

하지만 깔끔한 것은 당신이 이해하는 경우입니다 그 변수는 argv는 문자열의 단지 배열입니다 당신은 문자열을 이해 문자의 배열이며 우리는 실제로 종류의이 사용할 수 있습니다 대괄호 표기법을 여러 번 문자열을 선택하고 선택합니다 문자열 내에서 문자, 다음과 깊이로 다이빙. 이 예에서, 내가 가자 앞서이 argv2.c를 호출합니다. 그리고이 예에서, 내가 앞서 가자 그리고 난 공을받을 INT의 following--을, 내가,는 argc 미만 내가 플러스 플러스, 직전있다. 그래서 지금이 다른 글자 네요에 충분히 복잡 받고있다. 그리고 내가 말할거야 변수는 argv 문자열을 반복, 자신에 주석으로. 그리고 나는이거야 , 루프 중첩 아마하는 당신을 수행, 또는 고려 스크래치에, 일, 어디 난 난 int-- 말할거야 다시 나는를 사용하지 않을, 나는 그림자 싶지 않기 때문에, 또는 종류의 기존 전을 덮어 씁니다. 

나는 때문에, 대신, J 말할거야 즉, 내가 후 변수에 내 이동의 때 난 단지에 노력하고있어 간단한 숫자를 계산합니다. j는 도착를 들어 0-- 또한​​, N, 것입니다 , argv를 브래킷 난의 선미 길이를 얻을 너무 오래 j는 m 미만으로, J 플러스 플러스, 다음을 수행하십시오. 그리고 여기에 흥미로운 부분입니다. 

문자 및 새로운 라인을 인쇄, argv를 브래킷 난, 브래킷 J를 연결. 좋아, 그럼 내가 여기에 몇 가지 주석을 추가 할 수 있습니다. 문자를 반복 현재 문자열, i 번째 문자열에 인쇄 j 번째 문자. 그래서 지금의 고려하자 이러한 의견은 무엇을 의미. 

문자열을 반복 argv--에 얼마나 많은 문자열 배열하는 것입니다, 변수는 argv에? ARGC 많은, 그래서 반복 해요 에서 내가는 argc까지 0과 동일. 한편, 얼마나 많은 문자 변수는 argv에서 i 번째 문자열에? 

글쎄, 그 대답을 얻기 위해, 난 그냥 문자열 길이를 호출 현재 문자열 I 관리에 변수는 argv 브래킷 내가 어떤 약. 그리고 일시적으로 저장하는거야 값 N에 불과 캐싱 목적, 효율을 기억합니다. 그리고 나는 0으로 J를 초기화거야 j는보다 n은로 너무 오래 계속, 각 반복 증가 J에. 

그리고 여기에서, 당 라인 (12)에 대한 나의 의견, 문자를 인쇄, 새 줄 이어 구체적으로는 argv 브래킷 나는 나에게 i 번째 문자열을 제공합니다 argv-- 그래서 첫 번째 단어는 두 번째 단어, 세 번째 단어, 뭐든간에. 그리고 J의 깊이에서 잠수 및 도착 내가 그 단어의 j 번째 문자. 그래서, 효과에, 당신은 치료할 수 argv와 다차원으로, 이차원 배열로서 이에 외모의 모든 단어의 종류 마음의이 같은 눈 및 모든 문자 가지로 구성되어있다 열, 즉 도움이된다면. 

실제로, 우리는 때를 애타게 미래의 주에서이 떨어져, 조금 될 것 보다 더 정교한. 하지만 당신은 정말 할 수 지금은 그 생각, 바로이 두 가지 차원으로 그것의 배열, 이에 한 수준 모든 스트링이다. 그리고 당신은 더 깊은, 당신이 다이빙하는 경우 개별 문자에서 얻을 수 있습니다 여기에이 표기법을 사용하여 내부. 

그래서 그물 효과는 무엇인가? 내가 가서 보자 argv2-- 이놈에게 그것을 확인합니다. 여기 실수를했다. 암시 적 선언 라이브러리 함수 스털링. 그래서 모든 시간, 그것은이다 아마도 적절한 우리는 일종의 마무리하고 있는지 정확히 우리가 시작했던 곳. 

나는 암시 적으로 선언 망쳐 라이브러리 함수 스털링. OK, 분을 기다립니다. 나는 특히, 그 기억 이후 바로 여기입니다. 나는에 string.h를 포함해야 프로그램의 버전. 

내가 가서 포함하자 string.h, 그 저장 진행 및 argv2 다시 컴파일. 그리고 지금, 우리가 입력 argv2 확인 이동합니다. 그리고 그것은 조금 비록 첫눈에 비밀, 실제로, 그 통지, 무엇을 점 argv2 인쇄입니다. 

하지만 난 후 일부 단어를 입력하면 프롬프트 argv2 Zamyla 찬처럼, 또한, 조금 입력 첫눈에 비밀. 그러나 우리가 다시 이동하면, ./argv2 Z-A-M-Y-L-A C-H-A-N. 그래서 우리는 모든 단어를 통해 반복했습니다. 그리고 다시, 우리는 이상 반복했습니다 단어 내에서 모든 문자. 

자,이 모든 후, 거기 실현 다른 한 세부 우리는 친절했습니다 이 모든 시간을 무시. 우리는 단지 떨어져 조롱 무엇 메인의 입력은 할 수 있습니까? 무엇 주요의 출력은 어떻습니까? 

이 모든 시간, 우리는 봤는데 그냥 복사 및 붙여 넣기 주 앞의 단어 INT, 당신이 온라인으로 볼 수 있지만, 때때로 잘못 이전 버전에서 C와 컴파일러, 그들은 무효라고하는 것이 또는 아무것도 전혀. 그러나, 실제로의 버전 C의 우리가 사용하는 그, C (11), 또는 2011 년 실현 것을 그것은 INT해야합니다. 그리고 그것은이어야한다 무효 또는는 argc와 argv를 여기에. 

그런데 왜 INT 주? 실제로 무엇을 반환? 음,이 시간을 모두 밝혀 언제든지 당신은 프로그램 메인을 작성했습니다 항상 뭔가를 반환. 하지만 이렇게 비밀리에 일을하고 있어요. 

그 무언가가있는 INT는 선으로 5 건의한다. 하지만 INT? 음,이 거기에 프로그래밍 대회, 이에 아무것도가없는 경우 잘못된 사라지고 모두가 잘, 일반적으로 프로그램 및 기능 return-- 다소 counterintuitively-- 0. 0은 일반적으로 모두가 잘 나타냅니다. 당신이 생각 그래서 비록 많은 상황에서 거짓 그것, 실제로 일반적으로 좋은 일을 의미한다 

한편, 프로그램이 1을 반환하는 경우, 또는 음 1, 5, 또는 음 (42) 또는 0이 아닌 값, 즉, 일반적으로 의미 뭔가 잘못왔다. 사실, 자신의 Mac 또는 PC에, 실제로 본 적이 있습니다 에러 메시지가있다 그것을 뭔가 다른, 오류가 말한다 코드 음 (42), 또는 오류 코드 같은 23, 또는 무엇인가. 그 숫자는 일반적으로 그냥 힌트 프로그래머, 또는 회사에 즉, 소프트웨어를 만들어 무엇을, 왜, 왜 갔다 그들은을 통해 검색 할 수 있도록 (듯이) 자신의 문서 또는 코드, 그리고 알아 무엇 오류가 실제로 의미한다. 그것은 일반적으로 아니에요 우리에게 유용한 최종 사용자. 

그러나 주요 반환 0, 모두가 잘 때. 그리고 당신은 지정하지 않는 경우 반환해야합니다 주요 내용, 그냥 자동 것 당신을 위해 0을 반환합니다. 하지만 뭔가를 반환 다른 실제로 유용합니다. 

마지막 프로그램에서 저를 보자 가서이 exit.c 전화, 오늘의 마지막을 소개합니다 오류 코드라고도 주제. 내가 가서 포함하자 우리 익숙한 파일을 백업 정상은, INT 메인을한다. 그리고 이번에는, 이제 INT의는 argc을하자 문자열 변수는 argv, 내 브래킷 이 배열의 것을 의미합니다. 그리고 나를 그냥 정신 검사를 할 수 있습니다. 이번에는 argc하지 않는 경우 2 동일, 당신은 알아? 잊어 버려. 내가 그런 말을 하겠어, 이봐, 사용자, 당신은 명령 줄 인수를 누락 백 슬래시 n은. 

그리고 그게 다입니다. 나는 종료 할 수 있습니다. 나는, 선제에 갈거야 그리고 중간에 정말 반환 숫자 1이 아닌 다른. 첫 번째 가치로 이동 발생할 수있는 오류는 1 개입니다. 당신은 잘못된 다른이있는 경우 발생할 수있는 상황, 당신은 반환이 말 또는 3을 반환하거나, 수 어쩌면 음의 1 또는 음의 2. 

이는 종료 코드입니다 이 있으며, 일반적 단지 프로그래머에게 유용하거나 소프트웨어를 해운 회사입니다. 그러나 사실은이 있다고 0이 아닌 중요합니다 것입니다. 그래서이 프로그램의 경우, 내가 원하는 보장하는이 프로그램 만 사용자가 나에게 제공하는 경우 작동 두 인수 카운트를 갖는, 프로그램의 이름과 다른 단어, 나는 다음과 같이 많이 적용 할 수 있습니다 printf와의 말과 사용자에 소리, 명령 행 인수를 누락, 1을 반환합니다. 그건 그냥 바로 것이다 프로그램을 종료합니다. 

는 argc이 동일 경우에만 2 우리는 아래로 얻을 것이다 여기, 내가 말할거야 어떤 시점에서, 안녕하세요 퍼센트의, 백 슬래시 N, argv1. 즉, 난 변수는 argv 0 후에 않을, 이는 프로그램의 단지 이름입니다. 나는, 쉼표, 안녕하세요 인쇄 할 인간 입력 한 두 번째 단어. 그리고이 경우에에 라인 (13)은, 모두 잘 있습니다. 

저는는 argc 2 것을 알고 논리적으로이 프로그램에서. 내가 가서 0을 반환하겠습니다. 여담으로, 명심 그 이뿐만 아니라 스크래치에 해당됩니다. 

논리적으로, 나는이 작업을 수행 할 수 이러한 라인을 캡슐화 여기 다른 절에서 코드. 그러나 그것은 일종의이다 불필요하게 코드를 들여 쓰기. 그리고 슈퍼를 만들고 싶어 명확한 상관없이 그, 기본적으로, 안녕하세요 일이 인쇄되는 것 사용자가 협력으로 너무 오래. 

그래서 사용하는 것이 매우 일반적입니다 조건, 단지의 경우, 몇 가지 오류를 잡으려고 상황을 한 다음 종료합니다. 그리고, 너무 오래 전부입니다 물론, 그렇지 않은 경우가없는, 하지만 단지 코드가 그 밖에,이 때문에 경우 이 동등한 특별한 경우, 논리적으로. 그래서 난 그냥에 0을 반환하고 있습니다 명시 적으로 모든 잘 의미. 

내가 반환 0을 생략 할 경우, 그것은 것 자동으로 나를 위해 가정한다. 하지만 지금은 돌아 오는거야 있음 적어도이 경우 한 내가 좋은 측정을 위해,에 갈거야 및 선명도,이 경우에는 0을 반환한다. 그래서 지금 내가 가서 출구를 만들어 보자, 이는 바로 떠날 수있는 완벽한 SEGUE이다. 

그러나 출구를 확인하고 나를 가자 앞서 및 ./exit을 입력합니다. 그리고 프로그램은 나에게 소리 쳤다 명령 행 인수가 없습니다. OK, 내가 협력 할 수 있습니다. 

나를 대신 ./exit을하자, 다윗은, 입력합니다. 그리고 지금은 안녕하세요 데이비드 말했다. 그리고 당신은 일반적으로이 표시되지 것입니다. 

그러나 그것은이 있다고 밝혀 실제로 볼 수있는 리눅스의 특별한 방법 무엇 종료 코드로 프로그램이 종료. 때때로 그래픽에 맥 OS 또는 Windows와 같은 세계, 당신은이 숫자 참조 에러 메시지가 화면에 팝업 프로그래머 당신에게 그 번호를 보여줍니다. 그러나 우리는 어떤 오류가보고 싶다면 메시지는 우리가 그것을 here-- 할 수있다 그래서 ./exit, 입력, 인쇄 명령 행 인수가 없습니다. 

지금 에코 $을?한다면 어느입니다 보고 엄청나게 비밀. 하지만 $? 마법의 주문입니다 즉, 말한다 헤이, 컴퓨터, 말해 무엇 이전을 프로그램의 종료 코드이었다. 그리고 Enter를 누르십시오. 그 때문에 나는 1 참조 내가 반환 내 주요 기능을 말했다. 

한편, 내가 다윗을 ./exit 할 경우, 나는, 안녕하세요 데이비드을 참조 Enter 키를 누릅니다. 지금 에코 $을한다면? 나는 0 안녕하세요 참조하십시오. 그리고 이것은 실제로 것 유용한 정보가 될 디버거의 맥락, 그리에 당신이 인간이, 신경 것이라고 많은. 그러나 디버거 및 기타 프로그램은 우리가 이번 학기를 사용합니다 종종 그 번호 볼 것이다, 그것은 일종의 숨어 비록 당신은에 그것을보고하지 않는 결정 프로그램의 여부 실행은 올바른 또는 잘못된이었다. 

그리고 그것은 우리에게 가져다 이, 하루의 끝에서. 우리는보고 오늘 시작 디버깅 및 과정에 차례로 자체 한 다음 더 흥미롭게도, 기술적으로 후드 아래에 무엇 문자열이 지속되는입니다 당연한 주에 우리는 그냥했다 확실히 그들을했다 대한 스크래치 부여. 

우리는 우리가 액세스 할 수있는 방법을 보았다 문자열에서 개별 문자, 다시 높은 수준했다 저기 ... 어떻게보고, 사물을 보면 우리는 개인에 얻으려면 구조와 같은 목록의 요소, 우리는 여러 문자열을 할 수없는 이유는 무엇입니까? 그리고 우리는 명령 행 인수 할 수 있습니다. 그러나 여기 그냥 상자의이 사진 이 일반적인 개념의 실증이다 배열 또는리스트 또는 벡터. 그리고에 따라 문맥,이 모든 단어 약간 다른 것을 의미한다. 그래서 C에서, 우리는거야 배열에 대해 이야기합니다. 그리고 배열 ​​덩어리입니다 메모리, 누구의 각각의 요소는, 뒷, 인접 뒤로, 백업, 백업합니다. 

이들 요소는, 일반적으로, 아르 동일한 데이터 타입, 캐릭터 문자, 캐릭터, 캐릭터, 또는 문자열, 문자열, 문자열, 문자열, 또는 INT, 그것이 무엇이든 INT, INT, 우리는 가게에 노력하고 있습니다. 그러나 결국이있다 무엇 개념적처럼 보인다. 당신이 가지고있는 당신의 컴퓨터의 메모리 또는 RAM. 그리고 당신은에 그것을 밖으로 조각하고 동일 크기의 상자, 모두의 에, 다시, 돌아 다시,이 방법으로 백업합​​니다. 

그리고에 대한 좋은거야 이 아이디어와 사실 우리는 이러한 방식으로 값을 표현할 수 있다는 우리의 데이타 구조와 제 클래스에서, 우리는 시작할 수 있습니다 의미 코드 문제를 해결할 그 주 0 그렇게 직관적했다. 당신은 전화를 기억합니다 책 예제​​, 어디 우리는 나누기를 사용 정복 또는 이진 검색 알고리즘 전체를 통해 선별하는 이름과 전화 번호의 무리. 그러나 우리는 리콜을 가정하는 그 전화 번호부는 이미 분류 된 다른 사람이 이미 있다고 해서 돌출 이름의 목록을 제공 한 체격 그들을 알파벳순하는 방법을 numbers--. 그리고 지금 C에서 우리는, 도 능력을 가지고 , 일을하지 배치하기 물리적으로 전화 번호부에 그러나 사실상 컴퓨터에서 메모리는 우리가 할 다음 주에있을 것입니다 처음이 항아리 다시 소개 array-- 우리의 데이터 구조 하지만 더 중요한 것은, 실제 컴퓨터 과학 알고리즘 구현 코드에서있는 우리는 저장할 수 있습니다 이 같은 구조의 데이터, 다음을 조작하기 시작하고, 실제로 문제를 해결하기 위해, 그 위에 구축, 궁극적으로, C에서 프로그램, 파이썬, 자바 스크립트, SQL과 데이터베이스를 쿼리? 

그리고 우리는 이러한 모든 것을 볼 수 있습니다 연동 다른 생각. 하지만 지금은 리콜 우리가 오늘 소개 도메인 이 물건은 여기이고, 암호의 세계. 그리고 다음 문제 당신 자신을 중 해결 암호화의 예술입니다 것입니다, 스크램블 및 디 스크램블 정보 및 암호화 텍스트를 해독, 궁극적으로 가정 당신은 지금 알고있는 것을 후드 아래에있다 그래서 당신은 참조하거나받을 때 이 같은 메시지를 자신은 그것을 해독 할 수 있습니다. 이 모든, 그리고 더 많은 다음 번에. 

[VIDEO 재생] 

-Mover는 도착했다. 나는 방문을 갈거야 그의 대학 교수. 네. 안녕. 그것은 당신입니다. 기다림! 데이비드. 난 그냥 내려고 노력하고있어 당신에게 무슨 일이 일어 났는지. , 아무것도 도움이 될하시기 바랍니다. 당신은 자신의 대학이었다 룸메이트, 당신은하지 않았다? 당신은 그 때 함께 있었다 그는 CS50 프로젝트를 완료? 

[음악 재생] 

- 그건 CS50했다. 

나는이 장소를 좋아합니다. 

최대 -Eat. 우리는 사업을 것입니다. 

[END 재생] 