1
00:00:00,000 --> 00:00:02,970
>> [음악 재생]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> 데이비드 J. 마란 : 좋습니다.

4
00:00:15,700 --> 00:00:18,832
이 CS50이있다
주 (2)의 시작이다.

5
00:00:18,832 --> 00:00:21,040
그리고 당신은 그 이상 기억합니다
지난 몇 주,

6
00:00:21,040 --> 00:00:24,490
우리는 컴퓨터를 도입했습니다
과학, 차례로, 프로그래밍.

7
00:00:24,490 --> 00:00:27,640
>> 그리고 우리는의 방법으로 이야기를 시작
스크래치, 그 그래픽 언어

8
00:00:27,640 --> 00:00:28,990
MIT의 미디어 랩에서.

9
00:00:28,990 --> 00:00:30,780
그리고 가장 최근에,
지난 주, 우리했다

10
00:00:30,780 --> 00:00:34,450
higher-- a를 소개합니다
낮은 레벨의 언어 공지

11
00:00:34,450 --> 00:00:36,770
C, 순수하게 텍스트 뭔가있다.

12
00:00:36,770 --> 00:00:39,440
그리고, 참으로, 지난 시간 우리
그 맥락에서 탐구

13
00:00:39,440 --> 00:00:40,450
개념의 수입니다.

14
00:00:40,450 --> 00:00:43,010
>> 이, 리콜은 매우이었다
첫 번째 프로그램 우리는 보았다.

15
00:00:43,010 --> 00:00:45,710
그리고이 프로그램을 아주 간단하게,
"안녕하세요, 세상을."출력한다

16
00:00:45,710 --> 00:00:47,730
그러나 너무 많이있다
보이는 마법에 가고.

17
00:00:47,730 --> 00:00:51,460
이 사용법 #include가있다
이러한 꺾쇠 괄호와 함께.

18
00:00:51,460 --> 00:00:52,170
INT가있다.

19
00:00:52,170 --> 00:00:53,020
(무효)가있다.

20
00:00:53,020 --> 00:00:56,330
괄호, 중괄호가있다,
세미콜론, 그리고 훨씬 더.

21
00:00:56,330 --> 00:00:58,480
>> 그리고, 리콜
우리는 스크래치를 도입

22
00:00:58,480 --> 00:01:02,110
우리는 이상적으로, 과거를 볼 수 있도록
그 구문, 정말 아니에요 물건

23
00:01:02,110 --> 00:01:04,590
모든 지적
흥미로운하지만 초기에

24
00:01:04,590 --> 00:01:07,700
절대적으로, 조금 까다 롭습니다
당신의 마음을 주위에 포장합니다.

25
00:01:07,700 --> 00:01:10,860
그리고, 실제로 가장 일반적인 한
초기에 프로그래밍 클래스의 것,

26
00:01:10,860 --> 00:01:13,443
특히 적은을위한
편안 의해 좌절하는 것입니다

27
00:01:13,443 --> 00:01:17,460
특정 구문에 의해 트립
오류, 논리적 오류를 언급하지 않기 위하여.

28
00:01:17,460 --> 00:01:19,800
그리고 우리의 목표 중
오늘, 실제로 것

29
00:01:19,800 --> 00:01:23,280
일부를 장비하는
방법에 대한 문제 해결 기술

30
00:01:23,280 --> 00:01:26,705
더 문제 자체를 해결하기 위해
디버깅의 형태 일 수있다.

31
00:01:26,705 --> 00:01:29,330
그리고 당신은, 너무, 기억하는거야
우리가 도입 환경

32
00:01:29,330 --> 00:01:31,780
마지막으로는 CS50 IDE 불렀다.

33
00:01:31,780 --> 00:01:34,850
이 웹 기반 소프트웨어 인 것을
클라우드로 프로그래밍 할 수 있습니다,

34
00:01:34,850 --> 00:01:38,450
모두 유지하면서 그렇게 말을하는 방법
우리가 오늘 다시 것, 파일 등.

35
00:01:38,450 --> 00:01:41,480
그리고 우리를 기억
여기에이 주제를 재 방문,

36
00:01:41,480 --> 00:01:44,480
그 (것)들의 사이에서 함수, 루프,
변수 및 부울 식,

37
00:01:44,480 --> 00:01:45,110
조건.

38
00:01:45,110 --> 00:01:49,190
그리고 실제로 몇
스크래치의 세계에서 번역

39
00:01:49,190 --> 00:01:50,800
C.의 세계

40
00:01:50,800 --> 00:01:53,220
>> 그러나 기본적인 빌딩
블록은, 그래서, 말하자면

41
00:01:53,220 --> 00:01:55,150
정말 여전히 같은 지난 주에 있었다.

42
00:01:55,150 --> 00:01:57,900
사실, 우리가 정말 있었던
다른 퍼즐 조각, 당신이됩니다.

43
00:01:57,900 --> 00:02:00,300
그 대신 보라색의
블록을 저장, 우리 대신

44
00:02:00,300 --> 00:02:02,940
인는 printf했다
C에서이 기능이

45
00:02:02,940 --> 00:02:05,890
당신이 뭔가를 인쇄 할 수 있습니다
화면에 포맷.

46
00:02:05,890 --> 00:02:07,950
우리는 CS50 소개
도서관, 어디를

47
00:02:07,950 --> 00:02:11,420
귀하의 처분에 get_char에 지금있다,
및 GET_INT 및에서는 get_string,

48
00:02:11,420 --> 00:02:14,610
그리고 몇 가지 다른 기능으로
물론, 어떤을 통해 당신은 입력을받을 수 있습니다

49
00:02:14,610 --> 00:02:16,260
사용자 고유의 키보드.

50
00:02:16,260 --> 00:02:20,640
그리고 우리는 또한 가지를 살펴했다
these- 부울 및 문자 등,

51
00:02:20,640 --> 00:02:22,490
두 번, 플로트,
INT, long_long 문자열입니다.

52
00:02:22,490 --> 00:02:25,170
그리고 C. 심지어 다른 데이터 유형을 거기에

53
00:02:25,170 --> 00:02:28,560
>> 당신이 선언 즉,
변수는 어떤 값을 저장하고,

54
00:02:28,560 --> 00:02:32,600
또는 당신은 기능을 구현할 때
그 어떤 값을 반환

55
00:02:32,600 --> 00:02:35,290
당신은 무엇을 지정할 수 있습니다
인 값의 유형입니다.

56
00:02:35,290 --> 00:02:37,310
이 문자열은 같은가요
문자의 순서?

57
00:02:37,310 --> 00:02:39,490
그것은 정수처럼 수 있습니까?

58
00:02:39,490 --> 00:02:41,390
그것은 부동 소수점입니다
값 등?

59
00:02:41,390 --> 00:02:46,180
그래서 C에서, 스크래치는 달리, 우리는 실제로
데이터의 종류를 지정하기 시작했다

60
00:02:46,180 --> 00:02:48,330
우리는 반환 또는 사용 하였다.

61
00:02:48,330 --> 00:02:51,910
>> 하지만, 물론, 우리는 만났다
컴퓨팅의 근본적인 한계.

62
00:02:51,910 --> 00:02:54,100
특히,
이 언어 C, 리콜

63
00:02:54,100 --> 00:02:57,070
우리는 한 번 봐 걸렸다
정수 오버 플로우, 현실

64
00:02:57,070 --> 00:03:00,460
당신은 단지이있는 경우 그
메모리의 유한 한 양

65
00:03:00,460 --> 00:03:04,600
또는, 특히, 제한된 개수
비트, 당신은 너무 높은 셀 수 있습니다.

66
00:03:04,600 --> 00:03:08,460
그래서 우리는 여기 예를 보았다
이에 비행기에서 카운터,

67
00:03:08,460 --> 00:03:13,510
실제로, 충분히 경우를 것입니다 실행
오버 플로우 및 소프트웨어 결과

68
00:03:13,510 --> 00:03:15,560
실제 물리적 잠재적 인 오류가 발생했습니다.

69
00:03:15,560 --> 00:03:18,600
>> 우리는 또한 떠 보았다
포인트 부정확, 현실

70
00:03:18,600 --> 00:03:22,280
만 유한 한 개수
비트, 그것은 32 또는 64인지,

71
00:03:22,280 --> 00:03:27,330
당신은 너무 많은 숫자를 지정할 수 있습니다
소수점 후 어느 한 후

72
00:03:27,330 --> 00:03:29,110
부정확 얻을 시작합니다.

73
00:03:29,110 --> 00:03:32,360
예를 들어, 1/3 그래서
여기에 세계, 우리 인간 세계에서,

74
00:03:32,360 --> 00:03:35,360
우리는 무한한 알고
소수점 -3의.

75
00:03:35,360 --> 00:03:38,820
그러나 컴퓨터가 필요 없습니다
숫자의 무한한 수를 나타냅니다

76
00:03:38,820 --> 00:03:42,590
만 허용하는 경우 그 일부
정보의 유한 한 양.

77
00:03:42,590 --> 00:03:45,900
>> 그래서뿐만 아니라 우리는 당신을 장비 않았다
측면에서 더 큰 힘을 가진

78
00:03:45,900 --> 00:03:49,280
의 당신은 자신을 표현하는 방법
프로그래밍의 관점에서 키보드

79
00:03:49,280 --> 00:03:51,430
우리는 또한 제한 내용
당신은 실제로 할 수 있습니다.

80
00:03:51,430 --> 00:03:55,790
그리고 실제로, 버그와 실수는 할 수
문제의 그 종류에서 발생한다.

81
00:03:55,790 --> 00:03:59,900
그리고 실제로, 항목 중 오늘
디버깅 같은 주제로 가고있다

82
00:03:59,900 --> 00:04:03,699
실제로 후드 아래에보고
물건이 소개 된 방법을 지난 주에

83
00:04:03,699 --> 00:04:05,490
실제로 구현
당신이 더 잘되도록

84
00:04:05,490 --> 00:04:10,530
이해 양쪽의 기능 및
C.와 같은 언어의 제한

85
00:04:10,530 --> 00:04:14,770
>> 사실, 우리는 계층을 벗겨 것
데이터 구조의 단순한의

86
00:04:14,770 --> 00:04:17,756
배열이라는 것을, 어떤
스크래치는 호출하는 일 "목록을."

87
00:04:17,756 --> 00:04:19,589
그것은 약간의
그 상황에서 다른.

88
00:04:19,589 --> 00:04:23,340
그리고 우리는 또한 중 하나를 소개합니다
우리의 도메인 관련 문제의 첫 번째

89
00:04:23,340 --> 00:04:26,790
CS50에서의 세계
암호화, 스크램블링 기술 분야

90
00:04:26,790 --> 00:04:29,650
또는 그렇게 정보를 암호 처리
당신은 비밀 메시지를 보낼 수 있음

91
00:04:29,650 --> 00:04:34,520
비밀 메시지를 디코딩
두 사람 A와 B 사이

92
00:04:34,520 --> 00:04:37,490
>> 그래서 우리는 전환 전
그 새로운 세계에,

93
00:04:37,490 --> 00:04:42,059
의 일부에 당신을 갖추기 위해 노력하자
기술이있는 당신은 제거 할 수 있습니다

94
00:04:42,059 --> 00:04:43,850
적어도 일부를 감소
좌절감의

95
00:04:43,850 --> 00:04:46,630
당신은 아마 발생했는지
혼자 지난 주에 걸쳐.

96
00:04:46,630 --> 00:04:50,830
사실, 앞서의 일부를 such--된다
C. 그리고 확률의 첫 번째 문제입니다

97
00:04:50,830 --> 00:04:54,010
당신이 나 같은 경우, 처음
당신은 프로그램을 입력하려고,

98
00:04:54,010 --> 00:04:57,330
당신은 논리적으로 생각하는 경우에도
프로그램은 매우 간단하다

99
00:04:57,330 --> 00:05:01,200
당신은 매우 잘 벽에 충돌하고 있습니다
컴파일러는 협조하지 않을.

100
00:05:01,200 --> 00:05:03,940
확인 또는 연타는 않을 것이다
실제로 입찰을 할 수 있습니다.

101
00:05:03,940 --> 00:05:05,450
>> 그리고 그 이유가 될 수 있을까요?

102
00:05:05,450 --> 00:05:07,950
음, 그럼 살펴 보자
아마도 간단한 프로그램.

103
00:05:07,950 --> 00:05:11,190
내가 가서이 저장거야
의도적으로 buggy0.c라는 파일,

104
00:05:11,190 --> 00:05:13,590
나는 그것을 알고 있기 때문에
사전에 결함이 될 수있다.

105
00:05:13,590 --> 00:05:17,400
하지만 그 경우이 실현되지 않을 수도 있습니다
제 1, 제 2 또는 제 3 프로그램은

106
00:05:17,400 --> 00:05:18,830
있다는 사실은 자신을 만들고있어.

107
00:05:18,830 --> 00:05:23,820
그래서 앞서 갈거야 및
, INT 주 (무효)를 밖으로 입력합니다.

108
00:05:23,820 --> 00:05:28,130
그리고 내 중괄호의 내부,
안녕하세요,을 전 세계 ( "매우 잘 알고

109
00:05:28,130 --> 00:05:30,980
백 슬래시, N ") - 그리고 세미콜론.

110
00:05:30,980 --> 00:05:32,360
>> 나는 파일을 저장했습니다.

111
00:05:32,360 --> 00:05:34,850
지금은 내려 갈거야
내 터미널 창에

112
00:05:34,850 --> 00:05:40,340
입력을 확인합니다 buggy0 때문에, 다시,
파일명 오늘날 buggy0.c이다.

113
00:05:40,340 --> 00:05:43,660
그래서 입력 buggy0을 입력합니다.

114
00:05:43,660 --> 00:05:48,200
>> 그리고, 오, 이런, 마지막에서 리콜
오류 메시지 것이 좋은 일이다.

115
00:05:48,200 --> 00:05:49,740
그래서 출력이 좋은 일입니다.

116
00:05:49,740 --> 00:05:52,920
그러나 여기에서 나는 분명히해야
실수의 일부 번호.

117
00:05:52,920 --> 00:05:56,470
>> 출력의 첫 번째 줄 그래서
buggy0을 입력 한 후, 리콜,

118
00:05:56,470 --> 00:05:59,540
연타의 매우 자세한 출력이다.

119
00:05:59,540 --> 00:06:02,067
후드 아래,
CS50의 IDE가 구성되어

120
00:06:02,067 --> 00:06:04,150
의 모두를 사용하는
이 컴파일러 옵션

121
00:06:04,150 --> 00:06:05,941
그래서, 당신은하지 않는 것이
그들에 대해 생각합니다.

122
00:06:05,941 --> 00:06:08,840
그리고 그 모든 것을 첫 번째 줄이야
연타로 시작을 의미합니다.

123
00:06:08,840 --> 00:06:11,720
>> 그러나 그 후, 문제
자신의 모습을 시작합니다.

124
00:06:11,720 --> 00:06:17,390
라인 3 자에 Buggy0.c
5, 큰, 빨간색 오류가 있습니다.

125
00:06:17,390 --> 00:06:18,380
그 무엇입니까?

126
00:06:18,380 --> 00:06:23,562
암시 라이브러리 함수를 선언
int 형 (const를 숯불 *로는 printf,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
나는 매우 빨리, 그것을 의미
매우 모호한 가져옵니다.

129
00:06:28,379 --> 00:06:30,170
그리고 확실히, 처음
눈에, 우리는 않을 것

130
00:06:30,170 --> 00:06:32,380
당신은 이해 것으로 예상
해당 메시지의 전체.

131
00:06:32,380 --> 00:06:34,213
교훈 그래서 하나
오늘가는에 대한

132
00:06:34,213 --> 00:06:36,919
통지하려고 할 수 있습니다
패턴 또는 이와 유사한 것들

133
00:06:36,919 --> 00:06:38,960
오류가있을 수 있습니다
과거에 발생했습니다.

134
00:06:38,960 --> 00:06:41,335
그래서 단지 떨어져 애타게하자
익숙 그 단어.

135
00:06:41,335 --> 00:06:44,290
큰, 빨간색 오류는 분명히
무언가의 상징이 잘못되고.

136
00:06:44,290 --> 00:06:47,940
>> 암시 적 선언
라이브러리 함수의 printf.

137
00:06:47,940 --> 00:06:51,680
그래서 나는 아주 이해하지 못하는 경우에도 무엇
암시 적으로 라이브러리 함수를 선언

138
00:06:51,680 --> 00:06:54,900
수단, 확실히 문제
어떻게 든는 printf에 관한 것이다.

139
00:06:54,900 --> 00:06:59,130
그리고 그 문제의 원인
그것을 선언과 관련이있다.

140
00:06:59,130 --> 00:07:02,440
>> 함수가 선언
처음으로 언급.

141
00:07:02,440 --> 00:07:06,210
그리고 우리는 지난 주 용어를 사용
함수의 프로토 타입을 선언,

142
00:07:06,210 --> 00:07:11,860
하나의 상단에 하나의 라인과의
자신의 파일이나 소위 헤더 파일입니다.

143
00:07:11,860 --> 00:07:15,300
그리고 무엇에 파일은 우리가 말을했다
지난 주 printf의가 견적입니다,

144
00:07:15,300 --> 00:07:17,080
인용을 끝내 선언?

145
00:07:17,080 --> 00:07:20,950
어떤 파일에서 프로토 타입은?

146
00:07:20,950 --> 00:07:24,640
>> 그래서 만약 당신이 매우 먼저 I 리콜
입력 된 거의 모든 프로그램 마지막으로 ..

147
00:07:24,640 --> 00:07:30,790
실수로 잠시 전 시작
myself--를 입력하면이 일 here--했다

148
00:07:30,790 --> 00:07:38,630
hash-- 사용법 #include <stio--에 대한
입력 / output-- 도트 시간 그리고 실제로,

149
00:07:38,630 --> 00:07:41,860
지금이 파일을 저장하면, 내가 갈거야
가서 내 화면을 취소하고,

150
00:07:41,860 --> 00:07:44,740
당신은 입력 할 수있는
클리어하거나, 제어 L를 보유 할 수 있습니다

151
00:07:44,740 --> 00:07:47,680
당신의 터미널 창을 취소합니다
단지 약간의 혼란을 제거합니다.

152
00:07:47,680 --> 00:07:51,370
>> 내가 가서거야 및
다시 입력 메이크업의 buggy0 입력합니다.

153
00:07:51,370 --> 00:07:53,790
그리고 짜잔, 난 여전히 볼
연타에서 긴 명령,

154
00:07:53,790 --> 00:07:55,470
하지만 오류 메시지가이 시간이 없습니다.

155
00:07:55,470 --> 00:07:58,800
그리고 사실, 내가 ./buggy0을 할 경우,
단지 지난 번처럼,

156
00:07:58,800 --> 00:08:01,860
여기서 점은이 의미
디렉토리는 슬래시는 의미

157
00:08:01,860 --> 00:08:05,040
여기에 프로그램의 이름이 온다
프로그램의 이름은 buggy0입니다

158
00:08:05,040 --> 00:08:07,340
"안녕하세요, 세상을."입력

159
00:08:07,340 --> 00:08:09,440
>> 지금, 당신은 어떻게해야 할 수도 있습니다
이 솔루션을 수집

160
00:08:09,440 --> 00:08:12,017
없이 반드시
많은 단어를 인식

161
00:08:12,017 --> 00:08:14,350
내가 그랬던 것처럼, 확실히 갖는
이 때문에 몇 년 동안 수행?

162
00:08:14,350 --> 00:08:18,720
음, 첫 번째 문제에 따라 실현
세트, 우리는이 명령에 소개

163
00:08:18,720 --> 00:08:21,175
CS50 자신의 직원이
라는 help50을 썼다.

164
00:08:21,175 --> 00:08:24,300
그리고 실제로, C는 대한 사양을한다
이 문제는 사용하는 방법에 관하여 설정한다.

165
00:08:24,300 --> 00:08:27,210
>> 그러나 본질적으로 help50입니다
프로그램 CS50의 직원

166
00:08:27,210 --> 00:08:30,850
그 허용 쓴 당신은 실행
명령하거나, 프로그램을 실행

167
00:08:30,850 --> 00:08:36,169
당신이 이해하지 않는 경우에 그
출력은, help50에 출력을 전달하는

168
00:08:36,169 --> 00:08:38,890
있는 소프트웨어를 가리
과정의 직원이 쓴

169
00:08:38,890 --> 00:08:42,429
프로그램의 출력을 볼 것이다
라인으로 라인, 문자로 문자.

170
00:08:42,429 --> 00:08:46,000
그리고 우리 경우, 직원은 인식
발생한 오류 메시지,

171
00:08:46,000 --> 00:08:50,580
우리는 몇 가지 당신을 자극하려고합니다
몇 가지 조언과 수사 학적 질문,

172
00:08:50,580 --> 00:08:54,890
TF 또는 CA 또는 자신과 같은 많은
근무 시간에 직접 할 것.

173
00:08:54,890 --> 00:08:58,320
>> 그렇게하지 ​​않으면 그래서 help50에보고
반드시 문제를 인식하고 있습니다.

174
00:08:58,320 --> 00:09:00,790
그러나에 의존하지 않는
버팀목으로 너무 많이.

175
00:09:00,790 --> 00:09:03,990
확실히 이해하려고 노력의
출력 후 배우

176
00:09:03,990 --> 00:09:07,571
그래서 한 번 또는 두 번 당신을 수행하는 것이
어느 특정 오류에 대한 help50 실행

177
00:09:07,571 --> 00:09:08,070
메시지.

178
00:09:08,070 --> 00:09:10,660
그 후, 당신은해야한다
더 나은 자신을 장착

179
00:09:10,660 --> 00:09:13,180
실제로 무엇인지 알아낼 수 있습니다.

180
00:09:13,180 --> 00:09:14,350
>> 의 여기에 다른 하나를 수행 할 수 있습니다.

181
00:09:14,350 --> 00:09:20,410
내가 다른 앞서 가서 보자
파일을 우리는이 buggy1.c를 호출 할 수 있습니다.

182
00:09:20,410 --> 00:09:23,110
그리고이 파일에 난
deliberately-- 것

183
00:09:23,110 --> 00:09:26,330
하지만 그렇게하지 ​​척
내가 만든 한 내용을 잘못 이해하고 있습니다.

184
00:09:26,330 --> 00:09:31,420
>> 내가 가서이 항아리 할거야
사용법 #include, 나는했습니다 이후

185
00:09:31,420 --> 00:09:33,660
잠시 전에서 내 교훈을 배웠습니다.

186
00:09:33,660 --> 00:09:36,220
INT 주 (무효), 이전.

187
00:09:36,220 --> 00:09:40,880
그리고 여기에서 나는거야
문자열의 할 일 -에서는 get_string합니다.

188
00:09:40,880 --> 00:09:43,770
그리고 마지막에서 기억이
이 수단, 헤이, 컴퓨터,

189
00:09:43,770 --> 00:09:48,280
나에게 변수를 줄 것이에요 호출하고
그 변수 문자열의 유형을

190
00:09:48,280 --> 00:09:50,150
그래서 나는 거기에 하나 이상의 단어를 저장할 수 있습니다.

191
00:09:50,150 --> 00:09:52,191
>> 그리고 오른쪽에
등호의 측면

192
00:09:52,191 --> 00:09:54,980
을 인에서는 get_string된다
CS50 라이브러리 함수

193
00:09:54,980 --> 00:09:55,980
그게 정확히 않습니다.

194
00:09:55,980 --> 00:09:59,740
그런 다음 기능을 가져
오른쪽 손이 왼쪽으로.

195
00:09:59,740 --> 00:10:02,670
그래서이 등호는 뜻은 아닙니다
우리가 수학 생각으로 "동일".

196
00:10:02,670 --> 00:10:04,750
그것은 오른쪽에서 왼쪽으로 할당을 의미한다.

197
00:10:04,750 --> 00:10:09,640
그래서 이것은로부터 문자열을 의미
사용자는 (S)의 내부에 보관하고.

198
00:10:09,640 --> 00:10:10,460
>> 이제 사용할 수 있습니다.

199
00:10:10,460 --> 00:10:13,820
내가 두 번째로 현재와 앞으로 가자
라인, 내가 가서 "안녕하세요"라고하자 -

200
00:10:13,820 --> 00:10:19,330
하지 "세계"하지만 "안녕하세요, % s--
이는 우리의 자리, 쉼표들입니다,

201
00:10:19,330 --> 00:10:22,030
이는 우리의 변수가,
다음 세미​​콜론.

202
00:10:22,030 --> 00:10:26,070
그래서 너무 엉망하지 않은 경우
여기에, 이것은 올바른 코드처럼 보인다.

203
00:10:26,070 --> 00:10:28,090
>> 그리고 내 본능은 지금 컴파일한다.

204
00:10:28,090 --> 00:10:30,400
이 파일은 buggy1.c이라고합니다.

205
00:10:30,400 --> 00:10:33,770
그래서 입력 buggy1을 할거야.

206
00:10:33,770 --> 00:10:36,377
그리고 터무니 - 그것, 존재하지 않는 경우
이전보다 더 많은 오류.

207
00:10:36,377 --> 00:10:38,210
나는 더있어, 의미
오류 메시지는 것

208
00:10:38,210 --> 00:10:40,400
이 프로그램의 실제 라인보다 같다.

209
00:10:40,400 --> 00:10:42,730
>> 그러나 테이크 아웃은 여기입니다
당신은 압도 경우에도

210
00:10:42,730 --> 00:10:45,040
두 개 또는 세와
네 이상의 오류 메시지,

211
00:10:45,040 --> 00:10:48,340
아주 항상 초점
해당 메시지의 첫 번째.

212
00:10:48,340 --> 00:10:52,220
최상위 하나를 보면,
수 백업으로 필요 스크롤.

213
00:10:52,220 --> 00:10:53,930
그래서 여기에 나는 메이크업의 buggy1를 입력했습니다.

214
00:10:53,930 --> 00:10:55,700
여기에 예상대로 연타 출력입니다.

215
00:10:55,700 --> 00:10:57,290
>> 그리고 여기에 첫 번째 빨간색 오류입니다.

216
00:10:57,290 --> 00:11:02,370
선언되지 않은 식별자의 사용
문자열, 나는 표준을 의미 했습니까?

217
00:11:02,370 --> 00:11:04,260
그래서 표준입니다
실제로 뭔가.

218
00:11:04,260 --> 00:11:06,240
이것은 사용자를 의미
키보드, 기본적으로.

219
00:11:06,240 --> 00:11:08,080
>> 하지만 그게 무슨 의미가 아니다.

220
00:11:08,080 --> 00:11:11,770
나는 문자열을 의미, 나는에서는 get_string을 의미했다.

221
00:11:11,770 --> 00:11:16,200
그래서 있다는 것입니다 I
이 시간을 어떻게 잊어?

222
00:11:16,200 --> 00:11:20,230
어떻게이 시간을 누락?

223
00:11:20,230 --> 00:11:23,600
나는 나의 사용법 #include을 가지고,
그래서 printf의에 액세스 할 수 있습니다.

224
00:11:23,600 --> 00:11:26,090
>> 그러나 나는 무엇을 필요가 없습니다
아직 액세스?

225
00:11:26,090 --> 00:11:29,420
음, 그냥 지난 번처럼,
나는 컴파일러 말할 필요

226
00:11:29,420 --> 00:11:31,691
이러한 기능이 무엇인지 그 소리.

227
00:11:31,691 --> 00:11:33,940
에서는 get_string는 오지 않는다
C. 함께 특히 그것을

228
00:11:33,940 --> 00:11:38,160
에 오지 않는다
파일 헤더.

229
00:11:38,160 --> 00:11:40,770
대신에 온다
어떤 직원 썼다,

230
00:11:40,770 --> 00:11:44,176
이는 다른 파일입니다
이름하지만 적절하게 이름.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> 그래서 단순히 한 줄 것을 추가하여
마지막에서 code-- 리콜

233
00:11:50,861 --> 00:11:53,610
연타가 실행될 때, 그것은거야
바닥에 내 코드 상단에보고하고,

234
00:11:53,610 --> 00:11:54,193
왼쪽에서 오른쪽으로.

235
00:11:54,193 --> 00:11:57,200
그것은 알거야
오, 당신은 할 수 있습니다.

236
00:11:57,200 --> 00:11:59,900
내가 가서 그을 찾을 수 있습니다,
는 서버에있는 곳,

237
00:11:59,900 --> 00:12:03,090
본질적으로, 복사 및 붙여 넣기,
자신의 파일의 상단에

238
00:12:03,090 --> 00:12:06,820
그래서 이야기를이 시점에서 그,
라인 (1) 프로그램의 나머지

239
00:12:06,820 --> 00:12:11,651
실제로, 기능을 사용할 수
거기에, 그 (것)들의 사이에서는 get_string.

240
00:12:11,651 --> 00:12:13,650
그래서 나는 무시하는거야
이러한 오류의 나머지

241
00:12:13,650 --> 00:12:17,190
나는 때문에, 참으로, 만 의심
첫번째는 실제로 중요.

242
00:12:17,190 --> 00:12:20,780
그리고, 앞서 다시 실행 갈거야
내 파일을 저장 한 후 buggy1을합니다.

243
00:12:20,780 --> 00:12:22,580
그리고 짜잔, 그것은 일을했다.

244
00:12:22,580 --> 00:12:29,200
그리고 ./buggy1을하고 경우에 대해, 입력
인스턴스는, Zamyla는, 지금, 안녕하세요 얻을 것이다

245
00:12:29,200 --> 00:12:32,000
Zamyla 대신 안녕하세요, 세계.

246
00:12:32,000 --> 00:12:32,550
>> 괜찮아.

247
00:12:32,550 --> 00:12:35,890
그래서 여기 집에 사 가지고가는 요리는 다음과 같다,
하나, 많은 당신이 할 수 이삭하려고

248
00:12:35,890 --> 00:12:39,140
혼자 오류 메시지에서 찾고
인식 가능한 단어의 일부에서.

249
00:12:39,140 --> 00:12:43,070
이 없다면, 당 help50를 사용
문제는 사양을 설정합니다.

250
00:12:43,070 --> 00:12:46,500
하지만를 금지하는 것은, 너무, 항상 봐
가기 오류에서만 적어도

251
00:12:46,500 --> 00:12:50,051
처음에 볼 수있는 정보
실제로 얻을 수 있습니다.

252
00:12:50,051 --> 00:12:52,300
하지만이의를 밝혀
더 많은 기능을 내장

253
00:12:52,300 --> 00:12:55,030
CS50 라이브러리로 도움
학기 초기에 당신

254
00:12:55,030 --> 00:12:57,580
초기에 프로그래밍
잘못된 무슨 일이 일어나고 있는지 알아낼.

255
00:12:57,580 --> 00:12:59,840
그래서 여기에 또 다른 예를 수행 할 수 있습니다.

256
00:12:59,840 --> 00:13:04,350
나는 어떤이 buggy2를 호출하는거야,
다시 밖으로 결함이 될 것입니다

257
00:13:04,350 --> 00:13:05,650
디자인에 의해 게이트,의.

258
00:13:05,650 --> 00:13:09,980
>> 그리고 앞서 갈거야
및 사용법 #include을한다.

259
00:13:09,980 --> 00:13:12,580
그리고 나는 INT 주 (무효)를 할거야.

260
00:13:12,580 --> 00:13:14,840
그리고 나는 루프를 할거야.

261
00:13:14,840 --> 00:13:16,690
들어 (_ 0 난을 int로.

262
00:13:16,690 --> 00:13:18,750
난은 10 이하이다.

263
00:13:18,750 --> 00:13:24,260
나는 ++, 다음 중괄호, 내가 갈거야
여기에 단지 해시 태그 기호 인쇄하기

264
00:13:24,260 --> 00:13:25,920
새 라인 문자.

265
00:13:25,920 --> 00:13:29,220
>> 이 내 의도 그래서
프로그램은 매우 간단

266
00:13:29,220 --> 00:13:33,150
10 회 반복합니다
각 반복에

267
00:13:33,150 --> 00:13:35,260
그 루프마다의
사이클을 통해,

268
00:13:35,260 --> 00:13:37,660
해시 태그를 인쇄,
해시 태그, 해시 태그.

269
00:13:37,660 --> 00:13:40,480
하나 당 라인 I 때문에
거기에 새로운 라인을 가지고있다.

270
00:13:40,480 --> 00:13:42,787
그리고에 대한 리콜
마지막 week-- 당 루프,

271
00:13:42,787 --> 00:13:44,620
당신은 더 많은 것을 얻을 것이다
구문을 잘 알고

272
00:13:44,620 --> 00:13:47,170
연습을 사용하여
long-- 전에이 날 수 있습니다

273
00:13:47,170 --> 00:13:49,740
변수 내가 전화는 0으로 설정합니다.

274
00:13:49,740 --> 00:13:52,650
>> 이 난을에 증가
(1)에 의해 모든 반복.

275
00:13:52,650 --> 00:13:54,940
그래서 난 3 2 1로 이동합니다.

276
00:13:54,940 --> 00:13:57,690
그리고이 상태에서
세미 콜론 사이의 중간

277
00:13:57,690 --> 00:14:03,010
수 있도록 모든 반복에 확인됩니다
우리는 범위 내에서 여전히 있는지 확인하십시오.

278
00:14:03,010 --> 00:14:06,830
그래서 10 번 반복 할, 그래서
이 종류의 매우 직관적 단지

279
00:14:06,830 --> 00:14:09,070
거기에 내 상한으로 10했습니다.

280
00:14:09,070 --> 00:14:14,310
>> 그럼에도 불구하고, 나는이 프로그램을 실행할 때, 후
메이크업으로 컴파일 buggy2--

281
00:14:14,310 --> 00:14:15,440
그리고 OK 컴파일 않습니다.

282
00:14:15,440 --> 00:14:17,980
그래서 나는이 없습니다
구문 오류이 시간.

283
00:14:17,980 --> 00:14:20,940
내가 지금 앞서 가자
및 입력 buggy2를 실행합니다.

284
00:14:20,940 --> 00:14:22,620
그리고 지금까지 스크롤합니다.

285
00:14:22,620 --> 00:14:24,890
그리고 나 증가하자
창의 크기.

286
00:14:24,890 --> 00:14:33,720
>> I 가질 것 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
그래서, 비록 11 해시 태그있다
나는 분명히이 루프의 내부 (10)를 넣습니다.

288
00:14:38,891 --> 00:14:42,140
지금, 당신의 일부는 즉시 볼 수 있습니다
오류가 있기 때문에, 실제로이 무엇인지

289
00:14:42,140 --> 00:14:43,720
만들 수있는 매우 어려운 오류가 아닙니다.

290
00:14:43,720 --> 00:14:46,070
그러나 그것은 매우 일반적이다
초기에했다.

291
00:14:46,070 --> 00:14:49,820
>> 내가 지적하고자하지만,
어떻게이 알아낼 수 있습니까?

292
00:14:49,820 --> 00:14:52,300
글쎄, 그것은 밝혀
CS50 라이브러리 제공

293
00:14:52,300 --> 00:14:55,380
뿐만에서는 get_string 및 GET_INT와
get_float 및 기타 기능을합니다.

294
00:14:55,380 --> 00:14:59,980
또한 특별한 기능이 있습니다
라는 eprintf, 또는 오류의 printf.

295
00:14:59,980 --> 00:15:03,270
그리고 그것은 만들기 위해 단독으로 존재
그것은 당신을 위해 조금 더 쉽게

296
00:15:03,270 --> 00:15:06,310
단지를에 코드를 디버깅 할 때
화면 상에 에러 메시지를 출력

297
00:15:06,310 --> 00:15:07,850
그것이 어디에서 왔는지과 알​​고있다.

298
00:15:07,850 --> 00:15:11,000
>> 그래서 예를 들어, 한 가지 내가 수도
이 기능이 항아리입니다과 여기에서

299
00:15:11,000 --> 00:15:20,230
eprintf, 그리고, 나는 앞서 갈거야
그리고 난 내가, 백 슬래시, n은 지금 % 말한다.

300
00:15:20,230 --> 00:15:22,330
그리고 나는 i 값을 연결하겠습니다.

301
00:15:22,330 --> 00:15:25,400
그리고 상단까지,이 때문에
의 CS50 라이브러리에

302
00:15:25,400 --> 00:15:27,580
나는 앞서 갈거야
및 포함

303
00:15:27,580 --> 00:15:29,169
그래서 나는이 기능에 액세스 할 수 있습니다.

304
00:15:29,169 --> 00:15:31,460
하지만 이제 생각 해보자 무엇 라인
9 일을 할 예정이다.

305
00:15:31,460 --> 00:15:32,670
나는 결국이 삭제하겠습니다.

306
00:15:32,670 --> 00:15:34,670
이것은 할 수 없다
내 지배적 인 목표.

307
00:15:34,670 --> 00:15:39,090
그러나 eprintf, 오류의 printf, 그냥 의미
나에게 약간의 진단 정보를 제공합니다.

308
00:15:39,090 --> 00:15:42,460
내 프로그램을 실행하면, 내가 원하는
일시적으로 화면이 표시

309
00:15:42,460 --> 00:15:44,550
뿐만 아니라 단지 이해하기
무슨 일이야.

310
00:15:44,550 --> 00:15:47,330
>> 그리고, 참으로, 각
여기에 9 호선의 반복

311
00:15:47,330 --> 00:15:49,260
내가보고 싶은, i 값은 무엇인가?

312
00:15:49,260 --> 00:15:50,290
i 값은 무엇인가?

313
00:15:50,290 --> 00:15:51,280
i 값은 무엇인가?

314
00:15:51,280 --> 00:15:55,650
그리고, 희망, 나는 단지해야
해당 메시지, 또한, 10 배를 참조하십시오.

315
00:15:55,650 --> 00:15:57,780
>> 그래서 내가 가서 보자
내 프로그램을 다시 컴파일,

316
00:15:57,780 --> 00:15:59,905
나는 모든 시간을 할 필요가로
나는 변경합니다. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
그리고 now-- OK.

319
00:16:03,640 --> 00:16:04,820
더 진행이 많이 있습니다.

320
00:16:04,820 --> 00:16:07,610
그래서 나에 스크롤 할 수
더 큰 창.

321
00:16:07,610 --> 00:16:10,190
>> 그리고 당신의 각을 볼 수 있습니다
해시 태그는 여전히 인쇄됩니다.

322
00:16:10,190 --> 00:16:15,270
그러나 그 사이에 그들 각각은 지금이다
다음과 같이 진단 출력 포맷.

323
00:16:15,270 --> 00:16:17,960
여기 내 프로그램의 이름은 buggy2입니다.

324
00:16:17,960 --> 00:16:20,432
파일의 이름은 buggy2.c입니다.

325
00:16:20,432 --> 00:16:24,080
행 번호 이로부터
인쇄 된이 라인 9입니다.

326
00:16:24,080 --> 00:16:27,500
그리고 그 오른쪽에있는
내가 기대하고 있습니다 오류 메시지.

327
00:16:27,500 --> 00:16:30,701
>> 그리고이 있다는 것입니다에 대한 좋은거야
지금은 반드시 계산 할 필요가 없습니다

328
00:16:30,701 --> 00:16:32,200
내 머리에 내 프로그램은 무엇을하고 있는지.

329
00:16:32,200 --> 00:16:34,240
내가 온 것을 볼 수 있습니다
내가 0 첫 번째 반복,

330
00:16:34,240 --> 00:16:39,420
다음 1, 다음 2, 다음 3, 다음 4 다음
5, 다음 6 다음 7, 다음 8 다음 9 다음

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
그래서 분을 기다립니다.

333
00:16:42,050 --> 00:16:43,740
여기 무슨 일이야?

334
00:16:43,740 --> 00:16:48,190
나는 아직도 계산 된 것 같습니다
로 10 개까지 구성.

335
00:16:48,190 --> 00:16:50,550
>> 하지만 어디서부터 시작 했습니까?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

337
00:16:53,240 --> 00:16:58,040
따라서 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11 손가락

338
00:16:58,040 --> 00:16:59,990
문제를 나타낸다.

339
00:16:59,990 --> 00:17:02,850
내가 계산 한 것
잘못 내 루프입니다.

340
00:17:02,850 --> 00:17:06,599
10 반복을 이동하기보다는,
나는 0에서 시작 해요

341
00:17:06,599 --> 00:17:09,550
나는에 10을 종료하고 있습니다.

342
00:17:09,550 --> 00:17:12,030
그러나 때문에, 컴퓨터 등
나는 0에서 계산을 시작 해요

343
00:17:12,030 --> 00:17:15,250
나는까지 계산해야한다
행 아닌 10 내지.

344
00:17:15,250 --> 00:17:18,510
>> 그리고 수정, 나는 결국
여기에 실현, 두 가지 중 하나입니다.

345
00:17:18,510 --> 00:17:22,430
나는 아주 간단하게 말할 수
10 이하까지 계산합니다.

346
00:17:22,430 --> 00:17:27,260
따라서 0, 1, 2, 3, 4, 5, 6, 7, 8,
실제로, 올 9,

347
00:17:27,260 --> 00:17:28,900
심지어 약간의 잘못을 소리 불구하고.

348
00:17:28,900 --> 00:17:35,070
아니면 내가 할 수있는보다 작거나 같음
9, 너무 오래 나는 0에서 시작으로.

349
00:17:35,070 --> 00:17:40,056
아니면 정말 마음에 들지 않으면, 당신을
(10)를 통해 계산하지만 1에서 시작할 수 있습니다.

350
00:17:40,056 --> 00:17:41,680
그러나 다시, 이것은 단지 일반적인 아니다.

351
00:17:41,680 --> 00:17:43,977
programming--이기는에서
Scratch--에 너무 많이하지

352
00:17:43,977 --> 00:17:45,810
하지만 프로그래밍에
C와 다른 언어,

353
00:17:45,810 --> 00:17:47,670
자바 스크립트와 같은
파이썬과 다른, 그것은이다

354
00:17:47,670 --> 00:17:49,880
단지 아주 일반적인
이진의 논의

355
00:17:49,880 --> 00:17:53,450
단지에서 계산을 시작합니다
0 당신이 할 수있는 가장 낮은 숫자입니다.

356
00:17:53,450 --> 00:17:53,950
괜찮아.

357
00:17:53,950 --> 00:17:55,160
그래서 eprintf입니다.

358
00:17:55,160 --> 00:17:58,600
그리고 또, 지금은 알아 냈으니 내
문제는 내가 0으로 돌아갈거야

359
00:17:58,600 --> 00:18:01,470
10 미만을 통해, 내가 갈거야
가서 eprintf를 삭제합니다.

360
00:18:01,470 --> 00:18:04,580
>> 때 그것은 거기 안
코드를 제공하거나 코드를 제출

361
00:18:04,580 --> 00:18:05,800
또는 다른 사람에게 보여.

362
00:18:05,800 --> 00:18:07,980
그것은 정말 의미있어
임시로 사용할 수 있습니다.

363
00:18:07,980 --> 00:18:11,650
하지만 지금은이 문제를 해결했습니다
뿐만 아니라 특정 문제.

364
00:18:11,650 --> 00:18:16,780
>> 음, 여기에 하나 더 예를하자
본인은 다음과 같은 채찍거야있다.

365
00:18:16,780 --> 00:18:22,850
내가 가서거야 및
#포함 . $ (50)

366
00:18:22,850 --> 00:18:25,580
그리고 앞서 갈거야
및 사용법 #include.

367
00:18:25,580 --> 00:18:29,030
>> 그리고 저장거야
buggy3.c으로이 파일.

368
00:18:29,030 --> 00:18:31,740
그리고 앞서 갈거야
및 INT 주 (무효)를 선언합니다.

369
00:18:31,740 --> 00:18:34,186
그리고 내부가의
나는 내가 INT 할거야 _ -

370
00:18:34,186 --> 00:18:36,435
나는 프로그램을 구현하려면
get_negative_int와.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
이 아직 존재하는 함수가 아닙니다.

373
00:18:40,770 --> 00:18:42,870
그래서 우리는 구현하는거야
그것은 단지 순간입니다.

374
00:18:42,870 --> 00:18:45,541
그러나 우리는 왜 보게 될 것입니다
그것은 첫 번째 패스에서 버그가 있습니다.

375
00:18:45,541 --> 00:18:47,290
내가 받고 나면
사용자로부터의 int,

376
00:18:47,290 --> 00:18:53,365
난 그냥 %의 난을 인쇄 할거야 것은 부정적이다
정수, 백 슬래시, N, 쉼표, 난.

377
00:18:53,365 --> 00:18:55,240
즉, 모든 I
어떻게이 프로그램을 원하는

378
00:18:55,240 --> 00:18:58,000
에서 음의 INT를 얻을 수있다
사용자는 다음 인쇄

379
00:18:58,000 --> 00:18:59,980
그러한 이러한 부정적인 INT이다.

380
00:18:59,980 --> 00:19:02,080
>> 지금은이 기능을 구현해야합니다.

381
00:19:02,080 --> 00:19:05,740
그래서 나중에 내 파일에, 내가 갈거야
앞서와라는 함수를 선언

382
00:19:05,740 --> 00:19:10,670
get_negative_int (무효) - 우리 것
그 선이 다시 무엇을 의미하는지에 돌아온다

383
00:19:10,670 --> 00:19:18,790
moment--의 INT n에서; do-- 할 일
following--의의 printf n은 :.

384
00:19:18,790 --> 00:19:26,210
, GET_INT - 그리고 나는 N을 할거야
이 동안의 n은 0보다 큰 않습니다.

385
00:19:26,210 --> 00:19:28,310
그리고 n은 반환 ;.

386
00:19:28,310 --> 00:19:31,730
>> 그래서에서 진행이 많이있다
우리가하지 않았다있는이 있지만 없음

387
00:19:31,730 --> 00:19:33,710
적어도 잠시, 지난 주에 봐.

388
00:19:33,710 --> 00:19:36,980
그래서 여기에 라인 (10)에 I 선언 한
get_negative_int 호출 된 함수,

389
00:19:36,980 --> 00:19:39,620
나는에, (무효) 넣었습니다
괄호는 원인이되는

390
00:19:39,620 --> 00:19:40,950
입력을지지 않습니다.

391
00:19:40,950 --> 00:19:42,910
난 아무것도 통과하고 있지 않다
이 함수.

392
00:19:42,910 --> 00:19:44,690
난 그냥 다시 뭔가를 얻고있다.

393
00:19:44,690 --> 00:19:47,270
>> 그리고 난에 무엇을 바라고 있어요
돌아 가야하는 정수입니다.

394
00:19:47,270 --> 00:19:50,040
데이터 타입이 없다
C는 negative_int을했다.

395
00:19:50,040 --> 00:19:52,880
그냥 int로, 그래서 그것은거야
확인하기 위해 우리에 있어야합니다

396
00:19:52,880 --> 00:19:55,340
실제로의 값
반환뿐만 아니라 int 형이다

397
00:19:55,340 --> 00:19:56,380
뿐만 아니라 부정적이다.

398
00:19:56,380 --> 00:20:02,150
>> 라인 (12)에 나는 변수를 선언하고있어
n 및 int 타입을 제작했다.

399
00:20:02,150 --> 00:20:07,500
그리고 라인 (13) (18)를 통해 난
일을하는 것이 사실입니다있다.

400
00:20:07,500 --> 00:20:11,040
나는 앞서 인쇄거야
n은, 콜론 다음에 공백,

401
00:20:11,040 --> 00:20:12,800
사용자에 대한 메시지 등을들 수있다.

402
00:20:12,800 --> 00:20:16,410
>> 그때 GET_INT를 호출하고있어
이른바 리턴 값을 기억

403
00:20:16,410 --> 00:20:18,130
그 변수 n을한다.

404
00:20:18,130 --> 00:20:22,600
그러나 나는 일을 계속하려고 해요
이 동안의 n은 0보다 크다.

405
00:20:22,600 --> 00:20:27,960
즉, 사용자는 저을 준다면
int로 그 숫자가 0보다 큰 경우,

406
00:20:27,960 --> 00:20:31,180
ERGO는, 긍정적 인, 내가 갈거야
단지 사용자 reprompting 유지,

407
00:20:31,180 --> 00:20:37,160
그들을 강제로, reprompting을 유지
협력과 나에게 부정적인 INT를 제공합니다.

408
00:20:37,160 --> 00:20:41,640
>> n은 실제로 negative--되면
마지막 유형 -50 사용자 가정

409
00:20:41,640 --> 00:20:46,710
다음이 while 루프는 더 이상 사실입니다
-50 0보다 크지 않기 때문에.

410
00:20:46,710 --> 00:20:51,140
그래서 우리는 탈옥
루프는 논리적이고 n 반환합니다.

411
00:20:51,140 --> 00:20:53,520
>> 그러나 다른 하나는있다
일은 내가해야한다.

412
00:20:53,520 --> 00:20:56,190
그리고 간단히 말해서 나는이 작업을 수행 할 수 있습니다
복사 및 붙여 넣기로

413
00:20:56,190 --> 00:20:58,540
파일의 맨 위에 한 줄의 코드.

414
00:20:58,540 --> 00:21:01,630
나는 연타를 가르 칠 필요
또는 그 소리 약속,

415
00:21:01,630 --> 00:21:04,630
명시 적으로 나는 것,
실제로, 이동 및 구현

416
00:21:04,630 --> 00:21:06,020
이 기능 get_negative_int.

417
00:21:06,020 --> 00:21:07,674
그것은 단지 파일의 낮은 수 있습니다.

418
00:21:07,674 --> 00:21:09,840
다시, 리콜 연타
, 위에서 아래로 물건을 읽고

419
00:21:09,840 --> 00:21:12,330
왼쪽에서 오른쪽으로, 그래서 당신은 할 수 없습니다
연타하면 함수를 호출

420
00:21:12,330 --> 00:21:15,330
존재하는거야 알 수 없습니다.

421
00:21:15,330 --> 00:21:18,430
>> 지금, 불행하게도,이 프로그램,
당신의 일부는 눈치 챘을 수도

422
00:21:18,430 --> 00:21:19,590
이미 버그입니다.

423
00:21:19,590 --> 00:21:21,400
내가 가서 buggy3을 만들어 보자.

424
00:21:21,400 --> 00:21:26,904
내 문제는 지금되지 않도록 그것은 컴파일
구문 오류, 텍스트 오류 등,

425
00:21:26,904 --> 00:21:29,570
실제로 논리를 될 것
내가 의도적으로했습니다 오류

426
00:21:29,570 --> 00:21:32,450
를 기회로 만든
무슨 일이 일어나고 있는지를 단계별로.

427
00:21:32,450 --> 00:21:35,540
>> 나는 앞서 갈거야
지금 buggy3를 실행합니다.

428
00:21:35,540 --> 00:21:37,490
그리고 난 갈거야
앞서이 아닌 협력한다.

429
00:21:37,490 --> 00:21:39,494
나는 그것을 숫자 1을 줄거야.

430
00:21:39,494 --> 00:21:41,410
너무 그것을 좋아하지 않았다
그것은 나를 다시하라는거야.

431
00:21:41,410 --> 00:21:42,147
>> 방법 2?

432
00:21:42,147 --> 00:21:43,021
삼?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
그 중 어느 것도 작동하지 않습니다.

435
00:21:44,740 --> 00:21:46,890
어떻게 -50 어떻습니까?

436
00:21:46,890 --> 00:21:48,560
그리고 프로그램이 작동하는 것 같다.

437
00:21:48,560 --> 00:21:49,970
>> 나를 한 번 더 시도해 보자.

438
00:21:49,970 --> 00:21:53,400
나 -1을 시도하자 작동하는 것 같다.

439
00:21:53,400 --> 00:21:56,380
나 -2 해보자, 작동하는 것 같다.

440
00:21:56,380 --> 00:21:59,640
내가 공을 해보자.

441
00:21:59,640 --> 00:22:01,684
허, 그 잘못이다.

442
00:22:01,684 --> 00:22:03,350
이제, 우리는 여기에 약간 현학적 인 것입니다.

443
00:22:03,350 --> 00:22:07,090
그러나 경우 0이, 참으로,의
긍정적이나 부정적인 아닙니다.

444
00:22:07,090 --> 00:22:11,150
그래서 내 프로그램은 사실이다
0은 음의 정수라고 말하는

445
00:22:11,150 --> 00:22:12,820
즉, 기술적으로 정확하지 않습니다.

446
00:22:12,820 --> 00:22:15,180
>> 지금, 왜 이런 일을합니까?

447
00:22:15,180 --> 00:22:16,270
글쎄, 그것은 분명 수 있습니다.

448
00:22:16,270 --> 00:22:18,110
그리고, 실제로는, 프로그램
매우 간단 될 운명

449
00:22:18,110 --> 00:22:19,670
그래서 우리는 탐험하는 뭔가가있다.

450
00:22:19,670 --> 00:22:25,870
>> 그러나의 제 3 디버깅을 소개하자
기술은 여기 debug50했다.

451
00:22:25,870 --> 00:22:27,750
따라서이 프로그램은
우리는 방금 만든 것을

452
00:22:27,750 --> 00:22:30,770
올해이라고 debug50
그것은 당신에게 수

453
00:22:30,770 --> 00:22:34,130
내장 불리는 것을 사용
CS50의 IDE에서 그래픽 디버거.

454
00:22:34,130 --> 00:22:38,400
그리고 디버거는 프로그램입니다
일반적으로이 프로그램을 실행할 수 있습니다

455
00:22:38,400 --> 00:22:44,050
하지만, 단계, 라인별로 단계적으로
라인으로 라인으로, 파고, 일시 중지

456
00:22:44,050 --> 00:22:47,626
주변 변수를 찾고 있기 때문에
프로그램은 그냥지나 려하지 않습니다

457
00:22:47,626 --> 00:22:49,750
빨리 뭔가를 인쇄
또는 뭔가를 인쇄 할 수 없습니다.

458
00:22:49,750 --> 00:22:53,250
그것은에서 당신에게 기회를 제공합니다
인간의 속도는, 그것과 상호 작용할 수 있습니다.

459
00:22:53,250 --> 00:22:55,470
>> 그리고이 작업을 수행하려면
단순히 다음을 수행하십시오.

460
00:22:55,470 --> 00:22:58,479
코드를 컴파일 한 후,
이는 이미 한, buggy3,

461
00:22:58,479 --> 00:23:00,020
당신은 가서 debug50 ./buggy를 실행합니다.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
그래서 많은 help50 당신이 실행이 같은
help50하고 명령,

464
00:23:06,760 --> 00:23:10,120
debug50 당신이 debug50을 실행 가지고 있으며,
다음 명령의 이름.

465
00:23:10,120 --> 00:23:14,440
>> 지금 내 화면에 어떻게되는지보고,
특히 우측.

466
00:23:14,440 --> 00:23:19,400
나는 실행을, 모든 공격
갑자기이 오른쪽 패널

467
00:23:19,400 --> 00:23:20,419
화면에 열립니다.

468
00:23:20,419 --> 00:23:22,210
그리고가는 많은이있다
첫눈에.

469
00:23:22,210 --> 00:23:25,110
그러나 너무이 아니다
아직 걱정 많이.

470
00:23:25,110 --> 00:23:28,570
>> 이것은 나에게 모든 것을 보여주고있다
그건 내 프로그램의 내부에 무슨 일

471
00:23:28,570 --> 00:23:31,130
지금 이러한 통해
버튼 상단이 다음이다 최대

472
00:23:31,130 --> 00:23:35,910
내 코드를 단계별로 날 수 있도록
궁극적으로 단계별로 단계.

473
00:23:35,910 --> 00:23:37,140
하지만 아직.

474
00:23:37,140 --> 00:23:38,060
무슨 알 수 있습니다.

475
00:23:38,060 --> 00:23:40,600
내 터미널 창에서
나는 N를 입력하라는 메시지가되고 있어요.

476
00:23:40,600 --> 00:23:44,560
그리고 앞서 갈 예정하고있어
-1에서이 시간과 유형을 협력한다.

477
00:23:44,560 --> 00:23:48,770
그리고이기는하지만 약간 비밀스럽게, -1
예상대로 음의 정수이다.

478
00:23:48,770 --> 00:23:52,020
>> 그리고 아이로 종료
상태 0 GDBserver는 종료.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU 디버거는 이름입니다
기본 소프트웨어

480
00:23:55,180 --> 00:23:56,620
즉,이 디버거를 구현합니다.

481
00:23:56,620 --> 00:24:00,500
그러나이 모든 것이 정말 디버거를 의미한다
내 프로그램 종료하기 때문에 멀리 갔다

482
00:24:00,500 --> 00:24:01,710
모두 잘했다.

483
00:24:01,710 --> 00:24:06,020
내가 진정으로 내 프로그램을 디버깅 할 경우,
나는, 선제 debug50 말할 필요

484
00:24:06,020 --> 00:24:08,920
어디서 시작할까요
내 코드를 단계별로?

485
00:24:08,920 --> 00:24:11,750
>> 그리고 아마도 가장 간단한 방법
다음과 같이 즉해야 할 일.

486
00:24:11,750 --> 00:24:15,300
나는 위에 마우스를 올려 놓으면
여기 내 편집기의 거터,

487
00:24:15,300 --> 00:24:19,090
그래서 정말 여기에 사이드 바에서,
행 번호의 왼쪽에,

488
00:24:19,090 --> 00:24:21,870
있음을 그냥 클릭 통지하는 경우
일단, 나는 작은 빨간 점을 넣어.

489
00:24:21,870 --> 00:24:24,460
그리고 그 작은 빨간 점,
정지 신호처럼, 헤이, 의미,

490
00:24:24,460 --> 00:24:29,430
debug50, 내 코드의 일시 정지 실행
바로 내가이 프로그램을 실행할 때.

491
00:24:29,430 --> 00:24:30,260
>> 그럼 그렇게하자.

492
00:24:30,260 --> 00:24:37,340
내가 가서 내 프로그램을 실행하자
다시 debug50 ./buggy3에 입력합니다.

493
00:24:37,340 --> 00:24:40,110
그리고 지금, 통지, 뭔가
다른이 일어났다.

494
00:24:40,110 --> 00:24:42,440
나는 묻지 않을거야
아직 내 터미널 창에서

495
00:24:42,440 --> 00:24:45,430
아무것도, 때문에하지 않은
내 프로그램에서 아직 얻었다.

496
00:24:45,430 --> 00:24:47,950
라인 8 것을 알 수 있습니다
현재 하이라이트되는,

497
00:24:47,950 --> 00:24:51,720
그리고 약간의 화살표에있다
왼쪽 말은, 당신은 여기에 일시 중지됩니다.

498
00:24:51,720 --> 00:24:55,030
코드 라인이 선
8, 아직 실행되지 않았습니다.

499
00:24:55,030 --> 00:24:58,940
>> 내가 보면 그리고, 호기심 무엇
오른쪽에 여기에,

500
00:24:58,940 --> 00:25:03,530
내가 로컬 것을 알
의미에서 지역 변수,

501
00:25:03,530 --> 00:25:05,450
것이 현재의 함수 내에서입니다.

502
00:25:05,450 --> 00:25:08,920
그리고 그 값 분명히 기본적으로,
및 종류의 편리 0입니다.

503
00:25:08,920 --> 00:25:10,260
하지만 0을 입력하지 않았다.

504
00:25:10,260 --> 00:25:13,410
그건 그냥 될 일이 그
순간 기본값.

505
00:25:13,410 --> 00:25:15,490
>> 그래서 내가 가서 지금이 작업을 수행 할 수 있습니다.

506
00:25:15,490 --> 00:25:18,680
내가 미리와에 가자
여기 상단, 난

507
00:25:18,680 --> 00:25:20,970
앞서 갈과
이 첫 번째 아이콘을 클릭하는

508
00:25:20,970 --> 00:25:25,360
이상의 단계는 생략하지 않는 수단
그것은하지만이 코드 라인을 통해 단계,

509
00:25:25,360 --> 00:25:27,770
길을 따라 그것을 실행.

510
00:25:27,770 --> 00:25:30,710
>> 그리고 지금, 주목 내
프롬프트는 변경되었습니다.

511
00:25:30,710 --> 00:25:31,380
그 이유는 무엇입니까?

512
00:25:31,380 --> 00:25:33,639
나는 debug50 말 했어요,
이 코드 줄을 실행합니다.

513
00:25:33,639 --> 00:25:34,930
이 코드 줄은 무엇입니까?

514
00:25:34,930 --> 00:25:35,960
하는 int 날 메시지를 표시합니다.

515
00:25:35,960 --> 00:25:36,460
승인.

516
00:25:36,460 --> 00:25:37,400
내가 협력 할 수 있습니다.

517
00:25:37,400 --> 00:25:41,340
내가 지금 가서 -1을 입력, 입력 할 수 있습니다.

518
00:25:41,340 --> 00:25:42,920
그리고 지금의 변경 사항을 알 수 있습니다.

519
00:25:42,920 --> 00:25:46,060
오른쪽에,
내 지역 변수 내가

520
00:25:46,060 --> 00:25:48,200
인 -1 해주기로 표시됩니다.

521
00:25:48,200 --> 00:25:49,810
그리고 int 형의 여전히.

522
00:25:49,810 --> 00:25:53,102
>> 그리고주의 사항, 너무, 내 소위
스택을 호출, 어디 일시 중지 했습니까?

523
00:25:53,102 --> 00:25:54,810
우리에 대해 더 얘기하자
앞으로이.

524
00:25:54,810 --> 00:25:58,620
그러나 호출 스택은 무엇을 의미
기능은 모션 현재.

525
00:25:58,620 --> 00:26:00,040
지금은 그냥 기본입니다.

526
00:26:00,040 --> 00:26:03,590
그리고 지금 로컬을
변수는 1의 값을 전합니다.

527
00:26:03,590 --> 00:26:09,840
>> 그리고 마지막으로이 라인을 통해 단계 때
여기에, 오른쪽 상단에 같은 아이콘,

528
00:26:09,840 --> 00:26:11,410
-1 음의 정수입니다.

529
00:26:11,410 --> 00:26:13,580
지금은 그 중괄호를 통해 일시 중지합니다.

530
00:26:13,580 --> 00:26:14,740
의는 그 일을 할 수 있습니다.

531
00:26:14,740 --> 00:26:17,300
나는 그 라인, 그리고 짜잔을 통해 단계.

532
00:26:17,300 --> 00:26:20,240
>> 그래서 모든 것을 몹시
, 계몽 아직

533
00:26:20,240 --> 00:26:23,550
하지만 그것은 나를 일시 중지 할 수 않았다
논리적를 통해 생각

534
00:26:23,550 --> 00:26:24,870
이 프로그램은 무엇을하고있다.

535
00:26:24,870 --> 00:26:26,890
그러나 그것은 잘못된 경우 아니었다.

536
00:26:26,890 --> 00:26:28,510
다음의 다시이 작업을 수행 할 수 있습니다.

537
00:26:28,510 --> 00:26:31,340
>> 그 중단 점을 떠날거야
빨간 점과 선 8.

538
00:26:31,340 --> 00:26:32,830
나는 debug50를 다시 실행거야.

539
00:26:32,830 --> 00:26:34,400
그것은 여기에 자동으로 일시 정지합니다.

540
00:26:34,400 --> 00:26:37,660
하지만이 시간, 대신
이 라인을 통해 스테핑,

541
00:26:37,660 --> 00:26:42,290
내가 실제로 내부에 가자
get_negative_int 및 파악,

542
00:26:42,290 --> 00:26:45,530
왜 유효한 답변으로 0을 받고있다?

543
00:26:45,530 --> 00:26:47,990
>> 그래서 대신 이상의 단계를 클릭.

544
00:26:47,990 --> 00:26:50,630
나는 앞서 갈거야
그리고 한 단계를 클릭합니다.

545
00:26:50,630 --> 00:26:54,030
그리고 라인 (8)의 그 것을 알 수
지금 갑자기 지금 강조

546
00:26:54,030 --> 00:26:56,900
라인 (17)이된다.

547
00:26:56,900 --> 00:26:59,947
>> 지금, 그것은 디버거 것이 아니다
라인 (14) 및 (15, 16) 생략하고있다.

548
00:26:59,947 --> 00:27:01,780
그냥 거기에 아무것도 있어요
거기를 표시합니다.

549
00:27:01,780 --> 00:27:04,050
사람들은 그냥 변수를 선언하는,
다음 단어가 수행 있어요

550
00:27:04,050 --> 00:27:05,390
다음 오픈 중괄호.

551
00:27:05,390 --> 00:27:09,227
의 유일한 기능 라인
육즙이 정말 여기 하나, (17)이다.

552
00:27:09,227 --> 00:27:11,060
우리가했습니다 곳 그리고 그건
자동으로 일시 중지되었습니다.

553
00:27:11,060 --> 00:27:13,870
>> 그래서의 printf ( "n.is :"); 이렇게
즉, 아직 일어나지 않았습니다.

554
00:27:13,870 --> 00:27:18,250
그럼 가서 스텝 오버를 클릭 할 수 있습니다.

555
00:27:18,250 --> 00:27:20,326
지금 내 프롬프트, 참으로,
로 변경 ( "n은").

556
00:27:20,326 --> 00:27:22,450
지금은 않을거야, GET_INT
단계 씩 귀찮게하고,

557
00:27:22,450 --> 00:27:24,750
그 기능 이었기 때문에
도서관에서 CS50로했다.

558
00:27:24,750 --> 00:27:25,750
그것은 아마도 맞습니다.

559
00:27:25,750 --> 00:27:28,440
>> 그래서 앞서 갈거야 및
일종의을 제공함으로써 협력

560
00:27:28,440 --> 00:27:30,590
하는 int 있지만 부정적인 INT.

561
00:27:30,590 --> 00:27:32,870
그래서 내가 가서 공을 칠 수 있습니다.

562
00:27:32,870 --> 00:27:39,460
그리고 지금 무슨 일이 발생
내가 내려 할 때 21 선에?

563
00:27:39,460 --> 00:27:40,890
나는 다시 반복하지했습니다.

564
00:27:40,890 --> 00:27:43,320
그 루프에 갇혀 것 같습니다하지 않습니다.

565
00:27:43,320 --> 00:27:45,990
즉,이 노란색
바는, 주위에 계속하지 않았다

566
00:27:45,990 --> 00:27:47,130
주위, 주변.

567
00:27:47,130 --> 00:27:48,340
>> 이제, 그 이유는 무엇입니까?

568
00:27:48,340 --> 00:27:49,920
음, N, 지금 무엇을 n은?

569
00:27:49,920 --> 00:27:53,280
나는 지방에서 볼 수 있습니다
디버거의 변수.

570
00:27:53,280 --> 00:27:53,816
n은 0입니다.

571
00:27:53,816 --> 00:27:55,190
좋아, 내 조건은 무엇인가?

572
00:27:55,190 --> 00:27:58,700
>> 20-- 라인 (20)이 잘된다,
0은 0보다 크다.

573
00:27:58,700 --> 00:27:59,500
그건 사실이 아니다.

574
00:27:59,500 --> 00:28:01,020
0은 0보다 크다.

575
00:28:01,020 --> 00:28:02,820
그래서 나는이 밖으로 끊었다.

576
00:28:02,820 --> 00:28:06,370
>> 그리고 그 이유를 줄입니다
21 내가 실제로 계속하면,

577
00:28:06,370 --> 00:28:10,370
난, 0을 반환거야
나는 공을 거부해야하지만

578
00:28:10,370 --> 00:28:12,484
로 실제로 부정적 없습니다.

579
00:28:12,484 --> 00:28:14,650
그래서 지금, 난 정말조차하지 않습니다
디버거에 관심.

580
00:28:14,650 --> 00:28:16,900
그것은, 내가 할 필요가 없습니다 당함
무슨 일이 일어나고 있는지 더 알고있다.

581
00:28:16,900 --> 00:28:19,233
>> 그래서 앞서 갈거야 및
그냥 재생 버튼을 클릭,

582
00:28:19,233 --> 00:28:20,240
이 끝을 위로 할 수 있습니다.

583
00:28:20,240 --> 00:28:23,440
지금, 나는 것을 깨달았다 내
버그 라인 (20)에 분명히있다.

584
00:28:23,440 --> 00:28:25,160
그건 내 논리 오류입니다.

585
00:28:25,160 --> 00:28:28,100
>> 그래서 내가 원하는 수행
이 위치를 변경 할까?

586
00:28:28,100 --> 00:28:32,500
문제는 내가 아니에요 경우
0 잡기, 그것은 단지 논리적 인 오류입니다.

587
00:28:32,500 --> 00:28:35,910
n은 동안 내가 말할 수있는
0보다 크거나 같은,

588
00:28:35,910 --> 00:28:38,330
또 다시 사용자에게 메시지를 보관합니다.

589
00:28:38,330 --> 00:28:41,050
>> 그래서, 다시, 단순한 실수, 아마도
당신이 나를보고도 분명

590
00:28:41,050 --> 00:28:42,410
불과 몇 분 전을 작성합니다.

591
00:28:42,410 --> 00:28:44,570
그러나 여기 테이크 아웃
이다 디버그 (50)이,

592
00:28:44,570 --> 00:28:46,850
및 디버깅
소프트웨어보다 일반적

593
00:28:46,850 --> 00:28:51,370
이 새로운 발견 전원이
보고, 자신의 코드를 살펴

594
00:28:51,370 --> 00:28:55,590
그 오른쪽 패널을 통해 무엇을
당신의 변수 값은 다음과 같습니다.

595
00:28:55,590 --> 00:28:57,700
그래서 당신은 필요하지 않습니다
무언가를 사용해야

596
00:28:57,700 --> 00:29:00,630
같은 당신은 그 값을 인쇄 할 수 eprintf.

597
00:29:00,630 --> 00:29:04,430
당신은 실제로 그들을 볼 수 있습니다
시각적으로 화면에.

598
00:29:04,430 --> 00:29:08,920
>> 자,이 이상, 그것은 주목할 가치가있다
의 또 다른 기술이 있다고

599
00:29:08,920 --> 00:29:09,890
실제로 슈퍼 일반적인.

600
00:29:09,890 --> 00:29:13,120
그리고 당신은 왜이 조금 궁금 할 것이다
여기에 사람이 무대에 앉아있다.

601
00:29:13,120 --> 00:29:16,490
따라서이 기술은 일반적으로, 거기
고무 오리 디버깅으로 알려진,

602
00:29:16,490 --> 00:29:18,786
이는 정말로 단지입니다
사실 입증

603
00:29:18,786 --> 00:29:20,660
그 종종 프로그래머
코드를 작성,

604
00:29:20,660 --> 00:29:22,650
그들은 반드시 아니에요
다른 사람과 협력,

605
00:29:22,650 --> 00:29:24,030
또는 공유 환경에서 작업.

606
00:29:24,030 --> 00:29:25,050
>> 그들은 집에서 일종의입니다.

607
00:29:25,050 --> 00:29:25,910
아마 밤에 늦었어요.

608
00:29:25,910 --> 00:29:28,190
그들은 그림을 시도하고
자신의 코드에 약간의 버그 아웃.

609
00:29:28,190 --> 00:29:29,330
그리고 그들은 단지 그것을보고 아닙니다.

610
00:29:29,330 --> 00:29:30,329
>> 그리고 더 룸메이트가 없습니다.

611
00:29:30,329 --> 00:29:31,250
더 TF가 없습니다.

612
00:29:31,250 --> 00:29:32,680
주위에 CA가 없습니다.

613
00:29:32,680 --> 00:29:36,440
그들의 선반에있는 모든
이 작은 고무 오리입니다.

614
00:29:36,440 --> 00:29:39,030
>> 그리고 고무 오리 디버깅
그냥이 초대

615
00:29:39,030 --> 00:29:42,780
같은 바보 뭔가 생각하는
실제 생물로이 같은

616
00:29:42,780 --> 00:29:46,940
실제로 코드를 살펴
구두이 생명이없는 객체.

617
00:29:46,940 --> 00:29:49,230
그래서, 예를 들면,
이 내 예입니다 here--

618
00:29:49,230 --> 00:29:52,470
그 이전 리콜
문제는이 있었다

619
00:29:52,470 --> 00:29:58,140
나는이 코드 첫 줄을 삭제하는 경우,
내가 가서 다시 버그는 0,

620
00:29:58,140 --> 00:30:01,220
나는이 있었다는 것을 기억
여기에 오류 메시지.

621
00:30:01,220 --> 00:30:05,997
그래서 비록 말도 여기에 아이디어,
공개적으로이 일 순간에 느낌

622
00:30:05,997 --> 00:30:06,580
해당 오류입니다.

623
00:30:06,580 --> 00:30:10,910
>> OK, 그래서 내 문제는 내가했습니다 것입니다
암시 적으로 라이브러리 함수를 선언했다.

624
00:30:10,910 --> 00:30:12,610
그리고 그 라이브러리 함수의 printf입니다.

625
00:30:12,610 --> 00:30:15,290
OK Declare-- 선언
프로토 타입의 저를 생각 나게한다.

626
00:30:15,290 --> 00:30:18,930
>> 그게 내가 실제로 필요 의미
미리 컴파일러에게 무엇을

627
00:30:18,930 --> 00:30:19,980
이 함수는 것 같습니다.

628
00:30:19,980 --> 00:30:20,930
분을 기다립니다.

629
00:30:20,930 --> 00:30:23,580
나는 표준 io.h.이 없었다

630
00:30:23,580 --> 00:30:24,530
대단히 감사합니다.

631
00:30:24,530 --> 00:30:27,330
>> 당신 동행입니다 그래서 그냥이 과정
실제로 오리를 할 필요가 없습니다.

632
00:30:27,330 --> 00:30:29,819
그러나 걷는이 아이디어
자신의 코드를 통해 자신

633
00:30:29,819 --> 00:30:31,610
그래서 당신도들을 수 있음
자신 때문에 그

634
00:30:31,610 --> 00:30:35,620
자신의 누락을 실현
말은 일반적으로 생각입니다.

635
00:30:35,620 --> 00:30:38,910
>> 그리고, 아마도 더 논리적으로, 그리
하나하지만 더 많은 참여와 많은

636
00:30:38,910 --> 00:30:44,220
예를 들어 우리는 단지, 버그 3.C에서 한
당신은 그것을 통해 자신을 걸을 수 있습니다

637
00:30:44,220 --> 00:30:45,310
으로는 다음과 같습니다.

638
00:30:45,310 --> 00:30:49,190
그래서 모든 권리, 고무
오리, DDB, 당신이됩니다.

639
00:30:49,190 --> 00:30:52,350
여기에 우리가 내 주요 기능에있다,
나는 부정적인 INT를 얻을 전화 드렸습니다.

640
00:30:52,350 --> 00:30:54,660
>> 그리고는 반환 값을 얻고있다.

641
00:30:54,660 --> 00:31:00,410
I는 왼쪽에 기억하고있어
변수에 선 8 전을했다.

642
00:31:00,410 --> 00:31:02,380
OK,하지만 잠깐, 어떻게했다
즉, 그 값을 얻을?

643
00:31:02,380 --> 00:31:04,130
나 라인 (12)의 기능을 살펴 보자.

644
00:31:04,130 --> 00:31:05,760
>> 라인 12에서, 우리는 부정적인 INT를 얻을 수 있습니다.

645
00:31:05,760 --> 00:31:08,190
어떤 입력을하지 않는다,
OK, int를 반환 않습니다.

646
00:31:08,190 --> 00:31:10,929
나는 선 (14) 변수 (n)에 선언합니다.

647
00:31:10,929 --> 00:31:12,220
정수를 저장하는 것입니다.

648
00:31:12,220 --> 00:31:13,760
그게 내가 원하는거야.

649
00:31:13,760 --> 00:31:18,480
>> n은 할 수 is-- 동안 그래서 다음을 수행
나 수정 이미 만들어진 것을 취소.

650
00:31:18,480 --> 00:31:22,710
N보다 큰 동안 그래서
0, OK, n은 인쇄.

651
00:31:22,710 --> 00:31:25,170
그리고 INT N에 저장 얻을 호출합니다.

652
00:31:25,170 --> 00:31:30,160
n이 0 인 경우, 그리고, 확인
여기서 n은 이것도 아니고 ... 거기가입니다.

653
00:31:30,160 --> 00:31:31,910
그래서, 다시, 당신은하지 않습니다
실제 오리가 필요합니다.

654
00:31:31,910 --> 00:31:35,650
그러나 단지 자신을 통해 산책
지적 운동으로 코드

655
00:31:35,650 --> 00:31:37,720
종종 당신을 도울 것입니다
, 무슨 일이 일어나고 있는지 실현

656
00:31:37,720 --> 00:31:41,170
그냥 뭔가를하고 반대로
이 같은 화면을보고,

657
00:31:41,170 --> 00:31:43,720
자신을 통해 이야기하고 있지
정직하지 않습니다 그것은,

658
00:31:43,720 --> 00:31:46,270
거의 효과적인 기술로서.

659
00:31:46,270 --> 00:31:48,620
그래서 당신이 원해야하는
다른 기술의 수

660
00:31:48,620 --> 00:31:52,102
실제로 코드를 디버깅
하고, 오류를 찾는 모두의

661
00:31:52,102 --> 00:31:54,810
당신의 도구 키트 도구해야한다
당신이 밤 늦게 아니에요 너무

662
00:31:54,810 --> 00:31:57,660
특히, 당신은 식사에있어
홀, 또는 근무 시간에,

663
00:31:57,660 --> 00:32:00,368
에 대하여 당신의 머리를 두드리는
벽, 일부 문제를 해결하려고.

664
00:32:00,368 --> 00:32:02,020
소프트웨어 도구가 있다는 것을 알고 있습니다.

665
00:32:02,020 --> 00:32:03,720
고무 오리 도구가 있습니다.

666
00:32:03,720 --> 00:32:09,630
그리고의 전체 직원있다
손을 빌려 기다리고 지원합니다.

667
00:32:09,630 --> 00:32:13,120
>> 이 문제에 그래서 지금, 단어
세트, 우리는 당신을 희망하는지에

668
00:32:13,120 --> 00:32:15,620
그들 나가, 어떻게
우리는 평가에 대해 이동합니다.

669
00:32:15,620 --> 00:32:17,680
과정의 강의 당,
CS50의 문제 세트

670
00:32:17,680 --> 00:32:22,320
그래서, 4 개의 축에 평가
범위를 speak--하고, 정확성, 디자인,

671
00:32:22,320 --> 00:32:23,060
스타일.

672
00:32:23,060 --> 00:32:25,910
그리고 범위는 얼마나을 말한다
조각의 당신은 떨어져 물린했다?

673
00:32:25,910 --> 00:32:28,080
당신은 어떻게 문제의 대부분을 시도했다?

674
00:32:28,080 --> 00:32:30,110
노력의 수준을
당신은 명시했다?

675
00:32:30,110 --> 00:32:35,750
>> 정확성은 그대로 프로그램 작업을 수행
그것은 CS50 사양 당에 뜻이야

676
00:32:35,750 --> 00:32:38,640
당신은 어떤 입력을 제공 할 때
또는 특정 출력은 돌아 오지?

677
00:32:38,640 --> 00:32:41,130
디자인은 그들의 가장 주관적이다.

678
00:32:41,130 --> 00:32:43,360
그리고 하나는 것입니다
배우는 가장 긴을

679
00:32:43,360 --> 00:32:47,220
가장 긴은에서 가르쳐
지금까지 그 귀결로서,

680
00:32:47,220 --> 00:32:49,530
코드가 얼마나 잘 작성입니까?

681
00:32:49,530 --> 00:32:52,920
>> 그것은 단지 올바른을 인쇄 할 한 가지
출력 또는 오른쪽 값을 반환합니다.

682
00:32:52,920 --> 00:32:55,400
하지만 당신은으로하고있다
효율적으로?

683
00:32:55,400 --> 00:32:58,210
당신은 그것을 나누기를하고있다
정복, 또는 이진

684
00:32:58,210 --> 00:33:01,500
우리는 곧 우리가했던 것을 볼 수 있습니다로 검색
2 주 전 전화 번호부와?

685
00:33:01,500 --> 00:33:04,670
를 해결하기 위해 더 나은 방법이있다
현재 여기에있는 것보다 문제?

686
00:33:04,670 --> 00:33:06,380
즉, 더 나은 디자인을위한 기회입니다.

687
00:33:06,380 --> 00:33:08,530
>> 그리고 어떻게 style--
꽤 코드는?

688
00:33:08,530 --> 00:33:12,370
당신은 내가 꽤 있어요 것을 알 수 있습니다
내 코드 들여 쓰기를 고집,

689
00:33:12,370 --> 00:33:15,300
있는지 내 변수를 만들기
합리적으로 이름이 지정됩니다. 엔,

690
00:33:15,300 --> 00:33:19,660
짧은 동안,에 대한 좋은 이름입니다
번호, 계산 정수 난,

691
00:33:19,660 --> 00:33:20,727
문자열에 대한의.

692
00:33:20,727 --> 00:33:22,560
그리고 우리는 더 이상 할 수 있습니다
변수 이름 스타일.

693
00:33:22,560 --> 00:33:25,500
스타일은 얼마나 좋은
코드가 보입니까?

694
00:33:25,500 --> 00:33:26,600
그리고 그것은 어떻게 읽을?

695
00:33:26,600 --> 00:33:29,650
>> 그리고 시간이 지남에, 어떤 당신의 조교
및 TF가이 과정에서 할 것

696
00:33:29,650 --> 00:33:31,870
그 당신에게 제공한다
질적 인 피드백의 종류

697
00:33:31,870 --> 00:33:34,330
당신은 더 나은 얻을 수 있도록
그 다양한 측면에서.

698
00:33:34,330 --> 00:33:37,510
그리고 방법의 측면에서
이들 각 축의 평가

699
00:33:37,510 --> 00:33:40,080
그것은 거의 전형적이다
버킷 당신이 있기 때문에, 일반적으로,

700
00:33:40,080 --> 00:33:41,680
당신이하고있는 얼마나 잘 감각을 얻을.

701
00:33:41,680 --> 00:33:45,680
그리고, 참으로, 당신은 점수에 나타날 경우
그 axes-- 정확성, 디자인의

702
00:33:45,680 --> 00:33:49,659
스타일 especially-- 그 숫자가
일반적으로 1에서 5 사이에있을 것입니다.

703
00:33:49,659 --> 00:33:52,450
그리고, 문자 그대로 당신은 점점하는 경우
학기의 시작 3의,

704
00:33:52,450 --> 00:33:53,977
이것은 매우 좋은 일이있다.

705
00:33:53,977 --> 00:33:55,810
그것은 여전히​​ 의미합니다
개선의 여지,

706
00:33:55,810 --> 00:33:58,490
당신의 희망 것이다
처음 클래스 복용.

707
00:33:58,490 --> 00:34:01,820
천장의 일부 비트는 희망이있다
이는 당신이 도달에 주목하고 있습니다.

708
00:34:01,820 --> 00:34:03,970
그리고 3의에 점점
초기 조각,

709
00:34:03,970 --> 00:34:06,550
그렇지 않으면 일부 2의 4의,
참으로 좋은 일입니다.

710
00:34:06,550 --> 00:34:08,880
그것은 잘 범위 내에서의
잘 기대 이내.

711
00:34:08,880 --> 00:34:11,421
>> 당신의 마음이 경주되는 경우, 대기
분, 3 ~ 5 중.

712
00:34:11,421 --> 00:34:12,620
그건 정말 (10)의 6 아웃입니다.

713
00:34:12,620 --> 00:34:13,560
즉 60 %입니다.

714
00:34:13,560 --> 00:34:14,830
F.의 나의 하나님,

715
00:34:14,830 --> 00:34:15,870
>> 그것은 아니다.

716
00:34:15,870 --> 00:34:17,600
그것은 사실이 아니다.

717
00:34:17,600 --> 00:34:22,710
오히려 향상시킬 수있는 기회의
학기의 과정을 통해.

718
00:34:22,710 --> 00:34:25,580
그리고 당신은 어떤을 받고하는 경우
푸어스, 이러한 기회입니다

719
00:34:25,580 --> 00:34:29,199
근무 시간을 활용하기 위해,
확실히 섹션 및 기타 리소스.

720
00:34:29,199 --> 00:34:32,840
>> 베스트는 정말 기회입니다
당신이했습니다 얼마나 멀리 자랑하는

721
00:34:32,840 --> 00:34:34,520
학기의 과정을 통해 제공됩니다.

722
00:34:34,520 --> 00:34:38,199
그래서 실현 않는, 아무것도 경우
다른 세 좋다.

723
00:34:38,199 --> 00:34:40,179
그리고 시간이 지남에 따라 성장을위한 공간을 할 수 있습니다.

724
00:34:40,179 --> 00:34:43,090
>> 그 축이 방법으로
가중, 현실적으로 당신이있어

725
00:34:43,090 --> 00:34:46,745
점점 대부분의 시간을 보낼 예정
작업에 일이 제대로 혼자 할 수 있습니다.

726
00:34:46,745 --> 00:34:49,120
그리고 정확성는 경향이있다
와 같이, 대부분의 가중 될

727
00:34:49,120 --> 00:34:51,360
셋이 곱셈 요인.

728
00:34:51,360 --> 00:34:54,659
디자인도 중요하지만
당신이 필요하지 뭔가

729
00:34:54,659 --> 00:34:58,220
에 그 시간을 모두 소비
일이 그냥 작동려고.

730
00:34:58,220 --> 00:35:00,019
>> 그리고 그것은 가중있어
더 가볍게 조금.

731
00:35:00,019 --> 00:35:01,560
그리고 스타일은 적어도 가중된다.

732
00:35:01,560 --> 00:35:03,710
심지어 더 적은의 생각
근본적으로 중요한 것은,

733
00:35:03,710 --> 00:35:05,990
그것은 그냥, 아마의
가장 쉬운 방법은 바로해야 할 일

734
00:35:05,990 --> 00:35:08,440
예 우리를 흉내 낸
강의와 절에서 수행

735
00:35:08,440 --> 00:35:11,080
잘 것들로
들여 쓰기 및 댓글,

736
00:35:11,080 --> 00:35:14,320
등 가장 쉬운 방법 중 하나입니다
일이 이렇게 오른쪽 얻을 수 있습니다.

737
00:35:14,320 --> 00:35:16,960
같은 그래서 실현
그 포인트는 것을

738
00:35:16,960 --> 00:35:19,000
그 파악하기가 비교적 쉽다.

739
00:35:19,000 --> 00:35:22,360
>> 그리고 지금 단어에
학문적 정직이 항아리.

740
00:35:22,360 --> 00:35:25,150
과정의 당 그래서
강의 계획서, 당신은 볼 것이다

741
00:35:25,150 --> 00:35:27,630
코스가 가지고있는 꽤
이 주위 언어의 비트.

742
00:35:27,630 --> 00:35:31,380
그리고 과정의 문제를 소요
아주 심각하게 학문적 정직.

743
00:35:31,380 --> 00:35:33,450
>> 우리는 차이를 가지고,
더 나은 또는 더 나쁜,

744
00:35:33,450 --> 00:35:36,570
전송 한의 매년 더
징계 조치에 대한 학생

745
00:35:36,570 --> 00:35:39,670
대부분의 어떤 다른 것보다
물론, 나는의 알고있다.

746
00:35:39,670 --> 00:35:42,580
이것은 필요하지 않다
사실을 나타내는

747
00:35:42,580 --> 00:35:46,340
CS 학생, 또는 CS50 학생들이 있음
덜 반 친구들보다 정직.

748
00:35:46,340 --> 00:35:49,090
그러나 현실이이
세계, 전자, 우리 단지

749
00:35:49,090 --> 00:35:50,990
기술이
이 검출 수단.

750
00:35:50,990 --> 00:35:53,360
>> 그것은 우리에게 중요하다
클래스에서 공정성

751
00:35:53,360 --> 00:35:58,550
우리가 할 것을이를 감지하고, 인상
문제 우리는 사물을 볼 때.

752
00:35:58,550 --> 00:36:01,980
단지 그림을 그릴, 정말하기
이 싱크 같은 것을 돕기 위해,

753
00:36:01,980 --> 00:36:04,600
이들의 숫자
지난 10 년 동안 학생들

754
00:36:04,600 --> 00:36:07,610
일부에 관여 한 그
학문적 정직 등의 문제,

755
00:36:07,610 --> 00:36:10,990
일부 (32) 학생
가을 2015 년에서하는

756
00:36:10,990 --> 00:36:13,760
우리가 걸릴 않는 말을하는 것입니다
문제 매우 심각.

757
00:36:13,760 --> 00:36:18,380
그리고, 궁극적으로,이 숫자는 구성,
최근, 3 %, 4 % 정도

758
00:36:18,380 --> 00:36:19,120
클래스의.

759
00:36:19,120 --> 00:36:25,220
>> 학생의 슈퍼 대부분 그래서
선이 분명한 것 같다.

760
00:36:25,220 --> 00:36:27,940
그러나이 유지 않는다
특히 후반, 마음

761
00:36:27,940 --> 00:36:32,080
밤에 고민 할 때
문제 세트에 몇 가지 솔루션,

762
00:36:32,080 --> 00:36:34,830
메커니즘이 있음
더 나은 자신을 얻기를위한

763
00:36:34,830 --> 00:36:37,870
당신보다 지원이 수도
심지어 그 시간에, 생각한다.

764
00:36:37,870 --> 00:36:40,514
우리가받을 때 실현
학생의 제출, 우리는 교차

765
00:36:40,514 --> 00:36:43,430
올해 모든 제출을 비교
모든 제출 작년에 대하여,

766
00:36:43,430 --> 00:36:47,590
2007 년 모든 제출에 대하여,
뿐만 아니라,보고, 이후,

767
00:36:47,590 --> 00:36:49,931
코드는 온라인 레포지토리
토론 포럼, 작업 현장.

768
00:36:49,931 --> 00:36:51,806
그리고 우리는이 문제를 언급,
정말로 위해서 모든

769
00:36:51,806 --> 00:36:56,040
전체 공개의 경우 그
다른 사람이 온라인을 찾을 수 있습니다

770
00:36:56,040 --> 00:36:57,880
확실히, 우리 과정 수 있습니다.

771
00:36:57,880 --> 00:37:00,100
하지만, 정말 정신
과정은 종기의

772
00:37:00,100 --> 00:37:01,650
강의 계획서에서이 절에.

773
00:37:01,650 --> 00:37:03,670
정말 그냥 합리적이다.

774
00:37:03,670 --> 00:37:06,680
>> 그리고 우리는이 있다면 것을에 정교한하기
조금 더 언어,

775
00:37:06,680 --> 00:37:09,770
실현 모두의 본질
이 과정에 제출 작업

776
00:37:09,770 --> 00:37:10,954
자신의해야합니다.

777
00:37:10,954 --> 00:37:13,870
하지만 내 확실히있다
기회와 격려,

778
00:37:13,870 --> 00:37:17,300
에 의존와 교육적 가치
자신을 others--,하여 TFS는 CA에,

779
00:37:17,300 --> 00:37:20,760
클래스에서 조교 등,
지원, 혼자 친구하자

780
00:37:20,760 --> 00:37:23,547
룸메이트가 공부 한 자
전에 CS 및 프로그래밍.

781
00:37:23,547 --> 00:37:25,130
그리고 그에 대한 수당이있다.

782
00:37:25,130 --> 00:37:28,180
그리고 엄지 손가락의 일반적인 규칙
도움이 항아리 요청하는 경우,

783
00:37:28,180 --> 00:37:31,470
당신은 다른 사람에게 코드를 표시 할 수 있습니다,
하지만 당신은 그들의를 볼 수 있습니다.

784
00:37:31,470 --> 00:37:34,880
그래서 당신은 근무 시간에있을 경우에도,
또는 D 홀, 또는 다른 곳에서

785
00:37:34,880 --> 00:37:37,450
일부 종 세트 작업,
친구와 함께 작업하는

786
00:37:37,450 --> 00:37:40,160
상기 완전히 괜찮습니다
하루 작업의 끝

787
00:37:40,160 --> 00:37:43,034
궁극적으로 각에 속해야
당신의 각각, 그리고

788
00:37:43,034 --> 00:37:45,700
일부 공동 노력 수,
최종 프로젝트의 경우를 제외하고

789
00:37:45,700 --> 00:37:47,410
그것은 허용하고 권장합니다.

790
00:37:47,410 --> 00:37:49,830
>> 당신이 경우 실현
뭔가 고민

791
00:37:49,830 --> 00:37:52,520
당신의 친구는 발생
다음이 더 잘 될 당신,

792
00:37:52,520 --> 00:37:55,130
또는 당신보다 그 문제에 더 나은,
또는 더 멀리 앞서보다 조금,

793
00:37:55,130 --> 00:37:57,330
이 켜 완전히 합리적인
당신의 친구에는, 헤이 말

794
00:37:57,330 --> 00:38:00,480
여기에 내 코드를보고 줄래 않습니다,
내가 내 문제가 무엇인지 발견 돕는?

795
00:38:00,480 --> 00:38:03,760
그리고, 희망,의
교육학 값의 관심

796
00:38:03,760 --> 00:38:07,040
그 친구는 그냥 않습니다
아, 이렇게 말하는 것이 아니라

797
00:38:07,040 --> 00:38:09,917
당신은 무엇을 행에 누락
6, 뭐 그런?

798
00:38:09,917 --> 00:38:12,000
그러나 해결책은 아니다
당신 옆에있는 친구

799
00:38:12,000 --> 00:38:15,617
오, 음, 여기, 내가 당겨 보자, 대답
이 위로, 그리고 당신에게 내 솔루션을 보여줍니다.

800
00:38:15,617 --> 00:38:16,450
그래서 선이다.

801
00:38:16,450 --> 00:38:18,670
당신은 당신의 코드를 표시
다른 사람,하지만 당신은하지 않을 수 있습니다

802
00:38:18,670 --> 00:38:22,350
다른에 따라 그들의를 볼 수
과정의 강의에서 제약.

803
00:38:22,350 --> 00:38:24,760
>> 그래서 마음이 유지 않는다
후회 절 소위

804
00:38:24,760 --> 00:38:27,560
뿐만 아니라 과정의 강의에서,
당신은 어떤 행위를하는 경우 그

805
00:38:27,560 --> 00:38:30,476
합리적인 아니지만으로 가져
과정의 머리의 관심

806
00:38:30,476 --> 00:38:34,240
72 시간 내에 코스
지역의 제재를 부과 할 수

807
00:38:34,240 --> 00:38:37,380
불만족을 포함하거나
제출 된 작업에 실패 학년.

808
00:38:37,380 --> 00:38:41,410
그러나 과정은 참조하지 않습니다
추가 징계 조치에 대한 문제,

809
00:38:41,410 --> 00:38:43,010
반복 행위의 경우를 제외하고.

810
00:38:43,010 --> 00:38:46,632
즉, 당신이 경우에 어떤을
바보, 특히 늦은 밤, 결정

811
00:38:46,632 --> 00:38:49,340
그 다음 날 아침에 이틀
나중에, 당신은 일어나 실현,

812
00:38:49,340 --> 00:38:50,870
내가 무엇을 생각했다?

813
00:38:50,870 --> 00:38:53,890
당신은 출구를 가지고 CS50에서 할
이 문제를 해결하기위한

814
00:38:53,890 --> 00:38:57,170
그 그래서, 최대 소유 우리
중간 당신을 만나고 다룰 것이다

815
00:38:57,170 --> 00:39:01,500
즉, 둘 다 그 문제에서와
교육 및 당신을 위해 가치,

816
00:39:01,500 --> 00:39:04,200
하지만 어떤 방법으로 여전히 처벌.

817
00:39:04,200 --> 00:39:08,590
그리고 지금,이 가장자리를 촬영합니다.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO 재생]

819
00:39:10,570 --> 00:39:13,540
>> [음악 재생]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END 재생]

822
00:39:58,866 --> 00:40:00,490
데이비드 J. 마란 : 좋아, 우리는 다시 수 있습니다.

823
00:40:00,490 --> 00:40:03,680
그리고 지금 우리는 하나 봐
우리 실제 도메인 제

824
00:40:03,680 --> 00:40:08,720
CS50에서, 암호화의 예술,
전송 및 수신의 예술

825
00:40:08,720 --> 00:40:11,840
비밀 메시지 암호화
메시지 만약에 당신,

826
00:40:11,840 --> 00:40:17,060
당신이있는 경우에 그 만 해독 할 수 있습니다
발신자가 가지고있는 몇 가지 주요 성분

827
00:40:17,060 --> 00:40:18,030
게다가.

828
00:40:18,030 --> 00:40:22,120
우리가 할게요 그래서이 동기를 부여하기
A, 여기에이 일을보고

829
00:40:22,120 --> 00:40:26,750
이는 예이다
비밀 디코더 링이

830
00:40:26,750 --> 00:40:34,042
파악하기 위해 사용될 수있다
비밀 메시지가 실제로 무엇인지.

831
00:40:34,042 --> 00:40:35,750
사실, 뒤쪽에
초등학교에서의 하루,

832
00:40:35,750 --> 00:40:38,787
혹시에 비밀 메시지를 보낸 경우
어떤 친구 또는 클래스의 일부 호감,

833
00:40:38,787 --> 00:40:40,620
당신이 생각했을 수 있습니다
당신은 영리되고 있었다

834
00:40:40,620 --> 00:40:46,530
종이 변화의 당신의 조각에 의해,
같은 A B, 그리고 B C, 그리고 C D에,

835
00:40:46,530 --> 00:40:47,590
기타 등등.

836
00:40:47,590 --> 00:40:50,300
그러나 실제로 암호화 된
정보도

837
00:40:50,300 --> 00:40:53,300
조금 사소한 되었다면 아니었다
어려운 교사 실현하기 위해,

838
00:40:53,300 --> 00:40:55,675
물론, 당신은 단지 변경하는 경우
A와 C에 B는 B로,

839
00:40:55,675 --> 00:40:57,550
당신은 실제로 파악
메시지가 무엇이고,

840
00:40:57,550 --> 00:40:59,700
하지만 당신은 정보를 암호 처리에 있었다.

841
00:40:59,700 --> 00:41:03,420
>> 당신은 그 일을했다
단순히 많은 Ralphie처럼 여기

842
00:41:03,420 --> 00:41:07,934
재생 유명한 영화
거의 광고 nauseum 각각의 겨울.

843
00:41:07,934 --> 00:41:08,600
[VIDEO 재생]

844
00:41:08,600 --> 00:41:11,180
이 모든 것을 알고 -bE
랄프 파커는 이로써입니다

845
00:41:11,180 --> 00:41:14,070
리틀의 일원으로 임명
고아 애니 비밀 서클

846
00:41:14,070 --> 00:41:17,700
모든 명예를받을 권리가있다
및 혜택은 이에 발생.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, 리틀 고아 애니,
반대 서명 잉크, 피에르 앙드레.

848
00:41:24,340 --> 00:41:27,160
명예와 이익,
이미 아홉의 나이에.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [외침]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
- 어서.

853
00:41:34,250 --> 00:41:35,210
의 그것과에하자.

854
00:41:35,210 --> 00:41:39,530
나는 모든 재즈 필요하지 않습니다
밀수꾼과 해적에 대한.

855
00:41:39,530 --> 00:41:41,660
>> 에 대해 들어 봐요 내일 밤
결론 모험

856
00:41:41,660 --> 00:41:43,880
검은 해적선.

857
00:41:43,880 --> 00:41:46,650
지금, 그것은 시간이다
애니의 비밀 메시지

858
00:41:46,650 --> 00:41:49,840
비밀 서클의 당신 회원.

859
00:41:49,840 --> 00:41:53,570
, 아이, 회원 만 기억
애니의 비밀 서클의

860
00:41:53,570 --> 00:41:56,140
애니의 비밀 메시지를 디코딩 할 수있다.

861
00:41:56,140 --> 00:42:00,340
>> 기억, 애니 당신에 따라된다.

862
00:42:00,340 --> 00:42:02,880
B2에 핀을 설정합니다.

863
00:42:02,880 --> 00:42:05,230
여기서 메시지이다.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> - 난, 내 첫 번째 비밀 회의입니다.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre은 큰 음성 오늘 밤에 있었다.

868
00:42:15,780 --> 00:42:19,000
나는 오늘의 말할 수
메시지가 정말 중요했다.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, 즉 메시지의
애니 자신의.

870
00:42:22,694 --> 00:42:23,860
아무에게도 말하지 않는 기억하십시오.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 초 후에, 나는 단지에있어
집에 방 어디 아홉의 소년

873
00:42:32,930 --> 00:42:37,040
개인 정보 보호 및 디코딩에 앉아 있었다.

874
00:42:37,040 --> 00:42:39,730
아하, B!

875
00:42:39,730 --> 00:42:42,360
나는 다음, E. 갔다

876
00:42:42,360 --> 00:42:44,520
>> 첫 번째 단어가 될 것입니다.

877
00:42:44,520 --> 00:42:49,032
S, 지금 쉽게오고, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> 오, 나는 가야겠다, Ralphie를 어서!

879
00:42:51,733 --> 00:42:53,688
>> 오른쪽으로 오티스, 엄마!

880
00:42:53,688 --> 00:42:54,188
맙소사!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T는, O, 무엇을해야 이러시면해야?

883
00:43:04,060 --> 00:43:05,970
어린 고아가 무엇인지
애니 말하려고?

884
00:43:05,970 --> 00:43:07,264
무엇을해야?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, 앤디는에 도착했다
, 당신은 나와하시기 바랍니다 것입니다 가서?

886
00:43:09,634 --> 00:43:10,480
>> - 모든 권리, 엄마!

887
00:43:10,480 --> 00:43:12,880
금방 나올거야!

888
00:43:12,880 --> 00:43:14,550
>> - 난 가까이 지금지고 있었다.

889
00:43:14,550 --> 00:43:16,620
긴장은 끔찍했다.

890
00:43:16,620 --> 00:43:17,720
그것은 무엇입니까?

891
00:43:17,720 --> 00:43:20,170
행성의 운명
균형에 응답하지 않을 수 있습니다.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
앤디 돼 간다!

894
00:43:23,170 --> 00:43:26,890
>> 큰소리로 우는 위해 바로 나올 할께!

895
00:43:26,890 --> 00:43:32,680
>> 이 - 지하, 내 손가락은 내 마음을 날아
강철 함정이었다, 모든 구멍은 진동.

896
00:43:32,680 --> 00:43:37,198
그것은 그래, 그래, 그래, 거의 분명했다.

897
00:43:37,198 --> 00:43:43,091
>> 당신의 ovaltine 음료해야 -bE.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
싸구려 상업?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
개자식.

903
00:43:54,227 --> 00:43:54,810
[END 재생]

904
00:43:54,810 --> 00:43:57,390
데이비드 J. 마란 : OK, 그래서
그것은 매우 긴 길이었다

905
00:43:57,390 --> 00:44:00,660
암호화를 도입,
또한 ovaltine.

906
00:44:00,660 --> 00:44:04,470
사실,이 오래된 고라에서
여기에, 왜 ovaltine 너무 좋다?

907
00:44:04,470 --> 00:44:09,470
그것은 잘 익은 농축 추출입니다
보리 맥아, 순수한 크림 우유,

908
00:44:09,470 --> 00:44:14,360
특별히 함께, 코코아 준비
천연 인지질 및 비타민.

909
00:44:14,360 --> 00:44:18,240
그것은 추가로 강화된다
추가 비타민 B와 D, 냠.

910
00:44:18,240 --> 00:44:21,600
그리고 당신은 아직도 분명히 그것을 얻을 수
아마존에, 우리는 여기에 그랬던 것처럼.

911
00:44:21,600 --> 00:44:24,810
>> 그러나 동기는 여기에 있었다
특히, 암호화를 소개합니다

912
00:44:24,810 --> 00:44:28,340
알려진 암호화의 유형
비밀 키 암호로.

913
00:44:28,340 --> 00:44:34,284
상기 이름은 전체 건의
비밀 키 암호 시스템의 보안,

914
00:44:34,284 --> 00:44:36,200
, 방법론 만약에 당신
다만 스크램블링

915
00:44:36,200 --> 00:44:40,960
두 사람 정보는 것입니다
오직 송신자와 수신자 만

916
00:44:40,960 --> 00:44:46,980
비밀 key--에게 약간의 가치를 알고, 일부
비밀 문구, 일부 비밀 번호, 그

917
00:44:46,980 --> 00:44:50,660
모두 암호화에게 허용
정보를 해독.

918
00:44:50,660 --> 00:44:53,470
그리고 암호화, 정말,
다만 이번 주 0입니다.

919
00:44:53,470 --> 00:44:56,715
>> 그것은 입력을 거기에 문제의
영어로 실제 메시지 등

920
00:44:56,715 --> 00:44:59,340
또는 어떤 언어로 당신을
클래스에서 다른 사람에게 보내려면,

921
00:44:59,340 --> 00:45:00,580
또는 인터넷을 통해.

922
00:45:00,580 --> 00:45:03,840
것입니다 일부 출력은있다
스크램블 메시지가 될 당신을

923
00:45:03,840 --> 00:45:05,250
수신자가 수신 할 수 있습니다.

924
00:45:05,250 --> 00:45:07,405
그리고 경우에도 누군가
중간, 그것도 수신

925
00:45:07,405 --> 00:45:09,780
당신이 그들을 원하지 않는
반드시 암호를 해독 할 수 있습니다,

926
00:45:09,780 --> 00:45:12,840
이 내부에 있기 때문에
블랙 박스, 또는 알고리즘,

927
00:45:12,840 --> 00:45:17,650
어떤 메커니즘을 단계별로 몇 가지 단계입니다
그 입력을 복용에 대한 지침,

928
00:45:17,650 --> 00:45:20,710
상기로 변환
희망 안전한 방법으로 출력.

929
00:45:20,710 --> 00:45:23,640
>> 그리고, 사실,이 몇 가지
이 세상에서 어휘로 다음과 같습니다.

930
00:45:23,640 --> 00:45:26,100
일반 텍스트는 단어 A는
컴퓨터 과학자 것

931
00:45:26,100 --> 00:45:28,449
입력을 설명하는 데 사용
영어와 같은 메시지,

932
00:45:28,449 --> 00:45:31,240
또는 무엇이든 실제로 언어를
다른 사람에게 보내려고합니다.

933
00:45:31,240 --> 00:45:35,450
그리고 암호문은 스크램블입니다
암호화하거나, 암호화,

934
00:45:35,450 --> 00:45:36,520
그 버전입니다.

935
00:45:36,520 --> 00:45:38,750
>> 그러나 여기에 다른 성분이있다.

936
00:45:38,750 --> 00:45:43,200
다른 하나의 입력이있다
비밀 키 암호.

937
00:45:43,200 --> 00:45:45,200
그리고는 키 자체입니다,
이는 일반적이며

938
00:45:45,200 --> 00:45:48,930
우리가 볼 수 있습니다로, 숫자, 또는
문자 또는 단어, 어떤

939
00:45:48,930 --> 00:45:51,980
실제로되는 알고리즘은 기대한다.

940
00:45:51,980 --> 00:45:53,870
>> 그리고 당신은 어떻게 정보를 해독합니까?

941
00:45:53,870 --> 00:45:55,110
어떻게 당신은 그것을 해독합니까?

942
00:45:55,110 --> 00:45:57,950
글쎄, 당신은 단지 역
출력 및 입력한다.

943
00:45:57,950 --> 00:46:00,900
>> 즉, 사람이 한번
암호화 된 메시지를 수신하여

944
00:46:00,900 --> 00:46:03,740
그 또는 그녀는 단순히 보유
같은 키를 알 수 있습니다.

945
00:46:03,740 --> 00:46:05,700
그들은 암호문을 받았습니다.

946
00:46:05,700 --> 00:46:09,530
그리고 그 둘을 연결하여
크립토 시스템에 입력,

947
00:46:09,530 --> 00:46:14,260
알고리즘, 아웃이 블랙 박스,
원래 일반 텍스트를 제공해야합니다.

948
00:46:14,260 --> 00:46:17,830
그리고 그것은 매우 높은 수준이다
암호가 실제로 무엇인지보기

949
00:46:17,830 --> 00:46:18,590
모든 약.

950
00:46:18,590 --> 00:46:20,030
>> 그럼 거기에 도착 할 수 있습니다.

951
00:46:20,030 --> 00:46:22,700
의 지금 아래를 살펴 보자
뭔가의 후드

952
00:46:22,700 --> 00:46:26,000
부여를 위해 우리가 복용 한
지난 주, 그리고이 세션

953
00:46:26,000 --> 00:46:27,629
문자열을 here--.

954
00:46:27,629 --> 00:46:30,295
하루의 끝에 문자열
문자 단지 순서입니다.

955
00:46:30,295 --> 00:46:33,610
>> 그것은 안녕하세요 세계, 또는 수
안녕하세요 Zamyla, 또는 무엇이든.

956
00:46:33,610 --> 00:46:37,050
그러나 그것은 무엇을 의미 하는가
일련의 문자 수?

957
00:46:37,050 --> 00:46:41,520
사실, CS50 라이브러리 준다
우리 캐릭터라는 데이터 유형입니다.

958
00:46:41,520 --> 00:46:45,140
>> 하지만 실제로이
C. 문자열과 같은 것

959
00:46:45,140 --> 00:46:49,450
정말 그냥 순서입니다
문자, 캐릭터, 캐릭터

960
00:46:49,450 --> 00:46:52,180
문자는, 다시,에, 백업하기
다시 내부 백업, 백업하기

961
00:46:52,180 --> 00:46:54,650
컴퓨터의 메모리 또는 RAM의.

962
00:46:54,650 --> 00:46:58,940
그리고 우리는에 그 더 깊이 살펴 보겠습니다
앞으로 우리는 메모리 자체를 볼 때

963
00:46:58,940 --> 00:47:02,030
이용하고 및
관련된 위협.

964
00:47:02,030 --> 00:47:04,100
>> 그러나의 문자열 Zamyla을 생각해 보자.

965
00:47:04,100 --> 00:47:07,480
의, 그래서 그냥 이름
여기에 인간의, Zamyla,

966
00:47:07,480 --> 00:47:12,030
그의 순서입니다
자, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
그리고 지금의이 가정하자 그 Zamyla의 이름
컴퓨터 내에 저장되고

968
00:47:16,020 --> 00:47:16,880
프로그램.

969
00:47:16,880 --> 00:47:20,830
>> 음, 우리가해야 있음을 추론하기 위하여 서
그 문자를 볼 수 있습니다

970
00:47:20,830 --> 00:47:21,590
개별적으로.

971
00:47:21,590 --> 00:47:24,710
그래서 나는 조금을 그릴거야
여기 Zamyla의 이름 주위에 상자.

972
00:47:24,710 --> 00:47:31,580
그리고 C의 경우 때를 그
어쩌면 Zamyla--과 같은 문자열이

973
00:47:31,580 --> 00:47:34,940
그 문자열에서 돌아왔다
GET 문자열과 같은 기능,

974
00:47:34,940 --> 00:47:38,540
당신은 실제로 조작 할 수 있습니다
문자로 그 문자.

975
00:47:38,540 --> 00:47:42,070
>> 이제,이 대 밀접한
대화 손 때문에

976
00:47:42,070 --> 00:47:46,420
암호화에 당신은 변경하려는 경우
D에 대한 B, 그리고 B C, 그리고 C,

977
00:47:46,420 --> 00:47:49,650
등, 당신은 할 수 있어야합니다
개별 문자를보고

978
00:47:49,650 --> 00:47:50,190
문자열입니다.

979
00:47:50,190 --> 00:47:52,695
사용자가 변경할 수 있어야
뭔가는 A에 Z

980
00:47:52,695 --> 00:47:55,280
에 뭔가의 M에
다른 등 뭔가.

981
00:47:55,280 --> 00:47:58,000
그래서 우리는 방법이 필요합니다,
프로그래밍, 그래서

982
00:47:58,000 --> 00:48:03,020
C에서, 말을하면 변경할 수 있도록
및 개별 문자 본다.

983
00:48:03,020 --> 00:48:05,690
다음과 같이 우리는이 작업을 수행 할 수 있습니다.

984
00:48:05,690 --> 00:48:08,340
>> 나를 다시 CS50의 IDE에 머리를 가자.

985
00:48:08,340 --> 00:48:11,130
그리고 내가 앞서 가자
새로운 파일을 생성

986
00:48:11,130 --> 00:48:16,134
나는이 시간 string0를 호출거야,
우리의 최초의 예를 들어, C 점을 찍는다.

987
00:48:16,134 --> 00:48:18,300
그리고 앞서 갈거야
다음과 같이 그것을 채찍.

988
00:48:18,300 --> 00:48:22,870
>> 그래서 CS50.h을 포함하고,
다음 표준 io.h를 포함,

989
00:48:22,870 --> 00:48:25,990
어느 나는 거의 항상 갈거야
적어도, 내 프로그램에서 사용하고있을

990
00:48:25,990 --> 00:48:26,780
처음에.

991
00:48:26,780 --> 00:48:32,180
주요 무효를 int로하고 여기에 난
문자열을하기 위하여려고하는 문자열을 얻을 가져옵니다.

992
00:48:32,180 --> 00:48:35,260
그리고 내가 갈거야
가서 이렇게.

993
00:48:35,260 --> 00:48:37,460
나는 앞서 가고 싶어
그리고, 전성 검사로,

994
00:48:37,460 --> 00:48:43,607
그냥 말, 안녕하세요, 퍼센트의,
세미콜론은 문자열 0을합니다.

995
00:48:43,607 --> 00:48:44,690
어 오, 내가 여기에 무슨 짓을 한거야?

996
00:48:44,690 --> 00:48:45,930
아, 나는 그것을 연결하지 않았다.

997
00:48:45,930 --> 00:48:48,120
그래서 교훈은, 배운
의도적이 아니었다.

998
00:48:48,120 --> 00:48:52,480
>> 그래서 오류, 더 퍼센트
데이터 인수보다 전환.

999
00:48:52,480 --> 00:48:54,940
그리고 이것은에, 어디
라인 전하는 바에 좋아, 그럼 내가 가지고,

1000
00:48:54,940 --> 00:48:56,690
인용을 끝내 인용, 그건
내 문자열의 printf합니다.

1001
00:48:56,690 --> 00:48:58,151
나는 퍼센트 기호를 가지고있다.

1002
00:48:58,151 --> 00:48:59,650
하지만 두 번째 인수를 누락하고 있습니다.

1003
00:48:59,650 --> 00:49:03,190
>> 나는 쉼표들, 실종 해요있는
나는 앞의 예에있는 않았다.

1004
00:49:03,190 --> 00:49:06,650
그래서 좋은 기회가 해결합니다
또 하나의 실수, 실수.

1005
00:49:06,650 --> 00:49:09,950
그리고 지금 저를 실행하자
Zamyla에서 string0을 입력합니다.

1006
00:49:09,950 --> 00:49:10,970
Zamyla 안녕하세요, OK.

1007
00:49:10,970 --> 00:49:14,144
>> 그래서 우리는 프로그램의이 종류를 실행했습니다
이제 몇 가지 다른 시간.

1008
00:49:14,144 --> 00:49:16,310
그러나의 뭔가 a를하자
이 때 다른 작은.

1009
00:49:16,310 --> 00:49:19,450
대신 Zamyla의 인쇄의
printf와 함께 밖으로 전체 이름,

1010
00:49:19,450 --> 00:49:21,350
의 문자에 의해 그것을 문자를 할 수 있습니다.

1011
00:49:21,350 --> 00:49:22,700
>> 나는 루프를 사용하겠습니다.

1012
00:49:22,700 --> 00:49:26,160
그리고 나는 나 자신을 줄거야
카운트 변수는, 내가 불렀다.

1013
00:49:26,160 --> 00:49:33,530
그리고 나는 그렇게 반복하는 유지하는거야
난 (S)의 길이보다 짧은만큼.

1014
00:49:33,530 --> 00:49:35,930
>> 그것은 밝혀, 우리는하지 않았다
이 마지막 시간을,

1015
00:49:35,930 --> 00:49:39,100
그 C는 함께 제공
함수는 스털링을했다.

1016
00:49:39,100 --> 00:49:42,690
위로 하루에, 그리고 일반적으로
정지 기능을 구현할 때

1017
00:49:42,690 --> 00:49:45,405
인간은 종종 매우 선택합니다
소리의 간결한 이름 종류

1018
00:49:45,405 --> 00:49:48,280
당신이 비록, 원하는 등
몇 모음 또는 문자 A가 없습니다.

1019
00:49:48,280 --> 00:49:50,660
따라서 스털링 인
함수의 이름이

1020
00:49:50,660 --> 00:49:53,880
사이의 인수를
문자열이어야한다 괄호.

1021
00:49:53,880 --> 00:49:56,910
그리고 그것은 단지 정수를 반환,
그 문자열의 길이.

1022
00:49:56,910 --> 00:50:00,580
>> 라인 7 루프이 그래서 것입니다
내가 0 같다에서 계산을 시작합니다.

1023
00:50:00,580 --> 00:50:02,530
그것은 증가 것
각 반복에 난

1024
00:50:02,530 --> 00:50:04,350
1, 우리는 몇 번 해 봤는데있다.

1025
00:50:04,350 --> 00:50:06,780
그러나 그것은 단지 할 것
포인트까지이 최대

1026
00:50:06,780 --> 00:50:09,660
나는 길이 인 경우
문자열 자체의.

1027
00:50:09,660 --> 00:50:14,520
>> 그래서 이것은 궁극적으로하는 방법
문자 반복

1028
00:50:14,520 --> 00:50:17,430
문자열에 그대로 따른다.

1029
00:50:17,430 --> 00:50:20,670
나는하지 인쇄 할거야
전체 문자열하지만 퍼센트 다,

1030
00:50:20,670 --> 00:50:22,860
단일 문자
새 행 하였다.

1031
00:50:22,860 --> 00:50:24,880
그리고 내가 갈거야
가서, 내가 필요

1032
00:50:24,880 --> 00:50:29,080
나는 인쇄 할 말을
S의 i 번째 문자.

1033
00:50:29,080 --> 00:50:33,450
>> 내가 나타내는 변수 있다면
문자열의 인덱스

1034
00:50:33,450 --> 00:50:37,230
당신은 거기에, 나는 할 수 있어야된다
나에게 S의 i 번째 문자를주고 말한다.

1035
00:50:37,230 --> 00:50:40,390
C는하기의 방식이있다
대괄호이.

1036
00:50:40,390 --> 00:50:43,679
당신은 단순히 이름을 말
이 경우 s의 문자열.

1037
00:50:43,679 --> 00:50:46,970
그럼 당신은 대괄호를 사용
일반적으로 당신의 반환 또는 Enter 위

1038
00:50:46,970 --> 00:50:48,110
키보드의 키를 누릅니다.

1039
00:50:48,110 --> 00:50:52,410
그리고 당신은의 인덱스를 넣어
인쇄 할 문자.

1040
00:50:52,410 --> 00:50:55,960
따라서 인덱스는 될 것입니다
number-- 0 또는 1 또는 2 또는 3 또는 도트

1041
00:50:55,960 --> 00:50:57,590
점은, 다른 수를 점.

1042
00:50:57,590 --> 00:51:00,920
>> 그리고 우리는거야 있는지 확인
오른쪽 번호를 수 I 때문에

1043
00:51:00,920 --> 00:51:02,360
0 카운트 시작합니다.

1044
00:51:02,360 --> 00:51:07,020
그리고 기본적으로, 첫 번째 문자
문자열 컨벤션 0입니다.

1045
00:51:07,020 --> 00:51:09,230
그리고 두 번째 문자는 브래킷 1입니다.

1046
00:51:09,230 --> 00:51:11,120
그리고 세 번째 문자는 브래킷 2입니다.

1047
00:51:11,120 --> 00:51:13,630
그리고 당신도 가고 싶지 않아
지금까지, 그러나 우리는 우리가있어하지 않기 때문에

1048
00:51:13,630 --> 00:51:17,780
만 때까지를 증가 예정
문자열의 길이가 같다.

1049
00:51:17,780 --> 00:51:20,210
그리고 어느 시점에서,
루프이 중지됩니다.

1050
00:51:20,210 --> 00:51:25,550
>> 그래서 내가 가서이를 저장할 수
프로그램 및 실행 문자열 0을합니다.

1051
00:51:25,550 --> 00:51:28,400
하지만 망쳐.

1052
00:51:28,400 --> 00:51:35,390
암시 라이브러리 함수를 선언
유형 등으로 스털링 지금 such--,

1053
00:51:35,390 --> 00:51:36,430
이 익숙한 소리.

1054
00:51:36,430 --> 00:51:37,440
그러나는 printf 아니에요.

1055
00:51:37,440 --> 00:51:38,540
그리고 문자열을 얻을 아​​니에요.

1056
00:51:38,540 --> 00:51:40,480
>> 나는에 나사를하지 않았다
동일한 방법이 시간.

1057
00:51:40,480 --> 00:51:45,100
하지만 여기까지 조금을 알
또한, 상기 헤더 string.h를 포함

1058
00:51:45,100 --> 00:51:47,210
명시 적으로 제공
스털링에 대한 선언.

1059
00:51:47,210 --> 00:51:48,820
그래서 실제로 거기에 단서가있다.

1060
00:51:48,820 --> 00:51:51,670
>> 그리고 사실이 밝혀
다른 헤더 파일이있다

1061
00:51:51,670 --> 00:51:53,970
우리는 사용되지으니
클래스에 아직, 그것은하지만입니다

1062
00:51:53,970 --> 00:51:56,480
사용할 수있는 중
당신에게, string.h를했다.

1063
00:51:56,480 --> 00:52:00,930
그리고 그 파일 string.h에
스털링 선언이다.

1064
00:52:00,930 --> 00:52:05,220
그래서 내가 가서 보자
문자열을,이 저장

1065
00:52:05,220 --> 00:52:08,040
0-- 좋은, 아니 오류 메시지가이 시간.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla하고,
나는, Enter 키를 누르려고 해요

1067
00:52:12,290 --> 00:52:16,710
하는 점에는 getString는 것입니다
문자열을 반환,의에 넣어.

1068
00:52:16,710 --> 00:52:21,890
루프 반복하는 것입니다 그
한 번에 하나의 S의 문자를 통해,

1069
00:52:21,890 --> 00:52:28,420
하기 때문에, 그들에게 한 줄에 하나씩 인쇄
나는 끝이 백 슬래시 n을했다.

1070
00:52:28,420 --> 00:52:34,530
그래서 나는 백 슬래시를 생략 할 수있다
N, 다음 그냥 모든 Zamyla를 인쇄

1071
00:52:34,530 --> 00:52:37,460
같은 줄에,
효율적으로 재 구현

1072
00:52:37,460 --> 00:52:38,999
모두 유용하지 않습니다 printf와.

1073
00:52:38,999 --> 00:52:40,540
그러나이 경우, 나는 그것을하지했습니다.

1074
00:52:40,540 --> 00:52:43,610
사실 하나를 인쇄했습니다
한 번에 문자 한 줄에 하나씩,

1075
00:52:43,610 --> 00:52:45,400
그래서 우리는 실제로 효과를 볼 수있다.

1076
00:52:45,400 --> 00:52:46,900
>> 그러나 나는 여기서 한 가지주의해야한다.

1077
00:52:46,900 --> 00:52:48,930
그리고 우리는 다시 올 것이다
미래의 주에서이.

1078
00:52:48,930 --> 00:52:52,650
그것은이 밝혀
코드는 잠재적 버그입니다.

1079
00:52:52,650 --> 00:52:56,560
>> 그것은 그 GET 문자열을 밝혀
삶의 일부 다른 기능

1080
00:52:56,560 --> 00:53:00,280
반드시 항상하지 않습니다
당신이 기대하는지 돌아갑니다.

1081
00:53:00,280 --> 00:53:03,010
우리는 지난 시간 알고
얻을이이 시간

1082
00:53:03,010 --> 00:53:04,960
문자열은 문자열을 반환 할 예정이다.

1083
00:53:04,960 --> 00:53:09,900
그러나 이러한 아웃 사용자 유형의 경우
긴 단어, 또는 단락, 또는 에세이

1084
00:53:09,900 --> 00:53:13,010
충분하지가 있음
컴퓨터의 메모리가 적합합니다.

1085
00:53:13,010 --> 00:53:15,410
>> 마찬가지로, 무슨 일이 가면
후드 아래에 잘못?

1086
00:53:15,410 --> 00:53:18,400
그것은 자주 발생하지 않을 수 있습니다
그러나 한번 일어날 수

1087
00:53:18,400 --> 00:53:21,520
한 동안 매우 드물게.

1088
00:53:21,520 --> 00:53:25,460
그리고 그것은 그 GET 문자열을 밝혀
과 같은 기능을 반드시 수행

1089
00:53:25,460 --> 00:53:26,380
항상 문자열을 반환합니다.

1090
00:53:26,380 --> 00:53:30,680
그들은 일부 오류 값을 반환 할 수 있습니다,
일부 감시 값 때문에, 말하자면

1091
00:53:30,680 --> 00:53:32,612
그는 것을 나타냅니다
뭔가 잘못왔다.

1092
00:53:32,612 --> 00:53:35,320
그리고 당신은 단지에서 이것을 알 것
이제 클래스에서 배운 데,

1093
00:53:35,320 --> 00:53:37,700
또는 좀 더 문서를 읽은.

1094
00:53:37,700 --> 00:53:43,120
그것은 그 GET 문자열을 밝혀
널 (null)라는 값을 반환 할 수 있습니다.

1095
00:53:43,120 --> 00:53:46,220
널은 우리가 거​​ 특수 값입니다
미래의 주에 되돌아 온다.

1096
00:53:46,220 --> 00:53:50,420
하지만 지금은, 그냥 내가 원하는 경우 알고
전진 정말 적절한 될 수 있습니다

1097
00:53:50,420 --> 00:53:52,650
GET 문자열을 사용하여, I
그냥 전화 안,

1098
00:53:52,650 --> 00:53:56,870
그리고 맹목적으로 반환 값을 사용하여,
이 문자열 있다는 신뢰.

1099
00:53:56,870 --> 00:53:59,420
>> 내가 먼저 말을해야
헤이 만, 잠깐

1100
00:53:59,420 --> 00:54:03,380
s는 동일하지 않으면 계속
널 여기서 널 다시,

1101
00:54:03,380 --> 00:54:04,660
그냥 몇 가지 특별한 값입니다.

1102
00:54:04,660 --> 00:54:07,770
그리고 그것은 유일한 특수 값입니다 당신
GET 문자열을 걱정해야합니다.

1103
00:54:07,770 --> 00:54:10,900
문자열 중 하나를 것입니다 오기
문자열 또는 null을 반환합니다.

1104
00:54:10,900 --> 00:54:17,219
>> 그리고이 느낌표 등호
당신은 아마 수학 클래스에서 알 수 있습니다

1105
00:54:17,219 --> 00:54:20,510
당신과 등호를 그릴 수 있음
그것을 통해 선이 동일하지 나타냅니다.

1106
00:54:20,510 --> 00:54:23,135
즉, 일반적으로 성격이 아니다
당신은 당신의 키보드에서 입력 할 수 있습니다.

1107
00:54:23,135 --> 00:54:26,480
그리고 대부분의 프로그래밍 언어에서,
당신이 동일하지 않은 말을 할 때,

1108
00:54:26,480 --> 00:54:29,160
당신은 느낌표를 사용,
그렇지 않으면 탕으로 알려져 있습니다.

1109
00:54:29,160 --> 00:54:33,180
그래서 당신은 강타가, 동일 말을하는
하지 논리적으로 같음을 의미합니다.

1110
00:54:33,180 --> 00:54:38,060
그것은 더 큰 거기 그냥처럼
이상, 또는 동일하거나보다

1111
00:54:38,060 --> 00:54:41,270
같거나 키보드의 키 입력하기
즉, 하나의 심볼에서 모든 작업을 수행합니다.

1112
00:54:41,270 --> 00:54:44,020
그래서 그 이유는, 과거의 예에서,
당신은 오픈 브래킷을 한 후

1113
00:54:44,020 --> 00:54:48,670
등호는 순서대로해야 할 일
보다 크거나보다 작 말한다.

1114
00:54:48,670 --> 00:54:49,910
>> 그래서 테이크 아웃은 여기에 무엇입니까?

1115
00:54:49,910 --> 00:54:53,880
이것은 현재의 방법으로 단순히
이 구문을 도입,이 기능,

1116
00:54:53,880 --> 00:54:57,390
개별 반복
문자열의 문자.

1117
00:54:57,390 --> 00:55:00,260
그리고 바로 그 광장 등
브래킷은, 당신이 그들을 얻을 수 있습니다

1118
00:55:00,260 --> 00:55:03,790
로 그 대괄호를 고려
종류의이 기본 암시

1119
00:55:03,790 --> 00:55:06,040
디자인, 이에 모든
문자열의 내부 문자

1120
00:55:06,040 --> 00:55:10,180
가지 아래 어딘가에 박스입니다
컴퓨터의 메모리에 후드.

1121
00:55:10,180 --> 00:55:12,340
>> 그러나 이제이의 변형을 만들 수 있습니다.

1122
00:55:12,340 --> 00:55:14,880
그것은이 밝혀
프로그램은 올바른 것입니다.

1123
00:55:14,880 --> 00:55:18,810
CS50의 축 당 그래서 평가
코드는이 지금은 올바른 것입니다.

1124
00:55:18,810 --> 00:55:22,959
특히 지금은 검사거야 것을
null의 경우,이 프로그램이 충돌해서는 안됩니다.

1125
00:55:22,959 --> 00:55:24,500
그리고 난 그냥 경험으로부터 알고있다.

1126
00:55:24,500 --> 00:55:28,040
그러나 아무것도가 없습니다
우리가 정말 잘못 여기에 갈 수 있습니다.

1127
00:55:28,040 --> 00:55:31,860
그러나 그것은 매우 잘 설계된 아니에요
때문에하는 것은 이제 기본으로 돌아 가자.

1128
00:55:31,860 --> 00:55:34,450
>> 첫째, principles--
for 루프는 무엇을합니까?

1129
00:55:34,450 --> 00:55:36,290
루프에 대한 세 가지 작업을 수행합니다.

1130
00:55:36,290 --> 00:55:39,340
그것은 몇 가지를 초기화
값, 당신이 그것을 요​​구하는 경우.

1131
00:55:39,340 --> 00:55:41,770
그것은 상태를 확인합니다.

1132
00:55:41,770 --> 00:55:45,380
그리고 그 후 각
반복, 각주기 후,

1133
00:55:45,380 --> 00:55:49,330
그것은 일부를 증가
여기에 값 또는 값.

1134
00:55:49,330 --> 00:55:50,600
>> 그래서 무엇을 의미합니까?

1135
00:55:50,600 --> 00:55:52,940
우리는 i가 0에 초기화합니다.

1136
00:55:52,940 --> 00:55:58,610
우리는 확인하고 있는지 확인 난 미만
Z-A-M-Y-L-A 인 (S)의 길이,

1137
00:55:58,610 --> 00:55:59,900
그래서 미만 6이다.

1138
00:55:59,900 --> 00:56:02,590
그리고, 참으로, 0 미만 6있다.

1139
00:56:02,590 --> 00:56:05,580
>> 우리는 Zamyla의 이름에서 Z를 인쇄 할 수 있습니다.

1140
00:56:05,580 --> 00:56:08,080
그 다음 우리는 0에서 1로 전을 증가.

1141
00:56:08,080 --> 00:56:11,290
우리는 그 다음 1 이하, 확인
(S)의 길이보다?

1142
00:56:11,290 --> 00:56:13,270
(S)의 길이는 6이다.

1143
00:56:13,270 --> 00:56:13,950
네, 그렇습니다.

1144
00:56:13,950 --> 00:56:16,880
>> 그래서 우리는 Zamyla의 이름, ZA에 인쇄 할 수 있습니다.

1145
00:56:16,880 --> 00:56:20,090
우리는 2, 1, 0에서 난을 증가.

1146
00:56:20,090 --> 00:56:23,720
우리는 그 다음 2보다 작 확인
Zamyla의 이름의 길이.

1147
00:56:23,720 --> 00:56:25,380
6- 그래서 2 6 미만이다.

1148
00:56:25,380 --> 00:56:30,460
네, 그럼 이제 M을 인쇄 할 수
Zamyla의 이름, 세 번째 문자.

1149
00:56:30,460 --> 00:56:34,110
>> 열쇠는 여기에 각 해당 인
이야기의 반복, 나는 확인하고있어,

1150
00:56:34,110 --> 00:56:37,810
내가 Zamyla의 길이보다 작은?

1151
00:56:37,810 --> 00:56:40,350
그러나 캐치이다
스털링은 등록하지 않습니다.

1152
00:56:40,350 --> 00:56:43,100
프로그래밍 한 분들
자바 나 다른 언어로 이전

1153
00:56:43,100 --> 00:56:46,310
문자열 인의 길이를 알 수 있습니다
속성은, 그냥은 값을 읽습니다.

1154
00:56:46,310 --> 00:56:50,220
>> 이 경우 C에서,이이면
문자 그대로 함수

1155
00:56:50,220 --> 00:56:53,520
개수를 세고
때마다 Zamyla의 문자

1156
00:56:53,520 --> 00:56:54,740
우리는 그 함수를 호출합니다.

1157
00:56:54,740 --> 00:56:58,500
마다가 사용하는 컴퓨터를 요청할
스털링, 그것은, Zamyla에 모습을 복용

1158
00:56:58,500 --> 00:57:01,960
하고 말하는 Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
그리고 6을 반환합니다.

1160
00:57:02,962 --> 00:57:04,920
당신이 전화를 다음 번에
루프 그 안에 그것은,

1161
00:57:04,920 --> 00:57:08,610
Zamyla 볼 것
다시, Z-A-M-Y-L-A, (6)을 말한다.

1162
00:57:08,610 --> 00:57:10,320
그리고 6을 반환 할 것입니다.

1163
00:57:10,320 --> 00:57:12,980
그래서이 디자인에 대한 바보 무엇입니까?

1164
00:57:12,980 --> 00:57:17,700
>> 왜 내 코드가 아닌 5 개 만점에 5 점입니다
지금 디자인, 말하자면?

1165
00:57:17,700 --> 00:57:20,600
글쎄, 내가 부탁 해요
불필요하게 질문입니다.

1166
00:57:20,600 --> 00:57:23,030
I가 필요한 것보다 내가 더 많은 일을하고 있어요.

1167
00:57:23,030 --> 00:57:25,370
>> 그럼에도 불구하고
대답은 내가, 정확

1168
00:57:25,370 --> 00:57:29,560
컴퓨터를 묻는 것입니다
다시 Zamyla의 길이,

1169
00:57:29,560 --> 00:57:31,380
그리고 또 다시, 다시?

1170
00:57:31,380 --> 00:57:33,980
그리고 그 대답은
결코 변경하려고합니다.

1171
00:57:33,980 --> 00:57:35,900
항상 6 될 것입니다.

1172
00:57:35,900 --> 00:57:39,730
>> 이보다 그래서 더 나은 솔루션
이 다음 버전이 될 것이다.

1173
00:57:39,730 --> 00:57:43,390
내가 앞서 가자와에 넣어
string1.c라는 별도의 파일,

1174
00:57:43,390 --> 00:57:44,990
그냥 분리 유지합니다.

1175
00:57:44,990 --> 00:57:47,260
그리고 그것은의에서 밝혀
루프, 당신은 실제로 수

1176
00:57:47,260 --> 00:57:50,210
한 번에 여러 변수를 선언합니다.

1177
00:57:50,210 --> 00:57:53,460
>> 그래서 난을 유지하고 0으로 설정하겠습니다.

1178
00:57:53,460 --> 00:57:56,190
그러나 나는 또한 갈거야
쉼표를 추가하고, 말,

1179
00:57:56,190 --> 00:58:01,050
나에게 그 N이라는 변수를 제공
값의의 문자열 길이와 같습니다.

1180
00:58:01,050 --> 00:58:09,410
그리고 지금, 내 상태를 확인하십시오
너무 오래 전 n보다 작은있다.

1181
00:58:09,410 --> 00:58:14,140
>> 따라서 이러한 방식으로, 논리는
하루의 끝에서 동일합니다.

1182
00:58:14,140 --> 00:58:18,280
그러나 나는 기억하고있다
이 경우에는 값 6.

1183
00:58:18,280 --> 00:58:19,780
Zamyla 이름의 길이는 무엇입니까?

1184
00:58:19,780 --> 00:58:20,860
그리고 N에서 퍼팅하고있다.

1185
00:58:20,860 --> 00:58:23,050
>> 그리고 난 아직 확인 해요
조건마다.

1186
00:58:23,050 --> 00:58:24,300
0 6 이하인가?

1187
00:58:24,300 --> 00:58:25,600
1 6 이하인가?

1188
00:58:25,600 --> 00:58:28,600
등이 6 미만 및인가?

1189
00:58:28,600 --> 00:58:31,914
>> 하지만 컴퓨터를 요구하고 있지 않다
다시, 다시, 무슨 일이야

1190
00:58:31,914 --> 00:58:33,080
Zamyla 이름의 길이?

1191
00:58:33,080 --> 00:58:34,320
Zamyla 이름의 길이는 얼마입니까?

1192
00:58:34,320 --> 00:58:35,986
이 Zamyla 이름의 길이는 얼마입니까?

1193
00:58:35,986 --> 00:58:40,440
말 그대로 기억하고있어 그 제
단지이 두 번째 변수 (n)에 대한 답변.

1194
00:58:40,440 --> 00:58:45,280
그래서 지금뿐만 아니라 것
올바른뿐만 아니라, 잘 설계된.

1195
00:58:45,280 --> 00:58:46,670
>> 자, 어떤 스타일은 어떻습니까?

1196
00:58:46,670 --> 00:58:48,866
내 변수를 명명 한
꽤 잘, 나는 말할 것입니다.

1197
00:58:48,866 --> 00:58:50,240
그들은 지금 매우 간결입니다.

1198
00:58:50,240 --> 00:58:52,090
그리고 완전히 괜찮아요.

1199
00:58:52,090 --> 00:58:55,120
>> 당신은 단지 하나가있는 경우
프로그램에서 문자열,

1200
00:58:55,120 --> 00:58:56,860
당신은뿐만 아니라 그것을 문자열 s의 호출 할 수 있습니다.

1201
00:58:56,860 --> 00:58:59,370
당신은 단지 하나의 변수가있는 경우
프로그램의 카운트,

1202
00:58:59,370 --> 00:59:00,710
당신은뿐만 아니라 그것을 내가 전화 할 수 있습니다.

1203
00:59:00,710 --> 00:59:03,500
만약 길이를 갖는 경우, N
뿐만 아니라 슈퍼 일반적입니다.

1204
00:59:03,500 --> 00:59:05,800
하지만 내 코드의 댓글을 달았하지 않았습니다.

1205
00:59:05,800 --> 00:59:09,200
>> 나는 reader--을 통보하지했습니다
그건 내 TF, 또는 TA 여부,

1206
00:59:09,200 --> 00:59:12,460
아니면 그냥 가정 무엇 colleague--
에이 프로그램에서 진행된다.

1207
00:59:12,460 --> 00:59:15,760
그래서 좋은 스타일을 얻으려면,
내가하고 싶은 것이 무엇

1208
00:59:15,760 --> 00:59:24,580
이 항아리 무언가가있다
같은 입력을 사용자에게 요청합니다.

1209
00:59:24,580 --> 00:59:26,670
그리고 나는 다시 수
방법이 임의의 수.

1210
00:59:26,670 --> 00:59:35,630
>> 확인 GET을 s-- 확인
문자열은 문자열을 반환했습니다.

1211
00:59:35,630 --> 00:59:40,280
그리고 here--에서 이것은 아마도
가장 중요한 comment-- 반복 처리

1212
00:59:40,280 --> 00:59:44,450
한 번에의 하나의 문자를 통해.

1213
00:59:44,450 --> 00:59:47,060
그리고 나는 어떤을 사용할 수 있습니다
영어의 선택

1214
00:59:47,060 --> 00:59:49,650
여기에서 설명하는 각
이러한 코드 청크.

1215
00:59:49,650 --> 00:59:52,740
>> 내가 넣어하지 않았 음을 주목하라
코드의 모든 라인에 대한 의견,

1216
00:59:52,740 --> 00:59:55,690
정말 흥미에
사람, 사람이

1217
00:59:55,690 --> 00:59:59,460
어떤 의미가 그 나는 수도
사람에게 매우 명확하게 할

1218
00:59:59,460 --> 01:00:00,460
코드를 읽고.

1219
01:00:00,460 --> 01:00:02,920
왜 당신은 얻을 호출
문자열 입력을 사용자에게?

1220
01:00:02,920 --> 01:00:05,450
심지어 하나 반드시 없다
모든 것을 설명.

1221
01:00:05,450 --> 01:00:09,340
하지만, 이야기를하는 데 도움이 있기 때문에
이야기의 두 번째 줄이 있는지 확인한다

1222
01:00:09,340 --> 01:00:10,740
얻을 문자열은 문자열을 반환했습니다.

1223
01:00:10,740 --> 01:00:14,260
>> 그리고 이야기의 세 번째 줄입니다
의 하나의 문자 반복

1224
01:00:14,260 --> 01:00:15,380
한번에.

1225
01:00:15,380 --> 01:00:17,920
그리고 지금은 그냥 좋은 측정을위한,
내가 가서 추가 할거야

1226
01:00:17,920 --> 01:00:24,560
한 번 더 설명이 단지
의에 인쇄 i 번째 문자는 말한다.

1227
01:00:24,560 --> 01:00:26,520
자, 내가 수행 한
하루의 끝에서?

1228
01:00:26,520 --> 01:00:29,190
>> 나는 약간의 영어 추가
댓글의 형태로 단어.

1229
01:00:29,190 --> 01:00:32,700
슬래시 슬래시 기호 야, 의미,
이 인간을위한 컴퓨터,

1230
01:00:32,700 --> 01:00:33,820
아니 당신을 위해, 컴퓨터.

1231
01:00:33,820 --> 01:00:35,119
그래서 그들은 논리적으로 무시하고있다.

1232
01:00:35,119 --> 01:00:35,910
그들은 단지 거기.

1233
01:00:35,910 --> 01:00:39,830
>> 그리고, 참으로, CS50 IDE는 그들을 보여줍니다
회색 유용하지만, 키가 아닌 것으로

1234
01:00:39,830 --> 01:00:41,000
프로그램에.

1235
01:00:41,000 --> 01:00:42,570
당신은 지금 무엇을 할 수 있는지 알 수 있습니다.

1236
01:00:42,570 --> 01:00:44,950
당신은 C를 알고 있는지 여부
프로그램 또는 아니라,

1237
01:00:44,950 --> 01:00:47,722
그냥이 다시 설 수
프로그램은과 주석을 탈지.

1238
01:00:47,722 --> 01:00:50,180
확인, 입력을 사용자에게 문의
문자열이 문자열을 반환받을

1239
01:00:50,180 --> 01:00:53,009
S의 문자 반복
한 번에 하나의 문자를 인쇄

1240
01:00:53,009 --> 01:00:55,550
i 번째 문자 s-- 당신은하지 않습니다
심지어 코드를보고있다

1241
01:00:55,550 --> 01:00:57,270
이 프로그램이 무엇을하는지 이해합니다.

1242
01:00:57,270 --> 01:01:00,280
그리고, 더 나은 아직, 당신 자신을 보면
한 두 주에서이 프로그램에서,

1243
01:01:00,280 --> 01:01:02,280
또는 한 달, 또는 년,
당신도이 없습니다

1244
01:01:02,280 --> 01:01:04,420
코드를 응시하는,
기억하려고,

1245
01:01:04,420 --> 01:01:06,630
내가이 코드와 함께 일을하려고했다?

1246
01:01:06,630 --> 01:01:07,770
>> 당신은 자신을 말 했어요.

1247
01:01:07,770 --> 01:01:11,660
당신은 자신을 위해 그것을 설명했습니다,
일부 동료, 또는 TA, 또는 TF 나.

1248
01:01:11,660 --> 01:01:14,860
그리고이 이제 것
올바른, 디자인 좋은,

1249
01:01:14,860 --> 01:01:18,210
궁극적으로 스타일 좋은뿐만 아니라.

1250
01:01:18,210 --> 01:01:19,990
그래서 명심 않습니다.

1251
01:01:19,990 --> 01:01:22,200
>> 그래서 다른 하나는있다
일이 여기 할거야

1252
01:01:22,200 --> 01:01:28,240
즉, 지금 정확히 무엇을 밝힐 수
후드 아래에 계속.

1253
01:01:28,240 --> 01:01:30,390
따라서이 기능이있다
C 및 기타 언어,

1254
01:01:30,390 --> 01:01:33,010
라는 타입 캐스팅
그 암시

1255
01:01:33,010 --> 01:01:37,250
또는 명시 적으로 변환 할 수 있습니다
다른 하나의 데이터 유형에서.

1256
01:01:37,250 --> 01:01:39,800
우리는 그렇게 처리했습니다
문자열까지 오늘.

1257
01:01:39,800 --> 01:01:41,250
>> 그리고 문자열은 문자입니다.

1258
01:01:41,250 --> 01:01:44,910
그러나 주부터 리콜
0, 문자는 무엇인가?

1259
01:01:44,910 --> 01:01:49,334
문자는 추상이다
numbers-- 진수의 상단에,

1260
01:01:49,334 --> 01:01:52,500
그리고 진수는 정말로 단지입니다
이진수 위에 추상화,

1261
01:01:52,500 --> 01:01:53,720
우리는 그것을 정의.

1262
01:01:53,720 --> 01:01:55,540
>> 그래서 문자는 숫자입니다.

1263
01:01:55,540 --> 01:01:58,410
그리고 번호는 문자는,
다만 상황에 따라.

1264
01:01:58,410 --> 01:02:01,250
그리고 그 안에 밝혀
컴퓨터 프로그램,

1265
01:02:01,250 --> 01:02:06,830
당신은 당신이보고 싶은 방법을 지정할 수 있습니다
해당 프로그램의 내부 비트에서?

1266
01:02:06,830 --> 01:02:10,400
>> 우리가 가진 주 0에서 리콜
그냥이 코드는 아스키,

1267
01:02:10,400 --> 01:02:11,620
숫자에 매핑 문자.

1268
01:02:11,620 --> 01:02:13,660
그리고 우리는 자본 A는 65 말했다.

1269
01:02:13,660 --> 01:02:15,860
자본 B는 등 66합니다.

1270
01:02:15,860 --> 01:02:20,500
>> 그리고 통지, 우리는 본질적에 문자가
여기에 맨 위 행, C가 그들에게 전화하는 것처럼,

1271
01:02:20,500 --> 01:02:23,400
문자하고
두 번째 행에 정수.

1272
01:02:23,400 --> 01:02:28,180
그리고 그것은 당신이 변환 할 수 있습니다 밝혀
원활 일반적으로이 사이.

1273
01:02:28,180 --> 01:02:30,042
그리고 우리는 수행하려는 경우
이 의도적으로, 우리

1274
01:02:30,042 --> 01:02:31,750
해결하기 위해 할 수 있습니다
이 같은.

1275
01:02:31,750 --> 01:02:33,590
>> 우리는 변환 할 수 있습니다
대문자는 낮추는

1276
01:02:33,590 --> 01:02:35,330
경우, 또는 대문자로 소문자.

1277
01:02:35,330 --> 01:02:38,000
그리고 거기의 밝혀
여기에 실제로 패턴

1278
01:02:38,000 --> 01:02:39,900
우리는 단지 한 순간에 받아 들일 수 있습니다.

1279
01:02:39,900 --> 01:02:44,120
그러나의는에 처음으로 살펴 보자
명시 적으로이 일을 예.

1280
01:02:44,120 --> 01:02:46,340
>> 나는 CS50의 IDE로 돌아갈거야.

1281
01:02:46,340 --> 01:02:50,640
나는를 만들거야
파일 아스키 0.c.라고

1282
01:02:50,640 --> 01:02:55,960
내가 가서 추가하는거야 내
상단에 표준 io.h, INT 주요 무효

1283
01:02:55,960 --> 01:02:57,370
내 함수의 상단.

1284
01:02:57,370 --> 01:03:02,700
그리고 난 그냥 할거야
내가 같음에서 for 루프 following--,

1285
01:03:02,700 --> 01:03:04,610
이제, 65 가정 해 봅시다.

1286
01:03:04,610 --> 01:03:10,460
>> 그리고 내가 미만이 될 것입니다
알파벳 65, 플러스 26 문자.

1287
01:03:10,460 --> 01:03:12,640
그래서 컴퓨터를 드리겠습니다
거기에 나를 위해 수학을.

1288
01:03:12,640 --> 01:03:15,100
그리고이 루프 내부,
내가 인쇄 하겠어?

1289
01:03:15,100 --> 01:03:19,230
>> % C는 i가 n 개의 백 슬래시 %이다.

1290
01:03:19,230 --> 01:03:21,290
그리고 지금은 두 값을 연결하려고합니다.

1291
01:03:21,290 --> 01:03:24,530
나는 일시적으로 질문을 넣었습니다
질문을 초대가 표시합니다.

1292
01:03:24,530 --> 01:03:29,940
>> 나는 이후 65에서 반복 할
알파벳의 26 글자를 들면,

1293
01:03:29,940 --> 01:03:35,190
각 반복에 밖으로 인쇄하는
캐릭터의 필수적인 것과 같습니다.

1294
01:03:35,190 --> 01:03:38,299
즉, 내가 원하는
이상 26 번호 인쇄를 반복

1295
01:03:38,299 --> 01:03:41,590
ASCII 문자가 무엇인지, 편지,
상기 해당 번호가 무엇 is--

1296
01:03:41,590 --> 01:03:44,650
정말 다시
해당 슬라이드의 차트입니다.

1297
01:03:44,650 --> 01:03:47,010
그래서이 물음표는 무엇을해야 하는가?

1298
01:03:47,010 --> 01:03:51,760
>> 음, 제 2 밝혀
하나는 변수 내가해야한다.

1299
01:03:51,760 --> 01:03:53,860
나는 숫자로 그것을보고 싶어요.

1300
01:03:53,860 --> 01:03:58,920
그리고 중간에 인수
여기에, 나는 컴퓨터를 알 수 있습니다

1301
01:03:58,920 --> 01:04:03,470
그 정수를 치료하는
내가 문자로, 그래서

1302
01:04:03,470 --> 01:04:05,880
퍼센트 C. 여기를 대체하는

1303
01:04:05,880 --> 01:04:07,990
>> 즉, 만약 I의
인간의 프로그래머, 알고

1304
01:04:07,990 --> 01:04:09,865
이 단지 숫자
하루의 끝에서.

1305
01:04:09,865 --> 01:04:12,500
그리고 65해야 알아
일부 문자에 매핑됩니다.

1306
01:04:12,500 --> 01:04:15,310
이 명시 적 캐스트와 함께,
괄호와 함께,

1307
01:04:15,310 --> 01:04:18,840
당신이 원하는 데이터 유형의 이름
변환 및 닫힌 괄호

1308
01:04:18,840 --> 01:04:21,200
당신은 말할 수
컴퓨터, 헤이, 컴퓨터,

1309
01:04:21,200 --> 01:04:24,130
숯불이 정수를 변환합니다.

1310
01:04:24,130 --> 01:04:26,250
>> 그래서 나는이 프로그램을 실행할 때
프로그램 컴파일 후,

1311
01:04:26,250 --> 01:04:29,740
의 내가 아스키는 0이거나 먹어을 확인 할 수 있습니다.

1312
01:04:29,740 --> 01:04:33,020
그것은 이놈, 내가 잘못 여기에 무슨 짓을 한거야?

1313
01:04:33,020 --> 01:04:35,884
선언되지 않은 식별자의 사용
모든 의도적 인, 옳지 않아,

1314
01:04:35,884 --> 01:04:37,800
그러나 보자 경우 우리는 할 수 없습니다
이를 통해 이유.

1315
01:04:37,800 --> 01:04:41,220
>> 그래서 라인은 내가하지 않았다 five--
아주 멀리 망쳐 전에.

1316
01:04:41,220 --> 01:04:42,140
괜찮아.

1317
01:04:42,140 --> 01:04:46,560
그래서 난에 대한 선 (5)에 해당 65-- 난을 참조하십시오.

1318
01:04:46,560 --> 01:04:50,130
그래서 일부는 달리, C에서 그 기억
당신이 이전에 프로그램이있는 경우 언어

1319
01:04:50,130 --> 01:04:52,190
경험, 당신은
컴퓨터를 이야기하고,

1320
01:04:52,190 --> 01:04:55,040
스크래치는 달리, 무엇을
변수의 종류가있다.

1321
01:04:55,040 --> 01:04:56,860
>> 그리고 여기에서 중요한 어구를 잊어 버렸습니다.

1322
01:04:56,860 --> 01:04:59,200
라인 오, 나는 내가 사용하기 시작했습니다.

1323
01:04:59,200 --> 01:05:01,560
하지만 C를 말하지 않았다
어떤 데이터 유형이있다.

1324
01:05:01,560 --> 01:05:04,570
그래서 내가 여기에 갈거야 및
아, 그것은 정수 확인 말한다.

1325
01:05:04,570 --> 01:05:07,050
>> 지금은 가서 다시 컴파일거야.

1326
01:05:07,050 --> 01:05:08,080
즉, 그 고정.

1327
01:05:08,080 --> 01:05:12,660
입력 ./ascii0, 그 종류의 멋진입니다.

1328
01:05:12,660 --> 01:05:15,360
뿐만 아니라 그것은 슈퍼 빠른
컴퓨터이 질문을

1329
01:05:15,360 --> 01:05:18,885
오히려 슬라이드를 보는 것보다,
그것은, A가 65, 한 줄에 하나씩 인쇄

1330
01:05:18,885 --> 01:05:24,860
B는 I 이후 down-- (66), 모든 방법입니다
, 문자 z를이 26 times--했다

1331
01:05:24,860 --> 01:05:25,630
이는 90입니다.

1332
01:05:25,630 --> 01:05:27,790
그리고, 사실, 약간
보다 지능적인 것

1333
01:05:27,790 --> 01:05:31,030
나를 위해 없었을 의존하는
컴퓨터에 26를 추가합니다.

1334
01:05:31,030 --> 01:05:34,060
난 그냥 할 수 있었다
(90)뿐만 아니라, 너무 오래

1335
01:05:34,060 --> 01:05:37,390
내가 두 번 같은 실수를하지 않는 한.

1336
01:05:37,390 --> 01:05:41,880
나는 통해 가고 싶어
Z가 아닌 그냥 y를 통해.

1337
01:05:41,880 --> 01:05:44,000
>> 그래서 명시 적 캐스트입니다.

1338
01:05:44,000 --> 01:05:47,860
그것은이 밝혀
도 필요하지 않습니다.

1339
01:05:47,860 --> 01:05:52,480
내가 가서이를 다시 실행하자
컴파일러, 다시 실행 아스키 0.

1340
01:05:52,480 --> 01:05:54,940
그것은 C 꽤 똑똑 것으로 나타났다.

1341
01:05:54,940 --> 01:05:57,150
>> 그리고 printf와, 특히,
꽤 똑똑하다.

1342
01:05:57,150 --> 01:06:01,260
당신은 단지 두번 난을 전달하는 경우
모두 자리에 대한, printf의

1343
01:06:01,260 --> 01:06:04,510
실현합니다 오, 잘 난 당신을 알고
내게는 어떤 수를 integer-- 준,

1344
01:06:04,510 --> 01:06:06,380
65, 90, 또는 무엇이든 등을들 수있다.

1345
01:06:06,380 --> 01:06:10,170
그러나 나는 당신이 저를 원하는 참조
문자처럼 그 번호를 포맷합니다.

1346
01:06:10,170 --> 01:06:16,460
그리고 printf의 암시 적으로 변환 할 수 있습니다
뿐만 아니라 당신을 위해 문자를 int로.

1347
01:06:16,460 --> 01:06:19,360
그래서 전혀 문제가되지 않습니다.

1348
01:06:19,360 --> 01:06:23,100
>> 그러나이 때문에 등가의, 통지
우리는 실제로뿐만 아니라이 작업을 수행 할 수 있습니다.

1349
01:06:23,100 --> 01:06:26,520
내가 가서 하나를 만들어 보자
이 항아리 아스키 1.c.의 다른 버전

1350
01:06:26,520 --> 01:06:31,800
그리고 대신에 걸쳐 반복
정수, 정말 당신의 마음을 날려 버릴 수 있습니다

1351
01:06:31,800 --> 01:06:33,610
문자 반복에 의해.

1352
01:06:33,610 --> 01:06:37,660
숯불 c를 대문자 A를 얻을 수 있다면,
가서이 작업을 수행하려면,

1353
01:06:37,660 --> 01:06:41,740
오랫동안 C는 이하와 같이
자본 Z.에 그리고 각 반복에

1354
01:06:41,740 --> 01:06:45,690
나는 내가 할 수있는, C를 증가 할
지금 여기 내 printf의 라인

1355
01:06:45,690 --> 01:06:51,320
말하자면, %의 C이다
퍼센트 난 다시, 쉼표 C.

1356
01:06:51,320 --> 01:06:57,200
>> 그리고 지금, 나는 다른 방향으로 갈 수 있습니다,
명시 적 캐릭터 캐스팅

1357
01:06:57,200 --> 01:06:58,500
정수로.

1358
01:06:58,500 --> 01:07:00,560
그래서, 다시, 왜 이런 짓을 했을까?

1359
01:07:00,560 --> 01:07:03,830
그것은으로 정렬하려면 좀 이상해
문자의 관점에서 계산합니다.

1360
01:07:03,830 --> 01:07:07,430
>> 하지만 당신은 무엇을 이해한다면
후드 아래에 가고,

1361
01:07:07,430 --> 01:07:08,430
마술은 정말 없습니다.

1362
01:07:08,430 --> 01:07:13,060
당신은 헤이, 컴퓨터주고, 말을하는지
나 char 형의 C라는 변수.

1363
01:07:13,060 --> 01:07:16,520
자본 A.로 초기화하고
작은 따옴표 물질을 알 수 있습니다.

1364
01:07:16,520 --> 01:07:19,580
>> C에서 문자의 경우,에서 기억
지난 주, 당신은 작은 따옴표를 사용합니다.

1365
01:07:19,580 --> 01:07:23,720
문자열, 단어,
문구는 큰 따옴표를 사용합니다.

1366
01:07:23,720 --> 01:07:27,210
OK, 컴퓨터, 그래서이 일을 계속
문자만큼 미만

1367
01:07:27,210 --> 01:07:28,050
또는 z와 동일.

1368
01:07:28,050 --> 01:07:32,640
그리고 내 아스키 테이블에서 알고있는 모든
이 아스키 코드의 연속이다.

1369
01:07:32,640 --> 01:07:33,400
>> 틈이 없습니다.

1370
01:07:33,400 --> 01:07:36,737
그래서, 그냥 Z를 통해입니다
하나의 번호 각각에 의해 분리된다.

1371
01:07:36,737 --> 01:07:38,820
그리고 내가 증가 할 수 있습니다
숯불, 내가 정말 원하는 경우.

1372
01:07:38,820 --> 01:07:40,390
하루의 끝에서,
그것은 단지 숫자입니다.

1373
01:07:40,390 --> 01:07:41,030
나는이 사실을 알고.

1374
01:07:41,030 --> 01:07:43,670
그래서 난 그냥 1을 추가 추정 할 수 있습니다.

1375
01:07:43,670 --> 01:07:46,940
>> 그리고이 시간, 나는 C를 인쇄,
다음 적분 것과 같습니다.

1376
01:07:46,940 --> 01:07:50,170
그리고 난 명시 적 캐스트가 필요하지 않습니다.

1377
01:07:50,170 --> 01:07:52,680
나는 printf의과를하도록 할 수 있습니다
컴퓨터 그림 것들을 밖으로,

1378
01:07:52,680 --> 01:07:57,300
그래서 지금은 실행하는 경우
, Ascii1./ascii1을

1379
01:07:57,300 --> 01:08:01,520
나뿐만 아니라 동일한 일을 찾으실 수 있습니다.

1380
01:08:01,520 --> 01:08:04,530
>> 쓸모없는 프로그램, 아무도 though-- 없습니다
실제로 소프​​트웨어를 작성하는 것입니다

1381
01:08:04,530 --> 01:08:07,549
파악하기 위해, 무엇을했다
(A)에 맵핑 번호 또는 B, 또는 Z?

1382
01:08:07,549 --> 01:08:10,340
당신은 그냥 Google에 가고, 나하고
온라인을 찾아, 또는 그것을 찾아

1383
01:08:10,340 --> 01:08:11,650
슬라이드 등을합니다.

1384
01:08:11,650 --> 01:08:13,520
어디이 실제로 도움이 나올까요?

1385
01:08:13,520 --> 01:08:15,960
>> 글쎄, 그건 말하고
슬라이드, 거기에 알

1386
01:08:15,960 --> 01:08:20,890
대문자와 여기에 실제 패턴
소문자 실수하지 않았다 그.

1387
01:08:20,890 --> 01:08:23,760
그 자본 A는 65 알 수 있습니다.

1388
01:08:23,760 --> 01:08:25,830
소문자 a는 97입니다.

1389
01:08:25,830 --> 01:08:29,649
그리고 얼마나 멀리 떨어져 낮은 경우입니까?

1390
01:08:29,649 --> 01:08:32,649
>> 그래서 (65)는 몇 걸음 거리에 97인가?

1391
01:08:32,649 --> 01:08:36,210
그래서 97을 뺀 65 (32)이다.

1392
01:08:36,210 --> 01:08:37,910
그래서 자본 a는 65입니다.

1393
01:08:37,910 --> 01:08:39,939
당신은 32를 추가하는 경우,
당신은 소문자 얻을.

1394
01:08:39,939 --> 01:08:43,729
그리고, 동등하게, 당신은 32 빼기 경우,
당신은 자본으로 돌아 가야 할까 .. B와 동일

1395
01:08:43,729 --> 01:08:46,380
거의 다 거의 나에게 큰 C.

1396
01:08:46,380 --> 01:08:50,670
>> 이러한 갭은 모두 떨어져 32이다.

1397
01:08:50,670 --> 01:08:54,450
지금,이에 우리를 허용 할 것 같다
마이크로 소프트 워드 같은 것을 할,

1398
01:08:54,450 --> 01:08:57,729
또는 구글 문서 도구, 어디를 갖추고 있습니다
모든 것을 선택하고 말할 수있는,

1399
01:08:57,729 --> 01:09:00,520
소문자로 모두 변경하거나
대문자로 모든 변경,

1400
01:09:00,520 --> 01:09:03,840
또는 첫 번째 단어를 변경
대문자로 문장의.

1401
01:09:03,840 --> 01:09:07,390
우리는 실제로 뭔가를 할 수
자신처럼.

1402
01:09:07,390 --> 01:09:12,645
>> 내가 가서 보자하고 파일을 저장
여기 0.c.를 대문자로 불리는

1403
01:09:12,645 --> 01:09:15,770
그리고 이제 가서 프로그램을 채찍질하자
즉, 정확하게는 다음 있다고한다.

1404
01:09:15,770 --> 01:09:18,460
그래서 CS50 라이브러리를 포함한다.

1405
01:09:18,460 --> 01:09:21,430
그리고 표준 I / O를 포함한다.

1406
01:09:21,430 --> 01:09:22,787
>> 그리고 나는 이것이 곧 제공 될 예정입니다 알고있다.

1407
01:09:22,787 --> 01:09:24,870
그래서 난에 넣어 갈거야
거기에 이미, string.h,

1408
01:09:24,870 --> 01:09:26,960
그래서에 액세스 할 수 있습니다
스털링 같은 것들,

1409
01:09:26,960 --> 01:09:29,620
다음 평소와 같이, 메인 공백을 int로.

1410
01:09:29,620 --> 01:09:33,420
그리고 내가 가서거야
문자열을하는 문자열을 얻을 도착,

1411
01:09:33,420 --> 01:09:35,032
단지 사용자로부터 문자열을 얻을 수 있습니다.

1412
01:09:35,032 --> 01:09:36,740
그리고 내가 갈거야
내 정신 검사를 수행.

1413
01:09:36,740 --> 01:09:40,510
문자열이 동일 널 (null)이되지 않으면,
다음은 진행하는 것이 안전합니다.

1414
01:09:40,510 --> 01:09:42,000
그리고 내가 무엇을 하시겠습니까?

1415
01:09:42,000 --> 01:09:48,700
나는, 내가 0 같다에서 반복하는거야
n은 S의 문자열 길이까지.

1416
01:09:48,700 --> 01:09:51,899
>> 그리고 나는 너무 오래로이 작업을 수행하는거야
내가 플러스 플러스 n보다 작은합니다.

1417
01:09:51,899 --> 01:09:55,060
지금까지, 나는 정말이야
전에에서 아이디어를 빌려.

1418
01:09:55,060 --> 01:09:57,010
그리고 지금은 나뭇 가지를 소개하겠습니다.

1419
01:09:57,010 --> 01:09:59,635
>> 그래서 스크래치, 다시 생각한다
우리는 길에서 그 포크를했다

1420
01:09:59,635 --> 01:10:05,110
그리고 지난 주 C.에 나는 갈거야
이 말을하는 경우들에서 i 번째 문자

1421
01:10:05,110 --> 01:10:09,250
인 이상의
경우을 낮출 동일,

1422
01:10:09,250 --> 01:10:13,340
그리고 - 스크래치에서 당신은 말 그대로 것
그리고,하지만 C에서 당신이 앰퍼샌드 말 말

1423
01:10:13,340 --> 01:10:19,830
ampersand-- 및 S의 i 번째 문자
보다 작거나 케이스 Z 낮은 같음

1424
01:10:19,830 --> 01:10:21,780
의 흥미로운 뭔가를 할 수 있습니다.

1425
01:10:21,780 --> 01:10:27,020
의는 사실을 출력하자
없는 줄 바꿈과 문자

1426
01:10:27,020 --> 01:10:31,760
그 문자열의 문자입니다,
문자열의 i 번째 문자.

1427
01:10:31,760 --> 01:10:37,420
>> 그러나의를 진행하자
그것에서 32을 뺍니다.

1428
01:10:37,420 --> 01:10:42,120
다른 경우의 문자
우리가 찾고있는 것을 문자열

1429
01:10:42,120 --> 01:10:45,950
, 조금 사이 아니다
작은 Z, 진행

1430
01:10:45,950 --> 01:10:48,610
단지 변화를 인쇄.

1431
01:10:48,610 --> 01:10:50,840
그래서 우리는 도입했습니다
이 괄호 표기

1432
01:10:50,840 --> 01:10:53,560
우리의 문자열은에서 얻을 수에 대한
문자열에서 내가 번째 문자.

1433
01:10:53,560 --> 01:10:57,520
>> 내가 좋아하는 몇 가지 조건부 논리를 추가했습니다
지난 주 주 하나에 스크래치

1434
01:10:57,520 --> 01:10:59,880
난 그냥 내 기본을 사용하고 있습니다
무엇의 이해

1435
01:10:59,880 --> 01:11:01,130
후드 아래에 계속.

1436
01:11:01,130 --> 01:11:04,190
S의 i 번째 문자 인
(A)에 이상인?

1437
01:11:04,190 --> 01:11:08,290
마찬가지로, 97, 또는 98
또는 99 등?

1438
01:11:08,290 --> 01:11:11,940
>> 그러나 그것은 또한 이하인
소문자 Z의 값?

1439
01:11:11,940 --> 01:11:16,210
그렇다면,이 라인은 무엇을 의미합니까?

1440
01:11:16,210 --> 01:11:20,250
(14)이 일종의
전체 아이디어의 세균,

1441
01:11:20,250 --> 01:11:23,840
하여 문자를 대문자로
단순히, 그것에서 32을 뺀

1442
01:11:23,840 --> 01:11:29,370
이 경우, 나는 알고 있기 때문에, 그 당
내 번호가 표시되는 방법을 차트.

1443
01:11:29,370 --> 01:11:33,925
그럼 가서 이것을 실행하자,
0.c를 대문자로 컴파일 한 후,

1444
01:11:33,925 --> 01:11:36,210
및 실행은 (는) 0 투자.

1445
01:11:36,210 --> 01:11:40,300
>> 뭔가를 입력하자
모든 소문자 Zamyla을 입력합니다.

1446
01:11:40,300 --> 01:11:42,780
그리고 지금 우리는 모두 대문자로 Zamyla 있습니다.

1447
01:11:42,780 --> 01:11:45,050
의 모든 소문자 롭을 입력 할 수 있습니다.

1448
01:11:45,050 --> 01:11:46,674
의 모든 소문자로 제이슨을 해보자.

1449
01:11:46,674 --> 01:11:48,590
그리고 우리는 점점 계속
강제 대문자.

1450
01:11:48,590 --> 01:11:50,960
사소한 버그가 있습니다 그 I
가지 예상하지 않았다.

1451
01:11:50,960 --> 01:11:54,050
나의 새로운 메시지가 종료되어 주목
자신의 이름과 같은 줄에,

1452
01:11:54,050 --> 01:11:55,520
하는 약간의 혼란을 느낀다.

1453
01:11:55,520 --> 01:11:59,170
>> 그래서 여기에 갈 예정하고있어
실제로,이 프로그램의 끝

1454
01:11:59,170 --> 01:12:02,110
개행 문자를 인쇄 할 수 있습니다.

1455
01:12:02,110 --> 01:12:03,160
그게 다야.

1456
01:12:03,160 --> 01:12:06,120
printf와 함께, 당신은 할 필요가 없습니다
변수 또는 형식 코드를 전달합니다.

1457
01:12:06,120 --> 01:12:08,460
당신은 말 그대로 그냥 인쇄 할 수 있습니다
줄 바꿈 같은.

1458
01:12:08,460 --> 01:12:13,529
>> 그럼 가서 만들어 보자
, Zamyla을 다시 실행, 다시 0을 활용.

1459
01:12:13,529 --> 01:12:14,820
그리고 지금은 조금 더 예뻐이다.

1460
01:12:14,820 --> 01:12:17,274
지금, 내 메시지가 자신의 새로운 라인입니다.

1461
01:12:17,274 --> 01:12:18,440
그래서 모든 벌금과 좋은입니다.

1462
01:12:18,440 --> 01:12:19,910
그래서 그 좋은 예입니다.

1463
01:12:19,910 --> 01:12:22,700
하지만 난 필요하지 않습니다
하드 코드 32이 필요합니다.

1464
01:12:22,700 --> 01:12:23,350
당신 그거 알아?

1465
01:12:23,350 --> 01:12:26,350
나는 내가하지 say-- 수
그 차이가 무엇인지 기억한다.

1466
01:12:26,350 --> 01:12:29,330
>> 하지만 내가 알고있는 경우 I
소문자를 가지고,

1467
01:12:29,330 --> 01:12:34,430
나는 기본적으로 해제 빼기 할
어떤 거리가 조금 사이

1468
01:12:34,430 --> 01:12:39,160
a와 큰 A, 때문에 가정하면
다른 모든 문자는 동일

1469
01:12:39,160 --> 01:12:41,045
그 작업을 완수해야한다.

1470
01:12:41,045 --> 01:12:42,670
그러나 그렇게하기보다는, 그거 알아?

1471
01:12:42,670 --> 01:12:44,240
또 다른 방법이있다.

1472
01:12:44,240 --> 01:12:48,090
>> 내가 있다면 그 1.c-- 투자 인 경우
별도의 파일에 그것을 넣어.

1473
01:12:48,090 --> 01:12:51,030
다음의이 2.C을 활용하자.

1474
01:12:51,030 --> 01:12:53,060
난 정말 여기를 정리하겠습니다.

1475
01:12:53,060 --> 01:12:57,420
그리고 대신에도를 갖는
알거나 그 낮은 수준에 관심

1476
01:12:57,420 --> 01:13:01,090
구현 세부 사항은, 내가 대신 해요
그냥 문자를 인쇄하는 것,

1477
01:13:01,090 --> 01:13:04,610
인용 인용을 끝내, %의 C 및
다음 다른 함수를 호출하는

1478
01:13:04,610 --> 01:13:09,950
그 인수를 취 존재,
이는 같은 캐릭터입니다.

1479
01:13:09,950 --> 01:13:12,630
>> 그것은 거기에, C에서 밝혀
다른 함수 호출

1480
01:13:12,630 --> 01:13:15,550
상부에있는 그것의 이름으로
건의 문자를한다

1481
01:13:15,550 --> 01:13:19,350
그 대문자로 만든다
등가하고 리턴

1482
01:13:19,350 --> 01:13:21,410
그래서 printf와 거기에 연결할 수 있습니다.

1483
01:13:21,410 --> 01:13:25,484
그래서 난,하지만이 작업을 수행하는
다른 하나의 파일을 도입 할 필요가있다.

1484
01:13:25,484 --> 01:13:28,400
다른 파일 거기에서 그것은집니다
당신은 단지 클래스에서 알고있는 것,

1485
01:13:28,400 --> 01:13:33,020
교과서, 또는 온라인 또는
참조, 호출 C의 type.h.

1486
01:13:33,020 --> 01:13:38,570
>> 내 헤더 사이에 그를 추가 그래서 경우
파일은 이제 다시 컴파일이 프로그램을,

1487
01:13:38,570 --> 01:13:43,040
capitalize2는 입력 ./capitalize2.

1488
01:13:43,040 --> 01:13:46,690
의 모든에 Zamyla를 입력하자
소문자, 여전히 동일하게 작동합니다.

1489
01:13:46,690 --> 01:13:48,040
하지만 당신은 알아?

1490
01:13:48,040 --> 01:13:55,590
그것은 상단에 해당 밝혀
다른 기능이 있습니다.

1491
01:13:55,590 --> 01:13:58,410
>> 그리고 날이를 소개하자
일종의 가벼운 부상을 입, 여기에 명령

1492
01:13:58,410 --> 01:14:00,250
이름,하지만 설명서 남자.

1493
01:14:00,250 --> 01:14:03,960
그것은 대부분의 리눅스 컴퓨터를 밝혀
우리는 리눅스 운영을 here-- 사용하는 등

1494
01:14:03,960 --> 01:14:06,270
명령이 외 시스템
라고 불리는 사람,

1495
01:14:06,270 --> 01:14:08,530
이봐, 컴퓨터, 줘
컴퓨터의 사용 설명서.

1496
01:14:08,530 --> 01:14:10,680
당신이 원하는 작업
이 설명서에서 찾아 볼?

1497
01:14:10,680 --> 01:14:13,840
>> 나는 기능을보고 싶지
상단에 부름을 입력합니다.

1498
01:14:13,840 --> 01:14:16,070
그리고 약간의 비밀입니다
때로는 읽을 수 있습니다.

1499
01:14:16,070 --> 01:14:18,780
그러나 우리가에있어주의
리눅스 프로그래머 매뉴얼.

1500
01:14:18,780 --> 01:14:19,530
그리고 그것은 모든 텍스트입니다.

1501
01:14:19,530 --> 01:14:21,905
그리고 거기에 알
여기까지 함수의 이름을 지정합니다.

1502
01:14:21,905 --> 01:14:25,030
그것은이라는 사촌이 밝혀
반대를 수행하는 낮 춥니 다.

1503
01:14:25,030 --> 01:14:29,710
그리고 시놉시스에서 통지, 이것을 사용하기
, 말하자면, 그 사람 페이지를 작동

1504
01:14:29,710 --> 01:14:32,220
나에게 그 I를 말하고있다
ㄴ type.h.을 포함해야

1505
01:14:32,220 --> 01:14:33,630
그리고 연습에서 것을 알고 있었다.

1506
01:14:33,630 --> 01:14:36,210
>> 여기서, 나에게 두 가지를 보여주는 것
함수의 프로토 타입,

1507
01:14:36,210 --> 01:14:39,070
그래서 나는 지금이 사용하려는 경우
나는 그들이 입력으로 취 무엇인지,

1508
01:14:39,070 --> 01:14:40,652
그들은 출력으로 반환 할 것을.

1509
01:14:40,652 --> 01:14:42,360
그리고 나는 읽으면
설명, 내가 참조

1510
01:14:42,360 --> 01:14:44,820
보다 상세 기능은 무엇.

1511
01:14:44,820 --> 01:14:48,100
하지만 더 중요한 것은, 만약
나는, 반환 값에 따라보고

1512
01:14:48,100 --> 01:14:51,710
그것은 반환 값이 말한다
변환 된 편지의,

1513
01:14:51,710 --> 01:14:57,880
또는 C, 원래의 입력, 경우
변환이 불가능했다.

1514
01:14:57,880 --> 01:15:01,992
>> 즉, 상부하려고합니다합니다
대문자로 편지를 변환합니다.

1515
01:15:01,992 --> 01:15:03,450
그리고 만약 그렇다면, 그것을 반환 할 것입니다.

1516
01:15:03,450 --> 01:15:07,010
하지만 일부 reason--에 대한이 할 수있는 경우
어쩌면 이미 대문자가있어,

1517
01:15:07,010 --> 01:15:09,550
어쩌면 느낌표입니다
또는 다른 punctuation--

1518
01:15:09,550 --> 01:15:12,200
그냥가는거야
원래 C를 반환

1519
01:15:12,200 --> 01:15:17,340
내 코드를 만들 수 있음을 의미
다음과 같이 더 나은 디자인했다.

1520
01:15:17,340 --> 01:15:20,580
>> 나는 모든 필요하지 않습니다
이러한 코드 이놈 라인.

1521
01:15:20,580 --> 01:15:22,610
나는했습니다 라인의 모든
그냥 강조 할 수

1522
01:15:22,610 --> 01:15:28,700
하나의 간단한로 축소 할
이 항아리의 printf 퍼센트 인 라인,

1523
01:15:28,700 --> 01:15:33,510
상단 S 브라켓 난에 다.

1524
01:15:33,510 --> 01:15:36,090
그리고 이것은이 될 것입니다
더 나은 디자인의 예.

1525
01:15:36,090 --> 01:15:40,040
>> 왜 7 항 또는 제 8 라인 구현
코드, 그것은 그냥 어떤했다

1526
01:15:40,040 --> 01:15:44,960
대신 축소 할 수 있습니다 때, 삭제
그 논리 및 의사 결정의 모든

1527
01:15:44,960 --> 01:15:49,620
지금은 하나의 라인 (13)에 그
라이브러리에 의존 function--

1528
01:15:49,620 --> 01:15:53,430
는 C와 함께 제공 기능,하지만
당신이 뭘 원하는지 정확히 않습니다.

1529
01:15:53,430 --> 01:15:55,295
그리고, 솔직히 경우에도
그것은 C와 함께 제공되지 않은,

1530
01:15:55,295 --> 01:15:58,880
당신은, 스스로를 구현할 수
우리는 부정적인 INT를 얻을 수와 봤어요

1531
01:15:58,880 --> 01:16:01,700
뿐만 아니라 긍정적 인 INT 지난 주 얻을.

1532
01:16:01,700 --> 01:16:03,470
>> 이 코드는 훨씬 더 읽을 수 있습니다.

1533
01:16:03,470 --> 01:16:06,670
그리고, 참으로, 우리가 이동하면,
얼마나 훨씬 더 컴팩트 보면

1534
01:16:06,670 --> 01:16:08,360
내 프로그램의 버전입니다.

1535
01:16:08,360 --> 01:16:11,230
그것은, 지금은 조금 위에 무거운
모든 포함와.

1536
01:16:11,230 --> 01:16:14,380
지금 내가 서있는거야 때문에하지만, 괜찮아요
프로그래머의 어깨에

1537
01:16:14,380 --> 01:16:15,300
내 앞에.

1538
01:16:15,300 --> 01:16:18,440
그리고 그것은 누구 누구
정말 상단에 구현

1539
01:16:18,440 --> 01:16:21,470
많은처럼, 나에게 부탁을했다 누구
구현 스털링 정말

1540
01:16:21,470 --> 01:16:24,790
얼마 전에 나에게 부탁을했다.

1541
01:16:24,790 --> 01:16:26,970
그래서 지금 우리는이
더 나은 디자인 프로그램

1542
01:16:26,970 --> 01:16:31,680
즉, 동일한 로직을 구현한다.

1543
01:16:31,680 --> 01:16:35,580
>> 스털링의 말하기,하자
나 가서 이렇게.

1544
01:16:35,580 --> 01:16:38,320
내가 가서 저장하자
stirling.c으로이 파일.

1545
01:16:38,320 --> 01:16:43,255
그리고 그것은 밝혀, 우리는 다시 벗겨 수
아주 간단하게 지금 하나의 다른 층을 포함한다.

1546
01:16:43,255 --> 01:16:45,630
나는 앞과 채찍 갈거야
메인에서 다른 프로그램까지

1547
01:16:45,630 --> 01:16:49,759
여기에 단순히-구현을 다시 것을
문자열 길이는 다음과 같이.

1548
01:16:49,759 --> 01:16:52,300
그래서 여기에 코드 줄이야 그
나에게 사용자로부터 문자열을 가져옵니다.

1549
01:16:52,300 --> 01:16:53,910
우리는 또 다시이 문제를 계속 사용.

1550
01:16:53,910 --> 01:16:58,900
나 자신에게라는 변수를 줘 보자
번호를 저장하는 int 형의 n은.

1551
01:16:58,900 --> 01:17:02,490
>> 그리고 내가 가서 보자
다음 로직을한다.

1552
01:17:02,490 --> 01:17:15,610
의에서 n 번째 문자는 않지만
같지 백 슬래시 0, 진행

1553
01:17:15,610 --> 01:17:17,930
n은 증가.

1554
01:17:17,930 --> 01:17:23,506
그리고 printf의 %의 내가 없음을 인쇄 할 수 있습니다.

1555
01:17:23,506 --> 01:17:29,200
나는 그 프로그램이 여기에 주장
문자열 길이를 호출하지 않고,

1556
01:17:29,200 --> 01:17:31,150
문자열의 길이를 파악.

1557
01:17:31,150 --> 01:17:34,600
>> 그리고 마법은 전적으로
라인 (8)에 캡슐화

1558
01:17:34,600 --> 01:17:39,830
여기에 새 구문의 모습과,
따옴표에서이 백 슬래시 0.

1559
01:17:39,830 --> 01:17:41,360
그러나 그 이유는 무엇입니까?

1560
01:17:41,360 --> 01:17:44,100
음,되어 있는지 고려
이 모든 시간에가는.

1561
01:17:44,100 --> 01:17:47,990
>> 나는 잊어 버리기 전에 그리고로에게 옆으로 실현
도, 그 사람 페이지에 추가

1562
01:17:47,990 --> 01:17:50,920
그 전형적인 함께
CS50 IDE와 같은 리눅스 시스템,

1563
01:17:50,920 --> 01:17:53,770
실현이 우리의
물론 직원도 있습니다

1564
01:17:53,770 --> 01:17:56,030
웹 사이트 버전을 만든
라는이 같은 생각의

1565
01:17:56,030 --> 01:17:59,940
이 reference.cs50.net,
그 같은 사람의 모든 페이지,

1566
01:17:59,940 --> 01:18:02,020
같은 모든
문서뿐만 아니라

1567
01:18:02,020 --> 01:18:05,730
수 있습니다 상단에 작은 상자
당신은 매우 모든 변환

1568
01:18:05,730 --> 01:18:09,025
적은 편안한에 비밀 언어
모드, 어디서, 교원,

1569
01:18:09,025 --> 01:18:12,150
를 통과하고 단순화하기 위해 노력했다
물건을 유지하는 언어의 일부

1570
01:18:12,150 --> 01:18:14,830
아이디어에 초점을 맞추고, 그리고
교칙의 일부.

1571
01:18:14,830 --> 01:18:20,070
그래서 명심 reference.cs50.net
뿐만 아니라 다른 자원으로.

1572
01:18:20,070 --> 01:18:23,800
>> 그런데 왜 문자열 길이의 작품을 수행
내가 전에 잠시 시간을 제안한 방법은?

1573
01:18:23,800 --> 01:18:25,160
여기 Zamyla의 이름은 다시입니다.

1574
01:18:25,160 --> 01:18:27,690
그리고 여기 Zamyla의 이름입니다
나는이 일을 계속 같이에서 박스,

1575
01:18:27,690 --> 01:18:31,360
이 인의 사진을 칠하고,
정말, 문자 단지 순서.

1576
01:18:31,360 --> 01:18:34,260
그러나 Zamyla가 존재하지 않습니다
프로그램에서 분리한다.

1577
01:18:34,260 --> 01:18:37,420
>> 당신이 작성하고 프로그램을 실행하면,
당신은 당신의 Mac 또는 PC를 사용하는

1578
01:18:37,420 --> 01:18:40,010
메모리 또는 RAM으로 말하자면.

1579
01:18:40,010 --> 01:18:42,620
그리고 당신은 생각할 수
필요로 컴퓨터

1580
01:18:42,620 --> 01:18:44,730
메모리의 기가 바이트 요즘 많이.

1581
01:18:44,730 --> 01:18:47,700
그리고 공연은 수십억을 의미
바이트 그래서 수십억.

1582
01:18:47,700 --> 01:18:48,910
>> 그러나의 시간에 되감기 할 수 있습니다.

1583
01:18:48,910 --> 01:18:51,530
우리가 사용하고 있다고 가정
정말 오래된 컴퓨터가

1584
01:18:51,530 --> 01:18:55,150
전용 메모리의 32 바이트가 있습니다.

1585
01:18:55,150 --> 01:18:59,310
I 수, 내 컴퓨터 화면에,
다음과 같이 간단하게이를 그립니다.

1586
01:18:59,310 --> 01:19:05,240
>> 나는 단순히 말할 수 내
컴퓨터는이 모든 메모리가 있습니다.

1587
01:19:05,240 --> 01:19:08,830
그리고이 경우, 메모리 스틱처럼
당신은 마지막에서 우리의 사진을 기억합니다.

1588
01:19:08,830 --> 01:19:11,670
그리고 난 그냥 분할하는 경우
충분한 시간이,

1589
01:19:11,670 --> 01:19:15,040
나는 32 바이트를 가지고 있다고 주장
화면에 메모리.

1590
01:19:15,040 --> 01:19:18,239
>> 지금, 현실에서 내가 할 수있는 유일한
여기에이 화면에 지금까지 그립니다.

1591
01:19:18,239 --> 01:19:20,280
그래서 앞서 갈거야
그냥 규칙에 의해,

1592
01:19:20,280 --> 01:19:24,050
로 내 컴퓨터의 메모리를 그려
그리드, 단지 하나의 직선.

1593
01:19:24,050 --> 01:19:28,190
특히, 지금은 그 주장
이 그리드이 8로 4 그리드,

1594
01:19:28,190 --> 01:19:31,800
다만 모든 32 바이트를 나타냅니다
내 맥에서 사용 가능한 메모리,

1595
01:19:31,800 --> 01:19:33,030
또는 내 PC에서 사용할 수있는.

1596
01:19:33,030 --> 01:19:34,780
그리고 그들은 포장하고
에 두 라인, 단지

1597
01:19:34,780 --> 01:19:38,030
이를 화면에 더 적합하기 때문이다.

1598
01:19:38,030 --> 01:19:40,800
그러나 이것은 첫번째 바이트이다.

1599
01:19:40,800 --> 01:19:41,990
이것은 두 번째 바이트이다.

1600
01:19:41,990 --> 01:19:43,300
이 제 3 바이트이다.

1601
01:19:43,300 --> 01:19:45,310
>> 그리고 이것은 32 바이트이다.

1602
01:19:45,310 --> 01:19:52,910
아니면, 우리는 컴퓨터처럼 생각하는 경우
과학자 이것은 바이트 0, 1, 2, 3, 31이다.

1603
01:19:52,910 --> 01:19:55,950
그래서, 만약 31에 0이
당신은 0으로 계산 시작합니다.

1604
01:19:55,950 --> 01:19:59,830
>> 우리가 프로그램을 사용한다면
통화 문자열 얻을,

1605
01:19:59,830 --> 01:20:05,280
우리는 인간에서 문자열을 얻을
, 내가 Zamyla라고했던 것처럼 Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
어떻게 세상이 수행에
컴퓨터 킵 추적하는 바이트,

1607
01:20:09,430 --> 01:20:12,230
메모리의 어떤 덩어리,
어떤 문자열에 속해?

1608
01:20:12,230 --> 01:20:16,270
즉, 우리는에 진행하는 경우
컴퓨터에 다른 이름을 입력

1609
01:20:16,270 --> 01:20:19,890
이 앤디처럼 호출
문자열 두 번째 시간을 가져,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I는에서 생을 마감합니다
컴퓨터의 메모리뿐만 아니라.

1611
01:20:23,030 --> 01:20:23,850
하지만 어떻게?

1612
01:20:23,850 --> 01:20:29,700
>> 글쎄, 그것은 아래에 밝혀
문자열을 저장할 때 후드, 무슨 C 것은 않습니다

1613
01:20:29,700 --> 01:20:35,080
인간의 종류, 또는 그
그것이, 다른 소스에서 온

1614
01:20:35,080 --> 01:20:39,190
그들의 끝을 묘사
특별한 character-- 백 슬래시

1615
01:20:39,190 --> 01:20:44,750
그냥 특별한 방법 0,
행 80 비트 말.

1616
01:20:44,750 --> 01:20:47,950
>> 그래서 할까 ..이 숫자 97 리콜이다.

1617
01:20:47,950 --> 01:20:51,770
8 비트 그래서 몇 가지 패턴
진수 97를 나타냅니다.

1618
01:20:51,770 --> 01:20:58,070
이 백 슬래시 0 문자 수입니다
0, 일명 NUL, N-U-L, 이전과는 달리,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, 우리가 이야기했다.

1620
01:20:59,630 --> 01:21:05,700
하지만 지금은, 그냥이 알고
백 슬래시 0 행의 단지 80 비트이다.

1621
01:21:05,700 --> 01:21:09,810
>> 그리고 그것은 단지이 줄이야
왼쪽에있는 것을 말한다 모래

1622
01:21:09,810 --> 01:21:12,610
하나의 문자열, 또는 하나의 데이터 유형에 속한다.

1623
01:21:12,610 --> 01:21:15,480
오른쪽에 아무것도
뭔가에 속한다.

1624
01:21:15,480 --> 01:21:17,440
앤디의 이름, 한편,
이는 단지 시각적

1625
01:21:17,440 --> 01:21:21,310
다른 라인에 포장하는 일,
하지만, 단지 미적 세부 사항입니다

1626
01:21:21,310 --> 01:21:23,990
유사 NUL 종료한다.

1627
01:21:23,990 --> 01:21:29,290
>> 그것은는 A-N-D-I 문자의 문자열입니다
플러스 다섯 번째 비밀 문자,

1628
01:21:29,290 --> 01:21:33,560
단지 구분한다 모든 0 비트,
뿐만 아니라 앤디의 이름의 끝.

1629
01:21:33,560 --> 01:21:37,120
그리고 우리가 호출하는 경우 문자열을 세 번째를 얻을 수
컴퓨터에서 같은 문자열을 얻을 수

1630
01:21:37,120 --> 01:21:44,210
마리아, M-A-R-I-A는 유사 마리아의입니다
이름 NUL은 백 슬래시 0으로 종료되었습니다.

1631
01:21:44,210 --> 01:21:47,170
>> 이것은 근본적으로 다르​​다
방법에서 컴퓨터는 일반적으로 것

1632
01:21:47,170 --> 01:21:51,850
정수 또는 부동 소수점 또는 다른 저장
아직 데이터 형식, 리콜 때문에,

1633
01:21:51,850 --> 01:21:57,420
정수 일반적으로 32 비트 또는
4 바이트, 또는 어쩌면 64 비트,

1634
01:21:57,420 --> 01:21:59,100
또는 8 바이트.

1635
01:21:59,100 --> 01:22:02,620
그러나 컴퓨터에 많은 프리미티브
프로그래밍 언어

1636
01:22:02,620 --> 01:22:05,550
고정 된 수를 가지고
hood-- 아래 바이트

1637
01:22:05,550 --> 01:22:08,100
아마 1, 어쩌면 2, 아마 네, 아마 8.

1638
01:22:08,100 --> 01:22:13,250
>> 그러나 문자열, 디자인함으로써,이
문자의 동적 수입니다.

1639
01:22:13,250 --> 01:22:16,980
당신은 때까지, 사전에 몰라
Z-A-M-Y-L-A에서 인간 유형

1640
01:22:16,980 --> 01:22:21,400
또는 M-A-R-I-A 또는 A-N-I-D. 당신은 몰라
얼마나 많은 시간을 사용자가 칠 것입니다

1641
01:22:21,400 --> 01:22:22,070
키보드.

1642
01:22:22,070 --> 01:22:26,490
따라서, 당신은 방법을 모른다
사전에 많은 문자

1643
01:22:26,490 --> 01:22:27,540
당신이 필요 해요.

1644
01:22:27,540 --> 01:22:31,840
>> 그래서 C는 종류의 같은 잎
후드 아래에 비밀 이동 경로

1645
01:22:31,840 --> 01:22:32,960
문자열의 끝에서.

1646
01:22:32,960 --> 01:22:39,280
메모리에 Z-​​A-M-Y-L-A를 저장 한 후,
또한 단지 동등한를두고

1647
01:22:39,280 --> 01:22:40,210
기간의.

1648
01:22:40,210 --> 01:22:45,060
문장의 마지막
그것은 수 있도록 80 비트를 둔다

1649
01:22:45,060 --> 01:22:49,120
여기서 기억해야 할
Zamyla이 시작되고 끝납니다.

1650
01:22:49,120 --> 01:22:51,490
>> 그래서 연결은 무엇인가,
다음,이 프로그램에?

1651
01:22:51,490 --> 01:22:55,190
여기에이 프로그램, 스털링,
메커니즘은 단순히

1652
01:22:55,190 --> 01:22:57,970
문자열을 얻기를위한
사용자로부터, 라인 6.

1653
01:22:57,970 --> 01:23:01,160
7 호선, 나는 변수를 선언
N이라고는 0과 동일하게 설정.

1654
01:23:01,160 --> 01:23:08,680
>> 그리고 라인 8, 단순히 물어
질문, n 번째 문자가하는 동안

1655
01:23:08,680 --> 01:23:12,120
동일하지 않은 모든 0 bits--
즉하지 않는다

1656
01:23:12,120 --> 01:23:14,500
동일이 특별한
문자, 백 슬래시 0, 어떤

1657
01:23:14,500 --> 01:23:18,470
그냥 특별한 NUL character--했다
가서 그냥 N 증가.

1658
01:23:18,470 --> 01:23:21,460
>> 그리고 그 일을 유지하고 유지
그 일을 한 것은 일을 계속.

1659
01:23:21,460 --> 01:23:23,430
그래서도에서 비록
우리는 내가 사용했습니다 과거,

1660
01:23:23,430 --> 01:23:25,181
완벽하게 괜찮아요
의미 N 사용하는,

1661
01:23:25,181 --> 01:23:27,430
당신은 단지하려고하는 경우
의도적으로이 시간을 계산,

1662
01:23:27,430 --> 01:23:28,720
그냥 N을 호출 할 수 있습니다.

1663
01:23:28,720 --> 01:23:34,720
그래서 그냥 질문을 유지,
모두 0 (S)의 n 번째 문자는 무엇입니까?

1664
01:23:34,720 --> 01:23:38,470
그렇지 않은 경우, 다음 모양을 보면,
다음에 보면 다음에 보면,

1665
01:23:38,470 --> 01:23:39,460
다음에 봐.

1666
01:23:39,460 --> 01:23:45,540
>> 그러나 바로이 백 슬래시 0을 참조로,
11-- 통해이 loop-- 라인 (9)이 중지됩니다.

1667
01:23:45,540 --> 01:23:49,640
당신은, while 루프의 탈옥
그 변수 (n)의 내부 떠나

1668
01:23:49,640 --> 01:23:54,530
의 모든 총 개수
당신이 본 문자열의 문자,

1669
01:23:54,530 --> 01:23:55,660
따라서 그것을 밖으로 인쇄.

1670
01:23:55,660 --> 01:23:56,760
그래서이 시도 할 수 있습니다.

1671
01:23:56,760 --> 01:23:59,500
>> 없이, 내가 가서 보자
스털링 함수를 사용하여,

1672
01:23:59,500 --> 01:24:04,240
하지만 내 자신의 자체 개발 버전을 사용
여기 스털링라고, 내가 앞서 가자

1673
01:24:04,240 --> 01:24:07,700
뭔가 및 실행 스털링, 유형
내가 미리 알고 Zamyla, 같은

1674
01:24:07,700 --> 01:24:08,670
6 자이다.

1675
01:24:08,670 --> 01:24:10,080
그것이 작동하는지 보자.

1676
01:24:10,080 --> 01:24:10,920
실제로, 여섯이다.

1677
01:24:10,920 --> 01:24:15,257
의 롭 함께 해보자, 세 문자,
세 문자뿐만 아니라, 등등.

1678
01:24:15,257 --> 01:24:17,340
그래서 무슨 일이 전부입니다
후드 아래에.

1679
01:24:17,340 --> 01:24:19,548
그리고 연결을 발견,
다음, 첫 주에

1680
01:24:19,548 --> 01:24:22,370
클래스, 우리는 이야기 경우
추상화 같은,

1681
01:24:22,370 --> 01:24:26,960
어떤 아이디어가 바로이 레이어는, 또는
복잡성, 기본 원칙의 상단에.

1682
01:24:26,960 --> 01:24:30,710
여기, 우리는 일종의 찾고
스털링의 후드 아래,

1683
01:24:30,710 --> 01:24:33,510
그래서 알아 내기 위해, 이야기하기,
그것은 어떻게 구현 될 것인가?

1684
01:24:33,510 --> 01:24:35,232
>> 그리고 우리는 그것을 자신을 다시 구현할 수 있습니다.

1685
01:24:35,232 --> 01:24:37,440
그러나 우리는 다시는 않을거야
하는 스털링를 다시 구현.

1686
01:24:37,440 --> 01:24:39,780
우리는 단지에가는거야
위해 스털링를 사용

1687
01:24:39,780 --> 01:24:42,100
실제로 일부 문자열 길이를 얻을 수 있습니다.

1688
01:24:42,100 --> 01:24:44,200
>> 하지만 마법이 없다
후드 아래에.

1689
01:24:44,200 --> 01:24:46,716
당신이 알고있는 경우 아래 그
후드, 문자열

1690
01:24:46,716 --> 01:24:48,090
문자 단지 순서입니다.

1691
01:24:48,090 --> 01:24:51,090
그리고 문자의 순서
모든 수치 해결할 수 있습니다

1692
01:24:51,090 --> 01:24:53,330
브래킷 0, 브래킷
1 브래킷 (2), 그리고

1693
01:24:53,330 --> 01:24:57,420
문자열의 끝에를 것을 알고
특수 문자, 당신은 알아낼 수

1694
01:24:57,420 --> 01:25:01,710
A의 대부분의 작업을 수행하는 방법
프로그램은 모든 있기 때문에 아래로 비등

1695
01:25:01,710 --> 01:25:03,400
읽고 메모리를 쓰고있다.

1696
01:25:03,400 --> 01:25:06,130
즉, 변경하고 찾고 있습니다
메모리에, 또는 물건을 이동

1697
01:25:06,130 --> 01:25:10,940
주위에 메모리에, 인쇄 것들
등 스크린과에.

1698
01:25:10,940 --> 01:25:14,800
>> 그래서 지금이 새로 발견을 사용하자
사실을 문자열 무엇인지에 대한 이해

1699
01:25:14,800 --> 01:25:17,910
후드 아래에 있으며,
하나의 다른 층을 다시 껍질

1700
01:25:17,910 --> 01:25:20,080
지금까지 우리가했습니다까지 그
모두 무시되었다.

1701
01:25:20,080 --> 01:25:22,650
특히, 어떤 시간에
우리는 프로그램을 구현했습니다,

1702
01:25:22,650 --> 01:25:25,930
우리는이 코드 줄을 했어
상단 메인 선언.

1703
01:25:25,930 --> 01:25:27,810
그리고 우리는 INT의 주요 공백​​을 지정했습니다.

1704
01:25:27,810 --> 01:25:31,240
>> 그리고 괄호 안에 그 보이드
이이 모든 시간을 말한 것을 주

1705
01:25:31,240 --> 01:25:33,440
자체 인수를하지 않습니다.

1706
01:25:33,440 --> 01:25:36,210
주요임을 모든 입력
사용자로부터 얻을 것

1707
01:25:36,210 --> 01:25:39,020
다른에서 온합니다
메커니즘, 같은 GET INT,

1708
01:25:39,020 --> 01:25:42,040
또는 플로트를 얻을, 또는 문자열을 얻을,
또는 다른 기능.

1709
01:25:42,040 --> 01:25:44,710
그러나 그것은 밝혀
당신은 프로그램을 작성할 때,

1710
01:25:44,710 --> 01:25:47,690
실제로 지정할 수 있습니다
이 프로그램하여야한다

1711
01:25:47,690 --> 01:25:51,730
인간로부터의 입력을
명령 행 자체에서.

1712
01:25:51,730 --> 01:25:56,310
>> 즉, 비록 우리가 지금까지
안녕하세요 ./hello 단지 운영하고 있습니다

1713
01:25:56,310 --> 01:26:00,312
또는 이와 유사한 프로그램의 모든
우리가 사용했던 다른 프로그램

1714
01:26:00,312 --> 01:26:02,770
우리 자신이 작성하지 않은 그
이, 그것은 보인다, 복용

1715
01:26:02,770 --> 01:26:05,210
명령 줄 arguments--
메이크업 같은 것들.

1716
01:26:05,210 --> 01:26:07,450
당신은 메이크업과 같은 말을,
다음 제 2 워드.

1717
01:26:07,450 --> 01:26:10,950
또는 그 소리는, 당신은 그 때 그 소리와 말
제 2 워드, 파일의 이름입니다.

1718
01:26:10,950 --> 01:26:14,410
>> 당신은 수도, 또는 RM 또는 CP
알 나 이미 사용하고 있습니다

1719
01:26:14,410 --> 01:26:15,880
제거하거나 파일을 복사합니다.

1720
01:26:15,880 --> 01:26:18,920
이들 모두는 소위 취할
명령 줄 arguments--

1721
01:26:18,920 --> 01:26:21,130
터미널 프롬프트에서 추가 단어.

1722
01:26:21,130 --> 01:26:23,260
그러나 지금까지, 우리
자신은 없었어요

1723
01:26:23,260 --> 01:26:27,080
로부터 입력을 복용이 럭셔리
사용자가 그 또는 그녀가 실제로 실행될

1724
01:26:27,080 --> 01:26:29,120
명령 줄에서 프로그램 자체.

1725
01:26:29,120 --> 01:26:33,710
>> 그러나 우리는에 의해 다시 선언하는 것을 할 수있다
메인 것으로, 앞으로하지 이동

1726
01:26:33,710 --> 01:26:36,750
괄호 안에 무효,
그러나이 두 개의 인수

1727
01:26:36,750 --> 01:26:40,600
첫 번째 정수 instead--,
두 번째 것을

1728
01:26:40,600 --> 01:26:44,170
우리가 전화를 겁니다 새로운, 뭔가
배열, 정신 비슷한

1729
01:26:44,170 --> 01:26:49,220
우리가 목록으로 스크래치에서 본 것과하지만,
문자열의 배열, 우리는 곧 볼 수있다.

1730
01:26:49,220 --> 01:26:51,790
그러나 이제 이것을 보자
예로서, 우리는 이전

1731
01:26:51,790 --> 01:26:53,690
그 의미를 정확하게 구분합니다.

1732
01:26:53,690 --> 01:26:56,520
>> 내가 CS50 IDE로 이동한다면
여기에, 나는 앞으로 갔어요

1733
01:26:56,520 --> 01:27:01,840
와라는 파일에 선언
다음 템플릿을 argv0.c.

1734
01:27:01,840 --> 01:27:04,120
그리고 유일한 통지
즉, 지금까지 다르다

1735
01:27:04,120 --> 01:27:08,570
나는 int로 무효 변경 한 것을
는 argc 문자열은 가까운 오픈 브래킷을 argv를

1736
01:27:08,570 --> 01:27:09,070
까치발.

1737
01:27:09,070 --> 01:27:11,730
그리고 거기에, 지금 주목
그 괄호 안에 아무것도 없습니다.

1738
01:27:11,730 --> 01:27:12,620
>> 어떤 수는 없습니다.

1739
01:27:12,620 --> 01:27:15,070
그리고, 더 나는 없다 또는
N, 또는 다른 문자.

1740
01:27:15,070 --> 01:27:17,010
난 그냥 사용하고 있습니다
지금은 대괄호,

1741
01:27:17,010 --> 01:27:19,510
이유로 우리는 올 것이다
다시 그냥 순간입니다.

1742
01:27:19,510 --> 01:27:21,330
>> 그리고 지금 내가 할거야 것은 이것입니다.

1743
01:27:21,330 --> 01:27:26,680
는 argc가 동일한 경우에 해당 2--
그리고 그 같음과 동일 리콜

1744
01:27:26,680 --> 01:27:30,040
비교 항등 연산자이다
평등의 왼쪽과 오른쪽.

1745
01:27:30,040 --> 01:27:31,790
그것은 할당 아니다
이다 운영자,

1746
01:27:31,790 --> 01:27:36,510
사본을 의미하는 하나의 등호,
오른쪽에서 어떤 값을 왼쪽으로.

1747
01:27:36,510 --> 01:27:42,840
>> 는 argc와 같이 동일한 경우, 내가 원하는
말, printf와, 안녕하세요, 퍼센트, 새로운 라인,

1748
01:27:42,840 --> 01:27:47,340
다음 in-- 연결하고 여기에 새로운 기능
이유 trick-- argv를 브래킷 1

1749
01:27:47,340 --> 01:27:48,840
우리는 다시에 잠시 들어올거야.

1750
01:27:48,840 --> 01:27:52,110
는 argc하지 않는 경우는 다른
2 동일, 그거 알아?

1751
01:27:52,110 --> 01:27:57,400
평소, 인쇄로, 그냥 진행하자
아니 대체와 아웃 안녕하세요 세계.

1752
01:27:57,400 --> 01:28:02,710
>> 그래서 보이는 것이라고는 argc,하는 경우
,, 인수 수를 의미 2와 동일

1753
01:28:02,710 --> 01:28:04,740
나는 인쇄 할거야
안녕하세요 뭔가 다른.

1754
01:28:04,740 --> 01:28:07,560
그렇지 않으면, 기본적으로 난
안녕하세요 세상을 인쇄하는 것.

1755
01:28:07,560 --> 01:28:08,770
그래서 이것은 무엇을 의미합니까?

1756
01:28:08,770 --> 01:28:15,550
>> 글쎄, 내가 가서 저장할 수 있습니다
이 파일 다음 argv0을 수행

1757
01:28:15,550 --> 01:28:18,940
다음 ./argv0 입력합니다.

1758
01:28:18,940 --> 01:28:20,300
그리고 세계는 안부.

1759
01:28:20,300 --> 01:28:21,260
이제, 그 이유는 무엇입니까?

1760
01:28:21,260 --> 01:28:24,730
>> 글쎄, 당신은 언제 밝혀
명령 줄에서 프로그램을 실행,

1761
01:28:24,730 --> 01:28:29,570
당신은 우리가 거​​에서 작성된다
일반적으로 인수 벡터를 호출합니다.

1762
01:28:29,570 --> 01:28:33,100
자동 즉,
컴퓨터 운영 체제

1763
01:28:33,100 --> 01:28:38,340
프로그램에 손을 것입니다
자체 모든 단어의 목록

1764
01:28:38,340 --> 01:28:40,850
인간은 입력했는지
경우에 프롬프트, 당신

1765
01:28:40,850 --> 01:28:43,790
프로그래머가 수행 할
정보 뭔가.

1766
01:28:43,790 --> 01:28:48,540
이 경우, 유일한 단어
내가 프롬프트에서 입력 한 것은 ./argv0입니다.

1767
01:28:48,540 --> 01:28:55,420
>> 그리고 인수의 수입니다
내 프로그램에 전달되는 단지이다.

1768
01:28:55,420 --> 01:28:58,880
즉, 인수
다르게는 argc라고도 간주

1769
01:28:58,880 --> 01:29:00,970
여기에 정수로, 단지 하나입니다.

1770
01:29:00,970 --> 01:29:03,000
하나는 물론 두 동등하지 않는다.

1771
01:29:03,000 --> 01:29:05,980
그리고이 안녕하세요, 세상을 인쇄하는 것입니다.

1772
01:29:05,980 --> 01:29:08,170
>> 그러나 내가이 곳을 보자.

1773
01:29:08,170 --> 01:29:09,930
저 말 argv0하자.

1774
01:29:09,930 --> 01:29:12,740
그리고 어떻게 마리아는 어떻습니까?

1775
01:29:12,740 --> 01:29:14,990
그런 다음 Enter 키를 누릅니다.

1776
01:29:14,990 --> 01:29:18,020
>> 그리고 마술 여기에 무슨 알 수 있습니다.

1777
01:29:18,020 --> 01:29:22,640
자, 대신 안녕하세요 세계, 나는이
이 프로그램의 동작을 변경

1778
01:29:22,640 --> 01:29:26,310
GET에서하지 입력을 취함으로써
문자열이나 다른 기능,

1779
01:29:26,310 --> 01:29:30,570
하지만, 분명히, 내 명령
자체, 내가 처음에 입력 한 내용.

1780
01:29:30,570 --> 01:29:35,720
그리고 다시이 게임을 재생할 수 있습니다
예를 들어 스텔 리오스로 변경.

1781
01:29:35,720 --> 01:29:38,400
>> 그리고 지금은 또 다른 이름을 참조하십시오.

1782
01:29:38,400 --> 01:29:40,540
그리고 여기, 나는 앤디 말할 수 있습니다.

1783
01:29:40,540 --> 01:29:42,137
그리고 나는 Zamyla 말할 수 있습니다.

1784
01:29:42,137 --> 01:29:45,220
그리고 우리는 하루 종일이 게임을 재생할 수 있습니다
단지 다른 값에 연결,

1785
01:29:45,220 --> 01:29:49,550
너무 오래 내가 정확하게 제공으로
프롬프트에서 두 단어,

1786
01:29:49,550 --> 01:29:52,260
는 argc, 내 인수가 계산되도록, 2입니다.

1787
01:29:52,260 --> 01:29:57,240
>> 나는 이름에 연결되어 있음을 볼 수 있나요
printf와, 여기에이 조건 당?

1788
01:29:57,240 --> 01:30:00,550
그래서 우리는 지금 것 같다
표현 적 기능

1789
01:30:00,550 --> 01:30:04,410
다른기구로부터 입력을 복용,
소위 명령 줄에서,

1790
01:30:04,410 --> 01:30:07,000
오히려 기다릴 필요보다
사용자가 프로그램을 실행할 때까지

1791
01:30:07,000 --> 01:30:10,220
다음 그 또는 그녀의 메시지를 표시
GET 문자열 같은 것을 사용.

1792
01:30:10,220 --> 01:30:11,230
>> 그래서 이것은 무엇입니까?

1793
01:30:11,230 --> 01:30:15,010
ARGC 다시, 단지 정수이고,
글자 네요 arguments--의 수

1794
01:30:15,010 --> 01:30:18,540
그 사용자에 제공
프롬프트 단자 창에서,

1795
01:30:18,540 --> 01:30:20,110
프로그램의 이름을 포함.

1796
01:30:20,110 --> 01:30:23,340
그래서 우리 ./argv0 효과적으로이며,
프로그램의 이름,

1797
01:30:23,340 --> 01:30:24,520
또는 어떻게 프로그램을 실행합니다.

1798
01:30:24,520 --> 01:30:25,810
>> 즉 단어로 계산합니다.

1799
01:30:25,810 --> 01:30:27,080
그래서는 argc는 1이 될 것이다.

1800
01:30:27,080 --> 01:30:29,750
하지만 스텔 리오스를 작성하거나
앤디, 또는 Zamyla, 또는 마리아,

1801
01:30:29,750 --> 01:30:31,660
즉, 인수 개수가 두 의미합니다.

1802
01:30:31,660 --> 01:30:33,910
그리고 지금에 전달 된 두 단어가있다.

1803
01:30:33,910 --> 01:30:36,070
>> 그리고 통지, 우리는이 논리를 계속할 수 있습니다.

1804
01:30:36,070 --> 01:30:39,050
내가 실제로 말할 경우
Zamyla 찬과 같이,

1805
01:30:39,050 --> 01:30:42,200
전체 이름하여 전달
총 세 개의 인수,

1806
01:30:42,200 --> 01:30:47,410
지금은 기본을 다시 말한다,
물론, 3이 동일하지 않기 때문에.

1807
01:30:47,410 --> 01:30:54,080
>> 그래서 이런 식으로, 내가해야합니까
변수는 argv이 새로운 인수를 통해 액세스

1808
01:30:54,080 --> 01:30:56,080
우리는 기술적으로 수
우리가 원하는 무엇이든을 호출합니다.

1809
01:30:56,080 --> 01:30:58,940
그러나 관례, 그건
각각 변수는 argv와는 argc.

1810
01:30:58,940 --> 01:31:04,470
ARGV, 인수 벡터, 종류
프로그래밍의 동의어의

1811
01:31:04,470 --> 01:31:07,140
C의 기능은 배열을했다.

1812
01:31:07,140 --> 01:31:14,410
>> 배열은 비슷한 값의 목록입니다
뒤로, 뒤로, 백업, 백업합니다.

1813
01:31:14,410 --> 01:31:17,810
즉, 만약 하나는 바로 여기에있다
RAM, 다음 하나, 그것은 바로 옆에

1814
01:31:17,810 --> 01:31:18,800
오른쪽 옆에.

1815
01:31:18,800 --> 01:31:20,101
그들은 도처에 아니에요.

1816
01:31:20,101 --> 01:31:23,100
그리고 후자의 시나리오, 일
모든 메모리에 여기 저기 있습니다,

1817
01:31:23,100 --> 01:31:25,082
실제로 강력한 기능이 될 수 있습니다.

1818
01:31:25,082 --> 01:31:28,040
때 그러나 우리는 그에게 돌아올 것이다
애호가 데이터 구조에 대해 이야기.

1819
01:31:28,040 --> 01:31:32,260
지금은 배열 단지입니다
연속 메모리의 덩어리,

1820
01:31:32,260 --> 01:31:36,520
요소가 각각
다시, 다시, 다시, 다시하고,

1821
01:31:36,520 --> 01:31:38,050
일반적으로 동일한 유형.

1822
01:31:38,050 --> 01:31:42,630
>> 그래서 당신은에서 생각해 보면
순간 전, 문자열은 무엇인가?

1823
01:31:42,630 --> 01:31:50,460
음, 문자열, Zamyla 등,
Z-A-M-Y-L-A는 기술적 인

1824
01:31:50,460 --> 01:31:51,400
그냥 배열입니다.

1825
01:31:51,400 --> 01:31:53,700
그것은 문자의 배열입니다.

1826
01:31:53,700 --> 01:31:59,250
>> 그래서 우리는 정말이로 그릴 경우 I
메모리의 덩어리로, 이전했다

1827
01:31:59,250 --> 01:32:04,510
이들의 각을 밝혀
문자는 바이트를 차지합니다.

1828
01:32:04,510 --> 01:32:07,630
그리고 그 특별한있다
센티넬 문자, 백 슬래시 0,

1829
01:32:07,630 --> 01:32:12,360
또는 모두 여덟 0 비트, 그
해당 문자열의 끝을 구분한다.

1830
01:32:12,360 --> 01:32:15,090
그래서 문자열, 그것은집니다
아웃, 인용을 끝내 문자열을 인용

1831
01:32:15,090 --> 01:32:20,580
chara-- 단지 배열입니다
실제 데이터 형식 인을 char.

1832
01:32:20,580 --> 01:32:24,560
>> 이제 변수는 argv, meanwhile--
의 다시 프로그램에 가자.

1833
01:32:24,560 --> 01:32:29,582
우리가 말씀을 참조하더라도 ARGV,
문자열은 여기에, 문자열 자체가 아닙니다.

1834
01:32:29,582 --> 01:32:33,640
ARGV, 인수 벡터,
문자열의 배열입니다.

1835
01:32:33,640 --> 01:32:37,620
>> 당신의 배열을 가질 수 있도록 단지로
자, 당신은 높은 수준을 가질 수 있습니다,

1836
01:32:37,620 --> 01:32:46,279
strings--의 배열 때문에, 예를 들면,
나는이 순간을 전 입력 할 때 ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, 공간 Z-A는-M-Y-L-A, 나는 주장
변수는 argv는, 그건 ... ./argv0에서 두 문자열을했다

1838
01:33:00,150 --> 01:33:03,185
및 Z-A-M-Y-L-A. 에서
다른 단어는 argc는 2였다.

1839
01:33:03,185 --> 01:33:03,980
그 이유는 무엇입니까?

1840
01:33:03,980 --> 01:33:08,370
>> 음, 효율적으로, 무슨 일이야
에는 이러한 문자열의 각 그

1841
01:33:08,370 --> 01:33:13,990
물론, 문자의 배열
이전과 같이, 각각 그 문자

1842
01:33:13,990 --> 01:33:15,670
한 바이트까지 소요됩니다.

1843
01:33:15,670 --> 01:33:19,720
그리고 실제 공을 혼동하지 마십시오
0과 프로그램의 이름,

1844
01:33:19,720 --> 01:33:22,040
이는 모든 80 비트를 의미한다.

1845
01:33:22,040 --> 01:33:27,140
그리고 Zamyla 한편, 여전히
또한 문자의 배열.

1846
01:33:27,140 --> 01:33:31,450
>> 하루의 끝에 그래서, 실제로
후드 아래에 다음과 같습니다.

1847
01:33:31,450 --> 01:33:38,800
하지만 어떻게 메인의 자연, argv를
작품은, 내가이 모든 것을 포장 할 수 있습니다

1848
01:33:38,800 --> 01:33:44,810
, 만약에 당신, 더 큰 배열에 최대
우리가 약간 이상 단순화 경우, 그

1849
01:33:44,810 --> 01:33:48,180
사진이 좋아하고 안 모습
아주 거기 확장을 그려,

1850
01:33:48,180 --> 01:33:56,720
이 배열은, 단지 크기 2의 첫 번째입니다
문자열이 포함되어있는 요소,

1851
01:33:56,720 --> 01:33:59,230
의 두 번째 요소
어떤 문자열이 포함되어 있습니다.

1852
01:33:59,230 --> 01:34:01,687
그리고, 차례로, 당신의 경우
종류의 각각 확대

1853
01:34:01,687 --> 01:34:03,770
그 문자열의 무엇을
후드 아래에 참조

1854
01:34:03,770 --> 01:34:07,190
각 문자열은 그냥이다
문자의 배열.

1855
01:34:07,190 --> 01:34:11,680
>> 자, 그냥 문자열로,
우리는 액세스를 얻을 수 있었다

1856
01:34:11,680 --> 01:34:15,260
문자열의 i 번째 문자
그 대괄호 표기법을 사용.

1857
01:34:15,260 --> 01:34:17,320
마찬가지로, 배열과
일반적으로, 우리를 수

1858
01:34:17,320 --> 01:34:22,700
얻을 대괄호 표기법을 사용
배열의 문자열의 수에?

1859
01:34:22,700 --> 01:34:25,100
예를 들어, 저를 보자
가서 이렇게.

1860
01:34:25,100 --> 01:34:32,420
>> 내가 가서 argv1.c을 만들어 보자,
이는 조금 다른이 시간이다.

1861
01:34:32,420 --> 01:34:35,635
대신 argc2 검사의,
내가 대신 이렇게하는거야.

1862
01:34:35,635 --> 01:34:41,270
내가 공을받을 INT, 나는 작
는 argc보다, 내가 플러스 플러스,

1863
01:34:41,270 --> 01:34:47,920
다음,이 내부에 프린트
퍼센트의 새로운 라인, 다음

1864
01:34:47,920 --> 01:34:50,740
argv를 브래킷 난.

1865
01:34:50,740 --> 01:34:55,220
>> 즉 그래서, 내가 다루고 있지 않다
순간 개별 문자.

1866
01:34:55,220 --> 01:35:00,190
ARGV,이 빈 사각형에 의해 묵시적으로
이름 argv를 오른쪽 중괄호,

1867
01:35:00,190 --> 01:35:03,320
문자열의 배열입니다 argv를 의​​미한다.

1868
01:35:03,320 --> 01:35:04,870
그리고는 argc는 int 형입니다.

1869
01:35:04,870 --> 01:35:08,800
>> 여기이 선, 6이며,
세트 말을 내가 공에 동일.

1870
01:35:08,800 --> 01:35:11,980
, 최대 모든 방법을 계산
그러나는 argc, 포함하지 않음.

1871
01:35:11,980 --> 01:35:14,010
그리고 각각의 반복에,
문자열을 인쇄 할 수 있습니다.

1872
01:35:14,010 --> 01:35:14,800
어떤 캐릭터?

1873
01:35:14,800 --> 01:35:17,270
>> 변수는 argv의 i 번째 문자열입니다.

1874
01:35:17,270 --> 01:35:19,530
내가되기 전에 반면 그래서
대괄호를 사용하여

1875
01:35:19,530 --> 01:35:22,180
표기는 i 번째에 도착
지금은 문자열에서 문자,

1876
01:35:22,180 --> 01:35:27,240
나는 광장 브래킷 표기법을 사용하고 있습니다
배열의 i 번째 문자열에서 얻을 수 있습니다.

1877
01:35:27,240 --> 01:35:30,310
그래서 하나의 층의 종류입니다
위의 개념.

1878
01:35:30,310 --> 01:35:35,390
>> 그리고 이것에 대해 깔끔한 무엇
지금 프로그램, 내가 argv1 컴파일하는 경우,

1879
01:35:35,390 --> 01:35:42,067
다음 ./argv1을 수행 한 다음 입력
foo는 바 바즈 같은에서,

1880
01:35:42,067 --> 01:35:45,400
세 가지 기본 단어 a는하는 수 있습니다
컴퓨터 과학자는 시간에 도달

1881
01:35:45,400 --> 01:35:51,010
그 또는 그녀가 어떤 자리 워드를 필요
Enter 키를 누르, 그 단어의 각,

1882
01:35:51,010 --> 01:35:54,980
프로그램의 이름을 포함하는
상기 제 1 위치에서 argv를 인

1883
01:35:54,980 --> 01:35:58,320
끝은 한 번에 하나의 프린트된다.

1884
01:35:58,320 --> 01:36:05,290
그리고 나는 이것을 변경하고, 내가 말할 경우
argv1 Zamyla 찬과 같이,

1885
01:36:05,290 --> 01:36:08,800
우리는 그 중 세 가지 얻을
argv0입니다 즉,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2,이에 있기 때문에
케이스는 argc는 수는 3입니다.

1887
01:36:14,400 --> 01:36:20,020
>> 하지만 깔끔한 것은 당신이 이해하는 경우입니다
그 변수는 argv는 문자열의 단지 배열입니다

1888
01:36:20,020 --> 01:36:24,910
당신은 문자열을 이해
문자의 배열이며

1889
01:36:24,910 --> 01:36:29,470
우리는 실제로 종류의이 사용할 수 있습니다
대괄호 표기법을 여러 번

1890
01:36:29,470 --> 01:36:33,320
문자열을 선택하고 선택합니다
문자열 내에서 문자,

1891
01:36:33,320 --> 01:36:35,730
다음과 깊이로 다이빙.

1892
01:36:35,730 --> 01:36:40,100
이 예에서, 내가 가자
앞서이 argv2.c를 호출합니다.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
그리고이 예에서, 내가 앞서 가자
그리고 난 공을받을 INT의 following--을,

1895
01:36:50,180 --> 01:36:53,286
내가,는 argc 미만 내가 플러스
플러스, 직전있다.

1896
01:36:53,286 --> 01:36:55,910
그래서 지금이 다른 글자 네요에
충분히 복잡 받고있다.

1897
01:36:55,910 --> 01:36:59,940
그리고 내가 말할거야
변수는 argv 문자열을 반복,

1898
01:36:59,940 --> 01:37:01,294
자신에 주석으로.

1899
01:37:01,294 --> 01:37:03,960
그리고 나는이거야
, 루프 중첩 아마하는 당신을

1900
01:37:03,960 --> 01:37:06,290
수행, 또는 고려
스크래치에, 일, 어디

1901
01:37:06,290 --> 01:37:08,600
난 난 int-- 말할거야
다시 나는를 사용하지 않을,

1902
01:37:08,600 --> 01:37:12,590
나는 그림자 싶지 않기 때문에, 또는
종류의 기존 전을 덮어 씁니다.

1903
01:37:12,590 --> 01:37:15,780
>> 나는 때문에, 대신, J 말할거야
즉, 내가 후 변수에 내 이동의

1904
01:37:15,780 --> 01:37:18,590
때 난 단지에 노력하고있어
간단한 숫자를 계산합니다.

1905
01:37:18,590 --> 01:37:28,850
j는 도착를 들어 0-- 또한​​, N, 것입니다
, argv를 브래킷 난의 선미 길이를 얻을

1906
01:37:28,850 --> 01:37:36,030
너무 오래 j는 m 미만으로,
J 플러스 플러스, 다음을 수행하십시오.

1907
01:37:36,030 --> 01:37:37,500
그리고 여기에 흥미로운 부분입니다.

1908
01:37:37,500 --> 01:37:46,330
>> 문자 및 새로운 라인을 인쇄,
argv를 브래킷 난, 브래킷 J를 연결.

1909
01:37:46,330 --> 01:37:47,940
좋아, 그럼 내가 여기에 몇 가지 주석을 추가 할 수 있습니다.

1910
01:37:47,940 --> 01:37:54,820
문자를 반복
현재 문자열,

1911
01:37:54,820 --> 01:38:02,290
i 번째 문자열에 인쇄 j 번째 문자.

1912
01:38:02,290 --> 01:38:04,630
그래서 지금의 고려하자
이러한 의견은 무엇을 의미.

1913
01:38:04,630 --> 01:38:06,750
>> 문자열을 반복
argv--에 얼마나 많은

1914
01:38:06,750 --> 01:38:09,300
문자열 배열하는 것입니다, 변수는 argv에?

1915
01:38:09,300 --> 01:38:13,420
ARGC 많은, 그래서 반복 해요
에서 내가는 argc까지 0과 동일.

1916
01:38:13,420 --> 01:38:20,020
한편, 얼마나 많은 문자
변수는 argv에서 i 번째 문자열에?

1917
01:38:20,020 --> 01:38:22,880
>> 글쎄, 그 대답을 얻기 위해,
난 그냥 문자열 길이를 호출

1918
01:38:22,880 --> 01:38:26,810
현재 문자열 I 관리에
변수는 argv 브래킷 내가 어떤 약.

1919
01:38:26,810 --> 01:38:30,090
그리고 일시적으로 저장하는거야
값 N에 불과 캐싱 목적,

1920
01:38:30,090 --> 01:38:31,590
효율을 기억합니다.

1921
01:38:31,590 --> 01:38:36,330
그리고 나는 0으로 J를 초기화거야
j는보다 n은로 너무 오래 계속,

1922
01:38:36,330 --> 01:38:38,430
각 반복 증가 J에.

1923
01:38:38,430 --> 01:38:41,030
>> 그리고 여기에서, 당
라인 (12)에 대한 나의 의견,

1924
01:38:41,030 --> 01:38:43,390
문자를 인쇄,
새 줄 이어

1925
01:38:43,390 --> 01:38:48,140
구체적으로는 argv 브래킷
나는 나에게 i 번째 문자열을 제공합니다

1926
01:38:48,140 --> 01:38:51,690
argv-- 그래서 첫 번째 단어는
두 번째 단어, 세 번째 단어, 뭐든간에.

1927
01:38:51,690 --> 01:38:57,370
그리고 J의 깊이에서 잠수 및 도착
내가 그 단어의 j 번째 문자.

1928
01:38:57,370 --> 01:39:02,200
그래서, 효과에, 당신은 치료할 수
argv와 다차원으로,

1929
01:39:02,200 --> 01:39:06,050
이차원 배열로서
이에 외모의 모든 단어의 종류

1930
01:39:06,050 --> 01:39:08,580
마음의이 같은
눈 및 모든 문자

1931
01:39:08,580 --> 01:39:10,930
가지로 구성되어있다
열, 즉 도움이된다면.

1932
01:39:10,930 --> 01:39:13,260
>> 실제로, 우리는 때를 애타게
미래의 주에서이 떨어져,

1933
01:39:13,260 --> 01:39:15,580
조금 될 것
보다 더 정교한.

1934
01:39:15,580 --> 01:39:17,800
하지만 당신은 정말 할 수
지금은 그 생각,

1935
01:39:17,800 --> 01:39:22,110
바로이 두 가지 차원으로
그것의 배열, 이에 한 수준

1936
01:39:22,110 --> 01:39:23,260
모든 스트링이다.

1937
01:39:23,260 --> 01:39:26,760
그리고 당신은 더 깊은, 당신이 다이빙하는 경우
개별 문자에서 얻을 수 있습니다

1938
01:39:26,760 --> 01:39:29,600
여기에이 표기법을 사용하여 내부.

1939
01:39:29,600 --> 01:39:31,620
>> 그래서 그물 효과는 무엇인가?

1940
01:39:31,620 --> 01:39:34,970
내가 가서 보자
argv2-- 이놈에게 그것을 확인합니다.

1941
01:39:34,970 --> 01:39:36,210
여기 실수를했다.

1942
01:39:36,210 --> 01:39:40,160
암시 적 선언
라이브러리 함수 스털링.

1943
01:39:40,160 --> 01:39:42,190
그래서 모든 시간, 그것은이다
아마도 적절한

1944
01:39:42,190 --> 01:39:45,130
우리는 일종의 마무리하고 있는지
정확히 우리가 시작했던 곳.

1945
01:39:45,130 --> 01:39:48,160
>> 나는 암시 적으로 선언 망쳐
라이브러리 함수 스털링.

1946
01:39:48,160 --> 01:39:48,987
OK, 분을 기다립니다.

1947
01:39:48,987 --> 01:39:51,070
나는 특히, 그 기억
이후 바로 여기입니다.

1948
01:39:51,070 --> 01:39:54,490
나는에 string.h를 포함해야
프로그램의 버전.

1949
01:39:54,490 --> 01:40:00,050
>> 내가 가서 포함하자
string.h, 그 저장 진행

1950
01:40:00,050 --> 01:40:04,460
및 argv2 다시 컴파일.

1951
01:40:04,460 --> 01:40:08,390
그리고 지금, 우리가 입력 argv2 확인 이동합니다.

1952
01:40:08,390 --> 01:40:10,590
그리고 그것은 조금 비록
첫눈에 비밀,

1953
01:40:10,590 --> 01:40:15,690
실제로, 그 통지, 무엇을
점 argv2 인쇄입니다.

1954
01:40:15,690 --> 01:40:19,970
>> 하지만 난 후 일부 단어를 입력하면
프롬프트 argv2 Zamyla 찬처럼,

1955
01:40:19,970 --> 01:40:22,560
또한, 조금 입력
첫눈에 비밀.

1956
01:40:22,560 --> 01:40:30,540
그러나 우리가 다시 이동하면,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
그래서 우리는 모든 단어를 통해 반복했습니다.

1958
01:40:32,190 --> 01:40:37,770
그리고 다시, 우리는 이상 반복했습니다
단어 내에서 모든 문자.

1959
01:40:37,770 --> 01:40:40,040
>> 자,이 모든 후,
거기 실현

1960
01:40:40,040 --> 01:40:43,120
다른 한 세부 우리는 친절했습니다
이 모든 시간을 무시.

1961
01:40:43,120 --> 01:40:46,180
우리는 단지 떨어져 조롱 무엇
메인의 입력은 할 수 있습니까?

1962
01:40:46,180 --> 01:40:47,780
무엇 주요의 출력은 어떻습니까?

1963
01:40:47,780 --> 01:40:50,540
>> 이 모든 시간, 우리는 봤는데
그냥 복사 및 붙여 넣기

1964
01:40:50,540 --> 01:40:53,870
주 앞의 단어 INT,
당신이 온라인으로 볼 수 있지만,

1965
01:40:53,870 --> 01:40:58,340
때때로 잘못 이전 버전에서
C와 컴파일러, 그들은 무효라고하는 것이

1966
01:40:58,340 --> 01:40:59,410
또는 아무것도 전혀.

1967
01:40:59,410 --> 01:41:01,580
그러나, 실제로의 버전
C의 우리가 사용하는 그,

1968
01:41:01,580 --> 01:41:06,180
C (11), 또는 2011 년 실현
것을 그것은 INT해야합니다.

1969
01:41:06,180 --> 01:41:09,300
그리고 그것은이어야한다
무효 또는는 argc와 argv를 여기에.

1970
01:41:09,300 --> 01:41:10,790
>> 그런데 왜 INT 주?

1971
01:41:10,790 --> 01:41:12,480
실제로 무엇을 반환?

1972
01:41:12,480 --> 01:41:16,280
음,이 시간을 모두 밝혀
언제든지 당신은 프로그램 메인을 작성했습니다

1973
01:41:16,280 --> 01:41:18,440
항상 뭔가를 반환.

1974
01:41:18,440 --> 01:41:19,960
하지만 이렇게 비밀리에 일을하고 있어요.

1975
01:41:19,960 --> 01:41:23,350
>> 그 무언가가있는
INT는 선으로 5 건의한다.

1976
01:41:23,350 --> 01:41:24,225
하지만 INT?

1977
01:41:24,225 --> 01:41:26,100
음,이 거기에
프로그래밍 대회,

1978
01:41:26,100 --> 01:41:29,790
이에 아무것도가없는 경우
잘못된 사라지고 모두가 잘,

1979
01:41:29,790 --> 01:41:34,250
일반적으로 프로그램 및 기능
return-- 다소 counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0은 일반적으로 모두가 잘 나타냅니다.

1982
01:41:38,070 --> 01:41:40,610
당신이 생각 그래서 비록
많은 상황에서 거짓 그것,

1983
01:41:40,610 --> 01:41:42,930
실제로 일반적으로 좋은 일을 의미한다

1984
01:41:42,930 --> 01:41:49,560
>> 한편, 프로그램이 1을 반환하는 경우,
또는 음 1, 5, 또는 음 (42)

1985
01:41:49,560 --> 01:41:52,941
또는 0이 아닌 값,
즉, 일반적으로 의미

1986
01:41:52,941 --> 01:41:54,190
뭔가 잘못왔다.

1987
01:41:54,190 --> 01:41:56,700
사실, 자신의 Mac 또는 PC에,
실제로 본 적이 있습니다

1988
01:41:56,700 --> 01:42:01,050
에러 메시지가있다 그것을
뭔가 다른, 오류가 말한다

1989
01:42:01,050 --> 01:42:04,940
코드 음 (42), 또는 오류 코드
같은 23, 또는 무엇인가.

1990
01:42:04,940 --> 01:42:08,980
그 숫자는 일반적으로 그냥 힌트
프로그래머, 또는 회사에

1991
01:42:08,980 --> 01:42:11,174
즉, 소프트웨어를 만들어
무엇을, 왜, 왜 갔다

1992
01:42:11,174 --> 01:42:13,590
그들은을 통해 검색 할 수 있도록 (듯이)
자신의 문서 또는 코드,

1993
01:42:13,590 --> 01:42:15,465
그리고 알아 무엇
오류가 실제로 의미한다.

1994
01:42:15,465 --> 01:42:18,400
그것은 일반적으로 아니에요
우리에게 유용한 최종 사용자.

1995
01:42:18,400 --> 01:42:20,550
>> 그러나 주요 반환 0, 모두가 잘 때.

1996
01:42:20,550 --> 01:42:23,770
그리고 당신은 지정하지 않는 경우
반환해야합니다 주요 내용,

1997
01:42:23,770 --> 01:42:26,950
그냥 자동 것
당신을 위해 0을 반환합니다.

1998
01:42:26,950 --> 01:42:30,870
하지만 뭔가를 반환
다른 실제로 유용합니다.

1999
01:42:30,870 --> 01:42:34,660
>> 마지막 프로그램에서 저를 보자
가서이 exit.c 전화,

2000
01:42:34,660 --> 01:42:38,630
오늘의 마지막을 소개합니다
오류 코드라고도 주제.

2001
01:42:38,630 --> 01:42:42,930
내가 가서 포함하자 우리
익숙한 파일을 백업 정상은, INT 메인을한다.

2002
01:42:42,930 --> 01:42:49,500
그리고 이번에는, 이제 INT의는 argc을하자
문자열 변수는 argv, 내 브래킷

2003
01:42:49,500 --> 01:42:50,836
이 배열의 것을 의미합니다.

2004
01:42:50,836 --> 01:42:52,460
그리고 나를 그냥 정신 검사를 할 수 있습니다.

2005
01:42:52,460 --> 01:42:56,640
이번에는 argc하지 않는 경우
2 동일, 당신은 알아?

2006
01:42:56,640 --> 01:42:57,520
잊어 버려.

2007
01:42:57,520 --> 01:43:03,170
내가 그런 말을 하겠어, 이봐, 사용자,
당신은 명령 줄 인수를 누락

2008
01:43:03,170 --> 01:43:04,210
백 슬래시 n은.

2009
01:43:04,210 --> 01:43:05,230
>> 그리고 그게 다입니다.

2010
01:43:05,230 --> 01:43:06,130
나는 종료 할 수 있습니다.

2011
01:43:06,130 --> 01:43:11,030
나는, 선제에 갈거야
그리고 중간에 정말 반환

2012
01:43:11,030 --> 01:43:12,810
숫자 1이 아닌 다른.

2013
01:43:12,810 --> 01:43:15,360
첫 번째 가치로 이동
발생할 수있는 오류는 1 개입니다.

2014
01:43:15,360 --> 01:43:17,860
당신은 잘못된 다른이있는 경우
발생할 수있는 상황,

2015
01:43:17,860 --> 01:43:21,390
당신은 반환이 말 또는 3을 반환하거나, 수
어쩌면 음의 1 또는 음의 2.

2016
01:43:21,390 --> 01:43:23,750
>> 이는 종료 코드입니다
이 있으며, 일반적

2017
01:43:23,750 --> 01:43:27,770
단지 프로그래머에게 유용하거나
소프트웨어를 해운 회사입니다.

2018
01:43:27,770 --> 01:43:30,500
그러나 사실은이 있다고
0이 아닌 중요합니다 것입니다.

2019
01:43:30,500 --> 01:43:34,310
그래서이 프로그램의 경우, 내가 원하는
보장하는이 프로그램 만

2020
01:43:34,310 --> 01:43:38,190
사용자가 나에게 제공하는 경우 작동
두 인수 카운트를 갖는,

2021
01:43:38,190 --> 01:43:42,880
프로그램의 이름과 다른
단어, 나는 다음과 같이 많이 적용 할 수 있습니다

2022
01:43:42,880 --> 01:43:46,110
printf와의 말과 사용자에 소리,
명령 행 인수를 누락,

2023
01:43:46,110 --> 01:43:46,970
1을 반환합니다.

2024
01:43:46,970 --> 01:43:49,940
그건 그냥 바로 것이다
프로그램을 종료합니다.

2025
01:43:49,940 --> 01:43:55,840
>> 는 argc이 동일 경우에만 2 우리는 아래로 얻을 것이다
여기, 내가 말할거야 어떤 시점에서,

2026
01:43:55,840 --> 01:44:00,410
안녕하세요 퍼센트의, 백 슬래시 N, argv1.

2027
01:44:00,410 --> 01:44:03,827
즉, 난
변수는 argv 0 후에 않을,

2028
01:44:03,827 --> 01:44:05,410
이는 프로그램의 단지 이름입니다.

2029
01:44:05,410 --> 01:44:09,450
나는, 쉼표, 안녕하세요 인쇄 할
인간 입력 한 두 번째 단어.

2030
01:44:09,450 --> 01:44:12,580
그리고이 경우에에
라인 (13)은, 모두 잘 있습니다.

2031
01:44:12,580 --> 01:44:15,920
>> 저는는 argc 2 것을 알고
논리적으로이 프로그램에서.

2032
01:44:15,920 --> 01:44:17,770
내가 가서 0을 반환하겠습니다.

2033
01:44:17,770 --> 01:44:21,230
여담으로, 명심 그
이뿐만 아니라 스크래치에 해당됩니다.

2034
01:44:21,230 --> 01:44:24,760
>> 논리적으로, 나는이 작업을 수행 할 수
이러한 라인을 캡슐화

2035
01:44:24,760 --> 01:44:27,020
여기 다른 절에서 코드.

2036
01:44:27,020 --> 01:44:29,420
그러나 그것은 일종의이다
불필요하게 코드를 들여 쓰기.

2037
01:44:29,420 --> 01:44:31,800
그리고 슈퍼를 만들고 싶어
명확한 상관없이 그,

2038
01:44:31,800 --> 01:44:34,670
기본적으로, 안녕하세요
일이 인쇄되는 것

2039
01:44:34,670 --> 01:44:36,050
사용자가 협력으로 너무 오래.

2040
01:44:36,050 --> 01:44:39,360
>> 그래서 사용하는 것이 매우 일반적입니다
조건, 단지의 경우,

2041
01:44:39,360 --> 01:44:41,870
몇 가지 오류를 잡으려고
상황을 한 다음 종료합니다.

2042
01:44:41,870 --> 01:44:45,690
그리고, 너무 오래 전부입니다
물론, 그렇지 않은 경우가없는,

2043
01:44:45,690 --> 01:44:48,060
하지만 단지 코드가
그 밖에,이 때문에 경우

2044
01:44:48,060 --> 01:44:51,060
이 동등한
특별한 경우, 논리적으로.

2045
01:44:51,060 --> 01:44:54,480
그래서 난 그냥에 0을 반환하고 있습니다
명시 적으로 모든 잘 의미.

2046
01:44:54,480 --> 01:44:58,480
>> 내가 반환 0을 생략 할 경우, 그것은 것
자동으로 나를 위해 가정한다.

2047
01:44:58,480 --> 01:45:00,890
하지만 지금은 돌아 오는거야 있음
적어도이 경우 한

2048
01:45:00,890 --> 01:45:04,940
내가 좋은 측정을 위해,에 갈거야 및
선명도,이 경우에는 0을 반환한다.

2049
01:45:04,940 --> 01:45:09,690
그래서 지금 내가 가서 출구를 만들어 보자,
이는 바로 떠날 수있는 완벽한 SEGUE이다.

2050
01:45:09,690 --> 01:45:14,401
>> 그러나 출구를 확인하고 나를 가자
앞서 및 ./exit을 입력합니다.

2051
01:45:14,401 --> 01:45:16,900
그리고 프로그램은 나에게 소리 쳤다
명령 행 인수가 없습니다.

2052
01:45:16,900 --> 01:45:18,120
OK, 내가 협력 할 수 있습니다.

2053
01:45:18,120 --> 01:45:23,810
>> 나를 대신 ./exit을하자, 다윗은, 입력합니다.

2054
01:45:23,810 --> 01:45:25,190
그리고 지금은 안녕하세요 데이비드 말했다.

2055
01:45:25,190 --> 01:45:27,300
그리고 당신은 일반적으로이 표시되지 것입니다.

2056
01:45:27,300 --> 01:45:30,650
>> 그러나 그것은이 있다고 밝혀
실제로 볼 수있는 리눅스의 특별한 방법

2057
01:45:30,650 --> 01:45:34,470
무엇 종료 코드로 프로그램이 종료.

2058
01:45:34,470 --> 01:45:37,184
때때로 그래픽에
맥 OS 또는 Windows와 같은 세계,

2059
01:45:37,184 --> 01:45:40,100
당신은이 숫자 참조
에러 메시지가 화면에 팝업

2060
01:45:40,100 --> 01:45:41,940
프로그래머
당신에게 그 번호를 보여줍니다.

2061
01:45:41,940 --> 01:45:44,773
그러나 우리는 어떤 오류가보고 싶다면
메시지는 우리가 그것을 here-- 할 수있다

2062
01:45:44,773 --> 01:45:48,100
그래서 ./exit, 입력, 인쇄
명령 행 인수가 없습니다.

2063
01:45:48,100 --> 01:45:54,590
>> 지금 에코 $을?한다면 어느입니다
보고 엄청나게 비밀.

2064
01:45:54,590 --> 01:45:56,590
하지만 $?

2065
01:45:56,590 --> 01:45:59,220
마법의 주문입니다
즉, 말한다 헤이, 컴퓨터,

2066
01:45:59,220 --> 01:46:01,900
말해 무엇 이전을
프로그램의 종료 코드이었다.

2067
01:46:01,900 --> 01:46:03,410
그리고 Enter를 누르십시오.

2068
01:46:03,410 --> 01:46:07,520
그 때문에 나는 1 참조 내가
반환 내 주요 기능을 말했다.

2069
01:46:07,520 --> 01:46:12,310
>> 한편, 내가 다윗을 ./exit 할 경우,
나는, 안녕하세요 데이비드을 참조 Enter 키를 누릅니다.

2070
01:46:12,310 --> 01:46:16,800
지금 에코 $을한다면? 나는 0 안녕하세요 참조하십시오.

2071
01:46:16,800 --> 01:46:19,080
그리고 이것은 실제로 것
유용한 정보가 될

2072
01:46:19,080 --> 01:46:23,420
디버거의 맥락, 그리에
당신이 인간이, 신경 것이라고 많은.

2073
01:46:23,420 --> 01:46:26,060
그러나 디버거 및 기타
프로그램은 우리가 이번 학기를 사용합니다

2074
01:46:26,060 --> 01:46:29,420
종종 그 번호 볼 것이다,
그것은 일종의 숨어 비록

2075
01:46:29,420 --> 01:46:32,780
당신은에 그것을보고하지 않는
결정 프로그램의 여부

2076
01:46:32,780 --> 01:46:37,050
실행은 올바른 또는 잘못된이었다.

2077
01:46:37,050 --> 01:46:40,450
>> 그리고 그것은 우리에게 가져다
이, 하루의 끝에서.

2078
01:46:40,450 --> 01:46:43,917
우리는보고 오늘 시작
디버깅 및 과정에 차례로

2079
01:46:43,917 --> 01:46:46,750
자체 한 다음 더 흥미롭게도,
기술적으로 후드 아래에

2080
01:46:46,750 --> 01:46:49,490
무엇 문자열이 지속되는입니다
당연한 주에 우리는 그냥했다

2081
01:46:49,490 --> 01:46:51,900
확실히 그들을했다
대한 스크래치 부여.

2082
01:46:51,900 --> 01:46:56,040
>> 우리는 우리가 액세스 할 수있는 방법을 보았다
문자열에서 개별 문자,

2083
01:46:56,040 --> 01:47:00,310
다시 높은 수준했다
저기 ... 어떻게보고, 사물을 보면

2084
01:47:00,310 --> 01:47:04,226
우리는 개인에 얻으려면
구조와 같은 목록의 요소,

2085
01:47:04,226 --> 01:47:05,850
우리는 여러 문자열을 할 수없는 이유는 무엇입니까?

2086
01:47:05,850 --> 01:47:08,050
그리고 우리는 명령 행 인수 할 수 있습니다.

2087
01:47:08,050 --> 01:47:12,800
그러나 여기 그냥 상자의이 사진
이 일반적인 개념의 실증이다

2088
01:47:12,800 --> 01:47:14,451
배열 또는리스트 또는 벡터.

2089
01:47:14,451 --> 01:47:16,450
그리고에 따라
문맥,이 모든 단어

2090
01:47:16,450 --> 01:47:17,880
약간 다른 것을 의미한다.

2091
01:47:17,880 --> 01:47:20,060
그래서 C에서, 우리는거야
배열에 대해 이야기합니다.

2092
01:47:20,060 --> 01:47:23,840
그리고 배열 ​​덩어리입니다
메모리, 누구의 각각의

2093
01:47:23,840 --> 01:47:27,720
요소는, 뒷, 인접
뒤로, 백업, 백업합니다.

2094
01:47:27,720 --> 01:47:31,970
>> 이들 요소는, 일반적으로, 아르
동일한 데이터 타입, 캐릭터

2095
01:47:31,970 --> 01:47:35,966
문자, 캐릭터, 캐릭터, 또는
문자열, 문자열, 문자열, 문자열, 또는 INT,

2096
01:47:35,966 --> 01:47:38,600
그것이 무엇이든 INT, INT,
우리는 가게에 노력하고 있습니다.

2097
01:47:38,600 --> 01:47:42,540
그러나 결국이있다
무엇 개념적처럼 보인다.

2098
01:47:42,540 --> 01:47:44,530
당신이 가지고있는 당신의
컴퓨터의 메모리 또는 RAM.

2099
01:47:44,530 --> 01:47:48,590
그리고 당신은에 그것을 밖으로 조각하고
동일 크기의 상자, 모두의

2100
01:47:48,590 --> 01:47:50,920
에, 다시, 돌아
다시,이 방법으로 백업합​​니다.

2101
01:47:50,920 --> 01:47:53,200
>> 그리고에 대한 좋은거야
이 아이디어와 사실

2102
01:47:53,200 --> 01:47:58,580
우리는 이러한 방식으로 값을 표현할 수 있다는
우리의 데이타 구조와 제

2103
01:47:58,580 --> 01:48:02,520
클래스에서, 우리는 시작할 수 있습니다 의미
코드 문제를 해결할

2104
01:48:02,520 --> 01:48:04,079
그 주 0 그렇게 직관적했다.

2105
01:48:04,079 --> 01:48:05,870
당신은 전화를 기억합니다
책 예제​​, 어디

2106
01:48:05,870 --> 01:48:09,110
우리는 나누기를 사용 정복
또는 이진 검색 알고리즘

2107
01:48:09,110 --> 01:48:13,220
전체를 통해 선별하는
이름과 전화 번호의 무리.

2108
01:48:13,220 --> 01:48:18,220
그러나 우리는 리콜을 가정하는 그
전화 번호부는 이미 분류 된

2109
01:48:18,220 --> 01:48:21,630
다른 사람이 이미 있다고
해서 돌출 이름의 목록을 제공 한 체격

2110
01:48:21,630 --> 01:48:24,430
그들을 알파벳순하는 방법을 numbers--.

2111
01:48:24,430 --> 01:48:26,950
그리고 지금 C에서 우리는,
도 능력을 가지고

2112
01:48:26,950 --> 01:48:30,290
, 일을하지 배치하기
물리적으로 전화 번호부에

2113
01:48:30,290 --> 01:48:34,220
그러나 사실상 컴퓨터에서
메모리는 우리가 할 다음 주에있을 것입니다

2114
01:48:34,220 --> 01:48:38,470
처음이 항아리 다시 소개
array-- 우리의 데이터 구조

2115
01:48:38,470 --> 01:48:43,530
하지만 더 중요한 것은, 실제 컴퓨터
과학 알고리즘 구현

2116
01:48:43,530 --> 01:48:47,720
코드에서있는 우리는 저장할 수 있습니다
이 같은 구조의 데이터,

2117
01:48:47,720 --> 01:48:50,730
다음을 조작하기 시작하고,
실제로 문제를 해결하기 위해,

2118
01:48:50,730 --> 01:48:53,570
그 위에 구축,
궁극적으로, C에서 프로그램,

2119
01:48:53,570 --> 01:48:56,730
파이썬, 자바 스크립트,
SQL과 데이터베이스를 쿼리?

2120
01:48:56,730 --> 01:48:59,980
>> 그리고 우리는 이러한 모든 것을 볼 수 있습니다
연동 다른 생각.

2121
01:48:59,980 --> 01:49:04,100
하지만 지금은 리콜
우리가 오늘 소개 도메인

2122
01:49:04,100 --> 01:49:06,920
이 물건은 여기이고,
암호의 세계.

2123
01:49:06,920 --> 01:49:11,200
그리고 다음 문제 당신 자신을 중
해결 암호화의 예술입니다 것입니다,

2124
01:49:11,200 --> 01:49:13,630
스크램블 및 디 스크램블
정보 및 암호화

2125
01:49:13,630 --> 01:49:15,930
텍스트를 해독,
궁극적으로 가정

2126
01:49:15,930 --> 01:49:18,970
당신은 지금 알고있는 것을
후드 아래에있다

2127
01:49:18,970 --> 01:49:21,860
그래서 당신은 참조하거나받을 때
이 같은 메시지를

2128
01:49:21,860 --> 01:49:24,060
자신은 그것을 해독 할 수 있습니다.

2129
01:49:24,060 --> 01:49:26,740
이 모든, 그리고 더 많은 다음 번에.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO 재생]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover는 도착했다.

2133
01:49:32,970 --> 01:49:35,146
나는 방문을 갈거야
그의 대학 교수.

2134
01:49:35,146 --> 01:49:37,611
네.

2135
01:49:37,611 --> 01:49:40,080
안녕.

2136
01:49:40,080 --> 01:49:40,660
그것은 당신입니다.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
기다림!

2139
01:49:45,110 --> 01:49:45,610
데이비드.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
난 그냥 내려고 노력하고있어
당신에게 무슨 일이 일어 났는지.

2142
01:49:56,060 --> 01:49:58,130
, 아무것도 도움이 될하시기 바랍니다.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
당신은 자신의 대학이었다
룸메이트, 당신은하지 않았다?

2145
01:50:08,354 --> 01:50:10,770
당신은 그 때 함께 있었다
그는 CS50 프로젝트를 완료?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [음악 재생]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> - 그건 CS50했다.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> 나는이 장소를 좋아합니다.

2152
01:50:44,770 --> 01:50:45,854
>> 최대 -Eat.

2153
01:50:45,854 --> 01:50:47,020
우리는 사업을 것입니다.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END 재생]

