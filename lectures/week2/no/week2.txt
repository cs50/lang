[MUSIKK] 

DAVID J. MALAN: Greit. Dette er CS50 og dette er starten av uke 2. Og du husker at over de siste par ukene, vi har vært innføring av datamaskin vitenskap og i sin tur programmering. 

Og vi begynte historien ved hjelp av Scratch, som grafisk språk fra MIT Media Lab. Og så sist, forrige uke, gjorde vi innføre en higher-- en lavere nivå språk kjent som C, noe som er rent tekstlig. Og, ja, sist gang vi utforsket innenfor den konteksten en rekke begreper. 

Dette, husker, var det veldig første programmet vi så på. Og dette programmet, rett og slett, skrives ut, "hallo, verden." Men det er så mye tilsynelatende magiske skjer. Det er denne #include med disse vinkelparenteser. Det er int. Det er (void). Det er parenteser, klammeparentes, semikolon, og så mye mer. 

Og så, husker at vi introdusert Scratch slik at vi kunne, ideelt sett, se forbi som syntaks, ting det er egentlig ikke alt som intellektuelt interessant, men tidlig på er, absolutt, litt vanskelig å vikle tankene dine rundt. Og faktisk en av de mest vanlige ting tidlig i et programmerings klasse, spesielt for de mindre behagelig, er å bli frustrert av og utløst opp av visse syntaktiske feil, og ikke minst logiske feil. Og så blant våre mål i dag, faktisk, vil være å utstyre deg med noen problemløsning teknikker for hvordan å bedre løse problemene selv i form av feilsøking. Og du husker også at den miljø som vi innførte siste gang ble kalt CS50 IDE. Dette er web-basert programvare som kan du programmere i skyen, så å si, samtidig som alle dine filer sammen, som vi igjen vil i dag. Og minner om at vi revisited disse temaene her, blant dem funksjoner og looper, og variabler, og boolske uttrykk, og forhold. Og faktisk noen flere som vi oversatt fra verden av Scratch til en verden av C. 

Men grunnleggende bygge blokker, så å si, var egentlig fortsatt det samme forrige uke. Faktisk er vi egentlig bare hadde en annerledes puslespill brikke, hvis du vil. I stedet for det purpur redde blokk, vi i stedet hadde printf, som er denne funksjonen i C som kan du skrive ut noe og formatere den på skjermen. Vi introduserte CS50 Bibliotek, hvor du nå har til disposisjon get_char, og get_int, og get_string, og noen andre funksjoner som vel, via som du kan få innspill fra brukerens eget tastatur. Og vi tok en titt på ting som disse-bool, og røye, og double, float, int, long_long streng. Og det er til og med andre datatyper i C. 

Med andre ord, når du deklarerer en variabel til å lagre noen verdi, eller når du implementerer en funksjon som returnerer en viss verdi, du kan spesifisere hva type verdi som er. Er det en streng, som en sekvens av tegn? Er det et antall, for eksempel et heltall? Er det et flyt verdi eller lignende? Så i C, i motsetning til Scratch, vi faktisk begynte å spesifisere hva slags data vi var tilbake eller hjelp. 

Men, selvfølgelig, også kjørte vi inn noen grunnleggende grensene for databehandling. Og i særdeleshet, dette språket C, tilbakekalling at vi tok en titt på Heltallsoverflyt, virkeligheten at hvis du bare har en begrenset mengde minne eller, spesielt, et endelig antall bits, kan du bare telle så høyt. Og så har vi sett på dette eksemplet her hvor en teller i et fly,, faktisk, hvis du kjører lenge nok ville overflyt og resultere i en programvare en faktisk fysisk mulig feil. 

Vi så også på flytende punkt upresishet, virkeligheten som med bare et endelig antall bits, enten det er 32 eller 64, du kan bare spesifisere så mange tall etter et desimaltegn, etter som du begynner å få upresise. Så for eksempel, en tredjedel i verden her, i vår menneskelige verden, vi vet er bare et uendelig antall av 3s etter desimaltegnet. Men en datamaskin kan ikke nødvendigvis representerer et uendelig antall tall hvis du bare lar det noen begrenset mengde informasjon. 

Så ikke bare gjorde vi utstyre deg med større kraft i form på hvordan du kan uttrykke deg på et tastatur i form av programmering, vi også begrenset hva du kan faktisk gjøre. Og ja, feil og feil kan oppstå fra slike saker. Og faktisk, blant temaene i dag kommer til å være som debugging emner og faktisk ser under panseret på hvordan ting ble innført i forrige uke faktisk blir gjennomført slik at du bedre forstå både egenskapene til og begrensningene i et språk som C. 

Og faktisk, vil vi skrelle tilbake lagene av de enkleste av datastrukturen, noe som kalles en matrise, som Scratch skjer å kalle en "liste". Det er litt annerledes i den sammenheng. Og så får vi også presentere en av de første av våre domenespesifikke problemer i CS50, en verden av kryptografi, kunsten scrambling eller i ciphering informasjon slik som du kan sende hemmelige meldinger og dekode hemmelige meldinger mellom to personer, A og B. 

Så før vi overgang til den nye verden, la oss prøve å utstyre deg med noen teknikker som du kan eliminere eller redusere i det minste noen av frustrasjonene at du sannsynligvis har møtt den siste uken alene. Faktisk, før du such-- noen av dine første problemene i C. Og oddsen er, Hvis du er som meg, første gang du prøver å skrive ut et program, selv om du tror logisk programmet er ganske enkel, du kan godt treffer en vegg, og kompilatoren er ikke til å samarbeide. Gjør eller klang ikke kommer å faktisk gjøre din budgivning. 

Og hvorfor kan det være? Vel, la oss ta en titt på, kanskje et enkelt program. Jeg kommer til å gå videre og lagre dette i en fil bevisst kalt buggy0.c, fordi jeg vet at det å være feil på forhånd. Men jeg kan ikke forstå at hvis dette er den første eller andre eller tredje program at jeg faktisk gjør meg selv. Så jeg kommer til å gå videre og skriver ut, int main (void). Og så innsiden av mine klammeparentes, en veldig kjent ( "Hei, world-- backslash, n ") - og et semikolon. 

Jeg har lagret filen. Nå kommer jeg til å gå ned til min terminal vindu og type make buggy0, fordi, igjen, navnet på filen i dag er buggy0.c. Så jeg skriver gjøre buggy0, Enter. 

Og, ja, jøss, husker fra forrige gang at ingen feilmeldinger er en god ting. Så ingen utgang er en god ting. Men her har jeg klart et antall feil. 

Så den første linjen i produksjonen etter å ha skrevet lage buggy0, husker, er klang er ganske ordrik utgang. Under panseret, CS50 IDE er konfigurert å bruke en hel haug med alternativer med denne kompilatoren slik at du ikke trenger å tenke på dem. Og det er alt som førstelinje middel som starter med klang. 

Men etter det, problemene begynner å gjøre sitt utseende. Buggy0.c på linje 3, karakter 5, er det en stor, rød feil. Hva er det? Implisitt erklære bibliotek funksjon printf med type int (const char *, ...) [-Werror]. Jeg mener, det svært raskt blir veldig uforståelige. Og sikkert, først øyekast, ville vi ikke forvente deg å forstå helheten av den meldingen. Og så en av leksjonene for i dag kommer å være å prøve å legge merke mønstre, eller lignende ting, feil du kan ha oppstått i det siste. Så la oss erte hverandre bare de ordene som ser kjent ut. Den store, røde feil er klart symbolsk for noe være galt. 

implisitt erklære bibliotek funksjon printf. Så selv om jeg ikke helt forstår hva implisitt erklære bibliotek funksjon midler, problemet sikkert relatert til printf eller annen måte. Og kilden til dette problemet har å gjøre med å erklære det. 

Erklærte en funksjon er nevne det for første gang. Og vi brukte terminologien i forrige uke erklære en funksjon prototype, enten med en linje på toppen av din egen fil eller i en såkalt topptekstfilen. Og i hvilken fil gjorde vi sier i forrige uke at printf er sitat, unquote, erklærte? I hvilken fil er sin prototype? 

Så hvis du husker, det aller første jeg skrevet, nesten hvert program siste tid-- og tilfeldigvis et øyeblikk siden startet skrive myself-- var dette en her-- hash-- #include <stio-- for input / output-- dot h Og ja, hvis jeg nå lagre denne filen, jeg kommer å gå videre og klare skjermen min, som du kan gjøre ved å skrive Klar, eller du kan holde kontroll L, bare for å tømme terminalvindu bare for å eliminere noen rot. 

Jeg kommer til å gå videre og re-type make buggy0, Enter. Og voila, jeg fortsatt se at lang kommando fra klang, men det er ingen feilmelding denne gangen. Og ja, hvis jeg gjør ./buggy0, akkurat som forrige gang, hvor prikk betyr dette katalog, Slash bare betyr, her kommer navnet på programmet og at navnet på programmet er buggy0, Enter, "Hei, verden." 

Nå, hvordan kan du ha sanket denne løsningen uten nødvendigvis gjenkjenne så mange ord som jeg gjorde, i hvert fall, ha gjort dette i så mange år? Vel, skjønner per første problemet sett, vi introdusere deg til en kommando at CS50 egne ansatte skrev kalt help50. Og ja, det gjør C spesifikasjon oppgavesettet om hvordan man skal bruke dette. 

Men help50 er egentlig et program som CS50 ansatte skrev som lar deg kjøre en kommando eller kjøre et program, og hvis du ikke forstår sin utgang, for å passere sin produksjon til help50, noe som medførte at programvaren at kurset ansatte skrev vil se på programmet utgang linje for linje, tegn for tegn. Og hvis vi, de ansatte, gjenkjenne feilmelding om at du opplever, Vi vil prøve å provosere deg litt retoriske spørsmål, med noen råd, mye som en TF eller en CA eller meg selv ville gjøre personlig i kontortiden. 

Så se til help50 hvis du ikke nødvendigvis å gjenkjenne et problem. Men ikke stole på det for mye som en krykke. Gjerne prøve å forstå sin produksjon og deretter lære av det slik at bare en eller to ganger gjør du noen gang kjørt help50 for en bestemt feil beskjed. Etter det, bør du være bedre rustet selv å finne ut hva det egentlig er. 

La oss gjøre en annen her. La meg gå videre, og i en annen fil vi kaller dette buggy1.c. Og i denne filen er jeg kommer til å deliberately-- men later som jeg ikke forstå hva feil jeg har gjort. 

Jeg kommer til å gå videre og gjøre dette-- #include, siden jeg har lært min lekse fra et øyeblikk siden. Int main (void), som før. Og så her jeg kommer å gjøre streng s - get_string. Og husker fra forrige gang dette betyr, hei, datamaskin, gi meg en variabel, kaller det er, og gjøre den type som variabel en streng så jeg kan lagre ett eller flere ord i den. 

Og så på høyre hånd side av likhetstegnet er get_string, som er et funksjon i CS50 biblioteket som gjør akkurat det. Det blir en funksjon og deretter hender det fra høyre mot venstre. Så dette likhetstegnet betyr ikke "Lik" som vi kanskje tror i matematikk. Det betyr oppdrag fra høyre til venstre. Så dette betyr, ta strengen fra brukeren og lagre den på innsiden av s. 

Nå la oss bruke den. La meg gå videre nå og som andre linje, la meg gå videre og si "Hei" - ikke "verden", men "hallo,% S- som er vår plassholder, komma s, som er vår variabel, og deretter et semikolon. Så hvis jeg ikke skru opp for mye her, dette ser ut som riktig kode. 

Og mine instinkter nå er å kompilere den. Filen heter buggy1.c. Så jeg kommer til å gjør buggy1, Enter. Og søren-det, hvis det ikke finnes enda flere feil enn før. Jeg mener, det er mer feilmeldinger det would synes enn faktiske linjer i dette programmet. 

Men takeaway her er, selv om du er overveldet med to eller tre eller fire feilmeldinger, fokuserer alltid på veldig første av disse meldingene. Ser på det øverste ett, rulle opp igjen som må være. Så her skrev jeg make buggy1. Her er det klang utgang som forventet. 

Og her er den første røde feilen. Bruk av svart identifikator string, jeg mener standarden i? Så standard i er faktisk noe annet. Det refererer til brukerens tastatur, i hovedsak. 

Men det er ikke det jeg mente. Jeg mente streng, og jeg mente get_string. Så hva er det som jeg glemte å gjøre denne gangen? Hva mangler denne gangen? Jeg har min #include, så jeg har tilgang til printf. 

Men det har jeg ikke tilgang til ennå? Vel, akkurat som forrige gang, Jeg trenger å fortelle kompilatoren Klang hva disse funksjonene er. Get_string kommer ikke med C. og spesielt det kommer ikke i header fil,. Den kommer i stedet inn noe ansatte skrev: som er en annen fil nevne men treffende navn. 

Så ved å legge at en linje av code-- tilbakekalling fra forrige gang at når klang går, kommer det til å se på koden min topp til bunn, venstre til høyre. Det kommer til å legge merke til, oh, du ønsker. La meg gå og finne det, hvor det er på serveren, kopiere og lime, i hovedsak, inn i toppen av din egen fil slik at på dette punktet i historien, linje 1, resten av programmet kan faktisk bruke noen av funksjonene der, blant dem get_string. Så jeg kommer til å ignorere resten av disse feilene, fordi jeg faktisk mistenker at det bare den første faktisk betydde noe. Og jeg kommer til å gå videre og reprise, etter lagring filen min gjør buggy1. Og voila, det fungerte. Og hvis jeg gjør ./buggy1 og skriv inn, for eksempel, Zamyla, jeg nå vil få hallo, Zamyla, i stedet for hallo, verden. 

Greit. Så gatekjøkken her da skal, en, kan du prøve å fange opp så mye som mulig fra feilmeldingene alene, på jakt på noen av de gjenkjennelige ord. Sperring at bruker help50 per oppgavesettet spesifikasjonen. Men sperring det også, alltid se på toppen feilen bare, i det minste innledningsvis, for å se hva slags informasjon det kan faktisk gi. Men det viser seg at det er enda mer funksjonalitet inne inn i CS50 biblioteket for å hjelpe du tidlig i semesteret og tidlig i programmering finne ut hva som går galt. Så la oss gjøre et annet eksempel her. Jeg kommer til å kalle denne buggy2, som igjen, kommer til å være feil ut av porten, ved design. 

Og jeg kommer til å gå videre og gjøre #include. Og så kommer jeg til å gjøre int main (void). Og så kommer jeg til å gjøre en for loop. For (int i _ 0. i er mindre enn eller lik ti. i ++, og deretter i klammeparentes, kommer jeg å skrive ut bare en hashtag symbol her og en ny linje karakter. 

Så min hensikt med dette Programmet er ganske enkelt å veksle 10 ganger og på hver iterasjon av at sløyfe hver gang gjennom syklusen, skrive ut en hashtag, en hashtag, en hashtag. Én per linje fordi jeg har den nye linjen der. Og minner om at det for loop, per siste week-- og du får mer kjent med syntaks ved å bruke det med praksis før long-- dette gir meg en variabel som heter jeg, og setter den til 0. 

Dette intervaller jeg på hver iterasjon av en. Så jeg går til 1 til 2-3. Og så denne tilstanden i midt mellom semikolon blir sjekket på hver iterasjon å gjøre sikker på at vi fortsatt er innenfor rekkevidde. Så jeg ønsker å gjenta 10 ganger, så jeg har liksom veldig intuitivt bare satt 10 som min øvre grense der. 

Og likevel, når jeg kjører dette, etter kompilere det med make buggy2-- og det gjør kompilere OK. Så jeg har ikke en syntax error denne gangen. La meg gå videre nå og kjøre buggy2, Enter. Og nå bla opp. Og la meg øke størrelsen på vinduet. 

Jeg ser ut til å ha en, to, tre, 4, 5, 6, 7, 8, 9, 10, 11. Så det er 11 hashtags, selv om Jeg tydelig satt 10 inne i denne sløyfen. Nå kan noen av dere ser umiddelbart hvilken feilen er fordi faktisk denne er ikke en veldig vanskelig feil å gjøre. Men det er veldig vanlig gjort svært tidlig. 

Det jeg ønsker å påpeke, skjønt, er, hvordan kan jeg finne ut av dette? Vel, det viser seg at den CS50 biblioteket kommer med ikke bare get_string og get_int og get_float og andre funksjoner. Den kommer også med en spesiell funksjon kalt eprintf, eller feil printf. Og det eksisterer kun for å gjøre det litt enklere for deg når debugging koden for å bare skrive ut en feilmelding på skjermen og vet hvor den kom fra. 

Så for eksempel, en ting jeg kan gjøre her med denne funksjonen er dette-- eprintf, og da kommer jeg til å gå videre og si jeg er nå% i, skråstrek, n. Og jeg kommer til å plugge i verdien av i. Og opp toppen, fordi dette er i CS50 biblioteket, Jeg kommer til å gå videre og inkluderer så jeg har tilgang til denne funksjonen. Men la oss vurdere hvilken linje 9 er ment å gjøre. Jeg kommer til å slette dette til slutt. Dette har ingenting å gjøre med min overordnede mål. Men eprintf, feil printf, er bare ment å gi meg noen diagnostisk informasjon. Når jeg kjører mitt program, jeg ønsker å se dette på skjermen midlertidig så vel bare å forstå hva skjer. 

Og, faktisk, på hvert gjentakelse her på linje 9 Jeg ønsker å se, hva er verdien av jeg? Hva er verdien av i? Hva er verdien av i? Og, forhåpentligvis, skal jeg bare se at meldingen også, 10 ganger. 

Så la meg gå videre og rekompilere programmet mitt, så jeg må gjøre som helst Jeg gjør en endring. ./buggy2. Og now-- OK. Det er mye mer å gå på. Så la meg bla opp i en enda større vindu. 

Og vil du se at hver av hashtag er fortsatt utskrift. Men i mellom hver av dem er nå dette diagnostikk utgang formateres som følger. Navnet mitt program her er buggy2. Navnet på filen er buggy2.c. Linjen tallet som dette ble skrevet er linje 9. Og deretter til høyre for den som er feilmelding om at jeg er gravid. 

Og hva er fint om dette er at nå jeg trenger ikke å nødvendigvis telle i hodet mitt hva min programmet gjør. Jeg kan se at på første iterasjon i er 0, så en, så to, så tre, så fire, så 5, deretter 6, deretter 7, deretter 8, deretter 9, deretter 10. Så vent litt. Hva foregår her? Jeg fortsatt synes å telle som forutsatt opp til 10. 

Men hvor kom jeg begynne? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Så 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11. finger er en indikasjon på problemet. Jeg synes å ha regnet feil i min loop. Snarere enn å gå 10 gjentakelser, Jeg begynner på 0, Jeg endte på og gjennom 10. Men fordi, som en datamaskin, Jeg begynner å telle på 0, Jeg skal telle opp til, men ikke gjennom, 10. 

Og så fikse, jeg til slutt realisert her, er en av to ting. Jeg kunne veldig enkelt si teller opp til mindre enn 10. Så 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, som er faktisk riktig, selv om det høres litt feil. Eller jeg kunne gjøre mindre enn eller lik til ni, så lenge jeg starter på 0. Eller hvis du virkelig ikke liker det, kan telle opp til 10, men starter på en. Men igjen, dette er bare ikke så vanlig. I programming-- riktignok ikke så mye i Scratch-- men i programmering i C og andre språk, som Javascript og Python og andre, er det bare veldig vanlig for vår diskusjon av binære å bare begynne å telle på laveste tallet du kan, som er 0. Greit. Så det er eprintf. Og igjen, nå som jeg har funnet ut min problem, og jeg kommer til å gå tilbake til 0 gjennom mindre enn 10, skal jeg å gå inn og slette eprintf. 

Det bør ikke være der når jeg sende min kode eller sender min kode eller vise det til noen andre. Det er egentlig bare ment som skal brukes midlertidig. Men nå har jeg fikset dette spesielt problem i tillegg. 

Vel, la oss gjøre enda et eksempel her at jeg kommer til å piske opp som følger. Jeg kommer til å gå videre og # include. $ 50 Og jeg kommer til å gå videre og #include. 

Og jeg kommer til å spare denne filen som buggy3.c. Og jeg kommer til å gå videre og erklære int main (void). Og så innsiden av det Jeg kommer til å gjøre int i _ - Jeg ønsker å gjennomføre et program med en get_negative_int. Dette er ikke en funksjon som eksisterer ennå. Så vi kommer til å gjennomføre det i bare et øyeblikk. Men vi kommer til å se hvorfor det er buggy ved første passering. Og når jeg har fått en int fra brukeren, Jeg skal bare skrive% i er en negativ heltall, skråstrek, n, komma, jeg. Med andre ord, alt jeg vil dette programmet å gjøre er å få en negativ int fra brukeren og deretter skrive ut at slik og slik er en negativ int. 

Nå trenger jeg å implementere denne funksjonen. Så senere i filen min, jeg kommer til å gå videre og erklærer en funksjon som heter get_negative_int (void) - og vi vil komme tilbake til hva den linjen betyr igjen i en moment-- int n; do-- do den following-- printf n er :. Og så kommer jeg til å gjøre n - get_int, og gjøre dette mens n er større enn 0. Og så tilbake n ;. 

Så det er mye som skjer i dette, men ingen av dem vi ikke ser på forrige uke, minst kort. Så på linje 10 her har jeg erklært funksjon kalt get_negative_int, og jeg har satt (void), i parentes, årsaken er denne tar ikke en inngang. Jeg er ikke bestått noe til denne funksjonen. Jeg bare får noe tilbake fra den. 

Og hva jeg håper å komme tilbake er et heltall. Det er ingen datatype i C kalles negative_int. Det er bare int, så det kommer å være på oss for å være sikker at verdien som faktisk er returneres, er ikke bare en int men er også negativ. 

På linje 12 er jeg erklære en variabel kalt n og gjør det av type int. Og så i linje 13 gjennom 18 Jeg er gjøre noe mens noe er sant. Jeg går videre og utskrift n er, kolon, og deretter et mellomrom, som en ledetekst for brukeren. 

Jeg så ringer get_int og lagring av sin såkalte returverdi i den variabelen n. Men jeg kommer til å fortsette å gjøre dette mens n er større enn 0. Med andre ord, hvis brukeren gir meg en int og at antallet er større enn 0, ergo, positiv, jeg kommer til å bare holde reprompting brukeren, holde reprompting, ved å tvinge dem til å samarbeide og gi meg en negativ int. 

Og når n er faktisk negative-- anta at brukeren til slutt typer -50, da dette mens sløyfen er ikke lenger sant fordi -50 ikke er større enn 0. Så vi bryte ut av det sløyfe logisk og tilbake n. 

Men det er en annen ting jeg må gjøre. Og jeg kan bare gjøre dette ved å kopiere og lime inn en kodelinje på toppen av filen. Jeg trenger å lære klang, eller lover å klang, eksplisitt at jeg vil, ja, gå og implementere denne funksjonen get_negative_int. Det kan bare være lavere i filen. Igjen, husker at klang leser ting topp til bunn, venstre til høyre, slik at du ikke kan kalle en funksjon hvis klang ikke vet det kommer til å eksistere. 

Nå, dessverre, dette programmet, som noen av dere kanskje har lagt merke til, er allerede buggy. La meg gå videre og gjøre buggy3. Det kompilerer, så problemet mitt nå er ikke en syntaksfeil, som en tekstlig feil, det er faktisk kommer til å være en logisk feil som jeg har bevisst laget som en mulighet til å gå gjennom hva som skjer. 

Jeg kommer til å gå videre nå og kjøre buggy3. Og jeg kommer til å gå fremover og ikke samarbeide. Jeg kommer til å gi den nummer 1. Det gjorde ikke liker det, så det er å spørre meg igjen. 

Hva med to? 3? 50? Ingen av de som jobber. Hva med -50? Og programmet ser ut til å fungere. 

La meg prøve det en gang. La meg prøve -1, ser ut til å fungere. La meg prøve -2, ser ut til å fungere. La meg prøve 0. Huh, det er feil. Nå er vi å være litt pedantisk her. Men det er faktisk slik at 0 verken positiv eller negativ. Og så det faktum at mitt program er si at 0 er et negativt helt tall, det er ikke teknisk korrekt. 

Nå, hvorfor er det å gjøre dette? Vel, det kan være åpenbar. Og, ja, er programmet ment å være ganske enkel så vi har noe å utforske. 

Men la oss introdusere en tredje debugging Teknikken her kalt debug50. Så dette er et program at vi har nettopp opprettet i år heter debug50 som vil tillate deg å bruke det som kalles en innebygd grafisk debugger i CS50 IDE. Og en debugger er bare et program som vanligvis lar deg kjøre programmet men skritt for skritt for skritt, linje ved linje for linje, pause, poking rundt, ser på variabler, slik at programmet ikke bare blåse forbi deg og raskt skrive ut noe eller ikke skrive ut noe. Det gir deg en mulighet, på human hastighet, for å kommunisere med den. 

Og for å gjøre dette, du bare gjøre følgende. Etter kompilering koden din, som jeg allerede gjorde, buggy3, du gå videre og kjøre debug50 ./buggy. Så mye som help50 har du kjører help50 og deretter kommandoen, debug50 har du kjørt debug50 og deretter navnet på kommandoen. 

Nå se hva som skjer på skjermen min, på den høyre siden i særdeleshet. Når jeg treffer Run, alle Plutselig panel dette høyre åpner opp på skjermen. Og det er mye som skjer på ved første øyekast. Men det er ikke for mye å bekymre seg for ennå. 

Dette viser meg alt det som skjer på innsiden av mitt program akkurat nå, og via disse knapper opp toppen er så tillater meg å gå gjennom min kode til slutt trinn for trinn for trinn. Men ikke ennå. Legg merke til hva som skjer. På min terminalvindu Jeg blir bedt om n. Og jeg kommer til å gå videre og samarbeider denne gangen og skriv inn -1. Og riktignok litt kryptisk, -1 er et negativt helt tall, som forventet. 

Og så barnet gått ut med status 0 GDBserver spennende. GDB, GNU Debugger, er navnet av den underliggende programvare som implementerer dette debugger. Men alt dette egentlig betyr, debugger gikk bort fordi programmet mitt sluttet og alt var vel. Hvis jeg ønsker å virkelig feilsøke mitt program, Jeg må preemptively fortelle debug50, der ønsker jeg å starte stepping gjennom koden min? 

Og kanskje den enkleste måten å gjøre det på er som følger. Hvis jeg sveve over takrenne av redaktøren min her, så egentlig bare på sidelinjen her, til venstre for linjen nummer, Legg merke til at hvis jeg klikker bare gang, satte jeg en liten rød prikk. Og det lille røde prikken, som et stoppskilt, betyr, hei, debug50, pause gjennomføring av koden min der når jeg kjører dette programmet. 

Så la oss gjøre det. La meg gå videre og kjøre mitt program igjen med debug50 ./buggy3, Enter. Og nå, varsel, noe annet har skjedd. Jeg er ikke å bli spurt men i mitt terminalvindu for noe, fordi jeg har ikke fått det ennå i mitt program. Legg merke til at på linje 8 som nå er markert, og det er en liten pil på igjen sier, er du satt på pause her. Dette kodelinje, linje 8, har ennå ikke utført. 

Og hva er nysgjerrig, hvis jeg ser over her på høyre side, merker at jeg er en lokal variabel, lokal i den forstand at det er inni den aktuelle funksjonen. Og dens verdi, tilsynelatende som standard, og liksom praktisk, er 0. Men jeg ville ikke skrive 0. Det bare skjer for å være dens Standardverdien for øyeblikket. 

Så la meg gå videre og gjøre dette nå. La meg gå videre og videre Øverst til høyre her, jeg kommer til å gå videre og Klikk denne første ikonet som betyr skritt over hvilke betyr ikke hoppe det, men gå over denne linjen med kode, utfører det underveis. 

Og nå, merker, min teksten har nettopp endret. Hvorfor det? Jeg har fortalt debug50, kjøre denne linjen med kode. Hva betyr denne linjen med kode gjøre? Ber meg for en int. OK. La meg samarbeide. La meg gå videre nå og skriver -1, Enter. Og nå legger merke til hva som er endret. På høyre side, min lokale variable i angis som -1 nå. Og det er fortsatt av typen int. 

Og legg merke til, også, min såkalte kaller stack, der gjorde jeg en pause? Vi skal snakke mer om dette i fremtiden. Men samtalen stabelen bare refererer til hva funksjoner er for tiden i bevegelse. Akkurat nå er det bare hoved. Og akkurat nå er det eneste lokale variabelen er jeg med en verdi på 1. 

Og når jeg endelig gå over denne linjen her, med det samme ikonet øverst til høyre, -1 Er et negativt heltall. Nå er det pause over det krøllete brace. La oss la den gjøre sin ting. Jeg gå over den linjen, og voila. 

Så det er ikke alle som fryktelig opplysende ennå, men det lot meg pause og tenke gjennom logisk hva dette programmet gjør. Men det var ikke den feilaktige saken. La oss gjøre dette igjen som følger. 

Jeg kommer til å forlate det stoppunkt på linje 8 med den røde prikken. Jeg kommer til å kjøre debug50. Det er automatisk satt på pause her. Men denne gangen, i stedet for tråkke over denne linjen, la meg faktisk gå inni get_negative_int og finne ut, hvorfor er det å akseptere 0 som et gyldig svar? 

Så i stedet for å klikke Step Over. Jeg kommer til å gå videre og klikk Step Into. Og legg merke til at linjen 8 som er nå markert nå plutselig blir linje 17. 

Nå er det ikke at debugger har hoppet over linjene 14 og 15 og 16. Det er bare det er ingenting vise deg det. De er bare erklære variabler, og så er det ordet Gjør og deretter en åpen klammeparentes. Den eneste funksjonelle linje som er saftig er virkelig denne her, 17. Og det er der vi har pauset automatisk. 

Så printf ( "n.is:") ;, så det har ikke skjedd ennå. Så la oss gå videre og klikk gå over. Nå er min rask, ja, endret til ( "n er:"). Nå get_int, jeg kommer ikke til å bry stepping i, fordi den funksjonen var laget av CS50 i biblioteket. Det er antagelig riktig. 

Så jeg kommer til å gå videre og slags samarbeide ved å gi det en int, men ikke en negativ int. Så la meg gå videre og treffe 0. Og nå hva som skjer her når jeg kommer ned til linje 21? Jeg har ikke gjentok igjen. Jeg synes ikke å bli sittende fast i at loop. Med andre ord, dette gul baren ikke holde det gående rundt, og rundt, og rundt. 

Nå, hvorfor er det? Vel, n, hva er n akkurat nå? Jeg kan se på det lokale variablene i debugger. n er 0. Greit, det var min tilstand? 

20-- linje 20 er, vel, 0 er større enn 0. Det er ikke sant. 0 er ikke større enn 0. Og så jeg brøt ut av dette. 

Og så det er derfor på linje 21, hvis jeg faktisk fortsetter, Jeg kommer til å gå tilbake 0, selv selv om jeg burde ha avvist 0 som faktisk ikke å være negativ. Så nå har jeg egentlig ikke engang bryr seg om debugger. Fikk det, jeg trenger ikke å vet hva mer som skjer. 

Så jeg kommer til å gå videre og bare klikk på Play-knappen, og la dette ferdig opp. Nå har jeg innsett at min bug er tydeligvis på linje 20. Det er min logiske feil. 

Og så hva gjør jeg vil å gjøre for å endre dette? Hvis problemet er at jeg ikke er fanger 0, det er bare en logisk feil. Og jeg kan si mens n er større enn eller lik 0, holde spørre brukeren om og om igjen. 

Så, igjen, enkel feil, kanskje selv opplagt når du så meg skrive det bare noen få minutter siden. Men takeaway her er at med debug 50, og med debugging programvare mer generelt, du har dette nye funnet makt til å gå gjennom din egen kode, se via den hånden panel riktig hva variabler verdier er. Slik at du ikke nødvendigvis nødt til å bruke noe som du eprintf å skrive ut disse verdiene. Du kan faktisk se dem visuelt på skjermen. 

Nå, utover dette, er det verdt å merke seg at det er en annen teknikk som er faktisk super vanlig. Og du lurer kanskje på hvorfor denne lille fyren her har sittet på scenen. Så det er denne teknikken, generelt kjent som Badeand debugging, som egentlig er bare en testament til det faktum som ofte når programmerere skriver kode, de er ikke nødvendigvis samarbeide med andre, eller arbeider i et felles miljø. 

De er liksom hjemme. Kanskje det er sent på kvelden. De prøver å finne ut noen feil i koden sin. Og de er bare ikke se det. 

Og det er ingen romkamerat. Det er ingen TF. Det er ingen CA rundt. Alt de har på sin sokkel er denne lille gummianden. 

Og så Badeand debugging er nettopp denne invitasjonen å tenke på noe som dumt så dette som en reell skapning, og faktisk gå gjennom koden din verbalt til denne stillestående objekt. Så, for eksempel, hvis Dette er mitt eksempel her-- og huske at tidligere problemet var denne, hvis jeg sletter denne første linjen med kode, og jeg går videre og gjøre buggy 0 igjen, husker at jeg hadde disse feilmeldinger her. Så ideen her, latterlig om jeg føler i øyeblikket å gjøre dette offentlig, er det feil. 

OK, så mitt problem er at jeg har implisitt erklært et bibliotek funksjon. Og det bibliotek funksjon er printf. Declare-- OK, erklærer minner meg om prototyper. 

Det betyr at jeg må faktisk fortelle kompilatoren på forhånd hva funksjonen ser ut. Vent litt. Jeg hadde ikke standard io.h. Tusen takk. 

Så bare denne prosessen of-- deg trenger ikke å faktisk ha en and. Men denne ideen om gang selv gjennom din egen kode slik at du selv høre selv, slik at du realisere utelatelser i din egen bemerkninger, er vanligvis tanken. 

Og, kanskje mer logisk, ikke så mye med den ene, men mer involvert eksempelet vi nettopp gjorde i buggy 3.c, du kan gå deg gjennom det følgende. Så alt rett, gummi ducky, DDB, hvis du vil. Her har vi i min hovedfunksjon, Jeg ringer får negative int. 

Og jeg får returverdien. Jeg lagrer den på venstre side på linje 8 i en variabel kalt i. OK, men vent, hvordan gjorde som får denne verdien? La meg se på funksjonen i linje 12. 

I linje 12, har vi få negativ int. Tar ikke noen innganger, ikke returnere en int, OK. Jeg erklærer på linje 14 en variabel n. Det kommer til å lagre et heltall. Det er det jeg vil ha. 

Så gjør følgende mens n er-- la meg angre hva reparasjonen jeg allerede gjort. Så mens n er større enn 0, skrive ut n er, OK. Og så kaller bli int lagret i n. Og deretter sjekke om n er 0, n er Ikke slik det er. Så, igjen, trenger du ikke trenger selve anda. Men bare vandre deg gjennom koden som en intellektuell øvelse vil ofte hjelpe deg skjønner hva som skjer, i motsetning til bare å gjøre noe som dette, stirrer på skjermen, og ikke snakke deg gjennom det, som ærlig talt ikke er nesten som en effektiv teknikk. Så der har du det, en antall forskjellige teknikker for faktisk debugging koden og å finne feil, som alle bør være verktøy i verktøykasse slik at du ikke er sent på kvelden, spesielt, er du i spise haller, eller i kontortiden, stanger hodet mot veggen, prøver å løse noen problem. Innse at det er programvareverktøy. Det er Rubber Duck verktøy. Og det er en hel stab av støtte venter på å låne en hånd. 

Så nå, et ord på problemet sett, og på hva vi håper du komme seg ut av dem, og hvordan vi går om å vurdere. Per kursets pensum, CS50 problemsett blir vurdert på fire primære akser, så til speak-- omfang, nøyaktighet, design, og stil. Og omfanget bare refererer til hvor mye av stykket har du bitt av? Hvor mye av et problem har du prøvd? Hvilket nivå av innsats har du manifestert? 

Korrekthet er, gjør at programmet fungerer som det skal per CS50 spesifikasjon når du oppgir visse innganger eller visse utganger kommer tilbake? Design er den mest subjektive av dem. Og det er den som vil ta lengst tid å lære og den lengste for å undervise i så langt som det koker ned til, hvor godt skrevet er koden din? 

Det er én ting å bare skrive riktig utganger eller returnere de rette verdiene. Men gjør du det som effektivt som mulig? Er du gjør det skillet og erobre, eller binære søk som vi vil snart se at vi gjorde to uker siden med telefonboken? Er det bedre måter å løse problem enn det du har her? Det er en mulighet for bedre design. 

Og så style-- hvordan pen er koden din? Du vil merke at jeg er ganske Særlig om innrykk koden min, og gjør at mine variabler er rimelig navngitt. n, mens kort, er et godt navn for en nummer, jeg for en telling heltall, s for en streng. Og vi kan ha lengre variabel navn stil. Stil er bare hvor god gjør koden din ser? Og hvordan lesbar er det? 

Og over tid, hva dine TAs og TFS vil gjøre i løpet er å gi deg som slags kvalitative tilbakemeldinger slik at du får bedre på de ulike aspekter. Og i forhold til hvordan vi vurdere hver av disse aksene, det er typisk med svært få bøtter slik at du generelt få en følelse av hvor godt du gjør. Og, ja, hvis du mottar en poengsum på noen av disse axes-- korrekthet, design og stil especially-- at antall vil generelt være mellom 1 og 5. Og, bokstavelig talt, hvis du får 3 er i starten av semesteret, dette er en veldig god ting. Det betyr at det er fortsatt rom for forbedring, som du ville håpe på i tar en klasse for første gang. Det er forhåpentligvis noen bit av taket som du håper å nå. Og så får 3-tallet på de tidligste stykker, hvis ikke noen 2 og 4-tallet, er faktisk en god ting. Det er godt innenfor rekkevidde, godt innenfor forventninger. 

Og hvis ditt sinn er racing, vent et minutt, tre av fem. Det er virkelig en 6 av 10. Det er 60%. Herregud, det er en F. 

Det er ikke. Det er ikke, faktisk, at. Snarere er det en mulighet til å forbedre i løpet av semesteret. Og hvis du får noen Poors, dette er en mulighet å dra nytte av kontortiden, absolutt seksjoner og andre ressurser. 

Best er en mulighet, egentlig, å være stolte av hvor langt du har kommer i løpet av semesteret. Så skjønner, hvis ingenting annet, tre er bra. Og det gir plass for vekst over tid. 

Når det gjelder hvordan disse aksene er vektet, realistisk du er kommer til å tilbringe mesteparten av din tid på å få ting til å fungere, enn si riktig. Og så korrekthet har en tendens til å være vektet mest, som med dette multiplikativ faktor på tre. Design er også viktig, men noe som du ikke nødvendigvis bruker alle disse timene på prøver å få ting bare for å jobbe. 

Og så det er vektet litt mer forsiktig. Og så stilen er vektet minst. Selv om det er ikke mindre viktig fundamentalt, det er bare kanskje den enkleste å gjøre riktig, ligne eksemplene vi gjøre i foredrag og delen, med ting pent innrykket, og kommentert, og så videre er blant de enkleste ting å gjøre og få rett. Så som sådan, innser at de er poeng som er relativt enkle å forstå. 

Og nå et ord på dette-- akademisk redelighet. Så per kursets pensum, vil du se at kurset har ganske litt av språket rundt dette. Og selvfølgelig tar opp spørsmålet om akademisk redelighet ganske alvorlig. 

Vi har æren, for bedre eller verre, av å ha sendt hvert år mer studentene for disiplinærtiltak enn de fleste andre Selvfølgelig, at jeg er klar over. Dette er ikke nødvendigvis indikerer det faktum at CS studenter, eller CS50 studenter, er noe mindre ærlige enn klassekameratene dine. Men det faktum at i denne verden, elektronisk, vi bare har teknologisk middel for å detektere dette. 

Det er viktig for oss for rettferdighet på tvers av klasse at vi gjør oppdage dette, og heve problemet når vi ser ting. Og bare for å male et bilde, og virkelig å hjelpe noe sånt som dette synke inn, Dette er antallet studenter i løpet av de siste 10 årene som har vært involvert i noen slike spørsmål om akademisk redelighet, med noen 32 studenter fra høsten 2015, som Det vil si at vi tar saken svært alvorlig. Og, til slutt, disse tallene komponere, senest ca. 3%, 4% eller så av klassen. 

Så for kvalifisert flertall av elevene det synes at linjene er klare. Men ha dette i tankene, særlig sent om natten når sliter med noen løsning på et problem sett, at det finnes mekanismer for å få deg bedre støtte enn du kanskje Tenk, selv på denne timen. Innse at når vi mottar student innleveringer, krysser vi sammenligne hver innlevering i år mot hver innlevering i fjor, mot hver innsending fra 2007, og siden, ser på, også, koden repositories online, diskusjonsfora, jobbsider. Og vi nevner dette, virkelig, alt for å få av full åpenhet, at hvis noen andre kan finne det på nettet, sikkert, så kan vi kurset. Men, egentlig, ånd av kurset koker ned denne bestemmelsen i pensum. Det er egentlig bare være fornuftig. 

Og hvis vi måtte utdype det med bare litt mer språk, innser at essensen av alle arbeid som du sender til dette kurset må være din egen. Men i løpet av det, det er sikkert muligheter og oppmuntring, og pedagogisk verdi i å snu til others-- meg selv, TFS, CAS, Tas og andre i klassen, for støtte, enn si venner og romkamerater som har studert CS og programmering før. Og så er det en kvote for det. Og den generelle tommelfingerregel er dette-- når du ber om hjelp, du kan vise koden din til andre, men du kan ikke se deres. Så selv om du er på arbeidstid, eller i D hall, eller et annet arbeider på noen delers sett, arbeider sammen med en venn, som er helt fint, i slutten av dagen din jobb bør til slutt tilhøre hver av dere henholdsvis, og ikke være noen samarbeid, bortsett fra slutt prosjekt der det er lov og oppmuntret. 

Innse at hvis du er sliter med noe og din venn bare skjer å bli bedre på dette da du, eller bedre på det problemet enn deg, eller litt lenger fremover enn deg, det er helt rimelig å snu til din venn og si hei, Gjør det noe å se på koden min her, å hjelpe meg få øye på hva problemet mitt er? Og, forhåpentligvis, i interesse av pedagogisk verdi som venn ikke bare si, oh, gjør dette, men heller, hva er det du mangler på linje 6, eller noe sånt? Men løsningen er ikke for venn ved siden av deg å si, oh, vel, her, la meg dra dette opp, og vise min løsning til deg. Så det er linjen. Du viser din kode for å andre, men du kan ikke se deres, underlagt andre begrensninger i kursets pensum. 

Så husk dette såkalte beklagelse klausul i kursets pensum også, at hvis du begår noen handling som er ikke rimelig, men ta det til oppmerksomheten til kursets hoder innen 72 timer, kurset kan innføre lokale sanksjoner som kan omfatte en utilfredsstillende eller sviktende karakter for arbeidet sendes inn. Men selvsagt vil ikke henvise rolle for ytterligere disiplinære tiltak, unntatt i tilfeller av gjentatte handlinger. Med andre ord, hvis du gjør noe dum, særlig sent på kvelden, beslutnings at neste morgen eller to dager senere, du våkner opp og innser, hva tenkte jeg? Du gjør i CS50 ha en stikkontakt for å fikse det problemet og eie opp til det, slik at vi vil møte deg halvveis og avtale med det i en sak som er både pedagogiske og verdifull for deg, men fortsatt straff på noen måte. Og nå, for å ta kanten av, dette. 

[VIDEO PLAYBACK] 

[MUSIKK] 

[END PLAYBACK] DAVID J. MALAN: Greit, vi er tilbake. Og nå ser vi på en av de første av våre virkelige verden domener i CS50, kunsten kryptografi, kunsten å sende og motta hemmelige meldinger, kryptert meldinger om du vil, som bare kan tydes hvis du har noen viktig ingrediens at avsenderen har også. Så for å motivere dette vil vi ta en ser på denne saken her, som er et eksempel på en hemmelig dekoder ring som kan brukes for å regne ut hva en hemmelig melding faktisk er. Faktisk, tilbake i dag i grunnskolen, hvis du noen gang sendt hemmelige meldinger til noen venn eller noen forelsket i klassen, du kanskje har trodd du var flink av på din stykke papir endring, som, A til B og B til C og C til D, og så videre. Men du var faktisk kryptere informasjonen, selv om det var litt trivielt, var ikke det vanskelig for læreren å realisere, vel, hvis du bare endre B til A og C til B, du faktisk finne ut hva budskapet var, men du var i ciphering informasjon. 

Du var bare å gjøre det rett og slett, mye som Ralphie her i en berømt film som spiller ganske mye ad nauseum hver vinter. [VIDEO PLAYBACK] -Vær Det kjent for alle at Ralph Parker er herved oppnevnt et medlem av den lille Orphan Annie Secret Circle og har rett til alle æresbevisninger og fordelene som skjer i dette. 

-Signed, Little Orphan Annie, kontra signert Pierre Andre, i blekk. Honors og fordeler, allerede i en alder av ni. 

[SHOUTING] -Kom igjen. La oss fortsette med det. Jeg trenger ikke all that jazz om smuglere og pirater. 

Lytt morgen kveld for den avsluttende eventyr av svart sjørøverskute. Nå er det tid for Annie hemmelige budskap for dere medlemmer av Secret Circle. Husk, barn, bare medlemmer av Annie Secret Circle kan dekode Annie hemmelige budskap. 

Husk, er Annie avhengig av deg. Still dine pins til B2. Her er budskapet. 12, 11-- 

-Jeg Er i min første hemmelig møte. 

-14, 11, 18, 16. 

-Pierre var i stor stemme i kveld. Jeg kunne fortelle at kveldens Meldingen var veldig viktig. 

-3, 25, er at en melding fra Annie seg selv. Husk, ikke si det til noen. 

-90 Sekunder senere, jeg er i den eneste rom i huset hvor en gutt på ni kunne sitte i ro og dekode. Aha, B! Jeg gikk til den neste, E. 

Det første ordet er være. S, det kom lettere nå, U, 25-- 

-Å, Kom igjen, Ralphie, jeg må gå! 

-Jeg Være rett ned, Ma! Jøss! 

-T, O, sørg to-- være sikker på hva? Hva var Little Orphan Annie prøver å si? Pass på å hva? 

-Ralphie, Andy har fått til går, vil du være så snill å komme ut? 

-Alle Høyre, Ma! Jeg kommer rett ut! 

-Jeg Kom nærmere nå. Spenningen var forferdelig. Hva var det? Skjebnen til planeten kan henge i balanse. 

-Ralphie! Andy må gå! 

-Jeg Være rett ut, for roper høyt! 

-Nesten Der, fingrene mine fløy, mitt sinn var en stål felle, hver pore vibrerte. Det var nesten klar, ja, ja, ja. 

-Vær Sikker på å drikke din ovaltine. Ovaltine? En crummy kommersielle? Drittsekk. [END PLAYBACK] DAVID J. MALAN: OK, så det var en veldig lang vei å innføre kryptografi, og også Ovaltine. Faktisk, fra denne gamle annonsen her, hvorfor er ovaltine så bra? Det er en konsentrert ekstraksjon av moden byggmalt, ren kremet kumelk, og spesielt forberedt kakao, sammen med naturlige fosfatider og vitaminer. Det er videre forsterket med ekstra vitaminer B og D, yum. Og du kan fortsatt få det, tilsynelatende, på Amazon, som vi gjorde her. 

Men motivasjonen her skulle introdusere kryptografi, spesielt en type kryptografi kjent som hemmelig nøkkel kryptografi. Og som navnet antyder, hele sikkerhet av en hemmelig nøkkel kryptosystem, om du vil, en metode for bare scrambling informasjon mellom to mennesker, er at bare avsenderen og bare mottakeren vite en hemmelighet key-- noen verdi, noen hemmelig setning, noen hemmelig nummer, som gir dem mulighet til å både kryptere og dekryptere informasjon. Og kryptografi, egentlig, er nettopp dette fra uke 0. 

Det er et problem der det er innganger, som selve meldingen på engelsk eller hva språk du ønsker å sende til noen i klassen, eller over internett. Det er noen utgang, som er tenkt å være kryptert melding om at du vil at mottakeren skal motta. Og selv om noen i midten får det også, trenger du ikke vil at de skal nødvendigvis være i stand til å dekryptere den, fordi innsiden av denne svart boks, eller algoritme, er noen mekanisme, noe trinnvis instruksjoner, for å ta det inn og konvertere den inn i utgang, i forhåpentligvis en sikker måte. 

Og, faktisk, det er noen vokabular i denne verden som følger. Ren tekst er ordet en datamaskin vitenskapsmann ville bruker for å beskrive inngangs melding, for eksempel engelsk eller hva språk du faktisk ønsker å sende til noen andre menneske. Og så chifferteksten er krafse til kodet, eller kryptert, versjon av denne. 

Men det er en annen ingrediens her. Det er en annen inngang til hemmelig nøkkel kryptografi. Og det er selve nøkkelen, som er, generelt, som vi skal se, et tall, eller brev, eller ord, uansett algoritmen det er faktisk forventer. 

Og hvordan kan du dekryptere informasjonen? Hvordan du unscramble den? Vel, du bare snu utganger og innganger. 

Med andre ord, etter at noen mottar kryptert melding, han eller hun har rett og slett å vite at samme nøkkel. De har fått den krypterte teksten. Og ved å koble disse to input i krypto-systemet, algoritmen, denne svarte boksen, ut bør komme originalteksten. Og så det er svært høyt nivå syn på hva kryptografi er faktisk alt om. 

Så la oss komme dit. La oss nå se under panseret på noe vi har tatt for gitt for den siste uken, og for denne økten her-- strengen. En streng på slutten av dagen er bare en sekvens av tegn. 

Det kan være hello world, eller hei Zamyla, eller hva. Men hva betyr det å være en sekvens av tegn? Faktisk gir CS50 biblioteket oss en datatype som kalles streng. 

Men det er faktisk ikke noe slike ting som en streng i C. Det er egentlig bare en sekvens av karakter, personlighet, karakter, karakter, tilbake, til rygg, til tilbake, til rygg, mot rygg inne av datamaskinens minne, eller RAM. Og vi vil se dypere inn i det i fremtiden når vi ser på minne seg selv, og utnyttelse, og den truslene som er involvert. 

Men la oss vurdere strengen Zamyla. Så bare navnet menneske her, Zamyla, som er en sekvens av tegn, Z-A-M-Y-L-A. Og nå la oss anta at Zamyla navn blir lagret inne i en datamaskin program. 

Vel, står det til grunn at vi skal være i stand til å se på disse tegnene individuelt. Så jeg skal bare trekke litt boksen rundt Zamyla navn her. Og det er tilfelle i C som når du ha en streng, som Zamyla-- og kanskje at strengen har kommet tilbake fra en funksjon som get streng, du kan faktisk manipulere det tegn for tegn. 

Nå, dette er germane for samtale på hånden, fordi i kryptografi hvis du ønsker å endre A til B, og B til C og C til D, og så videre, må du være i stand å se på de enkelte tegn i en streng. Du må være i stand til å endre Z til noe annet, A til noe annet, M til noe annet, og så videre. Og så trenger vi en måte, programmatisk, så å si i C for å være i stand til å endre og se på enkeltbokstaver. Og vi kan gjøre dette på følgende måte. 

La meg gå hodet tilbake i CS50 IDE. Og la meg gå videre og opprette en ny fil at jeg vil kalle denne gangen string0, som vår første slikt eksempel, dot c. Og jeg kommer til å gå videre og pisk den opp som følger. 

Så inkluderer CS50.h, og deretter inkludere standard io.h, som jeg nesten alltid kommer til å skal bruke i mine programmer, minst i utgangspunktet. int main ugyldig, og så her er jeg kommer til å gjøre strenger får få streng. Og så kommer jeg til å gå videre og gjøre dette. Jeg ønsker å gå videre og, som en mental helse sjekk, bare si, hallo, prosent s, semikolon, gjør streng 0. Uh oh, hva har jeg gjort her? Oh, det gjorde jeg ikke koble den til. Slik erfaringer, som var ikke tilsiktet. 

Så feil, mer prosent konverteringer enn data argumenter. Og det er her, i linjen 7-- OK, så jeg har, quote unquote, det er min strengen til printf. Jeg har fått et prosenttegn. Men jeg mangler det andre argumentet. 

Jeg mangler komma s, noe som Jeg har i tidligere eksempler. Så en god mulighet til å løse en mer feil, uhell. Og nå la meg kjøre string0, skriv inn Zamyla. OK, hallo Zamyla. 

Så vi har kjørt denne typen program noen forskjellige tider nå. Men la oss gjøre noe litt annerledes denne gangen. I stedet for bare å skrive Zamyla s hele navnet med printf, la oss gjøre det tegn for tegn. 

Jeg kommer til å bruke en for loop. Og jeg kommer til å gi meg selv en tellevariabel, heter jeg. Og jeg kommer til å holde itera, så lenge i er mindre enn lengden av s. 

Det viser seg, gjorde vi ikke gjør dette siste gang, at c kommer med en funksjon som heter Stirling. Tilbake i dag, og generelt fortsatt ved implementering funksjoner, mennesker vil ofte velge veldig fyndig navn som slags lyd som hva du vil, selv om det er mangler noen vokaler eller bokstaver. Så Stirling er navnet på en funksjon som tar en krangel mellom parenteser som bør være en streng. Og det bare returnerer et heltall, lengden av strengen. 

Så dette for loop på linje 7 kommer å begynne å telle på i lik 0. Det kommer til å øke jeg på hver iterasjon etter en, slik vi har gjort et par ganger. Men det kommer til å bare gjøre denne fram til punktet når jeg er lengden av selve strengen. 

Så dette er en måte, til slutt, gjentar over tegnene i strengen som den er følger. Jeg kommer til å skrive ut ikke en Hele streng, men prosent c, et enkelt tegn etterfulgt av en ny linje. Og så kommer jeg til å gå videre, og jeg trenger å si at jeg ønsker å skrive ut ith karakter av s. 

Så hvis jeg er den variabelen som indikerer indeksen av strengen, der du er i det, jeg trenger å være i stand til å si, gi meg den ith karakter av s. Og c har en måte å gjøre dette med hakeparenteser. Du bare si navnet på streng, som i dette tilfellet er s. Deretter kan du bruke hakeparentes, som er vanligvis like over Retur eller Enter tast på tastaturet. Og så satte indeksen for tegnet du vil skrive ut. Så indeksen kommer til å bli en number-- 0 eller 1, eller to, eller tre, eller prikk, prikk, prikk, et annet nummer. 

Og vi sørge for at det kommer til å være riktig nummer, fordi jeg begynne å telle på 0. Og som standard, det første tegnet i en streng er av konvensjonen 0. Og den andre karakteren er brakett 1. Og den tredje tegnet er brakett 2. Og du ikke ønsker å gå for langt, men vi vil ikke fordi vi er kommer til å bare øke i før det lik lengden av strengen. Og ved hvilket tidspunkt, dette for sløyfen vil stoppe. 

Så la meg gå videre og lagre denne program, og løp gjør streng 0. Men jeg skrudd opp. Implisitt erklære bibliotek funksjon Stirling med type slik og such-- nå, dette høres kjent ut. Men det er ikke printf. Og det er ikke få streng. 

Jeg gjorde ikke skru opp i på samme måte som denne tid. Men legg merke til her nede litt ned videre, inkluderer overskriften string.h, eksplisitt gi erklæring for Stirling. Så det er faktisk en anelse i det. 

Og faktisk det viser seg det er en annen header fil at vi ikke har brukt i klassen ennå, er men det blant de som er tilgjengelige til deg, kalt string.h. Og i denne filen, string.h er Stirling erklært. Så la meg gå videre og lagre dette, gjør strengen 0-- hyggelig, ingen feilmeldinger av denne tiden. 

./string0 Zamyla, og Jeg er i ferd med å trykke Enter, ved hvilket punkt getstring kommer å returnere strengen, legg den i s. Så det for loop kommer til å reagere i løpet av S 'tegn om gangen, og skrive dem ut én per linje, fordi Jeg hadde som backslash n på slutten. Så jeg kunne utelate at backslash n, og så bare skrive ut Zamyla alle i den samme linje, effektivt reimplementing printf, som ikke er alle som nyttig. Men i dette tilfellet, har jeg ikke gjort det. Jeg har faktisk skrevet en tegn om gangen, ett per linje, slik at vi faktisk se effekten. 

Men jeg bør være oppmerksom på en ting her. Og vi vil komme tilbake til dette i en fremtidig uke. Det viser seg at denne Koden er potensielt buggy. 

Det viser seg at få streng og noen andre funksjoner i livet ikke nødvendigvis alltid tilbake hva du forventer. Vi vet fra klassen siste tid i denne som får strengen er ment for å returnere en streng. Men hva hvis brukeren skriver ut en slik et langt ord, eller ledd eller essay at det er bare ikke nok minne i datamaskinen til å passe den. 

Liker, hva om noe går galt under panseret? Det kan ikke skje ofte, men det kan skje en gang på en stund, veldig sjelden. Og så viser det seg at få streng og funksjoner som det ikke nødvendigvis alltid tilbake strenger. De kan returnere en feil verdi, noen sentinel verdi så å si, som indikerer at noe har gått galt. Og du vil bare vite dette fra etter å ha lært det i klassen nå, eller å ha lest litt mer dokumentasjon. Det viser seg at få streng kan returnere en verdi som kalles null. Null er en spesiell verdi som vi vil komme tilbake til i en senere uke. Men for nå, bare vet at hvis jeg vil ha å være veldig riktig i fremover bruker get streng, jeg bør ikke bare kalle det, og blindt bruke returverdien, stole på at det er en streng. 

Jeg må først si, hei, vent litt, bare fortsette hvis s er ikke lik null, hvor null igjen, er bare noen spesiell verdi. Og det er den eneste spesielle verdien du trenger å bekymre deg for få streng. Få strengen er enten kommer å returnere en streng eller null. 

Og dette utropstegn likhetstegn du kanskje kjenner fra kanskje matte klassen som du kan trekke et likhetstegn med en linje gjennom det for å indikere ikke like. Det er vanligvis ikke en karakter du kan skrive på tastaturet. Og så i de fleste programmeringsspråk, når du ønsker å si ikke like, du bruker et utropstegn, ellers kjent som bang. Så du sier bang lik, som betyr ikke lik, logisk. Det er akkurat som det ikke er en større enn, eller lik, eller mindre enn eller lik-tasten på tastaturet som gjør alt i ett symbol. Så det er derfor, i tidligere eksempler, du gjorde en åpen brakett, og deretter et likhetstegn, for å gjøre større enn eller, si, mindre enn. 

Så hva er takeaway her? Dette er bare en måte nå av innføre denne syntaksen, denne funksjonen, itera over individuelle tegn i en streng. Og akkurat som de torget parentes tillate deg å få på dem, vurdere disse klammer som slags antydet at dette underliggende design, hvor hver karakter inne i en streng er slags eske i et sted under panseret i datamaskinens minne. 

Men la oss gjøre en variant av dette. Det viser seg at denne program er korrekte. Så per CS50 er akser for å vurdere kode, er dette riktig nå. Spesielt nå som jeg sjekker for null, dette programmet skulle aldri krasje. Og jeg bare vet at fra erfaring. Men det er ingenting annet som Vi kan virkelig gå galt her. Men det er ikke veldig godt designet, fordi la oss gå tilbake til det grunnleggende. 

Først principles-- hva gjør en for løkke gjøre? En for løkke gjør tre ting. Det initialiserer noen verdi, spør du den til. Det sjekker en betingelse. Og så etter hvert iterasjon, etter hver syklus, intervaller det noen verdi, eller verdier, her. 

Så hva betyr det? Vi initial jeg til 0. Vi sjekker og sørge for at jeg er mindre enn lengden s, som er Z-A-M-Y-L-A, slik som er mindre enn seks. Og, ja, 0 som mindre enn seks. 

Vi skrive ut Z fra Zamyla navn. Deretter øke vi i fra 0 til 1. Vi så sjekk, er en mindre enn lengden av s? Lengden av s er seks. Ja det er det. 

Så vi ut en i Zamyla navn, ZA. Vi inkrementer i fra 0 til 1, til to. Vi så sjekk, er to mindre enn lengden på Zamyla navn. 6- så 2 er mindre enn seks. Ja, la oss skrive ut nå M i Zamyla navn, den tredje tegnet. 

Nøkkelen her er at på hver gjentakelse av historien, jeg sjekker, i er mindre enn lengden av Zamyla? Men fangsten er at Stirling er ikke en egenskap. De av dere som har programmert før i Java eller andre språk kanskje vet lengden på en streng er en eiendom, bare noen skrivebeskyttet verdi. 

I C i dette tilfellet, dersom dette er en funksjon som er bokstavelig talt å telle antall tegn i Zamyla hver gang Vi kaller denne funksjonen. Hver gang du spør datamaskinen til å bruke Stirling, er det å ta en titt på Zamyla, og sa: Z-A-M-Y-L-A, 6. Og den returnerer 6. Neste gang du ringer det inne at for loop, det kommer til å se på Zamyla videre sier Z-A-M-Y-L-A, 6. Og det kommer til å gå tilbake seks. Så hva er dumt om dette design? 

Hvorfor er min kode ikke en 5 av 5 for design akkurat nå, så å si? Vel, jeg spør en Spørsmålet unødvendig. Jeg gjør mer arbeid enn jeg må. 

Så selv om Svaret er riktig, jeg er spør datamaskinen, hva er lengden av Zamyla igjen, og igjen, og igjen, og igjen? Og det svaret er aldri kommer til å forandre seg. Det er alltid kommer til å være seks. 

Så en bedre løsning enn dette ville være dette neste versjon. La meg gå videre og sette den i en egen fil kalt string1.c, bare for å holde det atskilt. Og det viser seg i et for loop, kan du faktisk erklærer flere variabler samtidig. 

Så jeg kommer til å holde i og sette den til 0. Men jeg er også tenkt å legge til et komma, og sier: gi meg en variabel kalt n, hvis verdi tilsvarer strenglengde s. Og nå kan du gjøre min tilstand så lenge jeg er mindre enn n. 

Så på denne måten, er logikken identisk på slutten av dagen. Men jeg husker den verdi 6, i dette tilfellet. Hva er lengden på Zamyla navn? Og jeg setter den på n. 

Og jeg er fortsatt sjekker tilstanden hver gang. Er 0 mindre enn 6? Er en mindre enn 6? Er to mindre enn seks, og så videre? 

Men jeg ber ikke om datamaskinen igjen, og igjen, hva er lengden på Zamyla navn? Hva er lengden på Zamyla navn? Hva er lengden på denne Zamyla navn? Jeg bokstavelig talt å huske at første og bare svare på denne andre variabelen n. Så dette nå ville være ikke bare riktig, men også godt designet. 

Nå, hva om stil? Jeg har kalt mine variabler ganske bra, vil jeg si. De er super fyndig akkurat nå. Og det er helt greit. 

Hvis du bare har én streng i et program, du kan like godt kalle det er for streng. Hvis du bare har en variabel for telling i et program, du kan like godt kalle det jeg. Hvis du har en lengde, n er super vanlig også. Men jeg har ikke kommentert noen av koden min. 

Jeg har ikke informert reader-- enten det er min TF, eller TA, eller bare colleague-- hva som er ment å gå på i dette programmet. Og så for å få god stil, hva jeg ønsker å gjøre er dette-- noe som ber brukeren om innspill. Og jeg kunne skrive om denne en rekke måter. 

Sørg S- sørge get string returnerte streng. Og så i her-- og dette er kanskje det viktigste comment-- iterer i løpet av de tegnene i s ett om gangen. Og jeg kunne bruke noen Valget av engelsk språk her for å beskrive hver av disse biter av kode. 

Legg merke til at jeg ikke har satt en kommentere på hver linje med kode, egentlig bare på den interessante seg, de som har noen betydning for at jeg ønsker å lage super klar til noen lese min kode. Og hvorfor er du ringer får string ber brukeren om innspill? Selv som en ikke nødvendigvis alt som beskrivende. Men det hjelper å fortelle en historie, fordi andre linje i historien er, sørg få streng returnerte streng. 

Og den tredje linjen i historien er, iterere over karakterene i s en på en gang. Og nå bare for godt mål, Jeg kommer til å gå videre og legge en mer kommentar som bare sier print i-te karakter i s. Nå, hva har jeg gjort på slutten av dagen? 

Jeg har lagt litt engelsk ord i form av kommentarer. Den skråstrek skråstrek symbolet betyr, hei, Datamaskinen dette er for det humane, ikke for deg, datamaskinen. Så de ignorert logisk. De er bare der. 

Og, ja, viser CS50 IDE dem som grå, som å være nyttig, men ikke nøkkel til programmet. Legg merke til hva du nå kan gjøre. Enten du vet C programmering eller ikke, du kan bare stå tilbake på dette program, og skumme kommentarene. Be brukeren om innspill, sørg få streng returnerte streng, iterere over karakterene i s en om gangen, skriver tegnet i-te tegnet i S- du ikke engang å se på koden å forstå hva dette programmet gjør. Og enda bedre, hvis du selv ser på dette programmet i en uke eller to, eller en måned, eller et år, du også ikke har å stirre på koden, prøver å huske, hva jeg prøver å gjøre med denne koden? 

Du har fortalt deg. Du har beskrevet det selv, eller noen kollega, eller TA, eller TF. Og så dette ville nå være riktig, og god design, og til slutt god stil også. Så gjør holde det i bakhodet. 

Så det er en annen ting jeg skal gjøre her som kan nå avsløre nøyaktig hva som er skjer under panseret. Så det er denne funksjonen i C, og andre språk, kalt typecasting som enten implisitt eller eksplisitt lar deg konvertere fra en datatype til en annen. Vi har vært å gjøre så langt i dag med strenger. 

Og strenger er tegn. Men husker fra uke 0, hva er tegn? Tegn er bare en abstraksjon på toppen av numbers-- desimaltall, og desimaltall er egentlig bare en abstraksjon på toppen av binære tall, som vi definerte det. 

Så tegn er tall. Og tallene er tegn, bare avhengig av sammenhengen. Og det viser seg at det inne av et dataprogram kan du spesifisere hvordan du vil se på biter inne i det programmet? 

Recall fra uke 0 som vi hadde Ascii, som er bare denne koden kartlegging bokstaver til tall. Og vi sa, kapital A er 65. Kapital B er 66, og så videre. 

Og legg merke til, vi i hovedsak har tegn på øverste rad her, som C vil kalle dem, tegn, og deretter ints på andre rad. Og det viser seg at du kan konvertere sømløst mellom de to, vanligvis. Og hvis vi ønsker å gjøre dette bevisst, vi kan det være lurt å takle noe sånt som dette. 

Vi ønsker kanskje å konvertere store bokstaver til små tilfelle, eller små bokstaver til store bokstaver. Og det viser seg at det er faktisk et mønster her vi kan omfavne i bare et øyeblikk. Men la oss først se på en eksempel for å gjøre dette eksplisitt. 

Jeg kommer til å gå tilbake til CS50 IDE. Jeg kommer til å skape en fil som heter Ascii 0.c. Og jeg kommer til å gå videre og legge min standard io.h på toppen, int main ugyldig på toppen av min funksjon. Og så jeg bare kommer til å gjøre det following-- en for loop fra i lik, la oss si, 65. 

Og så er jeg kommer til å være mindre enn 65, pluss 26 bokstaver i alfabetet. Så jeg skal la datamaskinen gjøre regnestykket for meg der. Og så inne i denne sløyfen, hva skal jeg skrive? 

% C er% i backslash n. Og nå vil jeg koble to verdier. Jeg har midlertidig satt spørsmålet markerer det å invitere spørsmålet. 

Jeg vil gjenta fra 65 og framover for 26 bokstavene i alfabetet, skrive ut på hver iterasjon som karakterens integrert tilsvarende. Med andre ord, jeg vil iterere over 26 tall utskrift hva Ascii karakter er, brevet, og hva det tilsvarende tallet er-- egentlig bare å gjenskape diagrammet fra dette lysbildet. Så hva skal disse spørsmålstegn være? 

Vel, det viser seg at den andre man bør bare være variabelen i. Jeg vil se det som et tall. Og midt argument Herfra kan jeg fortelle datamaskinen å behandle som heltall jeg som et tegn, så som å erstatte det her for prosent C. 

Med andre ord, hvis jeg, menneskelig programmerer, vet disse er bare tall på slutten av dagen. Og jeg vet at 65 bør kart til noen tegn. Med dette eksplisitt cast, med en parentes, navnet på datatypen du vil konvertere til, og en lukket parentes du kan fortelle datamaskin, hei, datamaskin, konvertere denne heltall til en char. 

Så når jeg kjører dette program etter kompilering, la oss se hva jeg get-- gjøre Ascii 0. Darn det, hva har jeg gjort galt her? Bruk av svart identifikator, all right, ikke tilsiktet, men la oss se om vi ikke kan Grunnen gjennom dette. 

Så linjen five-- så jeg ikke fikk veldig langt før du skrur opp. Det er greit. Så linje 5 for jeg er lik 65-- jeg ser. Så husk at i C, i motsetning til noen språk hvis du har tidligere programmering erfaring, har du å fortelle datamaskinen, i motsetning til Scratch, hva type variabel det er. 

Og jeg glemte en nøkkel setning her. I tråd fem, har jeg begynt å bruke i. Men jeg har ikke fortalt C hva datatype det er. Så jeg kommer til å gå inn her og si, ah, gjør det til et heltall. 

Nå kommer jeg til å gå videre og rekompilere. Det fikset det. ./ascii0 inn, det er litt kult. Ikke bare er det super rask å be datamaskinen dette spørsmålet, heller enn å se det opp på et lysbilde, det skrevet ut ett per linje, A er 65, B er 66, hele veien down-- siden jeg gjorde dette 26 times-- til bokstaver z, som er 90. Og, faktisk litt mer intelligent ville har vært for meg å ikke stole på datamaskinen for å legge til 26. Jeg kunne bare ha gjort 90 også, så lenge som jeg ikke gjør samme feil to ganger. Jeg ønsker å gå opp gjennom z, ikke bare opp gjennom y. 

Så det er en eksplisitt konvertering. Det viser seg at denne er ikke engang nødvendig. La meg gå videre og kjør dette kompilator, og reprise Ascii 0. Det viser seg at C er ganske smart. 

Og printf, særlig er ganske smart. Hvis du bare passere en i to ganger for både plassholdere, printf vil innse, oh, vel jeg vet du ga meg en integer-- noen tall, som 65 eller 90, eller hva. Men jeg ser at du vil ha meg til formatere det nummeret som et tegn. Og så printf kan implisitt kaste int til en røye for deg også. Så det er ikke et problem i det hele tatt. 

Men legg merke til, på grunn av dette likeverdighet vi faktisk kan gjøre dette også. La meg gå videre og gjøre en annen versjon av dette-- Ascii 1.c. Og i stedet for itera løpet heltall, kan virkelig bakoversveis ved å gjenta over tegn. Hvis en char c får kapital A, jeg ønsker å gå videre og gjøre dette, så lenge som C er mindre enn eller lik til kapital Z. Og på hver iterasjon Jeg ønsker å øke C, kan jeg nå i min printf linje her si, er prosent C prosent i igjen, komma C. 

Og nå kan jeg gå den andre retningen, avstøpning tegnet eksplisitt til et helt tall. Så, igjen, hvorfor ville du gjøre dette? Det er litt rart å sortere av telle i form av tegn. 

Men hvis du forstår hva som er skjer under panseret, det er egentlig ingen magi. Du bare sier hei, datamaskin gi meg en variabel kalt C av type røye. Initialisere den til kapital A. Og merke enkeltanførselstegn saken. 

For karakterer i C, husker fra i forrige uke, bruker du enkle anførselstegn. For trenger, for ord, setninger, bruker du anførselstegn. OK, datamaskin, fortsette å gjøre dette, så lenge som tegnet er mindre enn eller lik z. Og jeg vet fra min Ascii tabellen at alle av disse ASCII-koder er sammenhengende. 

Det er ingen hull. Så det er bare A til Z, adskilt av ett nummer hver. Og så kan jeg øke en røye, hvis jeg virkelig vil. På slutten av dagen, det er bare et tall. Jeg vet dette. Så jeg kan bare anta å legge en til det. 

Og så denne gangen, jeg skriver c, og deretter integrert tilsvarende. Og jeg trenger ikke engang den eksplisitte cast. Jeg kan la printf og datamaskin finne ut av ting, så nå hvis jeg kjører gjøre Ascii1./ascii1, Jeg får akkurat det samme også. 

Ubrukelig program, though-- ingen kommer til å faktisk skrive programvare for å finne ut, hva var tall som er tilordnet A, eller B, eller Z? Du kommer bare til å google det, eller slå det opp på nettet, eller slå det opp på et lysbilde, eller lignende. Så hvor kommer dette faktisk få nyttig? 

Vel, vi snakker om det lysbilde, merker det er en faktisk mønster her mellom store og små bokstaver som ikke var tilfeldig. Legg merke til at kapital A er 65. Små bokstaver en er 97. Og hvor langt unna er små bokstaver en? 

Så 65 er hvor mange skritt fra 97? Så 97 minus 65 er 32. Så kapital en er 65. Hvis du legger 32 til det, du får små bokstaver en. Og tilsvarende, hvis du trekker fra 32, du kommer tilbake til hovedstaden A-- samme med B for lite b, stor C for lite c. 

Alle disse hullene er 32 fra hverandre. Nå, dette synes å tillate oss å gjøre noe som Microsoft Word, eller Google Docs har, hvor du kan velge alt og si, endre alle til små bokstaver, eller endre alle til store bokstaver, eller endre bare det første ordet av en setning til stor bokstav. Vi kan faktisk gjøre noe sånn selv. 

La meg gå videre og lagre en fil her kalt kapital 0.c. Og la oss gå videre og piske opp et program som gjør nøyaktig det som følger. Så ta med CS50 biblioteket. Og inkluderer standard I / O. 

Og jeg vet at dette kommer snart. Så jeg kommer til å sette det i der allerede, string.h, så jeg har tilgang til ting som Stirling, og deretter int main tomrom, som vanlig. Og så kommer jeg til å gå videre og gjøre strenger får få streng, bare for å få en streng fra brukeren. Og så kommer jeg til å gjør meg sunn fornuft sjekk. Hvis strengen ikke er lik null, så det er trygt å fortsette. Og hva ønsker jeg å gjøre? Jeg kommer til å reagere fra i lik 0, og n opp til strengen lengde s. 

Og jeg kommer til å gjøre dette så lenge Jeg er mindre enn n, og jeg pluss pluss. Så langt er jeg egentlig bare låne ideer fra før. Og nå kommer jeg til å innføre en gren. 

Så tenker tilbake til Scratch, hvor vi hadde de gafler i veien, og siste uke i C. Jeg kommer til å si dette, hvis den i-te karakter i s er større enn eller tilsvarende små bokstaver a, og-- i Scratch du ville bokstavelig talt sier og, men i C du sier ampersand, ampersand-- og i-te karakter i s er mindre enn eller lik til små bokstaver z, la oss gjøre noe interessant. La oss faktisk skrive ut en karakter uten linjeskift som er tegnet i strengen, i-te tegnet i strengen. 

Men la oss gå videre og trekke 32 fra det. Else hvis tegnet i streng som vi ser er ikke mellom liten en og lite z, gå videre og bare skrevet det ut uendret. Så vi har introdusert dette parentes notasjon for våre strenger for å få på i-te tegnet i strengen. 

Jeg har lagt noen betinget logikk, som Scratch i forrige ukes uke en, hvor Jeg bare bruker min fundamental forståelse av hva som er skjer under panseret. Er i-te karakter av s er større enn eller lik en? Liker, er det 97 eller 98, eller 99, og så videre? 

Men det er også mindre enn eller lik til verdien av små bokstaver z? Og hvis så, hva betyr denne linjen betyr? 14, er denne typen av spiren til hele ideen, kapitalisere brevet etter simpelthen å trekke 32 fra det, i dette tilfellet, fordi jeg vet, per som diagram, hvordan mine tall er representert. Så la oss gå videre og kjøre denne, etter kompilering kapital 0.c, og kjøre kapital 0. 

La oss skrive noe sånt Zamyla i små bokstaver angir. Og nå har vi Zamyla i store bokstaver. La oss skrive inn Rob i små bokstaver. La oss prøve Jason i små bokstaver. Og vi får stadig tvunget kapitalisering. Det er en mindre feil som jeg slags ikke hadde forutsett. Legg merke til min nye spørsmål er sluttet opp på samme linje som deres navn, som føles litt rotete. 

Så jeg kommer til å gå her, og faktisk ved slutten av dette programmet skrive ut et linjeskift karakter. Det er alt. Med printf, trenger du ikke å passere i variabler eller format kode. Du kan bokstavelig talt bare skrive noe som en ny linje. 

Så la oss gå videre og gjøre kapital 0 igjen, kjør det, Zamyla. Og nå er det litt penere. Nå er mitt spørsmål om sin egen nye linje. Så det er alt fint og bra. Så det er et godt eksempel. Men jeg vet ikke engang nødvendigvis må hardt koden den 32. Vet du hva? Jeg kunne say-- jeg ikke noen gang huske hva forskjellen er. 

Men jeg vet at hvis jeg har en liten bokstav, Jeg egentlig ønsker å trekke seg uansett avstanden er mellom lite en og stor A, fordi hvis jeg antar at alle de andre bokstavene er de samme, som bør få jobben gjort. Men heller enn å gjøre det, vet du hva? Det er en annen måte likevel. 

Hvis det er kapital 1.c-- hvis jeg var for å sette det inn i en egen fil. la oss bruker store bokstaver 2.c som følger. Jeg kommer til å virkelig rydde opp her. Og i stedet for å måtte vet eller bryr seg om de som er lavt nivå gjennomføring detaljer, jeg er i stedet bare kommer til å skrive ut et tegn, quote unquote, prosent C, og deretter ringe en annen funksjon som Det finnes som tar et argument, som er et tegn, som dette. 

Det viser seg i C, er det en annen funksjon samtale til øvre, noe som navnet antyder tar en karakter og gjør det til sin øvre sak tilsvarende, og returnerer det slik at printf kan plugge den inn der. Og så å gjøre dette, men jeg behov for å innføre en annen fil. Det viser seg at det er en annen fil at du bare ville vite fra klassen, eller en lærebok eller en elektronisk referanse, kalt C type.h. 

Så hvis jeg legger det opp blant mine header filer, og nå re-kompilere dette programmet, capitalize2, ./capitalize2 Enter. La oss skrive inn Zamyla i alt små bokstaver, fungerer fortsatt den samme. Men vet du hva? Det viser seg at for å over har noen annen funksjonalitet. 

Og la meg presentere dette kommandoen her, liksom klønete navngitt, men mannen for manuell. Det viser seg at de fleste Linux-maskiner, som vi bruker her-- Linux operativsystem system-- har en kommando kalt mann, som sier: hei, datamaskin, gi meg datamaskinens manual. hva vil du slå opp i den manuelle? 

Jeg vil slå opp funksjonen kalt til øvre, Enter. Og det er litt kryptisk å lese noen ganger. Men legg merke til vi er i Linux programmerer håndboken. Og det er all tekst. Og legg merke til at det er den Navnet på funksjonen her oppe. Det viser seg at det har en fetter som heter til lavere, noe som gjør det motsatte. Og legg merke til etter synopsis, for å bruke dette fungere mannen siden, så å si, forteller meg at jeg må inkludere c type.h. Og jeg visste at fra praksis. 

Her er det viser meg de to prototyper for funksjonen slik at hvis jeg noen gang vil bruke denne Jeg vet hva de tar som input, og hva de kommer tilbake som utgang. Og så hvis jeg leser beskrivelsen, ser jeg i mer detalj hva funksjonen gjør. Men enda viktigere, hvis Jeg ser under returverdi, det står den returnerte verdien er at av den konverterte brevet, eller C, den opprinnelige inngangs, hvis omdannelsen var ikke mulig. 

Med andre ord, for å over vil prøve å konvertere et brev til store bokstaver. Og hvis så, det kommer til å returnere den. Men hvis det ikke kan for noen reason-- kanskje det er allerede store bokstaver, kanskje det er et utropstegn eller en annen punctuation-- det bare kommer til å returnere den opprinnelige C, som betyr at jeg kan lage min kode bedre konstruert som følger. 

Jeg trenger ikke alle disse darn linjer med kode. Alle linjene jeg noens bare fremhevet kan bli kollapset i bare ett enkelt linje, som er dette-- printf prosent c til øvre S brakett i. Og dette ville være en eksempel på bedre design. 

Hvorfor implementere i 7 eller 8 linjer kode, uansett hva det var jeg bare slettet, når du kan i stedet kollapse alle som logikk og beslutningstaking til en enkelt linje, 13 nå, som er avhengig av et bibliotek function-- en funksjon som kommer med C, men det gjør akkurat hva du vil den skal gjøre. Og, ærlig, selv om det kom ikke med C, du kan gjennomføre det selv, som vi har sett, med få negative int og få positiv int i forrige uke også. 

Denne koden er nå mye mer lesbar. Og, ja, hvis vi bla opp, se hvor mye mer kompakt denne versjonen av mitt program er. Det er litt topptung nå, med alle disse inneholder. Men det er OK, fordi nå står jeg på skuldrene av programmerere før meg. Og hvem det var som iverksatt for å over virkelig gjorde meg en tjeneste, omtrent som den som implementert Stirling virkelig gjorde meg en tjeneste for en tid siden. Og så nå har vi en bedre design program som implementerer den samme logikken. 

Speaking of Stirling, la meg gå videre og gjøre dette. La meg gå videre og lagre denne filen som stirling.c. Og det viser seg, kan vi skrelle tilbake en annen lag ganske enkelt nå. Jeg kommer til å gå videre og pisk opp et annet program i hoved her at bare re-redskaper strenglengde som følger. Så her er en linje med kode som får meg en streng fra brukeren. Vi fortsetter å bruke dette igjen og igjen. La meg gi meg selv en variabel kalt n av typen int som lagrer et nummer. 

Og la meg gå videre og Gjør følgende logikk. Mens det n'te tegnet i s gjør ikke like skråstrek 0, gå videre og øke n. Og deretter skrive ut printf prosent i n. Jeg hevder at dette programmet her, uten å kalle streng lengde, tall ut lengden av en streng. 

Og magien er helt innkapslet i linje 8 her det ser ut som ny syntaks, Dette backslash 0 i enkle anførselstegn. Men hvorfor er det? Vel, vurdere hva som er skjer hele tiden. 

Og som en side før jeg glemmer, innser også at i tillegg til de man-sidene som kommer med en typisk Linux-system som CS50 IDE, innse at vi, den Kurset ansatte, har også laget en nettside versjon av den samme ideen som kalles reference.cs50.net, som har alle de samme man-sidene, alt dette samme dokumentasjon, samt en liten boks på toppen som gjør at du konvertere alle de nokså uforståelige språk til mindre komfortabel modus, hvor vi, i lærerstaben, har gått gjennom og prøvde å forenkle noen av språket for å holde ting fokusert på ideer, og ikke noen av formalitetene. Så husk, reference.cs50.net som en annen kilde i tillegg. 

Men hvorfor gjør strenglengde arbeid i slik jeg foreslo et øyeblikk siden? Her er Zamyla navn igjen. Og her er Zamyla navn innestengt, som jeg fortsette å gjøre, å male et bilde av det å være, egentlig, bare en sekvens av tegn. Men Zamyla eksisterer ikke isolert i et program. 

Når du skriver og kjøre et program, du bruker Mac eller PC som minne, eller RAM så å si. Og du kan tenke på datamaskinen som har mange gigabyte minne i disse dager. Og en gig betyr milliarder, så milliarder av bytes. 

Men la oss spole tilbake i tid. Og anta at vi bruker en virkelig gammel datamaskin som bare har 32 byte minne. Jeg kunne, på skjermen min, bare trekke dette ut som følger. 

Jeg kunne bare si at min Datamaskinen har alt dette minne. Og dette er som en stokk med minne, hvis du husker vår bilde fra forrige gang. Og hvis jeg bare dele dette i nok ganger, Jeg påstår at jeg har 32 bytes av minne på skjermen. 

Nå, i virkeligheten, kan jeg bare trekke så langt på denne skjermen her. Så jeg kommer til å gå videre, og bare ved konvensjonen, trekke datamaskinens minne som en gitter, ikke bare som en rett linje. Spesielt hevder jeg nå at dette rutenettet, dette åtte av 4 rutenett, bare representerer alle 32 bytes tilgjengelig minne i min Mac, eller tilgjengelig i min PC. Og de er innpakning på to linjer, bare fordi det passer mer på skjermen. Men dette er den første byte. Dette er den andre byten. Dette er den tredje byte. 

Og dette er den 32. byte. Eller, hvis vi tenke som en datamaskin vitenskapsmann, er dette byte 0, 1, 2, 3, 31. Så du har 0-31, hvis du begynner å telle på 0. 

Så hvis vi bruker et program at samtalene blir streng, og vi får en snor fra den humane som jeg gjorde kalt Zamyla, Z-A-M-Y-L-A, hvordan i all verden gjør datamaskin holde styr på hvilke byte, som del av minnet, tilhører hvilken streng? Med andre ord, hvis vi går videre til skriver et annet navn i datamaskinen, som dette Andi, ringer få strengen en andre gang, A-N-D-I har til å ende opp i maskinens minne også. Men hvordan? 

Vel, det viser seg at under hette, hva C gjør når lagring av strenger at mennesketyper i, eller at komme fra en annen kilde, er det markerer slutten av dem med en spesiell character-- skråstrek 0, som er bare en spesiell måte si 80 biter på rad. 

Så A-- dette er nummer 97 tilbakekalling. Så noen mønster av 8 bits representerer desimaltall 97. Dette backslash 0 er bokstavelig talt antall 0, også kjent nul, N-U-L, i motsetning til tidligere, N-U-L-L, som vi snakket om. Men for nå, bare vet at dette backslash 0 er kun 80 bits på rad. 

Og det er nettopp denne linjen i sand som sier noe til venstre hører til en streng, eller en datatype. Og noe til høyre hører til noe annet. Andi navn, i mellomtiden, som bare visuelt skjer for å vikle på den annen linje, men det er bare et estetisk detalj, på samme måte er nul avsluttet. 

Det er en streng med en A-N-D-I-tegn, pluss en femte hemmelig karakter, alle 0 biter, som bare avgrenser slutten av Andi navn i tillegg. Og hvis vi kaller får streng for tredje gang i datamaskinen for å få en streng som Maria M-A-R-I-A, er tilsvarende Maria Navnet nul avsluttet med backslash 0. 

Dette er fundamentalt forskjellig fra hvordan en datamaskin ville vanligvis lagre et helt tall, eller en flåte, eller annen datatyper fortsatt, fordi husker, et tall er vanligvis 32 biter, eller 4 byte, eller kanskje til og med 64 bits, eller åtte bytes. Men mange primitiver i en datamaskin i et programmeringsspråk ha et fast antall byte under hood-- kanskje en, kanskje to, kanskje fire, kanskje åtte. 

Men strenger, med design, har en dynamisk antall tegn. Du vet ikke på forhånd, før mennesketyper i Z-A-M-Y-L-A, eller M-A-R-I-A eller A-N-D-I. Du vet ikke hvor mange ganger brukeren kommer til å treffe tastaturet. Derfor trenger du ikke vet hvordan mange tegn i forveien du kommer til å trenge. 

Og så C bare slags blader som en hemmelig brødsmule under panseret ved slutten av strengen. Etter lagring av Z-A-M-Y-L-A i minnet, det også bare setter tilsvar av en periode. Ved slutten av en setning, det setter 80 biter, slik som å huske hvor Zamyla begynner og slutter. 

Så hva er forbindelsen, da, til dette programmet? Dette programmet her, Stirling, er ganske enkelt en mekanisme for å få en streng fra brukeren, linje 6. Linje 7, erklærer jeg en variabel kalt n og sette den lik 0. 

Og så i linje 8, bare spurte jeg spørsmål, mens den n-te tegn gjør ikke lik alle 0 bits-- med andre ord, ikke gjør lik denne spesielle karakter, backslash 0, som var bare at spesielle nul character-- gå videre og bare øke n. 

Og fortsette å gjøre det, og holde å gjøre det, og fortsette å gjøre det. Og så selv om det i Tidligere har vi brukt i, det er helt greit semantisk å bruke n, hvis du bare prøver å teller denne gangen med vilje, og bare ønsker å kalle det n. Så dette bare fortsetter å stille spørsmålet, er det n-te karakter er alle 0s? Hvis ikke, se til neste utseende, se til den neste, se til neste, se til neste. 

Men så snart du ser backslash 0, dette loop-- linje 9 gjennom 11-- stopper. Du bryte ut av mens loop, forlater innsiden av den variabelen n en total telling av alle tegn i strengen du så, dermed skrive den ut. Så la oss prøve dette. 

La meg gå videre og uten bruker stirling funksjon, men bare ved hjelp av min egen hjemmelaget versjon her kalt stirling, la meg gå videre og kjøre Stirling, skriv noe som Zamyla, som jeg vet på forhånd er seks tegn. La oss se om det fungerer. Faktisk er det seks. La oss prøve med Rob, tre tegn, tre tegn også, og så videre. Så det er alt som skjer på under panseret. Og legg merke til tilkoblingene, deretter, med den første uken av klasse, hvor vi snakket om noe som abstraksjon, som er nettopp dette lagdeling av ideer, eller kompleksitet, på toppen av grunnleggende prinsipper. Her, vi er liksom ute under panseret av Stirling, så å si, for å finne ut, hvordan ville det bli gjennomført? 

Og vi kunne re-implementere det selv. Men vi aldri igjen kommer å re-implementere Stirling. Vi skal bare bruke stirling for å faktisk få noen strenger lengde. 

Men det er ingen magisk under panseret. Hvis du vet at under panseret, en streng er bare en sekvens av tegn. Og at sekvens av tegn alle kan numerisk adressert med brakett 0, brakett 1, brakett 2, og du vet at ved enden av en streng er en spesialtegn, kan du finne ut hvordan du gjør de fleste noe i en program, fordi alt det koker ned til leser og skriver minne. Det er, i endring og ser på minne, eller flytte ting rundt i minne, trykking ting på skjermen, og så videre. 

Så la oss nå bruke denne nyvunne forståelse av hva strenger faktisk er under panseret, og skrelle tilbake en annen lag som inntil nå har vi vært ignorerer helt. I særdeleshet, når som helst Vi har iverksatt et program, vi har hatt denne linjen med kode nær toppen erklærte hoved. Og vi har angitt int main annullert. 

Og det tomrommet i parentes har vært å si hele tiden at hoved selv ikke ta noen argumenter. Eventuelle innspill som hoved er skal komme fra brukeren må komme fra noen andre mekanisme, som get int, eller få flyte, eller få streng, eller en annen funksjon. Men det viser seg at når du skriver et program, du kan faktisk spesifisere at dette programmet skal tar inngangssignaler fra den humane på kommandolinjen i seg selv. 

Med andre ord, selv om vi hittil har vært i drift bare ./hello hallo eller lignende programmer, alle av andre programmer som vi har brukt, at vi selv ikke skrive, har blitt tatt, det virker, kommandolinje arguments-- ting som gjør. Du sier noe som make, og deretter en andre ord. Eller klang, sier du clang, og deretter en andre ord, navnet på en fil. 

Eller enda RM eller CP, som du kanskje har sett eller brukt allerede å fjerne eller kopiere filer. Alle disse ta såkalt kommandolinje arguments-- flere ord på terminalen teksten. Men frem til nå, vi selv har ikke hatt denne luksusen av å ta innspill fra brukeren når han eller hun faktisk kjører selve programmet på kommandolinjen. 

Men vi kan gjøre det ved å re-erklære Hoved fremover, ikke som å ha ugyldig i parentes, men disse to argumenter instead-- første et heltall, og den andre noe nytt, noe som vi kommer til å kalle en matrise, noe lignende i ånd til hva vi så i Scratch som en liste, men en rekke strenger, som vi vil snart se. Men la oss se dette ved Som et eksempel, før vi skille nøyaktig hva det betyr. 

Så hvis jeg går inn CS50 IDE her har jeg gått fremover og erklærte i en fil kalt argv0.c følgende mal. Og legg merke til den eneste som er annerledes så langt er at jeg har forandret tomrommet til int argc streng argv åpen brakett, nær brakett. Og legg merke til nå, er det ingenting inne i disse aldersgruppene. 

Det finnes ingen tall. Og det er ingen i, eller n, eller en hvilken som helst annen bokstav. Jeg bare bruker hakeparentes for nå, av grunner vi vil komme tilbake til i løpet av et øyeblikk. 

Og nå hva jeg skal gjøre, er dette. Hvis argc lik lik 2-- og husker som tilsvarer likemenn er likestilling operatør sammenligne venstre og høyre for likestilling. Det er ikke oppdraget Operatøren, som er singelen likhetstegn, noe som betyr at kopi fra høyre mot venstre noen verdi. 

Hvis argc lik lik 2, ønsker jeg å sier printf, hallo, prosenter, ny linje, og koble deretter in-- og her er den nye trick-- argv brakett 1, av grunner at vi vil komme tilbake til i et øyeblikk. Else hvis argc ikke lik 2, vet du hva? La oss bare gå videre og, som vanlig, print ut hello world med ingen erstatning. 

Så det synes som om argc, som står for argumentet teller, er lik 2, Jeg kommer til å skrive ut hei eller annet. Ellers, som standard, er jeg kommer til å skrive ut hello world. Så hva betyr dette? 

Vel, la meg gå videre og lagre denne filen, og deretter gjør argv0, og deretter ./argv0, Enter. Og det sier hei verden. Nå, hvorfor er det? 

Vel, det viser seg når du kjøre et program på kommandolinjen, du fyller på hva vi vil vanligvis kaller et argument vektor. Med andre ord, automatisk datamaskinen, operativsystemet, kommer til å levere til programmet selv en liste over alle ordene at den menneskelige skrevet på spørsmål, i tilfelle du programmereren ønsker å gjøre noe med denne informasjonen. Og i dette tilfellet er den eneste ord Jeg har skrevet på teksten er ./argv0. 

Og så antallet argumenter som er blir sendt til programmet mitt er bare én. Med andre ord, argumentet teller, også kjent som argc her som et heltall, er bare ett. En selvfølgelig ikke lik to. Og så dette er hva skriver, hallo verden. 

Men la meg ta dette et sted. La meg si, argv0. Og så hva med Maria? Og så trykker på Enter. 

Og legg merke til hva som magisk som skjer her. Nå, i stedet for hallo verden, har jeg endret oppførsel av dette programmet ved å ta inngangs ikke fra get streng eller en annen funksjon, men fra, tilsynelatende, min kommando selv, hva jeg opprinnelig skrevet i. Og jeg kan spille dette spillet igjen ved endre den til Stelios, for eksempel. 

Og nå ser jeg et annet navn fortsatt. Og her kan jeg si Andi. Og jeg kan si Zamyla. Og vi kan spille dette spillet hele dagen lang, bare plugge i forskjellige verdier, så lenge jeg gi nøyaktig to ord på spørsmål, slik at argc, mitt argument teller, er 2. 

Ser jeg det navnet plugget inn printf, per denne tilstanden her? Så vi synes å ha nå uttrykksevne for å ta inndata fra en annen mekanisme, fra den såkalte kommandolinjen, i stedet for å måtte vente inntil brukeren kjører programmet, og deretter be ham eller henne bruke noe sånt get streng. 

Så hva er dette? Argc, igjen, er bare et tall, antall words-- arguments-- at brukeren gis ved teksten på terminalvinduet, inkludert programmets navn. Så vår ./argv0 er effektivt, programmets navn, eller hvordan jeg kjører programmet. 

Som teller som et ord. Så argc ville være en. Men når jeg skriver Stelios, eller Andi, eller Zamyla, eller Maria, det betyr at argumentet teller er to. Og så nå er det to ord gått inn. 

Og legg merke til, kan vi fortsette denne logikken. Hvis jeg faktisk si noe som Zamyla Chan, fullt navn, og dermed passerer tre argumenter totalt, Nå står det standard igjen, grunn, selvfølgelig, 3 ikke er lik to. 

Og så på denne måten, jeg har tilgang via argv denne nye argument at vi kunne teknisk kalle noe vi ønsker. Men etter konvensjonen, er det argv og argc, henholdsvis. Argv, argument vektor, er snill av et synonym for et programmerings funksjonen i C kalles en matrise. 

En matrise er en liste over lignende verdier tilbake, til rygg, og bakover, mot rygg. Med andre ord, er om man her i RAM, er den neste rett ved siden av den, og rett ved siden av den. De er ikke over alt. Og det sistnevnte scenario, hvor ting er over alt i minnet, kan faktisk være en kraftig funksjon. Men vi vil komme tilbake til det når vi snakke om mer avansert datastrukturer. For nå er en matrise bare en mengde sammenhengende minne, hver av der elementene tilbake, til rygg, og bakover, mot rygg, og generelt den samme type. 

Så hvis du tenker på, fra en øyeblikk siden, hva er en streng? Vel, en streng, som Zamyla, Z-A-M-Y-L-A, er teknisk sett bare en matrise. Det er en rekke tegn. 

Og så hvis vi virkelig trekke dette, som jeg gjorde tidligere, som en del av minne, det viser seg at hver av disse tegn tar opp en byte. Og så er det den spesielle sentinel karakter, backslash 0, eller alle åtte 0 biter, som avgrenser slutten av strengen. Så en streng, viser det ut, sitere unquote streng, er bare et utvalg av chara-- røye være en aktuell datatype. 

Og nå argv, meanwhile-- La oss gå tilbake til programmet. Argv, selv om vi ser ordet streng her, er ikke en streng selv. Argv, argument vektor, er en rekke strenger. 

Så akkurat som du kan ha en rekke tegn, kan du ha høyere nivå, en rekke strings-- slik at, for eksempel, når jeg skrev en stund siden ./argv0 argv0, plass Z-A-M-Y-L-A, I hevdet at argv hadde to strenger i it ./argv0, og Z-A-M-Y-L-A. I Med andre ord, argc var 2. Hvorfor det? 

Vel, effektivt, er det som skjer på er at hver av disse strengene er selvsagt en rekke tegn som før, hver av der tegnene tar opp en byte. Og ikke forveksle den faktiske 0 i programmets navn med 0, noe som betyr at alle 80 bits. Og Zamyla, i mellomtiden, er fortsatt også en rekke tegn. 

Så på slutten av dagen, det egentlig ser slik ut under panseret. Men argv, av naturen av hvordan hoved verker, tillater meg å pakke alt dette opp i, om du vil, en større matrise at hvis vi litt over forenkle hva bildet ser ut og ikke ganske trekke det å skalere opp der, denne matrisen er bare av størrelse 2, den første element som inneholder en streng, det andre elementet i som inneholder en streng. Og, i sin tur, hvis du slags zoome inn på hver av disse strengene, hva du se under panseret er at hver streng er bare en rekke med tegn. 

Nå, akkurat som med strenger, vi var i stand til å få tilgang til i-te tegn i en streng bruker som hakeparentes notasjon. På samme måte, med matriser Generelt kan vi bruke hakeparentes notasjon for å få på en rekke strenger i en matrise? For eksempel, la meg gå videre og gjøre dette. 

La meg gå videre og skape argv1.c, som er litt annerledes denne gangen. I stedet for å se etter argc2, Jeg kommer til stedet gjøre dette. For int jeg får 0, er jeg mindre enn argc, jeg pluss pluss, og deretter skrive ut innsiden av denne, prosent s, ny linje, og deretter argv brakett i. 

Så med andre ord, jeg er ikke arbeider med individuelle tegn i øyeblikket. Argv, som følger av disse tomme plassen bukseseler til høyre for navnet argv, betyr argv er en rekke strenger. Og argc er bare en int. 

Denne linjen her, seks, er sier sett i lik 0. Telle hele veien opp til, men ikke inkludert, argc. Og deretter på hver iterasjon, skrive ut en streng. Hva streng? 

I-te streng i argv. Så mens før jeg var bruker hakeparentes notasjon for å få på ith tegn i en streng, nå Jeg bruker hakeparentes notasjon å få på ith strengen i en matrise. Så det er på en måte ett lag ovenfor, konseptuelt. 

Og så hva er ryddig om dette programmet nå, hvis jeg kompilere argv1, og deretter gjøre ./argv1, og skriv deretter inn i noe som foo bar baz, som er de tre standard ord som en datamaskin vitenskapsmann strekker seg etter noe tid han eller hun trenger noen plassholder ord, og trykk Enter, og hver av disse ordene, inkludert programmets navn, som er i argv på det første sted, ender opp med å bli skrevet ut en av gangen. Og hvis jeg endrer dette, og jeg sier noe som argv1 Zamyla Chan, vi få alle tre av dem ord, som er argv0, argv1, argv2, fordi i denne case argc, telle, er tre. 

Men hva er ryddig er hvis du forstår som argv er bare et utvalg av strenger, og du forstår at en streng er en rekke tegn, vi kan faktisk slags bruk dette hakeparentes notasjons flere ganger å velge en streng, og velg deretter et tegn i strengen, dykking i dypere som følger. I dette eksempelet, la meg gå videre og kaller dette argv2.c. Og i dette eksempelet, la meg gå videre og gjøre den following-- for int jeg får 0, Jeg er mindre enn argc, jeg pluss pluss, akkurat som før. Så i andre words-- og nå dette blir komplisert nok. Så jeg kommer til å si iterere over strenger i argv, som en kommentar til meg selv. Og så kommer jeg til å ha en nestet for loop, som du sannsynligvis har gjort, eller vurdert gjør, i Scratch, hvor Jeg kommer til å si int-- jeg er ikke kommer til å bruke i på nytt, fordi jeg ikke ønsker å skygge, eller slags overskrive den eksisterende i. 

Jeg kommer til stedet, sier j, fordi det er mine går til variabelen etter at jeg, når jeg prøver bare å telle enkle tall. For j får 0-- og også, n, kommer til å få hekken lengden av argv brakett i, så lenge som j er mindre enn m, j pluss pluss, gjør følgende. Og her er den interessante delen. 

Skriv ut en karakter og en ny linje, plugge i argv brakett jeg, brakett j. OK, så la meg legge til noen kommentarer her. Iterere over tegn i aktuelle strengen, print j-te karakter i i-te streng. Så nå, la oss vurdere hva disse kommentarene mener. 

Iterere over strengene i argv-- hvor mange strenger er i argv, som er en matrise? Argc mange, så jeg gjentar fra i lik 0 opp til argc. I mellomtiden, hvor mange tegn er i den i-te streng i argv? 

Vel, for å få det svaret, Jeg bare ringe strenglengde på den aktuelle strengen jeg omsorg om, som er argv brakett i. Og jeg kommer til å midlertidig lagre som verdi i n, bare for caching formål, å huske det for effektivitet. Og så skal jeg initial j 0, holde det gående så lenge som j er mindre enn n, og på hver iterasjon økning j. 

Og så i her, per min kommentar på linje 12, skrive ut et tegn, etterfulgt av en ny linje, spesielt argv brakett Jeg gir meg i-te streng i argv-- så det første ordet, andre ord, den tredje ord, uansett. Og så j dykk i dypere og får meg j-te karakter av ordet. Og så, i kraft, kan du behandle argv som en flerdimensjonal, som en to-dimensjonal, matrise, der hvert ord slags utseende som dette i ditt sinn øyet, og hvert tegn er slags komponert i en kolonne, hvis det hjelper. 

I virkeligheten, når vi erte Dette leilighets i fremtiden uker, det kommer til å være litt mer avansert enn det. Men du kan virkelig tenke på det, for nå, som nettopp dette todimensjonale matrise, hvorved en nivå av det er alle strengene. Og så hvis du dykke i dypere, du kan få på de enkelte tegn disse ved å bruke denne notasjonen her. 

Så hva er nettoeffekten? La meg gå videre og gjøre argv2-- darn det. Jeg gjorde en feil her. Implisitt erklære bibliotek funksjon Stirling. Så hele denne tiden, er det kanskje passende at vi er liksom etterbehandling akkurat der vi startet. 

Jeg skrudd opp, implisitt erklære bibliotek funksjon Stirling. OK, vent litt. Jeg husker det, spesielt siden det er rett her. Jeg må ta string.h i denne versjonen av programmet. 

La meg gå videre og omfatte string.h, lagre det, gå videre og rekompilere argv2. Og nå, her går vi, gjør argv2, Enter. Og selv om det er litt kryptisk ved første øyekast, Legg merke til at, ja, hva skrives er prikk argv2. 

Men hvis jeg skriver noen ord etter teksten, som argv2 Zamyla Chan, Skriv også litt kryptisk ved første øyekast. Men hvis vi bla opp igjen, ./argv2 Z-A-M-Y-L-A C-H-A-N. Så vi har gjentok over hvert ord. Og i sin tur har vi gjentok løpet hvert tegn i et ord. 

Nå, etter alt dette, innse at det er en annen detalj vi har vært snill for å ignorere dette hele tiden. Vi ertet bare fra hverandre hva viktigste innganger kan være? Hva om hoved utgang? 

Hele tiden har vi vært bare å kopiere og lime inn ordet int foran hoved, om du kan se på nettet, noen ganger feil i eldre versjoner av C og kompilatorer, som de sier ugyldig, eller ingenting i det hele tatt. Men, ja, for den versjonen av C som vi bruker, C 11, eller 2011, innser at det skal være int. Og det bør heller være ugyldig eller argc og argv her. 

Men hvorfor int main? Hva er det egentlig tilbake? Vel, det viser seg all denne tiden, når du har skrevet et program hoved er alltid tilbake noe. Men det har vært å gjøre det i hemmelighet. 

At noe er en int, som linje 5 antyder. Men hva int? Vel, det er dette stevne i programmering, hvorved Hvis ingenting har gått galt og alt er bra, programmer og funksjoner generelt return-- noe counterintuitively-- 0. 0 vanligvis betyr at alt er bra. Så selv om du tenker på den som falsk i mange sammenhenger, det faktisk betyr vanligvis en god ting 

I mellomtiden, hvis et program returnerer 1, eller negativ 1 eller 5, eller negativ 42, eller hvilket som helst ikke-0-verdi, som vanligvis betyr at noe har gått galt. Faktisk, på din egen Mac eller PC, du kanskje har faktisk sett en feilmelding, der det sier et eller annet, feil kode negativ 42, eller feilkode 23, eller noe sånt. At antallet er vanligvis bare et hint til programmereren, eller selskapet som gjorde programvaren, hva som gikk galt og hvorfor, slik at de kan se igjennom dokumentasjonen eller kode, og finne ut hva error egentlig betyr. Det er som regel ikke nyttig for oss sluttbrukere. 

Men når hoved returnerer 0, alt er bra. Og hvis du ikke angir hva hoved skal returnere, det vil bare automatisk returnere 0 for deg. Men tilbake noe ellers er faktisk nyttig. 

I denne siste programmet, la meg gå videre og kaller dette exit.c, og innføre den siste av dagens emner, kjent som en feilkode. La meg gå videre og inkludere våre kjente filer opp toppen, gjør int main. Og denne gangen, la oss gjøre int argc, string argv, og med mine brak å antyde at det er i rekken. Og så la meg bare gjøre en helsesjekk. Denne gangen, hvis argc ikke lik 2, så vet du hva? Glem det. Jeg kommer til å si at, hei, bruker, du mangler kommandolinje argument backslash n. 

Og så det er det. Jeg ønsker å avslutte. Jeg kommer til å preemptively, og for tidlig egentlig, retur noe annet enn tallet 1. Farten til verdien for første feil som kan skje er en. Hvis du har noen andre feilaktige situasjon som kan oppstå, kan du si retur to eller returnere 3, eller kanskje til og med negativ ett eller negativ to. 

Dette er bare exit koder det er, generelt, bare nyttig til programmereren eller selskap som sender programvaren. Men det faktum at det er ikke 0 er det som er viktig. Så hvis du er i dette programmet, vil jeg garantere at dette programmet bare fungerer hvis brukeren gir meg med et argument greven av to, navnet på programmet, og en annen ord, kan jeg håndheve så mye som følger, kjefte på brukeren med printf ordtak, mangler kommandolinje argument, returnere en. Det vil bare umiddelbart avslutte programmet. 

Bare hvis argc tilsvarer 2 vil vi få ned her, slik at jeg kommer til å si, hei prosent s, backslash n, argv1. Med andre ord, jeg er ikke gå etter argv 0, som er bare navnet på programmet. Jeg ønsker å skrive ut hallo, komma, den andre ord at den menneskelige skrevet. Og i dette tilfellet videre linje 13, alt er bra. 

Jeg vet at argc er 2 logisk av dette programmet. Jeg kommer til å gå videre og returnere 0. Som en side, husk at dette er sant i Scratch også. 

Logisk, jeg kunne gjøre dette og innkapsle disse linjene kode i denne ellers klausul her. Men det er liksom unødvendig innrykk koden min. Og jeg vil lage super klart at uansett hvilken, som standard, hallo noe vil bli skrevet ut, så lenge brukeren samarbeider. 

Så det er veldig vanlig å bruke en tilstand, bare en hvis, å fange noen feilaktige situasjon, og deretter avslutte. Og så, er så lenge alle vel, ikke har et annet, men bare har koden utenfor at hvis, fordi det er tilsvarende i denne spesielle tilfellet, logisk. Så jeg er tilbake 0, bare for å eksplisitt betegne alt er bra. 

Hvis jeg utelatt avkastningen 0, ville det automatisk bli lagt til grunn for meg. Men nå som jeg er tilbake en i det minste i dette tilfellet Jeg kommer til å, for godt mål, og klarhet, returnerer 0 i dette tilfellet. Så nå la meg gå videre og gjøre exit, som er en perfekt naturlig overgang å bare la. 

Men gjør exit, og la meg gå videre og gjøre ./exit, Enter. Og programmet skrek til meg, mangler kommandolinje argument. OK, la meg samarbeide. 

La meg i stedet gjøre ./exit, David, Enter. Og nå sier det, hallo David. Og du normalt ikke ville se dette. 

Men det viser seg at det er en spesiell måte i Linux for å faktisk se med hva exit kode et program avsluttes. Noen ganger i en grafisk verden som Mac OS eller Windows, du bare se disse tallene når en feilmeldingen dukker opp på skjermen og programmereren viser at antall. Men hvis vi ønsker å se hva feilen Budskapet er, vi kan gjøre det her-- så ./exit, Enter, print mangler kommandolinje argument. 

Hvis jeg nå gjør echo $ ?, som er latterlig kryptisk utseende. Men $? er magisk besvergelse som sier hei, datamaskin, fortell meg hva den forrige programmets avslutningskode var. Og jeg trykker på Enter. Jeg ser en, fordi det er det jeg fortalte min viktigste funksjonen til å returnere. 

I mellomtiden, hvis jeg gjør ./exit David, og trykk Enter, ser jeg, hallo David. Og hvis jeg nå gjør ekko $ ?, jeg ser hallo 0. Og så vil dette faktisk være verdifull informasjon i sammenheng med debugger, ikke så mye at du som menneske, ville vare. Men debugger og andre programmene vi vil bruke dette semesteret vil ofte se på det nummeret, selv om det er slags gjemt bort med mindre du ser for det, for å avgjøre om et program eller ikke utførelsen var riktig eller feil. 

Og så det bringer oss til dette, på slutten av dagen. Vi begynte i dag med å se på debugging, og i sin tur på kurset i seg selv, og da mer interessant, teknisk under panseret hva strenger er, som sist uke vi bare tok for gitt, og sikkert tok dem for gitt i Scratch. 

Vi så på hvordan vi kan få tilgang til individuelle tegn i en streng, og deretter igjen tok et høyere nivå se på ting, se på hvordan samt-- hvis vi ønsker å få på individnivå elementer i en listelignende struktur, kan ikke vi gjøre det med flere strenger? Og vi kan med kommandolinjeargumenter. Men dette bildet her av bare bokser er demonstrative av denne generelle ideen av en matrise, eller en liste, eller en vektor. Og avhengig av kontekst, alle av disse ordene bety litt forskjellige ting. Så i C, vi bare kommer å snakke om en matrise. Og en matrise er en del minne, er hver av dem elementer er sammenhengende, tilbake, til rygg, og bakover, mot rygg. 

Og disse elementene er, generelt, av den samme datatype, karakter karakter, personlighet, karakter, eller string, string, string, string, eller int, int, int, uansett hva det er vi prøver å lagre. Men på slutten av dagen, er dette hvordan det ser ut konseptuelt. Du tar din maskinens minne eller RAM. Og du er carving det ut i identisk størrelse bokser, som alle er tilbake, til rygg, til tilbake, kan du ta på denne måten. 

Og hva er fint om denne ide, og det faktum at vi kan uttrykke verdier på denne måten med den første av de datastrukturer i klassen, betyr at vi kan starte å løse problemer med kode som kom så intuitivt i uke 0. Du husker telefonen Boken eksempel, der vi brukte en splitt og hersk, eller en Binærsøk, å sile gjennom en hel haug med navn og nummer. Men vi antok, husker, at det telefonboken var allerede sortert, at noen andre hadde allerede skjønte out-- gitt en liste med navn og numbers-- hvordan alfabetisk rekkefølge. Og nå som i C vi, også har evnen å legge ting ut, ikke fysisk i en telefonbok men nesten i en datamaskin minne, vil vi være i stand til neste uke å innføre nytt dette-- den første av våre datastrukturer i en array-- men enda viktigere, selve datamaskinen vitenskap algoritmer implementert i kode, som vi kan lagre data i strukturer som dette, og deretter begynne å manipulere den, og å faktisk løse problemer med det, og å bygge på toppen av det, slutt, programmer i C, i Python, i Javascript, spørring databaser med SQL? 

Og vi vil se at alle disse forskjellige ideer sperre. Men for nå, husker at domene som vi introduserte i dag var denne tingen her, og en verden av kryptografi. Og blant de neste problemene du selv vil løse er kunsten kryptografi, scrambling og de-scrambling informasjon, og kryptering og å tyde teksten, og antar slutt som du nå vet hva er under panseret slik at når du ser eller mottar en melding som dette, du selv kan tyde den. Alt dette, og mer neste gang. 

[VIDEO PLAYBACK] 

-Mover Nettopp kommet. Jeg kommer til å gå besøk hans college professor. Jepp. Hei. Det er deg. Vente! David. Jeg prøver bare å finne ut hva som skjedde med deg. Vær så snill, noe kunne hjelpe. Du var hans college romkamerat, var du ikke? Du var der med ham når han avsluttet CS50 prosjektet? 

[MUSIKK] 

-Det Var CS50. 

Jeg elsker dette stedet. 

-Spise opp. Vi skal ut av business. 

[END PLAYBACK] 