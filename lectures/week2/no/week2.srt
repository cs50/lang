1
00:00:00,000 --> 00:00:02,970
>> [MUSIKK]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN: Greit.

4
00:00:15,700 --> 00:00:18,832
Dette er CS50 og dette
er starten av uke 2.

5
00:00:18,832 --> 00:00:21,040
Og du husker at over
de siste par ukene,

6
00:00:21,040 --> 00:00:24,490
vi har vært innføring av datamaskin
vitenskap og i sin tur programmering.

7
00:00:24,490 --> 00:00:27,640
>> Og vi begynte historien ved hjelp av
Scratch, som grafisk språk

8
00:00:27,640 --> 00:00:28,990
fra MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
Og så sist,
forrige uke, gjorde vi

10
00:00:30,780 --> 00:00:34,450
innføre en higher-- en
lavere nivå språk kjent

11
00:00:34,450 --> 00:00:36,770
som C, noe som er rent tekstlig.

12
00:00:36,770 --> 00:00:39,440
Og, ja, sist gang vi
utforsket innenfor den konteksten

13
00:00:39,440 --> 00:00:40,450
en rekke begreper.

14
00:00:40,450 --> 00:00:43,010
>> Dette, husker, var det veldig
første programmet vi så på.

15
00:00:43,010 --> 00:00:45,710
Og dette programmet, rett og slett,
skrives ut, "hallo, verden."

16
00:00:45,710 --> 00:00:47,730
Men det er så mye
tilsynelatende magiske skjer.

17
00:00:47,730 --> 00:00:51,460
Det er denne #include
med disse vinkelparenteser.

18
00:00:51,460 --> 00:00:52,170
Det er int.

19
00:00:52,170 --> 00:00:53,020
Det er (void).

20
00:00:53,020 --> 00:00:56,330
Det er parenteser, klammeparentes,
semikolon, og så mye mer.

21
00:00:56,330 --> 00:00:58,480
>> Og så, husker at
vi introdusert Scratch

22
00:00:58,480 --> 00:01:02,110
slik at vi kunne, ideelt sett, se forbi
som syntaks, ting det er egentlig ikke

23
00:01:02,110 --> 00:01:04,590
alt som intellektuelt
interessant, men tidlig på

24
00:01:04,590 --> 00:01:07,700
er, absolutt, litt vanskelig
å vikle tankene dine rundt.

25
00:01:07,700 --> 00:01:10,860
Og faktisk en av de mest vanlige
ting tidlig i et programmerings klasse,

26
00:01:10,860 --> 00:01:13,443
spesielt for de mindre
behagelig, er å bli frustrert av

27
00:01:13,443 --> 00:01:17,460
og utløst opp av visse syntaktiske
feil, og ikke minst logiske feil.

28
00:01:17,460 --> 00:01:19,800
Og så blant våre mål
i dag, faktisk, vil

29
00:01:19,800 --> 00:01:23,280
være å utstyre deg med noen
problemløsning teknikker for hvordan

30
00:01:23,280 --> 00:01:26,705
å bedre løse problemene selv
i form av feilsøking.

31
00:01:26,705 --> 00:01:29,330
Og du husker også at den
miljø som vi innførte

32
00:01:29,330 --> 00:01:31,780
siste gang ble kalt CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Dette er web-basert programvare som
kan du programmere i skyen,

34
00:01:34,850 --> 00:01:38,450
så å si, samtidig som alle dine
filer sammen, som vi igjen vil i dag.

35
00:01:38,450 --> 00:01:41,480
Og minner om at vi
revisited disse temaene her,

36
00:01:41,480 --> 00:01:44,480
blant dem funksjoner og looper, og
variabler, og boolske uttrykk,

37
00:01:44,480 --> 00:01:45,110
og forhold.

38
00:01:45,110 --> 00:01:49,190
Og faktisk noen flere som vi
oversatt fra verden av Scratch

39
00:01:49,190 --> 00:01:50,800
til en verden av C.

40
00:01:50,800 --> 00:01:53,220
>> Men grunnleggende bygge
blokker, så å si,

41
00:01:53,220 --> 00:01:55,150
var egentlig fortsatt det samme forrige uke.

42
00:01:55,150 --> 00:01:57,900
Faktisk er vi egentlig bare hadde en
annerledes puslespill brikke, hvis du vil.

43
00:01:57,900 --> 00:02:00,300
I stedet for det purpur
redde blokk, vi i stedet

44
00:02:00,300 --> 00:02:02,940
hadde printf, som er
denne funksjonen i C som

45
00:02:02,940 --> 00:02:05,890
kan du skrive ut noe
og formatere den på skjermen.

46
00:02:05,890 --> 00:02:07,950
Vi introduserte CS50
Bibliotek, hvor du

47
00:02:07,950 --> 00:02:11,420
nå har til disposisjon get_char,
og get_int, og get_string,

48
00:02:11,420 --> 00:02:14,610
og noen andre funksjoner som
vel, via som du kan få innspill

49
00:02:14,610 --> 00:02:16,260
fra brukerens eget tastatur.

50
00:02:16,260 --> 00:02:20,640
Og vi tok en titt på ting
som disse-bool, og røye,

51
00:02:20,640 --> 00:02:22,490
og double, float,
int, long_long streng.

52
00:02:22,490 --> 00:02:25,170
Og det er til og med andre datatyper i C.

53
00:02:25,170 --> 00:02:28,560
>> Med andre ord, når du deklarerer
en variabel til å lagre noen verdi,

54
00:02:28,560 --> 00:02:32,600
eller når du implementerer en funksjon
som returnerer en viss verdi,

55
00:02:32,600 --> 00:02:35,290
du kan spesifisere hva
type verdi som er.

56
00:02:35,290 --> 00:02:37,310
Er det en streng, som en
sekvens av tegn?

57
00:02:37,310 --> 00:02:39,490
Er det et antall, for eksempel et heltall?

58
00:02:39,490 --> 00:02:41,390
Er det et flyt
verdi eller lignende?

59
00:02:41,390 --> 00:02:46,180
Så i C, i motsetning til Scratch, vi faktisk
begynte å spesifisere hva slags data

60
00:02:46,180 --> 00:02:48,330
vi var tilbake eller hjelp.

61
00:02:48,330 --> 00:02:51,910
>> Men, selvfølgelig, også kjørte vi inn
noen grunnleggende grensene for databehandling.

62
00:02:51,910 --> 00:02:54,100
Og i særdeleshet,
dette språket C, tilbakekalling

63
00:02:54,100 --> 00:02:57,070
at vi tok en titt på
Heltallsoverflyt, virkeligheten

64
00:02:57,070 --> 00:03:00,460
at hvis du bare har en
begrenset mengde minne

65
00:03:00,460 --> 00:03:04,600
eller, spesielt, et endelig antall
bits, kan du bare telle så høyt.

66
00:03:04,600 --> 00:03:08,460
Og så har vi sett på dette eksemplet her
hvor en teller i et fly,,

67
00:03:08,460 --> 00:03:13,510
faktisk, hvis du kjører lenge nok ville
overflyt og resultere i en programvare

68
00:03:13,510 --> 00:03:15,560
en faktisk fysisk mulig feil.

69
00:03:15,560 --> 00:03:18,600
>> Vi så også på flytende
punkt upresishet, virkeligheten

70
00:03:18,600 --> 00:03:22,280
som med bare et endelig antall
bits, enten det er 32 eller 64,

71
00:03:22,280 --> 00:03:27,330
du kan bare spesifisere så mange tall
etter et desimaltegn, etter som du

72
00:03:27,330 --> 00:03:29,110
begynner å få upresise.

73
00:03:29,110 --> 00:03:32,360
Så for eksempel, en tredjedel i
verden her, i vår menneskelige verden,

74
00:03:32,360 --> 00:03:35,360
vi vet er bare et uendelig antall
av 3s etter desimaltegnet.

75
00:03:35,360 --> 00:03:38,820
Men en datamaskin kan ikke nødvendigvis
representerer et uendelig antall tall

76
00:03:38,820 --> 00:03:42,590
hvis du bare lar det noen
begrenset mengde informasjon.

77
00:03:42,590 --> 00:03:45,900
>> Så ikke bare gjorde vi utstyre deg
med større kraft i form

78
00:03:45,900 --> 00:03:49,280
på hvordan du kan uttrykke deg på
et tastatur i form av programmering,

79
00:03:49,280 --> 00:03:51,430
vi også begrenset hva
du kan faktisk gjøre.

80
00:03:51,430 --> 00:03:55,790
Og ja, feil og feil kan
oppstå fra slike saker.

81
00:03:55,790 --> 00:03:59,900
Og faktisk, blant temaene i dag
kommer til å være som debugging emner

82
00:03:59,900 --> 00:04:03,699
og faktisk ser under panseret
på hvordan ting ble innført i forrige uke

83
00:04:03,699 --> 00:04:05,490
faktisk blir gjennomført
slik at du bedre

84
00:04:05,490 --> 00:04:10,530
forstå både egenskapene til og
begrensningene i et språk som C.

85
00:04:10,530 --> 00:04:14,770
>> Og faktisk, vil vi skrelle tilbake lagene
av de enkleste av datastrukturen,

86
00:04:14,770 --> 00:04:17,756
noe som kalles en matrise, som
Scratch skjer å kalle en "liste".

87
00:04:17,756 --> 00:04:19,589
Det er litt
annerledes i den sammenheng.

88
00:04:19,589 --> 00:04:23,340
Og så får vi også presentere en av de
første av våre domenespesifikke problemer

89
00:04:23,340 --> 00:04:26,790
i CS50, en verden av
kryptografi, kunsten scrambling

90
00:04:26,790 --> 00:04:29,650
eller i ciphering informasjon slik
som du kan sende hemmelige meldinger

91
00:04:29,650 --> 00:04:34,520
og dekode hemmelige meldinger
mellom to personer, A og B.

92
00:04:34,520 --> 00:04:37,490
>> Så før vi overgang
til den nye verden,

93
00:04:37,490 --> 00:04:42,059
la oss prøve å utstyre deg med noen
teknikker som du kan eliminere

94
00:04:42,059 --> 00:04:43,850
eller redusere i det minste noen
av frustrasjonene

95
00:04:43,850 --> 00:04:46,630
at du sannsynligvis har møtt
den siste uken alene.

96
00:04:46,630 --> 00:04:50,830
Faktisk, før du such-- noen av
dine første problemene i C. Og oddsen er,

97
00:04:50,830 --> 00:04:54,010
Hvis du er som meg, første gang
du prøver å skrive ut et program,

98
00:04:54,010 --> 00:04:57,330
selv om du tror logisk
programmet er ganske enkel,

99
00:04:57,330 --> 00:05:01,200
du kan godt treffer en vegg, og
kompilatoren er ikke til å samarbeide.

100
00:05:01,200 --> 00:05:03,940
Gjør eller klang ikke kommer
å faktisk gjøre din budgivning.

101
00:05:03,940 --> 00:05:05,450
>> Og hvorfor kan det være?

102
00:05:05,450 --> 00:05:07,950
Vel, la oss ta en titt på,
kanskje et enkelt program.

103
00:05:07,950 --> 00:05:11,190
Jeg kommer til å gå videre og lagre dette i
en fil bevisst kalt buggy0.c,

104
00:05:11,190 --> 00:05:13,590
fordi jeg vet at det å
være feil på forhånd.

105
00:05:13,590 --> 00:05:17,400
Men jeg kan ikke forstå at hvis dette
er den første eller andre eller tredje program

106
00:05:17,400 --> 00:05:18,830
at jeg faktisk gjør meg selv.

107
00:05:18,830 --> 00:05:23,820
Så jeg kommer til å gå videre og
skriver ut, int main (void).

108
00:05:23,820 --> 00:05:28,130
Og så innsiden av mine klammeparentes,
en veldig kjent ( "Hei, world--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - og et semikolon.

110
00:05:30,980 --> 00:05:32,360
>> Jeg har lagret filen.

111
00:05:32,360 --> 00:05:34,850
Nå kommer jeg til å gå ned
til min terminal vindu

112
00:05:34,850 --> 00:05:40,340
og type make buggy0, fordi, igjen,
navnet på filen i dag er buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Så jeg skriver gjøre buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Og, ja, jøss, husker fra forrige gang
at ingen feilmeldinger er en god ting.

115
00:05:48,200 --> 00:05:49,740
Så ingen utgang er en god ting.

116
00:05:49,740 --> 00:05:52,920
Men her har jeg klart
et antall feil.

117
00:05:52,920 --> 00:05:56,470
>> Så den første linjen i produksjonen
etter å ha skrevet lage buggy0, husker,

118
00:05:56,470 --> 00:05:59,540
er klang er ganske ordrik utgang.

119
00:05:59,540 --> 00:06:02,067
Under panseret,
CS50 IDE er konfigurert

120
00:06:02,067 --> 00:06:04,150
å bruke en hel haug med
alternativer med denne kompilatoren

121
00:06:04,150 --> 00:06:05,941
slik at du ikke trenger
å tenke på dem.

122
00:06:05,941 --> 00:06:08,840
Og det er alt som førstelinje
middel som starter med klang.

123
00:06:08,840 --> 00:06:11,720
>> Men etter det, problemene
begynner å gjøre sitt utseende.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c på linje 3, karakter
5, er det en stor, rød feil.

125
00:06:17,390 --> 00:06:18,380
Hva er det?

126
00:06:18,380 --> 00:06:23,562
Implisitt erklære bibliotek funksjon
printf med type int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Jeg mener, det svært raskt
blir veldig uforståelige.

129
00:06:28,379 --> 00:06:30,170
Og sikkert, først
øyekast, ville vi ikke

130
00:06:30,170 --> 00:06:32,380
forvente deg å forstå
helheten av den meldingen.

131
00:06:32,380 --> 00:06:34,213
Og så en av leksjonene
for i dag kommer

132
00:06:34,213 --> 00:06:36,919
å være å prøve å legge merke
mønstre, eller lignende ting,

133
00:06:36,919 --> 00:06:38,960
feil du kan ha
oppstått i det siste.

134
00:06:38,960 --> 00:06:41,335
Så la oss erte hverandre bare
de ordene som ser kjent ut.

135
00:06:41,335 --> 00:06:44,290
Den store, røde feil er klart
symbolsk for noe være galt.

136
00:06:44,290 --> 00:06:47,940
>> implisitt erklære
bibliotek funksjon printf.

137
00:06:47,940 --> 00:06:51,680
Så selv om jeg ikke helt forstår hva
implisitt erklære bibliotek funksjon

138
00:06:51,680 --> 00:06:54,900
midler, problemet sikkert
relatert til printf eller annen måte.

139
00:06:54,900 --> 00:06:59,130
Og kilden til dette problemet
har å gjøre med å erklære det.

140
00:06:59,130 --> 00:07:02,440
>> Erklærte en funksjon er
nevne det for første gang.

141
00:07:02,440 --> 00:07:06,210
Og vi brukte terminologien i forrige uke
erklære en funksjon prototype,

142
00:07:06,210 --> 00:07:11,860
enten med en linje på toppen av din
egen fil eller i en såkalt topptekstfilen.

143
00:07:11,860 --> 00:07:15,300
Og i hvilken fil gjorde vi sier
i forrige uke at printf er sitat,

144
00:07:15,300 --> 00:07:17,080
unquote, erklærte?

145
00:07:17,080 --> 00:07:20,950
I hvilken fil er sin prototype?

146
00:07:20,950 --> 00:07:24,640
>> Så hvis du husker, det aller første jeg
skrevet, nesten hvert program siste tid--

147
00:07:24,640 --> 00:07:30,790
og tilfeldigvis et øyeblikk siden startet
skrive myself-- var dette en her--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- for
input / output-- dot h Og ja,

149
00:07:38,630 --> 00:07:41,860
hvis jeg nå lagre denne filen, jeg kommer
å gå videre og klare skjermen min,

150
00:07:41,860 --> 00:07:44,740
som du kan gjøre ved å skrive
Klar, eller du kan holde kontroll L,

151
00:07:44,740 --> 00:07:47,680
bare for å tømme terminalvindu
bare for å eliminere noen rot.

152
00:07:47,680 --> 00:07:51,370
>> Jeg kommer til å gå videre og
re-type make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Og voila, jeg fortsatt se at
lang kommando fra klang,

154
00:07:53,790 --> 00:07:55,470
men det er ingen feilmelding denne gangen.

155
00:07:55,470 --> 00:07:58,800
Og ja, hvis jeg gjør ./buggy0,
akkurat som forrige gang,

156
00:07:58,800 --> 00:08:01,860
hvor prikk betyr dette
katalog, Slash bare betyr,

157
00:08:01,860 --> 00:08:05,040
her kommer navnet på programmet og
at navnet på programmet er buggy0,

158
00:08:05,040 --> 00:08:07,340
Enter, "Hei, verden."

159
00:08:07,340 --> 00:08:09,440
>> Nå, hvordan kan du ha
sanket denne løsningen

160
00:08:09,440 --> 00:08:12,017
uten nødvendigvis
gjenkjenne så mange ord

161
00:08:12,017 --> 00:08:14,350
som jeg gjorde, i hvert fall, ha
gjort dette i så mange år?

162
00:08:14,350 --> 00:08:18,720
Vel, skjønner per første problemet
sett, vi introdusere deg til en kommando

163
00:08:18,720 --> 00:08:21,175
at CS50 egne ansatte
skrev kalt help50.

164
00:08:21,175 --> 00:08:24,300
Og ja, det gjør C spesifikasjon
oppgavesettet om hvordan man skal bruke dette.

165
00:08:24,300 --> 00:08:27,210
>> Men help50 er egentlig
et program som CS50 ansatte

166
00:08:27,210 --> 00:08:30,850
skrev som lar deg kjøre
en kommando eller kjøre et program,

167
00:08:30,850 --> 00:08:36,169
og hvis du ikke forstår sin
utgang, for å passere sin produksjon til help50,

168
00:08:36,169 --> 00:08:38,890
noe som medførte at programvaren
at kurset ansatte skrev

169
00:08:38,890 --> 00:08:42,429
vil se på programmet utgang
linje for linje, tegn for tegn.

170
00:08:42,429 --> 00:08:46,000
Og hvis vi, de ansatte, gjenkjenne
feilmelding om at du opplever,

171
00:08:46,000 --> 00:08:50,580
Vi vil prøve å provosere deg litt
retoriske spørsmål, med noen råd,

172
00:08:50,580 --> 00:08:54,890
mye som en TF eller en CA eller meg selv
ville gjøre personlig i kontortiden.

173
00:08:54,890 --> 00:08:58,320
>> Så se til help50 hvis du ikke
nødvendigvis å gjenkjenne et problem.

174
00:08:58,320 --> 00:09:00,790
Men ikke stole på det
for mye som en krykke.

175
00:09:00,790 --> 00:09:03,990
Gjerne prøve å forstå sin
produksjon og deretter lære av det

176
00:09:03,990 --> 00:09:07,571
slik at bare en eller to ganger gjør du
noen gang kjørt help50 for en bestemt feil

177
00:09:07,571 --> 00:09:08,070
beskjed.

178
00:09:08,070 --> 00:09:10,660
Etter det, bør du være
bedre rustet selv

179
00:09:10,660 --> 00:09:13,180
å finne ut hva det egentlig er.

180
00:09:13,180 --> 00:09:14,350
>> La oss gjøre en annen her.

181
00:09:14,350 --> 00:09:20,410
La meg gå videre, og i en annen
fil vi kaller dette buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Og i denne filen er jeg
kommer til å deliberately--

183
00:09:23,110 --> 00:09:26,330
men later som jeg ikke
forstå hva feil jeg har gjort.

184
00:09:26,330 --> 00:09:31,420
>> Jeg kommer til å gå videre og gjøre dette--
#include, siden jeg har

185
00:09:31,420 --> 00:09:33,660
lært min lekse fra et øyeblikk siden.

186
00:09:33,660 --> 00:09:36,220
Int main (void), som før.

187
00:09:36,220 --> 00:09:40,880
Og så her jeg kommer
å gjøre streng s - get_string.

188
00:09:40,880 --> 00:09:43,770
Og husker fra forrige gang
dette betyr, hei, datamaskin,

189
00:09:43,770 --> 00:09:48,280
gi meg en variabel, kaller det er, og
gjøre den type som variabel en streng

190
00:09:48,280 --> 00:09:50,150
så jeg kan lagre ett eller flere ord i den.

191
00:09:50,150 --> 00:09:52,191
>> Og så på høyre hånd
side av likhetstegnet

192
00:09:52,191 --> 00:09:54,980
er get_string, som er et
funksjon i CS50 biblioteket

193
00:09:54,980 --> 00:09:55,980
som gjør akkurat det.

194
00:09:55,980 --> 00:09:59,740
Det blir en funksjon og deretter
hender det fra høyre mot venstre.

195
00:09:59,740 --> 00:10:02,670
Så dette likhetstegnet betyr ikke
"Lik" som vi kanskje tror i matematikk.

196
00:10:02,670 --> 00:10:04,750
Det betyr oppdrag fra høyre til venstre.

197
00:10:04,750 --> 00:10:09,640
Så dette betyr, ta strengen fra
brukeren og lagre den på innsiden av s.

198
00:10:09,640 --> 00:10:10,460
>> Nå la oss bruke den.

199
00:10:10,460 --> 00:10:13,820
La meg gå videre nå og som andre
linje, la meg gå videre og si "Hei" -

200
00:10:13,820 --> 00:10:19,330
ikke "verden", men "hallo,% S-
som er vår plassholder, komma s,

201
00:10:19,330 --> 00:10:22,030
som er vår variabel,
og deretter et semikolon.

202
00:10:22,030 --> 00:10:26,070
Så hvis jeg ikke skru opp for mye
her, dette ser ut som riktig kode.

203
00:10:26,070 --> 00:10:28,090
>> Og mine instinkter nå er å kompilere den.

204
00:10:28,090 --> 00:10:30,400
Filen heter buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Så jeg kommer til å gjør buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Og søren-det, hvis det ikke finnes
enda flere feil enn før.

207
00:10:36,377 --> 00:10:38,210
Jeg mener, det er mer
feilmeldinger det would

208
00:10:38,210 --> 00:10:40,400
synes enn faktiske linjer i dette programmet.

209
00:10:40,400 --> 00:10:42,730
>> Men takeaway her er,
selv om du er overveldet

210
00:10:42,730 --> 00:10:45,040
med to eller tre eller
fire feilmeldinger,

211
00:10:45,040 --> 00:10:48,340
fokuserer alltid på veldig
første av disse meldingene.

212
00:10:48,340 --> 00:10:52,220
Ser på det øverste ett,
rulle opp igjen som må være.

213
00:10:52,220 --> 00:10:53,930
Så her skrev jeg make buggy1.

214
00:10:53,930 --> 00:10:55,700
Her er det klang utgang som forventet.

215
00:10:55,700 --> 00:10:57,290
>> Og her er den første røde feilen.

216
00:10:57,290 --> 00:11:02,370
Bruk av svart identifikator
string, jeg mener standarden i?

217
00:11:02,370 --> 00:11:04,260
Så standard i er
faktisk noe annet.

218
00:11:04,260 --> 00:11:06,240
Det refererer til brukerens
tastatur, i hovedsak.

219
00:11:06,240 --> 00:11:08,080
>> Men det er ikke det jeg mente.

220
00:11:08,080 --> 00:11:11,770
Jeg mente streng, og jeg mente get_string.

221
00:11:11,770 --> 00:11:16,200
Så hva er det som jeg
glemte å gjøre denne gangen?

222
00:11:16,200 --> 00:11:20,230
Hva mangler denne gangen?

223
00:11:20,230 --> 00:11:23,600
Jeg har min #include,
så jeg har tilgang til printf.

224
00:11:23,600 --> 00:11:26,090
>> Men det har jeg ikke
tilgang til ennå?

225
00:11:26,090 --> 00:11:29,420
Vel, akkurat som forrige gang,
Jeg trenger å fortelle kompilatoren

226
00:11:29,420 --> 00:11:31,691
Klang hva disse funksjonene er.

227
00:11:31,691 --> 00:11:33,940
Get_string kommer ikke
med C. og spesielt det

228
00:11:33,940 --> 00:11:38,160
kommer ikke i
header fil,.

229
00:11:38,160 --> 00:11:40,770
Den kommer i stedet inn
noe ansatte skrev:

230
00:11:40,770 --> 00:11:44,176
som er en annen fil
nevne men treffende navn.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Så ved å legge at en linje
av code-- tilbakekalling fra forrige gang

233
00:11:50,861 --> 00:11:53,610
at når klang går, kommer det til
å se på koden min topp til bunn,

234
00:11:53,610 --> 00:11:54,193
venstre til høyre.

235
00:11:54,193 --> 00:11:57,200
Det kommer til å legge merke til,
oh, du ønsker.

236
00:11:57,200 --> 00:11:59,900
La meg gå og finne det,
hvor det er på serveren,

237
00:11:59,900 --> 00:12:03,090
kopiere og lime, i hovedsak,
inn i toppen av din egen fil

238
00:12:03,090 --> 00:12:06,820
slik at på dette punktet i historien,
linje 1, resten av programmet

239
00:12:06,820 --> 00:12:11,651
kan faktisk bruke noen av funksjonene
der, blant dem get_string.

240
00:12:11,651 --> 00:12:13,650
Så jeg kommer til å ignorere
resten av disse feilene,

241
00:12:13,650 --> 00:12:17,190
fordi jeg faktisk mistenker at det bare
den første faktisk betydde noe.

242
00:12:17,190 --> 00:12:20,780
Og jeg kommer til å gå videre og reprise,
etter lagring filen min gjør buggy1.

243
00:12:20,780 --> 00:12:22,580
Og voila, det fungerte.

244
00:12:22,580 --> 00:12:29,200
Og hvis jeg gjør ./buggy1 og skriv inn, for
eksempel, Zamyla, jeg nå vil få hallo,

245
00:12:29,200 --> 00:12:32,000
Zamyla, i stedet for hallo, verden.

246
00:12:32,000 --> 00:12:32,550
>> Greit.

247
00:12:32,550 --> 00:12:35,890
Så gatekjøkken her da skal,
en, kan du prøve å fange opp så mye som mulig

248
00:12:35,890 --> 00:12:39,140
fra feilmeldingene alene, på jakt
på noen av de gjenkjennelige ord.

249
00:12:39,140 --> 00:12:43,070
Sperring at bruker help50 per
oppgavesettet spesifikasjonen.

250
00:12:43,070 --> 00:12:46,500
Men sperring det også, alltid se
på toppen feilen bare, i det minste

251
00:12:46,500 --> 00:12:50,051
innledningsvis, for å se hva slags informasjon
det kan faktisk gi.

252
00:12:50,051 --> 00:12:52,300
Men det viser seg at det er
enda mer funksjonalitet inne

253
00:12:52,300 --> 00:12:55,030
inn i CS50 biblioteket for å hjelpe
du tidlig i semesteret

254
00:12:55,030 --> 00:12:57,580
og tidlig i programmering
finne ut hva som går galt.

255
00:12:57,580 --> 00:12:59,840
Så la oss gjøre et annet eksempel her.

256
00:12:59,840 --> 00:13:04,350
Jeg kommer til å kalle denne buggy2, som
igjen, kommer til å være feil ut

257
00:13:04,350 --> 00:13:05,650
av porten, ved design.

258
00:13:05,650 --> 00:13:09,980
>> Og jeg kommer til å gå videre
og gjøre #include.

259
00:13:09,980 --> 00:13:12,580
Og så kommer jeg til å gjøre int main (void).

260
00:13:12,580 --> 00:13:14,840
Og så kommer jeg til å gjøre en for loop.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i er mindre enn eller lik ti.

263
00:13:18,750 --> 00:13:24,260
i ++, og deretter i klammeparentes, kommer jeg
å skrive ut bare en hashtag symbol her

264
00:13:24,260 --> 00:13:25,920
og en ny linje karakter.

265
00:13:25,920 --> 00:13:29,220
>> Så min hensikt med dette
Programmet er ganske enkelt

266
00:13:29,220 --> 00:13:33,150
å veksle 10 ganger
og på hver iterasjon

267
00:13:33,150 --> 00:13:35,260
av at sløyfe hver gang
gjennom syklusen,

268
00:13:35,260 --> 00:13:37,660
skrive ut en hashtag,
en hashtag, en hashtag.

269
00:13:37,660 --> 00:13:40,480
Én per linje fordi jeg
har den nye linjen der.

270
00:13:40,480 --> 00:13:42,787
Og minner om at det for
loop, per siste week--

271
00:13:42,787 --> 00:13:44,620
og du får mer
kjent med syntaks

272
00:13:44,620 --> 00:13:47,170
ved å bruke det med praksis
før long-- dette gir meg

273
00:13:47,170 --> 00:13:49,740
en variabel som heter jeg, og setter den til 0.

274
00:13:49,740 --> 00:13:52,650
>> Dette intervaller jeg på
hver iterasjon av en.

275
00:13:52,650 --> 00:13:54,940
Så jeg går til 1 til 2-3.

276
00:13:54,940 --> 00:13:57,690
Og så denne tilstanden i
midt mellom semikolon

277
00:13:57,690 --> 00:14:03,010
blir sjekket på hver iterasjon å gjøre
sikker på at vi fortsatt er innenfor rekkevidde.

278
00:14:03,010 --> 00:14:06,830
Så jeg ønsker å gjenta 10 ganger, så jeg
har liksom veldig intuitivt bare

279
00:14:06,830 --> 00:14:09,070
satt 10 som min øvre grense der.

280
00:14:09,070 --> 00:14:14,310
>> Og likevel, når jeg kjører dette, etter
kompilere det med make buggy2--

281
00:14:14,310 --> 00:14:15,440
og det gjør kompilere OK.

282
00:14:15,440 --> 00:14:17,980
Så jeg har ikke en
syntax error denne gangen.

283
00:14:17,980 --> 00:14:20,940
La meg gå videre nå
og kjøre buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Og nå bla opp.

285
00:14:22,620 --> 00:14:24,890
Og la meg øke
størrelsen på vinduet.

286
00:14:24,890 --> 00:14:33,720
>> Jeg ser ut til å ha en, to, tre,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Så det er 11 hashtags, selv om
Jeg tydelig satt 10 inne i denne sløyfen.

288
00:14:38,891 --> 00:14:42,140
Nå kan noen av dere ser umiddelbart
hvilken feilen er fordi faktisk denne

289
00:14:42,140 --> 00:14:43,720
er ikke en veldig vanskelig feil å gjøre.

290
00:14:43,720 --> 00:14:46,070
Men det er veldig vanlig
gjort svært tidlig.

291
00:14:46,070 --> 00:14:49,820
>> Det jeg ønsker å påpeke, skjønt,
er, hvordan kan jeg finne ut av dette?

292
00:14:49,820 --> 00:14:52,300
Vel, det viser seg at
den CS50 biblioteket kommer

293
00:14:52,300 --> 00:14:55,380
med ikke bare get_string og get_int
og get_float og andre funksjoner.

294
00:14:55,380 --> 00:14:59,980
Den kommer også med en spesiell funksjon
kalt eprintf, eller feil printf.

295
00:14:59,980 --> 00:15:03,270
Og det eksisterer kun for å gjøre
det litt enklere for deg

296
00:15:03,270 --> 00:15:06,310
når debugging koden for å bare
skrive ut en feilmelding på skjermen

297
00:15:06,310 --> 00:15:07,850
og vet hvor den kom fra.

298
00:15:07,850 --> 00:15:11,000
>> Så for eksempel, en ting jeg kan
gjøre her med denne funksjonen er dette--

299
00:15:11,000 --> 00:15:20,230
eprintf, og da kommer jeg til å gå videre
og si jeg er nå% i, skråstrek, n.

300
00:15:20,230 --> 00:15:22,330
Og jeg kommer til å plugge i verdien av i.

301
00:15:22,330 --> 00:15:25,400
Og opp toppen, fordi dette
er i CS50 biblioteket,

302
00:15:25,400 --> 00:15:27,580
Jeg kommer til å gå videre
og inkluderer

303
00:15:27,580 --> 00:15:29,169
så jeg har tilgang til denne funksjonen.

304
00:15:29,169 --> 00:15:31,460
Men la oss vurdere hvilken linje
9 er ment å gjøre.

305
00:15:31,460 --> 00:15:32,670
Jeg kommer til å slette dette til slutt.

306
00:15:32,670 --> 00:15:34,670
Dette har ingenting å gjøre
med min overordnede mål.

307
00:15:34,670 --> 00:15:39,090
Men eprintf, feil printf, er bare ment
å gi meg noen diagnostisk informasjon.

308
00:15:39,090 --> 00:15:42,460
Når jeg kjører mitt program, jeg ønsker å
se dette på skjermen midlertidig

309
00:15:42,460 --> 00:15:44,550
så vel bare å forstå
hva skjer.

310
00:15:44,550 --> 00:15:47,330
>> Og, faktisk, på hvert
gjentakelse her på linje 9

311
00:15:47,330 --> 00:15:49,260
Jeg ønsker å se, hva er verdien av jeg?

312
00:15:49,260 --> 00:15:50,290
Hva er verdien av i?

313
00:15:50,290 --> 00:15:51,280
Hva er verdien av i?

314
00:15:51,280 --> 00:15:55,650
Og, forhåpentligvis, skal jeg bare
se at meldingen også, 10 ganger.

315
00:15:55,650 --> 00:15:57,780
>> Så la meg gå videre og
rekompilere programmet mitt,

316
00:15:57,780 --> 00:15:59,905
så jeg må gjøre som helst
Jeg gjør en endring. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Og now-- OK.

319
00:16:03,640 --> 00:16:04,820
Det er mye mer å gå på.

320
00:16:04,820 --> 00:16:07,610
Så la meg bla opp i
en enda større vindu.

321
00:16:07,610 --> 00:16:10,190
>> Og vil du se at hver av
hashtag er fortsatt utskrift.

322
00:16:10,190 --> 00:16:15,270
Men i mellom hver av dem er nå dette
diagnostikk utgang formateres som følger.

323
00:16:15,270 --> 00:16:17,960
Navnet mitt program her er buggy2.

324
00:16:17,960 --> 00:16:20,432
Navnet på filen er buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Linjen tallet som
dette ble skrevet er linje 9.

326
00:16:24,080 --> 00:16:27,500
Og deretter til høyre for den som er
feilmelding om at jeg er gravid.

327
00:16:27,500 --> 00:16:30,701
>> Og hva er fint om dette er at
nå jeg trenger ikke å nødvendigvis telle

328
00:16:30,701 --> 00:16:32,200
i hodet mitt hva min programmet gjør.

329
00:16:32,200 --> 00:16:34,240
Jeg kan se at på
første iterasjon i er 0,

330
00:16:34,240 --> 00:16:39,420
så en, så to, så tre, så fire, så
5, deretter 6, deretter 7, deretter 8, deretter 9, deretter

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Så vent litt.

333
00:16:42,050 --> 00:16:43,740
Hva foregår her?

334
00:16:43,740 --> 00:16:48,190
Jeg fortsatt synes å telle
som forutsatt opp til 10.

335
00:16:48,190 --> 00:16:50,550
>> Men hvor kom jeg begynne?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Så 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11. finger

338
00:16:58,040 --> 00:16:59,990
er en indikasjon på problemet.

339
00:16:59,990 --> 00:17:02,850
Jeg synes å ha regnet
feil i min loop.

340
00:17:02,850 --> 00:17:06,599
Snarere enn å gå 10 gjentakelser,
Jeg begynner på 0,

341
00:17:06,599 --> 00:17:09,550
Jeg endte på og gjennom 10.

342
00:17:09,550 --> 00:17:12,030
Men fordi, som en datamaskin,
Jeg begynner å telle på 0,

343
00:17:12,030 --> 00:17:15,250
Jeg skal telle opp
til, men ikke gjennom, 10.

344
00:17:15,250 --> 00:17:18,510
>> Og så fikse, jeg til slutt
realisert her, er en av to ting.

345
00:17:18,510 --> 00:17:22,430
Jeg kunne veldig enkelt si
teller opp til mindre enn 10.

346
00:17:22,430 --> 00:17:27,260
Så 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, som er faktisk riktig,

347
00:17:27,260 --> 00:17:28,900
selv om det høres litt feil.

348
00:17:28,900 --> 00:17:35,070
Eller jeg kunne gjøre mindre enn eller lik
til ni, så lenge jeg starter på 0.

349
00:17:35,070 --> 00:17:40,056
Eller hvis du virkelig ikke liker det,
kan telle opp til 10, men starter på en.

350
00:17:40,056 --> 00:17:41,680
Men igjen, dette er bare ikke så vanlig.

351
00:17:41,680 --> 00:17:43,977
I programming-- riktignok
ikke så mye i Scratch--

352
00:17:43,977 --> 00:17:45,810
men i programmering i
C og andre språk,

353
00:17:45,810 --> 00:17:47,670
som Javascript og
Python og andre, er det

354
00:17:47,670 --> 00:17:49,880
bare veldig vanlig for
vår diskusjon av binære

355
00:17:49,880 --> 00:17:53,450
å bare begynne å telle på
laveste tallet du kan, som er 0.

356
00:17:53,450 --> 00:17:53,950
Greit.

357
00:17:53,950 --> 00:17:55,160
Så det er eprintf.

358
00:17:55,160 --> 00:17:58,600
Og igjen, nå som jeg har funnet ut min
problem, og jeg kommer til å gå tilbake til 0

359
00:17:58,600 --> 00:18:01,470
gjennom mindre enn 10, skal jeg
å gå inn og slette eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Det bør ikke være der når jeg
sende min kode eller sender min kode

361
00:18:04,580 --> 00:18:05,800
eller vise det til noen andre.

362
00:18:05,800 --> 00:18:07,980
Det er egentlig bare ment
som skal brukes midlertidig.

363
00:18:07,980 --> 00:18:11,650
Men nå har jeg fikset dette
spesielt problem i tillegg.

364
00:18:11,650 --> 00:18:16,780
>> Vel, la oss gjøre enda et eksempel her
at jeg kommer til å piske opp som følger.

365
00:18:16,780 --> 00:18:22,850
Jeg kommer til å gå videre og
# include. $ 50

366
00:18:22,850 --> 00:18:25,580
Og jeg kommer til å gå videre
og #include.

367
00:18:25,580 --> 00:18:29,030
>> Og jeg kommer til å spare
denne filen som buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Og jeg kommer til å gå videre
og erklære int main (void).

369
00:18:31,740 --> 00:18:34,186
Og så innsiden av det
Jeg kommer til å gjøre int i _ -

370
00:18:34,186 --> 00:18:36,435
Jeg ønsker å gjennomføre et program
med en get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Dette er ikke en funksjon som eksisterer ennå.

373
00:18:40,770 --> 00:18:42,870
Så vi kommer til å gjennomføre
det i bare et øyeblikk.

374
00:18:42,870 --> 00:18:45,541
Men vi kommer til å se hvorfor
det er buggy ved første passering.

375
00:18:45,541 --> 00:18:47,290
Og når jeg har fått
en int fra brukeren,

376
00:18:47,290 --> 00:18:53,365
Jeg skal bare skrive% i er en negativ
heltall, skråstrek, n, komma, jeg.

377
00:18:53,365 --> 00:18:55,240
Med andre ord, alt jeg
vil dette programmet å gjøre

378
00:18:55,240 --> 00:18:58,000
er å få en negativ int fra
brukeren og deretter skrive ut

379
00:18:58,000 --> 00:18:59,980
at slik og slik er en negativ int.

380
00:18:59,980 --> 00:19:02,080
>> Nå trenger jeg å implementere denne funksjonen.

381
00:19:02,080 --> 00:19:05,740
Så senere i filen min, jeg kommer til å gå
videre og erklærer en funksjon som heter

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - og vi vil
komme tilbake til hva den linjen betyr igjen

383
00:19:10,670 --> 00:19:18,790
i en moment-- int n; do-- do
den following-- printf n er :.

384
00:19:18,790 --> 00:19:26,210
Og så kommer jeg til å gjøre n - get_int,
og gjøre dette mens n er større enn 0.

385
00:19:26,210 --> 00:19:28,310
Og så tilbake n ;.

386
00:19:28,310 --> 00:19:31,730
>> Så det er mye som skjer i
dette, men ingen av dem vi ikke

387
00:19:31,730 --> 00:19:33,710
ser på forrige uke, minst kort.

388
00:19:33,710 --> 00:19:36,980
Så på linje 10 her har jeg erklært
funksjon kalt get_negative_int,

389
00:19:36,980 --> 00:19:39,620
og jeg har satt (void), i
parentes, årsaken er denne

390
00:19:39,620 --> 00:19:40,950
tar ikke en inngang.

391
00:19:40,950 --> 00:19:42,910
Jeg er ikke bestått noe
til denne funksjonen.

392
00:19:42,910 --> 00:19:44,690
Jeg bare får noe tilbake fra den.

393
00:19:44,690 --> 00:19:47,270
>> Og hva jeg håper å
komme tilbake er et heltall.

394
00:19:47,270 --> 00:19:50,040
Det er ingen datatype i
C kalles negative_int.

395
00:19:50,040 --> 00:19:52,880
Det er bare int, så det kommer
å være på oss for å være sikker

396
00:19:52,880 --> 00:19:55,340
at verdien som faktisk er
returneres, er ikke bare en int

397
00:19:55,340 --> 00:19:56,380
men er også negativ.

398
00:19:56,380 --> 00:20:02,150
>> På linje 12 er jeg erklære en variabel
kalt n og gjør det av type int.

399
00:20:02,150 --> 00:20:07,500
Og så i linje 13 gjennom 18 Jeg er
gjøre noe mens noe er sant.

400
00:20:07,500 --> 00:20:11,040
Jeg går videre og utskrift
n er, kolon, og deretter et mellomrom,

401
00:20:11,040 --> 00:20:12,800
som en ledetekst for brukeren.

402
00:20:12,800 --> 00:20:16,410
>> Jeg så ringer get_int og
lagring av sin såkalte returverdi

403
00:20:16,410 --> 00:20:18,130
i den variabelen n.

404
00:20:18,130 --> 00:20:22,600
Men jeg kommer til å fortsette å gjøre
dette mens n er større enn 0.

405
00:20:22,600 --> 00:20:27,960
Med andre ord, hvis brukeren gir meg en
int og at antallet er større enn 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positiv, jeg kommer til å
bare holde reprompting brukeren,

407
00:20:31,180 --> 00:20:37,160
holde reprompting, ved å tvinge dem til å
samarbeide og gi meg en negativ int.

408
00:20:37,160 --> 00:20:41,640
>> Og når n er faktisk negative--
anta at brukeren til slutt typer -50,

409
00:20:41,640 --> 00:20:46,710
da dette mens sløyfen er ikke lenger sant
fordi -50 ikke er større enn 0.

410
00:20:46,710 --> 00:20:51,140
Så vi bryte ut av det
sløyfe logisk og tilbake n.

411
00:20:51,140 --> 00:20:53,520
>> Men det er en annen
ting jeg må gjøre.

412
00:20:53,520 --> 00:20:56,190
Og jeg kan bare gjøre dette
ved å kopiere og lime inn

413
00:20:56,190 --> 00:20:58,540
en kodelinje på toppen av filen.

414
00:20:58,540 --> 00:21:01,630
Jeg trenger å lære klang,
eller lover å klang,

415
00:21:01,630 --> 00:21:04,630
eksplisitt at jeg vil,
ja, gå og implementere

416
00:21:04,630 --> 00:21:06,020
denne funksjonen get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Det kan bare være lavere i filen.

418
00:21:07,674 --> 00:21:09,840
Igjen, husker at klang
leser ting topp til bunn,

419
00:21:09,840 --> 00:21:12,330
venstre til høyre, slik at du ikke kan
kalle en funksjon hvis klang

420
00:21:12,330 --> 00:21:15,330
ikke vet det kommer til å eksistere.

421
00:21:15,330 --> 00:21:18,430
>> Nå, dessverre, dette programmet,
som noen av dere kanskje har lagt merke til,

422
00:21:18,430 --> 00:21:19,590
er allerede buggy.

423
00:21:19,590 --> 00:21:21,400
La meg gå videre og gjøre buggy3.

424
00:21:21,400 --> 00:21:26,904
Det kompilerer, så problemet mitt nå er ikke
en syntaksfeil, som en tekstlig feil,

425
00:21:26,904 --> 00:21:29,570
det er faktisk kommer til å være en logisk
feil som jeg har bevisst

426
00:21:29,570 --> 00:21:32,450
laget som en mulighet til å
gå gjennom hva som skjer.

427
00:21:32,450 --> 00:21:35,540
>> Jeg kommer til å gå videre
nå og kjøre buggy3.

428
00:21:35,540 --> 00:21:37,490
Og jeg kommer til å gå
fremover og ikke samarbeide.

429
00:21:37,490 --> 00:21:39,494
Jeg kommer til å gi den nummer 1.

430
00:21:39,494 --> 00:21:41,410
Det gjorde ikke liker det, så
det er å spørre meg igjen.

431
00:21:41,410 --> 00:21:42,147
>> Hva med to?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Ingen av de som jobber.

435
00:21:44,740 --> 00:21:46,890
Hva med -50?

436
00:21:46,890 --> 00:21:48,560
Og programmet ser ut til å fungere.

437
00:21:48,560 --> 00:21:49,970
>> La meg prøve det en gang.

438
00:21:49,970 --> 00:21:53,400
La meg prøve -1, ser ut til å fungere.

439
00:21:53,400 --> 00:21:56,380
La meg prøve -2, ser ut til å fungere.

440
00:21:56,380 --> 00:21:59,640
La meg prøve 0.

441
00:21:59,640 --> 00:22:01,684
Huh, det er feil.

442
00:22:01,684 --> 00:22:03,350
Nå er vi å være litt pedantisk her.

443
00:22:03,350 --> 00:22:07,090
Men det er faktisk slik at 0
verken positiv eller negativ.

444
00:22:07,090 --> 00:22:11,150
Og så det faktum at mitt program er
si at 0 er et negativt helt tall,

445
00:22:11,150 --> 00:22:12,820
det er ikke teknisk korrekt.

446
00:22:12,820 --> 00:22:15,180
>> Nå, hvorfor er det å gjøre dette?

447
00:22:15,180 --> 00:22:16,270
Vel, det kan være åpenbar.

448
00:22:16,270 --> 00:22:18,110
Og, ja, er programmet
ment å være ganske enkel

449
00:22:18,110 --> 00:22:19,670
så vi har noe å utforske.

450
00:22:19,670 --> 00:22:25,870
>> Men la oss introdusere en tredje debugging
Teknikken her kalt debug50.

451
00:22:25,870 --> 00:22:27,750
Så dette er et program
at vi har nettopp opprettet

452
00:22:27,750 --> 00:22:30,770
i år heter debug50
som vil tillate deg

453
00:22:30,770 --> 00:22:34,130
å bruke det som kalles en innebygd
grafisk debugger i CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Og en debugger er bare et program som
vanligvis lar deg kjøre programmet

455
00:22:38,400 --> 00:22:44,050
men skritt for skritt for skritt, linje
ved linje for linje, pause, poking

456
00:22:44,050 --> 00:22:47,626
rundt, ser på variabler, slik at
programmet ikke bare blåse forbi deg

457
00:22:47,626 --> 00:22:49,750
og raskt skrive ut noe
eller ikke skrive ut noe.

458
00:22:49,750 --> 00:22:53,250
Det gir deg en mulighet, på
human hastighet, for å kommunisere med den.

459
00:22:53,250 --> 00:22:55,470
>> Og for å gjøre dette, du
bare gjøre følgende.

460
00:22:55,470 --> 00:22:58,479
Etter kompilering koden din,
som jeg allerede gjorde, buggy3,

461
00:22:58,479 --> 00:23:00,020
du gå videre og kjøre debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Så mye som help50 har du kjører
help50 og deretter kommandoen,

464
00:23:06,760 --> 00:23:10,120
debug50 har du kjørt debug50 og
deretter navnet på kommandoen.

465
00:23:10,120 --> 00:23:14,440
>> Nå se hva som skjer på skjermen min,
på den høyre siden i særdeleshet.

466
00:23:14,440 --> 00:23:19,400
Når jeg treffer Run, alle
Plutselig panel dette høyre

467
00:23:19,400 --> 00:23:20,419
åpner opp på skjermen.

468
00:23:20,419 --> 00:23:22,210
Og det er mye som skjer
på ved første øyekast.

469
00:23:22,210 --> 00:23:25,110
Men det er ikke for
mye å bekymre seg for ennå.

470
00:23:25,110 --> 00:23:28,570
>> Dette viser meg alt
det som skjer på innsiden av mitt program

471
00:23:28,570 --> 00:23:31,130
akkurat nå, og via disse
knapper opp toppen er så

472
00:23:31,130 --> 00:23:35,910
tillater meg å gå gjennom min kode
til slutt trinn for trinn for trinn.

473
00:23:35,910 --> 00:23:37,140
Men ikke ennå.

474
00:23:37,140 --> 00:23:38,060
Legg merke til hva som skjer.

475
00:23:38,060 --> 00:23:40,600
På min terminalvindu
Jeg blir bedt om n.

476
00:23:40,600 --> 00:23:44,560
Og jeg kommer til å gå videre og
samarbeider denne gangen og skriv inn -1.

477
00:23:44,560 --> 00:23:48,770
Og riktignok litt kryptisk, -1
er et negativt helt tall, som forventet.

478
00:23:48,770 --> 00:23:52,020
>> Og så barnet gått ut med
status 0 GDBserver spennende.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, er navnet
av den underliggende programvare

480
00:23:55,180 --> 00:23:56,620
som implementerer dette debugger.

481
00:23:56,620 --> 00:24:00,500
Men alt dette egentlig betyr, debugger
gikk bort fordi programmet mitt sluttet

482
00:24:00,500 --> 00:24:01,710
og alt var vel.

483
00:24:01,710 --> 00:24:06,020
Hvis jeg ønsker å virkelig feilsøke mitt program,
Jeg må preemptively fortelle debug50,

484
00:24:06,020 --> 00:24:08,920
der ønsker jeg å starte
stepping gjennom koden min?

485
00:24:08,920 --> 00:24:11,750
>> Og kanskje den enkleste måten
å gjøre det på er som følger.

486
00:24:11,750 --> 00:24:15,300
Hvis jeg sveve over
takrenne av redaktøren min her,

487
00:24:15,300 --> 00:24:19,090
så egentlig bare på sidelinjen her,
til venstre for linjen nummer,

488
00:24:19,090 --> 00:24:21,870
Legg merke til at hvis jeg klikker bare
gang, satte jeg en liten rød prikk.

489
00:24:21,870 --> 00:24:24,460
Og det lille røde prikken,
som et stoppskilt, betyr, hei,

490
00:24:24,460 --> 00:24:29,430
debug50, pause gjennomføring av koden min
der når jeg kjører dette programmet.

491
00:24:29,430 --> 00:24:30,260
>> Så la oss gjøre det.

492
00:24:30,260 --> 00:24:37,340
La meg gå videre og kjøre mitt program
igjen med debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Og nå, varsel, noe
annet har skjedd.

494
00:24:40,110 --> 00:24:42,440
Jeg er ikke å bli spurt
men i mitt terminalvindu

495
00:24:42,440 --> 00:24:45,430
for noe, fordi jeg har ikke
fått det ennå i mitt program.

496
00:24:45,430 --> 00:24:47,950
Legg merke til at på linje 8
som nå er markert,

497
00:24:47,950 --> 00:24:51,720
og det er en liten pil på
igjen sier, er du satt på pause her.

498
00:24:51,720 --> 00:24:55,030
Dette kodelinje, linje
8, har ennå ikke utført.

499
00:24:55,030 --> 00:24:58,940
>> Og hva er nysgjerrig, hvis jeg ser
over her på høyre side,

500
00:24:58,940 --> 00:25:03,530
merker at jeg er en lokal
variabel, lokal i den forstand

501
00:25:03,530 --> 00:25:05,450
at det er inni den aktuelle funksjonen.

502
00:25:05,450 --> 00:25:08,920
Og dens verdi, tilsynelatende som standard,
og liksom praktisk, er 0.

503
00:25:08,920 --> 00:25:10,260
Men jeg ville ikke skrive 0.

504
00:25:10,260 --> 00:25:13,410
Det bare skjer for å være dens
Standardverdien for øyeblikket.

505
00:25:13,410 --> 00:25:15,490
>> Så la meg gå videre og gjøre dette nå.

506
00:25:15,490 --> 00:25:18,680
La meg gå videre og videre
Øverst til høyre her, jeg

507
00:25:18,680 --> 00:25:20,970
kommer til å gå videre og
Klikk denne første ikonet som

508
00:25:20,970 --> 00:25:25,360
betyr skritt over hvilke betyr ikke hoppe
det, men gå over denne linjen med kode,

509
00:25:25,360 --> 00:25:27,770
utfører det underveis.

510
00:25:27,770 --> 00:25:30,710
>> Og nå, merker, min
teksten har nettopp endret.

511
00:25:30,710 --> 00:25:31,380
Hvorfor det?

512
00:25:31,380 --> 00:25:33,639
Jeg har fortalt debug50,
kjøre denne linjen med kode.

513
00:25:33,639 --> 00:25:34,930
Hva betyr denne linjen med kode gjøre?

514
00:25:34,930 --> 00:25:35,960
Ber meg for en int.

515
00:25:35,960 --> 00:25:36,460
OK.

516
00:25:36,460 --> 00:25:37,400
La meg samarbeide.

517
00:25:37,400 --> 00:25:41,340
La meg gå videre nå og skriver -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Og nå legger merke til hva som er endret.

519
00:25:42,920 --> 00:25:46,060
På høyre side,
min lokale variable i

520
00:25:46,060 --> 00:25:48,200
angis som -1 nå.

521
00:25:48,200 --> 00:25:49,810
Og det er fortsatt av typen int.

522
00:25:49,810 --> 00:25:53,102
>> Og legg merke til, også, min såkalte
kaller stack, der gjorde jeg en pause?

523
00:25:53,102 --> 00:25:54,810
Vi skal snakke mer om
dette i fremtiden.

524
00:25:54,810 --> 00:25:58,620
Men samtalen stabelen bare refererer til hva
funksjoner er for tiden i bevegelse.

525
00:25:58,620 --> 00:26:00,040
Akkurat nå er det bare hoved.

526
00:26:00,040 --> 00:26:03,590
Og akkurat nå er det eneste lokale
variabelen er jeg med en verdi på 1.

527
00:26:03,590 --> 00:26:09,840
>> Og når jeg endelig gå over denne linjen
her, med det samme ikonet øverst til høyre,

528
00:26:09,840 --> 00:26:11,410
-1 Er et negativt heltall.

529
00:26:11,410 --> 00:26:13,580
Nå er det pause over det krøllete brace.

530
00:26:13,580 --> 00:26:14,740
La oss la den gjøre sin ting.

531
00:26:14,740 --> 00:26:17,300
Jeg gå over den linjen, og voila.

532
00:26:17,300 --> 00:26:20,240
>> Så det er ikke alle som fryktelig
opplysende ennå,

533
00:26:20,240 --> 00:26:23,550
men det lot meg pause
og tenke gjennom logisk

534
00:26:23,550 --> 00:26:24,870
hva dette programmet gjør.

535
00:26:24,870 --> 00:26:26,890
Men det var ikke den feilaktige saken.

536
00:26:26,890 --> 00:26:28,510
La oss gjøre dette igjen som følger.

537
00:26:28,510 --> 00:26:31,340
>> Jeg kommer til å forlate det stoppunkt
på linje 8 med den røde prikken.

538
00:26:31,340 --> 00:26:32,830
Jeg kommer til å kjøre debug50.

539
00:26:32,830 --> 00:26:34,400
Det er automatisk satt på pause her.

540
00:26:34,400 --> 00:26:37,660
Men denne gangen, i stedet for
tråkke over denne linjen,

541
00:26:37,660 --> 00:26:42,290
la meg faktisk gå inni
get_negative_int og finne ut,

542
00:26:42,290 --> 00:26:45,530
hvorfor er det å akseptere 0 som et gyldig svar?

543
00:26:45,530 --> 00:26:47,990
>> Så i stedet for å klikke Step Over.

544
00:26:47,990 --> 00:26:50,630
Jeg kommer til å gå videre
og klikk Step Into.

545
00:26:50,630 --> 00:26:54,030
Og legg merke til at linjen 8 som er
nå markert nå plutselig

546
00:26:54,030 --> 00:26:56,900
blir linje 17.

547
00:26:56,900 --> 00:26:59,947
>> Nå er det ikke at debugger
har hoppet over linjene 14 og 15 og 16.

548
00:26:59,947 --> 00:27:01,780
Det er bare det er ingenting
vise deg det.

549
00:27:01,780 --> 00:27:04,050
De er bare erklære variabler,
og så er det ordet Gjør

550
00:27:04,050 --> 00:27:05,390
og deretter en åpen klammeparentes.

551
00:27:05,390 --> 00:27:09,227
Den eneste funksjonelle linje som er
saftig er virkelig denne her, 17.

552
00:27:09,227 --> 00:27:11,060
Og det er der vi har
pauset automatisk.

553
00:27:11,060 --> 00:27:13,870
>> Så printf ( "n.is:") ;, så
det har ikke skjedd ennå.

554
00:27:13,870 --> 00:27:18,250
Så la oss gå videre og klikk gå over.

555
00:27:18,250 --> 00:27:20,326
Nå er min rask, ja,
endret til ( "n er:").

556
00:27:20,326 --> 00:27:22,450
Nå get_int, jeg kommer ikke til
å bry stepping i,

557
00:27:22,450 --> 00:27:24,750
fordi den funksjonen var
laget av CS50 i biblioteket.

558
00:27:24,750 --> 00:27:25,750
Det er antagelig riktig.

559
00:27:25,750 --> 00:27:28,440
>> Så jeg kommer til å gå videre og
slags samarbeide ved å gi det

560
00:27:28,440 --> 00:27:30,590
en int, men ikke en negativ int.

561
00:27:30,590 --> 00:27:32,870
Så la meg gå videre og treffe 0.

562
00:27:32,870 --> 00:27:39,460
Og nå hva som skjer her
når jeg kommer ned til linje 21?

563
00:27:39,460 --> 00:27:40,890
Jeg har ikke gjentok igjen.

564
00:27:40,890 --> 00:27:43,320
Jeg synes ikke å bli sittende fast i at loop.

565
00:27:43,320 --> 00:27:45,990
Med andre ord, dette gul
baren ikke holde det gående rundt,

566
00:27:45,990 --> 00:27:47,130
og rundt, og rundt.

567
00:27:47,130 --> 00:27:48,340
>> Nå, hvorfor er det?

568
00:27:48,340 --> 00:27:49,920
Vel, n, hva er n akkurat nå?

569
00:27:49,920 --> 00:27:53,280
Jeg kan se på det lokale
variablene i debugger.

570
00:27:53,280 --> 00:27:53,816
n er 0.

571
00:27:53,816 --> 00:27:55,190
Greit, det var min tilstand?

572
00:27:55,190 --> 00:27:58,700
>> 20-- linje 20 er, vel,
0 er større enn 0.

573
00:27:58,700 --> 00:27:59,500
Det er ikke sant.

574
00:27:59,500 --> 00:28:01,020
0 er ikke større enn 0.

575
00:28:01,020 --> 00:28:02,820
Og så jeg brøt ut av dette.

576
00:28:02,820 --> 00:28:06,370
>> Og så det er derfor på linje
21, hvis jeg faktisk fortsetter,

577
00:28:06,370 --> 00:28:10,370
Jeg kommer til å gå tilbake 0, selv
selv om jeg burde ha avvist 0

578
00:28:10,370 --> 00:28:12,484
som faktisk ikke å være negativ.

579
00:28:12,484 --> 00:28:14,650
Så nå har jeg egentlig ikke engang
bryr seg om debugger.

580
00:28:14,650 --> 00:28:16,900
Fikk det, jeg trenger ikke å
vet hva mer som skjer.

581
00:28:16,900 --> 00:28:19,233
>> Så jeg kommer til å gå videre og
bare klikk på Play-knappen,

582
00:28:19,233 --> 00:28:20,240
og la dette ferdig opp.

583
00:28:20,240 --> 00:28:23,440
Nå har jeg innsett at min
bug er tydeligvis på linje 20.

584
00:28:23,440 --> 00:28:25,160
Det er min logiske feil.

585
00:28:25,160 --> 00:28:28,100
>> Og så hva gjør jeg vil
å gjøre for å endre dette?

586
00:28:28,100 --> 00:28:32,500
Hvis problemet er at jeg ikke er
fanger 0, det er bare en logisk feil.

587
00:28:32,500 --> 00:28:35,910
Og jeg kan si mens n er
større enn eller lik 0,

588
00:28:35,910 --> 00:28:38,330
holde spørre brukeren om og om igjen.

589
00:28:38,330 --> 00:28:41,050
>> Så, igjen, enkel feil, kanskje
selv opplagt når du så meg

590
00:28:41,050 --> 00:28:42,410
skrive det bare noen få minutter siden.

591
00:28:42,410 --> 00:28:44,570
Men takeaway her
er at med debug 50,

592
00:28:44,570 --> 00:28:46,850
og med debugging
programvare mer generelt,

593
00:28:46,850 --> 00:28:51,370
du har dette nye funnet makt til å
gå gjennom din egen kode, se

594
00:28:51,370 --> 00:28:55,590
via den hånden panel riktig hva
variabler verdier er.

595
00:28:55,590 --> 00:28:57,700
Slik at du ikke nødvendigvis
nødt til å bruke noe

596
00:28:57,700 --> 00:29:00,630
som du eprintf å skrive ut disse verdiene.

597
00:29:00,630 --> 00:29:04,430
Du kan faktisk se dem
visuelt på skjermen.

598
00:29:04,430 --> 00:29:08,920
>> Nå, utover dette, er det verdt å merke seg
at det er en annen teknikk som er

599
00:29:08,920 --> 00:29:09,890
faktisk super vanlig.

600
00:29:09,890 --> 00:29:13,120
Og du lurer kanskje på hvorfor denne lille
fyren her har sittet på scenen.

601
00:29:13,120 --> 00:29:16,490
Så det er denne teknikken, generelt
kjent som Badeand debugging,

602
00:29:16,490 --> 00:29:18,786
som egentlig er bare en
testament til det faktum

603
00:29:18,786 --> 00:29:20,660
som ofte når programmerere
skriver kode,

604
00:29:20,660 --> 00:29:22,650
de er ikke nødvendigvis
samarbeide med andre,

605
00:29:22,650 --> 00:29:24,030
eller arbeider i et felles miljø.

606
00:29:24,030 --> 00:29:25,050
>> De er liksom hjemme.

607
00:29:25,050 --> 00:29:25,910
Kanskje det er sent på kvelden.

608
00:29:25,910 --> 00:29:28,190
De prøver å finne
ut noen feil i koden sin.

609
00:29:28,190 --> 00:29:29,330
Og de er bare ikke se det.

610
00:29:29,330 --> 00:29:30,329
>> Og det er ingen romkamerat.

611
00:29:30,329 --> 00:29:31,250
Det er ingen TF.

612
00:29:31,250 --> 00:29:32,680
Det er ingen CA rundt.

613
00:29:32,680 --> 00:29:36,440
Alt de har på sin sokkel
er denne lille gummianden.

614
00:29:36,440 --> 00:29:39,030
>> Og så Badeand debugging
er nettopp denne invitasjonen

615
00:29:39,030 --> 00:29:42,780
å tenke på noe som dumt
så dette som en reell skapning,

616
00:29:42,780 --> 00:29:46,940
og faktisk gå gjennom koden din
verbalt til denne stillestående objekt.

617
00:29:46,940 --> 00:29:49,230
Så, for eksempel, hvis
Dette er mitt eksempel her--

618
00:29:49,230 --> 00:29:52,470
og huske at tidligere
problemet var denne,

619
00:29:52,470 --> 00:29:58,140
hvis jeg sletter denne første linjen med kode,
og jeg går videre og gjøre buggy 0 igjen,

620
00:29:58,140 --> 00:30:01,220
husker at jeg hadde disse
feilmeldinger her.

621
00:30:01,220 --> 00:30:05,997
Så ideen her, latterlig om jeg
føler i øyeblikket å gjøre dette offentlig,

622
00:30:05,997 --> 00:30:06,580
er det feil.

623
00:30:06,580 --> 00:30:10,910
>> OK, så mitt problem er at jeg har
implisitt erklært et bibliotek funksjon.

624
00:30:10,910 --> 00:30:12,610
Og det bibliotek funksjon er printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, erklærer
minner meg om prototyper.

626
00:30:15,290 --> 00:30:18,930
>> Det betyr at jeg må faktisk
fortelle kompilatoren på forhånd hva

627
00:30:18,930 --> 00:30:19,980
funksjonen ser ut.

628
00:30:19,980 --> 00:30:20,930
Vent litt.

629
00:30:20,930 --> 00:30:23,580
Jeg hadde ikke standard io.h.

630
00:30:23,580 --> 00:30:24,530
Tusen takk.

631
00:30:24,530 --> 00:30:27,330
>> Så bare denne prosessen of-- deg
trenger ikke å faktisk ha en and.

632
00:30:27,330 --> 00:30:29,819
Men denne ideen om gang
selv gjennom din egen kode

633
00:30:29,819 --> 00:30:31,610
slik at du selv høre
selv, slik at du

634
00:30:31,610 --> 00:30:35,620
realisere utelatelser i din egen
bemerkninger, er vanligvis tanken.

635
00:30:35,620 --> 00:30:38,910
>> Og, kanskje mer logisk, ikke så
mye med den ene, men mer involvert

636
00:30:38,910 --> 00:30:44,220
eksempelet vi nettopp gjorde i buggy 3.c,
du kan gå deg gjennom det

637
00:30:44,220 --> 00:30:45,310
følgende.

638
00:30:45,310 --> 00:30:49,190
Så alt rett, gummi
ducky, DDB, hvis du vil.

639
00:30:49,190 --> 00:30:52,350
Her har vi i min hovedfunksjon,
Jeg ringer får negative int.

640
00:30:52,350 --> 00:30:54,660
>> Og jeg får returverdien.

641
00:30:54,660 --> 00:31:00,410
Jeg lagrer den på venstre side
på linje 8 i en variabel kalt i.

642
00:31:00,410 --> 00:31:02,380
OK, men vent, hvordan gjorde
som får denne verdien?

643
00:31:02,380 --> 00:31:04,130
La meg se på funksjonen i linje 12.

644
00:31:04,130 --> 00:31:05,760
>> I linje 12, har vi få negativ int.

645
00:31:05,760 --> 00:31:08,190
Tar ikke noen innganger,
ikke returnere en int, OK.

646
00:31:08,190 --> 00:31:10,929
Jeg erklærer på linje 14 en variabel n.

647
00:31:10,929 --> 00:31:12,220
Det kommer til å lagre et heltall.

648
00:31:12,220 --> 00:31:13,760
Det er det jeg vil ha.

649
00:31:13,760 --> 00:31:18,480
>> Så gjør følgende mens n er-- la
meg angre hva reparasjonen jeg allerede gjort.

650
00:31:18,480 --> 00:31:22,710
Så mens n er større enn
0, skrive ut n er, OK.

651
00:31:22,710 --> 00:31:25,170
Og så kaller bli int lagret i n.

652
00:31:25,170 --> 00:31:30,160
Og deretter sjekke om n er 0,
n er Ikke slik det er.

653
00:31:30,160 --> 00:31:31,910
Så, igjen, trenger du ikke
trenger selve anda.

654
00:31:31,910 --> 00:31:35,650
Men bare vandre deg gjennom
koden som en intellektuell øvelse

655
00:31:35,650 --> 00:31:37,720
vil ofte hjelpe deg
skjønner hva som skjer,

656
00:31:37,720 --> 00:31:41,170
i motsetning til bare å gjøre noe
som dette, stirrer på skjermen,

657
00:31:41,170 --> 00:31:43,720
og ikke snakke deg gjennom
det, som ærlig talt ikke er

658
00:31:43,720 --> 00:31:46,270
nesten som en effektiv teknikk.

659
00:31:46,270 --> 00:31:48,620
Så der har du det, en
antall forskjellige teknikker

660
00:31:48,620 --> 00:31:52,102
for faktisk debugging koden
og å finne feil, som alle

661
00:31:52,102 --> 00:31:54,810
bør være verktøy i verktøykasse
slik at du ikke er sent på kvelden,

662
00:31:54,810 --> 00:31:57,660
spesielt, er du i spise
haller, eller i kontortiden,

663
00:31:57,660 --> 00:32:00,368
stanger hodet mot
veggen, prøver å løse noen problem.

664
00:32:00,368 --> 00:32:02,020
Innse at det er programvareverktøy.

665
00:32:02,020 --> 00:32:03,720
Det er Rubber Duck verktøy.

666
00:32:03,720 --> 00:32:09,630
Og det er en hel stab av
støtte venter på å låne en hånd.

667
00:32:09,630 --> 00:32:13,120
>> Så nå, et ord på problemet
sett, og på hva vi håper du

668
00:32:13,120 --> 00:32:15,620
komme seg ut av dem, og hvordan
vi går om å vurdere.

669
00:32:15,620 --> 00:32:17,680
Per kursets pensum,
CS50 problemsett

670
00:32:17,680 --> 00:32:22,320
blir vurdert på fire primære akser, så
til speak-- omfang, nøyaktighet, design,

671
00:32:22,320 --> 00:32:23,060
og stil.

672
00:32:23,060 --> 00:32:25,910
Og omfanget bare refererer til hvor mye
av stykket har du bitt av?

673
00:32:25,910 --> 00:32:28,080
Hvor mye av et problem har du prøvd?

674
00:32:28,080 --> 00:32:30,110
Hvilket nivå av innsats
har du manifestert?

675
00:32:30,110 --> 00:32:35,750
>> Korrekthet er, gjør at programmet fungerer som
det skal per CS50 spesifikasjon

676
00:32:35,750 --> 00:32:38,640
når du oppgir visse innganger
eller visse utganger kommer tilbake?

677
00:32:38,640 --> 00:32:41,130
Design er den mest subjektive av dem.

678
00:32:41,130 --> 00:32:43,360
Og det er den som vil
ta lengst tid å lære

679
00:32:43,360 --> 00:32:47,220
og den lengste for å undervise i
så langt som det koker ned til,

680
00:32:47,220 --> 00:32:49,530
hvor godt skrevet er koden din?

681
00:32:49,530 --> 00:32:52,920
>> Det er én ting å bare skrive riktig
utganger eller returnere de rette verdiene.

682
00:32:52,920 --> 00:32:55,400
Men gjør du det som
effektivt som mulig?

683
00:32:55,400 --> 00:32:58,210
Er du gjør det skillet
og erobre, eller binære

684
00:32:58,210 --> 00:33:01,500
søk som vi vil snart se at vi gjorde
to uker siden med telefonboken?

685
00:33:01,500 --> 00:33:04,670
Er det bedre måter å løse
problem enn det du har her?

686
00:33:04,670 --> 00:33:06,380
Det er en mulighet for bedre design.

687
00:33:06,380 --> 00:33:08,530
>> Og så style-- hvordan
pen er koden din?

688
00:33:08,530 --> 00:33:12,370
Du vil merke at jeg er ganske
Særlig om innrykk koden min,

689
00:33:12,370 --> 00:33:15,300
og gjør at mine variabler
er rimelig navngitt. n,

690
00:33:15,300 --> 00:33:19,660
mens kort, er et godt navn for en
nummer, jeg for en telling heltall,

691
00:33:19,660 --> 00:33:20,727
s for en streng.

692
00:33:20,727 --> 00:33:22,560
Og vi kan ha lengre
variabel navn stil.

693
00:33:22,560 --> 00:33:25,500
Stil er bare hvor god
gjør koden din ser?

694
00:33:25,500 --> 00:33:26,600
Og hvordan lesbar er det?

695
00:33:26,600 --> 00:33:29,650
>> Og over tid, hva dine TAs
og TFS vil gjøre i løpet

696
00:33:29,650 --> 00:33:31,870
er å gi deg som
slags kvalitative tilbakemeldinger

697
00:33:31,870 --> 00:33:34,330
slik at du får bedre
på de ulike aspekter.

698
00:33:34,330 --> 00:33:37,510
Og i forhold til hvordan vi
vurdere hver av disse aksene,

699
00:33:37,510 --> 00:33:40,080
det er typisk med svært få
bøtter slik at du generelt

700
00:33:40,080 --> 00:33:41,680
få en følelse av hvor godt du gjør.

701
00:33:41,680 --> 00:33:45,680
Og, ja, hvis du mottar en poengsum på
noen av disse axes-- korrekthet, design

702
00:33:45,680 --> 00:33:49,659
og stil especially-- at antall
vil generelt være mellom 1 og 5.

703
00:33:49,659 --> 00:33:52,450
Og, bokstavelig talt, hvis du får
3 er i starten av semesteret,

704
00:33:52,450 --> 00:33:53,977
dette er en veldig god ting.

705
00:33:53,977 --> 00:33:55,810
Det betyr at det er fortsatt
rom for forbedring,

706
00:33:55,810 --> 00:33:58,490
som du ville håpe på i
tar en klasse for første gang.

707
00:33:58,490 --> 00:34:01,820
Det er forhåpentligvis noen bit av taket
som du håper å nå.

708
00:34:01,820 --> 00:34:03,970
Og så får 3-tallet på
de tidligste stykker,

709
00:34:03,970 --> 00:34:06,550
hvis ikke noen 2 og 4-tallet,
er faktisk en god ting.

710
00:34:06,550 --> 00:34:08,880
Det er godt innenfor rekkevidde,
godt innenfor forventninger.

711
00:34:08,880 --> 00:34:11,421
>> Og hvis ditt sinn er racing, vent
et minutt, tre av fem.

712
00:34:11,421 --> 00:34:12,620
Det er virkelig en 6 av 10.

713
00:34:12,620 --> 00:34:13,560
Det er 60%.

714
00:34:13,560 --> 00:34:14,830
Herregud, det er en F.

715
00:34:14,830 --> 00:34:15,870
>> Det er ikke.

716
00:34:15,870 --> 00:34:17,600
Det er ikke, faktisk, at.

717
00:34:17,600 --> 00:34:22,710
Snarere er det en mulighet til å forbedre
i løpet av semesteret.

718
00:34:22,710 --> 00:34:25,580
Og hvis du får noen
Poors, dette er en mulighet

719
00:34:25,580 --> 00:34:29,199
å dra nytte av kontortiden,
absolutt seksjoner og andre ressurser.

720
00:34:29,199 --> 00:34:32,840
>> Best er en mulighet, egentlig,
å være stolte av hvor langt du har

721
00:34:32,840 --> 00:34:34,520
kommer i løpet av semesteret.

722
00:34:34,520 --> 00:34:38,199
Så skjønner, hvis ingenting
annet, tre er bra.

723
00:34:38,199 --> 00:34:40,179
Og det gir plass for vekst over tid.

724
00:34:40,179 --> 00:34:43,090
>> Når det gjelder hvordan disse aksene er
vektet, realistisk du er

725
00:34:43,090 --> 00:34:46,745
kommer til å tilbringe mesteparten av din tid på å få
ting til å fungere, enn si riktig.

726
00:34:46,745 --> 00:34:49,120
Og så korrekthet har en tendens til å
være vektet mest, som med

727
00:34:49,120 --> 00:34:51,360
dette multiplikativ faktor på tre.

728
00:34:51,360 --> 00:34:54,659
Design er også viktig, men
noe som du ikke nødvendigvis

729
00:34:54,659 --> 00:34:58,220
bruker alle disse timene på
prøver å få ting bare for å jobbe.

730
00:34:58,220 --> 00:35:00,019
>> Og så det er vektet
litt mer forsiktig.

731
00:35:00,019 --> 00:35:01,560
Og så stilen er vektet minst.

732
00:35:01,560 --> 00:35:03,710
Selv om det er ikke mindre
viktig fundamentalt,

733
00:35:03,710 --> 00:35:05,990
det er bare kanskje den
enkleste å gjøre riktig,

734
00:35:05,990 --> 00:35:08,440
ligne eksemplene vi
gjøre i foredrag og delen,

735
00:35:08,440 --> 00:35:11,080
med ting pent
innrykket, og kommentert,

736
00:35:11,080 --> 00:35:14,320
og så videre er blant de enkleste
ting å gjøre og få rett.

737
00:35:14,320 --> 00:35:16,960
Så som sådan, innser
at de er poeng

738
00:35:16,960 --> 00:35:19,000
som er relativt enkle å forstå.

739
00:35:19,000 --> 00:35:22,360
>> Og nå et ord på
dette-- akademisk redelighet.

740
00:35:22,360 --> 00:35:25,150
Så per kursets
pensum, vil du se

741
00:35:25,150 --> 00:35:27,630
at kurset har ganske
litt av språket rundt dette.

742
00:35:27,630 --> 00:35:31,380
Og selvfølgelig tar opp spørsmålet om
akademisk redelighet ganske alvorlig.

743
00:35:31,380 --> 00:35:33,450
>> Vi har æren,
for bedre eller verre,

744
00:35:33,450 --> 00:35:36,570
av å ha sendt hvert år mer
studentene for disiplinærtiltak

745
00:35:36,570 --> 00:35:39,670
enn de fleste andre
Selvfølgelig, at jeg er klar over.

746
00:35:39,670 --> 00:35:42,580
Dette er ikke nødvendigvis
indikerer det faktum

747
00:35:42,580 --> 00:35:46,340
at CS studenter, eller CS50 studenter, er
noe mindre ærlige enn klassekameratene dine.

748
00:35:46,340 --> 00:35:49,090
Men det faktum at i denne
verden, elektronisk, vi bare

749
00:35:49,090 --> 00:35:50,990
har teknologisk
middel for å detektere dette.

750
00:35:50,990 --> 00:35:53,360
>> Det er viktig for oss for
rettferdighet på tvers av klasse

751
00:35:53,360 --> 00:35:58,550
at vi gjør oppdage dette, og heve
problemet når vi ser ting.

752
00:35:58,550 --> 00:36:01,980
Og bare for å male et bilde, og virkelig
å hjelpe noe sånt som dette synke inn,

753
00:36:01,980 --> 00:36:04,600
Dette er antallet
studenter i løpet av de siste 10 årene

754
00:36:04,600 --> 00:36:07,610
som har vært involvert i noen
slike spørsmål om akademisk redelighet,

755
00:36:07,610 --> 00:36:10,990
med noen 32 studenter
fra høsten 2015, som

756
00:36:10,990 --> 00:36:13,760
Det vil si at vi tar
saken svært alvorlig.

757
00:36:13,760 --> 00:36:18,380
Og, til slutt, disse tallene komponere,
senest ca. 3%, 4% eller så

758
00:36:18,380 --> 00:36:19,120
av klassen.

759
00:36:19,120 --> 00:36:25,220
>> Så for kvalifisert flertall av elevene
det synes at linjene er klare.

760
00:36:25,220 --> 00:36:27,940
Men ha dette i
tankene, særlig sent

761
00:36:27,940 --> 00:36:32,080
om natten når sliter med
noen løsning på et problem sett,

762
00:36:32,080 --> 00:36:34,830
at det finnes mekanismer
for å få deg bedre

763
00:36:34,830 --> 00:36:37,870
støtte enn du kanskje
Tenk, selv på denne timen.

764
00:36:37,870 --> 00:36:40,514
Innse at når vi mottar
student innleveringer, krysser vi

765
00:36:40,514 --> 00:36:43,430
sammenligne hver innlevering i år
mot hver innlevering i fjor,

766
00:36:43,430 --> 00:36:47,590
mot hver innsending fra 2007,
og siden, ser på, også,

767
00:36:47,590 --> 00:36:49,931
koden repositories online,
diskusjonsfora, jobbsider.

768
00:36:49,931 --> 00:36:51,806
Og vi nevner dette,
virkelig, alt for å få

769
00:36:51,806 --> 00:36:56,040
av full åpenhet, at hvis
noen andre kan finne det på nettet,

770
00:36:56,040 --> 00:36:57,880
sikkert, så kan vi kurset.

771
00:36:57,880 --> 00:37:00,100
Men, egentlig, ånd
av kurset koker ned

772
00:37:00,100 --> 00:37:01,650
denne bestemmelsen i pensum.

773
00:37:01,650 --> 00:37:03,670
Det er egentlig bare være fornuftig.

774
00:37:03,670 --> 00:37:06,680
>> Og hvis vi måtte utdype det
med bare litt mer språk,

775
00:37:06,680 --> 00:37:09,770
innser at essensen av alle
arbeid som du sender til dette kurset

776
00:37:09,770 --> 00:37:10,954
må være din egen.

777
00:37:10,954 --> 00:37:13,870
Men i løpet av det, det er sikkert
muligheter og oppmuntring,

778
00:37:13,870 --> 00:37:17,300
og pedagogisk verdi i å snu til
others-- meg selv, TFS, CAS,

779
00:37:17,300 --> 00:37:20,760
Tas og andre i klassen,
for støtte, enn si venner

780
00:37:20,760 --> 00:37:23,547
og romkamerater som har studert
CS og programmering før.

781
00:37:23,547 --> 00:37:25,130
Og så er det en kvote for det.

782
00:37:25,130 --> 00:37:28,180
Og den generelle tommelfingerregel
er dette-- når du ber om hjelp,

783
00:37:28,180 --> 00:37:31,470
du kan vise koden din til andre,
men du kan ikke se deres.

784
00:37:31,470 --> 00:37:34,880
Så selv om du er på arbeidstid,
eller i D hall, eller et annet

785
00:37:34,880 --> 00:37:37,450
arbeider på noen delers sett,
arbeider sammen med en venn, som

786
00:37:37,450 --> 00:37:40,160
er helt fint, i
slutten av dagen din jobb

787
00:37:40,160 --> 00:37:43,034
bør til slutt tilhøre hver
av dere henholdsvis, og ikke

788
00:37:43,034 --> 00:37:45,700
være noen samarbeid,
bortsett fra slutt prosjekt der

789
00:37:45,700 --> 00:37:47,410
det er lov og oppmuntret.

790
00:37:47,410 --> 00:37:49,830
>> Innse at hvis du er
sliter med noe

791
00:37:49,830 --> 00:37:52,520
og din venn bare skjer
å bli bedre på dette da du,

792
00:37:52,520 --> 00:37:55,130
eller bedre på det problemet enn deg,
eller litt lenger fremover enn deg,

793
00:37:55,130 --> 00:37:57,330
det er helt rimelig å snu
til din venn og si hei,

794
00:37:57,330 --> 00:38:00,480
Gjør det noe å se på koden min her,
å hjelpe meg få øye på hva problemet mitt er?

795
00:38:00,480 --> 00:38:03,760
Og, forhåpentligvis, i
interesse av pedagogisk verdi

796
00:38:03,760 --> 00:38:07,040
som venn ikke bare
si, oh, gjør dette, men heller,

797
00:38:07,040 --> 00:38:09,917
hva er det du mangler på linje
6, eller noe sånt?

798
00:38:09,917 --> 00:38:12,000
Men løsningen er ikke
for venn ved siden av deg

799
00:38:12,000 --> 00:38:15,617
å si, oh, vel, her, la meg dra
dette opp, og vise min løsning til deg.

800
00:38:15,617 --> 00:38:16,450
Så det er linjen.

801
00:38:16,450 --> 00:38:18,670
Du viser din kode for å
andre, men du kan ikke

802
00:38:18,670 --> 00:38:22,350
se deres, underlagt andre
begrensninger i kursets pensum.

803
00:38:22,350 --> 00:38:24,760
>> Så husk dette
såkalte beklagelse klausul

804
00:38:24,760 --> 00:38:27,560
i kursets pensum også,
at hvis du begår noen handling som

805
00:38:27,560 --> 00:38:30,476
er ikke rimelig, men ta det til
oppmerksomheten til kursets hoder

806
00:38:30,476 --> 00:38:34,240
innen 72 timer, kurset
kan innføre lokale sanksjoner som

807
00:38:34,240 --> 00:38:37,380
kan omfatte en utilfredsstillende eller
sviktende karakter for arbeidet sendes inn.

808
00:38:37,380 --> 00:38:41,410
Men selvsagt vil ikke henvise
rolle for ytterligere disiplinære tiltak,

809
00:38:41,410 --> 00:38:43,010
unntatt i tilfeller av gjentatte handlinger.

810
00:38:43,010 --> 00:38:46,632
Med andre ord, hvis du gjør noe
dum, særlig sent på kvelden, beslutnings

811
00:38:46,632 --> 00:38:49,340
at neste morgen eller to dager
senere, du våkner opp og innser,

812
00:38:49,340 --> 00:38:50,870
hva tenkte jeg?

813
00:38:50,870 --> 00:38:53,890
Du gjør i CS50 ha en stikkontakt
for å fikse det problemet

814
00:38:53,890 --> 00:38:57,170
og eie opp til det, slik at vi
vil møte deg halvveis og avtale

815
00:38:57,170 --> 00:39:01,500
med det i en sak som er både
pedagogiske og verdifull for deg,

816
00:39:01,500 --> 00:39:04,200
men fortsatt straff på noen måte.

817
00:39:04,200 --> 00:39:08,590
Og nå, for å ta kanten av, dette.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO PLAYBACK]

819
00:39:10,570 --> 00:39:13,540
>> [MUSIKK]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END PLAYBACK]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN: Greit, vi er tilbake.

823
00:40:00,490 --> 00:40:03,680
Og nå ser vi på en av de
første av våre virkelige verden domener

824
00:40:03,680 --> 00:40:08,720
i CS50, kunsten kryptografi,
kunsten å sende og motta

825
00:40:08,720 --> 00:40:11,840
hemmelige meldinger, kryptert
meldinger om du vil,

826
00:40:11,840 --> 00:40:17,060
som bare kan tydes hvis du har
noen viktig ingrediens at avsenderen har

827
00:40:17,060 --> 00:40:18,030
også.

828
00:40:18,030 --> 00:40:22,120
Så for å motivere dette vil vi ta
en ser på denne saken her,

829
00:40:22,120 --> 00:40:26,750
som er et eksempel på en
hemmelig dekoder ring som

830
00:40:26,750 --> 00:40:34,042
kan brukes for å regne ut
hva en hemmelig melding faktisk er.

831
00:40:34,042 --> 00:40:35,750
Faktisk, tilbake i
dag i grunnskolen,

832
00:40:35,750 --> 00:40:38,787
hvis du noen gang sendt hemmelige meldinger til
noen venn eller noen forelsket i klassen,

833
00:40:38,787 --> 00:40:40,620
du kanskje har trodd
du var flink

834
00:40:40,620 --> 00:40:46,530
av på din stykke papir endring,
som, A til B og B til C og C til D,

835
00:40:46,530 --> 00:40:47,590
og så videre.

836
00:40:47,590 --> 00:40:50,300
Men du var faktisk kryptere
informasjonen, selv

837
00:40:50,300 --> 00:40:53,300
om det var litt trivielt, var ikke
det vanskelig for læreren å realisere,

838
00:40:53,300 --> 00:40:55,675
vel, hvis du bare endre
B til A og C til B,

839
00:40:55,675 --> 00:40:57,550
du faktisk finne ut
hva budskapet var,

840
00:40:57,550 --> 00:40:59,700
men du var i ciphering informasjon.

841
00:40:59,700 --> 00:41:03,420
>> Du var bare å gjøre det
rett og slett, mye som Ralphie her

842
00:41:03,420 --> 00:41:07,934
i en berømt film som spiller
ganske mye ad nauseum hver vinter.

843
00:41:07,934 --> 00:41:08,600
[VIDEO PLAYBACK]

844
00:41:08,600 --> 00:41:11,180
-Vær Det kjent for alle at
Ralph Parker er herved

845
00:41:11,180 --> 00:41:14,070
oppnevnt et medlem av den lille
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
og har rett til alle æresbevisninger
og fordelene som skjer i dette.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
kontra signert Pierre Andre, i blekk.

848
00:41:24,340 --> 00:41:27,160
Honors og fordeler,
allerede i en alder av ni.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [SHOUTING]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Kom igjen.

853
00:41:34,250 --> 00:41:35,210
La oss fortsette med det.

854
00:41:35,210 --> 00:41:39,530
Jeg trenger ikke all that jazz
om smuglere og pirater.

855
00:41:39,530 --> 00:41:41,660
>> Lytt morgen kveld for
den avsluttende eventyr

856
00:41:41,660 --> 00:41:43,880
av svart sjørøverskute.

857
00:41:43,880 --> 00:41:46,650
Nå er det tid for
Annie hemmelige budskap

858
00:41:46,650 --> 00:41:49,840
for dere medlemmer av Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Husk, barn, bare medlemmer
av Annie Secret Circle

860
00:41:53,570 --> 00:41:56,140
kan dekode Annie hemmelige budskap.

861
00:41:56,140 --> 00:42:00,340
>> Husk, er Annie avhengig av deg.

862
00:42:00,340 --> 00:42:02,880
Still dine pins til B2.

863
00:42:02,880 --> 00:42:05,230
Her er budskapet.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Jeg Er i min første hemmelig møte.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre var i stor stemme i kveld.

868
00:42:15,780 --> 00:42:19,000
Jeg kunne fortelle at kveldens
Meldingen var veldig viktig.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, er at en melding
fra Annie seg selv.

870
00:42:22,694 --> 00:42:23,860
Husk, ikke si det til noen.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekunder senere, jeg er i den eneste
rom i huset hvor en gutt på ni

873
00:42:32,930 --> 00:42:37,040
kunne sitte i ro og dekode.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Jeg gikk til den neste, E.

876
00:42:42,360 --> 00:42:44,520
>> Det første ordet er være.

877
00:42:44,520 --> 00:42:49,032
S, det kom lettere nå, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -Å, Kom igjen, Ralphie, jeg må gå!

879
00:42:51,733 --> 00:42:53,688
>> -Jeg Være rett ned, Ma!

880
00:42:53,688 --> 00:42:54,188
Jøss!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, sørg to-- være sikker på hva?

883
00:43:04,060 --> 00:43:05,970
Hva var Little Orphan
Annie prøver å si?

884
00:43:05,970 --> 00:43:07,264
Pass på å hva?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy har fått til
går, vil du være så snill å komme ut?

886
00:43:09,634 --> 00:43:10,480
>> -Alle Høyre, Ma!

887
00:43:10,480 --> 00:43:12,880
Jeg kommer rett ut!

888
00:43:12,880 --> 00:43:14,550
>> -Jeg Kom nærmere nå.

889
00:43:14,550 --> 00:43:16,620
Spenningen var forferdelig.

890
00:43:16,620 --> 00:43:17,720
Hva var det?

891
00:43:17,720 --> 00:43:20,170
Skjebnen til planeten
kan henge i balanse.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy må gå!

894
00:43:23,170 --> 00:43:26,890
>> -Jeg Være rett ut, for roper høyt!

895
00:43:26,890 --> 00:43:32,680
>> -Nesten Der, fingrene mine fløy, mitt sinn
var en stål felle, hver pore vibrerte.

896
00:43:32,680 --> 00:43:37,198
Det var nesten klar, ja, ja, ja.

897
00:43:37,198 --> 00:43:43,091
>> -Vær Sikker på å drikke din ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
En crummy kommersielle?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Drittsekk.

903
00:43:54,227 --> 00:43:54,810
[END PLAYBACK]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN: OK, så
det var en veldig lang vei

905
00:43:57,390 --> 00:44:00,660
å innføre kryptografi,
og også Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Faktisk, fra denne gamle annonsen
her, hvorfor er ovaltine så bra?

907
00:44:04,470 --> 00:44:09,470
Det er en konsentrert ekstraksjon av moden
byggmalt, ren kremet kumelk,

908
00:44:09,470 --> 00:44:14,360
og spesielt forberedt kakao, sammen
med naturlige fosfatider og vitaminer.

909
00:44:14,360 --> 00:44:18,240
Det er videre forsterket med
ekstra vitaminer B og D, yum.

910
00:44:18,240 --> 00:44:21,600
Og du kan fortsatt få det, tilsynelatende,
på Amazon, som vi gjorde her.

911
00:44:21,600 --> 00:44:24,810
>> Men motivasjonen her skulle
introdusere kryptografi, spesielt

912
00:44:24,810 --> 00:44:28,340
en type kryptografi kjent
som hemmelig nøkkel kryptografi.

913
00:44:28,340 --> 00:44:34,284
Og som navnet antyder, hele
sikkerhet av en hemmelig nøkkel kryptosystem,

914
00:44:34,284 --> 00:44:36,200
om du vil, en metode
for bare scrambling

915
00:44:36,200 --> 00:44:40,960
informasjon mellom to mennesker, er at
bare avsenderen og bare mottakeren

916
00:44:40,960 --> 00:44:46,980
vite en hemmelighet key-- noen verdi, noen
hemmelig setning, noen hemmelig nummer, som

917
00:44:46,980 --> 00:44:50,660
gir dem mulighet til å både kryptere
og dekryptere informasjon.

918
00:44:50,660 --> 00:44:53,470
Og kryptografi, egentlig,
er nettopp dette fra uke 0.

919
00:44:53,470 --> 00:44:56,715
>> Det er et problem der det er innganger,
som selve meldingen på engelsk

920
00:44:56,715 --> 00:44:59,340
eller hva språk du
ønsker å sende til noen i klassen,

921
00:44:59,340 --> 00:45:00,580
eller over internett.

922
00:45:00,580 --> 00:45:03,840
Det er noen utgang, som er tenkt
å være kryptert melding om at du

923
00:45:03,840 --> 00:45:05,250
vil at mottakeren skal motta.

924
00:45:05,250 --> 00:45:07,405
Og selv om noen i
midten får det også,

925
00:45:07,405 --> 00:45:09,780
trenger du ikke vil at de skal
nødvendigvis være i stand til å dekryptere den,

926
00:45:09,780 --> 00:45:12,840
fordi innsiden av denne
svart boks, eller algoritme,

927
00:45:12,840 --> 00:45:17,650
er noen mekanisme, noe trinnvis
instruksjoner, for å ta det inn

928
00:45:17,650 --> 00:45:20,710
og konvertere den inn i
utgang, i forhåpentligvis en sikker måte.

929
00:45:20,710 --> 00:45:23,640
>> Og, faktisk, det er noen
vokabular i denne verden som følger.

930
00:45:23,640 --> 00:45:26,100
Ren tekst er ordet en
datamaskin vitenskapsmann ville

931
00:45:26,100 --> 00:45:28,449
bruker for å beskrive inngangs
melding, for eksempel engelsk

932
00:45:28,449 --> 00:45:31,240
eller hva språk du faktisk
ønsker å sende til noen andre menneske.

933
00:45:31,240 --> 00:45:35,450
Og så chifferteksten er krafse
til kodet, eller kryptert,

934
00:45:35,450 --> 00:45:36,520
versjon av denne.

935
00:45:36,520 --> 00:45:38,750
>> Men det er en annen ingrediens her.

936
00:45:38,750 --> 00:45:43,200
Det er en annen inngang til
hemmelig nøkkel kryptografi.

937
00:45:43,200 --> 00:45:45,200
Og det er selve nøkkelen,
som er, generelt,

938
00:45:45,200 --> 00:45:48,930
som vi skal se, et tall, eller
brev, eller ord, uansett

939
00:45:48,930 --> 00:45:51,980
algoritmen det er faktisk forventer.

940
00:45:51,980 --> 00:45:53,870
>> Og hvordan kan du dekryptere informasjonen?

941
00:45:53,870 --> 00:45:55,110
Hvordan du unscramble den?

942
00:45:55,110 --> 00:45:57,950
Vel, du bare snu
utganger og innganger.

943
00:45:57,950 --> 00:46:00,900
>> Med andre ord, etter at noen
mottar kryptert melding,

944
00:46:00,900 --> 00:46:03,740
han eller hun har rett og slett
å vite at samme nøkkel.

945
00:46:03,740 --> 00:46:05,700
De har fått den krypterte teksten.

946
00:46:05,700 --> 00:46:09,530
Og ved å koble disse to
input i krypto-systemet,

947
00:46:09,530 --> 00:46:14,260
algoritmen, denne svarte boksen, ut
bør komme originalteksten.

948
00:46:14,260 --> 00:46:17,830
Og så det er svært høyt nivå
syn på hva kryptografi er faktisk

949
00:46:17,830 --> 00:46:18,590
alt om.

950
00:46:18,590 --> 00:46:20,030
>> Så la oss komme dit.

951
00:46:20,030 --> 00:46:22,700
La oss nå se under
panseret på noe

952
00:46:22,700 --> 00:46:26,000
vi har tatt for gitt for
den siste uken, og for denne økten

953
00:46:26,000 --> 00:46:27,629
her-- strengen.

954
00:46:27,629 --> 00:46:30,295
En streng på slutten av dagen
er bare en sekvens av tegn.

955
00:46:30,295 --> 00:46:33,610
>> Det kan være hello world, eller
hei Zamyla, eller hva.

956
00:46:33,610 --> 00:46:37,050
Men hva betyr det å
være en sekvens av tegn?

957
00:46:37,050 --> 00:46:41,520
Faktisk gir CS50 biblioteket
oss en datatype som kalles streng.

958
00:46:41,520 --> 00:46:45,140
>> Men det er faktisk ikke noe
slike ting som en streng i C.

959
00:46:45,140 --> 00:46:49,450
Det er egentlig bare en sekvens av
karakter, personlighet, karakter,

960
00:46:49,450 --> 00:46:52,180
karakter, tilbake, til rygg, til
tilbake, til rygg, mot rygg inne

961
00:46:52,180 --> 00:46:54,650
av datamaskinens minne, eller RAM.

962
00:46:54,650 --> 00:46:58,940
Og vi vil se dypere inn i det i
fremtiden når vi ser på minne seg selv,

963
00:46:58,940 --> 00:47:02,030
og utnyttelse, og den
truslene som er involvert.

964
00:47:02,030 --> 00:47:04,100
>> Men la oss vurdere strengen Zamyla.

965
00:47:04,100 --> 00:47:07,480
Så bare navnet
menneske her, Zamyla,

966
00:47:07,480 --> 00:47:12,030
som er en sekvens av
tegn, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Og nå la oss anta at Zamyla navn
blir lagret inne i en datamaskin

968
00:47:16,020 --> 00:47:16,880
program.

969
00:47:16,880 --> 00:47:20,830
>> Vel, står det til grunn at vi skal
være i stand til å se på disse tegnene

970
00:47:20,830 --> 00:47:21,590
individuelt.

971
00:47:21,590 --> 00:47:24,710
Så jeg skal bare trekke litt
boksen rundt Zamyla navn her.

972
00:47:24,710 --> 00:47:31,580
Og det er tilfelle i C som når du
ha en streng, som Zamyla-- og kanskje

973
00:47:31,580 --> 00:47:34,940
at strengen har kommet tilbake fra
en funksjon som get streng,

974
00:47:34,940 --> 00:47:38,540
du kan faktisk manipulere
det tegn for tegn.

975
00:47:38,540 --> 00:47:42,070
>> Nå, dette er germane for
samtale på hånden, fordi

976
00:47:42,070 --> 00:47:46,420
i kryptografi hvis du ønsker å endre
A til B, og B til C og C til D,

977
00:47:46,420 --> 00:47:49,650
og så videre, må du være i stand
å se på de enkelte tegn

978
00:47:49,650 --> 00:47:50,190
i en streng.

979
00:47:50,190 --> 00:47:52,695
Du må være i stand til å endre
Z til noe annet, A

980
00:47:52,695 --> 00:47:55,280
til noe annet, M til
noe annet, og så videre.

981
00:47:55,280 --> 00:47:58,000
Og så trenger vi en måte,
programmatisk, så

982
00:47:58,000 --> 00:48:03,020
å si i C for å være i stand til å endre
og se på enkeltbokstaver.

983
00:48:03,020 --> 00:48:05,690
Og vi kan gjøre dette på følgende måte.

984
00:48:05,690 --> 00:48:08,340
>> La meg gå hodet tilbake i CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Og la meg gå videre
og opprette en ny fil

986
00:48:11,130 --> 00:48:16,134
at jeg vil kalle denne gangen string0,
som vår første slikt eksempel, dot c.

987
00:48:16,134 --> 00:48:18,300
Og jeg kommer til å gå videre
og pisk den opp som følger.

988
00:48:18,300 --> 00:48:22,870
>> Så inkluderer CS50.h, og
deretter inkludere standard io.h,

989
00:48:22,870 --> 00:48:25,990
som jeg nesten alltid kommer til å
skal bruke i mine programmer, minst

990
00:48:25,990 --> 00:48:26,780
i utgangspunktet.

991
00:48:26,780 --> 00:48:32,180
int main ugyldig, og så her er jeg
kommer til å gjøre strenger får få streng.

992
00:48:32,180 --> 00:48:35,260
Og så kommer jeg til å
gå videre og gjøre dette.

993
00:48:35,260 --> 00:48:37,460
Jeg ønsker å gå videre
og, som en mental helse sjekk,

994
00:48:37,460 --> 00:48:43,607
bare si, hallo, prosent s,
semikolon, gjør streng 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, hva har jeg gjort her?

996
00:48:44,690 --> 00:48:45,930
Oh, det gjorde jeg ikke koble den til.

997
00:48:45,930 --> 00:48:48,120
Slik erfaringer, som
var ikke tilsiktet.

998
00:48:48,120 --> 00:48:52,480
>> Så feil, mer prosent
konverteringer enn data argumenter.

999
00:48:52,480 --> 00:48:54,940
Og det er her, i
linjen 7-- OK, så jeg har,

1000
00:48:54,940 --> 00:48:56,690
quote unquote, det er
min strengen til printf.

1001
00:48:56,690 --> 00:48:58,151
Jeg har fått et prosenttegn.

1002
00:48:58,151 --> 00:48:59,650
Men jeg mangler det andre argumentet.

1003
00:48:59,650 --> 00:49:03,190
>> Jeg mangler komma s, noe som
Jeg har i tidligere eksempler.

1004
00:49:03,190 --> 00:49:06,650
Så en god mulighet til å løse
en mer feil, uhell.

1005
00:49:06,650 --> 00:49:09,950
Og nå la meg kjøre
string0, skriv inn Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, hallo Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Så vi har kjørt denne typen program
noen forskjellige tider nå.

1008
00:49:14,144 --> 00:49:16,310
Men la oss gjøre noe
litt annerledes denne gangen.

1009
00:49:16,310 --> 00:49:19,450
I stedet for bare å skrive Zamyla s
hele navnet med printf,

1010
00:49:19,450 --> 00:49:21,350
la oss gjøre det tegn for tegn.

1011
00:49:21,350 --> 00:49:22,700
>> Jeg kommer til å bruke en for loop.

1012
00:49:22,700 --> 00:49:26,160
Og jeg kommer til å gi meg selv
en tellevariabel, heter jeg.

1013
00:49:26,160 --> 00:49:33,530
Og jeg kommer til å holde itera, så
lenge i er mindre enn lengden av s.

1014
00:49:33,530 --> 00:49:35,930
>> Det viser seg, gjorde vi ikke
gjør dette siste gang,

1015
00:49:35,930 --> 00:49:39,100
at c kommer med en
funksjon som heter Stirling.

1016
00:49:39,100 --> 00:49:42,690
Tilbake i dag, og generelt
fortsatt ved implementering funksjoner,

1017
00:49:42,690 --> 00:49:45,405
mennesker vil ofte velge veldig
fyndig navn som slags lyd

1018
00:49:45,405 --> 00:49:48,280
som hva du vil, selv om det er
mangler noen vokaler eller bokstaver.

1019
00:49:48,280 --> 00:49:50,660
Så Stirling er
navnet på en funksjon som

1020
00:49:50,660 --> 00:49:53,880
tar en krangel mellom
parenteser som bør være en streng.

1021
00:49:53,880 --> 00:49:56,910
Og det bare returnerer et heltall,
lengden av strengen.

1022
00:49:56,910 --> 00:50:00,580
>> Så dette for loop på linje 7 kommer
å begynne å telle på i lik 0.

1023
00:50:00,580 --> 00:50:02,530
Det kommer til å øke
jeg på hver iterasjon

1024
00:50:02,530 --> 00:50:04,350
etter en, slik vi har gjort et par ganger.

1025
00:50:04,350 --> 00:50:06,780
Men det kommer til å bare gjøre
denne fram til punktet

1026
00:50:06,780 --> 00:50:09,660
når jeg er lengden
av selve strengen.

1027
00:50:09,660 --> 00:50:14,520
>> Så dette er en måte, til slutt,
gjentar over tegnene

1028
00:50:14,520 --> 00:50:17,430
i strengen som den er følger.

1029
00:50:17,430 --> 00:50:20,670
Jeg kommer til å skrive ut ikke en
Hele streng, men prosent c,

1030
00:50:20,670 --> 00:50:22,860
et enkelt tegn
etterfulgt av en ny linje.

1031
00:50:22,860 --> 00:50:24,880
Og så kommer jeg til å
gå videre, og jeg trenger

1032
00:50:24,880 --> 00:50:29,080
å si at jeg ønsker å skrive ut
ith karakter av s.

1033
00:50:29,080 --> 00:50:33,450
>> Så hvis jeg er den variabelen som indikerer
indeksen av strengen, der

1034
00:50:33,450 --> 00:50:37,230
du er i det, jeg trenger å være i stand til å
si, gi meg den ith karakter av s.

1035
00:50:37,230 --> 00:50:40,390
Og c har en måte å gjøre
dette med hakeparenteser.

1036
00:50:40,390 --> 00:50:43,679
Du bare si navnet på
streng, som i dette tilfellet er s.

1037
00:50:43,679 --> 00:50:46,970
Deretter kan du bruke hakeparentes, som er
vanligvis like over Retur eller Enter

1038
00:50:46,970 --> 00:50:48,110
tast på tastaturet.

1039
00:50:48,110 --> 00:50:52,410
Og så satte indeksen for
tegnet du vil skrive ut.

1040
00:50:52,410 --> 00:50:55,960
Så indeksen kommer til å bli en
number-- 0 eller 1, eller to, eller tre, eller prikk,

1041
00:50:55,960 --> 00:50:57,590
prikk, prikk, et annet nummer.

1042
00:50:57,590 --> 00:51:00,920
>> Og vi sørge for at det kommer til å
være riktig nummer, fordi jeg

1043
00:51:00,920 --> 00:51:02,360
begynne å telle på 0.

1044
00:51:02,360 --> 00:51:07,020
Og som standard, det første tegnet
i en streng er av konvensjonen 0.

1045
00:51:07,020 --> 00:51:09,230
Og den andre karakteren er brakett 1.

1046
00:51:09,230 --> 00:51:11,120
Og den tredje tegnet er brakett 2.

1047
00:51:11,120 --> 00:51:13,630
Og du ikke ønsker å gå for
langt, men vi vil ikke fordi vi er

1048
00:51:13,630 --> 00:51:17,780
kommer til å bare øke i før det
lik lengden av strengen.

1049
00:51:17,780 --> 00:51:20,210
Og ved hvilket tidspunkt,
dette for sløyfen vil stoppe.

1050
00:51:20,210 --> 00:51:25,550
>> Så la meg gå videre og lagre denne
program, og løp gjør streng 0.

1051
00:51:25,550 --> 00:51:28,400
Men jeg skrudd opp.

1052
00:51:28,400 --> 00:51:35,390
Implisitt erklære bibliotek funksjon
Stirling med type slik og such-- nå,

1053
00:51:35,390 --> 00:51:36,430
dette høres kjent ut.

1054
00:51:36,430 --> 00:51:37,440
Men det er ikke printf.

1055
00:51:37,440 --> 00:51:38,540
Og det er ikke få streng.

1056
00:51:38,540 --> 00:51:40,480
>> Jeg gjorde ikke skru opp i
på samme måte som denne tid.

1057
00:51:40,480 --> 00:51:45,100
Men legg merke til her nede litt ned
videre, inkluderer overskriften string.h,

1058
00:51:45,100 --> 00:51:47,210
eksplisitt gi
erklæring for Stirling.

1059
00:51:47,210 --> 00:51:48,820
Så det er faktisk en anelse i det.

1060
00:51:48,820 --> 00:51:51,670
>> Og faktisk det viser seg
det er en annen header fil

1061
00:51:51,670 --> 00:51:53,970
at vi ikke har brukt
i klassen ennå, er men det

1062
00:51:53,970 --> 00:51:56,480
blant de som er tilgjengelige
til deg, kalt string.h.

1063
00:51:56,480 --> 00:52:00,930
Og i denne filen, string.h
er Stirling erklært.

1064
00:52:00,930 --> 00:52:05,220
Så la meg gå videre og
lagre dette, gjør strengen

1065
00:52:05,220 --> 00:52:08,040
0-- hyggelig, ingen feilmeldinger av denne tiden.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, og
Jeg er i ferd med å trykke Enter,

1067
00:52:12,290 --> 00:52:16,710
ved hvilket punkt getstring kommer
å returnere strengen, legg den i s.

1068
00:52:16,710 --> 00:52:21,890
Så det for loop kommer til å reagere
i løpet av S 'tegn om gangen,

1069
00:52:21,890 --> 00:52:28,420
og skrive dem ut én per linje, fordi
Jeg hadde som backslash n på slutten.

1070
00:52:28,420 --> 00:52:34,530
Så jeg kunne utelate at backslash
n, og så bare skrive ut Zamyla alle

1071
00:52:34,530 --> 00:52:37,460
i den samme linje,
effektivt reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, som ikke er alle som nyttig.

1073
00:52:38,999 --> 00:52:40,540
Men i dette tilfellet, har jeg ikke gjort det.

1074
00:52:40,540 --> 00:52:43,610
Jeg har faktisk skrevet en
tegn om gangen, ett per linje,

1075
00:52:43,610 --> 00:52:45,400
slik at vi faktisk se effekten.

1076
00:52:45,400 --> 00:52:46,900
>> Men jeg bør være oppmerksom på en ting her.

1077
00:52:46,900 --> 00:52:48,930
Og vi vil komme tilbake til
dette i en fremtidig uke.

1078
00:52:48,930 --> 00:52:52,650
Det viser seg at denne
Koden er potensielt buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Det viser seg at få streng
og noen andre funksjoner i livet

1080
00:52:56,560 --> 00:53:00,280
ikke nødvendigvis alltid
tilbake hva du forventer.

1081
00:53:00,280 --> 00:53:03,010
Vi vet fra klassen siste
tid i denne som får

1082
00:53:03,010 --> 00:53:04,960
strengen er ment for å returnere en streng.

1083
00:53:04,960 --> 00:53:09,900
Men hva hvis brukeren skriver ut en slik
et langt ord, eller ledd eller essay

1084
00:53:09,900 --> 00:53:13,010
at det er bare ikke nok
minne i datamaskinen til å passe den.

1085
00:53:13,010 --> 00:53:15,410
>> Liker, hva om noe går
galt under panseret?

1086
00:53:15,410 --> 00:53:18,400
Det kan ikke skje ofte,
men det kan skje en gang

1087
00:53:18,400 --> 00:53:21,520
på en stund, veldig sjelden.

1088
00:53:21,520 --> 00:53:25,460
Og så viser det seg at få streng
og funksjoner som det ikke nødvendigvis

1089
00:53:25,460 --> 00:53:26,380
alltid tilbake strenger.

1090
00:53:26,380 --> 00:53:30,680
De kan returnere en feil verdi,
noen sentinel verdi så å si,

1091
00:53:30,680 --> 00:53:32,612
som indikerer at
noe har gått galt.

1092
00:53:32,612 --> 00:53:35,320
Og du vil bare vite dette fra
etter å ha lært det i klassen nå,

1093
00:53:35,320 --> 00:53:37,700
eller å ha lest litt mer dokumentasjon.

1094
00:53:37,700 --> 00:53:43,120
Det viser seg at få streng
kan returnere en verdi som kalles null.

1095
00:53:43,120 --> 00:53:46,220
Null er en spesiell verdi som vi vil
komme tilbake til i en senere uke.

1096
00:53:46,220 --> 00:53:50,420
Men for nå, bare vet at hvis jeg vil ha
å være veldig riktig i fremover

1097
00:53:50,420 --> 00:53:52,650
bruker get streng, jeg
bør ikke bare kalle det,

1098
00:53:52,650 --> 00:53:56,870
og blindt bruke returverdien,
stole på at det er en streng.

1099
00:53:56,870 --> 00:53:59,420
>> Jeg må først si,
hei, vent litt, bare

1100
00:53:59,420 --> 00:54:03,380
fortsette hvis s er ikke lik
null, hvor null igjen,

1101
00:54:03,380 --> 00:54:04,660
er bare noen spesiell verdi.

1102
00:54:04,660 --> 00:54:07,770
Og det er den eneste spesielle verdien du
trenger å bekymre deg for få streng.

1103
00:54:07,770 --> 00:54:10,900
Få strengen er enten kommer
å returnere en streng eller null.

1104
00:54:10,900 --> 00:54:17,219
>> Og dette utropstegn likhetstegn
du kanskje kjenner fra kanskje matte klassen

1105
00:54:17,219 --> 00:54:20,510
som du kan trekke et likhetstegn med
en linje gjennom det for å indikere ikke like.

1106
00:54:20,510 --> 00:54:23,135
Det er vanligvis ikke en karakter
du kan skrive på tastaturet.

1107
00:54:23,135 --> 00:54:26,480
Og så i de fleste programmeringsspråk,
når du ønsker å si ikke like,

1108
00:54:26,480 --> 00:54:29,160
du bruker et utropstegn,
ellers kjent som bang.

1109
00:54:29,160 --> 00:54:33,180
Så du sier bang lik, som
betyr ikke lik, logisk.

1110
00:54:33,180 --> 00:54:38,060
Det er akkurat som det ikke er en større
enn, eller lik, eller mindre enn

1111
00:54:38,060 --> 00:54:41,270
eller lik-tasten på tastaturet
som gjør alt i ett symbol.

1112
00:54:41,270 --> 00:54:44,020
Så det er derfor, i tidligere eksempler,
du gjorde en åpen brakett, og deretter

1113
00:54:44,020 --> 00:54:48,670
et likhetstegn, for å gjøre
større enn eller, si, mindre enn.

1114
00:54:48,670 --> 00:54:49,910
>> Så hva er takeaway her?

1115
00:54:49,910 --> 00:54:53,880
Dette er bare en måte nå av
innføre denne syntaksen, denne funksjonen,

1116
00:54:53,880 --> 00:54:57,390
itera over individuelle
tegn i en streng.

1117
00:54:57,390 --> 00:55:00,260
Og akkurat som de torget
parentes tillate deg å få på dem,

1118
00:55:00,260 --> 00:55:03,790
vurdere disse klammer som
slags antydet at dette underliggende

1119
00:55:03,790 --> 00:55:06,040
design, hvor hver
karakter inne i en streng

1120
00:55:06,040 --> 00:55:10,180
er slags eske i et sted under
panseret i datamaskinens minne.

1121
00:55:10,180 --> 00:55:12,340
>> Men la oss gjøre en variant av dette.

1122
00:55:12,340 --> 00:55:14,880
Det viser seg at denne
program er korrekte.

1123
00:55:14,880 --> 00:55:18,810
Så per CS50 er akser for å vurdere
kode, er dette riktig nå.

1124
00:55:18,810 --> 00:55:22,959
Spesielt nå som jeg sjekker for
null, dette programmet skulle aldri krasje.

1125
00:55:22,959 --> 00:55:24,500
Og jeg bare vet at fra erfaring.

1126
00:55:24,500 --> 00:55:28,040
Men det er ingenting annet som
Vi kan virkelig gå galt her.

1127
00:55:28,040 --> 00:55:31,860
Men det er ikke veldig godt designet,
fordi la oss gå tilbake til det grunnleggende.

1128
00:55:31,860 --> 00:55:34,450
>> Først principles--
hva gjør en for løkke gjøre?

1129
00:55:34,450 --> 00:55:36,290
En for løkke gjør tre ting.

1130
00:55:36,290 --> 00:55:39,340
Det initialiserer noen
verdi, spør du den til.

1131
00:55:39,340 --> 00:55:41,770
Det sjekker en betingelse.

1132
00:55:41,770 --> 00:55:45,380
Og så etter hvert
iterasjon, etter hver syklus,

1133
00:55:45,380 --> 00:55:49,330
intervaller det noen
verdi, eller verdier, her.

1134
00:55:49,330 --> 00:55:50,600
>> Så hva betyr det?

1135
00:55:50,600 --> 00:55:52,940
Vi initial jeg til 0.

1136
00:55:52,940 --> 00:55:58,610
Vi sjekker og sørge for at jeg er mindre enn
lengden s, som er Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
slik som er mindre enn seks.

1138
00:55:59,900 --> 00:56:02,590
Og, ja, 0 som mindre enn seks.

1139
00:56:02,590 --> 00:56:05,580
>> Vi skrive ut Z fra Zamyla navn.

1140
00:56:05,580 --> 00:56:08,080
Deretter øke vi i fra 0 til 1.

1141
00:56:08,080 --> 00:56:11,290
Vi så sjekk, er en mindre
enn lengden av s?

1142
00:56:11,290 --> 00:56:13,270
Lengden av s er seks.

1143
00:56:13,270 --> 00:56:13,950
Ja det er det.

1144
00:56:13,950 --> 00:56:16,880
>> Så vi ut en i Zamyla navn, ZA.

1145
00:56:16,880 --> 00:56:20,090
Vi inkrementer i fra 0 til 1, til to.

1146
00:56:20,090 --> 00:56:23,720
Vi så sjekk, er to mindre enn
lengden på Zamyla navn.

1147
00:56:23,720 --> 00:56:25,380
6- så 2 er mindre enn seks.

1148
00:56:25,380 --> 00:56:30,460
Ja, la oss skrive ut nå M i
Zamyla navn, den tredje tegnet.

1149
00:56:30,460 --> 00:56:34,110
>> Nøkkelen her er at på hver
gjentakelse av historien, jeg sjekker,

1150
00:56:34,110 --> 00:56:37,810
i er mindre enn lengden av Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Men fangsten er at
Stirling er ikke en egenskap.

1152
00:56:40,350 --> 00:56:43,100
De av dere som har programmert
før i Java eller andre språk

1153
00:56:43,100 --> 00:56:46,310
kanskje vet lengden på en streng er
en eiendom, bare noen skrivebeskyttet verdi.

1154
00:56:46,310 --> 00:56:50,220
>> I C i dette tilfellet, dersom dette er
en funksjon som er bokstavelig talt

1155
00:56:50,220 --> 00:56:53,520
å telle antall
tegn i Zamyla hver gang

1156
00:56:53,520 --> 00:56:54,740
Vi kaller denne funksjonen.

1157
00:56:54,740 --> 00:56:58,500
Hver gang du spør datamaskinen til å bruke
Stirling, er det å ta en titt på Zamyla,

1158
00:56:58,500 --> 00:57:01,960
og sa: Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Og den returnerer 6.

1160
00:57:02,962 --> 00:57:04,920
Neste gang du ringer
det inne at for loop,

1161
00:57:04,920 --> 00:57:08,610
det kommer til å se på Zamyla
videre sier Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Og det kommer til å gå tilbake seks.

1163
00:57:10,320 --> 00:57:12,980
Så hva er dumt om dette design?

1164
00:57:12,980 --> 00:57:17,700
>> Hvorfor er min kode ikke en 5 av 5
for design akkurat nå, så å si?

1165
00:57:17,700 --> 00:57:20,600
Vel, jeg spør en
Spørsmålet unødvendig.

1166
00:57:20,600 --> 00:57:23,030
Jeg gjør mer arbeid enn jeg må.

1167
00:57:23,030 --> 00:57:25,370
>> Så selv om
Svaret er riktig, jeg er

1168
00:57:25,370 --> 00:57:29,560
spør datamaskinen, hva er
lengden av Zamyla igjen,

1169
00:57:29,560 --> 00:57:31,380
og igjen, og igjen, og igjen?

1170
00:57:31,380 --> 00:57:33,980
Og det svaret er
aldri kommer til å forandre seg.

1171
00:57:33,980 --> 00:57:35,900
Det er alltid kommer til å være seks.

1172
00:57:35,900 --> 00:57:39,730
>> Så en bedre løsning enn dette
ville være dette neste versjon.

1173
00:57:39,730 --> 00:57:43,390
La meg gå videre og sette den i en
egen fil kalt string1.c,

1174
00:57:43,390 --> 00:57:44,990
bare for å holde det atskilt.

1175
00:57:44,990 --> 00:57:47,260
Og det viser seg i et for
loop, kan du faktisk

1176
00:57:47,260 --> 00:57:50,210
erklærer flere variabler samtidig.

1177
00:57:50,210 --> 00:57:53,460
>> Så jeg kommer til å holde i og sette den til 0.

1178
00:57:53,460 --> 00:57:56,190
Men jeg er også tenkt å
legge til et komma, og sier:

1179
00:57:56,190 --> 00:58:01,050
gi meg en variabel kalt n, hvis
verdi tilsvarer strenglengde s.

1180
00:58:01,050 --> 00:58:09,410
Og nå kan du gjøre min tilstand
så lenge jeg er mindre enn n.

1181
00:58:09,410 --> 00:58:14,140
>> Så på denne måten, er logikken
identisk på slutten av dagen.

1182
00:58:14,140 --> 00:58:18,280
Men jeg husker den
verdi 6, i dette tilfellet.

1183
00:58:18,280 --> 00:58:19,780
Hva er lengden på Zamyla navn?

1184
00:58:19,780 --> 00:58:20,860
Og jeg setter den på n.

1185
00:58:20,860 --> 00:58:23,050
>> Og jeg er fortsatt sjekker
tilstanden hver gang.

1186
00:58:23,050 --> 00:58:24,300
Er 0 mindre enn 6?

1187
00:58:24,300 --> 00:58:25,600
Er en mindre enn 6?

1188
00:58:25,600 --> 00:58:28,600
Er to mindre enn seks, og så videre?

1189
00:58:28,600 --> 00:58:31,914
>> Men jeg ber ikke om datamaskinen
igjen, og igjen, hva er

1190
00:58:31,914 --> 00:58:33,080
lengden på Zamyla navn?

1191
00:58:33,080 --> 00:58:34,320
Hva er lengden på Zamyla navn?

1192
00:58:34,320 --> 00:58:35,986
Hva er lengden på denne Zamyla navn?

1193
00:58:35,986 --> 00:58:40,440
Jeg bokstavelig talt å huske at første og
bare svare på denne andre variabelen n.

1194
00:58:40,440 --> 00:58:45,280
Så dette nå ville være ikke bare
riktig, men også godt designet.

1195
00:58:45,280 --> 00:58:46,670
>> Nå, hva om stil?

1196
00:58:46,670 --> 00:58:48,866
Jeg har kalt mine variabler
ganske bra, vil jeg si.

1197
00:58:48,866 --> 00:58:50,240
De er super fyndig akkurat nå.

1198
00:58:50,240 --> 00:58:52,090
Og det er helt greit.

1199
00:58:52,090 --> 00:58:55,120
>> Hvis du bare har én
streng i et program,

1200
00:58:55,120 --> 00:58:56,860
du kan like godt kalle det er for streng.

1201
00:58:56,860 --> 00:58:59,370
Hvis du bare har en variabel
for telling i et program,

1202
00:58:59,370 --> 00:59:00,710
du kan like godt kalle det jeg.

1203
00:59:00,710 --> 00:59:03,500
Hvis du har en lengde, n
er super vanlig også.

1204
00:59:03,500 --> 00:59:05,800
Men jeg har ikke kommentert noen av koden min.

1205
00:59:05,800 --> 00:59:09,200
>> Jeg har ikke informert reader--
enten det er min TF, eller TA,

1206
00:59:09,200 --> 00:59:12,460
eller bare colleague-- hva som er ment
å gå på i dette programmet.

1207
00:59:12,460 --> 00:59:15,760
Og så for å få god stil,
hva jeg ønsker å gjøre

1208
00:59:15,760 --> 00:59:24,580
er dette-- noe
som ber brukeren om innspill.

1209
00:59:24,580 --> 00:59:26,670
Og jeg kunne skrive om
denne en rekke måter.

1210
00:59:26,670 --> 00:59:35,630
>> Sørg S- sørge get
string returnerte streng.

1211
00:59:35,630 --> 00:59:40,280
Og så i her-- og dette er kanskje
det viktigste comment-- iterer

1212
00:59:40,280 --> 00:59:44,450
i løpet av de tegnene i s ett om gangen.

1213
00:59:44,450 --> 00:59:47,060
Og jeg kunne bruke noen
Valget av engelsk språk

1214
00:59:47,060 --> 00:59:49,650
her for å beskrive hver
av disse biter av kode.

1215
00:59:49,650 --> 00:59:52,740
>> Legg merke til at jeg ikke har satt en
kommentere på hver linje med kode,

1216
00:59:52,740 --> 00:59:55,690
egentlig bare på den interessante
seg, de som

1217
00:59:55,690 --> 00:59:59,460
har noen betydning for at jeg
ønsker å lage super klar til noen

1218
00:59:59,460 --> 01:00:00,460
lese min kode.

1219
01:00:00,460 --> 01:00:02,920
Og hvorfor er du ringer får
string ber brukeren om innspill?

1220
01:00:02,920 --> 01:00:05,450
Selv som en ikke nødvendigvis
alt som beskrivende.

1221
01:00:05,450 --> 01:00:09,340
Men det hjelper å fortelle en historie, fordi
andre linje i historien er, sørg

1222
01:00:09,340 --> 01:00:10,740
få streng returnerte streng.

1223
01:00:10,740 --> 01:00:14,260
>> Og den tredje linjen i historien er,
iterere over karakterene i s en

1224
01:00:14,260 --> 01:00:15,380
på en gang.

1225
01:00:15,380 --> 01:00:17,920
Og nå bare for godt mål,
Jeg kommer til å gå videre og legge

1226
01:00:17,920 --> 01:00:24,560
en mer kommentar som bare
sier print i-te karakter i s.

1227
01:00:24,560 --> 01:00:26,520
Nå, hva har jeg gjort
på slutten av dagen?

1228
01:00:26,520 --> 01:00:29,190
>> Jeg har lagt litt engelsk
ord i form av kommentarer.

1229
01:00:29,190 --> 01:00:32,700
Den skråstrek skråstrek symbolet betyr, hei,
Datamaskinen dette er for det humane,

1230
01:00:32,700 --> 01:00:33,820
ikke for deg, datamaskinen.

1231
01:00:33,820 --> 01:00:35,119
Så de ignorert logisk.

1232
01:00:35,119 --> 01:00:35,910
De er bare der.

1233
01:00:35,910 --> 01:00:39,830
>> Og, ja, viser CS50 IDE dem som
grå, som å være nyttig, men ikke nøkkel

1234
01:00:39,830 --> 01:00:41,000
til programmet.

1235
01:00:41,000 --> 01:00:42,570
Legg merke til hva du nå kan gjøre.

1236
01:00:42,570 --> 01:00:44,950
Enten du vet C
programmering eller ikke, du

1237
01:00:44,950 --> 01:00:47,722
kan bare stå tilbake på dette
program, og skumme kommentarene.

1238
01:00:47,722 --> 01:00:50,180
Be brukeren om innspill, sørg
få streng returnerte streng,

1239
01:00:50,180 --> 01:00:53,009
iterere over karakterene i s
en om gangen, skriver tegnet

1240
01:00:53,009 --> 01:00:55,550
i-te tegnet i S- du ikke
engang å se på koden

1241
01:00:55,550 --> 01:00:57,270
å forstå hva dette programmet gjør.

1242
01:00:57,270 --> 01:01:00,280
Og enda bedre, hvis du selv ser
på dette programmet i en uke eller to,

1243
01:01:00,280 --> 01:01:02,280
eller en måned, eller et år,
du også ikke har

1244
01:01:02,280 --> 01:01:04,420
å stirre på koden,
prøver å huske,

1245
01:01:04,420 --> 01:01:06,630
hva jeg prøver å gjøre med denne koden?

1246
01:01:06,630 --> 01:01:07,770
>> Du har fortalt deg.

1247
01:01:07,770 --> 01:01:11,660
Du har beskrevet det selv,
eller noen kollega, eller TA, eller TF.

1248
01:01:11,660 --> 01:01:14,860
Og så dette ville nå være
riktig, og god design,

1249
01:01:14,860 --> 01:01:18,210
og til slutt god stil også.

1250
01:01:18,210 --> 01:01:19,990
Så gjør holde det i bakhodet.

1251
01:01:19,990 --> 01:01:22,200
>> Så det er en annen
ting jeg skal gjøre her

1252
01:01:22,200 --> 01:01:28,240
som kan nå avsløre nøyaktig hva som er
skjer under panseret.

1253
01:01:28,240 --> 01:01:30,390
Så det er denne funksjonen
i C, og andre språk,

1254
01:01:30,390 --> 01:01:33,010
kalt typecasting
som enten implisitt

1255
01:01:33,010 --> 01:01:37,250
eller eksplisitt lar deg konvertere
fra en datatype til en annen.

1256
01:01:37,250 --> 01:01:39,800
Vi har vært å gjøre så
langt i dag med strenger.

1257
01:01:39,800 --> 01:01:41,250
>> Og strenger er tegn.

1258
01:01:41,250 --> 01:01:44,910
Men husker fra uke
0, hva er tegn?

1259
01:01:44,910 --> 01:01:49,334
Tegn er bare en abstraksjon
på toppen av numbers-- desimaltall,

1260
01:01:49,334 --> 01:01:52,500
og desimaltall er egentlig bare en
abstraksjon på toppen av binære tall,

1261
01:01:52,500 --> 01:01:53,720
som vi definerte det.

1262
01:01:53,720 --> 01:01:55,540
>> Så tegn er tall.

1263
01:01:55,540 --> 01:01:58,410
Og tallene er tegn,
bare avhengig av sammenhengen.

1264
01:01:58,410 --> 01:02:01,250
Og det viser seg at det inne
av et dataprogram

1265
01:02:01,250 --> 01:02:06,830
kan du spesifisere hvordan du vil se
på biter inne i det programmet?

1266
01:02:06,830 --> 01:02:10,400
>> Recall fra uke 0 som vi hadde
Ascii, som er bare denne koden

1267
01:02:10,400 --> 01:02:11,620
kartlegging bokstaver til tall.

1268
01:02:11,620 --> 01:02:13,660
Og vi sa, kapital A er 65.

1269
01:02:13,660 --> 01:02:15,860
Kapital B er 66, og så videre.

1270
01:02:15,860 --> 01:02:20,500
>> Og legg merke til, vi i hovedsak har tegn på
øverste rad her, som C vil kalle dem,

1271
01:02:20,500 --> 01:02:23,400
tegn, og deretter
ints på andre rad.

1272
01:02:23,400 --> 01:02:28,180
Og det viser seg at du kan konvertere
sømløst mellom de to, vanligvis.

1273
01:02:28,180 --> 01:02:30,042
Og hvis vi ønsker å gjøre
dette bevisst, vi

1274
01:02:30,042 --> 01:02:31,750
kan det være lurt å takle
noe sånt som dette.

1275
01:02:31,750 --> 01:02:33,590
>> Vi ønsker kanskje å konvertere
store bokstaver til små

1276
01:02:33,590 --> 01:02:35,330
tilfelle, eller små bokstaver til store bokstaver.

1277
01:02:35,330 --> 01:02:38,000
Og det viser seg at det er
faktisk et mønster her

1278
01:02:38,000 --> 01:02:39,900
vi kan omfavne i bare et øyeblikk.

1279
01:02:39,900 --> 01:02:44,120
Men la oss først se på en
eksempel for å gjøre dette eksplisitt.

1280
01:02:44,120 --> 01:02:46,340
>> Jeg kommer til å gå tilbake til CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Jeg kommer til å skape en
fil som heter Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Og jeg kommer til å gå videre og legge min
standard io.h på toppen, int main ugyldig

1283
01:02:55,960 --> 01:02:57,370
på toppen av min funksjon.

1284
01:02:57,370 --> 01:03:02,700
Og så jeg bare kommer til å gjøre det
following-- en for loop fra i lik,

1285
01:03:02,700 --> 01:03:04,610
la oss si, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Og så er jeg kommer til å være mindre enn
65, pluss 26 bokstaver i alfabetet.

1287
01:03:10,460 --> 01:03:12,640
Så jeg skal la datamaskinen
gjøre regnestykket for meg der.

1288
01:03:12,640 --> 01:03:15,100
Og så inne i denne sløyfen,
hva skal jeg skrive?

1289
01:03:15,100 --> 01:03:19,230
>> % C er% i backslash n.

1290
01:03:19,230 --> 01:03:21,290
Og nå vil jeg koble to verdier.

1291
01:03:21,290 --> 01:03:24,530
Jeg har midlertidig satt spørsmålet
markerer det å invitere spørsmålet.

1292
01:03:24,530 --> 01:03:29,940
>> Jeg vil gjenta fra 65 og framover
for 26 bokstavene i alfabetet,

1293
01:03:29,940 --> 01:03:35,190
skrive ut på hver iterasjon som
karakterens integrert tilsvarende.

1294
01:03:35,190 --> 01:03:38,299
Med andre ord, jeg vil
iterere over 26 tall utskrift

1295
01:03:38,299 --> 01:03:41,590
hva Ascii karakter er, brevet,
og hva det tilsvarende tallet er--

1296
01:03:41,590 --> 01:03:44,650
egentlig bare å gjenskape
diagrammet fra dette lysbildet.

1297
01:03:44,650 --> 01:03:47,010
Så hva skal disse spørsmålstegn være?

1298
01:03:47,010 --> 01:03:51,760
>> Vel, det viser seg at den andre
man bør bare være variabelen i.

1299
01:03:51,760 --> 01:03:53,860
Jeg vil se det som et tall.

1300
01:03:53,860 --> 01:03:58,920
Og midt argument
Herfra kan jeg fortelle datamaskinen

1301
01:03:58,920 --> 01:04:03,470
å behandle som heltall
jeg som et tegn, så som

1302
01:04:03,470 --> 01:04:05,880
å erstatte det her for prosent C.

1303
01:04:05,880 --> 01:04:07,990
>> Med andre ord, hvis jeg,
menneskelig programmerer, vet

1304
01:04:07,990 --> 01:04:09,865
disse er bare tall
på slutten av dagen.

1305
01:04:09,865 --> 01:04:12,500
Og jeg vet at 65 bør
kart til noen tegn.

1306
01:04:12,500 --> 01:04:15,310
Med dette eksplisitt cast,
med en parentes,

1307
01:04:15,310 --> 01:04:18,840
navnet på datatypen du vil
konvertere til, og en lukket parentes

1308
01:04:18,840 --> 01:04:21,200
du kan fortelle
datamaskin, hei, datamaskin,

1309
01:04:21,200 --> 01:04:24,130
konvertere denne heltall til en char.

1310
01:04:24,130 --> 01:04:26,250
>> Så når jeg kjører dette
program etter kompilering,

1311
01:04:26,250 --> 01:04:29,740
la oss se hva jeg get-- gjøre Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Darn det, hva har jeg gjort galt her?

1313
01:04:33,020 --> 01:04:35,884
Bruk av svart identifikator,
all right, ikke tilsiktet,

1314
01:04:35,884 --> 01:04:37,800
men la oss se om vi ikke kan
Grunnen gjennom dette.

1315
01:04:37,800 --> 01:04:41,220
>> Så linjen five-- så jeg ikke fikk
veldig langt før du skrur opp.

1316
01:04:41,220 --> 01:04:42,140
Det er greit.

1317
01:04:42,140 --> 01:04:46,560
Så linje 5 for jeg er lik 65-- jeg ser.

1318
01:04:46,560 --> 01:04:50,130
Så husk at i C, i motsetning til noen
språk hvis du har tidligere programmering

1319
01:04:50,130 --> 01:04:52,190
erfaring, har du
å fortelle datamaskinen,

1320
01:04:52,190 --> 01:04:55,040
i motsetning til Scratch, hva
type variabel det er.

1321
01:04:55,040 --> 01:04:56,860
>> Og jeg glemte en nøkkel setning her.

1322
01:04:56,860 --> 01:04:59,200
I tråd fem, har jeg begynt å bruke i.

1323
01:04:59,200 --> 01:05:01,560
Men jeg har ikke fortalt C
hva datatype det er.

1324
01:05:01,560 --> 01:05:04,570
Så jeg kommer til å gå inn her og
si, ah, gjør det til et heltall.

1325
01:05:04,570 --> 01:05:07,050
>> Nå kommer jeg til å gå videre og rekompilere.

1326
01:05:07,050 --> 01:05:08,080
Det fikset det.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 inn, det er litt kult.

1328
01:05:12,660 --> 01:05:15,360
Ikke bare er det super rask å
be datamaskinen dette spørsmålet,

1329
01:05:15,360 --> 01:05:18,885
heller enn å se det opp på et lysbilde,
det skrevet ut ett per linje, A er 65,

1330
01:05:18,885 --> 01:05:24,860
B er 66, hele veien down-- siden jeg
gjorde dette 26 times-- til bokstaver z,

1331
01:05:24,860 --> 01:05:25,630
som er 90.

1332
01:05:25,630 --> 01:05:27,790
Og, faktisk litt
mer intelligent ville

1333
01:05:27,790 --> 01:05:31,030
har vært for meg å ikke stole
på datamaskinen for å legge til 26.

1334
01:05:31,030 --> 01:05:34,060
Jeg kunne bare ha gjort
90 også, så lenge

1335
01:05:34,060 --> 01:05:37,390
som jeg ikke gjør samme feil to ganger.

1336
01:05:37,390 --> 01:05:41,880
Jeg ønsker å gå opp gjennom
z, ikke bare opp gjennom y.

1337
01:05:41,880 --> 01:05:44,000
>> Så det er en eksplisitt konvertering.

1338
01:05:44,000 --> 01:05:47,860
Det viser seg at denne
er ikke engang nødvendig.

1339
01:05:47,860 --> 01:05:52,480
La meg gå videre og kjør dette
kompilator, og reprise Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Det viser seg at C er ganske smart.

1341
01:05:54,940 --> 01:05:57,150
>> Og printf, særlig
er ganske smart.

1342
01:05:57,150 --> 01:06:01,260
Hvis du bare passere en i to ganger
for både plassholdere, printf

1343
01:06:01,260 --> 01:06:04,510
vil innse, oh, vel jeg vet du
ga meg en integer-- noen tall,

1344
01:06:04,510 --> 01:06:06,380
som 65 eller 90, eller hva.

1345
01:06:06,380 --> 01:06:10,170
Men jeg ser at du vil ha meg til
formatere det nummeret som et tegn.

1346
01:06:10,170 --> 01:06:16,460
Og så printf kan implisitt kaste
int til en røye for deg også.

1347
01:06:16,460 --> 01:06:19,360
Så det er ikke et problem i det hele tatt.

1348
01:06:19,360 --> 01:06:23,100
>> Men legg merke til, på grunn av dette likeverdighet
vi faktisk kan gjøre dette også.

1349
01:06:23,100 --> 01:06:26,520
La meg gå videre og gjøre en
annen versjon av dette-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
Og i stedet for itera løpet
heltall, kan virkelig bakoversveis

1351
01:06:31,800 --> 01:06:33,610
ved å gjenta over tegn.

1352
01:06:33,610 --> 01:06:37,660
Hvis en char c får kapital A, jeg
ønsker å gå videre og gjøre dette,

1353
01:06:37,660 --> 01:06:41,740
så lenge som C er mindre enn eller lik
til kapital Z. Og på hver iterasjon

1354
01:06:41,740 --> 01:06:45,690
Jeg ønsker å øke C, kan jeg
nå i min printf linje her

1355
01:06:45,690 --> 01:06:51,320
si, er prosent C
prosent i igjen, komma C.

1356
01:06:51,320 --> 01:06:57,200
>> Og nå kan jeg gå den andre retningen,
avstøpning tegnet eksplisitt

1357
01:06:57,200 --> 01:06:58,500
til et helt tall.

1358
01:06:58,500 --> 01:07:00,560
Så, igjen, hvorfor ville du gjøre dette?

1359
01:07:00,560 --> 01:07:03,830
Det er litt rart å sortere av
telle i form av tegn.

1360
01:07:03,830 --> 01:07:07,430
>> Men hvis du forstår hva som er
skjer under panseret,

1361
01:07:07,430 --> 01:07:08,430
det er egentlig ingen magi.

1362
01:07:08,430 --> 01:07:13,060
Du bare sier hei, datamaskin gi
meg en variabel kalt C av type røye.

1363
01:07:13,060 --> 01:07:16,520
Initialisere den til kapital A. Og
merke enkeltanførselstegn saken.

1364
01:07:16,520 --> 01:07:19,580
>> For karakterer i C, husker fra
i forrige uke, bruker du enkle anførselstegn.

1365
01:07:19,580 --> 01:07:23,720
For trenger, for ord,
setninger, bruker du anførselstegn.

1366
01:07:23,720 --> 01:07:27,210
OK, datamaskin, fortsette å gjøre dette, så
lenge som tegnet er mindre enn

1367
01:07:27,210 --> 01:07:28,050
eller lik z.

1368
01:07:28,050 --> 01:07:32,640
Og jeg vet fra min Ascii tabellen at alle
av disse ASCII-koder er sammenhengende.

1369
01:07:32,640 --> 01:07:33,400
>> Det er ingen hull.

1370
01:07:33,400 --> 01:07:36,737
Så det er bare A til Z,
adskilt av ett nummer hver.

1371
01:07:36,737 --> 01:07:38,820
Og så kan jeg øke
en røye, hvis jeg virkelig vil.

1372
01:07:38,820 --> 01:07:40,390
På slutten av dagen,
det er bare et tall.

1373
01:07:40,390 --> 01:07:41,030
Jeg vet dette.

1374
01:07:41,030 --> 01:07:43,670
Så jeg kan bare anta å legge en til det.

1375
01:07:43,670 --> 01:07:46,940
>> Og så denne gangen, jeg skriver c,
og deretter integrert tilsvarende.

1376
01:07:46,940 --> 01:07:50,170
Og jeg trenger ikke engang den eksplisitte cast.

1377
01:07:50,170 --> 01:07:52,680
Jeg kan la printf og
datamaskin finne ut av ting,

1378
01:07:52,680 --> 01:07:57,300
så nå hvis jeg kjører
gjøre Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Jeg får akkurat det samme også.

1380
01:08:01,520 --> 01:08:04,530
>> Ubrukelig program, though-- ingen
kommer til å faktisk skrive programvare

1381
01:08:04,530 --> 01:08:07,549
for å finne ut, hva var
tall som er tilordnet A, eller B, eller Z?

1382
01:08:07,549 --> 01:08:10,340
Du kommer bare til å google det, eller
slå det opp på nettet, eller slå det opp

1383
01:08:10,340 --> 01:08:11,650
på et lysbilde, eller lignende.

1384
01:08:11,650 --> 01:08:13,520
Så hvor kommer dette faktisk få nyttig?

1385
01:08:13,520 --> 01:08:15,960
>> Vel, vi snakker om det
lysbilde, merker det er

1386
01:08:15,960 --> 01:08:20,890
en faktisk mønster her mellom store
og små bokstaver som ikke var tilfeldig.

1387
01:08:20,890 --> 01:08:23,760
Legg merke til at kapital A er 65.

1388
01:08:23,760 --> 01:08:25,830
Små bokstaver en er 97.

1389
01:08:25,830 --> 01:08:29,649
Og hvor langt unna er små bokstaver en?

1390
01:08:29,649 --> 01:08:32,649
>> Så 65 er hvor mange skritt fra 97?

1391
01:08:32,649 --> 01:08:36,210
Så 97 minus 65 er 32.

1392
01:08:36,210 --> 01:08:37,910
Så kapital en er 65.

1393
01:08:37,910 --> 01:08:39,939
Hvis du legger 32 til det,
du får små bokstaver en.

1394
01:08:39,939 --> 01:08:43,729
Og tilsvarende, hvis du trekker fra 32,
du kommer tilbake til hovedstaden A-- samme med B

1395
01:08:43,729 --> 01:08:46,380
for lite b, stor C for lite c.

1396
01:08:46,380 --> 01:08:50,670
>> Alle disse hullene er 32 fra hverandre.

1397
01:08:50,670 --> 01:08:54,450
Nå, dette synes å tillate oss å
gjøre noe som Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
eller Google Docs har, hvor du
kan velge alt og si,

1399
01:08:57,729 --> 01:09:00,520
endre alle til små bokstaver, eller
endre alle til store bokstaver,

1400
01:09:00,520 --> 01:09:03,840
eller endre bare det første ordet
av en setning til stor bokstav.

1401
01:09:03,840 --> 01:09:07,390
Vi kan faktisk gjøre noe
sånn selv.

1402
01:09:07,390 --> 01:09:12,645
>> La meg gå videre og lagre en fil
her kalt kapital 0.c.

1403
01:09:12,645 --> 01:09:15,770
Og la oss gå videre og piske opp et program
som gjør nøyaktig det som følger.

1404
01:09:15,770 --> 01:09:18,460
Så ta med CS50 biblioteket.

1405
01:09:18,460 --> 01:09:21,430
Og inkluderer standard I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Og jeg vet at dette kommer snart.

1407
01:09:22,787 --> 01:09:24,870
Så jeg kommer til å sette det i
der allerede, string.h,

1408
01:09:24,870 --> 01:09:26,960
så jeg har tilgang til
ting som Stirling,

1409
01:09:26,960 --> 01:09:29,620
og deretter int main tomrom, som vanlig.

1410
01:09:29,620 --> 01:09:33,420
Og så kommer jeg til å gå videre
og gjøre strenger får få streng,

1411
01:09:33,420 --> 01:09:35,032
bare for å få en streng fra brukeren.

1412
01:09:35,032 --> 01:09:36,740
Og så kommer jeg til å
gjør meg sunn fornuft sjekk.

1413
01:09:36,740 --> 01:09:40,510
Hvis strengen ikke er lik null,
så det er trygt å fortsette.

1414
01:09:40,510 --> 01:09:42,000
Og hva ønsker jeg å gjøre?

1415
01:09:42,000 --> 01:09:48,700
Jeg kommer til å reagere fra i lik 0,
og n opp til strengen lengde s.

1416
01:09:48,700 --> 01:09:51,899
>> Og jeg kommer til å gjøre dette så lenge
Jeg er mindre enn n, og jeg pluss pluss.

1417
01:09:51,899 --> 01:09:55,060
Så langt er jeg egentlig bare
låne ideer fra før.

1418
01:09:55,060 --> 01:09:57,010
Og nå kommer jeg til å innføre en gren.

1419
01:09:57,010 --> 01:09:59,635
>> Så tenker tilbake til Scratch, hvor
vi hadde de gafler i veien,

1420
01:09:59,635 --> 01:10:05,110
og siste uke i C. Jeg kommer til å
si dette, hvis den i-te karakter i s

1421
01:10:05,110 --> 01:10:09,250
er større enn eller
tilsvarende små bokstaver a,

1422
01:10:09,250 --> 01:10:13,340
og-- i Scratch du ville bokstavelig talt
sier og, men i C du sier ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- og i-te karakter i s
er mindre enn eller lik til små bokstaver z,

1424
01:10:19,830 --> 01:10:21,780
la oss gjøre noe interessant.

1425
01:10:21,780 --> 01:10:27,020
La oss faktisk skrive ut en
karakter uten linjeskift

1426
01:10:27,020 --> 01:10:31,760
som er tegnet i strengen,
i-te tegnet i strengen.

1427
01:10:31,760 --> 01:10:37,420
>> Men la oss gå videre og
trekke 32 fra det.

1428
01:10:37,420 --> 01:10:42,120
Else hvis tegnet i
streng som vi ser

1429
01:10:42,120 --> 01:10:45,950
er ikke mellom liten en
og lite z, gå videre

1430
01:10:45,950 --> 01:10:48,610
og bare skrevet det ut uendret.

1431
01:10:48,610 --> 01:10:50,840
Så vi har introdusert
dette parentes notasjon

1432
01:10:50,840 --> 01:10:53,560
for våre strenger for å få på
i-te tegnet i strengen.

1433
01:10:53,560 --> 01:10:57,520
>> Jeg har lagt noen betinget logikk, som
Scratch i forrige ukes uke en, hvor

1434
01:10:57,520 --> 01:10:59,880
Jeg bare bruker min fundamental
forståelse av hva som er

1435
01:10:59,880 --> 01:11:01,130
skjer under panseret.

1436
01:11:01,130 --> 01:11:04,190
Er i-te karakter av s
er større enn eller lik en?

1437
01:11:04,190 --> 01:11:08,290
Liker, er det 97 eller 98,
eller 99, og så videre?

1438
01:11:08,290 --> 01:11:11,940
>> Men det er også mindre enn eller lik
til verdien av små bokstaver z?

1439
01:11:11,940 --> 01:11:16,210
Og hvis så, hva betyr denne linjen betyr?

1440
01:11:16,210 --> 01:11:20,250
14, er denne typen av
spiren til hele ideen,

1441
01:11:20,250 --> 01:11:23,840
kapitalisere brevet etter
simpelthen å trekke 32 fra det,

1442
01:11:23,840 --> 01:11:29,370
i dette tilfellet, fordi jeg vet, per som
diagram, hvordan mine tall er representert.

1443
01:11:29,370 --> 01:11:33,925
Så la oss gå videre og kjøre denne,
etter kompilering kapital 0.c,

1444
01:11:33,925 --> 01:11:36,210
og kjøre kapital 0.

1445
01:11:36,210 --> 01:11:40,300
>> La oss skrive noe sånt
Zamyla i små bokstaver angir.

1446
01:11:40,300 --> 01:11:42,780
Og nå har vi Zamyla i store bokstaver.

1447
01:11:42,780 --> 01:11:45,050
La oss skrive inn Rob i små bokstaver.

1448
01:11:45,050 --> 01:11:46,674
La oss prøve Jason i små bokstaver.

1449
01:11:46,674 --> 01:11:48,590
Og vi får stadig
tvunget kapitalisering.

1450
01:11:48,590 --> 01:11:50,960
Det er en mindre feil som jeg
slags ikke hadde forutsett.

1451
01:11:50,960 --> 01:11:54,050
Legg merke til min nye spørsmål er sluttet opp
på samme linje som deres navn,

1452
01:11:54,050 --> 01:11:55,520
som føles litt rotete.

1453
01:11:55,520 --> 01:11:59,170
>> Så jeg kommer til å gå her, og
faktisk ved slutten av dette programmet

1454
01:11:59,170 --> 01:12:02,110
skrive ut et linjeskift karakter.

1455
01:12:02,110 --> 01:12:03,160
Det er alt.

1456
01:12:03,160 --> 01:12:06,120
Med printf, trenger du ikke å
passere i variabler eller format kode.

1457
01:12:06,120 --> 01:12:08,460
Du kan bokstavelig talt bare skrive
noe som en ny linje.

1458
01:12:08,460 --> 01:12:13,529
>> Så la oss gå videre og gjøre
kapital 0 igjen, kjør det, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Og nå er det litt penere.

1460
01:12:14,820 --> 01:12:17,274
Nå er mitt spørsmål om sin egen nye linje.

1461
01:12:17,274 --> 01:12:18,440
Så det er alt fint og bra.

1462
01:12:18,440 --> 01:12:19,910
Så det er et godt eksempel.

1463
01:12:19,910 --> 01:12:22,700
Men jeg vet ikke engang nødvendigvis
må hardt koden den 32.

1464
01:12:22,700 --> 01:12:23,350
Vet du hva?

1465
01:12:23,350 --> 01:12:26,350
Jeg kunne say-- jeg ikke noen gang
huske hva forskjellen er.

1466
01:12:26,350 --> 01:12:29,330
>> Men jeg vet at hvis jeg
har en liten bokstav,

1467
01:12:29,330 --> 01:12:34,430
Jeg egentlig ønsker å trekke seg
uansett avstanden er mellom lite

1468
01:12:34,430 --> 01:12:39,160
en og stor A, fordi hvis jeg antar at
alle de andre bokstavene er de samme,

1469
01:12:39,160 --> 01:12:41,045
som bør få jobben gjort.

1470
01:12:41,045 --> 01:12:42,670
Men heller enn å gjøre det, vet du hva?

1471
01:12:42,670 --> 01:12:44,240
Det er en annen måte likevel.

1472
01:12:44,240 --> 01:12:48,090
>> Hvis det er kapital 1.c-- hvis jeg var
for å sette det inn i en egen fil.

1473
01:12:48,090 --> 01:12:51,030
la oss bruker store bokstaver 2.c som følger.

1474
01:12:51,030 --> 01:12:53,060
Jeg kommer til å virkelig rydde opp her.

1475
01:12:53,060 --> 01:12:57,420
Og i stedet for å måtte
vet eller bryr seg om de som er lavt nivå

1476
01:12:57,420 --> 01:13:01,090
gjennomføring detaljer, jeg er i stedet
bare kommer til å skrive ut et tegn,

1477
01:13:01,090 --> 01:13:04,610
quote unquote, prosent C, og
deretter ringe en annen funksjon som

1478
01:13:04,610 --> 01:13:09,950
Det finnes som tar et argument,
som er et tegn, som dette.

1479
01:13:09,950 --> 01:13:12,630
>> Det viser seg i C, er det
en annen funksjon samtale

1480
01:13:12,630 --> 01:13:15,550
til øvre, noe som navnet
antyder tar en karakter

1481
01:13:15,550 --> 01:13:19,350
og gjør det til sin øvre sak
tilsvarende, og returnerer det

1482
01:13:19,350 --> 01:13:21,410
slik at printf kan plugge den inn der.

1483
01:13:21,410 --> 01:13:25,484
Og så å gjøre dette, men jeg
behov for å innføre en annen fil.

1484
01:13:25,484 --> 01:13:28,400
Det viser seg at det er en annen fil
at du bare ville vite fra klassen,

1485
01:13:28,400 --> 01:13:33,020
eller en lærebok eller en elektronisk
referanse, kalt C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Så hvis jeg legger det opp blant mine header
filer, og nå re-kompilere dette programmet,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
La oss skrive inn Zamyla i alt
små bokstaver, fungerer fortsatt den samme.

1489
01:13:46,690 --> 01:13:48,040
Men vet du hva?

1490
01:13:48,040 --> 01:13:55,590
Det viser seg at for å over
har noen annen funksjonalitet.

1491
01:13:55,590 --> 01:13:58,410
>> Og la meg presentere dette
kommandoen her, liksom klønete

1492
01:13:58,410 --> 01:14:00,250
navngitt, men mannen for manuell.

1493
01:14:00,250 --> 01:14:03,960
Det viser seg at de fleste Linux-maskiner,
som vi bruker her-- Linux operativsystem

1494
01:14:03,960 --> 01:14:06,270
system-- har en kommando
kalt mann, som sier:

1495
01:14:06,270 --> 01:14:08,530
hei, datamaskin, gi meg
datamaskinens manual.

1496
01:14:08,530 --> 01:14:10,680
hva vil du
slå opp i den manuelle?

1497
01:14:10,680 --> 01:14:13,840
>> Jeg vil slå opp funksjonen
kalt til øvre, Enter.

1498
01:14:13,840 --> 01:14:16,070
Og det er litt kryptisk
å lese noen ganger.

1499
01:14:16,070 --> 01:14:18,780
Men legg merke til vi er i
Linux programmerer håndboken.

1500
01:14:18,780 --> 01:14:19,530
Og det er all tekst.

1501
01:14:19,530 --> 01:14:21,905
Og legg merke til at det er den
Navnet på funksjonen her oppe.

1502
01:14:21,905 --> 01:14:25,030
Det viser seg at det har en fetter som heter
til lavere, noe som gjør det motsatte.

1503
01:14:25,030 --> 01:14:29,710
Og legg merke til etter synopsis, for å bruke dette
fungere mannen siden, så å si,

1504
01:14:29,710 --> 01:14:32,220
forteller meg at jeg
må inkludere c type.h.

1505
01:14:32,220 --> 01:14:33,630
Og jeg visste at fra praksis.

1506
01:14:33,630 --> 01:14:36,210
>> Her er det viser meg de to
prototyper for funksjonen

1507
01:14:36,210 --> 01:14:39,070
slik at hvis jeg noen gang vil bruke denne
Jeg vet hva de tar som input,

1508
01:14:39,070 --> 01:14:40,652
og hva de kommer tilbake som utgang.

1509
01:14:40,652 --> 01:14:42,360
Og så hvis jeg leser
beskrivelsen, ser jeg

1510
01:14:42,360 --> 01:14:44,820
i mer detalj hva funksjonen gjør.

1511
01:14:44,820 --> 01:14:48,100
Men enda viktigere, hvis
Jeg ser under returverdi,

1512
01:14:48,100 --> 01:14:51,710
det står den returnerte verdien er
at av den konverterte brevet,

1513
01:14:51,710 --> 01:14:57,880
eller C, den opprinnelige inngangs, hvis
omdannelsen var ikke mulig.

1514
01:14:57,880 --> 01:15:01,992
>> Med andre ord, for å over vil prøve
å konvertere et brev til store bokstaver.

1515
01:15:01,992 --> 01:15:03,450
Og hvis så, det kommer til å returnere den.

1516
01:15:03,450 --> 01:15:07,010
Men hvis det ikke kan for noen reason--
kanskje det er allerede store bokstaver,

1517
01:15:07,010 --> 01:15:09,550
kanskje det er et utropstegn
eller en annen punctuation--

1518
01:15:09,550 --> 01:15:12,200
det bare kommer til å
returnere den opprinnelige C,

1519
01:15:12,200 --> 01:15:17,340
som betyr at jeg kan lage min kode
bedre konstruert som følger.

1520
01:15:17,340 --> 01:15:20,580
>> Jeg trenger ikke alle
disse darn linjer med kode.

1521
01:15:20,580 --> 01:15:22,610
Alle linjene jeg noens
bare fremhevet kan

1522
01:15:22,610 --> 01:15:28,700
bli kollapset i bare ett enkelt
linje, som er dette-- printf prosent

1523
01:15:28,700 --> 01:15:33,510
c til øvre S brakett i.

1524
01:15:33,510 --> 01:15:36,090
Og dette ville være en
eksempel på bedre design.

1525
01:15:36,090 --> 01:15:40,040
>> Hvorfor implementere i 7 eller 8 linjer
kode, uansett hva det var jeg bare

1526
01:15:40,040 --> 01:15:44,960
slettet, når du kan i stedet kollapse
alle som logikk og beslutningstaking

1527
01:15:44,960 --> 01:15:49,620
til en enkelt linje, 13 nå, som
er avhengig av et bibliotek function--

1528
01:15:49,620 --> 01:15:53,430
en funksjon som kommer med C, men det
gjør akkurat hva du vil den skal gjøre.

1529
01:15:53,430 --> 01:15:55,295
Og, ærlig, selv om
det kom ikke med C,

1530
01:15:55,295 --> 01:15:58,880
du kan gjennomføre det selv, som
vi har sett, med få negative int

1531
01:15:58,880 --> 01:16:01,700
og få positiv int i forrige uke også.

1532
01:16:01,700 --> 01:16:03,470
>> Denne koden er nå mye mer lesbar.

1533
01:16:03,470 --> 01:16:06,670
Og, ja, hvis vi bla opp,
se hvor mye mer kompakt

1534
01:16:06,670 --> 01:16:08,360
denne versjonen av mitt program er.

1535
01:16:08,360 --> 01:16:11,230
Det er litt topptung nå,
med alle disse inneholder.

1536
01:16:11,230 --> 01:16:14,380
Men det er OK, fordi nå står jeg
på skuldrene av programmerere

1537
01:16:14,380 --> 01:16:15,300
før meg.

1538
01:16:15,300 --> 01:16:18,440
Og hvem det var som
iverksatt for å over virkelig

1539
01:16:18,440 --> 01:16:21,470
gjorde meg en tjeneste, omtrent som den som
implementert Stirling virkelig

1540
01:16:21,470 --> 01:16:24,790
gjorde meg en tjeneste for en tid siden.

1541
01:16:24,790 --> 01:16:26,970
Og så nå har vi en
bedre design program

1542
01:16:26,970 --> 01:16:31,680
som implementerer den samme logikken.

1543
01:16:31,680 --> 01:16:35,580
>> Speaking of Stirling, la
meg gå videre og gjøre dette.

1544
01:16:35,580 --> 01:16:38,320
La meg gå videre og lagre
denne filen som stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Og det viser seg, kan vi skrelle tilbake
en annen lag ganske enkelt nå.

1546
01:16:43,255 --> 01:16:45,630
Jeg kommer til å gå videre og pisk
opp et annet program i hoved

1547
01:16:45,630 --> 01:16:49,759
her at bare re-redskaper
strenglengde som følger.

1548
01:16:49,759 --> 01:16:52,300
Så her er en linje med kode som
får meg en streng fra brukeren.

1549
01:16:52,300 --> 01:16:53,910
Vi fortsetter å bruke dette igjen og igjen.

1550
01:16:53,910 --> 01:16:58,900
La meg gi meg selv en variabel kalt
n av typen int som lagrer et nummer.

1551
01:16:58,900 --> 01:17:02,490
>> Og la meg gå videre og
Gjør følgende logikk.

1552
01:17:02,490 --> 01:17:15,610
Mens det n'te tegnet i s gjør
ikke like skråstrek 0, gå videre

1553
01:17:15,610 --> 01:17:17,930
og øke n.

1554
01:17:17,930 --> 01:17:23,506
Og deretter skrive ut printf prosent i n.

1555
01:17:23,506 --> 01:17:29,200
Jeg hevder at dette programmet her,
uten å kalle streng lengde,

1556
01:17:29,200 --> 01:17:31,150
tall ut lengden av en streng.

1557
01:17:31,150 --> 01:17:34,600
>> Og magien er helt
innkapslet i linje 8

1558
01:17:34,600 --> 01:17:39,830
her det ser ut som ny syntaks,
Dette backslash 0 i enkle anførselstegn.

1559
01:17:39,830 --> 01:17:41,360
Men hvorfor er det?

1560
01:17:41,360 --> 01:17:44,100
Vel, vurdere hva som er
skjer hele tiden.

1561
01:17:44,100 --> 01:17:47,990
>> Og som en side før jeg glemmer, innser
også at i tillegg til de man-sidene

1562
01:17:47,990 --> 01:17:50,920
som kommer med en typisk
Linux-system som CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
innse at vi, den
Kurset ansatte, har også

1564
01:17:53,770 --> 01:17:56,030
laget en nettside versjon
av den samme ideen som kalles

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, som har
alle de samme man-sidene,

1566
01:17:59,940 --> 01:18:02,020
alt dette samme
dokumentasjon, samt

1567
01:18:02,020 --> 01:18:05,730
en liten boks på toppen som gjør at
du konvertere alle de nokså

1568
01:18:05,730 --> 01:18:09,025
uforståelige språk til mindre komfortabel
modus, hvor vi, i lærerstaben,

1569
01:18:09,025 --> 01:18:12,150
har gått gjennom og prøvde å forenkle
noen av språket for å holde ting

1570
01:18:12,150 --> 01:18:14,830
fokusert på ideer, og ikke
noen av formalitetene.

1571
01:18:14,830 --> 01:18:20,070
Så husk, reference.cs50.net
som en annen kilde i tillegg.

1572
01:18:20,070 --> 01:18:23,800
>> Men hvorfor gjør strenglengde arbeid i
slik jeg foreslo et øyeblikk siden?

1573
01:18:23,800 --> 01:18:25,160
Her er Zamyla navn igjen.

1574
01:18:25,160 --> 01:18:27,690
Og her er Zamyla navn
innestengt, som jeg fortsette å gjøre,

1575
01:18:27,690 --> 01:18:31,360
å male et bilde av det å være,
egentlig, bare en sekvens av tegn.

1576
01:18:31,360 --> 01:18:34,260
Men Zamyla eksisterer ikke
isolert i et program.

1577
01:18:34,260 --> 01:18:37,420
>> Når du skriver og kjøre et program,
du bruker Mac eller PC

1578
01:18:37,420 --> 01:18:40,010
som minne, eller RAM så å si.

1579
01:18:40,010 --> 01:18:42,620
Og du kan tenke på
datamaskinen som har

1580
01:18:42,620 --> 01:18:44,730
mange gigabyte minne i disse dager.

1581
01:18:44,730 --> 01:18:47,700
Og en gig betyr milliarder,
så milliarder av bytes.

1582
01:18:47,700 --> 01:18:48,910
>> Men la oss spole tilbake i tid.

1583
01:18:48,910 --> 01:18:51,530
Og anta at vi bruker
en virkelig gammel datamaskin som

1584
01:18:51,530 --> 01:18:55,150
bare har 32 byte minne.

1585
01:18:55,150 --> 01:18:59,310
Jeg kunne, på skjermen min,
bare trekke dette ut som følger.

1586
01:18:59,310 --> 01:19:05,240
>> Jeg kunne bare si at min
Datamaskinen har alt dette minne.

1587
01:19:05,240 --> 01:19:08,830
Og dette er som en stokk med minne, hvis
du husker vår bilde fra forrige gang.

1588
01:19:08,830 --> 01:19:11,670
Og hvis jeg bare dele
dette i nok ganger,

1589
01:19:11,670 --> 01:19:15,040
Jeg påstår at jeg har 32 bytes
av minne på skjermen.

1590
01:19:15,040 --> 01:19:18,239
>> Nå, i virkeligheten, kan jeg bare
trekke så langt på denne skjermen her.

1591
01:19:18,239 --> 01:19:20,280
Så jeg kommer til å gå videre,
og bare ved konvensjonen,

1592
01:19:20,280 --> 01:19:24,050
trekke datamaskinens minne som en
gitter, ikke bare som en rett linje.

1593
01:19:24,050 --> 01:19:28,190
Spesielt hevder jeg nå at
dette rutenettet, dette åtte av 4 rutenett,

1594
01:19:28,190 --> 01:19:31,800
bare representerer alle 32 bytes
tilgjengelig minne i min Mac,

1595
01:19:31,800 --> 01:19:33,030
eller tilgjengelig i min PC.

1596
01:19:33,030 --> 01:19:34,780
Og de er innpakning
på to linjer, bare

1597
01:19:34,780 --> 01:19:38,030
fordi det passer mer på skjermen.

1598
01:19:38,030 --> 01:19:40,800
Men dette er den første byte.

1599
01:19:40,800 --> 01:19:41,990
Dette er den andre byten.

1600
01:19:41,990 --> 01:19:43,300
Dette er den tredje byte.

1601
01:19:43,300 --> 01:19:45,310
>> Og dette er den 32. byte.

1602
01:19:45,310 --> 01:19:52,910
Eller, hvis vi tenke som en datamaskin
vitenskapsmann, er dette byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Så du har 0-31, hvis
du begynner å telle på 0.

1604
01:19:55,950 --> 01:19:59,830
>> Så hvis vi bruker et program
at samtalene blir streng,

1605
01:19:59,830 --> 01:20:05,280
og vi får en snor fra den humane
som jeg gjorde kalt Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
hvordan i all verden gjør
datamaskin holde styr på hvilke byte,

1607
01:20:09,430 --> 01:20:12,230
som del av minnet,
tilhører hvilken streng?

1608
01:20:12,230 --> 01:20:16,270
Med andre ord, hvis vi går videre til
skriver et annet navn i datamaskinen,

1609
01:20:16,270 --> 01:20:19,890
som dette Andi, ringer
få strengen en andre gang,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I har til å ende opp i
maskinens minne også.

1611
01:20:23,030 --> 01:20:23,850
Men hvordan?

1612
01:20:23,850 --> 01:20:29,700
>> Vel, det viser seg at under
hette, hva C gjør når lagring av strenger

1613
01:20:29,700 --> 01:20:35,080
at mennesketyper i, eller at
komme fra en annen kilde, er det

1614
01:20:35,080 --> 01:20:39,190
markerer slutten av dem med
en spesiell character-- skråstrek

1615
01:20:39,190 --> 01:20:44,750
0, som er bare en spesiell måte
si 80 biter på rad.

1616
01:20:44,750 --> 01:20:47,950
>> Så A-- dette er nummer 97 tilbakekalling.

1617
01:20:47,950 --> 01:20:51,770
Så noen mønster av 8 bits
representerer desimaltall 97.

1618
01:20:51,770 --> 01:20:58,070
Dette backslash 0 er bokstavelig talt antall
0, også kjent nul, N-U-L, i motsetning til tidligere,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, som vi snakket om.

1620
01:20:59,630 --> 01:21:05,700
Men for nå, bare vet at dette
backslash 0 er kun 80 bits på rad.

1621
01:21:05,700 --> 01:21:09,810
>> Og det er nettopp denne linjen i
sand som sier noe til venstre

1622
01:21:09,810 --> 01:21:12,610
hører til en streng, eller en datatype.

1623
01:21:12,610 --> 01:21:15,480
Og noe til høyre
hører til noe annet.

1624
01:21:15,480 --> 01:21:17,440
Andi navn, i mellomtiden,
som bare visuelt

1625
01:21:17,440 --> 01:21:21,310
skjer for å vikle på den annen linje,
men det er bare et estetisk detalj,

1626
01:21:21,310 --> 01:21:23,990
på samme måte er nul avsluttet.

1627
01:21:23,990 --> 01:21:29,290
>> Det er en streng med en A-N-D-I-tegn,
pluss en femte hemmelig karakter,

1628
01:21:29,290 --> 01:21:33,560
alle 0 biter, som bare avgrenser
slutten av Andi navn i tillegg.

1629
01:21:33,560 --> 01:21:37,120
Og hvis vi kaller får streng for tredje gang
i datamaskinen for å få en streng som

1630
01:21:37,120 --> 01:21:44,210
Maria M-A-R-I-A, er tilsvarende Maria
Navnet nul avsluttet med backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Dette er fundamentalt forskjellig
fra hvordan en datamaskin ville vanligvis

1632
01:21:47,170 --> 01:21:51,850
lagre et helt tall, eller en flåte, eller annen
datatyper fortsatt, fordi husker,

1633
01:21:51,850 --> 01:21:57,420
et tall er vanligvis 32 biter, eller
4 byte, eller kanskje til og med 64 bits,

1634
01:21:57,420 --> 01:21:59,100
eller åtte bytes.

1635
01:21:59,100 --> 01:22:02,620
Men mange primitiver i en datamaskin
i et programmeringsspråk

1636
01:22:02,620 --> 01:22:05,550
ha et fast antall
byte under hood--

1637
01:22:05,550 --> 01:22:08,100
kanskje en, kanskje to, kanskje fire, kanskje åtte.

1638
01:22:08,100 --> 01:22:13,250
>> Men strenger, med design, har en
dynamisk antall tegn.

1639
01:22:13,250 --> 01:22:16,980
Du vet ikke på forhånd, før
mennesketyper i Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
eller M-A-R-I-A eller A-N-D-I. Du vet ikke
hvor mange ganger brukeren kommer til å treffe

1641
01:22:21,400 --> 01:22:22,070
tastaturet.

1642
01:22:22,070 --> 01:22:26,490
Derfor trenger du ikke vet hvordan
mange tegn i forveien

1643
01:22:26,490 --> 01:22:27,540
du kommer til å trenge.

1644
01:22:27,540 --> 01:22:31,840
>> Og så C bare slags blader som en
hemmelig brødsmule under panseret

1645
01:22:31,840 --> 01:22:32,960
ved slutten av strengen.

1646
01:22:32,960 --> 01:22:39,280
Etter lagring av Z-A-M-Y-L-A i minnet,
det også bare setter tilsvar

1647
01:22:39,280 --> 01:22:40,210
av en periode.

1648
01:22:40,210 --> 01:22:45,060
Ved slutten av en setning,
det setter 80 biter, slik som

1649
01:22:45,060 --> 01:22:49,120
å huske hvor
Zamyla begynner og slutter.

1650
01:22:49,120 --> 01:22:51,490
>> Så hva er forbindelsen,
da, til dette programmet?

1651
01:22:51,490 --> 01:22:55,190
Dette programmet her, Stirling,
er ganske enkelt en mekanisme

1652
01:22:55,190 --> 01:22:57,970
for å få en streng
fra brukeren, linje 6.

1653
01:22:57,970 --> 01:23:01,160
Linje 7, erklærer jeg en variabel
kalt n og sette den lik 0.

1654
01:23:01,160 --> 01:23:08,680
>> Og så i linje 8, bare spurte jeg
spørsmål, mens den n-te tegn gjør

1655
01:23:08,680 --> 01:23:12,120
ikke lik alle 0 bits--
med andre ord, ikke gjør

1656
01:23:12,120 --> 01:23:14,500
lik denne spesielle
karakter, backslash 0, som

1657
01:23:14,500 --> 01:23:18,470
var bare at spesielle nul character--
gå videre og bare øke n.

1658
01:23:18,470 --> 01:23:21,460
>> Og fortsette å gjøre det, og holde
å gjøre det, og fortsette å gjøre det.

1659
01:23:21,460 --> 01:23:23,430
Og så selv om det i
Tidligere har vi brukt i,

1660
01:23:23,430 --> 01:23:25,181
det er helt greit
semantisk å bruke n,

1661
01:23:25,181 --> 01:23:27,430
hvis du bare prøver å
teller denne gangen med vilje,

1662
01:23:27,430 --> 01:23:28,720
og bare ønsker å kalle det n.

1663
01:23:28,720 --> 01:23:34,720
Så dette bare fortsetter å stille spørsmålet,
er det n-te karakter er alle 0s?

1664
01:23:34,720 --> 01:23:38,470
Hvis ikke, se til neste utseende,
se til den neste, se til neste,

1665
01:23:38,470 --> 01:23:39,460
se til neste.

1666
01:23:39,460 --> 01:23:45,540
>> Men så snart du ser backslash 0,
dette loop-- linje 9 gjennom 11-- stopper.

1667
01:23:45,540 --> 01:23:49,640
Du bryte ut av mens loop,
forlater innsiden av den variabelen n

1668
01:23:49,640 --> 01:23:54,530
en total telling av alle
tegn i strengen du så,

1669
01:23:54,530 --> 01:23:55,660
dermed skrive den ut.

1670
01:23:55,660 --> 01:23:56,760
Så la oss prøve dette.

1671
01:23:56,760 --> 01:23:59,500
>> La meg gå videre og uten
bruker stirling funksjon,

1672
01:23:59,500 --> 01:24:04,240
men bare ved hjelp av min egen hjemmelaget versjon
her kalt stirling, la meg gå videre

1673
01:24:04,240 --> 01:24:07,700
og kjøre Stirling, skriv noe
som Zamyla, som jeg vet på forhånd

1674
01:24:07,700 --> 01:24:08,670
er seks tegn.

1675
01:24:08,670 --> 01:24:10,080
La oss se om det fungerer.

1676
01:24:10,080 --> 01:24:10,920
Faktisk er det seks.

1677
01:24:10,920 --> 01:24:15,257
La oss prøve med Rob, tre tegn,
tre tegn også, og så videre.

1678
01:24:15,257 --> 01:24:17,340
Så det er alt som skjer
på under panseret.

1679
01:24:17,340 --> 01:24:19,548
Og legg merke til tilkoblingene,
deretter, med den første uken

1680
01:24:19,548 --> 01:24:22,370
av klasse, hvor vi snakket om
noe som abstraksjon,

1681
01:24:22,370 --> 01:24:26,960
som er nettopp dette lagdeling av ideer, eller
kompleksitet, på toppen av grunnleggende prinsipper.

1682
01:24:26,960 --> 01:24:30,710
Her, vi er liksom ute
under panseret av Stirling,

1683
01:24:30,710 --> 01:24:33,510
så å si, for å finne ut,
hvordan ville det bli gjennomført?

1684
01:24:33,510 --> 01:24:35,232
>> Og vi kunne re-implementere det selv.

1685
01:24:35,232 --> 01:24:37,440
Men vi aldri igjen kommer
å re-implementere Stirling.

1686
01:24:37,440 --> 01:24:39,780
Vi skal bare
bruke stirling for

1687
01:24:39,780 --> 01:24:42,100
å faktisk få noen strenger lengde.

1688
01:24:42,100 --> 01:24:44,200
>> Men det er ingen magisk
under panseret.

1689
01:24:44,200 --> 01:24:46,716
Hvis du vet at under
panseret, en streng

1690
01:24:46,716 --> 01:24:48,090
er bare en sekvens av tegn.

1691
01:24:48,090 --> 01:24:51,090
Og at sekvens av tegn
alle kan numerisk adressert

1692
01:24:51,090 --> 01:24:53,330
med brakett 0, brakett
1, brakett 2, og du

1693
01:24:53,330 --> 01:24:57,420
vet at ved enden av en streng er en
spesialtegn, kan du finne ut

1694
01:24:57,420 --> 01:25:01,710
hvordan du gjør de fleste noe i en
program, fordi alt det koker ned til

1695
01:25:01,710 --> 01:25:03,400
leser og skriver minne.

1696
01:25:03,400 --> 01:25:06,130
Det er, i endring og ser
på minne, eller flytte ting

1697
01:25:06,130 --> 01:25:10,940
rundt i minne, trykking ting
på skjermen, og så videre.

1698
01:25:10,940 --> 01:25:14,800
>> Så la oss nå bruke denne nyvunne
forståelse av hva strenger faktisk

1699
01:25:14,800 --> 01:25:17,910
er under panseret, og
skrelle tilbake en annen lag

1700
01:25:17,910 --> 01:25:20,080
som inntil nå har vi
vært ignorerer helt.

1701
01:25:20,080 --> 01:25:22,650
I særdeleshet, når som helst
Vi har iverksatt et program,

1702
01:25:22,650 --> 01:25:25,930
vi har hatt denne linjen med kode
nær toppen erklærte hoved.

1703
01:25:25,930 --> 01:25:27,810
Og vi har angitt int main annullert.

1704
01:25:27,810 --> 01:25:31,240
>> Og det tomrommet i parentes
har vært å si hele tiden at hoved

1705
01:25:31,240 --> 01:25:33,440
selv ikke ta noen argumenter.

1706
01:25:33,440 --> 01:25:36,210
Eventuelle innspill som hoved er
skal komme fra brukeren

1707
01:25:36,210 --> 01:25:39,020
må komme fra noen andre
mekanisme, som get int,

1708
01:25:39,020 --> 01:25:42,040
eller få flyte, eller få streng,
eller en annen funksjon.

1709
01:25:42,040 --> 01:25:44,710
Men det viser seg at
når du skriver et program,

1710
01:25:44,710 --> 01:25:47,690
du kan faktisk spesifisere
at dette programmet skal

1711
01:25:47,690 --> 01:25:51,730
tar inngangssignaler fra den humane
på kommandolinjen i seg selv.

1712
01:25:51,730 --> 01:25:56,310
>> Med andre ord, selv om vi hittil
har vært i drift bare ./hello hallo

1713
01:25:56,310 --> 01:26:00,312
eller lignende programmer, alle av
andre programmer som vi har brukt,

1714
01:26:00,312 --> 01:26:02,770
at vi selv ikke skrive,
har blitt tatt, det virker,

1715
01:26:02,770 --> 01:26:05,210
kommandolinje arguments--
ting som gjør.

1716
01:26:05,210 --> 01:26:07,450
Du sier noe som make,
og deretter en andre ord.

1717
01:26:07,450 --> 01:26:10,950
Eller klang, sier du clang, og deretter
en andre ord, navnet på en fil.

1718
01:26:10,950 --> 01:26:14,410
>> Eller enda RM eller CP, som du kanskje
har sett eller brukt allerede

1719
01:26:14,410 --> 01:26:15,880
å fjerne eller kopiere filer.

1720
01:26:15,880 --> 01:26:18,920
Alle disse ta såkalt
kommandolinje arguments--

1721
01:26:18,920 --> 01:26:21,130
flere ord på terminalen teksten.

1722
01:26:21,130 --> 01:26:23,260
Men frem til nå, vi
selv har ikke hatt

1723
01:26:23,260 --> 01:26:27,080
denne luksusen av å ta innspill fra
brukeren når han eller hun faktisk kjører

1724
01:26:27,080 --> 01:26:29,120
selve programmet på kommandolinjen.

1725
01:26:29,120 --> 01:26:33,710
>> Men vi kan gjøre det ved å re-erklære
Hoved fremover, ikke som å ha

1726
01:26:33,710 --> 01:26:36,750
ugyldig i parentes,
men disse to argumenter

1727
01:26:36,750 --> 01:26:40,600
instead-- første et heltall,
og den andre noe

1728
01:26:40,600 --> 01:26:44,170
nytt, noe som vi kommer til å kalle
en matrise, noe lignende i ånd

1729
01:26:44,170 --> 01:26:49,220
til hva vi så i Scratch som en liste, men
en rekke strenger, som vi vil snart se.

1730
01:26:49,220 --> 01:26:51,790
Men la oss se dette ved
Som et eksempel, før vi

1731
01:26:51,790 --> 01:26:53,690
skille nøyaktig hva det betyr.

1732
01:26:53,690 --> 01:26:56,520
>> Så hvis jeg går inn CS50 IDE
her har jeg gått fremover

1733
01:26:56,520 --> 01:27:01,840
og erklærte i en fil kalt
argv0.c følgende mal.

1734
01:27:01,840 --> 01:27:04,120
Og legg merke til den eneste
som er annerledes så langt

1735
01:27:04,120 --> 01:27:08,570
er at jeg har forandret tomrommet til int
argc streng argv åpen brakett, nær

1736
01:27:08,570 --> 01:27:09,070
brakett.

1737
01:27:09,070 --> 01:27:11,730
Og legg merke til nå, er det
ingenting inne i disse aldersgruppene.

1738
01:27:11,730 --> 01:27:12,620
>> Det finnes ingen tall.

1739
01:27:12,620 --> 01:27:15,070
Og det er ingen i, eller
n, eller en hvilken som helst annen bokstav.

1740
01:27:15,070 --> 01:27:17,010
Jeg bare bruker
hakeparentes for nå,

1741
01:27:17,010 --> 01:27:19,510
av grunner vi vil komme
tilbake til i løpet av et øyeblikk.

1742
01:27:19,510 --> 01:27:21,330
>> Og nå hva jeg skal gjøre, er dette.

1743
01:27:21,330 --> 01:27:26,680
Hvis argc lik lik 2--
og husker som tilsvarer likemenn

1744
01:27:26,680 --> 01:27:30,040
er likestilling operatør sammenligne
venstre og høyre for likestilling.

1745
01:27:30,040 --> 01:27:31,790
Det er ikke oppdraget
Operatøren, som er

1746
01:27:31,790 --> 01:27:36,510
singelen likhetstegn, noe som betyr at kopi
fra høyre mot venstre noen verdi.

1747
01:27:36,510 --> 01:27:42,840
>> Hvis argc lik lik 2, ønsker jeg å
sier printf, hallo, prosenter, ny linje,

1748
01:27:42,840 --> 01:27:47,340
og koble deretter in-- og her er den nye
trick-- argv brakett 1, av grunner

1749
01:27:47,340 --> 01:27:48,840
at vi vil komme tilbake til i et øyeblikk.

1750
01:27:48,840 --> 01:27:52,110
Else hvis argc ikke
lik 2, vet du hva?

1751
01:27:52,110 --> 01:27:57,400
La oss bare gå videre og, som vanlig, print
ut hello world med ingen erstatning.

1752
01:27:57,400 --> 01:28:02,710
>> Så det synes som om argc, som
står for argumentet teller, er lik 2,

1753
01:28:02,710 --> 01:28:04,740
Jeg kommer til å skrive ut
hei eller annet.

1754
01:28:04,740 --> 01:28:07,560
Ellers, som standard, er jeg
kommer til å skrive ut hello world.

1755
01:28:07,560 --> 01:28:08,770
Så hva betyr dette?

1756
01:28:08,770 --> 01:28:15,550
>> Vel, la meg gå videre og lagre
denne filen, og deretter gjør argv0,

1757
01:28:15,550 --> 01:28:18,940
og deretter ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Og det sier hei verden.

1759
01:28:20,300 --> 01:28:21,260
Nå, hvorfor er det?

1760
01:28:21,260 --> 01:28:24,730
>> Vel, det viser seg når du
kjøre et program på kommandolinjen,

1761
01:28:24,730 --> 01:28:29,570
du fyller på hva vi vil
vanligvis kaller et argument vektor.

1762
01:28:29,570 --> 01:28:33,100
Med andre ord, automatisk
datamaskinen, operativsystemet,

1763
01:28:33,100 --> 01:28:38,340
kommer til å levere til programmet
selv en liste over alle ordene

1764
01:28:38,340 --> 01:28:40,850
at den menneskelige skrevet på
spørsmål, i tilfelle du

1765
01:28:40,850 --> 01:28:43,790
programmereren ønsker å gjøre
noe med denne informasjonen.

1766
01:28:43,790 --> 01:28:48,540
Og i dette tilfellet er den eneste ord
Jeg har skrevet på teksten er ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Og så antallet argumenter som er
blir sendt til programmet mitt er bare én.

1768
01:28:55,420 --> 01:28:58,880
Med andre ord, argumentet
teller, også kjent som argc

1769
01:28:58,880 --> 01:29:00,970
her som et heltall, er bare ett.

1770
01:29:00,970 --> 01:29:03,000
En selvfølgelig ikke lik to.

1771
01:29:03,000 --> 01:29:05,980
Og så dette er hva skriver, hallo verden.

1772
01:29:05,980 --> 01:29:08,170
>> Men la meg ta dette et sted.

1773
01:29:08,170 --> 01:29:09,930
La meg si, argv0.

1774
01:29:09,930 --> 01:29:12,740
Og så hva med Maria?

1775
01:29:12,740 --> 01:29:14,990
Og så trykker på Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Og legg merke til hva som magisk som skjer her.

1777
01:29:18,020 --> 01:29:22,640
Nå, i stedet for hallo verden, har jeg
endret oppførsel av dette programmet

1778
01:29:22,640 --> 01:29:26,310
ved å ta inngangs ikke fra get
streng eller en annen funksjon,

1779
01:29:26,310 --> 01:29:30,570
men fra, tilsynelatende, min kommando
selv, hva jeg opprinnelig skrevet i.

1780
01:29:30,570 --> 01:29:35,720
Og jeg kan spille dette spillet igjen ved
endre den til Stelios, for eksempel.

1781
01:29:35,720 --> 01:29:38,400
>> Og nå ser jeg et annet navn fortsatt.

1782
01:29:38,400 --> 01:29:40,540
Og her kan jeg si Andi.

1783
01:29:40,540 --> 01:29:42,137
Og jeg kan si Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Og vi kan spille dette spillet hele dagen lang,
bare plugge i forskjellige verdier,

1785
01:29:45,220 --> 01:29:49,550
så lenge jeg gi nøyaktig
to ord på spørsmål,

1786
01:29:49,550 --> 01:29:52,260
slik at argc, mitt argument teller, er 2.

1787
01:29:52,260 --> 01:29:57,240
>> Ser jeg det navnet plugget inn
printf, per denne tilstanden her?

1788
01:29:57,240 --> 01:30:00,550
Så vi synes å ha nå
uttrykksevne

1789
01:30:00,550 --> 01:30:04,410
for å ta inndata fra en annen mekanisme,
fra den såkalte kommandolinjen,

1790
01:30:04,410 --> 01:30:07,000
i stedet for å måtte vente
inntil brukeren kjører programmet,

1791
01:30:07,000 --> 01:30:10,220
og deretter be ham eller henne
bruke noe sånt get streng.

1792
01:30:10,220 --> 01:30:11,230
>> Så hva er dette?

1793
01:30:11,230 --> 01:30:15,010
Argc, igjen, er bare et tall,
antall words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
at brukeren gis ved
teksten på terminalvinduet,

1795
01:30:18,540 --> 01:30:20,110
inkludert programmets navn.

1796
01:30:20,110 --> 01:30:23,340
Så vår ./argv0 er effektivt,
programmets navn,

1797
01:30:23,340 --> 01:30:24,520
eller hvordan jeg kjører programmet.

1798
01:30:24,520 --> 01:30:25,810
>> Som teller som et ord.

1799
01:30:25,810 --> 01:30:27,080
Så argc ville være en.

1800
01:30:27,080 --> 01:30:29,750
Men når jeg skriver Stelios, eller
Andi, eller Zamyla, eller Maria,

1801
01:30:29,750 --> 01:30:31,660
det betyr at argumentet teller er to.

1802
01:30:31,660 --> 01:30:33,910
Og så nå er det to ord gått inn.

1803
01:30:33,910 --> 01:30:36,070
>> Og legg merke til, kan vi fortsette denne logikken.

1804
01:30:36,070 --> 01:30:39,050
Hvis jeg faktisk si
noe som Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
fullt navn, og dermed passerer
tre argumenter totalt,

1806
01:30:42,200 --> 01:30:47,410
Nå står det standard igjen,
grunn, selvfølgelig, 3 ikke er lik to.

1807
01:30:47,410 --> 01:30:54,080
>> Og så på denne måten, jeg har
tilgang via argv denne nye argument

1808
01:30:54,080 --> 01:30:56,080
at vi kunne teknisk
kalle noe vi ønsker.

1809
01:30:56,080 --> 01:30:58,940
Men etter konvensjonen, er det
argv og argc, henholdsvis.

1810
01:30:58,940 --> 01:31:04,470
Argv, argument vektor, er snill
av et synonym for et programmerings

1811
01:31:04,470 --> 01:31:07,140
funksjonen i C kalles en matrise.

1812
01:31:07,140 --> 01:31:14,410
>> En matrise er en liste over lignende verdier
tilbake, til rygg, og bakover, mot rygg.

1813
01:31:14,410 --> 01:31:17,810
Med andre ord, er om man her i
RAM, er den neste rett ved siden av den,

1814
01:31:17,810 --> 01:31:18,800
og rett ved siden av den.

1815
01:31:18,800 --> 01:31:20,101
De er ikke over alt.

1816
01:31:20,101 --> 01:31:23,100
Og det sistnevnte scenario, hvor ting
er over alt i minnet,

1817
01:31:23,100 --> 01:31:25,082
kan faktisk være en kraftig funksjon.

1818
01:31:25,082 --> 01:31:28,040
Men vi vil komme tilbake til det når vi
snakke om mer avansert datastrukturer.

1819
01:31:28,040 --> 01:31:32,260
For nå er en matrise bare en
mengde sammenhengende minne,

1820
01:31:32,260 --> 01:31:36,520
hver av der elementene
tilbake, til rygg, og bakover, mot rygg,

1821
01:31:36,520 --> 01:31:38,050
og generelt den samme type.

1822
01:31:38,050 --> 01:31:42,630
>> Så hvis du tenker på, fra en
øyeblikk siden, hva er en streng?

1823
01:31:42,630 --> 01:31:50,460
Vel, en streng, som Zamyla,
Z-A-M-Y-L-A, er teknisk sett

1824
01:31:50,460 --> 01:31:51,400
bare en matrise.

1825
01:31:51,400 --> 01:31:53,700
Det er en rekke tegn.

1826
01:31:53,700 --> 01:31:59,250
>> Og så hvis vi virkelig trekke dette, som jeg
gjorde tidligere, som en del av minne,

1827
01:31:59,250 --> 01:32:04,510
det viser seg at hver av disse
tegn tar opp en byte.

1828
01:32:04,510 --> 01:32:07,630
Og så er det den spesielle
sentinel karakter, backslash 0,

1829
01:32:07,630 --> 01:32:12,360
eller alle åtte 0 biter, som
avgrenser slutten av strengen.

1830
01:32:12,360 --> 01:32:15,090
Så en streng, viser det
ut, sitere unquote streng,

1831
01:32:15,090 --> 01:32:20,580
er bare et utvalg av chara--
røye være en aktuell datatype.

1832
01:32:20,580 --> 01:32:24,560
>> Og nå argv, meanwhile--
La oss gå tilbake til programmet.

1833
01:32:24,560 --> 01:32:29,582
Argv, selv om vi ser ordet
streng her, er ikke en streng selv.

1834
01:32:29,582 --> 01:32:33,640
Argv, argument vektor,
er en rekke strenger.

1835
01:32:33,640 --> 01:32:37,620
>> Så akkurat som du kan ha en rekke
tegn, kan du ha høyere nivå,

1836
01:32:37,620 --> 01:32:46,279
en rekke strings-- slik at, for eksempel,
når jeg skrev en stund siden ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, plass Z-A-M-Y-L-A, I hevdet at
argv hadde to strenger i it ./argv0,

1838
01:33:00,150 --> 01:33:03,185
og Z-A-M-Y-L-A. I
Med andre ord, argc var 2.

1839
01:33:03,185 --> 01:33:03,980
Hvorfor det?

1840
01:33:03,980 --> 01:33:08,370
>> Vel, effektivt, er det som skjer
på er at hver av disse strengene

1841
01:33:08,370 --> 01:33:13,990
er selvsagt en rekke tegn
som før, hver av der tegnene

1842
01:33:13,990 --> 01:33:15,670
tar opp en byte.

1843
01:33:15,670 --> 01:33:19,720
Og ikke forveksle den faktiske 0
i programmets navn med 0,

1844
01:33:19,720 --> 01:33:22,040
noe som betyr at alle 80 bits.

1845
01:33:22,040 --> 01:33:27,140
Og Zamyla, i mellomtiden, er fortsatt
også en rekke tegn.

1846
01:33:27,140 --> 01:33:31,450
>> Så på slutten av dagen, det egentlig
ser slik ut under panseret.

1847
01:33:31,450 --> 01:33:38,800
Men argv, av naturen av hvordan hoved
verker, tillater meg å pakke alt dette

1848
01:33:38,800 --> 01:33:44,810
opp i, om du vil, en større matrise
at hvis vi litt over forenkle

1849
01:33:44,810 --> 01:33:48,180
hva bildet ser ut og ikke
ganske trekke det å skalere opp der,

1850
01:33:48,180 --> 01:33:56,720
denne matrisen er bare av størrelse 2, den første
element som inneholder en streng,

1851
01:33:56,720 --> 01:33:59,230
det andre elementet i
som inneholder en streng.

1852
01:33:59,230 --> 01:34:01,687
Og, i sin tur, hvis du
slags zoome inn på hver

1853
01:34:01,687 --> 01:34:03,770
av disse strengene, hva du
se under panseret

1854
01:34:03,770 --> 01:34:07,190
er at hver streng er bare
en rekke med tegn.

1855
01:34:07,190 --> 01:34:11,680
>> Nå, akkurat som med strenger,
vi var i stand til å få tilgang

1856
01:34:11,680 --> 01:34:15,260
til i-te tegn i en streng
bruker som hakeparentes notasjon.

1857
01:34:15,260 --> 01:34:17,320
På samme måte, med matriser
Generelt kan vi

1858
01:34:17,320 --> 01:34:22,700
bruke hakeparentes notasjon for å få
på en rekke strenger i en matrise?

1859
01:34:22,700 --> 01:34:25,100
For eksempel, la meg
gå videre og gjøre dette.

1860
01:34:25,100 --> 01:34:32,420
>> La meg gå videre og skape argv1.c,
som er litt annerledes denne gangen.

1861
01:34:32,420 --> 01:34:35,635
I stedet for å se etter argc2,
Jeg kommer til stedet gjøre dette.

1862
01:34:35,635 --> 01:34:41,270
For int jeg får 0, er jeg mindre
enn argc, jeg pluss pluss,

1863
01:34:41,270 --> 01:34:47,920
og deretter skrive ut innsiden av denne,
prosent s, ny linje, og deretter

1864
01:34:47,920 --> 01:34:50,740
argv brakett i.

1865
01:34:50,740 --> 01:34:55,220
>> Så med andre ord, jeg er ikke arbeider med
individuelle tegn i øyeblikket.

1866
01:34:55,220 --> 01:35:00,190
Argv, som følger av disse tomme plassen
bukseseler til høyre for navnet argv,

1867
01:35:00,190 --> 01:35:03,320
betyr argv er en rekke strenger.

1868
01:35:03,320 --> 01:35:04,870
Og argc er bare en int.

1869
01:35:04,870 --> 01:35:08,800
>> Denne linjen her, seks, er
sier sett i lik 0.

1870
01:35:08,800 --> 01:35:11,980
Telle hele veien opp til,
men ikke inkludert, argc.

1871
01:35:11,980 --> 01:35:14,010
Og deretter på hver iterasjon,
skrive ut en streng.

1872
01:35:14,010 --> 01:35:14,800
Hva streng?

1873
01:35:14,800 --> 01:35:17,270
>> I-te streng i argv.

1874
01:35:17,270 --> 01:35:19,530
Så mens før jeg var
bruker hakeparentes

1875
01:35:19,530 --> 01:35:22,180
notasjon for å få på ith
tegn i en streng, nå

1876
01:35:22,180 --> 01:35:27,240
Jeg bruker hakeparentes notasjon
å få på ith strengen i en matrise.

1877
01:35:27,240 --> 01:35:30,310
Så det er på en måte ett lag
ovenfor, konseptuelt.

1878
01:35:30,310 --> 01:35:35,390
>> Og så hva er ryddig om dette
programmet nå, hvis jeg kompilere argv1,

1879
01:35:35,390 --> 01:35:42,067
og deretter gjøre ./argv1, og skriv deretter inn
i noe som foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
som er de tre standard ord som en
datamaskin vitenskapsmann strekker seg etter noe tid

1881
01:35:45,400 --> 01:35:51,010
han eller hun trenger noen plassholder ord,
og trykk Enter, og hver av disse ordene,

1882
01:35:51,010 --> 01:35:54,980
inkludert programmets navn, som
er i argv på det første sted,

1883
01:35:54,980 --> 01:35:58,320
ender opp med å bli skrevet ut en av gangen.

1884
01:35:58,320 --> 01:36:05,290
Og hvis jeg endrer dette, og jeg sier
noe som argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
vi få alle tre av dem
ord, som er argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, fordi i denne
case argc, telle, er tre.

1887
01:36:14,400 --> 01:36:20,020
>> Men hva er ryddig er hvis du forstår
som argv er bare et utvalg av strenger,

1888
01:36:20,020 --> 01:36:24,910
og du forstår at en streng
er en rekke tegn,

1889
01:36:24,910 --> 01:36:29,470
vi kan faktisk slags bruk dette
hakeparentes notasjons flere ganger

1890
01:36:29,470 --> 01:36:33,320
å velge en streng, og velg deretter
et tegn i strengen,

1891
01:36:33,320 --> 01:36:35,730
dykking i dypere som følger.

1892
01:36:35,730 --> 01:36:40,100
I dette eksempelet, la meg gå
videre og kaller dette argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Og i dette eksempelet, la meg gå videre
og gjøre den following-- for int jeg får 0,

1895
01:36:50,180 --> 01:36:53,286
Jeg er mindre enn argc, jeg pluss
pluss, akkurat som før.

1896
01:36:53,286 --> 01:36:55,910
Så i andre words-- og nå dette
blir komplisert nok.

1897
01:36:55,910 --> 01:36:59,940
Så jeg kommer til å si
iterere over strenger i argv,

1898
01:36:59,940 --> 01:37:01,294
som en kommentar til meg selv.

1899
01:37:01,294 --> 01:37:03,960
Og så kommer jeg til å ha en
nestet for loop, som du sannsynligvis

1900
01:37:03,960 --> 01:37:06,290
har gjort, eller vurdert
gjør, i Scratch, hvor

1901
01:37:06,290 --> 01:37:08,600
Jeg kommer til å si int-- jeg er
ikke kommer til å bruke i på nytt,

1902
01:37:08,600 --> 01:37:12,590
fordi jeg ikke ønsker å skygge, eller
slags overskrive den eksisterende i.

1903
01:37:12,590 --> 01:37:15,780
>> Jeg kommer til stedet, sier j, fordi
det er mine går til variabelen etter at jeg,

1904
01:37:15,780 --> 01:37:18,590
når jeg prøver bare å
telle enkle tall.

1905
01:37:18,590 --> 01:37:28,850
For j får 0-- og også, n, kommer til å
få hekken lengden av argv brakett i,

1906
01:37:28,850 --> 01:37:36,030
så lenge som j er mindre enn m,
j pluss pluss, gjør følgende.

1907
01:37:36,030 --> 01:37:37,500
Og her er den interessante delen.

1908
01:37:37,500 --> 01:37:46,330
>> Skriv ut en karakter og en ny linje,
plugge i argv brakett jeg, brakett j.

1909
01:37:46,330 --> 01:37:47,940
OK, så la meg legge til noen kommentarer her.

1910
01:37:47,940 --> 01:37:54,820
Iterere over tegn
i aktuelle strengen,

1911
01:37:54,820 --> 01:38:02,290
print j-te karakter i i-te streng.

1912
01:38:02,290 --> 01:38:04,630
Så nå, la oss vurdere
hva disse kommentarene mener.

1913
01:38:04,630 --> 01:38:06,750
>> Iterere over strengene
i argv-- hvor mange

1914
01:38:06,750 --> 01:38:09,300
strenger er i argv, som er en matrise?

1915
01:38:09,300 --> 01:38:13,420
Argc mange, så jeg gjentar
fra i lik 0 opp til argc.

1916
01:38:13,420 --> 01:38:20,020
I mellomtiden, hvor mange tegn
er i den i-te streng i argv?

1917
01:38:20,020 --> 01:38:22,880
>> Vel, for å få det svaret,
Jeg bare ringe strenglengde

1918
01:38:22,880 --> 01:38:26,810
på den aktuelle strengen jeg omsorg
om, som er argv brakett i.

1919
01:38:26,810 --> 01:38:30,090
Og jeg kommer til å midlertidig lagre som
verdi i n, bare for caching formål,

1920
01:38:30,090 --> 01:38:31,590
å huske det for effektivitet.

1921
01:38:31,590 --> 01:38:36,330
Og så skal jeg initial j 0,
holde det gående så lenge som j er mindre enn n,

1922
01:38:36,330 --> 01:38:38,430
og på hver iterasjon økning j.

1923
01:38:38,430 --> 01:38:41,030
>> Og så i her, per
min kommentar på linje 12,

1924
01:38:41,030 --> 01:38:43,390
skrive ut et tegn,
etterfulgt av en ny linje,

1925
01:38:43,390 --> 01:38:48,140
spesielt argv brakett
Jeg gir meg i-te streng

1926
01:38:48,140 --> 01:38:51,690
i argv-- så det første ordet,
andre ord, den tredje ord, uansett.

1927
01:38:51,690 --> 01:38:57,370
Og så j dykk i dypere og får
meg j-te karakter av ordet.

1928
01:38:57,370 --> 01:39:02,200
Og så, i kraft, kan du behandle
argv som en flerdimensjonal,

1929
01:39:02,200 --> 01:39:06,050
som en to-dimensjonal, matrise,
der hvert ord slags utseende

1930
01:39:06,050 --> 01:39:08,580
som dette i ditt sinn
øyet, og hvert tegn

1931
01:39:08,580 --> 01:39:10,930
er slags komponert i
en kolonne, hvis det hjelper.

1932
01:39:10,930 --> 01:39:13,260
>> I virkeligheten, når vi erte
Dette leilighets i fremtiden uker,

1933
01:39:13,260 --> 01:39:15,580
det kommer til å være litt
mer avansert enn det.

1934
01:39:15,580 --> 01:39:17,800
Men du kan virkelig
tenke på det, for nå,

1935
01:39:17,800 --> 01:39:22,110
som nettopp dette todimensjonale
matrise, hvorved en nivå av det

1936
01:39:22,110 --> 01:39:23,260
er alle strengene.

1937
01:39:23,260 --> 01:39:26,760
Og så hvis du dykke i dypere, du
kan få på de enkelte tegn

1938
01:39:26,760 --> 01:39:29,600
disse ved å bruke denne notasjonen her.

1939
01:39:29,600 --> 01:39:31,620
>> Så hva er nettoeffekten?

1940
01:39:31,620 --> 01:39:34,970
La meg gå videre og
gjøre argv2-- darn det.

1941
01:39:34,970 --> 01:39:36,210
Jeg gjorde en feil her.

1942
01:39:36,210 --> 01:39:40,160
Implisitt erklære
bibliotek funksjon Stirling.

1943
01:39:40,160 --> 01:39:42,190
Så hele denne tiden, er det
kanskje passende

1944
01:39:42,190 --> 01:39:45,130
at vi er liksom etterbehandling
akkurat der vi startet.

1945
01:39:45,130 --> 01:39:48,160
>> Jeg skrudd opp, implisitt erklære
bibliotek funksjon Stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, vent litt.

1947
01:39:48,987 --> 01:39:51,070
Jeg husker det, spesielt
siden det er rett her.

1948
01:39:51,070 --> 01:39:54,490
Jeg må ta string.h i
denne versjonen av programmet.

1949
01:39:54,490 --> 01:40:00,050
>> La meg gå videre og omfatte
string.h, lagre det, gå videre

1950
01:40:00,050 --> 01:40:04,460
og rekompilere argv2.

1951
01:40:04,460 --> 01:40:08,390
Og nå, her går vi, gjør argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Og selv om det er litt
kryptisk ved første øyekast,

1953
01:40:10,590 --> 01:40:15,690
Legg merke til at, ja, hva
skrives er prikk argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Men hvis jeg skriver noen ord etter
teksten, som argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Skriv også litt
kryptisk ved første øyekast.

1956
01:40:22,560 --> 01:40:30,540
Men hvis vi bla opp igjen,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Så vi har gjentok over hvert ord.

1958
01:40:32,190 --> 01:40:37,770
Og i sin tur har vi gjentok løpet
hvert tegn i et ord.

1959
01:40:37,770 --> 01:40:40,040
>> Nå, etter alt dette,
innse at det er

1960
01:40:40,040 --> 01:40:43,120
en annen detalj vi har vært snill
for å ignorere dette hele tiden.

1961
01:40:43,120 --> 01:40:46,180
Vi ertet bare fra hverandre hva
viktigste innganger kan være?

1962
01:40:46,180 --> 01:40:47,780
Hva om hoved utgang?

1963
01:40:47,780 --> 01:40:50,540
>> Hele tiden har vi vært
bare å kopiere og lime inn

1964
01:40:50,540 --> 01:40:53,870
ordet int foran hoved,
om du kan se på nettet,

1965
01:40:53,870 --> 01:40:58,340
noen ganger feil i eldre versjoner
av C og kompilatorer, som de sier ugyldig,

1966
01:40:58,340 --> 01:40:59,410
eller ingenting i det hele tatt.

1967
01:40:59,410 --> 01:41:01,580
Men, ja, for den versjonen
av C som vi bruker,

1968
01:41:01,580 --> 01:41:06,180
C 11, eller 2011, innser
at det skal være int.

1969
01:41:06,180 --> 01:41:09,300
Og det bør heller være
ugyldig eller argc og argv her.

1970
01:41:09,300 --> 01:41:10,790
>> Men hvorfor int main?

1971
01:41:10,790 --> 01:41:12,480
Hva er det egentlig tilbake?

1972
01:41:12,480 --> 01:41:16,280
Vel, det viser seg all denne tiden,
når du har skrevet et program hoved

1973
01:41:16,280 --> 01:41:18,440
er alltid tilbake noe.

1974
01:41:18,440 --> 01:41:19,960
Men det har vært å gjøre det i hemmelighet.

1975
01:41:19,960 --> 01:41:23,350
>> At noe er en
int, som linje 5 antyder.

1976
01:41:23,350 --> 01:41:24,225
Men hva int?

1977
01:41:24,225 --> 01:41:26,100
Vel, det er dette
stevne i programmering,

1978
01:41:26,100 --> 01:41:29,790
hvorved Hvis ingenting har
gått galt og alt er bra,

1979
01:41:29,790 --> 01:41:34,250
programmer og funksjoner generelt
return-- noe counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 vanligvis betyr at alt er bra.

1982
01:41:38,070 --> 01:41:40,610
Så selv om du tenker på
den som falsk i mange sammenhenger,

1983
01:41:40,610 --> 01:41:42,930
det faktisk betyr vanligvis en god ting

1984
01:41:42,930 --> 01:41:49,560
>> I mellomtiden, hvis et program returnerer 1,
eller negativ 1 eller 5, eller negativ 42,

1985
01:41:49,560 --> 01:41:52,941
eller hvilket som helst ikke-0-verdi,
som vanligvis betyr

1986
01:41:52,941 --> 01:41:54,190
at noe har gått galt.

1987
01:41:54,190 --> 01:41:56,700
Faktisk, på din egen Mac eller PC,
du kanskje har faktisk sett

1988
01:41:56,700 --> 01:42:01,050
en feilmelding, der det
sier et eller annet, feil

1989
01:42:01,050 --> 01:42:04,940
kode negativ 42, eller feilkode
23, eller noe sånt.

1990
01:42:04,940 --> 01:42:08,980
At antallet er vanligvis bare et hint
til programmereren, eller selskapet

1991
01:42:08,980 --> 01:42:11,174
som gjorde programvaren,
hva som gikk galt og hvorfor,

1992
01:42:11,174 --> 01:42:13,590
slik at de kan se igjennom
dokumentasjonen eller kode,

1993
01:42:13,590 --> 01:42:15,465
og finne ut hva
error egentlig betyr.

1994
01:42:15,465 --> 01:42:18,400
Det er som regel ikke
nyttig for oss sluttbrukere.

1995
01:42:18,400 --> 01:42:20,550
>> Men når hoved returnerer 0, alt er bra.

1996
01:42:20,550 --> 01:42:23,770
Og hvis du ikke angir
hva hoved skal returnere,

1997
01:42:23,770 --> 01:42:26,950
det vil bare automatisk
returnere 0 for deg.

1998
01:42:26,950 --> 01:42:30,870
Men tilbake noe
ellers er faktisk nyttig.

1999
01:42:30,870 --> 01:42:34,660
>> I denne siste programmet, la meg
gå videre og kaller dette exit.c,

2000
01:42:34,660 --> 01:42:38,630
og innføre den siste av dagens
emner, kjent som en feilkode.

2001
01:42:38,630 --> 01:42:42,930
La meg gå videre og inkludere våre
kjente filer opp toppen, gjør int main.

2002
01:42:42,930 --> 01:42:49,500
Og denne gangen, la oss gjøre int argc,
string argv, og med mine brak

2003
01:42:49,500 --> 01:42:50,836
å antyde at det er i rekken.

2004
01:42:50,836 --> 01:42:52,460
Og så la meg bare gjøre en helsesjekk.

2005
01:42:52,460 --> 01:42:56,640
Denne gangen, hvis argc ikke
lik 2, så vet du hva?

2006
01:42:56,640 --> 01:42:57,520
Glem det.

2007
01:42:57,520 --> 01:43:03,170
Jeg kommer til å si at, hei, bruker,
du mangler kommandolinje argument

2008
01:43:03,170 --> 01:43:04,210
backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> Og så det er det.

2010
01:43:05,230 --> 01:43:06,130
Jeg ønsker å avslutte.

2011
01:43:06,130 --> 01:43:11,030
Jeg kommer til å preemptively,
og for tidlig egentlig, retur

2012
01:43:11,030 --> 01:43:12,810
noe annet enn tallet 1.

2013
01:43:12,810 --> 01:43:15,360
Farten til verdien for første
feil som kan skje er en.

2014
01:43:15,360 --> 01:43:17,860
Hvis du har noen andre feilaktige
situasjon som kan oppstå,

2015
01:43:17,860 --> 01:43:21,390
kan du si retur to eller returnere 3, eller
kanskje til og med negativ ett eller negativ to.

2016
01:43:21,390 --> 01:43:23,750
>> Dette er bare exit koder
det er, generelt,

2017
01:43:23,750 --> 01:43:27,770
bare nyttig til programmereren eller
selskap som sender programvaren.

2018
01:43:27,770 --> 01:43:30,500
Men det faktum at det er
ikke 0 er det som er viktig.

2019
01:43:30,500 --> 01:43:34,310
Så hvis du er i dette programmet, vil jeg
garantere at dette programmet bare

2020
01:43:34,310 --> 01:43:38,190
fungerer hvis brukeren gir meg
med et argument greven av to,

2021
01:43:38,190 --> 01:43:42,880
navnet på programmet, og en annen
ord, kan jeg håndheve så mye som følger,

2022
01:43:42,880 --> 01:43:46,110
kjefte på brukeren med printf ordtak,
mangler kommandolinje argument,

2023
01:43:46,110 --> 01:43:46,970
returnere en.

2024
01:43:46,970 --> 01:43:49,940
Det vil bare umiddelbart
avslutte programmet.

2025
01:43:49,940 --> 01:43:55,840
>> Bare hvis argc tilsvarer 2 vil vi få ned
her, slik at jeg kommer til å si,

2026
01:43:55,840 --> 01:44:00,410
hei prosent s, backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Med andre ord, jeg er
ikke gå etter argv 0,

2028
01:44:03,827 --> 01:44:05,410
som er bare navnet på programmet.

2029
01:44:05,410 --> 01:44:09,450
Jeg ønsker å skrive ut hallo, komma,
den andre ord at den menneskelige skrevet.

2030
01:44:09,450 --> 01:44:12,580
Og i dette tilfellet videre
linje 13, alt er bra.

2031
01:44:12,580 --> 01:44:15,920
>> Jeg vet at argc er 2
logisk av dette programmet.

2032
01:44:15,920 --> 01:44:17,770
Jeg kommer til å gå videre og returnere 0.

2033
01:44:17,770 --> 01:44:21,230
Som en side, husk at
dette er sant i Scratch også.

2034
01:44:21,230 --> 01:44:24,760
>> Logisk, jeg kunne gjøre dette
og innkapsle disse linjene

2035
01:44:24,760 --> 01:44:27,020
kode i denne ellers klausul her.

2036
01:44:27,020 --> 01:44:29,420
Men det er liksom
unødvendig innrykk koden min.

2037
01:44:29,420 --> 01:44:31,800
Og jeg vil lage super
klart at uansett hvilken,

2038
01:44:31,800 --> 01:44:34,670
som standard, hallo
noe vil bli skrevet ut,

2039
01:44:34,670 --> 01:44:36,050
så lenge brukeren samarbeider.

2040
01:44:36,050 --> 01:44:39,360
>> Så det er veldig vanlig å bruke
en tilstand, bare en hvis,

2041
01:44:39,360 --> 01:44:41,870
å fange noen feilaktige
situasjon, og deretter avslutte.

2042
01:44:41,870 --> 01:44:45,690
Og så, er så lenge alle
vel, ikke har et annet,

2043
01:44:45,690 --> 01:44:48,060
men bare har koden
utenfor at hvis, fordi det er

2044
01:44:48,060 --> 01:44:51,060
tilsvarende i denne
spesielle tilfellet, logisk.

2045
01:44:51,060 --> 01:44:54,480
Så jeg er tilbake 0, bare for å
eksplisitt betegne alt er bra.

2046
01:44:54,480 --> 01:44:58,480
>> Hvis jeg utelatt avkastningen 0, ville det
automatisk bli lagt til grunn for meg.

2047
01:44:58,480 --> 01:45:00,890
Men nå som jeg er tilbake
en i det minste i dette tilfellet

2048
01:45:00,890 --> 01:45:04,940
Jeg kommer til å, for godt mål, og
klarhet, returnerer 0 i dette tilfellet.

2049
01:45:04,940 --> 01:45:09,690
Så nå la meg gå videre og gjøre exit,
som er en perfekt naturlig overgang å bare la.

2050
01:45:09,690 --> 01:45:14,401
>> Men gjør exit, og la meg gå
videre og gjøre ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Og programmet skrek til meg,
mangler kommandolinje argument.

2052
01:45:16,900 --> 01:45:18,120
OK, la meg samarbeide.

2053
01:45:18,120 --> 01:45:23,810
>> La meg i stedet gjøre ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Og nå sier det, hallo David.

2055
01:45:25,190 --> 01:45:27,300
Og du normalt ikke ville se dette.

2056
01:45:27,300 --> 01:45:30,650
>> Men det viser seg at det er en
spesiell måte i Linux for å faktisk se

2057
01:45:30,650 --> 01:45:34,470
med hva exit kode et program avsluttes.

2058
01:45:34,470 --> 01:45:37,184
Noen ganger i en grafisk
verden som Mac OS eller Windows,

2059
01:45:37,184 --> 01:45:40,100
du bare se disse tallene når en
feilmeldingen dukker opp på skjermen

2060
01:45:40,100 --> 01:45:41,940
og programmereren
viser at antall.

2061
01:45:41,940 --> 01:45:44,773
Men hvis vi ønsker å se hva feilen
Budskapet er, vi kan gjøre det her--

2062
01:45:44,773 --> 01:45:48,100
så ./exit, Enter, print
mangler kommandolinje argument.

2063
01:45:48,100 --> 01:45:54,590
>> Hvis jeg nå gjør echo $ ?, som er
latterlig kryptisk utseende.

2064
01:45:54,590 --> 01:45:56,590
Men $?

2065
01:45:56,590 --> 01:45:59,220
er magisk besvergelse
som sier hei, datamaskin,

2066
01:45:59,220 --> 01:46:01,900
fortell meg hva den forrige
programmets avslutningskode var.

2067
01:46:01,900 --> 01:46:03,410
Og jeg trykker på Enter.

2068
01:46:03,410 --> 01:46:07,520
Jeg ser en, fordi det er det jeg
fortalte min viktigste funksjonen til å returnere.

2069
01:46:07,520 --> 01:46:12,310
>> I mellomtiden, hvis jeg gjør ./exit David,
og trykk Enter, ser jeg, hallo David.

2070
01:46:12,310 --> 01:46:16,800
Og hvis jeg nå gjør ekko $ ?, jeg ser hallo 0.

2071
01:46:16,800 --> 01:46:19,080
Og så vil dette faktisk
være verdifull informasjon

2072
01:46:19,080 --> 01:46:23,420
i sammenheng med debugger, ikke så
mye at du som menneske, ville vare.

2073
01:46:23,420 --> 01:46:26,060
Men debugger og andre
programmene vi vil bruke dette semesteret

2074
01:46:26,060 --> 01:46:29,420
vil ofte se på det nummeret,
selv om det er slags gjemt bort

2075
01:46:29,420 --> 01:46:32,780
med mindre du ser for det, for å
avgjøre om et program eller ikke

2076
01:46:32,780 --> 01:46:37,050
utførelsen var riktig eller feil.

2077
01:46:37,050 --> 01:46:40,450
>> Og så det bringer oss til
dette, på slutten av dagen.

2078
01:46:40,450 --> 01:46:43,917
Vi begynte i dag med å se på
debugging, og i sin tur på kurset

2079
01:46:43,917 --> 01:46:46,750
i seg selv, og da mer interessant,
teknisk under panseret

2080
01:46:46,750 --> 01:46:49,490
hva strenger er, som sist
uke vi bare tok for gitt,

2081
01:46:49,490 --> 01:46:51,900
og sikkert tok dem
for gitt i Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Vi så på hvordan vi kan få tilgang til
individuelle tegn i en streng,

2083
01:46:56,040 --> 01:47:00,310
og deretter igjen tok et høyere nivå
se på ting, se på hvordan samt--

2084
01:47:00,310 --> 01:47:04,226
hvis vi ønsker å få på individnivå
elementer i en listelignende struktur,

2085
01:47:04,226 --> 01:47:05,850
kan ikke vi gjøre det med flere strenger?

2086
01:47:05,850 --> 01:47:08,050
Og vi kan med kommandolinjeargumenter.

2087
01:47:08,050 --> 01:47:12,800
Men dette bildet her av bare bokser
er demonstrative av denne generelle ideen

2088
01:47:12,800 --> 01:47:14,451
av en matrise, eller en liste, eller en vektor.

2089
01:47:14,451 --> 01:47:16,450
Og avhengig av
kontekst, alle av disse ordene

2090
01:47:16,450 --> 01:47:17,880
bety litt forskjellige ting.

2091
01:47:17,880 --> 01:47:20,060
Så i C, vi bare kommer
å snakke om en matrise.

2092
01:47:20,060 --> 01:47:23,840
Og en matrise er en del
minne, er hver av dem

2093
01:47:23,840 --> 01:47:27,720
elementer er sammenhengende, tilbake,
til rygg, og bakover, mot rygg.

2094
01:47:27,720 --> 01:47:31,970
>> Og disse elementene er, generelt,
av den samme datatype, karakter

2095
01:47:31,970 --> 01:47:35,966
karakter, personlighet, karakter, eller
string, string, string, string, eller int,

2096
01:47:35,966 --> 01:47:38,600
int, int, uansett hva det er
vi prøver å lagre.

2097
01:47:38,600 --> 01:47:42,540
Men på slutten av dagen, er dette
hvordan det ser ut konseptuelt.

2098
01:47:42,540 --> 01:47:44,530
Du tar din
maskinens minne eller RAM.

2099
01:47:44,530 --> 01:47:48,590
Og du er carving det ut i
identisk størrelse bokser, som alle

2100
01:47:48,590 --> 01:47:50,920
er tilbake, til rygg, til
tilbake, kan du ta på denne måten.

2101
01:47:50,920 --> 01:47:53,200
>> Og hva er fint om
denne ide, og det faktum

2102
01:47:53,200 --> 01:47:58,580
at vi kan uttrykke verdier på denne måten
med den første av de datastrukturer

2103
01:47:58,580 --> 01:48:02,520
i klassen, betyr at vi kan starte
å løse problemer med kode

2104
01:48:02,520 --> 01:48:04,079
som kom så intuitivt i uke 0.

2105
01:48:04,079 --> 01:48:05,870
Du husker telefonen
Boken eksempel, der

2106
01:48:05,870 --> 01:48:09,110
vi brukte en splitt og hersk,
eller en Binærsøk,

2107
01:48:09,110 --> 01:48:13,220
å sile gjennom en hel
haug med navn og nummer.

2108
01:48:13,220 --> 01:48:18,220
Men vi antok, husker, at det
telefonboken var allerede sortert,

2109
01:48:18,220 --> 01:48:21,630
at noen andre hadde allerede
skjønte out-- gitt en liste med navn

2110
01:48:21,630 --> 01:48:24,430
og numbers-- hvordan alfabetisk rekkefølge.

2111
01:48:24,430 --> 01:48:26,950
Og nå som i C vi,
også har evnen

2112
01:48:26,950 --> 01:48:30,290
å legge ting ut, ikke
fysisk i en telefonbok

2113
01:48:30,290 --> 01:48:34,220
men nesten i en datamaskin
minne, vil vi være i stand til neste uke

2114
01:48:34,220 --> 01:48:38,470
å innføre nytt dette-- den første
av våre datastrukturer i en array--

2115
01:48:38,470 --> 01:48:43,530
men enda viktigere, selve datamaskinen
vitenskap algoritmer implementert

2116
01:48:43,530 --> 01:48:47,720
i kode, som vi kan lagre
data i strukturer som dette,

2117
01:48:47,720 --> 01:48:50,730
og deretter begynne å manipulere den, og
å faktisk løse problemer med det,

2118
01:48:50,730 --> 01:48:53,570
og å bygge på toppen av det,
slutt, programmer i C,

2119
01:48:53,570 --> 01:48:56,730
i Python, i Javascript,
spørring databaser med SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Og vi vil se at alle disse
forskjellige ideer sperre.

2121
01:48:59,980 --> 01:49:04,100
Men for nå, husker at
domene som vi introduserte i dag

2122
01:49:04,100 --> 01:49:06,920
var denne tingen her, og
en verden av kryptografi.

2123
01:49:06,920 --> 01:49:11,200
Og blant de neste problemene du selv
vil løse er kunsten kryptografi,

2124
01:49:11,200 --> 01:49:13,630
scrambling og de-scrambling
informasjon, og kryptering

2125
01:49:13,630 --> 01:49:15,930
og å tyde teksten,
og antar slutt

2126
01:49:15,930 --> 01:49:18,970
som du nå vet hva
er under panseret

2127
01:49:18,970 --> 01:49:21,860
slik at når du ser eller mottar
en melding som dette, du

2128
01:49:21,860 --> 01:49:24,060
selv kan tyde den.

2129
01:49:24,060 --> 01:49:26,740
Alt dette, og mer neste gang.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO PLAYBACK]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Nettopp kommet.

2133
01:49:32,970 --> 01:49:35,146
Jeg kommer til å gå besøk
hans college professor.

2134
01:49:35,146 --> 01:49:37,611
Jepp.

2135
01:49:37,611 --> 01:49:40,080
Hei.

2136
01:49:40,080 --> 01:49:40,660
Det er deg.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Vente!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Jeg prøver bare å finne
ut hva som skjedde med deg.

2142
01:49:56,060 --> 01:49:58,130
Vær så snill, noe kunne hjelpe.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Du var hans college
romkamerat, var du ikke?

2145
01:50:08,354 --> 01:50:10,770
Du var der med ham når
han avsluttet CS50 prosjektet?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUSIKK]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Det Var CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Jeg elsker dette stedet.

2152
01:50:44,770 --> 01:50:45,854
>> -Spise opp.

2153
01:50:45,854 --> 01:50:47,020
Vi skal ut av business.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END PLAYBACK]

