1
00:00:00,000 --> 00:00:02,970
>> [МУЗЫКА]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Малан: Хорошо.

4
00:00:15,700 --> 00:00:18,832
Это CS50 и это
является началом 2-й неделе.

5
00:00:18,832 --> 00:00:21,040
И вы помните, что более
последние пару недель,

6
00:00:21,040 --> 00:00:24,490
мы представили компьютер
наука и, в свою очередь, программирование.

7
00:00:24,490 --> 00:00:27,640
>> И мы начали рассказ путем
Царапина, что графический язык

8
00:00:27,640 --> 00:00:28,990
из медиа-лаборатории Массачусетского технологического института.

9
00:00:28,990 --> 00:00:30,780
А потом совсем недавно,
На прошлой неделе, мы сделали

10
00:00:30,780 --> 00:00:34,450
ввести higher-- A
язык более низкого уровня известны

11
00:00:34,450 --> 00:00:36,770
как С, то, что это чисто текстуально.

12
00:00:36,770 --> 00:00:39,440
И, действительно, последний раз, когда мы
изучить в этом контексте

13
00:00:39,440 --> 00:00:40,450
ряд понятий.

14
00:00:40,450 --> 00:00:43,010
>> Это, напомним, был очень
Первая программа мы рассмотрели.

15
00:00:43,010 --> 00:00:45,710
И эта программа, довольно просто,
печатает "Привет, мир."

16
00:00:45,710 --> 00:00:47,730
Но есть так много
кажущейся магии происходит.

17
00:00:47,730 --> 00:00:51,460
Там эта #include
с этих угловых скобках.

18
00:00:51,460 --> 00:00:52,170
Там в инт.

19
00:00:52,170 --> 00:00:53,020
Там в (аннулируются).

20
00:00:53,020 --> 00:00:56,330
Там в круглые скобки, фигурные скобки,
точка с запятой, и многое другое.

21
00:00:56,330 --> 00:00:58,480
>> Так, напомним, что
мы ввели Царапину

22
00:00:58,480 --> 00:01:02,110
так что мы могли бы, в идеале, увидеть прошлое
что синтаксис, материал, который действительно не

23
00:01:02,110 --> 00:01:04,590
все, что интеллектуально
интересно, но на ранних стадиях

24
00:01:04,590 --> 00:01:07,700
это, безусловно, немного сложнее
чтобы обернуть ваш разум вокруг.

25
00:01:07,700 --> 00:01:10,860
И в самом деле, одно из самых распространенных
вещи на раннем этапе в классе программирования,

26
00:01:10,860 --> 00:01:13,443
особенно для тех, кто меньше
удобно, чтобы сломаться,

27
00:01:13,443 --> 00:01:17,460
и подставляли некоторыми синтаксическими
ошибки, не говоря уже о логических ошибок.

28
00:01:17,460 --> 00:01:19,800
И поэтому среди наших целей
сегодня, на самом деле, будет

29
00:01:19,800 --> 00:01:23,280
будет оснащать вас с некоторыми
методы решения проблем для того, как

30
00:01:23,280 --> 00:01:26,705
чтобы лучше решать проблемы сами
в виде отладки.

31
00:01:26,705 --> 00:01:29,330
И вы помните, тоже, что
среда, мы ввели

32
00:01:29,330 --> 00:01:31,780
последний раз был назван CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Это веб-программное обеспечение,
позволяет программировать в облаке,

34
00:01:34,850 --> 00:01:38,450
так сказать, сохраняя при этом все ваши
файлы вместе, как мы снова будем сегодня.

35
00:01:38,450 --> 00:01:41,480
И напомним, что мы
пересмотреть эти темы здесь,

36
00:01:41,480 --> 00:01:44,480
среди них функций, а также петли, и
переменные и логические выражения,

37
00:01:44,480 --> 00:01:45,110
и условия.

38
00:01:45,110 --> 00:01:49,190
И на самом деле несколько больше, что мы
в переводе с нуля мира

39
00:01:49,190 --> 00:01:50,800
к миру C.

40
00:01:50,800 --> 00:01:53,220
>> Но основное здание
блоки, так сказать,

41
00:01:53,220 --> 00:01:55,150
действительно были все те же на прошлой неделе.

42
00:01:55,150 --> 00:01:57,900
На самом деле, мы действительно только имели
разные кусок головоломки, если вы будете.

43
00:01:57,900 --> 00:02:00,300
Вместо того, что фиолетовый
сохранить блок, мы вместо того, чтобы

44
00:02:00,300 --> 00:02:02,940
был PRINTF, который
эта функция в С,

45
00:02:02,940 --> 00:02:05,890
позволяет напечатать что-нибудь
и отформатировать его на экране.

46
00:02:05,890 --> 00:02:07,950
Мы ввели CS50
Библиотека, где вы

47
00:02:07,950 --> 00:02:11,420
есть сейчас в вашем распоряжении get_char,
и get_int и get_string,

48
00:02:11,420 --> 00:02:14,610
и несколько других функций, как
ну, с помощью которого вы можете получить ввод

49
00:02:14,610 --> 00:02:16,260
от собственной клавиатуры пользователя.

50
00:02:16,260 --> 00:02:20,640
И мы также взяли взгляд на вещи
как these- BOOL и полукокса,

51
00:02:20,640 --> 00:02:22,490
и двойные, с плавающей точкой,
INT, long_long строка.

52
00:02:22,490 --> 00:02:25,170
И есть даже другие типы данных в C.

53
00:02:25,170 --> 00:02:28,560
>> Другими словами, когда вы объявляете
переменная для хранения некоторого значения,

54
00:02:28,560 --> 00:02:32,600
или при реализации функции
которая возвращает некоторое значение,

55
00:02:32,600 --> 00:02:35,290
Вы можете указать, что
тип значения, которое.

56
00:02:35,290 --> 00:02:37,310
Это строка, подобно
последовательность символов?

57
00:02:37,310 --> 00:02:39,490
Это число, как целое число?

58
00:02:39,490 --> 00:02:41,390
Является ли это с плавающей точкой
значение, или тому подобное?

59
00:02:41,390 --> 00:02:46,180
Таким образом, в C, в отличие от нуля, мы на самом деле
начал указывать, какой тип данных

60
00:02:46,180 --> 00:02:48,330
мы возвращались или использования.

61
00:02:48,330 --> 00:02:51,910
>> Но, конечно, мы также столкнулись с
некоторые фундаментальные пределы вычислений.

62
00:02:51,910 --> 00:02:54,100
И в частности,
этот язык C, напомним

63
00:02:54,100 --> 00:02:57,070
что мы смотрели на
Целочисленное переполнение, реальность

64
00:02:57,070 --> 00:03:00,460
что если у вас есть только
конечное количество памяти

65
00:03:00,460 --> 00:03:04,600
или, в частности, конечное число
битов, вы можете рассчитывать только так высоко.

66
00:03:04,600 --> 00:03:08,460
И таким образом, мы смотрели на этот пример здесь
в результате чего счетчик в самолете,,

67
00:03:08,460 --> 00:03:13,510
на самом деле, если работает достаточно долго будет
переполнение и результат в программном обеспечении

68
00:03:13,510 --> 00:03:15,560
фактический физический потенциал ошибки.

69
00:03:15,560 --> 00:03:18,600
>> Мы также рассмотрели плавающей
точка неточностей, реальность

70
00:03:18,600 --> 00:03:22,280
что только с конечным числом
битов, будь то 32 или 64,

71
00:03:22,280 --> 00:03:27,330
вы можете указать только так много чисел
после десятичной точки, после чего вы

72
00:03:27,330 --> 00:03:29,110
начинают получать неточным.

73
00:03:29,110 --> 00:03:32,360
Так, например, одна треть в
мир здесь, в нашем человеческом мире,

74
00:03:32,360 --> 00:03:35,360
мы знаем, это просто бесконечное число
3 сек после десятичной точки.

75
00:03:35,360 --> 00:03:38,820
Но компьютер не обязательно
представляют собой бесконечное число цифр

76
00:03:38,820 --> 00:03:42,590
если вы только дайте ему некоторые
конечное количество информации.

77
00:03:42,590 --> 00:03:45,900
>> Так что мы не только вооружить вас
с большей силой в плане

78
00:03:45,900 --> 00:03:49,280
как Вы могли бы выразить себя в
клавиатура с точки зрения программирования,

79
00:03:49,280 --> 00:03:51,430
мы также ограничены, что
вы можете реально сделать.

80
00:03:51,430 --> 00:03:55,790
И в самом деле, ошибки и ошибки могут
возникают из этих видов вопросов.

81
00:03:55,790 --> 00:03:59,900
И действительно, среди тем сегодня
будут такие темы, как отладки

82
00:03:59,900 --> 00:04:03,699
и на самом деле, глядя под капотом
на то, как были введены вещи на прошлой неделе

83
00:04:03,699 --> 00:04:05,490
на самом деле реализованы
так что вам лучше

84
00:04:05,490 --> 00:04:10,530
понять, как возможностей и
ограничения языка как C.

85
00:04:10,530 --> 00:04:14,770
>> И в самом деле, мы отогните слои
из простейших структуры данных,

86
00:04:14,770 --> 00:04:17,756
то, что называется массив, который
Царапина случается называть "список."

87
00:04:17,756 --> 00:04:19,589
Это немного
отличается в этом контексте.

88
00:04:19,589 --> 00:04:23,340
И тогда мы будем также ввести одно из
первый из наших проблем предметно-ориентированных

89
00:04:23,340 --> 00:04:26,790
в CS50, мир
криптография, искусство карабкаться

90
00:04:26,790 --> 00:04:29,650
или в шифровании информации, так
что вы можете отправлять секретные сообщения

91
00:04:29,650 --> 00:04:34,520
и декодировать секретные сообщения
между двумя лицами, А и В.

92
00:04:34,520 --> 00:04:37,490
>> Поэтому, прежде чем мы перехода
к этому новому миру,

93
00:04:37,490 --> 00:04:42,059
давайте попробуем снабдить вас с некоторыми
методы, с которыми вы можете устранить

94
00:04:42,059 --> 00:04:43,850
или уменьшить по крайней мере, некоторые
разочарований

95
00:04:43,850 --> 00:04:46,630
что вы, вероятно, сталкивались
Только за прошедшую неделю.

96
00:04:46,630 --> 00:04:50,830
На самом деле, впереди вас such-- некоторые из
ваши первые проблемы в С и форы,

97
00:04:50,830 --> 00:04:54,010
если вы похожи на меня, в первый раз
вы пытаетесь впечатать программу,

98
00:04:54,010 --> 00:04:57,330
даже если вы думаете, логически
Программа довольно проста,

99
00:04:57,330 --> 00:05:01,200
вы можете очень хорошо врезался в стену, и
компилятор не собирается сотрудничать.

100
00:05:01,200 --> 00:05:03,940
Делают или Clang не собирается
на самом деле сделать ваши ставки.

101
00:05:03,940 --> 00:05:05,450
>> И почему это может быть?

102
00:05:05,450 --> 00:05:07,950
Что ж, давайте посмотрим на,
может быть, простая программа.

103
00:05:07,950 --> 00:05:11,190
Я собираюсь идти вперед и сохранить это в
файл намеренно называют buggy0.c,

104
00:05:11,190 --> 00:05:13,590
потому что я знаю его
быть испорчен заранее.

105
00:05:13,590 --> 00:05:17,400
Но я не мог понять, что если это
первый или второй или третьей программы

106
00:05:17,400 --> 00:05:18,830
что я на самом деле делает сам.

107
00:05:18,830 --> 00:05:23,820
Так что я собираюсь идти вперед и
впечатать, Int основной (вакуум).

108
00:05:23,820 --> 00:05:28,130
И тогда внутри моих фигурные скобки,
очень знакомый ( "привет, world--

109
00:05:28,130 --> 00:05:30,980
обратной косой черты, п ") - и точка с запятой.

110
00:05:30,980 --> 00:05:32,360
>> Я сохранил файл.

111
00:05:32,360 --> 00:05:34,850
Теперь я собираюсь пойти вниз
к моему окне терминала

112
00:05:34,850 --> 00:05:40,340
и тип делают buggy0, потому что, опять же,
имя файла сегодня buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Так что я типа сделать buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> И, о, господи, помните из последнего времени
что без каких-либо сообщений об ошибках это хорошая вещь.

115
00:05:48,200 --> 00:05:49,740
Так что вывод не является хорошей вещью.

116
00:05:49,740 --> 00:05:52,920
Но здесь я ясно
некоторое количество ошибок.

117
00:05:52,920 --> 00:05:56,470
>> Таким образом, в первой строке вывода
после ввода делают buggy0, напомним,

118
00:05:56,470 --> 00:05:59,540
довольно подробный вывод звоном в.

119
00:05:59,540 --> 00:06:02,067
Под капотом,
CS50 IDE настроен

120
00:06:02,067 --> 00:06:04,150
использовать целую кучу
Варианты с этим компилятором

121
00:06:04,150 --> 00:06:05,941
так что у вас нет
думать о них.

122
00:06:05,941 --> 00:06:08,840
И это все, что первая линия
означает, что начинается с Clang.

123
00:06:08,840 --> 00:06:11,720
>> Но после этого, проблемы
начать делать их внешний вид.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c на линии 3, характер
5, есть большая, красная ошибка.

125
00:06:17,390 --> 00:06:18,380
Что это?

126
00:06:18,380 --> 00:06:23,562
Косвенно объявляя функции библиотеки
PRINTF с типом Int (сопзЬ сЬаг *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Я имею в виду, это очень быстро
становится очень аркан.

129
00:06:28,379 --> 00:06:30,170
И, конечно же, в первую очередь
взгляд, мы не будем

130
00:06:30,170 --> 00:06:32,380
ожидают, что вы понимаете
полнота этого сообщения.

131
00:06:32,380 --> 00:06:34,213
И вот один из уроков
на сегодняшний день происходит

132
00:06:34,213 --> 00:06:36,919
чтобы попытаться заметить
узоры, или подобные вещи,

133
00:06:36,919 --> 00:06:38,960
к ошибкам вы можете иметь
столкнулись в прошлом.

134
00:06:38,960 --> 00:06:41,335
Так что давайте дразнить только друг от друга
те слова, которые выглядят знакомыми.

135
00:06:41,335 --> 00:06:44,290
Большой, красный ошибка явно
символом чего-то ошибиться.

136
00:06:44,290 --> 00:06:47,940
>> безоговорочное признание
Библиотека функций Printf.

137
00:06:47,940 --> 00:06:51,680
Так что даже если я не совсем понимаю, что
неявно объявляя функции библиотеки

138
00:06:51,680 --> 00:06:54,900
Значит, проблема, конечно,
относится к PRINTF каким-то образом.

139
00:06:54,900 --> 00:06:59,130
И источник этого вопроса
имеет дело с объявив его.

140
00:06:59,130 --> 00:07:02,440
>> Объявление функции является
упоминания о нем в первый раз.

141
00:07:02,440 --> 00:07:06,210
И мы использовали терминологию на прошлой неделе
того, чтобы объявить прототип функции во,

142
00:07:06,210 --> 00:07:11,860
либо с одной линией в верхней части вашего
собственный файл или в так называемом файле заголовка.

143
00:07:11,860 --> 00:07:15,300
И в каком файле сделал мы говорим
на прошлой неделе, что Printf цитата,

144
00:07:15,300 --> 00:07:17,080
Unquote, заявил?

145
00:07:17,080 --> 00:07:20,950
В каком файле находится его прототип?

146
00:07:20,950 --> 00:07:24,640
>> Так что, если вы помните, самое первое, что я
типизированных, почти каждая программа в прошлом time--

147
00:07:24,640 --> 00:07:30,790
и случайно минуту назад началась
набрав myself-- был один here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- для
вход / output-- точка ч И действительно,

149
00:07:38,630 --> 00:07:41,860
если я теперь сохранить этот файл, я собираюсь
идти вперед и очистить экран,

150
00:07:41,860 --> 00:07:44,740
которые вы можете сделать, введя
Ясно, или вы можете держать управления L,

151
00:07:44,740 --> 00:07:47,680
просто очистить окно терминала
просто чтобы устранить некоторые помехи.

152
00:07:47,680 --> 00:07:51,370
>> Я собираюсь идти вперед и
повторно типа делают buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
И вуаля, я до сих пор вижу, что
долгое время команда из Clang,

154
00:07:53,790 --> 00:07:55,470
но нет никакого сообщения об ошибке на этот раз.

155
00:07:55,470 --> 00:07:58,800
И в самом деле, если я ./buggy0,
так же, как в прошлый раз,

156
00:07:58,800 --> 00:08:01,860
где точка означает это
каталог, Слэш просто означает,

157
00:08:01,860 --> 00:08:05,040
здесь идет название программы и
что название программы buggy0,

158
00:08:05,040 --> 00:08:07,340
Введите, "Привет, мир."

159
00:08:07,340 --> 00:08:09,440
>> Теперь, как вы, возможно,
почерпнутые это решение

160
00:08:09,440 --> 00:08:12,017
не обязательно
признавая, как много слов,

161
00:08:12,017 --> 00:08:14,350
как и я, конечно же, имея
сделали это в течение многих лет?

162
00:08:14,350 --> 00:08:18,720
Ну, реализовать в первой задаче
набор, мы познакомим вас с командой

163
00:08:18,720 --> 00:08:21,175
что собственный персонал CS50 в
написал под названием help50.

164
00:08:21,175 --> 00:08:24,300
И в самом деле, C делает спецификацию
проблема установить относительно того, как использовать эту функцию.

165
00:08:24,300 --> 00:08:27,210
>> Но, по существу, help50
программа, которая сотрудники CS50 в

166
00:08:27,210 --> 00:08:30,850
писал, что позволяет запускать
команда или запустить программу,

167
00:08:30,850 --> 00:08:36,169
и если вы не понимаете его
выход, чтобы передать свой выход help50,

168
00:08:36,169 --> 00:08:38,890
и в этот момент программное обеспечение
что сотрудники конечно писал

169
00:08:38,890 --> 00:08:42,429
будет выглядеть на выходе вашей программы
строка за строкой, по одному символу.

170
00:08:42,429 --> 00:08:46,000
И если мы, сотрудники, признают
сообщение об ошибке, что вы испытываете,

171
00:08:46,000 --> 00:08:50,580
мы будем стараться, чтобы спровоцировать вас с некоторыми
риторические вопросы, с некоторыми советами,

172
00:08:50,580 --> 00:08:54,890
так же, как TF или CA или себя
будет делать лично в рабочее время.

173
00:08:54,890 --> 00:08:58,320
>> Так что смотрите, чтобы help50, если вы этого не сделаете
обязательно признают проблему.

174
00:08:58,320 --> 00:09:00,790
Но не полагаться на него
слишком много, как костыль.

175
00:09:00,790 --> 00:09:03,990
Конечно, попытаться понять его
вывода, а затем извлечь из него

176
00:09:03,990 --> 00:09:07,571
так что только один или два раза не так ли
когда-либо запустить help50 для конкретной ошибки

177
00:09:07,571 --> 00:09:08,070
сообщение.

178
00:09:08,070 --> 00:09:10,660
После этого, вы должны быть
лучше оснащены себя

179
00:09:10,660 --> 00:09:13,180
чтобы выяснить, что это на самом деле.

180
00:09:13,180 --> 00:09:14,350
>> Давайте сделаем один другой здесь.

181
00:09:14,350 --> 00:09:20,410
Позвольте мне идти вперед, а в другом
файл, который мы будем называть этот buggy1.c.

182
00:09:20,410 --> 00:09:23,110
И в этом файле я
собирается deliberately--

183
00:09:23,110 --> 00:09:26,330
но делать вид, что я не делаю
понять, что ошибка, которую я сделал.

184
00:09:26,330 --> 00:09:31,420
>> Я собираюсь идти вперед и делать this--
#include, так как я

185
00:09:31,420 --> 00:09:33,660
узнал, что мой урок из минуту назад.

186
00:09:33,660 --> 00:09:36,220
Int основных (недействительными), как и раньше.

187
00:09:36,220 --> 00:09:40,880
И тогда здесь я иду
сделать строку с - get_string.

188
00:09:40,880 --> 00:09:43,770
И помните из последнего времени,
это означает, эй, компьютер,

189
00:09:43,770 --> 00:09:48,280
дайте мне переменную, называем это S, и
сделать тип этой переменной строковым

190
00:09:48,280 --> 00:09:50,150
так что я могу хранить одно или несколько слов в нем.

191
00:09:50,150 --> 00:09:52,191
>> А потом на правой руке
сторона знака равенства

192
00:09:52,191 --> 00:09:54,980
является get_string, которая является
функция в библиотеке CS50

193
00:09:54,980 --> 00:09:55,980
что делает именно это.

194
00:09:55,980 --> 00:09:59,740
Он получает функцию, а затем
руки его справа налево.

195
00:09:59,740 --> 00:10:02,670
Так что этот знак равенства не означает,
"Равно", как мы могли бы думать в математике.

196
00:10:02,670 --> 00:10:04,750
Это означает назначение справа налево.

197
00:10:04,750 --> 00:10:09,640
Таким образом, это означает, взять строку из
пользователь и хранить его внутри с.

198
00:10:09,640 --> 00:10:10,460
>> Теперь давайте использовать его.

199
00:10:10,460 --> 00:10:13,820
Позвольте мне идти вперед сейчас и в качестве второго
линия, позвольте мне идти вперед и сказать "привет" -

200
00:10:13,820 --> 00:10:19,330
не "мир", но "Привет,% S--
которая является нашим заполнителем, запятая s,

201
00:10:19,330 --> 00:10:22,030
которая является нашей переменной,
а затем точка с запятой.

202
00:10:22,030 --> 00:10:26,070
Так что, если я не завинчивать слишком много
здесь, это выглядит как правильный код.

203
00:10:26,070 --> 00:10:28,090
>> И мои инстинкты теперь скомпилировать его.

204
00:10:28,090 --> 00:10:30,400
Файл называется buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Так что я собираюсь сделать сделать buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
И штопать-то, если нет
даже больше ошибок, чем раньше.

207
00:10:36,377 --> 00:10:38,210
Я имею в виду, есть больше
Сообщения об ошибках это было

208
00:10:38,210 --> 00:10:40,400
кажется, чем фактические линии в этой программе.

209
00:10:40,400 --> 00:10:42,730
>> Но еда на дом здесь,
даже если вы перегружены

210
00:10:42,730 --> 00:10:45,040
с двумя или тремя или
еще четыре сообщения об ошибках,

211
00:10:45,040 --> 00:10:48,340
фокус всегда на очень
Первый из этих сообщений.

212
00:10:48,340 --> 00:10:52,220
Глядя на самый верхний один,
прокрутки обратно вверх, как это будет необходимо.

213
00:10:52,220 --> 00:10:53,930
Так вот я напечатал косметику buggy1.

214
00:10:53,930 --> 00:10:55,700
Вот что выход Clang, как и ожидалось.

215
00:10:55,700 --> 00:10:57,290
>> И вот первая красная ошибка.

216
00:10:57,290 --> 00:11:02,370
Использование необъявленной идентификатора
Строка, я имею в виду стандарт в?

217
00:11:02,370 --> 00:11:04,260
Так стандарт является
на самом деле что-то другое.

218
00:11:04,260 --> 00:11:06,240
Это относится к пользователя
клавиатура, по существу.

219
00:11:06,240 --> 00:11:08,080
>> Но это не то, что я имел в виду.

220
00:11:08,080 --> 00:11:11,770
Я имел в виду строку, и я имел в виду get_string.

221
00:11:11,770 --> 00:11:16,200
Так что же это, что я
забыл сделать на этот раз?

222
00:11:16,200 --> 00:11:20,230
Чего не хватает на этот раз?

223
00:11:20,230 --> 00:11:23,600
У меня есть #include,
поэтому у меня есть доступ к Printf.

224
00:11:23,600 --> 00:11:26,090
>> Но что у меня нет
доступ к только что еще?

225
00:11:26,090 --> 00:11:29,420
Ну, так же, как в прошлый раз,
Я должен сказать компилятор

226
00:11:29,420 --> 00:11:31,691
Лязгом, что эти функции.

227
00:11:31,691 --> 00:11:33,940
Get_string не приходит
с С. И в частности, его

228
00:11:33,940 --> 00:11:38,160
не приходит в
заголовка файла.

229
00:11:38,160 --> 00:11:40,770
Вместо этого он приходит в
что-то сотрудники писали,

230
00:11:40,770 --> 00:11:44,176
который представляет собой другой файл
имя, но метко назвал.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Так, просто добавив, что одной линии
из code-- отзыва от последнего времени

233
00:11:50,861 --> 00:11:53,610
что при запуске Clang, это будет
посмотреть на мой код сверху вниз,

234
00:11:53,610 --> 00:11:54,193
слева направо.

235
00:11:54,193 --> 00:11:57,200
Это будет заметить,
Ах, вы хотите.

236
00:11:57,200 --> 00:11:59,900
Позвольте мне пойти и найти, что,
везде, где он находится на сервере,

237
00:11:59,900 --> 00:12:03,090
скопировать и вставить его, по существу,
в верхней части вашего собственного файла

238
00:12:03,090 --> 00:12:06,820
так что в этот момент в истории,
линия 1, остальная часть программы

239
00:12:06,820 --> 00:12:11,651
может, в самом деле, можно использовать любой из функций
в нем, среди них get_string.

240
00:12:11,651 --> 00:12:13,650
Так что я собираюсь игнорировать
остальные из этих ошибок,

241
00:12:13,650 --> 00:12:17,190
потому что я, в самом деле, подозреваю, что только
первый на самом деле имело значение.

242
00:12:17,190 --> 00:12:20,780
И я собираюсь идти вперед и перекладка,
после сохранения моего файла сделать buggy1.

243
00:12:20,780 --> 00:12:22,580
И вуаля, он сделал работу.

244
00:12:22,580 --> 00:12:29,200
А если я ./buggy1 и введите, для
экземпляр, Zamyla, я теперь получить привет,

245
00:12:29,200 --> 00:12:32,000
Zamyla, а не привет, мир.

246
00:12:32,000 --> 00:12:32,550
>> Отлично.

247
00:12:32,550 --> 00:12:35,890
Так вот тогда вынос должны,
один, старайтесь подбирать столько, сколько вы можете

248
00:12:35,890 --> 00:12:39,140
от сообщений об ошибках в одиночку, глядя
на некоторых из распознаваемых слов.

249
00:12:39,140 --> 00:12:43,070
Если исключить, что использовать help50 за
проблема установить спецификации.

250
00:12:43,070 --> 00:12:46,500
Но за исключением этого тоже, всегда обращайте внимание
только в верхней ошибки, по крайней мере,

251
00:12:46,500 --> 00:12:50,051
на начальном этапе, чтобы увидеть, какую информацию
он может на самом деле выход.

252
00:12:50,051 --> 00:12:52,300
Но оказывается, что есть
даже больше функциональных возможностей встроенной

253
00:12:52,300 --> 00:12:55,030
в библиотеку CS50, чтобы помочь
вы на раннем этапе в семестр

254
00:12:55,030 --> 00:12:57,580
и на ранней стадии в программировании
выяснить, что происходит не так.

255
00:12:57,580 --> 00:12:59,840
Так давайте сделаем еще один пример.

256
00:12:59,840 --> 00:13:04,350
Я буду называть это buggy2, который,
опять же, будет испорчен из

257
00:13:04,350 --> 00:13:05,650
ворот, по дизайну.

258
00:13:05,650 --> 00:13:09,980
>> И я собираюсь идти вперед
и делать #include.

259
00:13:09,980 --> 00:13:12,580
А потом я собираюсь сделать Int основной (вакуум).

260
00:13:12,580 --> 00:13:14,840
А потом я собираюсь сделать цикл.

261
00:13:14,840 --> 00:13:16,690
Для (INT I _ 0.

262
00:13:16,690 --> 00:13:18,750
Я меньше или равно 10.

263
00:13:18,750 --> 00:13:24,260
я ++, а затем в фигурные скобки, я иду
распечатать только символ хэштегом здесь

264
00:13:24,260 --> 00:13:25,920
и символ новой строки.

265
00:13:25,920 --> 00:13:29,220
>> Таким образом, мое намерение с этим
Программа достаточно просто

266
00:13:29,220 --> 00:13:33,150
итерацию в 10 раз
и на каждой итерации

267
00:13:33,150 --> 00:13:35,260
из этого цикла каждый раз
через цикл,

268
00:13:35,260 --> 00:13:37,660
распечатать хэштегом,
хэштегом, хэштегом.

269
00:13:37,660 --> 00:13:40,480
По одному в строке, потому что я
имеют новую линию там.

270
00:13:40,480 --> 00:13:42,787
И напомним, что для
петля, за последний week--

271
00:13:42,787 --> 00:13:44,620
и вы получите больше
знакомый с синтаксисом

272
00:13:44,620 --> 00:13:47,170
используя его с практикой
Перед long-- это дает мне

273
00:13:47,170 --> 00:13:49,740
переменная называется I и устанавливает его в 0.

274
00:13:49,740 --> 00:13:52,650
>> Это увеличивает I на
каждой итерации на 1.

275
00:13:52,650 --> 00:13:54,940
Так что я идет к 1 до 2 до 3.

276
00:13:54,940 --> 00:13:57,690
И тогда это условие в
посередине между точками с запятой

277
00:13:57,690 --> 00:14:03,010
получает проверяется на каждой итерации, чтобы сделать
уверен, что мы все еще в пределах диапазона.

278
00:14:03,010 --> 00:14:06,830
Так что я хочу итерацию в 10 раз, так что я
имеют вид очень интуитивно просто

279
00:14:06,830 --> 00:14:09,070
положить 10, как моя верхняя граница там.

280
00:14:09,070 --> 00:14:14,310
>> И все же, когда я запускаю это, после того, как
компиляции с указанием марки buggy2--

281
00:14:14,310 --> 00:14:15,440
и она компилируется ОК.

282
00:14:15,440 --> 00:14:17,980
Так что я не имеют
ошибка синтаксиса в этот раз.

283
00:14:17,980 --> 00:14:20,940
Позвольте мне идти вперед прямо сейчас
и запустить buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
А теперь выполните прокрутку вверх.

285
00:14:22,620 --> 00:14:24,890
И позвольте мне увеличить
размер окна.

286
00:14:24,890 --> 00:14:33,720
>> Я, кажется, есть 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Так что 11 хештегов, несмотря на то,
Я четко поставил 10 внутри этого цикла.

288
00:14:38,891 --> 00:14:42,140
Теперь, некоторые из вас могут увидеть сразу
что ошибка происходит потому, что, в самом деле, это

289
00:14:42,140 --> 00:14:43,720
это не очень трудно ошибка сделать.

290
00:14:43,720 --> 00:14:46,070
Но это очень часто
сделал очень рано.

291
00:14:46,070 --> 00:14:49,820
>> То, что я хочу отметить, однако,
в том, как я мог бы понять это?

292
00:14:49,820 --> 00:14:52,300
Что ж, получается, что
CS50 библиотека приходит

293
00:14:52,300 --> 00:14:55,380
с не только get_string и get_int
и get_float и другие функции.

294
00:14:55,380 --> 00:14:59,980
Он также поставляется со специальной функцией
называется eprintf, или, ошибка Printf.

295
00:14:59,980 --> 00:15:03,270
И существует только сделать
это немного проще для вас

296
00:15:03,270 --> 00:15:06,310
при отладке кода просто
выводит сообщение об ошибке на экране

297
00:15:06,310 --> 00:15:07,850
и знаю, откуда она взялась.

298
00:15:07,850 --> 00:15:11,000
>> Так, например, одна вещь, которую я мог бы
здесь делать с этой функцией является this--

299
00:15:11,000 --> 00:15:20,230
eprintf, а затем я собираюсь идти вперед
и сказать, что я теперь% я, обратный слэш, п.

300
00:15:20,230 --> 00:15:22,330
И я собираюсь подключить к значению I.

301
00:15:22,330 --> 00:15:25,400
И наверху, потому что этот
находится в библиотеке CS50,

302
00:15:25,400 --> 00:15:27,580
Я собираюсь идти вперед
и включают в себя

303
00:15:27,580 --> 00:15:29,169
поэтому у меня есть доступ к этой функции.

304
00:15:29,169 --> 00:15:31,460
Но давайте рассмотрим, что линия
9 предполагается делать.

305
00:15:31,460 --> 00:15:32,670
Я собираюсь удалить это в конце концов.

306
00:15:32,670 --> 00:15:34,670
Это не имеет ничего общего
с моей главной цели.

307
00:15:34,670 --> 00:15:39,090
Но eprintf, ошибка Printf, просто означает,
чтобы дать мне некоторую диагностическую информацию.

308
00:15:39,090 --> 00:15:42,460
Когда я запускаю мою программу, я хочу
увидеть это на экране временно

309
00:15:42,460 --> 00:15:44,550
а просто понять,
что происходит.

310
00:15:44,550 --> 00:15:47,330
>> И в самом деле, на каждом
итерация здесь линии 9

311
00:15:47,330 --> 00:15:49,260
Я хочу видеть, какова величина I?

312
00:15:49,260 --> 00:15:50,290
Что такое значение I?

313
00:15:50,290 --> 00:15:51,280
Что такое значение I?

314
00:15:51,280 --> 00:15:55,650
И, надеюсь, я должен только
видеть, что сообщение, кроме того, в 10 раз.

315
00:15:55,650 --> 00:15:57,780
>> Итак, позвольте мне идти вперед и
перекомпилировать мою программу,

316
00:15:57,780 --> 00:15:59,905
как я должен делать в любое время
Я внести изменения. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
И now-- OK.

319
00:16:03,640 --> 00:16:04,820
Там очень много больше происходит.

320
00:16:04,820 --> 00:16:07,610
Итак, позвольте мне пролистать вверх
еще большее окно.

321
00:16:07,610 --> 00:16:10,190
>> И вы увидите, что каждый из
Hashtags по-прежнему печати.

322
00:16:10,190 --> 00:16:15,270
Но между каждым из них в настоящее время этот
диагностический вывод отформатирован следующим образом.

323
00:16:15,270 --> 00:16:17,960
Название моей программы здесь является buggy2.

324
00:16:17,960 --> 00:16:20,432
Имя файла buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Номер строки, из которой
это было напечатано в строке 9.

326
00:16:24,080 --> 00:16:27,500
А потом справа, что является
сообщение об ошибке, что я ожидал.

327
00:16:27,500 --> 00:16:30,701
>> И что приятно об этом заключается в том, что
Теперь я не должен обязательно рассчитывать

328
00:16:30,701 --> 00:16:32,200
в моей голове, что моя программа делает.

329
00:16:32,200 --> 00:16:34,240
Я вижу, что на
Первая итерация я = 0,

330
00:16:34,240 --> 00:16:39,420
затем 1, затем 2, затем 3, затем 4, затем
5, затем 6, затем 7, затем 8, то 9, то,

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Так, подождите минуту.

333
00:16:42,050 --> 00:16:43,740
Что тут происходит?

334
00:16:43,740 --> 00:16:48,190
Я до сих пор, кажется, считая
как задумано до 10.

335
00:16:48,190 --> 00:16:50,550
>> Но где же мне начать?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Таким образом, 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11-й палец

338
00:16:58,040 --> 00:16:59,990
свидетельствует о проблеме.

339
00:16:59,990 --> 00:17:02,850
Я, кажется, подсчитали
неправильно в моем цикле.

340
00:17:02,850 --> 00:17:06,599
Вместо того, чтобы идти 10 итераций,
Я начиная с 0,

341
00:17:06,599 --> 00:17:09,550
Я и заканчивая через 10.

342
00:17:09,550 --> 00:17:12,030
Но, так как, как компьютер,
Я начинаю отсчет с 0,

343
00:17:12,030 --> 00:17:15,250
Я должен быть подсчитывая
до, но не до конца, 10.

344
00:17:15,250 --> 00:17:18,510
>> И поэтому исправление, я в конце концов
здесь реализуется, является одной из двух вещей.

345
00:17:18,510 --> 00:17:22,430
Я мог бы очень просто сказать,
сосчитать до менее 10.

346
00:17:22,430 --> 00:17:27,260
Таким образом, 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, которая является, по сути, верно,

347
00:17:27,260 --> 00:17:28,900
несмотря на то, что это звучит немного неправильно.

348
00:17:28,900 --> 00:17:35,070
Или я мог бы сделать меньше или равно
до 9, до тех пор, как я начинаю с 0.

349
00:17:35,070 --> 00:17:40,056
Или, если вы действительно не нравится, что ты
может рассчитывать через 10, но начинаются с 1.

350
00:17:40,056 --> 00:17:41,680
Но опять же, это просто не так часто.

351
00:17:41,680 --> 00:17:43,977
В programming-- хотя и
не столько в Scratch--

352
00:17:43,977 --> 00:17:45,810
но при программировании в
C и других языках,

353
00:17:45,810 --> 00:17:47,670
как JavaScript и
Python и другие, это

354
00:17:47,670 --> 00:17:49,880
просто очень часто для
наше обсуждение бинарная

355
00:17:49,880 --> 00:17:53,450
чтобы просто начать отсчет на
наименьшее число вы можете, что 0.

356
00:17:53,450 --> 00:17:53,950
Отлично.

357
00:17:53,950 --> 00:17:55,160
Так вот eprintf.

358
00:17:55,160 --> 00:17:58,600
И опять же, теперь, когда я понял, что я
Проблема, и я собираюсь вернуться к 0

359
00:17:58,600 --> 00:18:01,470
через менее чем 10, я собираюсь
пойти и удалить eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Оно не должно быть там, когда я
отправить мой код или отправить свой код

361
00:18:04,580 --> 00:18:05,800
или показать его кому-либо еще.

362
00:18:05,800 --> 00:18:07,980
Это действительно просто имел в виду
которые будут использоваться временно.

363
00:18:07,980 --> 00:18:11,650
Но теперь я это исправил
Особой проблемой, а также.

364
00:18:11,650 --> 00:18:16,780
>> Что ж, давайте сделаем еще один пример здесь
что я буду нагнетать следующим образом.

365
00:18:16,780 --> 00:18:22,850
Я собираюсь идти вперед и
#включают . $ 50

366
00:18:22,850 --> 00:18:25,580
И я собираюсь идти вперед
и #include.

367
00:18:25,580 --> 00:18:29,030
>> И я собираюсь сохранить
этот файл в качестве buggy3.c.

368
00:18:29,030 --> 00:18:31,740
И я собираюсь идти вперед
и объявить Int основной (вакуум).

369
00:18:31,740 --> 00:18:34,186
А потом внутри там
Я собираюсь сделать INT I _ -

370
00:18:34,186 --> 00:18:36,435
Я хочу, чтобы реализовать программу
с get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Это не функция, которая существует до сих пор.

373
00:18:40,770 --> 00:18:42,870
Итак, мы собираемся реализовать
это всего мгновение.

374
00:18:42,870 --> 00:18:45,541
Но мы будем видеть, почему
он ошибочен на первом проходе.

375
00:18:45,541 --> 00:18:47,290
И как только я получил
вызовите прерывание от пользователя,

376
00:18:47,290 --> 00:18:53,365
Я просто хочу, чтобы напечатать% I является отрицательным
целым числом, обратной косой черты, п, запятая, я.

377
00:18:53,365 --> 00:18:55,240
Другими словами, все, что я
хочу эту программу, чтобы сделать

378
00:18:55,240 --> 00:18:58,000
это получить отрицательное Int из
пользователь, а затем распечатать

379
00:18:58,000 --> 00:18:59,980
что такой негативный Int.

380
00:18:59,980 --> 00:19:02,080
>> Теперь мне нужно реализовать эту функцию.

381
00:19:02,080 --> 00:19:05,740
Так что позже в моем файле, я собираюсь пойти
вперед и объявить функцию под названием

382
00:19:05,740 --> 00:19:10,670
get_negative_int (пустота) - и мы
вернуться к тому, что означает, что линия снова

383
00:19:10,670 --> 00:19:18,790
в moment-- Int N; do-- делать
following-- Printf п :.

384
00:19:18,790 --> 00:19:26,210
А потом я собираюсь сделать п - get_int,
и сделать это в то время как п больше 0.

385
00:19:26,210 --> 00:19:28,310
А потом вернуться п ;.

386
00:19:28,310 --> 00:19:31,730
>> Так что есть много происходит в
не это, но ни один из которых мы не делали

387
00:19:31,730 --> 00:19:33,710
посмотрите на последнюю неделю, по крайней мере, на короткое время.

388
00:19:33,710 --> 00:19:36,980
Так что в строке 10 здесь я объявлен
Функция называется get_negative_int,

389
00:19:36,980 --> 00:19:39,620
и я поставил (пустота), в
круглые скобки, по той причине, это

390
00:19:39,620 --> 00:19:40,950
не принимает входной сигнал.

391
00:19:40,950 --> 00:19:42,910
Я ничего не пропуская
к этой функции.

392
00:19:42,910 --> 00:19:44,690
Я просто получаю что-то от него.

393
00:19:44,690 --> 00:19:47,270
>> А что я надеюсь
получить обратно целое.

394
00:19:47,270 --> 00:19:50,040
Там нет тип данных
C называется negative_int.

395
00:19:50,040 --> 00:19:52,880
Это просто Int, так что это будет
чтобы быть на нас, чтобы убедиться,

396
00:19:52,880 --> 00:19:55,340
что значение, которое на самом деле
Возвращается не только INT

397
00:19:55,340 --> 00:19:56,380
но также отрицательно.

398
00:19:56,380 --> 00:20:02,150
>> В строке 12 я объявляю переменную
называется п и делает его типа Int.

399
00:20:02,150 --> 00:20:07,500
А затем в строке 13 до 18 Я
делать что-то в то время как-то верно.

400
00:20:07,500 --> 00:20:11,040
Я иду вперед и печать
п, двоеточие, а затем пробел,

401
00:20:11,040 --> 00:20:12,800
как подсказку для пользователя.

402
00:20:12,800 --> 00:20:16,410
>> Я затем вызвать get_int и
хранить его так называемое возвращаемое значение

403
00:20:16,410 --> 00:20:18,130
в этой переменной п.

404
00:20:18,130 --> 00:20:22,600
Но я буду продолжать делать
это в то время как п больше 0.

405
00:20:22,600 --> 00:20:27,960
Другими словами, если пользователь дает мне
Int и это число больше 0,

406
00:20:27,960 --> 00:20:31,180
эрго, положительный, я собираюсь
просто держать reprompting пользователя,

407
00:20:31,180 --> 00:20:37,160
держать reprompting, заставляя их
сотрудничать и дайте мне отрицательный результат Int.

408
00:20:37,160 --> 00:20:41,640
>> И как только п на самом деле negative--
Предположим, что пользователь наконец типа -50,

409
00:20:41,640 --> 00:20:46,710
то это не в то время как цикл уже не так
потому что -50 не больше 0.

410
00:20:46,710 --> 00:20:51,140
Таким образом, мы нарушаем из этого
петля логически и вернуться п.

411
00:20:51,140 --> 00:20:53,520
>> Но есть еще одна
что я должен делать.

412
00:20:53,520 --> 00:20:56,190
И я могу просто сделать это
путем копирования и вставки

413
00:20:56,190 --> 00:20:58,540
одна строка кода в верхней части файла.

414
00:20:58,540 --> 00:21:01,630
Мне нужно, чтобы научить Clang,
или обещание лязгом,

415
00:21:01,630 --> 00:21:04,630
явно, что я буду,
на самом деле, пойти и осуществить

416
00:21:04,630 --> 00:21:06,020
эта функция get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Это может быть просто ниже в файле.

418
00:21:07,674 --> 00:21:09,840
Опять же, напомним, что Clang
читает вещи сверху вниз,

419
00:21:09,840 --> 00:21:12,330
слева направо, так что вы не можете
вызвать функцию, если Clang

420
00:21:12,330 --> 00:21:15,330
не знает, что это будет существовать.

421
00:21:15,330 --> 00:21:18,430
>> Теперь, к сожалению, эта программа,
так как некоторые из вас могли заметить,

422
00:21:18,430 --> 00:21:19,590
уже глючит.

423
00:21:19,590 --> 00:21:21,400
Позвольте мне идти вперед и сделать buggy3.

424
00:21:21,400 --> 00:21:26,904
Он собирает, так что моя проблема сейчас не
ошибка синтаксиса, как текстовой ошибки,

425
00:21:26,904 --> 00:21:29,570
это на самом деле будет логическим
ошибка, что я намеренно

426
00:21:29,570 --> 00:21:32,450
сделал как возможность
пошагово, что происходит.

427
00:21:32,450 --> 00:21:35,540
>> Я собираюсь идти вперед
Теперь и запустить buggy3.

428
00:21:35,540 --> 00:21:37,490
И я собираюсь пойти
вперед, а не сотрудничать.

429
00:21:37,490 --> 00:21:39,494
Я собираюсь дать ему номер 1.

430
00:21:39,494 --> 00:21:41,410
Это не понравилось, так
это меня снова пробуждая.

431
00:21:41,410 --> 00:21:42,147
>> Как насчет 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Ни один из них не работают.

435
00:21:44,740 --> 00:21:46,890
Как насчет -50?

436
00:21:46,890 --> 00:21:48,560
И программа, кажется, работает.

437
00:21:48,560 --> 00:21:49,970
>> Позвольте мне попробовать еще раз.

438
00:21:49,970 --> 00:21:53,400
Позвольте мне попробовать -1, кажется, работает.

439
00:21:53,400 --> 00:21:56,380
Позвольте мне попробовать -2, кажется, работает.

440
00:21:56,380 --> 00:21:59,640
Позвольте мне попробовать 0.

441
00:21:59,640 --> 00:22:01,684
Да, это неверно.

442
00:22:01,684 --> 00:22:03,350
Теперь мы, будучи немного педантичным здесь.

443
00:22:03,350 --> 00:22:07,090
Но это, на самом деле, так что 0
не является ни положительным, ни отрицательным.

444
00:22:07,090 --> 00:22:11,150
И поэтому тот факт, что моя программа
говоря, что 0 является отрицательным целым числом,

445
00:22:11,150 --> 00:22:12,820
это не технически правильно.

446
00:22:12,820 --> 00:22:15,180
>> Теперь, почему он это делает?

447
00:22:15,180 --> 00:22:16,270
Ну, это может быть очевидным.

448
00:22:16,270 --> 00:22:18,110
И, действительно, программа
имел в виду, чтобы быть достаточно простым

449
00:22:18,110 --> 00:22:19,670
поэтому у нас есть что-то, чтобы исследовать.

450
00:22:19,670 --> 00:22:25,870
>> Но давайте введем третью отладку
Техника здесь называется debug50.

451
00:22:25,870 --> 00:22:27,750
Так что это программа
что мы только что создали

452
00:22:27,750 --> 00:22:30,770
В этом году под названием debug50
что позволит вам

453
00:22:30,770 --> 00:22:34,130
использовать то, что называется встроенным
графический отладчик в CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
И отладчик просто программа, которая
как правило, позволяет запускать программу

455
00:22:38,400 --> 00:22:44,050
но шаг за шагом за шагом, линии
по линии по линии, делая паузу, тыкая

456
00:22:44,050 --> 00:22:47,626
вокруг, глядя на переменные, так что
программа не просто удар мимо вас

457
00:22:47,626 --> 00:22:49,750
и быстро напечатать что-нибудь
или не напечатать что-нибудь.

458
00:22:49,750 --> 00:22:53,250
Это дает возможность, в
человеческая скорость, чтобы взаимодействовать с ним.

459
00:22:53,250 --> 00:22:55,470
>> И сделать это, вы
просто сделайте следующее.

460
00:22:55,470 --> 00:22:58,479
После компиляции кода,
которые я уже сделал, buggy3,

461
00:22:58,479 --> 00:23:00,020
вы идете вперед и запустить debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Так же, как help50 имеет запуска
help50, а затем команда,

464
00:23:06,760 --> 00:23:10,120
debug50 имеет запустить debug50 и
то имя команды.

465
00:23:10,120 --> 00:23:14,440
>> Теперь посмотрим, что происходит на моем экране,
на правой стороне, в частности.

466
00:23:14,440 --> 00:23:19,400
Когда я ударил Выполнить, все
внезапная панель эта правая

467
00:23:19,400 --> 00:23:20,419
открывает на экране.

468
00:23:20,419 --> 00:23:22,210
И есть много чего происходит
на на первый взгляд.

469
00:23:22,210 --> 00:23:25,110
Но есть не слишком
много причин для беспокойства пока нет.

470
00:23:25,110 --> 00:23:28,570
>> Это показывает мне все
что происходит внутри моей программы

471
00:23:28,570 --> 00:23:31,130
прямо сейчас, и через них
Кнопки вверх верхней затем

472
00:23:31,130 --> 00:23:35,910
что позволило мне пройти через мой код
в конечном итоге шаг за шагом за шагом.

473
00:23:35,910 --> 00:23:37,140
Но не только пока.

474
00:23:37,140 --> 00:23:38,060
Обратите внимание на то, что происходит.

475
00:23:38,060 --> 00:23:40,600
В моем окне терминала
Я запроса на ввод п.

476
00:23:40,600 --> 00:23:44,560
И я собираюсь идти вперед и
сотрудничество на этот раз и введите -1.

477
00:23:44,560 --> 00:23:48,770
И хотя и немного загадочно, -1
является отрицательным целым числом, как и следовало ожидать.

478
00:23:48,770 --> 00:23:52,020
>> И тогда ребенок вышел с
Статус 0 GDBserver выхода.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, это имя
лежащего в основе программного обеспечения

480
00:23:55,180 --> 00:23:56,620
который реализует этот отладчик.

481
00:23:56,620 --> 00:24:00,500
Но все это на самом деле означает, отладчик
ушел, потому что моя программа бросить курить

482
00:24:00,500 --> 00:24:01,710
и все было хорошо.

483
00:24:01,710 --> 00:24:06,020
Если я хочу, чтобы действительно отлаживать программу,
Я должен сказать, превентивно debug50,

484
00:24:06,020 --> 00:24:08,920
где я хочу, чтобы начать
пошагового мой код?

485
00:24:08,920 --> 00:24:11,750
>> И, пожалуй, самый простой способ
сделать это следующим образом.

486
00:24:11,750 --> 00:24:15,300
Если я парить над
Желоб моего редактора здесь,

487
00:24:15,300 --> 00:24:19,090
так на самом деле просто в боковой панели здесь,
слева от номера строки,

488
00:24:19,090 --> 00:24:21,870
Обратите внимание, что, если я просто нажмите
один раз, я ставлю маленькую красную точку.

489
00:24:21,870 --> 00:24:24,460
И эта маленькая красная точка,
как знак остановки, значит, эй,

490
00:24:24,460 --> 00:24:29,430
debug50, выполнение паузы моего кода
прямо там, когда я запустить эту программу.

491
00:24:29,430 --> 00:24:30,260
>> Так давайте сделаем это.

492
00:24:30,260 --> 00:24:37,340
Позвольте мне идти вперед и запустить мою программу
снова с debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
А теперь, обратите внимание, что-то
иначе произошло.

494
00:24:40,110 --> 00:24:42,440
Я не запрос
все же в моем окне терминала

495
00:24:42,440 --> 00:24:45,430
ни за что, потому что у меня нет
получил там еще в моей программе.

496
00:24:45,430 --> 00:24:47,950
Обратите внимание на то, что в строке 8
который в настоящее время выделен,

497
00:24:47,950 --> 00:24:51,720
и есть маленькая стрелка
левая изречение, ты остановился здесь.

498
00:24:51,720 --> 00:24:55,030
Эта строка кода, строки
8, до сих пор не выполнено.

499
00:24:55,030 --> 00:24:58,940
>> И что любопытно, если я смотрю
здесь на правой стороне,

500
00:24:58,940 --> 00:25:03,530
обратите внимание, что я является локальным
переменная, локальная в том смысле,

501
00:25:03,530 --> 00:25:05,450
что она внутри текущей функции.

502
00:25:05,450 --> 00:25:08,920
И его значение, по-видимому, по умолчанию,
и вроде удобно, равно 0.

503
00:25:08,920 --> 00:25:10,260
Но я не тип 0.

504
00:25:10,260 --> 00:25:13,410
Это как раз случается быть его
Значение по умолчанию в данный момент.

505
00:25:13,410 --> 00:25:15,490
>> Итак, позвольте мне идти вперед и делать это сейчас.

506
00:25:15,490 --> 00:25:18,680
Позвольте мне идти вперед и на
в правом верхнем углу здесь, я

507
00:25:18,680 --> 00:25:20,970
идти вперед и
нажмите эту первую иконку, которая

508
00:25:20,970 --> 00:25:25,360
означает шаг, над которым означает не пропустить
это, но перешагнуть эту строку кода,

509
00:25:25,360 --> 00:25:27,770
выполняя его по пути.

510
00:25:27,770 --> 00:25:30,710
>> А теперь обратите внимание, что я
быстрое только что изменил.

511
00:25:30,710 --> 00:25:31,380
Почему это?

512
00:25:31,380 --> 00:25:33,639
Я сказал debug50,
запустить эту строку кода.

513
00:25:33,639 --> 00:25:34,930
Что делает эта строка кода делать?

514
00:25:34,930 --> 00:25:35,960
Запрашивает меня на междунар.

515
00:25:35,960 --> 00:25:36,460
ОК.

516
00:25:36,460 --> 00:25:37,400
Позвольте мне сотрудничать.

517
00:25:37,400 --> 00:25:41,340
Позвольте мне идти вперед сейчас и введите -1, Enter.

518
00:25:41,340 --> 00:25:42,920
А теперь обратите внимание, что изменилось.

519
00:25:42,920 --> 00:25:46,060
С правой стороны,
моя локальная переменная я

520
00:25:46,060 --> 00:25:48,200
обозначается как -1 в настоящее время.

521
00:25:48,200 --> 00:25:49,810
И это все-таки типа Int.

522
00:25:49,810 --> 00:25:53,102
>> И заметьте, тоже, мой так называемый
стек вызовов, где же я паузу?

523
00:25:53,102 --> 00:25:54,810
Мы будем говорить больше о
это в будущем.

524
00:25:54,810 --> 00:25:58,620
Но стек вызовов просто ссылается на то, что
функции в настоящее время в движении.

525
00:25:58,620 --> 00:26:00,040
Сейчас это просто главный.

526
00:26:00,040 --> 00:26:03,590
И сейчас единственный местный
переменная I со значением 1.

527
00:26:03,590 --> 00:26:09,840
>> И когда я, наконец, шаг по этой линии
здесь, с той же значок в правом верхнем углу,

528
00:26:09,840 --> 00:26:11,410
-1 Является отрицательным целым числом.

529
00:26:11,410 --> 00:26:13,580
Теперь он задержавшись над этим фигурной скобкой.

530
00:26:13,580 --> 00:26:14,740
Давайте пусть это делают свое дело.

531
00:26:14,740 --> 00:26:17,300
Я перешагнуть эту строку, и вуаля.

532
00:26:17,300 --> 00:26:20,240
>> Так что не все, что ужасно
поучительно все же,

533
00:26:20,240 --> 00:26:23,550
но это позвольте мне сделать паузу
и думаю, что через логически

534
00:26:23,550 --> 00:26:24,870
что эта программа делает.

535
00:26:24,870 --> 00:26:26,890
Но это не было ошибочным случаем.

536
00:26:26,890 --> 00:26:28,510
Давайте сделаем это снова следующим образом.

537
00:26:28,510 --> 00:26:31,340
>> Я собираюсь оставить эту точку останова
в строке 8 с красной точкой.

538
00:26:31,340 --> 00:26:32,830
Я собираюсь повторно запустить debug50.

539
00:26:32,830 --> 00:26:34,400
Это автоматически приостанавливается здесь.

540
00:26:34,400 --> 00:26:37,660
Но на этот раз, вместо того,
переступая через эту линию,

541
00:26:37,660 --> 00:26:42,290
позвольте мне на самом деле идти внутри
get_negative_int и выяснить,

542
00:26:42,290 --> 00:26:45,530
почему это принятие 0 в качестве действительного ответа?

543
00:26:45,530 --> 00:26:47,990
>> Таким образом, вместо того, чтобы нажать Step Over.

544
00:26:47,990 --> 00:26:50,630
Я собираюсь идти вперед
и нажмите кнопку Step Into.

545
00:26:50,630 --> 00:26:54,030
И обратите внимание, что линия 8 это
теперь выделяется теперь вдруг

546
00:26:54,030 --> 00:26:56,900
становится строка 17.

547
00:26:56,900 --> 00:26:59,947
>> Теперь, это не значит, что отладчик
пропустил линии 14 и 15, и 16.

548
00:26:59,947 --> 00:27:01,780
Это не просто там ничего
чтобы показать вам там.

549
00:27:01,780 --> 00:27:04,050
Те объявления переменных,
а затем там слово Do

550
00:27:04,050 --> 00:27:05,390
а затем открытая фигурная скобка.

551
00:27:05,390 --> 00:27:09,227
Только функциональная линия, это
сочный действительно этот здесь, 17.

552
00:27:09,227 --> 00:27:11,060
И вот где мы
автоматически приостанавливается.

553
00:27:11,060 --> 00:27:13,870
>> Так что Е ( "n.is:") ;, так
что до сих пор не произошло.

554
00:27:13,870 --> 00:27:18,250
Так что давайте идти вперед и нажмите кнопку Step Over.

555
00:27:18,250 --> 00:27:20,326
Теперь мой запрос, на самом деле,
изменен ( "п:").

556
00:27:20,326 --> 00:27:22,450
Теперь get_int, я не собираюсь
беспокоить вступаем,

557
00:27:22,450 --> 00:27:24,750
потому что функция была
сделанные CS50 в библиотеке.

558
00:27:24,750 --> 00:27:25,750
Это, вероятно, правильно.

559
00:27:25,750 --> 00:27:28,440
>> Так что я собираюсь идти вперед и
своего рода сотрудничество, придав ему

560
00:27:28,440 --> 00:27:30,590
вызовите прерывание, но не является отрицательным Int.

561
00:27:30,590 --> 00:27:32,870
Итак, позвольте мне идти вперед и ударил 0.

562
00:27:32,870 --> 00:27:39,460
А теперь, что происходит здесь
когда я получаю вниз к линии 21?

563
00:27:39,460 --> 00:27:40,890
Я не итерироваться снова.

564
00:27:40,890 --> 00:27:43,320
Я, кажется, не застрянет в этом цикле.

565
00:27:43,320 --> 00:27:45,990
Другими словами, этот желтый
бар не будет держать вокруг,

566
00:27:45,990 --> 00:27:47,130
и вокруг, и вокруг него.

567
00:27:47,130 --> 00:27:48,340
>> Теперь, почему это?

568
00:27:48,340 --> 00:27:49,920
Что ж, п, что равно п прямо сейчас?

569
00:27:49,920 --> 00:27:53,280
Я могу смотреть на местном
Переменные в отладчике.

570
00:27:53,280 --> 00:27:53,816
п равно 0.

571
00:27:53,816 --> 00:27:55,190
Хорошо, что это было мое состояние?

572
00:27:55,190 --> 00:27:58,700
>> 20-- линия 20, ну,
0 больше 0.

573
00:27:58,700 --> 00:27:59,500
Это неправда.

574
00:27:59,500 --> 00:28:01,020
0 не больше 0.

575
00:28:01,020 --> 00:28:02,820
И поэтому я вырвалась из этого.

576
00:28:02,820 --> 00:28:06,370
>> И вот почему на линии
21, если я на самом деле по-прежнему,

577
00:28:06,370 --> 00:28:10,370
Я собираюсь вернуть 0, даже
хотя я должен был отвергнуто 0

578
00:28:10,370 --> 00:28:12,484
а на самом деле не является отрицательным.

579
00:28:12,484 --> 00:28:14,650
Так что теперь, я не очень даже
заботиться о отладчика.

580
00:28:14,650 --> 00:28:16,900
Понял, я не нужно
знаю, что еще происходит.

581
00:28:16,900 --> 00:28:19,233
>> Так что я собираюсь идти вперед и
просто нажмите кнопку воспроизведения,

582
00:28:19,233 --> 00:28:20,240
и пусть это закончить.

583
00:28:20,240 --> 00:28:23,440
Теперь я понял, что мой
ошибка по-видимому, в строке 20.

584
00:28:23,440 --> 00:28:25,160
Это моя логическая ошибка.

585
00:28:25,160 --> 00:28:28,100
>> И вот, что я хочу
нужно сделать, чтобы изменить это?

586
00:28:28,100 --> 00:28:32,500
Если проблема заключается в том, что я не
ловить 0, это просто логическая ошибка.

587
00:28:32,500 --> 00:28:35,910
И я могу сказать, в то время как п
больше или равно 0,

588
00:28:35,910 --> 00:28:38,330
держать снова и снова запрашивая пользователя.

589
00:28:38,330 --> 00:28:41,050
>> Так что, опять же, простая ошибка, возможно,
даже очевидно, когда вы видели меня

590
00:28:41,050 --> 00:28:42,410
написать это всего несколько минут назад.

591
00:28:42,410 --> 00:28:44,570
Но здесь вынос
является то, что при отладке 50,

592
00:28:44,570 --> 00:28:46,850
и с отладкой
программное обеспечение в более общем плане,

593
00:28:46,850 --> 00:28:51,370
у вас есть это новое питание
пройти через свой собственный код, смотрите

594
00:28:51,370 --> 00:28:55,590
с помощью этой правой панели, что
переменные значения.

595
00:28:55,590 --> 00:28:57,700
Таким образом, вы не обязательно
должны использовать что-то

596
00:28:57,700 --> 00:29:00,630
как вы eprintf печатать эти значения.

597
00:29:00,630 --> 00:29:04,430
Вы можете увидеть их
визуально на экране.

598
00:29:04,430 --> 00:29:08,920
>> Теперь, помимо этого, стоит отметить,
что есть другая техника, которая

599
00:29:08,920 --> 00:29:09,890
на самом деле очень распространенным явлением.

600
00:29:09,890 --> 00:29:13,120
И вы могли бы задаться вопросом, почему этот маленький
парень здесь сидел на сцене.

601
00:29:13,120 --> 00:29:16,490
Так что есть эта техника, как правило,
известный как метод утёнка,

602
00:29:16,490 --> 00:29:18,786
который на самом деле это просто
свидетельством того,

603
00:29:18,786 --> 00:29:20,660
что часто, когда программисты
написании кода,

604
00:29:20,660 --> 00:29:22,650
они не обязательно
сотрудничая с другими,

605
00:29:22,650 --> 00:29:24,030
или работать в общей среде.

606
00:29:24,030 --> 00:29:25,050
>> Они вроде дома.

607
00:29:25,050 --> 00:29:25,910
Может быть, это поздно ночью.

608
00:29:25,910 --> 00:29:28,190
Они пытаются фигуры
некоторые ошибки в своем коде.

609
00:29:28,190 --> 00:29:29,330
И они просто не видит.

610
00:29:29,330 --> 00:29:30,329
>> И нет никакого соседа по комнате.

611
00:29:30,329 --> 00:29:31,250
Там нет TF.

612
00:29:31,250 --> 00:29:32,680
Там нет CA вокруг.

613
00:29:32,680 --> 00:29:36,440
Все они имеют на своей полке
эта маленькая резиновая уточка.

614
00:29:36,440 --> 00:29:39,030
>> И поэтому отладка резиновая утка
просто это приглашение

615
00:29:39,030 --> 00:29:42,780
думать о чем-то, как глупо
так как это как реальное существо,

616
00:29:42,780 --> 00:29:46,940
и на самом деле пройти через ваш код
в устной форме к этому неодушевленный объект.

617
00:29:46,940 --> 00:29:49,230
Так, например, если
это мой пример here--

618
00:29:49,230 --> 00:29:52,470
и напомним, что ранее
проблема была в этом,

619
00:29:52,470 --> 00:29:58,140
если я удалю эту первую строку кода,
и я иду вперед и сделать багги 0 раз,

620
00:29:58,140 --> 00:30:01,220
Напомним, что у меня были эти
Сообщения об ошибках здесь.

621
00:30:01,220 --> 00:30:05,997
Так что идея здесь, смешно, хотя я
чувствую в данный момент делает это публично,

622
00:30:05,997 --> 00:30:06,580
является то, что ошибка.

623
00:30:06,580 --> 00:30:10,910
>> ОК, так что моя проблема в том, что я
неявно библиотечную функцию.

624
00:30:10,910 --> 00:30:12,610
И эта функция библиотеки Printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, объявить
напоминает мне о прототипах.

626
00:30:15,290 --> 00:30:18,930
>> Это означает, что мне нужно на самом деле
сообщить компилятору заранее, что

627
00:30:18,930 --> 00:30:19,980
функция выглядит следующим образом.

628
00:30:19,980 --> 00:30:20,930
Подожди минуту.

629
00:30:20,930 --> 00:30:23,580
У меня не было стандартного io.h.

630
00:30:23,580 --> 00:30:24,530
Большое спасибо.

631
00:30:24,530 --> 00:30:27,330
>> Так что этот процесс of-- вас
не нужно на самом деле есть утка.

632
00:30:27,330 --> 00:30:29,819
Но эта идея ходить
самостоятельно через свой собственный код

633
00:30:29,819 --> 00:30:31,610
так что вы даже слышать
самостоятельно, так что вы

634
00:30:31,610 --> 00:30:35,620
реализовать упущения в свой собственный
замечания, как правило, идея.

635
00:30:35,620 --> 00:30:38,910
>> И, возможно, более логично, не так
много с этим один, но более активное участие

636
00:30:38,910 --> 00:30:44,220
Пример, который мы только что сделали в багги 3.c,
Вы могли бы ходить себя через него

637
00:30:44,220 --> 00:30:45,310
следующим образом.

638
00:30:45,310 --> 00:30:49,190
Так что все в порядке, резина
душка, DDB, если вы будете.

639
00:30:49,190 --> 00:30:52,350
Здесь мы имеем в своей основной функции,
Я звоню получить отрицательный результат Int.

640
00:30:52,350 --> 00:30:54,660
>> И я получаю возвращаемое значение.

641
00:30:54,660 --> 00:31:00,410
Я хранить его на левой стороне
в строке 8 в переменной называется I.

642
00:31:00,410 --> 00:31:02,380
Хорошо, но ждать, как сделал
что получить это значение?

643
00:31:02,380 --> 00:31:04,130
Позвольте мне взглянуть на функции в строке 12.

644
00:31:04,130 --> 00:31:05,760
>> В строке 12 мы имеем получить отрицательную Int.

645
00:31:05,760 --> 00:31:08,190
Не принимать какие-либо материалы,
это возвращает Int, OK.

646
00:31:08,190 --> 00:31:10,929
Я заявляю, в строке 14 переменная п.

647
00:31:10,929 --> 00:31:12,220
Это будет хранить целое число.

648
00:31:12,220 --> 00:31:13,760
Это то, что я хочу.

649
00:31:13,760 --> 00:31:18,480
>> Так сделайте следующее: Когда п is-- пусть
мне отменить то, что исправление я уже сделал.

650
00:31:18,480 --> 00:31:22,710
Таким образом, в то время как п больше
0, распечатать п, OK.

651
00:31:22,710 --> 00:31:25,170
А затем вызовите получить INT хранится в п.

652
00:31:25,170 --> 00:31:30,160
А затем проверьте, если п = 0,
п не-- там.

653
00:31:30,160 --> 00:31:31,910
Так что, опять же, вы этого не сделаете
нужен фактический утка.

654
00:31:31,910 --> 00:31:35,650
Но просто ходить самостоятельно через
ваш код как интеллектуальное упражнение

655
00:31:35,650 --> 00:31:37,720
часто поможет вам
осознать, что происходит,

656
00:31:37,720 --> 00:31:41,170
а не просто делать что-то
как это, глядя на экран,

657
00:31:41,170 --> 00:31:43,720
и не говорить себя через
то, что это не честно

658
00:31:43,720 --> 00:31:46,270
почти как эффективный метод.

659
00:31:46,270 --> 00:31:48,620
Так что у вас есть, A
количество различных методов

660
00:31:48,620 --> 00:31:52,102
для фактически отладки кода
и придираться, все из которых

661
00:31:52,102 --> 00:31:54,810
должны быть инструменты в ваш инструментарий
так что вы не поздно ночью,

662
00:31:54,810 --> 00:31:57,660
особенно, вы в столовой
залы, или в нерабочее время,

663
00:31:57,660 --> 00:32:00,368
бьешься головой против
стены, пытаясь решить некоторые проблемы.

664
00:32:00,368 --> 00:32:02,020
Понимают, что есть программные средства.

665
00:32:02,020 --> 00:32:03,720
Есть резиновая утка инструменты.

666
00:32:03,720 --> 00:32:09,630
И есть целый штат
поддержки ждут, чтобы протянуть руку помощи.

667
00:32:09,630 --> 00:32:13,120
>> Так что теперь, слово по проблеме
наборы, а также на то, что мы надеемся, что вам

668
00:32:13,120 --> 00:32:15,620
выйти из них, и как
мы идем об оценке.

669
00:32:15,620 --> 00:32:17,680
За учебный план Курса,
CS50 множества проблем в

670
00:32:17,680 --> 00:32:22,320
оцениваются по четырем основным осям, так
чтобы speak-- сферу, корректность, дизайн,

671
00:32:22,320 --> 00:32:23,060
и стиль.

672
00:32:23,060 --> 00:32:25,910
И сфера просто относится к тому, сколько
куска вы откусили?

673
00:32:25,910 --> 00:32:28,080
Сколько проблемы вы пробовали?

674
00:32:28,080 --> 00:32:30,110
Какой уровень усилий
Вы выражалось?

675
00:32:30,110 --> 00:32:35,750
>> Корректность, работает программа, как
он должен согласно спецификации CS50

676
00:32:35,750 --> 00:32:38,640
когда вы предоставляете определенные входы
или определенные выходы возвращаются?

677
00:32:38,640 --> 00:32:41,130
Дизайн является наиболее субъективным из них.

678
00:32:41,130 --> 00:32:43,360
И это тот, который будет
взять самый длинный, чтобы узнать,

679
00:32:43,360 --> 00:32:47,220
и самый длинный, чтобы преподавать в
до сих пор, как это сводится к тому,

680
00:32:47,220 --> 00:32:49,530
как хорошо написано ваш код?

681
00:32:49,530 --> 00:32:52,920
>> Это одна вещь, чтобы просто напечатать правильный
выходы или возвращать правильные значения.

682
00:32:52,920 --> 00:32:55,400
Но вы делаете это как
эффективно, насколько это возможно?

683
00:32:55,400 --> 00:32:58,210
Вы делаете это разрыв
и властвуй, или двоичный

684
00:32:58,210 --> 00:33:01,500
Поиск, как мы скоро увидим, что мы сделали
две недели назад с телефонной книгой?

685
00:33:01,500 --> 00:33:04,670
Существуют ли более эффективные способы решения
проблема, чем сейчас у вас здесь?

686
00:33:04,670 --> 00:33:06,380
Это возможность для лучшего дизайна.

687
00:33:06,380 --> 00:33:08,530
>> А потом, как style--
довольно ваш код?

688
00:33:08,530 --> 00:33:12,370
Вы заметите, что я довольно
частности о отступов мой код,

689
00:33:12,370 --> 00:33:15,300
и убедившись, что мои переменные
обоснованно названы. п,

690
00:33:15,300 --> 00:33:19,660
в то время как короткие, хорошее имя для
номер, я для подсчета числа,

691
00:33:19,660 --> 00:33:20,727
s для строки.

692
00:33:20,727 --> 00:33:22,560
И мы можем иметь больше
имена переменных стиля.

693
00:33:22,560 --> 00:33:25,500
Стиль, насколько хорошо
выглядит ваш код?

694
00:33:25,500 --> 00:33:26,600
А как читаемый это?

695
00:33:26,600 --> 00:33:29,650
>> И с течением времени, чем ваши TAs
и ТФ будет делать в процессе

696
00:33:29,650 --> 00:33:31,870
это предоставить вам, что
вид качественной обратной связи

697
00:33:31,870 --> 00:33:34,330
так что вы получите лучше
в этих различных аспектах.

698
00:33:34,330 --> 00:33:37,510
И с точки зрения того, как мы
оценить каждую из этих осей,

699
00:33:37,510 --> 00:33:40,080
это, как правило, с очень немногими
ведра, так что вы, как правило,

700
00:33:40,080 --> 00:33:41,680
получить представление о том, насколько хорошо вы делаете.

701
00:33:41,680 --> 00:33:45,680
И действительно, если вы получите счет на
любой из этих axes-- правильность, дизайн

702
00:33:45,680 --> 00:33:49,659
и стиль especially--, что число
как правило, составляет от 1 до 5 баллов.

703
00:33:49,659 --> 00:33:52,450
И, в буквальном смысле, если вы получаете
3-х в начале семестра,

704
00:33:52,450 --> 00:33:53,977
Это очень хорошая вещь.

705
00:33:53,977 --> 00:33:55,810
Это означает, что есть еще
возможности для совершенствования,

706
00:33:55,810 --> 00:33:58,490
который вы бы надеяться в
принимая класс в первый раз.

707
00:33:58,490 --> 00:34:01,820
Там в какой-то, надеюсь, немного потолка
к которому вы стремящихся к достижению.

708
00:34:01,820 --> 00:34:03,970
И поэтому получение 3 по
самые ранние пьесы,

709
00:34:03,970 --> 00:34:06,550
если не какой-то 2-х и 4-х,
это, действительно, очень хорошая вещь.

710
00:34:06,550 --> 00:34:08,880
Это хорошо в пределах диапазона,
хорошо в пределах ожиданий.

711
00:34:08,880 --> 00:34:11,421
>> И если ваш ум мчится, подождите
минуту, три из пяти.

712
00:34:11,421 --> 00:34:12,620
Это действительно 6 из 10.

713
00:34:12,620 --> 00:34:13,560
Это 60%.

714
00:34:13,560 --> 00:34:14,830
Боже мой, это на букву F.

715
00:34:14,830 --> 00:34:15,870
>> Это не.

716
00:34:15,870 --> 00:34:17,600
Это не так, на самом деле, это.

717
00:34:17,600 --> 00:34:22,710
Скорее всего, это возможность улучшить
в течение семестра.

718
00:34:22,710 --> 00:34:25,580
И если вы получаете некоторые
Poors, это возможность

719
00:34:25,580 --> 00:34:29,199
чтобы воспользоваться офисными часами,
конечно же разделы и другие ресурсы.

720
00:34:29,199 --> 00:34:32,840
>> Лучше это возможность, на самом деле,
можно гордиться, насколько далеко вы

721
00:34:32,840 --> 00:34:34,520
приходят в течение семестра.

722
00:34:34,520 --> 00:34:38,199
Так же понимаешь, если ничего
еще три хорошо.

723
00:34:38,199 --> 00:34:40,179
И это позволяет для роста с течением времени.

724
00:34:40,179 --> 00:34:43,090
>> Что касается того, как эти оси
взвешенное, реально вы

725
00:34:43,090 --> 00:34:46,745
собирается потратить большую часть своего времени получения
вещи, чтобы работать, не говоря уже правильно.

726
00:34:46,745 --> 00:34:49,120
И поэтому, как правило, корректность
взвешиваться больше всего, как и с

727
00:34:49,120 --> 00:34:51,360
этот мультипликативный фактор трех.

728
00:34:51,360 --> 00:34:54,659
Дизайн также имеет важное значение, но
то, что вы не обязательно

729
00:34:54,659 --> 00:34:58,220
тратить все те часы, на
пытаясь получить вещи просто работать.

730
00:34:58,220 --> 00:35:00,019
>> И таким образом это взвешенный
чуть более слегка.

731
00:35:00,019 --> 00:35:01,560
А потом стиль взвешивается по меньшей мере.

732
00:35:01,560 --> 00:35:03,710
Несмотря на то, что это не менее
важно фундаментально,

733
00:35:03,710 --> 00:35:05,990
это просто, может быть,
Проще всего сделать правильно,

734
00:35:05,990 --> 00:35:08,440
имитируя примеры, которые мы
делать в лекции и секции,

735
00:35:08,440 --> 00:35:11,080
с вещами красиво
отступом, и прокомментировал,

736
00:35:11,080 --> 00:35:14,320
и так далее является одним из самых простых
вещи, чтобы сделать и получить право.

737
00:35:14,320 --> 00:35:16,960
Так как таковые, реализовать
что те точки

738
00:35:16,960 --> 00:35:19,000
что относительно легко понять.

739
00:35:19,000 --> 00:35:22,360
>> А теперь слово на
this-- академической честности.

740
00:35:22,360 --> 00:35:25,150
Таким образом, за Курса
учебный план, вы увидите

741
00:35:25,150 --> 00:35:27,630
что курс имеет довольно
немного языка вокруг этого.

742
00:35:27,630 --> 00:35:31,380
И конечно же берет вопрос
академическая честность вполне серьезно.

743
00:35:31,380 --> 00:35:33,450
>> У нас есть различия,
лучше или хуже,

744
00:35:33,450 --> 00:35:36,570
из прислав каждый год более
студентов для принятия дисциплинарных мер

745
00:35:36,570 --> 00:35:39,670
чем большинство любой другой
Конечно же, что я знаю.

746
00:35:39,670 --> 00:35:42,580
Это не обязательно
свидетельствует о том,

747
00:35:42,580 --> 00:35:46,340
что студенты CS или CS50 студентов, являются
менее честнее своих одноклассников.

748
00:35:46,340 --> 00:35:49,090
Но реальность, что в этом
мир, в электронном виде, мы просто

749
00:35:49,090 --> 00:35:50,990
есть технологическая
средство обнаружения этого.

750
00:35:50,990 --> 00:35:53,360
>> Это очень важно для нас для
справедливость по классу

751
00:35:53,360 --> 00:35:58,550
что мы делаем это обнаружить и поднять
вопрос, когда мы видим вещи.

752
00:35:58,550 --> 00:36:01,980
И как раз, чтобы нарисовать картину, а на самом деле
чтобы помочь что-то вроде этого в раковине,

753
00:36:01,980 --> 00:36:04,600
это число
Студенты в течение последних 10 лет

754
00:36:04,600 --> 00:36:07,610
которые были вовлечены в некоторые
такие вопросы академической честности,

755
00:36:07,610 --> 00:36:10,990
с некоторыми 32 студентов
с осени 2015 года, которая

756
00:36:10,990 --> 00:36:13,760
должен сказать, что мы принимаем
дело очень серьезно.

757
00:36:13,760 --> 00:36:18,380
И, в конечном счете, эти цифры составляют,
Совсем недавно, около 3%, 4% или около того

758
00:36:18,380 --> 00:36:19,120
класса.

759
00:36:19,120 --> 00:36:25,220
>> Так что для супер большинства студентов
кажется, что линии четкие.

760
00:36:25,220 --> 00:36:27,940
Но имейте это в
ум, особенно поздно

761
00:36:27,940 --> 00:36:32,080
в ночное время, когда борется с
какое-то решение для множества проблем,

762
00:36:32,080 --> 00:36:34,830
что существуют механизмы
для получения себя лучше

763
00:36:34,830 --> 00:36:37,870
поддержка, чем вы могли бы
думаю, даже в тот час.

764
00:36:37,870 --> 00:36:40,514
Понимают, что, когда мы получаем
студенческие представления, мы пересекаем

765
00:36:40,514 --> 00:36:43,430
сравнить все представления в этом году
против каждого представления в прошлом году,

766
00:36:43,430 --> 00:36:47,590
против каждого представления с 2007 года,
и так как, глядя на, а также,

767
00:36:47,590 --> 00:36:49,931
код репозиториев онлайн,
дискуссионных форумах, работа сайтов.

768
00:36:49,931 --> 00:36:51,806
И мы отметим это,
на самом деле, все ради

769
00:36:51,806 --> 00:36:56,040
полного раскрытия, что если
кто-то может найти его в Интернете,

770
00:36:56,040 --> 00:36:57,880
конечно же, так что мы можем курс.

771
00:36:57,880 --> 00:37:00,100
Но, на самом деле, дух
из курса сводится

772
00:37:00,100 --> 00:37:01,650
к этой статье в учебной программе.

773
00:37:01,650 --> 00:37:03,670
Это действительно просто, разумно.

774
00:37:03,670 --> 00:37:06,680
>> И если мы должны были остановиться на этом
с только немного больше языка,

775
00:37:06,680 --> 00:37:09,770
осознать, что суть всех
Работа, которую вы представить этот курс

776
00:37:09,770 --> 00:37:10,954
должен быть свой собственный.

777
00:37:10,954 --> 00:37:13,870
Но в том, что есть, конечно,
возможностей и поощрение,

778
00:37:13,870 --> 00:37:17,300
и педагогическая ценность в превращении в
others-- себя, ССТ, КАС,

779
00:37:17,300 --> 00:37:20,760
Тас и другие в классе,
для поддержки, не говоря уже о друзей

780
00:37:20,760 --> 00:37:23,547
и соседи по комнате, кто изучал
CS и программирование раньше.

781
00:37:23,547 --> 00:37:25,130
И поэтому есть пособие для этого.

782
00:37:25,130 --> 00:37:28,180
А общее правило
является this--, когда просят о помощи,

783
00:37:28,180 --> 00:37:31,470
Вы можете показать свой код другим,
но вы не можете просматривать их.

784
00:37:31,470 --> 00:37:34,880
Так что даже если вы в рабочее время,
или в зале D, или где-нибудь еще

785
00:37:34,880 --> 00:37:37,450
работает над какой-то кусок набора,
работая вместе с другом, который

786
00:37:37,450 --> 00:37:40,160
это совершенно нормально, на
Конец дня вашей работы

787
00:37:40,160 --> 00:37:43,034
в конечном итоге должно принадлежать каждому
из вас, соответственно, и не

788
00:37:43,034 --> 00:37:45,700
быть некоторые совместные усилия,
для окончательного проекта, где кроме

789
00:37:45,700 --> 00:37:47,410
это разрешается и поощряется.

790
00:37:47,410 --> 00:37:49,830
>> Поймите, что если вы
борется с чем-то

791
00:37:49,830 --> 00:37:52,520
и ваш друг только что происходит
чтобы быть лучше в этом, то вы,

792
00:37:52,520 --> 00:37:55,130
или лучше на эту проблему, чем вы,
или чуть дальше вперед, чем вы,

793
00:37:55,130 --> 00:37:57,330
это совершенно разумно, чтобы превратить
своему другу и сказать, эй,

794
00:37:57,330 --> 00:38:00,480
Вы не возражаете, глядя на мой код здесь,
чтобы помочь мне определить, что мой вопрос?

795
00:38:00,480 --> 00:38:03,760
И, надеюсь, в
Интерес педагогической ценности

796
00:38:03,760 --> 00:38:07,040
что друг не просто
говорят, ах, сделать это, но, скорее,

797
00:38:07,040 --> 00:38:09,917
то, что вы пропали без вести на линии
6, или что-то подобное?

798
00:38:09,917 --> 00:38:12,000
Но это решение не
для друга рядом с вами

799
00:38:12,000 --> 00:38:15,617
сказать, ой, ну, вот, позвольте мне тянуть
это, и показать мое решение для вас.

800
00:38:15,617 --> 00:38:16,450
Так что это линия.

801
00:38:16,450 --> 00:38:18,670
Вы показываете свой код в
другие, но вы не можете

802
00:38:18,670 --> 00:38:22,350
посмотреть у них, в соответствии с другими
ограничения в учебный план Курса.

803
00:38:22,350 --> 00:38:24,760
>> Так что имейте в виду, что это
так называемый пункт сожаления

804
00:38:24,760 --> 00:38:27,560
в ходе учебного плана, а также,
что если вы совершите какой-то акт,

805
00:38:27,560 --> 00:38:30,476
не является разумным, но довести его до
внимание руководителей Курса

806
00:38:30,476 --> 00:38:34,240
в течение 72 часов, курс
может налагать санкции, местные

807
00:38:34,240 --> 00:38:37,380
может включать в себя неудовлетворительным или
провальную оценку для работы, представленные.

808
00:38:37,380 --> 00:38:41,410
Но, конечно, не передаст
важно для дальнейшего принятия дисциплинарных мер,

809
00:38:41,410 --> 00:38:43,010
за исключением случаев повторных актов.

810
00:38:43,010 --> 00:38:46,632
Другими словами, если вы делаете некоторые
глупо, особенно поздно вечером, решение

811
00:38:46,632 --> 00:38:49,340
что на следующее утро или через два дня
позже, вы пробудиться и осознать,

812
00:38:49,340 --> 00:38:50,870
о чем я только думал?

813
00:38:50,870 --> 00:38:53,890
Вы делаете в CS50 имеют выход
для фиксации этой проблемы

814
00:38:53,890 --> 00:38:57,170
и владеть до него, так что мы
встретит вас на полпути и дело

815
00:38:57,170 --> 00:39:01,500
с ним в вопросе, который является одновременно
образовательных и ценным для вас,

816
00:39:01,500 --> 00:39:04,200
но до сих пор карательный в некотором роде.

817
00:39:04,200 --> 00:39:08,590
И теперь, чтобы заморить, это.

818
00:39:08,590 --> 00:39:10,570
>> [ПРОИГРЫВАНИЕ ВИДЕО]

819
00:39:10,570 --> 00:39:13,540
>> [МУЗЫКА]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [КОНЕЦ ВОСП]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Малан: Хорошо, мы вернулись.

823
00:40:00,490 --> 00:40:03,680
А теперь мы посмотрим на один из
первый из наших реальных доменов

824
00:40:03,680 --> 00:40:08,720
в CS50, искусство криптографии,
искусство отправки и получения

825
00:40:08,720 --> 00:40:11,840
секретные сообщения, зашифрованного
сообщения, если вы будете,

826
00:40:11,840 --> 00:40:17,060
которые могут быть расшифрованы только если у вас есть
некоторые из ключевых элементов, что отправитель

827
00:40:17,060 --> 00:40:18,030
также.

828
00:40:18,030 --> 00:40:22,120
Таким образом, чтобы мотивировать этого мы возьмем
Посмотрите на эту вещь здесь,

829
00:40:22,120 --> 00:40:26,750
которая является Примердлительногопребывания
секрет декодер кольцо,

830
00:40:26,750 --> 00:40:34,042
может быть использован для того, чтобы выяснить,
то, что секретное сообщение на самом деле.

831
00:40:34,042 --> 00:40:35,750
На самом деле, еще в
день в начальной школе,

832
00:40:35,750 --> 00:40:38,787
если вы когда-нибудь послал секретные сообщения
некоторые друг или некоторые давка в классе,

833
00:40:38,787 --> 00:40:40,620
Вы могли бы подумать,
вы были умными

834
00:40:40,620 --> 00:40:46,530
путем на вашей части замены бумаги,
как, А к В, и В к С, В и С к D,

835
00:40:46,530 --> 00:40:47,590
и так далее.

836
00:40:47,590 --> 00:40:50,300
Но вы были на самом деле шифрования
Ваша информация, даже

837
00:40:50,300 --> 00:40:53,300
если это было немного тривиально, не было
что трудно для учителя, чтобы понять,

838
00:40:53,300 --> 00:40:55,675
хорошо, если вы просто изменить
В к А и С к В,

839
00:40:55,675 --> 00:40:57,550
вы на самом деле выяснить,
что было сообщение,

840
00:40:57,550 --> 00:40:59,700
но вы были в шифровании информации.

841
00:40:59,700 --> 00:41:03,420
>> Вы просто делали это
просто, так же, как Ральфи здесь

842
00:41:03,420 --> 00:41:07,934
в известном фильме, который играет
довольно много объявлений каждую зиму до тошноты.

843
00:41:07,934 --> 00:41:08,600
[ПРОИГРЫВАНИЕ ВИДЕО]

844
00:41:08,600 --> 00:41:11,180
-Будьте Это всем известно, что
Ральф Паркер Настоящим

845
00:41:11,180 --> 00:41:14,070
назначен членом Маленькой
Сиротка Энни Secret Circle

846
00:41:14,070 --> 00:41:17,700
и имеет право на все почести
и выгоды происходит с ним.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Сиротка Энни,
встречное подписал Пьер Андре, в чернилах.

848
00:41:24,340 --> 00:41:27,160
Почести и выгоды,
уже в возрасте девяти лет.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Крича]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Давай.

853
00:41:34,250 --> 00:41:35,210
Давайте покончим с этим.

854
00:41:35,210 --> 00:41:39,530
Мне не нужно все, что джаз
о контрабандистов и пиратов.

855
00:41:39,530 --> 00:41:41,660
>> -Слушай Завтра ночь
завершающим приключения

856
00:41:41,660 --> 00:41:43,880
черного пиратского корабля.

857
00:41:43,880 --> 00:41:46,650
Теперь пришло время для
секретное сообщение Энни

858
00:41:46,650 --> 00:41:49,840
для вас члены тайного кружка.

859
00:41:49,840 --> 00:41:53,570
Помните, дети, только члены
Энни Секретной Circle

860
00:41:53,570 --> 00:41:56,140
может расшифровать секретное сообщение Энни.

861
00:41:56,140 --> 00:42:00,340
>> Помните, что Энни зависит от вас.

862
00:42:00,340 --> 00:42:02,880
Установите штифты B2.

863
00:42:02,880 --> 00:42:05,230
Вот сообщение.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Я Нахожусь в, свою первую секретную встречу.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Был громкий голос сегодня.

868
00:42:15,780 --> 00:42:19,000
Я мог бы сказать, что сегодня вечером
сообщение было действительно важно.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, это сообщение
от самой Энни.

870
00:42:22,694 --> 00:42:23,860
Помните, что не говори никому.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Секунд спустя, я нахожусь в единственной
комната в доме, где девятилетний мальчик

873
00:42:32,930 --> 00:42:37,040
мог сидеть в уединении и декодированием.

874
00:42:37,040 --> 00:42:39,730
Ага, B!

875
00:42:39,730 --> 00:42:42,360
Я пошел к следующему, Е.

876
00:42:42,360 --> 00:42:44,520
>> Первое слово будет.

877
00:42:44,520 --> 00:42:49,032
S, он шел легче сейчас, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -О, Давай, Ральфи, я должен идти!

879
00:42:51,733 --> 00:42:53,688
>> -Я Сейчас спущусь, Ма!

880
00:42:53,688 --> 00:42:54,188
Вот здорово!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -Т, O, обязательно убедитесь, что, целью которых к чему?

883
00:43:04,060 --> 00:43:05,970
Что сиротка
Энни пытается сказать?

884
00:43:05,970 --> 00:43:07,264
Убедитесь, что к чему?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Энди попал
идти, то, пожалуйста, выйти?

886
00:43:09,634 --> 00:43:10,480
>> -Хорошо, Мама!

887
00:43:10,480 --> 00:43:12,880
Я буду прямо!

888
00:43:12,880 --> 00:43:14,550
>> -Я Становился ближе.

889
00:43:14,550 --> 00:43:16,620
Напряжение было ужасно.

890
00:43:16,620 --> 00:43:17,720
Что это было?

891
00:43:17,720 --> 00:43:20,170
Судьба планеты
может висеть на волоске.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Энди должен идти!

894
00:43:23,170 --> 00:43:26,890
>> -Я Сейчас выйду, для взывают громко!

895
00:43:26,890 --> 00:43:32,680
>> -почти Там, мои пальцы летали, мой разум
была стальная ловушка, каждая пора вибрировать.

896
00:43:32,680 --> 00:43:37,198
Это было почти ясно, да, да, да.

897
00:43:37,198 --> 00:43:43,091
>> -Будьте Обязательно пить Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Вшивого коммерческий?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Сукин сын.

903
00:43:54,227 --> 00:43:54,810
[КОНЕЦ ВОСП]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Малан: ОК, так что
это был очень долгий путь

905
00:43:57,390 --> 00:44:00,660
введения криптографию,
а также Ovaltine.

906
00:44:00,660 --> 00:44:04,470
На самом деле, от этого старого объявлений
здесь, почему Ovaltine так хорошо?

907
00:44:04,470 --> 00:44:09,470
Это концентрированное извлечение спелые
ячменный солод, чистое сливочное из коровьего молока,

908
00:44:09,470 --> 00:44:14,360
и специально подготовленные какао вместе
с природными фосфатидов и витаминов.

909
00:44:14,360 --> 00:44:18,240
Далее обогащенные
дополнительные витамины группы В и D, ням.

910
00:44:18,240 --> 00:44:21,600
И вы все еще можете получить его, по-видимому,
на Амазонке, как мы делали здесь.

911
00:44:21,600 --> 00:44:24,810
>> Но мотивация здесь была
ввести криптографию, в частности,

912
00:44:24,810 --> 00:44:28,340
тип криптографии известен
в качестве секретного ключа шифрования.

913
00:44:28,340 --> 00:44:34,284
И, как следует из названия, весь
безопасность секретного ключа системы криптографической,

914
00:44:34,284 --> 00:44:36,200
если вы будете, методология
для скремблирования просто

915
00:44:36,200 --> 00:44:40,960
информация между двумя людьми, в том, что
только отправитель и получатель только

916
00:44:40,960 --> 00:44:46,980
знать секрет key-- какую-то ценность, некоторые
условную фразу, какой-то секрет число, что

917
00:44:46,980 --> 00:44:50,660
позволяет им как зашифровать
и расшифровать информацию.

918
00:44:50,660 --> 00:44:53,470
И криптография, на самом деле,
как раз это от недели 0.

919
00:44:53,470 --> 00:44:56,715
>> Это проблема, где есть входы,
как реальное сообщение на английском языке

920
00:44:56,715 --> 00:44:59,340
или любой другой язык, который вы
хотите послать кому-то в классе,

921
00:44:59,340 --> 00:45:00,580
или через Интернет.

922
00:45:00,580 --> 00:45:03,840
Существует некоторый выход, который собирается
чтобы быть скремблированный сообщение, что вы

923
00:45:03,840 --> 00:45:05,250
хочет получатель получить.

924
00:45:05,250 --> 00:45:07,405
И даже если кто-то в
средний получает его тоже,

925
00:45:07,405 --> 00:45:09,780
вы не хотите, чтобы они
обязательно быть в состоянии расшифровать его,

926
00:45:09,780 --> 00:45:12,840
потому что внутри этого
черный ящик, или алгоритм,

927
00:45:12,840 --> 00:45:17,650
это какой-то механизм, некоторые шаг за шагом
инструкции, для принятия этого входа

928
00:45:17,650 --> 00:45:20,710
и превращение его в
выход, в надеюсь безопасным способом.

929
00:45:20,710 --> 00:45:23,640
>> И в самом деле, есть некоторые
словарный запас в этом мире следующим образом.

930
00:45:23,640 --> 00:45:26,100
Обычный текст является слово а
ученый будет

931
00:45:26,100 --> 00:45:28,449
использовать для описания входных
сообщение, как на английском

932
00:45:28,449 --> 00:45:31,240
или любой другой язык вы на самом деле
хотите отправить в какой-то другой человек.

933
00:45:31,240 --> 00:45:35,450
И тогда шифротекст является свалка
к шифрованных или зашифрованы,

934
00:45:35,450 --> 00:45:36,520
его версия.

935
00:45:36,520 --> 00:45:38,750
>> Но есть еще один ингредиент здесь.

936
00:45:38,750 --> 00:45:43,200
Там один другой вход
Секретный ключ шифрования.

937
00:45:43,200 --> 00:45:45,200
И это сам ключ,
который, как правило,

938
00:45:45,200 --> 00:45:48,930
как мы увидим, число или
буква или слово, независимо от

939
00:45:48,930 --> 00:45:51,980
алгоритм это на самом деле ожидает.

940
00:45:51,980 --> 00:45:53,870
>> И как вы расшифровать информацию?

941
00:45:53,870 --> 00:45:55,110
Как вы расшифровывать его?

942
00:45:55,110 --> 00:45:57,950
Ну, вы просто повернуть вспять
выходы и входы.

943
00:45:57,950 --> 00:46:00,900
>> Другими словами, как только кто-то
получает ваше зашифрованное сообщение,

944
00:46:00,900 --> 00:46:03,740
он или она просто имеет
чтобы знать, что тот же ключ.

945
00:46:03,740 --> 00:46:05,700
Они получили шифротекста.

946
00:46:05,700 --> 00:46:09,530
А подключив эти два
входы в систему криптографической,

947
00:46:09,530 --> 00:46:14,260
алгоритм, это черный ящик, из
должен прийти исходный открытый текст.

948
00:46:14,260 --> 00:46:17,830
И так что это очень высокий уровень
вид, что на самом деле криптография

949
00:46:17,830 --> 00:46:18,590
все о.

950
00:46:18,590 --> 00:46:20,030
>> Так что давайте там.

951
00:46:20,030 --> 00:46:22,700
Давайте теперь посмотрим под
капот чего-то

952
00:46:22,700 --> 00:46:26,000
мы принимали как само собой разумеющееся для
на прошлой неделе, и на этой сессии

953
00:46:26,000 --> 00:46:27,629
here-- строку.

954
00:46:27,629 --> 00:46:30,295
Строка в конце дня
это просто последовательность символов.

955
00:46:30,295 --> 00:46:33,610
>> Это может быть привет мир, или
привет Zamyla, или любой другой.

956
00:46:33,610 --> 00:46:37,050
Но что это значит, что
последовательность символов?

957
00:46:37,050 --> 00:46:41,520
На самом деле, библиотека CS50 дает
нам тип данных называется строкой.

958
00:46:41,520 --> 00:46:45,140
>> Но есть на самом деле нет
такая вещь как строка в C.

959
00:46:45,140 --> 00:46:49,450
Это действительно просто последовательность
характер, характер, характер,

960
00:46:49,450 --> 00:46:52,180
характер, спина, к спине, чтобы
назад, к спине, чтобы внутрь

961
00:46:52,180 --> 00:46:54,650
памяти компьютера или ОЗУ.

962
00:46:54,650 --> 00:46:58,940
И мы будем смотреть глубже, что в
будущее, когда мы смотрим на саму память,

963
00:46:58,940 --> 00:47:02,030
и использование, и
угрозы, которые участвуют.

964
00:47:02,030 --> 00:47:04,100
>> Но давайте рассмотрим строку Zamyla.

965
00:47:04,100 --> 00:47:07,480
Так что название
человек здесь, Zamyla,

966
00:47:07,480 --> 00:47:12,030
то есть последовательность
символы, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
А теперь давайте предположим, что имя Zamyla в
Во время сохранения внутри компьютера

968
00:47:16,020 --> 00:47:16,880
Программа.

969
00:47:16,880 --> 00:47:20,830
>> Ну, само собой разумеется, что мы должны
быть в состоянии смотреть на этих персонажей

970
00:47:20,830 --> 00:47:21,590
в индивидуальном порядке.

971
00:47:21,590 --> 00:47:24,710
Так что я просто хочу, чтобы нарисовать немного
рамку вокруг имени Zamyla здесь.

972
00:47:24,710 --> 00:47:31,580
И это происходит в C, что, когда вы
есть строка, как Zamyla-- и, возможно,

973
00:47:31,580 --> 00:47:34,940
эта строка вернулась из
функция как получения строки,

974
00:47:34,940 --> 00:47:38,540
вы можете манипулировать
это символ за символом.

975
00:47:38,540 --> 00:47:42,070
>> Теперь, это релевантно для
Разговор под рукой, потому что

976
00:47:42,070 --> 00:47:46,420
в криптографии, если вы хотите изменить
А в В, и В к С, В и С к D,

977
00:47:46,420 --> 00:47:49,650
и так далее, вы должны быть в состоянии
смотреть на отдельные символы

978
00:47:49,650 --> 00:47:50,190
в строке.

979
00:47:50,190 --> 00:47:52,695
Вы должны быть в состоянии изменить
Зет к чему-то еще, А

980
00:47:52,695 --> 00:47:55,280
к чему-то еще, чтобы М
что-то еще, и так далее.

981
00:47:55,280 --> 00:47:58,000
И поэтому нам нужен способ,
программным способом, так

982
00:47:58,000 --> 00:48:03,020
говорить, в C, чтобы иметь возможность изменить
и посмотреть на отдельные буквы.

983
00:48:03,020 --> 00:48:05,690
И мы можем сделать это следующим образом.

984
00:48:05,690 --> 00:48:08,340
>> Пусти голову назад в CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
И позвольте мне идти вперед
и создать новый файл

986
00:48:11,130 --> 00:48:16,134
что я буду называть этот раз string0,
как наш первый такой пример, точка с.

987
00:48:16,134 --> 00:48:18,300
И я собираюсь идти вперед
и взбить его следующим образом.

988
00:48:18,300 --> 00:48:22,870
>> Так включают CS50.h, и
затем включают в себя стандартные io.h,

989
00:48:22,870 --> 00:48:25,990
который я почти всегда будет
использовать в своих программах, по крайней мере,

990
00:48:25,990 --> 00:48:26,780
первоначально.

991
00:48:26,780 --> 00:48:32,180
INT главную пустоту, а затем здесь я
собирается делать строки получает получить строку.

992
00:48:32,180 --> 00:48:35,260
А потом я собираюсь
идти вперед и делать это.

993
00:48:35,260 --> 00:48:37,460
Я хочу, чтобы идти вперед
и, в качестве проверки вменяемости,

994
00:48:37,460 --> 00:48:43,607
просто сказать, привет, процентов s,
запятой, делает строку 0.

995
00:48:43,607 --> 00:48:44,690
Ой, что же я сделал здесь?

996
00:48:44,690 --> 00:48:45,930
О, я не подключить его.

997
00:48:45,930 --> 00:48:48,120
Так урок, что
не был преднамеренным.

998
00:48:48,120 --> 00:48:52,480
>> Так ошибка, более процентов
преобразования, чем аргументы данных.

999
00:48:52,480 --> 00:48:54,940
И здесь, в
линия 7-- ОК, так что у меня есть,

1000
00:48:54,940 --> 00:48:56,690
цитата Unquote, это
моя строка PRINTF.

1001
00:48:56,690 --> 00:48:58,151
У меня есть знак процента.

1002
00:48:58,151 --> 00:48:59,650
Но я пропускаю второй аргумент.

1003
00:48:59,650 --> 00:49:03,190
>> Я пропускаю запятой с, что
Я имею в предыдущих примерах.

1004
00:49:03,190 --> 00:49:06,650
Так хорошая возможность исправить
еще одна ошибка, случайно.

1005
00:49:06,650 --> 00:49:09,950
А теперь позвольте мне бежать
string0, тип в Zamyla.

1006
00:49:09,950 --> 00:49:10,970
Хорошо, привет Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Таким образом, мы запускаем этот вид программы
несколько различных раз сейчас.

1008
00:49:14,144 --> 00:49:16,310
Но давайте делать что-то
немного по-другому в этот раз.

1009
00:49:16,310 --> 00:49:19,450
Вместо того чтобы просто печать Zamyla-х
полное название с Printf,

1010
00:49:19,450 --> 00:49:21,350
давайте сделаем это символ за символом.

1011
00:49:21,350 --> 00:49:22,700
>> Я собираюсь использовать для цикла.

1012
00:49:22,700 --> 00:49:26,160
И я собираюсь отдать себя
переменная подсчета, называется I.

1013
00:49:26,160 --> 00:49:33,530
И я буду держать перебираете, так
Пока я меньше, чем длина с.

1014
00:49:33,530 --> 00:49:35,930
>> Оказывается, мы не сделали
сделать это в последний раз,

1015
00:49:35,930 --> 00:49:39,100
что с поставляется с
Функция называется Стирлинга.

1016
00:49:39,100 --> 00:49:42,690
Назад в день, а в целом
до сих пор при осуществлении функций,

1017
00:49:42,690 --> 00:49:45,405
люди часто выбирают очень
емкие имена, своего рода звук

1018
00:49:45,405 --> 00:49:48,280
как то, что вы хотите, даже если это
не хватает нескольких гласных звуков или букв.

1019
00:49:48,280 --> 00:49:50,660
Так Стирлинга является
имя функции, которая

1020
00:49:50,660 --> 00:49:53,880
принимает аргумент между
круглые скобки, которые должны быть строкой.

1021
00:49:53,880 --> 00:49:56,910
И это как раз возвращает целое число,
длина этой строки.

1022
00:49:56,910 --> 00:50:00,580
>> Так что этот цикл на линии 7 происходит
Чтобы начать обратный отсчет на я равна 0.

1023
00:50:00,580 --> 00:50:02,530
Это будет увеличиваться
я на каждой итерации

1024
00:50:02,530 --> 00:50:04,350
на 1, как мы делали несколько раз.

1025
00:50:04,350 --> 00:50:06,780
Но это будет только делать
это до точки

1026
00:50:06,780 --> 00:50:09,660
когда я длина
из самой строки.

1027
00:50:09,660 --> 00:50:14,520
>> Так что это путь, в конечном счете,
перебирает персонажей

1028
00:50:14,520 --> 00:50:17,430
в строке А как следует.

1029
00:50:17,430 --> 00:50:20,670
Я собираюсь распечатать не
вся строка, но процент с,

1030
00:50:20,670 --> 00:50:22,860
один символ
а затем новой линии.

1031
00:50:22,860 --> 00:50:24,880
А потом я собираюсь
идти вперед, и мне нужно

1032
00:50:24,880 --> 00:50:29,080
сказать, что я хочу напечатать
Ith характер с.

1033
00:50:29,080 --> 00:50:33,450
>> Так что, если я это переменная, которая указывает
индекс строки, где

1034
00:50:33,450 --> 00:50:37,230
вы в нем, мне нужно, чтобы иметь возможность
говорят, дайте мне ю характер с.

1035
00:50:37,230 --> 00:50:40,390
И с имеет способ сделать
это квадратные скобки.

1036
00:50:40,390 --> 00:50:43,679
Вы просто говорите от имени
строка, которая в данном случае является s.

1037
00:50:43,679 --> 00:50:46,970
Затем вы используете квадратные скобки, которые являются
как правило, чуть выше Return или Enter

1038
00:50:46,970 --> 00:50:48,110
клавиша на клавиатуре.

1039
00:50:48,110 --> 00:50:52,410
И тогда вы положили индекс
символ, который вы хотите напечатать.

1040
00:50:52,410 --> 00:50:55,960
Таким образом, индекс будет
number-- 0, или 1, или 2, или 3, или точка,

1041
00:50:55,960 --> 00:50:57,590
точка, точка, некоторое другое число.

1042
00:50:57,590 --> 00:51:00,920
>> И мы гарантируем, что это будет
быть правильный номер, потому что я

1043
00:51:00,920 --> 00:51:02,360
начать отсчет с 0.

1044
00:51:02,360 --> 00:51:07,020
И по умолчанию, первый символ
в строке является конвенцией 0.

1045
00:51:07,020 --> 00:51:09,230
И второй персонаж кронштейн 1.

1046
00:51:09,230 --> 00:51:11,120
И третий персонаж кронштейн 2.

1047
00:51:11,120 --> 00:51:13,630
И вы не хотите идти слишком
далеко, но мы не будем, потому что мы

1048
00:51:13,630 --> 00:51:17,780
происходит не только приращение I до него
равна длине строки.

1049
00:51:17,780 --> 00:51:20,210
И в этот момент,
этот цикл остановится.

1050
00:51:20,210 --> 00:51:25,550
>> Итак, позвольте мне идти вперед и сохранить этот
программа, и запустить сделать строку 0.

1051
00:51:25,550 --> 00:51:28,400
Но я облажался.

1052
00:51:28,400 --> 00:51:35,390
Косвенно объявляя функции библиотеки
Stirling с типом такой и such-- сейчас,

1053
00:51:35,390 --> 00:51:36,430
это звучит знакомо.

1054
00:51:36,430 --> 00:51:37,440
Но это не PRINTF.

1055
00:51:37,440 --> 00:51:38,540
И это не получить строку.

1056
00:51:38,540 --> 00:51:40,480
>> Я не ввернуть в
так же, как в этот раз.

1057
00:51:40,480 --> 00:51:45,100
Но обратите внимание, здесь немного вниз
кроме того, включать string.h заголовка,

1058
00:51:45,100 --> 00:51:47,210
явным образом предоставить
декларация Стерлинга.

1059
00:51:47,210 --> 00:51:48,820
Так что на самом деле ключ там.

1060
00:51:48,820 --> 00:51:51,670
>> И в самом деле оказывается,
есть еще один файл заголовка

1061
00:51:51,670 --> 00:51:53,970
что мы не использовали
в классе все же, но это

1062
00:51:53,970 --> 00:51:56,480
среди тех, доступны
к вам, называется string.h.

1063
00:51:56,480 --> 00:52:00,930
И в этом файле, string.h
является Стирлинга объявлена.

1064
00:52:00,930 --> 00:52:05,220
Итак, позвольте мне идти вперед и
сохранить это, сделать строку

1065
00:52:05,220 --> 00:52:08,040
0-- приятно, никаких сообщений об ошибках на этот раз.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, и
Я собираюсь нажать кнопку ввода,

1067
00:52:12,290 --> 00:52:16,710
в какой момент происходит GetString
чтобы вернуть строку, поместите ее в с.

1068
00:52:16,710 --> 00:52:21,890
Тогда, что цикл будет перебирать
над символов S один в то время,

1069
00:52:21,890 --> 00:52:28,420
и печатать их по одному в каждой строке, потому что
У меня было, что обратной косой п в конце.

1070
00:52:28,420 --> 00:52:34,530
Так что я мог бы опустить, что обратный слэш
п, а затем просто распечатать все Zamyla

1071
00:52:34,530 --> 00:52:37,460
в той же строке,
эффективно Переопределением

1072
00:52:37,460 --> 00:52:38,999
Printf, что не все, что полезно.

1073
00:52:38,999 --> 00:52:40,540
Но в данном случае, я не сделал этого.

1074
00:52:40,540 --> 00:52:43,610
Я на самом деле распечатываются
характер, в то время, по одному в каждой строке,

1075
00:52:43,610 --> 00:52:45,400
так что мы на самом деле увидеть эффект.

1076
00:52:45,400 --> 00:52:46,900
>> Но я должен отметить одну вещь здесь.

1077
00:52:46,900 --> 00:52:48,930
И мы вернемся к
это в будущей неделе.

1078
00:52:48,930 --> 00:52:52,650
Оказывается, что это
код потенциально глючный.

1079
00:52:52,650 --> 00:52:56,560
>> Оказывается, что получить строку
и некоторые другие функции в жизни

1080
00:52:56,560 --> 00:53:00,280
не обязательно всегда
вернуть то, что вы ожидали.

1081
00:53:00,280 --> 00:53:03,010
Мы знаем из класса последнего
Время в этом, что получить

1082
00:53:03,010 --> 00:53:04,960
строка должна возвращать строку.

1083
00:53:04,960 --> 00:53:09,900
Но что, если пользователь печатает такие
длинное слово или абзац, или эссе

1084
00:53:09,900 --> 00:53:13,010
что там просто не хватает
памяти в компьютере, чтобы соответствовать его.

1085
00:53:13,010 --> 00:53:15,410
>> Как и то, что если что-то идет
неправильно под капотом?

1086
00:53:15,410 --> 00:53:18,400
Это не может произойти часто,
но это может произойти один раз

1087
00:53:18,400 --> 00:53:21,520
в то время, очень редко.

1088
00:53:21,520 --> 00:53:25,460
И так получается, что получить строку
и функции подобные ему не обязательно

1089
00:53:25,460 --> 00:53:26,380
всегда возвращать строки.

1090
00:53:26,380 --> 00:53:30,680
Они могут возвращать некоторое значение ошибки,
некоторое значение сторожевого так сказать,

1091
00:53:30,680 --> 00:53:32,612
что указывает на то, что
что-то пошло не так.

1092
00:53:32,612 --> 00:53:35,320
И вы бы знали только это из
узнав его в классе сейчас,

1093
00:53:35,320 --> 00:53:37,700
или прочитав некоторую дополнительную документацию.

1094
00:53:37,700 --> 00:53:43,120
Оказывается, что получить строку
может возвращать значение, называемое нулевым.

1095
00:53:43,120 --> 00:53:46,220
Нулевой это специальное значение, что мы будем
вернуться в будущей недели.

1096
00:53:46,220 --> 00:53:50,420
Но сейчас, просто знаю, что если я хочу
чтобы быть действительно собственно в продвижении вперед

1097
00:53:50,420 --> 00:53:52,650
с помощью получения строки, я
не должны просто назвать его,

1098
00:53:52,650 --> 00:53:56,870
и слепо использовать возвращаемое значение,
полагая, что это строка.

1099
00:53:56,870 --> 00:53:59,420
>> Я должен сначала сказать,
Эй, подождите минуту, только

1100
00:53:59,420 --> 00:54:03,380
действовать, если s не равно
нуль, где нуль, опять же,

1101
00:54:03,380 --> 00:54:04,660
это просто какое-то особое значение.

1102
00:54:04,660 --> 00:54:07,770
И это единственное специальное значение, которое вы
нужно беспокоиться о для получения строки.

1103
00:54:07,770 --> 00:54:10,900
Получить строка либо собирается
возвращать строку или NULL.

1104
00:54:10,900 --> 00:54:17,219
>> И эта точка восклицательный знак равенства
вы могли бы знать, от возможно математическом классе

1105
00:54:17,219 --> 00:54:20,510
что вы могли бы нарисовать знак равенства с
линия, проходящая через него, чтобы указать, не равны.

1106
00:54:20,510 --> 00:54:23,135
Это вообще не персонаж
вы можете набрать на клавиатуре.

1107
00:54:23,135 --> 00:54:26,480
И поэтому в большинстве языков программирования,
когда вы хотите сказать, не равны,

1108
00:54:26,480 --> 00:54:29,160
вы используете восклицательный знак,
иначе известный как взрыв.

1109
00:54:29,160 --> 00:54:33,180
Так вы говорите, челка равно, что
означает не равно, по логике вещей.

1110
00:54:33,180 --> 00:54:38,060
Это так же, как там не больше
чем, или равное или меньше

1111
00:54:38,060 --> 00:54:41,270
или равно клавишу на клавиатуре
что делает все это в одном символе.

1112
00:54:41,270 --> 00:54:44,020
Так вот почему, в прошлых примерах,
вы сделали открытый кронштейн, а затем

1113
00:54:44,020 --> 00:54:48,670
знак равенства, для того, чтобы сделать
больше или, скажем, меньше.

1114
00:54:48,670 --> 00:54:49,910
>> Так что вынос здесь?

1115
00:54:49,910 --> 00:54:53,880
Это просто способ теперь
введение этого синтаксиса, эта функция,

1116
00:54:53,880 --> 00:54:57,390
перебирает частных лиц
символов в строке.

1117
00:54:57,390 --> 00:55:00,260
И точно так же, как те площади
кронштейны позволяют получить на них,

1118
00:55:00,260 --> 00:55:03,790
рассмотреть эти квадратные скобки
вид намекая на это основной

1119
00:55:03,790 --> 00:55:06,040
дизайн, в результате чего каждый
символ внутри строки

1120
00:55:06,040 --> 00:55:10,180
является своего рода зажаты в где-то внизу
капот в памяти вашего компьютера.

1121
00:55:10,180 --> 00:55:12,340
>> Но давайте сделаем вариант этого.

1122
00:55:12,340 --> 00:55:14,880
Оказывается, что это
программа верна.

1123
00:55:14,880 --> 00:55:18,810
Таким образом, на оси CS50 для оценки
код, теперь это правильно.

1124
00:55:18,810 --> 00:55:22,959
Особенно теперь, когда я проверка
нуль, эта программа никогда не должна врезаться.

1125
00:55:22,959 --> 00:55:24,500
И я просто знаю, что из опыта.

1126
00:55:24,500 --> 00:55:28,040
Но нет ничего, что
мы можем действительно пойти не так здесь.

1127
00:55:28,040 --> 00:55:31,860
Но это не очень хорошо продуманные,
потому что давайте вернемся к основам.

1128
00:55:31,860 --> 00:55:34,450
>> Во-первых, principles--
что делает цикл делать?

1129
00:55:34,450 --> 00:55:36,290
Для цикла делает три вещи.

1130
00:55:36,290 --> 00:55:39,340
Она инициализирует некоторые
значение, если вы попросите его.

1131
00:55:39,340 --> 00:55:41,770
Он проверяет состояние.

1132
00:55:41,770 --> 00:55:45,380
А потом после каждого
итерации, после каждого цикла,

1133
00:55:45,380 --> 00:55:49,330
он увеличивает некоторые
значение или значения, здесь.

1134
00:55:49,330 --> 00:55:50,600
>> Так что это значит?

1135
00:55:50,600 --> 00:55:52,940
Мы инициализируем я до 0.

1136
00:55:52,940 --> 00:55:58,610
Мы проверяем и убедитесь, что я меньше
длина с, что Z-А-М-У-Л-А,

1137
00:55:58,610 --> 00:55:59,900
так что меньше 6.

1138
00:55:59,900 --> 00:56:02,590
И в самом деле, 0, как менее 6.

1139
00:56:02,590 --> 00:56:05,580
>> Мы распечатать Z от имени Zamyla в.

1140
00:56:05,580 --> 00:56:08,080
Тогда мы увеличиваем I от 0 до 1.

1141
00:56:08,080 --> 00:56:11,290
Затем мы проверяем, 1 меньше
чем длина S?

1142
00:56:11,290 --> 00:56:13,270
Длина S составляет 6.

1143
00:56:13,270 --> 00:56:13,950
Да.

1144
00:56:13,950 --> 00:56:16,880
>> Таким образом, мы печатаем в имени Zamyla, в ZA.

1145
00:56:16,880 --> 00:56:20,090
Мы увеличиваем I от 0, 1, до 2.

1146
00:56:20,090 --> 00:56:23,720
Затем мы проверяем, на 2 меньше
длина имени Zamyla в.

1147
00:56:23,720 --> 00:56:25,380
6- так 2 составляет менее 6.

1148
00:56:25,380 --> 00:56:30,460
Да, давайте распечатать прямо сейчас M в
имя Zamyla, в третий символ.

1149
00:56:30,460 --> 00:56:34,110
>> Ключевым моментом здесь является то, что на каждом
итерация этой истории, я проверяю,

1150
00:56:34,110 --> 00:56:37,810
это я меньше, чем длина Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Но загвоздка в том, что
Stirling не является свойством.

1152
00:56:40,350 --> 00:56:43,100
Те из вас, кто программировал
до этого в Java или других языках

1153
00:56:43,100 --> 00:56:46,310
может знать длину строки является
свойство, только некоторые только для чтения значение.

1154
00:56:46,310 --> 00:56:50,220
>> В С в этом случае, если это
функция, которая в буквальном смысле

1155
00:56:50,220 --> 00:56:53,520
подсчета количества
символы в Zamyla каждый раз, когда

1156
00:56:53,520 --> 00:56:54,740
мы называем эту функцию.

1157
00:56:54,740 --> 00:56:58,500
Каждый раз, когда вы просите компьютер, чтобы использовать
Stirling, это взглянуть на Zamyla,

1158
00:56:58,500 --> 00:57:01,960
и говоря: Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
И это возвращает 6.

1160
00:57:02,962 --> 00:57:04,920
В следующий раз, когда вы звоните
то внутри, что цикл,

1161
00:57:04,920 --> 00:57:08,610
это будет смотреть на Zamyla
опять, скажем Z-А-М-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
И он собирается вернуться 6.

1163
00:57:10,320 --> 00:57:12,980
Так что глупо об этом проекте?

1164
00:57:12,980 --> 00:57:17,700
>> Почему мой код не 5 из 5
для дизайна прямо сейчас, так сказать?

1165
00:57:17,700 --> 00:57:20,600
Ну, Я спрашиваю
вопрос излишне.

1166
00:57:20,600 --> 00:57:23,030
Я делаю больше работы, чем мне нужно.

1167
00:57:23,030 --> 00:57:25,370
>> Таким образом, даже несмотря на то,
ответ правильный, я

1168
00:57:25,370 --> 00:57:29,560
спрашивая компьютер, что такое
длина Zamyla снова,

1169
00:57:29,560 --> 00:57:31,380
и снова, и снова, и снова?

1170
00:57:31,380 --> 00:57:33,980
И этот ответ
никогда не изменится.

1171
00:57:33,980 --> 00:57:35,900
Это всегда будет 6.

1172
00:57:35,900 --> 00:57:39,730
>> Таким образом, лучшее решение, чем это
будет это следующая версия.

1173
00:57:39,730 --> 00:57:43,390
Позвольте мне идти вперед и положить его в
отдельный файл с именем string1.c,

1174
00:57:43,390 --> 00:57:44,990
просто держать его отдельно.

1175
00:57:44,990 --> 00:57:47,260
И получается, в течение
цикл, вы можете на самом деле

1176
00:57:47,260 --> 00:57:50,210
объявить несколько переменных одновременно.

1177
00:57:50,210 --> 00:57:53,460
>> Так что я буду держать я и установить его в 0.

1178
00:57:53,460 --> 00:57:56,190
Но я также собираюсь
добавьте запятую, и сказать,

1179
00:57:56,190 --> 00:58:01,050
дайте мне переменную п, у которого
значение равно значению длину строки с.

1180
00:58:01,050 --> 00:58:09,410
А теперь, пожалуйста, мое состояние
до тех пор, как я меньше п.

1181
00:58:09,410 --> 00:58:14,140
>> Итак, таким образом, логика
идентичны в конце дня.

1182
00:58:14,140 --> 00:58:18,280
Но я вспоминая
значение 6, в этом случае.

1183
00:58:18,280 --> 00:58:19,780
Какова длина имени Zamyla в?

1184
00:58:19,780 --> 00:58:20,860
И я ставлю его в п.

1185
00:58:20,860 --> 00:58:23,050
>> И я до сих пор проверки
условие каждый раз.

1186
00:58:23,050 --> 00:58:24,300
Является 0 меньше, чем 6?

1187
00:58:24,300 --> 00:58:25,600
1 меньше, чем 6?

1188
00:58:25,600 --> 00:58:28,600
Есть 2 меньше, чем 6, и так далее?

1189
00:58:28,600 --> 00:58:31,914
>> Но я не требую компьютер
снова и снова, что

1190
00:58:31,914 --> 00:58:33,080
длина имени Zamyla в?

1191
00:58:33,080 --> 00:58:34,320
Что длина имени Zamyla в?

1192
00:58:34,320 --> 00:58:35,986
Что длина имени этого Zamyla в?

1193
00:58:35,986 --> 00:58:40,440
Я буквально помнить, что первый и
ответить только в этой второй переменной п.

1194
00:58:40,440 --> 00:58:45,280
Так что это сейчас было бы не только
правильно, но и хорошо продуманные.

1195
00:58:45,280 --> 00:58:46,670
>> Теперь, что касается стиля?

1196
00:58:46,670 --> 00:58:48,866
Я назвал мои переменные
очень хорошо, я бы сказал.

1197
00:58:48,866 --> 00:58:50,240
сейчас они супер лаконичным.

1198
00:58:50,240 --> 00:58:52,090
И это совершенно нормально.

1199
00:58:52,090 --> 00:58:55,120
>> Если у вас есть только один
строка в программе,

1200
00:58:55,120 --> 00:58:56,860
Вы могли бы также назвать это S для строки.

1201
00:58:56,860 --> 00:58:59,370
Если у вас есть только одна переменная
для подсчета в программе,

1202
00:58:59,370 --> 00:59:00,710
Вы могли бы также назвать это я.

1203
00:59:00,710 --> 00:59:03,500
Если у вас есть длина, п
супер часто, как хорошо.

1204
00:59:03,500 --> 00:59:05,800
Но я не заметил какой-либо из моего кода.

1205
00:59:05,800 --> 00:59:09,200
>> Я не сообщил reader--
что будь моя TF, или TA,

1206
00:59:09,200 --> 00:59:12,460
или просто colleague-- то, что, как предполагается,
чтобы идти дальше в этой программе.

1207
00:59:12,460 --> 00:59:15,760
И так, чтобы получить хороший стиль,
то, что я хотел бы сделать

1208
00:59:15,760 --> 00:59:24,580
это что-то this--
как спросить пользователя для входа.

1209
00:59:24,580 --> 00:59:26,670
И я мог бы переписать
это любое количество способов.

1210
00:59:26,670 --> 00:59:35,630
>> Убедитесь, что S-- убедитесь ПОЛУЧАЕТ
Строка, возвращаемая строка.

1211
00:59:35,630 --> 00:59:40,280
А потом в here--, и это, возможно,
самым важным comment-- итерация

1212
00:59:40,280 --> 00:59:44,450
над персонажами с одной одновременно.

1213
00:59:44,450 --> 00:59:47,060
И я мог бы использовать любой
Выбор английского языка

1214
00:59:47,060 --> 00:59:49,650
здесь, чтобы описать каждый
из этих кусков кода.

1215
00:59:49,650 --> 00:59:52,740
>> Обратите внимание на то, что я не оставляется
комментировать каждую строку кода,

1216
00:59:52,740 --> 00:59:55,690
на самом деле просто на интересный
из них, те,

1217
00:59:55,690 --> 00:59:59,460
есть какой-то смысл, что я мог бы
хотят, чтобы сделать супер ясный кому-то

1218
00:59:59,460 --> 01:00:00,460
чтение моего кода.

1219
01:00:00,460 --> 01:00:02,920
А почему ты звонишь получить
строка запрашивает у пользователя для входа?

1220
01:00:02,920 --> 01:00:05,450
Даже то, что один не обязательно
все, что описательный характер.

1221
01:00:05,450 --> 01:00:09,340
Но это помогает рассказать историю, потому что
Вторая строка в истории есть, убедитесь,

1222
01:00:09,340 --> 01:00:10,740
получить строки, возвращенной строку.

1223
01:00:10,740 --> 01:00:14,260
>> И третья строка в этой истории,
перебирать символов в одном ами

1224
01:00:14,260 --> 01:00:15,380
вовремя.

1225
01:00:15,380 --> 01:00:17,920
А теперь просто для хорошей мерой,
Я собираюсь идти вперед и добавить

1226
01:00:17,920 --> 01:00:24,560
еще один комментарий, который как раз
говорит печать I-й символ в с.

1227
01:00:24,560 --> 01:00:26,520
Теперь, что я сделал
в конце дня?

1228
01:00:26,520 --> 01:00:29,190
>> Я добавил некоторые английские
Слова в виде комментариев.

1229
01:00:29,190 --> 01:00:32,700
Символ косая черта означает, эй,
Компьютер это для человека,

1230
01:00:32,700 --> 01:00:33,820
не для вас, компьютер.

1231
01:00:33,820 --> 01:00:35,119
Таким образом, они игнорируются логически.

1232
01:00:35,119 --> 01:00:35,910
Они просто есть.

1233
01:00:35,910 --> 01:00:39,830
>> И действительно, CS50 IDE показывает их как
серый, как полезные, но не ключ

1234
01:00:39,830 --> 01:00:41,000
к программе.

1235
01:00:41,000 --> 01:00:42,570
Обратите внимание на то, что теперь вы можете сделать.

1236
01:00:42,570 --> 01:00:44,950
Знаете ли вы C
программирования или нет,

1237
01:00:44,950 --> 01:00:47,722
может просто стоять в стороне в этом
Программа, и обезжиренное комментарии.

1238
01:00:47,722 --> 01:00:50,180
Попросите пользователя для ввода, убедитесь,
получить строки, возвращенной строку,

1239
01:00:50,180 --> 01:00:53,009
перебирать символов в сек
по одному за раз, напечатать символ

1240
01:00:53,009 --> 01:00:55,550
I-й символ в S-- вы этого не сделаете
даже смотреть на код

1241
01:00:55,550 --> 01:00:57,270
чтобы понять, что делает эта программа.

1242
01:00:57,270 --> 01:01:00,280
И еще лучше, если вы сами смотрите
в этой программе в течение недели или двух,

1243
01:01:00,280 --> 01:01:02,280
или месяц, или год,
вы тоже не имеете

1244
01:01:02,280 --> 01:01:04,420
смотреть на код,
пытаясь вспомнить,

1245
01:01:04,420 --> 01:01:06,630
что я пытаюсь сделать с этим кодом?

1246
01:01:06,630 --> 01:01:07,770
>> Вы сказали себе.

1247
01:01:07,770 --> 01:01:11,660
Вы описали это для себя,
или какой-нибудь коллега или ТА, или TF.

1248
01:01:11,660 --> 01:01:14,860
И так это теперь будет
правильно, и хороший дизайн,

1249
01:01:14,860 --> 01:01:18,210
и в конечном счете, хороший стиль, а также.

1250
01:01:18,210 --> 01:01:19,990
Так что имейте это в виду.

1251
01:01:19,990 --> 01:01:22,200
>> Так что есть еще одна
что я собираюсь сделать здесь

1252
01:01:22,200 --> 01:01:28,240
что теперь может показать именно то, что
происходит под капотом.

1253
01:01:28,240 --> 01:01:30,390
Так что эта функция
в C и других языках,

1254
01:01:30,390 --> 01:01:33,010
называется типажей
что либо неявно

1255
01:01:33,010 --> 01:01:37,250
или явно позволяет конвертировать
от одного типа данных в другой.

1256
01:01:37,250 --> 01:01:39,800
Мы имеем дело так
далеко сегодня со строками.

1257
01:01:39,800 --> 01:01:41,250
>> И строки символов.

1258
01:01:41,250 --> 01:01:44,910
Но помните из недели
0, какие символы?

1259
01:01:44,910 --> 01:01:49,334
Символы просто абстракция
на вершине numbers-- десятичных чисел,

1260
01:01:49,334 --> 01:01:52,500
и десятичных чисел действительно просто
абстракция на вершине двоичных чисел,

1261
01:01:52,500 --> 01:01:53,720
как мы определили ее.

1262
01:01:53,720 --> 01:01:55,540
>> Так символы номера.

1263
01:01:55,540 --> 01:01:58,410
И цифры символов,
только в зависимости от контекста.

1264
01:01:58,410 --> 01:02:01,250
И получается, что внутри
компьютерной программы,

1265
01:02:01,250 --> 01:02:06,830
Вы можете указать, как вы хотите выглядеть
в биты внутри этой программы?

1266
01:02:06,830 --> 01:02:10,400
>> Напомним, от недели 0, что у нас было
Ascii, что именно этот код

1267
01:02:10,400 --> 01:02:11,620
отображение букв к цифрам.

1268
01:02:11,620 --> 01:02:13,660
И мы сказали, капитал А 65.

1269
01:02:13,660 --> 01:02:15,860
Капитал Б 66, и так далее.

1270
01:02:15,860 --> 01:02:20,500
>> И заметьте, мы, по существу есть символы на
верхний ряд здесь, как C назовет их,

1271
01:02:20,500 --> 01:02:23,400
символов, а затем
Интс на втором ряду.

1272
01:02:23,400 --> 01:02:28,180
И получается, вы можете конвертировать
бесшовно между ними, как правило.

1273
01:02:28,180 --> 01:02:30,042
И если мы хотим сделать
это сознательно, мы

1274
01:02:30,042 --> 01:02:31,750
может понадобиться для решения
что-то вроде этого.

1275
01:02:31,750 --> 01:02:33,590
>> Мы могли бы хотеть, чтобы преобразовать
верхний регистр, чтобы понизить

1276
01:02:33,590 --> 01:02:35,330
случай, или нижний регистр в верхний регистр.

1277
01:02:35,330 --> 01:02:38,000
И получается, что есть
на самом деле картина здесь

1278
01:02:38,000 --> 01:02:39,900
мы можем охватить всего минуту.

1279
01:02:39,900 --> 01:02:44,120
Но давайте сначала посмотрим на
Пример выполнения этого в явном виде.

1280
01:02:44,120 --> 01:02:46,340
>> Я собираюсь вернуться в CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Я собираюсь создать
файл с именем Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
И я собираюсь идти вперед и добавить мой
стандарт io.h в верхней части, INT Основная пустота

1283
01:02:55,960 --> 01:02:57,370
в верхней части моей функции.

1284
01:02:57,370 --> 01:03:02,700
А потом я просто буду делать
following-- для цикла от я равна,

1285
01:03:02,700 --> 01:03:04,610
скажем, 65 лет.

1286
01:03:04,610 --> 01:03:10,460
>> И тогда я будет меньше
65, плюс 26 букв в алфавите.

1287
01:03:10,460 --> 01:03:12,640
Так что я дам компьютер
делать математику для меня там.

1288
01:03:12,640 --> 01:03:15,100
А потом внутри этой петли,
что я буду печатать?

1289
01:03:15,100 --> 01:03:19,230
>> % С является% я обратной косой черты п.

1290
01:03:19,230 --> 01:03:21,290
А теперь я хочу, чтобы подключить два значения.

1291
01:03:21,290 --> 01:03:24,530
Я временно поставил вопрос
Оценки там пригласить на этот вопрос.

1292
01:03:24,530 --> 01:03:29,940
>> Я хочу итерацию от 65 вперед
для 26 букв алфавита,

1293
01:03:29,940 --> 01:03:35,190
печать на каждой итерации, что
интегральный эквивалент персонажа.

1294
01:03:35,190 --> 01:03:38,299
Другими словами, я хочу
перебрать 26 номеров печати

1295
01:03:38,299 --> 01:03:41,590
что Ascii символ, буква,
и что соответствующее число is--

1296
01:03:41,590 --> 01:03:44,650
на самом деле просто воссоздание
диаграмма из этого слайда.

1297
01:03:44,650 --> 01:03:47,010
Так что же эти знаки вопроса быть?

1298
01:03:47,010 --> 01:03:51,760
>> Что ж, получается, что второй
нужно просто быть переменной я.

1299
01:03:51,760 --> 01:03:53,860
Я хочу видеть, что как число.

1300
01:03:53,860 --> 01:03:58,920
А средний аргумент
здесь, я могу сказать компьютеру

1301
01:03:58,920 --> 01:04:03,470
для лечения, что число
я как характер, так

1302
01:04:03,470 --> 01:04:05,880
заменить его здесь процентов C.

1303
01:04:05,880 --> 01:04:07,990
>> Другими словами, если я, то
человек программист, знаю,

1304
01:04:07,990 --> 01:04:09,865
это просто цифры
в конце дня.

1305
01:04:09,865 --> 01:04:12,500
И я знаю, что 65 должен
карта в какой-то характер.

1306
01:04:12,500 --> 01:04:15,310
С помощью этого явного приведения типов,
с скобкой,

1307
01:04:15,310 --> 01:04:18,840
имя типа данных, который вы хотите
конвертировать, и закрытым скобка,

1308
01:04:18,840 --> 01:04:21,200
Вы можете сказать
компьютер, эй, компьютер,

1309
01:04:21,200 --> 01:04:24,130
преобразовать это число в символ.

1310
01:04:24,130 --> 01:04:26,250
>> Так что, когда я запускаю это
программа после компиляции,

1311
01:04:26,250 --> 01:04:29,740
давайте посмотрим, что я get-- сделать Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Чёрт это, что я сделал неправильно здесь?

1313
01:04:33,020 --> 01:04:35,884
Использование незаявленных идентификатора,
все в порядке, не намеренно,

1314
01:04:35,884 --> 01:04:37,800
но давайте посмотрим, если мы не можем
Причина через это.

1315
01:04:37,800 --> 01:04:41,220
>> Так линия five-- так что я не получил
очень далеко, прежде чем завинчивания.

1316
01:04:41,220 --> 01:04:42,140
Ничего страшного.

1317
01:04:42,140 --> 01:04:46,560
Таким образом, линия 5 для г равна 65-- я вижу.

1318
01:04:46,560 --> 01:04:50,130
Так что помните, что в C, в отличие от некоторых
языки, если у вас есть предварительное программирование

1319
01:04:50,130 --> 01:04:52,190
опыт, у вас есть
чтобы сказать компьютеру,

1320
01:04:52,190 --> 01:04:55,040
в отличие от нуля, то,
тип переменной она.

1321
01:04:55,040 --> 01:04:56,860
>> И я забыл ключевую фразу здесь.

1322
01:04:56,860 --> 01:04:59,200
В строке пять, я начал использовать I.

1323
01:04:59,200 --> 01:05:01,560
Но я не сказал C
какие данные типа это.

1324
01:05:01,560 --> 01:05:04,570
Так что я собираюсь идти сюда и
говорят, ах, сделать это целое число.

1325
01:05:04,570 --> 01:05:07,050
>> Теперь я собираюсь идти вперед и перекомпилировать.

1326
01:05:07,050 --> 01:05:08,080
Это зафиксировано, что.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, это своего рода прохладный.

1328
01:05:12,660 --> 01:05:15,360
Мало того, что это супер быстро
спросить компьютер на этот вопрос,

1329
01:05:15,360 --> 01:05:18,885
а не смотреть его на слайд,
она распечатывается по одному в каждой строке, А 65,

1330
01:05:18,885 --> 01:05:24,860
B 66, все пути down--, так как я
сделал это 26 times-- с буквами г,

1331
01:05:24,860 --> 01:05:25,630
что составляет 90.

1332
01:05:25,630 --> 01:05:27,790
И в самом деле, немного
более разумным будет

1333
01:05:27,790 --> 01:05:31,030
были для меня не полагаться
на компьютере, чтобы добавить 26.

1334
01:05:31,030 --> 01:05:34,060
Я мог бы просто сделать
90, а также, до тех пор,

1335
01:05:34,060 --> 01:05:37,390
как я не делают ту же ошибку дважды.

1336
01:05:37,390 --> 01:05:41,880
Я хочу, чтобы идти через
г, а не только через у.

1337
01:05:41,880 --> 01:05:44,000
>> Так что это явное приведение.

1338
01:05:44,000 --> 01:05:47,860
Оказывается, что это
даже нет необходимости.

1339
01:05:47,860 --> 01:05:52,480
Позвольте мне идти вперед и повторно запустить этот
компилятор, и перекладка Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Оказывается, что C является довольно умный.

1341
01:05:54,940 --> 01:05:57,150
>> И Printf, в частности,
довольно умный.

1342
01:05:57,150 --> 01:06:01,260
Если вы просто пройти я дважды
для обоих заполнителей, Printf

1343
01:06:01,260 --> 01:06:04,510
поймут, ой, ну я тебя знаю
дал мне integer-- некоторое число,

1344
01:06:04,510 --> 01:06:06,380
как 65, или 90, или любой другой.

1345
01:06:06,380 --> 01:06:10,170
Но я вижу, что вы хотите, чтобы я
форматирования это число как символ.

1346
01:06:10,170 --> 01:06:16,460
И поэтому Printf может неявно приведен
ИНТ к полукокса для вас.

1347
01:06:16,460 --> 01:06:19,360
Так что это не проблема вообще.

1348
01:06:19,360 --> 01:06:23,100
>> Но обратите внимание, из-за этой эквивалентности
мы можем на самом деле сделать это, как хорошо.

1349
01:06:23,100 --> 01:06:26,520
Позвольте мне идти вперед и сделать один
другая версия this-- Ascii 1.C.

1350
01:06:26,520 --> 01:06:31,800
И вместо того, чтобы перебирает
целые числа, действительно может взорвать ваш ум

1351
01:06:31,800 --> 01:06:33,610
перебирает символов.

1352
01:06:33,610 --> 01:06:37,660
Если символ с получает капитал A, I
хотят, чтобы идти вперед и делать это,

1353
01:06:37,660 --> 01:06:41,740
до тех пор, С меньше или равно
для капитала Z. И на каждой итерации

1354
01:06:41,740 --> 01:06:45,690
Я хочу, чтобы увеличить C, я могу
Теперь в моей PRINTF линии здесь

1355
01:06:45,690 --> 01:06:51,320
скажем, процентов С
процентов я снова, разделенные C.

1356
01:06:51,320 --> 01:06:57,200
>> А теперь, я могу пойти в другом направлении,
литье характер явно

1357
01:06:57,200 --> 01:06:58,500
в целое число.

1358
01:06:58,500 --> 01:07:00,560
Так что, опять же, зачем вы это делаете?

1359
01:07:00,560 --> 01:07:03,830
Это немного странно рода
рассчитывать с точки зрения персонажей.

1360
01:07:03,830 --> 01:07:07,430
>> Но если вы понимаете, что это
происходит под капотом,

1361
01:07:07,430 --> 01:07:08,430
нет действительно никакой магии.

1362
01:07:08,430 --> 01:07:13,060
Ты говоришь, эй, компьютер даст
меня переменная называется C типа полукокса.

1363
01:07:13,060 --> 01:07:16,520
Инициализировать его капитала А. И
заметить одиночные кавычки материи.

1364
01:07:16,520 --> 01:07:19,580
>> Для символов в C, помните из
На прошлой неделе, вы используете одиночные кавычки.

1365
01:07:19,580 --> 01:07:23,720
Для строк, слов,
фразы, вы используете двойные кавычки.

1366
01:07:23,720 --> 01:07:27,210
OK, компьютер, продолжайте делать это, так
Пока символ меньше

1367
01:07:27,210 --> 01:07:28,050
или равна г.

1368
01:07:28,050 --> 01:07:32,640
И я знаю, что от моего Ascii таблицы, что все
из этих кодов ASCII являются смежными.

1369
01:07:32,640 --> 01:07:33,400
>> Там нет никаких пробелов.

1370
01:07:33,400 --> 01:07:36,737
Так что это просто от А до Z,
разделенных одним номером каждого.

1371
01:07:36,737 --> 01:07:38,820
И тогда я могу увеличивать
полукокса, если я действительно хочу.

1372
01:07:38,820 --> 01:07:40,390
В конце дня,
это просто число.

1373
01:07:40,390 --> 01:07:41,030
Я знаю это.

1374
01:07:41,030 --> 01:07:43,670
Так что я могу только предположить, чтобы добавить к нему 1.

1375
01:07:43,670 --> 01:07:46,940
>> А потом на этот раз, я печатаю с,
а затем интегральный эквивалент.

1376
01:07:46,940 --> 01:07:50,170
И я даже не нужно явное приведение.

1377
01:07:50,170 --> 01:07:52,680
Я могу позволить Printf и тому
компьютер понять вещи,

1378
01:07:52,680 --> 01:07:57,300
так что теперь, если я бегу
сделать Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Я получаю точно такую ​​же вещь, как хорошо.

1380
01:08:01,520 --> 01:08:04,530
>> Бесполезная программа, не though-- ни одного
собирается на самом деле написать программное обеспечение

1381
01:08:04,530 --> 01:08:07,549
для того, чтобы выяснить, что было
число, которое отображается в А или В, или Z?

1382
01:08:07,549 --> 01:08:10,340
Ты просто гуглить это, или
посмотреть его в Интернете, или посмотреть его

1383
01:08:10,340 --> 01:08:11,650
на слайде, или тому подобное.

1384
01:08:11,650 --> 01:08:13,520
Так где же это на самом деле получить полезно?

1385
01:08:13,520 --> 01:08:15,960
>> Ну, если говорить о том, что
слайд, обратите внимание, что есть

1386
01:08:15,960 --> 01:08:20,890
фактическая картина здесь между заглавными буквами
и в нижнем регистре, что не было случайным.

1387
01:08:20,890 --> 01:08:23,760
Обратите внимание на то, что капитал А 65.

1388
01:08:23,760 --> 01:08:25,830
Строчные а является 97.

1389
01:08:25,830 --> 01:08:29,649
И как далеко ниже случай а?

1390
01:08:29,649 --> 01:08:32,649
>> Таким образом, 65 сколько шагов от 97?

1391
01:08:32,649 --> 01:08:36,210
Таким образом, 97 минус 65 равно 32.

1392
01:08:36,210 --> 01:08:37,910
Таким образом, капитал 65 а есть.

1393
01:08:37,910 --> 01:08:39,939
При добавлении 32 к этому,
Вы получаете в нижнем регистре а.

1394
01:08:39,939 --> 01:08:43,729
И, что то же самое, если вычесть 32,
вы получите обратно в столицу A-- же с B

1395
01:08:43,729 --> 01:08:46,380
маленькому б, большой С до мало с.

1396
01:08:46,380 --> 01:08:50,670
>> Все эти зазоры 32 друг от друга.

1397
01:08:50,670 --> 01:08:54,450
Теперь, это, казалось бы, чтобы позволить нам
сделать что-то вроде Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
или Google Docs есть, где вы
Можно выбрать все, а затем сказать,

1399
01:08:57,729 --> 01:09:00,520
изменить все в нижнем регистре, или
изменить все в верхний регистр,

1400
01:09:00,520 --> 01:09:03,840
или изменить только первое слово
приговора к верхнему регистру.

1401
01:09:03,840 --> 01:09:07,390
Мы можем сделать что-то
как и мы сами.

1402
01:09:07,390 --> 01:09:12,645
>> Позвольте мне идти вперед и сохранить файл
здесь называется капитализировать 0.c.

1403
01:09:12,645 --> 01:09:15,770
И давайте идти вперед и нагнетать программу
что делает именно то, что следующим образом.

1404
01:09:15,770 --> 01:09:18,460
Так включают в себя библиотеку CS50.

1405
01:09:18,460 --> 01:09:21,430
И включают в себя стандартные входы / выходы.

1406
01:09:21,430 --> 01:09:22,787
>> И я знаю, что это в ближайшее время.

1407
01:09:22,787 --> 01:09:24,870
Так что я собираюсь поставить его в
там уже, string.h,

1408
01:09:24,870 --> 01:09:26,960
поэтому у меня есть доступ к
такие вещи, как Стирлинг,

1409
01:09:26,960 --> 01:09:29,620
а затем INT главную пустоту, как обычно.

1410
01:09:29,620 --> 01:09:33,420
А потом я собираюсь идти вперед
и делать строки получает получить строку,

1411
01:09:33,420 --> 01:09:35,032
просто, чтобы получить строку от пользователя.

1412
01:09:35,032 --> 01:09:36,740
А потом я собираюсь
сделать мой чек вменяемость.

1413
01:09:36,740 --> 01:09:40,510
Если строка не равна нулю,
то это безопасно продолжить работу.

1414
01:09:40,510 --> 01:09:42,000
И то, что я хочу сделать?

1415
01:09:42,000 --> 01:09:48,700
Я собираюсь перебирать от я равен 0,
и п до длина строки с.

1416
01:09:48,700 --> 01:09:51,899
>> И я собираюсь сделать это до тех пор,
я меньше п, и я плюс плюс.

1417
01:09:51,899 --> 01:09:55,060
До сих пор, я на самом деле просто
заимствование идеи раньше.

1418
01:09:55,060 --> 01:09:57,010
А теперь я собираюсь ввести филиал.

1419
01:09:57,010 --> 01:09:59,635
>> Так что думайте снова чесать, где
мы имели те развилки,

1420
01:09:59,635 --> 01:10:05,110
а на прошлой неделе в C. Я собираюсь
говорить об этом, если я-й символ в секундах

1421
01:10:05,110 --> 01:10:09,250
больше или
равно нижнему регистру а,

1422
01:10:09,250 --> 01:10:13,340
и-- в пустом месте вы бы в буквальном смысле
говорят, и, но в C вы говорите амперсанд,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- и I-й символ в секундах
меньше или равен строчные г,

1424
01:10:19,830 --> 01:10:21,780
давайте сделаем что-то интересное.

1425
01:10:21,780 --> 01:10:27,020
Давайте на самом деле распечатать
характер, без перехода на новую строку

1426
01:10:27,020 --> 01:10:31,760
то есть символ в строке,
I-й символ в строке.

1427
01:10:31,760 --> 01:10:37,420
>> Но давайте идти вперед и
вычесть 32 из него.

1428
01:10:37,420 --> 01:10:42,120
Иначе, если символ в
Строка, мы ищем

1429
01:10:42,120 --> 01:10:45,950
не между Немного
и немного г, идти вперед

1430
01:10:45,950 --> 01:10:48,610
и просто распечатала его без изменений.

1431
01:10:48,610 --> 01:10:50,840
Таким образом, мы ввели
это обозначение в квадратных скобках

1432
01:10:50,840 --> 01:10:53,560
для наших строк, чтобы получить на
I-й символ в строке.

1433
01:10:53,560 --> 01:10:57,520
>> Я добавил некоторую условную логику, как
Царапины на прошлой неделе неделе один, где

1434
01:10:57,520 --> 01:10:59,880
Я просто использую мой фундаментальный
понимание того, что

1435
01:10:59,880 --> 01:11:01,130
происходит под капотом.

1436
01:11:01,130 --> 01:11:04,190
Является ли I-ый символ S
больше или равно а?

1437
01:11:04,190 --> 01:11:08,290
Мол, это 97, или 98,
или 99, и так далее?

1438
01:11:08,290 --> 01:11:11,940
>> Но это также меньше или равно
до значения в нижнем регистре г?

1439
01:11:11,940 --> 01:11:16,210
И если да, то что это значит эта линия?

1440
01:11:16,210 --> 01:11:20,250
14, это является своего рода
росток всей идеи,

1441
01:11:20,250 --> 01:11:23,840
заглавной письмо по
просто вычесть 32 из него,

1442
01:11:23,840 --> 01:11:29,370
в данном случае, потому что я знаю, за что
диаграммы, как представлены мои номера.

1443
01:11:29,370 --> 01:11:33,925
Так что давайте идти вперед и управлять этим,
после компиляции капитализировать 0.c,

1444
01:11:33,925 --> 01:11:36,210
и запустить капитализировать 0.

1445
01:11:36,210 --> 01:11:40,300
>> Давайте ввести что-то вроде
Zamyla в нижнем регистре ввода.

1446
01:11:40,300 --> 01:11:42,780
И теперь мы имеем Zamyla в верхнем регистре.

1447
01:11:42,780 --> 01:11:45,050
Давайте ввести Роба в нижнем регистре.

1448
01:11:45,050 --> 01:11:46,674
Давайте попробуем Джейсона в нижнем регистре.

1449
01:11:46,674 --> 01:11:48,590
И мы продолжаем получение
вынуждены капитализации.

1450
01:11:48,590 --> 01:11:50,960
Там есть небольшая ошибка, что я
вид не ожидал.

1451
01:11:50,960 --> 01:11:54,050
Обратите внимание на мой новый запрос оседает
на той же строке, их имена,

1452
01:11:54,050 --> 01:11:55,520
который чувствует себя немного грязным.

1453
01:11:55,520 --> 01:11:59,170
>> Так что я собираюсь ехать сюда, и
на самом деле в конце этой программы

1454
01:11:59,170 --> 01:12:02,110
распечатать символ новой строки.

1455
01:12:02,110 --> 01:12:03,160
Это все.

1456
01:12:03,160 --> 01:12:06,120
С Printf, вам не нужно
перейти в переменных или коде формата.

1457
01:12:06,120 --> 01:12:08,460
Вы можете в буквальном смысле просто распечатать
что-то вроде новой строки.

1458
01:12:08,460 --> 01:12:13,529
>> Так что давайте идти вперед и сделать
капитализировать 0 раз, повторно запустить его, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
А теперь это немного симпатичнее.

1460
01:12:14,820 --> 01:12:17,274
Теперь, мой запрос на своей собственной новой линии.

1461
01:12:17,274 --> 01:12:18,440
Так что это все прекрасно и хорошо.

1462
01:12:18,440 --> 01:12:19,910
Так что это хороший пример.

1463
01:12:19,910 --> 01:12:22,700
Но я даже не обязательно
необходимо жестко закодировать 32.

1464
01:12:22,700 --> 01:12:23,350
Знаешь что?

1465
01:12:23,350 --> 01:12:26,350
Я мог бы say-- я никогда не
помните, в чем разница.

1466
01:12:26,350 --> 01:12:29,330
>> Но я знаю, что если я
имеют строчной буквы,

1467
01:12:29,330 --> 01:12:34,430
Я по существу хочу, чтобы вычесть от
независимо от расстояния между мало

1468
01:12:34,430 --> 01:12:39,160
а и большой А, потому что, если я предполагаю, что
все остальные буквы одинаковы,

1469
01:12:39,160 --> 01:12:41,045
которые должны получить работу.

1470
01:12:41,045 --> 01:12:42,670
Но вместо того чтобы сделать это, вы знаете, что?

1471
01:12:42,670 --> 01:12:44,240
Там еще один способ до сих пор.

1472
01:12:44,240 --> 01:12:48,090
>> Если это капитализировать 1.c-- если бы я был
чтобы поместить это в отдельный файл.

1473
01:12:48,090 --> 01:12:51,030
давайте сделаем капитализировать 2.C следующим образом.

1474
01:12:51,030 --> 01:12:53,060
Я собираюсь действительно очистить это здесь.

1475
01:12:53,060 --> 01:12:57,420
И вместо того, чтобы даже не имея
знать или заботиться о тех низком уровне

1476
01:12:57,420 --> 01:13:01,090
детали реализации, я вместо того, чтобы
только собирается напечатать символ,

1477
01:13:01,090 --> 01:13:04,610
цитата конец цитаты, процента C, и
затем вызвать другую функцию, которая

1478
01:13:04,610 --> 01:13:09,950
существует, что принимает аргумент,
который является символом, как это.

1479
01:13:09,950 --> 01:13:12,630
>> Оказывается, в C, есть
другой вызов функции

1480
01:13:12,630 --> 01:13:15,550
к верхней, которая, как его имя
предполагает, принимает характер

1481
01:13:15,550 --> 01:13:19,350
и делает его в верхний регистр
эквивалент, а затем возвращает его

1482
01:13:19,350 --> 01:13:21,410
так что Printf можете подключить его там.

1483
01:13:21,410 --> 01:13:25,484
И так, чтобы сделать это, хотя, я
необходимо ввести еще один файл.

1484
01:13:25,484 --> 01:13:28,400
Оказывается, есть еще один файл
что вы только знаете из класса,

1485
01:13:28,400 --> 01:13:33,020
или учебник, или интернет
ссылка, называется C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Так что, если я добавлю, что до моего среди заголовка
файлы, а теперь заново компилировать эту программу,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Давайте ввести Zamyla всего
в нижнем регистре, по-прежнему работает так же.

1489
01:13:46,690 --> 01:13:48,040
Но вы знаете, что?

1490
01:13:48,040 --> 01:13:55,590
Оказывается, что в верхней
имеет некоторые другие функциональные возможности.

1491
01:13:55,590 --> 01:13:58,410
>> И позвольте мне представить это
командовать здесь, вроде неловко

1492
01:13:58,410 --> 01:14:00,250
по имени, но человек для руководства.

1493
01:14:00,250 --> 01:14:03,960
Оказывается, что большинство компьютеров Linux,
как мы используем here-- операционную Linux

1494
01:14:03,960 --> 01:14:06,270
система-- есть команда
называется человек, который говорит,

1495
01:14:06,270 --> 01:14:08,530
эй, компьютер, дайте мне
по эксплуатации компьютера.

1496
01:14:08,530 --> 01:14:10,680
Что вы хотите, чтобы
искать в этом руководстве?

1497
01:14:10,680 --> 01:14:13,840
>> Я хочу посмотреть функцию
открывается верхний, Enter.

1498
01:14:13,840 --> 01:14:16,070
И это немного загадочное
читать иногда.

1499
01:14:16,070 --> 01:14:18,780
Но обратите внимание, что мы в
руководство по Linux программиста.

1500
01:14:18,780 --> 01:14:19,530
И это весь текст.

1501
01:14:19,530 --> 01:14:21,905
И заметьте, что это
имя функции здесь.

1502
01:14:21,905 --> 01:14:25,030
Оказывается, у него есть двоюродный брат под названием
снизить, которая делает противоположное.

1503
01:14:25,030 --> 01:14:29,710
И заметьте под синопсис, чтобы использовать эту функцию
функционировать страницы человека, так сказать,

1504
01:14:29,710 --> 01:14:32,220
говорит мне, что я
необходимо включить гр type.h.

1505
01:14:32,220 --> 01:14:33,630
И я знал, что из практики.

1506
01:14:33,630 --> 01:14:36,210
>> Вот, он показывает мне два
прототипы для функции,

1507
01:14:36,210 --> 01:14:39,070
так что если я когда-нибудь хочу, чтобы использовать эту функцию
Я знаю, что они принимают в качестве входных данных,

1508
01:14:39,070 --> 01:14:40,652
и то, что они возвращаются в качестве выходного сигнала.

1509
01:14:40,652 --> 01:14:42,360
И потом, если я читаю
описание, я вижу

1510
01:14:42,360 --> 01:14:44,820
более подробно, что функция делает.

1511
01:14:44,820 --> 01:14:48,100
Но что более важно, если
Я смотрю под возвращаемого значения,

1512
01:14:48,100 --> 01:14:51,710
он говорит, возвращенное значение
что преобразованного письма,

1513
01:14:51,710 --> 01:14:57,880
или С, исходный входной, если
преобразование не удалось.

1514
01:14:57,880 --> 01:15:01,992
>> Другими словами, верхний будет пытаться
преобразовать письмо в верхний регистр.

1515
01:15:01,992 --> 01:15:03,450
И если да, то он собирается вернуть ее.

1516
01:15:03,450 --> 01:15:07,010
Но если он не может для некоторых reason--
может быть, это уже в верхнем регистре,

1517
01:15:07,010 --> 01:15:09,550
может быть, это восклицательный знак
или какой-либо другой punctuation--

1518
01:15:09,550 --> 01:15:12,200
это просто будет
вернуть исходный C,

1519
01:15:12,200 --> 01:15:17,340
а это значит, что я могу сделать мой код
лучше разработаны следующим образом.

1520
01:15:17,340 --> 01:15:20,580
>> Мне не нужны все
эти штопать строки кода.

1521
01:15:20,580 --> 01:15:22,610
Все строки я
только выделенный может

1522
01:15:22,610 --> 01:15:28,700
быть свернуты в только один простой
линия, которая является this-- Printf процента

1523
01:15:28,700 --> 01:15:33,510
с к верхнему кронштейну I S.

1524
01:15:33,510 --> 01:15:36,090
И это было бы
пример лучшего дизайна.

1525
01:15:36,090 --> 01:15:40,040
>> Почему реализовать в 7 или 8 линий
кода, каким бы он был я просто

1526
01:15:40,040 --> 01:15:44,960
удален, когда вы можете вместо того, чтобы свернуть
все, что логика и принятие решений

1527
01:15:44,960 --> 01:15:49,620
в одну линию, 13, что в настоящее время
опирается на библиотеку function--

1528
01:15:49,620 --> 01:15:53,430
функция, которая поставляется с C, но это
делает именно то, что вы хотите, чтобы это сделать.

1529
01:15:53,430 --> 01:15:55,295
И, честно говоря, даже если
он не пришел с C,

1530
01:15:55,295 --> 01:15:58,880
вы могли бы реализовать его самостоятельно, так как
мы уже видели, с Int получите отрицательный результат

1531
01:15:58,880 --> 01:16:01,700
и получить положительный INT на прошлой неделе.

1532
01:16:01,700 --> 01:16:03,470
>> Этот код в настоящее время гораздо более удобным для чтения.

1533
01:16:03,470 --> 01:16:06,670
И действительно, если мы прокрутки вверх,
Посмотрите, насколько более компактный

1534
01:16:06,670 --> 01:16:08,360
эта версия моей программы.

1535
01:16:08,360 --> 01:16:11,230
Это немного громоздкой сейчас,
со всеми этими включает в себя.

1536
01:16:11,230 --> 01:16:14,380
Но это нормально, потому что теперь я стою
на плечи программистов

1537
01:16:14,380 --> 01:16:15,300
до меня.

1538
01:16:15,300 --> 01:16:18,440
И кто бы это ни был, кто
реализованы в верхней действительно

1539
01:16:18,440 --> 01:16:21,470
сделал мне одолжение, так же, как тот, кто
реализован Стирлинга действительно

1540
01:16:21,470 --> 01:16:24,790
сделал мне одолжение некоторое время назад.

1541
01:16:24,790 --> 01:16:26,970
И вот теперь у нас есть
лучше дизайн программы

1542
01:16:26,970 --> 01:16:31,680
который реализует ту же самую логику.

1543
01:16:31,680 --> 01:16:35,580
>> Говоря о Стерлинга, пусть
мне идти вперед и делать это.

1544
01:16:35,580 --> 01:16:38,320
Позвольте мне идти вперед и сохранить
этот файл в качестве stirling.c.

1545
01:16:38,320 --> 01:16:43,255
И получается, мы можем отогните
один другой слой довольно просто прямо сейчас.

1546
01:16:43,255 --> 01:16:45,630
Я собираюсь идти вперед и кнут
до другой программы в главном

1547
01:16:45,630 --> 01:16:49,759
здесь просто повторно орудия
длина строки следующим образом.

1548
01:16:49,759 --> 01:16:52,300
Так вот строка кода, которая
получает меня строку от пользователя.

1549
01:16:52,300 --> 01:16:53,910
Мы продолжаем использовать это снова и снова.

1550
01:16:53,910 --> 01:16:58,900
Позвольте мне дать себе переменную
п типа Int, который хранит номер.

1551
01:16:58,900 --> 01:17:02,490
>> И позвольте мне идти вперед и
сделать следующую логику.

1552
01:17:02,490 --> 01:17:15,610
В то время как п-й символ в S делает
не равен 0 обратной косой черты, идти вперед

1553
01:17:15,610 --> 01:17:17,930
и приращение п.

1554
01:17:17,930 --> 01:17:23,506
И затем распечатать Printf процента I N.

1555
01:17:23,506 --> 01:17:29,200
Я утверждаю, что эта программа здесь,
без вызова длины строки,

1556
01:17:29,200 --> 01:17:31,150
выясняет длину строки.

1557
01:17:31,150 --> 01:17:34,600
>> И магия полностью
воплощен в строке 8

1558
01:17:34,600 --> 01:17:39,830
вот с чем выглядит как новый синтаксис,
это обратный слэш 0 в одинарные кавычки.

1559
01:17:39,830 --> 01:17:41,360
Но почему?

1560
01:17:41,360 --> 01:17:44,100
Ну, подумайте, что было
происходит все это время.

1561
01:17:44,100 --> 01:17:47,990
>> И, как в сторону, прежде чем я забыл, понимаю,
также, что в дополнение к человеку страниц

1562
01:17:47,990 --> 01:17:50,920
которые приходят с типичным
Система Linux как CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
понимать, что мы,
Персонал конечно, в есть также

1564
01:17:53,770 --> 01:17:56,030
сделал версию сайта
этой же идеи под названием

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, которая имеет
все те же человеко-страниц,

1566
01:17:59,940 --> 01:18:02,020
все тот же
документации, а также

1567
01:18:02,020 --> 01:18:05,730
маленькая коробочка в верхней части, что позволяет
конвертировать все из довольно

1568
01:18:05,730 --> 01:18:09,025
аркан язык в менее комфортно
режим, в котором мы, преподавательский состав,

1569
01:18:09,025 --> 01:18:12,150
прошли и попытался упростить
часть языка, чтобы держать вещи

1570
01:18:12,150 --> 01:18:14,830
сосредоточены на идеях, а не
некоторые тонкости.

1571
01:18:14,830 --> 01:18:20,070
Так что имейте в виду, reference.cs50.net
в качестве еще одного ресурса, а также.

1572
01:18:20,070 --> 01:18:23,800
>> Но почему длина строки в работу
как я предложил несколько минут назад?

1573
01:18:23,800 --> 01:18:25,160
Вот имя Zamyla снова.

1574
01:18:25,160 --> 01:18:27,690
А вот имя Zamyla в
зажаты в, как я продолжать делать,

1575
01:18:27,690 --> 01:18:31,360
чтобы нарисовать картину его бытия,
на самом деле, просто последовательность символов.

1576
01:18:31,360 --> 01:18:34,260
Но Zamyla не существует
в изоляции в программе.

1577
01:18:34,260 --> 01:18:37,420
>> Когда вы пишете и запустить программу,
вы используете ваш Mac или ПК

1578
01:18:37,420 --> 01:18:40,010
как память, или RAM, так сказать.

1579
01:18:40,010 --> 01:18:42,620
И вы можете думать о
ваш компьютер как имеющий

1580
01:18:42,620 --> 01:18:44,730
много гигабайт памяти в эти дни.

1581
01:18:44,730 --> 01:18:47,700
И гиг ​​означает миллиарды,
поэтому миллиарды байт.

1582
01:18:47,700 --> 01:18:48,910
>> Но давайте перематывать во времени.

1583
01:18:48,910 --> 01:18:51,530
И предположим, что мы используем
очень старый компьютер,

1584
01:18:51,530 --> 01:18:55,150
имеет только 32 байта памяти.

1585
01:18:55,150 --> 01:18:59,310
Я мог бы, на экране компьютера,
просто обратить на это следующим образом.

1586
01:18:59,310 --> 01:19:05,240
>> Я мог бы просто сказать, что мой
Компьютер имеет вся эта память.

1587
01:19:05,240 --> 01:19:08,830
И это, как палка памяти, если
Вы помните нашу картину в прошлый раз.

1588
01:19:08,830 --> 01:19:11,670
А если я просто разделить
это столько раз,

1589
01:19:11,670 --> 01:19:15,040
Я утверждаю, что у меня есть 32 байта
памяти на экране.

1590
01:19:15,040 --> 01:19:18,239
>> Теперь, на самом деле, я могу только
рисовать до сих пор на этом экране здесь.

1591
01:19:18,239 --> 01:19:20,280
Так что я собираюсь идти вперед,
и только по соглашению,

1592
01:19:20,280 --> 01:19:24,050
рисовать памяти моего компьютера в качестве
сетки, а не только как одна прямая линия.

1593
01:19:24,050 --> 01:19:28,190
В частности, я утверждаю, что в настоящее время
эта сетка, это 8 по 4 сетки,

1594
01:19:28,190 --> 01:19:31,800
просто представляет все 32 байта
доступной памяти в моем Mac,

1595
01:19:31,800 --> 01:19:33,030
или доступны в моем компьютере.

1596
01:19:33,030 --> 01:19:34,780
И они оберточная
на две линии, просто

1597
01:19:34,780 --> 01:19:38,030
так как он подходит больше на экране.

1598
01:19:38,030 --> 01:19:40,800
Но это первый байт.

1599
01:19:40,800 --> 01:19:41,990
Это второй байт.

1600
01:19:41,990 --> 01:19:43,300
Это третий байт.

1601
01:19:43,300 --> 01:19:45,310
>> И это 32-й байт.

1602
01:19:45,310 --> 01:19:52,910
Или, если мы думаем, как компьютер
ученый, это байт 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Так что у вас есть от 0 до 31, если
Вы начинаете отсчет с 0.

1604
01:19:55,950 --> 01:19:59,830
>> Так что, если мы используем программу
что звонки получить строку,

1605
01:19:59,830 --> 01:20:05,280
и мы получаем строку из человеческого
как я назвал Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
как в мире делает
компьютер отслеживать, какой байт,

1607
01:20:09,430 --> 01:20:12,230
который кусок памяти,
принадлежит какая строка?

1608
01:20:12,230 --> 01:20:16,270
Другими словами, если мы переходим к
введите другое имя в компьютер,

1609
01:20:16,270 --> 01:20:19,890
как этот Andi, называя
получить строку во второй раз,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-я должен закончить в
память компьютера, а также.

1611
01:20:23,030 --> 01:20:23,850
Но как?

1612
01:20:23,850 --> 01:20:29,700
>> Что ж, получается, что под
капот, то, что C делает при хранении строк

1613
01:20:29,700 --> 01:20:35,080
что человеческие типы в, или что
происходят из какого-либо другого источника, является его

1614
01:20:35,080 --> 01:20:39,190
очерчивает конец их с
специальный character-- обратной косой черты

1615
01:20:39,190 --> 01:20:44,750
0, что это просто особый способ
сказать 80 бит подряд.

1616
01:20:44,750 --> 01:20:47,950
>> Так A-- это число 97 отзыв.

1617
01:20:47,950 --> 01:20:51,770
Таким образом, некоторые модели из 8 битов
представляет десятичное число 97.

1618
01:20:51,770 --> 01:20:58,070
Этот обратный слэш 0 буквально число
0, а.к.а. NUL, N-U-L, в отличие от ранее,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, который мы говорили.

1620
01:20:59,630 --> 01:21:05,700
Но сейчас, просто знаю, что это
обратная косая 0 всего 80 бит подряд.

1621
01:21:05,700 --> 01:21:09,810
>> И это как раз эта строка в
песок, который говорит, что ничего слева

1622
01:21:09,810 --> 01:21:12,610
принадлежит к одной строке или одного типа данных.

1623
01:21:12,610 --> 01:21:15,480
И ничего вправо
принадлежит к чему-то еще.

1624
01:21:15,480 --> 01:21:17,440
наименование Andi, тем временем,
который только визуально

1625
01:21:17,440 --> 01:21:21,310
случается, чтобы обернуть на другой линии,
но это только эстетическая деталь,

1626
01:21:21,310 --> 01:21:23,990
Аналогичным образом завершается NUL.

1627
01:21:23,990 --> 01:21:29,290
>> Это струна символов A-N-D-I,
плюс пятый секретный характер,

1628
01:21:29,290 --> 01:21:33,560
все 0 биты, которые просто разграничивает
конец имени Andi, а также.

1629
01:21:33,560 --> 01:21:37,120
И если мы называем получить строку в третий раз
в компьютере, чтобы получить строку вида

1630
01:21:37,120 --> 01:21:44,210
Мария, М-А-Р-I-А, так же является Марии
Имя NUL завершается с обратной косой чертой 0.

1631
01:21:44,210 --> 01:21:47,170
>> Это принципиально отличается
от того, как компьютер, как правило,

1632
01:21:47,170 --> 01:21:51,850
хранить целое число или число с плавающей точкой, или другой
типы данных до сих пор, потому что вспомнить,

1633
01:21:51,850 --> 01:21:57,420
целое число, как правило, 32 бита, или
4 байта, или возможно даже 64 бита,

1634
01:21:57,420 --> 01:21:59,100
или восемь байт.

1635
01:21:59,100 --> 01:22:02,620
Но многие примитивы в компьютере
на языке программирования

1636
01:22:02,620 --> 01:22:05,550
имеют фиксированное число
байт под hood--

1637
01:22:05,550 --> 01:22:08,100
может быть 1, 2, может быть, может быть 4, может быть 8.

1638
01:22:08,100 --> 01:22:13,250
>> Но строки, по дизайну, имеют
динамическое количество символов.

1639
01:22:13,250 --> 01:22:16,980
Вы никогда не знаете заранее, до тех пор,
человеческие типы в Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
или М-А-Р-И-А или А-Н-Д-И. Вы не знаете,
сколько раз пользователь собирается ударить

1641
01:22:21,400 --> 01:22:22,070
клавиатура.

1642
01:22:22,070 --> 01:22:26,490
Таким образом, вы не знаете, как
много символов в заранее

1643
01:22:26,490 --> 01:22:27,540
вы будете нуждаться.

1644
01:22:27,540 --> 01:22:31,840
>> И так С просто вид листьев, как у
секрет крошка под капотом

1645
01:22:31,840 --> 01:22:32,960
в конце строки.

1646
01:22:32,960 --> 01:22:39,280
После хранения Z-А-М-Y-L-A в памяти,
он также просто ставит эквивалент

1647
01:22:39,280 --> 01:22:40,210
в течение периода.

1648
01:22:40,210 --> 01:22:45,060
В конце предложения,
он помещает 80 бит, таким образом,

1649
01:22:45,060 --> 01:22:49,120
чтобы вспомнить, где
Zamyla начинается и заканчивается.

1650
01:22:49,120 --> 01:22:51,490
>> Так что связь,
Затем, к этой программе?

1651
01:22:51,490 --> 01:22:55,190
Эта программа здесь, Стирлинга,
это просто механизм

1652
01:22:55,190 --> 01:22:57,970
для получения строки
от пользователя, строка 6.

1653
01:22:57,970 --> 01:23:01,160
Строка 7, я объявить переменную
называется п и установите его равным 0.

1654
01:23:01,160 --> 01:23:08,680
>> А потом в строке 8, я просто спросил
вопрос, в то время как п-й символ делает

1655
01:23:08,680 --> 01:23:12,120
не равны 0 все bits--
иными словами, не делает

1656
01:23:12,120 --> 01:23:14,500
равно этот специальный
символ, обратная косая 0,

1657
01:23:14,500 --> 01:23:18,470
был только что специальный NUL character--
идти вперед и просто увеличивать п.

1658
01:23:18,470 --> 01:23:21,460
>> И продолжать делать это, и держать
делая это, и продолжать делать это.

1659
01:23:21,460 --> 01:23:23,430
И поэтому, даже если в
прошлое мы использовали I,

1660
01:23:23,430 --> 01:23:25,181
это прекрасно
семантически использовать п,

1661
01:23:25,181 --> 01:23:27,430
если вы просто пытаетесь
рассчитывать на этот раз сознательно,

1662
01:23:27,430 --> 01:23:28,720
и просто хотите назвать это н.

1663
01:23:28,720 --> 01:23:34,720
Так что это просто продолжает задавать вопрос,
является н-ый символ с все 0s?

1664
01:23:34,720 --> 01:23:38,470
Если нет, посмотрите на следующий вид,
посмотрите на следующий, посмотрите на следующий,

1665
01:23:38,470 --> 01:23:39,460
посмотрите на следующий.

1666
01:23:39,460 --> 01:23:45,540
>> Но как только вы видите обратную косую 0,
это loop-- линия 9 через 11-- останавливается.

1667
01:23:45,540 --> 01:23:49,640
Вы вырваться из цикла в то время,
оставляя внутри этой переменной п

1668
01:23:49,640 --> 01:23:54,530
в общей сложности количество всех из
символов в строке, которую вы видели,

1669
01:23:54,530 --> 01:23:55,660
таким образом, выводе на печать.

1670
01:23:55,660 --> 01:23:56,760
Так давайте попробуем это.

1671
01:23:56,760 --> 01:23:59,500
>> Позвольте мне идти вперед и без
с помощью функции Стирлинга,

1672
01:23:59,500 --> 01:24:04,240
а просто используя свою собственную версию доморощенные
здесь называется Стирлинга, позвольте мне идти вперед

1673
01:24:04,240 --> 01:24:07,700
и запустить Стирлинга, типа в чем-то
как Zamyla, который я знаю заранее

1674
01:24:07,700 --> 01:24:08,670
составляет шесть символов.

1675
01:24:08,670 --> 01:24:10,080
Давайте посмотрим, работает ли он.

1676
01:24:10,080 --> 01:24:10,920
В самом деле, это шесть.

1677
01:24:10,920 --> 01:24:15,257
Давайте попробуем с Робом, три символа,
три символа, а также, и так далее.

1678
01:24:15,257 --> 01:24:17,340
Так что все, что происходит
на под капотом.

1679
01:24:17,340 --> 01:24:19,548
И обратите внимание, соединения,
затем, начиная с первой недели

1680
01:24:19,548 --> 01:24:22,370
класса, где мы говорили о
что-то вроде абстракции,

1681
01:24:22,370 --> 01:24:26,960
что именно это наслоение идей, или
сложность, на вершине основных принципов.

1682
01:24:26,960 --> 01:24:30,710
Здесь мы вроде смотреть
под капотом Стерлинга,

1683
01:24:30,710 --> 01:24:33,510
так сказать, чтобы выяснить,
как бы это реализовать?

1684
01:24:33,510 --> 01:24:35,232
>> И мы могли бы повторно реализовать его сами.

1685
01:24:35,232 --> 01:24:37,440
Но мы никогда снова собирается
повторно реализовать Стирлинга.

1686
01:24:37,440 --> 01:24:39,780
Мы просто собираемся
использовать Стирлинга в порядке

1687
01:24:39,780 --> 01:24:42,100
на самом деле получить некоторые строки длины.

1688
01:24:42,100 --> 01:24:44,200
>> Но нет никакой магии
под капотом.

1689
01:24:44,200 --> 01:24:46,716
Если вы знаете, что под
капот, строка

1690
01:24:46,716 --> 01:24:48,090
это просто последовательность символов.

1691
01:24:48,090 --> 01:24:51,090
И это последовательность символов
все они могут быть численно рассмотрены

1692
01:24:51,090 --> 01:24:53,330
с кронштейном 0, кронштейн
1, кронштейн 2, и вы

1693
01:24:53,330 --> 01:24:57,420
известно, что в конце строки является
специальный символ, вы можете выяснить,

1694
01:24:57,420 --> 01:25:01,710
как сделать большинство ничего в
Программа, потому что все это сводится к тому,

1695
01:25:01,710 --> 01:25:03,400
читает и пишет память.

1696
01:25:03,400 --> 01:25:06,130
То есть, меняется и ищет
в памяти, или перемещение вещей

1697
01:25:06,130 --> 01:25:10,940
вокруг в памяти, печатные вещи
на экране, и так далее.

1698
01:25:10,940 --> 01:25:14,800
>> Так давайте теперь использовать эту вновь обретенную
понимание того, какие строки на самом деле

1699
01:25:14,800 --> 01:25:17,910
находятся под капотом, и
отогните один другой слой

1700
01:25:17,910 --> 01:25:20,080
что до сих пор мы
игнорировал в целом.

1701
01:25:20,080 --> 01:25:22,650
В частности, любое время
мы реализовали программу,

1702
01:25:22,650 --> 01:25:25,930
мы имели эту строку кода
вблизи верхней объявляя главной.

1703
01:25:25,930 --> 01:25:27,810
И мы указали INT главную пустоту.

1704
01:25:27,810 --> 01:25:31,240
>> И эта пустота внутри скобок
говорил все это время, что основная

1705
01:25:31,240 --> 01:25:33,440
сама по себе не принимает каких-либо аргументов.

1706
01:25:33,440 --> 01:25:36,210
Любой вклад, что главное,
собирается получить от пользователя

1707
01:25:36,210 --> 01:25:39,020
должна исходить от какой-то другой
механизм, как Get INT,

1708
01:25:39,020 --> 01:25:42,040
или получить с плавающей точкой, или получить строку,
или какой-либо другой функции.

1709
01:25:42,040 --> 01:25:44,710
Но оказывается, что
когда вы пишете программу,

1710
01:25:44,710 --> 01:25:47,690
вы можете указать
что эта программа должна

1711
01:25:47,690 --> 01:25:51,730
принимают входные сигналы от человека
в самой командной строке.

1712
01:25:51,730 --> 01:25:56,310
>> Другими словами, даже если мы до сих пор
были работает только ./hello привет

1713
01:25:56,310 --> 01:26:00,312
или аналогичные программы, все
другие программы, которые мы использовали,

1714
01:26:00,312 --> 01:26:02,770
что мы сами не писали,
принимали, по-видимому,

1715
01:26:02,770 --> 01:26:05,210
командной строки arguments--
такие вещи, как сделать.

1716
01:26:05,210 --> 01:26:07,450
Вы говорите, что что-то вроде марка,
а затем второе слово.

1717
01:26:07,450 --> 01:26:10,950
Или лязг, вы говорите лязг, а затем
второе слово, имя файла.

1718
01:26:10,950 --> 01:26:14,410
>> Или даже RM или СР, как можно было бы
видели или использовать уже

1719
01:26:14,410 --> 01:26:15,880
удалять или копировать файлы.

1720
01:26:15,880 --> 01:26:18,920
Все те принимают так называемые
командной строки arguments--

1721
01:26:18,920 --> 01:26:21,130
дополнительные слова в строке терминала.

1722
01:26:21,130 --> 01:26:23,260
Но до сих пор, мы
сами не имели

1723
01:26:23,260 --> 01:26:27,080
Этот роскошный принимать входной сигнал от
пользователя, когда он или она на самом деле работает

1724
01:26:27,080 --> 01:26:29,120
сама программа в командной строке.

1725
01:26:29,120 --> 01:26:33,710
>> Но мы можем сделать это путем повторного декларирования
Основной двигаться вперед, а не как имеющие

1726
01:26:33,710 --> 01:26:36,750
недействительным в скобках,
но эти два аргумента

1727
01:26:36,750 --> 01:26:40,600
instead-- первое целое число,
а второй что-то

1728
01:26:40,600 --> 01:26:44,170
новое, то, что мы будем называть
массив, нечто подобное в духе

1729
01:26:44,170 --> 01:26:49,220
к тому, что мы видели в пустом виде списка, но
массив строк, как мы скоро увидим.

1730
01:26:49,220 --> 01:26:51,790
Но давайте посмотрим на это
В качестве примера, прежде чем мы

1731
01:26:51,790 --> 01:26:53,690
различают именно то, что это значит.

1732
01:26:53,690 --> 01:26:56,520
>> Так что, если я иду в CS50 IDE
здесь, я пошел вперед

1733
01:26:56,520 --> 01:27:01,840
и объявлен в файле с именем
argv0.c следующий шаблон.

1734
01:27:01,840 --> 01:27:04,120
И заметьте, единственное,
что по-другому до сих пор

1735
01:27:04,120 --> 01:27:08,570
является то, что я изменил ничтожным Int
ARGC строка ARGV открытый кронштейн, близко

1736
01:27:08,570 --> 01:27:09,070
скобка.

1737
01:27:09,070 --> 01:27:11,730
И обратите внимание на данный момент, есть
ничего не внутри этих скобок.

1738
01:27:11,730 --> 01:27:12,620
>> Там нет числа.

1739
01:27:12,620 --> 01:27:15,070
И нет я, или
N, или любое другое письмо.

1740
01:27:15,070 --> 01:27:17,010
Я просто с помощью
квадратные скобки на данный момент,

1741
01:27:17,010 --> 01:27:19,510
по причинам, мы приедем
обратно в мгновение.

1742
01:27:19,510 --> 01:27:21,330
>> А теперь, что я собираюсь сделать это.

1743
01:27:21,330 --> 01:27:26,680
Если ARGC равен равен 2--
и напомним, что равняется равных

1744
01:27:26,680 --> 01:27:30,040
является оператором сравнения равенства
левый и правый для равенства.

1745
01:27:30,040 --> 01:27:31,790
Это не уступка
оператор, который

1746
01:27:31,790 --> 01:27:36,510
единственный знак равенства, что означает копию
от справа налево какое-то значение.

1747
01:27:36,510 --> 01:27:42,840
>> Если ARGC равен равен 2, я хочу
скажем, Printf, привет, проценты, новая линия,

1748
01:27:42,840 --> 01:27:47,340
а затем подключить in-- и вот новый
trick-- ARGV кронштейн 1, по причинам

1749
01:27:47,340 --> 01:27:48,840
что мы вернемся в минуту.

1750
01:27:48,840 --> 01:27:52,110
Иначе, если ARGC не
равно 2, вы знаете, что?

1751
01:27:52,110 --> 01:27:57,400
Давайте просто идти вперед и, как обычно, печать
вне привет мир, без замены.

1752
01:27:57,400 --> 01:28:02,710
>> Так что, казалось бы, что если ARGC, который
выступает за количеством аргументов, равняется 2,

1753
01:28:02,710 --> 01:28:04,740
Я собираюсь распечатать
привет что-то или другое.

1754
01:28:04,740 --> 01:28:07,560
В противном случае, по умолчанию, я
собирается напечатать привет мир.

1755
01:28:07,560 --> 01:28:08,770
Так что же это означает?

1756
01:28:08,770 --> 01:28:15,550
>> Что ж, позвольте мне идти вперед и сохранить
этот файл, а затем делают argv0,

1757
01:28:15,550 --> 01:28:18,940
а затем ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
И это говорит привет мир.

1759
01:28:20,300 --> 01:28:21,260
Теперь, почему это?

1760
01:28:21,260 --> 01:28:24,730
>> Что ж, получается, в любое время вы
запустить программу в командной строке,

1761
01:28:24,730 --> 01:28:29,570
вы заполняете в том, что мы будем
обычно называем вектор аргументов.

1762
01:28:29,570 --> 01:28:33,100
Другими словами, автоматически
компьютер, операционная система,

1763
01:28:33,100 --> 01:28:38,340
собирается передать вашей программе
Сам список всех слов

1764
01:28:38,340 --> 01:28:40,850
что человек набрал на
подсказка, в случае, если

1765
01:28:40,850 --> 01:28:43,790
программист хочет сделать
что-то с этой информацией.

1766
01:28:43,790 --> 01:28:48,540
И в этом случае единственное слово,
Я набрал в строке является ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> И поэтому число аргументов, является
передается в моей программе только один.

1768
01:28:55,420 --> 01:28:58,880
Другими словами, аргумент
рассчитывать, иначе известный как ARGC

1769
01:28:58,880 --> 01:29:00,970
здесь как целое число, это лишь один.

1770
01:29:00,970 --> 01:29:03,000
Один из них, конечно, не равно двум.

1771
01:29:03,000 --> 01:29:05,980
И так это то, что печатает, привет мир.

1772
01:29:05,980 --> 01:29:08,170
>> Но позвольте мне взять это где-то.

1773
01:29:08,170 --> 01:29:09,930
Позвольте мне сказать, argv0.

1774
01:29:09,930 --> 01:29:12,740
А потом, как о Марии?

1775
01:29:12,740 --> 01:29:14,990
А затем нажмите клавишу Enter.

1776
01:29:14,990 --> 01:29:18,020
>> И обратите внимание, что волшебным образом здесь происходит.

1777
01:29:18,020 --> 01:29:22,640
Теперь, вместо привет мир, у меня есть
изменил поведение этой программы

1778
01:29:22,640 --> 01:29:26,310
принимая вход не от Get
строка или какой-либо другой функции,

1779
01:29:26,310 --> 01:29:30,570
но из, по-видимому, моя команда
Сам, что я первоначально напечатал.

1780
01:29:30,570 --> 01:29:35,720
И я могу играть в эту игру снова
изменяя его Стелиос, например.

1781
01:29:35,720 --> 01:29:38,400
>> А теперь я вижу другое имя до сих пор.

1782
01:29:38,400 --> 01:29:40,540
И здесь, я мог бы сказать, Анди.

1783
01:29:40,540 --> 01:29:42,137
И я мог бы сказать Zamyla.

1784
01:29:42,137 --> 01:29:45,220
И мы можем играть в эту игру в течение всего дня,
просто затыкать в различных значениях,

1785
01:29:45,220 --> 01:29:49,550
до тех пор, как я предоставить именно
два слова в командной строке

1786
01:29:49,550 --> 01:29:52,260
таким образом, что ARGC, граф мой аргумент, 2.

1787
01:29:52,260 --> 01:29:57,240
>> Вижу ли я, что имя подключен к
Printf, в этом состоянии здесь?

1788
01:29:57,240 --> 01:30:00,550
Таким образом, мы, кажется, в настоящее время
выразительный потенциал

1789
01:30:00,550 --> 01:30:04,410
принимать входной сигнал от другого механизма,
от так называемой командной строки,

1790
01:30:04,410 --> 01:30:07,000
вместо того, чтобы ждать
до тех пор, пока пользователь не запускает программу,

1791
01:30:07,000 --> 01:30:10,220
а затем побудить его или ее
используя что-то вроде получения строки.

1792
01:30:10,220 --> 01:30:11,230
>> Так что же это?

1793
01:30:11,230 --> 01:30:15,010
ARGC, опять же, это всего лишь целое число,
количество words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
что пользователь при условии, на
подскажите, в окне терминала,

1795
01:30:18,540 --> 01:30:20,110
в том числе название программы.

1796
01:30:20,110 --> 01:30:23,340
Таким образом, наша ./argv0 является, по сути,
название программы,

1797
01:30:23,340 --> 01:30:24,520
или как я запустить программу.

1798
01:30:24,520 --> 01:30:25,810
>> Это считается как слово.

1799
01:30:25,810 --> 01:30:27,080
Так ARGC будет 1.

1800
01:30:27,080 --> 01:30:29,750
Но когда я пишу Стелиос, или
Andi или Zamyla, или Мария,

1801
01:30:29,750 --> 01:30:31,660
это означает, что количество аргументов равно двум.

1802
01:30:31,660 --> 01:30:33,910
И вот теперь есть два слова, передаваемые в.

1803
01:30:33,910 --> 01:30:36,070
>> И заметьте, мы можем продолжить эту логику.

1804
01:30:36,070 --> 01:30:39,050
Если бы я на самом деле сказать
что-то вроде Zamyla Чан,

1805
01:30:39,050 --> 01:30:42,200
полное имя, тем самым передав
три аргумента в общей сложности,

1806
01:30:42,200 --> 01:30:47,410
Теперь он снова говорит по умолчанию,
потому что, конечно же, 3 не равно 2.

1807
01:30:47,410 --> 01:30:54,080
>> И вот таким образом, у меня есть
доступ через ARGV этот новый аргумент

1808
01:30:54,080 --> 01:30:56,080
что мы могли бы технически
называть все, что угодно.

1809
01:30:56,080 --> 01:30:58,940
Но в соответствии с соглашением, это
ARGV и ARGC соответственно.

1810
01:30:58,940 --> 01:31:04,470
ARGV, вектор аргументов, является своего рода
синонима для программирования

1811
01:31:04,470 --> 01:31:07,140
функция в C называется массив.

1812
01:31:07,140 --> 01:31:14,410
>> Массив представляет список значений аналогичных
назад, к спине, к спине, к спине.

1813
01:31:14,410 --> 01:31:17,810
Другими словами, если кто-то здесь, в
RAM, следующий прямо рядом с ним,

1814
01:31:17,810 --> 01:31:18,800
и рядом с ним.

1815
01:31:18,800 --> 01:31:20,101
Они не повсюду.

1816
01:31:20,101 --> 01:31:23,100
И это последний сценарий, где вещи
находятся повсюду в памяти,

1817
01:31:23,100 --> 01:31:25,082
может быть на самом деле мощная функция.

1818
01:31:25,082 --> 01:31:28,040
Но мы вернемся к тому, что, когда мы
говорить о причудливых структур данных.

1819
01:31:28,040 --> 01:31:32,260
На данный момент, массив просто
кусок непрерывной памяти,

1820
01:31:32,260 --> 01:31:36,520
каждый из которых элементы
назад, к спине, к спине, к спине,

1821
01:31:36,520 --> 01:31:38,050
и, как правило тот же самый тип.

1822
01:31:38,050 --> 01:31:42,630
>> Так что если вы думаете о том, от А
минуту назад, что такое строка?

1823
01:31:42,630 --> 01:31:50,460
Ну, строка, как Zamyla,
Z-А-М-У-Л-А, это, технически,

1824
01:31:50,460 --> 01:31:51,400
просто массив.

1825
01:31:51,400 --> 01:31:53,700
Это массив символов.

1826
01:31:53,700 --> 01:31:59,250
>> И поэтому, если мы действительно сделать это, как я
сделал ранее, как кусок памяти,

1827
01:31:59,250 --> 01:32:04,510
получается, что каждый из них
символов занимает байт.

1828
01:32:04,510 --> 01:32:07,630
А тут что особое
сторожевого символ, обратная косая 0,

1829
01:32:07,630 --> 01:32:12,360
или все восемь бит 0, что
разграничивает конец этой строки.

1830
01:32:12,360 --> 01:32:15,090
Так строка, получается
вне, цитируют Unquote строку,

1831
01:32:15,090 --> 01:32:20,580
это просто массив chara--
обугливается будучи фактическим типом данных.

1832
01:32:20,580 --> 01:32:24,560
>> А теперь ARGV, meanwhile--
давайте вернемся к программе.

1833
01:32:24,560 --> 01:32:29,582
ARGV, хотя мы видим, слово
Строка здесь, не является сама строка.

1834
01:32:29,582 --> 01:32:33,640
ARGV, вектор аргументов,
представляет собой массив строк.

1835
01:32:33,640 --> 01:32:37,620
>> Так же, как вы можете иметь массив
символов, вы можете иметь более высокий уровень,

1836
01:32:37,620 --> 01:32:46,279
массив strings-- так, например,
когда я набрал минуту назад ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, пространство Z-A-M-Y-L-A, я утверждал, что
ARGV имел две строки в it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
и Z-A-M-Y-L-A. В
Другими словами, ARGC было 2.

1839
01:33:03,185 --> 01:33:03,980
Почему это?

1840
01:33:03,980 --> 01:33:08,370
>> Ну, по сути, то, что происходит
на том, что каждая из этих строк

1841
01:33:08,370 --> 01:33:13,990
это, конечно, массив символов
как и прежде, каждый из которых персонажи

1842
01:33:13,990 --> 01:33:15,670
занимает один байт.

1843
01:33:15,670 --> 01:33:19,720
И не путайте фактическую 0
в названии программы с 0,

1844
01:33:19,720 --> 01:33:22,040
что означает все 80 бит.

1845
01:33:22,040 --> 01:33:27,140
И Zamyla, тем временем, по-прежнему
также массив символов.

1846
01:33:27,140 --> 01:33:31,450
>> Таким образом, в конце концов, это на самом деле
выглядит следующим образом под капотом.

1847
01:33:31,450 --> 01:33:38,800
Но ARGV, по своей природе, как главный
работы, позволяет мне обернуть все это

1848
01:33:38,800 --> 01:33:44,810
до в, если вы будете, больший массив
что, если мы чуть более упростить

1849
01:33:44,810 --> 01:33:48,180
что картина выглядит и не
достаточно нарисовать ее в масштабе там,

1850
01:33:48,180 --> 01:33:56,720
Этот массив является только размером 2, первый
элемент которого содержит строку,

1851
01:33:56,720 --> 01:33:59,230
второй элемент
которая содержит строку.

1852
01:33:59,230 --> 01:34:01,687
И, в свою очередь, если вы
вид увеличения на каждом

1853
01:34:01,687 --> 01:34:03,770
из этих строк, что вы
см под капотом

1854
01:34:03,770 --> 01:34:07,190
является то, что каждая строка просто
массив символов.

1855
01:34:07,190 --> 01:34:11,680
>> Теперь, так же, как со строками,
мы были в состоянии получить доступ

1856
01:34:11,680 --> 01:34:15,260
к г-го символа в строке
с помощью этой квадратной скобки обозначения.

1857
01:34:15,260 --> 01:34:17,320
Точно так же, с массивами
в общем, мы можем

1858
01:34:17,320 --> 01:34:22,700
использовать квадратные скобки, обозначения, чтобы получить
на любое количество строк в массиве?

1859
01:34:22,700 --> 01:34:25,100
Например, позвольте мне
идти вперед и делать это.

1860
01:34:25,100 --> 01:34:32,420
>> Позвольте мне идти вперед и создать argv1.c,
который немного отличается на этот раз.

1861
01:34:32,420 --> 01:34:35,635
Вместо проверки для argc2,
Я буду вместо этого.

1862
01:34:35,635 --> 01:34:41,270
Для инт я получаю 0, я меньше
чем ARGC, я плюс плюс,

1863
01:34:41,270 --> 01:34:47,920
а затем распечатать внутри этого,
процентов s, новая линия, а затем

1864
01:34:47,920 --> 01:34:50,740
ARGV кронштейн я.

1865
01:34:50,740 --> 01:34:55,220
>> Итак, другими словами, я не имеем дело с
отдельные символы в данный момент.

1866
01:34:55,220 --> 01:35:00,190
ARGV, как следует из этих пустой квадрат
брекет справа от имени ARGV,

1867
01:35:00,190 --> 01:35:03,320
означает ARGV массив строк.

1868
01:35:03,320 --> 01:35:04,870
И ARGC это просто инт.

1869
01:35:04,870 --> 01:35:08,800
>> Эта линия здесь, 6, является
говоря набор я равным 0.

1870
01:35:08,800 --> 01:35:11,980
Граф весь путь до,
но не включая, ARGC.

1871
01:35:11,980 --> 01:35:14,010
И затем на каждой итерации,
распечатать строку.

1872
01:35:14,010 --> 01:35:14,800
Какая строка?

1873
01:35:14,800 --> 01:35:17,270
>> I-й строки в ARGV.

1874
01:35:17,270 --> 01:35:19,530
Так что в то время, прежде чем я был
используя квадратные скобки

1875
01:35:19,530 --> 01:35:22,180
обозначения, чтобы получить в г-й
символ в строке, теперь

1876
01:35:22,180 --> 01:35:27,240
Я использую квадратные скобки, обозначения
чтобы получить в строке й в массиве.

1877
01:35:27,240 --> 01:35:30,310
Так что это своего рода один слой
выше, концептуально.

1878
01:35:30,310 --> 01:35:35,390
>> Так что аккуратным об этом
Программа теперь, если я компилирую argv1,

1879
01:35:35,390 --> 01:35:42,067
а затем сделать ./argv1, а затем введите
в чем-то вроде бара Baz Foo,

1880
01:35:42,067 --> 01:35:45,400
которые являются три стандартные слова, которые
ученый достигает в течение любого времени

1881
01:35:45,400 --> 01:35:51,010
он или она нуждается в некоторых шаблонные слова,
и нажмите Enter, каждое из этих слов,

1882
01:35:51,010 --> 01:35:54,980
в том числе название программы, которая
находится в ARGV на первом месте,

1883
01:35:54,980 --> 01:35:58,320
заканчивается печатается по одному за раз.

1884
01:35:58,320 --> 01:36:05,290
И если я изменить это, и я говорю:
что-то вроде argv1 Zamyla Чан,

1885
01:36:05,290 --> 01:36:08,800
мы получаем все три из них
слова, что является argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, потому что в этом
случай ARGC, счетчик, 3.

1887
01:36:14,400 --> 01:36:20,020
>> Но что аккуратный, если вы понимаете,
что ARGV просто массив строк,

1888
01:36:20,020 --> 01:36:24,910
и вы понимаете, что строка
представляет собой массив символов,

1889
01:36:24,910 --> 01:36:29,470
мы можем на самом деле вид использовать эту функцию
квадратные скобки обозначения несколько раз

1890
01:36:29,470 --> 01:36:33,320
чтобы выбрать строку, а затем выберите
символ в строке,

1891
01:36:33,320 --> 01:36:35,730
дайвинг глубже следующим образом.

1892
01:36:35,730 --> 01:36:40,100
В этом примере, отпусти меня
вперед и назвать эту argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
И в этом примере, позвольте мне идти вперед
и сделать following-- для INT я получаю 0,

1895
01:36:50,180 --> 01:36:53,286
я меньше ARGC, я плюс
плюс, так же, как и раньше.

1896
01:36:53,286 --> 01:36:55,910
Таким образом, в другом words-- и теперь этот
становится достаточно сложной.

1897
01:36:55,910 --> 01:36:59,940
Тогда я собираюсь сказать,
перебирать струны в ARGV,

1898
01:36:59,940 --> 01:37:01,294
в качестве комментария к себе.

1899
01:37:01,294 --> 01:37:03,960
И тогда я буду иметь
вложенный цикл, который вы, вероятно,

1900
01:37:03,960 --> 01:37:06,290
сделали или считаются
делать в пустом месте, где

1901
01:37:06,290 --> 01:37:08,600
Я хочу сказать, я int--
не собирается использовать я снова,

1902
01:37:08,600 --> 01:37:12,590
потому что я не хочу, чтобы тень, или
своего рода переписать существующий I.

1903
01:37:12,590 --> 01:37:15,780
>> Я собираюсь, а не, скажем, J, так как
это моя перейти к переменной после того как я,

1904
01:37:15,780 --> 01:37:18,590
когда я просто пытаюсь
рассчитывать простые числа.

1905
01:37:18,590 --> 01:37:28,850
Для J получает 0--, а также, п, собирается
получить кормовой длину ARGV кронштейна I,

1906
01:37:28,850 --> 01:37:36,030
до тех пор, J меньше т,
J плюс плюс, сделайте следующее.

1907
01:37:36,030 --> 01:37:37,500
А вот интересная часть.

1908
01:37:37,500 --> 01:37:46,330
>> Распечатайте характер и новую линию,
подключив ARGV кронштейн I, кронштейн J.

1909
01:37:46,330 --> 01:37:47,940
ОК, так что позвольте мне добавить некоторые комментарии здесь.

1910
01:37:47,940 --> 01:37:54,820
Перебрать символы
в текущей строке,

1911
01:37:54,820 --> 01:38:02,290
печать J-й символ в г-й строке.

1912
01:38:02,290 --> 01:38:04,630
Так что теперь, давайте рассмотрим
Что означают эти комментарии.

1913
01:38:04,630 --> 01:38:06,750
>> Перебор по струнам
в argv-- сколько

1914
01:38:06,750 --> 01:38:09,300
строки в ARGV, который является массивом?

1915
01:38:09,300 --> 01:38:13,420
ARGC много, поэтому я итерация
от я равно 0 до ARGC.

1916
01:38:13,420 --> 01:38:20,020
В то же время, сколько символов
в г-й строки в ARGV?

1917
01:38:20,020 --> 01:38:22,880
>> Ну, чтобы получить этот ответ,
Я просто называю длину строки

1918
01:38:22,880 --> 01:38:26,810
на I уход текущей строки
о, что ARGV кронштейн я.

1919
01:38:26,810 --> 01:38:30,090
И я собираюсь временно хранить, что
значение п, только для целей кэширования,

1920
01:38:30,090 --> 01:38:31,590
помнить его эффективности.

1921
01:38:31,590 --> 01:38:36,330
И тогда я буду инициализировать J 0,
продолжать идти так долго, как J меньше п,

1922
01:38:36,330 --> 01:38:38,430
и на каждый шаг итерации J.

1923
01:38:38,430 --> 01:38:41,030
>> А потом здесь, в
мой комментарий в строке 12,

1924
01:38:41,030 --> 01:38:43,390
распечатать символ,
а затем новой линии,

1925
01:38:43,390 --> 01:38:48,140
специально ARGV кронштейн
я дает мне I-й строки

1926
01:38:48,140 --> 01:38:51,690
в argv-- так что первое слово, то
Второе слово, третье слово, что угодно.

1927
01:38:51,690 --> 01:38:57,370
А потом J ныряет глубже и получает
я J-й символ этого слова.

1928
01:38:57,370 --> 01:39:02,200
И так, в сущности, вы можете обращаться
ARGV как многомерное,

1929
01:39:02,200 --> 01:39:06,050
в качестве двумерного массива,,
причем каждое слово вид выглядит

1930
01:39:06,050 --> 01:39:08,580
как это в вашем воображении
глаза, и каждый символ

1931
01:39:08,580 --> 01:39:10,930
является своего рода состоит в
столбец, если это помогает.

1932
01:39:10,930 --> 01:39:13,260
>> На самом деле, когда мы дразнить
это друг от друга в будущих недель,

1933
01:39:13,260 --> 01:39:15,580
это будет немного
более сложной, чем это.

1934
01:39:15,580 --> 01:39:17,800
Но вы можете реально
думать о том, что на данный момент,

1935
01:39:17,800 --> 01:39:22,110
как только что это двумерная
Массив, в результате чего один уровень его

1936
01:39:22,110 --> 01:39:23,260
это все строки.

1937
01:39:23,260 --> 01:39:26,760
И потом, если вы ныряете в глубже, вы
может получить в отдельных символов

1938
01:39:26,760 --> 01:39:29,600
в нем, используя эти обозначения здесь.

1939
01:39:29,600 --> 01:39:31,620
>> Так что же такое чистый эффект?

1940
01:39:31,620 --> 01:39:34,970
Позвольте мне идти вперед и
сделать argv2-- штопать его.

1941
01:39:34,970 --> 01:39:36,210
Я сделал ошибку здесь.

1942
01:39:36,210 --> 01:39:40,160
Косвенно объявив
библиотека функций Стирлинга.

1943
01:39:40,160 --> 01:39:42,190
Так что все это время, это
возможно, целесообразно

1944
01:39:42,190 --> 01:39:45,130
что мы вроде отделки
именно там, где мы начали.

1945
01:39:45,130 --> 01:39:48,160
>> Я облажался, безоговорочное признание
библиотека функций Стирлинга.

1946
01:39:48,160 --> 01:39:48,987
Хорошо, подождите минуту.

1947
01:39:48,987 --> 01:39:51,070
Я помню, что, особенно
так как это прямо здесь.

1948
01:39:51,070 --> 01:39:54,490
Мне нужно, чтобы включить string.h в
эта версия программы.

1949
01:39:54,490 --> 01:40:00,050
>> Позвольте мне идти вперед и включают в себя
string.h, кроме того, что, идти вперед

1950
01:40:00,050 --> 01:40:04,460
и пересобрать argv2.

1951
01:40:04,460 --> 01:40:08,390
И теперь, здесь мы идем, сделать argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
И хотя это немного
загадочные на первый взгляд,

1953
01:40:10,590 --> 01:40:15,690
обратите внимание, что, на самом деле, то, что
распечатывается является точка argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Но если я ввести некоторые слова за
подскажите, как argv2 Zamyla Чан,

1955
01:40:19,970 --> 01:40:22,560
Введите, также немного
загадочные на первый взгляд.

1956
01:40:22,560 --> 01:40:30,540
Но если мы прокручиваем обратно вверх,
./argv2 Z-А-М-У-Л-С-Н-А-Н.

1957
01:40:30,540 --> 01:40:32,190
Таким образом, мы итерацию над каждым словом.

1958
01:40:32,190 --> 01:40:37,770
И, в свою очередь, мы итерации
каждый символ в слове.

1959
01:40:37,770 --> 01:40:40,040
>> Теперь, после того, как все это,
понимаю, что есть

1960
01:40:40,040 --> 01:40:43,120
одна деталь мы были своего рода
игнорировать все это время.

1961
01:40:43,120 --> 01:40:46,180
Мы просто дразнят друг от друга, что
Входы главных может быть?

1962
01:40:46,180 --> 01:40:47,780
Как насчет выхода главных в?

1963
01:40:47,780 --> 01:40:50,540
>> Все это время мы были
просто копирование и вставка

1964
01:40:50,540 --> 01:40:53,870
слово INT перед главным образом,
хотя вы можете увидеть в Интернете,

1965
01:40:53,870 --> 01:40:58,340
иногда неправильно в более ранних версиях
С и компиляторов, что они говорят, что пустота,

1966
01:40:58,340 --> 01:40:59,410
или вообще ничего.

1967
01:40:59,410 --> 01:41:01,580
Но, на самом деле, для версии
С, что мы используем,

1968
01:41:01,580 --> 01:41:06,180
C 11, или 2011, реализовать
что оно должно быть инт.

1969
01:41:06,180 --> 01:41:09,300
И это должно быть либо
недействительным или ARGC и ARGV здесь.

1970
01:41:09,300 --> 01:41:10,790
>> Но почему INT главный?

1971
01:41:10,790 --> 01:41:12,480
Что это на самом деле возвращение?

1972
01:41:12,480 --> 01:41:16,280
Что ж, оказывается, все это время,
в любое время вы написали программа главная

1973
01:41:16,280 --> 01:41:18,440
всегда возвращается что-то.

1974
01:41:18,440 --> 01:41:19,960
Но это было делать это тайно.

1975
01:41:19,960 --> 01:41:23,350
>> Это что-то есть
INT, в строке 5 предлагает.

1976
01:41:23,350 --> 01:41:24,225
Но что INT?

1977
01:41:24,225 --> 01:41:26,100
Ну, есть такая
конвенции в области программирования,

1978
01:41:26,100 --> 01:41:29,790
причем, если ничего не имеет
пошло не так, и все хорошо,

1979
01:41:29,790 --> 01:41:34,250
программы и функции в целом
return-- несколько counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 в целом означает, что все хорошо.

1982
01:41:38,070 --> 01:41:40,610
Так что даже если вы думаете
это как ложь во многих контекстах,

1983
01:41:40,610 --> 01:41:42,930
это на самом деле означает, как правило, хорошая вещь

1984
01:41:42,930 --> 01:41:49,560
>> В то же время, если программа возвращает 1,
или отрицательный 1, или 5, или отрицательный 42,

1985
01:41:49,560 --> 01:41:52,941
или любой не-0 значение,
что в целом означает

1986
01:41:52,941 --> 01:41:54,190
что что-то пошло не так.

1987
01:41:54,190 --> 01:41:56,700
На самом деле, на вашем собственном Mac или PC,
Вы, возможно, на самом деле видел

1988
01:41:56,700 --> 01:42:01,050
сообщение об ошибке, в результате чего его
говорит что-то или другое, ошибка

1989
01:42:01,050 --> 01:42:04,940
код отрицательный 42, или код ошибки
23, или что-то в этом роде.

1990
01:42:04,940 --> 01:42:08,980
Это число, как правило, только намек
программисту или компании

1991
01:42:08,980 --> 01:42:11,174
что сделал программное обеспечение,
что пошло не так и почему,

1992
01:42:11,174 --> 01:42:13,590
таким образом, чтобы они могли смотреть через
их документация или код,

1993
01:42:13,590 --> 01:42:15,465
и выяснить, что
ошибка на самом деле означает.

1994
01:42:15,465 --> 01:42:18,400
Как правило, не
полезным для нас конечных пользователей.

1995
01:42:18,400 --> 01:42:20,550
>> Но когда основные возвращает 0, все хорошо.

1996
01:42:20,550 --> 01:42:23,770
И если вы не укажете
какие основные должны вернуться,

1997
01:42:23,770 --> 01:42:26,950
он просто будет автоматически
возвращает значение 0 для вас.

1998
01:42:26,950 --> 01:42:30,870
Но, возвращаясь что-то
еще на самом деле полезно.

1999
01:42:30,870 --> 01:42:34,660
>> В этой заключительной программе, дайте мне
идти вперед и назвать эту exit.c,

2000
01:42:34,660 --> 01:42:38,630
и ввести последний из сегодняшних
темы, известные как код ошибки.

2001
01:42:38,630 --> 01:42:42,930
Позвольте мне идти вперед и включают в себя наши
знакомые файлы Наверху, сделайте INT главный.

2002
01:42:42,930 --> 01:42:49,500
И на этот раз, давайте делать Int ARGC,
Строка ARGV, и с моих скобках

2003
01:42:49,500 --> 01:42:50,836
подразумевает, что это в массиве.

2004
01:42:50,836 --> 01:42:52,460
И тогда позвольте мне сделать проверку вменяемости.

2005
01:42:52,460 --> 01:42:56,640
На этот раз, если ARGC не
равно 2, то вы знаете, что?

2006
01:42:56,640 --> 01:42:57,520
Забудь это.

2007
01:42:57,520 --> 01:43:03,170
Я хочу сказать, что, эй, пользователь,
вам не хватает аргумент командной строки

2008
01:43:03,170 --> 01:43:04,210
обратная косая п.

2009
01:43:04,210 --> 01:43:05,230
>> А потом это все.

2010
01:43:05,230 --> 01:43:06,130
Я хочу, чтобы выйти.

2011
01:43:06,130 --> 01:43:11,030
Я собираюсь превентивно,
и преждевременно действительно, возвращение

2012
01:43:11,030 --> 01:43:12,810
что-то другое, чем число 1.

2013
01:43:12,810 --> 01:43:15,360
Перейти к значению для первого
ошибка, которая может произойти 1.

2014
01:43:15,360 --> 01:43:17,860
Если у вас есть какой-то другой ошибочный
ситуация, которая может произойти,

2015
01:43:17,860 --> 01:43:21,390
Вы могли бы сказать, возвращение 2 или возвращение 3, или
может быть, даже отрицательный 1 или отрицательный 2.

2016
01:43:21,390 --> 01:43:23,750
>> Это только коды завершения
которые являются, как правило,

2017
01:43:23,750 --> 01:43:27,770
только полезно для программиста, или
компания, судоходная программное обеспечение.

2018
01:43:27,770 --> 01:43:30,500
Но тот факт, что это
не 0, что важно.

2019
01:43:30,500 --> 01:43:34,310
Так что, если в этой программе, я хочу
гарантировать, что эта программа только

2020
01:43:34,310 --> 01:43:38,190
работает, если пользователь предоставляет мне
с количеством аргументов, из двух,

2021
01:43:38,190 --> 01:43:42,880
название программы, а также некоторые другие
слово, я могу применять столько, сколько следует,

2022
01:43:42,880 --> 01:43:46,110
кричать на пользователя с PRINTF поговорке,
отсутствует аргумент командной строки,

2023
01:43:46,110 --> 01:43:46,970
возвращает 1.

2024
01:43:46,970 --> 01:43:49,940
Это будет просто немедленно
выйти из программы.

2025
01:43:49,940 --> 01:43:55,840
>> Только если ARGC равен 2 мы получим вниз
здесь, в какой момент я собираюсь сказать,

2026
01:43:55,840 --> 01:44:00,410
привет процентов s, обратный слэш н, argv1.

2027
01:44:00,410 --> 01:44:03,827
Другими словами, я
не будет после того, как ARGV 0,

2028
01:44:03,827 --> 01:44:05,410
который является только название программы.

2029
01:44:05,410 --> 01:44:09,450
Я хочу, чтобы напечатать Привет, запятая,
второе слово, которое напечатал человек.

2030
01:44:09,450 --> 01:44:12,580
И в этом случае на
строка 13, все хорошо.

2031
01:44:12,580 --> 01:44:15,920
>> Я знаю, что ARGC 2
логически вытекает из этой программы.

2032
01:44:15,920 --> 01:44:17,770
Я собираюсь идти вперед и возвращать 0.

2033
01:44:17,770 --> 01:44:21,230
Как и в сторону, имейте в виду, что
это верно в пустом месте, а также.

2034
01:44:21,230 --> 01:44:24,760
>> По логике вещей, я мог бы это сделать
и инкапсулировать эти строки

2035
01:44:24,760 --> 01:44:27,020
кода в этом пункте остальное здесь.

2036
01:44:27,020 --> 01:44:29,420
Но это своего рода
излишне отступы мой код.

2037
01:44:29,420 --> 01:44:31,800
И я хочу, чтобы сделать супер
ясно, что независимо от того,

2038
01:44:31,800 --> 01:44:34,670
по умолчанию, привет
что-то и будет напечатан,

2039
01:44:34,670 --> 01:44:36,050
до тех пор, пока пользователь взаимодействует.

2040
01:44:36,050 --> 01:44:39,360
>> Так что это очень распространено использование
состояние, просто если,

2041
01:44:39,360 --> 01:44:41,870
поймать некоторые ошибочные
ситуация, а затем выйти.

2042
01:44:41,870 --> 01:44:45,690
И тогда, до тех пор, все
ну, не имеют другого,

2043
01:44:45,690 --> 01:44:48,060
но просто код
снаружи, что, если, потому что это

2044
01:44:48,060 --> 01:44:51,060
эквивалент в этом
частный случай, логически.

2045
01:44:51,060 --> 01:44:54,480
Так что я возвращаюсь 0, просто
явно означает, что все хорошо.

2046
01:44:54,480 --> 01:44:58,480
>> Если я пропустил возвращение 0, было бы
автоматически предполагается, для меня.

2047
01:44:58,480 --> 01:45:00,890
Но теперь, когда я возвращаюсь
один, по крайней мере этом случае,

2048
01:45:00,890 --> 01:45:04,940
Я собираюсь, для хорошей мерой и
ясность, возвращает 0 в этом случае.

2049
01:45:04,940 --> 01:45:09,690
Так что теперь позвольте мне идти вперед и сделать выход,
который является идеальным Segue просто уйти.

2050
01:45:09,690 --> 01:45:14,401
>> Но сделать выход, и отпустить меня
вперед и делать ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
И программа заорал на меня,
отсутствует аргумент командной строки.

2052
01:45:16,900 --> 01:45:18,120
Хорошо, позвольте мне сотрудничать.

2053
01:45:18,120 --> 01:45:23,810
>> Позвольте мне вместо того, чтобы делать ./exit, Дэвид, Enter.

2054
01:45:23,810 --> 01:45:25,190
А теперь он говорит, привет Дэвид.

2055
01:45:25,190 --> 01:45:27,300
И вы обычно не видите это.

2056
01:45:27,300 --> 01:45:30,650
>> Но оказывается, что есть
особый путь в Linux на самом деле увидеть

2057
01:45:30,650 --> 01:45:34,470
с тем, что код завершения программы завершается.

2058
01:45:34,470 --> 01:45:37,184
Иногда в графическом
мир, как Mac OS или Windows,

2059
01:45:37,184 --> 01:45:40,100
вы видите только эти цифры, когда
сообщение об ошибке появляется на экране

2060
01:45:40,100 --> 01:45:41,940
и программист
показывает, что число.

2061
01:45:41,940 --> 01:45:44,773
Но если мы хотим, чтобы увидеть, что ошибка
сообщение, мы можем сделать это here--

2062
01:45:44,773 --> 01:45:48,100
так ./exit, Enter, печать
отсутствует аргумент командной строки.

2063
01:45:48,100 --> 01:45:54,590
>> Если я теперь делать эхо $ ?, который
смешно загадочные глядя.

2064
01:45:54,590 --> 01:45:56,590
Но $?

2065
01:45:56,590 --> 01:45:59,220
является магическим заклинанием
что говорит, эй, компьютер,

2066
01:45:59,220 --> 01:46:01,900
скажите мне, что предыдущий
код выхода программы был.

2067
01:46:01,900 --> 01:46:03,410
И я ударил Enter.

2068
01:46:03,410 --> 01:46:07,520
Я вижу 1, потому что это то, что я
сказал своей основной функции, чтобы вернуться.

2069
01:46:07,520 --> 01:46:12,310
>> В то же время, если я ./exit Давида,
и нажмите Enter, я вижу, привет Давида.

2070
01:46:12,310 --> 01:46:16,800
И если я теперь делать эхо $ ?, Я вижу привет 0.

2071
01:46:16,800 --> 01:46:19,080
И таким образом это будет на самом деле
быть ценной информации

2072
01:46:19,080 --> 01:46:23,420
в контексте отладчика, не так
много, что вы, человек, будет заботиться.

2073
01:46:23,420 --> 01:46:26,060
Но отладчик и другие
программы, которые мы будем использовать в этом семестре

2074
01:46:26,060 --> 01:46:29,420
будет часто смотреть на это число,
несмотря на то, что это своего рода запрятаны

2075
01:46:29,420 --> 01:46:32,780
если не искать его, чтобы
определить, действительно ли програмы

2076
01:46:32,780 --> 01:46:37,050
исполнение было правильным или неправильным.

2077
01:46:37,050 --> 01:46:40,450
>> И так, что приводит нас к
это, в конце дня.

2078
01:46:40,450 --> 01:46:43,917
Мы начали сегодня, глядя на
отладки, и в свою очередь, в ходе

2079
01:46:43,917 --> 01:46:46,750
сама по себе, а затем более интересно,
технически под капотом

2080
01:46:46,750 --> 01:46:49,490
на то, что строки, которые длятся
неделю мы просто взяли нечто само собой разумеющееся,

2081
01:46:49,490 --> 01:46:51,900
и, конечно, взял их
как само собой разумеющееся в пустом месте.

2082
01:46:51,900 --> 01:46:56,040
>> Затем мы рассмотрели, как мы можем получить доступ
отдельные символы в строке,

2083
01:46:56,040 --> 01:47:00,310
а затем снова взял на более высокий уровень
смотреть на вещи, глядя на то, как well--

2084
01:47:00,310 --> 01:47:04,226
если мы хотим получить на индивидуальном
элементы в списке, как структура,

2085
01:47:04,226 --> 01:47:05,850
мы не можем сделать это с несколькими строками?

2086
01:47:05,850 --> 01:47:08,050
И мы можем с аргументами командной строки.

2087
01:47:08,050 --> 01:47:12,800
Но эта картина здесь просто коробки
Показательно в этой общей идеи

2088
01:47:12,800 --> 01:47:14,451
массива или списка или вектора.

2089
01:47:14,451 --> 01:47:16,450
И в зависимости от
контекст, все эти слова

2090
01:47:16,450 --> 01:47:17,880
означают немного разные вещи.

2091
01:47:17,880 --> 01:47:20,060
Таким образом, в C, мы только собираемся
говорить о массиве.

2092
01:47:20,060 --> 01:47:23,840
И массив представляет собой кусок
памяти, каждый из которых это

2093
01:47:23,840 --> 01:47:27,720
элементы являются смежными, обратно,
к спине, к спине, к спине.

2094
01:47:27,720 --> 01:47:31,970
>> И эти элементы, как правило,
одного и того же типа данных, символов,

2095
01:47:31,970 --> 01:47:35,966
характер, характер, характер, или
строка, строка, строка, строка, или INT,

2096
01:47:35,966 --> 01:47:38,600
INT, INT, то, что это
мы пытаемся сохранить.

2097
01:47:38,600 --> 01:47:42,540
Но в конце концов, это
как это выглядит концептуально.

2098
01:47:42,540 --> 01:47:44,530
Вы берете ваш
памяти или ОЗУ компьютера.

2099
01:47:44,530 --> 01:47:48,590
И вы вырезая его в
одинакового размера коробки, все из которых

2100
01:47:48,590 --> 01:47:50,920
вернулись, к спине, чтобы
назад, к спине таким образом.

2101
01:47:50,920 --> 01:47:53,200
>> И что приятно о
эта идея, и тот факт,

2102
01:47:53,200 --> 01:47:58,580
что мы можем выразить значения в этом случае
с первым из наших структур данных

2103
01:47:58,580 --> 01:48:02,520
в классе, означает, что мы можем начать
решить проблемы с кодом

2104
01:48:02,520 --> 01:48:04,079
что пришло так интуитивно в неделю 0.

2105
01:48:04,079 --> 01:48:05,870
Вы помните, телефон
Пример книги, где

2106
01:48:05,870 --> 01:48:09,110
мы использовали разделяй и властвуй,
или двоичный алгоритм поиска,

2107
01:48:09,110 --> 01:48:13,220
просеивать в целом
куча имен и номеров.

2108
01:48:13,220 --> 01:48:18,220
Но мы предполагали, напомним, что это
Телефонная книга была уже отсортирован,

2109
01:48:18,220 --> 01:48:21,630
что кто-то уже
фигурный out-- дан список имен

2110
01:48:21,630 --> 01:48:24,430
и numbers--, как в алфавитном порядке их.

2111
01:48:24,430 --> 01:48:26,950
И теперь, когда в C мы,
тоже есть возможность

2112
01:48:26,950 --> 01:48:30,290
заложить вещи, а не
физически в телефонной книге

2113
01:48:30,290 --> 01:48:34,220
но практически в компьютера
память, мы сможем на следующей неделе

2114
01:48:34,220 --> 01:48:38,470
ввести снова this-- первый
наших структур данных в array--

2115
01:48:38,470 --> 01:48:43,530
но что более важно, фактический компьютер
Алгоритмы науки реализованы

2116
01:48:43,530 --> 01:48:47,720
в коде, с помощью которого мы можем хранить
данные в структурах, как это,

2117
01:48:47,720 --> 01:48:50,730
а затем начинают манипулировать ею, и
на самом деле решить проблемы, связанные с ним,

2118
01:48:50,730 --> 01:48:53,570
и построить на вершине этого,
в конечном счете, программы в C,

2119
01:48:53,570 --> 01:48:56,730
в Python, в JavaScript,
запросов к базам данных с SQL?

2120
01:48:56,730 --> 01:48:59,980
>> И мы видим, что все эти
различные идеи блокировки.

2121
01:48:59,980 --> 01:49:04,100
Но сейчас, напомним, что
Домен, который мы ввели сегодня

2122
01:49:04,100 --> 01:49:06,920
была эта вещь здесь, и
мир криптографии.

2123
01:49:06,920 --> 01:49:11,200
А среди следующих проблем вы сами
будет решать это искусство криптографии,

2124
01:49:11,200 --> 01:49:13,630
скремблирования и дескремблирования
информация, и шифрации

2125
01:49:13,630 --> 01:49:15,930
и расшифровка текста,
и предполагая, в конечном счете,

2126
01:49:15,930 --> 01:49:18,970
что теперь вы знаете, что
находится под капотом

2127
01:49:18,970 --> 01:49:21,860
так что, когда вы видите или получить
сообщение как это, вы

2128
01:49:21,860 --> 01:49:24,060
сами можете расшифровать его.

2129
01:49:24,060 --> 01:49:26,740
Все это, и больше в следующий раз.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [ПРОИГРЫВАНИЕ ВИДЕО]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Только что прибыл.

2133
01:49:32,970 --> 01:49:35,146
Я собираюсь идти визит
его профессор колледжа.

2134
01:49:35,146 --> 01:49:37,611
Ага.

2135
01:49:37,611 --> 01:49:40,080
Здравствуй.

2136
01:49:40,080 --> 01:49:40,660
Это ты.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Подождите!

2139
01:49:45,110 --> 01:49:45,610
Дэвид.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Я просто пытаюсь понять
что случилось с вами.

2142
01:49:56,060 --> 01:49:58,130
Пожалуйста, что-нибудь может помочь.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Вы были его колледж
сосед по комнате, не так ли?

2145
01:50:08,354 --> 01:50:10,770
Вы были там с ним, когда
он завершил проект CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [МУЗЫКА]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Вот Был CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Мне нравится это место.

2152
01:50:44,770 --> 01:50:45,854
>> -Eat Вверх.

2153
01:50:45,854 --> 01:50:47,020
Мы собираемся из бизнеса.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [КОНЕЦ ВОСП]

