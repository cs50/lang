[МУЗЫКА] 

DAVID J. Малан: Хорошо. Это CS50 и это является началом 2-й неделе. И вы помните, что более последние пару недель, мы представили компьютер наука и, в свою очередь, программирование. 

И мы начали рассказ путем Царапина, что графический язык из медиа-лаборатории Массачусетского технологического института. А потом совсем недавно, На прошлой неделе, мы сделали ввести higher-- A язык более низкого уровня известны как С, то, что это чисто текстуально. И, действительно, последний раз, когда мы изучить в этом контексте ряд понятий. 

Это, напомним, был очень Первая программа мы рассмотрели. И эта программа, довольно просто, печатает "Привет, мир." Но есть так много кажущейся магии происходит. Там эта #include с этих угловых скобках. Там в инт. Там в (аннулируются). Там в круглые скобки, фигурные скобки, точка с запятой, и многое другое. 

Так, напомним, что мы ввели Царапину так что мы могли бы, в идеале, увидеть прошлое что синтаксис, материал, который действительно не все, что интеллектуально интересно, но на ранних стадиях это, безусловно, немного сложнее чтобы обернуть ваш разум вокруг. И в самом деле, одно из самых распространенных вещи на раннем этапе в классе программирования, особенно для тех, кто меньше удобно, чтобы сломаться, и подставляли некоторыми синтаксическими ошибки, не говоря уже о логических ошибок. И поэтому среди наших целей сегодня, на самом деле, будет будет оснащать вас с некоторыми методы решения проблем для того, как чтобы лучше решать проблемы сами в виде отладки. И вы помните, тоже, что среда, мы ввели последний раз был назван CS50 IDE. Это веб-программное обеспечение, позволяет программировать в облаке, так сказать, сохраняя при этом все ваши файлы вместе, как мы снова будем сегодня. И напомним, что мы пересмотреть эти темы здесь, среди них функций, а также петли, и переменные и логические выражения, и условия. И на самом деле несколько больше, что мы в переводе с нуля мира к миру C. 

Но основное здание блоки, так сказать, действительно были все те же на прошлой неделе. На самом деле, мы действительно только имели разные кусок головоломки, если вы будете. Вместо того, что фиолетовый сохранить блок, мы вместо того, чтобы был PRINTF, который эта функция в С, позволяет напечатать что-нибудь и отформатировать его на экране. Мы ввели CS50 Библиотека, где вы есть сейчас в вашем распоряжении get_char, и get_int и get_string, и несколько других функций, как ну, с помощью которого вы можете получить ввод от собственной клавиатуры пользователя. И мы также взяли взгляд на вещи как these- BOOL и полукокса, и двойные, с плавающей точкой, INT, long_long строка. И есть даже другие типы данных в C. 

Другими словами, когда вы объявляете переменная для хранения некоторого значения, или при реализации функции которая возвращает некоторое значение, Вы можете указать, что тип значения, которое. Это строка, подобно последовательность символов? Это число, как целое число? Является ли это с плавающей точкой значение, или тому подобное? Таким образом, в C, в отличие от нуля, мы на самом деле начал указывать, какой тип данных мы возвращались или использования. 

Но, конечно, мы также столкнулись с некоторые фундаментальные пределы вычислений. И в частности, этот язык C, напомним что мы смотрели на Целочисленное переполнение, реальность что если у вас есть только конечное количество памяти или, в частности, конечное число битов, вы можете рассчитывать только так высоко. И таким образом, мы смотрели на этот пример здесь в результате чего счетчик в самолете,, на самом деле, если работает достаточно долго будет переполнение и результат в программном обеспечении фактический физический потенциал ошибки. 

Мы также рассмотрели плавающей точка неточностей, реальность что только с конечным числом битов, будь то 32 или 64, вы можете указать только так много чисел после десятичной точки, после чего вы начинают получать неточным. Так, например, одна треть в мир здесь, в нашем человеческом мире, мы знаем, это просто бесконечное число 3 сек после десятичной точки. Но компьютер не обязательно представляют собой бесконечное число цифр если вы только дайте ему некоторые конечное количество информации. 

Так что мы не только вооружить вас с большей силой в плане как Вы могли бы выразить себя в клавиатура с точки зрения программирования, мы также ограничены, что вы можете реально сделать. И в самом деле, ошибки и ошибки могут возникают из этих видов вопросов. И действительно, среди тем сегодня будут такие темы, как отладки и на самом деле, глядя под капотом на то, как были введены вещи на прошлой неделе на самом деле реализованы так что вам лучше понять, как возможностей и ограничения языка как C. 

И в самом деле, мы отогните слои из простейших структуры данных, то, что называется массив, который Царапина случается называть "список." Это немного отличается в этом контексте. И тогда мы будем также ввести одно из первый из наших проблем предметно-ориентированных в CS50, мир криптография, искусство карабкаться или в шифровании информации, так что вы можете отправлять секретные сообщения и декодировать секретные сообщения между двумя лицами, А и В. 

Поэтому, прежде чем мы перехода к этому новому миру, давайте попробуем снабдить вас с некоторыми методы, с которыми вы можете устранить или уменьшить по крайней мере, некоторые разочарований что вы, вероятно, сталкивались Только за прошедшую неделю. На самом деле, впереди вас such-- некоторые из ваши первые проблемы в С и форы, если вы похожи на меня, в первый раз вы пытаетесь впечатать программу, даже если вы думаете, логически Программа довольно проста, вы можете очень хорошо врезался в стену, и компилятор не собирается сотрудничать. Делают или Clang не собирается на самом деле сделать ваши ставки. 

И почему это может быть? Что ж, давайте посмотрим на, может быть, простая программа. Я собираюсь идти вперед и сохранить это в файл намеренно называют buggy0.c, потому что я знаю его быть испорчен заранее. Но я не мог понять, что если это первый или второй или третьей программы что я на самом деле делает сам. Так что я собираюсь идти вперед и впечатать, Int основной (вакуум). И тогда внутри моих фигурные скобки, очень знакомый ( "привет, world-- обратной косой черты, п ") - и точка с запятой. 

Я сохранил файл. Теперь я собираюсь пойти вниз к моему окне терминала и тип делают buggy0, потому что, опять же, имя файла сегодня buggy0.c. Так что я типа сделать buggy0, Enter. 

И, о, господи, помните из последнего времени что без каких-либо сообщений об ошибках это хорошая вещь. Так что вывод не является хорошей вещью. Но здесь я ясно некоторое количество ошибок. 

Таким образом, в первой строке вывода после ввода делают buggy0, напомним, довольно подробный вывод звоном в. Под капотом, CS50 IDE настроен использовать целую кучу Варианты с этим компилятором так что у вас нет думать о них. И это все, что первая линия означает, что начинается с Clang. 

Но после этого, проблемы начать делать их внешний вид. Buggy0.c на линии 3, характер 5, есть большая, красная ошибка. Что это? Косвенно объявляя функции библиотеки PRINTF с типом Int (сопзЬ сЬаг *, ...) [-Werror]. Я имею в виду, это очень быстро становится очень аркан. И, конечно же, в первую очередь взгляд, мы не будем ожидают, что вы понимаете полнота этого сообщения. И вот один из уроков на сегодняшний день происходит чтобы попытаться заметить узоры, или подобные вещи, к ошибкам вы можете иметь столкнулись в прошлом. Так что давайте дразнить только друг от друга те слова, которые выглядят знакомыми. Большой, красный ошибка явно символом чего-то ошибиться. 

безоговорочное признание Библиотека функций Printf. Так что даже если я не совсем понимаю, что неявно объявляя функции библиотеки Значит, проблема, конечно, относится к PRINTF каким-то образом. И источник этого вопроса имеет дело с объявив его. 

Объявление функции является упоминания о нем в первый раз. И мы использовали терминологию на прошлой неделе того, чтобы объявить прототип функции во, либо с одной линией в верхней части вашего собственный файл или в так называемом файле заголовка. И в каком файле сделал мы говорим на прошлой неделе, что Printf цитата, Unquote, заявил? В каком файле находится его прототип? 

Так что, если вы помните, самое первое, что я типизированных, почти каждая программа в прошлом time-- и случайно минуту назад началась набрав myself-- был один here-- hash-- #include <stio-- для вход / output-- точка ч И действительно, если я теперь сохранить этот файл, я собираюсь идти вперед и очистить экран, которые вы можете сделать, введя Ясно, или вы можете держать управления L, просто очистить окно терминала просто чтобы устранить некоторые помехи. 

Я собираюсь идти вперед и повторно типа делают buggy0, Enter. И вуаля, я до сих пор вижу, что долгое время команда из Clang, но нет никакого сообщения об ошибке на этот раз. И в самом деле, если я ./buggy0, так же, как в прошлый раз, где точка означает это каталог, Слэш просто означает, здесь идет название программы и что название программы buggy0, Введите, "Привет, мир." 

Теперь, как вы, возможно, почерпнутые это решение не обязательно признавая, как много слов, как и я, конечно же, имея сделали это в течение многих лет? Ну, реализовать в первой задаче набор, мы познакомим вас с командой что собственный персонал CS50 в написал под названием help50. И в самом деле, C делает спецификацию проблема установить относительно того, как использовать эту функцию. 

Но, по существу, help50 программа, которая сотрудники CS50 в писал, что позволяет запускать команда или запустить программу, и если вы не понимаете его выход, чтобы передать свой выход help50, и в этот момент программное обеспечение что сотрудники конечно писал будет выглядеть на выходе вашей программы строка за строкой, по одному символу. И если мы, сотрудники, признают сообщение об ошибке, что вы испытываете, мы будем стараться, чтобы спровоцировать вас с некоторыми риторические вопросы, с некоторыми советами, так же, как TF или CA или себя будет делать лично в рабочее время. 

Так что смотрите, чтобы help50, если вы этого не сделаете обязательно признают проблему. Но не полагаться на него слишком много, как костыль. Конечно, попытаться понять его вывода, а затем извлечь из него так что только один или два раза не так ли когда-либо запустить help50 для конкретной ошибки сообщение. После этого, вы должны быть лучше оснащены себя чтобы выяснить, что это на самом деле. 

Давайте сделаем один другой здесь. Позвольте мне идти вперед, а в другом файл, который мы будем называть этот buggy1.c. И в этом файле я собирается deliberately-- но делать вид, что я не делаю понять, что ошибка, которую я сделал. 

Я собираюсь идти вперед и делать this-- #include, так как я узнал, что мой урок из минуту назад. Int основных (недействительными), как и раньше. И тогда здесь я иду сделать строку с - get_string. И помните из последнего времени, это означает, эй, компьютер, дайте мне переменную, называем это S, и сделать тип этой переменной строковым так что я могу хранить одно или несколько слов в нем. 

А потом на правой руке сторона знака равенства является get_string, которая является функция в библиотеке CS50 что делает именно это. Он получает функцию, а затем руки его справа налево. Так что этот знак равенства не означает, "Равно", как мы могли бы думать в математике. Это означает назначение справа налево. Таким образом, это означает, взять строку из пользователь и хранить его внутри с. 

Теперь давайте использовать его. Позвольте мне идти вперед сейчас и в качестве второго линия, позвольте мне идти вперед и сказать "привет" - не "мир", но "Привет,% S-- которая является нашим заполнителем, запятая s, которая является нашей переменной, а затем точка с запятой. Так что, если я не завинчивать слишком много здесь, это выглядит как правильный код. 

И мои инстинкты теперь скомпилировать его. Файл называется buggy1.c. Так что я собираюсь сделать сделать buggy1, Enter. И штопать-то, если нет даже больше ошибок, чем раньше. Я имею в виду, есть больше Сообщения об ошибках это было кажется, чем фактические линии в этой программе. 

Но еда на дом здесь, даже если вы перегружены с двумя или тремя или еще четыре сообщения об ошибках, фокус всегда на очень Первый из этих сообщений. Глядя на самый верхний один, прокрутки обратно вверх, как это будет необходимо. Так вот я напечатал косметику buggy1. Вот что выход Clang, как и ожидалось. 

И вот первая красная ошибка. Использование необъявленной идентификатора Строка, я имею в виду стандарт в? Так стандарт является на самом деле что-то другое. Это относится к пользователя клавиатура, по существу. 

Но это не то, что я имел в виду. Я имел в виду строку, и я имел в виду get_string. Так что же это, что я забыл сделать на этот раз? Чего не хватает на этот раз? У меня есть #include, поэтому у меня есть доступ к Printf. 

Но что у меня нет доступ к только что еще? Ну, так же, как в прошлый раз, Я должен сказать компилятор Лязгом, что эти функции. Get_string не приходит с С. И в частности, его не приходит в заголовка файла. Вместо этого он приходит в что-то сотрудники писали, который представляет собой другой файл имя, но метко назвал. 

Так, просто добавив, что одной линии из code-- отзыва от последнего времени что при запуске Clang, это будет посмотреть на мой код сверху вниз, слева направо. Это будет заметить, Ах, вы хотите. Позвольте мне пойти и найти, что, везде, где он находится на сервере, скопировать и вставить его, по существу, в верхней части вашего собственного файла так что в этот момент в истории, линия 1, остальная часть программы может, в самом деле, можно использовать любой из функций в нем, среди них get_string. Так что я собираюсь игнорировать остальные из этих ошибок, потому что я, в самом деле, подозреваю, что только первый на самом деле имело значение. И я собираюсь идти вперед и перекладка, после сохранения моего файла сделать buggy1. И вуаля, он сделал работу. А если я ./buggy1 и введите, для экземпляр, Zamyla, я теперь получить привет, Zamyla, а не привет, мир. 

Отлично. Так вот тогда вынос должны, один, старайтесь подбирать столько, сколько вы можете от сообщений об ошибках в одиночку, глядя на некоторых из распознаваемых слов. Если исключить, что использовать help50 за проблема установить спецификации. Но за исключением этого тоже, всегда обращайте внимание только в верхней ошибки, по крайней мере, на начальном этапе, чтобы увидеть, какую информацию он может на самом деле выход. Но оказывается, что есть даже больше функциональных возможностей встроенной в библиотеку CS50, чтобы помочь вы на раннем этапе в семестр и на ранней стадии в программировании выяснить, что происходит не так. Так давайте сделаем еще один пример. Я буду называть это buggy2, который, опять же, будет испорчен из ворот, по дизайну. 

И я собираюсь идти вперед и делать #include. А потом я собираюсь сделать Int основной (вакуум). А потом я собираюсь сделать цикл. Для (INT I _ 0. Я меньше или равно 10. я ++, а затем в фигурные скобки, я иду распечатать только символ хэштегом здесь и символ новой строки. 

Таким образом, мое намерение с этим Программа достаточно просто итерацию в 10 раз и на каждой итерации из этого цикла каждый раз через цикл, распечатать хэштегом, хэштегом, хэштегом. По одному в строке, потому что я имеют новую линию там. И напомним, что для петля, за последний week-- и вы получите больше знакомый с синтаксисом используя его с практикой Перед long-- это дает мне переменная называется I и устанавливает его в 0. 

Это увеличивает I на каждой итерации на 1. Так что я идет к 1 до 2 до 3. И тогда это условие в посередине между точками с запятой получает проверяется на каждой итерации, чтобы сделать уверен, что мы все еще в пределах диапазона. Так что я хочу итерацию в 10 раз, так что я имеют вид очень интуитивно просто положить 10, как моя верхняя граница там. 

И все же, когда я запускаю это, после того, как компиляции с указанием марки buggy2-- и она компилируется ОК. Так что я не имеют ошибка синтаксиса в этот раз. Позвольте мне идти вперед прямо сейчас и запустить buggy2, Enter. А теперь выполните прокрутку вверх. И позвольте мне увеличить размер окна. 

Я, кажется, есть 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Так что 11 хештегов, несмотря на то, Я четко поставил 10 внутри этого цикла. Теперь, некоторые из вас могут увидеть сразу что ошибка происходит потому, что, в самом деле, это это не очень трудно ошибка сделать. Но это очень часто сделал очень рано. 

То, что я хочу отметить, однако, в том, как я мог бы понять это? Что ж, получается, что CS50 библиотека приходит с не только get_string и get_int и get_float и другие функции. Он также поставляется со специальной функцией называется eprintf, или, ошибка Printf. И существует только сделать это немного проще для вас при отладке кода просто выводит сообщение об ошибке на экране и знаю, откуда она взялась. 

Так, например, одна вещь, которую я мог бы здесь делать с этой функцией является this-- eprintf, а затем я собираюсь идти вперед и сказать, что я теперь% я, обратный слэш, п. И я собираюсь подключить к значению I. И наверху, потому что этот находится в библиотеке CS50, Я собираюсь идти вперед и включают в себя поэтому у меня есть доступ к этой функции. Но давайте рассмотрим, что линия 9 предполагается делать. Я собираюсь удалить это в конце концов. Это не имеет ничего общего с моей главной цели. Но eprintf, ошибка Printf, просто означает, чтобы дать мне некоторую диагностическую информацию. Когда я запускаю мою программу, я хочу увидеть это на экране временно а просто понять, что происходит. 

И в самом деле, на каждом итерация здесь линии 9 Я хочу видеть, какова величина I? Что такое значение I? Что такое значение I? И, надеюсь, я должен только видеть, что сообщение, кроме того, в 10 раз. 

Итак, позвольте мне идти вперед и перекомпилировать мою программу, как я должен делать в любое время Я внести изменения. ./buggy2. И now-- OK. Там очень много больше происходит. Итак, позвольте мне пролистать вверх еще большее окно. 

И вы увидите, что каждый из Hashtags по-прежнему печати. Но между каждым из них в настоящее время этот диагностический вывод отформатирован следующим образом. Название моей программы здесь является buggy2. Имя файла buggy2.c. Номер строки, из которой это было напечатано в строке 9. А потом справа, что является сообщение об ошибке, что я ожидал. 

И что приятно об этом заключается в том, что Теперь я не должен обязательно рассчитывать в моей голове, что моя программа делает. Я вижу, что на Первая итерация я = 0, затем 1, затем 2, затем 3, затем 4, затем 5, затем 6, затем 7, затем 8, то 9, то, 10. Так, подождите минуту. Что тут происходит? Я до сих пор, кажется, считая как задумано до 10. 

Но где же мне начать? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Таким образом, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11-й палец свидетельствует о проблеме. Я, кажется, подсчитали неправильно в моем цикле. Вместо того, чтобы идти 10 итераций, Я начиная с 0, Я и заканчивая через 10. Но, так как, как компьютер, Я начинаю отсчет с 0, Я должен быть подсчитывая до, но не до конца, 10. 

И поэтому исправление, я в конце концов здесь реализуется, является одной из двух вещей. Я мог бы очень просто сказать, сосчитать до менее 10. Таким образом, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, которая является, по сути, верно, несмотря на то, что это звучит немного неправильно. Или я мог бы сделать меньше или равно до 9, до тех пор, как я начинаю с 0. Или, если вы действительно не нравится, что ты может рассчитывать через 10, но начинаются с 1. Но опять же, это просто не так часто. В programming-- хотя и не столько в Scratch-- но при программировании в C и других языках, как JavaScript и Python и другие, это просто очень часто для наше обсуждение бинарная чтобы просто начать отсчет на наименьшее число вы можете, что 0. Отлично. Так вот eprintf. И опять же, теперь, когда я понял, что я Проблема, и я собираюсь вернуться к 0 через менее чем 10, я собираюсь пойти и удалить eprintf. 

Оно не должно быть там, когда я отправить мой код или отправить свой код или показать его кому-либо еще. Это действительно просто имел в виду которые будут использоваться временно. Но теперь я это исправил Особой проблемой, а также. 

Что ж, давайте сделаем еще один пример здесь что я буду нагнетать следующим образом. Я собираюсь идти вперед и #включают . $ 50 И я собираюсь идти вперед и #include. 

И я собираюсь сохранить этот файл в качестве buggy3.c. И я собираюсь идти вперед и объявить Int основной (вакуум). А потом внутри там Я собираюсь сделать INT I _ - Я хочу, чтобы реализовать программу с get_negative_int. Это не функция, которая существует до сих пор. Итак, мы собираемся реализовать это всего мгновение. Но мы будем видеть, почему он ошибочен на первом проходе. И как только я получил вызовите прерывание от пользователя, Я просто хочу, чтобы напечатать% I является отрицательным целым числом, обратной косой черты, п, запятая, я. Другими словами, все, что я хочу эту программу, чтобы сделать это получить отрицательное Int из пользователь, а затем распечатать что такой негативный Int. 

Теперь мне нужно реализовать эту функцию. Так что позже в моем файле, я собираюсь пойти вперед и объявить функцию под названием get_negative_int (пустота) - и мы вернуться к тому, что означает, что линия снова в moment-- Int N; do-- делать following-- Printf п :. А потом я собираюсь сделать п - get_int, и сделать это в то время как п больше 0. А потом вернуться п ;. 

Так что есть много происходит в не это, но ни один из которых мы не делали посмотрите на последнюю неделю, по крайней мере, на короткое время. Так что в строке 10 здесь я объявлен Функция называется get_negative_int, и я поставил (пустота), в круглые скобки, по той причине, это не принимает входной сигнал. Я ничего не пропуская к этой функции. Я просто получаю что-то от него. 

А что я надеюсь получить обратно целое. Там нет тип данных C называется negative_int. Это просто Int, так что это будет чтобы быть на нас, чтобы убедиться, что значение, которое на самом деле Возвращается не только INT но также отрицательно. 

В строке 12 я объявляю переменную называется п и делает его типа Int. А затем в строке 13 до 18 Я делать что-то в то время как-то верно. Я иду вперед и печать п, двоеточие, а затем пробел, как подсказку для пользователя. 

Я затем вызвать get_int и хранить его так называемое возвращаемое значение в этой переменной п. Но я буду продолжать делать это в то время как п больше 0. Другими словами, если пользователь дает мне Int и это число больше 0, эрго, положительный, я собираюсь просто держать reprompting пользователя, держать reprompting, заставляя их сотрудничать и дайте мне отрицательный результат Int. 

И как только п на самом деле negative-- Предположим, что пользователь наконец типа -50, то это не в то время как цикл уже не так потому что -50 не больше 0. Таким образом, мы нарушаем из этого петля логически и вернуться п. 

Но есть еще одна что я должен делать. И я могу просто сделать это путем копирования и вставки одна строка кода в верхней части файла. Мне нужно, чтобы научить Clang, или обещание лязгом, явно, что я буду, на самом деле, пойти и осуществить эта функция get_negative_int. Это может быть просто ниже в файле. Опять же, напомним, что Clang читает вещи сверху вниз, слева направо, так что вы не можете вызвать функцию, если Clang не знает, что это будет существовать. 

Теперь, к сожалению, эта программа, так как некоторые из вас могли заметить, уже глючит. Позвольте мне идти вперед и сделать buggy3. Он собирает, так что моя проблема сейчас не ошибка синтаксиса, как текстовой ошибки, это на самом деле будет логическим ошибка, что я намеренно сделал как возможность пошагово, что происходит. 

Я собираюсь идти вперед Теперь и запустить buggy3. И я собираюсь пойти вперед, а не сотрудничать. Я собираюсь дать ему номер 1. Это не понравилось, так это меня снова пробуждая. 

Как насчет 2? 3? 50? Ни один из них не работают. Как насчет -50? И программа, кажется, работает. 

Позвольте мне попробовать еще раз. Позвольте мне попробовать -1, кажется, работает. Позвольте мне попробовать -2, кажется, работает. Позвольте мне попробовать 0. Да, это неверно. Теперь мы, будучи немного педантичным здесь. Но это, на самом деле, так что 0 не является ни положительным, ни отрицательным. И поэтому тот факт, что моя программа говоря, что 0 является отрицательным целым числом, это не технически правильно. 

Теперь, почему он это делает? Ну, это может быть очевидным. И, действительно, программа имел в виду, чтобы быть достаточно простым поэтому у нас есть что-то, чтобы исследовать. 

Но давайте введем третью отладку Техника здесь называется debug50. Так что это программа что мы только что создали В этом году под названием debug50 что позволит вам использовать то, что называется встроенным графический отладчик в CS50 IDE. И отладчик просто программа, которая как правило, позволяет запускать программу но шаг за шагом за шагом, линии по линии по линии, делая паузу, тыкая вокруг, глядя на переменные, так что программа не просто удар мимо вас и быстро напечатать что-нибудь или не напечатать что-нибудь. Это дает возможность, в человеческая скорость, чтобы взаимодействовать с ним. 

И сделать это, вы просто сделайте следующее. После компиляции кода, которые я уже сделал, buggy3, вы идете вперед и запустить debug50 ./buggy. Так же, как help50 имеет запуска help50, а затем команда, debug50 имеет запустить debug50 и то имя команды. 

Теперь посмотрим, что происходит на моем экране, на правой стороне, в частности. Когда я ударил Выполнить, все внезапная панель эта правая открывает на экране. И есть много чего происходит на на первый взгляд. Но есть не слишком много причин для беспокойства пока нет. 

Это показывает мне все что происходит внутри моей программы прямо сейчас, и через них Кнопки вверх верхней затем что позволило мне пройти через мой код в конечном итоге шаг за шагом за шагом. Но не только пока. Обратите внимание на то, что происходит. В моем окне терминала Я запроса на ввод п. И я собираюсь идти вперед и сотрудничество на этот раз и введите -1. И хотя и немного загадочно, -1 является отрицательным целым числом, как и следовало ожидать. 

И тогда ребенок вышел с Статус 0 GDBserver выхода. GDB, GNU Debugger, это имя лежащего в основе программного обеспечения который реализует этот отладчик. Но все это на самом деле означает, отладчик ушел, потому что моя программа бросить курить и все было хорошо. Если я хочу, чтобы действительно отлаживать программу, Я должен сказать, превентивно debug50, где я хочу, чтобы начать пошагового мой код? 

И, пожалуй, самый простой способ сделать это следующим образом. Если я парить над Желоб моего редактора здесь, так на самом деле просто в боковой панели здесь, слева от номера строки, Обратите внимание, что, если я просто нажмите один раз, я ставлю маленькую красную точку. И эта маленькая красная точка, как знак остановки, значит, эй, debug50, выполнение паузы моего кода прямо там, когда я запустить эту программу. 

Так давайте сделаем это. Позвольте мне идти вперед и запустить мою программу снова с debug50 ./buggy3, Enter. А теперь, обратите внимание, что-то иначе произошло. Я не запрос все же в моем окне терминала ни за что, потому что у меня нет получил там еще в моей программе. Обратите внимание на то, что в строке 8 который в настоящее время выделен, и есть маленькая стрелка левая изречение, ты остановился здесь. Эта строка кода, строки 8, до сих пор не выполнено. 

И что любопытно, если я смотрю здесь на правой стороне, обратите внимание, что я является локальным переменная, локальная в том смысле, что она внутри текущей функции. И его значение, по-видимому, по умолчанию, и вроде удобно, равно 0. Но я не тип 0. Это как раз случается быть его Значение по умолчанию в данный момент. 

Итак, позвольте мне идти вперед и делать это сейчас. Позвольте мне идти вперед и на в правом верхнем углу здесь, я идти вперед и нажмите эту первую иконку, которая означает шаг, над которым означает не пропустить это, но перешагнуть эту строку кода, выполняя его по пути. 

А теперь обратите внимание, что я быстрое только что изменил. Почему это? Я сказал debug50, запустить эту строку кода. Что делает эта строка кода делать? Запрашивает меня на междунар. ОК. Позвольте мне сотрудничать. Позвольте мне идти вперед сейчас и введите -1, Enter. А теперь обратите внимание, что изменилось. С правой стороны, моя локальная переменная я обозначается как -1 в настоящее время. И это все-таки типа Int. 

И заметьте, тоже, мой так называемый стек вызовов, где же я паузу? Мы будем говорить больше о это в будущем. Но стек вызовов просто ссылается на то, что функции в настоящее время в движении. Сейчас это просто главный. И сейчас единственный местный переменная I со значением 1. 

И когда я, наконец, шаг по этой линии здесь, с той же значок в правом верхнем углу, -1 Является отрицательным целым числом. Теперь он задержавшись над этим фигурной скобкой. Давайте пусть это делают свое дело. Я перешагнуть эту строку, и вуаля. 

Так что не все, что ужасно поучительно все же, но это позвольте мне сделать паузу и думаю, что через логически что эта программа делает. Но это не было ошибочным случаем. Давайте сделаем это снова следующим образом. 

Я собираюсь оставить эту точку останова в строке 8 с красной точкой. Я собираюсь повторно запустить debug50. Это автоматически приостанавливается здесь. Но на этот раз, вместо того, переступая через эту линию, позвольте мне на самом деле идти внутри get_negative_int и выяснить, почему это принятие 0 в качестве действительного ответа? 

Таким образом, вместо того, чтобы нажать Step Over. Я собираюсь идти вперед и нажмите кнопку Step Into. И обратите внимание, что линия 8 это теперь выделяется теперь вдруг становится строка 17. 

Теперь, это не значит, что отладчик пропустил линии 14 и 15, и 16. Это не просто там ничего чтобы показать вам там. Те объявления переменных, а затем там слово Do а затем открытая фигурная скобка. Только функциональная линия, это сочный действительно этот здесь, 17. И вот где мы автоматически приостанавливается. 

Так что Е ( "n.is:") ;, так что до сих пор не произошло. Так что давайте идти вперед и нажмите кнопку Step Over. Теперь мой запрос, на самом деле, изменен ( "п:"). Теперь get_int, я не собираюсь беспокоить вступаем, потому что функция была сделанные CS50 в библиотеке. Это, вероятно, правильно. 

Так что я собираюсь идти вперед и своего рода сотрудничество, придав ему вызовите прерывание, но не является отрицательным Int. Итак, позвольте мне идти вперед и ударил 0. А теперь, что происходит здесь когда я получаю вниз к линии 21? Я не итерироваться снова. Я, кажется, не застрянет в этом цикле. Другими словами, этот желтый бар не будет держать вокруг, и вокруг, и вокруг него. 

Теперь, почему это? Что ж, п, что равно п прямо сейчас? Я могу смотреть на местном Переменные в отладчике. п равно 0. Хорошо, что это было мое состояние? 

20-- линия 20, ну, 0 больше 0. Это неправда. 0 не больше 0. И поэтому я вырвалась из этого. 

И вот почему на линии 21, если я на самом деле по-прежнему, Я собираюсь вернуть 0, даже хотя я должен был отвергнуто 0 а на самом деле не является отрицательным. Так что теперь, я не очень даже заботиться о отладчика. Понял, я не нужно знаю, что еще происходит. 

Так что я собираюсь идти вперед и просто нажмите кнопку воспроизведения, и пусть это закончить. Теперь я понял, что мой ошибка по-видимому, в строке 20. Это моя логическая ошибка. 

И вот, что я хочу нужно сделать, чтобы изменить это? Если проблема заключается в том, что я не ловить 0, это просто логическая ошибка. И я могу сказать, в то время как п больше или равно 0, держать снова и снова запрашивая пользователя. 

Так что, опять же, простая ошибка, возможно, даже очевидно, когда вы видели меня написать это всего несколько минут назад. Но здесь вынос является то, что при отладке 50, и с отладкой программное обеспечение в более общем плане, у вас есть это новое питание пройти через свой собственный код, смотрите с помощью этой правой панели, что переменные значения. Таким образом, вы не обязательно должны использовать что-то как вы eprintf печатать эти значения. Вы можете увидеть их визуально на экране. 

Теперь, помимо этого, стоит отметить, что есть другая техника, которая на самом деле очень распространенным явлением. И вы могли бы задаться вопросом, почему этот маленький парень здесь сидел на сцене. Так что есть эта техника, как правило, известный как метод утёнка, который на самом деле это просто свидетельством того, что часто, когда программисты написании кода, они не обязательно сотрудничая с другими, или работать в общей среде. 

Они вроде дома. Может быть, это поздно ночью. Они пытаются фигуры некоторые ошибки в своем коде. И они просто не видит. 

И нет никакого соседа по комнате. Там нет TF. Там нет CA вокруг. Все они имеют на своей полке эта маленькая резиновая уточка. 

И поэтому отладка резиновая утка просто это приглашение думать о чем-то, как глупо так как это как реальное существо, и на самом деле пройти через ваш код в устной форме к этому неодушевленный объект. Так, например, если это мой пример here-- и напомним, что ранее проблема была в этом, если я удалю эту первую строку кода, и я иду вперед и сделать багги 0 раз, Напомним, что у меня были эти Сообщения об ошибках здесь. Так что идея здесь, смешно, хотя я чувствую в данный момент делает это публично, является то, что ошибка. 

ОК, так что моя проблема в том, что я неявно библиотечную функцию. И эта функция библиотеки Printf. Declare-- OK, объявить напоминает мне о прототипах. 

Это означает, что мне нужно на самом деле сообщить компилятору заранее, что функция выглядит следующим образом. Подожди минуту. У меня не было стандартного io.h. Большое спасибо. 

Так что этот процесс of-- вас не нужно на самом деле есть утка. Но эта идея ходить самостоятельно через свой собственный код так что вы даже слышать самостоятельно, так что вы реализовать упущения в свой собственный замечания, как правило, идея. 

И, возможно, более логично, не так много с этим один, но более активное участие Пример, который мы только что сделали в багги 3.c, Вы могли бы ходить себя через него следующим образом. Так что все в порядке, резина душка, DDB, если вы будете. Здесь мы имеем в своей основной функции, Я звоню получить отрицательный результат Int. 

И я получаю возвращаемое значение. Я хранить его на левой стороне в строке 8 в переменной называется I. Хорошо, но ждать, как сделал что получить это значение? Позвольте мне взглянуть на функции в строке 12. 

В строке 12 мы имеем получить отрицательную Int. Не принимать какие-либо материалы, это возвращает Int, OK. Я заявляю, в строке 14 переменная п. Это будет хранить целое число. Это то, что я хочу. 

Так сделайте следующее: Когда п is-- пусть мне отменить то, что исправление я уже сделал. Таким образом, в то время как п больше 0, распечатать п, OK. А затем вызовите получить INT хранится в п. А затем проверьте, если п = 0, п не-- там. Так что, опять же, вы этого не сделаете нужен фактический утка. Но просто ходить самостоятельно через ваш код как интеллектуальное упражнение часто поможет вам осознать, что происходит, а не просто делать что-то как это, глядя на экран, и не говорить себя через то, что это не честно почти как эффективный метод. Так что у вас есть, A количество различных методов для фактически отладки кода и придираться, все из которых должны быть инструменты в ваш инструментарий так что вы не поздно ночью, особенно, вы в столовой залы, или в нерабочее время, бьешься головой против стены, пытаясь решить некоторые проблемы. Понимают, что есть программные средства. Есть резиновая утка инструменты. И есть целый штат поддержки ждут, чтобы протянуть руку помощи. 

Так что теперь, слово по проблеме наборы, а также на то, что мы надеемся, что вам выйти из них, и как мы идем об оценке. За учебный план Курса, CS50 множества проблем в оцениваются по четырем основным осям, так чтобы speak-- сферу, корректность, дизайн, и стиль. И сфера просто относится к тому, сколько куска вы откусили? Сколько проблемы вы пробовали? Какой уровень усилий Вы выражалось? 

Корректность, работает программа, как он должен согласно спецификации CS50 когда вы предоставляете определенные входы или определенные выходы возвращаются? Дизайн является наиболее субъективным из них. И это тот, который будет взять самый длинный, чтобы узнать, и самый длинный, чтобы преподавать в до сих пор, как это сводится к тому, как хорошо написано ваш код? 

Это одна вещь, чтобы просто напечатать правильный выходы или возвращать правильные значения. Но вы делаете это как эффективно, насколько это возможно? Вы делаете это разрыв и властвуй, или двоичный Поиск, как мы скоро увидим, что мы сделали две недели назад с телефонной книгой? Существуют ли более эффективные способы решения проблема, чем сейчас у вас здесь? Это возможность для лучшего дизайна. 

А потом, как style-- довольно ваш код? Вы заметите, что я довольно частности о отступов мой код, и убедившись, что мои переменные обоснованно названы. п, в то время как короткие, хорошее имя для номер, я для подсчета числа, s для строки. И мы можем иметь больше имена переменных стиля. Стиль, насколько хорошо выглядит ваш код? А как читаемый это? 

И с течением времени, чем ваши TAs и ТФ будет делать в процессе это предоставить вам, что вид качественной обратной связи так что вы получите лучше в этих различных аспектах. И с точки зрения того, как мы оценить каждую из этих осей, это, как правило, с очень немногими ведра, так что вы, как правило, получить представление о том, насколько хорошо вы делаете. И действительно, если вы получите счет на любой из этих axes-- правильность, дизайн и стиль especially--, что число как правило, составляет от 1 до 5 баллов. И, в буквальном смысле, если вы получаете 3-х в начале семестра, Это очень хорошая вещь. Это означает, что есть еще возможности для совершенствования, который вы бы надеяться в принимая класс в первый раз. Там в какой-то, надеюсь, немного потолка к которому вы стремящихся к достижению. И поэтому получение 3 по самые ранние пьесы, если не какой-то 2-х и 4-х, это, действительно, очень хорошая вещь. Это хорошо в пределах диапазона, хорошо в пределах ожиданий. 

И если ваш ум мчится, подождите минуту, три из пяти. Это действительно 6 из 10. Это 60%. Боже мой, это на букву F. 

Это не. Это не так, на самом деле, это. Скорее всего, это возможность улучшить в течение семестра. И если вы получаете некоторые Poors, это возможность чтобы воспользоваться офисными часами, конечно же разделы и другие ресурсы. 

Лучше это возможность, на самом деле, можно гордиться, насколько далеко вы приходят в течение семестра. Так же понимаешь, если ничего еще три хорошо. И это позволяет для роста с течением времени. 

Что касается того, как эти оси взвешенное, реально вы собирается потратить большую часть своего времени получения вещи, чтобы работать, не говоря уже правильно. И поэтому, как правило, корректность взвешиваться больше всего, как и с этот мультипликативный фактор трех. Дизайн также имеет важное значение, но то, что вы не обязательно тратить все те часы, на пытаясь получить вещи просто работать. 

И таким образом это взвешенный чуть более слегка. А потом стиль взвешивается по меньшей мере. Несмотря на то, что это не менее важно фундаментально, это просто, может быть, Проще всего сделать правильно, имитируя примеры, которые мы делать в лекции и секции, с вещами красиво отступом, и прокомментировал, и так далее является одним из самых простых вещи, чтобы сделать и получить право. Так как таковые, реализовать что те точки что относительно легко понять. 

А теперь слово на this-- академической честности. Таким образом, за Курса учебный план, вы увидите что курс имеет довольно немного языка вокруг этого. И конечно же берет вопрос академическая честность вполне серьезно. 

У нас есть различия, лучше или хуже, из прислав каждый год более студентов для принятия дисциплинарных мер чем большинство любой другой Конечно же, что я знаю. Это не обязательно свидетельствует о том, что студенты CS или CS50 студентов, являются менее честнее своих одноклассников. Но реальность, что в этом мир, в электронном виде, мы просто есть технологическая средство обнаружения этого. 

Это очень важно для нас для справедливость по классу что мы делаем это обнаружить и поднять вопрос, когда мы видим вещи. И как раз, чтобы нарисовать картину, а на самом деле чтобы помочь что-то вроде этого в раковине, это число Студенты в течение последних 10 лет которые были вовлечены в некоторые такие вопросы академической честности, с некоторыми 32 студентов с осени 2015 года, которая должен сказать, что мы принимаем дело очень серьезно. И, в конечном счете, эти цифры составляют, Совсем недавно, около 3%, 4% или около того класса. 

Так что для супер большинства студентов кажется, что линии четкие. Но имейте это в ум, особенно поздно в ночное время, когда борется с какое-то решение для множества проблем, что существуют механизмы для получения себя лучше поддержка, чем вы могли бы думаю, даже в тот час. Понимают, что, когда мы получаем студенческие представления, мы пересекаем сравнить все представления в этом году против каждого представления в прошлом году, против каждого представления с 2007 года, и так как, глядя на, а также, код репозиториев онлайн, дискуссионных форумах, работа сайтов. И мы отметим это, на самом деле, все ради полного раскрытия, что если кто-то может найти его в Интернете, конечно же, так что мы можем курс. Но, на самом деле, дух из курса сводится к этой статье в учебной программе. Это действительно просто, разумно. 

И если мы должны были остановиться на этом с только немного больше языка, осознать, что суть всех Работа, которую вы представить этот курс должен быть свой собственный. Но в том, что есть, конечно, возможностей и поощрение, и педагогическая ценность в превращении в others-- себя, ССТ, КАС, Тас и другие в классе, для поддержки, не говоря уже о друзей и соседи по комнате, кто изучал CS и программирование раньше. И поэтому есть пособие для этого. А общее правило является this--, когда просят о помощи, Вы можете показать свой код другим, но вы не можете просматривать их. Так что даже если вы в рабочее время, или в зале D, или где-нибудь еще работает над какой-то кусок набора, работая вместе с другом, который это совершенно нормально, на Конец дня вашей работы в конечном итоге должно принадлежать каждому из вас, соответственно, и не быть некоторые совместные усилия, для окончательного проекта, где кроме это разрешается и поощряется. 

Поймите, что если вы борется с чем-то и ваш друг только что происходит чтобы быть лучше в этом, то вы, или лучше на эту проблему, чем вы, или чуть дальше вперед, чем вы, это совершенно разумно, чтобы превратить своему другу и сказать, эй, Вы не возражаете, глядя на мой код здесь, чтобы помочь мне определить, что мой вопрос? И, надеюсь, в Интерес педагогической ценности что друг не просто говорят, ах, сделать это, но, скорее, то, что вы пропали без вести на линии 6, или что-то подобное? Но это решение не для друга рядом с вами сказать, ой, ну, вот, позвольте мне тянуть это, и показать мое решение для вас. Так что это линия. Вы показываете свой код в другие, но вы не можете посмотреть у них, в соответствии с другими ограничения в учебный план Курса. 

Так что имейте в виду, что это так называемый пункт сожаления в ходе учебного плана, а также, что если вы совершите какой-то акт, не является разумным, но довести его до внимание руководителей Курса в течение 72 часов, курс может налагать санкции, местные может включать в себя неудовлетворительным или провальную оценку для работы, представленные. Но, конечно, не передаст важно для дальнейшего принятия дисциплинарных мер, за исключением случаев повторных актов. Другими словами, если вы делаете некоторые глупо, особенно поздно вечером, решение что на следующее утро или через два дня позже, вы пробудиться и осознать, о чем я только думал? Вы делаете в CS50 имеют выход для фиксации этой проблемы и владеть до него, так что мы встретит вас на полпути и дело с ним в вопросе, который является одновременно образовательных и ценным для вас, но до сих пор карательный в некотором роде. И теперь, чтобы заморить, это. 

[ПРОИГРЫВАНИЕ ВИДЕО] 

[МУЗЫКА] 

[КОНЕЦ ВОСП] DAVID J. Малан: Хорошо, мы вернулись. А теперь мы посмотрим на один из первый из наших реальных доменов в CS50, искусство криптографии, искусство отправки и получения секретные сообщения, зашифрованного сообщения, если вы будете, которые могут быть расшифрованы только если у вас есть некоторые из ключевых элементов, что отправитель также. Таким образом, чтобы мотивировать этого мы возьмем Посмотрите на эту вещь здесь, которая является Примердлительногопребывания секрет декодер кольцо, может быть использован для того, чтобы выяснить, то, что секретное сообщение на самом деле. На самом деле, еще в день в начальной школе, если вы когда-нибудь послал секретные сообщения некоторые друг или некоторые давка в классе, Вы могли бы подумать, вы были умными путем на вашей части замены бумаги, как, А к В, и В к С, В и С к D, и так далее. Но вы были на самом деле шифрования Ваша информация, даже если это было немного тривиально, не было что трудно для учителя, чтобы понять, хорошо, если вы просто изменить В к А и С к В, вы на самом деле выяснить, что было сообщение, но вы были в шифровании информации. 

Вы просто делали это просто, так же, как Ральфи здесь в известном фильме, который играет довольно много объявлений каждую зиму до тошноты. [ПРОИГРЫВАНИЕ ВИДЕО] -Будьте Это всем известно, что Ральф Паркер Настоящим назначен членом Маленькой Сиротка Энни Secret Circle и имеет право на все почести и выгоды происходит с ним. 

-Signed, Сиротка Энни, встречное подписал Пьер Андре, в чернилах. Почести и выгоды, уже в возрасте девяти лет. 

[Крича] -Давай. Давайте покончим с этим. Мне не нужно все, что джаз о контрабандистов и пиратов. 

-Слушай Завтра ночь завершающим приключения черного пиратского корабля. Теперь пришло время для секретное сообщение Энни для вас члены тайного кружка. Помните, дети, только члены Энни Секретной Circle может расшифровать секретное сообщение Энни. 

Помните, что Энни зависит от вас. Установите штифты B2. Вот сообщение. 12, 11-- 

-Я Нахожусь в, свою первую секретную встречу. 

-14, 11, 18, 16. 

-Pierre Был громкий голос сегодня. Я мог бы сказать, что сегодня вечером сообщение было действительно важно. 

-3, 25, это сообщение от самой Энни. Помните, что не говори никому. 

-90 Секунд спустя, я нахожусь в единственной комната в доме, где девятилетний мальчик мог сидеть в уединении и декодированием. Ага, B! Я пошел к следующему, Е. 

Первое слово будет. S, он шел легче сейчас, U, 25-- 

-О, Давай, Ральфи, я должен идти! 

-Я Сейчас спущусь, Ма! Вот здорово! 

-Т, O, обязательно убедитесь, что, целью которых к чему? Что сиротка Энни пытается сказать? Убедитесь, что к чему? 

-Ralphie, Энди попал идти, то, пожалуйста, выйти? 

-Хорошо, Мама! Я буду прямо! 

-Я Становился ближе. Напряжение было ужасно. Что это было? Судьба планеты может висеть на волоске. 

-Ralphie! Энди должен идти! 

-Я Сейчас выйду, для взывают громко! 

-почти Там, мои пальцы летали, мой разум была стальная ловушка, каждая пора вибрировать. Это было почти ясно, да, да, да. 

-Будьте Обязательно пить Ovaltine. Ovaltine? Вшивого коммерческий? Сукин сын. [КОНЕЦ ВОСП] DAVID J. Малан: ОК, так что это был очень долгий путь введения криптографию, а также Ovaltine. На самом деле, от этого старого объявлений здесь, почему Ovaltine так хорошо? Это концентрированное извлечение спелые ячменный солод, чистое сливочное из коровьего молока, и специально подготовленные какао вместе с природными фосфатидов и витаминов. Далее обогащенные дополнительные витамины группы В и D, ням. И вы все еще можете получить его, по-видимому, на Амазонке, как мы делали здесь. 

Но мотивация здесь была ввести криптографию, в частности, тип криптографии известен в качестве секретного ключа шифрования. И, как следует из названия, весь безопасность секретного ключа системы криптографической, если вы будете, методология для скремблирования просто информация между двумя людьми, в том, что только отправитель и получатель только знать секрет key-- какую-то ценность, некоторые условную фразу, какой-то секрет число, что позволяет им как зашифровать и расшифровать информацию. И криптография, на самом деле, как раз это от недели 0. 

Это проблема, где есть входы, как реальное сообщение на английском языке или любой другой язык, который вы хотите послать кому-то в классе, или через Интернет. Существует некоторый выход, который собирается чтобы быть скремблированный сообщение, что вы хочет получатель получить. И даже если кто-то в средний получает его тоже, вы не хотите, чтобы они обязательно быть в состоянии расшифровать его, потому что внутри этого черный ящик, или алгоритм, это какой-то механизм, некоторые шаг за шагом инструкции, для принятия этого входа и превращение его в выход, в надеюсь безопасным способом. 

И в самом деле, есть некоторые словарный запас в этом мире следующим образом. Обычный текст является слово а ученый будет использовать для описания входных сообщение, как на английском или любой другой язык вы на самом деле хотите отправить в какой-то другой человек. И тогда шифротекст является свалка к шифрованных или зашифрованы, его версия. 

Но есть еще один ингредиент здесь. Там один другой вход Секретный ключ шифрования. И это сам ключ, который, как правило, как мы увидим, число или буква или слово, независимо от алгоритм это на самом деле ожидает. 

И как вы расшифровать информацию? Как вы расшифровывать его? Ну, вы просто повернуть вспять выходы и входы. 

Другими словами, как только кто-то получает ваше зашифрованное сообщение, он или она просто имеет чтобы знать, что тот же ключ. Они получили шифротекста. А подключив эти два входы в систему криптографической, алгоритм, это черный ящик, из должен прийти исходный открытый текст. И так что это очень высокий уровень вид, что на самом деле криптография все о. 

Так что давайте там. Давайте теперь посмотрим под капот чего-то мы принимали как само собой разумеющееся для на прошлой неделе, и на этой сессии here-- строку. Строка в конце дня это просто последовательность символов. 

Это может быть привет мир, или привет Zamyla, или любой другой. Но что это значит, что последовательность символов? На самом деле, библиотека CS50 дает нам тип данных называется строкой. 

Но есть на самом деле нет такая вещь как строка в C. Это действительно просто последовательность характер, характер, характер, характер, спина, к спине, чтобы назад, к спине, чтобы внутрь памяти компьютера или ОЗУ. И мы будем смотреть глубже, что в будущее, когда мы смотрим на саму память, и использование, и угрозы, которые участвуют. 

Но давайте рассмотрим строку Zamyla. Так что название человек здесь, Zamyla, то есть последовательность символы, Z-A-M-Y-L-A. А теперь давайте предположим, что имя Zamyla в Во время сохранения внутри компьютера Программа. 

Ну, само собой разумеется, что мы должны быть в состоянии смотреть на этих персонажей в индивидуальном порядке. Так что я просто хочу, чтобы нарисовать немного рамку вокруг имени Zamyla здесь. И это происходит в C, что, когда вы есть строка, как Zamyla-- и, возможно, эта строка вернулась из функция как получения строки, вы можете манипулировать это символ за символом. 

Теперь, это релевантно для Разговор под рукой, потому что в криптографии, если вы хотите изменить А в В, и В к С, В и С к D, и так далее, вы должны быть в состоянии смотреть на отдельные символы в строке. Вы должны быть в состоянии изменить Зет к чему-то еще, А к чему-то еще, чтобы М что-то еще, и так далее. И поэтому нам нужен способ, программным способом, так говорить, в C, чтобы иметь возможность изменить и посмотреть на отдельные буквы. И мы можем сделать это следующим образом. 

Пусти голову назад в CS50 IDE. И позвольте мне идти вперед и создать новый файл что я буду называть этот раз string0, как наш первый такой пример, точка с. И я собираюсь идти вперед и взбить его следующим образом. 

Так включают CS50.h, и затем включают в себя стандартные io.h, который я почти всегда будет использовать в своих программах, по крайней мере, первоначально. INT главную пустоту, а затем здесь я собирается делать строки получает получить строку. А потом я собираюсь идти вперед и делать это. Я хочу, чтобы идти вперед и, в качестве проверки вменяемости, просто сказать, привет, процентов s, запятой, делает строку 0. Ой, что же я сделал здесь? О, я не подключить его. Так урок, что не был преднамеренным. 

Так ошибка, более процентов преобразования, чем аргументы данных. И здесь, в линия 7-- ОК, так что у меня есть, цитата Unquote, это моя строка PRINTF. У меня есть знак процента. Но я пропускаю второй аргумент. 

Я пропускаю запятой с, что Я имею в предыдущих примерах. Так хорошая возможность исправить еще одна ошибка, случайно. А теперь позвольте мне бежать string0, тип в Zamyla. Хорошо, привет Zamyla. 

Таким образом, мы запускаем этот вид программы несколько различных раз сейчас. Но давайте делать что-то немного по-другому в этот раз. Вместо того чтобы просто печать Zamyla-х полное название с Printf, давайте сделаем это символ за символом. 

Я собираюсь использовать для цикла. И я собираюсь отдать себя переменная подсчета, называется I. И я буду держать перебираете, так Пока я меньше, чем длина с. 

Оказывается, мы не сделали сделать это в последний раз, что с поставляется с Функция называется Стирлинга. Назад в день, а в целом до сих пор при осуществлении функций, люди часто выбирают очень емкие имена, своего рода звук как то, что вы хотите, даже если это не хватает нескольких гласных звуков или букв. Так Стирлинга является имя функции, которая принимает аргумент между круглые скобки, которые должны быть строкой. И это как раз возвращает целое число, длина этой строки. 

Так что этот цикл на линии 7 происходит Чтобы начать обратный отсчет на я равна 0. Это будет увеличиваться я на каждой итерации на 1, как мы делали несколько раз. Но это будет только делать это до точки когда я длина из самой строки. 

Так что это путь, в конечном счете, перебирает персонажей в строке А как следует. Я собираюсь распечатать не вся строка, но процент с, один символ а затем новой линии. А потом я собираюсь идти вперед, и мне нужно сказать, что я хочу напечатать Ith характер с. 

Так что, если я это переменная, которая указывает индекс строки, где вы в нем, мне нужно, чтобы иметь возможность говорят, дайте мне ю характер с. И с имеет способ сделать это квадратные скобки. Вы просто говорите от имени строка, которая в данном случае является s. Затем вы используете квадратные скобки, которые являются как правило, чуть выше Return или Enter клавиша на клавиатуре. И тогда вы положили индекс символ, который вы хотите напечатать. Таким образом, индекс будет number-- 0, или 1, или 2, или 3, или точка, точка, точка, некоторое другое число. 

И мы гарантируем, что это будет быть правильный номер, потому что я начать отсчет с 0. И по умолчанию, первый символ в строке является конвенцией 0. И второй персонаж кронштейн 1. И третий персонаж кронштейн 2. И вы не хотите идти слишком далеко, но мы не будем, потому что мы происходит не только приращение I до него равна длине строки. И в этот момент, этот цикл остановится. 

Итак, позвольте мне идти вперед и сохранить этот программа, и запустить сделать строку 0. Но я облажался. Косвенно объявляя функции библиотеки Stirling с типом такой и such-- сейчас, это звучит знакомо. Но это не PRINTF. И это не получить строку. 

Я не ввернуть в так же, как в этот раз. Но обратите внимание, здесь немного вниз кроме того, включать string.h заголовка, явным образом предоставить декларация Стерлинга. Так что на самом деле ключ там. 

И в самом деле оказывается, есть еще один файл заголовка что мы не использовали в классе все же, но это среди тех, доступны к вам, называется string.h. И в этом файле, string.h является Стирлинга объявлена. Итак, позвольте мне идти вперед и сохранить это, сделать строку 0-- приятно, никаких сообщений об ошибках на этот раз. 

./string0 Zamyla, и Я собираюсь нажать кнопку ввода, в какой момент происходит GetString чтобы вернуть строку, поместите ее в с. Тогда, что цикл будет перебирать над символов S один в то время, и печатать их по одному в каждой строке, потому что У меня было, что обратной косой п в конце. Так что я мог бы опустить, что обратный слэш п, а затем просто распечатать все Zamyla в той же строке, эффективно Переопределением Printf, что не все, что полезно. Но в данном случае, я не сделал этого. Я на самом деле распечатываются характер, в то время, по одному в каждой строке, так что мы на самом деле увидеть эффект. 

Но я должен отметить одну вещь здесь. И мы вернемся к это в будущей неделе. Оказывается, что это код потенциально глючный. 

Оказывается, что получить строку и некоторые другие функции в жизни не обязательно всегда вернуть то, что вы ожидали. Мы знаем из класса последнего Время в этом, что получить строка должна возвращать строку. Но что, если пользователь печатает такие длинное слово или абзац, или эссе что там просто не хватает памяти в компьютере, чтобы соответствовать его. 

Как и то, что если что-то идет неправильно под капотом? Это не может произойти часто, но это может произойти один раз в то время, очень редко. И так получается, что получить строку и функции подобные ему не обязательно всегда возвращать строки. Они могут возвращать некоторое значение ошибки, некоторое значение сторожевого так сказать, что указывает на то, что что-то пошло не так. И вы бы знали только это из узнав его в классе сейчас, или прочитав некоторую дополнительную документацию. Оказывается, что получить строку может возвращать значение, называемое нулевым. Нулевой это специальное значение, что мы будем вернуться в будущей недели. Но сейчас, просто знаю, что если я хочу чтобы быть действительно собственно в продвижении вперед с помощью получения строки, я не должны просто назвать его, и слепо использовать возвращаемое значение, полагая, что это строка. 

Я должен сначала сказать, Эй, подождите минуту, только действовать, если s не равно нуль, где нуль, опять же, это просто какое-то особое значение. И это единственное специальное значение, которое вы нужно беспокоиться о для получения строки. Получить строка либо собирается возвращать строку или NULL. 

И эта точка восклицательный знак равенства вы могли бы знать, от возможно математическом классе что вы могли бы нарисовать знак равенства с линия, проходящая через него, чтобы указать, не равны. Это вообще не персонаж вы можете набрать на клавиатуре. И поэтому в большинстве языков программирования, когда вы хотите сказать, не равны, вы используете восклицательный знак, иначе известный как взрыв. Так вы говорите, челка равно, что означает не равно, по логике вещей. Это так же, как там не больше чем, или равное или меньше или равно клавишу на клавиатуре что делает все это в одном символе. Так вот почему, в прошлых примерах, вы сделали открытый кронштейн, а затем знак равенства, для того, чтобы сделать больше или, скажем, меньше. 

Так что вынос здесь? Это просто способ теперь введение этого синтаксиса, эта функция, перебирает частных лиц символов в строке. И точно так же, как те площади кронштейны позволяют получить на них, рассмотреть эти квадратные скобки вид намекая на это основной дизайн, в результате чего каждый символ внутри строки является своего рода зажаты в где-то внизу капот в памяти вашего компьютера. 

Но давайте сделаем вариант этого. Оказывается, что это программа верна. Таким образом, на оси CS50 для оценки код, теперь это правильно. Особенно теперь, когда я проверка нуль, эта программа никогда не должна врезаться. И я просто знаю, что из опыта. Но нет ничего, что мы можем действительно пойти не так здесь. Но это не очень хорошо продуманные, потому что давайте вернемся к основам. 

Во-первых, principles-- что делает цикл делать? Для цикла делает три вещи. Она инициализирует некоторые значение, если вы попросите его. Он проверяет состояние. А потом после каждого итерации, после каждого цикла, он увеличивает некоторые значение или значения, здесь. 

Так что это значит? Мы инициализируем я до 0. Мы проверяем и убедитесь, что я меньше длина с, что Z-А-М-У-Л-А, так что меньше 6. И в самом деле, 0, как менее 6. 

Мы распечатать Z от имени Zamyla в. Тогда мы увеличиваем I от 0 до 1. Затем мы проверяем, 1 меньше чем длина S? Длина S составляет 6. Да. 

Таким образом, мы печатаем в имени Zamyla, в ZA. Мы увеличиваем I от 0, 1, до 2. Затем мы проверяем, на 2 меньше длина имени Zamyla в. 6- так 2 составляет менее 6. Да, давайте распечатать прямо сейчас M в имя Zamyla, в третий символ. 

Ключевым моментом здесь является то, что на каждом итерация этой истории, я проверяю, это я меньше, чем длина Zamyla? Но загвоздка в том, что Stirling не является свойством. Те из вас, кто программировал до этого в Java или других языках может знать длину строки является свойство, только некоторые только для чтения значение. 

В С в этом случае, если это функция, которая в буквальном смысле подсчета количества символы в Zamyla каждый раз, когда мы называем эту функцию. Каждый раз, когда вы просите компьютер, чтобы использовать Stirling, это взглянуть на Zamyla, и говоря: Z-A-M-Y-L-A, 6. И это возвращает 6. В следующий раз, когда вы звоните то внутри, что цикл, это будет смотреть на Zamyla опять, скажем Z-А-М-Y-L-A, 6. И он собирается вернуться 6. Так что глупо об этом проекте? 

Почему мой код не 5 из 5 для дизайна прямо сейчас, так сказать? Ну, Я спрашиваю вопрос излишне. Я делаю больше работы, чем мне нужно. 

Таким образом, даже несмотря на то, ответ правильный, я спрашивая компьютер, что такое длина Zamyla снова, и снова, и снова, и снова? И этот ответ никогда не изменится. Это всегда будет 6. 

Таким образом, лучшее решение, чем это будет это следующая версия. Позвольте мне идти вперед и положить его в отдельный файл с именем string1.c, просто держать его отдельно. И получается, в течение цикл, вы можете на самом деле объявить несколько переменных одновременно. 

Так что я буду держать я и установить его в 0. Но я также собираюсь добавьте запятую, и сказать, дайте мне переменную п, у которого значение равно значению длину строки с. А теперь, пожалуйста, мое состояние до тех пор, как я меньше п. 

Итак, таким образом, логика идентичны в конце дня. Но я вспоминая значение 6, в этом случае. Какова длина имени Zamyla в? И я ставлю его в п. 

И я до сих пор проверки условие каждый раз. Является 0 меньше, чем 6? 1 меньше, чем 6? Есть 2 меньше, чем 6, и так далее? 

Но я не требую компьютер снова и снова, что длина имени Zamyla в? Что длина имени Zamyla в? Что длина имени этого Zamyla в? Я буквально помнить, что первый и ответить только в этой второй переменной п. Так что это сейчас было бы не только правильно, но и хорошо продуманные. 

Теперь, что касается стиля? Я назвал мои переменные очень хорошо, я бы сказал. сейчас они супер лаконичным. И это совершенно нормально. 

Если у вас есть только один строка в программе, Вы могли бы также назвать это S для строки. Если у вас есть только одна переменная для подсчета в программе, Вы могли бы также назвать это я. Если у вас есть длина, п супер часто, как хорошо. Но я не заметил какой-либо из моего кода. 

Я не сообщил reader-- что будь моя TF, или TA, или просто colleague-- то, что, как предполагается, чтобы идти дальше в этой программе. И так, чтобы получить хороший стиль, то, что я хотел бы сделать это что-то this-- как спросить пользователя для входа. И я мог бы переписать это любое количество способов. 

Убедитесь, что S-- убедитесь ПОЛУЧАЕТ Строка, возвращаемая строка. А потом в here--, и это, возможно, самым важным comment-- итерация над персонажами с одной одновременно. И я мог бы использовать любой Выбор английского языка здесь, чтобы описать каждый из этих кусков кода. 

Обратите внимание на то, что я не оставляется комментировать каждую строку кода, на самом деле просто на интересный из них, те, есть какой-то смысл, что я мог бы хотят, чтобы сделать супер ясный кому-то чтение моего кода. А почему ты звонишь получить строка запрашивает у пользователя для входа? Даже то, что один не обязательно все, что описательный характер. Но это помогает рассказать историю, потому что Вторая строка в истории есть, убедитесь, получить строки, возвращенной строку. 

И третья строка в этой истории, перебирать символов в одном ами вовремя. А теперь просто для хорошей мерой, Я собираюсь идти вперед и добавить еще один комментарий, который как раз говорит печать I-й символ в с. Теперь, что я сделал в конце дня? 

Я добавил некоторые английские Слова в виде комментариев. Символ косая черта означает, эй, Компьютер это для человека, не для вас, компьютер. Таким образом, они игнорируются логически. Они просто есть. 

И действительно, CS50 IDE показывает их как серый, как полезные, но не ключ к программе. Обратите внимание на то, что теперь вы можете сделать. Знаете ли вы C программирования или нет, может просто стоять в стороне в этом Программа, и обезжиренное комментарии. Попросите пользователя для ввода, убедитесь, получить строки, возвращенной строку, перебирать символов в сек по одному за раз, напечатать символ I-й символ в S-- вы этого не сделаете даже смотреть на код чтобы понять, что делает эта программа. И еще лучше, если вы сами смотрите в этой программе в течение недели или двух, или месяц, или год, вы тоже не имеете смотреть на код, пытаясь вспомнить, что я пытаюсь сделать с этим кодом? 

Вы сказали себе. Вы описали это для себя, или какой-нибудь коллега или ТА, или TF. И так это теперь будет правильно, и хороший дизайн, и в конечном счете, хороший стиль, а также. Так что имейте это в виду. 

Так что есть еще одна что я собираюсь сделать здесь что теперь может показать именно то, что происходит под капотом. Так что эта функция в C и других языках, называется типажей что либо неявно или явно позволяет конвертировать от одного типа данных в другой. Мы имеем дело так далеко сегодня со строками. 

И строки символов. Но помните из недели 0, какие символы? Символы просто абстракция на вершине numbers-- десятичных чисел, и десятичных чисел действительно просто абстракция на вершине двоичных чисел, как мы определили ее. 

Так символы номера. И цифры символов, только в зависимости от контекста. И получается, что внутри компьютерной программы, Вы можете указать, как вы хотите выглядеть в биты внутри этой программы? 

Напомним, от недели 0, что у нас было Ascii, что именно этот код отображение букв к цифрам. И мы сказали, капитал А 65. Капитал Б 66, и так далее. 

И заметьте, мы, по существу есть символы на верхний ряд здесь, как C назовет их, символов, а затем Интс на втором ряду. И получается, вы можете конвертировать бесшовно между ними, как правило. И если мы хотим сделать это сознательно, мы может понадобиться для решения что-то вроде этого. 

Мы могли бы хотеть, чтобы преобразовать верхний регистр, чтобы понизить случай, или нижний регистр в верхний регистр. И получается, что есть на самом деле картина здесь мы можем охватить всего минуту. Но давайте сначала посмотрим на Пример выполнения этого в явном виде. 

Я собираюсь вернуться в CS50 IDE. Я собираюсь создать файл с именем Ascii 0.c. И я собираюсь идти вперед и добавить мой стандарт io.h в верхней части, INT Основная пустота в верхней части моей функции. А потом я просто буду делать following-- для цикла от я равна, скажем, 65 лет. 

И тогда я будет меньше 65, плюс 26 букв в алфавите. Так что я дам компьютер делать математику для меня там. А потом внутри этой петли, что я буду печатать? 

% С является% я обратной косой черты п. А теперь я хочу, чтобы подключить два значения. Я временно поставил вопрос Оценки там пригласить на этот вопрос. 

Я хочу итерацию от 65 вперед для 26 букв алфавита, печать на каждой итерации, что интегральный эквивалент персонажа. Другими словами, я хочу перебрать 26 номеров печати что Ascii символ, буква, и что соответствующее число is-- на самом деле просто воссоздание диаграмма из этого слайда. Так что же эти знаки вопроса быть? 

Что ж, получается, что второй нужно просто быть переменной я. Я хочу видеть, что как число. А средний аргумент здесь, я могу сказать компьютеру для лечения, что число я как характер, так заменить его здесь процентов C. 

Другими словами, если я, то человек программист, знаю, это просто цифры в конце дня. И я знаю, что 65 должен карта в какой-то характер. С помощью этого явного приведения типов, с скобкой, имя типа данных, который вы хотите конвертировать, и закрытым скобка, Вы можете сказать компьютер, эй, компьютер, преобразовать это число в символ. 

Так что, когда я запускаю это программа после компиляции, давайте посмотрим, что я get-- сделать Ascii 0. Чёрт это, что я сделал неправильно здесь? Использование незаявленных идентификатора, все в порядке, не намеренно, но давайте посмотрим, если мы не можем Причина через это. 

Так линия five-- так что я не получил очень далеко, прежде чем завинчивания. Ничего страшного. Таким образом, линия 5 для г равна 65-- я вижу. Так что помните, что в C, в отличие от некоторых языки, если у вас есть предварительное программирование опыт, у вас есть чтобы сказать компьютеру, в отличие от нуля, то, тип переменной она. 

И я забыл ключевую фразу здесь. В строке пять, я начал использовать I. Но я не сказал C какие данные типа это. Так что я собираюсь идти сюда и говорят, ах, сделать это целое число. 

Теперь я собираюсь идти вперед и перекомпилировать. Это зафиксировано, что. ./ascii0 Enter, это своего рода прохладный. Мало того, что это супер быстро спросить компьютер на этот вопрос, а не смотреть его на слайд, она распечатывается по одному в каждой строке, А 65, B 66, все пути down--, так как я сделал это 26 times-- с буквами г, что составляет 90. И в самом деле, немного более разумным будет были для меня не полагаться на компьютере, чтобы добавить 26. Я мог бы просто сделать 90, а также, до тех пор, как я не делают ту же ошибку дважды. Я хочу, чтобы идти через г, а не только через у. 

Так что это явное приведение. Оказывается, что это даже нет необходимости. Позвольте мне идти вперед и повторно запустить этот компилятор, и перекладка Ascii 0. Оказывается, что C является довольно умный. 

И Printf, в частности, довольно умный. Если вы просто пройти я дважды для обоих заполнителей, Printf поймут, ой, ну я тебя знаю дал мне integer-- некоторое число, как 65, или 90, или любой другой. Но я вижу, что вы хотите, чтобы я форматирования это число как символ. И поэтому Printf может неявно приведен ИНТ к полукокса для вас. Так что это не проблема вообще. 

Но обратите внимание, из-за этой эквивалентности мы можем на самом деле сделать это, как хорошо. Позвольте мне идти вперед и сделать один другая версия this-- Ascii 1.C. И вместо того, чтобы перебирает целые числа, действительно может взорвать ваш ум перебирает символов. Если символ с получает капитал A, I хотят, чтобы идти вперед и делать это, до тех пор, С меньше или равно для капитала Z. И на каждой итерации Я хочу, чтобы увеличить C, я могу Теперь в моей PRINTF линии здесь скажем, процентов С процентов я снова, разделенные C. 

А теперь, я могу пойти в другом направлении, литье характер явно в целое число. Так что, опять же, зачем вы это делаете? Это немного странно рода рассчитывать с точки зрения персонажей. 

Но если вы понимаете, что это происходит под капотом, нет действительно никакой магии. Ты говоришь, эй, компьютер даст меня переменная называется C типа полукокса. Инициализировать его капитала А. И заметить одиночные кавычки материи. 

Для символов в C, помните из На прошлой неделе, вы используете одиночные кавычки. Для строк, слов, фразы, вы используете двойные кавычки. OK, компьютер, продолжайте делать это, так Пока символ меньше или равна г. И я знаю, что от моего Ascii таблицы, что все из этих кодов ASCII являются смежными. 

Там нет никаких пробелов. Так что это просто от А до Z, разделенных одним номером каждого. И тогда я могу увеличивать полукокса, если я действительно хочу. В конце дня, это просто число. Я знаю это. Так что я могу только предположить, чтобы добавить к нему 1. 

А потом на этот раз, я печатаю с, а затем интегральный эквивалент. И я даже не нужно явное приведение. Я могу позволить Printf и тому компьютер понять вещи, так что теперь, если я бегу сделать Ascii1./ascii1, Я получаю точно такую ​​же вещь, как хорошо. 

Бесполезная программа, не though-- ни одного собирается на самом деле написать программное обеспечение для того, чтобы выяснить, что было число, которое отображается в А или В, или Z? Ты просто гуглить это, или посмотреть его в Интернете, или посмотреть его на слайде, или тому подобное. Так где же это на самом деле получить полезно? 

Ну, если говорить о том, что слайд, обратите внимание, что есть фактическая картина здесь между заглавными буквами и в нижнем регистре, что не было случайным. Обратите внимание на то, что капитал А 65. Строчные а является 97. И как далеко ниже случай а? 

Таким образом, 65 сколько шагов от 97? Таким образом, 97 минус 65 равно 32. Таким образом, капитал 65 а есть. При добавлении 32 к этому, Вы получаете в нижнем регистре а. И, что то же самое, если вычесть 32, вы получите обратно в столицу A-- же с B маленькому б, большой С до мало с. 

Все эти зазоры 32 друг от друга. Теперь, это, казалось бы, чтобы позволить нам сделать что-то вроде Microsoft Word, или Google Docs есть, где вы Можно выбрать все, а затем сказать, изменить все в нижнем регистре, или изменить все в верхний регистр, или изменить только первое слово приговора к верхнему регистру. Мы можем сделать что-то как и мы сами. 

Позвольте мне идти вперед и сохранить файл здесь называется капитализировать 0.c. И давайте идти вперед и нагнетать программу что делает именно то, что следующим образом. Так включают в себя библиотеку CS50. И включают в себя стандартные входы / выходы. 

И я знаю, что это в ближайшее время. Так что я собираюсь поставить его в там уже, string.h, поэтому у меня есть доступ к такие вещи, как Стирлинг, а затем INT главную пустоту, как обычно. А потом я собираюсь идти вперед и делать строки получает получить строку, просто, чтобы получить строку от пользователя. А потом я собираюсь сделать мой чек вменяемость. Если строка не равна нулю, то это безопасно продолжить работу. И то, что я хочу сделать? Я собираюсь перебирать от я равен 0, и п до длина строки с. 

И я собираюсь сделать это до тех пор, я меньше п, и я плюс плюс. До сих пор, я на самом деле просто заимствование идеи раньше. А теперь я собираюсь ввести филиал. 

Так что думайте снова чесать, где мы имели те развилки, а на прошлой неделе в C. Я собираюсь говорить об этом, если я-й символ в секундах больше или равно нижнему регистру а, и-- в пустом месте вы бы в буквальном смысле говорят, и, но в C вы говорите амперсанд, ampersand-- и I-й символ в секундах меньше или равен строчные г, давайте сделаем что-то интересное. Давайте на самом деле распечатать характер, без перехода на новую строку то есть символ в строке, I-й символ в строке. 

Но давайте идти вперед и вычесть 32 из него. Иначе, если символ в Строка, мы ищем не между Немного и немного г, идти вперед и просто распечатала его без изменений. Таким образом, мы ввели это обозначение в квадратных скобках для наших строк, чтобы получить на I-й символ в строке. 

Я добавил некоторую условную логику, как Царапины на прошлой неделе неделе один, где Я просто использую мой фундаментальный понимание того, что происходит под капотом. Является ли I-ый символ S больше или равно а? Мол, это 97, или 98, или 99, и так далее? 

Но это также меньше или равно до значения в нижнем регистре г? И если да, то что это значит эта линия? 14, это является своего рода росток всей идеи, заглавной письмо по просто вычесть 32 из него, в данном случае, потому что я знаю, за что диаграммы, как представлены мои номера. Так что давайте идти вперед и управлять этим, после компиляции капитализировать 0.c, и запустить капитализировать 0. 

Давайте ввести что-то вроде Zamyla в нижнем регистре ввода. И теперь мы имеем Zamyla в верхнем регистре. Давайте ввести Роба в нижнем регистре. Давайте попробуем Джейсона в нижнем регистре. И мы продолжаем получение вынуждены капитализации. Там есть небольшая ошибка, что я вид не ожидал. Обратите внимание на мой новый запрос оседает на той же строке, их имена, который чувствует себя немного грязным. 

Так что я собираюсь ехать сюда, и на самом деле в конце этой программы распечатать символ новой строки. Это все. С Printf, вам не нужно перейти в переменных или коде формата. Вы можете в буквальном смысле просто распечатать что-то вроде новой строки. 

Так что давайте идти вперед и сделать капитализировать 0 раз, повторно запустить его, Zamyla. А теперь это немного симпатичнее. Теперь, мой запрос на своей собственной новой линии. Так что это все прекрасно и хорошо. Так что это хороший пример. Но я даже не обязательно необходимо жестко закодировать 32. Знаешь что? Я мог бы say-- я никогда не помните, в чем разница. 

Но я знаю, что если я имеют строчной буквы, Я по существу хочу, чтобы вычесть от независимо от расстояния между мало а и большой А, потому что, если я предполагаю, что все остальные буквы одинаковы, которые должны получить работу. Но вместо того чтобы сделать это, вы знаете, что? Там еще один способ до сих пор. 

Если это капитализировать 1.c-- если бы я был чтобы поместить это в отдельный файл. давайте сделаем капитализировать 2.C следующим образом. Я собираюсь действительно очистить это здесь. И вместо того, чтобы даже не имея знать или заботиться о тех низком уровне детали реализации, я вместо того, чтобы только собирается напечатать символ, цитата конец цитаты, процента C, и затем вызвать другую функцию, которая существует, что принимает аргумент, который является символом, как это. 

Оказывается, в C, есть другой вызов функции к верхней, которая, как его имя предполагает, принимает характер и делает его в верхний регистр эквивалент, а затем возвращает его так что Printf можете подключить его там. И так, чтобы сделать это, хотя, я необходимо ввести еще один файл. Оказывается, есть еще один файл что вы только знаете из класса, или учебник, или интернет ссылка, называется C type.h. 

Так что, если я добавлю, что до моего среди заголовка файлы, а теперь заново компилировать эту программу, capitalize2, ./capitalize2 Enter. Давайте ввести Zamyla всего в нижнем регистре, по-прежнему работает так же. Но вы знаете, что? Оказывается, что в верхней имеет некоторые другие функциональные возможности. 

И позвольте мне представить это командовать здесь, вроде неловко по имени, но человек для руководства. Оказывается, что большинство компьютеров Linux, как мы используем here-- операционную Linux система-- есть команда называется человек, который говорит, эй, компьютер, дайте мне по эксплуатации компьютера. Что вы хотите, чтобы искать в этом руководстве? 

Я хочу посмотреть функцию открывается верхний, Enter. И это немного загадочное читать иногда. Но обратите внимание, что мы в руководство по Linux программиста. И это весь текст. И заметьте, что это имя функции здесь. Оказывается, у него есть двоюродный брат под названием снизить, которая делает противоположное. И заметьте под синопсис, чтобы использовать эту функцию функционировать страницы человека, так сказать, говорит мне, что я необходимо включить гр type.h. И я знал, что из практики. 

Вот, он показывает мне два прототипы для функции, так что если я когда-нибудь хочу, чтобы использовать эту функцию Я знаю, что они принимают в качестве входных данных, и то, что они возвращаются в качестве выходного сигнала. И потом, если я читаю описание, я вижу более подробно, что функция делает. Но что более важно, если Я смотрю под возвращаемого значения, он говорит, возвращенное значение что преобразованного письма, или С, исходный входной, если преобразование не удалось. 

Другими словами, верхний будет пытаться преобразовать письмо в верхний регистр. И если да, то он собирается вернуть ее. Но если он не может для некоторых reason-- может быть, это уже в верхнем регистре, может быть, это восклицательный знак или какой-либо другой punctuation-- это просто будет вернуть исходный C, а это значит, что я могу сделать мой код лучше разработаны следующим образом. 

Мне не нужны все эти штопать строки кода. Все строки я только выделенный может быть свернуты в только один простой линия, которая является this-- Printf процента с к верхнему кронштейну I S. И это было бы пример лучшего дизайна. 

Почему реализовать в 7 или 8 линий кода, каким бы он был я просто удален, когда вы можете вместо того, чтобы свернуть все, что логика и принятие решений в одну линию, 13, что в настоящее время опирается на библиотеку function-- функция, которая поставляется с C, но это делает именно то, что вы хотите, чтобы это сделать. И, честно говоря, даже если он не пришел с C, вы могли бы реализовать его самостоятельно, так как мы уже видели, с Int получите отрицательный результат и получить положительный INT на прошлой неделе. 

Этот код в настоящее время гораздо более удобным для чтения. И действительно, если мы прокрутки вверх, Посмотрите, насколько более компактный эта версия моей программы. Это немного громоздкой сейчас, со всеми этими включает в себя. Но это нормально, потому что теперь я стою на плечи программистов до меня. И кто бы это ни был, кто реализованы в верхней действительно сделал мне одолжение, так же, как тот, кто реализован Стирлинга действительно сделал мне одолжение некоторое время назад. И вот теперь у нас есть лучше дизайн программы который реализует ту же самую логику. 

Говоря о Стерлинга, пусть мне идти вперед и делать это. Позвольте мне идти вперед и сохранить этот файл в качестве stirling.c. И получается, мы можем отогните один другой слой довольно просто прямо сейчас. Я собираюсь идти вперед и кнут до другой программы в главном здесь просто повторно орудия длина строки следующим образом. Так вот строка кода, которая получает меня строку от пользователя. Мы продолжаем использовать это снова и снова. Позвольте мне дать себе переменную п типа Int, который хранит номер. 

И позвольте мне идти вперед и сделать следующую логику. В то время как п-й символ в S делает не равен 0 обратной косой черты, идти вперед и приращение п. И затем распечатать Printf процента I N. Я утверждаю, что эта программа здесь, без вызова длины строки, выясняет длину строки. 

И магия полностью воплощен в строке 8 вот с чем выглядит как новый синтаксис, это обратный слэш 0 в одинарные кавычки. Но почему? Ну, подумайте, что было происходит все это время. 

И, как в сторону, прежде чем я забыл, понимаю, также, что в дополнение к человеку страниц которые приходят с типичным Система Linux как CS50 IDE, понимать, что мы, Персонал конечно, в есть также сделал версию сайта этой же идеи под названием reference.cs50.net, которая имеет все те же человеко-страниц, все тот же документации, а также маленькая коробочка в верхней части, что позволяет конвертировать все из довольно аркан язык в менее комфортно режим, в котором мы, преподавательский состав, прошли и попытался упростить часть языка, чтобы держать вещи сосредоточены на идеях, а не некоторые тонкости. Так что имейте в виду, reference.cs50.net в качестве еще одного ресурса, а также. 

Но почему длина строки в работу как я предложил несколько минут назад? Вот имя Zamyla снова. А вот имя Zamyla в зажаты в, как я продолжать делать, чтобы нарисовать картину его бытия, на самом деле, просто последовательность символов. Но Zamyla не существует в изоляции в программе. 

Когда вы пишете и запустить программу, вы используете ваш Mac или ПК как память, или RAM, так сказать. И вы можете думать о ваш компьютер как имеющий много гигабайт памяти в эти дни. И гиг ​​означает миллиарды, поэтому миллиарды байт. 

Но давайте перематывать во времени. И предположим, что мы используем очень старый компьютер, имеет только 32 байта памяти. Я мог бы, на экране компьютера, просто обратить на это следующим образом. 

Я мог бы просто сказать, что мой Компьютер имеет вся эта память. И это, как палка памяти, если Вы помните нашу картину в прошлый раз. А если я просто разделить это столько раз, Я утверждаю, что у меня есть 32 байта памяти на экране. 

Теперь, на самом деле, я могу только рисовать до сих пор на этом экране здесь. Так что я собираюсь идти вперед, и только по соглашению, рисовать памяти моего компьютера в качестве сетки, а не только как одна прямая линия. В частности, я утверждаю, что в настоящее время эта сетка, это 8 по 4 сетки, просто представляет все 32 байта доступной памяти в моем Mac, или доступны в моем компьютере. И они оберточная на две линии, просто так как он подходит больше на экране. Но это первый байт. Это второй байт. Это третий байт. 

И это 32-й байт. Или, если мы думаем, как компьютер ученый, это байт 0, 1, 2, 3, 31. Так что у вас есть от 0 до 31, если Вы начинаете отсчет с 0. 

Так что, если мы используем программу что звонки получить строку, и мы получаем строку из человеческого как я назвал Zamyla, Z-A-M-Y-L-A, как в мире делает компьютер отслеживать, какой байт, который кусок памяти, принадлежит какая строка? Другими словами, если мы переходим к введите другое имя в компьютер, как этот Andi, называя получить строку во второй раз, A-N-D-я должен закончить в память компьютера, а также. Но как? 

Что ж, получается, что под капот, то, что C делает при хранении строк что человеческие типы в, или что происходят из какого-либо другого источника, является его очерчивает конец их с специальный character-- обратной косой черты 0, что это просто особый способ сказать 80 бит подряд. 

Так A-- это число 97 отзыв. Таким образом, некоторые модели из 8 битов представляет десятичное число 97. Этот обратный слэш 0 буквально число 0, а.к.а. NUL, N-U-L, в отличие от ранее, N-U-L-L, который мы говорили. Но сейчас, просто знаю, что это обратная косая 0 всего 80 бит подряд. 

И это как раз эта строка в песок, который говорит, что ничего слева принадлежит к одной строке или одного типа данных. И ничего вправо принадлежит к чему-то еще. наименование Andi, тем временем, который только визуально случается, чтобы обернуть на другой линии, но это только эстетическая деталь, Аналогичным образом завершается NUL. 

Это струна символов A-N-D-I, плюс пятый секретный характер, все 0 биты, которые просто разграничивает конец имени Andi, а также. И если мы называем получить строку в третий раз в компьютере, чтобы получить строку вида Мария, М-А-Р-I-А, так же является Марии Имя NUL завершается с обратной косой чертой 0. 

Это принципиально отличается от того, как компьютер, как правило, хранить целое число или число с плавающей точкой, или другой типы данных до сих пор, потому что вспомнить, целое число, как правило, 32 бита, или 4 байта, или возможно даже 64 бита, или восемь байт. Но многие примитивы в компьютере на языке программирования имеют фиксированное число байт под hood-- может быть 1, 2, может быть, может быть 4, может быть 8. 

Но строки, по дизайну, имеют динамическое количество символов. Вы никогда не знаете заранее, до тех пор, человеческие типы в Z-A-M-Y-L-A, или М-А-Р-И-А или А-Н-Д-И. Вы не знаете, сколько раз пользователь собирается ударить клавиатура. Таким образом, вы не знаете, как много символов в заранее вы будете нуждаться. 

И так С просто вид листьев, как у секрет крошка под капотом в конце строки. После хранения Z-А-М-Y-L-A в памяти, он также просто ставит эквивалент в течение периода. В конце предложения, он помещает 80 бит, таким образом, чтобы вспомнить, где Zamyla начинается и заканчивается. 

Так что связь, Затем, к этой программе? Эта программа здесь, Стирлинга, это просто механизм для получения строки от пользователя, строка 6. Строка 7, я объявить переменную называется п и установите его равным 0. 

А потом в строке 8, я просто спросил вопрос, в то время как п-й символ делает не равны 0 все bits-- иными словами, не делает равно этот специальный символ, обратная косая 0, был только что специальный NUL character-- идти вперед и просто увеличивать п. 

И продолжать делать это, и держать делая это, и продолжать делать это. И поэтому, даже если в прошлое мы использовали I, это прекрасно семантически использовать п, если вы просто пытаетесь рассчитывать на этот раз сознательно, и просто хотите назвать это н. Так что это просто продолжает задавать вопрос, является н-ый символ с все 0s? Если нет, посмотрите на следующий вид, посмотрите на следующий, посмотрите на следующий, посмотрите на следующий. 

Но как только вы видите обратную косую 0, это loop-- линия 9 через 11-- останавливается. Вы вырваться из цикла в то время, оставляя внутри этой переменной п в общей сложности количество всех из символов в строке, которую вы видели, таким образом, выводе на печать. Так давайте попробуем это. 

Позвольте мне идти вперед и без с помощью функции Стирлинга, а просто используя свою собственную версию доморощенные здесь называется Стирлинга, позвольте мне идти вперед и запустить Стирлинга, типа в чем-то как Zamyla, который я знаю заранее составляет шесть символов. Давайте посмотрим, работает ли он. В самом деле, это шесть. Давайте попробуем с Робом, три символа, три символа, а также, и так далее. Так что все, что происходит на под капотом. И обратите внимание, соединения, затем, начиная с первой недели класса, где мы говорили о что-то вроде абстракции, что именно это наслоение идей, или сложность, на вершине основных принципов. Здесь мы вроде смотреть под капотом Стерлинга, так сказать, чтобы выяснить, как бы это реализовать? 

И мы могли бы повторно реализовать его сами. Но мы никогда снова собирается повторно реализовать Стирлинга. Мы просто собираемся использовать Стирлинга в порядке на самом деле получить некоторые строки длины. 

Но нет никакой магии под капотом. Если вы знаете, что под капот, строка это просто последовательность символов. И это последовательность символов все они могут быть численно рассмотрены с кронштейном 0, кронштейн 1, кронштейн 2, и вы известно, что в конце строки является специальный символ, вы можете выяснить, как сделать большинство ничего в Программа, потому что все это сводится к тому, читает и пишет память. То есть, меняется и ищет в памяти, или перемещение вещей вокруг в памяти, печатные вещи на экране, и так далее. 

Так давайте теперь использовать эту вновь обретенную понимание того, какие строки на самом деле находятся под капотом, и отогните один другой слой что до сих пор мы игнорировал в целом. В частности, любое время мы реализовали программу, мы имели эту строку кода вблизи верхней объявляя главной. И мы указали INT главную пустоту. 

И эта пустота внутри скобок говорил все это время, что основная сама по себе не принимает каких-либо аргументов. Любой вклад, что главное, собирается получить от пользователя должна исходить от какой-то другой механизм, как Get INT, или получить с плавающей точкой, или получить строку, или какой-либо другой функции. Но оказывается, что когда вы пишете программу, вы можете указать что эта программа должна принимают входные сигналы от человека в самой командной строке. 

Другими словами, даже если мы до сих пор были работает только ./hello привет или аналогичные программы, все другие программы, которые мы использовали, что мы сами не писали, принимали, по-видимому, командной строки arguments-- такие вещи, как сделать. Вы говорите, что что-то вроде марка, а затем второе слово. Или лязг, вы говорите лязг, а затем второе слово, имя файла. 

Или даже RM или СР, как можно было бы видели или использовать уже удалять или копировать файлы. Все те принимают так называемые командной строки arguments-- дополнительные слова в строке терминала. Но до сих пор, мы сами не имели Этот роскошный принимать входной сигнал от пользователя, когда он или она на самом деле работает сама программа в командной строке. 

Но мы можем сделать это путем повторного декларирования Основной двигаться вперед, а не как имеющие недействительным в скобках, но эти два аргумента instead-- первое целое число, а второй что-то новое, то, что мы будем называть массив, нечто подобное в духе к тому, что мы видели в пустом виде списка, но массив строк, как мы скоро увидим. Но давайте посмотрим на это В качестве примера, прежде чем мы различают именно то, что это значит. 

Так что, если я иду в CS50 IDE здесь, я пошел вперед и объявлен в файле с именем argv0.c следующий шаблон. И заметьте, единственное, что по-другому до сих пор является то, что я изменил ничтожным Int ARGC строка ARGV открытый кронштейн, близко скобка. И обратите внимание на данный момент, есть ничего не внутри этих скобок. 

Там нет числа. И нет я, или N, или любое другое письмо. Я просто с помощью квадратные скобки на данный момент, по причинам, мы приедем обратно в мгновение. 

А теперь, что я собираюсь сделать это. Если ARGC равен равен 2-- и напомним, что равняется равных является оператором сравнения равенства левый и правый для равенства. Это не уступка оператор, который единственный знак равенства, что означает копию от справа налево какое-то значение. 

Если ARGC равен равен 2, я хочу скажем, Printf, привет, проценты, новая линия, а затем подключить in-- и вот новый trick-- ARGV кронштейн 1, по причинам что мы вернемся в минуту. Иначе, если ARGC не равно 2, вы знаете, что? Давайте просто идти вперед и, как обычно, печать вне привет мир, без замены. 

Так что, казалось бы, что если ARGC, который выступает за количеством аргументов, равняется 2, Я собираюсь распечатать привет что-то или другое. В противном случае, по умолчанию, я собирается напечатать привет мир. Так что же это означает? 

Что ж, позвольте мне идти вперед и сохранить этот файл, а затем делают argv0, а затем ./argv0, Enter. И это говорит привет мир. Теперь, почему это? 

Что ж, получается, в любое время вы запустить программу в командной строке, вы заполняете в том, что мы будем обычно называем вектор аргументов. Другими словами, автоматически компьютер, операционная система, собирается передать вашей программе Сам список всех слов что человек набрал на подсказка, в случае, если программист хочет сделать что-то с этой информацией. И в этом случае единственное слово, Я набрал в строке является ./argv0. 

И поэтому число аргументов, является передается в моей программе только один. Другими словами, аргумент рассчитывать, иначе известный как ARGC здесь как целое число, это лишь один. Один из них, конечно, не равно двум. И так это то, что печатает, привет мир. 

Но позвольте мне взять это где-то. Позвольте мне сказать, argv0. А потом, как о Марии? А затем нажмите клавишу Enter. 

И обратите внимание, что волшебным образом здесь происходит. Теперь, вместо привет мир, у меня есть изменил поведение этой программы принимая вход не от Get строка или какой-либо другой функции, но из, по-видимому, моя команда Сам, что я первоначально напечатал. И я могу играть в эту игру снова изменяя его Стелиос, например. 

А теперь я вижу другое имя до сих пор. И здесь, я мог бы сказать, Анди. И я мог бы сказать Zamyla. И мы можем играть в эту игру в течение всего дня, просто затыкать в различных значениях, до тех пор, как я предоставить именно два слова в командной строке таким образом, что ARGC, граф мой аргумент, 2. 

Вижу ли я, что имя подключен к Printf, в этом состоянии здесь? Таким образом, мы, кажется, в настоящее время выразительный потенциал принимать входной сигнал от другого механизма, от так называемой командной строки, вместо того, чтобы ждать до тех пор, пока пользователь не запускает программу, а затем побудить его или ее используя что-то вроде получения строки. 

Так что же это? ARGC, опять же, это всего лишь целое число, количество words-- arguments-- что пользователь при условии, на подскажите, в окне терминала, в том числе название программы. Таким образом, наша ./argv0 является, по сути, название программы, или как я запустить программу. 

Это считается как слово. Так ARGC будет 1. Но когда я пишу Стелиос, или Andi или Zamyla, или Мария, это означает, что количество аргументов равно двум. И вот теперь есть два слова, передаваемые в. 

И заметьте, мы можем продолжить эту логику. Если бы я на самом деле сказать что-то вроде Zamyla Чан, полное имя, тем самым передав три аргумента в общей сложности, Теперь он снова говорит по умолчанию, потому что, конечно же, 3 не равно 2. 

И вот таким образом, у меня есть доступ через ARGV этот новый аргумент что мы могли бы технически называть все, что угодно. Но в соответствии с соглашением, это ARGV и ARGC соответственно. ARGV, вектор аргументов, является своего рода синонима для программирования функция в C называется массив. 

Массив представляет список значений аналогичных назад, к спине, к спине, к спине. Другими словами, если кто-то здесь, в RAM, следующий прямо рядом с ним, и рядом с ним. Они не повсюду. И это последний сценарий, где вещи находятся повсюду в памяти, может быть на самом деле мощная функция. Но мы вернемся к тому, что, когда мы говорить о причудливых структур данных. На данный момент, массив просто кусок непрерывной памяти, каждый из которых элементы назад, к спине, к спине, к спине, и, как правило тот же самый тип. 

Так что если вы думаете о том, от А минуту назад, что такое строка? Ну, строка, как Zamyla, Z-А-М-У-Л-А, это, технически, просто массив. Это массив символов. 

И поэтому, если мы действительно сделать это, как я сделал ранее, как кусок памяти, получается, что каждый из них символов занимает байт. А тут что особое сторожевого символ, обратная косая 0, или все восемь бит 0, что разграничивает конец этой строки. Так строка, получается вне, цитируют Unquote строку, это просто массив chara-- обугливается будучи фактическим типом данных. 

А теперь ARGV, meanwhile-- давайте вернемся к программе. ARGV, хотя мы видим, слово Строка здесь, не является сама строка. ARGV, вектор аргументов, представляет собой массив строк. 

Так же, как вы можете иметь массив символов, вы можете иметь более высокий уровень, массив strings-- так, например, когда я набрал минуту назад ./argv0 argv0, пространство Z-A-M-Y-L-A, я утверждал, что ARGV имел две строки в it-- ./argv0, и Z-A-M-Y-L-A. В Другими словами, ARGC было 2. Почему это? 

Ну, по сути, то, что происходит на том, что каждая из этих строк это, конечно, массив символов как и прежде, каждый из которых персонажи занимает один байт. И не путайте фактическую 0 в названии программы с 0, что означает все 80 бит. И Zamyla, тем временем, по-прежнему также массив символов. 

Таким образом, в конце концов, это на самом деле выглядит следующим образом под капотом. Но ARGV, по своей природе, как главный работы, позволяет мне обернуть все это до в, если вы будете, больший массив что, если мы чуть более упростить что картина выглядит и не достаточно нарисовать ее в масштабе там, Этот массив является только размером 2, первый элемент которого содержит строку, второй элемент которая содержит строку. И, в свою очередь, если вы вид увеличения на каждом из этих строк, что вы см под капотом является то, что каждая строка просто массив символов. 

Теперь, так же, как со строками, мы были в состоянии получить доступ к г-го символа в строке с помощью этой квадратной скобки обозначения. Точно так же, с массивами в общем, мы можем использовать квадратные скобки, обозначения, чтобы получить на любое количество строк в массиве? Например, позвольте мне идти вперед и делать это. 

Позвольте мне идти вперед и создать argv1.c, который немного отличается на этот раз. Вместо проверки для argc2, Я буду вместо этого. Для инт я получаю 0, я меньше чем ARGC, я плюс плюс, а затем распечатать внутри этого, процентов s, новая линия, а затем ARGV кронштейн я. 

Итак, другими словами, я не имеем дело с отдельные символы в данный момент. ARGV, как следует из этих пустой квадрат брекет справа от имени ARGV, означает ARGV массив строк. И ARGC это просто инт. 

Эта линия здесь, 6, является говоря набор я равным 0. Граф весь путь до, но не включая, ARGC. И затем на каждой итерации, распечатать строку. Какая строка? 

I-й строки в ARGV. Так что в то время, прежде чем я был используя квадратные скобки обозначения, чтобы получить в г-й символ в строке, теперь Я использую квадратные скобки, обозначения чтобы получить в строке й в массиве. Так что это своего рода один слой выше, концептуально. 

Так что аккуратным об этом Программа теперь, если я компилирую argv1, а затем сделать ./argv1, а затем введите в чем-то вроде бара Baz Foo, которые являются три стандартные слова, которые ученый достигает в течение любого времени он или она нуждается в некоторых шаблонные слова, и нажмите Enter, каждое из этих слов, в том числе название программы, которая находится в ARGV на первом месте, заканчивается печатается по одному за раз. И если я изменить это, и я говорю: что-то вроде argv1 Zamyla Чан, мы получаем все три из них слова, что является argv0, argv1, argv2, потому что в этом случай ARGC, счетчик, 3. 

Но что аккуратный, если вы понимаете, что ARGV просто массив строк, и вы понимаете, что строка представляет собой массив символов, мы можем на самом деле вид использовать эту функцию квадратные скобки обозначения несколько раз чтобы выбрать строку, а затем выберите символ в строке, дайвинг глубже следующим образом. В этом примере, отпусти меня вперед и назвать эту argv2.c. И в этом примере, позвольте мне идти вперед и сделать following-- для INT я получаю 0, я меньше ARGC, я плюс плюс, так же, как и раньше. Таким образом, в другом words-- и теперь этот становится достаточно сложной. Тогда я собираюсь сказать, перебирать струны в ARGV, в качестве комментария к себе. И тогда я буду иметь вложенный цикл, который вы, вероятно, сделали или считаются делать в пустом месте, где Я хочу сказать, я int-- не собирается использовать я снова, потому что я не хочу, чтобы тень, или своего рода переписать существующий I. 

Я собираюсь, а не, скажем, J, так как это моя перейти к переменной после того как я, когда я просто пытаюсь рассчитывать простые числа. Для J получает 0--, а также, п, собирается получить кормовой длину ARGV кронштейна I, до тех пор, J меньше т, J плюс плюс, сделайте следующее. А вот интересная часть. 

Распечатайте характер и новую линию, подключив ARGV кронштейн I, кронштейн J. ОК, так что позвольте мне добавить некоторые комментарии здесь. Перебрать символы в текущей строке, печать J-й символ в г-й строке. Так что теперь, давайте рассмотрим Что означают эти комментарии. 

Перебор по струнам в argv-- сколько строки в ARGV, который является массивом? ARGC много, поэтому я итерация от я равно 0 до ARGC. В то же время, сколько символов в г-й строки в ARGV? 

Ну, чтобы получить этот ответ, Я просто называю длину строки на I уход текущей строки о, что ARGV кронштейн я. И я собираюсь временно хранить, что значение п, только для целей кэширования, помнить его эффективности. И тогда я буду инициализировать J 0, продолжать идти так долго, как J меньше п, и на каждый шаг итерации J. 

А потом здесь, в мой комментарий в строке 12, распечатать символ, а затем новой линии, специально ARGV кронштейн я дает мне I-й строки в argv-- так что первое слово, то Второе слово, третье слово, что угодно. А потом J ныряет глубже и получает я J-й символ этого слова. И так, в сущности, вы можете обращаться ARGV как многомерное, в качестве двумерного массива,, причем каждое слово вид выглядит как это в вашем воображении глаза, и каждый символ является своего рода состоит в столбец, если это помогает. 

На самом деле, когда мы дразнить это друг от друга в будущих недель, это будет немного более сложной, чем это. Но вы можете реально думать о том, что на данный момент, как только что это двумерная Массив, в результате чего один уровень его это все строки. И потом, если вы ныряете в глубже, вы может получить в отдельных символов в нем, используя эти обозначения здесь. 

Так что же такое чистый эффект? Позвольте мне идти вперед и сделать argv2-- штопать его. Я сделал ошибку здесь. Косвенно объявив библиотека функций Стирлинга. Так что все это время, это возможно, целесообразно что мы вроде отделки именно там, где мы начали. 

Я облажался, безоговорочное признание библиотека функций Стирлинга. Хорошо, подождите минуту. Я помню, что, особенно так как это прямо здесь. Мне нужно, чтобы включить string.h в эта версия программы. 

Позвольте мне идти вперед и включают в себя string.h, кроме того, что, идти вперед и пересобрать argv2. И теперь, здесь мы идем, сделать argv2, Enter. И хотя это немного загадочные на первый взгляд, обратите внимание, что, на самом деле, то, что распечатывается является точка argv2. 

Но если я ввести некоторые слова за подскажите, как argv2 Zamyla Чан, Введите, также немного загадочные на первый взгляд. Но если мы прокручиваем обратно вверх, ./argv2 Z-А-М-У-Л-С-Н-А-Н. Таким образом, мы итерацию над каждым словом. И, в свою очередь, мы итерации каждый символ в слове. 

Теперь, после того, как все это, понимаю, что есть одна деталь мы были своего рода игнорировать все это время. Мы просто дразнят друг от друга, что Входы главных может быть? Как насчет выхода главных в? 

Все это время мы были просто копирование и вставка слово INT перед главным образом, хотя вы можете увидеть в Интернете, иногда неправильно в более ранних версиях С и компиляторов, что они говорят, что пустота, или вообще ничего. Но, на самом деле, для версии С, что мы используем, C 11, или 2011, реализовать что оно должно быть инт. И это должно быть либо недействительным или ARGC и ARGV здесь. 

Но почему INT главный? Что это на самом деле возвращение? Что ж, оказывается, все это время, в любое время вы написали программа главная всегда возвращается что-то. Но это было делать это тайно. 

Это что-то есть INT, в строке 5 предлагает. Но что INT? Ну, есть такая конвенции в области программирования, причем, если ничего не имеет пошло не так, и все хорошо, программы и функции в целом return-- несколько counterintuitively-- 0. 0 в целом означает, что все хорошо. Так что даже если вы думаете это как ложь во многих контекстах, это на самом деле означает, как правило, хорошая вещь 

В то же время, если программа возвращает 1, или отрицательный 1, или 5, или отрицательный 42, или любой не-0 значение, что в целом означает что что-то пошло не так. На самом деле, на вашем собственном Mac или PC, Вы, возможно, на самом деле видел сообщение об ошибке, в результате чего его говорит что-то или другое, ошибка код отрицательный 42, или код ошибки 23, или что-то в этом роде. Это число, как правило, только намек программисту или компании что сделал программное обеспечение, что пошло не так и почему, таким образом, чтобы они могли смотреть через их документация или код, и выяснить, что ошибка на самом деле означает. Как правило, не полезным для нас конечных пользователей. 

Но когда основные возвращает 0, все хорошо. И если вы не укажете какие основные должны вернуться, он просто будет автоматически возвращает значение 0 для вас. Но, возвращаясь что-то еще на самом деле полезно. 

В этой заключительной программе, дайте мне идти вперед и назвать эту exit.c, и ввести последний из сегодняшних темы, известные как код ошибки. Позвольте мне идти вперед и включают в себя наши знакомые файлы Наверху, сделайте INT главный. И на этот раз, давайте делать Int ARGC, Строка ARGV, и с моих скобках подразумевает, что это в массиве. И тогда позвольте мне сделать проверку вменяемости. На этот раз, если ARGC не равно 2, то вы знаете, что? Забудь это. Я хочу сказать, что, эй, пользователь, вам не хватает аргумент командной строки обратная косая п. 

А потом это все. Я хочу, чтобы выйти. Я собираюсь превентивно, и преждевременно действительно, возвращение что-то другое, чем число 1. Перейти к значению для первого ошибка, которая может произойти 1. Если у вас есть какой-то другой ошибочный ситуация, которая может произойти, Вы могли бы сказать, возвращение 2 или возвращение 3, или может быть, даже отрицательный 1 или отрицательный 2. 

Это только коды завершения которые являются, как правило, только полезно для программиста, или компания, судоходная программное обеспечение. Но тот факт, что это не 0, что важно. Так что, если в этой программе, я хочу гарантировать, что эта программа только работает, если пользователь предоставляет мне с количеством аргументов, из двух, название программы, а также некоторые другие слово, я могу применять столько, сколько следует, кричать на пользователя с PRINTF поговорке, отсутствует аргумент командной строки, возвращает 1. Это будет просто немедленно выйти из программы. 

Только если ARGC равен 2 мы получим вниз здесь, в какой момент я собираюсь сказать, привет процентов s, обратный слэш н, argv1. Другими словами, я не будет после того, как ARGV 0, который является только название программы. Я хочу, чтобы напечатать Привет, запятая, второе слово, которое напечатал человек. И в этом случае на строка 13, все хорошо. 

Я знаю, что ARGC 2 логически вытекает из этой программы. Я собираюсь идти вперед и возвращать 0. Как и в сторону, имейте в виду, что это верно в пустом месте, а также. 

По логике вещей, я мог бы это сделать и инкапсулировать эти строки кода в этом пункте остальное здесь. Но это своего рода излишне отступы мой код. И я хочу, чтобы сделать супер ясно, что независимо от того, по умолчанию, привет что-то и будет напечатан, до тех пор, пока пользователь взаимодействует. 

Так что это очень распространено использование состояние, просто если, поймать некоторые ошибочные ситуация, а затем выйти. И тогда, до тех пор, все ну, не имеют другого, но просто код снаружи, что, если, потому что это эквивалент в этом частный случай, логически. Так что я возвращаюсь 0, просто явно означает, что все хорошо. 

Если я пропустил возвращение 0, было бы автоматически предполагается, для меня. Но теперь, когда я возвращаюсь один, по крайней мере этом случае, Я собираюсь, для хорошей мерой и ясность, возвращает 0 в этом случае. Так что теперь позвольте мне идти вперед и сделать выход, который является идеальным Segue просто уйти. 

Но сделать выход, и отпустить меня вперед и делать ./exit, Enter. И программа заорал на меня, отсутствует аргумент командной строки. Хорошо, позвольте мне сотрудничать. 

Позвольте мне вместо того, чтобы делать ./exit, Дэвид, Enter. А теперь он говорит, привет Дэвид. И вы обычно не видите это. 

Но оказывается, что есть особый путь в Linux на самом деле увидеть с тем, что код завершения программы завершается. Иногда в графическом мир, как Mac OS или Windows, вы видите только эти цифры, когда сообщение об ошибке появляется на экране и программист показывает, что число. Но если мы хотим, чтобы увидеть, что ошибка сообщение, мы можем сделать это here-- так ./exit, Enter, печать отсутствует аргумент командной строки. 

Если я теперь делать эхо $ ?, который смешно загадочные глядя. Но $? является магическим заклинанием что говорит, эй, компьютер, скажите мне, что предыдущий код выхода программы был. И я ударил Enter. Я вижу 1, потому что это то, что я сказал своей основной функции, чтобы вернуться. 

В то же время, если я ./exit Давида, и нажмите Enter, я вижу, привет Давида. И если я теперь делать эхо $ ?, Я вижу привет 0. И таким образом это будет на самом деле быть ценной информации в контексте отладчика, не так много, что вы, человек, будет заботиться. Но отладчик и другие программы, которые мы будем использовать в этом семестре будет часто смотреть на это число, несмотря на то, что это своего рода запрятаны если не искать его, чтобы определить, действительно ли програмы исполнение было правильным или неправильным. 

И так, что приводит нас к это, в конце дня. Мы начали сегодня, глядя на отладки, и в свою очередь, в ходе сама по себе, а затем более интересно, технически под капотом на то, что строки, которые длятся неделю мы просто взяли нечто само собой разумеющееся, и, конечно, взял их как само собой разумеющееся в пустом месте. 

Затем мы рассмотрели, как мы можем получить доступ отдельные символы в строке, а затем снова взял на более высокий уровень смотреть на вещи, глядя на то, как well-- если мы хотим получить на индивидуальном элементы в списке, как структура, мы не можем сделать это с несколькими строками? И мы можем с аргументами командной строки. Но эта картина здесь просто коробки Показательно в этой общей идеи массива или списка или вектора. И в зависимости от контекст, все эти слова означают немного разные вещи. Таким образом, в C, мы только собираемся говорить о массиве. И массив представляет собой кусок памяти, каждый из которых это элементы являются смежными, обратно, к спине, к спине, к спине. 

И эти элементы, как правило, одного и того же типа данных, символов, характер, характер, характер, или строка, строка, строка, строка, или INT, INT, INT, то, что это мы пытаемся сохранить. Но в конце концов, это как это выглядит концептуально. Вы берете ваш памяти или ОЗУ компьютера. И вы вырезая его в одинакового размера коробки, все из которых вернулись, к спине, чтобы назад, к спине таким образом. 

И что приятно о эта идея, и тот факт, что мы можем выразить значения в этом случае с первым из наших структур данных в классе, означает, что мы можем начать решить проблемы с кодом что пришло так интуитивно в неделю 0. Вы помните, телефон Пример книги, где мы использовали разделяй и властвуй, или двоичный алгоритм поиска, просеивать в целом куча имен и номеров. Но мы предполагали, напомним, что это Телефонная книга была уже отсортирован, что кто-то уже фигурный out-- дан список имен и numbers--, как в алфавитном порядке их. И теперь, когда в C мы, тоже есть возможность заложить вещи, а не физически в телефонной книге но практически в компьютера память, мы сможем на следующей неделе ввести снова this-- первый наших структур данных в array-- но что более важно, фактический компьютер Алгоритмы науки реализованы в коде, с помощью которого мы можем хранить данные в структурах, как это, а затем начинают манипулировать ею, и на самом деле решить проблемы, связанные с ним, и построить на вершине этого, в конечном счете, программы в C, в Python, в JavaScript, запросов к базам данных с SQL? 

И мы видим, что все эти различные идеи блокировки. Но сейчас, напомним, что Домен, который мы ввели сегодня была эта вещь здесь, и мир криптографии. А среди следующих проблем вы сами будет решать это искусство криптографии, скремблирования и дескремблирования информация, и шифрации и расшифровка текста, и предполагая, в конечном счете, что теперь вы знаете, что находится под капотом так что, когда вы видите или получить сообщение как это, вы сами можете расшифровать его. Все это, и больше в следующий раз. 

[ПРОИГРЫВАНИЕ ВИДЕО] 

-Mover Только что прибыл. Я собираюсь идти визит его профессор колледжа. Ага. Здравствуй. Это ты. Подождите! Дэвид. Я просто пытаюсь понять что случилось с вами. Пожалуйста, что-нибудь может помочь. Вы были его колледж сосед по комнате, не так ли? Вы были там с ним, когда он завершил проект CS50? 

[МУЗЫКА] 

-Вот Был CS50. 

Мне нравится это место. 

-Eat Вверх. Мы собираемся из бизнеса. 

[КОНЕЦ ВОСП] 