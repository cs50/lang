1
00:00:00,000 --> 00:00:02,970
>> [SKAN MŪZIKA]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Malan: Labi.

4
00:00:15,700 --> 00:00:18,832
Tas ir CS50, un šī
ir sākums 2. nedēļā.

5
00:00:18,832 --> 00:00:21,040
Un jūs atgādināt, ka vairāk nekā
Pēdējo pāris nedēļu laikā,

6
00:00:21,040 --> 00:00:24,490
mēs esam ieviešot datoru
zinātne un, savukārt, programmēšana.

7
00:00:24,490 --> 00:00:27,640
>> Un mēs sākām stāsts veidā
Scratch, ka grafiskā valoda

8
00:00:27,640 --> 00:00:28,990
no MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
Un tad pavisam nesen,
pagājušajā nedēļā, mēs esam

10
00:00:30,780 --> 00:00:34,450
ieviest higher-- A
zemāka līmeņa valoda zināms

11
00:00:34,450 --> 00:00:36,770
kā C, kaut kas ir tīri teksta.

12
00:00:36,770 --> 00:00:39,440
Un, protams, pēdējo reizi mēs
pētītas šajā kontekstā

13
00:00:39,440 --> 00:00:40,450
vairākas koncepcijas.

14
00:00:40,450 --> 00:00:43,010
>> Tas, atgādināt, bija ļoti
Pirmā programma mēs paskatījās.

15
00:00:43,010 --> 00:00:45,710
Un šī programma, gluži vienkārši,
izdrukā, "Hello, World".

16
00:00:45,710 --> 00:00:47,730
Bet tur ir tik daudz
šķietams burvju notiek.

17
00:00:47,730 --> 00:00:51,460
Tur ir šis # include
ar šiem leņķa iekavās.

18
00:00:51,460 --> 00:00:52,170
Tur ir int.

19
00:00:52,170 --> 00:00:53,020
Ir (spēkā neesošs).

20
00:00:53,020 --> 00:00:56,330
Tur ir iekavas, cirtaini bikšturi,
semikoli, un tā daudz vairāk.

21
00:00:56,330 --> 00:00:58,480
>> Un tā, atgādināt, ka
mēs ieviesām Scratch

22
00:00:58,480 --> 00:01:02,110
lai mēs varētu, ideālā gadījumā, sk pagātni
ka sintakse, sīkumi, kas tiešām nav

23
00:01:02,110 --> 00:01:04,590
viss, kas intelektuāli
interesanti, bet agri

24
00:01:04,590 --> 00:01:07,700
ir absolūti, mazliet viltīgs
wrap savas domas ap.

25
00:01:07,700 --> 00:01:10,860
Un, protams, ir viens no visbiežāk
lietas agri programmēšanas klasē,

26
00:01:10,860 --> 00:01:13,443
jo īpaši tiem mazāk
ērti, ir iegūt neapmierinātas ar

27
00:01:13,443 --> 00:01:17,460
un paklupu up ar noteiktu sintaktisko
kļūdas, nemaz nerunājot loģiskās kļūdas.

28
00:01:17,460 --> 00:01:19,800
Un tā no mūsu mērķiem
šodien, patiesībā, būs

29
00:01:19,800 --> 00:01:23,280
būt aprīkot jūs ar dažiem
problēmu risināšana paņēmieni, kā

30
00:01:23,280 --> 00:01:26,705
labāk risināt problēmas paši
formā atkļūdošanu.

31
00:01:26,705 --> 00:01:29,330
Un jūs atgādināt arī, ka
vide, ka mēs iepazīstinājām

32
00:01:29,330 --> 00:01:31,780
pēdējo reizi sauca CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Šī ir tīmekļa programmatūru, kas
ļauj ieprogrammēt mākonis,

34
00:01:34,850 --> 00:01:38,450
tā sakot, saglabājot visas jūsu
failus kopā, jo mēs atkal šodien.

35
00:01:38,450 --> 00:01:41,480
Un atgādina, ka mēs
pārskatīt šīs tēmas šeit,

36
00:01:41,480 --> 00:01:44,480
starp tiem funkcijas, un cilpas, un
mainīgie, un Būla izteiksmes,

37
00:01:44,480 --> 00:01:45,110
un nosacījumiem.

38
00:01:45,110 --> 00:01:49,190
Un patiesībā vēl dažus, ka mēs
tulkots no pasaules Scratch

39
00:01:49,190 --> 00:01:50,800
uz pasaules C.

40
00:01:50,800 --> 00:01:53,220
>> Bet galvenais ēka
bloki, tā sakot,

41
00:01:53,220 --> 00:01:55,150
bija tiešām joprojām ir tas pats pagājušajā nedēļā.

42
00:01:55,150 --> 00:01:57,900
Patiesībā, mēs tiešām tikai bija
atšķirīgs puzzle gabals, ja Jums gribas.

43
00:01:57,900 --> 00:02:00,300
Tā vietā, lai violeta
glābt bloku, mēs vietā

44
00:02:00,300 --> 00:02:02,940
bija Printf, kas ir
šī funkcija C ka

45
00:02:02,940 --> 00:02:05,890
ļauj drukāt kaut ko
un formatēt to uz ekrāna.

46
00:02:05,890 --> 00:02:07,950
Mēs iepazīstinājām CS50
Bibliotēka, kur jums

47
00:02:07,950 --> 00:02:11,420
tagad jūsu rīcībā get_char,
un get_int, un get_string,

48
00:02:11,420 --> 00:02:14,610
un dažas citas funkcijas, kā
labi, caur kuru jūs varat saņemt ievade

49
00:02:14,610 --> 00:02:16,260
no lietotāja paša klaviatūru.

50
00:02:16,260 --> 00:02:20,640
Un mēs arī ņēma apskatīt lietas
piemēram these- bool un palijas,

51
00:02:20,640 --> 00:02:22,490
un dubultā, peldēt,
int, long_long string.

52
00:02:22,490 --> 00:02:25,170
Un tur pat citu datu tipu C

53
00:02:25,170 --> 00:02:28,560
>> Citiem vārdiem sakot, ja jūs deklarēt
mainīgais uzglabāt dažas vērtību,

54
00:02:28,560 --> 00:02:32,600
vai ja jums īstenot funkciju
kas atgriež dažas vērtības,

55
00:02:32,600 --> 00:02:35,290
Jūs varat norādīt, ko
par vērtību, kas ir tips.

56
00:02:35,290 --> 00:02:37,310
Vai tas ir string, piemēram,
rakstzīmju secība?

57
00:02:37,310 --> 00:02:39,490
Vai tas ir skaitlis, piemēram, skaitlim?

58
00:02:39,490 --> 00:02:41,390
Vai tā ir peldošā komata
vērtība, vai tamlīdzīgi?

59
00:02:41,390 --> 00:02:46,180
Tātad C, atšķirībā no nulles, mēs faktiski
sāka norādīt, kāda veida datus

60
00:02:46,180 --> 00:02:48,330
mēs atgriešanās vai izmanto.

61
00:02:48,330 --> 00:02:51,910
>> Bet, protams, mēs arī uzbrauca
dažas būtiskas robežas skaitļošanas.

62
00:02:51,910 --> 00:02:54,100
Un it īpaši,
šī valoda C, atsaukšana

63
00:02:54,100 --> 00:02:57,070
ka mēs ņēmām apskatīt
skaitlis pārplūdes, realitāte

64
00:02:57,070 --> 00:03:00,460
ka, ja jums ir tikai
ierobežots atmiņas apjoms

65
00:03:00,460 --> 00:03:04,600
vai, precīzāk, ierobežots skaits
bitu, jūs varat tikai paļauties tik augsts.

66
00:03:04,600 --> 00:03:08,460
Un tā mēs paskatījās šo piemēru šeit
saskaņā ar kuru skaitītājs lidmašīnā,

67
00:03:08,460 --> 00:03:13,510
patiesībā, ja darbojas pietiekami ilgi būtu
pārplūdes un izraisīt programmatūru

68
00:03:13,510 --> 00:03:15,560
faktiskais fiziskais iespējamā kļūda.

69
00:03:15,560 --> 00:03:18,600
>> Mēs arī apskatīja peldošā
neprecizitāte punkts, realitāte

70
00:03:18,600 --> 00:03:22,280
ka tikai ierobežots skaits
bitu, vai tas ir 32 vai 64,

71
00:03:22,280 --> 00:03:27,330
Jūs varat norādīt tikai tik daudz numurus
pēc komata, pēc kura jūs

72
00:03:27,330 --> 00:03:29,110
sāk saņemt neprecīza.

73
00:03:29,110 --> 00:03:32,360
Tā, piemēram, vienu trešo vietu
pasaule šeit, mūsu cilvēku pasaulē,

74
00:03:32,360 --> 00:03:35,360
mēs zinām, ir tikai bezgalīgi daudz
no 3s aiz komata.

75
00:03:35,360 --> 00:03:38,820
Bet dators var nebūt
pārstāv neskaitāmas numuru

76
00:03:38,820 --> 00:03:42,590
ja Jums ir tikai ļaujiet tai dažas
ierobežots informācijas daudzums.

77
00:03:42,590 --> 00:03:45,900
>> Tātad ne tikai mēs aprīkot jūs
ar lielāku jaudu ziņā

78
00:03:45,900 --> 00:03:49,280
par to, kā jūs varētu izteikt sevi
tastatūra ziņā plānošanu,

79
00:03:49,280 --> 00:03:51,430
mēs arī ierobežots, ko
jūs faktiski var darīt.

80
00:03:51,430 --> 00:03:55,790
Un tiešām, bugs un kļūdas var
rodas no šiem jautājumiem veidu.

81
00:03:55,790 --> 00:03:59,900
Un tiešām, starp tēmām šodien
ir būs tēmas, piemēram atkļūdošana

82
00:03:59,900 --> 00:04:03,699
un faktiski meklē zem pārsega
cik tika ieviests lietas pagājušajā nedēļā

83
00:04:03,699 --> 00:04:05,490
faktiski īstenoti
lai jūs labāk

84
00:04:05,490 --> 00:04:10,530
izprast gan spējas un
ierobežojumi valodā, piemēram, C.

85
00:04:10,530 --> 00:04:14,770
>> Un patiesībā, mēs mizu atpakaļ slāņus
no vienkāršākajiem datu struktūras,

86
00:04:14,770 --> 00:04:17,756
kaut ko sauc masīvs, kas
Scratch notiek zvanīt "sarakstu."

87
00:04:17,756 --> 00:04:19,589
Tas ir mazliet
atšķirīga šajā kontekstā.

88
00:04:19,589 --> 00:04:23,340
Un tad mēs arī ieviest vienu no
Pirmais no mūsu domēna specifiskas problēmas

89
00:04:23,340 --> 00:04:26,790
in CS50, pasaule
kriptogrāfija, māksla kodēšanas

90
00:04:26,790 --> 00:04:29,650
vai šifrēšana informāciju,
ka jūs varat nosūtīt slepenu ziņu

91
00:04:29,650 --> 00:04:34,520
un atšifrēt slepenu ziņu
starp divām personām, A un B

92
00:04:34,520 --> 00:04:37,490
>> Tātad, pirms mēs pārejas
ar šo jauno pasauli,

93
00:04:37,490 --> 00:04:42,059
pamēģināsim aprīkot jūs ar dažiem
metodes, ar kuru jūs varat novērst

94
00:04:42,059 --> 00:04:43,850
vai samazināt vismaz daži
no neapmierinātību

95
00:04:43,850 --> 00:04:46,630
ka jūs, iespējams, radušās
pāri vien pagājušajā nedēļā.

96
00:04:46,630 --> 00:04:50,830
Patiesībā, pirms jums ir such-- daži
savu pirmo problēmas C. Un izredzes ir,

97
00:04:50,830 --> 00:04:54,010
Ja jūs esat līdzīgi man, pirmo reizi
jūs mēģināt rakstīt out programmu,

98
00:04:54,010 --> 00:04:57,330
pat ja jūs domājat, ka loģiski
programma ir diezgan vienkāršs,

99
00:04:57,330 --> 00:05:01,200
jūs varētu ļoti labi hit sienas, un
kompilators nav gatavojas sadarboties.

100
00:05:01,200 --> 00:05:03,940
Marka vai šķindēt negrasās
lai faktiski darīt savu solīšanu.

101
00:05:03,940 --> 00:05:05,450
>> Un kāpēc varētu būt?

102
00:05:05,450 --> 00:05:07,950
Nu, pieņemsim to apskatīt,
varbūt, vienkārša programma.

103
00:05:07,950 --> 00:05:11,190
Es iešu uz priekšu un saglabāt to
fails apzināti sauc buggy0.c,

104
00:05:11,190 --> 00:05:13,590
jo es zinu to
būt kļūdaina iepriekš.

105
00:05:13,590 --> 00:05:17,400
Bet es nevarētu saprast, ka, ja šis
ir pirmā vai otrā vai trešā programma

106
00:05:17,400 --> 00:05:18,830
ka es esmu faktiski padarot sevi.

107
00:05:18,830 --> 00:05:23,820
Tāpēc es esmu gatavojas iet uz priekšu un
veids, kas, int galvenais (spēkā neesošs).

108
00:05:23,820 --> 00:05:28,130
Un tad iekšā manas cirtaini bikšturi,
ļoti pazīstams ( "hello, world--

109
00:05:28,130 --> 00:05:30,980
reversā slīpsvītra, n ") - un semikolu.

110
00:05:30,980 --> 00:05:32,360
>> Esmu saglabājis failu.

111
00:05:32,360 --> 00:05:34,850
Tagad es esmu gatavojas iet uz leju
uz manu termināļa loga

112
00:05:34,850 --> 00:05:40,340
un tips make buggy0, jo, atkal,
nosaukums faila šodien ir buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Tāpēc es tipa darīt buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Un, ak, Dievs, atcerēties no pēdējo reizi
ka nav kļūdu ziņojumiem ir laba lieta.

115
00:05:48,200 --> 00:05:49,740
Līdz ar to nav izeja ir laba lieta.

116
00:05:49,740 --> 00:05:52,920
Bet šeit man ir skaidri
daži skaits kļūdām.

117
00:05:52,920 --> 00:05:56,470
>> Tātad pirmajā rindā produkcijas
pēc rakstīt padarīt buggy0, atgādināt,

118
00:05:56,470 --> 00:05:59,540
ir šķindēt ir diezgan runīgs produkciju.

119
00:05:59,540 --> 00:06:02,067
Zem motora pārsega,
CS50 IDE ir konfigurēts

120
00:06:02,067 --> 00:06:04,150
izmantot visu ķekars
iespējas ar šo kompilatoru

121
00:06:04,150 --> 00:06:05,941
tā, ka jums nav
domāt par tiem.

122
00:06:05,941 --> 00:06:08,840
Un tas ir viss, kas pirmajā rindā
līdzekļi, kas sākas ar šķindēt.

123
00:06:08,840 --> 00:06:11,720
>> Bet pēc tam, problēmas
sāk veikt savu izskatu.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c on line 3, raksturs
5, ir liels, sarkans kļūda.

125
00:06:17,390 --> 00:06:18,380
Kas tas ir?

126
00:06:18,380 --> 00:06:23,562
Netieši atzīstot bibliotēka funkciju
printf ar tipa int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Es domāju, ka ir ļoti ātri
kļūst ļoti arcane.

129
00:06:28,379 --> 00:06:30,170
Un, protams, vispirms
skatienu, mēs nebūtu

130
00:06:30,170 --> 00:06:32,380
sagaida, lai jūs saprastu
kopums šo ziņu.

131
00:06:32,380 --> 00:06:34,213
Un tā viena no mācībām
par šodien notiek

132
00:06:34,213 --> 00:06:36,919
būt mēģināt pamanīt
modeļus, vai līdzīgas lietas,

133
00:06:36,919 --> 00:06:38,960
kļūdas jums varētu būt
radušās pagātnē.

134
00:06:38,960 --> 00:06:41,335
Tātad, pieņemsim kaitināt intervālu tikai
šie vārdi, kas izskatās pazīstami.

135
00:06:41,335 --> 00:06:44,290
Liels, sarkans kļūda ir skaidri
simbolizē kaut ko ir nepareizi.

136
00:06:44,290 --> 00:06:47,940
>> netieši deklarējot
bibliotēkas funkciju printf.

137
00:06:47,940 --> 00:06:51,680
Tātad, pat ja man nav gluži saprast, ko
netieši atzīstot bibliotēka funkciju

138
00:06:51,680 --> 00:06:54,900
līdzekļiem, problēma noteikti
saistīts ar printf kaut kā.

139
00:06:54,900 --> 00:06:59,130
Un avots šajā jautājumā
ir saistīts ar to deklarējot.

140
00:06:59,130 --> 00:07:02,440
>> Pasludināšana funkcija ir
minot to pirmo reizi.

141
00:07:02,440 --> 00:07:06,210
Un mēs izmantojām terminoloģiju pagājušajā nedēļā
deklarēt funkcija ir prototips,

142
00:07:06,210 --> 00:07:11,860
nu ar vienu līniju augšpusē jūsu
pašu failu vai ts header failu.

143
00:07:11,860 --> 00:07:15,300
Un tas, ko fails darīja mēs sakām
pagājušajā nedēļā, ka printf ir citāts,

144
00:07:15,300 --> 00:07:17,080
likt pēdiņas beigās, paziņoja?

145
00:07:17,080 --> 00:07:20,950
Kādā fails ir tā prototips?

146
00:07:20,950 --> 00:07:24,640
>> Tātad, ja jūs atceraties, pati pirmā lieta, ko es
drukāti, gandrīz katrs programma pagājušajā LAIKU_

147
00:07:24,640 --> 00:07:30,790
un nejauši pirms brīža sākās
ierakstot myself-- bija tas viens here--

148
00:07:30,790 --> 00:07:38,630
hash-- # Ietvert <stio-- par
ievades / output-- dot h Un tiešām,

149
00:07:38,630 --> 00:07:41,860
ja es tagad saglabājiet šo failu, es eju
iet uz priekšu un iztīrītu ekrānu,

150
00:07:41,860 --> 00:07:44,740
ko jūs varat darīt, ierakstot
Skaidrs, vai jūs varat turēt Control L,

151
00:07:44,740 --> 00:07:47,680
tikai, lai skaidrs jūsu termināļa logu
tikai, lai novērstu kādu jucekli.

152
00:07:47,680 --> 00:07:51,370
>> Es iešu uz priekšu un
re-veida make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Un voila, es joprojām redzu, ka
garš komandu no šķindēt,

154
00:07:53,790 --> 00:07:55,470
bet tur nav kļūdas ziņojums šoreiz.

155
00:07:55,470 --> 00:07:58,800
Un tiešām, ja man ./buggy0,
tāpat kā pēdējo reizi,

156
00:07:58,800 --> 00:08:01,860
kur dot nozīmē, ka šis
katalogs, Slash tikai nozīmē,

157
00:08:01,860 --> 00:08:05,040
šeit nāk nosaukums programmas un
ka programmas nosaukums ir buggy0,

158
00:08:05,040 --> 00:08:07,340
Enter, "Hello, World".

159
00:08:07,340 --> 00:08:09,440
>> Tagad, kā varētu jums
gūta šo risinājumu

160
00:08:09,440 --> 00:08:12,017
ne vienmēr
atzīstot, jo daudzi vārdi

161
00:08:12,017 --> 00:08:14,350
kā es darīju, protams, kam
izdarījusi tik daudzus gadus?

162
00:08:14,350 --> 00:08:18,720
Nu, saproti, par pirmo problēmu
komplekts, mēs jūs iepazīstināt ar komandu

163
00:08:18,720 --> 00:08:21,175
ka CS50 paša darbiniekiem
rakstīja sauc help50.

164
00:08:21,175 --> 00:08:24,300
Un tiešām, C dara specifikācija
problēma noteikti par to, kā izmantot šo.

165
00:08:24,300 --> 00:08:27,210
>> Bet help50 būtībā
programma, kas CS50 personālam

166
00:08:27,210 --> 00:08:30,850
rakstīja, ka ļauj darbināt
komandu vai palaist programmu,

167
00:08:30,850 --> 00:08:36,169
un, ja jūs nesaprotat tās
izeja, nodot savu produkciju help50,

168
00:08:36,169 --> 00:08:38,890
kurā brīdī programmatūru
ka kurss personālam rakstīja

169
00:08:38,890 --> 00:08:42,429
apskatīsim jūsu programmas izejas
pozīcijai, raksturs ar raksturu.

170
00:08:42,429 --> 00:08:46,000
Un, ja mēs, darbinieki, atzīt
kļūdas ziņojums, ka jūs piedzīvo,

171
00:08:46,000 --> 00:08:50,580
mēs centīsimies provocēt jūs ar dažiem
retoriski jautājumi, ar kādu padomu,

172
00:08:50,580 --> 00:08:54,890
līdzīgi TF vai CA vai sevi
darītu personīgi darba laika.

173
00:08:54,890 --> 00:08:58,320
>> Tā izskatās uz help50 ja jums nav
vienmēr atzīst problēmu.

174
00:08:58,320 --> 00:09:00,790
Bet nav paļauties uz to
pārāk daudz kā kruķi.

175
00:09:00,790 --> 00:09:03,990
Protams mēģināt saprast savu
produkcija un pēc tam mācīties no tā

176
00:09:03,990 --> 00:09:07,571
tā, ka tikai vienu vai divas reizes darīt jums
kādreiz palaist help50 par konkrētu kļūda

177
00:09:07,571 --> 00:09:08,070
ziņa.

178
00:09:08,070 --> 00:09:10,660
Pēc tam, jums vajadzētu būt
labāk sevi

179
00:09:10,660 --> 00:09:13,180
lai noskaidrotu, kas tas patiesībā ir.

180
00:09:13,180 --> 00:09:14,350
>> Darīsim vienu otru šeit.

181
00:09:14,350 --> 00:09:20,410
Ļaujiet man iet uz priekšu, un citā
fails mēs saucam par buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Un šajā failā es esmu
gatavojas deliberately--

183
00:09:23,110 --> 00:09:26,330
bet izlikties, ka man nav
saprast, ko kļūda es esat veikuši.

184
00:09:26,330 --> 00:09:31,420
>> Es iešu uz priekšu un darīt this--
#include, jo es esmu

185
00:09:31,420 --> 00:09:33,660
uzzināja mana mācība no pirms brīža.

186
00:09:33,660 --> 00:09:36,220
Int galvenais (spēkā neesošs), kā iepriekš.

187
00:09:36,220 --> 00:09:40,880
Un tad šeit es esmu,
darīt virknes s - get_string.

188
00:09:40,880 --> 00:09:43,770
Un atsauktu no pēdējo reizi, ka
Tas nozīmē, hey, dators,

189
00:09:43,770 --> 00:09:48,280
man mainīgo, sauc to s, un
padara šo mainīgo ir virkne veidu

190
00:09:48,280 --> 00:09:50,150
lai es varētu glabāt vienu vai vairākus vārdus tajā.

191
00:09:50,150 --> 00:09:52,191
>> Un tad uz labās rokas
pusē vienādības zīmi

192
00:09:52,191 --> 00:09:54,980
ir get_string, kas ir
funkcija CS50 bibliotēkā

193
00:09:54,980 --> 00:09:55,980
kas dara tieši tā.

194
00:09:55,980 --> 00:09:59,740
Tā izpaužas funkciju un pēc tam
rokas no labās uz kreiso pusi.

195
00:09:59,740 --> 00:10:02,670
Tātad tas vienādības zīmi nenozīmē
"Vienāds", kā mēs varētu domāt math.

196
00:10:02,670 --> 00:10:04,750
Tas nozīmē uzdevumu no labās uz kreiso pusi.

197
00:10:04,750 --> 00:10:09,640
Tātad tas nozīmē, veikt virkni no
lietotājam un uzglabāt to iekšpusē s.

198
00:10:09,640 --> 00:10:10,460
>> Tagad to izmantot.

199
00:10:10,460 --> 00:10:13,820
Ļaujiet man iet uz priekšu tagad un kā otro
line, ļaujiet man iet uz priekšu un saka "hello" -

200
00:10:13,820 --> 00:10:19,330
nevis "pasaule", bet "hello,% s--
kas ir mūsu vietturis, komats s,

201
00:10:19,330 --> 00:10:22,030
kas ir mūsu mainīgs,
un tad semikolu.

202
00:10:22,030 --> 00:10:26,070
Tātad, ja man nav screw up pārāk daudz
šeit, tas izskatās pareizs kodu.

203
00:10:26,070 --> 00:10:28,090
>> Un mani instinkti tagad ir apkopot to.

204
00:10:28,090 --> 00:10:30,400
Fails sauc buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Tāpēc es esmu gatavojas darīt darīt buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Un darn-tas, ja nav
pat vairāk kļūdas nekā iepriekš.

207
00:10:36,377 --> 00:10:38,210
Es domāju, tur ir vairāk
kļūdu ziņojumi Būtu

208
00:10:38,210 --> 00:10:40,400
likties nekā faktiskās līniju šajā programmā.

209
00:10:40,400 --> 00:10:42,730
>> Bet takeaway šeit ir,
pat tad, ja jūs esat nomākti

210
00:10:42,730 --> 00:10:45,040
ar divām vai trīs vai
vēl četri kļūdu ziņojumus,

211
00:10:45,040 --> 00:10:48,340
koncentrēties vienmēr ļoti
Pirmais no šiem ziņojumiem.

212
00:10:48,340 --> 00:10:52,220
Aplūkojot visvairāk top-one,
ritināšanu atpakaļ uz augšu, kā tas būtu nepieciešams.

213
00:10:52,220 --> 00:10:53,930
Tātad, šeit es drukāti make buggy1.

214
00:10:53,930 --> 00:10:55,700
Lūk, kas šķindēt produkciju, kā gaidīts.

215
00:10:55,700 --> 00:10:57,290
>> Un šeit ir pirmais sarkanais kļūda.

216
00:10:57,290 --> 00:11:02,370
Izmantot nedeklarēto identifikatora
string, tomēr es domāju standartu?

217
00:11:02,370 --> 00:11:04,260
Tātad standartu ir
tiešām kaut kas cits.

218
00:11:04,260 --> 00:11:06,240
Tas attiecas uz lietotāja
tastatūra, būtībā.

219
00:11:06,240 --> 00:11:08,080
>> Bet tas nav tas, ko es gribēju.

220
00:11:08,080 --> 00:11:11,770
Es nozīmēja virkni, un es gribēju get_string.

221
00:11:11,770 --> 00:11:16,200
Tātad, kas ir tas, ka es
aizmirsu darīt šoreiz?

222
00:11:16,200 --> 00:11:20,230
Kas trūkst šoreiz?

223
00:11:20,230 --> 00:11:23,600
Man ir mana # include,
tāpēc man ir pieeja printf.

224
00:11:23,600 --> 00:11:26,090
>> Bet ko man nav
piekļuve tikai vēl?

225
00:11:26,090 --> 00:11:29,420
Nu, tāpat kā pēdējo reizi,
Man vajag pateikt kompilators

226
00:11:29,420 --> 00:11:31,691
Šķindēt ko šie funkcijas.

227
00:11:31,691 --> 00:11:33,940
Get_string nenāk
ar C un, jo īpaši, to

228
00:11:33,940 --> 00:11:38,160
nav nonākt
header failu,.

229
00:11:38,160 --> 00:11:40,770
Tā vietā nāk
kaut darbinieki rakstīja,

230
00:11:40,770 --> 00:11:44,176
kas ir atšķirīgs fails
nosaukt bet trāpīgi nosaukts.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Tik vienkārši, piebilstot, ka vienā rindā
no code-- atsaukšanu no pēdējo reizi

233
00:11:50,861 --> 00:11:53,610
ka tad, kad šķindēt iet, tas notiek
apskatīt manu kodu augšas uz apakšu,

234
00:11:53,610 --> 00:11:54,193
kreisās uz labo.

235
00:11:54,193 --> 00:11:57,200
Tas notiek, lai paziņojuma,
ak, jūs vēlaties.

236
00:11:57,200 --> 00:11:59,900
Ļaujiet man iet un atrast, ka,
kur tas ir uz servera,

237
00:11:59,900 --> 00:12:03,090
kopēt un ielīmēt to, būtībā,
uz augšu savu failu

238
00:12:03,090 --> 00:12:06,820
tā ka šajā brīdī stāsts,
līnija 1, pārējā programmas

239
00:12:06,820 --> 00:12:11,651
var, protams, izmantot kādu no funkcijām
tajā, starp tiem get_string.

240
00:12:11,651 --> 00:12:13,650
Tāpēc es esmu gatavojas ignorēt
pārējā šīm kļūdām,

241
00:12:13,650 --> 00:12:17,190
jo es, protams, ir aizdomas, ka tikai
pirmā patiešām vienaldzīgs.

242
00:12:17,190 --> 00:12:20,780
Un es iešu uz priekšu un atkārto,
pēc glābšanas manu failu padarīt buggy1.

243
00:12:20,780 --> 00:12:22,580
Un voila, tas bija darbs.

244
00:12:22,580 --> 00:12:29,200
Un, ja man ./buggy1 un ierakstiet, lai
piemēram, Zamyla, es tagad saņems hello,

245
00:12:29,200 --> 00:12:32,000
Zamyla, nevis sveiki, pasaule.

246
00:12:32,000 --> 00:12:32,550
>> Viss kārtībā.

247
00:12:32,550 --> 00:12:35,890
Tātad takeaways šeit, tad ir,
viens, mēģiniet salasīt tik daudz, kā jūs varat

248
00:12:35,890 --> 00:12:39,140
No kļūdu ziņojumus tikai, skatoties
dažas no atpazīstami vārdi.

249
00:12:39,140 --> 00:12:43,070
Lieguma ka, izmantojiet help50 vienu
problēma noteikti specifikāciju.

250
00:12:43,070 --> 00:12:46,500
Bet liegumu, ka pārāk, vienmēr izskatās
augšējā kļūdas tikai, vismaz

251
00:12:46,500 --> 00:12:50,051
Sākotnēji, lai redzētu, kāda informācija
tas tiešām var dot.

252
00:12:50,051 --> 00:12:52,300
Bet izrādās, tur ir
vēl vairāk funkcionalitāti būvēts

253
00:12:52,300 --> 00:12:55,030
uz CS50 bibliotēkā, lai palīdzētu
tu agri semestrī

254
00:12:55,030 --> 00:12:57,580
un agri programmēšanā
izdomāt, kas notiek nepareizi.

255
00:12:57,580 --> 00:12:59,840
Tātad, pieņemsim darīt vēl viens piemērs šeit.

256
00:12:59,840 --> 00:13:04,350
Es esmu gatavojas, lai izsauktu šo buggy2, kas,
atkal tiks kļūdains out

257
00:13:04,350 --> 00:13:05,650
no vārtiem, ar dizainu.

258
00:13:05,650 --> 00:13:09,980
>> Un es iešu uz priekšu
un darīt # Ietvert.

259
00:13:09,980 --> 00:13:12,580
Un tad es esmu gatavojas darīt int galvenais (spēkā neesošs).

260
00:13:12,580 --> 00:13:14,840
Un tad es esmu gatavojas darīt, lai cilpu.

261
00:13:14,840 --> 00:13:16,690
Par (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i ir mazāks par vai vienāds ar 10.

263
00:13:18,750 --> 00:13:24,260
i ++, un tad cirtaini bikšturi, es eju
izdrukāt tikai hashtag simbols šeit

264
00:13:24,260 --> 00:13:25,920
un jauna līnija raksturs.

265
00:13:25,920 --> 00:13:29,220
>> Tāpēc mans nolūks šajā
Programma ir pavisam vienkārši

266
00:13:29,220 --> 00:13:33,150
atkārtot 10 reizes
un par katru atkārtojuma

267
00:13:33,150 --> 00:13:35,260
Minētās cilpa katru reizi
cauri ciklam,

268
00:13:35,260 --> 00:13:37,660
izdrukāt hashtag,
atsauces, tiek restītes.

269
00:13:37,660 --> 00:13:40,480
Viens per line jo I
ir jaunu līniju tur.

270
00:13:40,480 --> 00:13:42,787
Un atgādināt, ka par
cilpa, par pēdējo week--

271
00:13:42,787 --> 00:13:44,620
un jūs saņemsiet vairāk
iepazinušies ar sintaksi

272
00:13:44,620 --> 00:13:47,170
, izmantojot to ar praksi
pirms long-- tas dod man

273
00:13:47,170 --> 00:13:49,740
mainīgs sauc i un nosaka to līdz 0.

274
00:13:49,740 --> 00:13:52,650
>> Šī pieauguma soli i uz
katru atkārtojuma par 1.

275
00:13:52,650 --> 00:13:54,940
Tātad man iet ar 1, 2 vai 3.

276
00:13:54,940 --> 00:13:57,690
Un tad šis nosacījums
vidu starp semikoliem

277
00:13:57,690 --> 00:14:03,010
izpaužas pārbauda katra atkārtojuma, lai padarītu
pārliecināts, ka mēs joprojām diapazonā.

278
00:14:03,010 --> 00:14:06,830
Tāpēc es gribu atkārtot 10 reizes, tāpēc es
ir sava veida ļoti intuitīvi vienkārši

279
00:14:06,830 --> 00:14:09,070
likts 10 kā mana augšējo robežu tur.

280
00:14:09,070 --> 00:14:14,310
>> Un tomēr, kad es palaist to, pēc
apkopojot to ar marku buggy2--

281
00:14:14,310 --> 00:14:15,440
un tas apkopo OK.

282
00:14:15,440 --> 00:14:17,980
Tāpēc man nav
sintakses kļūda šoreiz.

283
00:14:17,980 --> 00:14:20,940
Ļaujiet man iet uz priekšu tagad
un palaist buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Un tagad ritiniet uz augšu.

285
00:14:22,620 --> 00:14:24,890
Un ļaujiet man paaugstināt
izmērs no loga.

286
00:14:24,890 --> 00:14:33,720
>> Man šķiet, ir 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Tātad tur ir 11 atsauces, lai gan
Es skaidri izvirzīti 10 iekšpusē šīs cilpas.

288
00:14:38,891 --> 00:14:42,140
Tagad daži no jums varētu redzēt uzreiz
kāda kļūda ir tāpēc, ka, protams, šis

289
00:14:42,140 --> 00:14:43,720
nav ļoti grūti kļūda, lai padarītu.

290
00:14:43,720 --> 00:14:46,070
Bet tas ir ļoti bieži
izgatavoti ļoti agri.

291
00:14:46,070 --> 00:14:49,820
>> Ko es vēlos norādīt, lai gan,
ir, kā es varētu skaitlis šo out?

292
00:14:49,820 --> 00:14:52,300
Nu, izrādās, ka
CS50 Bibliotēka nāk

293
00:14:52,300 --> 00:14:55,380
ar ne tikai get_string un get_int
un get_float un citas funkcijas.

294
00:14:55,380 --> 00:14:59,980
Tas arī nāk ar īpašu funkciju
sauc eprintf, vai kļūda printf.

295
00:14:59,980 --> 00:15:03,270
Un tā pastāv tikai, lai padarītu
tā mazliet vieglāk jums

296
00:15:03,270 --> 00:15:06,310
kad atkļūdošana savu kodu, lai tikai
izdrukāt kļūdas paziņojumu uz ekrāna

297
00:15:06,310 --> 00:15:07,850
un zina, kur tas bija no.

298
00:15:07,850 --> 00:15:11,000
>> Tā, piemēram, viena lieta, ko es varētu
izdarīt šeit ar šī funkcija ir this--

299
00:15:11,000 --> 00:15:20,230
eprintf, un tad es iešu uz priekšu
un teikt, es tagad% i, slīpsvītra, n.

300
00:15:20,230 --> 00:15:22,330
Un es esmu gatavojas, lai kontaktdakšu vērtības i.

301
00:15:22,330 --> 00:15:25,400
Un up top, jo tas
atrodas CS50 bibliotēkā,

302
00:15:25,400 --> 00:15:27,580
Es iešu uz priekšu
un ietver

303
00:15:27,580 --> 00:15:29,169
tāpēc man ir pieeja šai funkcijai.

304
00:15:29,169 --> 00:15:31,460
Bet pieņemsim apsvērt, kādi līnija
9 ir vajadzēja darīt.

305
00:15:31,460 --> 00:15:32,670
Es esmu gatavojas, lai izdzēstu šo galu galā.

306
00:15:32,670 --> 00:15:34,670
Šī nav nekāda sakara
ar manu vispārējo mērķi.

307
00:15:34,670 --> 00:15:39,090
Bet eprintf, kļūda printf, ir tikai domāts
sniegt man kādu diagnostikas informāciju.

308
00:15:39,090 --> 00:15:42,460
Kad es palaist savu programmu, es gribu
redzēt šo uz ekrāna īslaicīgi

309
00:15:42,460 --> 00:15:44,550
kā arī vienkārši, lai saprastu
kas notiek.

310
00:15:44,550 --> 00:15:47,330
>> Un, protams, par katru
atkārtojuma šeit 9. līnijas

311
00:15:47,330 --> 00:15:49,260
Es gribu redzēt, kāda ir vērtība i?

312
00:15:49,260 --> 00:15:50,290
Kāda ir vērtība i?

313
00:15:50,290 --> 00:15:51,280
Kāda ir vērtība i?

314
00:15:51,280 --> 00:15:55,650
Un, cerams, es būtu tikai
redzēt, ka ziņu, arī 10 reizes.

315
00:15:55,650 --> 00:15:57,780
>> Tāpēc ļaujiet man iet uz priekšu un
recompile savu programmu,

316
00:15:57,780 --> 00:15:59,905
kā man ir jādara jebkurā laikā
Es veikt izmaiņas. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Un now-- OK.

319
00:16:03,640 --> 00:16:04,820
Tur ir daudz vairāk notiek.

320
00:16:04,820 --> 00:16:07,610
Tāpēc ļaujiet man ritiniet uz augšu
vēl lielāks logs.

321
00:16:07,610 --> 00:16:10,190
>> Un jūs redzēsiet, ka katrs
Atsauces, joprojām drukā.

322
00:16:10,190 --> 00:16:15,270
Bet starp katru no viņiem tagad ir šis
diagnostikas izejas formatēti šādi.

323
00:16:15,270 --> 00:16:17,960
Par manu programmu šeit vārds ir buggy2.

324
00:16:17,960 --> 00:16:20,432
No faila nosaukums ir buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Līnija numurs, no kura
tas bija iespiests ir līnija 9.

326
00:16:24,080 --> 00:16:27,500
Un pēc tam pa labi, ka ir
kļūdas ziņojums, ka es esmu gaidījis.

327
00:16:27,500 --> 00:16:30,701
>> Un, kas ir jauka par šo ir tas, ka
tagad man nav obligāti skaitīt

328
00:16:30,701 --> 00:16:32,200
manā galvā, ko mana programma dara.

329
00:16:32,200 --> 00:16:34,240
Es redzu, ka par
Pirmo atkārtojumu i ir 0,

330
00:16:34,240 --> 00:16:39,420
pēc tam 1, tad 2, tad 3, tad 4, tad
5, tad 6, tad 7, pēc tam 8, tad 9, tad

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Tātad pagaidiet minūti.

333
00:16:42,050 --> 00:16:43,740
Kas te notiek?

334
00:16:43,740 --> 00:16:48,190
Man joprojām šķiet, skaitot
kā paredzēts līdz 10.

335
00:16:48,190 --> 00:16:50,550
>> Bet kur gan es sākt?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Tātad, ir 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- kā 11. pirksts

338
00:16:58,040 --> 00:16:59,990
liecina par problēmu.

339
00:16:59,990 --> 00:17:02,850
Man šķiet, ir skaitītas
nepareizi manā cilpa.

340
00:17:02,850 --> 00:17:06,599
Nevis iet 10 iterācijas,
Es esmu sāk 0,

341
00:17:06,599 --> 00:17:09,550
Es esmu beidzot un līdz 10.

342
00:17:09,550 --> 00:17:12,030
Bet tāpēc, ka, piemēram, dators,
Es esmu sāk skaitīšanu 0,

343
00:17:12,030 --> 00:17:15,250
Es būtu skaitīs
to, bet ne caur, 10.

344
00:17:15,250 --> 00:17:18,510
>> Un tā fix, es beidzot
šeit sapratu, ir viena no divām lietām.

345
00:17:18,510 --> 00:17:22,430
Es varētu ļoti vienkārši pateikt
skaita līdz mazāk nekā 10.

346
00:17:22,430 --> 00:17:27,260
Tātad, ir 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, kas ir, protams, pareizi,

347
00:17:27,260 --> 00:17:28,900
kaut arī tas izklausās mazliet nepareizi.

348
00:17:28,900 --> 00:17:35,070
Vai es varētu darīt, ir mazāks vai vienāds
līdz 9. punktam, tik ilgi, kamēr es sāktu pie 0.

349
00:17:35,070 --> 00:17:40,056
Vai, ja jūs tiešām nepatīk, ka jums
var saskaitīt pa 10, bet sākas 1.

350
00:17:40,056 --> 00:17:41,680
Bet atkal, tas vienkārši nav tik bieži.

351
00:17:41,680 --> 00:17:43,977
In programming-- kaut arī
ne tik daudz Scratch--

352
00:17:43,977 --> 00:17:45,810
bet plānošanu
C un citās valodās,

353
00:17:45,810 --> 00:17:47,670
piemēram, JavaScript un
Python un citi, tas ir

354
00:17:47,670 --> 00:17:49,880
tikai ļoti bieži
Mūsu diskusija bināro

355
00:17:49,880 --> 00:17:53,450
lai tikai sāktu skaitot pie
Vismazāk jūs varat, kas ir 0.

356
00:17:53,450 --> 00:17:53,950
Viss kārtībā.

357
00:17:53,950 --> 00:17:55,160
Tātad tas ir eprintf.

358
00:17:55,160 --> 00:17:58,600
Un atkal, tagad, ka es esmu sapratu, mana
problēma, un es esmu gatavojas doties atpakaļ uz 0

359
00:17:58,600 --> 00:18:01,470
izmantojot mazāk nekā 10, es esmu gatavojas
iet un dzēst eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Tā nedrīkst būt tur, kad es
kuģis savu kodu vai iesniegt savu kodu

361
00:18:04,580 --> 00:18:05,800
vai parādīt to nevienam citam.

362
00:18:05,800 --> 00:18:07,980
Tas ir patiešām vienkārši domāts
uz laiku tiek izmantots.

363
00:18:07,980 --> 00:18:11,650
Bet tagad es esmu fiksēts šis
Īpaša problēma, kā arī.

364
00:18:11,650 --> 00:18:16,780
>> Nu, pieņemsim darīt vēl vienu piemēru šeit
ka es esmu gatavojas sakult šādi.

365
00:18:16,780 --> 00:18:22,850
Es iešu uz priekšu un
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
Un es iešu uz priekšu
un #include.

367
00:18:25,580 --> 00:18:29,030
>> Un es esmu gatavojas, lai saglabātu
šis fails kā buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Un es iešu uz priekšu
un deklarēt int galvenais (spēkā neesošs).

369
00:18:31,740 --> 00:18:34,186
Un tad iekšā tur
Es esmu gatavojas darīt int i _ -

370
00:18:34,186 --> 00:18:36,435
Es gribu, lai īstenotu programmu
ar get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Tas nav funkcija, kas eksistē vēl.

373
00:18:40,770 --> 00:18:42,870
Tātad mēs ejam, lai īstenotu
tas tikai brīdi.

374
00:18:42,870 --> 00:18:45,541
Bet mēs ejam, lai redzētu, kāpēc
tas ir buggy pirmajā caurlaide.

375
00:18:45,541 --> 00:18:47,290
Un, kad es esmu gotten
int no lietotāja,

376
00:18:47,290 --> 00:18:53,365
Es esmu tikai gatavojas drukāt% i ir negatīvs
skaitlis, slīpsvītru, n, komats, i.

377
00:18:53,365 --> 00:18:55,240
Citiem vārdiem sakot, viss, ko es
vēlas šo programmu darīt

378
00:18:55,240 --> 00:18:58,000
ir iegūt negatīvu int no
lietotājs un pēc tam izdrukāt

379
00:18:58,000 --> 00:18:59,980
ka tāds un tāds ir negatīvs int.

380
00:18:59,980 --> 00:19:02,080
>> Tagad man ir nepieciešams, lai īstenotu šo funkciju.

381
00:19:02,080 --> 00:19:05,740
Tik vēlāk manā failu, es iešu
priekšu un atzīt funkciju sauc

382
00:19:05,740 --> 00:19:10,670
get_negative_int (spēkā neesošs) - un mēs
nāk atpakaļ uz to, ka līnija nozīmē jauna

383
00:19:10,670 --> 00:19:18,790
tādā moment-- int n; do-- do
following-- printf n ir :.

384
00:19:18,790 --> 00:19:26,210
Un tad es esmu gatavojas darīt n - get_int,
un izdarīt, bet n ir lielāks par 0.

385
00:19:26,210 --> 00:19:28,310
Un pēc tam atgriezties n ;.

386
00:19:28,310 --> 00:19:31,730
>> Tātad tur ir daudz notiek
šo, bet neviens no tiem mēs neesam

387
00:19:31,730 --> 00:19:33,710
apskatīt pagājušajā nedēļā, vismaz īsumā.

388
00:19:33,710 --> 00:19:36,980
Tātad on line 10 šeit es esmu deklarēta
funkcija sauc get_negative_int,

389
00:19:36,980 --> 00:19:39,620
un es esmu likts (spēkā neesošs), jo
iekavas, iemesls ir tas

390
00:19:39,620 --> 00:19:40,950
neņem savu ieguldījumu.

391
00:19:40,950 --> 00:19:42,910
Es neesmu iet neko
šai funkcijai.

392
00:19:42,910 --> 00:19:44,690
Es esmu tikai iegūt kaut ko atpakaļ no tā.

393
00:19:44,690 --> 00:19:47,270
>> Un ko es esmu cerot, lai
nokļūt atpakaļ ir vesels skaitlis.

394
00:19:47,270 --> 00:19:50,040
Nav datu tips
C sauc negative_int.

395
00:19:50,040 --> 00:19:52,880
Tas ir tikai int, tāpēc tas notiek
būt par mums, lai pārliecinātos,

396
00:19:52,880 --> 00:19:55,340
ka vērtība, kas ir faktiski
Atgriezās ir ne tikai int

397
00:19:55,340 --> 00:19:56,380
bet ir arī negatīva.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 Es esmu deklarējot mainīgo
sauc n un padarot to int tipa.

399
00:20:02,150 --> 00:20:07,500
Un tad atbilstoši 13. līdz 18. Esmu
darot kaut ko, bet kaut kas ir patiess.

400
00:20:07,500 --> 00:20:11,040
Es dodos uz priekšu un drukāšana
n ir, resnās zarnas, un pēc tam telpa,

401
00:20:11,040 --> 00:20:12,800
kā uzvednes lietotājam.

402
00:20:12,800 --> 00:20:16,410
>> Es tad zvana get_int un
uzglabāt savu tā saukto atgriezto vērtību

403
00:20:16,410 --> 00:20:18,130
šajā mainīgo n.

404
00:20:18,130 --> 00:20:22,600
Bet es esmu gatavojas, lai saglabātu darot
šis kamēr n ir lielāks par 0.

405
00:20:22,600 --> 00:20:27,960
Citiem vārdiem sakot, ja lietotājs dod man
int un šis numurs ir lielāks par 0,

406
00:20:27,960 --> 00:20:31,180
ergo, pozitīvs, es esmu gatavojas
tikai glabāt reprompting lietotājam,

407
00:20:31,180 --> 00:20:37,160
glabāt reprompting, piespiežot viņus
sadarboties un sniegt man negatīvu int.

408
00:20:37,160 --> 00:20:41,640
>> Un, kad n ir faktiski negative--
pieņemsim lietotājs beidzot veidi -50,

409
00:20:41,640 --> 00:20:46,710
tad šī kamēr cilpa vairs nav taisnība
jo -50 ir ne lielāka par 0.

410
00:20:46,710 --> 00:20:51,140
Tātad, mēs izkļūt no ka
cilpa loģiski un atgriezties n.

411
00:20:51,140 --> 00:20:53,520
>> Bet tur ir viens cits
lieta man ir jādara.

412
00:20:53,520 --> 00:20:56,190
Un es varu vienkārši darīt
ko kopējot un ielīmējot

413
00:20:56,190 --> 00:20:58,540
viena līnija koda augšpusē faila.

414
00:20:58,540 --> 00:21:01,630
Man vajag, lai mācītu šķindēt,
vai sola šķindēt,

415
00:21:01,630 --> 00:21:04,630
skaidri, ka es gribu,
tiešām, iet un īstenot

416
00:21:04,630 --> 00:21:06,020
šī funkcija get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Tā var tikai būt zemāka failā.

418
00:21:07,674 --> 00:21:09,840
Atkal, atgādināt, ka šķindēt
skan lietas augšas uz leju,

419
00:21:09,840 --> 00:21:12,330
kreisās uz labo, lai jūs nevarat
zvanu funkciju, ja šķindēt

420
00:21:12,330 --> 00:21:15,330
nezina tas notiek pastāvēt.

421
00:21:15,330 --> 00:21:18,430
>> Tagad, diemžēl, šī programma,
kā daži no jums varētu būt pamanījuši,

422
00:21:18,430 --> 00:21:19,590
ir jau buggy.

423
00:21:19,590 --> 00:21:21,400
Ļaujiet man iet uz priekšu un darīt buggy3.

424
00:21:21,400 --> 00:21:26,904
Tā apkopo, lai mana problēma tagad nav
sintakses kļūdas, piemēram, teksta kļūdas,

425
00:21:26,904 --> 00:21:29,570
tas tiešām būs loģiska
kļūda, ka es esmu apzināti

426
00:21:29,570 --> 00:21:32,450
izgatavoti kā iespēja
soli pa to, kas notiek.

427
00:21:32,450 --> 00:21:35,540
>> Es iešu uz priekšu
tagad un palaist buggy3.

428
00:21:35,540 --> 00:21:37,490
Un es iešu
priekšu un nesadarbojas.

429
00:21:37,490 --> 00:21:39,494
Es esmu gatavojas sniegt tai numuru 1.

430
00:21:39,494 --> 00:21:41,410
Tas nepatika, tāpēc
tas pamudinot mani atkal.

431
00:21:41,410 --> 00:21:42,147
>> Kā par 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Neviens no tiem strādā.

435
00:21:44,740 --> 00:21:46,890
Kā par -50?

436
00:21:46,890 --> 00:21:48,560
Un programma, šķiet, darbojas.

437
00:21:48,560 --> 00:21:49,970
>> Ļaujiet man mēģināt to vēlreiz.

438
00:21:49,970 --> 00:21:53,400
Ļaujiet man mēģināt -1, šķiet, darbojas.

439
00:21:53,400 --> 00:21:56,380
Ļaujiet man mēģināt -2, šķiet, darbojas.

440
00:21:56,380 --> 00:21:59,640
Ļaujiet man mēģināt 0.

441
00:21:59,640 --> 00:22:01,684
Huh, tas ir nepareizi.

442
00:22:01,684 --> 00:22:03,350
Tagad mēs to mazliet pedantiska šeit.

443
00:22:03,350 --> 00:22:07,090
Bet tas, protams, ir gadījums, 0
nav ne pozitīvu, ne negatīvu.

444
00:22:07,090 --> 00:22:11,150
Un tā tas, ka mana programma
sakot, ka 0 ir negatīvs skaitlis,

445
00:22:11,150 --> 00:22:12,820
tas nav tehniski pareizi.

446
00:22:12,820 --> 00:22:15,180
>> Tagad, kāpēc tas ir to izdarīt?

447
00:22:15,180 --> 00:22:16,270
Nu, tas varētu būt skaidrs.

448
00:22:16,270 --> 00:22:18,110
Un, protams, programma ir
domāts, lai būtu diezgan vienkāršs

449
00:22:18,110 --> 00:22:19,670
tāpēc mums ir kaut kas, lai izpētītu.

450
00:22:19,670 --> 00:22:25,870
>> Bet pieņemsim ieviest trešo atkļūdošanu
paņēmiens šeit sauc debug50.

451
00:22:25,870 --> 00:22:27,750
Tāpēc tas ir programma
ka mēs tikko veikts

452
00:22:27,750 --> 00:22:30,770
šogad sauc debug50
kas ļaus jums

453
00:22:30,770 --> 00:22:34,130
izmantot to, ko sauc iebūvēts
grafiskā atkļūdotājs in CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Un atkļūdotājs ir tikai programma, kas
parasti ļauj palaist savu programmu

455
00:22:38,400 --> 00:22:44,050
bet soli pa soli pa solim, līnija
līdz pozīcijai, pauzes, poking

456
00:22:44,050 --> 00:22:47,626
apkārt, apskatot mainīgajiem, lai
programmā nav tikai trieciens pagātnes jums

457
00:22:47,626 --> 00:22:49,750
un ātri drukāt kaut ko
vai ne izdrukāt kaut ko.

458
00:22:49,750 --> 00:22:53,250
Tas dod jums iespēju, at
cilvēka ātrums, kas mijiedarbojas ar to.

459
00:22:53,250 --> 00:22:55,470
>> Un, lai to izdarītu, jums
vienkārši rīkoties šādi.

460
00:22:55,470 --> 00:22:58,479
Pēc apkopojot savu kodu,
ko es jau darīju, buggy3,

461
00:22:58,479 --> 00:23:00,020
jums iet uz priekšu un palaist debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Tik daudz, piemēram help50 ir palaist
help50 un tad komanda,

464
00:23:06,760 --> 00:23:10,120
debug50 ir palaist debug50 un
tad nosaukums komandu.

465
00:23:10,120 --> 00:23:14,440
>> Tagad skatīties, kas notiek uz mana ekrāna,
uz labajā pusē, jo īpaši.

466
00:23:14,440 --> 00:23:19,400
Kad es hit Izpildīt, visi
pēkšņi tas, labajā pusē

467
00:23:19,400 --> 00:23:20,419
paver uz ekrāna.

468
00:23:20,419 --> 00:23:22,210
Un tur ir daudz notiek
uz pirmā acu uzmetiena.

469
00:23:22,210 --> 00:23:25,110
Bet tur nav pārāk
daudz jāuztraucas par vēl.

470
00:23:25,110 --> 00:23:28,570
>> To rāda man visu
kas notiek iekšpusē manā programmā

471
00:23:28,570 --> 00:23:31,130
tieši tagad, un, izmantojot šos
pogas up top tad

472
00:23:31,130 --> 00:23:35,910
ļauj man soli pa manu kodu
galu galā soli pa soli pa solim.

473
00:23:35,910 --> 00:23:37,140
Bet ne tikai vēl.

474
00:23:37,140 --> 00:23:38,060
Paziņojums, kas notiek.

475
00:23:38,060 --> 00:23:40,600
Pēc mana termināļa logā
Es esmu tiek piedāvāts n.

476
00:23:40,600 --> 00:23:44,560
Un es iešu uz priekšu un
sadarboties šo laiku un ierakstiet -1.

477
00:23:44,560 --> 00:23:48,770
Un kaut arī nedaudz cryptically, -1
ir negatīvs skaitlis, kā gaidīts.

478
00:23:48,770 --> 00:23:52,020
>> Un tad bērns iziet ar
statuss 0 GDBserver iziešanas.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, ir nosaukums
pamatā esošā programmatūra

480
00:23:55,180 --> 00:23:56,620
kas īsteno šo atkļūdotājs.

481
00:23:56,620 --> 00:24:00,500
Bet tas viss īsti nozīmē, atkļūdotājs
devās prom, jo ​​mana programma atmest

482
00:24:00,500 --> 00:24:01,710
un viss bija labi.

483
00:24:01,710 --> 00:24:06,020
Ja es gribu, lai patiesi atkļūdot savu programmu,
Man ir preemptively pateikt debug50,

484
00:24:06,020 --> 00:24:08,920
kur vēlos sākt
pastiprināšanu, izmantojot manu kodu?

485
00:24:08,920 --> 00:24:11,750
>> Un varbūt vienkāršākais veids
to darīt, ir šāds.

486
00:24:11,750 --> 00:24:15,300
Ja es lidināties pār
noteka manas redaktors šeit,

487
00:24:15,300 --> 00:24:19,090
tik tiešām tikai sānjoslas šeit,
pa kreisi no līnijas numuru,

488
00:24:19,090 --> 00:24:21,870
Ievērojiet, ka, ja es vienkārši noklikšķiniet
vienu reizi, man mazliet sarkans dot.

489
00:24:21,870 --> 00:24:24,460
Un ka maz sarkans dot,
kā stop zīmi, nozīmē, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, pauze izpilde manu kodu
tieši tur, kad es palaist šo programmu.

491
00:24:29,430 --> 00:24:30,260
>> Tātad, pieņemsim darīt.

492
00:24:30,260 --> 00:24:37,340
Ļaujiet man iet uz priekšu un palaist savu programmu
atkal ar debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Un tagad, paziņojums, kaut
atšķirīgs ir noticis.

494
00:24:40,110 --> 00:24:42,440
Es neesmu tiek piedāvāts
vēl manā termināļa logā

495
00:24:42,440 --> 00:24:45,430
kaut ko, jo man nav
gotten tur vēl manā programmā.

496
00:24:45,430 --> 00:24:47,950
Ievērojiet, ka 8. līnijā
kas tagad iezīmēts,

497
00:24:47,950 --> 00:24:51,720
un tur ir maz bultiņa
kreisā sakot, jums ir apturēta šeit.

498
00:24:51,720 --> 00:24:55,030
Šī līnija kods, līnijas
8, vēl nav izpildīts.

499
00:24:55,030 --> 00:24:58,940
>> Un, kas ir ziņkārīgs, ja es paskatos
nekā šeit uz labajā pusē,

500
00:24:58,940 --> 00:25:03,530
paziņojums, ka man ir vietējais
mainīgs, vietējā tādā nozīmē,

501
00:25:03,530 --> 00:25:05,450
ka tas ir iekšā pašreizējās funkcijas.

502
00:25:05,450 --> 00:25:08,920
Un tā vērtība, acīmredzot pēc noklusējuma,
un veida ērti, ir 0.

503
00:25:08,920 --> 00:25:10,260
Bet man nav rakstīt 0.

504
00:25:10,260 --> 00:25:13,410
Tas vienkārši notiek, ir tā
Noklusētā vērtība brīdī.

505
00:25:13,410 --> 00:25:15,490
>> Tāpēc ļaujiet man iet uz priekšu un darīt to tagad.

506
00:25:15,490 --> 00:25:18,680
Ļaujiet man iet uz priekšu un uz
top tieši šeit, es esmu

507
00:25:18,680 --> 00:25:20,970
gatavojas iet uz priekšu un
noklikšķiniet uz šo pirmo ikonas, kas

508
00:25:20,970 --> 00:25:25,360
nozīmē soli pāri, kas nozīmē, nav izlaist
tas taču soli pa šo līniju kodu,

509
00:25:25,360 --> 00:25:27,770
izpildot to pa ceļam.

510
00:25:27,770 --> 00:25:30,710
>> Un tagad, paziņojums, mans
ātra tikko mainīts.

511
00:25:30,710 --> 00:25:31,380
Kāpēc ir tā, ka?

512
00:25:31,380 --> 00:25:33,639
Es esmu teicis debug50,
palaist šo rindiņu kodu.

513
00:25:33,639 --> 00:25:34,930
Ko tas līnija kods darīt?

514
00:25:34,930 --> 00:25:35,960
Liek man par int.

515
00:25:35,960 --> 00:25:36,460
LABI.

516
00:25:36,460 --> 00:25:37,400
Ļaujiet man sadarboties.

517
00:25:37,400 --> 00:25:41,340
Ļaujiet man iet uz priekšu tagad un -1 tips, Enter.

518
00:25:41,340 --> 00:25:42,920
Un tagad paziņojums, kas ir mainījies.

519
00:25:42,920 --> 00:25:46,060
No labajā pusē,
mana vietējo mainīgais i

520
00:25:46,060 --> 00:25:48,200
tiek norādīts kā -1 tagad.

521
00:25:48,200 --> 00:25:49,810
Un tas joprojām ir int tipa.

522
00:25:49,810 --> 00:25:53,102
>> Un paziņojums, arī mans tā sauktais
zvanu kaudze, no kurienes es pauzes?

523
00:25:53,102 --> 00:25:54,810
Mēs runājam vairāk par
tas nākotnē.

524
00:25:54,810 --> 00:25:58,620
Bet zvanu kaudze tieši norāda uz to,
funkcijas pašlaik kustībā.

525
00:25:58,620 --> 00:26:00,040
Šobrīd tas ir tikai galvenais.

526
00:26:00,040 --> 00:26:03,590
Un tieši tagad vienīgais vietējais
mainīgais ir tā, i ar vērtību 1.

527
00:26:03,590 --> 00:26:09,840
>> Un, kad es beidzot soli pa šo līniju
šeit, ar šo pašu ikonu augšējā labajā stūrī,

528
00:26:09,840 --> 00:26:11,410
-1 Ir negatīvs skaitlis.

529
00:26:11,410 --> 00:26:13,580
Tagad tas ir pauzēm pār šo cirtaini lencēm.

530
00:26:13,580 --> 00:26:14,740
Pieņemsim, ļaujiet to darīt lieta.

531
00:26:14,740 --> 00:26:17,300
Es soli pa šo līniju, un voila.

532
00:26:17,300 --> 00:26:20,240
>> Tāpēc ne viss, kas briesmīgi
informēts vēl,

533
00:26:20,240 --> 00:26:23,550
bet tas man pauze
un domāju, ka ar loģiski

534
00:26:23,550 --> 00:26:24,870
ko šī programma dara.

535
00:26:24,870 --> 00:26:26,890
Bet tas nebija kļūdains gadījums.

536
00:26:26,890 --> 00:26:28,510
Darīsim to atkal šādi.

537
00:26:28,510 --> 00:26:31,340
>> Es esmu gatavojas atstāt šo pārtraukumpunkts
8. Saskaņā ar sarkanu punktu.

538
00:26:31,340 --> 00:26:32,830
Es esmu gatavojas atkārto debug50.

539
00:26:32,830 --> 00:26:34,400
Tas automātiski apturēta šeit.

540
00:26:34,400 --> 00:26:37,660
Bet šis laiks, tā vietā, lai
kāpj pa šo līniju,

541
00:26:37,660 --> 00:26:42,290
ļaujiet man tiešām iet iekšā
get_negative_int un izdomāt,

542
00:26:42,290 --> 00:26:45,530
kāpēc ir tā, pieņemot 0 par derīgu atbildi?

543
00:26:45,530 --> 00:26:47,990
>> Tā vietā, noklikšķinot Step Over.

544
00:26:47,990 --> 00:26:50,630
Es iešu uz priekšu
un noklikšķiniet soli.

545
00:26:50,630 --> 00:26:54,030
Un paziņojums, ka līnija 8, kas ir
tagad uzsvēra tagad pēkšņi

546
00:26:54,030 --> 00:26:56,900
kļūst line 17.

547
00:26:56,900 --> 00:26:59,947
>> Tagad tas nav tik atkļūdotājs
ir izlaidis līnijas 14 un 15 un 16.

548
00:26:59,947 --> 00:27:01,780
Tas ir tikai tur nekas
lai parādītu jums tur.

549
00:27:01,780 --> 00:27:04,050
Tie ir tikai deklarējot mainīgos,
un tad tur ir vārds Do

550
00:27:04,050 --> 00:27:05,390
un tad atvērta cirtaini lencēm.

551
00:27:05,390 --> 00:27:09,227
Vienīgais funkcionāla līnija, kas ir
sulīgs tiešām tas ir viens šeit, 17.

552
00:27:09,227 --> 00:27:11,060
Un tas ir, ja mēs esam
apturēta automātiski.

553
00:27:11,060 --> 00:27:13,870
>> Tātad printf ( "n.is:") ;, tā
ka nav noticis vēl.

554
00:27:13,870 --> 00:27:18,250
So iesim uz priekšu un noklikšķiniet Step Over.

555
00:27:18,250 --> 00:27:20,326
Tagad mans ātru, patiešām,
mainīts uz ( "n ir:").

556
00:27:20,326 --> 00:27:22,450
Tagad get_int, es neesmu gatavojas
apgrūtināt pastiprināšanu,

557
00:27:22,450 --> 00:27:24,750
jo šī funkcija bija
, ko CS50 bibliotēkā.

558
00:27:24,750 --> 00:27:25,750
Tas ir iespējams, pareizi.

559
00:27:25,750 --> 00:27:28,440
>> Tāpēc es esmu gatavojas iet uz priekšu un
veida sadarbību, piešķirot tai

560
00:27:28,440 --> 00:27:30,590
int, bet ne negatīvs int.

561
00:27:30,590 --> 00:27:32,870
Tāpēc ļaujiet man iet uz priekšu un hit 0.

562
00:27:32,870 --> 00:27:39,460
Un tagad, kas notiek šeit
kad es nokļūt uz leju, lai līnija 21?

563
00:27:39,460 --> 00:27:40,890
Man nav vēlreiz jāatkārto.

564
00:27:40,890 --> 00:27:43,320
Man nav, šķiet, ir iestrēdzis šajā cilpa.

565
00:27:43,320 --> 00:27:45,990
Citiem vārdiem sakot, šis dzeltens
bar neturēja notiek apkārt,

566
00:27:45,990 --> 00:27:47,130
un apkārt, un apkārt.

567
00:27:47,130 --> 00:27:48,340
>> Tagad, kāpēc tā?

568
00:27:48,340 --> 00:27:49,920
Nu, n, kas ir n tieši tagad?

569
00:27:49,920 --> 00:27:53,280
Es varu apskatīt vietējā
mainīgie atkļūdotājs.

570
00:27:53,280 --> 00:27:53,816
n ir 0.

571
00:27:53,816 --> 00:27:55,190
Labi, kāds bija mans stāvoklis?

572
00:27:55,190 --> 00:27:58,700
>> 20-- līnija 20 ir labi,
0 ir lielāks par 0.

573
00:27:58,700 --> 00:27:59,500
Tas nav taisnība.

574
00:27:59,500 --> 00:28:01,020
0 ir ne lielāka par 0.

575
00:28:01,020 --> 00:28:02,820
Un tāpēc es izcēlās no šo.

576
00:28:02,820 --> 00:28:06,370
>> Un tā, ka tāpēc uz līnijas
21, ja es tiešām turpinās,

577
00:28:06,370 --> 00:28:10,370
Es esmu gatavojas atgriezties 0, pat
gan man vajadzēja noraidīt 0

578
00:28:10,370 --> 00:28:12,484
jo ne faktiski ir negatīvs.

579
00:28:12,484 --> 00:28:14,650
Tāpēc tagad, man nav īsti pat
rūp atkļūdotājs.

580
00:28:14,650 --> 00:28:16,900
Got to, man nav nepieciešams
zināt, kas vēl notiek.

581
00:28:16,900 --> 00:28:19,233
>> Tāpēc es esmu gatavojas iet uz priekšu un
vienkārši noklikšķiniet uz pogas Atskaņot,

582
00:28:19,233 --> 00:28:20,240
un ļaujiet šo pabeigt līdz.

583
00:28:20,240 --> 00:28:23,440
Tagad, es esmu sapratu, ka mans
bug ir acīmredzami uz līnijas 20.

584
00:28:23,440 --> 00:28:25,160
Tas ir mans loģiska kļūda.

585
00:28:25,160 --> 00:28:28,100
>> Un tā, ko es gribu
darīt, lai to mainītu?

586
00:28:28,100 --> 00:28:32,500
Ja problēma ir tā, ka es neesmu
tuvojas 0, tas ir tikai loģiska kļūda.

587
00:28:32,500 --> 00:28:35,910
Un es varu teikt, bet n ir
ir lielāks par vai vienāds ar 0,

588
00:28:35,910 --> 00:28:38,330
glabāt atkal un atkal pamudinot lietotājam.

589
00:28:38,330 --> 00:28:41,050
>> Tātad, atkal, vienkārši kļūda, varbūt
pat skaidrs, kad redzējāt mani

590
00:28:41,050 --> 00:28:42,410
uzrakstiet to tikai pirms dažām minūtēm.

591
00:28:42,410 --> 00:28:44,570
Bet takeaway šeit
ir tas, ka ar debug 50,

592
00:28:44,570 --> 00:28:46,850
un ar atkļūdošanu
programmatūra vispārīgāk,

593
00:28:46,850 --> 00:28:51,370
Jums ir šī jaunā atrasts strāvas padevi
staigāt pa savu kodu, meklēt

594
00:28:51,370 --> 00:28:55,590
izmantojot šo labajā panelī, ko
Jūsu mainīgie vērtības.

595
00:28:55,590 --> 00:28:57,700
Tātad jums nav obligāti
ir izmantot kaut ko

596
00:28:57,700 --> 00:29:00,630
kā jūs eprintf izdrukāt šīs vērtības.

597
00:29:00,630 --> 00:29:04,430
Jūs faktiski var redzēt
vizuāli uz ekrāna.

598
00:29:04,430 --> 00:29:08,920
>> Tagad aiz to, tas ir vērts atzīmēt
ka tur ir vēl viens paņēmiens, kas ir

599
00:29:08,920 --> 00:29:09,890
tiešām super bieži.

600
00:29:09,890 --> 00:29:13,120
Un jūs varētu brīnīties, kāpēc tas maz
puisis šeit ir sēdējis uz skatuves.

601
00:29:13,120 --> 00:29:16,490
Tātad tur ir šī metode, kas parasti
pazīstams kā gumijas pīles debugging,

602
00:29:16,490 --> 00:29:18,786
kas patiešām ir tikai
derība ar to,

603
00:29:18,786 --> 00:29:20,660
ka bieži, kad programmētāji
rakstāt kodu

604
00:29:20,660 --> 00:29:22,650
viņi ne vienmēr
sadarbojoties ar citiem,

605
00:29:22,650 --> 00:29:24,030
vai strādā kopīgu vidē.

606
00:29:24,030 --> 00:29:25,050
>> Viņi veida mājās.

607
00:29:25,050 --> 00:29:25,910
Varbūt tas ir vēlu vakarā.

608
00:29:25,910 --> 00:29:28,190
Viņi mēģina izdomāt
dažas bug to kodu.

609
00:29:28,190 --> 00:29:29,330
Un viņi vienkārši nav redzēt to.

610
00:29:29,330 --> 00:29:30,329
>> Un tur nav kaimiņiem.

611
00:29:30,329 --> 00:29:31,250
Nav TF.

612
00:29:31,250 --> 00:29:32,680
Nav CA apkārt.

613
00:29:32,680 --> 00:29:36,440
Visi viņi ir savā plauktā
tas ir maz gumijas ducky.

614
00:29:36,440 --> 00:29:39,030
>> Un tā gumijas pīle atkļūdošana
ir tikai šis uzaicinājums

615
00:29:39,030 --> 00:29:42,780
domāt par kaut ko tik dumjš
kā to kā reālu būtne,

616
00:29:42,780 --> 00:29:46,940
un faktiski iet caur savu kodu
mutiski šai nedzīvs objekts.

617
00:29:46,940 --> 00:29:49,230
Tā, piemēram, ja
šis ir mans piemērs here--

618
00:29:49,230 --> 00:29:52,470
un atgādina, ka agrāk
problēma bija tas,

619
00:29:52,470 --> 00:29:58,140
ja es dzēst šo pirmo rindiņu kodu,
un es iet uz priekšu un darīt buggy 0 atkal,

620
00:29:58,140 --> 00:30:01,220
atceros, ka man bija šie
kļūdu ziņojumus šeit.

621
00:30:01,220 --> 00:30:05,997
Tātad ideja šeit, smieklīgi gan I
justies brīdī darot publiski,

622
00:30:05,997 --> 00:30:06,580
ir tas, ka kļūda.

623
00:30:06,580 --> 00:30:10,910
>> Labi, tā mana problēma ir tā, ka es esmu
netieši paziņoja bibliotēkas funkciju.

624
00:30:10,910 --> 00:30:12,610
Un tas bibliotēka funkcija printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, deklarēt
man atgādina prototipu.

626
00:30:15,290 --> 00:30:18,930
>> Tas nozīmē, ka man ir nepieciešams, lai faktiski
pateikt kompilators iepriekš, kādu

627
00:30:18,930 --> 00:30:19,980
funkcija izskatās.

628
00:30:19,980 --> 00:30:20,930
Uzgaidi minūti.

629
00:30:20,930 --> 00:30:23,580
Man nebija standarta io.h.

630
00:30:23,580 --> 00:30:24,530
Liels paldies.

631
00:30:24,530 --> 00:30:27,330
>> Tik vienkārši šis process of-- jums
nav nepieciešams, lai tiešām ir pīle.

632
00:30:27,330 --> 00:30:29,819
Bet šī ideja pastaigas
sevi caur savu kodu

633
00:30:29,819 --> 00:30:31,610
tā, ka jūs pat dzirdēt
sevi, lai jums

634
00:30:31,610 --> 00:30:35,620
realizēt izlaidumus savu
piezīmes, parasti ideja.

635
00:30:35,620 --> 00:30:38,910
>> Un, iespējams, vairāk loģiski, ne tik
daudz ar šo vienu, bet jo vairāk iesaistīties

636
00:30:38,910 --> 00:30:44,220
piemērs mēs vienkārši darījām buggy 3.c,
jūs varētu staigāt sevi caur to

637
00:30:44,220 --> 00:30:45,310
sekojoši.

638
00:30:45,310 --> 00:30:49,190
Tātad viss labi, gumijas
ducky, DDB, ja Jums gribas.

639
00:30:49,190 --> 00:30:52,350
Šeit mums ir manā galvenā funkcija,
Es esmu aicinot saņemt negatīvu int.

640
00:30:52,350 --> 00:30:54,660
>> Un es esmu kļūst atgriešanās vērtību.

641
00:30:54,660 --> 00:31:00,410
Es esmu uzglabājot to kreisajā pusē
on line 8. ar mainīgo sauc i.

642
00:31:00,410 --> 00:31:02,380
OK, bet gaidīt, kā to darīja
kas saņem šo vērtību?

643
00:31:02,380 --> 00:31:04,130
Ļaujiet man apskatīt funkcijas atbilstoši 12.

644
00:31:04,130 --> 00:31:05,760
>> Atbilstoši 12, mums ir iegūt negatīvu int.

645
00:31:05,760 --> 00:31:08,190
Neņem izejmateriālus,
tomēr atgriezties int, OK.

646
00:31:08,190 --> 00:31:10,929
Es apliecinu, on line 14 mainīgs n.

647
00:31:10,929 --> 00:31:12,220
Tas notiek, lai saglabātu veselu skaitli.

648
00:31:12,220 --> 00:31:13,760
Tas, ko es gribu.

649
00:31:13,760 --> 00:31:18,480
>> Tāpēc šādas darbības, kamēr n is-- ļaut
mani atsaukt ko fix es jau veikts.

650
00:31:18,480 --> 00:31:22,710
Tāpēc, kamēr n ir lielāks nekā
0, izdrukāt n ir, OK.

651
00:31:22,710 --> 00:31:25,170
Un tad zvaniet get int saglabāti n.

652
00:31:25,170 --> 00:31:30,160
Un pēc tam pārbaudiet, vai n ir 0,
n ir not-- tur tas ir.

653
00:31:30,160 --> 00:31:31,910
Tātad, atkal, jums nav
nepieciešama faktisko pīle.

654
00:31:31,910 --> 00:31:35,650
Bet tikai ejot caur sevi
Jūsu kods kā intelektuālo izmantošanu

655
00:31:35,650 --> 00:31:37,720
bieži jums palīdzēt
saprast, kas notiek,

656
00:31:37,720 --> 00:31:41,170
nevis tikai kaut ko dara
kā šis, skatās uz ekrāna,

657
00:31:41,170 --> 00:31:43,720
un nerunāju sevi caur
tas, kas godīgi nav

658
00:31:43,720 --> 00:31:46,270
gandrīz kā efektīvu metodi.

659
00:31:46,270 --> 00:31:48,620
Tātad jums ir tā,
skaits dažādiem paņēmieniem

660
00:31:48,620 --> 00:31:52,102
par faktiski atkļūdošana kodu
un atrast vainu, kas visi

661
00:31:52,102 --> 00:31:54,810
būtu instrumenti jūsu rīkkopa
tāpēc, ka jūs neesat vēlu naktī,

662
00:31:54,810 --> 00:31:57,660
it īpaši, tu esi dining
zāles, vai darba laika,

663
00:31:57,660 --> 00:32:00,368
banging galvu pret
sienas, mēģinot atrisināt kādu problēmu.

664
00:32:00,368 --> 00:32:02,020
Apzināties, ka ir programmatūras rīki.

665
00:32:02,020 --> 00:32:03,720
Ir gumijas pīle instrumenti.

666
00:32:03,720 --> 00:32:09,630
Un tur ir viss personāls
atbalstīt gaida aizdot roku.

667
00:32:09,630 --> 00:32:13,120
>> Tāpēc tagad, vārds par problēmu
komplekti, un par to, ko mēs ceram tevi

668
00:32:13,120 --> 00:32:15,620
izkļūt no tiem, un cik
mēs iet par novērtēšanā.

669
00:32:15,620 --> 00:32:17,680
Per Kurss ir mācību programmas,
CS50 problēma komplekti

670
00:32:17,680 --> 00:32:22,320
tiek vērtēti četriem primārajiem asīm, tāpēc
līdz speak-- jomu, pareizību, dizains,

671
00:32:22,320 --> 00:32:23,060
un stils.

672
00:32:23,060 --> 00:32:25,910
Un darbības joma tieši atsaucas uz to, cik daudz
gabalos esat sakosts off?

673
00:32:25,910 --> 00:32:28,080
Cik daudz problēmu, tu esi mēģinājis?

674
00:32:28,080 --> 00:32:30,110
Kāds pūles
tu esi izpaužas?

675
00:32:30,110 --> 00:32:35,750
>> Pareizība ir, vai programmas darbu, kā
tas ir paredzēts vienam CS50 specifikācijai

676
00:32:35,750 --> 00:32:38,640
kad jūs sniedzat konkrētas izejvielas
vai daži rezultāti nāk atpakaļ?

677
00:32:38,640 --> 00:32:41,130
Dizains ir visvairāk subjektīvs no tiem.

678
00:32:41,130 --> 00:32:43,360
Un tas ir viens, ka būs
veikt garāko mācīties

679
00:32:43,360 --> 00:32:47,220
un garāko mācīt, it
ciktāl tā vārīties uz leju, lai,

680
00:32:47,220 --> 00:32:49,530
cik labi uzrakstīts ir jūsu kods?

681
00:32:49,530 --> 00:32:52,920
>> Tā ir viena lieta, lai tikai drukāt pareizs
izejas vai atgriešanās pareizās vērtības.

682
00:32:52,920 --> 00:32:55,400
Bet jūs darāt to, kā
iespējas efektīvāk?

683
00:32:55,400 --> 00:32:58,210
Vai jūs darāt to plaisu
un iekarot, vai binārā

684
00:32:58,210 --> 00:33:01,500
meklēšana kā mēs drīz redzēt, ka mēs darījām
Pirms divām nedēļām ar tālruņa grāmatu?

685
00:33:01,500 --> 00:33:04,670
Vai ir labāki veidi, lai atrisinātu
problēma, nekā jums šobrīd ir šeit?

686
00:33:04,670 --> 00:33:06,380
Tas ir iespēja labāku dizainu.

687
00:33:06,380 --> 00:33:08,530
>> Un tad style-- cik
diezgan ir jūsu kods?

688
00:33:08,530 --> 00:33:12,370
Jūs pamanīsiet, ka es esmu diezgan
īpaši par indenting manu kodu,

689
00:33:12,370 --> 00:33:15,300
un pārliecinoties manu mainīgos
ir pamatoti nosaukts. n,

690
00:33:15,300 --> 00:33:19,660
bet īstermiņa, ir labs vārds, lai
numurs, i par skaitīšanas skaitlim,

691
00:33:19,660 --> 00:33:20,727
s par virkni.

692
00:33:20,727 --> 00:33:22,560
Un mēs varam būt garāks
mainīgo nosaukumi stils.

693
00:33:22,560 --> 00:33:25,500
Stils ir, cik labi
ir jūsu kods meklēt?

694
00:33:25,500 --> 00:33:26,600
Un kā lasāms tas ir?

695
00:33:26,600 --> 00:33:29,650
>> Un laika gaitā, ko jūsu Tehniskās vienošanās
un TFS darīs gaitā

696
00:33:29,650 --> 00:33:31,870
ir nodrošināt jūs ar to
veida kvalitatīvas atgriezeniskās saites

697
00:33:31,870 --> 00:33:34,330
lai jums labāk
šajās dažādiem aspektiem.

698
00:33:34,330 --> 00:33:37,510
Un attiecībā uz to, kā mēs
novērtēt katru no šīm asīm,

699
00:33:37,510 --> 00:33:40,080
tas parasti ir ļoti maz
spaiņi, lai jūs, parasti,

700
00:33:40,080 --> 00:33:41,680
iegūt sajūtu par to, cik labi jūs darāt.

701
00:33:41,680 --> 00:33:45,680
Un, protams, ja jūs saņemat punktu skaits par
kāds no tiem axes-- pareizību, dizains

702
00:33:45,680 --> 00:33:49,659
un stils especially-- ka numurs
parasti ir robežās no 1 līdz 5.

703
00:33:49,659 --> 00:33:52,450
Un, burtiski, ja jūs saņemat
3 s sākumā semestra,

704
00:33:52,450 --> 00:33:53,977
šī ir ļoti laba lieta.

705
00:33:53,977 --> 00:33:55,810
Tas nozīmē, ka ir vēl
iespējami uzlabojumi,

706
00:33:55,810 --> 00:33:58,490
ko jūs varētu cerēt uz
ņemot klases pirmo reizi.

707
00:33:58,490 --> 00:34:01,820
Ir cerams daži griestu bit
uz kuru jūs esat iecerējušas panākt.

708
00:34:01,820 --> 00:34:03,970
Un tā kļūst 3 ir uz
Agrākais gabali,

709
00:34:03,970 --> 00:34:06,550
ja ne kāds 2 s un 4 s,
ir, protams, ir laba lieta.

710
00:34:06,550 --> 00:34:08,880
Tas ir labi diapazonā,
labi ietvaros cerības.

711
00:34:08,880 --> 00:34:11,421
>> Un, ja jūsu prāts ir sacīkšu, gaidiet
minūtes, trīs no pieciem.

712
00:34:11,421 --> 00:34:12,620
Tas tiešām ir 6 no 10.

713
00:34:12,620 --> 00:34:13,560
Tas ir 60%.

714
00:34:13,560 --> 00:34:14,830
Mans Dievs, tas F.

715
00:34:14,830 --> 00:34:15,870
>> Tas nav.

716
00:34:15,870 --> 00:34:17,600
Tas nav, jo fakts, ka.

717
00:34:17,600 --> 00:34:22,710
Drīzāk, tas ir iespēja uzlabot
gaitā semestra.

718
00:34:22,710 --> 00:34:25,580
Un, ja jūs saņemat kādu
Poors, tie ir iespēja

719
00:34:25,580 --> 00:34:29,199
lai izmantotu darba laika,
protams sadaļas un citus resursus.

720
00:34:29,199 --> 00:34:32,840
>> Best ir iespēja, tiešām,
lepoties, cik tālu jūs esat

721
00:34:32,840 --> 00:34:34,520
nākt gaitā semestra.

722
00:34:34,520 --> 00:34:38,199
Tātad saprotu, ja nekas
cits, trīs ir labs.

723
00:34:38,199 --> 00:34:40,179
Un tas ļauj vietas izaugsmei laikā.

724
00:34:40,179 --> 00:34:43,090
>> Par to, kā šie asis ir
svērtā, reāli tu esi

725
00:34:43,090 --> 00:34:46,745
gatavojas pavadīt lielāko daļu sava laika iegūt
lietas, darbu, nemaz nerunājot pareizi.

726
00:34:46,745 --> 00:34:49,120
Un tā pareizību tendence
vērtē visvairāk, jo ar

727
00:34:49,120 --> 00:34:51,360
šis multiplikatīvā koeficientu trīs.

728
00:34:51,360 --> 00:34:54,659
Dizains ir arī svarīgi, bet
kaut kas jums nav obligāti

729
00:34:54,659 --> 00:34:58,220
pavada visus šos stundas
cenšas iegūt lietas vienkārši strādāt.

730
00:34:58,220 --> 00:35:00,019
>> Un tā tas ir svērtā
vairāk viegli maz.

731
00:35:00,019 --> 00:35:01,560
Un tad stils tiek svērtas vismazāk.

732
00:35:01,560 --> 00:35:03,710
Pat ja tas ir ne mazāk
svarīgi būtiski,

733
00:35:03,710 --> 00:35:05,990
tas ir tikai, iespējams,
Vieglākais lieta darīt pareizi,

734
00:35:05,990 --> 00:35:08,440
atdarinot piemēriem
darīt lekciju un sadaļā,

735
00:35:08,440 --> 00:35:11,080
ar lietām labi
atkāpi, un komentēja,

736
00:35:11,080 --> 00:35:14,320
un tā tālāk, ir viens no vienkāršākajiem
lietas, kas darīt un iegūt tiesības.

737
00:35:14,320 --> 00:35:16,960
Tā kā tāds, saproti
ka tie ir punkti

738
00:35:16,960 --> 00:35:19,000
kas ir salīdzinoši viegli satvert.

739
00:35:19,000 --> 00:35:22,360
>> Un tagad vārds uz
this-- akadēmisko godīgumu.

740
00:35:22,360 --> 00:35:25,150
Tātad per kurss s
mācību programma, jūs redzēsiet

741
00:35:25,150 --> 00:35:27,630
ka protams, ir diezgan
Mazliet valodas ap šo.

742
00:35:27,630 --> 00:35:31,380
Un protams, ņem jautājumu
akadēmiskais godīgums diezgan nopietni.

743
00:35:31,380 --> 00:35:33,450
>> Mums ir atšķirība,
lai labāk vai sliktāk,

744
00:35:33,450 --> 00:35:36,570
ka tā nosūta katru gadu vairāk
studentus disciplināratbildības

745
00:35:36,570 --> 00:35:39,670
nekā lielākā daļa jebkurš cits
Protams, ka es apzinos.

746
00:35:39,670 --> 00:35:42,580
Tas ne vienmēr ir
liecina par to,

747
00:35:42,580 --> 00:35:46,340
ka CS studenti, vai CS50 studenti, ir
jebkuru mazāk godīgs nekā jūsu klasesbiedriem.

748
00:35:46,340 --> 00:35:49,090
Bet realitāte, ka šajā
pasaule, elektroniski, mēs vienkārši

749
00:35:49,090 --> 00:35:50,990
ir tehnoloģiskā
nozīmē atklāt to.

750
00:35:50,990 --> 00:35:53,360
>> Ir svarīgi, lai mums
taisnīgums visā klasē

751
00:35:53,360 --> 00:35:58,550
ka mēs atklāt to, kā paaugstināt
jautājums, kad mēs redzam lietas.

752
00:35:58,550 --> 00:36:01,980
Un tikai uzzīmēt zīmējumu, un patiešām
palīdzēt kaut kā šis izlietne,

753
00:36:01,980 --> 00:36:04,600
tie ir skaitļi, kas
studenti pēdējo 10 gadu laikā

754
00:36:04,600 --> 00:36:07,610
kas ir iesaistīts dažās
šie jautājumi akadēmisko godīgumu,

755
00:36:07,610 --> 00:36:10,990
ar dažiem 32 studentiem
no krišanas 2015, kas

756
00:36:10,990 --> 00:36:13,760
ir teikt, ka mēs veikt
jautājums ir ļoti nopietni.

757
00:36:13,760 --> 00:36:18,380
Un, galu galā, šie skaitļi sacerēt,
pavisam nesen, aptuveni 3%, 4%, vai arī tā

758
00:36:18,380 --> 00:36:19,120
no klases.

759
00:36:19,120 --> 00:36:25,220
>> Tātad super vairumam studentu
šķiet, ka līnijas ir skaidri.

760
00:36:25,220 --> 00:36:27,940
Bet vai paturēt to
prātā, īpaši vēlu

761
00:36:27,940 --> 00:36:32,080
naktī, kad cīnās ar
daži risinājumu problēmai, kas,

762
00:36:32,080 --> 00:36:34,830
mehānismus
lai iegūtu sevi labāk

763
00:36:34,830 --> 00:36:37,870
atbalsts, nekā jūs varētu
domāju, pat tajā stundā.

764
00:36:37,870 --> 00:36:40,514
Saprast, ka tad, kad mēs saņemam
studentu iesniegumi, mēs šķērsot

765
00:36:40,514 --> 00:36:43,430
salīdzināt katru iesniegumu šogad
pret katru iesniegumu pagājušajā gadā,

766
00:36:43,430 --> 00:36:47,590
pret katru iesniegumu no 2007. gada,
un kopš, apskatot, kā arī,

767
00:36:47,590 --> 00:36:49,931
koda repozitoriju online,
diskusiju forumos, darba vietas.

768
00:36:49,931 --> 00:36:51,806
Un mēs pieminēt,
tiešām, visi labad

769
00:36:51,806 --> 00:36:56,040
par pilnīgu atklātību, ka, ja
kāds cits var atrast internetā,

770
00:36:56,040 --> 00:36:57,880
protams, tāpēc mēs varam kurss.

771
00:36:57,880 --> 00:37:00,100
Bet, patiešām, gars
Kursa vārīties uz leju

772
00:37:00,100 --> 00:37:01,650
uz šo klauzulu mācību programmu.

773
00:37:01,650 --> 00:37:03,670
Tas patiešām ir vienkārši, būtu saprātīgi.

774
00:37:03,670 --> 00:37:06,680
>> Un, ja mums bija izstrādāt par ka
tikai mazliet vairāk valodu,

775
00:37:06,680 --> 00:37:09,770
saprast, ka būtība visu
darbu, kas jūs iesniegt šo kursu

776
00:37:09,770 --> 00:37:10,954
jābūt savu.

777
00:37:10,954 --> 00:37:13,870
Bet gan tas, ka ir noteikti
iespējas un pamudinājums,

778
00:37:13,870 --> 00:37:17,300
un pedagoģiskā vērtība pagrieziena uz
others-- sevi, tad TFS, CAS,

779
00:37:17,300 --> 00:37:20,760
tad TAS, un citi klasē,
atbalstam, nemaz nerunājot par draugu

780
00:37:20,760 --> 00:37:23,547
un roommates, kuri ir mācījušies
pirms CS un programmēšana.

781
00:37:23,547 --> 00:37:25,130
Un tāpēc ir pabalsts par to.

782
00:37:25,130 --> 00:37:28,180
Un vispārējais noteikums īkšķis
ir this-- kad lūdz palīdzību,

783
00:37:28,180 --> 00:37:31,470
jūs varat parādīt savu kodu, lai citiem,
bet jūs nevar skatīt savējo.

784
00:37:31,470 --> 00:37:34,880
Tātad, pat ja jūs esat pie darba laika,
vai D zālē, vai kaut kur citur

785
00:37:34,880 --> 00:37:37,450
strādā pie dažiem gabals komplektu,
strādājot kopā pastu, kas

786
00:37:37,450 --> 00:37:40,160
ir pilnīgi fine, pie
dienas beigās savu darbu

787
00:37:40,160 --> 00:37:43,034
galu galā būtu pieder katram
no jums attiecīgi, un ne

788
00:37:43,034 --> 00:37:45,700
daži sadarbības pūles,
izņemot gala projektu, kurā

789
00:37:45,700 --> 00:37:47,410
tas ir atļauts un jāveicina.

790
00:37:47,410 --> 00:37:49,830
>> Saprast, ka, ja jūs esat
cīnās ar kaut ko

791
00:37:49,830 --> 00:37:52,520
un jūsu draugs vienkārši notiek
būt labāk šo, tad jums,

792
00:37:52,520 --> 00:37:55,130
vai labāk šo problēmu, nekā jūs,
vai mazliet tālāk uz priekšu, nekā jūs,

793
00:37:55,130 --> 00:37:57,330
tas ir pilnīgi pamatoti, lai ieslēgtu
savam draugam un teikt, hey,

794
00:37:57,330 --> 00:38:00,480
Vai jums prātā, apskatot manu kodu šeit,
palīdzētu man vietas, ko mana problēma ir?

795
00:38:00,480 --> 00:38:03,760
Un, cerams, pēc
interese par pedagoģisko vērtību

796
00:38:03,760 --> 00:38:07,040
ka draugs nav tikai
saka, oh, to izdarītu, bet drīzāk,

797
00:38:07,040 --> 00:38:09,917
ko jūs trūkst tiešsaistē
6, vai kaut kas tamlīdzīgs?

798
00:38:09,917 --> 00:38:12,000
Bet risinājums ir ne
par draugu pie jums

799
00:38:12,000 --> 00:38:15,617
teikt, oh, labi, šeit, ļaujiet man pull
šo augšu, un parādīt savu risinājumu Jums.

800
00:38:15,617 --> 00:38:16,450
Tātad tas ir līnija.

801
00:38:16,450 --> 00:38:18,670
Jūs parādīt savu kodu
citi, bet jūs nedrīkstat

802
00:38:18,670 --> 00:38:22,350
skatīt savējo, ievērojot otru
ierobežojumi gaitā ir mācību programmas.

803
00:38:22,350 --> 00:38:24,760
>> Tāpēc paturiet prātā šo
tā sauktā nožēlu klauzula

804
00:38:24,760 --> 00:38:27,560
Gaitā ir mācību programmas, kā arī,
ka, ja jūs izdarīt kādu darbību, kas

805
00:38:27,560 --> 00:38:30,476
nav saprātīgi, bet lai to
uzmanība kursa galvām

806
00:38:30,476 --> 00:38:34,240
72 stundu laikā, protams,
var izvirzīt vietējās sankcijas, kas

807
00:38:34,240 --> 00:38:37,380
var būt neapmierinoša vai
ja pakāpe darbu iesniegto.

808
00:38:37,380 --> 00:38:41,410
Bet protams, nebūs atsaukties
jautājums tālākai disciplināratbildības,

809
00:38:41,410 --> 00:38:43,010
izņemot gadījumus atkārtotu aktu.

810
00:38:43,010 --> 00:38:46,632
Citiem vārdiem sakot, ja jūs veikt dažas
stulbi, it īpaši vēlu vakarā, lēmums

811
00:38:46,632 --> 00:38:49,340
ka nākamajā rītā vai divas dienas
vēlāk, tu pamosties un saprast,

812
00:38:49,340 --> 00:38:50,870
Ko es domāju?

813
00:38:50,870 --> 00:38:53,890
Jūs darīt CS50 ir noieta
lai noteiktu, ka problēma

814
00:38:53,890 --> 00:38:57,170
un kurai pieder līdz ar to, tā ka mēs
Jūs sagaidīs pusceļā un risināt

815
00:38:57,170 --> 00:39:01,500
ar to ir jautājums, kas ir gan
izglītības un vērtīgs, lai jūs,

816
00:39:01,500 --> 00:39:04,200
bet joprojām represīva kaut kādā veidā.

817
00:39:04,200 --> 00:39:08,590
Un tagad, lai ņemtu malu off, šis.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO PLAYBACK]

819
00:39:10,570 --> 00:39:13,540
>> [SKAN MŪZIKA]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END PLAYBACK]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Malan: Labi, mēs esam atpakaļ.

823
00:40:00,490 --> 00:40:03,680
Un tagad mēs skatāmies viens no
Pirmais no mūsu reālās pasaules domēniem

824
00:40:03,680 --> 00:40:08,720
in CS50, māksla kriptogrāfijas,
māksla sūtīšanas un saņemšanas

825
00:40:08,720 --> 00:40:11,840
slepenas ziņas, šifrētu
ziņas, ja jūs,

826
00:40:11,840 --> 00:40:17,060
ka var atšifrē tikai tad, ja jums ir
daži pamatelementiem, ka sūtītājs ir

827
00:40:17,060 --> 00:40:18,030
arī.

828
00:40:18,030 --> 00:40:22,120
Tātad, lai motivētu šo mēs ņemšu
apskatīt šo lieta šeit,

829
00:40:22,120 --> 00:40:26,750
kas ir piemērs
noslēpums dekoders gredzens, kas

830
00:40:26,750 --> 00:40:34,042
var tikt izmantoti, lai noskaidrotu
kāds noslēpums vēstījums patiesībā ir.

831
00:40:34,042 --> 00:40:35,750
Patiesībā, atpakaļ
diena pakāpē skolā,

832
00:40:35,750 --> 00:40:38,787
ja Jums kādreiz nosūtīts slepeno ziņojumus
kādu draugu vai kādu sasmalcināt klasē,

833
00:40:38,787 --> 00:40:40,620
jūs varētu būt doma
jūs ir gudrs

834
00:40:40,620 --> 00:40:46,530
ar jūsu gabals papīra maiņas,
piemēram, no A līdz B, un B uz C, un C līdz D,

835
00:40:46,530 --> 00:40:47,590
un tā tālāk.

836
00:40:47,590 --> 00:40:50,300
Bet jūs faktiski šifrējot
Jūsu informācija, pat

837
00:40:50,300 --> 00:40:53,300
ja tas bija mazliet niecīgs, nebija
ka grūti skolotājam realizēt,

838
00:40:53,300 --> 00:40:55,675
labi, ja jūs vienkārši mainīt
B uz A un C uz B,

839
00:40:55,675 --> 00:40:57,550
jūs faktiski izdomāt
kāda ziņa bija,

840
00:40:57,550 --> 00:40:59,700
bet jums bija šifrēšana informāciju.

841
00:40:59,700 --> 00:41:03,420
>> Tu tikai darot to
vienkārši, līdzīgi Ralphie šeit

842
00:41:03,420 --> 00:41:07,934
slavenā filma, kas spēlē
diezgan daudz ad nauseum katru ziemu.

843
00:41:07,934 --> 00:41:08,600
[VIDEO PLAYBACK]

844
00:41:08,600 --> 00:41:11,180
-Be Tas zināms visiem, ka
Ralfs Parker ir šo

845
00:41:11,180 --> 00:41:14,070
iecelts Little
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
un ir tiesības uz visiem apbalvojumus
un ieguvumi tiem notiek.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
counter-parakstīta Pierre Andre, ar tinti.

848
00:41:24,340 --> 00:41:27,160
Apbalvojumus un ieguvumi,
jau Deviņu gadu vecumā.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Kliegšana]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Aiziet.

853
00:41:34,250 --> 00:41:35,210
Pieņemsim galā ar to.

854
00:41:35,210 --> 00:41:39,530
Man nevajag visu, kas jazz
par kontrabandistu un pirātiem.

855
00:41:39,530 --> 00:41:41,660
>> -Listen Rīt nakts
Secinājumu piedzīvojums

856
00:41:41,660 --> 00:41:43,880
melnā pirātu kuģa.

857
00:41:43,880 --> 00:41:46,650
Tagad ir pienācis laiks
Annie slepeno ziņu

858
00:41:46,650 --> 00:41:49,840
par jums locekļi Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Atceries, bērni, tikai dalībnieki
no Annie 's Secret Circle

860
00:41:53,570 --> 00:41:56,140
var atšifrēt Annie slepeno ziņu.

861
00:41:56,140 --> 00:42:00,340
>> Atceries, Annie ir atkarīgs no jums.

862
00:42:00,340 --> 00:42:02,880
Iestatiet savu pins B2.

863
00:42:02,880 --> 00:42:05,230
Šeit ir vēstījums.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Es Esmu, manu pirmo slepenu sanāksmi.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Bija liels balss šovakar.

868
00:42:15,780 --> 00:42:19,000
Es varētu pateikt, ka šovakar
vēstījums bija ļoti svarīgi.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, tas ir vēstījums
no Annie pati.

870
00:42:22,694 --> 00:42:23,860
Atceries, nesaki nevienam.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekundes vēlāk, es esmu vienīgais
istabu mājā, kur zēns no deviņiem

873
00:42:32,930 --> 00:42:37,040
varētu sēdēt privātumu un atšifrēt.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Es devos uz nākamo, E.

876
00:42:42,360 --> 00:42:44,520
>> Pirmais vārds ir jābūt.

877
00:42:44,520 --> 00:42:49,032
S, tas nāk vieglāk, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> OH, come on, Ralphie, es gotta go!

879
00:42:51,733 --> 00:42:53,688
>> -I'll Būt tiesības uz leju, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee sīkšana!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, pārliecinieties, kuri paredzēti, pārliecinieties, ko?

883
00:43:04,060 --> 00:43:05,970
Kāds bija Little Orphan
Annie cenšas pateikt?

884
00:43:05,970 --> 00:43:07,264
Noteikti ko?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy ir nokļuvis
iet, jūs lūdzu iznākt?

886
00:43:09,634 --> 00:43:10,480
>> -Visas Labi, Ma!

887
00:43:10,480 --> 00:43:12,880
Es būšu labi out!

888
00:43:12,880 --> 00:43:14,550
>> -Es Tika tuvojas tagad.

889
00:43:14,550 --> 00:43:16,620
Spriedze bija briesmīga.

890
00:43:16,620 --> 00:43:17,720
Kas tas bija?

891
00:43:17,720 --> 00:43:20,170
Liktenis planētas
var pakārt bilancē.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy gotta go!

894
00:43:23,170 --> 00:43:26,890
>> -I'll Būt labi ārā, lai kliedz skaļi!

895
00:43:26,890 --> 00:43:32,680
>> -Almost Tur, mani pirksti lidoja, manu prātu
bija tērauda lamatas, katru poru vibrācijas.

896
00:43:32,680 --> 00:43:37,198
Tas bija gandrīz skaidrs, jā, jā, jā.

897
00:43:37,198 --> 00:43:43,091
>> -Be Noteikti dzert Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Apaļīgs tirdzniecības?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Kuces dēls.

903
00:43:54,227 --> 00:43:54,810
[END PLAYBACK]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Malan: Labi, tāpēc
tas bija ļoti garš ceļš

905
00:43:57,390 --> 00:44:00,660
ieviest kriptogrāfija,
un arī Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Faktiski, no šīs vecās sludinājumu
šeit, kāpēc ir Ovaltine tik labs?

907
00:44:04,470 --> 00:44:09,470
Tas ir koncentrēts ieguve nogatavojies
miežu iesals, Pure krēmīgu govs piens,

908
00:44:09,470 --> 00:44:14,360
un speciāli sagatavoti kakao, kopā
ar dabas fosfatīdu un vitamīniem.

909
00:44:14,360 --> 00:44:18,240
Tas ir vēl bagātināti ar
papildu vitamīnus B un D, ​​Yum.

910
00:44:18,240 --> 00:44:21,600
Un jūs joprojām varat saņemt to, acīmredzot,
Amazon, kā mēs to darījām šeit.

911
00:44:21,600 --> 00:44:24,810
>> Bet motivācija šeit bija
iepazīstināt kriptogrāfija, īpaši

912
00:44:24,810 --> 00:44:28,340
A kriptogrāfiju veids, ko sauc
kā slepeno atslēgu kriptogrāfiju.

913
00:44:28,340 --> 00:44:34,284
Un kā liecina nosaukums, viss
par slepeno atslēgu šifrēšanas sistēmas drošība,

914
00:44:34,284 --> 00:44:36,200
ja jūs, metodika
lai tikai kodēšanas

915
00:44:36,200 --> 00:44:40,960
informācijas apmaiņu starp diviem cilvēkiem, ir tas, ka
tikai sūtītājs un tikai saņēmējs

916
00:44:40,960 --> 00:44:46,980
zināt noslēpums key-- dažas vērtības, daži
noslēpums frāze, daži noslēpums numurs, kas

917
00:44:46,980 --> 00:44:50,660
ļauj viņiem gan šifrētu
un atšifrēt informāciju.

918
00:44:50,660 --> 00:44:53,470
Un kriptogrāfija, tiešām,
ir tikai tas no nedēļas 0.

919
00:44:53,470 --> 00:44:56,715
>> Tā ir problēma, kur tur ir ieejas,
tāpat faktisko ziņojumu Angļu

920
00:44:56,715 --> 00:44:59,340
vai kāds valoda, kas jums
vēlaties nosūtīt kādam klasē,

921
00:44:59,340 --> 00:45:00,580
vai visā internetā.

922
00:45:00,580 --> 00:45:03,840
Ir daži produkcija, kas gatavojas
būt scrambled ziņa, ka jums

923
00:45:03,840 --> 00:45:05,250
vēlas saņēmējs saņemt.

924
00:45:05,250 --> 00:45:07,405
Un pat tad, ja kāds
vidū saņem pārāk,

925
00:45:07,405 --> 00:45:09,780
jūs nevēlaties tos
vienmēr varēs atšifrēt to,

926
00:45:09,780 --> 00:45:12,840
jo iekšpusē šis
melnā kaste, vai algoritms,

927
00:45:12,840 --> 00:45:17,650
ir kāds mehānisms, kādu soli pa solim
instrukcijas, lai pieņemtu šo ievade

928
00:45:17,650 --> 00:45:20,710
un pārveidojot to par
produkcija, kas cerams drošā veidā.

929
00:45:20,710 --> 00:45:23,640
>> Un, patiesībā, ir daži
leksika šajā pasaulē šādi.

930
00:45:23,640 --> 00:45:26,100
Vienkāršs teksts ir vārds
dators zinātnieks būtu

931
00:45:26,100 --> 00:45:28,449
izmantot, lai aprakstītu ievadi
ziņojums, tāpat kā angļu valodā

932
00:45:28,449 --> 00:45:31,240
vai kāds valoda jums tiešām
vēlas, lai nosūtītu uz kādu citu cilvēku.

933
00:45:31,240 --> 00:45:35,450
Un tad ciphertext ir motokross
uz šifrēta, vai šifrēta,

934
00:45:35,450 --> 00:45:36,520
variantu.

935
00:45:36,520 --> 00:45:38,750
>> Bet tur ir vēl viena sastāvdaļa šeit.

936
00:45:38,750 --> 00:45:43,200
Ir viens cits pievade
slepenā atslēga kriptogrāfija.

937
00:45:43,200 --> 00:45:45,200
Un tas ir pats galvenais,
kas ir, parasti,

938
00:45:45,200 --> 00:45:48,930
kā mēs redzēsim, numuru, vai
vēstule, vai vārds, neatkarīgi

939
00:45:48,930 --> 00:45:51,980
algoritms tas faktiski sagaida.

940
00:45:51,980 --> 00:45:53,870
>> Un kā jūs atšifrēt informāciju?

941
00:45:53,870 --> 00:45:55,110
Kā jūs atšifrēt to?

942
00:45:55,110 --> 00:45:57,950
Nu, jūs vienkārši mainīt
izejas un ieejas.

943
00:45:57,950 --> 00:46:00,900
>> Citiem vārdiem sakot, ja kāds
saņem savu šifrētu ziņu,

944
00:46:00,900 --> 00:46:03,740
viņš vai viņa vienkārši ir
zināt, ka vienu un to pašu atslēgu.

945
00:46:03,740 --> 00:46:05,700
Viņi ir saņēmuši ciphertext.

946
00:46:05,700 --> 00:46:09,530
Un ar tapām šos divus
ieejas fani šifrēšanas sistēmu,

947
00:46:09,530 --> 00:46:14,260
algoritmu, šī melnā kaste, kas
jānāk sākotnējo teksta,.

948
00:46:14,260 --> 00:46:17,830
Un tā tas ir ļoti augsts līmenis
viedoklis par to, kas kriptogrāfija ir faktiski

949
00:46:17,830 --> 00:46:18,590
visu par.

950
00:46:18,590 --> 00:46:20,030
>> Tātad, pieņemsim tur nokļūt.

951
00:46:20,030 --> 00:46:22,700
Pieņemsim tagad izskatās zem
kapuci kaut

952
00:46:22,700 --> 00:46:26,000
mēs esam bijuši ņemot par pašsaprotamu, lai
pagājušajā nedēļā, un par to sesija

953
00:46:26,000 --> 00:46:27,629
here-- virkni.

954
00:46:27,629 --> 00:46:30,295
Virkne, beigās, dienā
ir tikai rakstzīmju secība.

955
00:46:30,295 --> 00:46:33,610
>> Tas varētu būt Hello World, vai
sveiki Zamyla, vai neatkarīgi.

956
00:46:33,610 --> 00:46:37,050
Bet ko tas nozīmē
būt secība rakstzīmes?

957
00:46:37,050 --> 00:46:41,520
Faktiski CS50 bibliotēka sniedz
mums datu tips sauc virkne.

958
00:46:41,520 --> 00:46:45,140
>> Bet tur faktiski nav
tādas lietas kā string C.

959
00:46:45,140 --> 00:46:49,450
Tas tiešām ir tikai secība
raksturs, raksturs, raksturs,

960
00:46:49,450 --> 00:46:52,180
raksturs, atpakaļ, atpakaļ, uz
atpakaļ, atpakaļ, atpakaļ iekšā

961
00:46:52,180 --> 00:46:54,650
no datora atmiņu, vai RAM.

962
00:46:54,650 --> 00:46:58,940
Un mēs apskatīt dziļāk, ka
nākotne, ja mēs skatāmies uz sevi atmiņas,

963
00:46:58,940 --> 00:47:02,030
un izmantošana, kā arī
draudi, kas ir iesaistīti.

964
00:47:02,030 --> 00:47:04,100
>> Bet pieņemsim apsvērt virkni Zamyla.

965
00:47:04,100 --> 00:47:07,480
Tātad tikai nosaukums
cilvēka šeit, Zamyla,

966
00:47:07,480 --> 00:47:12,030
kas ir secība
rakstzīmes, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Un tagad pieņemsim, ka Zamyla vārds
tiek glabāti iekšpusē datoru

968
00:47:16,020 --> 00:47:16,880
programma.

969
00:47:16,880 --> 00:47:20,830
>> Nu, tas saprotams, ka mums
varēs apskatīt šiem burtiem

970
00:47:20,830 --> 00:47:21,590
individuāli.

971
00:47:21,590 --> 00:47:24,710
Tāpēc es esmu tikai gatavojas izdarīt nedaudz
kaste ap Zamyla nosaukumu šeit.

972
00:47:24,710 --> 00:47:31,580
Un tas ir gadījumā C, ka tad, kad jūs
ir virkne, piemēram Zamyla-- un varbūt

973
00:47:31,580 --> 00:47:34,940
ka virkne ir atgriezies no
funkcija, piemēram, get virkni,

974
00:47:34,940 --> 00:47:38,540
Jūs faktiski var manipulēt
to raksturu ar raksturu.

975
00:47:38,540 --> 00:47:42,070
>> Tagad tas ir piederīgs, lai
saruna pie rokas, jo

976
00:47:42,070 --> 00:47:46,420
in kriptogrāfiju ja jūs vēlaties mainīt
A uz punktu B, un B uz C, un C līdz D,

977
00:47:46,420 --> 00:47:49,650
un tā tālāk, jums ir nepieciešams, lai varētu
apskatīt atsevišķas rakstzīmes

978
00:47:49,650 --> 00:47:50,190
virknē.

979
00:47:50,190 --> 00:47:52,695
Jums ir nepieciešams, lai varētu mainīt
Z uz kaut ko citu, tad A

980
00:47:52,695 --> 00:47:55,280
uz kaut ko citu, tad M līdz
kaut kas cits, un tā tālāk.

981
00:47:55,280 --> 00:47:58,000
Un tāpēc mums ir nepieciešams veids,
programmatiski, tāpēc

982
00:47:58,000 --> 00:48:03,020
runāt, C, lai varētu mainīt
un apskatīt atsevišķiem burtiem.

983
00:48:03,020 --> 00:48:05,690
Un mēs varam izdarīt šādi.

984
00:48:05,690 --> 00:48:08,340
>> Ļaujiet man iet galvu atpakaļ CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Un ļaujiet man iet uz priekšu
un izveidotu jaunu failu

986
00:48:11,130 --> 00:48:16,134
ka es aicinu šo laiku string0,
kā mūsu pirmais šāda piemēram, dot c.

987
00:48:16,134 --> 00:48:18,300
Un es iešu uz priekšu
un pātagu to šādi.

988
00:48:18,300 --> 00:48:22,870
>> Tātad ietver CS50.h, un
tad arī standarta io.h,

989
00:48:22,870 --> 00:48:25,990
ko es esmu gandrīz vienmēr gatavojas
būt lietot manas programmas, vismaz

990
00:48:25,990 --> 00:48:26,780
sākotnēji.

991
00:48:26,780 --> 00:48:32,180
int galveno tukšumu, un tad šeit es esmu
darīsim stīgas izpaužas saņemt virkni.

992
00:48:32,180 --> 00:48:35,260
Un tad es esmu gatavojas
iet uz priekšu un darīt to.

993
00:48:35,260 --> 00:48:37,460
Es gribu iet uz priekšu
un, kā veselība pārbaudītu,

994
00:48:37,460 --> 00:48:43,607
tikai teikt, hello, procenti s,
semikols, padara virkni 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, ko es daru šeit?

996
00:48:44,690 --> 00:48:45,930
Ak, man nav pievienojiet to.

997
00:48:45,930 --> 00:48:48,120
Tātad mācība, ka
nebija apzināta.

998
00:48:48,120 --> 00:48:52,480
>> Tātad kļūda, vairāk procenti
konvertēšanu nekā datu argumentiem.

999
00:48:52,480 --> 00:48:54,940
Un tas ir, ja, kas
line 7-- Labi, tāpēc man ir,

1000
00:48:54,940 --> 00:48:56,690
quote likt pēdiņas beigās, tas ir
mans string printf.

1001
00:48:56,690 --> 00:48:58,151
Man procentiem zīmi.

1002
00:48:58,151 --> 00:48:59,650
Bet es esmu trūkst otro argumentu.

1003
00:48:59,650 --> 00:49:03,190
>> Es esmu trūkst komats s, kas
Man tomēr ir iepriekšējos piemēros.

1004
00:49:03,190 --> 00:49:06,650
Tik laba iespēja, lai noteiktu
vēl viena kļūda, nejauši.

1005
00:49:06,650 --> 00:49:09,950
Un tagad ļaujiet man palaist
string0, ierakstiet Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, sveiki Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Tāpēc mēs esam palaist šāda veida programmas
daži citi laiki tagad.

1008
00:49:14,144 --> 00:49:16,310
Bet pieņemsim darīt kaut ko
maz atšķiras šoreiz.

1009
00:49:16,310 --> 00:49:19,450
Nevis tikai drukāšanas Zamyla s
Visa vārds out ar printf,

1010
00:49:19,450 --> 00:49:21,350
pieņemsim darīt rakstzīmi, raksturs.

1011
00:49:21,350 --> 00:49:22,700
>> Es esmu gatavojas izmantot par cilpu.

1012
00:49:22,700 --> 00:49:26,160
Un es esmu gatavojas sniegt sevi
skaitīšanas mainīgais, ko sauc par i.

1013
00:49:26,160 --> 00:49:33,530
Un es esmu gatavojas glabāt atkārtojot, tāpēc
ilgi, kamēr i ir mazāks par garumu s.

1014
00:49:33,530 --> 00:49:35,930
>> Izrādās, mēs neesam
darīt šo pēdējo reizi,

1015
00:49:35,930 --> 00:49:39,100
ka c nāk ar
funkcija sauc Stērlingas.

1016
00:49:39,100 --> 00:49:42,690
Atpakaļ dienā, un vispār
tomēr, īstenojot funkciju,

1017
00:49:42,690 --> 00:49:45,405
cilvēki bieži vien izvēlas ļoti
kodolīgs nosaukumi šāda veida skaņa

1018
00:49:45,405 --> 00:49:48,280
patīk tas, ko jūs vēlaties, pat ja tas ir
pazudis dažas patskaņi vai burtus.

1019
00:49:48,280 --> 00:49:50,660
Tātad Stirling ir
funkcijas nosaukumu, kas

1020
00:49:50,660 --> 00:49:53,880
aizņem arguments starp
iekavas, ka vajadzētu būt virkne.

1021
00:49:53,880 --> 00:49:56,910
Un tas tikai atgriež vesels skaitlis,
garums šī virkni.

1022
00:49:56,910 --> 00:50:00,580
>> Tātad šī cilpa uz 7. līnijā notiek
sākt skaitīšana i ir vienāds ar 0.

1023
00:50:00,580 --> 00:50:02,530
Tas notiek, lai pieauguma
i par katru atkārtojuma

1024
00:50:02,530 --> 00:50:04,350
ar 1, jo mēs esam bijuši dara pāris reizes.

1025
00:50:04,350 --> 00:50:06,780
Bet tas notiek, lai tikai darīt
tas līdz vietai

1026
00:50:06,780 --> 00:50:09,660
kad es ir garums
no virknes pati.

1027
00:50:09,660 --> 00:50:14,520
>> Tātad šis ir veids, kā, visbeidzot,
atkārtojot pār rakstzīmes

1028
00:50:14,520 --> 00:50:17,430
virknē kā ir šādi.

1029
00:50:17,430 --> 00:50:20,670
Es esmu gatavojas izdrukāt nav
visa virkne, bet procenti c,

1030
00:50:20,670 --> 00:50:22,860
vienu rakstzīmi
kam seko jaunu rindu.

1031
00:50:22,860 --> 00:50:24,880
Un tad es esmu gatavojas
iet uz priekšu, un man ir nepieciešams

1032
00:50:24,880 --> 00:50:29,080
teikt, es gribu, lai drukātu
kārtējā raksturs s.

1033
00:50:29,080 --> 00:50:33,450
>> Tātad, ja i ir mainīgs, kas norāda
indekss virknes, kur

1034
00:50:33,450 --> 00:50:37,230
Jums ir tā, man ir nepieciešams, lai varētu
saka, dod man kārtējam raksturu s.

1035
00:50:37,230 --> 00:50:40,390
Un c ir veids, kā to
tas ar kvadrātiekavās.

1036
00:50:40,390 --> 00:50:43,679
Jūs vienkārši pateikt nosaukumu
virkne, kas šajā gadījumā ir s.

1037
00:50:43,679 --> 00:50:46,970
Tad jūs izmantojat kvadrātiekavas, kas ir
parasti ir tikai virs jūsu Atgriezties vai Enter

1038
00:50:46,970 --> 00:50:48,110
taustiņu uz klaviatūras.

1039
00:50:48,110 --> 00:50:52,410
Un tad jūs nodot indekss
raksturu, kas jūs vēlaties drukāt.

1040
00:50:52,410 --> 00:50:55,960
Tātad indekss tiek būs
number-- 0, vai 1, vai 2, vai 3, vai dot,

1041
00:50:55,960 --> 00:50:57,590
dot, dot, kādu citu numuru.

1042
00:50:57,590 --> 00:51:00,920
>> Un mēs nodrošinām, ka tas notiek, lai
būt pareizo numuru, jo I

1043
00:51:00,920 --> 00:51:02,360
sākas skaitīšana 0.

1044
00:51:02,360 --> 00:51:07,020
Un pēc noklusējuma, pirmā rakstzīme
virknē, pēc vienošanās 0.

1045
00:51:07,020 --> 00:51:09,230
Un otrais raksturs ir kronšteins 1.

1046
00:51:09,230 --> 00:51:11,120
Un trešais raksturs ir kronšteins 2.

1047
00:51:11,120 --> 00:51:13,630
Un jūs nevēlaties, lai iet pārāk
tālu, bet mēs ne tāpēc, ka mēs esam

1048
00:51:13,630 --> 00:51:17,780
gatavojas tikai pieauguma i līdz to
vienāds ar garuma virknes.

1049
00:51:17,780 --> 00:51:20,210
Un kurā brīdī,
šis cilpa apstāsies.

1050
00:51:20,210 --> 00:51:25,550
>> Tāpēc ļaujiet man iet uz priekšu un saglabājiet šo
programma, un palaist veikt virkni 0.

1051
00:51:25,550 --> 00:51:28,400
Bet es ieskrūvē augšu.

1052
00:51:28,400 --> 00:51:35,390
Netieši atzīstot bibliotēka funkciju
Stirling ar šāda veida un such-- tagad,

1053
00:51:35,390 --> 00:51:36,430
tas izklausās pazīstami.

1054
00:51:36,430 --> 00:51:37,440
Bet tas nav printf.

1055
00:51:37,440 --> 00:51:38,540
Un tas nav get virkni.

1056
00:51:38,540 --> 00:51:40,480
>> Man nav screw up
tāpat šoreiz.

1057
00:51:40,480 --> 00:51:45,100
Bet paziņojums leju šeit mazliet uz leju
tālāk, ietver header string.h,

1058
00:51:45,100 --> 00:51:47,210
nepārprotami sniedz
deklarācija Stirling.

1059
00:51:47,210 --> 00:51:48,820
Tātad faktiski ir pavediens tur.

1060
00:51:48,820 --> 00:51:51,670
>> Un tiešām izrādās
tur ir cita header fails

1061
00:51:51,670 --> 00:51:53,970
ka mēs esam nav izmantoti
klasē vēl, bet tas ir

1062
00:51:53,970 --> 00:51:56,480
starp tiem pieejami
jums, ko sauc string.h.

1063
00:51:56,480 --> 00:52:00,930
Un šajā failu, string.h
ir Stirling deklarētas.

1064
00:52:00,930 --> 00:52:05,220
Tāpēc ļaujiet man iet uz priekšu un
saglabājiet to, veikt virkni

1065
00:52:05,220 --> 00:52:08,040
0-- jauki, nav kļūdu ziņojumus šoreiz.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, un
Es esmu par to hit Enter,

1067
00:52:12,290 --> 00:52:16,710
pie kura getstring punktu notiek
atgriezt virkni, ielieciet to s.

1068
00:52:16,710 --> 00:52:21,890
Tad, ka cilpa gatavojas atkārtot
pār s varoņi vienam,

1069
00:52:21,890 --> 00:52:28,420
un izdrukāt tos pa vienam katrā rindā, jo
Man bija, ka reversā slīpsvītra n beigās.

1070
00:52:28,420 --> 00:52:34,530
Lai es varētu izlaist šo slīpsvītru
n, un tad tikai drukāt Zamyla visu

1071
00:52:34,530 --> 00:52:37,460
tajā pašā rindā,
efektīvi reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, kas nav tik noderīgs.

1073
00:52:38,999 --> 00:52:40,540
Bet šajā gadījumā, man nav darījuši.

1074
00:52:40,540 --> 00:52:43,610
Es esmu tiešām drukā vienu
raksturs laikā, vienam katrā rindiņā,

1075
00:52:43,610 --> 00:52:45,400
lai mēs faktiski redzēt efektu.

1076
00:52:45,400 --> 00:52:46,900
>> Bet man vajadzētu atzīmēt, viena lieta šeit.

1077
00:52:46,900 --> 00:52:48,930
Un mēs atgriezties
tas nākamajā nedēļā.

1078
00:52:48,930 --> 00:52:52,650
Izrādās, ka šis
kods ir potenciāli buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Izrādās, ka saņemt virkni
un dažas citas funkcijas dzīvē

1080
00:52:56,560 --> 00:53:00,280
to ne vienmēr
atgriezt to, ko jūs gaida.

1081
00:53:00,280 --> 00:53:03,010
Mēs zinām no klases pēdējā
laiks, tas, ka nokļūt

1082
00:53:03,010 --> 00:53:04,960
string ir paredzēts atgriezties virkni.

1083
00:53:04,960 --> 00:53:09,900
Bet ko tad, ja lietotājs veic šādus
garš vārds, vai punktu, vai eseja

1084
00:53:09,900 --> 00:53:13,010
ka tur ir tikai nav pietiekami
atmiņa ar datoru, lai ietilptu to.

1085
00:53:13,010 --> 00:53:15,410
>> Tāpat, kas notiks, ja kaut kas noiet
nepareizi zem motora pārsega?

1086
00:53:15,410 --> 00:53:18,400
Tas varētu notikt bieži,
bet tas varētu notikt reizi

1087
00:53:18,400 --> 00:53:21,520
bet, ļoti reti.

1088
00:53:21,520 --> 00:53:25,460
Un tā izrādās, ka saņemt virkni
un funkcijas, piemēram, tas ne vienmēr

1089
00:53:25,460 --> 00:53:26,380
vienmēr atgriežas stīgas.

1090
00:53:26,380 --> 00:53:30,680
Tie varētu atgriezties dažas kļūdas vērtību,
daži Sentinel vērtība tā sakot,

1091
00:53:30,680 --> 00:53:32,612
kas norāda, ka
kaut kas ir nogājis greizi.

1092
00:53:32,612 --> 00:53:35,320
Un jūs tikai zināt, tas no
uzzinot to klasē tagad,

1093
00:53:35,320 --> 00:53:37,700
vai ir lasīt dažas vairāk dokumentāciju.

1094
00:53:37,700 --> 00:53:43,120
Izrādās, ka saņemt virkni
var atgriezties vērtību sauc null.

1095
00:53:43,120 --> 00:53:46,220
Null ir īpaša vērtība, ka mēs
atgriezties nākamajā nedēļā.

1096
00:53:46,220 --> 00:53:50,420
Bet tagad, tikai zinu, ka, ja es gribu
būt patiesi pareizi virzīties uz priekšu

1097
00:53:50,420 --> 00:53:52,650
izmantojot get virkni, es
būtu ne tikai sauc to,

1098
00:53:52,650 --> 00:53:56,870
un akli izmantot savu atgriešanās vērtību,
uzticoties, ka tā ir virkne.

1099
00:53:56,870 --> 00:53:59,420
>> Es vispirms vajadzētu teikt,
hey, pagaidiet minūti, tikai

1100
00:53:59,420 --> 00:54:03,380
turpināt, ja s nav vienāds
null, kur null, atkal,

1101
00:54:03,380 --> 00:54:04,660
ir tikai dažas īpašas vērtības.

1102
00:54:04,660 --> 00:54:07,770
Un tas ir vienīgais īpašu vērtību jūs
jāuztraucas par par get virkni.

1103
00:54:07,770 --> 00:54:10,900
Saņemt virkne ir vai nu iet
atgriezt virkni vai null.

1104
00:54:10,900 --> 00:54:17,219
>> Un šī izsaukuma zīme vienlīdzības zīme
jūs varētu zināt, no varbūt matemātikas klasē

1105
00:54:17,219 --> 00:54:20,510
ka jūs varētu izdarīt vienādības zīmi ar
līnija caur to norādīt nav vienāds.

1106
00:54:20,510 --> 00:54:23,135
Tas nav vispār raksturs
jūs varat rakstīt uz klaviatūras.

1107
00:54:23,135 --> 00:54:26,480
Un tāpēc vairumā programmēšanas valodas,
ja jūs vēlaties teikt nav vienāds,

1108
00:54:26,480 --> 00:54:29,160
Jūs lietojat izsaukuma zīmi,
citādi zināma kā sprādziena.

1109
00:54:29,160 --> 00:54:33,180
Tātad jūs sakāt sprādziena vienāds, kas
nozīmē ne vienāds, loģiski.

1110
00:54:33,180 --> 00:54:38,060
Tas ir tāpat kā tur nav lielāka
par vai vienāda ar vai mazāka nekā

1111
00:54:38,060 --> 00:54:41,270
vai vienāds ar tastatūras taustiņu
ka tas viss vienā simbolu.

1112
00:54:41,270 --> 00:54:44,020
Tātad, tāpēc, iepriekšējos piemēros,
jūs atklātu kronšteinu, un pēc tam

1113
00:54:44,020 --> 00:54:48,670
vienādības zīmi, lai darīt
ir lielāks nekā vai, teiksim, mazāk nekā.

1114
00:54:48,670 --> 00:54:49,910
>> Tātad, kāda ir takeaway šeit?

1115
00:54:49,910 --> 00:54:53,880
Tas ir vienkārši veids, tagad no
Ieviešot šo sintaksi, šī funkcija,

1116
00:54:53,880 --> 00:54:57,390
atkārtojot pār individuālo
rakstzīmes string.

1117
00:54:57,390 --> 00:55:00,260
Un tāpat kā tiem laukumā
kronšteini ļauj jums iegūt pie viņiem,

1118
00:55:00,260 --> 00:55:03,790
apsvērt šos kvadrātiekavas kā
veida hinting pie šī pamata

1119
00:55:03,790 --> 00:55:06,040
dizains, kurā katrs
raksturs iekšpusē virknes

1120
00:55:06,040 --> 00:55:10,180
ir sava veida liekami kaut kur zem
kapuci jūsu datora atmiņā.

1121
00:55:10,180 --> 00:55:12,340
>> Bet pieņemsim veikt variantu šo.

1122
00:55:12,340 --> 00:55:14,880
Izrādās, ka šis
programma ir pareiza.

1123
00:55:14,880 --> 00:55:18,810
Tātad par CS50 ir asis, lai izvērtētu
kods, tas ir pareizi tagad.

1124
00:55:18,810 --> 00:55:22,959
It īpaši tagad, ka es esmu pārbaudot
null, šī programma būtu nekad crash.

1125
00:55:22,959 --> 00:55:24,500
Un es tikai zinu, ka no pieredzes.

1126
00:55:24,500 --> 00:55:28,040
Bet tur nekas cits, ka
mēs varam tiešām iet greizi šeit.

1127
00:55:28,040 --> 00:55:31,860
Bet tas nav ļoti labi izstrādāts,
tāpēc iesim atpakaļ uz pamatus.

1128
00:55:31,860 --> 00:55:34,450
>> Pirmkārt, principles--
Ko dara cilpa darīt?

1129
00:55:34,450 --> 00:55:36,290
A cilpa dara trīs lietas.

1130
00:55:36,290 --> 00:55:39,340
Tas initializes daži
vērtība, ja jūs lūgt to.

1131
00:55:39,340 --> 00:55:41,770
Tā pārbauda nosacījumu.

1132
00:55:41,770 --> 00:55:45,380
Un tad pēc katras
atkārtojuma, pēc katra cikla,

1133
00:55:45,380 --> 00:55:49,330
tā pieauguma soli daži
vērtība vai vērtības, šeit.

1134
00:55:49,330 --> 00:55:50,600
>> Tātad, ko tas nozīmē?

1135
00:55:50,600 --> 00:55:52,940
Mēs sāktu i līdz 0.

1136
00:55:52,940 --> 00:55:58,610
Mēs pārbaudām un pārliecinieties, ka i ir mazāks nekā
garums s, kas ir Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
tā, kas ir mazāks nekā 6.

1138
00:55:59,900 --> 00:56:02,590
Un, protams, 0 mazāk nekā 6.

1139
00:56:02,590 --> 00:56:05,580
>> Mēs izdrukāt Z no Zamyla vārdu.

1140
00:56:05,580 --> 00:56:08,080
Tad mēs pieauguma i no 0 līdz 1.

1141
00:56:08,080 --> 00:56:11,290
Mēs pēc tam pārbauda, ​​ir 1 mazāks
par garumu s?

1142
00:56:11,290 --> 00:56:13,270
No s garums ir 6.

1143
00:56:13,270 --> 00:56:13,950
Jā, tā ir.

1144
00:56:13,950 --> 00:56:16,880
>> Tātad mēs drukāt A Zamyla vārdu, ZA.

1145
00:56:16,880 --> 00:56:20,090
Mēs pieauguma i no 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Mēs pēc tam pārbauda, ​​ir 2 mazāk nekā
garums Zamyla vārda.

1147
00:56:23,720 --> 00:56:25,380
6- tik 2 ir mazāks nekā 6.

1148
00:56:25,380 --> 00:56:30,460
Jā, pieņemsim izdrukāt tagad M in
Zamyla vārds, tad trešā zīme.

1149
00:56:30,460 --> 00:56:34,110
>> Galvenais šeit ir tāda, ka uz katru
atkārtojuma stāsts, es esmu pārbaudot,

1150
00:56:34,110 --> 00:56:37,810
ir tā, i mazāk nekā garumu Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Bet nozveju, ka
Stirling nav īpašums.

1152
00:56:40,350 --> 00:56:43,100
Tie no jums, kas ir ieprogrammēts
Pirms Java vai citās valodās

1153
00:56:43,100 --> 00:56:46,310
varētu zināt garumu virkne ir
īpašums, tikai daži lasīt tikai vērtību.

1154
00:56:46,310 --> 00:56:50,220
>> C, šajā gadījumā, ja tas ir
funkcija, kas ir burtiski

1155
00:56:50,220 --> 00:56:53,520
saskaitot
rakstzīmes Zamyla katru reizi

1156
00:56:53,520 --> 00:56:54,740
mēs saucam šo funkciju.

1157
00:56:54,740 --> 00:56:58,500
Katru reizi, kad jūs lūgt datoru lietošanā
Stirling, tas ir ņemot apskatīt Zamyla,

1158
00:56:58,500 --> 00:57:01,960
un saprotams, Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Un tas atgriež 6.

1160
00:57:02,962 --> 00:57:04,920
Nākamreiz, kad zvanīt
tā iekšā, ka cilpa,

1161
00:57:04,920 --> 00:57:08,610
tas notiek, lai apskatīt Zamyla
atkal, teiksim, Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Un tas notiek, lai atgrieztos 6.

1163
00:57:10,320 --> 00:57:12,980
Tātad, kas ir stulba par šo dizainu?

1164
00:57:12,980 --> 00:57:17,700
>> Kāpēc mans kods nav 5 no 5
dizaina tieši tagad, tāpēc runāt?

1165
00:57:17,700 --> 00:57:20,600
Nu, es esmu lūdzot
jautājums nevajadzīgi.

1166
00:57:20,600 --> 00:57:23,030
Es esmu dara vairāk darba, nekā man vajag.

1167
00:57:23,030 --> 00:57:25,370
>> Tātad, pat ja
atbilde ir pareiza, es esmu

1168
00:57:25,370 --> 00:57:29,560
lūdzot datoru, kas ir
garums Zamyla atkal,

1169
00:57:29,560 --> 00:57:31,380
un atkal, un atkal, un atkal?

1170
00:57:31,380 --> 00:57:33,980
Un šī atbilde ir
nekad gatavojas mainīt.

1171
00:57:33,980 --> 00:57:35,900
Tas vienmēr būs 6.

1172
00:57:35,900 --> 00:57:39,730
>> Tāpēc labāks risinājums nekā tas
būtu tas nākamais versija.

1173
00:57:39,730 --> 00:57:43,390
Ļaujiet man iet uz priekšu un nodot to
atsevišķs fails sauc string1.c,

1174
00:57:43,390 --> 00:57:44,990
tikai, lai saglabātu to atsevišķi.

1175
00:57:44,990 --> 00:57:47,260
Un izrādās A
cilpa, jūs faktiski var

1176
00:57:47,260 --> 00:57:50,210
deklarēt vairākas mainīgos uzreiz.

1177
00:57:50,210 --> 00:57:53,460
>> Tāpēc es esmu gatavojas glabāt i un noteikt to līdz 0.

1178
00:57:53,460 --> 00:57:56,190
Bet es esmu arī gatavojas
pievienot komatu, un saka,

1179
00:57:56,190 --> 00:58:01,050
man mainīgo sauc n, kuru
vērtība ir vienāda virknes garumu s.

1180
00:58:01,050 --> 00:58:09,410
Un tagad, lūdzu, savu stāvokli
tik ilgi, kamēr i ir mazāks nekā n.

1181
00:58:09,410 --> 00:58:14,140
>> Tātad šādā veidā, loģika ir
identisks beigās, dienā.

1182
00:58:14,140 --> 00:58:18,280
Bet es esmu atceroties
vērtība 6, šajā gadījumā.

1183
00:58:18,280 --> 00:58:19,780
Kas ir garums Zamyla vārda?

1184
00:58:19,780 --> 00:58:20,860
Un es varēšu to n.

1185
00:58:20,860 --> 00:58:23,050
>> Un es esmu joprojām pārbaudot
stāvoklis katru reizi.

1186
00:58:23,050 --> 00:58:24,300
Ir 0 mazāk nekā 6?

1187
00:58:24,300 --> 00:58:25,600
Ir 1 mazāk nekā 6?

1188
00:58:25,600 --> 00:58:28,600
Ir 2 mazāk nekā 6, un tā tālāk?

1189
00:58:28,600 --> 00:58:31,914
>> Bet es neesmu lūdzot datoru
atkal, un atkal, kas ir

1190
00:58:31,914 --> 00:58:33,080
garums Zamyla vārda?

1191
00:58:33,080 --> 00:58:34,320
Kas garums Zamyla vārda?

1192
00:58:34,320 --> 00:58:35,986
Kas garums šī Zamyla nosaukums?

1193
00:58:35,986 --> 00:58:40,440
Es burtiski atcerēties, ka pirmais un
atbildēt tikai šajā otrajā mainīgā n.

1194
00:58:40,440 --> 00:58:45,280
Tātad tagad tas būtu ne tikai
pareizi, bet arī labi izstrādāta.

1195
00:58:45,280 --> 00:58:46,670
>> Tagad, kas par stilu?

1196
00:58:46,670 --> 00:58:48,866
Es esmu nosaukts manu mainīgos
diezgan labi, es teiktu.

1197
00:58:48,866 --> 00:58:50,240
Viņi super kodolīgs tiesības tagad.

1198
00:58:50,240 --> 00:58:52,090
Un tas ir pilnīgi naudas sodu.

1199
00:58:52,090 --> 00:58:55,120
>> Ja jums ir tikai viens
string programmā,

1200
00:58:55,120 --> 00:58:56,860
Jūs varētu arī aicināt tas ir par virkni.

1201
00:58:56,860 --> 00:58:59,370
Ja jums ir tikai viens mainīgais
skaitīšanas programmā,

1202
00:58:59,370 --> 00:59:00,710
Jūs varētu arī aicināt to i.

1203
00:59:00,710 --> 00:59:03,500
Ja jums ir garums, n
ir super kopīgs, kā arī.

1204
00:59:03,500 --> 00:59:05,800
Bet es neesmu komentēja kāds manu kodu.

1205
00:59:05,800 --> 00:59:09,200
>> Man nav informējusi nolasītājs
vai tas ir mans TF, vai TA,

1206
00:59:09,200 --> 00:59:12,460
vai tikai colleague-- to, kas ir paredzēts
kas notiek šajā programmā.

1207
00:59:12,460 --> 00:59:15,760
Un tāpēc, lai iegūtu labu stilu,
ko es gribu darīt

1208
00:59:15,760 --> 00:59:24,580
ir this-- kaut
tāpat lūgt lietotāja ievadi.

1209
00:59:24,580 --> 00:59:26,670
Un es varētu pārrakstīt
Tas jebkurā vairākos veidos.

1210
00:59:26,670 --> 00:59:35,630
>> Pārliecinieties s-- pārliecinieties get
string atgriezās virkni.

1211
00:59:35,630 --> 00:59:40,280
Un pēc tam uz here-- un tas, iespējams,
vissvarīgākais comment-- atkārtot

1212
00:59:40,280 --> 00:59:44,450
pār rakstzīmes s vienā laikā.

1213
00:59:44,450 --> 00:59:47,060
Un es varētu izmantot jebkuru
izvēle angļu valodā

1214
00:59:47,060 --> 00:59:49,650
šeit aprakstīt katru
Šo gabalos kodu.

1215
00:59:49,650 --> 00:59:52,740
>> Ievērojiet, ka man nav likts
komentēt katru līnijas kodu,

1216
00:59:52,740 --> 00:59:55,690
tiešām tikai par interesantu
tiem, tie, kas

1217
00:59:55,690 --> 00:59:59,460
ir kāda nozīme, ka es varētu
gribu, lai super skaidrs, kāds

1218
00:59:59,460 --> 01:00:00,460
lasot manu kodu.

1219
01:00:00,460 --> 01:00:02,920
Un kāpēc jūs zvanot nokļūt
stīgu lūgt lietotājs ievadi?

1220
01:00:02,920 --> 01:00:05,450
Pat, ka viens nav obligāti
viss, kas aprakstošs.

1221
01:00:05,450 --> 01:00:09,340
Bet tas palīdz pastāstīt stāstu, jo
otrajā rindā stāstā ir, pārliecinieties,

1222
01:00:09,340 --> 01:00:10,740
saņemt string atgriezās virkni.

1223
01:00:10,740 --> 01:00:14,260
>> Un trešais rindā stāstā ir,
atkārtot pār rakstzīmes ir viens

1224
01:00:14,260 --> 01:00:15,380
laikā.

1225
01:00:15,380 --> 01:00:17,920
Un tagad tikai labu pasākumu,
Es iešu uz priekšu un pievienot

1226
01:00:17,920 --> 01:00:24,560
vēl viens komentārs, ka tikai
saka print i-th raksturs s.

1227
01:00:24,560 --> 01:00:26,520
Tagad, ko es esmu darījis
dienas beigās?

1228
01:00:26,520 --> 01:00:29,190
>> Man ir pievienoti daži English
vārdi formā komentārus.

1229
01:00:29,190 --> 01:00:32,700
Slīpsvītra slash simbols nozīmē, hey,
dators, tas ir par cilvēku,

1230
01:00:32,700 --> 01:00:33,820
nav par jums, dators.

1231
01:00:33,820 --> 01:00:35,119
Tātad viņi ignorēja loģiski.

1232
01:00:35,119 --> 01:00:35,910
Viņi tikai tur.

1233
01:00:35,910 --> 01:00:39,830
>> Un, protams, CS50 IDE parāda tos kā
pelēks, kā nozīmīgi, bet ne galvenais

1234
01:00:39,830 --> 01:00:41,000
programmai.

1235
01:00:41,000 --> 01:00:42,570
Paziņojums, ko jūs tagad var darīt.

1236
01:00:42,570 --> 01:00:44,950
Vai jūs zināt, C
programmēšanas vai ne, jūs

1237
01:00:44,950 --> 01:00:47,722
var vienkārši stāvēt atpakaļ pie šī
programma, un nosmelt komentārus.

1238
01:00:47,722 --> 01:00:50,180
Jautāt lietotājam ievadi, pārliecinieties,
saņemt string atgriezās virkne,

1239
01:00:50,180 --> 01:00:53,009
atkārtot pār rakstzīmes s
pa vienam, izdrukāt raksturs

1240
01:00:53,009 --> 01:00:55,550
i-th raksturs s-- jums nav
pat ir apskatīt kodu

1241
01:00:55,550 --> 01:00:57,270
saprast, ko šī programma dara.

1242
01:00:57,270 --> 01:01:00,280
Un, vēl labāk, ja jūs pats meklēt
šajā programmā nedēļu vai divas,

1243
01:01:00,280 --> 01:01:02,280
vai mēnesi, vai gadu,
jūs pārāk nav

1244
01:01:02,280 --> 01:01:04,420
skatās uz kodu,
mēģinot atcerēties,

1245
01:01:04,420 --> 01:01:06,630
kas bija man mēģina darīt ar šo kodu?

1246
01:01:06,630 --> 01:01:07,770
>> Jūs esat teicis pats.

1247
01:01:07,770 --> 01:01:11,660
Jūs esat aprakstīja to pats,
vai kādu kolēģis, vai TA, vai TF.

1248
01:01:11,660 --> 01:01:14,860
Un tā tas tagad būtu
pareizs, un labs dizains,

1249
01:01:14,860 --> 01:01:18,210
un galu galā labi stils, kā arī.

1250
01:01:18,210 --> 01:01:19,990
Tā darīt paturēt to prātā.

1251
01:01:19,990 --> 01:01:22,200
>> Tātad tur ir viens cits
lieta, ko es esmu gatavojas darīt šeit

1252
01:01:22,200 --> 01:01:28,240
ka tagad var atklāt tieši to, kas ir
notiek zem motora pārsega.

1253
01:01:28,240 --> 01:01:30,390
Tātad tur ir šī funkcija
C, kā arī citas valodas,

1254
01:01:30,390 --> 01:01:33,010
sauc Typecasting
ka vai nu netieši

1255
01:01:33,010 --> 01:01:37,250
vai nepārprotami ļauj pārvērst
no viena datu tipa uz citu.

1256
01:01:37,250 --> 01:01:39,800
Mēs esam nodarbojas tik
tālu šodien ar stīgām.

1257
01:01:39,800 --> 01:01:41,250
>> Un stīgas ir rakstzīmes.

1258
01:01:41,250 --> 01:01:44,910
Bet atceros no nedēļas
0, kādi ir varoņi?

1259
01:01:44,910 --> 01:01:49,334
Rakstzīmes ir tikai abstrakcija
virsū numbers-- aiz skaitļiem,

1260
01:01:49,334 --> 01:01:52,500
un zīmes aiz skaitļi ir patiešām tikai
abstrakcija virsū bināro numuru,

1261
01:01:52,500 --> 01:01:53,720
kā mēs definēts to.

1262
01:01:53,720 --> 01:01:55,540
>> Tātad rakstzīmes ir skaitļi.

1263
01:01:55,540 --> 01:01:58,410
Un skaitļi ir rakstzīmes,
tikai atkarībā no konteksta.

1264
01:01:58,410 --> 01:02:01,250
Un izrādās, ka iekšā
datorprogrammu,

1265
01:02:01,250 --> 01:02:06,830
Jūs varat norādīt, kā jūs vēlaties meklēt
pie biti iekšpusē šo programmu?

1266
01:02:06,830 --> 01:02:10,400
>> Atsaukt no nedēļas 0 ka mums bija
ASCII, kas ir tieši šis kods

1267
01:02:10,400 --> 01:02:11,620
kartēšanas vēstules numuru.

1268
01:02:11,620 --> 01:02:13,660
Un mēs teicām, kapitāls A ir 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B ir 66, un tā tālāk.

1270
01:02:15,860 --> 01:02:20,500
>> Un paziņojums, mēs būtībā ir chars uz
augšējā rindā šeit, jo C varētu viņiem piezvanīt,

1271
01:02:20,500 --> 01:02:23,400
rakstzīmes, un pēc tam
Ints par otrās rindas.

1272
01:02:23,400 --> 01:02:28,180
Un izrādās, jūs varat pārvērst
nemanāmi starp diviem, parasti.

1273
01:02:28,180 --> 01:02:30,042
Un, ja mēs vēlamies darīt
tas apzināti, mēs

1274
01:02:30,042 --> 01:02:31,750
varētu vēlēties, lai risinātu
kaut kas tamlīdzīgs.

1275
01:02:31,750 --> 01:02:33,590
>> Mēs varētu vēlēties, lai pārvērstu
lielie burti pazemināt

1276
01:02:33,590 --> 01:02:35,330
gadījumā, vai mazie burti uz lielajiem burtiem.

1277
01:02:35,330 --> 01:02:38,000
Un izrādās, tur ir
faktiski modelis šeit

1278
01:02:38,000 --> 01:02:39,900
mēs varam aptvert tikai brīdi.

1279
01:02:39,900 --> 01:02:44,120
Bet aplūkosim vispirms
Piemērs darot skaidri.

1280
01:02:44,120 --> 01:02:46,340
>> Es iešu atpakaļ CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Es esmu gatavojas, lai izveidotu
failu sauc ASCII 0.c.

1282
01:02:50,640 --> 01:02:55,960
Un es iešu uz priekšu un pievienot savu
standarta io.h augšpusē, int galvenais spēkā neesošu

1283
01:02:55,960 --> 01:02:57,370
augšpusē manu funkciju.

1284
01:02:57,370 --> 01:03:02,700
Un tad es esmu tikai gatavojas darīt
following-- A cilpu no i ir vienāds,

1285
01:03:02,700 --> 01:03:04,610
teiksim, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Un tad es būs mazāks nekā
65, plus 26 burti alfabēta.

1287
01:03:10,460 --> 01:03:12,640
Tāpēc es let datoru
do math par mani tur.

1288
01:03:12,640 --> 01:03:15,100
Un tad iekšā šīs cilpas,
Kas es esmu gatavojas izdrukāt?

1289
01:03:15,100 --> 01:03:19,230
>> % C ir% i slīpsvītru n.

1290
01:03:19,230 --> 01:03:21,290
Un tagad es gribu, lai kontaktdakšu divām vērtībām.

1291
01:03:21,290 --> 01:03:24,530
Es esmu uz laiku nodot jautājumu
iezīmē tur uzaicināt jautājumu.

1292
01:03:24,530 --> 01:03:29,940
>> Es vēlos atkārtot no 65 tālāk
26 alfabēta burtiem,

1293
01:03:29,940 --> 01:03:35,190
izdrukāšana par katru atkārtojuma ka
raksturs ir neatņemama ekvivalents.

1294
01:03:35,190 --> 01:03:38,299
Citiem vārdiem sakot, es gribu
atkārtot vairāk nekā 26 numuri drukāšanu

1295
01:03:38,299 --> 01:03:41,590
ko ASCII raksturs ir, burts,
un ko attiecīgais numurs is--

1296
01:03:41,590 --> 01:03:44,650
tiešām tikai atjaunošanās
diagramma no šī slaida.

1297
01:03:44,650 --> 01:03:47,010
Tātad, kādi ir šie jautājuma zīmes būt?

1298
01:03:47,010 --> 01:03:51,760
>> Nu, izrādās, ka otrajā
viens ir vienkārši mainīgais i.

1299
01:03:51,760 --> 01:03:53,860
Es gribu redzēt, ka par numuru.

1300
01:03:53,860 --> 01:03:58,920
Un vidū arguments
šeit, es varu pateikt datoru

1301
01:03:58,920 --> 01:04:03,470
ārstēt šo skaitli
es kā raksturs, tā kā

1302
01:04:03,470 --> 01:04:05,880
aizstāt to šeit C. procentiem

1303
01:04:05,880 --> 01:04:07,990
>> Citiem vārdiem sakot, ja es, tad
cilvēka programmētājs, zināt

1304
01:04:07,990 --> 01:04:09,865
tie ir tikai skaitļi
dienas beigās.

1305
01:04:09,865 --> 01:04:12,500
Un es zinu, ka 65 vajadzētu
karti uz kādu raksturu.

1306
01:04:12,500 --> 01:04:15,310
Ar šo skaidru vairākumu,
ar iekavās

1307
01:04:15,310 --> 01:04:18,840
nosaukums datu tipu, kuru vēlaties
konvertēt uz, un slēgtā iekavas,

1308
01:04:18,840 --> 01:04:21,200
jūs varat pateikt
dators, hey, dators,

1309
01:04:21,200 --> 01:04:24,130
pārvērst šo skaitli uz char.

1310
01:04:24,130 --> 01:04:26,250
>> Tātad, kad es palaist šo
programma pēc apkopojot,

1311
01:04:26,250 --> 01:04:29,740
pieņemsim redzēt, ko es get-- veikt ASCII 0.

1312
01:04:29,740 --> 01:04:33,020
Darn tas, ko es daru nepareizi šeit?

1313
01:04:33,020 --> 01:04:35,884
Izmantojiet nedeklarēta identifikatoru,
visas tiesības, kas nav tīši,

1314
01:04:35,884 --> 01:04:37,800
bet pieņemsim redzēt, ja mēs nevaram
Iemesls caur šo.

1315
01:04:37,800 --> 01:04:41,220
>> Tik line five-- tāpēc es nedabūju
ļoti tālu pirms skrūvēšanai up.

1316
01:04:41,220 --> 01:04:42,140
Tas ir labi.

1317
01:04:42,140 --> 01:04:46,560
Tātad line 5 i vienāds 65-- es redzu.

1318
01:04:46,560 --> 01:04:50,130
Tāpēc atcerieties, ka C, atšķirībā no dažiem
valodas, ja jums ir iepriekšēja programmēšana

1319
01:04:50,130 --> 01:04:52,190
pieredze, jums ir
pateikt datoru,

1320
01:04:52,190 --> 01:04:55,040
atšķirībā no nulles, ko
Mainīgā veids tas ir.

1321
01:04:55,040 --> 01:04:56,860
>> Un es aizmirsu par atslēgu frāze šeit.

1322
01:04:56,860 --> 01:04:59,200
Saskaņā pieci, es esmu sācis lietot i.

1323
01:04:59,200 --> 01:05:01,560
Bet es neesmu teicis C
kādi dati veida tā ir.

1324
01:05:01,560 --> 01:05:04,570
Tāpēc es esmu gatavojas iet šeit un
saka, ah, padara skaitlis.

1325
01:05:04,570 --> 01:05:07,050
>> Tagad es esmu gatavojas iet uz priekšu un recompile.

1326
01:05:07,050 --> 01:05:08,080
Tas nemainīgs.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, tas ir sava veida atdzist.

1328
01:05:12,660 --> 01:05:15,360
Ne tikai tas ir super ātri, lai
lūgt datoru šo jautājumu,

1329
01:05:15,360 --> 01:05:18,885
nevis meklē to uz slaidu,
tas izdrukāt vienu katrā rindā, A ir 65,

1330
01:05:18,885 --> 01:05:24,860
B ir 66, visu ceļu down-- kopš I
izdarīja 26 times-- ar burtiem z,

1331
01:05:24,860 --> 01:05:25,630
kas ir 90.

1332
01:05:25,630 --> 01:05:27,790
Un, patiesībā, nedaudz
vairāk viedo būtu

1333
01:05:27,790 --> 01:05:31,030
ir man nepaļauties
uz datora, lai pievienotu 26.

1334
01:05:31,030 --> 01:05:34,060
Es varētu būt tikko veikts
90, kā arī, tik ilgi

1335
01:05:34,060 --> 01:05:37,390
jo man nav darīt to pašu kļūdu divreiz.

1336
01:05:37,390 --> 01:05:41,880
Es gribu iet uz augšu cauri
z, ne tikai uz augšu pa y.

1337
01:05:41,880 --> 01:05:44,000
>> Tātad tas ir skaidri vairākumu.

1338
01:05:44,000 --> 01:05:47,860
Izrādās, ka šis
nav pat nepieciešams.

1339
01:05:47,860 --> 01:05:52,480
Ļaujiet man iet uz priekšu un atkārto šo
kompilatoru, un atkārto ASCII 0.

1340
01:05:52,480 --> 01:05:54,940
Izrādās, ka C ir diezgan gudrs.

1341
01:05:54,940 --> 01:05:57,150
>> Un printf, it īpaši,
ir diezgan gudrs.

1342
01:05:57,150 --> 01:06:01,260
Ja jūs vienkārši nokārtot i divreiz
gan vietturi, printf

1343
01:06:01,260 --> 01:06:04,510
sapratīs, oh, labi es jūs pazīstu
deva man integer-- kādu numuru,

1344
01:06:04,510 --> 01:06:06,380
piemēram, 65 vai 90, vai neatkarīgi.

1345
01:06:06,380 --> 01:06:10,170
Bet es redzu, ka jūs vēlaties, lai es
formatēt šo numuru, piemēram, raksturs.

1346
01:06:10,170 --> 01:06:16,460
Un tā printf varētu netieši nodot
int uz char jums, kā labi.

1347
01:06:16,460 --> 01:06:19,360
Tātad tas nav problēma vispār.

1348
01:06:19,360 --> 01:06:23,100
>> Bet paziņojums, jo šīs līdzvērtības
mēs faktiski var darīt, kā labi.

1349
01:06:23,100 --> 01:06:26,520
Ļaujiet man iet uz priekšu un veikt vienu
cita versija this-- ASCII 1.c

1350
01:06:26,520 --> 01:06:31,800
Un tā vietā, atkārtojot pār
veseli skaitļi, tiešām var trieciens jūsu prātā

1351
01:06:31,800 --> 01:06:33,610
atkārtojot pār rakstzīmes.

1352
01:06:33,610 --> 01:06:37,660
Ja char c saņem kapitāla A, I
gribu iet uz priekšu un darīt to,

1353
01:06:37,660 --> 01:06:41,740
tik ilgi, kamēr C ir mazāks par vai vienāds
Kapitāla Z. Un katra atkārtojuma

1354
01:06:41,740 --> 01:06:45,690
Es gribu pieauguma C, es varu
tagad manā printf līnija šeit

1355
01:06:45,690 --> 01:06:51,320
teiksim, C procenti ir
procenti i atkal, komats C.

1356
01:06:51,320 --> 01:06:57,200
>> Un tagad, es varu iet pretējā virzienā,
liešanas raksturu skaidri

1357
01:06:57,200 --> 01:06:58,500
līdz veselam skaitlim.

1358
01:06:58,500 --> 01:07:00,560
Tātad, atkal, kāpēc jūs darīt?

1359
01:07:00,560 --> 01:07:03,830
Tas ir nedaudz dīvaini, lai kārtotu no
skaits ziņā rakstzīmes.

1360
01:07:03,830 --> 01:07:07,430
>> Bet, ja jūs saprotat, kas ir
notiek zem motora pārsega,

1361
01:07:07,430 --> 01:07:08,430
tur tiešām nav maģija.

1362
01:07:08,430 --> 01:07:13,060
Jūs vienkārši sakot, hey, dators dod
me mainīgu sauc C tipa char.

1363
01:07:13,060 --> 01:07:16,520
Inicializēt to kapitāla A. And
ievērosiet vienu pēdiņām jautājumu.

1364
01:07:16,520 --> 01:07:19,580
>> Par rakstzīmes C, atceros no
pagājušajā nedēļā, jūs izmantojat vienu pēdiņas.

1365
01:07:19,580 --> 01:07:23,720
Virknes, vārdus,
frāzes, jūs izmantojat dubultās pēdiņas.

1366
01:07:23,720 --> 01:07:27,210
OK, dators, glabāt darot, tā
ilgi, kamēr raksturs ir mazāks nekā

1367
01:07:27,210 --> 01:07:28,050
vai vienāds ar z.

1368
01:07:28,050 --> 01:07:32,640
Un es zinu no mana ASCII tabulu, ka visi
Šo ascii kodu ir blakus.

1369
01:07:32,640 --> 01:07:33,400
>> Tur nav spraugu.

1370
01:07:33,400 --> 01:07:36,737
Tātad, tas ir tikai līdz Z,
atdalīti ar vienu skaitli katra.

1371
01:07:36,737 --> 01:07:38,820
Un tad es varu pieauguma
char, ja es tiešām gribu.

1372
01:07:38,820 --> 01:07:40,390
Dienas beigās,
tas ir tikai skaitlis.

1373
01:07:40,390 --> 01:07:41,030
Es zinu, tas.

1374
01:07:41,030 --> 01:07:43,670
Tāpēc es varu tikai pieņemt, lai pievienotu 1 līdz to.

1375
01:07:43,670 --> 01:07:46,940
>> Un tad šoreiz, es drukāt c,
un tad neatņemama ekvivalents.

1376
01:07:46,940 --> 01:07:50,170
Un man nav pat nepieciešams skaidru vairākumu.

1377
01:07:50,170 --> 01:07:52,680
Es varu ļaut printf un
dators skaitlis lietas,

1378
01:07:52,680 --> 01:07:57,300
tā, ka tagad, ja man palaist
padarīt Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Man tieši tas pats, kā arī.

1380
01:08:01,520 --> 01:08:04,530
>> Bezjēdzīgi programma, though-- neviens
gatavojas faktiski rakstīt programmatūru

1381
01:08:04,530 --> 01:08:07,549
lai noskaidrotu, kāda bija
skaitlis, kas kartes uz A vai B, vai Z?

1382
01:08:07,549 --> 01:08:10,340
Jūs tikai gatavojas Google to, vai
skatīties to tiešsaistē, vai meklēt to

1383
01:08:10,340 --> 01:08:11,650
uz priekšmetstikliņa, vai tamlīdzīgi.

1384
01:08:11,650 --> 01:08:13,520
Tātad, ja tas faktiski nokļūt noderīga?

1385
01:08:13,520 --> 01:08:15,960
>> Nu, runājot par ka
slaidu, paziņojums tur ir

1386
01:08:15,960 --> 01:08:20,890
faktiskā raksts šeit starp lielajiem burtiem
un mazie burti, kas nebija nejauša.

1387
01:08:20,890 --> 01:08:23,760
Ievērojiet, ka kapitāls A ir 65.

1388
01:08:23,760 --> 01:08:25,830
Mazie a ir 97.

1389
01:08:25,830 --> 01:08:29,649
Un cik tālu ir zemāks gadījums?

1390
01:08:29,649 --> 01:08:32,649
>> Tātad, 65 ir, cik daudz soļu attālumā no 97?

1391
01:08:32,649 --> 01:08:36,210
Tātad 97 mīnus 65 ir 32.

1392
01:08:36,210 --> 01:08:37,910
Tātad kapitāls a ir 65.

1393
01:08:37,910 --> 01:08:39,939
Ja pievienojat 32 tam,
jums mazajiem burtiem a.

1394
01:08:39,939 --> 01:08:43,729
Un, līdzvērtīgi, ja jūs atņemt 32,
jūs saņemsiet atpakaļ uz kapitāla izveidojuši lielisku pats ar B

1395
01:08:43,729 --> 01:08:46,380
uz nelielu b, liels C līdz maz c.

1396
01:08:46,380 --> 01:08:50,670
>> Visi šie nepilnības ir 32 intervālu.

1397
01:08:50,670 --> 01:08:54,450
Tagad, tas, šķiet, lai ļautu mums
kaut ko darīt, piemēram, Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
vai Google Docs iezīme, kur jūs
varat izvēlēties visu, un tad saka,

1399
01:08:57,729 --> 01:09:00,520
mainīt visu uz mazajiem burtiem, vai
mainīt visu uz lielajiem burtiem,

1400
01:09:00,520 --> 01:09:03,840
vai mainīt tikai pirmo vārdu
no soda ar lielajiem burtiem.

1401
01:09:03,840 --> 01:09:07,390
Mēs faktiski var darīt kaut ko
piemēram, ka mums pašiem.

1402
01:09:07,390 --> 01:09:12,645
>> Ļaujiet man iet uz priekšu un saglabātu failu
šeit sauc kapitalizēt 0.c.

1403
01:09:12,645 --> 01:09:15,770
Un iesim uz priekšu un pātagu up programmu
kas dara tieši ka šādi.

1404
01:09:15,770 --> 01:09:18,460
Tātad ietver CS50 bibliotēka.

1405
01:09:18,460 --> 01:09:21,430
Un ietver standarta I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Un es zinu, tas ir Drīzumā.

1407
01:09:22,787 --> 01:09:24,870
Tāpēc es esmu gatavojas nodot to
tur jau, string.h,

1408
01:09:24,870 --> 01:09:26,960
tāpēc man ir pieeja
lietas, piemēram, Stirling,

1409
01:09:26,960 --> 01:09:29,620
un tad int galvenais neesošu, kā parasti.

1410
01:09:29,620 --> 01:09:33,420
Un tad es iešu uz priekšu
un darīt virknes saņem saņemt virkni,

1411
01:09:33,420 --> 01:09:35,032
tikai, lai iegūtu virkni no lietotāja.

1412
01:09:35,032 --> 01:09:36,740
Un tad es esmu gatavojas
darīt mana veselība pārbaudi.

1413
01:09:36,740 --> 01:09:40,510
Ja virkne nav vienāds null,
tad tas ir droši, lai turpinātu.

1414
01:09:40,510 --> 01:09:42,000
Un ko darīt, es gribu darīt?

1415
01:09:42,000 --> 01:09:48,700
Es esmu gatavojas atkārtot no i ir vienāds ar 0,
un n līdz virknes garumu s.

1416
01:09:48,700 --> 01:09:51,899
>> Un es esmu gatavojas darīt to tik ilgi, kamēr
i ir mazāks nekā n, un es plus plus.

1417
01:09:51,899 --> 01:09:55,060
Līdz šim, es esmu patiešām tikai
aizņemoties idejas no iepriekš.

1418
01:09:55,060 --> 01:09:57,010
Un tagad es esmu gatavojas ieviest filiāli.

1419
01:09:57,010 --> 01:09:59,635
>> Tāpēc domāju, ka atpakaļ uz nulles, kur
mums bija šīs dakšas uz ceļa,

1420
01:09:59,635 --> 01:10:05,110
un pagājušajā nedēļā C. Es esmu gatavojas
saku, ja i-th raksturs s

1421
01:10:05,110 --> 01:10:09,250
ir lielāks par vai
vienāds ar mazajiem burtiem a,

1422
01:10:09,250 --> 01:10:13,340
and-- in nulles jūs varētu burtiski
saka un, bet C jūs sakāt ampersands,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- un i-th raksturs s
ir mazāks par vai vienāds ar pazeminātu case z,

1424
01:10:19,830 --> 01:10:21,780
pieņemsim darīt kaut ko interesantu.

1425
01:10:21,780 --> 01:10:27,020
Pieņemsim faktiski izdrukāt
raksturs bez newline

1426
01:10:27,020 --> 01:10:31,760
ka ir raksturs virknē,
i-th rakstura virkni.

1427
01:10:31,760 --> 01:10:37,420
>> Bet iesim uz priekšu un
atņemt 32 no tā.

1428
01:10:37,420 --> 01:10:42,120
Else ja rakstura
string ka mēs meklējam

1429
01:10:42,120 --> 01:10:45,950
nav starp maz a
un maz Z, iet uz priekšu

1430
01:10:45,950 --> 01:10:48,610
un tikko iespiests to ārā nemainīgs.

1431
01:10:48,610 --> 01:10:50,840
Tātad, mēs esam ieviesuši
šis strīdīgi notācija

1432
01:10:50,840 --> 01:10:53,560
lai mūsu virknes iegūt pie
i-th rakstura virkni.

1433
01:10:53,560 --> 01:10:57,520
>> Es esmu pievienojis kādu nosacītu loģiku, piemēram,
Scratch pagājušajā nedēļā nedēļu vienu, kur

1434
01:10:57,520 --> 01:10:59,880
Es esmu tikai izmantojot manu pamattiesību
izpratne par to, kas ir

1435
01:10:59,880 --> 01:11:01,130
notiek zem motora pārsega.

1436
01:11:01,130 --> 01:11:04,190
Vai i-th raksturs s
ir lielāks par vai vienāds ar simbolu?

1437
01:11:04,190 --> 01:11:08,290
Tāpat, tas ir 97, vai 98,
vai 99, un tā tālāk?

1438
01:11:08,290 --> 01:11:11,940
>> Bet tas ir arī mazāks par vai vienāds
vērtībai mazo z?

1439
01:11:11,940 --> 01:11:16,210
Un ja tā, ko tas līnija nozīmē?

1440
01:11:16,210 --> 01:11:20,250
14, tas ir sava veida
dīgļi visa ideja,

1441
01:11:20,250 --> 01:11:23,840
kapitalizēt vēstuli ar
vienkārši atņemot 32 no tā,

1442
01:11:23,840 --> 01:11:29,370
Šajā gadījumā, jo es zinu, uz vienu, ka
diagramma, kā mani numuri ir pārstāvētas.

1443
01:11:29,370 --> 01:11:33,925
So iesim uz priekšu un palaist to,
pēc apkopojot kapitalizēt 0.c,

1444
01:11:33,925 --> 01:11:36,210
un palaist kapitalizēt 0.

1445
01:11:36,210 --> 01:11:40,300
>> Let 's ierakstiet kaut ko līdzīgu
Zamyla visās mazajiem ienākt.

1446
01:11:40,300 --> 01:11:42,780
Un tagad mums ir Zamyla visās lielajiem burtiem.

1447
01:11:42,780 --> 01:11:45,050
Pieņemsim ierakstiet Rob visās mazajiem burtiem.

1448
01:11:45,050 --> 01:11:46,674
Pamēģināsim Jason visās mazajiem burtiem.

1449
01:11:46,674 --> 01:11:48,590
Un mēs turpinām iegūt
piespiedu kapitalizācija.

1450
01:11:48,590 --> 01:11:50,960
Tur ir neliela kļūda, ka es
veida nav paredzēt.

1451
01:11:50,960 --> 01:11:54,050
Paziņojums mana jaunā ātru beidzas up
uz vienas līnijas, kā to nosaukumiem,

1452
01:11:54,050 --> 01:11:55,520
kas jūtas mazliet netīrs.

1453
01:11:55,520 --> 01:11:59,170
>> Tāpēc es iešu šeit, un
faktiski beigās šīs programmas

1454
01:11:59,170 --> 01:12:02,110
izdrukāt newline raksturs.

1455
01:12:02,110 --> 01:12:03,160
Tas ir viss.

1456
01:12:03,160 --> 01:12:06,120
Ar printf, jums nav nepieciešams
caurlaide mainīgajiem vai formātā kodu.

1457
01:12:06,120 --> 01:12:08,460
Jūs varat burtiski vienkārši izdrukāt
kaut kā newline.

1458
01:12:08,460 --> 01:12:13,529
>> So iesim uz priekšu un veikt
kapitalizēt 0 atkal atkārto to, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Un tagad tas ir nedaudz prettier.

1460
01:12:14,820 --> 01:12:17,274
Tagad mans ātra ir savā jaunā rindā.

1461
01:12:17,274 --> 01:12:18,440
Tā ka viss ir labi un labs.

1462
01:12:18,440 --> 01:12:19,910
Tātad tas ir labs piemērs.

1463
01:12:19,910 --> 01:12:22,700
Bet man nav pat obligāti
nepieciešams cietā kodu no 32.

1464
01:12:22,700 --> 01:12:23,350
Tu zini ko?

1465
01:12:23,350 --> 01:12:26,350
Es varētu say-- man nav kādreiz
atcerēties, kāda ir atšķirība.

1466
01:12:26,350 --> 01:12:29,330
>> Bet es zinu, ka, ja es
ir mazo burtu,

1467
01:12:29,330 --> 01:12:34,430
Es būtībā gribu atņemt off
kāds attālums ir starp maz

1468
01:12:34,430 --> 01:12:39,160
a un liels, jo, ja es pieņemu, ka
visiem citiem burtiem, ir tāds pats,

1469
01:12:39,160 --> 01:12:41,045
ka vajadzētu iegūt darba darīts.

1470
01:12:41,045 --> 01:12:42,670
Bet nevis darīt, jūs zināt, ko?

1471
01:12:42,670 --> 01:12:44,240
Tur ir vēl viens veids, kā vēl.

1472
01:12:44,240 --> 01:12:48,090
>> Ja tas ir kapitalizēt 1.c-- ja es būtu
likt ka atsevišķā failā.

1473
01:12:48,090 --> 01:12:51,030
Darīsim kapitalizēt 2.c šādi.

1474
01:12:51,030 --> 01:12:53,060
Es esmu gatavojas tiešām attīrītu to šeit.

1475
01:12:53,060 --> 01:12:57,420
Un tā vietā, pat ņemot
zina vai rūp tiem zemā līmenī

1476
01:12:57,420 --> 01:13:01,090
īstenošanas detaļas, es esmu vietā
tikai gatavojas drukāt raksturs,

1477
01:13:01,090 --> 01:13:04,610
quote likt pēdiņas beigās, C procentiem, un
tad izsauktu citu funkciju,

1478
01:13:04,610 --> 01:13:09,950
pastāv, kas ņem argumentu,
kas ir raksturs, kā šis.

1479
01:13:09,950 --> 01:13:12,630
>> Izrādās C, tur ir
cita funkcija zvans

1480
01:13:12,630 --> 01:13:15,550
uz augšējo, kas, kā tā nosaukums
iesaka aizņem raksturs

1481
01:13:15,550 --> 01:13:19,350
un padara to uz lielajiem burtiem
ekvivalents, un tad nosūta atpakaļ

1482
01:13:19,350 --> 01:13:21,410
lai printf varētu pievienojiet to tur.

1483
01:13:21,410 --> 01:13:25,484
Un tā, kā to izdarīt, lai gan, es
nepieciešams ieviest vēl vienu failu.

1484
01:13:25,484 --> 01:13:28,400
Izrādās, tur ir cits fails
ka jūs zināt tikai no klases,

1485
01:13:28,400 --> 01:13:33,020
vai mācību grāmatas vai tiešsaistes
norāde, ko sauc par C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Tātad, ja es piebildīšu, ka pat starp manu galvu
failus, un tagad atkārtoti sastādīt šo programmu,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Pieņemsim ierakstiet Zamyla visās
mazie, joprojām darbojas vienādi.

1489
01:13:46,690 --> 01:13:48,040
Bet jūs zināt, ko?

1490
01:13:48,040 --> 01:13:55,590
Izrādās, ka uz augšējo
ir dažas citas funkcijas.

1491
01:13:55,590 --> 01:13:58,410
>> Un ļaujiet man iepazīstināt šis
komandu šeit, veida neveikli

1492
01:13:58,410 --> 01:14:00,250
nosaukts, bet cilvēks ar rokām.

1493
01:14:00,250 --> 01:14:03,960
Izrādās, ka lielākā daļa Linux datoriem,
kā mēs izmantojam here-- Linux operētājsistēmu

1494
01:14:03,960 --> 01:14:06,270
system-- ir komandu
sauc cilvēks, kas saka:

1495
01:14:06,270 --> 01:14:08,530
hey, datoru, dod man
datora rokasgrāmatu.

1496
01:14:08,530 --> 01:14:10,680
Ko jūs vēlaties
meklēt šajā rokasgrāmatā?

1497
01:14:10,680 --> 01:14:13,840
>> Es gribu uzmeklēt funkciju
aicināja augšējo, Enter.

1498
01:14:13,840 --> 01:14:16,070
Un tas ir nedaudz mistisks
lasīt reizēm.

1499
01:14:16,070 --> 01:14:18,780
Bet paziņojums mēs esi
Linux programmētājs rokasgrāmatu.

1500
01:14:18,780 --> 01:14:19,530
Un tas viss teksts.

1501
01:14:19,530 --> 01:14:21,905
Un ievērosiet, ka tur ir
Nosaukums funkcijas šeit.

1502
01:14:21,905 --> 01:14:25,030
Izrādās, tas ir brālēns sauc
pazemināt, kas dara pretējo.

1503
01:14:25,030 --> 01:14:29,710
Un paziņojums saskaņā konspekts, lai izmantotu šo
funkcionēt man dokumentu, tā sakot,

1504
01:14:29,710 --> 01:14:32,220
stāsta mani, ka es
nepieciešams iekļaut c type.h.

1505
01:14:32,220 --> 01:14:33,630
Un es zināju, ka no prakses.

1506
01:14:33,630 --> 01:14:36,210
>> Lūk, tas parāda man divi
prototipi par funkciju,

1507
01:14:36,210 --> 01:14:39,070
tā ka, ja es kādreiz vēlos izmantot šo
Es zinu, ko tās veic, kā ievade,

1508
01:14:39,070 --> 01:14:40,652
un ko viņi atgriežas kā produkciju.

1509
01:14:40,652 --> 01:14:42,360
Un tad, ja es izlasīju
apraksts, es redzu

1510
01:14:42,360 --> 01:14:44,820
sīkāk, kāda funkcija dara.

1511
01:14:44,820 --> 01:14:48,100
Bet vēl svarīgāk, ja
Es skatos zem atgriešanās vērtību,

1512
01:14:48,100 --> 01:14:51,710
tā saka vērtība atgriezās ir
ka konvertē vēstuli

1513
01:14:51,710 --> 01:14:57,880
vai C, sākotnējais ieguldījums, ja
konversija bija nav iespējams.

1514
01:14:57,880 --> 01:15:01,992
>> Citiem vārdiem sakot, lai augšējā centīšos
pārvērst vēstuli lielajiem burtiem.

1515
01:15:01,992 --> 01:15:03,450
Un ja tā, tas būs atpakaļ.

1516
01:15:03,450 --> 01:15:07,010
Bet, ja tā nevar dažiem reason--
varbūt tas jau lielie burti,

1517
01:15:07,010 --> 01:15:09,550
varbūt tas ir izsaukuma zīme
vai kādu citu punctuation--

1518
01:15:09,550 --> 01:15:12,200
tas ir tikai gatavojas
atgriezt sākotnējo C,

1519
01:15:12,200 --> 01:15:17,340
kas nozīmē, es varu darīt manu kodu
labāk izstrādāti šādi.

1520
01:15:17,340 --> 01:15:20,580
>> Man nav nepieciešams visu
šie darn rindas kodu.

1521
01:15:20,580 --> 01:15:22,610
Visas līnijas I noklikšķinājuši
tikko uzsvēra var

1522
01:15:22,610 --> 01:15:28,700
tikt sabruka tikai vienu vienkāršu
līnija, kas ir this-- printf procenti

1523
01:15:28,700 --> 01:15:33,510
c uz augšējo S grupā i.

1524
01:15:33,510 --> 01:15:36,090
Un tas būtu
piemērs labāku dizainu.

1525
01:15:36,090 --> 01:15:40,040
>> Kāpēc īstenot 7 vai 8 līnijām
kodu, kāds tas bija es tikai

1526
01:15:40,040 --> 01:15:44,960
izdzēsts, ja jūs varat, nevis sabrukt
visas šīs loģikas un lēmumu pieņemšanā

1527
01:15:44,960 --> 01:15:49,620
vienā rindā, 13 tagad, ka
balstās uz bibliotēku function--

1528
01:15:49,620 --> 01:15:53,430
funkcija, kas nāk ar C, bet
dara tieši to, ko vēlaties darīt.

1529
01:15:53,430 --> 01:15:55,295
Un, godīgi sakot, pat ja
tas nenāca ar C,

1530
01:15:55,295 --> 01:15:58,880
jūs varētu īstenot to pats, jo
mēs esam redzējuši, ar iegūtu negatīvu int

1531
01:15:58,880 --> 01:16:01,700
un saņemt pozitīvu int pagājušajā nedēļā, kā arī.

1532
01:16:01,700 --> 01:16:03,470
>> Šis kods tagad ir daudz vieglāk lasāmu.

1533
01:16:03,470 --> 01:16:06,670
Un, protams, ja mēs ritiniet uz augšu,
izskatās, cik daudz kompaktāka

1534
01:16:06,670 --> 01:16:08,360
šī versija mana programma ir.

1535
01:16:08,360 --> 01:16:11,230
Tas ir nedaudz smagnējās tagad,
ar visiem šiem ietver.

1536
01:16:11,230 --> 01:16:14,380
Bet tas ir OK, jo tagad es stāvu
uz pleciem programmētājiem

1537
01:16:14,380 --> 01:16:15,300
pirms manis.

1538
01:16:15,300 --> 01:16:18,440
Un kurš tas bija, kas
īstenoti, lai augšējā patiešām

1539
01:16:18,440 --> 01:16:21,470
darīja man labu, līdzīgi kurš
īstenoti Stirling patiešām

1540
01:16:21,470 --> 01:16:24,790
darīja man labu kādu laiku atpakaļ.

1541
01:16:24,790 --> 01:16:26,970
Un tāpēc tagad mums ir
labāks dizains programma

1542
01:16:26,970 --> 01:16:31,680
kas īsteno tieši tādu pašu loģiku.

1543
01:16:31,680 --> 01:16:35,580
>> Runājot par Stirling, ļaujiet
man iet uz priekšu un darīt to.

1544
01:16:35,580 --> 01:16:38,320
Ļaujiet man iet uz priekšu un saglabājiet
šis fails kā stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Un izrādās, mēs varam mizu atpakaļ
viena cita slāņa diezgan vienkārši tagad.

1546
01:16:43,255 --> 01:16:45,630
Es iešu uz priekšu un pātagu
līdz citai programmai galvenā

1547
01:16:45,630 --> 01:16:49,759
šeit vienkārši atkārtoti traktortehnikas
virknes garums šādi.

1548
01:16:49,759 --> 01:16:52,300
Tātad, šeit ir līnija kodu, kas
izpaužas man virknes no lietotāja.

1549
01:16:52,300 --> 01:16:53,910
Mēs pastāvīgi izmantojot šo atkal un atkal.

1550
01:16:53,910 --> 01:16:58,900
Ļaujiet man sniegt sev mainīgo sauc
n int tipa, kas saglabā numuru.

1551
01:16:58,900 --> 01:17:02,490
>> Un ļaujiet man iet uz priekšu un
rīkojieties šādi loģiku.

1552
01:17:02,490 --> 01:17:15,610
Kaut arī n-th raksturs s dara
nav vienāds slīpsvītru 0, iet uz priekšu

1553
01:17:15,610 --> 01:17:17,930
un pieauguma n.

1554
01:17:17,930 --> 01:17:23,506
Un tad izdrukāt printf procenti i n.

1555
01:17:23,506 --> 01:17:29,200
Es apgalvo, ka šī programma šeit,
neapstrīdot virknes garumu,

1556
01:17:29,200 --> 01:17:31,150
skaitļi, garumu virknes.

1557
01:17:31,150 --> 01:17:34,600
>> Un maģija ir pilnībā
iekapsulēti 8. līnijā

1558
01:17:34,600 --> 01:17:39,830
šeit ar to, kas izskatās jaunā sintaksi,
tas slīpsvītru 0 vienu pēdiņām.

1559
01:17:39,830 --> 01:17:41,360
Bet kāpēc tā?

1560
01:17:41,360 --> 01:17:44,100
Nu, apsvērt to, kas ir bijis
notiek visu šo laiku.

1561
01:17:44,100 --> 01:17:47,990
>> Un kā malā pirms es aizmirst, saprotu,
Arī, ka papildus cilvēks lapas

1562
01:17:47,990 --> 01:17:50,920
kas nāk ar tipisku
Linux sistēma kā CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
apzināties, ka mēs,
Protams darbinieki, ir arī

1564
01:17:53,770 --> 01:17:56,030
veica mājas versija
Šīs pašas idejas, ko sauc

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, kas ir
visiem šiem pašiem cilvēks lapas,

1566
01:17:59,940 --> 01:18:02,020
viss tas pats
dokumentācija, kā arī

1567
01:18:02,020 --> 01:18:05,730
nedaudz kaste augšpusē, kas ļauj
pārvērst visu iepriekš diezgan

1568
01:18:05,730 --> 01:18:09,025
arcane valodas mazāk apmierināti
režīms, kurā mēs, mācībspēki,

1569
01:18:09,025 --> 01:18:12,150
ir izgājušas cauri un mēģināja vienkāršot
daži no valodas, lai saglabātu lietas

1570
01:18:12,150 --> 01:18:14,830
vērsta uz idejām, un ne
daži no tehniskās.

1571
01:18:14,830 --> 01:18:20,070
Tāpēc paturiet prātā, reference.cs50.net
kā citu resursu, kā arī.

1572
01:18:20,070 --> 01:18:23,800
>> Bet kāpēc stīgu garuma darbu
kā es ierosināja pirms brīža?

1573
01:18:23,800 --> 01:18:25,160
Lūk Zamyla vārds atkal.

1574
01:18:25,160 --> 01:18:27,690
Un šeit ir Zamyla vārds
liekami, jo es glabāt darot,

1575
01:18:27,690 --> 01:18:31,360
uzzīmēt zīmējumu par to ko,
tiešām, tikai rakstzīmju sekvence.

1576
01:18:31,360 --> 01:18:34,260
Bet Zamyla neeksistē
izolēti raidījumā.

1577
01:18:34,260 --> 01:18:37,420
>> Kad jūs rakstīt un palaist programmu,
jūs izmantojat savu Mac vai jūsu datoru

1578
01:18:37,420 --> 01:18:40,010
kā atmiņu, vai RAM tā runāt.

1579
01:18:40,010 --> 01:18:42,620
Un jūs varat iedomāties
dators, kam ir

1580
01:18:42,620 --> 01:18:44,730
daudz gigabaitu atmiņas šajās dienās.

1581
01:18:44,730 --> 01:18:47,700
Un kabriolets nozīmē miljardiem,
tik miljardiem baitu.

1582
01:18:47,700 --> 01:18:48,910
>> Bet pieņemsim attīt laikā.

1583
01:18:48,910 --> 01:18:51,530
Un domāju, ka mēs esam izmantojot
patiešām vecs dators, kas

1584
01:18:51,530 --> 01:18:55,150
ir tikai 32 baiti atmiņas.

1585
01:18:55,150 --> 01:18:59,310
Es varētu, uz mana datora ekrāna,
vienkārši izdarīt šo veic šādi.

1586
01:18:59,310 --> 01:19:05,240
>> Es varētu vienkārši teikt, ka mana
dators ir visas šīs atmiņas.

1587
01:19:05,240 --> 01:19:08,830
Un tas ir kā stick atmiņas, ja
jūs atceraties mūsu attēlu no pēdējo reizi.

1588
01:19:08,830 --> 01:19:11,670
Un, ja es vienkārši sadalīt
tas pietiekami laikos,

1589
01:19:11,670 --> 01:19:15,040
Es apgalvot, ka man ir 32 baiti
atmiņas uz ekrāna.

1590
01:19:15,040 --> 01:19:18,239
>> Tagad, patiesībā, es varu tikai
izdarīt līdz šim šajā ekrānā šeit.

1591
01:19:18,239 --> 01:19:20,280
Tāpēc es esmu gatavojas iet uz priekšu,
un tikai pēc vienošanās,

1592
01:19:20,280 --> 01:19:24,050
izdarīt mana datora atmiņā kā
režģis, ne tikai kā vienu taisnu līniju.

1593
01:19:24,050 --> 01:19:28,190
Konkrēti, es apgalvot, ka šobrīd
tas režģis, šis 8. līdz 4 režģis,

1594
01:19:28,190 --> 01:19:31,800
vienkārši pārstāv visas 32 baiti
no pieejamās atmiņas manā Mac,

1595
01:19:31,800 --> 01:19:33,030
vai pieejams manā datorā.

1596
01:19:33,030 --> 01:19:34,780
Un viņi iesaiņošana
uz divām līnijām, tikai

1597
01:19:34,780 --> 01:19:38,030
jo tas iekļaujas vairāk uz ekrāna.

1598
01:19:38,030 --> 01:19:40,800
Bet tas ir pirmais baits.

1599
01:19:40,800 --> 01:19:41,990
Tas ir otrais baits.

1600
01:19:41,990 --> 01:19:43,300
Tas ir trešais baits.

1601
01:19:43,300 --> 01:19:45,310
>> Un tas ir 32. baitu.

1602
01:19:45,310 --> 01:19:52,910
Vai arī, ja mēs domājam līdzīgi datoru
zinātnieks, tas ir baits 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Tātad jums ir 0 līdz 31, ja
sākat skaitīšanas 0.

1604
01:19:55,950 --> 01:19:59,830
>> Tātad, ja mēs izmantot programmu
ka zvani get virkne,

1605
01:19:59,830 --> 01:20:05,280
un mēs iegūstam virkni no cilvēka
piemēram, I did sauc Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
cik pasaulē dara
dators izsekot, kuras baitu,

1607
01:20:09,430 --> 01:20:12,230
kas rieciens atmiņas,
pieder kurā virkne?

1608
01:20:12,230 --> 01:20:16,270
Citiem vārdiem sakot, ja mēs turpinām
ierakstiet citu nosaukumu datorā,

1609
01:20:16,270 --> 01:20:19,890
patīk šī Andi, aicinot
saņemt string otrreiz,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I ir līdz nonāk
Datora atmiņa, kā arī.

1611
01:20:23,030 --> 01:20:23,850
Bet kā?

1612
01:20:23,850 --> 01:20:29,700
>> Nu, izrādās, ka zem sadaļas
nosūcējs, ko C dara uzglabājot stīgas

1613
01:20:29,700 --> 01:20:35,080
ka cilvēka veidiem, vai ka
nāk no kāda cita avota, tas ir

1614
01:20:35,080 --> 01:20:39,190
attēlo galu no tām ar
īpašs character-- reversā slīpsvītra

1615
01:20:39,190 --> 01:20:44,750
0, kas ir tikai īpašs veids
no sakot 80 biti pēc kārtas.

1616
01:20:44,750 --> 01:20:47,950
>> Tāpēc izveidojuši lielisku tas ir skaitlis 97 atsaukšana.

1617
01:20:47,950 --> 01:20:51,770
Tāpēc daži modelis 8 biti
apzīmē Decimālskaitli 97.

1618
01:20:51,770 --> 01:20:58,070
Tas slīpsvītru 0 ir burtiski skaits
0, pazīstams arī kā Nul, N-U-L, atšķirībā no agrāk,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, kurā mēs runājām.

1620
01:20:59,630 --> 01:21:05,700
Bet tagad, tikai zinu, ka tas
slīpsvītru 0 ir tikai 80 bitu pēc kārtas.

1621
01:21:05,700 --> 01:21:09,810
>> Un tas ir tikai šī līnija
smilts, kas saka kaut ko pa kreisi

1622
01:21:09,810 --> 01:21:12,610
pieder vienam auklas, vai vienu datu tipu.

1623
01:21:12,610 --> 01:21:15,480
Un kaut kas pa labi
pieder kaut ko citu.

1624
01:21:15,480 --> 01:21:17,440
Andi vārds, tikmēr,
kas tikai vizuāli

1625
01:21:17,440 --> 01:21:21,310
notiek ar wrap uz otras līnijas,
bet tas ir tikai estētiska detaļa,

1626
01:21:21,310 --> 01:21:23,990
tāpat tiek Nul izbeigta.

1627
01:21:23,990 --> 01:21:29,290
>> Tas ir string of a A-N-D-I burtiem,
plus piektais noslēpums raksturs,

1628
01:21:29,290 --> 01:21:33,560
visas 0 biti, kas vienkārši norobežo
beigām Andi vārda, kā arī.

1629
01:21:33,560 --> 01:21:37,120
Un, ja mēs saucam saņemt string trešo reizi
ar datoru, lai iegūtu virkni, piemēram,

1630
01:21:37,120 --> 01:21:44,210
Maria M-A-R-I-A, kas līdzīgi Maria s
vārds Nul izbeigts ar slīpsvītru 0.

1631
01:21:44,210 --> 01:21:47,170
>> Tas ir būtiski atšķiras
no kā dators būtu tipiski

1632
01:21:47,170 --> 01:21:51,850
uzglabāt ir vesels skaitlis, vai iegremdēšanu, vai cits
datu tipi joprojām, jo ​​atsaukšanu,

1633
01:21:51,850 --> 01:21:57,420
vesels skaitlis, kas parasti ir 32 biti, vai
4 baiti, vai varbūt pat 64 biti,

1634
01:21:57,420 --> 01:21:59,100
vai astoņi baiti.

1635
01:21:59,100 --> 01:22:02,620
Bet daudzi primitīvi ar datoru
kādā programmēšanas valodā

1636
01:22:02,620 --> 01:22:05,550
ir noteiktu skaitu
baiti zem hood--

1637
01:22:05,550 --> 01:22:08,100
varbūt 1, varbūt 2, varbūt 4, varbūt 8.

1638
01:22:08,100 --> 01:22:13,250
>> Bet stīgas, dizains, ir
dinamiskā rakstzīmju skaits.

1639
01:22:13,250 --> 01:22:16,980
Jūs nezināt jau iepriekš, līdz
cilvēka veidi Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
vai M-A-R-I-A, vai A-N-D-I. Jūs nezināt
cik reizes lietotājs gatavojas hit

1641
01:22:21,400 --> 01:22:22,070
tastatūra.

1642
01:22:22,070 --> 01:22:26,490
Tāpēc, jūs nezināt, kā
daudz rakstzīmes iepriekš

1643
01:22:26,490 --> 01:22:27,540
Jums būs nepieciešama.

1644
01:22:27,540 --> 01:22:31,840
>> Un tā C tikko veida atstāj Like
noslēpums atpakaļceļa zem pārsega

1645
01:22:31,840 --> 01:22:32,960
beigās virkni.

1646
01:22:32,960 --> 01:22:39,280
Pēc tam, kad uzglabāšanas Z-A-M-Y-L-A atmiņā,
tas arī tikai liek ekvivalentu

1647
01:22:39,280 --> 01:22:40,210
ilgu laika posmu.

1648
01:22:40,210 --> 01:22:45,060
Beigās teikuma,
tas liek 80 bitiem, lai

1649
01:22:45,060 --> 01:22:49,120
atcerēties, kur
Zamyla sākas un beidzas.

1650
01:22:49,120 --> 01:22:51,490
>> Tātad, kas ir savienojums,
Pēc tam, lai šo programmu?

1651
01:22:51,490 --> 01:22:55,190
Šī programma šeit, Stirling,
ir vienkārši mehānisms

1652
01:22:55,190 --> 01:22:57,970
lai iegūtu virkni
no lietotāja, līnija 6.

1653
01:22:57,970 --> 01:23:01,160
7. līnija, es apliecinu mainīgo
dēvētais N un noteikt to vienāds ar 0.

1654
01:23:01,160 --> 01:23:08,680
>> Un tad 8. līniju, es vienkārši lūdza
jautājums, bet n-th raksturs dara

1655
01:23:08,680 --> 01:23:12,120
nav vienāds visiem 0 bits--
citiem vārdiem sakot, tas nav

1656
01:23:12,120 --> 01:23:14,500
vienāds šis īpašais
raksturs, slīpsvītru 0, kas

1657
01:23:14,500 --> 01:23:18,470
bija tikai, ka īpaša Nul character--
iet uz priekšu un tikai pieauguma n.

1658
01:23:18,470 --> 01:23:21,460
>> Un saglabāt to dara, un saglabāt
to dara, un saglabāt to dara.

1659
01:23:21,460 --> 01:23:23,430
Un tā kaut arī
pagātne, mēs esam izmanto i,

1660
01:23:23,430 --> 01:23:25,181
tas ir pilnīgi naudas sodu
semantiski izmantot n,

1661
01:23:25,181 --> 01:23:27,430
ja jūs vienkārši mēģināt
rēķināties šoreiz apzināti,

1662
01:23:27,430 --> 01:23:28,720
un vienkārši vēlaties, lai izsauktu to n.

1663
01:23:28,720 --> 01:23:34,720
Tātad tas tikai tur, uzdodot jautājumu,
ir n-tais raksturs viss 0s?

1664
01:23:34,720 --> 01:23:38,470
Ja nē, skatīties uz nākamo izskatu,
skatīties uz nākamo, skatīties uz nākamo,

1665
01:23:38,470 --> 01:23:39,460
skatīties uz nākamo.

1666
01:23:39,460 --> 01:23:45,540
>> Bet, tiklīdz jūs redzēt slīpsvītru 0,
Tas loop-- line 9 līdz 11-- apstājas.

1667
01:23:45,540 --> 01:23:49,640
Jūs izcelties no kamēr cilpa,
atstājot iekšpusē šī mainīgā n

1668
01:23:49,640 --> 01:23:54,530
kopējais skaits no visa
rakstzīmes jūs redzēja virknes,

1669
01:23:54,530 --> 01:23:55,660
tādējādi drukājot to ārā.

1670
01:23:55,660 --> 01:23:56,760
Tātad, pieņemsim mēģināt šo.

1671
01:23:56,760 --> 01:23:59,500
>> Ļaujiet man iet uz priekšu un, bez
izmantojot Stirling funkciju,

1672
01:23:59,500 --> 01:24:04,240
bet tikai izmantojot savu pašražoto versiju
šeit sauc Stirling, ļaujiet man iet uz priekšu

1673
01:24:04,240 --> 01:24:07,700
un palaist Stirling, ierakstiet kaut ko
piemēram Zamyla, ko es zinu iepriekš

1674
01:24:07,700 --> 01:24:08,670
ir sešas rakstzīmes.

1675
01:24:08,670 --> 01:24:10,080
Let 's redzēt, ja tā darbojas.

1676
01:24:10,080 --> 01:24:10,920
Patiešām, tas ir seši.

1677
01:24:10,920 --> 01:24:15,257
Pamēģināsim ar Rob, trīs rakstzīmes,
trīs rakstzīmes, kā arī, un tā tālāk.

1678
01:24:15,257 --> 01:24:17,340
Tātad tas ir viss, kas notiek
uz zem motora pārsega.

1679
01:24:17,340 --> 01:24:19,548
Un paziņojums savienojumus,
pēc tam, ar pirmajā nedēļā

1680
01:24:19,548 --> 01:24:22,370
klases, kur mēs runājām par
kaut kā abstrakcijas,

1681
01:24:22,370 --> 01:24:26,960
kas ir tikai šis noslāņojums idejas, vai
sarežģītība, virsū pamatprincipiem.

1682
01:24:26,960 --> 01:24:30,710
Lūk, mēs esam sava veida meklē
zem pārsega Stirling,

1683
01:24:30,710 --> 01:24:33,510
tā teikt, izdomāt,
kā tā īstenos?

1684
01:24:33,510 --> 01:24:35,232
>> Un mēs varētu vēlreiz īstenot sevi.

1685
01:24:35,232 --> 01:24:37,440
Bet mēs nekad atkal dodas
atkārtoti ieviest Stērlingas.

1686
01:24:37,440 --> 01:24:39,780
Mēs esam tikai gatavojas
izmantot Stērlingas secībā

1687
01:24:39,780 --> 01:24:42,100
lai faktiski saņemtu kādu virknes garumu.

1688
01:24:42,100 --> 01:24:44,200
>> Bet tur nav burvju
zem motora pārsega.

1689
01:24:44,200 --> 01:24:46,716
Ja jūs zināt, ka zem
kapuci, stīgu

1690
01:24:46,716 --> 01:24:48,090
ir tikai rakstzīmju secība.

1691
01:24:48,090 --> 01:24:51,090
Un ka rakstzīmju secība
visu var skaitliski risināt

1692
01:24:51,090 --> 01:24:53,330
ar kronšteinu 0, kronšteinu
1, kronšteins 2, un tu

1693
01:24:53,330 --> 01:24:57,420
zinu, ka beigās string ir
īpašo raksturu, jūs varat izdomāt

1694
01:24:57,420 --> 01:25:01,710
kā to izdarīt visvairāk neko tādā
programma, jo visi tā vārīties uz leju, lai

1695
01:25:01,710 --> 01:25:03,400
ir lasīšanas un rakstīšanas atmiņa.

1696
01:25:03,400 --> 01:25:06,130
Tas ir, mainās un meklē
pie atmiņas, vai pārvietojas lietas

1697
01:25:06,130 --> 01:25:10,940
ap atmiņā, drukas lietas
uz ekrāna, un tā tālāk.

1698
01:25:10,940 --> 01:25:14,800
>> Tātad, pieņemsim, tagad izmantot šo jaunatklāto
izpratne par to, kas patiesībā stīgas

1699
01:25:14,800 --> 01:25:17,910
ir zem motora pārsega, un
Noplēsiet vienu citu slāni

1700
01:25:17,910 --> 01:25:20,080
ka līdz šim mēs esam
tika ignorējot vispār.

1701
01:25:20,080 --> 01:25:22,650
Jo īpaši, jebkurā laikā
mēs esam ieviesuši programmu,

1702
01:25:22,650 --> 01:25:25,930
mēs esam bija šo rindiņu kodu
augšdaļā deklarējot galvenais.

1703
01:25:25,930 --> 01:25:27,810
Un mēs esam norādīts int galvenais tukšumu.

1704
01:25:27,810 --> 01:25:31,240
>> Un tas nav spēkā iekšpusē iekavās
ir teicis visu šo laiku, ka galvenais

1705
01:25:31,240 --> 01:25:33,440
pati neveic nekādus argumentus.

1706
01:25:33,440 --> 01:25:36,210
Jebkurš ieguldījums, ka galvenais ir
notiek, lai saņemtu no lietotāja

1707
01:25:36,210 --> 01:25:39,020
ir jānāk no kāda cita
mehānisms, tāpat get int,

1708
01:25:39,020 --> 01:25:42,040
vai saņemt peldēt, vai arī saņemt virkni,
vai kādu citu funkciju.

1709
01:25:42,040 --> 01:25:44,710
Bet izrādās, ka
kad jūs uzrakstīt programmu,

1710
01:25:44,710 --> 01:25:47,690
jūs faktiski var norādīt
ka šī programma veic

1711
01:25:47,690 --> 01:25:51,730
veikt ieguldījumus no cilvēka
tajā pašā komandrindas.

1712
01:25:51,730 --> 01:25:56,310
>> Citiem vārdiem sakot, pat ja mēs līdz šim
ir vadījusi tikai ./hello sveiki

1713
01:25:56,310 --> 01:26:00,312
vai līdzīgas programmas, visi no
citas programmas, kas mēs esam, izmantojot,

1714
01:26:00,312 --> 01:26:02,770
ka mēs paši nav rakstīt,
ir lietojis, šķiet,

1715
01:26:02,770 --> 01:26:05,210
komandrindas arguments--
lietas, piemēram, marka.

1716
01:26:05,210 --> 01:26:07,450
Jūs sakāt, kaut ko līdzīgu marku,
un pēc tam otrais vārds.

1717
01:26:07,450 --> 01:26:10,950
Vai šķindēt, jūs sakāt šķindēt, un pēc tam
otrais vārds, nosaukums failu.

1718
01:26:10,950 --> 01:26:14,410
>> Vai pat RM vai CP, kā jūs varētu
ir redzējuši vai izmantot jau

1719
01:26:14,410 --> 01:26:15,880
lai novērstu vai kopēt failus.

1720
01:26:15,880 --> 01:26:18,920
Visi no tiem, veikt tā saukto
komandrindas arguments--

1721
01:26:18,920 --> 01:26:21,130
papildu vārdi pie termināla ātri.

1722
01:26:21,130 --> 01:26:23,260
Bet līdz šim, mēs
paši nav bijis

1723
01:26:23,260 --> 01:26:27,080
šī luksusa ņemt ieguldījumu no
lietotāju, kad viņš vai viņa tiešām iet

1724
01:26:27,080 --> 01:26:29,120
pati programma pie komandrindas.

1725
01:26:29,120 --> 01:26:33,710
>> Bet mēs varam darīt, ka, atkārtoti paziņojot,
Galvenais virzās uz priekšu, nevis kā ar

1726
01:26:33,710 --> 01:26:36,750
neesošu iekavās,
bet šie divi argumenti

1727
01:26:36,750 --> 01:26:40,600
instead-- pirmo veselam skaitlim,
un otrs kaut kas

1728
01:26:40,600 --> 01:26:44,170
jauns, kaut kas, ka mēs ejam, lai izsauktu
masīvs, kaut kas līdzīgs garā

1729
01:26:44,170 --> 01:26:49,220
to, ko mēs redzējām Scratch kā sarakstu, bet
masīvs stīgas, kā mēs drīz redzēt.

1730
01:26:49,220 --> 01:26:51,790
Bet pieņemsim redzēt šo,
Piemēram, pirms mēs

1731
01:26:51,790 --> 01:26:53,690
atšķirt tieši to, ko tas nozīmē.

1732
01:26:53,690 --> 01:26:56,520
>> Tātad, ja es iedziļināties CS50 IDE
šeit, es esmu gājusi uz priekšu

1733
01:26:56,520 --> 01:27:01,840
un paziņoja failā ar nosaukumu
argv0.c šādu veidni.

1734
01:27:01,840 --> 01:27:04,120
Un paziņojums vienīgā lieta
tas ir atšķirīgs tik tālu

1735
01:27:04,120 --> 01:27:08,570
ir tas, ka es esmu mainījies par spēkā neesošu, int
argc string argv atvērta kronšteinu, close

1736
01:27:08,570 --> 01:27:09,070
kronšteins.

1737
01:27:09,070 --> 01:27:11,730
Un paziņojums tagad, tur ir
nekas iekšpusē šiem iekavās.

1738
01:27:11,730 --> 01:27:12,620
>> Nav numuru.

1739
01:27:12,620 --> 01:27:15,070
Un tur nav i, vai
n, vai jebkuru citu burtu.

1740
01:27:15,070 --> 01:27:17,010
Es esmu tikai izmantojot
kvadrātiekavas tagad,

1741
01:27:17,010 --> 01:27:19,510
iemeslu dēļ, mēs būsim
atpakaļ tikai brīdi.

1742
01:27:19,510 --> 01:27:21,330
>> Un tagad to, ko es esmu gatavojas darīt, ir šis.

1743
01:27:21,330 --> 01:27:26,680
Ja argc vienāds vienāds 2--
un atgādina, ka vienāds vienāds

1744
01:27:26,680 --> 01:27:30,040
ir vienlīdzība operators salīdzinot
pa kreisi un pa labi uz vienlīdzību.

1745
01:27:30,040 --> 01:27:31,790
Tas nav uzdevums
operators, kas ir

1746
01:27:31,790 --> 01:27:36,510
vienotais vienādības zīmi, kas nozīmē, kopiju
no labās uz kreiso pusi kādu vērtību.

1747
01:27:36,510 --> 01:27:42,840
>> Ja argc vienāds vienāds 2, es gribu
teiksim, printf, hello, procenti, jauna līnija,

1748
01:27:42,840 --> 01:27:47,340
un pēc tam pievienojiet in-- un šeit ir jauns
trick-- argv kronšteins 1, tādu iemeslu dēļ,

1749
01:27:47,340 --> 01:27:48,840
ka mēs būsim atpakaļ uz brīdi.

1750
01:27:48,840 --> 01:27:52,110
Cits, ja argc nav
vienāds 2, jūs zināt, ko?

1751
01:27:52,110 --> 01:27:57,400
Pieņemsim tikai iet uz priekšu un, kā parasti, drukāt
out hello world bez aizstāšanas.

1752
01:27:57,400 --> 01:28:02,710
>> Tāpēc šķiet, ka, ja argc, kas
stendi arguments skaits, ir vienāds ar 2,

1753
01:28:02,710 --> 01:28:04,740
Es esmu gatavojas izdrukāt
sveiki kaut vai otru.

1754
01:28:04,740 --> 01:28:07,560
Pretējā gadījumā, pēc noklusējuma, es esmu
nodots drukāšanai sveiki pasauli.

1755
01:28:07,560 --> 01:28:08,770
Tātad, ko tas nozīmē?

1756
01:28:08,770 --> 01:28:15,550
>> Nu, ļaujiet man iet uz priekšu un saglabājiet
šo failu, un pēc tam to dara argv0,

1757
01:28:15,550 --> 01:28:18,940
un tad ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Un tā saka sveiki pasaule.

1759
01:28:20,300 --> 01:28:21,260
Tagad, kāpēc tā?

1760
01:28:21,260 --> 01:28:24,730
>> Nu, izrādās, jebkurā laikā
palaist programmu pie komandrindas,

1761
01:28:24,730 --> 01:28:29,570
jūs aizpildīt, ko mēs
parasti sauc argumentu vektors.

1762
01:28:29,570 --> 01:28:33,100
Citiem vārdiem sakot, automātiski
dators, operētājsistēma,

1763
01:28:33,100 --> 01:28:38,340
gatavojas nodot ar savu programmu
pats saraksts visiem vārdiem

1764
01:28:38,340 --> 01:28:40,850
ka cilvēka ievadījis pie
ātru, ja jūs

1765
01:28:40,850 --> 01:28:43,790
programmētājs vēlas darīt
kaut kas ar šo informāciju.

1766
01:28:43,790 --> 01:28:48,540
Un šajā gadījumā, ir vienīgais vārds
Esmu drukāti pie uzvednē ir ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Un to skaits argumentus, kas ir
tiek nodota mana programma ir tikai viens.

1768
01:28:55,420 --> 01:28:58,880
Citiem vārdiem sakot, arguments
skaits, citādi zināma kā argc

1769
01:28:58,880 --> 01:29:00,970
šeit kā vesels skaitlis, ir tikai viens.

1770
01:29:00,970 --> 01:29:03,000
Viens, protams, nav vienāds divi.

1771
01:29:03,000 --> 01:29:05,980
Un tā tas ir tas, kas drukā, hello pasauli.

1772
01:29:05,980 --> 01:29:08,170
>> Bet ļaujiet man izmantot šo kaut kur.

1773
01:29:08,170 --> 01:29:09,930
Ļaujiet man teikt, argv0.

1774
01:29:09,930 --> 01:29:12,740
Un tad kā par Maria?

1775
01:29:12,740 --> 01:29:14,990
Un pēc tam hit Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Un paziņojums, kas maģiski notiek šeit.

1777
01:29:18,020 --> 01:29:22,640
Tagad, nevis Hello World, man ir
mainīja uzvedību šīs programmas

1778
01:29:22,640 --> 01:29:26,310
ņemot ievades nevis no get
string vai kādu citu funkciju,

1779
01:29:26,310 --> 01:29:30,570
bet no, acīmredzot, mana komanda
pati, ko es sākotnēji drukāti.

1780
01:29:30,570 --> 01:29:35,720
Un es varu spēlēt šo spēli atkal
mainot to Stelios, piemēram.

1781
01:29:35,720 --> 01:29:38,400
>> Un tagad es redzu citu nosaukumu joprojām.

1782
01:29:38,400 --> 01:29:40,540
Un šeit, es varētu teikt Andi.

1783
01:29:40,540 --> 01:29:42,137
Un es varētu teikt Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Un mēs varam spēlēt šo spēli visas dienas garumā,
vienkārši tapām dažādām vērtībām,

1785
01:29:45,220 --> 01:29:49,550
tik ilgi, kamēr es sniegt tieši
divi vārdi pie ātru,

1786
01:29:49,550 --> 01:29:52,260
tā, ka argc, mans arguments skaits ir 2.

1787
01:29:52,260 --> 01:29:57,240
>> Es redzu, ka vārds iesprausts
printf, par šī nosacījuma šeit?

1788
01:29:57,240 --> 01:30:00,550
Tāpēc mēs, šķiet, esam tagad
ekspresīvā spējas

1789
01:30:00,550 --> 01:30:04,410
ņemt datus no citu mehānismu,
no tā sauktās komandrindas,

1790
01:30:04,410 --> 01:30:07,000
nevis jāgaida
līdz lietotājs palaiž programmu,

1791
01:30:07,000 --> 01:30:10,220
un tad ātri viņu
izmantojot kaut ko līdzīgu get virkni.

1792
01:30:10,220 --> 01:30:11,230
>> Tātad, kas tas ir?

1793
01:30:11,230 --> 01:30:15,010
Argc, atkal, ir tikai skaitlis,
skaits words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
ka lietotājs ar nosacījumu, pie
ātra, pie termināla logā,

1795
01:30:18,540 --> 01:30:20,110
tai skaitā programmas nosaukumu.

1796
01:30:20,110 --> 01:30:23,340
Tātad mūsu ./argv0 ir, faktiski,
ka programmas nosaukums,

1797
01:30:23,340 --> 01:30:24,520
vai kā es palaist programmu.

1798
01:30:24,520 --> 01:30:25,810
>> Tas skaitās kā vārdu.

1799
01:30:25,810 --> 01:30:27,080
Tātad argc būtu 1.

1800
01:30:27,080 --> 01:30:29,750
Bet, kad es rakstīt Stelios, vai
Andi, vai Zamyla vai Maria,

1801
01:30:29,750 --> 01:30:31,660
tas nozīmē, ka arguments skaits ir divi.

1802
01:30:31,660 --> 01:30:33,910
Un tāpēc tagad tur ir divi pagāja vārdos.

1803
01:30:33,910 --> 01:30:36,070
>> Un paziņojums, mēs varam turpināt šo loģiku.

1804
01:30:36,070 --> 01:30:39,050
Ja es tiešām saku
kaut kas līdzīgs Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
pilns vārds, tādējādi iet
trīs argumentus kopā,

1806
01:30:42,200 --> 01:30:47,410
tagad tā saka noklusējuma atkal,
jo, protams, 3. nav vienāds 2.

1807
01:30:47,410 --> 01:30:54,080
>> Un tā šādā veidā, man ir
Pieeja caur argv šis jaunais arguments

1808
01:30:54,080 --> 01:30:56,080
ka mēs varētu tehniski
zvaniet kaut mēs gribam.

1809
01:30:56,080 --> 01:30:58,940
Bet pēc vienošanās, tas ir
argv un argc, attiecīgi.

1810
01:30:58,940 --> 01:31:04,470
Argv, arguments vektors, ir sava veida
par sinonīmu programmēšanas

1811
01:31:04,470 --> 01:31:07,140
iezīme C sauc masīvs.

1812
01:31:07,140 --> 01:31:14,410
>> Masīvs ir saraksts ar līdzīgām vērtībām
atpakaļ, atpakaļ, atpakaļ, uz muguras.

1813
01:31:14,410 --> 01:31:17,810
Citiem vārdiem sakot, ja viens ir tepat
RAM, nākamais ir tieši blakus tai,

1814
01:31:17,810 --> 01:31:18,800
un blakus tai.

1815
01:31:18,800 --> 01:31:20,101
Viņi ne visā vietā.

1816
01:31:20,101 --> 01:31:23,100
Un ka pēdējais scenārijs, kur lietas
ir visas vietas atmiņā,

1817
01:31:23,100 --> 01:31:25,082
patiesībā var būt spēcīgs līdzeklis.

1818
01:31:25,082 --> 01:31:28,040
Bet mēs atgriezties, ka, ja mēs
runāt par mīļotājs datu struktūras.

1819
01:31:28,040 --> 01:31:32,260
Tagad, masīvs ir tikai
rieciens blakusesošo atmiņas,

1820
01:31:32,260 --> 01:31:36,520
Katrā no kura elementi ir
atpakaļ, atpakaļ, atpakaļ, atpakaļ,

1821
01:31:36,520 --> 01:31:38,050
un parasti tā paša tipa.

1822
01:31:38,050 --> 01:31:42,630
>> Tātad, ja jūs domājat par, no A
Pirms brīža, kas ir string?

1823
01:31:42,630 --> 01:31:50,460
Nu, string, piemēram Zamyla,
Z-A-M-Y-L-A, ir, tehniski,

1824
01:31:50,460 --> 01:31:51,400
tikai masīvs.

1825
01:31:51,400 --> 01:31:53,700
Tas ir masīvs rakstzīmes.

1826
01:31:53,700 --> 01:31:59,250
>> Un tāpēc, ja mēs patiešām izdarīt to, kā es
darīja agrāk, kā rieciens atmiņas,

1827
01:31:59,250 --> 01:32:04,510
izrādās, ka katrs no šiem
rakstzīmes aizņem baitu.

1828
01:32:04,510 --> 01:32:07,630
Un tad tur ir kas īpašs
Sentinel raksturs, tad reversā slīpsvītra 0,

1829
01:32:07,630 --> 01:32:12,360
vai visi astoņi 0 biti, ka
norobežo uz pabeigtu virkni.

1830
01:32:12,360 --> 01:32:15,090
Tātad virkne, izrādās
ārā, citējot likt pēdiņas beigās virkni,

1831
01:32:15,090 --> 01:32:20,580
ir tikai masīvs chara--
char ir faktisko datu tips.

1832
01:32:20,580 --> 01:32:24,560
>> Un tagad argv, meanwhile--
iesim atpakaļ uz programmu.

1833
01:32:24,560 --> 01:32:29,582
Argv, kaut gan mēs redzam vārdu
string šeit, nav pati virkne.

1834
01:32:29,582 --> 01:32:33,640
Argv, arguments vektors,
ir masīvs stīgas.

1835
01:32:33,640 --> 01:32:37,620
>> Tik vienkārši, kā jūs varat būt masīvs
rakstzīmes, jums var būt augstāks,

1836
01:32:37,620 --> 01:32:46,279
masīvs strings-- tā, piemēram,
kad es drukāti pirms brīža ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, telpa Z-A-M-Y-L-A, es norādīja, ka
argv bija divas stīgas it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
un Z-A-M-Y-L-A. uz
citiem vārdiem sakot, argc bija 2.

1839
01:33:03,185 --> 01:33:03,980
Kāpēc ir tā, ka?

1840
01:33:03,980 --> 01:33:08,370
>> Nu, faktiski, kas notiek
par ir tas, ka katrs no šiem virknes

1841
01:33:08,370 --> 01:33:13,990
ir, protams, masīvs rakstzīmju
Tāpat kā iepriekš, katrs no kuras varoņi

1842
01:33:13,990 --> 01:33:15,670
aizņem vienu baitu.

1843
01:33:15,670 --> 01:33:19,720
Un nejauciet faktisko 0
Programmā vārda ar 0,

1844
01:33:19,720 --> 01:33:22,040
kas nozīmē visus 80 bitus.

1845
01:33:22,040 --> 01:33:27,140
Un Zamyla, tikmēr, joprojām
arī masīvs rakstzīmes.

1846
01:33:27,140 --> 01:33:31,450
>> Tātad beigās, dienā, tas patiešām
izskatās šādi zem motora pārsega.

1847
01:33:31,450 --> 01:33:38,800
Bet argv, pēc būtības, kā galvenā
darbi, ļauj man wrap viss

1848
01:33:38,800 --> 01:33:44,810
augšup, ja jūs, lielākā masīvs
ka, ja mēs nedaudz vairāk vienkāršot

1849
01:33:44,810 --> 01:33:48,180
kāda bilde izskatās un nav
diezgan izdarīt tā, lai palielinātu tur,

1850
01:33:48,180 --> 01:33:56,720
šis masīvs ir tikai no 2. izmēra, pirmais
elements, kas satur virkni,

1851
01:33:56,720 --> 01:33:59,230
No Otrais elements
kas satur virkni.

1852
01:33:59,230 --> 01:34:01,687
Un, savukārt, ja jums
veida tuvinātu par katru

1853
01:34:01,687 --> 01:34:03,770
Šo stīgas, ko jūs
redzēt zem motora pārsega

1854
01:34:03,770 --> 01:34:07,190
ir tas, ka katrs virkne ir tikai
masīvs rakstzīmes.

1855
01:34:07,190 --> 01:34:11,680
>> Tagad, tāpat kā ar stīgām,
mums bija iespēja piekļūt

1856
01:34:11,680 --> 01:34:15,260
uz i-rakstura string
izmantojot šo kvadrātiekava notācija.

1857
01:34:15,260 --> 01:34:17,320
Līdzīgi, ar masīviem
vispār, mēs varam

1858
01:34:17,320 --> 01:34:22,700
izmantot kvadrātiekavas notācija iegūt
jebkurā skaitu virknes masīvā?

1859
01:34:22,700 --> 01:34:25,100
Piemēram, ļaujiet man
iet uz priekšu un darīt to.

1860
01:34:25,100 --> 01:34:32,420
>> Ļaujiet man iet uz priekšu un izveidot argv1.c,
kas ir nedaudz atšķirīgs šoreiz.

1861
01:34:32,420 --> 01:34:35,635
Tā vietā, pārbaudot argc2,
Es esmu gatavojas vietā izdarīt.

1862
01:34:35,635 --> 01:34:41,270
Par int man 0, es mazāk
nekā argc, es plus plus,

1863
01:34:41,270 --> 01:34:47,920
un pēc tam izdrukāt iekšpusē šo,
procenti s, jauns līnija, un pēc tam

1864
01:34:47,920 --> 01:34:50,740
argv kronšteins i.

1865
01:34:50,740 --> 01:34:55,220
>> Tātad citiem vārdiem sakot, es neesmu nodarbojas ar
atsevišķas rakstzīmes brīdī.

1866
01:34:55,220 --> 01:35:00,190
Argv, kā tas ir ar šo tukšo kvadrātu
bikšturi pa labi no vārda argv,

1867
01:35:00,190 --> 01:35:03,320
nozīmē argv ir masīvs stīgas.

1868
01:35:03,320 --> 01:35:04,870
Un argc ir tikai int.

1869
01:35:04,870 --> 01:35:08,800
>> Šī līnija šeit, 6, ir
sakot kopumu i vienāds ar 0.

1870
01:35:08,800 --> 01:35:11,980
Count visu ceļu līdz,
neieskaitot, argc.

1871
01:35:11,980 --> 01:35:14,010
Un tad uz katra atkārtojuma,
izdrukāt virkni.

1872
01:35:14,010 --> 01:35:14,800
Kas string?

1873
01:35:14,800 --> 01:35:17,270
>> I-th string in argv.

1874
01:35:17,270 --> 01:35:19,530
Tātad, tā kā pirms es biju
izmantojot kvadrātveida skavu

1875
01:35:19,530 --> 01:35:22,180
notācija saņemt pie i-
raksturs string, tagad

1876
01:35:22,180 --> 01:35:27,240
Es esmu, izmantojot kvadrātiekava notācija
nokļūt pie i-virknes masīvā.

1877
01:35:27,240 --> 01:35:30,310
Tātad, tas ir sava veida viena slāņa
iepriekš, konceptuāli.

1878
01:35:30,310 --> 01:35:35,390
>> Un tā, kas ir veikls par šo
Programma tagad, ja es apkopot argv1,

1879
01:35:35,390 --> 01:35:42,067
un pēc tam darīt ./argv1, un pēc tam ierakstiet
kaut ko līdzīgu foo bar Baz,

1880
01:35:42,067 --> 01:35:45,400
kas ir trīs noklusējuma vārdi, kas a
datorzinātnieks pasniedzas jebkurā laikā

1881
01:35:45,400 --> 01:35:51,010
viņam vai viņai ir vajadzīgs kāds vietturu vārdus,
un hit Enter, katrs no šiem vārdiem,

1882
01:35:51,010 --> 01:35:54,980
tai skaitā programmas nosaukumu, kas
ir argv pirmajā vietā,

1883
01:35:54,980 --> 01:35:58,320
beidzas ar to drukā pa vienam.

1884
01:35:58,320 --> 01:36:05,290
Un, ja es mainītu, un es saku
kaut kā argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
mēs visi trīs no tiem
vārdi, kas ir argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, jo šajā
case argc, grāfs, ir 3.

1887
01:36:14,400 --> 01:36:20,020
>> Bet kas ir veikls ir, ja jūs saprotat
ka argv ir tikai masīvs stīgas,

1888
01:36:20,020 --> 01:36:24,910
un jūs saprotat, ka virkne
ir masīvs rakstzīmes,

1889
01:36:24,910 --> 01:36:29,470
mēs patiesībā varam veida izmantot šo
kvadrātiekava pieraksta vairākas reizes

1890
01:36:29,470 --> 01:36:33,320
izvēlēties virkni, un pēc tam izvēlieties
raksturs ietvaros virknes,

1891
01:36:33,320 --> 01:36:35,730
niršana dziļāk šādi.

1892
01:36:35,730 --> 01:36:40,100
Šajā piemērā, ļaujiet man iet
priekšu un nosaukt šo argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Un šajā piemērā, ļaujiet man iet uz priekšu
un darīt following-- par int man 0,

1895
01:36:50,180 --> 01:36:53,286
i ir mazāks nekā argc, es plus
plus, tāpat kā līdz šim.

1896
01:36:53,286 --> 01:36:55,910
Tātad citiem words-- un tagad šis
kļūst pietiekami sarežģīta.

1897
01:36:55,910 --> 01:36:59,940
Tad es esmu gatavojas teikt
atkārtot pār stīgas argv,

1898
01:36:59,940 --> 01:37:01,294
kā komentārs sevi.

1899
01:37:01,294 --> 01:37:03,960
Un tad es esmu nāksies
Nested cilpas, kas jums, iespējams,

1900
01:37:03,960 --> 01:37:06,290
ir darīts, vai uzskatīt
darot, jo nulles, kur

1901
01:37:06,290 --> 01:37:08,600
Es esmu gatavojas teikt int-- es esmu
nav gatavojas izmantot i atkal,

1902
01:37:08,600 --> 01:37:12,590
jo es nevēlos, lai ēnu, vai
veida pārrakstīt esošo i.

1903
01:37:12,590 --> 01:37:15,780
>> Es esmu gatavojas, nevis, teiksim j, jo
tas ir mans iet uz mainīgo pēc i,

1904
01:37:15,780 --> 01:37:18,590
kad es esmu tikai mēģina
skaitīt vienkāršus numurus.

1905
01:37:18,590 --> 01:37:28,850
Par j izpaužas 0-- un arī, n, gatavojas
saņemt pakaļgala garums argv kronšteinu i,

1906
01:37:28,850 --> 01:37:36,030
tik ilgi, kamēr j ir mazāks nekā m,
j plus plus, rīkojieties šādi.

1907
01:37:36,030 --> 01:37:37,500
Un šeit ir interesanti daļa.

1908
01:37:37,500 --> 01:37:46,330
>> Izdrukāt raksturu un jaunu līniju,
tapām argv grupā i, kronšteinu j.

1909
01:37:46,330 --> 01:37:47,940
Labi, tāpēc ļaujiet man piebilst dažus komentārus šeit.

1910
01:37:47,940 --> 01:37:54,820
Atkārtot pār rakstzīmes
pašreizējā virknes,

1911
01:37:54,820 --> 01:38:02,290
print j-th raksturs i-string.

1912
01:38:02,290 --> 01:38:04,630
Tāpēc tagad, pieņemsim apsvērt
Ko šie komentāri nozīmē.

1913
01:38:04,630 --> 01:38:06,750
>> Atkārtot pār stīgām
in argv-- cik

1914
01:38:06,750 --> 01:38:09,300
stīgas ir argv, kas ir masīvs?

1915
01:38:09,300 --> 01:38:13,420
Argc daudz, tāpēc es esmu atkārtojot
no i vienāds 0 līdz argc.

1916
01:38:13,420 --> 01:38:20,020
Tikmēr, cik rakstzīmes
ir i-virknes argv?

1917
01:38:20,020 --> 01:38:22,880
>> Nu, lai iegūtu, ka atbildi,
Es tikai aicinu virknes garumu

1918
01:38:22,880 --> 01:38:26,810
uz pašreizējo stīgu I aprūpei
par, kas ir argv kronšteins i.

1919
01:38:26,810 --> 01:38:30,090
Un es esmu gatavojas uz laiku uzglabāt ka
vērtība n, tikai caching nolūkos,

1920
01:38:30,090 --> 01:38:31,590
atcerēties to efektivitāti.

1921
01:38:31,590 --> 01:38:36,330
Un tad es esmu gatavojas sāktu J līdz 0,
glabāt iet tik ilgi, kamēr j ir mazāks nekā n,

1922
01:38:36,330 --> 01:38:38,430
un par katru atkārtojuma pieauguma j.

1923
01:38:38,430 --> 01:38:41,030
>> Un tad šeit, per
mans komentārs uz līnijas 12,

1924
01:38:41,030 --> 01:38:43,390
izdrukāt raksturs,
kam seko jaunu līniju,

1925
01:38:43,390 --> 01:38:48,140
īpaši argv kronšteins
i dod man i-string

1926
01:38:48,140 --> 01:38:51,690
in argv-- Tātad pirmais vārdu,
otrais vārds, trešais vārds, neatkarīgi.

1927
01:38:51,690 --> 01:38:57,370
Un tad j niršanas dziļāk, un izpaužas
me j-tais raksturs šo vārdu.

1928
01:38:57,370 --> 01:39:02,200
Un tā, faktiski, jūs var ārstēt
argv kā daudzdimensiju,

1929
01:39:02,200 --> 01:39:06,050
kā divdimensiju, masīvs,
kuru katrs vārds veida izskatās

1930
01:39:06,050 --> 01:39:08,580
piemēram, tas savā prātā s
acs, un katrs raksturs

1931
01:39:08,580 --> 01:39:10,930
ir sava veida veidots
kolonnu, ja tas palīdz.

1932
01:39:10,930 --> 01:39:13,260
>> Patiesībā, kad mēs ķircināt
Neraugoties uz nākotnē nedēļās,

1933
01:39:13,260 --> 01:39:15,580
tas būs nedaudz
sarežģītākas nekā.

1934
01:39:15,580 --> 01:39:17,800
Bet jūs tiešām var
domāju, ka tagad,

1935
01:39:17,800 --> 01:39:22,110
jo tikai šo divdimensiju
masīvs, ar ko viena līmenis no tā

1936
01:39:22,110 --> 01:39:23,260
ir visas stīgas.

1937
01:39:23,260 --> 01:39:26,760
Un tad, ja jūs nirt dziļāk, jums
var saņemt pie atsevišķām rakstzīmēm

1938
01:39:26,760 --> 01:39:29,600
tajā precizē, izmantojot šo apzīmējumu šeit.

1939
01:39:29,600 --> 01:39:31,620
>> Tātad, kas ir neto efekts?

1940
01:39:31,620 --> 01:39:34,970
Ļaujiet man iet uz priekšu un
padarīt argv2-- darn to.

1941
01:39:34,970 --> 01:39:36,210
Es kļūdījies šeit.

1942
01:39:36,210 --> 01:39:40,160
Netieši pasludina
bibliotēkas funkciju Stirling.

1943
01:39:40,160 --> 01:39:42,190
Tāpēc visu šo laiku, tas ir
varbūt vajadzīgs

1944
01:39:42,190 --> 01:39:45,130
ka mēs esam veida apdares
kur tieši mēs sākām.

1945
01:39:45,130 --> 01:39:48,160
>> Es ieskrūvē up, netieši atzīstot
bibliotēkas funkciju Stirling.

1946
01:39:48,160 --> 01:39:48,987
Labi, pagaidiet minūti.

1947
01:39:48,987 --> 01:39:51,070
Es atceros, ka, jo īpaši
jo tas ir tepat.

1948
01:39:51,070 --> 01:39:54,490
Man nepieciešams iekļaut string.h in
Šī programmas versija.

1949
01:39:54,490 --> 01:40:00,050
>> Ļaujiet man iet uz priekšu un ietver
string.h, izņemot to, ka, iet uz priekšu

1950
01:40:00,050 --> 01:40:04,460
un recompile argv2.

1951
01:40:04,460 --> 01:40:08,390
Un tagad, šeit mēs iet, darīt argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Un, lai gan tas ir nedaudz
mistisks pēc pirmā acu uzmetiena,

1953
01:40:10,590 --> 01:40:15,690
paziņojums, ka, patiešām, ko
tiek drukāts ir dot argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Bet, ja es rakstīt dažus vārdus pēc
ātru, tāpat argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Enter, arī nedaudz
mistisks pēc pirmā acu uzmetiena.

1956
01:40:22,560 --> 01:40:30,540
Bet, ja mēs ritiniet atpakaļ uz augšu,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Tāpēc mēs esam atkārtoja pār katru vārdu.

1958
01:40:32,190 --> 01:40:37,770
Un, savukārt, mēs esam atkārtoja pāri
katrs raksturs ietvaros vārdu.

1959
01:40:37,770 --> 01:40:40,040
>> Tagad, kad tas viss,
saprast, ka tur ir

1960
01:40:40,040 --> 01:40:43,120
viena cita detaļa mēs esam bijuši veida
ignorējot visu šo laiku.

1961
01:40:43,120 --> 01:40:46,180
Mēs vienkārši kaitināja izņemot to, kas
Galvenais ir ieejas var būt?

1962
01:40:46,180 --> 01:40:47,780
Kas par galvenais darba rezultāts?

1963
01:40:47,780 --> 01:40:50,540
>> Visu šo laiku, mēs esam bijuši
vienkārši kopējot un ielīmējot

1964
01:40:50,540 --> 01:40:53,870
vārds int priekšā galvenais,
lai gan jūs varat redzēt online,

1965
01:40:53,870 --> 01:40:58,340
dažreiz nepareizi vecākās versijās
C un kompilatori, ka viņi saka par spēkā neesošu,

1966
01:40:58,340 --> 01:40:59,410
vai neko.

1967
01:40:59,410 --> 01:41:01,580
Bet, protams, lai versija
C, ka mēs izmantojam,

1968
01:41:01,580 --> 01:41:06,180
C 11, vai 2011. gada, realizēt
ka tā būtu int.

1969
01:41:06,180 --> 01:41:09,300
Un tas būtu vai nu
spēkā neesošu vai argc un argv šeit.

1970
01:41:09,300 --> 01:41:10,790
>> Bet kāpēc int galvenais?

1971
01:41:10,790 --> 01:41:12,480
Kas tas ir faktiski atgriežas?

1972
01:41:12,480 --> 01:41:16,280
Nu, izrādās, visu šo laiku,
jebkurā laikā jūs esat uzrakstījis Programmas galvenās

1973
01:41:16,280 --> 01:41:18,440
vienmēr atgriežas kaut ko.

1974
01:41:18,440 --> 01:41:19,960
Bet tas ir bijis darīt slepeni.

1975
01:41:19,960 --> 01:41:23,350
>> Ka kaut kas ir
int, jo līnija 5 liecina.

1976
01:41:23,350 --> 01:41:24,225
Bet ko int?

1977
01:41:24,225 --> 01:41:26,100
Nu, tur ir šis
konvencija plānošanā,

1978
01:41:26,100 --> 01:41:29,790
saskaņā ar kuru, ja nekas nav
aizgājuši nepareizi, un viss ir labi,

1979
01:41:29,790 --> 01:41:34,250
programmas un funkcijas parasti
return-- nedaudz counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 parasti nozīmē viss ir labi.

1982
01:41:38,070 --> 01:41:40,610
Tātad, pat ja jūs domājat par
tā kā viltus daudzos kontekstos,

1983
01:41:40,610 --> 01:41:42,930
tas patiesībā parasti nozīmē laba lieta

1984
01:41:42,930 --> 01:41:49,560
>> Tikmēr, ja programma atgriež 1,
vai negatīvs 1, vai 5, vai negatīvs 42,

1985
01:41:49,560 --> 01:41:52,941
vai nav 0 vērtība,
kas parasti nozīmē

1986
01:41:52,941 --> 01:41:54,190
ka kaut kas ir nogājis greizi.

1987
01:41:54,190 --> 01:41:56,700
Patiesībā, par savu Mac vai PC,
Jums varētu būt tiešām redzējis

1988
01:41:56,700 --> 01:42:01,050
kļūdas ziņojums, ar kuru tā
saka kaut vai otru, kļūda

1989
01:42:01,050 --> 01:42:04,940
kods negatīvs 42, vai kļūdas kods
23, vai kaut kas tamlīdzīgs.

1990
01:42:04,940 --> 01:42:08,980
Šis skaits ir parasti tikai mājiens
programmētājs, vai uzņēmuma

1991
01:42:08,980 --> 01:42:11,174
kas padarīja programmatūru,
kas nogāja greizi un kāpēc,

1992
01:42:11,174 --> 01:42:13,590
lai viņi varētu skatīties cauri
viņu dokumentācija vai kods,

1993
01:42:13,590 --> 01:42:15,465
un izdomāt ko
kļūda patiesībā nozīmē.

1994
01:42:15,465 --> 01:42:18,400
Tas parasti nav
noderīga, lai mums galalietotājiem.

1995
01:42:18,400 --> 01:42:20,550
>> Bet, kad galvenie atgriež 0, viss ir labi.

1996
01:42:20,550 --> 01:42:23,770
Un, ja jums nav jānorāda
ko galvenokārt vajadzētu atgriezties,

1997
01:42:23,770 --> 01:42:26,950
tas būs tikai automātiski
atgriezties 0 jums.

1998
01:42:26,950 --> 01:42:30,870
Bet atgriežoties kaut
cits ir faktiski noderīga.

1999
01:42:30,870 --> 01:42:34,660
>> Šajā pēdējā programmā, ļaujiet man
iet uz priekšu un nosaukt šo exit.c,

2000
01:42:34,660 --> 01:42:38,630
un ieviest pēdējā no šodienas
tēmas, kas pazīstams kā kļūdas kodu.

2001
01:42:38,630 --> 01:42:42,930
Ļaujiet man iet uz priekšu un ietver mūsu
pazīstami failus līdz top, darīt int galvenais.

2002
01:42:42,930 --> 01:42:49,500
Un šoreiz, pieņemsim do int argc,
stīgu argv, un ar manu iekavās

2003
01:42:49,500 --> 01:42:50,836
nozīmēt, ka tas ir masīvā.

2004
01:42:50,836 --> 01:42:52,460
Un tad ļaujiet man tikai do veselība pārbaudītu.

2005
01:42:52,460 --> 01:42:56,640
Šoreiz ja argc nav
vienāds 2, tad jūs zināt, ko?

2006
01:42:56,640 --> 01:42:57,520
Aizmirsti.

2007
01:42:57,520 --> 01:43:03,170
Es esmu gatavojas teikt, ka, hey, lietotājs,
jums trūkst komandrindas argumentu

2008
01:43:03,170 --> 01:43:04,210
reversā slīpsvītra n.

2009
01:43:04,210 --> 01:43:05,230
>> Un tad tas arī viss.

2010
01:43:05,230 --> 01:43:06,130
Es gribu, lai izietu.

2011
01:43:06,130 --> 01:43:11,030
Es dodos uz preemptively,
un priekšlaicīgi tiešām, atgriešanās

2012
01:43:11,030 --> 01:43:12,810
kaut kas cits nekā skaits 1.

2013
01:43:12,810 --> 01:43:15,360
Go to vērtību par pirmo
kļūda, kas var notikt, ir 1.

2014
01:43:15,360 --> 01:43:17,860
Ja jums ir daži citi kļūdains
situācija, kas varētu notikt,

2015
01:43:17,860 --> 01:43:21,390
jūs varētu teikt atdevi 2 vai atgriezt 3, vai
varbūt pat negatīvs 1 vai negatīvs 2.

2016
01:43:21,390 --> 01:43:23,750
>> Šie ir tikai izejas kodi
kas ir, parasti,

2017
01:43:23,750 --> 01:43:27,770
tikai noderīga programmētājs, vai
uzņēmums, kas ir kuģniecības programmatūru.

2018
01:43:27,770 --> 01:43:30,500
Bet fakts, ka tā ir
ne 0 ir tas, kas ir svarīgi.

2019
01:43:30,500 --> 01:43:34,310
Tātad, ja šajā programmā, es gribu
garantēt, ka šī programma tikai

2020
01:43:34,310 --> 01:43:38,190
darbojas, ja lietotājs sniedz man
ar argumentu skaits ir divi,

2021
01:43:38,190 --> 01:43:42,880
nosaukums programmas, un dažas citas
vārds, es varu izpildīt tik daudz, cik šāds,

2022
01:43:42,880 --> 01:43:46,110
bļaut pie lietotājs ar printf sakot,
pazudis komandrindas argumentu,

2023
01:43:46,110 --> 01:43:46,970
atgriešanās 1.

2024
01:43:46,970 --> 01:43:49,940
Tas būs tikai uzreiz
atmest programmu.

2025
01:43:49,940 --> 01:43:55,840
>> Tikai tad, ja argc vienāds 2 mēs nokāpt
šeit, kurā brīdī es esmu gatavojas teikt,

2026
01:43:55,840 --> 01:44:00,410
sveiki procenti s, slīpsvītru n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Citiem vārdiem sakot, es esmu
nenāks pēc argv 0,

2028
01:44:03,827 --> 01:44:05,410
kas ir tikai programmas nosaukums.

2029
01:44:05,410 --> 01:44:09,450
Es gribu izdrukāt hello, komats,
otrais vārds, ka cilvēka ievadījis.

2030
01:44:09,450 --> 01:44:12,580
Un šajā gadījumā uz
līnija 13, viss ir labi.

2031
01:44:12,580 --> 01:44:15,920
>> Es zinu, ka argc ir 2
loģiski no šīs programmas.

2032
01:44:15,920 --> 01:44:17,770
Es iešu uz priekšu un atpakaļ 0.

2033
01:44:17,770 --> 01:44:21,230
Kā malā, paturiet prātā, ka
šis apgalvojums ir patiess Scratch, kā arī.

2034
01:44:21,230 --> 01:44:24,760
>> Loģiski, es varētu darīt
un rezumēju šīs līnijas

2035
01:44:24,760 --> 01:44:27,020
koda šajā cits klauzulu šeit.

2036
01:44:27,020 --> 01:44:29,420
Bet tas ir sava veida
nevajadzīgi indenting manu kodu.

2037
01:44:29,420 --> 01:44:31,800
Un es gribu, lai super
skaidrs, ka nav svarīgi, ko,

2038
01:44:31,800 --> 01:44:34,670
pēc noklusējuma, sveiki
kaut kas saņems drukāts,

2039
01:44:34,670 --> 01:44:36,050
tik ilgi, kamēr lietotājs sadarbojas.

2040
01:44:36,050 --> 01:44:39,360
>> Tātad, tas ir ļoti bieži, lai izmantotu
nosacījums, tikai tad,

2041
01:44:39,360 --> 01:44:41,870
noķert kādu kļūdaina
situāciju, un tad izeja.

2042
01:44:41,870 --> 01:44:45,690
Un pēc tam, tik ilgi visi ir
labi, nav ir cits,

2043
01:44:45,690 --> 01:44:48,060
bet vienkārši ir kodu
ārpuses, ka, ja, jo tas ir

2044
01:44:48,060 --> 01:44:51,060
ekvivalents šajā
īpaši gadījumā, loģiski.

2045
01:44:51,060 --> 01:44:54,480
Tāpēc es esmu atpakaļ 0, tikai
skaidri neizsaka viss ir labi.

2046
01:44:54,480 --> 01:44:58,480
>> Ja es izlaist atgriešanos 0, tas būtu
automātiski pieņemts par mani.

2047
01:44:58,480 --> 01:45:00,890
Bet tagad, ka es esmu atpakaļ
viens vismaz šajā gadījumā,

2048
01:45:00,890 --> 01:45:04,940
Es esmu gatavojas, labu pasākumu un
skaidrība, atgriešanās 0 šajā gadījumā.

2049
01:45:04,940 --> 01:45:09,690
Tāpēc tagad ļaujiet man iet uz priekšu un veikt izeju,
kas ir ideāls segue vienkārši atstāt.

2050
01:45:09,690 --> 01:45:14,401
>> Bet, pārliecinieties, izeju, un ļaujiet man iet
priekšu un darīt ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Un programma kliedza uz mani,
pazudis komandrindas argumentu.

2052
01:45:16,900 --> 01:45:18,120
Labi, ļaujiet man sadarboties.

2053
01:45:18,120 --> 01:45:23,810
>> Ļaujiet man nevis darīt ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Un tagad tā saka, hello Deivids.

2055
01:45:25,190 --> 01:45:27,300
Un jūs parasti nav redzēt šo.

2056
01:45:27,300 --> 01:45:30,650
>> Bet izrādās, ka tur ir
īpašs veids Linux faktiski redzēt

2057
01:45:30,650 --> 01:45:34,470
ar ko izejas kods programma iziet.

2058
01:45:34,470 --> 01:45:37,184
Dažreiz grafiskā
pasauli, Mac OS vai Windows,

2059
01:45:37,184 --> 01:45:40,100
jūs tikai redzēt šos numurus, kad
kļūdas ziņojums NOP augšu uz ekrāna

2060
01:45:40,100 --> 01:45:41,940
un programmētājs
parāda šo numuru.

2061
01:45:41,940 --> 01:45:44,773
Bet, ja mēs gribam, lai redzētu, kas kļūda
vēstījums ir, mēs varam darīt to here--

2062
01:45:44,773 --> 01:45:48,100
tik ./exit, Enter, print
pazudis komandrindas argumentu.

2063
01:45:48,100 --> 01:45:54,590
>> Ja es tagad darīt echo $ ?, kas ir
smieklīgi mistisks meklē.

2064
01:45:54,590 --> 01:45:56,590
Bet $?

2065
01:45:56,590 --> 01:45:59,220
ir burvju buršana
kas saka, hey, dators,

2066
01:45:59,220 --> 01:46:01,900
pasakiet man, kāda iepriekšējā
Programmas izejas kods bija.

2067
01:46:01,900 --> 01:46:03,410
Un es hit Enter.

2068
01:46:03,410 --> 01:46:07,520
Es redzu 1, jo tas, ko es
teica mana galvenā funkcija atgriezties.

2069
01:46:07,520 --> 01:46:12,310
>> Tikmēr, ja man ./exit Dāvidu,
un hit Enter, es redzu, Hello Dāvidu.

2070
01:46:12,310 --> 01:46:16,800
Un, ja es tagad darīt echo $ ?, es redzu sveiki 0.

2071
01:46:16,800 --> 01:46:19,080
Un tā tas patiešām
būt vērtīgu informāciju

2072
01:46:19,080 --> 01:46:23,420
kontekstā atkļūdotājs, ne tik
daudz, ka jūs, cilvēku, būtu vienalga.

2073
01:46:23,420 --> 01:46:26,060
Bet atkļūdotājs un citi
programmas, mēs izmantosim šo semestri

2074
01:46:26,060 --> 01:46:29,420
bieži apskatīt šo numuru,
pat ja tas ir sava veida Paslēpusies

2075
01:46:29,420 --> 01:46:32,780
ja jūs meklēt to, lai
noteiktu, vai nav programma s

2076
01:46:32,780 --> 01:46:37,050
izpilde bija pareizi vai nepareizi.

2077
01:46:37,050 --> 01:46:40,450
>> Un tā, kas dod mums
šis, beigās, dienā.

2078
01:46:40,450 --> 01:46:43,917
Mēs šodien uzsāka aplūkojot
atkļūdošana, un, savukārt, pie kursa

2079
01:46:43,917 --> 01:46:46,750
sevi, un tad vēl interesanti,
tehniski zem motora pārsega

2080
01:46:46,750 --> 01:46:49,490
par to, kas stīgas ir, kas ilgst
Šonedēļ mēs vienkārši ņēma par pašsaprotamu,

2081
01:46:49,490 --> 01:46:51,900
un, protams, ņēma tos
par piešķirts nulles.

2082
01:46:51,900 --> 01:46:56,040
>> Mēs pēc tam paskatījās kā mēs varam piekļūt
atsevišķas rakstzīmes virkni,

2083
01:46:56,040 --> 01:47:00,310
un tad atkal ieņēma augstāku
apskatīt lietas, aplūkojot, kā well--

2084
01:47:00,310 --> 01:47:04,226
ja mēs gribam nokļūt pie individuālo
elementi sarakstā līdzīgu struktūru,

2085
01:47:04,226 --> 01:47:05,850
mēs nevaram darīt, ka ar vairākiem stīgas?

2086
01:47:05,850 --> 01:47:08,050
Un mēs varam ar komandrindas argumentus.

2087
01:47:08,050 --> 01:47:12,800
Bet šī aina šeit ir tikai kastes
ir uzskatāms par šo vispārējo ideju

2088
01:47:12,800 --> 01:47:14,451
no masīva, vai saraksta, vai vektors.

2089
01:47:14,451 --> 01:47:16,450
Un atkarībā no
konteksts, visus šos vārdus

2090
01:47:16,450 --> 01:47:17,880
nozīmēt nedaudz atšķirīgas lietas.

2091
01:47:17,880 --> 01:47:20,060
Tātad C, mēs esam tikai gatavojas
runāt par masīvu.

2092
01:47:20,060 --> 01:47:23,840
Un masīvs ir rieciens
atmiņas, no kuriem katrs ir

2093
01:47:23,840 --> 01:47:27,720
elementi ir blakusesoši, atpakaļ,
atpakaļ, atpakaļ, uz muguras.

2094
01:47:27,720 --> 01:47:31,970
>> Un šie elementi ir, parasti,
no tā paša datu tips, raksturs,

2095
01:47:31,970 --> 01:47:35,966
raksturs, raksturs, raksturs, vai
stīgu, stīgu, stīgu, stīgu, vai int,

2096
01:47:35,966 --> 01:47:38,600
int, int, kāds tas ir
mēs cenšamies veikalā.

2097
01:47:38,600 --> 01:47:42,540
Bet beigās, dienā, tas ir
kā tas izskatās konceptuāli.

2098
01:47:42,540 --> 01:47:44,530
Jūs lietojat savu
datora atmiņā vai RAM.

2099
01:47:44,530 --> 01:47:48,590
Un jūs atkāpes to ārā
identiski izmēra kastes, kas visi

2100
01:47:48,590 --> 01:47:50,920
ir atpakaļ, atpakaļ, uz
atpakaļ, atpakaļ šādā veidā.

2101
01:47:50,920 --> 01:47:53,200
>> Un, kas ir jauka par
Šī ideja, un tas,

2102
01:47:53,200 --> 01:47:58,580
ka mēs varam izteikt vērtības šādā veidā
ar pirmo mūsu datu struktūras

2103
01:47:58,580 --> 01:48:02,520
klasē, nozīmē, ka mēs varam sākt
lai risinātu problēmas ar kodu

2104
01:48:02,520 --> 01:48:04,079
kas nāca tik intuitīvi in ​​nedēļā 0.

2105
01:48:04,079 --> 01:48:05,870
Jums atgādināt tālruni
grāmatas piemērs, kur

2106
01:48:05,870 --> 01:48:09,110
mēs izmantojām plaisu un iekarot,
vai bināro meklēšanas algoritmu,

2107
01:48:09,110 --> 01:48:13,220
izsijāt caur kopumā
ķekars vārdus un numurus.

2108
01:48:13,220 --> 01:48:18,220
Bet mēs pieņēmām, atgādināt, ka
tālruņu grāmata jau bija sakārtoti,

2109
01:48:18,220 --> 01:48:21,630
ka kāds cits bija jau
sapratu out-- dots nosaukumu sarakstu

2110
01:48:21,630 --> 01:48:24,430
un numbers-- kā alphabetize tos.

2111
01:48:24,430 --> 01:48:26,950
Un tagad, ka C mēs,
Arī, ir iespēja

2112
01:48:26,950 --> 01:48:30,290
nolikt lietas, ne
fiziski tālruņa grāmatu

2113
01:48:30,290 --> 01:48:34,220
bet praktiski datora
atmiņas, mēs varēsim nākamnedēļ

2114
01:48:34,220 --> 01:48:38,470
ieviest atkal this-- pirmais
Mūsu datu struktūru ar array--

2115
01:48:38,470 --> 01:48:43,530
bet vēl svarīgāk, faktisko dators
zinātne algoritmi īstenoti

2116
01:48:43,530 --> 01:48:47,720
ar kodu, ar kuru mēs varam glabāt
dati struktūrās, piemēram, tas,

2117
01:48:47,720 --> 01:48:50,730
un tad sāk manipulēt ar to, un
faktiski atrisināt problēmas ar to,

2118
01:48:50,730 --> 01:48:53,570
un, lai izveidotu uz augšu, ka,
galu galā, programmas C,

2119
01:48:53,570 --> 01:48:56,730
Python, JavaScript,
vaicājumiem datu bāzes ar SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Un mēs redzam, ka visi šie
dažādas idejas savienojas.

2121
01:48:59,980 --> 01:49:04,100
Bet tagad, atgādināt, ka
domēns, ka mēs šodien iepazīstināja

2122
01:49:04,100 --> 01:49:06,920
bija šī lieta šeit, un
pasaule kriptogrāfiju.

2123
01:49:06,920 --> 01:49:11,200
Un starp nākamajām problēmām tu pats
atrisinās ir māksla kriptogrāfijas,

2124
01:49:11,200 --> 01:49:13,630
šifrēšanas un de-kodēšanas
informācija, un šifrēšana

2125
01:49:13,630 --> 01:49:15,930
un atšifrējums tekstu,
un pieņemot, ka galu galā

2126
01:49:15,930 --> 01:49:18,970
ka jūs tagad zināt, ko
ir zem motora pārsega

2127
01:49:18,970 --> 01:49:21,860
lai tad, kad jūs redzēt vai saņemt
ziņa kā šis, jums

2128
01:49:21,860 --> 01:49:24,060
pats var atšifrēt to.

2129
01:49:24,060 --> 01:49:26,740
Tas viss, un vēl nākamo reizi.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO PLAYBACK]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Tikko ieradušies.

2133
01:49:32,970 --> 01:49:35,146
Es iešu vizītē
viņa koledžas profesors.

2134
01:49:35,146 --> 01:49:37,611
Yep.

2135
01:49:37,611 --> 01:49:40,080
Sveiki.

2136
01:49:40,080 --> 01:49:40,660
Tas esi tu.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Pagaidiet!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Es esmu tikai mēģina izdomāt
, kas noticis ar jums.

2142
01:49:56,060 --> 01:49:58,130
Lūdzu, kaut kas varētu palīdzēt.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Jūs bijāt viņa koledža
istabas biedrs, bija ne?

2145
01:50:08,354 --> 01:50:10,770
Jūs bijāt tur ar viņu, kad
viņš beidzis CS50 projektu?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [SKAN MŪZIKA]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -That Bija CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Es mīlu šo vietu.

2152
01:50:44,770 --> 01:50:45,854
>> -Eat Up.

2153
01:50:45,854 --> 01:50:47,020
Mēs ejam no uzņēmējdarbības.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END PLAYBACK]

