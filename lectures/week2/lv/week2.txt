[SKAN MŪZIKA] 

DAVID J. Malan: Labi. Tas ir CS50, un šī ir sākums 2. nedēļā. Un jūs atgādināt, ka vairāk nekā Pēdējo pāris nedēļu laikā, mēs esam ieviešot datoru zinātne un, savukārt, programmēšana. 

Un mēs sākām stāsts veidā Scratch, ka grafiskā valoda no MIT Media Lab. Un tad pavisam nesen, pagājušajā nedēļā, mēs esam ieviest higher-- A zemāka līmeņa valoda zināms kā C, kaut kas ir tīri teksta. Un, protams, pēdējo reizi mēs pētītas šajā kontekstā vairākas koncepcijas. 

Tas, atgādināt, bija ļoti Pirmā programma mēs paskatījās. Un šī programma, gluži vienkārši, izdrukā, "Hello, World". Bet tur ir tik daudz šķietams burvju notiek. Tur ir šis # include ar šiem leņķa iekavās. Tur ir int. Ir (spēkā neesošs). Tur ir iekavas, cirtaini bikšturi, semikoli, un tā daudz vairāk. 

Un tā, atgādināt, ka mēs ieviesām Scratch lai mēs varētu, ideālā gadījumā, sk pagātni ka sintakse, sīkumi, kas tiešām nav viss, kas intelektuāli interesanti, bet agri ir absolūti, mazliet viltīgs wrap savas domas ap. Un, protams, ir viens no visbiežāk lietas agri programmēšanas klasē, jo īpaši tiem mazāk ērti, ir iegūt neapmierinātas ar un paklupu up ar noteiktu sintaktisko kļūdas, nemaz nerunājot loģiskās kļūdas. Un tā no mūsu mērķiem šodien, patiesībā, būs būt aprīkot jūs ar dažiem problēmu risināšana paņēmieni, kā labāk risināt problēmas paši formā atkļūdošanu. Un jūs atgādināt arī, ka vide, ka mēs iepazīstinājām pēdējo reizi sauca CS50 IDE. Šī ir tīmekļa programmatūru, kas ļauj ieprogrammēt mākonis, tā sakot, saglabājot visas jūsu failus kopā, jo mēs atkal šodien. Un atgādina, ka mēs pārskatīt šīs tēmas šeit, starp tiem funkcijas, un cilpas, un mainīgie, un Būla izteiksmes, un nosacījumiem. Un patiesībā vēl dažus, ka mēs tulkots no pasaules Scratch uz pasaules C. 

Bet galvenais ēka bloki, tā sakot, bija tiešām joprojām ir tas pats pagājušajā nedēļā. Patiesībā, mēs tiešām tikai bija atšķirīgs puzzle gabals, ja Jums gribas. Tā vietā, lai violeta glābt bloku, mēs vietā bija Printf, kas ir šī funkcija C ka ļauj drukāt kaut ko un formatēt to uz ekrāna. Mēs iepazīstinājām CS50 Bibliotēka, kur jums tagad jūsu rīcībā get_char, un get_int, un get_string, un dažas citas funkcijas, kā labi, caur kuru jūs varat saņemt ievade no lietotāja paša klaviatūru. Un mēs arī ņēma apskatīt lietas piemēram these- bool un palijas, un dubultā, peldēt, int, long_long string. Un tur pat citu datu tipu C 

Citiem vārdiem sakot, ja jūs deklarēt mainīgais uzglabāt dažas vērtību, vai ja jums īstenot funkciju kas atgriež dažas vērtības, Jūs varat norādīt, ko par vērtību, kas ir tips. Vai tas ir string, piemēram, rakstzīmju secība? Vai tas ir skaitlis, piemēram, skaitlim? Vai tā ir peldošā komata vērtība, vai tamlīdzīgi? Tātad C, atšķirībā no nulles, mēs faktiski sāka norādīt, kāda veida datus mēs atgriešanās vai izmanto. 

Bet, protams, mēs arī uzbrauca dažas būtiskas robežas skaitļošanas. Un it īpaši, šī valoda C, atsaukšana ka mēs ņēmām apskatīt skaitlis pārplūdes, realitāte ka, ja jums ir tikai ierobežots atmiņas apjoms vai, precīzāk, ierobežots skaits bitu, jūs varat tikai paļauties tik augsts. Un tā mēs paskatījās šo piemēru šeit saskaņā ar kuru skaitītājs lidmašīnā, patiesībā, ja darbojas pietiekami ilgi būtu pārplūdes un izraisīt programmatūru faktiskais fiziskais iespējamā kļūda. 

Mēs arī apskatīja peldošā neprecizitāte punkts, realitāte ka tikai ierobežots skaits bitu, vai tas ir 32 vai 64, Jūs varat norādīt tikai tik daudz numurus pēc komata, pēc kura jūs sāk saņemt neprecīza. Tā, piemēram, vienu trešo vietu pasaule šeit, mūsu cilvēku pasaulē, mēs zinām, ir tikai bezgalīgi daudz no 3s aiz komata. Bet dators var nebūt pārstāv neskaitāmas numuru ja Jums ir tikai ļaujiet tai dažas ierobežots informācijas daudzums. 

Tātad ne tikai mēs aprīkot jūs ar lielāku jaudu ziņā par to, kā jūs varētu izteikt sevi tastatūra ziņā plānošanu, mēs arī ierobežots, ko jūs faktiski var darīt. Un tiešām, bugs un kļūdas var rodas no šiem jautājumiem veidu. Un tiešām, starp tēmām šodien ir būs tēmas, piemēram atkļūdošana un faktiski meklē zem pārsega cik tika ieviests lietas pagājušajā nedēļā faktiski īstenoti lai jūs labāk izprast gan spējas un ierobežojumi valodā, piemēram, C. 

Un patiesībā, mēs mizu atpakaļ slāņus no vienkāršākajiem datu struktūras, kaut ko sauc masīvs, kas Scratch notiek zvanīt "sarakstu." Tas ir mazliet atšķirīga šajā kontekstā. Un tad mēs arī ieviest vienu no Pirmais no mūsu domēna specifiskas problēmas in CS50, pasaule kriptogrāfija, māksla kodēšanas vai šifrēšana informāciju, ka jūs varat nosūtīt slepenu ziņu un atšifrēt slepenu ziņu starp divām personām, A un B 

Tātad, pirms mēs pārejas ar šo jauno pasauli, pamēģināsim aprīkot jūs ar dažiem metodes, ar kuru jūs varat novērst vai samazināt vismaz daži no neapmierinātību ka jūs, iespējams, radušās pāri vien pagājušajā nedēļā. Patiesībā, pirms jums ir such-- daži savu pirmo problēmas C. Un izredzes ir, Ja jūs esat līdzīgi man, pirmo reizi jūs mēģināt rakstīt out programmu, pat ja jūs domājat, ka loģiski programma ir diezgan vienkāršs, jūs varētu ļoti labi hit sienas, un kompilators nav gatavojas sadarboties. Marka vai šķindēt negrasās lai faktiski darīt savu solīšanu. 

Un kāpēc varētu būt? Nu, pieņemsim to apskatīt, varbūt, vienkārša programma. Es iešu uz priekšu un saglabāt to fails apzināti sauc buggy0.c, jo es zinu to būt kļūdaina iepriekš. Bet es nevarētu saprast, ka, ja šis ir pirmā vai otrā vai trešā programma ka es esmu faktiski padarot sevi. Tāpēc es esmu gatavojas iet uz priekšu un veids, kas, int galvenais (spēkā neesošs). Un tad iekšā manas cirtaini bikšturi, ļoti pazīstams ( "hello, world-- reversā slīpsvītra, n ") - un semikolu. 

Esmu saglabājis failu. Tagad es esmu gatavojas iet uz leju uz manu termināļa loga un tips make buggy0, jo, atkal, nosaukums faila šodien ir buggy0.c. Tāpēc es tipa darīt buggy0, Enter. 

Un, ak, Dievs, atcerēties no pēdējo reizi ka nav kļūdu ziņojumiem ir laba lieta. Līdz ar to nav izeja ir laba lieta. Bet šeit man ir skaidri daži skaits kļūdām. 

Tātad pirmajā rindā produkcijas pēc rakstīt padarīt buggy0, atgādināt, ir šķindēt ir diezgan runīgs produkciju. Zem motora pārsega, CS50 IDE ir konfigurēts izmantot visu ķekars iespējas ar šo kompilatoru tā, ka jums nav domāt par tiem. Un tas ir viss, kas pirmajā rindā līdzekļi, kas sākas ar šķindēt. 

Bet pēc tam, problēmas sāk veikt savu izskatu. Buggy0.c on line 3, raksturs 5, ir liels, sarkans kļūda. Kas tas ir? Netieši atzīstot bibliotēka funkciju printf ar tipa int (const char *, ...) [-Werror]. Es domāju, ka ir ļoti ātri kļūst ļoti arcane. Un, protams, vispirms skatienu, mēs nebūtu sagaida, lai jūs saprastu kopums šo ziņu. Un tā viena no mācībām par šodien notiek būt mēģināt pamanīt modeļus, vai līdzīgas lietas, kļūdas jums varētu būt radušās pagātnē. Tātad, pieņemsim kaitināt intervālu tikai šie vārdi, kas izskatās pazīstami. Liels, sarkans kļūda ir skaidri simbolizē kaut ko ir nepareizi. 

netieši deklarējot bibliotēkas funkciju printf. Tātad, pat ja man nav gluži saprast, ko netieši atzīstot bibliotēka funkciju līdzekļiem, problēma noteikti saistīts ar printf kaut kā. Un avots šajā jautājumā ir saistīts ar to deklarējot. 

Pasludināšana funkcija ir minot to pirmo reizi. Un mēs izmantojām terminoloģiju pagājušajā nedēļā deklarēt funkcija ir prototips, nu ar vienu līniju augšpusē jūsu pašu failu vai ts header failu. Un tas, ko fails darīja mēs sakām pagājušajā nedēļā, ka printf ir citāts, likt pēdiņas beigās, paziņoja? Kādā fails ir tā prototips? 

Tātad, ja jūs atceraties, pati pirmā lieta, ko es drukāti, gandrīz katrs programma pagājušajā LAIKU_ un nejauši pirms brīža sākās ierakstot myself-- bija tas viens here-- hash-- # Ietvert <stio-- par ievades / output-- dot h Un tiešām, ja es tagad saglabājiet šo failu, es eju iet uz priekšu un iztīrītu ekrānu, ko jūs varat darīt, ierakstot Skaidrs, vai jūs varat turēt Control L, tikai, lai skaidrs jūsu termināļa logu tikai, lai novērstu kādu jucekli. 

Es iešu uz priekšu un re-veida make buggy0, Enter. Un voila, es joprojām redzu, ka garš komandu no šķindēt, bet tur nav kļūdas ziņojums šoreiz. Un tiešām, ja man ./buggy0, tāpat kā pēdējo reizi, kur dot nozīmē, ka šis katalogs, Slash tikai nozīmē, šeit nāk nosaukums programmas un ka programmas nosaukums ir buggy0, Enter, "Hello, World". 

Tagad, kā varētu jums gūta šo risinājumu ne vienmēr atzīstot, jo daudzi vārdi kā es darīju, protams, kam izdarījusi tik daudzus gadus? Nu, saproti, par pirmo problēmu komplekts, mēs jūs iepazīstināt ar komandu ka CS50 paša darbiniekiem rakstīja sauc help50. Un tiešām, C dara specifikācija problēma noteikti par to, kā izmantot šo. 

Bet help50 būtībā programma, kas CS50 personālam rakstīja, ka ļauj darbināt komandu vai palaist programmu, un, ja jūs nesaprotat tās izeja, nodot savu produkciju help50, kurā brīdī programmatūru ka kurss personālam rakstīja apskatīsim jūsu programmas izejas pozīcijai, raksturs ar raksturu. Un, ja mēs, darbinieki, atzīt kļūdas ziņojums, ka jūs piedzīvo, mēs centīsimies provocēt jūs ar dažiem retoriski jautājumi, ar kādu padomu, līdzīgi TF vai CA vai sevi darītu personīgi darba laika. 

Tā izskatās uz help50 ja jums nav vienmēr atzīst problēmu. Bet nav paļauties uz to pārāk daudz kā kruķi. Protams mēģināt saprast savu produkcija un pēc tam mācīties no tā tā, ka tikai vienu vai divas reizes darīt jums kādreiz palaist help50 par konkrētu kļūda ziņa. Pēc tam, jums vajadzētu būt labāk sevi lai noskaidrotu, kas tas patiesībā ir. 

Darīsim vienu otru šeit. Ļaujiet man iet uz priekšu, un citā fails mēs saucam par buggy1.c. Un šajā failā es esmu gatavojas deliberately-- bet izlikties, ka man nav saprast, ko kļūda es esat veikuši. 

Es iešu uz priekšu un darīt this-- #include, jo es esmu uzzināja mana mācība no pirms brīža. Int galvenais (spēkā neesošs), kā iepriekš. Un tad šeit es esmu, darīt virknes s - get_string. Un atsauktu no pēdējo reizi, ka Tas nozīmē, hey, dators, man mainīgo, sauc to s, un padara šo mainīgo ir virkne veidu lai es varētu glabāt vienu vai vairākus vārdus tajā. 

Un tad uz labās rokas pusē vienādības zīmi ir get_string, kas ir funkcija CS50 bibliotēkā kas dara tieši tā. Tā izpaužas funkciju un pēc tam rokas no labās uz kreiso pusi. Tātad tas vienādības zīmi nenozīmē "Vienāds", kā mēs varētu domāt math. Tas nozīmē uzdevumu no labās uz kreiso pusi. Tātad tas nozīmē, veikt virkni no lietotājam un uzglabāt to iekšpusē s. 

Tagad to izmantot. Ļaujiet man iet uz priekšu tagad un kā otro line, ļaujiet man iet uz priekšu un saka "hello" - nevis "pasaule", bet "hello,% s-- kas ir mūsu vietturis, komats s, kas ir mūsu mainīgs, un tad semikolu. Tātad, ja man nav screw up pārāk daudz šeit, tas izskatās pareizs kodu. 

Un mani instinkti tagad ir apkopot to. Fails sauc buggy1.c. Tāpēc es esmu gatavojas darīt darīt buggy1, Enter. Un darn-tas, ja nav pat vairāk kļūdas nekā iepriekš. Es domāju, tur ir vairāk kļūdu ziņojumi Būtu likties nekā faktiskās līniju šajā programmā. 

Bet takeaway šeit ir, pat tad, ja jūs esat nomākti ar divām vai trīs vai vēl četri kļūdu ziņojumus, koncentrēties vienmēr ļoti Pirmais no šiem ziņojumiem. Aplūkojot visvairāk top-one, ritināšanu atpakaļ uz augšu, kā tas būtu nepieciešams. Tātad, šeit es drukāti make buggy1. Lūk, kas šķindēt produkciju, kā gaidīts. 

Un šeit ir pirmais sarkanais kļūda. Izmantot nedeklarēto identifikatora string, tomēr es domāju standartu? Tātad standartu ir tiešām kaut kas cits. Tas attiecas uz lietotāja tastatūra, būtībā. 

Bet tas nav tas, ko es gribēju. Es nozīmēja virkni, un es gribēju get_string. Tātad, kas ir tas, ka es aizmirsu darīt šoreiz? Kas trūkst šoreiz? Man ir mana # include, tāpēc man ir pieeja printf. 

Bet ko man nav piekļuve tikai vēl? Nu, tāpat kā pēdējo reizi, Man vajag pateikt kompilators Šķindēt ko šie funkcijas. Get_string nenāk ar C un, jo īpaši, to nav nonākt header failu,. Tā vietā nāk kaut darbinieki rakstīja, kas ir atšķirīgs fails nosaukt bet trāpīgi nosaukts. 

Tik vienkārši, piebilstot, ka vienā rindā no code-- atsaukšanu no pēdējo reizi ka tad, kad šķindēt iet, tas notiek apskatīt manu kodu augšas uz apakšu, kreisās uz labo. Tas notiek, lai paziņojuma, ak, jūs vēlaties. Ļaujiet man iet un atrast, ka, kur tas ir uz servera, kopēt un ielīmēt to, būtībā, uz augšu savu failu tā ka šajā brīdī stāsts, līnija 1, pārējā programmas var, protams, izmantot kādu no funkcijām tajā, starp tiem get_string. Tāpēc es esmu gatavojas ignorēt pārējā šīm kļūdām, jo es, protams, ir aizdomas, ka tikai pirmā patiešām vienaldzīgs. Un es iešu uz priekšu un atkārto, pēc glābšanas manu failu padarīt buggy1. Un voila, tas bija darbs. Un, ja man ./buggy1 un ierakstiet, lai piemēram, Zamyla, es tagad saņems hello, Zamyla, nevis sveiki, pasaule. 

Viss kārtībā. Tātad takeaways šeit, tad ir, viens, mēģiniet salasīt tik daudz, kā jūs varat No kļūdu ziņojumus tikai, skatoties dažas no atpazīstami vārdi. Lieguma ka, izmantojiet help50 vienu problēma noteikti specifikāciju. Bet liegumu, ka pārāk, vienmēr izskatās augšējā kļūdas tikai, vismaz Sākotnēji, lai redzētu, kāda informācija tas tiešām var dot. Bet izrādās, tur ir vēl vairāk funkcionalitāti būvēts uz CS50 bibliotēkā, lai palīdzētu tu agri semestrī un agri programmēšanā izdomāt, kas notiek nepareizi. Tātad, pieņemsim darīt vēl viens piemērs šeit. Es esmu gatavojas, lai izsauktu šo buggy2, kas, atkal tiks kļūdains out no vārtiem, ar dizainu. 

Un es iešu uz priekšu un darīt # Ietvert. Un tad es esmu gatavojas darīt int galvenais (spēkā neesošs). Un tad es esmu gatavojas darīt, lai cilpu. Par (int i _ 0. i ir mazāks par vai vienāds ar 10. i ++, un tad cirtaini bikšturi, es eju izdrukāt tikai hashtag simbols šeit un jauna līnija raksturs. 

Tāpēc mans nolūks šajā Programma ir pavisam vienkārši atkārtot 10 reizes un par katru atkārtojuma Minētās cilpa katru reizi cauri ciklam, izdrukāt hashtag, atsauces, tiek restītes. Viens per line jo I ir jaunu līniju tur. Un atgādināt, ka par cilpa, par pēdējo week-- un jūs saņemsiet vairāk iepazinušies ar sintaksi , izmantojot to ar praksi pirms long-- tas dod man mainīgs sauc i un nosaka to līdz 0. 

Šī pieauguma soli i uz katru atkārtojuma par 1. Tātad man iet ar 1, 2 vai 3. Un tad šis nosacījums vidu starp semikoliem izpaužas pārbauda katra atkārtojuma, lai padarītu pārliecināts, ka mēs joprojām diapazonā. Tāpēc es gribu atkārtot 10 reizes, tāpēc es ir sava veida ļoti intuitīvi vienkārši likts 10 kā mana augšējo robežu tur. 

Un tomēr, kad es palaist to, pēc apkopojot to ar marku buggy2-- un tas apkopo OK. Tāpēc man nav sintakses kļūda šoreiz. Ļaujiet man iet uz priekšu tagad un palaist buggy2, Enter. Un tagad ritiniet uz augšu. Un ļaujiet man paaugstināt izmērs no loga. 

Man šķiet, ir 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Tātad tur ir 11 atsauces, lai gan Es skaidri izvirzīti 10 iekšpusē šīs cilpas. Tagad daži no jums varētu redzēt uzreiz kāda kļūda ir tāpēc, ka, protams, šis nav ļoti grūti kļūda, lai padarītu. Bet tas ir ļoti bieži izgatavoti ļoti agri. 

Ko es vēlos norādīt, lai gan, ir, kā es varētu skaitlis šo out? Nu, izrādās, ka CS50 Bibliotēka nāk ar ne tikai get_string un get_int un get_float un citas funkcijas. Tas arī nāk ar īpašu funkciju sauc eprintf, vai kļūda printf. Un tā pastāv tikai, lai padarītu tā mazliet vieglāk jums kad atkļūdošana savu kodu, lai tikai izdrukāt kļūdas paziņojumu uz ekrāna un zina, kur tas bija no. 

Tā, piemēram, viena lieta, ko es varētu izdarīt šeit ar šī funkcija ir this-- eprintf, un tad es iešu uz priekšu un teikt, es tagad% i, slīpsvītra, n. Un es esmu gatavojas, lai kontaktdakšu vērtības i. Un up top, jo tas atrodas CS50 bibliotēkā, Es iešu uz priekšu un ietver tāpēc man ir pieeja šai funkcijai. Bet pieņemsim apsvērt, kādi līnija 9 ir vajadzēja darīt. Es esmu gatavojas, lai izdzēstu šo galu galā. Šī nav nekāda sakara ar manu vispārējo mērķi. Bet eprintf, kļūda printf, ir tikai domāts sniegt man kādu diagnostikas informāciju. Kad es palaist savu programmu, es gribu redzēt šo uz ekrāna īslaicīgi kā arī vienkārši, lai saprastu kas notiek. 

Un, protams, par katru atkārtojuma šeit 9. līnijas Es gribu redzēt, kāda ir vērtība i? Kāda ir vērtība i? Kāda ir vērtība i? Un, cerams, es būtu tikai redzēt, ka ziņu, arī 10 reizes. 

Tāpēc ļaujiet man iet uz priekšu un recompile savu programmu, kā man ir jādara jebkurā laikā Es veikt izmaiņas. ./buggy2. Un now-- OK. Tur ir daudz vairāk notiek. Tāpēc ļaujiet man ritiniet uz augšu vēl lielāks logs. 

Un jūs redzēsiet, ka katrs Atsauces, joprojām drukā. Bet starp katru no viņiem tagad ir šis diagnostikas izejas formatēti šādi. Par manu programmu šeit vārds ir buggy2. No faila nosaukums ir buggy2.c. Līnija numurs, no kura tas bija iespiests ir līnija 9. Un pēc tam pa labi, ka ir kļūdas ziņojums, ka es esmu gaidījis. 

Un, kas ir jauka par šo ir tas, ka tagad man nav obligāti skaitīt manā galvā, ko mana programma dara. Es redzu, ka par Pirmo atkārtojumu i ir 0, pēc tam 1, tad 2, tad 3, tad 4, tad 5, tad 6, tad 7, pēc tam 8, tad 9, tad 10. Tātad pagaidiet minūti. Kas te notiek? Man joprojām šķiet, skaitot kā paredzēts līdz 10. 

Bet kur gan es sākt? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Tātad, ir 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- kā 11. pirksts liecina par problēmu. Man šķiet, ir skaitītas nepareizi manā cilpa. Nevis iet 10 iterācijas, Es esmu sāk 0, Es esmu beidzot un līdz 10. Bet tāpēc, ka, piemēram, dators, Es esmu sāk skaitīšanu 0, Es būtu skaitīs to, bet ne caur, 10. 

Un tā fix, es beidzot šeit sapratu, ir viena no divām lietām. Es varētu ļoti vienkārši pateikt skaita līdz mazāk nekā 10. Tātad, ir 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, kas ir, protams, pareizi, kaut arī tas izklausās mazliet nepareizi. Vai es varētu darīt, ir mazāks vai vienāds līdz 9. punktam, tik ilgi, kamēr es sāktu pie 0. Vai, ja jūs tiešām nepatīk, ka jums var saskaitīt pa 10, bet sākas 1. Bet atkal, tas vienkārši nav tik bieži. In programming-- kaut arī ne tik daudz Scratch-- bet plānošanu C un citās valodās, piemēram, JavaScript un Python un citi, tas ir tikai ļoti bieži Mūsu diskusija bināro lai tikai sāktu skaitot pie Vismazāk jūs varat, kas ir 0. Viss kārtībā. Tātad tas ir eprintf. Un atkal, tagad, ka es esmu sapratu, mana problēma, un es esmu gatavojas doties atpakaļ uz 0 izmantojot mazāk nekā 10, es esmu gatavojas iet un dzēst eprintf. 

Tā nedrīkst būt tur, kad es kuģis savu kodu vai iesniegt savu kodu vai parādīt to nevienam citam. Tas ir patiešām vienkārši domāts uz laiku tiek izmantots. Bet tagad es esmu fiksēts šis Īpaša problēma, kā arī. 

Nu, pieņemsim darīt vēl vienu piemēru šeit ka es esmu gatavojas sakult šādi. Es iešu uz priekšu un #include. $ 50 Un es iešu uz priekšu un #include. 

Un es esmu gatavojas, lai saglabātu šis fails kā buggy3.c. Un es iešu uz priekšu un deklarēt int galvenais (spēkā neesošs). Un tad iekšā tur Es esmu gatavojas darīt int i _ - Es gribu, lai īstenotu programmu ar get_negative_int. Tas nav funkcija, kas eksistē vēl. Tātad mēs ejam, lai īstenotu tas tikai brīdi. Bet mēs ejam, lai redzētu, kāpēc tas ir buggy pirmajā caurlaide. Un, kad es esmu gotten int no lietotāja, Es esmu tikai gatavojas drukāt% i ir negatīvs skaitlis, slīpsvītru, n, komats, i. Citiem vārdiem sakot, viss, ko es vēlas šo programmu darīt ir iegūt negatīvu int no lietotājs un pēc tam izdrukāt ka tāds un tāds ir negatīvs int. 

Tagad man ir nepieciešams, lai īstenotu šo funkciju. Tik vēlāk manā failu, es iešu priekšu un atzīt funkciju sauc get_negative_int (spēkā neesošs) - un mēs nāk atpakaļ uz to, ka līnija nozīmē jauna tādā moment-- int n; do-- do following-- printf n ir :. Un tad es esmu gatavojas darīt n - get_int, un izdarīt, bet n ir lielāks par 0. Un pēc tam atgriezties n ;. 

Tātad tur ir daudz notiek šo, bet neviens no tiem mēs neesam apskatīt pagājušajā nedēļā, vismaz īsumā. Tātad on line 10 šeit es esmu deklarēta funkcija sauc get_negative_int, un es esmu likts (spēkā neesošs), jo iekavas, iemesls ir tas neņem savu ieguldījumu. Es neesmu iet neko šai funkcijai. Es esmu tikai iegūt kaut ko atpakaļ no tā. 

Un ko es esmu cerot, lai nokļūt atpakaļ ir vesels skaitlis. Nav datu tips C sauc negative_int. Tas ir tikai int, tāpēc tas notiek būt par mums, lai pārliecinātos, ka vērtība, kas ir faktiski Atgriezās ir ne tikai int bet ir arī negatīva. 

On line 12 Es esmu deklarējot mainīgo sauc n un padarot to int tipa. Un tad atbilstoši 13. līdz 18. Esmu darot kaut ko, bet kaut kas ir patiess. Es dodos uz priekšu un drukāšana n ir, resnās zarnas, un pēc tam telpa, kā uzvednes lietotājam. 

Es tad zvana get_int un uzglabāt savu tā saukto atgriezto vērtību šajā mainīgo n. Bet es esmu gatavojas, lai saglabātu darot šis kamēr n ir lielāks par 0. Citiem vārdiem sakot, ja lietotājs dod man int un šis numurs ir lielāks par 0, ergo, pozitīvs, es esmu gatavojas tikai glabāt reprompting lietotājam, glabāt reprompting, piespiežot viņus sadarboties un sniegt man negatīvu int. 

Un, kad n ir faktiski negative-- pieņemsim lietotājs beidzot veidi -50, tad šī kamēr cilpa vairs nav taisnība jo -50 ir ne lielāka par 0. Tātad, mēs izkļūt no ka cilpa loģiski un atgriezties n. 

Bet tur ir viens cits lieta man ir jādara. Un es varu vienkārši darīt ko kopējot un ielīmējot viena līnija koda augšpusē faila. Man vajag, lai mācītu šķindēt, vai sola šķindēt, skaidri, ka es gribu, tiešām, iet un īstenot šī funkcija get_negative_int. Tā var tikai būt zemāka failā. Atkal, atgādināt, ka šķindēt skan lietas augšas uz leju, kreisās uz labo, lai jūs nevarat zvanu funkciju, ja šķindēt nezina tas notiek pastāvēt. 

Tagad, diemžēl, šī programma, kā daži no jums varētu būt pamanījuši, ir jau buggy. Ļaujiet man iet uz priekšu un darīt buggy3. Tā apkopo, lai mana problēma tagad nav sintakses kļūdas, piemēram, teksta kļūdas, tas tiešām būs loģiska kļūda, ka es esmu apzināti izgatavoti kā iespēja soli pa to, kas notiek. 

Es iešu uz priekšu tagad un palaist buggy3. Un es iešu priekšu un nesadarbojas. Es esmu gatavojas sniegt tai numuru 1. Tas nepatika, tāpēc tas pamudinot mani atkal. 

Kā par 2? 3? 50? Neviens no tiem strādā. Kā par -50? Un programma, šķiet, darbojas. 

Ļaujiet man mēģināt to vēlreiz. Ļaujiet man mēģināt -1, šķiet, darbojas. Ļaujiet man mēģināt -2, šķiet, darbojas. Ļaujiet man mēģināt 0. Huh, tas ir nepareizi. Tagad mēs to mazliet pedantiska šeit. Bet tas, protams, ir gadījums, 0 nav ne pozitīvu, ne negatīvu. Un tā tas, ka mana programma sakot, ka 0 ir negatīvs skaitlis, tas nav tehniski pareizi. 

Tagad, kāpēc tas ir to izdarīt? Nu, tas varētu būt skaidrs. Un, protams, programma ir domāts, lai būtu diezgan vienkāršs tāpēc mums ir kaut kas, lai izpētītu. 

Bet pieņemsim ieviest trešo atkļūdošanu paņēmiens šeit sauc debug50. Tāpēc tas ir programma ka mēs tikko veikts šogad sauc debug50 kas ļaus jums izmantot to, ko sauc iebūvēts grafiskā atkļūdotājs in CS50 IDE. Un atkļūdotājs ir tikai programma, kas parasti ļauj palaist savu programmu bet soli pa soli pa solim, līnija līdz pozīcijai, pauzes, poking apkārt, apskatot mainīgajiem, lai programmā nav tikai trieciens pagātnes jums un ātri drukāt kaut ko vai ne izdrukāt kaut ko. Tas dod jums iespēju, at cilvēka ātrums, kas mijiedarbojas ar to. 

Un, lai to izdarītu, jums vienkārši rīkoties šādi. Pēc apkopojot savu kodu, ko es jau darīju, buggy3, jums iet uz priekšu un palaist debug50 ./buggy. Tik daudz, piemēram help50 ir palaist help50 un tad komanda, debug50 ir palaist debug50 un tad nosaukums komandu. 

Tagad skatīties, kas notiek uz mana ekrāna, uz labajā pusē, jo īpaši. Kad es hit Izpildīt, visi pēkšņi tas, labajā pusē paver uz ekrāna. Un tur ir daudz notiek uz pirmā acu uzmetiena. Bet tur nav pārāk daudz jāuztraucas par vēl. 

To rāda man visu kas notiek iekšpusē manā programmā tieši tagad, un, izmantojot šos pogas up top tad ļauj man soli pa manu kodu galu galā soli pa soli pa solim. Bet ne tikai vēl. Paziņojums, kas notiek. Pēc mana termināļa logā Es esmu tiek piedāvāts n. Un es iešu uz priekšu un sadarboties šo laiku un ierakstiet -1. Un kaut arī nedaudz cryptically, -1 ir negatīvs skaitlis, kā gaidīts. 

Un tad bērns iziet ar statuss 0 GDBserver iziešanas. GDB, GNU Debugger, ir nosaukums pamatā esošā programmatūra kas īsteno šo atkļūdotājs. Bet tas viss īsti nozīmē, atkļūdotājs devās prom, jo ​​mana programma atmest un viss bija labi. Ja es gribu, lai patiesi atkļūdot savu programmu, Man ir preemptively pateikt debug50, kur vēlos sākt pastiprināšanu, izmantojot manu kodu? 

Un varbūt vienkāršākais veids to darīt, ir šāds. Ja es lidināties pār noteka manas redaktors šeit, tik tiešām tikai sānjoslas šeit, pa kreisi no līnijas numuru, Ievērojiet, ka, ja es vienkārši noklikšķiniet vienu reizi, man mazliet sarkans dot. Un ka maz sarkans dot, kā stop zīmi, nozīmē, hey, debug50, pauze izpilde manu kodu tieši tur, kad es palaist šo programmu. 

Tātad, pieņemsim darīt. Ļaujiet man iet uz priekšu un palaist savu programmu atkal ar debug50 ./buggy3, Enter. Un tagad, paziņojums, kaut atšķirīgs ir noticis. Es neesmu tiek piedāvāts vēl manā termināļa logā kaut ko, jo man nav gotten tur vēl manā programmā. Ievērojiet, ka 8. līnijā kas tagad iezīmēts, un tur ir maz bultiņa kreisā sakot, jums ir apturēta šeit. Šī līnija kods, līnijas 8, vēl nav izpildīts. 

Un, kas ir ziņkārīgs, ja es paskatos nekā šeit uz labajā pusē, paziņojums, ka man ir vietējais mainīgs, vietējā tādā nozīmē, ka tas ir iekšā pašreizējās funkcijas. Un tā vērtība, acīmredzot pēc noklusējuma, un veida ērti, ir 0. Bet man nav rakstīt 0. Tas vienkārši notiek, ir tā Noklusētā vērtība brīdī. 

Tāpēc ļaujiet man iet uz priekšu un darīt to tagad. Ļaujiet man iet uz priekšu un uz top tieši šeit, es esmu gatavojas iet uz priekšu un noklikšķiniet uz šo pirmo ikonas, kas nozīmē soli pāri, kas nozīmē, nav izlaist tas taču soli pa šo līniju kodu, izpildot to pa ceļam. 

Un tagad, paziņojums, mans ātra tikko mainīts. Kāpēc ir tā, ka? Es esmu teicis debug50, palaist šo rindiņu kodu. Ko tas līnija kods darīt? Liek man par int. LABI. Ļaujiet man sadarboties. Ļaujiet man iet uz priekšu tagad un -1 tips, Enter. Un tagad paziņojums, kas ir mainījies. No labajā pusē, mana vietējo mainīgais i tiek norādīts kā -1 tagad. Un tas joprojām ir int tipa. 

Un paziņojums, arī mans tā sauktais zvanu kaudze, no kurienes es pauzes? Mēs runājam vairāk par tas nākotnē. Bet zvanu kaudze tieši norāda uz to, funkcijas pašlaik kustībā. Šobrīd tas ir tikai galvenais. Un tieši tagad vienīgais vietējais mainīgais ir tā, i ar vērtību 1. 

Un, kad es beidzot soli pa šo līniju šeit, ar šo pašu ikonu augšējā labajā stūrī, -1 Ir negatīvs skaitlis. Tagad tas ir pauzēm pār šo cirtaini lencēm. Pieņemsim, ļaujiet to darīt lieta. Es soli pa šo līniju, un voila. 

Tāpēc ne viss, kas briesmīgi informēts vēl, bet tas man pauze un domāju, ka ar loģiski ko šī programma dara. Bet tas nebija kļūdains gadījums. Darīsim to atkal šādi. 

Es esmu gatavojas atstāt šo pārtraukumpunkts 8. Saskaņā ar sarkanu punktu. Es esmu gatavojas atkārto debug50. Tas automātiski apturēta šeit. Bet šis laiks, tā vietā, lai kāpj pa šo līniju, ļaujiet man tiešām iet iekšā get_negative_int un izdomāt, kāpēc ir tā, pieņemot 0 par derīgu atbildi? 

Tā vietā, noklikšķinot Step Over. Es iešu uz priekšu un noklikšķiniet soli. Un paziņojums, ka līnija 8, kas ir tagad uzsvēra tagad pēkšņi kļūst line 17. 

Tagad tas nav tik atkļūdotājs ir izlaidis līnijas 14 un 15 un 16. Tas ir tikai tur nekas lai parādītu jums tur. Tie ir tikai deklarējot mainīgos, un tad tur ir vārds Do un tad atvērta cirtaini lencēm. Vienīgais funkcionāla līnija, kas ir sulīgs tiešām tas ir viens šeit, 17. Un tas ir, ja mēs esam apturēta automātiski. 

Tātad printf ( "n.is:") ;, tā ka nav noticis vēl. So iesim uz priekšu un noklikšķiniet Step Over. Tagad mans ātru, patiešām, mainīts uz ( "n ir:"). Tagad get_int, es neesmu gatavojas apgrūtināt pastiprināšanu, jo šī funkcija bija , ko CS50 bibliotēkā. Tas ir iespējams, pareizi. 

Tāpēc es esmu gatavojas iet uz priekšu un veida sadarbību, piešķirot tai int, bet ne negatīvs int. Tāpēc ļaujiet man iet uz priekšu un hit 0. Un tagad, kas notiek šeit kad es nokļūt uz leju, lai līnija 21? Man nav vēlreiz jāatkārto. Man nav, šķiet, ir iestrēdzis šajā cilpa. Citiem vārdiem sakot, šis dzeltens bar neturēja notiek apkārt, un apkārt, un apkārt. 

Tagad, kāpēc tā? Nu, n, kas ir n tieši tagad? Es varu apskatīt vietējā mainīgie atkļūdotājs. n ir 0. Labi, kāds bija mans stāvoklis? 

20-- līnija 20 ir labi, 0 ir lielāks par 0. Tas nav taisnība. 0 ir ne lielāka par 0. Un tāpēc es izcēlās no šo. 

Un tā, ka tāpēc uz līnijas 21, ja es tiešām turpinās, Es esmu gatavojas atgriezties 0, pat gan man vajadzēja noraidīt 0 jo ne faktiski ir negatīvs. Tāpēc tagad, man nav īsti pat rūp atkļūdotājs. Got to, man nav nepieciešams zināt, kas vēl notiek. 

Tāpēc es esmu gatavojas iet uz priekšu un vienkārši noklikšķiniet uz pogas Atskaņot, un ļaujiet šo pabeigt līdz. Tagad, es esmu sapratu, ka mans bug ir acīmredzami uz līnijas 20. Tas ir mans loģiska kļūda. 

Un tā, ko es gribu darīt, lai to mainītu? Ja problēma ir tā, ka es neesmu tuvojas 0, tas ir tikai loģiska kļūda. Un es varu teikt, bet n ir ir lielāks par vai vienāds ar 0, glabāt atkal un atkal pamudinot lietotājam. 

Tātad, atkal, vienkārši kļūda, varbūt pat skaidrs, kad redzējāt mani uzrakstiet to tikai pirms dažām minūtēm. Bet takeaway šeit ir tas, ka ar debug 50, un ar atkļūdošanu programmatūra vispārīgāk, Jums ir šī jaunā atrasts strāvas padevi staigāt pa savu kodu, meklēt izmantojot šo labajā panelī, ko Jūsu mainīgie vērtības. Tātad jums nav obligāti ir izmantot kaut ko kā jūs eprintf izdrukāt šīs vērtības. Jūs faktiski var redzēt vizuāli uz ekrāna. 

Tagad aiz to, tas ir vērts atzīmēt ka tur ir vēl viens paņēmiens, kas ir tiešām super bieži. Un jūs varētu brīnīties, kāpēc tas maz puisis šeit ir sēdējis uz skatuves. Tātad tur ir šī metode, kas parasti pazīstams kā gumijas pīles debugging, kas patiešām ir tikai derība ar to, ka bieži, kad programmētāji rakstāt kodu viņi ne vienmēr sadarbojoties ar citiem, vai strādā kopīgu vidē. 

Viņi veida mājās. Varbūt tas ir vēlu vakarā. Viņi mēģina izdomāt dažas bug to kodu. Un viņi vienkārši nav redzēt to. 

Un tur nav kaimiņiem. Nav TF. Nav CA apkārt. Visi viņi ir savā plauktā tas ir maz gumijas ducky. 

Un tā gumijas pīle atkļūdošana ir tikai šis uzaicinājums domāt par kaut ko tik dumjš kā to kā reālu būtne, un faktiski iet caur savu kodu mutiski šai nedzīvs objekts. Tā, piemēram, ja šis ir mans piemērs here-- un atgādina, ka agrāk problēma bija tas, ja es dzēst šo pirmo rindiņu kodu, un es iet uz priekšu un darīt buggy 0 atkal, atceros, ka man bija šie kļūdu ziņojumus šeit. Tātad ideja šeit, smieklīgi gan I justies brīdī darot publiski, ir tas, ka kļūda. 

Labi, tā mana problēma ir tā, ka es esmu netieši paziņoja bibliotēkas funkciju. Un tas bibliotēka funkcija printf. Declare-- OK, deklarēt man atgādina prototipu. 

Tas nozīmē, ka man ir nepieciešams, lai faktiski pateikt kompilators iepriekš, kādu funkcija izskatās. Uzgaidi minūti. Man nebija standarta io.h. Liels paldies. 

Tik vienkārši šis process of-- jums nav nepieciešams, lai tiešām ir pīle. Bet šī ideja pastaigas sevi caur savu kodu tā, ka jūs pat dzirdēt sevi, lai jums realizēt izlaidumus savu piezīmes, parasti ideja. 

Un, iespējams, vairāk loģiski, ne tik daudz ar šo vienu, bet jo vairāk iesaistīties piemērs mēs vienkārši darījām buggy 3.c, jūs varētu staigāt sevi caur to sekojoši. Tātad viss labi, gumijas ducky, DDB, ja Jums gribas. Šeit mums ir manā galvenā funkcija, Es esmu aicinot saņemt negatīvu int. 

Un es esmu kļūst atgriešanās vērtību. Es esmu uzglabājot to kreisajā pusē on line 8. ar mainīgo sauc i. OK, bet gaidīt, kā to darīja kas saņem šo vērtību? Ļaujiet man apskatīt funkcijas atbilstoši 12. 

Atbilstoši 12, mums ir iegūt negatīvu int. Neņem izejmateriālus, tomēr atgriezties int, OK. Es apliecinu, on line 14 mainīgs n. Tas notiek, lai saglabātu veselu skaitli. Tas, ko es gribu. 

Tāpēc šādas darbības, kamēr n is-- ļaut mani atsaukt ko fix es jau veikts. Tāpēc, kamēr n ir lielāks nekā 0, izdrukāt n ir, OK. Un tad zvaniet get int saglabāti n. Un pēc tam pārbaudiet, vai n ir 0, n ir not-- tur tas ir. Tātad, atkal, jums nav nepieciešama faktisko pīle. Bet tikai ejot caur sevi Jūsu kods kā intelektuālo izmantošanu bieži jums palīdzēt saprast, kas notiek, nevis tikai kaut ko dara kā šis, skatās uz ekrāna, un nerunāju sevi caur tas, kas godīgi nav gandrīz kā efektīvu metodi. Tātad jums ir tā, skaits dažādiem paņēmieniem par faktiski atkļūdošana kodu un atrast vainu, kas visi būtu instrumenti jūsu rīkkopa tāpēc, ka jūs neesat vēlu naktī, it īpaši, tu esi dining zāles, vai darba laika, banging galvu pret sienas, mēģinot atrisināt kādu problēmu. Apzināties, ka ir programmatūras rīki. Ir gumijas pīle instrumenti. Un tur ir viss personāls atbalstīt gaida aizdot roku. 

Tāpēc tagad, vārds par problēmu komplekti, un par to, ko mēs ceram tevi izkļūt no tiem, un cik mēs iet par novērtēšanā. Per Kurss ir mācību programmas, CS50 problēma komplekti tiek vērtēti četriem primārajiem asīm, tāpēc līdz speak-- jomu, pareizību, dizains, un stils. Un darbības joma tieši atsaucas uz to, cik daudz gabalos esat sakosts off? Cik daudz problēmu, tu esi mēģinājis? Kāds pūles tu esi izpaužas? 

Pareizība ir, vai programmas darbu, kā tas ir paredzēts vienam CS50 specifikācijai kad jūs sniedzat konkrētas izejvielas vai daži rezultāti nāk atpakaļ? Dizains ir visvairāk subjektīvs no tiem. Un tas ir viens, ka būs veikt garāko mācīties un garāko mācīt, it ciktāl tā vārīties uz leju, lai, cik labi uzrakstīts ir jūsu kods? 

Tā ir viena lieta, lai tikai drukāt pareizs izejas vai atgriešanās pareizās vērtības. Bet jūs darāt to, kā iespējas efektīvāk? Vai jūs darāt to plaisu un iekarot, vai binārā meklēšana kā mēs drīz redzēt, ka mēs darījām Pirms divām nedēļām ar tālruņa grāmatu? Vai ir labāki veidi, lai atrisinātu problēma, nekā jums šobrīd ir šeit? Tas ir iespēja labāku dizainu. 

Un tad style-- cik diezgan ir jūsu kods? Jūs pamanīsiet, ka es esmu diezgan īpaši par indenting manu kodu, un pārliecinoties manu mainīgos ir pamatoti nosaukts. n, bet īstermiņa, ir labs vārds, lai numurs, i par skaitīšanas skaitlim, s par virkni. Un mēs varam būt garāks mainīgo nosaukumi stils. Stils ir, cik labi ir jūsu kods meklēt? Un kā lasāms tas ir? 

Un laika gaitā, ko jūsu Tehniskās vienošanās un TFS darīs gaitā ir nodrošināt jūs ar to veida kvalitatīvas atgriezeniskās saites lai jums labāk šajās dažādiem aspektiem. Un attiecībā uz to, kā mēs novērtēt katru no šīm asīm, tas parasti ir ļoti maz spaiņi, lai jūs, parasti, iegūt sajūtu par to, cik labi jūs darāt. Un, protams, ja jūs saņemat punktu skaits par kāds no tiem axes-- pareizību, dizains un stils especially-- ka numurs parasti ir robežās no 1 līdz 5. Un, burtiski, ja jūs saņemat 3 s sākumā semestra, šī ir ļoti laba lieta. Tas nozīmē, ka ir vēl iespējami uzlabojumi, ko jūs varētu cerēt uz ņemot klases pirmo reizi. Ir cerams daži griestu bit uz kuru jūs esat iecerējušas panākt. Un tā kļūst 3 ir uz Agrākais gabali, ja ne kāds 2 s un 4 s, ir, protams, ir laba lieta. Tas ir labi diapazonā, labi ietvaros cerības. 

Un, ja jūsu prāts ir sacīkšu, gaidiet minūtes, trīs no pieciem. Tas tiešām ir 6 no 10. Tas ir 60%. Mans Dievs, tas F. 

Tas nav. Tas nav, jo fakts, ka. Drīzāk, tas ir iespēja uzlabot gaitā semestra. Un, ja jūs saņemat kādu Poors, tie ir iespēja lai izmantotu darba laika, protams sadaļas un citus resursus. 

Best ir iespēja, tiešām, lepoties, cik tālu jūs esat nākt gaitā semestra. Tātad saprotu, ja nekas cits, trīs ir labs. Un tas ļauj vietas izaugsmei laikā. 

Par to, kā šie asis ir svērtā, reāli tu esi gatavojas pavadīt lielāko daļu sava laika iegūt lietas, darbu, nemaz nerunājot pareizi. Un tā pareizību tendence vērtē visvairāk, jo ar šis multiplikatīvā koeficientu trīs. Dizains ir arī svarīgi, bet kaut kas jums nav obligāti pavada visus šos stundas cenšas iegūt lietas vienkārši strādāt. 

Un tā tas ir svērtā vairāk viegli maz. Un tad stils tiek svērtas vismazāk. Pat ja tas ir ne mazāk svarīgi būtiski, tas ir tikai, iespējams, Vieglākais lieta darīt pareizi, atdarinot piemēriem darīt lekciju un sadaļā, ar lietām labi atkāpi, un komentēja, un tā tālāk, ir viens no vienkāršākajiem lietas, kas darīt un iegūt tiesības. Tā kā tāds, saproti ka tie ir punkti kas ir salīdzinoši viegli satvert. 

Un tagad vārds uz this-- akadēmisko godīgumu. Tātad per kurss s mācību programma, jūs redzēsiet ka protams, ir diezgan Mazliet valodas ap šo. Un protams, ņem jautājumu akadēmiskais godīgums diezgan nopietni. 

Mums ir atšķirība, lai labāk vai sliktāk, ka tā nosūta katru gadu vairāk studentus disciplināratbildības nekā lielākā daļa jebkurš cits Protams, ka es apzinos. Tas ne vienmēr ir liecina par to, ka CS studenti, vai CS50 studenti, ir jebkuru mazāk godīgs nekā jūsu klasesbiedriem. Bet realitāte, ka šajā pasaule, elektroniski, mēs vienkārši ir tehnoloģiskā nozīmē atklāt to. 

Ir svarīgi, lai mums taisnīgums visā klasē ka mēs atklāt to, kā paaugstināt jautājums, kad mēs redzam lietas. Un tikai uzzīmēt zīmējumu, un patiešām palīdzēt kaut kā šis izlietne, tie ir skaitļi, kas studenti pēdējo 10 gadu laikā kas ir iesaistīts dažās šie jautājumi akadēmisko godīgumu, ar dažiem 32 studentiem no krišanas 2015, kas ir teikt, ka mēs veikt jautājums ir ļoti nopietni. Un, galu galā, šie skaitļi sacerēt, pavisam nesen, aptuveni 3%, 4%, vai arī tā no klases. 

Tātad super vairumam studentu šķiet, ka līnijas ir skaidri. Bet vai paturēt to prātā, īpaši vēlu naktī, kad cīnās ar daži risinājumu problēmai, kas, mehānismus lai iegūtu sevi labāk atbalsts, nekā jūs varētu domāju, pat tajā stundā. Saprast, ka tad, kad mēs saņemam studentu iesniegumi, mēs šķērsot salīdzināt katru iesniegumu šogad pret katru iesniegumu pagājušajā gadā, pret katru iesniegumu no 2007. gada, un kopš, apskatot, kā arī, koda repozitoriju online, diskusiju forumos, darba vietas. Un mēs pieminēt, tiešām, visi labad par pilnīgu atklātību, ka, ja kāds cits var atrast internetā, protams, tāpēc mēs varam kurss. Bet, patiešām, gars Kursa vārīties uz leju uz šo klauzulu mācību programmu. Tas patiešām ir vienkārši, būtu saprātīgi. 

Un, ja mums bija izstrādāt par ka tikai mazliet vairāk valodu, saprast, ka būtība visu darbu, kas jūs iesniegt šo kursu jābūt savu. Bet gan tas, ka ir noteikti iespējas un pamudinājums, un pedagoģiskā vērtība pagrieziena uz others-- sevi, tad TFS, CAS, tad TAS, un citi klasē, atbalstam, nemaz nerunājot par draugu un roommates, kuri ir mācījušies pirms CS un programmēšana. Un tāpēc ir pabalsts par to. Un vispārējais noteikums īkšķis ir this-- kad lūdz palīdzību, jūs varat parādīt savu kodu, lai citiem, bet jūs nevar skatīt savējo. Tātad, pat ja jūs esat pie darba laika, vai D zālē, vai kaut kur citur strādā pie dažiem gabals komplektu, strādājot kopā pastu, kas ir pilnīgi fine, pie dienas beigās savu darbu galu galā būtu pieder katram no jums attiecīgi, un ne daži sadarbības pūles, izņemot gala projektu, kurā tas ir atļauts un jāveicina. 

Saprast, ka, ja jūs esat cīnās ar kaut ko un jūsu draugs vienkārši notiek būt labāk šo, tad jums, vai labāk šo problēmu, nekā jūs, vai mazliet tālāk uz priekšu, nekā jūs, tas ir pilnīgi pamatoti, lai ieslēgtu savam draugam un teikt, hey, Vai jums prātā, apskatot manu kodu šeit, palīdzētu man vietas, ko mana problēma ir? Un, cerams, pēc interese par pedagoģisko vērtību ka draugs nav tikai saka, oh, to izdarītu, bet drīzāk, ko jūs trūkst tiešsaistē 6, vai kaut kas tamlīdzīgs? Bet risinājums ir ne par draugu pie jums teikt, oh, labi, šeit, ļaujiet man pull šo augšu, un parādīt savu risinājumu Jums. Tātad tas ir līnija. Jūs parādīt savu kodu citi, bet jūs nedrīkstat skatīt savējo, ievērojot otru ierobežojumi gaitā ir mācību programmas. 

Tāpēc paturiet prātā šo tā sauktā nožēlu klauzula Gaitā ir mācību programmas, kā arī, ka, ja jūs izdarīt kādu darbību, kas nav saprātīgi, bet lai to uzmanība kursa galvām 72 stundu laikā, protams, var izvirzīt vietējās sankcijas, kas var būt neapmierinoša vai ja pakāpe darbu iesniegto. Bet protams, nebūs atsaukties jautājums tālākai disciplināratbildības, izņemot gadījumus atkārtotu aktu. Citiem vārdiem sakot, ja jūs veikt dažas stulbi, it īpaši vēlu vakarā, lēmums ka nākamajā rītā vai divas dienas vēlāk, tu pamosties un saprast, Ko es domāju? Jūs darīt CS50 ir noieta lai noteiktu, ka problēma un kurai pieder līdz ar to, tā ka mēs Jūs sagaidīs pusceļā un risināt ar to ir jautājums, kas ir gan izglītības un vērtīgs, lai jūs, bet joprojām represīva kaut kādā veidā. Un tagad, lai ņemtu malu off, šis. 

[VIDEO PLAYBACK] 

[SKAN MŪZIKA] 

[END PLAYBACK] DAVID J. Malan: Labi, mēs esam atpakaļ. Un tagad mēs skatāmies viens no Pirmais no mūsu reālās pasaules domēniem in CS50, māksla kriptogrāfijas, māksla sūtīšanas un saņemšanas slepenas ziņas, šifrētu ziņas, ja jūs, ka var atšifrē tikai tad, ja jums ir daži pamatelementiem, ka sūtītājs ir arī. Tātad, lai motivētu šo mēs ņemšu apskatīt šo lieta šeit, kas ir piemērs noslēpums dekoders gredzens, kas var tikt izmantoti, lai noskaidrotu kāds noslēpums vēstījums patiesībā ir. Patiesībā, atpakaļ diena pakāpē skolā, ja Jums kādreiz nosūtīts slepeno ziņojumus kādu draugu vai kādu sasmalcināt klasē, jūs varētu būt doma jūs ir gudrs ar jūsu gabals papīra maiņas, piemēram, no A līdz B, un B uz C, un C līdz D, un tā tālāk. Bet jūs faktiski šifrējot Jūsu informācija, pat ja tas bija mazliet niecīgs, nebija ka grūti skolotājam realizēt, labi, ja jūs vienkārši mainīt B uz A un C uz B, jūs faktiski izdomāt kāda ziņa bija, bet jums bija šifrēšana informāciju. 

Tu tikai darot to vienkārši, līdzīgi Ralphie šeit slavenā filma, kas spēlē diezgan daudz ad nauseum katru ziemu. [VIDEO PLAYBACK] -Be Tas zināms visiem, ka Ralfs Parker ir šo iecelts Little Orphan Annie Secret Circle un ir tiesības uz visiem apbalvojumus un ieguvumi tiem notiek. 

-Signed, Little Orphan Annie, counter-parakstīta Pierre Andre, ar tinti. Apbalvojumus un ieguvumi, jau Deviņu gadu vecumā. 

[Kliegšana] -Aiziet. Pieņemsim galā ar to. Man nevajag visu, kas jazz par kontrabandistu un pirātiem. 

-Listen Rīt nakts Secinājumu piedzīvojums melnā pirātu kuģa. Tagad ir pienācis laiks Annie slepeno ziņu par jums locekļi Secret Circle. Atceries, bērni, tikai dalībnieki no Annie 's Secret Circle var atšifrēt Annie slepeno ziņu. 

Atceries, Annie ir atkarīgs no jums. Iestatiet savu pins B2. Šeit ir vēstījums. 12, 11-- 

-Es Esmu, manu pirmo slepenu sanāksmi. 

-14, 11, 18, 16. 

-Pierre Bija liels balss šovakar. Es varētu pateikt, ka šovakar vēstījums bija ļoti svarīgi. 

-3, 25, tas ir vēstījums no Annie pati. Atceries, nesaki nevienam. 

-90 Sekundes vēlāk, es esmu vienīgais istabu mājā, kur zēns no deviņiem varētu sēdēt privātumu un atšifrēt. Aha, B! Es devos uz nākamo, E. 

Pirmais vārds ir jābūt. S, tas nāk vieglāk, U, 25-- 

OH, come on, Ralphie, es gotta go! 

-I'll Būt tiesības uz leju, Ma! Gee sīkšana! 

-T, O, pārliecinieties, kuri paredzēti, pārliecinieties, ko? Kāds bija Little Orphan Annie cenšas pateikt? Noteikti ko? 

-Ralphie, Andy ir nokļuvis iet, jūs lūdzu iznākt? 

-Visas Labi, Ma! Es būšu labi out! 

-Es Tika tuvojas tagad. Spriedze bija briesmīga. Kas tas bija? Liktenis planētas var pakārt bilancē. 

-Ralphie! Andy gotta go! 

-I'll Būt labi ārā, lai kliedz skaļi! 

-Almost Tur, mani pirksti lidoja, manu prātu bija tērauda lamatas, katru poru vibrācijas. Tas bija gandrīz skaidrs, jā, jā, jā. 

-Be Noteikti dzert Ovaltine. Ovaltine? Apaļīgs tirdzniecības? Kuces dēls. [END PLAYBACK] DAVID J. Malan: Labi, tāpēc tas bija ļoti garš ceļš ieviest kriptogrāfija, un arī Ovaltine. Faktiski, no šīs vecās sludinājumu šeit, kāpēc ir Ovaltine tik labs? Tas ir koncentrēts ieguve nogatavojies miežu iesals, Pure krēmīgu govs piens, un speciāli sagatavoti kakao, kopā ar dabas fosfatīdu un vitamīniem. Tas ir vēl bagātināti ar papildu vitamīnus B un D, ​​Yum. Un jūs joprojām varat saņemt to, acīmredzot, Amazon, kā mēs to darījām šeit. 

Bet motivācija šeit bija iepazīstināt kriptogrāfija, īpaši A kriptogrāfiju veids, ko sauc kā slepeno atslēgu kriptogrāfiju. Un kā liecina nosaukums, viss par slepeno atslēgu šifrēšanas sistēmas drošība, ja jūs, metodika lai tikai kodēšanas informācijas apmaiņu starp diviem cilvēkiem, ir tas, ka tikai sūtītājs un tikai saņēmējs zināt noslēpums key-- dažas vērtības, daži noslēpums frāze, daži noslēpums numurs, kas ļauj viņiem gan šifrētu un atšifrēt informāciju. Un kriptogrāfija, tiešām, ir tikai tas no nedēļas 0. 

Tā ir problēma, kur tur ir ieejas, tāpat faktisko ziņojumu Angļu vai kāds valoda, kas jums vēlaties nosūtīt kādam klasē, vai visā internetā. Ir daži produkcija, kas gatavojas būt scrambled ziņa, ka jums vēlas saņēmējs saņemt. Un pat tad, ja kāds vidū saņem pārāk, jūs nevēlaties tos vienmēr varēs atšifrēt to, jo iekšpusē šis melnā kaste, vai algoritms, ir kāds mehānisms, kādu soli pa solim instrukcijas, lai pieņemtu šo ievade un pārveidojot to par produkcija, kas cerams drošā veidā. 

Un, patiesībā, ir daži leksika šajā pasaulē šādi. Vienkāršs teksts ir vārds dators zinātnieks būtu izmantot, lai aprakstītu ievadi ziņojums, tāpat kā angļu valodā vai kāds valoda jums tiešām vēlas, lai nosūtītu uz kādu citu cilvēku. Un tad ciphertext ir motokross uz šifrēta, vai šifrēta, variantu. 

Bet tur ir vēl viena sastāvdaļa šeit. Ir viens cits pievade slepenā atslēga kriptogrāfija. Un tas ir pats galvenais, kas ir, parasti, kā mēs redzēsim, numuru, vai vēstule, vai vārds, neatkarīgi algoritms tas faktiski sagaida. 

Un kā jūs atšifrēt informāciju? Kā jūs atšifrēt to? Nu, jūs vienkārši mainīt izejas un ieejas. 

Citiem vārdiem sakot, ja kāds saņem savu šifrētu ziņu, viņš vai viņa vienkārši ir zināt, ka vienu un to pašu atslēgu. Viņi ir saņēmuši ciphertext. Un ar tapām šos divus ieejas fani šifrēšanas sistēmu, algoritmu, šī melnā kaste, kas jānāk sākotnējo teksta,. Un tā tas ir ļoti augsts līmenis viedoklis par to, kas kriptogrāfija ir faktiski visu par. 

Tātad, pieņemsim tur nokļūt. Pieņemsim tagad izskatās zem kapuci kaut mēs esam bijuši ņemot par pašsaprotamu, lai pagājušajā nedēļā, un par to sesija here-- virkni. Virkne, beigās, dienā ir tikai rakstzīmju secība. 

Tas varētu būt Hello World, vai sveiki Zamyla, vai neatkarīgi. Bet ko tas nozīmē būt secība rakstzīmes? Faktiski CS50 bibliotēka sniedz mums datu tips sauc virkne. 

Bet tur faktiski nav tādas lietas kā string C. Tas tiešām ir tikai secība raksturs, raksturs, raksturs, raksturs, atpakaļ, atpakaļ, uz atpakaļ, atpakaļ, atpakaļ iekšā no datora atmiņu, vai RAM. Un mēs apskatīt dziļāk, ka nākotne, ja mēs skatāmies uz sevi atmiņas, un izmantošana, kā arī draudi, kas ir iesaistīti. 

Bet pieņemsim apsvērt virkni Zamyla. Tātad tikai nosaukums cilvēka šeit, Zamyla, kas ir secība rakstzīmes, Z-A-M-Y-L-A. Un tagad pieņemsim, ka Zamyla vārds tiek glabāti iekšpusē datoru programma. 

Nu, tas saprotams, ka mums varēs apskatīt šiem burtiem individuāli. Tāpēc es esmu tikai gatavojas izdarīt nedaudz kaste ap Zamyla nosaukumu šeit. Un tas ir gadījumā C, ka tad, kad jūs ir virkne, piemēram Zamyla-- un varbūt ka virkne ir atgriezies no funkcija, piemēram, get virkni, Jūs faktiski var manipulēt to raksturu ar raksturu. 

Tagad tas ir piederīgs, lai saruna pie rokas, jo in kriptogrāfiju ja jūs vēlaties mainīt A uz punktu B, un B uz C, un C līdz D, un tā tālāk, jums ir nepieciešams, lai varētu apskatīt atsevišķas rakstzīmes virknē. Jums ir nepieciešams, lai varētu mainīt Z uz kaut ko citu, tad A uz kaut ko citu, tad M līdz kaut kas cits, un tā tālāk. Un tāpēc mums ir nepieciešams veids, programmatiski, tāpēc runāt, C, lai varētu mainīt un apskatīt atsevišķiem burtiem. Un mēs varam izdarīt šādi. 

Ļaujiet man iet galvu atpakaļ CS50 IDE. Un ļaujiet man iet uz priekšu un izveidotu jaunu failu ka es aicinu šo laiku string0, kā mūsu pirmais šāda piemēram, dot c. Un es iešu uz priekšu un pātagu to šādi. 

Tātad ietver CS50.h, un tad arī standarta io.h, ko es esmu gandrīz vienmēr gatavojas būt lietot manas programmas, vismaz sākotnēji. int galveno tukšumu, un tad šeit es esmu darīsim stīgas izpaužas saņemt virkni. Un tad es esmu gatavojas iet uz priekšu un darīt to. Es gribu iet uz priekšu un, kā veselība pārbaudītu, tikai teikt, hello, procenti s, semikols, padara virkni 0. Uh oh, ko es daru šeit? Ak, man nav pievienojiet to. Tātad mācība, ka nebija apzināta. 

Tātad kļūda, vairāk procenti konvertēšanu nekā datu argumentiem. Un tas ir, ja, kas line 7-- Labi, tāpēc man ir, quote likt pēdiņas beigās, tas ir mans string printf. Man procentiem zīmi. Bet es esmu trūkst otro argumentu. 

Es esmu trūkst komats s, kas Man tomēr ir iepriekšējos piemēros. Tik laba iespēja, lai noteiktu vēl viena kļūda, nejauši. Un tagad ļaujiet man palaist string0, ierakstiet Zamyla. OK, sveiki Zamyla. 

Tāpēc mēs esam palaist šāda veida programmas daži citi laiki tagad. Bet pieņemsim darīt kaut ko maz atšķiras šoreiz. Nevis tikai drukāšanas Zamyla s Visa vārds out ar printf, pieņemsim darīt rakstzīmi, raksturs. 

Es esmu gatavojas izmantot par cilpu. Un es esmu gatavojas sniegt sevi skaitīšanas mainīgais, ko sauc par i. Un es esmu gatavojas glabāt atkārtojot, tāpēc ilgi, kamēr i ir mazāks par garumu s. 

Izrādās, mēs neesam darīt šo pēdējo reizi, ka c nāk ar funkcija sauc Stērlingas. Atpakaļ dienā, un vispār tomēr, īstenojot funkciju, cilvēki bieži vien izvēlas ļoti kodolīgs nosaukumi šāda veida skaņa patīk tas, ko jūs vēlaties, pat ja tas ir pazudis dažas patskaņi vai burtus. Tātad Stirling ir funkcijas nosaukumu, kas aizņem arguments starp iekavas, ka vajadzētu būt virkne. Un tas tikai atgriež vesels skaitlis, garums šī virkni. 

Tātad šī cilpa uz 7. līnijā notiek sākt skaitīšana i ir vienāds ar 0. Tas notiek, lai pieauguma i par katru atkārtojuma ar 1, jo mēs esam bijuši dara pāris reizes. Bet tas notiek, lai tikai darīt tas līdz vietai kad es ir garums no virknes pati. 

Tātad šis ir veids, kā, visbeidzot, atkārtojot pār rakstzīmes virknē kā ir šādi. Es esmu gatavojas izdrukāt nav visa virkne, bet procenti c, vienu rakstzīmi kam seko jaunu rindu. Un tad es esmu gatavojas iet uz priekšu, un man ir nepieciešams teikt, es gribu, lai drukātu kārtējā raksturs s. 

Tātad, ja i ir mainīgs, kas norāda indekss virknes, kur Jums ir tā, man ir nepieciešams, lai varētu saka, dod man kārtējam raksturu s. Un c ir veids, kā to tas ar kvadrātiekavās. Jūs vienkārši pateikt nosaukumu virkne, kas šajā gadījumā ir s. Tad jūs izmantojat kvadrātiekavas, kas ir parasti ir tikai virs jūsu Atgriezties vai Enter taustiņu uz klaviatūras. Un tad jūs nodot indekss raksturu, kas jūs vēlaties drukāt. Tātad indekss tiek būs number-- 0, vai 1, vai 2, vai 3, vai dot, dot, dot, kādu citu numuru. 

Un mēs nodrošinām, ka tas notiek, lai būt pareizo numuru, jo I sākas skaitīšana 0. Un pēc noklusējuma, pirmā rakstzīme virknē, pēc vienošanās 0. Un otrais raksturs ir kronšteins 1. Un trešais raksturs ir kronšteins 2. Un jūs nevēlaties, lai iet pārāk tālu, bet mēs ne tāpēc, ka mēs esam gatavojas tikai pieauguma i līdz to vienāds ar garuma virknes. Un kurā brīdī, šis cilpa apstāsies. 

Tāpēc ļaujiet man iet uz priekšu un saglabājiet šo programma, un palaist veikt virkni 0. Bet es ieskrūvē augšu. Netieši atzīstot bibliotēka funkciju Stirling ar šāda veida un such-- tagad, tas izklausās pazīstami. Bet tas nav printf. Un tas nav get virkni. 

Man nav screw up tāpat šoreiz. Bet paziņojums leju šeit mazliet uz leju tālāk, ietver header string.h, nepārprotami sniedz deklarācija Stirling. Tātad faktiski ir pavediens tur. 

Un tiešām izrādās tur ir cita header fails ka mēs esam nav izmantoti klasē vēl, bet tas ir starp tiem pieejami jums, ko sauc string.h. Un šajā failu, string.h ir Stirling deklarētas. Tāpēc ļaujiet man iet uz priekšu un saglabājiet to, veikt virkni 0-- jauki, nav kļūdu ziņojumus šoreiz. 

./string0 Zamyla, un Es esmu par to hit Enter, pie kura getstring punktu notiek atgriezt virkni, ielieciet to s. Tad, ka cilpa gatavojas atkārtot pār s varoņi vienam, un izdrukāt tos pa vienam katrā rindā, jo Man bija, ka reversā slīpsvītra n beigās. Lai es varētu izlaist šo slīpsvītru n, un tad tikai drukāt Zamyla visu tajā pašā rindā, efektīvi reimplementing printf, kas nav tik noderīgs. Bet šajā gadījumā, man nav darījuši. Es esmu tiešām drukā vienu raksturs laikā, vienam katrā rindiņā, lai mēs faktiski redzēt efektu. 

Bet man vajadzētu atzīmēt, viena lieta šeit. Un mēs atgriezties tas nākamajā nedēļā. Izrādās, ka šis kods ir potenciāli buggy. 

Izrādās, ka saņemt virkni un dažas citas funkcijas dzīvē to ne vienmēr atgriezt to, ko jūs gaida. Mēs zinām no klases pēdējā laiks, tas, ka nokļūt string ir paredzēts atgriezties virkni. Bet ko tad, ja lietotājs veic šādus garš vārds, vai punktu, vai eseja ka tur ir tikai nav pietiekami atmiņa ar datoru, lai ietilptu to. 

Tāpat, kas notiks, ja kaut kas noiet nepareizi zem motora pārsega? Tas varētu notikt bieži, bet tas varētu notikt reizi bet, ļoti reti. Un tā izrādās, ka saņemt virkni un funkcijas, piemēram, tas ne vienmēr vienmēr atgriežas stīgas. Tie varētu atgriezties dažas kļūdas vērtību, daži Sentinel vērtība tā sakot, kas norāda, ka kaut kas ir nogājis greizi. Un jūs tikai zināt, tas no uzzinot to klasē tagad, vai ir lasīt dažas vairāk dokumentāciju. Izrādās, ka saņemt virkni var atgriezties vērtību sauc null. Null ir īpaša vērtība, ka mēs atgriezties nākamajā nedēļā. Bet tagad, tikai zinu, ka, ja es gribu būt patiesi pareizi virzīties uz priekšu izmantojot get virkni, es būtu ne tikai sauc to, un akli izmantot savu atgriešanās vērtību, uzticoties, ka tā ir virkne. 

Es vispirms vajadzētu teikt, hey, pagaidiet minūti, tikai turpināt, ja s nav vienāds null, kur null, atkal, ir tikai dažas īpašas vērtības. Un tas ir vienīgais īpašu vērtību jūs jāuztraucas par par get virkni. Saņemt virkne ir vai nu iet atgriezt virkni vai null. 

Un šī izsaukuma zīme vienlīdzības zīme jūs varētu zināt, no varbūt matemātikas klasē ka jūs varētu izdarīt vienādības zīmi ar līnija caur to norādīt nav vienāds. Tas nav vispār raksturs jūs varat rakstīt uz klaviatūras. Un tāpēc vairumā programmēšanas valodas, ja jūs vēlaties teikt nav vienāds, Jūs lietojat izsaukuma zīmi, citādi zināma kā sprādziena. Tātad jūs sakāt sprādziena vienāds, kas nozīmē ne vienāds, loģiski. Tas ir tāpat kā tur nav lielāka par vai vienāda ar vai mazāka nekā vai vienāds ar tastatūras taustiņu ka tas viss vienā simbolu. Tātad, tāpēc, iepriekšējos piemēros, jūs atklātu kronšteinu, un pēc tam vienādības zīmi, lai darīt ir lielāks nekā vai, teiksim, mazāk nekā. 

Tātad, kāda ir takeaway šeit? Tas ir vienkārši veids, tagad no Ieviešot šo sintaksi, šī funkcija, atkārtojot pār individuālo rakstzīmes string. Un tāpat kā tiem laukumā kronšteini ļauj jums iegūt pie viņiem, apsvērt šos kvadrātiekavas kā veida hinting pie šī pamata dizains, kurā katrs raksturs iekšpusē virknes ir sava veida liekami kaut kur zem kapuci jūsu datora atmiņā. 

Bet pieņemsim veikt variantu šo. Izrādās, ka šis programma ir pareiza. Tātad par CS50 ir asis, lai izvērtētu kods, tas ir pareizi tagad. It īpaši tagad, ka es esmu pārbaudot null, šī programma būtu nekad crash. Un es tikai zinu, ka no pieredzes. Bet tur nekas cits, ka mēs varam tiešām iet greizi šeit. Bet tas nav ļoti labi izstrādāts, tāpēc iesim atpakaļ uz pamatus. 

Pirmkārt, principles-- Ko dara cilpa darīt? A cilpa dara trīs lietas. Tas initializes daži vērtība, ja jūs lūgt to. Tā pārbauda nosacījumu. Un tad pēc katras atkārtojuma, pēc katra cikla, tā pieauguma soli daži vērtība vai vērtības, šeit. 

Tātad, ko tas nozīmē? Mēs sāktu i līdz 0. Mēs pārbaudām un pārliecinieties, ka i ir mazāks nekā garums s, kas ir Z-A-M-Y-L-A, tā, kas ir mazāks nekā 6. Un, protams, 0 mazāk nekā 6. 

Mēs izdrukāt Z no Zamyla vārdu. Tad mēs pieauguma i no 0 līdz 1. Mēs pēc tam pārbauda, ​​ir 1 mazāks par garumu s? No s garums ir 6. Jā, tā ir. 

Tātad mēs drukāt A Zamyla vārdu, ZA. Mēs pieauguma i no 0, 1, 2. Mēs pēc tam pārbauda, ​​ir 2 mazāk nekā garums Zamyla vārda. 6- tik 2 ir mazāks nekā 6. Jā, pieņemsim izdrukāt tagad M in Zamyla vārds, tad trešā zīme. 

Galvenais šeit ir tāda, ka uz katru atkārtojuma stāsts, es esmu pārbaudot, ir tā, i mazāk nekā garumu Zamyla? Bet nozveju, ka Stirling nav īpašums. Tie no jums, kas ir ieprogrammēts Pirms Java vai citās valodās varētu zināt garumu virkne ir īpašums, tikai daži lasīt tikai vērtību. 

C, šajā gadījumā, ja tas ir funkcija, kas ir burtiski saskaitot rakstzīmes Zamyla katru reizi mēs saucam šo funkciju. Katru reizi, kad jūs lūgt datoru lietošanā Stirling, tas ir ņemot apskatīt Zamyla, un saprotams, Z-A-M-Y-L-A, 6. Un tas atgriež 6. Nākamreiz, kad zvanīt tā iekšā, ka cilpa, tas notiek, lai apskatīt Zamyla atkal, teiksim, Z-A-M-Y-L-A, 6. Un tas notiek, lai atgrieztos 6. Tātad, kas ir stulba par šo dizainu? 

Kāpēc mans kods nav 5 no 5 dizaina tieši tagad, tāpēc runāt? Nu, es esmu lūdzot jautājums nevajadzīgi. Es esmu dara vairāk darba, nekā man vajag. 

Tātad, pat ja atbilde ir pareiza, es esmu lūdzot datoru, kas ir garums Zamyla atkal, un atkal, un atkal, un atkal? Un šī atbilde ir nekad gatavojas mainīt. Tas vienmēr būs 6. 

Tāpēc labāks risinājums nekā tas būtu tas nākamais versija. Ļaujiet man iet uz priekšu un nodot to atsevišķs fails sauc string1.c, tikai, lai saglabātu to atsevišķi. Un izrādās A cilpa, jūs faktiski var deklarēt vairākas mainīgos uzreiz. 

Tāpēc es esmu gatavojas glabāt i un noteikt to līdz 0. Bet es esmu arī gatavojas pievienot komatu, un saka, man mainīgo sauc n, kuru vērtība ir vienāda virknes garumu s. Un tagad, lūdzu, savu stāvokli tik ilgi, kamēr i ir mazāks nekā n. 

Tātad šādā veidā, loģika ir identisks beigās, dienā. Bet es esmu atceroties vērtība 6, šajā gadījumā. Kas ir garums Zamyla vārda? Un es varēšu to n. 

Un es esmu joprojām pārbaudot stāvoklis katru reizi. Ir 0 mazāk nekā 6? Ir 1 mazāk nekā 6? Ir 2 mazāk nekā 6, un tā tālāk? 

Bet es neesmu lūdzot datoru atkal, un atkal, kas ir garums Zamyla vārda? Kas garums Zamyla vārda? Kas garums šī Zamyla nosaukums? Es burtiski atcerēties, ka pirmais un atbildēt tikai šajā otrajā mainīgā n. Tātad tagad tas būtu ne tikai pareizi, bet arī labi izstrādāta. 

Tagad, kas par stilu? Es esmu nosaukts manu mainīgos diezgan labi, es teiktu. Viņi super kodolīgs tiesības tagad. Un tas ir pilnīgi naudas sodu. 

Ja jums ir tikai viens string programmā, Jūs varētu arī aicināt tas ir par virkni. Ja jums ir tikai viens mainīgais skaitīšanas programmā, Jūs varētu arī aicināt to i. Ja jums ir garums, n ir super kopīgs, kā arī. Bet es neesmu komentēja kāds manu kodu. 

Man nav informējusi nolasītājs vai tas ir mans TF, vai TA, vai tikai colleague-- to, kas ir paredzēts kas notiek šajā programmā. Un tāpēc, lai iegūtu labu stilu, ko es gribu darīt ir this-- kaut tāpat lūgt lietotāja ievadi. Un es varētu pārrakstīt Tas jebkurā vairākos veidos. 

Pārliecinieties s-- pārliecinieties get string atgriezās virkni. Un pēc tam uz here-- un tas, iespējams, vissvarīgākais comment-- atkārtot pār rakstzīmes s vienā laikā. Un es varētu izmantot jebkuru izvēle angļu valodā šeit aprakstīt katru Šo gabalos kodu. 

Ievērojiet, ka man nav likts komentēt katru līnijas kodu, tiešām tikai par interesantu tiem, tie, kas ir kāda nozīme, ka es varētu gribu, lai super skaidrs, kāds lasot manu kodu. Un kāpēc jūs zvanot nokļūt stīgu lūgt lietotājs ievadi? Pat, ka viens nav obligāti viss, kas aprakstošs. Bet tas palīdz pastāstīt stāstu, jo otrajā rindā stāstā ir, pārliecinieties, saņemt string atgriezās virkni. 

Un trešais rindā stāstā ir, atkārtot pār rakstzīmes ir viens laikā. Un tagad tikai labu pasākumu, Es iešu uz priekšu un pievienot vēl viens komentārs, ka tikai saka print i-th raksturs s. Tagad, ko es esmu darījis dienas beigās? 

Man ir pievienoti daži English vārdi formā komentārus. Slīpsvītra slash simbols nozīmē, hey, dators, tas ir par cilvēku, nav par jums, dators. Tātad viņi ignorēja loģiski. Viņi tikai tur. 

Un, protams, CS50 IDE parāda tos kā pelēks, kā nozīmīgi, bet ne galvenais programmai. Paziņojums, ko jūs tagad var darīt. Vai jūs zināt, C programmēšanas vai ne, jūs var vienkārši stāvēt atpakaļ pie šī programma, un nosmelt komentārus. Jautāt lietotājam ievadi, pārliecinieties, saņemt string atgriezās virkne, atkārtot pār rakstzīmes s pa vienam, izdrukāt raksturs i-th raksturs s-- jums nav pat ir apskatīt kodu saprast, ko šī programma dara. Un, vēl labāk, ja jūs pats meklēt šajā programmā nedēļu vai divas, vai mēnesi, vai gadu, jūs pārāk nav skatās uz kodu, mēģinot atcerēties, kas bija man mēģina darīt ar šo kodu? 

Jūs esat teicis pats. Jūs esat aprakstīja to pats, vai kādu kolēģis, vai TA, vai TF. Un tā tas tagad būtu pareizs, un labs dizains, un galu galā labi stils, kā arī. Tā darīt paturēt to prātā. 

Tātad tur ir viens cits lieta, ko es esmu gatavojas darīt šeit ka tagad var atklāt tieši to, kas ir notiek zem motora pārsega. Tātad tur ir šī funkcija C, kā arī citas valodas, sauc Typecasting ka vai nu netieši vai nepārprotami ļauj pārvērst no viena datu tipa uz citu. Mēs esam nodarbojas tik tālu šodien ar stīgām. 

Un stīgas ir rakstzīmes. Bet atceros no nedēļas 0, kādi ir varoņi? Rakstzīmes ir tikai abstrakcija virsū numbers-- aiz skaitļiem, un zīmes aiz skaitļi ir patiešām tikai abstrakcija virsū bināro numuru, kā mēs definēts to. 

Tātad rakstzīmes ir skaitļi. Un skaitļi ir rakstzīmes, tikai atkarībā no konteksta. Un izrādās, ka iekšā datorprogrammu, Jūs varat norādīt, kā jūs vēlaties meklēt pie biti iekšpusē šo programmu? 

Atsaukt no nedēļas 0 ka mums bija ASCII, kas ir tieši šis kods kartēšanas vēstules numuru. Un mēs teicām, kapitāls A ir 65. Capital B ir 66, un tā tālāk. 

Un paziņojums, mēs būtībā ir chars uz augšējā rindā šeit, jo C varētu viņiem piezvanīt, rakstzīmes, un pēc tam Ints par otrās rindas. Un izrādās, jūs varat pārvērst nemanāmi starp diviem, parasti. Un, ja mēs vēlamies darīt tas apzināti, mēs varētu vēlēties, lai risinātu kaut kas tamlīdzīgs. 

Mēs varētu vēlēties, lai pārvērstu lielie burti pazemināt gadījumā, vai mazie burti uz lielajiem burtiem. Un izrādās, tur ir faktiski modelis šeit mēs varam aptvert tikai brīdi. Bet aplūkosim vispirms Piemērs darot skaidri. 

Es iešu atpakaļ CS50 IDE. Es esmu gatavojas, lai izveidotu failu sauc ASCII 0.c. Un es iešu uz priekšu un pievienot savu standarta io.h augšpusē, int galvenais spēkā neesošu augšpusē manu funkciju. Un tad es esmu tikai gatavojas darīt following-- A cilpu no i ir vienāds, teiksim, 65. 

Un tad es būs mazāks nekā 65, plus 26 burti alfabēta. Tāpēc es let datoru do math par mani tur. Un tad iekšā šīs cilpas, Kas es esmu gatavojas izdrukāt? 

% C ir% i slīpsvītru n. Un tagad es gribu, lai kontaktdakšu divām vērtībām. Es esmu uz laiku nodot jautājumu iezīmē tur uzaicināt jautājumu. 

Es vēlos atkārtot no 65 tālāk 26 alfabēta burtiem, izdrukāšana par katru atkārtojuma ka raksturs ir neatņemama ekvivalents. Citiem vārdiem sakot, es gribu atkārtot vairāk nekā 26 numuri drukāšanu ko ASCII raksturs ir, burts, un ko attiecīgais numurs is-- tiešām tikai atjaunošanās diagramma no šī slaida. Tātad, kādi ir šie jautājuma zīmes būt? 

Nu, izrādās, ka otrajā viens ir vienkārši mainīgais i. Es gribu redzēt, ka par numuru. Un vidū arguments šeit, es varu pateikt datoru ārstēt šo skaitli es kā raksturs, tā kā aizstāt to šeit C. procentiem 

Citiem vārdiem sakot, ja es, tad cilvēka programmētājs, zināt tie ir tikai skaitļi dienas beigās. Un es zinu, ka 65 vajadzētu karti uz kādu raksturu. Ar šo skaidru vairākumu, ar iekavās nosaukums datu tipu, kuru vēlaties konvertēt uz, un slēgtā iekavas, jūs varat pateikt dators, hey, dators, pārvērst šo skaitli uz char. 

Tātad, kad es palaist šo programma pēc apkopojot, pieņemsim redzēt, ko es get-- veikt ASCII 0. Darn tas, ko es daru nepareizi šeit? Izmantojiet nedeklarēta identifikatoru, visas tiesības, kas nav tīši, bet pieņemsim redzēt, ja mēs nevaram Iemesls caur šo. 

Tik line five-- tāpēc es nedabūju ļoti tālu pirms skrūvēšanai up. Tas ir labi. Tātad line 5 i vienāds 65-- es redzu. Tāpēc atcerieties, ka C, atšķirībā no dažiem valodas, ja jums ir iepriekšēja programmēšana pieredze, jums ir pateikt datoru, atšķirībā no nulles, ko Mainīgā veids tas ir. 

Un es aizmirsu par atslēgu frāze šeit. Saskaņā pieci, es esmu sācis lietot i. Bet es neesmu teicis C kādi dati veida tā ir. Tāpēc es esmu gatavojas iet šeit un saka, ah, padara skaitlis. 

Tagad es esmu gatavojas iet uz priekšu un recompile. Tas nemainīgs. ./ascii0 Enter, tas ir sava veida atdzist. Ne tikai tas ir super ātri, lai lūgt datoru šo jautājumu, nevis meklē to uz slaidu, tas izdrukāt vienu katrā rindā, A ir 65, B ir 66, visu ceļu down-- kopš I izdarīja 26 times-- ar burtiem z, kas ir 90. Un, patiesībā, nedaudz vairāk viedo būtu ir man nepaļauties uz datora, lai pievienotu 26. Es varētu būt tikko veikts 90, kā arī, tik ilgi jo man nav darīt to pašu kļūdu divreiz. Es gribu iet uz augšu cauri z, ne tikai uz augšu pa y. 

Tātad tas ir skaidri vairākumu. Izrādās, ka šis nav pat nepieciešams. Ļaujiet man iet uz priekšu un atkārto šo kompilatoru, un atkārto ASCII 0. Izrādās, ka C ir diezgan gudrs. 

Un printf, it īpaši, ir diezgan gudrs. Ja jūs vienkārši nokārtot i divreiz gan vietturi, printf sapratīs, oh, labi es jūs pazīstu deva man integer-- kādu numuru, piemēram, 65 vai 90, vai neatkarīgi. Bet es redzu, ka jūs vēlaties, lai es formatēt šo numuru, piemēram, raksturs. Un tā printf varētu netieši nodot int uz char jums, kā labi. Tātad tas nav problēma vispār. 

Bet paziņojums, jo šīs līdzvērtības mēs faktiski var darīt, kā labi. Ļaujiet man iet uz priekšu un veikt vienu cita versija this-- ASCII 1.c Un tā vietā, atkārtojot pār veseli skaitļi, tiešām var trieciens jūsu prātā atkārtojot pār rakstzīmes. Ja char c saņem kapitāla A, I gribu iet uz priekšu un darīt to, tik ilgi, kamēr C ir mazāks par vai vienāds Kapitāla Z. Un katra atkārtojuma Es gribu pieauguma C, es varu tagad manā printf līnija šeit teiksim, C procenti ir procenti i atkal, komats C. 

Un tagad, es varu iet pretējā virzienā, liešanas raksturu skaidri līdz veselam skaitlim. Tātad, atkal, kāpēc jūs darīt? Tas ir nedaudz dīvaini, lai kārtotu no skaits ziņā rakstzīmes. 

Bet, ja jūs saprotat, kas ir notiek zem motora pārsega, tur tiešām nav maģija. Jūs vienkārši sakot, hey, dators dod me mainīgu sauc C tipa char. Inicializēt to kapitāla A. And ievērosiet vienu pēdiņām jautājumu. 

Par rakstzīmes C, atceros no pagājušajā nedēļā, jūs izmantojat vienu pēdiņas. Virknes, vārdus, frāzes, jūs izmantojat dubultās pēdiņas. OK, dators, glabāt darot, tā ilgi, kamēr raksturs ir mazāks nekā vai vienāds ar z. Un es zinu no mana ASCII tabulu, ka visi Šo ascii kodu ir blakus. 

Tur nav spraugu. Tātad, tas ir tikai līdz Z, atdalīti ar vienu skaitli katra. Un tad es varu pieauguma char, ja es tiešām gribu. Dienas beigās, tas ir tikai skaitlis. Es zinu, tas. Tāpēc es varu tikai pieņemt, lai pievienotu 1 līdz to. 

Un tad šoreiz, es drukāt c, un tad neatņemama ekvivalents. Un man nav pat nepieciešams skaidru vairākumu. Es varu ļaut printf un dators skaitlis lietas, tā, ka tagad, ja man palaist padarīt Ascii1./ascii1, Man tieši tas pats, kā arī. 

Bezjēdzīgi programma, though-- neviens gatavojas faktiski rakstīt programmatūru lai noskaidrotu, kāda bija skaitlis, kas kartes uz A vai B, vai Z? Jūs tikai gatavojas Google to, vai skatīties to tiešsaistē, vai meklēt to uz priekšmetstikliņa, vai tamlīdzīgi. Tātad, ja tas faktiski nokļūt noderīga? 

Nu, runājot par ka slaidu, paziņojums tur ir faktiskā raksts šeit starp lielajiem burtiem un mazie burti, kas nebija nejauša. Ievērojiet, ka kapitāls A ir 65. Mazie a ir 97. Un cik tālu ir zemāks gadījums? 

Tātad, 65 ir, cik daudz soļu attālumā no 97? Tātad 97 mīnus 65 ir 32. Tātad kapitāls a ir 65. Ja pievienojat 32 tam, jums mazajiem burtiem a. Un, līdzvērtīgi, ja jūs atņemt 32, jūs saņemsiet atpakaļ uz kapitāla izveidojuši lielisku pats ar B uz nelielu b, liels C līdz maz c. 

Visi šie nepilnības ir 32 intervālu. Tagad, tas, šķiet, lai ļautu mums kaut ko darīt, piemēram, Microsoft Word, vai Google Docs iezīme, kur jūs varat izvēlēties visu, un tad saka, mainīt visu uz mazajiem burtiem, vai mainīt visu uz lielajiem burtiem, vai mainīt tikai pirmo vārdu no soda ar lielajiem burtiem. Mēs faktiski var darīt kaut ko piemēram, ka mums pašiem. 

Ļaujiet man iet uz priekšu un saglabātu failu šeit sauc kapitalizēt 0.c. Un iesim uz priekšu un pātagu up programmu kas dara tieši ka šādi. Tātad ietver CS50 bibliotēka. Un ietver standarta I / O. 

Un es zinu, tas ir Drīzumā. Tāpēc es esmu gatavojas nodot to tur jau, string.h, tāpēc man ir pieeja lietas, piemēram, Stirling, un tad int galvenais neesošu, kā parasti. Un tad es iešu uz priekšu un darīt virknes saņem saņemt virkni, tikai, lai iegūtu virkni no lietotāja. Un tad es esmu gatavojas darīt mana veselība pārbaudi. Ja virkne nav vienāds null, tad tas ir droši, lai turpinātu. Un ko darīt, es gribu darīt? Es esmu gatavojas atkārtot no i ir vienāds ar 0, un n līdz virknes garumu s. 

Un es esmu gatavojas darīt to tik ilgi, kamēr i ir mazāks nekā n, un es plus plus. Līdz šim, es esmu patiešām tikai aizņemoties idejas no iepriekš. Un tagad es esmu gatavojas ieviest filiāli. 

Tāpēc domāju, ka atpakaļ uz nulles, kur mums bija šīs dakšas uz ceļa, un pagājušajā nedēļā C. Es esmu gatavojas saku, ja i-th raksturs s ir lielāks par vai vienāds ar mazajiem burtiem a, and-- in nulles jūs varētu burtiski saka un, bet C jūs sakāt ampersands, ampersand-- un i-th raksturs s ir mazāks par vai vienāds ar pazeminātu case z, pieņemsim darīt kaut ko interesantu. Pieņemsim faktiski izdrukāt raksturs bez newline ka ir raksturs virknē, i-th rakstura virkni. 

Bet iesim uz priekšu un atņemt 32 no tā. Else ja rakstura string ka mēs meklējam nav starp maz a un maz Z, iet uz priekšu un tikko iespiests to ārā nemainīgs. Tātad, mēs esam ieviesuši šis strīdīgi notācija lai mūsu virknes iegūt pie i-th rakstura virkni. 

Es esmu pievienojis kādu nosacītu loģiku, piemēram, Scratch pagājušajā nedēļā nedēļu vienu, kur Es esmu tikai izmantojot manu pamattiesību izpratne par to, kas ir notiek zem motora pārsega. Vai i-th raksturs s ir lielāks par vai vienāds ar simbolu? Tāpat, tas ir 97, vai 98, vai 99, un tā tālāk? 

Bet tas ir arī mazāks par vai vienāds vērtībai mazo z? Un ja tā, ko tas līnija nozīmē? 14, tas ir sava veida dīgļi visa ideja, kapitalizēt vēstuli ar vienkārši atņemot 32 no tā, Šajā gadījumā, jo es zinu, uz vienu, ka diagramma, kā mani numuri ir pārstāvētas. So iesim uz priekšu un palaist to, pēc apkopojot kapitalizēt 0.c, un palaist kapitalizēt 0. 

Let 's ierakstiet kaut ko līdzīgu Zamyla visās mazajiem ienākt. Un tagad mums ir Zamyla visās lielajiem burtiem. Pieņemsim ierakstiet Rob visās mazajiem burtiem. Pamēģināsim Jason visās mazajiem burtiem. Un mēs turpinām iegūt piespiedu kapitalizācija. Tur ir neliela kļūda, ka es veida nav paredzēt. Paziņojums mana jaunā ātru beidzas up uz vienas līnijas, kā to nosaukumiem, kas jūtas mazliet netīrs. 

Tāpēc es iešu šeit, un faktiski beigās šīs programmas izdrukāt newline raksturs. Tas ir viss. Ar printf, jums nav nepieciešams caurlaide mainīgajiem vai formātā kodu. Jūs varat burtiski vienkārši izdrukāt kaut kā newline. 

So iesim uz priekšu un veikt kapitalizēt 0 atkal atkārto to, Zamyla. Un tagad tas ir nedaudz prettier. Tagad mans ātra ir savā jaunā rindā. Tā ka viss ir labi un labs. Tātad tas ir labs piemērs. Bet man nav pat obligāti nepieciešams cietā kodu no 32. Tu zini ko? Es varētu say-- man nav kādreiz atcerēties, kāda ir atšķirība. 

Bet es zinu, ka, ja es ir mazo burtu, Es būtībā gribu atņemt off kāds attālums ir starp maz a un liels, jo, ja es pieņemu, ka visiem citiem burtiem, ir tāds pats, ka vajadzētu iegūt darba darīts. Bet nevis darīt, jūs zināt, ko? Tur ir vēl viens veids, kā vēl. 

Ja tas ir kapitalizēt 1.c-- ja es būtu likt ka atsevišķā failā. Darīsim kapitalizēt 2.c šādi. Es esmu gatavojas tiešām attīrītu to šeit. Un tā vietā, pat ņemot zina vai rūp tiem zemā līmenī īstenošanas detaļas, es esmu vietā tikai gatavojas drukāt raksturs, quote likt pēdiņas beigās, C procentiem, un tad izsauktu citu funkciju, pastāv, kas ņem argumentu, kas ir raksturs, kā šis. 

Izrādās C, tur ir cita funkcija zvans uz augšējo, kas, kā tā nosaukums iesaka aizņem raksturs un padara to uz lielajiem burtiem ekvivalents, un tad nosūta atpakaļ lai printf varētu pievienojiet to tur. Un tā, kā to izdarīt, lai gan, es nepieciešams ieviest vēl vienu failu. Izrādās, tur ir cits fails ka jūs zināt tikai no klases, vai mācību grāmatas vai tiešsaistes norāde, ko sauc par C type.h. 

Tātad, ja es piebildīšu, ka pat starp manu galvu failus, un tagad atkārtoti sastādīt šo programmu, capitalize2, ./capitalize2 Enter. Pieņemsim ierakstiet Zamyla visās mazie, joprojām darbojas vienādi. Bet jūs zināt, ko? Izrādās, ka uz augšējo ir dažas citas funkcijas. 

Un ļaujiet man iepazīstināt šis komandu šeit, veida neveikli nosaukts, bet cilvēks ar rokām. Izrādās, ka lielākā daļa Linux datoriem, kā mēs izmantojam here-- Linux operētājsistēmu system-- ir komandu sauc cilvēks, kas saka: hey, datoru, dod man datora rokasgrāmatu. Ko jūs vēlaties meklēt šajā rokasgrāmatā? 

Es gribu uzmeklēt funkciju aicināja augšējo, Enter. Un tas ir nedaudz mistisks lasīt reizēm. Bet paziņojums mēs esi Linux programmētājs rokasgrāmatu. Un tas viss teksts. Un ievērosiet, ka tur ir Nosaukums funkcijas šeit. Izrādās, tas ir brālēns sauc pazemināt, kas dara pretējo. Un paziņojums saskaņā konspekts, lai izmantotu šo funkcionēt man dokumentu, tā sakot, stāsta mani, ka es nepieciešams iekļaut c type.h. Un es zināju, ka no prakses. 

Lūk, tas parāda man divi prototipi par funkciju, tā ka, ja es kādreiz vēlos izmantot šo Es zinu, ko tās veic, kā ievade, un ko viņi atgriežas kā produkciju. Un tad, ja es izlasīju apraksts, es redzu sīkāk, kāda funkcija dara. Bet vēl svarīgāk, ja Es skatos zem atgriešanās vērtību, tā saka vērtība atgriezās ir ka konvertē vēstuli vai C, sākotnējais ieguldījums, ja konversija bija nav iespējams. 

Citiem vārdiem sakot, lai augšējā centīšos pārvērst vēstuli lielajiem burtiem. Un ja tā, tas būs atpakaļ. Bet, ja tā nevar dažiem reason-- varbūt tas jau lielie burti, varbūt tas ir izsaukuma zīme vai kādu citu punctuation-- tas ir tikai gatavojas atgriezt sākotnējo C, kas nozīmē, es varu darīt manu kodu labāk izstrādāti šādi. 

Man nav nepieciešams visu šie darn rindas kodu. Visas līnijas I noklikšķinājuši tikko uzsvēra var tikt sabruka tikai vienu vienkāršu līnija, kas ir this-- printf procenti c uz augšējo S grupā i. Un tas būtu piemērs labāku dizainu. 

Kāpēc īstenot 7 vai 8 līnijām kodu, kāds tas bija es tikai izdzēsts, ja jūs varat, nevis sabrukt visas šīs loģikas un lēmumu pieņemšanā vienā rindā, 13 tagad, ka balstās uz bibliotēku function-- funkcija, kas nāk ar C, bet dara tieši to, ko vēlaties darīt. Un, godīgi sakot, pat ja tas nenāca ar C, jūs varētu īstenot to pats, jo mēs esam redzējuši, ar iegūtu negatīvu int un saņemt pozitīvu int pagājušajā nedēļā, kā arī. 

Šis kods tagad ir daudz vieglāk lasāmu. Un, protams, ja mēs ritiniet uz augšu, izskatās, cik daudz kompaktāka šī versija mana programma ir. Tas ir nedaudz smagnējās tagad, ar visiem šiem ietver. Bet tas ir OK, jo tagad es stāvu uz pleciem programmētājiem pirms manis. Un kurš tas bija, kas īstenoti, lai augšējā patiešām darīja man labu, līdzīgi kurš īstenoti Stirling patiešām darīja man labu kādu laiku atpakaļ. Un tāpēc tagad mums ir labāks dizains programma kas īsteno tieši tādu pašu loģiku. 

Runājot par Stirling, ļaujiet man iet uz priekšu un darīt to. Ļaujiet man iet uz priekšu un saglabājiet šis fails kā stirling.c. Un izrādās, mēs varam mizu atpakaļ viena cita slāņa diezgan vienkārši tagad. Es iešu uz priekšu un pātagu līdz citai programmai galvenā šeit vienkārši atkārtoti traktortehnikas virknes garums šādi. Tātad, šeit ir līnija kodu, kas izpaužas man virknes no lietotāja. Mēs pastāvīgi izmantojot šo atkal un atkal. Ļaujiet man sniegt sev mainīgo sauc n int tipa, kas saglabā numuru. 

Un ļaujiet man iet uz priekšu un rīkojieties šādi loģiku. Kaut arī n-th raksturs s dara nav vienāds slīpsvītru 0, iet uz priekšu un pieauguma n. Un tad izdrukāt printf procenti i n. Es apgalvo, ka šī programma šeit, neapstrīdot virknes garumu, skaitļi, garumu virknes. 

Un maģija ir pilnībā iekapsulēti 8. līnijā šeit ar to, kas izskatās jaunā sintaksi, tas slīpsvītru 0 vienu pēdiņām. Bet kāpēc tā? Nu, apsvērt to, kas ir bijis notiek visu šo laiku. 

Un kā malā pirms es aizmirst, saprotu, Arī, ka papildus cilvēks lapas kas nāk ar tipisku Linux sistēma kā CS50 IDE, apzināties, ka mēs, Protams darbinieki, ir arī veica mājas versija Šīs pašas idejas, ko sauc reference.cs50.net, kas ir visiem šiem pašiem cilvēks lapas, viss tas pats dokumentācija, kā arī nedaudz kaste augšpusē, kas ļauj pārvērst visu iepriekš diezgan arcane valodas mazāk apmierināti režīms, kurā mēs, mācībspēki, ir izgājušas cauri un mēģināja vienkāršot daži no valodas, lai saglabātu lietas vērsta uz idejām, un ne daži no tehniskās. Tāpēc paturiet prātā, reference.cs50.net kā citu resursu, kā arī. 

Bet kāpēc stīgu garuma darbu kā es ierosināja pirms brīža? Lūk Zamyla vārds atkal. Un šeit ir Zamyla vārds liekami, jo es glabāt darot, uzzīmēt zīmējumu par to ko, tiešām, tikai rakstzīmju sekvence. Bet Zamyla neeksistē izolēti raidījumā. 

Kad jūs rakstīt un palaist programmu, jūs izmantojat savu Mac vai jūsu datoru kā atmiņu, vai RAM tā runāt. Un jūs varat iedomāties dators, kam ir daudz gigabaitu atmiņas šajās dienās. Un kabriolets nozīmē miljardiem, tik miljardiem baitu. 

Bet pieņemsim attīt laikā. Un domāju, ka mēs esam izmantojot patiešām vecs dators, kas ir tikai 32 baiti atmiņas. Es varētu, uz mana datora ekrāna, vienkārši izdarīt šo veic šādi. 

Es varētu vienkārši teikt, ka mana dators ir visas šīs atmiņas. Un tas ir kā stick atmiņas, ja jūs atceraties mūsu attēlu no pēdējo reizi. Un, ja es vienkārši sadalīt tas pietiekami laikos, Es apgalvot, ka man ir 32 baiti atmiņas uz ekrāna. 

Tagad, patiesībā, es varu tikai izdarīt līdz šim šajā ekrānā šeit. Tāpēc es esmu gatavojas iet uz priekšu, un tikai pēc vienošanās, izdarīt mana datora atmiņā kā režģis, ne tikai kā vienu taisnu līniju. Konkrēti, es apgalvot, ka šobrīd tas režģis, šis 8. līdz 4 režģis, vienkārši pārstāv visas 32 baiti no pieejamās atmiņas manā Mac, vai pieejams manā datorā. Un viņi iesaiņošana uz divām līnijām, tikai jo tas iekļaujas vairāk uz ekrāna. Bet tas ir pirmais baits. Tas ir otrais baits. Tas ir trešais baits. 

Un tas ir 32. baitu. Vai arī, ja mēs domājam līdzīgi datoru zinātnieks, tas ir baits 0, 1, 2, 3, 31. Tātad jums ir 0 līdz 31, ja sākat skaitīšanas 0. 

Tātad, ja mēs izmantot programmu ka zvani get virkne, un mēs iegūstam virkni no cilvēka piemēram, I did sauc Zamyla, Z-A-M-Y-L-A, cik pasaulē dara dators izsekot, kuras baitu, kas rieciens atmiņas, pieder kurā virkne? Citiem vārdiem sakot, ja mēs turpinām ierakstiet citu nosaukumu datorā, patīk šī Andi, aicinot saņemt string otrreiz, A-N-D-I ir līdz nonāk Datora atmiņa, kā arī. Bet kā? 

Nu, izrādās, ka zem sadaļas nosūcējs, ko C dara uzglabājot stīgas ka cilvēka veidiem, vai ka nāk no kāda cita avota, tas ir attēlo galu no tām ar īpašs character-- reversā slīpsvītra 0, kas ir tikai īpašs veids no sakot 80 biti pēc kārtas. 

Tāpēc izveidojuši lielisku tas ir skaitlis 97 atsaukšana. Tāpēc daži modelis 8 biti apzīmē Decimālskaitli 97. Tas slīpsvītru 0 ir burtiski skaits 0, pazīstams arī kā Nul, N-U-L, atšķirībā no agrāk, N-U-L-L, kurā mēs runājām. Bet tagad, tikai zinu, ka tas slīpsvītru 0 ir tikai 80 bitu pēc kārtas. 

Un tas ir tikai šī līnija smilts, kas saka kaut ko pa kreisi pieder vienam auklas, vai vienu datu tipu. Un kaut kas pa labi pieder kaut ko citu. Andi vārds, tikmēr, kas tikai vizuāli notiek ar wrap uz otras līnijas, bet tas ir tikai estētiska detaļa, tāpat tiek Nul izbeigta. 

Tas ir string of a A-N-D-I burtiem, plus piektais noslēpums raksturs, visas 0 biti, kas vienkārši norobežo beigām Andi vārda, kā arī. Un, ja mēs saucam saņemt string trešo reizi ar datoru, lai iegūtu virkni, piemēram, Maria M-A-R-I-A, kas līdzīgi Maria s vārds Nul izbeigts ar slīpsvītru 0. 

Tas ir būtiski atšķiras no kā dators būtu tipiski uzglabāt ir vesels skaitlis, vai iegremdēšanu, vai cits datu tipi joprojām, jo ​​atsaukšanu, vesels skaitlis, kas parasti ir 32 biti, vai 4 baiti, vai varbūt pat 64 biti, vai astoņi baiti. Bet daudzi primitīvi ar datoru kādā programmēšanas valodā ir noteiktu skaitu baiti zem hood-- varbūt 1, varbūt 2, varbūt 4, varbūt 8. 

Bet stīgas, dizains, ir dinamiskā rakstzīmju skaits. Jūs nezināt jau iepriekš, līdz cilvēka veidi Z-A-M-Y-L-A, vai M-A-R-I-A, vai A-N-D-I. Jūs nezināt cik reizes lietotājs gatavojas hit tastatūra. Tāpēc, jūs nezināt, kā daudz rakstzīmes iepriekš Jums būs nepieciešama. 

Un tā C tikko veida atstāj Like noslēpums atpakaļceļa zem pārsega beigās virkni. Pēc tam, kad uzglabāšanas Z-A-M-Y-L-A atmiņā, tas arī tikai liek ekvivalentu ilgu laika posmu. Beigās teikuma, tas liek 80 bitiem, lai atcerēties, kur Zamyla sākas un beidzas. 

Tātad, kas ir savienojums, Pēc tam, lai šo programmu? Šī programma šeit, Stirling, ir vienkārši mehānisms lai iegūtu virkni no lietotāja, līnija 6. 7. līnija, es apliecinu mainīgo dēvētais N un noteikt to vienāds ar 0. 

Un tad 8. līniju, es vienkārši lūdza jautājums, bet n-th raksturs dara nav vienāds visiem 0 bits-- citiem vārdiem sakot, tas nav vienāds šis īpašais raksturs, slīpsvītru 0, kas bija tikai, ka īpaša Nul character-- iet uz priekšu un tikai pieauguma n. 

Un saglabāt to dara, un saglabāt to dara, un saglabāt to dara. Un tā kaut arī pagātne, mēs esam izmanto i, tas ir pilnīgi naudas sodu semantiski izmantot n, ja jūs vienkārši mēģināt rēķināties šoreiz apzināti, un vienkārši vēlaties, lai izsauktu to n. Tātad tas tikai tur, uzdodot jautājumu, ir n-tais raksturs viss 0s? Ja nē, skatīties uz nākamo izskatu, skatīties uz nākamo, skatīties uz nākamo, skatīties uz nākamo. 

Bet, tiklīdz jūs redzēt slīpsvītru 0, Tas loop-- line 9 līdz 11-- apstājas. Jūs izcelties no kamēr cilpa, atstājot iekšpusē šī mainīgā n kopējais skaits no visa rakstzīmes jūs redzēja virknes, tādējādi drukājot to ārā. Tātad, pieņemsim mēģināt šo. 

Ļaujiet man iet uz priekšu un, bez izmantojot Stirling funkciju, bet tikai izmantojot savu pašražoto versiju šeit sauc Stirling, ļaujiet man iet uz priekšu un palaist Stirling, ierakstiet kaut ko piemēram Zamyla, ko es zinu iepriekš ir sešas rakstzīmes. Let 's redzēt, ja tā darbojas. Patiešām, tas ir seši. Pamēģināsim ar Rob, trīs rakstzīmes, trīs rakstzīmes, kā arī, un tā tālāk. Tātad tas ir viss, kas notiek uz zem motora pārsega. Un paziņojums savienojumus, pēc tam, ar pirmajā nedēļā klases, kur mēs runājām par kaut kā abstrakcijas, kas ir tikai šis noslāņojums idejas, vai sarežģītība, virsū pamatprincipiem. Lūk, mēs esam sava veida meklē zem pārsega Stirling, tā teikt, izdomāt, kā tā īstenos? 

Un mēs varētu vēlreiz īstenot sevi. Bet mēs nekad atkal dodas atkārtoti ieviest Stērlingas. Mēs esam tikai gatavojas izmantot Stērlingas secībā lai faktiski saņemtu kādu virknes garumu. 

Bet tur nav burvju zem motora pārsega. Ja jūs zināt, ka zem kapuci, stīgu ir tikai rakstzīmju secība. Un ka rakstzīmju secība visu var skaitliski risināt ar kronšteinu 0, kronšteinu 1, kronšteins 2, un tu zinu, ka beigās string ir īpašo raksturu, jūs varat izdomāt kā to izdarīt visvairāk neko tādā programma, jo visi tā vārīties uz leju, lai ir lasīšanas un rakstīšanas atmiņa. Tas ir, mainās un meklē pie atmiņas, vai pārvietojas lietas ap atmiņā, drukas lietas uz ekrāna, un tā tālāk. 

Tātad, pieņemsim, tagad izmantot šo jaunatklāto izpratne par to, kas patiesībā stīgas ir zem motora pārsega, un Noplēsiet vienu citu slāni ka līdz šim mēs esam tika ignorējot vispār. Jo īpaši, jebkurā laikā mēs esam ieviesuši programmu, mēs esam bija šo rindiņu kodu augšdaļā deklarējot galvenais. Un mēs esam norādīts int galvenais tukšumu. 

Un tas nav spēkā iekšpusē iekavās ir teicis visu šo laiku, ka galvenais pati neveic nekādus argumentus. Jebkurš ieguldījums, ka galvenais ir notiek, lai saņemtu no lietotāja ir jānāk no kāda cita mehānisms, tāpat get int, vai saņemt peldēt, vai arī saņemt virkni, vai kādu citu funkciju. Bet izrādās, ka kad jūs uzrakstīt programmu, jūs faktiski var norādīt ka šī programma veic veikt ieguldījumus no cilvēka tajā pašā komandrindas. 

Citiem vārdiem sakot, pat ja mēs līdz šim ir vadījusi tikai ./hello sveiki vai līdzīgas programmas, visi no citas programmas, kas mēs esam, izmantojot, ka mēs paši nav rakstīt, ir lietojis, šķiet, komandrindas arguments-- lietas, piemēram, marka. Jūs sakāt, kaut ko līdzīgu marku, un pēc tam otrais vārds. Vai šķindēt, jūs sakāt šķindēt, un pēc tam otrais vārds, nosaukums failu. 

Vai pat RM vai CP, kā jūs varētu ir redzējuši vai izmantot jau lai novērstu vai kopēt failus. Visi no tiem, veikt tā saukto komandrindas arguments-- papildu vārdi pie termināla ātri. Bet līdz šim, mēs paši nav bijis šī luksusa ņemt ieguldījumu no lietotāju, kad viņš vai viņa tiešām iet pati programma pie komandrindas. 

Bet mēs varam darīt, ka, atkārtoti paziņojot, Galvenais virzās uz priekšu, nevis kā ar neesošu iekavās, bet šie divi argumenti instead-- pirmo veselam skaitlim, un otrs kaut kas jauns, kaut kas, ka mēs ejam, lai izsauktu masīvs, kaut kas līdzīgs garā to, ko mēs redzējām Scratch kā sarakstu, bet masīvs stīgas, kā mēs drīz redzēt. Bet pieņemsim redzēt šo, Piemēram, pirms mēs atšķirt tieši to, ko tas nozīmē. 

Tātad, ja es iedziļināties CS50 IDE šeit, es esmu gājusi uz priekšu un paziņoja failā ar nosaukumu argv0.c šādu veidni. Un paziņojums vienīgā lieta tas ir atšķirīgs tik tālu ir tas, ka es esmu mainījies par spēkā neesošu, int argc string argv atvērta kronšteinu, close kronšteins. Un paziņojums tagad, tur ir nekas iekšpusē šiem iekavās. 

Nav numuru. Un tur nav i, vai n, vai jebkuru citu burtu. Es esmu tikai izmantojot kvadrātiekavas tagad, iemeslu dēļ, mēs būsim atpakaļ tikai brīdi. 

Un tagad to, ko es esmu gatavojas darīt, ir šis. Ja argc vienāds vienāds 2-- un atgādina, ka vienāds vienāds ir vienlīdzība operators salīdzinot pa kreisi un pa labi uz vienlīdzību. Tas nav uzdevums operators, kas ir vienotais vienādības zīmi, kas nozīmē, kopiju no labās uz kreiso pusi kādu vērtību. 

Ja argc vienāds vienāds 2, es gribu teiksim, printf, hello, procenti, jauna līnija, un pēc tam pievienojiet in-- un šeit ir jauns trick-- argv kronšteins 1, tādu iemeslu dēļ, ka mēs būsim atpakaļ uz brīdi. Cits, ja argc nav vienāds 2, jūs zināt, ko? Pieņemsim tikai iet uz priekšu un, kā parasti, drukāt out hello world bez aizstāšanas. 

Tāpēc šķiet, ka, ja argc, kas stendi arguments skaits, ir vienāds ar 2, Es esmu gatavojas izdrukāt sveiki kaut vai otru. Pretējā gadījumā, pēc noklusējuma, es esmu nodots drukāšanai sveiki pasauli. Tātad, ko tas nozīmē? 

Nu, ļaujiet man iet uz priekšu un saglabājiet šo failu, un pēc tam to dara argv0, un tad ./argv0, Enter. Un tā saka sveiki pasaule. Tagad, kāpēc tā? 

Nu, izrādās, jebkurā laikā palaist programmu pie komandrindas, jūs aizpildīt, ko mēs parasti sauc argumentu vektors. Citiem vārdiem sakot, automātiski dators, operētājsistēma, gatavojas nodot ar savu programmu pats saraksts visiem vārdiem ka cilvēka ievadījis pie ātru, ja jūs programmētājs vēlas darīt kaut kas ar šo informāciju. Un šajā gadījumā, ir vienīgais vārds Esmu drukāti pie uzvednē ir ./argv0. 

Un to skaits argumentus, kas ir tiek nodota mana programma ir tikai viens. Citiem vārdiem sakot, arguments skaits, citādi zināma kā argc šeit kā vesels skaitlis, ir tikai viens. Viens, protams, nav vienāds divi. Un tā tas ir tas, kas drukā, hello pasauli. 

Bet ļaujiet man izmantot šo kaut kur. Ļaujiet man teikt, argv0. Un tad kā par Maria? Un pēc tam hit Enter. 

Un paziņojums, kas maģiski notiek šeit. Tagad, nevis Hello World, man ir mainīja uzvedību šīs programmas ņemot ievades nevis no get string vai kādu citu funkciju, bet no, acīmredzot, mana komanda pati, ko es sākotnēji drukāti. Un es varu spēlēt šo spēli atkal mainot to Stelios, piemēram. 

Un tagad es redzu citu nosaukumu joprojām. Un šeit, es varētu teikt Andi. Un es varētu teikt Zamyla. Un mēs varam spēlēt šo spēli visas dienas garumā, vienkārši tapām dažādām vērtībām, tik ilgi, kamēr es sniegt tieši divi vārdi pie ātru, tā, ka argc, mans arguments skaits ir 2. 

Es redzu, ka vārds iesprausts printf, par šī nosacījuma šeit? Tāpēc mēs, šķiet, esam tagad ekspresīvā spējas ņemt datus no citu mehānismu, no tā sauktās komandrindas, nevis jāgaida līdz lietotājs palaiž programmu, un tad ātri viņu izmantojot kaut ko līdzīgu get virkni. 

Tātad, kas tas ir? Argc, atkal, ir tikai skaitlis, skaits words-- arguments-- ka lietotājs ar nosacījumu, pie ātra, pie termināla logā, tai skaitā programmas nosaukumu. Tātad mūsu ./argv0 ir, faktiski, ka programmas nosaukums, vai kā es palaist programmu. 

Tas skaitās kā vārdu. Tātad argc būtu 1. Bet, kad es rakstīt Stelios, vai Andi, vai Zamyla vai Maria, tas nozīmē, ka arguments skaits ir divi. Un tāpēc tagad tur ir divi pagāja vārdos. 

Un paziņojums, mēs varam turpināt šo loģiku. Ja es tiešām saku kaut kas līdzīgs Zamyla Chan, pilns vārds, tādējādi iet trīs argumentus kopā, tagad tā saka noklusējuma atkal, jo, protams, 3. nav vienāds 2. 

Un tā šādā veidā, man ir Pieeja caur argv šis jaunais arguments ka mēs varētu tehniski zvaniet kaut mēs gribam. Bet pēc vienošanās, tas ir argv un argc, attiecīgi. Argv, arguments vektors, ir sava veida par sinonīmu programmēšanas iezīme C sauc masīvs. 

Masīvs ir saraksts ar līdzīgām vērtībām atpakaļ, atpakaļ, atpakaļ, uz muguras. Citiem vārdiem sakot, ja viens ir tepat RAM, nākamais ir tieši blakus tai, un blakus tai. Viņi ne visā vietā. Un ka pēdējais scenārijs, kur lietas ir visas vietas atmiņā, patiesībā var būt spēcīgs līdzeklis. Bet mēs atgriezties, ka, ja mēs runāt par mīļotājs datu struktūras. Tagad, masīvs ir tikai rieciens blakusesošo atmiņas, Katrā no kura elementi ir atpakaļ, atpakaļ, atpakaļ, atpakaļ, un parasti tā paša tipa. 

Tātad, ja jūs domājat par, no A Pirms brīža, kas ir string? Nu, string, piemēram Zamyla, Z-A-M-Y-L-A, ir, tehniski, tikai masīvs. Tas ir masīvs rakstzīmes. 

Un tāpēc, ja mēs patiešām izdarīt to, kā es darīja agrāk, kā rieciens atmiņas, izrādās, ka katrs no šiem rakstzīmes aizņem baitu. Un tad tur ir kas īpašs Sentinel raksturs, tad reversā slīpsvītra 0, vai visi astoņi 0 biti, ka norobežo uz pabeigtu virkni. Tātad virkne, izrādās ārā, citējot likt pēdiņas beigās virkni, ir tikai masīvs chara-- char ir faktisko datu tips. 

Un tagad argv, meanwhile-- iesim atpakaļ uz programmu. Argv, kaut gan mēs redzam vārdu string šeit, nav pati virkne. Argv, arguments vektors, ir masīvs stīgas. 

Tik vienkārši, kā jūs varat būt masīvs rakstzīmes, jums var būt augstāks, masīvs strings-- tā, piemēram, kad es drukāti pirms brīža ./argv0 argv0, telpa Z-A-M-Y-L-A, es norādīja, ka argv bija divas stīgas it-- ./argv0, un Z-A-M-Y-L-A. uz citiem vārdiem sakot, argc bija 2. Kāpēc ir tā, ka? 

Nu, faktiski, kas notiek par ir tas, ka katrs no šiem virknes ir, protams, masīvs rakstzīmju Tāpat kā iepriekš, katrs no kuras varoņi aizņem vienu baitu. Un nejauciet faktisko 0 Programmā vārda ar 0, kas nozīmē visus 80 bitus. Un Zamyla, tikmēr, joprojām arī masīvs rakstzīmes. 

Tātad beigās, dienā, tas patiešām izskatās šādi zem motora pārsega. Bet argv, pēc būtības, kā galvenā darbi, ļauj man wrap viss augšup, ja jūs, lielākā masīvs ka, ja mēs nedaudz vairāk vienkāršot kāda bilde izskatās un nav diezgan izdarīt tā, lai palielinātu tur, šis masīvs ir tikai no 2. izmēra, pirmais elements, kas satur virkni, No Otrais elements kas satur virkni. Un, savukārt, ja jums veida tuvinātu par katru Šo stīgas, ko jūs redzēt zem motora pārsega ir tas, ka katrs virkne ir tikai masīvs rakstzīmes. 

Tagad, tāpat kā ar stīgām, mums bija iespēja piekļūt uz i-rakstura string izmantojot šo kvadrātiekava notācija. Līdzīgi, ar masīviem vispār, mēs varam izmantot kvadrātiekavas notācija iegūt jebkurā skaitu virknes masīvā? Piemēram, ļaujiet man iet uz priekšu un darīt to. 

Ļaujiet man iet uz priekšu un izveidot argv1.c, kas ir nedaudz atšķirīgs šoreiz. Tā vietā, pārbaudot argc2, Es esmu gatavojas vietā izdarīt. Par int man 0, es mazāk nekā argc, es plus plus, un pēc tam izdrukāt iekšpusē šo, procenti s, jauns līnija, un pēc tam argv kronšteins i. 

Tātad citiem vārdiem sakot, es neesmu nodarbojas ar atsevišķas rakstzīmes brīdī. Argv, kā tas ir ar šo tukšo kvadrātu bikšturi pa labi no vārda argv, nozīmē argv ir masīvs stīgas. Un argc ir tikai int. 

Šī līnija šeit, 6, ir sakot kopumu i vienāds ar 0. Count visu ceļu līdz, neieskaitot, argc. Un tad uz katra atkārtojuma, izdrukāt virkni. Kas string? 

I-th string in argv. Tātad, tā kā pirms es biju izmantojot kvadrātveida skavu notācija saņemt pie i- raksturs string, tagad Es esmu, izmantojot kvadrātiekava notācija nokļūt pie i-virknes masīvā. Tātad, tas ir sava veida viena slāņa iepriekš, konceptuāli. 

Un tā, kas ir veikls par šo Programma tagad, ja es apkopot argv1, un pēc tam darīt ./argv1, un pēc tam ierakstiet kaut ko līdzīgu foo bar Baz, kas ir trīs noklusējuma vārdi, kas a datorzinātnieks pasniedzas jebkurā laikā viņam vai viņai ir vajadzīgs kāds vietturu vārdus, un hit Enter, katrs no šiem vārdiem, tai skaitā programmas nosaukumu, kas ir argv pirmajā vietā, beidzas ar to drukā pa vienam. Un, ja es mainītu, un es saku kaut kā argv1 Zamyla Chan, mēs visi trīs no tiem vārdi, kas ir argv0, argv1, argv2, jo šajā case argc, grāfs, ir 3. 

Bet kas ir veikls ir, ja jūs saprotat ka argv ir tikai masīvs stīgas, un jūs saprotat, ka virkne ir masīvs rakstzīmes, mēs patiesībā varam veida izmantot šo kvadrātiekava pieraksta vairākas reizes izvēlēties virkni, un pēc tam izvēlieties raksturs ietvaros virknes, niršana dziļāk šādi. Šajā piemērā, ļaujiet man iet priekšu un nosaukt šo argv2.c. Un šajā piemērā, ļaujiet man iet uz priekšu un darīt following-- par int man 0, i ir mazāks nekā argc, es plus plus, tāpat kā līdz šim. Tātad citiem words-- un tagad šis kļūst pietiekami sarežģīta. Tad es esmu gatavojas teikt atkārtot pār stīgas argv, kā komentārs sevi. Un tad es esmu nāksies Nested cilpas, kas jums, iespējams, ir darīts, vai uzskatīt darot, jo nulles, kur Es esmu gatavojas teikt int-- es esmu nav gatavojas izmantot i atkal, jo es nevēlos, lai ēnu, vai veida pārrakstīt esošo i. 

Es esmu gatavojas, nevis, teiksim j, jo tas ir mans iet uz mainīgo pēc i, kad es esmu tikai mēģina skaitīt vienkāršus numurus. Par j izpaužas 0-- un arī, n, gatavojas saņemt pakaļgala garums argv kronšteinu i, tik ilgi, kamēr j ir mazāks nekā m, j plus plus, rīkojieties šādi. Un šeit ir interesanti daļa. 

Izdrukāt raksturu un jaunu līniju, tapām argv grupā i, kronšteinu j. Labi, tāpēc ļaujiet man piebilst dažus komentārus šeit. Atkārtot pār rakstzīmes pašreizējā virknes, print j-th raksturs i-string. Tāpēc tagad, pieņemsim apsvērt Ko šie komentāri nozīmē. 

Atkārtot pār stīgām in argv-- cik stīgas ir argv, kas ir masīvs? Argc daudz, tāpēc es esmu atkārtojot no i vienāds 0 līdz argc. Tikmēr, cik rakstzīmes ir i-virknes argv? 

Nu, lai iegūtu, ka atbildi, Es tikai aicinu virknes garumu uz pašreizējo stīgu I aprūpei par, kas ir argv kronšteins i. Un es esmu gatavojas uz laiku uzglabāt ka vērtība n, tikai caching nolūkos, atcerēties to efektivitāti. Un tad es esmu gatavojas sāktu J līdz 0, glabāt iet tik ilgi, kamēr j ir mazāks nekā n, un par katru atkārtojuma pieauguma j. 

Un tad šeit, per mans komentārs uz līnijas 12, izdrukāt raksturs, kam seko jaunu līniju, īpaši argv kronšteins i dod man i-string in argv-- Tātad pirmais vārdu, otrais vārds, trešais vārds, neatkarīgi. Un tad j niršanas dziļāk, un izpaužas me j-tais raksturs šo vārdu. Un tā, faktiski, jūs var ārstēt argv kā daudzdimensiju, kā divdimensiju, masīvs, kuru katrs vārds veida izskatās piemēram, tas savā prātā s acs, un katrs raksturs ir sava veida veidots kolonnu, ja tas palīdz. 

Patiesībā, kad mēs ķircināt Neraugoties uz nākotnē nedēļās, tas būs nedaudz sarežģītākas nekā. Bet jūs tiešām var domāju, ka tagad, jo tikai šo divdimensiju masīvs, ar ko viena līmenis no tā ir visas stīgas. Un tad, ja jūs nirt dziļāk, jums var saņemt pie atsevišķām rakstzīmēm tajā precizē, izmantojot šo apzīmējumu šeit. 

Tātad, kas ir neto efekts? Ļaujiet man iet uz priekšu un padarīt argv2-- darn to. Es kļūdījies šeit. Netieši pasludina bibliotēkas funkciju Stirling. Tāpēc visu šo laiku, tas ir varbūt vajadzīgs ka mēs esam veida apdares kur tieši mēs sākām. 

Es ieskrūvē up, netieši atzīstot bibliotēkas funkciju Stirling. Labi, pagaidiet minūti. Es atceros, ka, jo īpaši jo tas ir tepat. Man nepieciešams iekļaut string.h in Šī programmas versija. 

Ļaujiet man iet uz priekšu un ietver string.h, izņemot to, ka, iet uz priekšu un recompile argv2. Un tagad, šeit mēs iet, darīt argv2, Enter. Un, lai gan tas ir nedaudz mistisks pēc pirmā acu uzmetiena, paziņojums, ka, patiešām, ko tiek drukāts ir dot argv2. 

Bet, ja es rakstīt dažus vārdus pēc ātru, tāpat argv2 Zamyla Chan, Enter, arī nedaudz mistisks pēc pirmā acu uzmetiena. Bet, ja mēs ritiniet atpakaļ uz augšu, ./argv2 Z-A-M-Y-L-A C-H-A-N. Tāpēc mēs esam atkārtoja pār katru vārdu. Un, savukārt, mēs esam atkārtoja pāri katrs raksturs ietvaros vārdu. 

Tagad, kad tas viss, saprast, ka tur ir viena cita detaļa mēs esam bijuši veida ignorējot visu šo laiku. Mēs vienkārši kaitināja izņemot to, kas Galvenais ir ieejas var būt? Kas par galvenais darba rezultāts? 

Visu šo laiku, mēs esam bijuši vienkārši kopējot un ielīmējot vārds int priekšā galvenais, lai gan jūs varat redzēt online, dažreiz nepareizi vecākās versijās C un kompilatori, ka viņi saka par spēkā neesošu, vai neko. Bet, protams, lai versija C, ka mēs izmantojam, C 11, vai 2011. gada, realizēt ka tā būtu int. Un tas būtu vai nu spēkā neesošu vai argc un argv šeit. 

Bet kāpēc int galvenais? Kas tas ir faktiski atgriežas? Nu, izrādās, visu šo laiku, jebkurā laikā jūs esat uzrakstījis Programmas galvenās vienmēr atgriežas kaut ko. Bet tas ir bijis darīt slepeni. 

Ka kaut kas ir int, jo līnija 5 liecina. Bet ko int? Nu, tur ir šis konvencija plānošanā, saskaņā ar kuru, ja nekas nav aizgājuši nepareizi, un viss ir labi, programmas un funkcijas parasti return-- nedaudz counterintuitively-- 0. 0 parasti nozīmē viss ir labi. Tātad, pat ja jūs domājat par tā kā viltus daudzos kontekstos, tas patiesībā parasti nozīmē laba lieta 

Tikmēr, ja programma atgriež 1, vai negatīvs 1, vai 5, vai negatīvs 42, vai nav 0 vērtība, kas parasti nozīmē ka kaut kas ir nogājis greizi. Patiesībā, par savu Mac vai PC, Jums varētu būt tiešām redzējis kļūdas ziņojums, ar kuru tā saka kaut vai otru, kļūda kods negatīvs 42, vai kļūdas kods 23, vai kaut kas tamlīdzīgs. Šis skaits ir parasti tikai mājiens programmētājs, vai uzņēmuma kas padarīja programmatūru, kas nogāja greizi un kāpēc, lai viņi varētu skatīties cauri viņu dokumentācija vai kods, un izdomāt ko kļūda patiesībā nozīmē. Tas parasti nav noderīga, lai mums galalietotājiem. 

Bet, kad galvenie atgriež 0, viss ir labi. Un, ja jums nav jānorāda ko galvenokārt vajadzētu atgriezties, tas būs tikai automātiski atgriezties 0 jums. Bet atgriežoties kaut cits ir faktiski noderīga. 

Šajā pēdējā programmā, ļaujiet man iet uz priekšu un nosaukt šo exit.c, un ieviest pēdējā no šodienas tēmas, kas pazīstams kā kļūdas kodu. Ļaujiet man iet uz priekšu un ietver mūsu pazīstami failus līdz top, darīt int galvenais. Un šoreiz, pieņemsim do int argc, stīgu argv, un ar manu iekavās nozīmēt, ka tas ir masīvā. Un tad ļaujiet man tikai do veselība pārbaudītu. Šoreiz ja argc nav vienāds 2, tad jūs zināt, ko? Aizmirsti. Es esmu gatavojas teikt, ka, hey, lietotājs, jums trūkst komandrindas argumentu reversā slīpsvītra n. 

Un tad tas arī viss. Es gribu, lai izietu. Es dodos uz preemptively, un priekšlaicīgi tiešām, atgriešanās kaut kas cits nekā skaits 1. Go to vērtību par pirmo kļūda, kas var notikt, ir 1. Ja jums ir daži citi kļūdains situācija, kas varētu notikt, jūs varētu teikt atdevi 2 vai atgriezt 3, vai varbūt pat negatīvs 1 vai negatīvs 2. 

Šie ir tikai izejas kodi kas ir, parasti, tikai noderīga programmētājs, vai uzņēmums, kas ir kuģniecības programmatūru. Bet fakts, ka tā ir ne 0 ir tas, kas ir svarīgi. Tātad, ja šajā programmā, es gribu garantēt, ka šī programma tikai darbojas, ja lietotājs sniedz man ar argumentu skaits ir divi, nosaukums programmas, un dažas citas vārds, es varu izpildīt tik daudz, cik šāds, bļaut pie lietotājs ar printf sakot, pazudis komandrindas argumentu, atgriešanās 1. Tas būs tikai uzreiz atmest programmu. 

Tikai tad, ja argc vienāds 2 mēs nokāpt šeit, kurā brīdī es esmu gatavojas teikt, sveiki procenti s, slīpsvītru n, argv1. Citiem vārdiem sakot, es esmu nenāks pēc argv 0, kas ir tikai programmas nosaukums. Es gribu izdrukāt hello, komats, otrais vārds, ka cilvēka ievadījis. Un šajā gadījumā uz līnija 13, viss ir labi. 

Es zinu, ka argc ir 2 loģiski no šīs programmas. Es iešu uz priekšu un atpakaļ 0. Kā malā, paturiet prātā, ka šis apgalvojums ir patiess Scratch, kā arī. 

Loģiski, es varētu darīt un rezumēju šīs līnijas koda šajā cits klauzulu šeit. Bet tas ir sava veida nevajadzīgi indenting manu kodu. Un es gribu, lai super skaidrs, ka nav svarīgi, ko, pēc noklusējuma, sveiki kaut kas saņems drukāts, tik ilgi, kamēr lietotājs sadarbojas. 

Tātad, tas ir ļoti bieži, lai izmantotu nosacījums, tikai tad, noķert kādu kļūdaina situāciju, un tad izeja. Un pēc tam, tik ilgi visi ir labi, nav ir cits, bet vienkārši ir kodu ārpuses, ka, ja, jo tas ir ekvivalents šajā īpaši gadījumā, loģiski. Tāpēc es esmu atpakaļ 0, tikai skaidri neizsaka viss ir labi. 

Ja es izlaist atgriešanos 0, tas būtu automātiski pieņemts par mani. Bet tagad, ka es esmu atpakaļ viens vismaz šajā gadījumā, Es esmu gatavojas, labu pasākumu un skaidrība, atgriešanās 0 šajā gadījumā. Tāpēc tagad ļaujiet man iet uz priekšu un veikt izeju, kas ir ideāls segue vienkārši atstāt. 

Bet, pārliecinieties, izeju, un ļaujiet man iet priekšu un darīt ./exit, Enter. Un programma kliedza uz mani, pazudis komandrindas argumentu. Labi, ļaujiet man sadarboties. 

Ļaujiet man nevis darīt ./exit, David, Enter. Un tagad tā saka, hello Deivids. Un jūs parasti nav redzēt šo. 

Bet izrādās, ka tur ir īpašs veids Linux faktiski redzēt ar ko izejas kods programma iziet. Dažreiz grafiskā pasauli, Mac OS vai Windows, jūs tikai redzēt šos numurus, kad kļūdas ziņojums NOP augšu uz ekrāna un programmētājs parāda šo numuru. Bet, ja mēs gribam, lai redzētu, kas kļūda vēstījums ir, mēs varam darīt to here-- tik ./exit, Enter, print pazudis komandrindas argumentu. 

Ja es tagad darīt echo $ ?, kas ir smieklīgi mistisks meklē. Bet $? ir burvju buršana kas saka, hey, dators, pasakiet man, kāda iepriekšējā Programmas izejas kods bija. Un es hit Enter. Es redzu 1, jo tas, ko es teica mana galvenā funkcija atgriezties. 

Tikmēr, ja man ./exit Dāvidu, un hit Enter, es redzu, Hello Dāvidu. Un, ja es tagad darīt echo $ ?, es redzu sveiki 0. Un tā tas patiešām būt vērtīgu informāciju kontekstā atkļūdotājs, ne tik daudz, ka jūs, cilvēku, būtu vienalga. Bet atkļūdotājs un citi programmas, mēs izmantosim šo semestri bieži apskatīt šo numuru, pat ja tas ir sava veida Paslēpusies ja jūs meklēt to, lai noteiktu, vai nav programma s izpilde bija pareizi vai nepareizi. 

Un tā, kas dod mums šis, beigās, dienā. Mēs šodien uzsāka aplūkojot atkļūdošana, un, savukārt, pie kursa sevi, un tad vēl interesanti, tehniski zem motora pārsega par to, kas stīgas ir, kas ilgst Šonedēļ mēs vienkārši ņēma par pašsaprotamu, un, protams, ņēma tos par piešķirts nulles. 

Mēs pēc tam paskatījās kā mēs varam piekļūt atsevišķas rakstzīmes virkni, un tad atkal ieņēma augstāku apskatīt lietas, aplūkojot, kā well-- ja mēs gribam nokļūt pie individuālo elementi sarakstā līdzīgu struktūru, mēs nevaram darīt, ka ar vairākiem stīgas? Un mēs varam ar komandrindas argumentus. Bet šī aina šeit ir tikai kastes ir uzskatāms par šo vispārējo ideju no masīva, vai saraksta, vai vektors. Un atkarībā no konteksts, visus šos vārdus nozīmēt nedaudz atšķirīgas lietas. Tātad C, mēs esam tikai gatavojas runāt par masīvu. Un masīvs ir rieciens atmiņas, no kuriem katrs ir elementi ir blakusesoši, atpakaļ, atpakaļ, atpakaļ, uz muguras. 

Un šie elementi ir, parasti, no tā paša datu tips, raksturs, raksturs, raksturs, raksturs, vai stīgu, stīgu, stīgu, stīgu, vai int, int, int, kāds tas ir mēs cenšamies veikalā. Bet beigās, dienā, tas ir kā tas izskatās konceptuāli. Jūs lietojat savu datora atmiņā vai RAM. Un jūs atkāpes to ārā identiski izmēra kastes, kas visi ir atpakaļ, atpakaļ, uz atpakaļ, atpakaļ šādā veidā. 

Un, kas ir jauka par Šī ideja, un tas, ka mēs varam izteikt vērtības šādā veidā ar pirmo mūsu datu struktūras klasē, nozīmē, ka mēs varam sākt lai risinātu problēmas ar kodu kas nāca tik intuitīvi in ​​nedēļā 0. Jums atgādināt tālruni grāmatas piemērs, kur mēs izmantojām plaisu un iekarot, vai bināro meklēšanas algoritmu, izsijāt caur kopumā ķekars vārdus un numurus. Bet mēs pieņēmām, atgādināt, ka tālruņu grāmata jau bija sakārtoti, ka kāds cits bija jau sapratu out-- dots nosaukumu sarakstu un numbers-- kā alphabetize tos. Un tagad, ka C mēs, Arī, ir iespēja nolikt lietas, ne fiziski tālruņa grāmatu bet praktiski datora atmiņas, mēs varēsim nākamnedēļ ieviest atkal this-- pirmais Mūsu datu struktūru ar array-- bet vēl svarīgāk, faktisko dators zinātne algoritmi īstenoti ar kodu, ar kuru mēs varam glabāt dati struktūrās, piemēram, tas, un tad sāk manipulēt ar to, un faktiski atrisināt problēmas ar to, un, lai izveidotu uz augšu, ka, galu galā, programmas C, Python, JavaScript, vaicājumiem datu bāzes ar SQL? 

Un mēs redzam, ka visi šie dažādas idejas savienojas. Bet tagad, atgādināt, ka domēns, ka mēs šodien iepazīstināja bija šī lieta šeit, un pasaule kriptogrāfiju. Un starp nākamajām problēmām tu pats atrisinās ir māksla kriptogrāfijas, šifrēšanas un de-kodēšanas informācija, un šifrēšana un atšifrējums tekstu, un pieņemot, ka galu galā ka jūs tagad zināt, ko ir zem motora pārsega lai tad, kad jūs redzēt vai saņemt ziņa kā šis, jums pats var atšifrēt to. Tas viss, un vēl nākamo reizi. 

[VIDEO PLAYBACK] 

-Mover Tikko ieradušies. Es iešu vizītē viņa koledžas profesors. Yep. Sveiki. Tas esi tu. Pagaidiet! David. Es esmu tikai mēģina izdomāt , kas noticis ar jums. Lūdzu, kaut kas varētu palīdzēt. Jūs bijāt viņa koledža istabas biedrs, bija ne? Jūs bijāt tur ar viņu, kad viņš beidzis CS50 projektu? 

[SKAN MŪZIKA] 

-That Bija CS50. 

Es mīlu šo vietu. 

-Eat Up. Mēs ejam no uzņēmējdarbības. 

[END PLAYBACK] 