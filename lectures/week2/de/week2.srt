1
00:00:00,000 --> 00:00:02,970
>> [MUSIK SPIELEN]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN: Alles in Ordnung.

4
00:00:15,700 --> 00:00:18,832
Dies ist CS50 und dies
ist der Beginn der Woche 2.

5
00:00:18,832 --> 00:00:21,040
Und Sie werden sich erinnern, dass über
in den letzten paar Wochen,

6
00:00:21,040 --> 00:00:24,490
wir haben Computer Einführung
Wissenschaft und wiederum, Programmierung.

7
00:00:24,490 --> 00:00:27,640
>> Und wir begannen die Geschichte haft
Scratch, dass grafische Sprache

8
00:00:27,640 --> 00:00:28,990
vom MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
Und dann zuletzt,
letzte Woche, haben wir

10
00:00:30,780 --> 00:00:34,450
eine higher-- eine Einführung
niedrigerer Ebene Sprache bekannt

11
00:00:34,450 --> 00:00:36,770
wie C, etwas, das rein textuellen ist.

12
00:00:36,770 --> 00:00:39,440
Und in der Tat, wir das letzte Mal
in diesem Zusammenhang untersucht

13
00:00:39,440 --> 00:00:40,450
eine Reihe von Konzepten.

14
00:00:40,450 --> 00:00:43,010
>> Dies erinnere, war das sehr
erste Programm, das wir betrachtet.

15
00:00:43,010 --> 00:00:45,710
Und dieses Programm, ganz einfach,
druckt, "Hallo, Welt."

16
00:00:45,710 --> 00:00:47,730
Aber es gibt so viel
scheinbare Magie geht.

17
00:00:47,730 --> 00:00:51,460
Es ist das # include
mit diesen spitzen Klammern.

18
00:00:51,460 --> 00:00:52,170
Es gibt int.

19
00:00:52,170 --> 00:00:53,020
Es gibt (void).

20
00:00:53,020 --> 00:00:56,330
Es gibt Klammern, geschweiften Klammern,
Semikolons, und so vieles mehr.

21
00:00:56,330 --> 00:00:58,480
>> Und so, daran erinnern, dass
wir eingeführt Scratch

22
00:00:58,480 --> 00:01:02,110
so dass wir konnten, im Idealfall, siehe Vergangenheit
dass Syntax, die Sachen, die wirklich nicht

23
00:01:02,110 --> 00:01:04,590
alles, was intellektuell
interessant, aber schon früh

24
00:01:04,590 --> 00:01:07,700
ist, absolut, ein bisschen schwierig
wickeln Sie Ihren Geist herum.

25
00:01:07,700 --> 00:01:10,860
Und in der Tat, eine der am häufigsten
früh auf die Dinge in einer Programmiersprache Klasse,

26
00:01:10,860 --> 00:01:13,443
vor allem für diejenigen weniger
komfortabel, ist von zu frustriert

27
00:01:13,443 --> 00:01:17,460
und stolpern durch bestimmte syntaktische
Fehler, nicht als logische Fehler zu erwähnen.

28
00:01:17,460 --> 00:01:19,800
Und so unter unseren Zielen
heute, tatsächlich,

29
00:01:19,800 --> 00:01:23,280
Ihnen mit einigen ausstatten
Problemlösungstechniken, wie

30
00:01:23,280 --> 00:01:26,705
lösen sich Probleme besser
in Form von Debugging.

31
00:01:26,705 --> 00:01:29,330
Und Sie werden sich erinnern, auch, dass die
Umwelt, die wir eingeführt

32
00:01:29,330 --> 00:01:31,780
zuletzt wurde CS50 IDE genannt.

33
00:01:31,780 --> 00:01:34,850
Dies ist web-basierte Software, die
Damit können Sie in der Cloud zu programmieren,

34
00:01:34,850 --> 00:01:38,450
so zu sprechen, während zu halten alle Ihre
Dateien wieder zusammen, wie wir wollen heute.

35
00:01:38,450 --> 00:01:41,480
Und erinnern daran, dass wir
revisited hier diese Themen,

36
00:01:41,480 --> 00:01:44,480
darunter Funktionen und Schleifen, und
Variablen und Booleschen Ausdrücken,

37
00:01:44,480 --> 00:01:45,110
und Bedingungen.

38
00:01:45,110 --> 00:01:49,190
Und tatsächlich ein paar mehr, dass wir
aus der Welt der Scratch übersetzt

39
00:01:49,190 --> 00:01:50,800
in der Welt von C.

40
00:01:50,800 --> 00:01:53,220
>> Aber die grundlegende Gebäude
Blöcke, sozusagen

41
00:01:53,220 --> 00:01:55,150
waren wirklich immer noch die gleiche letzte Woche.

42
00:01:55,150 --> 00:01:57,900
In der Tat, wir hatten wirklich nur ein
verschiedene Puzzle-Stück, wenn man so will.

43
00:01:57,900 --> 00:02:00,300
Statt dieser lila
speichern Block, wir statt

44
00:02:00,300 --> 00:02:02,940
hatte printf, das ist
diese Funktion in C, dass

45
00:02:02,940 --> 00:02:05,890
ermöglicht es Ihnen, etwas zu drucken
und formatieren Sie es auf dem Bildschirm.

46
00:02:05,890 --> 00:02:07,950
Wir führten den CS50
Bibliothek, wo Sie

47
00:02:07,950 --> 00:02:11,420
jetzt zur Verfügung get_char haben,
und get_int und get_string,

48
00:02:11,420 --> 00:02:14,610
und einige andere Funktionen als
gut, über die Sie Eingabe erhalten

49
00:02:14,610 --> 00:02:16,260
aus der eigenen Tastatur des Benutzers.

50
00:02:16,260 --> 00:02:20,640
Und wir haben auch einen Blick auf die Dinge
wie these- bool und char,

51
00:02:20,640 --> 00:02:22,490
und Doppelzimmer, Schwimmer,
int, long_long String.

52
00:02:22,490 --> 00:02:25,170
Und es gibt auch andere Datentypen in C

53
00:02:25,170 --> 00:02:28,560
>> Mit anderen Worten, wenn Sie erklären,
eine Variable einen Wert zu speichern,

54
00:02:28,560 --> 00:02:32,600
oder wenn implementieren Sie eine Funktion
dass gibt einen gewissen Wert,

55
00:02:32,600 --> 00:02:35,290
Sie können angeben, was
Typ des Wertes, der ist.

56
00:02:35,290 --> 00:02:37,310
Ist es eine Zeichenfolge, wie ein
Folge von Zeichen?

57
00:02:37,310 --> 00:02:39,490
Ist es eine Zahl, wie eine ganze Zahl?

58
00:02:39,490 --> 00:02:41,390
Ist es ein Gleitkomma
Wert oder dergleichen?

59
00:02:41,390 --> 00:02:46,180
So in C, im Gegensatz zu Scratch, wir tatsächlich
begann zu spezifizieren, welche Art von Daten

60
00:02:46,180 --> 00:02:48,330
wir zurückkehrten oder verwenden.

61
00:02:48,330 --> 00:02:51,910
>> Aber natürlich, wir liefen auch in
einige grundlegende Grenzen der Informatik.

62
00:02:51,910 --> 00:02:54,100
Und insbesondere,
diese Sprache C, Rückruf

63
00:02:54,100 --> 00:02:57,070
dass wir haben einen Blick auf
Integer-Überlauf, die Realität

64
00:02:57,070 --> 00:03:00,460
dass, wenn Sie ein nur haben
finite Menge an Speicher,

65
00:03:00,460 --> 00:03:04,600
oder speziell eine endliche Zahl
von Bits, können Sie nur so hoch zu zählen.

66
00:03:04,600 --> 00:03:08,460
Und so sahen wir uns an diesem Beispiel hier
wobei ein Zähler in einem Flugzeug,

67
00:03:08,460 --> 00:03:13,510
wenn tatsächlich läuft, lang genug wäre
Überlauf und führen zu einer Software

68
00:03:13,510 --> 00:03:15,560
eine tatsächliche physische Potential Fehler.

69
00:03:15,560 --> 00:03:18,600
>> Wir haben uns auch bei Floating
Punkt Unschärfen, die Realität

70
00:03:18,600 --> 00:03:22,280
daß nur eine endliche Anzahl
von Bits, ob 32 oder 64 ist,

71
00:03:22,280 --> 00:03:27,330
Sie können nur so viele Zahlen angeben
nach einem Komma, nach dem Sie

72
00:03:27,330 --> 00:03:29,110
beginnen ungenau zu bekommen.

73
00:03:29,110 --> 00:03:32,360
So zum Beispiel, ein Drittel in der
Welt hier, in unserer menschlichen Welt,

74
00:03:32,360 --> 00:03:35,360
wir wissen, ist nur eine unendliche Zahl
von 3s nach dem Komma.

75
00:03:35,360 --> 00:03:38,820
Aber ein Computer kann nicht notwendigerweise
eine unendliche Anzahl von Zahlen darstellen

76
00:03:38,820 --> 00:03:42,590
wenn Sie erlauben es einige
finite Menge an Informationen.

77
00:03:42,590 --> 00:03:45,900
>> So haben wir nicht nur statten Sie
mit mehr Leistung in Bezug auf

78
00:03:45,900 --> 00:03:49,280
wie Sie könnten sich auszudrücken an
eine Tastatur in der Programmierung,

79
00:03:49,280 --> 00:03:51,430
wir auch Mindestmaß beschränkt
Sie können tatsächlich tun.

80
00:03:51,430 --> 00:03:55,790
Und in der Tat, Fehler und Irrtümer
ergeben sich aus dieser Art von Fragen.

81
00:03:55,790 --> 00:03:59,900
Und in der Tat zu den Themen heute
werden Themen wie das Debuggen zu sein

82
00:03:59,900 --> 00:04:03,699
und eigentlich auf der Suche unter der Haube
an, wie die Dinge eingeführt wurden letzte Woche

83
00:04:03,699 --> 00:04:05,490
tatsächlich umgesetzt werden
so dass Sie besser

84
00:04:05,490 --> 00:04:10,530
verstehen sowohl die Fähigkeiten und
die Grenzen einer Sprache wie C

85
00:04:10,530 --> 00:04:14,770
>> Und in der Tat, werden wir die Schichten schälen zurück
der einfachsten Datenstruktur,

86
00:04:14,770 --> 00:04:17,756
etwas, das ein Array genannt, die
Scratch geschieht eine zu nennen "Liste."

87
00:04:17,756 --> 00:04:19,589
Es ist ein bisschen
andere in diesem Zusammenhang.

88
00:04:19,589 --> 00:04:23,340
Und dann werden wir auch einer der Einführung
erste unserer domänenspezifische Probleme

89
00:04:23,340 --> 00:04:26,790
in CS50, die Welt der
Kryptographie, die Kunst der Scrambling

90
00:04:26,790 --> 00:04:29,650
oder in Chiffrierung Informationen so
dass Sie geheime Botschaften schicken

91
00:04:29,650 --> 00:04:34,520
und dekodieren geheime Botschaften
zwischen zwei Personen, A und B.

92
00:04:34,520 --> 00:04:37,490
>> Also, bevor wir Übergang
zu dieser neuen Welt,

93
00:04:37,490 --> 00:04:42,059
Lassen Sie uns versuchen, Sie mit einigen ausstatten
Techniken, mit denen Sie beseitigen

94
00:04:42,059 --> 00:04:43,850
oder reduzieren zumindest einige
der Frustrationen

95
00:04:43,850 --> 00:04:46,630
dass Sie wahrscheinlich begegnet
in der vergangenen Woche allein.

96
00:04:46,630 --> 00:04:50,830
In der Tat, vor Ihnen sind such-- einige
Ihre erste Probleme in C. Und die Chancen,

97
00:04:50,830 --> 00:04:54,010
wenn Sie wie ich sind, das erste Mal,
Sie versuchen, ein Programm zu tippen,

98
00:04:54,010 --> 00:04:57,330
auch wenn Sie denken logisch
das Programm ist ziemlich einfach,

99
00:04:57,330 --> 00:05:01,200
Sie könnte sehr gut gegen eine Wand, und
der Compiler wird nicht zur Zusammenarbeit.

100
00:05:01,200 --> 00:05:03,940
Machen oder Clang nicht gehen
zu tun, tatsächlich Ihr Bieten.

101
00:05:03,940 --> 00:05:05,450
>> Und warum könnte das sein?

102
00:05:05,450 --> 00:05:07,950
Nun, lassen Sie uns einen Blick auf,
vielleicht, ein einfaches Programm.

103
00:05:07,950 --> 00:05:11,190
Ich gehe voran gehen und speichern diese in
eine Datei absichtlich buggy0.c genannt,

104
00:05:11,190 --> 00:05:13,590
weil ich weiß, dass es zu
werden im Voraus fehlerhaft.

105
00:05:13,590 --> 00:05:17,400
Aber ich kann nicht erkennen, dass, wenn diese
ist die erste oder zweite oder dritte Programm

106
00:05:17,400 --> 00:05:18,830
dass ich selbst mache eigentlich.

107
00:05:18,830 --> 00:05:23,820
Also werde ich voran gehen und
tippen, int main (void).

108
00:05:23,820 --> 00:05:28,130
Und dann in meiner geschweiften Klammern,
ein sehr vertraut ( "hallo, world--

109
00:05:28,130 --> 00:05:30,980
Backslash, n ") - und ein Semikolon.

110
00:05:30,980 --> 00:05:32,360
>> Ich habe die Datei gespeichert.

111
00:05:32,360 --> 00:05:34,850
Jetzt werde ich nach unten gehen
zu meinem Terminal-Fenster

112
00:05:34,850 --> 00:05:40,340
und geben Sie make buggy0, weil wieder,
der Name der Datei ist heute buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Also eingeben buggy0 machen, ein.

114
00:05:43,660 --> 00:05:48,200
>> Und, oh, mein Gott, erinnern vom letzten Mal
dass keine Fehlermeldungen ist eine gute Sache.

115
00:05:48,200 --> 00:05:49,740
So ist keine Ausgabe eine gute Sache.

116
00:05:49,740 --> 00:05:52,920
Aber hier habe ich klar
eine gewisse Anzahl von Fehlern.

117
00:05:52,920 --> 00:05:56,470
>> So ist die erste Zeile der Ausgabe
nach machen buggy0 eingeben, Rückruf,

118
00:05:56,470 --> 00:05:59,540
ist ziemlich ausführliche Ausgabe des Clang.

119
00:05:59,540 --> 00:06:02,067
Unter der Haube,
CS50 IDE ist so konfiguriert,

120
00:06:02,067 --> 00:06:04,150
eine ganze Reihe zu verwenden, von
Optionen mit diesem Compiler

121
00:06:04,150 --> 00:06:05,941
so dass Sie nicht haben,
an sie zu denken.

122
00:06:05,941 --> 00:06:08,840
Und das ist, dass alle ersten Zeile
Mittel, die mit Clang beginnt.

123
00:06:08,840 --> 00:06:11,720
>> Aber danach, die Probleme
beginnen, um ihr Aussehen zu machen.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c auf der Linie 3, Zeichen
5, gibt es einen großen, roten Fehler.

125
00:06:17,390 --> 00:06:18,380
Was ist das?

126
00:06:18,380 --> 00:06:23,562
erklärt Implizit Bibliotheksfunktion
printf mit Typ int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [Werror].

128
00:06:26,050 --> 00:06:28,379
Ich meine, es ist sehr schnell
wird sehr obskur.

129
00:06:28,379 --> 00:06:30,170
Und natürlich auf den ersten
Blick, würden wir nicht

130
00:06:30,170 --> 00:06:32,380
erwarten Sie zu verstehen, die
Gesamtheit dieser Nachricht.

131
00:06:32,380 --> 00:06:34,213
Und so eine der Lehren
heute geht

132
00:06:34,213 --> 00:06:36,919
um zu bemerken, zu versuchen,
Muster oder ähnliche Dinge,

133
00:06:36,919 --> 00:06:38,960
um Fehler könnten Sie
in der Vergangenheit begegnet.

134
00:06:38,960 --> 00:06:41,335
Also lassen Sie uns nur necken auseinander
diese Worte, die bekannt vorkommen.

135
00:06:41,335 --> 00:06:44,290
Der große, rote Fehler ist eindeutig
ein Symbol für etwas zu sein falsch.

136
00:06:44,290 --> 00:06:47,940
>> implizit erklärt
Bibliotheksfunktion printf.

137
00:06:47,940 --> 00:06:51,680
Also selbst wenn ich nicht ganz verstehen, was
Deklaration implizit Bibliotheksfunktion

138
00:06:51,680 --> 00:06:54,900
Mittel, das Problem sicher
bezieht sich irgendwie printf.

139
00:06:54,900 --> 00:06:59,130
Und die Quelle dieser Ausgabe
hat mit erklärt, es zu tun.

140
00:06:59,130 --> 00:07:02,440
>> Deklarieren eine Funktion
es zum ersten Mal zu erwähnen.

141
00:07:02,440 --> 00:07:06,210
Und wir verwendet, um die Terminologie der vergangenen Woche
von einer Funktion Prototyp deklarieren,

142
00:07:06,210 --> 00:07:11,860
entweder mit einer Zeile an der Spitze Ihrer
Eigene Dateien oder in einer sogenannten Header-Datei.

143
00:07:11,860 --> 00:07:15,300
Und in welcher Datei haben wir sagen
letzte Woche, dass printf ist Zitat,

144
00:07:15,300 --> 00:07:17,080
unquote, erklärt?

145
00:07:17,080 --> 00:07:20,950
In welcher Datei ist ihr Vorbild?

146
00:07:20,950 --> 00:07:24,640
>> Also, wenn Sie sich erinnern, das erste, was ich
getippt, fast jedes Programm letzte Zeit--

147
00:07:24,640 --> 00:07:30,790
und zufällig vor einem Moment gestartet
Eingabe myself-- war dies ein hier--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- für
Ein- / output-- Punkt h Und in der Tat,

149
00:07:38,630 --> 00:07:41,860
wenn ich jetzt diese Datei speichern, werde ich
gehen Sie vor und meinem Bildschirm zu löschen,

150
00:07:41,860 --> 00:07:44,740
was Sie können, indem Sie tun
Klar, oder Sie können Control L halten,

151
00:07:44,740 --> 00:07:47,680
nur Ihre Terminal-Fenster zu löschen
nur einige Unordnung zu beseitigen.

152
00:07:47,680 --> 00:07:51,370
>> Ich gehe voran gehen und
Wieder Typ make buggy0, eingeben.

153
00:07:51,370 --> 00:07:53,790
Und voila, ich sehe immer noch, dass
lange Befehl von Clang,

154
00:07:53,790 --> 00:07:55,470
aber es gibt keine Fehlermeldung diesmal.

155
00:07:55,470 --> 00:07:58,800
Und in der Tat, wenn ich es tue ./buggy0,
genau wie beim letzten Mal,

156
00:07:58,800 --> 00:08:01,860
wo Punkt bedeutet dies,
Verzeichnis, Slash nur bedeutet,

157
00:08:01,860 --> 00:08:05,040
hier kommt der Name des Programms und
dass Name des Programms ist buggy0,

158
00:08:05,040 --> 00:08:07,340
Geben Sie "Hallo, Welt."

159
00:08:07,340 --> 00:08:09,440
>> Nun, wie haben Sie vielleicht
diese Lösung aufgelesen

160
00:08:09,440 --> 00:08:12,017
ohne notwendigerweise
Anerkennung als viele Worte

161
00:08:12,017 --> 00:08:14,350
wie ich, natürlich, mit
dies getan, so viele Jahre?

162
00:08:14,350 --> 00:08:18,720
Nun, erkennen pro das erste Problem
Set stellen wir Ihnen auf einen Befehl

163
00:08:18,720 --> 00:08:21,175
dass CS50 eigene Mitarbeiter
schrieb genannt help50.

164
00:08:21,175 --> 00:08:24,300
Und in der Tat tut C-Spezifikation für
das Problem eingestellt, wie diese zu nutzen.

165
00:08:24,300 --> 00:08:27,210
>> Aber help50 ist im Wesentlichen
ein Programm, das CS50-Mitarbeiter

166
00:08:27,210 --> 00:08:30,850
das erlaubt schrieb die Sie ausführen
ein Befehl oder ein Programm ausführen,

167
00:08:30,850 --> 00:08:36,169
und wenn Sie nicht verstehen, seine
Ausgang, dessen Ausgang mit help50 zu passieren,

168
00:08:36,169 --> 00:08:38,890
an welchem ​​Punkt die Software
dass die Mitarbeiter der Kurs geschrieben

169
00:08:38,890 --> 00:08:42,429
wird sich am Ausgang Ihres Programms
Zeile für Zeile, Zeichen für Zeichen.

170
00:08:42,429 --> 00:08:46,000
Und wenn wir, das Personal, erkennen die
Fehlermeldung, die Sie erlebt haben,

171
00:08:46,000 --> 00:08:50,580
wir werden versuchen, Sie mit einigen zu provozieren
rhetorische Fragen, mit ein paar Ratschläge,

172
00:08:50,580 --> 00:08:54,890
ähnlich wie ein TF oder einer CA oder mich
würde bei der Bürozeiten persönlich tun.

173
00:08:54,890 --> 00:08:58,320
>> Also schauen zu help50, wenn Sie nicht tun
erkennen notwendigerweise ein Problem.

174
00:08:58,320 --> 00:09:00,790
Aber verlassen Sie sich nicht darauf
zu viel als eine Krücke.

175
00:09:00,790 --> 00:09:03,990
Sicherlich versuchen zu verstehen, seine
Ausgang und dann daraus lernen

176
00:09:03,990 --> 00:09:07,571
so dass nur einmal oder zweimal tun Sie
jemals laufen help50 für einen bestimmten Fehler

177
00:09:07,571 --> 00:09:08,070
Nachricht.

178
00:09:08,070 --> 00:09:10,660
Danach sollten Sie sein
besser gerüstet, sich

179
00:09:10,660 --> 00:09:13,180
um herauszufinden, was tatsächlich ist es.

180
00:09:13,180 --> 00:09:14,350
>> Lassen Sie uns hier eine andere tun.

181
00:09:14,350 --> 00:09:20,410
Lassen Sie mich los, und in einem anderen
Datei werden wir diese buggy1.c nennen.

182
00:09:20,410 --> 00:09:23,110
Und in dieser Datei ich bin
gehen deliberately--

183
00:09:23,110 --> 00:09:26,330
aber so tun, dass ich nicht
zu verstehen, welche Fehler ich gemacht habe.

184
00:09:26,330 --> 00:09:31,420
>> Ich werde weitermachen und tun this--
# include, da ich

185
00:09:31,420 --> 00:09:33,660
vor habe meine Lektion gelernt von einem Moment.

186
00:09:33,660 --> 00:09:36,220
Int main (void), wie zuvor.

187
00:09:36,220 --> 00:09:40,880
Und dann hier in Ich werde
string s zu tun - get_string.

188
00:09:40,880 --> 00:09:43,770
Und erinnern vom letzten Mal, dass
diese Mittel, hey, Computer,

189
00:09:43,770 --> 00:09:48,280
geben Sie mir eine Variable, nennen es ist, und
stellen den Typ der Variablen ein String

190
00:09:48,280 --> 00:09:50,150
so kann ich speichern ein oder mehrere Wörter in ihm.

191
00:09:50,150 --> 00:09:52,191
>> Und dann auf der rechten
Seite des Gleichheitszeichen

192
00:09:52,191 --> 00:09:54,980
get_string ist, worin A
Funktion in der Bibliothek CS50

193
00:09:54,980 --> 00:09:55,980
das tut genau das.

194
00:09:55,980 --> 00:09:59,740
Es wird eine Funktion und dann
Hände es von rechts nach links.

195
00:09:59,740 --> 00:10:02,670
Also das Gleichheitszeichen bedeutet nicht,
"Gleich", wie wir in der Mathematik vielleicht denken.

196
00:10:02,670 --> 00:10:04,750
Es bedeutet Zuordnung von rechts nach links.

197
00:10:04,750 --> 00:10:09,640
Dies bedeutet also, nehmen Sie die Zeichenfolge aus
der Benutzer und speichern Sie es innerhalb von s.

198
00:10:09,640 --> 00:10:10,460
>> Nun wollen wir es verwenden.

199
00:10:10,460 --> 00:10:13,820
Lassen Sie mich voran gehen jetzt und als zweite
Linie, lassen Sie mich voran gehen und sagen "Hallo" -

200
00:10:13,820 --> 00:10:19,330
nicht "Welt", sondern "hallo,% s--
Das ist unser Platzhalter, Komma s,

201
00:10:19,330 --> 00:10:22,030
Das ist unsere variabel,
und dann ein Semikolon.

202
00:10:22,030 --> 00:10:26,070
Also, wenn ich nicht zu vermasseln viel
hier sieht das richtige Code wie.

203
00:10:26,070 --> 00:10:28,090
>> Und meine Instinkte sind jetzt ist es zu kompilieren.

204
00:10:28,090 --> 00:10:30,400
Die Datei wird buggy1.c genannt.

205
00:10:30,400 --> 00:10:33,770
Also werde ich buggy1 zu tun, eintragen.

206
00:10:33,770 --> 00:10:36,377
Und stopfen-it, wenn es nicht ist
noch mehr Fehler als zuvor.

207
00:10:36,377 --> 00:10:38,210
Ich meine, es gibt noch mehr
Fehlermeldungen, es würde

208
00:10:38,210 --> 00:10:40,400
in diesem Programm scheinen als die tatsächlichen Linien.

209
00:10:40,400 --> 00:10:42,730
>> Aber das Essen zum Mitnehmen ist hier,
auch wenn Sie überwältigt

210
00:10:42,730 --> 00:10:45,040
mit zwei oder drei oder
vier weitere Fehlermeldungen,

211
00:10:45,040 --> 00:10:48,340
konzentrieren sich immer auf der sehr
erste dieser Nachrichten.

212
00:10:48,340 --> 00:10:52,220
Mit Blick auf die am weitesten oben ein,
Scrollen nach oben zurück, wie es sein muss.

213
00:10:52,220 --> 00:10:53,930
Also hier tippte ich make buggy1.

214
00:10:53,930 --> 00:10:55,700
Hier ist, dass Clang Ausgabe wie erwartet.

215
00:10:55,700 --> 00:10:57,290
>> Und hier ist der erste rote Fehler.

216
00:10:57,290 --> 00:11:02,370
Die Verwendung von nicht deklarierter Bezeichner
string, habe ich meine Standard in?

217
00:11:02,370 --> 00:11:04,260
So Standard in ist
eigentlich etwas anderes.

218
00:11:04,260 --> 00:11:06,240
Er bezieht sich auf den Benutzer
Tastatur, im Wesentlichen.

219
00:11:06,240 --> 00:11:08,080
>> Aber das ist nicht das, was ich meinte.

220
00:11:08,080 --> 00:11:11,770
Ich meinte, Schnur, und ich meinte get_string.

221
00:11:11,770 --> 00:11:16,200
Also, was ist es, dass ich
vergessen haben, diese Zeit zu tun?

222
00:11:16,200 --> 00:11:20,230
Was fehlt dieses Mal?

223
00:11:20,230 --> 00:11:23,600
Ich habe meine # include,
so habe ich Zugang zu printf.

224
00:11:23,600 --> 00:11:26,090
>> Aber was habe ich nicht
Zugriff auf nur noch?

225
00:11:26,090 --> 00:11:29,420
Nun, genau wie beim letzten Mal,
Ich brauche den Compiler zu sagen,

226
00:11:29,420 --> 00:11:31,691
Clang, was diese Funktionen sind.

227
00:11:31,691 --> 00:11:33,940
Get_string kommt nicht
mit C. Und es insbesondere

228
00:11:33,940 --> 00:11:38,160
kommt nicht in die
Header-Datei.

229
00:11:38,160 --> 00:11:40,770
Es kommt stattdessen in
etwas, das die Mitarbeiter schrieb,

230
00:11:40,770 --> 00:11:44,176
Das ist eine andere Datei
Name, aber treffend benannt.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> So einfach durch, dass eine Zeile hinzufügen
von code-- Rückruf vom letzten Mal

233
00:11:50,861 --> 00:11:53,610
dass, wenn läuft Clang, es geht
an meinem Code von oben nach unten zu schauen,

234
00:11:53,610 --> 00:11:54,193
links nach rechts.

235
00:11:54,193 --> 00:11:57,200
Es wird bemerkt,
oh, Sie wollen.

236
00:11:57,200 --> 00:11:59,900
Lassen Sie mich gehen und feststellen, dass,
überall dort, wo es auf dem Server ist,

237
00:11:59,900 --> 00:12:03,090
Kopieren und fügen Sie diesen im Wesentlichen wissen,
in die Spitze der eigenen Datei

238
00:12:03,090 --> 00:12:06,820
so daß an diesem Punkt in der Geschichte,
Linie 1, der Rest des Programms

239
00:12:06,820 --> 00:12:11,651
kann eine der Funktionen verwenden, in der Tat,
darin, unter ihnen get_string.

240
00:12:11,651 --> 00:12:13,650
Also werde ich zu ignorieren
der Rest dieser Fehler,

241
00:12:13,650 --> 00:12:17,190
weil ich in der Tat vermuten, dass nur
die erste zählte tatsächlich.

242
00:12:17,190 --> 00:12:20,780
Und ich werde weiter und erneut ausführen zu gehen,
nach meiner Datei zu speichern machen buggy1.

243
00:12:20,780 --> 00:12:22,580
Und voila, es hat funktioniert.

244
00:12:22,580 --> 00:12:29,200
Und wenn ich es tue ./buggy1 und geben, für
Beispiel Zamyla, ich werde jetzt bekommen hallo,

245
00:12:29,200 --> 00:12:32,000
Zamyla statt hallo, Welt.

246
00:12:32,000 --> 00:12:32,550
>> Gut.

247
00:12:32,550 --> 00:12:35,890
So sind die Imbissbuden hier sind dann zu,
ein, versuchen, so viel aufzulesen, wie Sie können

248
00:12:35,890 --> 00:12:39,140
aus den Fehlermeldungen alleine und suche
auf einige der erkennbaren Worte.

249
00:12:39,140 --> 00:12:43,070
Abgesehen davon, verwenden help50 pro
das Problem gesetzt Spezifikation.

250
00:12:43,070 --> 00:12:46,500
Aber das Sperre auch immer aussehen
nur oben Fehler zumindest

251
00:12:46,500 --> 00:12:50,051
zunächst, um zu sehen, welche Informationen
es könnte in der Tat ergeben.

252
00:12:50,051 --> 00:12:52,300
Aber es stellt sich dort die aus
noch mehr Funktionalität gebaut

253
00:12:52,300 --> 00:12:55,030
in die CS50-Bibliothek zu helfen,
Sie früh im Semester

254
00:12:55,030 --> 00:12:57,580
und früh im Programmier
herauszufinden, was falsch läuft.

255
00:12:57,580 --> 00:12:59,840
Also lassen Sie uns hier ein weiteres Beispiel zu tun.

256
00:12:59,840 --> 00:13:04,350
Ich werde diese buggy2 zu nennen, die,
wieder heraus werden wird fehlerhaft

257
00:13:04,350 --> 00:13:05,650
des Tores, durch Design.

258
00:13:05,650 --> 00:13:09,980
>> Und ich werde voran gehen
und tun # include.

259
00:13:09,980 --> 00:13:12,580
Und dann werde ich int main (void) zu tun.

260
00:13:12,580 --> 00:13:14,840
Und dann werde ich eine for-Schleife zu tun.

261
00:13:14,840 --> 00:13:16,690
Für (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i kleiner als oder gleich 10 ist.

263
00:13:18,750 --> 00:13:24,260
i ++, und dann in geschweiften Klammern, ich werde
nur ein Hashtag Symbol hier auszudrucken

264
00:13:24,260 --> 00:13:25,920
und eine neue Linie Charakter.

265
00:13:25,920 --> 00:13:29,220
>> So ist meine Absicht, mit diesem
Programm ist ganz einfach

266
00:13:29,220 --> 00:13:33,150
iterieren 10 mal
und bei jeder Iteration

267
00:13:33,150 --> 00:13:35,260
dieser Schleife jedes Mal
durch den Zyklus,

268
00:13:35,260 --> 00:13:37,660
drucken Sie eine Hashtag aus,
ein hashtag, ein Hashtag.

269
00:13:37,660 --> 00:13:40,480
Eine pro Zeile, weil ich
haben es die neue Linie.

270
00:13:40,480 --> 00:13:42,787
Und daran erinnern, dass die für
Schleife, pro letzten week--

271
00:13:42,787 --> 00:13:44,620
und du bekommst mehr
vertraut mit der Syntax

272
00:13:44,620 --> 00:13:47,170
indem sie sie mit der Praxis unter Verwendung von
vor long-- das gibt mir

273
00:13:47,170 --> 00:13:49,740
eine Variable i genannt und setzt ihn auf 0.

274
00:13:49,740 --> 00:13:52,650
>> Dies erhöht i auf
jeder Iteration um 1.

275
00:13:52,650 --> 00:13:54,940
So geht i auf 1 bis 2 bis 3 ist.

276
00:13:54,940 --> 00:13:57,690
Und dann diese Bedingung in der
Mitte zwischen den Semikolons

277
00:13:57,690 --> 00:14:03,010
wird bei jeder Iteration überprüft, um
sicher, dass wir immer noch in Reichweite befinden.

278
00:14:03,010 --> 00:14:06,830
Deshalb möchte ich 10-mal zu wiederholen, so dass ich
haben eine Art sehr intuitiv einfach

279
00:14:06,830 --> 00:14:09,070
setzen 10 als meine obere dort gebunden.

280
00:14:09,070 --> 00:14:14,310
>> Und doch, wenn ich das laufen, nach
Kompilieren mit make buggy2--

281
00:14:14,310 --> 00:14:15,440
und es läßt sich OK.

282
00:14:15,440 --> 00:14:17,980
Also habe ich nicht ein
Syntaxfehler dieser Zeit.

283
00:14:17,980 --> 00:14:20,940
Lassen Sie mich gehen Sie voran jetzt
und laufen buggy2, ein.

284
00:14:20,940 --> 00:14:22,620
Und jetzt nach oben.

285
00:14:22,620 --> 00:14:24,890
Und lassen Sie mich erhöhen
die Größe des Fensters.

286
00:14:24,890 --> 00:14:33,720
>> Ich scheine 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Es gibt also 11 Hashtags, obwohl
Ich habe klar 10 innerhalb dieser Schleife.

288
00:14:38,891 --> 00:14:42,140
einige von euch vielleicht jetzt sofort sehen
was der Fehler liegt daran, dass in der Tat, diese

289
00:14:42,140 --> 00:14:43,720
ist nicht ein sehr harter Fehler zu machen.

290
00:14:43,720 --> 00:14:46,070
Aber es ist sehr häufig
machte sehr früh.

291
00:14:46,070 --> 00:14:49,820
>> Was möchte ich darauf hinweisen, obwohl,
ist, wie könnte ich das herausfinden?

292
00:14:49,820 --> 00:14:52,300
Nun, es stellt sich heraus, dass
die CS50-Bibliothek kommt

293
00:14:52,300 --> 00:14:55,380
nicht nur mit get_string und get_int
und get_float und andere Funktionen.

294
00:14:55,380 --> 00:14:59,980
Es kommt auch mit einer speziellen Funktion
genannt eprintf, oder, Fehler printf.

295
00:14:59,980 --> 00:15:03,270
Und es existiert nur zu machen
es ein wenig einfacher für Sie

296
00:15:03,270 --> 00:15:06,310
beim Debuggen Ihres Codes nur
drucken Sie eine Fehlermeldung auf dem Bildschirm

297
00:15:06,310 --> 00:15:07,850
und wissen, woher es kam.

298
00:15:07,850 --> 00:15:11,000
>> So zum Beispiel, ist eine Sache, ich könnte
hier tun mit dieser Funktion ist this--

299
00:15:11,000 --> 00:15:20,230
eprintf, und dann gehe ich voran gehen
und sagen, dass ich jetzt% i ist, Backslash, n.

300
00:15:20,230 --> 00:15:22,330
Und ich werde im Wert von i zu stopfen.

301
00:15:22,330 --> 00:15:25,400
Und bis oben, weil diese
ist in der CS50-Bibliothek,

302
00:15:25,400 --> 00:15:27,580
Ich gehe voran gehen
und umfassen

303
00:15:27,580 --> 00:15:29,169
so habe ich Zugriff auf diese Funktion.

304
00:15:29,169 --> 00:15:31,460
Aber lassen Sie uns überlegen, welche Linie
9 soll, zu tun.

305
00:15:31,460 --> 00:15:32,670
Ich werde dies schließlich zu löschen.

306
00:15:32,670 --> 00:15:34,670
Das hat nichts zu tun
mit meinem übergeordneten Ziel.

307
00:15:34,670 --> 00:15:39,090
Aber eprintf, Fehler printf ist nur gemeint
zu geben Sie mir einige Diagnoseinformationen.

308
00:15:39,090 --> 00:15:42,460
Wenn ich mein Programm laufen, möchte ich
sehen dies auf dem Bildschirm vorübergehend

309
00:15:42,460 --> 00:15:44,550
auch nur zu verstehen,
Was ist los.

310
00:15:44,550 --> 00:15:47,330
>> Und in der Tat, auf jedem
Iteration hier der Linie 9

311
00:15:47,330 --> 00:15:49,260
Ich will sehen, was ist der Wert von i?

312
00:15:49,260 --> 00:15:50,290
Was ist der Wert von i?

313
00:15:50,290 --> 00:15:51,280
Was ist der Wert von i?

314
00:15:51,280 --> 00:15:55,650
Und hoffentlich, sollte ich nur
sehen diese Nachricht, auch, 10-mal.

315
00:15:55,650 --> 00:15:57,780
>> Also lassen Sie mich gehen Sie vor und
neu kompilieren mein Programm,

316
00:15:57,780 --> 00:15:59,905
wie ich haben keine Zeit zu tun
Ich mache eine Änderung. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Und now-- OK.

319
00:16:03,640 --> 00:16:04,820
Es gibt viel mehr los.

320
00:16:04,820 --> 00:16:07,610
lassen Sie mich nach oben So in
ein noch größeres Fenster.

321
00:16:07,610 --> 00:16:10,190
>> Und Sie werden sehen, dass jeder
die Hashtags druckt immer noch.

322
00:16:10,190 --> 00:16:15,270
Aber zwischen jedem von ihnen ist nun diese
Diagnoseausgang wie folgt formatiert.

323
00:16:15,270 --> 00:16:17,960
Der Name meines Programms ist hier buggy2.

324
00:16:17,960 --> 00:16:20,432
Der Name der Datei ist buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Die Zeilennummer aus dem
dies wurde gedruckt ist Linie 9.

326
00:16:24,080 --> 00:16:27,500
Und dann nach rechts, dass die
Fehlermeldung, die ich erwarte.

327
00:16:27,500 --> 00:16:30,701
>> Und was ist schön daran ist, dass
jetzt muss ich nicht unbedingt rechnen

328
00:16:30,701 --> 00:16:32,200
in meinem Kopf, was mein Programm tut.

329
00:16:32,200 --> 00:16:34,240
Ich kann das auf der zu sehen
erste Iteration i gleich 0 ist,

330
00:16:34,240 --> 00:16:39,420
dann 1, dann 2, dann 3, dann 4, dann
5, dann 6, dann 7, dann 8, dann 9, dann

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
So warten Sie eine Minute.

333
00:16:42,050 --> 00:16:43,740
Was ist denn hier los?

334
00:16:43,740 --> 00:16:48,190
Ich scheine immer noch zu zählen
wie bis 10 bestimmt werden.

335
00:16:48,190 --> 00:16:50,550
>> Aber woher fange ich an?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
So 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- der 11. Finger

338
00:16:58,040 --> 00:16:59,990
ist das Problem indikativ.

339
00:16:59,990 --> 00:17:02,850
Ich scheine zu haben gezählt
falsch in meiner Schleife.

340
00:17:02,850 --> 00:17:06,599
Anstatt 10 Iterationen gehen,
Ich fange bei 0,

341
00:17:06,599 --> 00:17:09,550
Ich endend bei und bis 10.

342
00:17:09,550 --> 00:17:12,030
Aber da, wie ein Computer,
Ich beginne das Zählen bei 0,

343
00:17:12,030 --> 00:17:15,250
Ich sollte Zählen
zu, aber nicht durch, 10.

344
00:17:15,250 --> 00:17:18,510
>> Und so ist die Verlegenheit, ich schließlich
hier realisiert, ist eines von zwei Dingen.

345
00:17:18,510 --> 00:17:22,430
Ich konnte sehr einfach sagen:
zählen bis zu weniger als 10.

346
00:17:22,430 --> 00:17:27,260
So 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, das ist in der Tat richtig,

347
00:17:27,260 --> 00:17:28,900
auch wenn es ein wenig falsch klingt.

348
00:17:28,900 --> 00:17:35,070
Oder ich könnte tun, weniger als oder gleich
so lange bis 9, wie ich bei 0 beginnen.

349
00:17:35,070 --> 00:17:40,056
Oder wenn Sie wirklich nicht, wie das, Sie
zählen bis 10 kann aber bei 1 beginnen.

350
00:17:40,056 --> 00:17:41,680
Aber noch einmal, das ist einfach nicht so weit verbreitet.

351
00:17:41,680 --> 00:17:43,977
In programming-- wenn auch
nicht so sehr in Scratch--

352
00:17:43,977 --> 00:17:45,810
aber in der Programmierung in
C und anderen Sprachen,

353
00:17:45,810 --> 00:17:47,670
wie JavaScript und
Python und andere, es ist

354
00:17:47,670 --> 00:17:49,880
nur sehr üblich,
unsere Diskussion von binären

355
00:17:49,880 --> 00:17:53,450
beginnen gerade bei der Zählung
niedrigste Zahl möglich, die 0 ist.

356
00:17:53,450 --> 00:17:53,950
Gut.

357
00:17:53,950 --> 00:17:55,160
Also das ist eprintf.

358
00:17:55,160 --> 00:17:58,600
Und wieder, jetzt, da ich habe meine heraus
Problem, und ich werde wieder auf 0 zu gehen

359
00:17:58,600 --> 00:18:01,470
durch weniger als 10, ich werde
zu gehen und zu löschen eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Es sollte nicht da sein, wenn ich
Schiff meinen Code oder einreichen meinen Code

361
00:18:04,580 --> 00:18:05,800
oder zeigen an andere Personen weiter.

362
00:18:05,800 --> 00:18:07,980
Es ist wirklich nur gemeint
vorübergehend verwendet werden.

363
00:18:07,980 --> 00:18:11,650
Aber jetzt habe ich feste diese
besonderes Problem auch.

364
00:18:11,650 --> 00:18:16,780
>> Nun, lassen Sie uns tun ein weiteres Beispiel hier
dass ich gehe wie folgt zu schüren.

365
00:18:16,780 --> 00:18:22,850
Ich gehe voran gehen und
# include. $ 50

366
00:18:22,850 --> 00:18:25,580
Und ich werde voran gehen
und # include.

367
00:18:25,580 --> 00:18:29,030
>> Und ich werde zu retten
Diese Datei als buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Und ich werde voran gehen
und erklären int main (void).

369
00:18:31,740 --> 00:18:34,186
Und dann in der es
Ich werde int i tun _ -

370
00:18:34,186 --> 00:18:36,435
Ich möchte ein Programm zu implementieren
mit einem get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Dies ist nicht eine Funktion, die noch vorhanden ist.

373
00:18:40,770 --> 00:18:42,870
Also wir gehen zu implementieren
es in nur einem Augenblick.

374
00:18:42,870 --> 00:18:45,541
Aber wir werden sehen, warum
es ist Buggy auf den ersten Pass.

375
00:18:45,541 --> 00:18:47,290
Und einmal habe ich bekommen
ein int vom Benutzer,

376
00:18:47,290 --> 00:18:53,365
Ich werde nur% i print ist eine negative
integer, Backslash, n, Komma, i.

377
00:18:53,365 --> 00:18:55,240
In anderen Worten, alle I
wollen dieses Programm zu tun

378
00:18:55,240 --> 00:18:58,000
eine negative int wird erhalten aus
der Benutzer und dann ausdrucken

379
00:18:58,000 --> 00:18:59,980
dass so und so ist eine negative int.

380
00:18:59,980 --> 00:19:02,080
>> Jetzt muss ich diese Funktion zu implementieren.

381
00:19:02,080 --> 00:19:05,740
So später in meiner Akte, ich werde gehen
voraus und eine Funktion deklarieren genannt

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - und wir werden
kommen zurück zu dem, was diese Linie wieder bedeutet,

383
00:19:10,670 --> 00:19:18,790
in einem moment-- int n; do-- do
die following-- printf n :.

384
00:19:18,790 --> 00:19:26,210
Und dann werde ich n zu tun - get_int,
und tun dies, während n größer als 0 ist.

385
00:19:26,210 --> 00:19:28,310
Und dann n zurückzukehren ;.

386
00:19:28,310 --> 00:19:31,730
>> Es gibt also eine Menge los in
dies aber keine von denen wir nicht

387
00:19:31,730 --> 00:19:33,710
sehen in der vergangenen Woche, zumindest kurzzeitig.

388
00:19:33,710 --> 00:19:36,980
Also auf der Linie 10 hier habe ich erklärt ein
Funktion namens get_negative_int,

389
00:19:36,980 --> 00:19:39,620
und ich habe setzen (void), in
Klammern, wobei der Grund dafür

390
00:19:39,620 --> 00:19:40,950
keine Eingabe mehr nehmen.

391
00:19:40,950 --> 00:19:42,910
Ich bin vorbei nichts
auf diese Funktion.

392
00:19:42,910 --> 00:19:44,690
Ich bin immer nur etwas von ihm zurück.

393
00:19:44,690 --> 00:19:47,270
>> Und was ich bin der Hoffnung auf
wieder eine ganze Zahl.

394
00:19:47,270 --> 00:19:50,040
Es gibt keine Datentyp in
C genannt negative_int.

395
00:19:50,040 --> 00:19:52,880
Es ist nur int, so es geht
zu sein auf uns, um sicherzustellen,

396
00:19:52,880 --> 00:19:55,340
dass der Wert, tatsächlich ist
Returned ist nicht nur ein int

397
00:19:55,340 --> 00:19:56,380
sondern ist auch negativ.

398
00:19:56,380 --> 00:20:02,150
>> In Zeile 12 Ich erkläre eine Variable
n und macht es vom Typ int genannt.

399
00:20:02,150 --> 00:20:07,500
Und dann in Zeile 13 bis 18 Ich bin
etwas zu tun, während etwas wahr ist.

400
00:20:07,500 --> 00:20:11,040
Ich gehe weiter und Drucken
n, Dickdarm-, und dann wird ein Raum,

401
00:20:11,040 --> 00:20:12,800
wie eine Aufforderung für den Benutzer.

402
00:20:12,800 --> 00:20:16,410
>> Ich bin dann get_int Aufruf und
Speicherung der so genannten Rückgabewert

403
00:20:16,410 --> 00:20:18,130
in dieser Variablen n.

404
00:20:18,130 --> 00:20:22,600
Aber ich werde weiterhin tun,
dies während n größer als 0 ist.

405
00:20:22,600 --> 00:20:27,960
Mit anderen Worten, wenn der Benutzer gibt mir eine
int und diese Zahl größer als 0 ist,

406
00:20:27,960 --> 00:20:31,180
ergo, positiv, ich werde
halten nur den Benutzer reprompting,

407
00:20:31,180 --> 00:20:37,160
halten reprompting, indem sie zu zwingen,
kooperieren und geben mir ein negatives int.

408
00:20:37,160 --> 00:20:41,640
>> Und wenn n tatsächlich negative-- ist
Angenommen, der Benutzer schließlich Typen -50,

409
00:20:41,640 --> 00:20:46,710
Diese while-Schleife dann ist nicht mehr wahr
weil -50 nicht größer als 0 ist.

410
00:20:46,710 --> 00:20:51,140
So brechen wir davon aus
Schleife logisch und zurück n.

411
00:20:51,140 --> 00:20:53,520
>> Aber es gibt eine andere
was ich zu tun habe.

412
00:20:53,520 --> 00:20:56,190
Und ich kann dies einfach tun
durch das Kopieren und Einfügen

413
00:20:56,190 --> 00:20:58,540
eine Codezeile am Anfang der Datei.

414
00:20:58,540 --> 00:21:01,630
Ich brauche zu lehren Clang,
oder Versprechen zu klappern,

415
00:21:01,630 --> 00:21:04,630
ausdrücklich, dass ich will,
in der Tat, zu gehen und implementieren

416
00:21:04,630 --> 00:21:06,020
diese Funktion get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Es könnte nur in der Datei niedriger sein.

418
00:21:07,674 --> 00:21:09,840
Auch daran erinnern, dass Clang
liest die Dinge von oben nach unten,

419
00:21:09,840 --> 00:21:12,330
links nach rechts, so dass Sie nicht
rufen Sie eine Funktion, wenn Clang

420
00:21:12,330 --> 00:21:15,330
weiß nicht, es wird zu existieren.

421
00:21:15,330 --> 00:21:18,430
>> Nun, leider ist dieses Programm,
wie einige von euch vielleicht bemerkt haben,

422
00:21:18,430 --> 00:21:19,590
ist bereits Buggy.

423
00:21:19,590 --> 00:21:21,400
Lassen Sie mich gehen Sie vor und buggy3 machen.

424
00:21:21,400 --> 00:21:26,904
Es kompiliert, so dass nun mein Problem ist nicht
ein Syntaxfehler, wie ein Textfehler,

425
00:21:26,904 --> 00:21:29,570
es wird tatsächlich eine logisch zu sein
Fehler, die ich bewusst habe

426
00:21:29,570 --> 00:21:32,450
gemacht als Chance
Schritt für Schritt durch, was los ist.

427
00:21:32,450 --> 00:21:35,540
>> Ich gehe voran gehen
jetzt und führen buggy3.

428
00:21:35,540 --> 00:21:37,490
Und ich werde gehen
kooperieren voraus und nicht.

429
00:21:37,490 --> 00:21:39,494
Ich werde es die Nummer 1 zu geben.

430
00:21:39,494 --> 00:21:41,410
Es mochte es nicht, so
es veranlasst mich wieder.

431
00:21:41,410 --> 00:21:42,147
>> Wie etwa 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Keiner von denen arbeiten.

435
00:21:44,740 --> 00:21:46,890
Wie etwa -50?

436
00:21:46,890 --> 00:21:48,560
Und das Programm scheint zu funktionieren.

437
00:21:48,560 --> 00:21:49,970
>> Lassen Sie mich versuchen es noch einmal.

438
00:21:49,970 --> 00:21:53,400
Lassen Sie mich versuchen, -1, scheint zu funktionieren.

439
00:21:53,400 --> 00:21:56,380
Lassen Sie mich versuchen, -2, scheint zu funktionieren.

440
00:21:56,380 --> 00:21:59,640
Lassen Sie mich versuchen, 0.

441
00:21:59,640 --> 00:22:01,684
Huh, das ist falsch.

442
00:22:01,684 --> 00:22:03,350
Jetzt sind wir ein wenig pedantisch hier zu sein.

443
00:22:03,350 --> 00:22:07,090
Aber es ist tatsächlich der Fall, dass 0
weder positiv noch negativ ist.

444
00:22:07,090 --> 00:22:11,150
Und so ist die Tatsache, dass mein Programm ist
sagen, dass 0 eine negative ganze Zahl ist,

445
00:22:11,150 --> 00:22:12,820
das ist technisch nicht korrekt.

446
00:22:12,820 --> 00:22:15,180
>> Nun, warum ist es dies zu tun?

447
00:22:15,180 --> 00:22:16,270
Nun, es mag offensichtlich sein.

448
00:22:16,270 --> 00:22:18,110
Und in der Tat ist das Programm
bedeutete ziemlich einfach zu sein

449
00:22:18,110 --> 00:22:19,670
so haben wir etwas zu erkunden.

450
00:22:19,670 --> 00:22:25,870
>> Aber lassen Sie uns ein drittes Debuggen einführen
Technik hier debug50 genannt.

451
00:22:25,870 --> 00:22:27,750
Das ist also ein Programm
dass wir gerade erstellt

452
00:22:27,750 --> 00:22:30,770
in diesem Jahr genannt debug50
das Ihnen erlaubt,

453
00:22:30,770 --> 00:22:34,130
zu verwenden, was einen eingebauten in genannt
grafischer Debugger in CS50-IDE.

454
00:22:34,130 --> 00:22:38,400
Und ein Debugger ist nur ein Programm, das
im Allgemeinen können Sie Ihr Programm ausführen

455
00:22:38,400 --> 00:22:44,050
aber Schritt für Schritt für Schritt, Zeile
Zeile für Zeile, pausieren, Stossen

456
00:22:44,050 --> 00:22:47,626
um, mit Blick auf Variablen, so dass
Schlag wird das Programm nicht nur an Ihnen vorbei

457
00:22:47,626 --> 00:22:49,750
und schnell drucken etwas
oder nicht, etwas zu drucken.

458
00:22:49,750 --> 00:22:53,250
Es gibt Ihnen die Möglichkeit, bei
menschliche Geschwindigkeit, mit ihr zu interagieren.

459
00:22:53,250 --> 00:22:55,470
>> Und um dies zu tun, werden Sie
einfach gehen Sie wie folgt.

460
00:22:55,470 --> 00:22:58,479
Nach dem Kompilieren von Code,
was ich schon getan, buggy3,

461
00:22:58,479 --> 00:23:00,020
Sie voran gehen und debug50 ./buggy laufen.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
So viel wie help50 hat Sie laufen
help50 und dann den Befehl,

464
00:23:06,760 --> 00:23:10,120
debug50 hat Sie debug50 laufen und
dann wird der Name des Befehls.

465
00:23:10,120 --> 00:23:14,440
>> Nun sehen, was auf meinem Bildschirm geschieht,
auf der rechten Seite im Besonderen.

466
00:23:14,440 --> 00:23:19,400
Als ich getroffen Run, die alle die
plötzlich dieses Panel rechts

467
00:23:19,400 --> 00:23:20,419
öffnet sich auf dem Bildschirm.

468
00:23:20,419 --> 00:23:22,210
Und es gibt eine Menge los
auf auf den ersten Blick.

469
00:23:22,210 --> 00:23:25,110
Aber ist es nicht zu
viel über noch zu kümmern.

470
00:23:25,110 --> 00:23:28,570
>> Dies zeigt mir alles
das wird auf der Innenseite meines Programms

471
00:23:28,570 --> 00:23:31,130
jetzt und über diese
Tasten bis oben ist dann

472
00:23:31,130 --> 00:23:35,910
Erlauben mir durch meinen Code zu Schritt
Schritt schließlich durch Schritt für Schritt.

473
00:23:35,910 --> 00:23:37,140
Aber nicht nur noch.

474
00:23:37,140 --> 00:23:38,060
Beachten Sie, was passiert.

475
00:23:38,060 --> 00:23:40,600
In meinem Terminal-Fenster
Ich wird für n gefragt werden.

476
00:23:40,600 --> 00:23:44,560
Und ich werde weitermachen und
diese Zeit und geben -1 zusammenarbeiten.

477
00:23:44,560 --> 00:23:48,770
Und wenn auch ein wenig kryptisch, -1
wie erwartet, ist eine negative ganze Zahl ist,.

478
00:23:48,770 --> 00:23:52,020
>> Und dann verlassen Kind mit
Status 0 gdbserver verlassen.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, ist der Name
der zugrunde liegenden Software

480
00:23:55,180 --> 00:23:56,620
dass implementiert diese Debugger.

481
00:23:56,620 --> 00:24:00,500
Aber all dies wirklich bedeutet, den Debugger
beenden ging weg, weil mein Programm

482
00:24:00,500 --> 00:24:01,710
und alles war gut.

483
00:24:01,710 --> 00:24:06,020
Wenn ich will wirklich mein Programm zu debuggen,
Ich muss präventiv debug50 sagen,

484
00:24:06,020 --> 00:24:08,920
wo soll ich anfangen
Schreiten durch meinen Code?

485
00:24:08,920 --> 00:24:11,750
>> Und vielleicht der einfachste Weg,
das zu tun, ist wie folgt.

486
00:24:11,750 --> 00:24:15,300
Wenn ich den Mauszeiger über die
Gosse meiner Editor hier,

487
00:24:15,300 --> 00:24:19,090
so wirklich nur in der Sidebar hier,
die links von der Zeilennummer,

488
00:24:19,090 --> 00:24:21,870
Beachten Sie, dass, wenn ich klicken Sie einfach
einmal, habe ich einen kleinen roten Punkt.

489
00:24:21,870 --> 00:24:24,460
Und das kleine rote Punkt,
wie ein Stoppschild bedeutet, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, Pause Ausführung meines Codes
genau dort, wenn ich dieses Programm ausführen.

491
00:24:29,430 --> 00:24:30,260
>> Also lassen Sie uns das tun.

492
00:24:30,260 --> 00:24:37,340
Lassen Sie mich gehen Sie vor und führen Sie mein Programm
wieder mit debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Und jetzt, bemerken, etwas
anders ist passiert.

494
00:24:40,110 --> 00:24:42,440
Ich bin nicht gefragt zu werden
noch in meinem Terminal-Fenster

495
00:24:42,440 --> 00:24:45,430
für alles, haben, weil ich nicht
bekommen es noch in meinem Programm.

496
00:24:45,430 --> 00:24:47,950
Beachten Sie, dass auf der Linie 8
die nun markiert ist,

497
00:24:47,950 --> 00:24:51,720
und es gibt einen kleinen Pfeil auf
links sagen, Sie sind hier angehalten.

498
00:24:51,720 --> 00:24:55,030
Diese Codezeile, Zeile
8, noch nicht ausgeführt.

499
00:24:55,030 --> 00:24:58,940
>> Und was ist neugierig, wenn ich sehe
hier auf der rechten Seite,

500
00:24:58,940 --> 00:25:03,530
bemerken, dass ich ein lokal
Variable, lokale im Sinne

501
00:25:03,530 --> 00:25:05,450
dass es innerhalb der aktuellen Funktion.

502
00:25:05,450 --> 00:25:08,920
Und ihr Wert, die anscheinend durch Standard,
und Art bequem, ist 0.

503
00:25:08,920 --> 00:25:10,260
Aber ich habe nicht 0 ein.

504
00:25:10,260 --> 00:25:13,410
Das geschieht nur um seine
Standardwert im Moment.

505
00:25:13,410 --> 00:25:15,490
>> Also lassen Sie mich gehen Sie vor und tun dies jetzt.

506
00:25:15,490 --> 00:25:18,680
Lassen Sie mich gehen Sie vor und auf
oben rechts hier, ich bin

507
00:25:18,680 --> 00:25:20,970
gehen voran gehen und
klicken Sie auf diese erste Symbol, das

508
00:25:20,970 --> 00:25:25,360
bedeutet Schritt, über die Mittel nicht überspringen
es aber über diese Codezeile Schritt,

509
00:25:25,360 --> 00:25:27,770
Ausführung es auf dem Weg.

510
00:25:27,770 --> 00:25:30,710
>> Und jetzt bemerken, meine
Prompt hat gerade geändert.

511
00:25:30,710 --> 00:25:31,380
Warum das?

512
00:25:31,380 --> 00:25:33,639
Ich habe gesagt, debug50,
laufen diese Codezeile.

513
00:25:33,639 --> 00:25:34,930
Was bedeutet diese Zeile Code zu tun?

514
00:25:34,930 --> 00:25:35,960
Fordert mich für ein int.

515
00:25:35,960 --> 00:25:36,460
OK.

516
00:25:36,460 --> 00:25:37,400
Lassen Sie mich zusammenarbeiten.

517
00:25:37,400 --> 00:25:41,340
Lassen Sie mich gehen Sie vor und geben Sie jetzt -1 eingeben.

518
00:25:41,340 --> 00:25:42,920
Und nun merken, was sich geändert hat.

519
00:25:42,920 --> 00:25:46,060
Auf der rechten Seite,
meine lokale Variable i

520
00:25:46,060 --> 00:25:48,200
wird als -1 jetzt angezeigt.

521
00:25:48,200 --> 00:25:49,810
Und es ist immer noch vom Typ int.

522
00:25:49,810 --> 00:25:53,102
>> Und beachten Sie auch meine so genannte
Call-Stack, wo habe ich Pause?

523
00:25:53,102 --> 00:25:54,810
Wir werden mehr darüber reden,
dies in der Zukunft.

524
00:25:54,810 --> 00:25:58,620
Aber der Call-Stack bezieht sich nur auf das, was
Funktionen sind zur Zeit in Bewegung.

525
00:25:58,620 --> 00:26:00,040
Im Moment ist es nur Haupt.

526
00:26:00,040 --> 00:26:03,590
Und gerade jetzt die einzige lokale
Variable mit einem Wert von 1 i.

527
00:26:03,590 --> 00:26:09,840
>> Und wenn ich Schritt schließlich über diese Leitung
hier mit dem gleichen Symbol oben rechts,

528
00:26:09,840 --> 00:26:11,410
-1 Ist eine negative ganze Zahl ist.

529
00:26:11,410 --> 00:26:13,580
Jetzt pausieren es über diese geschweiften Klammer.

530
00:26:13,580 --> 00:26:14,740
Lassen wir es nicht sein Ding.

531
00:26:14,740 --> 00:26:17,300
Ich trete über dieser Linie, und voila.

532
00:26:17,300 --> 00:26:20,240
>> Also gar nicht so schrecklich
erhellend noch,

533
00:26:20,240 --> 00:26:23,550
aber es ließ mich innehalten
und denken durch logisch

534
00:26:23,550 --> 00:26:24,870
was dieses Programm tut.

535
00:26:24,870 --> 00:26:26,890
Aber das war nicht der Fall fehlerhaft.

536
00:26:26,890 --> 00:26:28,510
Lassen Sie uns noch einmal das wie folgt aus.

537
00:26:28,510 --> 00:26:31,340
>> Ich werde diesen Breakpoint zu verlassen
auf der Linie 8 mit dem roten Punkt.

538
00:26:31,340 --> 00:26:32,830
Ich werde debug50 erneut ausführen.

539
00:26:32,830 --> 00:26:34,400
Es wird hier automatisch pausiert.

540
00:26:34,400 --> 00:26:37,660
Aber diesmal anstelle von
stieg über dieser Linie,

541
00:26:37,660 --> 00:26:42,290
Lassen Sie mich gehen tatsächlich in der
get_negative_int und herauszufinden,

542
00:26:42,290 --> 00:26:45,530
warum ist es 0 als eine gültige Antwort zu akzeptieren?

543
00:26:45,530 --> 00:26:47,990
>> Also anstatt zu klicken über Step.

544
00:26:47,990 --> 00:26:50,630
Ich gehe voran gehen
und klicken Sie auf Step Into.

545
00:26:50,630 --> 00:26:54,030
Und feststellen, dass die Linie 8, die ist
jetzt markiert nun plötzlich

546
00:26:54,030 --> 00:26:56,900
wird die Leitung 17.

547
00:26:56,900 --> 00:26:59,947
>> Nun, es ist nicht, dass der Debugger
14 und 15 und 16 übersprungen Linien.

548
00:26:59,947 --> 00:27:01,780
Es ist einfach, es gibt nichts
zeigen Sie es.

549
00:27:01,780 --> 00:27:04,050
Diejenigen deklarieren nur Variablen,
und dann gibt es das Wort tun

550
00:27:04,050 --> 00:27:05,390
und dann eine offene geschweifte Klammer.

551
00:27:05,390 --> 00:27:09,227
Die einzige funktionale Linie, die ist
saftig ist wirklich dieser hier, 17.

552
00:27:09,227 --> 00:27:11,060
Und das ist, wo wir haben
automatisch angehalten.

553
00:27:11,060 --> 00:27:13,870
>> So printf ( "n.is:") ;, so
dass ist noch nicht geschehen.

554
00:27:13,870 --> 00:27:18,250
Also lassen Sie uns fortfahren und klicken Over Schritt.

555
00:27:18,250 --> 00:27:20,326
Jetzt ist meine Aufforderung, in der Tat,
geändert ( "n").

556
00:27:20,326 --> 00:27:22,450
Jetzt get_int, ich werde nicht
zu stören, in Schritt,

557
00:27:22,450 --> 00:27:24,750
weil diese Funktion war
von CS50 in der Bibliothek gemacht.

558
00:27:24,750 --> 00:27:25,750
Es ist vermutlich richtig.

559
00:27:25,750 --> 00:27:28,440
>> Also werde ich voran gehen und
Art zusammenarbeiten, indem sie geben

560
00:27:28,440 --> 00:27:30,590
ein int, aber keine negative int.

561
00:27:30,590 --> 00:27:32,870
Also lassen Sie mich gehen Sie vor und 0 traf.

562
00:27:32,870 --> 00:27:39,460
Und nun, was geschieht hier
wenn ich um 21 zu säumen?

563
00:27:39,460 --> 00:27:40,890
Ich habe nicht noch einmal wiederholt.

564
00:27:40,890 --> 00:27:43,320
Ich scheine nicht in dieser Schleife stecken.

565
00:27:43,320 --> 00:27:45,990
In anderen Worten, diese gelben
Bar nicht halten geht um,

566
00:27:45,990 --> 00:27:47,130
und Umgebung, und Umgebung.

567
00:27:47,130 --> 00:27:48,340
>> Nun, warum ist das so?

568
00:27:48,340 --> 00:27:49,920
Nun, n, was jetzt ist n?

569
00:27:49,920 --> 00:27:53,280
Ich kann auf lokaler aussehen
Variablen im Debugger.

570
00:27:53,280 --> 00:27:53,816
n 0.

571
00:27:53,816 --> 00:27:55,190
Also gut, was war mein Zustand?

572
00:27:55,190 --> 00:27:58,700
>> 20-- Linie 20 ist, na ja,
0 größer als 0 ist.

573
00:27:58,700 --> 00:27:59,500
Das ist nicht wahr.

574
00:27:59,500 --> 00:28:01,020
0 nicht größer als 0 ist.

575
00:28:01,020 --> 00:28:02,820
Und so brach ich dies.

576
00:28:02,820 --> 00:28:06,370
>> Und so ist das, warum auf der Leitung
21, wenn ich tatsächlich fortsetzen,

577
00:28:06,370 --> 00:28:10,370
Ich gehe 0 zurückkehren, auch
obwohl ich sollte 0 abgelehnt

578
00:28:10,370 --> 00:28:12,484
als nicht wirklich negativ.

579
00:28:12,484 --> 00:28:14,650
So, jetzt muss ich nicht wirklich selbst
über den Debugger kümmern.

580
00:28:14,650 --> 00:28:16,900
Habe es, brauche ich nicht zu
wissen, was mehr los ist.

581
00:28:16,900 --> 00:28:19,233
>> Also werde ich voran gehen und
klicken Sie einfach auf die Play-Taste,

582
00:28:19,233 --> 00:28:20,240
und lassen Sie dieses Ziel auf.

583
00:28:20,240 --> 00:28:23,440
Nun, ich habe erkannt, dass mein
Fehler ist offenbar auf der Linie 20.

584
00:28:23,440 --> 00:28:25,160
Das ist meine logische Fehler.

585
00:28:25,160 --> 00:28:28,100
>> Und so was will ich
zu tun, um dies zu ändern?

586
00:28:28,100 --> 00:28:32,500
Wenn das Problem ist, dass ich nicht
0 fangen, es ist nur ein logischer Fehler.

587
00:28:32,500 --> 00:28:35,910
Und ich kann sagen, während n
größer als oder gleich 0,

588
00:28:35,910 --> 00:28:38,330
halten den Anwender immer wieder aufgefordert.

589
00:28:38,330 --> 00:28:41,050
>> Also, noch einmal, einfache Fehler, vielleicht
auch offensichtlich, wenn du mich gesehen hast

590
00:28:41,050 --> 00:28:42,410
schreiben es vor wenigen Minuten.

591
00:28:42,410 --> 00:28:44,570
Aber das Essen zum Mitnehmen hier
ist, dass mit debug 50,

592
00:28:44,570 --> 00:28:46,850
und mit Debugging
Software allgemein

593
00:28:46,850 --> 00:28:51,370
Sie haben diese neu gefundene Macht
Spaziergang durch Ihren eigenen Code, schauen

594
00:28:51,370 --> 00:28:55,590
über diese rechte Platte, was
Ihre Variablen Werte sind.

595
00:28:55,590 --> 00:28:57,700
Sie brauchen also nicht unbedingt
haben etwas zu verwenden,

596
00:28:57,700 --> 00:29:00,630
wie Sie eprintf diese Werte zu drucken.

597
00:29:00,630 --> 00:29:04,430
Sie können sie tatsächlich sehen
visuell auf dem Bildschirm.

598
00:29:04,430 --> 00:29:08,920
>> Nun, darüber hinaus ist es erwähnenswert,
dass es eine andere Technik, die ist

599
00:29:08,920 --> 00:29:09,890
tatsächlich Super üblich.

600
00:29:09,890 --> 00:29:13,120
Und Sie fragen sich vielleicht, warum dieses kleine
Kerl hier hat auf der Bühne gesessen.

601
00:29:13,120 --> 00:29:16,490
Also gibt es diese Technik, in der Regel
bekannt als Gummiente Debugging,

602
00:29:16,490 --> 00:29:18,786
das ist wirklich nur ein
Beweis für die Tatsache,

603
00:29:18,786 --> 00:29:20,660
die oft als Programmierer
sind das Schreiben von Code,

604
00:29:20,660 --> 00:29:22,650
sie sind nicht notwendigerweise
die Zusammenarbeit mit anderen,

605
00:29:22,650 --> 00:29:24,030
oder arbeiten in einer gemeinsamen Umgebung.

606
00:29:24,030 --> 00:29:25,050
>> Sie sind Art von zu Hause.

607
00:29:25,050 --> 00:29:25,910
Vielleicht ist es spät in der Nacht.

608
00:29:25,910 --> 00:29:28,190
Sie versuchen zu Figur
aus einiger Fehler in ihrem Code.

609
00:29:28,190 --> 00:29:29,330
Und sie sind nur sehen es nicht.

610
00:29:29,330 --> 00:29:30,329
>> Und es gibt keinen Mitbewohner.

611
00:29:30,329 --> 00:29:31,250
Es gibt keine TF.

612
00:29:31,250 --> 00:29:32,680
Es gibt keine CA herum.

613
00:29:32,680 --> 00:29:36,440
Alles, was sie auf ihrem Regal haben
ist dieser kleine gummiducky.

614
00:29:36,440 --> 00:29:39,030
>> Und so Gummi-Ente-Debugging
Gerade diese Einladung

615
00:29:39,030 --> 00:29:42,780
an etwas zu denken, wie dumm
da dies als eine echte Kreatur,

616
00:29:42,780 --> 00:29:46,940
und tatsächlich gehen durch den Code
verbal zu diesem leblosen Gegenstand.

617
00:29:46,940 --> 00:29:49,230
So zum Beispiel, wenn
dies ist mein Beispiel hier--

618
00:29:49,230 --> 00:29:52,470
und erinnern daran, dass früher
Das Problem war,

619
00:29:52,470 --> 00:29:58,140
wenn ich diese erste Zeile des Codes zu löschen,
und ich gehe voran und machen Buggy wieder 0,

620
00:29:58,140 --> 00:30:01,220
erinnern, dass ich diese
Fehlermeldungen hier.

621
00:30:01,220 --> 00:30:05,997
So ist die Idee hier, lächerlich, obwohl ich
fühlen im Moment dies öffentlich tun,

622
00:30:05,997 --> 00:30:06,580
ist, dass Fehler.

623
00:30:06,580 --> 00:30:10,910
>> OK, also mein Problem ist, dass ich
eine Bibliotheksfunktion implizit deklariert.

624
00:30:10,910 --> 00:30:12,610
Und das Bibliotheksfunktion ist printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, erklären
erinnert mich an Prototypen.

626
00:30:15,290 --> 00:30:18,930
>> Das heißt, ich muss eigentlich
sagen dem Compiler im Voraus, was

627
00:30:18,930 --> 00:30:19,980
die Funktion aussieht.

628
00:30:19,980 --> 00:30:20,930
Warte eine Minute.

629
00:30:20,930 --> 00:30:23,580
Ich habe nicht Standard io.h

630
00:30:23,580 --> 00:30:24,530
Vielen Dank.

631
00:30:24,530 --> 00:30:27,330
>> So einfach dieser Prozess von-- Sie
brauchen nicht wirklich eine Ente zu haben.

632
00:30:27,330 --> 00:30:29,819
Aber diese Idee des Gehens
Sie sich durch Ihren eigenen Code

633
00:30:29,819 --> 00:30:31,610
so dass man sogar hören
selbst, so dass Sie

634
00:30:31,610 --> 00:30:35,620
realisieren Versäumnisse in der eigenen
bemerkt, ist im Allgemeinen die Idee.

635
00:30:35,620 --> 00:30:38,910
>> Und, vielleicht mehr logisch, nicht so
viel mit, dass man aber die mehr beteiligt

636
00:30:38,910 --> 00:30:44,220
Beispiel wir haben gerade im Buggy 3.c,
Sie könnten sich durch sie hindurchgehen

637
00:30:44,220 --> 00:30:45,310
wie folgt.

638
00:30:45,310 --> 00:30:49,190
Also alles in Ordnung, Gummi
ducky, DDB, wenn man so will.

639
00:30:49,190 --> 00:30:52,350
Hier haben wir in meiner Hauptfunktion haben,
Ich rufe negativ int bekommen.

640
00:30:52,350 --> 00:30:54,660
>> Und ich bin immer der Rückgabewert.

641
00:30:54,660 --> 00:31:00,410
Ich bin zu speichern es auf der linken Seite
auf der Linie 8 in einer Variablen i genannt.

642
00:31:00,410 --> 00:31:02,380
OK, aber warten Sie, wie haben
dass dieser Wert zu erhalten?

643
00:31:02,380 --> 00:31:04,130
Lassen Sie mich 12 an der Funktion in Zeile suchen.

644
00:31:04,130 --> 00:31:05,760
>> In Zeile 12 haben wir negative int bekommen.

645
00:31:05,760 --> 00:31:08,190
Dauert keine Eingänge,
ein int zurückgibt, OK.

646
00:31:08,190 --> 00:31:10,929
Ich erkläre auf der Leitung 14 eine Variable n.

647
00:31:10,929 --> 00:31:12,220
Es wird eine ganze Zahl zu speichern.

648
00:31:12,220 --> 00:31:13,760
Das ist, was ich will.

649
00:31:13,760 --> 00:31:18,480
>> So gehen Sie wie folgt, während n ist-- lassen
mich rückgängig zu machen, was das Update ich schon gemacht.

650
00:31:18,480 --> 00:31:22,710
Während also n größer als
0, ausdrucken n, OK.

651
00:31:22,710 --> 00:31:25,170
Und dann rufen int n gespeichert zu bekommen.

652
00:31:25,170 --> 00:31:30,160
Und dann prüfen, ob n 0,
n ist nicht-- da ist es.

653
00:31:30,160 --> 00:31:31,910
Also, noch einmal, nicht wahr
müssen die tatsächlichen Ente.

654
00:31:31,910 --> 00:31:35,650
Aber gehen Sie sich einfach durch
Ihr Code als eine intellektuelle Übung

655
00:31:35,650 --> 00:31:37,720
wird Ihnen helfen, oft
erkennen, was los ist,

656
00:31:37,720 --> 00:31:41,170
im Gegensatz zu nur etwas zu tun
wie diese, starrte auf den Bildschirm,

657
00:31:41,170 --> 00:31:43,720
und sprechen Sie sich nicht durch
es, die nicht ehrlich ist

658
00:31:43,720 --> 00:31:46,270
fast als eine effektive Technik.

659
00:31:46,270 --> 00:31:48,620
So dort haben Sie es, ein
Anzahl verschiedener Techniken

660
00:31:48,620 --> 00:31:52,102
für tatsächlich Code Debugging
und Fehler zu finden, von denen alle

661
00:31:52,102 --> 00:31:54,810
sollten Werkzeuge in Ihrem Toolkit sein
so dass Sie nicht spät in der Nacht sind,

662
00:31:54,810 --> 00:31:57,660
vor allem sind Sie im Speise
Hallen oder bei Bürozeiten,

663
00:31:57,660 --> 00:32:00,368
hämmern Ihren Kopf gegen die
Wand und versuchte, ein Problem zu lösen.

664
00:32:00,368 --> 00:32:02,020
Erkenne, dass es Software-Tools.

665
00:32:02,020 --> 00:32:03,720
Es gibt Gummi-Ente-Tools.

666
00:32:03,720 --> 00:32:09,630
Und es gibt eine ganze Personal von
Unterstützung warten, um eine Hand zu leihen.

667
00:32:09,630 --> 00:32:13,120
>> So, jetzt, ein Wort, auf das Problem
Sets, und auf das, was wir Sie hoffen,

668
00:32:13,120 --> 00:32:15,620
aus ihnen herausholen, und wie
gehen wir über zu bewerten.

669
00:32:15,620 --> 00:32:17,680
Per den Kurs des Lehrplans,
CS50 das Problem Sets

670
00:32:17,680 --> 00:32:22,320
so sind auf vier Hauptachsen ausgewertet,
zu speak-- Umfang, Korrektheit, Design,

671
00:32:22,320 --> 00:32:23,060
und Stil.

672
00:32:23,060 --> 00:32:25,910
Und Bereich bezieht sich nur darauf, wie viel
des Stückes haben abgebissen Sie?

673
00:32:25,910 --> 00:32:28,080
Wie viel von einem Problem haben Sie versucht?

674
00:32:28,080 --> 00:32:30,110
Welches Maß an Aufwand
haben Sie manifestiert?

675
00:32:30,110 --> 00:32:35,750
>> Correctness ist, funktioniert das Programm als
es ist zu pro CS50 Spezifikation soll

676
00:32:35,750 --> 00:32:38,640
wenn Sie bestimmte Eingaben liefern
oder bestimmte Ausgänge wieder?

677
00:32:38,640 --> 00:32:41,130
Design ist die subjektive von ihnen.

678
00:32:41,130 --> 00:32:43,360
Und es ist das eine, die
nehmen Sie die längste lernen

679
00:32:43,360 --> 00:32:47,220
und die längste zu lehren, in
soweit sie nach unten läuft darauf hinaus,,

680
00:32:47,220 --> 00:32:49,530
wie gut geschrieben ist Ihr Code?

681
00:32:49,530 --> 00:32:52,920
>> Es ist eine Sache zu drucken nur die richtige
Ausgänge oder die richtigen Werte zurückgeben.

682
00:32:52,920 --> 00:32:55,400
Aber tun Sie es als
effizient wie möglich?

683
00:32:55,400 --> 00:32:58,210
Tun Sie es divide
und zu erobern, oder binäre

684
00:32:58,210 --> 00:33:01,500
Suche, wie wir bald sehen, dass wir das gemacht haben
vor zwei Wochen mit dem Telefonbuch?

685
00:33:01,500 --> 00:33:04,670
Gibt es bessere Möglichkeiten zur Lösung des
Problem, als Sie sich hier haben?

686
00:33:04,670 --> 00:33:06,380
Das ist eine Chance für besseres Design.

687
00:33:06,380 --> 00:33:08,530
>> Und dann style-- wie
hübsch ist der Code?

688
00:33:08,530 --> 00:33:12,370
Sie werden bemerken, dass ich bin ziemlich
insbesondere über meinen Code einrücken,

689
00:33:12,370 --> 00:33:15,300
und sicherstellen, dass meine Variablen
sind vernünftig genannt. n,

690
00:33:15,300 --> 00:33:19,660
kurze Zeit, ist ein guter Name für ein
Nummer, i für eine Zählung ganze Zahl,

691
00:33:19,660 --> 00:33:20,727
s für einen String.

692
00:33:20,727 --> 00:33:22,560
Und wir können mehr haben
Variablennamen Stil.

693
00:33:22,560 --> 00:33:25,500
Der Stil ist, wie gut
sieht Ihr Code aussehen?

694
00:33:25,500 --> 00:33:26,600
Und wie lesbar ist es?

695
00:33:26,600 --> 00:33:29,650
>> Und im Laufe der Zeit, was Ihre TAs
und TFs werden im Laufe tun

696
00:33:29,650 --> 00:33:31,870
mit, dass wird Ihnen zur Verfügung stellen
Art qualitative Feedback

697
00:33:31,870 --> 00:33:34,330
so dass Sie besser werden
bei diesen verschiedenen Aspekten.

698
00:33:34,330 --> 00:33:37,510
Und in Bezug darauf, wie wir
evaluieren jede dieser Achsen,

699
00:33:37,510 --> 00:33:40,080
es ist in der Regel mit sehr wenigen
Eimer, so dass Sie, in der Regel,

700
00:33:40,080 --> 00:33:41,680
bekommen ein Gefühl dafür, wie gut du bist zu tun.

701
00:33:41,680 --> 00:33:45,680
Und in der Tat, wenn Sie erhalten eine Punktzahl auf
jede von diesen axes-- Korrektheit, Design

702
00:33:45,680 --> 00:33:49,659
und Stil especially-- diese Zahl
wird in der Regel zwischen 1 und 5 sein.

703
00:33:49,659 --> 00:33:52,450
Und wörtlich, wenn Sie bekommen
3 ist zu Beginn des Semesters,

704
00:33:52,450 --> 00:33:53,977
das ist eine sehr gute Sache.

705
00:33:53,977 --> 00:33:55,810
Es bedeutet, dass es immer noch
Raum für Verbesserung,

706
00:33:55,810 --> 00:33:58,490
was würden Sie hoffen in
eine Klasse zum ersten Mal statt.

707
00:33:58,490 --> 00:34:01,820
Es gibt hoffentlich einige bisschen Decke
zu denen sind aufstrebende Sie zu erreichen.

708
00:34:01,820 --> 00:34:03,970
Und so 3 ist auf immer
die frühesten Stücke,

709
00:34:03,970 --> 00:34:06,550
wenn nicht einige 2er und 4er,
eine gute Sache ist in der Tat.

710
00:34:06,550 --> 00:34:08,880
Es ist gut innerhalb der Reichweite,
auch im Rahmen der Erwartungen.

711
00:34:08,880 --> 00:34:11,421
>> Und wenn Ihr Geist Rennen ist, warten
eine Minute, drei von fünf.

712
00:34:11,421 --> 00:34:12,620
Das ist wirklich ein 6 von 10.

713
00:34:12,620 --> 00:34:13,560
Das ist 60%.

714
00:34:13,560 --> 00:34:14,830
Mein Gott, das ein F. ist

715
00:34:14,830 --> 00:34:15,870
>> Es ist nicht.

716
00:34:15,870 --> 00:34:17,600
Es ist in der Tat nicht, dass.

717
00:34:17,600 --> 00:34:22,710
Es ist vielmehr eine Gelegenheit zur Verbesserung der
im Laufe des Semesters.

718
00:34:22,710 --> 00:34:25,580
Und wenn Sie bekommen einige
Poors, diese sind eine Chance

719
00:34:25,580 --> 00:34:29,199
um die Vorteile der Bürozeiten,
sicherlich Abschnitte und andere Ressourcen.

720
00:34:29,199 --> 00:34:32,840
>> Am besten ist es eine Chance, wirklich,
zu sein, nur stolz darauf, wie weit Sie haben

721
00:34:32,840 --> 00:34:34,520
kommen im Laufe des Semesters.

722
00:34:34,520 --> 00:34:38,199
Also erkennen, wenn nichts
sonst ist drei gut.

723
00:34:38,199 --> 00:34:40,179
Und es lässt Raum für das Wachstum im Laufe der Zeit.

724
00:34:40,179 --> 00:34:43,090
>> Was, wie diese Achsen
gewichtet, realistisch sind Sie

725
00:34:43,090 --> 00:34:46,745
werde die meiste Zeit verbringen bekommen
Dinge zu arbeiten, geschweige denn richtig lassen.

726
00:34:46,745 --> 00:34:49,120
Und so neigt Korrektheit
werden, um die meisten gewichtet, wie mit

727
00:34:49,120 --> 00:34:51,360
Diese multiplikative Faktor drei.

728
00:34:51,360 --> 00:34:54,659
Design ist auch wichtig, aber
etwas, das man nicht unbedingt tun

729
00:34:54,659 --> 00:34:58,220
alle diese Stunden verbringen
versuchen, die Dinge zu bekommen einfach zu arbeiten.

730
00:34:58,220 --> 00:35:00,019
>> Und so ist es gewichtet
ein wenig leichter.

731
00:35:00,019 --> 00:35:01,560
Und dann ist Stil die am wenigsten gewichtet.

732
00:35:01,560 --> 00:35:03,710
Auch wenn es nicht weniger
wichtig grundlegend,

733
00:35:03,710 --> 00:35:05,990
es ist nur vielleicht die
einfachste Sache zu tun rechts,

734
00:35:05,990 --> 00:35:08,440
Nachahmung der Beispiele, die wir
tun in Vortrag und Abschnitt,

735
00:35:08,440 --> 00:35:11,080
mit Dingen schön
gegliederte und kommentierte:

736
00:35:11,080 --> 00:35:14,320
und so ist weiter zu den einfachsten
Dinge zu tun und richtig zu machen.

737
00:35:14,320 --> 00:35:16,960
So als solche erkennen
dass diejenigen, sind Punkte

738
00:35:16,960 --> 00:35:19,000
Das sind relativ leicht zu fassen.

739
00:35:19,000 --> 00:35:22,360
>> Und nun ein Wort auf
this-- akademische Ehrlichkeit.

740
00:35:22,360 --> 00:35:25,150
Also pro Laufe des
Lehrplan, werden Sie sehen,

741
00:35:25,150 --> 00:35:27,630
dass der Kurs hat eine ganze
Bit von Sprache, um dieses.

742
00:35:27,630 --> 00:35:31,380
Und der Kurs nimmt das Thema
akademische Ehrlichkeit ganz ernst.

743
00:35:31,380 --> 00:35:33,450
>> Wir haben die Auszeichnung,
zum Besseren oder zum Schlechteren,

744
00:35:33,450 --> 00:35:36,570
zu haben jedes Jahr mehr gesendet
Studenten für Disziplinarmaßnahmen

745
00:35:36,570 --> 00:35:39,670
als die meisten anderen
Natürlich, das ist mir bewusst.

746
00:35:39,670 --> 00:35:42,580
Dies ist nicht unbedingt
indikativ für die Tatsache

747
00:35:42,580 --> 00:35:46,340
dass CS Studenten oder CS50 Studenten sind
nicht weniger ehrlich als Ihre Mitschüler.

748
00:35:46,340 --> 00:35:49,090
Aber die Realität, dass in diesem
Welt, elektronisch, wir haben nur

749
00:35:49,090 --> 00:35:50,990
haben technologische
bedeutet dies zu erfassen.

750
00:35:50,990 --> 00:35:53,360
>> Es ist uns wichtig, dass
Fairness in der Klasse

751
00:35:53,360 --> 00:35:58,550
dass wir dies tun erkennen und heben
das Problem, wenn wir Dinge sehen.

752
00:35:58,550 --> 00:36:01,980
Und nur ein Bild zu malen, und wirklich
so etwas wie dieses Waschbecken zu helfen, in,

753
00:36:01,980 --> 00:36:04,600
dies sind die Anzahlen von
Studenten in den letzten 10 Jahren

754
00:36:04,600 --> 00:36:07,610
die in einigen beteiligt waren
solche Fragen der akademischen Ehrlichkeit,

755
00:36:07,610 --> 00:36:10,990
mit rund 32 Studenten
ab Herbst 2015 die

756
00:36:10,990 --> 00:36:13,760
ist zu sagen, dass wir nehmen Sie
die Sache sehr ernst.

757
00:36:13,760 --> 00:36:18,380
Und schließlich diese Zahlen zusammensetzen,
kürzlich höchstens etwa 3%, 4% oder so

758
00:36:18,380 --> 00:36:19,120
der Klasse.

759
00:36:19,120 --> 00:36:25,220
>> Also für die super Mehrheit der Studenten
es scheint, dass die Linien sind klar.

760
00:36:25,220 --> 00:36:27,940
Aber halten diese in
dagegen, besonders spät

761
00:36:27,940 --> 00:36:32,080
in der Nacht, wenn kämpfen mit
einige Lösung für ein Problem-Set,

762
00:36:32,080 --> 00:36:34,830
Mechanismen, dass es
für immer selbst besser

763
00:36:34,830 --> 00:36:37,870
Unterstützung als Sie vielleicht
denken, auch jener Stunde an.

764
00:36:37,870 --> 00:36:40,514
Erkenne, dass, wenn wir erhalten
Schüler Einreichungen, wir überqueren

765
00:36:40,514 --> 00:36:43,430
jede Vorlage vergleichen in diesem Jahr
gegen jede Vorlage im letzten Jahr,

766
00:36:43,430 --> 00:36:47,590
gegen jede Vorlage aus dem Jahr 2007,
und da, mit Blick auf, als auch,

767
00:36:47,590 --> 00:36:49,931
Code-Repositories online,
Diskussionsforen, Baustellen.

768
00:36:49,931 --> 00:36:51,806
Und wir nennen dies,
wirklich alle im Interesse,

769
00:36:51,806 --> 00:36:56,040
einer vollständigen Offenlegung, dass, wenn
jemand anderes kann es online zu finden,

770
00:36:56,040 --> 00:36:57,880
Sicherlich kann, so dass wir den Kurs.

771
00:36:57,880 --> 00:37:00,100
Aber wirklich, der Geist
der Kurs läuft darauf hinaus,

772
00:37:00,100 --> 00:37:01,650
in den Lehrplan zu dieser Klausel.

773
00:37:01,650 --> 00:37:03,670
Es ist wirklich nur, angemessen sein.

774
00:37:03,670 --> 00:37:06,680
>> Und wenn wir mussten sorgfältig ausarbeiten, dass
mit nur ein bisschen mehr Sprache,

775
00:37:06,680 --> 00:37:09,770
erkennen, dass die Essenz aller
Arbeit, die Sie zu diesem Kurs einreichen

776
00:37:09,770 --> 00:37:10,954
müssen selbst sein.

777
00:37:10,954 --> 00:37:13,870
Aber innerhalb dieser gibt es sicherlich
Chancen und Ermutigung,

778
00:37:13,870 --> 00:37:17,300
und pädagogischen Wert beim Drehen zu
Andere-- mich, die TFs, die CAs,

779
00:37:17,300 --> 00:37:20,760
Tas, und andere in der Klasse,
für die Unterstützung, geschweige denn Freunde

780
00:37:20,760 --> 00:37:23,547
und Mitbewohner, die studiert haben,
CS und vor der Programmierung.

781
00:37:23,547 --> 00:37:25,130
Und so gibt es eine Zulage dafür.

782
00:37:25,130 --> 00:37:28,180
Und die allgemeine Faustregel gilt:
this-- wird, wenn um Hilfe zu bitten,

783
00:37:28,180 --> 00:37:31,470
Sie können Ihren Code zu anderen zu zeigen,
Sie können jedoch sehen ihre nicht.

784
00:37:31,470 --> 00:37:34,880
Also selbst wenn Sie im Büro Stunden sind,
oder in der D-Halle, oder irgendwo anders

785
00:37:34,880 --> 00:37:37,450
Arbeiten an einem gewissen Stück-Set,
In Zusammenarbeit mit einem Freund, der

786
00:37:37,450 --> 00:37:40,160
bei der ist völlig in Ordnung,
Ende des Tages Ihre Arbeit

787
00:37:40,160 --> 00:37:43,034
sollte letztlich zu jeder gehören
von euch sind, und nicht

788
00:37:43,034 --> 00:37:45,700
sein, einige gemeinsame Anstrengung,
Ausnahme des letzten Projekt, bei dem

789
00:37:45,700 --> 00:37:47,410
es ist erlaubt und erwünscht.

790
00:37:47,410 --> 00:37:49,830
>> Erkenne, dass, wenn Sie
kämpfen mit etwas

791
00:37:49,830 --> 00:37:52,520
und Ihr Freund gerade passiert,
um besser auf diese dann Sie,

792
00:37:52,520 --> 00:37:55,130
oder besser zu diesem Problem, als Sie,
oder ein wenig weiter vor, als Sie,

793
00:37:55,130 --> 00:37:57,330
es ist völlig vernünftig zu drehen
Ihrem Freund und sagen, hey,

794
00:37:57,330 --> 00:38:00,480
Haben Sie etwas dagegen hier bei meinem Code suchen,
mir zu helfen vor Ort, was mein Problem ist?

795
00:38:00,480 --> 00:38:03,760
Und hoffentlich in der
Interesse der pädagogischen Wert

796
00:38:03,760 --> 00:38:07,040
dass Freund nicht nur
sagen, oh, dies zu tun, sondern vielmehr,

797
00:38:07,040 --> 00:38:09,917
was sind Sie nicht auf Linie
6, oder so etwas?

798
00:38:09,917 --> 00:38:12,000
Aber die Lösung ist nicht
für den Freund neben dir

799
00:38:12,000 --> 00:38:15,617
zu sagen, oh, na ja, hier, lassen Sie mich ziehen
dies auf und zeigen meine Lösung für Sie.

800
00:38:15,617 --> 00:38:16,450
Damit ist die Linie.

801
00:38:16,450 --> 00:38:18,670
Sie zeigen Ihren Code
andere, aber Sie können nicht

802
00:38:18,670 --> 00:38:22,350
sehen ihre vorbehaltlich der anderen
Einschränkungen in den Lehrplan des Kurses.

803
00:38:22,350 --> 00:38:24,760
>> Also denken Sie daran, diese
so genannte Bedauern Klausel

804
00:38:24,760 --> 00:38:27,560
in den Lehrplan der natürlich auch,
dass, wenn Sie etwas Handlung begehen, die

805
00:38:27,560 --> 00:38:30,476
nicht sinnvoll ist, aber es bringen
die Aufmerksamkeit der Köpfe der Kurs

806
00:38:30,476 --> 00:38:34,240
innerhalb von 72 Stunden, der Kurs
können lokale Sanktionen aufzuerlegen,

807
00:38:34,240 --> 00:38:37,380
kann eine unbefriedigende umfassen oder
andernfalls Note für die Arbeit vorgelegt.

808
00:38:37,380 --> 00:38:41,410
Aber der Kurs wird nicht verweisen die
Rolle für die weitere Disziplinarmaßnahmen,

809
00:38:41,410 --> 00:38:43,010
außer in Fällen von wiederholten Handlungen.

810
00:38:43,010 --> 00:38:46,632
Mit anderen Worten, wenn Sie das tun machen einige
dumm, vor allem spät in der Nacht, Entscheidung

811
00:38:46,632 --> 00:38:49,340
dass am nächsten Morgen bis zwei Tage
später, Sie aufwachen und erkennen,

812
00:38:49,340 --> 00:38:50,870
was ich dachte?

813
00:38:50,870 --> 00:38:53,890
Sie tun in CS50 haben einen Auslass
für die Festsetzung dieses Problem

814
00:38:53,890 --> 00:38:57,170
und besitzen, um es nach oben, so dass wir
treffen Sie auf halber Strecke und beschäftigen

815
00:38:57,170 --> 00:39:01,500
mit ihm in einer Angelegenheit, die sowohl
Bildungs- und wertvoll für Sie,

816
00:39:01,500 --> 00:39:04,200
aber immer noch in irgendeiner Weise Straf.

817
00:39:04,200 --> 00:39:08,590
Und nun, nehmen den Rand dieses.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO-WIEDERGABE]

819
00:39:10,570 --> 00:39:13,540
>> [MUSIK SPIELEN]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END WIEDERGABE]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN: Okay, sind wir zurück.

823
00:40:00,490 --> 00:40:03,680
Und jetzt schauen wir auf eine der
erste unserer realen Welt Domains

824
00:40:03,680 --> 00:40:08,720
in CS50, die Kunst der Kryptographie,
die Kunst des Sendens und Empfangens

825
00:40:08,720 --> 00:40:11,840
geheime Nachrichten, verschlüsselte
Nachrichten, wenn man so will,

826
00:40:11,840 --> 00:40:17,060
das kann nur entschlüsselt werden, wenn Sie
einige wichtige Zutat, dass der Absender hat

827
00:40:17,060 --> 00:40:18,030
als auch.

828
00:40:18,030 --> 00:40:22,120
Also diese zu motivieren, wir nehmen
ein Blick hier auf dieser Sache,

829
00:40:22,120 --> 00:40:26,750
Das ist ein Beispiel für eine
Geheimnis Decoder Ring,

830
00:40:26,750 --> 00:40:34,042
um herauszufinden, kann verwendet werden, um
was eigentlich eine geheime Nachricht ist.

831
00:40:34,042 --> 00:40:35,750
In der Tat zurück in die
Tag in der Grundschule,

832
00:40:35,750 --> 00:40:38,787
wenn Sie jemals gesendet geheime Botschaften an
ein Freund oder ein Gedränge in der Klasse,

833
00:40:38,787 --> 00:40:40,620
Sie könnten gedacht haben,
Sie waren clever

834
00:40:40,620 --> 00:40:46,530
indem Sie auf Ihr Stück Papier Wechsel,
wie A zu B und B zu C und von C zu D,

835
00:40:46,530 --> 00:40:47,590
und so weiter.

836
00:40:47,590 --> 00:40:50,300
Aber Sie waren eigentlich die Verschlüsselung
Ihre Informationen, auch

837
00:40:50,300 --> 00:40:53,300
wenn es ein wenig trivial war, war nicht
so schwer für die Lehrer zu realisieren,

838
00:40:53,300 --> 00:40:55,675
gut, wenn Sie nur ändern
B zu A und C an B,

839
00:40:55,675 --> 00:40:57,550
Sie heraus tatsächlich aus
was war die Botschaft,

840
00:40:57,550 --> 00:40:59,700
aber sie waren in Informationen Chiffrierung.

841
00:40:59,700 --> 00:41:03,420
>> Sie taten es einfach
einfach, ähnlich wie Ralphie hier

842
00:41:03,420 --> 00:41:07,934
in einem berühmten Film spielt
jeden Winter ziemlich viel bis zum Überdruss.

843
00:41:07,934 --> 00:41:08,600
[VIDEO-WIEDERGABE]

844
00:41:08,600 --> 00:41:11,180
-Stellen Sie es auf alles, was bekannt
Ralph Parker ist hiermit

845
00:41:11,180 --> 00:41:14,070
ein Mitglied des Kleinen ernannt
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
und ist mit allen Ehren berechtigt
und Nutzen auftretenden dazu.

847
00:41:17,700 --> 00:41:24,340
>> Signierten, Little Orphan Annie,
Gegen unterzeichnet Pierre Andre, in der Tinte.

848
00:41:24,340 --> 00:41:27,160
Ehrungen und Vorteile,
bereits im Alter von neun.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [SCHREIEN]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Komm schon.

853
00:41:34,250 --> 00:41:35,210
Lassen Sie uns mit ihm auszukommen.

854
00:41:35,210 --> 00:41:39,530
Ich brauche nicht alle, die Jazz
über Schmuggler und Piraten.

855
00:41:39,530 --> 00:41:41,660
>> -listen Morgen Abend für
die abschließende Abenteuer

856
00:41:41,660 --> 00:41:43,880
des schwarzen Piratenschiff.

857
00:41:43,880 --> 00:41:46,650
Nun, es ist Zeit für
Annie geheime Botschaft

858
00:41:46,650 --> 00:41:49,840
Sie Mitglieder des Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Denken Sie daran, Kinder, nur für Mitglieder
von Annie Secret Circle

860
00:41:53,570 --> 00:41:56,140
Annie geheime Nachricht entschlüsseln kann.

861
00:41:56,140 --> 00:42:00,340
>> Denken Sie daran, Annie ist abhängig von Ihnen.

862
00:42:00,340 --> 00:42:02,880
Stellen Sie Ihre Stifte B2.

863
00:42:02,880 --> 00:42:05,230
Hier ist die Botschaft.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Ich Bin in meinen ersten geheimen Treffen.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre War in großer Stimme heute Abend.

868
00:42:15,780 --> 00:42:19,000
Ich könnte das heute Abend sagen
Nachricht war wirklich wichtig.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, ist, dass eine Nachricht
von Annie selbst.

870
00:42:22,694 --> 00:42:23,860
Denken Sie daran, nicht weitersagen.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekunden später, ich bin in der einzigen
Zimmer im Haus, wo ein Junge von neun

873
00:42:32,930 --> 00:42:37,040
könnte in die Privatsphäre und dekodieren sitzen.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Ich ging in die nächste, E.

876
00:42:42,360 --> 00:42:44,520
>> Das erste Wort ist sein.

877
00:42:44,520 --> 00:42:49,032
S, wurde es jetzt leichter kommen, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Ach, komm, Ralphie, ich muss gehen!

879
00:42:51,733 --> 00:42:53,688
>> -Ich Werde gleich unten, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee Whiz!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, achten Sie darauf, was zu-- sicher sein?

883
00:43:04,060 --> 00:43:05,970
Was war Little Orphan
Annie versucht zu sagen?

884
00:43:05,970 --> 00:43:07,264
Achten Sie darauf, was?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie Hat Andy bekam
gehen, werden Sie bitte herauskommen?

886
00:43:09,634 --> 00:43:10,480
>> -Alle Recht, Ma!

887
00:43:10,480 --> 00:43:12,880
Ich komme bald aus sein!

888
00:43:12,880 --> 00:43:14,550
>> -I Wurde jetzt immer näher.

889
00:43:14,550 --> 00:43:16,620
Die Spannung war schrecklich.

890
00:43:16,620 --> 00:43:17,720
Was war es?

891
00:43:17,720 --> 00:43:20,170
Das Schicksal des Planeten
kann in der Schwebe.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy gotta go!

894
00:43:23,170 --> 00:43:26,890
>> -Ich Werde direkt aus sein, für crying out loud!

895
00:43:26,890 --> 00:43:32,680
>> -fast Da, meine Finger flogen, mein Geist
eine Stahlfalle war, vibrierte jede Pore.

896
00:43:32,680 --> 00:43:37,198
Es war fast klar, ja, ja, ja.

897
00:43:37,198 --> 00:43:43,091
>> -Stellen Sie sicher, dass Ihr ovaltine zu trinken.

898
00:43:43,091 --> 00:43:43,590
Ovomaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Eine miese Handels?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Hurensohn.

903
00:43:54,227 --> 00:43:54,810
[END WIEDERGABE]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN: OK, so
das war ein sehr langer Weg

905
00:43:57,390 --> 00:44:00,660
der Einführung der Kryptographie,
und auch Ovomaltine.

906
00:44:00,660 --> 00:44:04,470
In der Tat, von diesem alten Anzeige
hier, warum ist ovaltine so gut?

907
00:44:04,470 --> 00:44:09,470
Es ist eine konzentrierte Extraktion von reifen
Gerstenmalz, rein sahnig Kuhmilch,

908
00:44:09,470 --> 00:44:14,360
und besonders zubereitet Kakao, zusammen
mit natürlichen Phosphatiden und Vitamine.

909
00:44:14,360 --> 00:44:18,240
Es wird weiter verstärkt durch
zusätzliche Vitamine B und D, yum.

910
00:44:18,240 --> 00:44:21,600
Und Sie können es immer noch bekommen, offenbar,
wie wir auf Amazon, tat hier.

911
00:44:21,600 --> 00:44:24,810
>> Aber die Motivation war hier zu
Einführung Kryptographie, insbesondere

912
00:44:24,810 --> 00:44:28,340
eine Art von Kryptographie bekannt
als geheimen Schlüssel Kryptographie.

913
00:44:28,340 --> 00:44:34,284
Und wie der Name schon sagt, die ganze
Sicherheit eines geheimen Schlüssels Krypto-System,

914
00:44:34,284 --> 00:44:36,200
wenn man so will, eine Methodik
für nur Scrambling

915
00:44:36,200 --> 00:44:40,960
Informationen zwischen zwei Menschen ist, dass
nur der Sender und der Empfänger nur

916
00:44:40,960 --> 00:44:46,980
Kennen Sie ein Geheimnis key-- einen gewissen Wert, einige
geheime Phrase, eine geheime Zahl, dass

917
00:44:46,980 --> 00:44:50,660
ermöglicht es ihnen, der zum Verschlüsseln
und Entschlüsseln von Informationen.

918
00:44:50,660 --> 00:44:53,470
Und Kryptographie, wirklich,
ist gerade von dieser Woche 0.

919
00:44:53,470 --> 00:44:56,715
>> Es ist ein Problem, wo es Eingänge ist,
wie die eigentliche Nachricht in Englisch

920
00:44:56,715 --> 00:44:59,340
oder was auch immer die Sprache, die Sie
will jemand in der Klasse zu schicken,

921
00:44:59,340 --> 00:45:00,580
oder über das Internet.

922
00:45:00,580 --> 00:45:03,840
Es gibt einige Ausgang, der gehen wird
das verschlüsselte Nachricht zu sein, dass Sie

923
00:45:03,840 --> 00:45:05,250
wollen, dass der Empfänger zu empfangen.

924
00:45:05,250 --> 00:45:07,405
Und selbst wenn jemand in der
Mitte empfängt es auch,

925
00:45:07,405 --> 00:45:09,780
Sie wollen sie nicht zu
unbedingt in der Lage sein, es zu entschlüsseln,

926
00:45:09,780 --> 00:45:12,840
da Innere dieser
Black-Box oder Algorithmus,

927
00:45:12,840 --> 00:45:17,650
ein Mechanismus ist, teilweise Schritt für Schritt
Anweisungen für diese Eingabe unter

928
00:45:17,650 --> 00:45:20,710
und Umwandlung in das
Ausgabe, in hoffentlich eine sichere Art und Weise.

929
00:45:20,710 --> 00:45:23,640
>> Und, in der Tat gibt es einige
Vokabular in dieser Welt wie folgt.

930
00:45:23,640 --> 00:45:26,100
Plain Text ist das Wort ein
Informatiker würde

931
00:45:26,100 --> 00:45:28,449
verwenden, um die Eingabe zu beschreiben
Nachricht, wie die englische

932
00:45:28,449 --> 00:45:31,240
oder was auch immer Sprache, die Sie tatsächlich
wollen einige andere Mensch zu senden.

933
00:45:31,240 --> 00:45:35,450
Und dann ist der verschlüsselte Text das Gerangel
auf die verschlüsselten oder verschlüsselten,

934
00:45:35,450 --> 00:45:36,520
davon Version.

935
00:45:36,520 --> 00:45:38,750
>> Aber es gibt eine andere Zutat hier.

936
00:45:38,750 --> 00:45:43,200
Es gibt einen anderen Eingang zu
geheimen Schlüssel Kryptographie.

937
00:45:43,200 --> 00:45:45,200
Und das ist der Schlüssel selbst,
die ist, in der Regel,

938
00:45:45,200 --> 00:45:48,930
wie wir sehen werden, eine Zahl oder
Brief oder Wort, was auch immer

939
00:45:48,930 --> 00:45:51,980
der Algorithmus ist es erwartet, tatsächlich.

940
00:45:51,980 --> 00:45:53,870
>> Und wie entschlüsseln Sie Informationen?

941
00:45:53,870 --> 00:45:55,110
Wie entwirren Sie es?

942
00:45:55,110 --> 00:45:57,950
Nun, Sie umkehren nur die
Ausgängen und den Eingängen.

943
00:45:57,950 --> 00:46:00,900
>> Mit anderen Worten, wenn jemand
empfängt Ihre verschlüsselte Nachricht,

944
00:46:00,900 --> 00:46:03,740
er oder sie hat einfach
den gleichen Schlüssel zu kennen.

945
00:46:03,740 --> 00:46:05,700
Sie haben den Chiffretext empfangen.

946
00:46:05,700 --> 00:46:09,530
Und von diesen beiden Aufstecken
Eingaben in das Krypto-System,

947
00:46:09,530 --> 00:46:14,260
der Algorithmus, diese Blackbox, aus
sollte den ursprünglichen Klartext kommen.

948
00:46:14,260 --> 00:46:17,830
Und so ist, dass die sehr hohen Niveau
Anbetracht dessen, was Kryptographie ist eigentlich

949
00:46:17,830 --> 00:46:18,590
alles über.

950
00:46:18,590 --> 00:46:20,030
>> Also lassen Sie uns dort.

951
00:46:20,030 --> 00:46:22,700
Lassen Sie uns jetzt unter aussehen
die Motorhaube etwas

952
00:46:22,700 --> 00:46:26,000
wir haben für selbstverständlich für
Vergangene Woche, und für diese Sitzung

953
00:46:26,000 --> 00:46:27,629
hier-- die Zeichenfolge.

954
00:46:27,629 --> 00:46:30,295
Ein String am Ende des Tages
ist nur eine Folge von Zeichen.

955
00:46:30,295 --> 00:46:33,610
>> Es könnte Hallo Welt sein, oder
hallo Zamyla, oder was auch immer.

956
00:46:33,610 --> 00:46:37,050
Aber was bedeutet das für
eine Folge von Zeichen?

957
00:46:37,050 --> 00:46:41,520
In der Tat gibt der Bibliothek CS50
uns einen Datentyp namens String.

958
00:46:41,520 --> 00:46:45,140
>> Aber es gibt eigentlich keine
so etwas wie eine Saite in C.

959
00:46:45,140 --> 00:46:49,450
Es ist wirklich nur eine Folge von
Zeichen, Zeichen, Zeichen,

960
00:46:49,450 --> 00:46:52,180
Charakter, Rücken an Rücken, zu
Rücken an Rücken, innen nach hinten

961
00:46:52,180 --> 00:46:54,650
der Speicher des Computers oder RAM.

962
00:46:54,650 --> 00:46:58,940
Und wir werden in der in diesem Blick tiefer
Zukunft, wenn wir in Erinnerung schauen selbst,

963
00:46:58,940 --> 00:47:02,030
und die Verwendung und die
Bedrohungen, die beteiligt sind.

964
00:47:02,030 --> 00:47:04,100
>> Aber lassen Sie uns die Zeichenfolge Zamyla betrachten.

965
00:47:04,100 --> 00:47:07,480
Also nur der Name
der Mensch hier, Zamyla,

966
00:47:07,480 --> 00:47:12,030
das ist eine Folge von
Zeichen, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Und nun lassen Sie uns annehmen, dass Zamyla Namen
wird innerhalb eines Computers gespeichert

968
00:47:16,020 --> 00:47:16,880
Programm.

969
00:47:16,880 --> 00:47:20,830
>> Nun, liegt es nahe, dass wir sollten
der Lage sein, auf diese Zeichen zu suchen

970
00:47:20,830 --> 00:47:21,590
individuell.

971
00:47:21,590 --> 00:47:24,710
Also werde ich nur ein wenig zu ziehen
hier um Zamyla Namen boxen.

972
00:47:24,710 --> 00:47:31,580
Und es ist der Fall, in C, dass Sie, wenn
habe eine Zeichenfolge, wie Zamyla-- und vielleicht

973
00:47:31,580 --> 00:47:34,940
dass String zurück gekommen aus
eine Funktion wie get string,

974
00:47:34,940 --> 00:47:38,540
Sie können tatsächlich manipulieren
es Zeichen für Zeichen.

975
00:47:38,540 --> 00:47:42,070
>> Nun, dies ist Germane für die
Gespräch zur Hand, denn

976
00:47:42,070 --> 00:47:46,420
wenn Sie in der Kryptographie ändern möchten
A zu B und B zu C und von C zu D,

977
00:47:46,420 --> 00:47:49,650
und so weiter, müssen Sie in der Lage zu sein,
an den einzelnen Zeichen zu suchen

978
00:47:49,650 --> 00:47:50,190
in einer Zeichenkette.

979
00:47:50,190 --> 00:47:52,695
Sie müssen in der Lage zu ändern
die Z etwas anderes, die A

980
00:47:52,695 --> 00:47:55,280
auf etwas anderes, das M
etwas anderes, und so weiter.

981
00:47:55,280 --> 00:47:58,000
Und so müssen wir einen Weg,
programmatisch, so

982
00:47:58,000 --> 00:48:03,020
in C zu sprechen zu können, zu ändern
und Blick auf einzelne Buchstaben.

983
00:48:03,020 --> 00:48:05,690
Und wir können dies tun, wie folgt.

984
00:48:05,690 --> 00:48:08,340
>> Lassen Sie mich gehen zurück in CS50 IDE Kopf.

985
00:48:08,340 --> 00:48:11,130
Und lassen Sie mich gehen voran
und erstellen Sie eine neue Datei

986
00:48:11,130 --> 00:48:16,134
dass ich dieses Mal String0 nennen werde,
als ersten solchen Beispiel dot c.

987
00:48:16,134 --> 00:48:18,300
Und ich werde voran gehen
und peitschen sie sich wie folgt zusammen.

988
00:48:18,300 --> 00:48:22,870
>> So gehören CS50.h und
dann sind Standard io.h,

989
00:48:22,870 --> 00:48:25,990
was ich bin fast immer gehen
unter Verwendung der in meinen Programmen, zumindest

990
00:48:25,990 --> 00:48:26,780
anfänglich.

991
00:48:26,780 --> 00:48:32,180
int main leer, und dann hier bin ich
gehen Strings zu tun bekommt String bekommen.

992
00:48:32,180 --> 00:48:35,260
Und dann werde ich
gehen Sie vor und tun dies.

993
00:48:35,260 --> 00:48:37,460
Ich will voran gehen
und als Plausibilitätsprüfung,

994
00:48:37,460 --> 00:48:43,607
nur sagen, hallo, Prozent s,
Semikolon, macht Zeichenfolge 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, was tat ich hier?

996
00:48:44,690 --> 00:48:45,930
Oh, ich habe stecken Sie es nicht in.

997
00:48:45,930 --> 00:48:48,120
So Lektion gelernt, dass
war nicht beabsichtigt.

998
00:48:48,120 --> 00:48:52,480
>> So Fehler, mehr Prozent
Umsätze als Daten Argumente.

999
00:48:52,480 --> 00:48:54,940
Und dies ist, wo, in
Linie 7-- OK, so habe ich,

1000
00:48:54,940 --> 00:48:56,690
Zitat unquote, das ist
meine Zeichenfolge printf.

1001
00:48:56,690 --> 00:48:58,151
Ich habe ein Prozentzeichen bekam.

1002
00:48:58,151 --> 00:48:59,650
Aber ich vermisse das zweite Argument.

1003
00:48:59,650 --> 00:49:03,190
>> Ich vermisse das Komma s, die
Ich habe in den vorherigen Beispielen haben.

1004
00:49:03,190 --> 00:49:06,650
Also eine gute Gelegenheit zu beheben
Fehler ein weiteres, aus Versehen.

1005
00:49:06,650 --> 00:49:09,950
Und lassen Sie mich jetzt laufen
String0, geben Sie in Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, hallo Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Deshalb haben wir diese Art von Programm ausführen
ein paar verschiedene Male jetzt.

1008
00:49:14,144 --> 00:49:16,310
Aber lassen Sie uns etwas ein tun
wenig anders diesmal.

1009
00:49:16,310 --> 00:49:19,450
Anstatt nur Zamyla der Druck
ganzen Namen heraus mit printf,

1010
00:49:19,450 --> 00:49:21,350
Lassen Sie uns tun es Zeichen für Zeichen.

1011
00:49:21,350 --> 00:49:22,700
>> Ich werde eine for-Schleife zu verwenden.

1012
00:49:22,700 --> 00:49:26,160
Und ich werde mich zu geben,
eine Zählvariable, i genannt.

1013
00:49:26,160 --> 00:49:33,530
Und ich werde das Iterieren zu halten, so
solange i kleiner als die Länge von s ist.

1014
00:49:33,530 --> 00:49:35,930
>> Es stellt sich heraus, haben wir nicht
tun, um dieses letzte Mal,

1015
00:49:35,930 --> 00:49:39,100
dass c kommt mit einem
Funktion aufgerufen Stirling.

1016
00:49:39,100 --> 00:49:42,690
Zurück in den Tag, und im Allgemeinen
noch bei der Implementierung von Funktionen,

1017
00:49:42,690 --> 00:49:45,405
Menschen werden oft wählen sehr
prägnanten Namen, die Art von Sound

1018
00:49:45,405 --> 00:49:48,280
wie das, was Sie wollen, auch wenn es
ein paar Vokale oder Buchstaben fehlen.

1019
00:49:48,280 --> 00:49:50,660
So Stirling ist die
Name einer Funktion, die

1020
00:49:50,660 --> 00:49:53,880
ein Argument zwischen
Klammern, die eine Zeichenfolge sein sollte.

1021
00:49:53,880 --> 00:49:56,910
Und es gibt nur eine ganze Zahl,
die Länge dieser Zeichenkette.

1022
00:49:56,910 --> 00:50:00,580
>> Also dieser for-Schleife in Zeile 7 wird
Zählen zu beginnen bei i gleich 0 ist.

1023
00:50:00,580 --> 00:50:02,530
Es wird erhöht
i bei jeder Iteration

1024
00:50:02,530 --> 00:50:04,350
von 1, wie wir tun, ein paar Mal habe.

1025
00:50:04,350 --> 00:50:06,780
Aber es wird nur das tun,
dies bis zu dem Punkt

1026
00:50:06,780 --> 00:50:09,660
wenn ich die Länge
der Zeichenfolge selbst.

1027
00:50:09,660 --> 00:50:14,520
>> So ist dies ein Weg, letztendlich
die Charaktere iterieren

1028
00:50:14,520 --> 00:50:17,430
in der Zeichenfolge folgt, wie ist.

1029
00:50:17,430 --> 00:50:20,670
Ich werde kein auszudrucken
ganze Reihe, aber Prozent c,

1030
00:50:20,670 --> 00:50:22,860
ein einzelnes Zeichen
durch eine neue Linie gefolgt.

1031
00:50:22,860 --> 00:50:24,880
Und dann werde ich
gehen Sie vor, und ich brauche

1032
00:50:24,880 --> 00:50:29,080
zu sagen, dass ich drucken möchten
i-te Zeichen von s.

1033
00:50:29,080 --> 00:50:33,450
>> Also, wenn ich die Variable, die angibt,
der Index der Zeichenfolge, wobei

1034
00:50:33,450 --> 00:50:37,230
Sie drin sind, muss ich in der Lage sein
sagen, gib mir das i-te Zeichen von s.

1035
00:50:37,230 --> 00:50:40,390
Und c hat eine Weise zu tun,
dies mit eckigen Klammern.

1036
00:50:40,390 --> 00:50:43,679
Sie sagen einfach den Namen der
Schnur, die in diesem Fall ist s.

1037
00:50:43,679 --> 00:50:46,970
Dann sind Sie eckige Klammern verwenden, die sind
in der Regel nur über Ihre Return oder Enter

1038
00:50:46,970 --> 00:50:48,110
Taste auf der Tastatur.

1039
00:50:48,110 --> 00:50:52,410
Und dann setzen Sie den Index der
Zeichen, das Sie drucken möchten.

1040
00:50:52,410 --> 00:50:55,960
So ist der Index wird ein Baby sein
number-- 0 oder 1 oder 2 oder 3 oder dot,

1041
00:50:55,960 --> 00:50:57,590
Punkt, Punkt, eine andere Zahl.

1042
00:50:57,590 --> 00:51:00,920
>> Und wir sorgen dafür, dass es geht zu
sein, die richtige Zahl, weil ich

1043
00:51:00,920 --> 00:51:02,360
beginnen bei 0 zu zählen.

1044
00:51:02,360 --> 00:51:07,020
Und standardmäßig das erste Zeichen
in einem String wird per Konvention 0.

1045
00:51:07,020 --> 00:51:09,230
Und das zweite Zeichen Klammer 1.

1046
00:51:09,230 --> 00:51:11,120
Und das dritte Zeichen ist Klammer 2.

1047
00:51:11,120 --> 00:51:13,630
Und Sie wollen nicht zu gehen
weit, aber wir werden nicht, weil wir

1048
00:51:13,630 --> 00:51:17,780
werde ich nur, bis sie erhöhen
gleich der Länge der Saite.

1049
00:51:17,780 --> 00:51:20,210
Und an diesem Punkt,
Diese for-Schleife wird beendet.

1050
00:51:20,210 --> 00:51:25,550
>> Also lassen Sie mich gehen Sie vor und speichern diese
Programm und zum Laufen zu bringen Zeichenfolge 0.

1051
00:51:25,550 --> 00:51:28,400
Aber ich vermasselt.

1052
00:51:28,400 --> 00:51:35,390
erklärt Implizit Bibliotheksfunktion
Stirling mit Typ, und such-- jetzt,

1053
00:51:35,390 --> 00:51:36,430
Das klingt vertraut.

1054
00:51:36,430 --> 00:51:37,440
Aber es ist nicht printf.

1055
00:51:37,440 --> 00:51:38,540
Und es ist nicht String zu erhalten.

1056
00:51:38,540 --> 00:51:40,480
>> Ich habe nicht vermasseln in
auf die gleiche Weise diesmal.

1057
00:51:40,480 --> 00:51:45,100
Beachten Sie aber hier unten ein wenig nach unten
Weiterhin umfassen die Header string.h,

1058
00:51:45,100 --> 00:51:47,210
ausdrücklich vor, die
Erklärung für Stirling.

1059
00:51:47,210 --> 00:51:48,820
So gibt es tatsächlich ein Hinweis drin.

1060
00:51:48,820 --> 00:51:51,670
>> Und in der Tat stellt sich heraus,
gibt es einen anderen Header-Datei

1061
00:51:51,670 --> 00:51:53,970
dass wir nicht verwendet haben
in der Klasse noch nicht, aber es ist

1062
00:51:53,970 --> 00:51:56,480
unter den zur Verfügung
Sie, die so genannte string.h.

1063
00:51:56,480 --> 00:52:00,930
Und in dieser Datei string.h
ist Stirling erklärt.

1064
00:52:00,930 --> 00:52:05,220
Also lassen Sie mich gehen Sie vor und
speichern diese, machen Zeichenfolge

1065
00:52:05,220 --> 00:52:08,040
0-- schön, keine Fehlermeldungen dieser Zeit.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla und
Ich bin über Geben Sie zu schlagen,

1067
00:52:12,290 --> 00:52:16,710
an welchem ​​Punkt getstring geht
die Zeichenfolge, steckte es in s zurückzukehren.

1068
00:52:16,710 --> 00:52:21,890
Dann, dass for-Schleife wird iterieren
über S Charaktere ein zu einer Zeit,

1069
00:52:21,890 --> 00:52:28,420
und drucken sie eine pro Zeile, weil
Ich hatte diesen Backslash n am Ende.

1070
00:52:28,420 --> 00:52:34,530
So konnte ich diesen Backslash weglassen
n, und drucken Sie dann nur Zamyla alle

1071
00:52:34,530 --> 00:52:37,460
in der gleichen Zeile,
effektiv Neuimplementierung

1072
00:52:37,460 --> 00:52:38,999
printf, die nicht alles, was nützlich ist.

1073
00:52:38,999 --> 00:52:40,540
Aber in diesem Fall, ich habe das nicht getan.

1074
00:52:40,540 --> 00:52:43,610
Ich habe tatsächlich ein gedruckt
Zeichen in einer Zeit, eine pro Zeile,

1075
00:52:43,610 --> 00:52:45,400
so dass wir tatsächlich sehen, die Wirkung.

1076
00:52:45,400 --> 00:52:46,900
>> Aber ich sollte hier eine Sache beachten.

1077
00:52:46,900 --> 00:52:48,930
Und wir kommen wieder zu
dies in einer zukünftigen Woche.

1078
00:52:48,930 --> 00:52:52,650
Es stellt sich heraus, dass diese
Code ist möglicherweise fehlerhaft.

1079
00:52:52,650 --> 00:52:56,560
>> Es stellt sich heraus, dass der String
und einige andere Funktionen im Leben

1080
00:52:56,560 --> 00:53:00,280
nicht unbedingt immer
zurückzugeben, was Sie erwarten.

1081
00:53:00,280 --> 00:53:03,010
Wir wissen aus der Klasse letzten
Zeit in diese, die erhalten

1082
00:53:03,010 --> 00:53:04,960
String soll einen String zurück.

1083
00:53:04,960 --> 00:53:09,900
Aber was, wenn der Benutzer aus solchen
ein langes Wort oder Absatz oder Essay

1084
00:53:09,900 --> 00:53:13,010
dass es einfach nicht genug
Speicher in den Computer es zu passen.

1085
00:53:13,010 --> 00:53:15,410
>> Wie, was, wenn etwas schief
falsch unter der Haube?

1086
00:53:15,410 --> 00:53:18,400
Es ist vielleicht nicht oft passieren,
aber es könnte passieren, wenn

1087
00:53:18,400 --> 00:53:21,520
in eine Weile, sehr selten.

1088
00:53:21,520 --> 00:53:25,460
Und so stellt sich, dass der String-out
und funktioniert wie es nicht unbedingt

1089
00:53:25,460 --> 00:53:26,380
immer Strings zurück.

1090
00:53:26,380 --> 00:53:30,680
Sie könnten einige Fehlerwert zurückgeben,
einige Sentinel-Wert so zu sprechen,

1091
00:53:30,680 --> 00:53:32,612
das zeigt an, daß
etwas schief gegangen ist.

1092
00:53:32,612 --> 00:53:35,320
Und würden Sie wissen, nur diese aus
haben es jetzt in der Klasse gelernt,

1093
00:53:35,320 --> 00:53:37,700
oder etwas mehr Dokumentation gelesen zu haben.

1094
00:53:37,700 --> 00:53:43,120
Es stellt sich heraus, dass der String
kann null zurück Wert genannt.

1095
00:53:43,120 --> 00:53:46,220
Null ist ein spezieller Wert, dass wir
wieder in einer zukünftigen Woche.

1096
00:53:46,220 --> 00:53:50,420
Aber jetzt weiß nur, dass, wenn ich will
wirklich die richtige zu sein, nach vorn in bewegten

1097
00:53:50,420 --> 00:53:52,650
mit der String, ich
sollten nicht nur es nennen,

1098
00:53:52,650 --> 00:53:56,870
und blind ihren Rückgabewert verwenden,
Vertrauen darauf, dass es sich um eine Zeichenfolge ist.

1099
00:53:56,870 --> 00:53:59,420
>> Ich möchte zunächst sagen,
hey, warten Sie eine Minute, nur

1100
00:53:59,420 --> 00:54:03,380
verfahren ist, wenn s nicht gleich
null, wo null, wieder,

1101
00:54:03,380 --> 00:54:04,660
ist nur ein paar besonderen Wert.

1102
00:54:04,660 --> 00:54:07,770
Und es ist der einzige besondere Wert, den Sie
müssen etwa für get-String zu kümmern.

1103
00:54:07,770 --> 00:54:10,900
Der String entweder geht
einen String oder null zurück.

1104
00:54:10,900 --> 00:54:17,219
>> Und das Ausrufezeichen Gleichheitszeichen
Sie könnten von vielleicht Mathe-Unterricht kennen

1105
00:54:17,219 --> 00:54:20,510
dass Sie vielleicht ein Gleichheitszeichen ziehen mit
eine Linie, die durch sie nicht gleich anzuzeigen.

1106
00:54:20,510 --> 00:54:23,135
Das ist nicht im Allgemeinen ein Zeichen
Sie können auf Ihrer Tastatur eingeben.

1107
00:54:23,135 --> 00:54:26,480
Und so in den meisten Programmiersprachen,
wenn Sie wollen, nicht gleich zu sagen,

1108
00:54:26,480 --> 00:54:29,160
Sie verwenden ein Ausrufezeichen,
sonst als Knall bekannt.

1109
00:54:29,160 --> 00:54:33,180
Sie sagen also Knall gleich, was
bedeutet, logisch nicht gleich.

1110
00:54:33,180 --> 00:54:38,060
Es ist wie es ist keine größere
als, oder gleich oder kleiner als

1111
00:54:38,060 --> 00:54:41,270
oder gleich auf der Tastatur eingeben
das tut alles in einem Symbol.

1112
00:54:41,270 --> 00:54:44,020
Also, warum, in Vergangenheit Beispiele,
Sie haben eine offene Klammer, und dann

1113
00:54:44,020 --> 00:54:48,670
ein Gleichheitszeichen, um das zu tun
größer oder, sagen wir, weniger als.

1114
00:54:48,670 --> 00:54:49,910
>> Also, was ist das Mitnehmen hier?

1115
00:54:49,910 --> 00:54:53,880
Dies ist einfach eine Möglichkeit, jetzt
Einführung dieser Syntax, ist diese Funktion,

1116
00:54:53,880 --> 00:54:57,390
Iterieren über einzelne
Zeichen in einer Zeichenkette.

1117
00:54:57,390 --> 00:55:00,260
Und ebenso wie die Quadrat
Klammern können Sie zu ihnen zu bekommen,

1118
00:55:00,260 --> 00:55:03,790
betrachten diese eckigen Klammern als
Art Hinting von an diesem zugrunde liegenden

1119
00:55:03,790 --> 00:55:06,040
Design, wobei jeder
Zeichen innerhalb eines Strings

1120
00:55:06,040 --> 00:55:10,180
ist eine Art von unten in irgendwo boxed
die Haube in den Arbeitsspeicher Ihres Computers.

1121
00:55:10,180 --> 00:55:12,340
>> Aber lassen Sie uns eine Variante davon machen.

1122
00:55:12,340 --> 00:55:14,880
Es stellt sich heraus, dass diese
Programm ist richtig.

1123
00:55:14,880 --> 00:55:18,810
Also pro CS50 Achsen für die Bewertung
Code, dies ist nun korrekt.

1124
00:55:18,810 --> 00:55:22,959
Gerade jetzt, wo ich Überprüfung auf
null, dieses Programm sollte niemals zum Absturz bringen.

1125
00:55:22,959 --> 00:55:24,500
Und ich weiß nur, dass aus Erfahrung.

1126
00:55:24,500 --> 00:55:28,040
Aber es gibt nichts anderes,
können wir wirklich schief gehen.

1127
00:55:28,040 --> 00:55:31,860
Aber es ist nicht sehr gut gestaltet,
da kommen wir zurück zu den Wurzeln zu gehen.

1128
00:55:31,860 --> 00:55:34,450
>> Zuerst principles--
Was macht eine for-Schleife?

1129
00:55:34,450 --> 00:55:36,290
Eine for-Schleife hat drei Dinge.

1130
00:55:36,290 --> 00:55:39,340
Sie initialisiert einige
Wert, wenn Sie danach fragen.

1131
00:55:39,340 --> 00:55:41,770
Es prüft eine Bedingung.

1132
00:55:41,770 --> 00:55:45,380
Und dann nach jeder
Iteration nach jedem Zyklus,

1133
00:55:45,380 --> 00:55:49,330
erhöht er einige
, Hier Wert oder Werte.

1134
00:55:49,330 --> 00:55:50,600
>> Also, was bedeutet das?

1135
00:55:50,600 --> 00:55:52,940
Wir initialisieren i 0 auf.

1136
00:55:52,940 --> 00:55:58,610
Wir prüfen und sicherstellen, dass ich weniger als
die Länge s, die Z-A-M-Y-L-A ist,

1137
00:55:58,610 --> 00:55:59,900
so, die weniger als 6.

1138
00:55:59,900 --> 00:56:02,590
Und in der Tat, 0 als weniger als 6.

1139
00:56:02,590 --> 00:56:05,580
>> Wir drucken Z aus Zamyla Namen.

1140
00:56:05,580 --> 00:56:08,080
Dann erhöhen wir i von 0 bis 1.

1141
00:56:08,080 --> 00:56:11,290
Wir haben dann zu überprüfen, ist ein weniger
als die Länge s?

1142
00:56:11,290 --> 00:56:13,270
Die Länge s ist 6.

1143
00:56:13,270 --> 00:56:13,950
Ja, so ist es.

1144
00:56:13,950 --> 00:56:16,880
>> So drucken wir in Zamyla Namen, SA.

1145
00:56:16,880 --> 00:56:20,090
Wir inkrementieren i aus 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Wir haben dann zu überprüfen, ist 2 weniger als
die Länge des Zamyla Namen.

1147
00:56:23,720 --> 00:56:25,380
6- so 2 kleiner als 6.

1148
00:56:25,380 --> 00:56:30,460
Ja, lassen Sie uns jetzt M auszudrucken in
Zamyla Namen, das dritte Zeichen.

1149
00:56:30,460 --> 00:56:34,110
>> Der Schlüssel ist hier, dass auf jedem
Iteration der Geschichte, ich bin Überprüfung,

1150
00:56:34,110 --> 00:56:37,810
i kleiner ist als die Länge des Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Aber der Haken ist, dass
Stirling ist keine Eigenschaft.

1152
00:56:40,350 --> 00:56:43,100
Diejenigen von euch, die programmiert haben
bevor in Java oder anderen Sprachen

1153
00:56:43,100 --> 00:56:46,310
vielleicht wissen die Länge einer Zeichenfolge
eine Eigenschaft, einige gerade gelesen, nur Wert.

1154
00:56:46,310 --> 00:56:50,220
>> In C in diesem Fall, wenn dies
eine Funktion, die buchstäblich

1155
00:56:50,220 --> 00:56:53,520
Zählen der Anzahl von
Zeichen in Zamyla jedes Mal,

1156
00:56:53,520 --> 00:56:54,740
wir nennen diese Funktion.

1157
00:56:54,740 --> 00:56:58,500
Jedes Mal, wenn Sie fragen, den Computer zu benutzen
Stirling, es ist ein Blick auf Zamyla nehmen,

1158
00:56:58,500 --> 00:57:01,960
und sagen Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Und es kehrt 6.

1160
00:57:02,962 --> 00:57:04,920
Das nächste Mal, wenn Sie anrufen
es im Inneren, die für Schleife,

1161
00:57:04,920 --> 00:57:08,610
es geht um Zamyla aussehen
wieder sagen Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Und es geht um 6 zurückzukehren.

1163
00:57:10,320 --> 00:57:12,980
Also, was ist dumm zu diesem Entwurf?

1164
00:57:12,980 --> 00:57:17,700
>> Warum ist mein Code nicht 5 von 5
jetzt für das Design, so zu sprechen?

1165
00:57:17,700 --> 00:57:20,600
Nun, ich frage ein
unnötig Frage.

1166
00:57:20,600 --> 00:57:23,030
Ich mache mehr Arbeit, als ich zu müssen.

1167
00:57:23,030 --> 00:57:25,370
>> Also auch wenn die
Antwort ist richtig, ich bin

1168
00:57:25,370 --> 00:57:29,560
den Computer zu fragen, was ist
die Länge Zamyla wieder

1169
00:57:29,560 --> 00:57:31,380
und wieder und wieder und wieder?

1170
00:57:31,380 --> 00:57:33,980
Und diese Antwort ist
wird nie ändern.

1171
00:57:33,980 --> 00:57:35,900
Es ist immer 6 sein wird.

1172
00:57:35,900 --> 00:57:39,730
>> So eine bessere Lösung als das
würde diese nächste Version.

1173
00:57:39,730 --> 00:57:43,390
Lassen Sie mich gehen Sie vor und steckte es in eine
separate Datei namens string1.c,

1174
00:57:43,390 --> 00:57:44,990
nur zu halten, es trennen.

1175
00:57:44,990 --> 00:57:47,260
Und es stellt sich in eine aus für
Schleife, können Sie tatsächlich

1176
00:57:47,260 --> 00:57:50,210
mehrere Variablen zu deklarieren einmal.

1177
00:57:50,210 --> 00:57:53,460
>> Also werde ich ich zu halten und es auf 0 gesetzt.

1178
00:57:53,460 --> 00:57:56,190
Aber ich werde auch zu
fügen Sie ein Komma, und sagen:

1179
00:57:56,190 --> 00:58:01,050
geben Sie mir eine Variable n genannt, deren
Wert ist gleich der Länge der Zeichenfolge s.

1180
00:58:01,050 --> 00:58:09,410
Und jetzt machen Sie in meinem Zustand
solange i kleiner als n ist.

1181
00:58:09,410 --> 00:58:14,140
>> So auf diese Weise die Logik ist
am Ende des Tages identisch.

1182
00:58:14,140 --> 00:58:18,280
Aber ich bin die Erinnerung an die
Wert 6, in diesem Fall.

1183
00:58:18,280 --> 00:58:19,780
Was ist die Länge der Zamyla Name?

1184
00:58:19,780 --> 00:58:20,860
Und ich stelle es bei n.

1185
00:58:20,860 --> 00:58:23,050
>> Und ich bin immer noch überprüft
der Zustand jedes Mal.

1186
00:58:23,050 --> 00:58:24,300
Ist 0 weniger als 6?

1187
00:58:24,300 --> 00:58:25,600
Ist 1 weniger als 6?

1188
00:58:25,600 --> 00:58:28,600
2 ist weniger als 6, und so weiter?

1189
00:58:28,600 --> 00:58:31,914
>> Aber ich frage nicht, den Computer
wieder und wieder, was ist

1190
00:58:31,914 --> 00:58:33,080
die Länge des Zamyla Namen?

1191
00:58:33,080 --> 00:58:34,320
Was ist die Länge von Zamyla Namen?

1192
00:58:34,320 --> 00:58:35,986
Was ist die Länge der Name dieser Zamyla?

1193
00:58:35,986 --> 00:58:40,440
Ich erinnere mich an wahrsten Sinne des Wortes, dass erste und
Antwort nur in dieser zweiten Variable n.

1194
00:58:40,440 --> 00:58:45,280
Also das wäre jetzt nicht nur
richtig, aber auch gut gestaltet.

1195
00:58:45,280 --> 00:58:46,670
>> Nun, was ist Stil?

1196
00:58:46,670 --> 00:58:48,866
Ich habe meine Variablen mit den Namen
ziemlich gut, würde ich sagen.

1197
00:58:48,866 --> 00:58:50,240
Sie sind super jetzt prägnant.

1198
00:58:50,240 --> 00:58:52,090
Und das ist völlig in Ordnung.

1199
00:58:52,090 --> 00:58:55,120
>> Wenn Sie nur ein
String in einem Programm,

1200
00:58:55,120 --> 00:58:56,860
Sie könnte genauso gut nennen es für String s.

1201
00:58:56,860 --> 00:58:59,370
Wenn Sie nur eine Variable
für in einem Programm zu zählen,

1202
00:58:59,370 --> 00:59:00,710
Sie könnten, wie es auch ich nennen.

1203
00:59:00,710 --> 00:59:03,500
Wenn Sie eine Länge aufweisen, n
ist super als auch gemeinsam.

1204
00:59:03,500 --> 00:59:05,800
Aber ich habe keine meiner Code kommentiert.

1205
00:59:05,800 --> 00:59:09,200
>> Ich habe nicht die reader-- informiert
ob das meine TF ist oder TA,

1206
00:59:09,200 --> 00:59:12,460
oder einfach nur colleague-- was soll
geht in diesem Programm zu werden.

1207
00:59:12,460 --> 00:59:15,760
Und so guten Stil zu bekommen,
was ich tun möchte,

1208
00:59:15,760 --> 00:59:24,580
ist this-- etwas
wie stellen Benutzer zur Eingabe.

1209
00:59:24,580 --> 00:59:26,670
Und ich konnte umschreiben
Diese beliebige Anzahl von Möglichkeiten.

1210
00:59:26,670 --> 00:59:35,630
>> Stellen Sie sicher, s-- sicher get machen
String zurückgegeben einen String.

1211
00:59:35,630 --> 00:59:40,280
Und dann in hier-- und das ist vielleicht
die wichtigsten comment-- Iterierte

1212
00:59:40,280 --> 00:59:44,450
über die Zeichen in s eine zu einem Zeitpunkt.

1213
00:59:44,450 --> 00:59:47,060
Und ich konnte jede verwenden
Wahl der englischen Sprache

1214
00:59:47,060 --> 00:59:49,650
hier zu beschreiben, jeder
dieser Stücke von Code.

1215
00:59:49,650 --> 00:59:52,740
>> Beachten Sie, dass ich nicht gesetzt haben
Kommentar auf jeder Codezeile,

1216
00:59:52,740 --> 00:59:55,690
wirklich nur auf die interessante
diejenigen, diejenigen, die

1217
00:59:55,690 --> 00:59:59,460
eine Bedeutung haben, ich könnte
wollen Super Clear, mit jemandem zu machen

1218
00:59:59,460 --> 01:00:00,460
Lesen mein Code.

1219
01:00:00,460 --> 01:00:02,920
Und warum rufen Sie bekommen
String fragen Benutzer zur Eingabe?

1220
01:00:02,920 --> 01:00:05,450
Selbst ist, dass man nicht unbedingt
alles, was beschreibend.

1221
01:00:05,450 --> 01:00:09,340
Aber es hilft, eine Geschichte zu erzählen, weil die
zweite Zeile in der Geschichte ist, stellen Sie sicher,

1222
01:00:09,340 --> 01:00:10,740
erhalten String zurückgegeben einen String.

1223
01:00:10,740 --> 01:00:14,260
>> Und die dritte Zeile in der Geschichte ist,
iterieren die Zeichen in s ein

1224
01:00:14,260 --> 01:00:15,380
zu einem Zeitpunkt.

1225
01:00:15,380 --> 01:00:17,920
Und jetzt nur für eine gute Maßnahme,
Ich gehe voran gehen und hinzufügen

1226
01:00:17,920 --> 01:00:24,560
eine Bemerkung, die gerade
sagt drucken i-te Zeichen in s.

1227
01:00:24,560 --> 01:00:26,520
Nun, was habe ich getan,
am Ende des Tages?

1228
01:00:26,520 --> 01:00:29,190
>> Ich habe einige Englisch hinzugefügt
Wörter in Form von Kommentaren.

1229
01:00:29,190 --> 01:00:32,700
Der Schrägstrich Schrägstrich bedeutet, hey,
Computer dies für den Menschen ist,

1230
01:00:32,700 --> 01:00:33,820
nicht für Sie, den Computer neu.

1231
01:00:33,820 --> 01:00:35,119
Also sind sie logisch ignoriert.

1232
01:00:35,119 --> 01:00:35,910
Sie sind einfach da.

1233
01:00:35,910 --> 01:00:39,830
>> Und in der Tat, CS50 IDE zeigt sie als
grau, als nützlich, aber nicht Schlüssel

1234
01:00:39,830 --> 01:00:41,000
an das Programm.

1235
01:00:41,000 --> 01:00:42,570
Beachten Sie, was Sie jetzt tun können.

1236
01:00:42,570 --> 01:00:44,950
Egal, ob Sie wissen, C
Programmierung oder nicht, Sie

1237
01:00:44,950 --> 01:00:47,722
kann nur stehen auf diese zurück
Programm und überfliegen die Kommentare.

1238
01:00:47,722 --> 01:00:50,180
Stellen Sie Benutzer zur Eingabe, stellen Sie sicher,
erhalten Zeichenfolge eine Zeichenfolge zurückgegeben,

1239
01:00:50,180 --> 01:00:53,009
iterieren die Zeichen in s
ein zu einer Zeit, drucken Sie das Zeichen

1240
01:00:53,009 --> 01:00:55,550
i-te Zeichen in S-- tun Sie nicht
selbst haben den Code zu sehen

1241
01:00:55,550 --> 01:00:57,270
zu verstehen, was dieses Programm tut.

1242
01:00:57,270 --> 01:01:00,280
Und noch besser, wenn Sie sich selbst schauen
auf dieses Programm in einer Woche oder zwei,

1243
01:01:00,280 --> 01:01:02,280
oder einen Monat oder ein Jahr,
Sie haben auch nicht

1244
01:01:02,280 --> 01:01:04,420
auf den Code zu starren,
versucht sich zu erinnern,

1245
01:01:04,420 --> 01:01:06,630
was habe ich versucht, mit diesem Code zu tun?

1246
01:01:06,630 --> 01:01:07,770
>> Sie haben sich gesagt.

1247
01:01:07,770 --> 01:01:11,660
Du hast es selbst beschrieben,
oder ein Kollege oder TA oder TF.

1248
01:01:11,660 --> 01:01:14,860
Und so würde dies nun sein
richtig, und gutes Design,

1249
01:01:14,860 --> 01:01:18,210
und letztlich guten Stil auch.

1250
01:01:18,210 --> 01:01:19,990
So tun Sie daran, dass im Auge behalten.

1251
01:01:19,990 --> 01:01:22,200
>> So gibt es eine andere
was ich werde hier zu tun

1252
01:01:22,200 --> 01:01:28,240
das kann jetzt genau zeigen, was
geht unter der Haube.

1253
01:01:28,240 --> 01:01:30,390
Also gibt es diese Funktion
in C und anderen Sprachen,

1254
01:01:30,390 --> 01:01:33,010
genannt typecasting
dass entweder implizit

1255
01:01:33,010 --> 01:01:37,250
oder explizit ermöglicht es Ihnen, zu konvertieren
von einem Datentyp zum anderen.

1256
01:01:37,250 --> 01:01:39,800
Wir haben zu tun, so
weit heute mit Saiten.

1257
01:01:39,800 --> 01:01:41,250
>> Und Strings sind Zeichen.

1258
01:01:41,250 --> 01:01:44,910
Aber erinnern von Woche
0, was sind Zeichen?

1259
01:01:44,910 --> 01:01:49,334
Charaktere sind nur eine Abstraktion
oben auf numbers-- Dezimalzahlen,

1260
01:01:49,334 --> 01:01:52,500
und Dezimalzahlen sind wirklich nur ein
Abstraktion auf der binären Zahlen,

1261
01:01:52,500 --> 01:01:53,720
wie wir sie definiert.

1262
01:01:53,720 --> 01:01:55,540
>> So Zeichen sind Zahlen.

1263
01:01:55,540 --> 01:01:58,410
Und Zahlen sind Zeichen,
nur je nach Kontext.

1264
01:01:58,410 --> 01:02:01,250
Und es stellt sich heraus, dass im Inneren
eines Computerprogramms,

1265
01:02:01,250 --> 01:02:06,830
können Sie festlegen, wie Sie aussehen wollen
an den Bits innerhalb dieses Programms?

1266
01:02:06,830 --> 01:02:10,400
>> Rückruf von Woche 0, die wir hatten
Ascii, die nur dieser Code

1267
01:02:10,400 --> 01:02:11,620
Abbildung Buchstaben in Zahlen.

1268
01:02:11,620 --> 01:02:13,660
Und wir sagten Kapital A 65 ist.

1269
01:02:13,660 --> 01:02:15,860
Capital B 66 ist, und so weiter.

1270
01:02:15,860 --> 01:02:20,500
>> Und beachten Sie, wir haben im wesentlichen Zeichen auf
die obere Reihe hier, wie C sie nennen würde,

1271
01:02:20,500 --> 01:02:23,400
Zeichen, und dann
Ints in der zweiten Reihe.

1272
01:02:23,400 --> 01:02:28,180
Und es stellt sich heraus, können Sie konvertieren
nahtlos zwischen den beiden, in der Regel.

1273
01:02:28,180 --> 01:02:30,042
Und wenn wir wollen, zu tun
dies bewusst, wir

1274
01:02:30,042 --> 01:02:31,750
Vielleicht möchten angehen
etwas wie das.

1275
01:02:31,750 --> 01:02:33,590
>> Wir könnten konvertieren möchten
Großbuchstaben abzusenken

1276
01:02:33,590 --> 01:02:35,330
Fall oder Kleinbuchstaben in Großbuchstaben.

1277
01:02:35,330 --> 01:02:38,000
Und es stellt sich dort die aus
eigentlich ein Muster hier

1278
01:02:38,000 --> 01:02:39,900
wir können in nur einem Augenblick umarmen.

1279
01:02:39,900 --> 01:02:44,120
Aber lassen Sie uns zunächst einen Blick auf eine
Beispiel hierfür ausdrücklich tun.

1280
01:02:44,120 --> 01:02:46,340
>> Ich gehe zurück in CS50 IDE zu gehen.

1281
01:02:46,340 --> 01:02:50,640
Ich werde ein zu schaffen
Datei namens Ascii 0.C.

1282
01:02:50,640 --> 01:02:55,960
Und ich werde weitermachen und fügen Sie meine
Standard io.h an der Spitze, int main Leere

1283
01:02:55,960 --> 01:02:57,370
an der Spitze meiner Funktion.

1284
01:02:57,370 --> 01:03:02,700
Und dann werde ich nur das zu tun,
following-- einer for-Schleife von i gleich,

1285
01:03:02,700 --> 01:03:04,610
sagen wir mal, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Und dann wird i kleiner als
65 plus 26 Buchstaben im Alphabet.

1287
01:03:10,460 --> 01:03:12,640
Also werde ich den Computer lassen
die Mathematik für mich da.

1288
01:03:12,640 --> 01:03:15,100
Und dann innerhalb dieser Schleife
Was werde ich drucken?

1289
01:03:15,100 --> 01:03:19,230
>> % C% i n Schrägstrich.

1290
01:03:19,230 --> 01:03:21,290
Und nun möchte ich in zwei Werte zu stopfen.

1291
01:03:21,290 --> 01:03:24,530
Ich habe Frage vorübergehend setzen
markiert es die Frage zu laden.

1292
01:03:24,530 --> 01:03:29,940
>> Ich möchte beginnen, ab 65 iterieren
26 Buchstaben des Alphabets,

1293
01:03:29,940 --> 01:03:35,190
Drucken auf jeder Iteration darauf hin, dass
Charakter des Integral-Äquivalent.

1294
01:03:35,190 --> 01:03:38,299
Mit anderen Worten, ich möchte
iterieren 26 Zahlen Drucken

1295
01:03:38,299 --> 01:03:41,590
was das ASCII-Zeichen ist der Buchstabe,
und was die entsprechende Anzahl ist--

1296
01:03:41,590 --> 01:03:44,650
wirklich nur neu zu erstellen
das Diagramm aus der Folie.

1297
01:03:44,650 --> 01:03:47,010
Also, wie sollten diese Fragezeichen?

1298
01:03:47,010 --> 01:03:51,760
>> Nun, es stellt sich heraus, dass die zweite
man sollte nur die Variable i sein.

1299
01:03:51,760 --> 01:03:53,860
Ich möchte, dass als eine Zahl zu sehen.

1300
01:03:53,860 --> 01:03:58,920
Und das mittlere Argument
hier kann ich sagen dem Computer,

1301
01:03:58,920 --> 01:04:03,470
zu behandeln, die integer
i als ein Zeichen, so wie

1302
01:04:03,470 --> 01:04:05,880
es hier Prozent C zu ersetzen

1303
01:04:05,880 --> 01:04:07,990
>> In anderen Worten, wenn I, die
menschliche Programmierer wissen

1304
01:04:07,990 --> 01:04:09,865
das sind nur Zahlen
am Ende des Tages.

1305
01:04:09,865 --> 01:04:12,500
Und ich weiß, dass 65 sollte
Karte bis zu einem gewissen Charakter.

1306
01:04:12,500 --> 01:04:15,310
Mit dieser explizite Umwandlung,
mit einer Klammer,

1307
01:04:15,310 --> 01:04:18,840
der Name des Datentyps Sie wollen
konvertieren, und eine geschlossene Klammer,

1308
01:04:18,840 --> 01:04:21,200
Sie können das sagen,
Computer, hey, Computer,

1309
01:04:21,200 --> 01:04:24,130
wandeln diese ganze Zahl in eine char.

1310
01:04:24,130 --> 01:04:26,250
>> Also, wenn ich laufen diese
Programm nach dem Kompilieren,

1311
01:04:26,250 --> 01:04:29,740
mal sehen, was ich get-- Ascii 0 zu machen.

1312
01:04:29,740 --> 01:04:33,020
Darn es, was habe ich falsch gemacht hier?

1313
01:04:33,020 --> 01:04:35,884
Die Verwendung von nicht deklarierter Bezeichner,
Alles in Ordnung, nicht beabsichtigt,

1314
01:04:35,884 --> 01:04:37,800
aber mal sehen, ob wir nicht
Grund durch diese.

1315
01:04:37,800 --> 01:04:41,220
>> So Linie five-- so habe ich nicht bekommen
sehr weit vor vermasseln.

1316
01:04:41,220 --> 01:04:42,140
Das ist ok.

1317
01:04:42,140 --> 01:04:46,560
So Linie 5 für i gleich 65-- ich sehe.

1318
01:04:46,560 --> 01:04:50,130
Also denken Sie daran, dass in C, im Gegensatz zu einigen
Sprachen, wenn Sie vor der Programmierung haben

1319
01:04:50,130 --> 01:04:52,190
Erfahrung, haben Sie
um dem Computer mitzuteilen,

1320
01:04:52,190 --> 01:04:55,040
im Gegensatz zu Scratch, was
Variablentyp es sich handelt.

1321
01:04:55,040 --> 01:04:56,860
>> Und ich habe vergessen, eine wichtige Phrase hier.

1322
01:04:56,860 --> 01:04:59,200
In Zeile fünf, ich habe mit i gestartet.

1323
01:04:59,200 --> 01:05:01,560
Aber ich habe nicht gesagt, C
welchen Datentyp es sich handelt.

1324
01:05:01,560 --> 01:05:04,570
Also werde ich in zu gehen, hier und
sagen, ah, es sich um eine ganze Zahl zu machen.

1325
01:05:04,570 --> 01:05:07,050
>> Jetzt werde ich weiter und neu kompilieren zu gehen.

1326
01:05:07,050 --> 01:05:08,080
Das festgelegt, dass.

1327
01:05:08,080 --> 01:05:12,660
Geben Sie ./ascii0, das ist irgendwie cool.

1328
01:05:12,660 --> 01:05:15,360
Es ist nicht nur superschnell
fragen Sie den Computer, auf diese Frage,

1329
01:05:15,360 --> 01:05:18,885
anstatt es auf einem Objektträger suchen,
es ausgedruckt eine pro Zeile, A 65 ist,

1330
01:05:18,885 --> 01:05:24,860
B 66, den ganzen Weg down-- da ich
tat dies 26 times-- auf die Buchstaben z,

1331
01:05:24,860 --> 01:05:25,630
Das ist 90.

1332
01:05:25,630 --> 01:05:27,790
Und in der Tat etwas
intelligenter würde

1333
01:05:27,790 --> 01:05:31,030
haben für mich nicht verlassen
auf dem Computer 26 hinzuzufügen.

1334
01:05:31,030 --> 01:05:34,060
Ich hätte gerade getan
90 als gut, so lange

1335
01:05:34,060 --> 01:05:37,390
da ich nicht zweimal den gleichen Fehler machen.

1336
01:05:37,390 --> 01:05:41,880
Ich will gehen nach oben durch
z, nicht nur nach oben durch y.

1337
01:05:41,880 --> 01:05:44,000
>> Also das ist eine explizite Umwandlung.

1338
01:05:44,000 --> 01:05:47,860
Es stellt sich heraus, dass diese
ist nicht einmal notwendig.

1339
01:05:47,860 --> 01:05:52,480
Lassen Sie mich gehen Sie vor, und wiederholen Sie diese
Compiler und Rerun Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Es stellt sich heraus, dass C ziemlich schlau ist.

1341
01:05:54,940 --> 01:05:57,150
>> Und printf, insbesondere,
ist ziemlich smart.

1342
01:05:57,150 --> 01:06:01,260
Wenn Sie gerade ein i passieren zweimal
für beide Platzhalter, printf

1343
01:06:01,260 --> 01:06:04,510
realisieren wird, oh, gut ich weiß, du
gab mir einige Zahl ein integer--,

1344
01:06:04,510 --> 01:06:06,380
wie 65 oder 90, oder was auch immer.

1345
01:06:06,380 --> 01:06:10,170
Aber ich sehe, dass Sie mich wollen
formatiert die Zahl ist wie ein Zeichen.

1346
01:06:10,170 --> 01:06:16,460
Und so kann printf implizit gegossen
die int für Sie als auch zu einem Zeichen.

1347
01:06:16,460 --> 01:06:19,360
Das ist also kein Problem.

1348
01:06:19,360 --> 01:06:23,100
>> Beachten Sie aber, weil dieser Gleichwertigkeit
wir können dies tatsächlich auch tun.

1349
01:06:23,100 --> 01:06:26,520
Lassen Sie mich gehen Sie vor und machen ein
andere Version von this-- Ascii 1.c

1350
01:06:26,520 --> 01:06:31,800
Und statt iterieren
Zahlen, kann wirklich einfach umhaut

1351
01:06:31,800 --> 01:06:33,610
um mehr als Zeichen laufen.

1352
01:06:33,610 --> 01:06:37,660
Wenn ein char c bekommt ein Kapital, I
wollen, gehen Sie vor und tun dies,

1353
01:06:37,660 --> 01:06:41,740
so lange, wie C ist kleiner oder gleich
Kapital Z. Und bei jeder Iteration

1354
01:06:41,740 --> 01:06:45,690
Ich möchte C zu erhöhen, kann ich
jetzt in meiner printf Linie hier

1355
01:06:45,690 --> 01:06:51,320
sagen wir, Prozent C
Prozent i wieder, Komma C.

1356
01:06:51,320 --> 01:06:57,200
>> Und jetzt kann ich in die andere Richtung gehen,
Gießen der Charakter ausdrücklich

1357
01:06:57,200 --> 01:06:58,500
in eine ganze Zahl.

1358
01:06:58,500 --> 01:07:00,560
Also, noch einmal, warum sollten Sie das tun?

1359
01:07:00,560 --> 01:07:03,830
Es ist ein wenig seltsam zu sortieren von
zählen in Bezug auf die Charaktere.

1360
01:07:03,830 --> 01:07:07,430
>> Aber wenn Sie verstehen, was ist
geht unter der Haube,

1361
01:07:07,430 --> 01:07:08,430
gibt es wirklich keine Magie.

1362
01:07:08,430 --> 01:07:13,060
Sie sagen, nur, hey, Computer geben
mir eine Variable C vom Typ char bezeichnet.

1363
01:07:13,060 --> 01:07:16,520
Initialisieren Sie es zu Kapital A. Und
Apostrophe Materie bemerken.

1364
01:07:16,520 --> 01:07:19,580
>> Für Zeichen in C, erinnern von
letzte Woche, verwenden Sie einfache Anführungszeichen.

1365
01:07:19,580 --> 01:07:23,720
Bei Strings für Wörter,
Sätze, verwenden Sie doppelte Anführungszeichen.

1366
01:07:23,720 --> 01:07:27,210
OK, Computer, Halten Sie tun dies, so
solange das Zeichen kleiner als

1367
01:07:27,210 --> 01:07:28,050
oder gleich z.

1368
01:07:28,050 --> 01:07:32,640
Und ich weiß aus meiner Ascii-Tabelle, die alle
dieser Ascii-Codes sind zusammenhängend.

1369
01:07:32,640 --> 01:07:33,400
>> Es gibt keine Lücken.

1370
01:07:33,400 --> 01:07:36,737
Es ist also nur A bis Z,
jeweils um eine Anzahl getrennt.

1371
01:07:36,737 --> 01:07:38,820
Und dann kann ich erhöhen
ein Zeichen, wenn ich wirklich will.

1372
01:07:38,820 --> 01:07:40,390
Am Ende des Tages,
es ist nur eine Zahl.

1373
01:07:40,390 --> 01:07:41,030
Ich weiß das.

1374
01:07:41,030 --> 01:07:43,670
So kann ich davon ausgehen, nur 1, um es hinzuzufügen.

1375
01:07:43,670 --> 01:07:46,940
>> Und dann dieses Mal, drucke ich c,
und dann das Integral äquivalent.

1376
01:07:46,940 --> 01:07:50,170
Und ich brauche nicht einmal die explizite Umwandlung.

1377
01:07:50,170 --> 01:07:52,680
Ich kann printf lassen und die
Computer Bild Dinge aus,

1378
01:07:52,680 --> 01:07:57,300
so dass jetzt, wenn ich laufen
machen Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Ich erhalte die genau die gleiche Sache auch.

1380
01:08:01,520 --> 01:08:04,530
>> Nutzloses Programm, though-- niemand
wird Software tatsächlich schreiben

1381
01:08:04,530 --> 01:08:07,549
um herauszufinden, was die
Nummer, die A-Karten, oder B oder Z?

1382
01:08:07,549 --> 01:08:10,340
Du bist nur es geht bei Google, oder
schauen sie online, oder schauen Sie

1383
01:08:10,340 --> 01:08:11,650
auf einem Objektträger oder dergleichen.

1384
01:08:11,650 --> 01:08:13,520
Woher kommt also diese bekommen wirklich nützlich?

1385
01:08:13,520 --> 01:08:15,960
>> Nun, spricht davon
Rutsche, bemerken es

1386
01:08:15,960 --> 01:08:20,890
eine tatsächliche Muster hier zwischen Groß-
und Klein, das war kein Zufall.

1387
01:08:20,890 --> 01:08:23,760
Beachten Sie, dass Kapital A 65.

1388
01:08:23,760 --> 01:08:25,830
Kleinbuchstaben ist 97.

1389
01:08:25,830 --> 01:08:29,649
Und wie ist weit weg Kleinbuchstaben a?

1390
01:08:29,649 --> 01:08:32,649
>> So 65 ist, wie viele Schritte von 97?

1391
01:08:32,649 --> 01:08:36,210
So 97 minus 65 ist 32.

1392
01:08:36,210 --> 01:08:37,910
So ist das Kapital ein 65.

1393
01:08:37,910 --> 01:08:39,939
Wenn Sie hinzufügen, 32, dass,
Sie erhalten Kleinbuchstaben.

1394
01:08:39,939 --> 01:08:43,729
Und dasselbe ist, wenn Sie 32 subtrahieren,
Sie wieder zu Kapital A-- gleiche mit B

1395
01:08:43,729 --> 01:08:46,380
zu wenig b, große C zu wenig c.

1396
01:08:46,380 --> 01:08:50,670
>> Alle diese Lücken 32 auseinander.

1397
01:08:50,670 --> 01:08:54,450
Nun, dies scheint uns zu ermöglichen,
etwas tun, wie Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
oder Google Text & Tabellen verfügen, in dem Sie
kann alles auswählen und dann sagen,

1399
01:08:57,729 --> 01:09:00,520
ändern alle in Kleinbuchstaben, oder
ändern alle in Großbuchstaben,

1400
01:09:00,520 --> 01:09:03,840
oder ändern Sie nur das erste Wort
eines Satzes in Großbuchstaben.

1401
01:09:03,840 --> 01:09:07,390
Wir können tatsächlich etwas tun
wie das selbst.

1402
01:09:07,390 --> 01:09:12,645
>> Lassen Sie mich gehen Sie vor und eine Datei speichern
hier genannt 0.C. Kapital

1403
01:09:12,645 --> 01:09:15,770
Und lassen Sie uns vorangehen und ein Programm Peitsche
dass genau das tut wie folgt.

1404
01:09:15,770 --> 01:09:18,460
So gehören die CS50-Bibliothek.

1405
01:09:18,460 --> 01:09:21,430
Und sind Standard-I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Und ich weiß, dass dies auch bald.

1407
01:09:22,787 --> 01:09:24,870
Also werde ich, es in
schon da, string.h,

1408
01:09:24,870 --> 01:09:26,960
so habe ich Zugang zu
Dinge wie Stirling,

1409
01:09:26,960 --> 01:09:29,620
und dann int Haupt Leere, wie üblich.

1410
01:09:29,620 --> 01:09:33,420
Und dann gehe ich voran gehen
und Strings zu tun bekommt String zu erhalten,

1411
01:09:33,420 --> 01:09:35,032
nur einen String vom Benutzer zu erhalten.

1412
01:09:35,032 --> 01:09:36,740
Und dann werde ich
tun, um meine geistige Gesundheit zu überprüfen.

1413
01:09:36,740 --> 01:09:40,510
Wenn Zeichenfolge nicht gleich null,
es ist dann sicher zu gehen.

1414
01:09:40,510 --> 01:09:42,000
Und was muss ich tun?

1415
01:09:42,000 --> 01:09:48,700
Ich werde iterieren von i gleich 0 ist,
und n bis zum String-Länge von s.

1416
01:09:48,700 --> 01:09:51,899
>> Und ich werde, dies zu tun, so lange
i kleiner als n, und i plus plus.

1417
01:09:51,899 --> 01:09:55,060
Bisher bin ich wirklich nur
Ideen aus der Zeit vor Kreditaufnahme.

1418
01:09:55,060 --> 01:09:57,010
Und jetzt werde ich einen Zweig einzuführen.

1419
01:09:57,010 --> 01:09:59,635
>> Also denken Sie zurück an Scratch, wo
wir hatten diese Gabeln in der Straße,

1420
01:09:59,635 --> 01:10:05,110
und letzte Woche in C. Ich werde
sagen, dass dies, wenn das i-te Zeichen in s

1421
01:10:05,110 --> 01:10:09,250
größer oder
gleich Fall eine zu senken,

1422
01:10:09,250 --> 01:10:13,340
und- in Scratch würden Sie buchstäblich
sagen und, aber in C Sie sagen etzeichen,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- und das i-te Zeichen in s
kleiner als oder gleich z Fall zu senken,

1424
01:10:19,830 --> 01:10:21,780
Lassen Sie uns etwas Interessantes zu tun.

1425
01:10:21,780 --> 01:10:27,020
Lassen Sie uns auszudrucken eigentlich ein
Zeichen ohne Newline

1426
01:10:27,020 --> 01:10:31,760
das ist das Zeichen in der Zeichenfolge,
das i-te Zeichen in der Zeichenfolge.

1427
01:10:31,760 --> 01:10:37,420
>> Aber lassen Sie uns fortfahren und
subtrahieren 32 davon entfernt.

1428
01:10:37,420 --> 01:10:42,120
Else, wenn das Zeichen in der
Zeichenfolge, die wir suchen

1429
01:10:42,120 --> 01:10:45,950
ist nicht zwischen wenig ein
und wenig z, gehen Sie voran

1430
01:10:45,950 --> 01:10:48,610
und es einfach ausgedruckt unverändert.

1431
01:10:48,610 --> 01:10:50,840
Deshalb haben wir eingeführt
diese klammert Notation

1432
01:10:50,840 --> 01:10:53,560
für unsere Saiten auf die zu bekommen
i-ten Zeichen in der Zeichenfolge.

1433
01:10:53,560 --> 01:10:57,520
>> Ich habe einige bedingte Logik hinzugefügt, wie
Scratch in der letzten Woche Woche ein, in dem

1434
01:10:57,520 --> 01:10:59,880
Ich verwende nur meine grundlegenden
Verständnis von dem, was

1435
01:10:59,880 --> 01:11:01,130
geht unter der Haube.

1436
01:11:01,130 --> 01:11:04,190
Ist das i-te Zeichen von s
größer oder gleich a?

1437
01:11:04,190 --> 01:11:08,290
Wie ist es 97 oder 98,
oder 99 und so weiter?

1438
01:11:08,290 --> 01:11:11,940
>> Jedoch ist es auch kleiner als oder gleich
auf den Wert der Klein z?

1439
01:11:11,940 --> 01:11:16,210
Und wenn ja, was bedeutet diese Linie?

1440
01:11:16,210 --> 01:11:20,250
14 ist diese Art der
Keim der ganzen Idee,

1441
01:11:20,250 --> 01:11:23,840
kapitalisieren den Brief
einfach 32 davon subtrahiert wird,

1442
01:11:23,840 --> 01:11:29,370
in diesem Fall, weil ich weiß, dass per
Diagramm, wie meine Zahlen dargestellt werden.

1443
01:11:29,370 --> 01:11:33,925
Also lassen Sie uns gehen Sie vor und führen diese,
nach dem Kompilieren nutzen 0.c,

1444
01:11:33,925 --> 01:11:36,210
und laufen profitieren 0.

1445
01:11:36,210 --> 01:11:40,300
>> Lassen Sie geben die in so etwas wie
Zamyla in Kleinbuchstaben eingeben.

1446
01:11:40,300 --> 01:11:42,780
Und jetzt haben wir Zamyla in Großbuchstaben.

1447
01:11:42,780 --> 01:11:45,050
Lassen Sie uns in Kleinbuchstaben in Rob geben.

1448
01:11:45,050 --> 01:11:46,674
Lassen Sie uns versuchen Jason in Kleinschreibung.

1449
01:11:46,674 --> 01:11:48,590
Und wir halten die immer
Zwangskapitalisierung.

1450
01:11:48,590 --> 01:11:50,960
Es gibt einen kleinen Bug, dass ich
Art hat nicht antizipieren.

1451
01:11:50,960 --> 01:11:54,050
Beachten Sie meine neue Prompt landen
auf der gleichen Linie wie ihre Namen,

1452
01:11:54,050 --> 01:11:55,520
das fühlt sich ein wenig chaotisch.

1453
01:11:55,520 --> 01:11:59,170
>> Also werde ich hier zu gehen, und
tatsächlich am Ende des Programms

1454
01:11:59,170 --> 01:12:02,110
drucken Sie ein Newline-Zeichen aus.

1455
01:12:02,110 --> 01:12:03,160
Das ist alles.

1456
01:12:03,160 --> 01:12:06,120
Mit printf, brauchen Sie nicht zu
Pass in Variablen oder Format-Code.

1457
01:12:06,120 --> 01:12:08,460
Sie können buchstäblich nur drucken
so etwas wie eine neue Zeile.

1458
01:12:08,460 --> 01:12:13,529
>> Also lassen Sie uns gehen Sie voran und machen
Kapital 0 wieder, erneut ausführen, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Und jetzt ist es ein wenig schöner.

1460
01:12:14,820 --> 01:12:17,274
Nun, meine Aufforderung ist auf seine eigene neue Zeile.

1461
01:12:17,274 --> 01:12:18,440
Also das ist alles schön und gut.

1462
01:12:18,440 --> 01:12:19,910
Das ist also ein gutes Beispiel.

1463
01:12:19,910 --> 01:12:22,700
Aber ich weiß nicht einmal notwendigerweise
müssen hart Code 32.

1464
01:12:22,700 --> 01:12:23,350
Weißt du was?

1465
01:12:23,350 --> 01:12:26,350
Ich konnte sagen-- ich nicht immer
daran erinnern, was der Unterschied ist.

1466
01:12:26,350 --> 01:12:29,330
>> Aber ich weiß, wenn ich
haben einen Kleinbuchstaben,

1467
01:12:29,330 --> 01:12:34,430
Ich möchte im Wesentlichen subtrahieren aus
was auch immer der Abstand zwischen wenig

1468
01:12:34,430 --> 01:12:39,160
a und große A, denn wenn ich davon aus, dass
alle anderen Buchstaben die gleichen sind,

1469
01:12:39,160 --> 01:12:41,045
das sollte den Job zu erledigen.

1470
01:12:41,045 --> 01:12:42,670
Aber anstatt das zu tun, weißt du was?

1471
01:12:42,670 --> 01:12:44,240
Es gibt noch eine andere Art und Weise.

1472
01:12:44,240 --> 01:12:48,090
>> Wenn das Kapital 1.c-- wenn ich
dass in eine separate Datei zu setzen.

1473
01:12:48,090 --> 01:12:51,030
Lassen Sie uns 2.c Sie profitieren wie folgt.

1474
01:12:51,030 --> 01:12:53,060
Ich werde wirklich hier aufzuräumen.

1475
01:12:53,060 --> 01:12:57,420
Und statt zu erhalten, sogar
wissen oder kümmern sich um jene niedrigen Niveau

1476
01:12:57,420 --> 01:13:01,090
Details der Implementierung, ich bin statt
Drucklegung nur ein Zeichen,

1477
01:13:01,090 --> 01:13:04,610
Zitat unquote, Prozent C, und
rufen Sie dann eine andere Funktion,

1478
01:13:04,610 --> 01:13:09,950
besteht, dass ein Argument nimmt,
Das ist ein Zeichen, wie diese.

1479
01:13:09,950 --> 01:13:12,630
>> Es stellt sich in C aus, gibt es
eine andere Funktionsaufruf

1480
01:13:12,630 --> 01:13:15,550
In den oberen, die wie der Name
schlägt vor, nimmt einen Charakter

1481
01:13:15,550 --> 01:13:19,350
und macht es zu seinem oberen Gehäuse
äquivalent, und gibt sie dann

1482
01:13:19,350 --> 01:13:21,410
so dass printf es dort stecken.

1483
01:13:21,410 --> 01:13:25,484
Und so, dies zu tun, ich aber,
müssen eine andere Datei einzuführen.

1484
01:13:25,484 --> 01:13:28,400
Es stellt sich heraus, es eine andere Datei ist
dass Sie nur von der Klasse wissen würde,

1485
01:13:28,400 --> 01:13:33,020
oder ein Lehrbuch oder ein Online
Referenz, die so genannte C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Also, wenn ich hinzufügen, dass sich unter meinen Kopf
Dateien, und jetzt neu kompilieren dieses Programm,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 eingeben.

1488
01:13:43,040 --> 01:13:46,690
Lassen Sie uns geben Zamyla in allen
Klein, arbeitet immer noch die gleiche.

1489
01:13:46,690 --> 01:13:48,040
Aber weißt du was?

1490
01:13:48,040 --> 01:13:55,590
Es stellt sich heraus, dass an der oberen
hat eine andere Funktionalität.

1491
01:13:55,590 --> 01:13:58,410
>> Und lassen Sie mich dies vorstellen
hier befehlen, irgendwie ungeschickt

1492
01:13:58,410 --> 01:14:00,250
genannt, aber der Mensch für die manuelle.

1493
01:14:00,250 --> 01:14:03,960
Es stellt sich heraus, dass die meisten Linux-Computer,
wie wir verwenden hier-- Linux Betriebs

1494
01:14:03,960 --> 01:14:06,270
system-- haben einen Befehl
rief ein Mann, der sagt,

1495
01:14:06,270 --> 01:14:08,530
hey, Computer, gib mir
des Computers manuell.

1496
01:14:08,530 --> 01:14:10,680
Was möchtest du
schauen in diesem Handbuch nach oben?

1497
01:14:10,680 --> 01:14:13,840
>> Ich möchte die Funktion nachschlagen
In den oberen genannt, ein.

1498
01:14:13,840 --> 01:14:16,070
Und es ist ein wenig kryptisch
manchmal zu lesen.

1499
01:14:16,070 --> 01:14:18,780
Beachten Sie aber, wir sind in der
Linux Programmiererhandbuch.

1500
01:14:18,780 --> 01:14:19,530
Und es ist alles Text.

1501
01:14:19,530 --> 01:14:21,905
Und feststellen, dass es die
Name der Funktion hier oben.

1502
01:14:21,905 --> 01:14:25,030
Es stellt sich heraus, dass es einen Cousin namens
zu senken, die das Gegenteil tut.

1503
01:14:25,030 --> 01:14:29,710
Und Mitteilung nach Synopsis, zu verwenden, um dies
Funktion, um die man-Seite, so zu sprechen,

1504
01:14:29,710 --> 01:14:32,220
sagt mir, dass ich
müssen c type.h. umfassen

1505
01:14:32,220 --> 01:14:33,630
Und ich wusste, dass aus der Praxis.

1506
01:14:33,630 --> 01:14:36,210
>> Hier ist es zeigt mir die zwei
Prototypen für die Funktion,

1507
01:14:36,210 --> 01:14:39,070
so dass, wenn ich will immer, dieses zu verwenden
Ich weiß, was sie als Eingabe,

1508
01:14:39,070 --> 01:14:40,652
und was sie zurückkommen als Ausgabe.

1509
01:14:40,652 --> 01:14:42,360
Und dann, wenn ich lese
die Beschreibung, die ich sehe,

1510
01:14:42,360 --> 01:14:44,820
genauer, was die Funktion tut.

1511
01:14:44,820 --> 01:14:48,100
Aber noch wichtiger ist, wenn
Ich sehe unter Rückgabewert,

1512
01:14:48,100 --> 01:14:51,710
es sagt der zurückgegebene Wert
dass der konvertierten Brief,

1513
01:14:51,710 --> 01:14:57,880
oder C, die ursprüngliche Eingangs, wenn
die Umsetzung war nicht möglich.

1514
01:14:57,880 --> 01:15:01,992
>> Mit anderen Worten, Ober zu versuchen,
einen Brief in Großbuchstaben zu konvertieren.

1515
01:15:01,992 --> 01:15:03,450
Und wenn ja, es geht es zurück.

1516
01:15:03,450 --> 01:15:07,010
Aber wenn es kann nicht für einige reason--
vielleicht ist es bereits die Groß-,

1517
01:15:07,010 --> 01:15:09,550
vielleicht ist es ein Ausrufezeichen
oder einige andere punctuation--

1518
01:15:09,550 --> 01:15:12,200
es geht nur um
händigt das Original C,

1519
01:15:12,200 --> 01:15:17,340
was bedeutet, dass ich meinen Code machen kann
wie folgt besser gestaltet.

1520
01:15:17,340 --> 01:15:20,580
>> Ich brauche nicht alle
diese verflixte Zeilen Code.

1521
01:15:20,580 --> 01:15:22,610
Alle Linien Ich habe
nur kann hervorgehoben

1522
01:15:22,610 --> 01:15:28,700
in nur einem einfachen zusammengeklappt werden
Linie, die this-- printf Prozent

1523
01:15:28,700 --> 01:15:33,510
c obere S Halterung i.

1524
01:15:33,510 --> 01:15:36,090
Und das wäre ein
Beispiel für besseres Design.

1525
01:15:36,090 --> 01:15:40,040
>> Warum in 7 oder 8 Zeilen implementieren
nur der Code, was immer es war ich

1526
01:15:40,040 --> 01:15:44,960
gelöscht, wenn Sie stattdessen kollabieren
all diese Logik und Entscheidungsfindung

1527
01:15:44,960 --> 01:15:49,620
in einer einzigen Zeile, 13 jetzt, dass
stützt sich auf eine Bibliothek function--

1528
01:15:49,620 --> 01:15:53,430
eine Funktion, die mit C kommt, aber das
genau das tut, was Sie es tun wollen.

1529
01:15:53,430 --> 01:15:55,295
Und, ehrlich gesagt, auch wenn
es kam nicht mit C,

1530
01:15:55,295 --> 01:15:58,880
Sie konnte es selbst implementieren, wie
wir haben gesehen, was negative int erhalten

1531
01:15:58,880 --> 01:16:01,700
und erhalten positive int letzte Woche auch.

1532
01:16:01,700 --> 01:16:03,470
>> Dieser Code ist jetzt viel besser lesbar.

1533
01:16:03,470 --> 01:16:06,670
Und in der Tat, wenn wir nach oben,
schauen, wie viel kompakter

1534
01:16:06,670 --> 01:16:08,360
Diese Version meines Programms ist.

1535
01:16:08,360 --> 01:16:11,230
Es ist ein wenig kopflastig jetzt,
mit all diesen umfasst.

1536
01:16:11,230 --> 01:16:14,380
Aber das ist in Ordnung, weil ich jetzt stehe
auf den Schultern der Programmierer

1537
01:16:14,380 --> 01:16:15,300
vor mir.

1538
01:16:15,300 --> 01:16:18,440
Und wer auch immer es war, der
umgesetzt wirklich obere

1539
01:16:18,440 --> 01:16:21,470
tat mir einen Gefallen, so wie jeder,
umgesetzt Stirling wirklich

1540
01:16:21,470 --> 01:16:24,790
Vor tat mir einige Zeit, um einen Gefallen.

1541
01:16:24,790 --> 01:16:26,970
Und so haben wir jetzt ein
bessere Design-Programm

1542
01:16:26,970 --> 01:16:31,680
dass implementiert die genau die gleiche Logik.

1543
01:16:31,680 --> 01:16:35,580
>> Apropos stirling, lassen
mich voran gehen und tun dies.

1544
01:16:35,580 --> 01:16:38,320
Lassen Sie mich gehen Sie vor und sparen
Diese Datei als stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Und es stellt sich heraus, können wir zurück schälen
eine andere Schicht ziemlich einfach jetzt.

1546
01:16:43,255 --> 01:16:45,630
Ich werde weitermachen und Peitsche
bis ein anderes Programm in Haupt

1547
01:16:45,630 --> 01:16:49,759
hier, dass einfach neu implementiert
Stringlänge wie folgt.

1548
01:16:49,759 --> 01:16:52,300
Also hier ist eine Zeile Code,
wird mir von dem Benutzer einen String.

1549
01:16:52,300 --> 01:16:53,910
Wir halten mit diesem immer wieder.

1550
01:16:53,910 --> 01:16:58,900
Lassen Sie mich eine Variable geben genannt
n vom Typ int, die eine Zahl speichert.

1551
01:16:58,900 --> 01:17:02,490
>> Und lassen Sie mich gehen Sie voran und
tun die folgende Logik.

1552
01:17:02,490 --> 01:17:15,610
Während das n-te Zeichen in s tut
nicht gleich Backslash 0, gehen Sie voran

1553
01:17:15,610 --> 01:17:17,930
und erhöhen n.

1554
01:17:17,930 --> 01:17:23,506
Und dann printf Prozent i n ausdrucken.

1555
01:17:23,506 --> 01:17:29,200
Ich behaupte, dass dieses Programm hier,
ohne Stringlänge Aufruf,

1556
01:17:29,200 --> 01:17:31,150
Zahlen, die Länge einer Zeichenkette aus.

1557
01:17:31,150 --> 01:17:34,600
>> Und die Magie ist ganz
in Zeile 8 verkapselt

1558
01:17:34,600 --> 01:17:39,830
hier mit, was wie eine neue Syntax aussieht,
diese Backslash 0 in einfache Anführungszeichen.

1559
01:17:39,830 --> 01:17:41,360
Aber warum ist das so?

1560
01:17:41,360 --> 01:17:44,100
Nun, überlegen, was gewesen ist
geht die ganze Zeit.

1561
01:17:44,100 --> 01:17:47,990
>> Und so nebenbei, bevor ich es vergesse, erkennen
auch, dass zusätzlich zu den Hilfeseiten

1562
01:17:47,990 --> 01:17:50,920
die kommen mit einem typischen
Linux-System wie CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
erkennen, dass wir, die
Natürlich Mitarbeiter, haben auch

1564
01:17:53,770 --> 01:17:56,030
machte eine Website-Version
dieser gleiche Idee genannt

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, das hat
alle den gleichen Mann Seiten,

1566
01:17:59,940 --> 01:18:02,020
alle gleichen
Dokumentation sowie

1567
01:18:02,020 --> 01:18:05,730
eine kleine Box an der Spitze, die erlaubt
Sie alle die ziemlich zu konvertieren

1568
01:18:05,730 --> 01:18:09,025
obskuren Sprache in weniger komfortabel
Modus, in dem wir, das Lehrpersonal,

1569
01:18:09,025 --> 01:18:12,150
durchgemacht haben und versuchte zu vereinfachen
ein Teil der Sprache, Dinge zu halten

1570
01:18:12,150 --> 01:18:14,830
konzentrierte sich auf die Ideen, und nicht
einige der technischen Details.

1571
01:18:14,830 --> 01:18:20,070
Also denken Sie daran, reference.cs50.net
sowie andere Ressource.

1572
01:18:20,070 --> 01:18:23,800
>> Aber warum tut Stringlänge Arbeit in
die Art, wie ich vorhin vorgeschlagen?

1573
01:18:23,800 --> 01:18:25,160
Hier ist Zamyla Namen wieder.

1574
01:18:25,160 --> 01:18:27,690
Und hier ist Zamyla Name
eingekeilt, wie ich zu tun zu halten,

1575
01:18:27,690 --> 01:18:31,360
zu malen, ein Bild davon zu sein
wirklich, nur eine Folge von Zeichen.

1576
01:18:31,360 --> 01:18:34,260
Aber Zamyla existiert nicht
isoliert in einem Programm.

1577
01:18:34,260 --> 01:18:37,420
>> Wenn Sie schreiben und ein Programm ausführen,
Sie mit Ihrem Mac oder PC

1578
01:18:37,420 --> 01:18:40,010
als Speicher oder RAM sozusagen.

1579
01:18:40,010 --> 01:18:42,620
Und Sie können denken
Ihren Computer als mit

1580
01:18:42,620 --> 01:18:44,730
viele Gigabyte Speicher in diesen Tagen.

1581
01:18:44,730 --> 01:18:47,700
Und ein Gig bedeutet Milliarden,
so Milliarden von Bytes.

1582
01:18:47,700 --> 01:18:48,910
>> Aber lassen Sie uns in der Zeit zurückzuspulen.

1583
01:18:48,910 --> 01:18:51,530
Und angenommen, dass wir verwenden
eine wirklich alte Computer,

1584
01:18:51,530 --> 01:18:55,150
hat nur 32 Byte Speicher.

1585
01:18:55,150 --> 01:18:59,310
Ich konnte, auf meinem Computer-Bildschirm,
dies einfach herausziehen wie folgt.

1586
01:18:59,310 --> 01:19:05,240
>> Ich könnte einfach sagen, dass mein
Computer verfügt über alle diese Speicher.

1587
01:19:05,240 --> 01:19:08,830
Und das ist wie ein Stock des Gedächtnisses, wenn
Sie erinnern an unser Bild vom letzten Mal.

1588
01:19:08,830 --> 01:19:11,670
Und wenn ich nur teilen
dies oft genug,

1589
01:19:11,670 --> 01:19:15,040
Ich behaupte, dass ich 32 Bytes
des Speichers auf dem Bildschirm.

1590
01:19:15,040 --> 01:19:18,239
>> Nun, in der Realität, kann ich nur
ziehen, so weit auf diesem Bildschirm hier.

1591
01:19:18,239 --> 01:19:20,280
Also werde ich voran gehen,
und nur durch Konvention,

1592
01:19:20,280 --> 01:19:24,050
zeichnen Speicher meines Computers als ein
Gitter, nicht nur als eine gerade Linie.

1593
01:19:24,050 --> 01:19:28,190
Insbesondere behaupte ich jetzt, dass
Dieses Gitter, das 8 x 4 Gitter,

1594
01:19:28,190 --> 01:19:31,800
nur repräsentiert alle 32 Bytes
verfügbaren Speicher in meinem Mac,

1595
01:19:31,800 --> 01:19:33,030
oder in meinem PC.

1596
01:19:33,030 --> 01:19:34,780
Und sie wickeln
auf zwei Linien, gerade

1597
01:19:34,780 --> 01:19:38,030
da passt es auf dem Bildschirm mehr.

1598
01:19:38,030 --> 01:19:40,800
Aber dies ist das erste Byte.

1599
01:19:40,800 --> 01:19:41,990
Dies ist das zweite Byte.

1600
01:19:41,990 --> 01:19:43,300
Dies ist das dritte Byte.

1601
01:19:43,300 --> 01:19:45,310
>> Und das ist das 32. Byte.

1602
01:19:45,310 --> 01:19:52,910
Oder, wenn wir denken wie ein Computer
Wissenschaftler, das ist das Byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
So haben Sie 0 bis 31, wenn
Sie beginnen bei 0 zu zählen.

1604
01:19:55,950 --> 01:19:59,830
>> Also, wenn wir ein Programm verwenden,
dass Anrufe erhalten string,

1605
01:19:59,830 --> 01:20:05,280
und wir bekommen einen String aus dem menschlichen
wie habe ich Zamyla, Z-A-M-Y-L-A genannt,

1606
01:20:05,280 --> 01:20:09,430
Wie in der Welt tut das
Computer zu verfolgen, welche Byte,

1607
01:20:09,430 --> 01:20:12,230
die Teil des Speichers,
gehört zu dem String?

1608
01:20:12,230 --> 01:20:16,270
Mit anderen Worten, wenn wir fortfahren
Geben Sie einen anderen Namen in den Computer,

1609
01:20:16,270 --> 01:20:19,890
wie diese Andi, ruft
erhalten Zeichenfolge ein zweites Mal,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I muss in der am Ende
Computer und Speicher.

1611
01:20:23,030 --> 01:20:23,850
Aber wie?

1612
01:20:23,850 --> 01:20:29,700
>> Nun, es stellt sich heraus, dass unter der
Kapuze, welche C tut, wenn Strings Speicherung

1613
01:20:29,700 --> 01:20:35,080
dass die menschlichen Arten in oder dass
kommen aus einer anderen Quelle, ist es

1614
01:20:35,080 --> 01:20:39,190
umreißt das Ende von ihnen mit
eine spezielle character-- Backslash

1615
01:20:39,190 --> 01:20:44,750
0, die nur eine besondere Art und Weise ist
zu sagen, 80 Bits in einer Reihe.

1616
01:20:44,750 --> 01:20:47,950
>> So A-- dies ist die Nummer 97 Rückruf.

1617
01:20:47,950 --> 01:20:51,770
So einige Muster von 8 Bits
stellt Dezimalzahl 97.

1618
01:20:51,770 --> 01:20:58,070
Dieser Backslash 0 ist buchstäblich die Zahl
0, auch bekannt als nul, N-U-L, im Gegensatz zu früher,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, über die wir gesprochen haben.

1620
01:20:59,630 --> 01:21:05,700
Aber jetzt weiß nur, dass diese
0 Backslash ist nur 80 Bits in einer Reihe.

1621
01:21:05,700 --> 01:21:09,810
>> Und es ist gerade diese Linie in der
Sand, der etwas auf der linken Seite, sagt

1622
01:21:09,810 --> 01:21:12,610
gehört zu einem String oder einem Datentyp.

1623
01:21:12,610 --> 01:21:15,480
Und alles, was auf der rechten Seite
gehört zu etwas anderem.

1624
01:21:15,480 --> 01:21:17,440
Andi Namen, inzwischen
die nur optisch

1625
01:21:17,440 --> 01:21:21,310
passiert mit der anderen Leitung zu wickeln auf,
aber das ist nur ein ästhetisches Detail,

1626
01:21:21,310 --> 01:21:23,990
ähnlich ist nul beendet.

1627
01:21:23,990 --> 01:21:29,290
>> Es ist eine Reihe von einem A-N-D-I-Zeichen,
und einen fünften Geheimnis Charakter,

1628
01:21:29,290 --> 01:21:33,560
alle 0-Bits, die nur abgrenzt
das Ende von Andi Namen als auch.

1629
01:21:33,560 --> 01:21:37,120
Und wenn wir bekommen rufen Zeichenfolge ein drittes Mal
in dem Computer eine Zeichenfolge zu erhalten wie

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, ist ähnlich Maria
Name nul mit Backslash 0 beendet.

1631
01:21:44,210 --> 01:21:47,170
>> Dies ist grundlegend anders
aus wie würde ein Computer typischerweise

1632
01:21:47,170 --> 01:21:51,850
speichern Sie eine ganze Zahl oder einen Schwimmer oder andere
Datentypen immer noch, weil Rückruf,

1633
01:21:51,850 --> 01:21:57,420
eine ganze Zahl ist in der Regel 32 Bits oder
4 Byte, oder vielleicht sogar 64 Bit,

1634
01:21:57,420 --> 01:21:59,100
oder acht Bytes.

1635
01:21:59,100 --> 01:22:02,620
Aber viele Primitiven in einem Computer
in einer Programmiersprache

1636
01:22:02,620 --> 01:22:05,550
haben eine feste Anzahl von
Bytes unter dem hood--

1637
01:22:05,550 --> 01:22:08,100
vielleicht 1, vielleicht 2, vielleicht 4, vielleicht 8.

1638
01:22:08,100 --> 01:22:13,250
>> Aber Strings, durch Design, haben ein
dynamische Anzahl von Zeichen.

1639
01:22:13,250 --> 01:22:16,980
Sie wissen nicht im Voraus, bis
die menschlichen Arten in Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
oder M-A-R-I-A oder A-N-D-I. Sie wissen nicht,
wie oft der Benutzer wird zu treffen

1641
01:22:21,400 --> 01:22:22,070
die Tastatur.

1642
01:22:22,070 --> 01:22:26,490
Daher wissen Sie nicht, wie
viele Zeichen im Voraus

1643
01:22:26,490 --> 01:22:27,540
Sie gehen zu müssen.

1644
01:22:27,540 --> 01:22:31,840
>> Und so C nur irgendwie lässt wie ein
Geheimnis Brotkrumen unter der Haube

1645
01:22:31,840 --> 01:22:32,960
am Ende der Zeichenfolge.

1646
01:22:32,960 --> 01:22:39,280
Nach dem Speichern Z-A-M-Y-L-A in einem Speicher,
es bringt auch nur das Äquivalent

1647
01:22:39,280 --> 01:22:40,210
einer Periode.

1648
01:22:40,210 --> 01:22:45,060
Am Ende eines Satzes,
es stellt 80 Bits, so wie

1649
01:22:45,060 --> 01:22:49,120
zu erinnern, wo
Zamyla beginnt und endet.

1650
01:22:49,120 --> 01:22:51,490
>> Was ist also die Verbindung,
dann, zu diesem Programm?

1651
01:22:51,490 --> 01:22:55,190
Dieses Programm hier, Stirling,
ist einfach ein Mechanismus

1652
01:22:55,190 --> 01:22:57,970
für einen String bekommen
von dem Benutzer, Zeile 6.

1653
01:22:57,970 --> 01:23:01,160
Linie 7, erkläre ich eine Variable
genannt n und setzen Sie ihn auf 0 gleich.

1654
01:23:01,160 --> 01:23:08,680
>> Und dann in die Linie 8, fragte ich einfach die
Frage, während die n-te Zeichen tut

1655
01:23:08,680 --> 01:23:12,120
nicht gleich alle 0 bits--
in anderen Worten, nicht

1656
01:23:12,120 --> 01:23:14,500
gleich diese besondere
Zeichen, Backslash 0, die

1657
01:23:14,500 --> 01:23:18,470
war nur, dass spezielle nul character--
gehen Sie voran und erhöhen nur n.

1658
01:23:18,470 --> 01:23:21,460
>> Und halten Sie es zu tun, und halten Sie
es zu tun, und halten Sie es zu tun.

1659
01:23:21,460 --> 01:23:23,430
Und so, obwohl in
der Vergangenheit haben wir die ich verwendet habe,

1660
01:23:23,430 --> 01:23:25,181
es ist völlig in Ordnung,
semantisch n zu verwenden,

1661
01:23:25,181 --> 01:23:27,430
wenn Sie versuchen, nur zu
zählen diesmal bewusst,

1662
01:23:27,430 --> 01:23:28,720
und wollen einfach nur n es nennen.

1663
01:23:28,720 --> 01:23:34,720
Also das hält nur die Frage zu stellen,
ist die n-te Zeichen von s alle 0s?

1664
01:23:34,720 --> 01:23:38,470
Wenn nicht, schauen Sie auf den nächsten Look,
schauen auf die nächste, schauen auf die nächste,

1665
01:23:38,470 --> 01:23:39,460
Blick auf die nächste.

1666
01:23:39,460 --> 01:23:45,540
>> Aber sobald Sie Backslash sehen 0,
diese loop-- Linie 9 bis 11-- stoppt.

1667
01:23:45,540 --> 01:23:49,640
Sie brechen aus der while-Schleife,
Verlassen innerhalb dieser Variablen n

1668
01:23:49,640 --> 01:23:54,530
eine Gesamtzahl aller von den
Zeichen in der Zeichenfolge, die Sie gesehen haben,

1669
01:23:54,530 --> 01:23:55,660
Drucken sie damit aus.

1670
01:23:55,660 --> 01:23:56,760
Also lassen Sie uns dies versuchen.

1671
01:23:56,760 --> 01:23:59,500
>> Lassen Sie mich gehen Sie voran und ohne
mit der stirling Funktion,

1672
01:23:59,500 --> 01:24:04,240
aber nur meine eigene homegrown Version mit
mich hier stirling genannt, lassen Sie gehen voran

1673
01:24:04,240 --> 01:24:07,700
und laufen stirling, Typ in etwas
wie Zamyla, die ich im Voraus

1674
01:24:07,700 --> 01:24:08,670
ist sechs Zeichen.

1675
01:24:08,670 --> 01:24:10,080
Mal sehen, ob es funktioniert.

1676
01:24:10,080 --> 01:24:10,920
Tatsächlich ist es sechs.

1677
01:24:10,920 --> 01:24:15,257
Lassen Sie uns versuchen, mit Rob, drei Zeichen,
drei Zeichen als gut, und so weiter.

1678
01:24:15,257 --> 01:24:17,340
Also das ist alles, was los ist
auf unter der Haube.

1679
01:24:17,340 --> 01:24:19,548
Und die Verbindungen bemerken,
Dann, mit der ersten Woche

1680
01:24:19,548 --> 01:24:22,370
der Klasse, wo wir sprachen über
so etwas wie Abstraktion,

1681
01:24:22,370 --> 01:24:26,960
das ist genau diese Schichtung von Ideen, oder
Komplexität, auf der Grundprinzipien.

1682
01:24:26,960 --> 01:24:30,710
Hier sind wir eine Art suchen
unter der Haube von stirling,

1683
01:24:30,710 --> 01:24:33,510
so zu sprechen, um herauszufinden,
wie wäre es umgesetzt werden?

1684
01:24:33,510 --> 01:24:35,232
>> Und wir könnten es uns neu zu implementieren.

1685
01:24:35,232 --> 01:24:37,440
Aber wir nie wieder los
neu implementieren stirling.

1686
01:24:37,440 --> 01:24:39,780
Wir gehen nur zu
verwenden stirling um

1687
01:24:39,780 --> 01:24:42,100
zu bekommen tatsächlich einige Saiten Länge.

1688
01:24:42,100 --> 01:24:44,200
>> Aber es gibt keine Magie
unter der Haube.

1689
01:24:44,200 --> 01:24:46,716
Wenn Sie, dass unterhalb wissen
die Haube, eine Zeichenfolge

1690
01:24:46,716 --> 01:24:48,090
ist nur eine Folge von Zeichen.

1691
01:24:48,090 --> 01:24:51,090
Und dass Folge von Zeichen
werden alle numerisch adressiert

1692
01:24:51,090 --> 01:24:53,330
mit Halter 0, Halter
1, Halter 2, und Sie

1693
01:24:53,330 --> 01:24:57,420
wissen, dass ein am Ende einer Zeichenfolge ist
Sonderzeichen, können Sie herausfinden

1694
01:24:57,420 --> 01:25:01,710
wie fast alles in einem zu tun
Programm, weil alle es läuft darauf hinaus,

1695
01:25:01,710 --> 01:25:03,400
ist das Lesen und Schreiben von Speicher.

1696
01:25:03,400 --> 01:25:06,130
Das heißt, ändern und suchen
im Speicher oder bewegliche Sachen

1697
01:25:06,130 --> 01:25:10,940
um im Speicher, Druck Dinge
auf dem Bildschirm, und so weiter.

1698
01:25:10,940 --> 01:25:14,800
>> Also lassen Sie uns nun diese neu gewonnene verwenden
Verständnis dessen, was tatsächlich Saiten

1699
01:25:14,800 --> 01:25:17,910
der Haube sind darunter und
Ziehen Sie eine weitere Schicht

1700
01:25:17,910 --> 01:25:20,080
dass bis jetzt wir haben
wurde ignoriert insgesamt.

1701
01:25:20,080 --> 01:25:22,650
Insbesondere jederzeit
wir haben ein Programm implementiert,

1702
01:25:22,650 --> 01:25:25,930
wir haben diese Codezeile hatte
in der Nähe der oben erklärt Haupt.

1703
01:25:25,930 --> 01:25:27,810
Und wir haben int main ungültig angegeben.

1704
01:25:27,810 --> 01:25:31,240
>> Und diese Lücke in den Klammern
wurde die ganze Zeit sagen, dass Haupt

1705
01:25:31,240 --> 01:25:33,440
selbst nimmt keine Argumente.

1706
01:25:33,440 --> 01:25:36,210
Jede Eingabe, dass Haupt ist
gehen von dem Benutzer zu erhalten,

1707
01:25:36,210 --> 01:25:39,020
hat von einem anderen zu kommen,
Mechanismus, wie get int,

1708
01:25:39,020 --> 01:25:42,040
oder erhalten Schwimmer oder eine Zeichenfolge zu erhalten,
oder eine andere Funktion.

1709
01:25:42,040 --> 01:25:44,710
Aber es stellt sich heraus, dass
wenn Sie ein Programm schreiben,

1710
01:25:44,710 --> 01:25:47,690
Sie können tatsächlich angeben
daß das Programm

1711
01:25:47,690 --> 01:25:51,730
nehmen Eingaben von der menschlichen
in der Befehlszeile selbst.

1712
01:25:51,730 --> 01:25:56,310
>> Mit anderen Worten, obwohl wir bisher
Laufen wurden ./hello nur hallo

1713
01:25:56,310 --> 01:26:00,312
oder ähnliche Programme, die alle die
andere Programme, die wir verwendet haben,

1714
01:26:00,312 --> 01:26:02,770
dass wir uns nicht schreiben,
wurden unter, wie es scheint,

1715
01:26:02,770 --> 01:26:05,210
Befehlszeile arguments--
Dinge wie machen.

1716
01:26:05,210 --> 01:26:07,450
Sie sagen, so etwas wie Marke,
und dann ein zweites Wort.

1717
01:26:07,450 --> 01:26:10,950
Oder Klirren, sagen Sie klirren, und dann
ein zweites Wort, der Name einer Datei.

1718
01:26:10,950 --> 01:26:14,410
>> Oder sogar RM oder CP, wie Sie vielleicht
haben bereits gesehen oder verwendet

1719
01:26:14,410 --> 01:26:15,880
zu entfernen oder Dateien kopieren.

1720
01:26:15,880 --> 01:26:18,920
Wir alle, die nehmen so genannte
Befehlszeile arguments--

1721
01:26:18,920 --> 01:26:21,130
zusätzliche Wörter an der Terminal-Eingabeaufforderung.

1722
01:26:21,130 --> 01:26:23,260
Aber bis jetzt haben wir
selbst nicht gehabt haben

1723
01:26:23,260 --> 01:26:27,080
Dieses luxuriöse Eingang des Nehmens von der
tatsächlich Benutzer, wenn er oder sie läuft

1724
01:26:27,080 --> 01:26:29,120
das Programm selbst auf der Kommandozeile.

1725
01:26:29,120 --> 01:26:33,710
>> Aber wir können durch die Wieder erklärt tun
Haupt voran, nicht mit

1726
01:26:33,710 --> 01:26:36,750
nichtig in Klammern,
aber diese beiden Argumente

1727
01:26:36,750 --> 01:26:40,600
instead-- ersten eine ganze Zahl ist,
und die zweite etwas

1728
01:26:40,600 --> 01:26:44,170
Neues, etwas, das wir gehen zu nennen
ein Array ist, etwas im Geiste

1729
01:26:44,170 --> 01:26:49,220
zu dem, was wir als Liste im Scratch sah, aber
ein Array von Strings, wie wir bald sehen.

1730
01:26:49,220 --> 01:26:51,790
Aber mal sehen dies durch
beispielsweise, bevor wir

1731
01:26:51,790 --> 01:26:53,690
unterscheiden genau das, was das bedeutet.

1732
01:26:53,690 --> 01:26:56,520
>> Also, wenn ich in CS50 IDE
hier, ich habe weitergemacht

1733
01:26:56,520 --> 01:27:01,840
und in einer Datei namens erklärt
argv0.c die folgende Vorlage.

1734
01:27:01,840 --> 01:27:04,120
Und beachten Sie die einzige Sache,
das ist anders, so weit

1735
01:27:04,120 --> 01:27:08,570
ist, dass ich int geändert nichtig
argc String argv offene Klammer, in der Nähe

1736
01:27:08,570 --> 01:27:09,070
Halterung.

1737
01:27:09,070 --> 01:27:11,730
Und jetzt bemerken, gibt es
nichts innerhalb dieser Klammern.

1738
01:27:11,730 --> 01:27:12,620
>> Es gibt keine Zahl.

1739
01:27:12,620 --> 01:27:15,070
Und es gibt keine i, oder
n oder eine beliebige andere Buchstaben.

1740
01:27:15,070 --> 01:27:17,010
Ich verwende nur die
eckigen Klammern für jetzt,

1741
01:27:17,010 --> 01:27:19,510
aus Gründen kommen wir
zurück in nur einem Augenblick.

1742
01:27:19,510 --> 01:27:21,330
>> Und jetzt, was ich tun werde, ist dieses.

1743
01:27:21,330 --> 01:27:26,680
Wenn argc gleich gleich 2--
und daran erinnern, dass gleich equals

1744
01:27:26,680 --> 01:27:30,040
ist der Gleichheitsoperator Vergleich
die linke und die rechte für die Gleichstellung.

1745
01:27:30,040 --> 01:27:31,790
Es ist nicht die Zuordnung
Betreiber, die ist

1746
01:27:31,790 --> 01:27:36,510
die einzelnen Gleichheitszeichen, die Kopie bedeutet
von rechts nach links einen gewissen Wert.

1747
01:27:36,510 --> 01:27:42,840
>> Wenn argc gleich gleich 2, möchte ich
sagen wir, printf, hallo, Prozente, neue Linie,

1748
01:27:42,840 --> 01:27:47,340
und stecken Sie dann in-- und hier ist die neue
trick-- argv Halterung 1 aus Gründen

1749
01:27:47,340 --> 01:27:48,840
dass wir in einem Moment zurückkommen werde.

1750
01:27:48,840 --> 01:27:52,110
Else wenn argc nicht tut
gleich 2, weißt du was?

1751
01:27:52,110 --> 01:27:57,400
nur Fahren wir fort und, wie üblich, Druck
out Hallo Welt ohne Substitution.

1752
01:27:57,400 --> 01:28:02,710
>> So scheint es, dass, wenn argc, welche
steht für Argument zählen, gleich 2,

1753
01:28:02,710 --> 01:28:04,740
Ich werde zum Ausdrucken
hallo etwas oder andere.

1754
01:28:04,740 --> 01:28:07,560
Ansonsten wird standardmäßig, ich bin
gehen Hallo Welt zu drucken.

1755
01:28:07,560 --> 01:28:08,770
Also, was bedeutet das?

1756
01:28:08,770 --> 01:28:15,550
>> Nun, lassen Sie mich gehen Sie vor und sparen
Diese Datei, und dann argv0 tun zu machen,

1757
01:28:15,550 --> 01:28:18,940
und dann ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Und es sagt hallo Welt.

1759
01:28:20,300 --> 01:28:21,260
Nun, warum ist das so?

1760
01:28:21,260 --> 01:28:24,730
>> Nun, es stellt sich heraus, wann immer Sie
führen ein Programm in der Befehlszeile,

1761
01:28:24,730 --> 01:28:29,570
was füllen Sie wir werden
im Allgemeinen nennen ein Argument Vektor.

1762
01:28:29,570 --> 01:28:33,100
Mit anderen Worten, die automatisch
Computer, das Betriebssystem,

1763
01:28:33,100 --> 01:28:38,340
wird sich Ihr Programm zur Hand
selbst eine Liste von allen Wörtern

1764
01:28:38,340 --> 01:28:40,850
dass der menschliche typisiert an
die Aufforderung, Sie im Falle

1765
01:28:40,850 --> 01:28:43,790
der Programmierer tun wollen
etwas mit dieser Information.

1766
01:28:43,790 --> 01:28:48,540
Und in diesem Fall das einzige Wort
Ich habe an der Eingabeaufforderung eingegeben ist ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Und so die Anzahl der Argumente, die ist
wobei an mein Programm übergeben ist nur eine davon.

1768
01:28:55,420 --> 01:28:58,880
Mit anderen Worten, das Argument
zählen, sonst als argc bekannt

1769
01:28:58,880 --> 01:29:00,970
hier als eine ganze Zahl ist nur eine davon.

1770
01:29:00,970 --> 01:29:03,000
Man ist natürlich nicht gleich zwei.

1771
01:29:03,000 --> 01:29:05,980
Und so ist es das, was druckt, hallo Welt.

1772
01:29:05,980 --> 01:29:08,170
>> Aber lassen Sie mich dies irgendwo nehmen.

1773
01:29:08,170 --> 01:29:09,930
Lassen Sie mich sagen, argv0.

1774
01:29:09,930 --> 01:29:12,740
Und dann, wie etwa Maria?

1775
01:29:12,740 --> 01:29:14,990
Und dann drücken Sie die Eingabetaste.

1776
01:29:14,990 --> 01:29:18,020
>> Und bemerken, was magisch hier passiert.

1777
01:29:18,020 --> 01:29:22,640
Statt nun Hallo Welt, ich habe
das Verhalten des Programms geändert

1778
01:29:22,640 --> 01:29:26,310
durch die Eingabe nicht von get nehmen
String oder eine andere Funktion,

1779
01:29:26,310 --> 01:29:30,570
aber aus, es scheint, mein Kommando
selbst, was ich in ursprünglich eingegeben haben.

1780
01:29:30,570 --> 01:29:35,720
Und ich kann wieder dieses Spiel spielen, indem sie
Ändern es zu Stelios, zum Beispiel.

1781
01:29:35,720 --> 01:29:38,400
>> Und jetzt sehe ich noch einen anderen Namen.

1782
01:29:38,400 --> 01:29:40,540
Und hier, ich könnte Andi sagen.

1783
01:29:40,540 --> 01:29:42,137
Und ich könnte Zamyla sagen.

1784
01:29:42,137 --> 01:29:45,220
Und wir können dieses Spiel den ganzen Tag lang spielen,
nur in unterschiedlichen Werten anschließen,

1785
01:29:45,220 --> 01:29:49,550
so lange, wie ich liefern genau
zwei Wörter an der Eingabeaufforderung,

1786
01:29:49,550 --> 01:29:52,260
so dass argc, mein Argument zählen, ist 2.

1787
01:29:52,260 --> 01:29:57,240
>> Ich sehe, dass Name gesteckt
printf, pro diesem Zustand hier?

1788
01:29:57,240 --> 01:30:00,550
So scheinen wir jetzt zu haben
die Ausdrucksmöglichkeiten

1789
01:30:00,550 --> 01:30:04,410
des Nehmens Eingang von einem anderen Mechanismus,
vom sogenannten Befehlszeilen,

1790
01:30:04,410 --> 01:30:07,000
anstatt zu warten,
bis der Benutzer das Programm ausführt,

1791
01:30:07,000 --> 01:30:10,220
und dann aufgefordert, ihn oder sie
mit so etwas wie der String.

1792
01:30:10,220 --> 01:30:11,230
>> Also, was ist das?

1793
01:30:11,230 --> 01:30:15,010
ARGC wiederum ist nur eine ganze Zahl,
die Anzahl der Wörter des arguments--

1794
01:30:15,010 --> 01:30:18,540
dass der Benutzer bei der vorgesehenen
Aufforderung an das Terminal-Fenster,

1795
01:30:18,540 --> 01:30:20,110
einschließlich des Namens des Programms.

1796
01:30:20,110 --> 01:30:23,340
Also unsere ./argv0 ist, effektiv,
den Namen des Programms,

1797
01:30:23,340 --> 01:30:24,520
oder wie ich das Programm ausführen.

1798
01:30:24,520 --> 01:30:25,810
>> Das zählt als ein Wort.

1799
01:30:25,810 --> 01:30:27,080
So würde argc 1 sein.

1800
01:30:27,080 --> 01:30:29,750
Aber wenn ich schreibe Stelios, oder
Andi oder Zamyla oder Maria,

1801
01:30:29,750 --> 01:30:31,660
das bedeutet, dass das Argument Zahl ist zwei.

1802
01:30:31,660 --> 01:30:33,910
Und jetzt gibt es zwei übergebenen Worte.

1803
01:30:33,910 --> 01:30:36,070
>> Und beachten Sie, können wir diese Logik weiter.

1804
01:30:36,070 --> 01:30:39,050
Wenn ich wirklich sagen,
so etwas wie Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
ein vollständiger Name, wodurch vorbei
drei Argumente insgesamt,

1806
01:30:42,200 --> 01:30:47,410
Jetzt heißt es die Standard wieder,
denn natürlich, tut 3 2 nicht gleich.

1807
01:30:47,410 --> 01:30:54,080
>> Und so auf diese Weise habe ich
Zugang über argv dieses neue Argument

1808
01:30:54,080 --> 01:30:56,080
dass wir konnten technisch
rufen Sie alles, was wir wollen.

1809
01:30:56,080 --> 01:30:58,940
Aber durch Konvention, es ist
argv und argc sind.

1810
01:30:58,940 --> 01:31:04,470
Argv, Argument-Vektor, ist eine Art
eines Synonyms für ein Programmier

1811
01:31:04,470 --> 01:31:07,140
Funktion in C genannt ein Array.

1812
01:31:07,140 --> 01:31:14,410
>> Ein Array ist eine Liste von ähnlichen Werten
Rücken an Rücken an Rücken, an Rücken.

1813
01:31:14,410 --> 01:31:17,810
Mit anderen Worten, wenn man hier in
RAM, der nächste ist direkt neben dem Hotel,

1814
01:31:17,810 --> 01:31:18,800
und rechts daneben.

1815
01:31:18,800 --> 01:31:20,101
Sie sind nicht alle über dem Platz.

1816
01:31:20,101 --> 01:31:23,100
Und das letztere Szenario, wo die Dinge
alle über den Ort im Speicher befinden,

1817
01:31:23,100 --> 01:31:25,082
kann tatsächlich eine leistungsstarke Funktion sein.

1818
01:31:25,082 --> 01:31:28,040
Aber wir werden darauf zurückkommen, wenn wir
reden über ausgefallenere Datenstrukturen.

1819
01:31:28,040 --> 01:31:32,260
Denn jetzt ist ein Array nur eine
Batzen zusammenhängenden Speicher,

1820
01:31:32,260 --> 01:31:36,520
jeweils deren Elemente
Rücken an Rücken an Rücken an Rücken,

1821
01:31:36,520 --> 01:31:38,050
und im allgemeinen vom gleichen Typ.

1822
01:31:38,050 --> 01:31:42,630
>> Also, wenn Sie darüber nachdenken, aus einem
Moment vor, was ist ein String?

1823
01:31:42,630 --> 01:31:50,460
Nun, eine Zeichenfolge, wie Zamyla,
Z-A-M-Y-L-A, ist, technisch gesehen,

1824
01:31:50,460 --> 01:31:51,400
nur ein Array.

1825
01:31:51,400 --> 01:31:53,700
Es gibt eine Reihe von Zeichen.

1826
01:31:53,700 --> 01:31:59,250
>> Und so, wenn wir dies wirklich zu zeichnen, wie ich
früher tat, als Teil des Speichers,

1827
01:31:59,250 --> 01:32:04,510
es stellt sich heraus, dass jede dieser
Zeichen nimmt ein Byte auf.

1828
01:32:04,510 --> 01:32:07,630
Und dann gibt es diese besondere
Sentinel-Zeichen, die Backslash 0,

1829
01:32:07,630 --> 01:32:12,360
oder alle acht Bits 0, dass
abgrenzt das Ende dieser Zeichenfolge.

1830
01:32:12,360 --> 01:32:15,090
So ein String ist, es stellt sich
aus, zitieren unquote string,

1831
01:32:15,090 --> 01:32:20,580
ist nur ein Array von chara--
char eine tatsächliche Datentyp sein.

1832
01:32:20,580 --> 01:32:24,560
>> Und jetzt argv, meanwhile--
Lassen Sie uns zurück zum Programm gehen.

1833
01:32:24,560 --> 01:32:29,582
Argv, auch wenn wir das Wort sehen
String hier ist kein String selbst.

1834
01:32:29,582 --> 01:32:33,640
Argv, Argument-Vektor,
ist ein Array von Strings.

1835
01:32:33,640 --> 01:32:37,620
>> So wie können Sie ein Array von
Zeichen, können Sie höhere Ebene haben,

1836
01:32:37,620 --> 01:32:46,279
ein Array von strings-- so, zum Beispiel,
wenn ich einen Moment getippt vor ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, Raum Z-A-M-Y-L-A, I behauptete,
argv hatte zwei Saiten in es-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
und Z-A-M-Y-L-A. Im
argc anderen Worten war 2.

1839
01:33:03,185 --> 01:33:03,980
Warum das?

1840
01:33:03,980 --> 01:33:08,370
>> Nun, effektiv, was los ist
eingeschaltet ist, daß jeder dieser Zeichenfolgen

1841
01:33:08,370 --> 01:33:13,990
ein Array von Zeichen ist, natürlich,
wie zuvor, jeweils deren Charaktere

1842
01:33:13,990 --> 01:33:15,670
ein Byte in Anspruch nimmt.

1843
01:33:15,670 --> 01:33:19,720
Und nicht zu verwechseln die tatsächliche 0
im Namen des Programms mit der 0,

1844
01:33:19,720 --> 01:33:22,040
was bedeutet, dass alle 80 Bits.

1845
01:33:22,040 --> 01:33:27,140
Und Zamyla, mittlerweile ist immer noch
auch eine Reihe von Zeichen.

1846
01:33:27,140 --> 01:33:31,450
>> So dass am Ende des Tages, ist es wirklich
sieht aus wie diese unter der Haube.

1847
01:33:31,450 --> 01:33:38,800
Aber argv, von der Natur, wie Haupt
Werke, ermöglicht es mir, dies alles zu wickeln

1848
01:33:38,800 --> 01:33:44,810
up in, wenn man so will, ein größeres Array
dass, wenn wir über etwas vereinfachen

1849
01:33:44,810 --> 01:33:48,180
was das Bild aussieht und nicht
ziehen es ganz maßstabs dort oben,

1850
01:33:48,180 --> 01:33:56,720
Diese Anordnung ist nur der Größe 2, wobei die erste
Element, von denen eine Zeichenfolge enthält,

1851
01:33:56,720 --> 01:33:59,230
das zweite Element des
die eine Zeichenfolge enthält.

1852
01:33:59,230 --> 01:34:01,687
Und wiederum, wenn Sie
Art von Zoom auf jeder

1853
01:34:01,687 --> 01:34:03,770
dieser Strings, was Sie
siehe unter der Haube

1854
01:34:03,770 --> 01:34:07,190
ist, dass jede Saite gerade ist
ein Array von Zeichen.

1855
01:34:07,190 --> 01:34:11,680
>> Nun, genauso wie mit Streichern,
konnten wir Zugang zu erhalten

1856
01:34:11,680 --> 01:34:15,260
zum i-ten Zeichen in einer Zeichenfolge
mit, dass eckige Klammer-Notation.

1857
01:34:15,260 --> 01:34:17,320
In ähnlicher Weise mit Arrays
Im Allgemeinen können wir

1858
01:34:17,320 --> 01:34:22,700
Verwenden Sie eckige Klammer-Notation zu erhalten
bei einer beliebigen Anzahl von Strings in einem Array?

1859
01:34:22,700 --> 01:34:25,100
mich Zum Beispiel lassen
gehen Sie vor und tun dies.

1860
01:34:25,100 --> 01:34:32,420
>> Lassen Sie mich gehen Sie vor und erstellen argv1.c,
Das ist ein wenig anders diesmal.

1861
01:34:32,420 --> 01:34:35,635
Statt Überprüfung für argc2,
Ich werde stattdessen das tun.

1862
01:34:35,635 --> 01:34:41,270
Für int I 0 zu erhalten, ist ich weniger
als argc, I plus plus,

1863
01:34:41,270 --> 01:34:47,920
und dann innerhalb dieses ausdrucken,
Prozent s, neue Zeile, und dann

1864
01:34:47,920 --> 01:34:50,740
argv Halterung i.

1865
01:34:50,740 --> 01:34:55,220
>> Also mit anderen Worten, zu tun habe ich nicht mit
einzelne Zeichen im Moment.

1866
01:34:55,220 --> 01:35:00,190
Argv, wie von diesen leeren Platz impliziert
Zahnspange nach rechts des Namens argv,

1867
01:35:00,190 --> 01:35:03,320
bedeutet argv ein Array von Strings ist.

1868
01:35:03,320 --> 01:35:04,870
Und argc ist nur ein int.

1869
01:35:04,870 --> 01:35:08,800
>> Diese Linie hier, 6, ist
Satz sagen i gleich 0 bis.

1870
01:35:08,800 --> 01:35:11,980
Zählen Sie den ganzen Weg bis zu,
jedoch nicht einschließlich, argc.

1871
01:35:11,980 --> 01:35:14,010
Und dann bei jeder Iteration,
drucken Sie eine Zeichenfolge aus.

1872
01:35:14,010 --> 01:35:14,800
Was String?

1873
01:35:14,800 --> 01:35:17,270
>> Die i-ten String in argv.

1874
01:35:17,270 --> 01:35:19,530
Während also bevor ich war
mit der eckigen Klammer

1875
01:35:19,530 --> 01:35:22,180
Notation beim i-ten zu erhalten
Zeichen in einer Zeichenkette, jetzt

1876
01:35:22,180 --> 01:35:27,240
Ich bin mit der eckigen Klammer-Notation
beim i-ten String in einem Array zu erhalten.

1877
01:35:27,240 --> 01:35:30,310
Also es ist eine Art von einer Schicht
oben, vom Konzept her.

1878
01:35:30,310 --> 01:35:35,390
>> Und so was ist ordentlich darüber
jetzt Programm, wenn ich kompilieren argv1,

1879
01:35:35,390 --> 01:35:42,067
und dann tun ./argv1, und geben Sie
in so etwas wie foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
Welches sind die drei Standard-Wörter, die eine
Informatiker greift nach jeder Zeit

1881
01:35:45,400 --> 01:35:51,010
er oder sie braucht einige Platzhalter Worte,
und drücken Sie die Eingabetaste, jedes dieser Worte,

1882
01:35:51,010 --> 01:35:54,980
einschließlich des Namens des Programms, das
an der ersten Stelle in argv ist,

1883
01:35:54,980 --> 01:35:58,320
endet ein zu einer Zeit gedruckt werden.

1884
01:35:58,320 --> 01:36:05,290
Und wenn ich das ändern, und ich sage,
so etwas wie argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
wir bekommen alle drei von denen,
Worte, die argv0 ist,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, weil in diesem
Fall argc, ist der Zähler, 3.

1887
01:36:14,400 --> 01:36:20,020
>> Aber was ordentlich ist, ist, wenn Sie verstehen,
dass argv ist nur ein Array von Strings,

1888
01:36:20,020 --> 01:36:24,910
und Sie verstehen, dass ein String
ist ein Feld von Zeichen,

1889
01:36:24,910 --> 01:36:29,470
wir können Art tatsächlich nutzen diese
eckige Klammer-Notation mehrere Male

1890
01:36:29,470 --> 01:36:33,320
zu wählen, eine Zeichenfolge, und wählen Sie dann
ein Zeichen innerhalb der Zeichenfolge,

1891
01:36:33,320 --> 01:36:35,730
Tauchen in tiefer wie folgt.

1892
01:36:35,730 --> 01:36:40,100
In diesem Beispiel, lassen Sie mich gehen
diese argv2.c voraus und rufen.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Und in diesem Beispiel, lassen Sie mich gehen voran
und tun das following-- für int i 0 erhalten,

1895
01:36:50,180 --> 01:36:53,286
i kleiner als argc, i plus
plus, genau wie zuvor.

1896
01:36:53,286 --> 01:36:55,910
Also mit anderen Wörter des und jetzt das
genug ist immer kompliziert.

1897
01:36:55,910 --> 01:36:59,940
Dann werde ich sagen
iterieren Strings in argv,

1898
01:36:59,940 --> 01:37:01,294
als Kommentar zu mir selbst.

1899
01:37:01,294 --> 01:37:03,960
Und dann werde ich ein Baby haben
verschachtelte for-Schleife, die Sie wahrscheinlich

1900
01:37:03,960 --> 01:37:06,290
getan haben, oder in Betracht gezogen
tun, in Scratch, wo

1901
01:37:06,290 --> 01:37:08,600
Ich werde sagen, ich bin int--
nicht, dass ich wieder in Gang zu verwenden,

1902
01:37:08,600 --> 01:37:12,590
weil ich nicht Schatten wollen, oder
Art der bestehenden i überschrieben.

1903
01:37:12,590 --> 01:37:15,780
>> Ich werde stattdessen j sagen, weil
das ist mein gehen zu Variable nach i,

1904
01:37:15,780 --> 01:37:18,590
wenn ich versuche nur zu
zählen einfache Zahlen.

1905
01:37:18,590 --> 01:37:28,850
Für j erhält 0-- und auch, n, wird zu
Holen Sie sich die Heck Länge von argv Klammer i,

1906
01:37:28,850 --> 01:37:36,030
solange j kleiner als m,
j plus plus, gehen Sie wie folgt vor.

1907
01:37:36,030 --> 01:37:37,500
Und hier ist der interessante Teil.

1908
01:37:37,500 --> 01:37:46,330
>> Drucken Sie einen Charakter und eine neue Linie,
Einstecken in argv Klammer i, j Klammer.

1909
01:37:46,330 --> 01:37:47,940
OK, so lassen Sie mich hier einige Kommentare hinzufügen.

1910
01:37:47,940 --> 01:37:54,820
Iterate Zeichen über
in aktuellen String,

1911
01:37:54,820 --> 01:38:02,290
Druck j-te Zeichen in i-ten String.

1912
01:38:02,290 --> 01:38:04,630
So, jetzt lassen Sie uns betrachten
Was bedeuten diese Kommentare.

1913
01:38:04,630 --> 01:38:06,750
>> Iterate über die Saiten
in argv--, wie viele

1914
01:38:06,750 --> 01:38:09,300
Strings sind in argv, das ist ein Array?

1915
01:38:09,300 --> 01:38:13,420
ARGC viele, also bin ich Iterieren
von i gleich 0 bis argc.

1916
01:38:13,420 --> 01:38:20,020
Inzwischen, wie viele Zeichen
sind in der i-ten String argv in?

1917
01:38:20,020 --> 01:38:22,880
>> Nun, um die Antwort zu bekommen,
Ich nenne nur String-Länge

1918
01:38:22,880 --> 01:38:26,810
auf dem aktuellen String ich Pflege
über, das ist argv Halterung i.

1919
01:38:26,810 --> 01:38:30,090
Und ich werde vorübergehend zu speichern, dass
Wert in n, nur für den Zweck der Speicherung,

1920
01:38:30,090 --> 01:38:31,590
daran zu erinnern, es für die Effizienz.

1921
01:38:31,590 --> 01:38:36,330
Und dann geht ich j auf 0 initialisiert werden,
halten zu gehen, solange j kleiner als n ist,

1922
01:38:36,330 --> 01:38:38,430
und bei jeder Iteration Inkrement j.

1923
01:38:38,430 --> 01:38:41,030
>> Und dann hier, per
mein Kommentar in Zeile 12,

1924
01:38:41,030 --> 01:38:43,390
drucken Sie einen Charakter aus,
gefolgt von einer neuen Zeile,

1925
01:38:43,390 --> 01:38:48,140
speziell argv Halterung
i gibt mir die i-ten String

1926
01:38:48,140 --> 01:38:51,690
in argv-- so das erste Wort, das
zweite Wort, das dritte Wort, was auch immer.

1927
01:38:51,690 --> 01:38:57,370
Und dann j Tauchgänge in tiefer, und bekommt
mir die j-te Zeichen des Wortes.

1928
01:38:57,370 --> 01:39:02,200
Und so, in der Tat, können Sie behandeln
argv als mehrdimensionale,

1929
01:39:02,200 --> 01:39:06,050
als zweidimensionales Array,
wobei jedes Wort Art von Aussehen

1930
01:39:06,050 --> 01:39:08,580
wie dies in Ihrem geistigen
Auge, und jedes Zeichen

1931
01:39:08,580 --> 01:39:10,930
ist eine Art komponiert
eine Säule, ob das hilft.

1932
01:39:10,930 --> 01:39:13,260
>> In Wirklichkeit, wenn wir necken
diese auseinander in Zukunft Wochen,

1933
01:39:13,260 --> 01:39:15,580
es wird ein wenig zu sein,
anspruchsvoller als das.

1934
01:39:15,580 --> 01:39:17,800
Aber man kann wirklich
denken Sie an, dass für jetzt,

1935
01:39:17,800 --> 01:39:22,110
wie gerade dieser zweidimensionalen
Array, wobei eine Ebene davon

1936
01:39:22,110 --> 01:39:23,260
ist alle Saiten.

1937
01:39:23,260 --> 01:39:26,760
Und dann tauchen, wenn Sie in tiefer, Sie
kann an den einzelnen Zeichen erhalten

1938
01:39:26,760 --> 01:39:29,600
darin durch diese Notation hier verwendet wird.

1939
01:39:29,600 --> 01:39:31,620
>> Also, was ist der Netto-Effekt?

1940
01:39:31,620 --> 01:39:34,970
Lassen Sie mich gehen Sie vor und
machen argv2-- darn es.

1941
01:39:34,970 --> 01:39:36,210
Ich habe hier einen Fehler gemacht.

1942
01:39:36,210 --> 01:39:40,160
Implizit erklärt die
Bibliotheksfunktion stirling.

1943
01:39:40,160 --> 01:39:42,190
Also die ganze Zeit, es ist
vielleicht angebracht

1944
01:39:42,190 --> 01:39:45,130
dass wir eine Art sind Finishing
genau dort, wo wir angefangen haben.

1945
01:39:45,130 --> 01:39:48,160
>> Ich vermasselt, implizit erklärt
Bibliotheksfunktion stirling.

1946
01:39:48,160 --> 01:39:48,987
Okay, warte eine Minute.

1947
01:39:48,987 --> 01:39:51,070
Ich erinnere mich, dass vor allem
da ist es hier richtig.

1948
01:39:51,070 --> 01:39:54,490
Ich muss schließen string.h in
Diese Version des Programms.

1949
01:39:54,490 --> 01:40:00,050
>> Lassen Sie mich gehen Sie vor und schließen
string.h, außer dass, gehen Sie vor

1950
01:40:00,050 --> 01:40:04,460
und neu kompilieren argv2.

1951
01:40:04,460 --> 01:40:08,390
Und jetzt, hier gehen wir, machen argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Und obwohl es ist ein wenig
kryptische auf den ersten Blick,

1953
01:40:10,590 --> 01:40:15,690
feststellen, dass in der Tat, was
gedruckt wird, ist Punkt argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Aber wenn ich ein paar Worte nach der Art
Prompt, wie argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Geben Sie auch ein wenig
auf den ersten Blick kryptisch.

1956
01:40:22,560 --> 01:40:30,540
Aber wenn wir zurückblättern oben,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Deshalb haben wir uns über jedes Wort wiederholt.

1958
01:40:32,190 --> 01:40:37,770
Und wiederum haben wir iteriert
jedes Zeichen innerhalb eines Wortes.

1959
01:40:37,770 --> 01:40:40,040
>> Jetzt, nach all dieser,
erkennen, dass es

1960
01:40:40,040 --> 01:40:43,120
ein weiteres Detail, das wir haben Art gewesen
ignorieren die ganze Zeit.

1961
01:40:43,120 --> 01:40:46,180
Wir neckten einfach auseinander, was
Haupt der Eingänge kann das sein?

1962
01:40:46,180 --> 01:40:47,780
Was Ausgabe Haupt?

1963
01:40:47,780 --> 01:40:50,540
>> All diese Zeit haben wir schon
nur das Kopieren und Einfügen

1964
01:40:50,540 --> 01:40:53,870
das Wort int vor main,
obwohl Sie online sehen kann,

1965
01:40:53,870 --> 01:40:58,340
manchmal falsch in älteren Versionen
von C und Compiler, dass sie sagen, Leere,

1966
01:40:58,340 --> 01:40:59,410
oder gar nichts.

1967
01:40:59,410 --> 01:41:01,580
Aber in der Tat, für die Version
von C, die wir verwenden,

1968
01:41:01,580 --> 01:41:06,180
C 11 oder 2011 realisieren
dass es sollte int sein.

1969
01:41:06,180 --> 01:41:09,300
Und es sollte entweder sein
Leere oder argc und argv hier.

1970
01:41:09,300 --> 01:41:10,790
>> Aber warum int main?

1971
01:41:10,790 --> 01:41:12,480
Was kehrt es eigentlich?

1972
01:41:12,480 --> 01:41:16,280
Nun stellt sich all dieser Zeit heraus,
jedes Mal, wenn ich ein Programm geschrieben Haupt

1973
01:41:16,280 --> 01:41:18,440
immer zurückkehrt etwas.

1974
01:41:18,440 --> 01:41:19,960
Aber es ist schon so heimlich tun.

1975
01:41:19,960 --> 01:41:23,350
>> Das ist etwas ein
int, als Linie 5 vermuten lässt.

1976
01:41:23,350 --> 01:41:24,225
Aber was int?

1977
01:41:24,225 --> 01:41:26,100
Nun, es ist das
Konvention in der Programmierung,

1978
01:41:26,100 --> 01:41:29,790
wobei, wenn nichts
schief gegangen und alles ist gut,

1979
01:41:29,790 --> 01:41:34,250
Programme und Funktionen im Allgemeinen
return-- etwas counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 im Allgemeinen bedeutet, alles ist gut.

1982
01:41:38,070 --> 01:41:40,610
Also auch wenn Sie denken
es als falsch in vielen Zusammenhängen,

1983
01:41:40,610 --> 01:41:42,930
es eigentlich bedeutet im Allgemeinen eine gute Sache

1984
01:41:42,930 --> 01:41:49,560
>> Unterdessen, wenn ein Programm 1 zurückkehrt,
oder negativ 1, oder 5, oder negative 42,

1985
01:41:49,560 --> 01:41:52,941
oder jede nicht den Wert 0,
dass in der Regel bedeutet,

1986
01:41:52,941 --> 01:41:54,190
dass etwas schief gegangen ist.

1987
01:41:54,190 --> 01:41:56,700
In der Tat, auf dem eigenen Mac oder PC,
Sie könnte in der Tat gesehen

1988
01:41:56,700 --> 01:42:01,050
eine Fehlermeldung, wobei es
etwas oder andere sagt, Fehler

1989
01:42:01,050 --> 01:42:04,940
Code negativ 42 oder Fehlercode
23, oder so ähnlich.

1990
01:42:04,940 --> 01:42:08,980
Diese Zahl ist in der Regel nur ein Hinweis
dem Programmierer oder das Unternehmen

1991
01:42:08,980 --> 01:42:11,174
das machte die Software,
was schief gelaufen ist und warum,

1992
01:42:11,174 --> 01:42:13,590
so dass sie aussehen durch können
deren Dokumentation oder Code,

1993
01:42:13,590 --> 01:42:15,465
und herauszufinden, was die
Fehler eigentlich bedeutet.

1994
01:42:15,465 --> 01:42:18,400
Es ist im Allgemeinen nicht
nützlich für uns Endverbraucher.

1995
01:42:18,400 --> 01:42:20,550
>> Aber als Haupt liefert 0, alles ist gut.

1996
01:42:20,550 --> 01:42:23,770
Und wenn Sie nicht angeben
welche Haupt zurückkehren sollte,

1997
01:42:23,770 --> 01:42:26,950
es wird nur automatisch
return 0 für Sie.

1998
01:42:26,950 --> 01:42:30,870
Aber Rückkehr etwas
sonst ist wirklich nützlich.

1999
01:42:30,870 --> 01:42:34,660
>> In diesem letzten Programm, lassen Sie mich
gehen Sie vor und nennen diese exit.c,

2000
01:42:34,660 --> 01:42:38,630
und die Einführung der letzte der heutigen
Themen, als Fehlercode bekannt.

2001
01:42:38,630 --> 01:42:42,930
Lassen Sie mich gehen Sie vor und schließen unsere
vertraute Dateien bis oben, tun int main.

2002
01:42:42,930 --> 01:42:49,500
Und dieses Mal, lassen Sie uns int argc tun,
String argv, und mit meiner Klammern

2003
01:42:49,500 --> 01:42:50,836
zu implizieren, dass sie in dem Array ist.

2004
01:42:50,836 --> 01:42:52,460
Und dann lassen Sie mich nur eine Plausibilitätsprüfung tun.

2005
01:42:52,460 --> 01:42:56,640
Dieses Mal, wenn nicht argc
gleich 2, wissen Sie, was dann?

2006
01:42:56,640 --> 01:42:57,520
Vergiss es.

2007
01:42:57,520 --> 01:43:03,170
Ich werde das zu sagen, hey, Benutzer,
Sie vermissen Kommandozeilenargument

2008
01:43:03,170 --> 01:43:04,210
Backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> Und dann ist es das.

2010
01:43:05,230 --> 01:43:06,130
Ich möchte zu verlassen.

2011
01:43:06,130 --> 01:43:11,030
Ich werde präventiv,
und vorzeitig wirklich, Rückkehr

2012
01:43:11,030 --> 01:43:12,810
etwas anderes als die Nummer 1.

2013
01:43:12,810 --> 01:43:15,360
Der Sprung auf den Wert für die erste
Fehler passieren kann, ist 1.

2014
01:43:15,360 --> 01:43:17,860
Wenn Sie eine andere fehlerhafte
Situation, die auftreten können,

2015
01:43:17,860 --> 01:43:21,390
Sie könnten sagen, Rückkehr 2 oder 3 zurückzukehren, oder
vielleicht sogar negativ 1 oder negativ 2.

2016
01:43:21,390 --> 01:43:23,750
>> Dies sind nur Exit-Codes
das sind im allgemeinen,

2017
01:43:23,750 --> 01:43:27,770
nur nützlich für den Programmierer oder
Unternehmen, die die Software und Versandkosten.

2018
01:43:27,770 --> 01:43:30,500
Aber die Tatsache, dass es
nicht gleich 0 ist, was wichtig ist.

2019
01:43:30,500 --> 01:43:34,310
Also, wenn in diesem Programm möchte ich
garantieren, dass dieses Programm nur

2020
01:43:34,310 --> 01:43:38,190
funktioniert, wenn der Benutzer mir bietet
mit einem Argument Zahl von zwei,

2021
01:43:38,190 --> 01:43:42,880
der Name des Programms, und einige andere
Wort, ich kann so viel erzwingen wie folgt,

2022
01:43:42,880 --> 01:43:46,110
anschreien Benutzer mit printf sagen,
Befehlszeilenargument fehlt,

2023
01:43:46,110 --> 01:43:46,970
1 zurückzukehren.

2024
01:43:46,970 --> 01:43:49,940
Das wird nur sofort
beenden Sie das Programm.

2025
01:43:49,940 --> 01:43:55,840
>> Nur wenn argc gleich 2 werden wir bekommen nach unten
hier, an welcher Stelle ich werde sagen,

2026
01:43:55,840 --> 01:44:00,410
hallo Prozent s, Backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Mit anderen Worten, ich bin
nicht nach argv gehen 0,

2028
01:44:03,827 --> 01:44:05,410
das ist nur der Name des Programms.

2029
01:44:05,410 --> 01:44:09,450
Ich möchte hallo auszudrucken, Komma,
das zweite Wort, das der menschliche getippt.

2030
01:44:09,450 --> 01:44:12,580
Und in diesem Fall auf
Linie 13, ist alles gut.

2031
01:44:12,580 --> 01:44:15,920
>> Ich weiß, dass argc 2
logisch aus diesem Programm.

2032
01:44:15,920 --> 01:44:17,770
Ich gehe voran gehen und 0 zurück.

2033
01:44:17,770 --> 01:44:21,230
Als Nebenwirkung, bedenken Sie, dass
dies ist in Scratch als auch wahr.

2034
01:44:21,230 --> 01:44:24,760
>> Logischerweise konnte ich dies tun
und kapseln diese Zeilen

2035
01:44:24,760 --> 01:44:27,020
hier der Code in diesem else-Klausel.

2036
01:44:27,020 --> 01:44:29,420
Aber das ist eine Art von
unnötig Einrücken meinen Code.

2037
01:44:29,420 --> 01:44:31,800
Und ich möchte, Super zu machen
klar, dass, egal was,

2038
01:44:31,800 --> 01:44:34,670
standardmäßig, hallo
etwas erhalten gedruckt,

2039
01:44:34,670 --> 01:44:36,050
solange der Benutzer arbeitet.

2040
01:44:36,050 --> 01:44:39,360
>> So ist es sehr häufig zu verwenden,
ein Zustand, ein nur wenn,

2041
01:44:39,360 --> 01:44:41,870
zu fangen einige fehlerhafte
Situation, und dann beenden.

2042
01:44:41,870 --> 01:44:45,690
Und dann, so lange alles
na ja, nicht ein anderes haben,

2043
01:44:45,690 --> 01:44:48,060
aber haben nur den Code
außen, dass, wenn, weil es

2044
01:44:48,060 --> 01:44:51,060
In diesem Ersatz
besonderen Fall logisch.

2045
01:44:51,060 --> 01:44:54,480
Also ich bin der Rückkehr 0, nur um
ausdrücklich bedeuten alles gut ist.

2046
01:44:54,480 --> 01:44:58,480
>> Wenn ich die Rückkehr 0, weggelassen würde es
werden automatisch für mich übernommen.

2047
01:44:58,480 --> 01:45:00,890
Aber jetzt, dass ich zurückkehren
ein zumindest in diesem Fall,

2048
01:45:00,890 --> 01:45:04,940
Ich werde, für eine gute Maßnahme und
Klarheit zurückkehren 0 in diesem Fall.

2049
01:45:04,940 --> 01:45:09,690
Also lassen Sie mich jetzt gehen Sie vor und Ausfahrt zu machen,
Das ist ein perfekter Übergang zu einfach gehen.

2050
01:45:09,690 --> 01:45:14,401
>> Aber stellen Sie Exit ein, und lassen Sie mich gehen
Sie voran und tun ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Und das Programm schrie mich an,
Kommandozeilenargument fehlt.

2052
01:45:16,900 --> 01:45:18,120
OK, lassen Sie mich zusammenarbeiten.

2053
01:45:18,120 --> 01:45:23,810
>> Lassen Sie mich stattdessen tun ./exit, David, ein.

2054
01:45:23,810 --> 01:45:25,190
Und jetzt sagt er, hallo David.

2055
01:45:25,190 --> 01:45:27,300
Und Sie würden diese normalerweise nicht zu sehen.

2056
01:45:27,300 --> 01:45:30,650
>> Aber es stellt sich heraus, dass es eine
besondere Art und Weise in Linux, um tatsächlich sehen

2057
01:45:30,650 --> 01:45:34,470
mit welchem ​​Exit-Code ein Programm verlassen.

2058
01:45:34,470 --> 01:45:37,184
Manchmal in einer grafischen
Welt wie Mac OS oder Windows,

2059
01:45:37,184 --> 01:45:40,100
Sie sehen nur diese Zahlen, wenn ein
Fehlermeldung erscheint auf dem Bildschirm

2060
01:45:40,100 --> 01:45:41,940
und der Programmierer
zeigt Ihnen diese Nummer.

2061
01:45:41,940 --> 01:45:44,773
Aber wenn wir wollen, um zu sehen, was der Fehler
Nachricht ist, wir können es tun hier--

2062
01:45:44,773 --> 01:45:48,100
so ./exit, eingeben, drucken
Kommandozeilenargument fehlt.

2063
01:45:48,100 --> 01:45:54,590
>> Wenn ich jetzt echo $ tun ?, das ist
lächerlich kryptischen suchen.

2064
01:45:54,590 --> 01:45:56,590
Aber $?

2065
01:45:56,590 --> 01:45:59,220
ist die magische Beschwörung
das sagt, hey, Computer,

2066
01:45:59,220 --> 01:46:01,900
sag mir, was die vorherige
Programm der Exit-Code war.

2067
01:46:01,900 --> 01:46:03,410
Und ich drücken Sie die Eingabetaste.

2068
01:46:03,410 --> 01:46:07,520
Ich sehe ein, denn das ist, was ich
sagte meine Hauptfunktion zurückzukehren.

2069
01:46:07,520 --> 01:46:12,310
>> Inzwischen, wenn ich David tun ./exit,
und drücken Sie die Eingabetaste, ich sehe, hallo David.

2070
01:46:12,310 --> 01:46:16,800
Und wenn ich jetzt echo $ tun ?, ich sehe, hallo 0.

2071
01:46:16,800 --> 01:46:19,080
Und so wird diese tatsächlich
werden wertvolle Informationen

2072
01:46:19,080 --> 01:46:23,420
im Rahmen des Debuggers, nicht so
sehr, dass Sie, kümmern würde der Mensch.

2073
01:46:23,420 --> 01:46:26,060
Aber der Debugger und andere
Programme werden wir in diesem Semester nutzen

2074
01:46:26,060 --> 01:46:29,420
sehen oft wird bei dieser Zahl,
obwohl es ist eine Art versteckt

2075
01:46:29,420 --> 01:46:32,780
es sei denn, Sie danach suchen, zu
bestimmen, ob ein Programm der

2076
01:46:32,780 --> 01:46:37,050
Ausführung richtig oder falsch war.

2077
01:46:37,050 --> 01:46:40,450
>> Und so bringt uns das zu
Damit am Ende des Tages.

2078
01:46:40,450 --> 01:46:43,917
Wir begannen heute, indem man
Debuggen und wiederum auf dem Golfplatz

2079
01:46:43,917 --> 01:46:46,750
selbst, und dann noch interessanter ist,
technisch unter der Haube

2080
01:46:46,750 --> 01:46:49,490
zu welchem ​​Strings sind, die im letzten
Woche nahmen wir für selbstverständlich,

2081
01:46:49,490 --> 01:46:51,900
und nahm sie sicherlich
in Scratch gewährt.

2082
01:46:51,900 --> 01:46:56,040
>> Wir haben uns dann an, wie wir zugreifen können
einzelne Zeichen in einer Zeichenfolge,

2083
01:46:56,040 --> 01:47:00,310
und dann nahm wieder ein höheres Niveau
Blick auf die Dinge, schauen, wie well--

2084
01:47:00,310 --> 01:47:04,226
wenn wir wollen, an den einzelnen zu bekommen
Elemente in einer Liste wie Struktur,

2085
01:47:04,226 --> 01:47:05,850
können wir nicht tun, dass mit mehreren Strings?

2086
01:47:05,850 --> 01:47:08,050
Und wir können mit Kommandozeilenargumenten.

2087
01:47:08,050 --> 01:47:12,800
Aber dieses Bild hier nur Boxen
ist demonstrative dieser allgemeinen Idee

2088
01:47:12,800 --> 01:47:14,451
eines Arrays oder einer Liste oder einem Vektor.

2089
01:47:14,451 --> 01:47:16,450
Und je nach den
Zusammenhang all dieser Worte

2090
01:47:16,450 --> 01:47:17,880
bedeuten geringfügig unterschiedliche Dinge.

2091
01:47:17,880 --> 01:47:20,060
So in C, wir gehen nur
über ein Array zu sprechen.

2092
01:47:20,060 --> 01:47:23,840
Und ein Array ist ein chunk
Speicher, von denen jeder ist,

2093
01:47:23,840 --> 01:47:27,720
Elemente aneinandergrenzen, zurück,
zurück, um wieder nach hinten.

2094
01:47:27,720 --> 01:47:31,970
>> Und diese Elemente sind, im allgemeinen,
von demselben Datentyp, Zeichen,

2095
01:47:31,970 --> 01:47:35,966
Zeichen, Zeichen, Zeichen, oder
string, string, string, string oder int,

2096
01:47:35,966 --> 01:47:38,600
int, int, was es ist,
wir versuchen, zu speichern.

2097
01:47:38,600 --> 01:47:42,540
Aber am Ende des Tages, das ist
was es sieht aus wie konzeptionell.

2098
01:47:42,540 --> 01:47:44,530
Sie nehmen Ihre
Computer-Speicher oder RAM.

2099
01:47:44,530 --> 01:47:48,590
Und Sie Carving es aus in
gleich große Kisten, von denen alle

2100
01:47:48,590 --> 01:47:50,920
sind Rücken an Rücken, zu
zurück, auf diese Weise zu sichern.

2101
01:47:50,920 --> 01:47:53,200
>> Und was ist schön, über
Diese Idee und die Tatsache

2102
01:47:53,200 --> 01:47:58,580
dass wir Werte auf diese Weise zum Ausdruck bringen
mit dem ersten der Datenstrukturen

2103
01:47:58,580 --> 01:48:02,520
in der Klasse, bedeutet, dass wir beginnen
Probleme mit dem Code zu lösen

2104
01:48:02,520 --> 01:48:04,079
das kam so intuitiv in Woche 0.

2105
01:48:04,079 --> 01:48:05,870
Sie werden das Telefon Rückruf
Buchbeispiel, wo

2106
01:48:05,870 --> 01:48:09,110
wir verwendet, um eine teile und herrsche,
oder eine binäre Suchalgorithmus,

2107
01:48:09,110 --> 01:48:13,220
durch eine ganze zu sichten
Bündel von Namen und Nummern.

2108
01:48:13,220 --> 01:48:18,220
Aber wir davon ausgegangen, Rückruf, dass die
Telefonbuch wurde bereits sortiert,

2109
01:48:18,220 --> 01:48:21,630
dass jemand anderes hatte bereits
gemustert out-- eine Liste von Namen gegeben

2110
01:48:21,630 --> 01:48:24,430
und numbers--, wie man sie alphabetisiert.

2111
01:48:24,430 --> 01:48:26,950
Und jetzt, da in C wir,
Auch haben die Fähigkeit,

2112
01:48:26,950 --> 01:48:30,290
zu legen Dinge, nicht
körperlich in einem Telefonbuch

2113
01:48:30,290 --> 01:48:34,220
sondern praktisch in ein Computer
Speicher, können wir nächste Woche

2114
01:48:34,220 --> 01:48:38,470
einzuführen wieder this-- ersten
unserer Datenstrukturen in einem array--

2115
01:48:38,470 --> 01:48:43,530
aber was noch wichtiger ist, tatsächliche Computer
Wissenschaft Algorithmen implementiert

2116
01:48:43,530 --> 01:48:47,720
in Code, mit dem wir speichern
Daten in Strukturen wie diese,

2117
01:48:47,720 --> 01:48:50,730
und dann beginnen sie zu manipulieren, und
um tatsächlich mit ihm Probleme zu lösen,

2118
01:48:50,730 --> 01:48:53,570
und obendrein zu bauen,
Letztlich Programme in C,

2119
01:48:53,570 --> 01:48:56,730
in Python, in JavaScript,
Abfragen von Datenbanken mit SQL?

2120
01:48:56,730 --> 01:48:59,980
>> sehen und wir werden feststellen, dass alle diese
verschiedene Ideen ineinander greifen.

2121
01:48:59,980 --> 01:49:04,100
Aber jetzt, daran erinnern, dass die
Domäne, die wir heute vorstellen

2122
01:49:04,100 --> 01:49:06,920
hier war das Ding, und
die Welt der Kryptographie.

2123
01:49:06,920 --> 01:49:11,200
Und unter den nächsten Probleme, die Sie selbst
lösen wird, ist die Kunst der Kryptographie,

2124
01:49:11,200 --> 01:49:13,630
Scrambling und Descrambling
Informationen und Chiffrierung

2125
01:49:13,630 --> 01:49:15,930
und Dechiffrieren Text,
und unter der Annahme letztlich

2126
01:49:15,930 --> 01:49:18,970
dass Sie jetzt wissen, was
ist unter der Haube

2127
01:49:18,970 --> 01:49:21,860
so dass, wenn Sie sehen oder zu empfangen
, Eine Nachricht wie diese Sie

2128
01:49:21,860 --> 01:49:24,060
selbst kann es zu entziffern.

2129
01:49:24,060 --> 01:49:26,740
All dies und vieles mehr beim nächsten Mal.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO-WIEDERGABE]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Gerade angekommen.

2133
01:49:32,970 --> 01:49:35,146
Ich gehe Besuch zu gehen
seine College-Professor.

2134
01:49:35,146 --> 01:49:37,611
Ja.

2135
01:49:37,611 --> 01:49:40,080
Hallo.

2136
01:49:40,080 --> 01:49:40,660
Du bist es.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Warte ab!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Ich versuche nur, um herauszufinden,
Sie heraus, was mit dir passiert.

2142
01:49:56,060 --> 01:49:58,130
Bitte, könnte alles helfen.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Sie waren seine College
Mitbewohner, waren Sie nicht?

2145
01:50:08,354 --> 01:50:10,770
Sie waren dort mit ihm, wenn
er beendete das CS50-Projekt?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUSIK SPIELEN]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Das War CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Ich liebe diesen Ort.

2152
01:50:44,770 --> 01:50:45,854
>> -Aufessen.

2153
01:50:45,854 --> 01:50:47,020
Wir gehen aus dem Geschäft.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END WIEDERGABE]

