[МУЗИКА] 

DAVID J. Малан: Добре. Це CS50 і це є початком 2-му тижні. І ви пам'ятаєте, що більш останні пару тижнів, ми представили комп'ютер наука і, в свою чергу, програмування. 

І ми почали розповідь шляхом Подряпина, що графічна мова з медіа-лабораторії Массачусетського технологічного інституту. А потім зовсім недавно, Минулого тижня, ми зробили ввести higher-- A мова нижчого рівня відомі як С, то, що це чисто текстуально. І, дійсно, останній раз, коли ми вивчити в цьому контексті ряд понять. 

Це, нагадаємо, був дуже Перша програма ми розглянули. І ця програма, досить просто, друкує "Привіт, світ." Але є так багато удаваній магії відбувається. Там ця #include з цих кутових дужках. Там в інт. Там в (анулюються). Там в круглі дужки, фігурні дужки, крапка з комою, і багато іншого. 

Так, нагадаємо, що ми ввели Подряпину так що ми могли б, в ідеалі, побачити минуле що синтаксис, матеріал, який справді не все, що інтелектуально цікаво, але на ранніх стадіях це, безумовно, трохи складніше щоб обернути ваш розум навколо. І справді, одне з найпоширеніших речі на ранньому етапі в класі програмування, особливо для тих, хто менше зручно, щоб зламатися, і підставляли деякими синтаксичними помилки, не кажучи вже про логічних помилок. І тому серед наших цілей сьогодні, насправді, буде буде оснащувати вас з деякими методи вирішення проблем для того, як щоб краще вирішувати проблеми самі у вигляді налагодження. І ви пам'ятаєте, теж, що среда, ми ввели останній раз був названий CS50 IDE. Це веб-програмне забезпечення, дозволяє програмувати в хмарі, так би мовити, зберігаючи при цьому всі ваші файли разом, як ми знову будемо сьогодні. І нагадаємо, що ми переглянути ці теми тут, серед них функцій, а також петлі, і змінні і логічні вираження, і умови. І насправді дещо більше, що ми в перекладі з нуля світу до світу C. 

Але основна будівля блоки, так би мовити, дійсно були всі ті ж минулого тижня. Насправді, ми дійсно тільки мали різні шматок головоломки, якщо ви будете. Замість того, що фіолетовий зберегти блок, ми замість того, щоб був PRINTF, який ця функція в С, дозволяє надрукувати що-небудь і відформатувати його на екрані. Ми ввели CS50 Бібліотека, де ви є зараз у вашому розпорядженні get_char, і get_int і get_string, і кілька інших функцій, як ну, за допомогою якого ви можете отримати введення від власної клавіатури користувача. І ми також взяли погляд на речі як these- BOOL і напівкоксу, і подвійні, з плаваючою точкою, INT, long_long рядок. І є навіть інші типи даних в C. 

Іншими словами, коли ви оголошуєте змінна для зберігання деякого значення, або при реалізації функції яка повертає деяке значення, Ви можете вказати, що тип значення, яке. Це рядок, подібно послідовність символів? Це число, як ціле число? Чи є це з плаваючою точкою значення, чи щось таке? Таким чином, в C, на відміну від нуля, ми насправді почав вказувати, який тип даних ми поверталися або використання. 

Але, звичайно, ми також зіткнулися з деякі фундаментальні межі обчислень. І зокрема, ця мова C, нагадаємо що ми дивилися на Целочисленное переповнення, реальність що якщо у вас є тільки кінцеве кількість пам'яті або, зокрема, кінцеве число бітів, ви можете розраховувати тільки так високо. І таким чином, ми дивилися на цей приклад тут в результаті чого лічильник в літаку ,, насправді, якщо працює досить довго буде переповнення і результат в програмному забезпеченні фактичний фізичний потенціал помилки. 

Ми також розглянули плаваючою точка неточностей, реальність що тільки з кінцевим числом бітів, будь то 32 чи 64, ви можете вказати тільки так багато чисел після десяткового дробу, після чого ви починають отримувати неточним. Так, наприклад, одна третина в світ тут, в нашому людському світі, ми знаємо, це просто нескінченне число 3 сек після десяткового дробу. Але комп'ютер не обов'язково являють собою нескінченне число цифр якщо ви тільки дайте йому деякі кінцеве кількість інформації. 

Так що ми не тільки озброїти вас з більшою силою в плані як Ви могли б виразити себе в клавіатура з точки зору програмування, ми також обмежені, що ви можете реально зробити. І справді, помилки і помилки можуть виникають з цих видів питань. І дійсно, серед тем сьогодні будуть такі теми, як налагодження і насправді, дивлячись під капотом на те, як були введені речі минулого тижня насправді реалізовані так що вам краще зрозуміти, як можливостей та обмеження мови як C. 

І справді, ми відігніть шари з найпростіших структури даних, то, що називається масив, який Подряпина трапляється називати "список." це трохи відрізняється в цьому контексті. І тоді ми будемо також ввести одне з перший з наших проблем предметно-орієнтованих в CS50, світ криптографія, мистецтво дертися або в шифруванні інформації, так що ви можете відправляти секретні повідомлення і декодувати секретні повідомлення між двома особами, А і В. 

Тому, перш ніж ми переходу до цього нового світу, давайте спробуємо забезпечити вас з деякими методи, з якими ви можете усунути або зменшити принаймні, деякі розчарувань що ви, ймовірно, стикалися Тільки за минулий тиждень. Насправді, попереду вас such-- деякі з ваші перші проблеми в С і фори, якщо ви схожі на мене, в перший раз ви намагаєтеся надрукувати програму, навіть якщо ви думаєте, логічно Програма досить проста, ви можете дуже добре врізався в стіну, і компілятор не збирається співпрацювати. Роблять або Clang не збирається насправді зробити ваші ставки. 

І чому це може бути? Що ж, давайте подивимося на, може бути, проста програма. Я збираюся йти вперед і зберегти це в файл навмисно називають buggy0.c, тому що я знаю його бути зіпсований заздалегідь. Але я не міг зрозуміти, що якщо це перший або другий або третій програми що я насправді робить сам. Так що я збираюся йти вперед і закарбувати, Int основний (вакуум). І тоді всередині моїх фігурні дужки, дуже знайомий ( "привіт, world-- зворотної косої межі, п ") - і крапка з комою. 

Я зберіг файл. Тепер я збираюся піти вниз до мого вікні терміналу і тип роблять buggy0, тому що, знову ж таки, ім'я файлу сьогодні buggy0.c. Так що я типу зробити buggy0, Enter. 

І, о, господи, пам'ятаєте з останнього часу що без будь-яких повідомлень про помилки це хороша річ. Так що висновок не є хорошою річчю. Але тут я ясно деяку кількість помилок. 

Таким чином, в першому рядку виведення після введення роблять buggy0, нагадаємо, досить докладний висновок дзвоном в. Під капотом, CS50 IDE налаштований використовувати цілу купу Варіанти з цим компілятором так що у вас немає думати про них. І це все, що перша лінія означає, що починається з Clang. 

Але після цього, проблеми почати робити їх зовнішній вигляд. Buggy0.c на лінії 3, характер 5, є велика, червона помилка. Що це? Побічно оголошуючи функції бібліотеки PRINTF з типом Int (сопзЬ сЬаг *, ...) [-Werror]. Я маю на увазі, це дуже швидко стає дуже аркан. І, звичайно ж, в першу чергу погляд, ми не будемо очікують, що ви розумієте повнота цього повідомлення. І ось один з уроків на сьогоднішній день відбувається щоб спробувати помітити візерунки, або подібні речі, до помилок ви можете мати зіткнулися в минулому. Так що давайте дражнити тільки одна від одної ті слова, які виглядають знайомими. Великий, червоний помилка явно символом чогось помилитися. 

беззастережне визнання Бібліотека функцій Printf. Так що навіть якщо я не зовсім розумію, що неявно оголошуючи функції бібліотеки Значить, проблема, звичайно, відноситься до PRINTF якимось чином. І джерело цього питання має справу з оголосивши його. 

Оголошення функції є згадки про нього в перший раз. І ми використовували термінологію минулого тижня того, щоб оголосити прототип функції у, або з однією лінією у верхній частині вашого власний файл або в так званому файлі заголовка. І в якому файлі зробив ми говоримо минулого тижня, що Printf цитата, Unquote, заявив? В якому файлі знаходиться його прототип? 

Так що, якщо ви пам'ятаєте, найперше, що я типізованих, майже кожна програма в минулому time-- і випадково хвилину назад почалася набравши myself-- був один here-- hash-- #include <stio-- для вхід / output-- точка ч І дійсно, якщо я тепер зберегти цей файл, я збираюся йти вперед і очистити екран, які ви можете зробити, ввівши Ясно, або ви можете тримати управління L, просто очистити вікно терміналу просто щоб усунути деякі перешкоди. 

Я збираюся йти вперед і повторно типу роблять buggy0, Enter. І вуаля, я до сих пір бачу, що довгий час команда з Clang, але немає ніякого повідомлення про помилку на цей раз. І справді, якщо я ./buggy0, так само, як в минулий раз, де точка означає це каталог, Слеш просто означає, тут йде назва програми і що назва програми buggy0, Введіть, "Привіт, світ." 

Тепер, як ви, можливо, почерпнуті це рішення не обов'язково визнаючи, як багато слів, як і я, звичайно ж, маючи зробили це протягом багатьох років? Ну, реалізувати в першому завданні набір, ми познайомимо вас з командою що власний персонал CS50 в написав під назвою help50. І справді, C робить специфікацію проблема встановити щодо того, як використовувати цю функцію. 

Але, по суті, help50 програма, яка співробітники CS50 в писав, що дозволяє запускати команда або запустити програму, і якщо ви не розумієте його вихід, щоб передати свій вихід help50, і в цей момент програмне забезпечення що співробітники звичайно писав буде виглядати на виході вашої програми рядок за рядком, по одному символу. І якщо ми, співробітники, визнають повідомлення про помилку, що ви відчуваєте, ми будемо намагатися, щоб спровокувати вас з деякими риторичні питання, з деякими порадами, так само, як TF або CA або себе робитиме особисто в робочий час. 

Так що дивіться, щоб help50, якщо ви цього не зробите обов'язково визнають проблему. Але не покладатися на нього занадто багато, як милицю. Звичайно, спробувати зрозуміти його виведення, а потім витягти з нього так що тільки один або два рази не так коли-небудь запустити help50 для конкретної помилки повідомлення. Після цього, ви повинні бути краще оснащені себе щоб з'ясувати, що це насправді. 

Давайте зробимо один інший тут. Дозвольте мені йти вперед, а в іншому файл, який ми будемо називати цей buggy1.c. І в цьому файлі я збирається deliberately-- але робити вигляд, що я не роблю зрозуміти, що помилка, яку я зробив. 

Я збираюся йти вперед і робити this-- #include, так як я дізнався, що мій урок з хвилину назад. Int основних (недійсними), як і раніше. І тоді тут я йду гарантувати рядку з - get_string. І пам'ятайте з останнього часу, це означає, агов, комп'ютер, дайте мені змінну, називаємо це S, і зробити тип цієї змінної строковим так що я можу зберігати одне або кілька слів у ньому. 

А потім на правій руці сторона знака рівності є get_string, яка є функція в бібліотеці CS50 що робить саме це. Він отримує функцію, а потім руки його справа наліво. Так що цей знак рівності не означає, "Так само", як ми могли б думати в математиці. Це означає призначення справа наліво. Таким чином, це означає, взяти рядок з користувач і зберігати його всередині с. 

Тепер давайте використовувати його. Дозвольте мені йти вперед зараз і в якості другого лінія, дозвольте мені йти вперед і сказати "привіт" - не «мир", але "Привіт,% S-- яка є нашим заповнювачем, кома s, яка є нашою змінної, а потім крапка з комою. Так що, якщо я не загвинчувати занадто багато тут, це виглядає як правильний код. 

І мої інстинкти тепер скомпілювати його. Файл називається buggy1.c. Так що я збираюся зробити зробити buggy1, Enter. І штопати-то, якщо немає навіть більше помилок, ніж раніше. Я маю на увазі, є більше Повідомлення про помилки це було здається, ніж фактичні лінії в цій програмі. 

Але їжа на будинок тут, навіть якщо ви перевантажені з двома або трьома або ще чотири повідомлення про помилки, фокус завжди на дуже Перший з цих повідомлень. Дивлячись на самий верхній один, прокрутки назад вгору, як це буде необхідно. Так ось я надрукував косметику buggy1. Ось що вихід Clang, як і очікувалося. 

І ось перша червона помилка. Використання неоголошеної ідентифікатора Рядок, я маю на увазі стандарт в? Так стандарт є насправді щось інше. Це відноситься до користувача клавіатура, по суті. 

Але це не те, що я мав на увазі. Я мав на увазі рядок, і я мав на увазі get_string. Так що ж це, що я забув зробити на цей раз? Чого не вистачає на цей раз? У мене є #include, тому у мене є доступ до Printf. 

Але що у мене немає доступ до щойно ще? Ну, так же, як в минулий раз, Я повинен сказати компілятор Брязкотом, що ці функції. Get_string не спадає з С. І зокрема, його не спадає на заголовка файлу. Замість цього він приходить в щось співробітники писали, який представляє собою інший файл ім'я, але влучно назвав. 

Так, просто додавши, що одній лінії з code-- відкликання від останнього часу що при запуску Clang, це буде подивитися на мій код зверху вниз, зліва направо. Це буде помітити, Ах, ви хочете. Дозвольте мені піти і знайти, що, всюди, де він знаходиться на сервері, скопіювати і вставити його, по суті, у верхній частині вашого власного файлу так що в цей момент в історії, лінія 1, інша частина програми може, справді, можна використовувати будь-який з функцій в ньому, серед них get_string. Так що я збираюся ігнорувати інші з цих помилок, тому що я, справді, підозрюю, що тільки перший насправді мало значення. І я збираюся йти вперед і перекладка, після збереження мого файлу зробити buggy1. І вуаля, він зробив роботу. А якщо я ./buggy1 і введіть, для екземпляр, Zamyla, я тепер отримати привіт, Zamyla, а не привіт, світ. 

Добре. Так ось тоді винос повинні, один, намагайтеся підбирати стільки, скільки ви можете від повідомлень про помилки в поодинці, дивлячись на деяких з розпізнаються слів. Якщо виключити, що використовувати help50 за проблема встановити специфікації. Але за винятком цього теж, завжди звертайте увагу тільки у верхній помилки, принаймні, на початковому етапі, щоб побачити, яку інформацію він може насправді вихід. Але виявляється, що є навіть більше функціональних можливостей вбудованої в бібліотеку CS50, щоб допомогти ви на ранньому етапі в семестр і на ранній стадії в програмуванні з'ясувати, що відбувається не так. Так давайте зробимо ще один приклад. Я буду називати це buggy2, який, знову ж таки, буде зіпсований з воріт, по дизайну. 

І я збираюся йти вперед і робити #include. А потім я збираюся зробити Int основний (вакуум). А потім я збираюся зробити цикл. Для (INT I _ 0. Я менше або дорівнює 10. я ++, а потім в фігурні дужки, я йду роздрукувати тільки символ хештегом тут і символ нового рядка. 

Таким чином, мій намір з цим Програма досить просто ітерацію в 10 разів і на кожній ітерації з цього циклу кожен раз через цикл, роздрукувати хештегом, хештегом, хештегом. По одному в рядку, тому що я мають нову лінію там. І нагадаємо, що для петля, за останній week-- і ви отримаєте більше знайомий з синтаксисом використовуючи його з практикою Перед long-- це дає мені змінна називається I і встановлює його в 0. 

Це збільшує I на кожній ітерації на 1. Так що я йде до 1 до 2 до 3. І тоді ця умова в посередині між точками з комою отримує перевіряється на кожній ітерації, щоб зробити упевнений, що ми все ще в межах діапазону. Так що я хочу ітерацію в 10 разів, так що я мають вигляд дуже інтуїтивно просто покласти 10, як моя верхня межа там. 

І все ж, коли я запускаю це, після того, як компіляції із зазначенням марки buggy2-- і вона компілюється ОК. Так що я не мають синтаксичну помилку в цей раз. Дозвольте мені йти вперед прямо зараз і запустити buggy2, Enter. А тепер можна переходити вгору. І дозвольте мені збільшити розмір вікна. 

Я, здається, є 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Так що 11 хештегів, незважаючи на те, Я чітко поставив 10 всередині цього циклу. Тепер, деякі з вас можуть побачити відразу що помилка відбувається тому, що, справді, це це не дуже важко помилка зробити. Але це дуже часто зробив дуже рано. 

Те, що я хочу відзначити, однак, в тому, як я міг би зрозуміти це? Що ж, виходить, що CS50 бібліотека приходить з не тільки get_string і get_int і get_float і інші функції. Він також поставляється зі спеціальною функцією називається eprintf, або, помилка Printf. І існує тільки зробити це трохи простіше для вас при налагодженні коду просто виводить повідомлення про помилку на екрані і знаю, звідки вона взялася. 

Так, наприклад, одна річ, яку я міг би тут робити з цією функцією є this-- eprintf, а потім я збираюся йти вперед і сказати, що я тепер% я, зворотний слеш, п. І я збираюся підключити до значення I. І нагорі, тому що цей знаходиться в бібліотеці CS50, Я збираюся йти вперед і включають в себе тому у мене є доступ до цієї функції. Але давайте розглянемо, що лінія 9 передбачається робити. Я збираюся видалити це врешті-решт. Це не має нічого спільного з моєї головної мети. Але eprintf, помилка Printf, просто означає, щоб дати мені деяку діагностичну інформацію. Коли я запускаю мою програму, я хочу побачити це на екрані тимчасово а просто зрозуміти, що відбувається. 

І справді, на кожному ітерація тут лінії 9 Я хочу бачити, як і величина I? Що таке значення I? Що таке значення I? І, сподіваюся, я повинен тільки бачити, що повідомлення, крім того, в 10 разів. 

Отже, дозвольте мені йти вперед і перекомпіліровать мою програму, як я повинен робити в будь-який час Я внести зміни. ./buggy2. І now-- OK. Там дуже багато більше відбувається. Отже, дозвольте мені перегорнути вгору ще більше вікно. 

І ви побачите, що кожен з Hashtags як і раніше друку. Але між кожним з них в даний час цей діагностичний висновок відформатований наступним чином. Назва моєї програми тут є buggy2. Файл buggy2.c. Номер рядка, з якої це було надруковано в рядку 9. А потім справа, що є повідомлення про помилку, що я очікував. 

І що приємно про це полягає в тому, що Тепер я не повинен обов'язково розраховувати в моїй голові, що моя програма робить. Я бачу, що на Перша ітерація я = 0, потім 1, потім 2, потім 3, потім 4, потім 5, потім 6, потім 7, потім 8, то 9, то, 10. Так, почекайте хвилину. Що тут відбувається? Я до сих пір, здається, вважаючи як задумано до 10. 

Але де ж мені почати? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. Таким чином, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11-й палець свідчить про проблему. Я, здається, підрахували неправильно в моєму циклі. Замість того, щоб йти 10 ітерацій, Я починаючи з 0, Я і закінчуючи через 10. Але, так як, як комп'ютер, Я починаю відлік з 0, Я повинен бути підраховуючи до, але не до кінця, 10. 

І тому виправлення, я врешті-решт тут реалізується, є однією з двох речей. Я міг би дуже просто сказати, порахувати до менш 10. Таким чином, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, яка є, по суті, вірно, незважаючи на те, що це звучить трохи неправильно. Або я міг би зробити менше або дорівнює до 9, до тих пір, як я починаю з 0. Або, якщо ви дійсно не подобається, що ти може розраховувати через 10, але починаються з 1. Але знову ж таки, це просто не так часто. У programming-- хоча і не стільки в Scratch-- але при програмуванні в C та іншими мовами, як JavaScript і Python і інші, це просто дуже часто для наше обговорення бінарна щоб просто почати відлік на найменше число ви можете, що 0. Добре. Так ось eprintf. І знову ж таки, тепер, коли я зрозумів, що я Проблема, і я збираюся повернутися до 0 через менш ніж 10, я збираюся піти і видалити eprintf. 

Воно не повинно бути там, коли я відправити мій код або відправити свій код або показати його кому-небудь ще. Це дійсно просто мав на увазі які будуть використовуватися тимчасово. Але тепер я це виправив Особливою проблемою, а також. 

Що ж, давайте зробимо ще один приклад тут що я буду нагнітати таким чином. Я збираюся йти вперед і #включати . $ 50 І я збираюся йти вперед і #include. 

І я збираюся зберегти цей файл в якості buggy3.c. І я збираюся йти вперед і оголосити Int основний (вакуум). А потім всередині там Я збираюся зробити INT I _ - Я хочу, щоб реалізувати програму з get_negative_int. Це не функція, яка існує до цих пір. Отже, ми збираємося реалізувати це лише мить. Але ми будемо бачити, чому вони є хибними на першому проході. І як тільки я отримав викличте переривання від користувача, Я просто хочу, щоб надрукувати% I є негативним цілим числом, зворотної косої межі, п, кома, я. Іншими словами, все, що я хочу цю програму, щоб зробити це отримати негативне Int з користувач, а потім роздрукувати що такий негативний Int. 

Тепер мені потрібно реалізувати цю функцію. Так що пізніше в моєму файлі, я збираюся піти вперед і оголосити функцію під назвою get_negative_int (порожнеча) - і ми повернутися до того, що означає, що лінія знову в moment-- Int N; do-- робити following-- Printf п:. А потім я збираюся зробити п - get_int, і зробити це в той час як п більше 0. А потім повернутися п;. 

Так що є багато відбувається в не це, але жоден з яких ми не робили подивіться на останній тиждень, по крайней мере, на короткий час. Так що в рядку 10 тут я оголошений Функція називається get_negative_int, і я поставив (порожнеча), в круглі дужки, з тієї причини, це не приймає вхідний сигнал. Я нічого не пропускаючи до цієї функції. Я просто отримую щось від нього. 

А що я сподіваюся отримати назад ціле. Там немає тип даних C називається negative_int. Це просто Int, так що це буде щоб бути на нас, щоб переконатися, що значення, яке насправді Повертається не тільки INT але також негативно. 

У рядку 12 я оголошую змінну називається п і робить його типу Int. А потім в рядку 13 до 18 Я робити щось в той час як-то вірно. Я йду вперед і друк п, двокрапка, а потім пробіл, як підказку для користувача. 

Я потім викликати get_int і зберігати його так зване повертається значення в цієї змінної п. Але я буду продовжувати робити це в той час як п більше 0. Іншими словами, якщо користувач дає мені Int і це число більше 0, ерго, позитивний, я збираюся просто тримати reprompting користувача, тримати reprompting, змушуючи їх співпрацювати і дайте мені негативний результат Int. 

І як тільки п насправді negative-- Припустимо, що користувач нарешті типу -50, то це не в той час як цикл вже не так бо -50 не більш 0. Таким чином, ми порушуємо з цього петля логічно і повернутися п. 

Але є ще одна що я повинен робити. І я можу просто зробити це шляхом копіювання і вставки один рядок коду у верхній частині файлу. Мені потрібно, щоб навчити Clang, або обіцянку брязкотом, явно, що я буду, насправді, піти і здійснити ця функція get_negative_int. Це може бути просто нижче в файлі. Знову ж, нагадаємо, що Clang читає речі зверху вниз, зліва направо, так що ви не можете викликати функцію, якщо Clang не знає, що це буде існувати. 

Тепер, на жаль, ця програма, так як деякі з вас могли помітити, вже глючить. Дозвольте мені йти вперед і зробити buggy3. Він збирає, так що моя проблема зараз не синтаксичну помилку, як текстової помилки, це насправді буде логічним помилка, що я навмисно зробив як можливість покроково, що відбувається. 

Я збираюся йти вперед Тепер і запустити buggy3. І я збираюся піти вперед, а не співпрацювати. Я збираюся дати йому номер 1. Це не сподобалося, так це мене знову пробуджуючи. 

Як щодо 2? 3? 50? Жоден з них не працюють. Як щодо -50? І програма, здається, працює. 

Дозвольте мені спробувати ще раз. Дозвольте мені спробувати -1, здається, працює. Дозвольте мені спробувати -2, здається, працює. Дозвольте мені спробувати 0. Так, це невірно. Тепер ми, будучи трохи педантичним тут. Але це, насправді, так що 0 не є ні позитивним, ні негативним. І тому той факт, що моя програма кажучи, що 0 є негативним цілим числом, це не технічно правильно. 

Тепер, чому він це робить? Ну, це може бути очевидним. І, дійсно, програма мав на увазі, щоб бути досить простим тому у нас є щось, щоб досліджувати. 

Але давайте введемо третю налагодження Техніка тут називається debug50. Так що це програма що ми тільки що створили У цьому році під назвою debug50 що дозволить вам використовувати те, що називається вбудованим графічний відладчик в CS50 IDE. І відладчик просто програма, яка як правило, дозволяє запускати програму але крок за кроком за кроком, лінії по лінії по лінії, роблячи паузу, тикаючи навколо, дивлячись на змінні, так що програма не просто удар повз вас і швидко надрукувати що-небудь або не надрукували що-небудь. Це дає можливість, в людська швидкість, щоб взаємодіяти з ним. 

І зробити це, ви просто зробіть наступне. Після компіляції коду, які я вже зробив, buggy3, ви йдете вперед і запустити debug50 ./buggy. Так само, як help50 має запуску help50, а потім команда, debug50 має запустити debug50 і то ім'я команди. 

Тепер подивимося, що відбувається на моєму екрані, на правій стороні, зокрема. Коли я вдарив Виконати, все раптова панель ця права відкриває на екрані. І є багато чого відбувається на на перший погляд. Але є не дуже багато причин для занепокоєння поки немає. 

Це показує мені все що відбувається всередині моєї програми прямо зараз, і через них Кнопки вгору верхньої потім що дозволило мені пройти через мій код в кінцевому підсумку крок за кроком за кроком. Але не тільки поки. Зверніть увагу на те, що відбувається. У моєму вікні терміналу Я вам буде запропоновано ввести п. І я збираюся йти вперед і співробітництво на цей раз і введіть -1. І хоча і трохи загадково, -1 є негативним цілим числом, як і слід було очікувати. 

І тоді дитина вийшла з Статус 0 GDBserver виходу. GDB, GNU Debugger, це ім'я що лежить в основі програмного забезпечення який реалізує цей відладчик. Але все це насправді означає, відладчик пішов, тому що моя програма кинути курити і все було добре. Якщо я хочу, щоб дійсно налагоджувати програму, Я повинен сказати, превентивно debug50, де я хочу, щоб почати покрокового мій код? 

І, мабуть, найпростіший спосіб зробити це в такий спосіб. Якщо я парити над Жолоб мого редактора тут, так насправді просто в бічній панелі тут, зліва від номера рядка, Зверніть увагу, що, якщо я просто натисніть один раз, я ставлю маленьку червону крапку. І ця маленька червона точка, як знак зупинки, значить, агов, debug50, виконання паузи мого коду прямо там, коли я запустити цю програму. 

Так давайте зробимо це. Дозвольте мені йти вперед і запустити мою програму знову з debug50 ./buggy3, Enter. А тепер, зверніть увагу, що щось інакше сталося. Я не запит все ж в моєму вікні терміналу ні за що, тому що у мене немає отримав там ще в моїй програмі. Зверніть увагу на те, що в рядку 8 який в даний час виділено, і є маленька стрілка ліва вислів, ти зупинився тут. Цей рядок коду, рядка 8, досі не виконано. 

І що цікаво, якщо я дивлюся тут на правій стороні, зверніть увагу, що я є локальним змінна, локальна в тому сенсі, що вона всередині поточної функції. І його значення, по-видимому, за замовчуванням, і начебто зручно, дорівнює 0. Але я не тип 0. Це як раз трапляється бути його Значення за замовчуванням в даний момент. 

Отже, дозвольте мені йти вперед і робити це зараз. Дозвольте мені йти вперед і на в правому верхньому кутку тут, я йти вперед і натисніть цю першу іконку, яка означає крок, над яким означає не пропустити це, але переступити цей рядок коду, виконуючи його по дорозі. 

А тепер зверніть увагу, що я швидке щойно змінив. Чому так? Я сказав debug50, запустити цей рядок коду. Що робить цей рядок коду робити? Запитує мене на міжнар. ДОБРЕ. Дозвольте мені співпрацювати. Дозвольте мені йти вперед зараз і введіть -1, Enter. А тепер зверніть увагу, що змінилося. З правого боку, моя локальна змінна я позначається як -1 в даний час. І це все-таки типу Int. 

І зауважте, теж, мій так званий стек викликів, де ж я паузу? Ми будемо говорити більше про це в майбутньому. Але стек викликів просто посилається на те, що функції в даний час в русі. Зараз це просто головний. І зараз єдиний місцевий змінна I зі значенням 1. 

І коли я, нарешті, крок по цій лінії тут, з тієї ж значок в правому верхньому куті, -1 Є негативним цілим числом. Тепер він затримавшись над цим фігурною дужкою. Давайте нехай це роблять свою справу. Я переступити цей рядок, і вуаля. 

Так що не все, що жахливо повчально все ж, але це дозвольте мені зробити паузу і думаю, що через логічно що ця програма робить. Але це не було помилковим випадком. Давайте зробимо це знову в такий спосіб. 

Я збираюся залишити цю точку зупину в рядку 8 з червоною крапкою. Я збираюся повторно запустити debug50. Це автоматично призупиняється тут. Але на цей раз, замість того, переступаючи через цю лінію, дозвольте мені насправді йти всередині get_negative_int і з'ясувати, чому це прийняття 0 в якості дійсного відповіді? 

Таким чином, замість того, щоб натиснути Step Over. Я збираюся йти вперед і натисніть кнопку Step Into. І зверніть увагу, що лінія 8 це тепер виділяється тепер раптом стає рядок 17. 

Тепер, це не означає, що відладчик пропустив лінії 14 і 15, і 16. Це не просто там нічого щоб показати вам там. Ті оголошення змінних, а потім там слово Do а потім відкрита фігурна дужка. Тільки функціональна лінія, це соковитий дійсно цей тут, 17. І ось де ми автоматично призупиняється. 

Так що Е ( "n.is:");, так що до сих пір не відбулося. Так що давайте йти вперед і натисніть кнопку Step Over. Тепер мій запит, насправді, змінений ( "п:"). Тепер get_int, я не збираюся турбувати вступаємо, тому що функція була зроблені CS50 в бібліотеці. Це, ймовірно, правильно. 

Так що я збираюся йти вперед і свого роду співпраця, надавши йому викличте переривання, але не є негативним Int. Отже, дозвольте мені йти вперед і вдарив 0. А тепер, що відбувається тут коли я отримую вниз до лінії 21? Я не ітерованих знову. Я, здається, не застрягне в цьому циклі. Іншими словами, цей жовтий бар не буде тримати навколо, і навколо, і навколо нього. 

Тепер, чому це? Що ж, п, що дорівнює п прямо зараз? Я можу дивитися на місцевому Змінні в отладчике. п дорівнює 0. Добре, що це було моє стан? 

20-- лінія 20, ну, 0 більше 0. Це не правда. 0 не більш 0. І тому я вирвалася з цього. 

І ось чому на лінії 21, якщо я насправді, як і раніше, Я збираюся повернути 0, навіть хоча я повинен був відкинуто 0 а насправді не є негативним. Так що тепер, я не дуже навіть піклуватися про відладчика. Зрозумів, я не потрібно знаю, що ще відбувається. 

Так що я збираюся йти вперед і просто натисніть кнопку відтворення, і нехай це закінчити. Тепер я зрозумів, що мій помилка мабуть, в рядку 20. Це моя логічна помилка. 

І ось, що я хочу потрібно зробити, щоб змінити це? Якщо проблема полягає в тому, що я не ловити 0, це просто логічна помилка. І я можу сказати, в той час як п більше або дорівнює 0, тримати знову і знову запитуючи користувача. 

Так що, знову ж таки, проста помилка, можливо, навіть очевидно, коли ви бачили мене написати це лише кілька хвилин тому. Але тут винос є те, що при налагодженні 50, і з налагодженням програмне забезпечення в більш загальному плані, у вас є це нове харчування пройти через свій власний код, дивіться за допомогою цієї правій панелі, що змінні значення. Таким чином, ви не обов'язково повинні використовувати щось як ви eprintf друкувати ці значення. Ви можете побачити їх візуально на екрані. 

Тепер, крім цього, варто відзначити, що є інша техніка, яка насправді дуже поширеним явищем. І ви могли б задатися питанням, чому цей маленький хлопець тут сидів на сцені. Так що є ця техніка, як правило, відомий як метод каченяти, який насправді це просто свідченням того, що часто, коли програмісти написанні коду, вони не обов'язково співпрацюючи з іншими, або працювати в загальному середовищі. 

Вони начебто вдома. Може бути, це пізно вночі. Вони намагаються фігури деякі помилки в своєму коді. І вони просто не бачить. 

І немає ніякого сусіда по кімнаті. Там немає TF. Там немає CA навколо. Всі вони мають на своїй полиці ця маленька гумова качечка. 

І тому налагодження гумова качка просто це запрошення думати про щось, як нерозумно так як це як реальна істота, і насправді пройти через ваш код в усній формі до цього неживий об'єкт. Так, наприклад, якщо це мій приклад here-- і нагадаємо, що раніше проблема була в цьому, якщо я видалю цю перший рядок коду, і я йду вперед і зробити баггі 0 раз, Нагадаємо, що у мене були ці Повідомлення про помилки тут. Так що ідея тут, смішно, хоча я відчуваю в даний момент робить це публічно, є те, що помилка. 

ОК, так що моя проблема в тому, що я неявно бібліотечну функцію. І ця функція бібліотеки Printf. Declare-- OK, оголосити нагадує мені про прототипи. 

Це означає, що мені потрібно насправді повідомити компілятору заздалегідь, що функція виглядає наступним чином. Почекай хвилинку. У мене не було стандартного io.h. Велике спасибі. 

Так що цей процес of-- вас не потрібно насправді є качка. Але ця ідея ходити самостійно через свій власний код так що ви навіть чути самостійно, так що ви реалізувати упущення в свій власний зауваження, як правило, ідея. 

І, можливо, більш логічно, чи не так багато з цим один, але більш активну участь Приклад, який ми тільки що зробили в баггі 3.c, Ви могли б ходити себе через нього наступним чином. Так що все в порядку, гума душка, DDB, якщо ви будете. Тут ми маємо в своїй основній функції, Я дзвоню отримати негативний результат Int. 

І я отримую повертається значення. Я зберігати його на лівій стороні в рядку 8 в змінної називається I. Добре, але чекати, як зробив що отримати це значення? Дозвольте мені поглянути на функції в рядку 12. 

У рядку 12 ми маємо отримати негативну Int. Не приймати будь-які матеріали, це повертає Int, OK. Я заявляю, в рядку 14 змінна п. Це буде зберігати ціле число. Це те, що я хочу. 

Так зробіть наступне: Коли п is-- нехай мені скасувати те, що виправлення я вже зробив. Таким чином, в той час як п більше 0, роздрукувати п, OK. А потім викличте отримати INT зберігається в п. А потім перевірте, якщо п = 0, п не-- там. Так що, знову ж таки, ви цього не зробите потрібен фактичний качка. Але просто ходити самостійно через ваш код як інтелектуальна вправа часто допоможе вам усвідомити, що відбувається, а не просто робити щось як це, дивлячись на екран, і не говорити себе через то, що це не чесно майже як ефективний метод. Так що у вас є, A кількість різних методів для фактично налагодження коду і чіплятися, все з яких повинні бути інструменти в ваш інструментарій так що ви не пізно вночі, особливо, ви в їдальні зали, або в неробочий час, б'єшся головою проти стіни, намагаючись вирішити деякі проблеми. Розуміють, що є програмні засоби. Є гумова качка інструменти. І є цілий штат підтримки чекають, щоб протягнути руку допомоги. 

Так що тепер, слово з проблеми набори, а також на те, що ми сподіваємося, що вам вийти з них, і як ми йдемо про оцінку. За навчальний план Курсу, CS50 безлічі проблем в оцінюються за чотирма основними осях, так щоб speak-- сферу, коректність, дизайн, і стиль. І сфера просто ставиться до того, скільки шматка ви відкусили? Скільки проблеми ви пробували? Який рівень зусиль Ви були? 

Коректність, працює програма, як він повинен згідно специфікації CS50 коли ви надаєте певні входи або певні виходи повертаються? Дизайн є найбільш суб'єктивним з них. І це той, який буде взяти найдовший, щоб дізнатися, і найдовший, щоб викладати в до сих пір, як це зводиться до того, як добре написано ваш код? 

Це одна річ, щоб просто надрукувати правильний виходи або повертати правильні значення. Але ви робите це як ефективно, наскільки це можливо? Ви робите це розрив і володарюй, або двійковий Пошук, як ми скоро побачимо, що ми зробили два тижні тому з телефонною книгою? Чи існують більш ефективні способи вирішення проблема, ніж зараз у вас тут? Це можливість для кращого дизайну. 

А потім, як style-- досить ваш код? Ви помітите, що я досить Зокрема про відступів мій код, і переконавшись, що мої змінні обґрунтовано названі. п, в той час як короткі, добре ім'я для номер, я для підрахунку числа, s для рядка. І ми можемо мати більше імена змінних стилю. Стиль, наскільки добре виглядає ваш код? А як читається це? 

І з плином часу, ніж ваші TAs і ТФ буде робити в процесі це надати вам, що вид якісної зворотного зв'язку так що ви отримаєте краще в цих різних аспектах. І з точки зору того, як ми оцінити кожну з цих осей, це, як правило, з дуже небагатьма відра, так що ви, як правило, отримати уявлення про те, наскільки добре ви робите. І дійсно, якщо ви отримаєте рахунок на будь-який з цих axes-- правильність, дизайн і стиль especially--, що число як правило, становить від 1 до 5 балів. І, в буквальному сенсі, якщо ви отримуєте 3-х на початку семестру, це дуже хороша річ. Це означає, що є ще можливості для поліпшення, який ви б сподіватися в приймаючи клас в перший раз. Там в якийсь, сподіваюся, трохи стелі до якого ви прагнуть до досягнення. І тому отримання 3 по найраніші п'єси, якщо не якийсь 2-х і 4-х, це, дійсно, дуже хороша річ. Це добре в межах діапазону, добре в межах очікувань. 

І якщо ваш розум мчить, зачекайте хвилину, три з п'яти. Це дійсно 6 з 10. Це 60%. Боже мій, це на букву F. 

Це не. Це не так, насправді, це. Швидше за все, це можливість поліпшити протягом семестру. І якщо ви отримуєте деякі Poors, це можливість щоб скористатися офісними годинами, звичайно ж розділи та інші ресурси. 

Краще це можливість, насправді, можна пишатися, наскільки далеко ви приходять протягом семестру. Так само розумієш, якщо нічого ще три добре. І це дозволяє для зростання з плином часу. 

Що стосується того, як ці осі зважене, реально ви збирається витратити більшу частину свого часу отримання речі, щоб працювати, не кажучи вже правильно. І тому, як правило, коректність зважуватися найбільше, як і з цей мультиплікативний фактор трьох. Дизайн також має важливе значення, але то, що ви не обов'язково витрачати все ті години, на намагаючись отримати речі просто працювати. 

І таким чином це зважений трохи більше злегка. А потім стиль зважується щонайменше. Незважаючи на те, що це не менш важливо фундаментально, це просто, може бути, Найпростіше зробити правильно, імітуючи приклади, які ми робити в лекції та секції, з речами красиво відступом, і прокоментував, і так далі є одним з найпростіших речі, щоб зробити і отримати право. Так як такі, реалізувати що ті точки що відносно легко зрозуміти. 

А тепер слово на this-- академічної чесності. Таким чином, за Курсу навчальний план, ви побачите що курс має досить трохи мови навколо цього. І звичайно ж бере питання академічна чесність цілком серйозно. 

У нас є деякі розбіжності, на краще чи на гірше, з надіславши щороку більше студентів для прийняття дисциплінарних заходів ніж більшість будь-який інший Звичайно ж, що я знаю. Це не обов'язково свідчить про те, що студенти CS або CS50 студентів, є Проте чесніше своїх однокласників. Але реальність, що в цьому світ, в електронному вигляді, ми просто є технологічна засіб виявлення цього. 

Це дуже важливо для нас для справедливість по класу що ми робимо це виявити і підняти питання, коли ми бачимо речі. І як раз, щоб намалювати картину, а насправді щоб допомогти щось на зразок цього в раковині, це число Студенти протягом останніх 10 років які були залучені до деяких такі питання академічної чесності, з деякими 32 студентів з осені 2015 року, яка повинен сказати, що ми приймаємо справа дуже серйозно. І, в кінцевому рахунку, ці цифри становлять, Зовсім недавно, близько 3%, 4% або близько того класу. 

Так що для супер більшості студентів здається, що лінії чіткі. Але майте це на розум, особливо пізно в нічний час, коли бореться з якесь рішення для безлічі проблем, що існують механізми для отримання себе краще підтримка, ніж ви могли б думаю, навіть в той час. Розуміють, що, коли ми отримуємо студентські уявлення, ми перетинаємо порівняти всі уявлення в цьому році проти кожного уявлення в минулому році, проти кожного уявлення з 2007 року, і так як, дивлячись на, а також, код репозиторіїв онлайн, дискусійних форумах, робота сайтів. І ми відзначимо це, насправді, все заради повного розкриття, що якщо хтось може знайти його в Інтернеті, звичайно ж, так що ми можемо курс. Але, насправді, дух з курсу зводиться до цієї статті в навчальній програмі. Це дійсно просто, розумно. 

І якщо ми повинні були зупинитися на цьому з тільки трохи більше мови, усвідомити, що суть всіх Робота, яку ви уявити цей курс повинен бути свій власний. Але в тому, що є, звичайно, можливостей і заохочення, і педагогічна цінність в перетворенні в others-- себе, ССТ, КАС, Тас і інші в класі, для підтримки, не кажучи вже про друзів і сусіди по кімнаті, хто вивчав CS і програмування раніше. І тому є посібник для цього. А загальне правило є this--, коли просять про допомогу, Ви можете показати свій код іншим, але ви не можете переглядати їх. Так що навіть якщо ви в робочий час, або в залі D, або де-небудь ще працює над якийсь шматок набору, працюючи разом з другом, який це абсолютно нормально, на Кінець дня вашої роботи в кінцевому підсумку повинно належати кожному з вас, відповідно, і не бути деякі спільні зусилля, для остаточного проекту, де крім це дозволяється і заохочується. 

Зрозумійте, що якщо ви бореться з чимось і ваш друг тільки що відбувається щоб бути краще в цьому, то ви, або краще на цю проблему, ніж ви, або трохи далі вперед, ніж ви, це абсолютно розумно, щоб перетворити своєму другові і сказати, агов, Ви не заперечуєте, дивлячись на мій код тут, щоб допомогти мені визначити, що моє запитання? І, сподіваюся, в Інтерес педагогічної цінності що друг не просто кажуть, ах, зробити це, але, скоріше, то, що ви пропали без вісті на лінії 6, або щось подібне? Але це рішення не для одного поруч з вами сказати, ой, ну, ось, дозвольте мені тягнути це, і показати моє рішення для вас. Так що це лінія. Ви показуєте свій код в інші, але ви не можете подивитися у них, відповідно до інших обмеження в навчальний план Курсу. 

Так що майте на увазі, що це так званий пункт жалю в ході навчального плану, а також, що якщо ви зробите якийсь акт, не є розумним, але довести його до увагу керівників Курсу протягом 72 годин, курс може накладати санкції, місцеві може включати в себе незадовільним або провальну оцінку для роботи, представлені. Але, звичайно, не передасть важливо для подальшого прийняття дисциплінарних заходів, за винятком випадків повторних актів. Іншими словами, якщо ви робите деякі нерозумно, особливо пізно ввечері, рішення що на наступний ранок або через два дні пізніше, ви прокинутися і усвідомити, про що я думав? Ви робите в CS50 мають вихід для фіксації цієї проблеми і володіти до нього, так що ми зустріне вас на півдорозі і справа з ним в питанні, який є одночасно освітніх і цінних для вас, але до сих пір каральний в деякому роді. І тепер, щоб заморити, це. 

[Відеовідтворення] 

[МУЗИКА] 

[КІНЕЦЬ ВОСП] DAVID J. Малан: Добре, ми повернулися. А тепер ми подивимося на один з перший з наших реальних доменів в CS50, мистецтво криптографії, Мистецтво відправки та отримання секретні повідомлення, зашифрованого повідомлення, якщо ви будете, які можуть бути розшифровані тільки якщо у вас є деякі з ключових елементів, що відправник так само. Таким чином, щоб мотивувати цього ми візьмемо Подивіться на цю річ тут, яка є Прімердлітельногопребиванія секрет декодер кільце, може бути використаний для того, щоб з'ясувати, то, що секретне повідомлення насправді. Насправді, ще в день в початковій школі, якщо ви коли-небудь послав секретні повідомлення деякі один або деякі тиснява в класі, Ви могли б подумати, ви були розумними шляхом на вашій частині заміни паперу, як, А до В, і В до С, В і С до D, і так далі. Але ви були насправді шифрування Ваша інформація, навіть якщо це було трохи тривіально, не було що важко для вчителя, щоб зрозуміти, добре, якщо ви просто змінити В до А і С до В, ви насправді з'ясувати, що було повідомлення, але ви були в шифруванні інформації. 

Ви просто робили це просто, так само, як Ральф тут у відомому фільмі, який грає досить багато оголошень щозими до нудоти. [Відеовідтворення] -Будьте Це всім відомо, що Ральф Паркер Справжнім призначений членом Малої Сирітка Енні Secret Circle і має право на всі почесті і вигоди відбувається з ним. 

-Signed, Сирітка Енні, зустрічне підписав П'єр Андре, в чорнилі. Почесті і вигоди, вже у віці дев'яти років. 

[Кричачи] -Давай. Давайте покінчимо з цим. Мені не потрібно все, що джаз про контрабандистів і піратів. 

Слухай Завтра ніч завершальним пригоди чорного піратського корабля. Тепер прийшов час для секретне повідомлення Енні для вас члени таємного гуртка. Пам'ятайте, діти, тільки члени Енні Секретної Circle може розшифрувати секретне повідомлення Енні. 

Пам'ятайте, що Енні залежить від вас. Встановіть штифти B2. Ось повідомлення. 12, 11-- 

-Я Перебуваю в, свою першу таємну зустріч. 

-14, 11, 18, 16. 

-Pierre Був гучний голос сьогодні. Я міг би сказати, що сьогодні ввечері повідомлення було дійсно важливо. 

-3, 25, це повідомлення від самої Енні. Пам'ятайте, що не говори нікому. 

-90 Секунд по тому, я перебуваю в єдиній кімната в будинку, де дев'ятирічний хлопчик міг сидіти на самоті і декодуванням. Ага, B! Я пішов до наступного, Е. 

Перше слово буде. S, він йшов легше зараз, U, 25-- 

-О, Давай, Ральф, я повинен йти! 

-Я Зараз спущуся, Ма! Ну і справи свисту! 

-Т, O, обов'язково переконайтеся, що, метою яких до чого? що сирітка Енні намагається сказати? Переконайтеся, що до чого? 

-Ralphie, Енді потрапив йти, то, будь ласка, вийти? 

-Добре, Мама! Я буду прямо! 

-Я Ставав ближче. Напруга була жахливо. Що це було? доля планети може висіти на волосині. 

-Ralphie! Енді повинен йти! 

-Я Зараз вийду, для волають голосно! 

-майже Там, мої пальці літали, мій розум була сталева пастка, кожна пора вібрувати. Це було майже ясно, так, так, так. 

-Будьте Обов'язково пити Ovaltine. Ovaltine? Вошивого комерційний? Сучий син. [КІНЕЦЬ ВОСП] DAVID J. Малан: ОК, так що це був дуже довгий шлях введення криптографію, а також Ovaltine. Насправді, від цього старого оголошень тут, чому Ovaltine так добре? Це концентроване витяг стиглі ячмінний солод, чисте вершкове з коров'ячого молока, і спеціально підготовлені какао разом з природними фосфатидів і вітамінів. далі збагачені додаткові вітаміни групи В і D, ням. І ви все ще можете отримати його, мабуть, на Амазонці, як ми робили тут. 

Але мотивація тут була ввести криптографію, зокрема, тип криптографії відомий в якості секретного ключа шифрування. І, як випливає з назви, весь безпеку секретного ключа системи криптографічного, якщо ви будете, методологія для скремблювання просто інформація між двома людьми, в тому, що тільки відправник і одержувач тільки знати секрет key-- якусь цінність, деякі умовну фразу, якийсь секрет число, що дозволяє їм як зашифрувати і розшифрувати інформацію. І криптографія, насправді, якраз це від тижня 0. 

Це проблема, де є входи, як реальне повідомлення англійською мовою або будь-який інший мову, який ви хочете послати кому-то в класі, або через Інтернет. Існує певний вихід, який збирається щоб бути ськремблірованний повідомлення, що ви хоче одержувач отримати. І навіть якщо хтось в середній отримує його теж, ви не хочете, щоб вони обов'язково бути в змозі розшифрувати його, тому що всередині цього чорний ящик, або алгоритм, це якийсь механізм, деякі крок за кроком інструкції, для прийняття цього входу і перетворення його в вихід, в сподіваюся безпечним способом. 

І справді, є деякі словниковий запас в цьому світі в такий спосіб. Звичайний текст є слово а вчений буде використовувати для опису вхідних повідомлення, як англійською або будь-який інший мову ви насправді хочете відправити в якийсь інший чоловік. І тоді шифротекст є звалище до шифрованих або зашифровані, його версія. 

Але є ще один інгредієнт тут. Там один інший вхід Секретний ключ шифрування. І це сам ключ, який, як правило, як ми побачимо, число або буква або слово, незалежно від алгоритм це насправді очікує. 

І як ви розшифрувати інформацію? Як ви розшифровувати його? Ну, ви просто повернути назад виходи і входи. 

Іншими словами, як тільки хтось отримує ваше зашифроване повідомлення, він або вона просто має щоб знати, що той же ключ. Вони отримали шифротекста. А підключивши ці два входи в систему криптографічного, алгоритм, це чорний ящик, з повинен прийти вихідний відкритий текст. І так що це дуже високий рівень вид, що насправді криптографія все про. 

Так що давайте там. Давайте тепер подивимося під капот чогось ми брали як само собою зрозуміле для минулого тижня, і на цій сесії here-- рядок. Рядок в кінці дня це просто послідовність символів. 

Це може бути привіт світ, або привіт Zamyla, або будь-який інший. Але що це означає, що послідовність символів? Насправді, бібліотека CS50 дає нам тип даних називається рядком. 

Але є насправді немає така річ як рядок в C. Це дійсно просто послідовність характер, темперамент, характер, характер, спина, до спини, щоб тому, до спини, щоб всередину пам'яті комп'ютера або ОЗУ. І ми будемо дивитися глибше, що в майбутнє, коли ми дивимося на саму згадку, і використання, і загрози, які беруть участь. 

Але давайте розглянемо рядок Zamyla. Так що назва людина тут, Zamyla, тобто послідовність символи, Z-A-M-Y-L-A. А тепер давайте припустимо, що ім'я Zamyla в Під час збереження всередині комп'ютера Програма. 

Ну, само собою зрозуміло, що ми повинні бути в змозі дивитися на цих персонажів в індивідуальному порядку. Так що я просто хочу, щоб намалювати трохи рамку навколо імені Zamyla тут. І це відбувається в C, що, коли ви є рядок, як Zamyla-- і, можливо, цей рядок повернулася з функція як отримання рядки, ви можете маніпулювати це символ за символом. 

Тепер, це релевантно для Розмова під рукою, тому що в криптографії, якщо ви хочете змінити А в В, і В до С, В і С до D, і так далі, ви повинні бути в змозі дивитися на окремі символи в рядку. Ви повинні бути в змозі змінити Зет до чогось ще, А до чогось ще, щоб М щось ще, і так далі. І тому нам потрібен спосіб, програмним способом, так говорити, в C, щоб мати можливість змінити і подивитися на окремі літери. І ми можемо зробити це в такий спосіб. 

Пусти голову назад в CS50 IDE. І дозвольте мені йти вперед і створити новий файл що я буду називати цей раз string0, як наш перший такий приклад, точка с. І я збираюся йти вперед і збити його наступним чином. 

Так включають CS50.h, і потім включають в себе стандартні io.h, який я майже завжди буде використовувати в своїх програмах, по крайней мере, на початковому етапі. INT головну порожнечу, а потім тут я збирається робити рядки отримує отримати рядок. А потім я збираюся йти вперед і робити це. Я хочу, щоб йти вперед і, як перевірки осудності, просто сказати, привіт, відсотків s, коми, робить рядок 0. Ой, що ж я зробив тут? О, я не підключити його. Так урок, що ні навмисним. 

Так помилка, більше відсотків перетворення, ніж аргументи даних. І тут, в лінія 7-- ОК, так що у мене є, цитата Unquote, це моя рядок PRINTF. У мене є знак відсотка. Але я пропускаю другий аргумент. 

Я пропускаю коми с, що Я маю на попередніх прикладах. Так хороша можливість виправити ще одна помилка, випадково. А тепер дозвольте мені бігти string0, тип в Zamyla. Добре, привіт Zamyla. 

Таким чином, ми запускаємо цей вид програми кілька різних раз зараз. Але давайте робити щось трохи по-іншому в цей раз. Замість того щоб просто друк Zamyla-х повна назва з Printf, давайте зробимо це символ за символом. 

Я збираюся використовувати для циклу. І я збираюся віддати себе змінна підрахунку, називається I. І я буду тримати перебирає, так Поки я менше, ніж довжина с. 

Виявляється, ми не зробили зробити це в останній раз, що з поставляється з Функція називається Стірлінга. Назад в день, а в цілому до сих пір при здійсненні функцій, люди часто вибирають дуже ємні імена, свого роду звук як то, що ви хочете, навіть якщо це не вистачає кількох голосних звуків або букв. Так Стірлінга є ім'я функції, яка приймає аргумент між круглі дужки, які повинні бути рядком. І це як раз повертає ціле число, довжина цього рядка. 

Так що цей цикл на лінії 7 відбувається Щоб почати зворотний відлік на я дорівнює 0. Це буде збільшуватися я на кожній ітерації на 1, як ми робили кілька разів. Але це буде тільки робити це до точки коли я довжина з самої рядки. 

Так що це шлях, в кінцевому рахунку, перебирає персонажів в рядку А як слід. Я збираюся роздрукувати НЕ вся рядок, але відсоток с, один символ а потім нової лінії. А потім я збираюся йти вперед, і мені потрібно сказати, що я хочу надрукувати Ith характер с. 

Так що, якщо я це змінна, яка вказує індекс рядка, де ви в ньому, мені потрібно, щоб мати можливість кажуть, дайте мені ю характер с. І з має спосіб зробити це квадратні дужки. Ви просто говорите від імені рядок, яка в даному випадку є s. Потім ви використовуєте квадратні дужки, які є як правило, трохи вище Return або Enter клавіша на клавіатурі. І тоді ви поклали індекс символ, який ви хочете надрукувати. Таким чином, індекс буде number-- 0, або 1, або 2, або 3, або точка, точка, точка, деяке інше число. 

І ми гарантуємо, що це буде бути правильний номер, тому що я почати відлік з 0. І за замовчуванням, перший символ в рядку є конвенцією 0. І другий персонаж кронштейн 1. І третій персонаж кронштейн 2. І ви не хочете йти занадто далеко, але ми не будемо, тому що ми відбувається не тільки збільшення I до нього дорівнює довжині рядка. І в цей момент, цей цикл зупиниться. 

Отже, дозвольте мені йти вперед і зберегти цей програма, і запустити гарантувати рядку 0. Але я облажався. Побічно оголошуючи функції бібліотеки Stirling з типом такої і such-- зараз, це звучить знайомо. Але це не PRINTF. І це не отримати рядок. 

Я не ввернути в так само, як в цей раз. Але зверніть увагу, тут трохи вниз крім того, включати string.h заголовка, явно надати декларація Стерлінга. Так що насправді ключ там. 

І справді виявляється, є ще один файл заголовка що ми не використали в класі все ж, але це серед тих, доступні до вас, називається string.h. І в цьому файлі, string.h є Стірлінга оголошена. Отже, дозвольте мені йти вперед і зберегти це, зробити рядок 0-- приємно, ніяких повідомлень про помилки на цей раз. 

./string0 Zamyla, і Я збираюся натиснути кнопку введення, в який момент відбувається GetString щоб повернути рядок, помістіть її в с. Тоді, що цикл буде перебирати над символів S один в той час, і друкувати їх по одному в кожному рядку, тому що У мене було, що зворотною косою п в кінці. Так що я міг би опустити, що зворотний слеш п, а потім просто роздрукувати всі Zamyla в тому ж рядку, ефективно перевизначення Printf, що не все, що корисно. Але в даному випадку, я не зробив цього. Я насправді роздруковуються характер, в той час, по одному в кожному рядку, так що ми насправді побачити ефект. 

Але я повинен відзначити одну річ тут. І ми повернемося до це в наступного тижня. Виявляється, що це код потенційно глючний. 

Виявляється, що отримати рядок і деякі інші функції в житті не обов'язково завжди повернути те, що ви очікували. Ми знаємо з класу останнього Час в цьому, що отримати рядок повинна повертати рядок. Але що, якщо користувач друкує такі Найдовше слово або абзац, або есе що там просто не вистачає пам'яті в комп'ютері, щоб відповідати його. 

Як і те, що якщо щось йде неправильно під капотом? Це не може статися часто, але це може статися один раз в той час, дуже рідко. І так виходить, що отримати рядок і функції подібні до нього не обов'язково завжди повертати рядки. Вони можуть повертати деяке значення помилки, деяке значення сторожового так би мовити, що вказує на те, що щось пішло не так. І ви б знали тільки це з дізнавшись його в класі зараз, або прочитавши деяку додаткову документацію. Виявляється, що отримати рядок може повертати значення, зване нульовим. Null це особлива цінність, яку ми будемо повернутися в майбутнього тижня. Але зараз, просто знаю, що якщо я хочу щоб бути дійсно власне в просуванні вперед за допомогою отримання рядки, я не повинні просто назвати його, і сліпо використовувати значення, що повертається, вважаючи, що це рядок. 

Я повинен спочатку сказати, Гей, почекайте хвилину, тільки діяти, якщо s не дорівнює нуль, де нуль, знову ж таки, це просто якесь особливе значення. І це єдине спеціальне значення, яке ви потрібно турбуватися про для отримання рядка. Отримати рядок або збирається повертати рядок або NULL. 

І ця точка знак оклику рівності ви могли б знати, від можливо математичному класі що ви могли б намалювати знак рівності з лінія, що проходить через нього, щоб вказати, не рівні. Це взагалі не персонаж ви можете набрати на клавіатурі. І тому в більшості мов програмування, коли ви хочете сказати, не рівні, ви використовуєте знак оклику, інакше відомий як вибух. Так ви говорите, чубчик одно, що означає не дорівнює, за логікою речей. Це так само, як там не більш ніж, або рівне або менше або дорівнює клавішу на клавіатурі що робить все це в одному символі. Так ось чому, в минулих прикладах, ви зробили відкритий кронштейн, а потім знак рівності, для того, щоб зробити більше або, скажімо, менше. 

Так що винос тут? Це просто спосіб тепер введення цього синтаксису, ця функція, перебирає приватних осіб символів в рядку. І точно так само, як ті площі кронштейни дозволяють отримати на них, розглянути ці квадратні дужки вид натякаючи на це основний дизайн, в результаті чого кожен символ всередині рядка є свого роду затиснуті в десь внизу капот в пам'яті вашого комп'ютера. 

Але давайте зробимо варіант цього. Виявляється, що це програма правильна. Таким чином, на осі CS50 для оцінки код, тепер це правильно. Особливо тепер, коли я перевірка нуль, ця програма ніколи не повинна врізатися. І я просто знаю, що з досвіду. Але немає нічого, що ми можемо дійсно піти не так тут. Але це не дуже добре продумані, тому що давайте повернемося до основ. 

По-перше, principles-- що робить цикл робити? Для циклу робить три речі. Вона инициализирует деякі значення, якщо ви попросите його. Він перевіряє стан. А потім після кожного ітерації, після кожного циклу, він збільшує деякі значення або значення, тут. 

Так що ж це значить? Ми инициализируем я до 0. Ми перевіряємо і переконайтеся, що я менше довжина с, що Z-А-М-У-Л-А, так що менше 6. І справді, 0, як менше 6. 

Ми роздрукувати Z від імені Zamyla в. Тоді ми збільшуємо I від 0 до 1. Потім ми перевіряємо, 1 менше ніж довжина S? Довжина S становить 6. Так. 

Таким чином, ми друкуємо в імені Zamyla, в ZA. Ми збільшуємо I від 0, 1, до 2. Потім ми перевіряємо, на 2 менше довжина імені Zamyla в. 6 так 2 становить менше 6. Так, давайте роздрукувати прямо зараз M в ім'я Zamyla, в третій символ. 

Ключовим моментом тут є те, що на кожному ітерація цієї історії, я перевіряю, це я менше, ніж довжина Zamyla? Але заковика в тому, що Stirling не є властивістю. Ті з вас, хто програмував до цього в Java або іншими мовами може знати довжину рядка є властивість, тільки деякі тільки для читання значення. 

В С в цьому випадку, якщо це функція, яка в буквальному сенсі підрахунку кількості символи в Zamyla кожен раз, коли ми називаємо цю функцію. Кожен раз, коли ви просите комп'ютер, щоб використовувати Stirling, це поглянути на Zamyla, і кажучи: Z-A-M-Y-L-A, 6. І це повертає 6. Наступного разу, коли ви дзвоните то всередині, що цикл, це буде дивитися на Zamyla знову, скажімо Z-А-М-Y-L-A, 6. І він збирається повернутися 6. Так що нерозумно про цей проект? 

Чому мій код не 5 з 5 для дизайну прямо зараз, так би мовити? Ну, Я питаю питання зайве. Я роблю більше роботи, ніж мені потрібно. 

Таким чином, навіть не дивлячись на те, відповідь правильна, я питаючи комп'ютер, що таке довжина Zamyla знову, і знову, і знову, і знову? І ця відповідь ніколи не зміниться. Це завжди буде 6. 

Таким чином, краще рішення, ніж це буде це наступна версія. Дозвольте мені йти вперед і покласти його в окремий файл з ім'ям string1.c, просто тримати його окремо. І виходить, протягом цикл, ви можете насправді оголосити кілька змінних одночасно. 

Так що я буду тримати я і встановити його в 0. Але я також збираюся додайте кому, і сказати, дайте мені змінну п, у якого значення дорівнює значенню довжину рядка с. А тепер, будь ласка, мій стан до тих пір, як я менше п. 

Отже, таким чином, логіка ідентичні в кінці дня. Але я згадуючи значення 6, в цьому випадку. Яка довжина імені Zamyla в? І я ставлю його в п. 

І я до сих пір перевірки умова кожен раз. Є 0 менше, ніж 6? 1 менше, ніж 6? Є 2 менше, ніж 6, і так далі? 

Але я не вимагаю комп'ютер знову і знову, що довжина імені Zamyla в? Що довжина імені Zamyla в? Що довжина імені цього Zamyla в? Я буквально пам'ятати, що перший і відповісти тільки в цій другій змінної п. Так що це зараз було б не тільки правильно, але і добре продумані. 

Тепер, що стосується стилю? Я назвав мої змінні дуже добре, я б сказав. Зараз вони супер лаконічним. І це абсолютно нормально. 

Якщо у вас є тільки один рядок в програмі, Ви могли б також назвати це S для рядка. Якщо у вас є тільки одна змінна для підрахунку в програмі, Ви могли б також назвати це я. Якщо у вас є довжина, п супер часто, як добре. Але я не помітив будь-якої з мого коду. 

Я не повідомив reader-- що будь моя TF, або TA, або просто colleague-- то, що, як передбачається, щоб йти далі в цій програмі. І так, щоб отримати хороший стиль, то, що я хотів би зробити це щось this-- як запитати користувача для входу. І я міг би переписати це будь-яку кількість способів. 

Переконайтеся, що S-- переконайтеся ОТРИМУЄ Рядок, повертається рядок. А потім в here--, і це, можливо, найважливішим comment-- ітерація над персонажами з одного одночасно. І я міг би використовувати будь-який Вибір англійської мови тут, щоб описати кожен з цих шматків коду. 

Зверніть увагу на те, що я не залишається коментувати кожен рядок коду, насправді просто на цікавий з них, ті, є якийсь сенс, що я міг би хочуть, щоб зробити супер ясний комусь читання мого коду. А чому ти дзвониш отримати рядок запитує у користувача для входу? Навіть те, що один не обов'язково все, що описовий характер. Але це допомагає розповісти історію, тому що Другий рядок в історії є, переконайтеся, отримати рядки, повернутої рядок. 

І третій рядок в цій історії, перебирати символів в одному ами зараз. А тепер просто для хорошої заходом, Я збираюся йти вперед і додати ще один коментар, який якраз каже друк I-й символ в с. Тепер, що я зробив в кінці дня? 

Я додав деякі англійські Слова у вигляді коментарів. Символ коса риска означає, агов, Комп'ютер це для людини, не для вас, комп'ютер. Таким чином, вони ігноруються логічно. Вони просто є. 

І дійсно, CS50 IDE показує їх як сірий, як корисні, але не ключ до програми. Зверніть увагу на те, що тепер ви можете зробити. Чи знаєте ви C програмування чи ні, може просто стояти осторонь в цьому Програма, і знежирене коментарі. Попросіть користувача для введення, переконайтеся, отримати рядки, повернутої рядок, перебирати символів в сек по одному за раз, надрукувати символ I-й символ в S-- ви цього не зробите навіть дивитися на код щоб зрозуміти, що робить ця програма. І ще краще, якщо ви самі дивіться в цій програмі протягом тижня або двох, або місяць, або рік, ви теж не маєте дивитися на код, намагаючись пригадати, що я намагаюся зробити з цим кодом? 

Ви сказали собі. Ви описали це для себе, або який-небудь колега або ТА, або TF. І так це тепер буде правильно, і хороший дизайн, і в кінцевому рахунку, хороший стиль, а також. Так що майте це на увазі. 

Так що є ще одна що я збираюся зробити тут що тепер може показати саме те, що відбувається під капотом. Так що ця функція в C та іншими мовами, називається типажів що або неявно або явно дозволяє конвертувати від одного типу даних в інший. Ми маємо справу так далеко сьогодні з рядками. 

І рядки символів. Але пам'ятайте з тижня 0, які символи? Символи просто абстракція на вершині numbers-- десяткових чисел, і десяткових чисел дійсно просто абстракція на вершині двійкових чисел, як ми визначили її. 

Так символи номера. І цифри символів, тільки в залежності від контексту. І виходить, що всередині комп'ютерної програми, Ви можете вказати, як ви хочете виглядати в біти всередині цієї програми? 

Нагадаємо, від тижня 0, що у нас було Ascii, що саме цей код відображення букв до цифр. І ми сказали, капітал А 65. Капітал Б 66, і так далі. 

І зауважте, ми, по суті є символи на верхній ряд тут, як C назве їх, символів, а потім Інтс на другому ряду. І виходить, ви можете конвертувати бесшовно між ними, як правило. І якщо ми хочемо зробити це свідомо, ми може знадобитися для вирішення щось на зразок цього. 

Ми могли б хотіти, щоб перетворити великі букви, щоб знизити випадок, або нижній регістр у верхній регістр. І виходить, що є насправді картина тут ми можемо охопити всього декілька хвилин. Але давайте спочатку подивимося на Приклад виконання цього в явному вигляді. 

Я збираюся повернутися в CS50 IDE. Я збираюся створити файл з ім'ям Ascii 0.c. І я збираюся йти вперед і додати мій стандарт io.h у верхній частині, INT Основна порожнеча у верхній частині моєї функції. А потім я просто буду робити following-- для циклу від я дорівнює, скажімо, 65 років. 

І тоді я буде менше 65, плюс 26 букв в алфавіті. Так що я дам комп'ютер робити математику для мене там. А потім всередині цієї петлі, що я буду друкувати? 

% С є% я зворотної косої межі п. А тепер я хочу, щоб підключити два значення. Я тимчасово поставив питання Оцінки там запросити на це питання. 

Я хочу ітерацію від 65 вперед для 26 букв алфавіту, друк на кожній ітерації, що інтегральний еквівалент персонажа. Іншими словами, я хочу перебрати 26 номерів друку що Ascii символ, буква, і що відповідне число is-- насправді просто відтворення діаграма з цього слайда. Так що ж ці знаки питання бути? 

Що ж, виходить, що другий потрібно просто бути змінної я. Я хочу бачити, що як число. А середній аргумент тут, я можу сказати комп'ютера для лікування, що число я як характер, так замінити його тут відсотків C. 

Іншими словами, якщо я, то людина програміст, знаю, це просто цифри в кінці дня. І я знаю, що 65 повинен карта в якийсь характер. За допомогою цього явного приведення типів, з дужкою, ім'я типу даних, який ви хочете конвертувати, і закритим дужка, Ви можете сказати комп'ютер, агов, комп'ютер, перетворити це число в символ. 

Так що, коли я запускаю це програма після компіляції, давайте подивимося, що я get-- зробити Ascii 0. Чорт це, що я зробив неправильно тут? Використання незаявлених ідентифікатора, все гаразд, не навмисно, але давайте подивимося, якщо ми не можемо Причина через це. 

Так лінія five-- так що я не отримав дуже далеко, перш ніж загвинчування. Все добре. Таким чином, лінія 5 для г дорівнює 65-- я бачу. Так що пам'ятайте, що в C, на відміну від деяких мови, якщо у вас є попереднє програмування досвід, у вас є щоб сказати комп'ютера, на відміну від нуля, то, тип змінної вона. 

І я забув ключову фразу тут. У рядку п'ять, я почав використовувати I. Але я не сказав C які дані типу це. Так що я збираюся йти сюди і кажуть, ах, зробити це ціле число. 

Тепер я збираюся йти вперед і перекомпіліровать. Це зафіксовано, що. ./ascii0 Enter, це свого роду прохолодний. Мало того, що це супер швидко запитати комп'ютер на це питання, а не дивитися його на слайд, вона роздруковується по одному в кожному рядку, А 65, B 66, всі шляхи down--, так як я зробив це 26 times-- з буквами г, що становить 90. І справді, трохи більш розумним буде були для мене не покладатися на комп'ютері, щоб додати 26. Я міг би просто зробити 90, а також, до тих пір, як я не роблять ту саму помилку двічі. Я хочу, щоб йти через г, а не тільки через у. 

Так що це явне приведення. Виявляється, що це навіть немає необхідності. Дозвольте мені йти вперед і повторно запустити цей компілятор, і перекладка Ascii 0. Виявляється, що C є досить розумний. 

І Printf, зокрема, досить розумний. Якщо ви просто пройти я двічі для обох наповнювачів, Printf зрозуміють, ой, ну я тебе знаю дав мені integer-- деяке число, як 65, або 90, або будь-який інший. Але я бачу, що ви хочете, щоб я форматування це число як символ. І тому Printf може неявно наведено ІНТ до напівкоксу для вас. Так що це не проблема взагалі. 

Але зверніть увагу, через цю еквівалентності ми можемо насправді зробити це, як добре. Дозвольте мені йти вперед і зробити один інша версія this-- Ascii 1.C. І замість того, щоб перебирає цілі числа, дійсно може підірвати ваш розум перебирає символів. Якщо символ з отримує капітал A, I хочуть, щоб йти вперед і робити це, до тих пір, С менше або дорівнює для капіталу Z. І на кожній ітерації Я хочу, щоб збільшити C, я можу Тепер в моїй PRINTF лінії тут скажімо, відсотків З відсотків я знову, розділені C. 

А тепер, я можу піти в іншому напрямку, лиття характер явно в ціле число. Так що, знову ж таки, навіщо ви це робите? Це трохи дивно роду розраховувати з точки зору персонажів. 

Але якщо ви розумієте, що це відбувається під капотом, немає дійсно ніякої магії. Ти говориш, агов, комп'ютер дасть мене змінна називається C типу напівкоксу. Ініціалізувати його капіталу А. І помітити одиничні лапки матерії. 

Для символів в C, пам'ятаєте з Минулого тижня, ви використовуєте одиничні лапки. Для рядків, слів, фрази, ви використовуєте подвійні лапки. OK, комп'ютер, продовжуйте робити це, так Поки символ менше або дорівнює р І я знаю, що від мого Ascii таблиці, що все з цих кодів ASCII є суміжними. 

Там немає ніяких прогалин. Так що це просто від А до Z, розділених одним номером кожного. І тоді я можу збільшувати напівкоксу, якщо я дійсно хочу. В кінці дня, це просто число. Я знаю, що це. Так що я можу тільки припустити, щоб додати до нього 1. 

А потім на цей раз, я друкую с, а потім інтегральний еквівалент. І я навіть не потрібно явне приведення. Я можу дозволити Printf і тому комп'ютер зрозуміти речі, так що тепер, якщо я біжу зробити Ascii1./ascii1, Я отримую точно таку ж річ, як добре. 

Не корисна програма, яка не though-- жодного збирається насправді написати програмне забезпечення для того, щоб з'ясувати, що було число, яке відображається в А чи В, або Z? Ти просто гуглити це, або подивитися його в Інтернеті, або подивитися його на слайді, чи щось таке. Так де ж це насправді отримати корисно? 

Ну, якщо говорити про те, що слайд, зверніть увагу, що є фактична картина тут між великими літерами і в нижньому регістрі, що не було випадковим. Зверніть увагу на те, що капітал А 65. Рядкові а є 97. І як далеко нижче випадок а? 

Таким чином, 65 скільки кроків від 97? Таким чином, 97 мінус 65 дорівнює 32. Таким чином, капітал 65 а є. При додаванні 32 до цього, Ви отримуєте в нижньому регістрі а. І, що те ж саме, якщо відняти 32, ви отримаєте назад до столиці A-- ж з B маленькому б, великий С до мало с. 

Всі ці зазори 32 друг від друга. Тепер, це, здавалося б, щоб дозволити нам зробити щось на кшталт Microsoft Word, або Google Docs є, де ви Можна вибрати все, а потім сказати, змінити все в нижньому регістрі, або змінити все в верхній регістр, або змінити тільки перше слово вироку до верхнього регістру. Ми можемо зробити щось як і ми самі. 

Дозвольте мені йти вперед і зберегти файл тут називається капіталізувати 0.c. І давайте йти вперед і нагнітати програму що робить саме те, що в такий спосіб. Так включають в себе бібліотеку CS50. І включають в себе стандартні входи / виходи. 

І я знаю, що це найближчим часом. Так що я збираюся поставити його в там вже, string.h, тому у мене є доступ до такі речі, як Стірлінг, а потім INT головну порожнечу, як зазвичай. А потім я збираюся йти вперед і робити рядки отримує отримати рядок, просто, щоб отримати рядок від користувача. А потім я збираюся зробити мій чек осудність. Якщо рядок не дорівнює нулю, то це безпечно продовжити роботу. І те, що я хочу зробити? Я збираюся перебирати від я дорівнює 0, і п до довжина рядка с. 

І я збираюся зробити це до тих пір, я менше п, і я плюс плюс. До сих пір, я насправді просто запозичення ідеї раніше. А тепер я збираюся ввести філія. 

Так що думайте знову чесати, де ми мали ті розвилки, а минулого тижня в C. Я збираюся говорити про це, якщо я-й символ в секундах більше або одно нижнього регістру а, і-- в порожньому місці ви б в буквальному сенсі кажуть, і, але в C ви говорите амперсанд, ampersand-- і I-й символ в секундах менше або дорівнює рядкові г, давайте зробимо щось цікаве. Давайте насправді роздрукувати характер, без переходу на новий рядок тобто символ в рядку, I-й символ в рядку. 

Але давайте йти вперед і відняти 32 з нього. Інакше, якщо символ в Рядок, ми шукаємо не між Трохи і трохи г, йти вперед і просто роздрукувала його без змін. Таким чином, ми ввели це позначення в квадратних дужках для наших рядків, щоб отримати на I-й символ в рядку. 

Я додав деяку умовну логіку, як Подряпини на минулому тижні тижні один, де Я просто використовую мій фундаментальний розуміння того, що відбувається під капотом. Чи є I-ий символ S більше або дорівнює а? Мовляв, це 97, або 98, або 99, і так далі? 

Але це також менше або дорівнює до значення в нижньому регістрі г? І якщо так, то що це означає ця лінія? 14, це є свого роду паросток всієї ідеї, заголовної лист по просто відняти 32 з нього, в даному випадку, тому що я знаю, за що діаграми, як представлені мої номери. Так що давайте йти вперед і управляти цим, після компіляції капіталізувати 0.c, і запустити капіталізувати 0. 

Давайте ввести щось на зразок Zamyla в нижньому регістрі введення. І тепер ми маємо Zamyla в верхньому регістрі. Давайте ввести Роба в нижньому регістрі. Давайте спробуємо Джейсона в нижньому регістрі. І ми продовжуємо отримання змушені капіталізації. Там є невелика помилка, що я вигляд не очікував. Зверніть увагу на мій новий запит осідає на тому самому рядку, їх імена, який відчуває себе трохи брудним. 

Так що я збираюся їхати сюди, і насправді в кінці цієї програми роздрукувати символ нового рядка. Це все. З Printf, вам не потрібно перейти в змінних або коді формату. Ви можете в буквальному сенсі просто роздрукувати щось на зразок нового рядка. 

Так що давайте йти вперед і зробити капіталізувати 0 раз, повторно запустити його, Zamyla. А тепер це трохи симпатичніше. Тепер, мій запит на своїй власній новій лінії. Так що це все прекрасно і добре. Так що це хороший приклад. Але я навіть не обов'язково необхідно жорстко закодувати 32. Знаєш, що? Я міг би say-- я ніколи не пам'ятайте, в чому різниця. 

Але я знаю, що якщо я мають малої літери, Я по суті хочу, щоб відняти від незалежно від відстані між мало а й великий А, тому що, якщо я припускаю, що всі інші літери однакові, які повинні отримати роботу. Але замість того щоб зробити це, ви знаєте, що? Там ще один спосіб досі. 

Якщо це капіталізувати 1.c-- якби я був щоб помістити це в окремий файл. давайте зробимо капіталізувати 2.C наступним чином. Я збираюся дійсно очистити це тут. І замість того, щоб навіть не маючи знати або піклуватися про тих низькому рівні деталі реалізації, я замість того, щоб тільки збирається надрукувати символ, цитата кінець цитати, відсотки C, і потім викликати іншу функцію, яка існує, що приймає аргумент, який є символом, як це. 

Виявляється, в C, є інший виклик функції до верхньої, яка, як його ім'я передбачає, приймає характер і робить його в верхній регістр еквівалент, а потім повертає його так що Printf можете підключити його там. І так, щоб зробити це, хоча, я необхідно ввести ще один файл. Виявляється, є ще один файл що ви тільки знаєте з класу, або підручник, або інтернет посилання, називається C type.h. 

Так що, якщо я додам, що до мого серед заголовка файли, а тепер заново компілювати цю програму, capitalize2, ./capitalize2 Enter. Давайте ввести Zamyla всього в нижньому регістрі, як і раніше працює так само. Але ви знаєте, що? Виявляється, що у верхній має деякі інші функціональні можливості. 

І дозвольте мені представити це командувати тут, начебто ніяково по імені, але людина для керівництва. Виявляється, що більшість комп'ютерів Linux, як ми використовуємо here-- операційну Linux сістема-- є команда називається людина, яка говорить, агов, комп'ютер, дайте мені роботу з комп'ютером. Що ви хочете шукати в цьому керівництві? 

Я хочу подивитися функцію відкривається верхній, Enter. І це трохи загадкове читати іноді. Але зверніть увагу, що ми в керівництво по Linux програміста. І це весь текст. І зауважте, що це ім'я функції тут. Виявляється, у нього є двоюрідний брат під назвою знизити, яка робить протилежне. І зауважте під синопсис, щоб використовувати цю функцію функціонувати сторінки людини, так би мовити, каже мені, що я необхідно включити гр type.h. І я знав, що з практики. 

Ось, він показує мені два прототипи для функції, так що якщо я коли-небудь хочу, щоб використовувати цю функцію Я знаю, що вони приймають в якості вхідних даних, і те, що вони повертаються в якості вихідного сигналу. І потім, якщо я читаю опис, я бачу більш детально, що функція робить. Але що більш важливо, якщо Я дивлюся під значення, що повертається, він говорить, повернене значення що перетвореного листи, або С, вихідний вхідний, якщо перетворення не вдалося. 

Іншими словами, верхній намагатиметься перетворити лист в верхній регістр. І якщо так, то він збирається повернути її. Але якщо він не може для деяких reason-- може бути, це вже в верхньому регістрі, може бути, це знак оклику або будь-якої іншої punctuation-- це просто буде повернути вихідний C, а це значить, що я можу зробити мій код краще розроблені таким чином. 

Мені не потрібні всі ці штопати рядки коду. Всі рядки я тільки виділений може бути згорнуті в тільки один простий лінія, яка є this-- Printf відсотка з горішнього кронштейну I S. І це було б приклад кращого дизайну. 

Чому реалізувати в 7 або 8 ліній коду, яким би він був я просто видалений, коли ви можете замість того, щоб згорнути все, що логіка і прийняття рішень в одну лінію, 13, що в даний час спирається на бібліотеку function-- функція, яка поставляється з C, але це робить саме те, що ви хочете, щоб це зробити. І, чесно кажучи, навіть якщо він не прийшов з C, ви могли б реалізувати його самостійно, так як ми вже бачили, з Int отримаєте негативний результат і отримати позитивний INT минулого тижня. 

Цей код в даний час набагато більш зручним для читання. І дійсно, якщо ми прокрутки вгору, Подивіться, наскільки більш компактний ця версія моєї програми. Це трохи громіздкою зараз, з усіма цими включає в себе. Але це нормально, тому що тепер я стою на плечі програмістів перед мною. І хто б це не був, хто реалізовані у верхній дійсно зробив мені послугу, так само, як той, хто реалізований Стірлінга дійсно зробив мені послугу деякий час назад. І ось тепер у нас є краще дизайн програми який реалізує ту ж саму логіку. 

Говорячи про Стерлінга, нехай мені йти вперед і робити це. Дозвольте мені йти вперед і зберегти цей файл в якості stirling.c. І виходить, ми можемо відігніть один інший шар досить просто прямо зараз. Я збираюся йти вперед і батіг до іншої програми в головному тут просто повторно знаряддя довжина рядка наступним чином. Так ось рядок коду, яка отримує мене рядок від користувача. Ми продовжуємо використовувати це знову і знову. Дозвольте мені дати собі змінну п типу Int, який зберігає номер. 

І дозвольте мені йти вперед і зробити таку логіку. У той час як п-й символ в S робить НЕ дорівнює 0 зворотної косої межі, йти вперед і приріст п. І потім роздрукувати Printf відсотка I N. Я стверджую, що ця програма тут, без виклику довжини рядка, з'ясовує довжину рядка. 

І магія повністю втілений в рядку 8 ось із чим виглядає як новий синтаксис, це зворотний слеш 0 в одинарні лапки. Але чому? Ну, подумайте, що було відбувається весь цей час. 

І, як в сторону, перш ніж я забув, розумію, також, що на додаток до людини сторінок які приходять з типовим Система Linux як CS50 IDE, розуміти, що ми, Персонал звичайно, в є також зробив версію сайту цієї ж ідеї під назвою reference.cs50.net, яка має всі ті ж людино-сторінок, все той же документації, а також маленька коробочка у верхній частині, що дозволяє конвертувати всі з досить аркан мову в менш комфортно режим, в якому ми, викладацький склад, пройшли і спробував спростити частина мови, щоб тримати речі зосереджені на ідеях, а не деякі тонкощі. Так що майте на увазі, reference.cs50.net в якості ще одного ресурсу, а також. 

Але чому довжина рядка в роботу як я запропонував кілька хвилин тому? Ось ім'я Zamyla знову. А ось ім'я Zamyla в затиснуті в, як я продовжувати робити, щоб намалювати картину його буття, насправді, просто послідовність символів. Але Zamyla не існує в ізоляції в програмі. 

Коли ви пишете і запустити програму, ви використовуєте ваш Mac або ПК як пам'ять, або RAM, так би мовити. І ви можете думати про ваш комп'ютер як має багато гігабайт пам'яті в ці дні. І гіг означає мільярди, тому мільярди байт. 

Але давайте перемотувати в часі. І припустимо, що ми використовуємо дуже старий комп'ютер, має тільки 32 байта пам'яті. Я міг би, на екрані комп'ютера, просто звернути на це наступним чином. 

Я міг би просто сказати, що мій Комп'ютер має вся ця пам'ять. І це, як палиця пам'яті, якщо Ви пам'ятаєте нашу картину минулого разу. А якщо я просто розділити це стільки разів, Я стверджую, що у мене є 32 байта пам'яті на екрані. 

Тепер, насправді, я можу тільки малювати досі на цьому екрані тут. Так що я збираюся йти вперед, і тільки за згодою, малювати пам'яті мого комп'ютера в якості сітки, а не тільки як одна пряма лінія. Зокрема, я стверджую, що в даний час ця сітка, це 8 по 4 сітки, просто представляє всі 32 байта доступної пам'яті в моєму Mac, або доступні в моєму комп'ютері. І вони обгортковий на дві лінії, просто так як він підходить більше на екрані. Але це перший байт. Це другий байт. Це третій байт. 

І це 32-й байт. Або, якщо ми думаємо, як комп'ютер вчений, це байт 0, 1, 2, 3, 31. Так що у вас є від 0 до 31, якщо Ви починаєте відлік з 0. 

Так що, якщо ми використовуємо програму що дзвінки отримати рядок, і ми отримуємо рядок з людського як я назвав Zamyla, Z-A-M-Y-L-A, як в світі робить комп'ютер відслідковувати, який байт, який шматок пам'яті, належить який рядок? Іншими словами, якщо ми переходимо до введіть інше ім'я в комп'ютер, як цей Andi, називаючи отримати рядок вдруге, A-N-D-я повинен закінчити в пам'ять комп'ютера, а також. Але як? 

Що ж, виходить, що під капот, то, що C робить при зберіганні рядків що людські типи в, або що походять з будь-якого іншого джерела, є його окреслює кінець їх з спеціальний character-- зворотної косої межі 0, що це просто особливий спосіб сказати 80 біт поспіль. 

Так A-- це число 97 відгук. Таким чином, деякі моделі з 8 бітів представляє десяткове число 97. Цей зворотний слеш 0 буквально число 0, а.к.а. NUL, N-U-L, на відміну від раніше, N-U-L-L, який ми говорили. Але зараз, просто знаю, що це зворотна коса 0 всього 80 біт поспіль. 

І це як раз цей рядок в пісок, який говорить, що нічого зліва належить до одного рядка або одного типу даних. І нічого вправо належить до чогось ще. найменування Andi, тим часом, який тільки візуально трапляється, щоб обернути на іншій лінії, але це тільки естетична деталь, Аналогічним чином завершується NUL. 

Це струна символів A-N-D-I, плюс п'ятий секретний характер, всі 0 біти, які просто розмежовує кінець імені Andi, а також. І якщо ми називаємо отримати рядок в третій раз в комп'ютері, щоб отримати рядок виду Марія, М-А-Р-I-А, так само є Марії Ім'я NUL завершується з зворотною косою межею 0. 

Це принципово відрізняється від того, як комп'ютер, як правило, зберігати ціле число або число з плаваючою точкою, або інший типи даних до сих пір, тому що згадати, ціле число, як правило, 32 біта, або 4 байта, або можливо навіть 64 біта, або вісім байт. Але багато примітиви в комп'ютері на мові програмування мають фіксоване число байт під hood-- може бути 1, 2, може бути, може бути 4, може бути 8. 

Але рядки, по дизайну, мають динамічне кількість символів. Ви ніколи не знаєте заздалегідь, до тих пір, людські типи в Z-A-M-Y-L-A, або М-А-Р-І-А або А-Н-Д-І. Ви не знаєте, скільки разів користувач збирається вдарити клавіатура. Таким чином, ви не знаєте, як багато символів в заздалегідь ви будете потребувати. 

І так З просто вид листя, як у секрет крихта під капотом в кінці рядка. Після зберігання Z-А-М-Y-L-A в пам'яті, він також просто ставить еквівалент протягом періоду. В кінці речення, він поміщає 80 біт, таким чином, щоб згадати, де Zamyla починається і закінчується. 

Так що зв'язок, Потім, до цієї програми? Ця програма тут, Стірлінга, це просто механізм для отримання рядка від користувача, рядок 6. Рядок 7, я оголосити змінну називається п і встановіть його рівним 0. 

А потім в рядку 8, я просто запитав питання, в той час як п-й символ робить нерівні 0 все bits-- іншими словами, не робить одно цей спеціальний символ, зворотна коса 0, був тільки що спеціальний NUL character-- йти вперед і просто збільшувати п. 

І продовжувати робити це, і тримати роблячи це, і продовжувати робити це. І тому, навіть якщо в минуле ми використовували I, це прекрасно семантично використовувати п, якщо ви просто намагаєтеся розраховувати на цей раз свідомо, і просто хочете назвати це н. Так що це просто продовжує задавати питання, є н-ий символ з всі 0s? Якщо немає, подивіться на наступний вигляд, подивіться на наступний, подивіться на наступний, подивіться на наступний. 

Але як тільки ви бачите зворотну косу 0, це loop-- лінія 9 через 11-- зупиняється. Ви вирватися з циклу в той час, залишаючи всередині цієї змінної п в цілому кількість всіх з символів в рядку, яку ви бачили, таким чином, виведення на друк. Так давайте спробуємо це. 

Дозвольте мені йти вперед і без за допомогою функції Стірлінга, а просто використовуючи свою власну версію доморощені тут називається Стірлінга, дозвольте мені йти вперед і запустити Стірлінга, типу в чомусь як Zamyla, який я знаю наперед становить шість символів. Давайте подивимося, чи працює він. Справді, це шість. Давайте спробуємо з Робом, три символу, три символи, а також, і так далі. Так що все, що відбувається на під капотом. І зверніть увагу, з'єднання, потім, починаючи з першого тижня класу, де ми говорили про щось на зразок абстракції, що саме це нашарування ідей, або складність, на вершині основних принципів. Тут ми начебто дивитися під капотом Стерлінга, так би мовити, щоб з'ясувати, як би це реалізувати? 

І ми могли б повторно реалізувати його самі. Але ми ніколи знову збирається повторно реалізувати Стірлінга. Ми просто збираємося використовувати Стірлінга в порядку насправді отримати деякі рядки довжини. 

Але немає ніякої магії під капотом. Якщо ви знаєте, що під капот, рядок це просто послідовність символів. І це послідовність символів всі вони можуть бути чисельно розглянуті з кронштейном 0, кронштейн 1, кронштейн 2, і ви відомо, що в кінці рядка є спеціальний символ, ви можете з'ясувати, як зробити більшість нічого в Програма, тому що все це зводиться до того, читає і пише пам'ять. Тобто, змінюється і шукає в пам'яті, або переміщення речей навколо в пам'яті, друковані речі на екрані, і так далі. 

Так давайте тепер використовувати цю новознайдену розуміння того, які рядки насправді знаходяться під капотом, і відігніть один інший шар що до сих пір ми ігнорував в цілому. Зокрема, будь-який час ми реалізували програму, ми мали цей рядок коду поблизу верхньої оголошуючи головною. І ми вказали INT головну порожнечу. 

І ця порожнеча всередині дужок говорив весь цей час, що основна сама по собі не приймає жодних аргументів. Будь внесок, що головне, збирається отримати від користувача повинна виходити від якоїсь іншої механізм, як Get INT, або отримати з плаваючою точкою, або отримати рядок, або будь-якої іншої функції. Але виявляється, що коли ви пишете програму, ви можете вказати що ця програма повинна приймають вхідні сигнали від людини в самій командному рядку. 

Іншими словами, навіть якщо ми до сих пір були працює тільки ./hello привіт або аналогічні програми, все інші програми, які ми використовували, що ми самі не писали, приймали, мабуть, командного рядка arguments-- такі речі, як зробити. Ви говорите, що щось на зразок марка, а потім друге слово. Або брязкіт, ви говорите брязкіт, а потім друге слово, ім'я файлу. 

Або навіть RM або СР, як можна було б бачили або використовувати вже видаляти або копіювати файли. Всі ті приймають так звані командного рядка arguments-- додаткові слова в рядку терміналу. Але до сих пір, ми самі не мали Цей розкішний приймати вхідний сигнал від користувача, коли він або вона насправді працює сама програма в командному рядку. 

Але ми можемо зробити це шляхом повторного декларування Основний рухатися вперед, а не як такі, що недійсним в дужках, але ці два аргументи instead-- перший ціле число, а другий щось нове, то, що ми будемо називати масив, щось подібне в дусі до того, що ми бачили в порожньому вигляді списку, але масив рядків, як ми скоро побачимо. Але давайте подивимося на це Як приклад, перш ніж ми розрізняють саме те, що це означає. 

Так що, якщо я йду в CS50 IDE тут, я пішов вперед і оголошений у файлі з ім'ям argv0.c наступний шаблон. І зауважте, єдине, що по-іншому до сих пір є те, що я змінив нікчемним Int ARGC рядок ARGV відкритий кронштейн, близько кронштейн. І зверніть увагу на даний момент, є нічого не всередині цих дужок. 

Там немає числа. І немає я, або N, або будь-який інший лист. Я просто за допомогою квадратні дужки на даний момент, з причин, ми приїдемо назад в мить. 

А тепер, що я збираюся зробити це. Якщо ARGC дорівнює дорівнює 2-- і нагадаємо, що дорівнює рівних є оператором порівняння рівності лівий і правий для рівності. Це не поступка оператор, який єдиний знак рівності, що означає копію від справа наліво якесь значення. 

Якщо ARGC дорівнює дорівнює 2, я хочу скажімо, Printf, привіт, відсотки, нова лінія, а потім підключити in-- і ось новий trick-- ARGV кронштейн 1, з причин що ми повернемося в хвилину. Інакше, якщо ARGC НЕ дорівнює 2, ви знаєте, що? Давайте просто йти вперед і, як зазвичай, друк поза привіт світ, без заміни. 

Так що, здавалося б, що якщо ARGC, який виступає за кількістю аргументів, дорівнює 2, Я збираюся роздрукувати привіт щось або інше. В іншому випадку, за замовчуванням, я збирається надрукувати привіт світ. Так що ж це означає? 

Що ж, дозвольте мені йти вперед і зберегти цей файл, а потім роблять argv0, а потім ./argv0, Enter. І це говорить привіт світ. Тепер, чому це? 

Що ж, виходить, в будь-який час ви запустити програму в командному рядку, ви заповнюєте в тому, що ми будемо зазвичай називаємо вектор аргументів. Іншими словами, автоматично комп'ютер, операційна система, збирається передати вашій програмі Сам список всіх слів що людина набрав на підказка, в разі, якщо програміст хоче зробити щось з цією інформацією. І в цьому випадку єдине слово, Я набрав у рядку є ./argv0. 

І тому число аргументів, є передається в моїй програмі тільки один. Іншими словами, аргумент розраховувати, інакше відомий як ARGC тут як ціле число, це лише один. Один з них, звичайно, не дорівнює двом. І так це те, що друкує, привіт світ. 

Але дозвольте мені взяти це десь. Дозвольте мені сказати, argv0. А потім, як про Марію? А потім натисніть клавішу Enter. 

І зверніть увагу, що чарівним чином тут відбувається. Тепер, замість привіт світ, у мене є змінив поведінку цієї програми приймаючи вхід немає від Get рядок або будь-якої іншої функції, але з, мабуть, моя команда Сам, що я спочатку надрукував. І я можу грати в цю гру знову змінюючи його Стеліос, наприклад. 

А тепер я бачу інше ім'я досі. І тут, я міг би сказати, Анді. І я міг би сказати Zamyla. І ми можемо грати в цю гру протягом всього дня, просто затикати в різних значеннях, до тих пір, як я надати саме два слова в командному рядку таким чином, що ARGC, граф мій аргумент, 2. 

Бачу я, що ім'я підключений до Printf, в цьому стані тут? Таким чином, ми, здається, в даний час виразний потенціал приймати вхідний сигнал від іншого механізму, від так званої командного рядка, замість того, щоб чекати до тих пір, поки користувач не запускає програму, а потім спонукати його або її використовуючи щось на зразок отримання рядка. 

Так що ж це? ARGC, знову ж таки, це всього лише ціле число, кількість words-- arguments-- що користувач за умови, на підкажіть, у вікні терміналу, в тому числі назва програми. Таким чином, наша ./argv0 є, по суті, назва програми, або як я запустити програму. 

Це вважається як слово. Так ARGC буде 1. Але коли я пишу Стеліос, або Andi або Zamyla, або Марія, це означає, що кількість аргументів дорівнює двом. І ось тепер є два слова, які передаються в. 

І зауважте, ми можемо продовжити цю логіку. Якби я насправді сказати щось на зразок Zamyla Чан, повне ім'я, тим самим передавши три аргументи в цілому, Тепер він знову говорить за замовчуванням, тому що, звичайно ж, 3 не дорівнює 2. 

І ось таким чином, у мене є доступ через ARGV цей новий аргумент що ми могли б технічно називати все, що завгодно. Але відповідно до угоди, це ARGV і ARGC відповідно. ARGV, вектор аргументів, є свого роду синоніма для програмування функція в C називається масив. 

Масив являє список значень аналогічних тому, до спини, до спини, до спини. Іншими словами, якщо хтось тут, в RAM, наступний прямо поруч з ним, і поряд з ним. Вони не всюди. І це останній сценарій, де речі знаходяться всюди в пам'яті, може бути насправді потужна функція. Але ми повернемося до того, що, коли ми говорити про химерних структур даних. На даний момент, масив просто шматок безперервної пам'яті, кожен з яких елементи тому, до спини, до спини, до спини, і, як правило той же самий тип. 

Так що якщо ви думаєте про те, від А хвилину тому, що таке рядок? Ну, рядок, як Zamyla, Z-А-М-У-Л-А, це, технічно, просто масив. Це масив символів. 

І тому, якщо ми дійсно зробити це, як я зробив раніше, як шматок пам'яті, виходить, що кожен з них символів займає байт. А тут що особливу сторожового символ, зворотна коса 0, або всі вісім біт 0, що розмежовує кінець цього рядка. Так рядок, виходить поза, цитують Unquote рядок, це просто масив chara-- обвуглюється будучи фактичним типом даних. 

А тепер ARGV, meanwhile-- давайте повернемося до програми. ARGV, хоча ми бачимо, слово Рядок тут, не є сама рядок. ARGV, вектор аргументів, являє собою масив рядків. 

Так само, як ви можете мати масив символів, ви можете мати більш високий рівень, масив strings-- так, наприклад, коли я набрав хвилину назад ./argv0 argv0, простір Z-A-M-Y-L-A, я стверджував, що ARGV мав два рядки в it-- ./argv0, і Z-A-M-Y-L-A. в Іншими словами, ARGC було 2. Чому так? 

Ну, по суті, те, що відбувається на те, що кожна з цих рядків це, звичайно, масив символів як і раніше, кожен з яких персонажі займає один байт. І не плутайте фактичну 0 в назві програми з 0, що означає все 80 біт. І Zamyla, тим часом, як і раніше також масив символів. 

Таким чином, в кінці кінців, це насправді виглядає наступним чином під капотом. Але ARGV, за своєю природою, як головний роботи, дозволяє мені обернути все це до в, якщо ви будете, більший масив що, якщо ми трохи більше спростити що картина виглядає і не досить намалювати її в масштабі там, Цей масив є тільки розміром 2, перший елемент якого містить рядок, другий елемент яка містить рядок. І, в свою чергу, якщо ви вид збільшення на кожному з цих рядків, що ви см під капотом є те, що кожен рядок просто масив символів. 

Тепер, так само, як з рядками, ми були в змозі отримати доступ до г-го символу в рядку за допомогою цієї квадратної дужки позначення. Точно так же, з масивами в загальному, ми можемо використовувати квадратні дужки, позначення, щоб отримати на будь-яку кількість рядків в масиві? Наприклад, дозвольте мені йти вперед і робити це. 

Дозвольте мені йти вперед і створити argv1.c, який трохи відрізняється на цей раз. Замість перевірки для argc2, Я буду замість цього. Для інт я отримую 0, я менше ніж ARGC, я плюс плюс, а потім роздрукувати всередині цього, відсотків s, нова лінія, а потім ARGV кронштейн я. 

Отже, іншими словами, я не маємо справу з окремі символи в даний момент. ARGV, як випливає з цих порожній квадрат брекет одразу після назви ARGV, означає ARGV масив рядків. І ARGC це просто інт. 

Ця лінія тут, 6, є кажучи набір я рівним 0. Граф весь шлях до, але не включаючи, ARGC. І потім на кожній ітерації, роздрукувати рядок. Яка рядок? 

I-го рядка в ARGV. Так що в той час, перш ніж я був використовуючи квадратні дужки позначення, щоб отримати в пана й символ в рядку, тепер Я використовую квадратні дужки, позначення щоб отримати в рядку й у масиві. Так що це свого роду один шар вище, концептуально. 

Так що акуратним про це Програма тепер, якщо я компілює argv1, а потім зробити ./argv1, а потім введіть в чимось на зразок бару Baz Foo, які є три стандартні слова, які вчений досягає протягом будь-якого часу він або вона потребує деяких шаблонні слова, і натисніть Enter, кожне з цих слів, в тому числі назва програми, яка знаходиться в ARGV на першому місці, закінчується друкується по одному за раз. І якщо я змінити це, і я кажу: щось на зразок argv1 Zamyla Чан, ми отримуємо все три з них слова, що є argv0, argv1, argv2, тому що в цьому випадок ARGC, лічильник, 3. 

Але що акуратний, якщо ви розумієте, що ARGV просто масив рядків, і ви розумієте, що рядок являє собою масив символів, ми можемо насправді вид використовувати цю функцію квадратні дужки позначення кілька разів щоб вибрати рядок, а потім виберіть символ в рядку, дайвінг глибше наступним чином. У цьому прикладі, відпусти мене вперед і назвати цю argv2.c. І в цьому прикладі, дозвольте мені йти вперед і зробити following-- для INT я отримую 0, я менше ARGC, я плюс плюс, так само, як і раніше. Таким чином, в іншому words-- і тепер цей стає досить складною. Тоді я збираюся сказати, перебирати струни в ARGV, в якості коментаря до себе. І тоді я буду мати вкладений цикл, який ви, ймовірно, зробили або вважаються робити в порожньому місці, де Я хочу сказати, я int-- не збирається використовувати я знову, тому що я не хочу, щоб тінь, або свого роду переписати існуючий I. 

Я збираюся, а не, скажімо, J, так як це моя перейти до змінної після того як я, коли я просто намагаюся розраховувати прості числа. Для J отримує 0--, а також, п, збирається отримати кормової довжину ARGV кронштейна I, до тих пір, J менше т, J плюс плюс, зробіть наступне. А ось цікава частина. 

Роздрукуйте характер і нову лінію, підключивши ARGV кронштейн I, кронштейн J. ОК, так що дозвольте мені додати деякі коментарі тут. перебрати символи в поточному рядку, друк J-й символ в г-й рядку. Так що тепер, давайте розглянемо Що означають ці коментарі. 

Перебір по струнах в argv-- скільки рядки в ARGV, який є масивом? ARGC багато, тому я ітерація від я дорівнює 0 до ARGC. У той же час, скільки символів в г-го рядка в ARGV? 

Ну, щоб отримати цю відповідь, Я просто називаю довжину рядка на I догляд поточного рядка про, що ARGV кронштейн я. І я збираюся тимчасово зберігати, що значення п, тільки для цілей кешування, пам'ятати його ефективності. І тоді я буду ініціювати J 0, продовжувати йти так довго, як J менше п, і на кожен крок ітерації J. 

А потім тут, в мій коментар в рядку 12, роздрукувати символ, а потім нової лінії, спеціально ARGV кронштейн я дає мені I-го рядка в argv-- так що перше слово, то Друге слово, третє слово, що завгодно. А потім J пірнає глибше і отримує я J-й символ цього слова. І так, по суті, ви можете звертатися ARGV як багатовимірне, як двовимірного масиву ,, причому кожне слово вид виглядає як це в вашій уяві очі, і кожен символ є свого роду полягає в стовпець, якщо це допомагає. 

Насправді, коли ми дражнити це одна від одної в майбутніх тижнів, це буде трохи складнішою, ніж це. Але ви можете реально думати про те, що на даний момент, як тільки що це двовимірна Масив, в результаті чого один рівень його це все рядки. І потім, якщо ви поринаєте в глибше, ви може отримати в окремих символів в ньому, використовуючи ці позначення тут. 

Так що ж таке чистий ефект? Дозвольте мені йти вперед і зробити argv2-- штопати його. Я зробив помилку тут. побічно оголосивши бібліотека функцій Стірлінга. Так що весь цей час, це можливо, доцільно що ми на зразок обробки саме там, де ми почали. 

Я облажався, беззастережне визнання бібліотека функцій Стірлінга. Добре, почекайте хвилину. Я пам'ятаю, що, особливо так як це прямо тут. Мені потрібно, щоб включити string.h в ця версія програми. 

Дозвольте мені йти вперед і включають в себе string.h, крім того, що, йти вперед і пересобрать argv2. І тепер, тут ми йдемо, зробити argv2, Enter. І хоча це трохи загадкові на перший погляд, зверніть увагу, що, насправді, те, що роздруковується є точка argv2. 

Але якщо я ввести деякі слова за підкажіть, як argv2 Zamyla Чан, Введіть, також трохи загадкові на перший погляд. Але якщо ми прокручуємо назад вгору, ./argv2 Z-А-М-У-Л-С-Н-А-Н. Таким чином, ми ітерацію над кожним словом. І, в свою чергу, ми ітерації кожен символ в слові. 

Тепер, після того, як все це, розумію, що є одна деталь ми були свого роду ігнорувати весь цей час. Ми просто дражнять один від одного, що Входи головних може бути? Як щодо виходу головних у? 

Весь цей час ми були просто копіювання і вставка слово INT перед головним чином, хоча ви можете побачити в Інтернеті, іноді неправильно в більш ранніх версіях З і компіляторів, що вони говорять, що порожнеча, або взагалі нічого. Але, насправді, для версії З, що ми використовуємо, C 11, або 2011, реалізувати що воно повинно бути інт. І це повинно бути або недійсним або ARGC і ARGV тут. 

Але чому INT головний? Що це насправді повернення? Що ж, виявляється, весь цей час, в будь-який час ви написали програма головна завжди повертається щось. Але це було робити це таємно. 

Це щось є INT, в рядку 5 пропонує. Але що INT? Ну, є така конвенції в області програмування, причому, якщо нічого не має пішло не так, і все добре, програми та функції в цілому return-- кілька counterintuitively-- 0. 0 в цілому означає, що все добре. Так що навіть якщо ви думаєте це як брехня в багатьох контекстах, це насправді означає, як правило, хороша річ 

У той же час, якщо програма повертає 1, або негативний 1, або 5, або негативний 42, або будь-який не-0 значення, що в цілому означає що щось пішло не так. Насправді, на вашому власному Mac або PC, Ви, можливо, насправді бачив повідомлення про помилку, в результаті чого його говорить щось або інше, помилка код негативний 42, або код помилки 23, або щось в цьому роді. Це число, як правило, тільки натяк програмісту або компанії що зробив програмне забезпечення, що пішло не так і чому, таким чином, щоб вони могли дивитися через їх документація або код, і з'ясувати, що помилка насправді означає. Як правило, не корисним для нас кінцевих користувачів. 

Але коли основні повертає 0, все добре. І якщо ви не вкажете які основні повинні повернутися, він просто буде автоматично повертає значення 0 для вас. Але, повертаючись щось ще насправді корисно. 

У цій заключній програмі, дайте мені йти вперед і назвати цю exit.c, і ввести останній з сьогоднішніх теми, відомі як код помилки. Дозвольте мені йти вперед і включають в себе наші знайомі файли Нагорі, зробіть INT головний. І на цей раз, давайте робити Int ARGC, Рядок ARGV, і з моїх дужках має на увазі, що це в масиві. І тоді дозвольте мені зробити перевірку осудності. На цей раз, якщо ARGC НЕ дорівнює 2, то ви знаєте, що? Забудь це. Я хочу сказати, що, гей, користувач, вам не вистачає аргумент командного рядка зворотна коса п. 

А потім це все. Я хочу, щоб вийти. Я збираюся превентивно, і передчасно дійсно, повернення щось інше, ніж число 1. Перейти до значення для першого помилка, яка може статися 1. Якщо у вас є якийсь інший помилковий ситуація, яка може статися, Ви могли б сказати, повернення 2 або повернення 3, або може бути, навіть негативний 1 або негативний 2. 

Це тільки коди завершення які є, як правило, тільки корисно для програміста, або компанія, судноплавна програмне забезпечення. Але той факт, що це НЕ 0, що важливо. Так що, якщо в цій програмі, я хочу гарантувати, що ця програма тільки працює, якщо користувач надає мені з кількістю аргументів, з двох, назва програми, а також деякі інші слово, я можу застосовувати стільки, скільки треба, кричати на користувача з PRINTF приказці, відсутня аргумент командного рядка, повертає 1. Це буде просто негайно вийти з програми. 

Тільки якщо ARGC дорівнює 2 ми отримаємо вниз тут, в який момент я збираюся сказати, привіт відсотків s, зворотний слеш н, argv1. Іншими словами, я не буде таких того, як ARGV 0, який є тільки назва програми. Я хочу, щоб надрукувати Привіт, кома, друге слово, яке надрукував людина. І в цьому випадку на рядок 13, все добре. 

Я знаю, що ARGC 2 логічно випливає з цієї програми. Я збираюся йти вперед і повертати 0. Як і в сторону, майте на увазі, що це вірно в порожньому місці, а також. 

За логікою речей, я міг би це зробити і инкапсулировать ці рядки коду в цьому пункті інше тут. Але це свого роду зайве відступи мій код. І я хочу, щоб зробити супер ясно, що незалежно від того, за замовчуванням, привіт щось і буде надрукований, до тих пір, поки користувач взаємодіє. 

Так що це дуже поширене використання стан, просто якщо, зловити деякі помилкові ситуація, а потім вийти. І тоді, до тих пір, все ну, не мають іншого, але просто код зовні, що, якщо, тому що це еквівалент в цьому окремий випадок, логічно. Так що я повертаюся 0, просто явно означає, що все добре. 

Якщо я пропустив повернення 0, було б автоматично передбачається, для мене. Але тепер, коли я повертаюся один, по крайней мере цьому випадку, Я збираюся, для хорошої заходом і ясність, повертає 0 в цьому випадку. Так що тепер дозвольте мені йти вперед і зробити вихід, який є ідеальним Segue просто піти. 

Але зробити вихід, і відпустити мене вперед і робити ./exit, Enter. І програма закричав на мене, відсутня аргумент командного рядка. Добре, дозвольте мені співпрацювати. 

Дозвольте мені замість того, щоб робити ./exit, Девід, Enter. А тепер він говорить, привіт Девід. І ви зазвичай не бачите це. 

Але виявляється, що є особливий шлях в Linux насправді побачити з тим, що код завершення програми завершується. Іноді в графічному світ, як Mac OS або Windows, ви бачите тільки ці цифри, коли повідомлення про помилку з'являється на екрані і програміст показує, що число. Але якщо ми хочемо, щоб побачити, що помилка повідомлення, ми можемо зробити це here-- так ./exit, Enter, друк відсутня аргумент командного рядка. 

Якщо я тепер робити відлуння $?, Який смішно загадкові дивлячись. Але $? є магічним заклинанням що говорить, агов, комп'ютер, скажіть мені, що попередній код виходу програми був. І я вдарив Enter. Я бачу 1, тому що це те, що я сказав своєї основної функції, щоб повернутися. 

У той же час, якщо я ./exit Давида, і натисніть Enter, я бачу, привіт Давида. І якщо я тепер робити відлуння $?, Я бачу привіт 0. І таким чином це буде насправді бути цінної інформації в контексті відладчика, не так багато, що ви, людина, буде піклуватися. Але відладчик і інші програми, які ми будемо використовувати в цьому семестрі буде часто дивитися на це число, незважаючи на те, що це свого роду заховані якщо не шукати його, щоб визначити, чи дійсно програми виконання було правильним чи неправильним. 

І так, що приводить нас до це, в кінці дня. Ми почали сьогодні, дивлячись на налагодження, і в свою чергу, в ході сама по собі, а потім більш цікаво, технічно під капотом на те, що рядки, які тривають тиждень ми просто взяли щось само собою зрозуміле, і, звичайно, взяв їх як само собою зрозуміле в порожньому місці. 

Потім ми розглянули, як ми можемо отримати доступ окремі символи в рядку, а потім знову взяв на більш високий рівень дивитися на речі, дивлячись на те, як well-- якщо ми хочемо отримати на індивідуальному елементи в списку, як структура, ми не можемо зробити це з кількома рядками? І ми можемо з аргументами командного рядка. Але ця картина тут просто коробки Показово в цій загальній ідеї масиву або списку або вектора. І в залежності від контекст, всі ці слова означають трохи різні речі. Таким чином, в C, ми тільки збираємося говорити про масиві. І масив являє собою шматок пам'яті, кожен з яких це елементи є суміжними, назад, до спини, до спини, до спини. 

І ці елементи, як правило, одного і того ж типу даних, символів, характер, темперамент, характер, або рядок, рядок, рядок, рядок, або INT, INT, INT, то, що це ми намагаємося зберегти. Але врешті-решт, це як це виглядає концептуально. Ви берете ваш пам'яті або ОЗУ комп'ютера. І ви вирізаючи його в однакового розміру коробки, всі з яких повернулися, до спини, щоб тому, до спини таким чином. 

І що приємно про ця ідея, і той факт, що ми можемо висловити значення в цьому випадку з першим з наших структур даних в класі, означає, що ми можемо почати вирішити проблеми з кодом що прийшло так інтуїтивно в тиждень 0. Ви пам'ятаєте, телефон Приклад книги, де ми використовували розділяй і володарюй, або двійковий алгоритм пошуку, просівати в цілому купа імен та номерів. Але ми припускали, нагадаємо, що це Телефонна книга була вже відсортований, що хтось вже фігурний out-- дан список імен і numbers--, як в алфавітному порядку їх. І тепер, коли в C ми, теж є можливість закласти речі, а не фізично в телефонній книзі але практично в комп'ютера пам'ять, ми зможемо на наступному тижні ввести знову this-- перший наших структур даних в array-- але що більш важливо, фактичний комп'ютер Алгоритми науки реалізовані в коді, за допомогою якого ми можемо зберігати дані в структурах, як це, а потім починають маніпулювати нею, і насправді вирішити проблеми, пов'язані з ним, і побудувати на вершині цього, в кінцевому рахунку, програми в C, в Python, в JavaScript, запитів до баз даних з SQL? 

І ми бачимо, що всі ці різні ідеї блокування. Але зараз, нагадаємо, що Домен, який ми ввели сьогодні була ця річ тут, і світ криптографії. А серед таких проблем ви самі буде вирішувати це мистецтво криптографії, скремблювання і дескремблирования інформація, і шифрування і розшифровка тексту, і припускаючи, в кінцевому рахунку, що тепер ви знаєте, що знаходиться під капотом так що, коли ви бачите або отримати повідомлення як це, ви самі можете розшифрувати його. Все це, і більше в наступний раз. 

[Відеовідтворення] 

-Mover Тільки що прибув. Я збираюся йти візит його професор коледжу. Так. Привіт. Це ти. Зачекайте! Девід. Я просто намагаюся зрозуміти що сталося з вами. Будь ласка, що-небудь може допомогти. Ви були його коледж сусід по кімнаті, чи не так? Ви були там з ним, коли він завершив проект CS50? 

[МУЗИКА] 

-Ось Був CS50. 

Я люблю це місце. 

-Поїсти. Ми збираємося з бізнесу. 

[КІНЕЦЬ ВОСП] 