1
00:00:00,000 --> 00:00:02,970
>> [МУЗИКА]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Малан: Добре.

4
00:00:15,700 --> 00:00:18,832
Це CS50 і це
є початком 2-му тижні.

5
00:00:18,832 --> 00:00:21,040
І ви пам'ятаєте, що більш
останні пару тижнів,

6
00:00:21,040 --> 00:00:24,490
ми представили комп'ютер
наука і, в свою чергу, програмування.

7
00:00:24,490 --> 00:00:27,640
>> І ми почали розповідь шляхом
Подряпина, що графічна мова

8
00:00:27,640 --> 00:00:28,990
з медіа-лабораторії Массачусетського технологічного інституту.

9
00:00:28,990 --> 00:00:30,780
А потім зовсім недавно,
Минулого тижня, ми зробили

10
00:00:30,780 --> 00:00:34,450
ввести higher-- A
мова нижчого рівня відомі

11
00:00:34,450 --> 00:00:36,770
як С, то, що це чисто текстуально.

12
00:00:36,770 --> 00:00:39,440
І, дійсно, останній раз, коли ми
вивчити в цьому контексті

13
00:00:39,440 --> 00:00:40,450
ряд понять.

14
00:00:40,450 --> 00:00:43,010
>> Це, нагадаємо, був дуже
Перша програма ми розглянули.

15
00:00:43,010 --> 00:00:45,710
І ця програма, досить просто,
друкує "Привіт, світ."

16
00:00:45,710 --> 00:00:47,730
Але є так багато
удаваній магії відбувається.

17
00:00:47,730 --> 00:00:51,460
Там ця #include
з цих кутових дужках.

18
00:00:51,460 --> 00:00:52,170
Там в інт.

19
00:00:52,170 --> 00:00:53,020
Там в (анулюються).

20
00:00:53,020 --> 00:00:56,330
Там в круглі дужки, фігурні дужки,
крапка з комою, і багато іншого.

21
00:00:56,330 --> 00:00:58,480
>> Так, нагадаємо, що
ми ввели Подряпину

22
00:00:58,480 --> 00:01:02,110
так що ми могли б, в ідеалі, побачити минуле
що синтаксис, матеріал, який справді не

23
00:01:02,110 --> 00:01:04,590
все, що інтелектуально
цікаво, але на ранніх стадіях

24
00:01:04,590 --> 00:01:07,700
це, безумовно, трохи складніше
щоб обернути ваш розум навколо.

25
00:01:07,700 --> 00:01:10,860
І справді, одне з найпоширеніших
речі на ранньому етапі в класі програмування,

26
00:01:10,860 --> 00:01:13,443
особливо для тих, хто менше
зручно, щоб зламатися,

27
00:01:13,443 --> 00:01:17,460
і підставляли деякими синтаксичними
помилки, не кажучи вже про логічних помилок.

28
00:01:17,460 --> 00:01:19,800
І тому серед наших цілей
сьогодні, насправді, буде

29
00:01:19,800 --> 00:01:23,280
буде оснащувати вас з деякими
методи вирішення проблем для того, як

30
00:01:23,280 --> 00:01:26,705
щоб краще вирішувати проблеми самі
у вигляді налагодження.

31
00:01:26,705 --> 00:01:29,330
І ви пам'ятаєте, теж, що
среда, ми ввели

32
00:01:29,330 --> 00:01:31,780
останній раз був названий CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Це веб-програмне забезпечення,
дозволяє програмувати в хмарі,

34
00:01:34,850 --> 00:01:38,450
так би мовити, зберігаючи при цьому всі ваші
файли разом, як ми знову будемо сьогодні.

35
00:01:38,450 --> 00:01:41,480
І нагадаємо, що ми
переглянути ці теми тут,

36
00:01:41,480 --> 00:01:44,480
серед них функцій, а також петлі, і
змінні і логічні вираження,

37
00:01:44,480 --> 00:01:45,110
і умови.

38
00:01:45,110 --> 00:01:49,190
І насправді дещо більше, що ми
в перекладі з нуля світу

39
00:01:49,190 --> 00:01:50,800
до світу C.

40
00:01:50,800 --> 00:01:53,220
>> Але основна будівля
блоки, так би мовити,

41
00:01:53,220 --> 00:01:55,150
дійсно були всі ті ж минулого тижня.

42
00:01:55,150 --> 00:01:57,900
Насправді, ми дійсно тільки мали
різні шматок головоломки, якщо ви будете.

43
00:01:57,900 --> 00:02:00,300
Замість того, що фіолетовий
зберегти блок, ми замість того, щоб

44
00:02:00,300 --> 00:02:02,940
був PRINTF, який
ця функція в С,

45
00:02:02,940 --> 00:02:05,890
дозволяє надрукувати що-небудь
і відформатувати його на екрані.

46
00:02:05,890 --> 00:02:07,950
Ми ввели CS50
Бібліотека, де ви

47
00:02:07,950 --> 00:02:11,420
є зараз у вашому розпорядженні get_char,
і get_int і get_string,

48
00:02:11,420 --> 00:02:14,610
і кілька інших функцій, як
ну, за допомогою якого ви можете отримати введення

49
00:02:14,610 --> 00:02:16,260
від власної клавіатури користувача.

50
00:02:16,260 --> 00:02:20,640
І ми також взяли погляд на речі
як these- BOOL і напівкоксу,

51
00:02:20,640 --> 00:02:22,490
і подвійні, з плаваючою точкою,
INT, long_long рядок.

52
00:02:22,490 --> 00:02:25,170
І є навіть інші типи даних в C.

53
00:02:25,170 --> 00:02:28,560
>> Іншими словами, коли ви оголошуєте
змінна для зберігання деякого значення,

54
00:02:28,560 --> 00:02:32,600
або при реалізації функції
яка повертає деяке значення,

55
00:02:32,600 --> 00:02:35,290
Ви можете вказати, що
тип значення, яке.

56
00:02:35,290 --> 00:02:37,310
Це рядок, подібно
послідовність символів?

57
00:02:37,310 --> 00:02:39,490
Це число, як ціле число?

58
00:02:39,490 --> 00:02:41,390
Чи є це з плаваючою точкою
значення, чи щось таке?

59
00:02:41,390 --> 00:02:46,180
Таким чином, в C, на відміну від нуля, ми насправді
почав вказувати, який тип даних

60
00:02:46,180 --> 00:02:48,330
ми поверталися або використання.

61
00:02:48,330 --> 00:02:51,910
>> Але, звичайно, ми також зіткнулися з
деякі фундаментальні межі обчислень.

62
00:02:51,910 --> 00:02:54,100
І зокрема,
ця мова C, нагадаємо

63
00:02:54,100 --> 00:02:57,070
що ми дивилися на
Целочисленное переповнення, реальність

64
00:02:57,070 --> 00:03:00,460
що якщо у вас є тільки
кінцеве кількість пам'яті

65
00:03:00,460 --> 00:03:04,600
або, зокрема, кінцеве число
бітів, ви можете розраховувати тільки так високо.

66
00:03:04,600 --> 00:03:08,460
І таким чином, ми дивилися на цей приклад тут
в результаті чого лічильник в літаку ,,

67
00:03:08,460 --> 00:03:13,510
насправді, якщо працює досить довго буде
переповнення і результат в програмному забезпеченні

68
00:03:13,510 --> 00:03:15,560
фактичний фізичний потенціал помилки.

69
00:03:15,560 --> 00:03:18,600
>> Ми також розглянули плаваючою
точка неточностей, реальність

70
00:03:18,600 --> 00:03:22,280
що тільки з кінцевим числом
бітів, будь то 32 чи 64,

71
00:03:22,280 --> 00:03:27,330
ви можете вказати тільки так багато чисел
після десяткового дробу, після чого ви

72
00:03:27,330 --> 00:03:29,110
починають отримувати неточним.

73
00:03:29,110 --> 00:03:32,360
Так, наприклад, одна третина в
світ тут, в нашому людському світі,

74
00:03:32,360 --> 00:03:35,360
ми знаємо, це просто нескінченне число
3 сек після десяткового дробу.

75
00:03:35,360 --> 00:03:38,820
Але комп'ютер не обов'язково
являють собою нескінченне число цифр

76
00:03:38,820 --> 00:03:42,590
якщо ви тільки дайте йому деякі
кінцеве кількість інформації.

77
00:03:42,590 --> 00:03:45,900
>> Так що ми не тільки озброїти вас
з більшою силою в плані

78
00:03:45,900 --> 00:03:49,280
як Ви могли б виразити себе в
клавіатура з точки зору програмування,

79
00:03:49,280 --> 00:03:51,430
ми також обмежені, що
ви можете реально зробити.

80
00:03:51,430 --> 00:03:55,790
І справді, помилки і помилки можуть
виникають з цих видів питань.

81
00:03:55,790 --> 00:03:59,900
І дійсно, серед тем сьогодні
будуть такі теми, як налагодження

82
00:03:59,900 --> 00:04:03,699
і насправді, дивлячись під капотом
на те, як були введені речі минулого тижня

83
00:04:03,699 --> 00:04:05,490
насправді реалізовані
так що вам краще

84
00:04:05,490 --> 00:04:10,530
зрозуміти, як можливостей та
обмеження мови як C.

85
00:04:10,530 --> 00:04:14,770
>> І справді, ми відігніть шари
з найпростіших структури даних,

86
00:04:14,770 --> 00:04:17,756
то, що називається масив, який
Подряпина трапляється називати "список."

87
00:04:17,756 --> 00:04:19,589
це трохи
відрізняється в цьому контексті.

88
00:04:19,589 --> 00:04:23,340
І тоді ми будемо також ввести одне з
перший з наших проблем предметно-орієнтованих

89
00:04:23,340 --> 00:04:26,790
в CS50, світ
криптографія, мистецтво дертися

90
00:04:26,790 --> 00:04:29,650
або в шифруванні інформації, так
що ви можете відправляти секретні повідомлення

91
00:04:29,650 --> 00:04:34,520
і декодувати секретні повідомлення
між двома особами, А і В.

92
00:04:34,520 --> 00:04:37,490
>> Тому, перш ніж ми переходу
до цього нового світу,

93
00:04:37,490 --> 00:04:42,059
давайте спробуємо забезпечити вас з деякими
методи, з якими ви можете усунути

94
00:04:42,059 --> 00:04:43,850
або зменшити принаймні, деякі
розчарувань

95
00:04:43,850 --> 00:04:46,630
що ви, ймовірно, стикалися
Тільки за минулий тиждень.

96
00:04:46,630 --> 00:04:50,830
Насправді, попереду вас such-- деякі з
ваші перші проблеми в С і фори,

97
00:04:50,830 --> 00:04:54,010
якщо ви схожі на мене, в перший раз
ви намагаєтеся надрукувати програму,

98
00:04:54,010 --> 00:04:57,330
навіть якщо ви думаєте, логічно
Програма досить проста,

99
00:04:57,330 --> 00:05:01,200
ви можете дуже добре врізався в стіну, і
компілятор не збирається співпрацювати.

100
00:05:01,200 --> 00:05:03,940
Роблять або Clang не збирається
насправді зробити ваші ставки.

101
00:05:03,940 --> 00:05:05,450
>> І чому це може бути?

102
00:05:05,450 --> 00:05:07,950
Що ж, давайте подивимося на,
може бути, проста програма.

103
00:05:07,950 --> 00:05:11,190
Я збираюся йти вперед і зберегти це в
файл навмисно називають buggy0.c,

104
00:05:11,190 --> 00:05:13,590
тому що я знаю його
бути зіпсований заздалегідь.

105
00:05:13,590 --> 00:05:17,400
Але я не міг зрозуміти, що якщо це
перший або другий або третій програми

106
00:05:17,400 --> 00:05:18,830
що я насправді робить сам.

107
00:05:18,830 --> 00:05:23,820
Так що я збираюся йти вперед і
закарбувати, Int основний (вакуум).

108
00:05:23,820 --> 00:05:28,130
І тоді всередині моїх фігурні дужки,
дуже знайомий ( "привіт, world--

109
00:05:28,130 --> 00:05:30,980
зворотної косої межі, п ") - і крапка з комою.

110
00:05:30,980 --> 00:05:32,360
>> Я зберіг файл.

111
00:05:32,360 --> 00:05:34,850
Тепер я збираюся піти вниз
до мого вікні терміналу

112
00:05:34,850 --> 00:05:40,340
і тип роблять buggy0, тому що, знову ж таки,
ім'я файлу сьогодні buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Так що я типу зробити buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> І, о, господи, пам'ятаєте з останнього часу
що без будь-яких повідомлень про помилки це хороша річ.

115
00:05:48,200 --> 00:05:49,740
Так що висновок не є хорошою річчю.

116
00:05:49,740 --> 00:05:52,920
Але тут я ясно
деяку кількість помилок.

117
00:05:52,920 --> 00:05:56,470
>> Таким чином, в першому рядку виведення
після введення роблять buggy0, нагадаємо,

118
00:05:56,470 --> 00:05:59,540
досить докладний висновок дзвоном в.

119
00:05:59,540 --> 00:06:02,067
Під капотом,
CS50 IDE налаштований

120
00:06:02,067 --> 00:06:04,150
використовувати цілу купу
Варіанти з цим компілятором

121
00:06:04,150 --> 00:06:05,941
так що у вас немає
думати про них.

122
00:06:05,941 --> 00:06:08,840
І це все, що перша лінія
означає, що починається з Clang.

123
00:06:08,840 --> 00:06:11,720
>> Але після цього, проблеми
почати робити їх зовнішній вигляд.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c на лінії 3, характер
5, є велика, червона помилка.

125
00:06:17,390 --> 00:06:18,380
Що це?

126
00:06:18,380 --> 00:06:23,562
Побічно оголошуючи функції бібліотеки
PRINTF з типом Int (сопзЬ сЬаг *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Я маю на увазі, це дуже швидко
стає дуже аркан.

129
00:06:28,379 --> 00:06:30,170
І, звичайно ж, в першу чергу
погляд, ми не будемо

130
00:06:30,170 --> 00:06:32,380
очікують, що ви розумієте
повнота цього повідомлення.

131
00:06:32,380 --> 00:06:34,213
І ось один з уроків
на сьогоднішній день відбувається

132
00:06:34,213 --> 00:06:36,919
щоб спробувати помітити
візерунки, або подібні речі,

133
00:06:36,919 --> 00:06:38,960
до помилок ви можете мати
зіткнулися в минулому.

134
00:06:38,960 --> 00:06:41,335
Так що давайте дражнити тільки одна від одної
ті слова, які виглядають знайомими.

135
00:06:41,335 --> 00:06:44,290
Великий, червоний помилка явно
символом чогось помилитися.

136
00:06:44,290 --> 00:06:47,940
>> беззастережне визнання
Бібліотека функцій Printf.

137
00:06:47,940 --> 00:06:51,680
Так що навіть якщо я не зовсім розумію, що
неявно оголошуючи функції бібліотеки

138
00:06:51,680 --> 00:06:54,900
Значить, проблема, звичайно,
відноситься до PRINTF якимось чином.

139
00:06:54,900 --> 00:06:59,130
І джерело цього питання
має справу з оголосивши його.

140
00:06:59,130 --> 00:07:02,440
>> Оголошення функції є
згадки про нього в перший раз.

141
00:07:02,440 --> 00:07:06,210
І ми використовували термінологію минулого тижня
того, щоб оголосити прототип функції у,

142
00:07:06,210 --> 00:07:11,860
або з однією лінією у верхній частині вашого
власний файл або в так званому файлі заголовка.

143
00:07:11,860 --> 00:07:15,300
І в якому файлі зробив ми говоримо
минулого тижня, що Printf цитата,

144
00:07:15,300 --> 00:07:17,080
Unquote, заявив?

145
00:07:17,080 --> 00:07:20,950
В якому файлі знаходиться його прототип?

146
00:07:20,950 --> 00:07:24,640
>> Так що, якщо ви пам'ятаєте, найперше, що я
типізованих, майже кожна програма в минулому time--

147
00:07:24,640 --> 00:07:30,790
і випадково хвилину назад почалася
набравши myself-- був один here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- для
вхід / output-- точка ч І дійсно,

149
00:07:38,630 --> 00:07:41,860
якщо я тепер зберегти цей файл, я збираюся
йти вперед і очистити екран,

150
00:07:41,860 --> 00:07:44,740
які ви можете зробити, ввівши
Ясно, або ви можете тримати управління L,

151
00:07:44,740 --> 00:07:47,680
просто очистити вікно терміналу
просто щоб усунути деякі перешкоди.

152
00:07:47,680 --> 00:07:51,370
>> Я збираюся йти вперед і
повторно типу роблять buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
І вуаля, я до сих пір бачу, що
довгий час команда з Clang,

154
00:07:53,790 --> 00:07:55,470
але немає ніякого повідомлення про помилку на цей раз.

155
00:07:55,470 --> 00:07:58,800
І справді, якщо я ./buggy0,
так само, як в минулий раз,

156
00:07:58,800 --> 00:08:01,860
де точка означає це
каталог, Слеш просто означає,

157
00:08:01,860 --> 00:08:05,040
тут йде назва програми і
що назва програми buggy0,

158
00:08:05,040 --> 00:08:07,340
Введіть, "Привіт, світ."

159
00:08:07,340 --> 00:08:09,440
>> Тепер, як ви, можливо,
почерпнуті це рішення

160
00:08:09,440 --> 00:08:12,017
не обов'язково
визнаючи, як багато слів,

161
00:08:12,017 --> 00:08:14,350
як і я, звичайно ж, маючи
зробили це протягом багатьох років?

162
00:08:14,350 --> 00:08:18,720
Ну, реалізувати в першому завданні
набір, ми познайомимо вас з командою

163
00:08:18,720 --> 00:08:21,175
що власний персонал CS50 в
написав під назвою help50.

164
00:08:21,175 --> 00:08:24,300
І справді, C робить специфікацію
проблема встановити щодо того, як використовувати цю функцію.

165
00:08:24,300 --> 00:08:27,210
>> Але, по суті, help50
програма, яка співробітники CS50 в

166
00:08:27,210 --> 00:08:30,850
писав, що дозволяє запускати
команда або запустити програму,

167
00:08:30,850 --> 00:08:36,169
і якщо ви не розумієте його
вихід, щоб передати свій вихід help50,

168
00:08:36,169 --> 00:08:38,890
і в цей момент програмне забезпечення
що співробітники звичайно писав

169
00:08:38,890 --> 00:08:42,429
буде виглядати на виході вашої програми
рядок за рядком, по одному символу.

170
00:08:42,429 --> 00:08:46,000
І якщо ми, співробітники, визнають
повідомлення про помилку, що ви відчуваєте,

171
00:08:46,000 --> 00:08:50,580
ми будемо намагатися, щоб спровокувати вас з деякими
риторичні питання, з деякими порадами,

172
00:08:50,580 --> 00:08:54,890
так само, як TF або CA або себе
робитиме особисто в робочий час.

173
00:08:54,890 --> 00:08:58,320
>> Так що дивіться, щоб help50, якщо ви цього не зробите
обов'язково визнають проблему.

174
00:08:58,320 --> 00:09:00,790
Але не покладатися на нього
занадто багато, як милицю.

175
00:09:00,790 --> 00:09:03,990
Звичайно, спробувати зрозуміти його
виведення, а потім витягти з нього

176
00:09:03,990 --> 00:09:07,571
так що тільки один або два рази не так
коли-небудь запустити help50 для конкретної помилки

177
00:09:07,571 --> 00:09:08,070
повідомлення.

178
00:09:08,070 --> 00:09:10,660
Після цього, ви повинні бути
краще оснащені себе

179
00:09:10,660 --> 00:09:13,180
щоб з'ясувати, що це насправді.

180
00:09:13,180 --> 00:09:14,350
>> Давайте зробимо один інший тут.

181
00:09:14,350 --> 00:09:20,410
Дозвольте мені йти вперед, а в іншому
файл, який ми будемо називати цей buggy1.c.

182
00:09:20,410 --> 00:09:23,110
І в цьому файлі я
збирається deliberately--

183
00:09:23,110 --> 00:09:26,330
але робити вигляд, що я не роблю
зрозуміти, що помилка, яку я зробив.

184
00:09:26,330 --> 00:09:31,420
>> Я збираюся йти вперед і робити this--
#include, так як я

185
00:09:31,420 --> 00:09:33,660
дізнався, що мій урок з хвилину назад.

186
00:09:33,660 --> 00:09:36,220
Int основних (недійсними), як і раніше.

187
00:09:36,220 --> 00:09:40,880
І тоді тут я йду
гарантувати рядку з - get_string.

188
00:09:40,880 --> 00:09:43,770
І пам'ятайте з останнього часу,
це означає, агов, комп'ютер,

189
00:09:43,770 --> 00:09:48,280
дайте мені змінну, називаємо це S, і
зробити тип цієї змінної строковим

190
00:09:48,280 --> 00:09:50,150
так що я можу зберігати одне або кілька слів у ньому.

191
00:09:50,150 --> 00:09:52,191
>> А потім на правій руці
сторона знака рівності

192
00:09:52,191 --> 00:09:54,980
є get_string, яка є
функція в бібліотеці CS50

193
00:09:54,980 --> 00:09:55,980
що робить саме це.

194
00:09:55,980 --> 00:09:59,740
Він отримує функцію, а потім
руки його справа наліво.

195
00:09:59,740 --> 00:10:02,670
Так що цей знак рівності не означає,
"Так само", як ми могли б думати в математиці.

196
00:10:02,670 --> 00:10:04,750
Це означає призначення справа наліво.

197
00:10:04,750 --> 00:10:09,640
Таким чином, це означає, взяти рядок з
користувач і зберігати його всередині с.

198
00:10:09,640 --> 00:10:10,460
>> Тепер давайте використовувати його.

199
00:10:10,460 --> 00:10:13,820
Дозвольте мені йти вперед зараз і в якості другого
лінія, дозвольте мені йти вперед і сказати "привіт" -

200
00:10:13,820 --> 00:10:19,330
не «мир", але "Привіт,% S--
яка є нашим заповнювачем, кома s,

201
00:10:19,330 --> 00:10:22,030
яка є нашою змінної,
а потім крапка з комою.

202
00:10:22,030 --> 00:10:26,070
Так що, якщо я не загвинчувати занадто багато
тут, це виглядає як правильний код.

203
00:10:26,070 --> 00:10:28,090
>> І мої інстинкти тепер скомпілювати його.

204
00:10:28,090 --> 00:10:30,400
Файл називається buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Так що я збираюся зробити зробити buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
І штопати-то, якщо немає
навіть більше помилок, ніж раніше.

207
00:10:36,377 --> 00:10:38,210
Я маю на увазі, є більше
Повідомлення про помилки це було

208
00:10:38,210 --> 00:10:40,400
здається, ніж фактичні лінії в цій програмі.

209
00:10:40,400 --> 00:10:42,730
>> Але їжа на будинок тут,
навіть якщо ви перевантажені

210
00:10:42,730 --> 00:10:45,040
з двома або трьома або
ще чотири повідомлення про помилки,

211
00:10:45,040 --> 00:10:48,340
фокус завжди на дуже
Перший з цих повідомлень.

212
00:10:48,340 --> 00:10:52,220
Дивлячись на самий верхній один,
прокрутки назад вгору, як це буде необхідно.

213
00:10:52,220 --> 00:10:53,930
Так ось я надрукував косметику buggy1.

214
00:10:53,930 --> 00:10:55,700
Ось що вихід Clang, як і очікувалося.

215
00:10:55,700 --> 00:10:57,290
>> І ось перша червона помилка.

216
00:10:57,290 --> 00:11:02,370
Використання неоголошеної ідентифікатора
Рядок, я маю на увазі стандарт в?

217
00:11:02,370 --> 00:11:04,260
Так стандарт є
насправді щось інше.

218
00:11:04,260 --> 00:11:06,240
Це відноситься до користувача
клавіатура, по суті.

219
00:11:06,240 --> 00:11:08,080
>> Але це не те, що я мав на увазі.

220
00:11:08,080 --> 00:11:11,770
Я мав на увазі рядок, і я мав на увазі get_string.

221
00:11:11,770 --> 00:11:16,200
Так що ж це, що я
забув зробити на цей раз?

222
00:11:16,200 --> 00:11:20,230
Чого не вистачає на цей раз?

223
00:11:20,230 --> 00:11:23,600
У мене є #include,
тому у мене є доступ до Printf.

224
00:11:23,600 --> 00:11:26,090
>> Але що у мене немає
доступ до щойно ще?

225
00:11:26,090 --> 00:11:29,420
Ну, так же, як в минулий раз,
Я повинен сказати компілятор

226
00:11:29,420 --> 00:11:31,691
Брязкотом, що ці функції.

227
00:11:31,691 --> 00:11:33,940
Get_string не спадає
з С. І зокрема, його

228
00:11:33,940 --> 00:11:38,160
не спадає на
заголовка файлу.

229
00:11:38,160 --> 00:11:40,770
Замість цього він приходить в
щось співробітники писали,

230
00:11:40,770 --> 00:11:44,176
який представляє собою інший файл
ім'я, але влучно назвав.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Так, просто додавши, що одній лінії
з code-- відкликання від останнього часу

233
00:11:50,861 --> 00:11:53,610
що при запуску Clang, це буде
подивитися на мій код зверху вниз,

234
00:11:53,610 --> 00:11:54,193
зліва направо.

235
00:11:54,193 --> 00:11:57,200
Це буде помітити,
Ах, ви хочете.

236
00:11:57,200 --> 00:11:59,900
Дозвольте мені піти і знайти, що,
всюди, де він знаходиться на сервері,

237
00:11:59,900 --> 00:12:03,090
скопіювати і вставити його, по суті,
у верхній частині вашого власного файлу

238
00:12:03,090 --> 00:12:06,820
так що в цей момент в історії,
лінія 1, інша частина програми

239
00:12:06,820 --> 00:12:11,651
може, справді, можна використовувати будь-який з функцій
в ньому, серед них get_string.

240
00:12:11,651 --> 00:12:13,650
Так що я збираюся ігнорувати
інші з цих помилок,

241
00:12:13,650 --> 00:12:17,190
тому що я, справді, підозрюю, що тільки
перший насправді мало значення.

242
00:12:17,190 --> 00:12:20,780
І я збираюся йти вперед і перекладка,
після збереження мого файлу зробити buggy1.

243
00:12:20,780 --> 00:12:22,580
І вуаля, він зробив роботу.

244
00:12:22,580 --> 00:12:29,200
А якщо я ./buggy1 і введіть, для
екземпляр, Zamyla, я тепер отримати привіт,

245
00:12:29,200 --> 00:12:32,000
Zamyla, а не привіт, світ.

246
00:12:32,000 --> 00:12:32,550
>> Добре.

247
00:12:32,550 --> 00:12:35,890
Так ось тоді винос повинні,
один, намагайтеся підбирати стільки, скільки ви можете

248
00:12:35,890 --> 00:12:39,140
від повідомлень про помилки в поодинці, дивлячись
на деяких з розпізнаються слів.

249
00:12:39,140 --> 00:12:43,070
Якщо виключити, що використовувати help50 за
проблема встановити специфікації.

250
00:12:43,070 --> 00:12:46,500
Але за винятком цього теж, завжди звертайте увагу
тільки у верхній помилки, принаймні,

251
00:12:46,500 --> 00:12:50,051
на початковому етапі, щоб побачити, яку інформацію
він може насправді вихід.

252
00:12:50,051 --> 00:12:52,300
Але виявляється, що є
навіть більше функціональних можливостей вбудованої

253
00:12:52,300 --> 00:12:55,030
в бібліотеку CS50, щоб допомогти
ви на ранньому етапі в семестр

254
00:12:55,030 --> 00:12:57,580
і на ранній стадії в програмуванні
з'ясувати, що відбувається не так.

255
00:12:57,580 --> 00:12:59,840
Так давайте зробимо ще один приклад.

256
00:12:59,840 --> 00:13:04,350
Я буду називати це buggy2, який,
знову ж таки, буде зіпсований з

257
00:13:04,350 --> 00:13:05,650
воріт, по дизайну.

258
00:13:05,650 --> 00:13:09,980
>> І я збираюся йти вперед
і робити #include.

259
00:13:09,980 --> 00:13:12,580
А потім я збираюся зробити Int основний (вакуум).

260
00:13:12,580 --> 00:13:14,840
А потім я збираюся зробити цикл.

261
00:13:14,840 --> 00:13:16,690
Для (INT I _ 0.

262
00:13:16,690 --> 00:13:18,750
Я менше або дорівнює 10.

263
00:13:18,750 --> 00:13:24,260
я ++, а потім в фігурні дужки, я йду
роздрукувати тільки символ хештегом тут

264
00:13:24,260 --> 00:13:25,920
і символ нового рядка.

265
00:13:25,920 --> 00:13:29,220
>> Таким чином, мій намір з цим
Програма досить просто

266
00:13:29,220 --> 00:13:33,150
ітерацію в 10 разів
і на кожній ітерації

267
00:13:33,150 --> 00:13:35,260
з цього циклу кожен раз
через цикл,

268
00:13:35,260 --> 00:13:37,660
роздрукувати хештегом,
хештегом, хештегом.

269
00:13:37,660 --> 00:13:40,480
По одному в рядку, тому що я
мають нову лінію там.

270
00:13:40,480 --> 00:13:42,787
І нагадаємо, що для
петля, за останній week--

271
00:13:42,787 --> 00:13:44,620
і ви отримаєте більше
знайомий з синтаксисом

272
00:13:44,620 --> 00:13:47,170
використовуючи його з практикою
Перед long-- це дає мені

273
00:13:47,170 --> 00:13:49,740
змінна називається I і встановлює його в 0.

274
00:13:49,740 --> 00:13:52,650
>> Це збільшує I на
кожній ітерації на 1.

275
00:13:52,650 --> 00:13:54,940
Так що я йде до 1 до 2 до 3.

276
00:13:54,940 --> 00:13:57,690
І тоді ця умова в
посередині між точками з комою

277
00:13:57,690 --> 00:14:03,010
отримує перевіряється на кожній ітерації, щоб зробити
упевнений, що ми все ще в межах діапазону.

278
00:14:03,010 --> 00:14:06,830
Так що я хочу ітерацію в 10 разів, так що я
мають вигляд дуже інтуїтивно просто

279
00:14:06,830 --> 00:14:09,070
покласти 10, як моя верхня межа там.

280
00:14:09,070 --> 00:14:14,310
>> І все ж, коли я запускаю це, після того, як
компіляції із зазначенням марки buggy2--

281
00:14:14,310 --> 00:14:15,440
і вона компілюється ОК.

282
00:14:15,440 --> 00:14:17,980
Так що я не мають
синтаксичну помилку в цей раз.

283
00:14:17,980 --> 00:14:20,940
Дозвольте мені йти вперед прямо зараз
і запустити buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
А тепер можна переходити вгору.

285
00:14:22,620 --> 00:14:24,890
І дозвольте мені збільшити
розмір вікна.

286
00:14:24,890 --> 00:14:33,720
>> Я, здається, є 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Так що 11 хештегів, незважаючи на те,
Я чітко поставив 10 всередині цього циклу.

288
00:14:38,891 --> 00:14:42,140
Тепер, деякі з вас можуть побачити відразу
що помилка відбувається тому, що, справді, це

289
00:14:42,140 --> 00:14:43,720
це не дуже важко помилка зробити.

290
00:14:43,720 --> 00:14:46,070
Але це дуже часто
зробив дуже рано.

291
00:14:46,070 --> 00:14:49,820
>> Те, що я хочу відзначити, однак,
в тому, як я міг би зрозуміти це?

292
00:14:49,820 --> 00:14:52,300
Що ж, виходить, що
CS50 бібліотека приходить

293
00:14:52,300 --> 00:14:55,380
з не тільки get_string і get_int
і get_float і інші функції.

294
00:14:55,380 --> 00:14:59,980
Він також поставляється зі спеціальною функцією
називається eprintf, або, помилка Printf.

295
00:14:59,980 --> 00:15:03,270
І існує тільки зробити
це трохи простіше для вас

296
00:15:03,270 --> 00:15:06,310
при налагодженні коду просто
виводить повідомлення про помилку на екрані

297
00:15:06,310 --> 00:15:07,850
і знаю, звідки вона взялася.

298
00:15:07,850 --> 00:15:11,000
>> Так, наприклад, одна річ, яку я міг би
тут робити з цією функцією є this--

299
00:15:11,000 --> 00:15:20,230
eprintf, а потім я збираюся йти вперед
і сказати, що я тепер% я, зворотний слеш, п.

300
00:15:20,230 --> 00:15:22,330
І я збираюся підключити до значення I.

301
00:15:22,330 --> 00:15:25,400
І нагорі, тому що цей
знаходиться в бібліотеці CS50,

302
00:15:25,400 --> 00:15:27,580
Я збираюся йти вперед
і включають в себе

303
00:15:27,580 --> 00:15:29,169
тому у мене є доступ до цієї функції.

304
00:15:29,169 --> 00:15:31,460
Але давайте розглянемо, що лінія
9 передбачається робити.

305
00:15:31,460 --> 00:15:32,670
Я збираюся видалити це врешті-решт.

306
00:15:32,670 --> 00:15:34,670
Це не має нічого спільного
з моєї головної мети.

307
00:15:34,670 --> 00:15:39,090
Але eprintf, помилка Printf, просто означає,
щоб дати мені деяку діагностичну інформацію.

308
00:15:39,090 --> 00:15:42,460
Коли я запускаю мою програму, я хочу
побачити це на екрані тимчасово

309
00:15:42,460 --> 00:15:44,550
а просто зрозуміти,
що відбувається.

310
00:15:44,550 --> 00:15:47,330
>> І справді, на кожному
ітерація тут лінії 9

311
00:15:47,330 --> 00:15:49,260
Я хочу бачити, як і величина I?

312
00:15:49,260 --> 00:15:50,290
Що таке значення I?

313
00:15:50,290 --> 00:15:51,280
Що таке значення I?

314
00:15:51,280 --> 00:15:55,650
І, сподіваюся, я повинен тільки
бачити, що повідомлення, крім того, в 10 разів.

315
00:15:55,650 --> 00:15:57,780
>> Отже, дозвольте мені йти вперед і
перекомпіліровать мою програму,

316
00:15:57,780 --> 00:15:59,905
як я повинен робити в будь-який час
Я внести зміни. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
І now-- OK.

319
00:16:03,640 --> 00:16:04,820
Там дуже багато більше відбувається.

320
00:16:04,820 --> 00:16:07,610
Отже, дозвольте мені перегорнути вгору
ще більше вікно.

321
00:16:07,610 --> 00:16:10,190
>> І ви побачите, що кожен з
Hashtags як і раніше друку.

322
00:16:10,190 --> 00:16:15,270
Але між кожним з них в даний час цей
діагностичний висновок відформатований наступним чином.

323
00:16:15,270 --> 00:16:17,960
Назва моєї програми тут є buggy2.

324
00:16:17,960 --> 00:16:20,432
Файл buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Номер рядка, з якої
це було надруковано в рядку 9.

326
00:16:24,080 --> 00:16:27,500
А потім справа, що є
повідомлення про помилку, що я очікував.

327
00:16:27,500 --> 00:16:30,701
>> І що приємно про це полягає в тому, що
Тепер я не повинен обов'язково розраховувати

328
00:16:30,701 --> 00:16:32,200
в моїй голові, що моя програма робить.

329
00:16:32,200 --> 00:16:34,240
Я бачу, що на
Перша ітерація я = 0,

330
00:16:34,240 --> 00:16:39,420
потім 1, потім 2, потім 3, потім 4, потім
5, потім 6, потім 7, потім 8, то 9, то,

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Так, почекайте хвилину.

333
00:16:42,050 --> 00:16:43,740
Що тут відбувається?

334
00:16:43,740 --> 00:16:48,190
Я до сих пір, здається, вважаючи
як задумано до 10.

335
00:16:48,190 --> 00:16:50,550
>> Але де ж мені почати?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

337
00:16:53,240 --> 00:16:58,040
Таким чином, 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11-й палець

338
00:16:58,040 --> 00:16:59,990
свідчить про проблему.

339
00:16:59,990 --> 00:17:02,850
Я, здається, підрахували
неправильно в моєму циклі.

340
00:17:02,850 --> 00:17:06,599
Замість того, щоб йти 10 ітерацій,
Я починаючи з 0,

341
00:17:06,599 --> 00:17:09,550
Я і закінчуючи через 10.

342
00:17:09,550 --> 00:17:12,030
Але, так як, як комп'ютер,
Я починаю відлік з 0,

343
00:17:12,030 --> 00:17:15,250
Я повинен бути підраховуючи
до, але не до кінця, 10.

344
00:17:15,250 --> 00:17:18,510
>> І тому виправлення, я врешті-решт
тут реалізується, є однією з двох речей.

345
00:17:18,510 --> 00:17:22,430
Я міг би дуже просто сказати,
порахувати до менш 10.

346
00:17:22,430 --> 00:17:27,260
Таким чином, 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, яка є, по суті, вірно,

347
00:17:27,260 --> 00:17:28,900
незважаючи на те, що це звучить трохи неправильно.

348
00:17:28,900 --> 00:17:35,070
Або я міг би зробити менше або дорівнює
до 9, до тих пір, як я починаю з 0.

349
00:17:35,070 --> 00:17:40,056
Або, якщо ви дійсно не подобається, що ти
може розраховувати через 10, але починаються з 1.

350
00:17:40,056 --> 00:17:41,680
Але знову ж таки, це просто не так часто.

351
00:17:41,680 --> 00:17:43,977
У programming-- хоча і
не стільки в Scratch--

352
00:17:43,977 --> 00:17:45,810
але при програмуванні в
C та іншими мовами,

353
00:17:45,810 --> 00:17:47,670
як JavaScript і
Python і інші, це

354
00:17:47,670 --> 00:17:49,880
просто дуже часто для
наше обговорення бінарна

355
00:17:49,880 --> 00:17:53,450
щоб просто почати відлік на
найменше число ви можете, що 0.

356
00:17:53,450 --> 00:17:53,950
Добре.

357
00:17:53,950 --> 00:17:55,160
Так ось eprintf.

358
00:17:55,160 --> 00:17:58,600
І знову ж таки, тепер, коли я зрозумів, що я
Проблема, і я збираюся повернутися до 0

359
00:17:58,600 --> 00:18:01,470
через менш ніж 10, я збираюся
піти і видалити eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Воно не повинно бути там, коли я
відправити мій код або відправити свій код

361
00:18:04,580 --> 00:18:05,800
або показати його кому-небудь ще.

362
00:18:05,800 --> 00:18:07,980
Це дійсно просто мав на увазі
які будуть використовуватися тимчасово.

363
00:18:07,980 --> 00:18:11,650
Але тепер я це виправив
Особливою проблемою, а також.

364
00:18:11,650 --> 00:18:16,780
>> Що ж, давайте зробимо ще один приклад тут
що я буду нагнітати таким чином.

365
00:18:16,780 --> 00:18:22,850
Я збираюся йти вперед і
#включати . $ 50

366
00:18:22,850 --> 00:18:25,580
І я збираюся йти вперед
і #include.

367
00:18:25,580 --> 00:18:29,030
>> І я збираюся зберегти
цей файл в якості buggy3.c.

368
00:18:29,030 --> 00:18:31,740
І я збираюся йти вперед
і оголосити Int основний (вакуум).

369
00:18:31,740 --> 00:18:34,186
А потім всередині там
Я збираюся зробити INT I _ -

370
00:18:34,186 --> 00:18:36,435
Я хочу, щоб реалізувати програму
з get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Це не функція, яка існує до цих пір.

373
00:18:40,770 --> 00:18:42,870
Отже, ми збираємося реалізувати
це лише мить.

374
00:18:42,870 --> 00:18:45,541
Але ми будемо бачити, чому
вони є хибними на першому проході.

375
00:18:45,541 --> 00:18:47,290
І як тільки я отримав
викличте переривання від користувача,

376
00:18:47,290 --> 00:18:53,365
Я просто хочу, щоб надрукувати% I є негативним
цілим числом, зворотної косої межі, п, кома, я.

377
00:18:53,365 --> 00:18:55,240
Іншими словами, все, що я
хочу цю програму, щоб зробити

378
00:18:55,240 --> 00:18:58,000
це отримати негативне Int з
користувач, а потім роздрукувати

379
00:18:58,000 --> 00:18:59,980
що такий негативний Int.

380
00:18:59,980 --> 00:19:02,080
>> Тепер мені потрібно реалізувати цю функцію.

381
00:19:02,080 --> 00:19:05,740
Так що пізніше в моєму файлі, я збираюся піти
вперед і оголосити функцію під назвою

382
00:19:05,740 --> 00:19:10,670
get_negative_int (порожнеча) - і ми
повернутися до того, що означає, що лінія знову

383
00:19:10,670 --> 00:19:18,790
в moment-- Int N; do-- робити
following-- Printf п:.

384
00:19:18,790 --> 00:19:26,210
А потім я збираюся зробити п - get_int,
і зробити це в той час як п більше 0.

385
00:19:26,210 --> 00:19:28,310
А потім повернутися п;.

386
00:19:28,310 --> 00:19:31,730
>> Так що є багато відбувається в
не це, але жоден з яких ми не робили

387
00:19:31,730 --> 00:19:33,710
подивіться на останній тиждень, по крайней мере, на короткий час.

388
00:19:33,710 --> 00:19:36,980
Так що в рядку 10 тут я оголошений
Функція називається get_negative_int,

389
00:19:36,980 --> 00:19:39,620
і я поставив (порожнеча), в
круглі дужки, з тієї причини, це

390
00:19:39,620 --> 00:19:40,950
не приймає вхідний сигнал.

391
00:19:40,950 --> 00:19:42,910
Я нічого не пропускаючи
до цієї функції.

392
00:19:42,910 --> 00:19:44,690
Я просто отримую щось від нього.

393
00:19:44,690 --> 00:19:47,270
>> А що я сподіваюся
отримати назад ціле.

394
00:19:47,270 --> 00:19:50,040
Там немає тип даних
C називається negative_int.

395
00:19:50,040 --> 00:19:52,880
Це просто Int, так що це буде
щоб бути на нас, щоб переконатися,

396
00:19:52,880 --> 00:19:55,340
що значення, яке насправді
Повертається не тільки INT

397
00:19:55,340 --> 00:19:56,380
але також негативно.

398
00:19:56,380 --> 00:20:02,150
>> У рядку 12 я оголошую змінну
називається п і робить його типу Int.

399
00:20:02,150 --> 00:20:07,500
А потім в рядку 13 до 18 Я
робити щось в той час як-то вірно.

400
00:20:07,500 --> 00:20:11,040
Я йду вперед і друк
п, двокрапка, а потім пробіл,

401
00:20:11,040 --> 00:20:12,800
як підказку для користувача.

402
00:20:12,800 --> 00:20:16,410
>> Я потім викликати get_int і
зберігати його так зване повертається значення

403
00:20:16,410 --> 00:20:18,130
в цієї змінної п.

404
00:20:18,130 --> 00:20:22,600
Але я буду продовжувати робити
це в той час як п більше 0.

405
00:20:22,600 --> 00:20:27,960
Іншими словами, якщо користувач дає мені
Int і це число більше 0,

406
00:20:27,960 --> 00:20:31,180
ерго, позитивний, я збираюся
просто тримати reprompting користувача,

407
00:20:31,180 --> 00:20:37,160
тримати reprompting, змушуючи їх
співпрацювати і дайте мені негативний результат Int.

408
00:20:37,160 --> 00:20:41,640
>> І як тільки п насправді negative--
Припустимо, що користувач нарешті типу -50,

409
00:20:41,640 --> 00:20:46,710
то це не в той час як цикл вже не так
бо -50 не більш 0.

410
00:20:46,710 --> 00:20:51,140
Таким чином, ми порушуємо з цього
петля логічно і повернутися п.

411
00:20:51,140 --> 00:20:53,520
>> Але є ще одна
що я повинен робити.

412
00:20:53,520 --> 00:20:56,190
І я можу просто зробити це
шляхом копіювання і вставки

413
00:20:56,190 --> 00:20:58,540
один рядок коду у верхній частині файлу.

414
00:20:58,540 --> 00:21:01,630
Мені потрібно, щоб навчити Clang,
або обіцянку брязкотом,

415
00:21:01,630 --> 00:21:04,630
явно, що я буду,
насправді, піти і здійснити

416
00:21:04,630 --> 00:21:06,020
ця функція get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Це може бути просто нижче в файлі.

418
00:21:07,674 --> 00:21:09,840
Знову ж, нагадаємо, що Clang
читає речі зверху вниз,

419
00:21:09,840 --> 00:21:12,330
зліва направо, так що ви не можете
викликати функцію, якщо Clang

420
00:21:12,330 --> 00:21:15,330
не знає, що це буде існувати.

421
00:21:15,330 --> 00:21:18,430
>> Тепер, на жаль, ця програма,
так як деякі з вас могли помітити,

422
00:21:18,430 --> 00:21:19,590
вже глючить.

423
00:21:19,590 --> 00:21:21,400
Дозвольте мені йти вперед і зробити buggy3.

424
00:21:21,400 --> 00:21:26,904
Він збирає, так що моя проблема зараз не
синтаксичну помилку, як текстової помилки,

425
00:21:26,904 --> 00:21:29,570
це насправді буде логічним
помилка, що я навмисно

426
00:21:29,570 --> 00:21:32,450
зробив як можливість
покроково, що відбувається.

427
00:21:32,450 --> 00:21:35,540
>> Я збираюся йти вперед
Тепер і запустити buggy3.

428
00:21:35,540 --> 00:21:37,490
І я збираюся піти
вперед, а не співпрацювати.

429
00:21:37,490 --> 00:21:39,494
Я збираюся дати йому номер 1.

430
00:21:39,494 --> 00:21:41,410
Це не сподобалося, так
це мене знову пробуджуючи.

431
00:21:41,410 --> 00:21:42,147
>> Як щодо 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Жоден з них не працюють.

435
00:21:44,740 --> 00:21:46,890
Як щодо -50?

436
00:21:46,890 --> 00:21:48,560
І програма, здається, працює.

437
00:21:48,560 --> 00:21:49,970
>> Дозвольте мені спробувати ще раз.

438
00:21:49,970 --> 00:21:53,400
Дозвольте мені спробувати -1, здається, працює.

439
00:21:53,400 --> 00:21:56,380
Дозвольте мені спробувати -2, здається, працює.

440
00:21:56,380 --> 00:21:59,640
Дозвольте мені спробувати 0.

441
00:21:59,640 --> 00:22:01,684
Так, це невірно.

442
00:22:01,684 --> 00:22:03,350
Тепер ми, будучи трохи педантичним тут.

443
00:22:03,350 --> 00:22:07,090
Але це, насправді, так що 0
не є ні позитивним, ні негативним.

444
00:22:07,090 --> 00:22:11,150
І тому той факт, що моя програма
кажучи, що 0 є негативним цілим числом,

445
00:22:11,150 --> 00:22:12,820
це не технічно правильно.

446
00:22:12,820 --> 00:22:15,180
>> Тепер, чому він це робить?

447
00:22:15,180 --> 00:22:16,270
Ну, це може бути очевидним.

448
00:22:16,270 --> 00:22:18,110
І, дійсно, програма
мав на увазі, щоб бути досить простим

449
00:22:18,110 --> 00:22:19,670
тому у нас є щось, щоб досліджувати.

450
00:22:19,670 --> 00:22:25,870
>> Але давайте введемо третю налагодження
Техніка тут називається debug50.

451
00:22:25,870 --> 00:22:27,750
Так що це програма
що ми тільки що створили

452
00:22:27,750 --> 00:22:30,770
У цьому році під назвою debug50
що дозволить вам

453
00:22:30,770 --> 00:22:34,130
використовувати те, що називається вбудованим
графічний відладчик в CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
І відладчик просто програма, яка
як правило, дозволяє запускати програму

455
00:22:38,400 --> 00:22:44,050
але крок за кроком за кроком, лінії
по лінії по лінії, роблячи паузу, тикаючи

456
00:22:44,050 --> 00:22:47,626
навколо, дивлячись на змінні, так що
програма не просто удар повз вас

457
00:22:47,626 --> 00:22:49,750
і швидко надрукувати що-небудь
або не надрукували що-небудь.

458
00:22:49,750 --> 00:22:53,250
Це дає можливість, в
людська швидкість, щоб взаємодіяти з ним.

459
00:22:53,250 --> 00:22:55,470
>> І зробити це, ви
просто зробіть наступне.

460
00:22:55,470 --> 00:22:58,479
Після компіляції коду,
які я вже зробив, buggy3,

461
00:22:58,479 --> 00:23:00,020
ви йдете вперед і запустити debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Так само, як help50 має запуску
help50, а потім команда,

464
00:23:06,760 --> 00:23:10,120
debug50 має запустити debug50 і
то ім'я команди.

465
00:23:10,120 --> 00:23:14,440
>> Тепер подивимося, що відбувається на моєму екрані,
на правій стороні, зокрема.

466
00:23:14,440 --> 00:23:19,400
Коли я вдарив Виконати, все
раптова панель ця права

467
00:23:19,400 --> 00:23:20,419
відкриває на екрані.

468
00:23:20,419 --> 00:23:22,210
І є багато чого відбувається
на на перший погляд.

469
00:23:22,210 --> 00:23:25,110
Але є не дуже
багато причин для занепокоєння поки немає.

470
00:23:25,110 --> 00:23:28,570
>> Це показує мені все
що відбувається всередині моєї програми

471
00:23:28,570 --> 00:23:31,130
прямо зараз, і через них
Кнопки вгору верхньої потім

472
00:23:31,130 --> 00:23:35,910
що дозволило мені пройти через мій код
в кінцевому підсумку крок за кроком за кроком.

473
00:23:35,910 --> 00:23:37,140
Але не тільки поки.

474
00:23:37,140 --> 00:23:38,060
Зверніть увагу на те, що відбувається.

475
00:23:38,060 --> 00:23:40,600
У моєму вікні терміналу
Я вам буде запропоновано ввести п.

476
00:23:40,600 --> 00:23:44,560
І я збираюся йти вперед і
співробітництво на цей раз і введіть -1.

477
00:23:44,560 --> 00:23:48,770
І хоча і трохи загадково, -1
є негативним цілим числом, як і слід було очікувати.

478
00:23:48,770 --> 00:23:52,020
>> І тоді дитина вийшла з
Статус 0 GDBserver виходу.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, це ім'я
що лежить в основі програмного забезпечення

480
00:23:55,180 --> 00:23:56,620
який реалізує цей відладчик.

481
00:23:56,620 --> 00:24:00,500
Але все це насправді означає, відладчик
пішов, тому що моя програма кинути курити

482
00:24:00,500 --> 00:24:01,710
і все було добре.

483
00:24:01,710 --> 00:24:06,020
Якщо я хочу, щоб дійсно налагоджувати програму,
Я повинен сказати, превентивно debug50,

484
00:24:06,020 --> 00:24:08,920
де я хочу, щоб почати
покрокового мій код?

485
00:24:08,920 --> 00:24:11,750
>> І, мабуть, найпростіший спосіб
зробити це в такий спосіб.

486
00:24:11,750 --> 00:24:15,300
Якщо я парити над
Жолоб мого редактора тут,

487
00:24:15,300 --> 00:24:19,090
так насправді просто в бічній панелі тут,
зліва від номера рядка,

488
00:24:19,090 --> 00:24:21,870
Зверніть увагу, що, якщо я просто натисніть
один раз, я ставлю маленьку червону крапку.

489
00:24:21,870 --> 00:24:24,460
І ця маленька червона точка,
як знак зупинки, значить, агов,

490
00:24:24,460 --> 00:24:29,430
debug50, виконання паузи мого коду
прямо там, коли я запустити цю програму.

491
00:24:29,430 --> 00:24:30,260
>> Так давайте зробимо це.

492
00:24:30,260 --> 00:24:37,340
Дозвольте мені йти вперед і запустити мою програму
знову з debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
А тепер, зверніть увагу, що щось
інакше сталося.

494
00:24:40,110 --> 00:24:42,440
Я не запит
все ж в моєму вікні терміналу

495
00:24:42,440 --> 00:24:45,430
ні за що, тому що у мене немає
отримав там ще в моїй програмі.

496
00:24:45,430 --> 00:24:47,950
Зверніть увагу на те, що в рядку 8
який в даний час виділено,

497
00:24:47,950 --> 00:24:51,720
і є маленька стрілка
ліва вислів, ти зупинився тут.

498
00:24:51,720 --> 00:24:55,030
Цей рядок коду, рядка
8, досі не виконано.

499
00:24:55,030 --> 00:24:58,940
>> І що цікаво, якщо я дивлюся
тут на правій стороні,

500
00:24:58,940 --> 00:25:03,530
зверніть увагу, що я є локальним
змінна, локальна в тому сенсі,

501
00:25:03,530 --> 00:25:05,450
що вона всередині поточної функції.

502
00:25:05,450 --> 00:25:08,920
І його значення, по-видимому, за замовчуванням,
і начебто зручно, дорівнює 0.

503
00:25:08,920 --> 00:25:10,260
Але я не тип 0.

504
00:25:10,260 --> 00:25:13,410
Це як раз трапляється бути його
Значення за замовчуванням в даний момент.

505
00:25:13,410 --> 00:25:15,490
>> Отже, дозвольте мені йти вперед і робити це зараз.

506
00:25:15,490 --> 00:25:18,680
Дозвольте мені йти вперед і на
в правому верхньому кутку тут, я

507
00:25:18,680 --> 00:25:20,970
йти вперед і
натисніть цю першу іконку, яка

508
00:25:20,970 --> 00:25:25,360
означає крок, над яким означає не пропустити
це, але переступити цей рядок коду,

509
00:25:25,360 --> 00:25:27,770
виконуючи його по дорозі.

510
00:25:27,770 --> 00:25:30,710
>> А тепер зверніть увагу, що я
швидке щойно змінив.

511
00:25:30,710 --> 00:25:31,380
Чому так?

512
00:25:31,380 --> 00:25:33,639
Я сказав debug50,
запустити цей рядок коду.

513
00:25:33,639 --> 00:25:34,930
Що робить цей рядок коду робити?

514
00:25:34,930 --> 00:25:35,960
Запитує мене на міжнар.

515
00:25:35,960 --> 00:25:36,460
ДОБРЕ.

516
00:25:36,460 --> 00:25:37,400
Дозвольте мені співпрацювати.

517
00:25:37,400 --> 00:25:41,340
Дозвольте мені йти вперед зараз і введіть -1, Enter.

518
00:25:41,340 --> 00:25:42,920
А тепер зверніть увагу, що змінилося.

519
00:25:42,920 --> 00:25:46,060
З правого боку,
моя локальна змінна я

520
00:25:46,060 --> 00:25:48,200
позначається як -1 в даний час.

521
00:25:48,200 --> 00:25:49,810
І це все-таки типу Int.

522
00:25:49,810 --> 00:25:53,102
>> І зауважте, теж, мій так званий
стек викликів, де ж я паузу?

523
00:25:53,102 --> 00:25:54,810
Ми будемо говорити більше про
це в майбутньому.

524
00:25:54,810 --> 00:25:58,620
Але стек викликів просто посилається на те, що
функції в даний час в русі.

525
00:25:58,620 --> 00:26:00,040
Зараз це просто головний.

526
00:26:00,040 --> 00:26:03,590
І зараз єдиний місцевий
змінна I зі значенням 1.

527
00:26:03,590 --> 00:26:09,840
>> І коли я, нарешті, крок по цій лінії
тут, з тієї ж значок в правому верхньому куті,

528
00:26:09,840 --> 00:26:11,410
-1 Є негативним цілим числом.

529
00:26:11,410 --> 00:26:13,580
Тепер він затримавшись над цим фігурною дужкою.

530
00:26:13,580 --> 00:26:14,740
Давайте нехай це роблять свою справу.

531
00:26:14,740 --> 00:26:17,300
Я переступити цей рядок, і вуаля.

532
00:26:17,300 --> 00:26:20,240
>> Так що не все, що жахливо
повчально все ж,

533
00:26:20,240 --> 00:26:23,550
але це дозвольте мені зробити паузу
і думаю, що через логічно

534
00:26:23,550 --> 00:26:24,870
що ця програма робить.

535
00:26:24,870 --> 00:26:26,890
Але це не було помилковим випадком.

536
00:26:26,890 --> 00:26:28,510
Давайте зробимо це знову в такий спосіб.

537
00:26:28,510 --> 00:26:31,340
>> Я збираюся залишити цю точку зупину
в рядку 8 з червоною крапкою.

538
00:26:31,340 --> 00:26:32,830
Я збираюся повторно запустити debug50.

539
00:26:32,830 --> 00:26:34,400
Це автоматично призупиняється тут.

540
00:26:34,400 --> 00:26:37,660
Але на цей раз, замість того,
переступаючи через цю лінію,

541
00:26:37,660 --> 00:26:42,290
дозвольте мені насправді йти всередині
get_negative_int і з'ясувати,

542
00:26:42,290 --> 00:26:45,530
чому це прийняття 0 в якості дійсного відповіді?

543
00:26:45,530 --> 00:26:47,990
>> Таким чином, замість того, щоб натиснути Step Over.

544
00:26:47,990 --> 00:26:50,630
Я збираюся йти вперед
і натисніть кнопку Step Into.

545
00:26:50,630 --> 00:26:54,030
І зверніть увагу, що лінія 8 це
тепер виділяється тепер раптом

546
00:26:54,030 --> 00:26:56,900
стає рядок 17.

547
00:26:56,900 --> 00:26:59,947
>> Тепер, це не означає, що відладчик
пропустив лінії 14 і 15, і 16.

548
00:26:59,947 --> 00:27:01,780
Це не просто там нічого
щоб показати вам там.

549
00:27:01,780 --> 00:27:04,050
Ті оголошення змінних,
а потім там слово Do

550
00:27:04,050 --> 00:27:05,390
а потім відкрита фігурна дужка.

551
00:27:05,390 --> 00:27:09,227
Тільки функціональна лінія, це
соковитий дійсно цей тут, 17.

552
00:27:09,227 --> 00:27:11,060
І ось де ми
автоматично призупиняється.

553
00:27:11,060 --> 00:27:13,870
>> Так що Е ( "n.is:");, так
що до сих пір не відбулося.

554
00:27:13,870 --> 00:27:18,250
Так що давайте йти вперед і натисніть кнопку Step Over.

555
00:27:18,250 --> 00:27:20,326
Тепер мій запит, насправді,
змінений ( "п:").

556
00:27:20,326 --> 00:27:22,450
Тепер get_int, я не збираюся
турбувати вступаємо,

557
00:27:22,450 --> 00:27:24,750
тому що функція була
зроблені CS50 в бібліотеці.

558
00:27:24,750 --> 00:27:25,750
Це, ймовірно, правильно.

559
00:27:25,750 --> 00:27:28,440
>> Так що я збираюся йти вперед і
свого роду співпраця, надавши йому

560
00:27:28,440 --> 00:27:30,590
викличте переривання, але не є негативним Int.

561
00:27:30,590 --> 00:27:32,870
Отже, дозвольте мені йти вперед і вдарив 0.

562
00:27:32,870 --> 00:27:39,460
А тепер, що відбувається тут
коли я отримую вниз до лінії 21?

563
00:27:39,460 --> 00:27:40,890
Я не ітерованих знову.

564
00:27:40,890 --> 00:27:43,320
Я, здається, не застрягне в цьому циклі.

565
00:27:43,320 --> 00:27:45,990
Іншими словами, цей жовтий
бар не буде тримати навколо,

566
00:27:45,990 --> 00:27:47,130
і навколо, і навколо нього.

567
00:27:47,130 --> 00:27:48,340
>> Тепер, чому це?

568
00:27:48,340 --> 00:27:49,920
Що ж, п, що дорівнює п прямо зараз?

569
00:27:49,920 --> 00:27:53,280
Я можу дивитися на місцевому
Змінні в отладчике.

570
00:27:53,280 --> 00:27:53,816
п дорівнює 0.

571
00:27:53,816 --> 00:27:55,190
Добре, що це було моє стан?

572
00:27:55,190 --> 00:27:58,700
>> 20-- лінія 20, ну,
0 більше 0.

573
00:27:58,700 --> 00:27:59,500
Це не правда.

574
00:27:59,500 --> 00:28:01,020
0 не більш 0.

575
00:28:01,020 --> 00:28:02,820
І тому я вирвалася з цього.

576
00:28:02,820 --> 00:28:06,370
>> І ось чому на лінії
21, якщо я насправді, як і раніше,

577
00:28:06,370 --> 00:28:10,370
Я збираюся повернути 0, навіть
хоча я повинен був відкинуто 0

578
00:28:10,370 --> 00:28:12,484
а насправді не є негативним.

579
00:28:12,484 --> 00:28:14,650
Так що тепер, я не дуже навіть
піклуватися про відладчика.

580
00:28:14,650 --> 00:28:16,900
Зрозумів, я не потрібно
знаю, що ще відбувається.

581
00:28:16,900 --> 00:28:19,233
>> Так що я збираюся йти вперед і
просто натисніть кнопку відтворення,

582
00:28:19,233 --> 00:28:20,240
і нехай це закінчити.

583
00:28:20,240 --> 00:28:23,440
Тепер я зрозумів, що мій
помилка мабуть, в рядку 20.

584
00:28:23,440 --> 00:28:25,160
Це моя логічна помилка.

585
00:28:25,160 --> 00:28:28,100
>> І ось, що я хочу
потрібно зробити, щоб змінити це?

586
00:28:28,100 --> 00:28:32,500
Якщо проблема полягає в тому, що я не
ловити 0, це просто логічна помилка.

587
00:28:32,500 --> 00:28:35,910
І я можу сказати, в той час як п
більше або дорівнює 0,

588
00:28:35,910 --> 00:28:38,330
тримати знову і знову запитуючи користувача.

589
00:28:38,330 --> 00:28:41,050
>> Так що, знову ж таки, проста помилка, можливо,
навіть очевидно, коли ви бачили мене

590
00:28:41,050 --> 00:28:42,410
написати це лише кілька хвилин тому.

591
00:28:42,410 --> 00:28:44,570
Але тут винос
є те, що при налагодженні 50,

592
00:28:44,570 --> 00:28:46,850
і з налагодженням
програмне забезпечення в більш загальному плані,

593
00:28:46,850 --> 00:28:51,370
у вас є це нове харчування
пройти через свій власний код, дивіться

594
00:28:51,370 --> 00:28:55,590
за допомогою цієї правій панелі, що
змінні значення.

595
00:28:55,590 --> 00:28:57,700
Таким чином, ви не обов'язково
повинні використовувати щось

596
00:28:57,700 --> 00:29:00,630
як ви eprintf друкувати ці значення.

597
00:29:00,630 --> 00:29:04,430
Ви можете побачити їх
візуально на екрані.

598
00:29:04,430 --> 00:29:08,920
>> Тепер, крім цього, варто відзначити,
що є інша техніка, яка

599
00:29:08,920 --> 00:29:09,890
насправді дуже поширеним явищем.

600
00:29:09,890 --> 00:29:13,120
І ви могли б задатися питанням, чому цей маленький
хлопець тут сидів на сцені.

601
00:29:13,120 --> 00:29:16,490
Так що є ця техніка, як правило,
відомий як метод каченяти,

602
00:29:16,490 --> 00:29:18,786
який насправді це просто
свідченням того,

603
00:29:18,786 --> 00:29:20,660
що часто, коли програмісти
написанні коду,

604
00:29:20,660 --> 00:29:22,650
вони не обов'язково
співпрацюючи з іншими,

605
00:29:22,650 --> 00:29:24,030
або працювати в загальному середовищі.

606
00:29:24,030 --> 00:29:25,050
>> Вони начебто вдома.

607
00:29:25,050 --> 00:29:25,910
Може бути, це пізно вночі.

608
00:29:25,910 --> 00:29:28,190
Вони намагаються фігури
деякі помилки в своєму коді.

609
00:29:28,190 --> 00:29:29,330
І вони просто не бачить.

610
00:29:29,330 --> 00:29:30,329
>> І немає ніякого сусіда по кімнаті.

611
00:29:30,329 --> 00:29:31,250
Там немає TF.

612
00:29:31,250 --> 00:29:32,680
Там немає CA навколо.

613
00:29:32,680 --> 00:29:36,440
Всі вони мають на своїй полиці
ця маленька гумова качечка.

614
00:29:36,440 --> 00:29:39,030
>> І тому налагодження гумова качка
просто це запрошення

615
00:29:39,030 --> 00:29:42,780
думати про щось, як нерозумно
так як це як реальна істота,

616
00:29:42,780 --> 00:29:46,940
і насправді пройти через ваш код
в усній формі до цього неживий об'єкт.

617
00:29:46,940 --> 00:29:49,230
Так, наприклад, якщо
це мій приклад here--

618
00:29:49,230 --> 00:29:52,470
і нагадаємо, що раніше
проблема була в цьому,

619
00:29:52,470 --> 00:29:58,140
якщо я видалю цю перший рядок коду,
і я йду вперед і зробити баггі 0 раз,

620
00:29:58,140 --> 00:30:01,220
Нагадаємо, що у мене були ці
Повідомлення про помилки тут.

621
00:30:01,220 --> 00:30:05,997
Так що ідея тут, смішно, хоча я
відчуваю в даний момент робить це публічно,

622
00:30:05,997 --> 00:30:06,580
є те, що помилка.

623
00:30:06,580 --> 00:30:10,910
>> ОК, так що моя проблема в тому, що я
неявно бібліотечну функцію.

624
00:30:10,910 --> 00:30:12,610
І ця функція бібліотеки Printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, оголосити
нагадує мені про прототипи.

626
00:30:15,290 --> 00:30:18,930
>> Це означає, що мені потрібно насправді
повідомити компілятору заздалегідь, що

627
00:30:18,930 --> 00:30:19,980
функція виглядає наступним чином.

628
00:30:19,980 --> 00:30:20,930
Почекай хвилинку.

629
00:30:20,930 --> 00:30:23,580
У мене не було стандартного io.h.

630
00:30:23,580 --> 00:30:24,530
Велике спасибі.

631
00:30:24,530 --> 00:30:27,330
>> Так що цей процес of-- вас
не потрібно насправді є качка.

632
00:30:27,330 --> 00:30:29,819
Але ця ідея ходити
самостійно через свій власний код

633
00:30:29,819 --> 00:30:31,610
так що ви навіть чути
самостійно, так що ви

634
00:30:31,610 --> 00:30:35,620
реалізувати упущення в свій власний
зауваження, як правило, ідея.

635
00:30:35,620 --> 00:30:38,910
>> І, можливо, більш логічно, чи не так
багато з цим один, але більш активну участь

636
00:30:38,910 --> 00:30:44,220
Приклад, який ми тільки що зробили в баггі 3.c,
Ви могли б ходити себе через нього

637
00:30:44,220 --> 00:30:45,310
наступним чином.

638
00:30:45,310 --> 00:30:49,190
Так що все в порядку, гума
душка, DDB, якщо ви будете.

639
00:30:49,190 --> 00:30:52,350
Тут ми маємо в своїй основній функції,
Я дзвоню отримати негативний результат Int.

640
00:30:52,350 --> 00:30:54,660
>> І я отримую повертається значення.

641
00:30:54,660 --> 00:31:00,410
Я зберігати його на лівій стороні
в рядку 8 в змінної називається I.

642
00:31:00,410 --> 00:31:02,380
Добре, але чекати, як зробив
що отримати це значення?

643
00:31:02,380 --> 00:31:04,130
Дозвольте мені поглянути на функції в рядку 12.

644
00:31:04,130 --> 00:31:05,760
>> У рядку 12 ми маємо отримати негативну Int.

645
00:31:05,760 --> 00:31:08,190
Не приймати будь-які матеріали,
це повертає Int, OK.

646
00:31:08,190 --> 00:31:10,929
Я заявляю, в рядку 14 змінна п.

647
00:31:10,929 --> 00:31:12,220
Це буде зберігати ціле число.

648
00:31:12,220 --> 00:31:13,760
Це те, що я хочу.

649
00:31:13,760 --> 00:31:18,480
>> Так зробіть наступне: Коли п is-- нехай
мені скасувати те, що виправлення я вже зробив.

650
00:31:18,480 --> 00:31:22,710
Таким чином, в той час як п більше
0, роздрукувати п, OK.

651
00:31:22,710 --> 00:31:25,170
А потім викличте отримати INT зберігається в п.

652
00:31:25,170 --> 00:31:30,160
А потім перевірте, якщо п = 0,
п не-- там.

653
00:31:30,160 --> 00:31:31,910
Так що, знову ж таки, ви цього не зробите
потрібен фактичний качка.

654
00:31:31,910 --> 00:31:35,650
Але просто ходити самостійно через
ваш код як інтелектуальна вправа

655
00:31:35,650 --> 00:31:37,720
часто допоможе вам
усвідомити, що відбувається,

656
00:31:37,720 --> 00:31:41,170
а не просто робити щось
як це, дивлячись на екран,

657
00:31:41,170 --> 00:31:43,720
і не говорити себе через
то, що це не чесно

658
00:31:43,720 --> 00:31:46,270
майже як ефективний метод.

659
00:31:46,270 --> 00:31:48,620
Так що у вас є, A
кількість різних методів

660
00:31:48,620 --> 00:31:52,102
для фактично налагодження коду
і чіплятися, все з яких

661
00:31:52,102 --> 00:31:54,810
повинні бути інструменти в ваш інструментарій
так що ви не пізно вночі,

662
00:31:54,810 --> 00:31:57,660
особливо, ви в їдальні
зали, або в неробочий час,

663
00:31:57,660 --> 00:32:00,368
б'єшся головою проти
стіни, намагаючись вирішити деякі проблеми.

664
00:32:00,368 --> 00:32:02,020
Розуміють, що є програмні засоби.

665
00:32:02,020 --> 00:32:03,720
Є гумова качка інструменти.

666
00:32:03,720 --> 00:32:09,630
І є цілий штат
підтримки чекають, щоб протягнути руку допомоги.

667
00:32:09,630 --> 00:32:13,120
>> Так що тепер, слово з проблеми
набори, а також на те, що ми сподіваємося, що вам

668
00:32:13,120 --> 00:32:15,620
вийти з них, і як
ми йдемо про оцінку.

669
00:32:15,620 --> 00:32:17,680
За навчальний план Курсу,
CS50 безлічі проблем в

670
00:32:17,680 --> 00:32:22,320
оцінюються за чотирма основними осях, так
щоб speak-- сферу, коректність, дизайн,

671
00:32:22,320 --> 00:32:23,060
і стиль.

672
00:32:23,060 --> 00:32:25,910
І сфера просто ставиться до того, скільки
шматка ви відкусили?

673
00:32:25,910 --> 00:32:28,080
Скільки проблеми ви пробували?

674
00:32:28,080 --> 00:32:30,110
Який рівень зусиль
Ви були?

675
00:32:30,110 --> 00:32:35,750
>> Коректність, працює програма, як
він повинен згідно специфікації CS50

676
00:32:35,750 --> 00:32:38,640
коли ви надаєте певні входи
або певні виходи повертаються?

677
00:32:38,640 --> 00:32:41,130
Дизайн є найбільш суб'єктивним з них.

678
00:32:41,130 --> 00:32:43,360
І це той, який буде
взяти найдовший, щоб дізнатися,

679
00:32:43,360 --> 00:32:47,220
і найдовший, щоб викладати в
до сих пір, як це зводиться до того,

680
00:32:47,220 --> 00:32:49,530
як добре написано ваш код?

681
00:32:49,530 --> 00:32:52,920
>> Це одна річ, щоб просто надрукувати правильний
виходи або повертати правильні значення.

682
00:32:52,920 --> 00:32:55,400
Але ви робите це як
ефективно, наскільки це можливо?

683
00:32:55,400 --> 00:32:58,210
Ви робите це розрив
і володарюй, або двійковий

684
00:32:58,210 --> 00:33:01,500
Пошук, як ми скоро побачимо, що ми зробили
два тижні тому з телефонною книгою?

685
00:33:01,500 --> 00:33:04,670
Чи існують більш ефективні способи вирішення
проблема, ніж зараз у вас тут?

686
00:33:04,670 --> 00:33:06,380
Це можливість для кращого дизайну.

687
00:33:06,380 --> 00:33:08,530
>> А потім, як style--
досить ваш код?

688
00:33:08,530 --> 00:33:12,370
Ви помітите, що я досить
Зокрема про відступів мій код,

689
00:33:12,370 --> 00:33:15,300
і переконавшись, що мої змінні
обґрунтовано названі. п,

690
00:33:15,300 --> 00:33:19,660
в той час як короткі, добре ім'я для
номер, я для підрахунку числа,

691
00:33:19,660 --> 00:33:20,727
s для рядка.

692
00:33:20,727 --> 00:33:22,560
І ми можемо мати більше
імена змінних стилю.

693
00:33:22,560 --> 00:33:25,500
Стиль, наскільки добре
виглядає ваш код?

694
00:33:25,500 --> 00:33:26,600
А як читається це?

695
00:33:26,600 --> 00:33:29,650
>> І з плином часу, ніж ваші TAs
і ТФ буде робити в процесі

696
00:33:29,650 --> 00:33:31,870
це надати вам, що
вид якісної зворотного зв'язку

697
00:33:31,870 --> 00:33:34,330
так що ви отримаєте краще
в цих різних аспектах.

698
00:33:34,330 --> 00:33:37,510
І з точки зору того, як ми
оцінити кожну з цих осей,

699
00:33:37,510 --> 00:33:40,080
це, як правило, з дуже небагатьма
відра, так що ви, як правило,

700
00:33:40,080 --> 00:33:41,680
отримати уявлення про те, наскільки добре ви робите.

701
00:33:41,680 --> 00:33:45,680
І дійсно, якщо ви отримаєте рахунок на
будь-який з цих axes-- правильність, дизайн

702
00:33:45,680 --> 00:33:49,659
і стиль especially--, що число
як правило, становить від 1 до 5 балів.

703
00:33:49,659 --> 00:33:52,450
І, в буквальному сенсі, якщо ви отримуєте
3-х на початку семестру,

704
00:33:52,450 --> 00:33:53,977
це дуже хороша річ.

705
00:33:53,977 --> 00:33:55,810
Це означає, що є ще
можливості для поліпшення,

706
00:33:55,810 --> 00:33:58,490
який ви б сподіватися в
приймаючи клас в перший раз.

707
00:33:58,490 --> 00:34:01,820
Там в якийсь, сподіваюся, трохи стелі
до якого ви прагнуть до досягнення.

708
00:34:01,820 --> 00:34:03,970
І тому отримання 3 по
найраніші п'єси,

709
00:34:03,970 --> 00:34:06,550
якщо не якийсь 2-х і 4-х,
це, дійсно, дуже хороша річ.

710
00:34:06,550 --> 00:34:08,880
Це добре в межах діапазону,
добре в межах очікувань.

711
00:34:08,880 --> 00:34:11,421
>> І якщо ваш розум мчить, зачекайте
хвилину, три з п'яти.

712
00:34:11,421 --> 00:34:12,620
Це дійсно 6 з 10.

713
00:34:12,620 --> 00:34:13,560
Це 60%.

714
00:34:13,560 --> 00:34:14,830
Боже мій, це на букву F.

715
00:34:14,830 --> 00:34:15,870
>> Це не.

716
00:34:15,870 --> 00:34:17,600
Це не так, насправді, це.

717
00:34:17,600 --> 00:34:22,710
Швидше за все, це можливість поліпшити
протягом семестру.

718
00:34:22,710 --> 00:34:25,580
І якщо ви отримуєте деякі
Poors, це можливість

719
00:34:25,580 --> 00:34:29,199
щоб скористатися офісними годинами,
звичайно ж розділи та інші ресурси.

720
00:34:29,199 --> 00:34:32,840
>> Краще це можливість, насправді,
можна пишатися, наскільки далеко ви

721
00:34:32,840 --> 00:34:34,520
приходять протягом семестру.

722
00:34:34,520 --> 00:34:38,199
Так само розумієш, якщо нічого
ще три добре.

723
00:34:38,199 --> 00:34:40,179
І це дозволяє для зростання з плином часу.

724
00:34:40,179 --> 00:34:43,090
>> Що стосується того, як ці осі
зважене, реально ви

725
00:34:43,090 --> 00:34:46,745
збирається витратити більшу частину свого часу отримання
речі, щоб працювати, не кажучи вже правильно.

726
00:34:46,745 --> 00:34:49,120
І тому, як правило, коректність
зважуватися найбільше, як і з

727
00:34:49,120 --> 00:34:51,360
цей мультиплікативний фактор трьох.

728
00:34:51,360 --> 00:34:54,659
Дизайн також має важливе значення, але
то, що ви не обов'язково

729
00:34:54,659 --> 00:34:58,220
витрачати все ті години, на
намагаючись отримати речі просто працювати.

730
00:34:58,220 --> 00:35:00,019
>> І таким чином це зважений
трохи більше злегка.

731
00:35:00,019 --> 00:35:01,560
А потім стиль зважується щонайменше.

732
00:35:01,560 --> 00:35:03,710
Незважаючи на те, що це не менш
важливо фундаментально,

733
00:35:03,710 --> 00:35:05,990
це просто, може бути,
Найпростіше зробити правильно,

734
00:35:05,990 --> 00:35:08,440
імітуючи приклади, які ми
робити в лекції та секції,

735
00:35:08,440 --> 00:35:11,080
з речами красиво
відступом, і прокоментував,

736
00:35:11,080 --> 00:35:14,320
і так далі є одним з найпростіших
речі, щоб зробити і отримати право.

737
00:35:14,320 --> 00:35:16,960
Так як такі, реалізувати
що ті точки

738
00:35:16,960 --> 00:35:19,000
що відносно легко зрозуміти.

739
00:35:19,000 --> 00:35:22,360
>> А тепер слово на
this-- академічної чесності.

740
00:35:22,360 --> 00:35:25,150
Таким чином, за Курсу
навчальний план, ви побачите

741
00:35:25,150 --> 00:35:27,630
що курс має досить
трохи мови навколо цього.

742
00:35:27,630 --> 00:35:31,380
І звичайно ж бере питання
академічна чесність цілком серйозно.

743
00:35:31,380 --> 00:35:33,450
>> У нас є деякі розбіжності,
на краще чи на гірше,

744
00:35:33,450 --> 00:35:36,570
з надіславши щороку більше
студентів для прийняття дисциплінарних заходів

745
00:35:36,570 --> 00:35:39,670
ніж більшість будь-який інший
Звичайно ж, що я знаю.

746
00:35:39,670 --> 00:35:42,580
Це не обов'язково
свідчить про те,

747
00:35:42,580 --> 00:35:46,340
що студенти CS або CS50 студентів, є
Проте чесніше своїх однокласників.

748
00:35:46,340 --> 00:35:49,090
Але реальність, що в цьому
світ, в електронному вигляді, ми просто

749
00:35:49,090 --> 00:35:50,990
є технологічна
засіб виявлення цього.

750
00:35:50,990 --> 00:35:53,360
>> Це дуже важливо для нас для
справедливість по класу

751
00:35:53,360 --> 00:35:58,550
що ми робимо це виявити і підняти
питання, коли ми бачимо речі.

752
00:35:58,550 --> 00:36:01,980
І як раз, щоб намалювати картину, а насправді
щоб допомогти щось на зразок цього в раковині,

753
00:36:01,980 --> 00:36:04,600
це число
Студенти протягом останніх 10 років

754
00:36:04,600 --> 00:36:07,610
які були залучені до деяких
такі питання академічної чесності,

755
00:36:07,610 --> 00:36:10,990
з деякими 32 студентів
з осені 2015 року, яка

756
00:36:10,990 --> 00:36:13,760
повинен сказати, що ми приймаємо
справа дуже серйозно.

757
00:36:13,760 --> 00:36:18,380
І, в кінцевому рахунку, ці цифри становлять,
Зовсім недавно, близько 3%, 4% або близько того

758
00:36:18,380 --> 00:36:19,120
класу.

759
00:36:19,120 --> 00:36:25,220
>> Так що для супер більшості студентів
здається, що лінії чіткі.

760
00:36:25,220 --> 00:36:27,940
Але майте це на
розум, особливо пізно

761
00:36:27,940 --> 00:36:32,080
в нічний час, коли бореться з
якесь рішення для безлічі проблем,

762
00:36:32,080 --> 00:36:34,830
що існують механізми
для отримання себе краще

763
00:36:34,830 --> 00:36:37,870
підтримка, ніж ви могли б
думаю, навіть в той час.

764
00:36:37,870 --> 00:36:40,514
Розуміють, що, коли ми отримуємо
студентські уявлення, ми перетинаємо

765
00:36:40,514 --> 00:36:43,430
порівняти всі уявлення в цьому році
проти кожного уявлення в минулому році,

766
00:36:43,430 --> 00:36:47,590
проти кожного уявлення з 2007 року,
і так як, дивлячись на, а також,

767
00:36:47,590 --> 00:36:49,931
код репозиторіїв онлайн,
дискусійних форумах, робота сайтів.

768
00:36:49,931 --> 00:36:51,806
І ми відзначимо це,
насправді, все заради

769
00:36:51,806 --> 00:36:56,040
повного розкриття, що якщо
хтось може знайти його в Інтернеті,

770
00:36:56,040 --> 00:36:57,880
звичайно ж, так що ми можемо курс.

771
00:36:57,880 --> 00:37:00,100
Але, насправді, дух
з курсу зводиться

772
00:37:00,100 --> 00:37:01,650
до цієї статті в навчальній програмі.

773
00:37:01,650 --> 00:37:03,670
Це дійсно просто, розумно.

774
00:37:03,670 --> 00:37:06,680
>> І якщо ми повинні були зупинитися на цьому
з тільки трохи більше мови,

775
00:37:06,680 --> 00:37:09,770
усвідомити, що суть всіх
Робота, яку ви уявити цей курс

776
00:37:09,770 --> 00:37:10,954
повинен бути свій власний.

777
00:37:10,954 --> 00:37:13,870
Але в тому, що є, звичайно,
можливостей і заохочення,

778
00:37:13,870 --> 00:37:17,300
і педагогічна цінність в перетворенні в
others-- себе, ССТ, КАС,

779
00:37:17,300 --> 00:37:20,760
Тас і інші в класі,
для підтримки, не кажучи вже про друзів

780
00:37:20,760 --> 00:37:23,547
і сусіди по кімнаті, хто вивчав
CS і програмування раніше.

781
00:37:23,547 --> 00:37:25,130
І тому є посібник для цього.

782
00:37:25,130 --> 00:37:28,180
А загальне правило
є this--, коли просять про допомогу,

783
00:37:28,180 --> 00:37:31,470
Ви можете показати свій код іншим,
але ви не можете переглядати їх.

784
00:37:31,470 --> 00:37:34,880
Так що навіть якщо ви в робочий час,
або в залі D, або де-небудь ще

785
00:37:34,880 --> 00:37:37,450
працює над якийсь шматок набору,
працюючи разом з другом, який

786
00:37:37,450 --> 00:37:40,160
це абсолютно нормально, на
Кінець дня вашої роботи

787
00:37:40,160 --> 00:37:43,034
в кінцевому підсумку повинно належати кожному
з вас, відповідно, і не

788
00:37:43,034 --> 00:37:45,700
бути деякі спільні зусилля,
для остаточного проекту, де крім

789
00:37:45,700 --> 00:37:47,410
це дозволяється і заохочується.

790
00:37:47,410 --> 00:37:49,830
>> Зрозумійте, що якщо ви
бореться з чимось

791
00:37:49,830 --> 00:37:52,520
і ваш друг тільки що відбувається
щоб бути краще в цьому, то ви,

792
00:37:52,520 --> 00:37:55,130
або краще на цю проблему, ніж ви,
або трохи далі вперед, ніж ви,

793
00:37:55,130 --> 00:37:57,330
це абсолютно розумно, щоб перетворити
своєму другові і сказати, агов,

794
00:37:57,330 --> 00:38:00,480
Ви не заперечуєте, дивлячись на мій код тут,
щоб допомогти мені визначити, що моє запитання?

795
00:38:00,480 --> 00:38:03,760
І, сподіваюся, в
Інтерес педагогічної цінності

796
00:38:03,760 --> 00:38:07,040
що друг не просто
кажуть, ах, зробити це, але, скоріше,

797
00:38:07,040 --> 00:38:09,917
то, що ви пропали без вісті на лінії
6, або щось подібне?

798
00:38:09,917 --> 00:38:12,000
Але це рішення не
для одного поруч з вами

799
00:38:12,000 --> 00:38:15,617
сказати, ой, ну, ось, дозвольте мені тягнути
це, і показати моє рішення для вас.

800
00:38:15,617 --> 00:38:16,450
Так що це лінія.

801
00:38:16,450 --> 00:38:18,670
Ви показуєте свій код в
інші, але ви не можете

802
00:38:18,670 --> 00:38:22,350
подивитися у них, відповідно до інших
обмеження в навчальний план Курсу.

803
00:38:22,350 --> 00:38:24,760
>> Так що майте на увазі, що це
так званий пункт жалю

804
00:38:24,760 --> 00:38:27,560
в ході навчального плану, а також,
що якщо ви зробите якийсь акт,

805
00:38:27,560 --> 00:38:30,476
не є розумним, але довести його до
увагу керівників Курсу

806
00:38:30,476 --> 00:38:34,240
протягом 72 годин, курс
може накладати санкції, місцеві

807
00:38:34,240 --> 00:38:37,380
може включати в себе незадовільним або
провальну оцінку для роботи, представлені.

808
00:38:37,380 --> 00:38:41,410
Але, звичайно, не передасть
важливо для подальшого прийняття дисциплінарних заходів,

809
00:38:41,410 --> 00:38:43,010
за винятком випадків повторних актів.

810
00:38:43,010 --> 00:38:46,632
Іншими словами, якщо ви робите деякі
нерозумно, особливо пізно ввечері, рішення

811
00:38:46,632 --> 00:38:49,340
що на наступний ранок або через два дні
пізніше, ви прокинутися і усвідомити,

812
00:38:49,340 --> 00:38:50,870
про що я думав?

813
00:38:50,870 --> 00:38:53,890
Ви робите в CS50 мають вихід
для фіксації цієї проблеми

814
00:38:53,890 --> 00:38:57,170
і володіти до нього, так що ми
зустріне вас на півдорозі і справа

815
00:38:57,170 --> 00:39:01,500
з ним в питанні, який є одночасно
освітніх і цінних для вас,

816
00:39:01,500 --> 00:39:04,200
але до сих пір каральний в деякому роді.

817
00:39:04,200 --> 00:39:08,590
І тепер, щоб заморити, це.

818
00:39:08,590 --> 00:39:10,570
>> [Відеовідтворення]

819
00:39:10,570 --> 00:39:13,540
>> [МУЗИКА]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [КІНЕЦЬ ВОСП]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Малан: Добре, ми повернулися.

823
00:40:00,490 --> 00:40:03,680
А тепер ми подивимося на один з
перший з наших реальних доменів

824
00:40:03,680 --> 00:40:08,720
в CS50, мистецтво криптографії,
Мистецтво відправки та отримання

825
00:40:08,720 --> 00:40:11,840
секретні повідомлення, зашифрованого
повідомлення, якщо ви будете,

826
00:40:11,840 --> 00:40:17,060
які можуть бути розшифровані тільки якщо у вас є
деякі з ключових елементів, що відправник

827
00:40:17,060 --> 00:40:18,030
так само.

828
00:40:18,030 --> 00:40:22,120
Таким чином, щоб мотивувати цього ми візьмемо
Подивіться на цю річ тут,

829
00:40:22,120 --> 00:40:26,750
яка є Прімердлітельногопребиванія
секрет декодер кільце,

830
00:40:26,750 --> 00:40:34,042
може бути використаний для того, щоб з'ясувати,
то, що секретне повідомлення насправді.

831
00:40:34,042 --> 00:40:35,750
Насправді, ще в
день в початковій школі,

832
00:40:35,750 --> 00:40:38,787
якщо ви коли-небудь послав секретні повідомлення
деякі один або деякі тиснява в класі,

833
00:40:38,787 --> 00:40:40,620
Ви могли б подумати,
ви були розумними

834
00:40:40,620 --> 00:40:46,530
шляхом на вашій частині заміни паперу,
як, А до В, і В до С, В і С до D,

835
00:40:46,530 --> 00:40:47,590
і так далі.

836
00:40:47,590 --> 00:40:50,300
Але ви були насправді шифрування
Ваша інформація, навіть

837
00:40:50,300 --> 00:40:53,300
якщо це було трохи тривіально, не було
що важко для вчителя, щоб зрозуміти,

838
00:40:53,300 --> 00:40:55,675
добре, якщо ви просто змінити
В до А і С до В,

839
00:40:55,675 --> 00:40:57,550
ви насправді з'ясувати,
що було повідомлення,

840
00:40:57,550 --> 00:40:59,700
але ви були в шифруванні інформації.

841
00:40:59,700 --> 00:41:03,420
>> Ви просто робили це
просто, так само, як Ральф тут

842
00:41:03,420 --> 00:41:07,934
у відомому фільмі, який грає
досить багато оголошень щозими до нудоти.

843
00:41:07,934 --> 00:41:08,600
[Відеовідтворення]

844
00:41:08,600 --> 00:41:11,180
-Будьте Це всім відомо, що
Ральф Паркер Справжнім

845
00:41:11,180 --> 00:41:14,070
призначений членом Малої
Сирітка Енні Secret Circle

846
00:41:14,070 --> 00:41:17,700
і має право на всі почесті
і вигоди відбувається з ним.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Сирітка Енні,
зустрічне підписав П'єр Андре, в чорнилі.

848
00:41:24,340 --> 00:41:27,160
Почесті і вигоди,
вже у віці дев'яти років.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Кричачи]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Давай.

853
00:41:34,250 --> 00:41:35,210
Давайте покінчимо з цим.

854
00:41:35,210 --> 00:41:39,530
Мені не потрібно все, що джаз
про контрабандистів і піратів.

855
00:41:39,530 --> 00:41:41,660
>> Слухай Завтра ніч
завершальним пригоди

856
00:41:41,660 --> 00:41:43,880
чорного піратського корабля.

857
00:41:43,880 --> 00:41:46,650
Тепер прийшов час для
секретне повідомлення Енні

858
00:41:46,650 --> 00:41:49,840
для вас члени таємного гуртка.

859
00:41:49,840 --> 00:41:53,570
Пам'ятайте, діти, тільки члени
Енні Секретної Circle

860
00:41:53,570 --> 00:41:56,140
може розшифрувати секретне повідомлення Енні.

861
00:41:56,140 --> 00:42:00,340
>> Пам'ятайте, що Енні залежить від вас.

862
00:42:00,340 --> 00:42:02,880
Встановіть штифти B2.

863
00:42:02,880 --> 00:42:05,230
Ось повідомлення.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Я Перебуваю в, свою першу таємну зустріч.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Був гучний голос сьогодні.

868
00:42:15,780 --> 00:42:19,000
Я міг би сказати, що сьогодні ввечері
повідомлення було дійсно важливо.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, це повідомлення
від самої Енні.

870
00:42:22,694 --> 00:42:23,860
Пам'ятайте, що не говори нікому.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Секунд по тому, я перебуваю в єдиній
кімната в будинку, де дев'ятирічний хлопчик

873
00:42:32,930 --> 00:42:37,040
міг сидіти на самоті і декодуванням.

874
00:42:37,040 --> 00:42:39,730
Ага, B!

875
00:42:39,730 --> 00:42:42,360
Я пішов до наступного, Е.

876
00:42:42,360 --> 00:42:44,520
>> Перше слово буде.

877
00:42:44,520 --> 00:42:49,032
S, він йшов легше зараз, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -О, Давай, Ральф, я повинен йти!

879
00:42:51,733 --> 00:42:53,688
>> -Я Зараз спущуся, Ма!

880
00:42:53,688 --> 00:42:54,188
Ну і справи свисту!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -Т, O, обов'язково переконайтеся, що, метою яких до чого?

883
00:43:04,060 --> 00:43:05,970
що сирітка
Енні намагається сказати?

884
00:43:05,970 --> 00:43:07,264
Переконайтеся, що до чого?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Енді потрапив
йти, то, будь ласка, вийти?

886
00:43:09,634 --> 00:43:10,480
>> -Добре, Мама!

887
00:43:10,480 --> 00:43:12,880
Я буду прямо!

888
00:43:12,880 --> 00:43:14,550
>> -Я Ставав ближче.

889
00:43:14,550 --> 00:43:16,620
Напруга була жахливо.

890
00:43:16,620 --> 00:43:17,720
Що це було?

891
00:43:17,720 --> 00:43:20,170
доля планети
може висіти на волосині.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Енді повинен йти!

894
00:43:23,170 --> 00:43:26,890
>> -Я Зараз вийду, для волають голосно!

895
00:43:26,890 --> 00:43:32,680
>> -майже Там, мої пальці літали, мій розум
була сталева пастка, кожна пора вібрувати.

896
00:43:32,680 --> 00:43:37,198
Це було майже ясно, так, так, так.

897
00:43:37,198 --> 00:43:43,091
>> -Будьте Обов'язково пити Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Вошивого комерційний?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Сучий син.

903
00:43:54,227 --> 00:43:54,810
[КІНЕЦЬ ВОСП]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Малан: ОК, так що
це був дуже довгий шлях

905
00:43:57,390 --> 00:44:00,660
введення криптографію,
а також Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Насправді, від цього старого оголошень
тут, чому Ovaltine так добре?

907
00:44:04,470 --> 00:44:09,470
Це концентроване витяг стиглі
ячмінний солод, чисте вершкове з коров'ячого молока,

908
00:44:09,470 --> 00:44:14,360
і спеціально підготовлені какао разом
з природними фосфатидів і вітамінів.

909
00:44:14,360 --> 00:44:18,240
далі збагачені
додаткові вітаміни групи В і D, ням.

910
00:44:18,240 --> 00:44:21,600
І ви все ще можете отримати його, мабуть,
на Амазонці, як ми робили тут.

911
00:44:21,600 --> 00:44:24,810
>> Але мотивація тут була
ввести криптографію, зокрема,

912
00:44:24,810 --> 00:44:28,340
тип криптографії відомий
в якості секретного ключа шифрування.

913
00:44:28,340 --> 00:44:34,284
І, як випливає з назви, весь
безпеку секретного ключа системи криптографічного,

914
00:44:34,284 --> 00:44:36,200
якщо ви будете, методологія
для скремблювання просто

915
00:44:36,200 --> 00:44:40,960
інформація між двома людьми, в тому, що
тільки відправник і одержувач тільки

916
00:44:40,960 --> 00:44:46,980
знати секрет key-- якусь цінність, деякі
умовну фразу, якийсь секрет число, що

917
00:44:46,980 --> 00:44:50,660
дозволяє їм як зашифрувати
і розшифрувати інформацію.

918
00:44:50,660 --> 00:44:53,470
І криптографія, насправді,
якраз це від тижня 0.

919
00:44:53,470 --> 00:44:56,715
>> Це проблема, де є входи,
як реальне повідомлення англійською мовою

920
00:44:56,715 --> 00:44:59,340
або будь-який інший мову, який ви
хочете послати кому-то в класі,

921
00:44:59,340 --> 00:45:00,580
або через Інтернет.

922
00:45:00,580 --> 00:45:03,840
Існує певний вихід, який збирається
щоб бути ськремблірованний повідомлення, що ви

923
00:45:03,840 --> 00:45:05,250
хоче одержувач отримати.

924
00:45:05,250 --> 00:45:07,405
І навіть якщо хтось в
середній отримує його теж,

925
00:45:07,405 --> 00:45:09,780
ви не хочете, щоб вони
обов'язково бути в змозі розшифрувати його,

926
00:45:09,780 --> 00:45:12,840
тому що всередині цього
чорний ящик, або алгоритм,

927
00:45:12,840 --> 00:45:17,650
це якийсь механізм, деякі крок за кроком
інструкції, для прийняття цього входу

928
00:45:17,650 --> 00:45:20,710
і перетворення його в
вихід, в сподіваюся безпечним способом.

929
00:45:20,710 --> 00:45:23,640
>> І справді, є деякі
словниковий запас в цьому світі в такий спосіб.

930
00:45:23,640 --> 00:45:26,100
Звичайний текст є слово а
вчений буде

931
00:45:26,100 --> 00:45:28,449
використовувати для опису вхідних
повідомлення, як англійською

932
00:45:28,449 --> 00:45:31,240
або будь-який інший мову ви насправді
хочете відправити в якийсь інший чоловік.

933
00:45:31,240 --> 00:45:35,450
І тоді шифротекст є звалище
до шифрованих або зашифровані,

934
00:45:35,450 --> 00:45:36,520
його версія.

935
00:45:36,520 --> 00:45:38,750
>> Але є ще один інгредієнт тут.

936
00:45:38,750 --> 00:45:43,200
Там один інший вхід
Секретний ключ шифрування.

937
00:45:43,200 --> 00:45:45,200
І це сам ключ,
який, як правило,

938
00:45:45,200 --> 00:45:48,930
як ми побачимо, число або
буква або слово, незалежно від

939
00:45:48,930 --> 00:45:51,980
алгоритм це насправді очікує.

940
00:45:51,980 --> 00:45:53,870
>> І як ви розшифрувати інформацію?

941
00:45:53,870 --> 00:45:55,110
Як ви розшифровувати його?

942
00:45:55,110 --> 00:45:57,950
Ну, ви просто повернути назад
виходи і входи.

943
00:45:57,950 --> 00:46:00,900
>> Іншими словами, як тільки хтось
отримує ваше зашифроване повідомлення,

944
00:46:00,900 --> 00:46:03,740
він або вона просто має
щоб знати, що той же ключ.

945
00:46:03,740 --> 00:46:05,700
Вони отримали шифротекста.

946
00:46:05,700 --> 00:46:09,530
А підключивши ці два
входи в систему криптографічного,

947
00:46:09,530 --> 00:46:14,260
алгоритм, це чорний ящик, з
повинен прийти вихідний відкритий текст.

948
00:46:14,260 --> 00:46:17,830
І так що це дуже високий рівень
вид, що насправді криптографія

949
00:46:17,830 --> 00:46:18,590
все про.

950
00:46:18,590 --> 00:46:20,030
>> Так що давайте там.

951
00:46:20,030 --> 00:46:22,700
Давайте тепер подивимося під
капот чогось

952
00:46:22,700 --> 00:46:26,000
ми брали як само собою зрозуміле для
минулого тижня, і на цій сесії

953
00:46:26,000 --> 00:46:27,629
here-- рядок.

954
00:46:27,629 --> 00:46:30,295
Рядок в кінці дня
це просто послідовність символів.

955
00:46:30,295 --> 00:46:33,610
>> Це може бути привіт світ, або
привіт Zamyla, або будь-який інший.

956
00:46:33,610 --> 00:46:37,050
Але що це означає, що
послідовність символів?

957
00:46:37,050 --> 00:46:41,520
Насправді, бібліотека CS50 дає
нам тип даних називається рядком.

958
00:46:41,520 --> 00:46:45,140
>> Але є насправді немає
така річ як рядок в C.

959
00:46:45,140 --> 00:46:49,450
Це дійсно просто послідовність
характер, темперамент, характер,

960
00:46:49,450 --> 00:46:52,180
характер, спина, до спини, щоб
тому, до спини, щоб всередину

961
00:46:52,180 --> 00:46:54,650
пам'яті комп'ютера або ОЗУ.

962
00:46:54,650 --> 00:46:58,940
І ми будемо дивитися глибше, що в
майбутнє, коли ми дивимося на саму згадку,

963
00:46:58,940 --> 00:47:02,030
і використання, і
загрози, які беруть участь.

964
00:47:02,030 --> 00:47:04,100
>> Але давайте розглянемо рядок Zamyla.

965
00:47:04,100 --> 00:47:07,480
Так що назва
людина тут, Zamyla,

966
00:47:07,480 --> 00:47:12,030
тобто послідовність
символи, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
А тепер давайте припустимо, що ім'я Zamyla в
Під час збереження всередині комп'ютера

968
00:47:16,020 --> 00:47:16,880
Програма.

969
00:47:16,880 --> 00:47:20,830
>> Ну, само собою зрозуміло, що ми повинні
бути в змозі дивитися на цих персонажів

970
00:47:20,830 --> 00:47:21,590
в індивідуальному порядку.

971
00:47:21,590 --> 00:47:24,710
Так що я просто хочу, щоб намалювати трохи
рамку навколо імені Zamyla тут.

972
00:47:24,710 --> 00:47:31,580
І це відбувається в C, що, коли ви
є рядок, як Zamyla-- і, можливо,

973
00:47:31,580 --> 00:47:34,940
цей рядок повернулася з
функція як отримання рядки,

974
00:47:34,940 --> 00:47:38,540
ви можете маніпулювати
це символ за символом.

975
00:47:38,540 --> 00:47:42,070
>> Тепер, це релевантно для
Розмова під рукою, тому що

976
00:47:42,070 --> 00:47:46,420
в криптографії, якщо ви хочете змінити
А в В, і В до С, В і С до D,

977
00:47:46,420 --> 00:47:49,650
і так далі, ви повинні бути в змозі
дивитися на окремі символи

978
00:47:49,650 --> 00:47:50,190
в рядку.

979
00:47:50,190 --> 00:47:52,695
Ви повинні бути в змозі змінити
Зет до чогось ще, А

980
00:47:52,695 --> 00:47:55,280
до чогось ще, щоб М
щось ще, і так далі.

981
00:47:55,280 --> 00:47:58,000
І тому нам потрібен спосіб,
програмним способом, так

982
00:47:58,000 --> 00:48:03,020
говорити, в C, щоб мати можливість змінити
і подивитися на окремі літери.

983
00:48:03,020 --> 00:48:05,690
І ми можемо зробити це в такий спосіб.

984
00:48:05,690 --> 00:48:08,340
>> Пусти голову назад в CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
І дозвольте мені йти вперед
і створити новий файл

986
00:48:11,130 --> 00:48:16,134
що я буду називати цей раз string0,
як наш перший такий приклад, точка с.

987
00:48:16,134 --> 00:48:18,300
І я збираюся йти вперед
і збити його наступним чином.

988
00:48:18,300 --> 00:48:22,870
>> Так включають CS50.h, і
потім включають в себе стандартні io.h,

989
00:48:22,870 --> 00:48:25,990
який я майже завжди буде
використовувати в своїх програмах, по крайней мере,

990
00:48:25,990 --> 00:48:26,780
на початковому етапі.

991
00:48:26,780 --> 00:48:32,180
INT головну порожнечу, а потім тут я
збирається робити рядки отримує отримати рядок.

992
00:48:32,180 --> 00:48:35,260
А потім я збираюся
йти вперед і робити це.

993
00:48:35,260 --> 00:48:37,460
Я хочу, щоб йти вперед
і, як перевірки осудності,

994
00:48:37,460 --> 00:48:43,607
просто сказати, привіт, відсотків s,
коми, робить рядок 0.

995
00:48:43,607 --> 00:48:44,690
Ой, що ж я зробив тут?

996
00:48:44,690 --> 00:48:45,930
О, я не підключити його.

997
00:48:45,930 --> 00:48:48,120
Так урок, що
ні навмисним.

998
00:48:48,120 --> 00:48:52,480
>> Так помилка, більше відсотків
перетворення, ніж аргументи даних.

999
00:48:52,480 --> 00:48:54,940
І тут, в
лінія 7-- ОК, так що у мене є,

1000
00:48:54,940 --> 00:48:56,690
цитата Unquote, це
моя рядок PRINTF.

1001
00:48:56,690 --> 00:48:58,151
У мене є знак відсотка.

1002
00:48:58,151 --> 00:48:59,650
Але я пропускаю другий аргумент.

1003
00:48:59,650 --> 00:49:03,190
>> Я пропускаю коми с, що
Я маю на попередніх прикладах.

1004
00:49:03,190 --> 00:49:06,650
Так хороша можливість виправити
ще одна помилка, випадково.

1005
00:49:06,650 --> 00:49:09,950
А тепер дозвольте мені бігти
string0, тип в Zamyla.

1006
00:49:09,950 --> 00:49:10,970
Добре, привіт Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Таким чином, ми запускаємо цей вид програми
кілька різних раз зараз.

1008
00:49:14,144 --> 00:49:16,310
Але давайте робити щось
трохи по-іншому в цей раз.

1009
00:49:16,310 --> 00:49:19,450
Замість того щоб просто друк Zamyla-х
повна назва з Printf,

1010
00:49:19,450 --> 00:49:21,350
давайте зробимо це символ за символом.

1011
00:49:21,350 --> 00:49:22,700
>> Я збираюся використовувати для циклу.

1012
00:49:22,700 --> 00:49:26,160
І я збираюся віддати себе
змінна підрахунку, називається I.

1013
00:49:26,160 --> 00:49:33,530
І я буду тримати перебирає, так
Поки я менше, ніж довжина с.

1014
00:49:33,530 --> 00:49:35,930
>> Виявляється, ми не зробили
зробити це в останній раз,

1015
00:49:35,930 --> 00:49:39,100
що з поставляється з
Функція називається Стірлінга.

1016
00:49:39,100 --> 00:49:42,690
Назад в день, а в цілому
до сих пір при здійсненні функцій,

1017
00:49:42,690 --> 00:49:45,405
люди часто вибирають дуже
ємні імена, свого роду звук

1018
00:49:45,405 --> 00:49:48,280
як то, що ви хочете, навіть якщо це
не вистачає кількох голосних звуків або букв.

1019
00:49:48,280 --> 00:49:50,660
Так Стірлінга є
ім'я функції, яка

1020
00:49:50,660 --> 00:49:53,880
приймає аргумент між
круглі дужки, які повинні бути рядком.

1021
00:49:53,880 --> 00:49:56,910
І це як раз повертає ціле число,
довжина цього рядка.

1022
00:49:56,910 --> 00:50:00,580
>> Так що цей цикл на лінії 7 відбувається
Щоб почати зворотний відлік на я дорівнює 0.

1023
00:50:00,580 --> 00:50:02,530
Це буде збільшуватися
я на кожній ітерації

1024
00:50:02,530 --> 00:50:04,350
на 1, як ми робили кілька разів.

1025
00:50:04,350 --> 00:50:06,780
Але це буде тільки робити
це до точки

1026
00:50:06,780 --> 00:50:09,660
коли я довжина
з самої рядки.

1027
00:50:09,660 --> 00:50:14,520
>> Так що це шлях, в кінцевому рахунку,
перебирає персонажів

1028
00:50:14,520 --> 00:50:17,430
в рядку А як слід.

1029
00:50:17,430 --> 00:50:20,670
Я збираюся роздрукувати НЕ
вся рядок, але відсоток с,

1030
00:50:20,670 --> 00:50:22,860
один символ
а потім нової лінії.

1031
00:50:22,860 --> 00:50:24,880
А потім я збираюся
йти вперед, і мені потрібно

1032
00:50:24,880 --> 00:50:29,080
сказати, що я хочу надрукувати
Ith характер с.

1033
00:50:29,080 --> 00:50:33,450
>> Так що, якщо я це змінна, яка вказує
індекс рядка, де

1034
00:50:33,450 --> 00:50:37,230
ви в ньому, мені потрібно, щоб мати можливість
кажуть, дайте мені ю характер с.

1035
00:50:37,230 --> 00:50:40,390
І з має спосіб зробити
це квадратні дужки.

1036
00:50:40,390 --> 00:50:43,679
Ви просто говорите від імені
рядок, яка в даному випадку є s.

1037
00:50:43,679 --> 00:50:46,970
Потім ви використовуєте квадратні дужки, які є
як правило, трохи вище Return або Enter

1038
00:50:46,970 --> 00:50:48,110
клавіша на клавіатурі.

1039
00:50:48,110 --> 00:50:52,410
І тоді ви поклали індекс
символ, який ви хочете надрукувати.

1040
00:50:52,410 --> 00:50:55,960
Таким чином, індекс буде
number-- 0, або 1, або 2, або 3, або точка,

1041
00:50:55,960 --> 00:50:57,590
точка, точка, деяке інше число.

1042
00:50:57,590 --> 00:51:00,920
>> І ми гарантуємо, що це буде
бути правильний номер, тому що я

1043
00:51:00,920 --> 00:51:02,360
почати відлік з 0.

1044
00:51:02,360 --> 00:51:07,020
І за замовчуванням, перший символ
в рядку є конвенцією 0.

1045
00:51:07,020 --> 00:51:09,230
І другий персонаж кронштейн 1.

1046
00:51:09,230 --> 00:51:11,120
І третій персонаж кронштейн 2.

1047
00:51:11,120 --> 00:51:13,630
І ви не хочете йти занадто
далеко, але ми не будемо, тому що ми

1048
00:51:13,630 --> 00:51:17,780
відбувається не тільки збільшення I до нього
дорівнює довжині рядка.

1049
00:51:17,780 --> 00:51:20,210
І в цей момент,
цей цикл зупиниться.

1050
00:51:20,210 --> 00:51:25,550
>> Отже, дозвольте мені йти вперед і зберегти цей
програма, і запустити гарантувати рядку 0.

1051
00:51:25,550 --> 00:51:28,400
Але я облажався.

1052
00:51:28,400 --> 00:51:35,390
Побічно оголошуючи функції бібліотеки
Stirling з типом такої і such-- зараз,

1053
00:51:35,390 --> 00:51:36,430
це звучить знайомо.

1054
00:51:36,430 --> 00:51:37,440
Але це не PRINTF.

1055
00:51:37,440 --> 00:51:38,540
І це не отримати рядок.

1056
00:51:38,540 --> 00:51:40,480
>> Я не ввернути в
так само, як в цей раз.

1057
00:51:40,480 --> 00:51:45,100
Але зверніть увагу, тут трохи вниз
крім того, включати string.h заголовка,

1058
00:51:45,100 --> 00:51:47,210
явно надати
декларація Стерлінга.

1059
00:51:47,210 --> 00:51:48,820
Так що насправді ключ там.

1060
00:51:48,820 --> 00:51:51,670
>> І справді виявляється,
є ще один файл заголовка

1061
00:51:51,670 --> 00:51:53,970
що ми не використали
в класі все ж, але це

1062
00:51:53,970 --> 00:51:56,480
серед тих, доступні
до вас, називається string.h.

1063
00:51:56,480 --> 00:52:00,930
І в цьому файлі, string.h
є Стірлінга оголошена.

1064
00:52:00,930 --> 00:52:05,220
Отже, дозвольте мені йти вперед і
зберегти це, зробити рядок

1065
00:52:05,220 --> 00:52:08,040
0-- приємно, ніяких повідомлень про помилки на цей раз.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, і
Я збираюся натиснути кнопку введення,

1067
00:52:12,290 --> 00:52:16,710
в який момент відбувається GetString
щоб повернути рядок, помістіть її в с.

1068
00:52:16,710 --> 00:52:21,890
Тоді, що цикл буде перебирати
над символів S один в той час,

1069
00:52:21,890 --> 00:52:28,420
і друкувати їх по одному в кожному рядку, тому що
У мене було, що зворотною косою п в кінці.

1070
00:52:28,420 --> 00:52:34,530
Так що я міг би опустити, що зворотний слеш
п, а потім просто роздрукувати всі Zamyla

1071
00:52:34,530 --> 00:52:37,460
в тому ж рядку,
ефективно перевизначення

1072
00:52:37,460 --> 00:52:38,999
Printf, що не все, що корисно.

1073
00:52:38,999 --> 00:52:40,540
Але в даному випадку, я не зробив цього.

1074
00:52:40,540 --> 00:52:43,610
Я насправді роздруковуються
характер, в той час, по одному в кожному рядку,

1075
00:52:43,610 --> 00:52:45,400
так що ми насправді побачити ефект.

1076
00:52:45,400 --> 00:52:46,900
>> Але я повинен відзначити одну річ тут.

1077
00:52:46,900 --> 00:52:48,930
І ми повернемося до
це в наступного тижня.

1078
00:52:48,930 --> 00:52:52,650
Виявляється, що це
код потенційно глючний.

1079
00:52:52,650 --> 00:52:56,560
>> Виявляється, що отримати рядок
і деякі інші функції в житті

1080
00:52:56,560 --> 00:53:00,280
не обов'язково завжди
повернути те, що ви очікували.

1081
00:53:00,280 --> 00:53:03,010
Ми знаємо з класу останнього
Час в цьому, що отримати

1082
00:53:03,010 --> 00:53:04,960
рядок повинна повертати рядок.

1083
00:53:04,960 --> 00:53:09,900
Але що, якщо користувач друкує такі
Найдовше слово або абзац, або есе

1084
00:53:09,900 --> 00:53:13,010
що там просто не вистачає
пам'яті в комп'ютері, щоб відповідати його.

1085
00:53:13,010 --> 00:53:15,410
>> Як і те, що якщо щось йде
неправильно під капотом?

1086
00:53:15,410 --> 00:53:18,400
Це не може статися часто,
але це може статися один раз

1087
00:53:18,400 --> 00:53:21,520
в той час, дуже рідко.

1088
00:53:21,520 --> 00:53:25,460
І так виходить, що отримати рядок
і функції подібні до нього не обов'язково

1089
00:53:25,460 --> 00:53:26,380
завжди повертати рядки.

1090
00:53:26,380 --> 00:53:30,680
Вони можуть повертати деяке значення помилки,
деяке значення сторожового так би мовити,

1091
00:53:30,680 --> 00:53:32,612
що вказує на те, що
щось пішло не так.

1092
00:53:32,612 --> 00:53:35,320
І ви б знали тільки це з
дізнавшись його в класі зараз,

1093
00:53:35,320 --> 00:53:37,700
або прочитавши деяку додаткову документацію.

1094
00:53:37,700 --> 00:53:43,120
Виявляється, що отримати рядок
може повертати значення, зване нульовим.

1095
00:53:43,120 --> 00:53:46,220
Null це особлива цінність, яку ми будемо
повернутися в майбутнього тижня.

1096
00:53:46,220 --> 00:53:50,420
Але зараз, просто знаю, що якщо я хочу
щоб бути дійсно власне в просуванні вперед

1097
00:53:50,420 --> 00:53:52,650
за допомогою отримання рядки, я
не повинні просто назвати його,

1098
00:53:52,650 --> 00:53:56,870
і сліпо використовувати значення, що повертається,
вважаючи, що це рядок.

1099
00:53:56,870 --> 00:53:59,420
>> Я повинен спочатку сказати,
Гей, почекайте хвилину, тільки

1100
00:53:59,420 --> 00:54:03,380
діяти, якщо s не дорівнює
нуль, де нуль, знову ж таки,

1101
00:54:03,380 --> 00:54:04,660
це просто якесь особливе значення.

1102
00:54:04,660 --> 00:54:07,770
І це єдине спеціальне значення, яке ви
потрібно турбуватися про для отримання рядка.

1103
00:54:07,770 --> 00:54:10,900
Отримати рядок або збирається
повертати рядок або NULL.

1104
00:54:10,900 --> 00:54:17,219
>> І ця точка знак оклику рівності
ви могли б знати, від можливо математичному класі

1105
00:54:17,219 --> 00:54:20,510
що ви могли б намалювати знак рівності з
лінія, що проходить через нього, щоб вказати, не рівні.

1106
00:54:20,510 --> 00:54:23,135
Це взагалі не персонаж
ви можете набрати на клавіатурі.

1107
00:54:23,135 --> 00:54:26,480
І тому в більшості мов програмування,
коли ви хочете сказати, не рівні,

1108
00:54:26,480 --> 00:54:29,160
ви використовуєте знак оклику,
інакше відомий як вибух.

1109
00:54:29,160 --> 00:54:33,180
Так ви говорите, чубчик одно, що
означає не дорівнює, за логікою речей.

1110
00:54:33,180 --> 00:54:38,060
Це так само, як там не більш
ніж, або рівне або менше

1111
00:54:38,060 --> 00:54:41,270
або дорівнює клавішу на клавіатурі
що робить все це в одному символі.

1112
00:54:41,270 --> 00:54:44,020
Так ось чому, в минулих прикладах,
ви зробили відкритий кронштейн, а потім

1113
00:54:44,020 --> 00:54:48,670
знак рівності, для того, щоб зробити
більше або, скажімо, менше.

1114
00:54:48,670 --> 00:54:49,910
>> Так що винос тут?

1115
00:54:49,910 --> 00:54:53,880
Це просто спосіб тепер
введення цього синтаксису, ця функція,

1116
00:54:53,880 --> 00:54:57,390
перебирає приватних осіб
символів в рядку.

1117
00:54:57,390 --> 00:55:00,260
І точно так само, як ті площі
кронштейни дозволяють отримати на них,

1118
00:55:00,260 --> 00:55:03,790
розглянути ці квадратні дужки
вид натякаючи на це основний

1119
00:55:03,790 --> 00:55:06,040
дизайн, в результаті чого кожен
символ всередині рядка

1120
00:55:06,040 --> 00:55:10,180
є свого роду затиснуті в десь внизу
капот в пам'яті вашого комп'ютера.

1121
00:55:10,180 --> 00:55:12,340
>> Але давайте зробимо варіант цього.

1122
00:55:12,340 --> 00:55:14,880
Виявляється, що це
програма правильна.

1123
00:55:14,880 --> 00:55:18,810
Таким чином, на осі CS50 для оцінки
код, тепер це правильно.

1124
00:55:18,810 --> 00:55:22,959
Особливо тепер, коли я перевірка
нуль, ця програма ніколи не повинна врізатися.

1125
00:55:22,959 --> 00:55:24,500
І я просто знаю, що з досвіду.

1126
00:55:24,500 --> 00:55:28,040
Але немає нічого, що
ми можемо дійсно піти не так тут.

1127
00:55:28,040 --> 00:55:31,860
Але це не дуже добре продумані,
тому що давайте повернемося до основ.

1128
00:55:31,860 --> 00:55:34,450
>> По-перше, principles--
що робить цикл робити?

1129
00:55:34,450 --> 00:55:36,290
Для циклу робить три речі.

1130
00:55:36,290 --> 00:55:39,340
Вона инициализирует деякі
значення, якщо ви попросите його.

1131
00:55:39,340 --> 00:55:41,770
Він перевіряє стан.

1132
00:55:41,770 --> 00:55:45,380
А потім після кожного
ітерації, після кожного циклу,

1133
00:55:45,380 --> 00:55:49,330
він збільшує деякі
значення або значення, тут.

1134
00:55:49,330 --> 00:55:50,600
>> Так що ж це значить?

1135
00:55:50,600 --> 00:55:52,940
Ми инициализируем я до 0.

1136
00:55:52,940 --> 00:55:58,610
Ми перевіряємо і переконайтеся, що я менше
довжина с, що Z-А-М-У-Л-А,

1137
00:55:58,610 --> 00:55:59,900
так що менше 6.

1138
00:55:59,900 --> 00:56:02,590
І справді, 0, як менше 6.

1139
00:56:02,590 --> 00:56:05,580
>> Ми роздрукувати Z від імені Zamyla в.

1140
00:56:05,580 --> 00:56:08,080
Тоді ми збільшуємо I від 0 до 1.

1141
00:56:08,080 --> 00:56:11,290
Потім ми перевіряємо, 1 менше
ніж довжина S?

1142
00:56:11,290 --> 00:56:13,270
Довжина S становить 6.

1143
00:56:13,270 --> 00:56:13,950
Так.

1144
00:56:13,950 --> 00:56:16,880
>> Таким чином, ми друкуємо в імені Zamyla, в ZA.

1145
00:56:16,880 --> 00:56:20,090
Ми збільшуємо I від 0, 1, до 2.

1146
00:56:20,090 --> 00:56:23,720
Потім ми перевіряємо, на 2 менше
довжина імені Zamyla в.

1147
00:56:23,720 --> 00:56:25,380
6 так 2 становить менше 6.

1148
00:56:25,380 --> 00:56:30,460
Так, давайте роздрукувати прямо зараз M в
ім'я Zamyla, в третій символ.

1149
00:56:30,460 --> 00:56:34,110
>> Ключовим моментом тут є те, що на кожному
ітерація цієї історії, я перевіряю,

1150
00:56:34,110 --> 00:56:37,810
це я менше, ніж довжина Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Але заковика в тому, що
Stirling не є властивістю.

1152
00:56:40,350 --> 00:56:43,100
Ті з вас, хто програмував
до цього в Java або іншими мовами

1153
00:56:43,100 --> 00:56:46,310
може знати довжину рядка є
властивість, тільки деякі тільки для читання значення.

1154
00:56:46,310 --> 00:56:50,220
>> В С в цьому випадку, якщо це
функція, яка в буквальному сенсі

1155
00:56:50,220 --> 00:56:53,520
підрахунку кількості
символи в Zamyla кожен раз, коли

1156
00:56:53,520 --> 00:56:54,740
ми називаємо цю функцію.

1157
00:56:54,740 --> 00:56:58,500
Кожен раз, коли ви просите комп'ютер, щоб використовувати
Stirling, це поглянути на Zamyla,

1158
00:56:58,500 --> 00:57:01,960
і кажучи: Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
І це повертає 6.

1160
00:57:02,962 --> 00:57:04,920
Наступного разу, коли ви дзвоните
то всередині, що цикл,

1161
00:57:04,920 --> 00:57:08,610
це буде дивитися на Zamyla
знову, скажімо Z-А-М-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
І він збирається повернутися 6.

1163
00:57:10,320 --> 00:57:12,980
Так що нерозумно про цей проект?

1164
00:57:12,980 --> 00:57:17,700
>> Чому мій код не 5 з 5
для дизайну прямо зараз, так би мовити?

1165
00:57:17,700 --> 00:57:20,600
Ну, Я питаю
питання зайве.

1166
00:57:20,600 --> 00:57:23,030
Я роблю більше роботи, ніж мені потрібно.

1167
00:57:23,030 --> 00:57:25,370
>> Таким чином, навіть не дивлячись на те,
відповідь правильна, я

1168
00:57:25,370 --> 00:57:29,560
питаючи комп'ютер, що таке
довжина Zamyla знову,

1169
00:57:29,560 --> 00:57:31,380
і знову, і знову, і знову?

1170
00:57:31,380 --> 00:57:33,980
І ця відповідь
ніколи не зміниться.

1171
00:57:33,980 --> 00:57:35,900
Це завжди буде 6.

1172
00:57:35,900 --> 00:57:39,730
>> Таким чином, краще рішення, ніж це
буде це наступна версія.

1173
00:57:39,730 --> 00:57:43,390
Дозвольте мені йти вперед і покласти його в
окремий файл з ім'ям string1.c,

1174
00:57:43,390 --> 00:57:44,990
просто тримати його окремо.

1175
00:57:44,990 --> 00:57:47,260
І виходить, протягом
цикл, ви можете насправді

1176
00:57:47,260 --> 00:57:50,210
оголосити кілька змінних одночасно.

1177
00:57:50,210 --> 00:57:53,460
>> Так що я буду тримати я і встановити його в 0.

1178
00:57:53,460 --> 00:57:56,190
Але я також збираюся
додайте кому, і сказати,

1179
00:57:56,190 --> 00:58:01,050
дайте мені змінну п, у якого
значення дорівнює значенню довжину рядка с.

1180
00:58:01,050 --> 00:58:09,410
А тепер, будь ласка, мій стан
до тих пір, як я менше п.

1181
00:58:09,410 --> 00:58:14,140
>> Отже, таким чином, логіка
ідентичні в кінці дня.

1182
00:58:14,140 --> 00:58:18,280
Але я згадуючи
значення 6, в цьому випадку.

1183
00:58:18,280 --> 00:58:19,780
Яка довжина імені Zamyla в?

1184
00:58:19,780 --> 00:58:20,860
І я ставлю його в п.

1185
00:58:20,860 --> 00:58:23,050
>> І я до сих пір перевірки
умова кожен раз.

1186
00:58:23,050 --> 00:58:24,300
Є 0 менше, ніж 6?

1187
00:58:24,300 --> 00:58:25,600
1 менше, ніж 6?

1188
00:58:25,600 --> 00:58:28,600
Є 2 менше, ніж 6, і так далі?

1189
00:58:28,600 --> 00:58:31,914
>> Але я не вимагаю комп'ютер
знову і знову, що

1190
00:58:31,914 --> 00:58:33,080
довжина імені Zamyla в?

1191
00:58:33,080 --> 00:58:34,320
Що довжина імені Zamyla в?

1192
00:58:34,320 --> 00:58:35,986
Що довжина імені цього Zamyla в?

1193
00:58:35,986 --> 00:58:40,440
Я буквально пам'ятати, що перший і
відповісти тільки в цій другій змінної п.

1194
00:58:40,440 --> 00:58:45,280
Так що це зараз було б не тільки
правильно, але і добре продумані.

1195
00:58:45,280 --> 00:58:46,670
>> Тепер, що стосується стилю?

1196
00:58:46,670 --> 00:58:48,866
Я назвав мої змінні
дуже добре, я б сказав.

1197
00:58:48,866 --> 00:58:50,240
Зараз вони супер лаконічним.

1198
00:58:50,240 --> 00:58:52,090
І це абсолютно нормально.

1199
00:58:52,090 --> 00:58:55,120
>> Якщо у вас є тільки один
рядок в програмі,

1200
00:58:55,120 --> 00:58:56,860
Ви могли б також назвати це S для рядка.

1201
00:58:56,860 --> 00:58:59,370
Якщо у вас є тільки одна змінна
для підрахунку в програмі,

1202
00:58:59,370 --> 00:59:00,710
Ви могли б також назвати це я.

1203
00:59:00,710 --> 00:59:03,500
Якщо у вас є довжина, п
супер часто, як добре.

1204
00:59:03,500 --> 00:59:05,800
Але я не помітив будь-якої з мого коду.

1205
00:59:05,800 --> 00:59:09,200
>> Я не повідомив reader--
що будь моя TF, або TA,

1206
00:59:09,200 --> 00:59:12,460
або просто colleague-- то, що, як передбачається,
щоб йти далі в цій програмі.

1207
00:59:12,460 --> 00:59:15,760
І так, щоб отримати хороший стиль,
то, що я хотів би зробити

1208
00:59:15,760 --> 00:59:24,580
це щось this--
як запитати користувача для входу.

1209
00:59:24,580 --> 00:59:26,670
І я міг би переписати
це будь-яку кількість способів.

1210
00:59:26,670 --> 00:59:35,630
>> Переконайтеся, що S-- переконайтеся ОТРИМУЄ
Рядок, повертається рядок.

1211
00:59:35,630 --> 00:59:40,280
А потім в here--, і це, можливо,
найважливішим comment-- ітерація

1212
00:59:40,280 --> 00:59:44,450
над персонажами з одного одночасно.

1213
00:59:44,450 --> 00:59:47,060
І я міг би використовувати будь-який
Вибір англійської мови

1214
00:59:47,060 --> 00:59:49,650
тут, щоб описати кожен
з цих шматків коду.

1215
00:59:49,650 --> 00:59:52,740
>> Зверніть увагу на те, що я не залишається
коментувати кожен рядок коду,

1216
00:59:52,740 --> 00:59:55,690
насправді просто на цікавий
з них, ті,

1217
00:59:55,690 --> 00:59:59,460
є якийсь сенс, що я міг би
хочуть, щоб зробити супер ясний комусь

1218
00:59:59,460 --> 01:00:00,460
читання мого коду.

1219
01:00:00,460 --> 01:00:02,920
А чому ти дзвониш отримати
рядок запитує у користувача для входу?

1220
01:00:02,920 --> 01:00:05,450
Навіть те, що один не обов'язково
все, що описовий характер.

1221
01:00:05,450 --> 01:00:09,340
Але це допомагає розповісти історію, тому що
Другий рядок в історії є, переконайтеся,

1222
01:00:09,340 --> 01:00:10,740
отримати рядки, повернутої рядок.

1223
01:00:10,740 --> 01:00:14,260
>> І третій рядок в цій історії,
перебирати символів в одному ами

1224
01:00:14,260 --> 01:00:15,380
зараз.

1225
01:00:15,380 --> 01:00:17,920
А тепер просто для хорошої заходом,
Я збираюся йти вперед і додати

1226
01:00:17,920 --> 01:00:24,560
ще один коментар, який якраз
каже друк I-й символ в с.

1227
01:00:24,560 --> 01:00:26,520
Тепер, що я зробив
в кінці дня?

1228
01:00:26,520 --> 01:00:29,190
>> Я додав деякі англійські
Слова у вигляді коментарів.

1229
01:00:29,190 --> 01:00:32,700
Символ коса риска означає, агов,
Комп'ютер це для людини,

1230
01:00:32,700 --> 01:00:33,820
не для вас, комп'ютер.

1231
01:00:33,820 --> 01:00:35,119
Таким чином, вони ігноруються логічно.

1232
01:00:35,119 --> 01:00:35,910
Вони просто є.

1233
01:00:35,910 --> 01:00:39,830
>> І дійсно, CS50 IDE показує їх як
сірий, як корисні, але не ключ

1234
01:00:39,830 --> 01:00:41,000
до програми.

1235
01:00:41,000 --> 01:00:42,570
Зверніть увагу на те, що тепер ви можете зробити.

1236
01:00:42,570 --> 01:00:44,950
Чи знаєте ви C
програмування чи ні,

1237
01:00:44,950 --> 01:00:47,722
може просто стояти осторонь в цьому
Програма, і знежирене коментарі.

1238
01:00:47,722 --> 01:00:50,180
Попросіть користувача для введення, переконайтеся,
отримати рядки, повернутої рядок,

1239
01:00:50,180 --> 01:00:53,009
перебирати символів в сек
по одному за раз, надрукувати символ

1240
01:00:53,009 --> 01:00:55,550
I-й символ в S-- ви цього не зробите
навіть дивитися на код

1241
01:00:55,550 --> 01:00:57,270
щоб зрозуміти, що робить ця програма.

1242
01:00:57,270 --> 01:01:00,280
І ще краще, якщо ви самі дивіться
в цій програмі протягом тижня або двох,

1243
01:01:00,280 --> 01:01:02,280
або місяць, або рік,
ви теж не маєте

1244
01:01:02,280 --> 01:01:04,420
дивитися на код,
намагаючись пригадати,

1245
01:01:04,420 --> 01:01:06,630
що я намагаюся зробити з цим кодом?

1246
01:01:06,630 --> 01:01:07,770
>> Ви сказали собі.

1247
01:01:07,770 --> 01:01:11,660
Ви описали це для себе,
або який-небудь колега або ТА, або TF.

1248
01:01:11,660 --> 01:01:14,860
І так це тепер буде
правильно, і хороший дизайн,

1249
01:01:14,860 --> 01:01:18,210
і в кінцевому рахунку, хороший стиль, а також.

1250
01:01:18,210 --> 01:01:19,990
Так що майте це на увазі.

1251
01:01:19,990 --> 01:01:22,200
>> Так що є ще одна
що я збираюся зробити тут

1252
01:01:22,200 --> 01:01:28,240
що тепер може показати саме те, що
відбувається під капотом.

1253
01:01:28,240 --> 01:01:30,390
Так що ця функція
в C та іншими мовами,

1254
01:01:30,390 --> 01:01:33,010
називається типажів
що або неявно

1255
01:01:33,010 --> 01:01:37,250
або явно дозволяє конвертувати
від одного типу даних в інший.

1256
01:01:37,250 --> 01:01:39,800
Ми маємо справу так
далеко сьогодні з рядками.

1257
01:01:39,800 --> 01:01:41,250
>> І рядки символів.

1258
01:01:41,250 --> 01:01:44,910
Але пам'ятайте з тижня
0, які символи?

1259
01:01:44,910 --> 01:01:49,334
Символи просто абстракція
на вершині numbers-- десяткових чисел,

1260
01:01:49,334 --> 01:01:52,500
і десяткових чисел дійсно просто
абстракція на вершині двійкових чисел,

1261
01:01:52,500 --> 01:01:53,720
як ми визначили її.

1262
01:01:53,720 --> 01:01:55,540
>> Так символи номера.

1263
01:01:55,540 --> 01:01:58,410
І цифри символів,
тільки в залежності від контексту.

1264
01:01:58,410 --> 01:02:01,250
І виходить, що всередині
комп'ютерної програми,

1265
01:02:01,250 --> 01:02:06,830
Ви можете вказати, як ви хочете виглядати
в біти всередині цієї програми?

1266
01:02:06,830 --> 01:02:10,400
>> Нагадаємо, від тижня 0, що у нас було
Ascii, що саме цей код

1267
01:02:10,400 --> 01:02:11,620
відображення букв до цифр.

1268
01:02:11,620 --> 01:02:13,660
І ми сказали, капітал А 65.

1269
01:02:13,660 --> 01:02:15,860
Капітал Б 66, і так далі.

1270
01:02:15,860 --> 01:02:20,500
>> І зауважте, ми, по суті є символи на
верхній ряд тут, як C назве їх,

1271
01:02:20,500 --> 01:02:23,400
символів, а потім
Інтс на другому ряду.

1272
01:02:23,400 --> 01:02:28,180
І виходить, ви можете конвертувати
бесшовно між ними, як правило.

1273
01:02:28,180 --> 01:02:30,042
І якщо ми хочемо зробити
це свідомо, ми

1274
01:02:30,042 --> 01:02:31,750
може знадобитися для вирішення
щось на зразок цього.

1275
01:02:31,750 --> 01:02:33,590
>> Ми могли б хотіти, щоб перетворити
великі букви, щоб знизити

1276
01:02:33,590 --> 01:02:35,330
випадок, або нижній регістр у верхній регістр.

1277
01:02:35,330 --> 01:02:38,000
І виходить, що є
насправді картина тут

1278
01:02:38,000 --> 01:02:39,900
ми можемо охопити всього декілька хвилин.

1279
01:02:39,900 --> 01:02:44,120
Але давайте спочатку подивимося на
Приклад виконання цього в явному вигляді.

1280
01:02:44,120 --> 01:02:46,340
>> Я збираюся повернутися в CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Я збираюся створити
файл з ім'ям Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
І я збираюся йти вперед і додати мій
стандарт io.h у верхній частині, INT Основна порожнеча

1283
01:02:55,960 --> 01:02:57,370
у верхній частині моєї функції.

1284
01:02:57,370 --> 01:03:02,700
А потім я просто буду робити
following-- для циклу від я дорівнює,

1285
01:03:02,700 --> 01:03:04,610
скажімо, 65 років.

1286
01:03:04,610 --> 01:03:10,460
>> І тоді я буде менше
65, плюс 26 букв в алфавіті.

1287
01:03:10,460 --> 01:03:12,640
Так що я дам комп'ютер
робити математику для мене там.

1288
01:03:12,640 --> 01:03:15,100
А потім всередині цієї петлі,
що я буду друкувати?

1289
01:03:15,100 --> 01:03:19,230
>> % С є% я зворотної косої межі п.

1290
01:03:19,230 --> 01:03:21,290
А тепер я хочу, щоб підключити два значення.

1291
01:03:21,290 --> 01:03:24,530
Я тимчасово поставив питання
Оцінки там запросити на це питання.

1292
01:03:24,530 --> 01:03:29,940
>> Я хочу ітерацію від 65 вперед
для 26 букв алфавіту,

1293
01:03:29,940 --> 01:03:35,190
друк на кожній ітерації, що
інтегральний еквівалент персонажа.

1294
01:03:35,190 --> 01:03:38,299
Іншими словами, я хочу
перебрати 26 номерів друку

1295
01:03:38,299 --> 01:03:41,590
що Ascii символ, буква,
і що відповідне число is--

1296
01:03:41,590 --> 01:03:44,650
насправді просто відтворення
діаграма з цього слайда.

1297
01:03:44,650 --> 01:03:47,010
Так що ж ці знаки питання бути?

1298
01:03:47,010 --> 01:03:51,760
>> Що ж, виходить, що другий
потрібно просто бути змінної я.

1299
01:03:51,760 --> 01:03:53,860
Я хочу бачити, що як число.

1300
01:03:53,860 --> 01:03:58,920
А середній аргумент
тут, я можу сказати комп'ютера

1301
01:03:58,920 --> 01:04:03,470
для лікування, що число
я як характер, так

1302
01:04:03,470 --> 01:04:05,880
замінити його тут відсотків C.

1303
01:04:05,880 --> 01:04:07,990
>> Іншими словами, якщо я, то
людина програміст, знаю,

1304
01:04:07,990 --> 01:04:09,865
це просто цифри
в кінці дня.

1305
01:04:09,865 --> 01:04:12,500
І я знаю, що 65 повинен
карта в якийсь характер.

1306
01:04:12,500 --> 01:04:15,310
За допомогою цього явного приведення типів,
з дужкою,

1307
01:04:15,310 --> 01:04:18,840
ім'я типу даних, який ви хочете
конвертувати, і закритим дужка,

1308
01:04:18,840 --> 01:04:21,200
Ви можете сказати
комп'ютер, агов, комп'ютер,

1309
01:04:21,200 --> 01:04:24,130
перетворити це число в символ.

1310
01:04:24,130 --> 01:04:26,250
>> Так що, коли я запускаю це
програма після компіляції,

1311
01:04:26,250 --> 01:04:29,740
давайте подивимося, що я get-- зробити Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Чорт це, що я зробив неправильно тут?

1313
01:04:33,020 --> 01:04:35,884
Використання незаявлених ідентифікатора,
все гаразд, не навмисно,

1314
01:04:35,884 --> 01:04:37,800
але давайте подивимося, якщо ми не можемо
Причина через це.

1315
01:04:37,800 --> 01:04:41,220
>> Так лінія five-- так що я не отримав
дуже далеко, перш ніж загвинчування.

1316
01:04:41,220 --> 01:04:42,140
Все добре.

1317
01:04:42,140 --> 01:04:46,560
Таким чином, лінія 5 для г дорівнює 65-- я бачу.

1318
01:04:46,560 --> 01:04:50,130
Так що пам'ятайте, що в C, на відміну від деяких
мови, якщо у вас є попереднє програмування

1319
01:04:50,130 --> 01:04:52,190
досвід, у вас є
щоб сказати комп'ютера,

1320
01:04:52,190 --> 01:04:55,040
на відміну від нуля, то,
тип змінної вона.

1321
01:04:55,040 --> 01:04:56,860
>> І я забув ключову фразу тут.

1322
01:04:56,860 --> 01:04:59,200
У рядку п'ять, я почав використовувати I.

1323
01:04:59,200 --> 01:05:01,560
Але я не сказав C
які дані типу це.

1324
01:05:01,560 --> 01:05:04,570
Так що я збираюся йти сюди і
кажуть, ах, зробити це ціле число.

1325
01:05:04,570 --> 01:05:07,050
>> Тепер я збираюся йти вперед і перекомпіліровать.

1326
01:05:07,050 --> 01:05:08,080
Це зафіксовано, що.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, це свого роду прохолодний.

1328
01:05:12,660 --> 01:05:15,360
Мало того, що це супер швидко
запитати комп'ютер на це питання,

1329
01:05:15,360 --> 01:05:18,885
а не дивитися його на слайд,
вона роздруковується по одному в кожному рядку, А 65,

1330
01:05:18,885 --> 01:05:24,860
B 66, всі шляхи down--, так як я
зробив це 26 times-- з буквами г,

1331
01:05:24,860 --> 01:05:25,630
що становить 90.

1332
01:05:25,630 --> 01:05:27,790
І справді, трохи
більш розумним буде

1333
01:05:27,790 --> 01:05:31,030
були для мене не покладатися
на комп'ютері, щоб додати 26.

1334
01:05:31,030 --> 01:05:34,060
Я міг би просто зробити
90, а також, до тих пір,

1335
01:05:34,060 --> 01:05:37,390
як я не роблять ту саму помилку двічі.

1336
01:05:37,390 --> 01:05:41,880
Я хочу, щоб йти через
г, а не тільки через у.

1337
01:05:41,880 --> 01:05:44,000
>> Так що це явне приведення.

1338
01:05:44,000 --> 01:05:47,860
Виявляється, що це
навіть немає необхідності.

1339
01:05:47,860 --> 01:05:52,480
Дозвольте мені йти вперед і повторно запустити цей
компілятор, і перекладка Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Виявляється, що C є досить розумний.

1341
01:05:54,940 --> 01:05:57,150
>> І Printf, зокрема,
досить розумний.

1342
01:05:57,150 --> 01:06:01,260
Якщо ви просто пройти я двічі
для обох наповнювачів, Printf

1343
01:06:01,260 --> 01:06:04,510
зрозуміють, ой, ну я тебе знаю
дав мені integer-- деяке число,

1344
01:06:04,510 --> 01:06:06,380
як 65, або 90, або будь-який інший.

1345
01:06:06,380 --> 01:06:10,170
Але я бачу, що ви хочете, щоб я
форматування це число як символ.

1346
01:06:10,170 --> 01:06:16,460
І тому Printf може неявно наведено
ІНТ до напівкоксу для вас.

1347
01:06:16,460 --> 01:06:19,360
Так що це не проблема взагалі.

1348
01:06:19,360 --> 01:06:23,100
>> Але зверніть увагу, через цю еквівалентності
ми можемо насправді зробити це, як добре.

1349
01:06:23,100 --> 01:06:26,520
Дозвольте мені йти вперед і зробити один
інша версія this-- Ascii 1.C.

1350
01:06:26,520 --> 01:06:31,800
І замість того, щоб перебирає
цілі числа, дійсно може підірвати ваш розум

1351
01:06:31,800 --> 01:06:33,610
перебирає символів.

1352
01:06:33,610 --> 01:06:37,660
Якщо символ з отримує капітал A, I
хочуть, щоб йти вперед і робити це,

1353
01:06:37,660 --> 01:06:41,740
до тих пір, С менше або дорівнює
для капіталу Z. І на кожній ітерації

1354
01:06:41,740 --> 01:06:45,690
Я хочу, щоб збільшити C, я можу
Тепер в моїй PRINTF лінії тут

1355
01:06:45,690 --> 01:06:51,320
скажімо, відсотків З
відсотків я знову, розділені C.

1356
01:06:51,320 --> 01:06:57,200
>> А тепер, я можу піти в іншому напрямку,
лиття характер явно

1357
01:06:57,200 --> 01:06:58,500
в ціле число.

1358
01:06:58,500 --> 01:07:00,560
Так що, знову ж таки, навіщо ви це робите?

1359
01:07:00,560 --> 01:07:03,830
Це трохи дивно роду
розраховувати з точки зору персонажів.

1360
01:07:03,830 --> 01:07:07,430
>> Але якщо ви розумієте, що це
відбувається під капотом,

1361
01:07:07,430 --> 01:07:08,430
немає дійсно ніякої магії.

1362
01:07:08,430 --> 01:07:13,060
Ти говориш, агов, комп'ютер дасть
мене змінна називається C типу напівкоксу.

1363
01:07:13,060 --> 01:07:16,520
Ініціалізувати його капіталу А. І
помітити одиничні лапки матерії.

1364
01:07:16,520 --> 01:07:19,580
>> Для символів в C, пам'ятаєте з
Минулого тижня, ви використовуєте одиничні лапки.

1365
01:07:19,580 --> 01:07:23,720
Для рядків, слів,
фрази, ви використовуєте подвійні лапки.

1366
01:07:23,720 --> 01:07:27,210
OK, комп'ютер, продовжуйте робити це, так
Поки символ менше

1367
01:07:27,210 --> 01:07:28,050
або дорівнює р

1368
01:07:28,050 --> 01:07:32,640
І я знаю, що від мого Ascii таблиці, що все
з цих кодів ASCII є суміжними.

1369
01:07:32,640 --> 01:07:33,400
>> Там немає ніяких прогалин.

1370
01:07:33,400 --> 01:07:36,737
Так що це просто від А до Z,
розділених одним номером кожного.

1371
01:07:36,737 --> 01:07:38,820
І тоді я можу збільшувати
напівкоксу, якщо я дійсно хочу.

1372
01:07:38,820 --> 01:07:40,390
В кінці дня,
це просто число.

1373
01:07:40,390 --> 01:07:41,030
Я знаю, що це.

1374
01:07:41,030 --> 01:07:43,670
Так що я можу тільки припустити, щоб додати до нього 1.

1375
01:07:43,670 --> 01:07:46,940
>> А потім на цей раз, я друкую с,
а потім інтегральний еквівалент.

1376
01:07:46,940 --> 01:07:50,170
І я навіть не потрібно явне приведення.

1377
01:07:50,170 --> 01:07:52,680
Я можу дозволити Printf і тому
комп'ютер зрозуміти речі,

1378
01:07:52,680 --> 01:07:57,300
так що тепер, якщо я біжу
зробити Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Я отримую точно таку ж річ, як добре.

1380
01:08:01,520 --> 01:08:04,530
>> Не корисна програма, яка не though-- жодного
збирається насправді написати програмне забезпечення

1381
01:08:04,530 --> 01:08:07,549
для того, щоб з'ясувати, що було
число, яке відображається в А чи В, або Z?

1382
01:08:07,549 --> 01:08:10,340
Ти просто гуглити це, або
подивитися його в Інтернеті, або подивитися його

1383
01:08:10,340 --> 01:08:11,650
на слайді, чи щось таке.

1384
01:08:11,650 --> 01:08:13,520
Так де ж це насправді отримати корисно?

1385
01:08:13,520 --> 01:08:15,960
>> Ну, якщо говорити про те, що
слайд, зверніть увагу, що є

1386
01:08:15,960 --> 01:08:20,890
фактична картина тут між великими літерами
і в нижньому регістрі, що не було випадковим.

1387
01:08:20,890 --> 01:08:23,760
Зверніть увагу на те, що капітал А 65.

1388
01:08:23,760 --> 01:08:25,830
Рядкові а є 97.

1389
01:08:25,830 --> 01:08:29,649
І як далеко нижче випадок а?

1390
01:08:29,649 --> 01:08:32,649
>> Таким чином, 65 скільки кроків від 97?

1391
01:08:32,649 --> 01:08:36,210
Таким чином, 97 мінус 65 дорівнює 32.

1392
01:08:36,210 --> 01:08:37,910
Таким чином, капітал 65 а є.

1393
01:08:37,910 --> 01:08:39,939
При додаванні 32 до цього,
Ви отримуєте в нижньому регістрі а.

1394
01:08:39,939 --> 01:08:43,729
І, що те ж саме, якщо відняти 32,
ви отримаєте назад до столиці A-- ж з B

1395
01:08:43,729 --> 01:08:46,380
маленькому б, великий С до мало с.

1396
01:08:46,380 --> 01:08:50,670
>> Всі ці зазори 32 друг від друга.

1397
01:08:50,670 --> 01:08:54,450
Тепер, це, здавалося б, щоб дозволити нам
зробити щось на кшталт Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
або Google Docs є, де ви
Можна вибрати все, а потім сказати,

1399
01:08:57,729 --> 01:09:00,520
змінити все в нижньому регістрі, або
змінити все в верхній регістр,

1400
01:09:00,520 --> 01:09:03,840
або змінити тільки перше слово
вироку до верхнього регістру.

1401
01:09:03,840 --> 01:09:07,390
Ми можемо зробити щось
як і ми самі.

1402
01:09:07,390 --> 01:09:12,645
>> Дозвольте мені йти вперед і зберегти файл
тут називається капіталізувати 0.c.

1403
01:09:12,645 --> 01:09:15,770
І давайте йти вперед і нагнітати програму
що робить саме те, що в такий спосіб.

1404
01:09:15,770 --> 01:09:18,460
Так включають в себе бібліотеку CS50.

1405
01:09:18,460 --> 01:09:21,430
І включають в себе стандартні входи / виходи.

1406
01:09:21,430 --> 01:09:22,787
>> І я знаю, що це найближчим часом.

1407
01:09:22,787 --> 01:09:24,870
Так що я збираюся поставити його в
там вже, string.h,

1408
01:09:24,870 --> 01:09:26,960
тому у мене є доступ до
такі речі, як Стірлінг,

1409
01:09:26,960 --> 01:09:29,620
а потім INT головну порожнечу, як зазвичай.

1410
01:09:29,620 --> 01:09:33,420
А потім я збираюся йти вперед
і робити рядки отримує отримати рядок,

1411
01:09:33,420 --> 01:09:35,032
просто, щоб отримати рядок від користувача.

1412
01:09:35,032 --> 01:09:36,740
А потім я збираюся
зробити мій чек осудність.

1413
01:09:36,740 --> 01:09:40,510
Якщо рядок не дорівнює нулю,
то це безпечно продовжити роботу.

1414
01:09:40,510 --> 01:09:42,000
І те, що я хочу зробити?

1415
01:09:42,000 --> 01:09:48,700
Я збираюся перебирати від я дорівнює 0,
і п до довжина рядка с.

1416
01:09:48,700 --> 01:09:51,899
>> І я збираюся зробити це до тих пір,
я менше п, і я плюс плюс.

1417
01:09:51,899 --> 01:09:55,060
До сих пір, я насправді просто
запозичення ідеї раніше.

1418
01:09:55,060 --> 01:09:57,010
А тепер я збираюся ввести філія.

1419
01:09:57,010 --> 01:09:59,635
>> Так що думайте знову чесати, де
ми мали ті розвилки,

1420
01:09:59,635 --> 01:10:05,110
а минулого тижня в C. Я збираюся
говорити про це, якщо я-й символ в секундах

1421
01:10:05,110 --> 01:10:09,250
більше або
одно нижнього регістру а,

1422
01:10:09,250 --> 01:10:13,340
і-- в порожньому місці ви б в буквальному сенсі
кажуть, і, але в C ви говорите амперсанд,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- і I-й символ в секундах
менше або дорівнює рядкові г,

1424
01:10:19,830 --> 01:10:21,780
давайте зробимо щось цікаве.

1425
01:10:21,780 --> 01:10:27,020
Давайте насправді роздрукувати
характер, без переходу на новий рядок

1426
01:10:27,020 --> 01:10:31,760
тобто символ в рядку,
I-й символ в рядку.

1427
01:10:31,760 --> 01:10:37,420
>> Але давайте йти вперед і
відняти 32 з нього.

1428
01:10:37,420 --> 01:10:42,120
Інакше, якщо символ в
Рядок, ми шукаємо

1429
01:10:42,120 --> 01:10:45,950
не між Трохи
і трохи г, йти вперед

1430
01:10:45,950 --> 01:10:48,610
і просто роздрукувала його без змін.

1431
01:10:48,610 --> 01:10:50,840
Таким чином, ми ввели
це позначення в квадратних дужках

1432
01:10:50,840 --> 01:10:53,560
для наших рядків, щоб отримати на
I-й символ в рядку.

1433
01:10:53,560 --> 01:10:57,520
>> Я додав деяку умовну логіку, як
Подряпини на минулому тижні тижні один, де

1434
01:10:57,520 --> 01:10:59,880
Я просто використовую мій фундаментальний
розуміння того, що

1435
01:10:59,880 --> 01:11:01,130
відбувається під капотом.

1436
01:11:01,130 --> 01:11:04,190
Чи є I-ий символ S
більше або дорівнює а?

1437
01:11:04,190 --> 01:11:08,290
Мовляв, це 97, або 98,
або 99, і так далі?

1438
01:11:08,290 --> 01:11:11,940
>> Але це також менше або дорівнює
до значення в нижньому регістрі г?

1439
01:11:11,940 --> 01:11:16,210
І якщо так, то що це означає ця лінія?

1440
01:11:16,210 --> 01:11:20,250
14, це є свого роду
паросток всієї ідеї,

1441
01:11:20,250 --> 01:11:23,840
заголовної лист по
просто відняти 32 з нього,

1442
01:11:23,840 --> 01:11:29,370
в даному випадку, тому що я знаю, за що
діаграми, як представлені мої номери.

1443
01:11:29,370 --> 01:11:33,925
Так що давайте йти вперед і управляти цим,
після компіляції капіталізувати 0.c,

1444
01:11:33,925 --> 01:11:36,210
і запустити капіталізувати 0.

1445
01:11:36,210 --> 01:11:40,300
>> Давайте ввести щось на зразок
Zamyla в нижньому регістрі введення.

1446
01:11:40,300 --> 01:11:42,780
І тепер ми маємо Zamyla в верхньому регістрі.

1447
01:11:42,780 --> 01:11:45,050
Давайте ввести Роба в нижньому регістрі.

1448
01:11:45,050 --> 01:11:46,674
Давайте спробуємо Джейсона в нижньому регістрі.

1449
01:11:46,674 --> 01:11:48,590
І ми продовжуємо отримання
змушені капіталізації.

1450
01:11:48,590 --> 01:11:50,960
Там є невелика помилка, що я
вигляд не очікував.

1451
01:11:50,960 --> 01:11:54,050
Зверніть увагу на мій новий запит осідає
на тому самому рядку, їх імена,

1452
01:11:54,050 --> 01:11:55,520
який відчуває себе трохи брудним.

1453
01:11:55,520 --> 01:11:59,170
>> Так що я збираюся їхати сюди, і
насправді в кінці цієї програми

1454
01:11:59,170 --> 01:12:02,110
роздрукувати символ нового рядка.

1455
01:12:02,110 --> 01:12:03,160
Це все.

1456
01:12:03,160 --> 01:12:06,120
З Printf, вам не потрібно
перейти в змінних або коді формату.

1457
01:12:06,120 --> 01:12:08,460
Ви можете в буквальному сенсі просто роздрукувати
щось на зразок нового рядка.

1458
01:12:08,460 --> 01:12:13,529
>> Так що давайте йти вперед і зробити
капіталізувати 0 раз, повторно запустити його, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
А тепер це трохи симпатичніше.

1460
01:12:14,820 --> 01:12:17,274
Тепер, мій запит на своїй власній новій лінії.

1461
01:12:17,274 --> 01:12:18,440
Так що це все прекрасно і добре.

1462
01:12:18,440 --> 01:12:19,910
Так що це хороший приклад.

1463
01:12:19,910 --> 01:12:22,700
Але я навіть не обов'язково
необхідно жорстко закодувати 32.

1464
01:12:22,700 --> 01:12:23,350
Знаєш, що?

1465
01:12:23,350 --> 01:12:26,350
Я міг би say-- я ніколи не
пам'ятайте, в чому різниця.

1466
01:12:26,350 --> 01:12:29,330
>> Але я знаю, що якщо я
мають малої літери,

1467
01:12:29,330 --> 01:12:34,430
Я по суті хочу, щоб відняти від
незалежно від відстані між мало

1468
01:12:34,430 --> 01:12:39,160
а й великий А, тому що, якщо я припускаю, що
всі інші літери однакові,

1469
01:12:39,160 --> 01:12:41,045
які повинні отримати роботу.

1470
01:12:41,045 --> 01:12:42,670
Але замість того щоб зробити це, ви знаєте, що?

1471
01:12:42,670 --> 01:12:44,240
Там ще один спосіб досі.

1472
01:12:44,240 --> 01:12:48,090
>> Якщо це капіталізувати 1.c-- якби я був
щоб помістити це в окремий файл.

1473
01:12:48,090 --> 01:12:51,030
давайте зробимо капіталізувати 2.C наступним чином.

1474
01:12:51,030 --> 01:12:53,060
Я збираюся дійсно очистити це тут.

1475
01:12:53,060 --> 01:12:57,420
І замість того, щоб навіть не маючи
знати або піклуватися про тих низькому рівні

1476
01:12:57,420 --> 01:13:01,090
деталі реалізації, я замість того, щоб
тільки збирається надрукувати символ,

1477
01:13:01,090 --> 01:13:04,610
цитата кінець цитати, відсотки C, і
потім викликати іншу функцію, яка

1478
01:13:04,610 --> 01:13:09,950
існує, що приймає аргумент,
який є символом, як це.

1479
01:13:09,950 --> 01:13:12,630
>> Виявляється, в C, є
інший виклик функції

1480
01:13:12,630 --> 01:13:15,550
до верхньої, яка, як його ім'я
передбачає, приймає характер

1481
01:13:15,550 --> 01:13:19,350
і робить його в верхній регістр
еквівалент, а потім повертає його

1482
01:13:19,350 --> 01:13:21,410
так що Printf можете підключити його там.

1483
01:13:21,410 --> 01:13:25,484
І так, щоб зробити це, хоча, я
необхідно ввести ще один файл.

1484
01:13:25,484 --> 01:13:28,400
Виявляється, є ще один файл
що ви тільки знаєте з класу,

1485
01:13:28,400 --> 01:13:33,020
або підручник, або інтернет
посилання, називається C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Так що, якщо я додам, що до мого серед заголовка
файли, а тепер заново компілювати цю програму,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Давайте ввести Zamyla всього
в нижньому регістрі, як і раніше працює так само.

1489
01:13:46,690 --> 01:13:48,040
Але ви знаєте, що?

1490
01:13:48,040 --> 01:13:55,590
Виявляється, що у верхній
має деякі інші функціональні можливості.

1491
01:13:55,590 --> 01:13:58,410
>> І дозвольте мені представити це
командувати тут, начебто ніяково

1492
01:13:58,410 --> 01:14:00,250
по імені, але людина для керівництва.

1493
01:14:00,250 --> 01:14:03,960
Виявляється, що більшість комп'ютерів Linux,
як ми використовуємо here-- операційну Linux

1494
01:14:03,960 --> 01:14:06,270
сістема-- є команда
називається людина, яка говорить,

1495
01:14:06,270 --> 01:14:08,530
агов, комп'ютер, дайте мені
роботу з комп'ютером.

1496
01:14:08,530 --> 01:14:10,680
Що ви хочете
шукати в цьому керівництві?

1497
01:14:10,680 --> 01:14:13,840
>> Я хочу подивитися функцію
відкривається верхній, Enter.

1498
01:14:13,840 --> 01:14:16,070
І це трохи загадкове
читати іноді.

1499
01:14:16,070 --> 01:14:18,780
Але зверніть увагу, що ми в
керівництво по Linux програміста.

1500
01:14:18,780 --> 01:14:19,530
І це весь текст.

1501
01:14:19,530 --> 01:14:21,905
І зауважте, що це
ім'я функції тут.

1502
01:14:21,905 --> 01:14:25,030
Виявляється, у нього є двоюрідний брат під назвою
знизити, яка робить протилежне.

1503
01:14:25,030 --> 01:14:29,710
І зауважте під синопсис, щоб використовувати цю функцію
функціонувати сторінки людини, так би мовити,

1504
01:14:29,710 --> 01:14:32,220
каже мені, що я
необхідно включити гр type.h.

1505
01:14:32,220 --> 01:14:33,630
І я знав, що з практики.

1506
01:14:33,630 --> 01:14:36,210
>> Ось, він показує мені два
прототипи для функції,

1507
01:14:36,210 --> 01:14:39,070
так що якщо я коли-небудь хочу, щоб використовувати цю функцію
Я знаю, що вони приймають в якості вхідних даних,

1508
01:14:39,070 --> 01:14:40,652
і те, що вони повертаються в якості вихідного сигналу.

1509
01:14:40,652 --> 01:14:42,360
І потім, якщо я читаю
опис, я бачу

1510
01:14:42,360 --> 01:14:44,820
більш детально, що функція робить.

1511
01:14:44,820 --> 01:14:48,100
Але що більш важливо, якщо
Я дивлюся під значення, що повертається,

1512
01:14:48,100 --> 01:14:51,710
він говорить, повернене значення
що перетвореного листи,

1513
01:14:51,710 --> 01:14:57,880
або С, вихідний вхідний, якщо
перетворення не вдалося.

1514
01:14:57,880 --> 01:15:01,992
>> Іншими словами, верхній намагатиметься
перетворити лист в верхній регістр.

1515
01:15:01,992 --> 01:15:03,450
І якщо так, то він збирається повернути її.

1516
01:15:03,450 --> 01:15:07,010
Але якщо він не може для деяких reason--
може бути, це вже в верхньому регістрі,

1517
01:15:07,010 --> 01:15:09,550
може бути, це знак оклику
або будь-якої іншої punctuation--

1518
01:15:09,550 --> 01:15:12,200
це просто буде
повернути вихідний C,

1519
01:15:12,200 --> 01:15:17,340
а це значить, що я можу зробити мій код
краще розроблені таким чином.

1520
01:15:17,340 --> 01:15:20,580
>> Мені не потрібні всі
ці штопати рядки коду.

1521
01:15:20,580 --> 01:15:22,610
Всі рядки я
тільки виділений може

1522
01:15:22,610 --> 01:15:28,700
бути згорнуті в тільки один простий
лінія, яка є this-- Printf відсотка

1523
01:15:28,700 --> 01:15:33,510
з горішнього кронштейну I S.

1524
01:15:33,510 --> 01:15:36,090
І це було б
приклад кращого дизайну.

1525
01:15:36,090 --> 01:15:40,040
>> Чому реалізувати в 7 або 8 ліній
коду, яким би він був я просто

1526
01:15:40,040 --> 01:15:44,960
видалений, коли ви можете замість того, щоб згорнути
все, що логіка і прийняття рішень

1527
01:15:44,960 --> 01:15:49,620
в одну лінію, 13, що в даний час
спирається на бібліотеку function--

1528
01:15:49,620 --> 01:15:53,430
функція, яка поставляється з C, але це
робить саме те, що ви хочете, щоб це зробити.

1529
01:15:53,430 --> 01:15:55,295
І, чесно кажучи, навіть якщо
він не прийшов з C,

1530
01:15:55,295 --> 01:15:58,880
ви могли б реалізувати його самостійно, так як
ми вже бачили, з Int отримаєте негативний результат

1531
01:15:58,880 --> 01:16:01,700
і отримати позитивний INT минулого тижня.

1532
01:16:01,700 --> 01:16:03,470
>> Цей код в даний час набагато більш зручним для читання.

1533
01:16:03,470 --> 01:16:06,670
І дійсно, якщо ми прокрутки вгору,
Подивіться, наскільки більш компактний

1534
01:16:06,670 --> 01:16:08,360
ця версія моєї програми.

1535
01:16:08,360 --> 01:16:11,230
Це трохи громіздкою зараз,
з усіма цими включає в себе.

1536
01:16:11,230 --> 01:16:14,380
Але це нормально, тому що тепер я стою
на плечі програмістів

1537
01:16:14,380 --> 01:16:15,300
перед мною.

1538
01:16:15,300 --> 01:16:18,440
І хто б це не був, хто
реалізовані у верхній дійсно

1539
01:16:18,440 --> 01:16:21,470
зробив мені послугу, так само, як той, хто
реалізований Стірлінга дійсно

1540
01:16:21,470 --> 01:16:24,790
зробив мені послугу деякий час назад.

1541
01:16:24,790 --> 01:16:26,970
І ось тепер у нас є
краще дизайн програми

1542
01:16:26,970 --> 01:16:31,680
який реалізує ту ж саму логіку.

1543
01:16:31,680 --> 01:16:35,580
>> Говорячи про Стерлінга, нехай
мені йти вперед і робити це.

1544
01:16:35,580 --> 01:16:38,320
Дозвольте мені йти вперед і зберегти
цей файл в якості stirling.c.

1545
01:16:38,320 --> 01:16:43,255
І виходить, ми можемо відігніть
один інший шар досить просто прямо зараз.

1546
01:16:43,255 --> 01:16:45,630
Я збираюся йти вперед і батіг
до іншої програми в головному

1547
01:16:45,630 --> 01:16:49,759
тут просто повторно знаряддя
довжина рядка наступним чином.

1548
01:16:49,759 --> 01:16:52,300
Так ось рядок коду, яка
отримує мене рядок від користувача.

1549
01:16:52,300 --> 01:16:53,910
Ми продовжуємо використовувати це знову і знову.

1550
01:16:53,910 --> 01:16:58,900
Дозвольте мені дати собі змінну
п типу Int, який зберігає номер.

1551
01:16:58,900 --> 01:17:02,490
>> І дозвольте мені йти вперед і
зробити таку логіку.

1552
01:17:02,490 --> 01:17:15,610
У той час як п-й символ в S робить
НЕ дорівнює 0 зворотної косої межі, йти вперед

1553
01:17:15,610 --> 01:17:17,930
і приріст п.

1554
01:17:17,930 --> 01:17:23,506
І потім роздрукувати Printf відсотка I N.

1555
01:17:23,506 --> 01:17:29,200
Я стверджую, що ця програма тут,
без виклику довжини рядка,

1556
01:17:29,200 --> 01:17:31,150
з'ясовує довжину рядка.

1557
01:17:31,150 --> 01:17:34,600
>> І магія повністю
втілений в рядку 8

1558
01:17:34,600 --> 01:17:39,830
ось із чим виглядає як новий синтаксис,
це зворотний слеш 0 в одинарні лапки.

1559
01:17:39,830 --> 01:17:41,360
Але чому?

1560
01:17:41,360 --> 01:17:44,100
Ну, подумайте, що було
відбувається весь цей час.

1561
01:17:44,100 --> 01:17:47,990
>> І, як в сторону, перш ніж я забув, розумію,
також, що на додаток до людини сторінок

1562
01:17:47,990 --> 01:17:50,920
які приходять з типовим
Система Linux як CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
розуміти, що ми,
Персонал звичайно, в є також

1564
01:17:53,770 --> 01:17:56,030
зробив версію сайту
цієї ж ідеї під назвою

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, яка має
всі ті ж людино-сторінок,

1566
01:17:59,940 --> 01:18:02,020
все той же
документації, а також

1567
01:18:02,020 --> 01:18:05,730
маленька коробочка у верхній частині, що дозволяє
конвертувати всі з досить

1568
01:18:05,730 --> 01:18:09,025
аркан мову в менш комфортно
режим, в якому ми, викладацький склад,

1569
01:18:09,025 --> 01:18:12,150
пройшли і спробував спростити
частина мови, щоб тримати речі

1570
01:18:12,150 --> 01:18:14,830
зосереджені на ідеях, а не
деякі тонкощі.

1571
01:18:14,830 --> 01:18:20,070
Так що майте на увазі, reference.cs50.net
в якості ще одного ресурсу, а також.

1572
01:18:20,070 --> 01:18:23,800
>> Але чому довжина рядка в роботу
як я запропонував кілька хвилин тому?

1573
01:18:23,800 --> 01:18:25,160
Ось ім'я Zamyla знову.

1574
01:18:25,160 --> 01:18:27,690
А ось ім'я Zamyla в
затиснуті в, як я продовжувати робити,

1575
01:18:27,690 --> 01:18:31,360
щоб намалювати картину його буття,
насправді, просто послідовність символів.

1576
01:18:31,360 --> 01:18:34,260
Але Zamyla не існує
в ізоляції в програмі.

1577
01:18:34,260 --> 01:18:37,420
>> Коли ви пишете і запустити програму,
ви використовуєте ваш Mac або ПК

1578
01:18:37,420 --> 01:18:40,010
як пам'ять, або RAM, так би мовити.

1579
01:18:40,010 --> 01:18:42,620
І ви можете думати про
ваш комп'ютер як має

1580
01:18:42,620 --> 01:18:44,730
багато гігабайт пам'яті в ці дні.

1581
01:18:44,730 --> 01:18:47,700
І гіг означає мільярди,
тому мільярди байт.

1582
01:18:47,700 --> 01:18:48,910
>> Але давайте перемотувати в часі.

1583
01:18:48,910 --> 01:18:51,530
І припустимо, що ми використовуємо
дуже старий комп'ютер,

1584
01:18:51,530 --> 01:18:55,150
має тільки 32 байта пам'яті.

1585
01:18:55,150 --> 01:18:59,310
Я міг би, на екрані комп'ютера,
просто звернути на це наступним чином.

1586
01:18:59,310 --> 01:19:05,240
>> Я міг би просто сказати, що мій
Комп'ютер має вся ця пам'ять.

1587
01:19:05,240 --> 01:19:08,830
І це, як палиця пам'яті, якщо
Ви пам'ятаєте нашу картину минулого разу.

1588
01:19:08,830 --> 01:19:11,670
А якщо я просто розділити
це стільки разів,

1589
01:19:11,670 --> 01:19:15,040
Я стверджую, що у мене є 32 байта
пам'яті на екрані.

1590
01:19:15,040 --> 01:19:18,239
>> Тепер, насправді, я можу тільки
малювати досі на цьому екрані тут.

1591
01:19:18,239 --> 01:19:20,280
Так що я збираюся йти вперед,
і тільки за згодою,

1592
01:19:20,280 --> 01:19:24,050
малювати пам'яті мого комп'ютера в якості
сітки, а не тільки як одна пряма лінія.

1593
01:19:24,050 --> 01:19:28,190
Зокрема, я стверджую, що в даний час
ця сітка, це 8 по 4 сітки,

1594
01:19:28,190 --> 01:19:31,800
просто представляє всі 32 байта
доступної пам'яті в моєму Mac,

1595
01:19:31,800 --> 01:19:33,030
або доступні в моєму комп'ютері.

1596
01:19:33,030 --> 01:19:34,780
І вони обгортковий
на дві лінії, просто

1597
01:19:34,780 --> 01:19:38,030
так як він підходить більше на екрані.

1598
01:19:38,030 --> 01:19:40,800
Але це перший байт.

1599
01:19:40,800 --> 01:19:41,990
Це другий байт.

1600
01:19:41,990 --> 01:19:43,300
Це третій байт.

1601
01:19:43,300 --> 01:19:45,310
>> І це 32-й байт.

1602
01:19:45,310 --> 01:19:52,910
Або, якщо ми думаємо, як комп'ютер
вчений, це байт 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Так що у вас є від 0 до 31, якщо
Ви починаєте відлік з 0.

1604
01:19:55,950 --> 01:19:59,830
>> Так що, якщо ми використовуємо програму
що дзвінки отримати рядок,

1605
01:19:59,830 --> 01:20:05,280
і ми отримуємо рядок з людського
як я назвав Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
як в світі робить
комп'ютер відслідковувати, який байт,

1607
01:20:09,430 --> 01:20:12,230
який шматок пам'яті,
належить який рядок?

1608
01:20:12,230 --> 01:20:16,270
Іншими словами, якщо ми переходимо до
введіть інше ім'я в комп'ютер,

1609
01:20:16,270 --> 01:20:19,890
як цей Andi, називаючи
отримати рядок вдруге,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-я повинен закінчити в
пам'ять комп'ютера, а також.

1611
01:20:23,030 --> 01:20:23,850
Але як?

1612
01:20:23,850 --> 01:20:29,700
>> Що ж, виходить, що під
капот, то, що C робить при зберіганні рядків

1613
01:20:29,700 --> 01:20:35,080
що людські типи в, або що
походять з будь-якого іншого джерела, є його

1614
01:20:35,080 --> 01:20:39,190
окреслює кінець їх з
спеціальний character-- зворотної косої межі

1615
01:20:39,190 --> 01:20:44,750
0, що це просто особливий спосіб
сказати 80 біт поспіль.

1616
01:20:44,750 --> 01:20:47,950
>> Так A-- це число 97 відгук.

1617
01:20:47,950 --> 01:20:51,770
Таким чином, деякі моделі з 8 бітів
представляє десяткове число 97.

1618
01:20:51,770 --> 01:20:58,070
Цей зворотний слеш 0 буквально число
0, а.к.а. NUL, N-U-L, на відміну від раніше,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, який ми говорили.

1620
01:20:59,630 --> 01:21:05,700
Але зараз, просто знаю, що це
зворотна коса 0 всього 80 біт поспіль.

1621
01:21:05,700 --> 01:21:09,810
>> І це як раз цей рядок в
пісок, який говорить, що нічого зліва

1622
01:21:09,810 --> 01:21:12,610
належить до одного рядка або одного типу даних.

1623
01:21:12,610 --> 01:21:15,480
І нічого вправо
належить до чогось ще.

1624
01:21:15,480 --> 01:21:17,440
найменування Andi, тим часом,
який тільки візуально

1625
01:21:17,440 --> 01:21:21,310
трапляється, щоб обернути на іншій лінії,
але це тільки естетична деталь,

1626
01:21:21,310 --> 01:21:23,990
Аналогічним чином завершується NUL.

1627
01:21:23,990 --> 01:21:29,290
>> Це струна символів A-N-D-I,
плюс п'ятий секретний характер,

1628
01:21:29,290 --> 01:21:33,560
всі 0 біти, які просто розмежовує
кінець імені Andi, а також.

1629
01:21:33,560 --> 01:21:37,120
І якщо ми називаємо отримати рядок в третій раз
в комп'ютері, щоб отримати рядок виду

1630
01:21:37,120 --> 01:21:44,210
Марія, М-А-Р-I-А, так само є Марії
Ім'я NUL завершується з зворотною косою межею 0.

1631
01:21:44,210 --> 01:21:47,170
>> Це принципово відрізняється
від того, як комп'ютер, як правило,

1632
01:21:47,170 --> 01:21:51,850
зберігати ціле число або число з плаваючою точкою, або інший
типи даних до сих пір, тому що згадати,

1633
01:21:51,850 --> 01:21:57,420
ціле число, як правило, 32 біта, або
4 байта, або можливо навіть 64 біта,

1634
01:21:57,420 --> 01:21:59,100
або вісім байт.

1635
01:21:59,100 --> 01:22:02,620
Але багато примітиви в комп'ютері
на мові програмування

1636
01:22:02,620 --> 01:22:05,550
мають фіксоване число
байт під hood--

1637
01:22:05,550 --> 01:22:08,100
може бути 1, 2, може бути, може бути 4, може бути 8.

1638
01:22:08,100 --> 01:22:13,250
>> Але рядки, по дизайну, мають
динамічне кількість символів.

1639
01:22:13,250 --> 01:22:16,980
Ви ніколи не знаєте заздалегідь, до тих пір,
людські типи в Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
або М-А-Р-І-А або А-Н-Д-І. Ви не знаєте,
скільки разів користувач збирається вдарити

1641
01:22:21,400 --> 01:22:22,070
клавіатура.

1642
01:22:22,070 --> 01:22:26,490
Таким чином, ви не знаєте, як
багато символів в заздалегідь

1643
01:22:26,490 --> 01:22:27,540
ви будете потребувати.

1644
01:22:27,540 --> 01:22:31,840
>> І так З просто вид листя, як у
секрет крихта під капотом

1645
01:22:31,840 --> 01:22:32,960
в кінці рядка.

1646
01:22:32,960 --> 01:22:39,280
Після зберігання Z-А-М-Y-L-A в пам'яті,
він також просто ставить еквівалент

1647
01:22:39,280 --> 01:22:40,210
протягом періоду.

1648
01:22:40,210 --> 01:22:45,060
В кінці речення,
він поміщає 80 біт, таким чином,

1649
01:22:45,060 --> 01:22:49,120
щоб згадати, де
Zamyla починається і закінчується.

1650
01:22:49,120 --> 01:22:51,490
>> Так що зв'язок,
Потім, до цієї програми?

1651
01:22:51,490 --> 01:22:55,190
Ця програма тут, Стірлінга,
це просто механізм

1652
01:22:55,190 --> 01:22:57,970
для отримання рядка
від користувача, рядок 6.

1653
01:22:57,970 --> 01:23:01,160
Рядок 7, я оголосити змінну
називається п і встановіть його рівним 0.

1654
01:23:01,160 --> 01:23:08,680
>> А потім в рядку 8, я просто запитав
питання, в той час як п-й символ робить

1655
01:23:08,680 --> 01:23:12,120
нерівні 0 все bits--
іншими словами, не робить

1656
01:23:12,120 --> 01:23:14,500
одно цей спеціальний
символ, зворотна коса 0,

1657
01:23:14,500 --> 01:23:18,470
був тільки що спеціальний NUL character--
йти вперед і просто збільшувати п.

1658
01:23:18,470 --> 01:23:21,460
>> І продовжувати робити це, і тримати
роблячи це, і продовжувати робити це.

1659
01:23:21,460 --> 01:23:23,430
І тому, навіть якщо в
минуле ми використовували I,

1660
01:23:23,430 --> 01:23:25,181
це прекрасно
семантично використовувати п,

1661
01:23:25,181 --> 01:23:27,430
якщо ви просто намагаєтеся
розраховувати на цей раз свідомо,

1662
01:23:27,430 --> 01:23:28,720
і просто хочете назвати це н.

1663
01:23:28,720 --> 01:23:34,720
Так що це просто продовжує задавати питання,
є н-ий символ з всі 0s?

1664
01:23:34,720 --> 01:23:38,470
Якщо немає, подивіться на наступний вигляд,
подивіться на наступний, подивіться на наступний,

1665
01:23:38,470 --> 01:23:39,460
подивіться на наступний.

1666
01:23:39,460 --> 01:23:45,540
>> Але як тільки ви бачите зворотну косу 0,
це loop-- лінія 9 через 11-- зупиняється.

1667
01:23:45,540 --> 01:23:49,640
Ви вирватися з циклу в той час,
залишаючи всередині цієї змінної п

1668
01:23:49,640 --> 01:23:54,530
в цілому кількість всіх з
символів в рядку, яку ви бачили,

1669
01:23:54,530 --> 01:23:55,660
таким чином, виведення на друк.

1670
01:23:55,660 --> 01:23:56,760
Так давайте спробуємо це.

1671
01:23:56,760 --> 01:23:59,500
>> Дозвольте мені йти вперед і без
за допомогою функції Стірлінга,

1672
01:23:59,500 --> 01:24:04,240
а просто використовуючи свою власну версію доморощені
тут називається Стірлінга, дозвольте мені йти вперед

1673
01:24:04,240 --> 01:24:07,700
і запустити Стірлінга, типу в чомусь
як Zamyla, який я знаю наперед

1674
01:24:07,700 --> 01:24:08,670
становить шість символів.

1675
01:24:08,670 --> 01:24:10,080
Давайте подивимося, чи працює він.

1676
01:24:10,080 --> 01:24:10,920
Справді, це шість.

1677
01:24:10,920 --> 01:24:15,257
Давайте спробуємо з Робом, три символу,
три символи, а також, і так далі.

1678
01:24:15,257 --> 01:24:17,340
Так що все, що відбувається
на під капотом.

1679
01:24:17,340 --> 01:24:19,548
І зверніть увагу, з'єднання,
потім, починаючи з першого тижня

1680
01:24:19,548 --> 01:24:22,370
класу, де ми говорили про
щось на зразок абстракції,

1681
01:24:22,370 --> 01:24:26,960
що саме це нашарування ідей, або
складність, на вершині основних принципів.

1682
01:24:26,960 --> 01:24:30,710
Тут ми начебто дивитися
під капотом Стерлінга,

1683
01:24:30,710 --> 01:24:33,510
так би мовити, щоб з'ясувати,
як би це реалізувати?

1684
01:24:33,510 --> 01:24:35,232
>> І ми могли б повторно реалізувати його самі.

1685
01:24:35,232 --> 01:24:37,440
Але ми ніколи знову збирається
повторно реалізувати Стірлінга.

1686
01:24:37,440 --> 01:24:39,780
Ми просто збираємося
використовувати Стірлінга в порядку

1687
01:24:39,780 --> 01:24:42,100
насправді отримати деякі рядки довжини.

1688
01:24:42,100 --> 01:24:44,200
>> Але немає ніякої магії
під капотом.

1689
01:24:44,200 --> 01:24:46,716
Якщо ви знаєте, що під
капот, рядок

1690
01:24:46,716 --> 01:24:48,090
це просто послідовність символів.

1691
01:24:48,090 --> 01:24:51,090
І це послідовність символів
всі вони можуть бути чисельно розглянуті

1692
01:24:51,090 --> 01:24:53,330
з кронштейном 0, кронштейн
1, кронштейн 2, і ви

1693
01:24:53,330 --> 01:24:57,420
відомо, що в кінці рядка є
спеціальний символ, ви можете з'ясувати,

1694
01:24:57,420 --> 01:25:01,710
як зробити більшість нічого в
Програма, тому що все це зводиться до того,

1695
01:25:01,710 --> 01:25:03,400
читає і пише пам'ять.

1696
01:25:03,400 --> 01:25:06,130
Тобто, змінюється і шукає
в пам'яті, або переміщення речей

1697
01:25:06,130 --> 01:25:10,940
навколо в пам'яті, друковані речі
на екрані, і так далі.

1698
01:25:10,940 --> 01:25:14,800
>> Так давайте тепер використовувати цю новознайдену
розуміння того, які рядки насправді

1699
01:25:14,800 --> 01:25:17,910
знаходяться під капотом, і
відігніть один інший шар

1700
01:25:17,910 --> 01:25:20,080
що до сих пір ми
ігнорував в цілому.

1701
01:25:20,080 --> 01:25:22,650
Зокрема, будь-який час
ми реалізували програму,

1702
01:25:22,650 --> 01:25:25,930
ми мали цей рядок коду
поблизу верхньої оголошуючи головною.

1703
01:25:25,930 --> 01:25:27,810
І ми вказали INT головну порожнечу.

1704
01:25:27,810 --> 01:25:31,240
>> І ця порожнеча всередині дужок
говорив весь цей час, що основна

1705
01:25:31,240 --> 01:25:33,440
сама по собі не приймає жодних аргументів.

1706
01:25:33,440 --> 01:25:36,210
Будь внесок, що головне,
збирається отримати від користувача

1707
01:25:36,210 --> 01:25:39,020
повинна виходити від якоїсь іншої
механізм, як Get INT,

1708
01:25:39,020 --> 01:25:42,040
або отримати з плаваючою точкою, або отримати рядок,
або будь-якої іншої функції.

1709
01:25:42,040 --> 01:25:44,710
Але виявляється, що
коли ви пишете програму,

1710
01:25:44,710 --> 01:25:47,690
ви можете вказати
що ця програма повинна

1711
01:25:47,690 --> 01:25:51,730
приймають вхідні сигнали від людини
в самій командному рядку.

1712
01:25:51,730 --> 01:25:56,310
>> Іншими словами, навіть якщо ми до сих пір
були працює тільки ./hello привіт

1713
01:25:56,310 --> 01:26:00,312
або аналогічні програми, все
інші програми, які ми використовували,

1714
01:26:00,312 --> 01:26:02,770
що ми самі не писали,
приймали, мабуть,

1715
01:26:02,770 --> 01:26:05,210
командного рядка arguments--
такі речі, як зробити.

1716
01:26:05,210 --> 01:26:07,450
Ви говорите, що щось на зразок марка,
а потім друге слово.

1717
01:26:07,450 --> 01:26:10,950
Або брязкіт, ви говорите брязкіт, а потім
друге слово, ім'я файлу.

1718
01:26:10,950 --> 01:26:14,410
>> Або навіть RM або СР, як можна було б
бачили або використовувати вже

1719
01:26:14,410 --> 01:26:15,880
видаляти або копіювати файли.

1720
01:26:15,880 --> 01:26:18,920
Всі ті приймають так звані
командного рядка arguments--

1721
01:26:18,920 --> 01:26:21,130
додаткові слова в рядку терміналу.

1722
01:26:21,130 --> 01:26:23,260
Але до сих пір, ми
самі не мали

1723
01:26:23,260 --> 01:26:27,080
Цей розкішний приймати вхідний сигнал від
користувача, коли він або вона насправді працює

1724
01:26:27,080 --> 01:26:29,120
сама програма в командному рядку.

1725
01:26:29,120 --> 01:26:33,710
>> Але ми можемо зробити це шляхом повторного декларування
Основний рухатися вперед, а не як такі, що

1726
01:26:33,710 --> 01:26:36,750
недійсним в дужках,
але ці два аргументи

1727
01:26:36,750 --> 01:26:40,600
instead-- перший ціле число,
а другий щось

1728
01:26:40,600 --> 01:26:44,170
нове, то, що ми будемо називати
масив, щось подібне в дусі

1729
01:26:44,170 --> 01:26:49,220
до того, що ми бачили в порожньому вигляді списку, але
масив рядків, як ми скоро побачимо.

1730
01:26:49,220 --> 01:26:51,790
Але давайте подивимося на це
Як приклад, перш ніж ми

1731
01:26:51,790 --> 01:26:53,690
розрізняють саме те, що це означає.

1732
01:26:53,690 --> 01:26:56,520
>> Так що, якщо я йду в CS50 IDE
тут, я пішов вперед

1733
01:26:56,520 --> 01:27:01,840
і оголошений у файлі з ім'ям
argv0.c наступний шаблон.

1734
01:27:01,840 --> 01:27:04,120
І зауважте, єдине,
що по-іншому до сих пір

1735
01:27:04,120 --> 01:27:08,570
є те, що я змінив нікчемним Int
ARGC рядок ARGV відкритий кронштейн, близько

1736
01:27:08,570 --> 01:27:09,070
кронштейн.

1737
01:27:09,070 --> 01:27:11,730
І зверніть увагу на даний момент, є
нічого не всередині цих дужок.

1738
01:27:11,730 --> 01:27:12,620
>> Там немає числа.

1739
01:27:12,620 --> 01:27:15,070
І немає я, або
N, або будь-який інший лист.

1740
01:27:15,070 --> 01:27:17,010
Я просто за допомогою
квадратні дужки на даний момент,

1741
01:27:17,010 --> 01:27:19,510
з причин, ми приїдемо
назад в мить.

1742
01:27:19,510 --> 01:27:21,330
>> А тепер, що я збираюся зробити це.

1743
01:27:21,330 --> 01:27:26,680
Якщо ARGC дорівнює дорівнює 2--
і нагадаємо, що дорівнює рівних

1744
01:27:26,680 --> 01:27:30,040
є оператором порівняння рівності
лівий і правий для рівності.

1745
01:27:30,040 --> 01:27:31,790
Це не поступка
оператор, який

1746
01:27:31,790 --> 01:27:36,510
єдиний знак рівності, що означає копію
від справа наліво якесь значення.

1747
01:27:36,510 --> 01:27:42,840
>> Якщо ARGC дорівнює дорівнює 2, я хочу
скажімо, Printf, привіт, відсотки, нова лінія,

1748
01:27:42,840 --> 01:27:47,340
а потім підключити in-- і ось новий
trick-- ARGV кронштейн 1, з причин

1749
01:27:47,340 --> 01:27:48,840
що ми повернемося в хвилину.

1750
01:27:48,840 --> 01:27:52,110
Інакше, якщо ARGC НЕ
дорівнює 2, ви знаєте, що?

1751
01:27:52,110 --> 01:27:57,400
Давайте просто йти вперед і, як зазвичай, друк
поза привіт світ, без заміни.

1752
01:27:57,400 --> 01:28:02,710
>> Так що, здавалося б, що якщо ARGC, який
виступає за кількістю аргументів, дорівнює 2,

1753
01:28:02,710 --> 01:28:04,740
Я збираюся роздрукувати
привіт щось або інше.

1754
01:28:04,740 --> 01:28:07,560
В іншому випадку, за замовчуванням, я
збирається надрукувати привіт світ.

1755
01:28:07,560 --> 01:28:08,770
Так що ж це означає?

1756
01:28:08,770 --> 01:28:15,550
>> Що ж, дозвольте мені йти вперед і зберегти
цей файл, а потім роблять argv0,

1757
01:28:15,550 --> 01:28:18,940
а потім ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
І це говорить привіт світ.

1759
01:28:20,300 --> 01:28:21,260
Тепер, чому це?

1760
01:28:21,260 --> 01:28:24,730
>> Що ж, виходить, в будь-який час ви
запустити програму в командному рядку,

1761
01:28:24,730 --> 01:28:29,570
ви заповнюєте в тому, що ми будемо
зазвичай називаємо вектор аргументів.

1762
01:28:29,570 --> 01:28:33,100
Іншими словами, автоматично
комп'ютер, операційна система,

1763
01:28:33,100 --> 01:28:38,340
збирається передати вашій програмі
Сам список всіх слів

1764
01:28:38,340 --> 01:28:40,850
що людина набрав на
підказка, в разі, якщо

1765
01:28:40,850 --> 01:28:43,790
програміст хоче зробити
щось з цією інформацією.

1766
01:28:43,790 --> 01:28:48,540
І в цьому випадку єдине слово,
Я набрав у рядку є ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> І тому число аргументів, є
передається в моїй програмі тільки один.

1768
01:28:55,420 --> 01:28:58,880
Іншими словами, аргумент
розраховувати, інакше відомий як ARGC

1769
01:28:58,880 --> 01:29:00,970
тут як ціле число, це лише один.

1770
01:29:00,970 --> 01:29:03,000
Один з них, звичайно, не дорівнює двом.

1771
01:29:03,000 --> 01:29:05,980
І так це те, що друкує, привіт світ.

1772
01:29:05,980 --> 01:29:08,170
>> Але дозвольте мені взяти це десь.

1773
01:29:08,170 --> 01:29:09,930
Дозвольте мені сказати, argv0.

1774
01:29:09,930 --> 01:29:12,740
А потім, як про Марію?

1775
01:29:12,740 --> 01:29:14,990
А потім натисніть клавішу Enter.

1776
01:29:14,990 --> 01:29:18,020
>> І зверніть увагу, що чарівним чином тут відбувається.

1777
01:29:18,020 --> 01:29:22,640
Тепер, замість привіт світ, у мене є
змінив поведінку цієї програми

1778
01:29:22,640 --> 01:29:26,310
приймаючи вхід немає від Get
рядок або будь-якої іншої функції,

1779
01:29:26,310 --> 01:29:30,570
але з, мабуть, моя команда
Сам, що я спочатку надрукував.

1780
01:29:30,570 --> 01:29:35,720
І я можу грати в цю гру знову
змінюючи його Стеліос, наприклад.

1781
01:29:35,720 --> 01:29:38,400
>> А тепер я бачу інше ім'я досі.

1782
01:29:38,400 --> 01:29:40,540
І тут, я міг би сказати, Анді.

1783
01:29:40,540 --> 01:29:42,137
І я міг би сказати Zamyla.

1784
01:29:42,137 --> 01:29:45,220
І ми можемо грати в цю гру протягом всього дня,
просто затикати в різних значеннях,

1785
01:29:45,220 --> 01:29:49,550
до тих пір, як я надати саме
два слова в командному рядку

1786
01:29:49,550 --> 01:29:52,260
таким чином, що ARGC, граф мій аргумент, 2.

1787
01:29:52,260 --> 01:29:57,240
>> Бачу я, що ім'я підключений до
Printf, в цьому стані тут?

1788
01:29:57,240 --> 01:30:00,550
Таким чином, ми, здається, в даний час
виразний потенціал

1789
01:30:00,550 --> 01:30:04,410
приймати вхідний сигнал від іншого механізму,
від так званої командного рядка,

1790
01:30:04,410 --> 01:30:07,000
замість того, щоб чекати
до тих пір, поки користувач не запускає програму,

1791
01:30:07,000 --> 01:30:10,220
а потім спонукати його або її
використовуючи щось на зразок отримання рядка.

1792
01:30:10,220 --> 01:30:11,230
>> Так що ж це?

1793
01:30:11,230 --> 01:30:15,010
ARGC, знову ж таки, це всього лише ціле число,
кількість words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
що користувач за умови, на
підкажіть, у вікні терміналу,

1795
01:30:18,540 --> 01:30:20,110
в тому числі назва програми.

1796
01:30:20,110 --> 01:30:23,340
Таким чином, наша ./argv0 є, по суті,
назва програми,

1797
01:30:23,340 --> 01:30:24,520
або як я запустити програму.

1798
01:30:24,520 --> 01:30:25,810
>> Це вважається як слово.

1799
01:30:25,810 --> 01:30:27,080
Так ARGC буде 1.

1800
01:30:27,080 --> 01:30:29,750
Але коли я пишу Стеліос, або
Andi або Zamyla, або Марія,

1801
01:30:29,750 --> 01:30:31,660
це означає, що кількість аргументів дорівнює двом.

1802
01:30:31,660 --> 01:30:33,910
І ось тепер є два слова, які передаються в.

1803
01:30:33,910 --> 01:30:36,070
>> І зауважте, ми можемо продовжити цю логіку.

1804
01:30:36,070 --> 01:30:39,050
Якби я насправді сказати
щось на зразок Zamyla Чан,

1805
01:30:39,050 --> 01:30:42,200
повне ім'я, тим самим передавши
три аргументи в цілому,

1806
01:30:42,200 --> 01:30:47,410
Тепер він знову говорить за замовчуванням,
тому що, звичайно ж, 3 не дорівнює 2.

1807
01:30:47,410 --> 01:30:54,080
>> І ось таким чином, у мене є
доступ через ARGV цей новий аргумент

1808
01:30:54,080 --> 01:30:56,080
що ми могли б технічно
називати все, що завгодно.

1809
01:30:56,080 --> 01:30:58,940
Але відповідно до угоди, це
ARGV і ARGC відповідно.

1810
01:30:58,940 --> 01:31:04,470
ARGV, вектор аргументів, є свого роду
синоніма для програмування

1811
01:31:04,470 --> 01:31:07,140
функція в C називається масив.

1812
01:31:07,140 --> 01:31:14,410
>> Масив являє список значень аналогічних
тому, до спини, до спини, до спини.

1813
01:31:14,410 --> 01:31:17,810
Іншими словами, якщо хтось тут, в
RAM, наступний прямо поруч з ним,

1814
01:31:17,810 --> 01:31:18,800
і поряд з ним.

1815
01:31:18,800 --> 01:31:20,101
Вони не всюди.

1816
01:31:20,101 --> 01:31:23,100
І це останній сценарій, де речі
знаходяться всюди в пам'яті,

1817
01:31:23,100 --> 01:31:25,082
може бути насправді потужна функція.

1818
01:31:25,082 --> 01:31:28,040
Але ми повернемося до того, що, коли ми
говорити про химерних структур даних.

1819
01:31:28,040 --> 01:31:32,260
На даний момент, масив просто
шматок безперервної пам'яті,

1820
01:31:32,260 --> 01:31:36,520
кожен з яких елементи
тому, до спини, до спини, до спини,

1821
01:31:36,520 --> 01:31:38,050
і, як правило той же самий тип.

1822
01:31:38,050 --> 01:31:42,630
>> Так що якщо ви думаєте про те, від А
хвилину тому, що таке рядок?

1823
01:31:42,630 --> 01:31:50,460
Ну, рядок, як Zamyla,
Z-А-М-У-Л-А, це, технічно,

1824
01:31:50,460 --> 01:31:51,400
просто масив.

1825
01:31:51,400 --> 01:31:53,700
Це масив символів.

1826
01:31:53,700 --> 01:31:59,250
>> І тому, якщо ми дійсно зробити це, як я
зробив раніше, як шматок пам'яті,

1827
01:31:59,250 --> 01:32:04,510
виходить, що кожен з них
символів займає байт.

1828
01:32:04,510 --> 01:32:07,630
А тут що особливу
сторожового символ, зворотна коса 0,

1829
01:32:07,630 --> 01:32:12,360
або всі вісім біт 0, що
розмежовує кінець цього рядка.

1830
01:32:12,360 --> 01:32:15,090
Так рядок, виходить
поза, цитують Unquote рядок,

1831
01:32:15,090 --> 01:32:20,580
це просто масив chara--
обвуглюється будучи фактичним типом даних.

1832
01:32:20,580 --> 01:32:24,560
>> А тепер ARGV, meanwhile--
давайте повернемося до програми.

1833
01:32:24,560 --> 01:32:29,582
ARGV, хоча ми бачимо, слово
Рядок тут, не є сама рядок.

1834
01:32:29,582 --> 01:32:33,640
ARGV, вектор аргументів,
являє собою масив рядків.

1835
01:32:33,640 --> 01:32:37,620
>> Так само, як ви можете мати масив
символів, ви можете мати більш високий рівень,

1836
01:32:37,620 --> 01:32:46,279
масив strings-- так, наприклад,
коли я набрав хвилину назад ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, простір Z-A-M-Y-L-A, я стверджував, що
ARGV мав два рядки в it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
і Z-A-M-Y-L-A. в
Іншими словами, ARGC було 2.

1839
01:33:03,185 --> 01:33:03,980
Чому так?

1840
01:33:03,980 --> 01:33:08,370
>> Ну, по суті, те, що відбувається
на те, що кожна з цих рядків

1841
01:33:08,370 --> 01:33:13,990
це, звичайно, масив символів
як і раніше, кожен з яких персонажі

1842
01:33:13,990 --> 01:33:15,670
займає один байт.

1843
01:33:15,670 --> 01:33:19,720
І не плутайте фактичну 0
в назві програми з 0,

1844
01:33:19,720 --> 01:33:22,040
що означає все 80 біт.

1845
01:33:22,040 --> 01:33:27,140
І Zamyla, тим часом, як і раніше
також масив символів.

1846
01:33:27,140 --> 01:33:31,450
>> Таким чином, в кінці кінців, це насправді
виглядає наступним чином під капотом.

1847
01:33:31,450 --> 01:33:38,800
Але ARGV, за своєю природою, як головний
роботи, дозволяє мені обернути все це

1848
01:33:38,800 --> 01:33:44,810
до в, якщо ви будете, більший масив
що, якщо ми трохи більше спростити

1849
01:33:44,810 --> 01:33:48,180
що картина виглядає і не
досить намалювати її в масштабі там,

1850
01:33:48,180 --> 01:33:56,720
Цей масив є тільки розміром 2, перший
елемент якого містить рядок,

1851
01:33:56,720 --> 01:33:59,230
другий елемент
яка містить рядок.

1852
01:33:59,230 --> 01:34:01,687
І, в свою чергу, якщо ви
вид збільшення на кожному

1853
01:34:01,687 --> 01:34:03,770
з цих рядків, що ви
см під капотом

1854
01:34:03,770 --> 01:34:07,190
є те, що кожен рядок просто
масив символів.

1855
01:34:07,190 --> 01:34:11,680
>> Тепер, так само, як з рядками,
ми були в змозі отримати доступ

1856
01:34:11,680 --> 01:34:15,260
до г-го символу в рядку
за допомогою цієї квадратної дужки позначення.

1857
01:34:15,260 --> 01:34:17,320
Точно так же, з масивами
в загальному, ми можемо

1858
01:34:17,320 --> 01:34:22,700
використовувати квадратні дужки, позначення, щоб отримати
на будь-яку кількість рядків в масиві?

1859
01:34:22,700 --> 01:34:25,100
Наприклад, дозвольте мені
йти вперед і робити це.

1860
01:34:25,100 --> 01:34:32,420
>> Дозвольте мені йти вперед і створити argv1.c,
який трохи відрізняється на цей раз.

1861
01:34:32,420 --> 01:34:35,635
Замість перевірки для argc2,
Я буду замість цього.

1862
01:34:35,635 --> 01:34:41,270
Для інт я отримую 0, я менше
ніж ARGC, я плюс плюс,

1863
01:34:41,270 --> 01:34:47,920
а потім роздрукувати всередині цього,
відсотків s, нова лінія, а потім

1864
01:34:47,920 --> 01:34:50,740
ARGV кронштейн я.

1865
01:34:50,740 --> 01:34:55,220
>> Отже, іншими словами, я не маємо справу з
окремі символи в даний момент.

1866
01:34:55,220 --> 01:35:00,190
ARGV, як випливає з цих порожній квадрат
брекет одразу після назви ARGV,

1867
01:35:00,190 --> 01:35:03,320
означає ARGV масив рядків.

1868
01:35:03,320 --> 01:35:04,870
І ARGC це просто інт.

1869
01:35:04,870 --> 01:35:08,800
>> Ця лінія тут, 6, є
кажучи набір я рівним 0.

1870
01:35:08,800 --> 01:35:11,980
Граф весь шлях до,
але не включаючи, ARGC.

1871
01:35:11,980 --> 01:35:14,010
І потім на кожній ітерації,
роздрукувати рядок.

1872
01:35:14,010 --> 01:35:14,800
Яка рядок?

1873
01:35:14,800 --> 01:35:17,270
>> I-го рядка в ARGV.

1874
01:35:17,270 --> 01:35:19,530
Так що в той час, перш ніж я був
використовуючи квадратні дужки

1875
01:35:19,530 --> 01:35:22,180
позначення, щоб отримати в пана й
символ в рядку, тепер

1876
01:35:22,180 --> 01:35:27,240
Я використовую квадратні дужки, позначення
щоб отримати в рядку й у масиві.

1877
01:35:27,240 --> 01:35:30,310
Так що це свого роду один шар
вище, концептуально.

1878
01:35:30,310 --> 01:35:35,390
>> Так що акуратним про це
Програма тепер, якщо я компілює argv1,

1879
01:35:35,390 --> 01:35:42,067
а потім зробити ./argv1, а потім введіть
в чимось на зразок бару Baz Foo,

1880
01:35:42,067 --> 01:35:45,400
які є три стандартні слова, які
вчений досягає протягом будь-якого часу

1881
01:35:45,400 --> 01:35:51,010
він або вона потребує деяких шаблонні слова,
і натисніть Enter, кожне з цих слів,

1882
01:35:51,010 --> 01:35:54,980
в тому числі назва програми, яка
знаходиться в ARGV на першому місці,

1883
01:35:54,980 --> 01:35:58,320
закінчується друкується по одному за раз.

1884
01:35:58,320 --> 01:36:05,290
І якщо я змінити це, і я кажу:
щось на зразок argv1 Zamyla Чан,

1885
01:36:05,290 --> 01:36:08,800
ми отримуємо все три з них
слова, що є argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, тому що в цьому
випадок ARGC, лічильник, 3.

1887
01:36:14,400 --> 01:36:20,020
>> Але що акуратний, якщо ви розумієте,
що ARGV просто масив рядків,

1888
01:36:20,020 --> 01:36:24,910
і ви розумієте, що рядок
являє собою масив символів,

1889
01:36:24,910 --> 01:36:29,470
ми можемо насправді вид використовувати цю функцію
квадратні дужки позначення кілька разів

1890
01:36:29,470 --> 01:36:33,320
щоб вибрати рядок, а потім виберіть
символ в рядку,

1891
01:36:33,320 --> 01:36:35,730
дайвінг глибше наступним чином.

1892
01:36:35,730 --> 01:36:40,100
У цьому прикладі, відпусти мене
вперед і назвати цю argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
І в цьому прикладі, дозвольте мені йти вперед
і зробити following-- для INT я отримую 0,

1895
01:36:50,180 --> 01:36:53,286
я менше ARGC, я плюс
плюс, так само, як і раніше.

1896
01:36:53,286 --> 01:36:55,910
Таким чином, в іншому words-- і тепер цей
стає досить складною.

1897
01:36:55,910 --> 01:36:59,940
Тоді я збираюся сказати,
перебирати струни в ARGV,

1898
01:36:59,940 --> 01:37:01,294
в якості коментаря до себе.

1899
01:37:01,294 --> 01:37:03,960
І тоді я буду мати
вкладений цикл, який ви, ймовірно,

1900
01:37:03,960 --> 01:37:06,290
зробили або вважаються
робити в порожньому місці, де

1901
01:37:06,290 --> 01:37:08,600
Я хочу сказати, я int--
не збирається використовувати я знову,

1902
01:37:08,600 --> 01:37:12,590
тому що я не хочу, щоб тінь, або
свого роду переписати існуючий I.

1903
01:37:12,590 --> 01:37:15,780
>> Я збираюся, а не, скажімо, J, так як
це моя перейти до змінної після того як я,

1904
01:37:15,780 --> 01:37:18,590
коли я просто намагаюся
розраховувати прості числа.

1905
01:37:18,590 --> 01:37:28,850
Для J отримує 0--, а також, п, збирається
отримати кормової довжину ARGV кронштейна I,

1906
01:37:28,850 --> 01:37:36,030
до тих пір, J менше т,
J плюс плюс, зробіть наступне.

1907
01:37:36,030 --> 01:37:37,500
А ось цікава частина.

1908
01:37:37,500 --> 01:37:46,330
>> Роздрукуйте характер і нову лінію,
підключивши ARGV кронштейн I, кронштейн J.

1909
01:37:46,330 --> 01:37:47,940
ОК, так що дозвольте мені додати деякі коментарі тут.

1910
01:37:47,940 --> 01:37:54,820
перебрати символи
в поточному рядку,

1911
01:37:54,820 --> 01:38:02,290
друк J-й символ в г-й рядку.

1912
01:38:02,290 --> 01:38:04,630
Так що тепер, давайте розглянемо
Що означають ці коментарі.

1913
01:38:04,630 --> 01:38:06,750
>> Перебір по струнах
в argv-- скільки

1914
01:38:06,750 --> 01:38:09,300
рядки в ARGV, який є масивом?

1915
01:38:09,300 --> 01:38:13,420
ARGC багато, тому я ітерація
від я дорівнює 0 до ARGC.

1916
01:38:13,420 --> 01:38:20,020
У той же час, скільки символів
в г-го рядка в ARGV?

1917
01:38:20,020 --> 01:38:22,880
>> Ну, щоб отримати цю відповідь,
Я просто називаю довжину рядка

1918
01:38:22,880 --> 01:38:26,810
на I догляд поточного рядка
про, що ARGV кронштейн я.

1919
01:38:26,810 --> 01:38:30,090
І я збираюся тимчасово зберігати, що
значення п, тільки для цілей кешування,

1920
01:38:30,090 --> 01:38:31,590
пам'ятати його ефективності.

1921
01:38:31,590 --> 01:38:36,330
І тоді я буду ініціювати J 0,
продовжувати йти так довго, як J менше п,

1922
01:38:36,330 --> 01:38:38,430
і на кожен крок ітерації J.

1923
01:38:38,430 --> 01:38:41,030
>> А потім тут, в
мій коментар в рядку 12,

1924
01:38:41,030 --> 01:38:43,390
роздрукувати символ,
а потім нової лінії,

1925
01:38:43,390 --> 01:38:48,140
спеціально ARGV кронштейн
я дає мені I-го рядка

1926
01:38:48,140 --> 01:38:51,690
в argv-- так що перше слово, то
Друге слово, третє слово, що завгодно.

1927
01:38:51,690 --> 01:38:57,370
А потім J пірнає глибше і отримує
я J-й символ цього слова.

1928
01:38:57,370 --> 01:39:02,200
І так, по суті, ви можете звертатися
ARGV як багатовимірне,

1929
01:39:02,200 --> 01:39:06,050
як двовимірного масиву ,,
причому кожне слово вид виглядає

1930
01:39:06,050 --> 01:39:08,580
як це в вашій уяві
очі, і кожен символ

1931
01:39:08,580 --> 01:39:10,930
є свого роду полягає в
стовпець, якщо це допомагає.

1932
01:39:10,930 --> 01:39:13,260
>> Насправді, коли ми дражнити
це одна від одної в майбутніх тижнів,

1933
01:39:13,260 --> 01:39:15,580
це буде трохи
складнішою, ніж це.

1934
01:39:15,580 --> 01:39:17,800
Але ви можете реально
думати про те, що на даний момент,

1935
01:39:17,800 --> 01:39:22,110
як тільки що це двовимірна
Масив, в результаті чого один рівень його

1936
01:39:22,110 --> 01:39:23,260
це все рядки.

1937
01:39:23,260 --> 01:39:26,760
І потім, якщо ви поринаєте в глибше, ви
може отримати в окремих символів

1938
01:39:26,760 --> 01:39:29,600
в ньому, використовуючи ці позначення тут.

1939
01:39:29,600 --> 01:39:31,620
>> Так що ж таке чистий ефект?

1940
01:39:31,620 --> 01:39:34,970
Дозвольте мені йти вперед і
зробити argv2-- штопати його.

1941
01:39:34,970 --> 01:39:36,210
Я зробив помилку тут.

1942
01:39:36,210 --> 01:39:40,160
побічно оголосивши
бібліотека функцій Стірлінга.

1943
01:39:40,160 --> 01:39:42,190
Так що весь цей час, це
можливо, доцільно

1944
01:39:42,190 --> 01:39:45,130
що ми на зразок обробки
саме там, де ми почали.

1945
01:39:45,130 --> 01:39:48,160
>> Я облажався, беззастережне визнання
бібліотека функцій Стірлінга.

1946
01:39:48,160 --> 01:39:48,987
Добре, почекайте хвилину.

1947
01:39:48,987 --> 01:39:51,070
Я пам'ятаю, що, особливо
так як це прямо тут.

1948
01:39:51,070 --> 01:39:54,490
Мені потрібно, щоб включити string.h в
ця версія програми.

1949
01:39:54,490 --> 01:40:00,050
>> Дозвольте мені йти вперед і включають в себе
string.h, крім того, що, йти вперед

1950
01:40:00,050 --> 01:40:04,460
і пересобрать argv2.

1951
01:40:04,460 --> 01:40:08,390
І тепер, тут ми йдемо, зробити argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
І хоча це трохи
загадкові на перший погляд,

1953
01:40:10,590 --> 01:40:15,690
зверніть увагу, що, насправді, те, що
роздруковується є точка argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Але якщо я ввести деякі слова за
підкажіть, як argv2 Zamyla Чан,

1955
01:40:19,970 --> 01:40:22,560
Введіть, також трохи
загадкові на перший погляд.

1956
01:40:22,560 --> 01:40:30,540
Але якщо ми прокручуємо назад вгору,
./argv2 Z-А-М-У-Л-С-Н-А-Н.

1957
01:40:30,540 --> 01:40:32,190
Таким чином, ми ітерацію над кожним словом.

1958
01:40:32,190 --> 01:40:37,770
І, в свою чергу, ми ітерації
кожен символ в слові.

1959
01:40:37,770 --> 01:40:40,040
>> Тепер, після того, як все це,
розумію, що є

1960
01:40:40,040 --> 01:40:43,120
одна деталь ми були свого роду
ігнорувати весь цей час.

1961
01:40:43,120 --> 01:40:46,180
Ми просто дражнять один від одного, що
Входи головних може бути?

1962
01:40:46,180 --> 01:40:47,780
Як щодо виходу головних у?

1963
01:40:47,780 --> 01:40:50,540
>> Весь цей час ми були
просто копіювання і вставка

1964
01:40:50,540 --> 01:40:53,870
слово INT перед головним чином,
хоча ви можете побачити в Інтернеті,

1965
01:40:53,870 --> 01:40:58,340
іноді неправильно в більш ранніх версіях
З і компіляторів, що вони говорять, що порожнеча,

1966
01:40:58,340 --> 01:40:59,410
або взагалі нічого.

1967
01:40:59,410 --> 01:41:01,580
Але, насправді, для версії
З, що ми використовуємо,

1968
01:41:01,580 --> 01:41:06,180
C 11, або 2011, реалізувати
що воно повинно бути інт.

1969
01:41:06,180 --> 01:41:09,300
І це повинно бути або
недійсним або ARGC і ARGV тут.

1970
01:41:09,300 --> 01:41:10,790
>> Але чому INT головний?

1971
01:41:10,790 --> 01:41:12,480
Що це насправді повернення?

1972
01:41:12,480 --> 01:41:16,280
Що ж, виявляється, весь цей час,
в будь-який час ви написали програма головна

1973
01:41:16,280 --> 01:41:18,440
завжди повертається щось.

1974
01:41:18,440 --> 01:41:19,960
Але це було робити це таємно.

1975
01:41:19,960 --> 01:41:23,350
>> Це щось є
INT, в рядку 5 пропонує.

1976
01:41:23,350 --> 01:41:24,225
Але що INT?

1977
01:41:24,225 --> 01:41:26,100
Ну, є така
конвенції в області програмування,

1978
01:41:26,100 --> 01:41:29,790
причому, якщо нічого не має
пішло не так, і все добре,

1979
01:41:29,790 --> 01:41:34,250
програми та функції в цілому
return-- кілька counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 в цілому означає, що все добре.

1982
01:41:38,070 --> 01:41:40,610
Так що навіть якщо ви думаєте
це як брехня в багатьох контекстах,

1983
01:41:40,610 --> 01:41:42,930
це насправді означає, як правило, хороша річ

1984
01:41:42,930 --> 01:41:49,560
>> У той же час, якщо програма повертає 1,
або негативний 1, або 5, або негативний 42,

1985
01:41:49,560 --> 01:41:52,941
або будь-який не-0 значення,
що в цілому означає

1986
01:41:52,941 --> 01:41:54,190
що щось пішло не так.

1987
01:41:54,190 --> 01:41:56,700
Насправді, на вашому власному Mac або PC,
Ви, можливо, насправді бачив

1988
01:41:56,700 --> 01:42:01,050
повідомлення про помилку, в результаті чого його
говорить щось або інше, помилка

1989
01:42:01,050 --> 01:42:04,940
код негативний 42, або код помилки
23, або щось в цьому роді.

1990
01:42:04,940 --> 01:42:08,980
Це число, як правило, тільки натяк
програмісту або компанії

1991
01:42:08,980 --> 01:42:11,174
що зробив програмне забезпечення,
що пішло не так і чому,

1992
01:42:11,174 --> 01:42:13,590
таким чином, щоб вони могли дивитися через
їх документація або код,

1993
01:42:13,590 --> 01:42:15,465
і з'ясувати, що
помилка насправді означає.

1994
01:42:15,465 --> 01:42:18,400
Як правило, не
корисним для нас кінцевих користувачів.

1995
01:42:18,400 --> 01:42:20,550
>> Але коли основні повертає 0, все добре.

1996
01:42:20,550 --> 01:42:23,770
І якщо ви не вкажете
які основні повинні повернутися,

1997
01:42:23,770 --> 01:42:26,950
він просто буде автоматично
повертає значення 0 для вас.

1998
01:42:26,950 --> 01:42:30,870
Але, повертаючись щось
ще насправді корисно.

1999
01:42:30,870 --> 01:42:34,660
>> У цій заключній програмі, дайте мені
йти вперед і назвати цю exit.c,

2000
01:42:34,660 --> 01:42:38,630
і ввести останній з сьогоднішніх
теми, відомі як код помилки.

2001
01:42:38,630 --> 01:42:42,930
Дозвольте мені йти вперед і включають в себе наші
знайомі файли Нагорі, зробіть INT головний.

2002
01:42:42,930 --> 01:42:49,500
І на цей раз, давайте робити Int ARGC,
Рядок ARGV, і з моїх дужках

2003
01:42:49,500 --> 01:42:50,836
має на увазі, що це в масиві.

2004
01:42:50,836 --> 01:42:52,460
І тоді дозвольте мені зробити перевірку осудності.

2005
01:42:52,460 --> 01:42:56,640
На цей раз, якщо ARGC НЕ
дорівнює 2, то ви знаєте, що?

2006
01:42:56,640 --> 01:42:57,520
Забудь це.

2007
01:42:57,520 --> 01:43:03,170
Я хочу сказати, що, гей, користувач,
вам не вистачає аргумент командного рядка

2008
01:43:03,170 --> 01:43:04,210
зворотна коса п.

2009
01:43:04,210 --> 01:43:05,230
>> А потім це все.

2010
01:43:05,230 --> 01:43:06,130
Я хочу, щоб вийти.

2011
01:43:06,130 --> 01:43:11,030
Я збираюся превентивно,
і передчасно дійсно, повернення

2012
01:43:11,030 --> 01:43:12,810
щось інше, ніж число 1.

2013
01:43:12,810 --> 01:43:15,360
Перейти до значення для першого
помилка, яка може статися 1.

2014
01:43:15,360 --> 01:43:17,860
Якщо у вас є якийсь інший помилковий
ситуація, яка може статися,

2015
01:43:17,860 --> 01:43:21,390
Ви могли б сказати, повернення 2 або повернення 3, або
може бути, навіть негативний 1 або негативний 2.

2016
01:43:21,390 --> 01:43:23,750
>> Це тільки коди завершення
які є, як правило,

2017
01:43:23,750 --> 01:43:27,770
тільки корисно для програміста, або
компанія, судноплавна програмне забезпечення.

2018
01:43:27,770 --> 01:43:30,500
Але той факт, що це
НЕ 0, що важливо.

2019
01:43:30,500 --> 01:43:34,310
Так що, якщо в цій програмі, я хочу
гарантувати, що ця програма тільки

2020
01:43:34,310 --> 01:43:38,190
працює, якщо користувач надає мені
з кількістю аргументів, з двох,

2021
01:43:38,190 --> 01:43:42,880
назва програми, а також деякі інші
слово, я можу застосовувати стільки, скільки треба,

2022
01:43:42,880 --> 01:43:46,110
кричати на користувача з PRINTF приказці,
відсутня аргумент командного рядка,

2023
01:43:46,110 --> 01:43:46,970
повертає 1.

2024
01:43:46,970 --> 01:43:49,940
Це буде просто негайно
вийти з програми.

2025
01:43:49,940 --> 01:43:55,840
>> Тільки якщо ARGC дорівнює 2 ми отримаємо вниз
тут, в який момент я збираюся сказати,

2026
01:43:55,840 --> 01:44:00,410
привіт відсотків s, зворотний слеш н, argv1.

2027
01:44:00,410 --> 01:44:03,827
Іншими словами, я
не буде таких того, як ARGV 0,

2028
01:44:03,827 --> 01:44:05,410
який є тільки назва програми.

2029
01:44:05,410 --> 01:44:09,450
Я хочу, щоб надрукувати Привіт, кома,
друге слово, яке надрукував людина.

2030
01:44:09,450 --> 01:44:12,580
І в цьому випадку на
рядок 13, все добре.

2031
01:44:12,580 --> 01:44:15,920
>> Я знаю, що ARGC 2
логічно випливає з цієї програми.

2032
01:44:15,920 --> 01:44:17,770
Я збираюся йти вперед і повертати 0.

2033
01:44:17,770 --> 01:44:21,230
Як і в сторону, майте на увазі, що
це вірно в порожньому місці, а також.

2034
01:44:21,230 --> 01:44:24,760
>> За логікою речей, я міг би це зробити
і инкапсулировать ці рядки

2035
01:44:24,760 --> 01:44:27,020
коду в цьому пункті інше тут.

2036
01:44:27,020 --> 01:44:29,420
Але це свого роду
зайве відступи мій код.

2037
01:44:29,420 --> 01:44:31,800
І я хочу, щоб зробити супер
ясно, що незалежно від того,

2038
01:44:31,800 --> 01:44:34,670
за замовчуванням, привіт
щось і буде надрукований,

2039
01:44:34,670 --> 01:44:36,050
до тих пір, поки користувач взаємодіє.

2040
01:44:36,050 --> 01:44:39,360
>> Так що це дуже поширене використання
стан, просто якщо,

2041
01:44:39,360 --> 01:44:41,870
зловити деякі помилкові
ситуація, а потім вийти.

2042
01:44:41,870 --> 01:44:45,690
І тоді, до тих пір, все
ну, не мають іншого,

2043
01:44:45,690 --> 01:44:48,060
але просто код
зовні, що, якщо, тому що це

2044
01:44:48,060 --> 01:44:51,060
еквівалент в цьому
окремий випадок, логічно.

2045
01:44:51,060 --> 01:44:54,480
Так що я повертаюся 0, просто
явно означає, що все добре.

2046
01:44:54,480 --> 01:44:58,480
>> Якщо я пропустив повернення 0, було б
автоматично передбачається, для мене.

2047
01:44:58,480 --> 01:45:00,890
Але тепер, коли я повертаюся
один, по крайней мере цьому випадку,

2048
01:45:00,890 --> 01:45:04,940
Я збираюся, для хорошої заходом і
ясність, повертає 0 в цьому випадку.

2049
01:45:04,940 --> 01:45:09,690
Так що тепер дозвольте мені йти вперед і зробити вихід,
який є ідеальним Segue просто піти.

2050
01:45:09,690 --> 01:45:14,401
>> Але зробити вихід, і відпустити мене
вперед і робити ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
І програма закричав на мене,
відсутня аргумент командного рядка.

2052
01:45:16,900 --> 01:45:18,120
Добре, дозвольте мені співпрацювати.

2053
01:45:18,120 --> 01:45:23,810
>> Дозвольте мені замість того, щоб робити ./exit, Девід, Enter.

2054
01:45:23,810 --> 01:45:25,190
А тепер він говорить, привіт Девід.

2055
01:45:25,190 --> 01:45:27,300
І ви зазвичай не бачите це.

2056
01:45:27,300 --> 01:45:30,650
>> Але виявляється, що є
особливий шлях в Linux насправді побачити

2057
01:45:30,650 --> 01:45:34,470
з тим, що код завершення програми завершується.

2058
01:45:34,470 --> 01:45:37,184
Іноді в графічному
світ, як Mac OS або Windows,

2059
01:45:37,184 --> 01:45:40,100
ви бачите тільки ці цифри, коли
повідомлення про помилку з'являється на екрані

2060
01:45:40,100 --> 01:45:41,940
і програміст
показує, що число.

2061
01:45:41,940 --> 01:45:44,773
Але якщо ми хочемо, щоб побачити, що помилка
повідомлення, ми можемо зробити це here--

2062
01:45:44,773 --> 01:45:48,100
так ./exit, Enter, друк
відсутня аргумент командного рядка.

2063
01:45:48,100 --> 01:45:54,590
>> Якщо я тепер робити відлуння $?, Який
смішно загадкові дивлячись.

2064
01:45:54,590 --> 01:45:56,590
Але $?

2065
01:45:56,590 --> 01:45:59,220
є магічним заклинанням
що говорить, агов, комп'ютер,

2066
01:45:59,220 --> 01:46:01,900
скажіть мені, що попередній
код виходу програми був.

2067
01:46:01,900 --> 01:46:03,410
І я вдарив Enter.

2068
01:46:03,410 --> 01:46:07,520
Я бачу 1, тому що це те, що я
сказав своєї основної функції, щоб повернутися.

2069
01:46:07,520 --> 01:46:12,310
>> У той же час, якщо я ./exit Давида,
і натисніть Enter, я бачу, привіт Давида.

2070
01:46:12,310 --> 01:46:16,800
І якщо я тепер робити відлуння $?, Я бачу привіт 0.

2071
01:46:16,800 --> 01:46:19,080
І таким чином це буде насправді
бути цінної інформації

2072
01:46:19,080 --> 01:46:23,420
в контексті відладчика, не так
багато, що ви, людина, буде піклуватися.

2073
01:46:23,420 --> 01:46:26,060
Але відладчик і інші
програми, які ми будемо використовувати в цьому семестрі

2074
01:46:26,060 --> 01:46:29,420
буде часто дивитися на це число,
незважаючи на те, що це свого роду заховані

2075
01:46:29,420 --> 01:46:32,780
якщо не шукати його, щоб
визначити, чи дійсно програми

2076
01:46:32,780 --> 01:46:37,050
виконання було правильним чи неправильним.

2077
01:46:37,050 --> 01:46:40,450
>> І так, що приводить нас до
це, в кінці дня.

2078
01:46:40,450 --> 01:46:43,917
Ми почали сьогодні, дивлячись на
налагодження, і в свою чергу, в ході

2079
01:46:43,917 --> 01:46:46,750
сама по собі, а потім більш цікаво,
технічно під капотом

2080
01:46:46,750 --> 01:46:49,490
на те, що рядки, які тривають
тиждень ми просто взяли щось само собою зрозуміле,

2081
01:46:49,490 --> 01:46:51,900
і, звичайно, взяв їх
як само собою зрозуміле в порожньому місці.

2082
01:46:51,900 --> 01:46:56,040
>> Потім ми розглянули, як ми можемо отримати доступ
окремі символи в рядку,

2083
01:46:56,040 --> 01:47:00,310
а потім знову взяв на більш високий рівень
дивитися на речі, дивлячись на те, як well--

2084
01:47:00,310 --> 01:47:04,226
якщо ми хочемо отримати на індивідуальному
елементи в списку, як структура,

2085
01:47:04,226 --> 01:47:05,850
ми не можемо зробити це з кількома рядками?

2086
01:47:05,850 --> 01:47:08,050
І ми можемо з аргументами командного рядка.

2087
01:47:08,050 --> 01:47:12,800
Але ця картина тут просто коробки
Показово в цій загальній ідеї

2088
01:47:12,800 --> 01:47:14,451
масиву або списку або вектора.

2089
01:47:14,451 --> 01:47:16,450
І в залежності від
контекст, всі ці слова

2090
01:47:16,450 --> 01:47:17,880
означають трохи різні речі.

2091
01:47:17,880 --> 01:47:20,060
Таким чином, в C, ми тільки збираємося
говорити про масиві.

2092
01:47:20,060 --> 01:47:23,840
І масив являє собою шматок
пам'яті, кожен з яких це

2093
01:47:23,840 --> 01:47:27,720
елементи є суміжними, назад,
до спини, до спини, до спини.

2094
01:47:27,720 --> 01:47:31,970
>> І ці елементи, як правило,
одного і того ж типу даних, символів,

2095
01:47:31,970 --> 01:47:35,966
характер, темперамент, характер, або
рядок, рядок, рядок, рядок, або INT,

2096
01:47:35,966 --> 01:47:38,600
INT, INT, то, що це
ми намагаємося зберегти.

2097
01:47:38,600 --> 01:47:42,540
Але врешті-решт, це
як це виглядає концептуально.

2098
01:47:42,540 --> 01:47:44,530
Ви берете ваш
пам'яті або ОЗУ комп'ютера.

2099
01:47:44,530 --> 01:47:48,590
І ви вирізаючи його в
однакового розміру коробки, всі з яких

2100
01:47:48,590 --> 01:47:50,920
повернулися, до спини, щоб
тому, до спини таким чином.

2101
01:47:50,920 --> 01:47:53,200
>> І що приємно про
ця ідея, і той факт,

2102
01:47:53,200 --> 01:47:58,580
що ми можемо висловити значення в цьому випадку
з першим з наших структур даних

2103
01:47:58,580 --> 01:48:02,520
в класі, означає, що ми можемо почати
вирішити проблеми з кодом

2104
01:48:02,520 --> 01:48:04,079
що прийшло так інтуїтивно в тиждень 0.

2105
01:48:04,079 --> 01:48:05,870
Ви пам'ятаєте, телефон
Приклад книги, де

2106
01:48:05,870 --> 01:48:09,110
ми використовували розділяй і володарюй,
або двійковий алгоритм пошуку,

2107
01:48:09,110 --> 01:48:13,220
просівати в цілому
купа імен та номерів.

2108
01:48:13,220 --> 01:48:18,220
Але ми припускали, нагадаємо, що це
Телефонна книга була вже відсортований,

2109
01:48:18,220 --> 01:48:21,630
що хтось вже
фігурний out-- дан список імен

2110
01:48:21,630 --> 01:48:24,430
і numbers--, як в алфавітному порядку їх.

2111
01:48:24,430 --> 01:48:26,950
І тепер, коли в C ми,
теж є можливість

2112
01:48:26,950 --> 01:48:30,290
закласти речі, а не
фізично в телефонній книзі

2113
01:48:30,290 --> 01:48:34,220
але практично в комп'ютера
пам'ять, ми зможемо на наступному тижні

2114
01:48:34,220 --> 01:48:38,470
ввести знову this-- перший
наших структур даних в array--

2115
01:48:38,470 --> 01:48:43,530
але що більш важливо, фактичний комп'ютер
Алгоритми науки реалізовані

2116
01:48:43,530 --> 01:48:47,720
в коді, за допомогою якого ми можемо зберігати
дані в структурах, як це,

2117
01:48:47,720 --> 01:48:50,730
а потім починають маніпулювати нею, і
насправді вирішити проблеми, пов'язані з ним,

2118
01:48:50,730 --> 01:48:53,570
і побудувати на вершині цього,
в кінцевому рахунку, програми в C,

2119
01:48:53,570 --> 01:48:56,730
в Python, в JavaScript,
запитів до баз даних з SQL?

2120
01:48:56,730 --> 01:48:59,980
>> І ми бачимо, що всі ці
різні ідеї блокування.

2121
01:48:59,980 --> 01:49:04,100
Але зараз, нагадаємо, що
Домен, який ми ввели сьогодні

2122
01:49:04,100 --> 01:49:06,920
була ця річ тут, і
світ криптографії.

2123
01:49:06,920 --> 01:49:11,200
А серед таких проблем ви самі
буде вирішувати це мистецтво криптографії,

2124
01:49:11,200 --> 01:49:13,630
скремблювання і дескремблирования
інформація, і шифрування

2125
01:49:13,630 --> 01:49:15,930
і розшифровка тексту,
і припускаючи, в кінцевому рахунку,

2126
01:49:15,930 --> 01:49:18,970
що тепер ви знаєте, що
знаходиться під капотом

2127
01:49:18,970 --> 01:49:21,860
так що, коли ви бачите або отримати
повідомлення як це, ви

2128
01:49:21,860 --> 01:49:24,060
самі можете розшифрувати його.

2129
01:49:24,060 --> 01:49:26,740
Все це, і більше в наступний раз.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [Відеовідтворення]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Тільки що прибув.

2133
01:49:32,970 --> 01:49:35,146
Я збираюся йти візит
його професор коледжу.

2134
01:49:35,146 --> 01:49:37,611
Так.

2135
01:49:37,611 --> 01:49:40,080
Привіт.

2136
01:49:40,080 --> 01:49:40,660
Це ти.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Зачекайте!

2139
01:49:45,110 --> 01:49:45,610
Девід.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Я просто намагаюся зрозуміти
що сталося з вами.

2142
01:49:56,060 --> 01:49:58,130
Будь ласка, що-небудь може допомогти.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Ви були його коледж
сусід по кімнаті, чи не так?

2145
01:50:08,354 --> 01:50:10,770
Ви були там з ним, коли
він завершив проект CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [МУЗИКА]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Ось Був CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Я люблю це місце.

2152
01:50:44,770 --> 01:50:45,854
>> -Поїсти.

2153
01:50:45,854 --> 01:50:47,020
Ми збираємося з бізнесу.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [КІНЕЦЬ ВОСП]

