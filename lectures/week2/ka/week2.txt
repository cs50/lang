[მუსიკის დაკვრა] 

დევიდ ჯ Malan ყველა უფლება. ეს არის CS50 და ეს არის დაწყების კვირა 2. და თქვენ გავიხსენოთ, რომ მეტი ბოლო რამდენიმე კვირის განმავლობაში, ჩვენ უკვე შემოღების კომპიუტერული მეცნიერებისა და, თავის მხრივ, პროგრამირების. 

და დავიწყეთ ამბავი გზით Scratch, რომ გრაფიკული ენის საწყისი MIT- ის მედია ლაბორატორია. და შემდეგ ყველაზე ცოტა ხნის წინ, გასულ კვირას, არც ჩვენ დანერგვა higher-- ქვედა დონის ენა ცნობილია როგორც C, რაღაც რომ წმინდა ტექსტური. და, მართლაც, ბოლო დროს ჩვენ შესწავლილი ფარგლებში კონტექსტში რიგი ცნებები. 

ეს, გავიხსენოთ, იყო ძალიან პირველი პროგრამა ჩვენ შევხედე. ეს პროგრამა, უბრალოდ, ბეჭდავს out, "hello, world". მაგრამ იქ იმდენად მოჩვენებითი ჯადოსნური მიმდინარეობს. არსებობს ამ # მოიცავს ამ კუთხე ფრჩხილებში. არსებობს int. არსებობს (void). არსებობს ფრჩხილებში, Curly braces, ნახევრად colons, და ასე უფრო მეტი. 

ასე რომ, გავიხსენოთ, რომ ჩვენ გააცნო Scratch ასე, რომ ჩვენ შეგვიძლია, იდეალურად, ვხედავ წარსულში რომ სინტაქსი, პერსონალის, რომ ნამდვილად არ არის ყველა, რომ ინტელექტუალურად საინტერესო, მაგრამ დასაწყისში არის, რა თქმა უნდა, ცოტა სახიფათო გადაიტანოთ თქვენი აზრით გარშემო. და, მართლაც, ერთ-ერთი ყველაზე გავრცელებული რამ ადრეულ პროგრამირების კლასი, განსაკუთრებით მათთვის, ნაკლებად კომფორტული, არის ის, რომ იმედგაცრუებულია და იმყოფებოდა up გარკვეული სინტაქსური შეცდომები, რომ აღარაფერი ვთქვათ ლოგიკური შეცდომები. ასე რომ, მათ შორის ჩვენი მიზნები დღეს, ფაქტობრივად, ნება უნდა აღჭურვა თქვენ გარკვეული პრობლემის გადაჭრაზე ტექნიკის როგორ უკეთ პრობლემების მოგვარებას თავად სახით debugging. და თქვენ გავიხსენოთ, ძალიან, რომ გარემო, რომელიც ჩვენ გააცნო ბოლო დროს ეწოდა CS50 IDE. ეს არის ვებ დაფუძნებული პროგრამული უზრუნველყოფა, რომელიც გაძლევთ საშუალებას პროგრამის ღრუბელი, ასე ვთქვათ, ხოლო შენახვა ყველა თქვენი ფაილი ერთად, როგორც ჩვენ კვლავ დღეს. და გავიხსენოთ, რომ ჩვენ revisited ეს თემა აქ, მათ შორის ფუნქციები და მარყუჟების, და ცვლადები და ლოგიკური გამონათქვამები, და პირობებს. და რეალურად კიდევ რამდენიმე, რომ ჩვენ თარგმნა მსოფლიოს Scratch სამყაროში C. 

მაგრამ ფუნდამენტური შენობა კორპუსები, ასე ვთქვათ, იყო ნამდვილად იგივეა გასულ კვირას. ფაქტობრივად, ჩვენ ნამდვილად ჰქონდა სხვადასხვა თავსატეხი ცალი, თუ გნებავთ. იმის ნაცვლად, რომ purple გადარჩენა ბლოკი, ჩვენ ნაცვლად ჰქონდა printf, რომელიც ამ ფუნქციის C, რომ საშუალებას გაძლევთ ამობეჭდოთ რაღაც და დააფორმატე ეკრანზე. ჩვენ გააცნო CS50 ბიბლიოთეკა, სადაც თქვენ აქვს ახლა თქვენს განკარგულებაშია get_char, და get_int და get_string, და რამდენიმე სხვა ფუნქციებს, ასევე, რომლის მეშვეობით თქვენ შეგიძლიათ მიიღოთ input მომხმარებელი საკუთარი კლავიატურაზე. და ჩვენ ასევე მიიღო შევხედოთ რამ როგორიცაა these- bool, და char, და ორმაგი, float, int, long_long სიმებიანი. და იქ კი სხვა მონაცემები სახის C. 

სხვა სიტყვებით, როდესაც თქვენ გამოაცხადოს ცვლადი შესანახად გარკვეული მნიშვნელობა, ან როდესაც თქვენ განახორციელოს ფუნქცია რომ ბრუნდება გარკვეული მნიშვნელობა, თქვენ შეგიძლიათ მიუთითოთ რა ტიპის ღირებულება, რომელიც არის. ეს არის ტექსტი, როგორიც თანმიმდევრობა გმირები? ეს არის ნომერი, როგორც რიცხვი? ეს არის მცურავი წერტილი ღირებულება, ან მოსწონს? ასე რომ, C, განსხვავებით Scratch, ჩვენ რეალურად დაიწყო აკონკრეტებს, თუ რა სახის მონაცემები ვბრუნდებოდით ან გამოყენებით. 

მაგრამ, რა თქმა უნდა, ჩვენ ასევე შეუვარდნენ ზოგიერთი ფუნდამენტური ლიმიტები computing. კერძოდ, ეს ენა C, გავიხსენოთ რომ ავიღეთ შევხედოთ რიცხვი overflow, რეალობა იმ შემთხვევაში, თუ თქვენ მხოლოდ სასრული რაოდენობით მეხსიერება და, კერძოდ, სასრული რაოდენობის ბიტი, თქვენ მხოლოდ ითვლიან იმდენად მაღალი. ასე რომ, ჩვენ შევხედე ამ მაგალითს აქ რომლის დროსაც counter თვითმფრინავის, რეალურად, თუ გაშვებული ხანგრძლივი საკმარისი იქნებოდა overflow და გამოიწვიოს პროგრამული უზრუნველყოფა ფაქტობრივი ფიზიკური პოტენციური შეცდომა. 

ჩვენ ასევე შევხედე მცურავი პუნქტიანი ორაზროვნება, რეალობა რომ მხოლოდ სასრული რაოდენობის ბიტი, თუ არა ის 32 ან 64, თქვენ შეგიძლიათ მიუთითოთ მხოლოდ ამდენი ნომრები მას შემდეგ, რაც ათობითი წერტილი, რის შემდეგაც თქვენ დაიწყოს მიიღოს ბუნდოვანი. ასე მაგალითად, ერთ-ერთი მესამედით მსოფლიოში აქ, ჩვენს ადამიანთა სამყაროში, ჩვენ ვიცით არის მხოლოდ უსასრულო რაოდენობის of 3s შემდეგ ათობითი წერტილი. მაგრამ კომპიუტერის ვერ აუცილებლად წარმოადგენს უსასრულო რაოდენობის ნომრები თუ თქვენ მხოლოდ დაუშვებს, რომ ზოგიერთი სასრული რაოდენობით ინფორმაცია. 

ასე რომ, არა მხოლოდ ჩვენ აღჭურვა თქვენ ერთად უფრო დიდი ძალა თვალსაზრისით თუ როგორ შეიძლება გამოხატოს საკუთარ თავს კლავიატურის თვალსაზრისით პროგრამირების, ჩვენ ასევე შეზღუდული რა თქვენ შეგიძლიათ რეალურად გავაკეთოთ. და მართლაც, შეცდომები და შეცდომები წარმოიქმნება იმ სახის საკითხები. და მართლაც, მათ შორის თემა დღეს ვაპირებთ, რომ თემები, როგორიცაა გამართვის და რეალურად ეძებს ქვეშ hood თუ როგორ რამ გაეცნენ გასულ კვირას ფაქტობრივად განხორციელებული ასე, რომ თქვენ უკეთესი გავიგოთ, როგორც შესაძლებლობების და შეზღუდვები ენის მსგავსად, C. 

და სინამდვილეში, ჩვენ კანი უკან ფენების უმარტივესი მონაცემები სტრუქტურის, რაღაც მოუწოდა მასივი, რომელიც Scratch ხდება მოვუწოდებთ "სიაში." ეს ცოტა სხვადასხვა კონტექსტში. და მაშინ ჩვენ ასევე წარმოგიდგინოთ ერთ-ერთი პირველი ჩვენი დომენური სპეციფიკური პრობლემები CS50, მსოფლიოს კრიპტოგრაფიის, ხელოვნების scrambling ან დაშიფრვის ინფორმაცია ისე, რომ თქვენ შეგიძლიათ გააგზავნოთ საიდუმლო შეტყობინებები და decode საიდუმლო შეტყობინებები ორ ადამიანს შორის, A და B. 

ასე რომ სანამ ჩვენ გარდამავალი რომ ახალ სამყაროში, მოდით მივცეთ თქვენ გარკვეული ტექნიკას, რომელთანაც შეგიძლიათ აღმოფხვრა ან შემცირება მინიმუმ რამდენიმე იმედგაცრუებები რომ თქვენ ალბათ გვხვდება გასული კვირის განმავლობაში მარტო. ფაქტობრივად, წინ თქვენ such-- ზოგიერთი თქვენი პირველი პრობლემა C. და შანსები, თუ თქვენ, როგორც მე, პირველად ცდილობენ ტიპი out პროგრამა, მაშინაც კი, თუ ვფიქრობ ლოგიკურად პროგრამა არის საკმაოდ მარტივი, თქვენ შეიძლება ძალიან კარგად მოხვდა კედლის და შემდგენელი თანამშრომლობას არ აპირებს. ან Clang არ აპირებს რეალურად თქვენი ტენდერების. 

და რატომ შეიძლება რომ იყოს? ისე, მოდით შევხედოთ, ალბათ, მარტივი პროგრამა. მე ვაპირებ წავიდეთ წინ და გადარჩენა ეს ფაილი შეგნებულად მოუწოდა buggy0.c, რადგან ვიცი, რომ ეს ყალბი წინასწარ. მაგრამ მე შეიძლება არ ესმოდეს, რომ თუ ეს პირველი ან მეორე ან მესამე პროგრამა რომ მე რეალურად მიღების თავს. ამიტომ, მე ვაპირებ წავიდეთ წინ და აკრიფოთ გარეთ, int ძირითადი (void). და შემდეგ შიგნით ჩემი Curly braces, ძალიან ნაცნობი ( "hello, world წარმატებული, n ") - და ნახევრად მსხვილი ნაწლავის. 

მე შენახული ფაილი. ახლა მე ვაპირებ დაცემას ჩემი ტერმინალის ფანჯარაში და ტიპის მიიღოს buggy0, რადგან, კიდევ ერთხელ, სახელი ფაილი დღეს buggy0.c. ასე რომ, მე აკრიფოთ მიიღოს buggy0, შეიტანეთ. 

და, რა, gosh, გავიხსენოთ ბოლო დროს რომ არ შეცდომის შეტყობინებები არ არის კარგია. ასე რომ, არ გამომავალი კარგია. მაგრამ აქ მე ნათლად გარკვეული რაოდენობის შეცდომები. 

ასე რომ, პირველი ხაზი გამომავალი მას შემდეგ, რაც აკრეფით მიიღოს buggy0, გავიხსენოთ, არის Clang ის საკმაოდ verbose გამომავალი. ქვეშ Hood, CS50 IDE არის კონფიგურირებული გამოიყენოს მთელი bunch პარამეტრები ამ შემდგენელი ასე რომ თქვენ არ აქვს ვფიქრობ, რომ მათ შესახებ. და ეს ყველაფერი, რომ პირველი ხაზი საშუალება, რომელიც იწყება Clang. 

მაგრამ ამის შემდეგ, პრობლემები, დაიწყოს, რათა მათი გამოჩენა. Buggy0.c on line 3, ხასიათი 5, არ არის დიდი, წითელი შეცდომა. რა არის ეს? მინიშნებით გამოცხადების ბიბლიოთეკის ფუნქცია printf ტიპის int (const char *, ...) [-Werror]. ვგულისხმობ, ეს ძალიან სწრაფად იღებს ძალიან arcane. და რა თქმა უნდა, პირველ რიგში, ერთი შეხედვით, ჩვენ არ ველით, რომ თქვენ უნდა გვესმოდეს, მთლიანად რომ გაგზავნა. ასე რომ, ერთი გაკვეთილები დღეს აპირებს უნდა ვეცადოთ, რომ შეამჩნია ნიმუშების, ან მსგავსი რამ, შეცდომები ალბათ შეექმნა წარსულში. მოდით აჯავრებენ გარდა მხოლოდ ეს სიტყვები, რომელიც ნაცნობი. დიდი, წითელი შეცდომა აშკარად სიმბოლურია ის, რომ არასწორია. 

მინიშნებით გამოცხადების ბიბლიოთეკის ფუნქცია printf. ასე რომ, თუ მე არ მესმის რა მინიშნებით გამოცხადების ბიბლიოთეკის ფუნქცია საშუალებით, პრობლემა აუცილებლად ეხება printf რატომღაც. და წყარო, რომ საკითხი უნდა გააკეთოს გამოცხადების მას. 

გამოცხადების ფუნქცია აღვნიშნო, რომ ეს პირველად. და ჩვენ გამოყენებული ტერმინოლოგიის გასულ კვირას გამოცხადების ფუნქციის პროტოტიპი, არც ერთი ხაზი ზედა თქვენი საკუთარი ფაილი ან ე.წ. header ფაილი. და რა ფაილი არ ვამბობთ, გასულ კვირას, რომ printf არის ციტირებით unquote, გამოაცხადა? რა ფაილი არის მისი პროტოტიპი? 

ასე რომ, თუ გავიხსენებთ, პირველი, რაც მე ტიპის, თითქმის ყველა პროგრამა ბოლო დროს და შემთხვევით მომენტში წინ დაიწყო ბეჭდვის myself-- იყო ამ ერთი აქ hash-- # include <stio-- for input / გამომავალი dot h მართლაც, თუ მე ახლა გადარჩენა ამ ფაილის, მე ვაპირებ წავიდეთ წინ და გარკვევა ჩემი ეკრანზე, თქვენ შეგიძლიათ აკრეფით წმინდა, და თქვენ შეგიძლიათ გამართავს კონტროლის L, უბრალოდ გარკვევა თქვენი ტერმინალის ფანჯარაში მხოლოდ აღმოფხვრას რამდენიმე clutter. 

მე ვაპირებ წავიდეთ წინ და აკრიფოთ make buggy0, შეიტანეთ. და voila, მე მაინც ვხედავ, რომ ხანგრძლივი ბრძანება Clang, მაგრამ იქ არ არის შეცდომა ამ დროს. და მართლაც, თუ მე ./buggy0, ისევე, როგორც ბოლო დროს, სადაც dot ნიშნავს ეს კატალოგი, Slash მხოლოდ იმას ნიშნავს, აქ მოდის პროგრამის დასახელება და ეს სახელი პროგრამა buggy0, შევა, "hello, world". 

ახლა, როგორ შეიძლება თქვენ გაქვთ გამომდინარე ამ გადაწყვეტა აუცილებელი აღიარებს, როგორც ბევრი სიტყვა როგორც მე, რა თქმა უნდა, რომელსაც კეთდება ეს ამდენი წლის განმავლობაში? ისე, გააცნობიეროს თითო პირველი პრობლემა კომპლექტი, ჩვენ წარმოგიდგინოთ ბრძანება რომ CS50 საკუთარი თანამშრომლები წერდა მოუწოდა help50. და მართლაც, C აკეთებს დაზუსტება პრობლემა შეიქმნა, თუ როგორ უნდა გამოიყენოთ ეს. 

მაგრამ help50 არსებითად პროგრამა, რომელიც CS50 პერსონალი წერდა, რომ საშუალებას გაძლევთ აწარმოებს ბრძანება ან გაუშვით პროგრამა, და თუ არ ესმის მისი გამომავალი, უნდა გაიაროს მისი გამომავალი help50, ამ დროს პროგრამული რომ რა თქმა უნდა პერსონალის დაწერა შეხედავს თქვენი პროგრამის გამომავალი ხაზს, ხასიათი ხასიათი. და თუ ჩვენ, პერსონალი, აღიარებს შეცდომა, რომ თქვენ განიცდის, ჩვენ შევეცდებით, რომ პროვოცირება თქვენ რამდენიმე რიტორიკული კითხვები, რამდენიმე რჩევა, ჰგავს TF ან CA ან თავს ყველაფერს გააკეთებს, პირის საათებში. 

ასე გამოიყურება help50 თუ არ აუცილებლად აღიარებს პრობლემა. მაგრამ არ დაეყრდნონ ეს ძალიან ბევრი, ყავარჯენი. უნდა ვეცადოთ, რომ მესმის მისი გამომავალი და მაშინ ვისწავლოთ მისგან ისე, რომ მხოლოდ ერთხელ ან ორჯერ თქვენ ოდესმე აწარმოებს help50 კონკრეტული შეცდომა გაგზავნა. ამის შემდეგ, თქვენ უნდა იყოს უკეთესი აღჭურვილი თავს გაერკვნენ, რა ის რეალურად არის. 

მოდით გავაკეთოთ ერთი აქ. ნება მომეცით წავიდეთ წინ, და სხვა ფაილი ჩვენ მოვუწოდებთ ამ buggy1.c. და ამ ფაილის ვარ აპირებს deliberately-- მაგრამ ვიტყვი, რომ მე არ გაგება, თუ რა შეცდომა მე გააკეთა. 

მე ვაპირებ წავიდეთ წინ და ამის ამას მოიცავს, მას შემდეგ, რაც მე გავიგე ჩემი გაკვეთილი მომენტში წინ. Int ძირითადი (void), როგორც ადრე. და მაშინ აქ მე ვაპირებ უნდა გააკეთოს სიმებიანი s - get_string. და გავიხსენოთ, ბოლო დროს, რომ ეს ნიშნავს, hey, კომპიუტერი, მომეცი ცვლადი, მას s, და რათა ტიპის, რომ ცვლადის სიმებიანი ასე რომ შეგიძლიათ შეინახოთ ერთი ან მეტი სიტყვა იგი. 

და მერე მარჯვენა მხარეს თანაბარი ნიშანი არის get_string, რომელიც არის ფუნქცია CS50 ბიბლიოთეკა რომელიც აკეთებს ზუსტად რომ. იგი იღებს ფუნქცია და შემდეგ ხელში მარჯვნიდან მარცხნივ. ასე რომ, ეს თანაბარი ნიშანი არ ნიშნავს იმას, "ტოლია" რადგან ჩვენ შესაძლოა იფიქროს მათემატიკის. ეს იმას ნიშნავს, დავალება მარჯვნიდან მარცხნივ. ასე რომ, ეს იმას ნიშნავს, მიიღოს სიმებიანი ეხლა შესახებ და ჩაწერს მას შიგნით s. 

ახლა მოდით გამოიყენოს იგი. ნება მომეცით წავიდეთ წინ არის და, როგორც მეორე ხაზი, ნება მომეცით წავიდეთ წინ და ამბობენ, "გამარჯობა", - არა "მსოფლიო", მაგრამ "hello,% s-- რაც ჩვენი placeholder, მძიმით s, რაც ჩვენი ცვლადი, და მერე ნახევრად მსხვილი ნაწლავის. ასე რომ, თუ მე არ ხრახნიანი ძალიან ბევრი აქ, ამ ჰგავს სწორი კოდი. 

და ჩემი ინსტინქტები ახლა კომპილირება. ფაილი ეწოდება buggy1.c. ამიტომ, მე ვაპირებ, რომ გავაკეთოთ buggy1, შეიტანეთ. და darn ის, თუ არ არის კიდევ უფრო შეცდომები, ვიდრე ადრე. ვგულისხმობ, იქ უფრო მეტი შეცდომის შეტყობინებები, რომ ის როგორც ჩანს, ვიდრე ფაქტობრივი ხაზები ამ პროგრამაში. 

მაგრამ takeaway აქ არის, მაშინაც კი, თუ თქვენ overwhelmed ორი ან სამი ან კიდევ ოთხი შეცდომა შეტყობინებები ყურადღებას ყოველთვის ძალიან პირველი იმ შეტყობინებები. ეძებს ყველაზე საუკეთესო ერთი, სენსორული უკან, როგორც საჭირო იქნება. ასე რომ აქ მე აკრეფილი გააკეთოს buggy1. აი, რომ Clang გამომავალი როგორც მოსალოდნელი იყო. 

აქ არის პირველი წითელი შეცდომა. გამოყენება გამოუცხადებელ იდენტიფიკატორი სიმებიანი, არ ვგულისხმობ სტანდარტი? ამიტომ სტანდარტის არის რეალურად რაღაც. ეს ეხება მომხმარებლის კლავიატურის, არსებითად. 

მაგრამ ეს არ არის ის, რაც მე ნიშნავდა. ვგულისხმობდი სიმებიანი და მე იმას ნიშნავდა, get_string. რა არის ის, რომ მე დაავიწყდა ამის გაკეთება ამ დროს? რა აკლია ამ დროს? მე მაქვს ჩემი მოიცავს, ასე რომ მე მაქვს წვდომა printf. 

მაგრამ რა არ აქვს ხელმისაწვდომობის უბრალოდ არ არის? კარგად, ისევე, ბოლო დროს, მე უნდა გითხრათ შემდგენელი Clang რა ამ ფუნქციების. Get_string არ მოდის ერთად C. და კერძოდ, არ მოდის header ფაილი,. ის ნაცვლად მოდის რაღაც თანამშრომლებს წერდა, რომელიც სხვადასხვა ფაილი სახელი, მაგრამ aptly დაასახელა. 

ასე რომ, უბრალოდ დასძინა, რომ ერთი ხაზი of code-- გავიხსენოთ ბოლო დროს რომ როდესაც Clang გადის, ის აპირებს შევხედოთ ჩემი კოდი ზემოდან, მარცხნიდან მარჯვნივ. ის აპირებს შეამჩნია, oh, გსურთ. ნება მომეცით წავიდეთ და ნახავთ, რომ, სადაც არ არის სერვერზე, დააკოპირეთ და ჩასვით იგი, არსებითად, ზედა საკუთარი ფაილი ასე რომ, ამ ეტაპზე იმ ამბავს, line 1, დანარჩენი პროგრამა შეიძლება, მართლაც, გამოიყენოთ რომელიმე ფუნქცია მასში, მათ შორის get_string. ამიტომ, მე ვაპირებ იგნორირება დანარჩენი იმ შეცდომებს, იმიტომ, რომ მე, რა თქმა უნდა, ეჭვი მაქვს, რომ მხოლოდ პირველი რეალურად აქვს. და მე ვაპირებ წავიდეთ წინ და გამეორება, შემდეგ გადარჩენა ჩემი ფაილი რათა buggy1. და voila, ის გავაკეთეთ მუშაობაში. და თუ მე ./buggy1 და აკრიფოთ, მაგალითად, Zamyla, მე ახლა მიიღებს hello, Zamyla, ნაცვლად hello, world. 

კარგი. ასე რომ, takeaways მაშინ აქ უნდა, ერთ-ერთი, ცდილობენ glean იმდენი, როგორც თქვენ შეგიძლიათ შეცდომა შეტყობინებები მარტო, ეძებს ზოგიერთი ცნობადი სიტყვა. გამოვრიცხავთ, რომ, გამოიყენოთ help50 პოსტი პრობლემა კომპლექტი სპეციფიკაცია. მაგრამ შეზღუდვის, რომ ძალიან, ყოველთვის გამოიყურება ზედა შეცდომა მხოლოდ, მინიმუმ თავდაპირველად, რა ინფორმაცია ეს შეიძლება რეალურად გამოიღო. მაგრამ ეს თურმე არსებობს კიდევ უფრო ფუნქციონალური ჩაშენებული შევიდა CS50 ბიბლიოთეკა, რათა დაეხმაროს თქვენ დასაწყისში სემესტრის და დილით პროგრამირების გაერკვნენ, თუ რა ხდება, არასწორია. მოდით გავაკეთოთ კიდევ ერთი მაგალითია აქ. მე ვაპირებ მოვუწოდო ამ buggy2, რომელიც, ერთხელ, იქნება გაყალბდა out კარიბჭე, დიზაინი. 

და მე ვაპირებ წავიდეთ წინ და ნუ # მოიცავს. და შემდეგ მე ვაპირებ ამის გაკეთებას int ძირითადი (void). და შემდეგ მე ვაპირებ გავაკეთოთ ამისთვის loop. ამისთვის (int i _ 0. მე ნაკლებია ან ტოლი 10. i ++, და შემდეგ Curly braces, მე ვაპირებ ამობეჭდოთ მხოლოდ hashtag სიმბოლო აქ ახალი ხაზი ხასიათი. 

ასე რომ, ჩემი განზრახვა ამ პროგრამა საკმაოდ უბრალოდ უნდა iterate 10 ჯერ და თითოეულ iteration რომ ციკლი ყოველ ჯერზე მეშვეობით ციკლი, ამობეჭდოთ hashtag, hashtag, hashtag. ერთ ხაზზე იმიტომ, რომ მე აქვს ახალი ხაზი არსებობს. და გავიხსენოთ, რომ ამისთვის loop, თითო გასულ კვირას და თქვენ მიიღებთ უფრო მეტი იცნობს სინტაქსი გამოყენებით იგი პრაქტიკაში ადრე long-- ეს მაძლევს ცვლადში მე და ადგენს მას 0. 

ეს increments i on ყოველ iteration 1. ასე რომ, მე ღებულობენ 1 2 3. და მაშინ ეს პირობა შუა შორის ნახევრად colons იღებს შემოწმდება ყოველ iteration რათა დარწმუნებული ვარ, რომ ჩვენ ჯერ კიდევ ფარგლებში დიაპაზონი. ასე რომ, მინდა iterate 10-ჯერ, ასე რომ მე გვაქვს ერთგვარი ინტუიტიურად მხოლოდ ბოლო 10 როგორც ჩემი ზედა ზღვარი არ არსებობს. 

და მაინც, როდესაც მე აწარმოებს ამ, მას შემდეგ, შედგენის იგი, რათა buggy2-- და ეს არ კომპილირდება OK. ასე რომ, არ აქვს სინტაქსური შეცდომა ამ დროს. ნება მომეცით წავიდეთ წინ ახლა და აწარმოებს buggy2, შეიტანეთ. და ახლა გადახვევა. და ნება მომეცით გაიზრდება ზომა ფანჯარა. 

მე, როგორც ჩანს 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. ასე რომ, 11 hashtags, მიუხედავად იმისა, რომ მე აშკარად დააყენა 10 შიგნით ამ loop. ახლა, ზოგიერთი შეიძლება ვხედავ დაუყოვნებლივ რა შეცდომა არის ის, რომ, მართლაც, ეს არ არის ძალიან რთული შეცდომა, რათა. მაგრამ ეს ძალიან ხშირად ძალიან დასაწყისში. 

რა მინდა აღვნიშნო, თუმცა, არის, თუ როგორ შეიძლება მე გაერკვნენ ამ გარეთ? ისე, გამოდის, რომ CS50 ბიბლიოთეკა გააჩნია არა მხოლოდ get_string და get_int და get_float და სხვა ფუნქციები. მას ასევე გააჩნია სპეციალური ფუნქცია მოუწოდა eprintf, ან, შეცდომა printf. და ის არსებობს მხოლოდ რათა ეს ცოტა ადვილი თქვენთვის როდესაც გამართვის თქვენი კოდი მხოლოდ ბეჭდვა შეცდომა ეკრანზე და ვიცი, სადაც იგი მოვიდა. 

ასე მაგალითად, ერთი რამ შეიძლება გავაკეთოთ აქ ეს ფუნქცია ამას eprintf, და შემდეგ მე ვაპირებ წავიდეთ წინ და ვთქვათ, მე ახლა% i, წარმატებული, ო. და მე ვაპირებ შეაერთედ ღირებულება i. და თავზე, რადგან ეს არის CS50 ბიბლიოთეკა, მე ვაპირებ წავიდეთ წინ და მოიცავს ასე რომ ჰქონდეს ამ ფუნქციას. მაგრამ მოდით განიხილავს, თუ რა ხაზი 9 უნდა აკეთებს. მე ვაპირებ წაშლა ამ საბოლოოდ. ეს არაფერი აქვს ჩემი მთავარი მიზანია. მაგრამ eprintf, შეცდომა printf, მხოლოდ იმას ნიშნავდა, მომეცი ზოგიერთი დიაგნოსტიკური ინფორმაცია. როდესაც მე აწარმოებს ჩემი პროგრამა, მინდა ვხედავ ამ ეკრანზე დროებით ასევე უბრალოდ უნდა გვესმოდეს, რა ხდება. 

და, რა თქმა უნდა, თითოეულ iteration აქ line 9 მე მინდა, რომ, რა არის ღირებულება i? რა არის ღირებულება i? რა არის ღირებულება i? და, იმედია, მე უნდა მხოლოდ ვხედავთ, რომ გაგზავნა, ასევე, 10-ჯერ. 

ნება მომეცით წავიდეთ წინ და recompile ჩემი პროგრამა, როგორც მე მაქვს ამის გაკეთება ნებისმიერ დროს მე, რათა ცვლილება. ./buggy2. ახლა კი OK. არსებობს კიდევ ბევრი ხდება. ნება მომეცით, გადახვევა მდე კიდევ უფრო დიდი ფანჯარა. 

და დაინახავთ, რომ თითოეული hashtags მაინც ბეჭდვა. მაგრამ შორის თითოეული მათგანი არის ამ დიაგნოსტიკური გამომავალი ფორმატირებული ასეთია. სახელი ჩემი პროგრამა აქ არის buggy2. სახელი ფაილი buggy2.c. ხაზის ნომერი, რომელიც ეს იყო დაბეჭდილი ხაზი 9. და შემდეგ მარჯვნივ რომ არის შეცდომა, რომ მე ელოდება. 

და რა ლამაზი არის, რომ ახლა მე არ უნდა აუცილებლად იმედი ჩემი უფროსი, რა ჩემი პროგრამა აკეთებს. მე ვხედავ, რომ პირველი iteration არის 0, შემდეგ 1, 2, მაშინ 3, მაშინ 4, მაშინ 5, 6-, მაშინ 7, შემდეგ 8, შემდეგ 9, შემდეგ 10. ასე რომ, დაველოდოთ წუთში. რა ხდება აქ? მე მაინც, როგორც ჩანს იმედი როგორც განკუთვნილი 10-მდე. 

მაგრამ სად უნდა დაიწყოს? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. ასე რომ, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11 თითი მიუთითებს პრობლემა. მე, როგორც ჩანს არ ითვლება არასწორად ჩემი loop. ვიდრე წასვლა 10 iterations, მე დაწყებული 0, მე დამთავრებული და საშუალებით 10. არამედ იმიტომ, რომ, როგორც კომპიუტერი, მე დაწყებული დათვლა 0, მე უნდა დამთვლელი მდე , მაგრამ არა, 10. 

ასე რომ, სარემონტო, მე საბოლოოდ მიხვდა, აქ არის ერთი ორი რამ. მე შეიძლება ძალიან უბრალოდ ვთქვა, ითვლიან მდე არანაკლებ 10. ასე რომ, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, რომელიც, მართლაც, სწორი, მიუხედავად იმისა, რომ ჟღერს ცოტა არასწორია. ან მე ვერ გავაკეთებ ნაკლებია ან ტოლი 9, სანამ მე იწყება 0. ან თუ თქვენ ნამდვილად არ მინდა, რომ თქვენ შეგიძლიათ იმედი მეშვეობით 10 მაგრამ იწყება 1. თუმცა ისევ და ისევ, ეს უბრალოდ არ არის, რომ გავრცელებული. In პროგრამირების თუმცა არა იმდენად ნულიდან მაგრამ პროგრამირების C და სხვა ენებზე, როგორიცაა JavaScript და Python და სხვები, უბრალოდ ძალიან გავრცელებული ჩვენი დისკუსიის ორობითი უბრალოდ დაიწყება დათვლის დროს დაბალი შეგიძლიათ, რომელიც არის 0. კარგი. ასე რომ, eprintf. ისევ და ისევ, ახლა რომ მე figured out my პრობლემა, და მე ვაპირებ დაბრუნდეს 0 მეშვეობით არანაკლებ 10, მე ვაპირებ წავიდეს და წაშლა eprintf. 

ეს არ უნდა იყოს, როდესაც მე მოვახდენთ ჩემი კოდი ან წარმოადგინოს ჩემი კოდი და აჩვენებს, რომ ვინმეს. ეს მართლაც მხოლოდ იმას ნიშნავდა, უნდა იყოს გამოყენებული დროებით. მაგრამ ახლა მე დაფიქსირდა ამ კერძოდ პრობლემაა. 

ისე, მოდით გავაკეთოთ კიდევ ერთი მაგალითია აქ რომ მე ვაპირებ რომ whip up ასეთია. მე ვაპირებ წავიდეთ წინ და მოიცავს. $ 50 და მე ვაპირებ წავიდეთ წინ და მოიცავს. 

და მე ვაპირებ გადარჩენა ამ ფაილს, როგორც buggy3.c. და მე ვაპირებ წავიდეთ წინ და აცხადებენ, int ძირითადი (void). და შემდეგ შიგნით არსებობს მე ვაპირებ ამის გაკეთებას int i _ - მე მინდა, რომ პროგრამის განხორციელება ერთად get_negative_int. ეს არ არის ფუნქცია, რომელიც არსებობს ამჟამად. ასე რომ, ჩვენ ვაპირებთ განახორციელოს ეს მხოლოდ ერთი წუთით. მაგრამ ჩვენ ვაპირებთ, თუ რატომ ეს buggy პირველ რიგში უღელტეხილზე. და კიდევ მე მიღებული int ეხლა შესახებ, მე უბრალოდ აპირებს ბეჭდვა% i არის უარყოფითი რიცხვი, წარმატებული, ო, მძიმე, i. სხვა სიტყვებით, ყველა მე გვინდა, რომ ეს პროგრამა უნდა გააკეთოს არის კიდევ უარყოფითი int საწყისი შესახებ და შემდეგ ამობეჭდოთ რომ ასეთი და ასეთი უარყოფითი int. 

ახლა მე უნდა განახორციელოს ამ ფუნქციას. ასე რომ, შემდეგ ჩემი ფაილი, მე ვაპირებ წასვლა წინ და აცხადებენ ფუნქცია მოუწოდა get_negative_int (void) - და ჩვენ დაბრუნდება რა, რომ ხაზი იმას ნიშნავს, კიდევ ერთხელ ამ მომენტში int n; გავაკეთოთ do ასეთია printf n არის :. და შემდეგ მე ვაპირებ ამის n - get_int, და ამის გაკეთება, ხოლო n მეტია 0. ხოლო შემდეგ დაბრუნდნენ n ;. 

ასე რომ, არსებობს უამრავი მიმდინარეობს ეს თუმცა არც ერთი მათგანი ჩვენ არ შევხედოთ გასულ კვირას, მინიმუმ მოკლედ. ასე რომ, on line 10 აქ მე გამოაცხადა ფუნქცია მოუწოდა get_negative_int, და მე დააყენა (void), ამ ფრჩხილებში, იმ მიზეზით, რომ ამ არ იღებს შეყვანა. მე არ გავლის არაფერი ამ ფუნქციას. მე უბრალოდ მიღების რაღაც უკან მას. 

და რა მე იმ იმედით, რომ დავუბრუნდეთ არის მთელი რიცხვი. არ არსებობს მონაცემები ტიპის C მოუწოდა negative_int. ეს მხოლოდ int, ასე რომ, ის აპირებს უნდა იყოს ჩვენთვის, რათა დავრწმუნდეთ, რომ ღირებულება, რომელიც, ფაქტობრივად, დაბრუნებული არ არის მხოლოდ int მაგრამ ასევე უარყოფითი. 

On line 12 მე გამოცხადების ცვლადი მოუწოდა N და რაც ტიპის int. ხოლო შემდეგ ხაზი 13 გზით 18 ვარ თავისსავე ხოლო რაღაც მართლაც ასეა. მე ვაპირებ წინ და ბეჭდვა n არის, მსხვილი ნაწლავის და მაშინ სივრცე, როგორიცაა ზოლში შესახებ. 

მე მაშინ მოუწოდებს get_int და შენახვის ე.წ. დაბრუნების ღირებულება რომ ცვლადი ო. მაგრამ მე ვაპირებ აკეთეთ ხოლო n მეტია 0. სხვა სიტყვებით, თუ მომხმარებელი მაძლევს int და, რომ ნომერი მეტია 0, ergo, დადებითი, მე ვაპირებ უბრალოდ შეინახოს reprompting შესახებ, შენარჩუნება reprompting, აიძულებენ უნდა ითანამშრომლონ და მომეცი უარყოფითი int. 

და კიდევ n არის რეალურად negative-- ვარაუდობენ მომხმარებლის საბოლოოდ სახის -50, შემდეგ ამ ხოლო loop აღარ არის ჭეშმარიტი იმიტომ -50 არ არის უფრო მეტი, ვიდრე 0. ასე რომ, ჩვენ შესვენება გარეთ რომ loop ლოგიკურად და დაბრუნდნენ n. 

მაგრამ არსებობს ერთი სხვა რაც უნდა გააკეთოს. და მე შემიძლია უბრალოდ ამისათვის მიერ გადაწერა და pasting ერთი ხაზი კოდი ზედა ფაილი. მე უნდა ავუხსნათ, Clang, და გპირდებით, რომ Clang, მკაფიოდ, რომ მე, მართლაც, წასვლა და განხორციელება ამ ფუნქციის get_negative_int. ეს შეიძლება იყოს ქვედა ფაილი. კიდევ ერთხელ გავიხსენოთ, რომ Clang ნათქვამია რამ ზემოდან, მარცხნიდან მარჯვნივ, ასე რომ თქვენ არ შეუძლია მოვუწოდებთ ფუნქცია თუ Clang არ ვიცი, ის აპირებს, რომ არსებობს. 

ახლა, სამწუხაროდ, ეს პროგრამა, როგორც ზოგიერთი თქვენ ალბათ შენიშნა, უკვე buggy. ნება მომეცით წავიდეთ წინ და მიიღოს buggy3. იგი ადგენს, ასე რომ ჩემი პრობლემა ახლა არ არის სინტაქსური შეცდომა, როგორც ტექსტური შეცდომა, ეს რეალურად იქნება ლოგიკური შეცდომა, რომ მე შეგნებულად გააკეთა, როგორც საშუალება ნაბიჯ მეშვეობით, თუ რა ხდება. 

მე ვაპირებ წავიდეთ წინ ახლა და აწარმოებს buggy3. და მე ვაპირებ წასვლა წინ და არ ითანამშრომლებს. მე ვაპირებ, რათა ეს ნომერი 1. ეს არ მოსწონს, ასე რომ ის რითაც მე კიდევ ერთხელ. 

როგორ შესახებ 2? 3? 50? არც იმ მუშაობენ. როგორ შესახებ -50? და პროგრამა ჩანს მუშაობა. 

ნება მომეცით ცდილობენ ეს კიდევ ერთხელ. ნება მომეცით ცდილობენ -1, როგორც ჩანს მუშაობა. ნება მომეცით ცდილობენ -2, როგორც ჩანს მუშაობა. ნება მომეცით ცდილობენ 0. Huh, რომ არასწორია. ახლა, ჩვენ რომ ცოტა pedantic აქ. მაგრამ ეს, რა თქმა უნდა, იმ შემთხვევაში, რომ 0 არც დადებითი და არც უარყოფითი. ასე რომ, ის ფაქტი, რომ ჩემი პროგრამა განაცხადა, რომ 0 არის უარყოფითი რიცხვი, ეს არ არის ტექნიკურად სწორი. 

ახლა, რატომ აკეთებს ამას? ისე, ეს შეიძლება იყოს აშკარა. და, მართლაც, პროგრამა იგულისხმება, რომ იყოს საკმაოდ მარტივია ასე რომ, ჩვენ გვაქვს რაღაც შეისწავლონ. 

მაგრამ მოდით გააცნობს მესამე გამართვის ტექნიკა აქ მოუწოდა debug50. ასე რომ, ეს არის პროგრამა რომ ჩვენ უბრალოდ შექმნა ამ წელს სახელწოდებით debug50 რომელიც საშუალებას გაძლევთ, გამოიყენოს რასაც ჩაშენებული გრაფიკული debugger in CS50 IDE. და debugger არის პროგრამა, რომელიც ზოგადად გაძლევთ აწარმოებს თქვენი პროგრამის მაგრამ ნაბიჯ ნაბიჯ-ნაბიჯ, ხაზი მიერ ხაზს, დაპაუზება, გააღიზიანოს გარშემო, ეძებს ცვლადები ისე, რომ პროგრამა არ უბრალოდ აფეთქება წარსულში თქვენ და სწრაფად ბეჭდვა რაღაც თუ არა ბეჭდვა რაღაც. ეს გაძლევთ შესაძლებლობა, ადამიანის სიჩქარე, ურთიერთქმედება იგი. 

და ამის გაკეთება, თქვენ უბრალოდ ამის შემდეგ. მას შემდეგ, რაც შედგენა თქვენი კოდი, რომელიც მე უკვე გააკეთა, buggy3, თქვენ წავიდეთ წინ და აწარმოებს debug50 ./buggy. ასე ჰგავს help50 აქვს თქვენ აწარმოებს help50 და შემდეგ ბრძანება, debug50 აქვს თქვენ აწარმოებს debug50 და შემდეგ სახელი ბრძანება. 

ახლა უყურებს, რა მოხდება ჩემი ეკრანზე, მარჯვენა მხარეს, კერძოდ. როდესაც მე მოხვდა Run, ყველა უეცრად ეს მარჯვენა პანელი ხსნის ეკრანზე. და იქ ბევრი აპირებს on ერთი შეხედვით. მაგრამ იქ არ არის ძალიან ბევრი ფიქრი არ არის. 

ეს აჩვენებს, ყველაფერი, რომ ხდება შიგნით ჩემი პროგრამა ახლავე და მეშვეობით ამ ღილაკები ზევით შემდეგ საშუალებას ჩემთვის დაიხევს მეშვეობით my კოდი საბოლოო ჯამში, ნაბიჯ-ნაბიჯ-ნაბიჯ. მაგრამ არა მხოლოდ ამჟამად. ყურადღება მიაქციეთ, რა ხდება. ჩემი ტერმინალის ფანჯარაში მე მიმდინარეობს აიძულა n. და მე ვაპირებ წავიდეთ წინ და ითანამშრომლონ ამ დროს და ტიპის -1. და თუმცა ცოტა cryptically, -1 უარყოფითი რიცხვი, როგორც მოსალოდნელი იყო. 

და მაშინ ბავშვი დასრულების ერთად სტატუსი 0 GDBserver არსებული. GDB, GNU Debugger, არის სახელი ძირითადი პროგრამული უზრუნველყოფა რომელიც ახორციელებს ამ debugger. მაგრამ ყველა ეს ნამდვილად იმას ნიშნავს, რომ debugger წავიდა იმიტომ, რომ ჩემი პროგრამა დატოვა და ყველა კარგად იყო. თუ მინდა, რომ ნამდვილად გამართვის ჩემი პროგრამა, მაქვს წინასწარ გეტყვით debug50, სად მინდა, რომ დაიწყოს სტეპინგზე მეშვეობით ჩემი კოდი? 

და, ალბათ, ყველაზე მარტივი გზა უნდა გავაკეთოთ, რომ ასეთია. თუ მე hover მეტი წყალსაწრეტი ჩემი რედაქტორი აქ, ასე რომ, მართლაც, მხოლოდ sidebar აქ, მარცხნივ ხაზის ნომერი, გაითვალისწინეთ, რომ თუ მე უბრალოდ დააჭირეთ ერთხელ, მე პატარა წითელი dot. და რომ პატარა წითელი dot, როგორიცაა გაჩერების ნიშანი, ნიშნავს, hey, debug50, პაუზის აღსრულების ჩემი კოდი უფლება, როდესაც მე აწარმოებს ამ პროგრამის. 

მოდით გავაკეთოთ, რომ. ნება მომეცით წავიდეთ წინ და აწარმოებს ჩემი პროგრამა კვლავ debug50 ./buggy3, შეიტანეთ. და ახლა, ცნობა, რაღაც სხვადასხვა მოხდა. მე არ მიმდინარეობს აიძულა ჯერ ჩემი ტერმინალის ფანჯარაში არაფერი, იმიტომ, რომ მე არ მაქვს მიღებული არსებობს ამჟამად ჩემი პროგრამა. გაითვალისწინეთ, რომ on line 8 რომელიც ახლა ხაზი გაუსვა, და იქ პატარა ისარი მარცხენა გამონათქვამი, თქვენ შეჩერებულია აქ. ეს ხაზი კოდი, ხაზი 8, ჯერ კიდევ არ არის შესრულებული. 

და რა არის საინტერესო, თუ გავითვალისწინებთ მეტი აქ მარჯვენა მხარეს, შეამჩნია, რომ მე ადგილობრივი ცვლადი, ადგილობრივი იმ გაგებით, ის, რომ ქვეყნის შიგნით მიმდინარე ფუნქცია. და მისი ღირებულება, როგორც ჩანს, ჩვეულებრივ, და ერთგვარი მოხერხებულად, არის 0. მაგრამ მე არ აკრიფოთ 0. რომ რაღაც უნდა იყოს მისი რა მნიშვნელობა მომენტში. 

ნება მომეცით, წავიდეთ წინ და ამის გაკეთება ახლა. ნება მომეცით წავიდეთ წინ და ზედა მარჯვენა აქ, მე ვაპირებ წავიდეთ წინ და დააჭირეთ ამ პირველი ხატი, რომელიც ნიშნავს ნაბიჯი მეტი რაც იმას ნიშნავს, არ გამოტოვოთ , მაგრამ ნაბიჯ ამ ხაზი კოდი, შესრულებაში მას გზაზე. 

ახლა კი, შეამჩნია, ჩემი სწრაფი ახლახანს შეიცვალა. რატომ არის, რომ? მე ვუთხარი debug50, აწარმოებს ამ ხაზი კოდი. რას ნიშნავს ეს ხაზი კოდი გავაკეთოთ? მოთხოვნა ჩემთვის int. კარგი. მიადევნე თვალი ითანამშრომლოს. ნება მომეცით წავიდეთ წინ არის და ჩაწერეთ -1, შეიტანეთ. და ახლა შეამჩნია, რაც შეიცვალა. მარჯვენა მხარეს, ჩემი ადგილობრივი ცვლადი i არის მითითებული, როგორც -1 ახლა. და ეს კიდევ ტიპის int. 

და გაფრთხილების, ძალიან, ჩემი ე.წ. სტეკი, სად მე პაუზის? ჩვენ გაიგო უფრო მეტი ეს მომავალში. მაგრამ სტეკი უბრალოდ ეხება რა ფუნქციები გაკეთებული მოძრაობაში. ახლა ის უბრალოდ ძირითადი. და ახლა მხოლოდ ადგილობრივი ცვლადი i ღირებულების 1. 

და როცა საბოლოოდ გადადგას ამ ონლაინ აქ, რომ იგივე ხატი ზედა მარჯვენა, -1 არის უარყოფითი რიცხვი. ახლა ის დაპაუზება გამო, რომ Curly გაუწიოს. მოდით ასეც გააკეთებს რამ. მე ნაბიჯ გამო, რომ ხაზი, და voila. 

ასე არ არის ყველა, რომ საშინლად ნათელი არ არის, მაგრამ ის ნება მომეცით პაუზის და ვფიქრობ ლოგიკურად რა ეს პროგრამა აკეთებს. მაგრამ ეს არ იყო მცდარი შემთხვევაში. მოდით ეს კიდევ ერთხელ გავაკეთოთ ასეთია. 

მე ვაპირებ დატოვება, რომ breakpoint on line 8 წითელი dot. მე ვაპირებ გამეორება debug50. ეს ავტომატურად paused აქ. მაგრამ ამ დროს, ნაცვლად სტეპინგზე მეტი ამ ხაზის, ნება მომეცით რეალურად წასვლა შიგნით get_negative_int და გაერკვნენ, რატომ არის ის მიღება 0 როგორც მოქმედი პასუხი? 

ასე რომ, ნაცვლად დაჭერით ნაბიჯი მეტი. მე ვაპირებ წავიდეთ წინ და დააჭირეთ Step Into. და შენიშნავს, რომ ხაზი 8, რომ ახლა ყურადღება გაამახვილა ახლა მოულოდნელად ხდება ხაზი 17. 

ახლა, ეს არ ნიშნავს, რომ debugger აქვს გამოტოვებენ ხაზები 14 და 15 და 16. ეს უბრალოდ არ არის არაფერი რომ ნახოთ, თუ არსებობს. ეს მხოლოდ გამოცხადების ცვლადები, და შემდეგ იქ სიტყვას და შემდეგ ღია Curly გაუწიოს. მხოლოდ ფუნქციური ხაზი, რომელიც არის წვნიანი ნამდვილად არის ერთი აქ, 17. და რომ სადაც ჩვენ შეჩერებულია ავტომატურად. 

ასე რომ, printf ( "n.is:") ;, ასე რომელიც ჯერ არ მომხდარა. მოდით წავიდეთ წინ და დააჭირეთ გადახვიდე. ახლა ჩემი სწრაფი, მართლაც, შეიცვალა ( "ო"). ახლა get_int, მე არ ვაპირებ შეწუხება სტეპინგზე შევიდა, იმიტომ, რომ ფუნქცია სანახავად CS50 ბიბლიოთეკა. ეს სავარაუდოდ სწორი. 

ამიტომ, მე ვაპირებ წავიდეთ წინ და ერთგვარი ითანამშრომლოს ვაძლევთ მას int, მაგრამ არ არის ნეგატიური int. ნება მომეცით წავიდეთ წინ და მოხვდა 0. და ახლა, რა ხდება აქ როდესაც მე ქვემოთ ხაზი 21? მე არ iterated ერთხელ. მე არ ჩანს, დავრჩებოდით რომ ციკლი. სხვა სიტყვებით, ეს ყვითელი ბარი არ შეინახოს აპირებს გარშემო, და მის გარშემო, და გარშემო. 

ახლა, რატომ არის, რომ? ისე, n, რა არის N ახლა? შემიძლია შევხედოთ ადგილობრივი ცვლადები debugger. N არის 0. ყველა უფლება, რა იყო ჩემი მდგომარეობა? 

20-- ხაზი 20, ასევე, 0 მეტია 0. ეს ასე არ არის. 0 არ არის უფრო მეტი, ვიდრე 0. და ასე დაიწყო ამ. 

და ამიტომაც on line 21, თუ რეალურად გაგრძელდება, მე ვაპირებ დაბრუნებას 0, მაშინაც კი, მიუხედავად იმისა, რომ მე არ უნდა უარყო 0 როგორც რეალურად არ უარყოფითი. ასე რომ, ახლა მე ნამდვილად არ კი აინტერესებს debugger. მივიღე ეს, მე არ უნდა ვიცი, რა უფრო ხდება. 

ამიტომ, მე ვაპირებ წავიდეთ წინ და უბრალოდ დააჭირეთ Play ღილაკს, და მოდით ეს ფერი up. ახლა, მე მივხვდი, რომ ჩემი bug აშკარად on line 20. ეს არის ჩემი ლოგიკური შეცდომა. 

ასე რომ, რა არ მინდა უნდა გავაკეთოთ, რომ შეიცვალოს ეს? თუ პრობლემა არის ის, რომ მე არ ვარ გამოჭერის 0, უბრალოდ ლოგიკური შეცდომა. და შემიძლია ვთქვა, ხოლო n მეტია ან ტოლია 0, შევინარჩუნოთ რამაც მომხმარებლის ისევ და ისევ. 

ასე რომ, კიდევ ერთხელ, შეცდომა, ალბათ, კი ნათელია, როდესაც დაინახა, წერენ, რომ ეს მხოლოდ რამდენიმე წუთის წინ. მაგრამ takeaway აქ ის არის, რომ გამართვის 50, და debugging პროგრამული უზრუნველყოფა უფრო ზოგადად, თქვენ გაქვთ ეს ახალი ი ძალა გავლა საკუთარი კოდი, გამოიყურება მეშვეობით, რომ მარჯვენა პანელი, რაც თქვენი ცვლადები ღირებულებები. ასე, რომ თქვენ არ არის აუცილებელი უნდა გამოვიყენოთ რაღაც როგორც თქვენ eprintf ბეჭდვა იმ ღირებულებებს. თქვენ შეგიძლიათ რეალურად ვხედავთ მათ ვიზუალურად ეკრანზე. 

ახლა, მიღმა, აღსანიშნავია, რომ რომ არსებობს კიდევ ერთი ტექნიკა, რომელიც არის რეალურად სუპერ საერთო. და თქვენ ალბათ საინტერესოა, რატომ ამ პატარა ბიჭი უკვე იჯდა სცენაზე. ასე რომ, ამ ტექნიკით, ზოგადად ცნობილია, როგორც რეზინის იხვი გამართვის, რაც ნამდვილად არ არის მხოლოდ პატივისცემის იმ ფაქტს, რომ ხშირად, როდესაც პროგრამისტები წერა კოდი, ისინი არ ემთხვეოდეს თანამშრომლობს სხვები, ან სამუშაო საერთო გარემოს. 

ისინი სახის სახლში. შესაძლოა, ეს გვიან ღამით. ისინი ცდილობენ ფიგურა გარკვეული ხარვეზების მათი კოდი. და ისინი უბრალოდ არ ხედავს მას. 

და არ არსებობს roommate. არ არსებობს TF. არ არსებობს CA გარშემო. ყველა მათ აქვთ მათ შელფზე ეს არის პატარა რეზინის ducky. 

ასე რომ, რეზინის იხვი გამართვის მხოლოდ ამ მოწვევის ვფიქრობ რაღაც, როგორც სულელური რადგან ეს, როგორც რეალური არსება, და რეალურად გავლა თქვენი კოდი სიტყვიერი ამ inanimate ობიექტი. ასე, მაგალითად, თუ ეს არის ჩემი მაგალითად აქ და გავიხსენოთ, რომ ადრე პრობლემა იყო, თუ წავშალო ეს პირველი ხაზი კოდი, და მე, წავიდეთ წინ და buggy 0, კიდევ ერთხელ, გავიხსენოთ, რომ მე მქონდა ეს შეცდომის შეტყობინებები აქ. ასე რომ, იდეა აქ, სასაცილოა, თუმცა მე გრძნობს მომენტში ამით საჯაროდ, ის არის, რომ შეცდომა. 

OK, ასე რომ, ჩემი პრობლემა ის არის, რომ მე მინიშნებით განაცხადა ბიბლიოთეკა ფუნქცია. და რომ ბიბლიოთეკის ფუნქცია printf. Declare-- OK, აცხადებენ, მაგონებს პროტოტიპები. 

ეს ნიშნავს, რომ მე უნდა რეალურად გითხრათ შემდგენელი წინასწარ რა ფუნქცია ჰგავს. ერთი წუთი მაცადე. მე არ მაქვს სტანდარტული io.h. ძალიან დიდი მადლობა. 

ასე რომ, მხოლოდ ეს პროცესი of-- თქვენ არ უნდა რეალურად იხვი. მაგრამ ეს იდეა ფეხით თავს მეშვეობით საკუთარი კოდი ასე რომ, თქვენ კი მოისმინოს თავს, ასე რომ თქვენ გააცნობიეროს ხარვეზების საკუთარი შენიშვნები, ზოგადად იდეა. 

და, ალბათ უფრო ლოგიკურად, ასე არ არის ბევრი, რომ ერთი, არამედ უფრო ჩართული მაგალითად, ჩვენ უბრალოდ გააკეთა buggy 3.C, თქვენ ფეხით თავს მეშვეობით შემდეგნაირად. ასე რომ, ყველა უფლება, რეზინის ducky, DDB, თუ გნებავთ. აქ ჩვენ გვაქვს ჩემი მთავარი ფუნქცია, მე ამას უარყოფითი int. 

და მე მიღების დაბრუნებული მნიშვნელობა. მე შენახვის მას მარცხენა მხარეს on line 8 ცვლადში i. OK, მაგრამ დაველოდოთ, როგორ რომ მიიღოს, რომ მნიშვნელობა? მიადევნე თვალი შევხედოთ ფუნქცია ხაზი 12. 

ხაზი 12, ჩვენ გვაქვს უარყოფითი int. არ მიიღოს ნებისმიერი საშუალებებით, ამჯამად დაბრუნების int, OK. ვაცხადებ, on line 14 ცვლადი ო. ის აპირებს შესანახად რიცხვი. აი რა მინდა. 

ასე რომ, ამის შემდეგ, ხოლო n is-- მიადევნე მომეცით გაუქმება, თუ რა სარემონტო მე უკვე გააკეთა. ასე რომ, ხოლო n მეტია 0, ამობეჭდოთ n არის, OK. და შემდეგ მისაღებად int ინახება n. და შემდეგ შეამოწმეთ თუ N არის 0 n არის not-- ეს არის. ასე რომ, კიდევ ერთხელ, თქვენ არ უნდა ფაქტობრივი იხვი. მაგრამ მხოლოდ ფეხით საკუთარ თავს თქვენი კოდი, როგორც ინტელექტუალური სწავლება ხშირად დაგეხმაროთ გააცნობიეროს, თუ რა ხდება, განსხვავებით მხოლოდ თავისსავე როგორც ეს, staring at ეკრანზე, და არ ვსაუბრობთ თავს მეშვეობით ის, რაც პატიოსნად არ არის თითქმის როგორც ეფექტური ტექნიკით. ასე რომ თქვენ გაქვთ ის, რაოდენობით სხვადასხვა ტექნიკა რეალურად debugging თქვენი კოდი და მოძიებაში ბრალია, რაც უნდა იყოს ინსტრუმენტები თქვენს ინსტრუმენტარიუმის ასე, რომ თქვენ არ გვიან ღამით, განსაკუთრებით, თქვენ სასადილო დარბაზები, ან საათებში, banging თქვენი უფროსის წინააღმდეგ კედელი, ცდილობს გადაწყვიტოს ზოგიერთი პრობლემა. გააცნობიეროს, რომ არსებობს პროგრამული ინსტრუმენტების. არსებობს რეზინის იხვი ინსტრუმენტები. და იქ მთელი პერსონალი მხარს ვუჭერთ ელოდება სარგებლის მხრივ. 

ასე რომ, ახლა, სიტყვა პრობლემის კომპლექტი, და ის, რაც ჩვენ იმ იმედით გავიდნენ და როგორ ჩვენ შესახებ შეფასებისას. პოსტი რა თქმა უნდა, სილაბუსი, CS50 პრობლემა კომპლექტი ფასდება ოთხი ძირითადი ღერძი, ასე რომ, ვთქვათ ფარგლებში, სისწორეში, დიზაინი, და სტილი. და ფარგლები უბრალოდ ეხება, თუ რამდენად ცალი თქვენ bitten off? რამდენი პრობლემა სცადა? რა დონის ძალისხმევა თქვენ გამოიხატება? 

სისწორე არის, პროგრამა მუშაობს როგორც ეს უნდა ერთ CS50 დაზუსტება როდესაც თქვენ გარკვეული საშუალებებით ან გარკვეული შედეგები ბრუნდება? დიზაინი არის ყველაზე სუბიექტური მათგანი. და ეს არის ერთ-ერთი, რომელიც , ყველაზე დიდი უნდა ვისწავლოთ და გრძელი ასწავლიან, ამ იმდენად, რამდენადაც ეს boils ქვემოთ, რამდენად კარგად დაწერილი თქვენი კოდი? 

ეს არის ერთი რამ მხოლოდ ბეჭდვა სწორი შედეგები ან დაბრუნებას მარჯვენა ღირებულებებს. მაგრამ აკეთებ, როგორც ეფექტურად შეიძლება? თქვენ აკეთებთ ეს გათიშე და დაიპყროთ, ან ორობითი ძიების როგორც ჩვენ მალე დაინახავთ, რომ ჩვენ გავაკეთეთ ორი კვირის წინ სატელეფონო წიგნი? არსებობს უკეთესი გადაჭრის გზები პრობლემა, ვიდრე თქვენ გაკეთებული გაქვთ? ეს არის შესაძლებლობა უკეთესი დიზაინი. 

და მაშინ style-- როგორ საკმაოდ თქვენი კოდი? თქვენ შეამჩნევთ, რომ მე საკმაოდ კერძოდ წაწევის ჩემი კოდი, და მიღების დარწმუნებული ვარ, ჩემი ცვლადები გონივრულად დაასახელა. n, ხოლო მოკლედ, არის კარგი სახელი ნომერი, მე დათვლის რიცხვი, s სიმებიანი. და ჩვენ შეგვიძლია აღარ ცვლადი სახელები სტილი. სტილი, თუ რამდენად კარგი ჯერ თქვენი კოდი გამოიყურება? და როგორ იკითხება ეს? 

და დროთა განმავლობაში, რა თქვენი TAs და TFs გავაკეთებ, რა თქმა უნდა ეს მოგაწვდით, რომ სახის ხარისხიანი კავშირი ასე რომ თქვენ უკეთ იმ სხვადასხვა ასპექტებს. და თვალსაზრისით, თუ როგორ შეაფასოს თითოეული ამ ცულები, ეს, როგორც წესი, ძალიან ცოტა თაიგულების ასე, რომ თქვენ, როგორც წესი, მისაღებად გრძნობა რამდენად კარგად თქვენ აკეთებთ. და, მართლაც, თუ იღებთ ქულა ნებისმიერი იმ ღერძი სისწორეში, დიზაინი და სტილი especially--, რომ ნომერი ზოგადად, 1-დან 5. და, ფაქტიურად, თუ თქვენ მიღების 3 დაწყების სემესტრის ეს არის ძალიან კარგი რამ. ეს იმას ნიშნავს, რომ ის ჯერ კიდევ ოთახი გაუმჯობესება, რომელიც თქვენ იმედი in აღების კლასის პირველად. არსებობს იმედია ზოგიერთი ცოტა ჭერი რომელიც თქვენ მიისწრაფვის მიაღწია. ასე რომ, მიღების 3-ის შესახებ ადრეული ცალი, თუ არა, 2 და 4-ის, მართლაც კარგია. ეს კარგად ფარგლებში სპექტრი, კარგად მოლოდინი. 

და თუ თქვენი გონება racing, დაველოდოთ ერთი წუთით, ხუთიდან სამი. ეს მართლაც 6 out of 10. ეს არის 60%. ღმერთო ჩემო, ეს არის ის, F. 

არ არის. ეს არ არის, ის ფაქტი, რომ. უფრო მეტიც, ეს შესაძლებლობა გააუმჯობესოს მეტი კურსი სემესტრი. და თუ თქვენ მიღების რამდენიმე Poors, ეს არის შესაძლებლობა ისარგებლოს საათებში, რა თქმა უნდა, განყოფილებები და სხვა რესურსები. 

საუკეთესო არის შესაძლებლობა, მართლაც, საამაყო, თუ რამდენად შორს თქვენ გადმოდიოდნენ კურსი სემესტრი. ასე რომ გააცნობიეროს, თუ არაფერი სხვაგან, სამი არის კარგი. და ეს საშუალებას ოთახი ზრდის დროთა განმავლობაში. 

რაც შეეხება, როგორ იმ ღერძი შეწონილი, რეალურად თქვენ დახარჯავს ყველაზე თქვენი დრო მიღების რამ მუშაობა, რომ აღარაფერი ვთქვათ სწორად. და ასე სისწორის ტენდენცია გაანგარიშება ყველაზე, როგორც ამ multiplicative ფაქტორი სამი. დიზაინი ასევე მნიშვნელოვანია, მაგრამ ის, რომ თქვენ არ არის აუცილებელი ატარებენ ყველა იმ საათი ცდილობს რამ უბრალოდ მუშაობა. 

ასე რომ, ეს შეწონილი ცოტა უფრო მსუბუქად. და მაშინ style შეწონილი მაინც. მიუხედავად იმისა, რომ არანაკლებ მნიშვნელოვანი ფუნდამენტურად, ეს, უბრალოდ, ალბათ, მარტივი რამ უნდა გააკეთოს, მარჯვენა ლიმიტირებით მაგალითები ჩვენ ამის ლექცია და სექციაში, რამ ლამაზად indented, და აღნიშნა, და სხვ შორის არის იოლი რამ უნდა გააკეთოს და მიიღოს უფლება. ასე რომ, როგორც ასეთი, გააცნობიეროს, რომ ეს არის რაოდენობა რომლებიც შედარებით ადვილად დაჯექი. 

და ახლა სიტყვა ამას აკადემიური პატიოსნება. ასე რომ პოსტი რა თქმა უნდა, სილაბუსი, ნახავთ რომ რა თქმა უნდა აქვს საკმაოდ ცოტა ენის გარშემო. და რა თქმა უნდა, იღებს საკითხი აკადემიური პატიოსნება საკმაოდ სერიოზულად. 

ჩვენ გვყავს განსხვავება, უკეთესი ან უარესი, რომელმაც იგზავნება ყოველი წლის მეტი სტუდენტები დისციპლინარული ზომების ვიდრე ყველაზე ნებისმიერი სხვა რა თქმა უნდა, რომ მე ვარ იცის. ეს არ არის აუცილებელი მიუთითებს ის ფაქტი, რომ CS სტუდენტები, ან CS50 სტუდენტები, რომლებიც ნაკლებად პატიოსანი, ვიდრე თქვენი თანაკლასელები. მაგრამ რეალობა, რომ ამ მსოფლიოში, ელექტრონულად, ჩვენ უბრალოდ ტექნოლოგიურ ნიშნავს გამოვლენის. 

მნიშვნელოვანია, რომ ჩვენს სამართლიანობის მასშტაბით კლასის რასაც ჩვენ ვაკეთებთ, აღმოაჩინოს ეს, და დააყენებს საკითხი, როდესაც ჩვენ ვხედავთ რამ. და მხოლოდ ხატავს სურათს, და მართლაც დაეხმაროს რაღაც ამ რადიატორის, ეს არის ნომრები სტუდენტები გასული 10 წლის განმავლობაში რომ უკვე ჩართული ზოგიერთი ისეთი საკითხები, აკადემიური პატიოსნება, ზოგიერთი 32 სტუდენტი შემოდგომაზე 2015, რომელიც უნდა ვთქვა, რომ ჩვენ არ მიიღოს ამ საკითხზე ძალიან სერიოზულად. და, საბოლოო ჯამში, ეს ციფრები შესაქმნელად, ყველაზე ცოტა ხნის წინ, დაახლოებით 3%, 4% ან ასე კლასში. 

ასე რომ, სუპერ უმრავლესობა სტუდენტები როგორც ჩანს, რომ ხაზები ნათელი. მაგრამ არ გაქვთ ამ იბადება, განსაკუთრებით გვიან ღამით, როდესაც იბრძვიან ზოგიერთი გადაწყვეტა პრობლემა კომპლექტი, რომ არსებობს მექანიზმები მისაღებად თავს უკეთ მხარდაჭერა, ვიდრე თქვენ შეიძლება ვფიქრობ, თუნდაც ის, რომ საათი. გააცნობიეროს, რომ, როდესაც ჩვენ ვიღებთ სტუდენტი წარდგინება, ჩვენ გადაკვეთა შედარების ყოველ წარდგენის წელს წინააღმდეგ ყველა წარდგენის გასულ წელს, წინააღმდეგ ყველა წარდგენის 2007 და მას, ეძებს, ისევე, კოდი საცავებში შემოსული, ფორუმი, სამუშაო ადგილები. ჩვენ აღვნიშნო, რომ ეს, მართლაც, ყველა გულისთვის სრული გამჟღავნება, რომ თუ ვინმეს შეგიძლიათ ის ონლაინ, რა თქმა უნდა, ასე რომ შეიძლება ჩვენ, რა თქმა უნდა. თუმცა, რეალურად, სული რა თქმა უნდა, boils ქვემოთ ამ სტატიაზე სილაბუსში. ეს ნამდვილად არ არის, უბრალოდ, იყოს გონივრული. 

და თუ ჩვენ უნდა შეიმუშაოს, რომ უბრალოდ ცოტა მეტი ენის, გააცნობიეროს, რომ არსი ყველა მუშაობა, რომ თქვენ წარმოადგინოს ამ კურსის უნდა იყოს საკუთარი. მაგრამ შიგნით რომ, არსებობს რა თქმა უნდა შესაძლებლობები, და წახალისება, და პედაგოგიური ღირებულების გთხოვოთ others-- თავს, TFS, რომ CAS, TAs, და სხვა კლასის, მხარდაჭერა, რომ აღარაფერი ვთქვათ მეგობრები და მცენარეები, რომლებმაც შეისწავლეს CS და პროგრამირების ადრე. და ასე არ არის დახმარებას, რომ. და ზოგადი წესი thumb არის ამ, როდესაც დახმარებას ითხოვენ, თქვენ შეიძლება ნახოთ თქვენი კოდი სხვები, მაგრამ შეიძლება არ ნახოთ მათი. ასე რომ, თუ თქვენ იმ საათებში, ან D დარბაზში, ან სადმე სხვაგან მუშაობს რამდენიმე ცალი კომპლექტი, სამუშაო ერთად მეგობარს, რომელიც არის სრულიად ჯარიმა, იმ დღის ბოლოს თქვენი სამუშაო საბოლოო ჯამში, ეკუთვნის თითოეულ თქვენ შესაბამისად, და არ იქნება რამდენიმე ერთობლივი ძალისხმევა, გარდა იმისა, რომ საბოლოო პროექტი, სადაც ეს დაშვებული და წახალისებული. 

გააცნობიეროს, რომ იმ შემთხვევაში, თუ იბრძვიან რაღაც და თქვენი მეგობარი რაღაც უნდა იყოს უკეთესი ამ მაშინ, ან უკეთესი, რომ პრობლემა, ვიდრე თქვენ, ან ცოტა უფრო ადრე, ვიდრე თქვენ, ეს სრულიად გონივრული გახდეს თქვენს მეგობარს და ამბობენ, hey, მიგაჩნიათ იბადება ეძებს ჩემს კოდი აქ, მეხმარება რაშია რა ჩემი საკითხი არის? და, იმედია, ამ ინტერესი პედაგოგიური ღირებულება რომ მეგობარი არ მხოლოდ თქვათ, ამისათვის, არამედ, რას დაკარგული on line 6, ან რაღაც მსგავსი? მაგრამ გამოსავალი არ არის იმ მეგობარს შემდეგი თქვენ სათქმელია, რა, ასევე, აქ, ნება მომეცით დახევის ეს ყველაფერი, და ნახოთ ჩემი გამოსავალი თქვენთვის. ასე რომ, ხაზი. თქვენ თქვენი კოდი სხვები, მაგრამ თქვენ არ შეუძლია ნახოთ მათი, დაექვემედებროს შეზღუდვები, რა თქმა უნდა სილაბუსში. 

ასე რომ, გახსოვდეთ, ამ ე.წ. სინანული პუნქტი რა თქმა უნდა, სილაბუსი, ისევე, იმ შემთხვევაში, თუ თქვენ ჩაიდინოს ზოგიერთი აქტი, რომელიც არ არის გამართლებული, მაგრამ მოუტანს მას ყურადღება კურსის ხელმძღვანელები 72 საათის განმავლობაში, რა თქმა უნდა, შეიძლება დააწესოს ადგილობრივი სანქციები, შეიძლება შეიცავდეს არადამაკმაყოფილებელი ან ვერ კლასის მუშაობის წარმოდგენილი. მაგრამ რა თქმა უნდა არ ეხება აქვს მნიშვნელობა, შემდგომი დისციპლინური, გარდა იმ შემთხვევებისა, განმეორებითი აქტებით. სხვა სიტყვებით, თუ თქვენ, რომ გარკვეული სულელური, განსაკუთრებით გვიან ღამით, გადაწყვეტილების რომ მეორე დილით და ორი დღით შემდეგ, თქვენ ვიღვიძებ და გააცნობიეროს, რა იყო მე ფიქრი? თქვენ ამ CS50 გაქვთ outlet აფიქსირებს, რომ პრობლემა და ფლობს მდე, ასე, რომ ჩვენ თქვენ დაგხვდებათ შუა და გარიგება მას ამ საკითხზე, რომელიც, როგორც საგანმანათლებლო და მნიშვნელოვანი თქვენთვის, მაგრამ მაინც სადამსჯელო რამდენიმე გზა. და ახლა, მიიღოს პირას off, ეს. 

[ვიდეო აღწარმოების] 

[მუსიკის დაკვრა] 

[END აღწარმოების] დევიდ ჯ Malan: ყველა უფლება, ჩვენ უკან. და ახლა ჩვენ შევხედოთ ერთი პირველი ჩვენი რეალური სამყაროს დომენები CS50, ხელოვნების კრიპტოგრაფიის, ხელოვნების გაგზავნის და მიღების საიდუმლო შეტყობინებები, დაშიფრული შეტყობინებები თუ გნებავთ, რომელიც შეიძლება მხოლოდ გაშიფრა, თუ თქვენ გაქვთ ზოგიერთი ძირითადი ნივთიერება, რომელიც გამომგზავნი როგორც. ასე რომ მოტივაცია ამ მივიღებთ შევხედოთ, ეს ისაა, რომელიც მაგალითია საიდუმლო დეკოდერი ბეჭედი, რომელიც შეიძლება გამოყენებულ იქნას იმისათვის, რომ გაერკვნენ რა საიდუმლო გაგზავნა რეალურად არის. ფაქტობრივად, უკან დღეს კლასის სკოლა, თუ თქვენ ოდესმე გაუგზავნა საიდუმლო შეტყობინებები ზოგიერთ მეგობარს ან რამდენიმე crush კლასში, ალბათ ფიქრობდა, თქვენ რომ ჭკვიანი მიერ თქვენი ნაჭერი ქაღალდი იცვლება, მოსწონს, რომ B და B C, და C D, და ასე შემდეგ. მაგრამ თქვენ რეალურად დაშიფრვა თქვენი ინფორმაცია, მაშინაც კი, თუ ეს იყო პატარა უმნიშვნელო, არ იყო რომ მძიმე პედაგოგი, გააცნობიეროს, ასევე, თუ თქვენ მხოლოდ შეცვლის ბ A და C B, თქვენ გაერკვნენ რა გზავნილი იყო, მაგრამ თქვენ იყავით დაშიფრვის ინფორმაცია. 

თქვენ უბრალოდ აკეთებს ამას უბრალოდ, ჰგავს Ralphie აქ ცნობილი ფილმი, რომელიც თამაშობს საკმაოდ ბევრი რეკლამა nauseum ყოველ ზამთარს. [ვიდეო აღწარმოების] -იქნება ეს ცნობილია, რომ ყველა რალფ პარკერი წინამდებარე დაინიშნა წევრი პატარა Orphan Annie საიდუმლო წრე და მას უფლება აქვს ყველა პატივით და სარგებელი ხდება მასთან. 

-Signed, პატარა ობოლი Annie, counter ხელმოწერილი Pierre Andre, მელნის. პატივით და სარგებელს, უკვე ასაკში ცხრა. 

[ყვირილი] -მოდი. მოდით კიდევ იგი. მე არ გვჭირდება ყველა რომ ჯაზის შესახებ კონტრაბანდისტები და მეკობრეები. 

-მოუსმინეთ ხვალ ღამე დადების თავგადასავალი შავი მეკობრე გემი. ახლა, დროა Annie საიდუმლო გაგზავნა თქვენთვის წევრები საიდუმლო წრე. გახსოვდეთ, ბავშვები, მხოლოდ წევრების Annie საიდუმლო წრე შეიძლება decode Annie საიდუმლო გაგზავნა. 

გახსოვდეთ, Annie დამოკიდებულია თქვენ. უცნობია თქვენი ქინძისთავები B2. აქ არის გზავნილი. 12 11-- 

მე ვარ, ჩემი პირველი საიდუმლო შეხვედრა. 

-14, 11, 18, 16. 

-Pierre იყო დიდი ხმა შეძლებენ. მე ვერ გეტყვით, რომ ამაღამ გზავნილი იყო მართლაც მნიშვნელოვანია. 

-3, 25, ეს არის ის გაგზავნა Annie თავად. გახსოვდეთ, არ ვუთხრა ვინმეს. 

-90 წამის შემდეგ, მე მხოლოდ სახლში ოთახი, სადაც ბიჭი ცხრა შეიძლება იჯდეს კონფიდენციალურობა და decode. აი, B! მივედი შემდეგ, E. 

პირველი სიტყვა არის იყოს. S, ის მოდიოდა ადვილი არის, U, 25-- 

-Oh, მოდის, Ralphie, მე უნდა წავიდე! 

-I'll იქნება ქვემოთ, Ma! Gee whiz! 

-T, O, რა თქმა უნდა, რომელთა მიზანია, რა თქმა უნდა, თუ რა? რა იყო პატარა ობოლი Annie ცდილობს ამბობენ? რა თქმა უნდა, თუ რა? 

-Ralphie, ენდი აქვს წავიდეთ, გთხოვთ, გამოვა? 

-ყველა უფლება, Ma! მე ვიქნები უფლება out! 

-I იყო უახლოვდება ახლა. დაძაბულობა იყო საშინელი. რა იყო ეს? ბედი პლანეტა შეიძლება სასწორზე დევს. 

-Ralphie! ენდი gotta წავიდეთ! 

-I'll Be უფლება, ამისთვის ღაღადებდეს ხმამაღლა! 

შეიძლება ითქვას, რომ იქ, ჩემი თითების გაფრინდა, ჩემი აზრით, იყო ფოლადის ხაფანგში, ყველა ფორე წვას. ეს იყო თითქმის ნათელია, დიახ, დიახ, დიახ. 

-დარწმუნდით დალევა თქვენი Ovaltine. Ovaltine? Crummy კომერციული? ძაღლიშვილია. [END აღწარმოების] დევიდ ჯ Malan: OK, ასე რომ, ეს იყო ძალიან დიდი გზა შემოღების კრიპტოგრაფიის, და ასევე Ovaltine. ფაქტობრივად, ეს ძველი რეკლამა აქ, რატომ არის Ovaltine იმდენად კარგი? ეს არის კონცენტრირებული მოპოვების მწიფე ქერის ალაოს, სუფთა ნაღების ძროხის ის რძე, და სპეციალურად მომზადებული კაკაო, ერთად ბუნებრივი ფოსფატიდები და ვიტამინები. ეს კიდევ უფრო გამაგრებული დამატებითი ვიტამინები B და D, yum. და თქვენ შეგიძლიათ მიიღოთ ეს, როგორც ჩანს, Amazon, როგორც ჩვენ აქ. 

მაგრამ მოტივაცია აქ იყო დანერგვა კრიპტოგრაფიის, კონკრეტულად ტიპის კრიპტოგრაფიის ცნობილია როგორც საიდუმლო გასაღები კრიპტოგრაფიის. და როგორც სახელი ვარაუდობს, მთელი უსაფრთხოების საიდუმლო გასაღები Crypto სისტემა, თუ თქვენ, მეთოდოლოგია მხოლოდ scrambling ინფორმაცია ორ ადამიანს შორის, ის არის, რომ მხოლოდ გამგზავნი და მხოლოდ მიმღები ვიცი საიდუმლო key-- გარკვეული მნიშვნელობა, გარკვეული საიდუმლო ფრაზა, რაღაც საიდუმლო ნომერი, რომელიც მათ საშუალებას აძლევს ორივე დაშიფვრა და გაშიფვრა ინფორმაცია. და კრიპტოგრაფიის, მართლაც, მხოლოდ ამ კვირაში 0. 

ეს პრობლემა, იქ, სადაც საშუალებებით, როგორც ფაქტობრივი გაგზავნა in English ან რასაც ენაზე, რომ თქვენ გსურთ გაუგზავნოთ ვინმე კლასში, ან მასშტაბით ინტერნეტით. არსებობს გარკვეული გამომუშავება, რომელიც აპირებს უნდა იყოს scrambled გაგზავნა, რომ თქვენ მიმღები მიიღებენ. და მაშინაც კი, თუ ვინმე შუა იღებს ძალიან, თქვენ არ გვინდა, რომ მათ აუცილებლად შეძლებს გაშიფვრა, იმიტომ, რომ შიგნით ამ შავი ყუთი, ან ალგორითმი, არის რაღაც მექანიზმი, ზოგიერთი ეტაპობრივად ინსტრუქციები, აღების, რომ შეყვანის და კონვერტიზაცია გამომავალი, და იმედია უსაფრთხო გზა. 

და, ფაქტობრივად, არსებობს გარკვეული ლექსიკა ამ სამყაროში ასეთია. ძირითადი ტექსტი არის სიტყვა კომპიუტერული მეცნიერი იქნებოდა გამოიყენოთ აღწერს input გაგზავნა, როგორიცაა ინგლისური ან რა ენაზე თქვენ რეალურად გსურთ გაუგზავნოთ რამდენიმე სხვა ადამიანის. და მაშინ ciphertext არის scramble რომ enciphered, ან დაშიფრული, მობილური შესახებ. 

მაგრამ არსებობს ერთი ნივთიერება აქ. არსებობს ერთი შეყვანის საიდუმლო გასაღები კრიპტოგრაფიის. და ეს არის გასაღები თავად, რომელიც, ზოგადად, როგორც ვნახავთ, ნომერი, ან წერილი, ან სიტყვა, რაც ალგორითმი ეს არის რეალურად ელის. 

და როგორ გაშიფვრა ინფორმაცია? როგორ ფიქრობთ, unscramble ეს? ისე, უბრალოდ გადახედოს მასალები და საშუალებებით. 

სხვა სიტყვებით, კიდევ ვინმე იღებს თქვენი დაშიფრული გაგზავნა, იგი უბრალოდ უნდა იცოდეს, რომ იგივე გასაღები. მათ მიიღეს ciphertext. და ჩართვის იმ ორ პორტები შიფრის სისტემა, ალგორითმი, ამ შავი ყუთი, გარეთ უნდა მოვიდეს ორიგინალური plaintext. და ისე, რომ ძალიან მაღალი დონის ხედი რა კრიპტოგრაფიის არის რეალურად ყველაფერი. 

მოდით იქ. მოდით ახლა შევხედოთ ქვეშ hood, რაღაც ჩვენ უკვე აღების გაცემული გასულ კვირას, და ამ სხდომაზე აქ სიმებიანი. სიმებიანი ბოლოს დღეს მხოლოდ თანმიმდევრობა სიმბოლო. 

ეს შეიძლება იყოს მშვენიერია, ან მიესალმები Zamyla, ან რასაც. მაგრამ რას ნიშნავს ეს, რომ იყოს თანმიმდევრობა გმირები? ფაქტია, რომ CS50 ბიბლიოთეკა აძლევს ჩვენს მონაცემთა ტიპის სიმებიანი. 

მაგრამ იქ არ ასეთი რამ, როგორც სიმებიანი C. ეს ნამდვილად არ არის უბრალოდ თანმიმდევრობა ხასიათი, ხასიათი, ხასიათი, ხასიათი, უკან, უკან, უკან, უკან, დაბრუნება შიგნით თქვენი კომპიუტერის მეხსიერების, ან RAM. და ჩვენ შევხედოთ სიღრმეში, რომ მომავალში, როდესაც ჩვენ შევხედოთ მეხსიერების თავად, და გამოყენების, და საფრთხეები, რომლებიც ჩართულნი. 

მაგრამ მოდით განიხილოს სიმებიანი Zamyla. ასე რომ მხოლოდ სახელი ადამიანის აქ, Zamyla, რომ არის თანმიმდევრობა გმირები, Z-A-M-Y-L-A. ახლა მოდით ვივარაუდოთ, რომ Zamyla სახელი მიმდინარეობს ინახება შიგნით კომპიუტერი პროგრამა. 

ისე, ეს ლოგიკურია, რომ ჩვენ უნდა შეძლებს შევხედოთ იმ გმირები ინდივიდუალურად. ასე რომ მე უბრალოდ აპირებს მოუტანს პატარა ყუთი გარშემო Zamyla სახელი აქ. და ეს არის ამ შემთხვევაში C, რომ როდესაც თქვენ სიმებიანი, როგორც Zamyla-- და შესაძლოა რომ სიმებიანი დადგა უკან ფუნქცია, როგორიცაა მიიღოს სიმებიანი, თქვენ შეგიძლიათ რეალურად მანიპულირება ეს ხასიათი ხასიათი. 

ახლა, ეს არის გერმანე, რომ საუბრის დროს იმიტომ, რომ კრიპტოგრაფიის თუ თქვენ გსურთ შეცვალოთ B, და B C და C, D, და ა.შ., თქვენ უნდა შეეძლოს შევხედოთ ინდივიდუალური გმირები სიმებიანი. თქვენ უნდა იყოს შეუძლია შეცვალოს რომ Z რაღაც, ა რაღაც, M, რათა რაღაც, და ასე შემდეგ. ასე რომ, ჩვენ გვჭირდება გზა, პროგრამულად, ასე რომ, ვთქვათ, C შეძლებს შეცვალოს და შევხედოთ ინდივიდუალური წერილები. და ჩვენ შეგვიძლია გავაკეთოთ ეს შემდეგნაირად. 

ნება მომეცით წავიდეთ უხელმძღვანელებს უკან CS50 IDE. და ნება მომეცით წავიდეთ წინ და შექმნა ახალი ფაილი რომ მე მოვუწოდებ ამ დროს string0, როგორც ჩვენი პირველი მაგალითია, dot გ. და მე ვაპირებ წავიდეთ წინ და Whip it up ასეთია. 

ასე შეიცავს CS50.h, და მაშინ მოიცავს სტანდარტული io.h, რომელიც მე თითქმის ყოველთვის აპირებს გამოყენებით ჩემი პროგრამები, მინიმუმ თავდაპირველად. int ძირითადი ბათილად, და მაშინ აქ ვარ აპირებს ამის strings იღებს მიიღოს სიმებიანი. და შემდეგ მე ვაპირებ წავიდეთ წინ და ამის გაკეთება. მინდა წავიდეთ წინ და, როგორც საღი აზრის შემოწმება, უბრალოდ, ვამბობთ, hello, პროცენტს s, ნახევრად მსხვილი ნაწლავის, რაც string 0. უკაცრავად, რა გავაკეთო აქ? ოჰ, მე არ შეაერთედ ის. ასე რომ გაკვეთილი, რომელიც არ იყო გამიზნული. 

ასე რომ, შეცდომა, მეტ პროცენტს კონვერტაციის ვიდრე მონაცემების არგუმენტები. და ეს არის, სადაც, ონლაინ -7 ბლოკის OK, ასე რომ მაქვს, ციტირებით unquote, რომ ჩემი სიმებიანი printf. მაქვს პროცენტი ნიშანი. მაგრამ მე დაკარგული მეორე არგუმენტი. 

მე დაკარგული მძიმით s, რომელიც მე უნდა წინა მაგალითები. ასე რომ კარგი შესაძლებლობა დააფიქსიროს კიდევ ერთი შეცდომა, შემთხვევით. ახლა კი ნება მომეცით აწარმოებს string0, ტიპის Zamyla. OK, hello Zamyla. 

ასე რომ, ჩვენ აწარმოებს ამ სახის პროგრამა რამდენიმე სხვადასხვა დროს არის. მაგრამ მოდით რამე ცოტა განსხვავებული ამ დროს. იმის ნაცვლად, რომ უბრალოდ ბეჭდვა Zamyla ს მთელი სახელი ერთად printf, მოდით ეს ხასიათი ხასიათი. 

მე ვაპირებ გამოიყენოს ამისთვის loop. და მე ვაპირებ, რათა თავს დათვლის ცვლადი, მოუწოდა i. და მე ვაპირებ შენარჩუნება iterating, ასე რომ, სანამ i ნაკლებია ხანგრძლივობა s. 

თურმე, ჩვენ არ ამისათვის ბოლო დროს, რომ გ გააჩნია ფუნქცია მოუწოდა Stirling. უკან დღეს და ზოგადად, ჯერ კიდევ მაშინ, როდესაც განხორციელების ფუნქციები, ადამიანები ხშირად აირჩიოს ძალიან ლაკონური სახელები, რომ სახის ხმა როგორიცაა, რა გსურთ, მიუხედავად იმისა, რომ დაკარგული რამდენიმე ხმოვანთა ან წერილებს. ასე რომ, Stirling არის ასახელებს ფუნქცია, იღებს არგუმენტი შორის ფრჩხილებში რომ უნდა იყოს სიმებიანი. და ეს მხოლოდ ბრუნდება მთელი რიცხვი, სიგრძეზე რომ სიმებიანი. 

ასე რომ, ეს loop on line 7 აპირებს დაიწყება დათვლის დროს i უდრის 0. ის აპირებს, რომ იყოს i თითოეულ iteration 1, როგორც ჩვენ უკვე აკეთებს რამდენჯერმე. მაგრამ ის აპირებს, რომ მხოლოდ ამის ამ წლამდე წერტილი, როდესაც მე სიგრძე სიმებიანი თავად. 

ასე რომ, ეს არის გზა, საბოლოო ჯამში, iterating მეტი სიმბოლო სიმებიანი როგორც არის შემდეგნაირად. მე ვაპირებ ამობეჭდოთ არ არის მთელი ტექსტი, მაგრამ პროცენტი გ, ერთჯერადი ხასიათი მოყვება ახალი ხაზი. და შემდეგ მე ვაპირებ წავიდეთ წინ, და მე უნდა ვთქვა, მინდა ბეჭდვა შ ხასიათი s. 

ასე რომ, თუ არის ცვლადი, რომელიც მიუთითებს, ინდექსის სიმებიანი, სადაც თქვენ ხართ ის, მე უნდა შეძლებს ვთქვა, მომეცი შ ხასიათი s. და გ აქვს გზა აკეთებს ამ კვადრატულ ფრჩხილებში. უბრალოდ აცხადებენ, რომ სახელი ტექსტი, რომელიც ამ შემთხვევაში არის s. მაშინ თქვენ იყენებთ კვადრატულ ფრჩხილებში, რომლებიც როგორც წესი, მხოლოდ ზემოთ თქვენი Return ან შეიყვანეთ გასაღები წლის კლავიატურის. და მაშინ დააყენა ინდექსი ხასიათი რომ გსურთ ბეჭდვა. ასე რომ, ინდექსი იქნება რიცხვი 0, ან 1, ან 2, ან 3 ან dot, dot, dot, სხვა ნომერი. 

და ჩვენ უზრუნველყოს, რომ ის აპირებს სწორი ნომერი, იმიტომ, რომ მე დაიწყება დათვლის დროს 0. და იყოს, პირველი ხასიათი სიმებიანი არის კონვენციის 0. და მეორე გმირი bracket 1. და მესამე გმირი არის bracket 2. და თუ თქვენ არ გსურთ წასვლა ძალიან შორს, მაგრამ ჩვენ არ იმიტომ, რომ ჩვენ აპირებს მხოლოდ ნამატი i სანამ ეს ტოლია სიგრძეზე სიმებიანი. და სადაც წერტილი, ამ loop შეწყდება. 

ნება მომეცით, წავიდეთ წინ და შეინახოთ ამ პროგრამა, და აწარმოებს მიიღოს string 0. მაგრამ მე ბრალია. მინიშნებით გამოცხადების ბიბლიოთეკის ფუნქცია Stirling ტიპის ასეთი და such-- ახლა, ეს ჟღერს ნაცნობი. მაგრამ ეს არ არის printf. და ეს არ მიიღოს სიმებიანი. 

მე არ ხრახნიანი up ანალოგიურად ამ დროს. მაგრამ შეამჩნია ქვემოთ აქ ცოტა ქვემოთ შემდგომი, მოიცავს header string.h, მკაფიოდ უზრუნველყოფს დეკლარაციის Stirling. ასე რომ, არსებობს რეალურად ნახავ იქ. 

და მართლაც, ეს გამოდის არსებობს კიდევ ერთი header ფაილი რომ ჩვენ არ გამოიყენება კლასში არის, მაგრამ ეს მათ შორის არსებული თქვენ, სახელად string.h. და რომ ფაილი, string.h არის Stirling განაცხადა. ნება მომეცით წავიდეთ წინ და შენახვა, რათა string 0- ლამაზი, არ შეცდომის შეტყობინებები ამ დროს. 

./string0 Zamyla, და მე უნდა დააჭიროთ, სადაც წერტილი getstring აპირებს დაბრუნებას სიმებიანი, ამას s. მაშინ, რომ მარყუჟი აპირებს iterate მეტი S გმირები ერთ დროს, ბეჭდვა და მათ ერთ ხაზზე, რადგან მქონდა, რომ წარმატებული ო ბოლოს. ასე რომ მე ვერ გამომრჩეს, რომ წარმატებული n, და შემდეგ უბრალოდ ბეჭდვა Zamyla ყველა იმავე ხაზის, ეფექტურად reimplementing printf, რომელიც არ არის ყველა, რომ სასარგებლო. მაგრამ ამ შემთხვევაში, მე არ კეთდება, რომ. მე რეალურად დაბეჭდილი ერთი ხასიათი დროს, ერთ ხაზზე, ასე, რომ ჩვენ რეალურად ვხედავ ეფექტი. 

მაგრამ უნდა აღვნიშნო ერთი რამ აქ. და ჩვენ დავბრუნდებით ეს მომავალი კვირის განმავლობაში. გამოდის, რომ ამ კოდი პოტენციურად buggy. 

გამოდის, რომ მიიღოს სიმებიანი და სხვა ფუნქციების ცხოვრებაში არ არის აუცილებელი ყოველთვის დაბრუნდება, თუ რა ველოდებით. ჩვენ ვიცით, რომ კლასის ბოლო დროის ამ, რომ მიიღოს string უნდა დაბრუნდეს სიმებიანი. მაგრამ რა, თუ მომხმარებლის ტიპის ასეთი გრძელი სიტყვა, ან მე, ან ნარკვევი რომ იქ უბრალოდ არ არის საკმარისი მეხსიერება კომპიუტერის შეესაბამება მას. 

მსგავსად, რა, თუ რამე მიდის არასწორი ქვეშ hood? ეს შეიძლება არ ხდება ხშირად, მაგრამ ეს შეიძლება მოხდეს ერთხელ ხოლო, ძალიან იშვიათად. და გამოდის, რომ მიიღოს სიმებიანი და ფუნქციები, როგორც ეს არ არის აუცილებელი ყოველთვის დაბრუნდება strings. შესაძლოა, მათ დააბრუნებს შეცდომა ღირებულება, ზოგიერთი Sentinel ღირებულება, ასე ვთქვათ, რომელიც მიუთითებს, რომ რაღაც წავიდა არასწორია. და თქვენ მხოლოდ ვიცი, რომ ეს რომელმაც შეიტყო, რომ კლასი ახლა, და რომელმაც წაიკითხა კიდევ რამდენიმე დოკუმენტაცია. გამოდის, რომ მიიღოს სიმებიანი შეუძლია დააბრუნოს მნიშვნელობა მოუწოდა null. Null არის განსაკუთრებული მნიშვნელობა, რომ ჩვენ დავბრუნდებით მომავალი კვირის განმავლობაში. მაგრამ ახლა, უბრალოდ ვიცი, რომ თუ მინდა უნდა იყოს ნამდვილად სათანადო წინსვლის გამოყენებით Get სიმებიანი, მე არ უნდა მხოლოდ მას, და ბრმად გამოიყენოს მისი დაბრუნების ღირებულება, ვაღიარებთ, რომ ეს ტექსტი. 

მე პირველ რიგში, უნდა ითქვას, hey, დაველოდოთ წუთში, მხოლოდ გაგრძელება თუ არ თანაბარი null, სადაც null, კიდევ ერთხელ, არის რამოდენიმე განსაკუთრებული მნიშვნელობა. და ეს არის ერთადერთი განსაკუთრებული მნიშვნელობა თქვენ უნდა ფიქრი Get სიმებიანი. მიიღოს სიმებიანი ან აპირებს დაბრუნებას სიმებიანი ან null. 

და ამ ძახილის წერტილი ტოლობის ნიშანი მოგეხსენებათ, შესაძლოა, მათემატიკის კლასის რომ თქვენ შეიძლება მიაპყროს თანაბარი ნიშანი ხაზის მეშვეობით ეს მიუთითებს იმაზე, არ არის თანაბარი. ეს არ არის ზოგადად ხასიათი შეგიძლიათ ჩაწეროთ თქვენს კლავიატურაზე. ასე რომ, ყველაზე პროგრამირების ენები, როდესაც თქვენ მინდა ვთქვა, არ არის თანასწორი, თქვენ იყენებთ ძახილის წერტილი, სხვაგვარად ცნობილია როგორც bang. ანუ, თქვენ ამბობთ bang ტოლია, რომელიც იმას ნიშნავს, არ უდრის, ლოგიკურად. ეს იგივეა, რომ არ არის დიდი მეტი, ან ტოლია, ან ნაკლები ან ტოლია კლავიშს რომ ეს ყველაფერი ერთი სიმბოლო. ასე რომ, რატომ, წარსულში მაგალითები, თქვენ გააკეთა ღია bracket და შემდეგ თანაბარი ნიშანი, რათა გააკეთოს მეტია ან, ვთქვათ, ნაკლები. 

ასე რომ, რა takeaway აქ? ეს არის უბრალოდ გზა არის შემოღების ეს სინტაქსი, ამ ფუნქციის, iterating მეტი ინდივიდუალური სიმბოლოების სიმებიანი. და ისევე, როგორც იმ მოედანზე ფრჩხილებში საშუალებას გაძლევთ მიიღონ მათ, განიხილოს იმ კვადრატულ ფრჩხილებში, როგორც ერთგვარი მან მიანიშნა ამ ფუძემდებლური დიზაინი, რომლის ყოველ ხასიათი შიგნით მისაღებად არის სახის ჩარჩოში სადღაც ქვეშ hood, თქვენი კომპიუტერის მეხსიერებაში. 

მაგრამ მოდით ვარიანტი ამ. გამოდის, რომ ამ პროგრამა არის სწორი. ასე რომ, ერთ CS50 ის ღერძი შეფასების კოდი, ეს არის სწორი ახლა. მით უმეტეს, რომ მე შემოწმება null, ეს პროგრამა არასდროს არ უნდა მისაწოდებლად. და მე ვიცი, რომ გამოცდილება. მაგრამ იქ სხვა არაფერი, რომ ჩვენ ნამდვილად შეგვიძლია წავიდეთ არასწორი აქ. მაგრამ ეს არ არის ძალიან კარგად შემუშავებული, იმიტომ, რომ მოდით დავუბრუნდეთ საფუძვლებს. 

პირველი, principles-- რას ამისთვის მარყუჟის გაკეთება? ამისთვის loop აკეთებს სამი რამ. ეს ველში გარკვეული მნიშვნელობა, თუ ვთხოვთ მას. ის ამოწმებს მდგომარეობა. და შემდეგ ყოველ iteration, ყოველი ციკლის, ეს increments ზოგიერთი ღირებულება, ან ღირებულებებს, აქ. 

ასე რომ, რას ნიშნავს ეს? ჩვენ ინიციალიზაცია i 0. ჩვენ შემოწმება და დარწმუნდით, რომ ნაკლებია ხანგრძლივობა s, რომელიც Z-A-M-Y-L-A, ასე რომ, რომელიც ნაკლებია, ვიდრე 6. და, მართლაც, 0, 6-ზე ნაკლები. 

ჩვენ ამობეჭდოთ Z დან Zamyla სახელი. მაშინ ჩვენ ნამატი i 0-დან 1. ჩვენ მაშინ შეამოწმეთ, არის 1 ნაკლები ვიდრე სიგრძე s? ხანგრძლივობა s 6. დიახ, ის არის. 

ასე რომ, ჩვენ ბეჭდვა in Zamyla სახელი, ZA. ჩვენ ნამატი i 0, 1, 2. ჩვენ მაშინ შეამოწმეთ, არის 2-ზე ნაკლები ხანგრძლივობა Zamyla სახელი. 6 ასე რომ 2 ნაკლებია, ვიდრე 6. დიახ, მოდით ამობეჭდოთ ახლა M in Zamyla სახელი, მესამე ხასიათი. 

გასაღები აქ არის ის, რომ თითოეული iteration ამბავი, მე შემოწმების, არის მე ნაკლები სიგრძის Zamyla? მაგრამ დაჭერა არის, რომ Stirling არ არის საკუთრება. იმ თქვენ, რომლებიც არ პროგრამირდება ადრე Java ან სხვა ენებზე ალბათ იცით, სიგრძეზე სიმებიანი ქონება, მხოლოდ რამდენიმე წაკითხვის მხოლოდ ღირებულება. 

In C, ამ შემთხვევაში, თუ ეს არის ფუნქცია, რომელიც არის ფაქტიურად დათვლის სიმბოლოების Zamyla ყოველ ჯერზე ჩვენ მოვუწოდებთ, რომ ფუნქცია. ყოველ დროს, თქვენ ვთხოვთ კომპიუტერის გამოყენება Stirling, ის აღების შევხედოთ Zamyla, და განაცხადა, Z-A-M-Y-L-A, 6. და ის დააბრუნებს 6. მომავალი დრო თქვენ მოვუწოდებთ შიგნით რომ loop, ის აპირებს, რომ შევხედოთ Zamyla ერთხელ, ვთქვათ, Z-A-M-Y-L-A, 6. და ის აპირებს დაბრუნებას 6. ასე რომ, რა სულელური ამ დიზაინი? 

რატომ არის ჩემი კოდი არ არის 5 out of 5 დიზაინი ახლა, ასე ვთქვათ? ისე, მე ითხოვს კითხვა ზედმეტად. მე ვაკეთებ მეტი მუშაობა, ვიდრე მე უნდა. 

ასე რომ, მიუხედავად იმისა, რომ პასუხი არის სწორი, მე ვარ ეკითხება კომპიუტერი, რა არის ხანგრძლივობა Zamyla ერთხელ, და ისევ და ისევ და ისევ? და რომ პასუხი არასოდეს შეიცვლება. ის ყოველთვის იქნება 6. 

ასე რომ, უკეთესი, ვიდრე ეს იქნება ეს მომდევნო ვერსია. ნება მომეცით წავიდეთ წინ და ამას ცალკე ფაილი სახელად string1.c, უბრალოდ შეინახოს იგი ცალკე. და აღმოჩნდება, რომ ამ საიტზე loop, შეგიძლიათ რეალურად განაცხადოს მრავალჯერადი ცვლადები ერთდროულად. 

ამიტომ, მე ვაპირებ, რომ შევინარჩუნოთ i და დაადგინა, რომ 0. მაგრამ მე ასევე აპირებს რჩეულებში მძიმით, და ამბობენ, მომეცი ცვლადში N, რომლის მნიშვნელობა ტოლია სიმებიანი ხანგრძლივობა s. და ახლა, გთხოვთ, ჩემი მდგომარეობა ასე რომ, სანამ i ნაკლებია, ვიდრე n. 

ასე რომ, ამ გზით, ლოგიკა იდენტური დასასრულს დღეში. მაგრამ მე დამახსოვრების ღირებულება 6, ამ შემთხვევაში. რა არის სიგრძე Zamyla სახელი? და მე აყენებს მას n. 

და მე მაინც შემოწმების იმ პირობით, ყოველ ჯერზე. 0 არანაკლებ 6? არის 1 არანაკლებ 6? 2 არანაკლებ 6 და ა.შ.? 

მაგრამ მე არ ითხოვს კომპიუტერული ისევ და ისევ, რა ხანგრძლივობა Zamyla სახელი? რა არის სიგრძეზე Zamyla სახელი? რა არის სიგრძეზე ამ Zamyla სახელი? მე ფაქტიურად ახსოვს, რომ პირველი და მხოლოდ უპასუხოს ამ მეორე ცვლადი ო. ასე რომ, ეს ახლა იქნება არა მხოლოდ სწორი, არამედ კარგად შემუშავებული. 

ახლა, რაც შეეხება სტილი? მე სახელად ჩემი ცვლადები კარგად, მე ვიტყოდი. ისინი სუპერ ლაკონური ახლავე. და რომ სრულიად ჯარიმა. 

თუ თქვენ გაქვთ მხოლოდ ერთი სიმებიანი პროგრამა, თქვენ შესაძლოა, ასევე მოვუწოდებთ მას s სიმებიანი. თუ თქვენ გაქვთ მხოლოდ ერთი ცვლადი დათვლის პროგრამა, თქვენ შესაძლოა, ასევე ეძახით i. თუ თქვენ გაქვთ სიგრძე, n super საერთო, ასევე. მაგრამ მე არ გამოეხმაურა არც ჩემი კოდი. 

მე არ შეატყობინა reader-- თუ არა, რომ ჩემი TF, ან TA, ან უბრალოდ კოლეგა რა უნდა უნდა მომხდარიყო ამ პროგრამაში. და ასე მიიღოს კარგი სტილი, ის, რაც მე მინდა ამის არის ამ რაღაც როგორიცაა ვთხოვთ მომხმარებელს შეყვანის. და მე ვერ გადაწერა ეს ნებისმიერი რაოდენობის გზები. 

დარწმუნდით s-- დარწმუნდით მისაღებად string დაბრუნდა სიმებიანი. და მაშინ აქ და ეს არის ალბათ ყველაზე მნიშვნელოვანი comment-- iterate მეტი სიმბოლოების s ერთ დროს. და მე ვერ გამოიყენოთ ნებისმიერი არჩევანი ინგლისური ენის აქ აღწერილია თითოეული ამ მოცულობით კოდი. 

გაითვალისწინეთ, რომ მე არ დააყენოს კომენტარს ყველა ხაზი კოდი, უბრალოდ, მათთვის საინტერესო პირობა, პირობა, რომ აქვს გარკვეული მნიშვნელობა, რომ მე შეიძლება მინდა, რომ სუპერ ნათელი ვინმე კითხულობს ჩემი კოდი. და რატომ მოუწოდებს მიიღოს string ვთხოვთ მომხმარებელს შეყვანის? მიუხედავად იმისა, რომ ერთ-ერთი არ არის აუცილებელი ყველა რომ აღწერითი. მაგრამ ეს ხელს ვუთხრა ამბავი, რადგან მეორე ხაზი ამბავი, დარწმუნდით სიმებიანი დაბრუნდა სიმებიანი. 

და მესამე ხაზი ამბავი, გადაურბინოთ სიმბოლოების ერთი დროულად. და ახლა მხოლოდ კარგი ღონისძიება, მე ვაპირებ წავიდეთ წინ და დაამატოთ კიდევ ერთი კომენტარი, რომ მხოლოდ ამბობს ბეჭდვითი i-th პერსონაჟი s. ახლა, რა დაგიშავე ბოლოს დღეს? 

მე დასძინა ზოგიერთი English სიტყვა სახით კომენტარი. ირიბის slash სიმბოლო ნიშნავს, hey, კომპიუტერული, რომ ეს არის ადამიანის, არ არის თქვენთვის, კომპიუტერი. ასე რომ, ისინი იგნორირებულია ლოგიკურად. ისინი უბრალოდ არ არსებობს. 

და, მართლაც, CS50 IDE აჩვენებს მათ, როგორც ნაცრისფერი, როგორც სასარგებლო, მაგრამ არა ძირითადი პროგრამა. ყურადღება მიაქციეთ, რა შეგიძლიათ გააკეთოთ. მიუხედავად იმისა, რომ თქვენ იცით, C პროგრამირების თუ არა, შეგიძლიათ უბრალოდ დგანან უკან ამ პროგრამა, skim კომენტარი. ჰკითხეთ მომხმარებლის input, დარწმუნდით სიმებიანი დაბრუნდა სიმებიანი, გადაურბინოთ სიმბოლოების s ერთ დროს, ბეჭდვა ხასიათი i-th პერსონაჟი s-- თქვენ არ კი უნდა შევხედოთ კოდი უნდა გვესმოდეს, რა ეს პროგრამა აკეთებს. და, კიდევ უკეთესი, თუ თავს გამოიყურება ამ პროგრამის ერთ-ორ კვირაში, ან ერთი თვის, ან ერთი წლის განმავლობაში, თქვენც არ აქვს მიშტერებული კოდი, ცდილობს გვახსოვს, რა იყო მე ცდილობს გააკეთოს ეს კოდი? 

თქვენ განუცხადა თავს. შენ აღწერილი თავს, და ზოგიერთი კოლეგის ან TA, ან TF. ასე რომ, ეს ახლა იყოს სწორი და კარგი დიზაინი, და საბოლოო ჯამში, კარგი სტილი, ასევე. ასე რომ შევინარჩუნოთ, რომ გონება. 

ასე რომ ერთი სხვა რაც მე ვაპირებ, რომ აქ რომ ახლა, ზუსტად რა არის მიმდინარეობს ქვეშ hood. ასე რომ ეს ფუნქცია C, და სხვა ენებზე, მოუწოდა typecasting რომ არც ირიბად ან პირდაპირ გაძლევთ საშუალებას დააკონვერტიროთ ერთი მონაცემები ტიპის სხვა. ჩვენ უკვე საქმე ასე რამდენადაც დღეს სტრიქონები. 

და სიმები არიან გმირები. მაგრამ გავიხსენოთ, კვირაში 0, რა გმირები? გმირები არიან უბრალოდ აბსტრაქცია თავზე ნომრებზე ათობითი ნომრები, და ათობითი ნომრები მართლაც მხოლოდ აბსტრაქცია თავზე ორობითი რიცხვი როგორც ჩვენ განსაზღვრული იყო. 

ასე რომ გმირები არიან ნომრები. და ნომრები გმირები, უბრალოდ დამოკიდებულია კონტექსტში. და აღმოჩნდება, რომ შიგნით კომპიუტერული პროგრამის, შეგიძლიათ მიუთითოთ თუ გსურთ გამოიყურება at ბიტი შიგნით რომ პროგრამა? 

შეგახსენებთ, კვირაში 0, რომ ჩვენ გვქონდა ASCII, რომელიც მხოლოდ ამ კოდექსით რუკების წერილები ნომრები. და ჩვენ ვთქვით, დედაქალაქში არის 65. Capital B არის 66, და სხვ. 

და შეამჩნია, ჩვენ არსებითად სიმბოლო on ზედა რიგის აქ, C მოვუწოდებთ მათ, პერსონაჟი, და შემდეგ ints მეორე ზედიზედ. და აღმოჩნდება, რომ თქვენ შეგიძლიათ დააკონვერტიროთ ჩაირთოს შორის, როგორც წესი. და თუ ჩვენ გვინდა, რომ შეგნებულად, ჩვენ დაგვჭირდება დაძლევის რაღაც მსგავსი. 

ჩვენ დაგვჭირდება გარდაქმნას ზედა შემთხვევაში შეამცირონ შემთხვევაში, ან ქვედა ზედა შემთხვევაში. და ეს თურმე არსებობს რეალურად ნიმუში აქ შეგვიძლია იკისროს რაღაც მომენტში. მაგრამ მოდით შევხედოთ პირველი საათზე მაგალითად ამით მკაფიოდ. 

მე ვაპირებ დაბრუნდეს CS50 IDE. მე ვაპირებ, რომ შევქმნათ ფაილი მოუწოდა ASCII 0.c. და მე ვაპირებ წავიდეთ წინ და დაამატოთ ჩემი სტანდარტული io.h ზედა, int ძირითადი ბათილად ზედა ჩემი ფუნქცია. და მაშინ მე უბრალოდ აპირებს ასეთია ამისთვის მარყუჟის i შეადგენს, ვთქვათ, 65. 

და მერე იქნება ნაკლები 65, პლუს 26 ასო ანბანი. ასე რომ, მე ნება კომპიუტერული მათემატიკის ჩემთვის არსებობს. და შემდეგ შიგნით ამ მარყუჟის, რა ვარ მე აპირებს ბეჭდვა? 

% C% i წარმატებული ო. და ახლა მინდა შეაერთედ ორი ღირებულებებს. მე დროებით კითხვა აღნიშნავს არ მოიწვიოს კითხვა. 

მინდა iterate 65 წლიდან 26 ასო ანბანი, დაბეჭდვისას თითოეულ iteration, რომ ხასიათი განუყოფელი ექვივალენტს. სხვა სიტყვებით, მინდა გადაურბინოთ 26 ნომრები ბეჭდვა რა ASCII ხასიათი, წერილი, და რა შესაბამისი რაოდენობის is-- უბრალოდ თავიდან სქემა, რომ slide. რა უნდა ამ კითხვის ნიშნები იყოს? 

ისე, გამოდის, რომ მეორე ერთი უნდა იყოს მხოლოდ ცვლადი მე. მე მინდა, რომ, რომელიც, როგორც ნომერი. და შუა არგუმენტი აქ, მე შემიძლია გითხრათ კომპიუტერი მკურნალობა, რომ მთელი მე, როგორც ხასიათი, ისე, რომ ჩაანაცვლებს, აქ პროცენტი C. 

სხვა სიტყვებით, თუ მე, ადამიანის პროგრამისტი, ვიცი, ეს არის მხოლოდ ციფრები ბოლოს დღის განმავლობაში. და მე ვიცი, რომ 65 უნდა MAP- ის გარკვეული ხასიათი. ამ გამოკვეთილ მსახიობი, ერთად ფრჩხილებში, სახელი მონაცემები ტიპის გსურთ გარდაქმნას, და დახურული ფრჩხილებში, თქვენ გეტყვით კომპიუტერი, hey, კომპიუტერი, გარდაქმნას ეს რიცხვი char. 

ასე რომ, როდესაც მე აწარმოებს ამ პროგრამის შემდეგ შედგენა, ვნახოთ, რა მივიღო, რათა ASCII 0. Darn ეს, რა გავაკეთო არასწორი აქ? გამოყენება გამოუცხადებელ იდენტიფიკატორი, ყველა უფლება, არ არის გამიზნული, მაგრამ ვნახოთ, თუ ჩვენ არ შეგვიძლია მიზეზი მეშვეობით. 

ამიტომ ხაზი ხუთ ასე რომ მე არ მიიღოს ძალიან შორს ადრე screwing up. არაუშავს. ამიტომ ხაზი 5 i უდრის 65-- ვხედავ. ასე მახსოვს, რომ C, განსხვავებით ზოგიერთი ენებზე, თუ თქვენ გაქვთ წინასწარი პროგრამირების გამოცდილება, თქვენ უნდა ვუთხრა კომპიუტერი, განსხვავებით Scratch, რა ტიპის ცვლადი ეს არის. 

და დამავიწყდა გასაღები ფრაზა აქ. შეესაბამება ხუთი, მე გამოყენება დაიწყო i. მაგრამ მე არ უთხრა C რა მონაცემები ტიპის ეს არის. ამიტომ, მე ვაპირებ წასვლა აქ და ამბობენ, ah, რათა ის რიცხვი. 

ახლა მე ვაპირებ წავიდეთ წინ და recompile. რომ დაფიქსირებული, რომ. ./ascii0 Enter, რომ სახის cool. ეს არ არის მხოლოდ სუპერ სწრაფი ვთხოვ კომპიუტერში ამ კითხვაზე, ვიდრე ეძებს ის შესახებ slide, ეს დაბეჭდილი ერთ ხაზზე ერთი, არის 65, B 66, ყველა გზა დანგრევა, რაც მე ეს გააკეთა 26 times-- წერილები z, რომელიც 90. და, ფაქტობრივად, ოდნავ უფრო ჭკვიანი იქნებოდა არ ყოფილა ჩემთვის, არ დაეყრდნონ on კომპიუტერი დაამატოთ 26. მე ვერ უბრალოდ გაკეთდეს 90 ასევე, ცოტა ხნის როგორც მე არ გააკეთოს იგივე შეცდომას ორჯერ. მინდა წასვლა მეშვეობით z, არა მხოლოდ მეშვეობით y. 

ასე რომ, თუ გამოკვეთილ მსახიობი. გამოდის, რომ ამ კი არ არის საჭირო. ნება მომეცით წავიდეთ წინ და გამეორება ამ შემდგენელი და გამეორება ASCII 0. გამოდის, რომ C საკმაოდ ჭკვიანი. 

და printf, კერძოდ, საკმაოდ ჭკვიანი. თუ თქვენ უბრალოდ გაივლის i ორჯერ ორივე placeholders, printf იქნება ხვდები, რა, კარგად მე ვიცი, რომ თქვენ მომცა რიცხვი გარკვეული რაოდენობის, მოსწონს 65, ან 90, ან რასაც. მაგრამ მე ვხედავ, რომ გინდა, ფორმატირება, რომ ნომერი, როგორც ხასიათი. ასე რომ, printf შეიძლება ირიბად მიცემული int, რათა char ამისთვის თქვენ ასევე. ასე რომ, არ არის პრობლემა. 

მაგრამ შეამჩნია, რადგან ამ ექვივალენტობის ჩვენ შეგვიძლია რეალურად ამის გაკეთება, ასევე. ნება მომეცით წავიდეთ წინ და ერთი სხვა ვერსია ამას ASCII 1.გ. და ნაცვლად iterating მეტი რიცხვებით, ნამდვილად აფეთქება თქვენი გონება მიერ iterating მეტი სიმბოლო. თუ char c იღებს დედაქალაქში, I გსურთ წავიდეთ წინ და ამის გაკეთება, ასე რომ, სანამ C ნაკლებია ან ტოლი კაპიტალის ზ და თითოეულ iteration მე მინდა, რომ ნამატი C, შემიძლია ახლა ჩემი printf ხაზი აქ ვთქვათ, პროცენტი C არის პროცენტი მე კიდევ ერთხელ, მძიმე C. 

და ახლა, მე შეიძლება სხვა მიმართულებით, კასტინგი ხასიათი მკაფიოდ რიცხვი. ასე რომ, კიდევ ერთხელ, რატომ აკეთებთ ამას? ეს ცოტა უცნაური დასალაგებლად იმედი თვალსაზრისით სიმბოლო. 

მაგრამ თუ თქვენ გვესმოდეს, რა არის მიმდინარეობს ქვეშ hood, იქ ნამდვილად არ Magic. თქვენ უბრალოდ ამბობდა, hey, კომპიუტერული მისცეს მომეცი ცვლადში C ტიპის char. ვრთავ, რომ დედაქალაქში ა და შეამჩნია ერთ შეთავაზებები საკითხზე. 

გმირები C, გავიხსენოთ გასულ კვირას, გამოიყენოთ ერთჯერადი შეთავაზებები. სიმებიანი, სიტყვა, ფრაზები, თქვენ ორმაგ ბრჭყალებში. OK, კომპიუტერი, ექცევით, ასე რომ, სანამ ხასიათი ნაკლებია, ვიდრე ან ტოლია z. და მე ვიცი, რომ ჩემი ASCII მაგიდასთან, რომ ყველა ამ ASCII კოდები მომიჯნავე. 

არ არსებობს ხარვეზები. ასე რომ, ეს უბრალოდ მეშვეობით Z, გამოყოფილი ერთი ნომერი თითოეული. და მერე შეგვიძლია გავზარდოთ char, თუ მე ნამდვილად მინდა. ბოლოს დღეს, ეს მხოლოდ ნომერი. მე ეს ვიცი. ასე, რომ შეიძლება მხოლოდ ვივარაუდოთ, რომ დაამატოთ 1 მას. 

შემდეგ კი ამ დროს, მე ბეჭდვა c, და შემდეგ განუყოფელი ექვივალენტს. და მე კი არ უნდა გამოკვეთილ მსახიობი. შემიძლია ნება printf და კომპიუტერული ფიგურა ნივთების, ასე რომ, ახლა თუ აწარმოებს რათა Ascii1./ascii1, მე კიდევ ზუსტად იგივე რამ, ისევე. 

უსარგებლო პროგრამა, though-- არავინ აპირებს რეალურად დაწეროს პროგრამა იმისათვის, რომ გავიგოთ, რა იყო ნომერი, რომელიც რუკები, ან B, ან Z? თქვენ უბრალოდ აპირებს Google მას, ან მას up ხაზზე, ან გამოიყურება ეს on slide, ან მოსწონს. ასე რომ, სადაც ეს რეალურად მიიღოთ სასარგებლო? 

ისე, რომ ვთქვათ, რომ slide, შეამჩნია ფაქტობრივი ნიმუში აქ შორის ზედა და ამას, რომ არ იყო შემთხვევითი. გაითვალისწინეთ, რომ დედაქალაქში არის 65. მხედრულ არის 97. და რამდენად შორს არის ქვედა შემთხვევაში? 

ასე რომ, 65 რამდენი ნაბიჯში 97? ასე რომ, 97 მინუს 65 არის 32. ასე რომ დედაქალაქში არის 65. თუ თქვენ დაამატოთ 32 რომ, თქვენ ამას. და, equivalently, თუ გამოვაკლებთ 32, დავუბრუნდეთ დედაქალაქის A-- იგივე B პატარა ბ, დიდი C პატარა გ. 

ყველა ეს ხარვეზები 32 გარდა. ახლა, ეს, როგორც ჩანს, საშუალებას გვაძლევს ამის გაკეთება რაღაც Microsoft Word, ან Google Docs ფუნქცია, სადაც თქვენ შეგიძლიათ აირჩიოთ ყველაფერი და მერე ამბობენ, შეიცვლება ყველა ამას, ან შეიცვლება ყველა ზედა შემთხვევაში, ან იცვლება მხოლოდ პირველი სიტყვა სასჯელის ზედა შემთხვევაში. ჩვენ შეგვიძლია რეალურად რაღაც მინდა, რომ საკუთარ თავს. 

ნება მომეცით წავიდეთ წინ და გადარჩენა ფაილი აქ მოუწოდა ესარგებლა 0.c. და მოდით წავიდეთ წინ და whip up პროგრამა რომელიც აკეთებს ზუსტად რომ ასეთია. ასე რომ მოიცავს CS50 ბიბლიოთეკა. და მოიცავს სტანდარტული I / O. 

და მე ვიცი, რომ ეს მალე. ასე რომ, მე ვაპირებ, რომ ეს იქ უკვე, string.h, ასე მაქვს ხელმისაწვდომობის რამ, როგორიცაა Stirling, და შემდეგ int ძირითადი ბათილად, როგორც ყოველთვის. და შემდეგ მე ვაპირებ წავიდეთ წინ და ნუ strings იღებს მიიღოს სიმებიანი, მხოლოდ მისაღებად ნახატზე შესახებ. და შემდეგ მე ვაპირებ ნუ ჩემი საღი აზრის ქვითარი. თუ სიმებიანი არ თანაბარი null, მაშინ ეს უსაფრთხო გაგრძელება. და რა უნდა გავაკეთოთ? მე ვაპირებ iterate საწყისი i = 0, და n მდე სიმებიანი ხანგრძლივობა s. 

და მე ვაპირებ, რომ ამის გაკეთება მანამ, სანამ i ნაკლებია, ვიდრე n, და მე plus plus. ჯერჯერობით, მე ნამდვილად სესხის იდეები ადრე. და ახლა მე ვაპირებ წარმოგიდგინოთ ფილიალი. 

ასე რომ, ვფიქრობ, უკან ნულიდან, სადაც ჩვენ გვქონდა იმ ჩანგლები საგზაო, და გასულ კვირას C. მე ვაპირებ ამბობენ, რომ ეს, თუ i-th ხასიათი s მეტია ან ტოლი ქვედა შემთხვევაში, and-- in Scratch თქვენ ფაქტიურად ვთქვათ და, მაგრამ C თქვენ ამბობთ ampersand, ampersand-- და i-th ხასიათი s ნაკლებია ან ტოლი ქვედა შემთხვევაში z, მოდით რაღაც საინტერესო. მოდით რეალურად ამობეჭდოთ ხასიათი არ newline რომ არის პერსონაჟი სიმებიანი, i-th პერსონაჟი სიმებიანი. 

მაგრამ მოდით წავიდეთ წინ და სხვაობა 32 მას. სხვაგან, თუ პერსონაჟის string, რომ ჩვენ ვეძებთ არ არის შორის პატარა და პატარა z, წავიდეთ წინ და მხოლოდ დაბეჭდილი ის არ შეცვლილა. ასე რომ, ჩვენ გააცნო ამ ფრჩხილებში notation ჩვენი strings მიიღონ ზე i-th პერსონაჟი სიმებიანი. 

მე დასძინა ზოგიერთი პირობითი ლოგიკის, როგორც Scratch გასულ კვირას კვირაში ერთი, სადაც მე უბრალოდ გამოყენებით ჩემი ძირითადი გაგება, თუ რა არის მიმდინარეობს ქვეშ hood. არის i-ე ხასიათი s მეტია ან ტოლია? მინდა, რომ 97, 98, ან 99 და ა.შ.? 

მაგრამ არის ის, ასევე ნაკლებია ან ტოლი ღირებულება ამას z? და თუ ასეა, რას ნიშნავს ეს ხაზი ნიშნავს? 14, ეს არის ერთგვარი ჩანასახები მთელი იდეა, კაპიტალიზაცია წერილში მიერ უბრალოდ გამოკლებით 32 მისგან, ამ შემთხვევაში, რადგან ვიცი, თითო რომ სქემა, თუ როგორ, ჩემი ნომრები წარმოდგენილი. მოდით წავიდეთ წინ და აწარმოებს ამ, შემდეგ შედგენა ესარგებლა 0.c, და აწარმოებს ესარგებლა 0. 

მოდით აკრიფოთ რაღაც Zamyla ყველა ამას შევა. და ახლა ჩვენ გვაქვს Zamyla ყველა ზედა. მოდით აკრიფოთ Rob ყველა ამას. მოდით ცდილობენ Jason ყველა ამას. ჩვენ მომდის იძულებული კაპიტალიზაცია. არსებობს მცირე შეცდომა, რომ მე სახის არ გავუსწრო. ყურადღება მიაქციეთ, რომ ჩემს ახალ ზოლზე არის დამთავრებული იმავე ხაზის, როგორც მათი სახელები, რომელიც გრძნობს ცოტა რთული. 

ამიტომ, მე ვაპირებ წასვლა აქ და რეალურად დასასრულს ამ პროგრამის ამობეჭდოთ სტრიქონების გადატანით ხასიათი. სულ ეს არის. ერთად printf, თქვენ არ უნდა გაივლის ცვლადები ან ფორმატი კოდი. თქვენ შეგიძლიათ სიტყვასიტყვით უბრალოდ ბეჭდვა რაღაც newline. 

მოდით, წავიდეთ წინ და ესარგებლა 0 ერთხელ, გამეორება ეს, Zamyla. და ახლა ეს პატარა გალამაზებაში. ახლა, ჩემი ზოლში არის საკუთარი ახალი ხაზი. ასე რომ, ყველა კარგი და კეთილი. ასე რომ, კარგი მაგალითი. მაგრამ მე კი არ არის აუცილებელი უნდა მძიმე კოდი 32. იცი რაა? მე ვერ იტყვის მე არ ოდესმე გვახსოვდეს, თუ რა განსხვავება არის. 

მაგრამ მე ვიცი, რომ თუ აქვს ქვედა შემთხვევაში წერილში, მე არსებითად გვინდა გამოვაკლოთ off რასაც მანძილი შორის პატარა a და დიდი, რადგან თუ მე ვივარაუდოთ, რომ ყველა სხვა წერილები იგივეა, რომ უნდა მიიღოს გაწეული სამუშაო. მაგრამ ვიდრე ამის გაკეთება, თქვენ იცით, რა? არსებობს კიდევ ერთი გზა მაინც. 

თუ ეს ესარგებლა 1.c-- თუ მე იმისათვის, რომ ცალკე ფაილი. მოდით ესარგებლა 2.c ასეთია. მე ვაპირებ ნამდვილად სუფთა ეს აქ. და ნაცვლად კი, რომელსაც ვიცი და არც მაინტერესებს, იმ დაბალი დონის განხორციელების დეტალები, მე ვარ ნაცვლად უბრალოდ აპირებს ბეჭდვა ხასიათი, ციტირებით unquote, პროცენტი C, და მაშინ მოვუწოდებთ სხვა ფუნქცია, რომელიც არსებობს ინფორმაცია, რომ იღებს არგუმენტი, რომელიც ხასიათი, მოსწონს ეს. 

თურმე C, არსებობს სხვა ფუნქცია ზარი ზედა, რომელიც, როგორც მისი სახელი ვარაუდობს იღებს ხასიათი და ხდის მის ზედა შემთხვევაში ექვივალენტს, და მერე დააბრუნებს მას ასე რომ printf შეგიძლიათ შეაერთედ მას იქ. ასე რომ, ამის გაკეთება, თუმცა, მე უნდა წარმოგიდგინოთ ერთი სხვა ფაილი. გამოდის, რომ კიდევ ერთი ფაილი რომ თქვენ მხოლოდ ვიცი კლასი, ან სახელმძღვანელოს, ან ონლაინ ცნობისთვის, სახელწოდებით C type.h. 

ასე რომ, თუ დავამატო, რომ მათ შორის ჩემი header ფაილი, და ახლა ხელახლა შეადგინონ ამ პროგრამის capitalize2, ./capitalize2 შეიტანეთ. მოდით აკრიფოთ Zamyla ყველა ამას, ჯერ კიდევ მუშაობს იგივე. მაგრამ იცით, რა? გამოდის, რომ ზედა აქვს ზოგიერთი სხვა ფუნქცია. 

და ნება მომეცით წარმოგიდგინოთ ამ ბრძანება აქ, ერთგვარი უხერხულად დაასახელა, მაგრამ კაცი სახელმძღვანელო. გამოდის, რომ ყველაზე Linux კომპიუტერები, როგორც ჩვენ გამოყენებით აქ Linux ოპერაციული system-- აქვს ბრძანება მოუწოდა კაცი, რომელიც ამბობს, hey, კომპიუტერი, მომეცი კომპიუტერის სახელმძღვანელო. რა გინდა რომ ეძებოთ იმ მექანიკური? 

მინდა გამოიყურებოდეს up ფუნქცია მოუწოდა ზედა, შეიტანეთ. და ეს ცოტა cryptic წაკითხვის ზოგჯერ. მაგრამ შეამჩნია, ჩვენ ვართ Linux პროგრამისტი სახელმძღვანელო. და ეს ყველაფერი ტექსტი. და შეამჩნია, რომ არსებობს სახელი ფუნქცია აქ. გამოდის, რომ მას აქვს ბიძაშვილი მოუწოდა შეამცირონ, რომელიც აკეთებს საპირისპირო. და შესაბამისად შეტყობინების შინაარსი, რათა გამოიყენონ ეს ფუნქციონირებს კაცი გვერდზე, ასე ვთქვათ, მეუბნებოდა, რომ მე უნდა შეიცავდეს გ type.h. და მე ვიცი, რომ პრაქტიკაში. 

აქ, ეს გვიჩვენებს მე ორ პროტოტიპები ფუნქცია, ასე რომ, თუ მე ოდესმე გვინდა გამოვიყენოთ ეს მე ვიცი, რა ისინი, როგორც input, და რა ისინი დაბრუნდებიან როგორც გამომავალი. და მაშინ, თუ წავიკითხე აღწერა, მე ვხედავ უფრო დეტალურად რა ფუნქცია აქვს. მაგრამ რაც მთავარია, თუ ვუყურებ ქვეშ დაბრუნების ღირებულება, იგი აცხადებს, რომ დაბრუნებული მნიშვნელობა არის რომ მოაქცია წერილი, ან C, ორიგინალური input, თუ კონვერტაციის არ იყო შესაძლებელი. 

სხვა სიტყვებით, ზედა შეეცდება გარდაქმნას წერილში ზედა შემთხვევაში. და თუ ასეა, ის აპირებს დაუბრუნდეს. მაგრამ თუ მას არ შეუძლია გარკვეული reason-- შესაძლოა, ეს უკვე ზედა შემთხვევაში, შესაძლოა, ეს ძახილის წერტილი ან სხვა punctuation-- ის უბრალოდ აპირებს დაბრუნდეს ორიგინალური C, რაც იმას ნიშნავს, მე შემიძლია ჩემი კოდი უკეთესი შექმნილია ასეთია. 

მე არ უნდა ყველა ამ darn ხაზი კოდი. ყველა ხაზების მე უბრალოდ ხაზი გაუსვა შეუძლია დაინგრა მხოლოდ ერთი მარტივი ხაზი, რომელიც არის ამ printf პროცენტი გ ზედა S bracket i. და ეს იქნება მაგალითად უკეთესი დიზაინი. 

რატომ განახორციელებს 7 ან 8 ხაზები კოდი, რაც არ იყო, მე უბრალოდ იშლება, როდესაც თქვენ შეგიძლიათ ნაცვლად დაიშალოს ყველა რომ ლოგიკა და გადაწყვეტილების მიღების ერთ ერთი ხაზი, 13 ახლა, რომ ეყრდნობა ბიბლიოთეკის ფუნქცია ფუნქცია, რომელიც გააჩნია C, მაგრამ ზუსტად რა გსურთ ამის გაკეთება. და, სიმართლე გითხრათ, თუნდაც ის არ მოდის C, თქვენ შეიძლება განახორციელოს იგი საკუთარ თავს, როგორც ჩვენ ვნახეთ, ერთად უარყოფითი int და დადებითი int გასულ კვირას, ისევე. 

ეს კოდი ახლა გაცილებით იკითხება. და, მართლაც, თუ ჩვენ გადახვევა up, შეხედეთ, როგორ ბევრად უფრო კომპაქტური ეს ვერსია ჩემი პროგრამა. ეს პატარა მძიმე ახლა, ყველა ამ მოიცავს. მაგრამ ეს კარგია, რადგან ახლა ვდგავარ მხრებზე პროგრამისტები ჩემამდე. და ვინც არ უნდა იყო, რომელიც განხორციელებული ზედა ნამდვილად ჩემთვის სასარგებლოდ, ჰგავს, ვინც განხორციელებული Stirling ნამდვილად ჩემთვის სასარგებლოდ რამდენიმე ხნის წინ. ასე რომ, ახლა ჩვენ გვაქვს უკეთესი დიზაინის პროგრამა რომელიც ახორციელებს ზუსტად იგივე ლოგიკით. 

საუბრისას Stirling, ნება მომეცით წავიდეთ წინ და ამის გაკეთება. ნება მომეცით წავიდეთ წინ და შენახვა ამ ფაილს, როგორც stirling.c. და აღმოჩნდება, ჩვენ შეგვიძლია კანი უკან ერთი სხვა ფენის საკმაოდ უბრალოდ ახლა. მე ვაპირებ წავიდეთ წინ და whip კიდევ ერთი პროგრამა მთავარი აქ უბრალოდ ხელახლა იარაღები სიმებიანი სიგრძე ასეთია. ასე რომ აქ ხაზი კოდი, რომ იღებს me სიმებიანი შესახებ. ჩვენ შევინარჩუნოთ გამოყენებით ეს ისევ და ისევ. ნება მომეცით მისცეს თავს ცვლადში n ტიპის int, რომელიც ინახავს ნომერი. 

და ნება მომეცით წავიდეთ წინ და შემდეგი ლოგიკა. მიუხედავად იმისა, რომ n-th პერსონაჟი s აკეთებს არ უდრის წარმატებული 0, წავიდეთ წინ და ნამატი n. და შემდეგ ამობეჭდოთ printf პროცენტი i n. მე ვამტკიცებ, რომ ამ პროგრამის, გარეშე მოუწოდებენ სიმებიანი სიგრძე, გათვლით, სიგრძეზე სიმებიანი. 

და ჯადოსნური მთლიანად ლაკონურად line 8 აქ რა ჰგავს ახალი სინტაქსი, ამ წარმატებული 0 ერთ შეთავაზებები. მაგრამ რატომ არის, რომ? ისე, რა იყო მიმდინარეობს ამ დროს. 

და როგორც განზე, სანამ მე დაგვავიწყდეს, გააცნობიეროს, ძალიან, რომ გარდა იმისა, რომ კაცი გვერდებზე რომ მოვიდა ერთად ტიპიური Linux სისტემა, როგორც CS50 IDE, გააცნობიეროს, რომ ჩვენ, რა თქმა უნდა, ის თანამშრომლები, ასევე გააკეთა საიტი ვერსია ამ იგივე იდეა მოუწოდა reference.cs50.net, რომელსაც აქვს ყველა იგივე კაცი გვერდებზე, ყველა რომ ერთი და იგივე დოკუმენტაცია, ისევე როგორც პატარა ყუთი ზედა, რომელიც საშუალებას საშუალებას გადაიყვანოთ ყველა სამართლიანად arcane ენიდან ნაკლებად კომფორტული რეჟიმი, სადაც, აკადემიური პერსონალის, გაიარა და ცდილობდა გამარტივება ზოგიერთი ენის შენარჩუნება რამ ორიენტირებულია იდეები, და არა ზოგიერთი ტექნიკური. ასე რომ, გახსოვდეთ, reference.cs50.net როგორც სხვა რესურსი. 

მაგრამ რატომ სიმებიანი სიგრძე მუშაობა გზა მე შევთავაზე მომენტში წინ? აი Zamyla სახელი ერთხელ. აქ არის Zamyla სახელი ჩარჩოში წელს, როგორც მე აკეთეთ, ხატავს სურათს, რომ იგი, ნამდვილად, უბრალოდ თანმიმდევრობა გმირები. მაგრამ Zamyla არ არსებობს იზოლაცია პროგრამა. 

როდესაც ვწერთ და გაუშვით პროგრამა, თქვენ იყენებთ თქვენს Mac ან თქვენი კომპიუტერის მეხსიერება, ან RAM, ასე ვთქვათ. და შეგიძლიათ წარმოიდგინოთ, თქვენს კომპიუტერში, როგორც უამრავი გბ მეხსიერების ამ დღეებში. და კონცერტი ნიშნავს მილიარდობით ასე მილიარდობით bytes. 

მაგრამ მოდით გადახვევა დროს. და ვფიქრობ, რომ ჩვენ გამოყენებით ნამდვილად ძველი კომპიუტერი, რომელიც მხოლოდ 32 ბაიტი მეხსიერება. შემეძლო, ჩემი კომპიუტერის ეკრანზე, უბრალოდ მიაპყროს ამ out ასეთია. 

მე უბრალოდ ვამბობ, რომ ჩემი კომპიუტერი ყველა ამ მეხსიერების. და ეს არის, როგორც ჯოხი მეხსიერება, თუ თქვენ გავიხსენოთ ჩვენი სურათი ბოლო დროს. და თუ მე გავყოფ ეს საკმარისი ჯერ, I აცხადებენ, რომ 32 bytes მეხსიერების ეკრანზე. 

ახლა, რეალურად, მხოლოდ ის შემიძლია მიაპყროს ჯერჯერობით ამ ეკრანზე აქ. ამიტომ, მე ვაპირებ წავიდეთ წინ, და მხოლოდ კონვენციის, მიაპყროს ჩემი კომპიუტერის მეხსიერებაში, როგორც ქსელის, არა მხოლოდ როგორც ერთ-ერთი სწორი ხაზი. კერძოდ, რომ აცხადებენ, რომ ამ ქსელის, ამ 8 4 ქსელის, უბრალოდ წარმოადგენს ყველა 32 bytes მეხსიერების ხელმისაწვდომია ჩემი Mac, ან შესაძლებელია ჩემი კომპიუტერი. და ისინი შესაფუთი on ორი ხაზი, უბრალოდ რადგან ის შეესაბამება უფრო ეკრანზე. მაგრამ ეს არის პირველი byte. ეს არის მეორე byte. ეს არის მესამე byte. 

და ეს არის 32-ე byte. ან, თუ ჩვენ ვფიქრობთ, როგორიცაა კომპიუტერი მეცნიერი, ეს არის byte 0, 1, 2, 3, 31. ასე, რომ თქვენ 0 to 31, თუ თქვენ დაიწყება დათვლის დროს 0. 

ასე რომ, თუ ჩვენ ვიყენებთ პროგრამა რომ მოწოდებები მიიღოს სიმებიანი, და მივიღებთ string ადამიანის როგორიც მე მოუწოდა Zamyla, Z-A-M-Y-L-A, როგორ მსოფლიოში აკეთებს კომპიუტერული ტრეკზე რომელიც byte, რომელიც ბლოკი მეხსიერება, ეკუთვნის, რომელიც სიმებიანი? სხვა სიტყვებით, თუ ვაგრძელებთ ჩაწერეთ სხვა სახელი კომპიუტერი, მოსწონს ეს Andi, მოუწოდებს სიმებიანი მეორედ, A-N-D-I უნდა დასრულდება მდე კომპიუტერის მეხსიერებაში, ასევე. მაგრამ როგორ? 

ასევე, ირკვევა, რომ ქვეშ hood, რა C აკეთებს, როდესაც შენახვის სტრიქონები რომ ადამიანის სახის, ან, რომ მოდის ზოგიერთი სხვა წყარო, არის ის, განსაზღვრავს ბოლოს მათ სპეციალური პერსონაჟი წარმატებული 0, რომელიც არის სპეციალური გზა ამბობდა 80 ბიტი ზედიზედ. 

ასე რომ, A-- ეს არის ნომერი 97 გაწვევას. ასე რომ ზოგიერთი ნიმუში 8 ბიტი წარმოადგენს ათობითი ნომერი 97. ეს წარმატებული 0 არის სიტყვასიტყვით ნომერი 0, a.k.a. nul, N-U-L, განსხვავებით ადრე, N-U-L-L, რომელიც ჩვენ ვისაუბრეთ. მაგრამ ახლა, უბრალოდ ვიცი, რომ ეს წარმატებული 0 არის მხოლოდ 80 ბიტი ზედიზედ. 

და ეს მხოლოდ ამ ხაზის ქვიშა, რომ რამეს მარცხენა ეკუთვნის ერთ სიმებიანი, ან ერთი მონაცემების ტიპის. და არაფერი მარჯვნივ ეკუთვნის რაღაც. Andi სახელი, იმავდროულად, რომელიც მხოლოდ ვიზუალურად ხდება გადაიტანოთ შესახებ, რომ მეორე ხაზი, მაგრამ ეს მხოლოდ ესთეტიკური დეტალურად ანალოგიურად არის nul წყდება. 

ეს არის სიმებიანი A-N-D-I გმირები, პლუს მეხუთე საიდუმლო ხასიათი, ყველა 0 ბიტი, რომ მხოლოდ demarcates ბოლოს Andi სახელი ისევე. და თუ ჩვენ მოვუწოდებთ მიიღოს სიმებიანი მესამედ კომპიუტერული მისაღებად სიმებიანი მოსწონს Maria, M-A-R-I-A, ასეთივე არის მარია სახელი nul წყდება წარმატებული 0. 

ეს არის ფუნდამენტურად განსხვავებული ეხლა როგორ კომპიუტერი, როგორც წესი, შესანახად რიცხვი, ან float, ან სხვა მონაცემთა ტიპები მაინც, იმიტომ, რომ გავიხსენოთ, რიცხვი, როგორც წესი, 32 ბიტი, ან 4 ბაიტი, ან თუნდაც 64 ბიტი, ან რვა ბაიტს. მაგრამ ბევრი primitives in კომპიუტერი პროგრამირების ენა ფიქსირებული ნომერი bytes ქვეშ hood-- შესაძლოა, 1, შესაძლოა, 2, იქნებ 4, შესაძლოა, 8. 

მაგრამ სიმები, დიზაინი, აქვს დინამიური რაოდენობის სიმბოლოს. თქვენ არ ვიცი წინასწარ, სანამ ადამიანის სახის Z-A-M-Y-L-A, ან M-A-R-I-A, ან A-N-D-I. თქვენ არ ვიცი რამდენჯერ შესახებ აპირებს მოხვდა კლავიატურაზე. აქედან გამომდინარე, თუ თქვენ არ იცით, თუ როგორ ბევრი პერსონაჟი წინასწარ თქვენ აპირებთ უნდა. 

ასე რომ, C უბრალოდ სახის ტოვებს მოსწონს საიდუმლო breadcrumb ქვეშ hood ბოლოს სიმებიანი. მას შემდეგ, რაც შენახვის Z-A-M-Y-L-A მეხსიერება, მას ასევე მხოლოდ აყენებს ექვივალენტი პერიოდი. ბოლოს სასჯელი, ეს აყენებს 80 ბიტი, ისე, რომ უნდა გვახსოვდეს, სადაც Zamyla იწყება და მთავრდება. 

ასე რომ, რა კავშირი, მაშინ, ეს პროგრამა? ეს პროგრამა აქ, Stirling, უბრალოდ მექანიზმი მიღების სიმებიანი შესახებ, line 6. Line 7, ვაცხადებ ცვლადი მოუწოდა N და ვაყენებთ მას ტოლი 0. 

ხოლო შემდეგ ხაზი 8, მე უბრალოდ სთხოვა კითხვაზე, ხოლო n-th ხასიათი აქვს არ უდრის ყველა 0 ბიტი სხვა სიტყვებით, არ თანაბარი ამ სპეციალური ხასიათი, წარმატებული 0, რაც იყო მხოლოდ, რომ სპეციალური nul პერსონაჟი წავიდეთ წინ და მხოლოდ ნამატი n. 

და აკეთეთ ის, და შეინახოს ამის გაკეთება, და აკეთეთ ის. ასე რომ, მიუხედავად იმისა, რომ წარსულში ჩვენ გამოიყენება i, ეს შესანიშნავად ჯარიმა სემანტიკურად გამოიყენოს ო, თუ თქვენ უბრალოდ ცდილობს იმედი ამ დროს შეგნებულად, და უბრალოდ ეძახით n. ასე რომ, ეს მხოლოდ ინარჩუნებს სვამს კითხვას, არის n-ე ხასიათი s ყველა 0S? თუ არა, გამოიყურება შემდეგ სახეს, გამოიყურება შემდეგ, გამოიყურება შემდეგ, გამოიყურება შემდეგ. 

მაგრამ, როგორც კი ხედავთ წარმატებული 0, ამ მარყუჟის ხაზი 9 11-- შეწყვეტს. თქვენ შესვენება, ხოლო მარყუჟის, რის გამოც შიგნით რომ ცვლადი n სულ გრაფი ყველა სიმბოლოების სიმებიანი დაინახა, ამით ბეჭდვის ის. მოდით ცდილობენ. 

ნება მომეცით წავიდეთ წინ და გარეშე გამოყენებით Stirling ფუნქცია, მაგრამ მხოლოდ გამოყენებით საკუთარი homegrown მობილური აქ მოუწოდა Stirling, ნება მომეცით წავიდეთ წინ და აწარმოებს Stirling, ტიპის რაღაც მოსწონს Zamyla, რაც მე ვიცი წინასწარ არის ექვსი სიმბოლო. ვნახოთ, თუ იგი მუშაობს. მართლაც, ეს ექვსი. მოდით ცდილობენ რობ სამი პერსონაჟი, სამი პერსონაჟი, ისევე, და სხვ. ასე რომ, ყველა, რომ აპირებს ქვეშ hood. და შენიშნავს, კავშირები, მაშინ, პირველ კვირას კლასი, სადაც ჩვენ ვისაუბრეთ რაღაც აბსტრაქცია, რომელიც მხოლოდ ამ layering იდეების, ან სირთულის, თავზე ძირითად პრინციპებს. აქ, ჩვენ ერთგვარი ეძებს ქვეშ hood Stirling, ასე ვთქვათ, გაერკვნენ, როგორ უნდა განხორციელდეს? 

და ჩვენ შეგვიძლია ხელახლა განახორციელოს იგი საკუთარ თავს. მაგრამ ჩვენ აღარასოდეს აპირებს ხელახლა განახორციელოს Stirling. ჩვენ უბრალოდ აპირებს გამოყენება Stirling, რათა რეალურად მიიღოთ გარკვეული სიმები სიგრძეზე. 

მაგრამ არ არსებობს ჯადოსნური ქვეშ hood. თუ თქვენ იცით, რომ ქვეშ Hood, string მხოლოდ თანმიმდევრობა სიმბოლო. და რომ თანმიმდევრობა გმირები ყველა შეიძლება რიცხობრივი მიმართა ერთად bracket 0, bracket 1, bracket 2, და თქვენ ვიცი, რომ ბოლოს სიმებიანი არის განსაკუთრებული ხასიათი, შეგიძლიათ გაერკვნენ როგორ უნდა გავაკეთოთ ყველაზე არაფერი პროგრამა, რადგან ყველა ეს boils ქვემოთ ეს კითხვა და წერა მეხსიერება. რომ არის, იცვლება და ეძებს მეხსიერების, ან მოძრავი რამ გარშემო მეხსიერების, ბეჭდვა რამ ეკრანზე, და სხვ. 

მოდით ახლა გამოიყენოთ ტენდენციები გაგება, თუ რა სიმები რეალურად ხართ ქვეშ Hood, და კანი უკან ერთი სხვა ფენის რომ აქამდე ჩვენ იგნორირება საერთოდ. კერძოდ, ნებისმიერ დროს ჩვენ განხორციელებული პროგრამა, ჩვენ გვქონდა ამ ხაზი კოდი ახლოს დაბრუნება გამოცხადების მთავარი. და ჩვენ მითითებული int ძირითადი ბათილად. 

და რომ ბათილად შიგნით ფრჩხილებში უკვე განაცხადა, მთელი ამ დროის განმავლობაში, რომ მთავარი თავად არ მიიღოს ნებისმიერი არგუმენტები. ნებისმიერი შეყვანის რომ მთავარი არის აპირებს მიიღოს მომხმარებელი უნდა მოდიოდეს სხვა მექანიზმი, ისევე მისაღებად int, ან კიდევ float, ან მიიღოთ ტექსტი, და ზოგიერთი სხვა ფუნქცია. მაგრამ აღმოჩნდება, რომ როდესაც წერთ პროგრამა, თქვენ შეგიძლიათ რეალურად დააკონკრეტა რომ ეს პროგრამა უნდა მიიღოს საშუალებებით ადამიანის ბრძანებათა ზოლს თავად. 

სხვა სიტყვებით, მიუხედავად იმისა, რომ დღემდე უკვე გაშვებული მხოლოდ მიესალმები მიესალმები ან მსგავს პროგრამებს, ყველა სხვა პროგრამები, რომ ჩვენ უკვე გამოყენებით, რომ ჩვენ თვითონ არ წერენ, უკვე აღების, როგორც ჩანს, ბრძანების არგუმენტი რამ, როგორიცაა მიიღოს. თქვენ ამბობთ, რომ რაღაც გააკეთოს, და მერე მეორე სიტყვა. ან clang, ითქვას clang და შემდეგ მეორე სიტყვა, სახელი ფაილი. 

ან თუნდაც RM და CP, როგორც თქვენ არ მინახავს ან უკვე ამოიღონ ან კოპირება ფაილი. ყველა იმ მიიღოს ე.წ. ბრძანების არგუმენტი დამატებითი სიტყვა ტერმინალში ზოლზე. მაგრამ დღემდე, ჩვენ თავს არ ჰქონდა ამ ფუფუნების აღების შეიტანენ შესახებ, როდესაც ის რეალურად მართავს პროგრამა თავისთავად ბრძანებათა ზოლს. 

მაგრამ ჩვენ შეგვიძლია გავაკეთოთ, რომ ხელახლა გამოცხადების მთავარი მიიწევს წინ, არა, როგორც ბათილად ფრჩხილებში, მაგრამ ეს ორი არგუმენტები instead-- პირველი რიცხვი, და მეორე რაღაც ახალი, რაღაც რომ ჩვენ ვაპირებთ, რომ მოვუწოდო მასივი, რაღაც მსგავსი სულისკვეთებით რა ვნახეთ Scratch, როგორც სია, მაგრამ მასივი სიმები, როგორც ჩვენ მალე. მაგრამ ვნახოთ, ამ მაგალითად, სანამ ჩვენ ზღვარის ზუსტად რას ნიშნავს ეს. 

ასე რომ, თუ მე წასვლას CS50 IDE აქ, მე წავიდა წინ და განაცხადა, ფაილი სახელად argv0.c შემდეგ template. და შენიშნავს, რომ ერთადერთი, რაც რომ სხვადასხვა ჯერჯერობით ის არის, რომ მე შეიცვალა ბათილად int, argc სიმებიანი argv ღია bracket, ახლოს bracket. და შეამჩნია, რომ ახლა, იქ არაფერი შიგნით იმ ფრჩხილებში. 

იქ არ არის ნომერი. და არ არსებობს მე, ან n, ან ნებისმიერი სხვა წერილში. მე უბრალოდ გამოყენებით კვადრატულ ფრჩხილებში ახლა, მიზეზების გამო, ჩვენ მოვალთ უკან რაღაც მომენტში. 

და ახლა რა მე ვაპირებ ამის გაკეთებას, ეს არის. თუ argc უდრის უდრის 2- და გავიხსენოთ, რომ შეადგენს შეადგენს არის თანასწორობის ოპერატორს შედარებით მარცხენა და მარჯვენა თანასწორობა. ეს არ არის დავალება ოპერატორი, რომელიც არის ერთი თანაბარი ნიშანი, რაც იმას ნიშნავს, ასლი მარჯვნიდან მარცხენა გარკვეული მნიშვნელობა. 

თუ argc უდრის უდრის 2, მინდა ვთქვათ, printf, hello, პროცენტების, ახალი ხაზი, ხოლო შემდეგ დანამატის შიგნით და აქ ახალი ხრიკი argv bracket 1, იმის გამო, რომ ჩვენ დავბრუნდებით ამ მომენტში. სხვაგან, თუ argc არ თანაბარი 2, იცით, რა? მოდით უბრალოდ წავიდეთ წინ და, როგორც ყოველთვის, ბეჭდვითი out hello მსოფლიოში არ რიგებში. 

ასე რომ, როგორც ჩანს, რომ იმ შემთხვევაში, თუ argc, რომელიც დგას არგუმენტი რაოდენობა, უდრის 2, მე ვაპირებ ამობეჭდოთ მიესალმები რაღაც ან სხვა. წინააღმდეგ შემთხვევაში, ძირითადად, მე აპირებს ბეჭდვა hello მსოფლიოში. ასე რომ, რას ნიშნავს ეს? 

ასევე, ნება მომეცით წავიდეთ წინ და შენახვა ეს ფაილი და შემდეგ გააკეთოს argv0, და შემდეგ ./argv0, შეიტანეთ. ის ამბობს hello მსოფლიოში. ახლა, რატომ არის, რომ? 

ისე, გამოდის, ნებისმიერ დროს აწარმოებს პროგრამის ბრძანების, თქვენ შევსების, რაც ჩვენ ზოგადად მოვუწოდებთ არგუმენტი ვექტორი. სხვა სიტყვებით, ავტომატურად კომპიუტერი, ოპერაციული სისტემა, აპირებს გადასცემს თქვენი პროგრამა თავად სიაში ყველა სიტყვა რომ ადამიანის აკრეფილი სწრაფი, იმ შემთხვევაში, თუ პროგრამისტი მინდა ამის გაკეთება რაღაც, რომ ინფორმაცია. და ამ შემთხვევაში, მხოლოდ სიტყვა მე აკრეფილი ბრძანებათა ზოლში არის ./argv0. 

ასე რომ, ნომერი არგუმენტები, რომ არის მიმდინარეობს გავიდა ჩემი პროგრამა არის მხოლოდ ერთი. სხვა სიტყვებით, არგუმენტი იმედი, სხვაგვარად ცნობილია როგორც argc აქ, როგორც მთელი რიცხვი, არის მხოლოდ ერთი. ერთ-ერთი, რა თქმა უნდა, არ თანაბარი ორი. ასე რომ, ეს არის ის, რაც ბეჭდავს, hello მსოფლიოში. 

მაგრამ ნება მომეცით მიიღოს ეს სადღაც. მინდა ვთქვა, argv0. და მაშინ როგორ შესახებ Maria? და შემდეგ დააჭიროთ. 

და შეამჩნია რა magically ხდება აქ. ახლა, ნაცვლად Hello World, მე მაქვს შეცვალა ქცევა ამ პროგრამის აღების შეყვანის არა მისაღებად სიმებიანი ან ზოგიერთი სხვა ფუნქცია, მაგრამ, როგორც ჩანს, ჩემი ბრძანება თავისთავად, რაც მე თავდაპირველად აკრეფილი. მე და შეგიძლიათ ითამაშოთ ეს თამაში ისევ შეცვლის მას Stelios, მაგალითად. 

და ახლა მე ვხედავ სხვა სახელი მაინც. და აქ, მე შეიძლება ითქვას Andi. და შეიძლება ითქვას, Zamyla. და ჩვენ შეგვიძლია ითამაშოს ამ თამაშში მთელი დღის განმავლობაში, უბრალოდ ჩართვის განსხვავებული ღირებულებები, ასე რომ, სანამ მე გთავაზობთ ზუსტად ორი სიტყვა დროს სწრაფი, ისეთი, რომ argc, ჩემი არგუმენტი ითვლიან, 2. 

ვხედავ, რომ სახელი plugged შევიდა printf, პოსტი ამ მდგომარეობის აქ? ასე რომ, ჩვენ, როგორც ჩანს, ახლა ექსპრესიული შესაძლებლობების აღების შეყვანის კიდევ ერთი მექანიზმი, საწყისი ე.წ. ბრძანების, ვიდრე დაველოდოთ სანამ მომხმარებლის ეშვება პროგრამა, და შემდეგ გამოიწვიოს მას გამოყენებით რაღაც მიიღოს სიმებიანი. 

ასე რომ, რა არის ეს? Argc, კიდევ ერთხელ, მხოლოდ რიცხვი, რაოდენობის words-- არგუმენტი რომ მომხმარებელს უზრუნველყოფილი სწრაფი, ტერმინალში ფანჯარა, მათ შორის, პროგრამის სახელი. ასე რომ, ჩვენი ./argv0, პრაქტიკულად, პროგრამის სახელი, ან როგორ აწარმოებს პროგრამა. 

რომ ითვლის როგორც სიტყვა. ასე რომ, argc იქნება 1. მაგრამ, როდესაც ვწერ Stelios, ან Andi, ან Zamyla, და მარია, ეს ნიშნავს, რომ არგუმენტი რაოდენობა ორი. ასე რომ, ახლა არსებობს ორი სიტყვა გავიდა. 

და შეამჩნია, რომ ჩვენ შეგვიძლია გავაგრძელოთ ამ ლოგიკით. თუ მე რეალურად ამბობენ რაღაც Zamyla Chan, სრული სახელი, რითაც ავლით სამი არგუმენტები საერთო ჯამში, ახლა იგი აცხადებს, რომ ძირითადად, კიდევ ერთხელ, იმიტომ, რომ, რა თქმა უნდა, 3 არ უდრის 2. 

ასე რომ, ამ გზით, მაქვს მეშვეობით argv ახალი არგუმენტი რომ ჩვენ შეგვიძლია ტექნიკურად მოვუწოდებთ არაფერი გვინდა. მაგრამ კონვენციის, ეს argv და argc, შესაბამისად. Argv, არგუმენტი ვექტორი, არის ერთგვარი საქართველოს სინონიმი პროგრამირების ფუნქცია C მოუწოდა მასივი. 

მასივი ჩამოთვლილია მსგავსი ღირებულებები უკან, უკან, უკან, უკან. სხვა სიტყვებით, თუ ერთი უფლება აქ RAM, შემდეგი ერთი არის სწორი, რომ ეს, და მარჯვენა შემდეგი მას. ისინი არ მთელი ადგილი. და რომ ეს უკანასკნელი სცენარი, სადაც ყველაფერი არიან მთელი ადგილი მეხსიერებაში, შეიძლება რეალურად იყოს ძლიერი თვისება. მაგრამ ჩვენ დავბრუნდებით, რომ როდესაც ჩვენ ვისაუბროთ fancier მონაცემების სტრუქტურები. ახლა, მასივი არის მხოლოდ ბლოკი მიმდებარე მეხსიერების, თითოეული რომლის ელემენტები არიან უკან, უკან, უკან, უკან, და საერთოდ, იგივე ტიპის. 

ასე რომ, თუ თქვენ ფიქრობთ, საწყისი მომენტში წინ, რა არის სიმებიანი? ისე, სიმებიანი, როგორიცაა Zamyla, Z-A-M-Y-L-A, არის, ტექნიკურად, მხოლოდ მასივი. ეს მასივი სიმბოლო. 

ასე რომ, თუ ჩვენ ნამდვილად მიაპყროს ამ, როგორც მე გავაკეთეთ ადრე, როგორც ბლოკი მეხსიერება, გამოდის, რომ თითოეული ეს გმირები იკავებს byte. და მერე იქ რომ სპეციალური Sentinel ხასიათი, წარმატებული 0, ან ყველა რვა 0 ბიტი, demarcates ბოლოს რომ სიმებიანი. ასე რომ, სიმებიანი, გამოდის გარეთ, შეთავაზება unquote სიმებიანი, მხოლოდ მასივი chara-- char რომ ფაქტობრივი მონაცემების ტიპის. 

და ახლა argv, meanwhile-- მოდით დავუბრუნდეთ პროგრამა. Argv, მიუხედავად იმისა, რომ ჩვენ ვხედავთ სიტყვას სიმებიანი აქ, არ არის სიმებიანი თავად. Argv, არგუმენტი ვექტორი, არის მასივი strings. 

ასე რომ, როგორც თქვენ შეგიძლიათ მასივი გმირები, შეგიძლიათ მაღალ დონეზე, მასივი strings-- ასე, მაგალითად, როდესაც მე აკრეფილი მომენტში წინ ./argv0 argv0, სივრცე Z-A-M-Y-L-A, ვამბობდი, რომ argv გვქონდა ორი სიმები in it-- ./argv0, და Z-A-M-Y-L-A. in სხვა სიტყვებით, argc 2. რატომ არის, რომ? 

ისე, ეფექტურად, თუ რა ხდება ის არის, რომ თითოეული ამ strings არის, რა თქმა უნდა, მასივი გმირები როგორც ადრე, თითოეული რომლის გმირები იღებს ერთი ბაიტი. და არ აღრეული ფაქტობრივი 0 პროგრამაში სახელს 0, რაც იმას ნიშნავს, ყველა 80 ბიტი. და Zamyla, იმავდროულად, არის კიდევ ასევე მასივი სიმბოლო. 

ასე რომ, დღის ბოლოს, ეს ნამდვილად ასე გამოიყურება ქვეშ hood. მაგრამ argv, ბუნებით, თუ როგორ მთავარი სამუშაოები, საშუალებას მაძლევს, რომ გადაიტანოთ ეს ყველაფერი შევიდა, თუ გნებავთ, უფრო დიდი მასივი რომ, თუ ჩვენ ოდნავ მეტი გაამარტივებს რა სურათზე ჰგავს და არ საკმაოდ დახაზვა გავაფართოვოთ იქ, ამ მასივი მხოლოდ ზომა 2, პირველი ელემენტს, რომელიც შეიცავს სიმებიანი, მეორე ელემენტს რომელიც შეიცავს სიმებიანი. და, თავის მხრივ, თუ თქვენ სახის მიუახლოვდით თითოეულ იმ strings, რას ვხედავ ქვეშ hood არის, რომ თითოეული სიმებიანი მხოლოდ მასივი სიმბოლო. 

ახლა, ისევე როგორც სიმები, ჩვენ შევძელით, რომ მიიღოთ დაშვება რომ i-th პერსონაჟი სიმებიანი გამოყენებით, რომ კვადრატული ფრჩხილი ნოტაცია. ანალოგიურად, მასივები ზოგადად, შეგვიძლია გამოყენება კვადრატულ bracket notation მისაღებად ნებისმიერ რაოდენობა სიმებიანი მასივი? მაგალითად, ნება მომეცით წავიდეთ წინ და ამის გაკეთება. 

ნება მომეცით წავიდეთ წინ და შექმნას argv1.c, რომელიც ცოტა განსხვავებული ამ დროს. იმის ნაცვლად, რომ შემოწმების argc2, მე ვაპირებ ნაცვლად ამის გაკეთება. განთავსების int მივიღებ 0, მე ნაკლებად ვიდრე argc, მე plus plus, და შემდეგ ამობეჭდოთ შიგნით ამ, პროცენტს s, ახალი ხაზი, და შემდეგ argv bracket i. 

სხვა სიტყვებით, მე არ საქმე ინდივიდუალური გმირები მომენტში. Argv, როგორც ითვალისწინებს ამ ცარიელი მოედანი braces მარჯვნივ სახელი argv, ნიშნავს argv არის მასივი სტრიქონები. და argc მხოლოდ int. 

ეს ხაზი აქ, 6, არის ამბობდა კომპლექტი i = 0. ითვლიან ყველა გზა მდე, მაგრამ არა, argc. და შემდეგ თითოეულ iteration, ამობეჭდოთ სიმებიანი. რა სიმებიანი? 

I-th სიმებიანი argv. ასე რომ, მაშინ ადრე ვიყავი გამოყენებით კვადრატული ფრჩხილი notation მისაღებად ზე შ პერსონაჟი სიმებიანი, ახლა მე გამოყენებით კვადრატული ფრჩხილი ნოტაცია მისაღებად ზე შ სიმებიანი მასივი. ასე რომ, ეს არის ერთგვარი ერთი ფენა ზემოთ, კონცეპტუალურად. 

ასე რომ, რა არის გარღვევა ამ პროგრამა არის, თუ მე კომპილაციის argv1, და შემდეგ გააკეთოს ./argv1, და შემდეგ აკრიფოთ რაღაც foo ბარი baz, რომლებიც სამი ძირითადად სიტყვები, რომ კომპიუტერული მეცნიერი აღწევს ნებისმიერ დროს მას სჭირდება გარკვეული ჩანაცვლების სიტყვები, და დააჭიროთ, თითოეული იმ სიტყვებით, მათ შორის, პროგრამის სახელწოდება, რომელიც არის argv პირველ ადგილას, მთავრდება იბეჭდება ერთ დროს. და თუ მე შეცვალოს ეს, და მე ვიტყვი, რაღაც argv1 Zamyla Chan, მივიღებთ სამივე იმ სიტყვა, რომელიც argv0, argv1, argv2, რადგან ამ შემთხვევაში argc, რაოდენობა, არის 3. 

მაგრამ რა არის გარღვევა არის თუ გესმით რომ argv მხოლოდ მასივი strings, და თქვენ იცით, რომ სიმებიანი არის მასივი გმირები, ჩვენ შეგვიძლია რეალურად სახის გამოიყენოს ეს კვადრატული ფრჩხილი ნოტაცია რამდენჯერმე აირჩიოს სიმებიანი და შემდეგ აირჩიოს ხასიათი ფარგლებში სიმებიანი, diving ღრმა ასეთია. ამ მაგალითად, ნება მომეცით წავიდეთ წინ და დაარქვით argv2.c. და ამ მაგალითად, ნება მომეცით წავიდეთ წინ და გავაკეთოთ შემდეგი for int i მისაღებად 0, i ნაკლებია, ვიდრე argc, i პლუს პლუს, ისევე როგორც ადრე. ასე რომ, სხვა words-- და ახლა ეს დღითიდღე რთული. ამის შემდეგ მე ვაპირებ ვთქვა გადაურბინოთ სიმებიანი argv, როგორც კომენტარი თავს. და შემდეგ მე ვაპირებ აქვს წყობილი მარყუჟის, რომელიც, ალბათ, არ კეთდება, ან განიხილება აკეთებს, Scratch, სადაც მე ვაპირებ ვთქვა გაკეთება int ვარ არ ვაპირებთ გამოვიყენოთ ისევ, იმიტომ, რომ მე არ მინდა, რომ დაჩრდილოს, ან ერთგვარი გადავაწერო არსებულ i. 

მე ვაპირებ, ნაცვლად, ვთქვათ, j, იმიტომ, ეს არის ჩემი გადასვლა ცვლადი შემდეგ i, როდესაც მე უბრალოდ ცდილობს იმედი მარტივი ნომრები. იყიდება j იღებს 0- და ასევე, n, აპირებს მიიღეთ stern სიგრძე argv bracket i, ასე რომ, სანამ კ ნაკლებია, ვიდრე მ, j პლუს პლუს, ამის შემდეგ. აქ არის საინტერესო. 

ამობეჭდოთ ხასიათი და ახალი ხაზი, ჩართვის argv bracket i, bracket კ. OK, ნება მომეცით დაამატოთ ზოგიერთი კომენტარი აქ. გადაურბინოთ გმირები მიმდინარე სიმებიანი, ბეჭდვითი j-th ხასიათი i-th სიმებიანი. ახლა, მოდით, განვიხილოთ რა ეს კომენტარი ნიშნავს. 

გადაურბინოთ სიმები in argv-- რამდენი სიმები არიან argv, რომელიც არის მასივი? Argc ბევრი, ასე რომ მე iterating ეხლა მე გაუტოლდება 0 მდე argc. იმავდროულად, რამდენი გმირები არიან i-th სიმებიანი argv? 

ისე, რომ მიიღოს, რომ პასუხი, მე უბრალოდ დარეკოთ სიმებიანი სიგრძე მიმდინარე სიმებიანი მოვლა შესახებ, რომელიც argv bracket i. და მე ვაპირებ დროებით შესანახად, რომ მნიშვნელობა N, უბრალოდ ქეშირების მიზნებისათვის, უნდა გვახსოვდეს, რომ ეს ეფექტურობა. და შემდეგ მე ვაპირებ ინიციალიზაცია j 0, შენარჩუნებას აპირებს მანამ, სანამ კ ნაკლებია, ვიდრე n, და თითოეულ iteration ბიჯი კ. 

და მაშინ აქ, თითო ჩემი კომენტარი on line 12 ამობეჭდოთ ხასიათი, მოყვება ახალი ხაზი, კონკრეტულად argv bracket i მაძლევს i-th string in argv-- ასე რომ, პირველი სიტყვა, მეორე სიტყვა, მესამე სიტყვა, რასაც. და შემდეგ კ dives ღრმა, და იღებს ჩემთვის j-ე ხასიათი, რომ სიტყვა. ასე რომ, ფაქტობრივად, შეგიძლიათ მკურნალობა argv როგორც მრავალ განზომილებიანი, როგორც ორგანზომილებიანი, მასივი, რომლის დროსაც ყოველი სიტყვა სახის გამოიყურება მოსწონს ეს თქვენი აზრით თვალი, და ყოველ ხასიათი არის სახის შედგება სვეტი, თუ, რომელიც ეხმარება. 

სინამდვილეში, როდესაც ჩვენ tease ამ გარდა მომავალში კვირის განმავლობაში, ის აპირებს, რომ იყოს პატარა უფრო დახვეწილი, ვიდრე. მაგრამ თქვენ ნამდვილად ვფიქრობ, რომ ახლა, როგორც მხოლოდ ამ ორგანზომილებიანი მასივი, რომლის ერთ დონეზე ეს არის ყველა სიმები. და მაშინ, თუ თქვენ ჩაყვინთვის უფრო ღრმა, თქვენ შეგიძლიათ მიიღოთ ინდივიდუალური სიმბოლოების მასში გამოყენებით ამ notation აქ. 

ასე რომ, რა არის წმინდა ეფექტი? ნება მომეცით წავიდეთ წინ და რათა argv2-- darn იგი. შევცდი აქ. მინიშნებით გამოცხადების ბიბლიოთეკის ფუნქცია Stirling. ამიტომ, ამ დროს, ეს ალბათ შესაბამისი რომ ჩვენ ერთგვარი დასრულების სწორედ იქ, სადაც ჩვენ დავიწყეთ. 

მე ბრალია, მინიშნებით გამოცხადების ბიბლიოთეკის ფუნქცია Stirling. OK, დაველოდოთ წუთში. მახსოვს, რომ, განსაკუთრებით მას შემდეგ, რაც არის აქ. მე უნდა შეიცავდეს string.h in ეს ვერსია პროგრამა. 

ნება მომეცით წავიდეთ წინ და მოიცავს string.h, შენახვა, რომ, წავიდეთ წინ და recompile argv2. და ახლა, აქ ჩვენ მივდივართ, რათა argv2, შეიტანეთ. მიუხედავად იმისა, რომ ეს არის პატარა cryptic ერთი შეხედვით, შეამჩნევთ, რომ, მართლაც, რა იბეჭდება არის dot argv2. 

მაგრამ თუ მე აკრიფოთ ზოგიერთი სიტყვა შემდეგ სწრაფი, როგორც argv2 Zamyla Chan, შეიტანეთ, ასევე პატარა cryptic ერთი შეხედვით. მაგრამ თუ ჩვენ გადახვევა უკან, ./argv2 Z-A-M-Y-L-A C-H-A-N. ასე რომ, ჩვენ iterated ზე ყოველ სიტყვას. და, თავის მხრივ, ჩვენ iterated მეტი ყოველ ხასიათის ფარგლებში სიტყვა. 

ახლა, მას შემდეგ ეს ყველაფერი, გააცნობიეროს, რომ არსებობს ერთი სხვა დეტალურად ჩვენ უკვე სახის იგნორირება ამ მთელი დრო. ჩვენ მხოლოდ teased გარდა რა მთავარი ის საშუალებებით შეიძლება იყოს? რაც შეეხება ძირითად გამომავალი? 

მთელი ამ დროის განმავლობაში, ჩვენ მხოლოდ კოპირება და pasting სიტყვა int თვალწინ მთავარი, მიუხედავად იმისა, რომ თქვენ შეიძლება ნახოთ შემოსული, ზოგჯერ არასწორად ძველი ვერსია C და შემდგენელი, რომ ისინი აცხადებენ, ბათილად, ან არაფერი. მაგრამ, მართლაც, მობილური C რომ ჩვენ გამოყენებით, C 11, ან 2011, გააცნობიეროს, რომ ეს უნდა იყოს int. და ეს უნდა იყოს ბათილად ან argc და argv აქ. 

მაგრამ რატომ int მთავარი? რა არის ეს რეალურად დაბრუნების? ისე, გამოდის, მთელი ამ დროის განმავლობაში, ნებისმიერ დროს თქვენ წერილობითი პროგრამის ძირითადი ყოველთვის დაბრუნების რაღაც. მაგრამ ეს უკვე ამით ფარულად. 

რომ რაღაც int, რადგან line 5 ვარაუდობს. მაგრამ რა int? ისე, რომ ამ კონვენციის პროგრამირებაში, რომლის მიხედვითაც, თუ არაფერი აქვს წავიდა არასწორი და ყველა კარგად არის, პროგრამების და ფუნქციების ზოგადად დაბრუნდება გარკვეულწილად counterintuitively-- 0. 0 ზოგადად ნიშნავს, ყველა კარგად არის. მიუხედავად იმისა, რომ თქვენ ფიქრობთ მას, როგორც ცრუ ბევრ კონტექსტში, ეს, ფაქტობრივად, ზოგადად ნიშნავს, კარგია 

ამასობაში, თუ პროგრამა დააბრუნებს 1, ან უარყოფით 1 ან 5, ან უარყოფით 42, ან ნებისმიერი არასამთავრობო 0 ღირებულება, რომ, ზოგადად, ნიშნავს, რომ რაღაც წავიდა არასწორია. ფაქტობრივად, საკუთარი Mac ან PC, თქვენ ალბათ რეალურად ჩანს შეცდომა, რომლის დროსაც იგი ამბობს, რომ რაღაც ან სხვა, შეცდომა კოდი უარყოფითი 42, ან შეცდომის კოდი 23, ან რამე მაგდაგვარს. ეს რიცხვი არის ზოგადად მხოლოდ მინიშნება პროგრამისტი, ან კომპანია რომ გააკეთა პროგრამული უზრუნველყოფა, რა გაფუჭდა და რატომ, ასე რომ შეიძლება გაეცნონ მათი დოკუმენტაცია ან კოდი, და გაერკვნენ, თუ რა შეცდომა ფაქტიურად ნიშნავს. ეს საერთოდ არ არის სასარგებლო ჩვენთვის ბოლოში მომხმარებლებს. 

მაგრამ როდესაც ძირითადი ანაზღაურება 0, ყველაფერი კარგად იქნება. და თუ არ არის მითითებული რა ძირითად უნდა დაბრუნდეს, იგი მხოლოდ ავტომატურად დაბრუნებას 0 თქვენთვის. მაგრამ დაბრუნების რაღაც სხვა ფაქტობრივად სასარგებლო. 

ამ საბოლოო პროგრამის ნება მიბოძეთ, წავიდეთ წინ და მოვუწოდებთ ამ exit.c, და დანერგვა ბოლო დღეს თემა, რომელიც ცნობილია როგორც შეცდომის კოდი. ნება მომეცით წავიდეთ წინ და მოიცავს ჩვენი ნაცნობი ფაილები დაბრუნება, int ძირითადი. და ამ დროს, მოდით int argc, სიმებიანი argv, და ჩემი ფრჩხილები ნიშნავს იმას, რომ ეს მასივი. და მაშინ ნება მომეცით უბრალოდ საღი აზრის ქვითარი. ამ დროს, თუ argc არ თანაბარი 2, მაშინ თქვენ იცით რა? დაივიწყე. მე ვაპირებ ვთქვა, რომ, hey, შესახებ, თქვენ დაკარგული ბრძანების არგუმენტი წარმატებული ო. 

და მაშინ, რომ ეს არის ის. მინდა გასვლა. ვაპირებ წინასწარ, და ნაადრევად ნამდვილად, დაბრუნების რაღაც სხვა, ვიდრე ნომერი 1. გადასვლა ღირებულების პირველად შეცდომა, რომ შეიძლება მოხდეს არის 1. თუ თქვენ გაქვთ რაიმე სხვა მცდარი სიტუაცია, რომელიც შეიძლება მოხდეს, შეიძლება ითქვას, რომ დაბრუნების 2 ან დაბრუნდნენ 3, ან შესაძლოა, უარყოფითი 1 ან -2. 

ეს არის მხოლოდ გასასვლელი კოდები რომ, ზოგადად, მხოლოდ სასარგებლო პროგრამისტი, ან კომპანია, რომელიც გადაზიდვა პროგრამული უზრუნველყოფა. მაგრამ ის ფაქტი, რომ არ არის 0, რაც მნიშვნელოვანია. ასე რომ, თუ ამ პროგრამას, მინდა გარანტი, რომ ეს პროგრამა მხოლოდ მუშაობს თუ მომხმარებელს უზრუნველყოფს ჩემთვის არგუმენტი რაოდენობა ორი, სახელი პროგრამა, და სხვა მოკლედ, შეუძლია აღასრულოს, როგორც შემდეგნაირად, დაწეროთ მომხმარებელი printf გამონათქვამი, დაკარგული ბრძანების არგუმენტი, დაბრუნდება 1. რომელიც მხოლოდ დაუყოვნებლივ დატოვა პროგრამა. 

იმ შემთხვევაში, თუ argc უდრის 2 მივიღებთ ქვემოთ აქ, სადაც წერტილი მე ვაპირებ ვთქვა, მიესალმები პროცენტს s, წარმატებული ო, argv1. სხვა სიტყვებით, მე არ ვაპირებთ შემდეგ argv 0, რაც არის პროგრამის სახელი. მინდა ამობეჭდოთ მძიმით, მეორე სიტყვა, რომელიც ადამიანის აკრეფილი. და ამ შემთხვევაში, line 13, ყველაფერი კარგად იქნება. 

მე ვიცი, რომ argc არის 2 ლოგიკურად ამ პროგრამის. მე ვაპირებ წავიდეთ წინ და უკან დაბრუნებას 0. როგორც განზე, გვახსოვდეს, რომ ეს არის ნამდვილი Scratch ისევე. 

ლოგიკურად, მე ვერ გავაკეთებ ამ და encapsulate ამ ხაზების კოდი ამ სხვა პუნქტი აქ. მაგრამ ეს ერთგვარი ზედმეტად წაწევის ჩემი კოდი. და მე მინდა, რომ სუპერ ნათელია, რომ რაც არ უნდა, ძირითადად, hello რაღაც დაბეჭდილი ასე რომ, სანამ შესახებ თანამშრომლობს. 

ასე რომ, ეს არის ძალიან გავრცელებული გამოყენება მდგომარეობა, მხოლოდ იმ შემთხვევაში, თუ დაჭერა ზოგიერთი მცდარი სიტუაცია, და შემდეგ გასვლა. და შემდეგ, ცოტა ხნის ყველა არის კარგად, არა აქვს სხვა, მაგრამ უბრალოდ კოდი გარეთ, რომ იმ შემთხვევაში, თუ იმიტომ, რომ ეს ექვივალენტი ამ კონკრეტულ შემთხვევაში, ლოგიკურად. ასე რომ, მე დაბრუნების 0, უბრალოდ მკაფიოდ ნიშნავდეს ყველა კარგად არის. 

თუ მე გამოტოვებული დაბრუნების 0, ეს იქნებოდა ავტომატურად აიღო ჩემთვის. მაგრამ ახლა, რომ მე ვბრუნდები ერთი მინიმუმ ამ შემთხვევაში, მე ვაპირებ, კარგი ღონისძიება და სიწმინდე, დაბრუნდნენ 0 ამ შემთხვევაში. ახლა ნება მომეცით წავიდეთ წინ და გასასვლელი, რომელიც არის სრულყოფილი segue უბრალოდ დატოვონ. 

მაგრამ, რათა გასასვლელი, და ნება მომეცით წავიდეთ წინ და ამის ./exit, შეიტანეთ. და პროგრამა დაიყვირა ჩემთვის, დაკარგული ბრძანების არგუმენტი. OK, ნება მომეცით ითანამშრომლოს. 

ნება მომეცით ნაცვლად ამის ./exit, დავით, შეიტანეთ. და ახლა იგი აცხადებს, hello დავით. და თქვენ არ ჩვეულებრივ ეს. 

მაგრამ აღმოჩნდება, რომ არსებობს სპეციალური გზა Linux რეალურად ვხედავ ის, რასაც გასასვლელი კოდი პროგრამა დასრულდა. ზოგჯერ გრაფიკული მსოფლიოში, როგორც Mac OS და Windows, თქვენ მხოლოდ ამ ნომრებზე, როდესაც შეცდომა pops up ეკრანზე და პროგრამისტი აჩვენებს, რომ ნომერი. მაგრამ თუ ჩვენ გვინდა, რომ რა შეცდომა გზავნილი არის, ჩვენ შეგვიძლია ამის გაკეთება აქ ასე ./exit, შეიყვანეთ ბეჭდვითი დაკარგული ბრძანების არგუმენტი. 

თუ მე ახლა echo $ ?, რომელიც ridiculously cryptic ეძებს. მაგრამ $? არის ჯადოსნური incantation რომელიც ამბობს, hey, კომპიუტერი, მითხარით, რა წინა პროგრამის გამშვები კოდი იყო. მე და დააჭიროთ. მე ვხედავ 1, იმიტომ, რომ ის, რაც მე ვუთხარი ჩემი მთავარი ფუნქცია დაბრუნებას. 

ამასობაში, თუ ამის ./exit დავით, და Enter, მე ვხედავ, hello დავით. და თუ ახლა echo $ ?, მე ვხედავთ მიესალმები 0. ასე რომ, ეს, ფაქტობრივად, იყოს ღირებული ინფორმაცია კონტექსტში debugger, ასე არ არის ბევრი, რომ თქვენ, ადამიანური, იზრუნებს. მაგრამ debugger და სხვა პროგრამების ჩვენ ვიყენებთ ამ სემესტრში ხშირად შევხედოთ, რომ ნომერი, მიუხედავად იმისა, რომ ეს ერთგვარი გადამალული მოშორებით თუ თქვენ ვეძებთ, რათა განსაზღვრავს თუ არა პროგრამის აღსრულების იყო სწორი ან არასწორი. 

და ისე, რომ მოაქვს ეს, ერთი დღის ბოლოს. ჩვენ დღეს დაიწყო ეძებს გამართვის, და თავის მხრივ, რა თქმა უნდა თავად, და მაშინ უფრო საინტერესოა, ტექნიკურად ქვეშ hood რა სტრიქონები, რომელიც გაგრძელდება კვირას ჩვენ უბრალოდ აიღო მიანიჭა, და რა თქმა უნდა წაიყვანეს გაიცემა Scratch. 

ჩვენ მაშინ შევხედე, თუ როგორ ჩვენ შეუძლია ინდივიდუალური სიმბოლოების სიმებიანი, და მერე კიდევ ერთხელ აიღო უფრო მაღალ დონეზე შევხედოთ რამ, შევხედავთ, როგორ well-- თუ ჩვენ გვინდა, რომ ინდივიდუალური ელემენტების სია მსგავსი სტრუქტურა, არ შეგვიძლია გავაკეთოთ, რომ მრავალჯერადი სიმებიანი? და ჩვენ შეგვიძლია ბრძანების ხაზი არგუმენტები. მაგრამ ამ სურათს აქ მხოლოდ ყუთები არის საჩვენებელი ამ ზოგადი იდეა მასივი, ან ჩამონათვალი, ან ვექტორი. და დამოკიდებულია კონტექსტში, ყველა ეს სიტყვა ნიშნავს ოდნავ განსხვავებული რამ. ასე რომ, C, ჩვენ მხოლოდ აპირებს ვისაუბროთ მასივი. ხოლო მასივი ბლოკი მეხსიერების, თითოეული მათგანი არის ელემენტები მომიჯნავე, უკან, უკან, უკან, უკან. 

და იმ ელემენტების, ზოგადად, იგივე მონაცემები ტიპის, ხასიათი, ხასიათი, ხასიათი, ხასიათი, ან სიმებიანი, სიმებიანი, სიმებიანი, სიმებიანი, ან int, int, int, რაც არ არის ჩვენ ვცდილობთ, რომ მაღაზიაში. თუმცა, დღის ბოლოს, ეს არის რას ჰგავს კონცეპტუალურად. თქვენ მიღების თქვენი კომპიუტერის მეხსიერების ან RAM. და თქვენ კვეთის ის შევიდა იდენტურად ზომის ყუთები, რაც უკან, უკან, რომ უკან, რომლითაც ამ გზით. 

და რა ლამაზი ამ იდეას, და ის ფაქტი, რომ ჩვენ შეგვიძლია გამოვხატოთ ღირებულებების ამ გზით პირველი ჩვენი მონაცემთა სტრუქტურები კლასი, იმას ნიშნავს, რომ ჩვენ შეგვიძლია დავიწყოთ პრობლემების მოსაგვარებლად კოდით რომ მოვიდა ინტუიციურად კვირაში 0. თქვენ გახსოვთ, ტელეფონით წიგნი მაგალითად, სადაც ჩვენ გამოყენებული გათიშე და იბატონეს ან ბინარული ძებნის ალგორითმი, Sift მეშვეობით მთელი bunch of სახელები და ნომრები. მაგრამ ჩვენ ვვარაუდობდით, გავიხსენოთ, რომ ეს სატელეფონო წიგნი უკვე დახარისხებული, რომ ვინმეს უკვე figured out-- მოცემულ სიაში სახელები და ნომრებზე როგორ alphabetize მათ. და ახლა, რომ C ჩვენ, ძალიან, აქვს უნარი ჩაუყარა ნივთების, არ ფიზიკური სატელეფონო წიგნი მაგრამ პრაქტიკულად კომპიუტერის მეხსიერება, ჩვენ შევძლებთ მომავალ კვირას დანერგვა კიდევ ერთხელ ამას პირველი ჩვენი მონაცემები სტრუქტურების მასივი მაგრამ რაც მთავარია, ფაქტობრივი კომპიუტერი მეცნიერება ალგორითმები განხორციელდა კოდი, რომლითაც ჩვენ შეგვიძლია შესანახად მონაცემების სტრუქტურები, როგორც ეს, და შემდეგ დაიწყება მართვას, და რეალურად მოგვარებას პრობლემები, და ავაშენოთ თავზე რომ, საბოლოო ჯამში, პროგრამების C, in Python, JavaScript, querying მონაცემთა ბაზის SQL? 

და ჩვენ დავინახავთ, რომ ყველა ეს სხვადასხვა იდეები ერთმანეთს. მაგრამ ახლა, გავიხსენოთ, რომ დომენი, რომ ჩვენ გააცნო დღეს იყო, ეს ისაა, და სამყაროში კრიპტოგრაფიის. და მათ შორის შემდეგი პრობლემები თქვენ თავს რომელიც გადაწყვეტს ხელოვნების კრიპტოგრაფიის, scrambling და დე-scrambling ინფორმაცია და დაშიფრვის და გაშიფვრის ტექსტი, და ვთქვათ, საბოლოო ჯამში, რომ თქვენ ახლა ვიცი, რა არის ქვეშ hood ასე რომ, როდესაც თქვენ ხედავთ ან მიიღოს გაგზავნა მოსწონს ეს, თქვენ თავს ვერ decipher იგი. ყველა ამ და სხვა დროს. 

[ვიდეო აღწარმოების] 

-Mover მხოლოდ ჩამოვიდა. მე ვაპირებ წასვლა ვიზიტი მისი კოლეჯის პროფესორი. Yep. Hi. ეს შენ ხარ. დაელოდეთ! დავით. მე უბრალოდ ცდილობენ გაერკვნენ გაირკვეს, თუ რა მოხდა თქვენ. გთხოვთ, არაფერი დაეხმარება. თქვენ იყავით მისი კოლეჯის roommate, იყო არა? თქვენ იქ მასთან ერთად, დაამთავრა CS50 პროექტი? 

[მუსიკის დაკვრა] 

-ეს იყო CS50. 

მე მიყვარს ეს ადგილი. 

-ჭამა. ჩვენ ვაპირებთ, ბიზნესი. 

[END აღწარმოების] 