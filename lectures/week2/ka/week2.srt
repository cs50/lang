1
00:00:00,000 --> 00:00:02,970
>> [მუსიკის დაკვრა]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> დევიდ ჯ Malan ყველა უფლება.

4
00:00:15,700 --> 00:00:18,832
ეს არის CS50 და ეს
არის დაწყების კვირა 2.

5
00:00:18,832 --> 00:00:21,040
და თქვენ გავიხსენოთ, რომ მეტი
ბოლო რამდენიმე კვირის განმავლობაში,

6
00:00:21,040 --> 00:00:24,490
ჩვენ უკვე შემოღების კომპიუტერული
მეცნიერებისა და, თავის მხრივ, პროგრამირების.

7
00:00:24,490 --> 00:00:27,640
>> და დავიწყეთ ამბავი გზით
Scratch, რომ გრაფიკული ენის

8
00:00:27,640 --> 00:00:28,990
საწყისი MIT- ის მედია ლაბორატორია.

9
00:00:28,990 --> 00:00:30,780
და შემდეგ ყველაზე ცოტა ხნის წინ,
გასულ კვირას, არც ჩვენ

10
00:00:30,780 --> 00:00:34,450
დანერგვა higher--
ქვედა დონის ენა ცნობილია

11
00:00:34,450 --> 00:00:36,770
როგორც C, რაღაც რომ წმინდა ტექსტური.

12
00:00:36,770 --> 00:00:39,440
და, მართლაც, ბოლო დროს ჩვენ
შესწავლილი ფარგლებში კონტექსტში

13
00:00:39,440 --> 00:00:40,450
რიგი ცნებები.

14
00:00:40,450 --> 00:00:43,010
>> ეს, გავიხსენოთ, იყო ძალიან
პირველი პროგრამა ჩვენ შევხედე.

15
00:00:43,010 --> 00:00:45,710
ეს პროგრამა, უბრალოდ,
ბეჭდავს out, "hello, world".

16
00:00:45,710 --> 00:00:47,730
მაგრამ იქ იმდენად
მოჩვენებითი ჯადოსნური მიმდინარეობს.

17
00:00:47,730 --> 00:00:51,460
არსებობს ამ # მოიცავს
ამ კუთხე ფრჩხილებში.

18
00:00:51,460 --> 00:00:52,170
არსებობს int.

19
00:00:52,170 --> 00:00:53,020
არსებობს (void).

20
00:00:53,020 --> 00:00:56,330
არსებობს ფრჩხილებში, Curly braces,
ნახევრად colons, და ასე უფრო მეტი.

21
00:00:56,330 --> 00:00:58,480
>> ასე რომ, გავიხსენოთ, რომ
ჩვენ გააცნო Scratch

22
00:00:58,480 --> 00:01:02,110
ასე, რომ ჩვენ შეგვიძლია, იდეალურად, ვხედავ წარსულში
რომ სინტაქსი, პერსონალის, რომ ნამდვილად არ არის

23
00:01:02,110 --> 00:01:04,590
ყველა, რომ ინტელექტუალურად
საინტერესო, მაგრამ დასაწყისში

24
00:01:04,590 --> 00:01:07,700
არის, რა თქმა უნდა, ცოტა სახიფათო
გადაიტანოთ თქვენი აზრით გარშემო.

25
00:01:07,700 --> 00:01:10,860
და, მართლაც, ერთ-ერთი ყველაზე გავრცელებული
რამ ადრეულ პროგრამირების კლასი,

26
00:01:10,860 --> 00:01:13,443
განსაკუთრებით მათთვის, ნაკლებად
კომფორტული, არის ის, რომ იმედგაცრუებულია

27
00:01:13,443 --> 00:01:17,460
და იმყოფებოდა up გარკვეული სინტაქსური
შეცდომები, რომ აღარაფერი ვთქვათ ლოგიკური შეცდომები.

28
00:01:17,460 --> 00:01:19,800
ასე რომ, მათ შორის ჩვენი მიზნები
დღეს, ფაქტობრივად, ნება

29
00:01:19,800 --> 00:01:23,280
უნდა აღჭურვა თქვენ გარკვეული
პრობლემის გადაჭრაზე ტექნიკის როგორ

30
00:01:23,280 --> 00:01:26,705
უკეთ პრობლემების მოგვარებას თავად
სახით debugging.

31
00:01:26,705 --> 00:01:29,330
და თქვენ გავიხსენოთ, ძალიან, რომ
გარემო, რომელიც ჩვენ გააცნო

32
00:01:29,330 --> 00:01:31,780
ბოლო დროს ეწოდა CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
ეს არის ვებ დაფუძნებული პროგრამული უზრუნველყოფა, რომელიც
გაძლევთ საშუალებას პროგრამის ღრუბელი,

34
00:01:34,850 --> 00:01:38,450
ასე ვთქვათ, ხოლო შენახვა ყველა თქვენი
ფაილი ერთად, როგორც ჩვენ კვლავ დღეს.

35
00:01:38,450 --> 00:01:41,480
და გავიხსენოთ, რომ ჩვენ
revisited ეს თემა აქ,

36
00:01:41,480 --> 00:01:44,480
მათ შორის ფუნქციები და მარყუჟების, და
ცვლადები და ლოგიკური გამონათქვამები,

37
00:01:44,480 --> 00:01:45,110
და პირობებს.

38
00:01:45,110 --> 00:01:49,190
და რეალურად კიდევ რამდენიმე, რომ ჩვენ
თარგმნა მსოფლიოს Scratch

39
00:01:49,190 --> 00:01:50,800
სამყაროში C.

40
00:01:50,800 --> 00:01:53,220
>> მაგრამ ფუნდამენტური შენობა
კორპუსები, ასე ვთქვათ,

41
00:01:53,220 --> 00:01:55,150
იყო ნამდვილად იგივეა გასულ კვირას.

42
00:01:55,150 --> 00:01:57,900
ფაქტობრივად, ჩვენ ნამდვილად ჰქონდა
სხვადასხვა თავსატეხი ცალი, თუ გნებავთ.

43
00:01:57,900 --> 00:02:00,300
იმის ნაცვლად, რომ purple
გადარჩენა ბლოკი, ჩვენ ნაცვლად

44
00:02:00,300 --> 00:02:02,940
ჰქონდა printf, რომელიც
ამ ფუნქციის C, რომ

45
00:02:02,940 --> 00:02:05,890
საშუალებას გაძლევთ ამობეჭდოთ რაღაც
და დააფორმატე ეკრანზე.

46
00:02:05,890 --> 00:02:07,950
ჩვენ გააცნო CS50
ბიბლიოთეკა, სადაც თქვენ

47
00:02:07,950 --> 00:02:11,420
აქვს ახლა თქვენს განკარგულებაშია get_char,
და get_int და get_string,

48
00:02:11,420 --> 00:02:14,610
და რამდენიმე სხვა ფუნქციებს,
ასევე, რომლის მეშვეობით თქვენ შეგიძლიათ მიიღოთ input

49
00:02:14,610 --> 00:02:16,260
მომხმარებელი საკუთარი კლავიატურაზე.

50
00:02:16,260 --> 00:02:20,640
და ჩვენ ასევე მიიღო შევხედოთ რამ
როგორიცაა these- bool, და char,

51
00:02:20,640 --> 00:02:22,490
და ორმაგი, float,
int, long_long სიმებიანი.

52
00:02:22,490 --> 00:02:25,170
და იქ კი სხვა მონაცემები სახის C.

53
00:02:25,170 --> 00:02:28,560
>> სხვა სიტყვებით, როდესაც თქვენ გამოაცხადოს
ცვლადი შესანახად გარკვეული მნიშვნელობა,

54
00:02:28,560 --> 00:02:32,600
ან როდესაც თქვენ განახორციელოს ფუნქცია
რომ ბრუნდება გარკვეული მნიშვნელობა,

55
00:02:32,600 --> 00:02:35,290
თქვენ შეგიძლიათ მიუთითოთ რა
ტიპის ღირებულება, რომელიც არის.

56
00:02:35,290 --> 00:02:37,310
ეს არის ტექსტი, როგორიც
თანმიმდევრობა გმირები?

57
00:02:37,310 --> 00:02:39,490
ეს არის ნომერი, როგორც რიცხვი?

58
00:02:39,490 --> 00:02:41,390
ეს არის მცურავი წერტილი
ღირებულება, ან მოსწონს?

59
00:02:41,390 --> 00:02:46,180
ასე რომ, C, განსხვავებით Scratch, ჩვენ რეალურად
დაიწყო აკონკრეტებს, თუ რა სახის მონაცემები

60
00:02:46,180 --> 00:02:48,330
ვბრუნდებოდით ან გამოყენებით.

61
00:02:48,330 --> 00:02:51,910
>> მაგრამ, რა თქმა უნდა, ჩვენ ასევე შეუვარდნენ
ზოგიერთი ფუნდამენტური ლიმიტები computing.

62
00:02:51,910 --> 00:02:54,100
კერძოდ,
ეს ენა C, გავიხსენოთ

63
00:02:54,100 --> 00:02:57,070
რომ ავიღეთ შევხედოთ
რიცხვი overflow, რეალობა

64
00:02:57,070 --> 00:03:00,460
იმ შემთხვევაში, თუ თქვენ მხოლოდ
სასრული რაოდენობით მეხსიერება

65
00:03:00,460 --> 00:03:04,600
და, კერძოდ, სასრული რაოდენობის
ბიტი, თქვენ მხოლოდ ითვლიან იმდენად მაღალი.

66
00:03:04,600 --> 00:03:08,460
ასე რომ, ჩვენ შევხედე ამ მაგალითს აქ
რომლის დროსაც counter თვითმფრინავის,

67
00:03:08,460 --> 00:03:13,510
რეალურად, თუ გაშვებული ხანგრძლივი საკმარისი იქნებოდა
overflow და გამოიწვიოს პროგრამული უზრუნველყოფა

68
00:03:13,510 --> 00:03:15,560
ფაქტობრივი ფიზიკური პოტენციური შეცდომა.

69
00:03:15,560 --> 00:03:18,600
>> ჩვენ ასევე შევხედე მცურავი
პუნქტიანი ორაზროვნება, რეალობა

70
00:03:18,600 --> 00:03:22,280
რომ მხოლოდ სასრული რაოდენობის
ბიტი, თუ არა ის 32 ან 64,

71
00:03:22,280 --> 00:03:27,330
თქვენ შეგიძლიათ მიუთითოთ მხოლოდ ამდენი ნომრები
მას შემდეგ, რაც ათობითი წერტილი, რის შემდეგაც თქვენ

72
00:03:27,330 --> 00:03:29,110
დაიწყოს მიიღოს ბუნდოვანი.

73
00:03:29,110 --> 00:03:32,360
ასე მაგალითად, ერთ-ერთი მესამედით
მსოფლიოში აქ, ჩვენს ადამიანთა სამყაროში,

74
00:03:32,360 --> 00:03:35,360
ჩვენ ვიცით არის მხოლოდ უსასრულო რაოდენობის
of 3s შემდეგ ათობითი წერტილი.

75
00:03:35,360 --> 00:03:38,820
მაგრამ კომპიუტერის ვერ აუცილებლად
წარმოადგენს უსასრულო რაოდენობის ნომრები

76
00:03:38,820 --> 00:03:42,590
თუ თქვენ მხოლოდ დაუშვებს, რომ ზოგიერთი
სასრული რაოდენობით ინფორმაცია.

77
00:03:42,590 --> 00:03:45,900
>> ასე რომ, არა მხოლოდ ჩვენ აღჭურვა თქვენ
ერთად უფრო დიდი ძალა თვალსაზრისით

78
00:03:45,900 --> 00:03:49,280
თუ როგორ შეიძლება გამოხატოს საკუთარ თავს
კლავიატურის თვალსაზრისით პროგრამირების,

79
00:03:49,280 --> 00:03:51,430
ჩვენ ასევე შეზღუდული რა
თქვენ შეგიძლიათ რეალურად გავაკეთოთ.

80
00:03:51,430 --> 00:03:55,790
და მართლაც, შეცდომები და შეცდომები
წარმოიქმნება იმ სახის საკითხები.

81
00:03:55,790 --> 00:03:59,900
და მართლაც, მათ შორის თემა დღეს
ვაპირებთ, რომ თემები, როგორიცაა გამართვის

82
00:03:59,900 --> 00:04:03,699
და რეალურად ეძებს ქვეშ hood
თუ როგორ რამ გაეცნენ გასულ კვირას

83
00:04:03,699 --> 00:04:05,490
ფაქტობრივად განხორციელებული
ასე, რომ თქვენ უკეთესი

84
00:04:05,490 --> 00:04:10,530
გავიგოთ, როგორც შესაძლებლობების და
შეზღუდვები ენის მსგავსად, C.

85
00:04:10,530 --> 00:04:14,770
>> და სინამდვილეში, ჩვენ კანი უკან ფენების
უმარტივესი მონაცემები სტრუქტურის,

86
00:04:14,770 --> 00:04:17,756
რაღაც მოუწოდა მასივი, რომელიც
Scratch ხდება მოვუწოდებთ "სიაში."

87
00:04:17,756 --> 00:04:19,589
ეს ცოტა
სხვადასხვა კონტექსტში.

88
00:04:19,589 --> 00:04:23,340
და მაშინ ჩვენ ასევე წარმოგიდგინოთ ერთ-ერთი
პირველი ჩვენი დომენური სპეციფიკური პრობლემები

89
00:04:23,340 --> 00:04:26,790
CS50, მსოფლიოს
კრიპტოგრაფიის, ხელოვნების scrambling

90
00:04:26,790 --> 00:04:29,650
ან დაშიფრვის ინფორმაცია ისე,
რომ თქვენ შეგიძლიათ გააგზავნოთ საიდუმლო შეტყობინებები

91
00:04:29,650 --> 00:04:34,520
და decode საიდუმლო შეტყობინებები
ორ ადამიანს შორის, A და B.

92
00:04:34,520 --> 00:04:37,490
>> ასე რომ სანამ ჩვენ გარდამავალი
რომ ახალ სამყაროში,

93
00:04:37,490 --> 00:04:42,059
მოდით მივცეთ თქვენ გარკვეული
ტექნიკას, რომელთანაც შეგიძლიათ აღმოფხვრა

94
00:04:42,059 --> 00:04:43,850
ან შემცირება მინიმუმ რამდენიმე
იმედგაცრუებები

95
00:04:43,850 --> 00:04:46,630
რომ თქვენ ალბათ გვხვდება
გასული კვირის განმავლობაში მარტო.

96
00:04:46,630 --> 00:04:50,830
ფაქტობრივად, წინ თქვენ such-- ზოგიერთი
თქვენი პირველი პრობლემა C. და შანსები,

97
00:04:50,830 --> 00:04:54,010
თუ თქვენ, როგორც მე, პირველად
ცდილობენ ტიპი out პროგრამა,

98
00:04:54,010 --> 00:04:57,330
მაშინაც კი, თუ ვფიქრობ ლოგიკურად
პროგრამა არის საკმაოდ მარტივი,

99
00:04:57,330 --> 00:05:01,200
თქვენ შეიძლება ძალიან კარგად მოხვდა კედლის და
შემდგენელი თანამშრომლობას არ აპირებს.

100
00:05:01,200 --> 00:05:03,940
ან Clang არ აპირებს
რეალურად თქვენი ტენდერების.

101
00:05:03,940 --> 00:05:05,450
>> და რატომ შეიძლება რომ იყოს?

102
00:05:05,450 --> 00:05:07,950
ისე, მოდით შევხედოთ,
ალბათ, მარტივი პროგრამა.

103
00:05:07,950 --> 00:05:11,190
მე ვაპირებ წავიდეთ წინ და გადარჩენა ეს
ფაილი შეგნებულად მოუწოდა buggy0.c,

104
00:05:11,190 --> 00:05:13,590
რადგან ვიცი, რომ ეს
ყალბი წინასწარ.

105
00:05:13,590 --> 00:05:17,400
მაგრამ მე შეიძლება არ ესმოდეს, რომ თუ ეს
პირველი ან მეორე ან მესამე პროგრამა

106
00:05:17,400 --> 00:05:18,830
რომ მე რეალურად მიღების თავს.

107
00:05:18,830 --> 00:05:23,820
ამიტომ, მე ვაპირებ წავიდეთ წინ და
აკრიფოთ გარეთ, int ძირითადი (void).

108
00:05:23,820 --> 00:05:28,130
და შემდეგ შიგნით ჩემი Curly braces,
ძალიან ნაცნობი ( "hello, world

109
00:05:28,130 --> 00:05:30,980
წარმატებული, n ") - და ნახევრად მსხვილი ნაწლავის.

110
00:05:30,980 --> 00:05:32,360
>> მე შენახული ფაილი.

111
00:05:32,360 --> 00:05:34,850
ახლა მე ვაპირებ დაცემას
ჩემი ტერმინალის ფანჯარაში

112
00:05:34,850 --> 00:05:40,340
და ტიპის მიიღოს buggy0, რადგან, კიდევ ერთხელ,
სახელი ფაილი დღეს buggy0.c.

113
00:05:40,340 --> 00:05:43,660
ასე რომ, მე აკრიფოთ მიიღოს buggy0, შეიტანეთ.

114
00:05:43,660 --> 00:05:48,200
>> და, რა, gosh, გავიხსენოთ ბოლო დროს
რომ არ შეცდომის შეტყობინებები არ არის კარგია.

115
00:05:48,200 --> 00:05:49,740
ასე რომ, არ გამომავალი კარგია.

116
00:05:49,740 --> 00:05:52,920
მაგრამ აქ მე ნათლად
გარკვეული რაოდენობის შეცდომები.

117
00:05:52,920 --> 00:05:56,470
>> ასე რომ, პირველი ხაზი გამომავალი
მას შემდეგ, რაც აკრეფით მიიღოს buggy0, გავიხსენოთ,

118
00:05:56,470 --> 00:05:59,540
არის Clang ის საკმაოდ verbose გამომავალი.

119
00:05:59,540 --> 00:06:02,067
ქვეშ Hood,
CS50 IDE არის კონფიგურირებული

120
00:06:02,067 --> 00:06:04,150
გამოიყენოს მთელი bunch
პარამეტრები ამ შემდგენელი

121
00:06:04,150 --> 00:06:05,941
ასე რომ თქვენ არ აქვს
ვფიქრობ, რომ მათ შესახებ.

122
00:06:05,941 --> 00:06:08,840
და ეს ყველაფერი, რომ პირველი ხაზი
საშუალება, რომელიც იწყება Clang.

123
00:06:08,840 --> 00:06:11,720
>> მაგრამ ამის შემდეგ, პრობლემები,
დაიწყოს, რათა მათი გამოჩენა.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c on line 3, ხასიათი
5, არ არის დიდი, წითელი შეცდომა.

125
00:06:17,390 --> 00:06:18,380
რა არის ეს?

126
00:06:18,380 --> 00:06:23,562
მინიშნებით გამოცხადების ბიბლიოთეკის ფუნქცია
printf ტიპის int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
ვგულისხმობ, ეს ძალიან სწრაფად
იღებს ძალიან arcane.

129
00:06:28,379 --> 00:06:30,170
და რა თქმა უნდა, პირველ რიგში,
ერთი შეხედვით, ჩვენ არ

130
00:06:30,170 --> 00:06:32,380
ველით, რომ თქვენ უნდა გვესმოდეს,
მთლიანად რომ გაგზავნა.

131
00:06:32,380 --> 00:06:34,213
ასე რომ, ერთი გაკვეთილები
დღეს აპირებს

132
00:06:34,213 --> 00:06:36,919
უნდა ვეცადოთ, რომ შეამჩნია
ნიმუშების, ან მსგავსი რამ,

133
00:06:36,919 --> 00:06:38,960
შეცდომები ალბათ
შეექმნა წარსულში.

134
00:06:38,960 --> 00:06:41,335
მოდით აჯავრებენ გარდა მხოლოდ
ეს სიტყვები, რომელიც ნაცნობი.

135
00:06:41,335 --> 00:06:44,290
დიდი, წითელი შეცდომა აშკარად
სიმბოლურია ის, რომ არასწორია.

136
00:06:44,290 --> 00:06:47,940
>> მინიშნებით გამოცხადების
ბიბლიოთეკის ფუნქცია printf.

137
00:06:47,940 --> 00:06:51,680
ასე რომ, თუ მე არ მესმის რა
მინიშნებით გამოცხადების ბიბლიოთეკის ფუნქცია

138
00:06:51,680 --> 00:06:54,900
საშუალებით, პრობლემა აუცილებლად
ეხება printf რატომღაც.

139
00:06:54,900 --> 00:06:59,130
და წყარო, რომ საკითხი
უნდა გააკეთოს გამოცხადების მას.

140
00:06:59,130 --> 00:07:02,440
>> გამოცხადების ფუნქცია
აღვნიშნო, რომ ეს პირველად.

141
00:07:02,440 --> 00:07:06,210
და ჩვენ გამოყენებული ტერმინოლოგიის გასულ კვირას
გამოცხადების ფუნქციის პროტოტიპი,

142
00:07:06,210 --> 00:07:11,860
არც ერთი ხაზი ზედა თქვენი
საკუთარი ფაილი ან ე.წ. header ფაილი.

143
00:07:11,860 --> 00:07:15,300
და რა ფაილი არ ვამბობთ,
გასულ კვირას, რომ printf არის ციტირებით

144
00:07:15,300 --> 00:07:17,080
unquote, გამოაცხადა?

145
00:07:17,080 --> 00:07:20,950
რა ფაილი არის მისი პროტოტიპი?

146
00:07:20,950 --> 00:07:24,640
>> ასე რომ, თუ გავიხსენებთ, პირველი, რაც მე
ტიპის, თითქმის ყველა პროგრამა ბოლო დროს

147
00:07:24,640 --> 00:07:30,790
და შემთხვევით მომენტში წინ დაიწყო
ბეჭდვის myself-- იყო ამ ერთი აქ

148
00:07:30,790 --> 00:07:38,630
hash-- # include <stio-- for
input / გამომავალი dot h მართლაც,

149
00:07:38,630 --> 00:07:41,860
თუ მე ახლა გადარჩენა ამ ფაილის, მე ვაპირებ
წავიდეთ წინ და გარკვევა ჩემი ეკრანზე,

150
00:07:41,860 --> 00:07:44,740
თქვენ შეგიძლიათ აკრეფით
წმინდა, და თქვენ შეგიძლიათ გამართავს კონტროლის L,

151
00:07:44,740 --> 00:07:47,680
უბრალოდ გარკვევა თქვენი ტერმინალის ფანჯარაში
მხოლოდ აღმოფხვრას რამდენიმე clutter.

152
00:07:47,680 --> 00:07:51,370
>> მე ვაპირებ წავიდეთ წინ და
აკრიფოთ make buggy0, შეიტანეთ.

153
00:07:51,370 --> 00:07:53,790
და voila, მე მაინც ვხედავ, რომ
ხანგრძლივი ბრძანება Clang,

154
00:07:53,790 --> 00:07:55,470
მაგრამ იქ არ არის შეცდომა ამ დროს.

155
00:07:55,470 --> 00:07:58,800
და მართლაც, თუ მე ./buggy0,
ისევე, როგორც ბოლო დროს,

156
00:07:58,800 --> 00:08:01,860
სადაც dot ნიშნავს ეს
კატალოგი, Slash მხოლოდ იმას ნიშნავს,

157
00:08:01,860 --> 00:08:05,040
აქ მოდის პროგრამის დასახელება და
ეს სახელი პროგრამა buggy0,

158
00:08:05,040 --> 00:08:07,340
შევა, "hello, world".

159
00:08:07,340 --> 00:08:09,440
>> ახლა, როგორ შეიძლება თქვენ გაქვთ
გამომდინარე ამ გადაწყვეტა

160
00:08:09,440 --> 00:08:12,017
აუცილებელი
აღიარებს, როგორც ბევრი სიტყვა

161
00:08:12,017 --> 00:08:14,350
როგორც მე, რა თქმა უნდა, რომელსაც
კეთდება ეს ამდენი წლის განმავლობაში?

162
00:08:14,350 --> 00:08:18,720
ისე, გააცნობიეროს თითო პირველი პრობლემა
კომპლექტი, ჩვენ წარმოგიდგინოთ ბრძანება

163
00:08:18,720 --> 00:08:21,175
რომ CS50 საკუთარი თანამშრომლები
წერდა მოუწოდა help50.

164
00:08:21,175 --> 00:08:24,300
და მართლაც, C აკეთებს დაზუსტება
პრობლემა შეიქმნა, თუ როგორ უნდა გამოიყენოთ ეს.

165
00:08:24,300 --> 00:08:27,210
>> მაგრამ help50 არსებითად
პროგრამა, რომელიც CS50 პერსონალი

166
00:08:27,210 --> 00:08:30,850
წერდა, რომ საშუალებას გაძლევთ აწარმოებს
ბრძანება ან გაუშვით პროგრამა,

167
00:08:30,850 --> 00:08:36,169
და თუ არ ესმის მისი
გამომავალი, უნდა გაიაროს მისი გამომავალი help50,

168
00:08:36,169 --> 00:08:38,890
ამ დროს პროგრამული
რომ რა თქმა უნდა პერსონალის დაწერა

169
00:08:38,890 --> 00:08:42,429
შეხედავს თქვენი პროგრამის გამომავალი
ხაზს, ხასიათი ხასიათი.

170
00:08:42,429 --> 00:08:46,000
და თუ ჩვენ, პერსონალი, აღიარებს
შეცდომა, რომ თქვენ განიცდის,

171
00:08:46,000 --> 00:08:50,580
ჩვენ შევეცდებით, რომ პროვოცირება თქვენ რამდენიმე
რიტორიკული კითხვები, რამდენიმე რჩევა,

172
00:08:50,580 --> 00:08:54,890
ჰგავს TF ან CA ან თავს
ყველაფერს გააკეთებს, პირის საათებში.

173
00:08:54,890 --> 00:08:58,320
>> ასე გამოიყურება help50 თუ არ
აუცილებლად აღიარებს პრობლემა.

174
00:08:58,320 --> 00:09:00,790
მაგრამ არ დაეყრდნონ ეს
ძალიან ბევრი, ყავარჯენი.

175
00:09:00,790 --> 00:09:03,990
უნდა ვეცადოთ, რომ მესმის მისი
გამომავალი და მაშინ ვისწავლოთ მისგან

176
00:09:03,990 --> 00:09:07,571
ისე, რომ მხოლოდ ერთხელ ან ორჯერ თქვენ
ოდესმე აწარმოებს help50 კონკრეტული შეცდომა

177
00:09:07,571 --> 00:09:08,070
გაგზავნა.

178
00:09:08,070 --> 00:09:10,660
ამის შემდეგ, თქვენ უნდა იყოს
უკეთესი აღჭურვილი თავს

179
00:09:10,660 --> 00:09:13,180
გაერკვნენ, რა ის რეალურად არის.

180
00:09:13,180 --> 00:09:14,350
>> მოდით გავაკეთოთ ერთი აქ.

181
00:09:14,350 --> 00:09:20,410
ნება მომეცით წავიდეთ წინ, და სხვა
ფაილი ჩვენ მოვუწოდებთ ამ buggy1.c.

182
00:09:20,410 --> 00:09:23,110
და ამ ფაილის ვარ
აპირებს deliberately--

183
00:09:23,110 --> 00:09:26,330
მაგრამ ვიტყვი, რომ მე არ
გაგება, თუ რა შეცდომა მე გააკეთა.

184
00:09:26,330 --> 00:09:31,420
>> მე ვაპირებ წავიდეთ წინ და ამის ამას
მოიცავს, მას შემდეგ, რაც მე

185
00:09:31,420 --> 00:09:33,660
გავიგე ჩემი გაკვეთილი მომენტში წინ.

186
00:09:33,660 --> 00:09:36,220
Int ძირითადი (void), როგორც ადრე.

187
00:09:36,220 --> 00:09:40,880
და მაშინ აქ მე ვაპირებ
უნდა გააკეთოს სიმებიანი s - get_string.

188
00:09:40,880 --> 00:09:43,770
და გავიხსენოთ, ბოლო დროს, რომ
ეს ნიშნავს, hey, კომპიუტერი,

189
00:09:43,770 --> 00:09:48,280
მომეცი ცვლადი, მას s, და
რათა ტიპის, რომ ცვლადის სიმებიანი

190
00:09:48,280 --> 00:09:50,150
ასე რომ შეგიძლიათ შეინახოთ ერთი ან მეტი სიტყვა იგი.

191
00:09:50,150 --> 00:09:52,191
>> და მერე მარჯვენა
მხარეს თანაბარი ნიშანი

192
00:09:52,191 --> 00:09:54,980
არის get_string, რომელიც არის
ფუნქცია CS50 ბიბლიოთეკა

193
00:09:54,980 --> 00:09:55,980
რომელიც აკეთებს ზუსტად რომ.

194
00:09:55,980 --> 00:09:59,740
იგი იღებს ფუნქცია და შემდეგ
ხელში მარჯვნიდან მარცხნივ.

195
00:09:59,740 --> 00:10:02,670
ასე რომ, ეს თანაბარი ნიშანი არ ნიშნავს იმას,
"ტოლია" რადგან ჩვენ შესაძლოა იფიქროს მათემატიკის.

196
00:10:02,670 --> 00:10:04,750
ეს იმას ნიშნავს, დავალება მარჯვნიდან მარცხნივ.

197
00:10:04,750 --> 00:10:09,640
ასე რომ, ეს იმას ნიშნავს, მიიღოს სიმებიანი ეხლა
შესახებ და ჩაწერს მას შიგნით s.

198
00:10:09,640 --> 00:10:10,460
>> ახლა მოდით გამოიყენოს იგი.

199
00:10:10,460 --> 00:10:13,820
ნება მომეცით წავიდეთ წინ არის და, როგორც მეორე
ხაზი, ნება მომეცით წავიდეთ წინ და ამბობენ, "გამარჯობა", -

200
00:10:13,820 --> 00:10:19,330
არა "მსოფლიო", მაგრამ "hello,% s--
რაც ჩვენი placeholder, მძიმით s,

201
00:10:19,330 --> 00:10:22,030
რაც ჩვენი ცვლადი,
და მერე ნახევრად მსხვილი ნაწლავის.

202
00:10:22,030 --> 00:10:26,070
ასე რომ, თუ მე არ ხრახნიანი ძალიან ბევრი
აქ, ამ ჰგავს სწორი კოდი.

203
00:10:26,070 --> 00:10:28,090
>> და ჩემი ინსტინქტები ახლა კომპილირება.

204
00:10:28,090 --> 00:10:30,400
ფაილი ეწოდება buggy1.c.

205
00:10:30,400 --> 00:10:33,770
ამიტომ, მე ვაპირებ, რომ გავაკეთოთ buggy1, შეიტანეთ.

206
00:10:33,770 --> 00:10:36,377
და darn ის, თუ არ არის
კიდევ უფრო შეცდომები, ვიდრე ადრე.

207
00:10:36,377 --> 00:10:38,210
ვგულისხმობ, იქ უფრო მეტი
შეცდომის შეტყობინებები, რომ ის

208
00:10:38,210 --> 00:10:40,400
როგორც ჩანს, ვიდრე ფაქტობრივი ხაზები ამ პროგრამაში.

209
00:10:40,400 --> 00:10:42,730
>> მაგრამ takeaway აქ არის,
მაშინაც კი, თუ თქვენ overwhelmed

210
00:10:42,730 --> 00:10:45,040
ორი ან სამი ან
კიდევ ოთხი შეცდომა შეტყობინებები

211
00:10:45,040 --> 00:10:48,340
ყურადღებას ყოველთვის ძალიან
პირველი იმ შეტყობინებები.

212
00:10:48,340 --> 00:10:52,220
ეძებს ყველაზე საუკეთესო ერთი,
სენსორული უკან, როგორც საჭირო იქნება.

213
00:10:52,220 --> 00:10:53,930
ასე რომ აქ მე აკრეფილი გააკეთოს buggy1.

214
00:10:53,930 --> 00:10:55,700
აი, რომ Clang გამომავალი როგორც მოსალოდნელი იყო.

215
00:10:55,700 --> 00:10:57,290
>> აქ არის პირველი წითელი შეცდომა.

216
00:10:57,290 --> 00:11:02,370
გამოყენება გამოუცხადებელ იდენტიფიკატორი
სიმებიანი, არ ვგულისხმობ სტანდარტი?

217
00:11:02,370 --> 00:11:04,260
ამიტომ სტანდარტის არის
რეალურად რაღაც.

218
00:11:04,260 --> 00:11:06,240
ეს ეხება მომხმარებლის
კლავიატურის, არსებითად.

219
00:11:06,240 --> 00:11:08,080
>> მაგრამ ეს არ არის ის, რაც მე ნიშნავდა.

220
00:11:08,080 --> 00:11:11,770
ვგულისხმობდი სიმებიანი და მე იმას ნიშნავდა, get_string.

221
00:11:11,770 --> 00:11:16,200
რა არის ის, რომ მე
დაავიწყდა ამის გაკეთება ამ დროს?

222
00:11:16,200 --> 00:11:20,230
რა აკლია ამ დროს?

223
00:11:20,230 --> 00:11:23,600
მე მაქვს ჩემი მოიცავს,
ასე რომ მე მაქვს წვდომა printf.

224
00:11:23,600 --> 00:11:26,090
>> მაგრამ რა არ აქვს
ხელმისაწვდომობის უბრალოდ არ არის?

225
00:11:26,090 --> 00:11:29,420
კარგად, ისევე, ბოლო დროს,
მე უნდა გითხრათ შემდგენელი

226
00:11:29,420 --> 00:11:31,691
Clang რა ამ ფუნქციების.

227
00:11:31,691 --> 00:11:33,940
Get_string არ მოდის
ერთად C. და კერძოდ,

228
00:11:33,940 --> 00:11:38,160
არ მოდის
header ფაილი,.

229
00:11:38,160 --> 00:11:40,770
ის ნაცვლად მოდის
რაღაც თანამშრომლებს წერდა,

230
00:11:40,770 --> 00:11:44,176
რომელიც სხვადასხვა ფაილი
სახელი, მაგრამ aptly დაასახელა.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> ასე რომ, უბრალოდ დასძინა, რომ ერთი ხაზი
of code-- გავიხსენოთ ბოლო დროს

233
00:11:50,861 --> 00:11:53,610
რომ როდესაც Clang გადის, ის აპირებს
შევხედოთ ჩემი კოდი ზემოდან,

234
00:11:53,610 --> 00:11:54,193
მარცხნიდან მარჯვნივ.

235
00:11:54,193 --> 00:11:57,200
ის აპირებს შეამჩნია,
oh, გსურთ.

236
00:11:57,200 --> 00:11:59,900
ნება მომეცით წავიდეთ და ნახავთ, რომ,
სადაც არ არის სერვერზე,

237
00:11:59,900 --> 00:12:03,090
დააკოპირეთ და ჩასვით იგი, არსებითად,
ზედა საკუთარი ფაილი

238
00:12:03,090 --> 00:12:06,820
ასე რომ, ამ ეტაპზე იმ ამბავს,
line 1, დანარჩენი პროგრამა

239
00:12:06,820 --> 00:12:11,651
შეიძლება, მართლაც, გამოიყენოთ რომელიმე ფუნქცია
მასში, მათ შორის get_string.

240
00:12:11,651 --> 00:12:13,650
ამიტომ, მე ვაპირებ იგნორირება
დანარჩენი იმ შეცდომებს,

241
00:12:13,650 --> 00:12:17,190
იმიტომ, რომ მე, რა თქმა უნდა, ეჭვი მაქვს, რომ მხოლოდ
პირველი რეალურად აქვს.

242
00:12:17,190 --> 00:12:20,780
და მე ვაპირებ წავიდეთ წინ და გამეორება,
შემდეგ გადარჩენა ჩემი ფაილი რათა buggy1.

243
00:12:20,780 --> 00:12:22,580
და voila, ის გავაკეთეთ მუშაობაში.

244
00:12:22,580 --> 00:12:29,200
და თუ მე ./buggy1 და აკრიფოთ,
მაგალითად, Zamyla, მე ახლა მიიღებს hello,

245
00:12:29,200 --> 00:12:32,000
Zamyla, ნაცვლად hello, world.

246
00:12:32,000 --> 00:12:32,550
>> კარგი.

247
00:12:32,550 --> 00:12:35,890
ასე რომ, takeaways მაშინ აქ უნდა,
ერთ-ერთი, ცდილობენ glean იმდენი, როგორც თქვენ შეგიძლიათ

248
00:12:35,890 --> 00:12:39,140
შეცდომა შეტყობინებები მარტო, ეძებს
ზოგიერთი ცნობადი სიტყვა.

249
00:12:39,140 --> 00:12:43,070
გამოვრიცხავთ, რომ, გამოიყენოთ help50 პოსტი
პრობლემა კომპლექტი სპეციფიკაცია.

250
00:12:43,070 --> 00:12:46,500
მაგრამ შეზღუდვის, რომ ძალიან, ყოველთვის გამოიყურება
ზედა შეცდომა მხოლოდ, მინიმუმ

251
00:12:46,500 --> 00:12:50,051
თავდაპირველად, რა ინფორმაცია
ეს შეიძლება რეალურად გამოიღო.

252
00:12:50,051 --> 00:12:52,300
მაგრამ ეს თურმე არსებობს
კიდევ უფრო ფუნქციონალური ჩაშენებული

253
00:12:52,300 --> 00:12:55,030
შევიდა CS50 ბიბლიოთეკა, რათა დაეხმაროს
თქვენ დასაწყისში სემესტრის

254
00:12:55,030 --> 00:12:57,580
და დილით პროგრამირების
გაერკვნენ, თუ რა ხდება, არასწორია.

255
00:12:57,580 --> 00:12:59,840
მოდით გავაკეთოთ კიდევ ერთი მაგალითია აქ.

256
00:12:59,840 --> 00:13:04,350
მე ვაპირებ მოვუწოდო ამ buggy2, რომელიც,
ერთხელ, იქნება გაყალბდა out

257
00:13:04,350 --> 00:13:05,650
კარიბჭე, დიზაინი.

258
00:13:05,650 --> 00:13:09,980
>> და მე ვაპირებ წავიდეთ წინ
და ნუ # მოიცავს.

259
00:13:09,980 --> 00:13:12,580
და შემდეგ მე ვაპირებ ამის გაკეთებას int ძირითადი (void).

260
00:13:12,580 --> 00:13:14,840
და შემდეგ მე ვაპირებ გავაკეთოთ ამისთვის loop.

261
00:13:14,840 --> 00:13:16,690
ამისთვის (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
მე ნაკლებია ან ტოლი 10.

263
00:13:18,750 --> 00:13:24,260
i ++, და შემდეგ Curly braces, მე ვაპირებ
ამობეჭდოთ მხოლოდ hashtag სიმბოლო აქ

264
00:13:24,260 --> 00:13:25,920
ახალი ხაზი ხასიათი.

265
00:13:25,920 --> 00:13:29,220
>> ასე რომ, ჩემი განზრახვა ამ
პროგრამა საკმაოდ უბრალოდ

266
00:13:29,220 --> 00:13:33,150
უნდა iterate 10 ჯერ
და თითოეულ iteration

267
00:13:33,150 --> 00:13:35,260
რომ ციკლი ყოველ ჯერზე
მეშვეობით ციკლი,

268
00:13:35,260 --> 00:13:37,660
ამობეჭდოთ hashtag,
hashtag, hashtag.

269
00:13:37,660 --> 00:13:40,480
ერთ ხაზზე იმიტომ, რომ მე
აქვს ახალი ხაზი არსებობს.

270
00:13:40,480 --> 00:13:42,787
და გავიხსენოთ, რომ ამისთვის
loop, თითო გასულ კვირას

271
00:13:42,787 --> 00:13:44,620
და თქვენ მიიღებთ უფრო მეტი
იცნობს სინტაქსი

272
00:13:44,620 --> 00:13:47,170
გამოყენებით იგი პრაქტიკაში
ადრე long-- ეს მაძლევს

273
00:13:47,170 --> 00:13:49,740
ცვლადში მე და ადგენს მას 0.

274
00:13:49,740 --> 00:13:52,650
>> ეს increments i on
ყოველ iteration 1.

275
00:13:52,650 --> 00:13:54,940
ასე რომ, მე ღებულობენ 1 2 3.

276
00:13:54,940 --> 00:13:57,690
და მაშინ ეს პირობა
შუა შორის ნახევრად colons

277
00:13:57,690 --> 00:14:03,010
იღებს შემოწმდება ყოველ iteration რათა
დარწმუნებული ვარ, რომ ჩვენ ჯერ კიდევ ფარგლებში დიაპაზონი.

278
00:14:03,010 --> 00:14:06,830
ასე რომ, მინდა iterate 10-ჯერ, ასე რომ მე
გვაქვს ერთგვარი ინტუიტიურად მხოლოდ

279
00:14:06,830 --> 00:14:09,070
ბოლო 10 როგორც ჩემი ზედა ზღვარი არ არსებობს.

280
00:14:09,070 --> 00:14:14,310
>> და მაინც, როდესაც მე აწარმოებს ამ, მას შემდეგ,
შედგენის იგი, რათა buggy2--

281
00:14:14,310 --> 00:14:15,440
და ეს არ კომპილირდება OK.

282
00:14:15,440 --> 00:14:17,980
ასე რომ, არ აქვს
სინტაქსური შეცდომა ამ დროს.

283
00:14:17,980 --> 00:14:20,940
ნება მომეცით წავიდეთ წინ ახლა
და აწარმოებს buggy2, შეიტანეთ.

284
00:14:20,940 --> 00:14:22,620
და ახლა გადახვევა.

285
00:14:22,620 --> 00:14:24,890
და ნება მომეცით გაიზრდება
ზომა ფანჯარა.

286
00:14:24,890 --> 00:14:33,720
>> მე, როგორც ჩანს 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
ასე რომ, 11 hashtags, მიუხედავად იმისა, რომ
მე აშკარად დააყენა 10 შიგნით ამ loop.

288
00:14:38,891 --> 00:14:42,140
ახლა, ზოგიერთი შეიძლება ვხედავ დაუყოვნებლივ
რა შეცდომა არის ის, რომ, მართლაც, ეს

289
00:14:42,140 --> 00:14:43,720
არ არის ძალიან რთული შეცდომა, რათა.

290
00:14:43,720 --> 00:14:46,070
მაგრამ ეს ძალიან ხშირად
ძალიან დასაწყისში.

291
00:14:46,070 --> 00:14:49,820
>> რა მინდა აღვნიშნო, თუმცა,
არის, თუ როგორ შეიძლება მე გაერკვნენ ამ გარეთ?

292
00:14:49,820 --> 00:14:52,300
ისე, გამოდის, რომ
CS50 ბიბლიოთეკა გააჩნია

293
00:14:52,300 --> 00:14:55,380
არა მხოლოდ get_string და get_int
და get_float და სხვა ფუნქციები.

294
00:14:55,380 --> 00:14:59,980
მას ასევე გააჩნია სპეციალური ფუნქცია
მოუწოდა eprintf, ან, შეცდომა printf.

295
00:14:59,980 --> 00:15:03,270
და ის არსებობს მხოლოდ რათა
ეს ცოტა ადვილი თქვენთვის

296
00:15:03,270 --> 00:15:06,310
როდესაც გამართვის თქვენი კოდი მხოლოდ
ბეჭდვა შეცდომა ეკრანზე

297
00:15:06,310 --> 00:15:07,850
და ვიცი, სადაც იგი მოვიდა.

298
00:15:07,850 --> 00:15:11,000
>> ასე მაგალითად, ერთი რამ შეიძლება
გავაკეთოთ აქ ეს ფუნქცია ამას

299
00:15:11,000 --> 00:15:20,230
eprintf, და შემდეგ მე ვაპირებ წავიდეთ წინ
და ვთქვათ, მე ახლა% i, წარმატებული, ო.

300
00:15:20,230 --> 00:15:22,330
და მე ვაპირებ შეაერთედ ღირებულება i.

301
00:15:22,330 --> 00:15:25,400
და თავზე, რადგან ეს
არის CS50 ბიბლიოთეკა,

302
00:15:25,400 --> 00:15:27,580
მე ვაპირებ წავიდეთ წინ
და მოიცავს

303
00:15:27,580 --> 00:15:29,169
ასე რომ ჰქონდეს ამ ფუნქციას.

304
00:15:29,169 --> 00:15:31,460
მაგრამ მოდით განიხილავს, თუ რა ხაზი
9 უნდა აკეთებს.

305
00:15:31,460 --> 00:15:32,670
მე ვაპირებ წაშლა ამ საბოლოოდ.

306
00:15:32,670 --> 00:15:34,670
ეს არაფერი აქვს
ჩემი მთავარი მიზანია.

307
00:15:34,670 --> 00:15:39,090
მაგრამ eprintf, შეცდომა printf, მხოლოდ იმას ნიშნავდა,
მომეცი ზოგიერთი დიაგნოსტიკური ინფორმაცია.

308
00:15:39,090 --> 00:15:42,460
როდესაც მე აწარმოებს ჩემი პროგრამა, მინდა
ვხედავ ამ ეკრანზე დროებით

309
00:15:42,460 --> 00:15:44,550
ასევე უბრალოდ უნდა გვესმოდეს,
რა ხდება.

310
00:15:44,550 --> 00:15:47,330
>> და, რა თქმა უნდა, თითოეულ
iteration აქ line 9

311
00:15:47,330 --> 00:15:49,260
მე მინდა, რომ, რა არის ღირებულება i?

312
00:15:49,260 --> 00:15:50,290
რა არის ღირებულება i?

313
00:15:50,290 --> 00:15:51,280
რა არის ღირებულება i?

314
00:15:51,280 --> 00:15:55,650
და, იმედია, მე უნდა მხოლოდ
ვხედავთ, რომ გაგზავნა, ასევე, 10-ჯერ.

315
00:15:55,650 --> 00:15:57,780
>> ნება მომეცით წავიდეთ წინ და
recompile ჩემი პროგრამა,

316
00:15:57,780 --> 00:15:59,905
როგორც მე მაქვს ამის გაკეთება ნებისმიერ დროს
მე, რათა ცვლილება. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
ახლა კი OK.

319
00:16:03,640 --> 00:16:04,820
არსებობს კიდევ ბევრი ხდება.

320
00:16:04,820 --> 00:16:07,610
ნება მომეცით, გადახვევა მდე
კიდევ უფრო დიდი ფანჯარა.

321
00:16:07,610 --> 00:16:10,190
>> და დაინახავთ, რომ თითოეული
hashtags მაინც ბეჭდვა.

322
00:16:10,190 --> 00:16:15,270
მაგრამ შორის თითოეული მათგანი არის ამ
დიაგნოსტიკური გამომავალი ფორმატირებული ასეთია.

323
00:16:15,270 --> 00:16:17,960
სახელი ჩემი პროგრამა აქ არის buggy2.

324
00:16:17,960 --> 00:16:20,432
სახელი ფაილი buggy2.c.

325
00:16:20,432 --> 00:16:24,080
ხაზის ნომერი, რომელიც
ეს იყო დაბეჭდილი ხაზი 9.

326
00:16:24,080 --> 00:16:27,500
და შემდეგ მარჯვნივ რომ არის
შეცდომა, რომ მე ელოდება.

327
00:16:27,500 --> 00:16:30,701
>> და რა ლამაზი არის, რომ
ახლა მე არ უნდა აუცილებლად იმედი

328
00:16:30,701 --> 00:16:32,200
ჩემი უფროსი, რა ჩემი პროგრამა აკეთებს.

329
00:16:32,200 --> 00:16:34,240
მე ვხედავ, რომ
პირველი iteration არის 0,

330
00:16:34,240 --> 00:16:39,420
შემდეგ 1, 2, მაშინ 3, მაშინ 4, მაშინ
5, 6-, მაშინ 7, შემდეგ 8, შემდეგ 9, შემდეგ

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
ასე რომ, დაველოდოთ წუთში.

333
00:16:42,050 --> 00:16:43,740
რა ხდება აქ?

334
00:16:43,740 --> 00:16:48,190
მე მაინც, როგორც ჩანს იმედი
როგორც განკუთვნილი 10-მდე.

335
00:16:48,190 --> 00:16:50,550
>> მაგრამ სად უნდა დაიწყოს?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

337
00:16:53,240 --> 00:16:58,040
ასე რომ, 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11 თითი

338
00:16:58,040 --> 00:16:59,990
მიუთითებს პრობლემა.

339
00:16:59,990 --> 00:17:02,850
მე, როგორც ჩანს არ ითვლება
არასწორად ჩემი loop.

340
00:17:02,850 --> 00:17:06,599
ვიდრე წასვლა 10 iterations,
მე დაწყებული 0,

341
00:17:06,599 --> 00:17:09,550
მე დამთავრებული და საშუალებით 10.

342
00:17:09,550 --> 00:17:12,030
არამედ იმიტომ, რომ, როგორც კომპიუტერი,
მე დაწყებული დათვლა 0,

343
00:17:12,030 --> 00:17:15,250
მე უნდა დამთვლელი მდე
, მაგრამ არა, 10.

344
00:17:15,250 --> 00:17:18,510
>> ასე რომ, სარემონტო, მე საბოლოოდ
მიხვდა, აქ არის ერთი ორი რამ.

345
00:17:18,510 --> 00:17:22,430
მე შეიძლება ძალიან უბრალოდ ვთქვა,
ითვლიან მდე არანაკლებ 10.

346
00:17:22,430 --> 00:17:27,260
ასე რომ, 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, რომელიც, მართლაც, სწორი,

347
00:17:27,260 --> 00:17:28,900
მიუხედავად იმისა, რომ ჟღერს ცოტა არასწორია.

348
00:17:28,900 --> 00:17:35,070
ან მე ვერ გავაკეთებ ნაკლებია ან ტოლი
9, სანამ მე იწყება 0.

349
00:17:35,070 --> 00:17:40,056
ან თუ თქვენ ნამდვილად არ მინდა, რომ თქვენ
შეგიძლიათ იმედი მეშვეობით 10 მაგრამ იწყება 1.

350
00:17:40,056 --> 00:17:41,680
თუმცა ისევ და ისევ, ეს უბრალოდ არ არის, რომ გავრცელებული.

351
00:17:41,680 --> 00:17:43,977
In პროგრამირების თუმცა
არა იმდენად ნულიდან

352
00:17:43,977 --> 00:17:45,810
მაგრამ პროგრამირების
C და სხვა ენებზე,

353
00:17:45,810 --> 00:17:47,670
როგორიცაა JavaScript და
Python და სხვები,

354
00:17:47,670 --> 00:17:49,880
უბრალოდ ძალიან გავრცელებული
ჩვენი დისკუსიის ორობითი

355
00:17:49,880 --> 00:17:53,450
უბრალოდ დაიწყება დათვლის დროს
დაბალი შეგიძლიათ, რომელიც არის 0.

356
00:17:53,450 --> 00:17:53,950
კარგი.

357
00:17:53,950 --> 00:17:55,160
ასე რომ, eprintf.

358
00:17:55,160 --> 00:17:58,600
ისევ და ისევ, ახლა რომ მე figured out my
პრობლემა, და მე ვაპირებ დაბრუნდეს 0

359
00:17:58,600 --> 00:18:01,470
მეშვეობით არანაკლებ 10, მე ვაპირებ
წავიდეს და წაშლა eprintf.

360
00:18:01,470 --> 00:18:04,580
>> ეს არ უნდა იყოს, როდესაც მე
მოვახდენთ ჩემი კოდი ან წარმოადგინოს ჩემი კოდი

361
00:18:04,580 --> 00:18:05,800
და აჩვენებს, რომ ვინმეს.

362
00:18:05,800 --> 00:18:07,980
ეს მართლაც მხოლოდ იმას ნიშნავდა,
უნდა იყოს გამოყენებული დროებით.

363
00:18:07,980 --> 00:18:11,650
მაგრამ ახლა მე დაფიქსირდა ამ
კერძოდ პრობლემაა.

364
00:18:11,650 --> 00:18:16,780
>> ისე, მოდით გავაკეთოთ კიდევ ერთი მაგალითია აქ
რომ მე ვაპირებ რომ whip up ასეთია.

365
00:18:16,780 --> 00:18:22,850
მე ვაპირებ წავიდეთ წინ და
მოიცავს. $ 50

366
00:18:22,850 --> 00:18:25,580
და მე ვაპირებ წავიდეთ წინ
და მოიცავს.

367
00:18:25,580 --> 00:18:29,030
>> და მე ვაპირებ გადარჩენა
ამ ფაილს, როგორც buggy3.c.

368
00:18:29,030 --> 00:18:31,740
და მე ვაპირებ წავიდეთ წინ
და აცხადებენ, int ძირითადი (void).

369
00:18:31,740 --> 00:18:34,186
და შემდეგ შიგნით არსებობს
მე ვაპირებ ამის გაკეთებას int i _ -

370
00:18:34,186 --> 00:18:36,435
მე მინდა, რომ პროგრამის განხორციელება
ერთად get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
ეს არ არის ფუნქცია, რომელიც არსებობს ამჟამად.

373
00:18:40,770 --> 00:18:42,870
ასე რომ, ჩვენ ვაპირებთ განახორციელოს
ეს მხოლოდ ერთი წუთით.

374
00:18:42,870 --> 00:18:45,541
მაგრამ ჩვენ ვაპირებთ, თუ რატომ
ეს buggy პირველ რიგში უღელტეხილზე.

375
00:18:45,541 --> 00:18:47,290
და კიდევ მე მიღებული
int ეხლა შესახებ,

376
00:18:47,290 --> 00:18:53,365
მე უბრალოდ აპირებს ბეჭდვა% i არის უარყოფითი
რიცხვი, წარმატებული, ო, მძიმე, i.

377
00:18:53,365 --> 00:18:55,240
სხვა სიტყვებით, ყველა მე
გვინდა, რომ ეს პროგრამა უნდა გააკეთოს

378
00:18:55,240 --> 00:18:58,000
არის კიდევ უარყოფითი int საწყისი
შესახებ და შემდეგ ამობეჭდოთ

379
00:18:58,000 --> 00:18:59,980
რომ ასეთი და ასეთი უარყოფითი int.

380
00:18:59,980 --> 00:19:02,080
>> ახლა მე უნდა განახორციელოს ამ ფუნქციას.

381
00:19:02,080 --> 00:19:05,740
ასე რომ, შემდეგ ჩემი ფაილი, მე ვაპირებ წასვლა
წინ და აცხადებენ ფუნქცია მოუწოდა

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - და ჩვენ
დაბრუნდება რა, რომ ხაზი იმას ნიშნავს, კიდევ ერთხელ

383
00:19:10,670 --> 00:19:18,790
ამ მომენტში int n; გავაკეთოთ do
ასეთია printf n არის :.

384
00:19:18,790 --> 00:19:26,210
და შემდეგ მე ვაპირებ ამის n - get_int,
და ამის გაკეთება, ხოლო n მეტია 0.

385
00:19:26,210 --> 00:19:28,310
ხოლო შემდეგ დაბრუნდნენ n ;.

386
00:19:28,310 --> 00:19:31,730
>> ასე რომ, არსებობს უამრავი მიმდინარეობს
ეს თუმცა არც ერთი მათგანი ჩვენ არ

387
00:19:31,730 --> 00:19:33,710
შევხედოთ გასულ კვირას, მინიმუმ მოკლედ.

388
00:19:33,710 --> 00:19:36,980
ასე რომ, on line 10 აქ მე გამოაცხადა
ფუნქცია მოუწოდა get_negative_int,

389
00:19:36,980 --> 00:19:39,620
და მე დააყენა (void), ამ
ფრჩხილებში, იმ მიზეზით, რომ ამ

390
00:19:39,620 --> 00:19:40,950
არ იღებს შეყვანა.

391
00:19:40,950 --> 00:19:42,910
მე არ გავლის არაფერი
ამ ფუნქციას.

392
00:19:42,910 --> 00:19:44,690
მე უბრალოდ მიღების რაღაც უკან მას.

393
00:19:44,690 --> 00:19:47,270
>> და რა მე იმ იმედით, რომ
დავუბრუნდეთ არის მთელი რიცხვი.

394
00:19:47,270 --> 00:19:50,040
არ არსებობს მონაცემები ტიპის
C მოუწოდა negative_int.

395
00:19:50,040 --> 00:19:52,880
ეს მხოლოდ int, ასე რომ, ის აპირებს
უნდა იყოს ჩვენთვის, რათა დავრწმუნდეთ,

396
00:19:52,880 --> 00:19:55,340
რომ ღირებულება, რომელიც, ფაქტობრივად,
დაბრუნებული არ არის მხოლოდ int

397
00:19:55,340 --> 00:19:56,380
მაგრამ ასევე უარყოფითი.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 მე გამოცხადების ცვლადი
მოუწოდა N და რაც ტიპის int.

399
00:20:02,150 --> 00:20:07,500
ხოლო შემდეგ ხაზი 13 გზით 18 ვარ
თავისსავე ხოლო რაღაც მართლაც ასეა.

400
00:20:07,500 --> 00:20:11,040
მე ვაპირებ წინ და ბეჭდვა
n არის, მსხვილი ნაწლავის და მაშინ სივრცე,

401
00:20:11,040 --> 00:20:12,800
როგორიცაა ზოლში შესახებ.

402
00:20:12,800 --> 00:20:16,410
>> მე მაშინ მოუწოდებს get_int და
შენახვის ე.წ. დაბრუნების ღირებულება

403
00:20:16,410 --> 00:20:18,130
რომ ცვლადი ო.

404
00:20:18,130 --> 00:20:22,600
მაგრამ მე ვაპირებ აკეთეთ
ხოლო n მეტია 0.

405
00:20:22,600 --> 00:20:27,960
სხვა სიტყვებით, თუ მომხმარებელი მაძლევს
int და, რომ ნომერი მეტია 0,

406
00:20:27,960 --> 00:20:31,180
ergo, დადებითი, მე ვაპირებ
უბრალოდ შეინახოს reprompting შესახებ,

407
00:20:31,180 --> 00:20:37,160
შენარჩუნება reprompting, აიძულებენ უნდა
ითანამშრომლონ და მომეცი უარყოფითი int.

408
00:20:37,160 --> 00:20:41,640
>> და კიდევ n არის რეალურად negative--
ვარაუდობენ მომხმარებლის საბოლოოდ სახის -50,

409
00:20:41,640 --> 00:20:46,710
შემდეგ ამ ხოლო loop აღარ არის ჭეშმარიტი
იმიტომ -50 არ არის უფრო მეტი, ვიდრე 0.

410
00:20:46,710 --> 00:20:51,140
ასე რომ, ჩვენ შესვენება გარეთ რომ
loop ლოგიკურად და დაბრუნდნენ n.

411
00:20:51,140 --> 00:20:53,520
>> მაგრამ არსებობს ერთი სხვა
რაც უნდა გააკეთოს.

412
00:20:53,520 --> 00:20:56,190
და მე შემიძლია უბრალოდ ამისათვის
მიერ გადაწერა და pasting

413
00:20:56,190 --> 00:20:58,540
ერთი ხაზი კოდი ზედა ფაილი.

414
00:20:58,540 --> 00:21:01,630
მე უნდა ავუხსნათ, Clang,
და გპირდებით, რომ Clang,

415
00:21:01,630 --> 00:21:04,630
მკაფიოდ, რომ მე,
მართლაც, წასვლა და განხორციელება

416
00:21:04,630 --> 00:21:06,020
ამ ფუნქციის get_negative_int.

417
00:21:06,020 --> 00:21:07,674
ეს შეიძლება იყოს ქვედა ფაილი.

418
00:21:07,674 --> 00:21:09,840
კიდევ ერთხელ გავიხსენოთ, რომ Clang
ნათქვამია რამ ზემოდან,

419
00:21:09,840 --> 00:21:12,330
მარცხნიდან მარჯვნივ, ასე რომ თქვენ არ შეუძლია
მოვუწოდებთ ფუნქცია თუ Clang

420
00:21:12,330 --> 00:21:15,330
არ ვიცი, ის აპირებს, რომ არსებობს.

421
00:21:15,330 --> 00:21:18,430
>> ახლა, სამწუხაროდ, ეს პროგრამა,
როგორც ზოგიერთი თქვენ ალბათ შენიშნა,

422
00:21:18,430 --> 00:21:19,590
უკვე buggy.

423
00:21:19,590 --> 00:21:21,400
ნება მომეცით წავიდეთ წინ და მიიღოს buggy3.

424
00:21:21,400 --> 00:21:26,904
იგი ადგენს, ასე რომ ჩემი პრობლემა ახლა არ არის
სინტაქსური შეცდომა, როგორც ტექსტური შეცდომა,

425
00:21:26,904 --> 00:21:29,570
ეს რეალურად იქნება ლოგიკური
შეცდომა, რომ მე შეგნებულად

426
00:21:29,570 --> 00:21:32,450
გააკეთა, როგორც საშუალება
ნაბიჯ მეშვეობით, თუ რა ხდება.

427
00:21:32,450 --> 00:21:35,540
>> მე ვაპირებ წავიდეთ წინ
ახლა და აწარმოებს buggy3.

428
00:21:35,540 --> 00:21:37,490
და მე ვაპირებ წასვლა
წინ და არ ითანამშრომლებს.

429
00:21:37,490 --> 00:21:39,494
მე ვაპირებ, რათა ეს ნომერი 1.

430
00:21:39,494 --> 00:21:41,410
ეს არ მოსწონს, ასე რომ
ის რითაც მე კიდევ ერთხელ.

431
00:21:41,410 --> 00:21:42,147
>> როგორ შესახებ 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
არც იმ მუშაობენ.

435
00:21:44,740 --> 00:21:46,890
როგორ შესახებ -50?

436
00:21:46,890 --> 00:21:48,560
და პროგრამა ჩანს მუშაობა.

437
00:21:48,560 --> 00:21:49,970
>> ნება მომეცით ცდილობენ ეს კიდევ ერთხელ.

438
00:21:49,970 --> 00:21:53,400
ნება მომეცით ცდილობენ -1, როგორც ჩანს მუშაობა.

439
00:21:53,400 --> 00:21:56,380
ნება მომეცით ცდილობენ -2, როგორც ჩანს მუშაობა.

440
00:21:56,380 --> 00:21:59,640
ნება მომეცით ცდილობენ 0.

441
00:21:59,640 --> 00:22:01,684
Huh, რომ არასწორია.

442
00:22:01,684 --> 00:22:03,350
ახლა, ჩვენ რომ ცოტა pedantic აქ.

443
00:22:03,350 --> 00:22:07,090
მაგრამ ეს, რა თქმა უნდა, იმ შემთხვევაში, რომ 0
არც დადებითი და არც უარყოფითი.

444
00:22:07,090 --> 00:22:11,150
ასე რომ, ის ფაქტი, რომ ჩემი პროგრამა
განაცხადა, რომ 0 არის უარყოფითი რიცხვი,

445
00:22:11,150 --> 00:22:12,820
ეს არ არის ტექნიკურად სწორი.

446
00:22:12,820 --> 00:22:15,180
>> ახლა, რატომ აკეთებს ამას?

447
00:22:15,180 --> 00:22:16,270
ისე, ეს შეიძლება იყოს აშკარა.

448
00:22:16,270 --> 00:22:18,110
და, მართლაც, პროგრამა
იგულისხმება, რომ იყოს საკმაოდ მარტივია

449
00:22:18,110 --> 00:22:19,670
ასე რომ, ჩვენ გვაქვს რაღაც შეისწავლონ.

450
00:22:19,670 --> 00:22:25,870
>> მაგრამ მოდით გააცნობს მესამე გამართვის
ტექნიკა აქ მოუწოდა debug50.

451
00:22:25,870 --> 00:22:27,750
ასე რომ, ეს არის პროგრამა
რომ ჩვენ უბრალოდ შექმნა

452
00:22:27,750 --> 00:22:30,770
ამ წელს სახელწოდებით debug50
რომელიც საშუალებას გაძლევთ,

453
00:22:30,770 --> 00:22:34,130
გამოიყენოს რასაც ჩაშენებული
გრაფიკული debugger in CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
და debugger არის პროგრამა, რომელიც
ზოგადად გაძლევთ აწარმოებს თქვენი პროგრამის

455
00:22:38,400 --> 00:22:44,050
მაგრამ ნაბიჯ ნაბიჯ-ნაბიჯ, ხაზი
მიერ ხაზს, დაპაუზება, გააღიზიანოს

456
00:22:44,050 --> 00:22:47,626
გარშემო, ეძებს ცვლადები ისე, რომ
პროგრამა არ უბრალოდ აფეთქება წარსულში თქვენ

457
00:22:47,626 --> 00:22:49,750
და სწრაფად ბეჭდვა რაღაც
თუ არა ბეჭდვა რაღაც.

458
00:22:49,750 --> 00:22:53,250
ეს გაძლევთ შესაძლებლობა,
ადამიანის სიჩქარე, ურთიერთქმედება იგი.

459
00:22:53,250 --> 00:22:55,470
>> და ამის გაკეთება, თქვენ
უბრალოდ ამის შემდეგ.

460
00:22:55,470 --> 00:22:58,479
მას შემდეგ, რაც შედგენა თქვენი კოდი,
რომელიც მე უკვე გააკეთა, buggy3,

461
00:22:58,479 --> 00:23:00,020
თქვენ წავიდეთ წინ და აწარმოებს debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
ასე ჰგავს help50 აქვს თქვენ აწარმოებს
help50 და შემდეგ ბრძანება,

464
00:23:06,760 --> 00:23:10,120
debug50 აქვს თქვენ აწარმოებს debug50 და
შემდეგ სახელი ბრძანება.

465
00:23:10,120 --> 00:23:14,440
>> ახლა უყურებს, რა მოხდება ჩემი ეკრანზე,
მარჯვენა მხარეს, კერძოდ.

466
00:23:14,440 --> 00:23:19,400
როდესაც მე მოხვდა Run, ყველა
უეცრად ეს მარჯვენა პანელი

467
00:23:19,400 --> 00:23:20,419
ხსნის ეკრანზე.

468
00:23:20,419 --> 00:23:22,210
და იქ ბევრი აპირებს
on ერთი შეხედვით.

469
00:23:22,210 --> 00:23:25,110
მაგრამ იქ არ არის ძალიან
ბევრი ფიქრი არ არის.

470
00:23:25,110 --> 00:23:28,570
>> ეს აჩვენებს, ყველაფერი,
რომ ხდება შიგნით ჩემი პროგრამა

471
00:23:28,570 --> 00:23:31,130
ახლავე და მეშვეობით ამ
ღილაკები ზევით შემდეგ

472
00:23:31,130 --> 00:23:35,910
საშუალებას ჩემთვის დაიხევს მეშვეობით my კოდი
საბოლოო ჯამში, ნაბიჯ-ნაბიჯ-ნაბიჯ.

473
00:23:35,910 --> 00:23:37,140
მაგრამ არა მხოლოდ ამჟამად.

474
00:23:37,140 --> 00:23:38,060
ყურადღება მიაქციეთ, რა ხდება.

475
00:23:38,060 --> 00:23:40,600
ჩემი ტერმინალის ფანჯარაში
მე მიმდინარეობს აიძულა n.

476
00:23:40,600 --> 00:23:44,560
და მე ვაპირებ წავიდეთ წინ და
ითანამშრომლონ ამ დროს და ტიპის -1.

477
00:23:44,560 --> 00:23:48,770
და თუმცა ცოტა cryptically, -1
უარყოფითი რიცხვი, როგორც მოსალოდნელი იყო.

478
00:23:48,770 --> 00:23:52,020
>> და მაშინ ბავშვი დასრულების ერთად
სტატუსი 0 GDBserver არსებული.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, არის სახელი
ძირითადი პროგრამული უზრუნველყოფა

480
00:23:55,180 --> 00:23:56,620
რომელიც ახორციელებს ამ debugger.

481
00:23:56,620 --> 00:24:00,500
მაგრამ ყველა ეს ნამდვილად იმას ნიშნავს, რომ debugger
წავიდა იმიტომ, რომ ჩემი პროგრამა დატოვა

482
00:24:00,500 --> 00:24:01,710
და ყველა კარგად იყო.

483
00:24:01,710 --> 00:24:06,020
თუ მინდა, რომ ნამდვილად გამართვის ჩემი პროგრამა,
მაქვს წინასწარ გეტყვით debug50,

484
00:24:06,020 --> 00:24:08,920
სად მინდა, რომ დაიწყოს
სტეპინგზე მეშვეობით ჩემი კოდი?

485
00:24:08,920 --> 00:24:11,750
>> და, ალბათ, ყველაზე მარტივი გზა
უნდა გავაკეთოთ, რომ ასეთია.

486
00:24:11,750 --> 00:24:15,300
თუ მე hover მეტი
წყალსაწრეტი ჩემი რედაქტორი აქ,

487
00:24:15,300 --> 00:24:19,090
ასე რომ, მართლაც, მხოლოდ sidebar აქ,
მარცხნივ ხაზის ნომერი,

488
00:24:19,090 --> 00:24:21,870
გაითვალისწინეთ, რომ თუ მე უბრალოდ დააჭირეთ
ერთხელ, მე პატარა წითელი dot.

489
00:24:21,870 --> 00:24:24,460
და რომ პატარა წითელი dot,
როგორიცაა გაჩერების ნიშანი, ნიშნავს, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, პაუზის აღსრულების ჩემი კოდი
უფლება, როდესაც მე აწარმოებს ამ პროგრამის.

491
00:24:29,430 --> 00:24:30,260
>> მოდით გავაკეთოთ, რომ.

492
00:24:30,260 --> 00:24:37,340
ნება მომეცით წავიდეთ წინ და აწარმოებს ჩემი პროგრამა
კვლავ debug50 ./buggy3, შეიტანეთ.

493
00:24:37,340 --> 00:24:40,110
და ახლა, ცნობა, რაღაც
სხვადასხვა მოხდა.

494
00:24:40,110 --> 00:24:42,440
მე არ მიმდინარეობს აიძულა
ჯერ ჩემი ტერმინალის ფანჯარაში

495
00:24:42,440 --> 00:24:45,430
არაფერი, იმიტომ, რომ მე არ მაქვს
მიღებული არსებობს ამჟამად ჩემი პროგრამა.

496
00:24:45,430 --> 00:24:47,950
გაითვალისწინეთ, რომ on line 8
რომელიც ახლა ხაზი გაუსვა,

497
00:24:47,950 --> 00:24:51,720
და იქ პატარა ისარი
მარცხენა გამონათქვამი, თქვენ შეჩერებულია აქ.

498
00:24:51,720 --> 00:24:55,030
ეს ხაზი კოდი, ხაზი
8, ჯერ კიდევ არ არის შესრულებული.

499
00:24:55,030 --> 00:24:58,940
>> და რა არის საინტერესო, თუ გავითვალისწინებთ
მეტი აქ მარჯვენა მხარეს,

500
00:24:58,940 --> 00:25:03,530
შეამჩნია, რომ მე ადგილობრივი
ცვლადი, ადგილობრივი იმ გაგებით,

501
00:25:03,530 --> 00:25:05,450
ის, რომ ქვეყნის შიგნით მიმდინარე ფუნქცია.

502
00:25:05,450 --> 00:25:08,920
და მისი ღირებულება, როგორც ჩანს, ჩვეულებრივ,
და ერთგვარი მოხერხებულად, არის 0.

503
00:25:08,920 --> 00:25:10,260
მაგრამ მე არ აკრიფოთ 0.

504
00:25:10,260 --> 00:25:13,410
რომ რაღაც უნდა იყოს მისი
რა მნიშვნელობა მომენტში.

505
00:25:13,410 --> 00:25:15,490
>> ნება მომეცით, წავიდეთ წინ და ამის გაკეთება ახლა.

506
00:25:15,490 --> 00:25:18,680
ნება მომეცით წავიდეთ წინ და
ზედა მარჯვენა აქ, მე

507
00:25:18,680 --> 00:25:20,970
ვაპირებ წავიდეთ წინ და
დააჭირეთ ამ პირველი ხატი, რომელიც

508
00:25:20,970 --> 00:25:25,360
ნიშნავს ნაბიჯი მეტი რაც იმას ნიშნავს, არ გამოტოვოთ
, მაგრამ ნაბიჯ ამ ხაზი კოდი,

509
00:25:25,360 --> 00:25:27,770
შესრულებაში მას გზაზე.

510
00:25:27,770 --> 00:25:30,710
>> ახლა კი, შეამჩნია, ჩემი
სწრაფი ახლახანს შეიცვალა.

511
00:25:30,710 --> 00:25:31,380
რატომ არის, რომ?

512
00:25:31,380 --> 00:25:33,639
მე ვუთხარი debug50,
აწარმოებს ამ ხაზი კოდი.

513
00:25:33,639 --> 00:25:34,930
რას ნიშნავს ეს ხაზი კოდი გავაკეთოთ?

514
00:25:34,930 --> 00:25:35,960
მოთხოვნა ჩემთვის int.

515
00:25:35,960 --> 00:25:36,460
კარგი.

516
00:25:36,460 --> 00:25:37,400
მიადევნე თვალი ითანამშრომლოს.

517
00:25:37,400 --> 00:25:41,340
ნება მომეცით წავიდეთ წინ არის და ჩაწერეთ -1, შეიტანეთ.

518
00:25:41,340 --> 00:25:42,920
და ახლა შეამჩნია, რაც შეიცვალა.

519
00:25:42,920 --> 00:25:46,060
მარჯვენა მხარეს,
ჩემი ადგილობრივი ცვლადი i

520
00:25:46,060 --> 00:25:48,200
არის მითითებული, როგორც -1 ახლა.

521
00:25:48,200 --> 00:25:49,810
და ეს კიდევ ტიპის int.

522
00:25:49,810 --> 00:25:53,102
>> და გაფრთხილების, ძალიან, ჩემი ე.წ.
სტეკი, სად მე პაუზის?

523
00:25:53,102 --> 00:25:54,810
ჩვენ გაიგო უფრო მეტი
ეს მომავალში.

524
00:25:54,810 --> 00:25:58,620
მაგრამ სტეკი უბრალოდ ეხება რა
ფუნქციები გაკეთებული მოძრაობაში.

525
00:25:58,620 --> 00:26:00,040
ახლა ის უბრალოდ ძირითადი.

526
00:26:00,040 --> 00:26:03,590
და ახლა მხოლოდ ადგილობრივი
ცვლადი i ღირებულების 1.

527
00:26:03,590 --> 00:26:09,840
>> და როცა საბოლოოდ გადადგას ამ ონლაინ
აქ, რომ იგივე ხატი ზედა მარჯვენა,

528
00:26:09,840 --> 00:26:11,410
-1 არის უარყოფითი რიცხვი.

529
00:26:11,410 --> 00:26:13,580
ახლა ის დაპაუზება გამო, რომ Curly გაუწიოს.

530
00:26:13,580 --> 00:26:14,740
მოდით ასეც გააკეთებს რამ.

531
00:26:14,740 --> 00:26:17,300
მე ნაბიჯ გამო, რომ ხაზი, და voila.

532
00:26:17,300 --> 00:26:20,240
>> ასე არ არის ყველა, რომ საშინლად
ნათელი არ არის,

533
00:26:20,240 --> 00:26:23,550
მაგრამ ის ნება მომეცით პაუზის
და ვფიქრობ ლოგიკურად

534
00:26:23,550 --> 00:26:24,870
რა ეს პროგრამა აკეთებს.

535
00:26:24,870 --> 00:26:26,890
მაგრამ ეს არ იყო მცდარი შემთხვევაში.

536
00:26:26,890 --> 00:26:28,510
მოდით ეს კიდევ ერთხელ გავაკეთოთ ასეთია.

537
00:26:28,510 --> 00:26:31,340
>> მე ვაპირებ დატოვება, რომ breakpoint
on line 8 წითელი dot.

538
00:26:31,340 --> 00:26:32,830
მე ვაპირებ გამეორება debug50.

539
00:26:32,830 --> 00:26:34,400
ეს ავტომატურად paused აქ.

540
00:26:34,400 --> 00:26:37,660
მაგრამ ამ დროს, ნაცვლად
სტეპინგზე მეტი ამ ხაზის,

541
00:26:37,660 --> 00:26:42,290
ნება მომეცით რეალურად წასვლა შიგნით
get_negative_int და გაერკვნენ,

542
00:26:42,290 --> 00:26:45,530
რატომ არის ის მიღება 0 როგორც მოქმედი პასუხი?

543
00:26:45,530 --> 00:26:47,990
>> ასე რომ, ნაცვლად დაჭერით ნაბიჯი მეტი.

544
00:26:47,990 --> 00:26:50,630
მე ვაპირებ წავიდეთ წინ
და დააჭირეთ Step Into.

545
00:26:50,630 --> 00:26:54,030
და შენიშნავს, რომ ხაზი 8, რომ
ახლა ყურადღება გაამახვილა ახლა მოულოდნელად

546
00:26:54,030 --> 00:26:56,900
ხდება ხაზი 17.

547
00:26:56,900 --> 00:26:59,947
>> ახლა, ეს არ ნიშნავს, რომ debugger
აქვს გამოტოვებენ ხაზები 14 და 15 და 16.

548
00:26:59,947 --> 00:27:01,780
ეს უბრალოდ არ არის არაფერი
რომ ნახოთ, თუ არსებობს.

549
00:27:01,780 --> 00:27:04,050
ეს მხოლოდ გამოცხადების ცვლადები,
და შემდეგ იქ სიტყვას

550
00:27:04,050 --> 00:27:05,390
და შემდეგ ღია Curly გაუწიოს.

551
00:27:05,390 --> 00:27:09,227
მხოლოდ ფუნქციური ხაზი, რომელიც არის
წვნიანი ნამდვილად არის ერთი აქ, 17.

552
00:27:09,227 --> 00:27:11,060
და რომ სადაც ჩვენ
შეჩერებულია ავტომატურად.

553
00:27:11,060 --> 00:27:13,870
>> ასე რომ, printf ( "n.is:") ;, ასე
რომელიც ჯერ არ მომხდარა.

554
00:27:13,870 --> 00:27:18,250
მოდით წავიდეთ წინ და დააჭირეთ გადახვიდე.

555
00:27:18,250 --> 00:27:20,326
ახლა ჩემი სწრაფი, მართლაც,
შეიცვალა ( "ო").

556
00:27:20,326 --> 00:27:22,450
ახლა get_int, მე არ ვაპირებ
შეწუხება სტეპინგზე შევიდა,

557
00:27:22,450 --> 00:27:24,750
იმიტომ, რომ ფუნქცია
სანახავად CS50 ბიბლიოთეკა.

558
00:27:24,750 --> 00:27:25,750
ეს სავარაუდოდ სწორი.

559
00:27:25,750 --> 00:27:28,440
>> ამიტომ, მე ვაპირებ წავიდეთ წინ და
ერთგვარი ითანამშრომლოს ვაძლევთ მას

560
00:27:28,440 --> 00:27:30,590
int, მაგრამ არ არის ნეგატიური int.

561
00:27:30,590 --> 00:27:32,870
ნება მომეცით წავიდეთ წინ და მოხვდა 0.

562
00:27:32,870 --> 00:27:39,460
და ახლა, რა ხდება აქ
როდესაც მე ქვემოთ ხაზი 21?

563
00:27:39,460 --> 00:27:40,890
მე არ iterated ერთხელ.

564
00:27:40,890 --> 00:27:43,320
მე არ ჩანს, დავრჩებოდით რომ ციკლი.

565
00:27:43,320 --> 00:27:45,990
სხვა სიტყვებით, ეს ყვითელი
ბარი არ შეინახოს აპირებს გარშემო,

566
00:27:45,990 --> 00:27:47,130
და მის გარშემო, და გარშემო.

567
00:27:47,130 --> 00:27:48,340
>> ახლა, რატომ არის, რომ?

568
00:27:48,340 --> 00:27:49,920
ისე, n, რა არის N ახლა?

569
00:27:49,920 --> 00:27:53,280
შემიძლია შევხედოთ ადგილობრივი
ცვლადები debugger.

570
00:27:53,280 --> 00:27:53,816
N არის 0.

571
00:27:53,816 --> 00:27:55,190
ყველა უფლება, რა იყო ჩემი მდგომარეობა?

572
00:27:55,190 --> 00:27:58,700
>> 20-- ხაზი 20, ასევე,
0 მეტია 0.

573
00:27:58,700 --> 00:27:59,500
ეს ასე არ არის.

574
00:27:59,500 --> 00:28:01,020
0 არ არის უფრო მეტი, ვიდრე 0.

575
00:28:01,020 --> 00:28:02,820
და ასე დაიწყო ამ.

576
00:28:02,820 --> 00:28:06,370
>> და ამიტომაც on line
21, თუ რეალურად გაგრძელდება,

577
00:28:06,370 --> 00:28:10,370
მე ვაპირებ დაბრუნებას 0, მაშინაც კი,
მიუხედავად იმისა, რომ მე არ უნდა უარყო 0

578
00:28:10,370 --> 00:28:12,484
როგორც რეალურად არ უარყოფითი.

579
00:28:12,484 --> 00:28:14,650
ასე რომ, ახლა მე ნამდვილად არ კი
აინტერესებს debugger.

580
00:28:14,650 --> 00:28:16,900
მივიღე ეს, მე არ უნდა
ვიცი, რა უფრო ხდება.

581
00:28:16,900 --> 00:28:19,233
>> ამიტომ, მე ვაპირებ წავიდეთ წინ და
უბრალოდ დააჭირეთ Play ღილაკს,

582
00:28:19,233 --> 00:28:20,240
და მოდით ეს ფერი up.

583
00:28:20,240 --> 00:28:23,440
ახლა, მე მივხვდი, რომ ჩემი
bug აშკარად on line 20.

584
00:28:23,440 --> 00:28:25,160
ეს არის ჩემი ლოგიკური შეცდომა.

585
00:28:25,160 --> 00:28:28,100
>> ასე რომ, რა არ მინდა
უნდა გავაკეთოთ, რომ შეიცვალოს ეს?

586
00:28:28,100 --> 00:28:32,500
თუ პრობლემა არის ის, რომ მე არ ვარ
გამოჭერის 0, უბრალოდ ლოგიკური შეცდომა.

587
00:28:32,500 --> 00:28:35,910
და შემიძლია ვთქვა, ხოლო n
მეტია ან ტოლია 0,

588
00:28:35,910 --> 00:28:38,330
შევინარჩუნოთ რამაც მომხმარებლის ისევ და ისევ.

589
00:28:38,330 --> 00:28:41,050
>> ასე რომ, კიდევ ერთხელ, შეცდომა, ალბათ,
კი ნათელია, როდესაც დაინახა,

590
00:28:41,050 --> 00:28:42,410
წერენ, რომ ეს მხოლოდ რამდენიმე წუთის წინ.

591
00:28:42,410 --> 00:28:44,570
მაგრამ takeaway აქ
ის არის, რომ გამართვის 50,

592
00:28:44,570 --> 00:28:46,850
და debugging
პროგრამული უზრუნველყოფა უფრო ზოგადად,

593
00:28:46,850 --> 00:28:51,370
თქვენ გაქვთ ეს ახალი ი ძალა
გავლა საკუთარი კოდი, გამოიყურება

594
00:28:51,370 --> 00:28:55,590
მეშვეობით, რომ მარჯვენა პანელი, რაც
თქვენი ცვლადები ღირებულებები.

595
00:28:55,590 --> 00:28:57,700
ასე, რომ თქვენ არ არის აუცილებელი
უნდა გამოვიყენოთ რაღაც

596
00:28:57,700 --> 00:29:00,630
როგორც თქვენ eprintf ბეჭდვა იმ ღირებულებებს.

597
00:29:00,630 --> 00:29:04,430
თქვენ შეგიძლიათ რეალურად ვხედავთ მათ
ვიზუალურად ეკრანზე.

598
00:29:04,430 --> 00:29:08,920
>> ახლა, მიღმა, აღსანიშნავია, რომ
რომ არსებობს კიდევ ერთი ტექნიკა, რომელიც არის

599
00:29:08,920 --> 00:29:09,890
რეალურად სუპერ საერთო.

600
00:29:09,890 --> 00:29:13,120
და თქვენ ალბათ საინტერესოა, რატომ ამ პატარა
ბიჭი უკვე იჯდა სცენაზე.

601
00:29:13,120 --> 00:29:16,490
ასე რომ, ამ ტექნიკით, ზოგადად
ცნობილია, როგორც რეზინის იხვი გამართვის,

602
00:29:16,490 --> 00:29:18,786
რაც ნამდვილად არ არის მხოლოდ
პატივისცემის იმ ფაქტს,

603
00:29:18,786 --> 00:29:20,660
რომ ხშირად, როდესაც პროგრამისტები
წერა კოდი,

604
00:29:20,660 --> 00:29:22,650
ისინი არ ემთხვეოდეს
თანამშრომლობს სხვები,

605
00:29:22,650 --> 00:29:24,030
ან სამუშაო საერთო გარემოს.

606
00:29:24,030 --> 00:29:25,050
>> ისინი სახის სახლში.

607
00:29:25,050 --> 00:29:25,910
შესაძლოა, ეს გვიან ღამით.

608
00:29:25,910 --> 00:29:28,190
ისინი ცდილობენ ფიგურა
გარკვეული ხარვეზების მათი კოდი.

609
00:29:28,190 --> 00:29:29,330
და ისინი უბრალოდ არ ხედავს მას.

610
00:29:29,330 --> 00:29:30,329
>> და არ არსებობს roommate.

611
00:29:30,329 --> 00:29:31,250
არ არსებობს TF.

612
00:29:31,250 --> 00:29:32,680
არ არსებობს CA გარშემო.

613
00:29:32,680 --> 00:29:36,440
ყველა მათ აქვთ მათ შელფზე
ეს არის პატარა რეზინის ducky.

614
00:29:36,440 --> 00:29:39,030
>> ასე რომ, რეზინის იხვი გამართვის
მხოლოდ ამ მოწვევის

615
00:29:39,030 --> 00:29:42,780
ვფიქრობ რაღაც, როგორც სულელური
რადგან ეს, როგორც რეალური არსება,

616
00:29:42,780 --> 00:29:46,940
და რეალურად გავლა თქვენი კოდი
სიტყვიერი ამ inanimate ობიექტი.

617
00:29:46,940 --> 00:29:49,230
ასე, მაგალითად, თუ
ეს არის ჩემი მაგალითად აქ

618
00:29:49,230 --> 00:29:52,470
და გავიხსენოთ, რომ ადრე
პრობლემა იყო,

619
00:29:52,470 --> 00:29:58,140
თუ წავშალო ეს პირველი ხაზი კოდი,
და მე, წავიდეთ წინ და buggy 0, კიდევ ერთხელ,

620
00:29:58,140 --> 00:30:01,220
გავიხსენოთ, რომ მე მქონდა ეს
შეცდომის შეტყობინებები აქ.

621
00:30:01,220 --> 00:30:05,997
ასე რომ, იდეა აქ, სასაცილოა, თუმცა მე
გრძნობს მომენტში ამით საჯაროდ,

622
00:30:05,997 --> 00:30:06,580
ის არის, რომ შეცდომა.

623
00:30:06,580 --> 00:30:10,910
>> OK, ასე რომ, ჩემი პრობლემა ის არის, რომ მე
მინიშნებით განაცხადა ბიბლიოთეკა ფუნქცია.

624
00:30:10,910 --> 00:30:12,610
და რომ ბიბლიოთეკის ფუნქცია printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, აცხადებენ,
მაგონებს პროტოტიპები.

626
00:30:15,290 --> 00:30:18,930
>> ეს ნიშნავს, რომ მე უნდა რეალურად
გითხრათ შემდგენელი წინასწარ რა

627
00:30:18,930 --> 00:30:19,980
ფუნქცია ჰგავს.

628
00:30:19,980 --> 00:30:20,930
ერთი წუთი მაცადე.

629
00:30:20,930 --> 00:30:23,580
მე არ მაქვს სტანდარტული io.h.

630
00:30:23,580 --> 00:30:24,530
ძალიან დიდი მადლობა.

631
00:30:24,530 --> 00:30:27,330
>> ასე რომ, მხოლოდ ეს პროცესი of-- თქვენ
არ უნდა რეალურად იხვი.

632
00:30:27,330 --> 00:30:29,819
მაგრამ ეს იდეა ფეხით
თავს მეშვეობით საკუთარი კოდი

633
00:30:29,819 --> 00:30:31,610
ასე რომ, თქვენ კი მოისმინოს
თავს, ასე რომ თქვენ

634
00:30:31,610 --> 00:30:35,620
გააცნობიეროს ხარვეზების საკუთარი
შენიშვნები, ზოგადად იდეა.

635
00:30:35,620 --> 00:30:38,910
>> და, ალბათ უფრო ლოგიკურად, ასე არ არის
ბევრი, რომ ერთი, არამედ უფრო ჩართული

636
00:30:38,910 --> 00:30:44,220
მაგალითად, ჩვენ უბრალოდ გააკეთა buggy 3.C,
თქვენ ფეხით თავს მეშვეობით

637
00:30:44,220 --> 00:30:45,310
შემდეგნაირად.

638
00:30:45,310 --> 00:30:49,190
ასე რომ, ყველა უფლება, რეზინის
ducky, DDB, თუ გნებავთ.

639
00:30:49,190 --> 00:30:52,350
აქ ჩვენ გვაქვს ჩემი მთავარი ფუნქცია,
მე ამას უარყოფითი int.

640
00:30:52,350 --> 00:30:54,660
>> და მე მიღების დაბრუნებული მნიშვნელობა.

641
00:30:54,660 --> 00:31:00,410
მე შენახვის მას მარცხენა მხარეს
on line 8 ცვლადში i.

642
00:31:00,410 --> 00:31:02,380
OK, მაგრამ დაველოდოთ, როგორ
რომ მიიღოს, რომ მნიშვნელობა?

643
00:31:02,380 --> 00:31:04,130
მიადევნე თვალი შევხედოთ ფუნქცია ხაზი 12.

644
00:31:04,130 --> 00:31:05,760
>> ხაზი 12, ჩვენ გვაქვს უარყოფითი int.

645
00:31:05,760 --> 00:31:08,190
არ მიიღოს ნებისმიერი საშუალებებით,
ამჯამად დაბრუნების int, OK.

646
00:31:08,190 --> 00:31:10,929
ვაცხადებ, on line 14 ცვლადი ო.

647
00:31:10,929 --> 00:31:12,220
ის აპირებს შესანახად რიცხვი.

648
00:31:12,220 --> 00:31:13,760
აი რა მინდა.

649
00:31:13,760 --> 00:31:18,480
>> ასე რომ, ამის შემდეგ, ხოლო n is-- მიადევნე
მომეცით გაუქმება, თუ რა სარემონტო მე უკვე გააკეთა.

650
00:31:18,480 --> 00:31:22,710
ასე რომ, ხოლო n მეტია
0, ამობეჭდოთ n არის, OK.

651
00:31:22,710 --> 00:31:25,170
და შემდეგ მისაღებად int ინახება n.

652
00:31:25,170 --> 00:31:30,160
და შემდეგ შეამოწმეთ თუ N არის 0
n არის not-- ეს არის.

653
00:31:30,160 --> 00:31:31,910
ასე რომ, კიდევ ერთხელ, თქვენ არ
უნდა ფაქტობრივი იხვი.

654
00:31:31,910 --> 00:31:35,650
მაგრამ მხოლოდ ფეხით საკუთარ თავს
თქვენი კოდი, როგორც ინტელექტუალური სწავლება

655
00:31:35,650 --> 00:31:37,720
ხშირად დაგეხმაროთ
გააცნობიეროს, თუ რა ხდება,

656
00:31:37,720 --> 00:31:41,170
განსხვავებით მხოლოდ თავისსავე
როგორც ეს, staring at ეკრანზე,

657
00:31:41,170 --> 00:31:43,720
და არ ვსაუბრობთ თავს მეშვეობით
ის, რაც პატიოსნად არ არის

658
00:31:43,720 --> 00:31:46,270
თითქმის როგორც ეფექტური ტექნიკით.

659
00:31:46,270 --> 00:31:48,620
ასე რომ თქვენ გაქვთ ის,
რაოდენობით სხვადასხვა ტექნიკა

660
00:31:48,620 --> 00:31:52,102
რეალურად debugging თქვენი კოდი
და მოძიებაში ბრალია, რაც

661
00:31:52,102 --> 00:31:54,810
უნდა იყოს ინსტრუმენტები თქვენს ინსტრუმენტარიუმის
ასე, რომ თქვენ არ გვიან ღამით,

662
00:31:54,810 --> 00:31:57,660
განსაკუთრებით, თქვენ სასადილო
დარბაზები, ან საათებში,

663
00:31:57,660 --> 00:32:00,368
banging თქვენი უფროსის წინააღმდეგ
კედელი, ცდილობს გადაწყვიტოს ზოგიერთი პრობლემა.

664
00:32:00,368 --> 00:32:02,020
გააცნობიეროს, რომ არსებობს პროგრამული ინსტრუმენტების.

665
00:32:02,020 --> 00:32:03,720
არსებობს რეზინის იხვი ინსტრუმენტები.

666
00:32:03,720 --> 00:32:09,630
და იქ მთელი პერსონალი
მხარს ვუჭერთ ელოდება სარგებლის მხრივ.

667
00:32:09,630 --> 00:32:13,120
>> ასე რომ, ახლა, სიტყვა პრობლემის
კომპლექტი, და ის, რაც ჩვენ იმ იმედით

668
00:32:13,120 --> 00:32:15,620
გავიდნენ და როგორ
ჩვენ შესახებ შეფასებისას.

669
00:32:15,620 --> 00:32:17,680
პოსტი რა თქმა უნდა, სილაბუსი,
CS50 პრობლემა კომპლექტი

670
00:32:17,680 --> 00:32:22,320
ფასდება ოთხი ძირითადი ღერძი, ასე რომ,
ვთქვათ ფარგლებში, სისწორეში, დიზაინი,

671
00:32:22,320 --> 00:32:23,060
და სტილი.

672
00:32:23,060 --> 00:32:25,910
და ფარგლები უბრალოდ ეხება, თუ რამდენად
ცალი თქვენ bitten off?

673
00:32:25,910 --> 00:32:28,080
რამდენი პრობლემა სცადა?

674
00:32:28,080 --> 00:32:30,110
რა დონის ძალისხმევა
თქვენ გამოიხატება?

675
00:32:30,110 --> 00:32:35,750
>> სისწორე არის, პროგრამა მუშაობს როგორც
ეს უნდა ერთ CS50 დაზუსტება

676
00:32:35,750 --> 00:32:38,640
როდესაც თქვენ გარკვეული საშუალებებით
ან გარკვეული შედეგები ბრუნდება?

677
00:32:38,640 --> 00:32:41,130
დიზაინი არის ყველაზე სუბიექტური მათგანი.

678
00:32:41,130 --> 00:32:43,360
და ეს არის ერთ-ერთი, რომელიც
, ყველაზე დიდი უნდა ვისწავლოთ

679
00:32:43,360 --> 00:32:47,220
და გრძელი ასწავლიან, ამ
იმდენად, რამდენადაც ეს boils ქვემოთ,

680
00:32:47,220 --> 00:32:49,530
რამდენად კარგად დაწერილი თქვენი კოდი?

681
00:32:49,530 --> 00:32:52,920
>> ეს არის ერთი რამ მხოლოდ ბეჭდვა სწორი
შედეგები ან დაბრუნებას მარჯვენა ღირებულებებს.

682
00:32:52,920 --> 00:32:55,400
მაგრამ აკეთებ, როგორც
ეფექტურად შეიძლება?

683
00:32:55,400 --> 00:32:58,210
თქვენ აკეთებთ ეს გათიშე
და დაიპყროთ, ან ორობითი

684
00:32:58,210 --> 00:33:01,500
ძიების როგორც ჩვენ მალე დაინახავთ, რომ ჩვენ გავაკეთეთ
ორი კვირის წინ სატელეფონო წიგნი?

685
00:33:01,500 --> 00:33:04,670
არსებობს უკეთესი გადაჭრის გზები
პრობლემა, ვიდრე თქვენ გაკეთებული გაქვთ?

686
00:33:04,670 --> 00:33:06,380
ეს არის შესაძლებლობა უკეთესი დიზაინი.

687
00:33:06,380 --> 00:33:08,530
>> და მაშინ style-- როგორ
საკმაოდ თქვენი კოდი?

688
00:33:08,530 --> 00:33:12,370
თქვენ შეამჩნევთ, რომ მე საკმაოდ
კერძოდ წაწევის ჩემი კოდი,

689
00:33:12,370 --> 00:33:15,300
და მიღების დარწმუნებული ვარ, ჩემი ცვლადები
გონივრულად დაასახელა. n,

690
00:33:15,300 --> 00:33:19,660
ხოლო მოკლედ, არის კარგი სახელი
ნომერი, მე დათვლის რიცხვი,

691
00:33:19,660 --> 00:33:20,727
s სიმებიანი.

692
00:33:20,727 --> 00:33:22,560
და ჩვენ შეგვიძლია აღარ
ცვლადი სახელები სტილი.

693
00:33:22,560 --> 00:33:25,500
სტილი, თუ რამდენად კარგი
ჯერ თქვენი კოდი გამოიყურება?

694
00:33:25,500 --> 00:33:26,600
და როგორ იკითხება ეს?

695
00:33:26,600 --> 00:33:29,650
>> და დროთა განმავლობაში, რა თქვენი TAs
და TFs გავაკეთებ, რა თქმა უნდა

696
00:33:29,650 --> 00:33:31,870
ეს მოგაწვდით, რომ
სახის ხარისხიანი კავშირი

697
00:33:31,870 --> 00:33:34,330
ასე რომ თქვენ უკეთ
იმ სხვადასხვა ასპექტებს.

698
00:33:34,330 --> 00:33:37,510
და თვალსაზრისით, თუ როგორ
შეაფასოს თითოეული ამ ცულები,

699
00:33:37,510 --> 00:33:40,080
ეს, როგორც წესი, ძალიან ცოტა
თაიგულების ასე, რომ თქვენ, როგორც წესი,

700
00:33:40,080 --> 00:33:41,680
მისაღებად გრძნობა რამდენად კარგად თქვენ აკეთებთ.

701
00:33:41,680 --> 00:33:45,680
და, მართლაც, თუ იღებთ ქულა
ნებისმიერი იმ ღერძი სისწორეში, დიზაინი

702
00:33:45,680 --> 00:33:49,659
და სტილი especially--, რომ ნომერი
ზოგადად, 1-დან 5.

703
00:33:49,659 --> 00:33:52,450
და, ფაქტიურად, თუ თქვენ მიღების
3 დაწყების სემესტრის

704
00:33:52,450 --> 00:33:53,977
ეს არის ძალიან კარგი რამ.

705
00:33:53,977 --> 00:33:55,810
ეს იმას ნიშნავს, რომ ის ჯერ კიდევ
ოთახი გაუმჯობესება,

706
00:33:55,810 --> 00:33:58,490
რომელიც თქვენ იმედი in
აღების კლასის პირველად.

707
00:33:58,490 --> 00:34:01,820
არსებობს იმედია ზოგიერთი ცოტა ჭერი
რომელიც თქვენ მიისწრაფვის მიაღწია.

708
00:34:01,820 --> 00:34:03,970
ასე რომ, მიღების 3-ის შესახებ
ადრეული ცალი,

709
00:34:03,970 --> 00:34:06,550
თუ არა, 2 და 4-ის,
მართლაც კარგია.

710
00:34:06,550 --> 00:34:08,880
ეს კარგად ფარგლებში სპექტრი,
კარგად მოლოდინი.

711
00:34:08,880 --> 00:34:11,421
>> და თუ თქვენი გონება racing, დაველოდოთ
ერთი წუთით, ხუთიდან სამი.

712
00:34:11,421 --> 00:34:12,620
ეს მართლაც 6 out of 10.

713
00:34:12,620 --> 00:34:13,560
ეს არის 60%.

714
00:34:13,560 --> 00:34:14,830
ღმერთო ჩემო, ეს არის ის, F.

715
00:34:14,830 --> 00:34:15,870
>> არ არის.

716
00:34:15,870 --> 00:34:17,600
ეს არ არის, ის ფაქტი, რომ.

717
00:34:17,600 --> 00:34:22,710
უფრო მეტიც, ეს შესაძლებლობა გააუმჯობესოს
მეტი კურსი სემესტრი.

718
00:34:22,710 --> 00:34:25,580
და თუ თქვენ მიღების რამდენიმე
Poors, ეს არის შესაძლებლობა

719
00:34:25,580 --> 00:34:29,199
ისარგებლოს საათებში,
რა თქმა უნდა, განყოფილებები და სხვა რესურსები.

720
00:34:29,199 --> 00:34:32,840
>> საუკეთესო არის შესაძლებლობა, მართლაც,
საამაყო, თუ რამდენად შორს თქვენ

721
00:34:32,840 --> 00:34:34,520
გადმოდიოდნენ კურსი სემესტრი.

722
00:34:34,520 --> 00:34:38,199
ასე რომ გააცნობიეროს, თუ არაფერი
სხვაგან, სამი არის კარგი.

723
00:34:38,199 --> 00:34:40,179
და ეს საშუალებას ოთახი ზრდის დროთა განმავლობაში.

724
00:34:40,179 --> 00:34:43,090
>> რაც შეეხება, როგორ იმ ღერძი
შეწონილი, რეალურად თქვენ

725
00:34:43,090 --> 00:34:46,745
დახარჯავს ყველაზე თქვენი დრო მიღების
რამ მუშაობა, რომ აღარაფერი ვთქვათ სწორად.

726
00:34:46,745 --> 00:34:49,120
და ასე სისწორის ტენდენცია
გაანგარიშება ყველაზე, როგორც

727
00:34:49,120 --> 00:34:51,360
ამ multiplicative ფაქტორი სამი.

728
00:34:51,360 --> 00:34:54,659
დიზაინი ასევე მნიშვნელოვანია, მაგრამ
ის, რომ თქვენ არ არის აუცილებელი

729
00:34:54,659 --> 00:34:58,220
ატარებენ ყველა იმ საათი
ცდილობს რამ უბრალოდ მუშაობა.

730
00:34:58,220 --> 00:35:00,019
>> ასე რომ, ეს შეწონილი
ცოტა უფრო მსუბუქად.

731
00:35:00,019 --> 00:35:01,560
და მაშინ style შეწონილი მაინც.

732
00:35:01,560 --> 00:35:03,710
მიუხედავად იმისა, რომ არანაკლებ
მნიშვნელოვანი ფუნდამენტურად,

733
00:35:03,710 --> 00:35:05,990
ეს, უბრალოდ, ალბათ,
მარტივი რამ უნდა გააკეთოს, მარჯვენა

734
00:35:05,990 --> 00:35:08,440
ლიმიტირებით მაგალითები ჩვენ
ამის ლექცია და სექციაში,

735
00:35:08,440 --> 00:35:11,080
რამ ლამაზად
indented, და აღნიშნა,

736
00:35:11,080 --> 00:35:14,320
და სხვ შორის არის იოლი
რამ უნდა გააკეთოს და მიიღოს უფლება.

737
00:35:14,320 --> 00:35:16,960
ასე რომ, როგორც ასეთი, გააცნობიეროს,
რომ ეს არის რაოდენობა

738
00:35:16,960 --> 00:35:19,000
რომლებიც შედარებით ადვილად დაჯექი.

739
00:35:19,000 --> 00:35:22,360
>> და ახლა სიტყვა
ამას აკადემიური პატიოსნება.

740
00:35:22,360 --> 00:35:25,150
ასე რომ პოსტი რა თქმა უნდა,
სილაბუსი, ნახავთ

741
00:35:25,150 --> 00:35:27,630
რომ რა თქმა უნდა აქვს საკმაოდ
ცოტა ენის გარშემო.

742
00:35:27,630 --> 00:35:31,380
და რა თქმა უნდა, იღებს საკითხი
აკადემიური პატიოსნება საკმაოდ სერიოზულად.

743
00:35:31,380 --> 00:35:33,450
>> ჩვენ გვყავს განსხვავება,
უკეთესი ან უარესი,

744
00:35:33,450 --> 00:35:36,570
რომელმაც იგზავნება ყოველი წლის მეტი
სტუდენტები დისციპლინარული ზომების

745
00:35:36,570 --> 00:35:39,670
ვიდრე ყველაზე ნებისმიერი სხვა
რა თქმა უნდა, რომ მე ვარ იცის.

746
00:35:39,670 --> 00:35:42,580
ეს არ არის აუცილებელი
მიუთითებს ის ფაქტი,

747
00:35:42,580 --> 00:35:46,340
რომ CS სტუდენტები, ან CS50 სტუდენტები, რომლებიც
ნაკლებად პატიოსანი, ვიდრე თქვენი თანაკლასელები.

748
00:35:46,340 --> 00:35:49,090
მაგრამ რეალობა, რომ ამ
მსოფლიოში, ელექტრონულად, ჩვენ უბრალოდ

749
00:35:49,090 --> 00:35:50,990
ტექნოლოგიურ
ნიშნავს გამოვლენის.

750
00:35:50,990 --> 00:35:53,360
>> მნიშვნელოვანია, რომ ჩვენს
სამართლიანობის მასშტაბით კლასის

751
00:35:53,360 --> 00:35:58,550
რასაც ჩვენ ვაკეთებთ, აღმოაჩინოს ეს, და დააყენებს
საკითხი, როდესაც ჩვენ ვხედავთ რამ.

752
00:35:58,550 --> 00:36:01,980
და მხოლოდ ხატავს სურათს, და მართლაც
დაეხმაროს რაღაც ამ რადიატორის,

753
00:36:01,980 --> 00:36:04,600
ეს არის ნომრები
სტუდენტები გასული 10 წლის განმავლობაში

754
00:36:04,600 --> 00:36:07,610
რომ უკვე ჩართული ზოგიერთი
ისეთი საკითხები, აკადემიური პატიოსნება,

755
00:36:07,610 --> 00:36:10,990
ზოგიერთი 32 სტუდენტი
შემოდგომაზე 2015, რომელიც

756
00:36:10,990 --> 00:36:13,760
უნდა ვთქვა, რომ ჩვენ არ მიიღოს
ამ საკითხზე ძალიან სერიოზულად.

757
00:36:13,760 --> 00:36:18,380
და, საბოლოო ჯამში, ეს ციფრები შესაქმნელად,
ყველაზე ცოტა ხნის წინ, დაახლოებით 3%, 4% ან ასე

758
00:36:18,380 --> 00:36:19,120
კლასში.

759
00:36:19,120 --> 00:36:25,220
>> ასე რომ, სუპერ უმრავლესობა სტუდენტები
როგორც ჩანს, რომ ხაზები ნათელი.

760
00:36:25,220 --> 00:36:27,940
მაგრამ არ გაქვთ ამ
იბადება, განსაკუთრებით გვიან

761
00:36:27,940 --> 00:36:32,080
ღამით, როდესაც იბრძვიან
ზოგიერთი გადაწყვეტა პრობლემა კომპლექტი,

762
00:36:32,080 --> 00:36:34,830
რომ არსებობს მექანიზმები
მისაღებად თავს უკეთ

763
00:36:34,830 --> 00:36:37,870
მხარდაჭერა, ვიდრე თქვენ შეიძლება
ვფიქრობ, თუნდაც ის, რომ საათი.

764
00:36:37,870 --> 00:36:40,514
გააცნობიეროს, რომ, როდესაც ჩვენ ვიღებთ
სტუდენტი წარდგინება, ჩვენ გადაკვეთა

765
00:36:40,514 --> 00:36:43,430
შედარების ყოველ წარდგენის წელს
წინააღმდეგ ყველა წარდგენის გასულ წელს,

766
00:36:43,430 --> 00:36:47,590
წინააღმდეგ ყველა წარდგენის 2007
და მას, ეძებს, ისევე,

767
00:36:47,590 --> 00:36:49,931
კოდი საცავებში შემოსული,
ფორუმი, სამუშაო ადგილები.

768
00:36:49,931 --> 00:36:51,806
ჩვენ აღვნიშნო, რომ ეს,
მართლაც, ყველა გულისთვის

769
00:36:51,806 --> 00:36:56,040
სრული გამჟღავნება, რომ თუ
ვინმეს შეგიძლიათ ის ონლაინ,

770
00:36:56,040 --> 00:36:57,880
რა თქმა უნდა, ასე რომ შეიძლება ჩვენ, რა თქმა უნდა.

771
00:36:57,880 --> 00:37:00,100
თუმცა, რეალურად, სული
რა თქმა უნდა, boils ქვემოთ

772
00:37:00,100 --> 00:37:01,650
ამ სტატიაზე სილაბუსში.

773
00:37:01,650 --> 00:37:03,670
ეს ნამდვილად არ არის, უბრალოდ, იყოს გონივრული.

774
00:37:03,670 --> 00:37:06,680
>> და თუ ჩვენ უნდა შეიმუშაოს, რომ
უბრალოდ ცოტა მეტი ენის,

775
00:37:06,680 --> 00:37:09,770
გააცნობიეროს, რომ არსი ყველა
მუშაობა, რომ თქვენ წარმოადგინოს ამ კურსის

776
00:37:09,770 --> 00:37:10,954
უნდა იყოს საკუთარი.

777
00:37:10,954 --> 00:37:13,870
მაგრამ შიგნით რომ, არსებობს რა თქმა უნდა
შესაძლებლობები, და წახალისება,

778
00:37:13,870 --> 00:37:17,300
და პედაგოგიური ღირებულების გთხოვოთ
others-- თავს, TFS, რომ CAS,

779
00:37:17,300 --> 00:37:20,760
TAs, და სხვა კლასის,
მხარდაჭერა, რომ აღარაფერი ვთქვათ მეგობრები

780
00:37:20,760 --> 00:37:23,547
და მცენარეები, რომლებმაც შეისწავლეს
CS და პროგრამირების ადრე.

781
00:37:23,547 --> 00:37:25,130
და ასე არ არის დახმარებას, რომ.

782
00:37:25,130 --> 00:37:28,180
და ზოგადი წესი thumb
არის ამ, როდესაც დახმარებას ითხოვენ,

783
00:37:28,180 --> 00:37:31,470
თქვენ შეიძლება ნახოთ თქვენი კოდი სხვები,
მაგრამ შეიძლება არ ნახოთ მათი.

784
00:37:31,470 --> 00:37:34,880
ასე რომ, თუ თქვენ იმ საათებში,
ან D დარბაზში, ან სადმე სხვაგან

785
00:37:34,880 --> 00:37:37,450
მუშაობს რამდენიმე ცალი კომპლექტი,
სამუშაო ერთად მეგობარს, რომელიც

786
00:37:37,450 --> 00:37:40,160
არის სრულიად ჯარიმა, იმ
დღის ბოლოს თქვენი სამუშაო

787
00:37:40,160 --> 00:37:43,034
საბოლოო ჯამში, ეკუთვნის თითოეულ
თქვენ შესაბამისად, და არ

788
00:37:43,034 --> 00:37:45,700
იქნება რამდენიმე ერთობლივი ძალისხმევა,
გარდა იმისა, რომ საბოლოო პროექტი, სადაც

789
00:37:45,700 --> 00:37:47,410
ეს დაშვებული და წახალისებული.

790
00:37:47,410 --> 00:37:49,830
>> გააცნობიეროს, რომ იმ შემთხვევაში, თუ
იბრძვიან რაღაც

791
00:37:49,830 --> 00:37:52,520
და თქვენი მეგობარი რაღაც
უნდა იყოს უკეთესი ამ მაშინ,

792
00:37:52,520 --> 00:37:55,130
ან უკეთესი, რომ პრობლემა, ვიდრე თქვენ,
ან ცოტა უფრო ადრე, ვიდრე თქვენ,

793
00:37:55,130 --> 00:37:57,330
ეს სრულიად გონივრული გახდეს
თქვენს მეგობარს და ამბობენ, hey,

794
00:37:57,330 --> 00:38:00,480
მიგაჩნიათ იბადება ეძებს ჩემს კოდი აქ,
მეხმარება რაშია რა ჩემი საკითხი არის?

795
00:38:00,480 --> 00:38:03,760
და, იმედია, ამ
ინტერესი პედაგოგიური ღირებულება

796
00:38:03,760 --> 00:38:07,040
რომ მეგობარი არ მხოლოდ
თქვათ, ამისათვის, არამედ,

797
00:38:07,040 --> 00:38:09,917
რას დაკარგული on line
6, ან რაღაც მსგავსი?

798
00:38:09,917 --> 00:38:12,000
მაგრამ გამოსავალი არ არის
იმ მეგობარს შემდეგი თქვენ

799
00:38:12,000 --> 00:38:15,617
სათქმელია, რა, ასევე, აქ, ნება მომეცით დახევის
ეს ყველაფერი, და ნახოთ ჩემი გამოსავალი თქვენთვის.

800
00:38:15,617 --> 00:38:16,450
ასე რომ, ხაზი.

801
00:38:16,450 --> 00:38:18,670
თქვენ თქვენი კოდი
სხვები, მაგრამ თქვენ არ შეუძლია

802
00:38:18,670 --> 00:38:22,350
ნახოთ მათი, დაექვემედებროს
შეზღუდვები, რა თქმა უნდა სილაბუსში.

803
00:38:22,350 --> 00:38:24,760
>> ასე რომ, გახსოვდეთ, ამ
ე.წ. სინანული პუნქტი

804
00:38:24,760 --> 00:38:27,560
რა თქმა უნდა, სილაბუსი, ისევე,
იმ შემთხვევაში, თუ თქვენ ჩაიდინოს ზოგიერთი აქტი, რომელიც

805
00:38:27,560 --> 00:38:30,476
არ არის გამართლებული, მაგრამ მოუტანს მას
ყურადღება კურსის ხელმძღვანელები

806
00:38:30,476 --> 00:38:34,240
72 საათის განმავლობაში, რა თქმა უნდა,
შეიძლება დააწესოს ადგილობრივი სანქციები,

807
00:38:34,240 --> 00:38:37,380
შეიძლება შეიცავდეს არადამაკმაყოფილებელი ან
ვერ კლასის მუშაობის წარმოდგენილი.

808
00:38:37,380 --> 00:38:41,410
მაგრამ რა თქმა უნდა არ ეხება
აქვს მნიშვნელობა, შემდგომი დისციპლინური,

809
00:38:41,410 --> 00:38:43,010
გარდა იმ შემთხვევებისა, განმეორებითი აქტებით.

810
00:38:43,010 --> 00:38:46,632
სხვა სიტყვებით, თუ თქვენ, რომ გარკვეული
სულელური, განსაკუთრებით გვიან ღამით, გადაწყვეტილების

811
00:38:46,632 --> 00:38:49,340
რომ მეორე დილით და ორი დღით
შემდეგ, თქვენ ვიღვიძებ და გააცნობიეროს,

812
00:38:49,340 --> 00:38:50,870
რა იყო მე ფიქრი?

813
00:38:50,870 --> 00:38:53,890
თქვენ ამ CS50 გაქვთ outlet
აფიქსირებს, რომ პრობლემა

814
00:38:53,890 --> 00:38:57,170
და ფლობს მდე, ასე, რომ ჩვენ
თქვენ დაგხვდებათ შუა და გარიგება

815
00:38:57,170 --> 00:39:01,500
მას ამ საკითხზე, რომელიც, როგორც
საგანმანათლებლო და მნიშვნელოვანი თქვენთვის,

816
00:39:01,500 --> 00:39:04,200
მაგრამ მაინც სადამსჯელო რამდენიმე გზა.

817
00:39:04,200 --> 00:39:08,590
და ახლა, მიიღოს პირას off, ეს.

818
00:39:08,590 --> 00:39:10,570
>> [ვიდეო აღწარმოების]

819
00:39:10,570 --> 00:39:13,540
>> [მუსიკის დაკვრა]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END აღწარმოების]

822
00:39:58,866 --> 00:40:00,490
დევიდ ჯ Malan: ყველა უფლება, ჩვენ უკან.

823
00:40:00,490 --> 00:40:03,680
და ახლა ჩვენ შევხედოთ ერთი
პირველი ჩვენი რეალური სამყაროს დომენები

824
00:40:03,680 --> 00:40:08,720
CS50, ხელოვნების კრიპტოგრაფიის,
ხელოვნების გაგზავნის და მიღების

825
00:40:08,720 --> 00:40:11,840
საიდუმლო შეტყობინებები, დაშიფრული
შეტყობინებები თუ გნებავთ,

826
00:40:11,840 --> 00:40:17,060
რომელიც შეიძლება მხოლოდ გაშიფრა, თუ თქვენ გაქვთ
ზოგიერთი ძირითადი ნივთიერება, რომელიც გამომგზავნი

827
00:40:17,060 --> 00:40:18,030
როგორც.

828
00:40:18,030 --> 00:40:22,120
ასე რომ მოტივაცია ამ მივიღებთ
შევხედოთ, ეს ისაა,

829
00:40:22,120 --> 00:40:26,750
რომელიც მაგალითია
საიდუმლო დეკოდერი ბეჭედი, რომელიც

830
00:40:26,750 --> 00:40:34,042
შეიძლება გამოყენებულ იქნას იმისათვის, რომ გაერკვნენ
რა საიდუმლო გაგზავნა რეალურად არის.

831
00:40:34,042 --> 00:40:35,750
ფაქტობრივად, უკან
დღეს კლასის სკოლა,

832
00:40:35,750 --> 00:40:38,787
თუ თქვენ ოდესმე გაუგზავნა საიდუმლო შეტყობინებები
ზოგიერთ მეგობარს ან რამდენიმე crush კლასში,

833
00:40:38,787 --> 00:40:40,620
ალბათ ფიქრობდა,
თქვენ რომ ჭკვიანი

834
00:40:40,620 --> 00:40:46,530
მიერ თქვენი ნაჭერი ქაღალდი იცვლება,
მოსწონს, რომ B და B C, და C D,

835
00:40:46,530 --> 00:40:47,590
და ასე შემდეგ.

836
00:40:47,590 --> 00:40:50,300
მაგრამ თქვენ რეალურად დაშიფრვა
თქვენი ინფორმაცია, მაშინაც კი,

837
00:40:50,300 --> 00:40:53,300
თუ ეს იყო პატარა უმნიშვნელო, არ იყო
რომ მძიმე პედაგოგი, გააცნობიეროს,

838
00:40:53,300 --> 00:40:55,675
ასევე, თუ თქვენ მხოლოდ შეცვლის
ბ A და C B,

839
00:40:55,675 --> 00:40:57,550
თქვენ გაერკვნენ
რა გზავნილი იყო,

840
00:40:57,550 --> 00:40:59,700
მაგრამ თქვენ იყავით დაშიფრვის ინფორმაცია.

841
00:40:59,700 --> 00:41:03,420
>> თქვენ უბრალოდ აკეთებს ამას
უბრალოდ, ჰგავს Ralphie აქ

842
00:41:03,420 --> 00:41:07,934
ცნობილი ფილმი, რომელიც თამაშობს
საკმაოდ ბევრი რეკლამა nauseum ყოველ ზამთარს.

843
00:41:07,934 --> 00:41:08,600
[ვიდეო აღწარმოების]

844
00:41:08,600 --> 00:41:11,180
-იქნება ეს ცნობილია, რომ ყველა
რალფ პარკერი წინამდებარე

845
00:41:11,180 --> 00:41:14,070
დაინიშნა წევრი პატარა
Orphan Annie საიდუმლო წრე

846
00:41:14,070 --> 00:41:17,700
და მას უფლება აქვს ყველა პატივით
და სარგებელი ხდება მასთან.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, პატარა ობოლი Annie,
counter ხელმოწერილი Pierre Andre, მელნის.

848
00:41:24,340 --> 00:41:27,160
პატივით და სარგებელს,
უკვე ასაკში ცხრა.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [ყვირილი]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-მოდი.

853
00:41:34,250 --> 00:41:35,210
მოდით კიდევ იგი.

854
00:41:35,210 --> 00:41:39,530
მე არ გვჭირდება ყველა რომ ჯაზის
შესახებ კონტრაბანდისტები და მეკობრეები.

855
00:41:39,530 --> 00:41:41,660
>> -მოუსმინეთ ხვალ ღამე
დადების თავგადასავალი

856
00:41:41,660 --> 00:41:43,880
შავი მეკობრე გემი.

857
00:41:43,880 --> 00:41:46,650
ახლა, დროა
Annie საიდუმლო გაგზავნა

858
00:41:46,650 --> 00:41:49,840
თქვენთვის წევრები საიდუმლო წრე.

859
00:41:49,840 --> 00:41:53,570
გახსოვდეთ, ბავშვები, მხოლოდ წევრების
Annie საიდუმლო წრე

860
00:41:53,570 --> 00:41:56,140
შეიძლება decode Annie საიდუმლო გაგზავნა.

861
00:41:56,140 --> 00:42:00,340
>> გახსოვდეთ, Annie დამოკიდებულია თქვენ.

862
00:42:00,340 --> 00:42:02,880
უცნობია თქვენი ქინძისთავები B2.

863
00:42:02,880 --> 00:42:05,230
აქ არის გზავნილი.

864
00:42:05,230 --> 00:42:06,090
12 11--

865
00:42:06,090 --> 00:42:10,250
>> მე ვარ, ჩემი პირველი საიდუმლო შეხვედრა.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre იყო დიდი ხმა შეძლებენ.

868
00:42:15,780 --> 00:42:19,000
მე ვერ გეტყვით, რომ ამაღამ
გზავნილი იყო მართლაც მნიშვნელოვანია.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, ეს არის ის გაგზავნა
Annie თავად.

870
00:42:22,694 --> 00:42:23,860
გახსოვდეთ, არ ვუთხრა ვინმეს.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 წამის შემდეგ, მე მხოლოდ
სახლში ოთახი, სადაც ბიჭი ცხრა

873
00:42:32,930 --> 00:42:37,040
შეიძლება იჯდეს კონფიდენციალურობა და decode.

874
00:42:37,040 --> 00:42:39,730
აი, B!

875
00:42:39,730 --> 00:42:42,360
მივედი შემდეგ, E.

876
00:42:42,360 --> 00:42:44,520
>> პირველი სიტყვა არის იყოს.

877
00:42:44,520 --> 00:42:49,032
S, ის მოდიოდა ადვილი არის, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -Oh, მოდის, Ralphie, მე უნდა წავიდე!

879
00:42:51,733 --> 00:42:53,688
>> -I'll იქნება ქვემოთ, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee whiz!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, რა თქმა უნდა, რომელთა მიზანია, რა თქმა უნდა, თუ რა?

883
00:43:04,060 --> 00:43:05,970
რა იყო პატარა ობოლი
Annie ცდილობს ამბობენ?

884
00:43:05,970 --> 00:43:07,264
რა თქმა უნდა, თუ რა?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, ენდი აქვს
წავიდეთ, გთხოვთ, გამოვა?

886
00:43:09,634 --> 00:43:10,480
>> -ყველა უფლება, Ma!

887
00:43:10,480 --> 00:43:12,880
მე ვიქნები უფლება out!

888
00:43:12,880 --> 00:43:14,550
>> -I იყო უახლოვდება ახლა.

889
00:43:14,550 --> 00:43:16,620
დაძაბულობა იყო საშინელი.

890
00:43:16,620 --> 00:43:17,720
რა იყო ეს?

891
00:43:17,720 --> 00:43:20,170
ბედი პლანეტა
შეიძლება სასწორზე დევს.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
ენდი gotta წავიდეთ!

894
00:43:23,170 --> 00:43:26,890
>> -I'll Be უფლება, ამისთვის ღაღადებდეს ხმამაღლა!

895
00:43:26,890 --> 00:43:32,680
>> შეიძლება ითქვას, რომ იქ, ჩემი თითების გაფრინდა, ჩემი აზრით,
იყო ფოლადის ხაფანგში, ყველა ფორე წვას.

896
00:43:32,680 --> 00:43:37,198
ეს იყო თითქმის ნათელია, დიახ, დიახ, დიახ.

897
00:43:37,198 --> 00:43:43,091
>> -დარწმუნდით დალევა თქვენი Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Crummy კომერციული?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
ძაღლიშვილია.

903
00:43:54,227 --> 00:43:54,810
[END აღწარმოების]

904
00:43:54,810 --> 00:43:57,390
დევიდ ჯ Malan: OK, ასე რომ,
ეს იყო ძალიან დიდი გზა

905
00:43:57,390 --> 00:44:00,660
შემოღების კრიპტოგრაფიის,
და ასევე Ovaltine.

906
00:44:00,660 --> 00:44:04,470
ფაქტობრივად, ეს ძველი რეკლამა
აქ, რატომ არის Ovaltine იმდენად კარგი?

907
00:44:04,470 --> 00:44:09,470
ეს არის კონცენტრირებული მოპოვების მწიფე
ქერის ალაოს, სუფთა ნაღების ძროხის ის რძე,

908
00:44:09,470 --> 00:44:14,360
და სპეციალურად მომზადებული კაკაო, ერთად
ბუნებრივი ფოსფატიდები და ვიტამინები.

909
00:44:14,360 --> 00:44:18,240
ეს კიდევ უფრო გამაგრებული
დამატებითი ვიტამინები B და D, yum.

910
00:44:18,240 --> 00:44:21,600
და თქვენ შეგიძლიათ მიიღოთ ეს, როგორც ჩანს,
Amazon, როგორც ჩვენ აქ.

911
00:44:21,600 --> 00:44:24,810
>> მაგრამ მოტივაცია აქ იყო
დანერგვა კრიპტოგრაფიის, კონკრეტულად

912
00:44:24,810 --> 00:44:28,340
ტიპის კრიპტოგრაფიის ცნობილია
როგორც საიდუმლო გასაღები კრიპტოგრაფიის.

913
00:44:28,340 --> 00:44:34,284
და როგორც სახელი ვარაუდობს, მთელი
უსაფრთხოების საიდუმლო გასაღები Crypto სისტემა,

914
00:44:34,284 --> 00:44:36,200
თუ თქვენ, მეთოდოლოგია
მხოლოდ scrambling

915
00:44:36,200 --> 00:44:40,960
ინფორმაცია ორ ადამიანს შორის, ის არის, რომ
მხოლოდ გამგზავნი და მხოლოდ მიმღები

916
00:44:40,960 --> 00:44:46,980
ვიცი საიდუმლო key-- გარკვეული მნიშვნელობა, გარკვეული
საიდუმლო ფრაზა, რაღაც საიდუმლო ნომერი, რომელიც

917
00:44:46,980 --> 00:44:50,660
მათ საშუალებას აძლევს ორივე დაშიფვრა
და გაშიფვრა ინფორმაცია.

918
00:44:50,660 --> 00:44:53,470
და კრიპტოგრაფიის, მართლაც,
მხოლოდ ამ კვირაში 0.

919
00:44:53,470 --> 00:44:56,715
>> ეს პრობლემა, იქ, სადაც საშუალებებით,
როგორც ფაქტობრივი გაგზავნა in English

920
00:44:56,715 --> 00:44:59,340
ან რასაც ენაზე, რომ თქვენ
გსურთ გაუგზავნოთ ვინმე კლასში,

921
00:44:59,340 --> 00:45:00,580
ან მასშტაბით ინტერნეტით.

922
00:45:00,580 --> 00:45:03,840
არსებობს გარკვეული გამომუშავება, რომელიც აპირებს
უნდა იყოს scrambled გაგზავნა, რომ თქვენ

923
00:45:03,840 --> 00:45:05,250
მიმღები მიიღებენ.

924
00:45:05,250 --> 00:45:07,405
და მაშინაც კი, თუ ვინმე
შუა იღებს ძალიან,

925
00:45:07,405 --> 00:45:09,780
თქვენ არ გვინდა, რომ მათ
აუცილებლად შეძლებს გაშიფვრა,

926
00:45:09,780 --> 00:45:12,840
იმიტომ, რომ შიგნით ამ
შავი ყუთი, ან ალგორითმი,

927
00:45:12,840 --> 00:45:17,650
არის რაღაც მექანიზმი, ზოგიერთი ეტაპობრივად
ინსტრუქციები, აღების, რომ შეყვანის

928
00:45:17,650 --> 00:45:20,710
და კონვერტიზაცია
გამომავალი, და იმედია უსაფრთხო გზა.

929
00:45:20,710 --> 00:45:23,640
>> და, ფაქტობრივად, არსებობს გარკვეული
ლექსიკა ამ სამყაროში ასეთია.

930
00:45:23,640 --> 00:45:26,100
ძირითადი ტექსტი არის სიტყვა
კომპიუტერული მეცნიერი იქნებოდა

931
00:45:26,100 --> 00:45:28,449
გამოიყენოთ აღწერს input
გაგზავნა, როგორიცაა ინგლისური

932
00:45:28,449 --> 00:45:31,240
ან რა ენაზე თქვენ რეალურად
გსურთ გაუგზავნოთ რამდენიმე სხვა ადამიანის.

933
00:45:31,240 --> 00:45:35,450
და მაშინ ciphertext არის scramble
რომ enciphered, ან დაშიფრული,

934
00:45:35,450 --> 00:45:36,520
მობილური შესახებ.

935
00:45:36,520 --> 00:45:38,750
>> მაგრამ არსებობს ერთი ნივთიერება აქ.

936
00:45:38,750 --> 00:45:43,200
არსებობს ერთი შეყვანის
საიდუმლო გასაღები კრიპტოგრაფიის.

937
00:45:43,200 --> 00:45:45,200
და ეს არის გასაღები თავად,
რომელიც, ზოგადად,

938
00:45:45,200 --> 00:45:48,930
როგორც ვნახავთ, ნომერი, ან
წერილი, ან სიტყვა, რაც

939
00:45:48,930 --> 00:45:51,980
ალგორითმი ეს არის რეალურად ელის.

940
00:45:51,980 --> 00:45:53,870
>> და როგორ გაშიფვრა ინფორმაცია?

941
00:45:53,870 --> 00:45:55,110
როგორ ფიქრობთ, unscramble ეს?

942
00:45:55,110 --> 00:45:57,950
ისე, უბრალოდ გადახედოს
მასალები და საშუალებებით.

943
00:45:57,950 --> 00:46:00,900
>> სხვა სიტყვებით, კიდევ ვინმე
იღებს თქვენი დაშიფრული გაგზავნა,

944
00:46:00,900 --> 00:46:03,740
იგი უბრალოდ
უნდა იცოდეს, რომ იგივე გასაღები.

945
00:46:03,740 --> 00:46:05,700
მათ მიიღეს ciphertext.

946
00:46:05,700 --> 00:46:09,530
და ჩართვის იმ ორ
პორტები შიფრის სისტემა,

947
00:46:09,530 --> 00:46:14,260
ალგორითმი, ამ შავი ყუთი, გარეთ
უნდა მოვიდეს ორიგინალური plaintext.

948
00:46:14,260 --> 00:46:17,830
და ისე, რომ ძალიან მაღალი დონის
ხედი რა კრიპტოგრაფიის არის რეალურად

949
00:46:17,830 --> 00:46:18,590
ყველაფერი.

950
00:46:18,590 --> 00:46:20,030
>> მოდით იქ.

951
00:46:20,030 --> 00:46:22,700
მოდით ახლა შევხედოთ ქვეშ
hood, რაღაც

952
00:46:22,700 --> 00:46:26,000
ჩვენ უკვე აღების გაცემული
გასულ კვირას, და ამ სხდომაზე

953
00:46:26,000 --> 00:46:27,629
აქ სიმებიანი.

954
00:46:27,629 --> 00:46:30,295
სიმებიანი ბოლოს დღეს
მხოლოდ თანმიმდევრობა სიმბოლო.

955
00:46:30,295 --> 00:46:33,610
>> ეს შეიძლება იყოს მშვენიერია, ან
მიესალმები Zamyla, ან რასაც.

956
00:46:33,610 --> 00:46:37,050
მაგრამ რას ნიშნავს ეს, რომ
იყოს თანმიმდევრობა გმირები?

957
00:46:37,050 --> 00:46:41,520
ფაქტია, რომ CS50 ბიბლიოთეკა აძლევს
ჩვენს მონაცემთა ტიპის სიმებიანი.

958
00:46:41,520 --> 00:46:45,140
>> მაგრამ იქ არ
ასეთი რამ, როგორც სიმებიანი C.

959
00:46:45,140 --> 00:46:49,450
ეს ნამდვილად არ არის უბრალოდ თანმიმდევრობა
ხასიათი, ხასიათი, ხასიათი,

960
00:46:49,450 --> 00:46:52,180
ხასიათი, უკან, უკან,
უკან, უკან, დაბრუნება შიგნით

961
00:46:52,180 --> 00:46:54,650
თქვენი კომპიუტერის მეხსიერების, ან RAM.

962
00:46:54,650 --> 00:46:58,940
და ჩვენ შევხედოთ სიღრმეში, რომ
მომავალში, როდესაც ჩვენ შევხედოთ მეხსიერების თავად,

963
00:46:58,940 --> 00:47:02,030
და გამოყენების, და
საფრთხეები, რომლებიც ჩართულნი.

964
00:47:02,030 --> 00:47:04,100
>> მაგრამ მოდით განიხილოს სიმებიანი Zamyla.

965
00:47:04,100 --> 00:47:07,480
ასე რომ მხოლოდ სახელი
ადამიანის აქ, Zamyla,

966
00:47:07,480 --> 00:47:12,030
რომ არის თანმიმდევრობა
გმირები, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
ახლა მოდით ვივარაუდოთ, რომ Zamyla სახელი
მიმდინარეობს ინახება შიგნით კომპიუტერი

968
00:47:16,020 --> 00:47:16,880
პროგრამა.

969
00:47:16,880 --> 00:47:20,830
>> ისე, ეს ლოგიკურია, რომ ჩვენ უნდა
შეძლებს შევხედოთ იმ გმირები

970
00:47:20,830 --> 00:47:21,590
ინდივიდუალურად.

971
00:47:21,590 --> 00:47:24,710
ასე რომ მე უბრალოდ აპირებს მოუტანს პატარა
ყუთი გარშემო Zamyla სახელი აქ.

972
00:47:24,710 --> 00:47:31,580
და ეს არის ამ შემთხვევაში C, რომ როდესაც თქვენ
სიმებიანი, როგორც Zamyla-- და შესაძლოა

973
00:47:31,580 --> 00:47:34,940
რომ სიმებიანი დადგა უკან
ფუნქცია, როგორიცაა მიიღოს სიმებიანი,

974
00:47:34,940 --> 00:47:38,540
თქვენ შეგიძლიათ რეალურად მანიპულირება
ეს ხასიათი ხასიათი.

975
00:47:38,540 --> 00:47:42,070
>> ახლა, ეს არის გერმანე, რომ
საუბრის დროს იმიტომ, რომ

976
00:47:42,070 --> 00:47:46,420
კრიპტოგრაფიის თუ თქვენ გსურთ შეცვალოთ
B, და B C და C, D,

977
00:47:46,420 --> 00:47:49,650
და ა.შ., თქვენ უნდა შეეძლოს
შევხედოთ ინდივიდუალური გმირები

978
00:47:49,650 --> 00:47:50,190
სიმებიანი.

979
00:47:50,190 --> 00:47:52,695
თქვენ უნდა იყოს შეუძლია შეცვალოს
რომ Z რაღაც, ა

980
00:47:52,695 --> 00:47:55,280
რაღაც, M, რათა
რაღაც, და ასე შემდეგ.

981
00:47:55,280 --> 00:47:58,000
ასე რომ, ჩვენ გვჭირდება გზა,
პროგრამულად, ასე რომ,

982
00:47:58,000 --> 00:48:03,020
ვთქვათ, C შეძლებს შეცვალოს
და შევხედოთ ინდივიდუალური წერილები.

983
00:48:03,020 --> 00:48:05,690
და ჩვენ შეგვიძლია გავაკეთოთ ეს შემდეგნაირად.

984
00:48:05,690 --> 00:48:08,340
>> ნება მომეცით წავიდეთ უხელმძღვანელებს უკან CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
და ნება მომეცით წავიდეთ წინ
და შექმნა ახალი ფაილი

986
00:48:11,130 --> 00:48:16,134
რომ მე მოვუწოდებ ამ დროს string0,
როგორც ჩვენი პირველი მაგალითია, dot გ.

987
00:48:16,134 --> 00:48:18,300
და მე ვაპირებ წავიდეთ წინ
და Whip it up ასეთია.

988
00:48:18,300 --> 00:48:22,870
>> ასე შეიცავს CS50.h, და
მაშინ მოიცავს სტანდარტული io.h,

989
00:48:22,870 --> 00:48:25,990
რომელიც მე თითქმის ყოველთვის აპირებს
გამოყენებით ჩემი პროგრამები, მინიმუმ

990
00:48:25,990 --> 00:48:26,780
თავდაპირველად.

991
00:48:26,780 --> 00:48:32,180
int ძირითადი ბათილად, და მაშინ აქ ვარ
აპირებს ამის strings იღებს მიიღოს სიმებიანი.

992
00:48:32,180 --> 00:48:35,260
და შემდეგ მე ვაპირებ
წავიდეთ წინ და ამის გაკეთება.

993
00:48:35,260 --> 00:48:37,460
მინდა წავიდეთ წინ
და, როგორც საღი აზრის შემოწმება,

994
00:48:37,460 --> 00:48:43,607
უბრალოდ, ვამბობთ, hello, პროცენტს s,
ნახევრად მსხვილი ნაწლავის, რაც string 0.

995
00:48:43,607 --> 00:48:44,690
უკაცრავად, რა გავაკეთო აქ?

996
00:48:44,690 --> 00:48:45,930
ოჰ, მე არ შეაერთედ ის.

997
00:48:45,930 --> 00:48:48,120
ასე რომ გაკვეთილი, რომელიც
არ იყო გამიზნული.

998
00:48:48,120 --> 00:48:52,480
>> ასე რომ, შეცდომა, მეტ პროცენტს
კონვერტაციის ვიდრე მონაცემების არგუმენტები.

999
00:48:52,480 --> 00:48:54,940
და ეს არის, სადაც,
ონლაინ -7 ბლოკის OK, ასე რომ მაქვს,

1000
00:48:54,940 --> 00:48:56,690
ციტირებით unquote, რომ
ჩემი სიმებიანი printf.

1001
00:48:56,690 --> 00:48:58,151
მაქვს პროცენტი ნიშანი.

1002
00:48:58,151 --> 00:48:59,650
მაგრამ მე დაკარგული მეორე არგუმენტი.

1003
00:48:59,650 --> 00:49:03,190
>> მე დაკარგული მძიმით s, რომელიც
მე უნდა წინა მაგალითები.

1004
00:49:03,190 --> 00:49:06,650
ასე რომ კარგი შესაძლებლობა დააფიქსიროს
კიდევ ერთი შეცდომა, შემთხვევით.

1005
00:49:06,650 --> 00:49:09,950
ახლა კი ნება მომეცით აწარმოებს
string0, ტიპის Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, hello Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> ასე რომ, ჩვენ აწარმოებს ამ სახის პროგრამა
რამდენიმე სხვადასხვა დროს არის.

1008
00:49:14,144 --> 00:49:16,310
მაგრამ მოდით რამე
ცოტა განსხვავებული ამ დროს.

1009
00:49:16,310 --> 00:49:19,450
იმის ნაცვლად, რომ უბრალოდ ბეჭდვა Zamyla ს
მთელი სახელი ერთად printf,

1010
00:49:19,450 --> 00:49:21,350
მოდით ეს ხასიათი ხასიათი.

1011
00:49:21,350 --> 00:49:22,700
>> მე ვაპირებ გამოიყენოს ამისთვის loop.

1012
00:49:22,700 --> 00:49:26,160
და მე ვაპირებ, რათა თავს
დათვლის ცვლადი, მოუწოდა i.

1013
00:49:26,160 --> 00:49:33,530
და მე ვაპირებ შენარჩუნება iterating, ასე რომ,
სანამ i ნაკლებია ხანგრძლივობა s.

1014
00:49:33,530 --> 00:49:35,930
>> თურმე, ჩვენ არ
ამისათვის ბოლო დროს,

1015
00:49:35,930 --> 00:49:39,100
რომ გ გააჩნია
ფუნქცია მოუწოდა Stirling.

1016
00:49:39,100 --> 00:49:42,690
უკან დღეს და ზოგადად,
ჯერ კიდევ მაშინ, როდესაც განხორციელების ფუნქციები,

1017
00:49:42,690 --> 00:49:45,405
ადამიანები ხშირად აირჩიოს ძალიან
ლაკონური სახელები, რომ სახის ხმა

1018
00:49:45,405 --> 00:49:48,280
როგორიცაა, რა გსურთ, მიუხედავად იმისა, რომ
დაკარგული რამდენიმე ხმოვანთა ან წერილებს.

1019
00:49:48,280 --> 00:49:50,660
ასე რომ, Stirling არის
ასახელებს ფუნქცია,

1020
00:49:50,660 --> 00:49:53,880
იღებს არგუმენტი შორის
ფრჩხილებში რომ უნდა იყოს სიმებიანი.

1021
00:49:53,880 --> 00:49:56,910
და ეს მხოლოდ ბრუნდება მთელი რიცხვი,
სიგრძეზე რომ სიმებიანი.

1022
00:49:56,910 --> 00:50:00,580
>> ასე რომ, ეს loop on line 7 აპირებს
დაიწყება დათვლის დროს i უდრის 0.

1023
00:50:00,580 --> 00:50:02,530
ის აპირებს, რომ იყოს
i თითოეულ iteration

1024
00:50:02,530 --> 00:50:04,350
1, როგორც ჩვენ უკვე აკეთებს რამდენჯერმე.

1025
00:50:04,350 --> 00:50:06,780
მაგრამ ის აპირებს, რომ მხოლოდ ამის
ამ წლამდე წერტილი,

1026
00:50:06,780 --> 00:50:09,660
როდესაც მე სიგრძე
სიმებიანი თავად.

1027
00:50:09,660 --> 00:50:14,520
>> ასე რომ, ეს არის გზა, საბოლოო ჯამში,
iterating მეტი სიმბოლო

1028
00:50:14,520 --> 00:50:17,430
სიმებიანი როგორც არის შემდეგნაირად.

1029
00:50:17,430 --> 00:50:20,670
მე ვაპირებ ამობეჭდოთ არ არის
მთელი ტექსტი, მაგრამ პროცენტი გ,

1030
00:50:20,670 --> 00:50:22,860
ერთჯერადი ხასიათი
მოყვება ახალი ხაზი.

1031
00:50:22,860 --> 00:50:24,880
და შემდეგ მე ვაპირებ
წავიდეთ წინ, და მე უნდა

1032
00:50:24,880 --> 00:50:29,080
ვთქვა, მინდა ბეჭდვა
შ ხასიათი s.

1033
00:50:29,080 --> 00:50:33,450
>> ასე რომ, თუ არის ცვლადი, რომელიც მიუთითებს,
ინდექსის სიმებიანი, სადაც

1034
00:50:33,450 --> 00:50:37,230
თქვენ ხართ ის, მე უნდა შეძლებს
ვთქვა, მომეცი შ ხასიათი s.

1035
00:50:37,230 --> 00:50:40,390
და გ აქვს გზა აკეთებს
ამ კვადრატულ ფრჩხილებში.

1036
00:50:40,390 --> 00:50:43,679
უბრალოდ აცხადებენ, რომ სახელი
ტექსტი, რომელიც ამ შემთხვევაში არის s.

1037
00:50:43,679 --> 00:50:46,970
მაშინ თქვენ იყენებთ კვადრატულ ფრჩხილებში, რომლებიც
როგორც წესი, მხოლოდ ზემოთ თქვენი Return ან შეიყვანეთ

1038
00:50:46,970 --> 00:50:48,110
გასაღები წლის კლავიატურის.

1039
00:50:48,110 --> 00:50:52,410
და მაშინ დააყენა ინდექსი
ხასიათი რომ გსურთ ბეჭდვა.

1040
00:50:52,410 --> 00:50:55,960
ასე რომ, ინდექსი იქნება
რიცხვი 0, ან 1, ან 2, ან 3 ან dot,

1041
00:50:55,960 --> 00:50:57,590
dot, dot, სხვა ნომერი.

1042
00:50:57,590 --> 00:51:00,920
>> და ჩვენ უზრუნველყოს, რომ ის აპირებს
სწორი ნომერი, იმიტომ, რომ მე

1043
00:51:00,920 --> 00:51:02,360
დაიწყება დათვლის დროს 0.

1044
00:51:02,360 --> 00:51:07,020
და იყოს, პირველი ხასიათი
სიმებიანი არის კონვენციის 0.

1045
00:51:07,020 --> 00:51:09,230
და მეორე გმირი bracket 1.

1046
00:51:09,230 --> 00:51:11,120
და მესამე გმირი არის bracket 2.

1047
00:51:11,120 --> 00:51:13,630
და თუ თქვენ არ გსურთ წასვლა ძალიან
შორს, მაგრამ ჩვენ არ იმიტომ, რომ ჩვენ

1048
00:51:13,630 --> 00:51:17,780
აპირებს მხოლოდ ნამატი i სანამ ეს
ტოლია სიგრძეზე სიმებიანი.

1049
00:51:17,780 --> 00:51:20,210
და სადაც წერტილი,
ამ loop შეწყდება.

1050
00:51:20,210 --> 00:51:25,550
>> ნება მომეცით, წავიდეთ წინ და შეინახოთ ამ
პროგრამა, და აწარმოებს მიიღოს string 0.

1051
00:51:25,550 --> 00:51:28,400
მაგრამ მე ბრალია.

1052
00:51:28,400 --> 00:51:35,390
მინიშნებით გამოცხადების ბიბლიოთეკის ფუნქცია
Stirling ტიპის ასეთი და such-- ახლა,

1053
00:51:35,390 --> 00:51:36,430
ეს ჟღერს ნაცნობი.

1054
00:51:36,430 --> 00:51:37,440
მაგრამ ეს არ არის printf.

1055
00:51:37,440 --> 00:51:38,540
და ეს არ მიიღოს სიმებიანი.

1056
00:51:38,540 --> 00:51:40,480
>> მე არ ხრახნიანი up
ანალოგიურად ამ დროს.

1057
00:51:40,480 --> 00:51:45,100
მაგრამ შეამჩნია ქვემოთ აქ ცოტა ქვემოთ
შემდგომი, მოიცავს header string.h,

1058
00:51:45,100 --> 00:51:47,210
მკაფიოდ უზრუნველყოფს
დეკლარაციის Stirling.

1059
00:51:47,210 --> 00:51:48,820
ასე რომ, არსებობს რეალურად ნახავ იქ.

1060
00:51:48,820 --> 00:51:51,670
>> და მართლაც, ეს გამოდის
არსებობს კიდევ ერთი header ფაილი

1061
00:51:51,670 --> 00:51:53,970
რომ ჩვენ არ გამოიყენება
კლასში არის, მაგრამ ეს

1062
00:51:53,970 --> 00:51:56,480
მათ შორის არსებული
თქვენ, სახელად string.h.

1063
00:51:56,480 --> 00:52:00,930
და რომ ფაილი, string.h
არის Stirling განაცხადა.

1064
00:52:00,930 --> 00:52:05,220
ნება მომეცით წავიდეთ წინ და
შენახვა, რათა string

1065
00:52:05,220 --> 00:52:08,040
0- ლამაზი, არ შეცდომის შეტყობინებები ამ დროს.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, და
მე უნდა დააჭიროთ,

1067
00:52:12,290 --> 00:52:16,710
სადაც წერტილი getstring აპირებს
დაბრუნებას სიმებიანი, ამას s.

1068
00:52:16,710 --> 00:52:21,890
მაშინ, რომ მარყუჟი აპირებს iterate
მეტი S გმირები ერთ დროს,

1069
00:52:21,890 --> 00:52:28,420
ბეჭდვა და მათ ერთ ხაზზე, რადგან
მქონდა, რომ წარმატებული ო ბოლოს.

1070
00:52:28,420 --> 00:52:34,530
ასე რომ მე ვერ გამომრჩეს, რომ წარმატებული
n, და შემდეგ უბრალოდ ბეჭდვა Zamyla ყველა

1071
00:52:34,530 --> 00:52:37,460
იმავე ხაზის,
ეფექტურად reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, რომელიც არ არის ყველა, რომ სასარგებლო.

1073
00:52:38,999 --> 00:52:40,540
მაგრამ ამ შემთხვევაში, მე არ კეთდება, რომ.

1074
00:52:40,540 --> 00:52:43,610
მე რეალურად დაბეჭდილი ერთი
ხასიათი დროს, ერთ ხაზზე,

1075
00:52:43,610 --> 00:52:45,400
ასე, რომ ჩვენ რეალურად ვხედავ ეფექტი.

1076
00:52:45,400 --> 00:52:46,900
>> მაგრამ უნდა აღვნიშნო ერთი რამ აქ.

1077
00:52:46,900 --> 00:52:48,930
და ჩვენ დავბრუნდებით
ეს მომავალი კვირის განმავლობაში.

1078
00:52:48,930 --> 00:52:52,650
გამოდის, რომ ამ
კოდი პოტენციურად buggy.

1079
00:52:52,650 --> 00:52:56,560
>> გამოდის, რომ მიიღოს სიმებიანი
და სხვა ფუნქციების ცხოვრებაში

1080
00:52:56,560 --> 00:53:00,280
არ არის აუცილებელი ყოველთვის
დაბრუნდება, თუ რა ველოდებით.

1081
00:53:00,280 --> 00:53:03,010
ჩვენ ვიცით, რომ კლასის ბოლო
დროის ამ, რომ მიიღოს

1082
00:53:03,010 --> 00:53:04,960
string უნდა დაბრუნდეს სიმებიანი.

1083
00:53:04,960 --> 00:53:09,900
მაგრამ რა, თუ მომხმარებლის ტიპის ასეთი
გრძელი სიტყვა, ან მე, ან ნარკვევი

1084
00:53:09,900 --> 00:53:13,010
რომ იქ უბრალოდ არ არის საკმარისი
მეხსიერება კომპიუტერის შეესაბამება მას.

1085
00:53:13,010 --> 00:53:15,410
>> მსგავსად, რა, თუ რამე მიდის
არასწორი ქვეშ hood?

1086
00:53:15,410 --> 00:53:18,400
ეს შეიძლება არ ხდება ხშირად,
მაგრამ ეს შეიძლება მოხდეს ერთხელ

1087
00:53:18,400 --> 00:53:21,520
ხოლო, ძალიან იშვიათად.

1088
00:53:21,520 --> 00:53:25,460
და გამოდის, რომ მიიღოს სიმებიანი
და ფუნქციები, როგორც ეს არ არის აუცილებელი

1089
00:53:25,460 --> 00:53:26,380
ყოველთვის დაბრუნდება strings.

1090
00:53:26,380 --> 00:53:30,680
შესაძლოა, მათ დააბრუნებს შეცდომა ღირებულება,
ზოგიერთი Sentinel ღირებულება, ასე ვთქვათ,

1091
00:53:30,680 --> 00:53:32,612
რომელიც მიუთითებს, რომ
რაღაც წავიდა არასწორია.

1092
00:53:32,612 --> 00:53:35,320
და თქვენ მხოლოდ ვიცი, რომ ეს
რომელმაც შეიტყო, რომ კლასი ახლა,

1093
00:53:35,320 --> 00:53:37,700
და რომელმაც წაიკითხა კიდევ რამდენიმე დოკუმენტაცია.

1094
00:53:37,700 --> 00:53:43,120
გამოდის, რომ მიიღოს სიმებიანი
შეუძლია დააბრუნოს მნიშვნელობა მოუწოდა null.

1095
00:53:43,120 --> 00:53:46,220
Null არის განსაკუთრებული მნიშვნელობა, რომ ჩვენ
დავბრუნდებით მომავალი კვირის განმავლობაში.

1096
00:53:46,220 --> 00:53:50,420
მაგრამ ახლა, უბრალოდ ვიცი, რომ თუ მინდა
უნდა იყოს ნამდვილად სათანადო წინსვლის

1097
00:53:50,420 --> 00:53:52,650
გამოყენებით Get სიმებიანი, მე
არ უნდა მხოლოდ მას,

1098
00:53:52,650 --> 00:53:56,870
და ბრმად გამოიყენოს მისი დაბრუნების ღირებულება,
ვაღიარებთ, რომ ეს ტექსტი.

1099
00:53:56,870 --> 00:53:59,420
>> მე პირველ რიგში, უნდა ითქვას,
hey, დაველოდოთ წუთში, მხოლოდ

1100
00:53:59,420 --> 00:54:03,380
გაგრძელება თუ არ თანაბარი
null, სადაც null, კიდევ ერთხელ,

1101
00:54:03,380 --> 00:54:04,660
არის რამოდენიმე განსაკუთრებული მნიშვნელობა.

1102
00:54:04,660 --> 00:54:07,770
და ეს არის ერთადერთი განსაკუთრებული მნიშვნელობა თქვენ
უნდა ფიქრი Get სიმებიანი.

1103
00:54:07,770 --> 00:54:10,900
მიიღოს სიმებიანი ან აპირებს
დაბრუნებას სიმებიანი ან null.

1104
00:54:10,900 --> 00:54:17,219
>> და ამ ძახილის წერტილი ტოლობის ნიშანი
მოგეხსენებათ, შესაძლოა, მათემატიკის კლასის

1105
00:54:17,219 --> 00:54:20,510
რომ თქვენ შეიძლება მიაპყროს თანაბარი ნიშანი
ხაზის მეშვეობით ეს მიუთითებს იმაზე, არ არის თანაბარი.

1106
00:54:20,510 --> 00:54:23,135
ეს არ არის ზოგადად ხასიათი
შეგიძლიათ ჩაწეროთ თქვენს კლავიატურაზე.

1107
00:54:23,135 --> 00:54:26,480
ასე რომ, ყველაზე პროგრამირების ენები,
როდესაც თქვენ მინდა ვთქვა, არ არის თანასწორი,

1108
00:54:26,480 --> 00:54:29,160
თქვენ იყენებთ ძახილის წერტილი,
სხვაგვარად ცნობილია როგორც bang.

1109
00:54:29,160 --> 00:54:33,180
ანუ, თქვენ ამბობთ bang ტოლია, რომელიც
იმას ნიშნავს, არ უდრის, ლოგიკურად.

1110
00:54:33,180 --> 00:54:38,060
ეს იგივეა, რომ არ არის დიდი
მეტი, ან ტოლია, ან ნაკლები

1111
00:54:38,060 --> 00:54:41,270
ან ტოლია კლავიშს
რომ ეს ყველაფერი ერთი სიმბოლო.

1112
00:54:41,270 --> 00:54:44,020
ასე რომ, რატომ, წარსულში მაგალითები,
თქვენ გააკეთა ღია bracket და შემდეგ

1113
00:54:44,020 --> 00:54:48,670
თანაბარი ნიშანი, რათა გააკეთოს
მეტია ან, ვთქვათ, ნაკლები.

1114
00:54:48,670 --> 00:54:49,910
>> ასე რომ, რა takeaway აქ?

1115
00:54:49,910 --> 00:54:53,880
ეს არის უბრალოდ გზა არის
შემოღების ეს სინტაქსი, ამ ფუნქციის,

1116
00:54:53,880 --> 00:54:57,390
iterating მეტი ინდივიდუალური
სიმბოლოების სიმებიანი.

1117
00:54:57,390 --> 00:55:00,260
და ისევე, როგორც იმ მოედანზე
ფრჩხილებში საშუალებას გაძლევთ მიიღონ მათ,

1118
00:55:00,260 --> 00:55:03,790
განიხილოს იმ კვადრატულ ფრჩხილებში, როგორც
ერთგვარი მან მიანიშნა ამ ფუძემდებლური

1119
00:55:03,790 --> 00:55:06,040
დიზაინი, რომლის ყოველ
ხასიათი შიგნით მისაღებად

1120
00:55:06,040 --> 00:55:10,180
არის სახის ჩარჩოში სადღაც ქვეშ
hood, თქვენი კომპიუტერის მეხსიერებაში.

1121
00:55:10,180 --> 00:55:12,340
>> მაგრამ მოდით ვარიანტი ამ.

1122
00:55:12,340 --> 00:55:14,880
გამოდის, რომ ამ
პროგრამა არის სწორი.

1123
00:55:14,880 --> 00:55:18,810
ასე რომ, ერთ CS50 ის ღერძი შეფასების
კოდი, ეს არის სწორი ახლა.

1124
00:55:18,810 --> 00:55:22,959
მით უმეტეს, რომ მე შემოწმება
null, ეს პროგრამა არასდროს არ უნდა მისაწოდებლად.

1125
00:55:22,959 --> 00:55:24,500
და მე ვიცი, რომ გამოცდილება.

1126
00:55:24,500 --> 00:55:28,040
მაგრამ იქ სხვა არაფერი, რომ
ჩვენ ნამდვილად შეგვიძლია წავიდეთ არასწორი აქ.

1127
00:55:28,040 --> 00:55:31,860
მაგრამ ეს არ არის ძალიან კარგად შემუშავებული,
იმიტომ, რომ მოდით დავუბრუნდეთ საფუძვლებს.

1128
00:55:31,860 --> 00:55:34,450
>> პირველი, principles--
რას ამისთვის მარყუჟის გაკეთება?

1129
00:55:34,450 --> 00:55:36,290
ამისთვის loop აკეთებს სამი რამ.

1130
00:55:36,290 --> 00:55:39,340
ეს ველში გარკვეული
მნიშვნელობა, თუ ვთხოვთ მას.

1131
00:55:39,340 --> 00:55:41,770
ის ამოწმებს მდგომარეობა.

1132
00:55:41,770 --> 00:55:45,380
და შემდეგ ყოველ
iteration, ყოველი ციკლის,

1133
00:55:45,380 --> 00:55:49,330
ეს increments ზოგიერთი
ღირებულება, ან ღირებულებებს, აქ.

1134
00:55:49,330 --> 00:55:50,600
>> ასე რომ, რას ნიშნავს ეს?

1135
00:55:50,600 --> 00:55:52,940
ჩვენ ინიციალიზაცია i 0.

1136
00:55:52,940 --> 00:55:58,610
ჩვენ შემოწმება და დარწმუნდით, რომ ნაკლებია
ხანგრძლივობა s, რომელიც Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
ასე რომ, რომელიც ნაკლებია, ვიდრე 6.

1138
00:55:59,900 --> 00:56:02,590
და, მართლაც, 0, 6-ზე ნაკლები.

1139
00:56:02,590 --> 00:56:05,580
>> ჩვენ ამობეჭდოთ Z დან Zamyla სახელი.

1140
00:56:05,580 --> 00:56:08,080
მაშინ ჩვენ ნამატი i 0-დან 1.

1141
00:56:08,080 --> 00:56:11,290
ჩვენ მაშინ შეამოწმეთ, არის 1 ნაკლები
ვიდრე სიგრძე s?

1142
00:56:11,290 --> 00:56:13,270
ხანგრძლივობა s 6.

1143
00:56:13,270 --> 00:56:13,950
დიახ, ის არის.

1144
00:56:13,950 --> 00:56:16,880
>> ასე რომ, ჩვენ ბეჭდვა in Zamyla სახელი, ZA.

1145
00:56:16,880 --> 00:56:20,090
ჩვენ ნამატი i 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
ჩვენ მაშინ შეამოწმეთ, არის 2-ზე ნაკლები
ხანგრძლივობა Zamyla სახელი.

1147
00:56:23,720 --> 00:56:25,380
6 ასე რომ 2 ნაკლებია, ვიდრე 6.

1148
00:56:25,380 --> 00:56:30,460
დიახ, მოდით ამობეჭდოთ ახლა M in
Zamyla სახელი, მესამე ხასიათი.

1149
00:56:30,460 --> 00:56:34,110
>> გასაღები აქ არის ის, რომ თითოეული
iteration ამბავი, მე შემოწმების,

1150
00:56:34,110 --> 00:56:37,810
არის მე ნაკლები სიგრძის Zamyla?

1151
00:56:37,810 --> 00:56:40,350
მაგრამ დაჭერა არის, რომ
Stirling არ არის საკუთრება.

1152
00:56:40,350 --> 00:56:43,100
იმ თქვენ, რომლებიც არ პროგრამირდება
ადრე Java ან სხვა ენებზე

1153
00:56:43,100 --> 00:56:46,310
ალბათ იცით, სიგრძეზე სიმებიანი
ქონება, მხოლოდ რამდენიმე წაკითხვის მხოლოდ ღირებულება.

1154
00:56:46,310 --> 00:56:50,220
>> In C, ამ შემთხვევაში, თუ ეს არის
ფუნქცია, რომელიც არის ფაქტიურად

1155
00:56:50,220 --> 00:56:53,520
დათვლის
სიმბოლოების Zamyla ყოველ ჯერზე

1156
00:56:53,520 --> 00:56:54,740
ჩვენ მოვუწოდებთ, რომ ფუნქცია.

1157
00:56:54,740 --> 00:56:58,500
ყოველ დროს, თქვენ ვთხოვთ კომპიუტერის გამოყენება
Stirling, ის აღების შევხედოთ Zamyla,

1158
00:56:58,500 --> 00:57:01,960
და განაცხადა, Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
და ის დააბრუნებს 6.

1160
00:57:02,962 --> 00:57:04,920
მომავალი დრო თქვენ მოვუწოდებთ
შიგნით რომ loop,

1161
00:57:04,920 --> 00:57:08,610
ის აპირებს, რომ შევხედოთ Zamyla
ერთხელ, ვთქვათ, Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
და ის აპირებს დაბრუნებას 6.

1163
00:57:10,320 --> 00:57:12,980
ასე რომ, რა სულელური ამ დიზაინი?

1164
00:57:12,980 --> 00:57:17,700
>> რატომ არის ჩემი კოდი არ არის 5 out of 5
დიზაინი ახლა, ასე ვთქვათ?

1165
00:57:17,700 --> 00:57:20,600
ისე, მე ითხოვს
კითხვა ზედმეტად.

1166
00:57:20,600 --> 00:57:23,030
მე ვაკეთებ მეტი მუშაობა, ვიდრე მე უნდა.

1167
00:57:23,030 --> 00:57:25,370
>> ასე რომ, მიუხედავად იმისა, რომ
პასუხი არის სწორი, მე ვარ

1168
00:57:25,370 --> 00:57:29,560
ეკითხება კომპიუტერი, რა არის
ხანგრძლივობა Zamyla ერთხელ,

1169
00:57:29,560 --> 00:57:31,380
და ისევ და ისევ და ისევ?

1170
00:57:31,380 --> 00:57:33,980
და რომ პასუხი
არასოდეს შეიცვლება.

1171
00:57:33,980 --> 00:57:35,900
ის ყოველთვის იქნება 6.

1172
00:57:35,900 --> 00:57:39,730
>> ასე რომ, უკეთესი, ვიდრე ეს
იქნება ეს მომდევნო ვერსია.

1173
00:57:39,730 --> 00:57:43,390
ნება მომეცით წავიდეთ წინ და ამას
ცალკე ფაილი სახელად string1.c,

1174
00:57:43,390 --> 00:57:44,990
უბრალოდ შეინახოს იგი ცალკე.

1175
00:57:44,990 --> 00:57:47,260
და აღმოჩნდება, რომ ამ საიტზე
loop, შეგიძლიათ რეალურად

1176
00:57:47,260 --> 00:57:50,210
განაცხადოს მრავალჯერადი ცვლადები ერთდროულად.

1177
00:57:50,210 --> 00:57:53,460
>> ამიტომ, მე ვაპირებ, რომ შევინარჩუნოთ i და დაადგინა, რომ 0.

1178
00:57:53,460 --> 00:57:56,190
მაგრამ მე ასევე აპირებს
რჩეულებში მძიმით, და ამბობენ,

1179
00:57:56,190 --> 00:58:01,050
მომეცი ცვლადში N, რომლის
მნიშვნელობა ტოლია სიმებიანი ხანგრძლივობა s.

1180
00:58:01,050 --> 00:58:09,410
და ახლა, გთხოვთ, ჩემი მდგომარეობა
ასე რომ, სანამ i ნაკლებია, ვიდრე n.

1181
00:58:09,410 --> 00:58:14,140
>> ასე რომ, ამ გზით, ლოგიკა
იდენტური დასასრულს დღეში.

1182
00:58:14,140 --> 00:58:18,280
მაგრამ მე დამახსოვრების
ღირებულება 6, ამ შემთხვევაში.

1183
00:58:18,280 --> 00:58:19,780
რა არის სიგრძე Zamyla სახელი?

1184
00:58:19,780 --> 00:58:20,860
და მე აყენებს მას n.

1185
00:58:20,860 --> 00:58:23,050
>> და მე მაინც შემოწმების
იმ პირობით, ყოველ ჯერზე.

1186
00:58:23,050 --> 00:58:24,300
0 არანაკლებ 6?

1187
00:58:24,300 --> 00:58:25,600
არის 1 არანაკლებ 6?

1188
00:58:25,600 --> 00:58:28,600
2 არანაკლებ 6 და ა.შ.?

1189
00:58:28,600 --> 00:58:31,914
>> მაგრამ მე არ ითხოვს კომპიუტერული
ისევ და ისევ, რა

1190
00:58:31,914 --> 00:58:33,080
ხანგრძლივობა Zamyla სახელი?

1191
00:58:33,080 --> 00:58:34,320
რა არის სიგრძეზე Zamyla სახელი?

1192
00:58:34,320 --> 00:58:35,986
რა არის სიგრძეზე ამ Zamyla სახელი?

1193
00:58:35,986 --> 00:58:40,440
მე ფაქტიურად ახსოვს, რომ პირველი და
მხოლოდ უპასუხოს ამ მეორე ცვლადი ო.

1194
00:58:40,440 --> 00:58:45,280
ასე რომ, ეს ახლა იქნება არა მხოლოდ
სწორი, არამედ კარგად შემუშავებული.

1195
00:58:45,280 --> 00:58:46,670
>> ახლა, რაც შეეხება სტილი?

1196
00:58:46,670 --> 00:58:48,866
მე სახელად ჩემი ცვლადები
კარგად, მე ვიტყოდი.

1197
00:58:48,866 --> 00:58:50,240
ისინი სუპერ ლაკონური ახლავე.

1198
00:58:50,240 --> 00:58:52,090
და რომ სრულიად ჯარიმა.

1199
00:58:52,090 --> 00:58:55,120
>> თუ თქვენ გაქვთ მხოლოდ ერთი
სიმებიანი პროგრამა,

1200
00:58:55,120 --> 00:58:56,860
თქვენ შესაძლოა, ასევე მოვუწოდებთ მას s სიმებიანი.

1201
00:58:56,860 --> 00:58:59,370
თუ თქვენ გაქვთ მხოლოდ ერთი ცვლადი
დათვლის პროგრამა,

1202
00:58:59,370 --> 00:59:00,710
თქვენ შესაძლოა, ასევე ეძახით i.

1203
00:59:00,710 --> 00:59:03,500
თუ თქვენ გაქვთ სიგრძე, n
super საერთო, ასევე.

1204
00:59:03,500 --> 00:59:05,800
მაგრამ მე არ გამოეხმაურა არც ჩემი კოდი.

1205
00:59:05,800 --> 00:59:09,200
>> მე არ შეატყობინა reader--
თუ არა, რომ ჩემი TF, ან TA,

1206
00:59:09,200 --> 00:59:12,460
ან უბრალოდ კოლეგა რა უნდა
უნდა მომხდარიყო ამ პროგრამაში.

1207
00:59:12,460 --> 00:59:15,760
და ასე მიიღოს კარგი სტილი,
ის, რაც მე მინდა ამის

1208
00:59:15,760 --> 00:59:24,580
არის ამ რაღაც
როგორიცაა ვთხოვთ მომხმარებელს შეყვანის.

1209
00:59:24,580 --> 00:59:26,670
და მე ვერ გადაწერა
ეს ნებისმიერი რაოდენობის გზები.

1210
00:59:26,670 --> 00:59:35,630
>> დარწმუნდით s-- დარწმუნდით მისაღებად
string დაბრუნდა სიმებიანი.

1211
00:59:35,630 --> 00:59:40,280
და მაშინ აქ და ეს არის ალბათ
ყველაზე მნიშვნელოვანი comment-- iterate

1212
00:59:40,280 --> 00:59:44,450
მეტი სიმბოლოების s ერთ დროს.

1213
00:59:44,450 --> 00:59:47,060
და მე ვერ გამოიყენოთ ნებისმიერი
არჩევანი ინგლისური ენის

1214
00:59:47,060 --> 00:59:49,650
აქ აღწერილია თითოეული
ამ მოცულობით კოდი.

1215
00:59:49,650 --> 00:59:52,740
>> გაითვალისწინეთ, რომ მე არ დააყენოს
კომენტარს ყველა ხაზი კოდი,

1216
00:59:52,740 --> 00:59:55,690
უბრალოდ, მათთვის საინტერესო
პირობა, პირობა, რომ

1217
00:59:55,690 --> 00:59:59,460
აქვს გარკვეული მნიშვნელობა, რომ მე შეიძლება
მინდა, რომ სუპერ ნათელი ვინმე

1218
00:59:59,460 --> 01:00:00,460
კითხულობს ჩემი კოდი.

1219
01:00:00,460 --> 01:00:02,920
და რატომ მოუწოდებს მიიღოს
string ვთხოვთ მომხმარებელს შეყვანის?

1220
01:00:02,920 --> 01:00:05,450
მიუხედავად იმისა, რომ ერთ-ერთი არ არის აუცილებელი
ყველა რომ აღწერითი.

1221
01:00:05,450 --> 01:00:09,340
მაგრამ ეს ხელს ვუთხრა ამბავი, რადგან
მეორე ხაზი ამბავი, დარწმუნდით

1222
01:00:09,340 --> 01:00:10,740
სიმებიანი დაბრუნდა სიმებიანი.

1223
01:00:10,740 --> 01:00:14,260
>> და მესამე ხაზი ამბავი,
გადაურბინოთ სიმბოლოების ერთი

1224
01:00:14,260 --> 01:00:15,380
დროულად.

1225
01:00:15,380 --> 01:00:17,920
და ახლა მხოლოდ კარგი ღონისძიება,
მე ვაპირებ წავიდეთ წინ და დაამატოთ

1226
01:00:17,920 --> 01:00:24,560
კიდევ ერთი კომენტარი, რომ მხოლოდ
ამბობს ბეჭდვითი i-th პერსონაჟი s.

1227
01:00:24,560 --> 01:00:26,520
ახლა, რა დაგიშავე
ბოლოს დღეს?

1228
01:00:26,520 --> 01:00:29,190
>> მე დასძინა ზოგიერთი English
სიტყვა სახით კომენტარი.

1229
01:00:29,190 --> 01:00:32,700
ირიბის slash სიმბოლო ნიშნავს, hey,
კომპიუტერული, რომ ეს არის ადამიანის,

1230
01:00:32,700 --> 01:00:33,820
არ არის თქვენთვის, კომპიუტერი.

1231
01:00:33,820 --> 01:00:35,119
ასე რომ, ისინი იგნორირებულია ლოგიკურად.

1232
01:00:35,119 --> 01:00:35,910
ისინი უბრალოდ არ არსებობს.

1233
01:00:35,910 --> 01:00:39,830
>> და, მართლაც, CS50 IDE აჩვენებს მათ, როგორც
ნაცრისფერი, როგორც სასარგებლო, მაგრამ არა ძირითადი

1234
01:00:39,830 --> 01:00:41,000
პროგრამა.

1235
01:00:41,000 --> 01:00:42,570
ყურადღება მიაქციეთ, რა შეგიძლიათ გააკეთოთ.

1236
01:00:42,570 --> 01:00:44,950
მიუხედავად იმისა, რომ თქვენ იცით, C
პროგრამირების თუ არა,

1237
01:00:44,950 --> 01:00:47,722
შეგიძლიათ უბრალოდ დგანან უკან ამ
პროგრამა, skim კომენტარი.

1238
01:00:47,722 --> 01:00:50,180
ჰკითხეთ მომხმარებლის input, დარწმუნდით
სიმებიანი დაბრუნდა სიმებიანი,

1239
01:00:50,180 --> 01:00:53,009
გადაურბინოთ სიმბოლოების s
ერთ დროს, ბეჭდვა ხასიათი

1240
01:00:53,009 --> 01:00:55,550
i-th პერსონაჟი s-- თქვენ არ
კი უნდა შევხედოთ კოდი

1241
01:00:55,550 --> 01:00:57,270
უნდა გვესმოდეს, რა ეს პროგრამა აკეთებს.

1242
01:00:57,270 --> 01:01:00,280
და, კიდევ უკეთესი, თუ თავს გამოიყურება
ამ პროგრამის ერთ-ორ კვირაში,

1243
01:01:00,280 --> 01:01:02,280
ან ერთი თვის, ან ერთი წლის განმავლობაში,
თქვენც არ აქვს

1244
01:01:02,280 --> 01:01:04,420
მიშტერებული კოდი,
ცდილობს გვახსოვს,

1245
01:01:04,420 --> 01:01:06,630
რა იყო მე ცდილობს გააკეთოს ეს კოდი?

1246
01:01:06,630 --> 01:01:07,770
>> თქვენ განუცხადა თავს.

1247
01:01:07,770 --> 01:01:11,660
შენ აღწერილი თავს,
და ზოგიერთი კოლეგის ან TA, ან TF.

1248
01:01:11,660 --> 01:01:14,860
ასე რომ, ეს ახლა იყოს
სწორი და კარგი დიზაინი,

1249
01:01:14,860 --> 01:01:18,210
და საბოლოო ჯამში, კარგი სტილი, ასევე.

1250
01:01:18,210 --> 01:01:19,990
ასე რომ შევინარჩუნოთ, რომ გონება.

1251
01:01:19,990 --> 01:01:22,200
>> ასე რომ ერთი სხვა
რაც მე ვაპირებ, რომ აქ

1252
01:01:22,200 --> 01:01:28,240
რომ ახლა, ზუსტად რა არის
მიმდინარეობს ქვეშ hood.

1253
01:01:28,240 --> 01:01:30,390
ასე რომ ეს ფუნქცია
C, და სხვა ენებზე,

1254
01:01:30,390 --> 01:01:33,010
მოუწოდა typecasting
რომ არც ირიბად

1255
01:01:33,010 --> 01:01:37,250
ან პირდაპირ გაძლევთ საშუალებას დააკონვერტიროთ
ერთი მონაცემები ტიპის სხვა.

1256
01:01:37,250 --> 01:01:39,800
ჩვენ უკვე საქმე ასე
რამდენადაც დღეს სტრიქონები.

1257
01:01:39,800 --> 01:01:41,250
>> და სიმები არიან გმირები.

1258
01:01:41,250 --> 01:01:44,910
მაგრამ გავიხსენოთ, კვირაში
0, რა გმირები?

1259
01:01:44,910 --> 01:01:49,334
გმირები არიან უბრალოდ აბსტრაქცია
თავზე ნომრებზე ათობითი ნომრები,

1260
01:01:49,334 --> 01:01:52,500
და ათობითი ნომრები მართლაც მხოლოდ
აბსტრაქცია თავზე ორობითი რიცხვი

1261
01:01:52,500 --> 01:01:53,720
როგორც ჩვენ განსაზღვრული იყო.

1262
01:01:53,720 --> 01:01:55,540
>> ასე რომ გმირები არიან ნომრები.

1263
01:01:55,540 --> 01:01:58,410
და ნომრები გმირები,
უბრალოდ დამოკიდებულია კონტექსტში.

1264
01:01:58,410 --> 01:02:01,250
და აღმოჩნდება, რომ შიგნით
კომპიუტერული პროგრამის,

1265
01:02:01,250 --> 01:02:06,830
შეგიძლიათ მიუთითოთ თუ გსურთ გამოიყურება
at ბიტი შიგნით რომ პროგრამა?

1266
01:02:06,830 --> 01:02:10,400
>> შეგახსენებთ, კვირაში 0, რომ ჩვენ გვქონდა
ASCII, რომელიც მხოლოდ ამ კოდექსით

1267
01:02:10,400 --> 01:02:11,620
რუკების წერილები ნომრები.

1268
01:02:11,620 --> 01:02:13,660
და ჩვენ ვთქვით, დედაქალაქში არის 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B არის 66, და სხვ.

1270
01:02:15,860 --> 01:02:20,500
>> და შეამჩნია, ჩვენ არსებითად სიმბოლო on
ზედა რიგის აქ, C მოვუწოდებთ მათ,

1271
01:02:20,500 --> 01:02:23,400
პერსონაჟი, და შემდეგ
ints მეორე ზედიზედ.

1272
01:02:23,400 --> 01:02:28,180
და აღმოჩნდება, რომ თქვენ შეგიძლიათ დააკონვერტიროთ
ჩაირთოს შორის, როგორც წესი.

1273
01:02:28,180 --> 01:02:30,042
და თუ ჩვენ გვინდა, რომ
შეგნებულად, ჩვენ

1274
01:02:30,042 --> 01:02:31,750
დაგვჭირდება დაძლევის
რაღაც მსგავსი.

1275
01:02:31,750 --> 01:02:33,590
>> ჩვენ დაგვჭირდება გარდაქმნას
ზედა შემთხვევაში შეამცირონ

1276
01:02:33,590 --> 01:02:35,330
შემთხვევაში, ან ქვედა ზედა შემთხვევაში.

1277
01:02:35,330 --> 01:02:38,000
და ეს თურმე არსებობს
რეალურად ნიმუში აქ

1278
01:02:38,000 --> 01:02:39,900
შეგვიძლია იკისროს რაღაც მომენტში.

1279
01:02:39,900 --> 01:02:44,120
მაგრამ მოდით შევხედოთ პირველი საათზე
მაგალითად ამით მკაფიოდ.

1280
01:02:44,120 --> 01:02:46,340
>> მე ვაპირებ დაბრუნდეს CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
მე ვაპირებ, რომ შევქმნათ
ფაილი მოუწოდა ASCII 0.c.

1282
01:02:50,640 --> 01:02:55,960
და მე ვაპირებ წავიდეთ წინ და დაამატოთ ჩემი
სტანდარტული io.h ზედა, int ძირითადი ბათილად

1283
01:02:55,960 --> 01:02:57,370
ზედა ჩემი ფუნქცია.

1284
01:02:57,370 --> 01:03:02,700
და მაშინ მე უბრალოდ აპირებს
ასეთია ამისთვის მარყუჟის i შეადგენს,

1285
01:03:02,700 --> 01:03:04,610
ვთქვათ, 65.

1286
01:03:04,610 --> 01:03:10,460
>> და მერე იქნება ნაკლები
65, პლუს 26 ასო ანბანი.

1287
01:03:10,460 --> 01:03:12,640
ასე რომ, მე ნება კომპიუტერული
მათემატიკის ჩემთვის არსებობს.

1288
01:03:12,640 --> 01:03:15,100
და შემდეგ შიგნით ამ მარყუჟის,
რა ვარ მე აპირებს ბეჭდვა?

1289
01:03:15,100 --> 01:03:19,230
>> % C% i წარმატებული ო.

1290
01:03:19,230 --> 01:03:21,290
და ახლა მინდა შეაერთედ ორი ღირებულებებს.

1291
01:03:21,290 --> 01:03:24,530
მე დროებით კითხვა
აღნიშნავს არ მოიწვიოს კითხვა.

1292
01:03:24,530 --> 01:03:29,940
>> მინდა iterate 65 წლიდან
26 ასო ანბანი,

1293
01:03:29,940 --> 01:03:35,190
დაბეჭდვისას თითოეულ iteration, რომ
ხასიათი განუყოფელი ექვივალენტს.

1294
01:03:35,190 --> 01:03:38,299
სხვა სიტყვებით, მინდა
გადაურბინოთ 26 ნომრები ბეჭდვა

1295
01:03:38,299 --> 01:03:41,590
რა ASCII ხასიათი, წერილი,
და რა შესაბამისი რაოდენობის is--

1296
01:03:41,590 --> 01:03:44,650
უბრალოდ თავიდან
სქემა, რომ slide.

1297
01:03:44,650 --> 01:03:47,010
რა უნდა ამ კითხვის ნიშნები იყოს?

1298
01:03:47,010 --> 01:03:51,760
>> ისე, გამოდის, რომ მეორე
ერთი უნდა იყოს მხოლოდ ცვლადი მე.

1299
01:03:51,760 --> 01:03:53,860
მე მინდა, რომ, რომელიც, როგორც ნომერი.

1300
01:03:53,860 --> 01:03:58,920
და შუა არგუმენტი
აქ, მე შემიძლია გითხრათ კომპიუტერი

1301
01:03:58,920 --> 01:04:03,470
მკურნალობა, რომ მთელი
მე, როგორც ხასიათი, ისე, რომ

1302
01:04:03,470 --> 01:04:05,880
ჩაანაცვლებს, აქ პროცენტი C.

1303
01:04:05,880 --> 01:04:07,990
>> სხვა სიტყვებით, თუ მე,
ადამიანის პროგრამისტი, ვიცი,

1304
01:04:07,990 --> 01:04:09,865
ეს არის მხოლოდ ციფრები
ბოლოს დღის განმავლობაში.

1305
01:04:09,865 --> 01:04:12,500
და მე ვიცი, რომ 65 უნდა
MAP- ის გარკვეული ხასიათი.

1306
01:04:12,500 --> 01:04:15,310
ამ გამოკვეთილ მსახიობი,
ერთად ფრჩხილებში,

1307
01:04:15,310 --> 01:04:18,840
სახელი მონაცემები ტიპის გსურთ
გარდაქმნას, და დახურული ფრჩხილებში,

1308
01:04:18,840 --> 01:04:21,200
თქვენ გეტყვით
კომპიუტერი, hey, კომპიუტერი,

1309
01:04:21,200 --> 01:04:24,130
გარდაქმნას ეს რიცხვი char.

1310
01:04:24,130 --> 01:04:26,250
>> ასე რომ, როდესაც მე აწარმოებს ამ
პროგრამის შემდეგ შედგენა,

1311
01:04:26,250 --> 01:04:29,740
ვნახოთ, რა მივიღო, რათა ASCII 0.

1312
01:04:29,740 --> 01:04:33,020
Darn ეს, რა გავაკეთო არასწორი აქ?

1313
01:04:33,020 --> 01:04:35,884
გამოყენება გამოუცხადებელ იდენტიფიკატორი,
ყველა უფლება, არ არის გამიზნული,

1314
01:04:35,884 --> 01:04:37,800
მაგრამ ვნახოთ, თუ ჩვენ არ შეგვიძლია
მიზეზი მეშვეობით.

1315
01:04:37,800 --> 01:04:41,220
>> ამიტომ ხაზი ხუთ ასე რომ მე არ მიიღოს
ძალიან შორს ადრე screwing up.

1316
01:04:41,220 --> 01:04:42,140
არაუშავს.

1317
01:04:42,140 --> 01:04:46,560
ამიტომ ხაზი 5 i უდრის 65-- ვხედავ.

1318
01:04:46,560 --> 01:04:50,130
ასე მახსოვს, რომ C, განსხვავებით ზოგიერთი
ენებზე, თუ თქვენ გაქვთ წინასწარი პროგრამირების

1319
01:04:50,130 --> 01:04:52,190
გამოცდილება, თქვენ უნდა
ვუთხრა კომპიუტერი,

1320
01:04:52,190 --> 01:04:55,040
განსხვავებით Scratch, რა
ტიპის ცვლადი ეს არის.

1321
01:04:55,040 --> 01:04:56,860
>> და დამავიწყდა გასაღები ფრაზა აქ.

1322
01:04:56,860 --> 01:04:59,200
შეესაბამება ხუთი, მე გამოყენება დაიწყო i.

1323
01:04:59,200 --> 01:05:01,560
მაგრამ მე არ უთხრა C
რა მონაცემები ტიპის ეს არის.

1324
01:05:01,560 --> 01:05:04,570
ამიტომ, მე ვაპირებ წასვლა აქ და
ამბობენ, ah, რათა ის რიცხვი.

1325
01:05:04,570 --> 01:05:07,050
>> ახლა მე ვაპირებ წავიდეთ წინ და recompile.

1326
01:05:07,050 --> 01:05:08,080
რომ დაფიქსირებული, რომ.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, რომ სახის cool.

1328
01:05:12,660 --> 01:05:15,360
ეს არ არის მხოლოდ სუპერ სწრაფი
ვთხოვ კომპიუტერში ამ კითხვაზე,

1329
01:05:15,360 --> 01:05:18,885
ვიდრე ეძებს ის შესახებ slide,
ეს დაბეჭდილი ერთ ხაზზე ერთი, არის 65,

1330
01:05:18,885 --> 01:05:24,860
B 66, ყველა გზა დანგრევა, რაც მე
ეს გააკეთა 26 times-- წერილები z,

1331
01:05:24,860 --> 01:05:25,630
რომელიც 90.

1332
01:05:25,630 --> 01:05:27,790
და, ფაქტობრივად, ოდნავ
უფრო ჭკვიანი იქნებოდა

1333
01:05:27,790 --> 01:05:31,030
არ ყოფილა ჩემთვის, არ დაეყრდნონ
on კომპიუტერი დაამატოთ 26.

1334
01:05:31,030 --> 01:05:34,060
მე ვერ უბრალოდ გაკეთდეს
90 ასევე, ცოტა ხნის

1335
01:05:34,060 --> 01:05:37,390
როგორც მე არ გააკეთოს იგივე შეცდომას ორჯერ.

1336
01:05:37,390 --> 01:05:41,880
მინდა წასვლა მეშვეობით
z, არა მხოლოდ მეშვეობით y.

1337
01:05:41,880 --> 01:05:44,000
>> ასე რომ, თუ გამოკვეთილ მსახიობი.

1338
01:05:44,000 --> 01:05:47,860
გამოდის, რომ ამ
კი არ არის საჭირო.

1339
01:05:47,860 --> 01:05:52,480
ნება მომეცით წავიდეთ წინ და გამეორება ამ
შემდგენელი და გამეორება ASCII 0.

1340
01:05:52,480 --> 01:05:54,940
გამოდის, რომ C საკმაოდ ჭკვიანი.

1341
01:05:54,940 --> 01:05:57,150
>> და printf, კერძოდ,
საკმაოდ ჭკვიანი.

1342
01:05:57,150 --> 01:06:01,260
თუ თქვენ უბრალოდ გაივლის i ორჯერ
ორივე placeholders, printf

1343
01:06:01,260 --> 01:06:04,510
იქნება ხვდები, რა, კარგად მე ვიცი, რომ თქვენ
მომცა რიცხვი გარკვეული რაოდენობის,

1344
01:06:04,510 --> 01:06:06,380
მოსწონს 65, ან 90, ან რასაც.

1345
01:06:06,380 --> 01:06:10,170
მაგრამ მე ვხედავ, რომ გინდა,
ფორმატირება, რომ ნომერი, როგორც ხასიათი.

1346
01:06:10,170 --> 01:06:16,460
ასე რომ, printf შეიძლება ირიბად მიცემული
int, რათა char ამისთვის თქვენ ასევე.

1347
01:06:16,460 --> 01:06:19,360
ასე რომ, არ არის პრობლემა.

1348
01:06:19,360 --> 01:06:23,100
>> მაგრამ შეამჩნია, რადგან ამ ექვივალენტობის
ჩვენ შეგვიძლია რეალურად ამის გაკეთება, ასევე.

1349
01:06:23,100 --> 01:06:26,520
ნება მომეცით წავიდეთ წინ და ერთი
სხვა ვერსია ამას ASCII 1.გ.

1350
01:06:26,520 --> 01:06:31,800
და ნაცვლად iterating მეტი
რიცხვებით, ნამდვილად აფეთქება თქვენი გონება

1351
01:06:31,800 --> 01:06:33,610
მიერ iterating მეტი სიმბოლო.

1352
01:06:33,610 --> 01:06:37,660
თუ char c იღებს დედაქალაქში, I
გსურთ წავიდეთ წინ და ამის გაკეთება,

1353
01:06:37,660 --> 01:06:41,740
ასე რომ, სანამ C ნაკლებია ან ტოლი
კაპიტალის ზ და თითოეულ iteration

1354
01:06:41,740 --> 01:06:45,690
მე მინდა, რომ ნამატი C, შემიძლია
ახლა ჩემი printf ხაზი აქ

1355
01:06:45,690 --> 01:06:51,320
ვთქვათ, პროცენტი C არის
პროცენტი მე კიდევ ერთხელ, მძიმე C.

1356
01:06:51,320 --> 01:06:57,200
>> და ახლა, მე შეიძლება სხვა მიმართულებით,
კასტინგი ხასიათი მკაფიოდ

1357
01:06:57,200 --> 01:06:58,500
რიცხვი.

1358
01:06:58,500 --> 01:07:00,560
ასე რომ, კიდევ ერთხელ, რატომ აკეთებთ ამას?

1359
01:07:00,560 --> 01:07:03,830
ეს ცოტა უცნაური დასალაგებლად
იმედი თვალსაზრისით სიმბოლო.

1360
01:07:03,830 --> 01:07:07,430
>> მაგრამ თუ თქვენ გვესმოდეს, რა არის
მიმდინარეობს ქვეშ hood,

1361
01:07:07,430 --> 01:07:08,430
იქ ნამდვილად არ Magic.

1362
01:07:08,430 --> 01:07:13,060
თქვენ უბრალოდ ამბობდა, hey, კომპიუტერული მისცეს
მომეცი ცვლადში C ტიპის char.

1363
01:07:13,060 --> 01:07:16,520
ვრთავ, რომ დედაქალაქში ა და
შეამჩნია ერთ შეთავაზებები საკითხზე.

1364
01:07:16,520 --> 01:07:19,580
>> გმირები C, გავიხსენოთ
გასულ კვირას, გამოიყენოთ ერთჯერადი შეთავაზებები.

1365
01:07:19,580 --> 01:07:23,720
სიმებიანი, სიტყვა,
ფრაზები, თქვენ ორმაგ ბრჭყალებში.

1366
01:07:23,720 --> 01:07:27,210
OK, კომპიუტერი, ექცევით, ასე რომ,
სანამ ხასიათი ნაკლებია, ვიდრე

1367
01:07:27,210 --> 01:07:28,050
ან ტოლია z.

1368
01:07:28,050 --> 01:07:32,640
და მე ვიცი, რომ ჩემი ASCII მაგიდასთან, რომ ყველა
ამ ASCII კოდები მომიჯნავე.

1369
01:07:32,640 --> 01:07:33,400
>> არ არსებობს ხარვეზები.

1370
01:07:33,400 --> 01:07:36,737
ასე რომ, ეს უბრალოდ მეშვეობით Z,
გამოყოფილი ერთი ნომერი თითოეული.

1371
01:07:36,737 --> 01:07:38,820
და მერე შეგვიძლია გავზარდოთ
char, თუ მე ნამდვილად მინდა.

1372
01:07:38,820 --> 01:07:40,390
ბოლოს დღეს,
ეს მხოლოდ ნომერი.

1373
01:07:40,390 --> 01:07:41,030
მე ეს ვიცი.

1374
01:07:41,030 --> 01:07:43,670
ასე, რომ შეიძლება მხოლოდ ვივარაუდოთ, რომ დაამატოთ 1 მას.

1375
01:07:43,670 --> 01:07:46,940
>> შემდეგ კი ამ დროს, მე ბეჭდვა c,
და შემდეგ განუყოფელი ექვივალენტს.

1376
01:07:46,940 --> 01:07:50,170
და მე კი არ უნდა გამოკვეთილ მსახიობი.

1377
01:07:50,170 --> 01:07:52,680
შემიძლია ნება printf და
კომპიუტერული ფიგურა ნივთების,

1378
01:07:52,680 --> 01:07:57,300
ასე რომ, ახლა თუ აწარმოებს
რათა Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
მე კიდევ ზუსტად იგივე რამ, ისევე.

1380
01:08:01,520 --> 01:08:04,530
>> უსარგებლო პროგრამა, though-- არავინ
აპირებს რეალურად დაწეროს პროგრამა

1381
01:08:04,530 --> 01:08:07,549
იმისათვის, რომ გავიგოთ, რა იყო
ნომერი, რომელიც რუკები, ან B, ან Z?

1382
01:08:07,549 --> 01:08:10,340
თქვენ უბრალოდ აპირებს Google მას, ან
მას up ხაზზე, ან გამოიყურება ეს

1383
01:08:10,340 --> 01:08:11,650
on slide, ან მოსწონს.

1384
01:08:11,650 --> 01:08:13,520
ასე რომ, სადაც ეს რეალურად მიიღოთ სასარგებლო?

1385
01:08:13,520 --> 01:08:15,960
>> ისე, რომ ვთქვათ, რომ
slide, შეამჩნია

1386
01:08:15,960 --> 01:08:20,890
ფაქტობრივი ნიმუში აქ შორის ზედა
და ამას, რომ არ იყო შემთხვევითი.

1387
01:08:20,890 --> 01:08:23,760
გაითვალისწინეთ, რომ დედაქალაქში არის 65.

1388
01:08:23,760 --> 01:08:25,830
მხედრულ არის 97.

1389
01:08:25,830 --> 01:08:29,649
და რამდენად შორს არის ქვედა შემთხვევაში?

1390
01:08:29,649 --> 01:08:32,649
>> ასე რომ, 65 რამდენი ნაბიჯში 97?

1391
01:08:32,649 --> 01:08:36,210
ასე რომ, 97 მინუს 65 არის 32.

1392
01:08:36,210 --> 01:08:37,910
ასე რომ დედაქალაქში არის 65.

1393
01:08:37,910 --> 01:08:39,939
თუ თქვენ დაამატოთ 32 რომ,
თქვენ ამას.

1394
01:08:39,939 --> 01:08:43,729
და, equivalently, თუ გამოვაკლებთ 32,
დავუბრუნდეთ დედაქალაქის A-- იგივე B

1395
01:08:43,729 --> 01:08:46,380
პატარა ბ, დიდი C პატარა გ.

1396
01:08:46,380 --> 01:08:50,670
>> ყველა ეს ხარვეზები 32 გარდა.

1397
01:08:50,670 --> 01:08:54,450
ახლა, ეს, როგორც ჩანს, საშუალებას გვაძლევს
ამის გაკეთება რაღაც Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
ან Google Docs ფუნქცია, სადაც თქვენ
შეგიძლიათ აირჩიოთ ყველაფერი და მერე ამბობენ,

1399
01:08:57,729 --> 01:09:00,520
შეიცვლება ყველა ამას, ან
შეიცვლება ყველა ზედა შემთხვევაში,

1400
01:09:00,520 --> 01:09:03,840
ან იცვლება მხოლოდ პირველი სიტყვა
სასჯელის ზედა შემთხვევაში.

1401
01:09:03,840 --> 01:09:07,390
ჩვენ შეგვიძლია რეალურად რაღაც
მინდა, რომ საკუთარ თავს.

1402
01:09:07,390 --> 01:09:12,645
>> ნება მომეცით წავიდეთ წინ და გადარჩენა ფაილი
აქ მოუწოდა ესარგებლა 0.c.

1403
01:09:12,645 --> 01:09:15,770
და მოდით წავიდეთ წინ და whip up პროგრამა
რომელიც აკეთებს ზუსტად რომ ასეთია.

1404
01:09:15,770 --> 01:09:18,460
ასე რომ მოიცავს CS50 ბიბლიოთეკა.

1405
01:09:18,460 --> 01:09:21,430
და მოიცავს სტანდარტული I / O.

1406
01:09:21,430 --> 01:09:22,787
>> და მე ვიცი, რომ ეს მალე.

1407
01:09:22,787 --> 01:09:24,870
ასე რომ, მე ვაპირებ, რომ ეს
იქ უკვე, string.h,

1408
01:09:24,870 --> 01:09:26,960
ასე მაქვს ხელმისაწვდომობის
რამ, როგორიცაა Stirling,

1409
01:09:26,960 --> 01:09:29,620
და შემდეგ int ძირითადი ბათილად, როგორც ყოველთვის.

1410
01:09:29,620 --> 01:09:33,420
და შემდეგ მე ვაპირებ წავიდეთ წინ
და ნუ strings იღებს მიიღოს სიმებიანი,

1411
01:09:33,420 --> 01:09:35,032
მხოლოდ მისაღებად ნახატზე შესახებ.

1412
01:09:35,032 --> 01:09:36,740
და შემდეგ მე ვაპირებ
ნუ ჩემი საღი აზრის ქვითარი.

1413
01:09:36,740 --> 01:09:40,510
თუ სიმებიანი არ თანაბარი null,
მაშინ ეს უსაფრთხო გაგრძელება.

1414
01:09:40,510 --> 01:09:42,000
და რა უნდა გავაკეთოთ?

1415
01:09:42,000 --> 01:09:48,700
მე ვაპირებ iterate საწყისი i = 0,
და n მდე სიმებიანი ხანგრძლივობა s.

1416
01:09:48,700 --> 01:09:51,899
>> და მე ვაპირებ, რომ ამის გაკეთება მანამ, სანამ
i ნაკლებია, ვიდრე n, და მე plus plus.

1417
01:09:51,899 --> 01:09:55,060
ჯერჯერობით, მე ნამდვილად
სესხის იდეები ადრე.

1418
01:09:55,060 --> 01:09:57,010
და ახლა მე ვაპირებ წარმოგიდგინოთ ფილიალი.

1419
01:09:57,010 --> 01:09:59,635
>> ასე რომ, ვფიქრობ, უკან ნულიდან, სადაც
ჩვენ გვქონდა იმ ჩანგლები საგზაო,

1420
01:09:59,635 --> 01:10:05,110
და გასულ კვირას C. მე ვაპირებ
ამბობენ, რომ ეს, თუ i-th ხასიათი s

1421
01:10:05,110 --> 01:10:09,250
მეტია ან
ტოლი ქვედა შემთხვევაში,

1422
01:10:09,250 --> 01:10:13,340
and-- in Scratch თქვენ ფაქტიურად
ვთქვათ და, მაგრამ C თქვენ ამბობთ ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- და i-th ხასიათი s
ნაკლებია ან ტოლი ქვედა შემთხვევაში z,

1424
01:10:19,830 --> 01:10:21,780
მოდით რაღაც საინტერესო.

1425
01:10:21,780 --> 01:10:27,020
მოდით რეალურად ამობეჭდოთ
ხასიათი არ newline

1426
01:10:27,020 --> 01:10:31,760
რომ არის პერსონაჟი სიმებიანი,
i-th პერსონაჟი სიმებიანი.

1427
01:10:31,760 --> 01:10:37,420
>> მაგრამ მოდით წავიდეთ წინ და
სხვაობა 32 მას.

1428
01:10:37,420 --> 01:10:42,120
სხვაგან, თუ პერსონაჟის
string, რომ ჩვენ ვეძებთ

1429
01:10:42,120 --> 01:10:45,950
არ არის შორის პატარა
და პატარა z, წავიდეთ წინ

1430
01:10:45,950 --> 01:10:48,610
და მხოლოდ დაბეჭდილი ის არ შეცვლილა.

1431
01:10:48,610 --> 01:10:50,840
ასე რომ, ჩვენ გააცნო
ამ ფრჩხილებში notation

1432
01:10:50,840 --> 01:10:53,560
ჩვენი strings მიიღონ ზე
i-th პერსონაჟი სიმებიანი.

1433
01:10:53,560 --> 01:10:57,520
>> მე დასძინა ზოგიერთი პირობითი ლოგიკის, როგორც
Scratch გასულ კვირას კვირაში ერთი, სადაც

1434
01:10:57,520 --> 01:10:59,880
მე უბრალოდ გამოყენებით ჩემი ძირითადი
გაგება, თუ რა არის

1435
01:10:59,880 --> 01:11:01,130
მიმდინარეობს ქვეშ hood.

1436
01:11:01,130 --> 01:11:04,190
არის i-ე ხასიათი s
მეტია ან ტოლია?

1437
01:11:04,190 --> 01:11:08,290
მინდა, რომ 97, 98,
ან 99 და ა.შ.?

1438
01:11:08,290 --> 01:11:11,940
>> მაგრამ არის ის, ასევე ნაკლებია ან ტოლი
ღირებულება ამას z?

1439
01:11:11,940 --> 01:11:16,210
და თუ ასეა, რას ნიშნავს ეს ხაზი ნიშნავს?

1440
01:11:16,210 --> 01:11:20,250
14, ეს არის ერთგვარი
ჩანასახები მთელი იდეა,

1441
01:11:20,250 --> 01:11:23,840
კაპიტალიზაცია წერილში მიერ
უბრალოდ გამოკლებით 32 მისგან,

1442
01:11:23,840 --> 01:11:29,370
ამ შემთხვევაში, რადგან ვიცი, თითო რომ
სქემა, თუ როგორ, ჩემი ნომრები წარმოდგენილი.

1443
01:11:29,370 --> 01:11:33,925
მოდით წავიდეთ წინ და აწარმოებს ამ,
შემდეგ შედგენა ესარგებლა 0.c,

1444
01:11:33,925 --> 01:11:36,210
და აწარმოებს ესარგებლა 0.

1445
01:11:36,210 --> 01:11:40,300
>> მოდით აკრიფოთ რაღაც
Zamyla ყველა ამას შევა.

1446
01:11:40,300 --> 01:11:42,780
და ახლა ჩვენ გვაქვს Zamyla ყველა ზედა.

1447
01:11:42,780 --> 01:11:45,050
მოდით აკრიფოთ Rob ყველა ამას.

1448
01:11:45,050 --> 01:11:46,674
მოდით ცდილობენ Jason ყველა ამას.

1449
01:11:46,674 --> 01:11:48,590
ჩვენ მომდის
იძულებული კაპიტალიზაცია.

1450
01:11:48,590 --> 01:11:50,960
არსებობს მცირე შეცდომა, რომ მე
სახის არ გავუსწრო.

1451
01:11:50,960 --> 01:11:54,050
ყურადღება მიაქციეთ, რომ ჩემს ახალ ზოლზე არის დამთავრებული
იმავე ხაზის, როგორც მათი სახელები,

1452
01:11:54,050 --> 01:11:55,520
რომელიც გრძნობს ცოტა რთული.

1453
01:11:55,520 --> 01:11:59,170
>> ამიტომ, მე ვაპირებ წასვლა აქ და
რეალურად დასასრულს ამ პროგრამის

1454
01:11:59,170 --> 01:12:02,110
ამობეჭდოთ სტრიქონების გადატანით ხასიათი.

1455
01:12:02,110 --> 01:12:03,160
სულ ეს არის.

1456
01:12:03,160 --> 01:12:06,120
ერთად printf, თქვენ არ უნდა
გაივლის ცვლადები ან ფორმატი კოდი.

1457
01:12:06,120 --> 01:12:08,460
თქვენ შეგიძლიათ სიტყვასიტყვით უბრალოდ ბეჭდვა
რაღაც newline.

1458
01:12:08,460 --> 01:12:13,529
>> მოდით, წავიდეთ წინ და
ესარგებლა 0 ერთხელ, გამეორება ეს, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
და ახლა ეს პატარა გალამაზებაში.

1460
01:12:14,820 --> 01:12:17,274
ახლა, ჩემი ზოლში არის საკუთარი ახალი ხაზი.

1461
01:12:17,274 --> 01:12:18,440
ასე რომ, ყველა კარგი და კეთილი.

1462
01:12:18,440 --> 01:12:19,910
ასე რომ, კარგი მაგალითი.

1463
01:12:19,910 --> 01:12:22,700
მაგრამ მე კი არ არის აუცილებელი
უნდა მძიმე კოდი 32.

1464
01:12:22,700 --> 01:12:23,350
იცი რაა?

1465
01:12:23,350 --> 01:12:26,350
მე ვერ იტყვის მე არ ოდესმე
გვახსოვდეს, თუ რა განსხვავება არის.

1466
01:12:26,350 --> 01:12:29,330
>> მაგრამ მე ვიცი, რომ თუ
აქვს ქვედა შემთხვევაში წერილში,

1467
01:12:29,330 --> 01:12:34,430
მე არსებითად გვინდა გამოვაკლოთ off
რასაც მანძილი შორის პატარა

1468
01:12:34,430 --> 01:12:39,160
a და დიდი, რადგან თუ მე ვივარაუდოთ, რომ
ყველა სხვა წერილები იგივეა,

1469
01:12:39,160 --> 01:12:41,045
რომ უნდა მიიღოს გაწეული სამუშაო.

1470
01:12:41,045 --> 01:12:42,670
მაგრამ ვიდრე ამის გაკეთება, თქვენ იცით, რა?

1471
01:12:42,670 --> 01:12:44,240
არსებობს კიდევ ერთი გზა მაინც.

1472
01:12:44,240 --> 01:12:48,090
>> თუ ეს ესარგებლა 1.c-- თუ მე
იმისათვის, რომ ცალკე ფაილი.

1473
01:12:48,090 --> 01:12:51,030
მოდით ესარგებლა 2.c ასეთია.

1474
01:12:51,030 --> 01:12:53,060
მე ვაპირებ ნამდვილად სუფთა ეს აქ.

1475
01:12:53,060 --> 01:12:57,420
და ნაცვლად კი, რომელსაც
ვიცი და არც მაინტერესებს, იმ დაბალი დონის

1476
01:12:57,420 --> 01:13:01,090
განხორციელების დეტალები, მე ვარ ნაცვლად
უბრალოდ აპირებს ბეჭდვა ხასიათი,

1477
01:13:01,090 --> 01:13:04,610
ციტირებით unquote, პროცენტი C, და
მაშინ მოვუწოდებთ სხვა ფუნქცია, რომელიც

1478
01:13:04,610 --> 01:13:09,950
არსებობს ინფორმაცია, რომ იღებს არგუმენტი,
რომელიც ხასიათი, მოსწონს ეს.

1479
01:13:09,950 --> 01:13:12,630
>> თურმე C, არსებობს
სხვა ფუნქცია ზარი

1480
01:13:12,630 --> 01:13:15,550
ზედა, რომელიც, როგორც მისი სახელი
ვარაუდობს იღებს ხასიათი

1481
01:13:15,550 --> 01:13:19,350
და ხდის მის ზედა შემთხვევაში
ექვივალენტს, და მერე დააბრუნებს მას

1482
01:13:19,350 --> 01:13:21,410
ასე რომ printf შეგიძლიათ შეაერთედ მას იქ.

1483
01:13:21,410 --> 01:13:25,484
ასე რომ, ამის გაკეთება, თუმცა, მე
უნდა წარმოგიდგინოთ ერთი სხვა ფაილი.

1484
01:13:25,484 --> 01:13:28,400
გამოდის, რომ კიდევ ერთი ფაილი
რომ თქვენ მხოლოდ ვიცი კლასი,

1485
01:13:28,400 --> 01:13:33,020
ან სახელმძღვანელოს, ან ონლაინ
ცნობისთვის, სახელწოდებით C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> ასე რომ, თუ დავამატო, რომ მათ შორის ჩემი header
ფაილი, და ახლა ხელახლა შეადგინონ ამ პროგრამის

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 შეიტანეთ.

1488
01:13:43,040 --> 01:13:46,690
მოდით აკრიფოთ Zamyla ყველა
ამას, ჯერ კიდევ მუშაობს იგივე.

1489
01:13:46,690 --> 01:13:48,040
მაგრამ იცით, რა?

1490
01:13:48,040 --> 01:13:55,590
გამოდის, რომ ზედა
აქვს ზოგიერთი სხვა ფუნქცია.

1491
01:13:55,590 --> 01:13:58,410
>> და ნება მომეცით წარმოგიდგინოთ ამ
ბრძანება აქ, ერთგვარი უხერხულად

1492
01:13:58,410 --> 01:14:00,250
დაასახელა, მაგრამ კაცი სახელმძღვანელო.

1493
01:14:00,250 --> 01:14:03,960
გამოდის, რომ ყველაზე Linux კომპიუტერები,
როგორც ჩვენ გამოყენებით აქ Linux ოპერაციული

1494
01:14:03,960 --> 01:14:06,270
system-- აქვს ბრძანება
მოუწოდა კაცი, რომელიც ამბობს,

1495
01:14:06,270 --> 01:14:08,530
hey, კომპიუტერი, მომეცი
კომპიუტერის სახელმძღვანელო.

1496
01:14:08,530 --> 01:14:10,680
რა გინდა რომ
ეძებოთ იმ მექანიკური?

1497
01:14:10,680 --> 01:14:13,840
>> მინდა გამოიყურებოდეს up ფუნქცია
მოუწოდა ზედა, შეიტანეთ.

1498
01:14:13,840 --> 01:14:16,070
და ეს ცოტა cryptic
წაკითხვის ზოგჯერ.

1499
01:14:16,070 --> 01:14:18,780
მაგრამ შეამჩნია, ჩვენ ვართ
Linux პროგრამისტი სახელმძღვანელო.

1500
01:14:18,780 --> 01:14:19,530
და ეს ყველაფერი ტექსტი.

1501
01:14:19,530 --> 01:14:21,905
და შეამჩნია, რომ არსებობს
სახელი ფუნქცია აქ.

1502
01:14:21,905 --> 01:14:25,030
გამოდის, რომ მას აქვს ბიძაშვილი მოუწოდა
შეამცირონ, რომელიც აკეთებს საპირისპირო.

1503
01:14:25,030 --> 01:14:29,710
და შესაბამისად შეტყობინების შინაარსი, რათა გამოიყენონ ეს
ფუნქციონირებს კაცი გვერდზე, ასე ვთქვათ,

1504
01:14:29,710 --> 01:14:32,220
მეუბნებოდა, რომ მე
უნდა შეიცავდეს გ type.h.

1505
01:14:32,220 --> 01:14:33,630
და მე ვიცი, რომ პრაქტიკაში.

1506
01:14:33,630 --> 01:14:36,210
>> აქ, ეს გვიჩვენებს მე ორ
პროტოტიპები ფუნქცია,

1507
01:14:36,210 --> 01:14:39,070
ასე რომ, თუ მე ოდესმე გვინდა გამოვიყენოთ ეს
მე ვიცი, რა ისინი, როგორც input,

1508
01:14:39,070 --> 01:14:40,652
და რა ისინი დაბრუნდებიან როგორც გამომავალი.

1509
01:14:40,652 --> 01:14:42,360
და მაშინ, თუ წავიკითხე
აღწერა, მე ვხედავ

1510
01:14:42,360 --> 01:14:44,820
უფრო დეტალურად რა ფუნქცია აქვს.

1511
01:14:44,820 --> 01:14:48,100
მაგრამ რაც მთავარია, თუ
ვუყურებ ქვეშ დაბრუნების ღირებულება,

1512
01:14:48,100 --> 01:14:51,710
იგი აცხადებს, რომ დაბრუნებული მნიშვნელობა არის
რომ მოაქცია წერილი,

1513
01:14:51,710 --> 01:14:57,880
ან C, ორიგინალური input, თუ
კონვერტაციის არ იყო შესაძლებელი.

1514
01:14:57,880 --> 01:15:01,992
>> სხვა სიტყვებით, ზედა შეეცდება
გარდაქმნას წერილში ზედა შემთხვევაში.

1515
01:15:01,992 --> 01:15:03,450
და თუ ასეა, ის აპირებს დაუბრუნდეს.

1516
01:15:03,450 --> 01:15:07,010
მაგრამ თუ მას არ შეუძლია გარკვეული reason--
შესაძლოა, ეს უკვე ზედა შემთხვევაში,

1517
01:15:07,010 --> 01:15:09,550
შესაძლოა, ეს ძახილის წერტილი
ან სხვა punctuation--

1518
01:15:09,550 --> 01:15:12,200
ის უბრალოდ აპირებს
დაბრუნდეს ორიგინალური C,

1519
01:15:12,200 --> 01:15:17,340
რაც იმას ნიშნავს, მე შემიძლია ჩემი კოდი
უკეთესი შექმნილია ასეთია.

1520
01:15:17,340 --> 01:15:20,580
>> მე არ უნდა ყველა
ამ darn ხაზი კოდი.

1521
01:15:20,580 --> 01:15:22,610
ყველა ხაზების მე
უბრალოდ ხაზი გაუსვა შეუძლია

1522
01:15:22,610 --> 01:15:28,700
დაინგრა მხოლოდ ერთი მარტივი
ხაზი, რომელიც არის ამ printf პროცენტი

1523
01:15:28,700 --> 01:15:33,510
გ ზედა S bracket i.

1524
01:15:33,510 --> 01:15:36,090
და ეს იქნება
მაგალითად უკეთესი დიზაინი.

1525
01:15:36,090 --> 01:15:40,040
>> რატომ განახორციელებს 7 ან 8 ხაზები
კოდი, რაც არ იყო, მე უბრალოდ

1526
01:15:40,040 --> 01:15:44,960
იშლება, როდესაც თქვენ შეგიძლიათ ნაცვლად დაიშალოს
ყველა რომ ლოგიკა და გადაწყვეტილების მიღების

1527
01:15:44,960 --> 01:15:49,620
ერთ ერთი ხაზი, 13 ახლა, რომ
ეყრდნობა ბიბლიოთეკის ფუნქცია

1528
01:15:49,620 --> 01:15:53,430
ფუნქცია, რომელიც გააჩნია C, მაგრამ
ზუსტად რა გსურთ ამის გაკეთება.

1529
01:15:53,430 --> 01:15:55,295
და, სიმართლე გითხრათ, თუნდაც
ის არ მოდის C,

1530
01:15:55,295 --> 01:15:58,880
თქვენ შეიძლება განახორციელოს იგი საკუთარ თავს, როგორც
ჩვენ ვნახეთ, ერთად უარყოფითი int

1531
01:15:58,880 --> 01:16:01,700
და დადებითი int გასულ კვირას, ისევე.

1532
01:16:01,700 --> 01:16:03,470
>> ეს კოდი ახლა გაცილებით იკითხება.

1533
01:16:03,470 --> 01:16:06,670
და, მართლაც, თუ ჩვენ გადახვევა up,
შეხედეთ, როგორ ბევრად უფრო კომპაქტური

1534
01:16:06,670 --> 01:16:08,360
ეს ვერსია ჩემი პროგრამა.

1535
01:16:08,360 --> 01:16:11,230
ეს პატარა მძიმე ახლა,
ყველა ამ მოიცავს.

1536
01:16:11,230 --> 01:16:14,380
მაგრამ ეს კარგია, რადგან ახლა ვდგავარ
მხრებზე პროგრამისტები

1537
01:16:14,380 --> 01:16:15,300
ჩემამდე.

1538
01:16:15,300 --> 01:16:18,440
და ვინც არ უნდა იყო, რომელიც
განხორციელებული ზედა ნამდვილად

1539
01:16:18,440 --> 01:16:21,470
ჩემთვის სასარგებლოდ, ჰგავს, ვინც
განხორციელებული Stirling ნამდვილად

1540
01:16:21,470 --> 01:16:24,790
ჩემთვის სასარგებლოდ რამდენიმე ხნის წინ.

1541
01:16:24,790 --> 01:16:26,970
ასე რომ, ახლა ჩვენ გვაქვს
უკეთესი დიზაინის პროგრამა

1542
01:16:26,970 --> 01:16:31,680
რომელიც ახორციელებს ზუსტად იგივე ლოგიკით.

1543
01:16:31,680 --> 01:16:35,580
>> საუბრისას Stirling, ნება
მომეცით წავიდეთ წინ და ამის გაკეთება.

1544
01:16:35,580 --> 01:16:38,320
ნება მომეცით წავიდეთ წინ და შენახვა
ამ ფაილს, როგორც stirling.c.

1545
01:16:38,320 --> 01:16:43,255
და აღმოჩნდება, ჩვენ შეგვიძლია კანი უკან
ერთი სხვა ფენის საკმაოდ უბრალოდ ახლა.

1546
01:16:43,255 --> 01:16:45,630
მე ვაპირებ წავიდეთ წინ და whip
კიდევ ერთი პროგრამა მთავარი

1547
01:16:45,630 --> 01:16:49,759
აქ უბრალოდ ხელახლა იარაღები
სიმებიანი სიგრძე ასეთია.

1548
01:16:49,759 --> 01:16:52,300
ასე რომ აქ ხაზი კოდი, რომ
იღებს me სიმებიანი შესახებ.

1549
01:16:52,300 --> 01:16:53,910
ჩვენ შევინარჩუნოთ გამოყენებით ეს ისევ და ისევ.

1550
01:16:53,910 --> 01:16:58,900
ნება მომეცით მისცეს თავს ცვლადში
n ტიპის int, რომელიც ინახავს ნომერი.

1551
01:16:58,900 --> 01:17:02,490
>> და ნება მომეცით წავიდეთ წინ და
შემდეგი ლოგიკა.

1552
01:17:02,490 --> 01:17:15,610
მიუხედავად იმისა, რომ n-th პერსონაჟი s აკეთებს
არ უდრის წარმატებული 0, წავიდეთ წინ

1553
01:17:15,610 --> 01:17:17,930
და ნამატი n.

1554
01:17:17,930 --> 01:17:23,506
და შემდეგ ამობეჭდოთ printf პროცენტი i n.

1555
01:17:23,506 --> 01:17:29,200
მე ვამტკიცებ, რომ ამ პროგრამის,
გარეშე მოუწოდებენ სიმებიანი სიგრძე,

1556
01:17:29,200 --> 01:17:31,150
გათვლით, სიგრძეზე სიმებიანი.

1557
01:17:31,150 --> 01:17:34,600
>> და ჯადოსნური მთლიანად
ლაკონურად line 8

1558
01:17:34,600 --> 01:17:39,830
აქ რა ჰგავს ახალი სინტაქსი,
ამ წარმატებული 0 ერთ შეთავაზებები.

1559
01:17:39,830 --> 01:17:41,360
მაგრამ რატომ არის, რომ?

1560
01:17:41,360 --> 01:17:44,100
ისე, რა იყო
მიმდინარეობს ამ დროს.

1561
01:17:44,100 --> 01:17:47,990
>> და როგორც განზე, სანამ მე დაგვავიწყდეს, გააცნობიეროს,
ძალიან, რომ გარდა იმისა, რომ კაცი გვერდებზე

1562
01:17:47,990 --> 01:17:50,920
რომ მოვიდა ერთად ტიპიური
Linux სისტემა, როგორც CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
გააცნობიეროს, რომ ჩვენ,
რა თქმა უნდა, ის თანამშრომლები, ასევე

1564
01:17:53,770 --> 01:17:56,030
გააკეთა საიტი ვერსია
ამ იგივე იდეა მოუწოდა

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, რომელსაც აქვს
ყველა იგივე კაცი გვერდებზე,

1566
01:17:59,940 --> 01:18:02,020
ყველა რომ ერთი და იგივე
დოკუმენტაცია, ისევე როგორც

1567
01:18:02,020 --> 01:18:05,730
პატარა ყუთი ზედა, რომელიც საშუალებას
საშუალებას გადაიყვანოთ ყველა სამართლიანად

1568
01:18:05,730 --> 01:18:09,025
arcane ენიდან ნაკლებად კომფორტული
რეჟიმი, სადაც, აკადემიური პერსონალის,

1569
01:18:09,025 --> 01:18:12,150
გაიარა და ცდილობდა გამარტივება
ზოგიერთი ენის შენარჩუნება რამ

1570
01:18:12,150 --> 01:18:14,830
ორიენტირებულია იდეები, და არა
ზოგიერთი ტექნიკური.

1571
01:18:14,830 --> 01:18:20,070
ასე რომ, გახსოვდეთ, reference.cs50.net
როგორც სხვა რესურსი.

1572
01:18:20,070 --> 01:18:23,800
>> მაგრამ რატომ სიმებიანი სიგრძე მუშაობა
გზა მე შევთავაზე მომენტში წინ?

1573
01:18:23,800 --> 01:18:25,160
აი Zamyla სახელი ერთხელ.

1574
01:18:25,160 --> 01:18:27,690
აქ არის Zamyla სახელი
ჩარჩოში წელს, როგორც მე აკეთეთ,

1575
01:18:27,690 --> 01:18:31,360
ხატავს სურათს, რომ იგი,
ნამდვილად, უბრალოდ თანმიმდევრობა გმირები.

1576
01:18:31,360 --> 01:18:34,260
მაგრამ Zamyla არ არსებობს
იზოლაცია პროგრამა.

1577
01:18:34,260 --> 01:18:37,420
>> როდესაც ვწერთ და გაუშვით პროგრამა,
თქვენ იყენებთ თქვენს Mac ან თქვენი კომპიუტერის

1578
01:18:37,420 --> 01:18:40,010
მეხსიერება, ან RAM, ასე ვთქვათ.

1579
01:18:40,010 --> 01:18:42,620
და შეგიძლიათ წარმოიდგინოთ,
თქვენს კომპიუტერში, როგორც

1580
01:18:42,620 --> 01:18:44,730
უამრავი გბ მეხსიერების ამ დღეებში.

1581
01:18:44,730 --> 01:18:47,700
და კონცერტი ნიშნავს მილიარდობით
ასე მილიარდობით bytes.

1582
01:18:47,700 --> 01:18:48,910
>> მაგრამ მოდით გადახვევა დროს.

1583
01:18:48,910 --> 01:18:51,530
და ვფიქრობ, რომ ჩვენ გამოყენებით
ნამდვილად ძველი კომპიუტერი, რომელიც

1584
01:18:51,530 --> 01:18:55,150
მხოლოდ 32 ბაიტი მეხსიერება.

1585
01:18:55,150 --> 01:18:59,310
შემეძლო, ჩემი კომპიუტერის ეკრანზე,
უბრალოდ მიაპყროს ამ out ასეთია.

1586
01:18:59,310 --> 01:19:05,240
>> მე უბრალოდ ვამბობ, რომ ჩემი
კომპიუტერი ყველა ამ მეხსიერების.

1587
01:19:05,240 --> 01:19:08,830
და ეს არის, როგორც ჯოხი მეხსიერება, თუ
თქვენ გავიხსენოთ ჩვენი სურათი ბოლო დროს.

1588
01:19:08,830 --> 01:19:11,670
და თუ მე გავყოფ
ეს საკმარისი ჯერ,

1589
01:19:11,670 --> 01:19:15,040
I აცხადებენ, რომ 32 bytes
მეხსიერების ეკრანზე.

1590
01:19:15,040 --> 01:19:18,239
>> ახლა, რეალურად, მხოლოდ ის შემიძლია
მიაპყროს ჯერჯერობით ამ ეკრანზე აქ.

1591
01:19:18,239 --> 01:19:20,280
ამიტომ, მე ვაპირებ წავიდეთ წინ,
და მხოლოდ კონვენციის,

1592
01:19:20,280 --> 01:19:24,050
მიაპყროს ჩემი კომპიუტერის მეხსიერებაში, როგორც
ქსელის, არა მხოლოდ როგორც ერთ-ერთი სწორი ხაზი.

1593
01:19:24,050 --> 01:19:28,190
კერძოდ, რომ აცხადებენ, რომ
ამ ქსელის, ამ 8 4 ქსელის,

1594
01:19:28,190 --> 01:19:31,800
უბრალოდ წარმოადგენს ყველა 32 bytes
მეხსიერების ხელმისაწვდომია ჩემი Mac,

1595
01:19:31,800 --> 01:19:33,030
ან შესაძლებელია ჩემი კომპიუტერი.

1596
01:19:33,030 --> 01:19:34,780
და ისინი შესაფუთი
on ორი ხაზი, უბრალოდ

1597
01:19:34,780 --> 01:19:38,030
რადგან ის შეესაბამება უფრო ეკრანზე.

1598
01:19:38,030 --> 01:19:40,800
მაგრამ ეს არის პირველი byte.

1599
01:19:40,800 --> 01:19:41,990
ეს არის მეორე byte.

1600
01:19:41,990 --> 01:19:43,300
ეს არის მესამე byte.

1601
01:19:43,300 --> 01:19:45,310
>> და ეს არის 32-ე byte.

1602
01:19:45,310 --> 01:19:52,910
ან, თუ ჩვენ ვფიქრობთ, როგორიცაა კომპიუტერი
მეცნიერი, ეს არის byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
ასე, რომ თქვენ 0 to 31, თუ
თქვენ დაიწყება დათვლის დროს 0.

1604
01:19:55,950 --> 01:19:59,830
>> ასე რომ, თუ ჩვენ ვიყენებთ პროგრამა
რომ მოწოდებები მიიღოს სიმებიანი,

1605
01:19:59,830 --> 01:20:05,280
და მივიღებთ string ადამიანის
როგორიც მე მოუწოდა Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
როგორ მსოფლიოში აკეთებს
კომპიუტერული ტრეკზე რომელიც byte,

1607
01:20:09,430 --> 01:20:12,230
რომელიც ბლოკი მეხსიერება,
ეკუთვნის, რომელიც სიმებიანი?

1608
01:20:12,230 --> 01:20:16,270
სხვა სიტყვებით, თუ ვაგრძელებთ
ჩაწერეთ სხვა სახელი კომპიუტერი,

1609
01:20:16,270 --> 01:20:19,890
მოსწონს ეს Andi, მოუწოდებს
სიმებიანი მეორედ,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I უნდა დასრულდება მდე
კომპიუტერის მეხსიერებაში, ასევე.

1611
01:20:23,030 --> 01:20:23,850
მაგრამ როგორ?

1612
01:20:23,850 --> 01:20:29,700
>> ასევე, ირკვევა, რომ ქვეშ
hood, რა C აკეთებს, როდესაც შენახვის სტრიქონები

1613
01:20:29,700 --> 01:20:35,080
რომ ადამიანის სახის, ან, რომ
მოდის ზოგიერთი სხვა წყარო, არის ის,

1614
01:20:35,080 --> 01:20:39,190
განსაზღვრავს ბოლოს მათ
სპეციალური პერსონაჟი წარმატებული

1615
01:20:39,190 --> 01:20:44,750
0, რომელიც არის სპეციალური გზა
ამბობდა 80 ბიტი ზედიზედ.

1616
01:20:44,750 --> 01:20:47,950
>> ასე რომ, A-- ეს არის ნომერი 97 გაწვევას.

1617
01:20:47,950 --> 01:20:51,770
ასე რომ ზოგიერთი ნიმუში 8 ბიტი
წარმოადგენს ათობითი ნომერი 97.

1618
01:20:51,770 --> 01:20:58,070
ეს წარმატებული 0 არის სიტყვასიტყვით ნომერი
0, a.k.a. nul, N-U-L, განსხვავებით ადრე,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, რომელიც ჩვენ ვისაუბრეთ.

1620
01:20:59,630 --> 01:21:05,700
მაგრამ ახლა, უბრალოდ ვიცი, რომ ეს
წარმატებული 0 არის მხოლოდ 80 ბიტი ზედიზედ.

1621
01:21:05,700 --> 01:21:09,810
>> და ეს მხოლოდ ამ ხაზის
ქვიშა, რომ რამეს მარცხენა

1622
01:21:09,810 --> 01:21:12,610
ეკუთვნის ერთ სიმებიანი, ან ერთი მონაცემების ტიპის.

1623
01:21:12,610 --> 01:21:15,480
და არაფერი მარჯვნივ
ეკუთვნის რაღაც.

1624
01:21:15,480 --> 01:21:17,440
Andi სახელი, იმავდროულად,
რომელიც მხოლოდ ვიზუალურად

1625
01:21:17,440 --> 01:21:21,310
ხდება გადაიტანოთ შესახებ, რომ მეორე ხაზი,
მაგრამ ეს მხოლოდ ესთეტიკური დეტალურად

1626
01:21:21,310 --> 01:21:23,990
ანალოგიურად არის nul წყდება.

1627
01:21:23,990 --> 01:21:29,290
>> ეს არის სიმებიანი A-N-D-I გმირები,
პლუს მეხუთე საიდუმლო ხასიათი,

1628
01:21:29,290 --> 01:21:33,560
ყველა 0 ბიტი, რომ მხოლოდ demarcates
ბოლოს Andi სახელი ისევე.

1629
01:21:33,560 --> 01:21:37,120
და თუ ჩვენ მოვუწოდებთ მიიღოს სიმებიანი მესამედ
კომპიუტერული მისაღებად სიმებიანი მოსწონს

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, ასეთივე არის მარია
სახელი nul წყდება წარმატებული 0.

1631
01:21:44,210 --> 01:21:47,170
>> ეს არის ფუნდამენტურად განსხვავებული
ეხლა როგორ კომპიუტერი, როგორც წესი,

1632
01:21:47,170 --> 01:21:51,850
შესანახად რიცხვი, ან float, ან სხვა
მონაცემთა ტიპები მაინც, იმიტომ, რომ გავიხსენოთ,

1633
01:21:51,850 --> 01:21:57,420
რიცხვი, როგორც წესი, 32 ბიტი, ან
4 ბაიტი, ან თუნდაც 64 ბიტი,

1634
01:21:57,420 --> 01:21:59,100
ან რვა ბაიტს.

1635
01:21:59,100 --> 01:22:02,620
მაგრამ ბევრი primitives in კომპიუტერი
პროგრამირების ენა

1636
01:22:02,620 --> 01:22:05,550
ფიქსირებული ნომერი
bytes ქვეშ hood--

1637
01:22:05,550 --> 01:22:08,100
შესაძლოა, 1, შესაძლოა, 2, იქნებ 4, შესაძლოა, 8.

1638
01:22:08,100 --> 01:22:13,250
>> მაგრამ სიმები, დიზაინი, აქვს
დინამიური რაოდენობის სიმბოლოს.

1639
01:22:13,250 --> 01:22:16,980
თქვენ არ ვიცი წინასწარ, სანამ
ადამიანის სახის Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
ან M-A-R-I-A, ან A-N-D-I. თქვენ არ ვიცი
რამდენჯერ შესახებ აპირებს მოხვდა

1641
01:22:21,400 --> 01:22:22,070
კლავიატურაზე.

1642
01:22:22,070 --> 01:22:26,490
აქედან გამომდინარე, თუ თქვენ არ იცით, თუ როგორ
ბევრი პერსონაჟი წინასწარ

1643
01:22:26,490 --> 01:22:27,540
თქვენ აპირებთ უნდა.

1644
01:22:27,540 --> 01:22:31,840
>> ასე რომ, C უბრალოდ სახის ტოვებს მოსწონს
საიდუმლო breadcrumb ქვეშ hood

1645
01:22:31,840 --> 01:22:32,960
ბოლოს სიმებიანი.

1646
01:22:32,960 --> 01:22:39,280
მას შემდეგ, რაც შენახვის Z-A-M-Y-L-A მეხსიერება,
მას ასევე მხოლოდ აყენებს ექვივალენტი

1647
01:22:39,280 --> 01:22:40,210
პერიოდი.

1648
01:22:40,210 --> 01:22:45,060
ბოლოს სასჯელი,
ეს აყენებს 80 ბიტი, ისე, რომ

1649
01:22:45,060 --> 01:22:49,120
უნდა გვახსოვდეს, სადაც
Zamyla იწყება და მთავრდება.

1650
01:22:49,120 --> 01:22:51,490
>> ასე რომ, რა კავშირი,
მაშინ, ეს პროგრამა?

1651
01:22:51,490 --> 01:22:55,190
ეს პროგრამა აქ, Stirling,
უბრალოდ მექანიზმი

1652
01:22:55,190 --> 01:22:57,970
მიღების სიმებიანი
შესახებ, line 6.

1653
01:22:57,970 --> 01:23:01,160
Line 7, ვაცხადებ ცვლადი
მოუწოდა N და ვაყენებთ მას ტოლი 0.

1654
01:23:01,160 --> 01:23:08,680
>> ხოლო შემდეგ ხაზი 8, მე უბრალოდ სთხოვა
კითხვაზე, ხოლო n-th ხასიათი აქვს

1655
01:23:08,680 --> 01:23:12,120
არ უდრის ყველა 0 ბიტი
სხვა სიტყვებით, არ

1656
01:23:12,120 --> 01:23:14,500
თანაბარი ამ სპეციალური
ხასიათი, წარმატებული 0, რაც

1657
01:23:14,500 --> 01:23:18,470
იყო მხოლოდ, რომ სპეციალური nul პერსონაჟი
წავიდეთ წინ და მხოლოდ ნამატი n.

1658
01:23:18,470 --> 01:23:21,460
>> და აკეთეთ ის, და შეინახოს
ამის გაკეთება, და აკეთეთ ის.

1659
01:23:21,460 --> 01:23:23,430
ასე რომ, მიუხედავად იმისა, რომ
წარსულში ჩვენ გამოიყენება i,

1660
01:23:23,430 --> 01:23:25,181
ეს შესანიშნავად ჯარიმა
სემანტიკურად გამოიყენოს ო,

1661
01:23:25,181 --> 01:23:27,430
თუ თქვენ უბრალოდ ცდილობს
იმედი ამ დროს შეგნებულად,

1662
01:23:27,430 --> 01:23:28,720
და უბრალოდ ეძახით n.

1663
01:23:28,720 --> 01:23:34,720
ასე რომ, ეს მხოლოდ ინარჩუნებს სვამს კითხვას,
არის n-ე ხასიათი s ყველა 0S?

1664
01:23:34,720 --> 01:23:38,470
თუ არა, გამოიყურება შემდეგ სახეს,
გამოიყურება შემდეგ, გამოიყურება შემდეგ,

1665
01:23:38,470 --> 01:23:39,460
გამოიყურება შემდეგ.

1666
01:23:39,460 --> 01:23:45,540
>> მაგრამ, როგორც კი ხედავთ წარმატებული 0,
ამ მარყუჟის ხაზი 9 11-- შეწყვეტს.

1667
01:23:45,540 --> 01:23:49,640
თქვენ შესვენება, ხოლო მარყუჟის,
რის გამოც შიგნით რომ ცვლადი n

1668
01:23:49,640 --> 01:23:54,530
სულ გრაფი ყველა
სიმბოლოების სიმებიანი დაინახა,

1669
01:23:54,530 --> 01:23:55,660
ამით ბეჭდვის ის.

1670
01:23:55,660 --> 01:23:56,760
მოდით ცდილობენ.

1671
01:23:56,760 --> 01:23:59,500
>> ნება მომეცით წავიდეთ წინ და გარეშე
გამოყენებით Stirling ფუნქცია,

1672
01:23:59,500 --> 01:24:04,240
მაგრამ მხოლოდ გამოყენებით საკუთარი homegrown მობილური
აქ მოუწოდა Stirling, ნება მომეცით წავიდეთ წინ

1673
01:24:04,240 --> 01:24:07,700
და აწარმოებს Stirling, ტიპის რაღაც
მოსწონს Zamyla, რაც მე ვიცი წინასწარ

1674
01:24:07,700 --> 01:24:08,670
არის ექვსი სიმბოლო.

1675
01:24:08,670 --> 01:24:10,080
ვნახოთ, თუ იგი მუშაობს.

1676
01:24:10,080 --> 01:24:10,920
მართლაც, ეს ექვსი.

1677
01:24:10,920 --> 01:24:15,257
მოდით ცდილობენ რობ სამი პერსონაჟი,
სამი პერსონაჟი, ისევე, და სხვ.

1678
01:24:15,257 --> 01:24:17,340
ასე რომ, ყველა, რომ აპირებს
ქვეშ hood.

1679
01:24:17,340 --> 01:24:19,548
და შენიშნავს, კავშირები,
მაშინ, პირველ კვირას

1680
01:24:19,548 --> 01:24:22,370
კლასი, სადაც ჩვენ ვისაუბრეთ
რაღაც აბსტრაქცია,

1681
01:24:22,370 --> 01:24:26,960
რომელიც მხოლოდ ამ layering იდეების, ან
სირთულის, თავზე ძირითად პრინციპებს.

1682
01:24:26,960 --> 01:24:30,710
აქ, ჩვენ ერთგვარი ეძებს
ქვეშ hood Stirling,

1683
01:24:30,710 --> 01:24:33,510
ასე ვთქვათ, გაერკვნენ,
როგორ უნდა განხორციელდეს?

1684
01:24:33,510 --> 01:24:35,232
>> და ჩვენ შეგვიძლია ხელახლა განახორციელოს იგი საკუთარ თავს.

1685
01:24:35,232 --> 01:24:37,440
მაგრამ ჩვენ აღარასოდეს აპირებს
ხელახლა განახორციელოს Stirling.

1686
01:24:37,440 --> 01:24:39,780
ჩვენ უბრალოდ აპირებს
გამოყენება Stirling, რათა

1687
01:24:39,780 --> 01:24:42,100
რეალურად მიიღოთ გარკვეული სიმები სიგრძეზე.

1688
01:24:42,100 --> 01:24:44,200
>> მაგრამ არ არსებობს ჯადოსნური
ქვეშ hood.

1689
01:24:44,200 --> 01:24:46,716
თუ თქვენ იცით, რომ ქვეშ
Hood, string

1690
01:24:46,716 --> 01:24:48,090
მხოლოდ თანმიმდევრობა სიმბოლო.

1691
01:24:48,090 --> 01:24:51,090
და რომ თანმიმდევრობა გმირები
ყველა შეიძლება რიცხობრივი მიმართა

1692
01:24:51,090 --> 01:24:53,330
ერთად bracket 0, bracket
1, bracket 2, და თქვენ

1693
01:24:53,330 --> 01:24:57,420
ვიცი, რომ ბოლოს სიმებიანი არის
განსაკუთრებული ხასიათი, შეგიძლიათ გაერკვნენ

1694
01:24:57,420 --> 01:25:01,710
როგორ უნდა გავაკეთოთ ყველაზე არაფერი
პროგრამა, რადგან ყველა ეს boils ქვემოთ

1695
01:25:01,710 --> 01:25:03,400
ეს კითხვა და წერა მეხსიერება.

1696
01:25:03,400 --> 01:25:06,130
რომ არის, იცვლება და ეძებს
მეხსიერების, ან მოძრავი რამ

1697
01:25:06,130 --> 01:25:10,940
გარშემო მეხსიერების, ბეჭდვა რამ
ეკრანზე, და სხვ.

1698
01:25:10,940 --> 01:25:14,800
>> მოდით ახლა გამოიყენოთ ტენდენციები
გაგება, თუ რა სიმები რეალურად

1699
01:25:14,800 --> 01:25:17,910
ხართ ქვეშ Hood, და
კანი უკან ერთი სხვა ფენის

1700
01:25:17,910 --> 01:25:20,080
რომ აქამდე ჩვენ
იგნორირება საერთოდ.

1701
01:25:20,080 --> 01:25:22,650
კერძოდ, ნებისმიერ დროს
ჩვენ განხორციელებული პროგრამა,

1702
01:25:22,650 --> 01:25:25,930
ჩვენ გვქონდა ამ ხაზი კოდი
ახლოს დაბრუნება გამოცხადების მთავარი.

1703
01:25:25,930 --> 01:25:27,810
და ჩვენ მითითებული int ძირითადი ბათილად.

1704
01:25:27,810 --> 01:25:31,240
>> და რომ ბათილად შიგნით ფრჩხილებში
უკვე განაცხადა, მთელი ამ დროის განმავლობაში, რომ მთავარი

1705
01:25:31,240 --> 01:25:33,440
თავად არ მიიღოს ნებისმიერი არგუმენტები.

1706
01:25:33,440 --> 01:25:36,210
ნებისმიერი შეყვანის რომ მთავარი არის
აპირებს მიიღოს მომხმარებელი

1707
01:25:36,210 --> 01:25:39,020
უნდა მოდიოდეს სხვა
მექანიზმი, ისევე მისაღებად int,

1708
01:25:39,020 --> 01:25:42,040
ან კიდევ float, ან მიიღოთ ტექსტი,
და ზოგიერთი სხვა ფუნქცია.

1709
01:25:42,040 --> 01:25:44,710
მაგრამ აღმოჩნდება, რომ
როდესაც წერთ პროგრამა,

1710
01:25:44,710 --> 01:25:47,690
თქვენ შეგიძლიათ რეალურად დააკონკრეტა
რომ ეს პროგრამა უნდა

1711
01:25:47,690 --> 01:25:51,730
მიიღოს საშუალებებით ადამიანის
ბრძანებათა ზოლს თავად.

1712
01:25:51,730 --> 01:25:56,310
>> სხვა სიტყვებით, მიუხედავად იმისა, რომ დღემდე
უკვე გაშვებული მხოლოდ მიესალმები მიესალმები

1713
01:25:56,310 --> 01:26:00,312
ან მსგავს პროგრამებს, ყველა
სხვა პროგრამები, რომ ჩვენ უკვე გამოყენებით,

1714
01:26:00,312 --> 01:26:02,770
რომ ჩვენ თვითონ არ წერენ,
უკვე აღების, როგორც ჩანს,

1715
01:26:02,770 --> 01:26:05,210
ბრძანების არგუმენტი
რამ, როგორიცაა მიიღოს.

1716
01:26:05,210 --> 01:26:07,450
თქვენ ამბობთ, რომ რაღაც გააკეთოს,
და მერე მეორე სიტყვა.

1717
01:26:07,450 --> 01:26:10,950
ან clang, ითქვას clang და შემდეგ
მეორე სიტყვა, სახელი ფაილი.

1718
01:26:10,950 --> 01:26:14,410
>> ან თუნდაც RM და CP, როგორც თქვენ
არ მინახავს ან უკვე

1719
01:26:14,410 --> 01:26:15,880
ამოიღონ ან კოპირება ფაილი.

1720
01:26:15,880 --> 01:26:18,920
ყველა იმ მიიღოს ე.წ.
ბრძანების არგუმენტი

1721
01:26:18,920 --> 01:26:21,130
დამატებითი სიტყვა ტერმინალში ზოლზე.

1722
01:26:21,130 --> 01:26:23,260
მაგრამ დღემდე, ჩვენ
თავს არ ჰქონდა

1723
01:26:23,260 --> 01:26:27,080
ამ ფუფუნების აღების შეიტანენ
შესახებ, როდესაც ის რეალურად მართავს

1724
01:26:27,080 --> 01:26:29,120
პროგრამა თავისთავად ბრძანებათა ზოლს.

1725
01:26:29,120 --> 01:26:33,710
>> მაგრამ ჩვენ შეგვიძლია გავაკეთოთ, რომ ხელახლა გამოცხადების
მთავარი მიიწევს წინ, არა, როგორც

1726
01:26:33,710 --> 01:26:36,750
ბათილად ფრჩხილებში,
მაგრამ ეს ორი არგუმენტები

1727
01:26:36,750 --> 01:26:40,600
instead-- პირველი რიცხვი,
და მეორე რაღაც

1728
01:26:40,600 --> 01:26:44,170
ახალი, რაღაც რომ ჩვენ ვაპირებთ, რომ მოვუწოდო
მასივი, რაღაც მსგავსი სულისკვეთებით

1729
01:26:44,170 --> 01:26:49,220
რა ვნახეთ Scratch, როგორც სია, მაგრამ
მასივი სიმები, როგორც ჩვენ მალე.

1730
01:26:49,220 --> 01:26:51,790
მაგრამ ვნახოთ, ამ
მაგალითად, სანამ ჩვენ

1731
01:26:51,790 --> 01:26:53,690
ზღვარის ზუსტად რას ნიშნავს ეს.

1732
01:26:53,690 --> 01:26:56,520
>> ასე რომ, თუ მე წასვლას CS50 IDE
აქ, მე წავიდა წინ

1733
01:26:56,520 --> 01:27:01,840
და განაცხადა, ფაილი სახელად
argv0.c შემდეგ template.

1734
01:27:01,840 --> 01:27:04,120
და შენიშნავს, რომ ერთადერთი, რაც
რომ სხვადასხვა ჯერჯერობით

1735
01:27:04,120 --> 01:27:08,570
ის არის, რომ მე შეიცვალა ბათილად int,
argc სიმებიანი argv ღია bracket, ახლოს

1736
01:27:08,570 --> 01:27:09,070
bracket.

1737
01:27:09,070 --> 01:27:11,730
და შეამჩნია, რომ ახლა, იქ
არაფერი შიგნით იმ ფრჩხილებში.

1738
01:27:11,730 --> 01:27:12,620
>> იქ არ არის ნომერი.

1739
01:27:12,620 --> 01:27:15,070
და არ არსებობს მე, ან
n, ან ნებისმიერი სხვა წერილში.

1740
01:27:15,070 --> 01:27:17,010
მე უბრალოდ გამოყენებით
კვადრატულ ფრჩხილებში ახლა,

1741
01:27:17,010 --> 01:27:19,510
მიზეზების გამო, ჩვენ მოვალთ
უკან რაღაც მომენტში.

1742
01:27:19,510 --> 01:27:21,330
>> და ახლა რა მე ვაპირებ ამის გაკეთებას, ეს არის.

1743
01:27:21,330 --> 01:27:26,680
თუ argc უდრის უდრის 2-
და გავიხსენოთ, რომ შეადგენს შეადგენს

1744
01:27:26,680 --> 01:27:30,040
არის თანასწორობის ოპერატორს შედარებით
მარცხენა და მარჯვენა თანასწორობა.

1745
01:27:30,040 --> 01:27:31,790
ეს არ არის დავალება
ოპერატორი, რომელიც არის

1746
01:27:31,790 --> 01:27:36,510
ერთი თანაბარი ნიშანი, რაც იმას ნიშნავს, ასლი
მარჯვნიდან მარცხენა გარკვეული მნიშვნელობა.

1747
01:27:36,510 --> 01:27:42,840
>> თუ argc უდრის უდრის 2, მინდა
ვთქვათ, printf, hello, პროცენტების, ახალი ხაზი,

1748
01:27:42,840 --> 01:27:47,340
ხოლო შემდეგ დანამატის შიგნით და აქ ახალი
ხრიკი argv bracket 1, იმის გამო,

1749
01:27:47,340 --> 01:27:48,840
რომ ჩვენ დავბრუნდებით ამ მომენტში.

1750
01:27:48,840 --> 01:27:52,110
სხვაგან, თუ argc არ
თანაბარი 2, იცით, რა?

1751
01:27:52,110 --> 01:27:57,400
მოდით უბრალოდ წავიდეთ წინ და, როგორც ყოველთვის, ბეჭდვითი
out hello მსოფლიოში არ რიგებში.

1752
01:27:57,400 --> 01:28:02,710
>> ასე რომ, როგორც ჩანს, რომ იმ შემთხვევაში, თუ argc, რომელიც
დგას არგუმენტი რაოდენობა, უდრის 2,

1753
01:28:02,710 --> 01:28:04,740
მე ვაპირებ ამობეჭდოთ
მიესალმები რაღაც ან სხვა.

1754
01:28:04,740 --> 01:28:07,560
წინააღმდეგ შემთხვევაში, ძირითადად, მე
აპირებს ბეჭდვა hello მსოფლიოში.

1755
01:28:07,560 --> 01:28:08,770
ასე რომ, რას ნიშნავს ეს?

1756
01:28:08,770 --> 01:28:15,550
>> ასევე, ნება მომეცით წავიდეთ წინ და შენახვა
ეს ფაილი და შემდეგ გააკეთოს argv0,

1757
01:28:15,550 --> 01:28:18,940
და შემდეგ ./argv0, შეიტანეთ.

1758
01:28:18,940 --> 01:28:20,300
ის ამბობს hello მსოფლიოში.

1759
01:28:20,300 --> 01:28:21,260
ახლა, რატომ არის, რომ?

1760
01:28:21,260 --> 01:28:24,730
>> ისე, გამოდის, ნებისმიერ დროს
აწარმოებს პროგრამის ბრძანების,

1761
01:28:24,730 --> 01:28:29,570
თქვენ შევსების, რაც ჩვენ
ზოგადად მოვუწოდებთ არგუმენტი ვექტორი.

1762
01:28:29,570 --> 01:28:33,100
სხვა სიტყვებით, ავტომატურად
კომპიუტერი, ოპერაციული სისტემა,

1763
01:28:33,100 --> 01:28:38,340
აპირებს გადასცემს თქვენი პროგრამა
თავად სიაში ყველა სიტყვა

1764
01:28:38,340 --> 01:28:40,850
რომ ადამიანის აკრეფილი
სწრაფი, იმ შემთხვევაში, თუ

1765
01:28:40,850 --> 01:28:43,790
პროგრამისტი მინდა ამის გაკეთება
რაღაც, რომ ინფორმაცია.

1766
01:28:43,790 --> 01:28:48,540
და ამ შემთხვევაში, მხოლოდ სიტყვა
მე აკრეფილი ბრძანებათა ზოლში არის ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> ასე რომ, ნომერი არგუმენტები, რომ არის
მიმდინარეობს გავიდა ჩემი პროგრამა არის მხოლოდ ერთი.

1768
01:28:55,420 --> 01:28:58,880
სხვა სიტყვებით, არგუმენტი
იმედი, სხვაგვარად ცნობილია როგორც argc

1769
01:28:58,880 --> 01:29:00,970
აქ, როგორც მთელი რიცხვი, არის მხოლოდ ერთი.

1770
01:29:00,970 --> 01:29:03,000
ერთ-ერთი, რა თქმა უნდა, არ თანაბარი ორი.

1771
01:29:03,000 --> 01:29:05,980
ასე რომ, ეს არის ის, რაც ბეჭდავს, hello მსოფლიოში.

1772
01:29:05,980 --> 01:29:08,170
>> მაგრამ ნება მომეცით მიიღოს ეს სადღაც.

1773
01:29:08,170 --> 01:29:09,930
მინდა ვთქვა, argv0.

1774
01:29:09,930 --> 01:29:12,740
და მაშინ როგორ შესახებ Maria?

1775
01:29:12,740 --> 01:29:14,990
და შემდეგ დააჭიროთ.

1776
01:29:14,990 --> 01:29:18,020
>> და შეამჩნია რა magically ხდება აქ.

1777
01:29:18,020 --> 01:29:22,640
ახლა, ნაცვლად Hello World, მე მაქვს
შეცვალა ქცევა ამ პროგრამის

1778
01:29:22,640 --> 01:29:26,310
აღების შეყვანის არა მისაღებად
სიმებიანი ან ზოგიერთი სხვა ფუნქცია,

1779
01:29:26,310 --> 01:29:30,570
მაგრამ, როგორც ჩანს, ჩემი ბრძანება
თავისთავად, რაც მე თავდაპირველად აკრეფილი.

1780
01:29:30,570 --> 01:29:35,720
მე და შეგიძლიათ ითამაშოთ ეს თამაში ისევ
შეცვლის მას Stelios, მაგალითად.

1781
01:29:35,720 --> 01:29:38,400
>> და ახლა მე ვხედავ სხვა სახელი მაინც.

1782
01:29:38,400 --> 01:29:40,540
და აქ, მე შეიძლება ითქვას Andi.

1783
01:29:40,540 --> 01:29:42,137
და შეიძლება ითქვას, Zamyla.

1784
01:29:42,137 --> 01:29:45,220
და ჩვენ შეგვიძლია ითამაშოს ამ თამაშში მთელი დღის განმავლობაში,
უბრალოდ ჩართვის განსხვავებული ღირებულებები,

1785
01:29:45,220 --> 01:29:49,550
ასე რომ, სანამ მე გთავაზობთ ზუსტად
ორი სიტყვა დროს სწრაფი,

1786
01:29:49,550 --> 01:29:52,260
ისეთი, რომ argc, ჩემი არგუმენტი ითვლიან, 2.

1787
01:29:52,260 --> 01:29:57,240
>> ვხედავ, რომ სახელი plugged შევიდა
printf, პოსტი ამ მდგომარეობის აქ?

1788
01:29:57,240 --> 01:30:00,550
ასე რომ, ჩვენ, როგორც ჩანს, ახლა
ექსპრესიული შესაძლებლობების

1789
01:30:00,550 --> 01:30:04,410
აღების შეყვანის კიდევ ერთი მექანიზმი,
საწყისი ე.წ. ბრძანების,

1790
01:30:04,410 --> 01:30:07,000
ვიდრე დაველოდოთ
სანამ მომხმარებლის ეშვება პროგრამა,

1791
01:30:07,000 --> 01:30:10,220
და შემდეგ გამოიწვიოს მას
გამოყენებით რაღაც მიიღოს სიმებიანი.

1792
01:30:10,220 --> 01:30:11,230
>> ასე რომ, რა არის ეს?

1793
01:30:11,230 --> 01:30:15,010
Argc, კიდევ ერთხელ, მხოლოდ რიცხვი,
რაოდენობის words-- არგუმენტი

1794
01:30:15,010 --> 01:30:18,540
რომ მომხმარებელს უზრუნველყოფილი
სწრაფი, ტერმინალში ფანჯარა,

1795
01:30:18,540 --> 01:30:20,110
მათ შორის, პროგრამის სახელი.

1796
01:30:20,110 --> 01:30:23,340
ასე რომ, ჩვენი ./argv0, პრაქტიკულად,
პროგრამის სახელი,

1797
01:30:23,340 --> 01:30:24,520
ან როგორ აწარმოებს პროგრამა.

1798
01:30:24,520 --> 01:30:25,810
>> რომ ითვლის როგორც სიტყვა.

1799
01:30:25,810 --> 01:30:27,080
ასე რომ, argc იქნება 1.

1800
01:30:27,080 --> 01:30:29,750
მაგრამ, როდესაც ვწერ Stelios, ან
Andi, ან Zamyla, და მარია,

1801
01:30:29,750 --> 01:30:31,660
ეს ნიშნავს, რომ არგუმენტი რაოდენობა ორი.

1802
01:30:31,660 --> 01:30:33,910
ასე რომ, ახლა არსებობს ორი სიტყვა გავიდა.

1803
01:30:33,910 --> 01:30:36,070
>> და შეამჩნია, რომ ჩვენ შეგვიძლია გავაგრძელოთ ამ ლოგიკით.

1804
01:30:36,070 --> 01:30:39,050
თუ მე რეალურად ამბობენ
რაღაც Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
სრული სახელი, რითაც ავლით
სამი არგუმენტები საერთო ჯამში,

1806
01:30:42,200 --> 01:30:47,410
ახლა იგი აცხადებს, რომ ძირითადად, კიდევ ერთხელ,
იმიტომ, რომ, რა თქმა უნდა, 3 არ უდრის 2.

1807
01:30:47,410 --> 01:30:54,080
>> ასე რომ, ამ გზით, მაქვს
მეშვეობით argv ახალი არგუმენტი

1808
01:30:54,080 --> 01:30:56,080
რომ ჩვენ შეგვიძლია ტექნიკურად
მოვუწოდებთ არაფერი გვინდა.

1809
01:30:56,080 --> 01:30:58,940
მაგრამ კონვენციის, ეს
argv და argc, შესაბამისად.

1810
01:30:58,940 --> 01:31:04,470
Argv, არგუმენტი ვექტორი, არის ერთგვარი
საქართველოს სინონიმი პროგრამირების

1811
01:31:04,470 --> 01:31:07,140
ფუნქცია C მოუწოდა მასივი.

1812
01:31:07,140 --> 01:31:14,410
>> მასივი ჩამოთვლილია მსგავსი ღირებულებები
უკან, უკან, უკან, უკან.

1813
01:31:14,410 --> 01:31:17,810
სხვა სიტყვებით, თუ ერთი უფლება აქ
RAM, შემდეგი ერთი არის სწორი, რომ ეს,

1814
01:31:17,810 --> 01:31:18,800
და მარჯვენა შემდეგი მას.

1815
01:31:18,800 --> 01:31:20,101
ისინი არ მთელი ადგილი.

1816
01:31:20,101 --> 01:31:23,100
და რომ ეს უკანასკნელი სცენარი, სადაც ყველაფერი
არიან მთელი ადგილი მეხსიერებაში,

1817
01:31:23,100 --> 01:31:25,082
შეიძლება რეალურად იყოს ძლიერი თვისება.

1818
01:31:25,082 --> 01:31:28,040
მაგრამ ჩვენ დავბრუნდებით, რომ როდესაც ჩვენ
ვისაუბროთ fancier მონაცემების სტრუქტურები.

1819
01:31:28,040 --> 01:31:32,260
ახლა, მასივი არის მხოლოდ
ბლოკი მიმდებარე მეხსიერების,

1820
01:31:32,260 --> 01:31:36,520
თითოეული რომლის ელემენტები არიან
უკან, უკან, უკან, უკან,

1821
01:31:36,520 --> 01:31:38,050
და საერთოდ, იგივე ტიპის.

1822
01:31:38,050 --> 01:31:42,630
>> ასე რომ, თუ თქვენ ფიქრობთ, საწყისი
მომენტში წინ, რა არის სიმებიანი?

1823
01:31:42,630 --> 01:31:50,460
ისე, სიმებიანი, როგორიცაა Zamyla,
Z-A-M-Y-L-A, არის, ტექნიკურად,

1824
01:31:50,460 --> 01:31:51,400
მხოლოდ მასივი.

1825
01:31:51,400 --> 01:31:53,700
ეს მასივი სიმბოლო.

1826
01:31:53,700 --> 01:31:59,250
>> ასე რომ, თუ ჩვენ ნამდვილად მიაპყროს ამ, როგორც მე
გავაკეთეთ ადრე, როგორც ბლოკი მეხსიერება,

1827
01:31:59,250 --> 01:32:04,510
გამოდის, რომ თითოეული ეს
გმირები იკავებს byte.

1828
01:32:04,510 --> 01:32:07,630
და მერე იქ რომ სპეციალური
Sentinel ხასიათი, წარმატებული 0,

1829
01:32:07,630 --> 01:32:12,360
ან ყველა რვა 0 ბიტი,
demarcates ბოლოს რომ სიმებიანი.

1830
01:32:12,360 --> 01:32:15,090
ასე რომ, სიმებიანი, გამოდის
გარეთ, შეთავაზება unquote სიმებიანი,

1831
01:32:15,090 --> 01:32:20,580
მხოლოდ მასივი chara--
char რომ ფაქტობრივი მონაცემების ტიპის.

1832
01:32:20,580 --> 01:32:24,560
>> და ახლა argv, meanwhile--
მოდით დავუბრუნდეთ პროგრამა.

1833
01:32:24,560 --> 01:32:29,582
Argv, მიუხედავად იმისა, რომ ჩვენ ვხედავთ სიტყვას
სიმებიანი აქ, არ არის სიმებიანი თავად.

1834
01:32:29,582 --> 01:32:33,640
Argv, არგუმენტი ვექტორი,
არის მასივი strings.

1835
01:32:33,640 --> 01:32:37,620
>> ასე რომ, როგორც თქვენ შეგიძლიათ მასივი
გმირები, შეგიძლიათ მაღალ დონეზე,

1836
01:32:37,620 --> 01:32:46,279
მასივი strings-- ასე, მაგალითად,
როდესაც მე აკრეფილი მომენტში წინ ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, სივრცე Z-A-M-Y-L-A, ვამბობდი, რომ
argv გვქონდა ორი სიმები in it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
და Z-A-M-Y-L-A. in
სხვა სიტყვებით, argc 2.

1839
01:33:03,185 --> 01:33:03,980
რატომ არის, რომ?

1840
01:33:03,980 --> 01:33:08,370
>> ისე, ეფექტურად, თუ რა ხდება
ის არის, რომ თითოეული ამ strings

1841
01:33:08,370 --> 01:33:13,990
არის, რა თქმა უნდა, მასივი გმირები
როგორც ადრე, თითოეული რომლის გმირები

1842
01:33:13,990 --> 01:33:15,670
იღებს ერთი ბაიტი.

1843
01:33:15,670 --> 01:33:19,720
და არ აღრეული ფაქტობრივი 0
პროგრამაში სახელს 0,

1844
01:33:19,720 --> 01:33:22,040
რაც იმას ნიშნავს, ყველა 80 ბიტი.

1845
01:33:22,040 --> 01:33:27,140
და Zamyla, იმავდროულად, არის კიდევ
ასევე მასივი სიმბოლო.

1846
01:33:27,140 --> 01:33:31,450
>> ასე რომ, დღის ბოლოს, ეს ნამდვილად
ასე გამოიყურება ქვეშ hood.

1847
01:33:31,450 --> 01:33:38,800
მაგრამ argv, ბუნებით, თუ როგორ მთავარი
სამუშაოები, საშუალებას მაძლევს, რომ გადაიტანოთ ეს ყველაფერი

1848
01:33:38,800 --> 01:33:44,810
შევიდა, თუ გნებავთ, უფრო დიდი მასივი
რომ, თუ ჩვენ ოდნავ მეტი გაამარტივებს

1849
01:33:44,810 --> 01:33:48,180
რა სურათზე ჰგავს და არ
საკმაოდ დახაზვა გავაფართოვოთ იქ,

1850
01:33:48,180 --> 01:33:56,720
ამ მასივი მხოლოდ ზომა 2, პირველი
ელემენტს, რომელიც შეიცავს სიმებიანი,

1851
01:33:56,720 --> 01:33:59,230
მეორე ელემენტს
რომელიც შეიცავს სიმებიანი.

1852
01:33:59,230 --> 01:34:01,687
და, თავის მხრივ, თუ თქვენ
სახის მიუახლოვდით თითოეულ

1853
01:34:01,687 --> 01:34:03,770
იმ strings, რას
ვხედავ ქვეშ hood

1854
01:34:03,770 --> 01:34:07,190
არის, რომ თითოეული სიმებიანი მხოლოდ
მასივი სიმბოლო.

1855
01:34:07,190 --> 01:34:11,680
>> ახლა, ისევე როგორც სიმები,
ჩვენ შევძელით, რომ მიიღოთ დაშვება

1856
01:34:11,680 --> 01:34:15,260
რომ i-th პერსონაჟი სიმებიანი
გამოყენებით, რომ კვადრატული ფრჩხილი ნოტაცია.

1857
01:34:15,260 --> 01:34:17,320
ანალოგიურად, მასივები
ზოგადად, შეგვიძლია

1858
01:34:17,320 --> 01:34:22,700
გამოყენება კვადრატულ bracket notation მისაღებად
ნებისმიერ რაოდენობა სიმებიანი მასივი?

1859
01:34:22,700 --> 01:34:25,100
მაგალითად, ნება მომეცით
წავიდეთ წინ და ამის გაკეთება.

1860
01:34:25,100 --> 01:34:32,420
>> ნება მომეცით წავიდეთ წინ და შექმნას argv1.c,
რომელიც ცოტა განსხვავებული ამ დროს.

1861
01:34:32,420 --> 01:34:35,635
იმის ნაცვლად, რომ შემოწმების argc2,
მე ვაპირებ ნაცვლად ამის გაკეთება.

1862
01:34:35,635 --> 01:34:41,270
განთავსების int მივიღებ 0, მე ნაკლებად
ვიდრე argc, მე plus plus,

1863
01:34:41,270 --> 01:34:47,920
და შემდეგ ამობეჭდოთ შიგნით ამ,
პროცენტს s, ახალი ხაზი, და შემდეგ

1864
01:34:47,920 --> 01:34:50,740
argv bracket i.

1865
01:34:50,740 --> 01:34:55,220
>> სხვა სიტყვებით, მე არ საქმე
ინდივიდუალური გმირები მომენტში.

1866
01:34:55,220 --> 01:35:00,190
Argv, როგორც ითვალისწინებს ამ ცარიელი მოედანი
braces მარჯვნივ სახელი argv,

1867
01:35:00,190 --> 01:35:03,320
ნიშნავს argv არის მასივი სტრიქონები.

1868
01:35:03,320 --> 01:35:04,870
და argc მხოლოდ int.

1869
01:35:04,870 --> 01:35:08,800
>> ეს ხაზი აქ, 6, არის
ამბობდა კომპლექტი i = 0.

1870
01:35:08,800 --> 01:35:11,980
ითვლიან ყველა გზა მდე,
მაგრამ არა, argc.

1871
01:35:11,980 --> 01:35:14,010
და შემდეგ თითოეულ iteration,
ამობეჭდოთ სიმებიანი.

1872
01:35:14,010 --> 01:35:14,800
რა სიმებიანი?

1873
01:35:14,800 --> 01:35:17,270
>> I-th სიმებიანი argv.

1874
01:35:17,270 --> 01:35:19,530
ასე რომ, მაშინ ადრე ვიყავი
გამოყენებით კვადრატული ფრჩხილი

1875
01:35:19,530 --> 01:35:22,180
notation მისაღებად ზე შ
პერსონაჟი სიმებიანი, ახლა

1876
01:35:22,180 --> 01:35:27,240
მე გამოყენებით კვადრატული ფრჩხილი ნოტაცია
მისაღებად ზე შ სიმებიანი მასივი.

1877
01:35:27,240 --> 01:35:30,310
ასე რომ, ეს არის ერთგვარი ერთი ფენა
ზემოთ, კონცეპტუალურად.

1878
01:35:30,310 --> 01:35:35,390
>> ასე რომ, რა არის გარღვევა ამ
პროგრამა არის, თუ მე კომპილაციის argv1,

1879
01:35:35,390 --> 01:35:42,067
და შემდეგ გააკეთოს ./argv1, და შემდეგ აკრიფოთ
რაღაც foo ბარი baz,

1880
01:35:42,067 --> 01:35:45,400
რომლებიც სამი ძირითადად სიტყვები, რომ
კომპიუტერული მეცნიერი აღწევს ნებისმიერ დროს

1881
01:35:45,400 --> 01:35:51,010
მას სჭირდება გარკვეული ჩანაცვლების სიტყვები,
და დააჭიროთ, თითოეული იმ სიტყვებით,

1882
01:35:51,010 --> 01:35:54,980
მათ შორის, პროგრამის სახელწოდება, რომელიც
არის argv პირველ ადგილას,

1883
01:35:54,980 --> 01:35:58,320
მთავრდება იბეჭდება ერთ დროს.

1884
01:35:58,320 --> 01:36:05,290
და თუ მე შეცვალოს ეს, და მე ვიტყვი,
რაღაც argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
მივიღებთ სამივე იმ
სიტყვა, რომელიც argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, რადგან ამ
შემთხვევაში argc, რაოდენობა, არის 3.

1887
01:36:14,400 --> 01:36:20,020
>> მაგრამ რა არის გარღვევა არის თუ გესმით
რომ argv მხოლოდ მასივი strings,

1888
01:36:20,020 --> 01:36:24,910
და თქვენ იცით, რომ სიმებიანი
არის მასივი გმირები,

1889
01:36:24,910 --> 01:36:29,470
ჩვენ შეგვიძლია რეალურად სახის გამოიყენოს ეს
კვადრატული ფრჩხილი ნოტაცია რამდენჯერმე

1890
01:36:29,470 --> 01:36:33,320
აირჩიოს სიმებიანი და შემდეგ აირჩიოს
ხასიათი ფარგლებში სიმებიანი,

1891
01:36:33,320 --> 01:36:35,730
diving ღრმა ასეთია.

1892
01:36:35,730 --> 01:36:40,100
ამ მაგალითად, ნება მომეცით წავიდეთ
წინ და დაარქვით argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
და ამ მაგალითად, ნება მომეცით წავიდეთ წინ
და გავაკეთოთ შემდეგი for int i მისაღებად 0,

1895
01:36:50,180 --> 01:36:53,286
i ნაკლებია, ვიდრე argc, i პლუს
პლუს, ისევე როგორც ადრე.

1896
01:36:53,286 --> 01:36:55,910
ასე რომ, სხვა words-- და ახლა ეს
დღითიდღე რთული.

1897
01:36:55,910 --> 01:36:59,940
ამის შემდეგ მე ვაპირებ ვთქვა
გადაურბინოთ სიმებიანი argv,

1898
01:36:59,940 --> 01:37:01,294
როგორც კომენტარი თავს.

1899
01:37:01,294 --> 01:37:03,960
და შემდეგ მე ვაპირებ აქვს
წყობილი მარყუჟის, რომელიც, ალბათ,

1900
01:37:03,960 --> 01:37:06,290
არ კეთდება, ან განიხილება
აკეთებს, Scratch, სადაც

1901
01:37:06,290 --> 01:37:08,600
მე ვაპირებ ვთქვა გაკეთება int ვარ
არ ვაპირებთ გამოვიყენოთ ისევ,

1902
01:37:08,600 --> 01:37:12,590
იმიტომ, რომ მე არ მინდა, რომ დაჩრდილოს, ან
ერთგვარი გადავაწერო არსებულ i.

1903
01:37:12,590 --> 01:37:15,780
>> მე ვაპირებ, ნაცვლად, ვთქვათ, j, იმიტომ,
ეს არის ჩემი გადასვლა ცვლადი შემდეგ i,

1904
01:37:15,780 --> 01:37:18,590
როდესაც მე უბრალოდ ცდილობს
იმედი მარტივი ნომრები.

1905
01:37:18,590 --> 01:37:28,850
იყიდება j იღებს 0- და ასევე, n, აპირებს
მიიღეთ stern სიგრძე argv bracket i,

1906
01:37:28,850 --> 01:37:36,030
ასე რომ, სანამ კ ნაკლებია, ვიდრე მ,
j პლუს პლუს, ამის შემდეგ.

1907
01:37:36,030 --> 01:37:37,500
აქ არის საინტერესო.

1908
01:37:37,500 --> 01:37:46,330
>> ამობეჭდოთ ხასიათი და ახალი ხაზი,
ჩართვის argv bracket i, bracket კ.

1909
01:37:46,330 --> 01:37:47,940
OK, ნება მომეცით დაამატოთ ზოგიერთი კომენტარი აქ.

1910
01:37:47,940 --> 01:37:54,820
გადაურბინოთ გმირები
მიმდინარე სიმებიანი,

1911
01:37:54,820 --> 01:38:02,290
ბეჭდვითი j-th ხასიათი i-th სიმებიანი.

1912
01:38:02,290 --> 01:38:04,630
ახლა, მოდით, განვიხილოთ
რა ეს კომენტარი ნიშნავს.

1913
01:38:04,630 --> 01:38:06,750
>> გადაურბინოთ სიმები
in argv-- რამდენი

1914
01:38:06,750 --> 01:38:09,300
სიმები არიან argv, რომელიც არის მასივი?

1915
01:38:09,300 --> 01:38:13,420
Argc ბევრი, ასე რომ მე iterating
ეხლა მე გაუტოლდება 0 მდე argc.

1916
01:38:13,420 --> 01:38:20,020
იმავდროულად, რამდენი გმირები
არიან i-th სიმებიანი argv?

1917
01:38:20,020 --> 01:38:22,880
>> ისე, რომ მიიღოს, რომ პასუხი,
მე უბრალოდ დარეკოთ სიმებიანი სიგრძე

1918
01:38:22,880 --> 01:38:26,810
მიმდინარე სიმებიანი მოვლა
შესახებ, რომელიც argv bracket i.

1919
01:38:26,810 --> 01:38:30,090
და მე ვაპირებ დროებით შესანახად, რომ
მნიშვნელობა N, უბრალოდ ქეშირების მიზნებისათვის,

1920
01:38:30,090 --> 01:38:31,590
უნდა გვახსოვდეს, რომ ეს ეფექტურობა.

1921
01:38:31,590 --> 01:38:36,330
და შემდეგ მე ვაპირებ ინიციალიზაცია j 0,
შენარჩუნებას აპირებს მანამ, სანამ კ ნაკლებია, ვიდრე n,

1922
01:38:36,330 --> 01:38:38,430
და თითოეულ iteration ბიჯი კ.

1923
01:38:38,430 --> 01:38:41,030
>> და მაშინ აქ, თითო
ჩემი კომენტარი on line 12

1924
01:38:41,030 --> 01:38:43,390
ამობეჭდოთ ხასიათი,
მოყვება ახალი ხაზი,

1925
01:38:43,390 --> 01:38:48,140
კონკრეტულად argv bracket
i მაძლევს i-th string

1926
01:38:48,140 --> 01:38:51,690
in argv-- ასე რომ, პირველი სიტყვა,
მეორე სიტყვა, მესამე სიტყვა, რასაც.

1927
01:38:51,690 --> 01:38:57,370
და შემდეგ კ dives ღრმა, და იღებს
ჩემთვის j-ე ხასიათი, რომ სიტყვა.

1928
01:38:57,370 --> 01:39:02,200
ასე რომ, ფაქტობრივად, შეგიძლიათ მკურნალობა
argv როგორც მრავალ განზომილებიანი,

1929
01:39:02,200 --> 01:39:06,050
როგორც ორგანზომილებიანი, მასივი,
რომლის დროსაც ყოველი სიტყვა სახის გამოიყურება

1930
01:39:06,050 --> 01:39:08,580
მოსწონს ეს თქვენი აზრით
თვალი, და ყოველ ხასიათი

1931
01:39:08,580 --> 01:39:10,930
არის სახის შედგება
სვეტი, თუ, რომელიც ეხმარება.

1932
01:39:10,930 --> 01:39:13,260
>> სინამდვილეში, როდესაც ჩვენ tease
ამ გარდა მომავალში კვირის განმავლობაში,

1933
01:39:13,260 --> 01:39:15,580
ის აპირებს, რომ იყოს პატარა
უფრო დახვეწილი, ვიდრე.

1934
01:39:15,580 --> 01:39:17,800
მაგრამ თქვენ ნამდვილად
ვფიქრობ, რომ ახლა,

1935
01:39:17,800 --> 01:39:22,110
როგორც მხოლოდ ამ ორგანზომილებიანი
მასივი, რომლის ერთ დონეზე ეს

1936
01:39:22,110 --> 01:39:23,260
არის ყველა სიმები.

1937
01:39:23,260 --> 01:39:26,760
და მაშინ, თუ თქვენ ჩაყვინთვის უფრო ღრმა, თქვენ
შეგიძლიათ მიიღოთ ინდივიდუალური სიმბოლოების

1938
01:39:26,760 --> 01:39:29,600
მასში გამოყენებით ამ notation აქ.

1939
01:39:29,600 --> 01:39:31,620
>> ასე რომ, რა არის წმინდა ეფექტი?

1940
01:39:31,620 --> 01:39:34,970
ნება მომეცით წავიდეთ წინ და
რათა argv2-- darn იგი.

1941
01:39:34,970 --> 01:39:36,210
შევცდი აქ.

1942
01:39:36,210 --> 01:39:40,160
მინიშნებით გამოცხადების
ბიბლიოთეკის ფუნქცია Stirling.

1943
01:39:40,160 --> 01:39:42,190
ამიტომ, ამ დროს, ეს
ალბათ შესაბამისი

1944
01:39:42,190 --> 01:39:45,130
რომ ჩვენ ერთგვარი დასრულების
სწორედ იქ, სადაც ჩვენ დავიწყეთ.

1945
01:39:45,130 --> 01:39:48,160
>> მე ბრალია, მინიშნებით გამოცხადების
ბიბლიოთეკის ფუნქცია Stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, დაველოდოთ წუთში.

1947
01:39:48,987 --> 01:39:51,070
მახსოვს, რომ, განსაკუთრებით
მას შემდეგ, რაც არის აქ.

1948
01:39:51,070 --> 01:39:54,490
მე უნდა შეიცავდეს string.h in
ეს ვერსია პროგრამა.

1949
01:39:54,490 --> 01:40:00,050
>> ნება მომეცით წავიდეთ წინ და მოიცავს
string.h, შენახვა, რომ, წავიდეთ წინ

1950
01:40:00,050 --> 01:40:04,460
და recompile argv2.

1951
01:40:04,460 --> 01:40:08,390
და ახლა, აქ ჩვენ მივდივართ, რათა argv2, შეიტანეთ.

1952
01:40:08,390 --> 01:40:10,590
მიუხედავად იმისა, რომ ეს არის პატარა
cryptic ერთი შეხედვით,

1953
01:40:10,590 --> 01:40:15,690
შეამჩნევთ, რომ, მართლაც, რა
იბეჭდება არის dot argv2.

1954
01:40:15,690 --> 01:40:19,970
>> მაგრამ თუ მე აკრიფოთ ზოგიერთი სიტყვა შემდეგ
სწრაფი, როგორც argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
შეიტანეთ, ასევე პატარა
cryptic ერთი შეხედვით.

1956
01:40:22,560 --> 01:40:30,540
მაგრამ თუ ჩვენ გადახვევა უკან,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
ასე რომ, ჩვენ iterated ზე ყოველ სიტყვას.

1958
01:40:32,190 --> 01:40:37,770
და, თავის მხრივ, ჩვენ iterated მეტი
ყოველ ხასიათის ფარგლებში სიტყვა.

1959
01:40:37,770 --> 01:40:40,040
>> ახლა, მას შემდეგ ეს ყველაფერი,
გააცნობიეროს, რომ არსებობს

1960
01:40:40,040 --> 01:40:43,120
ერთი სხვა დეტალურად ჩვენ უკვე სახის
იგნორირება ამ მთელი დრო.

1961
01:40:43,120 --> 01:40:46,180
ჩვენ მხოლოდ teased გარდა რა
მთავარი ის საშუალებებით შეიძლება იყოს?

1962
01:40:46,180 --> 01:40:47,780
რაც შეეხება ძირითად გამომავალი?

1963
01:40:47,780 --> 01:40:50,540
>> მთელი ამ დროის განმავლობაში, ჩვენ
მხოლოდ კოპირება და pasting

1964
01:40:50,540 --> 01:40:53,870
სიტყვა int თვალწინ მთავარი,
მიუხედავად იმისა, რომ თქვენ შეიძლება ნახოთ შემოსული,

1965
01:40:53,870 --> 01:40:58,340
ზოგჯერ არასწორად ძველი ვერსია
C და შემდგენელი, რომ ისინი აცხადებენ, ბათილად,

1966
01:40:58,340 --> 01:40:59,410
ან არაფერი.

1967
01:40:59,410 --> 01:41:01,580
მაგრამ, მართლაც, მობილური
C რომ ჩვენ გამოყენებით,

1968
01:41:01,580 --> 01:41:06,180
C 11, ან 2011, გააცნობიეროს,
რომ ეს უნდა იყოს int.

1969
01:41:06,180 --> 01:41:09,300
და ეს უნდა იყოს
ბათილად ან argc და argv აქ.

1970
01:41:09,300 --> 01:41:10,790
>> მაგრამ რატომ int მთავარი?

1971
01:41:10,790 --> 01:41:12,480
რა არის ეს რეალურად დაბრუნების?

1972
01:41:12,480 --> 01:41:16,280
ისე, გამოდის, მთელი ამ დროის განმავლობაში,
ნებისმიერ დროს თქვენ წერილობითი პროგრამის ძირითადი

1973
01:41:16,280 --> 01:41:18,440
ყოველთვის დაბრუნების რაღაც.

1974
01:41:18,440 --> 01:41:19,960
მაგრამ ეს უკვე ამით ფარულად.

1975
01:41:19,960 --> 01:41:23,350
>> რომ რაღაც
int, რადგან line 5 ვარაუდობს.

1976
01:41:23,350 --> 01:41:24,225
მაგრამ რა int?

1977
01:41:24,225 --> 01:41:26,100
ისე, რომ ამ
კონვენციის პროგრამირებაში,

1978
01:41:26,100 --> 01:41:29,790
რომლის მიხედვითაც, თუ არაფერი აქვს
წავიდა არასწორი და ყველა კარგად არის,

1979
01:41:29,790 --> 01:41:34,250
პროგრამების და ფუნქციების ზოგადად
დაბრუნდება გარკვეულწილად counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 ზოგადად ნიშნავს, ყველა კარგად არის.

1982
01:41:38,070 --> 01:41:40,610
მიუხედავად იმისა, რომ თქვენ ფიქრობთ
მას, როგორც ცრუ ბევრ კონტექსტში,

1983
01:41:40,610 --> 01:41:42,930
ეს, ფაქტობრივად, ზოგადად ნიშნავს, კარგია

1984
01:41:42,930 --> 01:41:49,560
>> ამასობაში, თუ პროგრამა დააბრუნებს 1,
ან უარყოფით 1 ან 5, ან უარყოფით 42,

1985
01:41:49,560 --> 01:41:52,941
ან ნებისმიერი არასამთავრობო 0 ღირებულება,
რომ, ზოგადად, ნიშნავს,

1986
01:41:52,941 --> 01:41:54,190
რომ რაღაც წავიდა არასწორია.

1987
01:41:54,190 --> 01:41:56,700
ფაქტობრივად, საკუთარი Mac ან PC,
თქვენ ალბათ რეალურად ჩანს

1988
01:41:56,700 --> 01:42:01,050
შეცდომა, რომლის დროსაც იგი
ამბობს, რომ რაღაც ან სხვა, შეცდომა

1989
01:42:01,050 --> 01:42:04,940
კოდი უარყოფითი 42, ან შეცდომის კოდი
23, ან რამე მაგდაგვარს.

1990
01:42:04,940 --> 01:42:08,980
ეს რიცხვი არის ზოგადად მხოლოდ მინიშნება
პროგრამისტი, ან კომპანია

1991
01:42:08,980 --> 01:42:11,174
რომ გააკეთა პროგრამული უზრუნველყოფა,
რა გაფუჭდა და რატომ,

1992
01:42:11,174 --> 01:42:13,590
ასე რომ შეიძლება გაეცნონ
მათი დოკუმენტაცია ან კოდი,

1993
01:42:13,590 --> 01:42:15,465
და გაერკვნენ, თუ რა
შეცდომა ფაქტიურად ნიშნავს.

1994
01:42:15,465 --> 01:42:18,400
ეს საერთოდ არ არის
სასარგებლო ჩვენთვის ბოლოში მომხმარებლებს.

1995
01:42:18,400 --> 01:42:20,550
>> მაგრამ როდესაც ძირითადი ანაზღაურება 0, ყველაფერი კარგად იქნება.

1996
01:42:20,550 --> 01:42:23,770
და თუ არ არის მითითებული
რა ძირითად უნდა დაბრუნდეს,

1997
01:42:23,770 --> 01:42:26,950
იგი მხოლოდ ავტომატურად
დაბრუნებას 0 თქვენთვის.

1998
01:42:26,950 --> 01:42:30,870
მაგრამ დაბრუნების რაღაც
სხვა ფაქტობრივად სასარგებლო.

1999
01:42:30,870 --> 01:42:34,660
>> ამ საბოლოო პროგრამის ნება მიბოძეთ,
წავიდეთ წინ და მოვუწოდებთ ამ exit.c,

2000
01:42:34,660 --> 01:42:38,630
და დანერგვა ბოლო დღეს
თემა, რომელიც ცნობილია როგორც შეცდომის კოდი.

2001
01:42:38,630 --> 01:42:42,930
ნება მომეცით წავიდეთ წინ და მოიცავს ჩვენი
ნაცნობი ფაილები დაბრუნება, int ძირითადი.

2002
01:42:42,930 --> 01:42:49,500
და ამ დროს, მოდით int argc,
სიმებიანი argv, და ჩემი ფრჩხილები

2003
01:42:49,500 --> 01:42:50,836
ნიშნავს იმას, რომ ეს მასივი.

2004
01:42:50,836 --> 01:42:52,460
და მაშინ ნება მომეცით უბრალოდ საღი აზრის ქვითარი.

2005
01:42:52,460 --> 01:42:56,640
ამ დროს, თუ argc არ
თანაბარი 2, მაშინ თქვენ იცით რა?

2006
01:42:56,640 --> 01:42:57,520
დაივიწყე.

2007
01:42:57,520 --> 01:43:03,170
მე ვაპირებ ვთქვა, რომ, hey, შესახებ,
თქვენ დაკარგული ბრძანების არგუმენტი

2008
01:43:03,170 --> 01:43:04,210
წარმატებული ო.

2009
01:43:04,210 --> 01:43:05,230
>> და მაშინ, რომ ეს არის ის.

2010
01:43:05,230 --> 01:43:06,130
მინდა გასვლა.

2011
01:43:06,130 --> 01:43:11,030
ვაპირებ წინასწარ,
და ნაადრევად ნამდვილად, დაბრუნების

2012
01:43:11,030 --> 01:43:12,810
რაღაც სხვა, ვიდრე ნომერი 1.

2013
01:43:12,810 --> 01:43:15,360
გადასვლა ღირებულების პირველად
შეცდომა, რომ შეიძლება მოხდეს არის 1.

2014
01:43:15,360 --> 01:43:17,860
თუ თქვენ გაქვთ რაიმე სხვა მცდარი
სიტუაცია, რომელიც შეიძლება მოხდეს,

2015
01:43:17,860 --> 01:43:21,390
შეიძლება ითქვას, რომ დაბრუნების 2 ან დაბრუნდნენ 3, ან
შესაძლოა, უარყოფითი 1 ან -2.

2016
01:43:21,390 --> 01:43:23,750
>> ეს არის მხოლოდ გასასვლელი კოდები
რომ, ზოგადად,

2017
01:43:23,750 --> 01:43:27,770
მხოლოდ სასარგებლო პროგრამისტი, ან
კომპანია, რომელიც გადაზიდვა პროგრამული უზრუნველყოფა.

2018
01:43:27,770 --> 01:43:30,500
მაგრამ ის ფაქტი, რომ
არ არის 0, რაც მნიშვნელოვანია.

2019
01:43:30,500 --> 01:43:34,310
ასე რომ, თუ ამ პროგრამას, მინდა
გარანტი, რომ ეს პროგრამა მხოლოდ

2020
01:43:34,310 --> 01:43:38,190
მუშაობს თუ მომხმარებელს უზრუნველყოფს ჩემთვის
არგუმენტი რაოდენობა ორი,

2021
01:43:38,190 --> 01:43:42,880
სახელი პროგრამა, და სხვა
მოკლედ, შეუძლია აღასრულოს, როგორც შემდეგნაირად,

2022
01:43:42,880 --> 01:43:46,110
დაწეროთ მომხმარებელი printf გამონათქვამი,
დაკარგული ბრძანების არგუმენტი,

2023
01:43:46,110 --> 01:43:46,970
დაბრუნდება 1.

2024
01:43:46,970 --> 01:43:49,940
რომელიც მხოლოდ დაუყოვნებლივ
დატოვა პროგრამა.

2025
01:43:49,940 --> 01:43:55,840
>> იმ შემთხვევაში, თუ argc უდრის 2 მივიღებთ ქვემოთ
აქ, სადაც წერტილი მე ვაპირებ ვთქვა,

2026
01:43:55,840 --> 01:44:00,410
მიესალმები პროცენტს s, წარმატებული ო, argv1.

2027
01:44:00,410 --> 01:44:03,827
სხვა სიტყვებით, მე
არ ვაპირებთ შემდეგ argv 0,

2028
01:44:03,827 --> 01:44:05,410
რაც არის პროგრამის სახელი.

2029
01:44:05,410 --> 01:44:09,450
მინდა ამობეჭდოთ მძიმით,
მეორე სიტყვა, რომელიც ადამიანის აკრეფილი.

2030
01:44:09,450 --> 01:44:12,580
და ამ შემთხვევაში,
line 13, ყველაფერი კარგად იქნება.

2031
01:44:12,580 --> 01:44:15,920
>> მე ვიცი, რომ argc არის 2
ლოგიკურად ამ პროგრამის.

2032
01:44:15,920 --> 01:44:17,770
მე ვაპირებ წავიდეთ წინ და უკან დაბრუნებას 0.

2033
01:44:17,770 --> 01:44:21,230
როგორც განზე, გვახსოვდეს, რომ
ეს არის ნამდვილი Scratch ისევე.

2034
01:44:21,230 --> 01:44:24,760
>> ლოგიკურად, მე ვერ გავაკეთებ ამ
და encapsulate ამ ხაზების

2035
01:44:24,760 --> 01:44:27,020
კოდი ამ სხვა პუნქტი აქ.

2036
01:44:27,020 --> 01:44:29,420
მაგრამ ეს ერთგვარი
ზედმეტად წაწევის ჩემი კოდი.

2037
01:44:29,420 --> 01:44:31,800
და მე მინდა, რომ სუპერ
ნათელია, რომ რაც არ უნდა,

2038
01:44:31,800 --> 01:44:34,670
ძირითადად, hello
რაღაც დაბეჭდილი

2039
01:44:34,670 --> 01:44:36,050
ასე რომ, სანამ შესახებ თანამშრომლობს.

2040
01:44:36,050 --> 01:44:39,360
>> ასე რომ, ეს არის ძალიან გავრცელებული გამოყენება
მდგომარეობა, მხოლოდ იმ შემთხვევაში, თუ

2041
01:44:39,360 --> 01:44:41,870
დაჭერა ზოგიერთი მცდარი
სიტუაცია, და შემდეგ გასვლა.

2042
01:44:41,870 --> 01:44:45,690
და შემდეგ, ცოტა ხნის ყველა არის
კარგად, არა აქვს სხვა,

2043
01:44:45,690 --> 01:44:48,060
მაგრამ უბრალოდ კოდი
გარეთ, რომ იმ შემთხვევაში, თუ იმიტომ, რომ ეს

2044
01:44:48,060 --> 01:44:51,060
ექვივალენტი ამ
კონკრეტულ შემთხვევაში, ლოგიკურად.

2045
01:44:51,060 --> 01:44:54,480
ასე რომ, მე დაბრუნების 0, უბრალოდ
მკაფიოდ ნიშნავდეს ყველა კარგად არის.

2046
01:44:54,480 --> 01:44:58,480
>> თუ მე გამოტოვებული დაბრუნების 0, ეს იქნებოდა
ავტომატურად აიღო ჩემთვის.

2047
01:44:58,480 --> 01:45:00,890
მაგრამ ახლა, რომ მე ვბრუნდები
ერთი მინიმუმ ამ შემთხვევაში,

2048
01:45:00,890 --> 01:45:04,940
მე ვაპირებ, კარგი ღონისძიება და
სიწმინდე, დაბრუნდნენ 0 ამ შემთხვევაში.

2049
01:45:04,940 --> 01:45:09,690
ახლა ნება მომეცით წავიდეთ წინ და გასასვლელი,
რომელიც არის სრულყოფილი segue უბრალოდ დატოვონ.

2050
01:45:09,690 --> 01:45:14,401
>> მაგრამ, რათა გასასვლელი, და ნება მომეცით წავიდეთ
წინ და ამის ./exit, შეიტანეთ.

2051
01:45:14,401 --> 01:45:16,900
და პროგრამა დაიყვირა ჩემთვის,
დაკარგული ბრძანების არგუმენტი.

2052
01:45:16,900 --> 01:45:18,120
OK, ნება მომეცით ითანამშრომლოს.

2053
01:45:18,120 --> 01:45:23,810
>> ნება მომეცით ნაცვლად ამის ./exit, დავით, შეიტანეთ.

2054
01:45:23,810 --> 01:45:25,190
და ახლა იგი აცხადებს, hello დავით.

2055
01:45:25,190 --> 01:45:27,300
და თქვენ არ ჩვეულებრივ ეს.

2056
01:45:27,300 --> 01:45:30,650
>> მაგრამ აღმოჩნდება, რომ არსებობს
სპეციალური გზა Linux რეალურად ვხედავ

2057
01:45:30,650 --> 01:45:34,470
ის, რასაც გასასვლელი კოდი პროგრამა დასრულდა.

2058
01:45:34,470 --> 01:45:37,184
ზოგჯერ გრაფიკული
მსოფლიოში, როგორც Mac OS და Windows,

2059
01:45:37,184 --> 01:45:40,100
თქვენ მხოლოდ ამ ნომრებზე, როდესაც
შეცდომა pops up ეკრანზე

2060
01:45:40,100 --> 01:45:41,940
და პროგრამისტი
აჩვენებს, რომ ნომერი.

2061
01:45:41,940 --> 01:45:44,773
მაგრამ თუ ჩვენ გვინდა, რომ რა შეცდომა
გზავნილი არის, ჩვენ შეგვიძლია ამის გაკეთება აქ

2062
01:45:44,773 --> 01:45:48,100
ასე ./exit, შეიყვანეთ ბეჭდვითი
დაკარგული ბრძანების არგუმენტი.

2063
01:45:48,100 --> 01:45:54,590
>> თუ მე ახლა echo $ ?, რომელიც
ridiculously cryptic ეძებს.

2064
01:45:54,590 --> 01:45:56,590
მაგრამ $?

2065
01:45:56,590 --> 01:45:59,220
არის ჯადოსნური incantation
რომელიც ამბობს, hey, კომპიუტერი,

2066
01:45:59,220 --> 01:46:01,900
მითხარით, რა წინა
პროგრამის გამშვები კოდი იყო.

2067
01:46:01,900 --> 01:46:03,410
მე და დააჭიროთ.

2068
01:46:03,410 --> 01:46:07,520
მე ვხედავ 1, იმიტომ, რომ ის, რაც მე
ვუთხარი ჩემი მთავარი ფუნქცია დაბრუნებას.

2069
01:46:07,520 --> 01:46:12,310
>> ამასობაში, თუ ამის ./exit დავით,
და Enter, მე ვხედავ, hello დავით.

2070
01:46:12,310 --> 01:46:16,800
და თუ ახლა echo $ ?, მე ვხედავთ მიესალმები 0.

2071
01:46:16,800 --> 01:46:19,080
ასე რომ, ეს, ფაქტობრივად,
იყოს ღირებული ინფორმაცია

2072
01:46:19,080 --> 01:46:23,420
კონტექსტში debugger, ასე არ არის
ბევრი, რომ თქვენ, ადამიანური, იზრუნებს.

2073
01:46:23,420 --> 01:46:26,060
მაგრამ debugger და სხვა
პროგრამების ჩვენ ვიყენებთ ამ სემესტრში

2074
01:46:26,060 --> 01:46:29,420
ხშირად შევხედოთ, რომ ნომერი,
მიუხედავად იმისა, რომ ეს ერთგვარი გადამალული მოშორებით

2075
01:46:29,420 --> 01:46:32,780
თუ თქვენ ვეძებთ, რათა
განსაზღვრავს თუ არა პროგრამის

2076
01:46:32,780 --> 01:46:37,050
აღსრულების იყო სწორი ან არასწორი.

2077
01:46:37,050 --> 01:46:40,450
>> და ისე, რომ მოაქვს
ეს, ერთი დღის ბოლოს.

2078
01:46:40,450 --> 01:46:43,917
ჩვენ დღეს დაიწყო ეძებს
გამართვის, და თავის მხრივ, რა თქმა უნდა

2079
01:46:43,917 --> 01:46:46,750
თავად, და მაშინ უფრო საინტერესოა,
ტექნიკურად ქვეშ hood

2080
01:46:46,750 --> 01:46:49,490
რა სტრიქონები, რომელიც გაგრძელდება
კვირას ჩვენ უბრალოდ აიღო მიანიჭა,

2081
01:46:49,490 --> 01:46:51,900
და რა თქმა უნდა წაიყვანეს
გაიცემა Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> ჩვენ მაშინ შევხედე, თუ როგორ ჩვენ შეუძლია
ინდივიდუალური სიმბოლოების სიმებიანი,

2083
01:46:56,040 --> 01:47:00,310
და მერე კიდევ ერთხელ აიღო უფრო მაღალ დონეზე
შევხედოთ რამ, შევხედავთ, როგორ well--

2084
01:47:00,310 --> 01:47:04,226
თუ ჩვენ გვინდა, რომ ინდივიდუალური
ელემენტების სია მსგავსი სტრუქტურა,

2085
01:47:04,226 --> 01:47:05,850
არ შეგვიძლია გავაკეთოთ, რომ მრავალჯერადი სიმებიანი?

2086
01:47:05,850 --> 01:47:08,050
და ჩვენ შეგვიძლია ბრძანების ხაზი არგუმენტები.

2087
01:47:08,050 --> 01:47:12,800
მაგრამ ამ სურათს აქ მხოლოდ ყუთები
არის საჩვენებელი ამ ზოგადი იდეა

2088
01:47:12,800 --> 01:47:14,451
მასივი, ან ჩამონათვალი, ან ვექტორი.

2089
01:47:14,451 --> 01:47:16,450
და დამოკიდებულია
კონტექსტში, ყველა ეს სიტყვა

2090
01:47:16,450 --> 01:47:17,880
ნიშნავს ოდნავ განსხვავებული რამ.

2091
01:47:17,880 --> 01:47:20,060
ასე რომ, C, ჩვენ მხოლოდ აპირებს
ვისაუბროთ მასივი.

2092
01:47:20,060 --> 01:47:23,840
ხოლო მასივი ბლოკი
მეხსიერების, თითოეული მათგანი არის

2093
01:47:23,840 --> 01:47:27,720
ელემენტები მომიჯნავე, უკან,
უკან, უკან, უკან.

2094
01:47:27,720 --> 01:47:31,970
>> და იმ ელემენტების, ზოგადად,
იგივე მონაცემები ტიპის, ხასიათი,

2095
01:47:31,970 --> 01:47:35,966
ხასიათი, ხასიათი, ხასიათი, ან
სიმებიანი, სიმებიანი, სიმებიანი, სიმებიანი, ან int,

2096
01:47:35,966 --> 01:47:38,600
int, int, რაც არ არის
ჩვენ ვცდილობთ, რომ მაღაზიაში.

2097
01:47:38,600 --> 01:47:42,540
თუმცა, დღის ბოლოს, ეს არის
რას ჰგავს კონცეპტუალურად.

2098
01:47:42,540 --> 01:47:44,530
თქვენ მიღების თქვენი
კომპიუტერის მეხსიერების ან RAM.

2099
01:47:44,530 --> 01:47:48,590
და თქვენ კვეთის ის შევიდა
იდენტურად ზომის ყუთები, რაც

2100
01:47:48,590 --> 01:47:50,920
უკან, უკან, რომ
უკან, რომლითაც ამ გზით.

2101
01:47:50,920 --> 01:47:53,200
>> და რა ლამაზი
ამ იდეას, და ის ფაქტი,

2102
01:47:53,200 --> 01:47:58,580
რომ ჩვენ შეგვიძლია გამოვხატოთ ღირებულებების ამ გზით
პირველი ჩვენი მონაცემთა სტრუქტურები

2103
01:47:58,580 --> 01:48:02,520
კლასი, იმას ნიშნავს, რომ ჩვენ შეგვიძლია დავიწყოთ
პრობლემების მოსაგვარებლად კოდით

2104
01:48:02,520 --> 01:48:04,079
რომ მოვიდა ინტუიციურად კვირაში 0.

2105
01:48:04,079 --> 01:48:05,870
თქვენ გახსოვთ, ტელეფონით
წიგნი მაგალითად, სადაც

2106
01:48:05,870 --> 01:48:09,110
ჩვენ გამოყენებული გათიშე და იბატონეს
ან ბინარული ძებნის ალგორითმი,

2107
01:48:09,110 --> 01:48:13,220
Sift მეშვეობით მთელი
bunch of სახელები და ნომრები.

2108
01:48:13,220 --> 01:48:18,220
მაგრამ ჩვენ ვვარაუდობდით, გავიხსენოთ, რომ ეს
სატელეფონო წიგნი უკვე დახარისხებული,

2109
01:48:18,220 --> 01:48:21,630
რომ ვინმეს უკვე
figured out-- მოცემულ სიაში სახელები

2110
01:48:21,630 --> 01:48:24,430
და ნომრებზე როგორ alphabetize მათ.

2111
01:48:24,430 --> 01:48:26,950
და ახლა, რომ C ჩვენ,
ძალიან, აქვს უნარი

2112
01:48:26,950 --> 01:48:30,290
ჩაუყარა ნივთების, არ
ფიზიკური სატელეფონო წიგნი

2113
01:48:30,290 --> 01:48:34,220
მაგრამ პრაქტიკულად კომპიუტერის
მეხსიერება, ჩვენ შევძლებთ მომავალ კვირას

2114
01:48:34,220 --> 01:48:38,470
დანერგვა კიდევ ერთხელ ამას პირველი
ჩვენი მონაცემები სტრუქტურების მასივი

2115
01:48:38,470 --> 01:48:43,530
მაგრამ რაც მთავარია, ფაქტობრივი კომპიუტერი
მეცნიერება ალგორითმები განხორციელდა

2116
01:48:43,530 --> 01:48:47,720
კოდი, რომლითაც ჩვენ შეგვიძლია შესანახად
მონაცემების სტრუქტურები, როგორც ეს,

2117
01:48:47,720 --> 01:48:50,730
და შემდეგ დაიწყება მართვას, და
რეალურად მოგვარებას პრობლემები,

2118
01:48:50,730 --> 01:48:53,570
და ავაშენოთ თავზე რომ,
საბოლოო ჯამში, პროგრამების C,

2119
01:48:53,570 --> 01:48:56,730
in Python, JavaScript,
querying მონაცემთა ბაზის SQL?

2120
01:48:56,730 --> 01:48:59,980
>> და ჩვენ დავინახავთ, რომ ყველა ეს
სხვადასხვა იდეები ერთმანეთს.

2121
01:48:59,980 --> 01:49:04,100
მაგრამ ახლა, გავიხსენოთ, რომ
დომენი, რომ ჩვენ გააცნო დღეს

2122
01:49:04,100 --> 01:49:06,920
იყო, ეს ისაა, და
სამყაროში კრიპტოგრაფიის.

2123
01:49:06,920 --> 01:49:11,200
და მათ შორის შემდეგი პრობლემები თქვენ თავს
რომელიც გადაწყვეტს ხელოვნების კრიპტოგრაფიის,

2124
01:49:11,200 --> 01:49:13,630
scrambling და დე-scrambling
ინფორმაცია და დაშიფრვის

2125
01:49:13,630 --> 01:49:15,930
და გაშიფვრის ტექსტი,
და ვთქვათ, საბოლოო ჯამში,

2126
01:49:15,930 --> 01:49:18,970
რომ თქვენ ახლა ვიცი, რა
არის ქვეშ hood

2127
01:49:18,970 --> 01:49:21,860
ასე რომ, როდესაც თქვენ ხედავთ ან მიიღოს
გაგზავნა მოსწონს ეს, თქვენ

2128
01:49:21,860 --> 01:49:24,060
თავს ვერ decipher იგი.

2129
01:49:24,060 --> 01:49:26,740
ყველა ამ და სხვა დროს.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [ვიდეო აღწარმოების]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover მხოლოდ ჩამოვიდა.

2133
01:49:32,970 --> 01:49:35,146
მე ვაპირებ წასვლა ვიზიტი
მისი კოლეჯის პროფესორი.

2134
01:49:35,146 --> 01:49:37,611
Yep.

2135
01:49:37,611 --> 01:49:40,080
Hi.

2136
01:49:40,080 --> 01:49:40,660
ეს შენ ხარ.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
დაელოდეთ!

2139
01:49:45,110 --> 01:49:45,610
დავით.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
მე უბრალოდ ცდილობენ გაერკვნენ
გაირკვეს, თუ რა მოხდა თქვენ.

2142
01:49:56,060 --> 01:49:58,130
გთხოვთ, არაფერი დაეხმარება.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
თქვენ იყავით მისი კოლეჯის
roommate, იყო არა?

2145
01:50:08,354 --> 01:50:10,770
თქვენ იქ მასთან ერთად,
დაამთავრა CS50 პროექტი?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [მუსიკის დაკვრა]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -ეს იყო CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> მე მიყვარს ეს ადგილი.

2152
01:50:44,770 --> 01:50:45,854
>> -ჭამა.

2153
01:50:45,854 --> 01:50:47,020
ჩვენ ვაპირებთ, ბიზნესი.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END აღწარმოების]

