[GROJA MUZIKA] 

David J. Malan: Gerai. Tai yra CS50 ir tai yra 2-ąją savaitę pradžia. Ir jūs priminti, kad per pastaruosius porą savaičių, mes jau įdiegti kompiuteryje mokslo ir, savo ruožtu, programavimas. 

Ir mes pradėjome pasakojimą būdu Nulio, kad grafinė kalba iš MIT Media Lab. Ir tada visai neseniai, Praėjusią savaitę, tai mes įvesti higher-- A žemesnio lygio kalba žinomas kaip C, kažką, kad vien tekstinė. Ir, tiesą sakant, paskutinį kartą mes ištirta per tą kontekste sąvokų skaičius. 

Tai, prisiminti, buvo labai Pirmoji programa, mes pažvelgė. Ir ši programa, paprasčiausiai, spausdina, "Hello, World". Bet ten tiek daug tariamas magija vyksta. Yra tai #include su šiomis laužtiniuose skliaustuose. Yra int. Yra (tuščia). Yra skliaustai, garbanotas petnešos, kabliataškiai ir daug daugiau. 

Ir taip, priminti, kad įdiegėme nulio kad galėtume, idealiu atveju, pamatyti praeities kad sintaksė, stuff, kad tikrai ne visi, kad intelektualiai įdomus, tačiau anksti yra absoliučiai šiek tiek sudėtinga wrap savo mintis aplink. Ir, iš tikrųjų, vienas iš dažniausiai viskas anksti programavimo klasės, ypač tiems, mažiau patogus, yra gauti nusivylė ir paslydau iki tam tikros sintaktikai klaidų, nekalbant loginių klaidų. Ir taip tarp mūsų tikslų šiandien, iš tikrųjų, bus būti išmokyti jus su kai Problemų sprendimo būdai, kaip geriau spręsti problemas patys atsižvelgiant į derinimo forma. Ir jūs žinote, taip pat, kad aplinka, mes pristatėme Paskutinį kartą buvo vadinamas CS50 IDE. Tai žiniatinklio programinės įrangos, kuri Leidžia programuoti debesyje taip sakant, išlaikant visus savo failus kartu, nes mes vėl šiandien. Ir prisiminti, kad mes peržiūrėta šias temas čia tarp jų funkcijas ir kilpos, ir kintamieji, ir Būlio išraiškos, ir sąlygomis. Ir iš tikrųjų keli, kad mes išversti iš nulio pasaulyje į C. pasaulyje 

Bet pagrindinis pastatas blokai, taip sakant, buvo tikrai vis dar tas pats praeitą savaitę. Iš tiesų, mes tikrai tik buvo skiriasi įspūdį, jei bus. Vietoj to violetinė išsaugoti bloką, mes vietoj buvo printf, kuris yra Ši funkcija C, kad leidžia spausdinti kažką ir suformatuoti jį ekrane. Mes pristatė CS50 Biblioteka, kurioje jus dabar turi savo žinioje get_char, ir get_int ir get_string, ir keletas kitų veikia kaip Na, per kurią jūs galite gauti indėlį iš vartotojo savą klaviatūrą. Ir mes taip pat paėmė į dalykus pažvelgti kaip these- bool ir char, ir du kartus, plūdė, INT, long_long eilutė. Ir ten net kitus duomenų tipus C 

Kitaip tariant, kai jūs deklaruoti kintamasis saugoti tam tikrą vertę, arba kai jums įgyvendinti funkciją kad grįžta tam tikrą vertę, galite nurodyti, ką tipo vertę, kuri yra. Ar tai eilutė, tarsi simbolių seka? Ar tai skaičius, kaip ir sveikasis skaičius? Ar tai slankaus kablelio vertė, arba kaip? Taigi C, skirtingai nuo nulio, mes iš tikrųjų pradėjo nurodykite, kokių rūšių duomenis mes buvome grįžta arba naudojant. 

Bet, žinoma, mes taip pat vyko į keletas pagrindinių ribos skaičiavimas. Ir visų pirma, Ši kalba, C, prisiminti kad mes priėmėme pažvelgti sveikasis skaičius perpildymo, realybė kad jei turite tik ribinis dydis atminties arba, konkrečiau, baigtinis skaičius Bitų, galite tik tikėtis, kad didelis. Ir todėl mes pažvelgė Šiame pavyzdyje čia kuriuo skaitliukas lėktuve,, Tiesą sakant, jei veikia pakankamai ilgai būtų perkrautas ir sukelti programinės įrangos faktinis fizinis potencialas klaida. 

Mes taip pat pažvelgė į plaukiojantieji taškas netikslumas, realybė kad tik su baigtinio skaičiaus Bitų, ar tai 32 ar 64, galite nurodyti tik tiek daug numerių po dešimtainio taško, po kurio jūs pradeda gauti netikslūs. Taigi, pavyzdžiui, vienas trečdalis į Pasaulio čia, mūsų žmonių pasaulyje, mes žinome tik begalinis skaičius apie 3s po kablelio. Bet kompiuteris gali nebūtinai atstovauti begalinį skaičių numeriais jei tik leidžia tai kai baigtinis informacijos kiekis. 

Taigi mes ne tik išmokyti jus su aukštesnės galios požiūriu kaip jums gali išreikšti save klaviatūra, kalbant apie programavimą, mes taip pat ribotas, ką jūs iš tikrųjų galite padaryti. Ir iš tiesų, klaidas ir klaidos gali kyla iš tų klausimų rūšių. Ir iš tiesų, tarp temų šiandien ketinate būti temas kaip derinti ir iš tikrųjų ieško po gaubtu tuo, kaip viskas buvo įvestas praėjusią savaitę yra realiai įgyvendinamas taip, kad jums geriau suprasti tiek pajėgumų ir panašaus C kalba apribojimai 

Ir iš tikrųjų, mes žievelės atgal sluoksnius iš paprasčiausių duomenų struktūros, kažkas vadinamas masyvas, kuris Įbrėžimams atsitinka skambinti "sąrašą". Tai šiek tiek besiskiriantis tuo, kad kontekste. Ir tada mes taip pat pristatyti vieną iš Pirmasis mūsų domenų konkrečių problemų į CS50, kad pasaulis kriptografija, kad stengiamasi menas arba kodavimo informaciją, kad jūs galite siųsti slaptus pranešimus ir iššifruoti slaptus pranešimus tarp dviejų asmenų A ir B 

Taigi, kol mes perėjimo tai naujo pasaulio, pabandykime išmokyti jus su kai metodai, su kuria jūs galite pašalinti arba sumažinti bent kai kurie iš nusivylimų kad jūs tikriausiai susidūrėte per vien praeitą savaitę. Tiesą sakant, prieš jus yra such-- kai Jūsų pirmieji problemos C. Ir šansai yra, jei jūs panašus į mane, pirmą kartą bandote tipo iš programos, net jei manote, logiškai Programa yra gana paprasta, jums gali labai gerai pataikyti sienos, ir sudarytojas nesiruošia bendradarbiauti. Padaryti arba klingsėti nesiruošia realiai padaryti savo siūlymų. 

Ir kodėl gali būti? Na, tegul pažvelgti, galbūt, paprasta programa. Aš ruošiuosi eiti į priekį ir sutaupyti tai byla sąmoningai vadinamas buggy0.c, nes žinau, ją būti ydingas iš anksto. Bet aš gali ne suprantame, kad, jeigu šis yra pirmoji arba antroji arba trečioji programa kad aš iš tikrųjų padaryti save. Taigi, aš ruošiuosi eiti į priekį ir tipo iš, int main (void). Ir tada viduje mano garbanotas petnešos, labai pažįstamas ( "Sveiki, world-- Backslash, n ") - ir pusiau-gaubtinės žarnos. 

Aš išsaugoti failą. Dabar aš ruošiuosi eiti mano terminalo lange ir tipo makiažo buggy0, nes, vėlgi, failo šiandien vardas buggy0.c. Taigi aš tipo padaryti buggy0, Enter. 

Ir, o, dieve, prisiminti nuo paskutinio karto kad be klaidų pranešimų yra geras dalykas. Taigi ne produkcija yra geras dalykas. Bet čia aš turiu aiškiai kai klaidų skaičius. 

Taigi pirmoje eilutėje produkcijos Įvedę padaryti buggy0, prisiminti, yra žvangėjimas gana daugiažodis produkcija. Po gaubtu, CS50 IDE yra sukonfigūruota naudoti visa krūva galimybės su šiuo sudarytojas taip, kad jūs neturite galvoti apie juos. Ir tai viskas, pirmoji eilutė reiškia, kad prasideda žvangėjimas. 

Bet po to, problemos pradėti uždirbti savo išvaizdą. Buggy0.c on-line 3, charakterio 5, ten yra didelis, raudonas klaida. Kas tai? Netiesiogiai teigiama bibliotekos funkcija printf su tipo int (const char *, ...) [-Werror]. Aš turiu galvoje, kad tai yra labai greitai tampa labai paslaptinga. Ir, žinoma, iš pradžių žvilgsnis, nebūtume tikimės, kad jūs suprasti visuma šio pranešimo. Ir taip viena iš pamokų už šiandien vyksta būti išbandyti pastebėti modeliai, ar panašių dalykų, klaidų gali tekti susiduriama su anksčiau. Taigi leiskite erzinti išskyrus tik šie žodžiai, kurie atrodo pažįstama. Didelis, raudonas klaida yra aiškiai simbolinė kažkas yra negerai. 

netiesiogiai teigiama, bibliotekos funkcija printf. Taigi, net jei aš ne visai suprantu, ką netiesiogiai teigiama bibliotekos funkcija priemonės, problema tikrai susijęs su printf kažkaip. Ir šiuo klausimu šaltinis turi daryti su nedeklaravę. 

Skelbiantis funkcija paminėti, kad pirmą kartą. Ir mes panaudojome terminologiją praėjusią savaitę skelbiantis funkcijos prototipas, arba su vienos linijos lango viršuje savo savo failą arba vadinamasis antraštės faile. Ir ką failo padariau sakome praeitą savaitę, kad printf yra citata, citatos pabaiga, pareiškė? Kokiu failas yra jos prototipas? 

Taigi, jei jūs prisimenate, pats pirmasis dalykas, kurį aš parašomas beveik kiekviena programa paskutinis LAIKĄ_ ir netyčia akimirka prieš pradėjau rašyti myself-- buvo tai vienas here-- hash-- #include <stio-- už įvesties / output-- taškas H ir iš tiesų, jei aš dabar išsaugoti šį failą, aš ruošiuosi eiti į priekį ir išvalyti ekraną, kurį galite padaryti, įvesdami Skaidrus, arba galite palaikykite valdymo L, tiesiog išvalyti terminalo langą tik siekiant pašalinti tam tikrą netvarką. 

Aš ruošiuosi eiti į priekį ir naujo tipo makiažo buggy0, Enter. Ir voila, aš vis dar matau, kad ilgai komandų iš žvangėjimas, bet ten ne klaidos pranešimas šįkart. Ir iš tiesų, jei aš ./buggy0, kaip paskutinį kartą, kur taškas reiškia tai katalogas, velniop tiesiog reiškia, čia ateina programos pavadinimas ir kad programos pavadinimas yra buggy0, Įveskite "Hello, World". 

Dabar, kaip gali jums gautą šį sprendimą nebūtinai pripažįstant tiek daug žodžių, kaip aš, žinoma, turintys tai padarė tiek daug metų? Na, suprasite už pirmąją problemą rinkinys, mes pristatome jums komandą kad CS50 paties personalo rašė vadinamas help50. Ir iš tiesų, C ar specifikacija problema nustatyti, kaip tai panaudoti. 

Bet help50 yra iš esmės programa, kuri CS50 darbuotojai rašė, kad leidžia jums paleisti komandų ar paleisti programą, ir jei jūs nesuprantate jos produkcija, perduoti savo produkciją į help50, kuriame taškas programinė įranga kad kursas darbuotojai rašė atrodys jūsų programa produkcijos eilutė po eilutės, charakteris pagal charakterį. Ir jei mes, darbuotojai, pripažinti klaidos pranešimas, kad jūs susidūrėte, bandysime jus išprovokuoti kai kurie retoriniai klausimai, su kai kuriais patarimais, panašiai kaip TF ar CA ar sau būtų padaryti asmeniškai darbo valandomis. 

Taigi atrodo, kad help50 jei ne nebūtinai pripažinti problemą. Tačiau nereikia remtis per kiek ramentas. Žinoma pabandyti suprasti jo produkcija ir tada iš jos pasimokyti taip, kad tik vieną ar du kartus padaryti jums kada paleisti help50 konkrečiam klaidos pranešimas. Po to, jums turėtų būti suteikta geriau pasirengę patys išsiaiškinti, kas jis iš tikrųjų yra. 

Darom vieną kitą čia. Leiskite man eiti į priekį, ir kita failą, mes vadiname tai buggy1.c. Ir šioje byloje aš ketina deliberately-- bet apsimesti, kad aš ne suprasti, kas klaida Aš atlikau. 

Aš ruošiuosi eiti į priekį ir padaryti this-- #include, nes aš išmoko savo pamoką iš prieš momentas. Int main (tuščia), kaip ir anksčiau. Ir tada aš čia ruošiuosi daryti styginių s - get_string. Ir prisiminti, nuo paskutinio karto, kad Tai reiškia, ei, kompiuteris, man kintamąjį, vadina tai ai, ir kad tos kintamojo styginių tipas todėl galiu laikyti vieną ar daugiau žodžių iš jo. 

Ir tada ant dešinėje pusė lygybės ženklo yra get_string, kuris yra funkcija CS50 bibliotekoje kad daro būtent tai. Ji gauna funkciją ir tada rankos jį iš dešinės į kairę. Taigi, tai lygybės ženklas nereiškia, "Lygus" kaip mes manote matematika. Tai reiškia, perkėlė iš dešinės į kairę. Taigi tai reiškia, imtis eilutę nuo vartotojo ir laikyti jį viduje s. 

Dabar galime jį naudoti. Leiskite man eiti į priekį ir dabar kaip sekundę linija, leiskite man eiti į priekį ir pasakyti "labas" - ne "pasaulio", bet "labas,% s-- kuri yra mūsų rezervavimo ženklas, kablelis s kuri yra mūsų kintamasis, ir tada pusiau-gaubtinės žarnos. Taigi, jei aš ne susukti per daug čia tai atrodo teisingą kodą. 

Ir mano instinktai dabar ją sudaryti. Šis failas yra vadinamas buggy1.c. Taigi, aš ruošiuosi daryti, kad buggy1, Enter. Ir darn-ji, jei nėra net daugiau klaidų nei anksčiau. Aš turiu galvoje, tai dar klaidų pranešimai būtų atrodo nei faktinių linijų šią programą. 

Bet Takeaway čia yra, net jei esate priblokšti su dviejų ar trijų ar keturi pranešimai apie klaidas, sutelkti visada labai Pirmoji iš šių pranešimų. Pažvelgus į viršų, didžioji vieną, przewijanie atgal kaip reikia. Taigi čia aš įvedėte makiažo buggy1. Štai kad klingsėti produkcijos, kaip tikėtasi. 

Ir štai pirmoji raudona klaida. Naudokite nedeklaruojamo identifikatorius eilutė, aš tai standartas? Taigi standartas yra tikrai kažkas. Ji remiasi vartotojo anketa klaviatūra, iš esmės. 

Bet tai nėra tai, ką aš reiškė. Aš norėjau eilutę, ir aš reiškė get_string. Taigi, kas tai yra, kad aš pamiršau padaryti šį kartą? Ko trūksta šį kartą? Turiu #include, todėl aš turiu priėjimą prie printf. 

Bet ką aš neturi Prieiga prie dar tik? Na, kaip ir paskutinį kartą, Man reikia pasakyti kompiliatorių Žvangėjimas, ką šios funkcijos yra. Get_string neateina su C ir ypač, kad neateina į header failą,. Tai vietoj ateina kažkas darbuotojai rašė: kuris yra kitoje failas vardu, bet taikliai pavadinta. 

Taigi tiesiog pridedant, kad vienos linijos iš code-- pašalinimo iš paskutinį kartą kad kai klingsėti veikia, ji vyksta pažvelgti į mano kodas viršaus į apačią, kairės į dešinę. Jis ketina pranešimas, oi, ko norite. Leiskite man eiti ir rasti, kad, ten, kur jis yra serveryje, nukopijuokite ir įklijuokite jį iš esmės, į savo failo viršuje taip, kad šiuo metu į istoriją, linija 1, programos poilsio iš tikrųjų gali naudoti bet kurią iš funkcijų jame, tarp jų ir get_string. Taigi, aš ruošiuosi ignoruoti šių klaidų poilsio, Nes aš, tiesą sakant, įtariu, kad tik pirmasis tikrai nerūpėjo. Ir aš ruošiuosi eiti į priekį ir pakartotinis, po išgelbėdamas mano failą padaryti buggy1. Ir voila, ji darbą. Ir jei aš ./buggy1 ir tipo, už pavyzdžiui, Zamyla, aš dabar gaus Sveiki, Zamyla, vietoj labas, pasauli. 

Gerai. Todėl čia takeaways tada yra, vienas, pabandykite rankioti kiek, kaip jūs galite vien iš klaidų pranešimų, ieško į kai kuriuos iš atpažįstamų žodžių. Draudimo, kad naudoti help50 už problema nustatyti specifikaciją. Bet draudimas, kad per daug, visada atrodo viršuje klaidos tik, ne mažiau kaip Iš pradžių, norėdami pamatyti, kokia informacija ji iš tikrųjų gali duoti. Tačiau paaiškėja, ten dar funkcionalumas pastatytas į CS50 bibliotekoje, kad padėtų Jums anksti semestro ir anksti programavimo išsiaiškinti, kas vyksta neteisingai. Taigi padarykime dar vieną pavyzdį čia. Aš ruošiuosi skambinti šiuo buggy2, kuris, vėl ketina būti ydingas iš Vartų, dizainas. 

Ir aš ruošiuosi eiti į priekį ir daryti #include. Ir tada aš ruošiuosi daryti int main (void). Ir tada aš ruošiuosi padaryti už kilpa. For (int i _ 0. i yra mažiau negu arba lygi 10. i ++, tada garbanotas petnešos, aš ruošiuosi spausdinti tik grotelėmis simbolis čia o nauja linija charakteris. 

Taigi, mano siekis šiame Programa yra paprasčiausiai į pakartoti 10 kartų ir ant kiekvienos iteracijos tos linijos kiekvieną kartą per ciklą, atsispausdinti hashtag, Žyma su grotelėmis A grotelėmis. Vienas už linijos, nes aš turėti naują eilutę ten. Ir priminti, kad už kilpa, už paskutinio week-- ir gausite daugiau susipažinęs su sintakse naudojant ją su praktika prieš long-- tai suteikia man kintamasis vadinamas i ir nustato, kad 0. 

Tai padidina I kas iteracijos 1. Todėl aš eina į 1 iki 2 iki 3. Ir tada ši sąlyga į viduryje tarp kabliataškiais gauna tikrinamas kiekvieną iteracijos padaryti Įsitikinkite, kad mes vis dar per diapazone. Taigi noriu pakartoti 10 kartų, todėl aš turi tarsi labai intuityviai tik įdėti 10 kaip mano viršutinė riba yra. 

Ir dar, kai aš paleisti tai, po Sudarant jį su modelio buggy2-- ir ji kaupia Gerai. Taigi aš neturite sintaksės klaida šį kartą. Leiskite man eiti į priekį dabar ir paleisti buggy2, Enter. Ir dabar slinkite aukštyn. Ir leiskite man padidinti lango dydis. 

Man atrodo, kad turi 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Taigi ten 11 Žymas, nors Aš aiškiai įdėti 10 viduje šio kilpa. Dabar, kai jūs galite pamatyti iš karto kas yra klaida, nes, tiesą sakant, tai nėra labai sunku klaida padaryti. Bet tai labai dažnai padarė labai anksti. 

Ką aš noriu atkreipti dėmesį, nors, yra, kaip gali man suprasti tai? Na, paaiškėja, kad CS50 biblioteka ateina su ne tik get_string ir get_int ir get_float ir kitas funkcijas. Ji taip pat ateina su specialiu funkcija vadinamas eprintf arba, klaida printf. Ir tai vien tik padaryti tai šiek tiek lengviau jums kai derinate kodą tiesiog spausdinti klaidos pranešimą ekrane ir žinoti, kur ji atėjo iš. 

Taigi, pavyzdžiui, vienas dalykas, aš galėtų padaryti čia su šia funkcija this-- eprintf, ir tada aš ruošiuosi eiti į priekį ir pasakyti, kad aš dabar% i Backslash n. Ir aš ruošiuosi įjunkite I vertė. Ir iki viršaus, nes tai yra CS50 bibliotekoje, Aš ruošiuosi eiti į priekį ir taip pat todėl aš turiu prieigą prie šios funkcijos. Bet tegul mano ką linija 9 Manoma, kad daryti. Aš ruošiuosi ištrinti, galų gale. Tai neturi nieko bendro su mano svarbiausiam tikslo. Bet eprintf, klaidų printf, tiesiog reiškė, duoti man šiek tiek diagnostikos informaciją. Kai aš paleisti savo programą, aš noriu pamatyti tai ekrane, laikinai taip pat tik suprasti kas vyksta. 

Ir, tiesą sakant, dėl kiekvieno iteracijos čia linijos 9 Noriu pamatyti, kas yra i vertė? Kas yra i vertė? Kas yra i vertė? Ir, tikiuosi, aš tik turėtų matyti, kad pranešimas, taip pat 10 kartų. 

Taigi leiskite man eiti į priekį ir perkompiliuoti savo programą, kaip turiu daryti bet kuriuo metu Aš padaryti kaita. ./buggy2. Ir now-- Gerai. Yra daug daugiau vyksta. Taigi leiskite man slinkite aukštyn į dar didesnis langas. 

Ir pamatysite, kad kiekvienas žymos su grotelėmis dar spausdinimo metu. Bet tarp kiekvienos iš jų yra dabar tai diagnostikos produkcija suformatuotas taip. Mano programa čia vardas buggy2. Failo vardas buggy2.c. Eilutės numeris, iš kurio tai buvo spausdinami yra linija, 9. Ir tada tos teisės yra klaidos pranešimas, kad aš laukiu. 

Ir kas malonu apie tai, kad dabar aš neturiu būtinai skaičiuoti mano galva, ką mano programa daro. Matau, kad dėl pirmajame iteracijos i yra 0, tada 1, tada 2, tada 3, tada 4, tada 5, tada 6, tada 7, tada 8, tada 9, tada 10. Taigi palauk. Kas čia vyksta? Aš vis dar atrodo, kad skaičiuojant kaip numatyta iki 10. 

Bet kur gi man pradėti? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. Taip 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11-pirštas tai rodo, kad šią problemą. Man atrodo, kad suskaičiavau neteisingai mano kilpa. Užuot eiti 10 iteracijų, Aš pradedu 0, Aš baigiasi ir per 10. Bet todėl, kad, kaip kompiuteris, Aš pradedu skaičiavimo 0, Būčiau skaičiuoti iki į, bet ne per, 10. 

Ir taip nustatyti, aš galų gale čia realizuotas, yra vienas iš dviejų dalykų. Galėčiau labai paprastai pasakyti skaičiuoti iki mažiau nei 10. Taip 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, kuris yra, iš tikrųjų, teisinga, nors tai skamba šiek tiek negerai. Arba aš galėčiau padaryti mažesnis arba lygus iki 9, taip ilgai, kaip aš prasideda nuo 0. Arba jei tikrai nepatinka, kad jus gali tikėtis ne per 10, bet prasideda 1 d. Bet vėl, tai tik ne tai, kad bendra. Be programming-- nors ir ne tiek Scratch-- bet programavimo C ir kitų kalbų, kaip JavaScript ir Python ir kiti, tai tiesiog labai dažnas Mūsų diskusija dvejetainis tiesiog pradėti skaičiuoti ne Mažiausiai galite, kuris yra 0. Gerai. Štai eprintf. Ir vėl, dabar, kad aš raštuotas, mano problema, ir aš ruošiuosi grįžti iki 0 per mažiau nei 10, aš ruošiuosi eiti ir ištrinti eprintf. 

Ji turėtų būti ten, kai aš pervežti savo kodą arba pateikti savo kodą arba parodyti jį kitiems. Tai tikrai tik reiškė laikinai naudoti. Bet dabar aš fiksuotas tai ypač problema taip pat. 

Na, padarykime dar vieną pavyzdį čia kad aš ruošiuosi pakelti taip. Aš ruošiuosi eiti į priekį ir #include. 50 $ Ir aš ruošiuosi eiti į priekį ir #include. 

Ir aš ruošiuosi išsaugoti šiam failui kaip buggy3.c. Ir aš ruošiuosi eiti į priekį ir deklaruoti int main (void). Ir tada viduje yra Aš ruošiuosi daryti int i _ - Noriu įgyvendinti programą su get_negative_int. Tai ne funkcija, kad egzistuoja dar. Taigi, mes ketiname įgyvendinti jis vos akimirką. Tačiau mes ketiname pamatyti, kodėl tai Buggy pirmo perdavimo. Ir kai aš Dotarłeś LC nuo vartotojo, Aš tik ketina spausdinti% I yra neigiamas sveikasis skaičius, Backslash, N, kablelis, aš. Kitaip tariant, viskas, ką aš norite šią programą padaryti yra gauti neigiamą int nuo vartotojas ir tada atsispausdinti kad toks ir toks yra neigiamas INT. 

Dabar man reikia įgyvendinti šią funkciją. Taigi vėliau mano byla, aš ruošiuosi eiti į priekį ir paskelbti funkcija vadinama get_negative_int (tuščia) - ir mes grįžti į tai, kas, kad linija reiškia vėl į moment-- int n; do-- Do following-- printf n yra :. Ir tada aš ruošiuosi daryti n - get_int, ir padaryti tai, o n yra didesnis už 0. Ir tada grįžti N ;. 

Taigi ten daug vyksta tai, tačiau nė vienas iš jų mes ne pažvelgti paskutinę savaitę, bent jau trumpai. Taigi nuo 10 eilutėje čia aš paskelbus funkcija vadinama get_negative_int, ir aš įdėti (tuščia), į skliaustai, priežastis yra tai nesiima įvestį. Nesu artimųjų nieko su šia funkcija. Aš tiesiog gauti kažką atgal iš jo. 

Ir ką aš tikiuosi, kad grįžti yra sveikasis skaičius. Nėra duomenų tipas C vadinamas negative_int. Tai tiesiog int, todėl jis ketina būti mums įsitikinti, kad vertė, kad iš tikrųjų Grąžintos yra ne tik int bet taip pat yra neigiama. 

On line 12 Aš paskelbti kintamąjį vadinamas n ir todėl tipo int. Ir tada linija 13 per 18 aš daro kažką, o kažkas yra tiesa. Aš ruošiuosi į priekį ir spausdinimas n yra, gaubtinės žarnos, ir tada erdvė, lyg Vartotojui eilutę. 

Aš tada skambina get_int ir saugoti savo vadinamąją sugrįžimo vertę toje kintamojo n. Bet aš ruošiuosi nuolat daro tai, o n yra didesnis už 0. Kitaip tariant, jei vartotojas suteikia man Int, kad skaičius yra didesnis už 0, ERGO teigiamas, aš ruošiuosi tiesiog laikyti reprompting vartotojui, išlaikyti reprompting, verčia juos bendradarbiauti ir suteikti man neigiamą int. 

Ir kai n yra iš tikrųjų negative-- Tarkime, kad vartotojas galiausiai tipai -50, tai o kilpa nebėra tiesa nes -50 yra ne didesnis nei 0. Taigi, mes išeiti iš, kad kilpa logiškai ir grįžti n. 

Bet yra vienas kitas dalykas turiu daryti. Ir aš tiesiog gali tai padaryti iki kopijuoti ir įklijuoti viena eilutė kodo ties failo viršuje. Man reikia mokyti žvangėjimas, ar žada žvangėjimas, aiškiai nurodoma, kad aš noriu, Iš tiesų, eikite ir įgyvendinti Ši funkcija get_negative_int. Tai gali būti tiesiog mažesnis failo. Vėlgi, priminti, kad klingsėti skaito dalykus iš viršaus į apačią, kairės į dešinę, todėl jūs negalite jų skambinti funkcija Jei žvangėjimas nepažįsta jis ketina egzistuoja. 

Dabar, deja, ši programa, kaip kai kurie iš jūsų galbūt jau pastebėjote, jau Buggy. Leiskite man eiti į priekį ir padaryti buggy3. Jis kaupia, todėl mano problema dabar ne sintaksės klaida, kaip teksto klaidos, tai tikrai bus logiškas klaida, kad aš sąmoningai padaryta galimybė žingsnis per tai, kas vyksta. 

Aš ruošiuosi eiti į priekį dabar ir paleisti buggy3. Ir aš ruošiuosi eiti į priekį, o ne bendradarbiauti. Aš ruošiuosi duoti jai skaičių 1. Tai nepatiko, todėl tai vėl paskatino mane. 

Kaip apie 2? 3? 50? Nė vienas iš šių dirba. Kaip apie -50? Ir atrodo, kad programoje dirbti. 

Leiskite pabandyti dar kartą. Leiskite man pabandyti -1, atrodo, kad darbas. Leiskite man pabandyti -2, atrodo, kad darbas. Leiskite man pabandyti 0. Huh, tai neteisinga. Dabar mes yra šiek tiek pedantiškas čia. Bet tai, žinoma, pasitaiko, kad 0 nėra nei teigiamas, nei neigiamas. Ir taip dėl to, kad mano programa yra sakydamas, kad 0 yra neigiamas sveikasis skaičius, tai ne techniškai teisinga. 

Dabar, kodėl jis tai daro? Na, tai gali būti akivaizdūs. Ir, tiesą sakant, ši programa yra reiškia būti gana paprasta todėl mes turime kažką tyrinėti. 

Bet tegul pristatyti trečią derinti technika čia vadinamas debug50. Todėl tai yra programa kad mes ką tik sukūrėte šiais metais vadinamas debug50 kuris leis jums naudoti tai, kas vadinama built-in grafinė derintojas į CS50 IDE. Ir debugerem yra tik programa, kuri paprastai leidžia jums paleisti savo programą bet žingsnis po žingsnio po žingsnio, linija iki eilutė po eilutės, sustoja, išnyra aplink, žiūri kintamųjų, kad Programa ne tik smūgis praeiti jums ir greitai spausdinti kažką ar ne spausdinti kažką. Jis suteikia jums galimybę, bent žmogaus greitis, bendrauti su juo. 

Ir tai padaryti, jums tiesiog atlikite šiuos veiksmus. Po kompiliavimo kodą, kurį aš jau padariau, buggy3, jūs einate į priekį ir paleisti debug50 ./buggy. Tiek daug, kaip help50 turi paleisti help50 ir tuomet komanda, debug50 turi paleisti debug50 ir tada komandą pavadinimas. 

Dabar žiūrėti, kas vyksta mano ekrano, ant dešinėje pusėje ypač. Kai aš paspauskite Vykdyti, visi iš Staiga tai dešinioji skydelis atveria ekrane. Ir ten daug vyksta nuo iš pirmo žvilgsnio. Bet ten ne per daug nerimauti dar. 

Tai rodo man viską kad vyksta viduje mano programos dabar ir per tai Mygtukai iki viršaus tada leidžia man dėti per mano kodas galiausiai žingsnis po žingsnio po žingsnio. Bet dar tik. Atkreipkite dėmesį, kas atsitiks. Mano terminalo lange Aš raginami n. Ir aš ruošiuosi eiti į priekį ir bendradarbiauti šiuo metu ir tipą -1. Ir nors šiek tiek cryptically -1 yra neigiamas sveikas skaičius, kaip tikimasi,. 

Ir tada vaikas išėjo su statusas 0 GDBserver išeinant. GDB GNU derintojas, yra vardas užtikrinamojo programinė įranga kad vykdo šią debugerem. Bet visa tai iš tikrųjų reiškia, kad debugerem pasitraukė, nes mano programa mesti ir viskas buvo gerai. Jei aš noriu tikrai derinti savo programą, Turiu Preemptively pasakyti debug50, kur aš noriu pradėti gerinimo per mano kodas? 

Ir galbūt paprasčiausias būdas padaryti, kad yra taip. Jei aš užveskite pelės žymeklį ant Latako mano redaktorius čia taip tikrai tik į šoninę juostą čia į eilutės numeris kairėje, Atkreipkite dėmesį, kad, jei aš tiesiog spustelėkite vieną kartą, aš įdėti mažą raudoną taškelį. Ir kad mažai red dot ", kaip stop ženklas, reiškia, ei, debug50, pauzė vykdymas mano kodas tiesiai ten, kai aš paleisti šią programą. 

Taigi leiskite tai padaryti. Leiskite man eiti į priekį ir paleisti savo programą vėl su debug50 ./buggy3, Enter. Ir dabar, pranešimas, kažkas skiriasi nutiko. Nesu raginami dar mano terminalo lange nieko, nes aš ne ten įsigijo dar mano programą. Atkreipkite dėmesį, kad 8 eilutė kuris dabar yra pabrėžta, ir ten šiek tiek rodyklę kairė posakis, jūs stabtelėjo čia. Šis kodas, linijos linija 8, dar nėra įvykdytas. 

Ir kas įdomu, jei aš žiūriu per čia, dešinėje pusėje, pastebėti, kad i yra vietos kintamasis, vietos ta prasme, kad viduje dabartinio funkcija. Ir jo vertė, matyt pagal nutylėjimą, ir tarsi patogiai, yra 0. Bet aš ne įrašykite 0. Tai tiesiog atsitinka būti jos Numatytoji reikšmė šiuo metu. 

Taigi leiskite man eiti į priekį ir tai padaryti dabar. Leiskite man eiti į priekį ir viršutiniame dešiniajame čia aš ketina eiti į priekį ir spustelėkite šį pirmąjį piktogramą, kuri reiškia peržengti, o tai reiškia ne praleisti ji bet žingsnis per šį kodo eilutę, vykdyti jai pakeliui. 

Ir dabar, pastebėsite, mano greitai ką tik pakeistas. Kodėl taip yra? Aš papasakojo debug50, paleisti šią eilutę kodo. Ką ši eilutė kodo daryti? Verčia mane už tarpt. GERAI. Leiskite bendradarbiauti. Leiskite man eiti į priekį ir dabar -1 tipo, "Enter". Ir dabar pastebėsite, kas pasikeitė. Dešinėje pusėje, mano vietos kintamasis i nurodoma kaip -1 dabar. Ir tai dar tipo int. 

Ir pranešimas, taip pat, mano vadinamasis skambinti krūvą, kur aš pristabdyti? Mes kalbame daugiau apie tai ateityje. Tačiau skambutis kamino tiesiog reiškia ką funkcijos yra šiuo metu juda. Dabar tai tik pagrindinis. Ir dabar vienintelis vietos kintamasis yra i su vertės 1 d. 

Ir kai aš pagaliau peržengti šią liniją čia su tuo pačiu piktogramą viršutiniame dešiniajame kampe, -1 Yra neigiamas sveikasis skaičius. Dabar jis sustoja per tą garbanotais petnešomis. Leiskite tegul ji padaryti savo dalykas. Aš peržengti tą liniją, ir voila. 

Taigi ne visi, kad siaubingai Paaiškinti dar, bet jis leiskite man pristabdyti ir manau per logiškai ką ši programa daro. Bet tai buvo ne klaidinga atveju. Leiskite tai padaryti dar kartą taip. 

Aš ruošiuosi išvykti iš šios atskaitos tašką 8 linijos su raudonu tašku. Aš ruošiuosi pakartotas debug50. Tai automatiškai sustabdytas čia. Bet šį kartą, vietoj gerinimo per šią liniją, leiskite man iš tikrųjų eiti viduje get_negative_int ir išsiaiškinti, kodėl jis priimdamas 0 kaip galiojantį atsakyti? 

Taigi vietoj paspausdami peržengti. Aš ruošiuosi eiti į priekį ir spauskite žingsnis į. Ir pastebėsite kad linija 8 tai dabar pabrėžė dabar staiga tampa eilutė 17. 

Dabar, tai nereiškia, kad išriktuotojo buvo praleista linijos 14 ir 15 ir 16. Tai tiesiog nėra nieko parodyti jums ten. Tie, kurie tik deklaruojant kintamuosius, ir tada ten žodis Ar ir tada atvira garbanotas petnešomis. Vienintelis funkcionalus linija, kuri yra sultingas tikrai tai vienas čia 17. Ir tai, kai mes automatiškai sustabdytas. 

Taigi printf ( "n.is:") ;, taip kad dar neįvyko. Taigi eikime į priekį ir spustelėkite peržengti. Dabar mano laiku, iš tikrųjų, pakeistas į ( "n yra:"). Dabar get_int, aš nesiruošia vargintis žengia į, nes ta funkcija buvo padaryta CS50 bibliotekoje. Tai turbūt teisinga. 

Taigi, aš ruošiuosi eiti į priekį ir rūšiuoti bendradarbiauti, suteikiant jam LC, bet nėra neigiamas INT. Taigi leiskite man eiti į priekį ir paspauskite 0. O dabar tai, kas vyksta čia kai aš kibti į liniją 21? Aš ne kartą pakartota. Nemanau, atrodo, įstrigo toje kilpa. Kitaip tariant, tai geltonos baras neišsaugojo vyksta aplink, ir aplink, ir aplink. 

Dabar, kodėl taip yra? Na, N, ką yra n dabar? Galiu pažvelgti vietos kintamieji išriktuotojo. n yra 0. Gerai, kas buvo mano būklė? 

20-- linija 20 yra gerai, 0 yra didesnis už 0. Tai netiesa. 0 yra ne didesnis nei 0. Ir todėl aš įsiplieskė apie tai. 

Ir taip, tai kodėl on-line 21, jei aš iš tikrųjų toliau, Aš ruošiuosi grįžti 0, net nors aš turėjo atmesti 0 kaip ne iš tikrųjų yra neigiamas. Taigi, dabar, aš tikrai ne, net rūpi išriktuotojo. Supratau, man nereikia, kad žinoti, kas daugiau, kas vyksta. 

Taigi, aš ruošiuosi eiti į priekį ir tiesiog spustelėkite mygtuką Groti, ir tegul šį baigti. Dabar, aš supratau, kad mano klaida yra, matyt, on-line 20 d. Štai mano logiška klaida. 

Ir taip, ko aš noriu daryti tai pakeisti? Jei problema yra tai, kad aš nesu traukiantis 0, tai tik logiška klaida. Ir galiu pasakyti, o n yra didesnis nei arba lygus 0, nuolat vėl ir vėl paskatino vartotoją. 

Taigi, vėlgi, paprastas klaida, galbūt net akivaizdu, kai pamatė mane rašyti vos prieš kelias minutes. Bet Takeaway čia yra tai, kad su debug 50, ir derinimo Programinė įranga apskritai turite šią naują rasti galią vaikščioti per savo kodo, ieškoti per tą dešiniajame skydelyje kas Jūsų kintamieji dydžiai. Taigi jūs nebūtinai turite naudoti kažką kaip jūs eprintf spausdinti šias vertybes. Jūs iš tikrųjų galite pamatyti juos vizualiai ekrane. 

Dabar, po to, verta pažymėti, kad yra ir kitas metodas, kuris yra tikrai super bendro. Ir galbūt įdomu, kodėl šis mažas vaikinas čia buvo sėdi ant scenos. Taigi ten šis metodas, paprastai žinomas kaip guminė antis derinimo, kuris tikrai yra tik testamentas į tai , kad dažnai, kai programuotojai rašote kodą jie nebūtinai bendradarbiauja su kitais, arba dirba bendrame aplinkos. 

Jie tarsi namuose. Gal tai vėlai naktį. Jie bando išsiaiškinti kai kurie jų klaidų kode. Ir jie tiesiog nemato ją. 

Ir nėra kambarioku. Nėra TF. Nėra ĮA aplink. Visi jie turi savo lentyna tai tiek gumos Ducky. 

Ir taip guminė antis derinimo yra tik tai kvietimas galvoti apie kažką kaip kvailas kaip tai kaip nekilnojamojo padaras, ir iš tikrųjų eiti per savo kodą žodžiu į šį negyvosios objektą. Taip, pavyzdžiui, jei tai yra mano pavyzdys here-- ir priminti, kad anksčiau problema buvo tai, jei aš ištrinti šį pirmą eilutę kodo, ir aš eiti į priekį ir padaryti Buggy 0 kartą Primenu, kad man teko juos pranešimai apie klaidas čia. Taigi, idėja čia juokinga, nors aš jaučiasi tuo momentu tai padaryti viešai, yra tai, kad klaida. 

Gerai, kad mano problema yra ta, kad aš netiesiogiai paskelbė bibliotekos funkciją. Ir kad bibliotekos funkcija yra printf. Declare-- Gerai, paskelbti man primena prototipų. 

Tai reiškia, kad man reikia iš tikrųjų pasakyti kompiliatorius iš anksto, ką funkcija atrodo. Palauk minutę. Aš neturėjau standartinį io.h. Labai ačiū. 

Taigi tik šis procesas of-- jumis nereikia iš tikrųjų turi antis. Tačiau šis ėjimas idėja save per savo kodo taip, kad jūs net girdėti sau, kad jums suvokti neveikimo jūsų pačių pastabos, paprastai yra idėja. 

Ir, ko gero daugiau logiškai, ne taip daug su tuo vienu, bet aktyviau dalyvauti pavyzdys mes tiesiog padarė buggy 3.c, jums gali vaikščioti save per ją taip. Taigi viskas gerai, gumos Ducky, DDB, jei bus. Čia mes turime savo pagrindinės funkcijos, Aš raginama gauti neigiamą int. 

Ir aš gaunu grąžos vertę. Aš ją saugoti kairės pusės 8 eilutėje kintamojo vadinamas i. Gerai, bet palauk, kaip tai padarė kad gauti tą vertę? Leiskite pažvelgti į funkciją atitinka 12. 

Pagal 12, mes turime gauti neigiamą int. Nesiima jokių sąnaudų, ar grąžina int, Gerai. Aš pareiškiu, 14 eilutėje kintamojo n. Ji ketina laikyti sveikasis skaičius. Tai ko aš noriu. 

Taigi atlikite šiuos veiksmus, o N is-- tegul man anuliuoti ką Fix aš jau padarė. Taigi, nors n yra didesnis nei 0, atsispausdinti N, Gerai. Ir tada skambinti gauti int saugomi n. Ir tada patikrinti, ar n yra 0, n yra not-- ten jis yra. Taigi, vėl, jūs neturite reikia faktinį antis. Bet tiesiog vaikščioti save per Jūsų kodas, kaip intelektualinė veikla dažnai jums padėti suprasti, kas vyksta, o ne tik tai, ką kaip tai, spoksoti į ekraną, ir nekalbu save per tai, kurie sąžiningai nėra beveik kaip veiksmingą technika. Taigi jūs turite tai A skaičius skirtingas technikas už faktiškai derinti savo kodą ir rasti kaltės, kurie visi turėtų būti įrankiai Jūsų Toolkit kad nesate vėlai naktį, ypač, esate valgomasis salės ar bent darbo valandomis, banking savo galvą prieš siena, bando išspręsti kai kurių problemų. Suprantu, kad yra programinės priemonės. Yra guminė antis įrankiai. Ir ten visai darbuotojai remti laukia ištiesti ranką. 

Taigi dabar, žodis nuo problemos rinkiniai, ir tai, ką mes tikimės jus gauti iš jų, ir kaip mes einame apie įvertinti. Už aikštyno mokymo programą, CS50 problema rinkiniai vertinami remiantis keturių pirminių ašių, todėl į speak-- apimtį, teisingumą, dizainas, ir stilius. Ir taikymo sritis tik nurodo, kiek kūrinio tu įkando išjungti? Kiek problema bandėte? Kokio lygio pastangų tu pasireiškia? 

Teisingumas yra, ši programa darbą, kaip jis turėjo už CS50 specifikacijos kai jūs pateikiate tam tikras žaliavas arba kai išėjimai grįžta? Dizainas yra labiausiai subjektyvus iš jų. Ir tai vienas, kad bus imtis ilgiausiai mokytis ir ilgiausiai mokyti, kad tiek, kiek jis gali būti suvesta į, kaip gerai parašyta jūsų kodas? 

Tai vienas dalykas, tiesiog atsispausdinti teisingas išėjimai arba grąžinti teisingas vertybes. Bet tu darai jį kaip veiksmingai, kaip įmanoma? Ar jūs darote tai atskirtį ir valdyk, arba dvejetainis paieška, kaip mes netrukus pamatysite, kad mes padarėme prieš dvi savaites su telefonų knygos? Ar yra geresnių būdų, kaip išspręsti problema, nei šiuo metu turite čia? Tai labai geresnio dizaino galimybė. 

Ir tada style-- kaip gana tavo kodas? Jūs pastebėsite, kad aš esu gana ypač apie atitraukdami savo kodą, ir todėl, kad mano kintamuosius yra pagrįstai pavadintas. n, o trumpai tariant, yra geras vardas dėl skaičius, i suskaičiavimo sveikasis skaičius s eilutę. Ir mes galime turėti daugiau kintamųjų vardai stilius. Stilius yra tik kaip gerai Ar jūsų kodas atrodo? Ir kaip skaitoma tai? 

Ir laikui bėgant, kas jūsų TAS ir TFS darys kurso yra suteikti jums, kad rūšies kokybinės grįžtamosios taip, kad jums geriau tose įvairiais aspektais. O kalbant apie tai, kaip mes įvertinti kiekvienas iš šių ašių, tai paprastai su labai mažai kibirai, kad jūs, paprastai, gauti, kaip gerai jūs darote jausmą. Ir, iš tiesų, jei jūs gaunate rezultatą bet iš tų axes-- teisingumą, dizainas ir stilius especially-- šis skaičius paprastai bus tarp 1 ir 5. Ir tiesiog, jei jūs gaunate 3 At semestro pradžios, tai yra labai geras dalykas. Tai reiškia, kad vis dar tobulinti, kurį būtų tikėtis iš atsižvelgiant klasę pirmą kartą. Yra tikiuosi kai lubų tiek prie kurio esate trokštantis pasiekti. Ir taip vis 3 spustelėjimas Ankstyviausi gabalus, jei ne kai 2 "ir 4 s, yra, iš tiesų, yra geras dalykas. Tai gerai zonoje, gerai per lūkesčius. 

Ir jei jūsų protas yra lenktynių, palaukite minutę, trys iš penkių. Tai tikrai 6 iš 10. Štai 60%. Mano Dieve, kad įvyko F. 

Tai nėra. Tai ne, iš tiesų, kad. Atvirkščiai, tai galimybė gerinti per semestro metu. Ir jei jūs gaunate šiek tiek Poors, tai yra galimybė pasinaudoti darbo valandomis, neabejotinai skyriai ir kitus išteklius. 

Geriausia yra galimybė, tikrai, didžiuotis, tik kiek jūs ateina per semestro metu. Taigi nereikia suprasti, jei nieko kitur, trys yra gera. Ir tai leidžia vietos augimo per tam tikrą laiką. 

Kaip tie kirviai yra svertinis, realiai esate ketina išleisti didžiąją dalį savo laiko gauti dalykų į darbą, jau nekalbant apie neteisingai. Ir taip teisingumą linkęs būti įvertintas labiausiai, kaip ir tai dauginamasis koeficientas trijų. Dizainas yra taip pat svarbu, bet kažkas, kad jūs padaryti nebūtinai praleisti visus tuos valandas bando gauti viskas tiesiog veikia. 

Ir todėl jis įvertintas šiek tiek lengvesnės. Ir tada stilius įvertintos mažiausiai. Nors tai ne mažiau svarbu iš esmės, tai tik, ko gero, Paprasčiausias dalykas, tai teisinga, mėgdžiodami pavyzdžius mes padaryti paskaitą ir skyriuje dalykų gražiai įspaudžiami ir komentarų, ir tt yra vienas lengviausiai ką daryti ir gauti teisę. Taigi, kaip, pavyzdžiui, suprasti, kad tie, kurie taškai kad yra gana lengva suprasti. 

O dabar žodis this-- akademinį sąžiningumą. Taigi už aikštyno programa, pamatysite kad kursas turi gana tiek kalba apie tai. Ir žinoma, mano klausimas, akademinis sąžiningumas gana rimtai. 

Mes turime atskirti, geriau ar blogiau, , kad jis išsiuntė kasmet daugiau studentai dėl drausminių veiksmų nei dauguma bet kurios kitos Žinoma, kad žinau. Tai nebūtinai rodo tai, kad CS studentų, ar CS50 studentų, yra bet mažiau sąžiningi, nei jūsų klasiokų. Tačiau realybė, kad tai pasaulis, elektroniniu būdu, mes tiesiog turi technologijų reiškia aptikti tai. 

Svarbu mums teisingumas visoje klasėje kad mes aptikti tai ir pakelkite klausimas, kai mes matome dalykus. Ir tik nupiešti piešinį, ir tikrai padėti kažką panašaus į tai kriauklė, Šitie yra numeriai studentai per pastaruosius 10 metų , kurie buvo įtraukti į kai tokie klausimai akademinės sąžiningumo, su kai 32 studentų nuo kritimo 2015, kuris yra pasakyti, kad mes imtis klausimas labai rimtai. Ir, galiausiai, šie skaičiai rašyti, labiausiai neseniai, apie 3%, 4%, arba tiek iš klasės. 

Taigi super dauguma studentų atrodo, kad linijos yra aiškios. Bet tai turi būti mind, ypač vėlai naktį, kai kovoja su kai išspręsti problemą rinkinys, , kad turi priemonių gauti sau geriau parama, nei jūs manau, net tą pačią valandą. Suprantu, kad kai gausime Studentų argumentai, mes kirsti palyginti kiekvieną pateikimo šiemet prieš kiekvieną pateikimo pernai, prieš kiekvieną pateikimo nuo 2007 ir nuo, žiūri, taip pat, kodas saugyklų internete, diskusijų forumai, darbo vietų. Ir mes paminėti, tikrai, viskas vardan visiško atskleidimo, kad jei kažkas gali rasti internete, tikrai, todėl mes galime kursas. Bet, tikrai, dvasia Kurso suvesta į šią sąlygą į mokymo programą. Jis tikrai yra teisingas, pagrįstas. 

Ir jei mes turėjo parengti apie tai tik su šiek tiek daugiau kalba, suprasti, kad visų esmė darbas, kad jūs pateikti šį kursą turi būti jūsų pačių. Bet per Be to, yra žinoma, galimybės ir skatinimas, pedagoginė vertė kreipiasi į others-- save, TFS, CAS, kad TAS, ir kiti klasėje, paramos, jau nekalbant apie draugus ir kambariokai, kurie mokėsi AP ir programavimas anksčiau. Ir taip yra už tai pašalpa. Ir bendra taisyklė nykščio yra this-- prašydami pagalbos, galite parodyti savo kodą su kitais, bet negalite peržiūrėti savo. Taigi, net jei esate ne darbo valandomis, arba D salėje, ar kur kitur darbo dėl kai kurių dalių rinkinys, dirbti kartu su draugu, kuris yra visiškai gerai, ne pabaigos dienos savo darbą galiausiai turėtų priklausyti kiekvienas jus atitinkamai, o ne būti šiek tiek bendromis pastangomis, išskyrus galutinio projektas, kuriame tai leidžiama ir skatinama. 

Suprantu, kad, jei esate kovoja su kažkuo ir jūsų draugas tiesiog atsitinka kad geriau tai tada tu, ar geriau tuo problema, nei jūs, arba šiek tiek toliau į priekį nei jums, tai visiškai logiška paversti savo draugui ir sako, ei, tu protas žiūri į mano kodas čia padeda man vietoje, ką mano klausimas? Ir, tikiuosi, į interesas pedagoginę vertę kad draugas ne tik sako, oi, tai padaryti, bet, ką tu trūksta on-line 6, ar kažkas panašaus? Bet tirpalas yra ne kitą draugas jums pasakyti, oi, gerai, čia, leiskite man traukti tai aukštyn, ir parodyti savo sprendimą Jums. Taip, kad yra linija. Jūs parodyti savo kodą kiti, bet jūs negalite peržiūrėti jų, atsižvelgiant į kitas apribojimų aikštyno mokymo programą. 

Taigi, reikia nepamiršti šio Vadinamasis apgailestauju sąlyga Be abejo anketa mokymo programas, taip pat, kad jei jums įsipareigoja tam tikrą teisės aktą, kad nėra pagrindo, bet apie jį kurso s vadovų dėmesys per 72 valandas, žinoma, gali taikyti vietos sankcijas, gali būti nepakankamas arba jei pažymys už pateiktą darbą. Bet žinoma, nebus perduoti klausimas dėl tolesnio drausminių veiksmų, išskyrus atvejus, kai pakartotinai aktais. Kitaip tariant, jei jūs padaryti kai kvaila, ypač vėlai naktį, sprendimas kad kitą rytą arba dvi dienas vėliau, jums pabusti ir suprasti, kas buvo aš galvoju? Jūs padaryti CS50 turi lizdą nustatant šią problemą ir turinti iki jo, taip, kad mes jus pasitiks pusiaukelėje ir spręsti su juo į klausimą, kad yra tiek švietimo ir vertinga už jus, bet vis baudinius tam tikru būdu. Ir dabar, imtis Naostrzyć, tai. 

[Vaizdo įrašų atkuriamų] 

[GROJA MUZIKA] 

[PABAIGA PLAYBACK] David J. Malan: Gerai, mes atgal. Ir dabar mes žiūrime į vieną iš Pirmasis mūsų realaus pasaulio domenų į CS50, kad kriptografija menas, siuntimo ir gavimo menas slapti pranešimai, saugiame pranešimus, jei norite, kad gali būti iššifruoti tik tada, jei turi kai pagrindinis ingredientas, kad siuntėjas turi taip pat. Taigi, norint motyvuoti tai mes priimsime Žvilgsnis šio dalyko čia kuris yra iš A pavyzdys Paslaptis dekoderis žiedas, gali būti naudojamas tam, kad išsiaiškinti kas paslaptis žinutė iš tikrųjų yra. Iš tiesų, atgal į dieną pradinėje mokykloje, jei kada nors išsiųsti slaptas žinutes kai draugas ar kai klasėje traiškyti, jums gali turėti minties Jums buvo yra protingas pagal savo gabalas popieriaus keičiasi, kaip, nuo A iki B, ir B C, ir C-D, ir taip toliau. Bet jūs iš tikrųjų buvo šifravimo jūsų informacija, net jei ji buvo šiek tiek nereikšmingas, nebuvo kad sunku mokytojas suprasti, Na, jei jūs tiesiog pakeisti B-A ir C į B, jūs iš tikrųjų išsiaiškinti, ką žinia buvo, bet jums buvo kodavimo informaciją. 

Jūs buvote tiesiog tai daro tiesiog, panašiai kaip Ralphie čia garsaus filmo, kuris vaidina gana daug Argumentas iš kartojimo kiekvieną žiemą. [Vaizdo įrašų atkuriamų] -Be To žinoma, kad visa tai Ralph Parkeris yra iš dalies paskirtas Little narys Našlaitė Annie paslaptis Draugų ir ji turi teisę į visas pagyrimu ir nauda pasireiškia tuo. 

-Signed Little Našlaitė Annie, Skaitliukas pasirašė Pjeras André rašalu. Garbės ir naudą, jau esant devynių amžiaus. 

[Šaukti] -Nagi. Leiskite gauti su juo. Man nereikia visą tą džiazą apie kontrabandininkus ir piratai. 

-Listen Rytoj naktį baigiamasis nuotykių juodo piratų laivą. Dabar atėjo laikas Annie paslaptis žinutė Jums nariai Slaptas ratas. Atminkite, kad vaikams, tik nariai Annie Secret Circle gali dekoduoti Annie slaptą žinutę. 

Įsiminti Annie priklauso nuo jūsų. Nustatykite savo smeigtukai B2. Čia yra žinia. 12, 11-- 

-Aš Esu, mano pirmasis slaptą susitikimą. 

-14, 11, 18, 16. 

-Pierre Buvo labai balso vakarą. Galėčiau pasakyti, kad vakaro žinutė buvo tikrai svarbus. 

-3, 25, tai pranešimas nuo Annie save. Atminkite, kad nereikia niekam. 

vėliau -90 sekundžių, aš tik kambarys name, kuriame iš devynių berniukas gali sėdėti privatumo ir iššifruoti. Aha B! Nuėjau į kitą, E. 

Pirmas žodis yra būti. S, tai buvo dar lengviau dabar, U, 25-- 

-OH, Nagi, Ralphie, aš turiu eiti! 

-I'll Būti nustatančio teisę Ma! Gee nusišvilpti! 

T, P, būtinai to-- būtinai ką? Kas buvo mažai Našlaitė Annie bando pasakyti? Būtinai ką? 

-Ralphie Andy pateko eiti, jūs galite išeiti? 

-Visa Teisę Ma! Aš būsiu teisus ne! 

-Aš Buvo vis arčiau dabar. Įtampa buvo baisi. Kas tai buvo? Planetos likimas gali pakabinti ant plauko. 

-Ralphie! Andy gotta go! 

-I'll Būti tiesiai iš, šaukė garsiai! 

-Almost Ten, mano pirštai skrido, mano protas buvo plieno gaudyklė, kiekvienas porų vibravo. Tai buvo beveik aišku, taip, taip, taip. 

-Be Būtinai gerti savo Ovaltine. Ovaltine? Prastas komercinis? Šunsnukis. [PABAIGA PLAYBACK] David J. Malan: Gerai, kad Tai buvo labai ilgas kelias įvesti kriptografiją, ir taip pat Ovaltine. Iš tiesų, iš šio seno skelbimą čia, tai kodėl Ovaltine taip gerai? Ji yra koncentruotas ekstrakcija prinokę miežių salyklas, grynas riebus karvės pienas, ir specialiai paruošti kakavos, kartu su gamtos fosfatidų ir vitaminų. Be to, yra prisotintas papildomas vitaminų B ir D, Yum. Ir jūs vis dar galite gauti jį, matyt, "Amazon", kaip mes čia padarė. 

Tačiau motyvacija čia buvo pristatyti kriptografiją, ypač iš kriptografija tipas žinomas kaip slaptą rakto kriptografija. Ir kaip rodo pavadinimas, visos saugumas slaptą rakto kriptografija sistemos jei bus, metodika tik už kodavimo informacija tarp dviejų žmonių, yra tai, kad tik siuntėjas ir tik gavėjas žinoti slaptą key-- tam tikrą vertę, kai Paslaptis frazė, kai paslaptis numerį, kad leidžia jiems tiek šifravimo ir iššifruoti informaciją. Ir kriptografija, tikrai, yra tik tai nuo 0 savaitės. 

Tai problema, kur yra įėjimai, kaip faktinio pranešimą anglų kalba ar kokia kalba, kuri jums norite siųsti kažkam klasėje, arba per internetą. Yra kai kurių produkcija, kuri vyksta būti koduotus pranešimą, kad jums noriu gavėjas gauti. Ir net jei kas nors viduryje jį gauna per, nenorite juos nebūtinai galėtų jį iššifruoti, nes vidinės tai juoda dėžutė, arba algoritmas, yra kai mechanizmas, kai žingsnis po žingsnio instrukcijos, skirtos imtis, kad pirkimo ir konvertuoti jį į rodmenys tikiuosi saugiai. 

Ir, iš tiesų, yra keletas žodynas šiame pasaulyje taip. Paprastas tekstas yra žodis kompiuterių mokslininkas būtų naudoti apibūdinti įvestį žinutė, kaip ir anglų kalba ar kokia kalba jūs iš tikrųjų norite siųsti į kitą žmogų. Ir tada ciphertext yra peštynės į užšifruota arba užšifruoti, jos versija. 

Bet yra vienas kitas ingredientas čia. Yra vienas kitas įvestis Paslaptis rakto kriptografija. Ir, kad yra pati raktas, kuris yra, paprastai, kaip matysime, skaičius, arba laiškas arba žodis, nesvarbu, kokia algoritmas yra iš tikrųjų tikisi. 

Ir kaip jums iššifruoti informaciją? Kaip jūs ją Rozszyfrować? Na, jūs tiesiog pakeisti šią išėjimai ir įėjimai. 

Kitaip tariant, vieną kartą kas nors gauna šifruotą pranešimą, jis ar ji tiesiog turi žinoti, kad tas pats raktas. Jie gavo ciphertext. Ir įkišant šių dviejų įėjimai į šifravimo sistema, algoritmas, tai juoda dėžutė, iš turėtų ateiti originalų paprastojo. Ir taip tai labai aukšto lygio vaizdas, kas kriptografija yra iš tikrųjų Viskas apie. 

Taigi galime gauti ten. Leiskite dabar atrodo po kažko gaubtas mes jau vartojate už suteikiamas praėjusią savaitę ir šios sesijos here-- eilutę. Eilutė, tuo dienos pabaigoje yra tik ženklų seka. 

Tai gali būti hello world arba Sveiki Zamyla, ar kas. Bet ką tai reiškia būti simbolių seka? Tiesą sakant, CS50 biblioteka suteikia mums duomenų tipas vadinamas eilutė. 

Bet iš tikrųjų nėra toks dalykas kaip C eilutę Tai tikrai yra tik seka charakteris, charakteris, charakteris, charakteris, nugaros, atgal, į atgal, atgal, atgal viduje jūsų kompiuterio atmintyje, ar atminties. Ir mes pažvelgti giliau į, kad ateityje, kai mes žiūrime į pačią atmintį, ir panaudojimo, ir grėsmės, kurios dalyvauja. 

Bet tegul mano eilutę Zamyla. Taigi tiesiog iš vardas žmogaus čia Zamyla, kad yra seka simbolių, Ž-A-M-Y-L-A. O dabar tarkime, kad Zamyla vardas yra saugomas viduje kompiuterio programa. 

Na, tai suprantama, kad mes turėtume gebėti pažvelgti į tų ženklų atskirai. Taigi, aš tik ketina padaryti šiek tiek Lauke aplink Zamyla vardo čia. Ir tai yra C atvejis, kai jūs turėti eilutę, pavyzdžiui, Zamyla-- o gal kad seka grįžo iš funkcija kaip get eilutę, jūs iš tikrųjų galite manipuliuoti tai charakteris pagal charakterį. 

Dabar, tai yra Germane už pokalbis vertus, dėl į kriptografiją, jei norite pakeisti Nuo A iki B, ir B C, ir C-D, ir taip toliau, reikia, kad būtų galima pažvelgti į atskirus simbolius į eilutę. Jums reikia, kad būtų galima pakeisti Z į ką nors kita, A kažką kitam, M kažkas, ir pan. Ir todėl mes turime būdą, programiškai, todėl sakant, C, kad būtų galima pakeisti ir pažvelgti atskirų raidžių. Ir mes galime tai padaryti taip. 

Leiskite man eiti galvą atgal į CS50 IDE. Ir leiskite man eiti į priekį ir sukurti naują failą kad aš tai vadina laiko string0, kaip mūsų pirmojo tokio Pavyzdžiui, dot c. Ir aš ruošiuosi eiti į priekį ir plakti jį taip. 

Taigi yra CS50.h ir tada apima standartinį io.h, kurios aš beveik visada vyksta būti naudojant mano programų, bent jau pradžių. int main negaliojančiu, o tada čia aš ketinate daryti eilutes gauna gauti eilutę. Ir tada aš ruošiuosi eiti į priekį ir tai padaryti. Noriu eiti į priekį ir, kaip normalumas patikrinti, tiesiog pasakyti, labas, proc s kabliataškis, daro eilutę 0. Uh oh, ką aš padaryti čia? Ech, man nebuvo prijunkite jį. Taigi pamoka, kad nebuvo tyčinis. 

Taigi klaida, daugiau procentų konversijų nei duomenų argumentais. Ir tai yra, kai, linija 7-- Gerai, kad turiu, citata citatos pabaiga, tai mano string printf. Aš turiu procentų ženklas. Bet aš trūksta antrojo argumento. 

Aš trūksta kablelio s, kuri Aš turėti ankstesniuose pavyzdžiuose. Taigi gera proga pataisyti dar viena klaida, netyčia. O dabar leiskite man paleisti string0, tipo Zamyla. Gerai, labas Zamyla. 

Taigi mes paleisti šią programą natūra keletas skirtingų kartų dabar. Bet darykime kažką tiek skiriasi šį kartą. Užuot tiesiog spausdinti Zamyla s Visas pavadinimas out su printf, Darom charakterį pobūdžio. 

Aš ruošiuosi naudoti už kilpa. Ir aš ruošiuosi duoti save suskaičiavimo kintamasis, vadinama i. Ir aš ruošiuosi laikyti Iteracja, todėl tol, kol i yra mažiau nei s ilgio. 

Pasirodo, mes ne tai padaryti paskutinį kartą, kad c ateina su funkcija vadinama Stirling. Atgal į dieną, ir apskritai dar kai įgyvendinant funkcijas, žmonės dažnai pasirenka labai glausti vardai, garso natūra patinka tai, ką norite, nors tai trūksta kelių balsių ar raides. Taigi Stirlingas yra Pavadinimas funkcija, kuri užima tarp argumentą skliaustai, kad turėtų būti eilutė. Ir tai tik grąžina sveikąjį skaičių, šios eilutės ilgis. 

Taigi, tai už kilpa 7 eilutėje vyksta pradėti skaičiuoti ne aš lygus 0. Ji ketina prieaugio Aš ant kiekvienos iteracijos 1, kaip mes darome kelis kartus. Bet jis ketina padaryti tik tai iki taško, kai i ilgis pačios eilutę. 

Taigi tai yra būdas, galiausiai, Iteracja per simbolių į eilutę, kaip yra taip. Aš ruošiuosi atsispausdinti nėra Visa eilutė, bet procentai C vienas simbolis po to naujos linijos. Ir tada aš ruošiuosi eiti į priekį, ir man reikia pasakyti, kad aš noriu spausdinti -osios pobūdis s. 

Taigi, jei aš yra kintamasis, kuris nurodo eilutės, kur indeksas jūs į jį, man reikia, kad būtų galima sako, duok man i-tojo požymio s. C turi daryti taip, kaip tai su laužtiniuose skliaustuose. Jūs galite tiesiog ištarkite vardą eilutė, kuri šiuo atveju yra S. Tada jums naudoti skliaustus,, kurie yra paprastai virš grąžą arba įveskite klaviatūros klavišą. Ir tada jūs įtraukėte indekso charakteris, kurį norite spausdinti. Taigi indeksas ketina būti number-- 0, arba 1, arba 2, arba 3, arba taškas, taškas, taškas, kai kurių kitų skaičių. 

Ir galime užtikrinti, kad jis ketina būtų teisingas skaičių, nes aš pradėti skaičiuoti 0. Ir pagal nutylėjimą, pirmasis simbolis į eilutę pagal susitarimą 0. Ir antra charakteris yra laikiklis 1. Ir trečia charakteris yra laikiklis 2. Ir jūs nenorite eiti per toli, bet mes ne todėl, kad mes vyksta tik prieaugio i tol, kol jis yra lygus Eiluė. Ir kuri vieta, tai už kilpa sustos. 

Taigi leiskite man eiti į priekį ir sutaupyti tai programa, ir paleisti padaryti eilutę 0. Bet aš įsukus. Netiesiogiai teigiama bibliotekos funkcija Stirling su tokio tipo, ir such-- dabar tai skamba pažįstamai. Bet tai ne printf. Ir tai ne gauti eilutę. 

Aš ne susukti į taip pat, šį kartą. Tačiau pastebėti žemyn čia truputį žemyn Be to, yra antraštės string.h, aiškiai teikti deklaracija Stirling. Taigi yra iš tikrųjų ten raktas. 

Ir iš tiesų paaiškėja, yra ir kitas antraštės failą kad mes ne naudoti klasėje, bet tai tarp tų, galima Jums, vadinamas string.h. Ir į tą bylą, string.h yra Stirlingo deklaruoti. Taigi leiskite man eiti į priekį ir išsaugoti tai, kad seka 0-- gražus, jokių klaidų pranešimai šįkart. 

./string0 Zamyla ir Aš apie paspauskite Enter, už kurią getstring taškas vyksta grįžti eilutę, įdėti jį į s. Tada, kad kilpa ketina pakartoti per s įtrauktas į simbolių vienu metu, ir spausdinti juos po vieną eilutėje, nes Turėjau tą backslash n pabaigoje. Taigi galėčiau praleisti tą kairinį brūkšnį, N, o tada tiesiog atsispausdinti Zamyla visi toje pačioje eilutėje, efektyviai reimplementing printf, kuris yra ne visi, kad naudinga. Tačiau šiuo atveju, aš ne padaryti. Aš faktiškai atspausdinta vieną simbolis vienu metu, po vieną kiekvienoje eilutėje, taip, kad mes iš tikrųjų pamatyti poveikį. 

Bet man reikia atkreipti dėmesį į vieną dalyką čia. Ir mes grįžti į tai ateityje savaitę. Pasirodo, kad tai kodas yra potencialiai Buggy. 

Pasirodo, kad gauti eilutę ir kai kurių kitų funkcijų gyvenime nebūtinai visada grįžti, ką jūs laukiate. Mes žinome iš klasės paskutinio Laikas tai, kad gauti eilutė turėtų grįžti eilutę. Bet kas, jei vartotojas įveda tokias ilgas žodis arba dalis, ar esė kad ten tiesiog nėra pakankamai atminties į kompiuterį, kad tilptų jį. 

Kaip, kas, jei kažkas negerai po gaubtu? Tai gali neįvyks dažnai bet tai gali atsitikti, kai kartais, labai retai. Ir taip it turns out, kad gauti eilutę ir funkcijas, pavyzdžiui, jį nebūtinai visada grįžti eilutes. Jie gali grįžti šiek tiek klaidos reikšmę, kai Sentinel vertė taip sakant, kad rodo, kad kažkas negerai. Ir jūs žinote, tik tai iš išmokus ją klasėje dabar arba perskaitęs šiek tiek daugiau dokumentaciją. Pasirodo, kad gauti eilutę gali grįžti vertę, vadinamą niekinis. Null yra speciali reikšmė, mes grįžti į būsimame savaitę. Bet dabar, tiesiog žinau, kad jei aš noriu būtų tikrai teisingas juda į priekį naudojant get eilutę, aš turėtų būti ne tik jį vadiname, ir aklai naudotis savo grąžos vertę, pasitikėti, kad tai eilutė. 

Aš pirmą kartą reikia pasakyti, Ei, palauk, tik elgtis, jei -ai nėra lygi nulis, kur nulis, vėl, yra tik keletas ypatingą vertę. Ir tai tik ypatinga vertė, kurią reikia nerimauti Get eilutę. Gauk eilutė arba vyksta grįžti eilutę arba null. 

Ir tai šauktukas lygus ženklą žinote iš gal matematikos klasės kad jūs galite padaryti lygybės ženklą su linija per jį rodo ne vienoda. Tai ne apskritai simbolis galite įvesti klaviatūroje. Ir taip daugelyje programavimo kalbų, kai norite pasakyti ne lygūs, naudoti šauktuką, kitaip žinomas kaip trenksmu. Taigi jūs sakote sprogimo lygi, kuris reiškia ne lygus, logiškai. Tai kaip ten ne didesnė nei arba lygus arba mažesnis nei arba lygus klaviatūros klavišą kad visa tai vienoje simboliu. Štai kodėl, pastaruosius pavyzdžių, tu atvirą laikiklį, tada lygybės ženklas, tam, kad padaryti didesnis nei arba, tarkim, mažiau nei. 

Taigi, kas yra Takeaway čia? Tai tiesiog būdas dabar ir įvedant šią sintaksę, ši funkcija, Iteracja individualios simbolių eilutę. Ir kaip tas kvadratas kronšteinai leidžia jums gauti į juos, atsižvelgti į tas skliaustus, kaip rūšies užuomina į tai pagrindinis dizainas, pagal kurią kiekvienas simbolių viduje eilutę rūšies supakuota kažkur po Į kompiuterio atmintį gaubtu. 

Bet tegul padaryti šį variantą. Pasirodo, kad tai programa yra teisinga. Taigi už CS50 anketa ašių įvertinti kodas, tai yra teisinga dabar. Ypač dabar, kad aš tikrinti niekinis, ši programa turėtų niekada avariją. Ir aš tiesiog žinau, kad iš patirties. Bet ten nieko, kad mes tikrai gali suklysti čia. Bet tai nėra labai gerai suprojektuoti, nes grįžkime prie pagrindo. 

Pirma, principles-- Ką for ciklas daryti? A kilpą daro tris dalykus. Ji inicijuoja kai vertė, jei jūs paprašykite jį. Jis tikrina sąlygą. Ir tada po kiekvieno iteracijos, po kiekvieno ciklo tai padidina kai vertė, ar vertės, čia. 

Taigi, ką tai reiškia? Mes inicijuoti i 0. Mes tikriname ir įsitikinkite, kad i yra mažiau nei jei S ilgis, kuris yra Ž-A-M-Y-L-A, taip, kuris yra mažesnis nei 6. Ir, tiesą sakant, 0 kaip mažiau kaip 6. 

Mes atsispausdinti Z nuo Zamyla vardu. Tada mes prieaugio i nuo 0 iki 1. Tada patikrinkite, yra 1 mažiau nei s ilgio? Iš s ilgis yra 6. Taip tai yra. 

Taigi, mes atspausdinti per Zamyla vardą, ZA. Mes prieaugio i nuo 0, 1, iki 2. Tada patikrinkite, yra 2 mažiau nei iš Zamyla vardo ilgis. 6- taip 2 yra mažiau nei 6. Taip, tegul atsispausdinti dabar M Zamyla vardas, trečiasis simbolis. 

Raktas čia yra tai, kad kiekvienas iteracijos istorijos, aš patikrinti, yra man mažiau nei Zamyla ilgio? Bet laimikis, kad Stirlingo nėra nuosavybė. Tie iš jūsų, kurie užprogramuoti prieš Java arba kitomis kalbomis gali žinoti ilgis eilutė yra nuosavybė, tik kai perskaičiau tik vertę. 

C šiuo atveju, jei tai yra funkcija, kuri yra tiesiog skaičiuojant skaičių simbolių Zamyla kiekvieną kartą mes vadiname šią funkciją. Kiekvieną kartą, kai jūs paprašykite kompiuterį naudoti Stirlingo, tai atsižvelgiant pažvelgti Zamyla, ir suprantama Ž-A-M-Y-L-A, 6. Ir jis grįžta 6 d. Kitą kartą jūs vadinate jis viduje, kad kilpa, jis ketina pažvelgti Zamyla vėl, pasakyti Ž-A-M-Y-L-a punktą, 6. Ir jis ketina grįžti 6 d. Taigi, kas yra kvaila apie šį dizainą? 

Kodėl mano kodas nėra 5 iš 5 projektavimo dabar, taip sakant? Na, aš prašau Klausimas be reikalo. Darau daugiau darbo nei man reikia. 

Taigi, nors atsakymas yra teisingas, aš esu klausia kompiuterį, kas yra iš Zamyla ilgis vėl ir vėl, ir vėl, ir vėl? Ir atsakymas yra niekada pakeisti. Jis visada bus 6. 

Taigi geresnis sprendimas, nei tai Būtų tai kitą versiją. Leiskite man eiti į priekį ir įdėti jį į atskiras failas, vadinamas string1.c, tiesiog laikyti jį atskirti. Ir paaiškėja, skirtame kilpa, jūs iš tikrųjų galite paskelbti kelis kintamuosius vienu metu. 

Taigi, aš ruošiuosi laikyti i ir nustatykite jį į 0. Bet aš taip pat ketina pridėti kablelį, ir pasakyti, man kintamąjį vadinamą n, kurio vertė yra lygi stygų ilgį s. O dabar, prašom padaryti, kad mano būklė tol, kol i yra mažiau nei n. 

Taip tokiu būdu, logika yra identiški dienos pabaigoje. Bet aš prisimena vertė 6, šiuo atveju. Kas yra Zamyla vardo ilgis? Ir aš pradėti jį n. 

Ir aš vis dar tikrinti sąlyga kiekvieną kartą. Ar 0 jaunesniems nei 6? Yra 1 mažesnis kaip 6? Ar 2 mažiau kaip 6 ir tt? 

Bet aš nesu klausia kompiuterį vėl, ir vėl, kas iš Zamyla vardo ilgis? Kokia Zamyla vardo ilgis? Koks šio Zamyla vardo ilgis? Aš tiesiog prisiminti, kad pirmasis ir atsakyti tik šio antrojo kintamojo n. Todėl tai dabar būtų ne tik teisinga, tačiau taip pat gerai suprojektuoti. 

Dabar, ką apie stilių? Aš pavadintas mano kintamuosius gana gerai, sakyčiau. Jie itin glaustas dabar. Ir tai visiškai gerai. 

Jei turite tik vieną Styga į programą, Jums gali taip pat skambinti tai s eilutę. Jei turite tik vieną kintamąjį skaičiavimo programoje, Jums gali taip pat skambinti jai i. Jei turite ilgis, n yra super bendra, taip pat. Bet aš ne komentavo bet mano kodas. 

Aš ne informavo reader-- ar tai mano TF, ar TA, ar tiesiog colleague-- kas turėtų būti vyksta šioje programoje. Ir taip gauti gerą stilių, ką aš noriu daryti yra this-- kažkas kaip paklausti vartotoją įvesties. Ir galėčiau perrašyti tai bet kurį iš būdų. 

Įsitikinkite s-- įsitikinkite get styginių grįžo eilutę. Ir tada here-- ir tai galbūt svarbiausia comment-- kartoti per S vienoje simbolių vienu metu. Ir aš galėtų naudoti bet pasirinkimas anglų kalba Čia aprašyti kiekvienas Šių kodo gabaliukus. 

Atkreipkite dėmesį, kad aš ne įdėti pakomentuoti kiekvieną kodo eilutę, tikrai tik dėl įdomus Ones tie, kurie turėti tam tikrą reikšmę kad galėčiau nori padaryti super aišku, kad kažkas skaityti mano kodą. Ir kodėl jūs skambinate gauti styginių paklausti vartotoją įvesties? Net, kad vienas yra nebūtinai visi, kad aprašomasis. Bet tai padeda pasakoti istoriją, nes Antroji eilutė į istoriją yra, įsitikinkite, kad gauti eilutė grįžo eilutę. 

Ir trečia eilutė į istoriją yra pakartoti per S vieną simbolių tuo metu. O dabar tiesiog gera priemonė, Aš ruošiuosi eiti į priekį ir pridėti dar vienas komentaras, kad tik sako Spausdinti i-asis veikėjas s. Dabar, kas aš padariau Dienos pabaigoje? 

Aš pridėjo keletą Anglų žodžiai pastabų forma. Velniop velniop simbolis reiškia, ei, kompiuteris tai yra už žmogaus, ne tau, kompiuteris. Taigi jie ignoruojami logiškai. Jie tiesiog ten. 

Ir, tiesą sakant, CS50 IDE rodo juos kaip pilka, kaip naudingi, bet ne raktas į programą. Atkreipkite dėmesį, ką dabar gali padaryti. Nesvarbu, ar jūs žinote, C programavimo, ar ne, jums gali tiesiog stovėti atgal tai programa, lieso komentarus. Klauskite vartotoją įvesties, įsitikinkite, kad gauti eilutė grįžo eilutę, pakartoti per S simbolių vienu metu, spausdinti simbolį i-asis veikėjas s-- jūs neturite net pažvelgti kodas suprasti, ką ši programa daro. Ir dar geriau, jei jūs sau atrodo ne šios programos per savaitę ar dvi, arba per mėnesį, arba per metus, tu irgi neturi spoksojimas kodas, bando prisiminti, tai, kas buvo man bando daryti su šiuo kodu? 

Jūs pasakė sau. Jūs apibūdino jį sau, arba kai kolega arba TP arba TF. Ir taip tai dabar būtų teisinga ir geras dizainas, ir galiausiai geras stilius, taip pat. Taigi, tai keep that in mind. 

Taigi vienas kitą dalykas, aš ruošiuosi padaryti čia kad dabar gali atskleisti, ką tai vyksta po gaubtu. Taigi ten ši funkcija C, ir kitomis kalbomis, vadinamas Typecasting kad arba netiesiogiai arba aiškiai leidžia jums konvertuoti iš vienos duomenų tipą į kitą. Mes užsiimame taip kiek šiandien stygos. 

Ir stygos simbolių. Bet prisimenu nuo savaitės 0, kas yra simbolių? Veikėjai yra tik abstrakcija ant numbers-- dešimtųjų, ir tūkstantųjų numeriai yra tikrai tik abstrakcija ant dvejetainius skaičius, kaip mes apibrėžti ją. 

Taigi simboliai yra skaičiai. Ir skaičiai yra simbolių, tik priklausomai nuo konteksto. Ir paaiškėja, kad viduje kompiuterinės programos, galite nurodyti, kaip norite atrodyti ne viduje tos programos bitai? 

Prisiminkite iš 0 savaitę, kad mes turėjome ASCII, kuri yra tik šis kodas kartografavimo raides į skaičius. Ir mes pasakėme, kapitalo A yra 65. Kapitalo B yra 66, ir kt. 

Ir pranešimas, mes iš esmės turime simbolius nuo viršutinėje eilutėje čia, kaip C, jiems skambinti, simbolių, tada ints antroje eilėje. Ir paaiškėja, galite konvertuoti sklandžiai tarp dviejų, dažniausiai. Ir jei mes norime padaryti tai sąmoningai, mes norėti spręsti kažkas panašaus į tai. 

Mes galbūt norėsite konvertuoti didžiosios sumažinti atveju, ar mažosios raidės viršutinę atveju. Ir it turns out Yra iš tikrųjų modelis čia galime priimti vos akimirką. Bet pažiūrėkime pirmą esant pavyzdys tai daryti aiškiai. 

Aš ruošiuosi grįžti į CS50 IDE. Aš ruošiuosi kurti byla vadinama ASCII 0.c. Ir aš ruošiuosi eiti į priekį ir pridėti mano standartinis io.h viršuje, int main negalioja tuo savo funkcija viršuje. Ir tada aš tik ketina padaryti following-- for ciklas iš I lygi, tarkim, 65. 

Ir tada aš bus mažiau nei 65, plius 26 raides abėcėlės. Taigi aš tegul kompiuterį matematikos už mane ten. Ir tada viduje šio ciklo, ką aš ketinu spausdinti? 

% C yra% i backslash N. Ir dabar noriu prijungti dviejų verčių. Aš laikinai įdėti klausimą žymi ten pakviesti į klausimą. 

Noriu pakartoti nuo 65 Pirmyn 26 abėcėlės raidėmis, spausdinti ant kiekvieno pakartojimo, kad personažo neatsiejama ekvivalentas. Kitaip tariant, noriu pakartoti nei 26 numeriai spauda kas ASCII simbolių yra raidė, ir koks atitinkamas skaičius is-- tikrai tik atkurti diagrama nuo tos skaidrės. Taigi, ką reikėtų šie klaustukai būti? 

Na, it turns out, kad antrasis vienas turėtų būti tiesiog kintamasis aš. Noriu pamatyti, kad kaip skaičius. Ir Artimuosiuose argumentas čia galiu pasakyti kompiuterį gydyti, kad sveikasis skaičius i kaip požymis, kad ją pakeisti čia C procentų 

Kitaip tariant, jei Aš, žmogaus programuotojas, žinau tai tik skaičiai Dienos pabaigoje. Ir aš žinau, kad 65 turėtų map tam tikru charakterio. Su šiuo aiškaus dauguma, su skliaustuose, iš duomenų tipą, kurį norite vardas konvertuoti į ir uždara skliausteliuose, galite papasakoti kompiuteris, ei, kompiuteris, konvertuoti šį sveikasis skaičius į char. 

Taigi, kai aš paleisti tai Programa po kompiliavimo, pažiūrėkime, ką aš get-- padaryti ASCII 0. Darn tai, ką aš padariau negerai čia? Naudokite nedeklaruojamo identifikatorių, viskas gerai, o ne tyčinis, bet pažiūrėkime, jei mes negalime Priežastis per tai. 

Taigi linija five-- todėl aš negavau labai toli iki varžtais. Tai gerai. Taigi 5 eilutė I lygus 65-- matau. Taigi nepamirškite, kad C, skirtingai nuo kai kurių kalbos, jei turi išankstinį programavimą patirtis, turite pasakyti kompiuterį skirtingai nuo nulio, kas tipo kintamasis yra. 

Ir aš pamiršau svarbiausią frazę čia. Pagal penkių, aš pradėjau naudoti i. Bet aš nepasakiau C kas duomenų tipas yra. Taigi, aš ruošiuosi eiti į čia ir pasakyti, ah, kad jis sveikas. 

Dabar aš ruošiuosi eiti į priekį ir perkompiliuoti. Tai fiksuotas tai. ./ascii0 Įveskite, tai tipo kietas. Ne tik tai super greitai paprašyti kompiuterį į šį klausimą, Užuot ieškojus jį ant skaidrės, tai išspausdinti po vieną eilutėje, A 65, B yra 66, visą kelią down-- nuo I tai padarė 26 times-- į raidžių z, kuris yra 90. Ir, iš tikrųjų, šiek tiek daugiau pažangių būtų buvo man ne pasikliauti kompiuteryje pridėti 26. Galėjau tik daroma 90, taip pat, taip ilgai kaip aš ne padaryti tą pačią klaidą du kartus. Noriu eiti per Z, o ne tik aukštyn per y. 

Taigi, kad aiškiai ketaus. Pasirodo, kad tai nėra net būtina. Leiskite man eiti į priekį ir iš naujo paleisti šią sudarytojas ir pakartotinis ASCII 0. Pasirodo, kad C yra gana protingas. 

Ir printf, ypač, yra gana protingas. Jei tiesiog praeiti i du kartus tiek vietos rezervavimo ženklų, printf suprasite, oi, gerai aš tave žinau davė man integer-- šiek tiek skaičių, kaip 65, ar 90, ar dar kas. Bet matau, kad norite mane formatuoti šį numerį panašaus pobūdžio. Ir taip printf gali netiesiogiai atiduoti INT į Jums char taip pat. Taigi, kad ne problema ne visiems. 

Bet pranešimas, dėl šios lygiavertiškumo mes iš tikrųjų gali tai padaryti taip pat. Leiskite man eiti į priekį ir padaryti vieną kita versija this-- ASCII 1.c. Ir vietoj Iteracja per sveikieji skaičiai, tikrai gali smūgis jūsų protas iteravimu per simbolius. Jei char c gauna kapitalo A, aš noriu eiti į priekį ir tai padaryti, tol, kol C yra mažesnė arba lygi kapitalo Z. Ir ant kiekvieno pakartojimo Noriu prieaugio C, galiu dabar mano printf linija čia tarkim, proc C procentų aš vėl kablelis C. 

Ir dabar, aš galiu eiti kita kryptimi, liejimo charakterį aiškiai iki sveikojo skaičiaus. Taigi, vėlgi, kodėl gi jūs tai padaryti? Tai šiek tiek keista rūšiuoti tikėtis, kalbant apie simbolių. 

Bet jei jūs suprantate, ką tai vyksta po gaubtu, ten tikrai ne stebuklinga. Jūs tiesiog pasakyti, ei, kompiuteris suteikia man kintamasis vadinamas C tipo char. Inicijuoti, kad kapitalo A. ir pastebėti Viengubomis kabutėmis klausimą. 

Simbolių C, prisiminti nuo Praėjusią savaitę, jūs naudojate Viengubomis kabutėmis. Styginiams, žodžių, frazės, naudokite kabutes. Gerai, kompiuteris, nuolat tai daryti, todėl tol, kol pobūdžio yra mažiau nei arba lygus z. Ir aš žinau, iš mano ASCII lentelę, kad visi Šių ASCII kodų ribojasi. 

Yra be tarpų. Taigi, tai tik nuo a iki z, atskirti kiekvienos vienu skaičiumi. Ir tada aš galiu prieaugio char, jei aš tikrai noriu. Dienos pabaigoje, tai tik skaičius. Aš žinau tai. Taigi galiu tik daryti prielaidą, kad pridėti 1 prie jo. 

Ir tada šį kartą, aš spausdinti C, ir tada sudėtinė ekvivalentas. Ir aš net nereikia aiškaus dauguma. Galiu leisti printf, o kompiuteris išsiaiškinti dalykus, taip, kad dabar, jei aš paleisti padaryti Ascii1./ascii1, Gaunu tą patį dalyką, taip pat. 

Nenaudingas programa, though-- niekas vyksta iš tikrųjų rašyti programinę įrangą tam, kad išsiaiškinti, kas buvo skaičius, žemėlapiai į A, arba B, arba Z? Jūs esate tik ketina jį "Google", arba ieškoti jį internete, arba ieškoti jį ant šliaužiklio, ar pan. Taigi, kur ar tai iš tikrųjų gauti naudinga? 

Na, kalbant apie tai Pristatymas, pastebėsite, ten tikrasis modelis čia didžiąsias ir mažosiomis raidėmis, kad nebuvo atsitiktinis. Atkreipkite dėmesį, kad kapitalas A yra 65. Mažosiomis raidėmis a yra 97. Ir kaip toli yra mažosios raidės ženklas? 

Taigi 65 yra kiek žingsnių nuo 97? Taigi 97 minus 65 yra 32. Taigi kapitalo a yra 65. Jei pridėsite nuo 32 iki, kad jums mažosiomis a. Ir analogiškai, jei atimti 32, Jums grįžti į kapitalo A-- pats su B į mažai B, didelis C mažai c. 

Visi šios dalies trūkumas yra 32 vienas nuo kito. Dabar, tai atrodo, kad galėtume kažką daryti, pavyzdžiui, Microsoft Word, arba Google Docs "funkcija, kur jums galite pasirinkti viską ir tada pasakyti, pakeisti visi mažąsias arba pakeisti visi didžiosiomis raidėmis, arba pakeisti tik pirmąjį žodį sakinio į didžiąsias raides. Mes iš tikrųjų galime padaryti kažką kaip kad save. 

Leiskite man eiti į priekį ir išsaugoti failą čia vadinamas pasinaudoti 0.c. Ir eikime į priekį ir pakelti programą kad tai tiksliai, kad taip. Taigi apima CS50 biblioteką. Ir apima standartinį I / O. 

Ir aš žinau, tai yra netrukus. Taigi, aš ruošiuosi įdėti ją į ten jau string.h, todėl aš turiu prieigą prie dalykų, pavyzdžiui, Stirling, ir tada int main negaliojančiu, kaip įprasta. Ir tada aš ruošiuosi eiti į priekį ir padaryti eilutes gauna gauti eilutę, tik gauti eilutę iš vartotojo. Ir tada aš ruošiuosi daryti mano naudojama logiškai patikrinimą. Jei eilutė nėra lygi NULL, tada tai saugu tęsti. Ir ką aš noriu daryti? Aš ruošiuosi kartoti iš I lygi 0, ir n iki eilutės ilgis S. 

Ir aš ruošiuosi tai padaryti tol, kol i yra mažiau nei N, ir i plius plius. Iki šiol, aš tikrai tik skolinimosi idėjų iš anksčiau. Ir dabar aš ruošiuosi pristatyti filialą. 

Taigi manau atgal į nulio, kur mes turėjome tuos šakės kelyje, ir praėjusią savaitę C. Aš ruošiuosi tai sakau, jei i-asis veikėjas s yra didesnis nei arba lygus mažosiomis raidėmis a, and-- į nulio jums būtų tiesiog pasakyti ir, bet C sakote ampersendas, ampersand-- ir i-asis veikėjas s yra mažesnis arba lygus lower case z, darykime kažką įdomaus. Leiskite tikrųjų atsispausdinti simbolių be naujos eilutės kad yra į eilutę simbolis, i-asis veikėjas eilutę. 

Bet eikime į priekį ir atimti 32 iš jo. Else if in simbolis eilutė, mes ieškome yra ne tarp mažai A ir šiek tiek Z, eiti į priekį ir tiesiog atspausdinti jį nepakeistą. Taigi, mes įdiegėme tai klaustuku žymėjimas už mūsų Strings gauti ne i-asis veikėjas eilutę. 

Aš pridėjau šiek tiek sąlyginis logika, kaip ir Nulio praėjusios savaitės savaitę vieną, kur Aš tiesiog naudojant mano pagrindinis supratimas apie tai, kas vyksta po gaubtu. Ar i-asis pobūdis s didesnis nei arba lygus? Kaip, tai 97, ar 98, arba 99, ir taip toliau? 

Bet tai taip pat yra mažesnė arba lygi į mažąsias z verte? Ir jei taip, ką ši linija reiškia? 14, tai yra rūšiuoti iš gemalai šia idėja, kapitalizuoti laišku tiesiog atimant 32 iš jo, šiuo atveju, nes žinau,, už, kad diagramą, kaip mano numeriai yra atstovaujama. Taigi eikime į priekį ir paleisti tai, po kompiliavimo pasinaudoti 0.c, ir paleisti pasinaudoti 0. 

Leiskite įvesti kažką panašaus Zamyla visose mažosiomis raidėmis įrašykite. Ir dabar mes turime Zamyla visose didžiosiomis raidėmis. Leiskite įveskite Rob visose mažosiomis raidėmis. Pabandykime Jasoną visose mažosiomis raidėmis. Ir mes gaunu priversti kapitalizacija. Yra nepilnametis klaidą, kad aš rūšies nebuvo numatyti. Atkreipkite dėmesį, my new greitai baigiasi iki toje pačioje eilutėje kaip ir jų pavadinimai, kuris jaučiasi šiek tiek nepatogus. 

Taigi, aš ruošiuosi eiti čia, ir tikrai ne šios programos pabaigoje spausdinti naujos eilutės simbolį. Tai viskas. Su printf, jums nereikia perduoti kintamuosius ar formatuoti kodą. Jūs tiesiog galite tiesiog atsispausdinti kažkas panašaus į naujos eilutės. 

Taigi eikime į priekį ir padaryti kapitalizuoti 0 vėl pakartotas jį Zamyla. O dabar šiek tiek gražiau. Dabar, mano eilutę yra savo naują eilutę. Taigi, kad viskas gerai ir gerai. Štai geras pavyzdys. Bet aš net nebūtinai reikia sunkiai kodas 32. Zinai ka? Galėčiau say-- aš ne kada nors prisiminti, kas skirtumas yra. 

Bet aš žinau, kad jei aš turi mažąją raidę, Aš iš esmės nori atimti išjungtas nepriklausomai nuo atstumo, yra tarp mažai A ir didelis, nes jei aš manau, kad visų kitų raidėmis yra tokie patys, kad turėtų gauti darbą. Tačiau užuot tai padaryti, žinote, ką? Yra dar vienas būdas vis. 

Jei tai išnaudoti 1.c-- jei aš būčiau įdėti, kad į atskirą failą. Darom pasinaudoti 2.c taip. Aš ruošiuosi tikrai valyti tai čia. Ir vietoj to, kad net nežino arba negalvoja apie tuos žemo lygio įgyvendinimo detales, aš vietoj tik ketina spausdinti simbolį, citata citatos pabaiga, proc C ir tada skambinti kitą funkciją, kad egzistuoja, kad mano argumentas, kuris yra simbolis, kaip tai. 

Pasirodo, C, ten kita skambinimo funkcijos į viršutinį, kuris, kaip jos pavadinimas rodo mano charakterį ir daro jį į viršutiniame atveju lygiaverčiai, ir tada vėl ją kad printf galite prijungti jį ten. Ir taip tai padaryti, nors aš reikia įvesti vieną kitą failą. Pasirodo, yra ir kitas failas kad jums būtų žinoti tik iš klasės, arba vadovėlis, arba internete nuoroda, vadinamas C type.h. 

Taigi, jei aš pridurti, kad iki tarp antraštės mano failai, o dabar iš naujo kompiliuoti šią programą, capitalize2, ./capitalize2 Enter. Leiskite įveskite Zamyla visų mažosiomis raidėmis, vis dar veikia tas pats. Bet žinote ką? Pasirodo, kad į viršutinio turi kitas funkcijas. 

Ir leiskite man pristatyti tai komanda čia tarsi negrabiai pavadintas, bet žmogus vadove. Pasirodo, kad dauguma Linux kompiuterius, kaip mes naudojame here-- Linux operacinė system-- turėti komandą vadinamas vyras, kuris sako, ei, kompiuteris, duok man kompiuterio instrukcijos. ko nori ieškoti toje instrukcijoje? 

Noriu pažvelgti funkcija pašaukti viršutinė, Enter. Ir tai šiek tiek paslaptingas skaityti kartais. Bet pastebėsite mes į Linux programuotojas instrukcijos. Ir visa tai tekstas. Ir pastebėsite, kad "The Pavadinimas funkcija čia. Pasirodo, ji turi pusbrolį, vadinamą sumažinti, kuris daro priešingai. Ir pranešimas pagal santrauką, naudoti šią Funkcija vyro puslapį, taip sakant, sako man, kad aš reikia įtraukti c type.h. Ir aš žinojau, kad iš praktikos. 

Čia, tai rodo man du prototipų funkciją, taip, kad jei aš kada nors norite naudoti šį Aš žinau, ką jie imasi, kaip įvestį, ir ką jie grįžta kaip produkcija. Ir tada, jei skaitau aprašymas, matau išsamiau, ką funkcija veikia. Bet dar svarbiau, jei Žiūriu pagal grįžimo vertės, ji sako, grąžinta reikšmė yra kad konvertuotų laiško, arba C, originalus įėjimas, jei toks pakeitimas buvo neįmanoma. 

Kitaip tariant, į viršutinę bandys konvertuoti laišką didžiosiomis raidėmis. Ir jei taip, tai kas vyksta jį grįžti. Bet jei jis negali kai reason-- gal tai jau didžiosios, gal tai yra šauktukas ar kokios nors kitos punctuation-- tai tik ketina grįžti į pradinę C, o tai reiškia, aš galiu padaryti, kad mano kodą geriau suprojektuoti taip. 

Aš nereikia visi Šie darn eilučių kodo. Visi linijų Aš tik pabrėžė gali būti perkeliamas į tik vieną paprastą linija, kuri yra this-- printf proc C viršutinėje S laikiklio i. Ir tai būtų pavyzdys geresnį projektavimą. 

Kodėl įgyvendinti 7 ar 8 linijos kodo, kokia ji man buvo tiesiog ištrinti, kai vietoj jų galima sutraukti visi, kad logika ir sprendimų priėmimo į vieną linija, 13 dabar, kad remiasi bibliotekoje function-- funkcija, kuri ateina su C, bet daro būtent tai, ką norite daryti. Ir, tiesą sakant, net jei jis neatėjo su C, galite ją įgyvendinti patys, kaip mes matėme, su gauti neigiamą int ir gauti teigiami INT praėjusią savaitę taip pat. 

Šis kodas dabar yra daug daugiau skaityti. Ir, iš tiesų, jei mes slinkti aukštyn, atrodo kiek kompaktiškesnis tai mano programos versija yra. Tai šiek tiek sunkesnė dabar su visa tai įeina. Bet tai gerai, nes dabar aš stoviu apie programuotojus pečių prieš mane. Ir kas tai buvo, kuris įgyvendintos viršutinė tikrai man padarė paslaugą, panašiai kaip kas įgyvendinti Stirlingo tikrai man padarė paslaugą prieš kurį laiką. Ir todėl dabar turime geriau dizainas programa kuri įgyvendina tą patį logiką. 

Kalbėdamas apie Stirling, tegul man eiti į priekį ir tai padaryti. Leiskite man eiti į priekį ir sutaupyti šiam failui kaip stirling.c. Ir it turns out, mes galime žievelės atgal vienas sluoksnis gana tiesiog dabar. Aš ruošiuosi eiti į priekį ir plakti iki kito pagrindinis programos kad čia tiesiog vėl padargus eilutės ilgis taip. Taigi čia kodo eilutė, kad gauna man eilutę iš vartotojo. Mes nuolat naudojant šį vėl ir vėl. Leiskite man duoti sau kintamąjį vadinamą n tipo int, kad išsaugo numerį. 

Ir leiskite man eiti į priekį ir daryti tokią logiką. Nors n-tojo personažas s daro nėra lygūs Backslash 0, eiti į priekį ir prieaugio N. Ir tada atsispausdinti printf proc I n. Aš teigia, kad ši programa čia nekeliant string ilgis, skaičiai dėmesį į eilutę ilgį. 

Ir magija yra visiškai aplieti 8 linija čia su tuo, kas atrodo kaip naujos sintaksės, tai Backslash 0 vienviečiai kabučių. Bet kodėl taip yra? Na, mano kas buvo vyksta visą šį laiką. 

Ir kaip žemę, kol aš pamiršti, suvokti taip pat, kad papildomai prie žmogaus puslapiuose kad ateis su tipiškas Linux sistemos kaip CS50 IDE, suprasti, kad mes, Kursas darbuotojai, taip pat padarė tinklalapio versija Šio pačią idėją, vadinamą reference.cs50.net, kuri turi visi tų pačių žmogaus puslapius, visi ta pati dokumentus, taip pat šiek tiek dėžutė viršuje, kuri leidžia jums konvertuoti visas gana Arcane kalba, į nekomfortiška režimas, kur mes, dėstytojai, išgyveno ir bandė supaprastinti kai kalba, kad viskas orientuota į idėjų, o ne kai techninių detalių. Taigi reikia nepamiršti, reference.cs50.net kaip kito ištekliaus, taip pat. 

Bet kodėl styginių ilgis darbą kaip man pasiūlė akimirką prieš? Štai Zamyla vardas dar kartą. Ir štai Zamyla vardas supakuoti į, kaip aš nuolat daro, tapyti paveikslėlį IT būtis, tikrai, tik simbolių seka. Bet Zamyla neegzistuoja atskirai į programą. 

Rašydami ir paleisti programą, jūs naudojate savo "Mac" arba kompiuterį , atminties, ar RAM taip sakant. Ir jūs galite galvoti apie kompiuteris kaip turintys daug gigabaitų atminties šių dienų. Ir koncertą reiškia milijardus, todėl milijardai baitai. 

Bet tegul atgal laiku. Ir manau, kad mes naudojame tikrai senas kompiuteris, turi tik 32 baitų atminties. Galėčiau, mano kompiuterio ekrane, tiesiog atkreipia į tai dėmesį taip. 

Galėčiau tiesiog pasakyti, kad mano kompiuteris turi visą šį atmintyje. Ir tai yra tarsi Memory Stick, jei jūs prisimenate mūsų nuotrauką iš paskutinio karto. Ir jei aš tiesiog padalinti tai pakankamai kartų, Galiu reikalauti, kad turiu 32 baitų atminties ekrane. 

Dabar, iš tikrųjų, aš galiu tik atkreipti šiol šiame ekrane čia. Taigi, aš ruošiuosi eiti į priekį, ir tik pagal susitarimą, atkreipti mano kompiuterio atmintį, kaip Tinklelis, ne tik kaip viena tiesi linija. Tiksliau, aš teigti, kad dabar tai tinklelis, tai 8 iki 4 tinklelis, tik atstovauja visus 32 baitų kiek laisvos atminties liko mano Mac, ar galima mano PC. Ir jie vyniojimo į dvi eilutes, tiesiog nes ji tinka daugiau ekrane. Bet tai yra pirmasis baitas. Tai yra antras baitas. Tai yra trečias baitas. 

Ir tai yra 32. baitų. Arba, jei mes manome, kaip kompiuteris mokslininkas, tai yra baitas 0, 1, 2, 3, 31. Taigi jūs turite 0 iki 31, jei Jums pradėti skaičiuoti 0. 

Taigi, jei mes naudojame programą kad skambučiai gauti eilutę, ir gauname eilutę iš žmogaus kaip aš vadinamas Zamyla, Ž-A-M-Y-L-A, Kaip pasaulyje veikia kompiuteris Sekite kurių baitas, kuri riekė atminties, priklauso, į kurią eilutę? Kitaip tariant, jei mes pereiti prie įrašykite kitą pavadinimą į kompiuterį, kaip šis Ieva, ragindamas gauti eilutė antrą kartą, A-N-D-I turi galų gale į kompiuterio atmintyje, taip pat. Bet kaip? 

Na, paaiškėja, kad po dangtis, ką, C ar laikant stygas kad žmogaus tipų, arba kad iš kitu šaltiniu, tai apibrėžia jų galą su specialus character-- Backslash 0, kuri yra tik ypatingu būdu sakydamas 80 bitai iš eilės. 

Taigi A-- tai yra numeris 97 atminties. Taigi kai kurie iš 8 bitų modelis atstovauja dešimtainį skaičių 97. Tai Backslash 0 yra tiesiog skaičius 0, dar žinoma kaip raj N-U L, skirtingai nuo anksčiau, N-U L-L, kurį mes kalbėjome apie tai. Bet dabar, tik žinau, kad tai Backslash 0 yra tik 80 bitai iš eilės. 

Ir tai tik tai linija smėlis, kuri sako ką nors į kairę priklauso viena eilutę, arba viena duomenų tipo. Ir nieko į dešinę priklauso kažkas. Ieva vardas, tuo tarpu, kurie tik vizualiai atsitinka, į kuriuos vyniojami ant į kitą linija, bet tai tik estetinis detalė, Panašiai yra nul nutrauktas. 

Ji yra A A-N-D-I simbolių eilutė, plius penktasis paslaptis charakteris, Visi 0 bitai, kad tik pažymėtų iš Andi vardo galas taip pat. Ir jei mes vadiname gauti string trečią kartą kompiuteryje gauti kaip eilutę Maria, M-A-R-I-A, panašiai yra maria s vardas raj nutraukta su backslash 0. 

Tai iš esmės skiriasi nuo to, kaip kompiuteris būtų paprastai saugoti sveikasis skaičius arba trintuve ar kitas duomenų tipai dar, nes žinote, sveikas skaičius yra paprastai 32 bitų, arba 4 baitų, o gal net 64 bitai, ar aštuonis baitai. Tačiau daugelis primityvai kompiuteryje į programavimo kalba turi fiksuotą skaičių baitų po hood-- gal 1, gal 2, gal 4, gal 8. 

Bet stygos, konstrukcijos, turėti dinamiškas simbolių skaičius. Jūs neturite žinoti iš anksto, kol žmogaus rūšys, Z-A-M-Y-L-A, arba M-A-R-I-A, arba A-N-D-I priedą. Jūs nežinote, kiek kartų vartotojas ketina hit klaviatūra. Todėl jums nereikia žinoti, kaip daug simbolių iš anksto jūs ketinate reikia. 

Ir taip, C tiesiog rūšies lapai tarsi Paslaptis tinklalapio po gaubtu tuo eilutės pabaigoje. Po to, kai saugojimo Ž-A-M-Y-L-A atmintyje, ji taip pat tik kelia ekvivalentą tam tikro laikotarpio. Pasibaigus sakinio pabaigoje tai kelia 80 bitai, kad prisiminti, kur Zamyla prasideda ir baigiasi. 

Taigi, kas yra ryšys, tada šią programą? Ši programa čia Stirlingas, yra tiesiog mechanizmas gauti eilutę nuo vartotojo, linija 6. 7 Line "aš pareiškiu, kintamąjį vadinamas n ir nustatyti, kad jis lygus 0. 

Ir tada 8 eilutėje, aš tiesiog paprašė klausimas, o n-oji simbolis daro nėra lygūs visi 0 bits-- kitaip tariant, ar ne lygus šis specialus charakteris, Backslash 0, o buvo tik, kad ypatingas raj character-- eiti į priekį ir tik prieaugio N. 

Ir nuolat tai daryti, ir išlaikyti daro, ir nuolat tai daryti. Ir todėl, nors ir Anksčiau mes jau naudojama i, tai puikiai baudą semantiškai naudoti n jei jūs tiesiog bando tikėtis šį kartą sąmoningai, ir tiesiog nori ją vadina n. Taigi tai tik išlaiko klausia klausimą, yra n-tojo pobūdis viskas 0s? Jei ne, pažiūrėkite į kitą išvaizdą, pažvelgti į kitą, pažvelgti į kitą, pažvelgti į kitą. 

Bet kaip tik matote kairinį brūkšnį, 0, tai loop-- linija 9 per 11-- sustoja. Jūs išeiti iš while cikle, paliekant viduje, kad kintamasis n bendras skaičius, susijusių su visomis simbolių eilutę matėte, taip spausdinant jį. Taigi pabandykime tai. 

Leiskite man eiti į priekį ir, be naudojant Stirling funkciją, bet tiesiog naudojant savo atpažinimo versiją čia vadinamas Stirling, leiskite man eiti į priekį ir paleisti Stirling, tipo kažką kaip Zamyla, kurį aš žinau, iš anksto yra šeši rašmenys. Leiskite pamatyti, jei ji veikia. Iš tiesų, tai šeši. Pabandykime su Rob, trys simboliai, trys simboliai, taip pat, ir kt. Taigi, kad viskas, kas vyksta apie po gaubtu. Ir pastebėti ryšius, tada, su pirmą savaitę klasės, kur mes kalbėjome apie kažkas panašaus imti, kuri yra tik tai idėjų sluoksniavimasis arba sudėtingumą, ant pagrindinių principų. Čia mes tarsi ieško po Stirling gaubtu, taip sakant, išsiaiškinti, kaip ji bus įgyvendinta? 

Ir mes galime iš naujo įgyvendinti jai save. Bet mes niekada vyksta iš naujo įdiegti Stirling. Mes tiesiog ketiname naudoti Stirling, kad kad iš tikrųjų kažkiek stygos ilgį. 

Bet ten ne magija po gaubtu. Jei žinote, kad po dangtis, styginių yra tik ženklų seka. Ir, kad ženklų seka visi gali būti skaitmeninio skirta su laikikliu 0, laikikliu 1, laikiklis 2, ir jūs žinome, kad ne iš eilutės pabaigos yra specialus simbolis, galite išsiaiškinti, Kaip padaryti dauguma nieko programa, nes visa tai suvesta yra skaitymo ir rašymo atmintį. Tai reiškia, kad keičiasi ir ieško ne atmintis, ar juda dalykų aplink atmintyje, spausdinimo dalykai ekrane, ir taip toliau. 

Tad dabar pats naudoju šį naujai atrastą supratimas, kas stygos iš tikrųjų yra po kapotu, ir žievelės atgal vieną kitą sluoksnį kad iki šiol mes buvo ignoruojant apskritai. Visų pirma, bet kuriuo metu mes įdiegėme programą, mes jau šią eilutę kodo viršuje deklaruojant pagrindinis. Ir mes nurodyta int main negaliojančiu. 

Ir tą tuštumą viduje skliausteliuose buvo sakydamas visą šį laiką, kad pagrindinis pati nesiima jokių argumentų. Bet kokius duomenis, kad pagrindinis yra ketina gauti iš vartotojo turi ateiti iš kai kurių kitų mechanizmas, kaip ir vakaronė INT, arba gauti plūdę, arba gauti eilutę, ar kokios nors kitos funkcijos. Tačiau paaiškėja, kad Rašydami programą, jūs iš tikrųjų galite nurodyti kad ši programa turi imtis įėjimai iš žmogaus ne pati komandų eilutę. 

Kitaip tariant, nors mes iki šiol jau veikia tik ./hello Sveiki ar panašios programos, visi Kitos programos, kad mes jau naudojate, kad mes patys nerašė, ėmėsi, atrodo, komandinės eilutės arguments-- tokie dalykai kaip padaryti. Jūs sakote kažką panašaus modelio, ir tada antras žodis. Arba žvangėjimas, jūs sakote žvangėjimas, ir tada antras žodis iš failo pavadinimą. 

Arba net RM ar KP, kaip jums gali mačiau ar jau naudojamas pašalinti arba kopijuoti failus. Visi tie imtis vadinamasis komandinės eilutės arguments-- papildomi žodžiai terminale eilutę. Tačiau iki šiol mes patys neturėjome Šis prabangus imtis įėjimas iš vartotojas, kai jis ar ji iš tikrųjų veikia pati programa komandų eilutę. 

Tačiau mes galime padaryti, kad iš naujo paskelbti Pagrindinis juda į priekį, o ne kaip turintys nebegalioti skliausteliuose, bet šie du argumentai instead-- pirmą sveikasis skaičius, ir antra, ką naujas, kažkas, kad mes ketiname skambinti masyvas, kažkas panašaus dvasia ką matėme nulio kaip sąrašą, bet eilučių masyvas, kaip mes greitai pamatyti. Bet pažiūrėkime, tai iki Pavyzdžiui, kol mes atskirti, ką tai reiškia. 

Taigi, jei aš einu į CS50 IDE čia aš nuėjo į priekį ir deklaruojama failo pavadinimu argv0.c šią šabloną. Ir pastebėsite vienintelis dalykas kad skiriasi tiek, kiek yra tai, kad aš pasikeitė negaliojančiu, int argc styginių argv atvirą laikiklį, netoli laikiklis. Ir pastebėti dabar, ten nieko viduje tų skliausteliuose. 

Nėra skaičius. Ir ten ne i arba N, arba bet kuri kita raidė. Aš tiesiog naudojant skliaustus dabar, dėl priežasčių, mes ateiti Atgal į vos akimirką. 

O dabar ką aš ruošiuosi daryti tai. Jei argc lygus lygus 2-- ir priminti, kad lygu lygu yra lygybė operatorius lyginant kairėje ir dešinėje lygybės. Tai ne perleidimas operatorius, kuris yra vienintelis lygybės ženklas, kuris reiškia kopiją iš dešinės į kairę tam tikrą vertę. 

Jei argc lygus lygus 2, noriu tarkim, printf, labas, procentai, nauja linija, ir tada prijunkite in-- ir čia nauja trick-- argv laikiklis 1 dėl priežasčių, kad mes grįžti į iškart. Else if argc nėra lygus 2, žinote, ką? Tegul tik eiti į priekį ir, kaip įprasta, spaudos iš hello world be keitimą. 

Taigi atrodytų, kad jei argc, kuris reiškia argumentų skaičius, lygus 2, Aš ruošiuosi atsispausdinti labas kažkas ar kita. Priešingu atveju, pagal nutylėjimą, aš ketinate spausdinti Sveiki pasaulį. Taigi, ką tai reiškia? 

Na, leiskite man eiti į priekį ir sutaupyti Šis failas, tada padarysiu argv0, ir tada ./argv0, Enter. Ir ji sako hello world. Dabar, kodėl taip yra? 

Na, it turns out bet kada paleisti programą komandų eilutėje, pildote, ką mes paprastai vadiname argumentas vektorių. Kitaip tariant, automatiškai aktyvuojami kompiuteris, operacinė sistema, ketina įteikti savo programą pati yra visi žodžiai sąrašas kad žmogaus įvedėte ne Paraginti tuo atveju, jei programuotojas nori daryti kažkas su šia informacija. Ir šiuo atveju, vienintelis žodis Aš įvedėte komandinėje eilutėje yra ./argv0. 

Ir taip keletą argumentų, kad yra patektų į mano programa yra tik vienas. Kitaip tariant, argumentas skaičiuoti, kitaip žinomas kaip argc čia kaip sveikasis skaičius, yra tik vienas. Vienas, žinoma, nėra lygi du. Ir todėl tai, ką spausdina, labas pasaulį. 

Bet leiskite man pasinaudoti šia kažkur. Leiskite man pasakyti, argv0. Ir tada, kaip apie Maria? Ir tada paspauskite Enter. 

Ir pastebėsite ką stebuklingai atsitinka čia. Dabar, užuot hello world, turiu pakeitė šią programą elgesį atsižvelgiant įvestį ne iš vakaronė eilutė arba kai kitas funkcijas, o iš, matyt, mano komanda pati, ką aš iš pradžių įvestas. Ir aš galiu žaisti šį žaidimą vėl jį pakeisti į STELIOS, pavyzdžiui. 

Ir dabar matau kitą vardą dar. Ir čia, sakyčiau Andi. Ir galiu pasakyti Zamyla. Ir mes galime žaisti šį žaidimą visą dieną, tiesiog įkišant į skirtingas vertybes, taip ilgai, kaip aš suteikti tiksliai du žodžiai komandinėje eilutėje, toks, kad argc, mano argumentas skaičiuoti, yra 2. 

Matau, kad vardas prijungtas prie printf, už šią sąlygą čia? Taigi, mes, atrodo, dabar ekspresyvi galimybė imtis įvestį iš kito mechanizmo, iš vadinamojo komandinėje eilutėje, o ne laukti tol, kol vartotojas paleidžia programą, ir tada paprašys jam ar jai naudojant kažką panašaus get eilutę. 

Taigi, kas tai yra? Argc, vėlgi, yra tik sveikasis skaičius, iš words-- arguments-- skaičius kad vartotojas, jeigu ne greitai, tuo terminalo langą, įskaitant programos pavadinimą. Taigi, mūsų ./argv0 yra, efektyviai, kad programos pavadinimas, arba kaip aš paleisti programą. 

Kad skaičiuoja kaip žodis. Taigi argc būtų 1 d. Bet kai aš rašau Stelios arba Ieva, ar Zamyla arba Marija, tai reiškia, kad šis argumentas skaičius yra du. Ir taip dabar ten du žodžiai praėjo per. 

Ir pranešimas, mes galime tęsti šią logiką. Jei aš iš tikrųjų pasakyti kažkas panašaus Zamyla Chan, pilnas vardas, tuo artimųjų trys argumentai iš viso dabar ji sako numatytasis vėl nes, žinoma, 3 nėra lygi 2. 

Ir taip tokiu būdu, aš turiu prieiga per argv tai naujas argumentas kad galėtume techniškai skambinti nieko mes norime. Tačiau pagal susitarimą, tai argv ir argc, atitinkamai. Argv, argumentas vektorius, yra natūra apie dėl programavimo sinonimas funkcija C vadinamas masyvą. 

Masyvas yra panašių verčių sąrašas atgal, atgal, atgal, į nugarą. Kitaip tariant, jei vienas yra čia į RAM, kitas iš jų yra šalia jo, ir šalia į jį. Jie ne visur. Ir tai pastarasis scenarijus, kur viskas yra visame atminties vietoje, iš tikrųjų gali būti galinga funkcija. Bet mes grįžti į tą, kai mes kalbėti apie mėgėjas duomenų struktūrų. Nes dabar, masyvas yra tik riekė gretimuose atminties, kai kiekvieno iš jų elementai yra atgal, atgal, atgal, atgal, ir paprastai to paties tipo. 

Taigi, jei jūs manote apie, nuo A prieš momentas, kas yra eilutė? Na, eilutė, kaip ir Zamyla, Ž-A-M-Y-L-A, yra, techniškai, tik masyvas. Tai simbolių masyvas. 

Ir todėl, jei mes tikrai atkreipia į tai, kaip aš darė anksčiau, kaip atminties riekė, ji Pasirodo, kad kiekvienas iš jų simbolių užima baitas. Ir tada ten, kad ypatingas Sentinel pobūdį, Backslash 0, ar visi aštuoni 0 bitai, kad pažymėtų tos eilutės pabaigą. Taigi seka, paaiškėja iš, cituoti citatos pabaiga eilutę, yra tik iš chara-- masyvo char yra faktinis duomenų tipas. 

Ir dabar argv, meanwhile-- grįžkime prie programos. Argv, nors matome žodį eilutė čia nėra pati eilutė. Argv, argumentas vektorius, yra eilučių masyvas. 

Taigi kaip jūs galite turėti iš masyvo simbolių, jūs galite turėti aukštesnio lygio, iš strings-- masyvo taip, pavyzdžiui, kai aš įvedėte akimirką prieš ./argv0 argv0, erdvė Ž-A-M-Y-L-A, aš teigiama, kad argv turėjo dvi eilutes į it-- ./argv0, ir Z-A-M-Y-L-A. į Kitaip tariant, argc buvo 2. Kodėl taip yra? 

Na, iš tikrųjų, kas vyksta dėl yra tai, kad kiekvienas iš šių stygos yra, žinoma, yra simbolių masyvo Kaip ir anksčiau, kiekvienas iš kurių simbolių užima vieną baitą. Ir nepainiokite faktinį 0 Į programos pavadinimo su 0, o tai reiškia, visus 80 bitai. Ir Zamyla, tuo tarpu, vis dar taip pat yra simbolių masyvas. 

Būdamas dienos pabaigoje, tai tikrai atrodo taip po gaubtu. Bet argv iš prigimties, kaip pagrindinis darbai, leidžia man, į kuriuos vyniojami visa tai aukštyn į, jei norite, kad padidintumėte masyvo , kad jei mes šiek tiek daugiau nei supaprastinti kas vaizdas išvaizda ir nėra gana piešti masto ten, šio masyvo yra tik 2 dydžio, pirmasis elementas, kuris yra eilutę, antrasis elementas kuriame yra eilutė. Ir, savo ruožtu, jei tau rūšies priartinti kiekvieną tų stygų, ką matyti po gaubtu yra tai, kad kiekvienas eilutė yra tik simbolių masyvas. 

Dabar, kaip ir su stygos, mes galėjome gauti prieigą prie i-tojo požymio eilutę naudojant tą kvadratinių laikiklis notacijos. Panašiai, su matricomis apskritai, mes galime naudoti kvadratinių laikiklis notacijos gauti bet kuriuo stygų skaičius masyve? Pavyzdžiui, leiskite man eiti į priekį ir tai padaryti. 

Leiskite man eiti į priekį ir kurti argv1.c, kuris yra šiek tiek kitoks šį kartą. Vietoj tikrinti argc2, Aš ruošiuosi vietoj tai padaryti. Dėl INT gaunu 0, I mažiau nei argc, aš plius plius, ir tada spausdinti viduje tai, proc S, nauja linija, ir tada argv laikiklis aš. 

Taigi, kitaip tariant, aš ne su atskirus simbolius šiuo metu. Argv, kaip teigiama šių tuščių aikštėje petnešos su vardo argv teise, reiškia argv yra eilučių masyvas. Ir argc yra tik int. 

čia tai linija, 6, yra sakydamas rinkinį i lygi 0. Count visą kelią iki, bet ne taip, argc. Ir tada ant kiekvienos iteracijos, spausdinti eilutę. Kas seka? 

I-oji eilutė į argv. Taigi o prieš buvau naudojant kvadratinę laikiklį notacija gauti ne i-tojo personažas eilutę, dabar Aš naudoju kvadratinių laikiklis notacijos gauti ne i-tojo eilutę masyvo. Taigi tai tipo vieno sluoksnio pirmiau, konceptualiai. 

Ir taip kas tvarkingas apie tai Programa dabar, jei aš parengia argv1, ir tada daryti ./argv1, tada įveskite kažką panašaus į foo bar Baz, kuri yra trys numatytieji žodžiai, kad kompiuterių mokslininkas pasiekia bet kuriuo metu jis ar ji turi keletą rezervuotųjų žodžius, ir paspauskite "Enter", kiekvienas iš šių žodžių, įskaitant programos pavadinimą, kuri yra argv tuo pirmosios buvimo, baigiasi spausdinamas vienu metu. Ir jei aš tai pakeisti, ir aš sakau, kažkas panašaus argv1 Zamyla Chan, mes visi tie trys žodžiai, kurie yra argv0, argv1, argv2, nes tai atveju argc, kad skaičius yra 3. 

Bet kas tvarkingas, jei jūs suprantate kad argv yra tik eilučių masyvas, ir jūs suprantate, kad seka yra simbolių masyvas, mes iš tikrųjų gali rūšies naudoti šį kvadratinių laikiklis notacijos kelis kartus pasirinkti eilutę, tada pasirinkite personažas per eilutę, nardymo giliau taip. Šiame pavyzdyje, leiskite man eiti į priekį ir tai vadina argv2.c. Ir šiame pavyzdyje, leiskite man eiti į priekį ir padaryti following-- už INT gaunu 0, i yra mažiau nei argc, i plius Be to, kaip ir anksčiau. Taigi kitose words-- o dabar tai gauna pakankamai sudėtinga. Tada aš ruošiuosi pasakyti pakartoti per styginiams argv, kaip komentaras save. Ir tada aš ruošiuosi turėti įdėtos for ciklas, kuris tikriausiai padariau, ar laikomas daro, kad nulio, kur Aš ruošiuosi pasakyti int-- aš nesiruošia aš naudoju vėl nes aš nenoriu šešėlis, arba rūšiuoti perrašyti esamą i. 

Aš ruošiuosi, o ne, tarkim, j, nes kad mano Eiti į kintamąjį po i, kai aš tiesiog bando skaičiuoti paprastus numerius. J gauna 0-- ir, N, ketina gauti laivagalio ilgis argv laikiklio i, tol, kol j yra mažiau nei m, j plius plius, atlikite šiuos veiksmus. Ir čia įdomiausia dalis. 

Atsispausdinti charakterį ir naują eilutę, prijungti argv laikiklio i kronšteino j. Gerai, todėl leiskite man pridėti keletą pastabų čia. Pakartoti per simbolius dabartinėje eilutę, Spausdinti j-osios personažas i-osios eilutės. Taigi dabar aptarkime Ką šie komentarai galvoje. 

Pakartoti per stygas į argv-- kiek Stygos yra argv, kuris yra masyvas? Argc daug, todėl aš Iteracja iš I lygus 0 iki argc. Tuo tarpu, kiek simbolių yra i-osios eilutės į argv? 

Na, jei norite gauti atsakymą Aš tiesiog paskambinkite string ilgis Dėl dabartinės styginių I priežiūra apie, kuris yra argv kronšteinas i. Ir aš ruošiuosi laikinai saugoti, kad vertė n, tik spartinimo tikslais, prisiminti jį efektyvumą. Ir tada aš ruošiuosi inicijuoti j 0, nuolat vyksta tol, kol j yra mažiau nei N, ir ant kiekvienos iteracijos prieaugio j. 

Ir tada čia, už mano komentaras on-line 12 spausdinti simbolį, po to naujai linijai, specialiai argv laikiklis Aš suteikia man I-oji eilutę į argv-- Taigi pirmas tariant, Antrasis žodis, trečias žodis, nesvarbu. Ir tada j neria į giliau, ir gauna man j-osios pobūdis šio žodžio. Ir taip, iš tikrųjų, jūs galite gydyti argv kaip įvairialypei, kaip dvimatis, masyvas, kuriuo kiekvienas žodis rūšies išvaizda kaip tai savo proto akis, ir kiekvienas personažas rūšies sudarytas stulpelis, jei tai padeda. 

Iš tikrųjų, kai mes erzinti tai be ateities savaites tai bus šiek tiek sudėtingesnės nei tai. Bet jūs tikrai gali galvoja, kad dabar, kaip tik tai dvimatis masyvas, kai vienas lygis jame yra visi stygos. Ir tada, jei jūs pasinerti giliau, jums gali gauti ne atskirų simbolių jame, naudojant šį formatą čia. 

Taigi, kas yra grynasis poveikis? Leiskite man eiti į priekį ir padaryti argv2-- darn ją. Aš padariau klaidą čia. Netiesiogiai paskelbiant bibliotekos funkcija Stirling. Taigi visą šį laiką, tai gal reikia kad mes tarsi apdailos tiksliai ten, kur pradėjome. 

Aš įsukus, netiesiogiai teigiama, bibliotekos funkcija Stirling. Gerai, palauk. Prisimenu, kad ypač nes tai čia. Man reikia įtraukti string.h į Ši programos versija. 

Leiskite man eiti į priekį ir taip pat string.h, išskyrus, kad eiti į priekį ir perkompiliuoti argv2. Ir dabar, čia mes einame, kad argv2, Enter. Ir nors tai šiek tiek paslaptingas iš pirmo žvilgsnio, pastebėti, kad, tiesą sakant, tai, ką spausdinamas yra taškas argv2. 

Bet jei aš tipo kai po žodžių greitai, kaip argv2 Zamyla Chan, Taip pat Įveskite, šiek tiek paslaptingas iš pirmo žvilgsnio. Bet jei mes slinkti atgal iki, ./argv2 Ž-A-M-Y-L-A, C-H-A-N. Taigi mes pakartota per kiekvieną žodį. Ir, savo ruožtu, mes pakartota per kiekvienas personažas per žodį. 

Dabar, po to, kai visa tai, suprasti, kad ten vienas kitas detalė mes jau natūra ignoruojant visą šį laiką. Mes tiesiog erzino, išskyrus tai, kas Pagrindinė anketa įėjimai gali būti? Ką apie pagrindinių produkcijos? 

Visi šiuo metu, mes buvome tiesiog kopijuodami žodis INT priešais pagrindinė, nors galite pamatyti internete, kartais neteisingai senesnių versijų C ir kompiliatoriai, kad jie sako, tuščia, arba visai nieko. Bet, tiesą sakant, nes versija C, kad mes naudojame, C 11, arba 2011, reikia suprasti, kad ji turėtų būti INT. Ir tai turėtų būti arba negaliojantis, arba argc ir argv čia. 

Bet kodėl int main? Ką ji iš tikrųjų grįžta? Gerai, tai Pasirodo, visą šį laiką, bet kada parašiau programa Pagrindinis visada grįžta kažkas. Bet tai buvo daroma taip slaptai. 

Kad kažkas yra INT, nes linijos 5 rodo. Bet kas int? Na, ten tai Konvencija programavimo, kuriuo, jei nieko negerai ir viskas yra gerai, programos ir funkcijos paprastai return-- šiek tiek counterintuitively-- 0. 0 paprastai reiškia viskas yra gerai. Taigi, nors jūs manote tai kaip klaidinga daugelyje kontekstų, ji iš tikrųjų paprastai reiškia geras dalykas 

Tuo tarpu, jei programa grąžina 1, arba neigiamas 1, arba 5, arba neigiamas 42, ar ne 0 vertė, kad paprastai reiškia kad kažkas negerai. Tiesą sakant, dėl savo Mac arba PC, galbūt iš tikrųjų matė klaidos pranešimas, pagal kurį jį sako kažką ar kita, klaidos kodas neigiamas 42 arba klaidos kodas 23, ar kažkas panašaus. Šis skaičius paprastai yra tik užuomina į programuotojas, ar bendrovė kad padarė programinę įrangą, kas nutiko ir kodėl, taip, kad jie gali pažvelgti pro jų dokumentai ar kodas, ir išsiaiškinti, kas klaida iš tikrųjų reiškia. Tai paprastai nėra naudinga mums galutiniams vartotojams. 

Bet kai pagrindiniai grįžta 0, viskas yra gerai. Ir jei nenurodysite Kokios pagrindinės turėtų grįžti, Jis tiesiog automatiškai grįžti 0 už jus. Bet grįžtant kažką dar yra iš tikrųjų naudinga. 

Baigiamajame programos, leiskite man eiti į priekį ir tai vadina exit.c, ir pristatyti paskutinis šiandien temos, žinomas kaip klaidos kodu. Leiskite man eiti į priekį ir taip pat mūsų pažįstami failus iki viršaus, tai int main. Ir šį kartą, darykime int argc, styginių argv ir su mano skliausteliuose tai nereiškia, kad jis yra masyve. Ir tada leiskite man tiesiog padaryti naudojama logiškai patikrinimą. Šį kartą, jei argc nėra lygus 2, tuomet jūs žinote, ką? Pamiršk tai. Aš einu pasakyti, kad, ei, vartotojas, Jums trūksta komandinės eilutės argumentus Backslash N. 

Ir tada viskas. Noriu, kad išeitumėte. Aš einu Preemptively, ir per anksti tikrai, grąžinimas nors kitu nei skaičiumi 1. Eiti į vertės pirmas klaida, kad gali atsitikti yra 1. Jei turite kai kurie kiti klaidingi situacija, kuri gali atsirasti, galima sakyti grąžą 2 arba grąžinti 3 arba gal net neigiamas 1 arba neigiamas 2. 

Tai yra tik išėjimo kodai kad yra, paprastai, naudinga tik programuotojas, arba įmonė, laivybos programinę įrangą. Bet faktas, kad tai ne 0 yra tai, kas svarbu. Taigi, jei šioje programoje, aš noriu užtikrinti, kad ši programa tik veikia, jei vartotojas suteikia man su argumentų skaičiaus dviejų, programos pavadinimas, ir kai kurių kitų žodis, galiu užtikrinti, kiek taip, klykauti vartotojas su printf žodžių trūksta komandinės eilutės argumentus, return 1. Tai tiesiog iš karto mesti programą. 

Tik jei argc lygus 2 mes kibti Čia, kuriame taškas aš ruošiuosi pasakyti, Sveiki proc s Backslash n argv1. Kitaip tariant, aš nesiruošia po argv 0, kuris yra tik programos pavadinimas. Noriu atsispausdinti Sveiki, kablelis, antras žodis, kad žmogaus įvedėte. Ir šiuo atveju dėl linija 13, viskas yra gerai. 

Žinau, kad argc yra 2 logiškai iš šios programos. Aš ruošiuosi eiti į priekį ir atgal 0. Kaip panaikinti, reikia nepamiršti, kad tai yra tiesa nulio, taip pat. 

Logiškai mąstant, galėčiau tai padaryti ir viską, šias eilutes kodo šioje kitam sąlygą čia. Bet tai tarsi be reikalo atitraukdami savo kodą. Ir aš noriu, kad super aišku, kad nesvarbu, ką, pagal nutylėjimą, labas kažkas bus gauti išspausdintas, taip ilgai, kol vartotojas bendradarbiauja. 

Taigi tai labai įprasta naudoti sąlyga, tik jei sugauti kai klaidinga situacija, ir tada išeiti. Ir tada, kol viskas yra Na, ne turėti kitas, bet tiesiog kodą ne, kad jei, nes tai ekvivalentas tai konkrečiu atveju, logiškai. Taigi, aš grįžta 0, tik aiškiai reikšti viskas yra gerai. 

Jei aš praleisti grįžimą 0, tai automatiškai prisiėmė už mane. Bet dabar, kad aš grįžimas vienas iš ne mažiau kaip šiuo atveju, Aš ruošiuosi, gera priemonė ir aiškumas, grįžti 0. Šiuo atveju. Taigi dabar leiskite man eiti į priekį ir padaryti išėjimą, kuris yra puikus Segue tiesiog palikti. 

Tačiau įsitikinkite, išvežimo, ir leiskite man eiti į priekį ir daryti ./exit, Enter. Ir programa rėkė ant manęs, trūksta komandinės eilutės argumentus. Gerai, leiskite man bendradarbiauti. 

Leiskite vietoj padaryti ./exit, Dovydas Enter. Ir dabar ji sako, labas Davidas. Ir tai būtų ne paprastai pamatyti tai. 

Tačiau paaiškėja, kad yra ypatingu būdu Linux realiai pamatyti su tuo, ką išeiti kodas programa išėjo. Kartais grafinę pasaulis kaip Mac OS arba Windows matysite tik šiuos numerius, kai klaidos pranešimas pasirodo ekrane ir programuotojas rodo, kad numeris. Bet jei mes norime pamatyti, ką klaidą pranešimas, mes galime tai padaryti here-- taip ./exit, Enter Spausdinti trūksta komandinės eilutės argumentus. 

Jei aš dabar daryti echo $ ?, kuris yra juokingai paslaptingas ieško. Bet $? yra magiškas užkalbėjimas kad sako, ei, kompiuteris, pasakykite man, ką ankstesnis Programos išeiti kodas buvo. Ir aš paspauskite Enter. Matau 1, nes tai, ką aš papasakojo mano pagrindinė funkcija grįžti. 

Tuo tarpu, jei aš ./exit Dovydą, ir paspauskite Enter, matau, hello Dovydą. Ir jeigu aš dabar daryti echo $ ?, matau labas 0. Ir todėl tai tikrai bus būti vertingos informacijos į derintuvės kontekste, ne taip daug, kad jūs, žmogaus, būtų nerūpi. Bet derintojas ir kita programos mes naudosime šį semestrą dažnai atrodo tuo numeriu, nors tai tarsi paslėptas nebent jums atrodo už jį, kad nustatyti, ar programa s, ar ne vykdymas buvo teisinga ar neteisinga. 

Ir taip, kad duoda mums tai, tuo dienos pabaigoje. Mes pradėjome šiandien, žiūrėdamas derinimo, ir savo ruožtu į kursą pati, ir tada daugiau Įdomu, techniškai po gaubtu ką stygos, kuris truks savaitę mes tiesiog paėmė už suteiktas, ir, žinoma, paėmė juos už suteiktas nulio. 

Tada pažvelgė, kaip mes galime prieiti prie individualūs simbolių eilutę, ir vėl paėmė aukštesnio lygio pažvelgti į dalykus, ieškome būdų, kaip well-- jei norime gauti ne atskirų elementai sąrašą panašią struktūrą, mes negalime padaryti, kad su keliais stygos? Ir mes galime su komandinės eilutės argumentus. Bet ši nuotrauka čia tik iš dėžių yra demonstratyvus šios bendros idėjos masyvo, arba sąrašą, arba vektorių. Ir priklausomai nuo konteksto, visi šie žodžiai reiškia šiek tiek skirtingus dalykus. Taigi C, mes tik ketina kalbėti apie masyvą. Ir masyvas yra riekė atminties, iš kurių kiekvienas yra elementai yra greta, nugaros, atgal, atgal, į nugarą. 

Ir tie elementai yra, paprastai, tos pačios duomenų tipą, charakteris, charakteris, charakteris, charakteris, arba eilutė, styginių, styginių, styginių, ar INT, INT, INT, kokia ji yra mes bandome parduotuvėje. Tačiau tuo dienos pabaigoje, tai yra kaip jis atrodo konceptualiai. Jūs vartojate savo kompiuterio atmintyje arba atminties. Ir jūs drožyba jį į identiškai dydžio dėžės, kurios visos atgal, atgal, į atgal, atgal, tokiu būdu. 

Ir kas malonu apie ši idėja, ir tai, kad galėtume išreikšti vertes, tokiu būdu su pirmuoju iš mūsų duomenų struktūrų klasėje, reiškia, mes galime pradėti spręsti problemas, su kodu kad atėjo tiek intuityviai per savaitę 0. Jūs priminti telefoną knyga pavyzdys, kur mes panaudojome skaldyk ir valdyk, arba dvejetainis paieškos algoritmas, atsijoti per visa krūva vardus ir numerius. Bet mes prielaida, prisiminti, kad telefonų knyga jau buvo rūšiuojamos, kad kažkas jau turėjo figured out-- suteikta pavardžių sąrašas ir numbers-- kaip juos abėcėlę. Ir dabar, kad C mes, taip pat turi galimybę nustatyti dalykus, o ne fiziškai telefono knygos bet praktiškai iš kompiuterio atmintis, galėsime kitą savaitę vėl pristatyti this-- pirmas mūsų duomenų struktūras į array-- bet dar svarbiau, tikrasis kompiuteris mokslo algoritmai įgyvendinami kodu, su kuria mes galime laikyti duomenų struktūrų, pavyzdžiui, tai, ir tada pradėti jį manipuliuoti, ir realiai spręsti problemas su juo, ir statyti ant to, galiausiai, programos C, Python, JavaScript, užklausų duomenų bazių SQL? 

Ir mes matome, kad visi jie įvairių idėjų blokavimo. Bet dabar, priminti, kad Domeno kad mes pristatėme šiandien buvo tai, ką čia ir iš kriptografija pasaulis. Ir tarp ateinančius problemų jūs patys bus išspręsti yra kriptografija menas, kodavimo ir de kodavimo informacija ir Łifravimas ir iššifravimą tekstą ir darant prielaidą, galiausiai kad dabar jūs žinote, ką yra po gaubtu taip, kad kai pamatysite arba gauti pranešimas patinka tai, ką Būk gali iššifruoti jį. Visa tai, ir daugiau kitą kartą. 

[Vaizdo įrašų atkuriamų] 

-Mover Tik atvyko. Aš ruošiuosi eiti aplankyti jo koledžo profesorius. Taip. Sveiki. Tai jums. Laukti! Davidas. Aš tiesiog bando išsiaiškinti , kas tau nutiko. Prašome, ką nors galėtų padėti. Jūs buvote jo aukštasis kambarioku, buvo ar ne? Jūs buvote ten su juo, kai baigė CS50 projektą? 

[GROJA MUZIKA] 

-Tai Buvo CS50. 

Aš myliu šią vietą. 

-Valgyti. Mes ketiname iš verslo. 

[PABAIGA PLAYBACK] 