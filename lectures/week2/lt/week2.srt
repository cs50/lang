1
00:00:00,000 --> 00:00:02,970
>> [GROJA MUZIKA]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> David J. Malan: Gerai.

4
00:00:15,700 --> 00:00:18,832
Tai yra CS50 ir tai
yra 2-ąją savaitę pradžia.

5
00:00:18,832 --> 00:00:21,040
Ir jūs priminti, kad per
pastaruosius porą savaičių,

6
00:00:21,040 --> 00:00:24,490
mes jau įdiegti kompiuteryje
mokslo ir, savo ruožtu, programavimas.

7
00:00:24,490 --> 00:00:27,640
>> Ir mes pradėjome pasakojimą būdu
Nulio, kad grafinė kalba

8
00:00:27,640 --> 00:00:28,990
iš MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
Ir tada visai neseniai,
Praėjusią savaitę, tai mes

10
00:00:30,780 --> 00:00:34,450
įvesti higher-- A
žemesnio lygio kalba žinomas

11
00:00:34,450 --> 00:00:36,770
kaip C, kažką, kad vien tekstinė.

12
00:00:36,770 --> 00:00:39,440
Ir, tiesą sakant, paskutinį kartą mes
ištirta per tą kontekste

13
00:00:39,440 --> 00:00:40,450
sąvokų skaičius.

14
00:00:40,450 --> 00:00:43,010
>> Tai, prisiminti, buvo labai
Pirmoji programa, mes pažvelgė.

15
00:00:43,010 --> 00:00:45,710
Ir ši programa, paprasčiausiai,
spausdina, "Hello, World".

16
00:00:45,710 --> 00:00:47,730
Bet ten tiek daug
tariamas magija vyksta.

17
00:00:47,730 --> 00:00:51,460
Yra tai #include
su šiomis laužtiniuose skliaustuose.

18
00:00:51,460 --> 00:00:52,170
Yra int.

19
00:00:52,170 --> 00:00:53,020
Yra (tuščia).

20
00:00:53,020 --> 00:00:56,330
Yra skliaustai, garbanotas petnešos,
kabliataškiai ir daug daugiau.

21
00:00:56,330 --> 00:00:58,480
>> Ir taip, priminti, kad
įdiegėme nulio

22
00:00:58,480 --> 00:01:02,110
kad galėtume, idealiu atveju, pamatyti praeities
kad sintaksė, stuff, kad tikrai ne

23
00:01:02,110 --> 00:01:04,590
visi, kad intelektualiai
įdomus, tačiau anksti

24
00:01:04,590 --> 00:01:07,700
yra absoliučiai šiek tiek sudėtinga
wrap savo mintis aplink.

25
00:01:07,700 --> 00:01:10,860
Ir, iš tikrųjų, vienas iš dažniausiai
viskas anksti programavimo klasės,

26
00:01:10,860 --> 00:01:13,443
ypač tiems, mažiau
patogus, yra gauti nusivylė

27
00:01:13,443 --> 00:01:17,460
ir paslydau iki tam tikros sintaktikai
klaidų, nekalbant loginių klaidų.

28
00:01:17,460 --> 00:01:19,800
Ir taip tarp mūsų tikslų
šiandien, iš tikrųjų, bus

29
00:01:19,800 --> 00:01:23,280
būti išmokyti jus su kai
Problemų sprendimo būdai, kaip

30
00:01:23,280 --> 00:01:26,705
geriau spręsti problemas patys
atsižvelgiant į derinimo forma.

31
00:01:26,705 --> 00:01:29,330
Ir jūs žinote, taip pat, kad
aplinka, mes pristatėme

32
00:01:29,330 --> 00:01:31,780
Paskutinį kartą buvo vadinamas CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Tai žiniatinklio programinės įrangos, kuri
Leidžia programuoti debesyje

34
00:01:34,850 --> 00:01:38,450
taip sakant, išlaikant visus savo
failus kartu, nes mes vėl šiandien.

35
00:01:38,450 --> 00:01:41,480
Ir prisiminti, kad mes
peržiūrėta šias temas čia

36
00:01:41,480 --> 00:01:44,480
tarp jų funkcijas ir kilpos, ir
kintamieji, ir Būlio išraiškos,

37
00:01:44,480 --> 00:01:45,110
ir sąlygomis.

38
00:01:45,110 --> 00:01:49,190
Ir iš tikrųjų keli, kad mes
išversti iš nulio pasaulyje

39
00:01:49,190 --> 00:01:50,800
į C. pasaulyje

40
00:01:50,800 --> 00:01:53,220
>> Bet pagrindinis pastatas
blokai, taip sakant,

41
00:01:53,220 --> 00:01:55,150
buvo tikrai vis dar tas pats praeitą savaitę.

42
00:01:55,150 --> 00:01:57,900
Iš tiesų, mes tikrai tik buvo
skiriasi įspūdį, jei bus.

43
00:01:57,900 --> 00:02:00,300
Vietoj to violetinė
išsaugoti bloką, mes vietoj

44
00:02:00,300 --> 00:02:02,940
buvo printf, kuris yra
Ši funkcija C, kad

45
00:02:02,940 --> 00:02:05,890
leidžia spausdinti kažką
ir suformatuoti jį ekrane.

46
00:02:05,890 --> 00:02:07,950
Mes pristatė CS50
Biblioteka, kurioje jus

47
00:02:07,950 --> 00:02:11,420
dabar turi savo žinioje get_char,
ir get_int ir get_string,

48
00:02:11,420 --> 00:02:14,610
ir keletas kitų veikia kaip
Na, per kurią jūs galite gauti indėlį

49
00:02:14,610 --> 00:02:16,260
iš vartotojo savą klaviatūrą.

50
00:02:16,260 --> 00:02:20,640
Ir mes taip pat paėmė į dalykus pažvelgti
kaip these- bool ir char,

51
00:02:20,640 --> 00:02:22,490
ir du kartus, plūdė,
INT, long_long eilutė.

52
00:02:22,490 --> 00:02:25,170
Ir ten net kitus duomenų tipus C

53
00:02:25,170 --> 00:02:28,560
>> Kitaip tariant, kai jūs deklaruoti
kintamasis saugoti tam tikrą vertę,

54
00:02:28,560 --> 00:02:32,600
arba kai jums įgyvendinti funkciją
kad grįžta tam tikrą vertę,

55
00:02:32,600 --> 00:02:35,290
galite nurodyti, ką
tipo vertę, kuri yra.

56
00:02:35,290 --> 00:02:37,310
Ar tai eilutė, tarsi
simbolių seka?

57
00:02:37,310 --> 00:02:39,490
Ar tai skaičius, kaip ir sveikasis skaičius?

58
00:02:39,490 --> 00:02:41,390
Ar tai slankaus kablelio
vertė, arba kaip?

59
00:02:41,390 --> 00:02:46,180
Taigi C, skirtingai nuo nulio, mes iš tikrųjų
pradėjo nurodykite, kokių rūšių duomenis

60
00:02:46,180 --> 00:02:48,330
mes buvome grįžta arba naudojant.

61
00:02:48,330 --> 00:02:51,910
>> Bet, žinoma, mes taip pat vyko į
keletas pagrindinių ribos skaičiavimas.

62
00:02:51,910 --> 00:02:54,100
Ir visų pirma,
Ši kalba, C, prisiminti

63
00:02:54,100 --> 00:02:57,070
kad mes priėmėme pažvelgti
sveikasis skaičius perpildymo, realybė

64
00:02:57,070 --> 00:03:00,460
kad jei turite tik
ribinis dydis atminties

65
00:03:00,460 --> 00:03:04,600
arba, konkrečiau, baigtinis skaičius
Bitų, galite tik tikėtis, kad didelis.

66
00:03:04,600 --> 00:03:08,460
Ir todėl mes pažvelgė Šiame pavyzdyje čia
kuriuo skaitliukas lėktuve,,

67
00:03:08,460 --> 00:03:13,510
Tiesą sakant, jei veikia pakankamai ilgai būtų
perkrautas ir sukelti programinės įrangos

68
00:03:13,510 --> 00:03:15,560
faktinis fizinis potencialas klaida.

69
00:03:15,560 --> 00:03:18,600
>> Mes taip pat pažvelgė į plaukiojantieji
taškas netikslumas, realybė

70
00:03:18,600 --> 00:03:22,280
kad tik su baigtinio skaičiaus
Bitų, ar tai 32 ar 64,

71
00:03:22,280 --> 00:03:27,330
galite nurodyti tik tiek daug numerių
po dešimtainio taško, po kurio jūs

72
00:03:27,330 --> 00:03:29,110
pradeda gauti netikslūs.

73
00:03:29,110 --> 00:03:32,360
Taigi, pavyzdžiui, vienas trečdalis į
Pasaulio čia, mūsų žmonių pasaulyje,

74
00:03:32,360 --> 00:03:35,360
mes žinome tik begalinis skaičius
apie 3s po kablelio.

75
00:03:35,360 --> 00:03:38,820
Bet kompiuteris gali nebūtinai
atstovauti begalinį skaičių numeriais

76
00:03:38,820 --> 00:03:42,590
jei tik leidžia tai kai
baigtinis informacijos kiekis.

77
00:03:42,590 --> 00:03:45,900
>> Taigi mes ne tik išmokyti jus
su aukštesnės galios požiūriu

78
00:03:45,900 --> 00:03:49,280
kaip jums gali išreikšti save
klaviatūra, kalbant apie programavimą,

79
00:03:49,280 --> 00:03:51,430
mes taip pat ribotas, ką
jūs iš tikrųjų galite padaryti.

80
00:03:51,430 --> 00:03:55,790
Ir iš tiesų, klaidas ir klaidos gali
kyla iš tų klausimų rūšių.

81
00:03:55,790 --> 00:03:59,900
Ir iš tiesų, tarp temų šiandien
ketinate būti temas kaip derinti

82
00:03:59,900 --> 00:04:03,699
ir iš tikrųjų ieško po gaubtu
tuo, kaip viskas buvo įvestas praėjusią savaitę

83
00:04:03,699 --> 00:04:05,490
yra realiai įgyvendinamas
taip, kad jums geriau

84
00:04:05,490 --> 00:04:10,530
suprasti tiek pajėgumų ir
panašaus C kalba apribojimai

85
00:04:10,530 --> 00:04:14,770
>> Ir iš tikrųjų, mes žievelės atgal sluoksnius
iš paprasčiausių duomenų struktūros,

86
00:04:14,770 --> 00:04:17,756
kažkas vadinamas masyvas, kuris
Įbrėžimams atsitinka skambinti "sąrašą".

87
00:04:17,756 --> 00:04:19,589
Tai šiek tiek
besiskiriantis tuo, kad kontekste.

88
00:04:19,589 --> 00:04:23,340
Ir tada mes taip pat pristatyti vieną iš
Pirmasis mūsų domenų konkrečių problemų

89
00:04:23,340 --> 00:04:26,790
į CS50, kad pasaulis
kriptografija, kad stengiamasi menas

90
00:04:26,790 --> 00:04:29,650
arba kodavimo informaciją,
kad jūs galite siųsti slaptus pranešimus

91
00:04:29,650 --> 00:04:34,520
ir iššifruoti slaptus pranešimus
tarp dviejų asmenų A ir B

92
00:04:34,520 --> 00:04:37,490
>> Taigi, kol mes perėjimo
tai naujo pasaulio,

93
00:04:37,490 --> 00:04:42,059
pabandykime išmokyti jus su kai
metodai, su kuria jūs galite pašalinti

94
00:04:42,059 --> 00:04:43,850
arba sumažinti bent kai kurie
iš nusivylimų

95
00:04:43,850 --> 00:04:46,630
kad jūs tikriausiai susidūrėte
per vien praeitą savaitę.

96
00:04:46,630 --> 00:04:50,830
Tiesą sakant, prieš jus yra such-- kai
Jūsų pirmieji problemos C. Ir šansai yra,

97
00:04:50,830 --> 00:04:54,010
jei jūs panašus į mane, pirmą kartą
bandote tipo iš programos,

98
00:04:54,010 --> 00:04:57,330
net jei manote, logiškai
Programa yra gana paprasta,

99
00:04:57,330 --> 00:05:01,200
jums gali labai gerai pataikyti sienos, ir
sudarytojas nesiruošia bendradarbiauti.

100
00:05:01,200 --> 00:05:03,940
Padaryti arba klingsėti nesiruošia
realiai padaryti savo siūlymų.

101
00:05:03,940 --> 00:05:05,450
>> Ir kodėl gali būti?

102
00:05:05,450 --> 00:05:07,950
Na, tegul pažvelgti,
galbūt, paprasta programa.

103
00:05:07,950 --> 00:05:11,190
Aš ruošiuosi eiti į priekį ir sutaupyti tai
byla sąmoningai vadinamas buggy0.c,

104
00:05:11,190 --> 00:05:13,590
nes žinau, ją
būti ydingas iš anksto.

105
00:05:13,590 --> 00:05:17,400
Bet aš gali ne suprantame, kad, jeigu šis
yra pirmoji arba antroji arba trečioji programa

106
00:05:17,400 --> 00:05:18,830
kad aš iš tikrųjų padaryti save.

107
00:05:18,830 --> 00:05:23,820
Taigi, aš ruošiuosi eiti į priekį ir
tipo iš, int main (void).

108
00:05:23,820 --> 00:05:28,130
Ir tada viduje mano garbanotas petnešos,
labai pažįstamas ( "Sveiki, world--

109
00:05:28,130 --> 00:05:30,980
Backslash, n ") - ir pusiau-gaubtinės žarnos.

110
00:05:30,980 --> 00:05:32,360
>> Aš išsaugoti failą.

111
00:05:32,360 --> 00:05:34,850
Dabar aš ruošiuosi eiti
mano terminalo lange

112
00:05:34,850 --> 00:05:40,340
ir tipo makiažo buggy0, nes, vėlgi,
failo šiandien vardas buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Taigi aš tipo padaryti buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Ir, o, dieve, prisiminti nuo paskutinio karto
kad be klaidų pranešimų yra geras dalykas.

115
00:05:48,200 --> 00:05:49,740
Taigi ne produkcija yra geras dalykas.

116
00:05:49,740 --> 00:05:52,920
Bet čia aš turiu aiškiai
kai klaidų skaičius.

117
00:05:52,920 --> 00:05:56,470
>> Taigi pirmoje eilutėje produkcijos
Įvedę padaryti buggy0, prisiminti,

118
00:05:56,470 --> 00:05:59,540
yra žvangėjimas gana daugiažodis produkcija.

119
00:05:59,540 --> 00:06:02,067
Po gaubtu,
CS50 IDE yra sukonfigūruota

120
00:06:02,067 --> 00:06:04,150
naudoti visa krūva
galimybės su šiuo sudarytojas

121
00:06:04,150 --> 00:06:05,941
taip, kad jūs neturite
galvoti apie juos.

122
00:06:05,941 --> 00:06:08,840
Ir tai viskas, pirmoji eilutė
reiškia, kad prasideda žvangėjimas.

123
00:06:08,840 --> 00:06:11,720
>> Bet po to, problemos
pradėti uždirbti savo išvaizdą.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c on-line 3, charakterio
5, ten yra didelis, raudonas klaida.

125
00:06:17,390 --> 00:06:18,380
Kas tai?

126
00:06:18,380 --> 00:06:23,562
Netiesiogiai teigiama bibliotekos funkcija
printf su tipo int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Aš turiu galvoje, kad tai yra labai greitai
tampa labai paslaptinga.

129
00:06:28,379 --> 00:06:30,170
Ir, žinoma, iš pradžių
žvilgsnis, nebūtume

130
00:06:30,170 --> 00:06:32,380
tikimės, kad jūs suprasti
visuma šio pranešimo.

131
00:06:32,380 --> 00:06:34,213
Ir taip viena iš pamokų
už šiandien vyksta

132
00:06:34,213 --> 00:06:36,919
būti išbandyti pastebėti
modeliai, ar panašių dalykų,

133
00:06:36,919 --> 00:06:38,960
klaidų gali tekti
susiduriama su anksčiau.

134
00:06:38,960 --> 00:06:41,335
Taigi leiskite erzinti išskyrus tik
šie žodžiai, kurie atrodo pažįstama.

135
00:06:41,335 --> 00:06:44,290
Didelis, raudonas klaida yra aiškiai
simbolinė kažkas yra negerai.

136
00:06:44,290 --> 00:06:47,940
>> netiesiogiai teigiama,
bibliotekos funkcija printf.

137
00:06:47,940 --> 00:06:51,680
Taigi, net jei aš ne visai suprantu, ką
netiesiogiai teigiama bibliotekos funkcija

138
00:06:51,680 --> 00:06:54,900
priemonės, problema tikrai
susijęs su printf kažkaip.

139
00:06:54,900 --> 00:06:59,130
Ir šiuo klausimu šaltinis
turi daryti su nedeklaravę.

140
00:06:59,130 --> 00:07:02,440
>> Skelbiantis funkcija
paminėti, kad pirmą kartą.

141
00:07:02,440 --> 00:07:06,210
Ir mes panaudojome terminologiją praėjusią savaitę
skelbiantis funkcijos prototipas,

142
00:07:06,210 --> 00:07:11,860
arba su vienos linijos lango viršuje savo
savo failą arba vadinamasis antraštės faile.

143
00:07:11,860 --> 00:07:15,300
Ir ką failo padariau sakome
praeitą savaitę, kad printf yra citata,

144
00:07:15,300 --> 00:07:17,080
citatos pabaiga, pareiškė?

145
00:07:17,080 --> 00:07:20,950
Kokiu failas yra jos prototipas?

146
00:07:20,950 --> 00:07:24,640
>> Taigi, jei jūs prisimenate, pats pirmasis dalykas, kurį aš
parašomas beveik kiekviena programa paskutinis LAIKĄ_

147
00:07:24,640 --> 00:07:30,790
ir netyčia akimirka prieš pradėjau
rašyti myself-- buvo tai vienas here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- už
įvesties / output-- taškas H ir iš tiesų,

149
00:07:38,630 --> 00:07:41,860
jei aš dabar išsaugoti šį failą, aš ruošiuosi
eiti į priekį ir išvalyti ekraną,

150
00:07:41,860 --> 00:07:44,740
kurį galite padaryti, įvesdami
Skaidrus, arba galite palaikykite valdymo L,

151
00:07:44,740 --> 00:07:47,680
tiesiog išvalyti terminalo langą
tik siekiant pašalinti tam tikrą netvarką.

152
00:07:47,680 --> 00:07:51,370
>> Aš ruošiuosi eiti į priekį ir
naujo tipo makiažo buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Ir voila, aš vis dar matau, kad
ilgai komandų iš žvangėjimas,

154
00:07:53,790 --> 00:07:55,470
bet ten ne klaidos pranešimas šįkart.

155
00:07:55,470 --> 00:07:58,800
Ir iš tiesų, jei aš ./buggy0,
kaip paskutinį kartą,

156
00:07:58,800 --> 00:08:01,860
kur taškas reiškia tai
katalogas, velniop tiesiog reiškia,

157
00:08:01,860 --> 00:08:05,040
čia ateina programos pavadinimas ir
kad programos pavadinimas yra buggy0,

158
00:08:05,040 --> 00:08:07,340
Įveskite "Hello, World".

159
00:08:07,340 --> 00:08:09,440
>> Dabar, kaip gali jums
gautą šį sprendimą

160
00:08:09,440 --> 00:08:12,017
nebūtinai
pripažįstant tiek daug žodžių,

161
00:08:12,017 --> 00:08:14,350
kaip aš, žinoma, turintys
tai padarė tiek daug metų?

162
00:08:14,350 --> 00:08:18,720
Na, suprasite už pirmąją problemą
rinkinys, mes pristatome jums komandą

163
00:08:18,720 --> 00:08:21,175
kad CS50 paties personalo
rašė vadinamas help50.

164
00:08:21,175 --> 00:08:24,300
Ir iš tiesų, C ar specifikacija
problema nustatyti, kaip tai panaudoti.

165
00:08:24,300 --> 00:08:27,210
>> Bet help50 yra iš esmės
programa, kuri CS50 darbuotojai

166
00:08:27,210 --> 00:08:30,850
rašė, kad leidžia jums paleisti
komandų ar paleisti programą,

167
00:08:30,850 --> 00:08:36,169
ir jei jūs nesuprantate jos
produkcija, perduoti savo produkciją į help50,

168
00:08:36,169 --> 00:08:38,890
kuriame taškas programinė įranga
kad kursas darbuotojai rašė

169
00:08:38,890 --> 00:08:42,429
atrodys jūsų programa produkcijos
eilutė po eilutės, charakteris pagal charakterį.

170
00:08:42,429 --> 00:08:46,000
Ir jei mes, darbuotojai, pripažinti
klaidos pranešimas, kad jūs susidūrėte,

171
00:08:46,000 --> 00:08:50,580
bandysime jus išprovokuoti kai kurie
retoriniai klausimai, su kai kuriais patarimais,

172
00:08:50,580 --> 00:08:54,890
panašiai kaip TF ar CA ar sau
būtų padaryti asmeniškai darbo valandomis.

173
00:08:54,890 --> 00:08:58,320
>> Taigi atrodo, kad help50 jei ne
nebūtinai pripažinti problemą.

174
00:08:58,320 --> 00:09:00,790
Tačiau nereikia remtis
per kiek ramentas.

175
00:09:00,790 --> 00:09:03,990
Žinoma pabandyti suprasti jo
produkcija ir tada iš jos pasimokyti

176
00:09:03,990 --> 00:09:07,571
taip, kad tik vieną ar du kartus padaryti jums
kada paleisti help50 konkrečiam klaidos

177
00:09:07,571 --> 00:09:08,070
pranešimas.

178
00:09:08,070 --> 00:09:10,660
Po to, jums turėtų būti suteikta
geriau pasirengę patys

179
00:09:10,660 --> 00:09:13,180
išsiaiškinti, kas jis iš tikrųjų yra.

180
00:09:13,180 --> 00:09:14,350
>> Darom vieną kitą čia.

181
00:09:14,350 --> 00:09:20,410
Leiskite man eiti į priekį, ir kita
failą, mes vadiname tai buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Ir šioje byloje aš
ketina deliberately--

183
00:09:23,110 --> 00:09:26,330
bet apsimesti, kad aš ne
suprasti, kas klaida Aš atlikau.

184
00:09:26,330 --> 00:09:31,420
>> Aš ruošiuosi eiti į priekį ir padaryti this--
#include, nes aš

185
00:09:31,420 --> 00:09:33,660
išmoko savo pamoką iš prieš momentas.

186
00:09:33,660 --> 00:09:36,220
Int main (tuščia), kaip ir anksčiau.

187
00:09:36,220 --> 00:09:40,880
Ir tada aš čia ruošiuosi
daryti styginių s - get_string.

188
00:09:40,880 --> 00:09:43,770
Ir prisiminti, nuo paskutinio karto, kad
Tai reiškia, ei, kompiuteris,

189
00:09:43,770 --> 00:09:48,280
man kintamąjį, vadina tai ai, ir
kad tos kintamojo styginių tipas

190
00:09:48,280 --> 00:09:50,150
todėl galiu laikyti vieną ar daugiau žodžių iš jo.

191
00:09:50,150 --> 00:09:52,191
>> Ir tada ant dešinėje
pusė lygybės ženklo

192
00:09:52,191 --> 00:09:54,980
yra get_string, kuris yra
funkcija CS50 bibliotekoje

193
00:09:54,980 --> 00:09:55,980
kad daro būtent tai.

194
00:09:55,980 --> 00:09:59,740
Ji gauna funkciją ir tada
rankos jį iš dešinės į kairę.

195
00:09:59,740 --> 00:10:02,670
Taigi, tai lygybės ženklas nereiškia,
"Lygus" kaip mes manote matematika.

196
00:10:02,670 --> 00:10:04,750
Tai reiškia, perkėlė iš dešinės į kairę.

197
00:10:04,750 --> 00:10:09,640
Taigi tai reiškia, imtis eilutę nuo
vartotojo ir laikyti jį viduje s.

198
00:10:09,640 --> 00:10:10,460
>> Dabar galime jį naudoti.

199
00:10:10,460 --> 00:10:13,820
Leiskite man eiti į priekį ir dabar kaip sekundę
linija, leiskite man eiti į priekį ir pasakyti "labas" -

200
00:10:13,820 --> 00:10:19,330
ne "pasaulio", bet "labas,% s--
kuri yra mūsų rezervavimo ženklas, kablelis s

201
00:10:19,330 --> 00:10:22,030
kuri yra mūsų kintamasis,
ir tada pusiau-gaubtinės žarnos.

202
00:10:22,030 --> 00:10:26,070
Taigi, jei aš ne susukti per daug
čia tai atrodo teisingą kodą.

203
00:10:26,070 --> 00:10:28,090
>> Ir mano instinktai dabar ją sudaryti.

204
00:10:28,090 --> 00:10:30,400
Šis failas yra vadinamas buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Taigi, aš ruošiuosi daryti, kad buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Ir darn-ji, jei nėra
net daugiau klaidų nei anksčiau.

207
00:10:36,377 --> 00:10:38,210
Aš turiu galvoje, tai dar
klaidų pranešimai būtų

208
00:10:38,210 --> 00:10:40,400
atrodo nei faktinių linijų šią programą.

209
00:10:40,400 --> 00:10:42,730
>> Bet Takeaway čia yra,
net jei esate priblokšti

210
00:10:42,730 --> 00:10:45,040
su dviejų ar trijų ar
keturi pranešimai apie klaidas,

211
00:10:45,040 --> 00:10:48,340
sutelkti visada labai
Pirmoji iš šių pranešimų.

212
00:10:48,340 --> 00:10:52,220
Pažvelgus į viršų, didžioji vieną,
przewijanie atgal kaip reikia.

213
00:10:52,220 --> 00:10:53,930
Taigi čia aš įvedėte makiažo buggy1.

214
00:10:53,930 --> 00:10:55,700
Štai kad klingsėti produkcijos, kaip tikėtasi.

215
00:10:55,700 --> 00:10:57,290
>> Ir štai pirmoji raudona klaida.

216
00:10:57,290 --> 00:11:02,370
Naudokite nedeklaruojamo identifikatorius
eilutė, aš tai standartas?

217
00:11:02,370 --> 00:11:04,260
Taigi standartas yra
tikrai kažkas.

218
00:11:04,260 --> 00:11:06,240
Ji remiasi vartotojo anketa
klaviatūra, iš esmės.

219
00:11:06,240 --> 00:11:08,080
>> Bet tai nėra tai, ką aš reiškė.

220
00:11:08,080 --> 00:11:11,770
Aš norėjau eilutę, ir aš reiškė get_string.

221
00:11:11,770 --> 00:11:16,200
Taigi, kas tai yra, kad aš
pamiršau padaryti šį kartą?

222
00:11:16,200 --> 00:11:20,230
Ko trūksta šį kartą?

223
00:11:20,230 --> 00:11:23,600
Turiu #include,
todėl aš turiu priėjimą prie printf.

224
00:11:23,600 --> 00:11:26,090
>> Bet ką aš neturi
Prieiga prie dar tik?

225
00:11:26,090 --> 00:11:29,420
Na, kaip ir paskutinį kartą,
Man reikia pasakyti kompiliatorių

226
00:11:29,420 --> 00:11:31,691
Žvangėjimas, ką šios funkcijos yra.

227
00:11:31,691 --> 00:11:33,940
Get_string neateina
su C ir ypač, kad

228
00:11:33,940 --> 00:11:38,160
neateina į
header failą,.

229
00:11:38,160 --> 00:11:40,770
Tai vietoj ateina
kažkas darbuotojai rašė:

230
00:11:40,770 --> 00:11:44,176
kuris yra kitoje failas
vardu, bet taikliai pavadinta.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Taigi tiesiog pridedant, kad vienos linijos
iš code-- pašalinimo iš paskutinį kartą

233
00:11:50,861 --> 00:11:53,610
kad kai klingsėti veikia, ji vyksta
pažvelgti į mano kodas viršaus į apačią,

234
00:11:53,610 --> 00:11:54,193
kairės į dešinę.

235
00:11:54,193 --> 00:11:57,200
Jis ketina pranešimas,
oi, ko norite.

236
00:11:57,200 --> 00:11:59,900
Leiskite man eiti ir rasti, kad,
ten, kur jis yra serveryje,

237
00:11:59,900 --> 00:12:03,090
nukopijuokite ir įklijuokite jį iš esmės,
į savo failo viršuje

238
00:12:03,090 --> 00:12:06,820
taip, kad šiuo metu į istoriją,
linija 1, programos poilsio

239
00:12:06,820 --> 00:12:11,651
iš tikrųjų gali naudoti bet kurią iš funkcijų
jame, tarp jų ir get_string.

240
00:12:11,651 --> 00:12:13,650
Taigi, aš ruošiuosi ignoruoti
šių klaidų poilsio,

241
00:12:13,650 --> 00:12:17,190
Nes aš, tiesą sakant, įtariu, kad tik
pirmasis tikrai nerūpėjo.

242
00:12:17,190 --> 00:12:20,780
Ir aš ruošiuosi eiti į priekį ir pakartotinis,
po išgelbėdamas mano failą padaryti buggy1.

243
00:12:20,780 --> 00:12:22,580
Ir voila, ji darbą.

244
00:12:22,580 --> 00:12:29,200
Ir jei aš ./buggy1 ir tipo, už
pavyzdžiui, Zamyla, aš dabar gaus Sveiki,

245
00:12:29,200 --> 00:12:32,000
Zamyla, vietoj labas, pasauli.

246
00:12:32,000 --> 00:12:32,550
>> Gerai.

247
00:12:32,550 --> 00:12:35,890
Todėl čia takeaways tada yra,
vienas, pabandykite rankioti kiek, kaip jūs galite

248
00:12:35,890 --> 00:12:39,140
vien iš klaidų pranešimų, ieško
į kai kuriuos iš atpažįstamų žodžių.

249
00:12:39,140 --> 00:12:43,070
Draudimo, kad naudoti help50 už
problema nustatyti specifikaciją.

250
00:12:43,070 --> 00:12:46,500
Bet draudimas, kad per daug, visada atrodo
viršuje klaidos tik, ne mažiau kaip

251
00:12:46,500 --> 00:12:50,051
Iš pradžių, norėdami pamatyti, kokia informacija
ji iš tikrųjų gali duoti.

252
00:12:50,051 --> 00:12:52,300
Tačiau paaiškėja, ten
dar funkcionalumas pastatytas

253
00:12:52,300 --> 00:12:55,030
į CS50 bibliotekoje, kad padėtų
Jums anksti semestro

254
00:12:55,030 --> 00:12:57,580
ir anksti programavimo
išsiaiškinti, kas vyksta neteisingai.

255
00:12:57,580 --> 00:12:59,840
Taigi padarykime dar vieną pavyzdį čia.

256
00:12:59,840 --> 00:13:04,350
Aš ruošiuosi skambinti šiuo buggy2, kuris,
vėl ketina būti ydingas iš

257
00:13:04,350 --> 00:13:05,650
Vartų, dizainas.

258
00:13:05,650 --> 00:13:09,980
>> Ir aš ruošiuosi eiti į priekį
ir daryti #include.

259
00:13:09,980 --> 00:13:12,580
Ir tada aš ruošiuosi daryti int main (void).

260
00:13:12,580 --> 00:13:14,840
Ir tada aš ruošiuosi padaryti už kilpa.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i yra mažiau negu arba lygi 10.

263
00:13:18,750 --> 00:13:24,260
i ++, tada garbanotas petnešos, aš ruošiuosi
spausdinti tik grotelėmis simbolis čia

264
00:13:24,260 --> 00:13:25,920
o nauja linija charakteris.

265
00:13:25,920 --> 00:13:29,220
>> Taigi, mano siekis šiame
Programa yra paprasčiausiai

266
00:13:29,220 --> 00:13:33,150
į pakartoti 10 kartų
ir ant kiekvienos iteracijos

267
00:13:33,150 --> 00:13:35,260
tos linijos kiekvieną kartą
per ciklą,

268
00:13:35,260 --> 00:13:37,660
atsispausdinti hashtag,
Žyma su grotelėmis A grotelėmis.

269
00:13:37,660 --> 00:13:40,480
Vienas už linijos, nes aš
turėti naują eilutę ten.

270
00:13:40,480 --> 00:13:42,787
Ir priminti, kad už
kilpa, už paskutinio week--

271
00:13:42,787 --> 00:13:44,620
ir gausite daugiau
susipažinęs su sintakse

272
00:13:44,620 --> 00:13:47,170
naudojant ją su praktika
prieš long-- tai suteikia man

273
00:13:47,170 --> 00:13:49,740
kintamasis vadinamas i ir nustato, kad 0.

274
00:13:49,740 --> 00:13:52,650
>> Tai padidina I
kas iteracijos 1.

275
00:13:52,650 --> 00:13:54,940
Todėl aš eina į 1 iki 2 iki 3.

276
00:13:54,940 --> 00:13:57,690
Ir tada ši sąlyga į
viduryje tarp kabliataškiais

277
00:13:57,690 --> 00:14:03,010
gauna tikrinamas kiekvieną iteracijos padaryti
Įsitikinkite, kad mes vis dar per diapazone.

278
00:14:03,010 --> 00:14:06,830
Taigi noriu pakartoti 10 kartų, todėl aš
turi tarsi labai intuityviai tik

279
00:14:06,830 --> 00:14:09,070
įdėti 10 kaip mano viršutinė riba yra.

280
00:14:09,070 --> 00:14:14,310
>> Ir dar, kai aš paleisti tai, po
Sudarant jį su modelio buggy2--

281
00:14:14,310 --> 00:14:15,440
ir ji kaupia Gerai.

282
00:14:15,440 --> 00:14:17,980
Taigi aš neturite
sintaksės klaida šį kartą.

283
00:14:17,980 --> 00:14:20,940
Leiskite man eiti į priekį dabar
ir paleisti buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Ir dabar slinkite aukštyn.

285
00:14:22,620 --> 00:14:24,890
Ir leiskite man padidinti
lango dydis.

286
00:14:24,890 --> 00:14:33,720
>> Man atrodo, kad turi 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Taigi ten 11 Žymas, nors
Aš aiškiai įdėti 10 viduje šio kilpa.

288
00:14:38,891 --> 00:14:42,140
Dabar, kai jūs galite pamatyti iš karto
kas yra klaida, nes, tiesą sakant, tai

289
00:14:42,140 --> 00:14:43,720
nėra labai sunku klaida padaryti.

290
00:14:43,720 --> 00:14:46,070
Bet tai labai dažnai
padarė labai anksti.

291
00:14:46,070 --> 00:14:49,820
>> Ką aš noriu atkreipti dėmesį, nors,
yra, kaip gali man suprasti tai?

292
00:14:49,820 --> 00:14:52,300
Na, paaiškėja, kad
CS50 biblioteka ateina

293
00:14:52,300 --> 00:14:55,380
su ne tik get_string ir get_int
ir get_float ir kitas funkcijas.

294
00:14:55,380 --> 00:14:59,980
Ji taip pat ateina su specialiu funkcija
vadinamas eprintf arba, klaida printf.

295
00:14:59,980 --> 00:15:03,270
Ir tai vien tik padaryti
tai šiek tiek lengviau jums

296
00:15:03,270 --> 00:15:06,310
kai derinate kodą tiesiog
spausdinti klaidos pranešimą ekrane

297
00:15:06,310 --> 00:15:07,850
ir žinoti, kur ji atėjo iš.

298
00:15:07,850 --> 00:15:11,000
>> Taigi, pavyzdžiui, vienas dalykas, aš galėtų
padaryti čia su šia funkcija this--

299
00:15:11,000 --> 00:15:20,230
eprintf, ir tada aš ruošiuosi eiti į priekį
ir pasakyti, kad aš dabar% i Backslash n.

300
00:15:20,230 --> 00:15:22,330
Ir aš ruošiuosi įjunkite I vertė.

301
00:15:22,330 --> 00:15:25,400
Ir iki viršaus, nes tai
yra CS50 bibliotekoje,

302
00:15:25,400 --> 00:15:27,580
Aš ruošiuosi eiti į priekį
ir taip pat

303
00:15:27,580 --> 00:15:29,169
todėl aš turiu prieigą prie šios funkcijos.

304
00:15:29,169 --> 00:15:31,460
Bet tegul mano ką linija
9 Manoma, kad daryti.

305
00:15:31,460 --> 00:15:32,670
Aš ruošiuosi ištrinti, galų gale.

306
00:15:32,670 --> 00:15:34,670
Tai neturi nieko bendro
su mano svarbiausiam tikslo.

307
00:15:34,670 --> 00:15:39,090
Bet eprintf, klaidų printf, tiesiog reiškė,
duoti man šiek tiek diagnostikos informaciją.

308
00:15:39,090 --> 00:15:42,460
Kai aš paleisti savo programą, aš noriu
pamatyti tai ekrane, laikinai

309
00:15:42,460 --> 00:15:44,550
taip pat tik suprasti
kas vyksta.

310
00:15:44,550 --> 00:15:47,330
>> Ir, tiesą sakant, dėl kiekvieno
iteracijos čia linijos 9

311
00:15:47,330 --> 00:15:49,260
Noriu pamatyti, kas yra i vertė?

312
00:15:49,260 --> 00:15:50,290
Kas yra i vertė?

313
00:15:50,290 --> 00:15:51,280
Kas yra i vertė?

314
00:15:51,280 --> 00:15:55,650
Ir, tikiuosi, aš tik turėtų
matyti, kad pranešimas, taip pat 10 kartų.

315
00:15:55,650 --> 00:15:57,780
>> Taigi leiskite man eiti į priekį ir
perkompiliuoti savo programą,

316
00:15:57,780 --> 00:15:59,905
kaip turiu daryti bet kuriuo metu
Aš padaryti kaita. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Ir now-- Gerai.

319
00:16:03,640 --> 00:16:04,820
Yra daug daugiau vyksta.

320
00:16:04,820 --> 00:16:07,610
Taigi leiskite man slinkite aukštyn į
dar didesnis langas.

321
00:16:07,610 --> 00:16:10,190
>> Ir pamatysite, kad kiekvienas
žymos su grotelėmis dar spausdinimo metu.

322
00:16:10,190 --> 00:16:15,270
Bet tarp kiekvienos iš jų yra dabar tai
diagnostikos produkcija suformatuotas taip.

323
00:16:15,270 --> 00:16:17,960
Mano programa čia vardas buggy2.

324
00:16:17,960 --> 00:16:20,432
Failo vardas buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Eilutės numeris, iš kurio
tai buvo spausdinami yra linija, 9.

326
00:16:24,080 --> 00:16:27,500
Ir tada tos teisės yra
klaidos pranešimas, kad aš laukiu.

327
00:16:27,500 --> 00:16:30,701
>> Ir kas malonu apie tai, kad
dabar aš neturiu būtinai skaičiuoti

328
00:16:30,701 --> 00:16:32,200
mano galva, ką mano programa daro.

329
00:16:32,200 --> 00:16:34,240
Matau, kad dėl
pirmajame iteracijos i yra 0,

330
00:16:34,240 --> 00:16:39,420
tada 1, tada 2, tada 3, tada 4, tada
5, tada 6, tada 7, tada 8, tada 9, tada

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Taigi palauk.

333
00:16:42,050 --> 00:16:43,740
Kas čia vyksta?

334
00:16:43,740 --> 00:16:48,190
Aš vis dar atrodo, kad skaičiuojant
kaip numatyta iki 10.

335
00:16:48,190 --> 00:16:50,550
>> Bet kur gi man pradėti?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

337
00:16:53,240 --> 00:16:58,040
Taip 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11-pirštas

338
00:16:58,040 --> 00:16:59,990
tai rodo, kad šią problemą.

339
00:16:59,990 --> 00:17:02,850
Man atrodo, kad suskaičiavau
neteisingai mano kilpa.

340
00:17:02,850 --> 00:17:06,599
Užuot eiti 10 iteracijų,
Aš pradedu 0,

341
00:17:06,599 --> 00:17:09,550
Aš baigiasi ir per 10.

342
00:17:09,550 --> 00:17:12,030
Bet todėl, kad, kaip kompiuteris,
Aš pradedu skaičiavimo 0,

343
00:17:12,030 --> 00:17:15,250
Būčiau skaičiuoti iki
į, bet ne per, 10.

344
00:17:15,250 --> 00:17:18,510
>> Ir taip nustatyti, aš galų gale
čia realizuotas, yra vienas iš dviejų dalykų.

345
00:17:18,510 --> 00:17:22,430
Galėčiau labai paprastai pasakyti
skaičiuoti iki mažiau nei 10.

346
00:17:22,430 --> 00:17:27,260
Taip 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, kuris yra, iš tikrųjų, teisinga,

347
00:17:27,260 --> 00:17:28,900
nors tai skamba šiek tiek negerai.

348
00:17:28,900 --> 00:17:35,070
Arba aš galėčiau padaryti mažesnis arba lygus
iki 9, taip ilgai, kaip aš prasideda nuo 0.

349
00:17:35,070 --> 00:17:40,056
Arba jei tikrai nepatinka, kad jus
gali tikėtis ne per 10, bet prasideda 1 d.

350
00:17:40,056 --> 00:17:41,680
Bet vėl, tai tik ne tai, kad bendra.

351
00:17:41,680 --> 00:17:43,977
Be programming-- nors ir
ne tiek Scratch--

352
00:17:43,977 --> 00:17:45,810
bet programavimo
C ir kitų kalbų,

353
00:17:45,810 --> 00:17:47,670
kaip JavaScript ir
Python ir kiti, tai

354
00:17:47,670 --> 00:17:49,880
tiesiog labai dažnas
Mūsų diskusija dvejetainis

355
00:17:49,880 --> 00:17:53,450
tiesiog pradėti skaičiuoti ne
Mažiausiai galite, kuris yra 0.

356
00:17:53,450 --> 00:17:53,950
Gerai.

357
00:17:53,950 --> 00:17:55,160
Štai eprintf.

358
00:17:55,160 --> 00:17:58,600
Ir vėl, dabar, kad aš raštuotas, mano
problema, ir aš ruošiuosi grįžti iki 0

359
00:17:58,600 --> 00:18:01,470
per mažiau nei 10, aš ruošiuosi
eiti ir ištrinti eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Ji turėtų būti ten, kai aš
pervežti savo kodą arba pateikti savo kodą

361
00:18:04,580 --> 00:18:05,800
arba parodyti jį kitiems.

362
00:18:05,800 --> 00:18:07,980
Tai tikrai tik reiškė
laikinai naudoti.

363
00:18:07,980 --> 00:18:11,650
Bet dabar aš fiksuotas tai
ypač problema taip pat.

364
00:18:11,650 --> 00:18:16,780
>> Na, padarykime dar vieną pavyzdį čia
kad aš ruošiuosi pakelti taip.

365
00:18:16,780 --> 00:18:22,850
Aš ruošiuosi eiti į priekį ir
#include. 50 $

366
00:18:22,850 --> 00:18:25,580
Ir aš ruošiuosi eiti į priekį
ir #include.

367
00:18:25,580 --> 00:18:29,030
>> Ir aš ruošiuosi išsaugoti
šiam failui kaip buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Ir aš ruošiuosi eiti į priekį
ir deklaruoti int main (void).

369
00:18:31,740 --> 00:18:34,186
Ir tada viduje yra
Aš ruošiuosi daryti int i _ -

370
00:18:34,186 --> 00:18:36,435
Noriu įgyvendinti programą
su get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Tai ne funkcija, kad egzistuoja dar.

373
00:18:40,770 --> 00:18:42,870
Taigi, mes ketiname įgyvendinti
jis vos akimirką.

374
00:18:42,870 --> 00:18:45,541
Tačiau mes ketiname pamatyti, kodėl
tai Buggy pirmo perdavimo.

375
00:18:45,541 --> 00:18:47,290
Ir kai aš Dotarłeś
LC nuo vartotojo,

376
00:18:47,290 --> 00:18:53,365
Aš tik ketina spausdinti% I yra neigiamas
sveikasis skaičius, Backslash, N, kablelis, aš.

377
00:18:53,365 --> 00:18:55,240
Kitaip tariant, viskas, ką aš
norite šią programą padaryti

378
00:18:55,240 --> 00:18:58,000
yra gauti neigiamą int nuo
vartotojas ir tada atsispausdinti

379
00:18:58,000 --> 00:18:59,980
kad toks ir toks yra neigiamas INT.

380
00:18:59,980 --> 00:19:02,080
>> Dabar man reikia įgyvendinti šią funkciją.

381
00:19:02,080 --> 00:19:05,740
Taigi vėliau mano byla, aš ruošiuosi eiti
į priekį ir paskelbti funkcija vadinama

382
00:19:05,740 --> 00:19:10,670
get_negative_int (tuščia) - ir mes
grįžti į tai, kas, kad linija reiškia vėl

383
00:19:10,670 --> 00:19:18,790
į moment-- int n; do-- Do
following-- printf n yra :.

384
00:19:18,790 --> 00:19:26,210
Ir tada aš ruošiuosi daryti n - get_int,
ir padaryti tai, o n yra didesnis už 0.

385
00:19:26,210 --> 00:19:28,310
Ir tada grįžti N ;.

386
00:19:28,310 --> 00:19:31,730
>> Taigi ten daug vyksta
tai, tačiau nė vienas iš jų mes ne

387
00:19:31,730 --> 00:19:33,710
pažvelgti paskutinę savaitę, bent jau trumpai.

388
00:19:33,710 --> 00:19:36,980
Taigi nuo 10 eilutėje čia aš paskelbus
funkcija vadinama get_negative_int,

389
00:19:36,980 --> 00:19:39,620
ir aš įdėti (tuščia), į
skliaustai, priežastis yra tai

390
00:19:39,620 --> 00:19:40,950
nesiima įvestį.

391
00:19:40,950 --> 00:19:42,910
Nesu artimųjų nieko
su šia funkcija.

392
00:19:42,910 --> 00:19:44,690
Aš tiesiog gauti kažką atgal iš jo.

393
00:19:44,690 --> 00:19:47,270
>> Ir ką aš tikiuosi, kad
grįžti yra sveikasis skaičius.

394
00:19:47,270 --> 00:19:50,040
Nėra duomenų tipas
C vadinamas negative_int.

395
00:19:50,040 --> 00:19:52,880
Tai tiesiog int, todėl jis ketina
būti mums įsitikinti,

396
00:19:52,880 --> 00:19:55,340
kad vertė, kad iš tikrųjų
Grąžintos yra ne tik int

397
00:19:55,340 --> 00:19:56,380
bet taip pat yra neigiama.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 Aš paskelbti kintamąjį
vadinamas n ir todėl tipo int.

399
00:20:02,150 --> 00:20:07,500
Ir tada linija 13 per 18 aš
daro kažką, o kažkas yra tiesa.

400
00:20:07,500 --> 00:20:11,040
Aš ruošiuosi į priekį ir spausdinimas
n yra, gaubtinės žarnos, ir tada erdvė,

401
00:20:11,040 --> 00:20:12,800
lyg Vartotojui eilutę.

402
00:20:12,800 --> 00:20:16,410
>> Aš tada skambina get_int ir
saugoti savo vadinamąją sugrįžimo vertę

403
00:20:16,410 --> 00:20:18,130
toje kintamojo n.

404
00:20:18,130 --> 00:20:22,600
Bet aš ruošiuosi nuolat daro
tai, o n yra didesnis už 0.

405
00:20:22,600 --> 00:20:27,960
Kitaip tariant, jei vartotojas suteikia man
Int, kad skaičius yra didesnis už 0,

406
00:20:27,960 --> 00:20:31,180
ERGO teigiamas, aš ruošiuosi
tiesiog laikyti reprompting vartotojui,

407
00:20:31,180 --> 00:20:37,160
išlaikyti reprompting, verčia juos
bendradarbiauti ir suteikti man neigiamą int.

408
00:20:37,160 --> 00:20:41,640
>> Ir kai n yra iš tikrųjų negative--
Tarkime, kad vartotojas galiausiai tipai -50,

409
00:20:41,640 --> 00:20:46,710
tai o kilpa nebėra tiesa
nes -50 yra ne didesnis nei 0.

410
00:20:46,710 --> 00:20:51,140
Taigi, mes išeiti iš, kad
kilpa logiškai ir grįžti n.

411
00:20:51,140 --> 00:20:53,520
>> Bet yra vienas kitas
dalykas turiu daryti.

412
00:20:53,520 --> 00:20:56,190
Ir aš tiesiog gali tai padaryti
iki kopijuoti ir įklijuoti

413
00:20:56,190 --> 00:20:58,540
viena eilutė kodo ties failo viršuje.

414
00:20:58,540 --> 00:21:01,630
Man reikia mokyti žvangėjimas,
ar žada žvangėjimas,

415
00:21:01,630 --> 00:21:04,630
aiškiai nurodoma, kad aš noriu,
Iš tiesų, eikite ir įgyvendinti

416
00:21:04,630 --> 00:21:06,020
Ši funkcija get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Tai gali būti tiesiog mažesnis failo.

418
00:21:07,674 --> 00:21:09,840
Vėlgi, priminti, kad klingsėti
skaito dalykus iš viršaus į apačią,

419
00:21:09,840 --> 00:21:12,330
kairės į dešinę, todėl jūs negalite jų
skambinti funkcija Jei žvangėjimas

420
00:21:12,330 --> 00:21:15,330
nepažįsta jis ketina egzistuoja.

421
00:21:15,330 --> 00:21:18,430
>> Dabar, deja, ši programa,
kaip kai kurie iš jūsų galbūt jau pastebėjote,

422
00:21:18,430 --> 00:21:19,590
jau Buggy.

423
00:21:19,590 --> 00:21:21,400
Leiskite man eiti į priekį ir padaryti buggy3.

424
00:21:21,400 --> 00:21:26,904
Jis kaupia, todėl mano problema dabar ne
sintaksės klaida, kaip teksto klaidos,

425
00:21:26,904 --> 00:21:29,570
tai tikrai bus logiškas
klaida, kad aš sąmoningai

426
00:21:29,570 --> 00:21:32,450
padaryta galimybė
žingsnis per tai, kas vyksta.

427
00:21:32,450 --> 00:21:35,540
>> Aš ruošiuosi eiti į priekį
dabar ir paleisti buggy3.

428
00:21:35,540 --> 00:21:37,490
Ir aš ruošiuosi eiti
į priekį, o ne bendradarbiauti.

429
00:21:37,490 --> 00:21:39,494
Aš ruošiuosi duoti jai skaičių 1.

430
00:21:39,494 --> 00:21:41,410
Tai nepatiko, todėl
tai vėl paskatino mane.

431
00:21:41,410 --> 00:21:42,147
>> Kaip apie 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Nė vienas iš šių dirba.

435
00:21:44,740 --> 00:21:46,890
Kaip apie -50?

436
00:21:46,890 --> 00:21:48,560
Ir atrodo, kad programoje dirbti.

437
00:21:48,560 --> 00:21:49,970
>> Leiskite pabandyti dar kartą.

438
00:21:49,970 --> 00:21:53,400
Leiskite man pabandyti -1, atrodo, kad darbas.

439
00:21:53,400 --> 00:21:56,380
Leiskite man pabandyti -2, atrodo, kad darbas.

440
00:21:56,380 --> 00:21:59,640
Leiskite man pabandyti 0.

441
00:21:59,640 --> 00:22:01,684
Huh, tai neteisinga.

442
00:22:01,684 --> 00:22:03,350
Dabar mes yra šiek tiek pedantiškas čia.

443
00:22:03,350 --> 00:22:07,090
Bet tai, žinoma, pasitaiko, kad 0
nėra nei teigiamas, nei neigiamas.

444
00:22:07,090 --> 00:22:11,150
Ir taip dėl to, kad mano programa yra
sakydamas, kad 0 yra neigiamas sveikasis skaičius,

445
00:22:11,150 --> 00:22:12,820
tai ne techniškai teisinga.

446
00:22:12,820 --> 00:22:15,180
>> Dabar, kodėl jis tai daro?

447
00:22:15,180 --> 00:22:16,270
Na, tai gali būti akivaizdūs.

448
00:22:16,270 --> 00:22:18,110
Ir, tiesą sakant, ši programa yra
reiškia būti gana paprasta

449
00:22:18,110 --> 00:22:19,670
todėl mes turime kažką tyrinėti.

450
00:22:19,670 --> 00:22:25,870
>> Bet tegul pristatyti trečią derinti
technika čia vadinamas debug50.

451
00:22:25,870 --> 00:22:27,750
Todėl tai yra programa
kad mes ką tik sukūrėte

452
00:22:27,750 --> 00:22:30,770
šiais metais vadinamas debug50
kuris leis jums

453
00:22:30,770 --> 00:22:34,130
naudoti tai, kas vadinama built-in
grafinė derintojas į CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Ir debugerem yra tik programa, kuri
paprastai leidžia jums paleisti savo programą

455
00:22:38,400 --> 00:22:44,050
bet žingsnis po žingsnio po žingsnio, linija
iki eilutė po eilutės, sustoja, išnyra

456
00:22:44,050 --> 00:22:47,626
aplink, žiūri kintamųjų, kad
Programa ne tik smūgis praeiti jums

457
00:22:47,626 --> 00:22:49,750
ir greitai spausdinti kažką
ar ne spausdinti kažką.

458
00:22:49,750 --> 00:22:53,250
Jis suteikia jums galimybę, bent
žmogaus greitis, bendrauti su juo.

459
00:22:53,250 --> 00:22:55,470
>> Ir tai padaryti, jums
tiesiog atlikite šiuos veiksmus.

460
00:22:55,470 --> 00:22:58,479
Po kompiliavimo kodą,
kurį aš jau padariau, buggy3,

461
00:22:58,479 --> 00:23:00,020
jūs einate į priekį ir paleisti debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Tiek daug, kaip help50 turi paleisti
help50 ir tuomet komanda,

464
00:23:06,760 --> 00:23:10,120
debug50 turi paleisti debug50 ir
tada komandą pavadinimas.

465
00:23:10,120 --> 00:23:14,440
>> Dabar žiūrėti, kas vyksta mano ekrano,
ant dešinėje pusėje ypač.

466
00:23:14,440 --> 00:23:19,400
Kai aš paspauskite Vykdyti, visi iš
Staiga tai dešinioji skydelis

467
00:23:19,400 --> 00:23:20,419
atveria ekrane.

468
00:23:20,419 --> 00:23:22,210
Ir ten daug vyksta
nuo iš pirmo žvilgsnio.

469
00:23:22,210 --> 00:23:25,110
Bet ten ne per
daug nerimauti dar.

470
00:23:25,110 --> 00:23:28,570
>> Tai rodo man viską
kad vyksta viduje mano programos

471
00:23:28,570 --> 00:23:31,130
dabar ir per tai
Mygtukai iki viršaus tada

472
00:23:31,130 --> 00:23:35,910
leidžia man dėti per mano kodas
galiausiai žingsnis po žingsnio po žingsnio.

473
00:23:35,910 --> 00:23:37,140
Bet dar tik.

474
00:23:37,140 --> 00:23:38,060
Atkreipkite dėmesį, kas atsitiks.

475
00:23:38,060 --> 00:23:40,600
Mano terminalo lange
Aš raginami n.

476
00:23:40,600 --> 00:23:44,560
Ir aš ruošiuosi eiti į priekį ir
bendradarbiauti šiuo metu ir tipą -1.

477
00:23:44,560 --> 00:23:48,770
Ir nors šiek tiek cryptically -1
yra neigiamas sveikas skaičius, kaip tikimasi,.

478
00:23:48,770 --> 00:23:52,020
>> Ir tada vaikas išėjo su
statusas 0 GDBserver išeinant.

479
00:23:52,020 --> 00:23:55,180
GDB GNU derintojas, yra vardas
užtikrinamojo programinė įranga

480
00:23:55,180 --> 00:23:56,620
kad vykdo šią debugerem.

481
00:23:56,620 --> 00:24:00,500
Bet visa tai iš tikrųjų reiškia, kad debugerem
pasitraukė, nes mano programa mesti

482
00:24:00,500 --> 00:24:01,710
ir viskas buvo gerai.

483
00:24:01,710 --> 00:24:06,020
Jei aš noriu tikrai derinti savo programą,
Turiu Preemptively pasakyti debug50,

484
00:24:06,020 --> 00:24:08,920
kur aš noriu pradėti
gerinimo per mano kodas?

485
00:24:08,920 --> 00:24:11,750
>> Ir galbūt paprasčiausias būdas
padaryti, kad yra taip.

486
00:24:11,750 --> 00:24:15,300
Jei aš užveskite pelės žymeklį ant
Latako mano redaktorius čia

487
00:24:15,300 --> 00:24:19,090
taip tikrai tik į šoninę juostą čia
į eilutės numeris kairėje,

488
00:24:19,090 --> 00:24:21,870
Atkreipkite dėmesį, kad, jei aš tiesiog spustelėkite
vieną kartą, aš įdėti mažą raudoną taškelį.

489
00:24:21,870 --> 00:24:24,460
Ir kad mažai red dot ",
kaip stop ženklas, reiškia, ei,

490
00:24:24,460 --> 00:24:29,430
debug50, pauzė vykdymas mano kodas
tiesiai ten, kai aš paleisti šią programą.

491
00:24:29,430 --> 00:24:30,260
>> Taigi leiskite tai padaryti.

492
00:24:30,260 --> 00:24:37,340
Leiskite man eiti į priekį ir paleisti savo programą
vėl su debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Ir dabar, pranešimas, kažkas
skiriasi nutiko.

494
00:24:40,110 --> 00:24:42,440
Nesu raginami
dar mano terminalo lange

495
00:24:42,440 --> 00:24:45,430
nieko, nes aš ne
ten įsigijo dar mano programą.

496
00:24:45,430 --> 00:24:47,950
Atkreipkite dėmesį, kad 8 eilutė
kuris dabar yra pabrėžta,

497
00:24:47,950 --> 00:24:51,720
ir ten šiek tiek rodyklę
kairė posakis, jūs stabtelėjo čia.

498
00:24:51,720 --> 00:24:55,030
Šis kodas, linijos linija
8, dar nėra įvykdytas.

499
00:24:55,030 --> 00:24:58,940
>> Ir kas įdomu, jei aš žiūriu
per čia, dešinėje pusėje,

500
00:24:58,940 --> 00:25:03,530
pastebėti, kad i yra vietos
kintamasis, vietos ta prasme,

501
00:25:03,530 --> 00:25:05,450
kad viduje dabartinio funkcija.

502
00:25:05,450 --> 00:25:08,920
Ir jo vertė, matyt pagal nutylėjimą,
ir tarsi patogiai, yra 0.

503
00:25:08,920 --> 00:25:10,260
Bet aš ne įrašykite 0.

504
00:25:10,260 --> 00:25:13,410
Tai tiesiog atsitinka būti jos
Numatytoji reikšmė šiuo metu.

505
00:25:13,410 --> 00:25:15,490
>> Taigi leiskite man eiti į priekį ir tai padaryti dabar.

506
00:25:15,490 --> 00:25:18,680
Leiskite man eiti į priekį ir
viršutiniame dešiniajame čia aš

507
00:25:18,680 --> 00:25:20,970
ketina eiti į priekį ir
spustelėkite šį pirmąjį piktogramą, kuri

508
00:25:20,970 --> 00:25:25,360
reiškia peržengti, o tai reiškia ne praleisti
ji bet žingsnis per šį kodo eilutę,

509
00:25:25,360 --> 00:25:27,770
vykdyti jai pakeliui.

510
00:25:27,770 --> 00:25:30,710
>> Ir dabar, pastebėsite, mano
greitai ką tik pakeistas.

511
00:25:30,710 --> 00:25:31,380
Kodėl taip yra?

512
00:25:31,380 --> 00:25:33,639
Aš papasakojo debug50,
paleisti šią eilutę kodo.

513
00:25:33,639 --> 00:25:34,930
Ką ši eilutė kodo daryti?

514
00:25:34,930 --> 00:25:35,960
Verčia mane už tarpt.

515
00:25:35,960 --> 00:25:36,460
GERAI.

516
00:25:36,460 --> 00:25:37,400
Leiskite bendradarbiauti.

517
00:25:37,400 --> 00:25:41,340
Leiskite man eiti į priekį ir dabar -1 tipo, "Enter".

518
00:25:41,340 --> 00:25:42,920
Ir dabar pastebėsite, kas pasikeitė.

519
00:25:42,920 --> 00:25:46,060
Dešinėje pusėje,
mano vietos kintamasis i

520
00:25:46,060 --> 00:25:48,200
nurodoma kaip -1 dabar.

521
00:25:48,200 --> 00:25:49,810
Ir tai dar tipo int.

522
00:25:49,810 --> 00:25:53,102
>> Ir pranešimas, taip pat, mano vadinamasis
skambinti krūvą, kur aš pristabdyti?

523
00:25:53,102 --> 00:25:54,810
Mes kalbame daugiau apie
tai ateityje.

524
00:25:54,810 --> 00:25:58,620
Tačiau skambutis kamino tiesiog reiškia ką
funkcijos yra šiuo metu juda.

525
00:25:58,620 --> 00:26:00,040
Dabar tai tik pagrindinis.

526
00:26:00,040 --> 00:26:03,590
Ir dabar vienintelis vietos
kintamasis yra i su vertės 1 d.

527
00:26:03,590 --> 00:26:09,840
>> Ir kai aš pagaliau peržengti šią liniją
čia su tuo pačiu piktogramą viršutiniame dešiniajame kampe,

528
00:26:09,840 --> 00:26:11,410
-1 Yra neigiamas sveikasis skaičius.

529
00:26:11,410 --> 00:26:13,580
Dabar jis sustoja per tą garbanotais petnešomis.

530
00:26:13,580 --> 00:26:14,740
Leiskite tegul ji padaryti savo dalykas.

531
00:26:14,740 --> 00:26:17,300
Aš peržengti tą liniją, ir voila.

532
00:26:17,300 --> 00:26:20,240
>> Taigi ne visi, kad siaubingai
Paaiškinti dar,

533
00:26:20,240 --> 00:26:23,550
bet jis leiskite man pristabdyti
ir manau per logiškai

534
00:26:23,550 --> 00:26:24,870
ką ši programa daro.

535
00:26:24,870 --> 00:26:26,890
Bet tai buvo ne klaidinga atveju.

536
00:26:26,890 --> 00:26:28,510
Leiskite tai padaryti dar kartą taip.

537
00:26:28,510 --> 00:26:31,340
>> Aš ruošiuosi išvykti iš šios atskaitos tašką
8 linijos su raudonu tašku.

538
00:26:31,340 --> 00:26:32,830
Aš ruošiuosi pakartotas debug50.

539
00:26:32,830 --> 00:26:34,400
Tai automatiškai sustabdytas čia.

540
00:26:34,400 --> 00:26:37,660
Bet šį kartą, vietoj
gerinimo per šią liniją,

541
00:26:37,660 --> 00:26:42,290
leiskite man iš tikrųjų eiti viduje
get_negative_int ir išsiaiškinti,

542
00:26:42,290 --> 00:26:45,530
kodėl jis priimdamas 0 kaip galiojantį atsakyti?

543
00:26:45,530 --> 00:26:47,990
>> Taigi vietoj paspausdami peržengti.

544
00:26:47,990 --> 00:26:50,630
Aš ruošiuosi eiti į priekį
ir spauskite žingsnis į.

545
00:26:50,630 --> 00:26:54,030
Ir pastebėsite kad linija 8 tai
dabar pabrėžė dabar staiga

546
00:26:54,030 --> 00:26:56,900
tampa eilutė 17.

547
00:26:56,900 --> 00:26:59,947
>> Dabar, tai nereiškia, kad išriktuotojo
buvo praleista linijos 14 ir 15 ir 16.

548
00:26:59,947 --> 00:27:01,780
Tai tiesiog nėra nieko
parodyti jums ten.

549
00:27:01,780 --> 00:27:04,050
Tie, kurie tik deklaruojant kintamuosius,
ir tada ten žodis Ar

550
00:27:04,050 --> 00:27:05,390
ir tada atvira garbanotas petnešomis.

551
00:27:05,390 --> 00:27:09,227
Vienintelis funkcionalus linija, kuri yra
sultingas tikrai tai vienas čia 17.

552
00:27:09,227 --> 00:27:11,060
Ir tai, kai mes
automatiškai sustabdytas.

553
00:27:11,060 --> 00:27:13,870
>> Taigi printf ( "n.is:") ;, taip
kad dar neįvyko.

554
00:27:13,870 --> 00:27:18,250
Taigi eikime į priekį ir spustelėkite peržengti.

555
00:27:18,250 --> 00:27:20,326
Dabar mano laiku, iš tikrųjų,
pakeistas į ( "n yra:").

556
00:27:20,326 --> 00:27:22,450
Dabar get_int, aš nesiruošia
vargintis žengia į,

557
00:27:22,450 --> 00:27:24,750
nes ta funkcija buvo
padaryta CS50 bibliotekoje.

558
00:27:24,750 --> 00:27:25,750
Tai turbūt teisinga.

559
00:27:25,750 --> 00:27:28,440
>> Taigi, aš ruošiuosi eiti į priekį ir
rūšiuoti bendradarbiauti, suteikiant jam

560
00:27:28,440 --> 00:27:30,590
LC, bet nėra neigiamas INT.

561
00:27:30,590 --> 00:27:32,870
Taigi leiskite man eiti į priekį ir paspauskite 0.

562
00:27:32,870 --> 00:27:39,460
O dabar tai, kas vyksta čia
kai aš kibti į liniją 21?

563
00:27:39,460 --> 00:27:40,890
Aš ne kartą pakartota.

564
00:27:40,890 --> 00:27:43,320
Nemanau, atrodo, įstrigo toje kilpa.

565
00:27:43,320 --> 00:27:45,990
Kitaip tariant, tai geltonos
baras neišsaugojo vyksta aplink,

566
00:27:45,990 --> 00:27:47,130
ir aplink, ir aplink.

567
00:27:47,130 --> 00:27:48,340
>> Dabar, kodėl taip yra?

568
00:27:48,340 --> 00:27:49,920
Na, N, ką yra n dabar?

569
00:27:49,920 --> 00:27:53,280
Galiu pažvelgti vietos
kintamieji išriktuotojo.

570
00:27:53,280 --> 00:27:53,816
n yra 0.

571
00:27:53,816 --> 00:27:55,190
Gerai, kas buvo mano būklė?

572
00:27:55,190 --> 00:27:58,700
>> 20-- linija 20 yra gerai,
0 yra didesnis už 0.

573
00:27:58,700 --> 00:27:59,500
Tai netiesa.

574
00:27:59,500 --> 00:28:01,020
0 yra ne didesnis nei 0.

575
00:28:01,020 --> 00:28:02,820
Ir todėl aš įsiplieskė apie tai.

576
00:28:02,820 --> 00:28:06,370
>> Ir taip, tai kodėl on-line
21, jei aš iš tikrųjų toliau,

577
00:28:06,370 --> 00:28:10,370
Aš ruošiuosi grįžti 0, net
nors aš turėjo atmesti 0

578
00:28:10,370 --> 00:28:12,484
kaip ne iš tikrųjų yra neigiamas.

579
00:28:12,484 --> 00:28:14,650
Taigi, dabar, aš tikrai ne, net
rūpi išriktuotojo.

580
00:28:14,650 --> 00:28:16,900
Supratau, man nereikia, kad
žinoti, kas daugiau, kas vyksta.

581
00:28:16,900 --> 00:28:19,233
>> Taigi, aš ruošiuosi eiti į priekį ir
tiesiog spustelėkite mygtuką Groti,

582
00:28:19,233 --> 00:28:20,240
ir tegul šį baigti.

583
00:28:20,240 --> 00:28:23,440
Dabar, aš supratau, kad mano
klaida yra, matyt, on-line 20 d.

584
00:28:23,440 --> 00:28:25,160
Štai mano logiška klaida.

585
00:28:25,160 --> 00:28:28,100
>> Ir taip, ko aš noriu
daryti tai pakeisti?

586
00:28:28,100 --> 00:28:32,500
Jei problema yra tai, kad aš nesu
traukiantis 0, tai tik logiška klaida.

587
00:28:32,500 --> 00:28:35,910
Ir galiu pasakyti, o n yra
didesnis nei arba lygus 0,

588
00:28:35,910 --> 00:28:38,330
nuolat vėl ir vėl paskatino vartotoją.

589
00:28:38,330 --> 00:28:41,050
>> Taigi, vėlgi, paprastas klaida, galbūt
net akivaizdu, kai pamatė mane

590
00:28:41,050 --> 00:28:42,410
rašyti vos prieš kelias minutes.

591
00:28:42,410 --> 00:28:44,570
Bet Takeaway čia
yra tai, kad su debug 50,

592
00:28:44,570 --> 00:28:46,850
ir derinimo
Programinė įranga apskritai

593
00:28:46,850 --> 00:28:51,370
turite šią naują rasti galią
vaikščioti per savo kodo, ieškoti

594
00:28:51,370 --> 00:28:55,590
per tą dešiniajame skydelyje kas
Jūsų kintamieji dydžiai.

595
00:28:55,590 --> 00:28:57,700
Taigi jūs nebūtinai
turite naudoti kažką

596
00:28:57,700 --> 00:29:00,630
kaip jūs eprintf spausdinti šias vertybes.

597
00:29:00,630 --> 00:29:04,430
Jūs iš tikrųjų galite pamatyti juos
vizualiai ekrane.

598
00:29:04,430 --> 00:29:08,920
>> Dabar, po to, verta pažymėti,
kad yra ir kitas metodas, kuris yra

599
00:29:08,920 --> 00:29:09,890
tikrai super bendro.

600
00:29:09,890 --> 00:29:13,120
Ir galbūt įdomu, kodėl šis mažas
vaikinas čia buvo sėdi ant scenos.

601
00:29:13,120 --> 00:29:16,490
Taigi ten šis metodas, paprastai
žinomas kaip guminė antis derinimo,

602
00:29:16,490 --> 00:29:18,786
kuris tikrai yra tik
testamentas į tai

603
00:29:18,786 --> 00:29:20,660
, kad dažnai, kai programuotojai
rašote kodą

604
00:29:20,660 --> 00:29:22,650
jie nebūtinai
bendradarbiauja su kitais,

605
00:29:22,650 --> 00:29:24,030
arba dirba bendrame aplinkos.

606
00:29:24,030 --> 00:29:25,050
>> Jie tarsi namuose.

607
00:29:25,050 --> 00:29:25,910
Gal tai vėlai naktį.

608
00:29:25,910 --> 00:29:28,190
Jie bando išsiaiškinti
kai kurie jų klaidų kode.

609
00:29:28,190 --> 00:29:29,330
Ir jie tiesiog nemato ją.

610
00:29:29,330 --> 00:29:30,329
>> Ir nėra kambarioku.

611
00:29:30,329 --> 00:29:31,250
Nėra TF.

612
00:29:31,250 --> 00:29:32,680
Nėra ĮA aplink.

613
00:29:32,680 --> 00:29:36,440
Visi jie turi savo lentyna
tai tiek gumos Ducky.

614
00:29:36,440 --> 00:29:39,030
>> Ir taip guminė antis derinimo
yra tik tai kvietimas

615
00:29:39,030 --> 00:29:42,780
galvoti apie kažką kaip kvailas
kaip tai kaip nekilnojamojo padaras,

616
00:29:42,780 --> 00:29:46,940
ir iš tikrųjų eiti per savo kodą
žodžiu į šį negyvosios objektą.

617
00:29:46,940 --> 00:29:49,230
Taip, pavyzdžiui, jei
tai yra mano pavyzdys here--

618
00:29:49,230 --> 00:29:52,470
ir priminti, kad anksčiau
problema buvo tai,

619
00:29:52,470 --> 00:29:58,140
jei aš ištrinti šį pirmą eilutę kodo,
ir aš eiti į priekį ir padaryti Buggy 0 kartą

620
00:29:58,140 --> 00:30:01,220
Primenu, kad man teko juos
pranešimai apie klaidas čia.

621
00:30:01,220 --> 00:30:05,997
Taigi, idėja čia juokinga, nors aš
jaučiasi tuo momentu tai padaryti viešai,

622
00:30:05,997 --> 00:30:06,580
yra tai, kad klaida.

623
00:30:06,580 --> 00:30:10,910
>> Gerai, kad mano problema yra ta, kad aš
netiesiogiai paskelbė bibliotekos funkciją.

624
00:30:10,910 --> 00:30:12,610
Ir kad bibliotekos funkcija yra printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- Gerai, paskelbti
man primena prototipų.

626
00:30:15,290 --> 00:30:18,930
>> Tai reiškia, kad man reikia iš tikrųjų
pasakyti kompiliatorius iš anksto, ką

627
00:30:18,930 --> 00:30:19,980
funkcija atrodo.

628
00:30:19,980 --> 00:30:20,930
Palauk minutę.

629
00:30:20,930 --> 00:30:23,580
Aš neturėjau standartinį io.h.

630
00:30:23,580 --> 00:30:24,530
Labai ačiū.

631
00:30:24,530 --> 00:30:27,330
>> Taigi tik šis procesas of-- jumis
nereikia iš tikrųjų turi antis.

632
00:30:27,330 --> 00:30:29,819
Tačiau šis ėjimas idėja
save per savo kodo

633
00:30:29,819 --> 00:30:31,610
taip, kad jūs net girdėti
sau, kad jums

634
00:30:31,610 --> 00:30:35,620
suvokti neveikimo jūsų pačių
pastabos, paprastai yra idėja.

635
00:30:35,620 --> 00:30:38,910
>> Ir, ko gero daugiau logiškai, ne taip
daug su tuo vienu, bet aktyviau dalyvauti

636
00:30:38,910 --> 00:30:44,220
pavyzdys mes tiesiog padarė buggy 3.c,
jums gali vaikščioti save per ją

637
00:30:44,220 --> 00:30:45,310
taip.

638
00:30:45,310 --> 00:30:49,190
Taigi viskas gerai, gumos
Ducky, DDB, jei bus.

639
00:30:49,190 --> 00:30:52,350
Čia mes turime savo pagrindinės funkcijos,
Aš raginama gauti neigiamą int.

640
00:30:52,350 --> 00:30:54,660
>> Ir aš gaunu grąžos vertę.

641
00:30:54,660 --> 00:31:00,410
Aš ją saugoti kairės pusės
8 eilutėje kintamojo vadinamas i.

642
00:31:00,410 --> 00:31:02,380
Gerai, bet palauk, kaip tai padarė
kad gauti tą vertę?

643
00:31:02,380 --> 00:31:04,130
Leiskite pažvelgti į funkciją atitinka 12.

644
00:31:04,130 --> 00:31:05,760
>> Pagal 12, mes turime gauti neigiamą int.

645
00:31:05,760 --> 00:31:08,190
Nesiima jokių sąnaudų,
ar grąžina int, Gerai.

646
00:31:08,190 --> 00:31:10,929
Aš pareiškiu, 14 eilutėje kintamojo n.

647
00:31:10,929 --> 00:31:12,220
Ji ketina laikyti sveikasis skaičius.

648
00:31:12,220 --> 00:31:13,760
Tai ko aš noriu.

649
00:31:13,760 --> 00:31:18,480
>> Taigi atlikite šiuos veiksmus, o N is-- tegul
man anuliuoti ką Fix aš jau padarė.

650
00:31:18,480 --> 00:31:22,710
Taigi, nors n yra didesnis nei
0, atsispausdinti N, Gerai.

651
00:31:22,710 --> 00:31:25,170
Ir tada skambinti gauti int saugomi n.

652
00:31:25,170 --> 00:31:30,160
Ir tada patikrinti, ar n yra 0,
n yra not-- ten jis yra.

653
00:31:30,160 --> 00:31:31,910
Taigi, vėl, jūs neturite
reikia faktinį antis.

654
00:31:31,910 --> 00:31:35,650
Bet tiesiog vaikščioti save per
Jūsų kodas, kaip intelektualinė veikla

655
00:31:35,650 --> 00:31:37,720
dažnai jums padėti
suprasti, kas vyksta,

656
00:31:37,720 --> 00:31:41,170
o ne tik tai, ką
kaip tai, spoksoti į ekraną,

657
00:31:41,170 --> 00:31:43,720
ir nekalbu save per
tai, kurie sąžiningai nėra

658
00:31:43,720 --> 00:31:46,270
beveik kaip veiksmingą technika.

659
00:31:46,270 --> 00:31:48,620
Taigi jūs turite tai A
skaičius skirtingas technikas

660
00:31:48,620 --> 00:31:52,102
už faktiškai derinti savo kodą
ir rasti kaltės, kurie visi

661
00:31:52,102 --> 00:31:54,810
turėtų būti įrankiai Jūsų Toolkit
kad nesate vėlai naktį,

662
00:31:54,810 --> 00:31:57,660
ypač, esate valgomasis
salės ar bent darbo valandomis,

663
00:31:57,660 --> 00:32:00,368
banking savo galvą prieš
siena, bando išspręsti kai kurių problemų.

664
00:32:00,368 --> 00:32:02,020
Suprantu, kad yra programinės priemonės.

665
00:32:02,020 --> 00:32:03,720
Yra guminė antis įrankiai.

666
00:32:03,720 --> 00:32:09,630
Ir ten visai darbuotojai
remti laukia ištiesti ranką.

667
00:32:09,630 --> 00:32:13,120
>> Taigi dabar, žodis nuo problemos
rinkiniai, ir tai, ką mes tikimės jus

668
00:32:13,120 --> 00:32:15,620
gauti iš jų, ir kaip
mes einame apie įvertinti.

669
00:32:15,620 --> 00:32:17,680
Už aikštyno mokymo programą,
CS50 problema rinkiniai

670
00:32:17,680 --> 00:32:22,320
vertinami remiantis keturių pirminių ašių, todėl
į speak-- apimtį, teisingumą, dizainas,

671
00:32:22,320 --> 00:32:23,060
ir stilius.

672
00:32:23,060 --> 00:32:25,910
Ir taikymo sritis tik nurodo, kiek
kūrinio tu įkando išjungti?

673
00:32:25,910 --> 00:32:28,080
Kiek problema bandėte?

674
00:32:28,080 --> 00:32:30,110
Kokio lygio pastangų
tu pasireiškia?

675
00:32:30,110 --> 00:32:35,750
>> Teisingumas yra, ši programa darbą, kaip
jis turėjo už CS50 specifikacijos

676
00:32:35,750 --> 00:32:38,640
kai jūs pateikiate tam tikras žaliavas
arba kai išėjimai grįžta?

677
00:32:38,640 --> 00:32:41,130
Dizainas yra labiausiai subjektyvus iš jų.

678
00:32:41,130 --> 00:32:43,360
Ir tai vienas, kad bus
imtis ilgiausiai mokytis

679
00:32:43,360 --> 00:32:47,220
ir ilgiausiai mokyti, kad
tiek, kiek jis gali būti suvesta į,

680
00:32:47,220 --> 00:32:49,530
kaip gerai parašyta jūsų kodas?

681
00:32:49,530 --> 00:32:52,920
>> Tai vienas dalykas, tiesiog atsispausdinti teisingas
išėjimai arba grąžinti teisingas vertybes.

682
00:32:52,920 --> 00:32:55,400
Bet tu darai jį kaip
veiksmingai, kaip įmanoma?

683
00:32:55,400 --> 00:32:58,210
Ar jūs darote tai atskirtį
ir valdyk, arba dvejetainis

684
00:32:58,210 --> 00:33:01,500
paieška, kaip mes netrukus pamatysite, kad mes padarėme
prieš dvi savaites su telefonų knygos?

685
00:33:01,500 --> 00:33:04,670
Ar yra geresnių būdų, kaip išspręsti
problema, nei šiuo metu turite čia?

686
00:33:04,670 --> 00:33:06,380
Tai labai geresnio dizaino galimybė.

687
00:33:06,380 --> 00:33:08,530
>> Ir tada style-- kaip
gana tavo kodas?

688
00:33:08,530 --> 00:33:12,370
Jūs pastebėsite, kad aš esu gana
ypač apie atitraukdami savo kodą,

689
00:33:12,370 --> 00:33:15,300
ir todėl, kad mano kintamuosius
yra pagrįstai pavadintas. n,

690
00:33:15,300 --> 00:33:19,660
o trumpai tariant, yra geras vardas dėl
skaičius, i suskaičiavimo sveikasis skaičius

691
00:33:19,660 --> 00:33:20,727
s eilutę.

692
00:33:20,727 --> 00:33:22,560
Ir mes galime turėti daugiau
kintamųjų vardai stilius.

693
00:33:22,560 --> 00:33:25,500
Stilius yra tik kaip gerai
Ar jūsų kodas atrodo?

694
00:33:25,500 --> 00:33:26,600
Ir kaip skaitoma tai?

695
00:33:26,600 --> 00:33:29,650
>> Ir laikui bėgant, kas jūsų TAS
ir TFS darys kurso

696
00:33:29,650 --> 00:33:31,870
yra suteikti jums, kad
rūšies kokybinės grįžtamosios

697
00:33:31,870 --> 00:33:34,330
taip, kad jums geriau
tose įvairiais aspektais.

698
00:33:34,330 --> 00:33:37,510
O kalbant apie tai, kaip mes
įvertinti kiekvienas iš šių ašių,

699
00:33:37,510 --> 00:33:40,080
tai paprastai su labai mažai
kibirai, kad jūs, paprastai,

700
00:33:40,080 --> 00:33:41,680
gauti, kaip gerai jūs darote jausmą.

701
00:33:41,680 --> 00:33:45,680
Ir, iš tiesų, jei jūs gaunate rezultatą
bet iš tų axes-- teisingumą, dizainas

702
00:33:45,680 --> 00:33:49,659
ir stilius especially-- šis skaičius
paprastai bus tarp 1 ir 5.

703
00:33:49,659 --> 00:33:52,450
Ir tiesiog, jei jūs gaunate
3 At semestro pradžios,

704
00:33:52,450 --> 00:33:53,977
tai yra labai geras dalykas.

705
00:33:53,977 --> 00:33:55,810
Tai reiškia, kad vis dar
tobulinti,

706
00:33:55,810 --> 00:33:58,490
kurį būtų tikėtis iš
atsižvelgiant klasę pirmą kartą.

707
00:33:58,490 --> 00:34:01,820
Yra tikiuosi kai lubų tiek
prie kurio esate trokštantis pasiekti.

708
00:34:01,820 --> 00:34:03,970
Ir taip vis 3 spustelėjimas
Ankstyviausi gabalus,

709
00:34:03,970 --> 00:34:06,550
jei ne kai 2 "ir 4 s,
yra, iš tiesų, yra geras dalykas.

710
00:34:06,550 --> 00:34:08,880
Tai gerai zonoje,
gerai per lūkesčius.

711
00:34:08,880 --> 00:34:11,421
>> Ir jei jūsų protas yra lenktynių, palaukite
minutę, trys iš penkių.

712
00:34:11,421 --> 00:34:12,620
Tai tikrai 6 iš 10.

713
00:34:12,620 --> 00:34:13,560
Štai 60%.

714
00:34:13,560 --> 00:34:14,830
Mano Dieve, kad įvyko F.

715
00:34:14,830 --> 00:34:15,870
>> Tai nėra.

716
00:34:15,870 --> 00:34:17,600
Tai ne, iš tiesų, kad.

717
00:34:17,600 --> 00:34:22,710
Atvirkščiai, tai galimybė gerinti
per semestro metu.

718
00:34:22,710 --> 00:34:25,580
Ir jei jūs gaunate šiek tiek
Poors, tai yra galimybė

719
00:34:25,580 --> 00:34:29,199
pasinaudoti darbo valandomis,
neabejotinai skyriai ir kitus išteklius.

720
00:34:29,199 --> 00:34:32,840
>> Geriausia yra galimybė, tikrai,
didžiuotis, tik kiek jūs

721
00:34:32,840 --> 00:34:34,520
ateina per semestro metu.

722
00:34:34,520 --> 00:34:38,199
Taigi nereikia suprasti, jei nieko
kitur, trys yra gera.

723
00:34:38,199 --> 00:34:40,179
Ir tai leidžia vietos augimo per tam tikrą laiką.

724
00:34:40,179 --> 00:34:43,090
>> Kaip tie kirviai yra
svertinis, realiai esate

725
00:34:43,090 --> 00:34:46,745
ketina išleisti didžiąją dalį savo laiko gauti
dalykų į darbą, jau nekalbant apie neteisingai.

726
00:34:46,745 --> 00:34:49,120
Ir taip teisingumą linkęs
būti įvertintas labiausiai, kaip ir

727
00:34:49,120 --> 00:34:51,360
tai dauginamasis koeficientas trijų.

728
00:34:51,360 --> 00:34:54,659
Dizainas yra taip pat svarbu, bet
kažkas, kad jūs padaryti nebūtinai

729
00:34:54,659 --> 00:34:58,220
praleisti visus tuos valandas
bando gauti viskas tiesiog veikia.

730
00:34:58,220 --> 00:35:00,019
>> Ir todėl jis įvertintas
šiek tiek lengvesnės.

731
00:35:00,019 --> 00:35:01,560
Ir tada stilius įvertintos mažiausiai.

732
00:35:01,560 --> 00:35:03,710
Nors tai ne mažiau
svarbu iš esmės,

733
00:35:03,710 --> 00:35:05,990
tai tik, ko gero,
Paprasčiausias dalykas, tai teisinga,

734
00:35:05,990 --> 00:35:08,440
mėgdžiodami pavyzdžius mes
padaryti paskaitą ir skyriuje

735
00:35:08,440 --> 00:35:11,080
dalykų gražiai
įspaudžiami ir komentarų,

736
00:35:11,080 --> 00:35:14,320
ir tt yra vienas lengviausiai
ką daryti ir gauti teisę.

737
00:35:14,320 --> 00:35:16,960
Taigi, kaip, pavyzdžiui, suprasti,
kad tie, kurie taškai

738
00:35:16,960 --> 00:35:19,000
kad yra gana lengva suprasti.

739
00:35:19,000 --> 00:35:22,360
>> O dabar žodis
this-- akademinį sąžiningumą.

740
00:35:22,360 --> 00:35:25,150
Taigi už aikštyno
programa, pamatysite

741
00:35:25,150 --> 00:35:27,630
kad kursas turi gana
tiek kalba apie tai.

742
00:35:27,630 --> 00:35:31,380
Ir žinoma, mano klausimas,
akademinis sąžiningumas gana rimtai.

743
00:35:31,380 --> 00:35:33,450
>> Mes turime atskirti,
geriau ar blogiau,

744
00:35:33,450 --> 00:35:36,570
, kad jis išsiuntė kasmet daugiau
studentai dėl drausminių veiksmų

745
00:35:36,570 --> 00:35:39,670
nei dauguma bet kurios kitos
Žinoma, kad žinau.

746
00:35:39,670 --> 00:35:42,580
Tai nebūtinai
rodo tai,

747
00:35:42,580 --> 00:35:46,340
kad CS studentų, ar CS50 studentų, yra
bet mažiau sąžiningi, nei jūsų klasiokų.

748
00:35:46,340 --> 00:35:49,090
Tačiau realybė, kad tai
pasaulis, elektroniniu būdu, mes tiesiog

749
00:35:49,090 --> 00:35:50,990
turi technologijų
reiškia aptikti tai.

750
00:35:50,990 --> 00:35:53,360
>> Svarbu mums
teisingumas visoje klasėje

751
00:35:53,360 --> 00:35:58,550
kad mes aptikti tai ir pakelkite
klausimas, kai mes matome dalykus.

752
00:35:58,550 --> 00:36:01,980
Ir tik nupiešti piešinį, ir tikrai
padėti kažką panašaus į tai kriauklė,

753
00:36:01,980 --> 00:36:04,600
Šitie yra numeriai
studentai per pastaruosius 10 metų

754
00:36:04,600 --> 00:36:07,610
, kurie buvo įtraukti į kai
tokie klausimai akademinės sąžiningumo,

755
00:36:07,610 --> 00:36:10,990
su kai 32 studentų
nuo kritimo 2015, kuris

756
00:36:10,990 --> 00:36:13,760
yra pasakyti, kad mes imtis
klausimas labai rimtai.

757
00:36:13,760 --> 00:36:18,380
Ir, galiausiai, šie skaičiai rašyti,
labiausiai neseniai, apie 3%, 4%, arba tiek

758
00:36:18,380 --> 00:36:19,120
iš klasės.

759
00:36:19,120 --> 00:36:25,220
>> Taigi super dauguma studentų
atrodo, kad linijos yra aiškios.

760
00:36:25,220 --> 00:36:27,940
Bet tai turi būti
mind, ypač vėlai

761
00:36:27,940 --> 00:36:32,080
naktį, kai kovoja su
kai išspręsti problemą rinkinys,

762
00:36:32,080 --> 00:36:34,830
, kad turi priemonių
gauti sau geriau

763
00:36:34,830 --> 00:36:37,870
parama, nei jūs
manau, net tą pačią valandą.

764
00:36:37,870 --> 00:36:40,514
Suprantu, kad kai gausime
Studentų argumentai, mes kirsti

765
00:36:40,514 --> 00:36:43,430
palyginti kiekvieną pateikimo šiemet
prieš kiekvieną pateikimo pernai,

766
00:36:43,430 --> 00:36:47,590
prieš kiekvieną pateikimo nuo 2007
ir nuo, žiūri, taip pat,

767
00:36:47,590 --> 00:36:49,931
kodas saugyklų internete,
diskusijų forumai, darbo vietų.

768
00:36:49,931 --> 00:36:51,806
Ir mes paminėti,
tikrai, viskas vardan

769
00:36:51,806 --> 00:36:56,040
visiško atskleidimo, kad jei
kažkas gali rasti internete,

770
00:36:56,040 --> 00:36:57,880
tikrai, todėl mes galime kursas.

771
00:36:57,880 --> 00:37:00,100
Bet, tikrai, dvasia
Kurso suvesta

772
00:37:00,100 --> 00:37:01,650
į šią sąlygą į mokymo programą.

773
00:37:01,650 --> 00:37:03,670
Jis tikrai yra teisingas, pagrįstas.

774
00:37:03,670 --> 00:37:06,680
>> Ir jei mes turėjo parengti apie tai
tik su šiek tiek daugiau kalba,

775
00:37:06,680 --> 00:37:09,770
suprasti, kad visų esmė
darbas, kad jūs pateikti šį kursą

776
00:37:09,770 --> 00:37:10,954
turi būti jūsų pačių.

777
00:37:10,954 --> 00:37:13,870
Bet per Be to, yra žinoma,
galimybės ir skatinimas,

778
00:37:13,870 --> 00:37:17,300
pedagoginė vertė kreipiasi į
others-- save, TFS, CAS,

779
00:37:17,300 --> 00:37:20,760
kad TAS, ir kiti klasėje,
paramos, jau nekalbant apie draugus

780
00:37:20,760 --> 00:37:23,547
ir kambariokai, kurie mokėsi
AP ir programavimas anksčiau.

781
00:37:23,547 --> 00:37:25,130
Ir taip yra už tai pašalpa.

782
00:37:25,130 --> 00:37:28,180
Ir bendra taisyklė nykščio
yra this-- prašydami pagalbos,

783
00:37:28,180 --> 00:37:31,470
galite parodyti savo kodą su kitais,
bet negalite peržiūrėti savo.

784
00:37:31,470 --> 00:37:34,880
Taigi, net jei esate ne darbo valandomis,
arba D salėje, ar kur kitur

785
00:37:34,880 --> 00:37:37,450
darbo dėl kai kurių dalių rinkinys,
dirbti kartu su draugu, kuris

786
00:37:37,450 --> 00:37:40,160
yra visiškai gerai, ne
pabaigos dienos savo darbą

787
00:37:40,160 --> 00:37:43,034
galiausiai turėtų priklausyti kiekvienas
jus atitinkamai, o ne

788
00:37:43,034 --> 00:37:45,700
būti šiek tiek bendromis pastangomis,
išskyrus galutinio projektas, kuriame

789
00:37:45,700 --> 00:37:47,410
tai leidžiama ir skatinama.

790
00:37:47,410 --> 00:37:49,830
>> Suprantu, kad, jei esate
kovoja su kažkuo

791
00:37:49,830 --> 00:37:52,520
ir jūsų draugas tiesiog atsitinka
kad geriau tai tada tu,

792
00:37:52,520 --> 00:37:55,130
ar geriau tuo problema, nei jūs,
arba šiek tiek toliau į priekį nei jums,

793
00:37:55,130 --> 00:37:57,330
tai visiškai logiška paversti
savo draugui ir sako, ei,

794
00:37:57,330 --> 00:38:00,480
tu protas žiūri į mano kodas čia
padeda man vietoje, ką mano klausimas?

795
00:38:00,480 --> 00:38:03,760
Ir, tikiuosi, į
interesas pedagoginę vertę

796
00:38:03,760 --> 00:38:07,040
kad draugas ne tik
sako, oi, tai padaryti, bet,

797
00:38:07,040 --> 00:38:09,917
ką tu trūksta on-line
6, ar kažkas panašaus?

798
00:38:09,917 --> 00:38:12,000
Bet tirpalas yra ne
kitą draugas jums

799
00:38:12,000 --> 00:38:15,617
pasakyti, oi, gerai, čia, leiskite man traukti
tai aukštyn, ir parodyti savo sprendimą Jums.

800
00:38:15,617 --> 00:38:16,450
Taip, kad yra linija.

801
00:38:16,450 --> 00:38:18,670
Jūs parodyti savo kodą
kiti, bet jūs negalite

802
00:38:18,670 --> 00:38:22,350
peržiūrėti jų, atsižvelgiant į kitas
apribojimų aikštyno mokymo programą.

803
00:38:22,350 --> 00:38:24,760
>> Taigi, reikia nepamiršti šio
Vadinamasis apgailestauju sąlyga

804
00:38:24,760 --> 00:38:27,560
Be abejo anketa mokymo programas, taip pat,
kad jei jums įsipareigoja tam tikrą teisės aktą, kad

805
00:38:27,560 --> 00:38:30,476
nėra pagrindo, bet apie jį
kurso s vadovų dėmesys

806
00:38:30,476 --> 00:38:34,240
per 72 valandas, žinoma,
gali taikyti vietos sankcijas,

807
00:38:34,240 --> 00:38:37,380
gali būti nepakankamas arba
jei pažymys už pateiktą darbą.

808
00:38:37,380 --> 00:38:41,410
Bet žinoma, nebus perduoti
klausimas dėl tolesnio drausminių veiksmų,

809
00:38:41,410 --> 00:38:43,010
išskyrus atvejus, kai pakartotinai aktais.

810
00:38:43,010 --> 00:38:46,632
Kitaip tariant, jei jūs padaryti kai
kvaila, ypač vėlai naktį, sprendimas

811
00:38:46,632 --> 00:38:49,340
kad kitą rytą arba dvi dienas
vėliau, jums pabusti ir suprasti,

812
00:38:49,340 --> 00:38:50,870
kas buvo aš galvoju?

813
00:38:50,870 --> 00:38:53,890
Jūs padaryti CS50 turi lizdą
nustatant šią problemą

814
00:38:53,890 --> 00:38:57,170
ir turinti iki jo, taip, kad mes
jus pasitiks pusiaukelėje ir spręsti

815
00:38:57,170 --> 00:39:01,500
su juo į klausimą, kad yra tiek
švietimo ir vertinga už jus,

816
00:39:01,500 --> 00:39:04,200
bet vis baudinius tam tikru būdu.

817
00:39:04,200 --> 00:39:08,590
Ir dabar, imtis Naostrzyć, tai.

818
00:39:08,590 --> 00:39:10,570
>> [Vaizdo įrašų atkuriamų]

819
00:39:10,570 --> 00:39:13,540
>> [GROJA MUZIKA]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [PABAIGA PLAYBACK]

822
00:39:58,866 --> 00:40:00,490
David J. Malan: Gerai, mes atgal.

823
00:40:00,490 --> 00:40:03,680
Ir dabar mes žiūrime į vieną iš
Pirmasis mūsų realaus pasaulio domenų

824
00:40:03,680 --> 00:40:08,720
į CS50, kad kriptografija menas,
siuntimo ir gavimo menas

825
00:40:08,720 --> 00:40:11,840
slapti pranešimai, saugiame
pranešimus, jei norite,

826
00:40:11,840 --> 00:40:17,060
kad gali būti iššifruoti tik tada, jei turi
kai pagrindinis ingredientas, kad siuntėjas turi

827
00:40:17,060 --> 00:40:18,030
taip pat.

828
00:40:18,030 --> 00:40:22,120
Taigi, norint motyvuoti tai mes priimsime
Žvilgsnis šio dalyko čia

829
00:40:22,120 --> 00:40:26,750
kuris yra iš A pavyzdys
Paslaptis dekoderis žiedas,

830
00:40:26,750 --> 00:40:34,042
gali būti naudojamas tam, kad išsiaiškinti
kas paslaptis žinutė iš tikrųjų yra.

831
00:40:34,042 --> 00:40:35,750
Iš tiesų, atgal į
dieną pradinėje mokykloje,

832
00:40:35,750 --> 00:40:38,787
jei kada nors išsiųsti slaptas žinutes
kai draugas ar kai klasėje traiškyti,

833
00:40:38,787 --> 00:40:40,620
jums gali turėti minties
Jums buvo yra protingas

834
00:40:40,620 --> 00:40:46,530
pagal savo gabalas popieriaus keičiasi,
kaip, nuo A iki B, ir B C, ir C-D,

835
00:40:46,530 --> 00:40:47,590
ir taip toliau.

836
00:40:47,590 --> 00:40:50,300
Bet jūs iš tikrųjų buvo šifravimo
jūsų informacija, net

837
00:40:50,300 --> 00:40:53,300
jei ji buvo šiek tiek nereikšmingas, nebuvo
kad sunku mokytojas suprasti,

838
00:40:53,300 --> 00:40:55,675
Na, jei jūs tiesiog pakeisti
B-A ir C į B,

839
00:40:55,675 --> 00:40:57,550
jūs iš tikrųjų išsiaiškinti,
ką žinia buvo,

840
00:40:57,550 --> 00:40:59,700
bet jums buvo kodavimo informaciją.

841
00:40:59,700 --> 00:41:03,420
>> Jūs buvote tiesiog tai daro
tiesiog, panašiai kaip Ralphie čia

842
00:41:03,420 --> 00:41:07,934
garsaus filmo, kuris vaidina
gana daug Argumentas iš kartojimo kiekvieną žiemą.

843
00:41:07,934 --> 00:41:08,600
[Vaizdo įrašų atkuriamų]

844
00:41:08,600 --> 00:41:11,180
-Be To žinoma, kad visa tai
Ralph Parkeris yra iš dalies

845
00:41:11,180 --> 00:41:14,070
paskirtas Little narys
Našlaitė Annie paslaptis Draugų

846
00:41:14,070 --> 00:41:17,700
ir ji turi teisę į visas pagyrimu
ir nauda pasireiškia tuo.

847
00:41:17,700 --> 00:41:24,340
>> -Signed Little Našlaitė Annie,
Skaitliukas pasirašė Pjeras André rašalu.

848
00:41:24,340 --> 00:41:27,160
Garbės ir naudą,
jau esant devynių amžiaus.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Šaukti]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Nagi.

853
00:41:34,250 --> 00:41:35,210
Leiskite gauti su juo.

854
00:41:35,210 --> 00:41:39,530
Man nereikia visą tą džiazą
apie kontrabandininkus ir piratai.

855
00:41:39,530 --> 00:41:41,660
>> -Listen Rytoj naktį
baigiamasis nuotykių

856
00:41:41,660 --> 00:41:43,880
juodo piratų laivą.

857
00:41:43,880 --> 00:41:46,650
Dabar atėjo laikas
Annie paslaptis žinutė

858
00:41:46,650 --> 00:41:49,840
Jums nariai Slaptas ratas.

859
00:41:49,840 --> 00:41:53,570
Atminkite, kad vaikams, tik nariai
Annie Secret Circle

860
00:41:53,570 --> 00:41:56,140
gali dekoduoti Annie slaptą žinutę.

861
00:41:56,140 --> 00:42:00,340
>> Įsiminti Annie priklauso nuo jūsų.

862
00:42:00,340 --> 00:42:02,880
Nustatykite savo smeigtukai B2.

863
00:42:02,880 --> 00:42:05,230
Čia yra žinia.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Aš Esu, mano pirmasis slaptą susitikimą.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Buvo labai balso vakarą.

868
00:42:15,780 --> 00:42:19,000
Galėčiau pasakyti, kad vakaro
žinutė buvo tikrai svarbus.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, tai pranešimas
nuo Annie save.

870
00:42:22,694 --> 00:42:23,860
Atminkite, kad nereikia niekam.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> vėliau -90 sekundžių, aš tik
kambarys name, kuriame iš devynių berniukas

873
00:42:32,930 --> 00:42:37,040
gali sėdėti privatumo ir iššifruoti.

874
00:42:37,040 --> 00:42:39,730
Aha B!

875
00:42:39,730 --> 00:42:42,360
Nuėjau į kitą, E.

876
00:42:42,360 --> 00:42:44,520
>> Pirmas žodis yra būti.

877
00:42:44,520 --> 00:42:49,032
S, tai buvo dar lengviau dabar, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> -OH, Nagi, Ralphie, aš turiu eiti!

879
00:42:51,733 --> 00:42:53,688
>> -I'll Būti nustatančio teisę Ma!

880
00:42:53,688 --> 00:42:54,188
Gee nusišvilpti!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> T, P, būtinai to-- būtinai ką?

883
00:43:04,060 --> 00:43:05,970
Kas buvo mažai Našlaitė
Annie bando pasakyti?

884
00:43:05,970 --> 00:43:07,264
Būtinai ką?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie Andy pateko
eiti, jūs galite išeiti?

886
00:43:09,634 --> 00:43:10,480
>> -Visa Teisę Ma!

887
00:43:10,480 --> 00:43:12,880
Aš būsiu teisus ne!

888
00:43:12,880 --> 00:43:14,550
>> -Aš Buvo vis arčiau dabar.

889
00:43:14,550 --> 00:43:16,620
Įtampa buvo baisi.

890
00:43:16,620 --> 00:43:17,720
Kas tai buvo?

891
00:43:17,720 --> 00:43:20,170
Planetos likimas
gali pakabinti ant plauko.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy gotta go!

894
00:43:23,170 --> 00:43:26,890
>> -I'll Būti tiesiai iš, šaukė garsiai!

895
00:43:26,890 --> 00:43:32,680
>> -Almost Ten, mano pirštai skrido, mano protas
buvo plieno gaudyklė, kiekvienas porų vibravo.

896
00:43:32,680 --> 00:43:37,198
Tai buvo beveik aišku, taip, taip, taip.

897
00:43:37,198 --> 00:43:43,091
>> -Be Būtinai gerti savo Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Prastas komercinis?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Šunsnukis.

903
00:43:54,227 --> 00:43:54,810
[PABAIGA PLAYBACK]

904
00:43:54,810 --> 00:43:57,390
David J. Malan: Gerai, kad
Tai buvo labai ilgas kelias

905
00:43:57,390 --> 00:44:00,660
įvesti kriptografiją,
ir taip pat Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Iš tiesų, iš šio seno skelbimą
čia, tai kodėl Ovaltine taip gerai?

907
00:44:04,470 --> 00:44:09,470
Ji yra koncentruotas ekstrakcija prinokę
miežių salyklas, grynas riebus karvės pienas,

908
00:44:09,470 --> 00:44:14,360
ir specialiai paruošti kakavos, kartu
su gamtos fosfatidų ir vitaminų.

909
00:44:14,360 --> 00:44:18,240
Be to, yra prisotintas
papildomas vitaminų B ir D, Yum.

910
00:44:18,240 --> 00:44:21,600
Ir jūs vis dar galite gauti jį, matyt,
"Amazon", kaip mes čia padarė.

911
00:44:21,600 --> 00:44:24,810
>> Tačiau motyvacija čia buvo
pristatyti kriptografiją, ypač

912
00:44:24,810 --> 00:44:28,340
iš kriptografija tipas žinomas
kaip slaptą rakto kriptografija.

913
00:44:28,340 --> 00:44:34,284
Ir kaip rodo pavadinimas, visos
saugumas slaptą rakto kriptografija sistemos

914
00:44:34,284 --> 00:44:36,200
jei bus, metodika
tik už kodavimo

915
00:44:36,200 --> 00:44:40,960
informacija tarp dviejų žmonių, yra tai, kad
tik siuntėjas ir tik gavėjas

916
00:44:40,960 --> 00:44:46,980
žinoti slaptą key-- tam tikrą vertę, kai
Paslaptis frazė, kai paslaptis numerį, kad

917
00:44:46,980 --> 00:44:50,660
leidžia jiems tiek šifravimo
ir iššifruoti informaciją.

918
00:44:50,660 --> 00:44:53,470
Ir kriptografija, tikrai,
yra tik tai nuo 0 savaitės.

919
00:44:53,470 --> 00:44:56,715
>> Tai problema, kur yra įėjimai,
kaip faktinio pranešimą anglų kalba

920
00:44:56,715 --> 00:44:59,340
ar kokia kalba, kuri jums
norite siųsti kažkam klasėje,

921
00:44:59,340 --> 00:45:00,580
arba per internetą.

922
00:45:00,580 --> 00:45:03,840
Yra kai kurių produkcija, kuri vyksta
būti koduotus pranešimą, kad jums

923
00:45:03,840 --> 00:45:05,250
noriu gavėjas gauti.

924
00:45:05,250 --> 00:45:07,405
Ir net jei kas nors
viduryje jį gauna per,

925
00:45:07,405 --> 00:45:09,780
nenorite juos
nebūtinai galėtų jį iššifruoti,

926
00:45:09,780 --> 00:45:12,840
nes vidinės tai
juoda dėžutė, arba algoritmas,

927
00:45:12,840 --> 00:45:17,650
yra kai mechanizmas, kai žingsnis po žingsnio
instrukcijos, skirtos imtis, kad pirkimo

928
00:45:17,650 --> 00:45:20,710
ir konvertuoti jį į
rodmenys tikiuosi saugiai.

929
00:45:20,710 --> 00:45:23,640
>> Ir, iš tiesų, yra keletas
žodynas šiame pasaulyje taip.

930
00:45:23,640 --> 00:45:26,100
Paprastas tekstas yra žodis
kompiuterių mokslininkas būtų

931
00:45:26,100 --> 00:45:28,449
naudoti apibūdinti įvestį
žinutė, kaip ir anglų kalba

932
00:45:28,449 --> 00:45:31,240
ar kokia kalba jūs iš tikrųjų
norite siųsti į kitą žmogų.

933
00:45:31,240 --> 00:45:35,450
Ir tada ciphertext yra peštynės
į užšifruota arba užšifruoti,

934
00:45:35,450 --> 00:45:36,520
jos versija.

935
00:45:36,520 --> 00:45:38,750
>> Bet yra vienas kitas ingredientas čia.

936
00:45:38,750 --> 00:45:43,200
Yra vienas kitas įvestis
Paslaptis rakto kriptografija.

937
00:45:43,200 --> 00:45:45,200
Ir, kad yra pati raktas,
kuris yra, paprastai,

938
00:45:45,200 --> 00:45:48,930
kaip matysime, skaičius, arba
laiškas arba žodis, nesvarbu, kokia

939
00:45:48,930 --> 00:45:51,980
algoritmas yra iš tikrųjų tikisi.

940
00:45:51,980 --> 00:45:53,870
>> Ir kaip jums iššifruoti informaciją?

941
00:45:53,870 --> 00:45:55,110
Kaip jūs ją Rozszyfrować?

942
00:45:55,110 --> 00:45:57,950
Na, jūs tiesiog pakeisti šią
išėjimai ir įėjimai.

943
00:45:57,950 --> 00:46:00,900
>> Kitaip tariant, vieną kartą kas nors
gauna šifruotą pranešimą,

944
00:46:00,900 --> 00:46:03,740
jis ar ji tiesiog turi
žinoti, kad tas pats raktas.

945
00:46:03,740 --> 00:46:05,700
Jie gavo ciphertext.

946
00:46:05,700 --> 00:46:09,530
Ir įkišant šių dviejų
įėjimai į šifravimo sistema,

947
00:46:09,530 --> 00:46:14,260
algoritmas, tai juoda dėžutė, iš
turėtų ateiti originalų paprastojo.

948
00:46:14,260 --> 00:46:17,830
Ir taip tai labai aukšto lygio
vaizdas, kas kriptografija yra iš tikrųjų

949
00:46:17,830 --> 00:46:18,590
Viskas apie.

950
00:46:18,590 --> 00:46:20,030
>> Taigi galime gauti ten.

951
00:46:20,030 --> 00:46:22,700
Leiskite dabar atrodo po
kažko gaubtas

952
00:46:22,700 --> 00:46:26,000
mes jau vartojate už suteikiamas
praėjusią savaitę ir šios sesijos

953
00:46:26,000 --> 00:46:27,629
here-- eilutę.

954
00:46:27,629 --> 00:46:30,295
Eilutė, tuo dienos pabaigoje
yra tik ženklų seka.

955
00:46:30,295 --> 00:46:33,610
>> Tai gali būti hello world arba
Sveiki Zamyla, ar kas.

956
00:46:33,610 --> 00:46:37,050
Bet ką tai reiškia
būti simbolių seka?

957
00:46:37,050 --> 00:46:41,520
Tiesą sakant, CS50 biblioteka suteikia
mums duomenų tipas vadinamas eilutė.

958
00:46:41,520 --> 00:46:45,140
>> Bet iš tikrųjų nėra
toks dalykas kaip C eilutę

959
00:46:45,140 --> 00:46:49,450
Tai tikrai yra tik seka
charakteris, charakteris, charakteris,

960
00:46:49,450 --> 00:46:52,180
charakteris, nugaros, atgal, į
atgal, atgal, atgal viduje

961
00:46:52,180 --> 00:46:54,650
jūsų kompiuterio atmintyje, ar atminties.

962
00:46:54,650 --> 00:46:58,940
Ir mes pažvelgti giliau į, kad
ateityje, kai mes žiūrime į pačią atmintį,

963
00:46:58,940 --> 00:47:02,030
ir panaudojimo, ir
grėsmės, kurios dalyvauja.

964
00:47:02,030 --> 00:47:04,100
>> Bet tegul mano eilutę Zamyla.

965
00:47:04,100 --> 00:47:07,480
Taigi tiesiog iš vardas
žmogaus čia Zamyla,

966
00:47:07,480 --> 00:47:12,030
kad yra seka
simbolių, Ž-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
O dabar tarkime, kad Zamyla vardas
yra saugomas viduje kompiuterio

968
00:47:16,020 --> 00:47:16,880
programa.

969
00:47:16,880 --> 00:47:20,830
>> Na, tai suprantama, kad mes turėtume
gebėti pažvelgti į tų ženklų

970
00:47:20,830 --> 00:47:21,590
atskirai.

971
00:47:21,590 --> 00:47:24,710
Taigi, aš tik ketina padaryti šiek tiek
Lauke aplink Zamyla vardo čia.

972
00:47:24,710 --> 00:47:31,580
Ir tai yra C atvejis, kai jūs
turėti eilutę, pavyzdžiui, Zamyla-- o gal

973
00:47:31,580 --> 00:47:34,940
kad seka grįžo iš
funkcija kaip get eilutę,

974
00:47:34,940 --> 00:47:38,540
jūs iš tikrųjų galite manipuliuoti
tai charakteris pagal charakterį.

975
00:47:38,540 --> 00:47:42,070
>> Dabar, tai yra Germane už
pokalbis vertus, dėl

976
00:47:42,070 --> 00:47:46,420
į kriptografiją, jei norite pakeisti
Nuo A iki B, ir B C, ir C-D,

977
00:47:46,420 --> 00:47:49,650
ir taip toliau, reikia, kad būtų galima
pažvelgti į atskirus simbolius

978
00:47:49,650 --> 00:47:50,190
į eilutę.

979
00:47:50,190 --> 00:47:52,695
Jums reikia, kad būtų galima pakeisti
Z į ką nors kita, A

980
00:47:52,695 --> 00:47:55,280
kažką kitam, M
kažkas, ir pan.

981
00:47:55,280 --> 00:47:58,000
Ir todėl mes turime būdą,
programiškai, todėl

982
00:47:58,000 --> 00:48:03,020
sakant, C, kad būtų galima pakeisti
ir pažvelgti atskirų raidžių.

983
00:48:03,020 --> 00:48:05,690
Ir mes galime tai padaryti taip.

984
00:48:05,690 --> 00:48:08,340
>> Leiskite man eiti galvą atgal į CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Ir leiskite man eiti į priekį
ir sukurti naują failą

986
00:48:11,130 --> 00:48:16,134
kad aš tai vadina laiko string0,
kaip mūsų pirmojo tokio Pavyzdžiui, dot c.

987
00:48:16,134 --> 00:48:18,300
Ir aš ruošiuosi eiti į priekį
ir plakti jį taip.

988
00:48:18,300 --> 00:48:22,870
>> Taigi yra CS50.h ir
tada apima standartinį io.h,

989
00:48:22,870 --> 00:48:25,990
kurios aš beveik visada vyksta
būti naudojant mano programų, bent jau

990
00:48:25,990 --> 00:48:26,780
pradžių.

991
00:48:26,780 --> 00:48:32,180
int main negaliojančiu, o tada čia aš
ketinate daryti eilutes gauna gauti eilutę.

992
00:48:32,180 --> 00:48:35,260
Ir tada aš ruošiuosi
eiti į priekį ir tai padaryti.

993
00:48:35,260 --> 00:48:37,460
Noriu eiti į priekį
ir, kaip normalumas patikrinti,

994
00:48:37,460 --> 00:48:43,607
tiesiog pasakyti, labas, proc s
kabliataškis, daro eilutę 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, ką aš padaryti čia?

996
00:48:44,690 --> 00:48:45,930
Ech, man nebuvo prijunkite jį.

997
00:48:45,930 --> 00:48:48,120
Taigi pamoka, kad
nebuvo tyčinis.

998
00:48:48,120 --> 00:48:52,480
>> Taigi klaida, daugiau procentų
konversijų nei duomenų argumentais.

999
00:48:52,480 --> 00:48:54,940
Ir tai yra, kai,
linija 7-- Gerai, kad turiu,

1000
00:48:54,940 --> 00:48:56,690
citata citatos pabaiga, tai
mano string printf.

1001
00:48:56,690 --> 00:48:58,151
Aš turiu procentų ženklas.

1002
00:48:58,151 --> 00:48:59,650
Bet aš trūksta antrojo argumento.

1003
00:48:59,650 --> 00:49:03,190
>> Aš trūksta kablelio s, kuri
Aš turėti ankstesniuose pavyzdžiuose.

1004
00:49:03,190 --> 00:49:06,650
Taigi gera proga pataisyti
dar viena klaida, netyčia.

1005
00:49:06,650 --> 00:49:09,950
O dabar leiskite man paleisti
string0, tipo Zamyla.

1006
00:49:09,950 --> 00:49:10,970
Gerai, labas Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Taigi mes paleisti šią programą natūra
keletas skirtingų kartų dabar.

1008
00:49:14,144 --> 00:49:16,310
Bet darykime kažką
tiek skiriasi šį kartą.

1009
00:49:16,310 --> 00:49:19,450
Užuot tiesiog spausdinti Zamyla s
Visas pavadinimas out su printf,

1010
00:49:19,450 --> 00:49:21,350
Darom charakterį pobūdžio.

1011
00:49:21,350 --> 00:49:22,700
>> Aš ruošiuosi naudoti už kilpa.

1012
00:49:22,700 --> 00:49:26,160
Ir aš ruošiuosi duoti save
suskaičiavimo kintamasis, vadinama i.

1013
00:49:26,160 --> 00:49:33,530
Ir aš ruošiuosi laikyti Iteracja, todėl
tol, kol i yra mažiau nei s ilgio.

1014
00:49:33,530 --> 00:49:35,930
>> Pasirodo, mes ne
tai padaryti paskutinį kartą,

1015
00:49:35,930 --> 00:49:39,100
kad c ateina su
funkcija vadinama Stirling.

1016
00:49:39,100 --> 00:49:42,690
Atgal į dieną, ir apskritai
dar kai įgyvendinant funkcijas,

1017
00:49:42,690 --> 00:49:45,405
žmonės dažnai pasirenka labai
glausti vardai, garso natūra

1018
00:49:45,405 --> 00:49:48,280
patinka tai, ką norite, nors tai
trūksta kelių balsių ar raides.

1019
00:49:48,280 --> 00:49:50,660
Taigi Stirlingas yra
Pavadinimas funkcija, kuri

1020
00:49:50,660 --> 00:49:53,880
užima tarp argumentą
skliaustai, kad turėtų būti eilutė.

1021
00:49:53,880 --> 00:49:56,910
Ir tai tik grąžina sveikąjį skaičių,
šios eilutės ilgis.

1022
00:49:56,910 --> 00:50:00,580
>> Taigi, tai už kilpa 7 eilutėje vyksta
pradėti skaičiuoti ne aš lygus 0.

1023
00:50:00,580 --> 00:50:02,530
Ji ketina prieaugio
Aš ant kiekvienos iteracijos

1024
00:50:02,530 --> 00:50:04,350
1, kaip mes darome kelis kartus.

1025
00:50:04,350 --> 00:50:06,780
Bet jis ketina padaryti tik
tai iki taško,

1026
00:50:06,780 --> 00:50:09,660
kai i ilgis
pačios eilutę.

1027
00:50:09,660 --> 00:50:14,520
>> Taigi tai yra būdas, galiausiai,
Iteracja per simbolių

1028
00:50:14,520 --> 00:50:17,430
į eilutę, kaip yra taip.

1029
00:50:17,430 --> 00:50:20,670
Aš ruošiuosi atsispausdinti nėra
Visa eilutė, bet procentai C

1030
00:50:20,670 --> 00:50:22,860
vienas simbolis
po to naujos linijos.

1031
00:50:22,860 --> 00:50:24,880
Ir tada aš ruošiuosi
eiti į priekį, ir man reikia

1032
00:50:24,880 --> 00:50:29,080
pasakyti, kad aš noriu spausdinti
-osios pobūdis s.

1033
00:50:29,080 --> 00:50:33,450
>> Taigi, jei aš yra kintamasis, kuris nurodo
eilutės, kur indeksas

1034
00:50:33,450 --> 00:50:37,230
jūs į jį, man reikia, kad būtų galima
sako, duok man i-tojo požymio s.

1035
00:50:37,230 --> 00:50:40,390
C turi daryti taip, kaip
tai su laužtiniuose skliaustuose.

1036
00:50:40,390 --> 00:50:43,679
Jūs galite tiesiog ištarkite vardą
eilutė, kuri šiuo atveju yra S.

1037
00:50:43,679 --> 00:50:46,970
Tada jums naudoti skliaustus,, kurie yra
paprastai virš grąžą arba įveskite

1038
00:50:46,970 --> 00:50:48,110
klaviatūros klavišą.

1039
00:50:48,110 --> 00:50:52,410
Ir tada jūs įtraukėte indekso
charakteris, kurį norite spausdinti.

1040
00:50:52,410 --> 00:50:55,960
Taigi indeksas ketina būti
number-- 0, arba 1, arba 2, arba 3, arba taškas,

1041
00:50:55,960 --> 00:50:57,590
taškas, taškas, kai kurių kitų skaičių.

1042
00:50:57,590 --> 00:51:00,920
>> Ir galime užtikrinti, kad jis ketina
būtų teisingas skaičių, nes aš

1043
00:51:00,920 --> 00:51:02,360
pradėti skaičiuoti 0.

1044
00:51:02,360 --> 00:51:07,020
Ir pagal nutylėjimą, pirmasis simbolis
į eilutę pagal susitarimą 0.

1045
00:51:07,020 --> 00:51:09,230
Ir antra charakteris yra laikiklis 1.

1046
00:51:09,230 --> 00:51:11,120
Ir trečia charakteris yra laikiklis 2.

1047
00:51:11,120 --> 00:51:13,630
Ir jūs nenorite eiti per
toli, bet mes ne todėl, kad mes

1048
00:51:13,630 --> 00:51:17,780
vyksta tik prieaugio i tol, kol jis
yra lygus Eiluė.

1049
00:51:17,780 --> 00:51:20,210
Ir kuri vieta,
tai už kilpa sustos.

1050
00:51:20,210 --> 00:51:25,550
>> Taigi leiskite man eiti į priekį ir sutaupyti tai
programa, ir paleisti padaryti eilutę 0.

1051
00:51:25,550 --> 00:51:28,400
Bet aš įsukus.

1052
00:51:28,400 --> 00:51:35,390
Netiesiogiai teigiama bibliotekos funkcija
Stirling su tokio tipo, ir such-- dabar

1053
00:51:35,390 --> 00:51:36,430
tai skamba pažįstamai.

1054
00:51:36,430 --> 00:51:37,440
Bet tai ne printf.

1055
00:51:37,440 --> 00:51:38,540
Ir tai ne gauti eilutę.

1056
00:51:38,540 --> 00:51:40,480
>> Aš ne susukti į
taip pat, šį kartą.

1057
00:51:40,480 --> 00:51:45,100
Tačiau pastebėti žemyn čia truputį žemyn
Be to, yra antraštės string.h,

1058
00:51:45,100 --> 00:51:47,210
aiškiai teikti
deklaracija Stirling.

1059
00:51:47,210 --> 00:51:48,820
Taigi yra iš tikrųjų ten raktas.

1060
00:51:48,820 --> 00:51:51,670
>> Ir iš tiesų paaiškėja,
yra ir kitas antraštės failą

1061
00:51:51,670 --> 00:51:53,970
kad mes ne naudoti
klasėje, bet tai

1062
00:51:53,970 --> 00:51:56,480
tarp tų, galima
Jums, vadinamas string.h.

1063
00:51:56,480 --> 00:52:00,930
Ir į tą bylą, string.h
yra Stirlingo deklaruoti.

1064
00:52:00,930 --> 00:52:05,220
Taigi leiskite man eiti į priekį ir
išsaugoti tai, kad seka

1065
00:52:05,220 --> 00:52:08,040
0-- gražus, jokių klaidų pranešimai šįkart.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla ir
Aš apie paspauskite Enter,

1067
00:52:12,290 --> 00:52:16,710
už kurią getstring taškas vyksta
grįžti eilutę, įdėti jį į s.

1068
00:52:16,710 --> 00:52:21,890
Tada, kad kilpa ketina pakartoti
per s įtrauktas į simbolių vienu metu,

1069
00:52:21,890 --> 00:52:28,420
ir spausdinti juos po vieną eilutėje, nes
Turėjau tą backslash n pabaigoje.

1070
00:52:28,420 --> 00:52:34,530
Taigi galėčiau praleisti tą kairinį brūkšnį,
N, o tada tiesiog atsispausdinti Zamyla visi

1071
00:52:34,530 --> 00:52:37,460
toje pačioje eilutėje,
efektyviai reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, kuris yra ne visi, kad naudinga.

1073
00:52:38,999 --> 00:52:40,540
Tačiau šiuo atveju, aš ne padaryti.

1074
00:52:40,540 --> 00:52:43,610
Aš faktiškai atspausdinta vieną
simbolis vienu metu, po vieną kiekvienoje eilutėje,

1075
00:52:43,610 --> 00:52:45,400
taip, kad mes iš tikrųjų pamatyti poveikį.

1076
00:52:45,400 --> 00:52:46,900
>> Bet man reikia atkreipti dėmesį į vieną dalyką čia.

1077
00:52:46,900 --> 00:52:48,930
Ir mes grįžti į
tai ateityje savaitę.

1078
00:52:48,930 --> 00:52:52,650
Pasirodo, kad tai
kodas yra potencialiai Buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Pasirodo, kad gauti eilutę
ir kai kurių kitų funkcijų gyvenime

1080
00:52:56,560 --> 00:53:00,280
nebūtinai visada
grįžti, ką jūs laukiate.

1081
00:53:00,280 --> 00:53:03,010
Mes žinome iš klasės paskutinio
Laikas tai, kad gauti

1082
00:53:03,010 --> 00:53:04,960
eilutė turėtų grįžti eilutę.

1083
00:53:04,960 --> 00:53:09,900
Bet kas, jei vartotojas įveda tokias
ilgas žodis arba dalis, ar esė

1084
00:53:09,900 --> 00:53:13,010
kad ten tiesiog nėra pakankamai
atminties į kompiuterį, kad tilptų jį.

1085
00:53:13,010 --> 00:53:15,410
>> Kaip, kas, jei kažkas
negerai po gaubtu?

1086
00:53:15,410 --> 00:53:18,400
Tai gali neįvyks dažnai
bet tai gali atsitikti, kai

1087
00:53:18,400 --> 00:53:21,520
kartais, labai retai.

1088
00:53:21,520 --> 00:53:25,460
Ir taip it turns out, kad gauti eilutę
ir funkcijas, pavyzdžiui, jį nebūtinai

1089
00:53:25,460 --> 00:53:26,380
visada grįžti eilutes.

1090
00:53:26,380 --> 00:53:30,680
Jie gali grįžti šiek tiek klaidos reikšmę,
kai Sentinel vertė taip sakant,

1091
00:53:30,680 --> 00:53:32,612
kad rodo, kad
kažkas negerai.

1092
00:53:32,612 --> 00:53:35,320
Ir jūs žinote, tik tai iš
išmokus ją klasėje dabar

1093
00:53:35,320 --> 00:53:37,700
arba perskaitęs šiek tiek daugiau dokumentaciją.

1094
00:53:37,700 --> 00:53:43,120
Pasirodo, kad gauti eilutę
gali grįžti vertę, vadinamą niekinis.

1095
00:53:43,120 --> 00:53:46,220
Null yra speciali reikšmė, mes
grįžti į būsimame savaitę.

1096
00:53:46,220 --> 00:53:50,420
Bet dabar, tiesiog žinau, kad jei aš noriu
būtų tikrai teisingas juda į priekį

1097
00:53:50,420 --> 00:53:52,650
naudojant get eilutę, aš
turėtų būti ne tik jį vadiname,

1098
00:53:52,650 --> 00:53:56,870
ir aklai naudotis savo grąžos vertę,
pasitikėti, kad tai eilutė.

1099
00:53:56,870 --> 00:53:59,420
>> Aš pirmą kartą reikia pasakyti,
Ei, palauk, tik

1100
00:53:59,420 --> 00:54:03,380
elgtis, jei -ai nėra lygi
nulis, kur nulis, vėl,

1101
00:54:03,380 --> 00:54:04,660
yra tik keletas ypatingą vertę.

1102
00:54:04,660 --> 00:54:07,770
Ir tai tik ypatinga vertė, kurią
reikia nerimauti Get eilutę.

1103
00:54:07,770 --> 00:54:10,900
Gauk eilutė arba vyksta
grįžti eilutę arba null.

1104
00:54:10,900 --> 00:54:17,219
>> Ir tai šauktukas lygus ženklą
žinote iš gal matematikos klasės

1105
00:54:17,219 --> 00:54:20,510
kad jūs galite padaryti lygybės ženklą su
linija per jį rodo ne vienoda.

1106
00:54:20,510 --> 00:54:23,135
Tai ne apskritai simbolis
galite įvesti klaviatūroje.

1107
00:54:23,135 --> 00:54:26,480
Ir taip daugelyje programavimo kalbų,
kai norite pasakyti ne lygūs,

1108
00:54:26,480 --> 00:54:29,160
naudoti šauktuką,
kitaip žinomas kaip trenksmu.

1109
00:54:29,160 --> 00:54:33,180
Taigi jūs sakote sprogimo lygi, kuris
reiškia ne lygus, logiškai.

1110
00:54:33,180 --> 00:54:38,060
Tai kaip ten ne didesnė
nei arba lygus arba mažesnis nei

1111
00:54:38,060 --> 00:54:41,270
arba lygus klaviatūros klavišą
kad visa tai vienoje simboliu.

1112
00:54:41,270 --> 00:54:44,020
Štai kodėl, pastaruosius pavyzdžių,
tu atvirą laikiklį, tada

1113
00:54:44,020 --> 00:54:48,670
lygybės ženklas, tam, kad padaryti
didesnis nei arba, tarkim, mažiau nei.

1114
00:54:48,670 --> 00:54:49,910
>> Taigi, kas yra Takeaway čia?

1115
00:54:49,910 --> 00:54:53,880
Tai tiesiog būdas dabar ir
įvedant šią sintaksę, ši funkcija,

1116
00:54:53,880 --> 00:54:57,390
Iteracja individualios
simbolių eilutę.

1117
00:54:57,390 --> 00:55:00,260
Ir kaip tas kvadratas
kronšteinai leidžia jums gauti į juos,

1118
00:55:00,260 --> 00:55:03,790
atsižvelgti į tas skliaustus, kaip
rūšies užuomina į tai pagrindinis

1119
00:55:03,790 --> 00:55:06,040
dizainas, pagal kurią kiekvienas
simbolių viduje eilutę

1120
00:55:06,040 --> 00:55:10,180
rūšies supakuota kažkur po
Į kompiuterio atmintį gaubtu.

1121
00:55:10,180 --> 00:55:12,340
>> Bet tegul padaryti šį variantą.

1122
00:55:12,340 --> 00:55:14,880
Pasirodo, kad tai
programa yra teisinga.

1123
00:55:14,880 --> 00:55:18,810
Taigi už CS50 anketa ašių įvertinti
kodas, tai yra teisinga dabar.

1124
00:55:18,810 --> 00:55:22,959
Ypač dabar, kad aš tikrinti
niekinis, ši programa turėtų niekada avariją.

1125
00:55:22,959 --> 00:55:24,500
Ir aš tiesiog žinau, kad iš patirties.

1126
00:55:24,500 --> 00:55:28,040
Bet ten nieko, kad
mes tikrai gali suklysti čia.

1127
00:55:28,040 --> 00:55:31,860
Bet tai nėra labai gerai suprojektuoti,
nes grįžkime prie pagrindo.

1128
00:55:31,860 --> 00:55:34,450
>> Pirma, principles--
Ką for ciklas daryti?

1129
00:55:34,450 --> 00:55:36,290
A kilpą daro tris dalykus.

1130
00:55:36,290 --> 00:55:39,340
Ji inicijuoja kai
vertė, jei jūs paprašykite jį.

1131
00:55:39,340 --> 00:55:41,770
Jis tikrina sąlygą.

1132
00:55:41,770 --> 00:55:45,380
Ir tada po kiekvieno
iteracijos, po kiekvieno ciklo

1133
00:55:45,380 --> 00:55:49,330
tai padidina kai
vertė, ar vertės, čia.

1134
00:55:49,330 --> 00:55:50,600
>> Taigi, ką tai reiškia?

1135
00:55:50,600 --> 00:55:52,940
Mes inicijuoti i 0.

1136
00:55:52,940 --> 00:55:58,610
Mes tikriname ir įsitikinkite, kad i yra mažiau nei
jei S ilgis, kuris yra Ž-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
taip, kuris yra mažesnis nei 6.

1138
00:55:59,900 --> 00:56:02,590
Ir, tiesą sakant, 0 kaip mažiau kaip 6.

1139
00:56:02,590 --> 00:56:05,580
>> Mes atsispausdinti Z nuo Zamyla vardu.

1140
00:56:05,580 --> 00:56:08,080
Tada mes prieaugio i nuo 0 iki 1.

1141
00:56:08,080 --> 00:56:11,290
Tada patikrinkite, yra 1 mažiau
nei s ilgio?

1142
00:56:11,290 --> 00:56:13,270
Iš s ilgis yra 6.

1143
00:56:13,270 --> 00:56:13,950
Taip tai yra.

1144
00:56:13,950 --> 00:56:16,880
>> Taigi, mes atspausdinti per Zamyla vardą, ZA.

1145
00:56:16,880 --> 00:56:20,090
Mes prieaugio i nuo 0, 1, iki 2.

1146
00:56:20,090 --> 00:56:23,720
Tada patikrinkite, yra 2 mažiau nei
iš Zamyla vardo ilgis.

1147
00:56:23,720 --> 00:56:25,380
6- taip 2 yra mažiau nei 6.

1148
00:56:25,380 --> 00:56:30,460
Taip, tegul atsispausdinti dabar M
Zamyla vardas, trečiasis simbolis.

1149
00:56:30,460 --> 00:56:34,110
>> Raktas čia yra tai, kad kiekvienas
iteracijos istorijos, aš patikrinti,

1150
00:56:34,110 --> 00:56:37,810
yra man mažiau nei Zamyla ilgio?

1151
00:56:37,810 --> 00:56:40,350
Bet laimikis, kad
Stirlingo nėra nuosavybė.

1152
00:56:40,350 --> 00:56:43,100
Tie iš jūsų, kurie užprogramuoti
prieš Java arba kitomis kalbomis

1153
00:56:43,100 --> 00:56:46,310
gali žinoti ilgis eilutė yra
nuosavybė, tik kai perskaičiau tik vertę.

1154
00:56:46,310 --> 00:56:50,220
>> C šiuo atveju, jei tai yra
funkcija, kuri yra tiesiog

1155
00:56:50,220 --> 00:56:53,520
skaičiuojant skaičių
simbolių Zamyla kiekvieną kartą

1156
00:56:53,520 --> 00:56:54,740
mes vadiname šią funkciją.

1157
00:56:54,740 --> 00:56:58,500
Kiekvieną kartą, kai jūs paprašykite kompiuterį naudoti
Stirlingo, tai atsižvelgiant pažvelgti Zamyla,

1158
00:56:58,500 --> 00:57:01,960
ir suprantama Ž-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Ir jis grįžta 6 d.

1160
00:57:02,962 --> 00:57:04,920
Kitą kartą jūs vadinate
jis viduje, kad kilpa,

1161
00:57:04,920 --> 00:57:08,610
jis ketina pažvelgti Zamyla
vėl, pasakyti Ž-A-M-Y-L-a punktą, 6.

1162
00:57:08,610 --> 00:57:10,320
Ir jis ketina grįžti 6 d.

1163
00:57:10,320 --> 00:57:12,980
Taigi, kas yra kvaila apie šį dizainą?

1164
00:57:12,980 --> 00:57:17,700
>> Kodėl mano kodas nėra 5 iš 5
projektavimo dabar, taip sakant?

1165
00:57:17,700 --> 00:57:20,600
Na, aš prašau
Klausimas be reikalo.

1166
00:57:20,600 --> 00:57:23,030
Darau daugiau darbo nei man reikia.

1167
00:57:23,030 --> 00:57:25,370
>> Taigi, nors
atsakymas yra teisingas, aš esu

1168
00:57:25,370 --> 00:57:29,560
klausia kompiuterį, kas yra
iš Zamyla ilgis vėl

1169
00:57:29,560 --> 00:57:31,380
ir vėl, ir vėl, ir vėl?

1170
00:57:31,380 --> 00:57:33,980
Ir atsakymas yra
niekada pakeisti.

1171
00:57:33,980 --> 00:57:35,900
Jis visada bus 6.

1172
00:57:35,900 --> 00:57:39,730
>> Taigi geresnis sprendimas, nei tai
Būtų tai kitą versiją.

1173
00:57:39,730 --> 00:57:43,390
Leiskite man eiti į priekį ir įdėti jį į
atskiras failas, vadinamas string1.c,

1174
00:57:43,390 --> 00:57:44,990
tiesiog laikyti jį atskirti.

1175
00:57:44,990 --> 00:57:47,260
Ir paaiškėja, skirtame
kilpa, jūs iš tikrųjų galite

1176
00:57:47,260 --> 00:57:50,210
paskelbti kelis kintamuosius vienu metu.

1177
00:57:50,210 --> 00:57:53,460
>> Taigi, aš ruošiuosi laikyti i ir nustatykite jį į 0.

1178
00:57:53,460 --> 00:57:56,190
Bet aš taip pat ketina
pridėti kablelį, ir pasakyti,

1179
00:57:56,190 --> 00:58:01,050
man kintamąjį vadinamą n, kurio
vertė yra lygi stygų ilgį s.

1180
00:58:01,050 --> 00:58:09,410
O dabar, prašom padaryti, kad mano būklė
tol, kol i yra mažiau nei n.

1181
00:58:09,410 --> 00:58:14,140
>> Taip tokiu būdu, logika yra
identiški dienos pabaigoje.

1182
00:58:14,140 --> 00:58:18,280
Bet aš prisimena
vertė 6, šiuo atveju.

1183
00:58:18,280 --> 00:58:19,780
Kas yra Zamyla vardo ilgis?

1184
00:58:19,780 --> 00:58:20,860
Ir aš pradėti jį n.

1185
00:58:20,860 --> 00:58:23,050
>> Ir aš vis dar tikrinti
sąlyga kiekvieną kartą.

1186
00:58:23,050 --> 00:58:24,300
Ar 0 jaunesniems nei 6?

1187
00:58:24,300 --> 00:58:25,600
Yra 1 mažesnis kaip 6?

1188
00:58:25,600 --> 00:58:28,600
Ar 2 mažiau kaip 6 ir tt?

1189
00:58:28,600 --> 00:58:31,914
>> Bet aš nesu klausia kompiuterį
vėl, ir vėl, kas

1190
00:58:31,914 --> 00:58:33,080
iš Zamyla vardo ilgis?

1191
00:58:33,080 --> 00:58:34,320
Kokia Zamyla vardo ilgis?

1192
00:58:34,320 --> 00:58:35,986
Koks šio Zamyla vardo ilgis?

1193
00:58:35,986 --> 00:58:40,440
Aš tiesiog prisiminti, kad pirmasis ir
atsakyti tik šio antrojo kintamojo n.

1194
00:58:40,440 --> 00:58:45,280
Todėl tai dabar būtų ne tik
teisinga, tačiau taip pat gerai suprojektuoti.

1195
00:58:45,280 --> 00:58:46,670
>> Dabar, ką apie stilių?

1196
00:58:46,670 --> 00:58:48,866
Aš pavadintas mano kintamuosius
gana gerai, sakyčiau.

1197
00:58:48,866 --> 00:58:50,240
Jie itin glaustas dabar.

1198
00:58:50,240 --> 00:58:52,090
Ir tai visiškai gerai.

1199
00:58:52,090 --> 00:58:55,120
>> Jei turite tik vieną
Styga į programą,

1200
00:58:55,120 --> 00:58:56,860
Jums gali taip pat skambinti tai s eilutę.

1201
00:58:56,860 --> 00:58:59,370
Jei turite tik vieną kintamąjį
skaičiavimo programoje,

1202
00:58:59,370 --> 00:59:00,710
Jums gali taip pat skambinti jai i.

1203
00:59:00,710 --> 00:59:03,500
Jei turite ilgis, n
yra super bendra, taip pat.

1204
00:59:03,500 --> 00:59:05,800
Bet aš ne komentavo bet mano kodas.

1205
00:59:05,800 --> 00:59:09,200
>> Aš ne informavo reader--
ar tai mano TF, ar TA,

1206
00:59:09,200 --> 00:59:12,460
ar tiesiog colleague-- kas turėtų
būti vyksta šioje programoje.

1207
00:59:12,460 --> 00:59:15,760
Ir taip gauti gerą stilių,
ką aš noriu daryti

1208
00:59:15,760 --> 00:59:24,580
yra this-- kažkas
kaip paklausti vartotoją įvesties.

1209
00:59:24,580 --> 00:59:26,670
Ir galėčiau perrašyti
tai bet kurį iš būdų.

1210
00:59:26,670 --> 00:59:35,630
>> Įsitikinkite s-- įsitikinkite get
styginių grįžo eilutę.

1211
00:59:35,630 --> 00:59:40,280
Ir tada here-- ir tai galbūt
svarbiausia comment-- kartoti

1212
00:59:40,280 --> 00:59:44,450
per S vienoje simbolių vienu metu.

1213
00:59:44,450 --> 00:59:47,060
Ir aš galėtų naudoti bet
pasirinkimas anglų kalba

1214
00:59:47,060 --> 00:59:49,650
Čia aprašyti kiekvienas
Šių kodo gabaliukus.

1215
00:59:49,650 --> 00:59:52,740
>> Atkreipkite dėmesį, kad aš ne įdėti
pakomentuoti kiekvieną kodo eilutę,

1216
00:59:52,740 --> 00:59:55,690
tikrai tik dėl įdomus
Ones tie, kurie

1217
00:59:55,690 --> 00:59:59,460
turėti tam tikrą reikšmę kad galėčiau
nori padaryti super aišku, kad kažkas

1218
00:59:59,460 --> 01:00:00,460
skaityti mano kodą.

1219
01:00:00,460 --> 01:00:02,920
Ir kodėl jūs skambinate gauti
styginių paklausti vartotoją įvesties?

1220
01:00:02,920 --> 01:00:05,450
Net, kad vienas yra nebūtinai
visi, kad aprašomasis.

1221
01:00:05,450 --> 01:00:09,340
Bet tai padeda pasakoti istoriją, nes
Antroji eilutė į istoriją yra, įsitikinkite, kad

1222
01:00:09,340 --> 01:00:10,740
gauti eilutė grįžo eilutę.

1223
01:00:10,740 --> 01:00:14,260
>> Ir trečia eilutė į istoriją yra
pakartoti per S vieną simbolių

1224
01:00:14,260 --> 01:00:15,380
tuo metu.

1225
01:00:15,380 --> 01:00:17,920
O dabar tiesiog gera priemonė,
Aš ruošiuosi eiti į priekį ir pridėti

1226
01:00:17,920 --> 01:00:24,560
dar vienas komentaras, kad tik
sako Spausdinti i-asis veikėjas s.

1227
01:00:24,560 --> 01:00:26,520
Dabar, kas aš padariau
Dienos pabaigoje?

1228
01:00:26,520 --> 01:00:29,190
>> Aš pridėjo keletą Anglų
žodžiai pastabų forma.

1229
01:00:29,190 --> 01:00:32,700
Velniop velniop simbolis reiškia, ei,
kompiuteris tai yra už žmogaus,

1230
01:00:32,700 --> 01:00:33,820
ne tau, kompiuteris.

1231
01:00:33,820 --> 01:00:35,119
Taigi jie ignoruojami logiškai.

1232
01:00:35,119 --> 01:00:35,910
Jie tiesiog ten.

1233
01:00:35,910 --> 01:00:39,830
>> Ir, tiesą sakant, CS50 IDE rodo juos kaip
pilka, kaip naudingi, bet ne raktas

1234
01:00:39,830 --> 01:00:41,000
į programą.

1235
01:00:41,000 --> 01:00:42,570
Atkreipkite dėmesį, ką dabar gali padaryti.

1236
01:00:42,570 --> 01:00:44,950
Nesvarbu, ar jūs žinote, C
programavimo, ar ne, jums

1237
01:00:44,950 --> 01:00:47,722
gali tiesiog stovėti atgal tai
programa, lieso komentarus.

1238
01:00:47,722 --> 01:00:50,180
Klauskite vartotoją įvesties, įsitikinkite, kad
gauti eilutė grįžo eilutę,

1239
01:00:50,180 --> 01:00:53,009
pakartoti per S simbolių
vienu metu, spausdinti simbolį

1240
01:00:53,009 --> 01:00:55,550
i-asis veikėjas s-- jūs neturite
net pažvelgti kodas

1241
01:00:55,550 --> 01:00:57,270
suprasti, ką ši programa daro.

1242
01:00:57,270 --> 01:01:00,280
Ir dar geriau, jei jūs sau atrodo
ne šios programos per savaitę ar dvi,

1243
01:01:00,280 --> 01:01:02,280
arba per mėnesį, arba per metus,
tu irgi neturi

1244
01:01:02,280 --> 01:01:04,420
spoksojimas kodas,
bando prisiminti,

1245
01:01:04,420 --> 01:01:06,630
tai, kas buvo man bando daryti su šiuo kodu?

1246
01:01:06,630 --> 01:01:07,770
>> Jūs pasakė sau.

1247
01:01:07,770 --> 01:01:11,660
Jūs apibūdino jį sau,
arba kai kolega arba TP arba TF.

1248
01:01:11,660 --> 01:01:14,860
Ir taip tai dabar būtų
teisinga ir geras dizainas,

1249
01:01:14,860 --> 01:01:18,210
ir galiausiai geras stilius, taip pat.

1250
01:01:18,210 --> 01:01:19,990
Taigi, tai keep that in mind.

1251
01:01:19,990 --> 01:01:22,200
>> Taigi vienas kitą
dalykas, aš ruošiuosi padaryti čia

1252
01:01:22,200 --> 01:01:28,240
kad dabar gali atskleisti, ką tai
vyksta po gaubtu.

1253
01:01:28,240 --> 01:01:30,390
Taigi ten ši funkcija
C, ir kitomis kalbomis,

1254
01:01:30,390 --> 01:01:33,010
vadinamas Typecasting
kad arba netiesiogiai

1255
01:01:33,010 --> 01:01:37,250
arba aiškiai leidžia jums konvertuoti
iš vienos duomenų tipą į kitą.

1256
01:01:37,250 --> 01:01:39,800
Mes užsiimame taip
kiek šiandien stygos.

1257
01:01:39,800 --> 01:01:41,250
>> Ir stygos simbolių.

1258
01:01:41,250 --> 01:01:44,910
Bet prisimenu nuo savaitės
0, kas yra simbolių?

1259
01:01:44,910 --> 01:01:49,334
Veikėjai yra tik abstrakcija
ant numbers-- dešimtųjų,

1260
01:01:49,334 --> 01:01:52,500
ir tūkstantųjų numeriai yra tikrai tik
abstrakcija ant dvejetainius skaičius,

1261
01:01:52,500 --> 01:01:53,720
kaip mes apibrėžti ją.

1262
01:01:53,720 --> 01:01:55,540
>> Taigi simboliai yra skaičiai.

1263
01:01:55,540 --> 01:01:58,410
Ir skaičiai yra simbolių,
tik priklausomai nuo konteksto.

1264
01:01:58,410 --> 01:02:01,250
Ir paaiškėja, kad viduje
kompiuterinės programos,

1265
01:02:01,250 --> 01:02:06,830
galite nurodyti, kaip norite atrodyti
ne viduje tos programos bitai?

1266
01:02:06,830 --> 01:02:10,400
>> Prisiminkite iš 0 savaitę, kad mes turėjome
ASCII, kuri yra tik šis kodas

1267
01:02:10,400 --> 01:02:11,620
kartografavimo raides į skaičius.

1268
01:02:11,620 --> 01:02:13,660
Ir mes pasakėme, kapitalo A yra 65.

1269
01:02:13,660 --> 01:02:15,860
Kapitalo B yra 66, ir kt.

1270
01:02:15,860 --> 01:02:20,500
>> Ir pranešimas, mes iš esmės turime simbolius nuo
viršutinėje eilutėje čia, kaip C, jiems skambinti,

1271
01:02:20,500 --> 01:02:23,400
simbolių, tada
ints antroje eilėje.

1272
01:02:23,400 --> 01:02:28,180
Ir paaiškėja, galite konvertuoti
sklandžiai tarp dviejų, dažniausiai.

1273
01:02:28,180 --> 01:02:30,042
Ir jei mes norime padaryti
tai sąmoningai, mes

1274
01:02:30,042 --> 01:02:31,750
norėti spręsti
kažkas panašaus į tai.

1275
01:02:31,750 --> 01:02:33,590
>> Mes galbūt norėsite konvertuoti
didžiosios sumažinti

1276
01:02:33,590 --> 01:02:35,330
atveju, ar mažosios raidės viršutinę atveju.

1277
01:02:35,330 --> 01:02:38,000
Ir it turns out Yra
iš tikrųjų modelis čia

1278
01:02:38,000 --> 01:02:39,900
galime priimti vos akimirką.

1279
01:02:39,900 --> 01:02:44,120
Bet pažiūrėkime pirmą esant
pavyzdys tai daryti aiškiai.

1280
01:02:44,120 --> 01:02:46,340
>> Aš ruošiuosi grįžti į CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Aš ruošiuosi kurti
byla vadinama ASCII 0.c.

1282
01:02:50,640 --> 01:02:55,960
Ir aš ruošiuosi eiti į priekį ir pridėti mano
standartinis io.h viršuje, int main negalioja

1283
01:02:55,960 --> 01:02:57,370
tuo savo funkcija viršuje.

1284
01:02:57,370 --> 01:03:02,700
Ir tada aš tik ketina padaryti
following-- for ciklas iš I lygi,

1285
01:03:02,700 --> 01:03:04,610
tarkim, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Ir tada aš bus mažiau nei
65, plius 26 raides abėcėlės.

1287
01:03:10,460 --> 01:03:12,640
Taigi aš tegul kompiuterį
matematikos už mane ten.

1288
01:03:12,640 --> 01:03:15,100
Ir tada viduje šio ciklo,
ką aš ketinu spausdinti?

1289
01:03:15,100 --> 01:03:19,230
>> % C yra% i backslash N.

1290
01:03:19,230 --> 01:03:21,290
Ir dabar noriu prijungti dviejų verčių.

1291
01:03:21,290 --> 01:03:24,530
Aš laikinai įdėti klausimą
žymi ten pakviesti į klausimą.

1292
01:03:24,530 --> 01:03:29,940
>> Noriu pakartoti nuo 65 Pirmyn
26 abėcėlės raidėmis,

1293
01:03:29,940 --> 01:03:35,190
spausdinti ant kiekvieno pakartojimo, kad
personažo neatsiejama ekvivalentas.

1294
01:03:35,190 --> 01:03:38,299
Kitaip tariant, noriu
pakartoti nei 26 numeriai spauda

1295
01:03:38,299 --> 01:03:41,590
kas ASCII simbolių yra raidė,
ir koks atitinkamas skaičius is--

1296
01:03:41,590 --> 01:03:44,650
tikrai tik atkurti
diagrama nuo tos skaidrės.

1297
01:03:44,650 --> 01:03:47,010
Taigi, ką reikėtų šie klaustukai būti?

1298
01:03:47,010 --> 01:03:51,760
>> Na, it turns out, kad antrasis
vienas turėtų būti tiesiog kintamasis aš.

1299
01:03:51,760 --> 01:03:53,860
Noriu pamatyti, kad kaip skaičius.

1300
01:03:53,860 --> 01:03:58,920
Ir Artimuosiuose argumentas
čia galiu pasakyti kompiuterį

1301
01:03:58,920 --> 01:04:03,470
gydyti, kad sveikasis skaičius
i kaip požymis, kad

1302
01:04:03,470 --> 01:04:05,880
ją pakeisti čia C procentų

1303
01:04:05,880 --> 01:04:07,990
>> Kitaip tariant, jei Aš,
žmogaus programuotojas, žinau

1304
01:04:07,990 --> 01:04:09,865
tai tik skaičiai
Dienos pabaigoje.

1305
01:04:09,865 --> 01:04:12,500
Ir aš žinau, kad 65 turėtų
map tam tikru charakterio.

1306
01:04:12,500 --> 01:04:15,310
Su šiuo aiškaus dauguma,
su skliaustuose,

1307
01:04:15,310 --> 01:04:18,840
iš duomenų tipą, kurį norite vardas
konvertuoti į ir uždara skliausteliuose,

1308
01:04:18,840 --> 01:04:21,200
galite papasakoti
kompiuteris, ei, kompiuteris,

1309
01:04:21,200 --> 01:04:24,130
konvertuoti šį sveikasis skaičius į char.

1310
01:04:24,130 --> 01:04:26,250
>> Taigi, kai aš paleisti tai
Programa po kompiliavimo,

1311
01:04:26,250 --> 01:04:29,740
pažiūrėkime, ką aš get-- padaryti ASCII 0.

1312
01:04:29,740 --> 01:04:33,020
Darn tai, ką aš padariau negerai čia?

1313
01:04:33,020 --> 01:04:35,884
Naudokite nedeklaruojamo identifikatorių,
viskas gerai, o ne tyčinis,

1314
01:04:35,884 --> 01:04:37,800
bet pažiūrėkime, jei mes negalime
Priežastis per tai.

1315
01:04:37,800 --> 01:04:41,220
>> Taigi linija five-- todėl aš negavau
labai toli iki varžtais.

1316
01:04:41,220 --> 01:04:42,140
Tai gerai.

1317
01:04:42,140 --> 01:04:46,560
Taigi 5 eilutė I lygus 65-- matau.

1318
01:04:46,560 --> 01:04:50,130
Taigi nepamirškite, kad C, skirtingai nuo kai kurių
kalbos, jei turi išankstinį programavimą

1319
01:04:50,130 --> 01:04:52,190
patirtis, turite
pasakyti kompiuterį

1320
01:04:52,190 --> 01:04:55,040
skirtingai nuo nulio, kas
tipo kintamasis yra.

1321
01:04:55,040 --> 01:04:56,860
>> Ir aš pamiršau svarbiausią frazę čia.

1322
01:04:56,860 --> 01:04:59,200
Pagal penkių, aš pradėjau naudoti i.

1323
01:04:59,200 --> 01:05:01,560
Bet aš nepasakiau C
kas duomenų tipas yra.

1324
01:05:01,560 --> 01:05:04,570
Taigi, aš ruošiuosi eiti į čia ir
pasakyti, ah, kad jis sveikas.

1325
01:05:04,570 --> 01:05:07,050
>> Dabar aš ruošiuosi eiti į priekį ir perkompiliuoti.

1326
01:05:07,050 --> 01:05:08,080
Tai fiksuotas tai.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Įveskite, tai tipo kietas.

1328
01:05:12,660 --> 01:05:15,360
Ne tik tai super greitai
paprašyti kompiuterį į šį klausimą,

1329
01:05:15,360 --> 01:05:18,885
Užuot ieškojus jį ant skaidrės,
tai išspausdinti po vieną eilutėje, A 65,

1330
01:05:18,885 --> 01:05:24,860
B yra 66, visą kelią down-- nuo I
tai padarė 26 times-- į raidžių z,

1331
01:05:24,860 --> 01:05:25,630
kuris yra 90.

1332
01:05:25,630 --> 01:05:27,790
Ir, iš tikrųjų, šiek tiek
daugiau pažangių būtų

1333
01:05:27,790 --> 01:05:31,030
buvo man ne pasikliauti
kompiuteryje pridėti 26.

1334
01:05:31,030 --> 01:05:34,060
Galėjau tik daroma
90, taip pat, taip ilgai

1335
01:05:34,060 --> 01:05:37,390
kaip aš ne padaryti tą pačią klaidą du kartus.

1336
01:05:37,390 --> 01:05:41,880
Noriu eiti per
Z, o ne tik aukštyn per y.

1337
01:05:41,880 --> 01:05:44,000
>> Taigi, kad aiškiai ketaus.

1338
01:05:44,000 --> 01:05:47,860
Pasirodo, kad tai
nėra net būtina.

1339
01:05:47,860 --> 01:05:52,480
Leiskite man eiti į priekį ir iš naujo paleisti šią
sudarytojas ir pakartotinis ASCII 0.

1340
01:05:52,480 --> 01:05:54,940
Pasirodo, kad C yra gana protingas.

1341
01:05:54,940 --> 01:05:57,150
>> Ir printf, ypač,
yra gana protingas.

1342
01:05:57,150 --> 01:06:01,260
Jei tiesiog praeiti i du kartus
tiek vietos rezervavimo ženklų, printf

1343
01:06:01,260 --> 01:06:04,510
suprasite, oi, gerai aš tave žinau
davė man integer-- šiek tiek skaičių,

1344
01:06:04,510 --> 01:06:06,380
kaip 65, ar 90, ar dar kas.

1345
01:06:06,380 --> 01:06:10,170
Bet matau, kad norite mane
formatuoti šį numerį panašaus pobūdžio.

1346
01:06:10,170 --> 01:06:16,460
Ir taip printf gali netiesiogiai atiduoti
INT į Jums char taip pat.

1347
01:06:16,460 --> 01:06:19,360
Taigi, kad ne problema ne visiems.

1348
01:06:19,360 --> 01:06:23,100
>> Bet pranešimas, dėl šios lygiavertiškumo
mes iš tikrųjų gali tai padaryti taip pat.

1349
01:06:23,100 --> 01:06:26,520
Leiskite man eiti į priekį ir padaryti vieną
kita versija this-- ASCII 1.c.

1350
01:06:26,520 --> 01:06:31,800
Ir vietoj Iteracja per
sveikieji skaičiai, tikrai gali smūgis jūsų protas

1351
01:06:31,800 --> 01:06:33,610
iteravimu per simbolius.

1352
01:06:33,610 --> 01:06:37,660
Jei char c gauna kapitalo A, aš
noriu eiti į priekį ir tai padaryti,

1353
01:06:37,660 --> 01:06:41,740
tol, kol C yra mažesnė arba lygi
kapitalo Z. Ir ant kiekvieno pakartojimo

1354
01:06:41,740 --> 01:06:45,690
Noriu prieaugio C, galiu
dabar mano printf linija čia

1355
01:06:45,690 --> 01:06:51,320
tarkim, proc C
procentų aš vėl kablelis C.

1356
01:06:51,320 --> 01:06:57,200
>> Ir dabar, aš galiu eiti kita kryptimi,
liejimo charakterį aiškiai

1357
01:06:57,200 --> 01:06:58,500
iki sveikojo skaičiaus.

1358
01:06:58,500 --> 01:07:00,560
Taigi, vėlgi, kodėl gi jūs tai padaryti?

1359
01:07:00,560 --> 01:07:03,830
Tai šiek tiek keista rūšiuoti
tikėtis, kalbant apie simbolių.

1360
01:07:03,830 --> 01:07:07,430
>> Bet jei jūs suprantate, ką tai
vyksta po gaubtu,

1361
01:07:07,430 --> 01:07:08,430
ten tikrai ne stebuklinga.

1362
01:07:08,430 --> 01:07:13,060
Jūs tiesiog pasakyti, ei, kompiuteris suteikia
man kintamasis vadinamas C tipo char.

1363
01:07:13,060 --> 01:07:16,520
Inicijuoti, kad kapitalo A. ir
pastebėti Viengubomis kabutėmis klausimą.

1364
01:07:16,520 --> 01:07:19,580
>> Simbolių C, prisiminti nuo
Praėjusią savaitę, jūs naudojate Viengubomis kabutėmis.

1365
01:07:19,580 --> 01:07:23,720
Styginiams, žodžių,
frazės, naudokite kabutes.

1366
01:07:23,720 --> 01:07:27,210
Gerai, kompiuteris, nuolat tai daryti, todėl
tol, kol pobūdžio yra mažiau nei

1367
01:07:27,210 --> 01:07:28,050
arba lygus z.

1368
01:07:28,050 --> 01:07:32,640
Ir aš žinau, iš mano ASCII lentelę, kad visi
Šių ASCII kodų ribojasi.

1369
01:07:32,640 --> 01:07:33,400
>> Yra be tarpų.

1370
01:07:33,400 --> 01:07:36,737
Taigi, tai tik nuo a iki z,
atskirti kiekvienos vienu skaičiumi.

1371
01:07:36,737 --> 01:07:38,820
Ir tada aš galiu prieaugio
char, jei aš tikrai noriu.

1372
01:07:38,820 --> 01:07:40,390
Dienos pabaigoje,
tai tik skaičius.

1373
01:07:40,390 --> 01:07:41,030
Aš žinau tai.

1374
01:07:41,030 --> 01:07:43,670
Taigi galiu tik daryti prielaidą, kad pridėti 1 prie jo.

1375
01:07:43,670 --> 01:07:46,940
>> Ir tada šį kartą, aš spausdinti C,
ir tada sudėtinė ekvivalentas.

1376
01:07:46,940 --> 01:07:50,170
Ir aš net nereikia aiškaus dauguma.

1377
01:07:50,170 --> 01:07:52,680
Galiu leisti printf, o
kompiuteris išsiaiškinti dalykus,

1378
01:07:52,680 --> 01:07:57,300
taip, kad dabar, jei aš paleisti
padaryti Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Gaunu tą patį dalyką, taip pat.

1380
01:08:01,520 --> 01:08:04,530
>> Nenaudingas programa, though-- niekas
vyksta iš tikrųjų rašyti programinę įrangą

1381
01:08:04,530 --> 01:08:07,549
tam, kad išsiaiškinti, kas buvo
skaičius, žemėlapiai į A, arba B, arba Z?

1382
01:08:07,549 --> 01:08:10,340
Jūs esate tik ketina jį "Google", arba
ieškoti jį internete, arba ieškoti jį

1383
01:08:10,340 --> 01:08:11,650
ant šliaužiklio, ar pan.

1384
01:08:11,650 --> 01:08:13,520
Taigi, kur ar tai iš tikrųjų gauti naudinga?

1385
01:08:13,520 --> 01:08:15,960
>> Na, kalbant apie tai
Pristatymas, pastebėsite, ten

1386
01:08:15,960 --> 01:08:20,890
tikrasis modelis čia didžiąsias
ir mažosiomis raidėmis, kad nebuvo atsitiktinis.

1387
01:08:20,890 --> 01:08:23,760
Atkreipkite dėmesį, kad kapitalas A yra 65.

1388
01:08:23,760 --> 01:08:25,830
Mažosiomis raidėmis a yra 97.

1389
01:08:25,830 --> 01:08:29,649
Ir kaip toli yra mažosios raidės ženklas?

1390
01:08:29,649 --> 01:08:32,649
>> Taigi 65 yra kiek žingsnių nuo 97?

1391
01:08:32,649 --> 01:08:36,210
Taigi 97 minus 65 yra 32.

1392
01:08:36,210 --> 01:08:37,910
Taigi kapitalo a yra 65.

1393
01:08:37,910 --> 01:08:39,939
Jei pridėsite nuo 32 iki, kad
jums mažosiomis a.

1394
01:08:39,939 --> 01:08:43,729
Ir analogiškai, jei atimti 32,
Jums grįžti į kapitalo A-- pats su B

1395
01:08:43,729 --> 01:08:46,380
į mažai B, didelis C mažai c.

1396
01:08:46,380 --> 01:08:50,670
>> Visi šios dalies trūkumas yra 32 vienas nuo kito.

1397
01:08:50,670 --> 01:08:54,450
Dabar, tai atrodo, kad galėtume
kažką daryti, pavyzdžiui, Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
arba Google Docs "funkcija, kur jums
galite pasirinkti viską ir tada pasakyti,

1399
01:08:57,729 --> 01:09:00,520
pakeisti visi mažąsias arba
pakeisti visi didžiosiomis raidėmis,

1400
01:09:00,520 --> 01:09:03,840
arba pakeisti tik pirmąjį žodį
sakinio į didžiąsias raides.

1401
01:09:03,840 --> 01:09:07,390
Mes iš tikrųjų galime padaryti kažką
kaip kad save.

1402
01:09:07,390 --> 01:09:12,645
>> Leiskite man eiti į priekį ir išsaugoti failą
čia vadinamas pasinaudoti 0.c.

1403
01:09:12,645 --> 01:09:15,770
Ir eikime į priekį ir pakelti programą
kad tai tiksliai, kad taip.

1404
01:09:15,770 --> 01:09:18,460
Taigi apima CS50 biblioteką.

1405
01:09:18,460 --> 01:09:21,430
Ir apima standartinį I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Ir aš žinau, tai yra netrukus.

1407
01:09:22,787 --> 01:09:24,870
Taigi, aš ruošiuosi įdėti ją į
ten jau string.h,

1408
01:09:24,870 --> 01:09:26,960
todėl aš turiu prieigą prie
dalykų, pavyzdžiui, Stirling,

1409
01:09:26,960 --> 01:09:29,620
ir tada int main negaliojančiu, kaip įprasta.

1410
01:09:29,620 --> 01:09:33,420
Ir tada aš ruošiuosi eiti į priekį
ir padaryti eilutes gauna gauti eilutę,

1411
01:09:33,420 --> 01:09:35,032
tik gauti eilutę iš vartotojo.

1412
01:09:35,032 --> 01:09:36,740
Ir tada aš ruošiuosi
daryti mano naudojama logiškai patikrinimą.

1413
01:09:36,740 --> 01:09:40,510
Jei eilutė nėra lygi NULL,
tada tai saugu tęsti.

1414
01:09:40,510 --> 01:09:42,000
Ir ką aš noriu daryti?

1415
01:09:42,000 --> 01:09:48,700
Aš ruošiuosi kartoti iš I lygi 0,
ir n iki eilutės ilgis S.

1416
01:09:48,700 --> 01:09:51,899
>> Ir aš ruošiuosi tai padaryti tol, kol
i yra mažiau nei N, ir i plius plius.

1417
01:09:51,899 --> 01:09:55,060
Iki šiol, aš tikrai tik
skolinimosi idėjų iš anksčiau.

1418
01:09:55,060 --> 01:09:57,010
Ir dabar aš ruošiuosi pristatyti filialą.

1419
01:09:57,010 --> 01:09:59,635
>> Taigi manau atgal į nulio, kur
mes turėjome tuos šakės kelyje,

1420
01:09:59,635 --> 01:10:05,110
ir praėjusią savaitę C. Aš ruošiuosi
tai sakau, jei i-asis veikėjas s

1421
01:10:05,110 --> 01:10:09,250
yra didesnis nei arba
lygus mažosiomis raidėmis a,

1422
01:10:09,250 --> 01:10:13,340
and-- į nulio jums būtų tiesiog
pasakyti ir, bet C sakote ampersendas,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- ir i-asis veikėjas s
yra mažesnis arba lygus lower case z,

1424
01:10:19,830 --> 01:10:21,780
darykime kažką įdomaus.

1425
01:10:21,780 --> 01:10:27,020
Leiskite tikrųjų atsispausdinti
simbolių be naujos eilutės

1426
01:10:27,020 --> 01:10:31,760
kad yra į eilutę simbolis,
i-asis veikėjas eilutę.

1427
01:10:31,760 --> 01:10:37,420
>> Bet eikime į priekį ir
atimti 32 iš jo.

1428
01:10:37,420 --> 01:10:42,120
Else if in simbolis
eilutė, mes ieškome

1429
01:10:42,120 --> 01:10:45,950
yra ne tarp mažai A
ir šiek tiek Z, eiti į priekį

1430
01:10:45,950 --> 01:10:48,610
ir tiesiog atspausdinti jį nepakeistą.

1431
01:10:48,610 --> 01:10:50,840
Taigi, mes įdiegėme
tai klaustuku žymėjimas

1432
01:10:50,840 --> 01:10:53,560
už mūsų Strings gauti ne
i-asis veikėjas eilutę.

1433
01:10:53,560 --> 01:10:57,520
>> Aš pridėjau šiek tiek sąlyginis logika, kaip ir
Nulio praėjusios savaitės savaitę vieną, kur

1434
01:10:57,520 --> 01:10:59,880
Aš tiesiog naudojant mano pagrindinis
supratimas apie tai, kas

1435
01:10:59,880 --> 01:11:01,130
vyksta po gaubtu.

1436
01:11:01,130 --> 01:11:04,190
Ar i-asis pobūdis s
didesnis nei arba lygus?

1437
01:11:04,190 --> 01:11:08,290
Kaip, tai 97, ar 98,
arba 99, ir taip toliau?

1438
01:11:08,290 --> 01:11:11,940
>> Bet tai taip pat yra mažesnė arba lygi
į mažąsias z verte?

1439
01:11:11,940 --> 01:11:16,210
Ir jei taip, ką ši linija reiškia?

1440
01:11:16,210 --> 01:11:20,250
14, tai yra rūšiuoti iš
gemalai šia idėja,

1441
01:11:20,250 --> 01:11:23,840
kapitalizuoti laišku
tiesiog atimant 32 iš jo,

1442
01:11:23,840 --> 01:11:29,370
šiuo atveju, nes žinau,, už, kad
diagramą, kaip mano numeriai yra atstovaujama.

1443
01:11:29,370 --> 01:11:33,925
Taigi eikime į priekį ir paleisti tai,
po kompiliavimo pasinaudoti 0.c,

1444
01:11:33,925 --> 01:11:36,210
ir paleisti pasinaudoti 0.

1445
01:11:36,210 --> 01:11:40,300
>> Leiskite įvesti kažką panašaus
Zamyla visose mažosiomis raidėmis įrašykite.

1446
01:11:40,300 --> 01:11:42,780
Ir dabar mes turime Zamyla visose didžiosiomis raidėmis.

1447
01:11:42,780 --> 01:11:45,050
Leiskite įveskite Rob visose mažosiomis raidėmis.

1448
01:11:45,050 --> 01:11:46,674
Pabandykime Jasoną visose mažosiomis raidėmis.

1449
01:11:46,674 --> 01:11:48,590
Ir mes gaunu
priversti kapitalizacija.

1450
01:11:48,590 --> 01:11:50,960
Yra nepilnametis klaidą, kad aš
rūšies nebuvo numatyti.

1451
01:11:50,960 --> 01:11:54,050
Atkreipkite dėmesį, my new greitai baigiasi iki
toje pačioje eilutėje kaip ir jų pavadinimai,

1452
01:11:54,050 --> 01:11:55,520
kuris jaučiasi šiek tiek nepatogus.

1453
01:11:55,520 --> 01:11:59,170
>> Taigi, aš ruošiuosi eiti čia, ir
tikrai ne šios programos pabaigoje

1454
01:11:59,170 --> 01:12:02,110
spausdinti naujos eilutės simbolį.

1455
01:12:02,110 --> 01:12:03,160
Tai viskas.

1456
01:12:03,160 --> 01:12:06,120
Su printf, jums nereikia
perduoti kintamuosius ar formatuoti kodą.

1457
01:12:06,120 --> 01:12:08,460
Jūs tiesiog galite tiesiog atsispausdinti
kažkas panašaus į naujos eilutės.

1458
01:12:08,460 --> 01:12:13,529
>> Taigi eikime į priekį ir padaryti
kapitalizuoti 0 vėl pakartotas jį Zamyla.

1459
01:12:13,529 --> 01:12:14,820
O dabar šiek tiek gražiau.

1460
01:12:14,820 --> 01:12:17,274
Dabar, mano eilutę yra savo naują eilutę.

1461
01:12:17,274 --> 01:12:18,440
Taigi, kad viskas gerai ir gerai.

1462
01:12:18,440 --> 01:12:19,910
Štai geras pavyzdys.

1463
01:12:19,910 --> 01:12:22,700
Bet aš net nebūtinai
reikia sunkiai kodas 32.

1464
01:12:22,700 --> 01:12:23,350
Zinai ka?

1465
01:12:23,350 --> 01:12:26,350
Galėčiau say-- aš ne kada nors
prisiminti, kas skirtumas yra.

1466
01:12:26,350 --> 01:12:29,330
>> Bet aš žinau, kad jei aš
turi mažąją raidę,

1467
01:12:29,330 --> 01:12:34,430
Aš iš esmės nori atimti išjungtas
nepriklausomai nuo atstumo, yra tarp mažai

1468
01:12:34,430 --> 01:12:39,160
A ir didelis, nes jei aš manau, kad
visų kitų raidėmis yra tokie patys,

1469
01:12:39,160 --> 01:12:41,045
kad turėtų gauti darbą.

1470
01:12:41,045 --> 01:12:42,670
Tačiau užuot tai padaryti, žinote, ką?

1471
01:12:42,670 --> 01:12:44,240
Yra dar vienas būdas vis.

1472
01:12:44,240 --> 01:12:48,090
>> Jei tai išnaudoti 1.c-- jei aš būčiau
įdėti, kad į atskirą failą.

1473
01:12:48,090 --> 01:12:51,030
Darom pasinaudoti 2.c taip.

1474
01:12:51,030 --> 01:12:53,060
Aš ruošiuosi tikrai valyti tai čia.

1475
01:12:53,060 --> 01:12:57,420
Ir vietoj to, kad net
nežino arba negalvoja apie tuos žemo lygio

1476
01:12:57,420 --> 01:13:01,090
įgyvendinimo detales, aš vietoj
tik ketina spausdinti simbolį,

1477
01:13:01,090 --> 01:13:04,610
citata citatos pabaiga, proc C ir
tada skambinti kitą funkciją, kad

1478
01:13:04,610 --> 01:13:09,950
egzistuoja, kad mano argumentas,
kuris yra simbolis, kaip tai.

1479
01:13:09,950 --> 01:13:12,630
>> Pasirodo, C, ten
kita skambinimo funkcijos

1480
01:13:12,630 --> 01:13:15,550
į viršutinį, kuris, kaip jos pavadinimas
rodo mano charakterį

1481
01:13:15,550 --> 01:13:19,350
ir daro jį į viršutiniame atveju
lygiaverčiai, ir tada vėl ją

1482
01:13:19,350 --> 01:13:21,410
kad printf galite prijungti jį ten.

1483
01:13:21,410 --> 01:13:25,484
Ir taip tai padaryti, nors aš
reikia įvesti vieną kitą failą.

1484
01:13:25,484 --> 01:13:28,400
Pasirodo, yra ir kitas failas
kad jums būtų žinoti tik iš klasės,

1485
01:13:28,400 --> 01:13:33,020
arba vadovėlis, arba internete
nuoroda, vadinamas C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Taigi, jei aš pridurti, kad iki tarp antraštės mano
failai, o dabar iš naujo kompiliuoti šią programą,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Leiskite įveskite Zamyla visų
mažosiomis raidėmis, vis dar veikia tas pats.

1489
01:13:46,690 --> 01:13:48,040
Bet žinote ką?

1490
01:13:48,040 --> 01:13:55,590
Pasirodo, kad į viršutinio
turi kitas funkcijas.

1491
01:13:55,590 --> 01:13:58,410
>> Ir leiskite man pristatyti tai
komanda čia tarsi negrabiai

1492
01:13:58,410 --> 01:14:00,250
pavadintas, bet žmogus vadove.

1493
01:14:00,250 --> 01:14:03,960
Pasirodo, kad dauguma Linux kompiuterius,
kaip mes naudojame here-- Linux operacinė

1494
01:14:03,960 --> 01:14:06,270
system-- turėti komandą
vadinamas vyras, kuris sako,

1495
01:14:06,270 --> 01:14:08,530
ei, kompiuteris, duok man
kompiuterio instrukcijos.

1496
01:14:08,530 --> 01:14:10,680
ko nori
ieškoti toje instrukcijoje?

1497
01:14:10,680 --> 01:14:13,840
>> Noriu pažvelgti funkcija
pašaukti viršutinė, Enter.

1498
01:14:13,840 --> 01:14:16,070
Ir tai šiek tiek paslaptingas
skaityti kartais.

1499
01:14:16,070 --> 01:14:18,780
Bet pastebėsite mes į
Linux programuotojas instrukcijos.

1500
01:14:18,780 --> 01:14:19,530
Ir visa tai tekstas.

1501
01:14:19,530 --> 01:14:21,905
Ir pastebėsite, kad "The
Pavadinimas funkcija čia.

1502
01:14:21,905 --> 01:14:25,030
Pasirodo, ji turi pusbrolį, vadinamą
sumažinti, kuris daro priešingai.

1503
01:14:25,030 --> 01:14:29,710
Ir pranešimas pagal santrauką, naudoti šią
Funkcija vyro puslapį, taip sakant,

1504
01:14:29,710 --> 01:14:32,220
sako man, kad aš
reikia įtraukti c type.h.

1505
01:14:32,220 --> 01:14:33,630
Ir aš žinojau, kad iš praktikos.

1506
01:14:33,630 --> 01:14:36,210
>> Čia, tai rodo man du
prototipų funkciją,

1507
01:14:36,210 --> 01:14:39,070
taip, kad jei aš kada nors norite naudoti šį
Aš žinau, ką jie imasi, kaip įvestį,

1508
01:14:39,070 --> 01:14:40,652
ir ką jie grįžta kaip produkcija.

1509
01:14:40,652 --> 01:14:42,360
Ir tada, jei skaitau
aprašymas, matau

1510
01:14:42,360 --> 01:14:44,820
išsamiau, ką funkcija veikia.

1511
01:14:44,820 --> 01:14:48,100
Bet dar svarbiau, jei
Žiūriu pagal grįžimo vertės,

1512
01:14:48,100 --> 01:14:51,710
ji sako, grąžinta reikšmė yra
kad konvertuotų laiško,

1513
01:14:51,710 --> 01:14:57,880
arba C, originalus įėjimas, jei
toks pakeitimas buvo neįmanoma.

1514
01:14:57,880 --> 01:15:01,992
>> Kitaip tariant, į viršutinę bandys
konvertuoti laišką didžiosiomis raidėmis.

1515
01:15:01,992 --> 01:15:03,450
Ir jei taip, tai kas vyksta jį grįžti.

1516
01:15:03,450 --> 01:15:07,010
Bet jei jis negali kai reason--
gal tai jau didžiosios,

1517
01:15:07,010 --> 01:15:09,550
gal tai yra šauktukas
ar kokios nors kitos punctuation--

1518
01:15:09,550 --> 01:15:12,200
tai tik ketina
grįžti į pradinę C,

1519
01:15:12,200 --> 01:15:17,340
o tai reiškia, aš galiu padaryti, kad mano kodą
geriau suprojektuoti taip.

1520
01:15:17,340 --> 01:15:20,580
>> Aš nereikia visi
Šie darn eilučių kodo.

1521
01:15:20,580 --> 01:15:22,610
Visi linijų Aš
tik pabrėžė gali

1522
01:15:22,610 --> 01:15:28,700
būti perkeliamas į tik vieną paprastą
linija, kuri yra this-- printf proc

1523
01:15:28,700 --> 01:15:33,510
C viršutinėje S laikiklio i.

1524
01:15:33,510 --> 01:15:36,090
Ir tai būtų
pavyzdys geresnį projektavimą.

1525
01:15:36,090 --> 01:15:40,040
>> Kodėl įgyvendinti 7 ar 8 linijos
kodo, kokia ji man buvo tiesiog

1526
01:15:40,040 --> 01:15:44,960
ištrinti, kai vietoj jų galima sutraukti
visi, kad logika ir sprendimų priėmimo

1527
01:15:44,960 --> 01:15:49,620
į vieną linija, 13 dabar, kad
remiasi bibliotekoje function--

1528
01:15:49,620 --> 01:15:53,430
funkcija, kuri ateina su C, bet
daro būtent tai, ką norite daryti.

1529
01:15:53,430 --> 01:15:55,295
Ir, tiesą sakant, net jei
jis neatėjo su C,

1530
01:15:55,295 --> 01:15:58,880
galite ją įgyvendinti patys, kaip
mes matėme, su gauti neigiamą int

1531
01:15:58,880 --> 01:16:01,700
ir gauti teigiami INT praėjusią savaitę taip pat.

1532
01:16:01,700 --> 01:16:03,470
>> Šis kodas dabar yra daug daugiau skaityti.

1533
01:16:03,470 --> 01:16:06,670
Ir, iš tiesų, jei mes slinkti aukštyn,
atrodo kiek kompaktiškesnis

1534
01:16:06,670 --> 01:16:08,360
tai mano programos versija yra.

1535
01:16:08,360 --> 01:16:11,230
Tai šiek tiek sunkesnė dabar
su visa tai įeina.

1536
01:16:11,230 --> 01:16:14,380
Bet tai gerai, nes dabar aš stoviu
apie programuotojus pečių

1537
01:16:14,380 --> 01:16:15,300
prieš mane.

1538
01:16:15,300 --> 01:16:18,440
Ir kas tai buvo, kuris
įgyvendintos viršutinė tikrai

1539
01:16:18,440 --> 01:16:21,470
man padarė paslaugą, panašiai kaip kas
įgyvendinti Stirlingo tikrai

1540
01:16:21,470 --> 01:16:24,790
man padarė paslaugą prieš kurį laiką.

1541
01:16:24,790 --> 01:16:26,970
Ir todėl dabar turime
geriau dizainas programa

1542
01:16:26,970 --> 01:16:31,680
kuri įgyvendina tą patį logiką.

1543
01:16:31,680 --> 01:16:35,580
>> Kalbėdamas apie Stirling, tegul
man eiti į priekį ir tai padaryti.

1544
01:16:35,580 --> 01:16:38,320
Leiskite man eiti į priekį ir sutaupyti
šiam failui kaip stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Ir it turns out, mes galime žievelės atgal
vienas sluoksnis gana tiesiog dabar.

1546
01:16:43,255 --> 01:16:45,630
Aš ruošiuosi eiti į priekį ir plakti
iki kito pagrindinis programos

1547
01:16:45,630 --> 01:16:49,759
kad čia tiesiog vėl padargus
eilutės ilgis taip.

1548
01:16:49,759 --> 01:16:52,300
Taigi čia kodo eilutė, kad
gauna man eilutę iš vartotojo.

1549
01:16:52,300 --> 01:16:53,910
Mes nuolat naudojant šį vėl ir vėl.

1550
01:16:53,910 --> 01:16:58,900
Leiskite man duoti sau kintamąjį vadinamą
n tipo int, kad išsaugo numerį.

1551
01:16:58,900 --> 01:17:02,490
>> Ir leiskite man eiti į priekį ir
daryti tokią logiką.

1552
01:17:02,490 --> 01:17:15,610
Nors n-tojo personažas s daro
nėra lygūs Backslash 0, eiti į priekį

1553
01:17:15,610 --> 01:17:17,930
ir prieaugio N.

1554
01:17:17,930 --> 01:17:23,506
Ir tada atsispausdinti printf proc I n.

1555
01:17:23,506 --> 01:17:29,200
Aš teigia, kad ši programa čia
nekeliant string ilgis,

1556
01:17:29,200 --> 01:17:31,150
skaičiai dėmesį į eilutę ilgį.

1557
01:17:31,150 --> 01:17:34,600
>> Ir magija yra visiškai
aplieti 8 linija

1558
01:17:34,600 --> 01:17:39,830
čia su tuo, kas atrodo kaip naujos sintaksės,
tai Backslash 0 vienviečiai kabučių.

1559
01:17:39,830 --> 01:17:41,360
Bet kodėl taip yra?

1560
01:17:41,360 --> 01:17:44,100
Na, mano kas buvo
vyksta visą šį laiką.

1561
01:17:44,100 --> 01:17:47,990
>> Ir kaip žemę, kol aš pamiršti, suvokti
taip pat, kad papildomai prie žmogaus puslapiuose

1562
01:17:47,990 --> 01:17:50,920
kad ateis su tipiškas
Linux sistemos kaip CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
suprasti, kad mes,
Kursas darbuotojai, taip pat

1564
01:17:53,770 --> 01:17:56,030
padarė tinklalapio versija
Šio pačią idėją, vadinamą

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, kuri turi
visi tų pačių žmogaus puslapius,

1566
01:17:59,940 --> 01:18:02,020
visi ta pati
dokumentus, taip pat

1567
01:18:02,020 --> 01:18:05,730
šiek tiek dėžutė viršuje, kuri leidžia
jums konvertuoti visas gana

1568
01:18:05,730 --> 01:18:09,025
Arcane kalba, į nekomfortiška
režimas, kur mes, dėstytojai,

1569
01:18:09,025 --> 01:18:12,150
išgyveno ir bandė supaprastinti
kai kalba, kad viskas

1570
01:18:12,150 --> 01:18:14,830
orientuota į idėjų, o ne
kai techninių detalių.

1571
01:18:14,830 --> 01:18:20,070
Taigi reikia nepamiršti, reference.cs50.net
kaip kito ištekliaus, taip pat.

1572
01:18:20,070 --> 01:18:23,800
>> Bet kodėl styginių ilgis darbą
kaip man pasiūlė akimirką prieš?

1573
01:18:23,800 --> 01:18:25,160
Štai Zamyla vardas dar kartą.

1574
01:18:25,160 --> 01:18:27,690
Ir štai Zamyla vardas
supakuoti į, kaip aš nuolat daro,

1575
01:18:27,690 --> 01:18:31,360
tapyti paveikslėlį IT būtis,
tikrai, tik simbolių seka.

1576
01:18:31,360 --> 01:18:34,260
Bet Zamyla neegzistuoja
atskirai į programą.

1577
01:18:34,260 --> 01:18:37,420
>> Rašydami ir paleisti programą,
jūs naudojate savo "Mac" arba kompiuterį

1578
01:18:37,420 --> 01:18:40,010
, atminties, ar RAM taip sakant.

1579
01:18:40,010 --> 01:18:42,620
Ir jūs galite galvoti apie
kompiuteris kaip turintys

1580
01:18:42,620 --> 01:18:44,730
daug gigabaitų atminties šių dienų.

1581
01:18:44,730 --> 01:18:47,700
Ir koncertą reiškia milijardus,
todėl milijardai baitai.

1582
01:18:47,700 --> 01:18:48,910
>> Bet tegul atgal laiku.

1583
01:18:48,910 --> 01:18:51,530
Ir manau, kad mes naudojame
tikrai senas kompiuteris,

1584
01:18:51,530 --> 01:18:55,150
turi tik 32 baitų atminties.

1585
01:18:55,150 --> 01:18:59,310
Galėčiau, mano kompiuterio ekrane,
tiesiog atkreipia į tai dėmesį taip.

1586
01:18:59,310 --> 01:19:05,240
>> Galėčiau tiesiog pasakyti, kad mano
kompiuteris turi visą šį atmintyje.

1587
01:19:05,240 --> 01:19:08,830
Ir tai yra tarsi Memory Stick, jei
jūs prisimenate mūsų nuotrauką iš paskutinio karto.

1588
01:19:08,830 --> 01:19:11,670
Ir jei aš tiesiog padalinti
tai pakankamai kartų,

1589
01:19:11,670 --> 01:19:15,040
Galiu reikalauti, kad turiu 32 baitų
atminties ekrane.

1590
01:19:15,040 --> 01:19:18,239
>> Dabar, iš tikrųjų, aš galiu tik
atkreipti šiol šiame ekrane čia.

1591
01:19:18,239 --> 01:19:20,280
Taigi, aš ruošiuosi eiti į priekį,
ir tik pagal susitarimą,

1592
01:19:20,280 --> 01:19:24,050
atkreipti mano kompiuterio atmintį, kaip
Tinklelis, ne tik kaip viena tiesi linija.

1593
01:19:24,050 --> 01:19:28,190
Tiksliau, aš teigti, kad dabar
tai tinklelis, tai 8 iki 4 tinklelis,

1594
01:19:28,190 --> 01:19:31,800
tik atstovauja visus 32 baitų
kiek laisvos atminties liko mano Mac,

1595
01:19:31,800 --> 01:19:33,030
ar galima mano PC.

1596
01:19:33,030 --> 01:19:34,780
Ir jie vyniojimo
į dvi eilutes, tiesiog

1597
01:19:34,780 --> 01:19:38,030
nes ji tinka daugiau ekrane.

1598
01:19:38,030 --> 01:19:40,800
Bet tai yra pirmasis baitas.

1599
01:19:40,800 --> 01:19:41,990
Tai yra antras baitas.

1600
01:19:41,990 --> 01:19:43,300
Tai yra trečias baitas.

1601
01:19:43,300 --> 01:19:45,310
>> Ir tai yra 32. baitų.

1602
01:19:45,310 --> 01:19:52,910
Arba, jei mes manome, kaip kompiuteris
mokslininkas, tai yra baitas 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Taigi jūs turite 0 iki 31, jei
Jums pradėti skaičiuoti 0.

1604
01:19:55,950 --> 01:19:59,830
>> Taigi, jei mes naudojame programą
kad skambučiai gauti eilutę,

1605
01:19:59,830 --> 01:20:05,280
ir gauname eilutę iš žmogaus
kaip aš vadinamas Zamyla, Ž-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
Kaip pasaulyje veikia
kompiuteris Sekite kurių baitas,

1607
01:20:09,430 --> 01:20:12,230
kuri riekė atminties,
priklauso, į kurią eilutę?

1608
01:20:12,230 --> 01:20:16,270
Kitaip tariant, jei mes pereiti prie
įrašykite kitą pavadinimą į kompiuterį,

1609
01:20:16,270 --> 01:20:19,890
kaip šis Ieva, ragindamas
gauti eilutė antrą kartą,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I turi galų gale į
kompiuterio atmintyje, taip pat.

1611
01:20:23,030 --> 01:20:23,850
Bet kaip?

1612
01:20:23,850 --> 01:20:29,700
>> Na, paaiškėja, kad po
dangtis, ką, C ar laikant stygas

1613
01:20:29,700 --> 01:20:35,080
kad žmogaus tipų, arba kad
iš kitu šaltiniu, tai

1614
01:20:35,080 --> 01:20:39,190
apibrėžia jų galą su
specialus character-- Backslash

1615
01:20:39,190 --> 01:20:44,750
0, kuri yra tik ypatingu būdu
sakydamas 80 bitai iš eilės.

1616
01:20:44,750 --> 01:20:47,950
>> Taigi A-- tai yra numeris 97 atminties.

1617
01:20:47,950 --> 01:20:51,770
Taigi kai kurie iš 8 bitų modelis
atstovauja dešimtainį skaičių 97.

1618
01:20:51,770 --> 01:20:58,070
Tai Backslash 0 yra tiesiog skaičius
0, dar žinoma kaip raj N-U L, skirtingai nuo anksčiau,

1619
01:20:58,070 --> 01:20:59,630
N-U L-L, kurį mes kalbėjome apie tai.

1620
01:20:59,630 --> 01:21:05,700
Bet dabar, tik žinau, kad tai
Backslash 0 yra tik 80 bitai iš eilės.

1621
01:21:05,700 --> 01:21:09,810
>> Ir tai tik tai linija
smėlis, kuri sako ką nors į kairę

1622
01:21:09,810 --> 01:21:12,610
priklauso viena eilutę, arba viena duomenų tipo.

1623
01:21:12,610 --> 01:21:15,480
Ir nieko į dešinę
priklauso kažkas.

1624
01:21:15,480 --> 01:21:17,440
Ieva vardas, tuo tarpu,
kurie tik vizualiai

1625
01:21:17,440 --> 01:21:21,310
atsitinka, į kuriuos vyniojami ant į kitą linija,
bet tai tik estetinis detalė,

1626
01:21:21,310 --> 01:21:23,990
Panašiai yra nul nutrauktas.

1627
01:21:23,990 --> 01:21:29,290
>> Ji yra A A-N-D-I simbolių eilutė,
plius penktasis paslaptis charakteris,

1628
01:21:29,290 --> 01:21:33,560
Visi 0 bitai, kad tik pažymėtų
iš Andi vardo galas taip pat.

1629
01:21:33,560 --> 01:21:37,120
Ir jei mes vadiname gauti string trečią kartą
kompiuteryje gauti kaip eilutę

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, panašiai yra maria s
vardas raj nutraukta su backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Tai iš esmės skiriasi
nuo to, kaip kompiuteris būtų paprastai

1632
01:21:47,170 --> 01:21:51,850
saugoti sveikasis skaičius arba trintuve ar kitas
duomenų tipai dar, nes žinote,

1633
01:21:51,850 --> 01:21:57,420
sveikas skaičius yra paprastai 32 bitų, arba
4 baitų, o gal net 64 bitai,

1634
01:21:57,420 --> 01:21:59,100
ar aštuonis baitai.

1635
01:21:59,100 --> 01:22:02,620
Tačiau daugelis primityvai kompiuteryje
į programavimo kalba

1636
01:22:02,620 --> 01:22:05,550
turi fiksuotą skaičių
baitų po hood--

1637
01:22:05,550 --> 01:22:08,100
gal 1, gal 2, gal 4, gal 8.

1638
01:22:08,100 --> 01:22:13,250
>> Bet stygos, konstrukcijos, turėti
dinamiškas simbolių skaičius.

1639
01:22:13,250 --> 01:22:16,980
Jūs neturite žinoti iš anksto, kol
žmogaus rūšys, Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
arba M-A-R-I-A, arba A-N-D-I priedą. Jūs nežinote,
kiek kartų vartotojas ketina hit

1641
01:22:21,400 --> 01:22:22,070
klaviatūra.

1642
01:22:22,070 --> 01:22:26,490
Todėl jums nereikia žinoti, kaip
daug simbolių iš anksto

1643
01:22:26,490 --> 01:22:27,540
jūs ketinate reikia.

1644
01:22:27,540 --> 01:22:31,840
>> Ir taip, C tiesiog rūšies lapai tarsi
Paslaptis tinklalapio po gaubtu

1645
01:22:31,840 --> 01:22:32,960
tuo eilutės pabaigoje.

1646
01:22:32,960 --> 01:22:39,280
Po to, kai saugojimo Ž-A-M-Y-L-A atmintyje,
ji taip pat tik kelia ekvivalentą

1647
01:22:39,280 --> 01:22:40,210
tam tikro laikotarpio.

1648
01:22:40,210 --> 01:22:45,060
Pasibaigus sakinio pabaigoje
tai kelia 80 bitai, kad

1649
01:22:45,060 --> 01:22:49,120
prisiminti, kur
Zamyla prasideda ir baigiasi.

1650
01:22:49,120 --> 01:22:51,490
>> Taigi, kas yra ryšys,
tada šią programą?

1651
01:22:51,490 --> 01:22:55,190
Ši programa čia Stirlingas,
yra tiesiog mechanizmas

1652
01:22:55,190 --> 01:22:57,970
gauti eilutę
nuo vartotojo, linija 6.

1653
01:22:57,970 --> 01:23:01,160
7 Line "aš pareiškiu, kintamąjį
vadinamas n ir nustatyti, kad jis lygus 0.

1654
01:23:01,160 --> 01:23:08,680
>> Ir tada 8 eilutėje, aš tiesiog paprašė
klausimas, o n-oji simbolis daro

1655
01:23:08,680 --> 01:23:12,120
nėra lygūs visi 0 bits--
kitaip tariant, ar ne

1656
01:23:12,120 --> 01:23:14,500
lygus šis specialus
charakteris, Backslash 0, o

1657
01:23:14,500 --> 01:23:18,470
buvo tik, kad ypatingas raj character--
eiti į priekį ir tik prieaugio N.

1658
01:23:18,470 --> 01:23:21,460
>> Ir nuolat tai daryti, ir išlaikyti
daro, ir nuolat tai daryti.

1659
01:23:21,460 --> 01:23:23,430
Ir todėl, nors ir
Anksčiau mes jau naudojama i,

1660
01:23:23,430 --> 01:23:25,181
tai puikiai baudą
semantiškai naudoti n

1661
01:23:25,181 --> 01:23:27,430
jei jūs tiesiog bando
tikėtis šį kartą sąmoningai,

1662
01:23:27,430 --> 01:23:28,720
ir tiesiog nori ją vadina n.

1663
01:23:28,720 --> 01:23:34,720
Taigi tai tik išlaiko klausia klausimą,
yra n-tojo pobūdis viskas 0s?

1664
01:23:34,720 --> 01:23:38,470
Jei ne, pažiūrėkite į kitą išvaizdą,
pažvelgti į kitą, pažvelgti į kitą,

1665
01:23:38,470 --> 01:23:39,460
pažvelgti į kitą.

1666
01:23:39,460 --> 01:23:45,540
>> Bet kaip tik matote kairinį brūkšnį, 0,
tai loop-- linija 9 per 11-- sustoja.

1667
01:23:45,540 --> 01:23:49,640
Jūs išeiti iš while cikle,
paliekant viduje, kad kintamasis n

1668
01:23:49,640 --> 01:23:54,530
bendras skaičius, susijusių su visomis
simbolių eilutę matėte,

1669
01:23:54,530 --> 01:23:55,660
taip spausdinant jį.

1670
01:23:55,660 --> 01:23:56,760
Taigi pabandykime tai.

1671
01:23:56,760 --> 01:23:59,500
>> Leiskite man eiti į priekį ir, be
naudojant Stirling funkciją,

1672
01:23:59,500 --> 01:24:04,240
bet tiesiog naudojant savo atpažinimo versiją
čia vadinamas Stirling, leiskite man eiti į priekį

1673
01:24:04,240 --> 01:24:07,700
ir paleisti Stirling, tipo kažką
kaip Zamyla, kurį aš žinau, iš anksto

1674
01:24:07,700 --> 01:24:08,670
yra šeši rašmenys.

1675
01:24:08,670 --> 01:24:10,080
Leiskite pamatyti, jei ji veikia.

1676
01:24:10,080 --> 01:24:10,920
Iš tiesų, tai šeši.

1677
01:24:10,920 --> 01:24:15,257
Pabandykime su Rob, trys simboliai,
trys simboliai, taip pat, ir kt.

1678
01:24:15,257 --> 01:24:17,340
Taigi, kad viskas, kas vyksta
apie po gaubtu.

1679
01:24:17,340 --> 01:24:19,548
Ir pastebėti ryšius,
tada, su pirmą savaitę

1680
01:24:19,548 --> 01:24:22,370
klasės, kur mes kalbėjome apie
kažkas panašaus imti,

1681
01:24:22,370 --> 01:24:26,960
kuri yra tik tai idėjų sluoksniavimasis arba
sudėtingumą, ant pagrindinių principų.

1682
01:24:26,960 --> 01:24:30,710
Čia mes tarsi ieško
po Stirling gaubtu,

1683
01:24:30,710 --> 01:24:33,510
taip sakant, išsiaiškinti,
kaip ji bus įgyvendinta?

1684
01:24:33,510 --> 01:24:35,232
>> Ir mes galime iš naujo įgyvendinti jai save.

1685
01:24:35,232 --> 01:24:37,440
Bet mes niekada vyksta
iš naujo įdiegti Stirling.

1686
01:24:37,440 --> 01:24:39,780
Mes tiesiog ketiname
naudoti Stirling, kad

1687
01:24:39,780 --> 01:24:42,100
kad iš tikrųjų kažkiek stygos ilgį.

1688
01:24:42,100 --> 01:24:44,200
>> Bet ten ne magija
po gaubtu.

1689
01:24:44,200 --> 01:24:46,716
Jei žinote, kad po
dangtis, styginių

1690
01:24:46,716 --> 01:24:48,090
yra tik ženklų seka.

1691
01:24:48,090 --> 01:24:51,090
Ir, kad ženklų seka
visi gali būti skaitmeninio skirta

1692
01:24:51,090 --> 01:24:53,330
su laikikliu 0, laikikliu
1, laikiklis 2, ir jūs

1693
01:24:53,330 --> 01:24:57,420
žinome, kad ne iš eilutės pabaigos yra
specialus simbolis, galite išsiaiškinti,

1694
01:24:57,420 --> 01:25:01,710
Kaip padaryti dauguma nieko
programa, nes visa tai suvesta

1695
01:25:01,710 --> 01:25:03,400
yra skaitymo ir rašymo atmintį.

1696
01:25:03,400 --> 01:25:06,130
Tai reiškia, kad keičiasi ir ieško
ne atmintis, ar juda dalykų

1697
01:25:06,130 --> 01:25:10,940
aplink atmintyje, spausdinimo dalykai
ekrane, ir taip toliau.

1698
01:25:10,940 --> 01:25:14,800
>> Tad dabar pats naudoju šį naujai atrastą
supratimas, kas stygos iš tikrųjų

1699
01:25:14,800 --> 01:25:17,910
yra po kapotu, ir
žievelės atgal vieną kitą sluoksnį

1700
01:25:17,910 --> 01:25:20,080
kad iki šiol mes
buvo ignoruojant apskritai.

1701
01:25:20,080 --> 01:25:22,650
Visų pirma, bet kuriuo metu
mes įdiegėme programą,

1702
01:25:22,650 --> 01:25:25,930
mes jau šią eilutę kodo
viršuje deklaruojant pagrindinis.

1703
01:25:25,930 --> 01:25:27,810
Ir mes nurodyta int main negaliojančiu.

1704
01:25:27,810 --> 01:25:31,240
>> Ir tą tuštumą viduje skliausteliuose
buvo sakydamas visą šį laiką, kad pagrindinis

1705
01:25:31,240 --> 01:25:33,440
pati nesiima jokių argumentų.

1706
01:25:33,440 --> 01:25:36,210
Bet kokius duomenis, kad pagrindinis yra
ketina gauti iš vartotojo

1707
01:25:36,210 --> 01:25:39,020
turi ateiti iš kai kurių kitų
mechanizmas, kaip ir vakaronė INT,

1708
01:25:39,020 --> 01:25:42,040
arba gauti plūdę, arba gauti eilutę,
ar kokios nors kitos funkcijos.

1709
01:25:42,040 --> 01:25:44,710
Tačiau paaiškėja, kad
Rašydami programą,

1710
01:25:44,710 --> 01:25:47,690
jūs iš tikrųjų galite nurodyti
kad ši programa turi

1711
01:25:47,690 --> 01:25:51,730
imtis įėjimai iš žmogaus
ne pati komandų eilutę.

1712
01:25:51,730 --> 01:25:56,310
>> Kitaip tariant, nors mes iki šiol
jau veikia tik ./hello Sveiki

1713
01:25:56,310 --> 01:26:00,312
ar panašios programos, visi
Kitos programos, kad mes jau naudojate,

1714
01:26:00,312 --> 01:26:02,770
kad mes patys nerašė,
ėmėsi, atrodo,

1715
01:26:02,770 --> 01:26:05,210
komandinės eilutės arguments--
tokie dalykai kaip padaryti.

1716
01:26:05,210 --> 01:26:07,450
Jūs sakote kažką panašaus modelio,
ir tada antras žodis.

1717
01:26:07,450 --> 01:26:10,950
Arba žvangėjimas, jūs sakote žvangėjimas, ir tada
antras žodis iš failo pavadinimą.

1718
01:26:10,950 --> 01:26:14,410
>> Arba net RM ar KP, kaip jums gali
mačiau ar jau naudojamas

1719
01:26:14,410 --> 01:26:15,880
pašalinti arba kopijuoti failus.

1720
01:26:15,880 --> 01:26:18,920
Visi tie imtis vadinamasis
komandinės eilutės arguments--

1721
01:26:18,920 --> 01:26:21,130
papildomi žodžiai terminale eilutę.

1722
01:26:21,130 --> 01:26:23,260
Tačiau iki šiol mes
patys neturėjome

1723
01:26:23,260 --> 01:26:27,080
Šis prabangus imtis įėjimas iš
vartotojas, kai jis ar ji iš tikrųjų veikia

1724
01:26:27,080 --> 01:26:29,120
pati programa komandų eilutę.

1725
01:26:29,120 --> 01:26:33,710
>> Tačiau mes galime padaryti, kad iš naujo paskelbti
Pagrindinis juda į priekį, o ne kaip turintys

1726
01:26:33,710 --> 01:26:36,750
nebegalioti skliausteliuose,
bet šie du argumentai

1727
01:26:36,750 --> 01:26:40,600
instead-- pirmą sveikasis skaičius,
ir antra, ką

1728
01:26:40,600 --> 01:26:44,170
naujas, kažkas, kad mes ketiname skambinti
masyvas, kažkas panašaus dvasia

1729
01:26:44,170 --> 01:26:49,220
ką matėme nulio kaip sąrašą, bet
eilučių masyvas, kaip mes greitai pamatyti.

1730
01:26:49,220 --> 01:26:51,790
Bet pažiūrėkime, tai iki
Pavyzdžiui, kol mes

1731
01:26:51,790 --> 01:26:53,690
atskirti, ką tai reiškia.

1732
01:26:53,690 --> 01:26:56,520
>> Taigi, jei aš einu į CS50 IDE
čia aš nuėjo į priekį

1733
01:26:56,520 --> 01:27:01,840
ir deklaruojama failo pavadinimu
argv0.c šią šabloną.

1734
01:27:01,840 --> 01:27:04,120
Ir pastebėsite vienintelis dalykas
kad skiriasi tiek, kiek

1735
01:27:04,120 --> 01:27:08,570
yra tai, kad aš pasikeitė negaliojančiu, int
argc styginių argv atvirą laikiklį, netoli

1736
01:27:08,570 --> 01:27:09,070
laikiklis.

1737
01:27:09,070 --> 01:27:11,730
Ir pastebėti dabar, ten
nieko viduje tų skliausteliuose.

1738
01:27:11,730 --> 01:27:12,620
>> Nėra skaičius.

1739
01:27:12,620 --> 01:27:15,070
Ir ten ne i arba
N, arba bet kuri kita raidė.

1740
01:27:15,070 --> 01:27:17,010
Aš tiesiog naudojant
skliaustus dabar,

1741
01:27:17,010 --> 01:27:19,510
dėl priežasčių, mes ateiti
Atgal į vos akimirką.

1742
01:27:19,510 --> 01:27:21,330
>> O dabar ką aš ruošiuosi daryti tai.

1743
01:27:21,330 --> 01:27:26,680
Jei argc lygus lygus 2--
ir priminti, kad lygu lygu

1744
01:27:26,680 --> 01:27:30,040
yra lygybė operatorius lyginant
kairėje ir dešinėje lygybės.

1745
01:27:30,040 --> 01:27:31,790
Tai ne perleidimas
operatorius, kuris yra

1746
01:27:31,790 --> 01:27:36,510
vienintelis lygybės ženklas, kuris reiškia kopiją
iš dešinės į kairę tam tikrą vertę.

1747
01:27:36,510 --> 01:27:42,840
>> Jei argc lygus lygus 2, noriu
tarkim, printf, labas, procentai, nauja linija,

1748
01:27:42,840 --> 01:27:47,340
ir tada prijunkite in-- ir čia nauja
trick-- argv laikiklis 1 dėl priežasčių,

1749
01:27:47,340 --> 01:27:48,840
kad mes grįžti į iškart.

1750
01:27:48,840 --> 01:27:52,110
Else if argc nėra
lygus 2, žinote, ką?

1751
01:27:52,110 --> 01:27:57,400
Tegul tik eiti į priekį ir, kaip įprasta, spaudos
iš hello world be keitimą.

1752
01:27:57,400 --> 01:28:02,710
>> Taigi atrodytų, kad jei argc, kuris
reiškia argumentų skaičius, lygus 2,

1753
01:28:02,710 --> 01:28:04,740
Aš ruošiuosi atsispausdinti
labas kažkas ar kita.

1754
01:28:04,740 --> 01:28:07,560
Priešingu atveju, pagal nutylėjimą, aš
ketinate spausdinti Sveiki pasaulį.

1755
01:28:07,560 --> 01:28:08,770
Taigi, ką tai reiškia?

1756
01:28:08,770 --> 01:28:15,550
>> Na, leiskite man eiti į priekį ir sutaupyti
Šis failas, tada padarysiu argv0,

1757
01:28:15,550 --> 01:28:18,940
ir tada ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Ir ji sako hello world.

1759
01:28:20,300 --> 01:28:21,260
Dabar, kodėl taip yra?

1760
01:28:21,260 --> 01:28:24,730
>> Na, it turns out bet kada
paleisti programą komandų eilutėje,

1761
01:28:24,730 --> 01:28:29,570
pildote, ką mes
paprastai vadiname argumentas vektorių.

1762
01:28:29,570 --> 01:28:33,100
Kitaip tariant, automatiškai aktyvuojami
kompiuteris, operacinė sistema,

1763
01:28:33,100 --> 01:28:38,340
ketina įteikti savo programą
pati yra visi žodžiai sąrašas

1764
01:28:38,340 --> 01:28:40,850
kad žmogaus įvedėte ne
Paraginti tuo atveju, jei

1765
01:28:40,850 --> 01:28:43,790
programuotojas nori daryti
kažkas su šia informacija.

1766
01:28:43,790 --> 01:28:48,540
Ir šiuo atveju, vienintelis žodis
Aš įvedėte komandinėje eilutėje yra ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Ir taip keletą argumentų, kad yra
patektų į mano programa yra tik vienas.

1768
01:28:55,420 --> 01:28:58,880
Kitaip tariant, argumentas
skaičiuoti, kitaip žinomas kaip argc

1769
01:28:58,880 --> 01:29:00,970
čia kaip sveikasis skaičius, yra tik vienas.

1770
01:29:00,970 --> 01:29:03,000
Vienas, žinoma, nėra lygi du.

1771
01:29:03,000 --> 01:29:05,980
Ir todėl tai, ką spausdina, labas pasaulį.

1772
01:29:05,980 --> 01:29:08,170
>> Bet leiskite man pasinaudoti šia kažkur.

1773
01:29:08,170 --> 01:29:09,930
Leiskite man pasakyti, argv0.

1774
01:29:09,930 --> 01:29:12,740
Ir tada, kaip apie Maria?

1775
01:29:12,740 --> 01:29:14,990
Ir tada paspauskite Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Ir pastebėsite ką stebuklingai atsitinka čia.

1777
01:29:18,020 --> 01:29:22,640
Dabar, užuot hello world, turiu
pakeitė šią programą elgesį

1778
01:29:22,640 --> 01:29:26,310
atsižvelgiant įvestį ne iš vakaronė
eilutė arba kai kitas funkcijas,

1779
01:29:26,310 --> 01:29:30,570
o iš, matyt, mano komanda
pati, ką aš iš pradžių įvestas.

1780
01:29:30,570 --> 01:29:35,720
Ir aš galiu žaisti šį žaidimą vėl
jį pakeisti į STELIOS, pavyzdžiui.

1781
01:29:35,720 --> 01:29:38,400
>> Ir dabar matau kitą vardą dar.

1782
01:29:38,400 --> 01:29:40,540
Ir čia, sakyčiau Andi.

1783
01:29:40,540 --> 01:29:42,137
Ir galiu pasakyti Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Ir mes galime žaisti šį žaidimą visą dieną,
tiesiog įkišant į skirtingas vertybes,

1785
01:29:45,220 --> 01:29:49,550
taip ilgai, kaip aš suteikti tiksliai
du žodžiai komandinėje eilutėje,

1786
01:29:49,550 --> 01:29:52,260
toks, kad argc, mano argumentas skaičiuoti, yra 2.

1787
01:29:52,260 --> 01:29:57,240
>> Matau, kad vardas prijungtas prie
printf, už šią sąlygą čia?

1788
01:29:57,240 --> 01:30:00,550
Taigi, mes, atrodo, dabar
ekspresyvi galimybė

1789
01:30:00,550 --> 01:30:04,410
imtis įvestį iš kito mechanizmo,
iš vadinamojo komandinėje eilutėje,

1790
01:30:04,410 --> 01:30:07,000
o ne laukti
tol, kol vartotojas paleidžia programą,

1791
01:30:07,000 --> 01:30:10,220
ir tada paprašys jam ar jai
naudojant kažką panašaus get eilutę.

1792
01:30:10,220 --> 01:30:11,230
>> Taigi, kas tai yra?

1793
01:30:11,230 --> 01:30:15,010
Argc, vėlgi, yra tik sveikasis skaičius,
iš words-- arguments-- skaičius

1794
01:30:15,010 --> 01:30:18,540
kad vartotojas, jeigu ne
greitai, tuo terminalo langą,

1795
01:30:18,540 --> 01:30:20,110
įskaitant programos pavadinimą.

1796
01:30:20,110 --> 01:30:23,340
Taigi, mūsų ./argv0 yra, efektyviai,
kad programos pavadinimas,

1797
01:30:23,340 --> 01:30:24,520
arba kaip aš paleisti programą.

1798
01:30:24,520 --> 01:30:25,810
>> Kad skaičiuoja kaip žodis.

1799
01:30:25,810 --> 01:30:27,080
Taigi argc būtų 1 d.

1800
01:30:27,080 --> 01:30:29,750
Bet kai aš rašau Stelios arba
Ieva, ar Zamyla arba Marija,

1801
01:30:29,750 --> 01:30:31,660
tai reiškia, kad šis argumentas skaičius yra du.

1802
01:30:31,660 --> 01:30:33,910
Ir taip dabar ten du žodžiai praėjo per.

1803
01:30:33,910 --> 01:30:36,070
>> Ir pranešimas, mes galime tęsti šią logiką.

1804
01:30:36,070 --> 01:30:39,050
Jei aš iš tikrųjų pasakyti
kažkas panašaus Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
pilnas vardas, tuo artimųjų
trys argumentai iš viso

1806
01:30:42,200 --> 01:30:47,410
dabar ji sako numatytasis vėl
nes, žinoma, 3 nėra lygi 2.

1807
01:30:47,410 --> 01:30:54,080
>> Ir taip tokiu būdu, aš turiu
prieiga per argv tai naujas argumentas

1808
01:30:54,080 --> 01:30:56,080
kad galėtume techniškai
skambinti nieko mes norime.

1809
01:30:56,080 --> 01:30:58,940
Tačiau pagal susitarimą, tai
argv ir argc, atitinkamai.

1810
01:30:58,940 --> 01:31:04,470
Argv, argumentas vektorius, yra natūra
apie dėl programavimo sinonimas

1811
01:31:04,470 --> 01:31:07,140
funkcija C vadinamas masyvą.

1812
01:31:07,140 --> 01:31:14,410
>> Masyvas yra panašių verčių sąrašas
atgal, atgal, atgal, į nugarą.

1813
01:31:14,410 --> 01:31:17,810
Kitaip tariant, jei vienas yra čia į
RAM, kitas iš jų yra šalia jo,

1814
01:31:17,810 --> 01:31:18,800
ir šalia į jį.

1815
01:31:18,800 --> 01:31:20,101
Jie ne visur.

1816
01:31:20,101 --> 01:31:23,100
Ir tai pastarasis scenarijus, kur viskas
yra visame atminties vietoje,

1817
01:31:23,100 --> 01:31:25,082
iš tikrųjų gali būti galinga funkcija.

1818
01:31:25,082 --> 01:31:28,040
Bet mes grįžti į tą, kai mes
kalbėti apie mėgėjas duomenų struktūrų.

1819
01:31:28,040 --> 01:31:32,260
Nes dabar, masyvas yra tik
riekė gretimuose atminties,

1820
01:31:32,260 --> 01:31:36,520
kai kiekvieno iš jų elementai yra
atgal, atgal, atgal, atgal,

1821
01:31:36,520 --> 01:31:38,050
ir paprastai to paties tipo.

1822
01:31:38,050 --> 01:31:42,630
>> Taigi, jei jūs manote apie, nuo A
prieš momentas, kas yra eilutė?

1823
01:31:42,630 --> 01:31:50,460
Na, eilutė, kaip ir Zamyla,
Ž-A-M-Y-L-A, yra, techniškai,

1824
01:31:50,460 --> 01:31:51,400
tik masyvas.

1825
01:31:51,400 --> 01:31:53,700
Tai simbolių masyvas.

1826
01:31:53,700 --> 01:31:59,250
>> Ir todėl, jei mes tikrai atkreipia į tai, kaip aš
darė anksčiau, kaip atminties riekė,

1827
01:31:59,250 --> 01:32:04,510
ji Pasirodo, kad kiekvienas iš jų
simbolių užima baitas.

1828
01:32:04,510 --> 01:32:07,630
Ir tada ten, kad ypatingas
Sentinel pobūdį, Backslash 0,

1829
01:32:07,630 --> 01:32:12,360
ar visi aštuoni 0 bitai, kad
pažymėtų tos eilutės pabaigą.

1830
01:32:12,360 --> 01:32:15,090
Taigi seka, paaiškėja
iš, cituoti citatos pabaiga eilutę,

1831
01:32:15,090 --> 01:32:20,580
yra tik iš chara-- masyvo
char yra faktinis duomenų tipas.

1832
01:32:20,580 --> 01:32:24,560
>> Ir dabar argv, meanwhile--
grįžkime prie programos.

1833
01:32:24,560 --> 01:32:29,582
Argv, nors matome žodį
eilutė čia nėra pati eilutė.

1834
01:32:29,582 --> 01:32:33,640
Argv, argumentas vektorius,
yra eilučių masyvas.

1835
01:32:33,640 --> 01:32:37,620
>> Taigi kaip jūs galite turėti iš masyvo
simbolių, jūs galite turėti aukštesnio lygio,

1836
01:32:37,620 --> 01:32:46,279
iš strings-- masyvo taip, pavyzdžiui,
kai aš įvedėte akimirką prieš ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, erdvė Ž-A-M-Y-L-A, aš teigiama, kad
argv turėjo dvi eilutes į it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
ir Z-A-M-Y-L-A. į
Kitaip tariant, argc buvo 2.

1839
01:33:03,185 --> 01:33:03,980
Kodėl taip yra?

1840
01:33:03,980 --> 01:33:08,370
>> Na, iš tikrųjų, kas vyksta
dėl yra tai, kad kiekvienas iš šių stygos

1841
01:33:08,370 --> 01:33:13,990
yra, žinoma, yra simbolių masyvo
Kaip ir anksčiau, kiekvienas iš kurių simbolių

1842
01:33:13,990 --> 01:33:15,670
užima vieną baitą.

1843
01:33:15,670 --> 01:33:19,720
Ir nepainiokite faktinį 0
Į programos pavadinimo su 0,

1844
01:33:19,720 --> 01:33:22,040
o tai reiškia, visus 80 bitai.

1845
01:33:22,040 --> 01:33:27,140
Ir Zamyla, tuo tarpu, vis dar
taip pat yra simbolių masyvas.

1846
01:33:27,140 --> 01:33:31,450
>> Būdamas dienos pabaigoje, tai tikrai
atrodo taip po gaubtu.

1847
01:33:31,450 --> 01:33:38,800
Bet argv iš prigimties, kaip pagrindinis
darbai, leidžia man, į kuriuos vyniojami visa tai

1848
01:33:38,800 --> 01:33:44,810
aukštyn į, jei norite, kad padidintumėte masyvo
, kad jei mes šiek tiek daugiau nei supaprastinti

1849
01:33:44,810 --> 01:33:48,180
kas vaizdas išvaizda ir nėra
gana piešti masto ten,

1850
01:33:48,180 --> 01:33:56,720
šio masyvo yra tik 2 dydžio, pirmasis
elementas, kuris yra eilutę,

1851
01:33:56,720 --> 01:33:59,230
antrasis elementas
kuriame yra eilutė.

1852
01:33:59,230 --> 01:34:01,687
Ir, savo ruožtu, jei tau
rūšies priartinti kiekvieną

1853
01:34:01,687 --> 01:34:03,770
tų stygų, ką
matyti po gaubtu

1854
01:34:03,770 --> 01:34:07,190
yra tai, kad kiekvienas eilutė yra tik
simbolių masyvas.

1855
01:34:07,190 --> 01:34:11,680
>> Dabar, kaip ir su stygos,
mes galėjome gauti prieigą

1856
01:34:11,680 --> 01:34:15,260
prie i-tojo požymio eilutę
naudojant tą kvadratinių laikiklis notacijos.

1857
01:34:15,260 --> 01:34:17,320
Panašiai, su matricomis
apskritai, mes galime

1858
01:34:17,320 --> 01:34:22,700
naudoti kvadratinių laikiklis notacijos gauti
bet kuriuo stygų skaičius masyve?

1859
01:34:22,700 --> 01:34:25,100
Pavyzdžiui, leiskite man
eiti į priekį ir tai padaryti.

1860
01:34:25,100 --> 01:34:32,420
>> Leiskite man eiti į priekį ir kurti argv1.c,
kuris yra šiek tiek kitoks šį kartą.

1861
01:34:32,420 --> 01:34:35,635
Vietoj tikrinti argc2,
Aš ruošiuosi vietoj tai padaryti.

1862
01:34:35,635 --> 01:34:41,270
Dėl INT gaunu 0, I mažiau
nei argc, aš plius plius,

1863
01:34:41,270 --> 01:34:47,920
ir tada spausdinti viduje tai,
proc S, nauja linija, ir tada

1864
01:34:47,920 --> 01:34:50,740
argv laikiklis aš.

1865
01:34:50,740 --> 01:34:55,220
>> Taigi, kitaip tariant, aš ne su
atskirus simbolius šiuo metu.

1866
01:34:55,220 --> 01:35:00,190
Argv, kaip teigiama šių tuščių aikštėje
petnešos su vardo argv teise,

1867
01:35:00,190 --> 01:35:03,320
reiškia argv yra eilučių masyvas.

1868
01:35:03,320 --> 01:35:04,870
Ir argc yra tik int.

1869
01:35:04,870 --> 01:35:08,800
>> čia tai linija, 6, yra
sakydamas rinkinį i lygi 0.

1870
01:35:08,800 --> 01:35:11,980
Count visą kelią iki,
bet ne taip, argc.

1871
01:35:11,980 --> 01:35:14,010
Ir tada ant kiekvienos iteracijos,
spausdinti eilutę.

1872
01:35:14,010 --> 01:35:14,800
Kas seka?

1873
01:35:14,800 --> 01:35:17,270
>> I-oji eilutė į argv.

1874
01:35:17,270 --> 01:35:19,530
Taigi o prieš buvau
naudojant kvadratinę laikiklį

1875
01:35:19,530 --> 01:35:22,180
notacija gauti ne i-tojo
personažas eilutę, dabar

1876
01:35:22,180 --> 01:35:27,240
Aš naudoju kvadratinių laikiklis notacijos
gauti ne i-tojo eilutę masyvo.

1877
01:35:27,240 --> 01:35:30,310
Taigi tai tipo vieno sluoksnio
pirmiau, konceptualiai.

1878
01:35:30,310 --> 01:35:35,390
>> Ir taip kas tvarkingas apie tai
Programa dabar, jei aš parengia argv1,

1879
01:35:35,390 --> 01:35:42,067
ir tada daryti ./argv1, tada įveskite
kažką panašaus į foo bar Baz,

1880
01:35:42,067 --> 01:35:45,400
kuri yra trys numatytieji žodžiai, kad
kompiuterių mokslininkas pasiekia bet kuriuo metu

1881
01:35:45,400 --> 01:35:51,010
jis ar ji turi keletą rezervuotųjų žodžius,
ir paspauskite "Enter", kiekvienas iš šių žodžių,

1882
01:35:51,010 --> 01:35:54,980
įskaitant programos pavadinimą, kuri
yra argv tuo pirmosios buvimo,

1883
01:35:54,980 --> 01:35:58,320
baigiasi spausdinamas vienu metu.

1884
01:35:58,320 --> 01:36:05,290
Ir jei aš tai pakeisti, ir aš sakau,
kažkas panašaus argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
mes visi tie trys
žodžiai, kurie yra argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, nes tai
atveju argc, kad skaičius yra 3.

1887
01:36:14,400 --> 01:36:20,020
>> Bet kas tvarkingas, jei jūs suprantate
kad argv yra tik eilučių masyvas,

1888
01:36:20,020 --> 01:36:24,910
ir jūs suprantate, kad seka
yra simbolių masyvas,

1889
01:36:24,910 --> 01:36:29,470
mes iš tikrųjų gali rūšies naudoti šį
kvadratinių laikiklis notacijos kelis kartus

1890
01:36:29,470 --> 01:36:33,320
pasirinkti eilutę, tada pasirinkite
personažas per eilutę,

1891
01:36:33,320 --> 01:36:35,730
nardymo giliau taip.

1892
01:36:35,730 --> 01:36:40,100
Šiame pavyzdyje, leiskite man eiti
į priekį ir tai vadina argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Ir šiame pavyzdyje, leiskite man eiti į priekį
ir padaryti following-- už INT gaunu 0,

1895
01:36:50,180 --> 01:36:53,286
i yra mažiau nei argc, i plius
Be to, kaip ir anksčiau.

1896
01:36:53,286 --> 01:36:55,910
Taigi kitose words-- o dabar tai
gauna pakankamai sudėtinga.

1897
01:36:55,910 --> 01:36:59,940
Tada aš ruošiuosi pasakyti
pakartoti per styginiams argv,

1898
01:36:59,940 --> 01:37:01,294
kaip komentaras save.

1899
01:37:01,294 --> 01:37:03,960
Ir tada aš ruošiuosi turėti
įdėtos for ciklas, kuris tikriausiai

1900
01:37:03,960 --> 01:37:06,290
padariau, ar laikomas
daro, kad nulio, kur

1901
01:37:06,290 --> 01:37:08,600
Aš ruošiuosi pasakyti int-- aš
nesiruošia aš naudoju vėl

1902
01:37:08,600 --> 01:37:12,590
nes aš nenoriu šešėlis, arba
rūšiuoti perrašyti esamą i.

1903
01:37:12,590 --> 01:37:15,780
>> Aš ruošiuosi, o ne, tarkim, j, nes
kad mano Eiti į kintamąjį po i,

1904
01:37:15,780 --> 01:37:18,590
kai aš tiesiog bando
skaičiuoti paprastus numerius.

1905
01:37:18,590 --> 01:37:28,850
J gauna 0-- ir, N, ketina
gauti laivagalio ilgis argv laikiklio i,

1906
01:37:28,850 --> 01:37:36,030
tol, kol j yra mažiau nei m,
j plius plius, atlikite šiuos veiksmus.

1907
01:37:36,030 --> 01:37:37,500
Ir čia įdomiausia dalis.

1908
01:37:37,500 --> 01:37:46,330
>> Atsispausdinti charakterį ir naują eilutę,
prijungti argv laikiklio i kronšteino j.

1909
01:37:46,330 --> 01:37:47,940
Gerai, todėl leiskite man pridėti keletą pastabų čia.

1910
01:37:47,940 --> 01:37:54,820
Pakartoti per simbolius
dabartinėje eilutę,

1911
01:37:54,820 --> 01:38:02,290
Spausdinti j-osios personažas i-osios eilutės.

1912
01:38:02,290 --> 01:38:04,630
Taigi dabar aptarkime
Ką šie komentarai galvoje.

1913
01:38:04,630 --> 01:38:06,750
>> Pakartoti per stygas
į argv-- kiek

1914
01:38:06,750 --> 01:38:09,300
Stygos yra argv, kuris yra masyvas?

1915
01:38:09,300 --> 01:38:13,420
Argc daug, todėl aš Iteracja
iš I lygus 0 iki argc.

1916
01:38:13,420 --> 01:38:20,020
Tuo tarpu, kiek simbolių
yra i-osios eilutės į argv?

1917
01:38:20,020 --> 01:38:22,880
>> Na, jei norite gauti atsakymą
Aš tiesiog paskambinkite string ilgis

1918
01:38:22,880 --> 01:38:26,810
Dėl dabartinės styginių I priežiūra
apie, kuris yra argv kronšteinas i.

1919
01:38:26,810 --> 01:38:30,090
Ir aš ruošiuosi laikinai saugoti, kad
vertė n, tik spartinimo tikslais,

1920
01:38:30,090 --> 01:38:31,590
prisiminti jį efektyvumą.

1921
01:38:31,590 --> 01:38:36,330
Ir tada aš ruošiuosi inicijuoti j 0,
nuolat vyksta tol, kol j yra mažiau nei N,

1922
01:38:36,330 --> 01:38:38,430
ir ant kiekvienos iteracijos prieaugio j.

1923
01:38:38,430 --> 01:38:41,030
>> Ir tada čia, už
mano komentaras on-line 12

1924
01:38:41,030 --> 01:38:43,390
spausdinti simbolį,
po to naujai linijai,

1925
01:38:43,390 --> 01:38:48,140
specialiai argv laikiklis
Aš suteikia man I-oji eilutę

1926
01:38:48,140 --> 01:38:51,690
į argv-- Taigi pirmas tariant,
Antrasis žodis, trečias žodis, nesvarbu.

1927
01:38:51,690 --> 01:38:57,370
Ir tada j neria į giliau, ir gauna
man j-osios pobūdis šio žodžio.

1928
01:38:57,370 --> 01:39:02,200
Ir taip, iš tikrųjų, jūs galite gydyti
argv kaip įvairialypei,

1929
01:39:02,200 --> 01:39:06,050
kaip dvimatis, masyvas,
kuriuo kiekvienas žodis rūšies išvaizda

1930
01:39:06,050 --> 01:39:08,580
kaip tai savo proto
akis, ir kiekvienas personažas

1931
01:39:08,580 --> 01:39:10,930
rūšies sudarytas
stulpelis, jei tai padeda.

1932
01:39:10,930 --> 01:39:13,260
>> Iš tikrųjų, kai mes erzinti
tai be ateities savaites

1933
01:39:13,260 --> 01:39:15,580
tai bus šiek tiek
sudėtingesnės nei tai.

1934
01:39:15,580 --> 01:39:17,800
Bet jūs tikrai gali
galvoja, kad dabar,

1935
01:39:17,800 --> 01:39:22,110
kaip tik tai dvimatis
masyvas, kai vienas lygis jame

1936
01:39:22,110 --> 01:39:23,260
yra visi stygos.

1937
01:39:23,260 --> 01:39:26,760
Ir tada, jei jūs pasinerti giliau, jums
gali gauti ne atskirų simbolių

1938
01:39:26,760 --> 01:39:29,600
jame, naudojant šį formatą čia.

1939
01:39:29,600 --> 01:39:31,620
>> Taigi, kas yra grynasis poveikis?

1940
01:39:31,620 --> 01:39:34,970
Leiskite man eiti į priekį ir
padaryti argv2-- darn ją.

1941
01:39:34,970 --> 01:39:36,210
Aš padariau klaidą čia.

1942
01:39:36,210 --> 01:39:40,160
Netiesiogiai paskelbiant
bibliotekos funkcija Stirling.

1943
01:39:40,160 --> 01:39:42,190
Taigi visą šį laiką, tai
gal reikia

1944
01:39:42,190 --> 01:39:45,130
kad mes tarsi apdailos
tiksliai ten, kur pradėjome.

1945
01:39:45,130 --> 01:39:48,160
>> Aš įsukus, netiesiogiai teigiama,
bibliotekos funkcija Stirling.

1946
01:39:48,160 --> 01:39:48,987
Gerai, palauk.

1947
01:39:48,987 --> 01:39:51,070
Prisimenu, kad ypač
nes tai čia.

1948
01:39:51,070 --> 01:39:54,490
Man reikia įtraukti string.h į
Ši programos versija.

1949
01:39:54,490 --> 01:40:00,050
>> Leiskite man eiti į priekį ir taip pat
string.h, išskyrus, kad eiti į priekį

1950
01:40:00,050 --> 01:40:04,460
ir perkompiliuoti argv2.

1951
01:40:04,460 --> 01:40:08,390
Ir dabar, čia mes einame, kad argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Ir nors tai šiek tiek
paslaptingas iš pirmo žvilgsnio,

1953
01:40:10,590 --> 01:40:15,690
pastebėti, kad, tiesą sakant, tai, ką
spausdinamas yra taškas argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Bet jei aš tipo kai po žodžių
greitai, kaip argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Taip pat Įveskite, šiek tiek
paslaptingas iš pirmo žvilgsnio.

1956
01:40:22,560 --> 01:40:30,540
Bet jei mes slinkti atgal iki,
./argv2 Ž-A-M-Y-L-A, C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Taigi mes pakartota per kiekvieną žodį.

1958
01:40:32,190 --> 01:40:37,770
Ir, savo ruožtu, mes pakartota per
kiekvienas personažas per žodį.

1959
01:40:37,770 --> 01:40:40,040
>> Dabar, po to, kai visa tai,
suprasti, kad ten

1960
01:40:40,040 --> 01:40:43,120
vienas kitas detalė mes jau natūra
ignoruojant visą šį laiką.

1961
01:40:43,120 --> 01:40:46,180
Mes tiesiog erzino, išskyrus tai, kas
Pagrindinė anketa įėjimai gali būti?

1962
01:40:46,180 --> 01:40:47,780
Ką apie pagrindinių produkcijos?

1963
01:40:47,780 --> 01:40:50,540
>> Visi šiuo metu, mes buvome
tiesiog kopijuodami

1964
01:40:50,540 --> 01:40:53,870
žodis INT priešais pagrindinė,
nors galite pamatyti internete,

1965
01:40:53,870 --> 01:40:58,340
kartais neteisingai senesnių versijų
C ir kompiliatoriai, kad jie sako, tuščia,

1966
01:40:58,340 --> 01:40:59,410
arba visai nieko.

1967
01:40:59,410 --> 01:41:01,580
Bet, tiesą sakant, nes versija
C, kad mes naudojame,

1968
01:41:01,580 --> 01:41:06,180
C 11, arba 2011, reikia suprasti,
kad ji turėtų būti INT.

1969
01:41:06,180 --> 01:41:09,300
Ir tai turėtų būti arba
negaliojantis, arba argc ir argv čia.

1970
01:41:09,300 --> 01:41:10,790
>> Bet kodėl int main?

1971
01:41:10,790 --> 01:41:12,480
Ką ji iš tikrųjų grįžta?

1972
01:41:12,480 --> 01:41:16,280
Gerai, tai Pasirodo, visą šį laiką,
bet kada parašiau programa Pagrindinis

1973
01:41:16,280 --> 01:41:18,440
visada grįžta kažkas.

1974
01:41:18,440 --> 01:41:19,960
Bet tai buvo daroma taip slaptai.

1975
01:41:19,960 --> 01:41:23,350
>> Kad kažkas yra
INT, nes linijos 5 rodo.

1976
01:41:23,350 --> 01:41:24,225
Bet kas int?

1977
01:41:24,225 --> 01:41:26,100
Na, ten tai
Konvencija programavimo,

1978
01:41:26,100 --> 01:41:29,790
kuriuo, jei nieko
negerai ir viskas yra gerai,

1979
01:41:29,790 --> 01:41:34,250
programos ir funkcijos paprastai
return-- šiek tiek counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 paprastai reiškia viskas yra gerai.

1982
01:41:38,070 --> 01:41:40,610
Taigi, nors jūs manote
tai kaip klaidinga daugelyje kontekstų,

1983
01:41:40,610 --> 01:41:42,930
ji iš tikrųjų paprastai reiškia geras dalykas

1984
01:41:42,930 --> 01:41:49,560
>> Tuo tarpu, jei programa grąžina 1,
arba neigiamas 1, arba 5, arba neigiamas 42,

1985
01:41:49,560 --> 01:41:52,941
ar ne 0 vertė,
kad paprastai reiškia

1986
01:41:52,941 --> 01:41:54,190
kad kažkas negerai.

1987
01:41:54,190 --> 01:41:56,700
Tiesą sakant, dėl savo Mac arba PC,
galbūt iš tikrųjų matė

1988
01:41:56,700 --> 01:42:01,050
klaidos pranešimas, pagal kurį jį
sako kažką ar kita, klaidos

1989
01:42:01,050 --> 01:42:04,940
kodas neigiamas 42 arba klaidos kodas
23, ar kažkas panašaus.

1990
01:42:04,940 --> 01:42:08,980
Šis skaičius paprastai yra tik užuomina
į programuotojas, ar bendrovė

1991
01:42:08,980 --> 01:42:11,174
kad padarė programinę įrangą,
kas nutiko ir kodėl,

1992
01:42:11,174 --> 01:42:13,590
taip, kad jie gali pažvelgti pro
jų dokumentai ar kodas,

1993
01:42:13,590 --> 01:42:15,465
ir išsiaiškinti, kas
klaida iš tikrųjų reiškia.

1994
01:42:15,465 --> 01:42:18,400
Tai paprastai nėra
naudinga mums galutiniams vartotojams.

1995
01:42:18,400 --> 01:42:20,550
>> Bet kai pagrindiniai grįžta 0, viskas yra gerai.

1996
01:42:20,550 --> 01:42:23,770
Ir jei nenurodysite
Kokios pagrindinės turėtų grįžti,

1997
01:42:23,770 --> 01:42:26,950
Jis tiesiog automatiškai
grįžti 0 už jus.

1998
01:42:26,950 --> 01:42:30,870
Bet grįžtant kažką
dar yra iš tikrųjų naudinga.

1999
01:42:30,870 --> 01:42:34,660
>> Baigiamajame programos, leiskite man
eiti į priekį ir tai vadina exit.c,

2000
01:42:34,660 --> 01:42:38,630
ir pristatyti paskutinis šiandien
temos, žinomas kaip klaidos kodu.

2001
01:42:38,630 --> 01:42:42,930
Leiskite man eiti į priekį ir taip pat mūsų
pažįstami failus iki viršaus, tai int main.

2002
01:42:42,930 --> 01:42:49,500
Ir šį kartą, darykime int argc,
styginių argv ir su mano skliausteliuose

2003
01:42:49,500 --> 01:42:50,836
tai nereiškia, kad jis yra masyve.

2004
01:42:50,836 --> 01:42:52,460
Ir tada leiskite man tiesiog padaryti naudojama logiškai patikrinimą.

2005
01:42:52,460 --> 01:42:56,640
Šį kartą, jei argc nėra
lygus 2, tuomet jūs žinote, ką?

2006
01:42:56,640 --> 01:42:57,520
Pamiršk tai.

2007
01:42:57,520 --> 01:43:03,170
Aš einu pasakyti, kad, ei, vartotojas,
Jums trūksta komandinės eilutės argumentus

2008
01:43:03,170 --> 01:43:04,210
Backslash N.

2009
01:43:04,210 --> 01:43:05,230
>> Ir tada viskas.

2010
01:43:05,230 --> 01:43:06,130
Noriu, kad išeitumėte.

2011
01:43:06,130 --> 01:43:11,030
Aš einu Preemptively,
ir per anksti tikrai, grąžinimas

2012
01:43:11,030 --> 01:43:12,810
nors kitu nei skaičiumi 1.

2013
01:43:12,810 --> 01:43:15,360
Eiti į vertės pirmas
klaida, kad gali atsitikti yra 1.

2014
01:43:15,360 --> 01:43:17,860
Jei turite kai kurie kiti klaidingi
situacija, kuri gali atsirasti,

2015
01:43:17,860 --> 01:43:21,390
galima sakyti grąžą 2 arba grąžinti 3 arba
gal net neigiamas 1 arba neigiamas 2.

2016
01:43:21,390 --> 01:43:23,750
>> Tai yra tik išėjimo kodai
kad yra, paprastai,

2017
01:43:23,750 --> 01:43:27,770
naudinga tik programuotojas, arba
įmonė, laivybos programinę įrangą.

2018
01:43:27,770 --> 01:43:30,500
Bet faktas, kad tai
ne 0 yra tai, kas svarbu.

2019
01:43:30,500 --> 01:43:34,310
Taigi, jei šioje programoje, aš noriu
užtikrinti, kad ši programa tik

2020
01:43:34,310 --> 01:43:38,190
veikia, jei vartotojas suteikia man
su argumentų skaičiaus dviejų,

2021
01:43:38,190 --> 01:43:42,880
programos pavadinimas, ir kai kurių kitų
žodis, galiu užtikrinti, kiek taip,

2022
01:43:42,880 --> 01:43:46,110
klykauti vartotojas su printf žodžių
trūksta komandinės eilutės argumentus,

2023
01:43:46,110 --> 01:43:46,970
return 1.

2024
01:43:46,970 --> 01:43:49,940
Tai tiesiog iš karto
mesti programą.

2025
01:43:49,940 --> 01:43:55,840
>> Tik jei argc lygus 2 mes kibti
Čia, kuriame taškas aš ruošiuosi pasakyti,

2026
01:43:55,840 --> 01:44:00,410
Sveiki proc s Backslash n argv1.

2027
01:44:00,410 --> 01:44:03,827
Kitaip tariant, aš
nesiruošia po argv 0,

2028
01:44:03,827 --> 01:44:05,410
kuris yra tik programos pavadinimas.

2029
01:44:05,410 --> 01:44:09,450
Noriu atsispausdinti Sveiki, kablelis,
antras žodis, kad žmogaus įvedėte.

2030
01:44:09,450 --> 01:44:12,580
Ir šiuo atveju dėl
linija 13, viskas yra gerai.

2031
01:44:12,580 --> 01:44:15,920
>> Žinau, kad argc yra 2
logiškai iš šios programos.

2032
01:44:15,920 --> 01:44:17,770
Aš ruošiuosi eiti į priekį ir atgal 0.

2033
01:44:17,770 --> 01:44:21,230
Kaip panaikinti, reikia nepamiršti, kad
tai yra tiesa nulio, taip pat.

2034
01:44:21,230 --> 01:44:24,760
>> Logiškai mąstant, galėčiau tai padaryti
ir viską, šias eilutes

2035
01:44:24,760 --> 01:44:27,020
kodo šioje kitam sąlygą čia.

2036
01:44:27,020 --> 01:44:29,420
Bet tai tarsi
be reikalo atitraukdami savo kodą.

2037
01:44:29,420 --> 01:44:31,800
Ir aš noriu, kad super
aišku, kad nesvarbu, ką,

2038
01:44:31,800 --> 01:44:34,670
pagal nutylėjimą, labas
kažkas bus gauti išspausdintas,

2039
01:44:34,670 --> 01:44:36,050
taip ilgai, kol vartotojas bendradarbiauja.

2040
01:44:36,050 --> 01:44:39,360
>> Taigi tai labai įprasta naudoti
sąlyga, tik jei

2041
01:44:39,360 --> 01:44:41,870
sugauti kai klaidinga
situacija, ir tada išeiti.

2042
01:44:41,870 --> 01:44:45,690
Ir tada, kol viskas yra
Na, ne turėti kitas,

2043
01:44:45,690 --> 01:44:48,060
bet tiesiog kodą
ne, kad jei, nes tai

2044
01:44:48,060 --> 01:44:51,060
ekvivalentas tai
konkrečiu atveju, logiškai.

2045
01:44:51,060 --> 01:44:54,480
Taigi, aš grįžta 0, tik
aiškiai reikšti viskas yra gerai.

2046
01:44:54,480 --> 01:44:58,480
>> Jei aš praleisti grįžimą 0, tai
automatiškai prisiėmė už mane.

2047
01:44:58,480 --> 01:45:00,890
Bet dabar, kad aš grįžimas
vienas iš ne mažiau kaip šiuo atveju,

2048
01:45:00,890 --> 01:45:04,940
Aš ruošiuosi, gera priemonė ir
aiškumas, grįžti 0. Šiuo atveju.

2049
01:45:04,940 --> 01:45:09,690
Taigi dabar leiskite man eiti į priekį ir padaryti išėjimą,
kuris yra puikus Segue tiesiog palikti.

2050
01:45:09,690 --> 01:45:14,401
>> Tačiau įsitikinkite, išvežimo, ir leiskite man eiti
į priekį ir daryti ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Ir programa rėkė ant manęs,
trūksta komandinės eilutės argumentus.

2052
01:45:16,900 --> 01:45:18,120
Gerai, leiskite man bendradarbiauti.

2053
01:45:18,120 --> 01:45:23,810
>> Leiskite vietoj padaryti ./exit, Dovydas Enter.

2054
01:45:23,810 --> 01:45:25,190
Ir dabar ji sako, labas Davidas.

2055
01:45:25,190 --> 01:45:27,300
Ir tai būtų ne paprastai pamatyti tai.

2056
01:45:27,300 --> 01:45:30,650
>> Tačiau paaiškėja, kad yra
ypatingu būdu Linux realiai pamatyti

2057
01:45:30,650 --> 01:45:34,470
su tuo, ką išeiti kodas programa išėjo.

2058
01:45:34,470 --> 01:45:37,184
Kartais grafinę
pasaulis kaip Mac OS arba Windows

2059
01:45:37,184 --> 01:45:40,100
matysite tik šiuos numerius, kai
klaidos pranešimas pasirodo ekrane

2060
01:45:40,100 --> 01:45:41,940
ir programuotojas
rodo, kad numeris.

2061
01:45:41,940 --> 01:45:44,773
Bet jei mes norime pamatyti, ką klaidą
pranešimas, mes galime tai padaryti here--

2062
01:45:44,773 --> 01:45:48,100
taip ./exit, Enter Spausdinti
trūksta komandinės eilutės argumentus.

2063
01:45:48,100 --> 01:45:54,590
>> Jei aš dabar daryti echo $ ?, kuris yra
juokingai paslaptingas ieško.

2064
01:45:54,590 --> 01:45:56,590
Bet $?

2065
01:45:56,590 --> 01:45:59,220
yra magiškas užkalbėjimas
kad sako, ei, kompiuteris,

2066
01:45:59,220 --> 01:46:01,900
pasakykite man, ką ankstesnis
Programos išeiti kodas buvo.

2067
01:46:01,900 --> 01:46:03,410
Ir aš paspauskite Enter.

2068
01:46:03,410 --> 01:46:07,520
Matau 1, nes tai, ką aš
papasakojo mano pagrindinė funkcija grįžti.

2069
01:46:07,520 --> 01:46:12,310
>> Tuo tarpu, jei aš ./exit Dovydą,
ir paspauskite Enter, matau, hello Dovydą.

2070
01:46:12,310 --> 01:46:16,800
Ir jeigu aš dabar daryti echo $ ?, matau labas 0.

2071
01:46:16,800 --> 01:46:19,080
Ir todėl tai tikrai bus
būti vertingos informacijos

2072
01:46:19,080 --> 01:46:23,420
į derintuvės kontekste, ne taip
daug, kad jūs, žmogaus, būtų nerūpi.

2073
01:46:23,420 --> 01:46:26,060
Bet derintojas ir kita
programos mes naudosime šį semestrą

2074
01:46:26,060 --> 01:46:29,420
dažnai atrodo tuo numeriu,
nors tai tarsi paslėptas

2075
01:46:29,420 --> 01:46:32,780
nebent jums atrodo už jį, kad
nustatyti, ar programa s, ar ne

2076
01:46:32,780 --> 01:46:37,050
vykdymas buvo teisinga ar neteisinga.

2077
01:46:37,050 --> 01:46:40,450
>> Ir taip, kad duoda mums
tai, tuo dienos pabaigoje.

2078
01:46:40,450 --> 01:46:43,917
Mes pradėjome šiandien, žiūrėdamas
derinimo, ir savo ruožtu į kursą

2079
01:46:43,917 --> 01:46:46,750
pati, ir tada daugiau Įdomu,
techniškai po gaubtu

2080
01:46:46,750 --> 01:46:49,490
ką stygos, kuris truks
savaitę mes tiesiog paėmė už suteiktas,

2081
01:46:49,490 --> 01:46:51,900
ir, žinoma, paėmė juos
už suteiktas nulio.

2082
01:46:51,900 --> 01:46:56,040
>> Tada pažvelgė, kaip mes galime prieiti prie
individualūs simbolių eilutę,

2083
01:46:56,040 --> 01:47:00,310
ir vėl paėmė aukštesnio lygio
pažvelgti į dalykus, ieškome būdų, kaip well--

2084
01:47:00,310 --> 01:47:04,226
jei norime gauti ne atskirų
elementai sąrašą panašią struktūrą,

2085
01:47:04,226 --> 01:47:05,850
mes negalime padaryti, kad su keliais stygos?

2086
01:47:05,850 --> 01:47:08,050
Ir mes galime su komandinės eilutės argumentus.

2087
01:47:08,050 --> 01:47:12,800
Bet ši nuotrauka čia tik iš dėžių
yra demonstratyvus šios bendros idėjos

2088
01:47:12,800 --> 01:47:14,451
masyvo, arba sąrašą, arba vektorių.

2089
01:47:14,451 --> 01:47:16,450
Ir priklausomai nuo
konteksto, visi šie žodžiai

2090
01:47:16,450 --> 01:47:17,880
reiškia šiek tiek skirtingus dalykus.

2091
01:47:17,880 --> 01:47:20,060
Taigi C, mes tik ketina
kalbėti apie masyvą.

2092
01:47:20,060 --> 01:47:23,840
Ir masyvas yra riekė
atminties, iš kurių kiekvienas yra

2093
01:47:23,840 --> 01:47:27,720
elementai yra greta, nugaros,
atgal, atgal, į nugarą.

2094
01:47:27,720 --> 01:47:31,970
>> Ir tie elementai yra, paprastai,
tos pačios duomenų tipą, charakteris,

2095
01:47:31,970 --> 01:47:35,966
charakteris, charakteris, charakteris, arba
eilutė, styginių, styginių, styginių, ar INT,

2096
01:47:35,966 --> 01:47:38,600
INT, INT, kokia ji yra
mes bandome parduotuvėje.

2097
01:47:38,600 --> 01:47:42,540
Tačiau tuo dienos pabaigoje, tai yra
kaip jis atrodo konceptualiai.

2098
01:47:42,540 --> 01:47:44,530
Jūs vartojate savo
kompiuterio atmintyje arba atminties.

2099
01:47:44,530 --> 01:47:48,590
Ir jūs drožyba jį į
identiškai dydžio dėžės, kurios visos

2100
01:47:48,590 --> 01:47:50,920
atgal, atgal, į
atgal, atgal, tokiu būdu.

2101
01:47:50,920 --> 01:47:53,200
>> Ir kas malonu apie
ši idėja, ir tai,

2102
01:47:53,200 --> 01:47:58,580
kad galėtume išreikšti vertes, tokiu būdu
su pirmuoju iš mūsų duomenų struktūrų

2103
01:47:58,580 --> 01:48:02,520
klasėje, reiškia, mes galime pradėti
spręsti problemas, su kodu

2104
01:48:02,520 --> 01:48:04,079
kad atėjo tiek intuityviai per savaitę 0.

2105
01:48:04,079 --> 01:48:05,870
Jūs priminti telefoną
knyga pavyzdys, kur

2106
01:48:05,870 --> 01:48:09,110
mes panaudojome skaldyk ir valdyk,
arba dvejetainis paieškos algoritmas,

2107
01:48:09,110 --> 01:48:13,220
atsijoti per visa
krūva vardus ir numerius.

2108
01:48:13,220 --> 01:48:18,220
Bet mes prielaida, prisiminti, kad
telefonų knyga jau buvo rūšiuojamos,

2109
01:48:18,220 --> 01:48:21,630
kad kažkas jau turėjo
figured out-- suteikta pavardžių sąrašas

2110
01:48:21,630 --> 01:48:24,430
ir numbers-- kaip juos abėcėlę.

2111
01:48:24,430 --> 01:48:26,950
Ir dabar, kad C mes,
taip pat turi galimybę

2112
01:48:26,950 --> 01:48:30,290
nustatyti dalykus, o ne
fiziškai telefono knygos

2113
01:48:30,290 --> 01:48:34,220
bet praktiškai iš kompiuterio
atmintis, galėsime kitą savaitę

2114
01:48:34,220 --> 01:48:38,470
vėl pristatyti this-- pirmas
mūsų duomenų struktūras į array--

2115
01:48:38,470 --> 01:48:43,530
bet dar svarbiau, tikrasis kompiuteris
mokslo algoritmai įgyvendinami

2116
01:48:43,530 --> 01:48:47,720
kodu, su kuria mes galime laikyti
duomenų struktūrų, pavyzdžiui, tai,

2117
01:48:47,720 --> 01:48:50,730
ir tada pradėti jį manipuliuoti, ir
realiai spręsti problemas su juo,

2118
01:48:50,730 --> 01:48:53,570
ir statyti ant to,
galiausiai, programos C,

2119
01:48:53,570 --> 01:48:56,730
Python, JavaScript,
užklausų duomenų bazių SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Ir mes matome, kad visi jie
įvairių idėjų blokavimo.

2121
01:48:59,980 --> 01:49:04,100
Bet dabar, priminti, kad
Domeno kad mes pristatėme šiandien

2122
01:49:04,100 --> 01:49:06,920
buvo tai, ką čia ir
iš kriptografija pasaulis.

2123
01:49:06,920 --> 01:49:11,200
Ir tarp ateinančius problemų jūs patys
bus išspręsti yra kriptografija menas,

2124
01:49:11,200 --> 01:49:13,630
kodavimo ir de kodavimo
informacija ir Łifravimas

2125
01:49:13,630 --> 01:49:15,930
ir iššifravimą tekstą
ir darant prielaidą, galiausiai

2126
01:49:15,930 --> 01:49:18,970
kad dabar jūs žinote, ką
yra po gaubtu

2127
01:49:18,970 --> 01:49:21,860
taip, kad kai pamatysite arba gauti
pranešimas patinka tai, ką

2128
01:49:21,860 --> 01:49:24,060
Būk gali iššifruoti jį.

2129
01:49:24,060 --> 01:49:26,740
Visa tai, ir daugiau kitą kartą.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [Vaizdo įrašų atkuriamų]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Tik atvyko.

2133
01:49:32,970 --> 01:49:35,146
Aš ruošiuosi eiti aplankyti
jo koledžo profesorius.

2134
01:49:35,146 --> 01:49:37,611
Taip.

2135
01:49:37,611 --> 01:49:40,080
Sveiki.

2136
01:49:40,080 --> 01:49:40,660
Tai jums.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Laukti!

2139
01:49:45,110 --> 01:49:45,610
Davidas.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Aš tiesiog bando išsiaiškinti
, kas tau nutiko.

2142
01:49:56,060 --> 01:49:58,130
Prašome, ką nors galėtų padėti.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Jūs buvote jo aukštasis
kambarioku, buvo ar ne?

2145
01:50:08,354 --> 01:50:10,770
Jūs buvote ten su juo, kai
baigė CS50 projektą?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [GROJA MUZIKA]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Tai Buvo CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Aš myliu šią vietą.

2152
01:50:44,770 --> 01:50:45,854
>> -Valgyti.

2153
01:50:45,854 --> 01:50:47,020
Mes ketiname iš verslo.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [PABAIGA PLAYBACK]

