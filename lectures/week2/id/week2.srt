1
00:00:00,000 --> 00:00:02,970
>> [MUSIC PLAYING]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Malan: Baiklah.

4
00:00:15,700 --> 00:00:18,832
Ini adalah CS50 dan ini
adalah awal dari Minggu 2.

5
00:00:18,832 --> 00:00:21,040
Dan Anda akan ingat bahwa lebih dari
beberapa minggu terakhir,

6
00:00:21,040 --> 00:00:24,490
kami sudah memperkenalkan komputer
ilmu pengetahuan dan, pada gilirannya, pemrograman.

7
00:00:24,490 --> 00:00:27,640
>> Dan kami mulai cerita dengan cara
Scratch, bahwa bahasa grafis

8
00:00:27,640 --> 00:00:28,990
dari MIT'S Media Lab.

9
00:00:28,990 --> 00:00:30,780
Dan kemudian yang terakhir,
minggu lalu, juga kita

10
00:00:30,780 --> 00:00:34,450
memperkenalkan higher-- a
Bahasa tingkat rendah yang dikenal

11
00:00:34,450 --> 00:00:36,770
C, sesuatu yang murni tekstual.

12
00:00:36,770 --> 00:00:39,440
Dan, memang, terakhir kali kami
dieksplorasi dalam konteks itu

13
00:00:39,440 --> 00:00:40,450
sejumlah konsep.

14
00:00:40,450 --> 00:00:43,010
>> Ini, ingat, adalah sangat
Program pertama kita melihat.

15
00:00:43,010 --> 00:00:45,710
Dan program ini, cukup sederhana,
mencetak, "Halo, dunia."

16
00:00:45,710 --> 00:00:47,730
Tapi ada begitu banyak
tampak ajaib terjadi.

17
00:00:47,730 --> 00:00:51,460
Ada #include ini
dengan kurung sudut ini.

18
00:00:51,460 --> 00:00:52,170
Ada int.

19
00:00:52,170 --> 00:00:53,020
Ada (void).

20
00:00:53,020 --> 00:00:56,330
Ada tanda kurung, kurung kurawal,
semi-titik dua, dan banyak lagi.

21
00:00:56,330 --> 00:00:58,480
>> Dan, ingat bahwa
kami memperkenalkan Scratch

22
00:00:58,480 --> 00:01:02,110
sehingga kita bisa, idealnya, melihat masa lalu
bahwa sintaks, hal-hal yang benar-benar tidak

23
00:01:02,110 --> 00:01:04,590
semua yang intelektual
menarik tetapi awal

24
00:01:04,590 --> 00:01:07,700
adalah, benar-benar, agak rumit
untuk membungkus pikiran Anda sekitar.

25
00:01:07,700 --> 00:01:10,860
Dan, memang, salah satu yang paling umum
hal pada awal kelas pemrograman,

26
00:01:10,860 --> 00:01:13,443
terutama bagi mereka yang kurang
nyaman, adalah untuk mendapatkan frustrasi oleh

27
00:01:13,443 --> 00:01:17,460
dan tersandung oleh sintaksis tertentu
kesalahan, belum lagi kesalahan logis.

28
00:01:17,460 --> 00:01:19,800
Dan di antara tujuan kami
hari ini, benar-benar, akan

29
00:01:19,800 --> 00:01:23,280
adalah untuk membekali Anda dengan beberapa
teknik pemecahan masalah untuk bagaimana

30
00:01:23,280 --> 00:01:26,705
untuk lebih memecahkan masalah sendiri
dalam bentuk debugging.

31
00:01:26,705 --> 00:01:29,330
Dan Anda akan ingat juga, bahwa
lingkungan yang kami memperkenalkan

32
00:01:29,330 --> 00:01:31,780
terakhir kali dipanggil CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Ini adalah perangkat lunak berbasis web yang
memungkinkan Anda untuk program di awan,

34
00:01:34,850 --> 00:01:38,450
sehingga untuk berbicara, sekaligus menjaga semua Anda
file bersama-sama, seperti yang kita lagi akan hari ini.

35
00:01:38,450 --> 00:01:41,480
Dan ingat kita bahwa
ditinjau kembali topik ini di sini,

36
00:01:41,480 --> 00:01:44,480
di antara mereka fungsi, dan loop, dan
variabel, dan ekspresi Boolean,

37
00:01:44,480 --> 00:01:45,110
dan kondisi.

38
00:01:45,110 --> 00:01:49,190
Dan sebenarnya beberapa lagi yang kita
diterjemahkan dari dunia Scratch

39
00:01:49,190 --> 00:01:50,800
ke dunia C.

40
00:01:50,800 --> 00:01:53,220
>> Tapi bangunan fundamental
blok, sehingga untuk berbicara,

41
00:01:53,220 --> 00:01:55,150
yang benar-benar masih sama pekan lalu.

42
00:01:55,150 --> 00:01:57,900
Bahkan, kami benar-benar hanya memiliki
berbeda potongan puzzle, jika Anda mau.

43
00:01:57,900 --> 00:02:00,300
Alih-alih yang ungu
menyimpan blok, kita malah

44
00:02:00,300 --> 00:02:02,940
telah printf, yang
fungsi ini di C yang

45
00:02:02,940 --> 00:02:05,890
memungkinkan Anda untuk mencetak sesuatu
dan format pada layar.

46
00:02:05,890 --> 00:02:07,950
Kami memperkenalkan CS50
Perpustakaan, di mana Anda

47
00:02:07,950 --> 00:02:11,420
memiliki sekarang di get_char Anda inginkan,
dan get_int, dan get_string,

48
00:02:11,420 --> 00:02:14,610
dan beberapa fungsi lainnya sebagai
baik, melalui mana Anda bisa mendapatkan masukan

49
00:02:14,610 --> 00:02:16,260
dari keyboard sendiri pengguna.

50
00:02:16,260 --> 00:02:20,640
Dan kami juga mengambil melihat hal-hal
seperti ini-bool, dan char,

51
00:02:20,640 --> 00:02:22,490
dan double, float,
int, long_long tali.

52
00:02:22,490 --> 00:02:25,170
Dan bahkan ada jenis data lain di C.

53
00:02:25,170 --> 00:02:28,560
>> Dengan kata lain, ketika Anda menyatakan
variabel untuk menyimpan beberapa nilai,

54
00:02:28,560 --> 00:02:32,600
atau ketika Anda menerapkan fungsi
yang mengembalikan beberapa nilai,

55
00:02:32,600 --> 00:02:35,290
Anda dapat menentukan apa yang
jenis nilai yang.

56
00:02:35,290 --> 00:02:37,310
Apakah string, seperti
urutan karakter?

57
00:02:37,310 --> 00:02:39,490
Apakah nomor, seperti integer?

58
00:02:39,490 --> 00:02:41,390
Adalah sebuah titik mengambang
nilai, atau sejenisnya?

59
00:02:41,390 --> 00:02:46,180
Jadi di C, tidak seperti Scratch, kita benar-benar
mulai menentukan apa jenis data

60
00:02:46,180 --> 00:02:48,330
kami kembali atau menggunakan.

61
00:02:48,330 --> 00:02:51,910
>> Tapi, tentu saja, kami juga berlari ke
beberapa batasan dasar komputasi.

62
00:02:51,910 --> 00:02:54,100
Dan khususnya,
ini bahasa C, recall

63
00:02:54,100 --> 00:02:57,070
bahwa kita mengambil melihat
integer overflow, kenyataannya

64
00:02:57,070 --> 00:03:00,460
bahwa jika Anda hanya memiliki
jumlah terbatas memori

65
00:03:00,460 --> 00:03:04,600
atau, secara khusus, jumlah terbatas
bit, Anda hanya dapat menghitung begitu tinggi.

66
00:03:04,600 --> 00:03:08,460
Dan kita melihat contoh ini di sini
dimana counter di pesawat terbang,,

67
00:03:08,460 --> 00:03:13,510
sebenarnya, jika berjalan cukup lama akan
meluap dan mengakibatkan perangkat lunak

68
00:03:13,510 --> 00:03:15,560
potensi fisik kesalahan yang sebenarnya.

69
00:03:15,560 --> 00:03:18,600
>> Kami juga melihat mengambang
Titik ketidaktepatan, kenyataannya

70
00:03:18,600 --> 00:03:22,280
bahwa dengan hanya jumlah terbatas
bit, apakah itu 32 atau 64,

71
00:03:22,280 --> 00:03:27,330
Anda hanya dapat menentukan begitu banyak nomor
setelah titik desimal, setelah itu Anda

72
00:03:27,330 --> 00:03:29,110
mulai mendapatkan tepat.

73
00:03:29,110 --> 00:03:32,360
Jadi misalnya, sepertiga di
dunia di sini, di dunia manusia,

74
00:03:32,360 --> 00:03:35,360
kita tahu hanya jumlah tak terbatas
3s setelah titik desimal.

75
00:03:35,360 --> 00:03:38,820
Tetapi komputer tidak bisa selalu
mewakili jumlah tak terbatas nomor

76
00:03:38,820 --> 00:03:42,590
jika Anda hanya memungkinkan beberapa
jumlah terbatas informasi.

77
00:03:42,590 --> 00:03:45,900
>> Jadi tidak hanya kita membekali Anda
dengan kekuatan yang lebih besar dalam hal

78
00:03:45,900 --> 00:03:49,280
bagaimana Anda dapat mengekspresikan diri di
keyboard dalam hal pemrograman,

79
00:03:49,280 --> 00:03:51,430
kami juga terbatas apa
Anda dapat benar-benar dilakukan.

80
00:03:51,430 --> 00:03:55,790
Dan memang, bug dan kesalahan dapat
timbul dari orang-orang macam masalah.

81
00:03:55,790 --> 00:03:59,900
Dan memang, di antara topik hari ini
akan menjadi topik seperti debugging

82
00:03:59,900 --> 00:04:03,699
dan benar-benar melihat di bawah tenda
bagaimana hal diperkenalkan minggu lalu

83
00:04:03,699 --> 00:04:05,490
benar-benar diterapkan
sehingga Anda lebih baik

84
00:04:05,490 --> 00:04:10,530
memahami baik kemampuan dan
keterbatasan bahasa seperti C.

85
00:04:10,530 --> 00:04:14,770
>> Dan pada kenyataannya, kita akan mengupas lapisan-lapisan
dari yang paling sederhana struktur data,

86
00:04:14,770 --> 00:04:17,756
sesuatu yang disebut array, yang
Scratch terjadi untuk memanggil "daftar."

87
00:04:17,756 --> 00:04:19,589
Ini sedikit
berbeda dalam konteks itu.

88
00:04:19,589 --> 00:04:23,340
Dan kemudian kami juga akan memperkenalkan salah satu
pertama masalah domain-spesifik kami

89
00:04:23,340 --> 00:04:26,790
di CS50, dunia
kriptografi, seni berebut

90
00:04:26,790 --> 00:04:29,650
atau dalam Pengkodean informasi sehingga
Anda dapat mengirim pesan rahasia

91
00:04:29,650 --> 00:04:34,520
dan memecahkan kode rahasia
antara dua orang, A dan B.

92
00:04:34,520 --> 00:04:37,490
>> Jadi sebelum kita transisi
ke dunia baru,

93
00:04:37,490 --> 00:04:42,059
mari kita coba untuk membekali Anda dengan beberapa
teknik dengan mana Anda dapat menghilangkan

94
00:04:42,059 --> 00:04:43,850
atau mengurangi setidaknya beberapa
frustrasi

95
00:04:43,850 --> 00:04:46,630
Anda mungkin mengalami
selama seminggu terakhir saja.

96
00:04:46,630 --> 00:04:50,830
Bahkan, di depan Anda such-- beberapa
masalah pertama Anda di C. Dan kemungkinan besar,

97
00:04:50,830 --> 00:04:54,010
jika Anda seperti saya, pertama kalinya
Anda mencoba untuk mengetik sebuah program,

98
00:04:54,010 --> 00:04:57,330
bahkan jika Anda berpikir logis
program ini cukup sederhana,

99
00:04:57,330 --> 00:05:01,200
Anda mungkin sangat baik menabrak dinding, dan
compiler tidak akan bekerja sama.

100
00:05:01,200 --> 00:05:03,940
Membuat atau dentang tidak akan
untuk benar-benar melakukan penawaran Anda.

101
00:05:03,940 --> 00:05:05,450
>> Dan mengapa yang mungkin?

102
00:05:05,450 --> 00:05:07,950
Nah, mari kita lihat,
mungkin, program yang sederhana.

103
00:05:07,950 --> 00:05:11,190
Aku akan pergi ke depan dan menyimpan ini dalam
file sengaja disebut buggy0.c,

104
00:05:11,190 --> 00:05:13,590
karena saya tahu itu untuk
akan cacat di muka.

105
00:05:13,590 --> 00:05:17,400
Tapi aku mungkin tidak menyadari bahwa jika ini
adalah program pertama atau kedua atau ketiga

106
00:05:17,400 --> 00:05:18,830
bahwa aku benar-benar membuat diriku.

107
00:05:18,830 --> 00:05:23,820
Jadi aku akan pergi ke depan dan
mengetikkan, int main (void).

108
00:05:23,820 --> 00:05:28,130
Dan kemudian di dalam kurung kurawal saya,
sangat familiar ( "Halo, dunia--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - dan semi-colon.

110
00:05:30,980 --> 00:05:32,360
>> Aku sudah menyimpan file.

111
00:05:32,360 --> 00:05:34,850
Sekarang aku akan turun
ke jendela terminal saya

112
00:05:34,850 --> 00:05:40,340
dan jenis make buggy0, karena, sekali lagi,
nama file saat ini adalah buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Jadi saya ketik membuat buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Dan, oh, gosh, ingat dari terakhir kali
bahwa tidak ada pesan error adalah hal yang baik.

115
00:05:48,200 --> 00:05:49,740
Jadi tidak ada output adalah hal yang baik.

116
00:05:49,740 --> 00:05:52,920
Tapi di sini aku harus jelas
beberapa jumlah kesalahan.

117
00:05:52,920 --> 00:05:56,470
>> Jadi baris pertama output
setelah mengetik membuat buggy0, ingat,

118
00:05:56,470 --> 00:05:59,540
adalah output cukup verbose dentang ini.

119
00:05:59,540 --> 00:06:02,067
Di bawah kap mesin,
CS50 IDE dikonfigurasi

120
00:06:02,067 --> 00:06:04,150
menggunakan sejumlah besar
Pilihan dengan compiler ini

121
00:06:04,150 --> 00:06:05,941
sehingga Anda tidak memiliki
untuk berpikir tentang mereka.

122
00:06:05,941 --> 00:06:08,840
Dan itulah yang baris pertama
berarti yang dimulai dengan dentang.

123
00:06:08,840 --> 00:06:11,720
>> Tapi setelah itu, masalah
mulai membuat penampilan mereka.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c on line 3, karakter
5, ada, kesalahan merah besar.

125
00:06:17,390 --> 00:06:18,380
Apa itu?

126
00:06:18,380 --> 00:06:23,562
Secara implisit menyatakan fungsi perpustakaan
printf dengan tipe int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Maksudku, itu sangat cepat
akan sangat misterius.

129
00:06:28,379 --> 00:06:30,170
Dan tentu saja, pada awalnya
Sekilas, kita tidak akan

130
00:06:30,170 --> 00:06:32,380
mengharapkan Anda untuk memahami
keseluruhan pesan itu.

131
00:06:32,380 --> 00:06:34,213
Dan jadi salah satu pelajaran
untuk hari ini akan

132
00:06:34,213 --> 00:06:36,919
menjadi mencoba untuk melihat
pola, atau hal-hal serupa,

133
00:06:36,919 --> 00:06:38,960
kesalahan yang mungkin Anda miliki
dihadapi di masa lalu.

134
00:06:38,960 --> 00:06:41,335
Jadi mari kita menggoda terpisah hanya
kata-kata yang terlihat akrab.

135
00:06:41,335 --> 00:06:44,290
Besar, kesalahan merah jelas
simbolis sesuatu yang salah.

136
00:06:44,290 --> 00:06:47,940
>> Secara implisit menyatakan
fungsi perpustakaan printf.

137
00:06:47,940 --> 00:06:51,680
Jadi, bahkan jika saya tidak begitu mengerti apa
implisit menyatakan fungsi perpustakaan

138
00:06:51,680 --> 00:06:54,900
berarti, masalah pasti
berkaitan dengan printf entah bagaimana.

139
00:06:54,900 --> 00:06:59,130
Dan sumber masalah yang
hubungannya dengan menyatakan hal itu.

140
00:06:59,130 --> 00:07:02,440
>> Mendeklarasikan suatu fungsi
menyebutkan itu untuk pertama kalinya.

141
00:07:02,440 --> 00:07:06,210
Dan kami menggunakan terminologi minggu lalu
mendeklarasikan prototipe fungsi ini,

142
00:07:06,210 --> 00:07:11,860
baik dengan satu baris di bagian atas Anda
File sendiri atau dalam disebut file header.

143
00:07:11,860 --> 00:07:15,300
Dan di file apa juga kita katakan
pekan lalu bahwa printf adalah kutipan,

144
00:07:15,300 --> 00:07:17,080
tanda kutip, menyatakan?

145
00:07:17,080 --> 00:07:20,950
Dalam file apa prototipe?

146
00:07:20,950 --> 00:07:24,640
>> Jadi, jika Anda ingat, hal pertama yang saya
diketik, hampir setiap program time-- lalu

147
00:07:24,640 --> 00:07:30,790
dan sengaja sesaat lalu mulai
mengetik myself-- adalah di sini-yang satu ini

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- untuk
input / output-- dot h Dan memang,

149
00:07:38,630 --> 00:07:41,860
jika saya sekarang menyimpan file ini, aku akan
untuk terus maju dan membersihkan layar saya,

150
00:07:41,860 --> 00:07:44,740
yang dapat Anda lakukan dengan mengetik
Yang jelas, atau Anda dapat memegang kontrol L,

151
00:07:44,740 --> 00:07:47,680
hanya untuk membersihkan jendela terminal Anda
hanya untuk menghilangkan beberapa kekacauan.

152
00:07:47,680 --> 00:07:51,370
>> Aku akan pergi ke depan dan
re-jenis make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Dan voila, saya masih melihat bahwa
perintah yang panjang dari dentang,

154
00:07:53,790 --> 00:07:55,470
tapi tidak ada pesan error saat ini.

155
00:07:55,470 --> 00:07:58,800
Dan memang, jika saya lakukan ./buggy0,
seperti terakhir kali,

156
00:07:58,800 --> 00:08:01,860
di mana titik berarti ini
direktori, Slash hanya berarti,

157
00:08:01,860 --> 00:08:05,040
inilah nama program dan
bahwa nama dari program ini adalah buggy0,

158
00:08:05,040 --> 00:08:07,340
Masukkan, "halo, dunia."

159
00:08:07,340 --> 00:08:09,440
>> Sekarang, bagaimana Anda mungkin memiliki
dikumpulkan solusi ini

160
00:08:09,440 --> 00:08:12,017
tanpa harus
mengenali banyak kata-kata

161
00:08:12,017 --> 00:08:14,350
seperti yang saya lakukan, tentu, memiliki
melakukan ini selama bertahun-tahun?

162
00:08:14,350 --> 00:08:18,720
Nah, menyadari per masalah pertama
set, kami memperkenalkan Anda kepada perintah

163
00:08:18,720 --> 00:08:21,175
bahwa staf CS50 sendiri
menulis disebut help50.

164
00:08:21,175 --> 00:08:24,300
Dan memang, C tidak spesifikasi untuk
masalah mengatur bagaimana menggunakan ini.

165
00:08:24,300 --> 00:08:27,210
>> Tapi help50 dasarnya
sebuah program yang staf CS50 ini

166
00:08:27,210 --> 00:08:30,850
menulis yang memungkinkan Anda untuk menjalankan
perintah atau menjalankan program,

167
00:08:30,850 --> 00:08:36,169
dan jika Anda tidak mengerti nya
output, untuk lulus output nya ke help50,

168
00:08:36,169 --> 00:08:38,890
di mana titik perangkat lunak
bahwa staf saja yang menulis

169
00:08:38,890 --> 00:08:42,429
akan melihat keluaran program anda
baris demi baris, karakter demi karakter.

170
00:08:42,429 --> 00:08:46,000
Dan jika kita, staf, mengakui
pesan kesalahan yang Anda alami,

171
00:08:46,000 --> 00:08:50,580
kami akan mencoba untuk memprovokasi Anda dengan beberapa
pertanyaan retoris, dengan beberapa saran,

172
00:08:50,580 --> 00:08:54,890
banyak seperti TF atau CA atau diriku
akan melakukan secara pribadi di jam kantor.

173
00:08:54,890 --> 00:08:58,320
>> Jadi melihat ke help50 jika Anda tidak
tentu mengenali masalah.

174
00:08:58,320 --> 00:09:00,790
Tapi jangan bergantung pada itu
terlalu banyak sebagai penopang.

175
00:09:00,790 --> 00:09:03,990
Tentu saja mencoba untuk memahami nya
output dan kemudian belajar dari itu

176
00:09:03,990 --> 00:09:07,571
sehingga hanya sekali atau dua kali kau
pernah menjalankan help50 untuk kesalahan tertentu

177
00:09:07,571 --> 00:09:08,070
pesan.

178
00:09:08,070 --> 00:09:10,660
Setelah itu, Anda harus
lebih siap diri

179
00:09:10,660 --> 00:09:13,180
untuk mencari tahu apa yang sebenarnya.

180
00:09:13,180 --> 00:09:14,350
>> Mari kita lakukan yang lain di sini.

181
00:09:14,350 --> 00:09:20,410
Biarkan aku pergi ke depan, dan di lain
File kita akan menyebutnya buggy1.c ini.

182
00:09:20,410 --> 00:09:23,110
Dan dalam file ini saya
akan deliberately--

183
00:09:23,110 --> 00:09:26,330
tapi berpura-pura bahwa saya tidak
memahami apa kesalahan yang saya buat.

184
00:09:26,330 --> 00:09:31,420
>> Aku akan pergi ke depan dan melakukan ini--
# include, karena saya sudah

185
00:09:31,420 --> 00:09:33,660
belajar pelajaran saya dari beberapa saat yang lalu.

186
00:09:33,660 --> 00:09:36,220
Int main (void), seperti sebelumnya.

187
00:09:36,220 --> 00:09:40,880
Dan kemudian di sini aku akan
untuk melakukan string s - get_string.

188
00:09:40,880 --> 00:09:43,770
Dan ingat dari terakhir kali
cara ini, hei, komputer,

189
00:09:43,770 --> 00:09:48,280
memberi saya sebuah variabel, menyebutnya s, dan
membuat jenis variabel yang string

190
00:09:48,280 --> 00:09:50,150
jadi saya dapat menyimpan satu atau lebih kata di dalamnya.

191
00:09:50,150 --> 00:09:52,191
>> Dan kemudian di kanan
sisi tanda sama

192
00:09:52,191 --> 00:09:54,980
adalah get_string, yang merupakan
fungsi di Perpustakaan CS50

193
00:09:54,980 --> 00:09:55,980
yang tidak tepat.

194
00:09:55,980 --> 00:09:59,740
Ia mendapat fungsi dan kemudian
tangan dari kanan ke kiri.

195
00:09:59,740 --> 00:10:02,670
Jadi tanda sama ini tidak berarti
"Sama" seperti yang kita mungkin berpikir dalam matematika.

196
00:10:02,670 --> 00:10:04,750
Ini berarti tugas dari kanan ke kiri.

197
00:10:04,750 --> 00:10:09,640
Jadi ini berarti, mengambil string dari
pengguna dan menyimpannya dalam s.

198
00:10:09,640 --> 00:10:10,460
>> Sekarang mari kita menggunakannya.

199
00:10:10,460 --> 00:10:13,820
Biarkan aku pergi ke depan sekarang dan sebagai kedua
line, biarkan aku pergi ke depan dan berkata "Halo" -

200
00:10:13,820 --> 00:10:19,330
tidak "dunia," tapi "Halo,% s--
yang placeholder kami, koma s,

201
00:10:19,330 --> 00:10:22,030
yang variabel kita,
dan kemudian semi-colon.

202
00:10:22,030 --> 00:10:26,070
Jadi jika saya tidak mengacaukan terlalu banyak
di sini, ini tampak seperti kode yang benar.

203
00:10:26,070 --> 00:10:28,090
>> Dan naluri saya sekarang adalah melakukan kompilasi.

204
00:10:28,090 --> 00:10:30,400
File ini disebut buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Jadi aku akan lakukan membuat buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Dan menisik-itu, jika tidak ada
bahkan lebih kesalahan dari sebelumnya.

207
00:10:36,377 --> 00:10:38,210
Maksudku, masih ada lagi
pesan kesalahan itu akan

208
00:10:38,210 --> 00:10:40,400
tampak dari garis yang sebenarnya dalam program ini.

209
00:10:40,400 --> 00:10:42,730
>> Tapi takeaway di sini adalah,
bahkan jika Anda kewalahan

210
00:10:42,730 --> 00:10:45,040
dengan dua atau tiga atau
empat pesan kesalahan lagi,

211
00:10:45,040 --> 00:10:48,340
fokus selalu pada sangat
pertama dari pesan tersebut.

212
00:10:48,340 --> 00:10:52,220
Melihat paling atas satu,
bergulir kembali sebagai perlu.

213
00:10:52,220 --> 00:10:53,930
Jadi di sini saya mengetik make buggy1.

214
00:10:53,930 --> 00:10:55,700
Berikut bahwa output dentang seperti yang diharapkan.

215
00:10:55,700 --> 00:10:57,290
>> Dan inilah kesalahan merah pertama.

216
00:10:57,290 --> 00:11:02,370
Penggunaan pengenal dideklarasikan
string, aku berarti standar di?

217
00:11:02,370 --> 00:11:04,260
Jadi dalam standar
sebenarnya sesuatu yang lain.

218
00:11:04,260 --> 00:11:06,240
Hal ini mengacu pada pengguna
Keyboard, pada dasarnya.

219
00:11:06,240 --> 00:11:08,080
>> Tapi bukan itu yang saya maksudkan.

220
00:11:08,080 --> 00:11:11,770
Aku berarti string, dan aku berarti get_string.

221
00:11:11,770 --> 00:11:16,200
Jadi apa itu yang saya
lupa untuk melakukan saat ini?

222
00:11:16,200 --> 00:11:20,230
Apa yang hilang saat ini?

223
00:11:20,230 --> 00:11:23,600
Aku punya # include saya,
jadi saya memiliki akses ke printf.

224
00:11:23,600 --> 00:11:26,090
>> Tapi apa yang saya tidak memiliki
akses ke dulu?

225
00:11:26,090 --> 00:11:29,420
Nah, seperti terakhir kali,
Saya harus memberitahu compiler

226
00:11:29,420 --> 00:11:31,691
Berdentang apa fungsi-fungsi ini.

227
00:11:31,691 --> 00:11:33,940
Get_string tidak datang
dengan C. Dan khususnya,

228
00:11:33,940 --> 00:11:38,160
tidak datang di
tajuk berkas,.

229
00:11:38,160 --> 00:11:40,770
Ini bukan datang di
sesuatu staf menulis,

230
00:11:40,770 --> 00:11:44,176
yang merupakan file yang berbeda
nama tapi aptly bernama.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Jadi hanya dengan menambahkan bahwa satu baris
recall code-- dari terakhir kali

233
00:11:50,861 --> 00:11:53,610
bahwa ketika dentang berjalan, itu akan
untuk melihat kode saya atas ke bawah,

234
00:11:53,610 --> 00:11:54,193
kiri ke kanan.

235
00:11:54,193 --> 00:11:57,200
Ini akan melihat,
oh, Anda ingin.

236
00:11:57,200 --> 00:11:59,900
Biarkan aku pergi dan menemukan bahwa,
mana pun di server,

237
00:11:59,900 --> 00:12:03,090
copy dan paste, pada dasarnya,
ke bagian atas file Anda sendiri

238
00:12:03,090 --> 00:12:06,820
sehingga pada titik ini dalam cerita,
baris 1, sisa program

239
00:12:06,820 --> 00:12:11,651
bisa, memang, menggunakan salah satu fungsi
di dalamnya, di antaranya get_string.

240
00:12:11,651 --> 00:12:13,650
Jadi aku akan mengabaikan
sisa kesalahan mereka,

241
00:12:13,650 --> 00:12:17,190
karena saya memang menduga bahwa hanya
yang pertama benar-benar penting.

242
00:12:17,190 --> 00:12:20,780
Dan aku akan pergi ke depan dan jalankan kembali,
setelah menyimpan file saya membuat buggy1.

243
00:12:20,780 --> 00:12:22,580
Dan voila, itu berhasil.

244
00:12:22,580 --> 00:12:29,200
Dan jika saya lakukan ./buggy1 dan ketik, untuk
Misalnya, Zamyla, sekarang saya akan mendapatkan halo,

245
00:12:29,200 --> 00:12:32,000
Zamyla, bukannya halo, dunia.

246
00:12:32,000 --> 00:12:32,550
>> Baiklah.

247
00:12:32,550 --> 00:12:35,890
Jadi takeaways sini kemudian dapat,
satu, mencoba untuk mengumpulkan sebanyak yang Anda bisa

248
00:12:35,890 --> 00:12:39,140
dari pesan kesalahan sendiri, mencari
beberapa kata-kata dikenali.

249
00:12:39,140 --> 00:12:43,070
Kecuali itu, gunakan help50 per
masalah mengatur spesifikasi.

250
00:12:43,070 --> 00:12:46,500
Tapi pembatasan itu juga, selalu melihat
di kesalahan atas saja, setidaknya

251
00:12:46,500 --> 00:12:50,051
awalnya, untuk melihat informasi apa
mungkin sebenarnya menghasilkan.

252
00:12:50,051 --> 00:12:52,300
Tapi ternyata ada yang
bahkan lebih fungsi built

253
00:12:52,300 --> 00:12:55,030
ke Perpustakaan CS50 untuk membantu
Anda di awal semester

254
00:12:55,030 --> 00:12:57,580
dan di awal pemrograman
mencari tahu apa yang salah.

255
00:12:57,580 --> 00:12:59,840
Jadi mari kita lakukan contoh lain di sini.

256
00:12:59,840 --> 00:13:04,350
Aku akan memanggil buggy2 ini, yang,
lagi, ini akan cacat keluar

257
00:13:04,350 --> 00:13:05,650
gerbang, dengan desain.

258
00:13:05,650 --> 00:13:09,980
>> Dan aku akan pergi ke depan
dan melakukan # include.

259
00:13:09,980 --> 00:13:12,580
Dan kemudian aku akan melakukan int main (void).

260
00:13:12,580 --> 00:13:14,840
Dan kemudian aku akan lakukan untuk loop.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i kurang dari atau sama dengan 10.

263
00:13:18,750 --> 00:13:24,260
i ++, dan kemudian di kurung kurawal, aku akan
untuk mencetak hanya simbol hashtag sini

264
00:13:24,260 --> 00:13:25,920
dan karakter baris baru.

265
00:13:25,920 --> 00:13:29,220
>> Jadi maksud saya dengan ini
Program ini cukup sederhana

266
00:13:29,220 --> 00:13:33,150
iterate 10 kali
dan pada setiap iterasi

267
00:13:33,150 --> 00:13:35,260
loop yang setiap kali
melalui siklus,

268
00:13:35,260 --> 00:13:37,660
mencetak hashtag,
hashtag, hashtag.

269
00:13:37,660 --> 00:13:40,480
Satu per baris karena saya
memiliki garis baru di sana.

270
00:13:40,480 --> 00:13:42,787
Dan ingat bahwa untuk
lingkaran, per week-- lalu

271
00:13:42,787 --> 00:13:44,620
dan Anda akan mendapatkan lebih banyak
akrab dengan sintaks

272
00:13:44,620 --> 00:13:47,170
dengan menggunakannya dengan praktek
sebelum long-- ini memberi saya

273
00:13:47,170 --> 00:13:49,740
variabel yang disebut i dan set ke 0.

274
00:13:49,740 --> 00:13:52,650
>> Ini akan menambahkan i pada
setiap iterasi oleh 1.

275
00:13:52,650 --> 00:13:54,940
Jadi saya pergi ke 1 untuk 2 sampai 3.

276
00:13:54,940 --> 00:13:57,690
Dan kemudian kondisi ini di
tengah antara semi-titik dua

277
00:13:57,690 --> 00:14:03,010
akan diperiksa pada setiap iterasi untuk membuat
yakin bahwa kita masih dalam jangkauan.

278
00:14:03,010 --> 00:14:06,830
Jadi saya ingin iterate 10 kali, jadi saya
memiliki semacam sangat intuitif hanya

279
00:14:06,830 --> 00:14:09,070
menempatkan 10 sebagai saya terikat atas sana.

280
00:14:09,070 --> 00:14:14,310
>> Namun, ketika saya menjalankan ini, setelah
kompilasi dengan make buggy2--

281
00:14:14,310 --> 00:14:15,440
dan itu mengkompilasi OK.

282
00:14:15,440 --> 00:14:17,980
Jadi saya tidak memiliki
kesalahan sintaks saat ini.

283
00:14:17,980 --> 00:14:20,940
Biarkan aku pergi ke depan sekarang
dan menjalankan buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Dan sekarang gulir ke atas.

285
00:14:22,620 --> 00:14:24,890
Dan biarkan aku meningkatkan
ukuran jendela.

286
00:14:24,890 --> 00:14:33,720
>> Saya tampaknya memiliki 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Jadi ada 11 hashtags, meskipun
Saya jelas menempatkan 10 dalam lingkaran ini.

288
00:14:38,891 --> 00:14:42,140
Sekarang, beberapa dari Anda mungkin melihat langsung
apa kesalahan ini karena, memang, ini

289
00:14:42,140 --> 00:14:43,720
bukan kesalahan sangat sulit untuk membuat.

290
00:14:43,720 --> 00:14:46,070
Tapi itu sangat umum
dibuat sangat awal.

291
00:14:46,070 --> 00:14:49,820
>> Apa yang saya ingin menunjukkan, meskipun,
adalah, bagaimana saya bisa memikirkan hal ini?

292
00:14:49,820 --> 00:14:52,300
Nah, ternyata
Perpustakaan CS50 datang

293
00:14:52,300 --> 00:14:55,380
dengan tidak hanya get_string dan get_int
dan get_float dan fungsi lainnya.

294
00:14:55,380 --> 00:14:59,980
Hal ini juga dilengkapi dengan fungsi khusus
disebut eprintf, atau, kesalahan printf.

295
00:14:59,980 --> 00:15:03,270
Dan itu ada hanya untuk membuat
itu sedikit lebih mudah untuk Anda

296
00:15:03,270 --> 00:15:06,310
saat debugging kode Anda hanya
mencetak pesan kesalahan pada layar

297
00:15:06,310 --> 00:15:07,850
dan tahu dari mana asalnya.

298
00:15:07,850 --> 00:15:11,000
>> Jadi misalnya, satu hal yang saya mungkin
lakukan di sini dengan fungsi ini ini--

299
00:15:11,000 --> 00:15:20,230
eprintf, dan kemudian aku akan pergi ke depan
dan mengatakan saya sekarang% i, backslash, n.

300
00:15:20,230 --> 00:15:22,330
Dan aku akan pasang di nilai i.

301
00:15:22,330 --> 00:15:25,400
Dan di bagian atas, karena ini
adalah di Perpustakaan CS50,

302
00:15:25,400 --> 00:15:27,580
Aku akan pergi ke depan
dan mencakup

303
00:15:27,580 --> 00:15:29,169
jadi saya memiliki akses ke fungsi ini.

304
00:15:29,169 --> 00:15:31,460
Tapi mari kita mempertimbangkan apa baris
9 seharusnya melakukan.

305
00:15:31,460 --> 00:15:32,670
Aku akan menghapus ini akhirnya.

306
00:15:32,670 --> 00:15:34,670
Ini tidak ada hubungannya
dengan tujuan menyeluruh saya.

307
00:15:34,670 --> 00:15:39,090
Tapi eprintf, kesalahan printf, hanya dimaksudkan
untuk memberikan beberapa informasi diagnostik.

308
00:15:39,090 --> 00:15:42,460
Ketika saya menjalankan program saya, saya ingin
melihat ini di layar sementara

309
00:15:42,460 --> 00:15:44,550
juga hanya untuk memahami
apa yang sedang terjadi.

310
00:15:44,550 --> 00:15:47,330
>> Dan, memang, pada setiap
iterasi sini garis 9

311
00:15:47,330 --> 00:15:49,260
Saya ingin melihat, apa nilai i?

312
00:15:49,260 --> 00:15:50,290
Apa nilai i?

313
00:15:50,290 --> 00:15:51,280
Apa nilai i?

314
00:15:51,280 --> 00:15:55,650
Dan, mudah-mudahan, saya hanya harus
melihat pesan tersebut, juga, 10 kali.

315
00:15:55,650 --> 00:15:57,780
>> Jadi biarkan aku pergi ke depan dan
mengkompilasi ulang program saya,

316
00:15:57,780 --> 00:15:59,905
seperti yang telah saya lakukan setiap saat
Saya membuat perubahan. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Dan sekarang-- OK.

319
00:16:03,640 --> 00:16:04,820
Ada banyak lebih terjadi.

320
00:16:04,820 --> 00:16:07,610
Jadi biarkan aku gulir ke atas di
jendela yang lebih besar.

321
00:16:07,610 --> 00:16:10,190
>> Dan Anda akan melihat bahwa masing-masing
hashtags masih mencetak.

322
00:16:10,190 --> 00:16:15,270
Tapi di antara masing-masing dari mereka sekarang ini
Output diagnostik diformat sebagai berikut.

323
00:16:15,270 --> 00:16:17,960
Nama program saya di sini adalah buggy2.

324
00:16:17,960 --> 00:16:20,432
Nama file adalah buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Nomor baris yang
ini dicetak adalah garis 9.

326
00:16:24,080 --> 00:16:27,500
Dan kemudian ke kanan itu adalah
pesan kesalahan yang saya harapkan.

327
00:16:27,500 --> 00:16:30,701
>> Dan apa yang baik tentang ini adalah bahwa
sekarang saya tidak perlu selalu menghitung

328
00:16:30,701 --> 00:16:32,200
di kepala saya apa program saya lakukan.

329
00:16:32,200 --> 00:16:34,240
Saya dapat melihat bahwa pada
iterasi pertama saya adalah 0,

330
00:16:34,240 --> 00:16:39,420
kemudian 1, kemudian 2, kemudian 3, kemudian 4, maka
5, maka 6, kemudian 7, kemudian 8, kemudian 9, maka

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Jadi tunggu sebentar.

333
00:16:42,050 --> 00:16:43,740
Apa yang terjadi di sini?

334
00:16:43,740 --> 00:16:48,190
Saya tampaknya masih akan menghitung
sebagaimana dimaksud hingga 10.

335
00:16:48,190 --> 00:16:50,550
>> Tapi dari mana saya mulai?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Jadi 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- jari-11

338
00:16:58,040 --> 00:16:59,990
merupakan indikasi dari masalah.

339
00:16:59,990 --> 00:17:02,850
Saya tampaknya telah dihitung
salah dalam lingkaran saya.

340
00:17:02,850 --> 00:17:06,599
Daripada pergi 10 iterasi,
Aku mulai pada 0,

341
00:17:06,599 --> 00:17:09,550
Saya berakhir di dan melalui 10.

342
00:17:09,550 --> 00:17:12,030
Tapi karena, seperti komputer,
Aku mulai menghitung pada 0,

343
00:17:12,030 --> 00:17:15,250
Saya harus menghitung up
, tapi tidak melalui, 10.

344
00:17:15,250 --> 00:17:18,510
>> Dan sehingga memperbaiki, saya akhirnya
menyadari sini, adalah salah satu dari dua hal.

345
00:17:18,510 --> 00:17:22,430
Saya sangat hanya bisa mengatakan
menghitung sampai kurang dari 10.

346
00:17:22,430 --> 00:17:27,260
Jadi 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, yang, memang, benar,

347
00:17:27,260 --> 00:17:28,900
meskipun kedengarannya sedikit salah.

348
00:17:28,900 --> 00:17:35,070
Atau aku bisa melakukan kurang dari atau sama
9, selama aku mulai 0.

349
00:17:35,070 --> 00:17:40,056
Atau jika Anda benar-benar tidak seperti itu, Anda
dapat menghitung sampai 10, tetapi mulai dari 1.

350
00:17:40,056 --> 00:17:41,680
Tapi sekali lagi, ini hanya tidak terlalu umum.

351
00:17:41,680 --> 00:17:43,977
Dalam programming-- meskipun
tidak begitu banyak di Scratch--

352
00:17:43,977 --> 00:17:45,810
tetapi dalam pemrograman di
C dan bahasa lainnya,

353
00:17:45,810 --> 00:17:47,670
seperti JavaScript dan
Python dan lain-lain, itu

354
00:17:47,670 --> 00:17:49,880
hanya sangat umum untuk
diskusi kami biner

355
00:17:49,880 --> 00:17:53,450
hanya mulai menghitung di
jumlah terendah yang bisa, yang adalah 0.

356
00:17:53,450 --> 00:17:53,950
Baiklah.

357
00:17:53,950 --> 00:17:55,160
Jadi itu eprintf.

358
00:17:55,160 --> 00:17:58,600
Dan lagi, sekarang aku sudah tahu saya
masalah, dan aku akan kembali ke 0

359
00:17:58,600 --> 00:18:01,470
melalui kurang dari 10, aku akan
untuk masuk dan menghapus eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Seharusnya tidak ada ketika saya
kapal kode saya atau mengirimkan kode saya

361
00:18:04,580 --> 00:18:05,800
atau menunjukkannya kepada orang lain.

362
00:18:05,800 --> 00:18:07,980
Ini benar-benar hanya dimaksudkan
untuk digunakan sementara.

363
00:18:07,980 --> 00:18:11,650
Tapi sekarang saya sudah tetap ini
masalah khusus juga.

364
00:18:11,650 --> 00:18:16,780
>> Nah, mari kita lakukan satu contoh lagi di sini
bahwa aku akan menyiapkan sebagai berikut.

365
00:18:16,780 --> 00:18:22,850
Aku akan pergi ke depan dan
# include. $ 50

366
00:18:22,850 --> 00:18:25,580
Dan aku akan pergi ke depan
dan # include.

367
00:18:25,580 --> 00:18:29,030
>> Dan aku akan menyimpan
file ini sebagai buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Dan aku akan pergi ke depan
dan menyatakan int main (void).

369
00:18:31,740 --> 00:18:34,186
Dan kemudian dalam ada
Aku akan melakukan int i _ -

370
00:18:34,186 --> 00:18:36,435
Saya ingin menerapkan program
dengan get_negative_int a.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Ini bukan fungsi yang ada belum.

373
00:18:40,770 --> 00:18:42,870
Jadi kita akan menerapkan
itu hanya dalam beberapa saat.

374
00:18:42,870 --> 00:18:45,541
Tapi kita akan melihat mengapa
itu kereta di lulus pertama.

375
00:18:45,541 --> 00:18:47,290
Dan sekali aku sudah
int dari pengguna,

376
00:18:47,290 --> 00:18:53,365
Aku hanya akan mencetak% i adalah negatif
integer, backslash, n, koma, i.

377
00:18:53,365 --> 00:18:55,240
Dengan kata lain, semua saya
ingin program ini untuk melakukan

378
00:18:55,240 --> 00:18:58,000
adalah mendapatkan int negatif dari
pengguna dan kemudian mencetak

379
00:18:58,000 --> 00:18:59,980
ini dan itu adalah int negatif.

380
00:18:59,980 --> 00:19:02,080
>> Sekarang saya perlu untuk mengimplementasikan fungsi ini.

381
00:19:02,080 --> 00:19:05,740
Jadi nanti di file saya, saya akan pergi
ke depan dan menyatakan fungsi disebut

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - dan kami akan
kembali ke apa baris yang berarti lagi

383
00:19:10,670 --> 00:19:18,790
dalam moment-- int n; do-- do
yang following-- printf n adalah :.

384
00:19:18,790 --> 00:19:26,210
Dan kemudian aku akan melakukan n - get_int,
dan melakukan sementara ini n lebih besar dari 0.

385
00:19:26,210 --> 00:19:28,310
Dan kemudian kembali n ;.

386
00:19:28,310 --> 00:19:31,730
>> Jadi ada banyak hal yang terjadi di
tidak ada ini, tetapi yang kami lakukan tidak

387
00:19:31,730 --> 00:19:33,710
melihat pekan lalu, setidaknya sebentar.

388
00:19:33,710 --> 00:19:36,980
Jadi pada baris 10 di sini saya sudah dinyatakan sebagai
fungsi yang disebut get_negative_int,

389
00:19:36,980 --> 00:19:39,620
dan aku telah menempatkan (void), di
kurung, alasannya karena ini

390
00:19:39,620 --> 00:19:40,950
tidak mengambil input.

391
00:19:40,950 --> 00:19:42,910
Aku tidak melewati apapun
untuk fungsi ini.

392
00:19:42,910 --> 00:19:44,690
Aku hanya mendapatkan sesuatu kembali dari itu.

393
00:19:44,690 --> 00:19:47,270
>> Dan apa yang saya berharap untuk
kembali adalah bilangan bulat.

394
00:19:47,270 --> 00:19:50,040
Tidak ada tipe data di
C disebut negative_int.

395
00:19:50,040 --> 00:19:52,880
Itu hanya int, sehingga akan
berada di kita untuk memastikan

396
00:19:52,880 --> 00:19:55,340
bahwa nilai yang sebenarnya
dikembalikan tidak hanya int

397
00:19:55,340 --> 00:19:56,380
tapi juga negatif.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 Saya mendeklarasikan variabel
disebut n dan menjadikannya tipe int.

399
00:20:02,150 --> 00:20:07,500
Dan kemudian sejalan 13 melalui 18 aku
melakukan sesuatu sementara sesuatu itu benar.

400
00:20:07,500 --> 00:20:11,040
Aku pergi ke depan dan mencetak
n adalah, usus besar, dan kemudian spasi,

401
00:20:11,040 --> 00:20:12,800
seperti prompt bagi pengguna.

402
00:20:12,800 --> 00:20:16,410
>> Saya kemudian menelepon get_int dan
menyimpan disebut nilai kembali

403
00:20:16,410 --> 00:20:18,130
dalam variabel n.

404
00:20:18,130 --> 00:20:22,600
Tapi aku akan tetap melakukan
sementara ini n lebih besar dari 0.

405
00:20:22,600 --> 00:20:27,960
Dengan kata lain, jika pengguna memberikan saya sebuah
int dan jumlah itu lebih besar dari 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positif, aku akan
terus reprompting pengguna,

407
00:20:31,180 --> 00:20:37,160
menjaga reprompting, dengan memaksa mereka untuk
bekerja sama dan memberi saya int negatif.

408
00:20:37,160 --> 00:20:41,640
>> Dan sekali n sebenarnya negative--
misalkan pengguna akhirnya jenis -50,

409
00:20:41,640 --> 00:20:46,710
maka loop sementara ini tidak lagi benar
karena -50 tidak lebih besar dari 0.

410
00:20:46,710 --> 00:20:51,140
Jadi kita keluar dari itu
lingkaran logis dan kembali n.

411
00:20:51,140 --> 00:20:53,520
>> Tapi ada satu lainnya
hal yang harus saya lakukan.

412
00:20:53,520 --> 00:20:56,190
Dan saya hanya bisa melakukan ini
oleh copy dan paste

413
00:20:56,190 --> 00:20:58,540
satu baris kode di atas file.

414
00:20:58,540 --> 00:21:01,630
Saya harus mengajar dentang,
atau menjanjikan untuk dentang,

415
00:21:01,630 --> 00:21:04,630
eksplisit bahwa saya akan,
memang, pergi dan menerapkan

416
00:21:04,630 --> 00:21:06,020
fungsi ini get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Ini mungkin saja lebih rendah dalam file.

418
00:21:07,674 --> 00:21:09,840
Sekali lagi, ingat bahwa dentang
membaca hal-hal atas ke bawah,

419
00:21:09,840 --> 00:21:12,330
kiri ke kanan, sehingga Anda tidak bisa
memanggil fungsi jika dentang

420
00:21:12,330 --> 00:21:15,330
tidak tahu itu akan ada.

421
00:21:15,330 --> 00:21:18,430
>> Sekarang, sayangnya, program ini,
karena beberapa dari Anda mungkin telah memperhatikan,

422
00:21:18,430 --> 00:21:19,590
sudah kereta.

423
00:21:19,590 --> 00:21:21,400
Biarkan aku pergi ke depan dan membuat buggy3.

424
00:21:21,400 --> 00:21:26,904
Mengkompilasi, jadi masalah saya sekarang tidak
kesalahan sintaks, seperti kesalahan tekstual,

425
00:21:26,904 --> 00:21:29,570
itu benar-benar akan menjadi logis
kesalahan yang telah saya sengaja

426
00:21:29,570 --> 00:21:32,450
dibuat sebagai kesempatan untuk
langkah melalui apa yang terjadi.

427
00:21:32,450 --> 00:21:35,540
>> Aku akan pergi ke depan
sekarang dan menjalankan buggy3.

428
00:21:35,540 --> 00:21:37,490
Dan aku akan pergi
ke depan dan tidak bekerja sama.

429
00:21:37,490 --> 00:21:39,494
Aku akan memberikan nomor 1.

430
00:21:39,494 --> 00:21:41,410
Ini tidak seperti itu, jadi
itu mendorong saya lagi.

431
00:21:41,410 --> 00:21:42,147
>> Bagaimana 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Tak satu pun dari mereka yang bekerja.

435
00:21:44,740 --> 00:21:46,890
Bagaimana -50?

436
00:21:46,890 --> 00:21:48,560
Dan program tampaknya bekerja.

437
00:21:48,560 --> 00:21:49,970
>> Biarkan aku mencobanya sekali lagi.

438
00:21:49,970 --> 00:21:53,400
Biarkan aku mencoba -1, tampaknya bekerja.

439
00:21:53,400 --> 00:21:56,380
Biarkan aku mencoba -2, tampaknya bekerja.

440
00:21:56,380 --> 00:21:59,640
Biarkan aku mencoba 0.

441
00:21:59,640 --> 00:22:01,684
Ya, itu tidak benar.

442
00:22:01,684 --> 00:22:03,350
Sekarang, kita sedang sedikit bertele-tele di sini.

443
00:22:03,350 --> 00:22:07,090
Tapi itu, memang, hal 0
yang tidak positif atau negatif.

444
00:22:07,090 --> 00:22:11,150
Dan fakta bahwa program saya adalah
mengatakan bahwa 0 adalah bilangan bulat negatif,

445
00:22:11,150 --> 00:22:12,820
itu tidak benar secara teknis.

446
00:22:12,820 --> 00:22:15,180
>> Sekarang, mengapa melakukan ini?

447
00:22:15,180 --> 00:22:16,270
Nah, itu mungkin jelas.

448
00:22:16,270 --> 00:22:18,110
Dan, memang, program ini
dimaksudkan untuk menjadi cukup sederhana

449
00:22:18,110 --> 00:22:19,670
sehingga kita memiliki sesuatu untuk mengeksplorasi.

450
00:22:19,670 --> 00:22:25,870
>> Tapi mari kita memperkenalkan debugging ketiga
Teknik sini disebut debug50.

451
00:22:25,870 --> 00:22:27,750
Jadi ini adalah sebuah program
bahwa kita baru saja dibuat

452
00:22:27,750 --> 00:22:30,770
tahun bernama ini debug50
yang akan memungkinkan Anda

453
00:22:30,770 --> 00:22:34,130
untuk menggunakan apa yang disebut built-in
debugger grafis dalam CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Dan debugger hanya sebuah program yang
umumnya memungkinkan Anda menjalankan program Anda

455
00:22:38,400 --> 00:22:44,050
tapi langkah demi langkah langkah, baris demi
oleh baris demi baris, berhenti, menusuk

456
00:22:44,050 --> 00:22:47,626
sekitar, melihat variabel sehingga
program ini tidak hanya meniup masa lalu Anda

457
00:22:47,626 --> 00:22:49,750
dan cepat mencetak sesuatu
atau tidak mencetak sesuatu.

458
00:22:49,750 --> 00:22:53,250
Ini memberi Anda kesempatan, di
kecepatan manusia, untuk berinteraksi dengan itu.

459
00:22:53,250 --> 00:22:55,470
>> Dan untuk melakukan hal ini, Anda
hanya melakukan hal berikut.

460
00:22:55,470 --> 00:22:58,479
Setelah kompilasi kode Anda,
yang saya sudah lakukan, buggy3,

461
00:22:58,479 --> 00:23:00,020
Anda pergi ke depan dan menjalankan ./buggy debug50.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Begitu banyak seperti help50 memiliki Anda menjalankan
help50 dan kemudian perintah,

464
00:23:06,760 --> 00:23:10,120
debug50 memiliki Anda menjalankan debug50 dan
maka nama dari perintah.

465
00:23:10,120 --> 00:23:14,440
>> Sekarang lihat apa yang terjadi di layar saya,
di sisi kanan pada khususnya.

466
00:23:14,440 --> 00:23:19,400
Ketika saya memukul Run, semua
panel kanan ini tiba-tiba

467
00:23:19,400 --> 00:23:20,419
membuka di layar.

468
00:23:20,419 --> 00:23:22,210
Dan ada banyak hal yang terjadi
pada pada pandangan pertama.

469
00:23:22,210 --> 00:23:25,110
Tapi ada tidak terlalu
banyak perlu khawatir belum.

470
00:23:25,110 --> 00:23:28,570
>> Hal ini menunjukkan semuanya padaku
yang terjadi di dalam program saya

471
00:23:28,570 --> 00:23:31,130
sekarang dan melalui ini
tombol di bagian atas kemudian

472
00:23:31,130 --> 00:23:35,910
memungkinkan saya untuk melangkah melalui kode saya
akhirnya langkah demi langkah demi langkah.

473
00:23:35,910 --> 00:23:37,140
Tapi bukan hanya belum.

474
00:23:37,140 --> 00:23:38,060
Perhatikan apa yang terjadi.

475
00:23:38,060 --> 00:23:40,600
Pada jendela terminal saya
Saya sedang diminta untuk n.

476
00:23:40,600 --> 00:23:44,560
Dan aku akan pergi ke depan dan
bekerja sama saat ini dan ketik -1.

477
00:23:44,560 --> 00:23:48,770
Dan meskipun sedikit samar, -1
adalah bilangan bulat negatif, seperti yang diharapkan.

478
00:23:48,770 --> 00:23:52,020
>> Dan kemudian anak keluar dengan
Status 0 GDBserver keluar.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, adalah nama
dari perangkat lunak yang mendasari

480
00:23:55,180 --> 00:23:56,620
yang mengimplementasikan debugger ini.

481
00:23:56,620 --> 00:24:00,500
Tapi semua ini benar-benar berarti, debugger
pergi karena program saya berhenti

482
00:24:00,500 --> 00:24:01,710
dan semua adalah baik.

483
00:24:01,710 --> 00:24:06,020
Jika saya ingin benar-benar debug program saya,
Saya harus Terlebih Dahulu memberitahu debug50,

484
00:24:06,020 --> 00:24:08,920
di mana saya ingin memulai
melangkah melalui kode saya?

485
00:24:08,920 --> 00:24:11,750
>> Dan mungkin cara paling sederhana
untuk melakukannya adalah sebagai berikut.

486
00:24:11,750 --> 00:24:15,300
Jika saya arahkan kursor
selokan editor saya di sini,

487
00:24:15,300 --> 00:24:19,090
sehingga benar-benar hanya di sidebar sini,
di sebelah kiri nomor baris,

488
00:24:19,090 --> 00:24:21,870
pemberitahuan bahwa jika saya klik saja
sekali, aku meletakkan titik merah kecil.

489
00:24:21,870 --> 00:24:24,460
Dan yang sedikit red dot,
seperti tanda berhenti, berarti, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, eksekusi jeda kode saya
di sana ketika saya menjalankan program ini.

491
00:24:29,430 --> 00:24:30,260
>> Jadi mari kita melakukan itu.

492
00:24:30,260 --> 00:24:37,340
Biarkan aku pergi ke depan dan menjalankan program saya
lagi dengan debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Dan sekarang, pemberitahuan, sesuatu
yang berbeda telah terjadi.

494
00:24:40,110 --> 00:24:42,440
Aku tidak sedang diminta
namun dalam jendela terminal saya

495
00:24:42,440 --> 00:24:45,430
untuk apa-apa, karena saya belum
sampai di sana belum di program saya.

496
00:24:45,430 --> 00:24:47,950
Perhatikan bahwa pada baris 8
yang sekarang disorot,

497
00:24:47,950 --> 00:24:51,720
dan ada panah kecil di
pepatah kiri, Anda berhenti di sini.

498
00:24:51,720 --> 00:24:55,030
Ini baris kode, baris
8, belum dilaksanakan.

499
00:24:55,030 --> 00:24:58,940
>> Dan apa yang penasaran, jika saya melihat
di sini di sisi kanan,

500
00:24:58,940 --> 00:25:03,530
melihat bahwa saya adalah lokal
variabel, lokal dalam arti

501
00:25:03,530 --> 00:25:05,450
bahwa itu dalam fungsi saat ini.

502
00:25:05,450 --> 00:25:08,920
Dan nilainya, ternyata secara default,
dan semacam nyaman, adalah 0.

503
00:25:08,920 --> 00:25:10,260
Tapi aku tidak mengetik 0.

504
00:25:10,260 --> 00:25:13,410
Yang kebetulan menjadi yang
nilai default pada saat ini.

505
00:25:13,410 --> 00:25:15,490
>> Jadi biarkan aku pergi ke depan dan melakukannya sekarang.

506
00:25:15,490 --> 00:25:18,680
Biarkan aku pergi ke depan dan pada
atas di sini, aku

507
00:25:18,680 --> 00:25:20,970
akan pergi ke depan dan
klik icon pertama yang

508
00:25:20,970 --> 00:25:25,360
berarti langkah lebih yang berarti tidak melewatkan
tapi langkah lebih baris kode ini,

509
00:25:25,360 --> 00:25:27,770
dijalankan sepanjang jalan.

510
00:25:27,770 --> 00:25:30,710
>> Dan sekarang, perhatikan, saya
cepat baru saja berubah.

511
00:25:30,710 --> 00:25:31,380
Mengapa demikian?

512
00:25:31,380 --> 00:25:33,639
Aku sudah bilang debug50,
menjalankan baris kode ini.

513
00:25:33,639 --> 00:25:34,930
Apa baris kode ini lakukan?

514
00:25:34,930 --> 00:25:35,960
Mendorong saya untuk int.

515
00:25:35,960 --> 00:25:36,460
BAIK.

516
00:25:36,460 --> 00:25:37,400
Biarkan saya bekerja sama.

517
00:25:37,400 --> 00:25:41,340
Biarkan aku pergi ke depan sekarang dan ketik -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Dan sekarang melihat apa yang telah berubah.

519
00:25:42,920 --> 00:25:46,060
Di sisi kanan,
variabel lokal saya i

520
00:25:46,060 --> 00:25:48,200
diindikasikan sebagai -1 sekarang.

521
00:25:48,200 --> 00:25:49,810
Dan itu masih tipe int.

522
00:25:49,810 --> 00:25:53,102
>> Dan pemberitahuan, juga, saya disebut
panggilan tumpukan, di mana aku berhenti?

523
00:25:53,102 --> 00:25:54,810
Kita akan berbicara lebih lanjut tentang
ini di masa depan.

524
00:25:54,810 --> 00:25:58,620
Tapi panggilan stack hanya mengacu pada apa
fungsi yang saat ini bergerak.

525
00:25:58,620 --> 00:26:00,040
Sekarang itu hanya main.

526
00:26:00,040 --> 00:26:03,590
Dan sekarang hanya lokal
variabel i dengan nilai 1.

527
00:26:03,590 --> 00:26:09,840
>> Dan ketika saya akhirnya melangkahi garis ini
di sini, dengan ikon yang sama di kanan atas,

528
00:26:09,840 --> 00:26:11,410
-1 Adalah bilangan bulat negatif.

529
00:26:11,410 --> 00:26:13,580
Sekarang itu berhenti lebih dari yang brace keriting.

530
00:26:13,580 --> 00:26:14,740
Mari kita biarkan melakukan hal tersebut.

531
00:26:14,740 --> 00:26:17,300
Aku melangkahi garis, dan voila.

532
00:26:17,300 --> 00:26:20,240
>> Jadi tidak semua yang sangat
mencerahkan belum,

533
00:26:20,240 --> 00:26:23,550
tapi itu biarkan aku berhenti
dan memikirkan secara logis

534
00:26:23,550 --> 00:26:24,870
apa program ini adalah melakukan.

535
00:26:24,870 --> 00:26:26,890
Tapi itu tidak terjadi salah.

536
00:26:26,890 --> 00:26:28,510
Mari kita lakukan ini lagi sebagai berikut.

537
00:26:28,510 --> 00:26:31,340
>> Aku akan meninggalkan breakpoint yang
pada baris 8 dengan titik merah.

538
00:26:31,340 --> 00:26:32,830
Aku akan menjalankan kembali debug50.

539
00:26:32,830 --> 00:26:34,400
Ini secara otomatis berhenti di sini.

540
00:26:34,400 --> 00:26:37,660
Tapi kali ini, bukannya
melangkahi garis ini,

541
00:26:37,660 --> 00:26:42,290
biarkan aku benar-benar pergi dalam
get_negative_int dan mencari tahu,

542
00:26:42,290 --> 00:26:45,530
mengapa itu menerima 0 sebagai jawaban yang valid?

543
00:26:45,530 --> 00:26:47,990
>> Jadi, bukannya mengklik Langkah Over.

544
00:26:47,990 --> 00:26:50,630
Aku akan pergi ke depan
dan klik Langkah Ke.

545
00:26:50,630 --> 00:26:54,030
Dan perhatikan bahwa garis 8 itu
sekarang disorot sekarang tiba-tiba

546
00:26:54,030 --> 00:26:56,900
menjadi garis 17.

547
00:26:56,900 --> 00:26:59,947
>> Sekarang, itu tidak debugger
telah dilewati garis 14 dan 15 dan 16.

548
00:26:59,947 --> 00:27:01,780
Hanya saja tidak ada
menampilkan sana.

549
00:27:01,780 --> 00:27:04,050
Mereka hanya menyatakan variabel,
dan kemudian ada kata Dilakukan

550
00:27:04,050 --> 00:27:05,390
dan kemudian brace keriting terbuka.

551
00:27:05,390 --> 00:27:09,227
Satu-satunya jalur fungsional yang
berair benar-benar adalah salah satu ini di sini, 17.

552
00:27:09,227 --> 00:27:11,060
Dan di situlah kita sudah
berhenti secara otomatis.

553
00:27:11,060 --> 00:27:13,870
>> Jadi printf ( "n.is:") ;, sehingga
yang belum terjadi.

554
00:27:13,870 --> 00:27:18,250
Jadi mari kita pergi ke depan dan klik Langkah Over.

555
00:27:18,250 --> 00:27:20,326
Sekarang saya prompt, memang,
berubah menjadi ( "n adalah:").

556
00:27:20,326 --> 00:27:22,450
Sekarang get_int, aku tidak akan
repot melangkah ke,

557
00:27:22,450 --> 00:27:24,750
karena fungsi itu
dibuat oleh CS50 di Perpustakaan.

558
00:27:24,750 --> 00:27:25,750
Ini mungkin benar.

559
00:27:25,750 --> 00:27:28,440
>> Jadi aku akan pergi ke depan dan
semacam bekerja sama dengan memberi

560
00:27:28,440 --> 00:27:30,590
int, tapi bukan int negatif.

561
00:27:30,590 --> 00:27:32,870
Jadi biarkan aku pergi ke depan dan memukul 0.

562
00:27:32,870 --> 00:27:39,460
Dan sekarang apa yang terjadi di sini
ketika saya turun ke baris 21?

563
00:27:39,460 --> 00:27:40,890
Aku sudah tidak mengulangi lagi.

564
00:27:40,890 --> 00:27:43,320
Saya tampaknya tidak akan terjebak dalam lingkaran itu.

565
00:27:43,320 --> 00:27:45,990
Dengan kata lain, ini kuning
bar tidak terus terjadi di sekitar,

566
00:27:45,990 --> 00:27:47,130
dan sekitar, dan sekitar.

567
00:27:47,130 --> 00:27:48,340
>> Sekarang, kenapa begitu?

568
00:27:48,340 --> 00:27:49,920
Nah, n, apa yang n sekarang?

569
00:27:49,920 --> 00:27:53,280
Saya dapat melihat lokal
variabel dalam debugger.

570
00:27:53,280 --> 00:27:53,816
n adalah 0.

571
00:27:53,816 --> 00:27:55,190
Baiklah, apa kondisi saya?

572
00:27:55,190 --> 00:27:58,700
>> 20-- line 20 adalah, baik,
0 lebih besar dari 0.

573
00:27:58,700 --> 00:27:59,500
Itu tidak benar.

574
00:27:59,500 --> 00:28:01,020
0 adalah tidak lebih besar dari 0.

575
00:28:01,020 --> 00:28:02,820
Dan jadi saya pecah ini.

576
00:28:02,820 --> 00:28:06,370
>> Dan jadi itu sebabnya on line
21, jika saya benar-benar terus,

577
00:28:06,370 --> 00:28:10,370
Aku akan kembali 0, bahkan
meskipun saya harus menolak 0

578
00:28:10,370 --> 00:28:12,484
tidak benar-benar menjadi negatif.

579
00:28:12,484 --> 00:28:14,650
Jadi sekarang, saya tidak benar-benar bahkan
peduli debugger.

580
00:28:14,650 --> 00:28:16,900
Mendapatkannya, saya tidak perlu
tahu apa lagi yang terjadi.

581
00:28:16,900 --> 00:28:19,233
>> Jadi aku akan pergi ke depan dan
klik tombol Play,

582
00:28:19,233 --> 00:28:20,240
dan biarkan finish hal ini.

583
00:28:20,240 --> 00:28:23,440
Sekarang, saya sudah menyadari bahwa saya
bug tampaknya on line 20.

584
00:28:23,440 --> 00:28:25,160
Itu kesalahan logis saya.

585
00:28:25,160 --> 00:28:28,100
>> Dan jadi apa yang saya inginkan
lakukan untuk mengubah ini?

586
00:28:28,100 --> 00:28:32,500
Jika masalahnya adalah bahwa saya tidak
catching 0, itu hanya kesalahan logis.

587
00:28:32,500 --> 00:28:35,910
Dan bisa saya katakan saat n adalah
lebih besar dari atau sama dengan 0,

588
00:28:35,910 --> 00:28:38,330
terus mendorong pengguna lagi dan lagi.

589
00:28:38,330 --> 00:28:41,050
>> Jadi, sekali lagi, kesalahan sederhana, mungkin
bahkan jelas ketika Anda melihat saya

590
00:28:41,050 --> 00:28:42,410
menulis itu hanya beberapa menit yang lalu.

591
00:28:42,410 --> 00:28:44,570
Tapi takeaway di sini
adalah bahwa dengan men-debug 50,

592
00:28:44,570 --> 00:28:46,850
dan dengan debugging
perangkat lunak yang lebih umum,

593
00:28:46,850 --> 00:28:51,370
Anda memiliki kekuatan menemukan ini baru untuk
berjalan melalui kode Anda sendiri, terlihat

594
00:28:51,370 --> 00:28:55,590
melalui panel tangan yang tepat apa yang
nilai-nilai variabel Anda.

595
00:28:55,590 --> 00:28:57,700
Jadi Anda tidak perlu
harus menggunakan sesuatu

596
00:28:57,700 --> 00:29:00,630
seperti Anda eprintf untuk mencetak nilai-nilai tersebut.

597
00:29:00,630 --> 00:29:04,430
Anda benar-benar dapat melihat mereka
visual di layar.

598
00:29:04,430 --> 00:29:08,920
>> Sekarang, di luar ini, itu perlu dicatat
bahwa ada teknik lain yang

599
00:29:08,920 --> 00:29:09,890
sebenarnya super umum.

600
00:29:09,890 --> 00:29:13,120
Dan Anda mungkin bertanya-tanya mengapa hal ini sedikit
orang di sini telah duduk di atas panggung.

601
00:29:13,120 --> 00:29:16,490
Jadi ada teknik ini, umumnya
dikenal sebagai bebek karet debugging,

602
00:29:16,490 --> 00:29:18,786
yang benar-benar hanya
bukti fakta

603
00:29:18,786 --> 00:29:20,660
yang sering ketika programmer
menulis kode,

604
00:29:20,660 --> 00:29:22,650
mereka belum tentu
berkolaborasi dengan orang lain,

605
00:29:22,650 --> 00:29:24,030
atau bekerja di lingkungan bersama.

606
00:29:24,030 --> 00:29:25,050
>> Mereka semacam di rumah.

607
00:29:25,050 --> 00:29:25,910
Mungkin itu larut malam.

608
00:29:25,910 --> 00:29:28,190
Mereka mencoba untuk angka
beberapa bug dalam kode mereka.

609
00:29:28,190 --> 00:29:29,330
Dan mereka hanya tidak melihatnya.

610
00:29:29,330 --> 00:29:30,329
>> Dan tidak ada teman sekamar.

611
00:29:30,329 --> 00:29:31,250
Tidak ada TF.

612
00:29:31,250 --> 00:29:32,680
Tidak ada CA di sekitar.

613
00:29:32,680 --> 00:29:36,440
Semua yang mereka miliki di rak mereka
adalah bebek karet kecil ini.

614
00:29:36,440 --> 00:29:39,030
>> Dan jadi bebek karet debugging
hanya undangan ini

615
00:29:39,030 --> 00:29:42,780
untuk memikirkan sesuatu yang konyol
karena ini sebagai makhluk yang nyata,

616
00:29:42,780 --> 00:29:46,940
dan benar-benar berjalan melalui kode Anda
secara lisan kepada benda mati ini.

617
00:29:46,940 --> 00:29:49,230
Jadi, misalnya, jika
ini adalah contoh saya di sini-

618
00:29:49,230 --> 00:29:52,470
dan ingat bahwa sebelumnya
masalahnya adalah ini,

619
00:29:52,470 --> 00:29:58,140
jika saya menghapus baris pertama kode ini,
dan aku pergi ke depan dan membuat kereta 0 lagi,

620
00:29:58,140 --> 00:30:01,220
ingat bahwa saya punya ini
pesan error di sini.

621
00:30:01,220 --> 00:30:05,997
Jadi ide di sini, konyol meskipun saya
merasa pada saat melakukan hal ini secara terbuka,

622
00:30:05,997 --> 00:30:06,580
kesalahan itu.

623
00:30:06,580 --> 00:30:10,910
>> OK, jadi masalah saya adalah bahwa saya sudah
implisit menyatakan fungsi perpustakaan.

624
00:30:10,910 --> 00:30:12,610
Dan bahwa fungsi perpustakaan printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, menyatakan
mengingatkan saya pada prototipe.

626
00:30:15,290 --> 00:30:18,930
>> Itu berarti saya harus benar-benar
memberitahu compiler terlebih dahulu apa

627
00:30:18,930 --> 00:30:19,980
fungsi terlihat seperti.

628
00:30:19,980 --> 00:30:20,930
Tunggu sebentar.

629
00:30:20,930 --> 00:30:23,580
Aku tidak punya io.h. standar

630
00:30:23,580 --> 00:30:24,530
Terima kasih banyak.

631
00:30:24,530 --> 00:30:27,330
>> Jadi hanya proses ini of-- Anda
tidak perlu benar-benar memiliki bebek.

632
00:30:27,330 --> 00:30:29,819
Tapi ide ini berjalan
sendiri melalui kode Anda sendiri

633
00:30:29,819 --> 00:30:31,610
sehingga Anda bahkan mendengar
sendiri, sehingga Anda

634
00:30:31,610 --> 00:30:35,620
menyadari kelalaian dalam Anda sendiri
komentar, umumnya ide.

635
00:30:35,620 --> 00:30:38,910
>> Dan, mungkin lebih logis, tidak begitu
banyak dengan yang satu tapi lebih terlibat

636
00:30:38,910 --> 00:30:44,220
Misalnya kita hanya melakukan di 3.c kereta,
Anda mungkin berjalan sendiri melalui itu

637
00:30:44,220 --> 00:30:45,310
sebagai berikut.

638
00:30:45,310 --> 00:30:49,190
Jadi baiklah, karet
bebek, DDB, jika Anda mau.

639
00:30:49,190 --> 00:30:52,350
Di sini kita memiliki fungsi utama saya,
Saya menelepon mendapatkan int negatif.

640
00:30:52,350 --> 00:30:54,660
>> Dan saya mendapatkan nilai kembali.

641
00:30:54,660 --> 00:31:00,410
Aku menyimpannya di sisi kiri
pada baris 8 dalam variabel yang disebut i.

642
00:31:00,410 --> 00:31:02,380
OK, tapi tunggu, bagaimana
yang mendapatkan nilai itu?

643
00:31:02,380 --> 00:31:04,130
Biarkan aku melihat fungsi sejalan 12.

644
00:31:04,130 --> 00:31:05,760
>> Sejalan 12, kita telah mendapatkan int negatif.

645
00:31:05,760 --> 00:31:08,190
Tidak mengambil input apapun,
tidak mengembalikan int, OK.

646
00:31:08,190 --> 00:31:10,929
Saya menyatakan on line 14 variabel n.

647
00:31:10,929 --> 00:31:12,220
Ini akan menyimpan integer.

648
00:31:12,220 --> 00:31:13,760
Itu yang saya mau.

649
00:31:13,760 --> 00:31:18,480
>> Jadi melakukan hal berikut saat n is-- membiarkan
saya membatalkan apa yang memperbaiki saya sudah dibuat.

650
00:31:18,480 --> 00:31:22,710
Jadi sementara n lebih besar dari
0, mencetak n adalah, OK.

651
00:31:22,710 --> 00:31:25,170
Dan kemudian memanggil mendapatkan int disimpan di n.

652
00:31:25,170 --> 00:31:30,160
Dan kemudian memeriksa apakah n adalah 0,
n adalah not-- ada itu.

653
00:31:30,160 --> 00:31:31,910
Jadi, sekali lagi, Anda tidak
perlu bebek yang sebenarnya.

654
00:31:31,910 --> 00:31:35,650
Tapi hanya berjalan sendiri melalui
kode Anda sebagai latihan intelektual

655
00:31:35,650 --> 00:31:37,720
sering akan membantu Anda
menyadari apa yang terjadi,

656
00:31:37,720 --> 00:31:41,170
sebagai lawan hanya melakukan sesuatu
seperti ini, menatap layar,

657
00:31:41,170 --> 00:31:43,720
dan tidak berbicara diri melalui
itu, yang jujur tidak

658
00:31:43,720 --> 00:31:46,270
hampir sama teknik yang efektif.

659
00:31:46,270 --> 00:31:48,620
Jadi di sana Anda memilikinya, sebuah
sejumlah teknik yang berbeda

660
00:31:48,620 --> 00:31:52,102
untuk benar-benar debugging kode Anda
dan menemukan kesalahan, yang semuanya

661
00:31:52,102 --> 00:31:54,810
harus menjadi alat dalam toolkit Anda
sehingga Anda tidak larut malam,

662
00:31:54,810 --> 00:31:57,660
terutama, Anda berada di makan
ruang, atau pada jam-jam kantor,

663
00:31:57,660 --> 00:32:00,368
membenturkan kepala Anda terhadap
dinding, mencoba untuk memecahkan beberapa masalah.

664
00:32:00,368 --> 00:32:02,020
Menyadari bahwa ada perangkat lunak.

665
00:32:02,020 --> 00:32:03,720
Ada alat bebek karet.

666
00:32:03,720 --> 00:32:09,630
Dan ada seluruh staf
mendukung menunggu untuk mengulurkan tangan.

667
00:32:09,630 --> 00:32:13,120
>> Jadi sekarang, kata pada masalah
set, dan pada apa yang kita berharap Anda

668
00:32:13,120 --> 00:32:15,620
keluar dari mereka, dan bagaimana
kita pergi tentang evaluasi.

669
00:32:15,620 --> 00:32:17,680
Per silabus kursus ini,
Masalah set CS50 ini

670
00:32:17,680 --> 00:32:22,320
dievaluasi pada empat sumbu utama, sehingga
untuk speak-- lingkup, ketepatan, desain,

671
00:32:22,320 --> 00:32:23,060
dan gaya.

672
00:32:23,060 --> 00:32:25,910
Dan ruang lingkup hanya mengacu pada berapa banyak
potongan yang telah Anda digigit off?

673
00:32:25,910 --> 00:32:28,080
Berapa banyak dari masalah yang telah Anda coba?

674
00:32:28,080 --> 00:32:30,110
Apa tingkat usaha
Anda telah terwujud?

675
00:32:30,110 --> 00:32:35,750
>> Kebenaran adalah, apakah program kerja sebagai
itu seharusnya sesuai spesifikasi CS50

676
00:32:35,750 --> 00:32:38,640
ketika Anda memberikan masukan tertentu
atau output tertentu datang kembali?

677
00:32:38,640 --> 00:32:41,130
Desain adalah yang paling subjektif dari mereka.

678
00:32:41,130 --> 00:32:43,360
Dan itu salah satu yang akan
mengambil terpanjang untuk belajar

679
00:32:43,360 --> 00:32:47,220
dan terpanjang untuk mengajar, di
sejauh itu bermuara,

680
00:32:47,220 --> 00:32:49,530
seberapa baik ditulis adalah kode Anda?

681
00:32:49,530 --> 00:32:52,920
>> Itu salah satu hal untuk hanya mencetak yang benar
output atau mengembalikan nilai-nilai yang tepat.

682
00:32:52,920 --> 00:32:55,400
Tapi yang Anda lakukan sebagai
seefisien mungkin?

683
00:32:55,400 --> 00:32:58,210
Apakah Anda melakukan itu membagi
dan menaklukkan, atau biner

684
00:32:58,210 --> 00:33:01,500
pencarian seperti yang kita akan segera melihat bahwa yang kita lakukan
dua minggu yang lalu dengan buku telepon?

685
00:33:01,500 --> 00:33:04,670
Apakah ada cara yang lebih baik untuk memecahkan
masalah dari saat ini Anda miliki di sini?

686
00:33:04,670 --> 00:33:06,380
Itu kesempatan untuk desain yang lebih baik.

687
00:33:06,380 --> 00:33:08,530
>> Dan kemudian style-- bagaimana
cukup adalah kode Anda?

688
00:33:08,530 --> 00:33:12,370
Anda akan melihat bahwa aku cukup
khusus tentang indentasi kode saya,

689
00:33:12,370 --> 00:33:15,300
dan memastikan variabel saya
yang cukup bernama. n,

690
00:33:15,300 --> 00:33:19,660
sementara waktu, adalah nama yang bagus untuk
nomor, i untuk menghitung bilangan bulat,

691
00:33:19,660 --> 00:33:20,727
s untuk string.

692
00:33:20,727 --> 00:33:22,560
Dan kita dapat memiliki lagi
variabel nama gaya.

693
00:33:22,560 --> 00:33:25,500
Gaya adalah seberapa baik
apakah kode Anda terlihat?

694
00:33:25,500 --> 00:33:26,600
Dan bagaimana dibaca itu?

695
00:33:26,600 --> 00:33:29,650
>> Dan dari waktu ke waktu, apa TA Anda
dan TF akan dilakukan di kursus

696
00:33:29,650 --> 00:33:31,870
adalah menyediakan Anda dengan itu
jenis umpan balik kualitatif

697
00:33:31,870 --> 00:33:34,330
sehingga Anda mendapatkan yang lebih baik
pada orang-orang berbagai aspek.

698
00:33:34,330 --> 00:33:37,510
Dan dalam hal bagaimana kita
mengevaluasi setiap sumbu tersebut,

699
00:33:37,510 --> 00:33:40,080
itu biasanya dengan sangat sedikit
ember sehingga Anda, umumnya,

700
00:33:40,080 --> 00:33:41,680
mendapatkan rasa seberapa baik Anda lakukan.

701
00:33:41,680 --> 00:33:45,680
Dan, memang, jika Anda menerima skor pada
salah satu dari mereka axes-- kebenaran, desain

702
00:33:45,680 --> 00:33:49,659
dan gaya especially-- nomor yang
umumnya akan antara 1 dan 5.

703
00:33:49,659 --> 00:33:52,450
Dan, secara harfiah, jika Anda mendapatkan
3 pada awal semester,

704
00:33:52,450 --> 00:33:53,977
ini adalah hal yang sangat baik.

705
00:33:53,977 --> 00:33:55,810
Ini berarti masih ada
ruang untuk perbaikan,

706
00:33:55,810 --> 00:33:58,490
yang akan Anda berharap untuk di
mengambil kelas untuk pertama kalinya.

707
00:33:58,490 --> 00:34:01,820
Ada mudah-mudahan beberapa bit dari langit-langit
yang Anda bercita-cita untuk mencapai.

708
00:34:01,820 --> 00:34:03,970
Dan sehingga mendapatkan 3 pada
potongan awal,

709
00:34:03,970 --> 00:34:06,550
jika tidak beberapa 2 dan 4.,
adalah, memang, hal yang baik.

710
00:34:06,550 --> 00:34:08,880
Ini juga dalam jangkauan,
baik dalam harapan.

711
00:34:08,880 --> 00:34:11,421
>> Dan jika pikiran Anda balap, tunggu
satu menit, tiga dari lima.

712
00:34:11,421 --> 00:34:12,620
Itu benar-benar 6 dari 10.

713
00:34:12,620 --> 00:34:13,560
Itu 60%.

714
00:34:13,560 --> 00:34:14,830
Tuhan, itu sebuah F.

715
00:34:14,830 --> 00:34:15,870
>> Ini bukan.

716
00:34:15,870 --> 00:34:17,600
Ini tidak, pada kenyataannya, itu.

717
00:34:17,600 --> 00:34:22,710
Sebaliknya, ini merupakan kesempatan untuk meningkatkan
selama semester.

718
00:34:22,710 --> 00:34:25,580
Dan jika Anda mendapatkan beberapa
poors, ini adalah kesempatan

719
00:34:25,580 --> 00:34:29,199
untuk mengambil keuntungan dari jam kantor,
tentu bagian dan sumber daya lainnya.

720
00:34:29,199 --> 00:34:32,840
>> Terbaik adalah kesempatan, benar-benar,
menjadi bangga seberapa jauh Anda sudah

721
00:34:32,840 --> 00:34:34,520
datang selama semester.

722
00:34:34,520 --> 00:34:38,199
Jadi menyadari, jika tidak ada
lain, tiga baik.

723
00:34:38,199 --> 00:34:40,179
Dan memungkinkan ruang untuk pertumbuhan dari waktu ke waktu.

724
00:34:40,179 --> 00:34:43,090
>> Bagaimana mereka sumbu yang
tertimbang, realistis Anda

725
00:34:43,090 --> 00:34:46,745
akan menghabiskan sebagian besar waktu Anda mendapatkan
hal bekerja, apalagi dengan benar.

726
00:34:46,745 --> 00:34:49,120
Dan kebenaran cenderung
tertimbang yang paling, seperti dengan

727
00:34:49,120 --> 00:34:51,360
Faktor perkalian ini tiga.

728
00:34:51,360 --> 00:34:54,659
Desain juga penting, tapi
sesuatu yang Anda lakukan belum tentu

729
00:34:54,659 --> 00:34:58,220
menghabiskan semua jam-jam di
mencoba untuk mendapatkan sesuatu hanya untuk bekerja.

730
00:34:58,220 --> 00:35:00,019
>> Dan itu berbobot
sedikit lebih ringan.

731
00:35:00,019 --> 00:35:01,560
Dan kemudian gaya berbobot sedikit.

732
00:35:01,560 --> 00:35:03,710
Meskipun itu tidak kurang
penting fundamental,

733
00:35:03,710 --> 00:35:05,990
itu hanya, mungkin,
Hal yang paling mudah untuk melakukan yang benar,

734
00:35:05,990 --> 00:35:08,440
meniru contoh kami
dilakukan di kuliah dan bagian,

735
00:35:08,440 --> 00:35:11,080
dengan hal-hal baik
indentasi, dan berkomentar,

736
00:35:11,080 --> 00:35:14,320
dan sebagainya adalah salah satu yang paling mudah
untuk melakukan sesuatu dan mendapatkan hak.

737
00:35:14,320 --> 00:35:16,960
Jadi dengan demikian, menyadari
bahwa mereka adalah poin

738
00:35:16,960 --> 00:35:19,000
yang relatif mudah untuk dipahami.

739
00:35:19,000 --> 00:35:22,360
>> Dan sekarang kata pada
ini-- kejujuran akademik.

740
00:35:22,360 --> 00:35:25,150
Jadi per kursus ini
silabus, Anda akan melihat

741
00:35:25,150 --> 00:35:27,630
yang tentu saja memiliki cukup
sedikit bahasa sekitar ini.

742
00:35:27,630 --> 00:35:31,380
Dan tentu saja mengambil isu
kejujuran akademik cukup serius.

743
00:35:31,380 --> 00:35:33,450
>> Kami memiliki perbedaan,
untuk lebih baik atau buruk,

744
00:35:33,450 --> 00:35:36,570
karena telah mengirim setiap tahun lebih
siswa untuk tindakan disipliner

745
00:35:36,570 --> 00:35:39,670
daripada kebanyakan lainnya
Tentu saja, itu saya sadar.

746
00:35:39,670 --> 00:35:42,580
Ini tidak selalu
Berkaca dari fakta tersebut

747
00:35:42,580 --> 00:35:46,340
bahwa siswa CS, atau siswa CS50, yang
kurang jujur dari teman sekelas Anda.

748
00:35:46,340 --> 00:35:49,090
Tetapi kenyataannya bahwa dalam hal ini
dunia, elektronik, kami hanya

749
00:35:49,090 --> 00:35:50,990
memiliki teknologi
berarti mendeteksi ini.

750
00:35:50,990 --> 00:35:53,360
>> Hal ini penting bagi kami untuk
keadilan di kelas

751
00:35:53,360 --> 00:35:58,550
yang kita lakukan mendeteksi ini, dan meningkatkan
masalah ketika kita melihat hal-hal.

752
00:35:58,550 --> 00:36:01,980
Dan hanya untuk melukis gambar, dan benar-benar
untuk membantu sesuatu seperti tenggelam ini di,

753
00:36:01,980 --> 00:36:04,600
ini adalah jumlah
siswa selama 10 tahun terakhir

754
00:36:04,600 --> 00:36:07,610
yang telah terlibat dalam beberapa
isu-isu seperti kejujuran akademik,

755
00:36:07,610 --> 00:36:10,990
dengan beberapa 32 siswa
dari musim gugur 2015, yang

756
00:36:10,990 --> 00:36:13,760
adalah untuk mengatakan bahwa kita mengambil
masalah ini sangat serius.

757
00:36:13,760 --> 00:36:18,380
Dan, akhirnya, angka-angka ini menulis,
baru-baru ini, sekitar 3%, 4% atau lebih

758
00:36:18,380 --> 00:36:19,120
kelas.

759
00:36:19,120 --> 00:36:25,220
>> Jadi untuk sebagian super siswa
tampaknya bahwa garis-garis yang jelas.

760
00:36:25,220 --> 00:36:27,940
Tapi jangan menyimpan ini dalam
keberatan, terutama akhir

761
00:36:27,940 --> 00:36:32,080
di malam hari ketika berjuang dengan
beberapa solusi untuk satu set masalah,

762
00:36:32,080 --> 00:36:34,830
bahwa ada mekanisme
untuk mendapatkan diri Anda lebih baik

763
00:36:34,830 --> 00:36:37,870
dukungan dari Anda mungkin
berpikir, bahkan pada saat itu.

764
00:36:37,870 --> 00:36:40,514
Sadarilah bahwa ketika kita menerima
kiriman siswa, kami menyeberang

765
00:36:40,514 --> 00:36:43,430
membandingkan setiap pengajuan tahun ini
terhadap setiap pengajuan tahun lalu,

766
00:36:43,430 --> 00:36:47,590
terhadap setiap pengajuan dari 2007,
dan karena, melihat, juga,

767
00:36:47,590 --> 00:36:49,931
kode repositori online,
forum diskusi, situs pekerjaan.

768
00:36:49,931 --> 00:36:51,806
Dan kami menyebutkan ini,
benar-benar, semua demi

769
00:36:51,806 --> 00:36:56,040
pengungkapan penuh, bahwa jika
orang lain dapat menemukan secara online,

770
00:36:56,040 --> 00:36:57,880
tentu, kita juga bisa saja.

771
00:36:57,880 --> 00:37:00,100
Tapi, benar-benar, roh
tentu saja bermuara

772
00:37:00,100 --> 00:37:01,650
untuk klausul ini dalam silabus.

773
00:37:01,650 --> 00:37:03,670
Ini benar-benar hanya, masuk akal.

774
00:37:03,670 --> 00:37:06,680
>> Dan jika kita harus menguraikan bahwa
dengan hanya bahasa sedikit lebih,

775
00:37:06,680 --> 00:37:09,770
menyadari bahwa esensi dari semua
pekerjaan yang Anda kirimkan ke kursus ini

776
00:37:09,770 --> 00:37:10,954
harus Anda sendiri.

777
00:37:10,954 --> 00:37:13,870
Tetapi dalam itu, tentu ada
peluang, dan dorongan,

778
00:37:13,870 --> 00:37:17,300
dan nilai pedagogis dalam beralih ke
others-- sendiri, TF, para CA,

779
00:37:17,300 --> 00:37:20,760
yang TA, dan lain-lain di kelas,
untuk dukungan, memberitahu teman-teman sendiri

780
00:37:20,760 --> 00:37:23,547
dan teman sekamar yang telah mempelajari
CS dan pemrograman sebelumnya.

781
00:37:23,547 --> 00:37:25,130
Dan sehingga ada uang saku untuk itu.

782
00:37:25,130 --> 00:37:28,180
Dan aturan umum
adalah ini-- ketika meminta bantuan,

783
00:37:28,180 --> 00:37:31,470
Anda bisa menunjukkan kode Anda kepada orang lain,
tapi Anda mungkin tidak melihat mereka.

784
00:37:31,470 --> 00:37:34,880
Jadi bahkan jika Anda berada di jam kantor,
atau di aula D, atau di tempat lain

785
00:37:34,880 --> 00:37:37,450
bekerja pada beberapa bagian set,
bekerja bersama seorang teman, yang

786
00:37:37,450 --> 00:37:40,160
benar-benar baik-baik saja, di
akhir hari kerja Anda

787
00:37:40,160 --> 00:37:43,034
akhirnya harus milik masing-masing
Anda masing-masing, dan tidak

788
00:37:43,034 --> 00:37:45,700
ada beberapa upaya kolaborasi,
kecuali untuk tugas akhir di mana

789
00:37:45,700 --> 00:37:47,410
itu diperbolehkan dan dianjurkan.

790
00:37:47,410 --> 00:37:49,830
>> Sadarilah bahwa jika Anda
berjuang dengan sesuatu

791
00:37:49,830 --> 00:37:52,520
dan teman Anda kebetulan
untuk menjadi lebih baik ini maka Anda,

792
00:37:52,520 --> 00:37:55,130
atau lebih baik di masalah itu dari Anda,
atau sedikit lebih jauh ke depan dari Anda,

793
00:37:55,130 --> 00:37:57,330
itu benar-benar masuk akal untuk mengubah
ke teman Anda dan berkata, hey,

794
00:37:57,330 --> 00:38:00,480
Anda keberatan melihat kode saya di sini,
membantu saya melihat apa masalah saya?

795
00:38:00,480 --> 00:38:03,760
Dan, mudah-mudahan, dalam
kepentingan nilai pedagogis

796
00:38:03,760 --> 00:38:07,040
teman yang tidak hanya
mengatakan, oh, melakukan hal ini, tetapi,

797
00:38:07,040 --> 00:38:09,917
apa yang Anda hilang on line
6, atau sesuatu seperti itu?

798
00:38:09,917 --> 00:38:12,000
Tetapi solusi ini tidak
untuk teman di samping Anda

799
00:38:12,000 --> 00:38:15,617
mengatakan, oh, baik, di sini, saya menariknya
ini, dan menunjukkan solusi saya untuk Anda.

800
00:38:15,617 --> 00:38:16,450
Jadi itu adalah garis.

801
00:38:16,450 --> 00:38:18,670
Anda menunjukkan kode untuk
orang lain, tetapi Anda mungkin tidak

802
00:38:18,670 --> 00:38:22,350
melihat mereka, tunduk pada lain
kendala dalam silabus kursus ini.

803
00:38:22,350 --> 00:38:24,760
>> Jadi perlu diingat ini
disebut-penyesalan klausul

804
00:38:24,760 --> 00:38:27,560
dalam silabus kursus ini juga,
bahwa jika Anda melakukan beberapa tindakan yang

805
00:38:27,560 --> 00:38:30,476
tidak masuk akal, tapi membawanya ke
perhatian kepala kursus ini

806
00:38:30,476 --> 00:38:34,240
dalam waktu 72 jam, kursus
mungkin menjatuhkan sanksi lokal yang

807
00:38:34,240 --> 00:38:37,380
mungkin termasuk memuaskan atau
gagal kelas untuk karya yang dikirimkan.

808
00:38:37,380 --> 00:38:41,410
Tapi tentu saja tidak akan merujuk
penting untuk tindakan disipliner lanjut,

809
00:38:41,410 --> 00:38:43,010
kecuali dalam kasus-kasus tindakan berulang.

810
00:38:43,010 --> 00:38:46,632
Dengan kata lain, jika Anda membuat beberapa
bodoh, terutama larut malam, keputusan

811
00:38:46,632 --> 00:38:49,340
bahwa keesokan harinya atau dua hari
kemudian, Anda bangun dan menyadari,

812
00:38:49,340 --> 00:38:50,870
apa yang saya pikirkan?

813
00:38:50,870 --> 00:38:53,890
Anda di CS50 memiliki outlet
untuk memperbaiki masalah yang

814
00:38:53,890 --> 00:38:57,170
dan memiliki untuk itu, sehingga kita
akan bertemu Anda setengah jalan dan menangani

815
00:38:57,170 --> 00:39:01,500
dengan itu dalam hal yang bersifat
pendidikan dan berharga untuk Anda,

816
00:39:01,500 --> 00:39:04,200
tapi masih menghukum dalam beberapa cara.

817
00:39:04,200 --> 00:39:08,590
Dan sekarang, untuk mengambil tepi off, ini.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO PEMUTARAN]

819
00:39:10,570 --> 00:39:13,540
>> [MUSIC PLAYING]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END PEMUTARAN]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Malan: Baiklah, kita kembali.

823
00:40:00,490 --> 00:40:03,680
Dan sekarang kita melihat salah satu
pertama domain dunia nyata kami

824
00:40:03,680 --> 00:40:08,720
di CS50, seni kriptografi,
seni mengirim dan menerima

825
00:40:08,720 --> 00:40:11,840
pesan rahasia, terenkripsi
pesan jika Anda mau,

826
00:40:11,840 --> 00:40:17,060
yang hanya dapat diuraikan jika Anda memiliki
beberapa bahan utama bahwa pengirim memiliki

827
00:40:17,060 --> 00:40:18,030
demikian juga.

828
00:40:18,030 --> 00:40:22,120
Jadi untuk memotivasi ini kami akan mengarahkan
a melihat hal ini di sini,

829
00:40:22,120 --> 00:40:26,750
yang merupakan contoh dari
cincin decoder rahasia yang

830
00:40:26,750 --> 00:40:34,042
dapat digunakan untuk mengetahui
apa pesan rahasia sebenarnya.

831
00:40:34,042 --> 00:40:35,750
Bahkan, kembali di
hari di sekolah dasar,

832
00:40:35,750 --> 00:40:38,787
jika Anda pernah mengirim pesan rahasia kepada
beberapa teman atau beberapa naksir di kelas,

833
00:40:38,787 --> 00:40:40,620
Anda mungkin berpikir
Anda sedang pintar

834
00:40:40,620 --> 00:40:46,530
oleh pada bagian Anda berubah kertas,
seperti, A ke B, dan B ke C, dan C ke D,

835
00:40:46,530 --> 00:40:47,590
dan seterusnya.

836
00:40:47,590 --> 00:40:50,300
Tapi Anda benar-benar enkripsi
informasi Anda, bahkan

837
00:40:50,300 --> 00:40:53,300
jika itu sepele sedikit, tidak
yang sulit bagi guru untuk menyadari,

838
00:40:53,300 --> 00:40:55,675
baik, jika Anda hanya mengubah
B ke A dan C ke B,

839
00:40:55,675 --> 00:40:57,550
Anda benar-benar mencari tahu
apa pesan itu,

840
00:40:57,550 --> 00:40:59,700
tetapi Anda berada di Pengkodean informasi.

841
00:40:59,700 --> 00:41:03,420
>> Anda hanya melakukannya
sederhana, seperti Ralphie sini

842
00:41:03,420 --> 00:41:07,934
dalam film terkenal yang memainkan
cukup banyak nauseum iklan setiap musim dingin.

843
00:41:07,934 --> 00:41:08,600
[VIDEO PEMUTARAN]

844
00:41:08,600 --> 00:41:11,180
-Jadilah Itu diketahui semua bahwa
Ralph Parker dengan ini

845
00:41:11,180 --> 00:41:14,070
ditunjuk anggota dari Little
Orphan Annie Rahasia Lingkaran

846
00:41:14,070 --> 00:41:17,700
dan berhak atas semua penghargaan
dan manfaat yang terjadi padanya.

847
00:41:17,700 --> 00:41:24,340
>> -Signed Little Orphan Annie,
kontra-ditandatangani Pierre Andre, tinta.

848
00:41:24,340 --> 00:41:27,160
Kehormatan dan manfaat,
sudah pada usia sembilan.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [BERTERIAK]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Ayolah.

853
00:41:34,250 --> 00:41:35,210
Mari kita langsung saja.

854
00:41:35,210 --> 00:41:39,530
Saya tidak perlu semua jazz yang
tentang penyelundup dan bajak laut.

855
00:41:39,530 --> 00:41:41,660
>> -Dengarkan Besok malam untuk
petualangan penutup

856
00:41:41,660 --> 00:41:43,880
dari kapal bajak laut hitam.

857
00:41:43,880 --> 00:41:46,650
Sekarang, saatnya untuk
pesan rahasia Annie

858
00:41:46,650 --> 00:41:49,840
untuk anggota Anda dari Rahasia Lingkaran.

859
00:41:49,840 --> 00:41:53,570
Ingat, anak-anak, hanya anggota
Annie Rahasia Lingkaran

860
00:41:53,570 --> 00:41:56,140
dapat memecahkan kode pesan rahasia Annie.

861
00:41:56,140 --> 00:42:00,340
>> Ingat, Annie tergantung pada Anda.

862
00:42:00,340 --> 00:42:02,880
Mengatur pin untuk B2.

863
00:42:02,880 --> 00:42:05,230
Berikut adalah pesan.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Aku Di, pertemuan rahasia pertama saya.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Itu malam ini suara besar.

868
00:42:15,780 --> 00:42:19,000
Aku tahu bahwa malam ini
Pesan itu benar-benar penting.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, itu pesan
dari Annie dirinya.

870
00:42:22,694 --> 00:42:23,860
Ingat, jangan bilang siapa-siapa.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Detik kemudian, aku di satu-satunya
kamar di rumah di mana anak laki-laki dari sembilan

873
00:42:32,930 --> 00:42:37,040
bisa duduk di privasi dan decode.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Aku pergi ke depan, E.

876
00:42:42,360 --> 00:42:44,520
>> Kata pertama adalah menjadi.

877
00:42:44,520 --> 00:42:49,032
S, itu datang lebih mudah sekarang, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Oh, ayolah, Ralphie, aku harus pergi!

879
00:42:51,733 --> 00:42:53,688
>> -aku Akan segera turun, Ma!

880
00:42:53,688 --> 00:42:54,188
Wah!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, pastikan to-- pastikan untuk apa?

883
00:43:04,060 --> 00:43:05,970
Apa Sedikit Orphan
Annie mencoba untuk mengatakan?

884
00:43:05,970 --> 00:43:07,264
Pastikan untuk apa?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy telah sampai ke
pergi, tolong keluar?

886
00:43:09,634 --> 00:43:10,480
>> benar -Semua, Ma!

887
00:43:10,480 --> 00:43:12,880
Aku akan keluar benar!

888
00:43:12,880 --> 00:43:14,550
>> -Saya Semakin dekat sekarang.

889
00:43:14,550 --> 00:43:16,620
Ketegangan itu mengerikan.

890
00:43:16,620 --> 00:43:17,720
Apa itu?

891
00:43:17,720 --> 00:43:20,170
Nasib planet ini
mungkin menggantung di keseimbangan.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Harus Andy pergi!

894
00:43:23,170 --> 00:43:26,890
>> -aku Akan keluar, menangis dengan suara keras!

895
00:43:26,890 --> 00:43:32,680
>> -Hampir Ada, jari-jari saya terbang, pikiran saya
adalah perangkap baja, setiap pori bergetar.

896
00:43:32,680 --> 00:43:37,198
Itu hampir jelas, ya, ya, ya.

897
00:43:37,198 --> 00:43:43,091
>> -Pastikan Untuk minum ovaltine Anda.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Sebuah iklan payah?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Dasar bajingan.

903
00:43:54,227 --> 00:43:54,810
[END PEMUTARAN]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Malan: OK, jadi
itu adalah cara yang sangat panjang

905
00:43:57,390 --> 00:44:00,660
memperkenalkan kriptografi,
dan juga Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Bahkan, dari iklan lama ini
di sini, mengapa ovaltine begitu baik?

907
00:44:04,470 --> 00:44:09,470
Ini adalah ekstraksi terkonsentrasi matang
barley malt, susu murni krim sapi,

908
00:44:09,470 --> 00:44:14,360
dan khusus disiapkan kakao, bersama-sama
dengan fosfatida alami dan vitamin.

909
00:44:14,360 --> 00:44:18,240
Hal ini lebih lanjut diperkaya dengan
vitamin tambahan B dan D, yum.

910
00:44:18,240 --> 00:44:21,600
Dan Anda masih bisa mendapatkannya, tampaknya,
di Amazon, seperti yang kita lakukan di sini.

911
00:44:21,600 --> 00:44:24,810
>> Tapi motivasi di sini adalah untuk
memperkenalkan kriptografi, khususnya

912
00:44:24,810 --> 00:44:28,340
jenis kriptografi dikenal
sebagai kriptografi kunci rahasia.

913
00:44:28,340 --> 00:44:34,284
Dan seperti namanya, keseluruhan
keamanan sistem kripto kunci rahasia,

914
00:44:34,284 --> 00:44:36,200
jika Anda mau, metodologi
hanya berebut

915
00:44:36,200 --> 00:44:40,960
informasi antara dua orang, adalah bahwa
hanya pengirim dan hanya penerima

916
00:44:40,960 --> 00:44:46,980
tahu KEY- rahasia beberapa nilai, beberapa
frase rahasia, beberapa nomor rahasia, yang

917
00:44:46,980 --> 00:44:50,660
memungkinkan mereka untuk kedua mengenkripsi
dan mendekripsi informasi.

918
00:44:50,660 --> 00:44:53,470
Dan kriptografi, benar-benar,
hanya ini dari minggu 0.

919
00:44:53,470 --> 00:44:56,715
>> Ini masalah di mana ada masukan,
seperti pesan yang sebenarnya dalam bahasa Inggris

920
00:44:56,715 --> 00:44:59,340
atau apa pun bahasa yang Anda
ingin mengirim kepada seseorang di kelas,

921
00:44:59,340 --> 00:45:00,580
atau di internet.

922
00:45:00,580 --> 00:45:03,840
Ada beberapa output, yang akan
menjadi pesan orak-arik yang Anda

923
00:45:03,840 --> 00:45:05,250
ingin penerima untuk menerima.

924
00:45:05,250 --> 00:45:07,405
Dan bahkan jika seseorang dalam
tengah menerima itu juga,

925
00:45:07,405 --> 00:45:09,780
Anda tidak ingin mereka
tentu dapat mendekripsi itu,

926
00:45:09,780 --> 00:45:12,840
karena dalam hal ini
kotak hitam, atau algoritma,

927
00:45:12,840 --> 00:45:17,650
beberapa mekanisme, beberapa langkah demi langkah
instruksi, untuk mengambil input yang

928
00:45:17,650 --> 00:45:20,710
dan mengubahnya ke dalam
output, di mudah-mudahan cara yang aman.

929
00:45:20,710 --> 00:45:23,640
>> Dan, pada kenyataannya, ada beberapa
kosakata di dunia ini sebagai berikut.

930
00:45:23,640 --> 00:45:26,100
Plain text adalah kata
ilmuwan komputer akan

931
00:45:26,100 --> 00:45:28,449
gunakan untuk menggambarkan input
pesan, seperti Inggris

932
00:45:28,449 --> 00:45:31,240
atau apa pun bahasa yang Anda benar-benar
ingin mengirim ke beberapa manusia lainnya.

933
00:45:31,240 --> 00:45:35,450
Dan kemudian ciphertext adalah berebut
untuk dienkripsi, atau dienkripsi,

934
00:45:35,450 --> 00:45:36,520
versi darinya.

935
00:45:36,520 --> 00:45:38,750
>> Tapi ada satu bahan lain di sini.

936
00:45:38,750 --> 00:45:43,200
Ada satu masukan lain untuk
rahasia kriptografi kunci.

937
00:45:43,200 --> 00:45:45,200
Dan itu adalah kunci sendiri,
yang, umumnya,

938
00:45:45,200 --> 00:45:48,930
seperti yang akan kita lihat, angka, atau
surat, atau kata, apa pun

939
00:45:48,930 --> 00:45:51,980
algoritma itu sebenarnya mengharapkan.

940
00:45:51,980 --> 00:45:53,870
>> Dan bagaimana Anda mendekripsi informasi?

941
00:45:53,870 --> 00:45:55,110
Bagaimana Anda menguraikan itu?

942
00:45:55,110 --> 00:45:57,950
Nah, Anda hanya membalik
output dan input.

943
00:45:57,950 --> 00:46:00,900
>> Dengan kata lain, setelah seseorang
menerima pesan terenkripsi,

944
00:46:00,900 --> 00:46:03,740
ia hanya memiliki
tahu bahwa kunci yang sama.

945
00:46:03,740 --> 00:46:05,700
Mereka telah menerima ciphertext.

946
00:46:05,700 --> 00:46:09,530
Dan dengan menancapkan dua
input ke dalam sistem kripto,

947
00:46:09,530 --> 00:46:14,260
algoritma, kotak hitam ini, keluar
harus datang plaintext asli.

948
00:46:14,260 --> 00:46:17,830
Dan itulah tingkat yang sangat tinggi
Mengingat apa kriptografi sebenarnya

949
00:46:17,830 --> 00:46:18,590
semua tentang.

950
00:46:18,590 --> 00:46:20,030
>> Jadi mari kita ke sana.

951
00:46:20,030 --> 00:46:22,700
Sekarang mari kita lihat di bawah
kap sesuatu

952
00:46:22,700 --> 00:46:26,000
kami telah mengambil untuk diberikan untuk
seminggu terakhir, dan untuk sesi ini

953
00:46:26,000 --> 00:46:27,629
sini-string.

954
00:46:27,629 --> 00:46:30,295
Sebuah string pada akhir hari
hanya urutan karakter.

955
00:46:30,295 --> 00:46:33,610
>> Mungkin halo dunia, atau
halo Zamyla, atau apa pun.

956
00:46:33,610 --> 00:46:37,050
Tapi apa artinya bagi
menjadi urutan karakter?

957
00:46:37,050 --> 00:46:41,520
Bahkan, perpustakaan CS50 memberikan
kami tipe data disebut string.

958
00:46:41,520 --> 00:46:45,140
>> Tapi sebenarnya tidak ada
hal seperti string di C.

959
00:46:45,140 --> 00:46:49,450
Ini benar-benar hanya urutan
karakter, karakter, karakter,

960
00:46:49,450 --> 00:46:52,180
karakter, kembali, ke belakang, ke
kembali, ke belakang, ke belakang dalam

961
00:46:52,180 --> 00:46:54,650
memori komputer Anda, atau RAM.

962
00:46:54,650 --> 00:46:58,940
Dan kita akan melihat lebih dalam bahwa dalam
masa depan ketika kita melihat memori itu sendiri,

963
00:46:58,940 --> 00:47:02,030
dan pemanfaatan, dan
ancaman yang terlibat.

964
00:47:02,030 --> 00:47:04,100
>> Tapi mari kita pertimbangkan string Zamyla.

965
00:47:04,100 --> 00:47:07,480
Jadi hanya nama
manusia di sini, Zamyla,

966
00:47:07,480 --> 00:47:12,030
yang merupakan urutan
karakter, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Dan sekarang mari kita mengira bahwa nama Zamyla ini
sedang disimpan di dalam komputer

968
00:47:16,020 --> 00:47:16,880
program.

969
00:47:16,880 --> 00:47:20,830
>> Nah, maka bisa dipastikan bahwa kita harus
dapat melihat karakter-karakter

970
00:47:20,830 --> 00:47:21,590
individual.

971
00:47:21,590 --> 00:47:24,710
Jadi aku hanya akan menggambar sedikit
kotak sekitar nama Zamyla di sini.

972
00:47:24,710 --> 00:47:31,580
Dan itu adalah kasus di C bahwa ketika Anda
memiliki string, seperti Zamyla-- dan mungkin

973
00:47:31,580 --> 00:47:34,940
bahwa string telah kembali dari
fungsi seperti get string,

974
00:47:34,940 --> 00:47:38,540
Anda benar-benar dapat memanipulasi
itu karakter demi karakter.

975
00:47:38,540 --> 00:47:42,070
>> Sekarang, ini erat untuk
percakapan di tangan, karena

976
00:47:42,070 --> 00:47:46,420
dalam kriptografi jika Anda ingin mengubah
A ke B, dan B ke C, dan C ke D,

977
00:47:46,420 --> 00:47:49,650
dan sebagainya, Anda harus mampu
untuk melihat karakter individu

978
00:47:49,650 --> 00:47:50,190
dalam sebuah string.

979
00:47:50,190 --> 00:47:52,695
Anda harus mampu mengubah
Z untuk sesuatu yang lain, A

980
00:47:52,695 --> 00:47:55,280
untuk sesuatu yang lain, M untuk
sesuatu yang lain, dan sebagainya.

981
00:47:55,280 --> 00:47:58,000
Dan jadi kita perlu cara,
pemrograman, sehingga

982
00:47:58,000 --> 00:48:03,020
untuk berbicara, di C untuk dapat mengubah
dan melihat surat individu.

983
00:48:03,020 --> 00:48:05,690
Dan kita bisa melakukan ini sebagai berikut.

984
00:48:05,690 --> 00:48:08,340
>> Biarkan aku pergi kepala kembali CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Dan biarkan aku pergi ke depan
dan membuat file baru

986
00:48:11,130 --> 00:48:16,134
bahwa saya akan menelepon saat ini string0,
sebagai contoh seperti pertama kami, dot c.

987
00:48:16,134 --> 00:48:18,300
Dan aku akan pergi ke depan
dan cambuk itu sebagai berikut.

988
00:48:18,300 --> 00:48:22,870
>> Jadi termasuk CS50.h, dan
kemudian termasuk io.h standar,

989
00:48:22,870 --> 00:48:25,990
yang aku hampir selalu akan
akan menggunakan dalam program saya, setidaknya

990
00:48:25,990 --> 00:48:26,780
mulanya.

991
00:48:26,780 --> 00:48:32,180
int void main, dan kemudian di sini aku
akan melakukan string mendapat mendapatkan tali.

992
00:48:32,180 --> 00:48:35,260
Dan kemudian aku akan
pergi ke depan dan melakukan hal ini.

993
00:48:35,260 --> 00:48:37,460
Saya ingin pergi ke depan
dan, sebagai cek kewarasan,

994
00:48:37,460 --> 00:48:43,607
hanya mengatakan, halo, persen s,
semi-kolon, membuat tali 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, apa yang saya lakukan di sini?

996
00:48:44,690 --> 00:48:45,930
Oh, saya tidak pasang.

997
00:48:45,930 --> 00:48:48,120
Jadi pelajaran, bahwa
tidak disengaja.

998
00:48:48,120 --> 00:48:52,480
>> Jadi kesalahan, lebih persen
konversi dari argumen data.

999
00:48:52,480 --> 00:48:54,940
Dan ini adalah di mana, di
baris 7-- OK, jadi saya memiliki,

1000
00:48:54,940 --> 00:48:56,690
kutipan tanda kutip, itu
string yang saya printf.

1001
00:48:56,690 --> 00:48:58,151
Aku punya tanda persen.

1002
00:48:58,151 --> 00:48:59,650
Tapi aku hilang argumen kedua.

1003
00:48:59,650 --> 00:49:03,190
>> Aku kehilangan s koma, yang
Aku harus di contoh sebelumnya.

1004
00:49:03,190 --> 00:49:06,650
Jadi kesempatan yang baik untuk memperbaiki
satu lagi kesalahan, sengaja.

1005
00:49:06,650 --> 00:49:09,950
Dan sekarang biarkan aku menjalankan
string0, ketik Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, halo Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Jadi kami telah menjalankan program semacam ini
beberapa kali berbeda sekarang.

1008
00:49:14,144 --> 00:49:16,310
Tapi mari kita lakukan sesuatu yang
sedikit berbeda kali ini.

1009
00:49:16,310 --> 00:49:19,450
Alih-alih hanya mencetak Zamyla ini
Seluruh nama dengan printf,

1010
00:49:19,450 --> 00:49:21,350
mari kita lakukan karakter demi karakter.

1011
00:49:21,350 --> 00:49:22,700
>> Aku akan menggunakan untuk loop.

1012
00:49:22,700 --> 00:49:26,160
Dan aku akan memberi diriku
variabel penghitungan, yang disebut i.

1013
00:49:26,160 --> 00:49:33,530
Dan aku akan terus iterasi, sehingga
selama i kurang dari panjang s.

1014
00:49:33,530 --> 00:49:35,930
>> Ternyata, kita tidak
melakukan ini terakhir kali,

1015
00:49:35,930 --> 00:49:39,100
yang c dilengkapi dengan
fungsi yang disebut Stirling.

1016
00:49:39,100 --> 00:49:42,690
Kembali pada hari, dan pada umumnya
masih ketika mengimplementasikan fungsi,

1017
00:49:42,690 --> 00:49:45,405
manusia akan sering memilih sangat
nama singkat semacam suara

1018
00:49:45,405 --> 00:49:48,280
seperti apa yang Anda inginkan, meskipun itu
hilang beberapa vokal atau huruf.

1019
00:49:48,280 --> 00:49:50,660
Jadi Stirling adalah
nama fungsi yang

1020
00:49:50,660 --> 00:49:53,880
membawa argumen antara
kurung yang harus string.

1021
00:49:53,880 --> 00:49:56,910
Dan itu hanya mengembalikan integer,
panjang string itu.

1022
00:49:56,910 --> 00:50:00,580
>> Jadi ini untuk loop on line 7 akan
untuk mulai menghitung di i sama 0.

1023
00:50:00,580 --> 00:50:02,530
Ini akan kenaikan
i pada setiap iterasi

1024
00:50:02,530 --> 00:50:04,350
oleh 1, seperti yang telah kami lakukan beberapa kali.

1025
00:50:04,350 --> 00:50:06,780
Tapi itu akan hanya melakukan
up ini sampai titik

1026
00:50:06,780 --> 00:50:09,660
ketika saya adalah panjang
dari string itu sendiri.

1027
00:50:09,660 --> 00:50:14,520
>> Jadi ini adalah cara, akhirnya,
iterasi atas karakter

1028
00:50:14,520 --> 00:50:17,430
dalam string sebagaimana adanya berikut.

1029
00:50:17,430 --> 00:50:20,670
Aku akan mencetak tidak
seluruh string, tapi persen c,

1030
00:50:20,670 --> 00:50:22,860
karakter tunggal
diikuti oleh baris baru.

1031
00:50:22,860 --> 00:50:24,880
Dan kemudian aku akan
pergi ke depan, dan saya perlu

1032
00:50:24,880 --> 00:50:29,080
mengatakan saya ingin mencetak
Karakter engan s.

1033
00:50:29,080 --> 00:50:33,450
>> Jadi jika saya adalah variabel yang menunjukkan
indeks dari string, di mana

1034
00:50:33,450 --> 00:50:37,230
Anda di dalamnya, saya harus bisa
mengatakan, memberikan karakter i dari s.

1035
00:50:37,230 --> 00:50:40,390
Dan c memiliki cara untuk melakukan
ini dengan tanda kurung persegi.

1036
00:50:40,390 --> 00:50:43,679
Anda hanya mengatakan nama
string, yang dalam hal ini adalah s.

1037
00:50:43,679 --> 00:50:46,970
Maka Anda menggunakan tanda kurung persegi, yang
biasanya hanya atas Kembali atau Masukkan

1038
00:50:46,970 --> 00:50:48,110
tombol pada keyboard.

1039
00:50:48,110 --> 00:50:52,410
Dan kemudian Anda menempatkan indeks dari
karakter yang akan dicetak.

1040
00:50:52,410 --> 00:50:55,960
Jadi indeks akan menjadi
number-- 0, atau 1, atau 2, atau 3, atau titik,

1041
00:50:55,960 --> 00:50:57,590
dot, dot, beberapa nomor lainnya.

1042
00:50:57,590 --> 00:51:00,920
>> Dan kami memastikan bahwa itu akan
menjadi nomor yang benar, karena saya

1043
00:51:00,920 --> 00:51:02,360
mulai menghitung pada 0.

1044
00:51:02,360 --> 00:51:07,020
Dan secara default, karakter pertama
dalam sebuah string adalah dengan konvensi 0.

1045
00:51:07,020 --> 00:51:09,230
Dan karakter kedua adalah bracket 1.

1046
00:51:09,230 --> 00:51:11,120
Dan karakter ketiga adalah braket 2.

1047
00:51:11,120 --> 00:51:13,630
Dan Anda tidak ingin pergi terlalu
jauh, tapi kami tidak akan karena kita

1048
00:51:13,630 --> 00:51:17,780
akan hanya kenaikan i sampai
sama dengan panjang string.

1049
00:51:17,780 --> 00:51:20,210
Dan di mana titik,
ini untuk loop akan berhenti.

1050
00:51:20,210 --> 00:51:25,550
>> Jadi biarkan aku pergi ke depan dan menyimpan ini
Program, dan menjalankan membuat tali 0.

1051
00:51:25,550 --> 00:51:28,400
Tapi aku kacau.

1052
00:51:28,400 --> 00:51:35,390
Secara implisit menyatakan fungsi perpustakaan
Stirling dengan tipe tersebut dan such-- sekarang,

1053
00:51:35,390 --> 00:51:36,430
ini terdengar akrab.

1054
00:51:36,430 --> 00:51:37,440
Tapi itu tidak printf.

1055
00:51:37,440 --> 00:51:38,540
Dan itu tidak mendapatkan tali.

1056
00:51:38,540 --> 00:51:40,480
>> Saya tidak mengacaukan di
dengan cara yang sama saat ini.

1057
00:51:40,480 --> 00:51:45,100
Tapi perhatikan di sini sedikit turun
lebih lanjut, termasuk string.h header,

1058
00:51:45,100 --> 00:51:47,210
eksplisit memberikan
deklarasi untuk Stirling.

1059
00:51:47,210 --> 00:51:48,820
Jadi sebenarnya ada petunjuk di sana.

1060
00:51:48,820 --> 00:51:51,670
>> Dan memang ternyata
ada file header lain

1061
00:51:51,670 --> 00:51:53,970
bahwa kita sudah tidak digunakan
di kelas, tapi itu

1062
00:51:53,970 --> 00:51:56,480
di antara mereka yang tersedia
Anda, yang disebut string.h.

1063
00:51:56,480 --> 00:52:00,930
Dan dalam file, string.h
adalah Stirling dinyatakan.

1064
00:52:00,930 --> 00:52:05,220
Jadi biarkan aku pergi ke depan dan
simpan ini, membuat tali

1065
00:52:05,220 --> 00:52:08,040
0-- bagus, tidak ada pesan error saat ini.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, dan
Aku akan tekan Enter,

1067
00:52:12,290 --> 00:52:16,710
di mana titik GetString akan
untuk kembali string, memasukkannya ke dalam s.

1068
00:52:16,710 --> 00:52:21,890
Kemudian yang untuk loop akan iterate
lebih dari karakter S satu per satu,

1069
00:52:21,890 --> 00:52:28,420
dan mencetaknya satu per baris, karena
Aku punya yang backslash n di akhir.

1070
00:52:28,420 --> 00:52:34,530
Jadi saya bisa menghilangkan garis miring terbalik yang
n, dan kemudian hanya mencetak Zamyla semua

1071
00:52:34,530 --> 00:52:37,460
di baris yang sama,
efektif reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, yang tidak semua yang berguna.

1073
00:52:38,999 --> 00:52:40,540
Tapi dalam kasus ini, saya sudah tidak melakukan itu.

1074
00:52:40,540 --> 00:52:43,610
Aku sebenarnya sudah dicetak satu
karakter pada satu waktu, satu per baris,

1075
00:52:43,610 --> 00:52:45,400
sehingga kita benar-benar melihat efeknya.

1076
00:52:45,400 --> 00:52:46,900
>> Tapi aku harus mencatat satu hal di sini.

1077
00:52:46,900 --> 00:52:48,930
Dan kami akan kembali ke
ini dalam seminggu ke depan.

1078
00:52:48,930 --> 00:52:52,650
Ternyata ini
Kode berpotensi kereta.

1079
00:52:52,650 --> 00:52:56,560
>> Ternyata get tali
dan beberapa fungsi lainnya dalam hidup

1080
00:52:56,560 --> 00:53:00,280
belum tentu selalu
kembali apa yang Anda harapkan.

1081
00:53:00,280 --> 00:53:03,010
Kita tahu dari kelas terakhir
waktu ini yang mendapatkan

1082
00:53:03,010 --> 00:53:04,960
string seharusnya mengembalikan string.

1083
00:53:04,960 --> 00:53:09,900
Tapi bagaimana jika jenis pengguna keluar seperti
kata yang panjang, atau paragraf, atau esai

1084
00:53:09,900 --> 00:53:13,010
yang ada hanya tidak cukup
memori di komputer untuk menyesuaikan.

1085
00:53:13,010 --> 00:53:15,410
>> Seperti, bagaimana jika sesuatu berjalan
salah di bawah kap mesin?

1086
00:53:15,410 --> 00:53:18,400
Ini mungkin tidak sering terjadi,
tapi itu bisa terjadi sekali

1087
00:53:18,400 --> 00:53:21,520
sementara, sangat jarang.

1088
00:53:21,520 --> 00:53:25,460
Dan ternyata mendapatkan tali
dan fungsi seperti itu belum tentu

1089
00:53:25,460 --> 00:53:26,380
selalu kembali string.

1090
00:53:26,380 --> 00:53:30,680
Mereka mungkin kembali beberapa nilai error,
beberapa nilai sentinel sehingga untuk berbicara,

1091
00:53:30,680 --> 00:53:32,612
yang menunjukkan bahwa
sesuatu yang tidak beres.

1092
00:53:32,612 --> 00:53:35,320
Dan Anda hanya akan tahu ini dari
setelah belajar di kelas sekarang,

1093
00:53:35,320 --> 00:53:37,700
atau setelah membaca beberapa dokumentasi yang lebih.

1094
00:53:37,700 --> 00:53:43,120
Ternyata get tali
dapat mengembalikan nilai disebut null.

1095
00:53:43,120 --> 00:53:46,220
Null adalah nilai khusus yang kita akan
kembali ke dalam seminggu ke depan.

1096
00:53:46,220 --> 00:53:50,420
Tapi untuk saat ini, hanya tahu bahwa jika saya ingin
harus benar-benar tepat dalam bergerak maju

1097
00:53:50,420 --> 00:53:52,650
menggunakan get string, saya
seharusnya tidak hanya menyebutnya,

1098
00:53:52,650 --> 00:53:56,870
dan membabi buta menggunakan nilai kembali,
percaya bahwa itu string.

1099
00:53:56,870 --> 00:53:59,420
>> awalnya saya harus mengatakan,
hey, tunggu sebentar, hanya

1100
00:53:59,420 --> 00:54:03,380
melanjutkan jika s tidak sama
null, di mana nol, lagi,

1101
00:54:03,380 --> 00:54:04,660
hanya beberapa nilai khusus.

1102
00:54:04,660 --> 00:54:07,770
Dan itu satu-satunya nilai khusus Anda
perlu khawatir tentang untuk mendapatkan tali.

1103
00:54:07,770 --> 00:54:10,900
Dapatkan string baik akan
untuk kembali string atau null.

1104
00:54:10,900 --> 00:54:17,219
>> Dan tanda seru ini tanda sama dengan
Anda mungkin tahu dari mungkin kelas matematika

1105
00:54:17,219 --> 00:54:20,510
Anda mungkin menarik tanda sama dengan
garis melalui itu untuk menunjukkan tidak sama.

1106
00:54:20,510 --> 00:54:23,135
Itu bukan umumnya karakter
Anda dapat mengetik pada keyboard Anda.

1107
00:54:23,135 --> 00:54:26,480
Dan dalam kebanyakan bahasa pemrograman,
ketika Anda ingin mengatakan tidak sama,

1108
00:54:26,480 --> 00:54:29,160
Anda menggunakan tanda seru,
atau dikenal sebagai Bang.

1109
00:54:29,160 --> 00:54:33,180
Jadi Anda mengatakan ledakan sama, yang
berarti tidak sama, secara logis.

1110
00:54:33,180 --> 00:54:38,060
Ini seperti tidak ada yang lebih besar
dari, atau sama dengan, atau kurang dari

1111
00:54:38,060 --> 00:54:41,270
atau sama dengan kunci pada keyboard Anda
yang melakukan itu semua dalam satu simbol.

1112
00:54:41,270 --> 00:54:44,020
Jadi itu sebabnya, di contoh terakhir,
Anda melakukan braket terbuka, dan kemudian

1113
00:54:44,020 --> 00:54:48,670
tanda sama, dalam rangka untuk melakukan
lebih besar dari atau, mengatakan, kurang dari.

1114
00:54:48,670 --> 00:54:49,910
>> Jadi apa takeaway di sini?

1115
00:54:49,910 --> 00:54:53,880
Ini hanyalah sebuah cara sekarang dari
memperkenalkan sintaks ini, fitur ini,

1116
00:54:53,880 --> 00:54:57,390
iterasi atas individu
karakter dalam string.

1117
00:54:57,390 --> 00:55:00,260
Dan seperti persegi yang
kurung memungkinkan Anda untuk mendapatkan mereka,

1118
00:55:00,260 --> 00:55:03,790
pertimbangkan mereka kurung persegi
jenis mengisyaratkan ini mendasari

1119
00:55:03,790 --> 00:55:06,040
desain, dimana setiap
karakter dalam string

1120
00:55:06,040 --> 00:55:10,180
adalah jenis kotak di suatu tempat di bawah
kap dalam memori komputer Anda.

1121
00:55:10,180 --> 00:55:12,340
>> Tapi mari kita membuat varian ini.

1122
00:55:12,340 --> 00:55:14,880
Ternyata ini
program ini benar.

1123
00:55:14,880 --> 00:55:18,810
Jadi per sumbu CS50 untuk mengevaluasi
kode, ini benar sekarang.

1124
00:55:18,810 --> 00:55:22,959
Apalagi sekarang bahwa aku memeriksa
null, program ini seharusnya tidak pernah kecelakaan.

1125
00:55:22,959 --> 00:55:24,500
Dan aku hanya tahu bahwa dari pengalaman.

1126
00:55:24,500 --> 00:55:28,040
Tapi ada hal lain yang
kita bisa benar-benar salah di sini.

1127
00:55:28,040 --> 00:55:31,860
Tapi itu tidak sangat dirancang dengan baik,
karena mari kita kembali ke dasar.

1128
00:55:31,860 --> 00:55:34,450
>> Pertama, principles--
apa untuk loop lakukan?

1129
00:55:34,450 --> 00:55:36,290
A untuk loop melakukan tiga hal.

1130
00:55:36,290 --> 00:55:39,340
Menginisialisasi beberapa
nilai, jika Anda meminta untuk.

1131
00:55:39,340 --> 00:55:41,770
Ia memeriksa kondisi.

1132
00:55:41,770 --> 00:55:45,380
Dan kemudian setelah setiap
iterasi, setelah setiap siklus,

1133
00:55:45,380 --> 00:55:49,330
itu akan menambahkan beberapa
nilai, atau nilai-nilai, di sini.

1134
00:55:49,330 --> 00:55:50,600
>> Jadi apa artinya?

1135
00:55:50,600 --> 00:55:52,940
Kami menginisialisasi i dengan 0.

1136
00:55:52,940 --> 00:55:58,610
Kami memeriksa dan memastikan saya adalah kurang dari
panjang s, yang merupakan Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
jadi yang kurang dari 6.

1138
00:55:59,900 --> 00:56:02,590
Dan, memang, 0 sebagai kurang dari 6.

1139
00:56:02,590 --> 00:56:05,580
>> Kami mencetak Z dari nama Zamyla ini.

1140
00:56:05,580 --> 00:56:08,080
Kemudian kami kenaikan i dari 0 ke 1.

1141
00:56:08,080 --> 00:56:11,290
Kami kemudian memeriksa, adalah 1 kurang
dari panjang s?

1142
00:56:11,290 --> 00:56:13,270
Panjang s adalah 6.

1143
00:56:13,270 --> 00:56:13,950
Ya itu.

1144
00:56:13,950 --> 00:56:16,880
>> Jadi kami mencetak nama Zamyla ini, ZA.

1145
00:56:16,880 --> 00:56:20,090
Kami kenaikan i dari 0, 1, ke 2.

1146
00:56:20,090 --> 00:56:23,720
Kami kemudian memeriksa, adalah 2 kurang dari
panjang nama Zamyla ini.

1147
00:56:23,720 --> 00:56:25,380
6- jadi 2 kurang dari 6.

1148
00:56:25,380 --> 00:56:30,460
Ya, mari kita mencetak sekarang M di
Nama Zamyla ini, karakter ketiga.

1149
00:56:30,460 --> 00:56:34,110
>> Kuncinya di sini adalah bahwa pada setiap
iterasi dari cerita, saya memeriksa,

1150
00:56:34,110 --> 00:56:37,810
adalah saya kurang dari panjang Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Tapi menangkap adalah bahwa
Stirling tidak properti.

1152
00:56:40,350 --> 00:56:43,100
Bagi Anda yang telah diprogram
sebelum di Jawa atau bahasa lainnya

1153
00:56:43,100 --> 00:56:46,310
mungkin tahu panjang dari string adalah
properti, hanya beberapa hanya membaca nilai.

1154
00:56:46,310 --> 00:56:50,220
>> Dalam C dalam kasus ini, jika ini adalah
fungsi yang secara harfiah

1155
00:56:50,220 --> 00:56:53,520
menghitung jumlah
karakter dalam Zamyla setiap kali

1156
00:56:53,520 --> 00:56:54,740
kita memanggil fungsi itu.

1157
00:56:54,740 --> 00:56:58,500
Setiap kali Anda meminta komputer untuk menggunakan
Stirling, itu mengambil melihat Zamyla,

1158
00:56:58,500 --> 00:57:01,960
dan mengatakan Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Dan mengembalikan 6.

1160
00:57:02,962 --> 00:57:04,920
Pada saat Anda menelepon
di dalam bahwa untuk loop,

1161
00:57:04,920 --> 00:57:08,610
itu akan melihat Zamyla
lagi, mengatakan Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Dan itu akan kembali 6.

1163
00:57:10,320 --> 00:57:12,980
Jadi apa yang bodoh tentang desain ini?

1164
00:57:12,980 --> 00:57:17,700
>> Mengapa kode saya tidak 5 dari 5
untuk desain sekarang, sehingga untuk berbicara?

1165
00:57:17,700 --> 00:57:20,600
Yah, aku mengajukan
Pertanyaan yang tidak perlu.

1166
00:57:20,600 --> 00:57:23,030
Saya melakukan pekerjaan lebih dari yang saya butuhkan untuk.

1167
00:57:23,030 --> 00:57:25,370
>> Jadi meskipun
Jawabannya adalah benar, saya

1168
00:57:25,370 --> 00:57:29,560
meminta komputer, apa yang
panjang Zamyla lagi,

1169
00:57:29,560 --> 00:57:31,380
dan lagi, dan lagi, dan lagi?

1170
00:57:31,380 --> 00:57:33,980
Dan jawaban itu
tidak akan pernah berubah.

1171
00:57:33,980 --> 00:57:35,900
Itu selalu akan menjadi 6.

1172
00:57:35,900 --> 00:57:39,730
>> Jadi solusi yang lebih baik dari ini
akan versi berikutnya ini.

1173
00:57:39,730 --> 00:57:43,390
Biarkan aku pergi ke depan dan memasukkannya ke dalam
file terpisah disebut string1.c,

1174
00:57:43,390 --> 00:57:44,990
hanya untuk tetap memisahkan.

1175
00:57:44,990 --> 00:57:47,260
Dan ternyata dalam untuk
lingkaran, Anda dapat benar-benar

1176
00:57:47,260 --> 00:57:50,210
mendeklarasikan beberapa variabel sekaligus.

1177
00:57:50,210 --> 00:57:53,460
>> Jadi aku akan terus saya dan set ke 0.

1178
00:57:53,460 --> 00:57:56,190
Tapi aku juga akan
menambahkan koma, dan berkata,

1179
00:57:56,190 --> 00:58:01,050
memberi saya sebuah variabel yang disebut n, yang
nilai sama dengan panjang string s.

1180
00:58:01,050 --> 00:58:09,410
Dan sekarang, silakan membuat kondisi saya
selama i kurang dari n.

1181
00:58:09,410 --> 00:58:14,140
>> Jadi dengan cara ini, logika adalah
identik pada akhir hari.

1182
00:58:14,140 --> 00:58:18,280
Tapi aku mengingat
nilai 6, dalam hal ini.

1183
00:58:18,280 --> 00:58:19,780
Berapa panjang dari nama Zamyla ini?

1184
00:58:19,780 --> 00:58:20,860
Dan aku meletakkan di n.

1185
00:58:20,860 --> 00:58:23,050
>> Dan aku masih memeriksa
kondisi setiap kali.

1186
00:58:23,050 --> 00:58:24,300
Adalah 0 kurang dari 6?

1187
00:58:24,300 --> 00:58:25,600
Adalah 1 kurang dari 6?

1188
00:58:25,600 --> 00:58:28,600
Adalah 2 kurang dari 6, dan sebagainya?

1189
00:58:28,600 --> 00:58:31,914
>> Tapi aku tidak meminta komputer
lagi, dan lagi, apa

1190
00:58:31,914 --> 00:58:33,080
panjang nama Zamyla ini?

1191
00:58:33,080 --> 00:58:34,320
Apa panjang nama Zamyla ini?

1192
00:58:34,320 --> 00:58:35,986
Apa panjang nama ini Zamyla ini?

1193
00:58:35,986 --> 00:58:40,440
Aku benar-benar mengingat bahwa pertama dan
hanya menjawab dalam variabel n kedua ini.

1194
00:58:40,440 --> 00:58:45,280
Jadi ini sekarang akan menjadi tidak hanya
yang benar, tetapi juga dirancang dengan baik.

1195
00:58:45,280 --> 00:58:46,670
>> Sekarang, bagaimana dengan gaya?

1196
00:58:46,670 --> 00:58:48,866
Aku bernama variabel saya
cukup baik, aku akan mengatakan.

1197
00:58:48,866 --> 00:58:50,240
Mereka super ringkas sekarang.

1198
00:58:50,240 --> 00:58:52,090
Dan itu benar-benar baik-baik saja.

1199
00:58:52,090 --> 00:58:55,120
>> Jika Anda hanya memiliki satu
string dalam sebuah program,

1200
00:58:55,120 --> 00:58:56,860
Anda mungkin juga menyebutnya s string.

1201
00:58:56,860 --> 00:58:59,370
Jika Anda hanya memiliki satu variabel
untuk menghitung dalam sebuah program,

1202
00:58:59,370 --> 00:59:00,710
Anda mungkin juga menyebutnya i.

1203
00:59:00,710 --> 00:59:03,500
Jika Anda memiliki panjang, n
super umum juga.

1204
00:59:03,500 --> 00:59:05,800
Tapi saya belum berkomentar apapun dari kode saya.

1205
00:59:05,800 --> 00:59:09,200
>> Aku sudah tidak diberitahu reader--
apakah itu TF saya, atau TA,

1206
00:59:09,200 --> 00:59:12,460
atau hanya colleague-- apa yang seharusnya
akan terjadi di program ini.

1207
00:59:12,460 --> 00:59:15,760
Dan untuk mendapatkan gaya yang baik,
apa yang saya ingin lakukan

1208
00:59:15,760 --> 00:59:24,580
adalah sesuatu ini--
seperti meminta pengguna untuk input.

1209
00:59:24,580 --> 00:59:26,670
Dan aku bisa menulis ulang
ini berbagai cara.

1210
00:59:26,670 --> 00:59:35,630
>> Pastikan s-- memastikan get
string kembali string.

1211
00:59:35,630 --> 00:59:40,280
Dan kemudian di sini-dan ini mungkin
yang iterate comment-- paling penting

1212
00:59:40,280 --> 00:59:44,450
atas karakter dalam s satu per satu.

1213
00:59:44,450 --> 00:59:47,060
Dan saya bisa menggunakan
pilihan bahasa Inggris

1214
00:59:47,060 --> 00:59:49,650
di sini untuk menggambarkan setiap
dari potongan kode ini.

1215
00:59:49,650 --> 00:59:52,740
>> Perhatikan bahwa saya tidak menempatkan
mengomentari setiap baris kode,

1216
00:59:52,740 --> 00:59:55,690
benar-benar hanya pada menarik
yang, orang-orang yang

1217
00:59:55,690 --> 00:59:59,460
memiliki beberapa arti bahwa saya mungkin
ingin membuat super jelas kepada seseorang

1218
00:59:59,460 --> 01:00:00,460
membaca kode saya.

1219
01:00:00,460 --> 01:00:02,920
Dan mengapa Anda menelepon mendapatkan
string yang meminta pengguna untuk input?

1220
01:00:02,920 --> 01:00:05,450
Bahkan salah satu yang tidak tentu
semua yang deskriptif.

1221
01:00:05,450 --> 01:00:09,340
Tapi membantu bercerita, karena
baris kedua di cerita ini, pastikan

1222
01:00:09,340 --> 01:00:10,740
mendapatkan string kembali string.

1223
01:00:10,740 --> 01:00:14,260
>> Dan baris ketiga dalam cerita adalah,
iterate atas karakter dalam s satu

1224
01:00:14,260 --> 01:00:15,380
pada suatu waktu.

1225
01:00:15,380 --> 01:00:17,920
Dan sekarang hanya untuk mengukur baik,
Aku akan pergi ke depan dan menambahkan

1226
01:00:17,920 --> 01:00:24,560
satu komentar lebih yang hanya
kata print-i karakter di s.

1227
01:00:24,560 --> 01:00:26,520
Sekarang, apa yang saya lakukan
pada akhir hari?

1228
01:00:26,520 --> 01:00:29,190
>> Saya telah menambahkan beberapa bahasa Inggris
kata-kata dalam bentuk komentar.

1229
01:00:29,190 --> 01:00:32,700
Simbol slash garis miring berarti, hey,
komputer ini adalah untuk manusia,

1230
01:00:32,700 --> 01:00:33,820
bukan untuk Anda, komputer.

1231
01:00:33,820 --> 01:00:35,119
Jadi mereka diabaikan logis.

1232
01:00:35,119 --> 01:00:35,910
Mereka hanya ada.

1233
01:00:35,910 --> 01:00:39,830
>> Dan, memang, CS50 IDE menunjukkan mereka sebagai
abu-abu, sebagai berguna, tapi tidak key

1234
01:00:39,830 --> 01:00:41,000
untuk program ini.

1235
01:00:41,000 --> 01:00:42,570
Perhatikan apa yang Anda sekarang dapat melakukan.

1236
01:00:42,570 --> 01:00:44,950
Apakah Anda tahu C
pemrograman atau tidak, Anda

1237
01:00:44,950 --> 01:00:47,722
hanya bisa berdiri kembali di ini
Program, dan skim komentar.

1238
01:00:47,722 --> 01:00:50,180
Meminta pengguna untuk input, pastikan
mendapatkan string kembali string,

1239
01:00:50,180 --> 01:00:53,009
iterate atas karakter di s
satu per satu, mencetak karakter

1240
01:00:53,009 --> 01:00:55,550
karakter ke-i di s-- Anda tidak
bahkan harus melihat kode

1241
01:00:55,550 --> 01:00:57,270
untuk memahami apa program ini tidak.

1242
01:00:57,270 --> 01:01:00,280
Dan, lebih baik lagi, jika Anda sendiri melihat
di program ini dalam satu atau dua minggu,

1243
01:01:00,280 --> 01:01:02,280
atau satu bulan, atau satu tahun,
Anda juga tidak memiliki

1244
01:01:02,280 --> 01:01:04,420
menatap kode,
mencoba mengingat,

1245
01:01:04,420 --> 01:01:06,630
apa yang saya coba lakukan dengan kode ini?

1246
01:01:06,630 --> 01:01:07,770
>> Anda mengatakan kepada diri sendiri.

1247
01:01:07,770 --> 01:01:11,660
Anda sudah dijelaskan untuk diri sendiri,
atau kolega, atau TA, atau TF.

1248
01:01:11,660 --> 01:01:14,860
Dan jadi ini sekarang akan menjadi
yang benar, dan baik desain,

1249
01:01:14,860 --> 01:01:18,210
dan akhirnya baik gaya juga.

1250
01:01:18,210 --> 01:01:19,990
Begitu mengingatnya.

1251
01:01:19,990 --> 01:01:22,200
>> Jadi ada satu lainnya
hal yang akan saya lakukan di sini

1252
01:01:22,200 --> 01:01:28,240
yang sekarang dapat mengungkapkan persis apa
terjadi di bawah tenda.

1253
01:01:28,240 --> 01:01:30,390
Jadi ada fitur ini
di C, dan bahasa lainnya,

1254
01:01:30,390 --> 01:01:33,010
disebut typecasting
yang baik secara implisit

1255
01:01:33,010 --> 01:01:37,250
atau secara eksplisit memungkinkan Anda untuk mengkonversi
dari satu tipe data yang lain.

1256
01:01:37,250 --> 01:01:39,800
Kita sudah berhadapan sehingga
jauh hari dengan string.

1257
01:01:39,800 --> 01:01:41,250
>> Dan string adalah karakter.

1258
01:01:41,250 --> 01:01:44,910
Tapi ingat dari minggu
0, apa karakter?

1259
01:01:44,910 --> 01:01:49,334
Karakter hanya sebuah abstraksi
di atas angka desimal Numbers,

1260
01:01:49,334 --> 01:01:52,500
dan angka desimal yang benar-benar hanya
abstraksi di atas bilangan biner,

1261
01:01:52,500 --> 01:01:53,720
seperti yang kita mendefinisikannya.

1262
01:01:53,720 --> 01:01:55,540
>> Jadi karakter angka.

1263
01:01:55,540 --> 01:01:58,410
Dan nomor karakter,
hanya tergantung pada konteksnya.

1264
01:01:58,410 --> 01:02:01,250
Dan ternyata di dalam
dari program komputer,

1265
01:02:01,250 --> 01:02:06,830
Anda dapat menentukan bagaimana Anda ingin melihat
pada bit di dalam program itu?

1266
01:02:06,830 --> 01:02:10,400
>> Ingat dari minggu 0 yang kita miliki
Ascii, yang hanya kode ini

1267
01:02:10,400 --> 01:02:11,620
huruf pemetaan ke nomor.

1268
01:02:11,620 --> 01:02:13,660
Dan kami mengatakan, modal A adalah 65.

1269
01:02:13,660 --> 01:02:15,860
Modal B adalah 66, dan sebagainya.

1270
01:02:15,860 --> 01:02:20,500
>> Dan pemberitahuan, kita pada dasarnya memiliki karakter di
baris atas di sini, seperti C akan memanggil mereka,

1271
01:02:20,500 --> 01:02:23,400
karakter, dan kemudian
int pada baris kedua.

1272
01:02:23,400 --> 01:02:28,180
Dan ternyata Anda dapat mengkonversi
mulus antara dua, biasanya.

1273
01:02:28,180 --> 01:02:30,042
Dan jika kita ingin melakukan
ini sengaja, kita

1274
01:02:30,042 --> 01:02:31,750
mungkin ingin mengatasi
sesuatu seperti ini.

1275
01:02:31,750 --> 01:02:33,590
>> Kita mungkin ingin mengkonversi
kasus atas ke bawah

1276
01:02:33,590 --> 01:02:35,330
kasus, atau huruf kecil ke huruf besar.

1277
01:02:35,330 --> 01:02:38,000
Dan ternyata ada ini
sebenarnya pola di sini

1278
01:02:38,000 --> 01:02:39,900
kita bisa merangkul hanya dalam beberapa saat.

1279
01:02:39,900 --> 01:02:44,120
Tapi mari kita lihat pertama pada
Misalnya melakukan hal ini secara eksplisit.

1280
01:02:44,120 --> 01:02:46,340
>> Aku akan kembali ke CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Aku akan membuat
file bernama Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Dan aku akan pergi ke depan dan menambahkan saya
io.h standar di atas, int void main

1283
01:02:55,960 --> 01:02:57,370
di bagian atas fungsi saya.

1284
01:02:57,370 --> 01:03:02,700
Dan kemudian aku hanya akan melakukan
following-- untuk loop dari i sama,

1285
01:03:02,700 --> 01:03:04,610
katakanlah, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Dan kemudian saya akan menjadi kurang dari
65, ditambah 26 huruf dalam alfabet.

1287
01:03:10,460 --> 01:03:12,640
Jadi saya akan membiarkan komputer
melakukan matematika untuk saya di sana.

1288
01:03:12,640 --> 01:03:15,100
Dan kemudian di dalam lingkaran ini,
apa yang akan saya untuk mencetak?

1289
01:03:15,100 --> 01:03:19,230
>> % C adalah% i backslash n.

1290
01:03:19,230 --> 01:03:21,290
Dan sekarang saya ingin pasang di dua nilai.

1291
01:03:21,290 --> 01:03:24,530
Aku telah menempatkan sementara pertanyaan
menandai ada mengundang pertanyaan.

1292
01:03:24,530 --> 01:03:29,940
>> Saya ingin beralih dari 65 dan seterusnya
untuk 26 huruf abjad,

1293
01:03:29,940 --> 01:03:35,190
mencetak pada setiap iterasi yang
karakter setara terpisahkan.

1294
01:03:35,190 --> 01:03:38,299
Dengan kata lain, saya ingin
iterate lebih dari 26 nomor printing

1295
01:03:38,299 --> 01:03:41,590
apa karakter Ascii adalah, surat itu,
dan apa jumlah yang sesuai is--

1296
01:03:41,590 --> 01:03:44,650
benar-benar hanya menciptakan
grafik dari slide itu.

1297
01:03:44,650 --> 01:03:47,010
Jadi apa yang harus tanda tanya ini itu?

1298
01:03:47,010 --> 01:03:51,760
>> Nah, ternyata kedua
satu hanya harus menjadi variabel i.

1299
01:03:51,760 --> 01:03:53,860
Saya ingin melihat bahwa sebagai angka.

1300
01:03:53,860 --> 01:03:58,920
Dan argumen tengah
di sini, saya dapat memberitahu komputer

1301
01:03:58,920 --> 01:04:03,470
untuk mengobati integer yang
i sebagai karakter, sehingga

1302
01:04:03,470 --> 01:04:05,880
untuk menggantikan sini untuk persen C.

1303
01:04:05,880 --> 01:04:07,990
>> Dengan kata lain, jika saya, yang
programmer manusia, tahu

1304
01:04:07,990 --> 01:04:09,865
ini hanya nomor
pada akhir hari.

1305
01:04:09,865 --> 01:04:12,500
Dan aku tahu bahwa 65 harus
memetakan ke beberapa karakter.

1306
01:04:12,500 --> 01:04:15,310
Dengan cor eksplisit ini,
dengan kurung,

1307
01:04:15,310 --> 01:04:18,840
nama jenis data yang ingin Anda
dikonversi ke, dan kurung tertutup,

1308
01:04:18,840 --> 01:04:21,200
Anda dapat memberitahu
komputer, hey, komputer,

1309
01:04:21,200 --> 01:04:24,130
mengkonversi bilangan bulat ini ke char.

1310
01:04:24,130 --> 01:04:26,250
>> Jadi ketika saya menjalankan ini
Program setelah kompilasi,

1311
01:04:26,250 --> 01:04:29,740
mari kita lihat apa get-- saya membuat Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Sial, apa yang saya lakukan salah di sini?

1313
01:04:33,020 --> 01:04:35,884
Gunakan pengenal dideklarasikan,
semua benar, tidak disengaja,

1314
01:04:35,884 --> 01:04:37,800
tapi mari kita lihat apakah kita tidak bisa
Alasan melalui ini.

1315
01:04:37,800 --> 01:04:41,220
>> Jadi garis five-- jadi saya tidak mendapatkan
sangat jauh sebelum mengacaukan.

1316
01:04:41,220 --> 01:04:42,140
Itu OK.

1317
01:04:42,140 --> 01:04:46,560
Jadi baris 5 untuk saya sama 65-- saya lihat.

1318
01:04:46,560 --> 01:04:50,130
Jadi ingat bahwa dalam C, tidak seperti beberapa
bahasa jika Anda memiliki pemrograman sebelumnya

1319
01:04:50,130 --> 01:04:52,190
pengalaman, Anda memiliki
untuk memberitahu komputer,

1320
01:04:52,190 --> 01:04:55,040
tidak seperti Scratch, apa
jenis variabel itu.

1321
01:04:55,040 --> 01:04:56,860
>> Dan aku lupa frase kunci di sini.

1322
01:04:56,860 --> 01:04:59,200
Sejalan lima, aku sudah mulai menggunakan i.

1323
01:04:59,200 --> 01:05:01,560
Tapi saya belum diberitahu C
data apa jenis itu.

1324
01:05:01,560 --> 01:05:04,570
Jadi aku akan pergi di sini dan
mengatakan, ah, membuatnya integer.

1325
01:05:04,570 --> 01:05:07,050
>> Sekarang aku akan pergi ke depan dan mengkompilasi ulang.

1326
01:05:07,050 --> 01:05:08,080
Yang tetap itu.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Masukkan, itu agak dingin.

1328
01:05:12,660 --> 01:05:15,360
Tidak hanya itu super cepat untuk
meminta komputer pertanyaan ini,

1329
01:05:15,360 --> 01:05:18,885
daripada melihat itu pada slide,
itu dicetak satu per baris, A adalah 65,

1330
01:05:18,885 --> 01:05:24,860
B adalah 66, semua jalan down-- sejak saya
melakukan ini 26 times-- untuk huruf z,

1331
01:05:24,860 --> 01:05:25,630
yang 90.

1332
01:05:25,630 --> 01:05:27,790
Dan, pada kenyataannya, sedikit
lebih cerdas akan

1333
01:05:27,790 --> 01:05:31,030
telah bagi saya untuk tidak bergantung
di komputer untuk menambah 26.

1334
01:05:31,030 --> 01:05:34,060
Saya bisa saja melakukan
90 juga, begitu lama

1335
01:05:34,060 --> 01:05:37,390
karena saya tidak membuat kesalahan yang sama dua kali.

1336
01:05:37,390 --> 01:05:41,880
Saya ingin pergi melalui
z, bukan hanya melalui y.

1337
01:05:41,880 --> 01:05:44,000
>> Jadi itulah cast yang eksplisit.

1338
01:05:44,000 --> 01:05:47,860
Ternyata ini
bahkan tidak diperlukan.

1339
01:05:47,860 --> 01:05:52,480
Biarkan aku pergi ke depan dan memutarkan ini
compiler, dan jalankan kembali Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Ternyata C cukup cerdas.

1341
01:05:54,940 --> 01:05:57,150
>> Dan printf, khususnya,
cukup cerdas.

1342
01:05:57,150 --> 01:06:01,260
Jika Anda hanya lulus saya dua kali
untuk kedua placeholder, printf

1343
01:06:01,260 --> 01:06:04,510
akan menyadari, oh, baik saya tahu Anda
memberi saya sebuah integer-- beberapa nomor,

1344
01:06:04,510 --> 01:06:06,380
seperti 65, atau 90, atau apa pun.

1345
01:06:06,380 --> 01:06:10,170
Tapi saya melihat bahwa Anda ingin aku
memformat nomor seperti karakter.

1346
01:06:10,170 --> 01:06:16,460
Dan printf implisit dapat mengusir
int ke char untuk Anda juga.

1347
01:06:16,460 --> 01:06:19,360
Sehingga tidak masalah sama sekali.

1348
01:06:19,360 --> 01:06:23,100
>> Tapi perhatikan, karena kesetaraan ini
kita benar-benar bisa melakukan ini juga.

1349
01:06:23,100 --> 01:06:26,520
Biarkan aku pergi ke depan dan membuat satu
Versi lain dari ini-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
Dan bukannya iterasi
bilangan bulat, benar-benar dapat meniup pikiran Anda

1351
01:06:31,800 --> 01:06:33,610
oleh iterasi karakter.

1352
01:06:33,610 --> 01:06:37,660
Jika char c mendapat modal A, I
ingin pergi ke depan dan melakukan hal ini,

1353
01:06:37,660 --> 01:06:41,740
asalkan C kurang dari atau sama
untuk Z. modal Dan pada setiap iterasi

1354
01:06:41,740 --> 01:06:45,690
Saya ingin kenaikan C, saya bisa
sekarang sejalan printf saya di sini

1355
01:06:45,690 --> 01:06:51,320
katakanlah, persen C adalah
persen saya lagi, koma C.

1356
01:06:51,320 --> 01:06:57,200
>> Dan sekarang, aku bisa pergi ke arah lain,
pengecoran karakter secara eksplisit

1357
01:06:57,200 --> 01:06:58,500
ke integer.

1358
01:06:58,500 --> 01:07:00,560
Jadi, sekali lagi, mengapa anda melakukan hal ini?

1359
01:07:00,560 --> 01:07:03,830
Ini sedikit aneh untuk menyortir dari
menghitung dalam hal karakter.

1360
01:07:03,830 --> 01:07:07,430
>> Tetapi jika Anda memahami apa yang
terjadi di bawah tenda,

1361
01:07:07,430 --> 01:07:08,430
ada benar-benar ada keajaiban.

1362
01:07:08,430 --> 01:07:13,060
Kau hanya mengatakan, hei, komputer memberikan
saya variabel yang disebut C tipe char.

1363
01:07:13,060 --> 01:07:16,520
Menginisialisasi ke ibukota A. Dan
melihat satu kutipan materi.

1364
01:07:16,520 --> 01:07:19,580
>> Untuk karakter dalam C, mengingat dari
pekan lalu, Anda menggunakan tanda kutip tunggal.

1365
01:07:19,580 --> 01:07:23,720
Untuk string, untuk kata-kata,
frase, Anda menggunakan tanda kutip ganda.

1366
01:07:23,720 --> 01:07:27,210
OK, komputer, terus melakukan hal ini, sehingga
Selama karakter kurang dari

1367
01:07:27,210 --> 01:07:28,050
atau sama dengan z.

1368
01:07:28,050 --> 01:07:32,640
Dan aku tahu dari meja Ascii saya bahwa semua
kode Ascii ini bersebelahan.

1369
01:07:32,640 --> 01:07:33,400
>> Tidak ada kesenjangan.

1370
01:07:33,400 --> 01:07:36,737
Jadi itu hanya A sampai Z,
dipisahkan oleh satu nomor masing-masing.

1371
01:07:36,737 --> 01:07:38,820
Dan kemudian saya dapat kenaikan
char, jika saya benar-benar ingin.

1372
01:07:38,820 --> 01:07:40,390
Pada akhir hari,
itu hanya sebuah nomor.

1373
01:07:40,390 --> 01:07:41,030
Saya tahu ini.

1374
01:07:41,030 --> 01:07:43,670
Jadi saya hanya bisa menganggap menambahkan 1 untuk itu.

1375
01:07:43,670 --> 01:07:46,940
>> Dan kemudian saat ini, saya mencetak c,
dan kemudian integral setara.

1376
01:07:46,940 --> 01:07:50,170
Dan aku bahkan tidak perlu cast eksplisit.

1377
01:07:50,170 --> 01:07:52,680
Aku bisa membiarkan printf dan
Angka komputer hal-hal,

1378
01:07:52,680 --> 01:07:57,300
sehingga jika saya menjalankan
membuat Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Saya mendapatkan hal yang sama juga.

1380
01:08:01,520 --> 01:08:04,530
>> program yang tidak berguna, though-- tidak ada
akan benar-benar menulis perangkat lunak

1381
01:08:04,530 --> 01:08:07,549
dalam rangka untuk mencari tahu, apa yang
nomor yang memetakan ke A, atau B, atau Z?

1382
01:08:07,549 --> 01:08:10,340
Anda hanya akan Google itu, atau
mencarinya secara online, atau mencarinya

1383
01:08:10,340 --> 01:08:11,650
pada slide, atau sejenisnya.

1384
01:08:11,650 --> 01:08:13,520
Jadi bagaimana ini benar-benar mendapatkan berguna?

1385
01:08:13,520 --> 01:08:15,960
>> Nah, berbicara tentang itu
slide, melihat ada

1386
01:08:15,960 --> 01:08:20,890
pola yang sebenarnya di sini antara huruf besar
dan huruf kecil yang tidak disengaja.

1387
01:08:20,890 --> 01:08:23,760
Perhatikan bahwa modal A adalah 65.

1388
01:08:23,760 --> 01:08:25,830
Huruf kecil adalah 97.

1389
01:08:25,830 --> 01:08:29,649
Dan seberapa jauh adalah huruf kecil a?

1390
01:08:29,649 --> 01:08:32,649
>> Jadi 65 adalah berapa banyak langkah dari 97?

1391
01:08:32,649 --> 01:08:36,210
Jadi 97 dikurangi 65 adalah 32.

1392
01:08:36,210 --> 01:08:37,910
Jadi modal adalah 65.

1393
01:08:37,910 --> 01:08:39,939
Jika Anda menambahkan 32 untuk itu,
Anda mendapatkan huruf kecil a.

1394
01:08:39,939 --> 01:08:43,729
Dan, secara ekuivalen, jika Anda mengurangi 32,
Anda kembali ke ibukota A-- sama dengan B

1395
01:08:43,729 --> 01:08:46,380
untuk sedikit b, C besar untuk sedikit c.

1396
01:08:46,380 --> 01:08:50,670
>> Semua kesenjangan ini 32 terpisah.

1397
01:08:50,670 --> 01:08:54,450
Sekarang, ini tampaknya akan memungkinkan kita untuk
melakukan sesuatu seperti Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
atau Google Docs memiliki, di mana Anda
dapat memilih segala sesuatu dan kemudian berkata,

1399
01:08:57,729 --> 01:09:00,520
mengubah semua huruf kecil, atau
mengubah semua kasus atas,

1400
01:09:00,520 --> 01:09:03,840
atau mengubah hanya kata pertama
dari kalimat untuk huruf.

1401
01:09:03,840 --> 01:09:07,390
Kami benar-benar bisa melakukan sesuatu
seperti itu diri kita sendiri.

1402
01:09:07,390 --> 01:09:12,645
>> Biarkan aku pergi ke depan dan menyimpan file
di sini disebut memanfaatkan 0.c.

1403
01:09:12,645 --> 01:09:15,770
Dan mari kita pergi ke depan dan menyiapkan program
yang tidak tepat sebagai berikut.

1404
01:09:15,770 --> 01:09:18,460
Jadi termasuk perpustakaan CS50.

1405
01:09:18,460 --> 01:09:21,430
Dan termasuk standar I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Dan aku tahu ini akan datang segera.

1407
01:09:22,787 --> 01:09:24,870
Jadi aku akan memasukkannya ke dalam
sudah ada, string.h,

1408
01:09:24,870 --> 01:09:26,960
jadi saya memiliki akses ke
hal-hal seperti Stirling,

1409
01:09:26,960 --> 01:09:29,620
dan kemudian int void main, seperti biasa.

1410
01:09:29,620 --> 01:09:33,420
Dan kemudian aku akan pergi ke depan
dan melakukan string mendapat mendapatkan string,

1411
01:09:33,420 --> 01:09:35,032
hanya untuk mendapatkan string dari pengguna.

1412
01:09:35,032 --> 01:09:36,740
Dan kemudian aku akan
melakukan cek kewarasan saya.

1413
01:09:36,740 --> 01:09:40,510
Jika string yang tidak nol sama,
maka itu aman untuk melanjutkan.

1414
01:09:40,510 --> 01:09:42,000
Dan apa yang ingin saya lakukan?

1415
01:09:42,000 --> 01:09:48,700
Aku akan beralih dari i sama dengan 0,
dan n sampai panjang string s.

1416
01:09:48,700 --> 01:09:51,899
>> Dan aku akan melakukan hal ini selama
i kurang dari n, dan i plus plus.

1417
01:09:51,899 --> 01:09:55,060
Sejauh ini, aku benar-benar hanya
meminjam ide dari sebelumnya.

1418
01:09:55,060 --> 01:09:57,010
Dan sekarang aku akan memperkenalkan cabang.

1419
01:09:57,010 --> 01:09:59,635
>> Jadi pikirkan kembali ke Scratch, di mana
kami memiliki orang-orang garpu di jalan,

1420
01:09:59,635 --> 01:10:05,110
dan minggu lalu di C. Saya akan
mengatakan ini, jika karakter ke-i di s

1421
01:10:05,110 --> 01:10:09,250
lebih besar dari atau
sama untuk menurunkan kasus,

1422
01:10:09,250 --> 01:10:13,340
dan- di Scratch Anda akan benar-benar
katakan dan, tapi di C Anda katakan ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- dan karakter ke-i di s
kurang dari atau sama dengan huruf kecil z,

1424
01:10:19,830 --> 01:10:21,780
mari kita lakukan sesuatu yang menarik.

1425
01:10:21,780 --> 01:10:27,020
Mari kita benar-benar mencetak
karakter tanpa baris

1426
01:10:27,020 --> 01:10:31,760
yang merupakan karakter dalam string,
karakter ke-i dalam string.

1427
01:10:31,760 --> 01:10:37,420
>> Tapi mari kita pergi ke depan dan
kurangi 32 dari itu.

1428
01:10:37,420 --> 01:10:42,120
Lain jika karakter dalam
string yang kita cari

1429
01:10:42,120 --> 01:10:45,950
bukan antara sedikit a
dan sedikit z, pergi ke depan

1430
01:10:45,950 --> 01:10:48,610
dan hanya mencetaknya tidak berubah.

1431
01:10:48,610 --> 01:10:50,840
Jadi kami telah memperkenalkan
notasi kurung ini

1432
01:10:50,840 --> 01:10:53,560
untuk string kami untuk mendapatkan di
i-th karakter dalam string.

1433
01:10:53,560 --> 01:10:57,520
>> Saya telah menambahkan beberapa logika kondisional, seperti
Scratch di minggu satu minggu lalu, di mana

1434
01:10:57,520 --> 01:10:59,880
Aku hanya menggunakan dasar saya
pemahaman tentang apa

1435
01:10:59,880 --> 01:11:01,130
terjadi di bawah tenda.

1436
01:11:01,130 --> 01:11:04,190
Adalah karakter ke-i dari s
lebih besar atau sama dengan?

1437
01:11:04,190 --> 01:11:08,290
Seperti, apakah 97, atau 98,
atau 99, dan sebagainya?

1438
01:11:08,290 --> 01:11:11,940
>> Tapi apakah itu juga kurang dari atau sama
dengan nilai z huruf kecil?

1439
01:11:11,940 --> 01:11:16,210
Dan jika demikian, apa garis ini artinya?

1440
01:11:16,210 --> 01:11:20,250
14, ini adalah semacam
kuman dari seluruh ide,

1441
01:11:20,250 --> 01:11:23,840
mengkapitalisasi huruf oleh
hanya mengurangkan 32 dari itu,

1442
01:11:23,840 --> 01:11:29,370
dalam hal ini, karena saya tahu, per yang
grafik, bagaimana nomor saya diwakili.

1443
01:11:29,370 --> 01:11:33,925
Jadi mari kita pergi ke depan dan menjalankan ini,
setelah kompilasi memanfaatkan 0.c,

1444
01:11:33,925 --> 01:11:36,210
dan menjalankan memanfaatkan 0.

1445
01:11:36,210 --> 01:11:40,300
>> Mari mengetik sesuatu seperti
Zamyla di semua huruf kecil masukkan.

1446
01:11:40,300 --> 01:11:42,780
Dan sekarang kami memiliki Zamyla dalam huruf besar.

1447
01:11:42,780 --> 01:11:45,050
Mari kita ketik Rob di semua huruf kecil.

1448
01:11:45,050 --> 01:11:46,674
Mari kita coba Jason dalam semua huruf kecil.

1449
01:11:46,674 --> 01:11:48,590
Dan kami terus mendapatkan
kapitalisasi paksa.

1450
01:11:48,590 --> 01:11:50,960
Ada bug kecil yang saya
jenis tidak mengantisipasi.

1451
01:11:50,960 --> 01:11:54,050
Perhatikan cepat baru saya berakhir
pada baris yang sama seperti nama mereka,

1452
01:11:54,050 --> 01:11:55,520
yang terasa sedikit berantakan.

1453
01:11:55,520 --> 01:11:59,170
>> Jadi aku akan pergi di sini, dan
sebenarnya pada akhir program ini

1454
01:11:59,170 --> 01:12:02,110
mencetak karakter baris baru.

1455
01:12:02,110 --> 01:12:03,160
Itu saja.

1456
01:12:03,160 --> 01:12:06,120
Dengan printf, Anda tidak perlu
lulus dalam variabel atau kode Format.

1457
01:12:06,120 --> 01:12:08,460
Anda dapat benar-benar hanya mencetak
sesuatu seperti baris baru.

1458
01:12:08,460 --> 01:12:13,529
>> Jadi mari kita pergi ke depan dan membuat
memanfaatkan 0 lagi, jalankan kembali itu, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Dan sekarang sudah sedikit lebih cantik.

1460
01:12:14,820 --> 01:12:17,274
Sekarang, saya prompt adalah pada baris baru sendiri.

1461
01:12:17,274 --> 01:12:18,440
Jadi itu semua baik dan bagus.

1462
01:12:18,440 --> 01:12:19,910
Jadi itu contoh yang baik.

1463
01:12:19,910 --> 01:12:22,700
Tapi aku bahkan tidak tentu
perlu kode keras 32.

1464
01:12:22,700 --> 01:12:23,350
Kamu tahu apa?

1465
01:12:23,350 --> 01:12:26,350
Aku bisa say-- saya tidak pernah
ingat apa perbedaannya.

1466
01:12:26,350 --> 01:12:29,330
>> Tapi aku tahu bahwa jika saya
memiliki huruf kecil,

1467
01:12:29,330 --> 01:12:34,430
Saya pada dasarnya ingin mengurangi off
apa pun jarak antara sedikit

1468
01:12:34,430 --> 01:12:39,160
dan besar A, karena jika saya berasumsi bahwa
semua surat-surat lainnya adalah sama,

1469
01:12:39,160 --> 01:12:41,045
yang seharusnya mendapatkan pekerjaan yang dilakukan.

1470
01:12:41,045 --> 01:12:42,670
Namun, bukannya melakukan itu, Anda tahu apa?

1471
01:12:42,670 --> 01:12:44,240
Ada cara lain masih.

1472
01:12:44,240 --> 01:12:48,090
>> Jika yang memanfaatkan 1.c-- jika saya
untuk menempatkan bahwa ke file terpisah.

1473
01:12:48,090 --> 01:12:51,030
mari kita jangan memanfaatkan 2.c sebagai berikut.

1474
01:12:51,030 --> 01:12:53,060
Aku akan benar-benar membersihkan ini di sini.

1475
01:12:53,060 --> 01:12:57,420
Dan bukannya bahkan harus
tahu atau peduli tentang orang-orang tingkat rendah

1476
01:12:57,420 --> 01:13:01,090
rincian implementasi, aku bukan
hanya akan mencetak karakter,

1477
01:13:01,090 --> 01:13:04,610
kutipan tanda kutip, persen C, dan
kemudian memanggil fungsi lain yang

1478
01:13:04,610 --> 01:13:09,950
ada yang mengambil argumen,
yang merupakan karakter, seperti ini.

1479
01:13:09,950 --> 01:13:12,630
>> Ternyata di C, ada
fungsi panggilan lain

1480
01:13:12,630 --> 01:13:15,550
untuk atas, yang seperti namanya
menyarankan mengambil karakter

1481
01:13:15,550 --> 01:13:19,350
dan membuat kasus atasnya
setara, dan kemudian mengembalikannya

1482
01:13:19,350 --> 01:13:21,410
sehingga printf dapat pasang di sana.

1483
01:13:21,410 --> 01:13:25,484
Dan untuk melakukan hal ini, meskipun, saya
perlu memperkenalkan satu file lainnya.

1484
01:13:25,484 --> 01:13:28,400
Ternyata ada file lain
bahwa Anda hanya akan tahu dari kelas,

1485
01:13:28,400 --> 01:13:33,020
atau buku teks, atau secara online
referensi, yang disebut C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Jadi jika saya menambahkan bahwa di antara header saya
file, dan sekarang kompilasi ulang program ini,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Mari kita ketik Zamyla di semua
huruf kecil, masih bekerja sama.

1489
01:13:46,690 --> 01:13:48,040
Tapi kau tahu apa?

1490
01:13:48,040 --> 01:13:55,590
Ternyata untuk atas
memiliki beberapa fungsi lainnya.

1491
01:13:55,590 --> 01:13:58,410
>> Dan biarkan saya memperkenalkan ini
perintah di sini, semacam canggung

1492
01:13:58,410 --> 01:14:00,250
bernama, tetapi manusia untuk manual.

1493
01:14:00,250 --> 01:14:03,960
Ternyata kebanyakan komputer Linux,
karena kami menggunakan sini-operasi Linux

1494
01:14:03,960 --> 01:14:06,270
system-- memiliki perintah
disebut manusia, yang mengatakan,

1495
01:14:06,270 --> 01:14:08,530
hey, komputer, memberikan
komputer pengguna.

1496
01:14:08,530 --> 01:14:10,680
Apa yang Anda ingin
mencari di manual yang?

1497
01:14:10,680 --> 01:14:13,840
>> Saya ingin mencari fungsi
dipanggil untuk atas, Enter.

1498
01:14:13,840 --> 01:14:16,070
Dan itu sedikit samar
untuk membaca kadang-kadang.

1499
01:14:16,070 --> 01:14:18,780
Tapi perhatikan kami di
Linux programmer manual.

1500
01:14:18,780 --> 01:14:19,530
Dan itu semua teks.

1501
01:14:19,530 --> 01:14:21,905
Dan perhatikan bahwa ada yang
nama fungsi di sini.

1502
01:14:21,905 --> 01:14:25,030
Ternyata ia memiliki sepupu bernama
untuk menurunkan, yang tidak sebaliknya.

1503
01:14:25,030 --> 01:14:29,710
Dan pemberitahuan berdasarkan sinopsis, untuk menggunakan ini
berfungsi halaman manual, sehingga untuk berbicara,

1504
01:14:29,710 --> 01:14:32,220
mengatakan kepada saya bahwa saya
harus menyertakan c type.h.

1505
01:14:32,220 --> 01:14:33,630
Dan aku tahu bahwa dari latihan.

1506
01:14:33,630 --> 01:14:36,210
>> Di sini, itu menunjukkan saya dua
prototipe untuk fungsi,

1507
01:14:36,210 --> 01:14:39,070
sehingga jika saya pernah ingin menggunakan ini
Aku tahu apa yang mereka ambil sebagai masukan,

1508
01:14:39,070 --> 01:14:40,652
dan apa yang mereka kembali sebagai output.

1509
01:14:40,652 --> 01:14:42,360
Dan kemudian jika saya membaca
deskripsi, saya melihat

1510
01:14:42,360 --> 01:14:44,820
secara lebih rinci apa fungsi tidak.

1511
01:14:44,820 --> 01:14:48,100
Tapi yang lebih penting, jika
Aku melihat di bawah nilai kembali,

1512
01:14:48,100 --> 01:14:51,710
ia mengatakan nilai yang dikembalikan adalah
bahwa surat dikonversi,

1513
01:14:51,710 --> 01:14:57,880
atau C, masukan asli, jika
konversi itu tidak mungkin.

1514
01:14:57,880 --> 01:15:01,992
>> Dengan kata lain, untuk bagian atas akan mencoba
untuk mengkonversi surat kepada huruf.

1515
01:15:01,992 --> 01:15:03,450
Dan jika demikian, itu akan mengembalikannya.

1516
01:15:03,450 --> 01:15:07,010
Tapi jika tidak bisa untuk beberapa reason--
mungkin itu kasus sudah atas,

1517
01:15:07,010 --> 01:15:09,550
mungkin itu tanda seru
atau punctuation-- lainnya

1518
01:15:09,550 --> 01:15:12,200
itu hanya akan
mengembalikan C asli,

1519
01:15:12,200 --> 01:15:17,340
yang berarti saya dapat membuat kode saya
lebih baik dirancang sebagai berikut.

1520
01:15:17,340 --> 01:15:20,580
>> Saya tidak perlu semua
baris sialan ini kode.

1521
01:15:20,580 --> 01:15:22,610
Semua lini saya sudah
hanya disorot bisa

1522
01:15:22,610 --> 01:15:28,700
akan runtuh menjadi hanya satu sederhana
line, yang ini-- printf persen

1523
01:15:28,700 --> 01:15:33,510
c untuk S bracket atas i.

1524
01:15:33,510 --> 01:15:36,090
Dan ini akan menjadi
contoh desain yang lebih baik.

1525
01:15:36,090 --> 01:15:40,040
>> Mengapa menerapkan dalam 7 atau 8 baris
kode, apa pun itu saya hanya

1526
01:15:40,040 --> 01:15:44,960
dihapus, ketika Anda malah bisa runtuh
semua itu logika dan pengambilan keputusan

1527
01:15:44,960 --> 01:15:49,620
menjadi satu baris, 13 sekarang, yang
bergantung pada perpustakaan function--

1528
01:15:49,620 --> 01:15:53,430
fungsi yang datang dengan C, tapi itu
tidak persis apa yang Anda ingin lakukan.

1529
01:15:53,430 --> 01:15:55,295
Dan, terus terang, bahkan jika
itu tidak datang dengan C,

1530
01:15:55,295 --> 01:15:58,880
Anda bisa menerapkan sendiri, sebagai
kita lihat, dengan mendapatkan int negatif

1531
01:15:58,880 --> 01:16:01,700
dan positif int pekan lalu juga.

1532
01:16:01,700 --> 01:16:03,470
>> Kode ini sekarang jauh lebih mudah dibaca.

1533
01:16:03,470 --> 01:16:06,670
Dan, memang, jika kita gulir ke atas,
melihat berapa banyak lebih kompak

1534
01:16:06,670 --> 01:16:08,360
versi ini program saya adalah.

1535
01:16:08,360 --> 01:16:11,230
Ini adalah berat atas sedikit sekarang,
dengan semua ini termasuk.

1536
01:16:11,230 --> 01:16:14,380
Tapi itu OK, karena sekarang aku berdiri
di pundak programmer

1537
01:16:14,380 --> 01:16:15,300
sebelum saya.

1538
01:16:15,300 --> 01:16:18,440
Dan siapa pun itu yang
diimplementasikan untuk atas benar-benar

1539
01:16:18,440 --> 01:16:21,470
melakukan saya nikmat, seperti siapa pun
diimplementasikan Stirling benar

1540
01:16:21,470 --> 01:16:24,790
melakukan saya nikmat beberapa waktu lalu.

1541
01:16:24,790 --> 01:16:26,970
Dan sekarang kita memiliki
Program desain yang lebih baik

1542
01:16:26,970 --> 01:16:31,680
yang mengimplementasikan logika yang sama persis.

1543
01:16:31,680 --> 01:16:35,580
>> Berbicara tentang stirling, biarkan
saya pergi ke depan dan melakukan hal ini.

1544
01:16:35,580 --> 01:16:38,320
Biarkan aku pergi ke depan dan menyimpan
file ini sebagai stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Dan ternyata, kita dapat mengupas
satu lapisan lain cukup hanya sekarang.

1546
01:16:43,255 --> 01:16:45,630
Aku akan pergi ke depan dan cambuk
up program lain di utama

1547
01:16:45,630 --> 01:16:49,759
di sini yang hanya re-alat
panjang string sebagai berikut.

1548
01:16:49,759 --> 01:16:52,300
Jadi di sini adalah baris kode yang
membuat saya string dari pengguna.

1549
01:16:52,300 --> 01:16:53,910
Kami terus menggunakan ini lagi dan lagi.

1550
01:16:53,910 --> 01:16:58,900
Biarkan saya memberi diriku variabel yang disebut
n tipe int yang menyimpan nomor.

1551
01:16:58,900 --> 01:17:02,490
>> Dan biarkan aku pergi ke depan dan
melakukan logika berikut.

1552
01:17:02,490 --> 01:17:15,610
Sementara karakter n-th di s tidak
tidak sama backslash 0, pergi ke depan

1553
01:17:15,610 --> 01:17:17,930
dan kenaikan n.

1554
01:17:17,930 --> 01:17:23,506
Dan kemudian mencetak printf persen i n.

1555
01:17:23,506 --> 01:17:29,200
Saya mengklaim bahwa program ini di sini,
tanpa menelepon panjang string,

1556
01:17:29,200 --> 01:17:31,150
angka keluar panjang string.

1557
01:17:31,150 --> 01:17:34,600
>> Dan sihir sepenuhnya
dikemas dalam garis 8

1558
01:17:34,600 --> 01:17:39,830
di sini dengan apa yang tampak seperti sintaks baru,
backslash ini 0 dalam tanda kutip tunggal.

1559
01:17:39,830 --> 01:17:41,360
Tapi kenapa begitu?

1560
01:17:41,360 --> 01:17:44,100
Nah, pertimbangkan apa yang telah
terjadi selama ini.

1561
01:17:44,100 --> 01:17:47,990
>> Dan sebagai samping sebelum aku lupa, menyadari
juga, bahwa selain halaman manual

1562
01:17:47,990 --> 01:17:50,920
yang datang dengan khas
Sistem Linux seperti CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
menyadari bahwa kita, yang
Staf tentu saja ini, juga telah

1564
01:17:53,770 --> 01:17:56,030
membuat versi situs
dari ide yang sama ini disebut

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, yang memiliki
semua halaman manual yang sama,

1566
01:17:59,940 --> 01:18:02,020
semua itu sama
dokumentasi, serta

1567
01:18:02,020 --> 01:18:05,730
kotak kecil di bagian atas yang memungkinkan
Anda untuk mengkonversi semua cukup

1568
01:18:05,730 --> 01:18:09,025
bahasa misterius ke kurang nyaman
mode, di mana kita, staf pengajar,

1569
01:18:09,025 --> 01:18:12,150
telah melalui dan mencoba untuk menyederhanakan
beberapa bahasa untuk menjaga hal-hal

1570
01:18:12,150 --> 01:18:14,830
berfokus pada ide-ide, dan tidak
beberapa teknis.

1571
01:18:14,830 --> 01:18:20,070
Jadi perlu diingat, reference.cs50.net
sebagai sumber daya yang lain juga.

1572
01:18:20,070 --> 01:18:23,800
>> Tapi mengapa panjang string bekerja di
cara saya mengusulkan saat lalu?

1573
01:18:23,800 --> 01:18:25,160
Berikut nama Zamyla lagi.

1574
01:18:25,160 --> 01:18:27,690
Dan inilah nama Zamyla ini
kotak, seperti yang saya terus lakukan,

1575
01:18:27,690 --> 01:18:31,360
melukis gambar itu menjadi,
benar-benar, hanya urutan karakter.

1576
01:18:31,360 --> 01:18:34,260
Tapi Zamyla tidak ada
dalam isolasi dalam sebuah program.

1577
01:18:34,260 --> 01:18:37,420
>> Ketika Anda menulis dan menjalankan program,
Anda menggunakan Mac atau PC Anda

1578
01:18:37,420 --> 01:18:40,010
sebagai memori, atau RAM sehingga untuk berbicara.

1579
01:18:40,010 --> 01:18:42,620
Dan Anda bisa memikirkan
komputer Anda sebagai memiliki

1580
01:18:42,620 --> 01:18:44,730
banyak gigabyte memori hari ini.

1581
01:18:44,730 --> 01:18:47,700
Dan manggung berarti miliaran,
sehingga miliaran byte.

1582
01:18:47,700 --> 01:18:48,910
>> Tapi mari kita mundur dalam waktu.

1583
01:18:48,910 --> 01:18:51,530
Dan misalkan kita menggunakan
komputer benar-benar tua yang

1584
01:18:51,530 --> 01:18:55,150
hanya memiliki 32 byte memori.

1585
01:18:55,150 --> 01:18:59,310
Aku bisa, di layar komputer saya,
hanya menarik ini sebagai berikut.

1586
01:18:59,310 --> 01:19:05,240
>> Saya hanya bisa mengatakan bahwa saya
komputer memiliki semua memori ini.

1587
01:19:05,240 --> 01:19:08,830
Dan ini seperti tongkat memori, jika
Anda ingat gambar kami dari terakhir kali.

1588
01:19:08,830 --> 01:19:11,670
Dan jika saya hanya membagi
ini cukup kali,

1589
01:19:11,670 --> 01:19:15,040
Saya menyatakan bahwa saya memiliki 32 byte
memori pada layar.

1590
01:19:15,040 --> 01:19:18,239
>> Sekarang, pada kenyataannya, saya hanya dapat
menggambar sejauh pada layar ini di sini.

1591
01:19:18,239 --> 01:19:20,280
Jadi aku akan pergi ke depan,
dan hanya dengan konvensi,

1592
01:19:20,280 --> 01:19:24,050
menggambar memori komputer saya sebagai
grid, bukan hanya sebagai salah satu garis lurus.

1593
01:19:24,050 --> 01:19:28,190
Secara khusus, saya mengklaim sekarang
grid ini, ini 8 dengan 4 grid,

1594
01:19:28,190 --> 01:19:31,800
hanya mewakili semua 32 byte
memori yang tersedia di Mac saya,

1595
01:19:31,800 --> 01:19:33,030
atau tersedia di PC saya.

1596
01:19:33,030 --> 01:19:34,780
Dan mereka membungkus
pada dua baris, hanya

1597
01:19:34,780 --> 01:19:38,030
karena cocok lebih pada layar.

1598
01:19:38,030 --> 01:19:40,800
Tapi ini adalah byte pertama.

1599
01:19:40,800 --> 01:19:41,990
Ini adalah byte kedua.

1600
01:19:41,990 --> 01:19:43,300
Ini adalah byte ketiga.

1601
01:19:43,300 --> 01:19:45,310
>> Dan ini adalah byte ke-32.

1602
01:19:45,310 --> 01:19:52,910
Atau, jika kita berpikir seperti komputer
ilmuwan, ini adalah byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Jadi, Anda harus 0 sampai 31, jika
Anda mulai menghitung pada 0.

1604
01:19:55,950 --> 01:19:59,830
>> Jadi jika kita menggunakan program
bahwa panggilan mendapatkan string,

1605
01:19:59,830 --> 01:20:05,280
dan kami mendapatkan string dari manusia
seperti saya disebut Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
bagaimana di dunia melakukan
keep komputer track yang byte,

1607
01:20:09,430 --> 01:20:12,230
yang sepotong memori,
milik yang tali?

1608
01:20:12,230 --> 01:20:16,270
Dengan kata lain, jika kita melanjutkan ke
ketik nama lain ke dalam komputer,

1609
01:20:16,270 --> 01:20:19,890
seperti Andi ini, menelepon
mendapatkan string kedua kalinya,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I harus berakhir di
memori komputer juga.

1611
01:20:23,030 --> 01:20:23,850
Tapi bagaimana caranya?

1612
01:20:23,850 --> 01:20:29,700
>> Nah, ternyata di bawah
hood, apa C tidak ketika menyimpan string

1613
01:20:29,700 --> 01:20:35,080
bahwa jenis manusia dalam, atau bahwa
berasal dari sumber lain, itu

1614
01:20:35,080 --> 01:20:39,190
melukiskan akhir mereka dengan
backslash character-- khusus

1615
01:20:39,190 --> 01:20:44,750
0, yang hanya dengan cara khusus
mengatakan 80 bit berturut-turut.

1616
01:20:44,750 --> 01:20:47,950
>> Jadi A-- ini adalah nomor 97 recall.

1617
01:20:47,950 --> 01:20:51,770
Jadi beberapa pola dari 8 bit
mewakili angka desimal 97.

1618
01:20:51,770 --> 01:20:58,070
backslash ini 0 secara harfiah nomor
0, alias nul, N-U-L, tidak seperti sebelumnya,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, yang kita bicarakan.

1620
01:20:59,630 --> 01:21:05,700
Tapi untuk saat ini, hanya tahu bahwa ini
backslash 0 hanya 80 bit berturut-turut.

1621
01:21:05,700 --> 01:21:09,810
>> Dan itu hanya baris ini di
pasir yang mengatakan apa-apa ke kiri

1622
01:21:09,810 --> 01:21:12,610
milik satu string, atau satu jenis data.

1623
01:21:12,610 --> 01:21:15,480
Dan apa pun ke kanan
milik sesuatu yang lain.

1624
01:21:15,480 --> 01:21:17,440
Andi nama, sementara itu,
yang hanya secara visual

1625
01:21:17,440 --> 01:21:21,310
terjadi untuk membungkus ke jalur lain,
tapi itu hanya sebuah detil estetika,

1626
01:21:21,310 --> 01:21:23,990
sama adalah nul dihentikan.

1627
01:21:23,990 --> 01:21:29,290
>> Ini adalah string dari A-N-D-I karakter,
ditambah karakter rahasia kelima,

1628
01:21:29,290 --> 01:21:33,560
semua 0 bit, yang baru saja demarcates
akhir nama Andi juga.

1629
01:21:33,560 --> 01:21:37,120
Dan jika kita sebut mendapatkan string ketiga kalinya
di komputer untuk mendapatkan string seperti

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, sama adalah Maria
Nama nul diakhiri dengan garis miring terbalik 0.

1631
01:21:44,210 --> 01:21:47,170
>> Ini secara fundamental berbeda
dari bagaimana komputer akan biasanya

1632
01:21:47,170 --> 01:21:51,850
menyimpan integer, atau pelampung, atau lainnya
tipe data masih, karena ingat,

1633
01:21:51,850 --> 01:21:57,420
integer biasanya 32 bit, atau
4 byte, atau bahkan mungkin 64 bit,

1634
01:21:57,420 --> 01:21:59,100
atau delapan byte.

1635
01:21:59,100 --> 01:22:02,620
Tapi banyak primitif di komputer
dalam bahasa pemrograman

1636
01:22:02,620 --> 01:22:05,550
memiliki jumlah tetap
byte bawah hood-- yang

1637
01:22:05,550 --> 01:22:08,100
mungkin 1, mungkin 2, mungkin 4, mungkin 8.

1638
01:22:08,100 --> 01:22:13,250
>> Tapi string, dengan desain, memiliki
Jumlah dinamis karakter.

1639
01:22:13,250 --> 01:22:16,980
Anda tidak tahu sebelumnya, sampai
jenis manusia di Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
atau M-A-R-I-A, atau A-N-D-I. Anda tidak tahu
berapa kali pengguna akan memukul

1641
01:22:21,400 --> 01:22:22,070
keyboard.

1642
01:22:22,070 --> 01:22:26,490
Oleh karena itu, Anda tidak tahu bagaimana
banyak karakter di muka

1643
01:22:26,490 --> 01:22:27,540
Anda akan membutuhkan.

1644
01:22:27,540 --> 01:22:31,840
>> Dan C hanya jenis daun seperti
breadcrumb rahasia di bawah tenda

1645
01:22:31,840 --> 01:22:32,960
pada akhir string.

1646
01:22:32,960 --> 01:22:39,280
Setelah menyimpan Z-A-M-Y-L-A di memori,
itu juga hanya menempatkan setara

1647
01:22:39,280 --> 01:22:40,210
dari periode.

1648
01:22:40,210 --> 01:22:45,060
Pada akhir kalimat,
menempatkan 80 bit, sehingga

1649
01:22:45,060 --> 01:22:49,120
mengingat di mana
Zamyla dimulai dan berakhir.

1650
01:22:49,120 --> 01:22:51,490
>> Jadi apa sambungan,
kemudian, untuk program ini?

1651
01:22:51,490 --> 01:22:55,190
Program ini di sini, Stirling,
hanya mekanisme

1652
01:22:55,190 --> 01:22:57,970
untuk mendapatkan string
dari pengguna, baris 6.

1653
01:22:57,970 --> 01:23:01,160
Baris 7, saya menyatakan variabel
disebut n dan set sama dengan 0.

1654
01:23:01,160 --> 01:23:08,680
>> Dan kemudian sejalan 8, saya hanya bertanya
pertanyaan, sementara karakter n-th tidak

1655
01:23:08,680 --> 01:23:12,120
tidak sama semua 0 bits--
dengan kata lain, tidak

1656
01:23:12,120 --> 01:23:14,500
sama khusus ini
karakter, backslash 0, yang

1657
01:23:14,500 --> 01:23:18,470
Hanya saja character-- nul khusus
pergi ke depan dan hanya selisih n.

1658
01:23:18,470 --> 01:23:21,460
>> Dan terus melakukan itu, dan tetap
melakukannya, dan terus melakukannya.

1659
01:23:21,460 --> 01:23:23,430
Dan jadi meskipun di
masa lalu kami telah digunakan i,

1660
01:23:23,430 --> 01:23:25,181
itu baik-baik saja
semantik menggunakan n,

1661
01:23:25,181 --> 01:23:27,430
jika Anda hanya mencoba untuk
menghitung waktu ini sengaja,

1662
01:23:27,430 --> 01:23:28,720
dan hanya ingin menyebutnya n.

1663
01:23:28,720 --> 01:23:34,720
Jadi ini hanya terus mengajukan pertanyaan,
adalah karakter ke-n dari s semua 0s?

1664
01:23:34,720 --> 01:23:38,470
Jika tidak, melihat ke tampilan berikutnya,
melihat ke depan, melihat ke depan,

1665
01:23:38,470 --> 01:23:39,460
melihat ke depan.

1666
01:23:39,460 --> 01:23:45,540
>> Tapi segera setelah Anda melihat backslash 0,
baris loop-- ini 9 sampai 11-- berhenti.

1667
01:23:45,540 --> 01:23:49,640
Anda keluar dari loop sementara,
meninggalkan dalam variabel n

1668
01:23:49,640 --> 01:23:54,530
jumlah total semua
karakter dalam string Anda melihat,

1669
01:23:54,530 --> 01:23:55,660
sehingga pencetakan itu.

1670
01:23:55,660 --> 01:23:56,760
Jadi mari kita coba ini.

1671
01:23:56,760 --> 01:23:59,500
>> Biarkan aku pergi ke depan dan, tanpa
menggunakan fungsi stirling,

1672
01:23:59,500 --> 01:24:04,240
tetapi hanya menggunakan versi homegrown saya sendiri
di sini disebut stirling, biarkan aku pergi ke depan

1673
01:24:04,240 --> 01:24:07,700
dan menjalankan stirling, ketik sesuatu
seperti Zamyla, yang saya tahu sebelumnya

1674
01:24:07,700 --> 01:24:08,670
adalah enam karakter.

1675
01:24:08,670 --> 01:24:10,080
Mari kita lihat apakah ia bekerja.

1676
01:24:10,080 --> 01:24:10,920
Memang, itu enam.

1677
01:24:10,920 --> 01:24:15,257
Mari kita coba dengan Rob, tiga karakter,
tiga karakter sekaligus, dan sebagainya.

1678
01:24:15,257 --> 01:24:17,340
Jadi itu semua yang terjadi
di bawah kap mesin.

1679
01:24:17,340 --> 01:24:19,548
Dan perhatikan koneksi,
kemudian, dengan minggu pertama

1680
01:24:19,548 --> 01:24:22,370
kelas, di mana kita berbicara tentang
sesuatu seperti abstraksi,

1681
01:24:22,370 --> 01:24:26,960
yang hanya layering ini ide, atau
kompleksitas, di atas prinsip-prinsip dasar.

1682
01:24:26,960 --> 01:24:30,710
Di sini, kita semacam melihat
di bawah kap stirling,

1683
01:24:30,710 --> 01:24:33,510
sehingga untuk berbicara, untuk mencari tahu,
bagaimana hal itu akan dilaksanakan?

1684
01:24:33,510 --> 01:24:35,232
>> Dan kita bisa menerapkan kembali diri kita sendiri.

1685
01:24:35,232 --> 01:24:37,440
Tapi kami tidak pernah lagi akan
untuk kembali melaksanakan stirling.

1686
01:24:37,440 --> 01:24:39,780
Kami hanya akan
menggunakan stirling dalam rangka

1687
01:24:39,780 --> 01:24:42,100
untuk benar-benar mendapatkan beberapa string panjang.

1688
01:24:42,100 --> 01:24:44,200
>> Tapi tidak ada sihir
di bawah tenda.

1689
01:24:44,200 --> 01:24:46,716
Jika Anda tahu bahwa di balik
kap, string

1690
01:24:46,716 --> 01:24:48,090
hanya urutan karakter.

1691
01:24:48,090 --> 01:24:51,090
Dan bahwa urutan karakter
semua bisa numerik ditangani

1692
01:24:51,090 --> 01:24:53,330
dengan braket 0, braket
1, braket 2, dan Anda

1693
01:24:53,330 --> 01:24:57,420
tahu bahwa di akhir string adalah
karakter khusus, Anda dapat mencari tahu

1694
01:24:57,420 --> 01:25:01,710
bagaimana melakukan apa yang paling dalam
Program, karena semua itu bermuara

1695
01:25:01,710 --> 01:25:03,400
adalah membaca dan menulis memori.

1696
01:25:03,400 --> 01:25:06,130
Artinya, berubah dan mencari
di memori, atau memindahkan barang

1697
01:25:06,130 --> 01:25:10,940
di dalam memori, hal pencetakan
pada layar, dan sebagainya.

1698
01:25:10,940 --> 01:25:14,800
>> Jadi mari kita sekarang menggunakan baru ditemukan ini
pemahaman tentang apa senar sebenarnya

1699
01:25:14,800 --> 01:25:17,910
yang di bawah kap mesin, dan
mengupas satu lapisan lainnya

1700
01:25:17,910 --> 01:25:20,080
yang sampai sekarang kita sudah
telah mengabaikan sama sekali.

1701
01:25:20,080 --> 01:25:22,650
Secara khusus, setiap saat
kami telah menerapkan program,

1702
01:25:22,650 --> 01:25:25,930
kami sudah baris kode ini
dekat bagian atas menyatakan utama.

1703
01:25:25,930 --> 01:25:27,810
Dan kita sudah ditentukan void main int.

1704
01:25:27,810 --> 01:25:31,240
>> Dan kekosongan di dalam kurung
memiliki telah mengatakan selama ini yang utama

1705
01:25:31,240 --> 01:25:33,440
itu sendiri tidak mengambil argumen.

1706
01:25:33,440 --> 01:25:36,210
Input yang utama adalah
akan mendapatkan dari pengguna

1707
01:25:36,210 --> 01:25:39,020
harus datang dari beberapa lainnya
mekanisme, seperti get int,

1708
01:25:39,020 --> 01:25:42,040
atau mendapatkan float, atau mendapatkan string,
atau beberapa fungsi lainnya.

1709
01:25:42,040 --> 01:25:44,710
Tapi ternyata
ketika Anda menulis sebuah program,

1710
01:25:44,710 --> 01:25:47,690
Anda benar-benar dapat menentukan
bahwa program ini akan

1711
01:25:47,690 --> 01:25:51,730
mengambil masukan dari manusia
pada baris perintah itu sendiri.

1712
01:25:51,730 --> 01:25:56,310
>> Dengan kata lain, meskipun kami sejauh ini
memiliki berjalan hanya ./hello halo

1713
01:25:56,310 --> 01:26:00,312
atau program serupa, semua
program lain yang kita sudah menggunakan,

1714
01:26:00,312 --> 01:26:02,770
bahwa kita sendiri tidak menulis,
memiliki telah mengambil, tampaknya,

1715
01:26:02,770 --> 01:26:05,210
baris perintah arguments--
hal-hal seperti make.

1716
01:26:05,210 --> 01:26:07,450
Anda mengatakan sesuatu seperti make,
dan kemudian kata kedua.

1717
01:26:07,450 --> 01:26:10,950
Atau dentang, Anda mengatakan berdentang, dan kemudian
kata kedua, nama file.

1718
01:26:10,950 --> 01:26:14,410
>> Atau bahkan RM atau CP, seperti yang mungkin Anda
telah melihat atau digunakan sudah

1719
01:26:14,410 --> 01:26:15,880
untuk menghapus atau menyalin file.

1720
01:26:15,880 --> 01:26:18,920
Semua dari mereka mengambil apa yang disebut
baris perintah arguments--

1721
01:26:18,920 --> 01:26:21,130
kata tambahan pada prompt terminal.

1722
01:26:21,130 --> 01:26:23,260
Tapi sampai sekarang, kami
sendiri belum memiliki

1723
01:26:23,260 --> 01:26:27,080
mewah ini mengambil masukan dari
pengguna ketika dia benar-benar berjalan

1724
01:26:27,080 --> 01:26:29,120
program itu sendiri pada baris perintah.

1725
01:26:29,120 --> 01:26:33,710
>> Tapi kita bisa melakukannya dengan ulang menyatakan
utama bergerak maju, tidak memiliki

1726
01:26:33,710 --> 01:26:36,750
membatalkan dalam tanda kurung,
tapi dua argumen ini

1727
01:26:36,750 --> 01:26:40,600
instead-- pertama integer,
dan yang kedua sesuatu

1728
01:26:40,600 --> 01:26:44,170
baru, sesuatu yang kita akan memanggil
array, sesuatu yang sama dalam semangat

1729
01:26:44,170 --> 01:26:49,220
untuk apa yang kita lihat di Scratch sebagai daftar, tapi
array string, seperti yang kita segera akan melihat.

1730
01:26:49,220 --> 01:26:51,790
Tapi mari kita melihat ini dengan
cara contoh, sebelum kita

1731
01:26:51,790 --> 01:26:53,690
membedakan persis apa artinya.

1732
01:26:53,690 --> 01:26:56,520
>> Jadi jika saya pergi ke CS50 IDE
di sini, saya telah pergi ke depan

1733
01:26:56,520 --> 01:27:01,840
dan menyatakan dalam sebuah file yang bernama
argv0.c template berikut.

1734
01:27:01,840 --> 01:27:04,120
Dan melihat satu-satunya hal yang
yang berbeda sejauh

1735
01:27:04,120 --> 01:27:08,570
adalah bahwa saya telah berubah batal ke int
argc tali argv braket terbuka, dekat

1736
01:27:08,570 --> 01:27:09,070
mengurung.

1737
01:27:09,070 --> 01:27:11,730
Dan melihat untuk saat ini, ada
tidak ada di dalam kurung tersebut.

1738
01:27:11,730 --> 01:27:12,620
>> Tidak ada nomor.

1739
01:27:12,620 --> 01:27:15,070
Dan tidak ada i, atau
n, atau surat lainnya.

1740
01:27:15,070 --> 01:27:17,010
Aku hanya menggunakan
kurung persegi untuk sekarang,

1741
01:27:17,010 --> 01:27:19,510
untuk alasan kami akan datang
kembali ke hanya dalam beberapa saat.

1742
01:27:19,510 --> 01:27:21,330
>> Dan sekarang apa yang akan saya lakukan adalah ini.

1743
01:27:21,330 --> 01:27:26,680
Jika argc sama sama 2--
dan ingat bahwa sama equals

1744
01:27:26,680 --> 01:27:30,040
adalah operator kesetaraan membandingkan
kiri dan kanan untuk kesetaraan.

1745
01:27:30,040 --> 01:27:31,790
Ini bukan tugas
operator, yang

1746
01:27:31,790 --> 01:27:36,510
single sama tanda, yang berarti copy
dari kanan ke kiri beberapa nilai.

1747
01:27:36,510 --> 01:27:42,840
>> Jika argc sama sama dengan 2, saya ingin
katakanlah, printf, halo, persen, baris baru,

1748
01:27:42,840 --> 01:27:47,340
dan kemudian pasang in-- dan inilah baru
trick-- argv bracket 1, karena alasan

1749
01:27:47,340 --> 01:27:48,840
bahwa kita akan kembali ke dalam sekejap.

1750
01:27:48,840 --> 01:27:52,110
Lain jika argc tidak
sama 2, Anda tahu apa?

1751
01:27:52,110 --> 01:27:57,400
Mari kita pergi ke depan dan, seperti biasa, cetak
keluar halo dunia tanpa substitusi.

1752
01:27:57,400 --> 01:28:02,710
>> Sehingga akan tampak bahwa jika argc, yang
singkatan jumlah argumen, sama dengan 2,

1753
01:28:02,710 --> 01:28:04,740
Aku akan mencetak
halo sesuatu atau lainnya.

1754
01:28:04,740 --> 01:28:07,560
Jika tidak, secara default, saya
akan mencetak hello world.

1755
01:28:07,560 --> 01:28:08,770
Jadi apa artinya ini?

1756
01:28:08,770 --> 01:28:15,550
>> Nah, biarkan aku pergi ke depan dan menyimpan
file ini, dan kemudian melakukan membuat argv0,

1757
01:28:15,550 --> 01:28:18,940
dan kemudian ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Dan menyapa dunia.

1759
01:28:20,300 --> 01:28:21,260
Sekarang, kenapa begitu?

1760
01:28:21,260 --> 01:28:24,730
>> Nah, ternyata kapan saja Anda
menjalankan program pada baris perintah,

1761
01:28:24,730 --> 01:28:29,570
Anda mengisi apa yang kami akan
umumnya memanggil vektor argumen.

1762
01:28:29,570 --> 01:28:33,100
Dengan kata lain, secara otomatis
komputer, sistem operasi,

1763
01:28:33,100 --> 01:28:38,340
akan menyerahkan ke program Anda
sendiri daftar semua kata

1764
01:28:38,340 --> 01:28:40,850
bahwa manusia diketik di
prompt, dalam kasus Anda

1765
01:28:40,850 --> 01:28:43,790
programmer ingin melakukan
sesuatu dengan informasi tersebut.

1766
01:28:43,790 --> 01:28:48,540
Dan dalam hal ini, satu-satunya kata
Aku sudah diketik pada prompt adalah ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Dan jumlah argumen yang
dilewatkan ke program saya adalah salah satu.

1768
01:28:55,420 --> 01:28:58,880
Dengan kata lain, argumen
menghitung, atau dikenal sebagai argc

1769
01:28:58,880 --> 01:29:00,970
di sini sebagai integer, hanya satu.

1770
01:29:00,970 --> 01:29:03,000
Salah, tentu saja, tidak sama dua.

1771
01:29:03,000 --> 01:29:05,980
Dan jadi ini adalah apa yang mencetak, halo dunia.

1772
01:29:05,980 --> 01:29:08,170
>> Tapi biarkan aku mengambil tempat ini.

1773
01:29:08,170 --> 01:29:09,930
Saya katakan, argv0.

1774
01:29:09,930 --> 01:29:12,740
Dan kemudian bagaimana Maria?

1775
01:29:12,740 --> 01:29:14,990
Dan kemudian tekan Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Dan perhatikan apa yang ajaib yang terjadi di sini.

1777
01:29:18,020 --> 01:29:22,640
Sekarang, bukannya dunia Halo, aku punya
mengubah perilaku program ini

1778
01:29:22,640 --> 01:29:26,310
dengan mengambil input tidak dari get
string atau beberapa fungsi lainnya,

1779
01:29:26,310 --> 01:29:30,570
tapi dari, tampaknya, perintah saya
itu sendiri, apa yang awalnya saya mengetik di.

1780
01:29:30,570 --> 01:29:35,720
Dan saya bisa memainkan permainan ini lagi oleh
mengubahnya ke Stelios, misalnya.

1781
01:29:35,720 --> 01:29:38,400
>> Dan sekarang saya melihat nama lain masih.

1782
01:29:38,400 --> 01:29:40,540
Dan di sini, saya mungkin mengatakan Andi.

1783
01:29:40,540 --> 01:29:42,137
Dan saya mungkin mengatakan Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Dan kita bisa memainkan permainan ini sepanjang hari,
hanya mencolokkan nilai yang berbeda,

1785
01:29:45,220 --> 01:29:49,550
selama aku memberikan persis
dua kata pada prompt,

1786
01:29:49,550 --> 01:29:52,260
sehingga argc, menghitung argumen saya, adalah 2.

1787
01:29:52,260 --> 01:29:57,240
>> Apakah saya melihat bahwa nama dicolokkan ke
printf, per kondisi ini di sini?

1788
01:29:57,240 --> 01:30:00,550
Jadi kita tampaknya memiliki sekarang
kemampuan ekspresif

1789
01:30:00,550 --> 01:30:04,410
mengambil masukan dari mekanisme lain,
dari apa yang disebut baris perintah,

1790
01:30:04,410 --> 01:30:07,000
daripada harus menunggu
sampai pengguna menjalankan program,

1791
01:30:07,000 --> 01:30:10,220
dan kemudian meminta dia
menggunakan sesuatu seperti get tali.

1792
01:30:10,220 --> 01:30:11,230
>> Jadi apa ini?

1793
01:30:11,230 --> 01:30:15,010
Argc, sekali lagi, hanya sebuah integer,
jumlah words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
bahwa pengguna disediakan di
prompt, di jendela terminal,

1795
01:30:18,540 --> 01:30:20,110
termasuk nama program.

1796
01:30:20,110 --> 01:30:23,340
Jadi ./argv0 kami, efektif,
nama program,

1797
01:30:23,340 --> 01:30:24,520
atau bagaimana saya menjalankan program.

1798
01:30:24,520 --> 01:30:25,810
>> Yang dianggap sebagai sebuah kata.

1799
01:30:25,810 --> 01:30:27,080
Jadi argc akan 1.

1800
01:30:27,080 --> 01:30:29,750
Tapi ketika saya menulis Stelios, atau
Andi, atau Zamyla, atau Maria,

1801
01:30:29,750 --> 01:30:31,660
itu berarti jumlah argumen adalah dua.

1802
01:30:31,660 --> 01:30:33,910
Dan sekarang ada dua kata yang disahkan pada.

1803
01:30:33,910 --> 01:30:36,070
>> Dan pemberitahuan, kita bisa melanjutkan logika ini.

1804
01:30:36,070 --> 01:30:39,050
Jika saya benar-benar mengatakan
sesuatu seperti Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
nama lengkap, sehingga lewat
tiga argumen di total,

1806
01:30:42,200 --> 01:30:47,410
sekarang ia mengatakan default lagi,
karena, tentu saja, 3 tidak sama dengan 2.

1807
01:30:47,410 --> 01:30:54,080
>> Dan dengan cara ini, apakah saya harus
Akses melalui argv argumen baru ini

1808
01:30:54,080 --> 01:30:56,080
bahwa kita bisa secara teknis
sebut apa pun yang kita inginkan.

1809
01:30:56,080 --> 01:30:58,940
Tapi dengan konvensi, itu
argv dan argc, masing-masing.

1810
01:30:58,940 --> 01:31:04,470
Argv, vektor argumen, adalah jenis
dari sinonim untuk pemrograman

1811
01:31:04,470 --> 01:31:07,140
fitur di C disebut array.

1812
01:31:07,140 --> 01:31:14,410
>> Array adalah daftar nilai yang sama
kembali, ke belakang, ke belakang, ke belakang.

1813
01:31:14,410 --> 01:31:17,810
Dengan kata lain, jika salah satu ada di sini di
RAM, yang berikutnya adalah tepat di sebelah itu,

1814
01:31:17,810 --> 01:31:18,800
dan di sebelahnya.

1815
01:31:18,800 --> 01:31:20,101
Mereka tidak di semua tempat.

1816
01:31:20,101 --> 01:31:23,100
Dan bahwa skenario terakhir, di mana hal-hal
adalah seluruh tempat di memori,

1817
01:31:23,100 --> 01:31:25,082
benar-benar dapat menjadi fitur yang kuat.

1818
01:31:25,082 --> 01:31:28,040
Tapi kita akan kembali ke bahwa ketika kita
berbicara tentang struktur data yang lebih menarik.

1819
01:31:28,040 --> 01:31:32,260
Untuk saat ini, sebuah array hanya
sepotong memori yang berdekatan,

1820
01:31:32,260 --> 01:31:36,520
masing-masing yang elemennya
kembali, ke belakang, ke belakang, ke belakang,

1821
01:31:36,520 --> 01:31:38,050
dan umumnya jenis yang sama.

1822
01:31:38,050 --> 01:31:42,630
>> Jadi jika Anda berpikir tentang, dari
saat yang lalu, apa adalah string?

1823
01:31:42,630 --> 01:31:50,460
Nah, string, seperti Zamyla,
Z-A-M-Y-L-A, adalah, secara teknis,

1824
01:31:50,460 --> 01:31:51,400
hanya sebuah array.

1825
01:31:51,400 --> 01:31:53,700
Ini sebuah array karakter.

1826
01:31:53,700 --> 01:31:59,250
>> Dan jadi jika kita benar-benar menarik ini, karena saya
lakukan sebelumnya, sebagai sepotong memori,

1827
01:31:59,250 --> 01:32:04,510
ternyata masing-masing
karakter memakan byte.

1828
01:32:04,510 --> 01:32:07,630
Dan kemudian ada yang istimewa
karakter sentinel, backslash 0,

1829
01:32:07,630 --> 01:32:12,360
atau semua delapan 0 bit, yang
demarcates akhir string.

1830
01:32:12,360 --> 01:32:15,090
Jadi string, ternyata
out, mengutip tali tanda kutip,

1831
01:32:15,090 --> 01:32:20,580
hanya sebuah array chara--
char di menjadi tipe data yang sebenarnya.

1832
01:32:20,580 --> 01:32:24,560
>> Dan sekarang argv, meanwhile--
mari kita kembali ke program.

1833
01:32:24,560 --> 01:32:29,582
Argv, meskipun kita melihat kata
String di sini, bukan string itu sendiri.

1834
01:32:29,582 --> 01:32:33,640
Argv, vektor argumen,
adalah array dari string.

1835
01:32:33,640 --> 01:32:37,620
>> Jadi hanya karena Anda dapat memiliki sebuah array
karakter, Anda dapat memiliki tingkat yang lebih tinggi,

1836
01:32:37,620 --> 01:32:46,279
array strings-- sehingga, misalnya,
ketika saya mengetik beberapa saat yang lalu ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, ruang Z-A-M-Y-L-A, saya menyatakan bahwa
argv memiliki dua string di ./argv0 itu--,

1838
01:33:00,150 --> 01:33:03,185
dan Z-A-M-Y-L-A. Di
Dengan kata lain, argc adalah 2.

1839
01:33:03,185 --> 01:33:03,980
Mengapa demikian?

1840
01:33:03,980 --> 01:33:08,370
>> Nah, efektif, apa yang terjadi
pada adalah bahwa masing-masing string ini

1841
01:33:08,370 --> 01:33:13,990
adalah, tentu saja, sebuah array karakter
seperti sebelumnya, masing-masing yang karakter

1842
01:33:13,990 --> 01:33:15,670
mengambil satu byte.

1843
01:33:15,670 --> 01:33:19,720
Dan tidak membingungkan sebenarnya 0
nama program dengan 0,

1844
01:33:19,720 --> 01:33:22,040
yang berarti semua 80 bit.

1845
01:33:22,040 --> 01:33:27,140
Dan Zamyla, sementara itu, masih
juga sebuah array karakter.

1846
01:33:27,140 --> 01:33:31,450
>> Jadi pada akhir hari, itu benar-benar
terlihat seperti ini di bawah tenda.

1847
01:33:31,450 --> 01:33:38,800
Tapi argv, dengan sifat bagaimana utama
karya, memungkinkan saya untuk membungkus semua ini

1848
01:33:38,800 --> 01:33:44,810
menjadi, jika Anda mau, array yang lebih besar
bahwa, jika kita sedikit lebih menyederhanakan

1849
01:33:44,810 --> 01:33:48,180
apa gambar terlihat seperti dan tidak
cukup menarik untuk skala di atas sana,

1850
01:33:48,180 --> 01:33:56,720
array ini hanya dari ukuran 2, yang pertama
unsur yang mengandung string,

1851
01:33:56,720 --> 01:33:59,230
elemen kedua dari
yang berisi string.

1852
01:33:59,230 --> 01:34:01,687
Dan, pada gilirannya, jika Anda
jenis memperbesar pada setiap

1853
01:34:01,687 --> 01:34:03,770
dari mereka string, apa yang Anda
lihat di bawah tenda

1854
01:34:03,770 --> 01:34:07,190
adalah bahwa setiap string hanya
array karakter.

1855
01:34:07,190 --> 01:34:11,680
>> Sekarang, seperti halnya dengan string,
kami mampu mendapatkan akses

1856
01:34:11,680 --> 01:34:15,260
dengan karakter ke-i dalam sebuah string
menggunakan yang notasi braket persegi.

1857
01:34:15,260 --> 01:34:17,320
Demikian pula, dengan array
secara umum, kita bisa

1858
01:34:17,320 --> 01:34:22,700
menggunakan notasi braket persegi untuk mendapatkan
di sejumlah string dalam array?

1859
01:34:22,700 --> 01:34:25,100
Misalnya, biarkan aku
pergi ke depan dan melakukan hal ini.

1860
01:34:25,100 --> 01:34:32,420
>> Biarkan aku pergi ke depan dan menciptakan argv1.c,
yang sedikit berbeda kali ini.

1861
01:34:32,420 --> 01:34:35,635
Alih-alih memeriksa argc2,
Aku akan sebaliknya melakukan hal ini.

1862
01:34:35,635 --> 01:34:41,270
Untuk int saya mendapatkan 0, saya kurang
dari argc, aku plus plus,

1863
01:34:41,270 --> 01:34:47,920
dan kemudian mencetak dalam ini,
persen s, baris baru, dan kemudian

1864
01:34:47,920 --> 01:34:50,740
argv braket i.

1865
01:34:50,740 --> 01:34:55,220
>> Jadi dengan kata lain, saya tidak berurusan dengan
karakter individu pada saat ini.

1866
01:34:55,220 --> 01:35:00,190
Argv, seperti yang tersirat oleh ini persegi kosong
kawat gigi di sebelah kanan nama argv,

1867
01:35:00,190 --> 01:35:03,320
berarti argv adalah array dari string.

1868
01:35:03,320 --> 01:35:04,870
Dan argc hanya sebuah int.

1869
01:35:04,870 --> 01:35:08,800
>> baris ini di sini, 6, adalah
mengatakan set i sama dengan 0.

1870
01:35:08,800 --> 01:35:11,980
Menghitung semua jalan sampai ke,
tetapi tidak termasuk, argc.

1871
01:35:11,980 --> 01:35:14,010
Dan kemudian pada setiap iterasi,
mencetak string.

1872
01:35:14,010 --> 01:35:14,800
Apa tali?

1873
01:35:14,800 --> 01:35:17,270
>> I-th string dalam argv.

1874
01:35:17,270 --> 01:35:19,530
Jadi padahal sebelumnya saya
menggunakan braket persegi

1875
01:35:19,530 --> 01:35:22,180
notasi untuk mendapatkan engan
karakter dalam sebuah string, sekarang

1876
01:35:22,180 --> 01:35:27,240
Saya menggunakan notasi braket persegi
untuk mendapatkan string engan dalam array.

1877
01:35:27,240 --> 01:35:30,310
Jadi itu semacam satu lapisan
di atas, secara konseptual.

1878
01:35:30,310 --> 01:35:35,390
>> Dan jadi apa yang rapi tentang ini
Program sekarang, jika saya kompilasi argv1,

1879
01:35:35,390 --> 01:35:42,067
dan kemudian melakukan ./argv1, dan kemudian ketik
dalam sesuatu seperti foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
yang merupakan tiga kata bawaan bahwa
ilmuwan komputer meraih setiap saat

1881
01:35:45,400 --> 01:35:51,010
ia membutuhkan beberapa kata placeholder,
dan tekan Enter, setiap kata-kata,

1882
01:35:51,010 --> 01:35:54,980
termasuk nama program, yang
dalam argv di lokasi pertama,

1883
01:35:54,980 --> 01:35:58,320
akhirnya dicetak satu per satu.

1884
01:35:58,320 --> 01:36:05,290
Dan jika saya mengubah ini, dan saya katakan
sesuatu seperti argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
kita mendapatkan semua tiga dari mereka
kata-kata, yang argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, karena dalam hal ini
Kasus argc, menghitung, adalah 3.

1887
01:36:14,400 --> 01:36:20,020
>> Tapi apa yang rapi adalah jika Anda memahami
yang argv hanya sebuah array dari string,

1888
01:36:20,020 --> 01:36:24,910
dan Anda memahami bahwa string
adalah array dari karakter,

1889
01:36:24,910 --> 01:36:29,470
kita bisa benar-benar jenis menggunakan ini
notasi braket persegi beberapa kali

1890
01:36:29,470 --> 01:36:33,320
untuk memilih string, dan kemudian pilih
karakter dalam string,

1891
01:36:33,320 --> 01:36:35,730
diving lebih dalam sebagai berikut.

1892
01:36:35,730 --> 01:36:40,100
Dalam contoh ini, biarkan aku pergi
depan dan memanggil argv2.c ini.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Dan dalam contoh ini, biarkan aku pergi ke depan
dan melakukan following-- untuk int saya mendapatkan 0,

1895
01:36:50,180 --> 01:36:53,286
i kurang dari argc, i ditambah
ditambah, seperti sebelumnya.

1896
01:36:53,286 --> 01:36:55,910
Jadi di words-- lainnya dan sekarang ini
mendapatkan cukup rumit.

1897
01:36:55,910 --> 01:36:59,940
Lalu aku akan mengatakan
iterate atas string di argv,

1898
01:36:59,940 --> 01:37:01,294
sebagai komentar untuk diriku sendiri.

1899
01:37:01,294 --> 01:37:03,960
Dan kemudian aku akan memiliki
bersarang untuk loop, yang Anda mungkin

1900
01:37:03,960 --> 01:37:06,290
telah dilakukan, atau dianggap
melakukan, di Scratch, di mana

1901
01:37:06,290 --> 01:37:08,600
Aku akan mengatakan int-- saya
tidak akan menggunakan i lagi,

1902
01:37:08,600 --> 01:37:12,590
karena saya tidak ingin bayangan, atau
semacam menimpa saya yang ada.

1903
01:37:12,590 --> 01:37:15,780
>> Aku akan, sebaliknya, mengatakan j, karena
itu saya pergi ke variabel setelah saya,

1904
01:37:15,780 --> 01:37:18,590
ketika Aku hanya berusaha untuk
menghitung angka sederhana.

1905
01:37:18,590 --> 01:37:28,850
Untuk j mendapat 0-- dan juga, n, akan
mendapatkan panjang buritan argv braket i,

1906
01:37:28,850 --> 01:37:36,030
asalkan j kurang dari m,
j plus plus, lakukan langkah berikut.

1907
01:37:36,030 --> 01:37:37,500
Dan inilah bagian yang menarik.

1908
01:37:37,500 --> 01:37:46,330
>> Mencetak karakter dan baris baru,
mencolokkan argv bracket i, braket j.

1909
01:37:46,330 --> 01:37:47,940
OK, jadi biar menambahkan beberapa komentar di sini.

1910
01:37:47,940 --> 01:37:54,820
Iterate atas karakter
dalam string saat ini,

1911
01:37:54,820 --> 01:38:02,290
print-j karakter dalam i-th tali.

1912
01:38:02,290 --> 01:38:04,630
Jadi sekarang, mari kita pertimbangkan
apa komentar ini berarti.

1913
01:38:04,630 --> 01:38:06,750
>> Iterate atas senar
di argv-- berapa banyak

1914
01:38:06,750 --> 01:38:09,300
string dalam argv, yang merupakan array?

1915
01:38:09,300 --> 01:38:13,420
Argc banyak, jadi aku iterasi
dari i sama 0 sampai argc.

1916
01:38:13,420 --> 01:38:20,020
Sementara itu, berapa banyak karakter
berada di string-i di argv?

1917
01:38:20,020 --> 01:38:22,880
>> Nah, untuk mendapatkan jawaban itu,
Aku hanya memanggil panjang string

1918
01:38:22,880 --> 01:38:26,810
pada string saat perawatan saya
tentang, yang argv braket i.

1919
01:38:26,810 --> 01:38:30,090
Dan aku akan menyimpan sementara yang
nilai n, hanya untuk tujuan caching,

1920
01:38:30,090 --> 01:38:31,590
mengingatnya untuk efisiensi.

1921
01:38:31,590 --> 01:38:36,330
Dan kemudian aku akan menginisialisasi j ke 0,
terus selama j kurang dari n,

1922
01:38:36,330 --> 01:38:38,430
dan pada setiap kenaikan iterasi j.

1923
01:38:38,430 --> 01:38:41,030
>> Dan kemudian di sini, per
komentar saya on line 12,

1924
01:38:41,030 --> 01:38:43,390
mencetak karakter,
diikuti oleh baris baru,

1925
01:38:43,390 --> 01:38:48,140
braket khusus argv
i memberi saya string ke-i

1926
01:38:48,140 --> 01:38:51,690
begitu kata pertama argv--, yang
Kata kedua, kata ketiga, apa pun.

1927
01:38:51,690 --> 01:38:57,370
Dan kemudian menyelam j lebih dalam, dan mendapat
saya karakter-j dari kata itu.

1928
01:38:57,370 --> 01:39:02,200
Dan, pada dasarnya, Anda dapat mengobati
argv sebagai multi-dimensi,

1929
01:39:02,200 --> 01:39:06,050
sebagai dua dimensi, array,
dimana setiap kata jenis terlihat

1930
01:39:06,050 --> 01:39:08,580
seperti ini dalam pikiran Anda
mata, dan setiap karakter

1931
01:39:08,580 --> 01:39:10,930
adalah jenis terdiri di
kolom, jika yang membantu.

1932
01:39:10,930 --> 01:39:13,260
>> Pada kenyataannya, ketika kita menggoda
ini selain di minggu depan,

1933
01:39:13,260 --> 01:39:15,580
itu akan menjadi sedikit
lebih canggih dari itu.

1934
01:39:15,580 --> 01:39:17,800
Tapi Anda benar-benar bisa
memikirkan bahwa, untuk saat ini,

1935
01:39:17,800 --> 01:39:22,110
sebagai hanya ini dua dimensi
array, dimana satu tingkat dari itu

1936
01:39:22,110 --> 01:39:23,260
adalah semua string.

1937
01:39:23,260 --> 01:39:26,760
Dan kemudian jika Anda menyelam lebih dalam, Anda
bisa mendapatkan di karakter individu

1938
01:39:26,760 --> 01:39:29,600
atasnya dengan menggunakan notasi ini di sini.

1939
01:39:29,600 --> 01:39:31,620
>> Jadi apa efek bersih?

1940
01:39:31,620 --> 01:39:34,970
Biarkan aku pergi ke depan dan
membuat argv2-- sialan.

1941
01:39:34,970 --> 01:39:36,210
Saya membuat kesalahan di sini.

1942
01:39:36,210 --> 01:39:40,160
Secara implisit menyatakan
fungsi perpustakaan stirling.

1943
01:39:40,160 --> 01:39:42,190
Jadi selama ini, itu
mungkin tepat

1944
01:39:42,190 --> 01:39:45,130
bahwa kita semacam menyelesaikan
persis di mana kita mulai.

1945
01:39:45,130 --> 01:39:48,160
>> Aku kacau, secara implisit menyatakan
fungsi perpustakaan stirling.

1946
01:39:48,160 --> 01:39:48,987
OK tunggu sebentar.

1947
01:39:48,987 --> 01:39:51,070
Saya ingat bahwa, terutama
karena itu di sini.

1948
01:39:51,070 --> 01:39:54,490
Aku harus menyertakan string.h di
versi ini program.

1949
01:39:54,490 --> 01:40:00,050
>> Biarkan aku pergi ke depan dan mencakup
string.h, simpan itu, maju

1950
01:40:00,050 --> 01:40:04,460
dan mengkompilasi ulang argv2.

1951
01:40:04,460 --> 01:40:08,390
Dan sekarang, di sini kita pergi, membuat argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Dan meskipun itu sedikit
samar pada pandangan pertama,

1953
01:40:10,590 --> 01:40:15,690
melihat bahwa, memang, apa yang
dicetak adalah dot argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Tetapi jika saya ketik beberapa kata setelah
prompt, seperti argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Masukkan, juga sedikit
samar pada pandangan pertama.

1956
01:40:22,560 --> 01:40:30,540
Tetapi jika kita gulir kembali,
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Jadi kita sudah iterasi lebih dari setiap kata.

1958
01:40:32,190 --> 01:40:37,770
Dan, pada gilirannya, kami telah mengulangi lebih
setiap karakter dalam kata.

1959
01:40:37,770 --> 01:40:40,040
>> Sekarang, setelah semua ini,
menyadari bahwa ada

1960
01:40:40,040 --> 01:40:43,120
satu detail lain kita sudah baik
mengabaikan sepanjang waktu ini.

1961
01:40:43,120 --> 01:40:46,180
Kami hanya menggoda terpisah apa
input utama ini bisa?

1962
01:40:46,180 --> 01:40:47,780
Bagaimana keluaran utama ini?

1963
01:40:47,780 --> 01:40:50,540
>> Semua waktu ini, kami sudah
hanya menyalin dan menyisipkan

1964
01:40:50,540 --> 01:40:53,870
kata int di depan utama,
meskipun Anda mungkin melihat secara online,

1965
01:40:53,870 --> 01:40:58,340
terkadang salah dalam versi
C dan compiler, yang mereka katakan batal,

1966
01:40:58,340 --> 01:40:59,410
atau tidak sama sekali.

1967
01:40:59,410 --> 01:41:01,580
Tapi, memang, untuk versi
C yang kita gunakan,

1968
01:41:01,580 --> 01:41:06,180
C 11, atau 2011, menyadari
bahwa itu harus int.

1969
01:41:06,180 --> 01:41:09,300
Dan itu harus berupa
batal atau argc dan argv sini.

1970
01:41:09,300 --> 01:41:10,790
>> Tapi mengapa int main?

1971
01:41:10,790 --> 01:41:12,480
Apa itu benar-benar kembali?

1972
01:41:12,480 --> 01:41:16,280
Nah, ternyata semua waktu ini,
setiap kali Anda telah menulis sebuah program utama

1973
01:41:16,280 --> 01:41:18,440
selalu kembali sesuatu.

1974
01:41:18,440 --> 01:41:19,960
Tapi sudah melakukannya diam-diam.

1975
01:41:19,960 --> 01:41:23,350
>> sesuatu yang merupakan
int, sebagai garis 5 menyarankan.

1976
01:41:23,350 --> 01:41:24,225
Tapi int apa?

1977
01:41:24,225 --> 01:41:26,100
Nah, ada ini
konvensi dalam pemrograman,

1978
01:41:26,100 --> 01:41:29,790
dimana jika tidak ada memiliki
beres dan semuanya baik-baik,

1979
01:41:29,790 --> 01:41:34,250
program dan fungsi umum
return-- agak counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 umumnya menandakan semuanya baik-baik.

1982
01:41:38,070 --> 01:41:40,610
Jadi meskipun Anda memikirkan
sebagai palsu dalam banyak konteks,

1983
01:41:40,610 --> 01:41:42,930
sebenarnya umumnya berarti hal yang baik

1984
01:41:42,930 --> 01:41:49,560
>> Sementara itu, jika suatu program mengembalikan 1,
atau negatif 1, atau 5, atau negatif 42,

1985
01:41:49,560 --> 01:41:52,941
atau 0 non nilai,
yang umumnya menandakan

1986
01:41:52,941 --> 01:41:54,190
sesuatu yang tidak beres.

1987
01:41:54,190 --> 01:41:56,700
Bahkan, pada Mac sendiri atau PC,
Anda mungkin telah benar-benar melihat

1988
01:41:56,700 --> 01:42:01,050
pesan kesalahan, dimana itu
mengatakan sesuatu atau lainnya, kesalahan

1989
01:42:01,050 --> 01:42:04,940
Kode negatif 42, atau kesalahan kode
23, atau sesuatu seperti itu.

1990
01:42:04,940 --> 01:42:08,980
Angka itu umumnya hanya petunjuk
untuk programmer, atau perusahaan

1991
01:42:08,980 --> 01:42:11,174
yang membuat perangkat lunak,
apa yang salah dan mengapa,

1992
01:42:11,174 --> 01:42:13,590
sehingga mereka dapat melihat melalui
dokumentasi atau kode mereka,

1993
01:42:13,590 --> 01:42:15,465
dan mencari tahu apa yang
Kesalahan sebenarnya berarti.

1994
01:42:15,465 --> 01:42:18,400
Ini umumnya tidak
berguna bagi kita pengguna akhir.

1995
01:42:18,400 --> 01:42:20,550
>> Tapi ketika kembali utama 0, semuanya baik-baik.

1996
01:42:20,550 --> 01:42:23,770
Dan jika Anda tidak menentukan
apa yang utama harus kembali,

1997
01:42:23,770 --> 01:42:26,950
itu hanya akan otomatis
kembali 0 untuk Anda.

1998
01:42:26,950 --> 01:42:30,870
Tapi kembali sesuatu
lain benar-benar berguna.

1999
01:42:30,870 --> 01:42:34,660
>> Dalam program akhir ini, biarkan aku
pergi ke depan dan memanggil exit.c ini,

2000
01:42:34,660 --> 01:42:38,630
dan memperkenalkan terakhir hari ini
topik, yang dikenal sebagai kode kesalahan.

2001
01:42:38,630 --> 01:42:42,930
Biarkan aku pergi ke depan dan termasuk kami
file akrab di bagian atas, lakukan int main.

2002
01:42:42,930 --> 01:42:49,500
Dan kali ini, mari kita lakukan int argc,
tali argv, dan dengan kurung saya

2003
01:42:49,500 --> 01:42:50,836
menyiratkan bahwa itu dalam array.

2004
01:42:50,836 --> 01:42:52,460
Dan kemudian saya hanya melakukan cek kewarasan.

2005
01:42:52,460 --> 01:42:56,640
Kali ini, jika argc tidak
sama 2, maka Anda tahu apa?

2006
01:42:56,640 --> 01:42:57,520
Lupakan.

2007
01:42:57,520 --> 01:43:03,170
Saya akan mengatakan bahwa, hei, pengguna,
Anda kehilangan argumen baris perintah

2008
01:43:03,170 --> 01:43:04,210
n backslash.

2009
01:43:04,210 --> 01:43:05,230
>> Dan kemudian itu saja.

2010
01:43:05,230 --> 01:43:06,130
Aku ingin keluar.

2011
01:43:06,130 --> 01:43:11,030
Saya akan Terlebih Dahulu,
dan prematur benar, pulang

2012
01:43:11,030 --> 01:43:12,810
sesuatu yang lain dari nomor 1.

2013
01:43:12,810 --> 01:43:15,360
The pergi ke nilai untuk pertama
kesalahan yang dapat terjadi adalah 1.

2014
01:43:15,360 --> 01:43:17,860
Jika Anda memiliki beberapa lainnya yang keliru
Situasi yang mungkin terjadi,

2015
01:43:17,860 --> 01:43:21,390
Anda mungkin mengatakan pulang 2 atau kembali 3, atau
bahkan mungkin negatif 1 atau negatif 2.

2016
01:43:21,390 --> 01:43:23,750
>> Ini hanya kode keluar
yang, umumnya,

2017
01:43:23,750 --> 01:43:27,770
hanya berguna untuk programmer, atau
Perusahaan yang pengiriman perangkat lunak.

2018
01:43:27,770 --> 01:43:30,500
Tapi fakta bahwa itu
tidak 0 adalah apa yang penting.

2019
01:43:30,500 --> 01:43:34,310
Jadi jika dalam program ini, saya ingin
menjamin bahwa program ini hanya

2020
01:43:34,310 --> 01:43:38,190
bekerja jika pengguna memberikan saya
dengan jumlah argumen dari dua,

2021
01:43:38,190 --> 01:43:42,880
nama program, dan beberapa lainnya
kata, saya bisa menegakkan sebanyak sebagai berikut,

2022
01:43:42,880 --> 01:43:46,110
berteriak pada pengguna dengan printf mengatakan,
hilang argumen baris perintah,

2023
01:43:46,110 --> 01:43:46,970
kembali 1.

2024
01:43:46,970 --> 01:43:49,940
Itu hanya segera akan
keluar dari program.

2025
01:43:49,940 --> 01:43:55,840
>> Hanya jika argc sama 2 akan kita turun
di sini, di mana titik aku akan mengatakan,

2026
01:43:55,840 --> 01:44:00,410
halo persen s, backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Dengan kata lain, aku
tidak akan setelah argv 0,

2028
01:44:03,827 --> 01:44:05,410
yang hanya nama program.

2029
01:44:05,410 --> 01:44:09,450
Saya ingin mencetak Halo, koma,
kata kedua bahwa manusia diketik.

2030
01:44:09,450 --> 01:44:12,580
Dan dalam hal ini pada
baris 13, semuanya baik-baik.

2031
01:44:12,580 --> 01:44:15,920
>> Saya tahu bahwa argc adalah 2
logis dari program ini.

2032
01:44:15,920 --> 01:44:17,770
Aku akan pergi ke depan dan kembali 0.

2033
01:44:17,770 --> 01:44:21,230
Sebagai samping, perlu diingat bahwa
ini benar dalam Scratch juga.

2034
01:44:21,230 --> 01:44:24,760
>> Logikanya, aku bisa melakukan ini
dan merangkum garis-garis ini

2035
01:44:24,760 --> 01:44:27,020
kode di lain ini klausul sini.

2036
01:44:27,020 --> 01:44:29,420
Tapi itu semacam
tidak perlu indentasi kode saya.

2037
01:44:29,420 --> 01:44:31,800
Dan saya ingin membuat yang super
jelas bahwa tidak peduli apa,

2038
01:44:31,800 --> 01:44:34,670
secara default, halo
sesuatu yang akan bisa dicetak,

2039
01:44:34,670 --> 01:44:36,050
asalkan pengguna bekerja sama.

2040
01:44:36,050 --> 01:44:39,360
>> Sehingga sangat umum untuk menggunakan
kondisi, hanya jika,

2041
01:44:39,360 --> 01:44:41,870
untuk menangkap beberapa yang salah
situasi, dan kemudian keluar.

2042
01:44:41,870 --> 01:44:45,690
Dan kemudian, begitu lama semua adalah
baik, tidak memiliki lagi,

2043
01:44:45,690 --> 01:44:48,060
tetapi hanya memiliki kode
luar bahwa jika, karena itu

2044
01:44:48,060 --> 01:44:51,060
setara dalam hal ini
kasus tertentu, secara logis.

2045
01:44:51,060 --> 01:44:54,480
Jadi aku kembali 0, hanya untuk
eksplisit menandakan semuanya baik-baik.

2046
01:44:54,480 --> 01:44:58,480
>> Jika saya menghilangkan return 0, itu akan
secara otomatis diasumsikan bagi saya.

2047
01:44:58,480 --> 01:45:00,890
Tapi sekarang aku kembali
satu di setidaknya hal ini,

2048
01:45:00,890 --> 01:45:04,940
Aku akan, untuk mengukur baik dan
kejelasan, kembali 0 dalam kasus ini.

2049
01:45:04,940 --> 01:45:09,690
Jadi sekarang biarkan aku pergi ke depan dan membuat keluar,
yang merupakan Shalawat sempurna untuk hanya meninggalkan.

2050
01:45:09,690 --> 01:45:14,401
>> Tetapi membuat keluar, dan biarkan aku pergi
depan dan melakukan ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Dan program berteriak padaku,
hilang argumen baris perintah.

2052
01:45:16,900 --> 01:45:18,120
OK, saya bekerja sama.

2053
01:45:18,120 --> 01:45:23,810
>> Biarkan aku bukannya melakukan ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Dan sekarang ia mengatakan, halo David.

2055
01:45:25,190 --> 01:45:27,300
Dan Anda biasanya tidak akan melihat ini.

2056
01:45:27,300 --> 01:45:30,650
>> Tapi ternyata ada
cara khusus di Linux untuk benar-benar melihat

2057
01:45:30,650 --> 01:45:34,470
dengan apa kode keluar program keluar.

2058
01:45:34,470 --> 01:45:37,184
Kadang-kadang di grafis sebuah
dunia seperti Mac OS atau Windows,

2059
01:45:37,184 --> 01:45:40,100
Anda hanya melihat angka-angka ini ketika
pesan kesalahan muncul di layar

2060
01:45:40,100 --> 01:45:41,940
dan programmer
menunjukkan jumlah itu.

2061
01:45:41,940 --> 01:45:44,773
Tetapi jika kita ingin melihat apa kesalahan
Pesan, kita bisa melakukannya di sini-

2062
01:45:44,773 --> 01:45:48,100
sehingga ./exit, Masukkan, cetak
hilang argumen baris perintah.

2063
01:45:48,100 --> 01:45:54,590
>> Jika sekarang saya lakukan echo $ ?, yang
ridiculously samar tampak.

2064
01:45:54,590 --> 01:45:56,590
Tapi $?

2065
01:45:56,590 --> 01:45:59,220
adalah mantra ajaib
yang mengatakan, hei, komputer,

2066
01:45:59,220 --> 01:46:01,900
ceritakan apa yang sebelumnya
kode keluar program itu.

2067
01:46:01,900 --> 01:46:03,410
Dan saya tekan Enter.

2068
01:46:03,410 --> 01:46:07,520
Saya melihat 1, karena itulah yang saya
mengatakan fungsi utama saya untuk kembali.

2069
01:46:07,520 --> 01:46:12,310
>> Sementara itu, jika saya melakukan ./exit David,
dan tekan Enter, saya melihat, halo David.

2070
01:46:12,310 --> 01:46:16,800
Dan jika saya lakukan sekarang $ echo ?, saya melihat halo 0.

2071
01:46:16,800 --> 01:46:19,080
Dan jadi ini benar-benar akan
menjadi informasi yang berharga

2072
01:46:19,080 --> 01:46:23,420
dalam konteks debugger, tidak begitu
banyak yang Anda, manusia, akan peduli.

2073
01:46:23,420 --> 01:46:26,060
Tapi debugger dan lainnya
program kita akan menggunakan semester ini

2074
01:46:26,060 --> 01:46:29,420
akan sering melihat jumlah itu,
meskipun itu semacam tersembunyi

2075
01:46:29,420 --> 01:46:32,780
kecuali jika Anda mencarinya, untuk
menentukan apakah atau tidak program

2076
01:46:32,780 --> 01:46:37,050
eksekusi itu benar atau salah.

2077
01:46:37,050 --> 01:46:40,450
>> Dan itu membawa kita ke
ini, pada akhir hari.

2078
01:46:40,450 --> 01:46:43,917
Kami mulai hari ini dengan melihat
debugging, dan pada gilirannya di kursus

2079
01:46:43,917 --> 01:46:46,750
sendiri, dan kemudian lebih menarik,
teknis di bawah tenda

2080
01:46:46,750 --> 01:46:49,490
apa string, yang bertahan
minggu kami hanya mengambil untuk diberikan,

2081
01:46:49,490 --> 01:46:51,900
dan tentu saja membawa mereka
untuk diberikan di Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Kami kemudian melihat bagaimana kita dapat mengakses
karakter individu dalam sebuah string,

2083
01:46:56,040 --> 01:47:00,310
dan sekali lagi mengambil tingkat yang lebih tinggi
melihat hal-hal, melihat bagaimana well--

2084
01:47:00,310 --> 01:47:04,226
jika kita ingin mendapatkan individu
elemen dalam daftar seperti struktur,

2085
01:47:04,226 --> 01:47:05,850
kita tidak bisa melakukan itu dengan beberapa string?

2086
01:47:05,850 --> 01:47:08,050
Dan kita bisa dengan argumen baris perintah.

2087
01:47:08,050 --> 01:47:12,800
Tapi gambar ini di sini hanya kotak
adalah demonstratif dari ide umum ini

2088
01:47:12,800 --> 01:47:14,451
array, atau daftar, atau vektor.

2089
01:47:14,451 --> 01:47:16,450
Dan tergantung pada
konteks, semua kata-kata ini

2090
01:47:16,450 --> 01:47:17,880
berarti hal yang sedikit berbeda.

2091
01:47:17,880 --> 01:47:20,060
Jadi dalam C, kita hanya akan
untuk berbicara tentang array.

2092
01:47:20,060 --> 01:47:23,840
Dan sebuah array adalah sepotong
memori, yang masing-masing adalah

2093
01:47:23,840 --> 01:47:27,720
elemen yang berdekatan, kembali,
ke belakang, ke belakang, ke belakang.

2094
01:47:27,720 --> 01:47:31,970
>> Dan unsur-unsur yang, umumnya,
dari tipe data yang sama, karakter,

2095
01:47:31,970 --> 01:47:35,966
karakter, karakter, karakter, atau
string, string, string, string, atau int,

2096
01:47:35,966 --> 01:47:38,600
int, int, apa pun itu
kita mencoba untuk menyimpan.

2097
01:47:38,600 --> 01:47:42,540
Tetapi pada akhir hari, ini
seperti apa konseptual.

2098
01:47:42,540 --> 01:47:44,530
Anda mengambil Anda
memori komputer atau RAM.

2099
01:47:44,530 --> 01:47:48,590
Dan kau ukiran itu keluar ke
berukuran identik kotak, yang semuanya

2100
01:47:48,590 --> 01:47:50,920
kembali, ke belakang, ke
kembali, untuk kembali dengan cara ini.

2101
01:47:50,920 --> 01:47:53,200
>> Dan apa yang baik tentang
ide ini, dan fakta

2102
01:47:53,200 --> 01:47:58,580
bahwa kita dapat mengekspresikan nilai-nilai dengan cara ini
dengan yang pertama dari struktur data kami

2103
01:47:58,580 --> 01:48:02,520
di kelas, berarti kita dapat mulai
untuk memecahkan masalah dengan kode

2104
01:48:02,520 --> 01:48:04,079
yang datang begitu intuitif dalam seminggu 0.

2105
01:48:04,079 --> 01:48:05,870
Anda akan ingat telepon
buku contoh, di mana

2106
01:48:05,870 --> 01:48:09,110
kami menggunakan membagi dan menaklukkan,
atau algoritma pencarian biner,

2107
01:48:09,110 --> 01:48:13,220
untuk menyaring melalui keseluruhan
sekelompok nama dan nomor.

2108
01:48:13,220 --> 01:48:18,220
Tapi kita mengasumsikan, ingat, bahwa
buku telepon sudah diurutkan,

2109
01:48:18,220 --> 01:48:21,630
bahwa orang lain sudah
Figur out-- diberikan daftar nama

2110
01:48:21,630 --> 01:48:24,430
dan Numbers bagaimana diurut berdasarkan abjad.

2111
01:48:24,430 --> 01:48:26,950
Dan sekarang di C kita,
juga, memiliki kemampuan

2112
01:48:26,950 --> 01:48:30,290
untuk meletakkan hal-hal, tidak
fisik dalam buku telepon

2113
01:48:30,290 --> 01:48:34,220
tapi hampir di komputer
memori, kita akan mampu minggu depan

2114
01:48:34,220 --> 01:48:38,470
memperkenalkan lagi ini-- pertama
struktur data kami dalam array--

2115
01:48:38,470 --> 01:48:43,530
tetapi yang lebih penting, komputer yang sebenarnya
algoritma ilmu diimplementasikan

2116
01:48:43,530 --> 01:48:47,720
dalam kode, dengan mana kita dapat menyimpan
Data dalam struktur seperti ini,

2117
01:48:47,720 --> 01:48:50,730
dan kemudian mulai untuk memanipulasi itu, dan
untuk benar-benar memecahkan masalah dengan itu,

2118
01:48:50,730 --> 01:48:53,570
dan untuk membangun di atas itu,
akhirnya, program di C,

2119
01:48:53,570 --> 01:48:56,730
Python, dalam JavaScript,
query database dengan SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Dan kita akan melihat bahwa semua ini
ide yang berbeda interlock.

2121
01:48:59,980 --> 01:49:04,100
Tapi untuk saat ini, mengingat bahwa
domain yang kita diperkenalkan hari ini

2122
01:49:04,100 --> 01:49:06,920
adalah hal ini di sini, dan
dunia kriptografi.

2123
01:49:06,920 --> 01:49:11,200
Dan di antara masalah berikutnya Anda sendiri
akan memecahkan adalah seni kriptografi,

2124
01:49:11,200 --> 01:49:13,630
berebut dan de-scrambling
informasi, dan ciphering

2125
01:49:13,630 --> 01:49:15,930
dan mengartikan teks,
dan asumsi akhirnya

2126
01:49:15,930 --> 01:49:18,970
Anda sekarang tahu apa yang
adalah di bawah tenda

2127
01:49:18,970 --> 01:49:21,860
sehingga ketika Anda melihat atau menerima
pesan seperti ini, Anda

2128
01:49:21,860 --> 01:49:24,060
sendiri dapat memahaminya.

2129
01:49:24,060 --> 01:49:26,740
Semua ini, dan lebih banyak waktu berikutnya.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO PEMUTARAN]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Saja tiba.

2133
01:49:32,970 --> 01:49:35,146
Aku akan pergi mengunjungi
profesor perguruan tinggi.

2134
01:49:35,146 --> 01:49:37,611
Ya.

2135
01:49:37,611 --> 01:49:40,080
Hai.

2136
01:49:40,080 --> 01:49:40,660
Itu kamu.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Tunggu!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Aku hanya mencoba untuk mencari
tahu apa yang terjadi pada Anda.

2142
01:49:56,060 --> 01:49:58,130
Silakan, apa pun bisa membantu.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Anda kuliah
teman sekamar, yang Anda tidak?

2145
01:50:08,354 --> 01:50:10,770
Anda berada di sana dengan dia ketika
ia selesai proyek CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUSIC PLAYING]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Itu Adalah CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Saya menyukai tempat ini.

2152
01:50:44,770 --> 01:50:45,854
>> -Menelan.

2153
01:50:45,854 --> 01:50:47,020
Kita akan keluar dari bisnis.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END PEMUTARAN]

