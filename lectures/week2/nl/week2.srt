1
00:00:00,000 --> 00:00:02,970
>> [Muziek]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. MALAN: Oké.

4
00:00:15,700 --> 00:00:18,832
Dit is CS50 en deze
is het begin van week 2.

5
00:00:18,832 --> 00:00:21,040
En je zult zien dat meer dan herinneren
de afgelopen paar weken,

6
00:00:21,040 --> 00:00:24,490
we hebben de introductie van de computer
wetenschap en op zijn beurt de programmering.

7
00:00:24,490 --> 00:00:27,640
>> En we begonnen met het verhaal door middel van
Scratch, dat grafische taal

8
00:00:27,640 --> 00:00:28,990
van MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
En dan het meest recent,
vorige week, hebben we

10
00:00:30,780 --> 00:00:34,450
invoering van een higher-- een
lager niveau taal bekend

11
00:00:34,450 --> 00:00:36,770
zoals C, iets dat puur tekstueel.

12
00:00:36,770 --> 00:00:39,440
En inderdaad, de laatste keer dat we
verkend in dat kader

13
00:00:39,440 --> 00:00:40,450
een aantal begrippen.

14
00:00:40,450 --> 00:00:43,010
>> Dit, rappel, was de
eerste programma keken we naar.

15
00:00:43,010 --> 00:00:45,710
En dit programma, heel eenvoudig,
afgedrukt, "hallo, wereld."

16
00:00:45,710 --> 00:00:47,730
Maar er is zo veel
schijnbare magie er aan de hand.

17
00:00:47,730 --> 00:00:51,460
Er is dit #include
met deze punthaken.

18
00:00:51,460 --> 00:00:52,170
Er is int.

19
00:00:52,170 --> 00:00:53,020
Er is (void).

20
00:00:53,020 --> 00:00:56,330
Er is tussen haakjes, accolades,
puntkomma, en nog veel meer.

21
00:00:56,330 --> 00:00:58,480
>> En zo, herinneren dat
introduceerden we Scratch

22
00:00:58,480 --> 00:01:02,110
zodat we konden, idealiter, zie verleden
dat syntax, het spul dat is echt niet

23
00:01:02,110 --> 00:01:04,590
alles wat intellectueel
interessant maar vroeg

24
00:01:04,590 --> 00:01:07,700
is, absoluut, een beetje lastig
te wikkelen je gedachten rond.

25
00:01:07,700 --> 00:01:10,860
En inderdaad, een van de meest voorkomende
dingen vroeg in een programmeertaal klasse,

26
00:01:10,860 --> 00:01:13,443
vooral voor degenen die minder
comfortabel, is om zich te gefrustreerd door

27
00:01:13,443 --> 00:01:17,460
en struikelen door bepaalde syntactische
fouten, niet logische fouten noemen.

28
00:01:17,460 --> 00:01:19,800
En zo onder onze doelen
vandaag de dag, in feite, zal

29
00:01:19,800 --> 00:01:23,280
zijn om u uit te rusten met een aantal
probleemoplossende technieken voor de manier waarop

30
00:01:23,280 --> 00:01:26,705
zichzelf beter lossen problemen
in de vorm van debuggen.

31
00:01:26,705 --> 00:01:29,330
En je zult herinneren, ook dat de
omgeving die we geïntroduceerd

32
00:01:29,330 --> 00:01:31,780
laatste keer heette CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Dit is web-based software die
kunt u programmeren in de cloud,

34
00:01:34,850 --> 00:01:38,450
zogezegd, terwijl al uw
bestanden samen, zoals we zullen weer vandaag.

35
00:01:38,450 --> 00:01:41,480
En herinner me dat we
revisited deze onderwerpen hier,

36
00:01:41,480 --> 00:01:44,480
waaronder functies en loops, en
variabelen en Booleaanse uitdrukkingen,

37
00:01:44,480 --> 00:01:45,110
en voorwaarden.

38
00:01:45,110 --> 00:01:49,190
En eigenlijk nog een paar dat we
vertaald uit de wereld van Scratch

39
00:01:49,190 --> 00:01:50,800
in de wereld van C.

40
00:01:50,800 --> 00:01:53,220
>> Maar de fundamentele bouwsteen
blokken, zo te zeggen,

41
00:01:53,220 --> 00:01:55,150
waren echt nog steeds hetzelfde vorige week.

42
00:01:55,150 --> 00:01:57,900
In feite hebben we echt net een
verschillende puzzelstukje, als je wil.

43
00:01:57,900 --> 00:02:00,300
In plaats daarvan paarse
opslaan blok, we in plaats daarvan

44
00:02:00,300 --> 00:02:02,940
had printf, dat is
Deze functie C dat

45
00:02:02,940 --> 00:02:05,890
stelt u in staat om iets af te drukken
en formatteren op het scherm.

46
00:02:05,890 --> 00:02:07,950
We introduceerden de CS50
Bibliotheek, waar u

47
00:02:07,950 --> 00:02:11,420
nu tot uw beschikking get_char,
en get_int en get_string,

48
00:02:11,420 --> 00:02:14,610
en een paar andere functies zoals
nou ja, via welke je kunt krijgen invoeren

49
00:02:14,610 --> 00:02:16,260
uit eigen toetsenbord van de gebruiker.

50
00:02:16,260 --> 00:02:20,640
En we namen ook een kijkje nemen op de dingen
als deze-Bool en char,

51
00:02:20,640 --> 00:02:22,490
en dubbele, vlotter,
int, long_long string.

52
00:02:22,490 --> 00:02:25,170
En er is zelfs andere soorten gegevens in C.

53
00:02:25,170 --> 00:02:28,560
>> Met andere woorden, als je verklaren
een variabele enkele waarde op te slaan,

54
00:02:28,560 --> 00:02:32,600
of wanneer u implementeren van een functie
dat geeft een zekere waarde,

55
00:02:32,600 --> 00:02:35,290
kunt u aangeven wat
type waarde dat is.

56
00:02:35,290 --> 00:02:37,310
Is het een koord, zoals een
opeenvolging van karakters?

57
00:02:37,310 --> 00:02:39,490
Is het een getal, als een integer?

58
00:02:39,490 --> 00:02:41,390
Is het een floating point
waarde, of iets dergelijks?

59
00:02:41,390 --> 00:02:46,180
Dus in C, in tegenstelling tot Scratch, we eigenlijk
begon aan te geven wat voor soort data

60
00:02:46,180 --> 00:02:48,330
we waren terug te keren of het gebruik.

61
00:02:48,330 --> 00:02:51,910
>> Maar natuurlijk, we liepen ook naar
een aantal fundamentele beperkingen van de informatica.

62
00:02:51,910 --> 00:02:54,100
En in het bijzonder,
deze taal C, recall

63
00:02:54,100 --> 00:02:57,070
dat we nam een ​​kijkje op
integer overflow, de realiteit

64
00:02:57,070 --> 00:03:00,460
dat als je alleen maar een
eindige hoeveelheid geheugen

65
00:03:00,460 --> 00:03:04,600
of specifiek een eindig aantal
bits, kunt u alleen rekenen zo hoog.

66
00:03:04,600 --> 00:03:08,460
En dus hebben we gekeken naar dit voorbeeld hier
waarbij een teller in een vliegtuig,

67
00:03:08,460 --> 00:03:13,510
Eigenlijk, als lang genoeg loopt zou
overlopen en resulteren in een software

68
00:03:13,510 --> 00:03:15,560
een daadwerkelijke fysieke potentieel fout.

69
00:03:15,560 --> 00:03:18,600
>> We hebben ook gekeken naar drijvende
point onnauwkeurigheid, de realiteit

70
00:03:18,600 --> 00:03:22,280
dat slechts een eindig aantal
bits, of het 32 ​​of 64,

71
00:03:22,280 --> 00:03:27,330
je kunt alleen opgeven zo veel nummers
na een komma, waarna u

72
00:03:27,330 --> 00:03:29,110
beginnen onnauwkeurig te krijgen.

73
00:03:29,110 --> 00:03:32,360
Dus bijvoorbeeld een derde in de
wereld hier, in onze menselijke wereld,

74
00:03:32,360 --> 00:03:35,360
we weten is slechts een oneindig aantal
van 3s na de komma.

75
00:03:35,360 --> 00:03:38,820
Maar een computer kan niet per se
vormen een oneindig aantal getallen

76
00:03:38,820 --> 00:03:42,590
Als u alleen toestaan ​​sommige
eindige hoeveelheid informatie.

77
00:03:42,590 --> 00:03:45,900
>> Dus niet alleen hebben wij u uitrusten
met een grotere macht in termen

78
00:03:45,900 --> 00:03:49,280
van hoe je zou uiten op
een toetsenbord op het gebied van programmering,

79
00:03:49,280 --> 00:03:51,430
beperkten we ook wat
kun je eigenlijk doen.

80
00:03:51,430 --> 00:03:55,790
En inderdaad, bugs en fouten kunnen
voortvloeien uit dit soort kwesties.

81
00:03:55,790 --> 00:03:59,900
En inderdaad, een van de thema's van vandaag
gaan om onderwerpen als debuggen

82
00:03:59,900 --> 00:04:03,699
en eigenlijk kijken onder de motorkap
hoe dingen waren die vorig week

83
00:04:03,699 --> 00:04:05,490
daadwerkelijk worden geïmplementeerd
zodat je beter

84
00:04:05,490 --> 00:04:10,530
begrijpen zowel de capaciteiten en
de beperkingen van een taal als C.

85
00:04:10,530 --> 00:04:14,770
>> En in feite, zullen we schil de rug van de lagen
van de eenvoudigste gegevensstructuur,

86
00:04:14,770 --> 00:04:17,756
zoiets als een array, die
Scratch toevallig een te bellen "lijst."

87
00:04:17,756 --> 00:04:19,589
Het is een beetje
verschillend in die context.

88
00:04:19,589 --> 00:04:23,340
En dan zullen we introduceren ook een van de
eerste van onze domein-specifieke problemen

89
00:04:23,340 --> 00:04:26,790
in CS50, de wereld van de
cryptografie, de kunst van het klauteren

90
00:04:26,790 --> 00:04:29,650
of coderen Zo
dat je geheime boodschappen kunt verzenden

91
00:04:29,650 --> 00:04:34,520
en decoderen van geheime boodschappen
tussen twee personen, A en B.

92
00:04:34,520 --> 00:04:37,490
>> Dus voordat we overgang
naar die nieuwe wereld,

93
00:04:37,490 --> 00:04:42,059
laten we proberen om u uit te rusten met een aantal
technieken waarmee je kunt elimineren

94
00:04:42,059 --> 00:04:43,850
of verminderen ten minste sommige
van de frustraties

95
00:04:43,850 --> 00:04:46,630
dat je waarschijnlijk hebben ondervonden
van de afgelopen week alleen.

96
00:04:46,630 --> 00:04:50,830
In feite, met een voorsprong van jullie such-- een aantal van
uw eerste problemen in C. En kansen zijn,

97
00:04:50,830 --> 00:04:54,010
Als je net als ik, de eerste keer
je probeert te typen van een programma,

98
00:04:54,010 --> 00:04:57,330
zelfs als u denkt logisch
het programma is vrij eenvoudig,

99
00:04:57,330 --> 00:05:01,200
je zou heel goed tegen een muur, en
de compiler is niet van plan om mee te werken.

100
00:05:01,200 --> 00:05:03,940
Bellen of Clang is niet van plan
eigenlijk doe je bieden.

101
00:05:03,940 --> 00:05:05,450
>> En waarom zou dat zijn?

102
00:05:05,450 --> 00:05:07,950
Nou, laten we een kijkje nemen op,
misschien een eenvoudig programma.

103
00:05:07,950 --> 00:05:11,190
Ik ga om te gaan en op te slaan deze in
Een bestand met opzet genaamd buggy0.c,

104
00:05:11,190 --> 00:05:13,590
omdat ik weet dat het
worden ontsierd op voorhand.

105
00:05:13,590 --> 00:05:17,400
Maar ik misschien niet beseffen dat als deze
is de eerste of tweede of derde programma

106
00:05:17,400 --> 00:05:18,830
dat ik ben eigenlijk het maken van mezelf.

107
00:05:18,830 --> 00:05:23,820
Dus ik ga om te gaan en
uittypen, int main (void).

108
00:05:23,820 --> 00:05:28,130
En dan is de binnenkant van mijn accolades,
een zeer vertrouwd ( "hallo, wereld--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - en een puntkomma.

110
00:05:30,980 --> 00:05:32,360
>> Ik heb het bestand opgeslagen.

111
00:05:32,360 --> 00:05:34,850
Nu ga ik naar beneden te gaan
aan mijn terminal venster

112
00:05:34,850 --> 00:05:40,340
en het type make buggy0, want, nogmaals,
de naam van het bestand is vandaag buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Dus ik typ maken buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> En, oh, gosh, herinneren van de vorige keer
dat er geen foutmeldingen is een goede zaak.

115
00:05:48,200 --> 00:05:49,740
Dus geen output is een goede zaak.

116
00:05:49,740 --> 00:05:52,920
Maar hier heb ik duidelijk
bepaald aantal fouten.

117
00:05:52,920 --> 00:05:56,470
>> Dus de eerste regel van de output
na het typen maken buggy0, rappel,

118
00:05:56,470 --> 00:05:59,540
is vrij uitgebreide uitvoer Clang's.

119
00:05:59,540 --> 00:06:02,067
Onder de kap,
CS50 IDE is geconfigureerd

120
00:06:02,067 --> 00:06:04,150
een hele hoop te gebruiken
opties met deze compiler

121
00:06:04,150 --> 00:06:05,941
zodat u niet hoeft
om na te denken over hen.

122
00:06:05,941 --> 00:06:08,840
En dat is alles dat de eerste lijn
middelen die begint met Clang.

123
00:06:08,840 --> 00:06:11,720
>> Maar daarna problemen
beginnen hun verschijning.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c op lijn 3, karakter
5, is er een grote, rode error.

125
00:06:17,390 --> 00:06:18,380
Wat is dat?

126
00:06:18,380 --> 00:06:23,562
Impliciet verklaren bibliotheekfunctie
printf met type int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Ik bedoel, het zeer snel
erg mysterieus.

129
00:06:28,379 --> 00:06:30,170
En zeker, op het eerste
blik, zouden we niet

130
00:06:30,170 --> 00:06:32,380
verwachten dat je het begrijpt
geheel van die boodschap.

131
00:06:32,380 --> 00:06:34,213
En zo een van de lessen
voor vandaag gaat

132
00:06:34,213 --> 00:06:36,919
om te proberen het bericht
patronen of soortgelijke dingen,

133
00:06:36,919 --> 00:06:38,960
om fouten die u zou kunnen hebben
in het verleden ondervonden.

134
00:06:38,960 --> 00:06:41,335
Dus laten we alleen plagen elkaar
die woorden die bekend voor.

135
00:06:41,335 --> 00:06:44,290
De grote, rode fout is duidelijk
symbolisch dat iets mis is.

136
00:06:44,290 --> 00:06:47,940
>> impliciet verklaren
bibliotheek functie printf.

137
00:06:47,940 --> 00:06:51,680
Dus zelfs als ik niet helemaal begrijpen wat
impliciet verklaren bibliotheekfunctie

138
00:06:51,680 --> 00:06:54,900
middelen, het probleem toch
heeft betrekking op een of andere manier printf.

139
00:06:54,900 --> 00:06:59,130
En de bron van die kwestie
heeft te maken met aangifte te doen.

140
00:06:59,130 --> 00:07:02,440
>> Het uitroepen van een functie
met vermelding van het voor de eerste keer.

141
00:07:02,440 --> 00:07:06,210
En we gebruikten de terminologie van vorige week
verklaren prototype van een functie,

142
00:07:06,210 --> 00:07:11,860
hetzij met één lijn aan de bovenkant van uw
eigen bestand of in een zogenaamde header file.

143
00:07:11,860 --> 00:07:15,300
En in welke file deden we zeggen
vorige week dat printf is citaat,

144
00:07:15,300 --> 00:07:17,080
unquote, verklaarde?

145
00:07:17,080 --> 00:07:20,950
In welk bestand is het prototype?

146
00:07:20,950 --> 00:07:24,640
>> Dus als u zich herinneren, het allereerste wat ik
getypte, bijna elk programma afgelopen tijd--

147
00:07:24,640 --> 00:07:30,790
en per ongeluk even geleden begonnen
typen myself-- was dit een hier--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- voor
input / output-- dot h En inderdaad,

149
00:07:38,630 --> 00:07:41,860
Als ik nu dit bestand op te slaan, ga ik
om verder te gaan en mijn scherm te wissen,

150
00:07:41,860 --> 00:07:44,740
die je kunt doen door het intikken
Heldere, of u kunt houden Control L,

151
00:07:44,740 --> 00:07:47,680
alleen maar om je terminal venster te wissen
gewoon om wat rommel te elimineren.

152
00:07:47,680 --> 00:07:51,370
>> Ik ga om te gaan en
re-type make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
En voila, ik zie nog steeds dat
lange commando van Clang,

154
00:07:53,790 --> 00:07:55,470
maar er is geen foutmelding deze tijd.

155
00:07:55,470 --> 00:07:58,800
En inderdaad, als ik dat doe ./buggy0,
net als de vorige keer,

156
00:07:58,800 --> 00:08:01,860
waar de stip betekent dit
directory, Slash betekent gewoon,

157
00:08:01,860 --> 00:08:05,040
Hier komt de naam van het programma en
dat de naam van het programma is buggy0,

158
00:08:05,040 --> 00:08:07,340
Enter, "hello, world."

159
00:08:07,340 --> 00:08:09,440
>> Nu, hoe zou je hebt
deze oplossing verzameld

160
00:08:09,440 --> 00:08:12,017
zonder dat
het herkennen van zo veel mogelijk woorden

161
00:08:12,017 --> 00:08:14,350
zoals ik heb gedaan, zeker, met
dit gedaan voor zo vele jaren?

162
00:08:14,350 --> 00:08:18,720
Nou, realiseren per het eerste probleem
set, introduceren wij u een opdracht

163
00:08:18,720 --> 00:08:21,175
dat eigen medewerkers CS50's
schreef genaamd help50.

164
00:08:21,175 --> 00:08:24,300
En inderdaad, C doet specificatie voor
het probleem stellen hoe dit te gebruiken.

165
00:08:24,300 --> 00:08:27,210
>> Maar help50 hoofdzaak
een programma dat het personeel CS50's

166
00:08:27,210 --> 00:08:30,850
schreef die u toelaat om te draaien
een opdracht of uitvoeren van een programma,

167
00:08:30,850 --> 00:08:36,169
en als je niet begrijpt haar
output, naar de uitgang door te geven aan help50,

168
00:08:36,169 --> 00:08:38,890
waarna de software
dat het personeel van de cursus schreef

169
00:08:38,890 --> 00:08:42,429
zal kijken naar de uitgang van uw programma
regel voor regel, teken voor teken.

170
00:08:42,429 --> 00:08:46,000
En als we, het personeel, erkennen de
foutmelding die je ervaart,

171
00:08:46,000 --> 00:08:50,580
we zullen proberen om u te lokken met een aantal
retorische vragen, met wat advies,

172
00:08:50,580 --> 00:08:54,890
net als een TF of een CA of ikzelf
zou doen in persoon op kantooruren.

173
00:08:54,890 --> 00:08:58,320
>> Dus kijk naar help50 als je dat niet doet
per se een probleem te herkennen.

174
00:08:58,320 --> 00:09:00,790
Maar niet op vertrouwen
te veel als een kruk.

175
00:09:00,790 --> 00:09:03,990
Zeker proberen te begrijpen zijn
output en vervolgens van leren

176
00:09:03,990 --> 00:09:07,571
zodat slechts één of twee keer heb je
ooit lopen help50 voor een bepaalde fout

177
00:09:07,571 --> 00:09:08,070
bericht.

178
00:09:08,070 --> 00:09:10,660
Daarna moet u
beter uitgerust jezelf

179
00:09:10,660 --> 00:09:13,180
om erachter te komen wat het eigenlijk is.

180
00:09:13,180 --> 00:09:14,350
>> Laten we een ander hier.

181
00:09:14,350 --> 00:09:20,410
Laat me gaan, en in een ander
bestand zullen we deze buggy1.c noemen.

182
00:09:20,410 --> 00:09:23,110
En in dit bestand Ik ben
gaat deliberately--

183
00:09:23,110 --> 00:09:26,330
maar doen alsof dat ik niet
begrijpen wat fout die ik heb gemaakt.

184
00:09:26,330 --> 00:09:31,420
>> Ik ga om te gaan en te doen dit--
# include, want ik heb

185
00:09:31,420 --> 00:09:33,660
leerde mijn les van daarnet.

186
00:09:33,660 --> 00:09:36,220
Int main (void), zoals voorheen.

187
00:09:36,220 --> 00:09:40,880
En dan hier ga ik
te doen tekenreeks s - get_string.

188
00:09:40,880 --> 00:09:43,770
En herinneren van de vorige keer dat
Dit betekent, hey, computer,

189
00:09:43,770 --> 00:09:48,280
geef me een variabele, noem het is, en
maken de aard van die variabele een string

190
00:09:48,280 --> 00:09:50,150
dus ik kan één of meer woorden in te bewaren.

191
00:09:50,150 --> 00:09:52,191
>> En dan op de rechter
kant van het isgelijkteken

192
00:09:52,191 --> 00:09:54,980
get_string is, dat een
functie in de CS50 Bibliotheek

193
00:09:54,980 --> 00:09:55,980
dat doet precies dat.

194
00:09:55,980 --> 00:09:59,740
Het wordt een functie en
handen is van rechts naar links.

195
00:09:59,740 --> 00:10:02,670
Dus dit gelijk-teken betekent niet
"Gelijk", zoals we zouden kunnen denken in wiskunde.

196
00:10:02,670 --> 00:10:04,750
Het betekent opdracht van rechts naar links.

197
00:10:04,750 --> 00:10:09,640
Dus dit betekent, neemt de string uit
de gebruiker en bewaar het binnenkant van s.

198
00:10:09,640 --> 00:10:10,460
>> Laten we nu gebruiken.

199
00:10:10,460 --> 00:10:13,820
Laat me nu en ga je gang als tweede
lijn, laat me ga je gang en zeg "hallo" -

200
00:10:13,820 --> 00:10:19,330
niet "wereld", maar "hello,% S--
dat is onze placeholder, komma's,

201
00:10:19,330 --> 00:10:22,030
die ons variabel,
en vervolgens een puntkomma.

202
00:10:22,030 --> 00:10:26,070
Dus als ik niet verpesten teveel
Hier, dit ziet eruit als de code juist is.

203
00:10:26,070 --> 00:10:28,090
>> En mijn instincten nu zijn om het te compileren.

204
00:10:28,090 --> 00:10:30,400
Het bestand heet buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Dus ik ga doen maken buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
En stopt-het, als er geen
nog meer fouten dan voorheen.

207
00:10:36,377 --> 00:10:38,210
Ik bedoel, er is meer
foutmeldingen het zou

208
00:10:38,210 --> 00:10:40,400
lijken dan de werkelijke regels in dit programma.

209
00:10:40,400 --> 00:10:42,730
>> Maar de afhaalmaaltijd is hier,
zelfs als je overweldigd bent

210
00:10:42,730 --> 00:10:45,040
met twee of drie of
vier meer foutmeldingen,

211
00:10:45,040 --> 00:10:48,340
altijd gericht op de
eerste van deze berichten.

212
00:10:48,340 --> 00:10:52,220
Kijkend naar de bovenste één,
scrolling back-up als het nodig is.

213
00:10:52,220 --> 00:10:53,930
Dus hier Ik typte make buggy1.

214
00:10:53,930 --> 00:10:55,700
Hier is dat Clang uitgevoerd als verwacht.

215
00:10:55,700 --> 00:10:57,290
>> En hier is de eerste rode fout.

216
00:10:57,290 --> 00:11:02,370
Het gebruik van niet-aangegeven identifier
koord, heb ik bedoel standaard in?

217
00:11:02,370 --> 00:11:04,260
Dus standaard is
eigenlijk iets anders.

218
00:11:04,260 --> 00:11:06,240
Het verwijst naar de gebruiker
toetsenbord wezen.

219
00:11:06,240 --> 00:11:08,080
>> Maar dat is niet wat ik bedoelde.

220
00:11:08,080 --> 00:11:11,770
Ik bedoelde touwtje, en ik bedoelde get_string.

221
00:11:11,770 --> 00:11:16,200
Dus wat is het dat ik
vergat deze keer doen?

222
00:11:16,200 --> 00:11:20,230
Wat ontbreekt deze keer?

223
00:11:20,230 --> 00:11:23,600
Ik heb mijn # include,
dus ik heb toegang tot printf.

224
00:11:23,600 --> 00:11:26,090
>> Maar wat heb ik niet
toegang tot gewoon nog niet?

225
00:11:26,090 --> 00:11:29,420
Nou, net als de vorige keer,
Ik moet de compiler te vertellen

226
00:11:29,420 --> 00:11:31,691
Clang wat deze functies zijn.

227
00:11:31,691 --> 00:11:33,940
Get_string komt niet
met C en in het bijzonder

228
00:11:33,940 --> 00:11:38,160
komt niet in de
header bestand.

229
00:11:38,160 --> 00:11:40,770
Het komt in plaats daarvan in
iets wat het personeel heeft geschreven,

230
00:11:40,770 --> 00:11:44,176
dat is een ander bestand
noem maar toepasselijke naam.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Dus gewoon door het toevoegen van die ene lijn
van code-- recall van de vorige keer

233
00:11:50,861 --> 00:11:53,610
dat wanneer Clang wordt uitgevoerd, gaat het
om te kijken naar mijn code boven naar beneden,

234
00:11:53,610 --> 00:11:54,193
van links naar rechts.

235
00:11:54,193 --> 00:11:57,200
Het gaat om op te merken,
oh, je wilt.

236
00:11:57,200 --> 00:11:59,900
Laat me gaan en vinden dat,
waar het ook is op de server,

237
00:11:59,900 --> 00:12:03,090
kopiëren en plakken, in wezen,
in de bovenkant van je eigen bestand

238
00:12:03,090 --> 00:12:06,820
zodat op dit punt in het verhaal,
lijn 1, de rest van het programma

239
00:12:06,820 --> 00:12:11,651
kan inderdaad gebruik gemaakt van de functies
daarin, onder hen get_string.

240
00:12:11,651 --> 00:12:13,650
Dus ik ga om te negeren
de rest van deze fouten,

241
00:12:13,650 --> 00:12:17,190
omdat ik inderdaad vermoeden dat alleen
de eerste echt toe deed.

242
00:12:17,190 --> 00:12:20,780
En ik ga je gang en herhaling te gaan,
na mijn bestand op te slaan maken buggy1.

243
00:12:20,780 --> 00:12:22,580
En voila, het werkte.

244
00:12:22,580 --> 00:12:29,200
En als ik dat doe ./buggy1 en typ in, voor
Zo Zamyla, ik nu zal hello krijgen,

245
00:12:29,200 --> 00:12:32,000
Zamyla, in plaats van hello, wereld.

246
00:12:32,000 --> 00:12:32,550
>> Okee.

247
00:12:32,550 --> 00:12:35,890
Dus de afhaalrestaurants hier dan zijn om,
een, probeer zoveel als je kunt achterhalen

248
00:12:35,890 --> 00:12:39,140
alleen op grond van de foutmeldingen, op zoek
op enkele van de herkenbare woorden.

249
00:12:39,140 --> 00:12:43,070
Behoudens dat, gebruiken help50 per
het probleem set specificaties.

250
00:12:43,070 --> 00:12:46,500
Maar behoudens dat ook altijd kijken
bovenaan fout, minstens

251
00:12:46,500 --> 00:12:50,051
in eerste instantie, om te zien welke informatie
het zou eigenlijk opleveren.

252
00:12:50,051 --> 00:12:52,300
Maar het blijkt er's
nog meer functionaliteit ingebouwd

253
00:12:52,300 --> 00:12:55,030
in de CS50 Library te helpen
je vroeg in het semester

254
00:12:55,030 --> 00:12:57,580
en in het begin van de programmering
erachter te komen wat er mis gaat.

255
00:12:57,580 --> 00:12:59,840
Dus laten we een ander voorbeeld hier.

256
00:12:59,840 --> 00:13:04,350
Ik ga dit buggy2 noemen, die,
weer, zal worden ontsierd uit

257
00:13:04,350 --> 00:13:05,650
van de poort, door het ontwerp.

258
00:13:05,650 --> 00:13:09,980
>> En ik ga om verder te gaan
en doe #include.

259
00:13:09,980 --> 00:13:12,580
En dan ga ik int main (void) te doen.

260
00:13:12,580 --> 00:13:14,840
En dan ga ik een te doen voor lus.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i kleiner is dan of gelijk aan 10.

263
00:13:18,750 --> 00:13:24,260
i ++, en vervolgens in accolades, ik ga
om uit te printen op een hashtag symbool hier

264
00:13:24,260 --> 00:13:25,920
en een nieuwe lijn karakter.

265
00:13:25,920 --> 00:13:29,220
>> Dus mijn bedoeling met deze
programma is gewoonweg

266
00:13:29,220 --> 00:13:33,150
tot 10 keer herhalen
en elke iteratie

267
00:13:33,150 --> 00:13:35,260
van die lus telkens
door de cyclus,

268
00:13:35,260 --> 00:13:37,660
afdrukken van een hashtag,
een hashtag, een hashtag.

269
00:13:37,660 --> 00:13:40,480
Één per regel, omdat ik
hebben de nieuwe lijn daar.

270
00:13:40,480 --> 00:13:42,787
En herinneren dat de voor
lus, per laatste week--

271
00:13:42,787 --> 00:13:44,620
en je zult meer krijgen
vertrouwd met de syntax

272
00:13:44,620 --> 00:13:47,170
door het te gebruiken met de praktijk
voordat long-- geeft dit me

273
00:13:47,170 --> 00:13:49,740
een variabele genaamd i en zet het aan 0.

274
00:13:49,740 --> 00:13:52,650
>> Dit verhoogt op i
iedere iteratie door 1.

275
00:13:52,650 --> 00:13:54,940
Dus gaat i 1 tot 2-3.

276
00:13:54,940 --> 00:13:57,690
En dan is deze voorwaarde in de
midden tussen de puntkomma

277
00:13:57,690 --> 00:14:03,010
wordt gecontroleerd op elke iteratie te maken
er zeker van dat we nog steeds binnen bereik.

278
00:14:03,010 --> 00:14:06,830
Dus ik wil 10 keer herhalen, dus ik
hebben een soort van zeer intuïtief net

279
00:14:06,830 --> 00:14:09,070
zet 10 als mijn bovengrens daar.

280
00:14:09,070 --> 00:14:14,310
>> En toch, toen ik dit run, na
compilatie met make buggy2--

281
00:14:14,310 --> 00:14:15,440
en het doet compileren OK.

282
00:14:15,440 --> 00:14:17,980
Dus ik heb geen
syntax error deze tijd.

283
00:14:17,980 --> 00:14:20,940
Laat me nu ga je gang
en lopen buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
En nu gaat u omhoog.

285
00:14:22,620 --> 00:14:24,890
En laat me te verhogen
de grootte van het venster.

286
00:14:24,890 --> 00:14:33,720
>> Ik lijken te hebben 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Dus er is 11 hashtags, alhoewel
Ik heb duidelijk zet 10 binnenkant van deze lus.

288
00:14:38,891 --> 00:14:42,140
Nu, sommigen van u misschien meteen
wat de fout is dat inderdaad deze

289
00:14:42,140 --> 00:14:43,720
is een hardwarefout te maken.

290
00:14:43,720 --> 00:14:46,070
Maar het is zeer vaak
heel vroeg gemaakt.

291
00:14:46,070 --> 00:14:49,820
>> Wat ik wil erop wijzen, hoewel,
is, hoe kan ik dit uit?

292
00:14:49,820 --> 00:14:52,300
Nou, het blijkt dat
de CS50 Bibliotheek komt

293
00:14:52,300 --> 00:14:55,380
met niet alleen get_string en get_int
en get_float en andere functies.

294
00:14:55,380 --> 00:14:59,980
Het komt ook met een speciale functie
genaamd eprintf, of fout printf.

295
00:14:59,980 --> 00:15:03,270
En het bestaat uitsluitend te maken
het een beetje makkelijker voor u

296
00:15:03,270 --> 00:15:06,310
bij het oplossen van uw code om gewoon
afdrukken een foutmelding op het scherm

297
00:15:06,310 --> 00:15:07,850
en weten waar het vandaan kwam.

298
00:15:07,850 --> 00:15:11,000
>> Dus bijvoorbeeld, een ding dat ik zou
hier doen met deze functie is dit--

299
00:15:11,000 --> 00:15:20,230
eprintf, en dan ga ik om verder te gaan
en zeggen dat ik nu% i, backslash, n.

300
00:15:20,230 --> 00:15:22,330
En ik ga om aan te sluiten in de waarde van i.

301
00:15:22,330 --> 00:15:25,400
En tot boven, want dit
in het CS50 Library,

302
00:15:25,400 --> 00:15:27,580
Ik ga om verder te gaan
en omvatten

303
00:15:27,580 --> 00:15:29,169
dus ik heb toegang tot deze functie.

304
00:15:29,169 --> 00:15:31,460
Maar laten we eens kijken welke lijn
9 is zou moeten doen.

305
00:15:31,460 --> 00:15:32,670
Ik ga dit uiteindelijk te verwijderen.

306
00:15:32,670 --> 00:15:34,670
Dit heeft niets te maken
met mijn overkoepelende doel.

307
00:15:34,670 --> 00:15:39,090
Maar eprintf, fout printf, is alleen bedoeld
voor mij sommige diagnostische informatie te geven.

308
00:15:39,090 --> 00:15:42,460
Toen ik mijn programma uit te voeren, wil ik
Bekijk dit op het scherm tijdelijk

309
00:15:42,460 --> 00:15:44,550
net zo goed te begrijpen
wat gebeurd er.

310
00:15:44,550 --> 00:15:47,330
>> En inderdaad op elke
iteratie hier van lijn 9

311
00:15:47,330 --> 00:15:49,260
Ik wil zien, wat is de waarde van i?

312
00:15:49,260 --> 00:15:50,290
Wat is de waarde van i?

313
00:15:50,290 --> 00:15:51,280
Wat is de waarde van i?

314
00:15:51,280 --> 00:15:55,650
En hopelijk, zou ik alleen maar
zien die boodschap ook, 10 keer.

315
00:15:55,650 --> 00:15:57,780
>> Dus laat me ga je gang en
recompile mijn programma,

316
00:15:57,780 --> 00:15:59,905
als ik elk moment doen
Ik maak een verandering. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
En now-- OK.

319
00:16:03,640 --> 00:16:04,820
Er is veel meer aan de hand.

320
00:16:04,820 --> 00:16:07,610
Dus laat me scroll omhoog in
een nog groter venster.

321
00:16:07,610 --> 00:16:10,190
>> En je zult zien dat elk van
de hashtags is nog steeds afdrukken.

322
00:16:10,190 --> 00:16:15,270
Maar tussen elk van hen is nu dit
diagnostische uitvoer opgemaakt als volgt.

323
00:16:15,270 --> 00:16:17,960
De naam van mijn programma is hier buggy2.

324
00:16:17,960 --> 00:16:20,432
De naam van het bestand is buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Het lijnnummer van waaruit
Dit werd gedrukt is lijn 9.

326
00:16:24,080 --> 00:16:27,500
En vervolgens naar rechts daarvan is de
foutmelding dat ik verwachtte.

327
00:16:27,500 --> 00:16:30,701
>> En wat er leuk is aan dit is dat
Nu heb ik niet per se te tellen

328
00:16:30,701 --> 00:16:32,200
in mijn hoofd wat mijn programma aan het doen is.

329
00:16:32,200 --> 00:16:34,240
Ik kan zien dat op de
eerste iteratie i is 0,

330
00:16:34,240 --> 00:16:39,420
dan 1, dan 2, dan 3, dan 4, dan
5, dan 6, dan 7, dan 8, dan 9, dan

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Dus wacht een minuut.

333
00:16:42,050 --> 00:16:43,740
Wat is hier aan de hand?

334
00:16:43,740 --> 00:16:48,190
Ik meen mij nog te tellen
zoals bedoeld tot 10.

335
00:16:48,190 --> 00:16:50,550
>> Maar waar heb ik beginnen?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Dus 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 11 10-- vinger

338
00:16:58,040 --> 00:16:59,990
is indicatief voor het probleem.

339
00:16:59,990 --> 00:17:02,850
Ik lijken te hebben geteld
verkeerd in mijn loop.

340
00:17:02,850 --> 00:17:06,599
In plaats van naar 10 herhalingen,
Ik begin op 0,

341
00:17:06,599 --> 00:17:09,550
Ik eindigt bij en door 10.

342
00:17:09,550 --> 00:17:12,030
Maar omdat, zoals een computer,
Ik ben beginnen te tellen bij 0,

343
00:17:12,030 --> 00:17:15,250
Ik zou moeten tellen
, maar niet door, 10.

344
00:17:15,250 --> 00:17:18,510
>> En dus is de fix, ik uiteindelijk
hier gerealiseerd, is een van twee dingen.

345
00:17:18,510 --> 00:17:22,430
Ik zou heel gewoon zeggen
tellen tot minder dan 10.

346
00:17:22,430 --> 00:17:27,260
Dus 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, die inderdaad correct,

347
00:17:27,260 --> 00:17:28,900
hoewel het klinkt een beetje verkeerd.

348
00:17:28,900 --> 00:17:35,070
Of ik kon doen kleiner dan of gelijk
tot 9, zolang ik vanaf 0.

349
00:17:35,070 --> 00:17:40,056
Of als je echt niet wilt dat u
kan tellen tot en met 10, maar beginnen bij 1.

350
00:17:40,056 --> 00:17:41,680
Maar nogmaals, dit is gewoon niet zo vaak voor.

351
00:17:41,680 --> 00:17:43,977
In programming-- zij
niet zozeer in Scratch--

352
00:17:43,977 --> 00:17:45,810
maar in de programmering in
C en andere talen,

353
00:17:45,810 --> 00:17:47,670
zoals JavaScript en
Python en anderen, het is

354
00:17:47,670 --> 00:17:49,880
gewoon heel vaak voor
onze bespreking van binaire

355
00:17:49,880 --> 00:17:53,450
gewoon beginnen te tellen bij de
laagste aantal je kunt, dat is 0.

356
00:17:53,450 --> 00:17:53,950
Okee.

357
00:17:53,950 --> 00:17:55,160
Dus dat is eprintf.

358
00:17:55,160 --> 00:17:58,600
En nogmaals, nu heb ik bedacht mijn
probleem, en ik ga terug naar 0

359
00:17:58,600 --> 00:18:01,470
door middel van minder dan 10, ik ga
te gaan en eprintf verwijderen.

360
00:18:01,470 --> 00:18:04,580
>> Het zou er niet zijn als ik
het schip mijn code of mijn code in te dienen

361
00:18:04,580 --> 00:18:05,800
laten zien of aan iemand anders.

362
00:18:05,800 --> 00:18:07,980
Het is eigenlijk alleen maar bedoeld
voor tijdelijk gebruik.

363
00:18:07,980 --> 00:18:11,650
Maar nu heb ik dit vast
bijzonder probleem.

364
00:18:11,650 --> 00:18:16,780
>> Nou, laten we nog een voorbeeld hier
dat ik ga om zweep als volgt.

365
00:18:16,780 --> 00:18:22,850
Ik ga om te gaan en
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
En ik ga om verder te gaan
en #include.

367
00:18:25,580 --> 00:18:29,030
>> En ik ga op te slaan
dit bestand als buggy3.c.

368
00:18:29,030 --> 00:18:31,740
En ik ga om verder te gaan
en verklaar int main (void).

369
00:18:31,740 --> 00:18:34,186
En dan de binnenkant van daar
Ik ga doen int i _ -

370
00:18:34,186 --> 00:18:36,435
Ik wil een programma uit te voeren
met get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Dit is niet een functie die nog bestaat.

373
00:18:40,770 --> 00:18:42,870
Dus we gaan uit te voeren
in slechts een moment.

374
00:18:42,870 --> 00:18:45,541
Maar we zullen zien waarom
het is buggy op het eerste pass.

375
00:18:45,541 --> 00:18:47,290
En zodra ik heb gekregen
een int van de gebruiker,

376
00:18:47,290 --> 00:18:53,365
Ik ga gewoon naar% i te drukken is een negatief
integer, backslash, n, komma, i.

377
00:18:53,365 --> 00:18:55,240
Met andere woorden, ik
wil dit programma te doen

378
00:18:55,240 --> 00:18:58,000
is krijgen een negatief int uit
de gebruiker en vervolgens uitprinten

379
00:18:58,000 --> 00:18:59,980
dat die en die een negatief int.

380
00:18:59,980 --> 00:19:02,080
>> Nu moet ik deze functie uit te voeren.

381
00:19:02,080 --> 00:19:05,740
Dus later in mijn dossier, ga ik om te gaan
vooruit en verklaren een functie genaamd

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - en we zullen
terug te komen op wat die lijn weer betekent

383
00:19:10,670 --> 00:19:18,790
in een moment-- int n; doen-- do
de following-- printf n is :.

384
00:19:18,790 --> 00:19:26,210
En dan ga ik n doen - get_int,
en dit doet bij n groter is dan 0.

385
00:19:26,210 --> 00:19:28,310
En dan terug n ;.

386
00:19:28,310 --> 00:19:31,730
>> Dus er is veel gaande in
dit, maar geen van die we niet deden

387
00:19:31,730 --> 00:19:33,710
kijk naar de afgelopen week, op zijn minst kort.

388
00:19:33,710 --> 00:19:36,980
Dus op lijn 10 hier Ik heb verklaard
functie genaamd get_negative_int,

389
00:19:36,980 --> 00:19:39,620
en ik heb gezet (void), in
haakjes, de reden hiervoor is deze

390
00:19:39,620 --> 00:19:40,950
geen input nemen.

391
00:19:40,950 --> 00:19:42,910
Ik doe niets passeren
deze functie.

392
00:19:42,910 --> 00:19:44,690
Ik ben gewoon om iets terug uit het.

393
00:19:44,690 --> 00:19:47,270
>> En wat ik hoop te
terug te krijgen is een integer.

394
00:19:47,270 --> 00:19:50,040
Er is geen enkele vorm van gegevens in
C genoemd negative_int.

395
00:19:50,040 --> 00:19:52,880
Het is gewoon int, dus het gaat
om op ons om ervoor te zorgen

396
00:19:52,880 --> 00:19:55,340
dat de waarde die is eigenlijk
Teruggekeerde is niet alleen een int

397
00:19:55,340 --> 00:19:56,380
maar is ook negatief.

398
00:19:56,380 --> 00:20:02,150
>> Op lijn 12 Ik ben declareren van een variabele
riep n en maakt het van het type int.

399
00:20:02,150 --> 00:20:07,500
En dan in de lijn 13 tot 18 Ik ben
iets te doen terwijl iets waar is.

400
00:20:07,500 --> 00:20:11,040
Ik ga vooruit en afdrukken gaan
n is, dikke darm, en dan een spatie,

401
00:20:11,040 --> 00:20:12,800
als een aanwijzing voor de gebruiker.

402
00:20:12,800 --> 00:20:16,410
>> Ik ben dan bellen get_int en
het opslaan van de zogenaamde return waarde

403
00:20:16,410 --> 00:20:18,130
dat variabele n.

404
00:20:18,130 --> 00:20:22,600
Maar ik ga blijven doen
Dit terwijl n groter is dan 0.

405
00:20:22,600 --> 00:20:27,960
Met andere woorden, als de gebruiker kijkt me
int en dat aantal groter is dan 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positief, ik ga
gewoon blijven reprompting de gebruiker,

407
00:20:31,180 --> 00:20:37,160
houden reprompting, door hen te dwingen
samen te werken en geef me een negatieve int.

408
00:20:37,160 --> 00:20:41,640
>> En zodra n is eigenlijk negative--
veronderstel dat de gebruiker eindelijk types -50,

409
00:20:41,640 --> 00:20:46,710
dan is deze while-lus is niet langer waar
want -50 niet groter is dan 0.

410
00:20:46,710 --> 00:20:51,140
Dus breken we uit die
lus logisch en terug te keren n.

411
00:20:51,140 --> 00:20:53,520
>> Maar er is een andere
wat ik moet doen.

412
00:20:53,520 --> 00:20:56,190
En ik kan gewoon doen
door kopiëren en plakken

413
00:20:56,190 --> 00:20:58,540
een regel code aan het begin van het bestand.

414
00:20:58,540 --> 00:21:01,630
Ik moet Clang te onderwijzen,
of beloven Clang,

415
00:21:01,630 --> 00:21:04,630
uitdrukkelijk dat ik wil,
inderdaad, ga en uit te voeren

416
00:21:04,630 --> 00:21:06,020
Deze functie get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Het zou wel eens lager in het bestand.

418
00:21:07,674 --> 00:21:09,840
Nogmaals, herinneren dat Clang
leest dingen boven naar beneden,

419
00:21:09,840 --> 00:21:12,330
van links naar rechts, zodat u niet
bel een functie als Clang

420
00:21:12,330 --> 00:21:15,330
niet weet dat het gaat om te bestaan.

421
00:21:15,330 --> 00:21:18,430
>> Nu helaas het programma,
Zoals sommigen van jullie misschien gemerkt hebben,

422
00:21:18,430 --> 00:21:19,590
is al buggy.

423
00:21:19,590 --> 00:21:21,400
Laat me ga je gang en maak buggy3.

424
00:21:21,400 --> 00:21:26,904
Het compileert, dus mijn probleem is nu niet
een syntax error, als een tekstuele fout,

425
00:21:26,904 --> 00:21:29,570
het eigenlijk gaat om een ​​logisch
fout die ik heb met opzet

426
00:21:29,570 --> 00:21:32,450
maakte als een kans om
stap door wat er gaande is.

427
00:21:32,450 --> 00:21:35,540
>> Ik ga om verder te gaan
nu en voer buggy3.

428
00:21:35,540 --> 00:21:37,490
En ik ga om te gaan
vooruit en niet meewerken.

429
00:21:37,490 --> 00:21:39,494
Ik ga om het te geven het nummer 1.

430
00:21:39,494 --> 00:21:41,410
Hij vond het niet leuk, dus
het is weer gevraagd me.

431
00:21:41,410 --> 00:21:42,147
>> Hoe zit het met 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Geen van deze werken.

435
00:21:44,740 --> 00:21:46,890
Hoe zit het met -50?

436
00:21:46,890 --> 00:21:48,560
En het programma lijkt te werken.

437
00:21:48,560 --> 00:21:49,970
>> Laat ik probeer het nog eens.

438
00:21:49,970 --> 00:21:53,400
Laat me proberen -1, lijkt te werken.

439
00:21:53,400 --> 00:21:56,380
Laat me proberen -2, lijkt te werken.

440
00:21:56,380 --> 00:21:59,640
Laat me proberen 0.

441
00:21:59,640 --> 00:22:01,684
Huh, dat is onjuist.

442
00:22:01,684 --> 00:22:03,350
Nu, we zijn hier een beetje pedant.

443
00:22:03,350 --> 00:22:07,090
Maar het is inderdaad zo dat 0
is noch positief, noch negatief.

444
00:22:07,090 --> 00:22:11,150
En dus het feit dat mijn programma is
te zeggen dat 0 is een negatief getal is,

445
00:22:11,150 --> 00:22:12,820
Dat is technisch niet correct.

446
00:22:12,820 --> 00:22:15,180
>> Nu, waarom is het om dit te doen?

447
00:22:15,180 --> 00:22:16,270
Nou, zou het duidelijk zijn.

448
00:22:16,270 --> 00:22:18,110
En inderdaad, het programma
bedoeld vrij eenvoudig te

449
00:22:18,110 --> 00:22:19,670
dus we hebben iets om te verkennen.

450
00:22:19,670 --> 00:22:25,870
>> Maar laten we introduceren een derde debugging
techniek die hier genoemd debug50.

451
00:22:25,870 --> 00:22:27,750
Dit is dus een programma
dat we net hebben gemaakt

452
00:22:27,750 --> 00:22:30,770
dit jaar riep debug50
die u zal toestaan

453
00:22:30,770 --> 00:22:34,130
te gebruiken wat wordt genoemd een ingebouwde
grafische debugger in CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
En een debugger is gewoon een programma dat
over het algemeen kunt u uw programma uit te voeren

455
00:22:38,400 --> 00:22:44,050
maar stap voor stap voor stap, lijn
per lijn per lijn, pauzeren, porren

456
00:22:44,050 --> 00:22:47,626
rond, op zoek naar variabelen, zodat
het programma niet alleen blazen je voorbij

457
00:22:47,626 --> 00:22:49,750
en snel iets af te drukken
of niet iets afgedrukt.

458
00:22:49,750 --> 00:22:53,250
Het geeft je een kans, op
menselijke snelheid, om te communiceren met het.

459
00:22:53,250 --> 00:22:55,470
>> En om dit te doen, je
gewoon het volgende doen.

460
00:22:55,470 --> 00:22:58,479
Na het opstellen van de code,
die heb ik al gedaan, buggy3,

461
00:22:58,479 --> 00:23:00,020
ga je gang en lopen debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Zoveel als help50 heeft u loopt
help50 en vervolgens de opdracht,

464
00:23:06,760 --> 00:23:10,120
debug50 heeft u debug50 rennen en
dan is de naam van de opdracht.

465
00:23:10,120 --> 00:23:14,440
>> Nu, let op wat er gebeurt op mijn scherm,
aan de rechterzijde in het bijzonder.

466
00:23:14,440 --> 00:23:19,400
Toen ik hit Run, alle van de
plotselinge dit rechterpaneel

467
00:23:19,400 --> 00:23:20,419
opent op het scherm.

468
00:23:20,419 --> 00:23:22,210
En er is veel te doen
op het eerste gezicht.

469
00:23:22,210 --> 00:23:25,110
Maar er is niet al te
veel zorgen te maken over het nog niet.

470
00:23:25,110 --> 00:23:28,570
>> Dit toont me alles
dat is er aan de binnenkant van mijn programma

471
00:23:28,570 --> 00:23:31,130
op dit moment en via deze
knoppen up top is dan

472
00:23:31,130 --> 00:23:35,910
waardoor ik stap door mijn code
uiteindelijk stap voor stap voor stap.

473
00:23:35,910 --> 00:23:37,140
Maar niet gewoon nog niet.

474
00:23:37,140 --> 00:23:38,060
Let op wat er gebeurt.

475
00:23:38,060 --> 00:23:40,600
Op mijn terminal venster
Ik word gevraagd om n.

476
00:23:40,600 --> 00:23:44,560
En ik ga om verder te gaan en
samen deze tijd en typ -1.

477
00:23:44,560 --> 00:23:48,770
En zij het een beetje cryptisch, -1
een negatief geheel getal is, zoals verwacht.

478
00:23:48,770 --> 00:23:52,020
>> En dan kind verlaten met
status van 0 GDBserver verlaten.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, is de naam
van de onderliggende software

480
00:23:55,180 --> 00:23:56,620
dat implementeert deze debugger.

481
00:23:56,620 --> 00:24:00,500
Maar dit alles betekent eigenlijk, de debugger
ging weg omdat mijn programma af te sluiten

482
00:24:00,500 --> 00:24:01,710
en alles was goed.

483
00:24:01,710 --> 00:24:06,020
Als ik wil echt debuggen mijn programma,
Ik moet preventief vertellen debug50,

484
00:24:06,020 --> 00:24:08,920
waar wil ik beginnen
het doorlopen van mijn code?

485
00:24:08,920 --> 00:24:11,750
>> En misschien wel de eenvoudigste manier
om dat te doen is als volgt.

486
00:24:11,750 --> 00:24:15,300
Als ik de muisaanwijzer op de
goot van mijn redacteur hier,

487
00:24:15,300 --> 00:24:19,090
dus echt alleen in de zijbalk hier,
links van het regelnummer,

488
00:24:19,090 --> 00:24:21,870
Merk op dat als ik klik gewoon
een keer, heb ik een kleine rode stip.

489
00:24:21,870 --> 00:24:24,460
En dat kleine rode stip,
als een stopteken, betekent, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, pauzeren uitvoering van mijn code
daar wanneer ik dit programma.

491
00:24:29,430 --> 00:24:30,260
>> Dus laten we dat doen.

492
00:24:30,260 --> 00:24:37,340
Laat me ga je gang en voer mijn programma
opnieuw met debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
En nu, bericht, iets
anders is gebeurd.

494
00:24:40,110 --> 00:24:42,440
Ik ben niet gevraagd
maar in mijn terminal venster

495
00:24:42,440 --> 00:24:45,430
voor iets, want ik heb niet
gotten er in mijn programma.

496
00:24:45,430 --> 00:24:47,950
Merk op dat op lijn 8
die nu is gemarkeerd,

497
00:24:47,950 --> 00:24:51,720
en er is een kleine pijl bij
links gezegde, je bent hier onderbroken.

498
00:24:51,720 --> 00:24:55,030
Deze lijn van code, lijn
8, is nog niet uitgevoerd.

499
00:24:55,030 --> 00:24:58,940
>> En wat is nieuwsgierig, als ik kijk
hier aan de rechterzijde,

500
00:24:58,940 --> 00:25:03,530
merken dat ik een lokale
variabele lokale in de zin

501
00:25:03,530 --> 00:25:05,450
dat het in de huidige functie.

502
00:25:05,450 --> 00:25:08,920
En de waarde, blijkbaar standaard,
en sorteren van gunstig, is 0.

503
00:25:08,920 --> 00:25:10,260
Maar ik heb niet het type 0.

504
00:25:10,260 --> 00:25:13,410
Dat gebeurt alleen maar om haar
default waarde op het ogenblik.

505
00:25:13,410 --> 00:25:15,490
>> Dus laat me ga je gang en doe dit nu.

506
00:25:15,490 --> 00:25:18,680
Laat me gaan en op
de top hier, ik ben

507
00:25:18,680 --> 00:25:20,970
gaan om verder te gaan en
Klik op deze eerste pictogram dat

508
00:25:20,970 --> 00:25:25,360
betekent stap waarover betekent niet overslaan
het, maar stap over deze lijn van code,

509
00:25:25,360 --> 00:25:27,770
het uitvoeren van het langs de weg.

510
00:25:27,770 --> 00:25:30,710
>> En nu, ziet, mijn
prompt heeft zojuist veranderd.

511
00:25:30,710 --> 00:25:31,380
Waarom is dat?

512
00:25:31,380 --> 00:25:33,639
Ik heb debug50 verteld,
run deze regel code.

513
00:25:33,639 --> 00:25:34,930
Wat betekent deze lijn van code doen?

514
00:25:34,930 --> 00:25:35,960
Vraagt ​​me om een ​​int.

515
00:25:35,960 --> 00:25:36,460
OK.

516
00:25:36,460 --> 00:25:37,400
Laat me samenwerken.

517
00:25:37,400 --> 00:25:41,340
Laat me nu ga je gang en type-1, Enter.

518
00:25:41,340 --> 00:25:42,920
En let nu op wat er is veranderd.

519
00:25:42,920 --> 00:25:46,060
Aan de rechterkant,
mijn lokale variabele i

520
00:25:46,060 --> 00:25:48,200
wordt aangegeven als zijnde -1 nu.

521
00:25:48,200 --> 00:25:49,810
En het is nog steeds van het type int.

522
00:25:49,810 --> 00:25:53,102
>> En let op, ook, mijn zogenaamde
noemen stack, waar heb ik pauze?

523
00:25:53,102 --> 00:25:54,810
We zullen meer over praten
dit in de toekomst.

524
00:25:54,810 --> 00:25:58,620
Maar de call stack net verwijst naar wat
functies zijn nog in beweging.

525
00:25:58,620 --> 00:26:00,040
Op dit moment is het gewoon de belangrijkste.

526
00:26:00,040 --> 00:26:03,590
En op dit moment de enige lokale
variabele i met de waarde 1.

527
00:26:03,590 --> 00:26:09,840
>> En toen ik eindelijk stap over deze lijn
Hier, met datzelfde icoontje bovenaan rechts,

528
00:26:09,840 --> 00:26:11,410
-1 Is een negatief getal.

529
00:26:11,410 --> 00:26:13,580
Nu is het pauzeren over die accolade.

530
00:26:13,580 --> 00:26:14,740
Laten we laat het zijn ding te doen.

531
00:26:14,740 --> 00:26:17,300
Ik stap over die lijn, en voila.

532
00:26:17,300 --> 00:26:20,240
>> Dus niet zo vreselijk
verhelderend nog,

533
00:26:20,240 --> 00:26:23,550
maar het deed laat me pauzeren
en doordenken logisch

534
00:26:23,550 --> 00:26:24,870
wat dit programma doet.

535
00:26:24,870 --> 00:26:26,890
Maar dat was niet het geval onjuist.

536
00:26:26,890 --> 00:26:28,510
Laten we dit doen weer als volgt.

537
00:26:28,510 --> 00:26:31,340
>> Ik ga dat breekpunt te verlaten
op lijn 8 met de rode stip.

538
00:26:31,340 --> 00:26:32,830
Ik ga debug50 opnieuw uit te voeren.

539
00:26:32,830 --> 00:26:34,400
Het wordt hier automatisch gepauzeerd.

540
00:26:34,400 --> 00:26:37,660
Maar deze keer in plaats van
intensivering over deze lijn,

541
00:26:37,660 --> 00:26:42,290
laat me ook daadwerkelijk te gaan binnenkant van
get_negative_int en erachter te komen,

542
00:26:42,290 --> 00:26:45,530
waarom is het aanvaarden van 0 als een geldig antwoord?

543
00:26:45,530 --> 00:26:47,990
>> Dus in plaats van te klikken Step Over.

544
00:26:47,990 --> 00:26:50,630
Ik ga om verder te gaan
en klik Step Into.

545
00:26:50,630 --> 00:26:54,030
En merk op dat de lijn 8 dat is
nu gemarkeerd nu opeens

546
00:26:54,030 --> 00:26:56,900
wordt lijn 17.

547
00:26:56,900 --> 00:26:59,947
>> Nu, het is niet zo dat de debugger
heeft overgeslagen lijnen 14 en 15 en 16.

548
00:26:59,947 --> 00:27:01,780
Het is gewoon dat er niets
u daar te zien.

549
00:27:01,780 --> 00:27:04,050
Die zijn gewoon te verklaren variabelen,
En dan is er het woord doen

550
00:27:04,050 --> 00:27:05,390
en dan een open accolade.

551
00:27:05,390 --> 00:27:09,227
De enige functionele lijn die is
sappige is echt dit hier, 17.

552
00:27:09,227 --> 00:27:11,060
En dat is waar we hebben
automatisch gepauzeerd.

553
00:27:11,060 --> 00:27:13,870
>> Dus printf ( "n.is:") ;, zo
dat is nog niet gebeurd.

554
00:27:13,870 --> 00:27:18,250
Dus laten we gaan door en klik op Stap Over.

555
00:27:18,250 --> 00:27:20,326
Nu is mijn prompt, inderdaad,
veranderd ( "n").

556
00:27:20,326 --> 00:27:22,450
Nu get_int, ik ga niet
lastig te vallen stappen in,

557
00:27:22,450 --> 00:27:24,750
omdat die functie was
door CS50 in de bibliotheek.

558
00:27:24,750 --> 00:27:25,750
Het is waarschijnlijk correct.

559
00:27:25,750 --> 00:27:28,440
>> Dus ik ga om te gaan en
soort van werken door het geven van het

560
00:27:28,440 --> 00:27:30,590
een int, maar geen negatieve int.

561
00:27:30,590 --> 00:27:32,870
Dus laat me ga je gang en sloeg 0.

562
00:27:32,870 --> 00:27:39,460
En nu, wat gebeurt hier
als ik naar beneden op lijn 21?

563
00:27:39,460 --> 00:27:40,890
Ik heb niet meer herhaald.

564
00:27:40,890 --> 00:27:43,320
Ik weet niet lijken vast te zitten in die lus.

565
00:27:43,320 --> 00:27:45,990
Met andere woorden, deze gele
bar niet te gaan rond,

566
00:27:45,990 --> 00:27:47,130
en rond en rond.

567
00:27:47,130 --> 00:27:48,340
>> Nu, waarom is dat?

568
00:27:48,340 --> 00:27:49,920
Nou, n, wat n op dit moment?

569
00:27:49,920 --> 00:27:53,280
Ik kan kijken naar de lokale
variabelen in de debugger.

570
00:27:53,280 --> 00:27:53,816
n 0 is.

571
00:27:53,816 --> 00:27:55,190
Oké, wat was mijn conditie?

572
00:27:55,190 --> 00:27:58,700
>> 20-- lijn 20 is, nou ja,
0 is groter dan 0.

573
00:27:58,700 --> 00:27:59,500
Dat is niet waar.

574
00:27:59,500 --> 00:28:01,020
0 niet groter is dan 0.

575
00:28:01,020 --> 00:28:02,820
En dus ik brak uit deze.

576
00:28:02,820 --> 00:28:06,370
>> En dus dat is waarom on line
21, als ik eigenlijk voort te zetten,

577
00:28:06,370 --> 00:28:10,370
Ik ga om terug te keren 0, zelfs
hoewel ik zou hebben verworpen 0

578
00:28:10,370 --> 00:28:12,484
zo niet echt negatief.

579
00:28:12,484 --> 00:28:14,650
Dus nu, ik niet echt eens
zorg over de debugger.

580
00:28:14,650 --> 00:28:16,900
Kreeg het, ik hoef niet te
weet wat er nog meer aan de hand is.

581
00:28:16,900 --> 00:28:19,233
>> Dus ik ga om te gaan en
klikt u op de knop Afspelen,

582
00:28:19,233 --> 00:28:20,240
en laat deze eindigen.

583
00:28:20,240 --> 00:28:23,440
Nu, heb ik besefte dat mijn
bug is blijkbaar op lijn 20.

584
00:28:23,440 --> 00:28:25,160
Dat is mijn denkfout.

585
00:28:25,160 --> 00:28:28,100
>> En dus wat wil ik
te doen om dit te veranderen?

586
00:28:28,100 --> 00:28:32,500
Als het probleem is dat ik niet
het vangen van 0, het is gewoon een denkfout.

587
00:28:32,500 --> 00:28:35,910
En ik kan zeggen, terwijl n
groter dan of gelijk aan 0,

588
00:28:35,910 --> 00:28:38,330
houden opnieuw en opnieuw vragen aan de gebruiker.

589
00:28:38,330 --> 00:28:41,050
>> Dus nogmaals, eenvoudig fout, misschien
zelfs voor de hand als je me zag

590
00:28:41,050 --> 00:28:42,410
schrijf het maar een paar minuten geleden.

591
00:28:42,410 --> 00:28:44,570
Maar de afhaalmaaltijd hier
is dat met debug 50,

592
00:28:44,570 --> 00:28:46,850
en debugging
software algemeen,

593
00:28:46,850 --> 00:28:51,370
you have this nieuw gevonden macht aan
wandeling door uw eigen code, kijk

594
00:28:51,370 --> 00:28:55,590
via die rechts paneel wat
variabelen waarden zijn.

595
00:28:55,590 --> 00:28:57,700
Zodat je niet per se
hebben om iets te gebruiken

596
00:28:57,700 --> 00:29:00,630
alsof je eprintf om die waarden te drukken.

597
00:29:00,630 --> 00:29:04,430
Je kunt ze eigenlijk zien
visueel op het scherm.

598
00:29:04,430 --> 00:29:08,920
>> Nu, meer dan dit, het is vermeldenswaard
dat er een andere techniek die is

599
00:29:08,920 --> 00:29:09,890
eigenlijk super gemeen.

600
00:29:09,890 --> 00:29:13,120
En je kunt je afvragen waarom dit kleine
guy here is zittend op het podium.

601
00:29:13,120 --> 00:29:16,490
Dus er is deze techniek, in het algemeen
bekend als rubber duck debuggen,

602
00:29:16,490 --> 00:29:18,786
dat is eigenlijk gewoon een
bewijs van het feit

603
00:29:18,786 --> 00:29:20,660
dat vaak als programmeurs
het schrijven van code,

604
00:29:20,660 --> 00:29:22,650
ze zijn niet per se
samenwerken met anderen,

605
00:29:22,650 --> 00:29:24,030
of werken in een gedeelde omgeving.

606
00:29:24,030 --> 00:29:25,050
>> Ze zijn een soort van thuis.

607
00:29:25,050 --> 00:29:25,910
Misschien is het 's avonds laat.

608
00:29:25,910 --> 00:29:28,190
Ze proberen cijfer
enkele bug in hun code.

609
00:29:28,190 --> 00:29:29,330
En ze zijn gewoon niet te zien.

610
00:29:29,330 --> 00:29:30,329
>> En er is geen kamergenoot.

611
00:29:30,329 --> 00:29:31,250
Er is geen TF.

612
00:29:31,250 --> 00:29:32,680
Er is geen CA omgeving.

613
00:29:32,680 --> 00:29:36,440
Alles wat ze hebben op hun plank
is dit kleine rubber ducky.

614
00:29:36,440 --> 00:29:39,030
>> En dus badeend debugging
is gewoon deze uitnodiging

615
00:29:39,030 --> 00:29:42,780
te denken aan iets zo dom
aangezien dit als een echte wezen,

616
00:29:42,780 --> 00:29:46,940
en eigenlijk wandeling door uw code
verbaal op deze levenloos voorwerp.

617
00:29:46,940 --> 00:29:49,230
Dus, bijvoorbeeld, indien
dit is mijn voorbeeld hier--

618
00:29:49,230 --> 00:29:52,470
en herinneren eraan dat eerder
het probleem was dat,

619
00:29:52,470 --> 00:29:58,140
als ik dit eerste regel van de code te verwijderen,
en ik ga je gang en maak buggy 0 weer,

620
00:29:58,140 --> 00:30:01,220
herinneren dat ik had deze
foutmeldingen hier.

621
00:30:01,220 --> 00:30:05,997
Dus het idee hier, belachelijk hoewel ik
voelen op het moment dat dit te doen in het openbaar,

622
00:30:05,997 --> 00:30:06,580
is dat fout.

623
00:30:06,580 --> 00:30:10,910
>> OK, dus mijn probleem is dat ik heb
impliciet verklaarde een functie uit de bibliotheek.

624
00:30:10,910 --> 00:30:12,610
En die bibliotheek functie printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, verklaren
doet me denken aan prototypes.

626
00:30:15,290 --> 00:30:18,930
>> Dat betekent dat ik moet eigenlijk
vertel de compiler van tevoren wat

627
00:30:18,930 --> 00:30:19,980
de functie eruit ziet.

628
00:30:19,980 --> 00:30:20,930
Wacht even.

629
00:30:20,930 --> 00:30:23,580
Ik had geen standaard io.h.

630
00:30:23,580 --> 00:30:24,530
Veel dank.

631
00:30:24,530 --> 00:30:27,330
>> Dus dit proces van-- u
niet nodig om daadwerkelijk een eend.

632
00:30:27,330 --> 00:30:29,819
Maar dit idee van het lopen
uzelf via uw eigen code

633
00:30:29,819 --> 00:30:31,610
zodat je zelfs horen
jezelf, zodat je

634
00:30:31,610 --> 00:30:35,620
realiseren omissies in uw eigen
opmerkingen, doorgaans het idee.

635
00:30:35,620 --> 00:30:38,910
>> En, misschien wel meer logisch, niet zo
veel met die ene, maar de meer betrokken

636
00:30:38,910 --> 00:30:44,220
voorbeeld dat we net deed in buggy 3.c,
je zou je er doorheen lopen

637
00:30:44,220 --> 00:30:45,310
als volgt.

638
00:30:45,310 --> 00:30:49,190
Zo goed, rubber
ducky, DDB, als je wil.

639
00:30:49,190 --> 00:30:52,350
Hier hebben we in mijn belangrijkste functie,
Ik bel krijg negatief int.

640
00:30:52,350 --> 00:30:54,660
>> En ik krijg de return waarde.

641
00:30:54,660 --> 00:31:00,410
Ik doe het opslaan aan de linkerkant
op lijn 8 in een variabele met de naam i.

642
00:31:00,410 --> 00:31:02,380
OK, maar wacht, hoe heeft
die krijgen die waarde?

643
00:31:02,380 --> 00:31:04,130
Laat me kijken naar de functie in de lijn 12.

644
00:31:04,130 --> 00:31:05,760
>> In lijn 12, we hebben krijgen negatieve int.

645
00:31:05,760 --> 00:31:08,190
Heeft geen inputs te nemen,
retourneert een int, OK.

646
00:31:08,190 --> 00:31:10,929
Ik verklaar op lijn 14 een variabele n.

647
00:31:10,929 --> 00:31:12,220
Het gaat om een ​​geheel getal op te slaan.

648
00:31:12,220 --> 00:31:13,760
Dat is wat ik wil.

649
00:31:13,760 --> 00:31:18,480
>> Dus doe het volgende terwijl n is-- laten
me ongedaan maken wat de moeilijke situatie ik al gemaakt.

650
00:31:18,480 --> 00:31:22,710
Dus terwijl n groter is dan
0, uitprinten n is, OK.

651
00:31:22,710 --> 00:31:25,170
En dan noemen krijgen int opgeslagen in n.

652
00:31:25,170 --> 00:31:30,160
En dan controleren of n 0,
n is niet-- daar is het.

653
00:31:30,160 --> 00:31:31,910
Dus nogmaals, doe je niet
moet de werkelijke eend.

654
00:31:31,910 --> 00:31:35,650
Maar gewoon wandelen jezelf door
uw code als een intellectuele oefening

655
00:31:35,650 --> 00:31:37,720
zal vaak u helpen
beseffen wat er gaande is,

656
00:31:37,720 --> 00:31:41,170
in tegenstelling tot net iets te doen
als dit, staren naar het scherm,

657
00:31:41,170 --> 00:31:43,720
en niet praten jezelf door
is, die niet eerlijk

658
00:31:43,720 --> 00:31:46,270
bijna als een effectieve techniek.

659
00:31:46,270 --> 00:31:48,620
Dus daar heb je het, een
aantal verschillende technieken

660
00:31:48,620 --> 00:31:52,102
voor het daadwerkelijk debuggen uw code
en het vinden van fouten, die

661
00:31:52,102 --> 00:31:54,810
moet gereedschappen in uw toolkit
zodat je niet 's avonds laat,

662
00:31:54,810 --> 00:31:57,660
vooral, je bent in de eetzaal
zalen, of op kantooruren

663
00:31:57,660 --> 00:32:00,368
bonzen je hoofd tegen de
muur, in een poging om een ​​probleem op te lossen.

664
00:32:00,368 --> 00:32:02,020
Realiseer je dat er software tools.

665
00:32:02,020 --> 00:32:03,720
Er zijn rubber duck gereedschappen.

666
00:32:03,720 --> 00:32:09,630
En er is een hele staf van
ondersteuning te wachten om een ​​handje te helpen.

667
00:32:09,630 --> 00:32:13,120
>> Dus nu, een woord over het probleem
sets, en op wat we u hopen

668
00:32:13,120 --> 00:32:15,620
eruit te komen van hen, en hoe
we gaan evalueren.

669
00:32:15,620 --> 00:32:17,680
Per syllabus van de cursus,
CS50's probleem sets

670
00:32:17,680 --> 00:32:22,320
worden beoordeeld op vier primaire assen, dus
om de reikwijdte speak--, correctheid, ontwerp,

671
00:32:22,320 --> 00:32:23,060
en stijl.

672
00:32:23,060 --> 00:32:25,910
En reikwijdte gewoon verwijst naar hoe veel
van het stuk heb je gebeten?

673
00:32:25,910 --> 00:32:28,080
Hoeveel van een probleem heb je geprobeerd?

674
00:32:28,080 --> 00:32:30,110
Wat is het niveau van de inspanning
heb je gemanifesteerd?

675
00:32:30,110 --> 00:32:35,750
>> Correctheid is, doet het programma werk als
het zou moeten per CS50 specificatie

676
00:32:35,750 --> 00:32:38,640
wanneer u bepaalde ingangen
of bepaalde uitgangen terug te komen?

677
00:32:38,640 --> 00:32:41,130
Design is de meest subjectieve van hen.

678
00:32:41,130 --> 00:32:43,360
En het is degene die zal
neem de langste om te leren

679
00:32:43,360 --> 00:32:47,220
en de langste om les te geven, in
voor zover het op neer komt,

680
00:32:47,220 --> 00:32:49,530
hoe goed geschreven is je code?

681
00:32:49,530 --> 00:32:52,920
>> Het is één ding om alleen af ​​te drukken op de juiste
uitgangen of de terugkeer van de juiste waarden.

682
00:32:52,920 --> 00:32:55,400
Maar doe je het als
efficiënt mogelijk?

683
00:32:55,400 --> 00:32:58,210
Doe je het verdelen
en heers, of binaire

684
00:32:58,210 --> 00:33:01,500
zoekopdracht als we binnenkort zullen zien dat we dat deden
twee weken geleden met het telefoonboek?

685
00:33:01,500 --> 00:33:04,670
Zijn er betere manieren om het op te lossen
probleem dan u op dit moment hier?

686
00:33:04,670 --> 00:33:06,380
Dat is een kans voor een beter ontwerp.

687
00:33:06,380 --> 00:33:08,530
>> En dan style-- hoe
mooie is je code?

688
00:33:08,530 --> 00:33:12,370
U zult merken dat ik ben er vrij
bijzonder over inspringen mijn code,

689
00:33:12,370 --> 00:33:15,300
en ervoor te zorgen dat mijn variabelen
zijn redelijk genoemd. n,

690
00:33:15,300 --> 00:33:19,660
terwijl de korte, is een goede naam voor een
nummer, i een geheel getal tellen,

691
00:33:19,660 --> 00:33:20,727
s voor een string.

692
00:33:20,727 --> 00:33:22,560
En we kunnen meer hebben
variabelennamen stijl.

693
00:33:22,560 --> 00:33:25,500
Style is gewoon hoe goed
doet uw code eruit?

694
00:33:25,500 --> 00:33:26,600
En hoe leesbaar is het?

695
00:33:26,600 --> 00:33:29,650
>> En na verloop van tijd, wat uw TA
en TF's zal doen in de loop

696
00:33:29,650 --> 00:33:31,870
wordt u met dat
soort kwalitatieve feedback

697
00:33:31,870 --> 00:33:34,330
zodat je beter
op deze verschillende aspecten.

698
00:33:34,330 --> 00:33:37,510
En in termen van hoe we
evalueren elk van deze assen,

699
00:33:37,510 --> 00:33:40,080
Het is typisch met zeer weinig
emmers zodat u, in het algemeen,

700
00:33:40,080 --> 00:33:41,680
krijg je een gevoel van hoe goed je het doet.

701
00:33:41,680 --> 00:33:45,680
En inderdaad, als je krijgt een score op
een van deze axes-- correctheid, ontwerp

702
00:33:45,680 --> 00:33:49,659
en de stijl especially-- dat nummer
zal in het algemeen tussen 1 en 5.

703
00:33:49,659 --> 00:33:52,450
En, letterlijk, als je krijgt
3 bij het begin van het semester

704
00:33:52,450 --> 00:33:53,977
dit is een zeer goede zaak.

705
00:33:53,977 --> 00:33:55,810
Het betekent dat er nog steeds
ruimte voor verbetering,

706
00:33:55,810 --> 00:33:58,490
die je zou hopen in
nemen van een klasse voor het eerst.

707
00:33:58,490 --> 00:34:01,820
Er is hopelijk een aantal beetje plafond
waarop je streven naar het bereiken van.

708
00:34:01,820 --> 00:34:03,970
En zo krijgen 3 op
vroegste stukken,

709
00:34:03,970 --> 00:34:06,550
zo niet enige 2 en 4 is,
is inderdaad een goede zaak.

710
00:34:06,550 --> 00:34:08,880
Het is goed binnen het bereik,
valt binnen de verwachtingen.

711
00:34:08,880 --> 00:34:11,421
>> En als je geest is racen, wacht
een minuut, drie van de vijf.

712
00:34:11,421 --> 00:34:12,620
Dat is echt een 6 op 10.

713
00:34:12,620 --> 00:34:13,560
Dat is 60%.

714
00:34:13,560 --> 00:34:14,830
Mijn God, dat is een F.

715
00:34:14,830 --> 00:34:15,870
>> Het is niet.

716
00:34:15,870 --> 00:34:17,600
Het is niet, in feite, dat.

717
00:34:17,600 --> 00:34:22,710
Integendeel, het is een kans om te verbeteren
in de loop van het semester.

718
00:34:22,710 --> 00:34:25,580
En als je het krijgen van een aantal
poors, deze zijn een kans

719
00:34:25,580 --> 00:34:29,199
om te profiteren van de kantooruren,
zeker secties en andere hulpmiddelen.

720
00:34:29,199 --> 00:34:32,840
>> Best is een kans, echt,
trots op hoe ver je hebt te zijn

721
00:34:32,840 --> 00:34:34,520
komen in de loop van het semester.

722
00:34:34,520 --> 00:34:38,199
Dus beseffen, als er niets
anders, drie is goed.

723
00:34:38,199 --> 00:34:40,179
En het laat ruimte voor groei in de tijd.

724
00:34:40,179 --> 00:34:43,090
>> Met betrekking tot hoe die assen
gewogen, realistisch ben je

725
00:34:43,090 --> 00:34:46,745
gaat om de meeste van uw tijd te besteden krijgen
dingen om te werken, laat staan ​​correct.

726
00:34:46,745 --> 00:34:49,120
En zo juist neigt
gewogen de, zoals bij

727
00:34:49,120 --> 00:34:51,360
Deze vermenigvuldigingsfactor van drie.

728
00:34:51,360 --> 00:34:54,659
Het ontwerp is ook belangrijk, maar
iets dat je per se niet

729
00:34:54,659 --> 00:34:58,220
besteden al die uren op
proberen om dingen gewoon aan het werk.

730
00:34:58,220 --> 00:35:00,019
>> En dus het is gewogen
een beetje meer licht.

731
00:35:00,019 --> 00:35:01,560
En dan is de stijl is het minst gewogen.

732
00:35:01,560 --> 00:35:03,710
Ook al is het niet minder
belangrijk fundamenteel,

733
00:35:03,710 --> 00:35:05,990
het is gewoon misschien de
makkelijkste om te goed te doen,

734
00:35:05,990 --> 00:35:08,440
nabootsen voorbeelden we
doen in college en sectie,

735
00:35:08,440 --> 00:35:11,080
met de dingen mooi
ingesprongen, en becommentarieerd,

736
00:35:11,080 --> 00:35:14,320
enzovoort is de gemakkelijkst
dingen te doen en goed te krijgen.

737
00:35:14,320 --> 00:35:16,960
Dus als zodanig te realiseren
dat deze punten zijn

738
00:35:16,960 --> 00:35:19,000
die relatief eenvoudig te begrijpen.

739
00:35:19,000 --> 00:35:22,360
>> En nu een woord over
dit-- academische eerlijkheid.

740
00:35:22,360 --> 00:35:25,150
Dus per de cursus
syllabus, zul je zien

741
00:35:25,150 --> 00:35:27,630
dat de cursus heeft nogal een
bit van de taal rond dit.

742
00:35:27,630 --> 00:35:31,380
En de cursus neemt de kwestie van de
academische eerlijkheid heel serieus.

743
00:35:31,380 --> 00:35:33,450
>> We hebben het onderscheid,
in voor-en tegenspoed,

744
00:35:33,450 --> 00:35:36,570
te hebben verzonden elk jaar meer
studenten voor disciplinaire maatregelen

745
00:35:36,570 --> 00:35:39,670
dan de meeste andere
Natuurlijk, dat ik ben me bewust van.

746
00:35:39,670 --> 00:35:42,580
Dit is niet noodzakelijk
indicatief voor het feit

747
00:35:42,580 --> 00:35:46,340
dat CS studenten, of CS50 studenten, zijn
minder eerlijk dan je klasgenoten.

748
00:35:46,340 --> 00:35:49,090
Maar de realiteit dat deze
wereld, elektronisch, we gewoon

749
00:35:49,090 --> 00:35:50,990
hebben technologische
middelen voor het detecteren van deze.

750
00:35:50,990 --> 00:35:53,360
>> Het is belangrijk voor ons
eerlijkheid over de klas

751
00:35:53,360 --> 00:35:58,550
dat we op te sporen dit, en verhogen
de vraag wanneer we dingen zien.

752
00:35:58,550 --> 00:36:01,980
En alleen maar om een ​​beeld te schetsen, en echt
om iets te helpen als dit wastafel in,

753
00:36:01,980 --> 00:36:04,600
dit zijn de aantallen
studenten in de afgelopen 10 jaar

754
00:36:04,600 --> 00:36:07,610
die betrokken zijn bij sommige
dergelijke kwesties van de academische eerlijkheid,

755
00:36:07,610 --> 00:36:10,990
met ongeveer 32 leerlingen
vanaf najaar 2015, die

756
00:36:10,990 --> 00:36:13,760
is om te zeggen dat we doen nemen
de zaak zeer serieus.

757
00:36:13,760 --> 00:36:18,380
En uiteindelijk deze nummers samen,
laatstelijk ongeveer 3%, 4% of zo

758
00:36:18,380 --> 00:36:19,120
van de klas.

759
00:36:19,120 --> 00:36:25,220
>> Dus voor de super meerderheid van de studenten
het lijkt erop dat de lijnen duidelijk.

760
00:36:25,220 --> 00:36:27,940
Maar houd dit in
geest, in het bijzonder late

761
00:36:27,940 --> 00:36:32,080
's nachts wanneer worstelen met
enkele oplossing voor een probleem set,

762
00:36:32,080 --> 00:36:34,830
dat er mechanismen
voor het krijgen van jezelf beter

763
00:36:34,830 --> 00:36:37,870
ondersteuning dan je misschien
denken, zelfs op dat uur.

764
00:36:37,870 --> 00:36:40,514
Realiseer je dat wanneer we ontvangen
student inzendingen, steken we

765
00:36:40,514 --> 00:36:43,430
Vergelijk elke inzending dit jaar
tegen elke inzending van vorig jaar,

766
00:36:43,430 --> 00:36:47,590
tegen elke inzending van 2007,
en omdat, op zoek naar, maar ook,

767
00:36:47,590 --> 00:36:49,931
code repositories online,
discussiefora, jobsites.

768
00:36:49,931 --> 00:36:51,806
En we noemen dit,
echt, allemaal ter wille

769
00:36:51,806 --> 00:36:56,040
van volledige openbaarmaking, dat als
iemand anders kan het online vinden,

770
00:36:56,040 --> 00:36:57,880
zeker, dus kunnen we de cursus.

771
00:36:57,880 --> 00:37:00,100
Maar, echt, de geest
van de cursus neer

772
00:37:00,100 --> 00:37:01,650
om deze clausule in de syllabus.

773
00:37:01,650 --> 00:37:03,670
Het is eigenlijk gewoon, wees redelijk.

774
00:37:03,670 --> 00:37:06,680
>> En als we moesten werken op die
met slechts een beetje meer taal,

775
00:37:06,680 --> 00:37:09,770
beseffen dat de essentie van alle
werk dat u aan deze cursus

776
00:37:09,770 --> 00:37:10,954
moet uw eigen zijn.

777
00:37:10,954 --> 00:37:13,870
Maar binnen dat, er zijn zeker
kansen en aanmoediging,

778
00:37:13,870 --> 00:37:17,300
en pedagogische waarde in het draaien aan
others-- mezelf, de TF's, de CA's,

779
00:37:17,300 --> 00:37:20,760
de TAS, en anderen in de klas,
voor steun, laat staan ​​vrienden

780
00:37:20,760 --> 00:37:23,547
en huisgenoten die hebben gestudeerd
CS en programmering voor.

781
00:37:23,547 --> 00:37:25,130
En dus is er een vergoeding voor.

782
00:37:25,130 --> 00:37:28,180
En de algemene vuistregel
wordt dit-- bij zijn verzoek om hulp,

783
00:37:28,180 --> 00:37:31,470
kunt u uw code te laten zien aan anderen,
maar je mag hen niet zien.

784
00:37:31,470 --> 00:37:34,880
Dus zelfs als je toch bezig bent kantooruren,
of D zaal of elders

785
00:37:34,880 --> 00:37:37,450
werken aan een aantal delige set,
werken samen met een vriend, die

786
00:37:37,450 --> 00:37:40,160
is helemaal prima, op de
einde van de dag op uw werk

787
00:37:40,160 --> 00:37:43,034
Uiteindelijk moet behoren tot elke
van jullie respectievelijk, en niet

788
00:37:43,034 --> 00:37:45,700
een aantal gezamenlijke inspanning,
met uitzondering van het afstudeerproject, waar

789
00:37:45,700 --> 00:37:47,410
het is toegestaan ​​en wordt aangemoedigd.

790
00:37:47,410 --> 00:37:49,830
>> Realiseer je dat als je
worstelen met iets

791
00:37:49,830 --> 00:37:52,520
en uw vriend toevallig
beter in deze zijn dan u,

792
00:37:52,520 --> 00:37:55,130
of beter dat probleem dan jij,
of een beetje verder vooruit dan jij,

793
00:37:55,130 --> 00:37:57,330
het is volstrekt redelijk om te draaien
aan uw vriend en zeggen: hey,

794
00:37:57,330 --> 00:38:00,480
Vind je het erg naar mijn code hier,
helpt me herkennen wat mijn probleem is?

795
00:38:00,480 --> 00:38:03,760
En hopelijk in de
belang van de pedagogische waarde

796
00:38:03,760 --> 00:38:07,040
die vriend niet alleen
zeggen, oh, doe dit, maar eerder,

797
00:38:07,040 --> 00:38:09,917
Wat mist u op de lijn
6, of iets dergelijks?

798
00:38:09,917 --> 00:38:12,000
Maar de oplossing is niet
voor de vriend naast je

799
00:38:12,000 --> 00:38:15,617
te zeggen, oh, nou ja, hier, laat me trekken
dit, en toon mijn oplossing voor jou.

800
00:38:15,617 --> 00:38:16,450
Dus dat is de lijn.

801
00:38:16,450 --> 00:38:18,670
U toont uw code te
anderen, maar je mag niet

802
00:38:18,670 --> 00:38:22,350
bekijken van hen, onder voorbehoud van de andere
beperkingen in syllabus van de cursus.

803
00:38:22,350 --> 00:38:24,760
>> Dus maak je in gedachten houden deze
zogenaamde spijt clausule

804
00:38:24,760 --> 00:38:27,560
in syllabus van de cursus zo goed,
dat als je commit enkele handeling die

805
00:38:27,560 --> 00:38:30,476
is niet redelijk, maar breng het naar
de aandacht van de hoofden van de cursus

806
00:38:30,476 --> 00:38:34,240
binnen 72 uur, de cursus
eventueel sancties op te leggen dat

807
00:38:34,240 --> 00:38:37,380
kan een onbevredigende omvatten of
falende cijfer voor het ingediende werk.

808
00:38:37,380 --> 00:38:41,410
Maar de cursus zal niet verwijzen
zaak voor verdere disciplinaire maatregelen,

809
00:38:41,410 --> 00:38:43,010
behalve in gevallen van herhaalde handelingen.

810
00:38:43,010 --> 00:38:46,632
Met andere woorden, als je zelf een
dom, vooral 's avonds laat, besluit

811
00:38:46,632 --> 00:38:49,340
dat de volgende ochtend of twee dagen
later, je wordt wakker en beseffen,

812
00:38:49,340 --> 00:38:50,870
Wat dacht ik?

813
00:38:50,870 --> 00:38:53,890
Je doet in CS50 hebben een stopcontact
voor de vaststelling van dat probleem

814
00:38:53,890 --> 00:38:57,170
en bezit er naar toe, zodat we
zul je halverwege ontmoeten en aan te pakken

815
00:38:57,170 --> 00:39:01,500
met in een zaak die zowel
educatieve en waardevol voor u,

816
00:39:01,500 --> 00:39:04,200
maar nog steeds bestraffend op een bepaalde manier.

817
00:39:04,200 --> 00:39:08,590
En nu, aan de rand opstijgen, dit.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO AFSPELEN]

819
00:39:10,570 --> 00:39:13,540
>> [Muziek]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END AFSPELEN]

822
00:39:58,866 --> 00:40:00,490
DAVID J. MALAN: Oké, we zijn terug.

823
00:40:00,490 --> 00:40:03,680
En nu kijken we naar één van de
eerste van onze echte wereld domeinen

824
00:40:03,680 --> 00:40:08,720
in CS50, de kunst van cryptografie,
de kunst van het verzenden en ontvangen

825
00:40:08,720 --> 00:40:11,840
geheime boodschappen, versleutelde
berichten als je wil,

826
00:40:11,840 --> 00:40:17,060
dat kan alleen worden ontcijferd als u
een aantal belangrijke ingrediënt dat de afzender heeft

827
00:40:17,060 --> 00:40:18,030
ook.

828
00:40:18,030 --> 00:40:22,120
Dus om dit te motiveren we zullen nemen
Een blik op dit ding hier,

829
00:40:22,120 --> 00:40:26,750
dat een voorbeeld van een
geheime decoder ring die

830
00:40:26,750 --> 00:40:34,042
kan worden gebruikt om te achterhalen
wat een geheime boodschap eigenlijk is.

831
00:40:34,042 --> 00:40:35,750
In feite, terug in de
dag op de lagere school,

832
00:40:35,750 --> 00:40:38,787
als je ooit geheime boodschappen verzonden naar
sommige vriend of een oogje in de klas,

833
00:40:38,787 --> 00:40:40,620
je zou hebben gedacht
dat je slim zijn

834
00:40:40,620 --> 00:40:46,530
door op uw stuk papier veranderen,
zoals, A naar B en B naar C en C naar D,

835
00:40:46,530 --> 00:40:47,590
enzovoorts.

836
00:40:47,590 --> 00:40:50,300
Maar je was eigenlijk versleutelen
uw informatie, zelfs

837
00:40:50,300 --> 00:40:53,300
als het een beetje triviaal, was niet
dat moeilijk voor de leraar om te beseffen,

838
00:40:53,300 --> 00:40:55,675
Nou, als je gewoon veranderen
B naar A en C naar B,

839
00:40:55,675 --> 00:40:57,550
je eigenlijk uitzoeken
wat de boodschap was,

840
00:40:57,550 --> 00:40:59,700
maar je was in het coderen van gegevens.

841
00:40:59,700 --> 00:41:03,420
>> Je was gewoon doen
gewoon, net als Ralphie hier

842
00:41:03,420 --> 00:41:07,934
in een beroemde film die speelt
vrij veel tot vervelens toe elke winter.

843
00:41:07,934 --> 00:41:08,600
[VIDEO AFSPELEN]

844
00:41:08,600 --> 00:41:11,180
-Wees Bekend om al dat
Ralph Parker is hierbij

845
00:41:11,180 --> 00:41:14,070
benoemd tot lid van de Kleine
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
en heeft recht op alle eer
en voordelen welke ontstaan.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
-Counter ondertekend Pierre Andre, met inkt.

848
00:41:24,340 --> 00:41:27,160
Eer en voordelen,
al op de leeftijd van negen.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [SCHREEUWEN]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Kom op.

853
00:41:34,250 --> 00:41:35,210
Laten we aan de slag gaan.

854
00:41:35,210 --> 00:41:39,530
Ik geloof niet alles wat jazz nodig
over smokkelaars en piraten.

855
00:41:39,530 --> 00:41:41,660
>> -listen Morgenavond voor
de afsluitende avontuur

856
00:41:41,660 --> 00:41:43,880
van de zwarte piratenschip.

857
00:41:43,880 --> 00:41:46,650
Nu is het tijd voor
geheime boodschap Annie's

858
00:41:46,650 --> 00:41:49,840
voor u de leden van de Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Vergeet niet, kinderen, alleen voor leden
van Annie's Secret Circle

860
00:41:53,570 --> 00:41:56,140
kan Annie's geheime boodschap te ontcijferen.

861
00:41:56,140 --> 00:42:00,340
>> Vergeet niet, Annie is afhankelijk van je.

862
00:42:00,340 --> 00:42:02,880
Stel je pinnen om B2.

863
00:42:02,880 --> 00:42:05,230
Hier is de boodschap.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Ik Ben, mijn eerste geheime vergadering.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Was in grote stem vanavond.

868
00:42:15,780 --> 00:42:19,000
Ik kon vertellen dat vanavond
boodschap was heel belangrijk.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, dat is een boodschap
van Annie zichzelf.

870
00:42:22,694 --> 00:42:23,860
Vergeet niet, niet verder vertellen.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Seconden later, ik ben in de enige
kamer in het huis, waar een jongetje van negen

873
00:42:32,930 --> 00:42:37,040
in privacy en decoderen kon zitten.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Ik ging naar de volgende, E.

876
00:42:42,360 --> 00:42:44,520
>> Het eerste woord is.

877
00:42:44,520 --> 00:42:49,032
S, werd het aankomen makkelijker nu, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Oh, kom op, Ralphie, ik moet gaan!

879
00:42:51,733 --> 00:42:53,688
>> -Ik Recht naar beneden, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee whiz!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, zeker to-- moet u wat?

883
00:43:04,060 --> 00:43:05,970
Wat was Little Orphan
Annie probeer te zeggen?

884
00:43:05,970 --> 00:43:07,264
Zorg ervoor dat u wat?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy heeft te
gaan, wilt u alstublieft naar buiten komen?

886
00:43:09,634 --> 00:43:10,480
>> -Alle Recht, Ma!

887
00:43:10,480 --> 00:43:12,880
Ik kom uit zijn!

888
00:43:12,880 --> 00:43:14,550
>> -Ik Was nu dichterbij krijgt.

889
00:43:14,550 --> 00:43:16,620
De spanning was verschrikkelijk.

890
00:43:16,620 --> 00:43:17,720
Wat was het?

891
00:43:17,720 --> 00:43:20,170
Het lot van de planeet
kan hangen in de balans.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy's gotta go!

894
00:43:23,170 --> 00:43:26,890
>> -Ik Rechts uit, voor schreeuwt luid!

895
00:43:26,890 --> 00:43:32,680
>> -bijna Er, vloog mijn vingers, mijn geest
was een stalen val, elke porie getrild.

896
00:43:32,680 --> 00:43:37,198
Het was bijna duidelijk, ja, ja, ja.

897
00:43:37,198 --> 00:43:43,091
>> -Zorg Ervoor dat u uw Ovaltine drinken.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Een slordig uit commercieel?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Klootzak.

903
00:43:54,227 --> 00:43:54,810
[END AFSPELEN]

904
00:43:54,810 --> 00:43:57,390
DAVID J. MALAN: OK, dus
dat was een zeer lange weg

905
00:43:57,390 --> 00:44:00,660
invoering cryptografie,
en ook Ovaltine.

906
00:44:00,660 --> 00:44:04,470
In feite, van deze oude advertentie
hier, waarom is ovaltine zo goed?

907
00:44:04,470 --> 00:44:09,470
Het is een geconcentreerde extractie van rijpe
gerstemout, melk pure romig koe,

908
00:44:09,470 --> 00:44:14,360
en speciaal geprepareerde cacao, samen
met natuurlijke fosfatiden en vitaminen.

909
00:44:14,360 --> 00:44:18,240
Verder wordt verrijkt met
extra vitamine B en D, yum.

910
00:44:18,240 --> 00:44:21,600
En je kunt nog steeds het, blijkbaar,
op Amazon, zoals wij deden hier.

911
00:44:21,600 --> 00:44:24,810
>> Maar de motivatie was de bedoeling
invoering van cryptografie, in het bijzonder

912
00:44:24,810 --> 00:44:28,340
een type cryptografie bekende
als geheime sleutel cryptografie.

913
00:44:28,340 --> 00:44:34,284
En zoals de naam al doet vermoeden, de hele
veiligheid van een geheime sleutel crypto-systeem,

914
00:44:34,284 --> 00:44:36,200
als je wil, een methodologie
voor slechts versluiering

915
00:44:36,200 --> 00:44:40,960
informatie tussen twee mensen, is dat
alleen de zender en alleen de ontvanger

916
00:44:40,960 --> 00:44:46,980
weet een geheim key-- wat waarde, wat
geheime zin, een geheim nummer, dat

917
00:44:46,980 --> 00:44:50,660
kunnen ze allebei coderen
en decoderen van informatie.

918
00:44:50,660 --> 00:44:53,470
En cryptografie, echt,
is alleen deze vanaf week 0.

919
00:44:53,470 --> 00:44:56,715
>> Het is een probleem waar er inputs,
als de werkelijke boodschap in het Engels

920
00:44:56,715 --> 00:44:59,340
of welke taal die u
wilt sturen naar iemand in de klas,

921
00:44:59,340 --> 00:45:00,580
of via het internet.

922
00:45:00,580 --> 00:45:03,840
Er is enige uitgang die gaat
om de gecodeerde boodschap zijn dat u

923
00:45:03,840 --> 00:45:05,250
willen de ontvanger te ontvangen.

924
00:45:05,250 --> 00:45:07,405
En zelfs als iemand in de
midden krijgt het ook,

925
00:45:07,405 --> 00:45:09,780
je ze niet willen
noodzakelijkerwijs in staat zijn om het te ontcijferen,

926
00:45:09,780 --> 00:45:12,840
want binnen dit
black box, of algoritme,

927
00:45:12,840 --> 00:45:17,650
is een mechanisme, wat stapsgewijs
instructies voor het nemen van die ingang

928
00:45:17,650 --> 00:45:20,710
en om te zetten in de
output, in hopelijk een veilige manier.

929
00:45:20,710 --> 00:45:23,640
>> En in feite is er een aantal
woordenschat in deze wereld als volgt.

930
00:45:23,640 --> 00:45:26,100
Platte tekst is het woord een
computer wetenschapper zou

931
00:45:26,100 --> 00:45:28,449
om de input beschrijven
bericht, zoals het Engels

932
00:45:28,449 --> 00:45:31,240
of welke taal je eigenlijk
wilt verzenden naar een ander mens.

933
00:45:31,240 --> 00:45:35,450
En dan is de cijfertekst is de scramble
de vercijferde of versleuteld,

934
00:45:35,450 --> 00:45:36,520
versie ervan.

935
00:45:36,520 --> 00:45:38,750
>> Maar er is een ander ingrediënt hier.

936
00:45:38,750 --> 00:45:43,200
Er is nog een andere ingang te
geheime sleutel cryptografie.

937
00:45:43,200 --> 00:45:45,200
En dat is de sleutel zelf,
die algemeen

938
00:45:45,200 --> 00:45:48,930
zoals we zullen zien, een getal, of
letter of woord, ongeacht

939
00:45:48,930 --> 00:45:51,980
het algoritme is eigenlijk verwacht.

940
00:45:51,980 --> 00:45:53,870
>> En hoe krijg je informatie te ontcijferen?

941
00:45:53,870 --> 00:45:55,110
Hoe krijg je het decoderen?

942
00:45:55,110 --> 00:45:57,950
Nou, je gewoon achteruit de
uitgangen en ingangen.

943
00:45:57,950 --> 00:46:00,900
>> Met andere woorden, zodra iemand
ontvangt uw gecodeerd bericht,

944
00:46:00,900 --> 00:46:03,740
hij of zij moet gewoon
diezelfde sleutel kennen.

945
00:46:03,740 --> 00:46:05,700
Zij hebben de versleutelde tekst ontvangen.

946
00:46:05,700 --> 00:46:09,530
En door de stekker die twee
input in het crypto-systeem,

947
00:46:09,530 --> 00:46:14,260
het algoritme, deze zwarte doos, uit
moet de oorspronkelijke plaintext komen.

948
00:46:14,260 --> 00:46:17,830
En dat is dus de zeer hoog niveau
Gezien wat cryptografie is eigenlijk

949
00:46:17,830 --> 00:46:18,590
alles over.

950
00:46:18,590 --> 00:46:20,030
>> Dus laten we daar te komen.

951
00:46:20,030 --> 00:46:22,700
Laten we nu eens kijken eronder
de kap van iets

952
00:46:22,700 --> 00:46:26,000
we hebben als vanzelfsprekend voor
de afgelopen week, en voor deze sessie

953
00:46:26,000 --> 00:46:27,629
hier-- de string.

954
00:46:27,629 --> 00:46:30,295
Een tekenreeks aan het einde van de dag
is gewoon een reeks tekens.

955
00:46:30,295 --> 00:46:33,610
>> Het is misschien hello wereld, of
hello Zamyla, of wat dan ook.

956
00:46:33,610 --> 00:46:37,050
Maar wat betekent dat voor
zijn een reeks tekens?

957
00:46:37,050 --> 00:46:41,520
In feite is de CS50 bibliotheek geeft
ons een datatype genaamd string.

958
00:46:41,520 --> 00:46:45,140
>> Maar er is eigenlijk geen
zoiets als een string in C.

959
00:46:45,140 --> 00:46:49,450
Het is eigenlijk gewoon een opeenvolging van
karakter, karakter, karakter,

960
00:46:49,450 --> 00:46:52,180
karakter, terug, naar achter, naar
terug, naar achter, naar binnen te steunen

961
00:46:52,180 --> 00:46:54,650
van het geheugen van uw computer, of RAM.

962
00:46:54,650 --> 00:46:58,940
En we dieper in dat er in de
toekomst, wanneer we kijken naar het geheugen zelf,

963
00:46:58,940 --> 00:47:02,030
en het gebruik en de
bedreigingen die betrokken zijn.

964
00:47:02,030 --> 00:47:04,100
>> Maar laten we eens kijken naar de string Zamyla.

965
00:47:04,100 --> 00:47:07,480
Dus gewoon de naam van
de mens hier, Zamyla,

966
00:47:07,480 --> 00:47:12,030
dat een reeks
karakters, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
En laten we nu eens veronderstellen dat de naam Zamyla's
wordt opgeslagen in een computer

968
00:47:16,020 --> 00:47:16,880
programma.

969
00:47:16,880 --> 00:47:20,830
>> Nou, is het logisch dat we moeten
in staat zijn om te kijken naar deze tekens

970
00:47:20,830 --> 00:47:21,590
individueel.

971
00:47:21,590 --> 00:47:24,710
Dus ik ga gewoon om een ​​beetje te trekken
box rond de naam Zamyla's hier.

972
00:47:24,710 --> 00:47:31,580
En het is het geval in C dat bij
hebben een string, zoals Zamyla-- en misschien

973
00:47:31,580 --> 00:47:34,940
die string is terug uit te komen
een functie als get koord,

974
00:47:34,940 --> 00:47:38,540
je kunt eigenlijk te manipuleren
Het teken voor teken.

975
00:47:38,540 --> 00:47:42,070
>> Nu is dit germane de
gesprek bij de hand, want

976
00:47:42,070 --> 00:47:46,420
in cryptografie als je wilt veranderen
A naar B en B naar C en C naar D,

977
00:47:46,420 --> 00:47:49,650
enzovoort, moet je in staat zijn
te kijken naar de individuele personages

978
00:47:49,650 --> 00:47:50,190
in een koord.

979
00:47:50,190 --> 00:47:52,695
Je moet in staat zijn om te veranderen
de Z iets anders, de A

980
00:47:52,695 --> 00:47:55,280
om iets anders, de M te
iets anders, enzovoort.

981
00:47:55,280 --> 00:47:58,000
En dus moeten we een manier,
programmatisch, dus

982
00:47:58,000 --> 00:48:03,020
spreken in C te kunnen veranderen
en kijk naar de afzonderlijke letters.

983
00:48:03,020 --> 00:48:05,690
En we kunnen dit als volgt doen.

984
00:48:05,690 --> 00:48:08,340
>> Laat me gaan hoofd terug in CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
En laat me ga je gang
en maak een nieuw bestand

986
00:48:11,130 --> 00:48:16,134
dat ik deze keer string0 zullen noemen,
als onze eerste voorbeeld daarvan, punt c.

987
00:48:16,134 --> 00:48:18,300
En ik ga om verder te gaan
en zweep het als volgt.

988
00:48:18,300 --> 00:48:22,870
>> Zo zijn onder andere CS50.h, en
dan zijn standaard io.h,

989
00:48:22,870 --> 00:48:25,990
die ik ben bijna altijd gaat om
worden met behulp van in mijn programma's, op zijn minst

990
00:48:25,990 --> 00:48:26,780
aanvankelijk.

991
00:48:26,780 --> 00:48:32,180
int main leegte, en dan hier ben ik
gaat strings doen krijgt krijgen string.

992
00:48:32,180 --> 00:48:35,260
En dan ga ik
ga je gang en dit te doen.

993
00:48:35,260 --> 00:48:37,460
Ik wil doorgaan
en, als een sanity check,

994
00:48:37,460 --> 00:48:43,607
gewoon zeggen, hello, procent s,
puntkomma, maakt snaar 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, wat heb ik hier doen?

996
00:48:44,690 --> 00:48:45,930
Oh, ik heb niet stekker in het stopcontact.

997
00:48:45,930 --> 00:48:48,120
Dus les geleerd, dat
was niet opzettelijk.

998
00:48:48,120 --> 00:48:52,480
>> Dus fout, meer procent
conversies dan data argumenten.

999
00:48:52,480 --> 00:48:54,940
En dit is waar, in
lijn 7-- OK, dus ik heb,

1000
00:48:54,940 --> 00:48:56,690
citaat unquote, dat is
mijn string printf.

1001
00:48:56,690 --> 00:48:58,151
Ik heb een procent teken.

1002
00:48:58,151 --> 00:48:59,650
Maar ik ben het tweede argument ontbreekt.

1003
00:48:59,650 --> 00:49:03,190
>> Ik mis de komma's, die
Ik had in de voorgaande voorbeelden.

1004
00:49:03,190 --> 00:49:06,650
Dus een goede gelegenheid om vast te stellen
nog een fout, ongeluk.

1005
00:49:06,650 --> 00:49:09,950
En nu laat me lopen
string0, typ Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, hello Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Dus we hebben dit soort programma uit te voeren
een paar verschillende keren.

1008
00:49:14,144 --> 00:49:16,310
Maar laten we iets doen een
beetje anders deze keer.

1009
00:49:16,310 --> 00:49:19,450
In plaats van alleen het afdrukken van Zamyla's
hele naam met printf,

1010
00:49:19,450 --> 00:49:21,350
laten we het teken voor teken.

1011
00:49:21,350 --> 00:49:22,700
>> Ik ga een te gebruiken voor lus.

1012
00:49:22,700 --> 00:49:26,160
En ik ga mezelf te geven
een telling variabele, genaamd i.

1013
00:49:26,160 --> 00:49:33,530
En ik ga iteratie te houden, zodat
zolang i kleiner is dan de lengte van s.

1014
00:49:33,530 --> 00:49:35,930
>> Het blijkt, hebben we niet
doe dit laatste keer,

1015
00:49:35,930 --> 00:49:39,100
dat c wordt geleverd met een
functie genaamd Stirling.

1016
00:49:39,100 --> 00:49:42,690
Terug in de dag, en in het algemeen
nog steeds bij de uitvoering van functies,

1017
00:49:42,690 --> 00:49:45,405
mensen zullen kiezen vaak zeer
beknopte namen die soort geluid

1018
00:49:45,405 --> 00:49:48,280
als wat je wilt, zelfs al is het
het missen van een paar klinkers of letters.

1019
00:49:48,280 --> 00:49:50,660
Dus is de Stirling
de naam van een functie die

1020
00:49:50,660 --> 00:49:53,880
neemt een ruzie tussen
haakjes een tekenreeks moet zijn.

1021
00:49:53,880 --> 00:49:56,910
En het net retourneert een integer,
de lengte van deze draad.

1022
00:49:56,910 --> 00:50:00,580
>> Dus deze lus op lijn 7 gaat
om te beginnen met het tellen van i gelijk is aan 0.

1023
00:50:00,580 --> 00:50:02,530
Het zal verhogen
i op elke iteratie

1024
00:50:02,530 --> 00:50:04,350
met 1, zoals we hebben gedaan een paar keer.

1025
00:50:04,350 --> 00:50:06,780
Maar het gaat om alleen te doen
dit tot het moment

1026
00:50:06,780 --> 00:50:09,660
toen ik de lengte
van het koord zelf.

1027
00:50:09,660 --> 00:50:14,520
>> Dit is dus een manier uiteindelijk
itereren over de personages

1028
00:50:14,520 --> 00:50:17,430
in de string als volgt zeggen.

1029
00:50:17,430 --> 00:50:20,670
Ik ga niet uit te drukken een
hele reeks, maar procent c,

1030
00:50:20,670 --> 00:50:22,860
een enkel teken
gevolgd door een nieuwe regel.

1031
00:50:22,860 --> 00:50:24,880
En dan ga ik
ga je gang, en ik moet

1032
00:50:24,880 --> 00:50:29,080
te zeggen dat ik wil afdrukken
ide karakter van s.

1033
00:50:29,080 --> 00:50:33,450
>> Dus als ik is de variabele die aangeeft
de index van de tekenreeks, waarbij

1034
00:50:33,450 --> 00:50:37,230
u bent in het, moet ik in staat zijn om
zeggen, geef mij de i-karakter van s.

1035
00:50:37,230 --> 00:50:40,390
En c heeft een manier van doen
dit met vierkante haken.

1036
00:50:40,390 --> 00:50:43,679
Je zegt gewoon de naam van de
tekenreeks, die in dit geval is s.

1037
00:50:43,679 --> 00:50:46,970
Dan vierkante haakjes, welke gebruikt u
meestal net boven uw Return of Enter

1038
00:50:46,970 --> 00:50:48,110
toets op het toetsenbord.

1039
00:50:48,110 --> 00:50:52,410
En dan zet je de index van de
teken dat u wilt afdrukken.

1040
00:50:52,410 --> 00:50:55,960
Dus de index gaat om een ​​te zijn
number-- 0 of 1 of 2 of 3 of dot

1041
00:50:55,960 --> 00:50:57,590
dot, dot, een ander nummer.

1042
00:50:57,590 --> 00:51:00,920
>> En zorgen we ervoor dat het gaat om
zijn het juiste aantal, want ik

1043
00:51:00,920 --> 00:51:02,360
beginnen te tellen bij 0.

1044
00:51:02,360 --> 00:51:07,020
En door gebrek, het eerste teken
in een string is volgens afspraak 0.

1045
00:51:07,020 --> 00:51:09,230
En de tweede personage is beugel 1.

1046
00:51:09,230 --> 00:51:11,120
En het derde teken is beugel 2.

1047
00:51:11,120 --> 00:51:13,630
En je wilt niet te gaan
ver, maar we zullen niet omdat we

1048
00:51:13,630 --> 00:51:17,780
zal alleen i incrementeren totdat
gelijk aan de lengte van de snaar.

1049
00:51:17,780 --> 00:51:20,210
En op welk punt,
Deze lus zal stoppen.

1050
00:51:20,210 --> 00:51:25,550
>> Dus laat me ga je gang en bewaar deze
programma en run te maken snaar 0.

1051
00:51:25,550 --> 00:51:28,400
Maar Ik heb het verknald.

1052
00:51:28,400 --> 00:51:35,390
Impliciet verklaren bibliotheekfunctie
Stirling met type zodanig en such-- nu,

1053
00:51:35,390 --> 00:51:36,430
dit klinkt bekend.

1054
00:51:36,430 --> 00:51:37,440
Maar het is niet printf.

1055
00:51:37,440 --> 00:51:38,540
En het is niet snaar te krijgen.

1056
00:51:38,540 --> 00:51:40,480
>> Ik heb niet verpest in
net ditmaal.

1057
00:51:40,480 --> 00:51:45,100
Maar let hier beneden een beetje naar beneden
verder, onder de kop string.h,

1058
00:51:45,100 --> 00:51:47,210
uitdrukkelijk de
verklaring voor Stirling.

1059
00:51:47,210 --> 00:51:48,820
Er is dus eigenlijk een aanwijzing in.

1060
00:51:48,820 --> 00:51:51,670
>> En inderdaad, het blijkt
er is nog een header-bestand

1061
00:51:51,670 --> 00:51:53,970
dat we niet hebben gebruikt
in de klas nog niet, maar het is

1062
00:51:53,970 --> 00:51:56,480
Onder de beschikbare
aan u, de zogenaamde string.h.

1063
00:51:56,480 --> 00:52:00,930
En in dat bestand, string.h
Stirling is verklaard.

1064
00:52:00,930 --> 00:52:05,220
Dus laat me ga je gang en
bewaar deze, maken koord

1065
00:52:05,220 --> 00:52:08,040
0-- nice, geen foutmeldingen deze tijd.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, en
Ik ben over te druk op Enter,

1067
00:52:12,290 --> 00:52:16,710
op welk punt getString gaat
om de string terug, zet het in 's.

1068
00:52:16,710 --> 00:52:21,890
Dan is dat voor de lus gaat herhalen
meer dan S personages een voor een,

1069
00:52:21,890 --> 00:52:28,420
en print ze één per regel, omdat
Ik had dat backslash n aan het eind.

1070
00:52:28,420 --> 00:52:34,530
Dus ik kon dat backslash weglaten
n, en dan gewoon afdrukken Zamyla alle

1071
00:52:34,530 --> 00:52:37,460
in dezelfde lijn,
effectief herimplementeren

1072
00:52:37,460 --> 00:52:38,999
printf, dat niet alles nuttig.

1073
00:52:38,999 --> 00:52:40,540
Maar in dit geval heb ik niet gedaan.

1074
00:52:40,540 --> 00:52:43,610
Ik heb eigenlijk afgedrukt,
karakter per keer, één per regel,

1075
00:52:43,610 --> 00:52:45,400
zodat we eigenlijk zien het effect.

1076
00:52:45,400 --> 00:52:46,900
>> Maar ik moet één ding hier rekening mee.

1077
00:52:46,900 --> 00:52:48,930
En we zullen terugkomen naar
dit in een toekomstige week.

1078
00:52:48,930 --> 00:52:52,650
Het blijkt dat deze
code is potentieel buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Het blijkt dat get snaar
en enkele andere functies in het leven

1080
00:52:56,560 --> 00:53:00,280
niet per se altijd
terug wat je verwacht.

1081
00:53:00,280 --> 00:53:03,010
We weten uit de klas laatste
tijd in deze, dat krijgen

1082
00:53:03,010 --> 00:53:04,960
snaar wordt verondersteld om een ​​string terug te keren.

1083
00:53:04,960 --> 00:53:09,900
Maar wat als de gebruiker typt dergelijke
een lang woord, of paragraaf of essay

1084
00:53:09,900 --> 00:53:13,010
dat er gewoon niet genoeg
geheugen in de computer te passen.

1085
00:53:13,010 --> 00:53:15,410
>> Net als, wat als er iets
verkeerde onder de motorkap?

1086
00:53:15,410 --> 00:53:18,400
Het is misschien niet vaak,
maar het kan een keer gebeuren

1087
00:53:18,400 --> 00:53:21,520
in een tijd, zeer zelden.

1088
00:53:21,520 --> 00:53:25,460
En zo blijkt dat get snaar
en functies als het niet per se

1089
00:53:25,460 --> 00:53:26,380
altijd terugkeren strings.

1090
00:53:26,380 --> 00:53:30,680
Ze kunnen terugkeren een fout waarde,
sommige sentinel waarde om zo te zeggen,

1091
00:53:30,680 --> 00:53:32,612
die aangeeft dat
er is iets misgegaan.

1092
00:53:32,612 --> 00:53:35,320
En je zou alleen dit weten uit
zij hebben geleerd in de klas nu,

1093
00:53:35,320 --> 00:53:37,700
of wat meer documentatie gelezen.

1094
00:53:37,700 --> 00:53:43,120
Het blijkt dat get snaar
kan een waarde genaamd null terug te keren.

1095
00:53:43,120 --> 00:53:46,220
Null is een speciale waarde die we zullen
terug te komen in een toekomstige week.

1096
00:53:46,220 --> 00:53:50,420
Maar voor nu, weet alleen dat als ik wil
echt een goede in vooruit te zijn

1097
00:53:50,420 --> 00:53:52,650
met behulp get koord, I
moet niet alleen het noemen,

1098
00:53:52,650 --> 00:53:56,870
en blindelings gebruik maken van haar return waarde,
vertrouwend dat het een string.

1099
00:53:56,870 --> 00:53:59,420
>> Ik moet eerst zeggen,
Hé, wacht eens even, alleen

1100
00:53:59,420 --> 00:54:03,380
verder als s niet gelijk
null, waarbij null, nogmaals,

1101
00:54:03,380 --> 00:54:04,660
is slechts enkele bijzondere waarde.

1102
00:54:04,660 --> 00:54:07,770
En het is de enige bijzondere waarde die u
hoeft te maken over voor te krijgen string.

1103
00:54:07,770 --> 00:54:10,900
Krijg snaar is ofwel gaat
naar een string of null terug te keren.

1104
00:54:10,900 --> 00:54:17,219
>> En dit uitroepteken gelijk-teken
u misschien kent van misschien mathklasse

1105
00:54:17,219 --> 00:54:20,510
dat je een isgelijkteken zou kunnen tekenen met
een streep erdoor om niet gelijk te geven.

1106
00:54:20,510 --> 00:54:23,135
Dat is over het algemeen niet een personage
u kunt typen op het toetsenbord.

1107
00:54:23,135 --> 00:54:26,480
En dus in de meeste programmeertalen,
wanneer u wilt niet gelijk zeggen,

1108
00:54:26,480 --> 00:54:29,160
u gebruik maken van een uitroepteken,
oftewel knal.

1109
00:54:29,160 --> 00:54:33,180
Dus je zegt bang is gelijk aan die
betekent niet gelijk, logisch.

1110
00:54:33,180 --> 00:54:38,060
Het is net alsof er geen grotere
dan, of gelijk aan, of kleiner dan

1111
00:54:38,060 --> 00:54:41,270
of gelijk in te toetsen op je toetsenbord
dat doet het allemaal in één symbool.

1112
00:54:41,270 --> 00:54:44,020
Dus dat is de reden waarom, in het verleden voorbeelden,
je hebt een open beugel, en dan

1113
00:54:44,020 --> 00:54:48,670
een isgelijkteken, om te doen
groter dan of, zeg, minder dan.

1114
00:54:48,670 --> 00:54:49,910
>> Dus wat is het hier mee te nemen?

1115
00:54:49,910 --> 00:54:53,880
Dit is gewoon een manier om nu uit
de introductie van deze syntax, deze functie,

1116
00:54:53,880 --> 00:54:57,390
itereren voor individuele
tekens in een tekenreeks.

1117
00:54:57,390 --> 00:55:00,260
En net als die square
beugels kunt u bij hen te krijgen,

1118
00:55:00,260 --> 00:55:03,790
rekening te houden met vierkante haken als
soort zinspeelde op deze onderliggende

1119
00:55:03,790 --> 00:55:06,040
ontwerp, waarbij elke
karakter binnen van een string

1120
00:55:06,040 --> 00:55:10,180
is een beetje ingesloten ergens onderaan
de kap in het geheugen van uw computer.

1121
00:55:10,180 --> 00:55:12,340
>> Maar laten we een variant van dit.

1122
00:55:12,340 --> 00:55:14,880
Het blijkt dat deze
programma correct.

1123
00:55:14,880 --> 00:55:18,810
Dus per assen CS50's voor het evalueren
code, dit is nu juist.

1124
00:55:18,810 --> 00:55:22,959
Zeker nu dat ik het controleren op
null, dit programma moet nooit crashen.

1125
00:55:22,959 --> 00:55:24,500
En ik weet gewoon dat uit ervaring.

1126
00:55:24,500 --> 00:55:28,040
Maar er is niets anders dat
we mis kan hier echt gaan.

1127
00:55:28,040 --> 00:55:31,860
Maar het is niet erg goed ontworpen,
want laten we terug gaan naar de basis.

1128
00:55:31,860 --> 00:55:34,450
>> Eerst, principles--
wat doet een lus doen?

1129
00:55:34,450 --> 00:55:36,290
Een lus doet drie dingen.

1130
00:55:36,290 --> 00:55:39,340
Het initialiseert sommige
waarde, als je het vraagt.

1131
00:55:39,340 --> 00:55:41,770
Het controleert een voorwaarde.

1132
00:55:41,770 --> 00:55:45,380
En vervolgens na elke
iteratie na elke cyclus,

1133
00:55:45,380 --> 00:55:49,330
Het verhoogt een aantal
waarde of waarden, hier.

1134
00:55:49,330 --> 00:55:50,600
>> Dus wat betekent dat?

1135
00:55:50,600 --> 00:55:52,940
We initialiseren i op 0.

1136
00:55:52,940 --> 00:55:58,610
We controleren en ervoor zorgen dat ik minder dan
de lengte van s, die Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
zodat die minder dan 6.

1138
00:55:59,900 --> 00:56:02,590
En inderdaad 0 minder dan 6.

1139
00:56:02,590 --> 00:56:05,580
>> We uitprinten Z van de naam Zamyla's.

1140
00:56:05,580 --> 00:56:08,080
Dan verhogen we i 0-1.

1141
00:56:08,080 --> 00:56:11,290
Vervolgens hebben we controleren, is 1 minder
dan de lengte van s?

1142
00:56:11,290 --> 00:56:13,270
De lengte van s is 6.

1143
00:56:13,270 --> 00:56:13,950
Ja dat is zo.

1144
00:56:13,950 --> 00:56:16,880
>> Dus een afdruk van een in naam Zamyla's, ZA.

1145
00:56:16,880 --> 00:56:20,090
Wij verhogen i van 0 tot 1 tot 2.

1146
00:56:20,090 --> 00:56:23,720
Vervolgens hebben we controleren, 2 minder dan
de lengte van de naam Zamyla's.

1147
00:56:23,720 --> 00:56:25,380
6- dus 2 minder dan 6.

1148
00:56:25,380 --> 00:56:30,460
Ja, laten we uitprinten nu M in
Zamyla naam, het derde teken.

1149
00:56:30,460 --> 00:56:34,110
>> Het belangrijkste is dat op elke
iteratie van het verhaal, ik ben het controleren,

1150
00:56:34,110 --> 00:56:37,810
i is kleiner dan de lengte van Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Maar de vangst is dat
Stirling is geen eigenschap.

1152
00:56:40,350 --> 00:56:43,100
Degenen onder jullie die hebben geprogrammeerd
eerder in Java of andere talen

1153
00:56:43,100 --> 00:56:46,310
kan de lengte ken een string
een eigenschap, slechts enkele alleen-lezen waarde.

1154
00:56:46,310 --> 00:56:50,220
>> In C in dit geval als dit
een functie die letterlijk

1155
00:56:50,220 --> 00:56:53,520
tellen van het aantal
personages in Zamyla telkens

1156
00:56:53,520 --> 00:56:54,740
we noemen die functie.

1157
00:56:54,740 --> 00:56:58,500
Elke keer dat u vragen de computer te gebruiken
Stirling, is het nemen van een blik op Zamyla,

1158
00:56:58,500 --> 00:57:01,960
en zeggen Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
En keert terug 6.

1160
00:57:02,962 --> 00:57:04,920
De volgende keer dat u belt
het binnen die lus,

1161
00:57:04,920 --> 00:57:08,610
het gaat om te kijken naar Zamyla
voorts zeg Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
En het gaat om terug te keren 6.

1163
00:57:10,320 --> 00:57:12,980
Dus wat is dom over dit ontwerp?

1164
00:57:12,980 --> 00:57:17,700
>> Waarom is mijn code niet een 5 op 5
voor het ontwerp op dit moment, om zo te zeggen?

1165
00:57:17,700 --> 00:57:20,600
Nou, ik vraag een
vraag onnodig.

1166
00:57:20,600 --> 00:57:23,030
Ik doe meer werk dan ik nodig is.

1167
00:57:23,030 --> 00:57:25,370
>> Dus hoewel de
antwoord is juist, ben ik

1168
00:57:25,370 --> 00:57:29,560
vraagt ​​de computer, wat
de lengte van Zamyla weer,

1169
00:57:29,560 --> 00:57:31,380
en opnieuw, en opnieuw, en opnieuw?

1170
00:57:31,380 --> 00:57:33,980
En dat antwoord is
nooit zal veranderen.

1171
00:57:33,980 --> 00:57:35,900
Het is altijd gaat worden 6.

1172
00:57:35,900 --> 00:57:39,730
>> Dus een betere oplossing dan dit
zou dit de volgende versie.

1173
00:57:39,730 --> 00:57:43,390
Laat me ga je gang en zet het in een
apart bestand met de naam string1.c,

1174
00:57:43,390 --> 00:57:44,990
gewoon te houden scheiden.

1175
00:57:44,990 --> 00:57:47,260
En het blijkt in een voor
lus, kun je eigenlijk

1176
00:57:47,260 --> 00:57:50,210
verklaren meerdere variabelen tegelijk.

1177
00:57:50,210 --> 00:57:53,460
>> Dus ik ga i te houden en zet deze op 0.

1178
00:57:53,460 --> 00:57:56,190
Maar ik ga ook
voeg een komma, en zeggen:

1179
00:57:56,190 --> 00:58:01,050
geef me een variabele n genaamd, wiens
waarde is gelijk aan de lengte van de string van s.

1180
00:58:01,050 --> 00:58:09,410
En nu, maak mijn conditie
zolang i kleiner is dan n.

1181
00:58:09,410 --> 00:58:14,140
>> Dus op deze manier, is de logica
identiek aan het eind van de dag.

1182
00:58:14,140 --> 00:58:18,280
Maar ik herinneren van de
waarde 6, in dit geval.

1183
00:58:18,280 --> 00:58:19,780
Wat is de lengte van de naam Zamyla's?

1184
00:58:19,780 --> 00:58:20,860
En ik zet het op n.

1185
00:58:20,860 --> 00:58:23,050
>> En ik ben nog steeds het controleren
de toestand elke keer.

1186
00:58:23,050 --> 00:58:24,300
0 is minder dan 6?

1187
00:58:24,300 --> 00:58:25,600
1 is minder dan 6?

1188
00:58:25,600 --> 00:58:28,600
2 is minder dan 6, enzovoorts?

1189
00:58:28,600 --> 00:58:31,914
>> Maar ik ben niet het stellen van de computer
opnieuw, en opnieuw, wat is

1190
00:58:31,914 --> 00:58:33,080
de lengte van de naam Zamyla's?

1191
00:58:33,080 --> 00:58:34,320
Wat is de lengte van de naam Zamyla's?

1192
00:58:34,320 --> 00:58:35,986
Wat is de lengte van de naam van deze Zamyla?

1193
00:58:35,986 --> 00:58:40,440
Ik ben letterlijk te beseffen dat de eerste en
alleen beantwoorden in deze tweede variabele n.

1194
00:58:40,440 --> 00:58:45,280
Dus dit nu niet alleen zou zijn
correct, maar ook goed ontworpen.

1195
00:58:45,280 --> 00:58:46,670
>> Nu, hoe zit het met stijl?

1196
00:58:46,670 --> 00:58:48,866
Ik heb mijn variabelen vernoemd
vrij goed, zou ik zeggen.

1197
00:58:48,866 --> 00:58:50,240
Ze zijn op dit moment super beknopt.

1198
00:58:50,240 --> 00:58:52,090
En dat is helemaal prima.

1199
00:58:52,090 --> 00:58:55,120
>> Als u slechts één
tekenreeks in een programma,

1200
00:58:55,120 --> 00:58:56,860
je net zo goed noemen is voor string.

1201
00:58:56,860 --> 00:58:59,370
Als u slechts één variabele
voor het tellen in een programma,

1202
00:58:59,370 --> 00:59:00,710
je net zo goed noemen i.

1203
00:59:00,710 --> 00:59:03,500
Als u een lengte, n
is super vaak ook.

1204
00:59:03,500 --> 00:59:05,800
Maar ik heb niet gereageerd geen van mijn code.

1205
00:59:05,800 --> 00:59:09,200
>> Ik heb niet de reader-- hoogte
of dat is mijn TF of TA,

1206
00:59:09,200 --> 00:59:12,460
of gewoon colleague-- wat verondersteld
worden er aan de hand in dit programma.

1207
00:59:12,460 --> 00:59:15,760
En zo te goede stijl te krijgen,
wat ik zou willen doen

1208
00:59:15,760 --> 00:59:24,580
is dit-- iets
zoals vragen de gebruiker om input.

1209
00:59:24,580 --> 00:59:26,670
En ik kon herschrijven
dit een aantal manieren.

1210
00:59:26,670 --> 00:59:35,630
>> Zorg ervoor dat S-- ervoor get maken
snaar terug een string.

1211
00:59:35,630 --> 00:59:40,280
En vervolgens in hier-- en dit is misschien wel
de belangrijkste comment-- iterate

1212
00:59:40,280 --> 00:59:44,450
via tekens en een voor een.

1213
00:59:44,450 --> 00:59:47,060
En ik kon geen gebruik maken van
keuze van het Engels taal

1214
00:59:47,060 --> 00:59:49,650
hier te beschrijven elk
van deze stukjes code.

1215
00:59:49,650 --> 00:59:52,740
>> Merk op dat ik niet heb zet een
commentaar op elke regel code,

1216
00:59:52,740 --> 00:59:55,690
eigenlijk alleen maar op de interessante
degenen, degenen die

1217
00:59:55,690 --> 00:59:59,460
hebben een betekenis die ik zou kunnen
willen super duidelijk om iemand te maken

1218
00:59:59,460 --> 01:00:00,460
het lezen van mijn code.

1219
01:00:00,460 --> 01:00:02,920
En waarom bel je krijgt
koord vraagt ​​de gebruiker om input?

1220
01:00:02,920 --> 01:00:05,450
Zelfs dat men niet per se
al dat beschrijvend.

1221
01:00:05,450 --> 01:00:09,340
Maar het helpt een verhaal vertellen, omdat de
tweede lijn in het verhaal is, zorg ervoor dat

1222
01:00:09,340 --> 01:00:10,740
krijgen snaar terug een string.

1223
01:00:10,740 --> 01:00:14,260
>> En de derde lijn in het verhaal is,
itereren over de personages in 's één

1224
01:00:14,260 --> 01:00:15,380
tegelijk.

1225
01:00:15,380 --> 01:00:17,920
En nu slechts voor een goede maatregel,
Ik ga om te gaan en toe te voegen

1226
01:00:17,920 --> 01:00:24,560
nog een opmerking die net
zegt printen i-ste karakter in s.

1227
01:00:24,560 --> 01:00:26,520
Nu, wat heb ik gedaan
aan het einde van de dag?

1228
01:00:26,520 --> 01:00:29,190
>> Ik heb een aantal Engels toegevoegd
woorden in de vorm van opmerkingen.

1229
01:00:29,190 --> 01:00:32,700
De slash slash symbool betekent, hey,
computer dit is voor de mens,

1230
01:00:32,700 --> 01:00:33,820
niet voor u, de computer.

1231
01:00:33,820 --> 01:00:35,119
Dus ze logischerwijs genegeerd.

1232
01:00:35,119 --> 01:00:35,910
Ze zijn er gewoon.

1233
01:00:35,910 --> 01:00:39,830
>> En, inderdaad, CS50 IDE toont ze als
grijs, als nuttig, maar niet belangrijke

1234
01:00:39,830 --> 01:00:41,000
het programma.

1235
01:00:41,000 --> 01:00:42,570
Let op wat je nu kunt doen.

1236
01:00:42,570 --> 01:00:44,950
Of je weet C
programmeren of niet, je

1237
01:00:44,950 --> 01:00:47,722
kan gewoon staan ​​terug op deze
programma, en afgeroomde de commentaren.

1238
01:00:47,722 --> 01:00:50,180
Vraag gebruiker om invoer, zorg ervoor dat
krijgen snaar terug een string,

1239
01:00:50,180 --> 01:00:53,009
itereren over de personages in 's
een voor een, print de karakter

1240
01:00:53,009 --> 01:00:55,550
i-de teken in S-- je niet
zelfs om te kijken naar de code

1241
01:00:55,550 --> 01:00:57,270
om te begrijpen wat het programma doet.

1242
01:00:57,270 --> 01:01:00,280
En beter nog, als je jezelf ziet
Dit programma in een week of twee,

1243
01:01:00,280 --> 01:01:02,280
of een maand of per jaar
je ook niet hoeft

1244
01:01:02,280 --> 01:01:04,420
te staren naar de code,
proberen te herinneren,

1245
01:01:04,420 --> 01:01:06,630
wat ik probeerde te doen met deze code?

1246
01:01:06,630 --> 01:01:07,770
>> Je hebt jezelf verteld.

1247
01:01:07,770 --> 01:01:11,660
Je hebt het beschreven voor jezelf,
of een collega, of TA of TF.

1248
01:01:11,660 --> 01:01:14,860
En dus dit zou nu
correct, en een goed ontwerp,

1249
01:01:14,860 --> 01:01:18,210
en uiteindelijk een goede stijl ook.

1250
01:01:18,210 --> 01:01:19,990
Dus doe dat in gedachten houden.

1251
01:01:19,990 --> 01:01:22,200
>> Dus er is een ander
wat ik ga doen hier

1252
01:01:22,200 --> 01:01:28,240
dat kan nu onthullen precies wat er
er aan de hand onder de motorkap.

1253
01:01:28,240 --> 01:01:30,390
Dus er is deze functie
in C, en andere talen,

1254
01:01:30,390 --> 01:01:33,010
riep typecasting
dat impliciet

1255
01:01:33,010 --> 01:01:37,250
of expliciet stelt u in staat om te zetten
van het ene gegevenstype naar het andere.

1256
01:01:37,250 --> 01:01:39,800
We hebben beziggehouden, zodat
Wat vandaag met strijkers.

1257
01:01:39,800 --> 01:01:41,250
>> En strijkers zijn personages.

1258
01:01:41,250 --> 01:01:44,910
Maar herinneren vanaf week
0, wat zijn personages?

1259
01:01:44,910 --> 01:01:49,334
Personages zijn onder abstractie
op de top van numbers-- decimale getallen,

1260
01:01:49,334 --> 01:01:52,500
en decimale getallen zijn eigenlijk alleen maar een
abstractie bovenop binaire getallen,

1261
01:01:52,500 --> 01:01:53,720
we definieerde.

1262
01:01:53,720 --> 01:01:55,540
>> Dus tekens cijfers.

1263
01:01:55,540 --> 01:01:58,410
En nummers zijn personages,
alleen afhankelijk van de context.

1264
01:01:58,410 --> 01:02:01,250
En het blijkt dat binnen
van een computerprogramma,

1265
01:02:01,250 --> 01:02:06,830
kunt u opgeven hoe je wilt kijken
de bits in dat programma?

1266
01:02:06,830 --> 01:02:10,400
>> Recall vanaf week 0 die we hadden
Ascii, dat is gewoon deze code

1267
01:02:10,400 --> 01:02:11,620
mapping letters naar cijfers.

1268
01:02:11,620 --> 01:02:13,660
En wij zeiden, de hoofdstad A 65.

1269
01:02:13,660 --> 01:02:15,860
Kapitaal B 66, enzovoort.

1270
01:02:15,860 --> 01:02:20,500
>> En let op, we hebben in wezen chars op
de bovenste rij hier, zoals C hen zou noemen,

1271
01:02:20,500 --> 01:02:23,400
karakters, en dan
ints op de tweede rij.

1272
01:02:23,400 --> 01:02:28,180
En het blijkt dat je kunt omzetten
naadloos tussen de twee, typisch.

1273
01:02:28,180 --> 01:02:30,042
En als we willen doen
dit met opzet, we

1274
01:02:30,042 --> 01:02:31,750
zou willen aanpakken
iets zoals dit.

1275
01:02:31,750 --> 01:02:33,590
>> We zouden willen omzetten
hoofdletters naar kleine

1276
01:02:33,590 --> 01:02:35,330
geval is, of kleine letters naar hoofdletters.

1277
01:02:35,330 --> 01:02:38,000
En het blijkt dat er's
eigenlijk een patroon hier

1278
01:02:38,000 --> 01:02:39,900
we kunnen omarmen in slechts een moment.

1279
01:02:39,900 --> 01:02:44,120
Maar laten we eerst kijken naar een
voorbeeld om dit te doen expliciet.

1280
01:02:44,120 --> 01:02:46,340
>> Ik ga terug te gaan in CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Ik ga naar het creëren van een
bestand genaamd Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
En ik ga om verder te gaan en voeg mijn
standaard io.h aan de top, int main leegte

1283
01:02:55,960 --> 01:02:57,370
bovenaan mijn functie.

1284
01:02:57,370 --> 01:03:02,700
En dan ga ik gewoon naar de doen
following-- een lus van i gelijk is aan,

1285
01:03:02,700 --> 01:03:04,610
laten we zeggen, 65.

1286
01:03:04,610 --> 01:03:10,460
>> En dan wordt ik zal minder zijn dan
65, plus 26 letters in het alfabet.

1287
01:03:10,460 --> 01:03:12,640
Dus ik zal de computer te laten
doen de wiskunde voor mij daar.

1288
01:03:12,640 --> 01:03:15,100
En vervolgens binnen deze lus,
wat ga ik om af te drukken?

1289
01:03:15,100 --> 01:03:19,230
>> % C% i Backslash n.

1290
01:03:19,230 --> 01:03:21,290
En nu wil ik de stekker in twee waarden.

1291
01:03:21,290 --> 01:03:24,530
Ik heb tijdelijk in vraag
markeert er om de vraag uit te nodigen.

1292
01:03:24,530 --> 01:03:29,940
>> Ik wil verder herhalen vanaf 65
26 letters van het alfabet,

1293
01:03:29,940 --> 01:03:35,190
printen op elke iteratie dat
personage integraal equivalent.

1294
01:03:35,190 --> 01:03:38,299
Met andere woorden, ik wil
itereren over 26 nummers afdrukken

1295
01:03:38,299 --> 01:03:41,590
wat het ASCII-teken is, de brief,
en wat de bijbehorende nummer is--

1296
01:03:41,590 --> 01:03:44,650
eigenlijk gewoon recreëren
het schema van die dia.

1297
01:03:44,650 --> 01:03:47,010
Dus wat moeten deze vraagtekens zijn?

1298
01:03:47,010 --> 01:03:51,760
>> Nou, het blijkt dat de tweede
men moet alleen de variabele i zijn.

1299
01:03:51,760 --> 01:03:53,860
Ik wil zien dat als een getal.

1300
01:03:53,860 --> 01:03:58,920
En de middelste argument
hier kan ik de computer vertellen

1301
01:03:58,920 --> 01:04:03,470
behandeling die integer
i als aard geleidelijk

1302
01:04:03,470 --> 01:04:05,880
deze hier vervangen procent C.

1303
01:04:05,880 --> 01:04:07,990
>> Met andere woorden, als I,
menselijke programmeur, weet

1304
01:04:07,990 --> 01:04:09,865
dit zijn slechts cijfers
aan het einde van de dag.

1305
01:04:09,865 --> 01:04:12,500
En ik weet dat 65 moet
toewijzen aan één of ander karakter.

1306
01:04:12,500 --> 01:04:15,310
Met deze expliciete cast,
met een haakje,

1307
01:04:15,310 --> 01:04:18,840
de naam van het type data die u wilt
converteren, en een gesloten haakjes

1308
01:04:18,840 --> 01:04:21,200
U kunt vertellen dat de
computer, hey, computer,

1309
01:04:21,200 --> 01:04:24,130
omzetten dit integer naar een char.

1310
01:04:24,130 --> 01:04:26,250
>> Dus wanneer ik deze
programma na het compileren,

1311
01:04:26,250 --> 01:04:29,740
laten we eens kijken wat ik Ascii 0 get-- maken.

1312
01:04:29,740 --> 01:04:33,020
Verdorie, wat heb ik verkeerd hier?

1313
01:04:33,020 --> 01:04:35,884
Gebruik van niet-aangegeven identifier,
oke, niet opzettelijk,

1314
01:04:35,884 --> 01:04:37,800
maar laten we eens kijken of we kunnen niet
reden doorheen.

1315
01:04:37,800 --> 01:04:41,220
>> Dus lijn five-- dus ik niet krijgen
heel ver voor verknalt.

1316
01:04:41,220 --> 01:04:42,140
Dat is geen probleem.

1317
01:04:42,140 --> 01:04:46,560
Dus lijn 5 voor i is gelijk aan 65-- ik zie.

1318
01:04:46,560 --> 01:04:50,130
Dus vergeet niet dat in C, in tegenstelling tot sommige
talen als u vóór de programmering

1319
01:04:50,130 --> 01:04:52,190
ervaring, je hebt
de computer instrueren,

1320
01:04:52,190 --> 01:04:55,040
in tegenstelling tot Scratch, wat
type variabele is.

1321
01:04:55,040 --> 01:04:56,860
>> En ik vergat een sleutelzin hier.

1322
01:04:56,860 --> 01:04:59,200
In lijn vijf, heb ik begonnen met behulp van i.

1323
01:04:59,200 --> 01:05:01,560
Maar ik heb niet verteld C
welke gegevens het type het is.

1324
01:05:01,560 --> 01:05:04,570
Dus ik ga hier in te gaan en
zeggen, ah, maken het een integer.

1325
01:05:04,570 --> 01:05:07,050
>> Nu ga ik om verder te gaan en opnieuw te compileren.

1326
01:05:07,050 --> 01:05:08,080
Dat loste dat.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, dat is wel cool.

1328
01:05:12,660 --> 01:05:15,360
Niet alleen is het super snel
vraagt ​​de computer deze vraag,

1329
01:05:15,360 --> 01:05:18,885
in plaats van op te zoeken op een dia,
Het uitgeprint één per regel, A is 65,

1330
01:05:18,885 --> 01:05:24,860
B is 66, de hele weg down-- omdat ik
deed dit 26 times-- om de letters z,

1331
01:05:24,860 --> 01:05:25,630
die 90.

1332
01:05:25,630 --> 01:05:27,790
En in feite enigszins
intelligenter zou

1333
01:05:27,790 --> 01:05:31,030
zijn voor mij niet te vertrouwen
op de computer 26 te voegen.

1334
01:05:31,030 --> 01:05:34,060
Ik kon gewoon hebben gedaan
90 zo goed, zo lang

1335
01:05:34,060 --> 01:05:37,390
omdat ik niet twee keer dezelfde fout te maken.

1336
01:05:37,390 --> 01:05:41,880
Ik wil om omhoog te gaan door middel van
z, niet alleen omhoog door y.

1337
01:05:41,880 --> 01:05:44,000
>> Dus dat is een expliciete cast.

1338
01:05:44,000 --> 01:05:47,860
Het blijkt dat deze
niet eens nodig.

1339
01:05:47,860 --> 01:05:52,480
Laat me ga je gang en voer deze
compiler en herhaling Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Het blijkt dat C is behoorlijk slim.

1341
01:05:54,940 --> 01:05:57,150
>> En printf, in het bijzonder,
is behoorlijk slim.

1342
01:05:57,150 --> 01:06:01,260
Als je gewoon slagen voor een i tweemaal
voor zowel tijdelijke aanduidingen, printf

1343
01:06:01,260 --> 01:06:04,510
zullen beseffen, oh, nou ik weet dat je
gaf me een integer-- een getal,

1344
01:06:04,510 --> 01:06:06,380
zoals 65, of 90, of wat dan ook.

1345
01:06:06,380 --> 01:06:10,170
Maar ik zie dat je me wilt
opmaken dat nummer als een karakter.

1346
01:06:10,170 --> 01:06:16,460
En dus printf kan impliciet gegoten
de int naar een klusje voor je net zo goed.

1347
01:06:16,460 --> 01:06:19,360
Dus dat is geen probleem.

1348
01:06:19,360 --> 01:06:23,100
>> Maar let op, als gevolg van deze gelijkwaardigheid
we kunnen dit eigenlijk doen ook.

1349
01:06:23,100 --> 01:06:26,520
Laat me ga je gang en maak een
andere versie van dit-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
En in plaats van meer dan itereren
integers, kan echt blow your mind

1351
01:06:31,800 --> 01:06:33,610
door het itereren dan karakters.

1352
01:06:33,610 --> 01:06:37,660
Als een char c krijgt hoofdletter A, I
wil om vooruit te gaan en dit te doen,

1353
01:06:37,660 --> 01:06:41,740
mits C kleiner dan of gelijk
om kapitaal Z. En op elke iteratie

1354
01:06:41,740 --> 01:06:45,690
Ik wil C verhogen, kan ik
nu in mijn printf lijn hier

1355
01:06:45,690 --> 01:06:51,320
laten we zeggen, procent C is
percent ik opnieuw, komma C.

1356
01:06:51,320 --> 01:06:57,200
>> En nu kan ik de andere richting,
gieten van het karakter uitdrukkelijk

1357
01:06:57,200 --> 01:06:58,500
naar een integer.

1358
01:06:58,500 --> 01:07:00,560
Dus nogmaals, waarom zou je dat doen?

1359
01:07:00,560 --> 01:07:03,830
Het is een beetje raar om te sorteren van
rekenen in termen van karakters.

1360
01:07:03,830 --> 01:07:07,430
>> Maar als je begrijpt wat er
er aan de hand onder de motorkap,

1361
01:07:07,430 --> 01:07:08,430
er is echt geen magie.

1362
01:07:08,430 --> 01:07:13,060
Je bent gewoon te zeggen, hey, computer geven
me een variabele met de naam C van het type char.

1363
01:07:13,060 --> 01:07:16,520
Initialiseren om kapitaal A. And
opmerken enkele aanhalingstekens materie.

1364
01:07:16,520 --> 01:07:19,580
>> Voor karakters in C, ophalen uit
vorige week, gebruik je enkele aanhalingstekens.

1365
01:07:19,580 --> 01:07:23,720
Voor strijkers, naar woorden,
zinnen, dubbele aanhalingstekens gebruikt u.

1366
01:07:23,720 --> 01:07:27,210
OK, computer, blijven doen, dus
Zolang het karakter dan

1367
01:07:27,210 --> 01:07:28,050
of gelijk aan z.

1368
01:07:28,050 --> 01:07:32,640
En ik weet uit mijn Ascii tafel dat alle
Deze ASCII codes opeenvolgend.

1369
01:07:32,640 --> 01:07:33,400
>> Er is geen hiaten.

1370
01:07:33,400 --> 01:07:36,737
Dus het is gewoon A tot Z,
elk gescheiden door een nummer.

1371
01:07:36,737 --> 01:07:38,820
En dan kan ik verhogen
een char, als ik echt wil.

1372
01:07:38,820 --> 01:07:40,390
Aan het einde van de dag,
het is gewoon een nummer.

1373
01:07:40,390 --> 01:07:41,030
Ik weet dit.

1374
01:07:41,030 --> 01:07:43,670
Dus ik kan alleen maar veronderstellen om toe te voegen 1 aan.

1375
01:07:43,670 --> 01:07:46,940
>> En dan deze keer, ik afdrukken c,
en vervolgens de integraal equivalent.

1376
01:07:46,940 --> 01:07:50,170
En ik weet niet eens de expliciete cast nodig.

1377
01:07:50,170 --> 01:07:52,680
Ik kan printf en laat
computer figuur dingen uit,

1378
01:07:52,680 --> 01:07:57,300
zodat nu als ik zonder
maken Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Ik krijg het precies hetzelfde als goed.

1380
01:08:01,520 --> 01:08:04,530
>> Nutteloos programma hoewel-- niemand
gaat eigenlijk software te schrijven

1381
01:08:04,530 --> 01:08:07,549
om erachter te komen, wat was de
nummer dat wordt toegewezen aan A of B, of Z?

1382
01:08:07,549 --> 01:08:10,340
Je bent gewoon gaan om het Google, of
opzoeken online, of zoek het op

1383
01:08:10,340 --> 01:08:11,650
op een dia, of dergelijke.

1384
01:08:11,650 --> 01:08:13,520
Dus waar gaat dit eigenlijk nuttig?

1385
01:08:13,520 --> 01:08:15,960
>> Nou, spreken van die
glijbaan, ziet er

1386
01:08:15,960 --> 01:08:20,890
een echte patroon hier tussen hoofdletters
en kleine letters dat was niet toevallig.

1387
01:08:20,890 --> 01:08:23,760
Merk op dat het kapitaal A 65.

1388
01:08:23,760 --> 01:08:25,830
Kleine letters a 97.

1389
01:08:25,830 --> 01:08:29,649
En hoe ver is lager geval een?

1390
01:08:29,649 --> 01:08:32,649
>> Dus 65 is hoeveel een steenworp afstand van 97?

1391
01:08:32,649 --> 01:08:36,210
Dus 97 min 65 is 32.

1392
01:08:36,210 --> 01:08:37,910
Dus hoofdstad een is 65.

1393
01:08:37,910 --> 01:08:39,939
Als u 32 aan toevoegen,
je krijgt een kleine letters.

1394
01:08:39,939 --> 01:08:43,729
En, equivalent, als je 32 aftrekken,
je terug naar de hoofdstad A-- hetzelfde met B

1395
01:08:43,729 --> 01:08:46,380
tot kleine b, grote C tot kleine c.

1396
01:08:46,380 --> 01:08:50,670
>> Al deze gaten zijn 32 elkaar.

1397
01:08:50,670 --> 01:08:54,450
Nu, dit lijkt ons laten
doe iets zoals Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
of Google Docs-functie, waar u
kan alles selecteren en dan zeggen:

1399
01:08:57,729 --> 01:09:00,520
verandert alles in kleine letters, of
verander alle naar hoofdletters,

1400
01:09:00,520 --> 01:09:03,840
of verander alleen het eerste woord
van een zin naar hoofdletters.

1401
01:09:03,840 --> 01:09:07,390
We kunnen eigenlijk iets te doen
als dat onszelf.

1402
01:09:07,390 --> 01:09:12,645
>> Laat me ga je gang en een bestand op te slaan
hier genoemd kapitaliseren 0.c.

1403
01:09:12,645 --> 01:09:15,770
En laten we ga je gang en zweep een programma
die precies doet dat als volgt.

1404
01:09:15,770 --> 01:09:18,460
Zo zijn onder andere de CS50 bibliotheek.

1405
01:09:18,460 --> 01:09:21,430
En zijn standaard I / O.

1406
01:09:21,430 --> 01:09:22,787
>> En ik weet dat dit is binnenkort beschikbaar.

1407
01:09:22,787 --> 01:09:24,870
Dus ik ga het in te zetten
is er al, string.h,

1408
01:09:24,870 --> 01:09:26,960
dus ik heb toegang tot
dingen zoals Stirling,

1409
01:09:26,960 --> 01:09:29,620
en dan int belangrijkste leegte, zoals gebruikelijk.

1410
01:09:29,620 --> 01:09:33,420
En dan ga ik om verder te gaan
en doe strings krijgt krijgen koord,

1411
01:09:33,420 --> 01:09:35,032
alleen maar om een ​​string van de gebruiker te krijgen.

1412
01:09:35,032 --> 01:09:36,740
En dan ga ik
doe mijn sanity check.

1413
01:09:36,740 --> 01:09:40,510
Als touwtje niet gelijk is aan nul,
dan is het veilig om door te gaan.

1414
01:09:40,510 --> 01:09:42,000
En wat wil ik doen?

1415
01:09:42,000 --> 01:09:48,700
Ik ga herhalen van i gelijk is aan 0,
en n tot de string lengte van s.

1416
01:09:48,700 --> 01:09:51,899
>> En ik ga dit doen zolang
i is kleiner dan n, en ik plus plus.

1417
01:09:51,899 --> 01:09:55,060
Tot nu toe, ik ben echt gewoon
lenen ideeën van voor.

1418
01:09:55,060 --> 01:09:57,010
En nu ga ik aan een tak te introduceren.

1419
01:09:57,010 --> 01:09:59,635
>> Dus denk terug aan Scratch, waarbij
we hadden die vork in de weg,

1420
01:09:59,635 --> 01:10:05,110
en de laatste week in C. Ik ga
zeggen dat, indien de ie karakter s

1421
01:10:05,110 --> 01:10:09,250
groter of
gelijk aan kleine letters a,

1422
01:10:09,250 --> 01:10:13,340
en-- in Scratch zou je letterlijk
te zeggen en, maar in C zeg je ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- en de i-ste karakter in s
kleiner is dan of gelijk aan case z verlagen,

1424
01:10:19,830 --> 01:10:21,780
laten we iets interessants te doen.

1425
01:10:21,780 --> 01:10:27,020
Laten we eigenlijk uitprinten een
karakter zonder newline

1426
01:10:27,020 --> 01:10:31,760
dat het teken in de tekenreeks,
de ie teken in de reeks.

1427
01:10:31,760 --> 01:10:37,420
>> Maar laten we verder gaan en
aftrekken 32 van.

1428
01:10:37,420 --> 01:10:42,120
Indien echter het teken in het
string die we zoeken

1429
01:10:42,120 --> 01:10:45,950
is niet tussen een kleine
en weinig z, ga je gang

1430
01:10:45,950 --> 01:10:48,610
en gewoon uitgeprint ongewijzigd.

1431
01:10:48,610 --> 01:10:50,840
Dus we hebben geïntroduceerd
deze tussen haakjes notatie

1432
01:10:50,840 --> 01:10:53,560
voor onze strings te krijgen op de
i-ste karakter in de string.

1433
01:10:53,560 --> 01:10:57,520
>> Ik heb een aantal conditionele logica toegevoegd, zoals
Scratch in de laatste week van de week één, waarbij

1434
01:10:57,520 --> 01:10:59,880
Ik ben gewoon met mijn fundamentele
begrip van wat er

1435
01:10:59,880 --> 01:11:01,130
er aan de hand onder de motorkap.

1436
01:11:01,130 --> 01:11:04,190
Is de ie karakter s
groter dan of gelijk aan?

1437
01:11:04,190 --> 01:11:08,290
Zoals, is het ook 97 of 98,
of 99, enzovoorts?

1438
01:11:08,290 --> 01:11:11,940
>> Maar is het ook minder dan of gelijk
om de waarde van kleine letters z?

1439
01:11:11,940 --> 01:11:16,210
En zo ja, wat betekent dit lijn betekenen?

1440
01:11:16,210 --> 01:11:20,250
14 Dit is een soort van de
kiem van het hele idee,

1441
01:11:20,250 --> 01:11:23,840
kapitaliseren de brief van
eenvoudigweg aftrekken 32 ervan,

1442
01:11:23,840 --> 01:11:29,370
in dit geval, omdat ik weet, dat per
grafiek, hoe mijn nummers zijn vertegenwoordigd.

1443
01:11:29,370 --> 01:11:33,925
Dus laten we gaan vooruit en uitvoeren van deze,
na het compileren kapitaliseren 0.c,

1444
01:11:33,925 --> 01:11:36,210
en run kapitaliseren 0.

1445
01:11:36,210 --> 01:11:40,300
>> Laten we type in iets als
Zamyla in kleine letters in te voeren.

1446
01:11:40,300 --> 01:11:42,780
En nu hebben we Zamyla in hoofdletters.

1447
01:11:42,780 --> 01:11:45,050
Laten we type in Rob in alle kleine letters.

1448
01:11:45,050 --> 01:11:46,674
Laten we proberen Jason in kleine letters.

1449
01:11:46,674 --> 01:11:48,590
En we houden het krijgen van de
gedwongen kapitalisatie.

1450
01:11:48,590 --> 01:11:50,960
Er is een kleine bug die ik
soort niet anticiperen.

1451
01:11:50,960 --> 01:11:54,050
Let op mijn nieuwe prompt wordt belanden
op dezelfde lijn als hun namen,

1452
01:11:54,050 --> 01:11:55,520
die voelt een beetje rommelig.

1453
01:11:55,520 --> 01:11:59,170
>> Dus ik ga hier te gaan, en
daadwerkelijk aan het einde van het programma

1454
01:11:59,170 --> 01:12:02,110
afdrukken van een nieuwe regel.

1455
01:12:02,110 --> 01:12:03,160
Dat is alles.

1456
01:12:03,160 --> 01:12:06,120
Met printf, hoeft u niet hoeft te
pas in variabelen of formaat code.

1457
01:12:06,120 --> 01:12:08,460
Je kunt letterlijk gewoon uitprinten
zoiets als een nieuwe regel.

1458
01:12:08,460 --> 01:12:13,529
>> Dus laten we gaan door en maak
kapitaliseren 0 weer, opnieuw uit te voeren is, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
En nu is het een beetje mooier.

1460
01:12:14,820 --> 01:12:17,274
Nu, mijn aanwijzing is op zijn eigen nieuwe regel.

1461
01:12:17,274 --> 01:12:18,440
Dus dat is allemaal prima en goed.

1462
01:12:18,440 --> 01:12:19,910
Dus dat is een goed voorbeeld.

1463
01:12:19,910 --> 01:12:22,700
Maar ik heb niet eens per se
moeten harde code van de 32.

1464
01:12:22,700 --> 01:12:23,350
Weet je wat?

1465
01:12:23,350 --> 01:12:26,350
Ik kon say-- ik niet ooit
herinneren wat het verschil is.

1466
01:12:26,350 --> 01:12:29,330
>> Maar ik weet dat als ik
hebben een kleine letter,

1467
01:12:29,330 --> 01:12:34,430
Ik wil in wezen af ​​aftrekken
ongeacht de afstand is tussen de kleine

1468
01:12:34,430 --> 01:12:39,160
een en grote A, want als ik neem aan dat
alle andere letters hetzelfde,

1469
01:12:39,160 --> 01:12:41,045
dat moet de klus te klaren.

1470
01:12:41,045 --> 01:12:42,670
Maar in plaats van dat te doen, weet je wat?

1471
01:12:42,670 --> 01:12:44,240
Er is een andere manier nog steeds.

1472
01:12:44,240 --> 01:12:48,090
>> Als dat kapitaliseren 1.c-- als ik
te zetten dat in een apart bestand.

1473
01:12:48,090 --> 01:12:51,030
Laten we profiteren 2.c als volgt.

1474
01:12:51,030 --> 01:12:53,060
Ik ga dit echt schoon te maken hier.

1475
01:12:53,060 --> 01:12:57,420
En in plaats van te hoeven
weten of de zorg over die lage niveau

1476
01:12:57,420 --> 01:13:01,090
implementatie details, ik ben in plaats
gewoon gaan om een ​​teken af ​​te drukken,

1477
01:13:01,090 --> 01:13:04,610
citaat unquote, procent C, en
bel dan een andere functie die

1478
01:13:04,610 --> 01:13:09,950
bestaat dat neemt een argument,
dat is een karakter, zoals deze.

1479
01:13:09,950 --> 01:13:12,630
>> Het blijkt in C, is er
een andere functie aan te roepen

1480
01:13:12,630 --> 01:13:15,550
de bovenste, met als naam
suggereert neemt een personage

1481
01:13:15,550 --> 01:13:19,350
en maakt het haar hoofdletters
equivalent, en vervolgens stuurt het terug

1482
01:13:19,350 --> 01:13:21,410
zodat printf kan inpluggen daar.

1483
01:13:21,410 --> 01:13:25,484
En zo te doen, hoewel ik
moet een ander bestand in te voeren.

1484
01:13:25,484 --> 01:13:28,400
Het blijkt dat er een ander bestand
dat u alleen zou weten uit de klas,

1485
01:13:28,400 --> 01:13:33,020
of een leerboek, of een online
verwijzing, de zogenaamde C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Dus als ik toevoegen dat in Mijn header
bestanden, en nu opnieuw te compileren dit programma,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Laten we type in Zamyla in alle
kleine letters, werkt nog steeds hetzelfde.

1489
01:13:46,690 --> 01:13:48,040
Maar weet je wat?

1490
01:13:48,040 --> 01:13:55,590
Het blijkt dat de bovenste
heeft een aantal andere functies.

1491
01:13:55,590 --> 01:13:58,410
>> En laat me dit te introduceren
commando hier, een soort van onhandig

1492
01:13:58,410 --> 01:14:00,250
genoemd, maar de mens voor het handmatig.

1493
01:14:00,250 --> 01:14:03,960
Het blijkt dat de meeste Linux-computers,
als we met behulp van hier-- Linux besturingssysteem

1494
01:14:03,960 --> 01:14:06,270
system-- hebben een opdracht
genaamd man, die zegt:

1495
01:14:06,270 --> 01:14:08,530
hey, computer, geef me
handleiding van de computer.

1496
01:14:08,530 --> 01:14:10,680
Wat wil je
opzoeken in dit handboek?

1497
01:14:10,680 --> 01:14:13,840
>> Ik wil kijken de functie
geroepen om de bovenste, Enter.

1498
01:14:13,840 --> 01:14:16,070
En het is een beetje cryptisch
soms te lezen.

1499
01:14:16,070 --> 01:14:18,780
Maar let op dat we in de
handmatige Linux programmeur.

1500
01:14:18,780 --> 01:14:19,530
En het is allemaal tekst.

1501
01:14:19,530 --> 01:14:21,905
En merk op dat er de
naam van de functie hier.

1502
01:14:21,905 --> 01:14:25,030
Het blijkt dat het heeft een neef genaamd
te verlagen, waarbij het tegenovergestelde doet.

1503
01:14:25,030 --> 01:14:29,710
En let onder synopsis, om dit te gebruiken
functioneren van de man-pagina, om zo te zeggen,

1504
01:14:29,710 --> 01:14:32,220
vertelt me ​​dat ik
moeten c type.h. omvatten

1505
01:14:32,220 --> 01:14:33,630
En ik wist dat uit de praktijk.

1506
01:14:33,630 --> 01:14:36,210
>> Hier, het toont me de twee
prototypes voor de functie,

1507
01:14:36,210 --> 01:14:39,070
dus dat als ik ooit willen om dit te gebruiken
Ik weet wat ze te nemen als input,

1508
01:14:39,070 --> 01:14:40,652
en wat ze terugkeren als output.

1509
01:14:40,652 --> 01:14:42,360
En dan, als ik lees
de beschrijving, zie ik

1510
01:14:42,360 --> 01:14:44,820
meer in detail wat de functie doet.

1511
01:14:44,820 --> 01:14:48,100
Maar nog belangrijker,
Ik kijk onder return waarde,

1512
01:14:48,100 --> 01:14:51,710
zegt de geretourneerde waarde is
dat van de omgezette letter,

1513
01:14:51,710 --> 01:14:57,880
of C, de originele ingang als
de conversie niet mogelijk.

1514
01:14:57,880 --> 01:15:01,992
>> Met andere woorden, de bovenste proberen
een brief omzetten in hoofdletters.

1515
01:15:01,992 --> 01:15:03,450
En zo ja, het gaat om het terug te keren.

1516
01:15:03,450 --> 01:15:07,010
Maar als het niet kan voor sommige reason--
misschien is het al hoofdletters,

1517
01:15:07,010 --> 01:15:09,550
misschien is het een uitroepteken
of een andere punctuation--

1518
01:15:09,550 --> 01:15:12,200
het is gewoon gaat om
geeft het origineel C,

1519
01:15:12,200 --> 01:15:17,340
wat betekent dat ik kan mijn code maken
beter ontworpen als volgt.

1520
01:15:17,340 --> 01:15:20,580
>> Ik heb niet alle nodig
deze darn regels code.

1521
01:15:20,580 --> 01:15:22,610
Alle lijnen die ik heb
gewoon gemarkeerd kan

1522
01:15:22,610 --> 01:15:28,700
worden samengevoegd in één eenvoudige
lijn, dat is dit-- printf procent

1523
01:15:28,700 --> 01:15:33,510
c naar de bovenste S beugel i.

1524
01:15:33,510 --> 01:15:36,090
En dit zou zijn
voorbeeld van een beter ontwerp.

1525
01:15:36,090 --> 01:15:40,040
>> Waarom implementeren in 7 of 8 lijnen
code, wat het ook was ik gewoon

1526
01:15:40,040 --> 01:15:44,960
verwijderd, als je in plaats daarvan kan instorten
al die logica en besluitvorming

1527
01:15:44,960 --> 01:15:49,620
in één enkele lijn, 13 nu, dat
is gebaseerd op een bibliotheek function--

1528
01:15:49,620 --> 01:15:53,430
een functie die wordt geleverd met C, maar dat
doet precies wat je wilt doen.

1529
01:15:53,430 --> 01:15:55,295
En, eerlijk gezegd, zelfs als
het kwam niet met C,

1530
01:15:55,295 --> 01:15:58,880
je zou het zelf uit te voeren, zoals
we hebben gezien, krijgen met negatieve int

1531
01:15:58,880 --> 01:16:01,700
en krijg positieve int vorige week ook.

1532
01:16:01,700 --> 01:16:03,470
>> Deze code is nu veel beter leesbaar.

1533
01:16:03,470 --> 01:16:06,670
En inderdaad, als we bladert u omhoog,
kijk eens hoe veel compacter

1534
01:16:06,670 --> 01:16:08,360
Deze versie van mijn programma.

1535
01:16:08,360 --> 01:16:11,230
Het is een beetje topzwaar nu,
al deze omvat.

1536
01:16:11,230 --> 01:16:14,380
Maar dat is OK, want nu sta ik
op de schouders van programmeurs

1537
01:16:14,380 --> 01:16:15,300
voor mij.

1538
01:16:15,300 --> 01:16:18,440
En wie het ook was, die
geïmplementeerd bovenste echt

1539
01:16:18,440 --> 01:16:21,470
deed me een plezier, net als degene die
geïmplementeerd Stirling echt

1540
01:16:21,470 --> 01:16:24,790
deed me een plezier enige tijd geleden.

1541
01:16:24,790 --> 01:16:26,970
En nu hebben we een
beter ontwerp programma

1542
01:16:26,970 --> 01:16:31,680
dat implementeert exact dezelfde logica.

1543
01:16:31,680 --> 01:16:35,580
>> Spreken van Stirling, laat
ik ga je gang en dit te doen.

1544
01:16:35,580 --> 01:16:38,320
Laat me ga je gang en op te slaan
dit bestand als stirling.c.

1545
01:16:38,320 --> 01:16:43,255
En het blijkt, kunnen we terug pellen
een andere laag gewoon nu mooi.

1546
01:16:43,255 --> 01:16:45,630
Ik ga je gang en zweep gaan
een ander programma in de belangrijkste

1547
01:16:45,630 --> 01:16:49,759
hier dat gewoon opnieuw werktuigen
stringlengte als volgt.

1548
01:16:49,759 --> 01:16:52,300
Dus hier is een regel code die
krijgt me een string van de gebruiker.

1549
01:16:52,300 --> 01:16:53,910
We blijven het gebruik van dit opnieuw en opnieuw.

1550
01:16:53,910 --> 01:16:58,900
Ik geef mezelf een variabele genaamd
n type int dat verscheidene opslaat.

1551
01:16:58,900 --> 01:17:02,490
>> En laat me ga je gang en
doe dan het volgende logica.

1552
01:17:02,490 --> 01:17:15,610
Terwijl de n-de teken in s doet
niet gelijk backslash 0, ga je gang

1553
01:17:15,610 --> 01:17:17,930
en verhogen n.

1554
01:17:17,930 --> 01:17:23,506
En dan uitprinten printf procent i n.

1555
01:17:23,506 --> 01:17:29,200
Ik eis dat het programma hier,
zonder dat lengte van de string,

1556
01:17:29,200 --> 01:17:31,150
berekent de lengte van een string.

1557
01:17:31,150 --> 01:17:34,600
>> En de magie is volledig
ingekapseld in lijn 8

1558
01:17:34,600 --> 01:17:39,830
hier met wat lijkt op nieuwe syntaxis,
Dit backslash 0 in enkele aanhalingstekens.

1559
01:17:39,830 --> 01:17:41,360
Maar waarom is dat?

1560
01:17:41,360 --> 01:17:44,100
Nou, overwegen wat is geweest
gaande al die tijd.

1561
01:17:44,100 --> 01:17:47,990
>> En als een terzijde voordat ik het vergeet, realiseer
Ook dat naast de man pagina

1562
01:17:47,990 --> 01:17:50,920
die komen met een typische
Linux-systeem zoals CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
beseffen dat wij, de
personeel cursus, hebben ook

1564
01:17:53,770 --> 01:17:56,030
maakte een website versie
deze zelfde gedachte genaamd

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, die moet
al die zelfde man pagina's,

1566
01:17:59,940 --> 01:18:02,020
al diezelfde
documentatie alsmede

1567
01:18:02,020 --> 01:18:05,730
een kleine doos op de top die het mogelijk maakt
u al de vrij te zetten

1568
01:18:05,730 --> 01:18:09,025
geheimzinnige taal in minder comfortabel
modus, waarin we, het onderwijzend personeel,

1569
01:18:09,025 --> 01:18:12,150
hebben doorgemaakt en probeerde te vereenvoudigen
een aantal van de taal om de dingen te houden

1570
01:18:12,150 --> 01:18:14,830
gericht op de ideeën en niet
een deel van de technische aspecten.

1571
01:18:14,830 --> 01:18:20,070
Dus hou in het achterhoofd, reference.cs50.net
als een andere hulpbron.

1572
01:18:20,070 --> 01:18:23,800
>> Maar waarom doet tekenreekslengte werk in
de manier waarop ik even geleden voorgesteld?

1573
01:18:23,800 --> 01:18:25,160
Hier is de naam Zamyla's weer.

1574
01:18:25,160 --> 01:18:27,690
En hier is de naam Zamyla's
boxed in, zoals ik blijven doen,

1575
01:18:27,690 --> 01:18:31,360
om een ​​beeld te schetsen van het feit dat,
echt, maar een reeks tekens.

1576
01:18:31,360 --> 01:18:34,260
Maar Zamyla bestaat niet
afzonderlijk in een programma.

1577
01:18:34,260 --> 01:18:37,420
>> Als je schrijft en uitvoeren van een programma,
je gebruikt je Mac of pc

1578
01:18:37,420 --> 01:18:40,010
als het geheugen, of RAM om zo te zeggen.

1579
01:18:40,010 --> 01:18:42,620
En je kunt bedenken
uw computer als het hebben

1580
01:18:42,620 --> 01:18:44,730
veel gigabyte geheugen deze dagen.

1581
01:18:44,730 --> 01:18:47,700
En een optreden betekent miljarden,
dus miljarden bytes.

1582
01:18:47,700 --> 01:18:48,910
>> Maar laten we terugspoelen in de tijd.

1583
01:18:48,910 --> 01:18:51,530
En stel dat we gebruiken
echt een oude computer dat

1584
01:18:51,530 --> 01:18:55,150
slechts 32 bytes geheugen.

1585
01:18:55,150 --> 01:18:59,310
Ik kon op mijn computerscherm,
dit is gewoon trekken uit als volgt.

1586
01:18:59,310 --> 01:19:05,240
>> Ik kon alleen maar zeggen dat mijn
computer beschikt over alle van dit geheugen.

1587
01:19:05,240 --> 01:19:08,830
En dit is als een staaf geheugen, indien
Herinnert u zich onze foto van de vorige keer.

1588
01:19:08,830 --> 01:19:11,670
En als ik gewoon te verdelen
Deze in voldoende tijd,

1589
01:19:11,670 --> 01:19:15,040
Ik beweer dat ik 32 bytes
geheugen op het scherm.

1590
01:19:15,040 --> 01:19:18,239
>> Nu, in de werkelijkheid, kan ik alleen maar
trekken tot nu toe op dit scherm hier.

1591
01:19:18,239 --> 01:19:20,280
Dus ik ga om verder te gaan,
en gewoon volgens afspraak,

1592
01:19:20,280 --> 01:19:24,050
trek het geheugen van mijn computer als een
raster, niet alleen als een rechte lijn.

1593
01:19:24,050 --> 01:19:28,190
In het bijzonder, ik beweren nu dat
dit raster, deze 8 bij 4 raster,

1594
01:19:28,190 --> 01:19:31,800
gewoon vertegenwoordigt alle 32 bytes
geheugen beschikbaar in mijn Mac,

1595
01:19:31,800 --> 01:19:33,030
of beschikbaar in mijn PC.

1596
01:19:33,030 --> 01:19:34,780
En ze omwikkelen
op twee lijnen, net

1597
01:19:34,780 --> 01:19:38,030
omdat het past meer op het scherm.

1598
01:19:38,030 --> 01:19:40,800
Maar dit is de eerste byte.

1599
01:19:40,800 --> 01:19:41,990
Dit is de tweede byte.

1600
01:19:41,990 --> 01:19:43,300
Dit is de derde byte.

1601
01:19:43,300 --> 01:19:45,310
>> En dit is de 32 byte.

1602
01:19:45,310 --> 01:19:52,910
Of, als we denken als een computer
wetenschapper, dit is byte 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Dus je moet 0-31, indien
je begint te tellen bij 0.

1604
01:19:55,950 --> 01:19:59,830
>> Dus als we een programma gebruiken
Gesprekken krijgen koord,

1605
01:19:59,830 --> 01:20:05,280
en we krijgen een string uit de menselijke
zoals ik heb Zamyla genoemd, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
hoe in de wereld doet het
computer bijhouden welke byte,

1607
01:20:09,430 --> 01:20:12,230
die brok van geheugen,
hoort bij welke snaar?

1608
01:20:12,230 --> 01:20:16,270
Met andere woorden, als we verder naar
typ andere naam in de computer,

1609
01:20:16,270 --> 01:20:19,890
als dit Andi, bellen
krijg reeks een tweede keer,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I moet eindigen in de
computer het geheugen ook.

1611
01:20:23,030 --> 01:20:23,850
Maar hoe?

1612
01:20:23,850 --> 01:20:29,700
>> Nou, het blijkt dat onder de
kap, wat C doet bij het opslaan van strings

1613
01:20:29,700 --> 01:20:35,080
dat de humane in of die
afkomstig van een andere bron, is het ook

1614
01:20:35,080 --> 01:20:39,190
bakent eind hen
een speciale character-- backslash

1615
01:20:39,190 --> 01:20:44,750
0, dat is gewoon een speciale manier
zeggen 80 bits in een rij.

1616
01:20:44,750 --> 01:20:47,950
>> Dus A-- is dit de nummer 97 recall.

1617
01:20:47,950 --> 01:20:51,770
Dus sommige patroon van 8 bits
vertegenwoordigt decimaal getal 97.

1618
01:20:51,770 --> 01:20:58,070
Dit backslash 0 is letterlijk het aantal
0, alias nul, N-U-L, in tegenstelling tot vroeger,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, die we gesproken over.

1620
01:20:59,630 --> 01:21:05,700
Maar voor nu, weet alleen dat dit
backslash 0 ligt op slechts 80 bits in een rij.

1621
01:21:05,700 --> 01:21:09,810
>> En het is juist deze lijn in de
zand dat zegt iets naar links

1622
01:21:09,810 --> 01:21:12,610
behoort tot één snaar, of een data type.

1623
01:21:12,610 --> 01:21:15,480
En iets naar rechts
maakt deel uit van iets anders.

1624
01:21:15,480 --> 01:21:17,440
Andi's naam, ondertussen,
die net visueel

1625
01:21:17,440 --> 01:21:21,310
gebeurt er op te wikkelen naar de andere lijn,
maar dat is slechts een esthetische detail,

1626
01:21:21,310 --> 01:21:23,990
evenzo is nul beëindigd.

1627
01:21:23,990 --> 01:21:29,290
>> Het is een string van een A-N-D-I tekens,
plus een vijfde geheim karakter,

1628
01:21:29,290 --> 01:21:33,560
Alle 0 bits, die net bakent
Eind naam Andi eveneens.

1629
01:21:33,560 --> 01:21:37,120
En als we noemen krijgen snaar een derde keer
in de computer naar een string zoals krijgen

1630
01:21:37,120 --> 01:21:44,210
Maria M-A-R-I-A, die gelijk is Maria
naam nul afgesloten met backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> Dit verschilt fundamenteel
van hoe een computer zou typisch

1632
01:21:47,170 --> 01:21:51,850
slaan een geheel getal of een float of andere
data types nog steeds, omdat de recall,

1633
01:21:51,850 --> 01:21:57,420
een geheel getal is meestal 32 bits, of
4 bytes, of misschien zelfs 64 bits,

1634
01:21:57,420 --> 01:21:59,100
of acht bytes.

1635
01:21:59,100 --> 01:22:02,620
Maar veel primitieven in een computer
in een programmeertaal

1636
01:22:02,620 --> 01:22:05,550
een vast aantal
bytes onder de hood--

1637
01:22:05,550 --> 01:22:08,100
misschien 1, misschien 2, misschien 4, misschien 8.

1638
01:22:08,100 --> 01:22:13,250
>> Maar strings, door het ontwerp, hebben een
dynamische aantal karakters.

1639
01:22:13,250 --> 01:22:16,980
Je weet niet van tevoren, totdat
menselijke soorten van Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
of M-A-R-I-A of A-N-D-I. Je weet het niet
hoe vaak de gebruiker gaat raken

1641
01:22:21,400 --> 01:22:22,070
het toetsenbord.

1642
01:22:22,070 --> 01:22:26,490
Daarom, weet je niet hoe
vele personages van tevoren

1643
01:22:26,490 --> 01:22:27,540
je gaat nodig hebben.

1644
01:22:27,540 --> 01:22:31,840
>> En dus C gewoon een soort van bladeren als een
geheime broodkruimel onder de motorkap

1645
01:22:31,840 --> 01:22:32,960
Aan het einde van de string.

1646
01:22:32,960 --> 01:22:39,280
Na het opslaan Z-A-M-Y-L-A geheugen,
ook zet gewoon het equivalent

1647
01:22:39,280 --> 01:22:40,210
van een periode.

1648
01:22:40,210 --> 01:22:45,060
Aan het einde van een zin,
het zet 80 bits, om zo

1649
01:22:45,060 --> 01:22:49,120
te onthouden waar
Zamyla begint en eindigt.

1650
01:22:49,120 --> 01:22:51,490
>> Dus wat is het verband,
dan, om dit programma?

1651
01:22:51,490 --> 01:22:55,190
Dit programma hier, Stirling,
is gewoon een mechanisme

1652
01:22:55,190 --> 01:22:57,970
om betere koord
van de gebruiker, lijn 6.

1653
01:22:57,970 --> 01:23:01,160
Lijn 7, verklaar ik een variabele
riep n en zet deze gelijk is aan 0.

1654
01:23:01,160 --> 01:23:08,680
>> En vervolgens in lijn 8, ik gewoon vroeg de
vraag, terwijl de n-de teken is

1655
01:23:08,680 --> 01:23:12,120
niet gelijk Alle 0 bits--
met andere woorden, niet

1656
01:23:12,120 --> 01:23:14,500
gelijk deze speciale
karakter, backslash 0, die

1657
01:23:14,500 --> 01:23:18,470
was alleen dat speciale nul character--
ga je gang en gewoon verhogen n.

1658
01:23:18,470 --> 01:23:21,460
>> En blijven doen, en houden
doen en blijven doen.

1659
01:23:21,460 --> 01:23:23,430
En dus zelfs al in
het verleden hebben we i gebruikt,

1660
01:23:23,430 --> 01:23:25,181
het is perfect in orde
semantisch te n te gebruiken,

1661
01:23:25,181 --> 01:23:27,430
als je gewoon proberen te
tellen deze keer met opzet,

1662
01:23:27,430 --> 01:23:28,720
en wil gewoon het n noemen.

1663
01:23:28,720 --> 01:23:34,720
Dus dit blijft gewoon de vraag te stellen,
is het n-ste karakter van allemaal 0s?

1664
01:23:34,720 --> 01:23:38,470
Zo niet, kijk naar de volgende look,
kijken naar de volgende, kijk naar de volgende,

1665
01:23:38,470 --> 01:23:39,460
kijken naar de volgende.

1666
01:23:39,460 --> 01:23:45,540
>> Maar zodra je ziet backslash 0,
Dit loop-- lijn 9 tot 11-- stopt.

1667
01:23:45,540 --> 01:23:49,640
Je breekt uit de while lus,
waardoor binnenkant van die variabele n

1668
01:23:49,640 --> 01:23:54,530
een totaal aantal van alle
tekens in de string je zag,

1669
01:23:54,530 --> 01:23:55,660
waardoor het uitprinten.

1670
01:23:55,660 --> 01:23:56,760
Dus laten we proberen dit.

1671
01:23:56,760 --> 01:23:59,500
>> Laat me ga je gang en zonder
met de stirling functie,

1672
01:23:59,500 --> 01:24:04,240
maar alleen met behulp van mijn eigen bodem versie
hier genoemd Stirling, laat me ga je gang

1673
01:24:04,240 --> 01:24:07,700
en run Stirling, typ in iets
zoals Zamyla, waarvan ik weet van tevoren

1674
01:24:07,700 --> 01:24:08,670
is zes karakters.

1675
01:24:08,670 --> 01:24:10,080
Laten we eens kijken of het werkt.

1676
01:24:10,080 --> 01:24:10,920
Inderdaad, het is zes.

1677
01:24:10,920 --> 01:24:15,257
Laten we proberen met Rob, drie letters,
drie karakters ook, enzovoort.

1678
01:24:15,257 --> 01:24:17,340
Dus dat is alles wat er aan de hand
op onder de motorkap.

1679
01:24:17,340 --> 01:24:19,548
En let op de verbindingen,
Vervolgens, met de eerste week

1680
01:24:19,548 --> 01:24:22,370
van klasse, waar we spraken over
zoiets als abstractie,

1681
01:24:22,370 --> 01:24:26,960
dat is gewoon de gelaagdheid van ideeën, of
complexiteit bovenop basisprincipes.

1682
01:24:26,960 --> 01:24:30,710
Hier zijn we een soort van kijken
onder de motorkap van Stirling,

1683
01:24:30,710 --> 01:24:33,510
zo te zeggen, om erachter te komen,
hoe zou het ten uitvoer worden gelegd?

1684
01:24:33,510 --> 01:24:35,232
>> En we konden re-implementeren onszelf.

1685
01:24:35,232 --> 01:24:37,440
Maar we nooit meer gaan
opnieuw te implementeren stirling.

1686
01:24:37,440 --> 01:24:39,780
We gaan gewoon naar
Gebruik Stirling in orde

1687
01:24:39,780 --> 01:24:42,100
om daadwerkelijk te krijgen aan wat touwtjes lengte.

1688
01:24:42,100 --> 01:24:44,200
>> Maar er is geen magische
onder de motorkap.

1689
01:24:44,200 --> 01:24:46,716
Als je weet dat eronder
de motorkap, een string

1690
01:24:46,716 --> 01:24:48,090
is gewoon een reeks tekens.

1691
01:24:48,090 --> 01:24:51,090
En dat reeks tekens
allemaal kunnen numeriek worden aangepakt

1692
01:24:51,090 --> 01:24:53,330
met beugel 0, bracket
1, 2 beugel, en u

1693
01:24:53,330 --> 01:24:57,420
dat aan het einde van een string is een
speciaal karakter, kunt u uitzoeken

1694
01:24:57,420 --> 01:25:01,710
hoe je bijna alles in een te doen
programma, want al komt het neer op

1695
01:25:01,710 --> 01:25:03,400
leest en schrijft geheugen.

1696
01:25:03,400 --> 01:25:06,130
Dat is, veranderen en kijken
in het geheugen, of bewegende dingen

1697
01:25:06,130 --> 01:25:10,940
rond in het geheugen, printen dingen
op het scherm, enzovoorts.

1698
01:25:10,940 --> 01:25:14,800
>> Dus laten we dit nu pas ontdekte gebruiken
begrip van wat er werkelijk snaren

1699
01:25:14,800 --> 01:25:17,910
zijn onder de motorkap, en
schil terug een andere laag

1700
01:25:17,910 --> 01:25:20,080
dat tot nu toe hebben we
genegeerd helemaal.

1701
01:25:20,080 --> 01:25:22,650
In het bijzonder, op elk moment
We hebben een programma uitgevoerd,

1702
01:25:22,650 --> 01:25:25,930
We hebben deze regel code had
in de buurt van de top te verklaren belangrijkste.

1703
01:25:25,930 --> 01:25:27,810
En we hebben int main leegte gespecificeerd.

1704
01:25:27,810 --> 01:25:31,240
>> En die leegte tussen de haakjes
heeft gezegd al die tijd dat de belangrijkste

1705
01:25:31,240 --> 01:25:33,440
zelf heeft geen argumenten nemen.

1706
01:25:33,440 --> 01:25:36,210
Elke input die de belangrijkste is
gaande van de gebruiker te krijgen

1707
01:25:36,210 --> 01:25:39,020
heeft van een andere te komen
mechanisme, zoals get int,

1708
01:25:39,020 --> 01:25:42,040
of krijgen float, of om koord,
of een andere functie.

1709
01:25:42,040 --> 01:25:44,710
Maar het blijkt dat
wanneer u een programma schrijven,

1710
01:25:44,710 --> 01:25:47,690
je kunt eigenlijk opgeven
dat dit programma wordt

1711
01:25:47,690 --> 01:25:51,730
nemen input van het menselijk
op de opdrachtregel zelf.

1712
01:25:51,730 --> 01:25:56,310
>> Met andere woorden, hoewel we tot nu toe
hebben zojuist loopt ./hello hello

1713
01:25:56,310 --> 01:26:00,312
en dergelijke meer, alle
andere programma's die we geweest zijn gebruikt,

1714
01:26:00,312 --> 01:26:02,770
dat we onszelf niet schrijven,
hebben genomen, zo lijkt het,

1715
01:26:02,770 --> 01:26:05,210
command line arguments--
dingen zoals make.

1716
01:26:05,210 --> 01:26:07,450
Je zegt iets als merk,
en vervolgens een tweede woord.

1717
01:26:07,450 --> 01:26:10,950
Of Clang, zeg je kletteren, en vervolgens
een tweede woord, de naam van een bestand.

1718
01:26:10,950 --> 01:26:14,410
>> Of zelfs RM of CP, zoals je misschien
hebben gezien of al gebruikt

1719
01:26:14,410 --> 01:26:15,880
te verwijderen of bestanden kopiëren.

1720
01:26:15,880 --> 01:26:18,920
Al deze nemen zogenoemde
command line arguments--

1721
01:26:18,920 --> 01:26:21,130
extra woorden op de terminal prompt.

1722
01:26:21,130 --> 01:26:23,260
Maar tot nu toe hebben we
onszelf niet hebben gehad

1723
01:26:23,260 --> 01:26:27,080
Dit luxe van het nemen van de inbreng van de
gebruiker wanneer hij of zij eigenlijk loopt

1724
01:26:27,080 --> 01:26:29,120
het programma zelf op de opdrachtregel.

1725
01:26:29,120 --> 01:26:33,710
>> Maar we kunnen dat doen door opnieuw te verklaren
hoofd vooruit, niet als het hebben van

1726
01:26:33,710 --> 01:26:36,750
ongeldig tussen haakjes,
maar deze twee argumenten

1727
01:26:36,750 --> 01:26:40,600
instead-- de eerste een integer,
en de tweede iets

1728
01:26:40,600 --> 01:26:44,170
nieuws, iets dat we gaan om te bellen
een array iets dergelijks geest

1729
01:26:44,170 --> 01:26:49,220
met wat we zagen in Scratch als een lijst, maar
een array van strings, zoals we zullen snel te zien.

1730
01:26:49,220 --> 01:26:51,790
Maar laten we dit zien door
Als voorbeeld voor we

1731
01:26:51,790 --> 01:26:53,690
onderscheiden precies wat dat betekent.

1732
01:26:53,690 --> 01:26:56,520
>> Dus als ik ga in CS50 IDE
hier heb ik vooruit gegaan

1733
01:26:56,520 --> 01:27:01,840
en verklaarde in een bestand met de naam
argv0.c de volgende template.

1734
01:27:01,840 --> 01:27:04,120
En let op de enige
dat anders tot nu toe

1735
01:27:04,120 --> 01:27:08,570
is dat ik nietig heeft gewijzigd in int
argc snaar argv geopend beugel dicht

1736
01:27:08,570 --> 01:27:09,070
haakje.

1737
01:27:09,070 --> 01:27:11,730
En merk voor nu, is er
niets binnen van de haakjes.

1738
01:27:11,730 --> 01:27:12,620
>> Er is geen nummer.

1739
01:27:12,620 --> 01:27:15,070
En er is geen i, of
n of andere letters.

1740
01:27:15,070 --> 01:27:17,010
Ik ben gewoon met behulp van de
vierkante haken voor nu,

1741
01:27:17,010 --> 01:27:19,510
om redenen die we zullen komen
terug in slechts een moment.

1742
01:27:19,510 --> 01:27:21,330
>> En nu, wat ik ga doen is het volgende.

1743
01:27:21,330 --> 01:27:26,680
Als argc gelijk gelijk 2--
en herinneren dat gelijken gelijk

1744
01:27:26,680 --> 01:27:30,040
is de operator gelijkheid vergelijken
de linker en rechter voor gelijkheid.

1745
01:27:30,040 --> 01:27:31,790
Het is niet de opdracht
operator, die

1746
01:27:31,790 --> 01:27:36,510
de enige isgelijkteken, wat betekent dat een kopie
van rechts naar links een bepaalde waarde.

1747
01:27:36,510 --> 01:27:42,840
>> Als argc gelijk gelijk is aan 2, ik wil
zeg, printf, hello, procenten, nieuwe regel,

1748
01:27:42,840 --> 01:27:47,340
en steek in-- en hier is de nieuwe
trick-- argv beugel 1, om redenen

1749
01:27:47,340 --> 01:27:48,840
dat we terug naar in een moment zal komen.

1750
01:27:48,840 --> 01:27:52,110
Anders als argc niet doet
gelijk 2, weet je wat?

1751
01:27:52,110 --> 01:27:57,400
Laten we gewoon doorgaan en, zoals gebruikelijk, print
out hello wereld zonder substitutie.

1752
01:27:57,400 --> 01:28:02,710
>> Dus het lijkt erop dat als argc, die
staat voor argument tellen, gelijk aan 2,

1753
01:28:02,710 --> 01:28:04,740
Ik ga om uit te printen
hello het een of ander.

1754
01:28:04,740 --> 01:28:07,560
Anders, standaard, ben ik
gaan om hallo te drukken wereld.

1755
01:28:07,560 --> 01:28:08,770
Dus wat betekent dit?

1756
01:28:08,770 --> 01:28:15,550
>> Nou, laat me ga je gang en op te slaan
dit bestand, en dan doen maken argv0,

1757
01:28:15,550 --> 01:28:18,940
en dan ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
En het zegt hallo wereld.

1759
01:28:20,300 --> 01:28:21,260
Nu, waarom is dat?

1760
01:28:21,260 --> 01:28:24,730
>> Nou, het blijkt dat wanneer je
uitvoeren van een programma op de opdrachtregel

1761
01:28:24,730 --> 01:28:29,570
u bent het invullen van wat we zullen
over het algemeen noemen een argument vector.

1762
01:28:29,570 --> 01:28:33,100
Met andere woorden, automatisch
computer, het besturingssysteem,

1763
01:28:33,100 --> 01:28:38,340
zal bij de hand om uw programma
zelf een lijst van alle woorden

1764
01:28:38,340 --> 01:28:40,850
dat het menselijk getypt op
de prompt voor het geval u

1765
01:28:40,850 --> 01:28:43,790
de programmeur willen doen
iets met die informatie.

1766
01:28:43,790 --> 01:28:48,540
En in dit geval, het enige woord
Ik heb getypt in de prompt is ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> En zo het aantal argumenten dat is
wordt doorgegeven aan mijn programma is slechts een.

1768
01:28:55,420 --> 01:28:58,880
Met andere woorden, het argument
tellen, ook wel bekend als argc

1769
01:28:58,880 --> 01:29:00,970
hier als een geheel getal, is slechts een.

1770
01:29:00,970 --> 01:29:03,000
Eén, natuurlijk, is niet gelijk aan twee.

1771
01:29:03,000 --> 01:29:05,980
En dus dit is wat wordt afgedrukt, hello wereld.

1772
01:29:05,980 --> 01:29:08,170
>> Maar laat mij dit ergens nemen.

1773
01:29:08,170 --> 01:29:09,930
Laat ik zeggen, argv0.

1774
01:29:09,930 --> 01:29:12,740
En vervolgens hoe over Maria?

1775
01:29:12,740 --> 01:29:14,990
En dan druk op Enter.

1776
01:29:14,990 --> 01:29:18,020
>> En let op wat magisch gebeurt hier.

1777
01:29:18,020 --> 01:29:22,640
Nu, in plaats van Hallo wereld, ik heb
veranderde het gedrag van het programma

1778
01:29:22,640 --> 01:29:26,310
door het nemen van de ingang niet uit get
koord of een andere functie,

1779
01:29:26,310 --> 01:29:30,570
maar van, blijkbaar, mijn bevel
zelf, wat ik oorspronkelijk getypt.

1780
01:29:30,570 --> 01:29:35,720
En ik kan dit spel opnieuw te spelen door
veranderen Stelios, bijvoorbeeld.

1781
01:29:35,720 --> 01:29:38,400
>> En nu zie ik nog een andere naam.

1782
01:29:38,400 --> 01:29:40,540
En hier, zou ik zeggen Andi.

1783
01:29:40,540 --> 01:29:42,137
En ik zou kunnen zeggen Zamyla.

1784
01:29:42,137 --> 01:29:45,220
En we kunnen dit spel spelen de hele dag lang,
gewoon inpluggen in verschillende waarden,

1785
01:29:45,220 --> 01:29:49,550
zolang ik precies bieden
twee woorden op de prompt,

1786
01:29:49,550 --> 01:29:52,260
zodanig dat argc, mijn betoog te tellen, is 2.

1787
01:29:52,260 --> 01:29:57,240
>> Zie ik die naam aangesloten op
printf, per deze aandoening hier?

1788
01:29:57,240 --> 01:30:00,550
Dus lijken we nu hebben
de expressieve mogelijkheden

1789
01:30:00,550 --> 01:30:04,410
nemen input van een ander mechanisme,
van de zogenaamde command line,

1790
01:30:04,410 --> 01:30:07,000
in plaats van te moeten wachten
totdat de gebruiker het programma loopt,

1791
01:30:07,000 --> 01:30:10,220
en dan vraagt ​​hem of haar
met behulp van iets als get string.

1792
01:30:10,220 --> 01:30:11,230
>> Dus wat is dit?

1793
01:30:11,230 --> 01:30:15,010
Argc, nogmaals, is gewoon een integer,
het aantal words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
dat de gebruiker verschaft in de
prompt, bij het raam terminal,

1795
01:30:18,540 --> 01:30:20,110
waaronder de naam van het programma.

1796
01:30:20,110 --> 01:30:23,340
Dus onze ./argv0 is, effectief,
de naam van het programma,

1797
01:30:23,340 --> 01:30:24,520
of hoe ik uitvoeren van het programma.

1798
01:30:24,520 --> 01:30:25,810
>> Dat telt als een woord.

1799
01:30:25,810 --> 01:30:27,080
Dus zou argc 1.

1800
01:30:27,080 --> 01:30:29,750
Maar als ik schrijf Stelios, of
Andi of Zamyla, of Maria,

1801
01:30:29,750 --> 01:30:31,660
dat betekent het argument telling twee.

1802
01:30:31,660 --> 01:30:33,910
En nu zijn er twee woorden doorgegeven.

1803
01:30:33,910 --> 01:30:36,070
>> En let op, kunnen we deze logica voort te zetten.

1804
01:30:36,070 --> 01:30:39,050
Als ik eigenlijk zeggen
zoiets als Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
een volledige naam, waardoor het passeren
drie argumenten in totaal,

1806
01:30:42,200 --> 01:30:47,410
Nu zegt de standaard weer,
omdat natuurlijk 3 is niet gelijk aan 2.

1807
01:30:47,410 --> 01:30:54,080
>> En dus op deze manier, heb ik
toegang via argv deze nieuwe argument

1808
01:30:54,080 --> 01:30:56,080
dat we konden technisch
roepen wat we willen.

1809
01:30:56,080 --> 01:30:58,940
Maar volgens afspraak, het is
argv en argc, respectievelijk.

1810
01:30:58,940 --> 01:31:04,470
Argv argument vector, is een soort
of een synoniem voor een uitvergroting

1811
01:31:04,470 --> 01:31:07,140
feature C in een array genoemd.

1812
01:31:07,140 --> 01:31:14,410
>> Een array is een lijst met vergelijkbare waarden
terug, aan rug, aan rug, terug.

1813
01:31:14,410 --> 01:31:17,810
Met andere woorden, wanneer men hier in is
RAM, de volgende is er vlak naast,

1814
01:31:17,810 --> 01:31:18,800
en rechts ernaast.

1815
01:31:18,800 --> 01:31:20,101
Ze zijn niet all over the place.

1816
01:31:20,101 --> 01:31:23,100
En dat laatste scenario, waar dingen
zijn all over the place in het geheugen,

1817
01:31:23,100 --> 01:31:25,082
kan eigenlijk een krachtige functie.

1818
01:31:25,082 --> 01:31:28,040
Maar we zullen terug te komen op dat wanneer we
praten over liefhebber datastructuren.

1819
01:31:28,040 --> 01:31:32,260
Voor nu, een array is gewoon een
brok van aaneengesloten geheugen,

1820
01:31:32,260 --> 01:31:36,520
elk waarvan de elementen
terug, aan rug, aan rug, aan rug,

1821
01:31:36,520 --> 01:31:38,050
en in het algemeen hetzelfde type.

1822
01:31:38,050 --> 01:31:42,630
>> Dus als je erover nadenkt, vanuit een
ogenblik geleden, wat is een string?

1823
01:31:42,630 --> 01:31:50,460
Nou ja, een string, zoals Zamyla,
Z-A-M-Y-L-A, is technisch gezien

1824
01:31:50,460 --> 01:31:51,400
gewoon een array.

1825
01:31:51,400 --> 01:31:53,700
Het is een reeks tekens.

1826
01:31:53,700 --> 01:31:59,250
>> En dus als we dit echt trekken, zoals ik
deed eerder, als een stuk van het geheugen,

1827
01:31:59,250 --> 01:32:04,510
Het blijkt dat elk van deze
karakters neemt een byte.

1828
01:32:04,510 --> 01:32:07,630
En dan is er die speciale
sentinel karakter, de backslash 0,

1829
01:32:07,630 --> 01:32:12,360
of alle acht 0 bits, dat
markeert het einde van die string.

1830
01:32:12,360 --> 01:32:15,090
Dus een string, blijkt
out, citeer unquote koord,

1831
01:32:15,090 --> 01:32:20,580
is slechts een array van chara--
char wordt een actuele gegevens type.

1832
01:32:20,580 --> 01:32:24,560
>> En nu argv, meanwhile--
Laten we teruggaan naar het programma te gaan.

1833
01:32:24,560 --> 01:32:29,582
Argv, hoewel we het woord te zien
snaar hier, is niet een string zelf.

1834
01:32:29,582 --> 01:32:33,640
Argv, argument vector,
is een array van strings.

1835
01:32:33,640 --> 01:32:37,620
>> Dus net zoals je een scala aan kan hebben
tekens, kunt u een hoger niveau hebben,

1836
01:32:37,620 --> 01:32:46,279
een reeks strings-- dus bijvoorbeeld
toen ik typte een ogenblik geleden ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, space Z-A-M-Y-L-A, I beweerd dat
argv had twee strings in het-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
en Z-A-M-Y-L-A. In
Anders gezegd, argc was 2.

1839
01:33:03,185 --> 01:33:03,980
Waarom is dat?

1840
01:33:03,980 --> 01:33:08,370
>> Nou, effectief, wat er gaande
on is dat elk van deze reeksen

1841
01:33:08,370 --> 01:33:13,990
is uiteraard een reeks karakters
als voorheen, waarvan elk karakters

1842
01:33:13,990 --> 01:33:15,670
neemt één byte.

1843
01:33:15,670 --> 01:33:19,720
En niet te verwarren met de feitelijke 0
in de naam van het programma met de 0,

1844
01:33:19,720 --> 01:33:22,040
wat betekent dat alle 80 bits.

1845
01:33:22,040 --> 01:33:27,140
En Zamyla, ondertussen, is nog steeds
ook een scala aan personages.

1846
01:33:27,140 --> 01:33:31,450
>> Dus aan het eind van de dag, het echt
ziet er als volgt onder de motorkap.

1847
01:33:31,450 --> 01:33:38,800
Maar argv, door de aard van de manier waarop de belangrijkste
werken, kan ik dit alles wrap

1848
01:33:38,800 --> 01:33:44,810
omhoog in, als je wil, een groter scala
dat als wij iets meer dan vereenvoudigen

1849
01:33:44,810 --> 01:33:48,180
hoe het beeld eruit ziet en niet doen
vrij tekenen op schaal daarboven,

1850
01:33:48,180 --> 01:33:56,720
deze array slechts de grootte 2, de eerste
element waarvan een tekenreeks,

1851
01:33:56,720 --> 01:33:59,230
het tweede element van
die is voorzien van een string.

1852
01:33:59,230 --> 01:34:01,687
En op hun beurt, als je
soort inzoomen op elke

1853
01:34:01,687 --> 01:34:03,770
van die strings, wat je
zie onder de motorkap

1854
01:34:03,770 --> 01:34:07,190
is dat elke snaar is gewoon
een reeks tekens.

1855
01:34:07,190 --> 01:34:11,680
>> Nu, net als bij strijkers,
we waren in staat om toegang te krijgen

1856
01:34:11,680 --> 01:34:15,260
de i-de teken in een string
met behulp van dat plein haakjesnotering.

1857
01:34:15,260 --> 01:34:17,320
Ook met arrays
In het algemeen kunnen we

1858
01:34:17,320 --> 01:34:22,700
Gebruik vierkante haakjesnotering te krijgen
er talrijke strings in een array?

1859
01:34:22,700 --> 01:34:25,100
Bijvoorbeeld, laat me
ga je gang en dit te doen.

1860
01:34:25,100 --> 01:34:32,420
>> Laat me ga je gang en maak argv1.c,
dat is een beetje anders deze keer.

1861
01:34:32,420 --> 01:34:35,635
In plaats van het controleren van argc2,
Ik ga dit doen in plaats.

1862
01:34:35,635 --> 01:34:41,270
Voor int Ik krijg 0, I minder
dan argc, ik plus plus,

1863
01:34:41,270 --> 01:34:47,920
en vervolgens uitprinten binnenkant van deze,
procent s, nieuwe regel, en dan

1864
01:34:47,920 --> 01:34:50,740
argv beugel i.

1865
01:34:50,740 --> 01:34:55,220
>> Dus met andere woorden, ik ben niet te maken met
afzonderlijke tekens op het moment.

1866
01:34:55,220 --> 01:35:00,190
Argv, zoals gesuggereerd door deze lege plein
bretels aan de rechterkant van de naam argv,

1867
01:35:00,190 --> 01:35:03,320
betekent argv is een array van strings.

1868
01:35:03,320 --> 01:35:04,870
En argc is slechts een int.

1869
01:35:04,870 --> 01:35:08,800
>> Deze lijn hier, 6, is
zeggende set i gelijk aan 0.

1870
01:35:08,800 --> 01:35:11,980
Tel alle de heenweg naar,
maar niet inclusief, argc.

1871
01:35:11,980 --> 01:35:14,010
En dan op elke iteratie,
afdrukken van een string.

1872
01:35:14,010 --> 01:35:14,800
Wat touwtje?

1873
01:35:14,800 --> 01:35:17,270
>> De i-de tekenreeks in argv.

1874
01:35:17,270 --> 01:35:19,530
Dus terwijl ik was
met behulp van de vierkante haak

1875
01:35:19,530 --> 01:35:22,180
notatie te krijgen op de i
teken in een tekenreeks, nu

1876
01:35:22,180 --> 01:35:27,240
Ik gebruik de beugel vierkante notatie
om bij de i-tekenreeks in een array.

1877
01:35:27,240 --> 01:35:30,310
Dus het is een soort van een laag
hierboven, conceptueel.

1878
01:35:30,310 --> 01:35:35,390
>> En dus wat is netjes over dit
programma nu, als ik het compileren argv1,

1879
01:35:35,390 --> 01:35:42,067
en dan doen ./argv1 en typ
in iets als foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
waarin de drie standaardwoorden dat zijn
computer wetenschapper bereikt voor elk moment

1881
01:35:45,400 --> 01:35:51,010
hij of zij heeft wat placeholder woorden,
en druk op Enter, elk van die woorden,

1882
01:35:51,010 --> 01:35:54,980
waaronder de naam van het programma, dat
argv is op de eerste locatie,

1883
01:35:54,980 --> 01:35:58,320
uiteindelijk worden afgedrukt, tegelijkertijd.

1884
01:35:58,320 --> 01:36:05,290
En als ik dit te veranderen, en ik zeg
zoiets als argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
krijgen we alle drie van die
woorden die argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, omdat in dit
geval argc, de telling, is 3.

1887
01:36:14,400 --> 01:36:20,020
>> Maar wat is netjes is als je begrijpt
dat argv is slechts een array van strings,

1888
01:36:20,020 --> 01:36:24,910
en u begrijpt dat een string
een reeks karakters,

1889
01:36:24,910 --> 01:36:29,470
we kunnen eigenlijk wel dit te gebruiken
square haakjesnotering meerdere keren

1890
01:36:29,470 --> 01:36:33,320
naar een string te kiezen en kies vervolgens
een teken in de string,

1891
01:36:33,320 --> 01:36:35,730
duiken in diepere als volgt.

1892
01:36:35,730 --> 01:36:40,100
In dit voorbeeld, laat me gaan
vooruit en noemen dit argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
En in dit voorbeeld, laat me ga je gang
en doe de following-- voor int krijg ik 0,

1895
01:36:50,180 --> 01:36:53,286
i minder dan argc, i plus
plus, net als vroeger.

1896
01:36:53,286 --> 01:36:55,910
Dus met andere words-- en nu dit
krijgt al ingewikkeld genoeg.

1897
01:36:55,910 --> 01:36:59,940
Dan ga ik om te zeggen
itereren over strings in argv,

1898
01:36:59,940 --> 01:37:01,294
als een reactie op mezelf.

1899
01:37:01,294 --> 01:37:03,960
En dan ga ik een hebben
geneste lus, die je waarschijnlijk

1900
01:37:03,960 --> 01:37:06,290
hebben gedaan, of geacht
doen, in Scratch, waarbij

1901
01:37:06,290 --> 01:37:08,600
Ik ga zeggen int-- ik ben
niet van plan om i opnieuw te gebruiken,

1902
01:37:08,600 --> 01:37:12,590
want ik wil geen schaduw, of
soort van overschrijven de bestaande i.

1903
01:37:12,590 --> 01:37:15,780
>> Ik ga, in plaats daarvan, zeg j, omdat
dat is mijn ga naar variabele nadat ik,

1904
01:37:15,780 --> 01:37:18,590
wanneer ik probeer gewoon
tellen nummertjes.

1905
01:37:18,590 --> 01:37:28,850
Voor j krijgt 0-- en, n, gaat
krijgen de achtersteven lengte van argv beugel i,

1906
01:37:28,850 --> 01:37:36,030
zolang j is dan m,
j plus plus, doet u het volgende.

1907
01:37:36,030 --> 01:37:37,500
En hier is het interessante deel.

1908
01:37:37,500 --> 01:37:46,330
>> Druk een karakter en een nieuwe lijn,
inpluggen in argv beugel i, beugel j.

1909
01:37:46,330 --> 01:37:47,940
OK, dus laat ik enkele opmerkingen hier toevoegen.

1910
01:37:47,940 --> 01:37:54,820
Itereren over personages
in de huidige reeks,

1911
01:37:54,820 --> 01:38:02,290
afdruk j-ste karakter in i-de string.

1912
01:38:02,290 --> 01:38:04,630
Dus nu, laten we eens kijken
wat deze opmerkingen betekenen.

1913
01:38:04,630 --> 01:38:06,750
>> Itereren over de snaren
in argv-- hoeveel

1914
01:38:06,750 --> 01:38:09,300
snaren zijn in argv, die een array?

1915
01:38:09,300 --> 01:38:13,420
Argc veel, dus ik ben itereren
van i gelijk 0 tot argc.

1916
01:38:13,420 --> 01:38:20,020
Ondertussen, hoeveel tekens
in de ie tekenreeks in argv?

1917
01:38:20,020 --> 01:38:22,880
>> Nou, om dat antwoord te krijgen,
Ik bel tekenreekslengte

1918
01:38:22,880 --> 01:38:26,810
op de huidige reeks I care
over, dat is argv beugel i.

1919
01:38:26,810 --> 01:38:30,090
En ik ga tijdelijk op te slaan dat
waarde in n, alleen voor caching doeleinden,

1920
01:38:30,090 --> 01:38:31,590
om het te onthouden voor efficiency.

1921
01:38:31,590 --> 01:38:36,330
En dan ga ik initialiseren van j naar 0,
doorgaan zolang j kleiner dan n,

1922
01:38:36,330 --> 01:38:38,430
en elke iteratie increment j.

1923
01:38:38,430 --> 01:38:41,030
>> En dan hier, per
mijn commentaar op lijn 12,

1924
01:38:41,030 --> 01:38:43,390
afdrukken van een karakter,
gevolgd door een nieuwe regel,

1925
01:38:43,390 --> 01:38:48,140
specifiek argv bracket
i geeft me de i-de snaar

1926
01:38:48,140 --> 01:38:51,690
in argv-- dus het eerste woord, de
tweede woord, het derde woord, wat dan ook.

1927
01:38:51,690 --> 01:38:57,370
En dan j duiken in dieper, en krijgt
me de j-de aard van dat woord.

1928
01:38:57,370 --> 01:39:02,200
En dus, in feite, kunt u behandelen
argv als een multidimensionaal,

1929
01:39:02,200 --> 01:39:06,050
als een tweedimensionale, matrix,
waarbij elk woord soort looks

1930
01:39:06,050 --> 01:39:08,580
als dit in uw geest
oog, en elk karakter

1931
01:39:08,580 --> 01:39:10,930
is een soort van samengesteld
een kolom, als dat helpt.

1932
01:39:10,930 --> 01:39:13,260
>> In werkelijkheid, als we plagen
deze apart in de toekomst weken,

1933
01:39:13,260 --> 01:39:15,580
het gaat om een ​​beetje te zijn
geavanceerder dan dat.

1934
01:39:15,580 --> 01:39:17,800
Maar kan je echt
denk dat, voor nu,

1935
01:39:17,800 --> 01:39:22,110
als alleen deze tweedimensionale
matrix, waarbij één niveau ervan

1936
01:39:22,110 --> 01:39:23,260
is alle snaren.

1937
01:39:23,260 --> 01:39:26,760
En dan als je duikt in diepere, u
kunnen krijgen op de afzonderlijke tekens

1938
01:39:26,760 --> 01:39:29,600
vermeen door het gebruik van deze notatie hier.

1939
01:39:29,600 --> 01:39:31,620
>> Dus wat is het netto-effect?

1940
01:39:31,620 --> 01:39:34,970
Laat me ga je gang en
maken argv2-- verdorie.

1941
01:39:34,970 --> 01:39:36,210
Ik heb een fout gemaakt hier.

1942
01:39:36,210 --> 01:39:40,160
Impliciet verklaren de
bibliotheekfunctie Stirling.

1943
01:39:40,160 --> 01:39:42,190
Dus al die tijd, is het
misschien geschikt

1944
01:39:42,190 --> 01:39:45,130
dat we een soort van afwerking
precies waar we begonnen zijn.

1945
01:39:45,130 --> 01:39:48,160
>> Ik heb het verknald, impliciet te verklaren
bibliotheekfunctie Stirling.

1946
01:39:48,160 --> 01:39:48,987
Oké, wacht eens even.

1947
01:39:48,987 --> 01:39:51,070
Ik herinner me dat, in het bijzonder
want het is hier.

1948
01:39:51,070 --> 01:39:54,490
Ik moet string.h onder meer in
Deze versie van het programma.

1949
01:39:54,490 --> 01:40:00,050
>> Laat me ga je gang en omvatten
string.h, behalve dat, ga je gang

1950
01:40:00,050 --> 01:40:04,460
en opnieuw compileren argv2.

1951
01:40:04,460 --> 01:40:08,390
En nu, hier gaan we, maken argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
En al is het een beetje
cryptische op het eerste gezicht,

1953
01:40:10,590 --> 01:40:15,690
merkt dat, inderdaad, wat
wordt gedrukt is dot argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Maar als ik typ enkele woorden na de
prompt, zoals argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Enter, ook een beetje
cryptische op het eerste gezicht.

1956
01:40:22,560 --> 01:40:30,540
Maar als we schuiven back-up,
./argv2 Z-A-M-Y-L-AC-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Dus we hebben herhaald over elk woord.

1958
01:40:32,190 --> 01:40:37,770
En, op zijn beurt, we hebben herhaald op
elk karakter binnen een woord.

1959
01:40:37,770 --> 01:40:40,040
>> Nu, na dit alles,
beseffen dat er

1960
01:40:40,040 --> 01:40:43,120
een ander detail dat we aardig geweest
van het negeren van deze hele tijd.

1961
01:40:43,120 --> 01:40:46,180
We geplaagd net uit elkaar wat
ingangen belangrijkste kan zijn?

1962
01:40:46,180 --> 01:40:47,780
Hoe zit het met de uitgang main's?

1963
01:40:47,780 --> 01:40:50,540
>> Al die tijd hebben we geweest
gewoon kopiëren en plakken

1964
01:40:50,540 --> 01:40:53,870
het woord int in de voorkant van de belangrijkste,
hoewel je online kunt zien,

1965
01:40:53,870 --> 01:40:58,340
soms ten onrechte in oudere versies
van C en compilers, dat zeggen ze leegte,

1966
01:40:58,340 --> 01:40:59,410
of helemaal niets.

1967
01:40:59,410 --> 01:41:01,580
Maar inderdaad de versie
van C die we gebruiken,

1968
01:41:01,580 --> 01:41:06,180
C 11, of 2011, te realiseren
dat int moet zijn.

1969
01:41:06,180 --> 01:41:09,300
En het moet ofwel
nietig of argc en argv hier.

1970
01:41:09,300 --> 01:41:10,790
>> Maar waarom int main?

1971
01:41:10,790 --> 01:41:12,480
Wat is het eigenlijk terug te keren?

1972
01:41:12,480 --> 01:41:16,280
Nou, het blijkt dat dit alles tijd,
elke keer dat je een programma centraal schriftelijke

1973
01:41:16,280 --> 01:41:18,440
is altijd iets terug.

1974
01:41:18,440 --> 01:41:19,960
Maar het is zo in het geheim gedaan.

1975
01:41:19,960 --> 01:41:23,350
>> Dat iets een
int, zoals lijn 5 suggereert.

1976
01:41:23,350 --> 01:41:24,225
Maar wat int?

1977
01:41:24,225 --> 01:41:26,100
Nou, er is dit
conventie in de programmering,

1978
01:41:26,100 --> 01:41:29,790
waarbij er niets aan heeft
misgegaan en alles is goed,

1979
01:41:29,790 --> 01:41:34,250
programma's en functies algemeen
return-- enigszins counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 betekent over het algemeen is alles goed.

1982
01:41:38,070 --> 01:41:40,610
Dus zelfs als je denkt aan
als valse het dikwijls,

1983
01:41:40,610 --> 01:41:42,930
het eigenlijk betekent over het algemeen een goede zaak

1984
01:41:42,930 --> 01:41:49,560
>> Ondertussen, als een programma terug 1,
of negatief 1 of 5, of negatief 42,

1985
01:41:49,560 --> 01:41:52,941
of een niet-waarde 0,
dat algemeen betekent

1986
01:41:52,941 --> 01:41:54,190
dat er iets is misgegaan.

1987
01:41:54,190 --> 01:41:56,700
In feite, op je eigen Mac of pc,
je zou eigenlijk hebben gezien

1988
01:41:56,700 --> 01:42:01,050
een foutmelding, waardoor het
zegt dat het een of ander, fout

1989
01:42:01,050 --> 01:42:04,940
code negatieve 42, of foutcode
23, of iets dergelijks.

1990
01:42:04,940 --> 01:42:08,980
Dat aantal is in het algemeen slechts een hint
de programmeur of het bedrijf

1991
01:42:08,980 --> 01:42:11,174
dat de software gemaakt,
wat er mis ging en waarom,

1992
01:42:11,174 --> 01:42:13,590
zodat ze kunnen kijken door
hun documentatie of code,

1993
01:42:13,590 --> 01:42:15,465
en erachter te komen wat de
fout betekent eigenlijk.

1994
01:42:15,465 --> 01:42:18,400
Het is over het algemeen niet
nuttig voor ons eindgebruikers.

1995
01:42:18,400 --> 01:42:20,550
>> Maar als belangrijkste rendement 0, alles is goed.

1996
01:42:20,550 --> 01:42:23,770
En als je niet opgeeft
wat belangrijkste moet terugkeren,

1997
01:42:23,770 --> 01:42:26,950
het zal gewoon automatisch
0 terug voor jou.

1998
01:42:26,950 --> 01:42:30,870
Maar terug te keren iets
anders is werkelijk nuttig.

1999
01:42:30,870 --> 01:42:34,660
>> In dit laatste programma, laat me
ga je gang en noemen dit exit.c,

2000
01:42:34,660 --> 01:42:38,630
en de invoering van de laatste van vandaag
onderwerpen, die bekend staat als een foutcode.

2001
01:42:38,630 --> 01:42:42,930
Laat me ga je gang en beschikken over ons
vertrouwd bestanden up top, doen int main.

2002
01:42:42,930 --> 01:42:49,500
En deze keer, laten we het doen int argc,
snaar argv, en met mijn beugels

2003
01:42:49,500 --> 01:42:50,836
te impliceren dat het in de array.

2004
01:42:50,836 --> 01:42:52,460
En dan laat ik gewoon een sanity check.

2005
01:42:52,460 --> 01:42:56,640
Deze keer, als argc niet doet
gelijk 2, dan weet je wat?

2006
01:42:56,640 --> 01:42:57,520
Laat maar.

2007
01:42:57,520 --> 01:43:03,170
Ik ga om te zeggen dat, hey, gebruiker,
je mist opdrachtregelargument

2008
01:43:03,170 --> 01:43:04,210
backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> En dan is dat het.

2010
01:43:05,230 --> 01:43:06,130
Ik wil om af te sluiten.

2011
01:43:06,130 --> 01:43:11,030
Ik ga naar preventief,
en voortijdig echt, terugkeer

2012
01:43:11,030 --> 01:43:12,810
iets anders dan het getal 1.

2013
01:43:12,810 --> 01:43:15,360
De go om waarde voor de eerste
error dat kan gebeuren is 1.

2014
01:43:15,360 --> 01:43:17,860
Als u nog een andere foutieve
situatie die zou kunnen optreden,

2015
01:43:17,860 --> 01:43:21,390
je zou kunnen zeggen return 2 of 3 terug te keren, of
misschien zelfs negatief 1 of negatief 2.

2016
01:43:21,390 --> 01:43:23,750
>> Dit zijn slechts exit codes
die algemeen

2017
01:43:23,750 --> 01:43:27,770
alleen handig voor de programmeur, of
bedrijf dat de verzending van de software.

2018
01:43:27,770 --> 01:43:30,500
Maar het feit dat het
niet 0 is wat belangrijk is.

2019
01:43:30,500 --> 01:43:34,310
Dus als in dit programma, wil ik
garanderen dat dit programma alleen

2020
01:43:34,310 --> 01:43:38,190
werkt als de gebruiker me biedt
met een argument telling van twee,

2021
01:43:38,190 --> 01:43:42,880
de naam van het programma, en andere
woord, ik kan zo veel als volgt af te dwingen,

2022
01:43:42,880 --> 01:43:46,110
schreeuwen tegen de gebruiker met printf zeggen,
ontbrekende command line argument,

2023
01:43:46,110 --> 01:43:46,970
terugkeren 1.

2024
01:43:46,970 --> 01:43:49,940
Dat zal alleen maar onmiddellijk
stoppen met het programma.

2025
01:43:49,940 --> 01:43:55,840
>> Alleen als argc gelijk is aan 2 zullen we get down
hier, op welk punt ik ga zeggen,

2026
01:43:55,840 --> 01:44:00,410
hello procent s, backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Met andere woorden, ik ben
niet gaan na argv 0,

2028
01:44:03,827 --> 01:44:05,410
dat is gewoon de naam van het programma.

2029
01:44:05,410 --> 01:44:09,450
Ik wil afdrukken hello, komma,
het tweede woord dat het menselijk getypt.

2030
01:44:09,450 --> 01:44:12,580
En in dit geval op
lijn 13, alles is goed.

2031
01:44:12,580 --> 01:44:15,920
>> Ik weet dat argc is 2
logisch uit dit programma.

2032
01:44:15,920 --> 01:44:17,770
Ik ga om verder te gaan en terug te keren 0.

2033
01:44:17,770 --> 01:44:21,230
Even terzijde, in gedachten houden dat
dit geldt in Scratch ook.

2034
01:44:21,230 --> 01:44:24,760
>> Logisch, zou ik dit doen
en kapselt deze lijnen

2035
01:44:24,760 --> 01:44:27,020
van de code in dit anders clausule hier.

2036
01:44:27,020 --> 01:44:29,420
Maar dat is een soort van
onnodig inspringen mijn code.

2037
01:44:29,420 --> 01:44:31,800
En ik wil super maken
duidelijk dat het niet uitmaakt wat,

2038
01:44:31,800 --> 01:44:34,670
standaard, hello
iets wordt afgedrukt,

2039
01:44:34,670 --> 01:44:36,050
zolang de gebruiker werkt.

2040
01:44:36,050 --> 01:44:39,360
>> Dus het is heel gebruikelijk om te gebruiken
een voorwaarde, maar een if,

2041
01:44:39,360 --> 01:44:41,870
enkele foutieve vangen
situatie, en vervolgens de afslag.

2042
01:44:41,870 --> 01:44:45,690
En dan, zo lang al is
nou ja, niet een anders hebben,

2043
01:44:45,690 --> 01:44:48,060
maar gewoon de code
buiten dat, als omdat het

2044
01:44:48,060 --> 01:44:51,060
equivalent in deze
specifieke geval, logisch.

2045
01:44:51,060 --> 01:44:54,480
Dus ik ben terug te keren 0, gewoon om te
expliciet betekenen alles goed is.

2046
01:44:54,480 --> 01:44:58,480
>> Als ik de return 0 weggelaten, het zou
automatisch worden aangenomen voor mij.

2047
01:44:58,480 --> 01:45:00,890
Maar nu dat ik terugkeer
een in althans casu

2048
01:45:00,890 --> 01:45:04,940
Ik ga voor een goede maatregel en
helderheid, 0 terug in dit geval.

2049
01:45:04,940 --> 01:45:09,690
Dus laat me nu ga je gang en maak exit,
dat is een perfecte segue om gewoon vertrekken.

2050
01:45:09,690 --> 01:45:14,401
>> Maar zorg exit, en laat me gaan
gang en doe ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
En het programma schreeuwde naar me,
ontbrekende command line argument.

2052
01:45:16,900 --> 01:45:18,120
Oké, laat me samenwerken.

2053
01:45:18,120 --> 01:45:23,810
>> Laat me doen in plaats ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
En nu zegt: hello David.

2055
01:45:25,190 --> 01:45:27,300
En je normaal niet zou zien.

2056
01:45:27,300 --> 01:45:30,650
>> Maar het blijkt dat er een
speciale manier in Linux eigenlijk zien

2057
01:45:30,650 --> 01:45:34,470
wat exit code van een programma afgesloten.

2058
01:45:34,470 --> 01:45:37,184
Soms in een grafische
wereld zoals Mac OS of Windows,

2059
01:45:37,184 --> 01:45:40,100
zie je alleen deze nummers wanneer een
foutmelding verschijnt op het scherm

2060
01:45:40,100 --> 01:45:41,940
en de programmeur
laat zien dat nummer.

2061
01:45:41,940 --> 01:45:44,773
Maar als we willen wat de fout te zien
boodschap is, kunnen we het doen hier--

2062
01:45:44,773 --> 01:45:48,100
dus ./exit, Enter, print
ontbrekende command line argument.

2063
01:45:48,100 --> 01:45:54,590
>> Als ik nu doen echo $ ?, dat is
belachelijk cryptische kijken.

2064
01:45:54,590 --> 01:45:56,590
Maar $?

2065
01:45:56,590 --> 01:45:59,220
is de magische bezwering
dat zegt: hey, computer,

2066
01:45:59,220 --> 01:46:01,900
vertel me wat de vorige
programma exit code was.

2067
01:46:01,900 --> 01:46:03,410
En ik druk op Enter.

2068
01:46:03,410 --> 01:46:07,520
Ik zie 1, want dat is wat ik
vertelde mijn belangrijkste functie om terug te keren.

2069
01:46:07,520 --> 01:46:12,310
>> Ondertussen, als ik dat doe ./exit David,
en druk op Enter, zie ik, hallo David.

2070
01:46:12,310 --> 01:46:16,800
En als ik nu doe echo $ ?, Ik zie hello 0.

2071
01:46:16,800 --> 01:46:19,080
En dus dit ook daadwerkelijk
waardevol informatie

2072
01:46:19,080 --> 01:46:23,420
in het kader van de debugger, niet
veel dat je, de mens, zou schelen.

2073
01:46:23,420 --> 01:46:26,060
Maar de debugger en andere
programma's die we zullen dit semester gebruiken

2074
01:46:26,060 --> 01:46:29,420
zal vaak kijken naar dat nummer,
ook al is het een soort van verborgen

2075
01:46:29,420 --> 01:46:32,780
tenzij je voor het kijken, naar
bepalen of een programma

2076
01:46:32,780 --> 01:46:37,050
executie was juist of onjuist.

2077
01:46:37,050 --> 01:46:40,450
>> En dat brengt ons bij
dit, aan het eind van de dag.

2078
01:46:40,450 --> 01:46:43,917
We vandaag de dag begonnen door te kijken naar
debuggen, en op zijn beurt op de cursus

2079
01:46:43,917 --> 01:46:46,750
zelf, en dan meer interessant,
technisch gezien onder de motorkap

2080
01:46:46,750 --> 01:46:49,490
wat snaren zijn, die duren
week namen we gewoon voor lief,

2081
01:46:49,490 --> 01:46:51,900
en zeker nam ze
als vanzelfsprekend in Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Vervolgens hebben we gekeken hoe we kunnen openen
afzonderlijke tekens in een string,

2083
01:46:56,040 --> 01:47:00,310
en dan weer namen een hoger niveau
kijken naar dingen, op zoek naar hoe goed--

2084
01:47:00,310 --> 01:47:04,226
als we willen op individueel te krijgen
elementen in een lijst achtige structuur,

2085
01:47:04,226 --> 01:47:05,850
kunnen we dat niet doen met meerdere snaren?

2086
01:47:05,850 --> 01:47:08,050
En we kunnen met command line argumenten.

2087
01:47:08,050 --> 01:47:12,800
Maar deze foto hier van slechts dozen
is demonstratieve van deze algemene idee

2088
01:47:12,800 --> 01:47:14,451
van een array, of een lijst of een vector.

2089
01:47:14,451 --> 01:47:16,450
En afhankelijk van de
context, al deze woorden

2090
01:47:16,450 --> 01:47:17,880
bedoel iets andere dingen.

2091
01:47:17,880 --> 01:47:20,060
Dus in C, we alleen maar
om te praten over een array.

2092
01:47:20,060 --> 01:47:23,840
En een array is een brok
van het geheugen, elk van hen is

2093
01:47:23,840 --> 01:47:27,720
elementen aaneengesloten zijn rug,
aan rug, aan rug, terug.

2094
01:47:27,720 --> 01:47:31,970
>> En die elementen zijn, in het algemeen,
van hetzelfde gegevenstype, karakter,

2095
01:47:31,970 --> 01:47:35,966
karakter, karakter, karakter, of
Zeen, Zeen, Zeen, Zeen, of int,

2096
01:47:35,966 --> 01:47:38,600
int, int, wat het ook is
we proberen te slaan.

2097
01:47:38,600 --> 01:47:42,540
Maar aan het eind van de dag, is
hoe het eruit ziet conceptueel.

2098
01:47:42,540 --> 01:47:44,530
Je neemt je
geheugen of RAM computer.

2099
01:47:44,530 --> 01:47:48,590
En je carving it out in
even grote dozen, die

2100
01:47:48,590 --> 01:47:50,920
zijn terug, naar achter, naar
terug aan rug op deze manier.

2101
01:47:50,920 --> 01:47:53,200
>> En wat is er leuk is aan
dit idee en het feit

2102
01:47:53,200 --> 01:47:58,580
dat we waarden zo kunnen uitdrukken
de eerste van onze datastructuren

2103
01:47:58,580 --> 01:48:02,520
in de klas, betekent dat we kunnen beginnen
om problemen met de code op te lossen

2104
01:48:02,520 --> 01:48:04,079
dat kwam zo intuïtief in week 0.

2105
01:48:04,079 --> 01:48:05,870
U vindt de telefoon te roepen
boek bijvoorbeeld, waar

2106
01:48:05,870 --> 01:48:09,110
We gebruikten een verdeel en heers,
of een binaire zoekalgoritme,

2107
01:48:09,110 --> 01:48:13,220
te ziften door middel van een hele
bos van namen en nummers.

2108
01:48:13,220 --> 01:48:18,220
Maar we zijn ervan uitgegaan, rappel, dat
telefoonboek was al naargelang,

2109
01:48:18,220 --> 01:48:21,630
dat iemand anders had al
dacht out-- gegeven een lijst met namen

2110
01:48:21,630 --> 01:48:24,430
en numbers-- hoe ze alfabetisch.

2111
01:48:24,430 --> 01:48:26,950
En nu dat in C we,
Ook hebben de mogelijkheid

2112
01:48:26,950 --> 01:48:30,290
om dingen lay-out, niet
fysiek in een telefoonboek

2113
01:48:30,290 --> 01:48:34,220
maar vrijwel in een computer
geheugen, zullen we in staat volgende week

2114
01:48:34,220 --> 01:48:38,470
om opnieuw te introduceren dit-- de eerste
van onze data structuren in een array--

2115
01:48:38,470 --> 01:48:43,530
maar nog belangrijker, werkelijke computer
science algoritmen geïmplementeerd

2116
01:48:43,530 --> 01:48:47,720
in de code, waarmee we kunnen opslaan
data in structuren zoals deze,

2117
01:48:47,720 --> 01:48:50,730
en dan beginnen te manipuleren, en
daadwerkelijk problemen mee,

2118
01:48:50,730 --> 01:48:53,570
en voort te bouwen op de top van dat,
uiteindelijk programma in C,

2119
01:48:53,570 --> 01:48:56,730
in Python, in JavaScript,
bevragen van databases met SQL?

2120
01:48:56,730 --> 01:48:59,980
>> En we zullen zien dat al deze
verschillende ideeën interlock.

2121
01:48:59,980 --> 01:49:04,100
Maar voor nu, herinneren dat de
domein dat we vandaag geïntroduceerd

2122
01:49:04,100 --> 01:49:06,920
was dit ding hier, en
de wereld van cryptografie.

2123
01:49:06,920 --> 01:49:11,200
En een van de volgende problemen die u zelf
zal oplossen is de kunst van cryptografie,

2124
01:49:11,200 --> 01:49:13,630
klauteren en de-klauteren
informatie en ciphering

2125
01:49:13,630 --> 01:49:15,930
en ontcijferen tekst,
en uitgaande uiteindelijk

2126
01:49:15,930 --> 01:49:18,970
dat je nu weet wat
is onder de motorkap

2127
01:49:18,970 --> 01:49:21,860
zodat wanneer je ziet of ontvangt
een bericht als dit, je

2128
01:49:21,860 --> 01:49:24,060
je kan ontcijferen.

2129
01:49:24,060 --> 01:49:26,740
Dit alles, en nog veel meer de volgende keer.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO AFSPELEN]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Net aangekomen.

2133
01:49:32,970 --> 01:49:35,146
Ik ga om te gaan bezoeken
zijn college professor.

2134
01:49:35,146 --> 01:49:37,611
Yep.

2135
01:49:37,611 --> 01:49:40,080
Hoi.

2136
01:49:40,080 --> 01:49:40,660
Jij bent het.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Wacht!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Ik probeer alleen maar te achterhalen
wat er met je gebeurd.

2142
01:49:56,060 --> 01:49:58,130
Gelieve, om het even wat zou kunnen helpen.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Je was zijn college
kamergenoot, was je niet?

2145
01:50:08,354 --> 01:50:10,770
Je was er bij hem toen
Hij eindigde de CS50-project?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [Muziek]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -dat Was CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Ik hou van deze plek.

2152
01:50:44,770 --> 01:50:45,854
>> -Eet op.

2153
01:50:45,854 --> 01:50:47,020
We gaan uit van het bedrijfsleven.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END AFSPELEN]

