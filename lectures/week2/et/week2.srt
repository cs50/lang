1
00:00:00,000 --> 00:00:02,970
>> [MUSIC MÄNGIB]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Humala: Hea küll.

4
00:00:15,700 --> 00:00:18,832
See on CS50 ja see
on algus 2. nädal.

5
00:00:18,832 --> 00:00:21,040
Ja võite meelde tuletada, et üle
Viimase paari nädala jooksul,

6
00:00:21,040 --> 00:00:24,490
viisime sisse arvuti
teaduse ja omakorda, programmeerimine.

7
00:00:24,490 --> 00:00:27,640
>> Ja hakkasime lugu teel
Scratch, et graafiline keel

8
00:00:27,640 --> 00:00:28,990
MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
Ja siis viimasena
Eelmisel nädalal tegime

10
00:00:30,780 --> 00:00:34,450
kehtestada higher--
madalama taseme keeles tuntud

11
00:00:34,450 --> 00:00:36,770
C, midagi, mis on puhtalt tekstiline.

12
00:00:36,770 --> 00:00:39,440
Ja tõesti, viimane kord
uurida selles kontekstis

13
00:00:39,440 --> 00:00:40,450
mitmeid kontseptsioone.

14
00:00:40,450 --> 00:00:43,010
>> See, mäletate, oli väga
Esimene programm me vaatasime.

15
00:00:43,010 --> 00:00:45,710
Ja seda programmi, lihtsalt
prindib välja, "Tere, maailm."

16
00:00:45,710 --> 00:00:47,730
Aga seal on nii palju
näilisest magic toimub.

17
00:00:47,730 --> 00:00:51,460
Seal on see #include
Nende noolsulgudega.

18
00:00:51,460 --> 00:00:52,170
Seal on int.

19
00:00:52,170 --> 00:00:53,020
Seal (void).

20
00:00:53,020 --> 00:00:56,330
Seal on sulgudes, looksulg,
semikoolonite, ja nii palju.

21
00:00:56,330 --> 00:00:58,480
>> Ja nii, meelde tuletada, et
meil kasutusele Scratch

22
00:00:58,480 --> 00:01:02,110
nii et me võiks ideaalis näha minevikku
et süntaks, asju, mis pole tegelikult

23
00:01:02,110 --> 00:01:04,590
kõik, mis intellektuaalselt
huvitav, kuid juba varakult

24
00:01:04,590 --> 00:01:07,700
on absoluutselt, natuke keeruline
wrap meelt umbes.

25
00:01:07,700 --> 00:01:10,860
Ja tõepoolest, üks levinumaid
asju varakult programmeerimise klassi,

26
00:01:10,860 --> 00:01:13,443
eriti neile vähem
mugav, on saada pettunud

27
00:01:13,443 --> 00:01:17,460
ja kompastumisen teatud süntaktilise
vigadest, rääkimata loogiline vigadest.

28
00:01:17,460 --> 00:01:19,800
Ja nii üks meie eesmärke
täna, tegelikult, eks

29
00:01:19,800 --> 00:01:23,280
olla varustada teid mõned
probleemide lahendamise tehnikaid kuidas

30
00:01:23,280 --> 00:01:26,705
paremini lahendada probleeme ise
kujul silumine.

31
00:01:26,705 --> 00:01:29,330
Ja teil meenutada ka, et
keskkonda, milles me sisse

32
00:01:29,330 --> 00:01:31,780
Viimast korda kutsuti CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
See on veebipõhine tarkvara, mis
võimaldab teil programmeerida pilv,

34
00:01:34,850 --> 00:01:38,450
niiöelda, hoides kogu oma
failid koos, kui me jälle täna.

35
00:01:38,450 --> 00:01:41,480
Ja meenutada, et me
vaadata neid teemasid siin,

36
00:01:41,480 --> 00:01:44,480
nende seas funktsioonid ning silmusesse
muutujad ja Boole'i ​​väljendeid,

37
00:01:44,480 --> 00:01:45,110
ja tingimusi.

38
00:01:45,110 --> 00:01:49,190
Ja tegelikult veel mõned, et me
tõlgitud maailma Scratch

39
00:01:49,190 --> 00:01:50,800
maailma C.

40
00:01:50,800 --> 00:01:53,220
>> Aga põhiline hoone
plokid, nii et rääkida,

41
00:01:53,220 --> 00:01:55,150
olid tõesti ikka sama eelmisel nädalal.

42
00:01:55,150 --> 00:01:57,900
Tegelikult on meil tõesti oli just
erinevat pusletükk, kui soovite.

43
00:01:57,900 --> 00:02:00,300
Selle asemel, et lilla
salvestada plokk, me asemel

44
00:02:00,300 --> 00:02:02,940
oli printf, mis on
Selle funktsiooni C, et

45
00:02:02,940 --> 00:02:05,890
võimaldab printida midagi
ja vormi seda ekraanil.

46
00:02:05,890 --> 00:02:07,950
Me tutvustas CS50
Raamatukogu, kus te

47
00:02:07,950 --> 00:02:11,420
on nüüd teie käsutuses get_char,
ja get_int ja get_string,

48
00:02:11,420 --> 00:02:14,610
ja mõned muud funktsioonid
noh, mille kaudu saad sisestada

49
00:02:14,610 --> 00:02:16,260
kasutaja enda klaviatuuri.

50
00:02:16,260 --> 00:02:20,640
Ja meil on ka vaatlesime asju
nagu these- bool ja paalia,

51
00:02:20,640 --> 00:02:22,490
ja double, float,
int, long_long string.

52
00:02:22,490 --> 00:02:25,170
Ja seal on isegi muid andmeid liigid C.

53
00:02:25,170 --> 00:02:28,560
>> Teisisõnu, kui kuulutada
muutuja salvestada mingi väärtuse,

54
00:02:28,560 --> 00:02:32,600
või kui rakendada funktsiooni
mis tagastab mingi väärtuse,

55
00:02:32,600 --> 00:02:35,290
saate määrata, milliseid
tüüpi väärtus, mis on.

56
00:02:35,290 --> 00:02:37,310
Kas see on string, nagu
märgijada?

57
00:02:37,310 --> 00:02:39,490
Kas see on number, nagu täisarv?

58
00:02:39,490 --> 00:02:41,390
Kas see on ujukoma
väärtust vms?

59
00:02:41,390 --> 00:02:46,180
Nii C erinevalt Scratch, me tegelikult
hakkas täpsustanud, milliseid andmeid

60
00:02:46,180 --> 00:02:48,330
olime tagasi või kasutades.

61
00:02:48,330 --> 00:02:51,910
>> Aga muidugi on meil ka sattus
mõned põhipiirangut arvutustehnika.

62
00:02:51,910 --> 00:02:54,100
Ja eriti
Selle keele C, turult

63
00:02:54,100 --> 00:02:57,070
et me vaatlesime
täisarv ülevoolu, tegelikkus

64
00:02:57,070 --> 00:03:00,460
et kui sul on ainult
piiratud kogus mälu

65
00:03:00,460 --> 00:03:04,600
või täpsemalt hulga
bittide, saad ainult loota nii kõrge.

66
00:03:04,600 --> 00:03:08,460
Ja nii me vaatasime seda näiteks siin
kusjuures counter lennukis,

67
00:03:08,460 --> 00:03:13,510
tegelikult, kui töötab piisavalt pikk oleks
ülevoolu ja põhjustada tarkvara

68
00:03:13,510 --> 00:03:15,560
tegeliku füüsilise potentsiaali viga.

69
00:03:15,560 --> 00:03:18,600
>> Me vaadeldi ka ujuva
punkti ebatäpsus, tegelikkus

70
00:03:18,600 --> 00:03:22,280
et ainult piiratud arvu
bittide, kas see on 32 või 64,

71
00:03:22,280 --> 00:03:27,330
saab määrata ainult nii palju numbreid
pärast koma, pärast mida

72
00:03:27,330 --> 00:03:29,110
alustada saada ebatäpne.

73
00:03:29,110 --> 00:03:32,360
Nii näiteks ühe kolmandiku võrra
maailma siin, inimeste maailma,

74
00:03:32,360 --> 00:03:35,360
me teame, on ainult lõpmatu arv
ning 3s pärast koma.

75
00:03:35,360 --> 00:03:38,820
Aga arvuti ei saa tingimata
esindavad lõpmatu arv numbrid

76
00:03:38,820 --> 00:03:42,590
kui sa ainult seda lubavad mõned
piiratud hulgal teavet.

77
00:03:42,590 --> 00:03:45,900
>> Nii et mitte ainult ei me varustada teid
suurema võimsuse poolest

78
00:03:45,900 --> 00:03:49,280
kuidas siis võib väljendada ennast
klaviatuuri poolest programmeerimine,

79
00:03:49,280 --> 00:03:51,430
meil on ka piiratud, mida
tegelikult võite seda teha.

80
00:03:51,430 --> 00:03:55,790
Ja tõepoolest, vead ja vigu võib
tekivad seda tüüpi küsimusi.

81
00:03:55,790 --> 00:03:59,900
Ja tõepoolest, üks teemasid täna
hakkavad teemasid nagu silumine

82
00:03:59,900 --> 00:04:03,699
ja tegelikult otsivad all kapuuts
kuidas asjad toodi eelmisel nädalal

83
00:04:03,699 --> 00:04:05,490
tegelikult ellu
nii et sa parem

84
00:04:05,490 --> 00:04:10,530
mõista nii võimeid ja
piirangud keeles nagu C

85
00:04:10,530 --> 00:04:14,770
>> Ja tegelikult, me Tõmmake kihid
lihtsamaid andmete struktuuri,

86
00:04:14,770 --> 00:04:17,756
midagi, mida nimetatakse massiivi, mis
Scratch juhtub nimetame "nimekirja."

87
00:04:17,756 --> 00:04:19,589
See on natuke
erinevad selles kontekstis.

88
00:04:19,589 --> 00:04:23,340
Ja siis me ka tutvustada üks
Esimene meie valdkonnapõhised probleeme

89
00:04:23,340 --> 00:04:26,790
aastal CS50, maailma
krüptograafia, kunst segunemise

90
00:04:26,790 --> 00:04:29,650
või šifreerimine informatsiooni nii
et võite saata salajasi teateid

91
00:04:29,650 --> 00:04:34,520
ja dekodeerida saladus teateid
kahe isiku vahel, A ja B.

92
00:04:34,520 --> 00:04:37,490
>> Nii enne kui me üleminek
Selle uue maailma,

93
00:04:37,490 --> 00:04:42,059
Proovime varustada teid mõned
tehnikat, millega saab kõrvaldada

94
00:04:42,059 --> 00:04:43,850
või vähendada vähemalt mõned
pettumusi

95
00:04:43,850 --> 00:04:46,630
et teil on ilmselt tekkinud
viimase nädala jooksul üksi.

96
00:04:46,630 --> 00:04:50,830
Tegelikult su ees on such-- mõned
Teie esimene probleeme C. Ja koefitsiendid,

97
00:04:50,830 --> 00:04:54,010
Kui sa oled nagu mina, esimest korda
püüad tüüp välja programm,

98
00:04:54,010 --> 00:04:57,330
isegi siis, kui te arvate, loogiliselt
programm on üsna lihtne,

99
00:04:57,330 --> 00:05:01,200
võite väga hästi tabanud seina ja
koostaja ei kavatse koostööd.

100
00:05:01,200 --> 00:05:03,940
Tee või rõkkama ei kavatse
tegelikult teha oma pakkumise.

101
00:05:03,940 --> 00:05:05,450
>> Ja miks see võiks olla?

102
00:05:05,450 --> 00:05:07,950
Noh, kui heita pilk,
ehk lihtne programm.

103
00:05:07,950 --> 00:05:11,190
Ma lähen edasi minna ja päästa seda
faili teadlikult nn buggy0.c,

104
00:05:11,190 --> 00:05:13,590
sest ma tean, et see
puudulikud ette.

105
00:05:13,590 --> 00:05:17,400
Aga ma ei pruugi mõista, et kui see
on esimene või teine ​​või kolmas programm

106
00:05:17,400 --> 00:05:18,830
et ma tegelikult teeb ise.

107
00:05:18,830 --> 00:05:23,820
Nii et ma lähen edasi minna ja
tüüp välja, int main (void).

108
00:05:23,820 --> 00:05:28,130
Ja siis sees minu looksulg,
väga tuttav ( "tere, world--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - ja semikooloniga.

110
00:05:30,980 --> 00:05:32,360
>> Olen salvestatud faili.

111
00:05:32,360 --> 00:05:34,850
Nüüd ma lähen alla
minu terminali aknas

112
00:05:34,850 --> 00:05:40,340
ja liiki make buggy0, sest jällegi
nimi faili täna buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Nii I tüüpi muuta buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> Ja oh jumal, mäletate viimast korda
et ükski veateated on hea.

115
00:05:48,200 --> 00:05:49,740
Seega ei ole väljund on hea.

116
00:05:49,740 --> 00:05:52,920
Aga siin mul selgelt
mõned vigade arvu.

117
00:05:52,920 --> 00:05:56,470
>> Nii et esimene rida väljund
pärast kirjutades teha buggy0, meenutada,

118
00:05:56,470 --> 00:05:59,540
on rõkkama on üsna paljusõnaline väljund.

119
00:05:59,540 --> 00:06:02,067
All kapuuts,
CS50 IDE on seadistatud

120
00:06:02,067 --> 00:06:04,150
kasutada terve hulk
võimalusi selle koostaja

121
00:06:04,150 --> 00:06:05,941
nii et sa ei pea
mõelda neist.

122
00:06:05,941 --> 00:06:08,840
Ja see on kõik, mis esimese rea
vahendid, mis algab rõkkama.

123
00:06:08,840 --> 00:06:11,720
>> Kuid pärast seda, probleemid
hakata tegema oma välimust.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c rea 3, iseloomu
5, on suur, punane viga.

125
00:06:17,390 --> 00:06:18,380
Mis see on?

126
00:06:18,380 --> 00:06:23,562
Kaudselt kuulutatakse raamatukogu funktsiooni
printf tüüpi int (const char *

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Ma mõtlen, et see väga kiiresti
läheb väga kauge.

129
00:06:28,379 --> 00:06:30,170
Ja kindlasti, esimesel
lühidalt, me ei

130
00:06:30,170 --> 00:06:32,380
eeldada, et sa aru
kogu see sõnum.

131
00:06:32,380 --> 00:06:34,213
Ja nii üks lugu
täna läheb

132
00:06:34,213 --> 00:06:36,919
olema püüda märgata
mustrid, või sarnaseid asju,

133
00:06:36,919 --> 00:06:38,960
vigu, mida oleks võinud
varem kokku puutunud.

134
00:06:38,960 --> 00:06:41,335
Nii saab õrritama peale ainult
need sõnad, mis näevad välja tuttav.

135
00:06:41,335 --> 00:06:44,290
Suur, punane viga on selgelt
sümboolne midagi on valesti.

136
00:06:44,290 --> 00:06:47,940
>> kaudselt kuulutatakse
raamatukogu funktsiooni printf.

137
00:06:47,940 --> 00:06:51,680
Nii et isegi kui ma ei saa aru, mis
kaudselt kuulutatakse raamatukogu funktsiooni

138
00:06:51,680 --> 00:06:54,900
vahenditega, probleem kindlasti
seotud printf kuidagi.

139
00:06:54,900 --> 00:06:59,130
Ja allikas, et küsimus
on pistmist väljakuulutamiseks.

140
00:06:59,130 --> 00:07:02,440
>> Kuulutatakse funktsioon on
viitavad see esimest korda.

141
00:07:02,440 --> 00:07:06,210
Ja me kasutasime terminoloogia eelmisel nädalal
tunnistamise funktsioon prototüüp,

142
00:07:06,210 --> 00:07:11,860
kas ühe rea peal oma
ise fail või nn päisefaili.

143
00:07:11,860 --> 00:07:15,300
Ja mida faili tegid ütleme
eelmisel nädalal, et printf on tsitaat,

144
00:07:15,300 --> 00:07:17,080
lõppeb, deklareeritud?

145
00:07:17,080 --> 00:07:20,950
Mis fail on selle prototüüp?

146
00:07:20,950 --> 00:07:24,640
>> Nii et kui te mäletate, kõige esimene asi, mida ma
trükitud, peaaegu iga programmi viimase AEG_

147
00:07:24,640 --> 00:07:30,790
ja kogemata hetk tagasi alustas
kirjutades myself-- oli see üks siin--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- eest
sisend / output-- dot h Ja tõepoolest,

149
00:07:38,630 --> 00:07:41,860
kui ma nüüd salvestada faili, et ma lähen
minna ja selge minu ekraanil,

150
00:07:41,860 --> 00:07:44,740
mida saate teha kirjutades
Läbipaistev, või saate hoida kontrolli L,

151
00:07:44,740 --> 00:07:47,680
lihtsalt kustutada oma terminali aknas
lihtsalt kõrvaldada mõned segadusega.

152
00:07:47,680 --> 00:07:51,370
>> Ma lähen edasi minna ja
re-tüüpi make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
Ja voila, ma ikka näha, et
pikk käsk rõkkama,

154
00:07:53,790 --> 00:07:55,470
kuid seal ei veateate seekord.

155
00:07:55,470 --> 00:07:58,800
Ja tõepoolest, kui ma ./buggy0,
nagu viimane kord,

156
00:07:58,800 --> 00:08:01,860
kus dot tähendab see
kataloog, Slash tähendab lihtsalt,

157
00:08:01,860 --> 00:08:05,040
siin on programmi nimi ja
mis programmi nimi on buggy0,

158
00:08:05,040 --> 00:08:07,340
Sisesta, "Tere, maailm."

159
00:08:07,340 --> 00:08:09,440
>> Nüüd, kuidas võib teil
väita seda lahendust

160
00:08:09,440 --> 00:08:12,017
ilma et see tingimata
tunnistades nii palju sõnu

161
00:08:12,017 --> 00:08:14,350
kui mina, kindlasti, võttes
seda teinud nii palju aastaid?

162
00:08:14,350 --> 00:08:18,720
Noh, mõistad kohta esimene probleem
komplekt, me tutvustada teile käsu

163
00:08:18,720 --> 00:08:21,175
et CS50 enda töötajad
kirjutas nimetatakse help50.

164
00:08:21,175 --> 00:08:24,300
Ja tõepoolest, C teeb spetsifikatsioon
probleemi seatud, kuidas kasutada seda.

165
00:08:24,300 --> 00:08:27,210
>> Aga help50 on sisuliselt
programm, mis CS50 töötajad

166
00:08:27,210 --> 00:08:30,850
kirjutas, et saab käivitada
käsu või käivitada programme,

167
00:08:30,850 --> 00:08:36,169
ja kui sa ei mõista selle
väljund, läbida oma toodangut help50,

168
00:08:36,169 --> 00:08:38,890
misjärel tarkvara
et loomulikult töötajate kirjutas

169
00:08:38,890 --> 00:08:42,429
otsib oma programmi väljund
rida-realt, tähthaaval.

170
00:08:42,429 --> 00:08:46,000
Ja kui me töötajad, tunnustada
veateate, et sul on,

171
00:08:46,000 --> 00:08:50,580
püüame provotseerida teile mõned
retorisia, mõned nõuanded,

172
00:08:50,580 --> 00:08:54,890
palju nagu TF või CA või ise
teeks isiklikult tööaega.

173
00:08:54,890 --> 00:08:58,320
>> Nii vaatame help50 kui te ei
pruugi tunda probleem.

174
00:08:58,320 --> 00:09:00,790
Aga ei tugine ta
liiga palju kark.

175
00:09:00,790 --> 00:09:03,990
Kindlasti püüa mõista selle
väljund ja siis õppida seda

176
00:09:03,990 --> 00:09:07,571
nii et ainult üks või kaks korda sa
kunagi joosta help50 konkreetse viga

177
00:09:07,571 --> 00:09:08,070
sõnum.

178
00:09:08,070 --> 00:09:10,660
Pärast seda, sa peaksid olema
paremini varustatud ise

179
00:09:10,660 --> 00:09:13,180
aru saada, mis see tegelikult on.

180
00:09:13,180 --> 00:09:14,350
>> Teeme ühe teise siin.

181
00:09:14,350 --> 00:09:20,410
Lubage mul minna ja teises
file me nimetame seda buggy1.c.

182
00:09:20,410 --> 00:09:23,110
Ja seda faili ma olen
läheb deliberately--

183
00:09:23,110 --> 00:09:26,330
kuid teeselda, et ma ei ole
mõista, mis viga olen teinud.

184
00:09:26,330 --> 00:09:31,420
>> Ma lähen edasi minna ja seda see--
#include, sest ma olen

185
00:09:31,420 --> 00:09:33,660
õppinud minu õppetund hetk tagasi.

186
00:09:33,660 --> 00:09:36,220
Int main (void), kui enne.

187
00:09:36,220 --> 00:09:40,880
Ja siis siin ma lähen
teha string s - get_string.

188
00:09:40,880 --> 00:09:43,770
Ja mäletate viimast korda
See tähendab, hei, arvuti,

189
00:09:43,770 --> 00:09:48,280
mulle varieeruv, nimetame seda s, ja
teha, millist tüüpi muutuja string

190
00:09:48,280 --> 00:09:50,150
nii et ma mahutab ühest või mitmest sõnast ta.

191
00:09:50,150 --> 00:09:52,191
>> Ja siis paremal
pool võrdusmärki

192
00:09:52,191 --> 00:09:54,980
on get_string, mis on
funktsiooni CS50 raamatukogu

193
00:09:54,980 --> 00:09:55,980
et just selline.

194
00:09:55,980 --> 00:09:59,740
Läheb funktsioon ja seejärel
käed see paremalt vasakule.

195
00:09:59,740 --> 00:10:02,670
Nii et see võrdusmärk ei tähenda
"Võrdub", nagu me võiks arvata, matemaatika.

196
00:10:02,670 --> 00:10:04,750
See tähendab loovutamine paremalt vasakule.

197
00:10:04,750 --> 00:10:09,640
Nii et see tähendab, võtab stringi
kasutaja ja hoidke seda sees s.

198
00:10:09,640 --> 00:10:10,460
>> Nüüd seda kasutada.

199
00:10:10,460 --> 00:10:13,820
Lubage mul minna nüüd ja teise
line, lubage mul minna ja öelda "tere" -

200
00:10:13,820 --> 00:10:19,330
mitte "maailmas", aga "tere,% S-
mis on meie kohatäide, koma s,

201
00:10:19,330 --> 00:10:22,030
mis on meie muutuja,
ja seejärel semikooloniga.

202
00:10:22,030 --> 00:10:26,070
Nii et kui ma ei kruvi liiga palju
siin, see näeb välja nagu õige koodi.

203
00:10:26,070 --> 00:10:28,090
>> Ja mu instinktid nüüd on kompileerida.

204
00:10:28,090 --> 00:10:30,400
Fail nimega buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Nii et ma lähen tegema teha buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
Ja darn-it, kui ei ole
isegi rohkem vigu kui enne.

207
00:10:36,377 --> 00:10:38,210
Ma mõtlen, et seal on rohkem
veateateid see oleks

208
00:10:38,210 --> 00:10:40,400
tundub kui tegelik rida selles programmis.

209
00:10:40,400 --> 00:10:42,730
>> Aga Buffee siin on,
isegi kui sa oled ülekoormatud

210
00:10:42,730 --> 00:10:45,040
kahe või kolme või
veel neli veateateid,

211
00:10:45,040 --> 00:10:48,340
keskenduda alati väga
Esimene neist sõnumeid.

212
00:10:48,340 --> 00:10:52,220
Vaadates kõige ülemisele üks,
kerimine varukoopiasse pea olema.

213
00:10:52,220 --> 00:10:53,930
Nii et siin ma kirjutada make buggy1.

214
00:10:53,930 --> 00:10:55,700
Siin ongi rõkkama väljund ootuspäraselt.

215
00:10:55,700 --> 00:10:57,290
>> Ja siin on esimene punane viga.

216
00:10:57,290 --> 00:11:02,370
Kasuta deklareerimata identifitseerimine
string, ma tähenda standardiks?

217
00:11:02,370 --> 00:11:04,260
Nii standard on
tegelikult midagi muud.

218
00:11:04,260 --> 00:11:06,240
See viitab kasutaja
klaviatuur, sisuliselt.

219
00:11:06,240 --> 00:11:08,080
>> Aga see pole see, mida ma mõtlesin.

220
00:11:08,080 --> 00:11:11,770
Ma mõtlesin string, ja ma mõtlesin get_string.

221
00:11:11,770 --> 00:11:16,200
Mis on see, et ma
unustasin teha sel ajal?

222
00:11:16,200 --> 00:11:20,230
Mis puudu sel ajal?

223
00:11:20,230 --> 00:11:23,600
Mul on #include,
nii et mul on juurdepääs printf.

224
00:11:23,600 --> 00:11:26,090
>> Aga mida ma ei pea
juurdepääsu veel?

225
00:11:26,090 --> 00:11:29,420
Noh, nagu viimasel ajal
Mul on vaja öelda tõlkija

226
00:11:29,420 --> 00:11:31,691
Rõkkama, mida need funktsioonid on.

227
00:11:31,691 --> 00:11:33,940
Get_string ei tule
C. Ja eelkõige see

228
00:11:33,940 --> 00:11:38,160
ei tulnud
header faili.

229
00:11:38,160 --> 00:11:40,770
Selle asemel tuleb
midagi personali kirjutas,

230
00:11:40,770 --> 00:11:44,176
mis on eri faili
nimi, aga tabavalt nimeks.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Nii lihtsalt, lisades, et üks rida
ning code-- tagasikutsumise viimast korda

233
00:11:50,861 --> 00:11:53,610
et kui rõkkama jookseb, siis läheb
pilk minu kood ülevalt alla,

234
00:11:53,610 --> 00:11:54,193
vasakult paremale.

235
00:11:54,193 --> 00:11:57,200
See saab märgata,
oh, kui soovite.

236
00:11:57,200 --> 00:11:59,900
Lubage mul minna ja leida, et
kus see asub serveril,

237
00:11:59,900 --> 00:12:03,090
kopeeri ja kleebi see sisuliselt
ülemisse oma faili

238
00:12:03,090 --> 00:12:06,820
nii et siinkohal lugu,
line 1, ülejäänud programmi

239
00:12:06,820 --> 00:12:11,651
võib tõepoolest kasutada ükskõik millist funktsioonid
seal, nende seas get_string.

240
00:12:11,651 --> 00:12:13,650
Nii et ma lähen ignoreerida
Ülejäänud need vead,

241
00:12:13,650 --> 00:12:17,190
sest ma tõesti arvan, et ainult
esimene tegelikult Olulised.

242
00:12:17,190 --> 00:12:20,780
Ja ma lähen edasi minna ja kordamisega,
pärast salvestamist minu faili teha buggy1.

243
00:12:20,780 --> 00:12:22,580
Ja voila, ta tegi tööd.

244
00:12:22,580 --> 00:12:29,200
Ja kui ma ./buggy1 ja kirjuta jaoks
Näiteks Zamyla, ma nüüd saan tere,

245
00:12:29,200 --> 00:12:32,000
Zamyla asemel Hello, world.

246
00:12:32,000 --> 00:12:32,550
>> Hästi.

247
00:12:32,550 --> 00:12:35,890
Nii takeaways siin siis on,
üks, proovige noppima nii palju kui võimalik

248
00:12:35,890 --> 00:12:39,140
alates veateateid üksi, vaadates
mõningaid äratuntav sõnu.

249
00:12:39,140 --> 00:12:43,070
Piirangu, et kasutada help50 kohta
Probleemi määratud kirjelduses.

250
00:12:43,070 --> 00:12:46,500
Aga piirangu, et ka alati vaadata
ülaosas viga ainult, vähemalt

251
00:12:46,500 --> 00:12:50,051
Esialgu näha, millist teavet
see võib tegelikult anda.

252
00:12:50,051 --> 00:12:52,300
Aga selgub, et tema
isegi rohkem funktsioone ehitatud

253
00:12:52,300 --> 00:12:55,030
arvesse CS50 raamatukogu aidata
sa varakult semestri

254
00:12:55,030 --> 00:12:57,580
ja varakult programmeerimine
aru saada, mis on valesti.

255
00:12:57,580 --> 00:12:59,840
Nii teeme järjekordne näide siin.

256
00:12:59,840 --> 00:13:04,350
Ma nimetan seda buggy2, mis
jälle läheb vigane välja

257
00:13:04,350 --> 00:13:05,650
värava, mille disain.

258
00:13:05,650 --> 00:13:09,980
>> Ja ma lähen edasi minna
ja teha #include.

259
00:13:09,980 --> 00:13:12,580
Ja siis ma lähen tegema int main (void).

260
00:13:12,580 --> 00:13:14,840
Ja siis ma lähen tegema jaoks silmus.

261
00:13:14,840 --> 00:13:16,690
Jaoks (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i on väiksem või võrdne 10.

263
00:13:18,750 --> 00:13:24,260
i ++ ja seejärel looksulg, ma lähen
välja trükkida vaid hashtag sümbol siin

264
00:13:24,260 --> 00:13:25,920
ja reavahetusmärki.

265
00:13:25,920 --> 00:13:29,220
>> Nii et minu eesmärgiks selles
Programm on lihtsalt

266
00:13:29,220 --> 00:13:33,150
itereerima 10 korda
ja iga iteratsiooni

267
00:13:33,150 --> 00:13:35,260
Selle silmus iga kord
kaudu tsükli

268
00:13:35,260 --> 00:13:37,660
välja printida hashtag,
hashtag, hashtag.

269
00:13:37,660 --> 00:13:40,480
Üks rea kohta, sest ma
on uus liin seal.

270
00:13:40,480 --> 00:13:42,787
Ja meenutada, et eest
loop, ühe viimase week--

271
00:13:42,787 --> 00:13:44,620
ja saate rohkem
tuttav süntaks

272
00:13:44,620 --> 00:13:47,170
kasutades seda tava
enne long-- see annab mulle

273
00:13:47,170 --> 00:13:49,740
muutuva nimetatakse i ja häälestab selle 0.

274
00:13:49,740 --> 00:13:52,650
>> See kasvatab i kohta
Iga iteratsiooni 1.

275
00:13:52,650 --> 00:13:54,940
Nii i läheb 1 kuni 2-3.

276
00:13:54,940 --> 00:13:57,690
Ja siis seda tingimust
Lähis vahel semikoolonite

277
00:13:57,690 --> 00:14:03,010
saab kontrollida iga iteratsiooni teha
kindel, et me oleme ikka tööpiirkonnas.

278
00:14:03,010 --> 00:14:06,830
Ma tahan kinnitada, 10 korda, nii et ma
on omamoodi väga intuitiivselt lihtsalt

279
00:14:06,830 --> 00:14:09,070
pane 10 kui minu ülemise seal.

280
00:14:09,070 --> 00:14:14,310
>> Ja veel, kui ma saan selle pärast
kompileerimisel koos margi buggy2--

281
00:14:14,310 --> 00:14:15,440
ja see ei kompileerida OK.

282
00:14:15,440 --> 00:14:17,980
Nii et ma ei ole
syntaksivirhettä seekord.

283
00:14:17,980 --> 00:14:20,940
Lubage mul minna nüüd
ja joosta buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
Ja nüüd keri üles.

285
00:14:22,620 --> 00:14:24,890
Ja las ma suurendada
suurust akna.

286
00:14:24,890 --> 00:14:33,720
>> Mul paistab 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Nii et 11 hashtags, kuigi
Ma selgelt panna 10 sees see silmus.

288
00:14:38,891 --> 00:14:42,140
Nüüd, mõned võite näha kohe
Mis viga on, sest tõesti, seda

289
00:14:42,140 --> 00:14:43,720
ei ole väga raske viga teha.

290
00:14:43,720 --> 00:14:46,070
Aga see on väga sageli
tehtud väga varakult.

291
00:14:46,070 --> 00:14:49,820
>> Mida ma tahan rõhutada, kuigi
on, kuidas võiks ma selgitada seda?

292
00:14:49,820 --> 00:14:52,300
Noh, selgub, et
CS50 raamatukogu tegemist

293
00:14:52,300 --> 00:14:55,380
mitte ainult get_string ja get_int
ja get_float ja muid funktsioone.

294
00:14:55,380 --> 00:14:59,980
Kaasas ka spetsiaalne funktsioon
nimetatakse eprintf või viga printf.

295
00:14:59,980 --> 00:15:03,270
Ja see on olemas ainult teha
see natuke lihtsamaks

296
00:15:03,270 --> 00:15:06,310
kui silumine oma koodi ainult
veateadet ekraanile

297
00:15:06,310 --> 00:15:07,850
ja tean, kust see tuli.

298
00:15:07,850 --> 00:15:11,000
>> Nii näiteks üks asi, mida ma võiks
teha siin see funktsioon on see--

299
00:15:11,000 --> 00:15:20,230
eprintf, ja siis ma lähen edasi minna
ja öelda, et ma praegu% i, backslash, n.

300
00:15:20,230 --> 00:15:22,330
Ja ma lähen pistik väärtus i.

301
00:15:22,330 --> 00:15:25,400
Ja kuni top, sest see
on CS50 raamatukogu,

302
00:15:25,400 --> 00:15:27,580
Ma lähen edasi minna
ning sisaldama

303
00:15:27,580 --> 00:15:29,169
nii et ma kasutada seda funktsiooni.

304
00:15:29,169 --> 00:15:31,460
Kuid olgem kaaluma, mida joon
9 peaks tegema.

305
00:15:31,460 --> 00:15:32,670
Ma lähen kustutada lõpuks.

306
00:15:32,670 --> 00:15:34,670
See on midagi pistmist
minu üldine eesmärk.

307
00:15:34,670 --> 00:15:39,090
Aga eprintf, viga printf, on lihtsalt mõeldud
mulle mõned diagnostilist informatsiooni.

308
00:15:39,090 --> 00:15:42,460
Kui ma saan oma programmi, ma tahan
vaata seda ekraanil ajutiselt

309
00:15:42,460 --> 00:15:44,550
ka lihtsalt mõista
mis toimub.

310
00:15:44,550 --> 00:15:47,330
>> Ja tõepoolest, iga
iteratsiooni siin rida 9

311
00:15:47,330 --> 00:15:49,260
Ma tahan näha, milline on väärtus i?

312
00:15:49,260 --> 00:15:50,290
Mis on väärtus i?

313
00:15:50,290 --> 00:15:51,280
Mis on väärtus i?

314
00:15:51,280 --> 00:15:55,650
Ja loodetavasti ma peaks ainult
näha, et sõnum, samuti 10 korda.

315
00:15:55,650 --> 00:15:57,780
>> Nii et lubage mul minna ja
kompileerida minu programmi

316
00:15:57,780 --> 00:15:59,905
kui ma pean seda tegema igal ajal
Ma teha muutusi. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
Ja now-- OK.

319
00:16:03,640 --> 00:16:04,820
Seal on palju rohkem toimub.

320
00:16:04,820 --> 00:16:07,610
Nii et lubage mul kerida üles
isegi suurem aken.

321
00:16:07,610 --> 00:16:10,190
>> Ja te näete, et iga
hashtags veel prinditakse.

322
00:16:10,190 --> 00:16:15,270
Aga vahel igaüks neist on nüüd see
diagnostilised väljund vormindatud järgmiselt.

323
00:16:15,270 --> 00:16:17,960
Nimiminu programm on siin buggy2.

324
00:16:17,960 --> 00:16:20,432
Nimi faili on buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Liini number, millelt
See oli trükitud on line 9.

326
00:16:24,080 --> 00:16:27,500
Ja siis paremal see on
veateate, et ma olen oodanud.

327
00:16:27,500 --> 00:16:30,701
>> Ja mis on tore on see, et
Nüüd ma ei pea tingimata lugema

328
00:16:30,701 --> 00:16:32,200
mu peas, mis mu programm teeb.

329
00:16:32,200 --> 00:16:34,240
Ma näen, et on
esimese iteratsiooni i on 0,

330
00:16:34,240 --> 00:16:39,420
siis 1, siis 2, siis 3, siis 4, siis
5, siis 6, siis 7, siis 8, siis 9, siis

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Nii oodake minut.

333
00:16:42,050 --> 00:16:43,740
Mis siin toimub?

334
00:16:43,740 --> 00:16:48,190
Ma ikka tundub, et lugedes
eesmärgipäraselt kuni 10.

335
00:16:48,190 --> 00:16:50,550
>> Aga kust alustada?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Nii 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11. sõrme

338
00:16:58,040 --> 00:16:59,990
näitab probleemi.

339
00:16:59,990 --> 00:17:02,850
Mulle tundub, et on loendatud
valesti minu loop.

340
00:17:02,850 --> 00:17:06,599
Selle asemel, et minna 10 iteratsioon
Ma olen hakanud 0,

341
00:17:06,599 --> 00:17:09,550
Ma lõpeb ja kuni 10.

342
00:17:09,550 --> 00:17:12,030
Aga kuna, nagu arvuti,
Ma olen hakanud lugedes 0,

343
00:17:12,030 --> 00:17:15,250
Oleksin lugedes üles
, kuid mitte läbi, 10.

344
00:17:15,250 --> 00:17:18,510
>> Ja nii fix, ma lõpuks
mõistis, siin on üks kahest.

345
00:17:18,510 --> 00:17:22,430
Ma võiks väga lihtsalt öelda,
loota kuni vähem kui 10.

346
00:17:22,430 --> 00:17:27,260
Nii 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, mis on tõepoolest õige,

347
00:17:27,260 --> 00:17:28,900
kuigi see kõlab natuke valesti.

348
00:17:28,900 --> 00:17:35,070
Või ma võiks teha väiksem või võrdne
kuni 9, nii kaua kui ma algavad 0.

349
00:17:35,070 --> 00:17:40,056
Või kui sa tõesti ei meeldi, et sa
võib loota kuni kuni 10, kuid algavad 1.

350
00:17:40,056 --> 00:17:41,680
Aga jälle, see lihtsalt ei ole nii levinud.

351
00:17:41,680 --> 00:17:43,977
In programming-- kuigi
mitte niivõrd Scratch--

352
00:17:43,977 --> 00:17:45,810
kuid programmeerimine
C ja teistes keeltes,

353
00:17:45,810 --> 00:17:47,670
nagu JavaScript ja
Python ja teised, et see on

354
00:17:47,670 --> 00:17:49,880
lihtsalt väga tavaline
Meie arutelu binaarsed

355
00:17:49,880 --> 00:17:53,450
lihtsalt lugemise alustamiseks juures
Kõige vähem saate, mis on 0.

356
00:17:53,450 --> 00:17:53,950
Hästi.

357
00:17:53,950 --> 00:17:55,160
Nii et eprintf.

358
00:17:55,160 --> 00:17:58,600
Ja jälle, et nüüd, ma olen aru saanud minu
probleem, ja ma lähen tagasi 0

359
00:17:58,600 --> 00:18:01,470
läbi vähem kui 10, ma lähen
minna ja kustutada eprintf.

360
00:18:01,470 --> 00:18:04,580
>> See ei tohiks olla seal, kui ma
laev minu kood või esitada oma koodi

361
00:18:04,580 --> 00:18:05,800
või näidata seda kellelegi teisele.

362
00:18:05,800 --> 00:18:07,980
Tegelikult on see vaid tähendas
ajutist kasutamist.

363
00:18:07,980 --> 00:18:11,650
Aga nüüd ma olen parandanud seda
Eriliseks probleemiks ka.

364
00:18:11,650 --> 00:18:16,780
>> Noh, teeme veel ühe näite siin
et ma lähen klopsima järgmiselt.

365
00:18:16,780 --> 00:18:22,850
Ma lähen edasi minna ja
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
Ja ma lähen edasi minna
ja #include.

367
00:18:25,580 --> 00:18:29,030
>> Ja ma lähen säästa
see pilt buggy3.c.

368
00:18:29,030 --> 00:18:31,740
Ja ma lähen edasi minna
ja kuulutada int main (void).

369
00:18:31,740 --> 00:18:34,186
Ja siis sees olemas
Ma teen int i _ -

370
00:18:34,186 --> 00:18:36,435
Ma tahan, et rakendada programmi
koos get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
See ei ole funktsioon, mis eksisteerib veel.

373
00:18:40,770 --> 00:18:42,870
Nii et me kavatseme rakendada
see hetk.

374
00:18:42,870 --> 00:18:45,541
Aga me näeme, miks
see lollakas esimesel läbima.

375
00:18:45,541 --> 00:18:47,290
Ja kui ma olen saanud
int kasutaja,

376
00:18:47,290 --> 00:18:53,365
Ma lihtsalt printida% i on negatiivne
täisarv, backslash, n, koma i.

377
00:18:53,365 --> 00:18:55,240
Teisisõnu, kõik I
tahan seda programmi teha

378
00:18:55,240 --> 00:18:58,000
on saada negatiivne int alates
kasutaja ja siis välja printida

379
00:18:58,000 --> 00:18:59,980
et selline ja selline on negatiivne int.

380
00:18:59,980 --> 00:19:02,080
>> Nüüd on mul vaja rakendada seda funktsiooni.

381
00:19:02,080 --> 00:19:05,740
Nii hiljem minu fail, ma lähen
edasi ja kuulutada funktsioon nimega

382
00:19:05,740 --> 00:19:10,670
get_negative_int (kehtetu) - ja me
tagasi tulla, milline see joon tähendab jälle

383
00:19:10,670 --> 00:19:18,790
a moment-- int n; do-- do
following-- printf n on :.

384
00:19:18,790 --> 00:19:26,210
Ja siis ma lähen tegema, n - get_int,
ja seda samal ajal n on suurem kui 0.

385
00:19:26,210 --> 00:19:28,310
Ja siis tagasi n ;.

386
00:19:28,310 --> 00:19:31,730
>> Nii on palju toimub
Selle kuid ükski neist me ei

387
00:19:31,730 --> 00:19:33,710
vaadata eelmisel nädalal, vähemalt korraks.

388
00:19:33,710 --> 00:19:36,980
Nii on line 10 siin ma olen kuulutanud
funktsiooni nimetatakse get_negative_int,

389
00:19:36,980 --> 00:19:39,620
ja ma panin (void), in
sulgudes, selle põhjuseks on see

390
00:19:39,620 --> 00:19:40,950
ei võta sisend.

391
00:19:40,950 --> 00:19:42,910
Ma ei paneks midagi
Selle funktsiooniga.

392
00:19:42,910 --> 00:19:44,690
Ma lihtsalt saada midagi tagasi saada.

393
00:19:44,690 --> 00:19:47,270
>> Ja mida ma loodan, et
tagasi saada on täisarv.

394
00:19:47,270 --> 00:19:50,040
Puuduvad andmed tüüpi
C nimetatakse negative_int.

395
00:19:50,040 --> 00:19:52,880
See on lihtsalt int, nii see läheb
olema meile veenduda

396
00:19:52,880 --> 00:19:55,340
väärtus, mis on tegelikult
Tagastatud on mitte ainult int

397
00:19:55,340 --> 00:19:56,380
kuid on ka negatiivne.

398
00:19:56,380 --> 00:20:02,150
>> On line 12 Ma kuulutab muutuja
nimetatakse n ja muudab tüüpi int.

399
00:20:02,150 --> 00:20:07,500
Ja siis vastavalt 13 kuni 18 Ma
midagi, kui midagi on tõsi.

400
00:20:07,500 --> 00:20:11,040
Ma lähen edasi ja trükkimine
n tähendab, käärsoole ja seejärel tühiku

401
00:20:11,040 --> 00:20:12,800
nagu kiire kasutaja.

402
00:20:12,800 --> 00:20:16,410
>> Ma siis helistades get_int ja
ladustamiseks oma nn tagastatav väärtus

403
00:20:16,410 --> 00:20:18,130
et muutuja n.

404
00:20:18,130 --> 00:20:22,600
Aga ma lähen hoida tehes
Selle ajal n on suurem kui 0.

405
00:20:22,600 --> 00:20:27,960
Teisisõnu, kui kasutaja annab mulle
int ja see arv on suurem kui 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positiivne, ma lähen
muudkui reprompting kasutaja,

407
00:20:31,180 --> 00:20:37,160
hoida reprompting, sundides neid
koostööd ning annab mulle negatiivset int.

408
00:20:37,160 --> 00:20:41,640
>> Ja kui n on tegelikult negative--
Oletame kasutaja lõpuks tüübid -50,

409
00:20:41,640 --> 00:20:46,710
siis see samas loop ei ole enam õige
sest -50 ei ole suurem kui 0.

410
00:20:46,710 --> 00:20:51,140
Nii et me murda välja, et
loop loogiliselt ja tagasi n.

411
00:20:51,140 --> 00:20:53,520
>> Aga seal on üks teine
asi, mida ma pean tegema.

412
00:20:53,520 --> 00:20:56,190
Ja ma ei saa lihtsalt teha
poolt kopeerimist ja kleepimist

413
00:20:56,190 --> 00:20:58,540
üks rida koodi ülaosas faili.

414
00:20:58,540 --> 00:21:01,630
Mul on vaja õpetada rõkkama,
või luban rõkkama,

415
00:21:01,630 --> 00:21:04,630
selgesõnaliselt, et ma,
Tõepoolest, mine ja rakendada

416
00:21:04,630 --> 00:21:06,020
Selle funktsiooni get_negative_int.

417
00:21:06,020 --> 00:21:07,674
See võib lihtsalt olla väiksem fail.

418
00:21:07,674 --> 00:21:09,840
Jällegi, meelde tuletada, et rõkkama
loeb asju ülevalt alla,

419
00:21:09,840 --> 00:21:12,330
vasakult paremale, nii et sa ei saa
nimetame funktsiooni, kui rõkkama

420
00:21:12,330 --> 00:21:15,330
ei tea, see läheb eksisteerida.

421
00:21:15,330 --> 00:21:18,430
>> Nüüd kahjuks see programm,
nagu mõned teist ehk märganud,

422
00:21:18,430 --> 00:21:19,590
on juba lollakas.

423
00:21:19,590 --> 00:21:21,400
Lubage mul minna ja teha buggy3.

424
00:21:21,400 --> 00:21:26,904
See koostab, nii et minu probleem ei ole praegu
syntaksivirhettä, nagu tekstiviga,

425
00:21:26,904 --> 00:21:29,570
see on tegelikult saab olema loogiline
viga, et ma olen teadlikult

426
00:21:29,570 --> 00:21:32,450
tehtud kui võimalust
sammult läbi, mis toimub.

427
00:21:32,450 --> 00:21:35,540
>> Ma lähen edasi minna
nüüd ja kestab buggy3.

428
00:21:35,540 --> 00:21:37,490
Ja ma lähen
edasi ja tee koostööd.

429
00:21:37,490 --> 00:21:39,494
Ma annan selle number 1.

430
00:21:39,494 --> 00:21:41,410
See ei meeldi, nii et
see sunnib mind jälle.

431
00:21:41,410 --> 00:21:42,147
>> Kuidas umbes 2?

432
00:21:42,147 --> 00:21:43,021
3p

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Ükski neist ei tööta.

435
00:21:44,740 --> 00:21:46,890
Kuidas -50?

436
00:21:46,890 --> 00:21:48,560
Ja tundub programmi tööd.

437
00:21:48,560 --> 00:21:49,970
>> Las ma proovin seda veel kord.

438
00:21:49,970 --> 00:21:53,400
Las ma proovin -1, tundub, et töö.

439
00:21:53,400 --> 00:21:56,380
Las ma proovin -2, tundub, et töö.

440
00:21:56,380 --> 00:21:59,640
Las ma proovin 0.

441
00:21:59,640 --> 00:22:01,684
Huh, see on vale.

442
00:22:01,684 --> 00:22:03,350
Nüüd me oleme seda natuke pedantne siin.

443
00:22:03,350 --> 00:22:07,090
Aga see on tõesti nii, et 0
on ei positiivset ega negatiivset.

444
00:22:07,090 --> 00:22:11,150
Ja nii, et minu programm on
öeldes, et 0 on negatiivne täisarv,

445
00:22:11,150 --> 00:22:12,820
see ei ole tehniliselt korrektne.

446
00:22:12,820 --> 00:22:15,180
>> Nüüd, miks seda teeme?

447
00:22:15,180 --> 00:22:16,270
Noh, see võib olla ilmne.

448
00:22:16,270 --> 00:22:18,110
Ja tõepoolest, et programm on
tule üsna lihtne

449
00:22:18,110 --> 00:22:19,670
nii et meil on midagi uurida.

450
00:22:19,670 --> 00:22:25,870
>> Kuid olgem tutvustada kolmanda silumine
tehnikat siin nimetatakse debug50.

451
00:22:25,870 --> 00:22:27,750
Nii et see on programm
et oleme lihtsalt loodud

452
00:22:27,750 --> 00:22:30,770
Sel aastal kutsus debug50
mis võimaldab teil

453
00:22:30,770 --> 00:22:34,130
kasutama, mida nimetatakse sisseehitatud
graafiline silur on CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
Ja siluri on ainult programm, mis
Üldiselt saab käivitada oma programmi

455
00:22:38,400 --> 00:22:44,050
aga samm-samm-sammult, liin
poolt rida-realt, pausid, poking

456
00:22:44,050 --> 00:22:47,626
ümber, vaadates muutujad nii, et
programm ei ole lihtsalt löök minevikus teid

457
00:22:47,626 --> 00:22:49,750
ja kiiresti printida midagi
või ei prindi midagi.

458
00:22:49,750 --> 00:22:53,250
See annab teile võimaluse juures
Inimese kiirusega, et suhelda ta.

459
00:22:53,250 --> 00:22:55,470
>> Ja seda teha, siis
lihtsalt teha järgmist.

460
00:22:55,470 --> 00:22:58,479
Pärast koostamist oma koodi,
mida ma juba teinud, buggy3,

461
00:22:58,479 --> 00:23:00,020
kui edasi minna ja joosta debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Nii palju nagu help50 on sul tekib
help50 ja seejärel käsku,

464
00:23:06,760 --> 00:23:10,120
debug50 on sul tekib debug50 ja
siis käsu nime.

465
00:23:10,120 --> 00:23:14,440
>> Nüüd vaata mis juhtub minu ekraanil,
paremal pool eriti.

466
00:23:14,440 --> 00:23:19,400
Kui ma tabanud Run kõik
järsku see parempoolne paneel

467
00:23:19,400 --> 00:23:20,419
avab ekraanil.

468
00:23:20,419 --> 00:23:22,210
Ja seal on palju läheb
kohta esimesel pilgul.

469
00:23:22,210 --> 00:23:25,110
Aga seal ei ole liiga
palju muretsema veel.

470
00:23:25,110 --> 00:23:28,570
>> See näitab mulle kõik
mis toimub sees minu programm

471
00:23:28,570 --> 00:23:31,130
kohe ja nende kaudu
nupud üles top on siis

472
00:23:31,130 --> 00:23:35,910
võimaldab mul sammult läbi minu kood
lõppkokkuvõttes samm samm-sammult.

473
00:23:35,910 --> 00:23:37,140
Aga mitte veel.

474
00:23:37,140 --> 00:23:38,060
Pange tähele, mis juhtub.

475
00:23:38,060 --> 00:23:40,600
Minu terminali aknas
Ma seda küsitakse n.

476
00:23:40,600 --> 00:23:44,560
Ja ma lähen edasi minna ja
koostööd seekord ja kirjuta -1.

477
00:23:44,560 --> 00:23:48,770
Ja kuigi veidi cryptically, -1
on negatiivne täisarv ootuspäraselt.

478
00:23:48,770 --> 00:23:52,020
>> Ja siis laps väljus koos
staatuse 0 GDBserver väljumisel.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU siluri, on nimi
aluseks olevate tarkvara

480
00:23:55,180 --> 00:23:56,620
mis rakendab seda siluri.

481
00:23:56,620 --> 00:24:00,500
Aga see kõik tõesti tähendab, siluri
läks ära, sest mu programmi loobuda

482
00:24:00,500 --> 00:24:01,710
ja kõik oli hästi.

483
00:24:01,710 --> 00:24:06,020
Kui ma tahan tõesti siluda oma programmi
Mul on ennetavalt öelda debug50,

484
00:24:06,020 --> 00:24:08,920
Kui ma tahan alustada
astutakse läbi minu kood?

485
00:24:08,920 --> 00:24:11,750
>> Ja võib-olla kõige lihtsam viis
seda teha on järgmine.

486
00:24:11,750 --> 00:24:15,300
Kui ma hover üle
vihmaveerennid minu toimetaja siin

487
00:24:15,300 --> 00:24:19,090
nii tõesti ainult vasaku siin
vasakul rea number,

488
00:24:19,090 --> 00:24:21,870
Pange tähele, et kui ma lihtsalt käsku
kord, panin veidi red dot.

489
00:24:21,870 --> 00:24:24,460
Ja see väike punane täpp,
nagu stop märk tähendab, hei,

490
00:24:24,460 --> 00:24:29,430
debug50, pausi täitmine minu kood
seal kui ma saan selle programmi.

491
00:24:29,430 --> 00:24:30,260
>> Nii teeme seda.

492
00:24:30,260 --> 00:24:37,340
Lubage mul minna ja käivitada oma programmi
jälle debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
Ja nüüd, teate, midagi
erinev on juhtunud.

494
00:24:40,110 --> 00:24:42,440
Ma ei luba küsima
veel minu terminali aknas

495
00:24:42,440 --> 00:24:45,430
midagi, sest ma ei ole
saanud seal veel minu programm.

496
00:24:45,430 --> 00:24:47,950
Pange tähele, et real 8
mis nüüd esile tõstetud,

497
00:24:47,950 --> 00:24:51,720
ja seal on vähe nool
Vasakul ütlus, siis on peatatud siin.

498
00:24:51,720 --> 00:24:55,030
See koodirida, liin
8, ei ole veel teostatud.

499
00:24:55,030 --> 00:24:58,940
>> Ja mis on uudishimulik, kui ma vaatan
siin paremal servas

500
00:24:58,940 --> 00:25:03,530
märgata, et i on kohalik
muutuja, kohalikud selles mõttes,

501
00:25:03,530 --> 00:25:05,450
et see sees praegune funktsioon.

502
00:25:05,450 --> 00:25:08,920
Ja selle väärtus ilmselt vaikimisi
ja omamoodi mugavalt on 0.

503
00:25:08,920 --> 00:25:10,260
Aga ma ei kirjuta 0.

504
00:25:10,260 --> 00:25:13,410
See lihtsalt juhtub olema oma
Vaikimisi väärtus hetkel.

505
00:25:13,410 --> 00:25:15,490
>> Nii et lubage mul minna ja teha seda nüüd.

506
00:25:15,490 --> 00:25:18,680
Lubage mul minna ja
paremal üleval siin, ma olen

507
00:25:18,680 --> 00:25:20,970
läheb minna ja
Klõpsake seda esimest ikoon, mis

508
00:25:20,970 --> 00:25:25,360
tähendab sammu üle, mis tähendab, ärge jätke
see aga samm üle selle koodirida,

509
00:25:25,360 --> 00:25:27,770
käivitamata mööda teed.

510
00:25:27,770 --> 00:25:30,710
>> Ja nüüd, märkate, minu
kiire on lihtsalt muutunud.

511
00:25:30,710 --> 00:25:31,380
Miks nii?

512
00:25:31,380 --> 00:25:33,639
Olen rääkinud debug50,
käivitada rida koodi.

513
00:25:33,639 --> 00:25:34,930
Mida see koodirida teha?

514
00:25:34,930 --> 00:25:35,960
Küsib minult int.

515
00:25:35,960 --> 00:25:36,460
OKEI.

516
00:25:36,460 --> 00:25:37,400
Lubage mul koostööd.

517
00:25:37,400 --> 00:25:41,340
Lubage mul minna nüüd ja kirjuta -1, Enter.

518
00:25:41,340 --> 00:25:42,920
Ja nüüd pane tähele, mis on muutunud.

519
00:25:42,920 --> 00:25:46,060
Paremal servas,
minu kohaliku muutuja i

520
00:25:46,060 --> 00:25:48,200
on osutatud kui -1 nüüd.

521
00:25:48,200 --> 00:25:49,810
Ja see on ikka tüüpi int.

522
00:25:49,810 --> 00:25:53,102
>> Ja teate ka, minu nn
pinu, kus ma pausi?

523
00:25:53,102 --> 00:25:54,810
Me räägime rohkem
seda tulevikus.

524
00:25:54,810 --> 00:25:58,620
Aga pinu lihtsalt viitab mida
funktsioonid on praegu liigub.

525
00:25:58,620 --> 00:26:00,040
Praegu on see lihtsalt peamine.

526
00:26:00,040 --> 00:26:03,590
Ja praegu ainus kohalik
muutuja on i, mille väärtus 1.

527
00:26:03,590 --> 00:26:09,840
>> Ja kui ma lõpuks samm üle selle joone
siin, selle sama ikooni ülaosas paremal,

528
00:26:09,840 --> 00:26:11,410
-1 On negatiivne täisarv.

529
00:26:11,410 --> 00:26:13,580
Nüüd on pausid üle, et lokkis traksidega.

530
00:26:13,580 --> 00:26:14,740
Laskem seda teha oma asja.

531
00:26:14,740 --> 00:26:17,300
Ma sammu üle, et joon, ja voila.

532
00:26:17,300 --> 00:26:20,240
>> Nii ei ole kõik nii kohutavalt
valgustav veel

533
00:26:20,240 --> 00:26:23,550
kuid see ei lase mul pausi
ja läbi mõelda loogiliselt

534
00:26:23,550 --> 00:26:24,870
mida see programm teeb.

535
00:26:24,870 --> 00:26:26,890
Aga see ei olnud ekslikud puhul.

536
00:26:26,890 --> 00:26:28,510
Teeme seda uuesti järgmiselt.

537
00:26:28,510 --> 00:26:31,340
>> Ma jätan selle murdepunkti
real 8 punase punktina.

538
00:26:31,340 --> 00:26:32,830
Ma lähen uuesti, debug50.

539
00:26:32,830 --> 00:26:34,400
See automaatselt peatatud siin.

540
00:26:34,400 --> 00:26:37,660
Kuid seekord asemel
üle astuda selles reas

541
00:26:37,660 --> 00:26:42,290
las ma tegelikult minna sees
get_negative_int ja nuputada,

542
00:26:42,290 --> 00:26:45,530
miks see vastu 0 kehtiv vastus?

543
00:26:45,530 --> 00:26:47,990
>> Nii et selle asemel klikkides samm üle.

544
00:26:47,990 --> 00:26:50,630
Ma lähen edasi minna
ja klõpsake samm.

545
00:26:50,630 --> 00:26:54,030
Ja märgata, et rida 8, mis on
nüüd rõhutatud nüüd äkki

546
00:26:54,030 --> 00:26:56,900
muutub liin 17.

547
00:26:56,900 --> 00:26:59,947
>> Nüüd, see ei ole nii siluri
on vahele read 14 ja 15 ja 16.

548
00:26:59,947 --> 00:27:01,780
See on lihtsalt miski
näidata seal.

549
00:27:01,780 --> 00:27:04,050
Need on lihtsalt kuulutatakse muutujad,
Ja siis on sõna Kas

550
00:27:04,050 --> 00:27:05,390
ja siis avatud lokkis traksidega.

551
00:27:05,390 --> 00:27:09,227
Ainus funktsionaalne joon, mis on
mahlane tõesti on see üks siin, 17.

552
00:27:09,227 --> 00:27:11,060
Ja see, kui me oleme
peatatud automaatselt.

553
00:27:11,060 --> 00:27:13,870
>> Nii printf ( "n.is:") ;, nii
mis pole veel juhtunud.

554
00:27:13,870 --> 00:27:18,250
Nii lähme edasi ja klõpsake samm üle.

555
00:27:18,250 --> 00:27:20,326
Nüüd on mu kiire, tõepoolest,
muudeti ( "n on:").

556
00:27:20,326 --> 00:27:22,450
Nüüd get_int, ma ei kavatse
vaeva astumist,

557
00:27:22,450 --> 00:27:24,750
sest see funktsioon oli
tehtud CS50 Raamatukogu.

558
00:27:24,750 --> 00:27:25,750
See on arvatavasti õige.

559
00:27:25,750 --> 00:27:28,440
>> Nii et ma lähen edasi minna ja
omamoodi koostööd, andes talle

560
00:27:28,440 --> 00:27:30,590
int, kuid ei ole negatiivne int.

561
00:27:30,590 --> 00:27:32,870
Nii et lubage mul minna ja tabas 0.

562
00:27:32,870 --> 00:27:39,460
Ja nüüd, mis juhtub siin
kui ma pikali joon 21?

563
00:27:39,460 --> 00:27:40,890
Ma ei ole itereerida uuesti.

564
00:27:40,890 --> 00:27:43,320
Ma ei tundu olevat ummikus, et silmus.

565
00:27:43,320 --> 00:27:45,990
Teisisõnu, see kollane
baar ei käiks ringi,

566
00:27:45,990 --> 00:27:47,130
ja ümber ja ümber.

567
00:27:47,130 --> 00:27:48,340
>> Nüüd, miks see nii on?

568
00:27:48,340 --> 00:27:49,920
Noh, n, mida on N kohe?

569
00:27:49,920 --> 00:27:53,280
Ma ei vaadata kohaliku
muutujate siluri.

570
00:27:53,280 --> 00:27:53,816
n on 0.

571
00:27:53,816 --> 00:27:55,190
Olgu, mis oli minu tingimus?

572
00:27:55,190 --> 00:27:58,700
>> 20-- line 20 on hästi,
0 on suurem kui 0.

573
00:27:58,700 --> 00:27:59,500
See pole tõsi.

574
00:27:59,500 --> 00:28:01,020
0 ei ole suurem kui 0.

575
00:28:01,020 --> 00:28:02,820
Ja nii ma puhkes selle.

576
00:28:02,820 --> 00:28:06,370
>> Ja nii see on, miks on line
21, kui ma tegelikult jätkata,

577
00:28:06,370 --> 00:28:10,370
Ma lähen tagasi 0, isegi
kuigi ma oleks pidanud tagasi 0

578
00:28:10,370 --> 00:28:12,484
kui tegelikult ei ole negatiivne.

579
00:28:12,484 --> 00:28:14,650
Nüüd, ma tõesti ei isegi
hoolivad siluri.

580
00:28:14,650 --> 00:28:16,900
Sai siis ma ei pea
tean, mida rohkem toimub.

581
00:28:16,900 --> 00:28:19,233
>> Nii et ma lähen edasi minna ja
lihtsalt nuppu Esita,

582
00:28:19,233 --> 00:28:20,240
ja las see viimistlus üles.

583
00:28:20,240 --> 00:28:23,440
Nüüd ma olen aru saanud, et minu
viga ilmselt on line 20.

584
00:28:23,440 --> 00:28:25,160
See on minu loogikaviga.

585
00:28:25,160 --> 00:28:28,100
>> Ja mis ma tahan
teha, et seda muuta?

586
00:28:28,100 --> 00:28:32,500
Kui probleem on selles, et ma ei ole
püüdmine 0, see on lihtsalt loogiline viga.

587
00:28:32,500 --> 00:28:35,910
Ja ma ei saa öelda, kui n on
suurem või võrdne 0,

588
00:28:35,910 --> 00:28:38,330
hoida ajendades kasutajal uuesti ja uuesti.

589
00:28:38,330 --> 00:28:41,050
>> Niisiis, jälle, lihtne viga, võib-olla
isegi ilmne, kui nägid mind

590
00:28:41,050 --> 00:28:42,410
kirjutada vaid paar minutit tagasi.

591
00:28:42,410 --> 00:28:44,570
Aga Buffee siin
on see, et silumis 50,

592
00:28:44,570 --> 00:28:46,850
ja silumine
tarkvara üldisemalt

593
00:28:46,850 --> 00:28:51,370
sul on see uus leitud võim
kõndida läbi oma kood, vaatame

594
00:28:51,370 --> 00:28:55,590
kaudu, et parempoolne paneel, mida
oma muutujate väärtused on.

595
00:28:55,590 --> 00:28:57,700
Nii et sa ei pea tingimata
pead kasutama midagi

596
00:28:57,700 --> 00:29:00,630
nagu sa eprintf printida neid väärtusi.

597
00:29:00,630 --> 00:29:04,430
Võite tegelikult neid näha
visuaalselt ekraanil.

598
00:29:04,430 --> 00:29:08,920
>> Nüüd, pärast seda, tasub märkimist
et seal on teine ​​meetod, mis on

599
00:29:08,920 --> 00:29:09,890
tegelikult super ühist.

600
00:29:09,890 --> 00:29:13,120
Ja siis võiks küsida, miks see väike
poiss siin on istunud laval.

601
00:29:13,120 --> 00:29:16,490
Nii et seda tehnikat, üldiselt
tuntakse kummist part silumine,

602
00:29:16,490 --> 00:29:18,786
mis on tegelikult lihtsalt
märk sellest,

603
00:29:18,786 --> 00:29:20,660
et sageli, kui programmeerijad
kirjutate koodi

604
00:29:20,660 --> 00:29:22,650
nad ei ole tingimata
koostööd teiste

605
00:29:22,650 --> 00:29:24,030
või töötavad jagatud keskkonnas.

606
00:29:24,030 --> 00:29:25,050
>> Nad justkui kodus.

607
00:29:25,050 --> 00:29:25,910
Võibolla on see hilja õhtul.

608
00:29:25,910 --> 00:29:28,190
Nad püüavad näitaja
mõned bug oma koodi.

609
00:29:28,190 --> 00:29:29,330
Ja nad lihtsalt ei näe seda.

610
00:29:29,330 --> 00:29:30,329
>> Ja pole mingit toakaaslane.

611
00:29:30,329 --> 00:29:31,250
Ei ole TF.

612
00:29:31,250 --> 00:29:32,680
Ei ole CA ümber.

613
00:29:32,680 --> 00:29:36,440
Kõik nad on oma riiul
on see väike kummist Tore.

614
00:29:36,440 --> 00:29:39,030
>> Ja nii kummist part silumine
just seda kutset

615
00:29:39,030 --> 00:29:42,780
mõelda midagi nii rumal
sest see on reaalne olend,

616
00:29:42,780 --> 00:29:46,940
ja tegelikult kõndida läbi oma koodi
verbaalselt sellele elutu objekt.

617
00:29:46,940 --> 00:29:49,230
Nii näiteks, kui
see on minu näide siin--

618
00:29:49,230 --> 00:29:52,470
ja meelde tuletada, et varem
probleem oli see,

619
00:29:52,470 --> 00:29:58,140
kui ma kustutan selle esimene rida koodi,
ja ma minna ja teha lollakas 0 uuesti

620
00:29:58,140 --> 00:30:01,220
Tuletame meelde, et mul oli neist
veateateid siin.

621
00:30:01,220 --> 00:30:05,997
Nii et idee siin, naeruväärne kuigi ma
tunnen hetkel teeme seda avalikult,

622
00:30:05,997 --> 00:30:06,580
on see viga.

623
00:30:06,580 --> 00:30:10,910
>> OK, nii et minu probleem on see, et ma olen
vaikimisi, raamatukogu funktsiooni.

624
00:30:10,910 --> 00:30:12,610
Ja et raamatukogu ülesanne on printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, kuulutada
meenutab mulle prototüübid.

626
00:30:15,290 --> 00:30:18,930
>> See tähendab, et ma pean tegelikult
öelda koostaja ette, milline

627
00:30:18,930 --> 00:30:19,980
funktsioon välja näeb.

628
00:30:19,980 --> 00:30:20,930
Oota hetk.

629
00:30:20,930 --> 00:30:23,580
Mul ei olnud standard io.h.

630
00:30:23,580 --> 00:30:24,530
Tänan teid väga.

631
00:30:24,530 --> 00:30:27,330
>> Nii lihtsalt see protsess of-- sa
ei pea tegelikult on part.

632
00:30:27,330 --> 00:30:29,819
Aga see idee kõndimine
ise läbi oma koodi

633
00:30:29,819 --> 00:30:31,610
nii et sa isegi kuulda
ise, et sa

634
00:30:31,610 --> 00:30:35,620
mõistma tegevusetuse oma
märkused, on üldiselt idee.

635
00:30:35,620 --> 00:30:38,910
>> Ja võib-olla loogiliselt, mitte nii
palju, et üks, vaid rohkem kaasatud

636
00:30:38,910 --> 00:30:44,220
Näiteks me lihtsalt tegime lollakas 3.c,
võite käia ise läbi

637
00:30:44,220 --> 00:30:45,310
järgnevalt.

638
00:30:45,310 --> 00:30:49,190
Nii et kõik õige, kummi
Tore, DDB, kui soovite.

639
00:30:49,190 --> 00:30:52,350
Siin on meil minu põhifunktsiooni
Helistan saada negatiivse int.

640
00:30:52,350 --> 00:30:54,660
>> Ja ma saan tagastatav väärtus.

641
00:30:54,660 --> 00:31:00,410
Ma hoiustamisel vasakul servas
real 8 muutuv nimetatakse i.

642
00:31:00,410 --> 00:31:02,380
OK, aga ära, kuidas
et saada, et väärtus?

643
00:31:02,380 --> 00:31:04,130
Lubage mul vaadata funktsiooni line 12.

644
00:31:04,130 --> 00:31:05,760
>> Vastavalt 12, meil saada negatiivse int.

645
00:31:05,760 --> 00:31:08,190
Ei võta mingeid sisendeid,
ei tagastab int, OK.

646
00:31:08,190 --> 00:31:10,929
Kinnitan line 14 muutuv n.

647
00:31:10,929 --> 00:31:12,220
See saab salvestada täisarv.

648
00:31:12,220 --> 00:31:13,760
See, mida ma tahan.

649
00:31:13,760 --> 00:31:18,480
>> Nii et järgmine samas n las
mulle tagasi võtta, mida fix ma juba teinud.

650
00:31:18,480 --> 00:31:22,710
Niisiis, kui n on suurem kui
0, trükkida n on, OK.

651
00:31:22,710 --> 00:31:25,170
Ja siis helistada saan int salvestatud n.

652
00:31:25,170 --> 00:31:30,160
Ja siis vaadata, kas n on 0,
n on not-- siin see on.

653
00:31:30,160 --> 00:31:31,910
Nii, nüüd, siis ei
vaja tegelikku part.

654
00:31:31,910 --> 00:31:35,650
Aga lihtsalt kõndides ise läbi
koodi intellektuaalse kasutamise

655
00:31:35,650 --> 00:31:37,720
Sageli aitab
aru, mis toimub,

656
00:31:37,720 --> 00:31:41,170
mitte lihtsalt midagi
niimoodi, jõllis ekraani

657
00:31:41,170 --> 00:31:43,720
ja ei räägi ise läbi
see, mis ausalt ei ole

658
00:31:43,720 --> 00:31:46,270
peaaegu sama tõhus meetod.

659
00:31:46,270 --> 00:31:48,620
Nii et teil on see, et
mitmeid erinevaid meetodeid

660
00:31:48,620 --> 00:31:52,102
jaoks tegelikult koodi silumine
ja laites, mis kõik

661
00:31:52,102 --> 00:31:54,810
peaks olema vahendeid oma toolkit
nii, et sa ei ole hilja õhtul,

662
00:31:54,810 --> 00:31:57,660
Eriti, oled söögituba
saali, või tööaega,

663
00:31:57,660 --> 00:32:00,368
peksma oma pead vastu
seina, püüab lahendada mingi probleem.

664
00:32:00,368 --> 00:32:02,020
Mõista, et on tarkvarasse.

665
00:32:02,020 --> 00:32:03,720
Seal on kummist part tööriistu.

666
00:32:03,720 --> 00:32:09,630
Ja seal on terve töötajad
toetada ootab appi.

667
00:32:09,630 --> 00:32:13,120
>> Nüüd, sõna probleemist
komplekti, ja sellest, mida me loodame teile

668
00:32:13,120 --> 00:32:15,620
välja saada neid ja kuidas
meil minna hindamiseks.

669
00:32:15,620 --> 00:32:17,680
Per kursuse ainekava,
CS50 probleem komplekti

670
00:32:17,680 --> 00:32:22,320
hinnatakse nelja peamist telge, nii
kuni speak-- ulatus, korrektsust, disain,

671
00:32:22,320 --> 00:32:23,060
ja stiili.

672
00:32:23,060 --> 00:32:25,910
Ja ulatus vaid viitab sellele, kui palju
tükk olete hammustanud?

673
00:32:25,910 --> 00:32:28,080
Kuidas suur probleem on olete proovinud?

674
00:32:28,080 --> 00:32:30,110
Mis tehtud jõupingutusi
olete väljendub?

675
00:32:30,110 --> 00:32:35,750
>> Korrektsus on, kas programmi töö
see peaks ühe CS50 spetsifikatsioon

676
00:32:35,750 --> 00:32:38,640
kui pakute teatud sisendite
või teatud väljundeid tulevad tagasi?

677
00:32:38,640 --> 00:32:41,130
Design on kõige subjektiivne neist.

678
00:32:41,130 --> 00:32:43,360
Ja see on üks, mis
võtab kauem õppida

679
00:32:43,360 --> 00:32:47,220
ja pikim õpetamast
niivõrd, kuivõrd see taandub,

680
00:32:47,220 --> 00:32:49,530
kui hästi kirjutatud on oma kood?

681
00:32:49,530 --> 00:32:52,920
>> See on üks asi, mida lihtsalt printida õige
väljundid või naasta õigeid väärtusi.

682
00:32:52,920 --> 00:32:55,400
Aga sa teed seda
efektiivselt kui võimalik?

683
00:32:55,400 --> 00:32:58,210
Kas sa teed seda lõhet
ja vallutada või binaarsed

684
00:32:58,210 --> 00:33:01,500
Otsing kui me kohe näha, et me tegime
kaks nädalat tagasi koos telefoniraamatu?

685
00:33:01,500 --> 00:33:04,670
Kas on paremaid viise lahendada
Probleem kui teil on praegu siin?

686
00:33:04,670 --> 00:33:06,380
See on võimalus parem disain.

687
00:33:06,380 --> 00:33:08,530
>> Ja siis style-- kuidas
päris on oma kood?

688
00:33:08,530 --> 00:33:12,370
Märkad, et ma olen päris
Eelkõige umbes taandamine minu kood,

689
00:33:12,370 --> 00:33:15,300
ja hoolitsedes minu muutujad
on mõistliku nimega. n,

690
00:33:15,300 --> 00:33:19,660
samas lühike, on hea nimi jaoks
number, i lugedes täisarv,

691
00:33:19,660 --> 00:33:20,727
s string.

692
00:33:20,727 --> 00:33:22,560
Ja meil on enam
muutujanimed stiilis.

693
00:33:22,560 --> 00:33:25,500
Stiil on, kuidas hea
ei oma koodi vaatama?

694
00:33:25,500 --> 00:33:26,600
Ja kuidas loetav on?

695
00:33:26,600 --> 00:33:29,650
>> Ja aja jooksul, mida oma ajutise töötaja
ja TF teeme käigus

696
00:33:29,650 --> 00:33:31,870
on anda teile, et
liiki kvalitatiivne tagasiside

697
00:33:31,870 --> 00:33:34,330
nii et saad paremini
neile erinevaid aspekte.

698
00:33:34,330 --> 00:33:37,510
Ja nii, kuidas me
hinnata iga telge,

699
00:33:37,510 --> 00:33:40,080
see on tavaliselt väga vähe
ämbrid, nii et sa üldiselt

700
00:33:40,080 --> 00:33:41,680
saada tunnet, kui hästi sa teed.

701
00:33:41,680 --> 00:33:45,680
Ja tõesti, kui teile skoor
kõik need axes-- õigsust, disain

702
00:33:45,680 --> 00:33:49,659
ja stiili especially-- et number
on üldiselt vahemikus 1 kuni 5.

703
00:33:49,659 --> 00:33:52,450
Ja sõna otseses mõttes, kui sa käid
3 on alguses semestri

704
00:33:52,450 --> 00:33:53,977
see on väga hea.

705
00:33:53,977 --> 00:33:55,810
See tähendab, seal on veel
arenemisruumi,

706
00:33:55,810 --> 00:33:58,490
mis siis oleks lootust ka
võttes klassi esimest korda.

707
00:33:58,490 --> 00:34:01,820
Seal on loodetavasti mõned natuke lakke
millele sa soovivad jõuda.

708
00:34:01,820 --> 00:34:03,970
Ja nii saan 3 üritused
esimesel tükki,

709
00:34:03,970 --> 00:34:06,550
Kui ei ole mõned 2-ja 4-ndatel,
on tõesti hea.

710
00:34:06,550 --> 00:34:08,880
See on hästi levialas,
ka sees ootustele.

711
00:34:08,880 --> 00:34:11,421
>> Ja kui teie arvates on võidusõit, oodake
minut, kolm viiest.

712
00:34:11,421 --> 00:34:12,620
See on tõesti 6 10st.

713
00:34:12,620 --> 00:34:13,560
See on 60%.

714
00:34:13,560 --> 00:34:14,830
Mu jumal, see on F.

715
00:34:14,830 --> 00:34:15,870
>> See ei ole.

716
00:34:15,870 --> 00:34:17,600
See ei ole tegelikult nii.

717
00:34:17,600 --> 00:34:22,710
Pigem on see võimalus parandada
jooksul semestri.

718
00:34:22,710 --> 00:34:25,580
Ja kui te saate mõned
Poors, need annavad võimaluse

719
00:34:25,580 --> 00:34:29,199
ära tööaega
kindlasti lõigud ja muud vahendid.

720
00:34:29,199 --> 00:34:32,840
>> Parim on võimalus, tõesti,
mille üle uhke olla, kui kaugele olete

721
00:34:32,840 --> 00:34:34,520
tulevad jooksul semestri.

722
00:34:34,520 --> 00:34:38,199
Nii saan aru, kui midagi
teine, kolm on hea.

723
00:34:38,199 --> 00:34:40,179
Ja see võimaldab kasvuruumi aja jooksul.

724
00:34:40,179 --> 00:34:43,090
>> Kuidas need teljed on
kaalutud, reaalselt sa oled

725
00:34:43,090 --> 00:34:46,745
veedab enamiku oma aega saada
asju teha, rääkimata õigesti.

726
00:34:46,745 --> 00:34:49,120
Ja nii õigsuse kipub
kaalutakse kõige Nagu

727
00:34:49,120 --> 00:34:51,360
See multiplikatiivseid kolmega.

728
00:34:51,360 --> 00:34:54,659
Disain on ka oluline, kuid
midagi, mida sa ei pruugi

729
00:34:54,659 --> 00:34:58,220
veedavad kõik need tunni kohta
üritavad asjad lihtsalt töötada.

730
00:34:58,220 --> 00:35:00,019
>> Ja nii see kaalutud
veidi kergelt.

731
00:35:00,019 --> 00:35:01,560
Ja siis stiil on kaalutud vähemalt.

732
00:35:01,560 --> 00:35:03,710
Kuigi see ei ole vähem
oluline põhjalikult,

733
00:35:03,710 --> 00:35:05,990
see on lihtsalt võib-olla
kõige lihtsam asi, mida teha õige,

734
00:35:05,990 --> 00:35:08,440
imiteerib näidetes me
teha loengu ja paragrahvi

735
00:35:08,440 --> 00:35:11,080
asjad kenasti
liigestatud ja kommenteeris

736
00:35:11,080 --> 00:35:14,320
ja nii edasi on üks kõige lihtsam
asju teha ja saada õigus.

737
00:35:14,320 --> 00:35:16,960
Nii sellisena realiseerida
et need on punktid

738
00:35:16,960 --> 00:35:19,000
mis on suhteliselt lihtne haarata.

739
00:35:19,000 --> 00:35:22,360
>> Ja nüüd sõna
see-- akadeemilise aususe.

740
00:35:22,360 --> 00:35:25,150
Nii ühe kursuse
ainekava, näed

741
00:35:25,150 --> 00:35:27,630
et loomulikult on üsna
natuke keelt selle ümber.

742
00:35:27,630 --> 00:35:31,380
Ja muidugi suhtub
akadeemilise aususe üsna tõsiselt.

743
00:35:31,380 --> 00:35:33,450
>> Meil on vahet,
paremaks või halvemaks,

744
00:35:33,450 --> 00:35:36,570
saatnud igal aastal rohkem
õpilased distsiplinaarvastutuse

745
00:35:36,570 --> 00:35:39,670
kui enamik muid
Muidugi, et olen teadlik.

746
00:35:39,670 --> 00:35:42,580
See ei pruugi
viitab asjaolule,

747
00:35:42,580 --> 00:35:46,340
et CS õpilased või CS50 õpilased on
vähem aus kui oma klassikaaslastega.

748
00:35:46,340 --> 00:35:49,090
Aga tegelikult, et see
maailma elektrooniliselt, me lihtsalt

749
00:35:49,090 --> 00:35:50,990
on tehnoloogia
tuvastamise vahend selle.

750
00:35:50,990 --> 00:35:53,360
>> Oluline on meile
õigluse üle klassi

751
00:35:53,360 --> 00:35:58,550
et me avastada seda ning tõsta
küsimus, kui me näeme asju.

752
00:35:58,550 --> 00:36:01,980
Ja just maalida, ja tõesti
aidata midagi sellist valamu,

753
00:36:01,980 --> 00:36:04,600
need on numbrid
õpilased on viimase 10 aasta jooksul

754
00:36:04,600 --> 00:36:07,610
mis on seotud mõne
selliseid küsimusi akadeemilise aususe,

755
00:36:07,610 --> 00:36:10,990
koos umbes 32 õpilast
sügisest 2015, mis

756
00:36:10,990 --> 00:36:13,760
See tähendab, et me ei võta
asja väga tõsiselt.

757
00:36:13,760 --> 00:36:18,380
Ja lõpuks, need numbrid kirjutada,
viimasena umbes 3%, 4% või nii

758
00:36:18,380 --> 00:36:19,120
klassi.

759
00:36:19,120 --> 00:36:25,220
>> Nii et super enamik õpilasi
tundub, et read on selge.

760
00:36:25,220 --> 00:36:27,940
Aga ärge pidage seda
pahanda, eriti hilja

761
00:36:27,940 --> 00:36:32,080
öösel, kui hädas
mingi lahenduse probleemile komplekti,

762
00:36:32,080 --> 00:36:34,830
et on olemas mehhanismid
saada ise paremaks

763
00:36:34,830 --> 00:36:37,870
toetust, kui võiks
arvan, isegi tol tunnis.

764
00:36:37,870 --> 00:36:40,514
Aru, et kui me saame
õpilane kaotanud, me rist

765
00:36:40,514 --> 00:36:43,430
võrrelda iga esitamist käesoleva aasta
vastu iga esitamiseks eelmisel aastal

766
00:36:43,430 --> 00:36:47,590
igaühe vastu esitada alates 2007. aastast
ja kuna vaadates, samuti,

767
00:36:47,590 --> 00:36:49,931
kood andmehoidlatest online,
foorumeid, töö saitidele.

768
00:36:49,931 --> 00:36:51,806
Ja räägitakse sellest,
tõesti, kõik huvides

769
00:36:51,806 --> 00:36:56,040
täielikku avalikustamist, et kui
keegi ei leia seda võrgus,

770
00:36:56,040 --> 00:36:57,880
Kindlasti, nii me saame muidugi.

771
00:36:57,880 --> 00:37:00,100
Aga tõesti, vaimu
Kursuse taandub

772
00:37:00,100 --> 00:37:01,650
Käesoleva punkti ainekava.

773
00:37:01,650 --> 00:37:03,670
See on tõesti õige, mõistlik.

774
00:37:03,670 --> 00:37:06,680
>> Ja kui meil oleks täpsustada, et
vaid veidi keeles

775
00:37:06,680 --> 00:37:09,770
aru, et sisuliselt kõik
tööd, mida esitada selle käigus

776
00:37:09,770 --> 00:37:10,954
peab olema oma.

777
00:37:10,954 --> 00:37:13,870
Aga selles on kindlasti
võimalusi ja julgustust,

778
00:37:13,870 --> 00:37:17,300
ja pedagoogilist väärtust pöördunud
others-- mina, TFS, kuid CAS

779
00:37:17,300 --> 00:37:20,760
TAS, ja teised klassis,
toetust, rääkimata sõbrad

780
00:37:20,760 --> 00:37:23,547
ja toakaaslased, kes on õppinud
CS ja programmeerimine enne.

781
00:37:23,547 --> 00:37:25,130
Ja nii on saastekvoodi eest.

782
00:37:25,130 --> 00:37:28,180
Ja üldine rusikareegel
on see-- küsides abi,

783
00:37:28,180 --> 00:37:31,470
võite näidata oma koodi teistele,
aga sa ei pruugi näha päralt.

784
00:37:31,470 --> 00:37:34,880
Nii et isegi kui sa oled tööaega
või D saal, või kusagil mujal

785
00:37:34,880 --> 00:37:37,450
töötavad mõned osaline komplekt,
töö kõrval sõber, mis

786
00:37:37,450 --> 00:37:40,160
on täiesti trahvi, kell
Päeva lõpuks oma töö

787
00:37:40,160 --> 00:37:43,034
peaks lõppkokkuvõttes kuuluvad iga
teist võrra ning mitte

788
00:37:43,034 --> 00:37:45,700
mõned ühiseid jõupingutusi,
välja arvatud lõplik projekt, kus

789
00:37:45,700 --> 00:37:47,410
see on lubatud ja soovitatav.

790
00:37:47,410 --> 00:37:49,830
>> Mõista, et kui te olete
hädas midagi

791
00:37:49,830 --> 00:37:52,520
ja su sõber lihtsalt juhtub
olema parem selles siis,

792
00:37:52,520 --> 00:37:55,130
või parem, et probleem kui sa,
või veidi kaugemal ees kui sina,

793
00:37:55,130 --> 00:37:57,330
see on täiesti mõistlik pöörduda
Teie sõber ja öelda, hei,

794
00:37:57,330 --> 00:38:00,480
Ega sa ei pahanda vaatasin koodi siin,
aitab mul märgata, mis mu probleem on?

795
00:38:00,480 --> 00:38:03,760
Ja loodetavasti ka
huvi pedagoogiline väärtus

796
00:38:03,760 --> 00:38:07,040
et sõber ei ole lihtsalt
öelda, oh, seda teha, vaid pigem

797
00:38:07,040 --> 00:38:09,917
mida sa kadunud real
6, või midagi sellist?

798
00:38:09,917 --> 00:38:12,000
Aga lahendus ei ole
Sõber sinu kõrval

799
00:38:12,000 --> 00:38:15,617
öelda, oh, noh, siin, las ma tõmban
see üles ja näitab minu lahendus sulle.

800
00:38:15,617 --> 00:38:16,450
Nii et on rida.

801
00:38:16,450 --> 00:38:18,670
Sa näitad oma koodi
teised, kuid te ei tohi

802
00:38:18,670 --> 00:38:22,350
Vaata ise, et teised
piirangute kursuse ainekava.

803
00:38:22,350 --> 00:38:24,760
>> Nii et ärge pidage meeles, see
Niinimetatud kahetsust punkti

804
00:38:24,760 --> 00:38:27,560
käigus on ainekava samuti,
et kui sa endale mingi teo, mis

805
00:38:27,560 --> 00:38:30,476
ei ole mõistlik, kuid too see
tähelepanu käigus peadesse

806
00:38:30,476 --> 00:38:34,240
72 tunni jooksul, loomulikult
võib kehtestada kohaliku sanktsioonid, et

807
00:38:34,240 --> 00:38:37,380
võib sisaldada vasta nõuetele või
vastasel hinne esitatud tööd.

808
00:38:37,380 --> 00:38:41,410
Aga muidugi ei suunata
asja veelgi distsiplinaarkaristuse,

809
00:38:41,410 --> 00:38:43,010
välja arvatud juhul, korduvate tegude eest.

810
00:38:43,010 --> 00:38:46,632
Teisisõnu, kui sa teha mõned
loll, eriti hilja õhtul otsus

811
00:38:46,632 --> 00:38:49,340
et järgmisel hommikul või kaks päeva
Hiljem, kui ärkama ja mõistma,

812
00:38:49,340 --> 00:38:50,870
Mida ma mõtlesin?

813
00:38:50,870 --> 00:38:53,890
Sa teha CS50 on väljund
fikseerimiseks, et probleem

814
00:38:53,890 --> 00:38:57,170
ja omavad kuni see, et me
kohtub teil pooleldi ja tegeleda

815
00:38:57,170 --> 00:39:01,500
kus see küsimus, mis on nii
haridus- ja väärtuslik teile,

816
00:39:01,500 --> 00:39:04,200
aga ikkagi karistusliku mingil moel.

817
00:39:04,200 --> 00:39:08,590
Ja nüüd, et nüristama see.

818
00:39:08,590 --> 00:39:10,570
>> [VIDEO PLAYBACK]

819
00:39:10,570 --> 00:39:13,540
>> [MUSIC MÄNGIB]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [END PLAYBACK]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Humala: Olgu, me oleme tagasi.

823
00:40:00,490 --> 00:40:03,680
Ja nüüd vaatame ühte
Esimene meie reaalses maailmas domeenid

824
00:40:03,680 --> 00:40:08,720
aastal CS50, kunst krüptograafia
kunst saatmine ja vastuvõtmine

825
00:40:08,720 --> 00:40:11,840
saladus sõnumeid krüpteeritud
lugemiseks, kui soovite,

826
00:40:11,840 --> 00:40:17,060
mis saab dešifreerida ainult siis, kui teil on
mõned võtmetähtsusega, et saatja on

827
00:40:17,060 --> 00:40:18,030
samuti.

828
00:40:18,030 --> 00:40:22,120
Nii et motiveerida seda me võtame
pilk see asi siin,

829
00:40:22,120 --> 00:40:26,750
mis on näide
saladus dekooder ring, mis

830
00:40:26,750 --> 00:40:34,042
saab kasutada selleks, et aru saada,
Mis saladus sõnum tegelikult on.

831
00:40:34,042 --> 00:40:35,750
Tegelikult tagasi
päev algkool,

832
00:40:35,750 --> 00:40:38,787
kui sa kunagi saatis salajase sõnumeid
mõned sõber või mõne purustada klassis,

833
00:40:38,787 --> 00:40:40,620
Te olete mõelnud
sa oleks tark

834
00:40:40,620 --> 00:40:46,530
poolt oma paberile muutmine,
jms, A punkti B ja B C ja C-D,

835
00:40:46,530 --> 00:40:47,590
ja nii edasi.

836
00:40:47,590 --> 00:40:50,300
Aga sa tegelikult krüptimine
Teie andmeid isegi

837
00:40:50,300 --> 00:40:53,300
kui see oli veidi triviaalne, ei olnud
et hard õpetaja mõistma,

838
00:40:53,300 --> 00:40:55,675
Noh, kui sa lihtsalt muuta
B A ja C B,

839
00:40:55,675 --> 00:40:57,550
sa tegelikult aru saada
Mis sõnum oli,

840
00:40:57,550 --> 00:40:59,700
aga sa olid šifreerimine teavet.

841
00:40:59,700 --> 00:41:03,420
>> Sa olid lihtsalt tee seda
lihtsalt meelega Ralphie siin

842
00:41:03,420 --> 00:41:07,934
kuulsa filmi, mis mängib
päris palju reklaami nauseum iga talvel.

843
00:41:07,934 --> 00:41:08,600
[VIDEO PLAYBACK]

844
00:41:08,600 --> 00:41:11,180
-Ole See kõigile teada, et
Ralph Parker Käesolevaga

845
00:41:11,180 --> 00:41:14,070
määratud liige Little
Harva Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
ning tal on õigus kõiki autasud
ja kasu esinevad nendega.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little harva Annie,
kaasallkirja Pierre Andre, tindiga.

848
00:41:24,340 --> 00:41:27,160
Kiitusega ja kasu,
juba üheksa-aastaselt.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Karjumine]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Ole nüüd.

853
00:41:34,250 --> 00:41:35,210
Lähme edasi.

854
00:41:35,210 --> 00:41:39,530
Ma ei pea kõik, et jazz
umbes salakaubavedajate ja piraadid.

855
00:41:39,530 --> 00:41:41,660
>> Saate kuulata homme õhtul
kokkuvõtvad seiklus

856
00:41:41,660 --> 00:41:43,880
must Piraatlaeva.

857
00:41:43,880 --> 00:41:46,650
Nüüd on aeg
Annie salajane sõnum

858
00:41:46,650 --> 00:41:49,840
Teile liikmed Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Pea meeles, et lapsed, vaid liikmed
Annie Secret Circle

860
00:41:53,570 --> 00:41:56,140
saab dekodeerida Annie salajane sõnum.

861
00:41:56,140 --> 00:42:00,340
>> Pea meeles, et Annie on sõltuvalt teile.

862
00:42:00,340 --> 00:42:02,880
Määra oma sõrmed B2.

863
00:42:02,880 --> 00:42:05,230
Siin on sõnum.

864
00:42:05,230 --> 00:42:06,090
12 11--

865
00:42:06,090 --> 00:42:10,250
>> -Ma Olen, minu esimene salajase kohtumise.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Oli suur hääl täna.

868
00:42:15,780 --> 00:42:19,000
Ma võiks öelda, et tänase
sõnum oli väga oluline.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, see on sõnum
alates Annie ise.

870
00:42:22,694 --> 00:42:23,860
Pea meeles, et ei ütle kellelegi.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekundit hiljem, ma olen ainuke
tuba majast, kus poiss üheksa

873
00:42:32,930 --> 00:42:37,040
võiks istuda privaatsust ja dekodeerida.

874
00:42:37,040 --> 00:42:39,730
Ahaa, B!

875
00:42:39,730 --> 00:42:42,360
Läksin järgmisel, E.

876
00:42:42,360 --> 00:42:44,520
>> Esimene sõna on olla.

877
00:42:44,520 --> 00:42:49,032
S, siis tuli lihtsam nüüd, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Oh, tule, Ralphie, ma pean minema!

879
00:42:51,733 --> 00:42:53,688
>> -Ma Kohe maha, ema!

880
00:42:53,688 --> 00:42:54,188
Gee viuhti!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, kindlasti mina-- kindlasti mida?

883
00:43:04,060 --> 00:43:05,970
Mis oli Little harva
Annie üritab öelda?

884
00:43:05,970 --> 00:43:07,264
Kindlasti mida?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy on saanud
minna, kas sa siis välja tulema?

886
00:43:09,634 --> 00:43:10,480
>> -Heaküll, Ma!

887
00:43:10,480 --> 00:43:12,880
Ma tulen kohe välja!

888
00:43:12,880 --> 00:43:14,550
>> -Ma Oli läheneme.

889
00:43:14,550 --> 00:43:16,620
Pinge oli kohutav.

890
00:43:16,620 --> 00:43:17,720
Mis see oli?

891
00:43:17,720 --> 00:43:20,170
Saatus planeedi
võib vaekausil.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Andy pean minema!

894
00:43:23,170 --> 00:43:26,890
>> -Ma Kohe välja, nutt valjusti!

895
00:43:26,890 --> 00:43:32,680
>> Peaaegu seal, mu sõrmed lendas mu mõistus
oli terasest trap, igast poorist vibreerima.

896
00:43:32,680 --> 00:43:37,198
See oli peaaegu selge, jah, jah, jah.

897
00:43:37,198 --> 00:43:43,091
>> -Ole Kindlasti juua oma Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Trullakas kaubandusliku?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Litsipurikas.

903
00:43:54,227 --> 00:43:54,810
[END PLAYBACK]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Humala: OK, nii
See oli väga pikk tee

905
00:43:57,390 --> 00:44:00,660
kasutusele krüptograafia
ja ka Ovaltine.

906
00:44:00,660 --> 00:44:04,470
Tegelikult on see vana kuulutus
siin, miks on Ovaltine nii hea?

907
00:44:04,470 --> 00:44:09,470
See on kontsentreeritud kaevandamise küps
odralinnastest, puhas koorene lehmapiima,

908
00:44:09,470 --> 00:44:14,360
ja spetsiaalselt ettevalmistatud kakao, koos
looduslike fosfatiidfraktsioone ja vitamiine.

909
00:44:14,360 --> 00:44:18,240
Lisaks sellele on rikastatud
täiendavaid vitamiine B ja D, yum.

910
00:44:18,240 --> 00:44:21,600
Ja saad ikka see ilmselt
Amazon, nagu tegime siin.

911
00:44:21,600 --> 00:44:24,810
>> Aga motivatsiooni siin oli
tutvustada krüptograafia, täpsemalt

912
00:44:24,810 --> 00:44:28,340
tüüpi krüptograafia tuntud
kui salajase võtme krüptograafia.

913
00:44:28,340 --> 00:44:34,284
Ja nagu nimigi ütleb, terve
turvalisuse salajase võtme krüpto süsteemi

914
00:44:34,284 --> 00:44:36,200
kui soovite, metoodika
just skrambleerimise

915
00:44:36,200 --> 00:44:40,960
teave kahe inimese vahel, on see, et
ainult saatjale ja ainult saaja

916
00:44:40,960 --> 00:44:46,980
tean salajane key-- mingi väärtus, mõned
saladus fraas mõned salajane number, et

917
00:44:46,980 --> 00:44:50,660
võimaldab neil nii krüpteerida
dekrüpteerida andmeid.

918
00:44:50,660 --> 00:44:53,470
Ja krüptograafia, tõesti,
just seda nädalast 0.

919
00:44:53,470 --> 00:44:56,715
>> See on probleem, kus on sisendid,
nagu tegelik sõnum inglise

920
00:44:56,715 --> 00:44:59,340
või mis iganes keeles, et sa
soovite saata kellelegi klassis,

921
00:44:59,340 --> 00:45:00,580
või üle interneti.

922
00:45:00,580 --> 00:45:03,840
On mõned väljund, mis läheb
olla kodeeritud sõnum, mida

923
00:45:03,840 --> 00:45:05,250
taha saaja saada.

924
00:45:05,250 --> 00:45:07,405
Ja isegi kui keegi
keskel saab see ka

925
00:45:07,405 --> 00:45:09,780
sa ei taha, et nad
pruugi olla võimalik lahti krüptida,

926
00:45:09,780 --> 00:45:12,840
sest sees käesoleva
musta kasti või algoritm,

927
00:45:12,840 --> 00:45:17,650
on mingi mehhanism, mõned samm-sammult
juhiseid, et võtta, et sisend

928
00:45:17,650 --> 00:45:20,710
ja muundab selle sisse
väljund mis loodetavasti turvaliselt.

929
00:45:20,710 --> 00:45:23,640
>> Ja tegelikult on teatud
sõnavara siin maailmas järgmiselt.

930
00:45:23,640 --> 00:45:26,100
Tavaline tekst on sõnale
arvuti teadlane oleks

931
00:45:26,100 --> 00:45:28,449
kasutada, et kirjeldada sisend
sõnum, nagu inglise

932
00:45:28,449 --> 00:45:31,240
või mis iganes keeles sa tegelikult
soovite saata mõne teise inimese.

933
00:45:31,240 --> 00:45:35,450
Ja siis ciphertext on rüselus
et šifreeritud või krüpteeritud,

934
00:45:35,450 --> 00:45:36,520
versioonis.

935
00:45:36,520 --> 00:45:38,750
>> Aga seal on üks teine ​​koostisosa siin.

936
00:45:38,750 --> 00:45:43,200
On veel üks sisend
salajase võtme krüptograafia.

937
00:45:43,200 --> 00:45:45,200
Ja see on võti ise,
mis on üldiselt

938
00:45:45,200 --> 00:45:48,930
nagu me näeme, numbri või
kirja või sõna, mida iganes

939
00:45:48,930 --> 00:45:51,980
algoritm on tegelikult ootab.

940
00:45:51,980 --> 00:45:53,870
>> Ja kuidas sa lahti informatsiooni?

941
00:45:53,870 --> 00:45:55,110
Kuidas te lahti harutama?

942
00:45:55,110 --> 00:45:57,950
Noh, sa lihtsalt vastupidine
väljundeid ja sisendeid.

943
00:45:57,950 --> 00:46:00,900
>> Teisisõnu, kui keegi
saab oma krüptitud kirja,

944
00:46:00,900 --> 00:46:03,740
ta lihtsalt peab
teada, et sama võti.

945
00:46:03,740 --> 00:46:05,700
Nad on saanud ciphertext.

946
00:46:05,700 --> 00:46:09,530
Ja ühendades need kaks
sisestavate krüpto süsteemi

947
00:46:09,530 --> 00:46:14,260
algoritmi, see must kast, välja
peaks tulema originaal polegi.

948
00:46:14,260 --> 00:46:17,830
Ja nii see on väga kõrgel tasemel
Arvestades seda, mida krüptograafia on tegelikult

949
00:46:17,830 --> 00:46:18,590
kõike.

950
00:46:18,590 --> 00:46:20,030
>> Nii lähme sinna.

951
00:46:20,030 --> 00:46:22,700
Olgem nüüd pilk all
kapuutsi midagi

952
00:46:22,700 --> 00:46:26,000
oleme võtnud ette antud
Viimase nädala ning selle seansi

953
00:46:26,000 --> 00:46:27,629
siin-- string.

954
00:46:27,629 --> 00:46:30,295
See string lõpus päeval
on lihtsalt märgijada.

955
00:46:30,295 --> 00:46:33,610
>> See võib olla tere, või
tere Zamyla, või mis iganes.

956
00:46:33,610 --> 00:46:37,050
Aga mida see tähendab, et
olla märgijada?

957
00:46:37,050 --> 00:46:41,520
Tegelikult CS50 raamatukogu annab
meil andmetüüp nimetatakse jada.

958
00:46:41,520 --> 00:46:45,140
>> Aga seal on tegelikult puudub
sellist asja nagu string C.

959
00:46:45,140 --> 00:46:49,450
See on tõesti lihtsalt jada
iseloomu, iseloomu, iseloomus,

960
00:46:49,450 --> 00:46:52,180
iseloomu, tagasi, tagasi, et
tagasi, tagasi, tagasi sees

961
00:46:52,180 --> 00:46:54,650
arvuti mälu või mälu.

962
00:46:54,650 --> 00:46:58,940
Ja me vaatame sügavamale, et
tulevikus, kui me vaatame mälu ise

963
00:46:58,940 --> 00:47:02,030
ja kasutamise ning
ohud, mis on seotud.

964
00:47:02,030 --> 00:47:04,100
>> Aga Vaatleme jada Zamyla.

965
00:47:04,100 --> 00:47:07,480
Nii lihtsalt nime
Inimese siin Zamyla,

966
00:47:07,480 --> 00:47:12,030
et on jada
Märgid, Z-A-M-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
Ja nüüd oletame, et Zamyla nimi
on ladestunud arvuti

968
00:47:16,020 --> 00:47:16,880
programmi.

969
00:47:16,880 --> 00:47:20,830
>> Noh, siis loogiline, et me peaksime
oleks võimalik vaadata neid tähemärki

970
00:47:20,830 --> 00:47:21,590
individuaalselt.

971
00:47:21,590 --> 00:47:24,710
Nii et ma lihtsalt lähen juhtida vähe
kast ümber Zamyla nime siin.

972
00:47:24,710 --> 00:47:31,580
Ja see on nii C, et kui sa
on string, nagu Zamyla-- ja võibolla

973
00:47:31,580 --> 00:47:34,940
et string on tulnud tagasi
funktsioon nagu get string,

974
00:47:34,940 --> 00:47:38,540
saab tegelikult manipuleerida
see tähthaaval.

975
00:47:38,540 --> 00:47:42,070
>> Nüüd on see Sobiv jaoks
vestlus käepärast, sest

976
00:47:42,070 --> 00:47:46,420
krüptograafia kui te soovite muuta
A B ja B C ja C-D,

977
00:47:46,420 --> 00:47:49,650
ja nii edasi, sa pead olema võimeline
vaadata üksikute märkide

978
00:47:49,650 --> 00:47:50,190
string.

979
00:47:50,190 --> 00:47:52,695
Sa pead olema võimeline muutma
Z midagi muud, A

980
00:47:52,695 --> 00:47:55,280
midagi muud, M
midagi muud, ja nii edasi.

981
00:47:55,280 --> 00:47:58,000
Ja seega peame nii,
programmiliselt, nii

982
00:47:58,000 --> 00:48:03,020
rääkida, C, et oleks võimalik muuta
ja vaadata üksikuid tähti.

983
00:48:03,020 --> 00:48:05,690
Ja me saame seda teha järgmiselt.

984
00:48:05,690 --> 00:48:08,340
>> Lubage mul minna pea tagasi CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
Ja las ma minna
ja luua uus fail

986
00:48:11,130 --> 00:48:16,134
et ma helistan seekord string0,
meie esimene selline näide, dot c.

987
00:48:16,134 --> 00:48:18,300
Ja ma lähen edasi minna
ja vahusta see üles järgmiselt.

988
00:48:18,300 --> 00:48:22,870
>> Nii hulka CS50.h ja
Seejärel lisada standard io.h,

989
00:48:22,870 --> 00:48:25,990
mis ma peaaegu alati läheb
kasuta minu programmid, vähemalt

990
00:48:25,990 --> 00:48:26,780
esialgu.

991
00:48:26,780 --> 00:48:32,180
int main void ja siis siin ma olen
kavatsevad teha stringid saab saada string.

992
00:48:32,180 --> 00:48:35,260
Ja siis ma lähen
minna ja seda teha.

993
00:48:35,260 --> 00:48:37,460
Tahan minna
ja kui mõistuse kontrolli,

994
00:48:37,460 --> 00:48:43,607
lihtsalt öelda, tere, protsendi s,
semikoolon, teeb string 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, mida ma tegin siin?

996
00:48:44,690 --> 00:48:45,930
Oh, ma ei ühendage see.

997
00:48:45,930 --> 00:48:48,120
Nii õppetund, et
ei olnud tahtlik.

998
00:48:48,120 --> 00:48:52,480
>> Nii viga, rohkem protsenti
konversioone kui andmed argumente.

999
00:48:52,480 --> 00:48:54,940
Ja see on osa, kus
line 7-- OK, nii et mul on,

1000
00:48:54,940 --> 00:48:56,690
tsitaat lõppeb, mis on
minu stringi printf.

1001
00:48:56,690 --> 00:48:58,151
Mul protsendimärgiga.

1002
00:48:58,151 --> 00:48:59,650
Aga ma puudu teine ​​argument.

1003
00:48:59,650 --> 00:49:03,190
>> Ma puudu koma s, mis
Ma olen oma varasemates näiteid.

1004
00:49:03,190 --> 00:49:06,650
Nii hea võimaluse määrata
veel üks viga, kogemata.

1005
00:49:06,650 --> 00:49:09,950
Ja nüüd lubage mul juhtida
string0, kirjuta Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, tere Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Nii oleme käivitada selline programm
paar erinevat korda nüüd.

1008
00:49:14,144 --> 00:49:16,310
Aga teeme midagi
veidi erinev seekord.

1009
00:49:16,310 --> 00:49:19,450
Selle asemel, et lihtsalt printimisel Zamyla on
Kogu nime välja printf,

1010
00:49:19,450 --> 00:49:21,350
teeme ära tähthaaval.

1011
00:49:21,350 --> 00:49:22,700
>> Ma lähen kasutada jaoks silmus.

1012
00:49:22,700 --> 00:49:26,160
Ja ma lähen annan end
lugedes muutuja, mida nimetatakse i.

1013
00:49:26,160 --> 00:49:33,530
Ja ma lähen hoida itereerimine, nii
Niikaua kui i on väiksem kui pikkus s.

1014
00:49:33,530 --> 00:49:35,930
>> Selgub, me ei teinud
Selleks viimane kord,

1015
00:49:35,930 --> 00:49:39,100
et c kaasas
funktsiooni nimetatakse Stirling.

1016
00:49:39,100 --> 00:49:42,690
Juba järgmisel päeval, ja üldiselt
veel rakendamisel funktsioone,

1017
00:49:42,690 --> 00:49:45,405
Inimestel on sageli valida väga
sisutihedat nimed sellist heli

1018
00:49:45,405 --> 00:49:48,280
nagu mida sa tahad, kuigi see on
puudu mõned täishäälikud või tähed.

1019
00:49:48,280 --> 00:49:50,660
Nii Stirling on
funktsiooni nime, mis

1020
00:49:50,660 --> 00:49:53,880
võtab argumendiks vahel
Sulgudes mis peaks olema string.

1021
00:49:53,880 --> 00:49:56,910
Ja see lihtsalt tagastab täisarvu
pikkus, et string.

1022
00:49:56,910 --> 00:50:00,580
>> Nii et see silmus real 7 läheb
lugemise alustamiseks kell i võrdub 0.

1023
00:50:00,580 --> 00:50:02,530
See saab juurdekasvu
i iga iteratsiooni

1024
00:50:02,530 --> 00:50:04,350
1, kui me oleme teinud paar korda.

1025
00:50:04,350 --> 00:50:06,780
Aga see läheb ainult teha
Selle kuni hetkeni

1026
00:50:06,780 --> 00:50:09,660
kui ma ei pikkusest
string ise.

1027
00:50:09,660 --> 00:50:14,520
>> Nii et see on viis lõpuks
iterating üle tähemärki

1028
00:50:14,520 --> 00:50:17,430
stringi, nagu ta on järgmine.

1029
00:50:17,430 --> 00:50:20,670
Ma lähen välja trükkida ei ole
Kogu stringi, kuid protsenti c,

1030
00:50:20,670 --> 00:50:22,860
Ühe märgi
järgneb uus liin.

1031
00:50:22,860 --> 00:50:24,880
Ja siis ma lähen
minna, ja mul on vaja

1032
00:50:24,880 --> 00:50:29,080
öelda tahan printida
nda iseloomu s.

1033
00:50:29,080 --> 00:50:33,450
>> Nii et kui i on muutuja, mis näitab,
indeks string, kus

1034
00:50:33,450 --> 00:50:37,230
Te olete see, mul on vaja, et oleks võimalik
öelda, anna mulle nda iseloomu s.

1035
00:50:37,230 --> 00:50:40,390
Ja C on viisiks
seda nurksulgudes.

1036
00:50:40,390 --> 00:50:43,679
Sa lihtsalt öelda nime
string, mis antud juhul on s.

1037
00:50:43,679 --> 00:50:46,970
Siis saate kasutada nurksulgudes, mis on
tavaliselt veidi üle oma Return või Sisesta

1038
00:50:46,970 --> 00:50:48,110
klaviatuuril.

1039
00:50:48,110 --> 00:50:52,410
Ja siis paned indeks
märk, mida soovite printida.

1040
00:50:52,410 --> 00:50:55,960
Nii indeks saab olema
number-- 0 või 1 või 2 või 3, või dot,

1041
00:50:55,960 --> 00:50:57,590
dot, dot, mõne muu number.

1042
00:50:57,590 --> 00:51:00,920
>> Ja me tagada, et see läheb
õige number, sest ma

1043
00:51:00,920 --> 00:51:02,360
lugemise alustamiseks 0.

1044
00:51:02,360 --> 00:51:07,020
Ja vaikimisi esimene märk
string on kokkuleppeliselt 0.

1045
00:51:07,020 --> 00:51:09,230
Ja teine ​​täht on sulg 1.

1046
00:51:09,230 --> 00:51:11,120
Ja kolmas täht on sulg 2.

1047
00:51:11,120 --> 00:51:13,630
Ja sa ei taha minna liiga
kaugele, kuid me ei ole, sest me oleme

1048
00:51:13,630 --> 00:51:17,780
läheb ainult juurdekasvu i, kuni see
võrdub stringi pikkusena.

1049
00:51:17,780 --> 00:51:20,210
Ja sel hetkel,
Selle jaoks silmus peatub.

1050
00:51:20,210 --> 00:51:25,550
>> Nii et lubage mul minna ja päästa see
programmi ning run teha string 0.

1051
00:51:25,550 --> 00:51:28,400
Aga ma silmamunad.

1052
00:51:28,400 --> 00:51:35,390
Kaudselt kuulutatakse raamatukogu funktsiooni
Stirling sellist tüüpi ja such-- nüüd,

1053
00:51:35,390 --> 00:51:36,430
see tuttav.

1054
00:51:36,430 --> 00:51:37,440
Aga see ei ole printf.

1055
00:51:37,440 --> 00:51:38,540
Ja see ei saa string.

1056
00:51:38,540 --> 00:51:40,480
>> Ma ei kruvi üles
Samamoodi seekord.

1057
00:51:40,480 --> 00:51:45,100
Aga märkate siin veidi alla
Lisaks sisaldavad päise kaudu string,

1058
00:51:45,100 --> 00:51:47,210
selgesõnaliselt anda
deklaratsiooni Stirling.

1059
00:51:47,210 --> 00:51:48,820
Seega on tegelikult aimugi seal.

1060
00:51:48,820 --> 00:51:51,670
>> Ja tõepoolest selgub
seal on veel päisefaili

1061
00:51:51,670 --> 00:51:53,970
et me oleme ei kasutata
klassis, aga see on

1062
00:51:53,970 --> 00:51:56,480
nende hulgas saadaval
teile, mida nimetatakse string.

1063
00:51:56,480 --> 00:52:00,930
Ja selles failis string
on Stirling tunnistada.

1064
00:52:00,930 --> 00:52:05,220
Nii et lubage mul minna ja
päästa see, et string

1065
00:52:05,220 --> 00:52:08,040
0-- kena, ei veateateid seekord.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla ja
Ma olen umbes Enter,

1067
00:52:12,290 --> 00:52:16,710
misjärel getString läheb
tagasi string, pane see s.

1068
00:52:16,710 --> 00:52:21,890
Siis, et loop läheb itereerima
Üle S tegelased ükshaaval,

1069
00:52:21,890 --> 00:52:28,420
ja printida neid üks rea kohta, sest
Mul oli, et backslash n lõpus.

1070
00:52:28,420 --> 00:52:34,530
Nii et ma võiks jätta, et backslash
n, ja siis lihtsalt printida Zamyla kõik

1071
00:52:34,530 --> 00:52:37,460
sama liini,
tõhusalt reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, mis ei ole nii kasulik.

1073
00:52:38,999 --> 00:52:40,540
Aga sel juhul, ma ei ole teinud.

1074
00:52:40,540 --> 00:52:43,610
Olen tegelikult trükitud üks
täht korraga, üks rea kohta

1075
00:52:43,610 --> 00:52:45,400
nii et me tegelikult näha mõju.

1076
00:52:45,400 --> 00:52:46,900
>> Aga ma peaks tähele üks asi siin.

1077
00:52:46,900 --> 00:52:48,930
Ja me tuleme tagasi
Seda tulevase nädalas.

1078
00:52:48,930 --> 00:52:52,650
Selgub, et see
kood on potentsiaalselt lollakas.

1079
00:52:52,650 --> 00:52:56,560
>> Selgub, et get string
ja mõned muud ülesanded elu

1080
00:52:56,560 --> 00:53:00,280
ei pruugi alati
tagasi, mida te ootate.

1081
00:53:00,280 --> 00:53:03,010
Me teame klassi viimase
aega selles, et saada

1082
00:53:03,010 --> 00:53:04,960
string peaksid tagasi string.

1083
00:53:04,960 --> 00:53:09,900
Aga mis siis, kui kasutaja tipib sellist
pikk sõna või lõigu või essee

1084
00:53:09,900 --> 00:53:13,010
et seal on lihtsalt ei piisa
Mälu on arvuti sobitada see.

1085
00:53:13,010 --> 00:53:15,410
>> Nagu, mis siis, kui midagi läheb
vale all kapuuts?

1086
00:53:15,410 --> 00:53:18,400
See ei pruugi juhtuda sageli
kuid see võib juhtuda kord

1087
00:53:18,400 --> 00:53:21,520
samal ajal, väga harva.

1088
00:53:21,520 --> 00:53:25,460
Ja nii selgub, et get string
ja funktsioone, nagu see ei pruugi

1089
00:53:25,460 --> 00:53:26,380
alati tagasi stringid.

1090
00:53:26,380 --> 00:53:30,680
Nad võivad naasta mõni viga väärtus,
mõned valvur väärtust nii-öelda

1091
00:53:30,680 --> 00:53:32,612
mis näitab, et
midagi on valesti läinud.

1092
00:53:32,612 --> 00:53:35,320
Ja siis oleks ainult tean, et see on
olles õppinud klassis praegu

1093
00:53:35,320 --> 00:53:37,700
või lugenud veel mõned dokumendid.

1094
00:53:37,700 --> 00:53:43,120
Selgub, et get string
võib naasta väärtus ehk null.

1095
00:53:43,120 --> 00:53:46,220
Null on eriline väärtus, et me
tagasi tulla tulevases nädalas.

1096
00:53:46,220 --> 00:53:50,420
Aga nüüd, lihtsalt tean, et kui ma tahan
olla tõesti õige viia edasi

1097
00:53:50,420 --> 00:53:52,650
kasutades get string, ma
ei tohiks lihtsalt nimetame seda,

1098
00:53:52,650 --> 00:53:56,870
ja pimesi kasutada oma tagastatav väärtus,
uskudes, et see on string.

1099
00:53:56,870 --> 00:53:59,420
>> Ma peaks kõigepealt öelda,
Hei, oota üks hetk, vaid

1100
00:53:59,420 --> 00:54:03,380
jätkata, kui te ei võrdu
null, kus null jällegi

1101
00:54:03,380 --> 00:54:04,660
on vaid mõned eriline väärtus.

1102
00:54:04,660 --> 00:54:07,770
Ja see on ainus eriline väärtus, mida
vaja muretseda get string.

1103
00:54:07,770 --> 00:54:10,900
Saada string kas läheb
tagasi string või null.

1104
00:54:10,900 --> 00:54:17,219
>> Ja see hüüumärk võrdusmärki
võite teame võibolla matemaatika klassi

1105
00:54:17,219 --> 00:54:20,510
et võite juhtida võrdusmärk koos
läbikriipsutatud näidata ei ole võrdsed.

1106
00:54:20,510 --> 00:54:23,135
See ei ole tavaliselt märk
saate tippida klaviatuuril.

1107
00:54:23,135 --> 00:54:26,480
Ja nii enamikes programmeerimiskeeltes,
kui sa tahad öelda ei ole võrdsed,

1108
00:54:26,480 --> 00:54:29,160
kasutate hüüumärk,
muidu tuntud pauk.

1109
00:54:29,160 --> 00:54:33,180
Nii sa ütled bang võrdub, mis
tähendab mitte võrdub loogiliselt.

1110
00:54:33,180 --> 00:54:38,060
See on nagu seal ei ole suurem
kui või võrdne või väiksem kui

1111
00:54:38,060 --> 00:54:41,270
või võrdne klahvi
et see kõik on üks sümbol.

1112
00:54:41,270 --> 00:54:44,020
Nii et see, miks varem näiteid,
sa tegid avatud sulg ja seejärel

1113
00:54:44,020 --> 00:54:48,670
võrdusmärk, et teha
suurem või, ütleme, vähem kui.

1114
00:54:48,670 --> 00:54:49,910
>> Mis siis Buffee siin?

1115
00:54:49,910 --> 00:54:53,880
See on lihtsalt nii nüüd on
kehtestades selle süntaksit, see funktsioon,

1116
00:54:53,880 --> 00:54:57,390
iterating üksikult
märkide jada.

1117
00:54:57,390 --> 00:55:00,260
Ja nagu need, kandiline
Sulgudes võimaldab teil saada neid,

1118
00:55:00,260 --> 00:55:03,790
arvestama nurksulgudes nagu
Selline vihjab sellele aluseks oleva

1119
00:55:03,790 --> 00:55:06,040
disain, kusjuures iga
märgi sees string

1120
00:55:06,040 --> 00:55:10,180
on selline pakendada kusagil all
kapoti arvuti mällu.

1121
00:55:10,180 --> 00:55:12,340
>> Kuid olgem teha variant sellest.

1122
00:55:12,340 --> 00:55:14,880
Selgub, et see
Programm on õige.

1123
00:55:14,880 --> 00:55:18,810
Nii ühe CS50 teljed hindamiseks
kood, see on õige nüüd.

1124
00:55:18,810 --> 00:55:22,959
Eriti nüüd, et ma olen kontrollimine
null, see programm peaks kunagi krahhi.

1125
00:55:22,959 --> 00:55:24,500
Ja ma lihtsalt tean, et kogemustest.

1126
00:55:24,500 --> 00:55:28,040
Aga seal on midagi muud, mis
saame tõesti minna valesti.

1127
00:55:28,040 --> 00:55:31,860
Aga see ei ole väga hästi läbi mõeldud,
sest lähme tagasi põhitõdesid.

1128
00:55:31,860 --> 00:55:34,450
>> Esiteks principles--
Mis siis silmus teha?

1129
00:55:34,450 --> 00:55:36,290
Jaoks silmus teeb kolme asja.

1130
00:55:36,290 --> 00:55:39,340
See käivitab mõne
väärtust, kui te küsite seda.

1131
00:55:39,340 --> 00:55:41,770
Ta kontrollib tingimus.

1132
00:55:41,770 --> 00:55:45,380
Ja siis pärast iga
korduse pärast iga tsükli

1133
00:55:45,380 --> 00:55:49,330
see kasvatab mõned
väärtuse või väärtused, siin.

1134
00:55:49,330 --> 00:55:50,600
>> Mida see tähendab?

1135
00:55:50,600 --> 00:55:52,940
Me initsialiseerida i kuni 0.

1136
00:55:52,940 --> 00:55:58,610
Me kontrollime ja veenduge i on väiksem kui
pikkus s, mis on Z-A-M-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
nii mis on vähem kui 6.

1138
00:55:59,900 --> 00:56:02,590
Ja tõepoolest, 0, sest alla 6.

1139
00:56:02,590 --> 00:56:05,580
>> Me printida Z alates Zamyla nime.

1140
00:56:05,580 --> 00:56:08,080
Siis juurdekasvu i 0-1.

1141
00:56:08,080 --> 00:56:11,290
Siis vaadake, on 1 vähem
kui pikkus s?

1142
00:56:11,290 --> 00:56:13,270
Pikkus s on 6.

1143
00:56:13,270 --> 00:56:13,950
Jah see on.

1144
00:56:13,950 --> 00:56:16,880
>> Nii et me printida ka Zamyla nimi, ZA.

1145
00:56:16,880 --> 00:56:20,090
Me juurdekasvu i 0, 1, 2.

1146
00:56:20,090 --> 00:56:23,720
Siis vaadake, on 2 alla
pikkus Zamyla nime.

1147
00:56:23,720 --> 00:56:25,380
6- nii 2 on vähem kui 6.

1148
00:56:25,380 --> 00:56:30,460
Jah, lähme välja trükkida nüüd M
Zamyla nimi, kolmas tähemärk.

1149
00:56:30,460 --> 00:56:34,110
>> Peamine on, et iga
iteratsiooni lugu, ma kontrollida,

1150
00:56:34,110 --> 00:56:37,810
on i vähem kui pikkus Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Aga saak on, et
Stirling ei ole vara.

1152
00:56:40,350 --> 00:56:43,100
Neile, kes on programmeeritud
Enne Java või teistes keeltes

1153
00:56:43,100 --> 00:56:46,310
tunneksid pikkus string
vara, vaid mõned read only väärtus.

1154
00:56:46,310 --> 00:56:50,220
>> In C sel juhul, kui see on
funktsioon, mis on sõna otseses mõttes

1155
00:56:50,220 --> 00:56:53,520
loendades
tegelased Zamyla iga kord

1156
00:56:53,520 --> 00:56:54,740
me nimetame seda funktsiooni.

1157
00:56:54,740 --> 00:56:58,500
Iga kord, kui te küsite arvuti kasutamise
Stirling, see võtab pilk Zamyla,

1158
00:56:58,500 --> 00:57:01,960
ja öelda Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
Ja ta naaseb 6.

1160
00:57:02,962 --> 00:57:04,920
Järgmine kord, kui helistada
see sees, et loop,

1161
00:57:04,920 --> 00:57:08,610
see saab vaadata Zamyla
jälle öelda Z-A-M-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
Ja see läheb tagasi 6.

1163
00:57:10,320 --> 00:57:12,980
Mis siis loll selle kujundus?

1164
00:57:12,980 --> 00:57:17,700
>> Miks on minu kood ei ole 5 out of 5
projekteerimise kohe, kui nii võib öelda?

1165
00:57:17,700 --> 00:57:20,600
Noh, ma küsib
Küsimus asjatult.

1166
00:57:20,600 --> 00:57:23,030
Ma teen rohkem tööd kui mul on vaja.

1167
00:57:23,030 --> 00:57:25,370
>> Nii kuigi
vastus on õige, ma olen

1168
00:57:25,370 --> 00:57:29,560
küsib arvuti, mis on
pikkus Zamyla jälle

1169
00:57:29,560 --> 00:57:31,380
ja uuesti ja uuesti ja uuesti?

1170
00:57:31,380 --> 00:57:33,980
Ja see vastus on
muutu kunagi.

1171
00:57:33,980 --> 00:57:35,900
See on alati saab olema 6.

1172
00:57:35,900 --> 00:57:39,730
>> Nii on parem lahendus kui see
oleks see järgmine versioon.

1173
00:57:39,730 --> 00:57:43,390
Lubage mul minna ja pane see
eraldi faili nimega string1.c,

1174
00:57:43,390 --> 00:57:44,990
lihtsalt hoida eraldi.

1175
00:57:44,990 --> 00:57:47,260
Ja selgub, on ette
loop, saab tegelikult

1176
00:57:47,260 --> 00:57:50,210
Kinnitan mitu muutujat korraga.

1177
00:57:50,210 --> 00:57:53,460
>> Nii et ma lähen hoida i ja pani 0.

1178
00:57:53,460 --> 00:57:56,190
Aga ma kavatsen ka
Koma, ja öelda,

1179
00:57:56,190 --> 00:58:01,050
mulle muutuja nimega n, kelle
väärtus on string pikkusega s.

1180
00:58:01,050 --> 00:58:09,410
Ja nüüd, palun teha oma seisundi
niikaua i on väiksem kui n.

1181
00:58:09,410 --> 00:58:14,140
>> Nii et sel viisil, loogika on
identsed lõpus päeval.

1182
00:58:14,140 --> 00:58:18,280
Aga ma olen mäleta
väärtus 6, antud juhul.

1183
00:58:18,280 --> 00:58:19,780
Mis on pikkus Zamyla nimi?

1184
00:58:19,780 --> 00:58:20,860
Ja ma panen seda n.

1185
00:58:20,860 --> 00:58:23,050
>> Ja ma olen ikka kontrollida
tingimusel, iga kord.

1186
00:58:23,050 --> 00:58:24,300
Kas 0 alla 6?

1187
00:58:24,300 --> 00:58:25,600
Kas 1 alla 6?

1188
00:58:25,600 --> 00:58:28,600
Kas 2 alla 6, ja nii edasi?

1189
00:58:28,600 --> 00:58:31,914
>> Aga Ma ei palu arvuti
uuesti ja uuesti, mis on

1190
00:58:31,914 --> 00:58:33,080
pikkus Zamyla nimi?

1191
00:58:33,080 --> 00:58:34,320
Mis on pikkus Zamyla nimi?

1192
00:58:34,320 --> 00:58:35,986
Mis on pikkus selle Zamyla nimi?

1193
00:58:35,986 --> 00:58:40,440
Ma sõna otseses mõttes pea meeles, et esimene ja
vastata ainult selles teises muutuja n.

1194
00:58:40,440 --> 00:58:45,280
Nii et see nüüd oleks mitte ainult
õige, vaid ka hästi läbi mõeldud.

1195
00:58:45,280 --> 00:58:46,670
>> Nüüd, kuidas stiil?

1196
00:58:46,670 --> 00:58:48,866
Olen nimega minu muutujad
päris hästi, ma ütleks.

1197
00:58:48,866 --> 00:58:50,240
Nad super sisutihedat kohe.

1198
00:58:50,240 --> 00:58:52,090
Ja see on täiesti korras.

1199
00:58:52,090 --> 00:58:55,120
>> Kui teil on ainult üks
stringi programmi

1200
00:58:55,120 --> 00:58:56,860
võite ka seda nimetada s string.

1201
00:58:56,860 --> 00:58:59,370
Kui teil on ainult üks muutuja
loendamiseks programmi

1202
00:58:59,370 --> 00:59:00,710
võite ka kutsuda i.

1203
00:59:00,710 --> 00:59:03,500
Kui teil on pikkus, n
on super ühine samuti.

1204
00:59:03,500 --> 00:59:05,800
Aga ma ei ole kommenteeris mõnda minu koodi.

1205
00:59:05,800 --> 00:59:09,200
>> Ma ei ole teatanud reader--
kas see on minu TF või TA,

1206
00:59:09,200 --> 00:59:12,460
või lihtsalt colleague--, mis peaks
tuleb toimub selle programmi.

1207
00:59:12,460 --> 00:59:15,760
Ja nii, et saada hea stiil,
mida ma tahan teha

1208
00:59:15,760 --> 00:59:24,580
on see-- midagi
nagu küsida kasutaja sisend.

1209
00:59:24,580 --> 00:59:26,670
Ja ma võiks kirjutada
Selle väga mitmel viisil.

1210
00:59:26,670 --> 00:59:35,630
>> Veenduge, S- veenduge get
string tagasi string.

1211
00:59:35,630 --> 00:59:40,280
Ja siis siin-- ja see on võib-olla
kõige olulisem comment-- Kerrata

1212
00:59:40,280 --> 00:59:44,450
üle tähemärki s ühe korraga.

1213
00:59:44,450 --> 00:59:47,060
Ja ma võiks kasutada ükskõik
valik inglise keeles

1214
00:59:47,060 --> 00:59:49,650
siin kirjeldada iga
nende tükkideks koodi.

1215
00:59:49,650 --> 00:59:52,740
>> Pange tähele, et ma ei ole esitanud
kommenteerida iga rida koodi,

1216
00:59:52,740 --> 00:59:55,690
tõesti lihtsalt huvitav
need on need, mis

1217
00:59:55,690 --> 00:59:59,460
mõned tähenduses, et ma võin
tahad teha super selge, et keegi

1218
00:59:59,460 --> 01:00:00,460
lugemine minu koodi.

1219
01:00:00,460 --> 01:00:02,920
Ja miks sa helistad saada
string küsida kasutaja sisend?

1220
01:00:02,920 --> 01:00:05,450
Isegi, et üks ei ole tingimata
kõik, mis kirjeldavad.

1221
01:00:05,450 --> 01:00:09,340
Aga see aitab rääkida lugu, sest
Teine rida lugu, veenduge,

1222
01:00:09,340 --> 01:00:10,740
saada string tagasi string.

1223
01:00:10,740 --> 01:00:14,260
>> Ja kolmas rida selles loos on,
Käi tähemärki on üks

1224
01:00:14,260 --> 01:00:15,380
korraga.

1225
01:00:15,380 --> 01:00:17,920
Ja nüüd lihtsalt hea meede,
Ma lähen edasi minna ja lisada

1226
01:00:17,920 --> 01:00:24,560
veel üks kommentaar, et lihtsalt
ütleb print i-nda tegelaskuju s.

1227
01:00:24,560 --> 01:00:26,520
Nüüd, mida ma olen teinud
Päeva lõpuks?

1228
01:00:26,520 --> 01:00:29,190
>> Olen lisanud mõned inglise
sõnad kujul kommentaarid.

1229
01:00:29,190 --> 01:00:32,700
Kaldkriips kaldkriipsuga sümbol tähendab, hei,
arvuti see on inimese,

1230
01:00:32,700 --> 01:00:33,820
ei ole teie jaoks, arvuti.

1231
01:00:33,820 --> 01:00:35,119
Nii nad ignoreerinud loogiliselt.

1232
01:00:35,119 --> 01:00:35,910
Nad on lihtsalt olemas.

1233
01:00:35,910 --> 01:00:39,830
>> Ja tõepoolest, CS50 IDE näitab neid
hall, mis on kasulikud, kuid mitte peamine

1234
01:00:39,830 --> 01:00:41,000
programmile.

1235
01:00:41,000 --> 01:00:42,570
Pane tähele, mida saab nüüd teha.

1236
01:00:42,570 --> 01:00:44,950
Kas sa tead C
programmeerimise või mitte, siis

1237
01:00:44,950 --> 01:00:47,722
lihtsalt seisma tagasi selle
programmi ja koorima kommentaare.

1238
01:00:47,722 --> 01:00:50,180
Küsi kasutaja sisend, veenduge,
saada string tagasi string

1239
01:00:50,180 --> 01:00:53,009
Käi tähemärki s
ükshaaval, printida iseloomu

1240
01:00:53,009 --> 01:00:55,550
i-nda tegelaskuju S- sa seda ei tee
isegi vaadata koodi

1241
01:00:55,550 --> 01:00:57,270
aru saada, mida see programm teeb.

1242
01:00:57,270 --> 01:01:00,280
Ja veel parem, kui sa ise otsida
See programm nädal või kaks,

1243
01:01:00,280 --> 01:01:02,280
või kuus või aastas
sinagi ei ole

1244
01:01:02,280 --> 01:01:04,420
vahtima koodi
püüab meeles pidada,

1245
01:01:04,420 --> 01:01:06,630
Mida ma üritan teha selle koodi?

1246
01:01:06,630 --> 01:01:07,770
>> Olete rääkinud ise.

1247
01:01:07,770 --> 01:01:11,660
Olete kirjeldas seda ise,
või mõne kolleegi või TA või TF.

1248
01:01:11,660 --> 01:01:14,860
Ja nii see oleks nüüd
õige ja hea disain,

1249
01:01:14,860 --> 01:01:18,210
ja lõpuks hea stiili ka.

1250
01:01:18,210 --> 01:01:19,990
Nii et hoidke seda silmas pidades.

1251
01:01:19,990 --> 01:01:22,200
>> Nii et üks teine
asi, mida ma lähen tegema siin

1252
01:01:22,200 --> 01:01:28,240
mida saab nüüd paljastada millised täpselt
toimub all kapuuts.

1253
01:01:28,240 --> 01:01:30,390
Nii et seda funktsiooni
C ja teistes keeltes,

1254
01:01:30,390 --> 01:01:33,010
nimetatakse typecasting
et kas kaudselt

1255
01:01:33,010 --> 01:01:37,250
või kaudselt võimaldab teisendada
ühest andmete tüübist teise.

1256
01:01:37,250 --> 01:01:39,800
Me oleme arutanud nii
palju täna stringid.

1257
01:01:39,800 --> 01:01:41,250
>> Ja stringid on tähemärki.

1258
01:01:41,250 --> 01:01:44,910
Aga mäletate nädal
0, millised on tegelased?

1259
01:01:44,910 --> 01:01:49,334
Tegelased on vaid abstraktsioon
peal numbers-- kohaga numbrid,

1260
01:01:49,334 --> 01:01:52,500
ja kohaga numbrid on tõesti ainult
võtmiseks peal kahendsüsteemile,

1261
01:01:52,500 --> 01:01:53,720
nagu me määratleda seda.

1262
01:01:53,720 --> 01:01:55,540
>> Nii tegelased on numbrid.

1263
01:01:55,540 --> 01:01:58,410
Ja numbrid on tegelased,
lihtsalt sõltuvalt kontekstist.

1264
01:01:58,410 --> 01:02:01,250
Ja selgub, et sees
arvutiprogrammi,

1265
01:02:01,250 --> 01:02:06,830
saab määrata, kuidas soovite otsida
kell bitti sees, et programm?

1266
01:02:06,830 --> 01:02:10,400
>> Meenuta nädal 0, et meil oli
Ascii, mis on just see kood

1267
01:02:10,400 --> 01:02:11,620
kaardistamine kirju numbrid.

1268
01:02:11,620 --> 01:02:13,660
Ja me ütlesime, kapitali A on 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B on 66, ja nii edasi.

1270
01:02:15,860 --> 01:02:20,500
>> Ja teate, meil sisuliselt on sümbolite kohta
esirea siin, nagu C kutsuksin neid,

1271
01:02:20,500 --> 01:02:23,400
tegelased ja seejärel
ints teises reas.

1272
01:02:23,400 --> 01:02:28,180
Ja selgub, saate teisendada
sujuvalt kahe, tavaliselt.

1273
01:02:28,180 --> 01:02:30,042
Ja kui me tahame teha
See teadlikult, me

1274
01:02:30,042 --> 01:02:31,750
Võiksid tegeleda
midagi sellist.

1275
01:02:31,750 --> 01:02:33,590
>> Me võime soovite teisendada
suur- alandada

1276
01:02:33,590 --> 01:02:35,330
juhul, või madalam suurtähtedega.

1277
01:02:35,330 --> 01:02:38,000
Ja selgub, et tema
tegelikult muster siin

1278
01:02:38,000 --> 01:02:39,900
saame omaks vaid hetkeks.

1279
01:02:39,900 --> 01:02:44,120
Aga vaatame kõigepealt juures
Näiteks seda teha selgelt.

1280
01:02:44,120 --> 01:02:46,340
>> Ma lähen tagasi CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Ma lähen, et luua
fail nimega Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
Ja ma lähen edasi minna ja lisan
standard io.h tipus, int main void

1283
01:02:55,960 --> 01:02:57,370
ülaosas oma funktsiooni.

1284
01:02:57,370 --> 01:03:02,700
Ja siis ma lihtsalt teha
following-- jaoks silmus alates i võrdub,

1285
01:03:02,700 --> 01:03:04,610
oletame, 65.

1286
01:03:04,610 --> 01:03:10,460
>> Ja siis ma ei kavatse olla väiksem kui
65, pluss 26 tähte tähestikus.

1287
01:03:10,460 --> 01:03:12,640
Nii et ma lasen arvuti
teha matemaatika minu jaoks olemas.

1288
01:03:12,640 --> 01:03:15,100
Ja siis sees silmus,
Mis ma nüüd välja printida?

1289
01:03:15,100 --> 01:03:19,230
>> % C on% i kurakaldkriipsuga n.

1290
01:03:19,230 --> 01:03:21,290
Ja nüüd ma tahan ühendada kaks väärtust.

1291
01:03:21,290 --> 01:03:24,530
Olen ajutiselt panna küsimus
tähistab seal kutsuda küsimus.

1292
01:03:24,530 --> 01:03:29,940
>> Ma tahan kinnitada, alates 65 aastast
26 tähestiku tähti,

1293
01:03:29,940 --> 01:03:35,190
väljatrükk iga iteratsiooni, et
tegelase lahutamatu samaväärne.

1294
01:03:35,190 --> 01:03:38,299
Teisisõnu, ma tahan
Käi 26 numbrid trükkimine

1295
01:03:38,299 --> 01:03:41,590
Mis ASCII on kirjas,
ja mida vastav number on--

1296
01:03:41,590 --> 01:03:44,650
tõesti ainult taasloomine
graafikus, et slaidi.

1297
01:03:44,650 --> 01:03:47,010
Mida peaks neid küsimärke olla?

1298
01:03:47,010 --> 01:03:51,760
>> Noh, selgub, et teine
üks peaks olema ainult muutuja i.

1299
01:03:51,760 --> 01:03:53,860
Ma tahan näha, et kui number.

1300
01:03:53,860 --> 01:03:58,920
Ja keset argument
siin võin öelda arvuti

1301
01:03:58,920 --> 01:04:03,470
ravida, et täisarv
i kui märki, nii nagu

1302
01:04:03,470 --> 01:04:05,880
asendada see siin protsenti C.

1303
01:04:05,880 --> 01:04:07,990
>> Teisisõnu, kui I
Inimese programmeerija, tean

1304
01:04:07,990 --> 01:04:09,865
need on vaid numbrid
Päeva lõpuks.

1305
01:04:09,865 --> 01:04:12,500
Ja ma tean, et 65 peaks
map teatud iseloomu.

1306
01:04:12,500 --> 01:04:15,310
Selle selgesõnaline valatud,
koos sulgudes

1307
01:04:15,310 --> 01:04:18,840
nimi andmete tüübi soovid
teisendada ja suletud sulgudes

1308
01:04:18,840 --> 01:04:21,200
Võite öelda
arvuti, hei, arvuti,

1309
01:04:21,200 --> 01:04:24,130
teisendada see täisarv süsi.

1310
01:04:24,130 --> 01:04:26,250
>> Nii et kui ma saan seda
programmi pärast koostamisel,

1311
01:04:26,250 --> 01:04:29,740
Vaatame, mida ma saame-- teha Ascii 0.

1312
01:04:29,740 --> 01:04:33,020
Darn see, mida ma valesti tegin siin?

1313
01:04:33,020 --> 01:04:35,884
Kasutage deklareerimata tunnus
kõik korras, ei olnud tahtlik,

1314
01:04:35,884 --> 01:04:37,800
aga vaatame, kui me ei saa
Põhjus selle kaudu.

1315
01:04:37,800 --> 01:04:41,220
>> Nii line five-- nii et ma ei saa
väga palju enne kruvimiseks üles.

1316
01:04:41,220 --> 01:04:42,140
See on OK.

1317
01:04:42,140 --> 01:04:46,560
Nii line 5 i võrdub 65-- näen.

1318
01:04:46,560 --> 01:04:50,130
Seega pidage meeles, et C, erinevalt mõnest
keeles, kui teil on eelneva programmeerimine

1319
01:04:50,130 --> 01:04:52,190
kogemus, siis on
öelda arvutis

1320
01:04:52,190 --> 01:04:55,040
Erinevalt Scratch, mida
tüüpi muutuja see on.

1321
01:04:55,040 --> 01:04:56,860
>> Ja ma unustasin oluline lause siin.

1322
01:04:56,860 --> 01:04:59,200
Kooskõlas viis, ma olen hakanud kasutama i.

1323
01:04:59,200 --> 01:05:01,560
Aga ma ei öelnud C
Mis andmete tüübi see on.

1324
01:05:01,560 --> 01:05:04,570
Nii et ma lähen siin ja
öelda, ah, oleks täisarv.

1325
01:05:04,570 --> 01:05:07,050
>> Nüüd ma lähen edasi minna ja uuesti kompileerida.

1326
01:05:07,050 --> 01:05:08,080
See fikseeritud, et.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Sisesta, see on selline lahe.

1328
01:05:12,660 --> 01:05:15,360
Mitte ainult see on super kiire
küsi arvuti sellele küsimusele,

1329
01:05:15,360 --> 01:05:18,885
pigem otsin ta üles slaidil,
see välja trükkida üks rea kohta, A on 65,

1330
01:05:18,885 --> 01:05:24,860
B on 66, kõik viis down-- kuna ma
tegi seda 26 korda-- kirjadele z,

1331
01:05:24,860 --> 01:05:25,630
mis on 90.

1332
01:05:25,630 --> 01:05:27,790
Ja tegelikult veidi
arukamaid oleks

1333
01:05:27,790 --> 01:05:31,030
on olnud minu jaoks mitte tugineda
arvutis lisada 26.

1334
01:05:31,030 --> 01:05:34,060
Ma oleks võinud lihtsalt teha
90 ka, nii kaua

1335
01:05:34,060 --> 01:05:37,390
kui ma ei tee sama viga kaks korda.

1336
01:05:37,390 --> 01:05:41,880
Ma tahan minna kuni kaudu
z, mitte ainult üles läbi y.

1337
01:05:41,880 --> 01:05:44,000
>> Nii et selgesõnalise valatud.

1338
01:05:44,000 --> 01:05:47,860
Selgub, et see
ei ole isegi vajalik.

1339
01:05:47,860 --> 01:05:52,480
Lubage mul minna ja uuesti, see
tõlkija ja kordamisega Ascii 0.

1340
01:05:52,480 --> 01:05:54,940
Selgub, et C on päris tark.

1341
01:05:54,940 --> 01:05:57,150
>> Ja printf, eelkõige
on päris tark.

1342
01:05:57,150 --> 01:06:01,260
Kui sa just sooritama i kaks korda
nii kohatäitjaid, printf

1343
01:06:01,260 --> 01:06:04,510
saad aru, oh, noh, ma tean, et sa
andis mulle integer-- mõned number,

1344
01:06:04,510 --> 01:06:06,380
nagu 65 või 90 või mis iganes.

1345
01:06:06,380 --> 01:06:10,170
Aga ma näen, et sa tahad, et
vormingus, mis number nagu iseloomu.

1346
01:06:10,170 --> 01:06:16,460
Ja nii printf võib kaudselt heita
int, et char ka teid.

1347
01:06:16,460 --> 01:06:19,360
Nii et see ei ole probleem üldse.

1348
01:06:19,360 --> 01:06:23,100
>> Aga märgata, sest see võrdväärsuse
me tegelikult võite seda teha ka.

1349
01:06:23,100 --> 01:06:26,520
Lubage mul minna ja teha üks
teiste versioon see-- Ascii 1.c.

1350
01:06:26,520 --> 01:06:31,800
Ja selle asemel, iterating üle
täisarvud, võib tõesti löök meelt

1351
01:06:31,800 --> 01:06:33,610
iterating üle tähemärki.

1352
01:06:33,610 --> 01:06:37,660
Kui char c saab kapitali A, ma
tahan minna ja teha seda,

1353
01:06:37,660 --> 01:06:41,740
niikaua C on väiksem või võrdne
kapitali Z. Ja iga iteratsiooni

1354
01:06:41,740 --> 01:06:45,690
Tahan juurdekasvu C, suudan
Nüüd minu printf line siin

1355
01:06:45,690 --> 01:06:51,320
ütleme, protsendi C on
protsenti i uuesti komaga C.

1356
01:06:51,320 --> 01:06:57,200
>> Ja nüüd, ma ei saa minna teise suunda,
casting iseloomu selgesõnaliselt

1357
01:06:57,200 --> 01:06:58,500
täisarv.

1358
01:06:58,500 --> 01:07:00,560
Niisiis, jälle, miks sa seda teed?

1359
01:07:00,560 --> 01:07:03,830
See on natuke imelik, et mingisugune
loe mõttes märki.

1360
01:07:03,830 --> 01:07:07,430
>> Aga kui sa aru saada, mis on
toimub all kapuuts,

1361
01:07:07,430 --> 01:07:08,430
seal on tõesti mingit maagiat.

1362
01:07:08,430 --> 01:07:13,060
Sa oled lihtsalt öeldes, hei, arvuti annab
mulle muutuja nimega C tüüpi char.

1363
01:07:13,060 --> 01:07:16,520
Vorminda seda kapitali A. Ja
märgata ülakoma asi.

1364
01:07:16,520 --> 01:07:19,580
>> Sest tähemärki C, tagasikutsumise
Eelmisel nädalal sa Kasutada ülakoma.

1365
01:07:19,580 --> 01:07:23,720
Keelpillidele, sõnu,
laused, mida kasutate jutumärkide.

1366
01:07:23,720 --> 01:07:27,210
OK, arvuti, hoida seda teed, et
Niikaua kui iseloomu on alla

1367
01:07:27,210 --> 01:07:28,050
või võrdne z.

1368
01:07:28,050 --> 01:07:32,640
Ja ma tean, minu Ascii laua, et kõik
Nende Ascii koode piirnevad.

1369
01:07:32,640 --> 01:07:33,400
>> Ei ole mingit puudust.

1370
01:07:33,400 --> 01:07:36,737
Nii et see on lihtsalt läbi Z,
eraldatud ühe numbri kaupa.

1371
01:07:36,737 --> 01:07:38,820
Ja siis ma saan juurdekasvu
süsi, kui ma tõesti tahan.

1372
01:07:38,820 --> 01:07:40,390
Päeva lõpuks,
see on lihtsalt number.

1373
01:07:40,390 --> 01:07:41,030
Ma tean seda.

1374
01:07:41,030 --> 01:07:43,670
Nii et ma lihtsalt eeldada, et lisada 1 kuni ta.

1375
01:07:43,670 --> 01:07:46,940
>> Ja siis seekord ma printida c,
ja siis lahutamatu samaväärne.

1376
01:07:46,940 --> 01:07:50,170
Ja ma ei pea isegi selgesõnalise valatud.

1377
01:07:50,170 --> 01:07:52,680
Ma ei lase printf ja
arvuti välja mõtlemiseks,

1378
01:07:52,680 --> 01:07:57,300
nii et nüüd, kui ma saan
teha Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Ma saan täpselt sama asi ka.

1380
01:08:01,520 --> 01:08:04,530
>> Kasutu programm, though-- keegi
läheb tegelikult kirjutada tarkvara

1381
01:08:04,530 --> 01:08:07,549
selleks, et aru saada, milline oli
number, mis kaardistab A või B või Z?

1382
01:08:07,549 --> 01:08:10,340
Sa lihtsalt läheb Google, või
otsida see üles online, või otsida see üles

1383
01:08:10,340 --> 01:08:11,650
slaidil vms.

1384
01:08:11,650 --> 01:08:13,520
Nii et kui see tegelikult saada kasulikku?

1385
01:08:13,520 --> 01:08:15,960
>> Noh, rääkides, et
slaidi märgata seal

1386
01:08:15,960 --> 01:08:20,890
tegelik muster siin suur-
ja väiketähed, mis ei olnud juhuslik.

1387
01:08:20,890 --> 01:08:23,760
Pange tähele, et kapitali A on 65.

1388
01:08:23,760 --> 01:08:25,830
Väiketähed a on 97.

1389
01:08:25,830 --> 01:08:29,649
Ja kui kaugel on madalam juhul?

1390
01:08:29,649 --> 01:08:32,649
>> Nii 65 on mitu sammu kaugusel 97?

1391
01:08:32,649 --> 01:08:36,210
Nii 97 miinus 65 on 32.

1392
01:08:36,210 --> 01:08:37,910
Nii kapitali a on 65.

1393
01:08:37,910 --> 01:08:39,939
Kui lisate 32, et
saad väiketähed a.

1394
01:08:39,939 --> 01:08:43,729
Ja võrreldavalt kui te lahutama 32,
saad tagasi kapitali a-- sama B

1395
01:08:43,729 --> 01:08:46,380
vähe b, suur C vähe c.

1396
01:08:46,380 --> 01:08:50,670
>> Kõik need puudujäägid on 32 peale.

1397
01:08:50,670 --> 01:08:54,450
Nüüd tundub see võimaldab meil
midagi nagu Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
või Google Docs funktsioon, kus te
saab valida kõike ja siis öelda,

1399
01:08:57,729 --> 01:09:00,520
muuta kõik väiketähed või
muuta kõik suurtähtedega,

1400
01:09:00,520 --> 01:09:03,840
või muuta ainult ühe sõna
Lause suurtähtedesse.

1401
01:09:03,840 --> 01:09:07,390
Me ei saa tegelikult midagi
niimoodi ise.

1402
01:09:07,390 --> 01:09:12,645
>> Lubage mul minna ja salvestada faili
siin nimetatakse ära 0.c.

1403
01:09:12,645 --> 01:09:15,770
Ja olgem minna ja klopsima programmi
et just selline järgmiselt.

1404
01:09:15,770 --> 01:09:18,460
Nii hõlmavad CS50 raamatukogu.

1405
01:09:18,460 --> 01:09:21,430
Ja hulka standard I / O.

1406
01:09:21,430 --> 01:09:22,787
>> Ja ma tean, et see on tulemas.

1407
01:09:22,787 --> 01:09:24,870
Nii et ma lähen pane see
seal juba, string,

1408
01:09:24,870 --> 01:09:26,960
nii et mul on juurdepääs
asjad Stirling,

1409
01:09:26,960 --> 01:09:29,620
ja siis int main void, nagu tavaliselt.

1410
01:09:29,620 --> 01:09:33,420
Ja siis ma lähen edasi minna
ja teha stringid saab saada string,

1411
01:09:33,420 --> 01:09:35,032
lihtsalt saada string kasutaja.

1412
01:09:35,032 --> 01:09:36,740
Ja siis ma lähen
teen meelerahu kontrolli.

1413
01:09:36,740 --> 01:09:40,510
Kui string ei võrdu null,
siis see on ohutu sõita.

1414
01:09:40,510 --> 01:09:42,000
Ja mida ma tahan teha?

1415
01:09:42,000 --> 01:09:48,700
Ma lähen itereerima alates i võrdub 0,
ja n kuni stringi pikkus s.

1416
01:09:48,700 --> 01:09:51,899
>> Ja ma teen seda nii kaua, kui
i on väiksem kui n ja i pluss pluss.

1417
01:09:51,899 --> 01:09:55,060
Siiani ma olen tõesti lihtsalt
laenates ideid enne.

1418
01:09:55,060 --> 01:09:57,010
Ja nüüd ma lähen tutvustada filiaal.

1419
01:09:57,010 --> 01:09:59,635
>> Nii arvan, et tagasi Scratch, kus
meil oli neid kahvlid maantee,

1420
01:09:59,635 --> 01:10:05,110
ja eelmisel nädalal C. ma lähen
ütlen seda, kui i-nda tegelaskuju s

1421
01:10:05,110 --> 01:10:09,250
on suurem või
võrdne alandada juhul,

1422
01:10:09,250 --> 01:10:13,340
Ja-- Scratch teil oleks sõna otseses mõttes
öelda ja, kuid C ütled ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- ja i-nda tegelaskuju s
on väiksem või võrdne väiketähtedesse z,

1424
01:10:19,830 --> 01:10:21,780
teeme midagi huvitavat.

1425
01:10:21,780 --> 01:10:27,020
Olgem tegelikult välja trükkida
sümbol ei reavahetus

1426
01:10:27,020 --> 01:10:31,760
mis on märk String,
i-nda tegelaskuju string.

1427
01:10:31,760 --> 01:10:37,420
>> Aga lähme edasi ja
lahutama 32 ta.

1428
01:10:37,420 --> 01:10:42,120
Või kui märk
string et ootame

1429
01:10:42,120 --> 01:10:45,950
ei ole vahel pisuke
ja vähe z, edasi minna

1430
01:10:45,950 --> 01:10:48,610
ja lihtsalt trükitud seda muutmata.

1431
01:10:48,610 --> 01:10:50,840
Nii oleme kasutusele
see sulgudes märge

1432
01:10:50,840 --> 01:10:53,560
meie stringid saada on
i-nda tegelaskuju string.

1433
01:10:53,560 --> 01:10:57,520
>> Olen lisanud mõned tingimisi loogika, nagu
Scratch eelmisel nädalal nädalas üks, kus

1434
01:10:57,520 --> 01:10:59,880
Ma lihtsalt kasutades oma põhiõigusi
arusaam sellest, mis on

1435
01:10:59,880 --> 01:11:01,130
toimub all kapuuts.

1436
01:11:01,130 --> 01:11:04,190
Kas i-nda iseloomu s
suurem või võrdne?

1437
01:11:04,190 --> 01:11:08,290
Nagu, see on 97 või 98,
või 99, ja nii edasi?

1438
01:11:08,290 --> 01:11:11,940
>> Aga see ka väiksem või võrdne
väärtusega väiketähed z?

1439
01:11:11,940 --> 01:11:16,210
Ja kui nii, siis mida see rida tähendab?

1440
01:11:16,210 --> 01:11:20,250
14, see on omamoodi
idu kogu idee,

1441
01:11:20,250 --> 01:11:23,840
ära kirja teel
lihtsalt lahutades 32 sellest,

1442
01:11:23,840 --> 01:11:29,370
sel juhul, sest ma tean, per et
skeem, kuidas minu numbrid on esindatud.

1443
01:11:29,370 --> 01:11:33,925
Nii saab minna ja käivitada,
pärast koostamisel ära 0.c,

1444
01:11:33,925 --> 01:11:36,210
ja joosta ära 0.

1445
01:11:36,210 --> 01:11:40,300
>> Olgem kirjuta midagi
Zamyla kõik väiketähed sisestada.

1446
01:11:40,300 --> 01:11:42,780
Ja nüüd on meil Zamyla kõigis suur-.

1447
01:11:42,780 --> 01:11:45,050
Olgem kirjuta Rob kõik väiketähed.

1448
01:11:45,050 --> 01:11:46,674
Proovime Jason väiketähtedega.

1449
01:11:46,674 --> 01:11:48,590
Ja me hoiame saada
sunnitud kapitaliseeritust.

1450
01:11:48,590 --> 01:11:50,960
Seal on väike viga, et ma
Selline ei osatud ette näha.

1451
01:11:50,960 --> 01:11:54,050
Pane tähele minu uus kiire on lõpetades
samal joonel nende nimed,

1452
01:11:54,050 --> 01:11:55,520
mis tundub natuke segane.

1453
01:11:55,520 --> 01:11:59,170
>> Nii et ma lähen siin, ja
tegelikult lõpul selle programmi

1454
01:11:59,170 --> 01:12:02,110
prindi välja reavahetuse märk.

1455
01:12:02,110 --> 01:12:03,160
See on kõik.

1456
01:12:03,160 --> 01:12:06,120
Mis printf, siis ei pea
liigu muutujate või formaadis koodi.

1457
01:12:06,120 --> 01:12:08,460
Võid sõna otseses mõttes lihtsalt printida
midagi reavahetus.

1458
01:12:08,460 --> 01:12:13,529
>> Nii saab minna ja teha
ära 0 uuesti, uuesti, see, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
Ja nüüd on see natuke ilusam.

1460
01:12:14,820 --> 01:12:17,274
Nüüd, minu kiire on omal uus liin.

1461
01:12:17,274 --> 01:12:18,440
Nii et kõik on hästi ja hea.

1462
01:12:18,440 --> 01:12:19,910
Nii et see on hea näide.

1463
01:12:19,910 --> 01:12:22,700
Aga ma isegi ei pruugi
vaja kõvasti kood 32.

1464
01:12:22,700 --> 01:12:23,350
Tead mida?

1465
01:12:23,350 --> 01:12:26,350
Ma võiks say-- Ma ei ole kunagi
mäleta, mis vahe on.

1466
01:12:26,350 --> 01:12:29,330
>> Aga ma tean, et kui ma
on väiketäht,

1467
01:12:29,330 --> 01:12:34,430
Ma põhimõtteliselt taha lahutada maha
olenemata vahemaa on väike

1468
01:12:34,430 --> 01:12:39,160
A ja suur, sest kui ma eeldan, et
kõik teised tähte on samad,

1469
01:12:39,160 --> 01:12:41,045
mis peaks tööd teha.

1470
01:12:41,045 --> 01:12:42,670
Aga mitte seda teha, sa tead, mida?

1471
01:12:42,670 --> 01:12:44,240
Seal on veel üks võimalus veel.

1472
01:12:44,240 --> 01:12:48,090
>> Kui seda ära 1.c-- kui ma
panna, et eraldi faili.

1473
01:12:48,090 --> 01:12:51,030
Teeme ära 2.c järgmiselt.

1474
01:12:51,030 --> 01:12:53,060
Ma tõesti puhastada seda siin.

1475
01:12:53,060 --> 01:12:57,420
Ja selle asemel, et isegi võttes
tea või hoolivad neile madal

1476
01:12:57,420 --> 01:13:01,090
rakendamise üksikasju, ma olen selle asemel
lihtsalt läheb print iseloomu,

1477
01:13:01,090 --> 01:13:04,610
tsitaat lõppeb, protsendi C ja
siis helista teine ​​funktsioon, mis

1478
01:13:04,610 --> 01:13:09,950
olemas, mis võtab argumendiks,
mis on märk, niimoodi.

1479
01:13:09,950 --> 01:13:12,630
>> Selgub, C, seal on
teine ​​funktsioon kõne

1480
01:13:12,630 --> 01:13:15,550
ülemiste, mis nagu nimigi
soovitab võtab iseloomu

1481
01:13:15,550 --> 01:13:19,350
ja teeb oma suur-
samaväärne, ning tagastab

1482
01:13:19,350 --> 01:13:21,410
nii et printf saab ühendage see seal.

1483
01:13:21,410 --> 01:13:25,484
Ja nii, et seda teha, aga ma
vaja kehtestada ühe teise faili.

1484
01:13:25,484 --> 01:13:28,400
Selgub, et on veel üks fail
et siis oleks ainult teada, klass,

1485
01:13:28,400 --> 01:13:33,020
või õpik või online
viide, mida nimetatakse C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Nii et kui ma lisan, et kuni üks minu päise kaudu
faile, ja nüüd uuesti kompileerida selle programmi

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Olgem kirjuta Zamyla kõik
väiketähed, töötab sama.

1489
01:13:46,690 --> 01:13:48,040
Aga tead mis?

1490
01:13:48,040 --> 01:13:55,590
Selgub, et ülemiste
on mõned muud funktsioonid.

1491
01:13:55,590 --> 01:13:58,410
>> Ja lubage mul tutvustada selle
käsin siin mingi kohmakalt

1492
01:13:58,410 --> 01:14:00,250
nimed, kuid mees käsitsi.

1493
01:14:00,250 --> 01:14:03,960
Selgub, et kõige Linux arvuteid,
kui me kasutame siin-- Linux operatsioonisüsteemi

1494
01:14:03,960 --> 01:14:06,270
süsteemis endale valda
nimetatakse meest, mis ütleb,

1495
01:14:06,270 --> 01:14:08,530
hei, arvuti, anna mulle
arvuti kasutusjuhendist.

1496
01:14:08,530 --> 01:14:10,680
Mida sa tahad
otsida, et käsitsi?

1497
01:14:10,680 --> 01:14:13,840
>> Tahan otsida funktsiooni
kutsutud ülemine, Enter.

1498
01:14:13,840 --> 01:14:16,070
Ja see on natuke segasena
loe mõnikord.

1499
01:14:16,070 --> 01:14:18,780
Aga märka me ka
Linux programmeerija käsitsi.

1500
01:14:18,780 --> 01:14:19,530
Ja see on kõik teksti.

1501
01:14:19,530 --> 01:14:21,905
Ja märgata, et seal on
funktsiooni nimi siia üles.

1502
01:14:21,905 --> 01:14:25,030
Selgub, ta on sugulane nimega
alandada, mis teeb vastupidist.

1503
01:14:25,030 --> 01:14:29,710
Ja teate all sünopsis, et kasutada seda
toimida mees lehel, nii et rääkida,

1504
01:14:29,710 --> 01:14:32,220
räägib mulle, et ma
vaja lisada c type.h.

1505
01:14:32,220 --> 01:14:33,630
Ja ma teadsin, et praktikast.

1506
01:14:33,630 --> 01:14:36,210
>> Siin, see näitab mulle kahe
prototüüpide funktsiooni

1507
01:14:36,210 --> 01:14:39,070
nii et kui ma kunagi soovi seda
Ma tean, mida nad võtavad sisendiks

1508
01:14:39,070 --> 01:14:40,652
ja mida nad tagasi väljundiks.

1509
01:14:40,652 --> 01:14:42,360
Ja kui siis lugesin
kirjeldamise, ma näen

1510
01:14:42,360 --> 01:14:44,820
täpsem funktsioon teeb.

1511
01:14:44,820 --> 01:14:48,100
Kuid mis veelgi tähtsam, kui
Ma vaatan alla tagastatav väärtus,

1512
01:14:48,100 --> 01:14:51,710
ta ütleb väärtus tagastatakse on
mis on ümber kirjas,

1513
01:14:51,710 --> 01:14:57,880
või C, originaal sisend, kui
konverteerimise ei olnud võimalik.

1514
01:14:57,880 --> 01:15:01,992
>> Teisisõnu, ülemise püüab
teisendada kirja suurtähtedega.

1515
01:15:01,992 --> 01:15:03,450
Ja kui nii, siis läheb see tagasi.

1516
01:15:03,450 --> 01:15:07,010
Aga kui seda ei saa mingil reason--
äkki see on juba suurtäht,

1517
01:15:07,010 --> 01:15:09,550
võibolla on hüüumärk
või mõne muu punctuation--

1518
01:15:09,550 --> 01:15:12,200
see on lihtsalt läheb
tagasi algse C,

1519
01:15:12,200 --> 01:15:17,340
mis tähendab Saan koodi
parem disainiti järgmiselt.

1520
01:15:17,340 --> 01:15:20,580
>> Ma ei pea kõiki
Nende paganama rida koodi.

1521
01:15:20,580 --> 01:15:22,610
Kõik read Olen
lihtsalt esile ei

1522
01:15:22,610 --> 01:15:28,700
kokku tõmmata vaid üks lihtne
line, mis on see-- printf protsenti

1523
01:15:28,700 --> 01:15:33,510
c ülemiste S sulg i.

1524
01:15:33,510 --> 01:15:36,090
Ja see oleks
Näiteks parema disainiga.

1525
01:15:36,090 --> 01:15:40,040
>> Miks rakendama 7 või 8 rida
koodi, mis iganes see oli mul lihtsalt

1526
01:15:40,040 --> 01:15:44,960
kustutada, kui sa saad selle asemel variseda
kõik selle loogika ja otsuste tegemisel

1527
01:15:44,960 --> 01:15:49,620
ühte rida, 13 nüüd, et
toetub raamatukogu funktsioon--

1528
01:15:49,620 --> 01:15:53,430
funktsioon, mis on varustatud C, kuid see
ei täpselt, mida sa tahad seda teha.

1529
01:15:53,430 --> 01:15:55,295
Ja ausalt öeldes, isegi kui
see ei tulnud C,

1530
01:15:55,295 --> 01:15:58,880
siis võiks rakendada seda ise, kui
oleme näinud, kus saan negatiivse int

1531
01:15:58,880 --> 01:16:01,700
ja saada positiivne int eelmisel nädalal samuti.

1532
01:16:01,700 --> 01:16:03,470
>> See kood on praegu palju paremini arusaadavaks.

1533
01:16:03,470 --> 01:16:06,670
Ja tõepoolest, kui me üleskerimiseks
vaata kui palju kompaktsem

1534
01:16:06,670 --> 01:16:08,360
Selle versiooni minu programm on.

1535
01:16:08,360 --> 01:16:11,230
See on veidi tsentraliseeritud nüüd,
kõik need kuuluvad.

1536
01:16:11,230 --> 01:16:14,380
Aga see on OK, sest nüüd olengi
õlgadele programmeerijad

1537
01:16:14,380 --> 01:16:15,300
enne mind.

1538
01:16:15,300 --> 01:16:18,440
Ja kes see oli, kes
rakendatud ülemise tõesti

1539
01:16:18,440 --> 01:16:21,470
tegi mulle teene, meelega iganes
rakendatud Stirling tõesti

1540
01:16:21,470 --> 01:16:24,790
tegi mulle teene mõni aeg tagasi.

1541
01:16:24,790 --> 01:16:26,970
Ja nii nüüd on meil
parem disain programm

1542
01:16:26,970 --> 01:16:31,680
mis rakendab täpselt sama loogika.

1543
01:16:31,680 --> 01:16:35,580
>> Rääkides Stirling, las
mul minna ja seda teha.

1544
01:16:35,580 --> 01:16:38,320
Lubage mul minna ja päästa
see pilt stirling.c.

1545
01:16:38,320 --> 01:16:43,255
Ja selgub, saame koorida tagasi
üks teine ​​kiht päris lihtsalt nüüd.

1546
01:16:43,255 --> 01:16:45,630
Ma lähen edasi minna ja piits
kuni teise programmi peamine

1547
01:16:45,630 --> 01:16:49,759
siin, et lihtsalt uuesti rakendab
string pikkusega järgmiselt.

1548
01:16:49,759 --> 01:16:52,300
Nii et siin on rida koodi, mis
saab mind string kasutaja.

1549
01:16:52,300 --> 01:16:53,910
Hoiame kasutades seda ikka ja jälle.

1550
01:16:53,910 --> 01:16:58,900
Annan endale muutuja nimega
n-tüüpi int, mis talletab number.

1551
01:16:58,900 --> 01:17:02,490
>> Ja las ma minna ja
teha järgmist loogikat.

1552
01:17:02,490 --> 01:17:15,610
Kuigi n-nda tegelaskuju s teeb
ei võrdu backslash 0, edasi minna

1553
01:17:15,610 --> 01:17:17,930
ja juurdekasvu n.

1554
01:17:17,930 --> 01:17:23,506
Ja siis välja printida printf protsenti i n.

1555
01:17:23,506 --> 01:17:29,200
Väidan, et see programm siin,
kutsumata string pikkusega,

1556
01:17:29,200 --> 01:17:31,150
arvud, pikkus string.

1557
01:17:31,150 --> 01:17:34,600
>> Ja magic on täiesti
kapseldatud rida 8

1558
01:17:34,600 --> 01:17:39,830
siin sellega, mis näeb välja nagu uus süntaks,
See backslash 0 ülakoma.

1559
01:17:39,830 --> 01:17:41,360
Aga miks see nii on?

1560
01:17:41,360 --> 01:17:44,100
Noh, kaaluma, mida on olnud
toimub kogu aeg.

1561
01:17:44,100 --> 01:17:47,990
>> Ja kui kõrvale, enne kui ma unustan, mõistad
ka, et lisaks manuaalilehekülgedest

1562
01:17:47,990 --> 01:17:50,920
et tulla tüüpiline
Linux nagu CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
aru, et meie,
Muidugi töötajad, on ka

1564
01:17:53,770 --> 01:17:56,030
teinud veebileht versioon
Selle sama mõte nimetatakse

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, mis on
kõik need samad man-lehekülgi,

1566
01:17:59,940 --> 01:18:02,020
kõik sama
dokumentatsiooni, samuti

1567
01:18:02,020 --> 01:18:05,730
natuke ülaosas, mis võimaldab
teisendada kõik üsna

1568
01:18:05,730 --> 01:18:09,025
kauge keelde ebamugavamate
režiim, kus me, õppejõudude,

1569
01:18:09,025 --> 01:18:12,150
läbi käinud ja püüdnud lihtsustada
mõned keele hoida asjad

1570
01:18:12,150 --> 01:18:14,830
keskendunud ideid, mitte
mõned tehnilised.

1571
01:18:14,830 --> 01:18:20,070
Nii meeles pidada, reference.cs50.net
teise ressursi samuti.

1572
01:18:20,070 --> 01:18:23,800
>> Aga miks ei string pikkusega töö
Muide Tegin hetk tagasi?

1573
01:18:23,800 --> 01:18:25,160
Siin Zamyla nime uuesti.

1574
01:18:25,160 --> 01:18:27,690
Ja siin on Zamyla nimi
pakendada, nagu ma hoida teed,

1575
01:18:27,690 --> 01:18:31,360
et maalida seda on,
tõesti, lihtsalt märgijada.

1576
01:18:31,360 --> 01:18:34,260
Aga Zamyla ei ole olemas
eraldi programmis.

1577
01:18:34,260 --> 01:18:37,420
>> Kui sa kirjutada ja käivitada programmi
te kasutate Mac või arvuti

1578
01:18:37,420 --> 01:18:40,010
mälu, või RAM nii rääkida.

1579
01:18:40,010 --> 01:18:42,620
Ja sa ei mõtle
arvuti, millel

1580
01:18:42,620 --> 01:18:44,730
palju gigabaiti mälu nendel päevadel.

1581
01:18:44,730 --> 01:18:47,700
Ja kaarik tähendab miljardeid
nii miljardeid baiti.

1582
01:18:47,700 --> 01:18:48,910
>> Kuid olgem kerida ajas.

1583
01:18:48,910 --> 01:18:51,530
Ja oletame, et me kasutame
tõesti vana arvuti, mis

1584
01:18:51,530 --> 01:18:55,150
ainult 32 baiti mälu.

1585
01:18:55,150 --> 01:18:59,310
Ma võiks minu arvuti ekraanil,
lihtsalt juhtida seda läbi järgmiselt.

1586
01:18:59,310 --> 01:19:05,240
>> Ma võiks lihtsalt öelda, et minu
arvutis on kõik see mälu.

1587
01:19:05,240 --> 01:19:08,830
Ja see on nagu pulk mälu, kui
te mäletate meie pilt viimast korda.

1588
01:19:08,830 --> 01:19:11,670
Ja kui ma lihtsalt jagada
seda piisavalt korda,

1589
01:19:11,670 --> 01:19:15,040
Väidan, et mul on 32 baiti
mälu ekraanil.

1590
01:19:15,040 --> 01:19:18,239
>> Nüüd, tegelikult võin ainult
juhtida seni seda ekraani siin.

1591
01:19:18,239 --> 01:19:20,280
Nii et ma lähen edasi minna,
ja lihtsalt kokkuleppeline

1592
01:19:20,280 --> 01:19:24,050
juhtida oma arvuti mälus kui
võrku, mitte ainult ühe sirge.

1593
01:19:24,050 --> 01:19:28,190
Nimelt ma väita, et nüüd,
See võre, see 8 4 võrku

1594
01:19:28,190 --> 01:19:31,800
lihtsalt esindab kõiki 32 baiti
vaba mälu minu Mac,

1595
01:19:31,800 --> 01:19:33,030
või saadaval minu arvuti.

1596
01:19:33,030 --> 01:19:34,780
Ja nad ümbriste
edasi kaks rida, vaid

1597
01:19:34,780 --> 01:19:38,030
sest see sobib rohkem ekraanil.

1598
01:19:38,030 --> 01:19:40,800
Aga see on esimene bait.

1599
01:19:40,800 --> 01:19:41,990
See on teine ​​bait.

1600
01:19:41,990 --> 01:19:43,300
See on kolmas bait.

1601
01:19:43,300 --> 01:19:45,310
>> Ja see on 32. bait.

1602
01:19:45,310 --> 01:19:52,910
Või kui me arvame, nagu arvuti
teadlane, see on bait 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Nii on 0 kuni 31, kui
hakkate lugedes 0.

1604
01:19:55,950 --> 01:19:59,830
>> Nii et kui me kasutame programmi
et kõned saada string,

1605
01:19:59,830 --> 01:20:05,280
ja saame stringi inimese
nagu ma nimega Zamyla, Z-A-M-Y-L-A

1606
01:20:05,280 --> 01:20:09,430
kuidas maailmas teeb
arvuti jälgida, millist bait,

1607
01:20:09,430 --> 01:20:12,230
mis patakas mälu,
kuulub mille string?

1608
01:20:12,230 --> 01:20:16,270
Teisisõnu, kui me suunduda
kirjuta teise nime arvutisse,

1609
01:20:16,270 --> 01:20:19,890
niimoodi Andi, kutsudes
saada string teist korda

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I on sattuda
arvuti mälu samuti.

1611
01:20:23,030 --> 01:20:23,850
Aga kuidas?

1612
01:20:23,850 --> 01:20:29,700
>> Noh, selgub, et all
hood, mida C teeb, kui stringide salvestamiseks

1613
01:20:29,700 --> 01:20:35,080
et inimese liigid, või et
tulevad mõnest muust allikast, on see

1614
01:20:35,080 --> 01:20:39,190
delineates lõppu neile
eriline character-- backslash

1615
01:20:39,190 --> 01:20:44,750
0, mis on just erilisel moel
öelda 80 bitti järjest.

1616
01:20:44,750 --> 01:20:47,950
>> Nii a-- see on number 97 tagasivõtmist.

1617
01:20:47,950 --> 01:20:51,770
Nii mõned muster 8 bitti
esindab kümnendnumbrina 97.

1618
01:20:51,770 --> 01:20:58,070
See backslash 0 on sõna otseses mõttes arv
0 teise nimega Nul, N-U-L, erinevalt varem

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, mis me rääkisime.

1620
01:20:59,630 --> 01:21:05,700
Aga nüüd, lihtsalt tean, et see
backslash 0 on ainult 80 bitti järjest.

1621
01:21:05,700 --> 01:21:09,810
>> Ja see on lihtsalt see joon
liiva, mis ütleb midagi vasakule

1622
01:21:09,810 --> 01:21:12,610
kuulub üks string, või ühe andmetüübi.

1623
01:21:12,610 --> 01:21:15,480
Ja midagi õige
kuulub midagi muud.

1624
01:21:15,480 --> 01:21:17,440
Andi nime, vahepeal
mis lihtsalt visuaalselt

1625
01:21:17,440 --> 01:21:21,310
juhtub murrab edasi teistele line,
aga see on ainult esteetiline detail,

1626
01:21:21,310 --> 01:21:23,990
Samamoodi on Nul lõpetada.

1627
01:21:23,990 --> 01:21:29,290
>> See on stringi A-N-D-I märki,
lisaks viies salajase iseloomu,

1628
01:21:29,290 --> 01:21:33,560
kõik 0 bitti, et lihtsalt piiritleb
lõpuks Andi nime ka.

1629
01:21:33,560 --> 01:21:37,120
Ja kui me nimetame saada string kolmandat korda
arvuti saada string nagu

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, sarnaselt on Maria
nimi Nul lõpetada backslash 0.

1631
01:21:44,210 --> 01:21:47,170
>> See on täiesti erinev
sellest, kuidas arvuti on tavaliselt

1632
01:21:47,170 --> 01:21:51,850
talletada täisarv või sularahaga või muu
andmetüübid ikka, sest turult,

1633
01:21:51,850 --> 01:21:57,420
täisarv on tavaliselt 32 bitti või
4 baiti, või isegi 64 bitti,

1634
01:21:57,420 --> 01:21:59,100
või kaheksa baiti.

1635
01:21:59,100 --> 01:22:02,620
Kuid paljud primitiivide arvutis
programmeerimiskeelt

1636
01:22:02,620 --> 01:22:05,550
on kindel arv
baiti all hood--

1637
01:22:05,550 --> 01:22:08,100
võibolla 1, võibolla 2, võibolla 4, võibolla 8.

1638
01:22:08,100 --> 01:22:13,250
>> Aga stringid, mille konstruktsioon, on
dünaamiline arvu märke.

1639
01:22:13,250 --> 01:22:16,980
Sa ei tea ette, kuni
Inimese liigid Z-A-M-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
või M-A-R-I-A või A-N-D-I. Sa ei tea
mitu korda kasutaja saab löögi

1641
01:22:21,400 --> 01:22:22,070
klaviatuuri.

1642
01:22:22,070 --> 01:22:26,490
Seega, sa ei tea, kuidas
palju märke ette

1643
01:22:26,490 --> 01:22:27,540
sa lähed vaja.

1644
01:22:27,540 --> 01:22:31,840
>> Ja nii C lihtsalt selline jätab nagu
saladus riivsai all kapuuts

1645
01:22:31,840 --> 01:22:32,960
lõpus stringi.

1646
01:22:32,960 --> 01:22:39,280
Pärast ladustamiseks Z-A-M-Y-L-A mälust
Samuti lihtsalt paneb samaväärne

1647
01:22:39,280 --> 01:22:40,210
perioodi.

1648
01:22:40,210 --> 01:22:45,060
Lõpus lause,
see paneb 80 bitti, nii

1649
01:22:45,060 --> 01:22:49,120
meeles pidada, kus
Zamyla algab ja lõpeb.

1650
01:22:49,120 --> 01:22:51,490
>> Mis siis ühendus
siis, et see programm?

1651
01:22:51,490 --> 01:22:55,190
See programm siin, Stirling,
on lihtsalt mehhanism

1652
01:22:55,190 --> 01:22:57,970
saada string
kasutaja, rida 6.

1653
01:22:57,970 --> 01:23:01,160
Line 7, ma kuulutada muutuja
nimetatakse n ja seada see võrdub 0.

1654
01:23:01,160 --> 01:23:08,680
>> Ja siis vastavalt 8, ma lihtsalt küsis
küsimus, samas kui n-nda tegelane teeb

1655
01:23:08,680 --> 01:23:12,120
ei ole võrdsed kõik 0 bits--
teisisõnu ei

1656
01:23:12,120 --> 01:23:14,500
võrdub see eriline
iseloomu, backslash 0, mis

1657
01:23:14,500 --> 01:23:18,470
oli lihtsalt, et erilist Nul character--
minna ja lihtsalt juurdekasvu n.

1658
01:23:18,470 --> 01:23:21,460
>> Ja hoida teeme seda ja hoida
tee seda, ja hoida seda teevad.

1659
01:23:21,460 --> 01:23:23,430
Ja nii kuigi
Varem oleme kasutanud i,

1660
01:23:23,430 --> 01:23:25,181
see on täiesti trahvi
semantiliselt kasutada n,

1661
01:23:25,181 --> 01:23:27,430
kui sa püüad lihtsalt
loota seekord teadlikult,

1662
01:23:27,430 --> 01:23:28,720
ja tahan seda kutsuda n.

1663
01:23:28,720 --> 01:23:34,720
Nii see lihtsalt hoiab küsib küsimuse,
on n-nda iseloomu s kõik 0.?

1664
01:23:34,720 --> 01:23:38,470
Kui ei, siis vaadatakse järgmist ilme,
vaatame edasi, vaatame järgmisel,

1665
01:23:38,470 --> 01:23:39,460
vaadatakse järgmist.

1666
01:23:39,460 --> 01:23:45,540
>> Aga niipea, kui sa näed backslash 0,
See loop-- line 9 kuni 11-- peatub.

1667
01:23:45,540 --> 01:23:49,640
Sa murda samas silmus,
jättes sees, et muutuja n

1668
01:23:49,640 --> 01:23:54,530
Total count Kõike
märkide jada nägid,

1669
01:23:54,530 --> 01:23:55,660
seeläbi lasta välja trükkida.

1670
01:23:55,660 --> 01:23:56,760
Nii proovime seda.

1671
01:23:56,760 --> 01:23:59,500
>> Lubage mul minna ja ilma
abil Stirling funktsiooni

1672
01:23:59,500 --> 01:24:04,240
aga lihtsalt kasutades oma kodumaine versioon
siin nimetatakse Stirling, lubage mul minna

1673
01:24:04,240 --> 01:24:07,700
ja joosta Stirling, kirjuta midagi
nagu Zamyla, mida ma tean ette

1674
01:24:07,700 --> 01:24:08,670
on kuus tähemärki.

1675
01:24:08,670 --> 01:24:10,080
Vaatame, kas see toimib.

1676
01:24:10,080 --> 01:24:10,920
Tõepoolest, see on kuus.

1677
01:24:10,920 --> 01:24:15,257
Proovime koos Rob, kolm märki,
kolm märki ka, ja nii edasi.

1678
01:24:15,257 --> 01:24:17,340
Nii et kõik, mis läheb
kohta all kapuuts.

1679
01:24:17,340 --> 01:24:19,548
Ja märgata seoseid,
Seejärel, esimese nädala

1680
01:24:19,548 --> 01:24:22,370
klassi, kus me rääkisime
midagi võtmiseks,

1681
01:24:22,370 --> 01:24:26,960
mis on just see kihilisus ideede või
keerukust, peal põhimõtteid.

1682
01:24:26,960 --> 01:24:30,710
Siin me oleme omamoodi vaadates
all kapuuts Stirling,

1683
01:24:30,710 --> 01:24:33,510
niiöelda, et aru saada,
kuidas oleks seda rakendatakse?

1684
01:24:33,510 --> 01:24:35,232
>> Ja me võiks uuesti rakendada ise.

1685
01:24:35,232 --> 01:24:37,440
Aga me kunagi läheb
uuesti rakendada Stirling.

1686
01:24:37,440 --> 01:24:39,780
Me lihtsalt läheb
kasuta Stirling, et

1687
01:24:39,780 --> 01:24:42,100
tegelikult saada mõned stringid pikkus.

1688
01:24:42,100 --> 01:24:44,200
>> Aga seal ei ole magic
all kapuuts.

1689
01:24:44,200 --> 01:24:46,716
Kui tead, et all
Kapoti string

1690
01:24:46,716 --> 01:24:48,090
on lihtsalt märgijada.

1691
01:24:48,090 --> 01:24:51,090
Ja see märgijada
kõik on võimalik arvuliselt adresseeritud

1692
01:24:51,090 --> 01:24:53,330
sulg 0, sulg
1, sulg 2, ja te

1693
01:24:53,330 --> 01:24:57,420
tean, et lõpus string on
erilist iseloomu, saate aru saada

1694
01:24:57,420 --> 01:25:01,710
kuidas seda teha kõige midagi on
programmi, sest kõik taandub

1695
01:25:01,710 --> 01:25:03,400
on lugemine ja kirjutamine mälu.

1696
01:25:03,400 --> 01:25:06,130
See tähendab, et muutuvas ja otsin
kell mälu, või liigub asju

1697
01:25:06,130 --> 01:25:10,940
ringi mälu, trükkimine asju
ekraanil, ja nii edasi.

1698
01:25:10,940 --> 01:25:14,800
>> Nii saab nüüd kasutada seda taasleitud
arusaam sellest, mida stringid tegelikult

1699
01:25:14,800 --> 01:25:17,910
on all kapuuts, ja
koorida tagasi üks teine ​​kiht

1700
01:25:17,910 --> 01:25:20,080
et seni me oleme
olnud ignoreerides täielikult.

1701
01:25:20,080 --> 01:25:22,650
Eelkõige igal ajal
oleme rakendanud programmi

1702
01:25:22,650 --> 01:25:25,930
oleme olnud seda rida koodi
ülaosas kuulutatakse peamine.

1703
01:25:25,930 --> 01:25:27,810
Ja me oleme määratud int main void.

1704
01:25:27,810 --> 01:25:31,240
>> Ja see tühine sulgude sees
on öelnud kõik see aeg, et peamine

1705
01:25:31,240 --> 01:25:33,440
ise ei võta mingeid argumente.

1706
01:25:33,440 --> 01:25:36,210
Iga sisend, et peamine on
hakka kasutaja

1707
01:25:36,210 --> 01:25:39,020
peab tulema mõnest muust
mehhanism, nagu get int,

1708
01:25:39,020 --> 01:25:42,040
või saada float või saada string,
või mõni muu funktsioon.

1709
01:25:42,040 --> 01:25:44,710
Aga selgub, et
kui sa kirjutada programm,

1710
01:25:44,710 --> 01:25:47,690
saab tegelikult määrata
et nimetatud programm

1711
01:25:47,690 --> 01:25:51,730
võtta sisendeid inimese
käsurea ise.

1712
01:25:51,730 --> 01:25:56,310
>> Teisisõnu, kuigi me siiani
käinud lihtsalt ./hello tere

1713
01:25:56,310 --> 01:26:00,312
või sarnased programmid, kõik
muud programmid, mis me oleme kasutanud,

1714
01:26:00,312 --> 01:26:02,770
et me ise ei kirjuta,
on võtnud, tundub,

1715
01:26:02,770 --> 01:26:05,210
käsurea arguments--
asju nagu make.

1716
01:26:05,210 --> 01:26:07,450
Sa ütled midagi teha,
ja siis teine ​​sõna.

1717
01:26:07,450 --> 01:26:10,950
Või clang, ütlete kolisevad ja seejärel
teine ​​sõna on faili nime.

1718
01:26:10,950 --> 01:26:14,410
>> Või isegi RM või CP, nagu võite
näinud või kasutada juba

1719
01:26:14,410 --> 01:26:15,880
eemaldada või kopeerida.

1720
01:26:15,880 --> 01:26:18,920
Kõik need võtta nn
käsurea arguments--

1721
01:26:18,920 --> 01:26:21,130
lisasõnadega terminali kiire.

1722
01:26:21,130 --> 01:26:23,260
Aga siiani oleme
ise ei ole olnud

1723
01:26:23,260 --> 01:26:27,080
seda luksust võtta panus
kasutajale, kui ta tegelikult töötab

1724
01:26:27,080 --> 01:26:29,120
programm ise käsurea.

1725
01:26:29,120 --> 01:26:33,710
>> Aga me saame teha, et uuesti deklareerides
Peamised liigub edasi, mitte võttes

1726
01:26:33,710 --> 01:26:36,750
kehtetuks sulgudes
aga need kaks argumenti

1727
01:26:36,750 --> 01:26:40,600
instead-- esimene täisarv,
ja teine ​​midagi

1728
01:26:40,600 --> 01:26:44,170
uut, midagi, mida me ei kavatse helistada
massiivi, midagi sarnast vaimu

1729
01:26:44,170 --> 01:26:49,220
mida nägime Scratch loeteluna, kuid
massiivi stringe, nagu me varsti näha.

1730
01:26:49,220 --> 01:26:51,790
Aga vaatame seda
Näitena enne me

1731
01:26:51,790 --> 01:26:53,690
eristada täpselt, mida see tähendab.

1732
01:26:53,690 --> 01:26:56,520
>> Nii et kui ma minema CS50 IDE
Siin ma olen läinud edasi

1733
01:26:56,520 --> 01:27:01,840
ja deklareeritud fail nimega
argv0.c järgmist malli.

1734
01:27:01,840 --> 01:27:04,120
Ja märgata ainus asi
mis on erinev nii kaugele

1735
01:27:04,120 --> 01:27:08,570
on see, et ma olen muutunud tühiseks int
Argc string argv avatud sulg lähedal

1736
01:27:08,570 --> 01:27:09,070
sulg.

1737
01:27:09,070 --> 01:27:11,730
Ja teate nüüd, seal on
midagi sees need sulgudes.

1738
01:27:11,730 --> 01:27:12,620
>> Ei ole number.

1739
01:27:12,620 --> 01:27:15,070
Ja pole mingit i või
n, või mis tahes muu täht.

1740
01:27:15,070 --> 01:27:17,010
Ma lihtsalt abil
nurksulgudes nüüd,

1741
01:27:17,010 --> 01:27:19,510
põhjustel me tuleme
Tagasi vaid hetkeks.

1742
01:27:19,510 --> 01:27:21,330
>> Ja nüüd, mida ma lähen tegema, on see.

1743
01:27:21,330 --> 01:27:26,680
Kui Argc võrdub võrdub 2--
ja meenutada, mis võrdub võrdsete

1744
01:27:26,680 --> 01:27:30,040
on võrdsus operaator võrrelda
vasakule ja paremale võrdõiguslikkuse eest.

1745
01:27:30,040 --> 01:27:31,790
See ei ole loovutamise
operaator, mis on

1746
01:27:31,790 --> 01:27:36,510
ühtse võrdusmärk, mis tähendab, koopia
paremalt vasakule mingi väärtus.

1747
01:27:36,510 --> 01:27:42,840
>> Kui Argc võrdub võrdub 2, ma tahan
ütleme, printf, tere, protsente, uus liin,

1748
01:27:42,840 --> 01:27:47,340
ja seejärel ühendage in-- ja siin on uus
trick-- argv sulg 1 põhjustel

1749
01:27:47,340 --> 01:27:48,840
et me tuleme tagasi hetkel.

1750
01:27:48,840 --> 01:27:52,110
Või kui Argc ei
võrdsed 2, tead mis?

1751
01:27:52,110 --> 01:27:57,400
Lähme edasi ja nagu tavaliselt, print
välja hello world ilma vahetusest.

1752
01:27:57,400 --> 01:28:02,710
>> Nii tundub, et kui Argc, mis
tähistab argument loota, võrdub 2,

1753
01:28:02,710 --> 01:28:04,740
Ma lähen välja printida
tere midagi vms.

1754
01:28:04,740 --> 01:28:07,560
Vastasel juhul vaikimisi, ma olen
trükkimineku tere.

1755
01:28:07,560 --> 01:28:08,770
Mida see tähendab?

1756
01:28:08,770 --> 01:28:15,550
>> Noh, lubage mul minna ja päästa
See fail ja tehke teha argv0,

1757
01:28:15,550 --> 01:28:18,940
ja siis ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
Ja ta ütleb tere.

1759
01:28:20,300 --> 01:28:21,260
Nüüd, miks see nii on?

1760
01:28:21,260 --> 01:28:24,730
>> Noh, selgub millal
programm käivituma käsurealt

1761
01:28:24,730 --> 01:28:29,570
te täitmist, mida jagame
Üldiselt nõuavad argument vektor.

1762
01:28:29,570 --> 01:28:33,100
Teisisõnu automaatselt
arvuti, operatsioonisüsteem,

1763
01:28:33,100 --> 01:28:38,340
läheb käsi oma programmi
ise nimekirja kõigi sõnadega

1764
01:28:38,340 --> 01:28:40,850
et inimese kirjutatud juures
kiire, kui sa

1765
01:28:40,850 --> 01:28:43,790
programmeerija taha teha
midagi, mis infot.

1766
01:28:43,790 --> 01:28:48,540
Ja sel juhul, ainuke sõna
Olen kirjutada käsureale on ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> Ja nii mitu argumenti, mis on
möödutakse minu programm on vaid üks.

1768
01:28:55,420 --> 01:28:58,880
Teisisõnu, argument
loota, muidu tuntud Argc

1769
01:28:58,880 --> 01:29:00,970
siin täisarv, on vaid üks.

1770
01:29:00,970 --> 01:29:03,000
Üks muidugi ei võrdu kaks.

1771
01:29:03,000 --> 01:29:05,980
Ja nii see on, mida prindib, tere.

1772
01:29:05,980 --> 01:29:08,170
>> Aga mulle seda kusagil.

1773
01:29:08,170 --> 01:29:09,930
Ütlen, argv0.

1774
01:29:09,930 --> 01:29:12,740
Ja siis kuidas Maria?

1775
01:29:12,740 --> 01:29:14,990
Ja siis Enter.

1776
01:29:14,990 --> 01:29:18,020
>> Ja pane tähele, mis võluväel juhtub siin.

1777
01:29:18,020 --> 01:29:22,640
Nüüd, selle asemel, et tere, mul on
muutunud käitumist selle programmi

1778
01:29:22,640 --> 01:29:26,310
võttes sisendi mitte get
string või mõne muu funktsiooni,

1779
01:29:26,310 --> 01:29:30,570
kuid ilmselt minu käsu
ise, mida ma algselt sisestatud.

1780
01:29:30,570 --> 01:29:35,720
Ja ma ei saa mängida seda mängu uuesti
see muuta Stelios, näiteks.

1781
01:29:35,720 --> 01:29:38,400
>> Ja nüüd ma näen teise nime ikka.

1782
01:29:38,400 --> 01:29:40,540
Ja siin, ma võin öelda, Andi.

1783
01:29:40,540 --> 01:29:42,137
Ja ma võin öelda, Zamyla.

1784
01:29:42,137 --> 01:29:45,220
Ja me saame mängida seda mängu terve päeva,
lihtsalt ühendades erinevaid väärtusi,

1785
01:29:45,220 --> 01:29:49,550
nii kaua, kui ma ette täpselt
kaks sõna käsureale,

1786
01:29:49,550 --> 01:29:52,260
nii et Argc, minu argument loota, on 2.

1787
01:29:52,260 --> 01:29:57,240
>> Kas ma näen, et nimi ühendatud
printf kohta, see tingimus siin?

1788
01:29:57,240 --> 01:30:00,550
Nii näib, et oleme nüüd
ekspressiivne võime

1789
01:30:00,550 --> 01:30:04,410
võttes sisend teise mehhanismiga,
alates nn käsurea

1790
01:30:04,410 --> 01:30:07,000
selle asemel, et oodata
kuni kasutaja käivitab programmi,

1791
01:30:07,000 --> 01:30:10,220
ja siis küsib tema
kasutades midagi get string.

1792
01:30:10,220 --> 01:30:11,230
>> Mis see on?

1793
01:30:11,230 --> 01:30:15,010
Argc jällegi on lihtsalt täisarv,
arvu words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
et kasutaja osutatakse
kiire, terminali aknas

1795
01:30:18,540 --> 01:30:20,110
sh programmi nimi.

1796
01:30:20,110 --> 01:30:23,340
Nii et meie ./argv0 on tõhusalt,
Programmi nimi,

1797
01:30:23,340 --> 01:30:24,520
või kuidas ma saan programmi.

1798
01:30:24,520 --> 01:30:25,810
>> See loeb sõna.

1799
01:30:25,810 --> 01:30:27,080
Nii Argc oleks 1.

1800
01:30:27,080 --> 01:30:29,750
Aga kui ma kirjutan Stelios või
Andi või Zamyla või Maria,

1801
01:30:29,750 --> 01:30:31,660
see tähendab, et argument arv on kaks.

1802
01:30:31,660 --> 01:30:33,910
Ja nii nüüd on kaks sõna möödunud aastal.

1803
01:30:33,910 --> 01:30:36,070
>> Ja teate, saame jätkata seda loogikat.

1804
01:30:36,070 --> 01:30:39,050
Kui ma tegelikult öelda
midagi Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
täielik nimi, mis kulgeb
kolm argumenti kokku

1806
01:30:42,200 --> 01:30:47,410
nüüd ta ütleb vaikimisi uuesti
sest muidugi 3 ei võrdu 2.

1807
01:30:47,410 --> 01:30:54,080
>> Ja nii sel moel, ma pean
juurdepääsu kaudu argv uue argumendi

1808
01:30:54,080 --> 01:30:56,080
et me võiks tehniliselt
helistada midagi tahame.

1809
01:30:56,080 --> 01:30:58,940
Aga kokkuleppeliselt, see on
argv ja Argc võrra.

1810
01:30:58,940 --> 01:31:04,470
Argv, argument vektor, on selline
sünonüümi jaoks programmeerimine

1811
01:31:04,470 --> 01:31:07,140
funktsiooni C nimetatakse massiivi.

1812
01:31:07,140 --> 01:31:14,410
>> Hulgaliselt on nimekirja sarnased väärtused
tagasi, tagasi, tagasi, edasi-tagasi.

1813
01:31:14,410 --> 01:31:17,810
Teisisõnu, kui üks on siinsamas
RAM, järgmine on õigus selle kõrval

1814
01:31:17,810 --> 01:31:18,800
ja paremale selle kõrval.

1815
01:31:18,800 --> 01:31:20,101
Nad ei ole kogu koht.

1816
01:31:20,101 --> 01:31:23,100
Ja see viimane stsenaarium, kus asjad
on kogu koht mälus,

1817
01:31:23,100 --> 01:31:25,082
võib tegelikult olla võimas.

1818
01:31:25,082 --> 01:31:28,040
Aga tuleme tagasi, et kui me
rääkida Kasvataja andmestruktuurid.

1819
01:31:28,040 --> 01:31:32,260
Praegu massiivi on lihtsalt
patakas sidusmäluplokki,

1820
01:31:32,260 --> 01:31:36,520
iga, mille elemendid on
tagasi, tagasi, tagasi, tagasi,

1821
01:31:36,520 --> 01:31:38,050
ja üldiselt sama tüüpi.

1822
01:31:38,050 --> 01:31:42,630
>> Nii et kui sa arvad, alates
Hetk tagasi, mida on string?

1823
01:31:42,630 --> 01:31:50,460
Noh, string, nagu Zamyla,
Z-A-M-Y-L-A, on tehniliselt

1824
01:31:50,460 --> 01:31:51,400
lihtsalt massiivi.

1825
01:31:51,400 --> 01:31:53,700
See on hulgaliselt märke.

1826
01:31:53,700 --> 01:31:59,250
>> Ja kui me tõesti teha seda, nagu ma
tegid varem, kui patakas mälu,

1827
01:31:59,250 --> 01:32:04,510
Selgub, et kõik need
tegelased kulub bait.

1828
01:32:04,510 --> 01:32:07,630
Ja siis on see eriline
valvur iseloomu, längkriipsu 0,

1829
01:32:07,630 --> 01:32:12,360
või kõik kaheksa 0 bitti, et
piiritleb lõpuks, et string.

1830
01:32:12,360 --> 01:32:15,090
Nii string, selgub
välja, tsiteerida lõppeb string,

1831
01:32:15,090 --> 01:32:20,580
on lihtsalt massiivi chara--
char on tegelik andmetüüp.

1832
01:32:20,580 --> 01:32:24,560
>> Ja nüüd argv, meanwhile--
lähme tagasi programmi.

1833
01:32:24,560 --> 01:32:29,582
Argv, kuigi me näeme sõna
string siin, ei ole string ise.

1834
01:32:29,582 --> 01:32:33,640
Argv, argument vektor,
on massiivi stringe.

1835
01:32:33,640 --> 01:32:37,620
>> Nii nagu sul võib olla mitmeid erinevaid
märki, siis võib olla kõrgem,

1836
01:32:37,620 --> 01:32:46,279
massiivi strings-- nii näiteks
kui ma kirjutada hetk tagasi ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, ruumi Z-A-M-Y-L-A, ma väita, et
argv oli kaks stringid see-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
ja Z-A-M-Y-L-A. sisse
Teisisõnu, Argc oli 2.

1839
01:33:03,185 --> 01:33:03,980
Miks nii?

1840
01:33:03,980 --> 01:33:08,370
>> Noh, tegelikult, mis toimub
kohta on see, et kõik need stringid

1841
01:33:08,370 --> 01:33:13,990
on muidugi hulgaliselt tähemärki
nagu varemgi, mille kõigile tähemärki

1842
01:33:13,990 --> 01:33:15,670
kulub ühe baidi.

1843
01:33:15,670 --> 01:33:19,720
Ja ärge ajage tegelik 0
programmi nimi koos 0,

1844
01:33:19,720 --> 01:33:22,040
mis tähendab kõik 80 bitti.

1845
01:33:22,040 --> 01:33:27,140
Ja Zamyla, vahepeal on veel
Samuti array tähemärki.

1846
01:33:27,140 --> 01:33:31,450
>> Nii lõpus päeval, siis tegelikult
näeb välja selline all kapuuts.

1847
01:33:31,450 --> 01:33:38,800
Aga argv olemuselt kuidas peamine
töid, võimaldab mul murrab kõik see

1848
01:33:38,800 --> 01:33:44,810
üles, kui soovite, suurem massiiv
et kui me veidi üle lihtsustada

1849
01:33:44,810 --> 01:33:48,180
Mis pilt välja näeb ja ei
üsna joonistada skaala seal,

1850
01:33:48,180 --> 01:33:56,720
See massiiv on ainult suurus 2, esimene
element, mis sisaldab string,

1851
01:33:56,720 --> 01:33:59,230
teine ​​osa
mis sisaldab stringi.

1852
01:33:59,230 --> 01:34:01,687
Ja omakorda kui sa
Selline suumida iga

1853
01:34:01,687 --> 01:34:03,770
need stringid, mida
vaata all kapuuts

1854
01:34:03,770 --> 01:34:07,190
on see, et iga string on lihtsalt
array tähemärki.

1855
01:34:07,190 --> 01:34:11,680
>> Nüüd, just nagu stringid,
suutsime pääse

1856
01:34:11,680 --> 01:34:15,260
to i-nda iseloomu string
kasutades, et nurksulg märke.

1857
01:34:15,260 --> 01:34:17,320
Samamoodi massiivid
üldiselt me ​​saame

1858
01:34:17,320 --> 01:34:22,700
kasuta nurksulg märke saada
igal arv stringe massiivi?

1859
01:34:22,700 --> 01:34:25,100
Näiteks, las ma
minna ja seda teha.

1860
01:34:25,100 --> 01:34:32,420
>> Lubage mul minna ja luua argv1.c,
mis on veidi erinev seekord.

1861
01:34:32,420 --> 01:34:35,635
Selle asemel, et kontrollimine argc2,
Ma lähen selle asemel teha.

1862
01:34:35,635 --> 01:34:41,270
Sest int saan 0, I vähem
kui Argc Ma pluss pluss,

1863
01:34:41,270 --> 01:34:47,920
ja siis välja printida sees see,
protsenti s, uus rida ja seejärel

1864
01:34:47,920 --> 01:34:50,740
argv sulg i.

1865
01:34:50,740 --> 01:34:55,220
>> Nii teisisõnu, ma ei tegele
üksikute märkide hetkel.

1866
01:34:55,220 --> 01:35:00,190
Argv, nagu võiks eeldada nende tühjal väljal
traksid paremal nime argv,

1867
01:35:00,190 --> 01:35:03,320
tähendab argv on massiivi stringe.

1868
01:35:03,320 --> 01:35:04,870
Ja Argc on lihtsalt int.

1869
01:35:04,870 --> 01:35:08,800
>> See joon siin, 6, on
öeldes komplekt i võrdne 0.

1870
01:35:08,800 --> 01:35:11,980
Count kõik viis kuni,
kuid need ei hõlma, Argc.

1871
01:35:11,980 --> 01:35:14,010
Ja siis iga korduse
välja printida string.

1872
01:35:14,010 --> 01:35:14,800
Mis string?

1873
01:35:14,800 --> 01:35:17,270
>> I-nda stringi argv.

1874
01:35:17,270 --> 01:35:19,530
Nii et enne, kui ma olin
abil nurksulg

1875
01:35:19,530 --> 01:35:22,180
märke saada on nda
märk string nüüd

1876
01:35:22,180 --> 01:35:27,240
Ma abil nurksulg märke
saada juures nda stringi massiivi.

1877
01:35:27,240 --> 01:35:30,310
Nii et see on omamoodi üks kiht
eespool kontseptuaalselt.

1878
01:35:30,310 --> 01:35:35,390
>> Ja mis on puhas sellest
Programm nüüd, kui ma koostada argv1,

1879
01:35:35,390 --> 01:35:42,067
ja siis teha ./argv1 ja tippige
midagi nagu foo bar Baz,

1880
01:35:42,067 --> 01:35:45,400
mis on kolm vaikimisi sõnu, et
arvuti teadlane jõuab iga kord,

1881
01:35:45,400 --> 01:35:51,010
ta vajab kohatäide sõnu,
ja vajuta Enter, kõik need sõnad,

1882
01:35:51,010 --> 01:35:54,980
sh programmi nimi, mis
on argv esimesel asukoht,

1883
01:35:54,980 --> 01:35:58,320
jõuab trükitava ühekaupa.

1884
01:35:58,320 --> 01:36:05,290
Ja kui ma seda muuta, ja ma ütlen
midagi argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
saame kõik kolm nimetatud
sõnad, mis on argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, sest selles
Juhul Argc, loota, on 3.

1887
01:36:14,400 --> 01:36:20,020
>> Aga mis on puhas on, kui sa aru
et argv on lihtsalt massiivi stringe,

1888
01:36:20,020 --> 01:36:24,910
ja saate aru, et string
on hulgaliselt märke,

1889
01:36:24,910 --> 01:36:29,470
me saame tegelikult omamoodi kasutada seda
nurksulg märke mitu korda

1890
01:36:29,470 --> 01:36:33,320
valida string, ja seejärel valida
iseloomu jooksul string,

1891
01:36:33,320 --> 01:36:35,730
sukeldudes sügavamale järgmiselt.

1892
01:36:35,730 --> 01:36:40,100
Selles näites lase mul minna
käia ja nimetame seda argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
Ja selles näites, lubage mul minna
ja teha following-- jaoks int i saada 0,

1895
01:36:50,180 --> 01:36:53,286
i on väiksem kui Argc, i pluss
pluss, nagu enne.

1896
01:36:53,286 --> 01:36:55,910
Nii teistes words-- ja nüüd see
muutub üsna keerulised.

1897
01:36:55,910 --> 01:36:59,940
Siis ma lähen ütlen
Käi stringid argv,

1898
01:36:59,940 --> 01:37:01,294
kommentaarina ise.

1899
01:37:01,294 --> 01:37:03,960
Ja siis ma lähen on
Pesastatud silmus, mis siis ilmselt

1900
01:37:03,960 --> 01:37:06,290
teinud, või peetakse
teed, Scratch, kus

1901
01:37:06,290 --> 01:37:08,600
Ma ütlen int-- ma olen
ei kasuta ma jälle,

1902
01:37:08,600 --> 01:37:12,590
sest ma ei taha varju, või
omamoodi kirjutada olemasolev i.

1903
01:37:12,590 --> 01:37:15,780
>> Ma lähen hoopis öelda, j, sest
see on minu minna muutuva pärast i,

1904
01:37:15,780 --> 01:37:18,590
kui ma üritan
loota lihtne numbrid.

1905
01:37:18,590 --> 01:37:28,850
J saab 0-- ja ka n, läheb
saada ahtri pikkus argv sulg i,

1906
01:37:28,850 --> 01:37:36,030
niikaua j on väiksem kui m,
j pluss pluss, teha järgmist.

1907
01:37:36,030 --> 01:37:37,500
Ja siin on huvitav osa.

1908
01:37:37,500 --> 01:37:46,330
>> Prindi välja iseloomu ning uus liin,
ühendades argv sulg i, sulg j.

1909
01:37:46,330 --> 01:37:47,940
OK, nii et las ma lisan mõned kommentaarid siin.

1910
01:37:47,940 --> 01:37:54,820
Käi tähemärki
praegustes string,

1911
01:37:54,820 --> 01:38:02,290
print j-nda märk i-nda string.

1912
01:38:02,290 --> 01:38:04,630
Nüüd Vaatleme
Mis need kommentaarid tähenda.

1913
01:38:04,630 --> 01:38:06,750
>> Käi stringid
aastal argv-- mitu

1914
01:38:06,750 --> 01:38:09,300
stringid on argv, mis on massiivi?

1915
01:38:09,300 --> 01:38:13,420
Argc palju, nii et ma iterating
alates i võrdne 0 kuni Argc.

1916
01:38:13,420 --> 01:38:20,020
Vahepeal, kui palju märke
on i-nda stringi argv?

1917
01:38:20,020 --> 01:38:22,880
>> Noh, et saada see vastus
Ma lihtsalt helistada string pikkusega

1918
01:38:22,880 --> 01:38:26,810
praeguse string Ma hooldus
umbes, mis on argv sulg i.

1919
01:38:26,810 --> 01:38:30,090
Ja ma lähen ajutiseks salvestamiseks, et
väärtus n, lihtsalt vahemällu eesmärkidel,

1920
01:38:30,090 --> 01:38:31,590
meeles pidada seda tõhusam.

1921
01:38:31,590 --> 01:38:36,330
Ja siis ma lähen initsialiseerida j 0,
hoida läheb nii kaua kui j on väiksem kui n,

1922
01:38:36,330 --> 01:38:38,430
ja iga iteratsiooni juurdekasvu j.

1923
01:38:38,430 --> 01:38:41,030
>> Ja siis siin kohta
minu kommentaar on line 12

1924
01:38:41,030 --> 01:38:43,390
välja printida iseloomu,
järgneb uus liin,

1925
01:38:43,390 --> 01:38:48,140
spetsiaalselt argv sulg
i annab mulle i-nda string

1926
01:38:48,140 --> 01:38:51,690
aastal argv-- nii esimene sõna on
Teine sõna, kolmas sõna, mis iganes.

1927
01:38:51,690 --> 01:38:57,370
Ja siis j sukeldub sügavamale, ja saab
mulle j-nda iseloomu selle sõna.

1928
01:38:57,370 --> 01:39:02,200
Ja nii, et tegelikult saab ravida
argv nagu mitmemõõtmeline,

1929
01:39:02,200 --> 01:39:06,050
nagu kahemõõtmeline, massiiv,
kusjuures iga sõna mingi välimus

1930
01:39:06,050 --> 01:39:08,580
niimoodi oma vaimusilmas
silma, ja iga tegelane

1931
01:39:08,580 --> 01:39:10,930
on selline komponeeritud
veerus, kui see aitab.

1932
01:39:10,930 --> 01:39:13,260
>> Tegelikult, kui me tease
Selle peale tulevikus nädalat

1933
01:39:13,260 --> 01:39:15,580
see saab olema natuke
keerukam kui see.

1934
01:39:15,580 --> 01:39:17,800
Aga sa võid tõesti
mõelda, et nüüd,

1935
01:39:17,800 --> 01:39:22,110
lihtsalt see kahemõõtmeline
massiiv, kusjuures üks tase seda

1936
01:39:22,110 --> 01:39:23,260
on kõik stringid.

1937
01:39:23,260 --> 01:39:26,760
Ja siis, kui sa sukelduda sügavamale, siis
saan isikliku tähemärki

1938
01:39:26,760 --> 01:39:29,600
mispärast, kasutades seda märke siin.

1939
01:39:29,600 --> 01:39:31,620
>> Mis on netomõjust?

1940
01:39:31,620 --> 01:39:34,970
Lubage mul minna ja
teha argv2-- paganama ta.

1941
01:39:34,970 --> 01:39:36,210
Ma tegin vea siin.

1942
01:39:36,210 --> 01:39:40,160
Kaudselt kuulutatakse
raamatukogu funktsiooni Stirling.

1943
01:39:40,160 --> 01:39:42,190
Nii et kõik see aeg, see on
ehk asjakohane

1944
01:39:42,190 --> 01:39:45,130
et me omamoodi viimistlus
täpselt, kus me alustasime.

1945
01:39:45,130 --> 01:39:48,160
>> Ma silmamunad kaudselt kuulutatakse
raamatukogu funktsiooni Stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, oota üks hetk.

1947
01:39:48,987 --> 01:39:51,070
Mäletan, et eriti
kuna see on siin.

1948
01:39:51,070 --> 01:39:54,490
Mul on vaja lisada string sisse
See versioon programm.

1949
01:39:54,490 --> 01:40:00,050
>> Lubage mul minna ja lisada
string, salvestada, et minna

1950
01:40:00,050 --> 01:40:04,460
ja kompileerida argv2.

1951
01:40:04,460 --> 01:40:08,390
Ja nüüd, siin me läheme, et argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
Ja kuigi see on natuke
segasena esimesel pilgul,

1953
01:40:10,590 --> 01:40:15,690
märgata, et tõepoolest, mida
trükitud on dot argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Aga kui ma tüüpi mõned sõnad peale
kiire, nagu argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Sisesta ka natuke
segasena esimesel pilgul.

1956
01:40:22,560 --> 01:40:30,540
Aga kui me kerida tagasi üles
./argv2 Z-A-M-Y-L-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Nii oleme itereerida üle iga sõna.

1958
01:40:32,190 --> 01:40:37,770
Ja omakorda oleme itereerida üle
Iga tähemärgi sõna.

1959
01:40:37,770 --> 01:40:40,040
>> Nüüd, pärast kõike seda,
aru, et seal on

1960
01:40:40,040 --> 01:40:43,120
üks teine ​​detail oleme olnud sellist
ignoreerides seda kogu aeg.

1961
01:40:43,120 --> 01:40:46,180
Me lihtsalt teased peale mida
Peamised sisendite võib olla?

1962
01:40:46,180 --> 01:40:47,780
Aga peamine väljund?

1963
01:40:47,780 --> 01:40:50,540
>> Kõik see aeg, me oleme olnud
ainult kopeerimise ja kleepimise

1964
01:40:50,540 --> 01:40:53,870
sõna int ees peamine,
kuigi võite näha online,

1965
01:40:53,870 --> 01:40:58,340
mõnikord valesti vanemad versioonid
C ja koostajad, et nad ütlevad tühine,

1966
01:40:58,340 --> 01:40:59,410
või üldse mitte midagi.

1967
01:40:59,410 --> 01:41:01,580
Aga tõepoolest versiooni jaoks
C, et me kasutame,

1968
01:41:01,580 --> 01:41:06,180
C 11 või 2011 mõistma
et see peaks olema int.

1969
01:41:06,180 --> 01:41:09,300
Ja see peaks olema kas
tühine või Argc ja argv siin.

1970
01:41:09,300 --> 01:41:10,790
>> Aga miks int main?

1971
01:41:10,790 --> 01:41:12,480
Mis on see tegelikult tagasi?

1972
01:41:12,480 --> 01:41:16,280
Noh, selgub kõik see aeg,
igal ajal olete kirjutanud programmi peamine

1973
01:41:16,280 --> 01:41:18,440
alati tagasi midagi.

1974
01:41:18,440 --> 01:41:19,960
Aga see on teinud seda salaja.

1975
01:41:19,960 --> 01:41:23,350
>> Et midagi on
int, kui rida 5 näitab.

1976
01:41:23,350 --> 01:41:24,225
Aga mis int?

1977
01:41:24,225 --> 01:41:26,100
Noh, seal on see
konventsiooni programmeerimine,

1978
01:41:26,100 --> 01:41:29,790
kusjuures, kui midagi on
valesti läinud ja kõik on hästi,

1979
01:41:29,790 --> 01:41:34,250
programmide ja funktsioonide üldiselt
return-- mõnevõrra counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 üldjuhul tähendab, et kõik on hästi.

1982
01:41:38,070 --> 01:41:40,610
Nii et kuigi sa arvad
see vale paljudes kontekstides,

1983
01:41:40,610 --> 01:41:42,930
see tegelikult tähendab üldiselt hea

1984
01:41:42,930 --> 01:41:49,560
>> Vahepeal, kui programmi tagastab 1,
või negatiivne 1 või 5 või negatiivne 42,

1985
01:41:49,560 --> 01:41:52,941
või mitte-0 väärtus,
et üldiselt tähistab

1986
01:41:52,941 --> 01:41:54,190
et midagi on valesti läinud.

1987
01:41:54,190 --> 01:41:56,700
Tegelikult on oma Mac või PC,
sa võisid tõepoolest näinud

1988
01:41:56,700 --> 01:42:01,050
veateade, millega ta
ütleb midagi või muu viga

1989
01:42:01,050 --> 01:42:04,940
kood negatiivne 42 või error code
23, või midagi sellist.

1990
01:42:04,940 --> 01:42:08,980
See arv on üldiselt lihtsalt vihje
programmeerija või ettevõtte

1991
01:42:08,980 --> 01:42:11,174
mis tehtud tarkvara
mis valesti läks ja miks

1992
01:42:11,174 --> 01:42:13,590
et nad saaksid vaadata läbi
nende dokumentide või koodi

1993
01:42:13,590 --> 01:42:15,465
ja aru saada, mis
viga tegelikult tähendab.

1994
01:42:15,465 --> 01:42:18,400
See ei ole üldiselt
meile kasulik lõppkasutajatele.

1995
01:42:18,400 --> 01:42:20,550
>> Aga kui peamine naaseb 0, et kõik on hästi.

1996
01:42:20,550 --> 01:42:23,770
Ja kui sa ei määra
Mis peamine peaks tagasi,

1997
01:42:23,770 --> 01:42:26,950
see lihtsalt automaatselt
tagasi 0 teile.

1998
01:42:26,950 --> 01:42:30,870
Aga tagasi midagi
muidu on tegelikult kasulik.

1999
01:42:30,870 --> 01:42:34,660
>> Sel lõplik programm, lase mind
minna ja nimetame seda exit.c,

2000
01:42:34,660 --> 01:42:38,630
ja tutvustada viimase tänapäeva
teemasid, mida tuntakse veakood.

2001
01:42:38,630 --> 01:42:42,930
Lubage mul minna ja sisaldavad meie
tuttav faile üles top, do int main.

2002
01:42:42,930 --> 01:42:49,500
Ja seekord teeme int Argc,
string argv ja minu sulgudes

2003
01:42:49,500 --> 01:42:50,836
tähenda, et see on massiivi.

2004
01:42:50,836 --> 01:42:52,460
Ja siis me lihtsalt ei meelerahu kontrolli.

2005
01:42:52,460 --> 01:42:56,640
Seekord kui Argc ei
võrdsed 2, siis sa tead, mida?

2006
01:42:56,640 --> 01:42:57,520
Unusta ära.

2007
01:42:57,520 --> 01:43:03,170
Ma ei ütle, et kuule, kasutaja,
siis on puudu käsureaargumenti

2008
01:43:03,170 --> 01:43:04,210
backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> Ja siis ongi kõik.

2010
01:43:05,230 --> 01:43:06,130
Ma tahan, et väljuda.

2011
01:43:06,130 --> 01:43:11,030
Ma ennatlikult,
ja enneaegselt tõesti, tagastamise

2012
01:43:11,030 --> 01:43:12,810
midagi muud kui number 1.

2013
01:43:12,810 --> 01:43:15,360
Ava väärtus esimese
viga, mis võib juhtuda, on 1.

2014
01:43:15,360 --> 01:43:17,860
Kui teil on mõni muu ekslik
olukorda, mis võib tekkida,

2015
01:43:17,860 --> 01:43:21,390
Võib öelda tagastamise 2 või tagasi 3 või
võibolla isegi negatiivne 1 või negatiivne 2.

2016
01:43:21,390 --> 01:43:23,750
>> Need on vaid väljundkoodid
mis on üldiselt

2017
01:43:23,750 --> 01:43:27,770
ainult kasulik programmeerija või
ettevõte, mis laevanduse tarkvara.

2018
01:43:27,770 --> 01:43:30,500
Aga fakt, et see
ei 0 on, mis on oluline.

2019
01:43:30,500 --> 01:43:34,310
Nii et kui see programm, ma tahan
tagada, et see programm ainult

2020
01:43:34,310 --> 01:43:38,190
toimib siis, kui kasutaja annab mulle
koos argument arv kaks,

2021
01:43:38,190 --> 01:43:42,880
nimi programm, ja mõned teised
Ühesõnaga, ma ei saa jõustada nii palju kui järgmine,

2022
01:43:42,880 --> 01:43:46,110
kisa kasutajale printf ütlus
puudu käsureaargumenti,

2023
01:43:46,110 --> 01:43:46,970
tagasi 1.

2024
01:43:46,970 --> 01:43:49,940
See lihtsalt kohe
sulgege programm.

2025
01:43:49,940 --> 01:43:55,840
>> Ainult siis, kui Argc võrdub 2 me pikali
siin, selles punktis ma öelda,

2026
01:43:55,840 --> 01:44:00,410
tere protsenti s, backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Teisisõnu, ma olen
ei kavatse pärast argv 0,

2028
01:44:03,827 --> 01:44:05,410
mis on lihtsalt programmi nimi.

2029
01:44:05,410 --> 01:44:09,450
Ma tahan välja printida tere, koma,
teine ​​sõna, et inimese kirjutatud.

2030
01:44:09,450 --> 01:44:12,580
Ja sel juhul on
line 13, kõik on hästi.

2031
01:44:12,580 --> 01:44:15,920
>> Ma tean, et Argc on 2
loogiliselt seda programmi.

2032
01:44:15,920 --> 01:44:17,770
Ma lähen edasi minna ja tagasi 0.

2033
01:44:17,770 --> 01:44:21,230
Selle kõrvale, pea meeles, et
see on tõsi Scratch samuti.

2034
01:44:21,230 --> 01:44:24,760
>> Loogiliselt ma võiks seda teha
ning loovad need read

2035
01:44:24,760 --> 01:44:27,020
koodi selles muidu punktis siin.

2036
01:44:27,020 --> 01:44:29,420
Aga see on omamoodi
asjatult taandamine minu koodi.

2037
01:44:29,420 --> 01:44:31,800
Ja ma tahan teha super
selge, et ükskõik, mida,

2038
01:44:31,800 --> 01:44:34,670
vaikimisi, tere
midagi saavad trükitud,

2039
01:44:34,670 --> 01:44:36,050
niikaua kui kasutaja teeb seda.

2040
01:44:36,050 --> 01:44:39,360
>> Nii et see on väga tavaline, et
tingimus, lihtsalt kui

2041
01:44:39,360 --> 01:44:41,870
püüda mõned ekslikud
olukorras, ja seejärel sulgub.

2042
01:44:41,870 --> 01:44:45,690
Ja siis, nii kaua kõik on
noh, ole muud,

2043
01:44:45,690 --> 01:44:48,060
aga lihtsalt koodi
väljaspool, et kui, sest see on

2044
01:44:48,060 --> 01:44:51,060
samaväärsed selles
eriti juhul, loogiliselt.

2045
01:44:51,060 --> 01:44:54,480
Nii et ma tagasi 0, lihtsalt
selgesõnaliselt tähenda, et kõik on hästi.

2046
01:44:54,480 --> 01:44:58,480
>> Kui ma jätta tagastamise 0, oleks
automaatselt eeldada, minu jaoks.

2047
01:44:58,480 --> 01:45:00,890
Aga nüüd, et ma olen tagasi
üks vähemalt sel juhul,

2048
01:45:00,890 --> 01:45:04,940
Ma lähen, hea meede ja
selgus, tagastab 0 käesolevas asjas.

2049
01:45:04,940 --> 01:45:09,690
Nüüd lubage mul minna ja teha exit
mis on täiuslik rännata jäta.

2050
01:45:09,690 --> 01:45:14,401
>> Aga teha exit ja lase mul minna
käia ja teha ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
Ja programmi karjus mulle,
puudu käsureaargumenti.

2052
01:45:16,900 --> 01:45:18,120
OK, las ma koostööd.

2053
01:45:18,120 --> 01:45:23,810
>> Lubage mul asemel teha ./exit, David, Enter.

2054
01:45:23,810 --> 01:45:25,190
Ja nüüd ta ütleb, tere David.

2055
01:45:25,190 --> 01:45:27,300
Ja sa tavaliselt ei näe seda.

2056
01:45:27,300 --> 01:45:30,650
>> Aga selgub, et seal on
erilisel moel Linux tegelikult näha

2057
01:45:30,650 --> 01:45:34,470
mida koodiga programm väljunud.

2058
01:45:34,470 --> 01:45:37,184
Vahel graafilise
maailma nagu Mac OS või Windows,

2059
01:45:37,184 --> 01:45:40,100
näed ainult need numbrid, kui
veateadet hüppab ekraanil

2060
01:45:40,100 --> 01:45:41,940
ja programmeerija
näitab, et number.

2061
01:45:41,940 --> 01:45:44,773
Aga kui me tahame näha, milline viga
sõnum on, me ei saa seda teha siin--

2062
01:45:44,773 --> 01:45:48,100
nii ./exit, Enter, print
puudu käsureaargumenti.

2063
01:45:48,100 --> 01:45:54,590
>> Kui ma nüüd tegema kaja $ ?, mis on
naeruväärselt segasena otsima.

2064
01:45:54,590 --> 01:45:56,590
Aga $?

2065
01:45:56,590 --> 01:45:59,220
on maagiline loits
mis ütleb, hei, arvuti,

2066
01:45:59,220 --> 01:46:01,900
öelge mulle, mida eelmise
Programmi koodiga oli.

2067
01:46:01,900 --> 01:46:03,410
Ja ma Enter.

2068
01:46:03,410 --> 01:46:07,520
Näen 1, sest see, mida ma
ütles mu põhiülesanne tagasi.

2069
01:46:07,520 --> 01:46:12,310
>> Vahepeal, kui ma ./exit David,
ja vajuta Enter, ma näen, tere David.

2070
01:46:12,310 --> 01:46:16,800
Ja kui ma nüüd tegema kaja $ ?, näen hello 0.

2071
01:46:16,800 --> 01:46:19,080
Ja nii see tegelikult
väärtuslik teave

2072
01:46:19,080 --> 01:46:23,420
kontekstis siluri, mitte nii
palju, et sa inimese, hooliks.

2073
01:46:23,420 --> 01:46:26,060
Aga siluri ja muu
programmid me kasutame sel semestril

2074
01:46:26,060 --> 01:46:29,420
Sageli vaadata, et number,
kuigi see on omamoodi peidetud

2075
01:46:29,420 --> 01:46:32,780
kui sa otsida seda, et
kindlaks teha, kas või mitte programmi

2076
01:46:32,780 --> 01:46:37,050
täitmise oli õige või vale.

2077
01:46:37,050 --> 01:46:40,450
>> Ja nii, et toob meid
Selle lõpus päeval.

2078
01:46:40,450 --> 01:46:43,917
Alustasime täna vaadates
silumine ja kordamööda käigus

2079
01:46:43,917 --> 01:46:46,750
ise ja seejärel rohkem huvitaval kombel
tehniliselt all kapuuts

2080
01:46:46,750 --> 01:46:49,490
millise stringid on, mis kestab
nädalal me lihtsalt võttis ette antud,

2081
01:46:49,490 --> 01:46:51,900
ja kindlasti oli neid
enesestmõistetavaks Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Siis vaatasin, kuidas suudame
üksikute märkide jada,

2083
01:46:56,040 --> 01:47:00,310
ja siis jälle võttis kõrgemal tasemel
vaadata asju, vaadates, kuidas well--

2084
01:47:00,310 --> 01:47:04,226
Kui me tahame saada üksikisiku
elementide nimekirja sarnane struktuur,

2085
01:47:04,226 --> 01:47:05,850
ei saa me seda teha mitu stringid?

2086
01:47:05,850 --> 01:47:08,050
Ja me saame koos käsurea argumente.

2087
01:47:08,050 --> 01:47:12,800
Aga see pilt siin lihtsalt kastid
on demonstratiivne selle üldine idee

2088
01:47:12,800 --> 01:47:14,451
massiivi või nimekirja, või vektor.

2089
01:47:14,451 --> 01:47:16,450
Ja sõltuvalt
kontekstis kõiki neid sõnu

2090
01:47:16,450 --> 01:47:17,880
tähenda veidi erinevaid asju.

2091
01:47:17,880 --> 01:47:20,060
Nii C, me üksnes
rääkida massiivi.

2092
01:47:20,060 --> 01:47:23,840
Ja massiivi on patakas
mälu, kellest igaüks on

2093
01:47:23,840 --> 01:47:27,720
elemendid on pidevad tagasi
tagasi, tagasi, edasi-tagasi.

2094
01:47:27,720 --> 01:47:31,970
>> Ja need elemendid on üldiselt
sama andmetüüp, iseloomu,

2095
01:47:31,970 --> 01:47:35,966
iseloomu, iseloomu, iseloomus, või
string, string, string, string, või int,

2096
01:47:35,966 --> 01:47:38,600
int, int, mis see on
me üritame poest.

2097
01:47:38,600 --> 01:47:42,540
Aga lõpus päeval, see on
kuidas see välja näeb kontseptuaalselt.

2098
01:47:42,540 --> 01:47:44,530
Sa võtad oma
arvuti mälu või mälu.

2099
01:47:44,530 --> 01:47:48,590
Ja sa jätta välja võtta
identselt suurusega karbid, mis kõik

2100
01:47:48,590 --> 01:47:50,920
on tagasi, tagasi, et
tagasi, tagasi niimoodi.

2101
01:47:50,920 --> 01:47:53,200
>> Ja mis tore
Selle idee ning tõsiasi

2102
01:47:53,200 --> 01:47:58,580
et võime väljendada väärtused sel viisil
esimese meie andmestruktuuride

2103
01:47:58,580 --> 01:48:02,520
klassis, tähendab, et saame alustada
lahendada probleeme koodi

2104
01:48:02,520 --> 01:48:04,079
mis tuli nii intuitiivselt nädal 0.

2105
01:48:04,079 --> 01:48:05,870
Sul on meenutada telefon
raamat näiteks siis, kui

2106
01:48:05,870 --> 01:48:09,110
me kasutasime jaga ja valitse,
või binaarne otsingu algoritm,

2107
01:48:09,110 --> 01:48:13,220
sõeluma läbi terve
kamp nimed ja numbrid.

2108
01:48:13,220 --> 01:48:18,220
Aga me eeldada, meenutada, et see
telefoniraamat juba sorteeritud,

2109
01:48:18,220 --> 01:48:21,630
et keegi oli juba
arvasin out-- antud nimesid,

2110
01:48:21,630 --> 01:48:24,430
ja numbers-- kuidas alphabetize neid.

2111
01:48:24,430 --> 01:48:26,950
Ja nüüd, et C oleme,
Ka on võime

2112
01:48:26,950 --> 01:48:30,290
panna asjad läbi, mitte
füüsiliselt telefoniraamat

2113
01:48:30,290 --> 01:48:34,220
kuid praktiliselt arvuti
mälu, saame järgmisel nädalal

2114
01:48:34,220 --> 01:48:38,470
tutvustada uuesti see-- esimene
Meie andmete struktuurid array--

2115
01:48:38,470 --> 01:48:43,530
kuid veelgi tähtsam, tegelik arvuti
teaduse algoritme

2116
01:48:43,530 --> 01:48:47,720
koodi, kellega meil on võimalik salvestada
andmete struktuurid nagu see,

2117
01:48:47,720 --> 01:48:50,730
ja siis hakkavad manipuleerida, ja
tegelikult lahendada probleeme sellega,

2118
01:48:50,730 --> 01:48:53,570
ja ehitada peal, et
lõpuks programme C,

2119
01:48:53,570 --> 01:48:56,730
Python, JavaScript,
päringute andmebaase SQL?

2120
01:48:56,730 --> 01:48:59,980
>> Ja me näeme, et kõik need
erinevaid ideid omavahel tihedalt.

2121
01:48:59,980 --> 01:49:04,100
Aga nüüd, meelde tuletada, et
domeeni, mis me sisse täna

2122
01:49:04,100 --> 01:49:06,920
oli see asi siin, ja
maailma krüptograafia.

2123
01:49:06,920 --> 01:49:11,200
Ja vahel järgmise probleemidest ise
lahendab on kunst krüptograafia

2124
01:49:11,200 --> 01:49:13,630
skrambleerimise ja de-skrambleerimise
info ja krüptimine

2125
01:49:13,630 --> 01:49:15,930
ja kulus teksti
ja eeldades lõpuks

2126
01:49:15,930 --> 01:49:18,970
mis sa nüüd tea, mida
on all kapuuts

2127
01:49:18,970 --> 01:49:21,860
nii et kui te näete või saada
selline teade, siis

2128
01:49:21,860 --> 01:49:24,060
ise ei oska seda lugeda.

2129
01:49:24,060 --> 01:49:26,740
Kõik see ja rohkem järgmine kord.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [VIDEO PLAYBACK]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Just saabunud.

2133
01:49:32,970 --> 01:49:35,146
Ma lähen visiidil
oma kolledži professor.

2134
01:49:35,146 --> 01:49:37,611
Yep.

2135
01:49:37,611 --> 01:49:40,080
Tere.

2136
01:49:40,080 --> 01:49:40,660
See oled sina.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Oodake!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Ma lihtsalt üritan aru
mis juhtus sinuga.

2142
01:49:56,060 --> 01:49:58,130
Palun, midagi võiks aidata.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Sa olid oma kolledži
toakaaslane, eks ole?

2145
01:50:08,354 --> 01:50:10,770
Sa olid seal koos temaga, kui
Ta lõpetas CS50 projekti?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUSIC MÄNGIB]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -See Oli CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Ma armastan seda kohta.

2152
01:50:44,770 --> 01:50:45,854
>> -Ära sööma.

2153
01:50:45,854 --> 01:50:47,020
Me läheme pankrotti.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [END PLAYBACK]

