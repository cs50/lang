[MUSIC MÄNGIB] 

DAVID J. Humala: Hea küll. See on CS50 ja see on algus 2. nädal. Ja võite meelde tuletada, et üle Viimase paari nädala jooksul, viisime sisse arvuti teaduse ja omakorda, programmeerimine. 

Ja hakkasime lugu teel Scratch, et graafiline keel MIT Media Lab. Ja siis viimasena Eelmisel nädalal tegime kehtestada higher-- madalama taseme keeles tuntud C, midagi, mis on puhtalt tekstiline. Ja tõesti, viimane kord uurida selles kontekstis mitmeid kontseptsioone. 

See, mäletate, oli väga Esimene programm me vaatasime. Ja seda programmi, lihtsalt prindib välja, "Tere, maailm." Aga seal on nii palju näilisest magic toimub. Seal on see #include Nende noolsulgudega. Seal on int. Seal (void). Seal on sulgudes, looksulg, semikoolonite, ja nii palju. 

Ja nii, meelde tuletada, et meil kasutusele Scratch nii et me võiks ideaalis näha minevikku et süntaks, asju, mis pole tegelikult kõik, mis intellektuaalselt huvitav, kuid juba varakult on absoluutselt, natuke keeruline wrap meelt umbes. Ja tõepoolest, üks levinumaid asju varakult programmeerimise klassi, eriti neile vähem mugav, on saada pettunud ja kompastumisen teatud süntaktilise vigadest, rääkimata loogiline vigadest. Ja nii üks meie eesmärke täna, tegelikult, eks olla varustada teid mõned probleemide lahendamise tehnikaid kuidas paremini lahendada probleeme ise kujul silumine. Ja teil meenutada ka, et keskkonda, milles me sisse Viimast korda kutsuti CS50 IDE. See on veebipõhine tarkvara, mis võimaldab teil programmeerida pilv, niiöelda, hoides kogu oma failid koos, kui me jälle täna. Ja meenutada, et me vaadata neid teemasid siin, nende seas funktsioonid ning silmusesse muutujad ja Boole'i ​​väljendeid, ja tingimusi. Ja tegelikult veel mõned, et me tõlgitud maailma Scratch maailma C. 

Aga põhiline hoone plokid, nii et rääkida, olid tõesti ikka sama eelmisel nädalal. Tegelikult on meil tõesti oli just erinevat pusletükk, kui soovite. Selle asemel, et lilla salvestada plokk, me asemel oli printf, mis on Selle funktsiooni C, et võimaldab printida midagi ja vormi seda ekraanil. Me tutvustas CS50 Raamatukogu, kus te on nüüd teie käsutuses get_char, ja get_int ja get_string, ja mõned muud funktsioonid noh, mille kaudu saad sisestada kasutaja enda klaviatuuri. Ja meil on ka vaatlesime asju nagu these- bool ja paalia, ja double, float, int, long_long string. Ja seal on isegi muid andmeid liigid C. 

Teisisõnu, kui kuulutada muutuja salvestada mingi väärtuse, või kui rakendada funktsiooni mis tagastab mingi väärtuse, saate määrata, milliseid tüüpi väärtus, mis on. Kas see on string, nagu märgijada? Kas see on number, nagu täisarv? Kas see on ujukoma väärtust vms? Nii C erinevalt Scratch, me tegelikult hakkas täpsustanud, milliseid andmeid olime tagasi või kasutades. 

Aga muidugi on meil ka sattus mõned põhipiirangut arvutustehnika. Ja eriti Selle keele C, turult et me vaatlesime täisarv ülevoolu, tegelikkus et kui sul on ainult piiratud kogus mälu või täpsemalt hulga bittide, saad ainult loota nii kõrge. Ja nii me vaatasime seda näiteks siin kusjuures counter lennukis, tegelikult, kui töötab piisavalt pikk oleks ülevoolu ja põhjustada tarkvara tegeliku füüsilise potentsiaali viga. 

Me vaadeldi ka ujuva punkti ebatäpsus, tegelikkus et ainult piiratud arvu bittide, kas see on 32 või 64, saab määrata ainult nii palju numbreid pärast koma, pärast mida alustada saada ebatäpne. Nii näiteks ühe kolmandiku võrra maailma siin, inimeste maailma, me teame, on ainult lõpmatu arv ning 3s pärast koma. Aga arvuti ei saa tingimata esindavad lõpmatu arv numbrid kui sa ainult seda lubavad mõned piiratud hulgal teavet. 

Nii et mitte ainult ei me varustada teid suurema võimsuse poolest kuidas siis võib väljendada ennast klaviatuuri poolest programmeerimine, meil on ka piiratud, mida tegelikult võite seda teha. Ja tõepoolest, vead ja vigu võib tekivad seda tüüpi küsimusi. Ja tõepoolest, üks teemasid täna hakkavad teemasid nagu silumine ja tegelikult otsivad all kapuuts kuidas asjad toodi eelmisel nädalal tegelikult ellu nii et sa parem mõista nii võimeid ja piirangud keeles nagu C 

Ja tegelikult, me Tõmmake kihid lihtsamaid andmete struktuuri, midagi, mida nimetatakse massiivi, mis Scratch juhtub nimetame "nimekirja." See on natuke erinevad selles kontekstis. Ja siis me ka tutvustada üks Esimene meie valdkonnapõhised probleeme aastal CS50, maailma krüptograafia, kunst segunemise või šifreerimine informatsiooni nii et võite saata salajasi teateid ja dekodeerida saladus teateid kahe isiku vahel, A ja B. 

Nii enne kui me üleminek Selle uue maailma, Proovime varustada teid mõned tehnikat, millega saab kõrvaldada või vähendada vähemalt mõned pettumusi et teil on ilmselt tekkinud viimase nädala jooksul üksi. Tegelikult su ees on such-- mõned Teie esimene probleeme C. Ja koefitsiendid, Kui sa oled nagu mina, esimest korda püüad tüüp välja programm, isegi siis, kui te arvate, loogiliselt programm on üsna lihtne, võite väga hästi tabanud seina ja koostaja ei kavatse koostööd. Tee või rõkkama ei kavatse tegelikult teha oma pakkumise. 

Ja miks see võiks olla? Noh, kui heita pilk, ehk lihtne programm. Ma lähen edasi minna ja päästa seda faili teadlikult nn buggy0.c, sest ma tean, et see puudulikud ette. Aga ma ei pruugi mõista, et kui see on esimene või teine ​​või kolmas programm et ma tegelikult teeb ise. Nii et ma lähen edasi minna ja tüüp välja, int main (void). Ja siis sees minu looksulg, väga tuttav ( "tere, world-- backslash, n ") - ja semikooloniga. 

Olen salvestatud faili. Nüüd ma lähen alla minu terminali aknas ja liiki make buggy0, sest jällegi nimi faili täna buggy0.c. Nii I tüüpi muuta buggy0, Enter. 

Ja oh jumal, mäletate viimast korda et ükski veateated on hea. Seega ei ole väljund on hea. Aga siin mul selgelt mõned vigade arvu. 

Nii et esimene rida väljund pärast kirjutades teha buggy0, meenutada, on rõkkama on üsna paljusõnaline väljund. All kapuuts, CS50 IDE on seadistatud kasutada terve hulk võimalusi selle koostaja nii et sa ei pea mõelda neist. Ja see on kõik, mis esimese rea vahendid, mis algab rõkkama. 

Kuid pärast seda, probleemid hakata tegema oma välimust. Buggy0.c rea 3, iseloomu 5, on suur, punane viga. Mis see on? Kaudselt kuulutatakse raamatukogu funktsiooni printf tüüpi int (const char * ...) [-Werror]. Ma mõtlen, et see väga kiiresti läheb väga kauge. Ja kindlasti, esimesel lühidalt, me ei eeldada, et sa aru kogu see sõnum. Ja nii üks lugu täna läheb olema püüda märgata mustrid, või sarnaseid asju, vigu, mida oleks võinud varem kokku puutunud. Nii saab õrritama peale ainult need sõnad, mis näevad välja tuttav. Suur, punane viga on selgelt sümboolne midagi on valesti. 

kaudselt kuulutatakse raamatukogu funktsiooni printf. Nii et isegi kui ma ei saa aru, mis kaudselt kuulutatakse raamatukogu funktsiooni vahenditega, probleem kindlasti seotud printf kuidagi. Ja allikas, et küsimus on pistmist väljakuulutamiseks. 

Kuulutatakse funktsioon on viitavad see esimest korda. Ja me kasutasime terminoloogia eelmisel nädalal tunnistamise funktsioon prototüüp, kas ühe rea peal oma ise fail või nn päisefaili. Ja mida faili tegid ütleme eelmisel nädalal, et printf on tsitaat, lõppeb, deklareeritud? Mis fail on selle prototüüp? 

Nii et kui te mäletate, kõige esimene asi, mida ma trükitud, peaaegu iga programmi viimase AEG_ ja kogemata hetk tagasi alustas kirjutades myself-- oli see üks siin-- hash-- #include <stio-- eest sisend / output-- dot h Ja tõepoolest, kui ma nüüd salvestada faili, et ma lähen minna ja selge minu ekraanil, mida saate teha kirjutades Läbipaistev, või saate hoida kontrolli L, lihtsalt kustutada oma terminali aknas lihtsalt kõrvaldada mõned segadusega. 

Ma lähen edasi minna ja re-tüüpi make buggy0, Enter. Ja voila, ma ikka näha, et pikk käsk rõkkama, kuid seal ei veateate seekord. Ja tõepoolest, kui ma ./buggy0, nagu viimane kord, kus dot tähendab see kataloog, Slash tähendab lihtsalt, siin on programmi nimi ja mis programmi nimi on buggy0, Sisesta, "Tere, maailm." 

Nüüd, kuidas võib teil väita seda lahendust ilma et see tingimata tunnistades nii palju sõnu kui mina, kindlasti, võttes seda teinud nii palju aastaid? Noh, mõistad kohta esimene probleem komplekt, me tutvustada teile käsu et CS50 enda töötajad kirjutas nimetatakse help50. Ja tõepoolest, C teeb spetsifikatsioon probleemi seatud, kuidas kasutada seda. 

Aga help50 on sisuliselt programm, mis CS50 töötajad kirjutas, et saab käivitada käsu või käivitada programme, ja kui sa ei mõista selle väljund, läbida oma toodangut help50, misjärel tarkvara et loomulikult töötajate kirjutas otsib oma programmi väljund rida-realt, tähthaaval. Ja kui me töötajad, tunnustada veateate, et sul on, püüame provotseerida teile mõned retorisia, mõned nõuanded, palju nagu TF või CA või ise teeks isiklikult tööaega. 

Nii vaatame help50 kui te ei pruugi tunda probleem. Aga ei tugine ta liiga palju kark. Kindlasti püüa mõista selle väljund ja siis õppida seda nii et ainult üks või kaks korda sa kunagi joosta help50 konkreetse viga sõnum. Pärast seda, sa peaksid olema paremini varustatud ise aru saada, mis see tegelikult on. 

Teeme ühe teise siin. Lubage mul minna ja teises file me nimetame seda buggy1.c. Ja seda faili ma olen läheb deliberately-- kuid teeselda, et ma ei ole mõista, mis viga olen teinud. 

Ma lähen edasi minna ja seda see-- #include, sest ma olen õppinud minu õppetund hetk tagasi. Int main (void), kui enne. Ja siis siin ma lähen teha string s - get_string. Ja mäletate viimast korda See tähendab, hei, arvuti, mulle varieeruv, nimetame seda s, ja teha, millist tüüpi muutuja string nii et ma mahutab ühest või mitmest sõnast ta. 

Ja siis paremal pool võrdusmärki on get_string, mis on funktsiooni CS50 raamatukogu et just selline. Läheb funktsioon ja seejärel käed see paremalt vasakule. Nii et see võrdusmärk ei tähenda "Võrdub", nagu me võiks arvata, matemaatika. See tähendab loovutamine paremalt vasakule. Nii et see tähendab, võtab stringi kasutaja ja hoidke seda sees s. 

Nüüd seda kasutada. Lubage mul minna nüüd ja teise line, lubage mul minna ja öelda "tere" - mitte "maailmas", aga "tere,% S- mis on meie kohatäide, koma s, mis on meie muutuja, ja seejärel semikooloniga. Nii et kui ma ei kruvi liiga palju siin, see näeb välja nagu õige koodi. 

Ja mu instinktid nüüd on kompileerida. Fail nimega buggy1.c. Nii et ma lähen tegema teha buggy1, Enter. Ja darn-it, kui ei ole isegi rohkem vigu kui enne. Ma mõtlen, et seal on rohkem veateateid see oleks tundub kui tegelik rida selles programmis. 

Aga Buffee siin on, isegi kui sa oled ülekoormatud kahe või kolme või veel neli veateateid, keskenduda alati väga Esimene neist sõnumeid. Vaadates kõige ülemisele üks, kerimine varukoopiasse pea olema. Nii et siin ma kirjutada make buggy1. Siin ongi rõkkama väljund ootuspäraselt. 

Ja siin on esimene punane viga. Kasuta deklareerimata identifitseerimine string, ma tähenda standardiks? Nii standard on tegelikult midagi muud. See viitab kasutaja klaviatuur, sisuliselt. 

Aga see pole see, mida ma mõtlesin. Ma mõtlesin string, ja ma mõtlesin get_string. Mis on see, et ma unustasin teha sel ajal? Mis puudu sel ajal? Mul on #include, nii et mul on juurdepääs printf. 

Aga mida ma ei pea juurdepääsu veel? Noh, nagu viimasel ajal Mul on vaja öelda tõlkija Rõkkama, mida need funktsioonid on. Get_string ei tule C. Ja eelkõige see ei tulnud header faili. Selle asemel tuleb midagi personali kirjutas, mis on eri faili nimi, aga tabavalt nimeks. 

Nii lihtsalt, lisades, et üks rida ning code-- tagasikutsumise viimast korda et kui rõkkama jookseb, siis läheb pilk minu kood ülevalt alla, vasakult paremale. See saab märgata, oh, kui soovite. Lubage mul minna ja leida, et kus see asub serveril, kopeeri ja kleebi see sisuliselt ülemisse oma faili nii et siinkohal lugu, line 1, ülejäänud programmi võib tõepoolest kasutada ükskõik millist funktsioonid seal, nende seas get_string. Nii et ma lähen ignoreerida Ülejäänud need vead, sest ma tõesti arvan, et ainult esimene tegelikult Olulised. Ja ma lähen edasi minna ja kordamisega, pärast salvestamist minu faili teha buggy1. Ja voila, ta tegi tööd. Ja kui ma ./buggy1 ja kirjuta jaoks Näiteks Zamyla, ma nüüd saan tere, Zamyla asemel Hello, world. 

Hästi. Nii takeaways siin siis on, üks, proovige noppima nii palju kui võimalik alates veateateid üksi, vaadates mõningaid äratuntav sõnu. Piirangu, et kasutada help50 kohta Probleemi määratud kirjelduses. Aga piirangu, et ka alati vaadata ülaosas viga ainult, vähemalt Esialgu näha, millist teavet see võib tegelikult anda. Aga selgub, et tema isegi rohkem funktsioone ehitatud arvesse CS50 raamatukogu aidata sa varakult semestri ja varakult programmeerimine aru saada, mis on valesti. Nii teeme järjekordne näide siin. Ma nimetan seda buggy2, mis jälle läheb vigane välja värava, mille disain. 

Ja ma lähen edasi minna ja teha #include. Ja siis ma lähen tegema int main (void). Ja siis ma lähen tegema jaoks silmus. Jaoks (int i _ 0. i on väiksem või võrdne 10. i ++ ja seejärel looksulg, ma lähen välja trükkida vaid hashtag sümbol siin ja reavahetusmärki. 

Nii et minu eesmärgiks selles Programm on lihtsalt itereerima 10 korda ja iga iteratsiooni Selle silmus iga kord kaudu tsükli välja printida hashtag, hashtag, hashtag. Üks rea kohta, sest ma on uus liin seal. Ja meenutada, et eest loop, ühe viimase week-- ja saate rohkem tuttav süntaks kasutades seda tava enne long-- see annab mulle muutuva nimetatakse i ja häälestab selle 0. 

See kasvatab i kohta Iga iteratsiooni 1. Nii i läheb 1 kuni 2-3. Ja siis seda tingimust Lähis vahel semikoolonite saab kontrollida iga iteratsiooni teha kindel, et me oleme ikka tööpiirkonnas. Ma tahan kinnitada, 10 korda, nii et ma on omamoodi väga intuitiivselt lihtsalt pane 10 kui minu ülemise seal. 

Ja veel, kui ma saan selle pärast kompileerimisel koos margi buggy2-- ja see ei kompileerida OK. Nii et ma ei ole syntaksivirhettä seekord. Lubage mul minna nüüd ja joosta buggy2, Enter. Ja nüüd keri üles. Ja las ma suurendada suurust akna. 

Mul paistab 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11. Nii et 11 hashtags, kuigi Ma selgelt panna 10 sees see silmus. Nüüd, mõned võite näha kohe Mis viga on, sest tõesti, seda ei ole väga raske viga teha. Aga see on väga sageli tehtud väga varakult. 

Mida ma tahan rõhutada, kuigi on, kuidas võiks ma selgitada seda? Noh, selgub, et CS50 raamatukogu tegemist mitte ainult get_string ja get_int ja get_float ja muid funktsioone. Kaasas ka spetsiaalne funktsioon nimetatakse eprintf või viga printf. Ja see on olemas ainult teha see natuke lihtsamaks kui silumine oma koodi ainult veateadet ekraanile ja tean, kust see tuli. 

Nii näiteks üks asi, mida ma võiks teha siin see funktsioon on see-- eprintf, ja siis ma lähen edasi minna ja öelda, et ma praegu% i, backslash, n. Ja ma lähen pistik väärtus i. Ja kuni top, sest see on CS50 raamatukogu, Ma lähen edasi minna ning sisaldama nii et ma kasutada seda funktsiooni. Kuid olgem kaaluma, mida joon 9 peaks tegema. Ma lähen kustutada lõpuks. See on midagi pistmist minu üldine eesmärk. Aga eprintf, viga printf, on lihtsalt mõeldud mulle mõned diagnostilist informatsiooni. Kui ma saan oma programmi, ma tahan vaata seda ekraanil ajutiselt ka lihtsalt mõista mis toimub. 

Ja tõepoolest, iga iteratsiooni siin rida 9 Ma tahan näha, milline on väärtus i? Mis on väärtus i? Mis on väärtus i? Ja loodetavasti ma peaks ainult näha, et sõnum, samuti 10 korda. 

Nii et lubage mul minna ja kompileerida minu programmi kui ma pean seda tegema igal ajal Ma teha muutusi. ./buggy2. Ja now-- OK. Seal on palju rohkem toimub. Nii et lubage mul kerida üles isegi suurem aken. 

Ja te näete, et iga hashtags veel prinditakse. Aga vahel igaüks neist on nüüd see diagnostilised väljund vormindatud järgmiselt. Nimiminu programm on siin buggy2. Nimi faili on buggy2.c. Liini number, millelt See oli trükitud on line 9. Ja siis paremal see on veateate, et ma olen oodanud. 

Ja mis on tore on see, et Nüüd ma ei pea tingimata lugema mu peas, mis mu programm teeb. Ma näen, et on esimese iteratsiooni i on 0, siis 1, siis 2, siis 3, siis 4, siis 5, siis 6, siis 7, siis 8, siis 9, siis 10. Nii oodake minut. Mis siin toimub? Ma ikka tundub, et lugedes eesmärgipäraselt kuni 10. 

Aga kust alustada? 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10. Nii 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- 11. sõrme näitab probleemi. Mulle tundub, et on loendatud valesti minu loop. Selle asemel, et minna 10 iteratsioon Ma olen hakanud 0, Ma lõpeb ja kuni 10. Aga kuna, nagu arvuti, Ma olen hakanud lugedes 0, Oleksin lugedes üles , kuid mitte läbi, 10. 

Ja nii fix, ma lõpuks mõistis, siin on üks kahest. Ma võiks väga lihtsalt öelda, loota kuni vähem kui 10. Nii 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, mis on tõepoolest õige, kuigi see kõlab natuke valesti. Või ma võiks teha väiksem või võrdne kuni 9, nii kaua kui ma algavad 0. Või kui sa tõesti ei meeldi, et sa võib loota kuni kuni 10, kuid algavad 1. Aga jälle, see lihtsalt ei ole nii levinud. In programming-- kuigi mitte niivõrd Scratch-- kuid programmeerimine C ja teistes keeltes, nagu JavaScript ja Python ja teised, et see on lihtsalt väga tavaline Meie arutelu binaarsed lihtsalt lugemise alustamiseks juures Kõige vähem saate, mis on 0. Hästi. Nii et eprintf. Ja jälle, et nüüd, ma olen aru saanud minu probleem, ja ma lähen tagasi 0 läbi vähem kui 10, ma lähen minna ja kustutada eprintf. 

See ei tohiks olla seal, kui ma laev minu kood või esitada oma koodi või näidata seda kellelegi teisele. Tegelikult on see vaid tähendas ajutist kasutamist. Aga nüüd ma olen parandanud seda Eriliseks probleemiks ka. 

Noh, teeme veel ühe näite siin et ma lähen klopsima järgmiselt. Ma lähen edasi minna ja #include. $ 50 Ja ma lähen edasi minna ja #include. 

Ja ma lähen säästa see pilt buggy3.c. Ja ma lähen edasi minna ja kuulutada int main (void). Ja siis sees olemas Ma teen int i _ - Ma tahan, et rakendada programmi koos get_negative_int. See ei ole funktsioon, mis eksisteerib veel. Nii et me kavatseme rakendada see hetk. Aga me näeme, miks see lollakas esimesel läbima. Ja kui ma olen saanud int kasutaja, Ma lihtsalt printida% i on negatiivne täisarv, backslash, n, koma i. Teisisõnu, kõik I tahan seda programmi teha on saada negatiivne int alates kasutaja ja siis välja printida et selline ja selline on negatiivne int. 

Nüüd on mul vaja rakendada seda funktsiooni. Nii hiljem minu fail, ma lähen edasi ja kuulutada funktsioon nimega get_negative_int (kehtetu) - ja me tagasi tulla, milline see joon tähendab jälle a moment-- int n; do-- do following-- printf n on :. Ja siis ma lähen tegema, n - get_int, ja seda samal ajal n on suurem kui 0. Ja siis tagasi n ;. 

Nii on palju toimub Selle kuid ükski neist me ei vaadata eelmisel nädalal, vähemalt korraks. Nii on line 10 siin ma olen kuulutanud funktsiooni nimetatakse get_negative_int, ja ma panin (void), in sulgudes, selle põhjuseks on see ei võta sisend. Ma ei paneks midagi Selle funktsiooniga. Ma lihtsalt saada midagi tagasi saada. 

Ja mida ma loodan, et tagasi saada on täisarv. Puuduvad andmed tüüpi C nimetatakse negative_int. See on lihtsalt int, nii see läheb olema meile veenduda väärtus, mis on tegelikult Tagastatud on mitte ainult int kuid on ka negatiivne. 

On line 12 Ma kuulutab muutuja nimetatakse n ja muudab tüüpi int. Ja siis vastavalt 13 kuni 18 Ma midagi, kui midagi on tõsi. Ma lähen edasi ja trükkimine n tähendab, käärsoole ja seejärel tühiku nagu kiire kasutaja. 

Ma siis helistades get_int ja ladustamiseks oma nn tagastatav väärtus et muutuja n. Aga ma lähen hoida tehes Selle ajal n on suurem kui 0. Teisisõnu, kui kasutaja annab mulle int ja see arv on suurem kui 0, ergo, positiivne, ma lähen muudkui reprompting kasutaja, hoida reprompting, sundides neid koostööd ning annab mulle negatiivset int. 

Ja kui n on tegelikult negative-- Oletame kasutaja lõpuks tüübid -50, siis see samas loop ei ole enam õige sest -50 ei ole suurem kui 0. Nii et me murda välja, et loop loogiliselt ja tagasi n. 

Aga seal on üks teine asi, mida ma pean tegema. Ja ma ei saa lihtsalt teha poolt kopeerimist ja kleepimist üks rida koodi ülaosas faili. Mul on vaja õpetada rõkkama, või luban rõkkama, selgesõnaliselt, et ma, Tõepoolest, mine ja rakendada Selle funktsiooni get_negative_int. See võib lihtsalt olla väiksem fail. Jällegi, meelde tuletada, et rõkkama loeb asju ülevalt alla, vasakult paremale, nii et sa ei saa nimetame funktsiooni, kui rõkkama ei tea, see läheb eksisteerida. 

Nüüd kahjuks see programm, nagu mõned teist ehk märganud, on juba lollakas. Lubage mul minna ja teha buggy3. See koostab, nii et minu probleem ei ole praegu syntaksivirhettä, nagu tekstiviga, see on tegelikult saab olema loogiline viga, et ma olen teadlikult tehtud kui võimalust sammult läbi, mis toimub. 

Ma lähen edasi minna nüüd ja kestab buggy3. Ja ma lähen edasi ja tee koostööd. Ma annan selle number 1. See ei meeldi, nii et see sunnib mind jälle. 

Kuidas umbes 2? 3p 50? Ükski neist ei tööta. Kuidas -50? Ja tundub programmi tööd. 

Las ma proovin seda veel kord. Las ma proovin -1, tundub, et töö. Las ma proovin -2, tundub, et töö. Las ma proovin 0. Huh, see on vale. Nüüd me oleme seda natuke pedantne siin. Aga see on tõesti nii, et 0 on ei positiivset ega negatiivset. Ja nii, et minu programm on öeldes, et 0 on negatiivne täisarv, see ei ole tehniliselt korrektne. 

Nüüd, miks seda teeme? Noh, see võib olla ilmne. Ja tõepoolest, et programm on tule üsna lihtne nii et meil on midagi uurida. 

Kuid olgem tutvustada kolmanda silumine tehnikat siin nimetatakse debug50. Nii et see on programm et oleme lihtsalt loodud Sel aastal kutsus debug50 mis võimaldab teil kasutama, mida nimetatakse sisseehitatud graafiline silur on CS50 IDE. Ja siluri on ainult programm, mis Üldiselt saab käivitada oma programmi aga samm-samm-sammult, liin poolt rida-realt, pausid, poking ümber, vaadates muutujad nii, et programm ei ole lihtsalt löök minevikus teid ja kiiresti printida midagi või ei prindi midagi. See annab teile võimaluse juures Inimese kiirusega, et suhelda ta. 

Ja seda teha, siis lihtsalt teha järgmist. Pärast koostamist oma koodi, mida ma juba teinud, buggy3, kui edasi minna ja joosta debug50 ./buggy. Nii palju nagu help50 on sul tekib help50 ja seejärel käsku, debug50 on sul tekib debug50 ja siis käsu nime. 

Nüüd vaata mis juhtub minu ekraanil, paremal pool eriti. Kui ma tabanud Run kõik järsku see parempoolne paneel avab ekraanil. Ja seal on palju läheb kohta esimesel pilgul. Aga seal ei ole liiga palju muretsema veel. 

See näitab mulle kõik mis toimub sees minu programm kohe ja nende kaudu nupud üles top on siis võimaldab mul sammult läbi minu kood lõppkokkuvõttes samm samm-sammult. Aga mitte veel. Pange tähele, mis juhtub. Minu terminali aknas Ma seda küsitakse n. Ja ma lähen edasi minna ja koostööd seekord ja kirjuta -1. Ja kuigi veidi cryptically, -1 on negatiivne täisarv ootuspäraselt. 

Ja siis laps väljus koos staatuse 0 GDBserver väljumisel. GDB, GNU siluri, on nimi aluseks olevate tarkvara mis rakendab seda siluri. Aga see kõik tõesti tähendab, siluri läks ära, sest mu programmi loobuda ja kõik oli hästi. Kui ma tahan tõesti siluda oma programmi Mul on ennetavalt öelda debug50, Kui ma tahan alustada astutakse läbi minu kood? 

Ja võib-olla kõige lihtsam viis seda teha on järgmine. Kui ma hover üle vihmaveerennid minu toimetaja siin nii tõesti ainult vasaku siin vasakul rea number, Pange tähele, et kui ma lihtsalt käsku kord, panin veidi red dot. Ja see väike punane täpp, nagu stop märk tähendab, hei, debug50, pausi täitmine minu kood seal kui ma saan selle programmi. 

Nii teeme seda. Lubage mul minna ja käivitada oma programmi jälle debug50 ./buggy3, Enter. Ja nüüd, teate, midagi erinev on juhtunud. Ma ei luba küsima veel minu terminali aknas midagi, sest ma ei ole saanud seal veel minu programm. Pange tähele, et real 8 mis nüüd esile tõstetud, ja seal on vähe nool Vasakul ütlus, siis on peatatud siin. See koodirida, liin 8, ei ole veel teostatud. 

Ja mis on uudishimulik, kui ma vaatan siin paremal servas märgata, et i on kohalik muutuja, kohalikud selles mõttes, et see sees praegune funktsioon. Ja selle väärtus ilmselt vaikimisi ja omamoodi mugavalt on 0. Aga ma ei kirjuta 0. See lihtsalt juhtub olema oma Vaikimisi väärtus hetkel. 

Nii et lubage mul minna ja teha seda nüüd. Lubage mul minna ja paremal üleval siin, ma olen läheb minna ja Klõpsake seda esimest ikoon, mis tähendab sammu üle, mis tähendab, ärge jätke see aga samm üle selle koodirida, käivitamata mööda teed. 

Ja nüüd, märkate, minu kiire on lihtsalt muutunud. Miks nii? Olen rääkinud debug50, käivitada rida koodi. Mida see koodirida teha? Küsib minult int. OKEI. Lubage mul koostööd. Lubage mul minna nüüd ja kirjuta -1, Enter. Ja nüüd pane tähele, mis on muutunud. Paremal servas, minu kohaliku muutuja i on osutatud kui -1 nüüd. Ja see on ikka tüüpi int. 

Ja teate ka, minu nn pinu, kus ma pausi? Me räägime rohkem seda tulevikus. Aga pinu lihtsalt viitab mida funktsioonid on praegu liigub. Praegu on see lihtsalt peamine. Ja praegu ainus kohalik muutuja on i, mille väärtus 1. 

Ja kui ma lõpuks samm üle selle joone siin, selle sama ikooni ülaosas paremal, -1 On negatiivne täisarv. Nüüd on pausid üle, et lokkis traksidega. Laskem seda teha oma asja. Ma sammu üle, et joon, ja voila. 

Nii ei ole kõik nii kohutavalt valgustav veel kuid see ei lase mul pausi ja läbi mõelda loogiliselt mida see programm teeb. Aga see ei olnud ekslikud puhul. Teeme seda uuesti järgmiselt. 

Ma jätan selle murdepunkti real 8 punase punktina. Ma lähen uuesti, debug50. See automaatselt peatatud siin. Kuid seekord asemel üle astuda selles reas las ma tegelikult minna sees get_negative_int ja nuputada, miks see vastu 0 kehtiv vastus? 

Nii et selle asemel klikkides samm üle. Ma lähen edasi minna ja klõpsake samm. Ja märgata, et rida 8, mis on nüüd rõhutatud nüüd äkki muutub liin 17. 

Nüüd, see ei ole nii siluri on vahele read 14 ja 15 ja 16. See on lihtsalt miski näidata seal. Need on lihtsalt kuulutatakse muutujad, Ja siis on sõna Kas ja siis avatud lokkis traksidega. Ainus funktsionaalne joon, mis on mahlane tõesti on see üks siin, 17. Ja see, kui me oleme peatatud automaatselt. 

Nii printf ( "n.is:") ;, nii mis pole veel juhtunud. Nii lähme edasi ja klõpsake samm üle. Nüüd on mu kiire, tõepoolest, muudeti ( "n on:"). Nüüd get_int, ma ei kavatse vaeva astumist, sest see funktsioon oli tehtud CS50 Raamatukogu. See on arvatavasti õige. 

Nii et ma lähen edasi minna ja omamoodi koostööd, andes talle int, kuid ei ole negatiivne int. Nii et lubage mul minna ja tabas 0. Ja nüüd, mis juhtub siin kui ma pikali joon 21? Ma ei ole itereerida uuesti. Ma ei tundu olevat ummikus, et silmus. Teisisõnu, see kollane baar ei käiks ringi, ja ümber ja ümber. 

Nüüd, miks see nii on? Noh, n, mida on N kohe? Ma ei vaadata kohaliku muutujate siluri. n on 0. Olgu, mis oli minu tingimus? 

20-- line 20 on hästi, 0 on suurem kui 0. See pole tõsi. 0 ei ole suurem kui 0. Ja nii ma puhkes selle. 

Ja nii see on, miks on line 21, kui ma tegelikult jätkata, Ma lähen tagasi 0, isegi kuigi ma oleks pidanud tagasi 0 kui tegelikult ei ole negatiivne. Nüüd, ma tõesti ei isegi hoolivad siluri. Sai siis ma ei pea tean, mida rohkem toimub. 

Nii et ma lähen edasi minna ja lihtsalt nuppu Esita, ja las see viimistlus üles. Nüüd ma olen aru saanud, et minu viga ilmselt on line 20. See on minu loogikaviga. 

Ja mis ma tahan teha, et seda muuta? Kui probleem on selles, et ma ei ole püüdmine 0, see on lihtsalt loogiline viga. Ja ma ei saa öelda, kui n on suurem või võrdne 0, hoida ajendades kasutajal uuesti ja uuesti. 

Niisiis, jälle, lihtne viga, võib-olla isegi ilmne, kui nägid mind kirjutada vaid paar minutit tagasi. Aga Buffee siin on see, et silumis 50, ja silumine tarkvara üldisemalt sul on see uus leitud võim kõndida läbi oma kood, vaatame kaudu, et parempoolne paneel, mida oma muutujate väärtused on. Nii et sa ei pea tingimata pead kasutama midagi nagu sa eprintf printida neid väärtusi. Võite tegelikult neid näha visuaalselt ekraanil. 

Nüüd, pärast seda, tasub märkimist et seal on teine ​​meetod, mis on tegelikult super ühist. Ja siis võiks küsida, miks see väike poiss siin on istunud laval. Nii et seda tehnikat, üldiselt tuntakse kummist part silumine, mis on tegelikult lihtsalt märk sellest, et sageli, kui programmeerijad kirjutate koodi nad ei ole tingimata koostööd teiste või töötavad jagatud keskkonnas. 

Nad justkui kodus. Võibolla on see hilja õhtul. Nad püüavad näitaja mõned bug oma koodi. Ja nad lihtsalt ei näe seda. 

Ja pole mingit toakaaslane. Ei ole TF. Ei ole CA ümber. Kõik nad on oma riiul on see väike kummist Tore. 

Ja nii kummist part silumine just seda kutset mõelda midagi nii rumal sest see on reaalne olend, ja tegelikult kõndida läbi oma koodi verbaalselt sellele elutu objekt. Nii näiteks, kui see on minu näide siin-- ja meelde tuletada, et varem probleem oli see, kui ma kustutan selle esimene rida koodi, ja ma minna ja teha lollakas 0 uuesti Tuletame meelde, et mul oli neist veateateid siin. Nii et idee siin, naeruväärne kuigi ma tunnen hetkel teeme seda avalikult, on see viga. 

OK, nii et minu probleem on see, et ma olen vaikimisi, raamatukogu funktsiooni. Ja et raamatukogu ülesanne on printf. Declare-- OK, kuulutada meenutab mulle prototüübid. 

See tähendab, et ma pean tegelikult öelda koostaja ette, milline funktsioon välja näeb. Oota hetk. Mul ei olnud standard io.h. Tänan teid väga. 

Nii lihtsalt see protsess of-- sa ei pea tegelikult on part. Aga see idee kõndimine ise läbi oma koodi nii et sa isegi kuulda ise, et sa mõistma tegevusetuse oma märkused, on üldiselt idee. 

Ja võib-olla loogiliselt, mitte nii palju, et üks, vaid rohkem kaasatud Näiteks me lihtsalt tegime lollakas 3.c, võite käia ise läbi järgnevalt. Nii et kõik õige, kummi Tore, DDB, kui soovite. Siin on meil minu põhifunktsiooni Helistan saada negatiivse int. 

Ja ma saan tagastatav väärtus. Ma hoiustamisel vasakul servas real 8 muutuv nimetatakse i. OK, aga ära, kuidas et saada, et väärtus? Lubage mul vaadata funktsiooni line 12. 

Vastavalt 12, meil saada negatiivse int. Ei võta mingeid sisendeid, ei tagastab int, OK. Kinnitan line 14 muutuv n. See saab salvestada täisarv. See, mida ma tahan. 

Nii et järgmine samas n las mulle tagasi võtta, mida fix ma juba teinud. Niisiis, kui n on suurem kui 0, trükkida n on, OK. Ja siis helistada saan int salvestatud n. Ja siis vaadata, kas n on 0, n on not-- siin see on. Nii, nüüd, siis ei vaja tegelikku part. Aga lihtsalt kõndides ise läbi koodi intellektuaalse kasutamise Sageli aitab aru, mis toimub, mitte lihtsalt midagi niimoodi, jõllis ekraani ja ei räägi ise läbi see, mis ausalt ei ole peaaegu sama tõhus meetod. Nii et teil on see, et mitmeid erinevaid meetodeid jaoks tegelikult koodi silumine ja laites, mis kõik peaks olema vahendeid oma toolkit nii, et sa ei ole hilja õhtul, Eriti, oled söögituba saali, või tööaega, peksma oma pead vastu seina, püüab lahendada mingi probleem. Mõista, et on tarkvarasse. Seal on kummist part tööriistu. Ja seal on terve töötajad toetada ootab appi. 

Nüüd, sõna probleemist komplekti, ja sellest, mida me loodame teile välja saada neid ja kuidas meil minna hindamiseks. Per kursuse ainekava, CS50 probleem komplekti hinnatakse nelja peamist telge, nii kuni speak-- ulatus, korrektsust, disain, ja stiili. Ja ulatus vaid viitab sellele, kui palju tükk olete hammustanud? Kuidas suur probleem on olete proovinud? Mis tehtud jõupingutusi olete väljendub? 

Korrektsus on, kas programmi töö see peaks ühe CS50 spetsifikatsioon kui pakute teatud sisendite või teatud väljundeid tulevad tagasi? Design on kõige subjektiivne neist. Ja see on üks, mis võtab kauem õppida ja pikim õpetamast niivõrd, kuivõrd see taandub, kui hästi kirjutatud on oma kood? 

See on üks asi, mida lihtsalt printida õige väljundid või naasta õigeid väärtusi. Aga sa teed seda efektiivselt kui võimalik? Kas sa teed seda lõhet ja vallutada või binaarsed Otsing kui me kohe näha, et me tegime kaks nädalat tagasi koos telefoniraamatu? Kas on paremaid viise lahendada Probleem kui teil on praegu siin? See on võimalus parem disain. 

Ja siis style-- kuidas päris on oma kood? Märkad, et ma olen päris Eelkõige umbes taandamine minu kood, ja hoolitsedes minu muutujad on mõistliku nimega. n, samas lühike, on hea nimi jaoks number, i lugedes täisarv, s string. Ja meil on enam muutujanimed stiilis. Stiil on, kuidas hea ei oma koodi vaatama? Ja kuidas loetav on? 

Ja aja jooksul, mida oma ajutise töötaja ja TF teeme käigus on anda teile, et liiki kvalitatiivne tagasiside nii et saad paremini neile erinevaid aspekte. Ja nii, kuidas me hinnata iga telge, see on tavaliselt väga vähe ämbrid, nii et sa üldiselt saada tunnet, kui hästi sa teed. Ja tõesti, kui teile skoor kõik need axes-- õigsust, disain ja stiili especially-- et number on üldiselt vahemikus 1 kuni 5. Ja sõna otseses mõttes, kui sa käid 3 on alguses semestri see on väga hea. See tähendab, seal on veel arenemisruumi, mis siis oleks lootust ka võttes klassi esimest korda. Seal on loodetavasti mõned natuke lakke millele sa soovivad jõuda. Ja nii saan 3 üritused esimesel tükki, Kui ei ole mõned 2-ja 4-ndatel, on tõesti hea. See on hästi levialas, ka sees ootustele. 

Ja kui teie arvates on võidusõit, oodake minut, kolm viiest. See on tõesti 6 10st. See on 60%. Mu jumal, see on F. 

See ei ole. See ei ole tegelikult nii. Pigem on see võimalus parandada jooksul semestri. Ja kui te saate mõned Poors, need annavad võimaluse ära tööaega kindlasti lõigud ja muud vahendid. 

Parim on võimalus, tõesti, mille üle uhke olla, kui kaugele olete tulevad jooksul semestri. Nii saan aru, kui midagi teine, kolm on hea. Ja see võimaldab kasvuruumi aja jooksul. 

Kuidas need teljed on kaalutud, reaalselt sa oled veedab enamiku oma aega saada asju teha, rääkimata õigesti. Ja nii õigsuse kipub kaalutakse kõige Nagu See multiplikatiivseid kolmega. Disain on ka oluline, kuid midagi, mida sa ei pruugi veedavad kõik need tunni kohta üritavad asjad lihtsalt töötada. 

Ja nii see kaalutud veidi kergelt. Ja siis stiil on kaalutud vähemalt. Kuigi see ei ole vähem oluline põhjalikult, see on lihtsalt võib-olla kõige lihtsam asi, mida teha õige, imiteerib näidetes me teha loengu ja paragrahvi asjad kenasti liigestatud ja kommenteeris ja nii edasi on üks kõige lihtsam asju teha ja saada õigus. Nii sellisena realiseerida et need on punktid mis on suhteliselt lihtne haarata. 

Ja nüüd sõna see-- akadeemilise aususe. Nii ühe kursuse ainekava, näed et loomulikult on üsna natuke keelt selle ümber. Ja muidugi suhtub akadeemilise aususe üsna tõsiselt. 

Meil on vahet, paremaks või halvemaks, saatnud igal aastal rohkem õpilased distsiplinaarvastutuse kui enamik muid Muidugi, et olen teadlik. See ei pruugi viitab asjaolule, et CS õpilased või CS50 õpilased on vähem aus kui oma klassikaaslastega. Aga tegelikult, et see maailma elektrooniliselt, me lihtsalt on tehnoloogia tuvastamise vahend selle. 

Oluline on meile õigluse üle klassi et me avastada seda ning tõsta küsimus, kui me näeme asju. Ja just maalida, ja tõesti aidata midagi sellist valamu, need on numbrid õpilased on viimase 10 aasta jooksul mis on seotud mõne selliseid küsimusi akadeemilise aususe, koos umbes 32 õpilast sügisest 2015, mis See tähendab, et me ei võta asja väga tõsiselt. Ja lõpuks, need numbrid kirjutada, viimasena umbes 3%, 4% või nii klassi. 

Nii et super enamik õpilasi tundub, et read on selge. Aga ärge pidage seda pahanda, eriti hilja öösel, kui hädas mingi lahenduse probleemile komplekti, et on olemas mehhanismid saada ise paremaks toetust, kui võiks arvan, isegi tol tunnis. Aru, et kui me saame õpilane kaotanud, me rist võrrelda iga esitamist käesoleva aasta vastu iga esitamiseks eelmisel aastal igaühe vastu esitada alates 2007. aastast ja kuna vaadates, samuti, kood andmehoidlatest online, foorumeid, töö saitidele. Ja räägitakse sellest, tõesti, kõik huvides täielikku avalikustamist, et kui keegi ei leia seda võrgus, Kindlasti, nii me saame muidugi. Aga tõesti, vaimu Kursuse taandub Käesoleva punkti ainekava. See on tõesti õige, mõistlik. 

Ja kui meil oleks täpsustada, et vaid veidi keeles aru, et sisuliselt kõik tööd, mida esitada selle käigus peab olema oma. Aga selles on kindlasti võimalusi ja julgustust, ja pedagoogilist väärtust pöördunud others-- mina, TFS, kuid CAS TAS, ja teised klassis, toetust, rääkimata sõbrad ja toakaaslased, kes on õppinud CS ja programmeerimine enne. Ja nii on saastekvoodi eest. Ja üldine rusikareegel on see-- küsides abi, võite näidata oma koodi teistele, aga sa ei pruugi näha päralt. Nii et isegi kui sa oled tööaega või D saal, või kusagil mujal töötavad mõned osaline komplekt, töö kõrval sõber, mis on täiesti trahvi, kell Päeva lõpuks oma töö peaks lõppkokkuvõttes kuuluvad iga teist võrra ning mitte mõned ühiseid jõupingutusi, välja arvatud lõplik projekt, kus see on lubatud ja soovitatav. 

Mõista, et kui te olete hädas midagi ja su sõber lihtsalt juhtub olema parem selles siis, või parem, et probleem kui sa, või veidi kaugemal ees kui sina, see on täiesti mõistlik pöörduda Teie sõber ja öelda, hei, Ega sa ei pahanda vaatasin koodi siin, aitab mul märgata, mis mu probleem on? Ja loodetavasti ka huvi pedagoogiline väärtus et sõber ei ole lihtsalt öelda, oh, seda teha, vaid pigem mida sa kadunud real 6, või midagi sellist? Aga lahendus ei ole Sõber sinu kõrval öelda, oh, noh, siin, las ma tõmban see üles ja näitab minu lahendus sulle. Nii et on rida. Sa näitad oma koodi teised, kuid te ei tohi Vaata ise, et teised piirangute kursuse ainekava. 

Nii et ärge pidage meeles, see Niinimetatud kahetsust punkti käigus on ainekava samuti, et kui sa endale mingi teo, mis ei ole mõistlik, kuid too see tähelepanu käigus peadesse 72 tunni jooksul, loomulikult võib kehtestada kohaliku sanktsioonid, et võib sisaldada vasta nõuetele või vastasel hinne esitatud tööd. Aga muidugi ei suunata asja veelgi distsiplinaarkaristuse, välja arvatud juhul, korduvate tegude eest. Teisisõnu, kui sa teha mõned loll, eriti hilja õhtul otsus et järgmisel hommikul või kaks päeva Hiljem, kui ärkama ja mõistma, Mida ma mõtlesin? Sa teha CS50 on väljund fikseerimiseks, et probleem ja omavad kuni see, et me kohtub teil pooleldi ja tegeleda kus see küsimus, mis on nii haridus- ja väärtuslik teile, aga ikkagi karistusliku mingil moel. Ja nüüd, et nüristama see. 

[VIDEO PLAYBACK] 

[MUSIC MÄNGIB] 

[END PLAYBACK] DAVID J. Humala: Olgu, me oleme tagasi. Ja nüüd vaatame ühte Esimene meie reaalses maailmas domeenid aastal CS50, kunst krüptograafia kunst saatmine ja vastuvõtmine saladus sõnumeid krüpteeritud lugemiseks, kui soovite, mis saab dešifreerida ainult siis, kui teil on mõned võtmetähtsusega, et saatja on samuti. Nii et motiveerida seda me võtame pilk see asi siin, mis on näide saladus dekooder ring, mis saab kasutada selleks, et aru saada, Mis saladus sõnum tegelikult on. Tegelikult tagasi päev algkool, kui sa kunagi saatis salajase sõnumeid mõned sõber või mõne purustada klassis, Te olete mõelnud sa oleks tark poolt oma paberile muutmine, jms, A punkti B ja B C ja C-D, ja nii edasi. Aga sa tegelikult krüptimine Teie andmeid isegi kui see oli veidi triviaalne, ei olnud et hard õpetaja mõistma, Noh, kui sa lihtsalt muuta B A ja C B, sa tegelikult aru saada Mis sõnum oli, aga sa olid šifreerimine teavet. 

Sa olid lihtsalt tee seda lihtsalt meelega Ralphie siin kuulsa filmi, mis mängib päris palju reklaami nauseum iga talvel. [VIDEO PLAYBACK] -Ole See kõigile teada, et Ralph Parker Käesolevaga määratud liige Little Harva Annie Secret Circle ning tal on õigus kõiki autasud ja kasu esinevad nendega. 

-Signed, Little harva Annie, kaasallkirja Pierre Andre, tindiga. Kiitusega ja kasu, juba üheksa-aastaselt. 

[Karjumine] -Ole nüüd. Lähme edasi. Ma ei pea kõik, et jazz umbes salakaubavedajate ja piraadid. 

Saate kuulata homme õhtul kokkuvõtvad seiklus must Piraatlaeva. Nüüd on aeg Annie salajane sõnum Teile liikmed Secret Circle. Pea meeles, et lapsed, vaid liikmed Annie Secret Circle saab dekodeerida Annie salajane sõnum. 

Pea meeles, et Annie on sõltuvalt teile. Määra oma sõrmed B2. Siin on sõnum. 12 11-- 

-Ma Olen, minu esimene salajase kohtumise. 

-14, 11, 18, 16. 

-Pierre Oli suur hääl täna. Ma võiks öelda, et tänase sõnum oli väga oluline. 

-3, 25, see on sõnum alates Annie ise. Pea meeles, et ei ütle kellelegi. 

-90 Sekundit hiljem, ma olen ainuke tuba majast, kus poiss üheksa võiks istuda privaatsust ja dekodeerida. Ahaa, B! Läksin järgmisel, E. 

Esimene sõna on olla. S, siis tuli lihtsam nüüd, U, 25-- 

Oh, tule, Ralphie, ma pean minema! 

-Ma Kohe maha, ema! Gee viuhti! 

-T, O, kindlasti mina-- kindlasti mida? Mis oli Little harva Annie üritab öelda? Kindlasti mida? 

-Ralphie, Andy on saanud minna, kas sa siis välja tulema? 

-Heaküll, Ma! Ma tulen kohe välja! 

-Ma Oli läheneme. Pinge oli kohutav. Mis see oli? Saatus planeedi võib vaekausil. 

-Ralphie! Andy pean minema! 

-Ma Kohe välja, nutt valjusti! 

Peaaegu seal, mu sõrmed lendas mu mõistus oli terasest trap, igast poorist vibreerima. See oli peaaegu selge, jah, jah, jah. 

-Ole Kindlasti juua oma Ovaltine. Ovaltine? Trullakas kaubandusliku? Litsipurikas. [END PLAYBACK] DAVID J. Humala: OK, nii See oli väga pikk tee kasutusele krüptograafia ja ka Ovaltine. Tegelikult on see vana kuulutus siin, miks on Ovaltine nii hea? See on kontsentreeritud kaevandamise küps odralinnastest, puhas koorene lehmapiima, ja spetsiaalselt ettevalmistatud kakao, koos looduslike fosfatiidfraktsioone ja vitamiine. Lisaks sellele on rikastatud täiendavaid vitamiine B ja D, yum. Ja saad ikka see ilmselt Amazon, nagu tegime siin. 

Aga motivatsiooni siin oli tutvustada krüptograafia, täpsemalt tüüpi krüptograafia tuntud kui salajase võtme krüptograafia. Ja nagu nimigi ütleb, terve turvalisuse salajase võtme krüpto süsteemi kui soovite, metoodika just skrambleerimise teave kahe inimese vahel, on see, et ainult saatjale ja ainult saaja tean salajane key-- mingi väärtus, mõned saladus fraas mõned salajane number, et võimaldab neil nii krüpteerida dekrüpteerida andmeid. Ja krüptograafia, tõesti, just seda nädalast 0. 

See on probleem, kus on sisendid, nagu tegelik sõnum inglise või mis iganes keeles, et sa soovite saata kellelegi klassis, või üle interneti. On mõned väljund, mis läheb olla kodeeritud sõnum, mida taha saaja saada. Ja isegi kui keegi keskel saab see ka sa ei taha, et nad pruugi olla võimalik lahti krüptida, sest sees käesoleva musta kasti või algoritm, on mingi mehhanism, mõned samm-sammult juhiseid, et võtta, et sisend ja muundab selle sisse väljund mis loodetavasti turvaliselt. 

Ja tegelikult on teatud sõnavara siin maailmas järgmiselt. Tavaline tekst on sõnale arvuti teadlane oleks kasutada, et kirjeldada sisend sõnum, nagu inglise või mis iganes keeles sa tegelikult soovite saata mõne teise inimese. Ja siis ciphertext on rüselus et šifreeritud või krüpteeritud, versioonis. 

Aga seal on üks teine ​​koostisosa siin. On veel üks sisend salajase võtme krüptograafia. Ja see on võti ise, mis on üldiselt nagu me näeme, numbri või kirja või sõna, mida iganes algoritm on tegelikult ootab. 

Ja kuidas sa lahti informatsiooni? Kuidas te lahti harutama? Noh, sa lihtsalt vastupidine väljundeid ja sisendeid. 

Teisisõnu, kui keegi saab oma krüptitud kirja, ta lihtsalt peab teada, et sama võti. Nad on saanud ciphertext. Ja ühendades need kaks sisestavate krüpto süsteemi algoritmi, see must kast, välja peaks tulema originaal polegi. Ja nii see on väga kõrgel tasemel Arvestades seda, mida krüptograafia on tegelikult kõike. 

Nii lähme sinna. Olgem nüüd pilk all kapuutsi midagi oleme võtnud ette antud Viimase nädala ning selle seansi siin-- string. See string lõpus päeval on lihtsalt märgijada. 

See võib olla tere, või tere Zamyla, või mis iganes. Aga mida see tähendab, et olla märgijada? Tegelikult CS50 raamatukogu annab meil andmetüüp nimetatakse jada. 

Aga seal on tegelikult puudub sellist asja nagu string C. See on tõesti lihtsalt jada iseloomu, iseloomu, iseloomus, iseloomu, tagasi, tagasi, et tagasi, tagasi, tagasi sees arvuti mälu või mälu. Ja me vaatame sügavamale, et tulevikus, kui me vaatame mälu ise ja kasutamise ning ohud, mis on seotud. 

Aga Vaatleme jada Zamyla. Nii lihtsalt nime Inimese siin Zamyla, et on jada Märgid, Z-A-M-Y-L-A. Ja nüüd oletame, et Zamyla nimi on ladestunud arvuti programmi. 

Noh, siis loogiline, et me peaksime oleks võimalik vaadata neid tähemärki individuaalselt. Nii et ma lihtsalt lähen juhtida vähe kast ümber Zamyla nime siin. Ja see on nii C, et kui sa on string, nagu Zamyla-- ja võibolla et string on tulnud tagasi funktsioon nagu get string, saab tegelikult manipuleerida see tähthaaval. 

Nüüd on see Sobiv jaoks vestlus käepärast, sest krüptograafia kui te soovite muuta A B ja B C ja C-D, ja nii edasi, sa pead olema võimeline vaadata üksikute märkide string. Sa pead olema võimeline muutma Z midagi muud, A midagi muud, M midagi muud, ja nii edasi. Ja seega peame nii, programmiliselt, nii rääkida, C, et oleks võimalik muuta ja vaadata üksikuid tähti. Ja me saame seda teha järgmiselt. 

Lubage mul minna pea tagasi CS50 IDE. Ja las ma minna ja luua uus fail et ma helistan seekord string0, meie esimene selline näide, dot c. Ja ma lähen edasi minna ja vahusta see üles järgmiselt. 

Nii hulka CS50.h ja Seejärel lisada standard io.h, mis ma peaaegu alati läheb kasuta minu programmid, vähemalt esialgu. int main void ja siis siin ma olen kavatsevad teha stringid saab saada string. Ja siis ma lähen minna ja seda teha. Tahan minna ja kui mõistuse kontrolli, lihtsalt öelda, tere, protsendi s, semikoolon, teeb string 0. Uh oh, mida ma tegin siin? Oh, ma ei ühendage see. Nii õppetund, et ei olnud tahtlik. 

Nii viga, rohkem protsenti konversioone kui andmed argumente. Ja see on osa, kus line 7-- OK, nii et mul on, tsitaat lõppeb, mis on minu stringi printf. Mul protsendimärgiga. Aga ma puudu teine ​​argument. 

Ma puudu koma s, mis Ma olen oma varasemates näiteid. Nii hea võimaluse määrata veel üks viga, kogemata. Ja nüüd lubage mul juhtida string0, kirjuta Zamyla. OK, tere Zamyla. 

Nii oleme käivitada selline programm paar erinevat korda nüüd. Aga teeme midagi veidi erinev seekord. Selle asemel, et lihtsalt printimisel Zamyla on Kogu nime välja printf, teeme ära tähthaaval. 

Ma lähen kasutada jaoks silmus. Ja ma lähen annan end lugedes muutuja, mida nimetatakse i. Ja ma lähen hoida itereerimine, nii Niikaua kui i on väiksem kui pikkus s. 

Selgub, me ei teinud Selleks viimane kord, et c kaasas funktsiooni nimetatakse Stirling. Juba järgmisel päeval, ja üldiselt veel rakendamisel funktsioone, Inimestel on sageli valida väga sisutihedat nimed sellist heli nagu mida sa tahad, kuigi see on puudu mõned täishäälikud või tähed. Nii Stirling on funktsiooni nime, mis võtab argumendiks vahel Sulgudes mis peaks olema string. Ja see lihtsalt tagastab täisarvu pikkus, et string. 

Nii et see silmus real 7 läheb lugemise alustamiseks kell i võrdub 0. See saab juurdekasvu i iga iteratsiooni 1, kui me oleme teinud paar korda. Aga see läheb ainult teha Selle kuni hetkeni kui ma ei pikkusest string ise. 

Nii et see on viis lõpuks iterating üle tähemärki stringi, nagu ta on järgmine. Ma lähen välja trükkida ei ole Kogu stringi, kuid protsenti c, Ühe märgi järgneb uus liin. Ja siis ma lähen minna, ja mul on vaja öelda tahan printida nda iseloomu s. 

Nii et kui i on muutuja, mis näitab, indeks string, kus Te olete see, mul on vaja, et oleks võimalik öelda, anna mulle nda iseloomu s. Ja C on viisiks seda nurksulgudes. Sa lihtsalt öelda nime string, mis antud juhul on s. Siis saate kasutada nurksulgudes, mis on tavaliselt veidi üle oma Return või Sisesta klaviatuuril. Ja siis paned indeks märk, mida soovite printida. Nii indeks saab olema number-- 0 või 1 või 2 või 3, või dot, dot, dot, mõne muu number. 

Ja me tagada, et see läheb õige number, sest ma lugemise alustamiseks 0. Ja vaikimisi esimene märk string on kokkuleppeliselt 0. Ja teine ​​täht on sulg 1. Ja kolmas täht on sulg 2. Ja sa ei taha minna liiga kaugele, kuid me ei ole, sest me oleme läheb ainult juurdekasvu i, kuni see võrdub stringi pikkusena. Ja sel hetkel, Selle jaoks silmus peatub. 

Nii et lubage mul minna ja päästa see programmi ning run teha string 0. Aga ma silmamunad. Kaudselt kuulutatakse raamatukogu funktsiooni Stirling sellist tüüpi ja such-- nüüd, see tuttav. Aga see ei ole printf. Ja see ei saa string. 

Ma ei kruvi üles Samamoodi seekord. Aga märkate siin veidi alla Lisaks sisaldavad päise kaudu string, selgesõnaliselt anda deklaratsiooni Stirling. Seega on tegelikult aimugi seal. 

Ja tõepoolest selgub seal on veel päisefaili et me oleme ei kasutata klassis, aga see on nende hulgas saadaval teile, mida nimetatakse string. Ja selles failis string on Stirling tunnistada. Nii et lubage mul minna ja päästa see, et string 0-- kena, ei veateateid seekord. 

./string0 Zamyla ja Ma olen umbes Enter, misjärel getString läheb tagasi string, pane see s. Siis, et loop läheb itereerima Üle S tegelased ükshaaval, ja printida neid üks rea kohta, sest Mul oli, et backslash n lõpus. Nii et ma võiks jätta, et backslash n, ja siis lihtsalt printida Zamyla kõik sama liini, tõhusalt reimplementing printf, mis ei ole nii kasulik. Aga sel juhul, ma ei ole teinud. Olen tegelikult trükitud üks täht korraga, üks rea kohta nii et me tegelikult näha mõju. 

Aga ma peaks tähele üks asi siin. Ja me tuleme tagasi Seda tulevase nädalas. Selgub, et see kood on potentsiaalselt lollakas. 

Selgub, et get string ja mõned muud ülesanded elu ei pruugi alati tagasi, mida te ootate. Me teame klassi viimase aega selles, et saada string peaksid tagasi string. Aga mis siis, kui kasutaja tipib sellist pikk sõna või lõigu või essee et seal on lihtsalt ei piisa Mälu on arvuti sobitada see. 

Nagu, mis siis, kui midagi läheb vale all kapuuts? See ei pruugi juhtuda sageli kuid see võib juhtuda kord samal ajal, väga harva. Ja nii selgub, et get string ja funktsioone, nagu see ei pruugi alati tagasi stringid. Nad võivad naasta mõni viga väärtus, mõned valvur väärtust nii-öelda mis näitab, et midagi on valesti läinud. Ja siis oleks ainult tean, et see on olles õppinud klassis praegu või lugenud veel mõned dokumendid. Selgub, et get string võib naasta väärtus ehk null. Null on eriline väärtus, et me tagasi tulla tulevases nädalas. Aga nüüd, lihtsalt tean, et kui ma tahan olla tõesti õige viia edasi kasutades get string, ma ei tohiks lihtsalt nimetame seda, ja pimesi kasutada oma tagastatav väärtus, uskudes, et see on string. 

Ma peaks kõigepealt öelda, Hei, oota üks hetk, vaid jätkata, kui te ei võrdu null, kus null jällegi on vaid mõned eriline väärtus. Ja see on ainus eriline väärtus, mida vaja muretseda get string. Saada string kas läheb tagasi string või null. 

Ja see hüüumärk võrdusmärki võite teame võibolla matemaatika klassi et võite juhtida võrdusmärk koos läbikriipsutatud näidata ei ole võrdsed. See ei ole tavaliselt märk saate tippida klaviatuuril. Ja nii enamikes programmeerimiskeeltes, kui sa tahad öelda ei ole võrdsed, kasutate hüüumärk, muidu tuntud pauk. Nii sa ütled bang võrdub, mis tähendab mitte võrdub loogiliselt. See on nagu seal ei ole suurem kui või võrdne või väiksem kui või võrdne klahvi et see kõik on üks sümbol. Nii et see, miks varem näiteid, sa tegid avatud sulg ja seejärel võrdusmärk, et teha suurem või, ütleme, vähem kui. 

Mis siis Buffee siin? See on lihtsalt nii nüüd on kehtestades selle süntaksit, see funktsioon, iterating üksikult märkide jada. Ja nagu need, kandiline Sulgudes võimaldab teil saada neid, arvestama nurksulgudes nagu Selline vihjab sellele aluseks oleva disain, kusjuures iga märgi sees string on selline pakendada kusagil all kapoti arvuti mällu. 

Kuid olgem teha variant sellest. Selgub, et see Programm on õige. Nii ühe CS50 teljed hindamiseks kood, see on õige nüüd. Eriti nüüd, et ma olen kontrollimine null, see programm peaks kunagi krahhi. Ja ma lihtsalt tean, et kogemustest. Aga seal on midagi muud, mis saame tõesti minna valesti. Aga see ei ole väga hästi läbi mõeldud, sest lähme tagasi põhitõdesid. 

Esiteks principles-- Mis siis silmus teha? Jaoks silmus teeb kolme asja. See käivitab mõne väärtust, kui te küsite seda. Ta kontrollib tingimus. Ja siis pärast iga korduse pärast iga tsükli see kasvatab mõned väärtuse või väärtused, siin. 

Mida see tähendab? Me initsialiseerida i kuni 0. Me kontrollime ja veenduge i on väiksem kui pikkus s, mis on Z-A-M-Y-L-A, nii mis on vähem kui 6. Ja tõepoolest, 0, sest alla 6. 

Me printida Z alates Zamyla nime. Siis juurdekasvu i 0-1. Siis vaadake, on 1 vähem kui pikkus s? Pikkus s on 6. Jah see on. 

Nii et me printida ka Zamyla nimi, ZA. Me juurdekasvu i 0, 1, 2. Siis vaadake, on 2 alla pikkus Zamyla nime. 6- nii 2 on vähem kui 6. Jah, lähme välja trükkida nüüd M Zamyla nimi, kolmas tähemärk. 

Peamine on, et iga iteratsiooni lugu, ma kontrollida, on i vähem kui pikkus Zamyla? Aga saak on, et Stirling ei ole vara. Neile, kes on programmeeritud Enne Java või teistes keeltes tunneksid pikkus string vara, vaid mõned read only väärtus. 

In C sel juhul, kui see on funktsioon, mis on sõna otseses mõttes loendades tegelased Zamyla iga kord me nimetame seda funktsiooni. Iga kord, kui te küsite arvuti kasutamise Stirling, see võtab pilk Zamyla, ja öelda Z-A-M-Y-L-A, 6. Ja ta naaseb 6. Järgmine kord, kui helistada see sees, et loop, see saab vaadata Zamyla jälle öelda Z-A-M-Y-L-A, 6. Ja see läheb tagasi 6. Mis siis loll selle kujundus? 

Miks on minu kood ei ole 5 out of 5 projekteerimise kohe, kui nii võib öelda? Noh, ma küsib Küsimus asjatult. Ma teen rohkem tööd kui mul on vaja. 

Nii kuigi vastus on õige, ma olen küsib arvuti, mis on pikkus Zamyla jälle ja uuesti ja uuesti ja uuesti? Ja see vastus on muutu kunagi. See on alati saab olema 6. 

Nii on parem lahendus kui see oleks see järgmine versioon. Lubage mul minna ja pane see eraldi faili nimega string1.c, lihtsalt hoida eraldi. Ja selgub, on ette loop, saab tegelikult Kinnitan mitu muutujat korraga. 

Nii et ma lähen hoida i ja pani 0. Aga ma kavatsen ka Koma, ja öelda, mulle muutuja nimega n, kelle väärtus on string pikkusega s. Ja nüüd, palun teha oma seisundi niikaua i on väiksem kui n. 

Nii et sel viisil, loogika on identsed lõpus päeval. Aga ma olen mäleta väärtus 6, antud juhul. Mis on pikkus Zamyla nimi? Ja ma panen seda n. 

Ja ma olen ikka kontrollida tingimusel, iga kord. Kas 0 alla 6? Kas 1 alla 6? Kas 2 alla 6, ja nii edasi? 

Aga Ma ei palu arvuti uuesti ja uuesti, mis on pikkus Zamyla nimi? Mis on pikkus Zamyla nimi? Mis on pikkus selle Zamyla nimi? Ma sõna otseses mõttes pea meeles, et esimene ja vastata ainult selles teises muutuja n. Nii et see nüüd oleks mitte ainult õige, vaid ka hästi läbi mõeldud. 

Nüüd, kuidas stiil? Olen nimega minu muutujad päris hästi, ma ütleks. Nad super sisutihedat kohe. Ja see on täiesti korras. 

Kui teil on ainult üks stringi programmi võite ka seda nimetada s string. Kui teil on ainult üks muutuja loendamiseks programmi võite ka kutsuda i. Kui teil on pikkus, n on super ühine samuti. Aga ma ei ole kommenteeris mõnda minu koodi. 

Ma ei ole teatanud reader-- kas see on minu TF või TA, või lihtsalt colleague--, mis peaks tuleb toimub selle programmi. Ja nii, et saada hea stiil, mida ma tahan teha on see-- midagi nagu küsida kasutaja sisend. Ja ma võiks kirjutada Selle väga mitmel viisil. 

Veenduge, S- veenduge get string tagasi string. Ja siis siin-- ja see on võib-olla kõige olulisem comment-- Kerrata üle tähemärki s ühe korraga. Ja ma võiks kasutada ükskõik valik inglise keeles siin kirjeldada iga nende tükkideks koodi. 

Pange tähele, et ma ei ole esitanud kommenteerida iga rida koodi, tõesti lihtsalt huvitav need on need, mis mõned tähenduses, et ma võin tahad teha super selge, et keegi lugemine minu koodi. Ja miks sa helistad saada string küsida kasutaja sisend? Isegi, et üks ei ole tingimata kõik, mis kirjeldavad. Aga see aitab rääkida lugu, sest Teine rida lugu, veenduge, saada string tagasi string. 

Ja kolmas rida selles loos on, Käi tähemärki on üks korraga. Ja nüüd lihtsalt hea meede, Ma lähen edasi minna ja lisada veel üks kommentaar, et lihtsalt ütleb print i-nda tegelaskuju s. Nüüd, mida ma olen teinud Päeva lõpuks? 

Olen lisanud mõned inglise sõnad kujul kommentaarid. Kaldkriips kaldkriipsuga sümbol tähendab, hei, arvuti see on inimese, ei ole teie jaoks, arvuti. Nii nad ignoreerinud loogiliselt. Nad on lihtsalt olemas. 

Ja tõepoolest, CS50 IDE näitab neid hall, mis on kasulikud, kuid mitte peamine programmile. Pane tähele, mida saab nüüd teha. Kas sa tead C programmeerimise või mitte, siis lihtsalt seisma tagasi selle programmi ja koorima kommentaare. Küsi kasutaja sisend, veenduge, saada string tagasi string Käi tähemärki s ükshaaval, printida iseloomu i-nda tegelaskuju S- sa seda ei tee isegi vaadata koodi aru saada, mida see programm teeb. Ja veel parem, kui sa ise otsida See programm nädal või kaks, või kuus või aastas sinagi ei ole vahtima koodi püüab meeles pidada, Mida ma üritan teha selle koodi? 

Olete rääkinud ise. Olete kirjeldas seda ise, või mõne kolleegi või TA või TF. Ja nii see oleks nüüd õige ja hea disain, ja lõpuks hea stiili ka. Nii et hoidke seda silmas pidades. 

Nii et üks teine asi, mida ma lähen tegema siin mida saab nüüd paljastada millised täpselt toimub all kapuuts. Nii et seda funktsiooni C ja teistes keeltes, nimetatakse typecasting et kas kaudselt või kaudselt võimaldab teisendada ühest andmete tüübist teise. Me oleme arutanud nii palju täna stringid. 

Ja stringid on tähemärki. Aga mäletate nädal 0, millised on tegelased? Tegelased on vaid abstraktsioon peal numbers-- kohaga numbrid, ja kohaga numbrid on tõesti ainult võtmiseks peal kahendsüsteemile, nagu me määratleda seda. 

Nii tegelased on numbrid. Ja numbrid on tegelased, lihtsalt sõltuvalt kontekstist. Ja selgub, et sees arvutiprogrammi, saab määrata, kuidas soovite otsida kell bitti sees, et programm? 

Meenuta nädal 0, et meil oli Ascii, mis on just see kood kaardistamine kirju numbrid. Ja me ütlesime, kapitali A on 65. Capital B on 66, ja nii edasi. 

Ja teate, meil sisuliselt on sümbolite kohta esirea siin, nagu C kutsuksin neid, tegelased ja seejärel ints teises reas. Ja selgub, saate teisendada sujuvalt kahe, tavaliselt. Ja kui me tahame teha See teadlikult, me Võiksid tegeleda midagi sellist. 

Me võime soovite teisendada suur- alandada juhul, või madalam suurtähtedega. Ja selgub, et tema tegelikult muster siin saame omaks vaid hetkeks. Aga vaatame kõigepealt juures Näiteks seda teha selgelt. 

Ma lähen tagasi CS50 IDE. Ma lähen, et luua fail nimega Ascii 0.c. Ja ma lähen edasi minna ja lisan standard io.h tipus, int main void ülaosas oma funktsiooni. Ja siis ma lihtsalt teha following-- jaoks silmus alates i võrdub, oletame, 65. 

Ja siis ma ei kavatse olla väiksem kui 65, pluss 26 tähte tähestikus. Nii et ma lasen arvuti teha matemaatika minu jaoks olemas. Ja siis sees silmus, Mis ma nüüd välja printida? 

% C on% i kurakaldkriipsuga n. Ja nüüd ma tahan ühendada kaks väärtust. Olen ajutiselt panna küsimus tähistab seal kutsuda küsimus. 

Ma tahan kinnitada, alates 65 aastast 26 tähestiku tähti, väljatrükk iga iteratsiooni, et tegelase lahutamatu samaväärne. Teisisõnu, ma tahan Käi 26 numbrid trükkimine Mis ASCII on kirjas, ja mida vastav number on-- tõesti ainult taasloomine graafikus, et slaidi. Mida peaks neid küsimärke olla? 

Noh, selgub, et teine üks peaks olema ainult muutuja i. Ma tahan näha, et kui number. Ja keset argument siin võin öelda arvuti ravida, et täisarv i kui märki, nii nagu asendada see siin protsenti C. 

Teisisõnu, kui I Inimese programmeerija, tean need on vaid numbrid Päeva lõpuks. Ja ma tean, et 65 peaks map teatud iseloomu. Selle selgesõnaline valatud, koos sulgudes nimi andmete tüübi soovid teisendada ja suletud sulgudes Võite öelda arvuti, hei, arvuti, teisendada see täisarv süsi. 

Nii et kui ma saan seda programmi pärast koostamisel, Vaatame, mida ma saame-- teha Ascii 0. Darn see, mida ma valesti tegin siin? Kasutage deklareerimata tunnus kõik korras, ei olnud tahtlik, aga vaatame, kui me ei saa Põhjus selle kaudu. 

Nii line five-- nii et ma ei saa väga palju enne kruvimiseks üles. See on OK. Nii line 5 i võrdub 65-- näen. Seega pidage meeles, et C, erinevalt mõnest keeles, kui teil on eelneva programmeerimine kogemus, siis on öelda arvutis Erinevalt Scratch, mida tüüpi muutuja see on. 

Ja ma unustasin oluline lause siin. Kooskõlas viis, ma olen hakanud kasutama i. Aga ma ei öelnud C Mis andmete tüübi see on. Nii et ma lähen siin ja öelda, ah, oleks täisarv. 

Nüüd ma lähen edasi minna ja uuesti kompileerida. See fikseeritud, et. ./ascii0 Sisesta, see on selline lahe. Mitte ainult see on super kiire küsi arvuti sellele küsimusele, pigem otsin ta üles slaidil, see välja trükkida üks rea kohta, A on 65, B on 66, kõik viis down-- kuna ma tegi seda 26 korda-- kirjadele z, mis on 90. Ja tegelikult veidi arukamaid oleks on olnud minu jaoks mitte tugineda arvutis lisada 26. Ma oleks võinud lihtsalt teha 90 ka, nii kaua kui ma ei tee sama viga kaks korda. Ma tahan minna kuni kaudu z, mitte ainult üles läbi y. 

Nii et selgesõnalise valatud. Selgub, et see ei ole isegi vajalik. Lubage mul minna ja uuesti, see tõlkija ja kordamisega Ascii 0. Selgub, et C on päris tark. 

Ja printf, eelkõige on päris tark. Kui sa just sooritama i kaks korda nii kohatäitjaid, printf saad aru, oh, noh, ma tean, et sa andis mulle integer-- mõned number, nagu 65 või 90 või mis iganes. Aga ma näen, et sa tahad, et vormingus, mis number nagu iseloomu. Ja nii printf võib kaudselt heita int, et char ka teid. Nii et see ei ole probleem üldse. 

Aga märgata, sest see võrdväärsuse me tegelikult võite seda teha ka. Lubage mul minna ja teha üks teiste versioon see-- Ascii 1.c. Ja selle asemel, iterating üle täisarvud, võib tõesti löök meelt iterating üle tähemärki. Kui char c saab kapitali A, ma tahan minna ja teha seda, niikaua C on väiksem või võrdne kapitali Z. Ja iga iteratsiooni Tahan juurdekasvu C, suudan Nüüd minu printf line siin ütleme, protsendi C on protsenti i uuesti komaga C. 

Ja nüüd, ma ei saa minna teise suunda, casting iseloomu selgesõnaliselt täisarv. Niisiis, jälle, miks sa seda teed? See on natuke imelik, et mingisugune loe mõttes märki. 

Aga kui sa aru saada, mis on toimub all kapuuts, seal on tõesti mingit maagiat. Sa oled lihtsalt öeldes, hei, arvuti annab mulle muutuja nimega C tüüpi char. Vorminda seda kapitali A. Ja märgata ülakoma asi. 

Sest tähemärki C, tagasikutsumise Eelmisel nädalal sa Kasutada ülakoma. Keelpillidele, sõnu, laused, mida kasutate jutumärkide. OK, arvuti, hoida seda teed, et Niikaua kui iseloomu on alla või võrdne z. Ja ma tean, minu Ascii laua, et kõik Nende Ascii koode piirnevad. 

Ei ole mingit puudust. Nii et see on lihtsalt läbi Z, eraldatud ühe numbri kaupa. Ja siis ma saan juurdekasvu süsi, kui ma tõesti tahan. Päeva lõpuks, see on lihtsalt number. Ma tean seda. Nii et ma lihtsalt eeldada, et lisada 1 kuni ta. 

Ja siis seekord ma printida c, ja siis lahutamatu samaväärne. Ja ma ei pea isegi selgesõnalise valatud. Ma ei lase printf ja arvuti välja mõtlemiseks, nii et nüüd, kui ma saan teha Ascii1./ascii1, Ma saan täpselt sama asi ka. 

Kasutu programm, though-- keegi läheb tegelikult kirjutada tarkvara selleks, et aru saada, milline oli number, mis kaardistab A või B või Z? Sa lihtsalt läheb Google, või otsida see üles online, või otsida see üles slaidil vms. Nii et kui see tegelikult saada kasulikku? 

Noh, rääkides, et slaidi märgata seal tegelik muster siin suur- ja väiketähed, mis ei olnud juhuslik. Pange tähele, et kapitali A on 65. Väiketähed a on 97. Ja kui kaugel on madalam juhul? 

Nii 65 on mitu sammu kaugusel 97? Nii 97 miinus 65 on 32. Nii kapitali a on 65. Kui lisate 32, et saad väiketähed a. Ja võrreldavalt kui te lahutama 32, saad tagasi kapitali a-- sama B vähe b, suur C vähe c. 

Kõik need puudujäägid on 32 peale. Nüüd tundub see võimaldab meil midagi nagu Microsoft Word, või Google Docs funktsioon, kus te saab valida kõike ja siis öelda, muuta kõik väiketähed või muuta kõik suurtähtedega, või muuta ainult ühe sõna Lause suurtähtedesse. Me ei saa tegelikult midagi niimoodi ise. 

Lubage mul minna ja salvestada faili siin nimetatakse ära 0.c. Ja olgem minna ja klopsima programmi et just selline järgmiselt. Nii hõlmavad CS50 raamatukogu. Ja hulka standard I / O. 

Ja ma tean, et see on tulemas. Nii et ma lähen pane see seal juba, string, nii et mul on juurdepääs asjad Stirling, ja siis int main void, nagu tavaliselt. Ja siis ma lähen edasi minna ja teha stringid saab saada string, lihtsalt saada string kasutaja. Ja siis ma lähen teen meelerahu kontrolli. Kui string ei võrdu null, siis see on ohutu sõita. Ja mida ma tahan teha? Ma lähen itereerima alates i võrdub 0, ja n kuni stringi pikkus s. 

Ja ma teen seda nii kaua, kui i on väiksem kui n ja i pluss pluss. Siiani ma olen tõesti lihtsalt laenates ideid enne. Ja nüüd ma lähen tutvustada filiaal. 

Nii arvan, et tagasi Scratch, kus meil oli neid kahvlid maantee, ja eelmisel nädalal C. ma lähen ütlen seda, kui i-nda tegelaskuju s on suurem või võrdne alandada juhul, Ja-- Scratch teil oleks sõna otseses mõttes öelda ja, kuid C ütled ampersand, ampersand-- ja i-nda tegelaskuju s on väiksem või võrdne väiketähtedesse z, teeme midagi huvitavat. Olgem tegelikult välja trükkida sümbol ei reavahetus mis on märk String, i-nda tegelaskuju string. 

Aga lähme edasi ja lahutama 32 ta. Või kui märk string et ootame ei ole vahel pisuke ja vähe z, edasi minna ja lihtsalt trükitud seda muutmata. Nii oleme kasutusele see sulgudes märge meie stringid saada on i-nda tegelaskuju string. 

Olen lisanud mõned tingimisi loogika, nagu Scratch eelmisel nädalal nädalas üks, kus Ma lihtsalt kasutades oma põhiõigusi arusaam sellest, mis on toimub all kapuuts. Kas i-nda iseloomu s suurem või võrdne? Nagu, see on 97 või 98, või 99, ja nii edasi? 

Aga see ka väiksem või võrdne väärtusega väiketähed z? Ja kui nii, siis mida see rida tähendab? 14, see on omamoodi idu kogu idee, ära kirja teel lihtsalt lahutades 32 sellest, sel juhul, sest ma tean, per et skeem, kuidas minu numbrid on esindatud. Nii saab minna ja käivitada, pärast koostamisel ära 0.c, ja joosta ära 0. 

Olgem kirjuta midagi Zamyla kõik väiketähed sisestada. Ja nüüd on meil Zamyla kõigis suur-. Olgem kirjuta Rob kõik väiketähed. Proovime Jason väiketähtedega. Ja me hoiame saada sunnitud kapitaliseeritust. Seal on väike viga, et ma Selline ei osatud ette näha. Pane tähele minu uus kiire on lõpetades samal joonel nende nimed, mis tundub natuke segane. 

Nii et ma lähen siin, ja tegelikult lõpul selle programmi prindi välja reavahetuse märk. See on kõik. Mis printf, siis ei pea liigu muutujate või formaadis koodi. Võid sõna otseses mõttes lihtsalt printida midagi reavahetus. 

Nii saab minna ja teha ära 0 uuesti, uuesti, see, Zamyla. Ja nüüd on see natuke ilusam. Nüüd, minu kiire on omal uus liin. Nii et kõik on hästi ja hea. Nii et see on hea näide. Aga ma isegi ei pruugi vaja kõvasti kood 32. Tead mida? Ma võiks say-- Ma ei ole kunagi mäleta, mis vahe on. 

Aga ma tean, et kui ma on väiketäht, Ma põhimõtteliselt taha lahutada maha olenemata vahemaa on väike A ja suur, sest kui ma eeldan, et kõik teised tähte on samad, mis peaks tööd teha. Aga mitte seda teha, sa tead, mida? Seal on veel üks võimalus veel. 

Kui seda ära 1.c-- kui ma panna, et eraldi faili. Teeme ära 2.c järgmiselt. Ma tõesti puhastada seda siin. Ja selle asemel, et isegi võttes tea või hoolivad neile madal rakendamise üksikasju, ma olen selle asemel lihtsalt läheb print iseloomu, tsitaat lõppeb, protsendi C ja siis helista teine ​​funktsioon, mis olemas, mis võtab argumendiks, mis on märk, niimoodi. 

Selgub, C, seal on teine ​​funktsioon kõne ülemiste, mis nagu nimigi soovitab võtab iseloomu ja teeb oma suur- samaväärne, ning tagastab nii et printf saab ühendage see seal. Ja nii, et seda teha, aga ma vaja kehtestada ühe teise faili. Selgub, et on veel üks fail et siis oleks ainult teada, klass, või õpik või online viide, mida nimetatakse C type.h. 

Nii et kui ma lisan, et kuni üks minu päise kaudu faile, ja nüüd uuesti kompileerida selle programmi capitalize2, ./capitalize2 Enter. Olgem kirjuta Zamyla kõik väiketähed, töötab sama. Aga tead mis? Selgub, et ülemiste on mõned muud funktsioonid. 

Ja lubage mul tutvustada selle käsin siin mingi kohmakalt nimed, kuid mees käsitsi. Selgub, et kõige Linux arvuteid, kui me kasutame siin-- Linux operatsioonisüsteemi süsteemis endale valda nimetatakse meest, mis ütleb, hei, arvuti, anna mulle arvuti kasutusjuhendist. Mida sa tahad otsida, et käsitsi? 

Tahan otsida funktsiooni kutsutud ülemine, Enter. Ja see on natuke segasena loe mõnikord. Aga märka me ka Linux programmeerija käsitsi. Ja see on kõik teksti. Ja märgata, et seal on funktsiooni nimi siia üles. Selgub, ta on sugulane nimega alandada, mis teeb vastupidist. Ja teate all sünopsis, et kasutada seda toimida mees lehel, nii et rääkida, räägib mulle, et ma vaja lisada c type.h. Ja ma teadsin, et praktikast. 

Siin, see näitab mulle kahe prototüüpide funktsiooni nii et kui ma kunagi soovi seda Ma tean, mida nad võtavad sisendiks ja mida nad tagasi väljundiks. Ja kui siis lugesin kirjeldamise, ma näen täpsem funktsioon teeb. Kuid mis veelgi tähtsam, kui Ma vaatan alla tagastatav väärtus, ta ütleb väärtus tagastatakse on mis on ümber kirjas, või C, originaal sisend, kui konverteerimise ei olnud võimalik. 

Teisisõnu, ülemise püüab teisendada kirja suurtähtedega. Ja kui nii, siis läheb see tagasi. Aga kui seda ei saa mingil reason-- äkki see on juba suurtäht, võibolla on hüüumärk või mõne muu punctuation-- see on lihtsalt läheb tagasi algse C, mis tähendab Saan koodi parem disainiti järgmiselt. 

Ma ei pea kõiki Nende paganama rida koodi. Kõik read Olen lihtsalt esile ei kokku tõmmata vaid üks lihtne line, mis on see-- printf protsenti c ülemiste S sulg i. Ja see oleks Näiteks parema disainiga. 

Miks rakendama 7 või 8 rida koodi, mis iganes see oli mul lihtsalt kustutada, kui sa saad selle asemel variseda kõik selle loogika ja otsuste tegemisel ühte rida, 13 nüüd, et toetub raamatukogu funktsioon-- funktsioon, mis on varustatud C, kuid see ei täpselt, mida sa tahad seda teha. Ja ausalt öeldes, isegi kui see ei tulnud C, siis võiks rakendada seda ise, kui oleme näinud, kus saan negatiivse int ja saada positiivne int eelmisel nädalal samuti. 

See kood on praegu palju paremini arusaadavaks. Ja tõepoolest, kui me üleskerimiseks vaata kui palju kompaktsem Selle versiooni minu programm on. See on veidi tsentraliseeritud nüüd, kõik need kuuluvad. Aga see on OK, sest nüüd olengi õlgadele programmeerijad enne mind. Ja kes see oli, kes rakendatud ülemise tõesti tegi mulle teene, meelega iganes rakendatud Stirling tõesti tegi mulle teene mõni aeg tagasi. Ja nii nüüd on meil parem disain programm mis rakendab täpselt sama loogika. 

Rääkides Stirling, las mul minna ja seda teha. Lubage mul minna ja päästa see pilt stirling.c. Ja selgub, saame koorida tagasi üks teine ​​kiht päris lihtsalt nüüd. Ma lähen edasi minna ja piits kuni teise programmi peamine siin, et lihtsalt uuesti rakendab string pikkusega järgmiselt. Nii et siin on rida koodi, mis saab mind string kasutaja. Hoiame kasutades seda ikka ja jälle. Annan endale muutuja nimega n-tüüpi int, mis talletab number. 

Ja las ma minna ja teha järgmist loogikat. Kuigi n-nda tegelaskuju s teeb ei võrdu backslash 0, edasi minna ja juurdekasvu n. Ja siis välja printida printf protsenti i n. Väidan, et see programm siin, kutsumata string pikkusega, arvud, pikkus string. 

Ja magic on täiesti kapseldatud rida 8 siin sellega, mis näeb välja nagu uus süntaks, See backslash 0 ülakoma. Aga miks see nii on? Noh, kaaluma, mida on olnud toimub kogu aeg. 

Ja kui kõrvale, enne kui ma unustan, mõistad ka, et lisaks manuaalilehekülgedest et tulla tüüpiline Linux nagu CS50 IDE, aru, et meie, Muidugi töötajad, on ka teinud veebileht versioon Selle sama mõte nimetatakse reference.cs50.net, mis on kõik need samad man-lehekülgi, kõik sama dokumentatsiooni, samuti natuke ülaosas, mis võimaldab teisendada kõik üsna kauge keelde ebamugavamate režiim, kus me, õppejõudude, läbi käinud ja püüdnud lihtsustada mõned keele hoida asjad keskendunud ideid, mitte mõned tehnilised. Nii meeles pidada, reference.cs50.net teise ressursi samuti. 

Aga miks ei string pikkusega töö Muide Tegin hetk tagasi? Siin Zamyla nime uuesti. Ja siin on Zamyla nimi pakendada, nagu ma hoida teed, et maalida seda on, tõesti, lihtsalt märgijada. Aga Zamyla ei ole olemas eraldi programmis. 

Kui sa kirjutada ja käivitada programmi te kasutate Mac või arvuti mälu, või RAM nii rääkida. Ja sa ei mõtle arvuti, millel palju gigabaiti mälu nendel päevadel. Ja kaarik tähendab miljardeid nii miljardeid baiti. 

Kuid olgem kerida ajas. Ja oletame, et me kasutame tõesti vana arvuti, mis ainult 32 baiti mälu. Ma võiks minu arvuti ekraanil, lihtsalt juhtida seda läbi järgmiselt. 

Ma võiks lihtsalt öelda, et minu arvutis on kõik see mälu. Ja see on nagu pulk mälu, kui te mäletate meie pilt viimast korda. Ja kui ma lihtsalt jagada seda piisavalt korda, Väidan, et mul on 32 baiti mälu ekraanil. 

Nüüd, tegelikult võin ainult juhtida seni seda ekraani siin. Nii et ma lähen edasi minna, ja lihtsalt kokkuleppeline juhtida oma arvuti mälus kui võrku, mitte ainult ühe sirge. Nimelt ma väita, et nüüd, See võre, see 8 4 võrku lihtsalt esindab kõiki 32 baiti vaba mälu minu Mac, või saadaval minu arvuti. Ja nad ümbriste edasi kaks rida, vaid sest see sobib rohkem ekraanil. Aga see on esimene bait. See on teine ​​bait. See on kolmas bait. 

Ja see on 32. bait. Või kui me arvame, nagu arvuti teadlane, see on bait 0, 1, 2, 3, 31. Nii on 0 kuni 31, kui hakkate lugedes 0. 

Nii et kui me kasutame programmi et kõned saada string, ja saame stringi inimese nagu ma nimega Zamyla, Z-A-M-Y-L-A kuidas maailmas teeb arvuti jälgida, millist bait, mis patakas mälu, kuulub mille string? Teisisõnu, kui me suunduda kirjuta teise nime arvutisse, niimoodi Andi, kutsudes saada string teist korda A-N-D-I on sattuda arvuti mälu samuti. Aga kuidas? 

Noh, selgub, et all hood, mida C teeb, kui stringide salvestamiseks et inimese liigid, või et tulevad mõnest muust allikast, on see delineates lõppu neile eriline character-- backslash 0, mis on just erilisel moel öelda 80 bitti järjest. 

Nii a-- see on number 97 tagasivõtmist. Nii mõned muster 8 bitti esindab kümnendnumbrina 97. See backslash 0 on sõna otseses mõttes arv 0 teise nimega Nul, N-U-L, erinevalt varem N-U-L-L, mis me rääkisime. Aga nüüd, lihtsalt tean, et see backslash 0 on ainult 80 bitti järjest. 

Ja see on lihtsalt see joon liiva, mis ütleb midagi vasakule kuulub üks string, või ühe andmetüübi. Ja midagi õige kuulub midagi muud. Andi nime, vahepeal mis lihtsalt visuaalselt juhtub murrab edasi teistele line, aga see on ainult esteetiline detail, Samamoodi on Nul lõpetada. 

See on stringi A-N-D-I märki, lisaks viies salajase iseloomu, kõik 0 bitti, et lihtsalt piiritleb lõpuks Andi nime ka. Ja kui me nimetame saada string kolmandat korda arvuti saada string nagu Maria, M-A-R-I-A, sarnaselt on Maria nimi Nul lõpetada backslash 0. 

See on täiesti erinev sellest, kuidas arvuti on tavaliselt talletada täisarv või sularahaga või muu andmetüübid ikka, sest turult, täisarv on tavaliselt 32 bitti või 4 baiti, või isegi 64 bitti, või kaheksa baiti. Kuid paljud primitiivide arvutis programmeerimiskeelt on kindel arv baiti all hood-- võibolla 1, võibolla 2, võibolla 4, võibolla 8. 

Aga stringid, mille konstruktsioon, on dünaamiline arvu märke. Sa ei tea ette, kuni Inimese liigid Z-A-M-Y-L-A, või M-A-R-I-A või A-N-D-I. Sa ei tea mitu korda kasutaja saab löögi klaviatuuri. Seega, sa ei tea, kuidas palju märke ette sa lähed vaja. 

Ja nii C lihtsalt selline jätab nagu saladus riivsai all kapuuts lõpus stringi. Pärast ladustamiseks Z-A-M-Y-L-A mälust Samuti lihtsalt paneb samaväärne perioodi. Lõpus lause, see paneb 80 bitti, nii meeles pidada, kus Zamyla algab ja lõpeb. 

Mis siis ühendus siis, et see programm? See programm siin, Stirling, on lihtsalt mehhanism saada string kasutaja, rida 6. Line 7, ma kuulutada muutuja nimetatakse n ja seada see võrdub 0. 

Ja siis vastavalt 8, ma lihtsalt küsis küsimus, samas kui n-nda tegelane teeb ei ole võrdsed kõik 0 bits-- teisisõnu ei võrdub see eriline iseloomu, backslash 0, mis oli lihtsalt, et erilist Nul character-- minna ja lihtsalt juurdekasvu n. 

Ja hoida teeme seda ja hoida tee seda, ja hoida seda teevad. Ja nii kuigi Varem oleme kasutanud i, see on täiesti trahvi semantiliselt kasutada n, kui sa püüad lihtsalt loota seekord teadlikult, ja tahan seda kutsuda n. Nii see lihtsalt hoiab küsib küsimuse, on n-nda iseloomu s kõik 0.? Kui ei, siis vaadatakse järgmist ilme, vaatame edasi, vaatame järgmisel, vaadatakse järgmist. 

Aga niipea, kui sa näed backslash 0, See loop-- line 9 kuni 11-- peatub. Sa murda samas silmus, jättes sees, et muutuja n Total count Kõike märkide jada nägid, seeläbi lasta välja trükkida. Nii proovime seda. 

Lubage mul minna ja ilma abil Stirling funktsiooni aga lihtsalt kasutades oma kodumaine versioon siin nimetatakse Stirling, lubage mul minna ja joosta Stirling, kirjuta midagi nagu Zamyla, mida ma tean ette on kuus tähemärki. Vaatame, kas see toimib. Tõepoolest, see on kuus. Proovime koos Rob, kolm märki, kolm märki ka, ja nii edasi. Nii et kõik, mis läheb kohta all kapuuts. Ja märgata seoseid, Seejärel, esimese nädala klassi, kus me rääkisime midagi võtmiseks, mis on just see kihilisus ideede või keerukust, peal põhimõtteid. Siin me oleme omamoodi vaadates all kapuuts Stirling, niiöelda, et aru saada, kuidas oleks seda rakendatakse? 

Ja me võiks uuesti rakendada ise. Aga me kunagi läheb uuesti rakendada Stirling. Me lihtsalt läheb kasuta Stirling, et tegelikult saada mõned stringid pikkus. 

Aga seal ei ole magic all kapuuts. Kui tead, et all Kapoti string on lihtsalt märgijada. Ja see märgijada kõik on võimalik arvuliselt adresseeritud sulg 0, sulg 1, sulg 2, ja te tean, et lõpus string on erilist iseloomu, saate aru saada kuidas seda teha kõige midagi on programmi, sest kõik taandub on lugemine ja kirjutamine mälu. See tähendab, et muutuvas ja otsin kell mälu, või liigub asju ringi mälu, trükkimine asju ekraanil, ja nii edasi. 

Nii saab nüüd kasutada seda taasleitud arusaam sellest, mida stringid tegelikult on all kapuuts, ja koorida tagasi üks teine ​​kiht et seni me oleme olnud ignoreerides täielikult. Eelkõige igal ajal oleme rakendanud programmi oleme olnud seda rida koodi ülaosas kuulutatakse peamine. Ja me oleme määratud int main void. 

Ja see tühine sulgude sees on öelnud kõik see aeg, et peamine ise ei võta mingeid argumente. Iga sisend, et peamine on hakka kasutaja peab tulema mõnest muust mehhanism, nagu get int, või saada float või saada string, või mõni muu funktsioon. Aga selgub, et kui sa kirjutada programm, saab tegelikult määrata et nimetatud programm võtta sisendeid inimese käsurea ise. 

Teisisõnu, kuigi me siiani käinud lihtsalt ./hello tere või sarnased programmid, kõik muud programmid, mis me oleme kasutanud, et me ise ei kirjuta, on võtnud, tundub, käsurea arguments-- asju nagu make. Sa ütled midagi teha, ja siis teine ​​sõna. Või clang, ütlete kolisevad ja seejärel teine ​​sõna on faili nime. 

Või isegi RM või CP, nagu võite näinud või kasutada juba eemaldada või kopeerida. Kõik need võtta nn käsurea arguments-- lisasõnadega terminali kiire. Aga siiani oleme ise ei ole olnud seda luksust võtta panus kasutajale, kui ta tegelikult töötab programm ise käsurea. 

Aga me saame teha, et uuesti deklareerides Peamised liigub edasi, mitte võttes kehtetuks sulgudes aga need kaks argumenti instead-- esimene täisarv, ja teine ​​midagi uut, midagi, mida me ei kavatse helistada massiivi, midagi sarnast vaimu mida nägime Scratch loeteluna, kuid massiivi stringe, nagu me varsti näha. Aga vaatame seda Näitena enne me eristada täpselt, mida see tähendab. 

Nii et kui ma minema CS50 IDE Siin ma olen läinud edasi ja deklareeritud fail nimega argv0.c järgmist malli. Ja märgata ainus asi mis on erinev nii kaugele on see, et ma olen muutunud tühiseks int Argc string argv avatud sulg lähedal sulg. Ja teate nüüd, seal on midagi sees need sulgudes. 

Ei ole number. Ja pole mingit i või n, või mis tahes muu täht. Ma lihtsalt abil nurksulgudes nüüd, põhjustel me tuleme Tagasi vaid hetkeks. 

Ja nüüd, mida ma lähen tegema, on see. Kui Argc võrdub võrdub 2-- ja meenutada, mis võrdub võrdsete on võrdsus operaator võrrelda vasakule ja paremale võrdõiguslikkuse eest. See ei ole loovutamise operaator, mis on ühtse võrdusmärk, mis tähendab, koopia paremalt vasakule mingi väärtus. 

Kui Argc võrdub võrdub 2, ma tahan ütleme, printf, tere, protsente, uus liin, ja seejärel ühendage in-- ja siin on uus trick-- argv sulg 1 põhjustel et me tuleme tagasi hetkel. Või kui Argc ei võrdsed 2, tead mis? Lähme edasi ja nagu tavaliselt, print välja hello world ilma vahetusest. 

Nii tundub, et kui Argc, mis tähistab argument loota, võrdub 2, Ma lähen välja printida tere midagi vms. Vastasel juhul vaikimisi, ma olen trükkimineku tere. Mida see tähendab? 

Noh, lubage mul minna ja päästa See fail ja tehke teha argv0, ja siis ./argv0, Enter. Ja ta ütleb tere. Nüüd, miks see nii on? 

Noh, selgub millal programm käivituma käsurealt te täitmist, mida jagame Üldiselt nõuavad argument vektor. Teisisõnu automaatselt arvuti, operatsioonisüsteem, läheb käsi oma programmi ise nimekirja kõigi sõnadega et inimese kirjutatud juures kiire, kui sa programmeerija taha teha midagi, mis infot. Ja sel juhul, ainuke sõna Olen kirjutada käsureale on ./argv0. 

Ja nii mitu argumenti, mis on möödutakse minu programm on vaid üks. Teisisõnu, argument loota, muidu tuntud Argc siin täisarv, on vaid üks. Üks muidugi ei võrdu kaks. Ja nii see on, mida prindib, tere. 

Aga mulle seda kusagil. Ütlen, argv0. Ja siis kuidas Maria? Ja siis Enter. 

Ja pane tähele, mis võluväel juhtub siin. Nüüd, selle asemel, et tere, mul on muutunud käitumist selle programmi võttes sisendi mitte get string või mõne muu funktsiooni, kuid ilmselt minu käsu ise, mida ma algselt sisestatud. Ja ma ei saa mängida seda mängu uuesti see muuta Stelios, näiteks. 

Ja nüüd ma näen teise nime ikka. Ja siin, ma võin öelda, Andi. Ja ma võin öelda, Zamyla. Ja me saame mängida seda mängu terve päeva, lihtsalt ühendades erinevaid väärtusi, nii kaua, kui ma ette täpselt kaks sõna käsureale, nii et Argc, minu argument loota, on 2. 

Kas ma näen, et nimi ühendatud printf kohta, see tingimus siin? Nii näib, et oleme nüüd ekspressiivne võime võttes sisend teise mehhanismiga, alates nn käsurea selle asemel, et oodata kuni kasutaja käivitab programmi, ja siis küsib tema kasutades midagi get string. 

Mis see on? Argc jällegi on lihtsalt täisarv, arvu words-- arguments-- et kasutaja osutatakse kiire, terminali aknas sh programmi nimi. Nii et meie ./argv0 on tõhusalt, Programmi nimi, või kuidas ma saan programmi. 

See loeb sõna. Nii Argc oleks 1. Aga kui ma kirjutan Stelios või Andi või Zamyla või Maria, see tähendab, et argument arv on kaks. Ja nii nüüd on kaks sõna möödunud aastal. 

Ja teate, saame jätkata seda loogikat. Kui ma tegelikult öelda midagi Zamyla Chan, täielik nimi, mis kulgeb kolm argumenti kokku nüüd ta ütleb vaikimisi uuesti sest muidugi 3 ei võrdu 2. 

Ja nii sel moel, ma pean juurdepääsu kaudu argv uue argumendi et me võiks tehniliselt helistada midagi tahame. Aga kokkuleppeliselt, see on argv ja Argc võrra. Argv, argument vektor, on selline sünonüümi jaoks programmeerimine funktsiooni C nimetatakse massiivi. 

Hulgaliselt on nimekirja sarnased väärtused tagasi, tagasi, tagasi, edasi-tagasi. Teisisõnu, kui üks on siinsamas RAM, järgmine on õigus selle kõrval ja paremale selle kõrval. Nad ei ole kogu koht. Ja see viimane stsenaarium, kus asjad on kogu koht mälus, võib tegelikult olla võimas. Aga tuleme tagasi, et kui me rääkida Kasvataja andmestruktuurid. Praegu massiivi on lihtsalt patakas sidusmäluplokki, iga, mille elemendid on tagasi, tagasi, tagasi, tagasi, ja üldiselt sama tüüpi. 

Nii et kui sa arvad, alates Hetk tagasi, mida on string? Noh, string, nagu Zamyla, Z-A-M-Y-L-A, on tehniliselt lihtsalt massiivi. See on hulgaliselt märke. 

Ja kui me tõesti teha seda, nagu ma tegid varem, kui patakas mälu, Selgub, et kõik need tegelased kulub bait. Ja siis on see eriline valvur iseloomu, längkriipsu 0, või kõik kaheksa 0 bitti, et piiritleb lõpuks, et string. Nii string, selgub välja, tsiteerida lõppeb string, on lihtsalt massiivi chara-- char on tegelik andmetüüp. 

Ja nüüd argv, meanwhile-- lähme tagasi programmi. Argv, kuigi me näeme sõna string siin, ei ole string ise. Argv, argument vektor, on massiivi stringe. 

Nii nagu sul võib olla mitmeid erinevaid märki, siis võib olla kõrgem, massiivi strings-- nii näiteks kui ma kirjutada hetk tagasi ./argv0 argv0, ruumi Z-A-M-Y-L-A, ma väita, et argv oli kaks stringid see-- ./argv0, ja Z-A-M-Y-L-A. sisse Teisisõnu, Argc oli 2. Miks nii? 

Noh, tegelikult, mis toimub kohta on see, et kõik need stringid on muidugi hulgaliselt tähemärki nagu varemgi, mille kõigile tähemärki kulub ühe baidi. Ja ärge ajage tegelik 0 programmi nimi koos 0, mis tähendab kõik 80 bitti. Ja Zamyla, vahepeal on veel Samuti array tähemärki. 

Nii lõpus päeval, siis tegelikult näeb välja selline all kapuuts. Aga argv olemuselt kuidas peamine töid, võimaldab mul murrab kõik see üles, kui soovite, suurem massiiv et kui me veidi üle lihtsustada Mis pilt välja näeb ja ei üsna joonistada skaala seal, See massiiv on ainult suurus 2, esimene element, mis sisaldab string, teine ​​osa mis sisaldab stringi. Ja omakorda kui sa Selline suumida iga need stringid, mida vaata all kapuuts on see, et iga string on lihtsalt array tähemärki. 

Nüüd, just nagu stringid, suutsime pääse to i-nda iseloomu string kasutades, et nurksulg märke. Samamoodi massiivid üldiselt me ​​saame kasuta nurksulg märke saada igal arv stringe massiivi? Näiteks, las ma minna ja seda teha. 

Lubage mul minna ja luua argv1.c, mis on veidi erinev seekord. Selle asemel, et kontrollimine argc2, Ma lähen selle asemel teha. Sest int saan 0, I vähem kui Argc Ma pluss pluss, ja siis välja printida sees see, protsenti s, uus rida ja seejärel argv sulg i. 

Nii teisisõnu, ma ei tegele üksikute märkide hetkel. Argv, nagu võiks eeldada nende tühjal väljal traksid paremal nime argv, tähendab argv on massiivi stringe. Ja Argc on lihtsalt int. 

See joon siin, 6, on öeldes komplekt i võrdne 0. Count kõik viis kuni, kuid need ei hõlma, Argc. Ja siis iga korduse välja printida string. Mis string? 

I-nda stringi argv. Nii et enne, kui ma olin abil nurksulg märke saada on nda märk string nüüd Ma abil nurksulg märke saada juures nda stringi massiivi. Nii et see on omamoodi üks kiht eespool kontseptuaalselt. 

Ja mis on puhas sellest Programm nüüd, kui ma koostada argv1, ja siis teha ./argv1 ja tippige midagi nagu foo bar Baz, mis on kolm vaikimisi sõnu, et arvuti teadlane jõuab iga kord, ta vajab kohatäide sõnu, ja vajuta Enter, kõik need sõnad, sh programmi nimi, mis on argv esimesel asukoht, jõuab trükitava ühekaupa. Ja kui ma seda muuta, ja ma ütlen midagi argv1 Zamyla Chan, saame kõik kolm nimetatud sõnad, mis on argv0, argv1, argv2, sest selles Juhul Argc, loota, on 3. 

Aga mis on puhas on, kui sa aru et argv on lihtsalt massiivi stringe, ja saate aru, et string on hulgaliselt märke, me saame tegelikult omamoodi kasutada seda nurksulg märke mitu korda valida string, ja seejärel valida iseloomu jooksul string, sukeldudes sügavamale järgmiselt. Selles näites lase mul minna käia ja nimetame seda argv2.c. Ja selles näites, lubage mul minna ja teha following-- jaoks int i saada 0, i on väiksem kui Argc, i pluss pluss, nagu enne. Nii teistes words-- ja nüüd see muutub üsna keerulised. Siis ma lähen ütlen Käi stringid argv, kommentaarina ise. Ja siis ma lähen on Pesastatud silmus, mis siis ilmselt teinud, või peetakse teed, Scratch, kus Ma ütlen int-- ma olen ei kasuta ma jälle, sest ma ei taha varju, või omamoodi kirjutada olemasolev i. 

Ma lähen hoopis öelda, j, sest see on minu minna muutuva pärast i, kui ma üritan loota lihtne numbrid. J saab 0-- ja ka n, läheb saada ahtri pikkus argv sulg i, niikaua j on väiksem kui m, j pluss pluss, teha järgmist. Ja siin on huvitav osa. 

Prindi välja iseloomu ning uus liin, ühendades argv sulg i, sulg j. OK, nii et las ma lisan mõned kommentaarid siin. Käi tähemärki praegustes string, print j-nda märk i-nda string. Nüüd Vaatleme Mis need kommentaarid tähenda. 

Käi stringid aastal argv-- mitu stringid on argv, mis on massiivi? Argc palju, nii et ma iterating alates i võrdne 0 kuni Argc. Vahepeal, kui palju märke on i-nda stringi argv? 

Noh, et saada see vastus Ma lihtsalt helistada string pikkusega praeguse string Ma hooldus umbes, mis on argv sulg i. Ja ma lähen ajutiseks salvestamiseks, et väärtus n, lihtsalt vahemällu eesmärkidel, meeles pidada seda tõhusam. Ja siis ma lähen initsialiseerida j 0, hoida läheb nii kaua kui j on väiksem kui n, ja iga iteratsiooni juurdekasvu j. 

Ja siis siin kohta minu kommentaar on line 12 välja printida iseloomu, järgneb uus liin, spetsiaalselt argv sulg i annab mulle i-nda string aastal argv-- nii esimene sõna on Teine sõna, kolmas sõna, mis iganes. Ja siis j sukeldub sügavamale, ja saab mulle j-nda iseloomu selle sõna. Ja nii, et tegelikult saab ravida argv nagu mitmemõõtmeline, nagu kahemõõtmeline, massiiv, kusjuures iga sõna mingi välimus niimoodi oma vaimusilmas silma, ja iga tegelane on selline komponeeritud veerus, kui see aitab. 

Tegelikult, kui me tease Selle peale tulevikus nädalat see saab olema natuke keerukam kui see. Aga sa võid tõesti mõelda, et nüüd, lihtsalt see kahemõõtmeline massiiv, kusjuures üks tase seda on kõik stringid. Ja siis, kui sa sukelduda sügavamale, siis saan isikliku tähemärki mispärast, kasutades seda märke siin. 

Mis on netomõjust? Lubage mul minna ja teha argv2-- paganama ta. Ma tegin vea siin. Kaudselt kuulutatakse raamatukogu funktsiooni Stirling. Nii et kõik see aeg, see on ehk asjakohane et me omamoodi viimistlus täpselt, kus me alustasime. 

Ma silmamunad kaudselt kuulutatakse raamatukogu funktsiooni Stirling. OK, oota üks hetk. Mäletan, et eriti kuna see on siin. Mul on vaja lisada string sisse See versioon programm. 

Lubage mul minna ja lisada string, salvestada, et minna ja kompileerida argv2. Ja nüüd, siin me läheme, et argv2, Enter. Ja kuigi see on natuke segasena esimesel pilgul, märgata, et tõepoolest, mida trükitud on dot argv2. 

Aga kui ma tüüpi mõned sõnad peale kiire, nagu argv2 Zamyla Chan, Sisesta ka natuke segasena esimesel pilgul. Aga kui me kerida tagasi üles ./argv2 Z-A-M-Y-L-A C-H-A-N. Nii oleme itereerida üle iga sõna. Ja omakorda oleme itereerida üle Iga tähemärgi sõna. 

Nüüd, pärast kõike seda, aru, et seal on üks teine ​​detail oleme olnud sellist ignoreerides seda kogu aeg. Me lihtsalt teased peale mida Peamised sisendite võib olla? Aga peamine väljund? 

Kõik see aeg, me oleme olnud ainult kopeerimise ja kleepimise sõna int ees peamine, kuigi võite näha online, mõnikord valesti vanemad versioonid C ja koostajad, et nad ütlevad tühine, või üldse mitte midagi. Aga tõepoolest versiooni jaoks C, et me kasutame, C 11 või 2011 mõistma et see peaks olema int. Ja see peaks olema kas tühine või Argc ja argv siin. 

Aga miks int main? Mis on see tegelikult tagasi? Noh, selgub kõik see aeg, igal ajal olete kirjutanud programmi peamine alati tagasi midagi. Aga see on teinud seda salaja. 

Et midagi on int, kui rida 5 näitab. Aga mis int? Noh, seal on see konventsiooni programmeerimine, kusjuures, kui midagi on valesti läinud ja kõik on hästi, programmide ja funktsioonide üldiselt return-- mõnevõrra counterintuitively-- 0. 0 üldjuhul tähendab, et kõik on hästi. Nii et kuigi sa arvad see vale paljudes kontekstides, see tegelikult tähendab üldiselt hea 

Vahepeal, kui programmi tagastab 1, või negatiivne 1 või 5 või negatiivne 42, või mitte-0 väärtus, et üldiselt tähistab et midagi on valesti läinud. Tegelikult on oma Mac või PC, sa võisid tõepoolest näinud veateade, millega ta ütleb midagi või muu viga kood negatiivne 42 või error code 23, või midagi sellist. See arv on üldiselt lihtsalt vihje programmeerija või ettevõtte mis tehtud tarkvara mis valesti läks ja miks et nad saaksid vaadata läbi nende dokumentide või koodi ja aru saada, mis viga tegelikult tähendab. See ei ole üldiselt meile kasulik lõppkasutajatele. 

Aga kui peamine naaseb 0, et kõik on hästi. Ja kui sa ei määra Mis peamine peaks tagasi, see lihtsalt automaatselt tagasi 0 teile. Aga tagasi midagi muidu on tegelikult kasulik. 

Sel lõplik programm, lase mind minna ja nimetame seda exit.c, ja tutvustada viimase tänapäeva teemasid, mida tuntakse veakood. Lubage mul minna ja sisaldavad meie tuttav faile üles top, do int main. Ja seekord teeme int Argc, string argv ja minu sulgudes tähenda, et see on massiivi. Ja siis me lihtsalt ei meelerahu kontrolli. Seekord kui Argc ei võrdsed 2, siis sa tead, mida? Unusta ära. Ma ei ütle, et kuule, kasutaja, siis on puudu käsureaargumenti backslash n. 

Ja siis ongi kõik. Ma tahan, et väljuda. Ma ennatlikult, ja enneaegselt tõesti, tagastamise midagi muud kui number 1. Ava väärtus esimese viga, mis võib juhtuda, on 1. Kui teil on mõni muu ekslik olukorda, mis võib tekkida, Võib öelda tagastamise 2 või tagasi 3 või võibolla isegi negatiivne 1 või negatiivne 2. 

Need on vaid väljundkoodid mis on üldiselt ainult kasulik programmeerija või ettevõte, mis laevanduse tarkvara. Aga fakt, et see ei 0 on, mis on oluline. Nii et kui see programm, ma tahan tagada, et see programm ainult toimib siis, kui kasutaja annab mulle koos argument arv kaks, nimi programm, ja mõned teised Ühesõnaga, ma ei saa jõustada nii palju kui järgmine, kisa kasutajale printf ütlus puudu käsureaargumenti, tagasi 1. See lihtsalt kohe sulgege programm. 

Ainult siis, kui Argc võrdub 2 me pikali siin, selles punktis ma öelda, tere protsenti s, backslash n, argv1. Teisisõnu, ma olen ei kavatse pärast argv 0, mis on lihtsalt programmi nimi. Ma tahan välja printida tere, koma, teine ​​sõna, et inimese kirjutatud. Ja sel juhul on line 13, kõik on hästi. 

Ma tean, et Argc on 2 loogiliselt seda programmi. Ma lähen edasi minna ja tagasi 0. Selle kõrvale, pea meeles, et see on tõsi Scratch samuti. 

Loogiliselt ma võiks seda teha ning loovad need read koodi selles muidu punktis siin. Aga see on omamoodi asjatult taandamine minu koodi. Ja ma tahan teha super selge, et ükskõik, mida, vaikimisi, tere midagi saavad trükitud, niikaua kui kasutaja teeb seda. 

Nii et see on väga tavaline, et tingimus, lihtsalt kui püüda mõned ekslikud olukorras, ja seejärel sulgub. Ja siis, nii kaua kõik on noh, ole muud, aga lihtsalt koodi väljaspool, et kui, sest see on samaväärsed selles eriti juhul, loogiliselt. Nii et ma tagasi 0, lihtsalt selgesõnaliselt tähenda, et kõik on hästi. 

Kui ma jätta tagastamise 0, oleks automaatselt eeldada, minu jaoks. Aga nüüd, et ma olen tagasi üks vähemalt sel juhul, Ma lähen, hea meede ja selgus, tagastab 0 käesolevas asjas. Nüüd lubage mul minna ja teha exit mis on täiuslik rännata jäta. 

Aga teha exit ja lase mul minna käia ja teha ./exit, Enter. Ja programmi karjus mulle, puudu käsureaargumenti. OK, las ma koostööd. 

Lubage mul asemel teha ./exit, David, Enter. Ja nüüd ta ütleb, tere David. Ja sa tavaliselt ei näe seda. 

Aga selgub, et seal on erilisel moel Linux tegelikult näha mida koodiga programm väljunud. Vahel graafilise maailma nagu Mac OS või Windows, näed ainult need numbrid, kui veateadet hüppab ekraanil ja programmeerija näitab, et number. Aga kui me tahame näha, milline viga sõnum on, me ei saa seda teha siin-- nii ./exit, Enter, print puudu käsureaargumenti. 

Kui ma nüüd tegema kaja $ ?, mis on naeruväärselt segasena otsima. Aga $? on maagiline loits mis ütleb, hei, arvuti, öelge mulle, mida eelmise Programmi koodiga oli. Ja ma Enter. Näen 1, sest see, mida ma ütles mu põhiülesanne tagasi. 

Vahepeal, kui ma ./exit David, ja vajuta Enter, ma näen, tere David. Ja kui ma nüüd tegema kaja $ ?, näen hello 0. Ja nii see tegelikult väärtuslik teave kontekstis siluri, mitte nii palju, et sa inimese, hooliks. Aga siluri ja muu programmid me kasutame sel semestril Sageli vaadata, et number, kuigi see on omamoodi peidetud kui sa otsida seda, et kindlaks teha, kas või mitte programmi täitmise oli õige või vale. 

Ja nii, et toob meid Selle lõpus päeval. Alustasime täna vaadates silumine ja kordamööda käigus ise ja seejärel rohkem huvitaval kombel tehniliselt all kapuuts millise stringid on, mis kestab nädalal me lihtsalt võttis ette antud, ja kindlasti oli neid enesestmõistetavaks Scratch. 

Siis vaatasin, kuidas suudame üksikute märkide jada, ja siis jälle võttis kõrgemal tasemel vaadata asju, vaadates, kuidas well-- Kui me tahame saada üksikisiku elementide nimekirja sarnane struktuur, ei saa me seda teha mitu stringid? Ja me saame koos käsurea argumente. Aga see pilt siin lihtsalt kastid on demonstratiivne selle üldine idee massiivi või nimekirja, või vektor. Ja sõltuvalt kontekstis kõiki neid sõnu tähenda veidi erinevaid asju. Nii C, me üksnes rääkida massiivi. Ja massiivi on patakas mälu, kellest igaüks on elemendid on pidevad tagasi tagasi, tagasi, edasi-tagasi. 

Ja need elemendid on üldiselt sama andmetüüp, iseloomu, iseloomu, iseloomu, iseloomus, või string, string, string, string, või int, int, int, mis see on me üritame poest. Aga lõpus päeval, see on kuidas see välja näeb kontseptuaalselt. Sa võtad oma arvuti mälu või mälu. Ja sa jätta välja võtta identselt suurusega karbid, mis kõik on tagasi, tagasi, et tagasi, tagasi niimoodi. 

Ja mis tore Selle idee ning tõsiasi et võime väljendada väärtused sel viisil esimese meie andmestruktuuride klassis, tähendab, et saame alustada lahendada probleeme koodi mis tuli nii intuitiivselt nädal 0. Sul on meenutada telefon raamat näiteks siis, kui me kasutasime jaga ja valitse, või binaarne otsingu algoritm, sõeluma läbi terve kamp nimed ja numbrid. Aga me eeldada, meenutada, et see telefoniraamat juba sorteeritud, et keegi oli juba arvasin out-- antud nimesid, ja numbers-- kuidas alphabetize neid. Ja nüüd, et C oleme, Ka on võime panna asjad läbi, mitte füüsiliselt telefoniraamat kuid praktiliselt arvuti mälu, saame järgmisel nädalal tutvustada uuesti see-- esimene Meie andmete struktuurid array-- kuid veelgi tähtsam, tegelik arvuti teaduse algoritme koodi, kellega meil on võimalik salvestada andmete struktuurid nagu see, ja siis hakkavad manipuleerida, ja tegelikult lahendada probleeme sellega, ja ehitada peal, et lõpuks programme C, Python, JavaScript, päringute andmebaase SQL? 

Ja me näeme, et kõik need erinevaid ideid omavahel tihedalt. Aga nüüd, meelde tuletada, et domeeni, mis me sisse täna oli see asi siin, ja maailma krüptograafia. Ja vahel järgmise probleemidest ise lahendab on kunst krüptograafia skrambleerimise ja de-skrambleerimise info ja krüptimine ja kulus teksti ja eeldades lõpuks mis sa nüüd tea, mida on all kapuuts nii et kui te näete või saada selline teade, siis ise ei oska seda lugeda. Kõik see ja rohkem järgmine kord. 

[VIDEO PLAYBACK] 

-Mover Just saabunud. Ma lähen visiidil oma kolledži professor. Yep. Tere. See oled sina. Oodake! David. Ma lihtsalt üritan aru mis juhtus sinuga. Palun, midagi võiks aidata. Sa olid oma kolledži toakaaslane, eks ole? Sa olid seal koos temaga, kui Ta lõpetas CS50 projekti? 

[MUSIC MÄNGIB] 

-See Oli CS50. 

Ma armastan seda kohta. 

-Ära sööma. Me läheme pankrotti. 

[END PLAYBACK] 