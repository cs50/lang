1
00:00:00,000 --> 00:00:02,970
>> [Reprodución de música]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> DAVID J. Malan: Todo ben.

4
00:00:15,700 --> 00:00:18,832
Este é CS50 e este
é o inicio da Semana 2.

5
00:00:18,832 --> 00:00:21,040
E vai lembrar que, ao longo
o último par de semanas,

6
00:00:21,040 --> 00:00:24,490
vimos introducir ordenador
ciencia e, á súa vez, a programación.

7
00:00:24,490 --> 00:00:27,640
>> E comezamos a historia por medio de
Cero, que a linguaxe gráfica

8
00:00:27,640 --> 00:00:28,990
desde o MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
E, a continuación, máis recentemente,
a semana pasada, fixemos

10
00:00:30,780 --> 00:00:34,450
introducir un higher-- un
linguaxe de nivel máis baixo coñecido

11
00:00:34,450 --> 00:00:36,770
como C, algo que é puramente textual.

12
00:00:36,770 --> 00:00:39,440
E, de feito, última vez que
explotado dentro dese contexto

13
00:00:39,440 --> 00:00:40,450
unha serie de conceptos.

14
00:00:40,450 --> 00:00:43,010
>> Este, recall, era a propia
primeiro programa nós encontramos.

15
00:00:43,010 --> 00:00:45,710
E este programa, moi simplemente,
imprime, "Ola, mundo".

16
00:00:45,710 --> 00:00:47,730
Pero hai moito
magic parecendo suceder.

17
00:00:47,730 --> 00:00:51,460
Hai esa #include
con estes corchetes.

18
00:00:51,460 --> 00:00:52,170
Hai int.

19
00:00:52,170 --> 00:00:53,020
Hai (void).

20
00:00:53,020 --> 00:00:56,330
Hai parénteses, corchetes,
punto e coma, e moito máis.

21
00:00:56,330 --> 00:00:58,480
>> E así, recordar que
introducimos Raspadinha

22
00:00:58,480 --> 00:01:02,110
para que puidésemos, idealmente, ver o pasado
que a sintaxe, o material que non é realmente

23
00:01:02,110 --> 00:01:04,590
todo o que intelectualmente
interesante, pero pronto

24
00:01:04,590 --> 00:01:07,700
é, absolutamente, un pouco complicado
para involucrar súa mente en torno.

25
00:01:07,700 --> 00:01:10,860
E, de feito, un dos máis comúns
as cousas no inicio dunha clase de programación,

26
00:01:10,860 --> 00:01:13,443
sobre todo para os menos
cómodo, é para frustrado por

27
00:01:13,443 --> 00:01:17,460
e tropezou algúns sintáctica
erros, sen esquecer a erros lóxicos.

28
00:01:17,460 --> 00:01:19,800
E así entre os nosos obxectivos
hoxe, en realidade, vontade

29
00:01:19,800 --> 00:01:23,280
sexa para equipa-lo con algún
técnicas de resolución de problemas sobre como

30
00:01:23,280 --> 00:01:26,705
para resolver mellor os problemas propios
baixo a forma de depuración.

31
00:01:26,705 --> 00:01:29,330
E vai lembrar, tamén, que o
ambiente que foi introducida

32
00:01:29,330 --> 00:01:31,780
última vez que foi chamado CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Este é un programa baseado na web que
permite programar na nube,

34
00:01:34,850 --> 00:01:38,450
por así dicir, mantendo todo o seu
arquivos xuntos, como teremos novo hoxe.

35
00:01:38,450 --> 00:01:41,480
E lembrar que
revisitado estes temas aquí,

36
00:01:41,480 --> 00:01:44,480
entre elas funcións e loops, e
variables e expresións booleanas,

37
00:01:44,480 --> 00:01:45,110
e condicións.

38
00:01:45,110 --> 00:01:49,190
E, de feito, un pouco máis que
traducido do mundo do scratch

39
00:01:49,190 --> 00:01:50,800
para o mundo do C.

40
00:01:50,800 --> 00:01:53,220
>> Pero a construción fundamental
bloques, por así dicir,

41
00:01:53,220 --> 00:01:55,150
foron realmente aínda o mesmo a semana pasada.

42
00:01:55,150 --> 00:01:57,900
En realidade, nós realmente só tiña un
diferente peza do puzzle, se quere.

43
00:01:57,900 --> 00:02:00,300
No canto de que o vermello
gardar bloque, nós en vez

44
00:02:00,300 --> 00:02:02,940
tiña printf, que é
esta función en C que

45
00:02:02,940 --> 00:02:05,890
permite imprimir algo
e formato-lo na pantalla.

46
00:02:05,890 --> 00:02:07,950
Introducimos o CS50
Biblioteca, onde

47
00:02:07,950 --> 00:02:11,420
teñen agora á súa disposición get_char,
e get_int, e get_string,

48
00:02:11,420 --> 00:02:14,610
e algunhas outras funcións como
ben, a través do cal se pode obter a entrada

49
00:02:14,610 --> 00:02:16,260
do propio teclado do usuario.

50
00:02:16,260 --> 00:02:20,640
E tamén tivo un ollar para as cousas
como these- bool, e char,

51
00:02:20,640 --> 00:02:22,490
e double, float,
int, cadea long_long.

52
00:02:22,490 --> 00:02:25,170
E hai aínda outros tipos de datos en C

53
00:02:25,170 --> 00:02:28,560
>> Noutras palabras, cando declara
unha variable para almacenar un valor,

54
00:02:28,560 --> 00:02:32,600
ou cando aplicar unha función
que retorna un valor,

55
00:02:32,600 --> 00:02:35,290
pode especificar o que
tipo de valor que sexa.

56
00:02:35,290 --> 00:02:37,310
É unha cadea, como un
secuencia de caracteres?

57
00:02:37,310 --> 00:02:39,490
É un número, como un número enteiro?

58
00:02:39,490 --> 00:02:41,390
É un punto flotante
valor ou similares?

59
00:02:41,390 --> 00:02:46,180
Así, en C, ao contrario do risco, nós realmente
comezou a especificar o tipo de datos

60
00:02:46,180 --> 00:02:48,330
estabamos volvendo ou usar.

61
00:02:48,330 --> 00:02:51,910
>> Pero, por suposto, tamén foi para
algúns límites fundamentais da informática.

62
00:02:51,910 --> 00:02:54,100
E, en particular,
esa linguaxe C, recordo

63
00:02:54,100 --> 00:02:57,070
que demos un ollo a
integer overflow, a realidade

64
00:02:57,070 --> 00:03:00,460
que, se ten só un
cantidade finita de memoria

65
00:03:00,460 --> 00:03:04,600
ou, en concreto, un número finito
de bits, só pode contar tan alto.

66
00:03:04,600 --> 00:03:08,460
E así nós miramos para este exemplo aquí
en que un contador nun avión,

67
00:03:08,460 --> 00:03:13,510
en realidade, se executar o tempo suficiente sería
rebosar e producir un programa

68
00:03:13,510 --> 00:03:15,560
un erro potencial físico real.

69
00:03:15,560 --> 00:03:18,600
>> Tamén mirou flotante
punto de imprecisión, a realidade

70
00:03:18,600 --> 00:03:22,280
que, con só un número finito
de bits, se é 32 ou 64,

71
00:03:22,280 --> 00:03:27,330
só se pode especificar tantos números
despois dun punto decimal, tras o cal

72
00:03:27,330 --> 00:03:29,110
comezan a estar imprecisa.

73
00:03:29,110 --> 00:03:32,360
Así, por exemplo, un terzo en
mundo aquí, no noso mundo humano,

74
00:03:32,360 --> 00:03:35,360
o que si sabemos é só un número infinito
de 3s despois do punto decimal.

75
00:03:35,360 --> 00:03:38,820
Pero un ordenador non pode necesariamente
representan un número infinito de números

76
00:03:38,820 --> 00:03:42,590
se permitir só que algúns
cantidade finita de información.

77
00:03:42,590 --> 00:03:45,900
>> Así, non só nós equipa-lo
con maior poder en canto

78
00:03:45,900 --> 00:03:49,280
de como pode expresarse en
un teclado en termos de programación,

79
00:03:49,280 --> 00:03:51,430
Tamén limita o
pode realmente facer.

80
00:03:51,430 --> 00:03:55,790
E, de feito, os erros e os erros poden
xorden a partir destes tipos de problemas.

81
00:03:55,790 --> 00:03:59,900
E, de feito, entre os temas hoxe
van ser temas como a depuración

82
00:03:59,900 --> 00:04:03,699
e, de feito, mirando por baixo do capuz
o xeito no que as cousas foron introducidos na semana pasada

83
00:04:03,699 --> 00:04:05,490
son realmente aplicadas
de xeito que é mellor

84
00:04:05,490 --> 00:04:10,530
comprender tanto as capacidades de correo
as limitacións dunha linguaxe como C.

85
00:04:10,530 --> 00:04:14,770
>> E, de feito, imos pelar as capas
dos máis simple de estrutura de datos,

86
00:04:14,770 --> 00:04:17,756
algo chamado un array, que
Cero pasa a chamar unha "lista".

87
00:04:17,756 --> 00:04:19,589
É un pouco
diferente nese contexto.

88
00:04:19,589 --> 00:04:23,340
E entón nós tamén imos presentar un dos
primeiro dos nosos problemas específicos do campo

89
00:04:23,340 --> 00:04:26,790
en CS50, o mundo da
criptografía, a arte de Nomes

90
00:04:26,790 --> 00:04:29,650
ou cifrar Información
que pode enviar mensaxes secretas

91
00:04:29,650 --> 00:04:34,520
e descodificar mensaxes secretas
entre dúas persoas, A e B.

92
00:04:34,520 --> 00:04:37,490
>> Polo tanto, antes de transición,
a ese novo mundo,

93
00:04:37,490 --> 00:04:42,059
imos tratar equipa-lo con algún
técnicas coas que pode eliminar

94
00:04:42,059 --> 00:04:43,850
ou reducir, polo menos, algúns
das frustracións

95
00:04:43,850 --> 00:04:46,630
que probablemente xa atopou
ao longo da última semana só.

96
00:04:46,630 --> 00:04:50,830
De feito, antes de lle son algúns dos such--
seus primeiros problemas en C. E as probabilidades son,

97
00:04:50,830 --> 00:04:54,010
se vostede é como eu, por primeira vez
tenta escribir un programa,

98
00:04:54,010 --> 00:04:57,330
mesmo se pensar loxicamente
o programa é moi sinxelo,

99
00:04:57,330 --> 00:05:01,200
pode moi ben bater nunha parede, e
o compilador non vai cooperar.

100
00:05:01,200 --> 00:05:03,940
Facer ou Clang non
para realmente facer o seu tiro.

101
00:05:03,940 --> 00:05:05,450
>> E por que pode ser iso?

102
00:05:05,450 --> 00:05:07,950
Ben, imos dar un ollo,
quizais, un programa sinxelo.

103
00:05:07,950 --> 00:05:11,190
Eu estou indo a ir adiante e gardar isto en
un arquivo chamado deliberadamente buggy0.c,

104
00:05:11,190 --> 00:05:13,590
porque sei que a
ser fallo con antelación.

105
00:05:13,590 --> 00:05:17,400
Pero pode non entender que, se esta
é o primeiro ou segundo ou terceiro programa

106
00:05:17,400 --> 00:05:18,830
que realmente estou me facendo.

107
00:05:18,830 --> 00:05:23,820
Entón, eu estou indo a ir adiante e
escribir, int main (void).

108
00:05:23,820 --> 00:05:28,130
E, a continuación, dentro das miñas chaves,
moi familiar ( "Ola, mundo--

109
00:05:28,130 --> 00:05:30,980
barra invertida, n ") - e un punto e coma.

110
00:05:30,980 --> 00:05:32,360
>> Eu salvo o ficheiro.

111
00:05:32,360 --> 00:05:34,850
Agora eu estou indo a ir para abaixo
na miña fiestra de terminal

112
00:05:34,850 --> 00:05:40,340
e tipo make buggy0 porque, de novo,
o nome do ficheiro é hoxe buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Entón eu tecleo facer buggy0, Intro.

114
00:05:43,660 --> 00:05:48,200
>> E, oh, Deus, lembro a última vez
que ningunha mensaxe de erro é bo.

115
00:05:48,200 --> 00:05:49,740
Así, ningunha saída é unha cousa boa.

116
00:05:49,740 --> 00:05:52,920
Pero aquí eu teño claro
un número de erros.

117
00:05:52,920 --> 00:05:56,470
>> Así, a primeira liña de saída
despois de escribir facer buggy0, recall,

118
00:05:56,470 --> 00:05:59,540
se emite bastante detallado do Clang.

119
00:05:59,540 --> 00:06:02,067
Debaixo do capó,
IDE estabelécese CS50

120
00:06:02,067 --> 00:06:04,150
para usar unha morea de
opcións con este compilador

121
00:06:04,150 --> 00:06:05,941
de xeito que non ten
para pensar sobre eles.

122
00:06:05,941 --> 00:06:08,840
E iso é todo o que a primeira liña
medios que comeza con Clang.

123
00:06:08,840 --> 00:06:11,720
>> Pero despois diso, os problemas
comezar a facer o seu aspecto.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c na liña 3, carácter
5, existe un gran erro, vermello.

125
00:06:17,390 --> 00:06:18,380
Qué e iso?

126
00:06:18,380 --> 00:06:23,562
Implicitamente declarando función de biblioteca
printf co tipo int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Quero dicir, moi rapidamente
queda moi misterioso.

129
00:06:28,379 --> 00:06:30,170
E, por suposto, a primeira
vista, non queremos

130
00:06:30,170 --> 00:06:32,380
espero que entenda o
totalidade da mensaxe.

131
00:06:32,380 --> 00:06:34,213
E así unha das leccións
para hoxe vai

132
00:06:34,213 --> 00:06:36,919
ser a de tentar entender
patróns, ou cousas semellantes,

133
00:06:36,919 --> 00:06:38,960
a erros que pode ter
encontradas no pasado.

134
00:06:38,960 --> 00:06:41,335
Entón, imos provocar única apart
aquelas palabras que mira familiar.

135
00:06:41,335 --> 00:06:44,290
O gran, vermello de erro é claramente
simbólica de que algo está mal.

136
00:06:44,290 --> 00:06:47,940
>> implicitamente declarando
biblioteca printf función.

137
00:06:47,940 --> 00:06:51,680
Así, aínda que eu non entendo moi ben o que
declarar implicitamente función de biblioteca

138
00:06:51,680 --> 00:06:54,900
medios, o problema seguramente
refírese a printf de algunha maneira.

139
00:06:54,900 --> 00:06:59,130
E a fonte dese problema
ten que ver co declarar.

140
00:06:59,130 --> 00:07:02,440
>> Declarar unha función é
mencionalo-lo por primeira vez.

141
00:07:02,440 --> 00:07:06,210
E usamos a terminoloxía a semana pasada
de declarar un prototipo de función,

142
00:07:06,210 --> 00:07:11,860
ou cunha liña na parte superior do seu
propio ficheiro ou nun arquivo de cabeceira chamado.

143
00:07:11,860 --> 00:07:15,300
E en que ficheiro fixo dicimos
a semana pasada que printf é citar,

144
00:07:15,300 --> 00:07:17,080
unquote, declarou?

145
00:07:17,080 --> 00:07:20,950
En o ficheiro é o seu prototipo?

146
00:07:20,950 --> 00:07:24,640
>> Entón, se se lembra, o primeiro que eu
ingresaran, case todos os programas última vez--

147
00:07:24,640 --> 00:07:30,790
e, accidentalmente, un momento atrás comezou
escribindo myself-- foi esta aqui--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- para
input / output-- dot h E, de feito,

149
00:07:38,630 --> 00:07:41,860
se eu agora salva este ficheiro, eu vou
para ir adiante e limpar a miña pantalla,

150
00:07:41,860 --> 00:07:44,740
que se pode facer escribindo
Limpar, ou pode manter control de L,

151
00:07:44,740 --> 00:07:47,680
só para limpar a súa fiestra de terminal
só para eliminar algunha desorde.

152
00:07:47,680 --> 00:07:51,370
>> Eu estou indo a ir adiante e
re-escribe make buggy0, Intro.

153
00:07:51,370 --> 00:07:53,790
E listo, eu ver que
mando longo Clang,

154
00:07:53,790 --> 00:07:55,470
pero non hai ningunha mensaxe de erro neste momento.

155
00:07:55,470 --> 00:07:58,800
E, de feito, se eu fai ./buggy0,
Como a última vez,

156
00:07:58,800 --> 00:08:01,860
onde punto significa esta
Directorio, Slash só significa,

157
00:08:01,860 --> 00:08:05,040
aquí vén o nome do programa e
que nome do programa é buggy0,

158
00:08:05,040 --> 00:08:07,340
Intro, "Ola, mundo".

159
00:08:07,340 --> 00:08:09,440
>> Agora, como pode ter
esta solución adquirida

160
00:08:09,440 --> 00:08:12,017
sen necesariamente
recoñecendo como moitas palabras

161
00:08:12,017 --> 00:08:14,350
como eu fixen, seguramente, ter
feito isto por tantos anos?

162
00:08:14,350 --> 00:08:18,720
Ben, entender por o primeiro problema
set, imos presentar-lle un comando

163
00:08:18,720 --> 00:08:21,175
que a propia equipo do CS50
escribiu chamado help50.

164
00:08:21,175 --> 00:08:24,300
E, de feito, C fai especificación para
o conxunto de problemas acerca de como usar isto.

165
00:08:24,300 --> 00:08:27,210
>> Pero é esencialmente help50
un programa que o persoal do CS50

166
00:08:27,210 --> 00:08:30,850
escribiu que permite que executa
unha orde ou executar un programa,

167
00:08:30,850 --> 00:08:36,169
e se non entender a súa
de saída, para pasar a súa saída para help50,

168
00:08:36,169 --> 00:08:38,890
momento no que o software
que o persoal do curso escribiu

169
00:08:38,890 --> 00:08:42,429
vai mirar para a saída do seu programa
liña por liña, carácter por carácter.

170
00:08:42,429 --> 00:08:46,000
E se nós, os funcionarios, recoñecer o
mensaxe de erro que está experimentando,

171
00:08:46,000 --> 00:08:50,580
imos tratar provocalo lo con algún
preguntas retóricas, con algúns consellos,

172
00:08:50,580 --> 00:08:54,890
así como un TF ou dunha CA ou eu mesmo
faría persoalmente en horario de expediente.

173
00:08:54,890 --> 00:08:58,320
>> Entón mire para help50 Se non o fai
-Se recoñecer necesariamente un problema.

174
00:08:58,320 --> 00:09:00,790
Pero non contar con el
moi como unha muleta.

175
00:09:00,790 --> 00:09:03,990
Certamente tentar entender a
de saída e, a continuación, aprender con el

176
00:09:03,990 --> 00:09:07,571
de xeito que só unha ou dúas veces
nunca correr help50 a un erro específico

177
00:09:07,571 --> 00:09:08,070
mensaxe.

178
00:09:08,070 --> 00:09:10,660
Despois diso, ten que ser
mellor equipado-se

179
00:09:10,660 --> 00:09:13,180
para descubrir o que realmente é.

180
00:09:13,180 --> 00:09:14,350
>> Faremos outro aquí.

181
00:09:14,350 --> 00:09:20,410
Déixeme ir adiante, e noutro
arquivo imos chamar este buggy1.c.

182
00:09:20,410 --> 00:09:23,110
E neste arquivo que eu son
vai deliberately--

183
00:09:23,110 --> 00:09:26,330
pero finxir que non
entender o erro que eu fixen.

184
00:09:26,330 --> 00:09:31,420
>> Eu estou indo a ir adiante e facer isto--
#include, dende que eu teño

185
00:09:31,420 --> 00:09:33,660
aprendín miña lección de un momento atrás.

186
00:09:33,660 --> 00:09:36,220
Int main (void), como antes.

187
00:09:36,220 --> 00:09:40,880
E entón aquí eu vou
para facer corda s - get_string.

188
00:09:40,880 --> 00:09:43,770
E lembro a última vez que
este medio, hey, ordenador,

189
00:09:43,770 --> 00:09:48,280
dáme unha variable, chame-s, e
facer o tipo desta variable unha cadea

190
00:09:48,280 --> 00:09:50,150
para que eu poida almacenar unha ou máis palabras nel.

191
00:09:50,150 --> 00:09:52,191
>> E logo, no lado dereito
lado do signo igual

192
00:09:52,191 --> 00:09:54,980
é get_string, que é un
función na biblioteca CS50

193
00:09:54,980 --> 00:09:55,980
que fai exactamente iso.

194
00:09:55,980 --> 00:09:59,740
Ela recibe unha función e, a continuación,
man de dereita a esquerda.

195
00:09:59,740 --> 00:10:02,670
Polo tanto, este signo igual non significa
"Iguais" como poderiamos pensar en matemáticas.

196
00:10:02,670 --> 00:10:04,750
Isto significa que a asignación de dereita a esquerda.

197
00:10:04,750 --> 00:10:09,640
Entón isto significa, tomar a secuencia de
o usuario e almacena-lo dentro de s.

198
00:10:09,640 --> 00:10:10,460
>> Agora imos usalo.

199
00:10:10,460 --> 00:10:13,820
Déixeme ir adiante agora e como unha segunda
liña, deixe-me ir adiante e dicir "Ola" -

200
00:10:13,820 --> 00:10:19,330
non "mundo", pero "Ola,% s--
que é o noso espazo reservado, coma s,

201
00:10:19,330 --> 00:10:22,030
que é a nosa variable,
e logo, un punto e coma.

202
00:10:22,030 --> 00:10:26,070
Entón, se eu non romper máis
aquí, iso parece correcta do código.

203
00:10:26,070 --> 00:10:28,090
>> E os meus instintos son agora compilalo.

204
00:10:28,090 --> 00:10:30,400
O ficheiro é chamado buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Entón eu vou facer facer buggy1, Intro.

206
00:10:33,770 --> 00:10:36,377
E ma-lo, se non hai
incluso máis erros que antes.

207
00:10:36,377 --> 00:10:38,210
É dicir, hai máis
mensaxes de erro que faría

208
00:10:38,210 --> 00:10:40,400
Parece que as liñas reais neste programa.

209
00:10:40,400 --> 00:10:42,730
>> Pero o takeaway aquí é,
aínda se está resaltado

210
00:10:42,730 --> 00:10:45,040
con dous ou tres ou
catro mensaxes de erro,

211
00:10:45,040 --> 00:10:48,340
concentrarse sempre sobre o propio
primeira destas mensaxes.

212
00:10:48,340 --> 00:10:52,220
Mirando para o máis alto dun,
desprazamento de volta sempre que sexa necesario.

213
00:10:52,220 --> 00:10:53,930
Entón aquí eu escriba make buggy1.

214
00:10:53,930 --> 00:10:55,700
Aquí é que a produción Clang como espera.

215
00:10:55,700 --> 00:10:57,290
>> E aquí está o primeiro erro vermello.

216
00:10:57,290 --> 00:11:02,370
Uso de identificador non declarado
corda, que quero dicir por defecto en?

217
00:11:02,370 --> 00:11:04,260
Así, en defecto é
realmente outra cousa.

218
00:11:04,260 --> 00:11:06,240
Se refire ao usuario
teclado, esencialmente.

219
00:11:06,240 --> 00:11:08,080
>> Pero non é iso que eu quería dicir.

220
00:11:08,080 --> 00:11:11,770
Eu quería dicir corda, e eu quería dicir get_string.

221
00:11:11,770 --> 00:11:16,200
Entón que é o que eu
esqueceu facer esta vez?

222
00:11:16,200 --> 00:11:20,230
O que falta neste momento?

223
00:11:20,230 --> 00:11:23,600
Eu teño o meu #include,
entón eu teño acceso a printf.

224
00:11:23,600 --> 00:11:26,090
>> Pero o que eu non teño
acceso a só aínda?

225
00:11:26,090 --> 00:11:29,420
Ben, así como a última vez,
Eu teño que dicir ao compilador

226
00:11:29,420 --> 00:11:31,691
Clang que esas funcións son.

227
00:11:31,691 --> 00:11:33,940
O get_string non vén
con C. E, en particular,

228
00:11:33,940 --> 00:11:38,160
non vén na
cabeceira do ficheiro ,.

229
00:11:38,160 --> 00:11:40,770
Pola contra vén
algo que o equipo escribiu,

230
00:11:40,770 --> 00:11:44,176
que é un ficheiro diferente
nome, pero apropiadamente chamado.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Entón, simplemente engadindo que unha liña
da recordo code-- da última vez

233
00:11:50,861 --> 00:11:53,610
que cando Clang corre, vai
a ollar para o meu top código abaixo,

234
00:11:53,610 --> 00:11:54,193
esquerda a dereita.

235
00:11:54,193 --> 00:11:57,200
Vai notar,
Oh, quere.

236
00:11:57,200 --> 00:11:59,900
Deixe-me ir e descubrir que,
onde queira que sexa o servidor,

237
00:11:59,900 --> 00:12:03,090
copiar e pegalo, esencialmente,
na parte superior do seu propio arquivo

238
00:12:03,090 --> 00:12:06,820
de xeito que, neste punto da historia,
A liña 1, o resto do programa

239
00:12:06,820 --> 00:12:11,651
Pode, de feito, usar calquera das funcións
nel, entre eles get_string.

240
00:12:11,651 --> 00:12:13,650
Entón, eu vou ignorar
resto destes erros,

241
00:12:13,650 --> 00:12:17,190
porque, en realidade, sospeito que só
o primeiro realmente importaba.

242
00:12:17,190 --> 00:12:20,780
E eu estou indo a ir adiante e reprise,
despois de gardar o meu arquivo facer buggy1.

243
00:12:20,780 --> 00:12:22,580
E listo, fixo traballo.

244
00:12:22,580 --> 00:12:29,200
E se eu fai ./buggy1 e escriba, por
exemplo, Zamyla, agora terá Ola,

245
00:12:29,200 --> 00:12:32,000
Zamyla, no canto de Ola, mundo.

246
00:12:32,000 --> 00:12:32,550
>> Todo ben.

247
00:12:32,550 --> 00:12:35,890
Así, os takeaways aquí, logo deben,
un, tentar recoller o máximo que poida

248
00:12:35,890 --> 00:12:39,140
a partir das mensaxes de erro por si só, mirando
Nalgunhas das palabras recoñecibles.

249
00:12:39,140 --> 00:12:43,070
Excepto isto, usa help50 per
o conxunto de problemas especificación.

250
00:12:43,070 --> 00:12:46,500
Pero tirando iso, tamén, sempre mirar
na parte superior de erro única, polo menos

251
00:12:46,500 --> 00:12:50,051
inicialmente, para ver información
pode realmente render.

252
00:12:50,051 --> 00:12:52,300
Pero resulta que hai
aínda máis funcionalidade embutida

253
00:12:52,300 --> 00:12:55,030
para a Biblioteca CS50 para axudar
ti logo no inicio do semestre

254
00:12:55,030 --> 00:12:57,580
e no inicio da programación
descubrir o que está a suceder de malo.

255
00:12:57,580 --> 00:12:59,840
Entón imos facer outro exemplo aquí.

256
00:12:59,840 --> 00:13:04,350
Vou chamar este buggy2, que,
unha vez máis, será fallo fóra

257
00:13:04,350 --> 00:13:05,650
da porta, por deseño.

258
00:13:05,650 --> 00:13:09,980
>> E eu estou indo a ir adiante
e facer #include.

259
00:13:09,980 --> 00:13:12,580
E entón eu vou facer int main (void).

260
00:13:12,580 --> 00:13:14,840
E entón eu vou facer un loop.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i é menos que ou igual a 10.

263
00:13:18,750 --> 00:13:24,260
i ++, e logo entre chaves, eu vou
Para imprimir só un símbolo hashtag aquí

264
00:13:24,260 --> 00:13:25,920
e un novo carácter de liña.

265
00:13:25,920 --> 00:13:29,220
>> Así, a miña intención con este
programa é moi sinxelo

266
00:13:29,220 --> 00:13:33,150
para repetir 10 veces
e en cada iteración

267
00:13:33,150 --> 00:13:35,260
á vez que o circuíto
ao longo do ciclo,

268
00:13:35,260 --> 00:13:37,660
imprimir un hashtag,
unha hashtag, unha hashtag.

269
00:13:37,660 --> 00:13:40,480
Unha liña por mor I
ten a nova liña de alí.

270
00:13:40,480 --> 00:13:42,787
E lembrar que o de
loop, por último week--

271
00:13:42,787 --> 00:13:44,620
e vai ter máis
familiarizado coa sintaxe

272
00:13:44,620 --> 00:13:47,170
usar-o coa práctica
antes long-- iso dáme

273
00:13:47,170 --> 00:13:49,740
unha variable chamada i e defíneo como 0.

274
00:13:49,740 --> 00:13:52,650
>> Isto increméntase i na
cada iteración en 1.

275
00:13:52,650 --> 00:13:54,940
Así i vai a 1 a 2 a 3.

276
00:13:54,940 --> 00:13:57,690
E entón esta condición na
medio entre os puntos e comas

277
00:13:57,690 --> 00:14:03,010
checado cada iteración para facer
Asegúrese de que aínda están dentro do seu alcance.

278
00:14:03,010 --> 00:14:06,830
Entón, quero facer unha iteración 10 veces, entón eu
temos un tipo de moi intuitivamente só

279
00:14:06,830 --> 00:14:09,070
poñer 10 como o meu límite superior alí.

280
00:14:09,070 --> 00:14:14,310
>> E aínda así, cando executar este, despois de
recompila-lo co make buggy2--

281
00:14:14,310 --> 00:14:15,440
e non compilar Aceptar.

282
00:14:15,440 --> 00:14:17,980
Entón, eu non teño un
erro de sintaxe esta vez.

283
00:14:17,980 --> 00:14:20,940
Déixeme ir adiante agora
e realizar buggy2, Intro.

284
00:14:20,940 --> 00:14:22,620
E agora vai para arriba.

285
00:14:22,620 --> 00:14:24,890
E déixeme aumentar
o tamaño da fiestra.

286
00:14:24,890 --> 00:14:33,720
>> Eu parezo ter 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Polo tanto, hai 11 hashtags, aínda
Engada claramente 10 dentro deste loop.

288
00:14:38,891 --> 00:14:42,140
Agora, algúns de vostedes poden ver inmediatamente
o que o erro é porque, de feito, este

289
00:14:42,140 --> 00:14:43,720
Non é un erro moi difícil de facer.

290
00:14:43,720 --> 00:14:46,070
Pero é moi comunmente
feita moi cedo.

291
00:14:46,070 --> 00:14:49,820
>> O que quero salientar, con todo,
é, como eu podería descubrir iso?

292
00:14:49,820 --> 00:14:52,300
Ben, parece que
Biblioteca CS50 vén

293
00:14:52,300 --> 00:14:55,380
non só con get_string e get_int
e get_float e outras funcións.

294
00:14:55,380 --> 00:14:59,980
Tamén ven con unha función especial
chamado eprintf ou, erro printf.

295
00:14:59,980 --> 00:15:03,270
E hai unicamente para facer
Lo un pouco máis fácil para ti

296
00:15:03,270 --> 00:15:06,310
ao depurar o seu código para só
imprimir unha mensaxe de erro na pantalla

297
00:15:06,310 --> 00:15:07,850
e saber de onde veu.

298
00:15:07,850 --> 00:15:11,000
>> Así, por exemplo, unha cousa que eu podería
facer aquí con esta función é isto--

299
00:15:11,000 --> 00:15:20,230
eprintf, e entón eu estou indo a ir adiante
e dicir que está% i, barra invertida, n.

300
00:15:20,230 --> 00:15:22,330
E eu vou chamar o valor de i.

301
00:15:22,330 --> 00:15:25,400
E encima, porque este
está na Biblioteca CS50,

302
00:15:25,400 --> 00:15:27,580
Eu estou indo a ir adiante
e incluír

303
00:15:27,580 --> 00:15:29,169
entón eu teño acceso a esta función.

304
00:15:29,169 --> 00:15:31,460
Pero imos considerar o que liña
9 se quere estar a facer.

305
00:15:31,460 --> 00:15:32,670
Vou borrar este eventualmente.

306
00:15:32,670 --> 00:15:34,670
Isto non ten nada que ver
co meu obxectivo global.

307
00:15:34,670 --> 00:15:39,090
Pero eprintf, printf de erro, é só significou
para me dar unha información de diagnóstico.

308
00:15:39,090 --> 00:15:42,460
Cando executar o meu programa, quero
ver iso na pantalla temporalmente

309
00:15:42,460 --> 00:15:44,550
ben só para entender
o que está pasando.

310
00:15:44,550 --> 00:15:47,330
>> E, de feito, en cada
iteración aquí da liña 9

311
00:15:47,330 --> 00:15:49,260
Quero ver, cal é o valor de i?

312
00:15:49,260 --> 00:15:50,290
Qué é o valor de i?

313
00:15:50,290 --> 00:15:51,280
Qué é o valor de i?

314
00:15:51,280 --> 00:15:55,650
E, esperanza, eu debería
vexa esta mensaxe, tamén, 10 veces.

315
00:15:55,650 --> 00:15:57,780
>> Entón deixe-me ir adiante e
recompilar o meu programa,

316
00:15:57,780 --> 00:15:59,905
como eu teño que facer a calquera hora
I facer un cambio. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
E agora-- Aceptar.

319
00:16:03,640 --> 00:16:04,820
Hai moito máis a suceder.

320
00:16:04,820 --> 00:16:07,610
Entón deixe-me rolar para arriba no
un diálogo aínda maior.

321
00:16:07,610 --> 00:16:10,190
>> E podes ver que cada un de
o hashtags aínda está imprimindo.

322
00:16:10,190 --> 00:16:15,270
Pero entre cada un deles é agora este
saída de diagnóstico formato como segue.

323
00:16:15,270 --> 00:16:17,960
O nome do meu programa aquí é buggy2.

324
00:16:17,960 --> 00:16:20,432
O nome do ficheiro é buggy2.c.

325
00:16:20,432 --> 00:16:24,080
O número da liña a partir da cal
este foi impresa é a liña 9.

326
00:16:24,080 --> 00:16:27,500
E, a continuación, a dereita que é a
mensaxe de erro que eu estou esperando.

327
00:16:27,500 --> 00:16:30,701
>> E o que é bo sobre iso é que
Agora eu non teño que contar, necesariamente,

328
00:16:30,701 --> 00:16:32,200
na miña cabeza que o meu programa está facendo.

329
00:16:32,200 --> 00:16:34,240
Podo ver que na
primeira iteración i é 0,

330
00:16:34,240 --> 00:16:39,420
logo 1, logo 2, logo, 3, 4, logo logo
5, a continuación, 6, 7, a continuación, en seguida, 8, 9, logo logo

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Entón, agarde un minuto.

333
00:16:42,050 --> 00:16:43,740
O que está pasando aquí?

334
00:16:43,740 --> 00:16:48,190
Eu aínda parecen estar contando
como desexado ata 10.

335
00:16:48,190 --> 00:16:50,550
>> Pero onde eu comezo?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10.

337
00:16:53,240 --> 00:16:58,040
Así, 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- o 11º dedo

338
00:16:58,040 --> 00:16:59,990
é indicativa do problema.

339
00:16:59,990 --> 00:17:02,850
Paréceme contar
incorrectamente no meu loop.

340
00:17:02,850 --> 00:17:06,599
En vez de ir a 10 iteracións,
Estou empezando a 0,

341
00:17:06,599 --> 00:17:09,550
Estou terminando en ea través de 10.

342
00:17:09,550 --> 00:17:12,030
Senón porque, como un ordenador,
Estou empezando a conta en 0,

343
00:17:12,030 --> 00:17:15,250
Eu debería estar contando
para, pero non a través, 10.

344
00:17:15,250 --> 00:17:18,510
>> E así a corrección, finalmente
entender aquí, é unha das dúas cousas.

345
00:17:18,510 --> 00:17:22,430
Podería moi simplemente dicir
cóntanse a menos de 10.

346
00:17:22,430 --> 00:17:27,260
Así, 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, que é, de feito, correcto,

347
00:17:27,260 --> 00:17:28,900
aínda que iso soa un pouco mal.

348
00:17:28,900 --> 00:17:35,070
Ou eu podería facer igual ou inferior
a 9, mentres eu comezo a 0.

349
00:17:35,070 --> 00:17:40,056
Ou se realmente non gusta diso,
pode contar-se a 10, pero comezar en 1.

350
00:17:40,056 --> 00:17:41,680
Pero, de novo, iso non é tan común.

351
00:17:41,680 --> 00:17:43,977
En programming-- aínda
non tanto en Scratch--

352
00:17:43,977 --> 00:17:45,810
pero en programación en
C e outras linguaxes,

353
00:17:45,810 --> 00:17:47,670
como Javascript e
Python e outros, é

354
00:17:47,670 --> 00:17:49,880
só moi común para
nosa discusión de par

355
00:17:49,880 --> 00:17:53,450
só para comezar a contar no
menor número posible, que é 0.

356
00:17:53,450 --> 00:17:53,950
Todo ben.

357
00:17:53,950 --> 00:17:55,160
Entón, iso é eprintf.

358
00:17:55,160 --> 00:17:58,600
E unha vez máis, agora que eu descubrir o meu
problema, e eu vou volver a 0

359
00:17:58,600 --> 00:18:01,470
mediante menos de 10, eu vou
para entrar e eliminar eprintf.

360
00:18:01,470 --> 00:18:04,580
>> Non debería estar alí cando
Envío o meu código ou enviar o meu código

361
00:18:04,580 --> 00:18:05,800
ou mostra-lo a ninguén.

362
00:18:05,800 --> 00:18:07,980
É realmente só significou
para ser usado temporalmente.

363
00:18:07,980 --> 00:18:11,650
Pero agora eu reparei que
nomeadamente problema ben.

364
00:18:11,650 --> 00:18:16,780
>> Ben, imos facer un exemplo aquí
que eu estou indo a chicotear enriba do seguinte xeito.

365
00:18:16,780 --> 00:18:22,850
Eu estou indo a ir adiante e
#include. $ 50

366
00:18:22,850 --> 00:18:25,580
E eu estou indo a ir adiante
e #include.

367
00:18:25,580 --> 00:18:29,030
>> E eu estou indo a salvar
este ficheiro como buggy3.c.

368
00:18:29,030 --> 00:18:31,740
E eu estou indo a ir adiante
e declarar int main (void).

369
00:18:31,740 --> 00:18:34,186
E entón dentro
Vou facer int i _ -

370
00:18:34,186 --> 00:18:36,435
Quero aplicar un programa
cun get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
Esta non é unha función que existe aínda.

373
00:18:40,770 --> 00:18:42,870
Entón, nós estamos indo a aplicar
Lo en só un momento.

374
00:18:42,870 --> 00:18:45,541
Pero imos ver por que
é de buggy en primeira pasaxe.

375
00:18:45,541 --> 00:18:47,290
E xa que comece
un int do usuario,

376
00:18:47,290 --> 00:18:53,365
Eu só vou para imprimir% i é un negativo
enteiro, barra invertida, n, coma, i.

377
00:18:53,365 --> 00:18:55,240
Noutras palabras, as I
Quere este programa para facer

378
00:18:55,240 --> 00:18:58,000
é obter un int negativa de
o usuario e, a continuación, imprimir

379
00:18:58,000 --> 00:18:59,980
que tal e tal é un int negativo.

380
00:18:59,980 --> 00:19:02,080
>> Agora eu teño para aplicar esta función.

381
00:19:02,080 --> 00:19:05,740
Entón, máis tarde no meu arquivo, eu estou indo a ir
adiante e declarar unha función chamada

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - e nós
volver ao que esta liña significa novo

383
00:19:10,670 --> 00:19:18,790
nun moment-- int n; fazer-- facer
o following-- printf n é:.

384
00:19:18,790 --> 00:19:26,210
E entón eu vou facer n - get_int,
e facelo mentres n é maior que 0.

385
00:19:26,210 --> 00:19:28,310
E despois volver n;.

386
00:19:28,310 --> 00:19:31,730
>> Polo tanto, hai moita cousa a suceder na
iso, pero ningún dos cales non

387
00:19:31,730 --> 00:19:33,710
ollar a semana pasada, polo menos momentaneamente.

388
00:19:33,710 --> 00:19:36,980
Así, na liña 10 aquí eu teño declarado
función chamada get_negative_int,

389
00:19:36,980 --> 00:19:39,620
e engada (void), en
parénteses, a razón de ser desta

390
00:19:39,620 --> 00:19:40,950
Non é preciso unha entrada.

391
00:19:40,950 --> 00:19:42,910
Non estou pasando todo
para esta función.

392
00:19:42,910 --> 00:19:44,690
Estou só comezando algo de volta a partir del.

393
00:19:44,690 --> 00:19:47,270
>> E o que eu estou esperando para
volver é un enteiro.

394
00:19:47,270 --> 00:19:50,040
Non hai ningún tipo de datos en
C chamado negative_int.

395
00:19:50,040 --> 00:19:52,880
É só int, polo que vai
estar en nós para asegurarse de

396
00:19:52,880 --> 00:19:55,340
que o valor que realmente
retorno é non só un int

397
00:19:55,340 --> 00:19:56,380
pero tamén é negativo.

398
00:19:56,380 --> 00:20:02,150
>> Na liña 12 Estou declarando unha variable
chamado n e tornándose a do tipo int.

399
00:20:02,150 --> 00:20:07,500
E, a continuación, na liña 13 a 18 que eu son
facendo algo mentres algo é certo.

400
00:20:07,500 --> 00:20:11,040
Eu vou adiante e impresión
n é, de colonos, e logo un espazo,

401
00:20:11,040 --> 00:20:12,800
como un aviso para o usuario.

402
00:20:12,800 --> 00:20:16,410
>> Estou logo chamando get_int e
almacenar o seu chamado valor de retorno

403
00:20:16,410 --> 00:20:18,130
nesa variable n.

404
00:20:18,130 --> 00:20:22,600
Pero eu vou seguir facendo
mentres esta n é maior que 0.

405
00:20:22,600 --> 00:20:27,960
Noutras palabras, se o usuario-me un dá
int e ese número é maior que 0,

406
00:20:27,960 --> 00:20:31,180
ergo, positivo, eu vou
Só ten que manter reprompting o usuario,

407
00:20:31,180 --> 00:20:37,160
manter reprompting, forzándoos a
cooperar e me dar un int negativo.

408
00:20:37,160 --> 00:20:41,640
>> E xa que n é en realidade negative--
Supoña que o usuario finalmente tipo -50,

409
00:20:41,640 --> 00:20:46,710
entón este loop while non é verdade
-50 Porque non é maior que 0.

410
00:20:46,710 --> 00:20:51,140
Entón, nós saír desa
loop de lóxica e voltar n.

411
00:20:51,140 --> 00:20:53,520
>> Pero hai outra
cousa que teño que facer.

412
00:20:53,520 --> 00:20:56,190
E podo simplemente facelo
copiando e colando

413
00:20:56,190 --> 00:20:58,540
unha liña de código na parte superior do ficheiro.

414
00:20:58,540 --> 00:21:01,630
Necesito ensinar Clang,
ou promesa de Clang,

415
00:21:01,630 --> 00:21:04,630
explicitamente que quero,
en realidade, ir e aplicar

416
00:21:04,630 --> 00:21:06,020
esta función get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Podería ser só máis baixa no ficheiro.

418
00:21:07,674 --> 00:21:09,840
Unha vez máis, recordar que Clang
le as cousas de arriba abaixo,

419
00:21:09,840 --> 00:21:12,330
esquerda a dereita, de xeito que non pode
chamar unha función, se Clang

420
00:21:12,330 --> 00:21:15,330
non sabe que vai existir.

421
00:21:15,330 --> 00:21:18,430
>> Agora, por desgraza, este programa,
Como algúns de vostedes deben notar,

422
00:21:18,430 --> 00:21:19,590
xa é buggy.

423
00:21:19,590 --> 00:21:21,400
Deixe-me ir adiante e facer buggy3.

424
00:21:21,400 --> 00:21:26,904
El compila, por iso o meu problema non é
un erro de sintaxe, como un erro textual,

425
00:21:26,904 --> 00:21:29,570
é, en realidade, vai ser unha lóxica
erro que eu teño deliberadamente

426
00:21:29,570 --> 00:21:32,450
feita como unha oportunidade de
percorrer o que está pasando.

427
00:21:32,450 --> 00:21:35,540
>> Eu estou indo a ir adiante
agora e executar buggy3.

428
00:21:35,540 --> 00:21:37,490
E eu estou indo a ir
adiante e non cooperar.

429
00:21:37,490 --> 00:21:39,494
Vou darlle o número 1.

430
00:21:39,494 --> 00:21:41,410
Non gusta, entón
iso está me levando de novo.

431
00:21:41,410 --> 00:21:42,147
>> Como preto de 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Ningún dos que están a traballar.

435
00:21:44,740 --> 00:21:46,890
Como case -50?

436
00:21:46,890 --> 00:21:48,560
E o programa parece funcionar.

437
00:21:48,560 --> 00:21:49,970
>> Déixeme probar unha vez máis.

438
00:21:49,970 --> 00:21:53,400
Déixeme probar -1, parece funcionar.

439
00:21:53,400 --> 00:21:56,380
Déixeme probar -2, parece funcionar.

440
00:21:56,380 --> 00:21:59,640
Déixeme probar 0.

441
00:21:59,640 --> 00:22:01,684
Huh, iso é incorrecto.

442
00:22:01,684 --> 00:22:03,350
Agora, estamos a ser un pouco pedante aquí.

443
00:22:03,350 --> 00:22:07,090
Pero é, en realidade, o caso de que 0
non é nin positivo nin negativo.

444
00:22:07,090 --> 00:22:11,150
E así o feito de que o meu programa é
dicindo que 0 é un enteiro negativo,

445
00:22:11,150 --> 00:22:12,820
iso non é tecnicamente correcto.

446
00:22:12,820 --> 00:22:15,180
>> Agora, por que está facendo iso?

447
00:22:15,180 --> 00:22:16,270
Ben, pode ser evidente.

448
00:22:16,270 --> 00:22:18,110
E, de feito, o programa é
pretende ser moi sinxelo

449
00:22:18,110 --> 00:22:19,670
polo que temos algo para explorar.

450
00:22:19,670 --> 00:22:25,870
>> Pero imos introducir unha terceira depuración
técnica aquí chamado debug50.

451
00:22:25,870 --> 00:22:27,750
Polo tanto, este é un programa
que acaba de crear

452
00:22:27,750 --> 00:22:30,770
este ano chamado debug50
que permitirá que

453
00:22:30,770 --> 00:22:34,130
usar o que se chama un built-in
depurador gráfico no IDE CS50.

454
00:22:34,130 --> 00:22:38,400
E un depurador é só un programa que
xeralmente permite que executa o seu programa

455
00:22:38,400 --> 00:22:44,050
pero paso a paso a paso, liña
por liña por liña, parando, cutucando

456
00:22:44,050 --> 00:22:47,626
arredor, mirando para as variables de xeito que
o programa non só golpe pasado vostede

457
00:22:47,626 --> 00:22:49,750
e imprimir rapidamente algo
ou non imprimir algo.

458
00:22:49,750 --> 00:22:53,250
Dálle unha oportunidade, polo
velocidade humana, para interactuar con el.

459
00:22:53,250 --> 00:22:55,470
>> E para iso, ten
simplemente faga o seguinte.

460
00:22:55,470 --> 00:22:58,479
Despois de compilar o seu código,
que eu xa fixen, buggy3,

461
00:22:58,479 --> 00:23:00,020
dalle correr debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Tan parecido help50 ten de executar
help50 e entón a orde,

464
00:23:06,760 --> 00:23:10,120
debug50 ten de executar debug50 e
a continuación, o nome do comando.

465
00:23:10,120 --> 00:23:14,440
>> Agora observe o que pasa na miña pantalla,
no lado da man dereita en particular.

466
00:23:14,440 --> 00:23:19,400
Cando bati Run, todo
panel deste dereito súbita

467
00:23:19,400 --> 00:23:20,419
abre en pantalla.

468
00:23:20,419 --> 00:23:22,210
E hai moita cousa a suceder
na que a primeira vista.

469
00:23:22,210 --> 00:23:25,110
Pero non hai moito
moito que preocuparse aínda.

470
00:23:25,110 --> 00:23:28,570
>> Isto me amosando todo
que está a suceder dentro do meu programa

471
00:23:28,570 --> 00:23:31,130
agora ea través destes
botóns para arriba arriba é entón

472
00:23:31,130 --> 00:23:35,910
permitindo-me a percorrer o meu código
en definitiva, paso a paso a paso.

473
00:23:35,910 --> 00:23:37,140
Pero aínda non.

474
00:23:37,140 --> 00:23:38,060
Teña en conta o que pasa.

475
00:23:38,060 --> 00:23:40,600
Na miña fiestra de terminal
Estou sendo solicitado para n.

476
00:23:40,600 --> 00:23:44,560
E eu estou indo a ir adiante e
cooperar neste momento e escriba -1.

477
00:23:44,560 --> 00:23:48,770
E aínda que un pouco enigmaticamente, -1
é un número enteiro negativo, como se esperaba.

478
00:23:48,770 --> 00:23:52,020
>> E, a continuación, fillo rematou
Status 0 gdbserver saír.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, é o nome
do software subxacente

480
00:23:55,180 --> 00:23:56,620
que aplica esta depurador.

481
00:23:56,620 --> 00:24:00,500
Pero todo isto realmente significa, o depurador
marchou porque o meu programa de saír

482
00:24:00,500 --> 00:24:01,710
e todo estaba ben.

483
00:24:01,710 --> 00:24:06,020
Se eu queira depurar verdadeiramente meu programa,
Eu teño que dicir cautelarmente debug50,

484
00:24:06,020 --> 00:24:08,920
Onde me gustaría comezar
percorrendo o meu código?

485
00:24:08,920 --> 00:24:11,750
>> E quizais a forma máis simple
para facer isto é como segue.

486
00:24:11,750 --> 00:24:15,300
Se eu pair sobre o
sarjeta do meu editor aquí,

487
00:24:15,300 --> 00:24:19,090
polo que realmente só na barra lateral aquí,
á esquerda do número de liña,

488
00:24:19,090 --> 00:24:21,870
Teña en conta que, se eu só clic
Unha vez máis, eu coloque un pequeno punto vermello.

489
00:24:21,870 --> 00:24:24,460
E aquel pequeno punto vermello,
como un sinal de parada, significa, hey,

490
00:24:24,460 --> 00:24:29,430
debug50, execución de descanso do meu código
alí cando executar este programa.

491
00:24:29,430 --> 00:24:30,260
>> Entón, imos facelo.

492
00:24:30,260 --> 00:24:37,340
Deixe-me ir adiante e executar o meu programa
de novo con debug50 ./buggy3, Intro.

493
00:24:37,340 --> 00:24:40,110
E agora, o aviso previo, algo
diferente pasou.

494
00:24:40,110 --> 00:24:42,440
Non estou a ser solicitado
aínda na miña fiestra de terminal

495
00:24:42,440 --> 00:24:45,430
para nada, porque eu non teño
chegado alí aínda no meu programa.

496
00:24:45,430 --> 00:24:47,950
Teña en conta que na liña 8
que agora está en destaque,

497
00:24:47,950 --> 00:24:51,720
e hai unha pequena frecha no
dito esquerda, está en pausa aquí.

498
00:24:51,720 --> 00:24:55,030
Esta liña de código, liña
8, aínda non foi executado.

499
00:24:55,030 --> 00:24:58,940
>> E o que é curioso, se eu ollar
aquí no lado da man dereita,

500
00:24:58,940 --> 00:25:03,530
Repare que eu é o lugar
variable, lugar no sentido

501
00:25:03,530 --> 00:25:05,450
que é dentro da función actual.

502
00:25:05,450 --> 00:25:08,920
E o seu valor, ao parecer, por defecto,
e tipo de convenientemente, é 0.

503
00:25:08,920 --> 00:25:10,260
Pero eu non escriba 0.

504
00:25:10,260 --> 00:25:13,410
Isto só pasa de ser a súa
valor por defecto no momento.

505
00:25:13,410 --> 00:25:15,490
>> Entón deixe-me ir adiante e facelo agora.

506
00:25:15,490 --> 00:25:18,680
Deixe-me ir adiante e na
ángulo superior dereito aquí, estou

507
00:25:18,680 --> 00:25:20,970
indo a ir adiante e
prema neste primeiro icona que

508
00:25:20,970 --> 00:25:25,360
significa un paso sobre o que significa que non pule
pero pasar por riba desta liña de código,

509
00:25:25,360 --> 00:25:27,770
executa-lo ao longo do camiño.

510
00:25:27,770 --> 00:25:30,710
>> E agora, teña en conta o meu
liña acaba de cambiar.

511
00:25:30,710 --> 00:25:31,380
Por que é iso?

512
00:25:31,380 --> 00:25:33,639
Eu dixen debug50,
executar esta liña de código.

513
00:25:33,639 --> 00:25:34,930
Que esta liña de código fai?

514
00:25:34,930 --> 00:25:35,960
Lévame a un int.

515
00:25:35,960 --> 00:25:36,460
OK.

516
00:25:36,460 --> 00:25:37,400
Déixeme cooperar.

517
00:25:37,400 --> 00:25:41,340
Déixeme ir adiante agora e escriba -1, Intro.

518
00:25:41,340 --> 00:25:42,920
E agora entender o que cambiou.

519
00:25:42,920 --> 00:25:46,060
Do lado da man dereita,
miña variable local i

520
00:25:46,060 --> 00:25:48,200
indícase como -1 agora.

521
00:25:48,200 --> 00:25:49,810
E aínda é do tipo int.

522
00:25:49,810 --> 00:25:53,102
>> E teña en conta, ademais, a miña chamada
chamar pila, onde eu facer unha pausa?

523
00:25:53,102 --> 00:25:54,810
Falaremos máis sobre
esta no futuro.

524
00:25:54,810 --> 00:25:58,620
Pero a pila de chamadas se refire ao que
funcións están en movemento.

525
00:25:58,620 --> 00:26:00,040
Agora é só principal.

526
00:26:00,040 --> 00:26:03,590
E agora o único lugar,
variable representa I, cun valor de 1.

527
00:26:03,590 --> 00:26:09,840
>> E cando finalmente pasar por riba desta liña
aquí, con aquel mesmo icona na esquina superior dereita,

528
00:26:09,840 --> 00:26:11,410
-1 É un enteiro negativo.

529
00:26:11,410 --> 00:26:13,580
Agora que está parando ao longo deste chaveta.

530
00:26:13,580 --> 00:26:14,740
Imos deixar facer a súa cousa.

531
00:26:14,740 --> 00:26:17,300
Eu pasar por riba desta liña, e listo.

532
00:26:17,300 --> 00:26:20,240
>> Entón, non todo o que terriblemente
esclarecedor aínda,

533
00:26:20,240 --> 00:26:23,550
pero deixoume facer unha pausa
e pensar loxicamente

534
00:26:23,550 --> 00:26:24,870
o que este programa está facendo.

535
00:26:24,870 --> 00:26:26,890
Pero iso non foi o caso errónea.

536
00:26:26,890 --> 00:26:28,510
Imos facer iso de novo como segue.

537
00:26:28,510 --> 00:26:31,340
>> Vou deixar ese punto de interrupción
na liña 8 co punto vermello.

538
00:26:31,340 --> 00:26:32,830
Eu estou indo a executar de novo debug50.

539
00:26:32,830 --> 00:26:34,400
É automaticamente unha pausa aquí.

540
00:26:34,400 --> 00:26:37,660
Pero esta vez, en vez de
pisando sobre esta liña,

541
00:26:37,660 --> 00:26:42,290
déixeme realmente ir dentro
get_negative_int e descubrir,

542
00:26:42,290 --> 00:26:45,530
por que é aceptar 0 como unha resposta válida?

543
00:26:45,530 --> 00:26:47,990
>> Entón, en vez de premer Step Over.

544
00:26:47,990 --> 00:26:50,630
Eu estou indo a ir adiante
e prema en Step Into.

545
00:26:50,630 --> 00:26:54,030
E teña en conta que a liña 8, que
agora destacado agora, de súpeto

546
00:26:54,030 --> 00:26:56,900
convértese en liña 17.

547
00:26:56,900 --> 00:26:59,947
>> Agora, non é que o depurador
ignorou as liñas 14 e 15 e 16.

548
00:26:59,947 --> 00:27:01,780
É só que non hai nada
para amosar-lle alí.

549
00:27:01,780 --> 00:27:04,050
Estas son só declarar variables,
E despois hai a palabra Faga

550
00:27:04,050 --> 00:27:05,390
e despois unha chaveta aberto.

551
00:27:05,390 --> 00:27:09,227
A única liña funcional que é
suculento realmente é este aquí, 17.

552
00:27:09,227 --> 00:27:11,060
E é aí onde temos
pausada automaticamente.

553
00:27:11,060 --> 00:27:13,870
>> Entón printf ( "n.is:"); por iso
que aínda non ocorreu.

554
00:27:13,870 --> 00:27:18,250
Entón, imos adiante e prema Step Over.

555
00:27:18,250 --> 00:27:20,326
Agora, a miña liña, de feito,
cambiado ( "N é:").

556
00:27:20,326 --> 00:27:22,450
Agora get_int, eu non vou
incomodá entrando,

557
00:27:22,450 --> 00:27:24,750
porque esta función foi
feita por CS50 na Biblioteca.

558
00:27:24,750 --> 00:27:25,750
É probabelmente correcto.

559
00:27:25,750 --> 00:27:28,440
>> Entón, eu estou indo a ir adiante e
tipo de cooperar, dándolle

560
00:27:28,440 --> 00:27:30,590
un int, pero non un int negativo.

561
00:27:30,590 --> 00:27:32,870
Entón deixe-me ir adiante e bateu 0.

562
00:27:32,870 --> 00:27:39,460
E agora o que pasa aquí
cando descender á liña 21?

563
00:27:39,460 --> 00:27:40,890
Non teño reiterou de novo.

564
00:27:40,890 --> 00:27:43,320
Non parecen ser preso nese loop.

565
00:27:43,320 --> 00:27:45,990
Noutras palabras, este amarelo
bar non siga indo ao redor,

566
00:27:45,990 --> 00:27:47,130
e ao redor, e ao redor.

567
00:27:47,130 --> 00:27:48,340
>> Agora, por que isto?

568
00:27:48,340 --> 00:27:49,920
Ben, n, o que é n agora?

569
00:27:49,920 --> 00:27:53,280
Podo ollar para o lugar,
variables no depurador.

570
00:27:53,280 --> 00:27:53,816
n é 0.

571
00:27:53,816 --> 00:27:55,190
Todo ben, o que foi a miña condición?

572
00:27:55,190 --> 00:27:58,700
>> 20-- liña 20 é, así,
0 é maior que 0.

573
00:27:58,700 --> 00:27:59,500
Iso non é verdade.

574
00:27:59,500 --> 00:28:01,020
0 non é maior que 0.

575
00:28:01,020 --> 00:28:02,820
E así eu rompe a fóra deste.

576
00:28:02,820 --> 00:28:06,370
>> E é por iso que na liña
21, se eu realmente continuar,

577
00:28:06,370 --> 00:28:10,370
Eu estou indo a retornar 0, mesmo
aínda que debería rexeitado 0

578
00:28:10,370 --> 00:28:12,484
a non ser realmente negativo.

579
00:28:12,484 --> 00:28:14,650
Entón, agora, realmente non mesmo
se preocupan o depurador.

580
00:28:14,650 --> 00:28:16,900
Entendín, eu non teño
sei que máis está a suceder.

581
00:28:16,900 --> 00:28:19,233
>> Entón, eu estou indo a ir adiante e
basta con premer no botón Play,

582
00:28:19,233 --> 00:28:20,240
e deixar este fin.

583
00:28:20,240 --> 00:28:23,440
Agora podo entender que a miña
erro é, ao parecer, na liña 20.

584
00:28:23,440 --> 00:28:25,160
Ese é o meu erro lóxico.

585
00:28:25,160 --> 00:28:28,100
>> E entón o que quero
que facer para cambiar isto?

586
00:28:28,100 --> 00:28:32,500
Se o problema é que eu non son
pegando 0, é só un erro de lóxica.

587
00:28:32,500 --> 00:28:35,910
E podo dicir cando n é
maior que ou igual a 0,

588
00:28:35,910 --> 00:28:38,330
manter avisar o usuario novo e de novo.

589
00:28:38,330 --> 00:28:41,050
>> Entón, de novo, simple erro, quizais
mesmo evidente cando me viu

590
00:28:41,050 --> 00:28:42,410
gravala-lo só uns minutos.

591
00:28:42,410 --> 00:28:44,570
Pero o takeaway aquí
é que, con depuración 50,

592
00:28:44,570 --> 00:28:46,850
e coa depuración
software dun xeito máis xeral,

593
00:28:46,850 --> 00:28:51,370
ten ese novo poder para
camiñar polo seu propio código, ollar

594
00:28:51,370 --> 00:28:55,590
a través dese panel do lado dereito que
seus valores variables son.

595
00:28:55,590 --> 00:28:57,700
Entón, non necesariamente
Ten que usar algo

596
00:28:57,700 --> 00:29:00,630
como eprintf para imprimir estes valores.

597
00:29:00,630 --> 00:29:04,430
Realmente pode velos
visualmente na pantalla.

598
00:29:04,430 --> 00:29:08,920
>> Agora, ademais, é importante ter en conta
que non hai outra técnica que é

599
00:29:08,920 --> 00:29:09,890
realmente super-común.

600
00:29:09,890 --> 00:29:13,120
E pode preguntar por que este pequeno
cara aquí foi sentado no escenario.

601
00:29:13,120 --> 00:29:16,490
Polo tanto, hai esa técnica, en xeral
coñecido como o pato de goma depuración,

602
00:29:16,490 --> 00:29:18,786
o que realmente é só unha
testamento ao feito

603
00:29:18,786 --> 00:29:20,660
que os programadores moitas veces, cando
está escribindo código,

604
00:29:20,660 --> 00:29:22,650
eles non son necesariamente
colaborar con outras persoas,

605
00:29:22,650 --> 00:29:24,030
ou traballar nun ambiente compartido.

606
00:29:24,030 --> 00:29:25,050
>> Son tipo de casa.

607
00:29:25,050 --> 00:29:25,910
Quizais sexa tarde de noite.

608
00:29:25,910 --> 00:29:28,190
Eles están tentando figura
algún erro no seu código.

609
00:29:28,190 --> 00:29:29,330
E simplemente non está a ver iso.

610
00:29:29,330 --> 00:29:30,329
>> E non hai ningún compañeiro de cuarto.

611
00:29:30,329 --> 00:29:31,250
Non hai TF.

612
00:29:31,250 --> 00:29:32,680
Non hai CA torno.

613
00:29:32,680 --> 00:29:36,440
Todo o que teñen na súa andel
é este pequeno Patiño de caucho.

614
00:29:36,440 --> 00:29:39,030
>> E así pato de goma depuración
é só esta invitación

615
00:29:39,030 --> 00:29:42,780
pensar en algo tan parvo
como esta como unha criatura real

616
00:29:42,780 --> 00:29:46,940
e realmente andar a través do seu código
verbalmente a este obxecto inanimado.

617
00:29:46,940 --> 00:29:49,230
Así, por exemplo, se
este é o meu exemplo aqui--

618
00:29:49,230 --> 00:29:52,470
e recordar que a principios
o problema era ese,

619
00:29:52,470 --> 00:29:58,140
se eu eliminar esta primeira liña de código,
e eu ir adiante e facer buggy de 0 novo,

620
00:29:58,140 --> 00:30:01,220
lembro que eu tiña eses
mensaxes de erro aquí.

621
00:30:01,220 --> 00:30:05,997
Polo tanto, a idea aquí, ridículo que
sente no momento facendo iso publicamente,

622
00:30:05,997 --> 00:30:06,580
é que o erro.

623
00:30:06,580 --> 00:30:10,910
>> OK, entón o meu problema é que eu teño
implicitamente declarada unha función de biblioteca.

624
00:30:10,910 --> 00:30:12,610
E esa función de biblioteca é printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, declarar
recórdame de prototipos.

626
00:30:15,290 --> 00:30:18,930
>> Isto significa que eu teño realmente
informar o compilador de antemán o que

627
00:30:18,930 --> 00:30:19,980
a función se parece.

628
00:30:19,980 --> 00:30:20,930
Espera un minuto.

629
00:30:20,930 --> 00:30:23,580
Non tiña io.h. estándar

630
00:30:23,580 --> 00:30:24,530
Moitas grazas.

631
00:30:24,530 --> 00:30:27,330
>> Entón, só este proceso de-- vostede
Non precisa realmente ter un pato.

632
00:30:27,330 --> 00:30:29,819
Pero esta idea de camiñar
-Se a través do seu propio código

633
00:30:29,819 --> 00:30:31,610
de xeito que nin escoitar
mesmo, para que

634
00:30:31,610 --> 00:30:35,620
entender omisións no seu propio
observacións, adoita ser a idea.

635
00:30:35,620 --> 00:30:38,910
>> E, quizais máis loxicamente, non tan
tanto que un, pero o máis implicados

636
00:30:38,910 --> 00:30:44,220
exemplo que acabamos de facer en 3.c de buggy,
pode camiñar a través del

637
00:30:44,220 --> 00:30:45,310
como segue.

638
00:30:45,310 --> 00:30:49,190
Entón todo ben, goma
ducky, DDB, se quere.

639
00:30:49,190 --> 00:30:52,350
Aquí temos na miña función principal,
Estou chamando obter int negativo.

640
00:30:52,350 --> 00:30:54,660
>> E eu estou a recibir o valor de retorno.

641
00:30:54,660 --> 00:31:00,410
Estou almacenando o no lado esquerdo
na liña 8 nunha variable chamada i.

642
00:31:00,410 --> 00:31:02,380
OK, pero espera, como fixo
que obter ese valor?

643
00:31:02,380 --> 00:31:04,130
Déixeme mirar a función na liña 12.

644
00:31:04,130 --> 00:31:05,760
>> Na liña 12, temos obter int negativo.

645
00:31:05,760 --> 00:31:08,190
non tomar calquera entradas,
non voltar un int, OK.

646
00:31:08,190 --> 00:31:10,929
Declaro na liña 14 unha variable n.

647
00:31:10,929 --> 00:31:12,220
Vai gardar un número enteiro.

648
00:31:12,220 --> 00:31:13,760
Iso é o que quero.

649
00:31:13,760 --> 00:31:18,480
>> Entón faga o seguinte mentres n é-- deixe
me desfacer o que a corrección xa fixen.

650
00:31:18,480 --> 00:31:22,710
Así, mentres que n é maior que
0, imprima n é, OK.

651
00:31:22,710 --> 00:31:25,170
E despois chamar se int almacenado n.

652
00:31:25,170 --> 00:31:30,160
E, a continuación, comprobar se n é 0,
n é não-- aí está.

653
00:31:30,160 --> 00:31:31,910
Entón, de novo, non facer
Debe o pato real.

654
00:31:31,910 --> 00:31:35,650
Pero só camiñando a través de
seu código como un exercicio intelectual

655
00:31:35,650 --> 00:31:37,720
moitas veces vai axudar
entender o que está pasando,

656
00:31:37,720 --> 00:31:41,170
no canto de só facer algo
así, mirando para a pantalla,

657
00:31:41,170 --> 00:31:43,720
e non falar a través de
Lo, o que sinceramente non é

658
00:31:43,720 --> 00:31:46,270
case como unha técnica eficaz.

659
00:31:46,270 --> 00:31:48,620
Entón, ten iso, unha
número de técnicas diferentes

660
00:31:48,620 --> 00:31:52,102
para realmente depuración do código
e atopar o fallo, os cales

661
00:31:52,102 --> 00:31:54,810
deben ferramentas na súa caixa de ferramentas
de xeito que non é tarde de noite,

662
00:31:54,810 --> 00:31:57,660
especialmente, está na cea
salóns, ou polo horario de oficina,

663
00:31:57,660 --> 00:32:00,368
batendo coa cabeza contra o
parede, intentando resolver problemas.

664
00:32:00,368 --> 00:32:02,020
Entender que existen ferramentas de software.

665
00:32:02,020 --> 00:32:03,720
Existen ferramentas de pato de goma.

666
00:32:03,720 --> 00:32:09,630
E hai un equipo enteira de
apoiar esperando para dar unha man.

667
00:32:09,630 --> 00:32:13,120
>> Entón, agora, unha palabra sobre o problema
conxuntos, e sobre o que estamos esperando que

668
00:32:13,120 --> 00:32:15,620
saír deles, e como
nós imos sobre a avaliación.

669
00:32:15,620 --> 00:32:17,680
Por Syllabus do curso,
conxuntos de problemas CS50

670
00:32:17,680 --> 00:32:22,320
son avaliados en catro eixos primarios, así
para speak-- ámbito de aplicación, corrección, deseño,

671
00:32:22,320 --> 00:32:23,060
e estilo.

672
00:32:23,060 --> 00:32:25,910
E alcance só se refire a como
da peza que mordido?

673
00:32:25,910 --> 00:32:28,080
Como dun problema xa intentou?

674
00:32:28,080 --> 00:32:30,110
O nivel de esforzo
vostede manifesta?

675
00:32:30,110 --> 00:32:35,750
>> Exactitude, o programa traballa como
que debería por especificación CS50

676
00:32:35,750 --> 00:32:38,640
cando fornecer certos insumos
ou certas saídas de volta?

677
00:32:38,640 --> 00:32:41,130
O deseño é o máis subxectivo deles.

678
00:32:41,130 --> 00:32:43,360
E é o que vai
tardan máis para aprender

679
00:32:43,360 --> 00:32:47,220
e máis tempo para ensinar, en
medida en que se reduce a,

680
00:32:47,220 --> 00:32:49,530
como ben escrito é o código?

681
00:32:49,530 --> 00:32:52,920
>> É unha cousa para só imprimir a correcta
saídas ou devolver os valores correctos.

682
00:32:52,920 --> 00:32:55,400
Pero está facendo iso como
máis eficiente posible?

683
00:32:55,400 --> 00:32:58,210
Está facendo iso división
e conquistar, ou binario

684
00:32:58,210 --> 00:33:01,500
investigación como veremos en breve que fixemos
hai dúas semanas co libro de teléfono?

685
00:33:01,500 --> 00:33:04,670
Hai mellores formas de resolver o
problema que ten actualmente aquí?

686
00:33:04,670 --> 00:33:06,380
Esta é unha oportunidade para mellor deseño.

687
00:33:06,380 --> 00:33:08,530
>> E, a continuación, como style--
bonito é o código?

688
00:33:08,530 --> 00:33:12,370
Notarás que eu son bonito
particular sobre o recuar meu código,

689
00:33:12,370 --> 00:33:15,300
e que seguro que os meus variables
son razoablemente nomeado. N,

690
00:33:15,300 --> 00:33:19,660
mentres resumo, é un bo nome para un
número, i para un número enteiro de conta,

691
00:33:19,660 --> 00:33:20,727
s para unha cadea.

692
00:33:20,727 --> 00:33:22,560
E podemos ter máis tempo
estilo nomes variable.

693
00:33:22,560 --> 00:33:25,500
Estilo é só como bo
O seu código de ollar?

694
00:33:25,500 --> 00:33:26,600
E como lexible é?

695
00:33:26,600 --> 00:33:29,650
>> E co paso do tempo, o que as súas axencias de viaxes
e TFS fará no curso

696
00:33:29,650 --> 00:33:31,870
é proporcionar-lle que
tipo de feedback cualitativo

697
00:33:31,870 --> 00:33:34,330
para que obteña unha mellor
neses varios aspectos.

698
00:33:34,330 --> 00:33:37,510
E en canto a como nós
avaliar cada un destes eixes,

699
00:33:37,510 --> 00:33:40,080
é tipicamente con moi poucos
baldes para que, en xeral,

700
00:33:40,080 --> 00:33:41,680
ter unha noción de quão ben está facendo.

701
00:33:41,680 --> 00:33:45,680
E, de feito, se recibe unha puntuación de
calquera destes axes-- corrección, deseño

702
00:33:45,680 --> 00:33:49,659
e estilo especially-- este número
será xeralmente entre 1 e 5.

703
00:33:49,659 --> 00:33:52,450
E, literalmente, se está a recibir
3 de no inicio do semestre,

704
00:33:52,450 --> 00:33:53,977
iso é unha cousa moi boa.

705
00:33:53,977 --> 00:33:55,810
Isto significa que aínda hai
espazo para melloras,

706
00:33:55,810 --> 00:33:58,490
que sería de esperar en
tendo unha clase para a primeira vez.

707
00:33:58,490 --> 00:34:01,820
Hai espero que algún anaco de teito
para o cal está aspirando a acadar.

708
00:34:01,820 --> 00:34:03,970
E así que comezar o día 3 de
as primeiras pezas,

709
00:34:03,970 --> 00:34:06,550
Se non a preto de 2 e 4 de do,
é, en realidade, unha cousa boa.

710
00:34:06,550 --> 00:34:08,880
É ben dentro do alcance,
ben dentro das expectativas.

711
00:34:08,880 --> 00:34:11,421
>> E se a súa mente está executando, agarde
un minuto, tres de cada cinco.

712
00:34:11,421 --> 00:34:12,620
Isto é realmente un 6 out of 10.

713
00:34:12,620 --> 00:34:13,560
Isto é 60%.

714
00:34:13,560 --> 00:34:14,830
Meu Deus, iso é un F.

715
00:34:14,830 --> 00:34:15,870
>> Non é.

716
00:34:15,870 --> 00:34:17,600
Non é, de feito, que.

717
00:34:17,600 --> 00:34:22,710
Pola contra, é unha oportunidade para mellorar
ao longo do semestre.

718
00:34:22,710 --> 00:34:25,580
E se está a recibir algún
Poors, estes son unha oportunidade

719
00:34:25,580 --> 00:34:29,199
para aproveitar as horas de expediente,
certamente seccións e outros recursos.

720
00:34:29,199 --> 00:34:32,840
>> Mellor é unha oportunidade, realmente,
para presumir de quão lonxe

721
00:34:32,840 --> 00:34:34,520
veñen ao longo do semestre.

722
00:34:34,520 --> 00:34:38,199
Entón entender, se nada
máis, tres é bo.

723
00:34:38,199 --> 00:34:40,179
E permite espazo para o crecemento ao longo do tempo.

724
00:34:40,179 --> 00:34:43,090
>> En canto á forma como estes eixes son
ponderada, de forma realista está

725
00:34:43,090 --> 00:34:46,745
vai pasar a maior parte do seu tempo a chegar
cousas para traballar, e moito menos correctamente.

726
00:34:46,745 --> 00:34:49,120
E así corrección tende a
a ponderación do máis, como con

727
00:34:49,120 --> 00:34:51,360
este factor multiplicativo de tres.

728
00:34:51,360 --> 00:34:54,659
O deseño tamén é importante, pero
algo que non necesariamente

729
00:34:54,659 --> 00:34:58,220
gastar todas esas horas
tentando facer as cousas só para traballar.

730
00:34:58,220 --> 00:35:00,019
>> E por iso é ponderado
un pouco máis de ánimo leve.

731
00:35:00,019 --> 00:35:01,560
E, a continuación, o estilo é ponderado mínimo.

732
00:35:01,560 --> 00:35:03,710
Aínda que non é menos
importante, fundamentalmente,

733
00:35:03,710 --> 00:35:05,990
é só quizais a
O máis fácil de facer o correcto,

734
00:35:05,990 --> 00:35:08,440
imitando os exemplos que
facer en charla e sección,

735
00:35:08,440 --> 00:35:11,080
coas cousas Nicely
recuado, e comentou,

736
00:35:11,080 --> 00:35:14,320
etc. é entre os máis fáciles
cousas para facer e axustar.

737
00:35:14,320 --> 00:35:16,960
Así, como tal, entender
aqueles que son puntos

738
00:35:16,960 --> 00:35:19,000
que son relativamente fáciles de entender.

739
00:35:19,000 --> 00:35:22,360
>> E agora unha palabra sobre
isto-- honestidade académica.

740
00:35:22,360 --> 00:35:25,150
Entón por curso de
plan de estudos, vai ver

741
00:35:25,150 --> 00:35:27,630
que o curso ten bastante
pouco da linguaxe en torno a este.

742
00:35:27,630 --> 00:35:31,380
E o curso leva o tema da
honestidade académica moi en serio.

743
00:35:31,380 --> 00:35:33,450
>> Temos a distinción,
para mellor ou para peor,

744
00:35:33,450 --> 00:35:36,570
de enviar cada ano máis
estudantes para acción disciplinaria

745
00:35:36,570 --> 00:35:39,670
do que a maioría calquera outro
claro, que eu estou consciente.

746
00:35:39,670 --> 00:35:42,580
Este non é necesariamente
indicativa do feito

747
00:35:42,580 --> 00:35:46,340
que os estudantes do CS, ou estudantes CS50, son
menos honesto que os seus compañeiros.

748
00:35:46,340 --> 00:35:49,090
Pero a realidade que neste
mundo, electronicamente, nós só

749
00:35:49,090 --> 00:35:50,990
ten tecnolóxico
Os medios de detección deste.

750
00:35:50,990 --> 00:35:53,360
>> É importante para nós, para
xustiza en toda clase

751
00:35:53,360 --> 00:35:58,550
o que facemos detectar iso, e aumentar
o problema cando vemos as cousas.

752
00:35:58,550 --> 00:36:01,980
E só para pintar un cadro, e realmente
para axudar a algo así pía,

753
00:36:01,980 --> 00:36:04,600
estes son os números de
alumnos ao longo dos últimos 10 anos

754
00:36:04,600 --> 00:36:07,610
que foron implicados nalgún
tales cuestións de honestidade académica,

755
00:36:07,610 --> 00:36:10,990
con preto de 32 alumnos
da caída de 2015, que

756
00:36:10,990 --> 00:36:13,760
é dicir que nós levamos
o tema moi en serio.

757
00:36:13,760 --> 00:36:18,380
E, en definitiva, estas cifras compoñer,
máis recentemente, preto de 3%, 4% ou menos

758
00:36:18,380 --> 00:36:19,120
da clase.

759
00:36:19,120 --> 00:36:25,220
>> Así, para o super maioría dos estudantes
parece que as liñas son claras.

760
00:36:25,220 --> 00:36:27,940
Pero manter isto
importa, particularmente tarde

761
00:36:27,940 --> 00:36:32,080
á noite, cando loitando con
algunha solución para un conxunto de problemas,

762
00:36:32,080 --> 00:36:34,830
que existen mecanismos
para obter-se mellor

763
00:36:34,830 --> 00:36:37,870
apoio que pode
creo que, mesmo nesa hora.

764
00:36:37,870 --> 00:36:40,514
Entenda que cando recibimos
presentacións dos alumnos, atravesamos

765
00:36:40,514 --> 00:36:43,430
comparar cada presentación este ano
contra cada presentación o pasado ano,

766
00:36:43,430 --> 00:36:47,590
contra cada presentación a partir de 2007,
e sempre que, ollando para, así,

767
00:36:47,590 --> 00:36:49,931
código de repositorios en liña,
foros de debate, sitios de emprego.

768
00:36:49,931 --> 00:36:51,806
E esquecer iso,
Realmente, todo para o ben

769
00:36:51,806 --> 00:36:56,040
da divulgación chea, que se
alguén pode atopalo en liña,

770
00:36:56,040 --> 00:36:57,880
Certamente, nós tamén podemos curso.

771
00:36:57,880 --> 00:37:00,100
Pero, en realidade, o espírito
do curso resume

772
00:37:00,100 --> 00:37:01,650
a esta cláusula no programa.

773
00:37:01,650 --> 00:37:03,670
É realmente só, ser razoable.

774
00:37:03,670 --> 00:37:06,680
>> E se tivésemos de elaborar sobre iso
con só un pouco máis da linguaxe,

775
00:37:06,680 --> 00:37:09,770
entender que a esencia de todo
traballo que enviar a este curso

776
00:37:09,770 --> 00:37:10,954
debe ser o seu propio.

777
00:37:10,954 --> 00:37:13,870
Pero dentro diso, hai certamente
oportunidades e alento,

778
00:37:13,870 --> 00:37:17,300
e valor pedagóxico en transformar a
outros- min mesmo, o FT, o CAS,

779
00:37:17,300 --> 00:37:20,760
os asistentes técnicos, e outros na clase,
para o apoio, e moito menos amigos

780
00:37:20,760 --> 00:37:23,547
e compañeiros que estudaron
CS e programación antes.

781
00:37:23,547 --> 00:37:25,130
E así hai un subsidio para iso.

782
00:37:25,130 --> 00:37:28,180
E a regra xeral do polgar
é isto-- cando pedir axuda,

783
00:37:28,180 --> 00:37:31,470
pode amosar o seu código para os outros,
pero non pode ver a deles.

784
00:37:31,470 --> 00:37:34,880
Así, aínda se está en horario de oficina,
ou na sala D, ou noutro lugar

785
00:37:34,880 --> 00:37:37,450
traballar nalgún conxunto peza,
traballar xunto a un amigo, que

786
00:37:37,450 --> 00:37:40,160
é totalmente ben, na
final do día o seu traballo

787
00:37:40,160 --> 00:37:43,034
debe, en última instancia pertencen a cada
de vós, respectivamente, e non

788
00:37:43,034 --> 00:37:45,700
haber un esforzo colaborativo,
excepto para o proxecto final, onde

789
00:37:45,700 --> 00:37:47,410
permítese e animou.

790
00:37:47,410 --> 00:37:49,830
>> Entenda que se está
loitando con algo

791
00:37:49,830 --> 00:37:52,520
eo seu amigo só acontece
para ser mellor niso, entón,

792
00:37:52,520 --> 00:37:55,130
ou mellor a este problema do que,
ou un pouco máis adiante do que,

793
00:37:55,130 --> 00:37:57,330
é totalmente razoable para transformar
para o seu amigo e dicir, hey,

794
00:37:57,330 --> 00:38:00,480
lle importa de ollar para o meu código aquí,
me axudar a detectar o que o meu problema é?

795
00:38:00,480 --> 00:38:03,760
E, esperanza, no
xuros de valor pedagóxico

796
00:38:03,760 --> 00:38:07,040
que o amigo non só
digo, oh, iso, pero si,

797
00:38:07,040 --> 00:38:09,917
o que falta na liña
6, ou algo así?

798
00:38:09,917 --> 00:38:12,000
Pero a solución non é
ao amigo ao seu lado

799
00:38:12,000 --> 00:38:15,617
quere dicir, oh, así, aquí, déixame sacar
isto, e mostrar a miña solución para ti.

800
00:38:15,617 --> 00:38:16,450
Así que é a liña.

801
00:38:16,450 --> 00:38:18,670
Mostra o seu código para
outros, pero non pode

802
00:38:18,670 --> 00:38:22,350
ver deles, suxeitos a outro
restricións no currículo do curso.

803
00:38:22,350 --> 00:38:24,760
>> Polo tanto, ten en conta que esta
chamada cláusula de conversión

804
00:38:24,760 --> 00:38:27,560
no plan de estudos do curso, así como,
que se comete un acto que

805
00:38:27,560 --> 00:38:30,476
Non é razoable, pero trae-lo para
a atención dos xefes do curso

806
00:38:30,476 --> 00:38:34,240
dentro de 72 horas, o curso
pode impoñer sancións locais que

807
00:38:34,240 --> 00:38:37,380
Pode incluír unha ou insatisfatória
clase de failing ao traballo presentado.

808
00:38:37,380 --> 00:38:41,410
Pero o curso non vai remitir o
importa posterior acción disciplinaria,

809
00:38:41,410 --> 00:38:43,010
excepto en casos de actos repetidos.

810
00:38:43,010 --> 00:38:46,632
Noutras palabras, se fai algo
estúpida, especialmente tarde de noite, a decisión

811
00:38:46,632 --> 00:38:49,340
que á mañá seguinte ou dous días
máis tarde, espertar e entender,

812
00:38:49,340 --> 00:38:50,870
o que eu estaba a pensar?

813
00:38:50,870 --> 00:38:53,890
Facer en CS50 ter unha saída
para fixar este problema

814
00:38:53,890 --> 00:38:57,170
e posuír-se a el, de xeito que nós
pode atopalo no medio do camiño e tratar

815
00:38:57,170 --> 00:39:01,500
con iso dunha cuestión que é tamén
educativo e valioso para ti,

816
00:39:01,500 --> 00:39:04,200
pero aínda punitiva de algunha maneira.

817
00:39:04,200 --> 00:39:08,590
E agora, para tomar a bordo fóra, este.

818
00:39:08,590 --> 00:39:10,570
>> [Reprodución de vídeo]

819
00:39:10,570 --> 00:39:13,540
>> [Reprodución de música]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [FIN DE REPRODUCIÓN]

822
00:39:58,866 --> 00:40:00,490
DAVID J. Malan: Todo ben, estamos de volta.

823
00:40:00,490 --> 00:40:03,680
E agora miramos para unha das
primeiro dos nosos dominios do mundo real

824
00:40:03,680 --> 00:40:08,720
en CS50, a arte de cifrado,
a arte de envío e recepción

825
00:40:08,720 --> 00:40:11,840
mensaxes secretas, cifrado
mensaxes se queres,

826
00:40:11,840 --> 00:40:17,060
que só se pode descifrado se ten
algún ingrediente clave que o remitente ten

827
00:40:17,060 --> 00:40:18,030
ben.

828
00:40:18,030 --> 00:40:22,120
Entón, para motivar este tomaremos
un ollar para esta cousa aquí,

829
00:40:22,120 --> 00:40:26,750
que é un exemplo dun
decodificador secreto que

830
00:40:26,750 --> 00:40:34,042
pode ser usado para descubrir
o que unha mensaxe secreta é realmente.

831
00:40:34,042 --> 00:40:35,750
De feito, de volta ao
día na escola,

832
00:40:35,750 --> 00:40:38,787
se nunca enviou mensaxes secretas para
algún amigo ou algunha caída en clase,

833
00:40:38,787 --> 00:40:40,620
que pode ter pensado
estabas sendo intelixente

834
00:40:40,620 --> 00:40:46,530
por no seu anaco de cambio de papel,
como, de A a B e B para C e C para D,

835
00:40:46,530 --> 00:40:47,590
e así por diante.

836
00:40:47,590 --> 00:40:50,300
Pero estaba realmente cifrar
información, mesmo

837
00:40:50,300 --> 00:40:53,300
se foi algo trivial, non foi
tan difícil para o profesor a entender,

838
00:40:53,300 --> 00:40:55,675
ben, se acaba de mudar
B para A e C para B,

839
00:40:55,675 --> 00:40:57,550
realmente descubrir
que a mensaxe foi,

840
00:40:57,550 --> 00:40:59,700
pero estaba en cifrar información.

841
00:40:59,700 --> 00:41:03,420
>> Só estaba facendo iso
simplemente, moi parecido Ralphie aquí

842
00:41:03,420 --> 00:41:07,934
nun filme famoso que desempeña
practicamente ad nauseum cada inverno.

843
00:41:07,934 --> 00:41:08,600
[Reprodución de vídeo]

844
00:41:08,600 --> 00:41:11,180
-Ser-Lo coñecido de todos que
Ralph Parker é por este medio

845
00:41:11,180 --> 00:41:14,070
nomeado membro da Pequena
Orphan Annie Secret Circle

846
00:41:14,070 --> 00:41:17,700
e ten dereito a todos os honores
e beneficios produciron ao mesmo.

847
00:41:17,700 --> 00:41:24,340
>> Sinatura automática, Little Orphan Annie,
contra-asinado Pierre André, en pintura.

848
00:41:24,340 --> 00:41:27,160
Honores e beneficios,
xa coa idade de nove.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [Gritando]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Imos.

853
00:41:34,250 --> 00:41:35,210
Seguiremos con el.

854
00:41:35,210 --> 00:41:39,530
Eu non teño todo ese jazz
uns contrabandistas e piratas.

855
00:41:39,530 --> 00:41:41,660
>> -listen Mañá á noite para
a aventura final

856
00:41:41,660 --> 00:41:43,880
do barco pirata negro.

857
00:41:43,880 --> 00:41:46,650
Agora é o momento de
mensaxe secreta de Annie

858
00:41:46,650 --> 00:41:49,840
para ti membros do Círculo Secreto.

859
00:41:49,840 --> 00:41:53,570
Lembre, miúdo, só os membros
de Secret Circle de Annie

860
00:41:53,570 --> 00:41:56,140
Pode decodificar mensaxe secreta de Annie.

861
00:41:56,140 --> 00:42:00,340
>> Lembre, Annie está dependendo de ti.

862
00:42:00,340 --> 00:42:02,880
Define os seus pinos para B2.

863
00:42:02,880 --> 00:42:05,230
Aquí está a mensaxe.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Eu Estou na miña primeira reunión secreta.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Estaba en gran voz esta noite.

868
00:42:15,780 --> 00:42:19,000
Podería dicir que esta noite
mensaxe era realmente importante.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, que é unha mensaxe
de Annie si mesma.

870
00:42:22,694 --> 00:42:23,860
Lembre, non conte a ninguén.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Segundos despois, estou na única
cuarto na casa onde un neno de nove anos

873
00:42:32,930 --> 00:42:37,040
podería sentar privacidade e decodificar.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Eu fun a outro, E.

876
00:42:42,360 --> 00:42:44,520
>> A primeira palabra é ser.

877
00:42:44,520 --> 00:42:49,032
S, que estaba chegando máis fácil agora, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Ah, imos alí, Ralphie, teño que ir!

879
00:42:51,733 --> 00:42:53,688
>> -Vou Estar seguro para baixo, Ma!

880
00:42:53,688 --> 00:42:54,188
Gee Whiz!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, asegúrese a-- asegúrese de que?

883
00:43:04,060 --> 00:43:05,970
Cal foi Little Orphan
Annie está intentando dicir?

884
00:43:05,970 --> 00:43:07,264
Asegúrese de que?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie, Andy ten que
Vai, vai facer o favor de saír?

886
00:43:09,634 --> 00:43:10,480
>> dereito -Todos, Ma!

887
00:43:10,480 --> 00:43:12,880
Estarei fóra á dereita!

888
00:43:12,880 --> 00:43:14,550
>> -Eu Estaba quedando máis preto agora.

889
00:43:14,550 --> 00:43:16,620
A tensión era terrible.

890
00:43:16,620 --> 00:43:17,720
O que era?

891
00:43:17,720 --> 00:43:20,170
O destino do planeta
pode colgar na balanza.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
gotta de Andy ir!

894
00:43:23,170 --> 00:43:26,890
>> -Vou Estar seguro para fóra, polo amor de Deus!

895
00:43:26,890 --> 00:43:32,680
>> -Quase Alí, os dedos voaron, a miña mente
era unha trampa de aceiro, todos os poros vibrou.

896
00:43:32,680 --> 00:43:37,198
Era case clara, si, si, si.

897
00:43:37,198 --> 00:43:43,091
>> -Certifique-Se de beber o seu ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovomaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Un comercial miserable?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Fillo de puta.

903
00:43:54,227 --> 00:43:54,810
[FIN DE REPRODUCIÓN]

904
00:43:54,810 --> 00:43:57,390
DAVID J. Malan: OK, entón
que era un camiño moi longo

905
00:43:57,390 --> 00:44:00,660
introdución de cifrado,
e tamén Ovomaltine.

906
00:44:00,660 --> 00:44:04,470
De feito, desde este anuncio vello
aquí, por que é ovaltine tan bo?

907
00:44:04,470 --> 00:44:09,470
É unha extracción de concentrado madura
malta de cebada, leite puro de vaca cremoso,

908
00:44:09,470 --> 00:44:14,360
e especialmente preparado de cacao, en conxunto
con fosfatidos naturais e vitaminas.

909
00:44:14,360 --> 00:44:18,240
É aínda enriquecidos con
vitaminas adicionais B e D, yum.

910
00:44:18,240 --> 00:44:21,600
E aínda pode obterse ao parecer
na Amazonia, como fixemos aquí.

911
00:44:21,600 --> 00:44:24,810
>> Pero a motivación aquí foi
introducir cifrado, especialmente

912
00:44:24,810 --> 00:44:28,340
un tipo de cifrado coñecido
como cifrado de clave secreta.

913
00:44:28,340 --> 00:44:34,284
E como o nome suxire, o conxunto
seguridade dun sistema de cifrado de clave secreta,

914
00:44:34,284 --> 00:44:36,200
se quixeren, unha metodoloxía
para só loitando

915
00:44:36,200 --> 00:44:40,960
información entre dúas persoas, é que
só o remitente eo destinatario único

916
00:44:40,960 --> 00:44:46,980
coñecer un key-- segredo algún valor, algunha
frase, un número secreto, que

917
00:44:46,980 --> 00:44:50,660
lles permite cifrar
e descifrar información.

918
00:44:50,660 --> 00:44:53,470
E cifrado, realmente,
é só iso desde a semana 0.

919
00:44:53,470 --> 00:44:56,715
>> É un problema onde non hai entradas,
como a mensaxe real en Inglés

920
00:44:56,715 --> 00:44:59,340
ou calquera outra lingua que
quere enviar a alguén na clase,

921
00:44:59,340 --> 00:45:00,580
ou a través de internet.

922
00:45:00,580 --> 00:45:03,840
Hai algunha saída, que vai
ser a mensaxe que revoltos

923
00:45:03,840 --> 00:45:05,250
quere que o destinatario reciba.

924
00:45:05,250 --> 00:45:07,405
E mesmo se alguén no
MIDDLE recibe-lo tamén,

925
00:45:07,405 --> 00:45:09,780
non quere que eles
necesariamente poder descifrar-lo,

926
00:45:09,780 --> 00:45:12,840
porque neste
caixa negra, é algoritmo,

927
00:45:12,840 --> 00:45:17,650
é un mecanismo, algún paso a paso
instrucións, para tomar esta entrada

928
00:45:17,650 --> 00:45:20,710
e converténdose na
de saída, na esperanza de forma segura.

929
00:45:20,710 --> 00:45:23,640
>> E, de feito, hai algún
vocabulario neste mundo como segue.

930
00:45:23,640 --> 00:45:26,100
Texto é a palabra dun
científico da computación sería

931
00:45:26,100 --> 00:45:28,449
usar para describir os datos
mensaxe, como o inglés

932
00:45:28,449 --> 00:45:31,240
ou calquera outra lingua que realmente
quere enviar a algún outro humano.

933
00:45:31,240 --> 00:45:35,450
E, a continuación, o texto cifrado é a carreira
ao cifrada, ou cifrada,

934
00:45:35,450 --> 00:45:36,520
versión do mesmo.

935
00:45:36,520 --> 00:45:38,750
>> Pero hai outro ingrediente aquí.

936
00:45:38,750 --> 00:45:43,200
Hai outra entrada
cifrado de clave secreta.

937
00:45:43,200 --> 00:45:45,200
E esa é a clave en si,
que é, xeralmente,

938
00:45:45,200 --> 00:45:48,930
como veremos, un número ou
letra, ou unha palabra, calquera que sexa

939
00:45:48,930 --> 00:45:51,980
o algoritmo é realmente espera.

940
00:45:51,980 --> 00:45:53,870
>> E como descifrar a información?

941
00:45:53,870 --> 00:45:55,110
Como desembaralhar-lo?

942
00:45:55,110 --> 00:45:57,950
Ben, só inverter a
saídas e entradas.

943
00:45:57,950 --> 00:46:00,900
>> Noutras palabras, unha vez que alguén
recibe a mensaxe cifrada,

944
00:46:00,900 --> 00:46:03,740
el ou ela simplemente ten
a saber, que mesmo clave.

945
00:46:03,740 --> 00:46:05,700
Recibiron o texto cifrado.

946
00:46:05,700 --> 00:46:09,530
E ligando estes dous
contribucións ao sistema de cifrado,

947
00:46:09,530 --> 00:46:14,260
o algoritmo, esta caixa negra, fóra
debe vir o texto plano inicial.

948
00:46:14,260 --> 00:46:17,830
E así que é o nivel moi alto
visión do que o cifrado é realmente

949
00:46:17,830 --> 00:46:18,590
todo sobre.

950
00:46:18,590 --> 00:46:20,030
>> Entón, imos chegar alí.

951
00:46:20,030 --> 00:46:22,700
Imos agora ollar por baixo
a capa de algo

952
00:46:22,700 --> 00:46:26,000
vimos tomar para concedida para
a semana pasada, e para esta sesión

953
00:46:26,000 --> 00:46:27,629
aqui-- a corda.

954
00:46:27,629 --> 00:46:30,295
Unha cadea ao final do día
é só unha secuencia de caracteres.

955
00:46:30,295 --> 00:46:33,610
>> Pode ser Ola mundo, ou
Ola Zamyla, ou o que quere.

956
00:46:33,610 --> 00:46:37,050
Pero o que iso supón para
Ser unha secuencia de caracteres?

957
00:46:37,050 --> 00:46:41,520
De feito, a biblioteca CS50 dá
-Nos un tipo de datos chamado cadea.

958
00:46:41,520 --> 00:46:45,140
>> Pero non hai realmente ningunha
tal cousa como unha cadea C.

959
00:46:45,140 --> 00:46:49,450
É realmente só unha secuencia de
carácter, personalidade, carácter,

960
00:46:49,450 --> 00:46:52,180
carácter, para atrás, cara atrás, para
atrás, cara atrás, cara atrás dentro

961
00:46:52,180 --> 00:46:54,650
da memoria do ordenador, ou RAM.

962
00:46:54,650 --> 00:46:58,940
E nós imos ollar máis profundo no que, no
futuro, cando miramos para a propia memoria,

963
00:46:58,940 --> 00:47:02,030
ea utilización, ea
ameazas que están implicados.

964
00:47:02,030 --> 00:47:04,100
>> Pero imos considerar a cadea Zamyla.

965
00:47:04,100 --> 00:47:07,480
Así, só o nome do
o ser humano aquí, Zamyla,

966
00:47:07,480 --> 00:47:12,030
que é unha secuencia de
caracteres, Z-A-H-Y-L-A.

967
00:47:12,030 --> 00:47:16,020
E agora imos supor que o nome de Zamyla
está sendo almacenado no interior dun ordenador

968
00:47:16,020 --> 00:47:16,880
programa.

969
00:47:16,880 --> 00:47:20,830
>> Ben, é lóxico que debemos
ser capaz de ollar para os personaxes

970
00:47:20,830 --> 00:47:21,590
individualmente.

971
00:47:21,590 --> 00:47:24,710
Entón, eu estou indo só para debuxar algo
caixa arredor nome de Zamyla aquí.

972
00:47:24,710 --> 00:47:31,580
E é o caso en C que, cando
ter unha secuencia, como Zamyla-- e quizais

973
00:47:31,580 --> 00:47:34,940
esta secuencia volveu da
unha función como cadea get,

974
00:47:34,940 --> 00:47:38,540
realmente pode manipular
Lo carácter por carácter.

975
00:47:38,540 --> 00:47:42,070
>> Agora, iso é pertinente para o
conversación a man, porque

976
00:47:42,070 --> 00:47:46,420
en criptografía se quere cambiar
A a B, e B para C e C para D,

977
00:47:46,420 --> 00:47:49,650
etc., ten que ser capaz
ollar os caracteres individuais

978
00:47:49,650 --> 00:47:50,190
nunha cadea.

979
00:47:50,190 --> 00:47:52,695
Debe ser capaz de cambiar
Z a outra cousa, o A

980
00:47:52,695 --> 00:47:55,280
a outra cousa, o M para
outra cousa, e así por diante.

981
00:47:55,280 --> 00:47:58,000
E por iso necesitamos unha forma,
programaticamente, entón

982
00:47:58,000 --> 00:48:03,020
falar, en C, para poder cambiar
e mirar para cartas individuais.

983
00:48:03,020 --> 00:48:05,690
E podemos facelo do seguinte xeito.

984
00:48:05,690 --> 00:48:08,340
>> Deixe-me ir atrás no IDE CS50.

985
00:48:08,340 --> 00:48:11,130
E deixe-me ir adiante
e crear un novo ficheiro

986
00:48:11,130 --> 00:48:16,134
que eu vou chamar este string0 tempo,
como o noso primeiro exemplo desta situación, punto c.

987
00:48:16,134 --> 00:48:18,300
E eu estou indo a ir adiante
e chicoteá lo deste xeito.

988
00:48:18,300 --> 00:48:22,870
>> Así inclúen CS50.h, e
logo incluír io.h estándar,

989
00:48:22,870 --> 00:48:25,990
que estou case sempre vai
estar a usar nos meus programas, polo menos,

990
00:48:25,990 --> 00:48:26,780
inicialmente.

991
00:48:26,780 --> 00:48:32,180
int void main, logo aquí estou
fará cordas recibe obter cadea.

992
00:48:32,180 --> 00:48:35,260
E entón eu vou
dalle facelo.

993
00:48:35,260 --> 00:48:37,460
Quero ir adiante
e, como verificación de sanidade,

994
00:48:37,460 --> 00:48:43,607
só dicir, Ola, cento s,
-e coma, fai corda 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, o que eu fixen aquí?

996
00:48:44,690 --> 00:48:45,930
Oh, eu non liga-lo.

997
00:48:45,930 --> 00:48:48,120
Entón, lección aprendida, que
non foi intencional.

998
00:48:48,120 --> 00:48:52,480
>> Así erro, máis por cento
conversións que argumentos dados.

999
00:48:52,480 --> 00:48:54,940
E é aí que, en
liña 7-- OK, entón eu teño,

1000
00:48:54,940 --> 00:48:56,690
entre comiñas, que é
miña cadea de caracteres para printf.

1001
00:48:56,690 --> 00:48:58,151
Eu teño un signo de porcentaxe.

1002
00:48:58,151 --> 00:48:59,650
Pero eu estou perdendo o segundo argumento.

1003
00:48:59,650 --> 00:49:03,190
>> Estou falta o s coma, que
Eu tiña nos exemplos anteriores.

1004
00:49:03,190 --> 00:49:06,650
Entón, unha boa oportunidade para corrixir
un erro, accidentalmente.

1005
00:49:06,650 --> 00:49:09,950
E agora me deixar correr
string0, escriba Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, Ola Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Entón nós realizar este tipo de programa
algunhas veces diferente agora.

1008
00:49:14,144 --> 00:49:16,310
Pero imos facer algo un
pouco distinto esta vez.

1009
00:49:16,310 --> 00:49:19,450
No canto de só imprimir Zamyla de
O nome co printf,

1010
00:49:19,450 --> 00:49:21,350
imos facelo carácter por carácter.

1011
00:49:21,350 --> 00:49:22,700
>> Vou usar un loop for.

1012
00:49:22,700 --> 00:49:26,160
E eu vou entregar-me
unha variable de conta, nome i.

1013
00:49:26,160 --> 00:49:33,530
E eu vou seguir iteración, entón
sempre que i é inferior á lonxitude de s.

1014
00:49:33,530 --> 00:49:35,930
>> Acontece que, non o fixemos
facelo a última vez,

1015
00:49:35,930 --> 00:49:39,100
que vén cun c
función chamada Stirling.

1016
00:49:39,100 --> 00:49:42,690
De volta ao día, e, en xeral
aínda na posta en marcha de funcións,

1017
00:49:42,690 --> 00:49:45,405
seres humanos, moitas veces, escoller con moito
nomes sucintas que tipo de son

1018
00:49:45,405 --> 00:49:48,280
como o que quere, aínda que sexa
falta algunhas vogais ou letras.

1019
00:49:48,280 --> 00:49:50,660
Así Stirling é a
nome dunha función que

1020
00:49:50,660 --> 00:49:53,880
toma unha discusión entre
entre parénteses, que debe ser unha cadea.

1021
00:49:53,880 --> 00:49:56,910
E só devolve un enteiro,
a lonxitude desta corda.

1022
00:49:56,910 --> 00:50:00,580
>> Polo tanto, este loop for na liña 7 vai
para iniciar a conta en i é igual a 0.

1023
00:50:00,580 --> 00:50:02,530
Vai para incrementar
i en cada iteración

1024
00:50:02,530 --> 00:50:04,350
por 1, como vimos facendo algunhas veces.

1025
00:50:04,350 --> 00:50:06,780
Pero vai facer só
isto ata o punto

1026
00:50:06,780 --> 00:50:09,660
cando i é a lonxitude
da propia cadea.

1027
00:50:09,660 --> 00:50:14,520
>> Polo tanto, esta é unha forma de, en definitiva,
iteración sobre os personaxes

1028
00:50:14,520 --> 00:50:17,430
na secuencia como é segue.

1029
00:50:17,430 --> 00:50:20,670
Vou imprimir non un
secuencia enteira, pero por cento c,

1030
00:50:20,670 --> 00:50:22,860
un único carácter
seguido por unha nova liña.

1031
00:50:22,860 --> 00:50:24,880
E entón eu vou
vai adiante, e eu teño

1032
00:50:24,880 --> 00:50:29,080
dicir Quero imprimir
carácter i s.

1033
00:50:29,080 --> 00:50:33,450
>> Polo tanto, se i é a variable que indica
o índice da cadea, onde

1034
00:50:33,450 --> 00:50:37,230
está nel, eu teño poder
dicir, me dar o personaxe i s.

1035
00:50:37,230 --> 00:50:40,390
Ec ten unha forma de facer
isto con corchetes.

1036
00:50:40,390 --> 00:50:43,679
Simplemente dicir o nome do
cadea, que neste caso é s.

1037
00:50:43,679 --> 00:50:46,970
Entón usa corchetes, que son
xeralmente só por riba da súa Return ou Intro

1038
00:50:46,970 --> 00:50:48,110
tecla no teclado.

1039
00:50:48,110 --> 00:50:52,410
E entón poñer o índice do
carácter que quere imprimir.

1040
00:50:52,410 --> 00:50:55,960
Así, o índice será un
number-- 0, ou 1, ou 2, ou 3, ou un punto,

1041
00:50:55,960 --> 00:50:57,590
punto, punto, algún outro número.

1042
00:50:57,590 --> 00:51:00,920
>> E é seguro que vai
ser o número correcto, porque

1043
00:51:00,920 --> 00:51:02,360
comezar a contar a 0.

1044
00:51:02,360 --> 00:51:07,020
E, por defecto, o primeiro carácter
nunha cadea é, por convención 0.

1045
00:51:07,020 --> 00:51:09,230
E o segundo personaxe é soporte 1.

1046
00:51:09,230 --> 00:51:11,120
E o terceiro personaxe é bracket 2.

1047
00:51:11,120 --> 00:51:13,630
E non quere ir moi
lonxe, pero non imos porque somos

1048
00:51:13,630 --> 00:51:17,780
vai incrementar só ata que
é igual á lonxitude da corda.

1049
00:51:17,780 --> 00:51:20,210
E en que punto,
este loop pode parar.

1050
00:51:20,210 --> 00:51:25,550
>> Entón deixe-me ir adiante e gardar este
programa, e realizar facer corda 0.

1051
00:51:25,550 --> 00:51:28,400
Pero eu estraguei todo.

1052
00:51:28,400 --> 00:51:35,390
Implicitamente declarando función de biblioteca
Stirling co tipo tal e such-- agora,

1053
00:51:35,390 --> 00:51:36,430
iso soa familiar.

1054
00:51:36,430 --> 00:51:37,440
Pero non é printf.

1055
00:51:37,440 --> 00:51:38,540
E non é obter cadea.

1056
00:51:38,540 --> 00:51:40,480
>> Non romper en
Analogamente neste momento.

1057
00:51:40,480 --> 00:51:45,100
Pero teña en conta-se aquí un pouco para abaixo
Ademais, inclúen o string.h cabeceira,

1058
00:51:45,100 --> 00:51:47,210
proporcionar explicitamente o
declaración de Stirling.

1059
00:51:47,210 --> 00:51:48,820
Polo tanto, non é realmente unha pista alí.

1060
00:51:48,820 --> 00:51:51,670
>> E de feito el saír
hai outro ficheiro de cabeceira

1061
00:51:51,670 --> 00:51:53,970
que non usei
en clase aínda, pero é

1062
00:51:53,970 --> 00:51:56,480
entre os dispoñibles
para ti, chamado string.h.

1063
00:51:56,480 --> 00:52:00,930
E nese arquivo, string.h
é Stirling declarou.

1064
00:52:00,930 --> 00:52:05,220
Entón deixe-me ir adiante e
gardar tanto, asegúrese corda

1065
00:52:05,220 --> 00:52:08,040
0-- agradable, sen mensaxes de erro neste momento.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla, e
Estou a piques de premer intro,

1067
00:52:12,290 --> 00:52:16,710
en que punto getString vai
para volver a corda, poñelas s.

1068
00:52:16,710 --> 00:52:21,890
Logo que sexa loop fará unha iteración
sobre os personaxes de S un de cada vez,

1069
00:52:21,890 --> 00:52:28,420
e imprimir-los un por liña, porque
Eu tiña que barra invertida n ao final.

1070
00:52:28,420 --> 00:52:34,530
Así eu podería omitir que barra invertida
n, e despois é só imprimir Zamyla todo

1071
00:52:34,530 --> 00:52:37,460
na mesma liña,
eficazmente reimplementar

1072
00:52:37,460 --> 00:52:38,999
printf, que non é tan útil.

1073
00:52:38,999 --> 00:52:40,540
Pero, neste caso, eu non fixen iso.

1074
00:52:40,540 --> 00:52:43,610
Realmente impresa unha
carácter de cada vez, un por liña,

1075
00:52:43,610 --> 00:52:45,400
de xeito que realmente ver o efecto.

1076
00:52:45,400 --> 00:52:46,900
>> Pero debo salientar algo aquí.

1077
00:52:46,900 --> 00:52:48,930
E nós imos voltar a
este nunha semana futuro.

1078
00:52:48,930 --> 00:52:52,650
Acontece que este
código é potencialmente buggy.

1079
00:52:52,650 --> 00:52:56,560
>> Acontece que cadea get
e algunhas outras funcións na vida

1080
00:52:56,560 --> 00:53:00,280
non necesariamente sempre
devolver o que está esperando.

1081
00:53:00,280 --> 00:53:03,010
Sabemos da clase pasada
tempo nesta que estar

1082
00:53:03,010 --> 00:53:04,960
cadea debe volver unha cadea.

1083
00:53:04,960 --> 00:53:09,900
Pero e se o usuario escribe fóra, tales
unha palabra longa, ou parágrafo, ou ensaio

1084
00:53:09,900 --> 00:53:13,010
que hai só non é suficiente
memoria do ordenador para axusta-lo.

1085
00:53:13,010 --> 00:53:15,410
>> Como, o que se algo sae
mal debaixo do capó?

1086
00:53:15,410 --> 00:53:18,400
Pode non acontece moitas veces,
pero podería acontecer xa

1087
00:53:18,400 --> 00:53:21,520
en vez, moi raramente.

1088
00:53:21,520 --> 00:53:25,460
E así acontece que cadea get
e funcións como fai non necesariamente

1089
00:53:25,460 --> 00:53:26,380
sempre retornan cadeas.

1090
00:53:26,380 --> 00:53:30,680
Poden volver algún valor de erro,
algún valor de sentinela por así dicir,

1091
00:53:30,680 --> 00:53:32,612
que indica que
algo deu mal.

1092
00:53:32,612 --> 00:53:35,320
E só sabe que iso
aprenderen en clase agora,

1093
00:53:35,320 --> 00:53:37,700
ou de ler máis documentación.

1094
00:53:37,700 --> 00:53:43,120
Acontece que cadea get
pode devolver un valor chamado nulo.

1095
00:53:43,120 --> 00:53:46,220
Nulo é un valor especial que imos
volver unha semana futuro.

1096
00:53:46,220 --> 00:53:50,420
Pero, polo de agora, só sei que se eu queira
para ser realmente bo en avanzar

1097
00:53:50,420 --> 00:53:52,650
mediante a corda get, I
non debe só chamalo,

1098
00:53:52,650 --> 00:53:56,870
e cegamente usar o seu valor de retorno,
confiando que é unha cadea.

1099
00:53:56,870 --> 00:53:59,420
>> Eu debería dicir en primeiro lugar,
Ei, agarde un minuto, única

1100
00:53:59,420 --> 00:54:03,380
proceder se s non é igual
nulo, onde nula, de novo,

1101
00:54:03,380 --> 00:54:04,660
é só un valor especial.

1102
00:54:04,660 --> 00:54:07,770
E é o único valor especial que
se preocupe a secuencia de get.

1103
00:54:07,770 --> 00:54:10,900
Obter cadea é calquera que vai
para devolver unha cadea ou nulo.

1104
00:54:10,900 --> 00:54:17,219
>> E este punto de exclamación signo igual
pode saber a partir quizais clase de matemáticas

1105
00:54:17,219 --> 00:54:20,510
que pode deseñar un sinal de igualdade con
unha liña a través del para indicar non é igual.

1106
00:54:20,510 --> 00:54:23,135
Isto non é xeralmente un personaxe
podes escribir no teclado.

1107
00:54:23,135 --> 00:54:26,480
E así a maioría das linguaxes de programación,
cando quere dicir non é igual,

1108
00:54:26,480 --> 00:54:29,160
usa un punto de exclamación,
tamén coñecido como estrondo.

1109
00:54:29,160 --> 00:54:33,180
Entón di Bang é igual, o que
significa non é igual, loxicamente.

1110
00:54:33,180 --> 00:54:38,060
E como non hai un maior
que, o igual a, ou inferior a

1111
00:54:38,060 --> 00:54:41,270
ou igual a tecla no teclado
que fai todo nun símbolo.

1112
00:54:41,270 --> 00:54:44,020
É por iso que, nos exemplos anteriores,
fixo un soporte aberto, e logo

1113
00:54:44,020 --> 00:54:48,670
un signo igual, a fin de facer
maior ou, digamos, menos.

1114
00:54:48,670 --> 00:54:49,910
>> Entón cal é o takeaway aquí?

1115
00:54:49,910 --> 00:54:53,880
Isto é simplemente unha forma de agora
introducir esta sintaxe, este recurso,

1116
00:54:53,880 --> 00:54:57,390
iteración sobre individuo
caracteres nunha cadea.

1117
00:54:57,390 --> 00:55:00,260
E, así como aqueles cadrado
corchetes permiten que chegar a eles,

1118
00:55:00,260 --> 00:55:03,790
considerar os corchetes como
tipo de insinuando neste subxacente

1119
00:55:03,790 --> 00:55:06,040
deseño, no que cada
caracteres dentro dunha cadea

1120
00:55:06,040 --> 00:55:10,180
é unha especie de caixa nalgún lugar debaixo
o capó na memoria do ordenador.

1121
00:55:10,180 --> 00:55:12,340
>> Pero imos facer unha variante deste.

1122
00:55:12,340 --> 00:55:14,880
Acontece que este
programa é correcta.

1123
00:55:14,880 --> 00:55:18,810
Entón por eixes de CS50 para avaliar
código, iso é correcto agora.

1124
00:55:18,810 --> 00:55:22,959
Sobre todo agora que estou comprobando
null, este programa non debe fallar.

1125
00:55:22,959 --> 00:55:24,500
E eu só sei que coa experiencia.

1126
00:55:24,500 --> 00:55:28,040
Pero non hai nada máis que
podemos realmente dar mal aquí.

1127
00:55:28,040 --> 00:55:31,860
Pero non é moi ben deseñado,
porque imos volver ao básico.

1128
00:55:31,860 --> 00:55:34,450
>> En primeiro lugar, principles--
o que fai un loop for facer?

1129
00:55:34,450 --> 00:55:36,290
Bucle for fai tres cousas.

1130
00:55:36,290 --> 00:55:39,340
El arrinque algúns
valor, se pedir a el.

1131
00:55:39,340 --> 00:55:41,770
El comprobar unha condición.

1132
00:55:41,770 --> 00:55:45,380
E logo despois de cada
iteración, despois de cada ciclo,

1133
00:55:45,380 --> 00:55:49,330
incrementa algúns
valor ou valores, aquí.

1134
00:55:49,330 --> 00:55:50,600
>> Entón, o que significa isto?

1135
00:55:50,600 --> 00:55:52,940
Nós arrincar i a 0.

1136
00:55:52,940 --> 00:55:58,610
Nós comprobar e asegurarse i é inferior a
a lonxitude do s, o que é Z-A-H-Y-L-A,

1137
00:55:58,610 --> 00:55:59,900
de xeito que é inferior a 6.

1138
00:55:59,900 --> 00:56:02,590
E, de feito, como menos que 0 6.

1139
00:56:02,590 --> 00:56:05,580
>> Nós imprimir Z do nome de Zamyla.

1140
00:56:05,580 --> 00:56:08,080
Logo incrementar i 0-1.

1141
00:56:08,080 --> 00:56:11,290
A continuación, comproba, é de 1 a menos
do que a lonxitude do s?

1142
00:56:11,290 --> 00:56:13,270
A lonxitude s é 6.

1143
00:56:13,270 --> 00:56:13,950
Si, é.

1144
00:56:13,950 --> 00:56:16,880
>> Por iso, imprimir unha en nome Zamyla, ZA.

1145
00:56:16,880 --> 00:56:20,090
Nós incrementar i de 0 a 1, a 2.

1146
00:56:20,090 --> 00:56:23,720
A continuación, comproba, sexa inferior a 2
a lonxitude do nome de Zamyla.

1147
00:56:23,720 --> 00:56:25,380
6- SO 2 é menor que 6.

1148
00:56:25,380 --> 00:56:30,460
Si, imos imprimir agora M en
O nome de Zamyla, o terceiro personaxe.

1149
00:56:30,460 --> 00:56:34,110
>> A clave aquí é que en cada
iteración da historia, eu estou comprobando,

1150
00:56:34,110 --> 00:56:37,810
i é inferior á lonxitude de Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Pero o problema é que
Stirling non é unha propiedade.

1152
00:56:40,350 --> 00:56:43,100
Aqueles de vós que teña previsto
antes en Java ou outras linguaxes

1153
00:56:43,100 --> 00:56:46,310
pode saber a lonxitude dunha cadea é
unha propiedade, só algunhas lea único valor.

1154
00:56:46,310 --> 00:56:50,220
>> C, neste caso, se este é
unha función que é, literalmente,

1155
00:56:50,220 --> 00:56:53,520
a conta do número de
caracteres Zamyla cada vez

1156
00:56:53,520 --> 00:56:54,740
chamamos esta función.

1157
00:56:54,740 --> 00:56:58,500
Cada vez que preguntar ao ordenador para usar
Stirling, está a ter un ollar para Zamyla,

1158
00:56:58,500 --> 00:57:01,960
e dicindo Z-A-H-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
E retorna 6.

1160
00:57:02,962 --> 00:57:04,920
A próxima vez que chamar
Lo dentro dese loop for,

1161
00:57:04,920 --> 00:57:08,610
que vai mirar para Zamyla
de novo, digamos, Z-A-H-Y-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
E vai volver 6.

1163
00:57:10,320 --> 00:57:12,980
Entón, o que é parvo sobre este proxecto?

1164
00:57:12,980 --> 00:57:17,700
>> Por que o meu código non a 5 de 5
para o proxecto agora, por así dicir?

1165
00:57:17,700 --> 00:57:20,600
Ben, eu estou pedindo un
pregunta innecesariamente.

1166
00:57:20,600 --> 00:57:23,030
Eu estou facendo máis traballo do que eu teño.

1167
00:57:23,030 --> 00:57:25,370
>> Así, aínda que o
resposta é correcta, eu son

1168
00:57:25,370 --> 00:57:29,560
pedindo o ordenador, que é o
a lonxitude de Zamyla novo,

1169
00:57:29,560 --> 00:57:31,380
e de novo, e de novo, e de novo?

1170
00:57:31,380 --> 00:57:33,980
E esa resposta é
nunca vai cambiar.

1171
00:57:33,980 --> 00:57:35,900
Sempre será 6.

1172
00:57:35,900 --> 00:57:39,730
>> Entón, unha solución mellor que este
Sería esta próxima versión.

1173
00:57:39,730 --> 00:57:43,390
Deixe-me ir adiante e poñelas nun
arquivo separado chamado string1.c,

1174
00:57:43,390 --> 00:57:44,990
só para mantelo separado.

1175
00:57:44,990 --> 00:57:47,260
E verifícase en un de
loop, pode realmente

1176
00:57:47,260 --> 00:57:50,210
declarar múltiples variables á vez.

1177
00:57:50,210 --> 00:57:53,460
>> Entón, eu vou seguir i e configuralo para 0.

1178
00:57:53,460 --> 00:57:56,190
Pero eu tamén vou
engadir unha coma, e dicir:

1179
00:57:56,190 --> 00:58:01,050
dáme unha variable chamada n, cuxas
valor é igual á lonxitude da corda de s.

1180
00:58:01,050 --> 00:58:09,410
E agora, por favor, faga a miña condición
sempre que i é menor que n.

1181
00:58:09,410 --> 00:58:14,140
>> Así, deste xeito, a lóxica está
idénticas ao final do día.

1182
00:58:14,140 --> 00:58:18,280
Pero estou lembrando a
valor 6, neste caso.

1183
00:58:18,280 --> 00:58:19,780
Cal é a lonxitude do nome de Zamyla?

1184
00:58:19,780 --> 00:58:20,860
E eu estou poñendo-o n.

1185
00:58:20,860 --> 00:58:23,050
>> E eu aínda estou comprobando
a condición de cada vez.

1186
00:58:23,050 --> 00:58:24,300
0 é inferior a 6?

1187
00:58:24,300 --> 00:58:25,600
1 é inferior a 6?

1188
00:58:25,600 --> 00:58:28,600
É de 2 a menos de 6, e así por diante?

1189
00:58:28,600 --> 00:58:31,914
>> Pero eu non estou pedindo o ordenador
de novo, e de novo, o que é

1190
00:58:31,914 --> 00:58:33,080
a lonxitude do nome de Zamyla?

1191
00:58:33,080 --> 00:58:34,320
Cal é a lonxitude do nome de Zamyla?

1192
00:58:34,320 --> 00:58:35,986
Cal é a lonxitude do nome deste Zamyla?

1193
00:58:35,986 --> 00:58:40,440
Estou literalmente lembrando que en primeiro
única resposta neste segundo n variable.

1194
00:58:40,440 --> 00:58:45,280
Entón, iso agora sería non só
correcto, pero tamén ben deseñado.

1195
00:58:45,280 --> 00:58:46,670
>> Agora, o que sobre o estilo?

1196
00:58:46,670 --> 00:58:48,866
Eu nomeei meus variables
moi ben, eu diría.

1197
00:58:48,866 --> 00:58:50,240
Son super sucinta agora.

1198
00:58:50,240 --> 00:58:52,090
E iso é totalmente ben.

1199
00:58:52,090 --> 00:58:55,120
>> Se só ten unha
Cadea de caracteres nun programa,

1200
00:58:55,120 --> 00:58:56,860
así como pode chamalo s para a cadea.

1201
00:58:56,860 --> 00:58:59,370
Se só ten unha variable
para conta nun programa,

1202
00:58:59,370 --> 00:59:00,710
así como pode chamalo i.

1203
00:59:00,710 --> 00:59:03,500
Se ten unha lonxitude, n
é super común tamén.

1204
00:59:03,500 --> 00:59:05,800
Pero eu non comentou calquera do meu código.

1205
00:59:05,800 --> 00:59:09,200
>> Non teño informou o reader--
se esa é a miña TF ou TA,

1206
00:59:09,200 --> 00:59:12,460
ou só colleague-- o que se quere
estar a suceder neste programa.

1207
00:59:12,460 --> 00:59:15,760
E así, para obter un bo estilo,
o que me gustaría facer

1208
00:59:15,760 --> 00:59:24,580
é isto-- algo
como pedir usuario entrada.

1209
00:59:24,580 --> 00:59:26,670
E eu podería reescribir
este calquera número de formas.

1210
00:59:26,670 --> 00:59:35,630
>> Asegúrese de s-- asegúrese get
cadea retornada unha cadea.

1211
00:59:35,630 --> 00:59:40,280
E entón, en aqui-- e este é, se cadra,
o iterate comment-- máis importante

1212
00:59:40,280 --> 00:59:44,450
sobre os personaxes s un de cada vez.

1213
00:59:44,450 --> 00:59:47,060
E eu podería usar calquera
elección do idioma inglés

1214
00:59:47,060 --> 00:59:49,650
aquí para describir cada
destes anacos de código.

1215
00:59:49,650 --> 00:59:52,740
>> Repare que eu non colocar un
comentar cada liña de código,

1216
00:59:52,740 --> 00:59:55,690
realmente sobre a interesante
queridos, os que

1217
00:59:55,690 --> 00:59:59,460
ter algún significado que eu podería
Quere facer super clara a alguén

1218
00:59:59,460 --> 01:00:00,460
ler o meu código.

1219
01:00:00,460 --> 01:00:02,920
E por que está chamando de obter
cadea preguntar usuario para a entrada?

1220
01:00:02,920 --> 01:00:05,450
Aínda que un non é necesariamente
todo o que descritiva.

1221
01:00:05,450 --> 01:00:09,340
Pero axuda a contar unha historia, xa que o
segunda liña na historia é, comproba se

1222
01:00:09,340 --> 01:00:10,740
obter cadea devolta unha cadea de caracteres.

1223
01:00:10,740 --> 01:00:14,260
>> E a terceira liña da historia é,
iterado sobre os personaxes s un

1224
01:00:14,260 --> 01:00:15,380
á vez.

1225
01:00:15,380 --> 01:00:17,920
E agora só para unha boa medida,
Eu estou indo a ir adiante e engadir

1226
01:00:17,920 --> 01:00:24,560
un comentario que
di impresión de caracteres i-th en s.

1227
01:00:24,560 --> 01:00:26,520
Agora, o que eu fixen
ao final do día?

1228
01:00:26,520 --> 01:00:29,190
>> Eu engade un pouco de inglés
palabras a xeito de comentarios.

1229
01:00:29,190 --> 01:00:32,700
O símbolo de barra barra significa, hey,
ordenador é dicir, para o ser humano,

1230
01:00:32,700 --> 01:00:33,820
non para ti, o ordenador.

1231
01:00:33,820 --> 01:00:35,119
Entón, eles son ignorados loxicamente.

1232
01:00:35,119 --> 01:00:35,910
Son só alí.

1233
01:00:35,910 --> 01:00:39,830
>> E, de feito, CS50 IDE mostra-los como
gris, como útil, pero non tecla

1234
01:00:39,830 --> 01:00:41,000
para o programa.

1235
01:00:41,000 --> 01:00:42,570
Teña en conta o que agora pode facer.

1236
01:00:42,570 --> 01:00:44,950
Se coñeces C
programación ou non,

1237
01:00:44,950 --> 01:00:47,722
pode só ir cara atrás neste
programa, e roçar os comentarios.

1238
01:00:47,722 --> 01:00:50,180
Preguntar ao usuario a entrada, comproba se
obter cadea devolta unha cadea de caracteres,

1239
01:00:50,180 --> 01:00:53,009
iterado sobre os personaxes de s
un de cada vez, imprimir o caracter

1240
01:00:53,009 --> 01:00:55,550
i-th personaxe s-- non fai
aínda ten que mirar para o código

1241
01:00:55,550 --> 01:00:57,270
para entender o que este programa fai.

1242
01:00:57,270 --> 01:01:00,280
E, mellor aínda, se ollar
neste programa de unha semana ou dúas,

1243
01:01:00,280 --> 01:01:02,280
ou un mes ou un ano,
Tamén non teñen

1244
01:01:02,280 --> 01:01:04,420
a ollar para o código,
tentando lembrar,

1245
01:01:04,420 --> 01:01:06,630
o que eu estaba tentando facer este código?

1246
01:01:06,630 --> 01:01:07,770
>> Xa dixo a si mesmo.

1247
01:01:07,770 --> 01:01:11,660
Describiu-o para si mesmo,
ou algún compañeiro ou TA, ou TF.

1248
01:01:11,660 --> 01:01:14,860
E así este sería agora
correcta, e un bo deseño,

1249
01:01:14,860 --> 01:01:18,210
e, finalmente, un bo estilo tamén.

1250
01:01:18,210 --> 01:01:19,990
Entón faga manter isto presente.

1251
01:01:19,990 --> 01:01:22,200
>> Polo tanto, hai outro
cousa que eu vou facer aquí

1252
01:01:22,200 --> 01:01:28,240
que agora poden revelar o que é
pasando debaixo do capó.

1253
01:01:28,240 --> 01:01:30,390
Entón hai ese recurso
en C, e outras linguas,

1254
01:01:30,390 --> 01:01:33,010
chamado typecasting
que de forma implícita

1255
01:01:33,010 --> 01:01:37,250
ou explicitamente permite converter
a partir dun tipo de datos a outro.

1256
01:01:37,250 --> 01:01:39,800
Temos lidado tan
até hoxe, con cordas.

1257
01:01:39,800 --> 01:01:41,250
>> E as cordas son carácteres.

1258
01:01:41,250 --> 01:01:44,910
Pero lembre-se a partir da semana
0, cales son personaxes?

1259
01:01:44,910 --> 01:01:49,334
Caracteres son só unha abstracción
enriba de números decimais Números de,

1260
01:01:49,334 --> 01:01:52,500
e os números decimais son realmente só un
abstracción encima dos números binarios,

1261
01:01:52,500 --> 01:01:53,720
como definimos.

1262
01:01:53,720 --> 01:01:55,540
>> Entón personaxes son números.

1263
01:01:55,540 --> 01:01:58,410
E as cifras son personaxes,
só en función do contexto.

1264
01:01:58,410 --> 01:02:01,250
E verifícase que dentro
dun programa de ordenador,

1265
01:02:01,250 --> 01:02:06,830
pode especificar como quere ollar
nos bits dentro dese programa?

1266
01:02:06,830 --> 01:02:10,400
>> Lembre da semana 0 que tivemos
Ascii, que é só este código

1267
01:02:10,400 --> 01:02:11,620
letras de cartografía para números.

1268
01:02:11,620 --> 01:02:13,660
E nós dixemos, o capital Un é de 65.

1269
01:02:13,660 --> 01:02:15,860
Capital B é 66, e así por diante.

1270
01:02:15,860 --> 01:02:20,500
>> E observen, temos esencialmente caracteres
a liña superior aquí, como C sería chamalos,

1271
01:02:20,500 --> 01:02:23,400
caracteres e logo
ints na segunda liña.

1272
01:02:23,400 --> 01:02:28,180
E resulta que pode converter
sen problemas entre os dous, normalmente.

1273
01:02:28,180 --> 01:02:30,042
E se queremos facer
este deliberadamente, nós

1274
01:02:30,042 --> 01:02:31,750
Pode querer afrontar
algo coma isto.

1275
01:02:31,750 --> 01:02:33,590
>> Podemos querer converter
maiúsculas para diminuír

1276
01:02:33,590 --> 01:02:35,330
caso, minúsculas para maiúsculas.

1277
01:02:35,330 --> 01:02:38,000
E verifícase que hai
en realidade, un estándar aquí

1278
01:02:38,000 --> 01:02:39,900
podemos abrazar en só un momento.

1279
01:02:39,900 --> 01:02:44,120
Pero imos ollar primeiro para un
exemplo de facelo explicitamente.

1280
01:02:44,120 --> 01:02:46,340
>> Vou volver para IDE CS50.

1281
01:02:46,340 --> 01:02:50,640
Eu estou indo para crear un
arquivo chamado ASCII 0.c.

1282
01:02:50,640 --> 01:02:55,960
E eu estou indo a ir adiante e engadir o meu
io.h estándar na parte superior, int void main

1283
01:02:55,960 --> 01:02:57,370
na parte superior da miña función.

1284
01:02:57,370 --> 01:03:02,700
E entón eu estou indo só para facer o
following-- bucle i é igual,

1285
01:03:02,700 --> 01:03:04,610
digamos, 65.

1286
01:03:04,610 --> 01:03:10,460
>> E entón eu será inferior a
65, ademais de 26 letras no alfabeto.

1287
01:03:10,460 --> 01:03:12,640
Entón eu vou deixar o ordenador
facer a matemática para min alí.

1288
01:03:12,640 --> 01:03:15,100
E, a continuación, no interior deste circuíto,
o que eu vou para imprimir?

1289
01:03:15,100 --> 01:03:19,230
>> % C é% i barra invertida n.

1290
01:03:19,230 --> 01:03:21,290
E agora quero para conectar dous valores.

1291
01:03:21,290 --> 01:03:24,530
Engada temporalmente cuestión
marca alí para invitar a cuestión.

1292
01:03:24,530 --> 01:03:29,940
>> Quero facer unha iteración de 65 en diante
durante 26 letras do alfabeto,

1293
01:03:29,940 --> 01:03:35,190
imprimindo en cada iteración que
equivalente integrante do personaxe.

1294
01:03:35,190 --> 01:03:38,299
Noutras palabras, quero
iteración máis de 26 números de impresión

1295
01:03:38,299 --> 01:03:41,590
o que o personaxe ASCII é, a carta,
e que o número correspondente é--

1296
01:03:41,590 --> 01:03:44,650
realmente só recreando
o gráfico a partir dese foto.

1297
01:03:44,650 --> 01:03:47,010
Entón, o que eses puntos de interrogación ser?

1298
01:03:47,010 --> 01:03:51,760
>> Ben, parece que a segunda
hai que ser só o i variable.

1299
01:03:51,760 --> 01:03:53,860
Quero ver iso como un número.

1300
01:03:53,860 --> 01:03:58,920
E o argumento media
aquí, podo dicir ao ordenador

1301
01:03:58,920 --> 01:04:03,470
para tratar ese enteiro
i como un personaxe, de xeito

1302
01:04:03,470 --> 01:04:05,880
para substitúe-lo aquí por cento C.

1303
01:04:05,880 --> 01:04:07,990
>> Noutras palabras, se I, o
programador humano, sabe

1304
01:04:07,990 --> 01:04:09,865
estes son só números
ao final do día.

1305
01:04:09,865 --> 01:04:12,500
E sei que 65 deben
mapear a algún personaxe.

1306
01:04:12,500 --> 01:04:15,310
Con este elenco explícito,
cun paréntese,

1307
01:04:15,310 --> 01:04:18,840
o nome do tipo de datos que quere
converter, e un paréntese pechada,

1308
01:04:18,840 --> 01:04:21,200
pode dicir o
ordenador, hey, ordenador,

1309
01:04:21,200 --> 01:04:24,130
converter este número enteiro para un char.

1310
01:04:24,130 --> 01:04:26,250
>> Entón, cando eu executar este
programa tras compilar,

1311
01:04:26,250 --> 01:04:29,740
imos ver o que eu get-- facer ASCII 0.

1312
01:04:29,740 --> 01:04:33,020
Darn-lo, o que eu fixen de malo aquí?

1313
01:04:33,020 --> 01:04:35,884
Use de identificador non declarado,
todo ben, non intencional,

1314
01:04:35,884 --> 01:04:37,800
pero imos ver se non podemos
razón por iso.

1315
01:04:37,800 --> 01:04:41,220
>> Entón liña five-- entón eu non chegar
moi lonxe antes de romper.

1316
01:04:41,220 --> 01:04:42,140
Está ben.

1317
01:04:42,140 --> 01:04:46,560
Así, a liña 5 para i é igual a 65-- vexo.

1318
01:04:46,560 --> 01:04:50,130
Entón recorda que, en C, ao contrario de algúns
idiomas, se ten programación previa

1319
01:04:50,130 --> 01:04:52,190
experiencia, ten
para dicir ao ordenador,

1320
01:04:52,190 --> 01:04:55,040
A diferenza de risco, o que
tipo de variable que é.

1321
01:04:55,040 --> 01:04:56,860
>> E eu esquezo unha frase clave aquí.

1322
01:04:56,860 --> 01:04:59,200
Na liña de cinco, eu comece a usar i.

1323
01:04:59,200 --> 01:05:01,560
Pero eu non contei C
o tipo de datos que é.

1324
01:05:01,560 --> 01:05:04,570
Entón, eu estou indo a ir aquí e
dicir, ah, facelo un enteiro.

1325
01:05:04,570 --> 01:05:07,050
>> Agora eu estou indo a ir adiante e recompilar.

1326
01:05:07,050 --> 01:05:08,080
Que fixa iso.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Intro, iso é legal.

1328
01:05:12,660 --> 01:05:15,360
Non só é super rápido para
pedir ao ordenador a esta pregunta,

1329
01:05:15,360 --> 01:05:18,885
en vez de ollar-lo nun slide,
Lo impreso un por liña, A é 65,

1330
01:05:18,885 --> 01:05:24,860
B é de 66, todo o camiño desde que down--
fixo 26 vezes-- ao letras z,

1331
01:05:24,860 --> 01:05:25,630
que é de 90.

1332
01:05:25,630 --> 01:05:27,790
E, de feito, lixeiramente
máis intelixente sería

1333
01:05:27,790 --> 01:05:31,030
foron para min a non confiar
no ordenador para engadir 26.

1334
01:05:31,030 --> 01:05:34,060
I podería ter feito
90, así como, tanto tempo

1335
01:05:34,060 --> 01:05:37,390
como eu non cometer o mesmo erro dúas veces.

1336
01:05:37,390 --> 01:05:41,880
Eu quero ir cara arriba a través
z, non só a través y.

1337
01:05:41,880 --> 01:05:44,000
>> Entón, iso é unha conversión explícita.

1338
01:05:44,000 --> 01:05:47,860
Acontece que este
Nin sequera é necesario.

1339
01:05:47,860 --> 01:05:52,480
Deixe-me ir adiante e executa de novo este
compilador e reprise ASCII 0.

1340
01:05:52,480 --> 01:05:54,940
Acontece que C é moi intelixente.

1341
01:05:54,940 --> 01:05:57,150
>> E printf, en particular,
é moi intelixente.

1342
01:05:57,150 --> 01:06:01,260
Se só pasar un i dúas veces
a ambos os espazos reservados, printf

1343
01:06:01,260 --> 01:06:04,510
Notarás, oh, así, sei que
deume un integer-- algún número,

1344
01:06:04,510 --> 01:06:06,380
como 65 ou 90, ou o que quere.

1345
01:06:06,380 --> 01:06:10,170
Pero ver que me quere
formato ese número como un personaxe.

1346
01:06:10,170 --> 01:06:16,460
E así printf pode implicitamente fundido
o int para un char para ti tamén.

1347
01:06:16,460 --> 01:06:19,360
Entón iso non é un problema de todos.

1348
01:06:19,360 --> 01:06:23,100
>> Pero teña en conta, por mor desa equivalencia
podemos realmente facer iso tamén.

1349
01:06:23,100 --> 01:06:26,520
Deixe-me ir adiante e facer un
outra versión do isto-- 1.c. ASCII

1350
01:06:26,520 --> 01:06:31,800
E no canto de iteración sobre
enteiros, realmente pode fundir a súa mente

1351
01:06:31,800 --> 01:06:33,610
iterando sobre personaxes.

1352
01:06:33,610 --> 01:06:37,660
Un char c obtén capital de A, I
quere ir adiante e facelo,

1353
01:06:37,660 --> 01:06:41,740
sempre que C é menos que o igual
a Z. de capital e en cada iteración

1354
01:06:41,740 --> 01:06:45,690
Quero incrementar C, podo
agora na miña liña printf aquí

1355
01:06:45,690 --> 01:06:51,320
digamos, por cento C é
por cento i novo, coma C.

1356
01:06:51,320 --> 01:06:57,200
>> E agora, podo ir na outra dirección,
lanzando o carácter explícitamente

1357
01:06:57,200 --> 01:06:58,500
para un número enteiro.

1358
01:06:58,500 --> 01:07:00,560
Entón, unha vez máis, por que faría iso?

1359
01:07:00,560 --> 01:07:03,830
É un pouco raro para clasificar de
contar en termos de caracteres.

1360
01:07:03,830 --> 01:07:07,430
>> Pero se entender o que está
pasando baixo o capó,

1361
01:07:07,430 --> 01:07:08,430
Non hai realmente ningunha máxica.

1362
01:07:08,430 --> 01:07:13,060
Só está dicindo, hey, ordenador dar
me unha variable chamada C do tipo char.

1363
01:07:13,060 --> 01:07:16,520
Inicialize-o ao capital A. E
notar única cuestión comiñas.

1364
01:07:16,520 --> 01:07:19,580
>> Para caracteres en C, lembre de
a semana pasada, usa comiñas simples.

1365
01:07:19,580 --> 01:07:23,720
Para cadeas, por palabras,
frases, usa comiñas dobres.

1366
01:07:23,720 --> 01:07:27,210
OK, ordenador, continuar facendo iso, entón
sempre que o personaxe é inferior a

1367
01:07:27,210 --> 01:07:28,050
ou igual a z.

1368
01:07:28,050 --> 01:07:32,640
E sei da miña mesa ASCII que todos
destes códigos ASCII son contiguos.

1369
01:07:32,640 --> 01:07:33,400
>> Non hai lagoas.

1370
01:07:33,400 --> 01:07:36,737
Entón é só da a Z,
separados por un número cada.

1371
01:07:36,737 --> 01:07:38,820
E entón eu podo incrementar
un char, se eu realmente quero.

1372
01:07:38,820 --> 01:07:40,390
Ao final do día,
é só un número.

1373
01:07:40,390 --> 01:07:41,030
Sei que isto.

1374
01:07:41,030 --> 01:07:43,670
Entón eu só podo presumir para engadir 1 a ela.

1375
01:07:43,670 --> 01:07:46,940
>> E, a continuación, esta vez, eu imprimir c,
e, a continuación, o equivalente integrante.

1376
01:07:46,940 --> 01:07:50,170
E eu nin sequera precisa do elenco explícito.

1377
01:07:50,170 --> 01:07:52,680
Podo deixar printf eo
ordenador entender as cousas,

1378
01:07:52,680 --> 01:07:57,300
de xeito que agora se eu executar
facer Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Recibe exactamente o mesmo tamén.

1380
01:08:01,520 --> 01:08:04,530
>> programa inútil, embora-- ninguén
vai realmente escribir software

1381
01:08:04,530 --> 01:08:07,549
a fin de descubrir, cal foi o
número que mapea a A ou B, ou Z?

1382
01:08:07,549 --> 01:08:10,340
Só vai a Google-lo, ou
buscalo en liña, ou buscalo

1383
01:08:10,340 --> 01:08:11,650
sobre unha lámina, ou similares.

1384
01:08:11,650 --> 01:08:13,520
Entón onde é que isto realmente obter útil?

1385
01:08:13,520 --> 01:08:15,960
>> Ben, falando niso
foto, sinalar que hai

1386
01:08:15,960 --> 01:08:20,890
un patrón real aquí entre maiúsculas
e minúsculas que non foi accidental.

1387
01:08:20,890 --> 01:08:23,760
Teña en conta que o capital Un é de 65.

1388
01:08:23,760 --> 01:08:25,830
Minúsculas un é de 97.

1389
01:08:25,830 --> 01:08:29,649
E como lonxe é minúscula a?

1390
01:08:29,649 --> 01:08:32,649
>> Así, 65 é o número de pasos de 97?

1391
01:08:32,649 --> 01:08:36,210
Entón, 97 menos 65 é de 32.

1392
01:08:36,210 --> 01:08:37,910
Así, o capital un é de 65.

1393
01:08:37,910 --> 01:08:39,939
Se engadir 32 a iso,
comeza minúsculas a.

1394
01:08:39,939 --> 01:08:43,729
E, de forma equivalente, se restar 32,
Lo a volver para o capital A-- mesmo con B

1395
01:08:43,729 --> 01:08:46,380
poucos B, C grande para algo c.

1396
01:08:46,380 --> 01:08:50,670
>> Todas esas lagoas son 32 apart.

1397
01:08:50,670 --> 01:08:54,450
Agora, iso parece para permitir
facer algo como Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
ou Google Docs posúen, onde
Pode seleccionar todo e, a continuación, dicir:

1399
01:08:57,729 --> 01:09:00,520
cambiar todo en minúsculas, ou
cambiar todo en maiúsculas,

1400
01:09:00,520 --> 01:09:03,840
ou cambiar só a primeira palabra
dunha frase en maiúsculas.

1401
01:09:03,840 --> 01:09:07,390
Podemos realmente facer algo
así nós mesmos.

1402
01:09:07,390 --> 01:09:12,645
>> Deixe-me ir adiante e gardar un ficheiro
aquí chamado de capitalizar 0.c.

1403
01:09:12,645 --> 01:09:15,770
E imos adiante e látego dun programa
que fai exactamente iso deste xeito.

1404
01:09:15,770 --> 01:09:18,460
Así, a biblioteca inclúen CS50.

1405
01:09:18,460 --> 01:09:21,430
E inclúen estándar de I / O.

1406
01:09:21,430 --> 01:09:22,787
>> E sei que iso está chegando.

1407
01:09:22,787 --> 01:09:24,870
Entón, eu vou poñelas
xa, string.h,

1408
01:09:24,870 --> 01:09:26,960
entón eu teño acceso a
cousas como Stirling,

1409
01:09:26,960 --> 01:09:29,620
e logo, int void main, como de costume.

1410
01:09:29,620 --> 01:09:33,420
E entón eu estou indo a ir adiante
e facer cordas recibe obter corda,

1411
01:09:33,420 --> 01:09:35,032
só para obter unha secuencia do usuario.

1412
01:09:35,032 --> 01:09:36,740
E entón eu vou
facer o meu exame de sanidade.

1413
01:09:36,740 --> 01:09:40,510
A cadea non é igual a cero,
entón é seguro para continuar.

1414
01:09:40,510 --> 01:09:42,000
E o que quero facer?

1415
01:09:42,000 --> 01:09:48,700
Eu estou indo a percorrer desde i é igual a 0,
e n ata a lonxitude da corda de s.

1416
01:09:48,700 --> 01:09:51,899
>> E eu vou facer iso, sempre que
i é menor que n, e eu plus plus.

1417
01:09:51,899 --> 01:09:55,060
Ata agora, eu son realmente só
prestando ideas de antes.

1418
01:09:55,060 --> 01:09:57,010
E agora eu estou indo a introducir unha rama.

1419
01:09:57,010 --> 01:09:59,635
>> Entón, creo que volta a cero, onde
tivemos estes garfos na estrada,

1420
01:09:59,635 --> 01:10:05,110
e na semana pasada en C. Vou
dicir que, se o personaxe i-th en s

1421
01:10:05,110 --> 01:10:09,250
é maior que ou
igual a un minúsculas,

1422
01:10:09,250 --> 01:10:13,340
e- en risco se fose literalmente
dicir e, aínda que en C di e comercial,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- eo carácter i-th en s
é inferior ou igual a z minúsculas,

1424
01:10:19,830 --> 01:10:21,780
imos facer algo interesante.

1425
01:10:21,780 --> 01:10:27,020
Imos realmente imprimir un
personaxe con ningunha nova liña

1426
01:10:27,020 --> 01:10:31,760
que é o carácter na secuencia,
o carácter i-th na cadea.

1427
01:10:31,760 --> 01:10:37,420
>> Pero imos adiante e
restar 32 a partir del.

1428
01:10:37,420 --> 01:10:42,120
Else o personaxe do
cadea que nós estamos mirando

1429
01:10:42,120 --> 01:10:45,950
non é entre un pouco
e pouca z, vai adiante

1430
01:10:45,950 --> 01:10:48,610
e só imprimiu inalterado.

1431
01:10:48,610 --> 01:10:50,840
Entón, nós introducimos
esta notación entre corchetes

1432
01:10:50,840 --> 01:10:53,560
para as nosas cordas para chegar á
i-th carácter na cadea.

1433
01:10:53,560 --> 01:10:57,520
>> Eu engade algunha lóxica condicional, como
Cero a semana última semana, onde

1434
01:10:57,520 --> 01:10:59,880
Eu só estou usando o meu fundamentais
comprensión do que é

1435
01:10:59,880 --> 01:11:01,130
pasando debaixo do capó.

1436
01:11:01,130 --> 01:11:04,190
É o personaxe i da s
maior que ou igual a un?

1437
01:11:04,190 --> 01:11:08,290
Como é 97 ou 98,
ou 99, e así por diante?

1438
01:11:08,290 --> 01:11:11,940
>> Pero tamén é menor ou igual
ao valor de z minúsculas?

1439
01:11:11,940 --> 01:11:16,210
E se é así, o que é que esta liña significa?

1440
01:11:16,210 --> 01:11:20,250
14, esta é unha especie de
xerme de toda idea,

1441
01:11:20,250 --> 01:11:23,840
capitalizar letra por
simplemente subtraindo 32 a partir del,

1442
01:11:23,840 --> 01:11:29,370
neste caso, porque sei, por que
gráfico, como os meus números son representados.

1443
01:11:29,370 --> 01:11:33,925
Entón, imos adiante e executar tanto,
tras compilar capitalizar 0.c,

1444
01:11:33,925 --> 01:11:36,210
e executar capitalizar 0.

1445
01:11:36,210 --> 01:11:40,300
>> Imos escribir algo como
Zamyla en todas as letras minúsculas entrar.

1446
01:11:40,300 --> 01:11:42,780
E agora temos Zamyla en todas as letras maiúsculas.

1447
01:11:42,780 --> 01:11:45,050
Imos escribir Rob en todas as letras minúsculas.

1448
01:11:45,050 --> 01:11:46,674
Intentaremos Jason en todas as letras minúsculas.

1449
01:11:46,674 --> 01:11:48,590
E seguimos recibindo o
capitalización forzada.

1450
01:11:48,590 --> 01:11:50,960
Hai un pequeno erro que eu
tipo de non anticipar.

1451
01:11:50,960 --> 01:11:54,050
Teña en conta o meu novo poder é acabar
na mesma liña que os seus nomes,

1452
01:11:54,050 --> 01:11:55,520
que se sente un pouco confuso.

1453
01:11:55,520 --> 01:11:59,170
>> Entón, eu estou indo a ir aquí, e
en realidade, a finais do presente programa

1454
01:11:59,170 --> 01:12:02,110
imprimir un carácter de nova liña.

1455
01:12:02,110 --> 01:12:03,160
Iso é todo.

1456
01:12:03,160 --> 01:12:06,120
Con printf, non
pasar variables ou código de formato.

1457
01:12:06,120 --> 01:12:08,460
Pode literalmente só imprimir
algo así como unha nova liña.

1458
01:12:08,460 --> 01:12:13,529
>> Entón, imos adiante e facer
capitalizar 0 novo, executa-lo de novo, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
E agora é un pouco máis fermosa.

1460
01:12:14,820 --> 01:12:17,274
Agora, a miña liña é na súa propia liña nova.

1461
01:12:17,274 --> 01:12:18,440
Entón, iso é todo moi ben e bo.

1462
01:12:18,440 --> 01:12:19,910
Entón, iso é un bo exemplo.

1463
01:12:19,910 --> 01:12:22,700
Pero nin sequera necesariamente
Debe codificar a 32.

1464
01:12:22,700 --> 01:12:23,350
Vostede sabe o que?

1465
01:12:23,350 --> 01:12:26,350
Podería dizer-- eu nunca
Lembre-se cal é a diferenza.

1466
01:12:26,350 --> 01:12:29,330
>> Pero eu sei que eu
ten unha letra minúscula,

1467
01:12:29,330 --> 01:12:34,430
I, esencialmente, quere restar off
calquera que sexa a distancia entre é pouco

1468
01:12:34,430 --> 01:12:39,160
un e un grande, porque se eu asumir que
todas as outras cartas son os mesmos,

1469
01:12:39,160 --> 01:12:41,045
que debe comezar o traballo feito.

1470
01:12:41,045 --> 01:12:42,670
Pero en vez de facelo, vostede sabe o que?

1471
01:12:42,670 --> 01:12:44,240
Hai outra forma aínda.

1472
01:12:44,240 --> 01:12:48,090
>> Se isto é feito 1.c-- se eu fose
Para poñer isto nun ficheiro separado.

1473
01:12:48,090 --> 01:12:51,030
Imos facer capitalizar 2.c como segue.

1474
01:12:51,030 --> 01:12:53,060
Eu estou indo para realmente limpar iso aquí.

1475
01:12:53,060 --> 01:12:57,420
E en vez de ter que mesmo
saben ou se preocupan os de baixo nivel

1476
01:12:57,420 --> 01:13:01,090
detalles de implementación, eu son xa
indo só para imprimir un carácter,

1477
01:13:01,090 --> 01:13:04,610
entre comiñas, por cento C, e
logo chamar outra función que

1478
01:13:04,610 --> 01:13:09,950
hai que leva un argumento,
que é un personaxe, como este.

1479
01:13:09,950 --> 01:13:12,630
>> Acontece en C, non hai
outra chamada de función

1480
01:13:12,630 --> 01:13:15,550
a superior, que como o seu propio nome
suxire leva un personaxe

1481
01:13:15,550 --> 01:13:19,350
e fai a súa maiúsculas
equivalente, e, a continuación, devolve-lo

1482
01:13:19,350 --> 01:13:21,410
de xeito que printf pode liga-lo alí.

1483
01:13:21,410 --> 01:13:25,484
E así, para facelo, con todo, eu
necesidade de introducir un ficheiro.

1484
01:13:25,484 --> 01:13:28,400
Acontece que hai outro arquivo
que só sabería de clase,

1485
01:13:28,400 --> 01:13:33,020
ou un libro, ou un en liña
referencia chamada C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Entón, se eu engadir que ata entre meu cabeceira
arquivos, e agora re-compilar este programa,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Intro.

1488
01:13:43,040 --> 01:13:46,690
Imos escribir Zamyla en todos
minúsculas, aínda funciona do mesmo.

1489
01:13:46,690 --> 01:13:48,040
Pero vostede sabe o que?

1490
01:13:48,040 --> 01:13:55,590
Acontece que a parte superior
Ten algunha outra función.

1491
01:13:55,590 --> 01:13:58,410
>> E deixe-me presentar este
mando aquí, máis ou menos torpes

1492
01:13:58,410 --> 01:14:00,250
chamado, pero o home para guía.

1493
01:14:00,250 --> 01:14:03,960
Acontece que a maioría dos ordenadores Linux,
como estamos usando aqui-- operativo Linux

1494
01:14:03,960 --> 01:14:06,270
system-- ter unha orde
chamado home, que di:

1495
01:14:06,270 --> 01:14:08,530
hey, ordenador, dáme
manual do ordenador.

1496
01:14:08,530 --> 01:14:10,680
O que quere
mirar para arriba nese manual?

1497
01:14:10,680 --> 01:14:13,840
>> Quero mirar para arriba a función
chamados a superior, Intro.

1498
01:14:13,840 --> 01:14:16,070
E é algo críptica
para ler, ás veces.

1499
01:14:16,070 --> 01:14:18,780
Pero teña en conta que estamos no
Manual de Programador Linux.

1500
01:14:18,780 --> 01:14:19,530
E é todo o texto.

1501
01:14:19,530 --> 01:14:21,905
E teña en conta que hai a
nome da función ata aquí.

1502
01:14:21,905 --> 01:14:25,030
Acontece que un primo chamado
para diminuír, o que fai o contrario.

1503
01:14:25,030 --> 01:14:29,710
E notificación segundo sinopse, para usar o
funcionar a páxina do manual, por así dicir,

1504
01:14:29,710 --> 01:14:32,220
Está me dicindo que eu
Debe incluír c type.h.

1505
01:14:32,220 --> 01:14:33,630
E eu sabía que a partir da práctica.

1506
01:14:33,630 --> 01:14:36,210
>> Aquí, está me amosando os dous
prototipos para a función,

1507
01:14:36,210 --> 01:14:39,070
de xeito que se eu queira utilizar este
Sei o que toman como entrada,

1508
01:14:39,070 --> 01:14:40,652
eo que retornan como saída.

1509
01:14:40,652 --> 01:14:42,360
E entón se eu ler
a descrición, eu vexo

1510
01:14:42,360 --> 01:14:44,820
con máis detalle o que a función fai.

1511
01:14:44,820 --> 01:14:48,100
Pero o máis importante, se
Eu ollo baixo do valor de cambio,

1512
01:14:48,100 --> 01:14:51,710
el di que o valor devolto é
que da carta convertido,

1513
01:14:51,710 --> 01:14:57,880
ou C, a entrada orixinal, Se
a conversión non foi posible.

1514
01:14:57,880 --> 01:15:01,992
>> Noutras palabras, a parte superior vai
para converter unha carta para maiúsculas.

1515
01:15:01,992 --> 01:15:03,450
E se é así, que vai para devolve-lo.

1516
01:15:03,450 --> 01:15:07,010
Pero se non pode, por algunha razón
quizais sexa caso xa superior,

1517
01:15:07,010 --> 01:15:09,550
quizais sexa un punto de exclamación
ou algún outro punctuation--

1518
01:15:09,550 --> 01:15:12,200
el só vai para
devolver o C orixinal,

1519
01:15:12,200 --> 01:15:17,340
o que significa que podo facer o meu código
mellor deseñado como segue.

1520
01:15:17,340 --> 01:15:20,580
>> Eu non teño todos
estas liñas danado de código.

1521
01:15:20,580 --> 01:15:22,610
Todas as liñas que eu
só iluminada pode

1522
01:15:22,610 --> 01:15:28,700
ser recollidas en só un simple
liña, que é isto-- cento printf

1523
01:15:28,700 --> 01:15:33,510
c ó soporte S superior i.

1524
01:15:33,510 --> 01:15:36,090
E esta sería unha
exemplo de mellor deseño.

1525
01:15:36,090 --> 01:15:40,040
>> Por implantar en 7 ou 8 liñas
de código, calquera que fose só

1526
01:15:40,040 --> 01:15:44,960
suprimido, cando se pode, en vez colapso
todo isto a toma de lóxica e da decisión

1527
01:15:44,960 --> 01:15:49,620
nunha soa liña, 13 agora, que
depende dunha biblioteca function--

1528
01:15:49,620 --> 01:15:53,430
unha función que vén con C, pero que
fai o que quere que faga.

1529
01:15:53,430 --> 01:15:55,295
E, francamente, mesmo se
el non veu con C,

1530
01:15:55,295 --> 01:15:58,880
podes implementar lo, como
vimos, coa obter int negativo

1531
01:15:58,880 --> 01:16:01,700
e obter positiva int a semana pasada tamén.

1532
01:16:01,700 --> 01:16:03,470
>> Este código é agora moito máis lexible.

1533
01:16:03,470 --> 01:16:06,670
E, de feito, se desprazar para arriba,
vexa como moito máis compacto

1534
01:16:06,670 --> 01:16:08,360
esta versión do meu programa é.

1535
01:16:08,360 --> 01:16:11,230
É un pouco pesado top agora,
con todos estes inclúe.

1536
01:16:11,230 --> 01:16:14,380
Pero todo ben, porque agora eu estou de pé
sobre os ombreiros dos programadores

1537
01:16:14,380 --> 01:16:15,300
antes de min.

1538
01:16:15,300 --> 01:16:18,440
E quen queira que fose que
aplicadas para superior realmente

1539
01:16:18,440 --> 01:16:21,470
fíxome un favor, moi parecido quen
aplicado Stirling realmente

1540
01:16:21,470 --> 01:16:24,790
fíxome un favor hai algún tempo.

1541
01:16:24,790 --> 01:16:26,970
E agora temos unha
mellor programa de deseño

1542
01:16:26,970 --> 01:16:31,680
que aplica a mesma lóxica exacta.

1543
01:16:31,680 --> 01:16:35,580
>> Falando de Stirling, imos
me ir adiante e facelo.

1544
01:16:35,580 --> 01:16:38,320
Deixe-me ir adiante e gardar
este ficheiro como stirling.c.

1545
01:16:38,320 --> 01:16:43,255
E pasa, podemos pelar
outra capa moi sinxelo agora.

1546
01:16:43,255 --> 01:16:45,630
Eu estou indo a ir adiante e látego
-Se outro programa na principal

1547
01:16:45,630 --> 01:16:49,759
aquí que simplemente re-aplica
lonxitude da corda como segue.

1548
01:16:49,759 --> 01:16:52,300
Entón aquí está unha liña de código que
déixame unha secuencia do usuario.

1549
01:16:52,300 --> 01:16:53,910
Seguimos a utilizar este novo e de novo.

1550
01:16:53,910 --> 01:16:58,900
Deixe-me dar-me unha variable chamada
n do tipo int que almacena un número.

1551
01:16:58,900 --> 01:17:02,490
>> E deixe-me ir adiante e
faga o seguinte lóxica.

1552
01:17:02,490 --> 01:17:15,610
Mentres que o personaxe N-th no s
é igual a barra invertida 0, vai adiante

1553
01:17:15,610 --> 01:17:17,930
e incrementar n.

1554
01:17:17,930 --> 01:17:23,506
E, a continuación, imprimir printf cento i n.

1555
01:17:23,506 --> 01:17:29,200
Eu afirmo que este programa aquí,
sen chamar lonxitude da corda,

1556
01:17:29,200 --> 01:17:31,150
descobre a lonxitude dunha cadea.

1557
01:17:31,150 --> 01:17:34,600
>> E a maxia é enteiramente
encapsulada en liña 8

1558
01:17:34,600 --> 01:17:39,830
aquí o que parece ser unha nova sintaxe,
esta barra invertida 0 entre aspas.

1559
01:17:39,830 --> 01:17:41,360
Pero por que isto?

1560
01:17:41,360 --> 01:17:44,100
Ben, considerada o que foi
pasando todo este tempo.

1561
01:17:44,100 --> 01:17:47,990
>> E como un aparte antes de que eu esqueza, entende
tamén, que ademais das páxinas man

1562
01:17:47,990 --> 01:17:50,920
que veñen con un típico
sistema Linux como CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
entender que nós, o
Os funcionarios do curso, teñen tamén

1564
01:17:53,770 --> 01:17:56,030
fixo unha versión web
desta mesma idea chamada

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, que posúe
todas estas mesmas páxinas man,

1566
01:17:59,940 --> 01:18:02,020
todos da mesma
documentación, así como

1567
01:18:02,020 --> 01:18:05,730
unha pequena caixa na parte superior que permite
converter todo o bastante

1568
01:18:05,730 --> 01:18:09,025
linguaxe arcano en menos cómodo
mode, onde nós, o corpo docente,

1569
01:18:09,025 --> 01:18:12,150
pasaron por e intentou simplificar
un pouco de linguaxe para manter as cousas

1570
01:18:12,150 --> 01:18:14,830
incidir sobre as ideas, e non
algúns dos aspectos técnicos.

1571
01:18:14,830 --> 01:18:20,070
Polo tanto, teña presente, reference.cs50.net
como outro recurso tamén.

1572
01:18:20,070 --> 01:18:23,800
>> Pero por que funciona lonxitude da corda
a forma como eu propuxen un momento atrás?

1573
01:18:23,800 --> 01:18:25,160
Aquí é o nome do Zamyla novo.

1574
01:18:25,160 --> 01:18:27,690
E aquí é o nome do Zamyla
casetonado, como eu continuar facendo,

1575
01:18:27,690 --> 01:18:31,360
para pintar unha imaxe de ser,
realmente, só unha secuencia de caracteres.

1576
01:18:31,360 --> 01:18:34,260
Pero non hai Zamyla
no illamento dun programa.

1577
01:18:34,260 --> 01:18:37,420
>> Cando escribir e executar un programa,
está a usar o seu Mac ou PC

1578
01:18:37,420 --> 01:18:40,010
como memoria, ou RAM, por así dicir.

1579
01:18:40,010 --> 01:18:42,620
E pode pensar
o ordenador como tendo

1580
01:18:42,620 --> 01:18:44,730
lotes de gigabytes de memoria nestes días.

1581
01:18:44,730 --> 01:18:47,700
E un concerto significa millóns,
polo que miles de millóns de bytes.

1582
01:18:47,700 --> 01:18:48,910
>> Pero imos retroceder no tempo.

1583
01:18:48,910 --> 01:18:51,530
E supoña que estamos usando
un ordenador moi antigo que

1584
01:18:51,530 --> 01:18:55,150
só ten 32 bytes de memoria.

1585
01:18:55,150 --> 01:18:59,310
Podería, na pantalla do meu ordenador,
simplemente deseñar iso deste xeito.

1586
01:18:59,310 --> 01:19:05,240
>> Podería simplemente dicir que o meu
ordenador ten toda esa memoria.

1587
01:19:05,240 --> 01:19:08,830
E iso é como unha vara de memoria, se
Vostede recorda a nosa imaxe da última vez.

1588
01:19:08,830 --> 01:19:11,670
E se eu só dividir
isto varias veces,

1589
01:19:11,670 --> 01:19:15,040
Eu afirmo que teño 32 bytes
de memoria na pantalla.

1590
01:19:15,040 --> 01:19:18,239
>> Agora, en realidade, só podo
deseñar ata agora nesta pantalla aquí.

1591
01:19:18,239 --> 01:19:20,280
Entón, eu estou indo para adiante,
e só por convención,

1592
01:19:20,280 --> 01:19:24,050
chamar a memoria do meu ordenador como un
reixa, non só como unha liña recta.

1593
01:19:24,050 --> 01:19:28,190
En concreto, eu afirmo agora que
esa reixa, esta reixa 8 por 4,

1594
01:19:28,190 --> 01:19:31,800
só representa todos os 32 bytes
de memoria dispoñible no meu Mac,

1595
01:19:31,800 --> 01:19:33,030
ou dispoñibles no meu PC.

1596
01:19:33,030 --> 01:19:34,780
E eles están enrolando
en dúas liñas, só

1597
01:19:34,780 --> 01:19:38,030
porque encaixa máis na pantalla.

1598
01:19:38,030 --> 01:19:40,800
Pero este é o primeiro byte.

1599
01:19:40,800 --> 01:19:41,990
Este é o segundo byte.

1600
01:19:41,990 --> 01:19:43,300
Este é o terceiro byte.

1601
01:19:43,300 --> 01:19:45,310
>> E este é o byte 32.

1602
01:19:45,310 --> 01:19:52,910
Ou, se pensamos como un ordenador
científico, isto é o octeto 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Entón tes 0 a 31, se
comezar a contar a 0.

1604
01:19:55,950 --> 01:19:59,830
>> Entón, se usamos un programa
que as chamadas obter corda,

1605
01:19:59,830 --> 01:20:05,280
e estivemos cunha corda do humano
como eu fixen chamado Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
como no mundo fai o
franxa do ordenador sustento dos cales byte,

1607
01:20:09,430 --> 01:20:12,230
que pedazo de memoria,
pertence a cal corda?

1608
01:20:12,230 --> 01:20:16,270
Noutras palabras, se proceder á
escriba outro nome para o ordenador,

1609
01:20:16,270 --> 01:20:19,890
como este Andi, chamando
obter cadea por segunda vez,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I ten que acabar no
memoria do ordenador tamén.

1611
01:20:23,030 --> 01:20:23,850
Pero como?

1612
01:20:23,850 --> 01:20:29,700
>> Ben, acontece que por baixo da
capo, o C fai cando almacenar cordas

1613
01:20:29,700 --> 01:20:35,080
que tipo humanos, ou que
vir dalgunha outra fonte, é

1614
01:20:35,080 --> 01:20:39,190
delineia a fin de lles
unha barra invertida character-- especial

1615
01:20:39,190 --> 01:20:44,750
0, que é só un xeito especial
de dicir 80 bits nunha fileira.

1616
01:20:44,750 --> 01:20:47,950
>> Entón A-- este é o recall número 97.

1617
01:20:47,950 --> 01:20:51,770
Entón, algún defecto de 8 bits
representa o número decimal 97.

1618
01:20:51,770 --> 01:20:58,070
Esta barra invertida 0 é, literalmente, o número
0, nul a.k.a., N-L-G, ao contrario da anterior,

1619
01:20:58,070 --> 01:20:59,630
N-Ou-L-L, que falamos.

1620
01:20:59,630 --> 01:21:05,700
Pero, polo de agora, só sei que este
barra invertida 0 é só 80 bits nunha fileira.

1621
01:21:05,700 --> 01:21:09,810
>> E é só esta liña no
area que di algo á esquerda

1622
01:21:09,810 --> 01:21:12,610
pertence a unha corda, ou un tipo de datos.

1623
01:21:12,610 --> 01:21:15,480
E algo a dereita
pertence a algunha outra cousa.

1624
01:21:15,480 --> 01:21:17,440
Andi do nome, non obstante,
que visualmente

1625
01:21:17,440 --> 01:21:21,310
pasa para embrulhar a outra liña,
pero iso é só un detalle estético,

1626
01:21:21,310 --> 01:21:23,990
Analogamente é nul terminada.

1627
01:21:23,990 --> 01:21:29,290
>> É unha secuencia de caracteres a A-N-D-I,
ademais dun quinto personaxe secreto,

1628
01:21:29,290 --> 01:21:33,560
todo 0 bits, que só demarcam
a fin do nome do Andi ben.

1629
01:21:33,560 --> 01:21:37,120
E se chamamos obter secuencia dunha terceira vez
no ordenador para obter unha cadea como

1630
01:21:37,120 --> 01:21:44,210
Maria, H-A-R-I-A, de forma semellante é o María
nome nul rematou barra invertida 0.

1631
01:21:44,210 --> 01:21:47,170
>> Isto é fundamentalmente diferente
de como un ordenador faría normalmente

1632
01:21:47,170 --> 01:21:51,850
almacenar un número enteiro, é un float, ou outra
tipos de datos aínda, porque recall,

1633
01:21:51,850 --> 01:21:57,420
un completo é xeralmente de 32 bits, ou
4 bytes, ou quizais ata 64 bits,

1634
01:21:57,420 --> 01:21:59,100
ou oito bytes.

1635
01:21:59,100 --> 01:22:02,620
Pero moitas primitivas nun ordenador
nunha linguaxe de programación

1636
01:22:02,620 --> 01:22:05,550
teñen un número fixo de
bytes debaixo da hood--

1637
01:22:05,550 --> 01:22:08,100
quizais un, quizais dous, quizais 4, quizais 8.

1638
01:22:08,100 --> 01:22:13,250
>> Pero cordas, polo proxecto, ter un
número dinámico de caracteres.

1639
01:22:13,250 --> 01:22:16,980
Non sabe con antelación, ata
tipo humanos en Z-A-H-Y-L-A,

1640
01:22:16,980 --> 01:22:21,400
ou M-A-R-I-A, ou A-N-D-I. Non sabe
cantas veces o usuario está indo bater

1641
01:22:21,400 --> 01:22:22,070
teclado.

1642
01:22:22,070 --> 01:22:26,490
Polo tanto, non sabe como
moitos personaxes de antelación

1643
01:22:26,490 --> 01:22:27,540
vai ter.

1644
01:22:27,540 --> 01:22:31,840
>> E así C só unha especie de follas como un
breadcrumb segredo debaixo do capó

1645
01:22:31,840 --> 01:22:32,960
ao final da cadea.

1646
01:22:32,960 --> 01:22:39,280
Despois de gardar Z-A-H-Y-L-A en memoria,
Tamén só pon o equivalente

1647
01:22:39,280 --> 01:22:40,210
dun período.

1648
01:22:40,210 --> 01:22:45,060
Ao final dunha frase,
pon 80 bits, de xeito

1649
01:22:45,060 --> 01:22:49,120
lembrar de onde
Zamyla comeza e remata.

1650
01:22:49,120 --> 01:22:51,490
>> Entón, cal é a conexión,
entón, para este programa?

1651
01:22:51,490 --> 01:22:55,190
Este programa aquí, Stirling,
é simplemente un mecanismo

1652
01:22:55,190 --> 01:22:57,970
para obter unha cadea
do usuario, a liña 6.

1653
01:22:57,970 --> 01:23:01,160
Liña 7, eu declarar unha variable
chamado n e define-lo igual a 0.

1654
01:23:01,160 --> 01:23:08,680
>> E, a continuación, na liña 8, eu simplemente preguntou ao
pregunta, mentres que o personaxe N-th fai

1655
01:23:08,680 --> 01:23:12,120
é igual a todo 0 bits--
Noutras palabras, non fai

1656
01:23:12,120 --> 01:23:14,500
igual este especial
carácter, barra invertida 0, o que

1657
01:23:14,500 --> 01:23:18,470
Era só que character-- nul especial
dalle só incrementar n.

1658
01:23:18,470 --> 01:23:21,460
>> E seguir facendo iso, e manter a
facendo iso, e continuar facendo isto.

1659
01:23:21,460 --> 01:23:23,430
E por iso mesmo que en
o pasado usamos i,

1660
01:23:23,430 --> 01:23:25,181
é perfectamente ben
semanticamente para usar N,

1661
01:23:25,181 --> 01:23:27,430
se está só tentando
contar esta vez deliberadamente,

1662
01:23:27,430 --> 01:23:28,720
e só quero chamalo n.

1663
01:23:28,720 --> 01:23:34,720
Entón, iso simplemente continúa facendo a pregunta,
é o personaxe N-th s todo 0s?

1664
01:23:34,720 --> 01:23:38,470
Se non, mire para o próximo look,
mirar para o outro, ollar para o outro,

1665
01:23:38,470 --> 01:23:39,460
ollar para o seguinte.

1666
01:23:39,460 --> 01:23:45,540
>> Pero así que ve barra invertida 0,
esta liña loop-- 9 a 11-- para.

1667
01:23:45,540 --> 01:23:49,640
Saia do loop while,
deixando dentro desa variable n

1668
01:23:49,640 --> 01:23:54,530
unha conta total de todo o
caracteres na secuencia que viu,

1669
01:23:54,530 --> 01:23:55,660
imprimir lo dese xeito para fóra.

1670
01:23:55,660 --> 01:23:56,760
Entón, imos tentar iso.

1671
01:23:56,760 --> 01:23:59,500
>> Deixe-me ir adiante e sen
utilizando a función de Stirling,

1672
01:23:59,500 --> 01:24:04,240
pero só usando a miña propia versión homegrown
aquí chamado de Stirling, deixe-me ir adiante

1673
01:24:04,240 --> 01:24:07,700
e executar Stirling, escriba algo
como Zamyla, que eu saiba con antelación

1674
01:24:07,700 --> 01:24:08,670
é de seis caracteres.

1675
01:24:08,670 --> 01:24:10,080
Imos ver se funciona.

1676
01:24:10,080 --> 01:24:10,920
En realidade, é seis.

1677
01:24:10,920 --> 01:24:15,257
Intentaremos con Rob, tres personaxes,
tres caracteres, así como, e así por diante.

1678
01:24:15,257 --> 01:24:17,340
Entón, iso é todo o que está pasando
por baixo do capuz.

1679
01:24:17,340 --> 01:24:19,548
E teña en conta as conexións,
despois, coa primeira semana

1680
01:24:19,548 --> 01:24:22,370
de clase, onde falamos
algo así como abstracción,

1681
01:24:22,370 --> 01:24:26,960
que é só iso capas de ideas, ou
complexidade, na parte superior dos principios básicos.

1682
01:24:26,960 --> 01:24:30,710
Aquí, nós estamos mirando tipo de
debaixo do capó de Stirling,

1683
01:24:30,710 --> 01:24:33,510
por así dicir, de descubrir,
como sería aplicado?

1684
01:24:33,510 --> 01:24:35,232
>> E poderiamos volver implementar lo nós mesmos.

1685
01:24:35,232 --> 01:24:37,440
Pero estamos nunca máis vai
reimplementar Stirling.

1686
01:24:37,440 --> 01:24:39,780
Nós só estamos indo a
Stirling, a fin usar

1687
01:24:39,780 --> 01:24:42,100
para realmente obter un longo cordas.

1688
01:24:42,100 --> 01:24:44,200
>> Pero non hai máxica
debaixo do capó.

1689
01:24:44,200 --> 01:24:46,716
Se sabe que por baixo
o capó, unha cadea

1690
01:24:46,716 --> 01:24:48,090
é só unha secuencia de caracteres.

1691
01:24:48,090 --> 01:24:51,090
E esa secuencia de caracteres
todo pode ser numericamente dirixida

1692
01:24:51,090 --> 01:24:53,330
co soporte 0, soporte
1, o soporte 2, e

1693
01:24:53,330 --> 01:24:57,420
sabe que ao final dunha secuencia é un
carácter especial, pode descubrir

1694
01:24:57,420 --> 01:25:01,710
como facer máis nada nun
programa, porque todo o que se reduce a

1695
01:25:01,710 --> 01:25:03,400
é a lectura ea escritura de memoria.

1696
01:25:03,400 --> 01:25:06,130
Isto é, o cambio e á procura
na memoria, ou mover as cousas

1697
01:25:06,130 --> 01:25:10,940
arredor da memoria, cousas de impresión
na pantalla, e así por diante.

1698
01:25:10,940 --> 01:25:14,800
>> Entón, imos agora utilizar esta nova
comprensión do que realmente amarra

1699
01:25:14,800 --> 01:25:17,910
están debaixo do capó, e
pelar outra capa

1700
01:25:17,910 --> 01:25:20,080
que ata agora temos
foi ignorando por completo.

1701
01:25:20,080 --> 01:25:22,650
En particular, calquera momento
temos implantado un programa,

1702
01:25:22,650 --> 01:25:25,930
tivemos esta liña de código
na parte superior declarando principal.

1703
01:25:25,930 --> 01:25:27,810
E nós temos indicado void main int.

1704
01:25:27,810 --> 01:25:31,240
>> E ese baleiro dentro dos parénteses
está a dicir todo este tempo que a principal

1705
01:25:31,240 --> 01:25:33,440
en si non recibe ningún argumento.

1706
01:25:33,440 --> 01:25:36,210
Calquera entrada que o principal é
comezará a partir do usuario

1707
01:25:36,210 --> 01:25:39,020
Ten que vir dalgún outro
mecanismo, como get int,

1708
01:25:39,020 --> 01:25:42,040
ou obter float, ou obter corda,
ou algunha outra función.

1709
01:25:42,040 --> 01:25:44,710
Pero parece que
cando escribe un programa,

1710
01:25:44,710 --> 01:25:47,690
realmente pode especificar
que este programa

1711
01:25:47,690 --> 01:25:51,730
tomar entradas do humano
na propia liña de comandos.

1712
01:25:51,730 --> 01:25:56,310
>> Noutras palabras, aínda que ata o momento
ser executado só ./hello Ola

1713
01:25:56,310 --> 01:26:00,312
ou programas similares, todos do
outros programas que temos benvida a empregar,

1714
01:26:00,312 --> 01:26:02,770
que nós mesmos non escribiu,
está a tomar, ao parecer,

1715
01:26:02,770 --> 01:26:05,210
liña de comandos arguments--
cousas como facer.

1716
01:26:05,210 --> 01:26:07,450
Di algo así como marca,
e, a continuación, unha segunda palabra.

1717
01:26:07,450 --> 01:26:10,950
Ou clang, di clang, e logo
unha segunda palabra, o nome dun ficheiro.

1718
01:26:10,950 --> 01:26:14,410
>> Ou mesmo RM ou CP, como pode
ver ou xa utilizado

1719
01:26:14,410 --> 01:26:15,880
para eliminar ou copiar ficheiros.

1720
01:26:15,880 --> 01:26:18,920
Todos aqueles tomar chamada
liña de comandos arguments--

1721
01:26:18,920 --> 01:26:21,130
palabras adicionais no ventá de terminal.

1722
01:26:21,130 --> 01:26:23,260
Pero ata agora, nós
nós non tivemos

1723
01:26:23,260 --> 01:26:27,080
ese luxo de tomar a entrada do
usuario cando el ou ela realmente funciona

1724
01:26:27,080 --> 01:26:29,120
o propio programa da liña de comandos.

1725
01:26:29,120 --> 01:26:33,710
>> Pero podemos facelo por re-declarar
principal fronte, non tendo

1726
01:26:33,710 --> 01:26:36,750
anular entre parénteses,
pero estes dous argumentos

1727
01:26:36,750 --> 01:26:40,600
instead-- o primeiro un enteiro,
ea segunda algo

1728
01:26:40,600 --> 01:26:44,170
novo, algo que nós imos chamar
unha matriz, algo semellante en espírito

1729
01:26:44,170 --> 01:26:49,220
ao que vimos en risco como unha lista, pero
unha matriz de cadeas, como veremos en breve.

1730
01:26:49,220 --> 01:26:51,790
Pero imos ver iso
Como exemplo, antes de

1731
01:26:51,790 --> 01:26:53,690
distinguir o que iso significa.

1732
01:26:53,690 --> 01:26:56,520
>> Entón, se eu entrar CS50 IDE
aquí, eu teño ido adiante

1733
01:26:56,520 --> 01:27:01,840
e declarou nun arquivo chamado
argv0.c o modelo a seguir.

1734
01:27:01,840 --> 01:27:04,120
E teña en conta que o único
que é diferente de momento

1735
01:27:04,120 --> 01:27:08,570
é que eu cambie baleiro para int
cadea argc argv soporte abatible, pechar

1736
01:27:08,570 --> 01:27:09,070
soporte.

1737
01:27:09,070 --> 01:27:11,730
E teña en conta, de momento, non hai
nada dentro destes soportes.

1738
01:27:11,730 --> 01:27:12,620
>> Non hai ningún número.

1739
01:27:12,620 --> 01:27:15,070
E non hai ningún i, ou
n, ou calquera outra letra.

1740
01:27:15,070 --> 01:27:17,010
Estou só usando o
corchetes, por agora,

1741
01:27:17,010 --> 01:27:19,510
por razóns que virá
ao en só un momento.

1742
01:27:19,510 --> 01:27:21,330
>> E agora o que eu vou facer é esta.

1743
01:27:21,330 --> 01:27:26,680
Se argc é igual é igual a 2--
e recordar que é igual a igual

1744
01:27:26,680 --> 01:27:30,040
é o operador de igualdade comparando
á esquerda e á dereita a igualdade.

1745
01:27:30,040 --> 01:27:31,790
Non é a asignación
operador, que é

1746
01:27:31,790 --> 01:27:36,510
o signo igual única, o que significa copia
da dereita á esquerda algún valor.

1747
01:27:36,510 --> 01:27:42,840
>> Se argc é igual é igual a 2, quero
digamos, printf, Ola, porcentaxes, nova liña,

1748
01:27:42,840 --> 01:27:47,340
A continuación, conectar em-- e aquí está o novo
soporte de argv trick-- 1, por razóns

1749
01:27:47,340 --> 01:27:48,840
que imos volver nun momento.

1750
01:27:48,840 --> 01:27:52,110
Else if argc non
igual a 2, vostede sabe o que?

1751
01:27:52,110 --> 01:27:57,400
Nós só ir adiante e, como de costume, impresión
out Ola mundo sen substitución.

1752
01:27:57,400 --> 01:28:02,710
>> Así, parece que, se argc, que
significa conta de argumento, é igual a 2,

1753
01:28:02,710 --> 01:28:04,740
Eu estou indo a imprimir
Ola unha cousa ou outra.

1754
01:28:04,740 --> 01:28:07,560
Se non, por defecto, eu son
vai imprimir Ola mundo.

1755
01:28:07,560 --> 01:28:08,770
Entón o que significa isto?

1756
01:28:08,770 --> 01:28:15,550
>> Ben, deixe-me ir adiante e gardar
este ficheiro, e despois fan argv0,

1757
01:28:15,550 --> 01:28:18,940
e despois ./argv0, Intro.

1758
01:28:18,940 --> 01:28:20,300
E di Ola mundo.

1759
01:28:20,300 --> 01:28:21,260
Agora, por que isto?

1760
01:28:21,260 --> 01:28:24,730
>> Ben, acontece que cando
executar un programa en liña de comandos,

1761
01:28:24,730 --> 01:28:29,570
está cubrindo o que imos
xeralmente chamamos un vector de argumento.

1762
01:28:29,570 --> 01:28:33,100
Noutras palabras, automaticamente o
ordenador, o sistema operativo,

1763
01:28:33,100 --> 01:28:38,340
entregará ao seu programa
-se unha lista de todas as palabras

1764
01:28:38,340 --> 01:28:40,850
que o ser humano ingresaran no
ventá, no caso de que

1765
01:28:40,850 --> 01:28:43,790
o programador quere facer
algo con esa información.

1766
01:28:43,790 --> 01:28:48,540
E, neste caso, a única palabra
Eu ingresaran no prompt é ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> E así o número de argumentos que se
sendo pasado para o meu programa é só un.

1768
01:28:55,420 --> 01:28:58,880
Noutras palabras, o argumento
contar, tamén coñecido como argc

1769
01:28:58,880 --> 01:29:00,970
aquí como un enteiro, é só un.

1770
01:29:00,970 --> 01:29:03,000
Un, por suposto, non é igual a dous.

1771
01:29:03,000 --> 01:29:05,980
E entón iso é o que imprime, Ola mundo.

1772
01:29:05,980 --> 01:29:08,170
>> Pero déixeme ter en algún lugar.

1773
01:29:08,170 --> 01:29:09,930
Deixe-me dicir, argv0.

1774
01:29:09,930 --> 01:29:12,740
E entón como sobre María?

1775
01:29:12,740 --> 01:29:14,990
E, a continuación, prema Intro.

1776
01:29:14,990 --> 01:29:18,020
>> E teña en conta o que pasa Magic aquí.

1777
01:29:18,020 --> 01:29:22,640
Agora, en vez de o mundo Ola, teño
cambiou o comportamento deste programa

1778
01:29:22,640 --> 01:29:26,310
tomando a entrada non de obter
corda ou algunha outra función,

1779
01:29:26,310 --> 01:29:30,570
pero a partir de, ao parecer, o meu mando
en si, o que eu orixinalmente escritas.

1780
01:29:30,570 --> 01:29:35,720
E podo xogar este xogo de novo
mudalo para Stelios, por exemplo.

1781
01:29:35,720 --> 01:29:38,400
>> E agora eu vexo outro nome aínda.

1782
01:29:38,400 --> 01:29:40,540
E aquí, eu podería dicir Andi.

1783
01:29:40,540 --> 01:29:42,137
E eu podería dicir Zamyla.

1784
01:29:42,137 --> 01:29:45,220
E podemos xogar este xogo durante todo o día,
só conectar valores diferentes,

1785
01:29:45,220 --> 01:29:49,550
sempre que eu proporcionar exactamente
dúas palabras no prompt,

1786
01:29:49,550 --> 01:29:52,260
de tal forma que argc, contar o meu argumento, é 2.

1787
01:29:52,260 --> 01:29:57,240
>> Non vexo que o nome ligado a
printf, por esa condición aquí?

1788
01:29:57,240 --> 01:30:00,550
Entón parece que temos agora
a capacidade expresiva

1789
01:30:00,550 --> 01:30:04,410
de tomar a entrada doutro mecanismo,
na liña de comandos chamada,

1790
01:30:04,410 --> 01:30:07,000
en vez de ter que esperar
ata que o usuario executa o programa,

1791
01:30:07,000 --> 01:30:10,220
e, a continuación, pedir-lle
usando algo corda get.

1792
01:30:10,220 --> 01:30:11,230
>> Entón, o que é iso?

1793
01:30:11,230 --> 01:30:15,010
Argc, unha vez máis, é só un enteiro,
o número de palavras-- arguments--

1794
01:30:15,010 --> 01:30:18,540
que o usuario proporcionado na
alerta, na fiestra de terminal,

1795
01:30:18,540 --> 01:30:20,110
incluíndo o nome do programa.

1796
01:30:20,110 --> 01:30:23,340
Polo tanto, a nosa ./argv0 é, efectivamente,
o nome do programa,

1797
01:30:23,340 --> 01:30:24,520
ou como eu executar o programa.

1798
01:30:24,520 --> 01:30:25,810
>> Iso conta como unha palabra.

1799
01:30:25,810 --> 01:30:27,080
Así, sería unha argc.

1800
01:30:27,080 --> 01:30:29,750
Pero cando eu escriba Stelios, ou
Andi, ou Zamyla, ou María,

1801
01:30:29,750 --> 01:30:31,660
isto significa que o número de argumentos é dous.

1802
01:30:31,660 --> 01:30:33,910
E agora hai dúas palabras pasado para el.

1803
01:30:33,910 --> 01:30:36,070
>> E noten, podemos seguir esa lóxica.

1804
01:30:36,070 --> 01:30:39,050
Se realmente dicir
algo así como Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
un nome, pasando así
tres argumentos en total,

1806
01:30:42,200 --> 01:30:47,410
Agora di que o estándar novo,
porque, obviamente, 3 non é igual a dous.

1807
01:30:47,410 --> 01:30:54,080
>> E así, deste xeito, eu teño
acceso vía argv este novo argumento

1808
01:30:54,080 --> 01:30:56,080
que poderiamos tecnicamente
chamar calquera cousa que queiramos.

1809
01:30:56,080 --> 01:30:58,940
Pero, por convención, é
argv e argc, respectivamente.

1810
01:30:58,940 --> 01:31:04,470
Argv, vector argumento, é unha especie
dun sinónimo para unha programación

1811
01:31:04,470 --> 01:31:07,140
recurso en C chamado un array.

1812
01:31:07,140 --> 01:31:14,410
>> Unha matriz é unha lista de valores semellantes
atrás, cara atrás, cara atrás, cara atrás.

1813
01:31:14,410 --> 01:31:17,810
Noutras palabras, se un está ben aquí en
RAM, a próxima é ben próximo a ela,

1814
01:31:17,810 --> 01:31:18,800
e á dereita próximo a el.

1815
01:31:18,800 --> 01:31:20,101
Eles non están en todo o lugar.

1816
01:31:20,101 --> 01:31:23,100
E que este último escenario, onde as cousas
están por todo o lugar da memoria,

1817
01:31:23,100 --> 01:31:25,082
realmente pode ser un poderoso recurso.

1818
01:31:25,082 --> 01:31:28,040
Pero imos voltar a iso cando
falar sobre estruturas de datos máis sofisticados.

1819
01:31:28,040 --> 01:31:32,260
De momento, unha matriz é só un
anaco de memoria contigua,

1820
01:31:32,260 --> 01:31:36,520
cada un de cuxos elementos son
atrás, cara atrás, cara atrás, cara atrás,

1821
01:31:36,520 --> 01:31:38,050
e, xeralmente, do mesmo tipo.

1822
01:31:38,050 --> 01:31:42,630
>> Entón, se pensar, a partir dun
hai pouco, o que é unha cadea?

1823
01:31:42,630 --> 01:31:50,460
Ben, unha corda, como Zamyla,
Z-A-H-Y-L-A, é, tecnicamente,

1824
01:31:50,460 --> 01:31:51,400
só unha matriz.

1825
01:31:51,400 --> 01:31:53,700
É unha matriz de caracteres.

1826
01:31:53,700 --> 01:31:59,250
>> E por iso, se realmente chamar a isto, como eu
fixo anteriormente, como unha peza de memoria,

1827
01:31:59,250 --> 01:32:04,510
verifícase que cada un destes
caracteres ocupa un byte.

1828
01:32:04,510 --> 01:32:07,630
E despois hai quen especial
carácter sentinela, a barra invertida 0,

1829
01:32:07,630 --> 01:32:12,360
ou todos os oito bits de 0, que
demarca o fin desa cadea.

1830
01:32:12,360 --> 01:32:15,090
Así, unha corda, que se transforma
a fóra, citar cadea unquote,

1831
01:32:15,090 --> 01:32:20,580
é só un conxunto de chara--
carbonizar ser un tipo de datos real.

1832
01:32:20,580 --> 01:32:24,560
>> E agora argv, meanwhile--
imos voltar para o programa.

1833
01:32:24,560 --> 01:32:29,582
Argv, a pesar de ver a palabra
cadea aquí, non é unha cadea en si.

1834
01:32:29,582 --> 01:32:33,640
Argv, o argumento do vector,
é unha matriz de cadeas.

1835
01:32:33,640 --> 01:32:37,620
>> Entón, como pode ter unha variedade de
caracteres, pode ter nivel superior,

1836
01:32:37,620 --> 01:32:46,279
unha matriz de strings-- Así, por exemplo,
cando eu escriba un momento atrás ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0, espazo Z-A-M-Y-L-A, I alegou que
argv tiña dúas cordas en ./argv0 ele--,

1838
01:33:00,150 --> 01:33:03,185
e Z-A-H-Y-L-A. en
Noutras palabras, se argc 2.

1839
01:33:03,185 --> 01:33:03,980
Por que é iso?

1840
01:33:03,980 --> 01:33:08,370
>> Ben, de forma eficaz, o que está pasando
en é que cada unha desas cordas

1841
01:33:08,370 --> 01:33:13,990
é, por suposto, unha serie de caracteres
Como antes, cada un de cuxos personaxes

1842
01:33:13,990 --> 01:33:15,670
ocupa un byte.

1843
01:33:15,670 --> 01:33:19,720
E non confundir a 0 real
en nome do programa coa 0,

1844
01:33:19,720 --> 01:33:22,040
o que significa que todos os 80 bits.

1845
01:33:22,040 --> 01:33:27,140
E Zamyla, mentres, aínda é
tamén unha matriz de caracteres.

1846
01:33:27,140 --> 01:33:31,450
>> Así, ao final do día, realmente
parécese tanto debaixo do capó.

1847
01:33:31,450 --> 01:33:38,800
Pero argv, por natureza, como principal
obras, permite-me para embrulhar todo isto

1848
01:33:38,800 --> 01:33:44,810
-se para, se quixeren, unha matriz maior
que, se un pouco máis de simplificar

1849
01:33:44,810 --> 01:33:48,180
o que a imaxe se parece e non
moi deseña-lo para escalar alí enriba,

1850
01:33:48,180 --> 01:33:56,720
esta matriz é só o tamaño 2, o primeiro
elemento que contén unha cadea,

1851
01:33:56,720 --> 01:33:59,230
o segundo elemento de
que contén unha cadea.

1852
01:33:59,230 --> 01:34:01,687
E, á súa vez, se
tipo de zoom en cada

1853
01:34:01,687 --> 01:34:03,770
desas cordas, o que lle
vexa debaixo do capó

1854
01:34:03,770 --> 01:34:07,190
é que cada corda é só
un conxunto de caracteres.

1855
01:34:07,190 --> 01:34:11,680
>> Agora, como con cordas,
fomos capaces de obter acceso

1856
01:34:11,680 --> 01:34:15,260
ao carácter i-th nunha cadea
usando esa notación corchete.

1857
01:34:15,260 --> 01:34:17,320
Do mesmo xeito, con matrices
En xeral, podemos

1858
01:34:17,320 --> 01:34:22,700
usar a notación de corchete para
en calquera número de cordas nunha matriz?

1859
01:34:22,700 --> 01:34:25,100
Por exemplo, déixeme
dalle facelo.

1860
01:34:25,100 --> 01:34:32,420
>> Deixe-me ir adiante e crear argv1.c,
que é un pouco diferente esta vez.

1861
01:34:32,420 --> 01:34:35,635
No canto de comprobar a argc2,
Vou vez facelo.

1862
01:34:35,635 --> 01:34:41,270
Para int eu recibín 0, I é menos
que argc, eu plus plus,

1863
01:34:41,270 --> 01:34:47,920
e, a continuación, imprimir neste,
por cento s, nova liña e, a continuación,

1864
01:34:47,920 --> 01:34:50,740
argv soporte i.

1865
01:34:50,740 --> 01:34:55,220
>> Polo tanto, noutras palabras, eu non estou lidando con
caracteres individuais no momento.

1866
01:34:55,220 --> 01:35:00,190
Argv, como suxire estes cadrado
cintas á dereita do nome argv,

1867
01:35:00,190 --> 01:35:03,320
significa argv é un array de cadeas.

1868
01:35:03,320 --> 01:35:04,870
E argc é só un int.

1869
01:35:04,870 --> 01:35:08,800
>> Esta liña aquí, 6, é
dicindo set i igual a 0.

1870
01:35:08,800 --> 01:35:11,980
Conta todo o camiño ata,
pero non incluídos, argc.

1871
01:35:11,980 --> 01:35:14,010
E, a continuación, en cada iteración,
imprimir unha cadea.

1872
01:35:14,010 --> 01:35:14,800
Que corda?

1873
01:35:14,800 --> 01:35:17,270
>> A cadea i-th en argv.

1874
01:35:17,270 --> 01:35:19,530
Así, mentres que antes era
usando o corchete

1875
01:35:19,530 --> 01:35:22,180
notación para chegar ao om
carácter dunha cadea, agora

1876
01:35:22,180 --> 01:35:27,240
Eu estou usando a notación corchete
para chegar á cadea om nunha matriz.

1877
01:35:27,240 --> 01:35:30,310
Entón, é unha especie de unha capa
anterior, conceptualmente.

1878
01:35:30,310 --> 01:35:35,390
>> E entón o que é interesante sobre esta
programa de agora, se eu compilar argv1,

1879
01:35:35,390 --> 01:35:42,067
e despois facer ./argv1 e escriba
en algo así como foo bar Baz,

1880
01:35:42,067 --> 01:35:45,400
que son as tres palabras estándar que un
científico da computación colle calquera momento

1881
01:35:45,400 --> 01:35:51,010
el ou ela ten que algunhas palabras de espazo reservado,
e prema Intro, cada unha destas palabras,

1882
01:35:51,010 --> 01:35:54,980
incluíndo o nome do programa, que
é en argv no primeiro lugar,

1883
01:35:54,980 --> 01:35:58,320
remata-se a ser impreso un de cada vez.

1884
01:35:58,320 --> 01:36:05,290
E se eu cambiar isto, e eu digo
algo así como argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
temos os tres deses
palabras, que é argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, porque neste
caso argc, a conta, é 3.

1887
01:36:14,400 --> 01:36:20,020
>> Pero o que é interesante é se entender
que argv é só unha matriz de cadeas,

1888
01:36:20,020 --> 01:36:24,910
e entende que unha cadea
é un array de caracteres,

1889
01:36:24,910 --> 01:36:29,470
podemos realmente tipo de usar este
notación corchete varias veces

1890
01:36:29,470 --> 01:36:33,320
para escoller unha corda, a continuación, escolla
un personaxe dentro da cadea,

1891
01:36:33,320 --> 01:36:35,730
mergullo en profundo como segue.

1892
01:36:35,730 --> 01:36:40,100
Neste exemplo, deixe-me ir
adiante e chamar este argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
E, neste exemplo, deixe-me ir adiante
e facer o following-- para int i obter 0,

1895
01:36:50,180 --> 01:36:53,286
i é menos argc, i máis
Ademais, como antes.

1896
01:36:53,286 --> 01:36:55,910
Polo tanto, noutras palavras-- e agora este
está quedando complicado abondo.

1897
01:36:55,910 --> 01:36:59,940
Entón eu vou dicir
iterado sobre cordas en argv,

1898
01:36:59,940 --> 01:37:01,294
como un comentario para min mesmo.

1899
01:37:01,294 --> 01:37:03,960
E entón eu vou ter un
aniñada para loop, que probablemente

1900
01:37:03,960 --> 01:37:06,290
ter feito, é considerado
facendo, en arañazos, onde

1901
01:37:06,290 --> 01:37:08,600
Eu vou dicir que eu son int--
non vai utilizar i novo,

1902
01:37:08,600 --> 01:37:12,590
porque eu non quero sombra, ou
tipo de substituír o i existente.

1903
01:37:12,590 --> 01:37:15,780
>> Eu estou indo a, no seu lugar, din j porque
esa é a miña vez de variable despois i,

1904
01:37:15,780 --> 01:37:18,590
cando eu só estou tentando
contar números simples.

1905
01:37:18,590 --> 01:37:28,850
Para j obtén 0-- e tamén, N, vai
obter a lonxitude popa do soporte de argv i,

1906
01:37:28,850 --> 01:37:36,030
sempre que J é inferior a M,
j plus plus, faga o seguinte.

1907
01:37:36,030 --> 01:37:37,500
E aquí é a parte interesante.

1908
01:37:37,500 --> 01:37:46,330
>> Imprimir un carácter e unha nova liña,
conectando soporte argv i, j soporte.

1909
01:37:46,330 --> 01:37:47,940
OK, entón deixe-me engadir algúns comentarios aquí.

1910
01:37:47,940 --> 01:37:54,820
Iterado sobre personaxes
na secuencia actual,

1911
01:37:54,820 --> 01:38:02,290
impresión de caracteres j-th na cadea i-th.

1912
01:38:02,290 --> 01:38:04,630
Entón, agora, imos considerar
que eses comentarios dicir.

1913
01:38:04,630 --> 01:38:06,750
>> Iterado sobre as cordas
en argv-- cantas

1914
01:38:06,750 --> 01:38:09,300
cordas están en argv, que é unha matriz?

1915
01:38:09,300 --> 01:38:13,420
Argc moitos, polo que estou a iteración
desde i igual a 0 ata argc.

1916
01:38:13,420 --> 01:38:20,020
Mentres tanto, o número de caracteres
están na cadea i-th en argv?

1917
01:38:20,020 --> 01:38:22,880
>> Ben, para obter esta resposta,
Só chamar lonxitude da corda

1918
01:38:22,880 --> 01:38:26,810
sobre os coidados da cadea cadea I
sobre, que é argv soporte i.

1919
01:38:26,810 --> 01:38:30,090
E eu estou indo para almacenar temporalmente que
valor n, só para fins de almacenamento na caché,

1920
01:38:30,090 --> 01:38:31,590
para garda-lo para a eficiencia.

1921
01:38:31,590 --> 01:38:36,330
E entón eu vou arrincar j a 0,
continuar mentres j sexa menor que n,

1922
01:38:36,330 --> 01:38:38,430
e en cada incremento iteración j.

1923
01:38:38,430 --> 01:38:41,030
>> E entón aquí, por
o meu comentario na liña 12,

1924
01:38:41,030 --> 01:38:43,390
imprimir un carácter,
seguido por unha nova liña,

1925
01:38:43,390 --> 01:38:48,140
soporte especialmente argv
i me dá a secuencia de i-th

1926
01:38:48,140 --> 01:38:51,690
en argv-- así que a primeira palabra, o
segunda palabra, terceira palabra, que sexa.

1927
01:38:51,690 --> 01:38:57,370
E, a continuación, mergullo j no máis profundo, e queda
me o personaxe j-th da palabra.

1928
01:38:57,370 --> 01:39:02,200
E así, efectivamente, pode tratar
argv como un multi-dimensional,

1929
01:39:02,200 --> 01:39:06,050
como bidimensional, matriz,
no que cada palabra tipo de miradas

1930
01:39:06,050 --> 01:39:08,580
como este na súa mente de
ollo, e cada personaxe

1931
01:39:08,580 --> 01:39:10,930
é unha especie de composto en
unha columna, se iso axuda.

1932
01:39:10,930 --> 01:39:13,260
>> En realidade, cando provocalo
este apart en futuras semanas

1933
01:39:13,260 --> 01:39:15,580
vai ser un pouco
máis sofisticado do que iso.

1934
01:39:15,580 --> 01:39:17,800
Pero realmente pode
pensar que, polo momento,

1935
01:39:17,800 --> 01:39:22,110
como só iso bidimensional
array, no que un nivel de que

1936
01:39:22,110 --> 01:39:23,260
é todas as cordas.

1937
01:39:23,260 --> 01:39:26,760
E entón se mergullar máis fondo,
pode chegar a caracteres individuais

1938
01:39:26,760 --> 01:39:29,600
nel empregando esta notación aquí.

1939
01:39:29,600 --> 01:39:31,620
>> Entón, cal é o efecto neto?

1940
01:39:31,620 --> 01:39:34,970
Deixe-me ir adiante e
facer danado argv2 --- lo.

1941
01:39:34,970 --> 01:39:36,210
Eu cometín un erro aquí.

1942
01:39:36,210 --> 01:39:40,160
Implicitamente declarando a
Biblioteca Stirling función.

1943
01:39:40,160 --> 01:39:42,190
Entón todo este tempo, é
quizais apropiado

1944
01:39:42,190 --> 01:39:45,130
que estamos tipo de acabado
exactamente onde comezamos.

1945
01:39:45,130 --> 01:39:48,160
>> Eu estraguei todo, declarando implicitamente
Biblioteca Stirling función.

1946
01:39:48,160 --> 01:39:48,987
OK, agarde un minuto.

1947
01:39:48,987 --> 01:39:51,070
Lembro que, sobre todo
xa que é aquí.

1948
01:39:51,070 --> 01:39:54,490
Que incluír string.h en
esta versión do programa.

1949
01:39:54,490 --> 01:40:00,050
>> Deixe-me ir adiante e inclúen
string.h, salvo que, vai adiante

1950
01:40:00,050 --> 01:40:04,460
e recompilar argv2.

1951
01:40:04,460 --> 01:40:08,390
E agora, aquí imos nós, facer argv2, Intro.

1952
01:40:08,390 --> 01:40:10,590
E, aínda que sexa un pouco
enigmática, a primeira vista,

1953
01:40:10,590 --> 01:40:15,690
entender que, de feito, o que
é impreso é argv2 punto.

1954
01:40:15,690 --> 01:40:19,970
>> Pero se eu escribir algunhas palabras tras o
alerta, como argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Intro, tamén un pouco
críptica a primeira vista.

1956
01:40:22,560 --> 01:40:30,540
Pero desprazarse cara arriba,
./argv2 Z-A-H-Y-G-A C-H-A-N.

1957
01:40:30,540 --> 01:40:32,190
Entón, nós temos iteración sobre cada palabra.

1958
01:40:32,190 --> 01:40:37,770
E, á súa vez, nos iterada
cada personaxe dentro dunha palabra.

1959
01:40:37,770 --> 01:40:40,040
>> Agora, despois de todo isto,
entender que non hai

1960
01:40:40,040 --> 01:40:43,120
outro detalle que estivemos tipo
de ignorar este tempo.

1961
01:40:43,120 --> 01:40:46,180
Nós só chanceou separar o que
entradas do principal pode ser?

1962
01:40:46,180 --> 01:40:47,780
E como a saída do principal?

1963
01:40:47,780 --> 01:40:50,540
>> Todo este tempo, fomos
só copiando e colando

1964
01:40:50,540 --> 01:40:53,870
a palabra int diante do principal,
que se pode ver en liña,

1965
01:40:53,870 --> 01:40:58,340
ás veces incorrectamente en versións máis antigas
de C e compiladores, que din baleiro,

1966
01:40:58,340 --> 01:40:59,410
ou nada.

1967
01:40:59,410 --> 01:41:01,580
Pero, efectivamente, a versión
de C que estamos usando,

1968
01:41:01,580 --> 01:41:06,180
C 11, ou 2011, enténdese
que debe ser int.

1969
01:41:06,180 --> 01:41:09,300
E debe ser tanto
nula ou argc e argv aquí.

1970
01:41:09,300 --> 01:41:10,790
>> Pero por int main?

1971
01:41:10,790 --> 01:41:12,480
Que realmente volvendo?

1972
01:41:12,480 --> 01:41:16,280
Ben, acontece que todo este tempo,
calquera momento que teña escrito un programa de inicio

1973
01:41:16,280 --> 01:41:18,440
sempre retornando algo.

1974
01:41:18,440 --> 01:41:19,960
Pero foi facelo en segredo.

1975
01:41:19,960 --> 01:41:23,350
>> Isto é algo que é un
int, como suxire a liña 5.

1976
01:41:23,350 --> 01:41:24,225
Pero o que int?

1977
01:41:24,225 --> 01:41:26,100
Así, hai este
convenio en programación,

1978
01:41:26,100 --> 01:41:29,790
polo cal se nada ten
mal e todo está ben,

1979
01:41:29,790 --> 01:41:34,250
programas e funcións xeralmente
return-- pouco counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 xeralmente significa que todo está ben.

1982
01:41:38,070 --> 01:41:40,610
Así, aínda que pensas de
-la como falsa en moitos contextos,

1983
01:41:40,610 --> 01:41:42,930
realmente xeralmente significa bo

1984
01:41:42,930 --> 01:41:49,560
>> Por outra banda, se un programa retorna 1,
ou negativo 1 ou 5, ou negativo 42,

1985
01:41:49,560 --> 01:41:52,941
ou calquera-0 non valor,
que xeralmente significa

1986
01:41:52,941 --> 01:41:54,190
que algo deu mal.

1987
01:41:54,190 --> 01:41:56,700
De feito, no seu propio Mac ou PC,
podería ter realmente visto

1988
01:41:56,700 --> 01:42:01,050
unha mensaxe de erro, polo que
di unha cousa ou outra, erro

1989
01:42:01,050 --> 01:42:04,940
código de negativo 42, ou código de erro
23, ou algo así.

1990
01:42:04,940 --> 01:42:08,980
Ese número é xeralmente só unha suxestión
para o programador, ou a empresa

1991
01:42:08,980 --> 01:42:11,174
que fixo o programa,
o que deu mal e por que,

1992
01:42:11,174 --> 01:42:13,590
de xeito que poidan ollar a través
súa documentación ou o código,

1993
01:42:13,590 --> 01:42:15,465
e descubrir o que o
de erro significa realmente.

1994
01:42:15,465 --> 01:42:18,400
Ela xeralmente non é
útil para nós usuarios finais.

1995
01:42:18,400 --> 01:42:20,550
>> Pero cando principais regresa 0, todo está ben.

1996
01:42:20,550 --> 01:42:23,770
E se non especificar
o principal debe volver,

1997
01:42:23,770 --> 01:42:26,950
Ela só vai automaticamente
voltar 0 para ti.

1998
01:42:26,950 --> 01:42:30,870
Pero volvendo algo
outra cousa é realmente útil.

1999
01:42:30,870 --> 01:42:34,660
>> Neste programa final, déixeme
dalle chamar este exit.c,

2000
01:42:34,660 --> 01:42:38,630
e introducir o último de hoxe
temas coñecidos, como un código de erro.

2001
01:42:38,630 --> 01:42:42,930
Deixe-me ir adiante e incluír o noso
arquivos familiares enriba, facer int main.

2002
01:42:42,930 --> 01:42:49,500
E, esta vez, imos facer int argc,
cadea argv, e cos meus soportes

2003
01:42:49,500 --> 01:42:50,836
implicar que é na matriz.

2004
01:42:50,836 --> 01:42:52,460
E, a continuación, deixe-me só facer unha comprobación de sanidade.

2005
01:42:52,460 --> 01:42:56,640
Esta vez, se argc non
igual a 2, entón vostede sabe o que?

2006
01:42:56,640 --> 01:42:57,520
Esquéceo.

2007
01:42:57,520 --> 01:43:03,170
Vou dicir que, hey, usuario,
está falta argumento da liña de comandos

2008
01:43:03,170 --> 01:43:04,210
n barra invertida.

2009
01:43:04,210 --> 01:43:05,230
>> E entón é iso.

2010
01:43:05,230 --> 01:43:06,130
Quero saír.

2011
01:43:06,130 --> 01:43:11,030
Vou preventivamente,
e prematuramente realmente, o retorno

2012
01:43:11,030 --> 01:43:12,810
algo que non sexa o número 1.

2013
01:43:12,810 --> 01:43:15,360
O movemento de valor para o primeiro
erro que pode ocorrer é 1.

2014
01:43:15,360 --> 01:43:17,860
Se ten algunha outra incorrecta
situación que poida ocorrer,

2015
01:43:17,860 --> 01:43:21,390
pódese dicir de retorno 2 ou voltar 3, ou
quizais ata negativo 1 ou 2 negativo.

2016
01:43:21,390 --> 01:43:23,750
>> Estes son só códigos de saída
que son, xeralmente,

2017
01:43:23,750 --> 01:43:27,770
só é útil para o programador, ou o
empresa que está enviando o software.

2018
01:43:27,770 --> 01:43:30,500
Pero o feito de que é
Non 0 é o que é importante.

2019
01:43:30,500 --> 01:43:34,310
Entón, neste programa, quero
garantir que este programa só

2020
01:43:34,310 --> 01:43:38,190
funciona se o usuario ofrece me
cunha conta de argumentos de dous,

2021
01:43:38,190 --> 01:43:42,880
o nome do programa, e algúns outros
palabra, podo facer valer tanto como segue,

2022
01:43:42,880 --> 01:43:46,110
berrar co usuario co proverbio printf,
falta argumento da liña de comandos,

2023
01:43:46,110 --> 01:43:46,970
voltar 1.

2024
01:43:46,970 --> 01:43:49,940
Que só vai inmediatamente
saír do programa.

2025
01:43:49,940 --> 01:43:55,840
>> Só se argc é igual a 2 imos descender
aquí, momento no que eu vou dicir,

2026
01:43:55,840 --> 01:44:00,410
Ola por cento s, barra invertida n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Noutras palabras, eu estou
non indo atrás argv 0,

2028
01:44:03,827 --> 01:44:05,410
que é só o nome do programa.

2029
01:44:05,410 --> 01:44:09,450
Quero imprimir Ola, coma,
a segunda palabra que o ser humano ingresaran.

2030
01:44:09,450 --> 01:44:12,580
E, neste caso en
liña 13, está todo ben.

2031
01:44:12,580 --> 01:44:15,920
>> Sei que argc é 2
loxicamente dende programa.

2032
01:44:15,920 --> 01:44:17,770
Eu estou indo a ir adiante e volver 0.

2033
01:44:17,770 --> 01:44:21,230
Como un aparte, ten en conta que
iso é verdade en risco tamén.

2034
01:44:21,230 --> 01:44:24,760
>> Loxicamente, eu podería facelo
e encapsular estas liñas

2035
01:44:24,760 --> 01:44:27,020
de código nesta cláusula else aquí.

2036
01:44:27,020 --> 01:44:29,420
Pero iso é unha especie de
innecesariamente o recúo meu código.

2037
01:44:29,420 --> 01:44:31,800
E quero facer de super
claro que non importa o que,

2038
01:44:31,800 --> 01:44:34,670
por defecto, Ola
algo vai obter impresos,

2039
01:44:34,670 --> 01:44:36,050
sempre que o usuario coopera.

2040
01:44:36,050 --> 01:44:39,360
>> Polo tanto, é moi común o uso de
unha condición, só unha se,

2041
01:44:39,360 --> 01:44:41,870
para incorporarse algúns incorrecta
situación, e despois saír.

2042
01:44:41,870 --> 01:44:45,690
E, a continuación, tanto todo é
ben, non ten unha persoa,

2043
01:44:45,690 --> 01:44:48,060
pero só ten o código
fóra que, se, por que é

2044
01:44:48,060 --> 01:44:51,060
equivalente neste
caso particular, loxicamente.

2045
01:44:51,060 --> 01:44:54,480
Entón, eu estou volvendo 0, só para
significar explicitamente todo está ben.

2046
01:44:54,480 --> 01:44:58,480
>> Se eu omitido retorno 0, sería
presumir-se automaticamente para min.

2047
01:44:58,480 --> 01:45:00,890
Pero agora que estou volvendo
unha en, polo menos neste caso,

2048
01:45:00,890 --> 01:45:04,940
Vou, para unha boa medida e
claridade, voltar 0, neste caso.

2049
01:45:04,940 --> 01:45:09,690
Entón, agora déixeme ir adiante e facer a saída,
que é un xeito perfecto para a só saír.

2050
01:45:09,690 --> 01:45:14,401
>> Pero asegúrese saída, e me deixe ir
adiante e facer ./exit, Intro.

2051
01:45:14,401 --> 01:45:16,900
E o programa gritou comigo,
falta argumento da liña de comandos.

2052
01:45:16,900 --> 01:45:18,120
OK, déixeme cooperar.

2053
01:45:18,120 --> 01:45:23,810
>> Déixeme en vez facer ./exit, David, Intro.

2054
01:45:23,810 --> 01:45:25,190
E agora di, Ola David.

2055
01:45:25,190 --> 01:45:27,300
E normalmente non ver iso.

2056
01:45:27,300 --> 01:45:30,650
>> Pero parece que hai unha
xeito especial en Linux para realmente ver

2057
01:45:30,650 --> 01:45:34,470
co que o código de saída de un programa pechado.

2058
01:45:34,470 --> 01:45:37,184
Ás veces nunha gráfica
mundo como Mac OS ou Windows,

2059
01:45:37,184 --> 01:45:40,100
só ve estes números cando un
mensaxe de erro aparece na pantalla

2060
01:45:40,100 --> 01:45:41,940
eo programador
mostra ese número.

2061
01:45:41,940 --> 01:45:44,773
Pero se queres ver o que o erro
mensaxe, podemos facelo aqui--

2062
01:45:44,773 --> 01:45:48,100
así ./exit, Intro, impresión
falta argumento da liña de comandos.

2063
01:45:48,100 --> 01:45:54,590
>> Se fago agora $ echo?, Que é
ridiculamente enigmático ollar.

2064
01:45:54,590 --> 01:45:56,590
Pero $?

2065
01:45:56,590 --> 01:45:59,220
é o encantamento máxico
que di, hey, ordenador,

2066
01:45:59,220 --> 01:46:01,900
Dime o que o anterior
código de saída do programa era.

2067
01:46:01,900 --> 01:46:03,410
E eu prema Intro.

2068
01:46:03,410 --> 01:46:07,520
Vexo 1, porque iso é o que eu
dixo a miña principal función para voltar.

2069
01:46:07,520 --> 01:46:12,310
>> Mentres tanto, se eu fai ./exit David,
e prema Intro, vexo, Ola David.

2070
01:46:12,310 --> 01:46:16,800
E se fago agora $ eco?, Eu vexo Ola 0.

2071
01:46:16,800 --> 01:46:19,080
E así que realmente vai
ser unha información valiosa

2072
01:46:19,080 --> 01:46:23,420
no contexto do depurador, non tan
tanto que, o ser humano, lle importaría.

2073
01:46:23,420 --> 01:46:26,060
Pero o depurador e outras
programas usaremos este semestre

2074
01:46:26,060 --> 01:46:29,420
, Moitas veces, ollar para este número,
aínda que é tipo de oculto

2075
01:46:29,420 --> 01:46:32,780
a menos que ollar para el, para
determinar se un programa ou non de

2076
01:46:32,780 --> 01:46:37,050
execución foi correcta ou incorrecta.

2077
01:46:37,050 --> 01:46:40,450
>> E así que nos leva a
este, ao final do día.

2078
01:46:40,450 --> 01:46:43,917
Comezamos hoxe, mirando
depuración, e á súa vez no campo

2079
01:46:43,917 --> 01:46:46,750
en si, e, a continuación, máis interesante,
tecnicamente baixo o capuz

2080
01:46:46,750 --> 01:46:49,490
en que as cordas son, o que dure
semana que acabamos levou para concedida,

2081
01:46:49,490 --> 01:46:51,900
e por suposto os levou
para concedida en perigo.

2082
01:46:51,900 --> 01:46:56,040
>> Logo analizaron o xeito no que podemos acceder
caracteres individuais nunha corda,

2083
01:46:56,040 --> 01:47:00,310
e logo, de novo tivo un nivel
mirar para as cousas, mirando como bem--

2084
01:47:00,310 --> 01:47:04,226
Se queremos chegar a nivel individual
elementos nunha lista como estrutura,

2085
01:47:04,226 --> 01:47:05,850
Non podemos facer iso con varias cadeas de caracteres?

2086
01:47:05,850 --> 01:47:08,050
E podemos con argumentos de liña de comandos.

2087
01:47:08,050 --> 01:47:12,800
Pero esta imaxe aquí só caixas
é demostrativa desta idea xeral

2088
01:47:12,800 --> 01:47:14,451
dunha matriz ou unha lista, ou un vector.

2089
01:47:14,451 --> 01:47:16,450
E, dependendo do
contexto, todas estas palabras

2090
01:47:16,450 --> 01:47:17,880
significar cousas lixeiramente diferentes.

2091
01:47:17,880 --> 01:47:20,060
Así, en C, estamos só indo
para falar sobre unha matriz.

2092
01:47:20,060 --> 01:47:23,840
E unha matriz é unha peza
da memoria, cada un dos cales é

2093
01:47:23,840 --> 01:47:27,720
elementos son contiguos, de volta,
atrás, cara atrás, cara atrás.

2094
01:47:27,720 --> 01:47:31,970
>> E eses elementos son, en xeral,
do mesmo tipo de datos, carácter,

2095
01:47:31,970 --> 01:47:35,966
carácter, carácter, personaxe ou
corda, corda, corda, corda, ou int,

2096
01:47:35,966 --> 01:47:38,600
int, int, sexa o que sexa
estamos intentando tenda.

2097
01:47:38,600 --> 01:47:42,540
Con todo, ao final do día, esta é
o que parece conceptualmente.

2098
01:47:42,540 --> 01:47:44,530
Está a ter o seu
memoria ou RAM do ordenador.

2099
01:47:44,530 --> 01:47:48,590
E está esculpindo-o para fóra en
caixas de tamaño idéntico, todos os cales

2100
01:47:48,590 --> 01:47:50,920
están de volta, para atrás, para
atrás, atrás deste xeito.

2101
01:47:50,920 --> 01:47:53,200
>> E o que é agradable sobre
esta idea, eo feito

2102
01:47:53,200 --> 01:47:58,580
que podemos expresar valores deste xeito
coa primeira das nosas estruturas de datos

2103
01:47:58,580 --> 01:48:02,520
na clase, significa que podemos comezar
para resolver problemas co código

2104
01:48:02,520 --> 01:48:04,079
que veu tan intuitivamente a semana 0.

2105
01:48:04,079 --> 01:48:05,870
Debe lembrar o teléfono
exemplo do libro, onde

2106
01:48:05,870 --> 01:48:09,110
foi utilizado un dividir e conquistar,
ou un algoritmo de procura binaria,

2107
01:48:09,110 --> 01:48:13,220
para peneirar un todo
chea de nomes e números.

2108
01:48:13,220 --> 01:48:18,220
Pero asumimos, recall, que este
libro de teléfono xa foi resolto,

2109
01:48:18,220 --> 01:48:21,630
que outra persoa xa tivo
figurado out-- dada unha lista de nomes

2110
01:48:21,630 --> 01:48:24,430
e número de como alfabetizar a eles.

2111
01:48:24,430 --> 01:48:26,950
E agora que en C que,
Tamén, ter a capacidade

2112
01:48:26,950 --> 01:48:30,290
para poñer as cousas, non
fisicamente nunha lista telefónica

2113
01:48:30,290 --> 01:48:34,220
pero practicamente nun ordenador de
memoria, poderemos a próxima semana

2114
01:48:34,220 --> 01:48:38,470
para introducir de novo a primeira o--
das nosas estruturas de datos nun array--

2115
01:48:38,470 --> 01:48:43,530
pero máis importante, ordenador real
algoritmos de ciencias aplicadas

2116
01:48:43,530 --> 01:48:47,720
no código, co cal podemos almacenar
datos en estruturas como esta,

2117
01:48:47,720 --> 01:48:50,730
e, a continuación, comezar a manipule, e
para resolver problemas, en realidade, el,

2118
01:48:50,730 --> 01:48:53,570
e construír encima diso,
en definitiva, programas en C,

2119
01:48:53,570 --> 01:48:56,730
en Python, en JavaScript,
consultar bases de datos con SQL?

2120
01:48:56,730 --> 01:48:59,980
>> E veremos que todos estes
ideas diferentes de bloqueo.

2121
01:48:59,980 --> 01:49:04,100
Pero, polo de agora, lembre que o
dominio que presentou hoxe

2122
01:49:04,100 --> 01:49:06,920
era esta cousa aquí, e
o mundo da criptografía.

2123
01:49:06,920 --> 01:49:11,200
E, entre os próximos problemas que aínda
vai resolver é a arte de cifrado,

2124
01:49:11,200 --> 01:49:13,630
codificación e de-embaralhar
información e codificación

2125
01:49:13,630 --> 01:49:15,930
e descifrar texto,
e asumindo que, en definitiva

2126
01:49:15,930 --> 01:49:18,970
que xa sabes o que
é debaixo do capó

2127
01:49:18,970 --> 01:49:21,860
de xeito que cando ve ou recibir
unha mensaxe como esta, ten

2128
01:49:21,860 --> 01:49:24,060
mesmo pode descifrar-la.

2129
01:49:24,060 --> 01:49:26,740
Todo iso, e máis a próxima vez.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [Reprodución de vídeo]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Acaba de chegar.

2133
01:49:32,970 --> 01:49:35,146
Eu estou indo a ir visita
seu profesor de universidade.

2134
01:49:35,146 --> 01:49:37,611
Yep.

2135
01:49:37,611 --> 01:49:40,080
Ola.

2136
01:49:40,080 --> 01:49:40,660
É vostede.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Agarde!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Eu só estou tentando descubrir
o que pasou con vostede.

2142
01:49:56,060 --> 01:49:58,130
Por favor, calquera cousa podería axudar.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Era a súa facultade
compañeiro de cuarto, non estaba?

2145
01:50:08,354 --> 01:50:10,770
Estaba alí con el cando
rematou o proxecto CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [Reprodución de música]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -Iso Foi CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Encántame este sitio.

2152
01:50:44,770 --> 01:50:45,854
>> -Devorar.

2153
01:50:45,854 --> 01:50:47,020
Estamos indo para fóra da empresa.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [FIN DE REPRODUCIÓN]

