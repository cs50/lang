1
00:00:00,000 --> 00:00:02,970
>> [MUZYKA]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> David J. MALAN: W porządku.

4
00:00:15,700 --> 00:00:18,832
To CS50 i to
jest początek tygodnia 2.

5
00:00:18,832 --> 00:00:21,040
I będziesz przypomnieć, że ponad
w ciągu ostatnich kilku tygodni,

6
00:00:21,040 --> 00:00:24,490
byliśmy wprowadzenie komputera
nauka i kolei, programowanie.

7
00:00:24,490 --> 00:00:27,640
>> I zaczęliśmy historię drodze
Scratch, że język graficzny

8
00:00:27,640 --> 00:00:28,990
z MIT Media Lab.

9
00:00:28,990 --> 00:00:30,780
A potem ostatnio
W zeszłym tygodniu, jak my

10
00:00:30,780 --> 00:00:34,450
wprowadzenie higher-- A
Język niższego poziomu znany

11
00:00:34,450 --> 00:00:36,770
jak C, coś, co jest czysto tekstowe.

12
00:00:36,770 --> 00:00:39,440
I rzeczywiście, ostatni raz
zbadane w tym kontekście

13
00:00:39,440 --> 00:00:40,450
szereg pojęć.

14
00:00:40,450 --> 00:00:43,010
>> To, przypomnijmy, był bardzo
Pierwszy program przyjrzeliśmy.

15
00:00:43,010 --> 00:00:45,710
A ten program, po prostu,
wypisuje "Hello, World".

16
00:00:45,710 --> 00:00:47,730
Ale jest tak wiele
pozornie magiczne dzieje.

17
00:00:47,730 --> 00:00:51,460
Jest to #include
z tych nawiasach kątowych.

18
00:00:51,460 --> 00:00:52,170
Jest int.

19
00:00:52,170 --> 00:00:53,020
Nie (void).

20
00:00:53,020 --> 00:00:56,330
Jest nawiasy, nawiasy klamrowe,
średniki, a więc znacznie więcej.

21
00:00:56,330 --> 00:00:58,480
>> A więc przypomnieć, że
wprowadziliśmy Scratch

22
00:00:58,480 --> 00:01:02,110
abyśmy mogli najlepiej, patrz przeszłość
że składnia, rzeczy, które naprawdę nie jest

23
00:01:02,110 --> 00:01:04,590
wszystko to intelektualnie
ciekawe, ale na początku

24
00:01:04,590 --> 00:01:07,700
jest absolutnie nieco kłopotliwe
owinąć wokół umysł.

25
00:01:07,700 --> 00:01:10,860
I rzeczywiście, jedną z najbardziej powszechnych
rzeczy w klasie programowania na początku,

26
00:01:10,860 --> 00:01:13,443
zwłaszcza dla tych mniej
wygodny, ma się sfrustrowany

27
00:01:13,443 --> 00:01:17,460
i wyzwolony przez pewien składniowych
Błędy nie wspominając błędy logiczne.

28
00:01:17,460 --> 00:01:19,800
I tak wśród naszych celów
Dzisiaj, w rzeczywistości, będzie

29
00:01:19,800 --> 00:01:23,280
być wyposażyć niektóre
Techniki rozwiązywania problemów na jaki

30
00:01:23,280 --> 00:01:26,705
aby lepiej rozwiązywać problemy się
w postaci debugowania.

31
00:01:26,705 --> 00:01:29,330
I będziesz przypomnieć także, że
środowisko, które wprowadziliśmy

32
00:01:29,330 --> 00:01:31,780
Ostatni raz był nazywany CS50 IDE.

33
00:01:31,780 --> 00:01:34,850
Jest to oprogramowanie oparte na sieci Web, które
umożliwia programowanie w chmurze,

34
00:01:34,850 --> 00:01:38,450
by tak rzec, zachowując wszystkie swoje
Plików razem, jak znów będzie dziś.

35
00:01:38,450 --> 00:01:41,480
I przypominam, że mamy
revisited te tematy tutaj

36
00:01:41,480 --> 00:01:44,480
wśród nich funkcje i pętle, oraz
Zmienne i wyrażenia logiczne,

37
00:01:44,480 --> 00:01:45,110
i warunki.

38
00:01:45,110 --> 00:01:49,190
A właściwie kilka bardziej, że my
tłumaczone ze świata Scratch

39
00:01:49,190 --> 00:01:50,800
w świecie C.

40
00:01:50,800 --> 00:01:53,220
>> Ale zasadnicza budowa
bloki, by tak rzec,

41
00:01:53,220 --> 00:01:55,150
były naprawdę ciągle to samo w zeszłym tygodniu.

42
00:01:55,150 --> 00:01:57,900
W rzeczywistości, tak naprawdę miał
inna kawałek układanki, jeśli będzie.

43
00:01:57,900 --> 00:02:00,300
Zamiast tego fioletowy
zapisz blok, możemy zamiast

44
00:02:00,300 --> 00:02:02,940
nie printf, który jest
Ta funkcja w C, które

45
00:02:02,940 --> 00:02:05,890
Umożliwia drukowanie coś
i sformatować ją na ekranie.

46
00:02:05,890 --> 00:02:07,950
Wprowadziliśmy CS50
Biblioteka, gdzie

47
00:02:07,950 --> 00:02:11,420
mają teraz do dyspozycji get_char,
i get_int i get_string,

48
00:02:11,420 --> 00:02:14,610
i kilka innych funkcji,
dobrze, za pomocą której można uzyskać wejście

49
00:02:14,610 --> 00:02:16,260
od użytkownika własnej klawiatury.

50
00:02:16,260 --> 00:02:20,640
I my również przyjrzał się rzeczy
jak these- bool i char,

51
00:02:20,640 --> 00:02:22,490
i double, float,
int, long_long ciąg.

52
00:02:22,490 --> 00:02:25,170
I nie ma nawet inne typy danych w C

53
00:02:25,170 --> 00:02:28,560
>> Innymi słowy, jeśli deklarują
zmienna do przechowywania jakąś wartość,

54
00:02:28,560 --> 00:02:32,600
lub podczas realizacji funkcji
która zwraca jakąś wartość,

55
00:02:32,600 --> 00:02:35,290
można określić, jakie
typ wartości, która jest.

56
00:02:35,290 --> 00:02:37,310
Czy jest ciągiem znaków, jak
ciąg znaków?

57
00:02:37,310 --> 00:02:39,490
Czy jest to liczba, jak na liczbę całkowitą?

58
00:02:39,490 --> 00:02:41,390
Czy to zmiennoprzecinkowe
Wartość lub podobne?

59
00:02:41,390 --> 00:02:46,180
Więc w C, w odróżnieniu od podstaw, tak naprawdę
zaczął określić, jakiego rodzaju dane

60
00:02:46,180 --> 00:02:48,330
wracaliśmy lub używanie.

61
00:02:48,330 --> 00:02:51,910
>> Ale, oczywiście, również wpadł
pewne fundamentalne ograniczenia informatyki.

62
00:02:51,910 --> 00:02:54,100
A w szczególności
Ten język C, przypomnijmy

63
00:02:54,100 --> 00:02:57,070
że przyjrzeliśmy się
całkowitą przepełnienie, rzeczywistość

64
00:02:57,070 --> 00:03:00,460
że jeśli masz tylko
skończoną ilość pamięci

65
00:03:00,460 --> 00:03:04,600
lub konkretnie liczbą skończoną
bitów, można liczyć tylko tak wysoko.

66
00:03:04,600 --> 00:03:08,460
I tak patrzyliśmy na ten przykład tutaj
przy czym licznik w samolocie,

67
00:03:08,460 --> 00:03:13,510
Właściwie, jeśli działa na tyle długo, by
przepełnienia i doprowadzić do oprogramowania

68
00:03:13,510 --> 00:03:15,560
rzeczywiste fizyczne potencjalny błąd.

69
00:03:15,560 --> 00:03:18,600
>> Przyglądaliśmy się także pływające
Punkt nieścisłości, rzeczywistość

70
00:03:18,600 --> 00:03:22,280
że tylko skończoną liczbą
bitów, czy jest to 32 lub 64,

71
00:03:22,280 --> 00:03:27,330
można określić tylko tyle numerów
po kropce dziesiętnej, po którym

72
00:03:27,330 --> 00:03:29,110
zaczynają się nieprecyzyjne.

73
00:03:29,110 --> 00:03:32,360
Tak na przykład, jedna trzecia w
Świat tu, w naszym ludzkim świecie,

74
00:03:32,360 --> 00:03:35,360
Wiemy tylko, po prostu nieskończona liczba
3S po przecinku.

75
00:03:35,360 --> 00:03:38,820
Ale komputer nie może niekoniecznie
stanowią nieskończoną liczbę numerów

76
00:03:38,820 --> 00:03:42,590
jeśli tylko pozwoli to jakiś
ograniczona ilość informacji.

77
00:03:42,590 --> 00:03:45,900
>> Więc nie tylko my się z wami wyposażyć
z większą mocą w kategoriach

78
00:03:45,900 --> 00:03:49,280
w jaki sposób można wyrazić siebie w
klawiatura w zakresie programowania,

79
00:03:49,280 --> 00:03:51,430
również ograniczone, co
rzeczywiście można zrobić.

80
00:03:51,430 --> 00:03:55,790
I rzeczywiście, błędy i błędy mogą
wynikać z tego rodzaju problemów.

81
00:03:55,790 --> 00:03:59,900
I rzeczywiście, wśród tematów dziś
będą tematy takie jak debugowania

82
00:03:59,900 --> 00:04:03,699
i rzeczywiście patrząc pod maską
w jaki zostały wprowadzone rzeczy ostatniego tygodnia

83
00:04:03,699 --> 00:04:05,490
są faktycznie realizowane
tak aby lepiej

84
00:04:05,490 --> 00:04:10,530
zrozumieć zarówno możliwości i
ograniczenia języka jak C

85
00:04:10,530 --> 00:04:14,770
>> A w rzeczywistości, będziemy obierać powrotem warstw
z najprostszych struktury danych,

86
00:04:14,770 --> 00:04:17,756
coś, co nazywa tablicą, która
Scratch dzieje się nazywać "listy".

87
00:04:17,756 --> 00:04:19,589
To trochę
różne w tym kontekście.

88
00:04:19,589 --> 00:04:23,340
A potem będziemy również wprowadzać jedną z
Pierwszy z naszych problemów specyficznych domen

89
00:04:23,340 --> 00:04:26,790
W CS50, świat
kryptografii, sztuka kodowania

90
00:04:26,790 --> 00:04:29,650
lub szyfrowania informacji, dzięki czemu
które można wysyłać grypsy

91
00:04:29,650 --> 00:04:34,520
i dekodowania grypsy
między dwiema osobami, A i B.

92
00:04:34,520 --> 00:04:37,490
>> Więc zanim przejścia
do tego nowego świata,

93
00:04:37,490 --> 00:04:42,059
spróbujmy wyposażyć niektóre
techniki, z którymi można wyeliminować

94
00:04:42,059 --> 00:04:43,850
lub zmniejszenie co najmniej niektórych
z frustracji

95
00:04:43,850 --> 00:04:46,630
że prawdopodobnie napotkał
nad samym tylko ubiegłym tygodniu.

96
00:04:46,630 --> 00:04:50,830
W rzeczywistości, przed wami są such-- niektóre
Twoje pierwsze problemy w C i kursy są,

97
00:04:50,830 --> 00:04:54,010
jeśli jesteś podobny do mnie, po raz pierwszy
spróbować wpisać się program,

98
00:04:54,010 --> 00:04:57,330
nawet jeśli myślisz logicznie
Program jest bardzo prosty,

99
00:04:57,330 --> 00:05:01,200
można bardzo dobrze uderzyć w mur, a
kompilator nie będzie współpracować.

100
00:05:01,200 --> 00:05:03,940
Wykonanie lub Clang nie będzie
rzeczywiście zrobić swoje rozkazy.

101
00:05:03,940 --> 00:05:05,450
>> I dlaczego może to być?

102
00:05:05,450 --> 00:05:07,950
Cóż, rzućmy okiem na,
być może, prosty program.

103
00:05:07,950 --> 00:05:11,190
Mam zamiar iść do przodu i zapisać to w
plik o nazwie buggy0.c umyślnie,

104
00:05:11,190 --> 00:05:13,590
bo wiem, że go
być wadliwy z wyprzedzeniem.

105
00:05:13,590 --> 00:05:17,400
Ale nie może zrozumieć, że jeśli ten
Jest to pierwszy albo drugi albo trzeci program

106
00:05:17,400 --> 00:05:18,830
że jestem naprawdę co ja.

107
00:05:18,830 --> 00:05:23,820
Więc mam zamiar iść do przodu i
wpisz się, int main (void).

108
00:05:23,820 --> 00:05:28,130
A potem wewnątrz moich nawiasy,
bardzo zaznajomiony ( "Hello, world--

109
00:05:28,130 --> 00:05:30,980
backslash, n ") - i średnik.

110
00:05:30,980 --> 00:05:32,360
>> Uratowałem plik.

111
00:05:32,360 --> 00:05:34,850
Teraz mam zamiar iść w dół
moim oknie terminala

112
00:05:34,850 --> 00:05:40,340
i rodzaj make buggy0, bo, znowu,
nazwa pliku jest dziś buggy0.c.

113
00:05:40,340 --> 00:05:43,660
Więc make buggy0, Enter.

114
00:05:43,660 --> 00:05:48,200
>> I, och, Boże, pamiętam z ostatniej chwili
komunikatów o błędach, które nie jest dobrą rzeczą.

115
00:05:48,200 --> 00:05:49,740
Więc nie ma wyjścia jest dobrą rzeczą.

116
00:05:49,740 --> 00:05:52,920
Ale tu mam jasno
pewna liczba błędów.

117
00:05:52,920 --> 00:05:56,470
>> Tak więc w pierwszym wierszu wyjścia
po wpisaniu dokonać buggy0, przypomnijmy,

118
00:05:56,470 --> 00:05:59,540
Wyjście jest dość rozwlekły Clang jest.

119
00:05:59,540 --> 00:06:02,067
Pod maską,
CS50 IDE jest skonfigurowany

120
00:06:02,067 --> 00:06:04,150
wykorzystać całą masę
Opcje z tym kompilator

121
00:06:04,150 --> 00:06:05,941
tak, że nie masz
myśleć o nich.

122
00:06:05,941 --> 00:06:08,840
I to wszystko, że pierwsza linia
oznacza, że ​​zaczyna się od Clang.

123
00:06:08,840 --> 00:06:11,720
>> Ale po tym, problemy
zaczynają się pojawiać.

124
00:06:11,720 --> 00:06:17,390
Buggy0.c na linii 3, charakteru
5, nie jest duży, czerwony błąd.

125
00:06:17,390 --> 00:06:18,380
Co to jest?

126
00:06:18,380 --> 00:06:23,562
Pośrednio deklarowania funkcji biblioteki
printf z typu int (const char *,

127
00:06:23,562 --> 00:06:26,050
...) [-Werror].

128
00:06:26,050 --> 00:06:28,379
Mam na myśli, to bardzo szybko
staje się bardzo zaawansowanych.

129
00:06:28,379 --> 00:06:30,170
I z pewnością, w pierwszym
oka, nie bylibyśmy

130
00:06:30,170 --> 00:06:32,380
oczekiwać, aby zrozumieć
Całość tej wiadomości.

131
00:06:32,380 --> 00:06:34,213
I tak jeden z lekcji
do dziś się dzieje

132
00:06:34,213 --> 00:06:36,919
będzie starać się zauważyć
wzory lub podobnych rzeczy,

133
00:06:36,919 --> 00:06:38,960
błędów może mieć
spotykane w przeszłości.

134
00:06:38,960 --> 00:06:41,335
Warto więc odciąć tylko
te słowa, które wyglądają znajomo.

135
00:06:41,335 --> 00:06:44,290
Duży, czerwony Błąd jest wyraźnie
symboliczne, że coś jest nie tak.

136
00:06:44,290 --> 00:06:47,940
>> pośrednio deklarowania
Biblioteka funkcji printf.

137
00:06:47,940 --> 00:06:51,680
Więc nawet jeśli nie do końca rozumiem, co
niejawnie deklarowania funkcji biblioteki

138
00:06:51,680 --> 00:06:54,900
środków, z pewnością problem
odnosi się do printf jakoś.

139
00:06:54,900 --> 00:06:59,130
A źródłem tego problemu
Ma to związek z deklarując ją.

140
00:06:59,130 --> 00:07:02,440
>> Deklarowanie funkcją jest
podając je po raz pierwszy.

141
00:07:02,440 --> 00:07:06,210
I użyliśmy terminologię w ubiegłym tygodniu
deklarowania prototypów funkcji,

142
00:07:06,210 --> 00:07:11,860
albo w jednej linii na górnej swojej
własny plik lub w tak zwanym pliku nagłówka.

143
00:07:11,860 --> 00:07:15,300
Iw jaki plik nie mówimy
w zeszłym tygodniu, że printf jest cytat,

144
00:07:15,300 --> 00:07:17,080
koniec cytatu, oświadczył?

145
00:07:17,080 --> 00:07:20,950
W jaki plik jest prototyp?

146
00:07:20,950 --> 00:07:24,640
>> Więc jeśli pamiętamy, pierwszą rzeczą I
wpisane, prawie każdy program ostatnia time--

147
00:07:24,640 --> 00:07:30,790
i przypadkowo przed chwilą rozpoczął
wpisując myself-- był ten jeden here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- dla
wejścia / output-- dot h I rzeczywiście,

149
00:07:38,630 --> 00:07:41,860
Jeśli teraz zapisać ten plik, jadę
iść do przodu i wyczyścić ekran,

150
00:07:41,860 --> 00:07:44,740
które można zrobić, wpisując
Jasne, czy można trzymać sterowania L,

151
00:07:44,740 --> 00:07:47,680
wystarczy wyczyścić okno terminala
tak aby wyeliminować niektóre bałaganu.

152
00:07:47,680 --> 00:07:51,370
>> Mam zamiar iść do przodu i
Re-make buggy0, Enter.

153
00:07:51,370 --> 00:07:53,790
I voila, wciąż widzę, że
długie polecenie od Clang,

154
00:07:53,790 --> 00:07:55,470
ale nie ma żadnego komunikatu o błędzie i tym razem.

155
00:07:55,470 --> 00:07:58,800
I rzeczywiście, jeśli to zrobię ./buggy0,
tak jak ostatnim razem,

156
00:07:58,800 --> 00:08:01,860
gdzie kropka oznacza to,
katalog, Slash oznacza po prostu,

157
00:08:01,860 --> 00:08:05,040
tu pojawia się nazwa programu i
nazwa programu jest buggy0,

158
00:08:05,040 --> 00:08:07,340
Enter "Hello, World".

159
00:08:07,340 --> 00:08:09,440
>> Teraz, jak można mieć
zaczerpniętych z tego rozwiązania

160
00:08:09,440 --> 00:08:12,017
niekoniecznie
uznawania za wiele słów

161
00:08:12,017 --> 00:08:14,350
jak ja, oczywiście, mając
zrobił to przez tyle lat?

162
00:08:14,350 --> 00:08:18,720
Dobrze, realizować za pierwszego problemu
Zestaw, wprowadzamy do polecenia

163
00:08:18,720 --> 00:08:21,175
że za własnych pracowników CS50
napisał o nazwie help50.

164
00:08:21,175 --> 00:08:24,300
I rzeczywiście, C robi specyfikacji
Problem ustawić, jak korzystać z tego.

165
00:08:24,300 --> 00:08:27,210
>> Ale help50 jest zasadniczo
program, który zespół jest CS50

166
00:08:27,210 --> 00:08:30,850
napisał, że pozwala na uruchamianie
polecenia lub uruchomić program,

167
00:08:30,850 --> 00:08:36,169
a jeśli nie rozumieją jego
Wyjście, aby przekazać swoje wyjście do help50,

168
00:08:36,169 --> 00:08:38,890
w tym momencie program
że pracownicy trakcie napisał

169
00:08:38,890 --> 00:08:42,429
będzie wyglądać na wyjściu Twojego programu
linia po linii, znak po znaku.

170
00:08:42,429 --> 00:08:46,000
A jeśli my, pracownicy, rozpoznać
Komunikat o błędzie, że jesteś doświadcza,

171
00:08:46,000 --> 00:08:50,580
postaramy się sprowokować niektóre
pytania retoryczne, z niektórych rad,

172
00:08:50,580 --> 00:08:54,890
podobnie jak TF lub CA lub siebie
zrobi osobiście w godzinach pracy urzędu.

173
00:08:54,890 --> 00:08:58,320
>> Więc spojrzeć help50 jeśli nie
muszą rozpoznać problem.

174
00:08:58,320 --> 00:09:00,790
Ale nie opierają się na nim
zbyt dużo, bo krocze.

175
00:09:00,790 --> 00:09:03,990
Oczywiście staram się zrozumieć jego
Wyjście, a następnie uczyć się od niego

176
00:09:03,990 --> 00:09:07,571
tak, że tylko raz lub dwa razy prawda
kiedykolwiek uruchomić help50 dla danego błędu

177
00:09:07,571 --> 00:09:08,070
wiadomość.

178
00:09:08,070 --> 00:09:10,660
Po tym, powinno być
lepiej wyposażone siebie

179
00:09:10,660 --> 00:09:13,180
dowiedzieć się, co jest w rzeczywistości.

180
00:09:13,180 --> 00:09:14,350
>> Zróbmy jeden inny tutaj.

181
00:09:14,350 --> 00:09:20,410
Pozwólcie mi iść do przodu, a w innym
Plik nazwijmy to buggy1.c.

182
00:09:20,410 --> 00:09:23,110
I w tym pliku jestem
zamiar deliberately--

183
00:09:23,110 --> 00:09:26,330
ale udawać, że nie wiem
zrozumieć, co zrobiłem błąd.

184
00:09:26,330 --> 00:09:31,420
>> Mam zamiar iść do przodu i robić this--
#include, odkąd

185
00:09:31,420 --> 00:09:33,660
nauczkę z przed chwilą.

186
00:09:33,660 --> 00:09:36,220
Int main (void), jak poprzednio.

187
00:09:36,220 --> 00:09:40,880
A potem tu idę
zrobić łańcuch s - get_string.

188
00:09:40,880 --> 00:09:43,770
I przypominam, że od czasu ostatniego
to znaczy, hej, komputer,

189
00:09:43,770 --> 00:09:48,280
daj mi zmiennej nazwać S i
sprawiają, że typ tej zmiennej string

190
00:09:48,280 --> 00:09:50,150
więc mogę przechowywać jeden lub więcej słów w nim.

191
00:09:50,150 --> 00:09:52,191
>> A potem po prawej ręki
stronie znaku równości

192
00:09:52,191 --> 00:09:54,980
jest get_string, który jest
Funkcja w Bibliotece CS50

193
00:09:54,980 --> 00:09:55,980
że robi dokładnie to.

194
00:09:55,980 --> 00:09:59,740
Robi się funkcji, a następnie
Ręce go od prawej do lewej.

195
00:09:59,740 --> 00:10:02,670
Więc ten znak równości nie oznacza
"Równa się", jak możemy myśleć w matematyce.

196
00:10:02,670 --> 00:10:04,750
Oznacza to zadanie od prawej do lewej.

197
00:10:04,750 --> 00:10:09,640
Więc to oznacza, wziąć ciąg znaków
użytkownik i przechowywać go wewnątrz s.

198
00:10:09,640 --> 00:10:10,460
>> Teraz użyjmy go.

199
00:10:10,460 --> 00:10:13,820
Pozwólcie mi iść do przodu i teraz jako drugi
Linia, pozwól mi iść dalej i powiedzieć "cześć" -

200
00:10:13,820 --> 00:10:19,330
nie "świat", ale "Hello,% S-
który jest naszym zastępczym, przecinek s,

201
00:10:19,330 --> 00:10:22,030
która jest naszą zmienną,
a następnie średnik.

202
00:10:22,030 --> 00:10:26,070
Więc gdybym nie zepsuć zbyt dużo
tutaj, to wygląda poprawnego kodu.

203
00:10:26,070 --> 00:10:28,090
>> A moje instynkty są teraz go skompilować.

204
00:10:28,090 --> 00:10:30,400
Plik nazywa buggy1.c.

205
00:10:30,400 --> 00:10:33,770
Więc mam zamiar robią buggy1, Enter.

206
00:10:33,770 --> 00:10:36,377
I ceruję-go, o ile nie jest
nawet więcej błędów niż wcześniej.

207
00:10:36,377 --> 00:10:38,210
Znaczy się, nie więcej
Byłoby komunikaty o błędach

208
00:10:38,210 --> 00:10:40,400
Wydaje niż rzeczywiste linie w tym programie.

209
00:10:40,400 --> 00:10:42,730
>> Ale na wynos o to,
nawet jeśli jesteś przytłoczony

210
00:10:42,730 --> 00:10:45,040
z dwoma, trzema lub
cztery kolejne komunikaty o błędach

211
00:10:45,040 --> 00:10:48,340
koncentrują się zawsze na bardzo
Pierwsza z tych wiadomości.

212
00:10:48,340 --> 00:10:52,220
Patrząc na najwyższym, drugim,
przewijanie z powrotem, jak zajdzie taka potrzeba.

213
00:10:52,220 --> 00:10:53,930
Więc tutaj Wpisałem make buggy1.

214
00:10:53,930 --> 00:10:55,700
Oto, że wyjście Clang zgodnie z oczekiwaniami.

215
00:10:55,700 --> 00:10:57,290
>> A oto pierwsza czerwona błąd.

216
00:10:57,290 --> 00:11:02,370
Korzystanie z identyfikatorem nierejestrowanej
ciąg, nie mam na myśli w standardzie?

217
00:11:02,370 --> 00:11:04,260
Więc jest standardem
faktycznie coś innego.

218
00:11:04,260 --> 00:11:06,240
To odnosi się do użytkownika
klawiatura, zasadniczo.

219
00:11:06,240 --> 00:11:08,080
>> Ale nie o to mi chodziło.

220
00:11:08,080 --> 00:11:11,770
Chodziło mi łańcuch, a mam na myśli get_string.

221
00:11:11,770 --> 00:11:16,200
Więc co to jest, że ja
zapomniałem zrobić tym razem?

222
00:11:16,200 --> 00:11:20,230
Czego brakuje tym razem?

223
00:11:20,230 --> 00:11:23,600
Mam #include,
więc mam dostęp do printf.

224
00:11:23,600 --> 00:11:26,090
>> Ale czego nie mam
dostęp do tylko jeszcze?

225
00:11:26,090 --> 00:11:29,420
Cóż, tak jak ostatnim razem,
Muszę powiedzieć, że kompilator

226
00:11:29,420 --> 00:11:31,691
Clang co te funkcje.

227
00:11:31,691 --> 00:11:33,940
Get_string nie przychodzi
C. A w szczególności,

228
00:11:33,940 --> 00:11:38,160
nie wchodzi w
nagłówku pliku.

229
00:11:38,160 --> 00:11:40,770
Zamiast tego przychodzi
coś personel napisał

230
00:11:40,770 --> 00:11:44,176
który jest inny plik
nazwę, ale trafnie nazwany.

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> Tak po prostu, dodając, że jedną linię
z code-- odwołania z ostatniej chwili

233
00:11:50,861 --> 00:11:53,610
że kiedy Clang działa, to będzie
spojrzeć na mój kod góry do dołu,

234
00:11:53,610 --> 00:11:54,193
od lewej do prawej.

235
00:11:54,193 --> 00:11:57,200
To będzie zauważyć,
Oh, chcesz.

236
00:11:57,200 --> 00:11:59,900
Pozwól mi odejść i stwierdzić, że,
tam, gdzie to jest na serwerze

237
00:11:59,900 --> 00:12:03,090
skopiuj i wklej go w istocie,
do górnej części własnego pliku

238
00:12:03,090 --> 00:12:06,820
tak, że w tym momencie w historii,
Linia 1, reszta z programu

239
00:12:06,820 --> 00:12:11,651
Można wprawdzie użyć dowolnej funkcji
w tym, między innymi get_string.

240
00:12:11,651 --> 00:12:13,650
Więc mam zamiar ignorować
reszta z tych błędów,

241
00:12:13,650 --> 00:12:17,190
Bo rzeczywiście, podejrzewam, że tylko
pierwszy z nich rzeczywiście znaczenie.

242
00:12:17,190 --> 00:12:20,780
I zamierzam iść do przodu i ponownie,
Po zapisaniu mój plik dokonać buggy1.

243
00:12:20,780 --> 00:12:22,580
I voila, to nie działa.

244
00:12:22,580 --> 00:12:29,200
A jeśli robię ./buggy1 i wpisz, na
Instancja, Zamyla, teraz dostanie cześć,

245
00:12:29,200 --> 00:12:32,000
Zamyla zamiast hello, world.

246
00:12:32,000 --> 00:12:32,550
>> W porządku.

247
00:12:32,550 --> 00:12:35,890
Więc gdy takeaways czym są,
jeden, starają się zebrać jak najwięcej jak to możliwe

248
00:12:35,890 --> 00:12:39,140
od samych komunikatów o błędach, patrząc
w niektórych rozpoznawalnych słów.

249
00:12:39,140 --> 00:12:43,070
Blokowanie to zrobić, należy help50 za
problem ustawienia specyfikacji.

250
00:12:43,070 --> 00:12:46,500
Ale zakazu to też zawsze wyglądają
w górnym błędu tylko co najmniej

251
00:12:46,500 --> 00:12:50,051
Początkowo, aby zobaczyć, jakie informacje
Może to faktycznie ustąpić.

252
00:12:50,051 --> 00:12:52,300
Ale okazuje się, istnieje
jeszcze bardziej funkcjonalność wbudowany

253
00:12:52,300 --> 00:12:55,030
do Biblioteki CS50 pomóc
Ci na początku semestru

254
00:12:55,030 --> 00:12:57,580
i na wczesnym etapie programowania
dowiedzieć się, co się dzieje źle.

255
00:12:57,580 --> 00:12:59,840
Więc zróbmy kolejny przykład.

256
00:12:59,840 --> 00:13:04,350
Idę do wywołania tej buggy2, które
znowu będzie zajmowało się

257
00:13:04,350 --> 00:13:05,650
bramy, w fazie projektowania.

258
00:13:05,650 --> 00:13:09,980
>> I zamierzam iść do przodu
i zrobić #include.

259
00:13:09,980 --> 00:13:12,580
A potem mam zamiar zrobić int main (void).

260
00:13:12,580 --> 00:13:14,840
A potem mam zamiar zrobić dla pętli.

261
00:13:14,840 --> 00:13:16,690
For (int i _ 0.

262
00:13:16,690 --> 00:13:18,750
i jest mniejsze niż lub równe 10.

263
00:13:18,750 --> 00:13:24,260
i ++, a następnie w nawiasach klamrowych, jadę
wydrukować tylko symbol hashtag tutaj

264
00:13:24,260 --> 00:13:25,920
oraz znak nowego wiersza.

265
00:13:25,920 --> 00:13:29,220
>> Więc moim zamiarem z tym
Program ten jest po prostu

266
00:13:29,220 --> 00:13:33,150
iteracyjne 10 razy
i w każdej iteracji

267
00:13:33,150 --> 00:13:35,260
tej pętli za każdym razem
przez cyklu

268
00:13:35,260 --> 00:13:37,660
wydrukować hashtag,
Hashtag, Hashtag.

269
00:13:37,660 --> 00:13:40,480
Jedna linia na bo
mają nową linię tam.

270
00:13:40,480 --> 00:13:42,787
I przypomnieć, że dla
Pętla, na ostatniej week--

271
00:13:42,787 --> 00:13:44,620
a dostaniesz więcej
zaznajomiony ze składnią

272
00:13:44,620 --> 00:13:47,170
stosując go w praktyce
Przed long-- to daje mi

273
00:13:47,170 --> 00:13:49,740
zmienna o nazwie I i ustawia go na 0.

274
00:13:49,740 --> 00:13:52,650
>> To zwiększa i na
każdej iteracji o 1.

275
00:13:52,650 --> 00:13:54,940
Tak, że przechodzi do 1 do 2 do 3.

276
00:13:54,940 --> 00:13:57,690
A potem ten warunek w
środku pomiędzy średnikami

277
00:13:57,690 --> 00:14:03,010
zostanie zaznaczona na każdej iteracji, aby
upewnić się, że nadal jesteśmy w zasięgu.

278
00:14:03,010 --> 00:14:06,830
Więc chcę iteracyjne 10 razy, więc
mają coś w rodzaju bardzo intuicyjnie prostu

279
00:14:06,830 --> 00:14:09,070
umieścić 10 jako moja górna granica nie istnieje.

280
00:14:09,070 --> 00:14:14,310
>> A jednak, gdy ten po
kompilowanie go z make buggy2--

281
00:14:14,310 --> 00:14:15,440
i to nie kompiluje OK.

282
00:14:15,440 --> 00:14:17,980
Więc nie masz
błąd składni i tym razem.

283
00:14:17,980 --> 00:14:20,940
Pozwólcie mi iść do przodu teraz
i uruchomić buggy2, Enter.

284
00:14:20,940 --> 00:14:22,620
A teraz przewijać w górę.

285
00:14:22,620 --> 00:14:24,890
I niech mi zwiększyć
wielkość okna.

286
00:14:24,890 --> 00:14:33,720
>> I wydaje się, że 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11.

287
00:14:33,720 --> 00:14:38,891
Więc jest 11 hashtags, chociaż
I wyraźnie umieścić 10 wewnątrz tej pętli.

288
00:14:38,891 --> 00:14:42,140
Teraz niektórzy z was może zobaczyć od razu
co błędów, ponieważ w istocie tę

289
00:14:42,140 --> 00:14:43,720
Nie jest to bardzo trudne do błędu.

290
00:14:43,720 --> 00:14:46,070
Ale to bardzo często
wykonane bardzo wcześnie.

291
00:14:46,070 --> 00:14:49,820
>> Co chcę podkreślić jednak,
jest, w jaki sposób mogę dowiedzieć się tego?

292
00:14:49,820 --> 00:14:52,300
Cóż, okazuje się, że
Biblioteka CS50 przychodzi

293
00:14:52,300 --> 00:14:55,380
ze nie tylko get_string i get_int
i get_float i inne funkcje.

294
00:14:55,380 --> 00:14:59,980
Jest również wyposażony w specjalną funkcję
nazywa eprintf, lub błędu printf.

295
00:14:59,980 --> 00:15:03,270
I istnieje wyłącznie w celu dokonania
to trochę łatwiejsze dla Ciebie

296
00:15:03,270 --> 00:15:06,310
podczas debugowania kodu po prostu
wydrukować komunikat o błędzie na ekranie

297
00:15:06,310 --> 00:15:07,850
i wiedzieć, skąd pochodzi.

298
00:15:07,850 --> 00:15:11,000
>> Tak na przykład, jedno mógłbym
tu zrobić z tą funkcją jest this--

299
00:15:11,000 --> 00:15:20,230
eprintf, a potem mam zamiar iść do przodu
i powiedzieć, że jest teraz% i, odwrotny ukośnik, n.

300
00:15:20,230 --> 00:15:22,330
I mam zamiar podłączyć wartości i.

301
00:15:22,330 --> 00:15:25,400
I aż górze, bo to
Jest w Bibliotece CS50,

302
00:15:25,400 --> 00:15:27,580
Mam zamiar iść do przodu
i obejmują

303
00:15:27,580 --> 00:15:29,169
więc mam dostęp do tej funkcji.

304
00:15:29,169 --> 00:15:31,460
Ale rozważmy, co linia
9 ma robić.

305
00:15:31,460 --> 00:15:32,670
Mam zamiar usunąć ten ostatecznie.

306
00:15:32,670 --> 00:15:34,670
To nie ma nic wspólnego
z moim nadrzędnym celem.

307
00:15:34,670 --> 00:15:39,090
Ale eprintf, błąd printf, jest po prostu oznaczało
dać mi jakieś informacje diagnostyczne.

308
00:15:39,090 --> 00:15:42,460
Kiedy uruchomić mój program, chcę
zobacz na ekranie czasowo

309
00:15:42,460 --> 00:15:44,550
równie dobrze zrozumieć
co się dzieje.

310
00:15:44,550 --> 00:15:47,330
>> I rzeczywiście, na każdym
iteracja tu linii 9

311
00:15:47,330 --> 00:15:49,260
Chcę zobaczyć, co jest wartością I?

312
00:15:49,260 --> 00:15:50,290
Jaka jest wartość i?

313
00:15:50,290 --> 00:15:51,280
Jaka jest wartość i?

314
00:15:51,280 --> 00:15:55,650
I miejmy nadzieję, że powinienem tylko
zobaczyć, że wiadomość, również 10 razy.

315
00:15:55,650 --> 00:15:57,780
>> Więc pozwól mi iść do przodu i
skompilować mój program,

316
00:15:57,780 --> 00:15:59,905
jak mam to zrobić w każdej chwili
I wprowadzić zmiany. ./buggy2.

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
I now-- OK.

319
00:16:03,640 --> 00:16:04,820
Jest o wiele więcej dzieje.

320
00:16:04,820 --> 00:16:07,610
Więc pozwól mi się przewijać
jeszcze większe okno.

321
00:16:07,610 --> 00:16:10,190
>> A zobaczysz, że każdy z
hashtags nadal drukuje.

322
00:16:10,190 --> 00:16:15,270
A pomiędzy każdym z nich jest to
wyjście diagnostyczne sformatowany w następujący sposób.

323
00:16:15,270 --> 00:16:17,960
Nazwa mojego programu jest tu buggy2.

324
00:16:17,960 --> 00:16:20,432
Nazwa pliku jest buggy2.c.

325
00:16:20,432 --> 00:16:24,080
Numer linii, z których
ta została wydrukowana jest linia 9.

326
00:16:24,080 --> 00:16:27,500
A następnie z prawej strony, który jest
Komunikat o błędzie, który Czekam.

327
00:16:27,500 --> 00:16:30,701
>> A co miłe jest to, że
Teraz nie muszę koniecznie liczyć

328
00:16:30,701 --> 00:16:32,200
w głowie, co mój program robi.

329
00:16:32,200 --> 00:16:34,240
Widzę, że na
Pierwsza iteracja i wynosi 0,

330
00:16:34,240 --> 00:16:39,420
Następnie 1, a następnie 2, a następnie 3, 4, a następnie, po czym
5, a 6, a 7, a 8, a 9, a następnie

331
00:16:39,420 --> 00:16:40,980
10.

332
00:16:40,980 --> 00:16:42,050
Więc chwileczkę.

333
00:16:42,050 --> 00:16:43,740
Co tu się dzieje?

334
00:16:43,740 --> 00:16:48,190
Nadal wydaje się liczy
jako przeznaczone do 10.

335
00:16:48,190 --> 00:16:50,550
>> Ale skąd mam zacząć?

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

337
00:16:53,240 --> 00:16:58,040
Tak 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11. Palec

338
00:16:58,040 --> 00:16:59,990
wskazuje problemu.

339
00:16:59,990 --> 00:17:02,850
Wydaje mi się liczyć
nieprawidłowo w moim pętli.

340
00:17:02,850 --> 00:17:06,599
Zamiast jechać 10 powtórzeń,
Zaczynam na 0,

341
00:17:06,599 --> 00:17:09,550
Ja kończąc dzień i do 10.

342
00:17:09,550 --> 00:17:12,030
Ale ponieważ, jak komputer,
Zaczynam odliczanie na 0,

343
00:17:12,030 --> 00:17:15,250
I należy się liczyć
, ale nie przez 10.

344
00:17:15,250 --> 00:17:18,510
>> A więc dylemat, w końcu
realizowane tutaj, jest jednym z dwóch miejsc.

345
00:17:18,510 --> 00:17:22,430
Mogę powiedzieć bardzo prosto
liczą się do mniej niż 10.

346
00:17:22,430 --> 00:17:27,260
Tak 0, 1, 2, 3, 4, 5, 6, 7, 8,
9, który jest rzeczywiście poprawna,

347
00:17:27,260 --> 00:17:28,900
choć brzmi to trochę źle.

348
00:17:28,900 --> 00:17:35,070
Albo można zrobić mniejsze lub równe
9, tak długo, jak tylko rozpocznie się 0.

349
00:17:35,070 --> 00:17:40,056
A jeśli naprawdę nie podoba, że ​​cię
może liczyć do 10, ale zaczynają się od 1.

350
00:17:40,056 --> 00:17:41,680
Ale znowu, to po prostu nie jest tak powszechne.

351
00:17:41,680 --> 00:17:43,977
W programming-- aczkolwiek
nie tyle w Scratch--

352
00:17:43,977 --> 00:17:45,810
ale w programowaniu w
C i innych języków,

353
00:17:45,810 --> 00:17:47,670
jak JavaScript i
Python i inni, to

354
00:17:47,670 --> 00:17:49,880
po prostu bardzo często
Nasza dyskusja binarny

355
00:17:49,880 --> 00:17:53,450
po prostu rozpocząć liczenie u
Najmniej można, czyli 0.

356
00:17:53,450 --> 00:17:53,950
W porządku.

357
00:17:53,950 --> 00:17:55,160
Więc to eprintf.

358
00:17:55,160 --> 00:17:58,600
I znowu, teraz, kiedy zorientowali się, moim
problem i mam zamiar wrócić do 0

359
00:17:58,600 --> 00:18:01,470
przez mniej niż 10, jadę
wejść i usuwać eprintf.

360
00:18:01,470 --> 00:18:04,580
>> To nie powinno być tam, kiedy
Wysyłam mój kod lub prześlij mój kod

361
00:18:04,580 --> 00:18:05,800
lub pokazać go nikomu innemu.

362
00:18:05,800 --> 00:18:07,980
To tak naprawdę oznaczało
być stosowane chwilowo.

363
00:18:07,980 --> 00:18:11,650
Ale teraz Naprawiłem to
Szczególnym problemem, jak również.

364
00:18:11,650 --> 00:18:16,780
>> Dobrze, zróbmy jeszcze jeden przykład tutaj
że będę wzbudzać w następujący sposób.

365
00:18:16,780 --> 00:18:22,850
Mam zamiar iść do przodu i
#zawierać . $ 50

366
00:18:22,850 --> 00:18:25,580
I zamierzam iść do przodu
oraz #include.

367
00:18:25,580 --> 00:18:29,030
>> I mam zamiar zapisać
ten plik jako buggy3.c.

368
00:18:29,030 --> 00:18:31,740
I zamierzam iść do przodu
i zadeklarować int main (void).

369
00:18:31,740 --> 00:18:34,186
A potem wewnątrz istnieje
Idę zrobić int I _ -

370
00:18:34,186 --> 00:18:36,435
Chcę wdrożyć program
z get_negative_int.

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
To nie jest funkcja, która jeszcze nie istnieje.

373
00:18:40,770 --> 00:18:42,870
Więc mamy zamiar wdrożyć
to za chwilę.

374
00:18:42,870 --> 00:18:45,541
Ale mamy zamiar zobaczyć, dlaczego
to buggy w pierwszym przejeździe.

375
00:18:45,541 --> 00:18:47,290
A kiedy stałam
int od użytkownika,

376
00:18:47,290 --> 00:18:53,365
Idę do wydrukowania% i jest ujemna
całkowitą, backslash, n, przecinek, i.

377
00:18:53,365 --> 00:18:55,240
Innymi słowy, wszystkie I
chce zrobić ten program

378
00:18:55,240 --> 00:18:58,000
jest dostać negatywną z int
użytkownik, a następnie wydrukować

379
00:18:58,000 --> 00:18:59,980
że taki a taki jest negatywnym int.

380
00:18:59,980 --> 00:19:02,080
>> Teraz trzeba zaimplementować tę funkcję.

381
00:19:02,080 --> 00:19:05,740
Dlatego w dalszej części mojego pliku, mam zamiar iść
naprzód i zadeklarować funkcję o nazwie

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - i będziemy
wrócić do tego, co oznacza, że ​​linia ponownie

383
00:19:10,670 --> 00:19:18,790
w moment-- int n; Do do--
following-- printf n :.

384
00:19:18,790 --> 00:19:26,210
A potem zrobię N - get_int,
i zrobić to, gdy n jest większe niż 0.

385
00:19:26,210 --> 00:19:28,310
A potem wrócić n ;.

386
00:19:28,310 --> 00:19:31,730
>> Więc jest dużo dzieje się w
tego, ale żaden z którego nie

387
00:19:31,730 --> 00:19:33,710
spojrzeć na ostatni tydzień, przynajmniej na chwilę.

388
00:19:33,710 --> 00:19:36,980
Więc on line 10 tutaj mam uznany za
Funkcja o nazwie get_negative_int,

389
00:19:36,980 --> 00:19:39,620
a ja umieścić (void), w
nawiasy, powodem jest to

390
00:19:39,620 --> 00:19:40,950
nie bierze wejście.

391
00:19:40,950 --> 00:19:42,910
Nie mam nic przekazując
do tej funkcji.

392
00:19:42,910 --> 00:19:44,690
Jestem po prostu coraz coś w zamian od niego.

393
00:19:44,690 --> 00:19:47,270
>> I co mam nadzieję
wrócić jest liczbą całkowitą.

394
00:19:47,270 --> 00:19:50,040
Nie ma typ danych w
C nazywa negative_int.

395
00:19:50,040 --> 00:19:52,880
To tylko int, więc to się dzieje
być na nas, aby upewnić się,

396
00:19:52,880 --> 00:19:55,340
że wartość to rzeczywiście
Zwrot jest nie tylko int

397
00:19:55,340 --> 00:19:56,380
lecz również ujemny.

398
00:19:56,380 --> 00:20:02,150
>> W linii 12 Jestem deklarując zmienną
nazywany n i czyni go typu int.

399
00:20:02,150 --> 00:20:07,500
A następnie w wierszu 13 do 18 jestem
robić coś gdy coś jest prawdą.

400
00:20:07,500 --> 00:20:11,040
Idę do przodu i drukowanie
n jest, okrężnicy, a następnie przestrzeń

401
00:20:11,040 --> 00:20:12,800
jak zachęty dla użytkownika.

402
00:20:12,800 --> 00:20:16,410
>> Ja i następnie wywołanie get_int
przechowywanie jej tzw wartości zwracanej

403
00:20:16,410 --> 00:20:18,130
w tej zmiennej n.

404
00:20:18,130 --> 00:20:22,600
Ale mam zamiar dalej robić
Ten gdy n jest większe niż 0.

405
00:20:22,600 --> 00:20:27,960
Innymi słowy, gdy użytkownik podaje mi
Int i ta liczba jest większa niż 0 ° C,

406
00:20:27,960 --> 00:20:31,180
ergo, pozytywny, będę
po prostu zachować reprompting użytkownika,

407
00:20:31,180 --> 00:20:37,160
utrzymać reprompting, zmuszając ich do
współpracować i dać mi negatywny int.

408
00:20:37,160 --> 00:20:41,640
>> I po raz n jest rzeczywiście negative--
Przypuszczam użytkownikowi wreszcie rodzaje -50,

409
00:20:41,640 --> 00:20:46,710
Następnie ta pętla nie jest już prawdą
-50 ponieważ nie jest większy niż 0 ° C.

410
00:20:46,710 --> 00:20:51,140
Więc z tego wyrwać
Pętla logicznie i powrócić n.

411
00:20:51,140 --> 00:20:53,520
>> Ale jest jeszcze jedna
co mam zrobić.

412
00:20:53,520 --> 00:20:56,190
I może po prostu to zrobić
poprzez kopiowanie i wklejanie

413
00:20:56,190 --> 00:20:58,540
jednej linii kodu na początku pliku.

414
00:20:58,540 --> 00:21:01,630
Muszę nauczyć brzękiem,
lub obiecują brzękiem,

415
00:21:01,630 --> 00:21:04,630
wyraźnie, że będę,
Rzeczywiście, idź i wdrożenia

416
00:21:04,630 --> 00:21:06,020
Ta funkcja get_negative_int.

417
00:21:06,020 --> 00:21:07,674
Może to być po prostu niższe w pliku.

418
00:21:07,674 --> 00:21:09,840
Ponownie przypominam, że Clang
czyta wszystko od góry do dołu,

419
00:21:09,840 --> 00:21:12,330
od lewej do prawej, więc nie można
wywołać funkcję, jeśli Clang

420
00:21:12,330 --> 00:21:15,330
nie wie, że będzie istnieć.

421
00:21:15,330 --> 00:21:18,430
>> Teraz, niestety, ten program,
jak niektórzy z was zauważyli,

422
00:21:18,430 --> 00:21:19,590
już jest wadliwy.

423
00:21:19,590 --> 00:21:21,400
Pozwólcie mi iść do przodu i zrobić buggy3.

424
00:21:21,400 --> 00:21:26,904
Kompiluje, więc mój problem teraz, nie jest
błąd składni, jak błędu tekstowej,

425
00:21:26,904 --> 00:21:29,570
to faktycznie będzie to logiczne
Błąd, który mam celowo

426
00:21:29,570 --> 00:21:32,450
wykonane jako okazję do
krok po kroku, co się dzieje.

427
00:21:32,450 --> 00:21:35,540
>> Mam zamiar iść do przodu
teraz i uruchomić buggy3.

428
00:21:35,540 --> 00:21:37,490
I zamierzam iść
do przodu i nie współpracują.

429
00:21:37,490 --> 00:21:39,494
Mam zamiar dać mu numer 1.

430
00:21:39,494 --> 00:21:41,410
To nie podobało się to, więc
to skłoniło mnie ponownie.

431
00:21:41,410 --> 00:21:42,147
>> Jak o 2?

432
00:21:42,147 --> 00:21:43,021
3?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
Żaden z nich pracują.

435
00:21:44,740 --> 00:21:46,890
Jak o -50?

436
00:21:46,890 --> 00:21:48,560
I program wydaje się działać.

437
00:21:48,560 --> 00:21:49,970
>> Pozwól mi spróbować jeszcze raz.

438
00:21:49,970 --> 00:21:53,400
Pozwól mi spróbować -1, wydaje się działać.

439
00:21:53,400 --> 00:21:56,380
Pozwól mi spróbować -2 wydaje się działać.

440
00:21:56,380 --> 00:21:59,640
Pozwól mi spróbować 0.

441
00:21:59,640 --> 00:22:01,684
Huh, to jest błędne.

442
00:22:01,684 --> 00:22:03,350
Teraz jesteśmy tutaj jest trochę pedantyczny.

443
00:22:03,350 --> 00:22:07,090
Ale to rzeczywiście jest tak, że 0
nie jest ani pozytywne, ani negatywne.

444
00:22:07,090 --> 00:22:11,150
A więc fakt, że mój program jest
mówiąc, że 0 jest ujemną liczbą całkowitą,

445
00:22:11,150 --> 00:22:12,820
to nie jest technicznie poprawne.

446
00:22:12,820 --> 00:22:15,180
>> Teraz, dlaczego jest on to robi?

447
00:22:15,180 --> 00:22:16,270
Cóż, może to być oczywiste.

448
00:22:16,270 --> 00:22:18,110
I rzeczywiście, program jest
miało być dość proste

449
00:22:18,110 --> 00:22:19,670
więc mamy coś do zbadania.

450
00:22:19,670 --> 00:22:25,870
>> Ale niech wprowadzi trzeci debugowanie
Technika tutaj nazywa debug50.

451
00:22:25,870 --> 00:22:27,750
Więc jest to program
że właśnie stworzył

452
00:22:27,750 --> 00:22:30,770
W tym roku o nazwie debug50
że pozwolisz

453
00:22:30,770 --> 00:22:34,130
w użyciu, co nazywa wbudowany
Graficzny debugger w CS50 IDE.

454
00:22:34,130 --> 00:22:38,400
A debugger jest tylko program, który
generalnie pozwala uruchomić program

455
00:22:38,400 --> 00:22:44,050
ale krok po krok po kroku, zgodnie
przez linia po linii, zatrzymując się, szturchając

456
00:22:44,050 --> 00:22:47,626
wokół, patrząc na zmienne tak, że
Program nie tylko dmuchać obok ciebie

457
00:22:47,626 --> 00:22:49,750
i szybko wydrukować coś
czy nie wydrukować coś.

458
00:22:49,750 --> 00:22:53,250
To daje szansę na
Prędkość ludzką, do interakcji z nim.

459
00:22:53,250 --> 00:22:55,470
>> I żeby to zrobić,
wystarczy wykonać następujące czynności.

460
00:22:55,470 --> 00:22:58,479
Po kompilacji kodu,
który już zrobił, buggy3,

461
00:22:58,479 --> 00:23:00,020
śmiało uruchomić debug50 ./buggy.

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
Więc podobnie help50 ma uruchomić
help50 a następnie polecenie,

464
00:23:06,760 --> 00:23:10,120
debug50 ma uruchomić debug50 i
następnie nazwę polecenia.

465
00:23:10,120 --> 00:23:14,440
>> Teraz obserwować co się dzieje na ekranie,
z prawej strony, w szczególności.

466
00:23:14,440 --> 00:23:19,400
Kiedy uderzył Uruchom, wszystkie
Panel ten nagły prawostronnego

467
00:23:19,400 --> 00:23:20,419
otwiera się na ekranie.

468
00:23:20,419 --> 00:23:22,210
I nie ma dużo się dzieje
on na pierwszy rzut oka.

469
00:23:22,210 --> 00:23:25,110
Ale nie jest zbyt
dużo się martwić o jeszcze.

470
00:23:25,110 --> 00:23:28,570
>> To pokazuje mi wszystko
że dzieje się wewnątrz mojego programu

471
00:23:28,570 --> 00:23:31,130
już teraz, a poprzez nich
Przyciski do góry następnie

472
00:23:31,130 --> 00:23:35,910
pozwalając mi przejść przez mojego kodu
ostatecznie krok po kroku po kroku.

473
00:23:35,910 --> 00:23:37,140
Ale jeszcze nie teraz.

474
00:23:37,140 --> 00:23:38,060
Zauważ, co się dzieje.

475
00:23:38,060 --> 00:23:40,600
W moim oknie terminala
Jestem potwierdzeniu przez n.

476
00:23:40,600 --> 00:23:44,560
I zamierzam iść do przodu i
Tym razem współpracować i wpisać -1.

477
00:23:44,560 --> 00:23:48,770
I choć trochę tajemniczo, -1
jest ujemna, zgodnie z oczekiwaniami.

478
00:23:48,770 --> 00:23:52,020
>> A potem wyszła z dzieckiem
Stan 0 GDBserver wyjściu.

479
00:23:52,020 --> 00:23:55,180
GDB, GNU Debugger, to nazwa
oprogramowania bazowego

480
00:23:55,180 --> 00:23:56,620
który implementuje ten debugger.

481
00:23:56,620 --> 00:24:00,500
Ale wszystko to naprawdę oznacza, debugger
odszedł, ponieważ mój program zamknąć

482
00:24:00,500 --> 00:24:01,710
i wszystko było dobrze.

483
00:24:01,710 --> 00:24:06,020
Jeśli chcę, żeby naprawdę debugowania mój program,
Muszę powiedzieć debug50 zapobiegawczo,

484
00:24:06,020 --> 00:24:08,920
gdzie chcę, aby rozpocząć
Krokowe mojego kodu?

485
00:24:08,920 --> 00:24:11,750
>> A może najprostszym sposobem
zrobić to w następujący sposób.

486
00:24:11,750 --> 00:24:15,300
Gdybym unoszą się nad
Rynna mojego edytora tutaj

487
00:24:15,300 --> 00:24:19,090
tak naprawdę tylko na pasku bocznym tu
na lewo od liczby linii,

488
00:24:19,090 --> 00:24:21,870
Zauważ, że jeśli po prostu kliknij
raz, kładę małą czerwoną kropkę.

489
00:24:21,870 --> 00:24:24,460
I ta mała czerwona kropka,
jak znak stopu, co oznacza, hej,

490
00:24:24,460 --> 00:24:29,430
debug50, wykonanie pauza mojego kodu
właśnie tam, kiedy uruchomić ten program.

491
00:24:29,430 --> 00:24:30,260
>> Więc zróbmy to.

492
00:24:30,260 --> 00:24:37,340
Pozwólcie mi iść do przodu i uruchomić swój program
dzięki debug50 ./buggy3, Enter.

493
00:24:37,340 --> 00:24:40,110
A teraz, informacja, coś
różni się stało.

494
00:24:40,110 --> 00:24:42,440
Nie mam potwierdzeniu
jeszcze w moim oknie terminala

495
00:24:42,440 --> 00:24:45,430
do niczego, bo nie mają
zdobyć tam jeszcze w moim programie.

496
00:24:45,430 --> 00:24:47,950
Zauważ, że na linii 8
który jest podświetlony,

497
00:24:47,950 --> 00:24:51,720
i tam jest mała strzałka na
lewa powiedzenie, jesteś zatrzymał się tutaj.

498
00:24:51,720 --> 00:24:55,030
Ta linia kodu, linii
8, nie została jeszcze wykonana.

499
00:24:55,030 --> 00:24:58,940
>> I co ciekawe, kiedy patrzę
tu na prawej stronie,

500
00:24:58,940 --> 00:25:03,530
Zauważ, że jest lokalnym
zmienną lokalną w tym sensie

501
00:25:03,530 --> 00:25:05,450
że jest w środku obecnej funkcji.

502
00:25:05,450 --> 00:25:08,920
A jego wartość, najwyraźniej domyślnie
oraz rodzaj wygodnie jest 0.

503
00:25:08,920 --> 00:25:10,260
Ale nie wpisać 0.

504
00:25:10,260 --> 00:25:13,410
To się po prostu dzieje się za jego
Domyślna wartość w tej chwili.

505
00:25:13,410 --> 00:25:15,490
>> Więc pozwól mi iść do przodu i zrobić to teraz.

506
00:25:15,490 --> 00:25:18,680
Pozwólcie mi iść do przodu i na
prawy górny tu jestem

507
00:25:18,680 --> 00:25:20,970
zamiar iść do przodu i
kliknij tę ikonę, która pierwszy

508
00:25:20,970 --> 00:25:25,360
oznacza etap, na którym nie oznacza pominięcia
to jednak krok na tej linii kodu,

509
00:25:25,360 --> 00:25:27,770
wykonując go po drodze.

510
00:25:27,770 --> 00:25:30,710
>> A teraz zauważyć, mój
szybka właśnie się zmienił.

511
00:25:30,710 --> 00:25:31,380
Dlaczego?

512
00:25:31,380 --> 00:25:33,639
Mówiłem debug50,
uruchomienia tej linii kodu.

513
00:25:33,639 --> 00:25:34,930
Co to linia kodu zrobić?

514
00:25:34,930 --> 00:25:35,960
Skłania mnie do wew.

515
00:25:35,960 --> 00:25:36,460
OK.

516
00:25:36,460 --> 00:25:37,400
Pozwól mi współpracować.

517
00:25:37,400 --> 00:25:41,340
Pozwólcie mi iść do przodu i teraz wpisać -1, Enter.

518
00:25:41,340 --> 00:25:42,920
A teraz zauważyć, co się zmieniło.

519
00:25:42,920 --> 00:25:46,060
Po prawej stronie,
moja lokalna zmienna i

520
00:25:46,060 --> 00:25:48,200
jest oznaczony jako -1 się.

521
00:25:48,200 --> 00:25:49,810
I to jest nadal typu int.

522
00:25:49,810 --> 00:25:53,102
>> A informacja, zbyt, mój tak zwany
zadzwoń stos, gdzie się wstrzymać?

523
00:25:53,102 --> 00:25:54,810
Porozmawiamy więcej o
to w przyszłości.

524
00:25:54,810 --> 00:25:58,620
Ale stos wywołań po prostu odnosi się do tego, co
funkcje są obecnie w ruchu.

525
00:25:58,620 --> 00:26:00,040
Teraz to tylko główne.

526
00:26:00,040 --> 00:26:03,590
A teraz tylko lokalne
zmienna jest I o wartości 1.

527
00:26:03,590 --> 00:26:09,840
>> A kiedy w końcu krok na tej linii
tutaj, z tej samej ikony w prawym górnym rogu,

528
00:26:09,840 --> 00:26:11,410
-1 Jest ujemna.

529
00:26:11,410 --> 00:26:13,580
Teraz jest zatrzymując nad tym nawias klamrowy.

530
00:26:13,580 --> 00:26:14,740
Pozwólmy to, co robi.

531
00:26:14,740 --> 00:26:17,300
I krok na tej linii, i voila.

532
00:26:17,300 --> 00:26:20,240
>> Więc wcale nie tak strasznie
pouczające jeszcze

533
00:26:20,240 --> 00:26:23,550
ale nie pozwól mi wstrzymać
i myśleć logicznie przez

534
00:26:23,550 --> 00:26:24,870
co ten program robi.

535
00:26:24,870 --> 00:26:26,890
Ale to nie był przypadek błędne.

536
00:26:26,890 --> 00:26:28,510
Zróbmy to ponownie w następujący sposób.

537
00:26:28,510 --> 00:26:31,340
>> Idę do opuszczenia tego przerwania
linii nr 8 z czerwoną kropką.

538
00:26:31,340 --> 00:26:32,830
Idę powtórzona debug50.

539
00:26:32,830 --> 00:26:34,400
To automatycznie wstrzymane tutaj.

540
00:26:34,400 --> 00:26:37,660
Ale tym razem, zamiast
depcząc po tej linii,

541
00:26:37,660 --> 00:26:42,290
pozwól, że faktycznie go wewnątrz
get_negative_int i dowiedzieć się,

542
00:26:42,290 --> 00:26:45,530
dlaczego jest przyjmowanie 0 jako ważnego odpowiedź?

543
00:26:45,530 --> 00:26:47,990
>> Więc zamiast klikania Step Over.

544
00:26:47,990 --> 00:26:50,630
Mam zamiar iść do przodu
i kliknij przycisk Step Into.

545
00:26:50,630 --> 00:26:54,030
I zauważyć, że linia 8 to
podświetlony teraz nagle

546
00:26:54,030 --> 00:26:56,900
staje się linia 17.

547
00:26:56,900 --> 00:26:59,947
>> Teraz to nie jest takie debuggera
został pominięty linie 14 i 15 oraz 16.

548
00:26:59,947 --> 00:27:01,780
To po prostu nie ma nic
pokazać wam tam.

549
00:27:01,780 --> 00:27:04,050
To są po prostu deklarowania zmiennych,
I jeszcze słowo uwagi

550
00:27:04,050 --> 00:27:05,390
a następnie otwarty nawias klamrowy.

551
00:27:05,390 --> 00:27:09,227
Jedyna linia to funkcjonalna
soczyste naprawdę jest ten tu 17.

552
00:27:09,227 --> 00:27:11,060
I w tym miejscu mamy
Zatrzymał się automatycznie.

553
00:27:11,060 --> 00:27:13,870
>> Więc printf ( "n.is:") ;, tak
który jeszcze nie zdarzyło.

554
00:27:13,870 --> 00:27:18,250
Więc idź naprzód i kliknij Step Over.

555
00:27:18,250 --> 00:27:20,326
Teraz moja szybka, rzeczywiście,
zmienia się ( "n").

556
00:27:20,326 --> 00:27:22,450
Teraz get_int, ja nie zamierzam
niepokoić wkraczającego,

557
00:27:22,450 --> 00:27:24,750
ponieważ ta funkcja była
przez CS50 w bibliotece.

558
00:27:24,750 --> 00:27:25,750
To prawdopodobnie poprawne.

559
00:27:25,750 --> 00:27:28,440
>> Więc mam zamiar iść do przodu i
rodzaj współpracy poprzez nadanie mu

560
00:27:28,440 --> 00:27:30,590
int, ale nie negatywny int.

561
00:27:30,590 --> 00:27:32,870
Więc pozwól mi iść do przodu i uderzył 0.

562
00:27:32,870 --> 00:27:39,460
A teraz co się dzieje tutaj
kiedy się w dół do linii 21?

563
00:27:39,460 --> 00:27:40,890
I już nie raz powtórzyć.

564
00:27:40,890 --> 00:27:43,320
I nie wydają się być zatrzymany w tej pętli.

565
00:27:43,320 --> 00:27:45,990
Innymi słowy, żółty
Pasek nie poddawać się dokoła,

566
00:27:45,990 --> 00:27:47,130
i dookoła i dookoła.

567
00:27:47,130 --> 00:27:48,340
>> Teraz, dlaczego tak jest?

568
00:27:48,340 --> 00:27:49,920
Dobrze, n, co oznacza N teraz?

569
00:27:49,920 --> 00:27:53,280
Mogę patrzeć na lokalne
Zmienne w debuggera.

570
00:27:53,280 --> 00:27:53,816
n oznacza 0.

571
00:27:53,816 --> 00:27:55,190
Wszystko w porządku, jaki był mój stan?

572
00:27:55,190 --> 00:27:58,700
>> 20-- Linia 20 jest dobrze,
0 jest większy niż 0 ° C.

573
00:27:58,700 --> 00:27:59,500
To nie jest prawda.

574
00:27:59,500 --> 00:28:01,020
0 nie jest większy niż 0 ° C.

575
00:28:01,020 --> 00:28:02,820
I tak wybuchła z tego.

576
00:28:02,820 --> 00:28:06,370
>> A więc dlatego on line
21, jeśli rzeczywiście w dalszym ciągu,

577
00:28:06,370 --> 00:28:10,370
Zamierzam powrócić 0, nawet
choć powinienem odrzucić 0

578
00:28:10,370 --> 00:28:12,484
w rzeczywistości nie jest negatywna.

579
00:28:12,484 --> 00:28:14,650
Więc teraz, nie wiem tak naprawdę, nawet
dbają o debugger.

580
00:28:14,650 --> 00:28:16,900
Got to, że nie trzeba
wiem co dalej się dzieje.

581
00:28:16,900 --> 00:28:19,233
>> Więc mam zamiar iść do przodu i
wystarczy kliknąć przycisk odtwarzania,

582
00:28:19,233 --> 00:28:20,240
i niech to skończyć.

583
00:28:20,240 --> 00:28:23,440
Teraz zdałem sobie sprawę, że mój
Błąd jest najwyraźniej na linii 20.

584
00:28:23,440 --> 00:28:25,160
To mój błąd logiczny.

585
00:28:25,160 --> 00:28:28,100
>> A więc to, co chcę
zrobić, aby to zmienić?

586
00:28:28,100 --> 00:28:32,500
Jeśli problem jest to, że nie jestem
łowienie 0, to po prostu błąd logiczny.

587
00:28:32,500 --> 00:28:35,910
I mogę powiedzieć, gdy n jest
większa niż lub równa 0,

588
00:28:35,910 --> 00:28:38,330
utrzymać kółko monitowania użytkownika.

589
00:28:38,330 --> 00:28:41,050
>> Więc znowu, prosty błąd, być może
nawet oczywiste, gdy widziałeś mnie

590
00:28:41,050 --> 00:28:42,410
zapisz go zaledwie kilka minut temu.

591
00:28:42,410 --> 00:28:44,570
Ale tu na wynos
Jest to z debugowania 50,

592
00:28:44,570 --> 00:28:46,850
i debugowania
Oprogramowanie bardziej ogólnie,

593
00:28:46,850 --> 00:28:51,370
masz tego nowego znaleźć zasilanie
przejść przez swój własny kod, wygląd

594
00:28:51,370 --> 00:28:55,590
za pośrednictwem tej strony, co prawego panelu
Twoje wartości są zmienne.

595
00:28:55,590 --> 00:28:57,700
Więc nie koniecznie
trzeba użyć czegoś

596
00:28:57,700 --> 00:29:00,630
jakbyś eprintf wydrukować te wartości.

597
00:29:00,630 --> 00:29:04,430
rzeczywiście można je zobaczyć
wizualnie na ekranie.

598
00:29:04,430 --> 00:29:08,920
>> Teraz, poza tym, warto zauważyć,
że istnieje inna metoda to

599
00:29:08,920 --> 00:29:09,890
faktycznie bardzo powszechne.

600
00:29:09,890 --> 00:29:13,120
I można się zastanawiać, dlaczego ten mały
Facet został tu siedzi na scenie.

601
00:29:13,120 --> 00:29:16,490
Więc jest ta technika, na ogół
znana jako metoda gumowej kaczuszki,

602
00:29:16,490 --> 00:29:18,786
co naprawdę jest po prostu
świadectwem faktu

603
00:29:18,786 --> 00:29:20,660
że często, gdy programiści
pisania kodu,

604
00:29:20,660 --> 00:29:22,650
oni nie muszą
współpracując z innymi,

605
00:29:22,650 --> 00:29:24,030
lub pracuje w środowisku współdzielonym.

606
00:29:24,030 --> 00:29:25,050
>> Są jakby w domu.

607
00:29:25,050 --> 00:29:25,910
Może to późno w nocy.

608
00:29:25,910 --> 00:29:28,190
Próbują rysunku
z pewnym błędem w kodzie.

609
00:29:28,190 --> 00:29:29,330
A oni po prostu nie widząc go.

610
00:29:29,330 --> 00:29:30,329
>> I nie ma współlokatora.

611
00:29:30,329 --> 00:29:31,250
Nie ma TF.

612
00:29:31,250 --> 00:29:32,680
Nie ma CA się.

613
00:29:32,680 --> 00:29:36,440
Wszystkie mają na swojej półce
Jest to małe Rubber Ducky.

614
00:29:36,440 --> 00:29:39,030
>> I tak metoda gumowej kaczuszki
jest tylko to zaproszenie

615
00:29:39,030 --> 00:29:42,780
myśleć o czymś tak głupim
ponieważ jako prawdziwe istoty,

616
00:29:42,780 --> 00:29:46,940
i rzeczywiście chodzić po kodzie
ustnie do tego martwego przedmiotu.

617
00:29:46,940 --> 00:29:49,230
Tak więc, na przykład, jeśli
to jest mój przykład here--

618
00:29:49,230 --> 00:29:52,470
i przypomnieć, że wcześniej
Problem był w tym,

619
00:29:52,470 --> 00:29:58,140
jeśli usunę tę pierwszą linię kodu,
i idę do przodu i zrobić buggy 0 raz

620
00:29:58,140 --> 00:30:01,220
Przypomnijmy, że miałem je
komunikaty o błędach tutaj.

621
00:30:01,220 --> 00:30:05,997
Tak więc idea tu śmieszne choć
czuję w tej chwili robi to publicznie,

622
00:30:05,997 --> 00:30:06,580
jest to błąd.

623
00:30:06,580 --> 00:30:10,910
>> OK, więc mój problem jest, że mam
niejawnie zadeklarowana funkcję biblioteki.

624
00:30:10,910 --> 00:30:12,610
I to jest funkcja biblioteki printf.

625
00:30:12,610 --> 00:30:15,290
Declare-- OK, oświadczam
Przypomina mi prototypów.

626
00:30:15,290 --> 00:30:18,930
>> Oznacza to, że muszę naprawdę
poinformować kompilator, co z góry

627
00:30:18,930 --> 00:30:19,980
funkcja wygląda.

628
00:30:19,980 --> 00:30:20,930
Poczekaj chwilę.

629
00:30:20,930 --> 00:30:23,580
Nie miałem standardowe io.h.

630
00:30:23,580 --> 00:30:24,530
Dziękuję Ci bardzo.

631
00:30:24,530 --> 00:30:27,330
>> Więc po prostu proces ten of-- Ciebie
nie trzeba rzeczywiście mają kaczkę.

632
00:30:27,330 --> 00:30:29,819
Ale ten pomysł chodzenia
siebie poprzez własny kod

633
00:30:29,819 --> 00:30:31,610
tak że nawet usłyszeć
samodzielnie, dzięki czemu

634
00:30:31,610 --> 00:30:35,620
sprawę przeoczeń w swoim własnym
Uwagi, jest generalnie pomysł.

635
00:30:35,620 --> 00:30:38,910
>> I, być może bardziej logicznie, nie tak
dużo z tym jednym, ale z bardziej zaangażowani

636
00:30:38,910 --> 00:30:44,220
Przykładem właśnie miało miejsce w buggy 3.c,
można chodzić samemu przez niego

637
00:30:44,220 --> 00:30:45,310
następująco.

638
00:30:45,310 --> 00:30:49,190
Więc wszystko w porządku, gumy
Ducky, DDB, jeśli będzie.

639
00:30:49,190 --> 00:30:52,350
Mamy tutaj w moim głównych funkcji,
Dzwonię uzyskać ujemną int.

640
00:30:52,350 --> 00:30:54,660
>> I jestem coraz zwracanej wartości.

641
00:30:54,660 --> 00:31:00,410
Jestem przechowywanie go na lewej stronie
linii nr 8 w zmiennej o nazwie i.

642
00:31:00,410 --> 00:31:02,380
OK, ale czekaj, skąd
że aby ta wartość?

643
00:31:02,380 --> 00:31:04,130
Pozwól mi spojrzeć na funkcję w linii 12.

644
00:31:04,130 --> 00:31:05,760
>> W linii 12, musimy uzyskać ujemną int.

645
00:31:05,760 --> 00:31:08,190
Nie podejmować żadnych nakładów,
nie zwraca int, OK.

646
00:31:08,190 --> 00:31:10,929
Oświadczam, na linii 14. zmienna n.

647
00:31:10,929 --> 00:31:12,220
To będzie przechowywać liczbę całkowitą.

648
00:31:12,220 --> 00:31:13,760
To jest to czego chce.

649
00:31:13,760 --> 00:31:18,480
>> Więc nie następuje natomiast n is-- pozwól
mi cofnąć to, co już mam dylemat.

650
00:31:18,480 --> 00:31:22,710
Tak więc, gdy n jest większe
0, wydruk N jest, OK.

651
00:31:22,710 --> 00:31:25,170
A następnie wywołać uzyskać int przechowywane w n.

652
00:31:25,170 --> 00:31:30,160
A następnie sprawdzić, czy n wynosi 0,
n jest not-- nie jest.

653
00:31:30,160 --> 00:31:31,910
Tak, znowu, nie
potrzebuje rzeczywistego kaczki.

654
00:31:31,910 --> 00:31:35,650
Ale chodzenie siebie poprzez
Twój kod jako ćwiczenie intelektualne

655
00:31:35,650 --> 00:31:37,720
często pomóc
sobie sprawę, co się dzieje,

656
00:31:37,720 --> 00:31:41,170
a nie tylko robić coś
w ten sposób, patrząc na ekranie,

657
00:31:41,170 --> 00:31:43,720
i nie rozmawia się przez
to, co naprawdę nie jest

658
00:31:43,720 --> 00:31:46,270
mocno jako skuteczne techniki.

659
00:31:46,270 --> 00:31:48,620
Więc nie masz niego,
Wiele różnych technik

660
00:31:48,620 --> 00:31:52,102
za faktycznie debugowania kodu
i znalezienie usterki, z których wszystkie

661
00:31:52,102 --> 00:31:54,810
powinny być narzędziami w swoim zestawie narzędzi
tak, że nie jesteś późno w nocy,

662
00:31:54,810 --> 00:31:57,660
zwłaszcza, że ​​jesteś w restauracji
hale, lub w godzinach pracy urzędu,

663
00:31:57,660 --> 00:32:00,368
walić głową w
ściana, stara się rozwiązać jakiś problem.

664
00:32:00,368 --> 00:32:02,020
Sobie sprawę, że istnieją narzędzia programowe.

665
00:32:02,020 --> 00:32:03,720
Istnieją narzędzia gumowe kaczki.

666
00:32:03,720 --> 00:32:09,630
A istnieje cały zespół
wsparcie czeka na pomocną dłoń.

667
00:32:09,630 --> 00:32:13,120
>> Więc teraz, słowo na problemie
zestawy, a na co mamy nadzieję, że ty

668
00:32:13,120 --> 00:32:15,620
wydostać się z nich i jak
pójdziemy na temat oceny.

669
00:32:15,620 --> 00:32:17,680
Za nauczania kursu, w
Zestawy CS50 za problemowe

670
00:32:17,680 --> 00:32:22,320
ocenia się na czterech głównych osi, więc
do speak-- zakres, poprawność, projektowanie,

671
00:32:22,320 --> 00:32:23,060
i styl.

672
00:32:23,060 --> 00:32:25,910
I zakres odnosi się tylko, ile
utworu czy odgryźć?

673
00:32:25,910 --> 00:32:28,080
Jak wielkim problemem próbowałeś?

674
00:32:28,080 --> 00:32:30,110
Jaki poziom wysiłku
ty objawia?

675
00:32:30,110 --> 00:32:35,750
>> Poprawność jest, działa program jako
to ma ze specyfikacją CS50

676
00:32:35,750 --> 00:32:38,640
kiedy zapewnienia pewnych nakładów
lub niektóre wyjścia wróci?

677
00:32:38,640 --> 00:32:41,130
Projekt jest najbardziej prywatną z nich.

678
00:32:41,130 --> 00:32:43,360
I to jest ten, który będzie
podjąć najdłuższa się uczyć

679
00:32:43,360 --> 00:32:47,220
a najdłuższy uczyć w
O ile nie sprowadza się do,

680
00:32:47,220 --> 00:32:49,530
Jak dobrze napisana jest kod?

681
00:32:49,530 --> 00:32:52,920
>> Jest jedna rzecz, po prostu wydrukować poprawny
wyjść lub powrócić właściwych wartości.

682
00:32:52,920 --> 00:32:55,400
Ale robisz to jako
efektywnie, jak to możliwe?

683
00:32:55,400 --> 00:32:58,210
Robisz oddzieli
i podbić lub binarny

684
00:32:58,210 --> 00:33:01,500
wyszukiwanie jako my wkrótce zobaczyć, że my
Dwa tygodnie temu z książki telefonicznej?

685
00:33:01,500 --> 00:33:04,670
Czy istnieją lepsze sposoby, aby rozwiązać
problemem niż obecnie tu mamy?

686
00:33:04,670 --> 00:33:06,380
To okazja do lepszego projektowania.

687
00:33:06,380 --> 00:33:08,530
>> A potem, jak style--
ładna jest kod?

688
00:33:08,530 --> 00:33:12,370
Zauważysz, że jestem ładna
szczególności o wcięcia kodu,

689
00:33:12,370 --> 00:33:15,300
i upewniając moje zmienne
są dostatecznie nazwane. n

690
00:33:15,300 --> 00:33:19,660
podczas krótkiego, to dobra nazwa dla
Numer, ja na całkowitą liczenia,

691
00:33:19,660 --> 00:33:20,727
s na sznurku.

692
00:33:20,727 --> 00:33:22,560
A może mamy już
Zmienna nazwy stylu.

693
00:33:22,560 --> 00:33:25,500
Styl jest po prostu jak dobry
nie Twój kod wygląda?

694
00:33:25,500 --> 00:33:26,600
A jak to jest czytelna?

695
00:33:26,600 --> 00:33:29,650
>> I po pewnym czasie, co twój TAs
i TF zrobi w toku

696
00:33:29,650 --> 00:33:31,870
jest zapewnić Państwu, że
rodzaj sprzężenia jakościowej

697
00:33:31,870 --> 00:33:34,330
dzięki czemu lepiej
w tych różnych aspektów.

698
00:33:34,330 --> 00:33:37,510
I pod względem tego, jak
ocenić każdą z tych osi,

699
00:33:37,510 --> 00:33:40,080
to zazwyczaj z bardzo niewielu
wiadra tak, że ogólnie

700
00:33:40,080 --> 00:33:41,680
zorientować się, jak dobrze robisz.

701
00:33:41,680 --> 00:33:45,680
I rzeczywiście, jeśli otrzyma wynik na
każda z tych axes-- dokładność, projektowania

702
00:33:45,680 --> 00:33:49,659
i styl especially-- liczba
na ogół będzie w zakresie od 1 do 5.

703
00:33:49,659 --> 00:33:52,450
I dosłownie, jeśli dostajesz
3 Jest na początku semestru,

704
00:33:52,450 --> 00:33:53,977
Jest to bardzo dobra rzecz.

705
00:33:53,977 --> 00:33:55,810
Oznacza to, że nadal
miejsce na udoskonalenie,

706
00:33:55,810 --> 00:33:58,490
którego ma nadzieję na
przy klasie po raz pierwszy.

707
00:33:58,490 --> 00:34:01,820
Nie miejmy nadzieję niektóre kawałek sufitu
do którego jesteś aspiruje do osiągnięcia.

708
00:34:01,820 --> 00:34:03,970
A więc dostanie 3 w serwisie
najwcześniejsze sztuk,

709
00:34:03,970 --> 00:34:06,550
jeśli nie jakiś 2 i 4'S,
jest rzeczywiście dobrą rzeczą.

710
00:34:06,550 --> 00:34:08,880
To również jest w zasięgu,
dobrze w oczekiwania.

711
00:34:08,880 --> 00:34:11,421
>> A jeśli twój umysł jest wyścigi, czekaj
minutę, trzy z pięciu.

712
00:34:11,421 --> 00:34:12,620
To naprawdę 6 z 10.

713
00:34:12,620 --> 00:34:13,560
To 60%.

714
00:34:13,560 --> 00:34:14,830
Mój Boże, to F.

715
00:34:14,830 --> 00:34:15,870
>> To nie jest.

716
00:34:15,870 --> 00:34:17,600
Nie jest, w tym, że.

717
00:34:17,600 --> 00:34:22,710
Przeciwnie, jest to okazja, aby poprawić
w ciągu semestru.

718
00:34:22,710 --> 00:34:25,580
A jeśli się niektóre
Poors, są okazją

719
00:34:25,580 --> 00:34:29,199
do skorzystania z godzinami pracy,
pewnością sekcje i innych zasobów.

720
00:34:29,199 --> 00:34:32,840
>> Najlepszy jest okazją, naprawdę,
do dumy, jak daleko masz

721
00:34:32,840 --> 00:34:34,520
przyjść w ciągu semestru.

722
00:34:34,520 --> 00:34:38,199
Tak zdają sobie sprawy, jeśli nic
indziej, trzy dobre.

723
00:34:38,199 --> 00:34:40,179
I to pozwala miejsce na wzrost w czasie.

724
00:34:40,179 --> 00:34:43,090
>> , Jak te osie
ważony, realistycznie jesteś

725
00:34:43,090 --> 00:34:46,745
zamiar spędzić większość czasu coraz
rzeczy do pracy, nie mówiąc już poprawnie.

726
00:34:46,745 --> 00:34:49,120
A więc ma tendencję do poprawności
ważone najbardziej jak w przypadku

727
00:34:49,120 --> 00:34:51,360
Ten mnożnikowy trzech.

728
00:34:51,360 --> 00:34:54,659
Projekt jest również ważne, ale
coś, co nie koniecznie

729
00:34:54,659 --> 00:34:58,220
wydać wszystkie te godziny na
próbuje dostać rzeczy po prostu pracować.

730
00:34:58,220 --> 00:35:00,019
>> I tak to jest ważone
trochę lżej.

731
00:35:00,019 --> 00:35:01,560
I wtedy styl jest ważony najmniej.

732
00:35:01,560 --> 00:35:03,710
Nawet jeśli jest to nie mniej
fundamentalnie ważne,

733
00:35:03,710 --> 00:35:05,990
to jest po prostu, być może,
Najłatwiej to zrobić dobrze,

734
00:35:05,990 --> 00:35:08,440
naśladując przykładach
zrobić w wykładzie i sekcji

735
00:35:08,440 --> 00:35:11,080
z rzeczami ładnie
wcięte i skomentował,

736
00:35:11,080 --> 00:35:14,320
i tak dalej jest jednym z najłatwiej
rzeczy do zrobienia i uzyskać prawo.

737
00:35:14,320 --> 00:35:16,960
Tak więc jako takie sobie sprawę,
że są to punkty

738
00:35:16,960 --> 00:35:19,000
które są stosunkowo łatwe do uchwycenia.

739
00:35:19,000 --> 00:35:22,360
>> A teraz kilka słów o
this-- uczciwości akademickiej.

740
00:35:22,360 --> 00:35:25,150
Więc za kurs na
program nauczania, widać

741
00:35:25,150 --> 00:35:27,630
Oczywiście, że ma dość
nieco języka wokół tego.

742
00:35:27,630 --> 00:35:31,380
I oczywiście zajmuje się kwestią
uczciwości akademickiej dość poważnie.

743
00:35:31,380 --> 00:35:33,450
>> Mamy rozróżnienie,
na dobre i na złe,

744
00:35:33,450 --> 00:35:36,570
ich wysłania każdego roku więcej
studentów do podjęcia działań dyscyplinarnych

745
00:35:36,570 --> 00:35:39,670
niż większość każda inna
Oczywiście, że jestem świadomy.

746
00:35:39,670 --> 00:35:42,580
Nie jest to koniecznie
wskazuje na fakt

747
00:35:42,580 --> 00:35:46,340
że uczniowie CS lub CS50 studentów, są
mniej uczciwi niż twoi koledzy.

748
00:35:46,340 --> 00:35:49,090
Ale w rzeczywistości, że w tym
Świat, w formie elektronicznej, po prostu

749
00:35:49,090 --> 00:35:50,990
mają technologiczny
środki wykrywania tego.

750
00:35:50,990 --> 00:35:53,360
>> Jest to dla nas ważny
rzetelność całej klasy

751
00:35:53,360 --> 00:35:58,550
że robimy to wykryć i podniesienie
kwestia, kiedy widzimy rzeczy.

752
00:35:58,550 --> 00:36:01,980
I po prostu namalować obraz, i naprawdę
aby pomóc coś jak ten w zlewie,

753
00:36:01,980 --> 00:36:04,600
są numery
studentów w ciągu ostatnich 10 lat

754
00:36:04,600 --> 00:36:07,610
które brały udział w niektórych
takie kwestie uczciwości akademickiej,

755
00:36:07,610 --> 00:36:10,990
z jakimiś 32 uczniów
od jesieni 2015 roku, która

756
00:36:10,990 --> 00:36:13,760
To znaczy, że możemy brać
sprawę bardzo poważnie.

757
00:36:13,760 --> 00:36:18,380
I ostatecznie, te numery komponować,
Ostatnio, około 3%, 4%, lub

758
00:36:18,380 --> 00:36:19,120
klasy.

759
00:36:19,120 --> 00:36:25,220
>> Więc za większość kwalifikowana studentów
wydaje się, że linie są wyraźne.

760
00:36:25,220 --> 00:36:27,940
Ale nie należy mieć to na
przeszkadza, zwłaszcza późno

761
00:36:27,940 --> 00:36:32,080
w nocy, kiedy zmaga się z
niektóre rozwiązania do zestawu problemów,

762
00:36:32,080 --> 00:36:34,830
że istnieją mechanizmy
do poruszania się lepiej

763
00:36:34,830 --> 00:36:37,870
Wsparcie może od ciebie
myślę, nawet o tej godzinie.

764
00:36:37,870 --> 00:36:40,514
Sobie sprawę, że po otrzymaniu
Zgłoszenia studentów, przejeżdżamy

765
00:36:40,514 --> 00:36:43,430
porównanie każdy złożenia tego roku
przed każdym złożeniem w ubiegłym roku,

766
00:36:43,430 --> 00:36:47,590
przed każdym złożeniem od 2007 roku,
a ponieważ, patrząc, jak również,

767
00:36:47,590 --> 00:36:49,931
Kod repozytoriów on-line,
fora dyskusyjne, serwisy pracę.

768
00:36:49,931 --> 00:36:51,806
A my o tym wspomnieć,
Naprawdę, wszystko dla dobra

769
00:36:51,806 --> 00:36:56,040
pełnego ujawnienia, że ​​jeśli
ktoś inny może go znaleźć w Internecie,

770
00:36:56,040 --> 00:36:57,880
Z pewnością, dzięki czemu możemy kursu.

771
00:36:57,880 --> 00:37:00,100
Ale, naprawdę, duch
kursu sprowadza

772
00:37:00,100 --> 00:37:01,650
do tej klauzuli w programie nauczania.

773
00:37:01,650 --> 00:37:03,670
To naprawdę jest tak, bądź rozsądny.

774
00:37:03,670 --> 00:37:06,680
>> I gdybyśmy mieli do opracowania na ten temat
tylko z nieco bardziej językiem,

775
00:37:06,680 --> 00:37:09,770
sobie sprawę, że istota wszystkich
Prace, które zostaną przesłane do tego kursu

776
00:37:09,770 --> 00:37:10,954
musi być własne.

777
00:37:10,954 --> 00:37:13,870
Ale w tym, nie są z pewnością
możliwości i zachęty,

778
00:37:13,870 --> 00:37:17,300
i wartość pedagogiczną w przekształcaniu się
wiele innych, siebie, TFS, CAS,

779
00:37:17,300 --> 00:37:20,760
TAS, a inni w klasie,
do wsparcia, nie mówiąc już o znajomych

780
00:37:20,760 --> 00:37:23,547
i współlokatorzy, którzy studiowali
CS i programowania wcześniej.

781
00:37:23,547 --> 00:37:25,130
A więc nie jest to dodatek do tego.

782
00:37:25,130 --> 00:37:28,180
A ogólna zasada
jest this-- prosząc o pomoc,

783
00:37:28,180 --> 00:37:31,470
można pokazać swój kod do innych,
ale nie może ich kompetencji zobaczyć.

784
00:37:31,470 --> 00:37:34,880
Więc nawet jeśli jesteś w godzinach pracy urzędu,
lub w hali D, lub gdzieś indziej

785
00:37:34,880 --> 00:37:37,450
pracuje nad pewnym częściowy zestaw,
współpracując znajomego, który

786
00:37:37,450 --> 00:37:40,160
jest całkowicie w porządku, u
Koniec dnia swoją pracę

787
00:37:40,160 --> 00:37:43,034
powinien ostatecznie należeć do siebie
was odpowiednio, a nie

788
00:37:43,034 --> 00:37:45,700
być jakiś wspólny wysiłek,
z wyjątkiem ostatniego projektu, w przypadku

789
00:37:45,700 --> 00:37:47,410
jest to dozwolone i popierane.

790
00:37:47,410 --> 00:37:49,830
>> Uświadom sobie, że jeśli jesteś
zmaga się z czymś

791
00:37:49,830 --> 00:37:52,520
a twój przyjaciel właśnie się dzieje
być lepiej na to wtedy,

792
00:37:52,520 --> 00:37:55,130
albo lepiej na tym problemu niż ty,
lub nieco dalej w przyszłość niż ty,

793
00:37:55,130 --> 00:37:57,330
jest to całkowicie uzasadnione, aby włączyć
do swojego przyjaciela i powiedzieć, hej,

794
00:37:57,330 --> 00:38:00,480
Czy myśli patrząc na mojego kodu tutaj
pomaga mi dostrzec, co mój problem jest?

795
00:38:00,480 --> 00:38:03,760
I miejmy nadzieję, że w
Zainteresowanie wartości pedagogicznej

796
00:38:03,760 --> 00:38:07,040
że przyjaciółka nie tylko
powiedzieć, oh, to zrobić, ale raczej

797
00:38:07,040 --> 00:38:09,917
co ty brakuje on line
6, lub coś w tym stylu?

798
00:38:09,917 --> 00:38:12,000
Jednak rozwiązanie to nie jest
dla przyjaciela obok ciebie

799
00:38:12,000 --> 00:38:15,617
powiedzieć, oh, dobrze, tutaj, pozwól mi wyciągnąć
Ten górę i pokazać moje rozwiązanie dla Ciebie.

800
00:38:15,617 --> 00:38:16,450
Więc to jest linia.

801
00:38:16,450 --> 00:38:18,670
Pokazujesz swój kod
inni, ale nie może

802
00:38:18,670 --> 00:38:22,350
zobaczyć ich kompetencji, z zastrzeżeniem pozostałych
Ograniczenia w programie nauczania w toku.

803
00:38:22,350 --> 00:38:24,760
>> Więc nie pamiętać tego
tak zwana klauzula żal

804
00:38:24,760 --> 00:38:27,560
w toku nauczania, jak również,
że jeśli popełnić jakiś czyn

805
00:38:27,560 --> 00:38:30,476
Nie jest rozsądne, ale doprowadzenie do
uwaga głowami w trakcie

806
00:38:30,476 --> 00:38:34,240
w ciągu 72 godzin, kurs
może nałożyć sankcje, które lokalne

807
00:38:34,240 --> 00:38:37,380
może zawierać niezadowalający lub
braku stopnia za pracę złożone.

808
00:38:37,380 --> 00:38:41,410
Ale oczywiście, że nie skieruje
znaczenia dla dalszego postępowania dyscyplinarnego,

809
00:38:41,410 --> 00:38:43,010
z wyjątkiem przypadków powtarzających się czynności.

810
00:38:43,010 --> 00:38:46,632
Innymi słowy, jeśli robią niektóre
głupie, zwłaszcza późnym wieczorem, decyzja

811
00:38:46,632 --> 00:38:49,340
że następnego dnia rano lub dwa dni
później obudzić się i uświadomić sobie,

812
00:38:49,340 --> 00:38:50,870
co ja sobie myślałem?

813
00:38:50,870 --> 00:38:53,890
Robisz w CS50 mają ujście
do mocowania tego problemu

814
00:38:53,890 --> 00:38:57,170
i przyznanie się do tego, abyśmy
spotka się w połowie drogi i radzić sobie

815
00:38:57,170 --> 00:39:01,500
z nim w sprawie, która jest zarówno
edukacyjnych i cenne dla ciebie,

816
00:39:01,500 --> 00:39:04,200
ale mimo to w jakiś sposób represyjny.

817
00:39:04,200 --> 00:39:08,590
A teraz, by stępić ten.

818
00:39:08,590 --> 00:39:10,570
>> [ODTWARZANIE]

819
00:39:10,570 --> 00:39:13,540
>> [MUZYKA]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [KONIEC ODTWARZANIA]

822
00:39:58,866 --> 00:40:00,490
David J. MALAN: Dobra, jesteśmy z powrotem.

823
00:40:00,490 --> 00:40:03,680
A teraz patrzymy na jednym z
Pierwszy z naszych domen świata rzeczywistego

824
00:40:03,680 --> 00:40:08,720
W CS50, sztuka kryptografii
sztuka wysyłania i odbierania

825
00:40:08,720 --> 00:40:11,840
grypsy, szyfrowane
Komunikaty jeśli chcesz,

826
00:40:11,840 --> 00:40:17,060
które mogą być rozszyfrowane tylko jeśli masz
niektóre kluczowym składnikiem że nadawca ma

827
00:40:17,060 --> 00:40:18,030
także.

828
00:40:18,030 --> 00:40:22,120
Więc motywują to weźmiemy
Spojrzenie na tej rzeczy tutaj

829
00:40:22,120 --> 00:40:26,750
która jest przykładem
tajemnicą, że pierścień dekoder

830
00:40:26,750 --> 00:40:34,042
może być wykorzystany w celu, aby dowiedzieć
co tajny komunikat w rzeczywistości.

831
00:40:34,042 --> 00:40:35,750
W rzeczywistości, z powrotem w
dzień w szkole,

832
00:40:35,750 --> 00:40:38,787
jeśli kiedykolwiek wysłał tajne wiadomości
niektóre przyjaciel czy niektórzy zgniatać w klasie,

833
00:40:38,787 --> 00:40:40,620
można pomyśleć
pan jest mądry

834
00:40:40,620 --> 00:40:46,530
by na kawałku papieru zmiany,
jak, od A do B i B do C i C do D,

835
00:40:46,530 --> 00:40:47,590
i tak dalej.

836
00:40:47,590 --> 00:40:50,300
Ale faktycznie szyfrowania
Twoje dane, nawet

837
00:40:50,300 --> 00:40:53,300
gdyby to było trochę banalne, nie było
że trudno prowadzącemu sprawę,

838
00:40:53,300 --> 00:40:55,675
dobrze, jeśli tylko zmieni
B A B i C,

839
00:40:55,675 --> 00:40:57,550
rzeczywiście dowiedzieć się,
co było przesłanie,

840
00:40:57,550 --> 00:40:59,700
ale były szyfrowania informacji.

841
00:40:59,700 --> 00:41:03,420
>> Byłaś po prostu robi to
po prostu, tak jak Ralphie tutaj

842
00:41:03,420 --> 00:41:07,934
w słynnym filmie, który gra
dość dużo reklam nauseum każdej zimy.

843
00:41:07,934 --> 00:41:08,600
[ODTWARZANIE]

844
00:41:08,600 --> 00:41:11,180
-bE Jest znany wszystkim, że
Ralph Parker Niniejszym

845
00:41:11,180 --> 00:41:14,070
mianowany członkiem Little
Orphan Annie Tajny Krąg

846
00:41:14,070 --> 00:41:17,700
i ma prawo do wszystkich wyróżnieniem
i korzyści z nim występujących.

847
00:41:17,700 --> 00:41:24,340
>> -Signed, Little Orphan Annie,
Licznik podpisany Pierre Andre, atramentem.

848
00:41:24,340 --> 00:41:27,160
Zaszczytów i korzyści,
już w wieku dziewięciu lat.

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [ROZKRZYCZANY]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Daj spokój.

853
00:41:34,250 --> 00:41:35,210
Zabierzmy się za to.

854
00:41:35,210 --> 00:41:39,530
Nie muszę cały ten jazz
o przemytników i piratów.

855
00:41:39,530 --> 00:41:41,660
>> -listen Jutro dla
przygoda zawieranie

856
00:41:41,660 --> 00:41:43,880
czarnego statku pirackiego.

857
00:41:43,880 --> 00:41:46,650
Teraz nadszedł czas na
tajne wiadomości Annie

858
00:41:46,650 --> 00:41:49,840
dla Ciebie członkowie Secret Circle.

859
00:41:49,840 --> 00:41:53,570
Pamiętaj, dzieci, tylko członkowie
Annie Secret Kole

860
00:41:53,570 --> 00:41:56,140
może dekodować tajną wiadomość Annie.

861
00:41:56,140 --> 00:42:00,340
>> Pamiętaj, Annie zależy od ciebie.

862
00:42:00,340 --> 00:42:02,880
Określ szpilki do B2.

863
00:42:02,880 --> 00:42:05,230
Oto komunikat.

864
00:42:05,230 --> 00:42:06,090
12, 11--

865
00:42:06,090 --> 00:42:10,250
>> -Ja Jestem, moje pierwsze tajne spotkanie.

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16.

867
00:42:13,890 --> 00:42:15,780
>> -Pierre Był w wielkim dzisiaj głosu.

868
00:42:15,780 --> 00:42:19,000
Mógłbym powiedzieć, że dzisiejszy
Przesłanie było naprawdę ważne.

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, to wiadomość
z Annie sama.

870
00:42:22,694 --> 00:42:23,860
Pamiętaj, nie mów nikomu.

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 Sekund później, jestem w jedynym
pokój w domu, w którym chłopiec z dziewięciu

873
00:42:32,930 --> 00:42:37,040
może siedzieć w prywatność i dekodowania.

874
00:42:37,040 --> 00:42:39,730
Aha, B!

875
00:42:39,730 --> 00:42:42,360
Poszedłem do następnego, E.

876
00:42:42,360 --> 00:42:44,520
>> Pierwsze słowo to będzie.

877
00:42:44,520 --> 00:42:49,032
S, to teraz przychodzi łatwiej, U, 25--

878
00:42:49,032 --> 00:42:51,733
>> Och, daj spokój, Ralphie, muszę iść!

879
00:42:51,733 --> 00:42:53,688
>> -I'll Zaraz zejdzie, mamo!

880
00:42:53,688 --> 00:42:54,188
Gee świst!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, pamiętaj to-- koniecznie co?

883
00:43:04,060 --> 00:43:05,970
Jaki był mały Orphan
Annie chce powiedzieć?

884
00:43:05,970 --> 00:43:07,264
Pamiętaj, aby co?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie Andy zajechał
Idź, to proszę wyjść?

886
00:43:09,634 --> 00:43:10,480
>> -W Porządku, mamo!

887
00:43:10,480 --> 00:43:12,880
Zaraz będę się!

888
00:43:12,880 --> 00:43:14,550
>> -I Był coraz bliżej.

889
00:43:14,550 --> 00:43:16,620
Napięcie było straszne.

890
00:43:16,620 --> 00:43:17,720
Co to było?

891
00:43:17,720 --> 00:43:20,170
Losy planety
może zawiesić w bilansie.

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
Musi Andy'ego udać!

894
00:43:23,170 --> 00:43:26,890
>> -I'll Być prosto, na litość boską!

895
00:43:26,890 --> 00:43:32,680
>> -Almost Tam palce przyleciał, mój umysł
była pułapka stali, każda pora wibruje.

896
00:43:32,680 --> 00:43:37,198
To było niemal oczywiste, tak, tak, tak.

897
00:43:37,198 --> 00:43:43,091
>> -bE Pamiętaj, aby pić Ovaltine.

898
00:43:43,091 --> 00:43:43,590
Ovaltine?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
Za durny komercyjnych?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
Sukinsyn.

903
00:43:54,227 --> 00:43:54,810
[KONIEC ODTWARZANIA]

904
00:43:54,810 --> 00:43:57,390
David J. MALAN: OK, więc
że był to bardzo długa droga

905
00:43:57,390 --> 00:44:00,660
wprowadzenia kryptografii,
a także Ovaltine.

906
00:44:00,660 --> 00:44:04,470
W rzeczywistości, z tego starego ogłoszenie
Tutaj dlaczego Ovaltine tak dobrze?

907
00:44:04,470 --> 00:44:09,470
Jest skoncentrowany ekstrakcja dojrzałe
słód jęczmienny, mleko krowie czystego kremowym,

908
00:44:09,470 --> 00:44:14,360
oraz specjalnie przygotowane kakao, wraz
z naturalnych fosfolipidów i witamin.

909
00:44:14,360 --> 00:44:18,240
To jest dodatkowo wzmocniony
dodatkowe witaminy z grupy B i D, mniam.

910
00:44:18,240 --> 00:44:21,600
I nadal można dostać to, jak widać,
na Amazon, jak my tutaj.

911
00:44:21,600 --> 00:44:24,810
>> Ale motywacja tutaj było
wprowadzenie kryptografii, a konkretnie

912
00:44:24,810 --> 00:44:28,340
rodzaj kryptografii znana
a kluczem tajnym.

913
00:44:28,340 --> 00:44:34,284
I jak sama nazwa wskazuje, całość
Bezpieczeństwo tajnego klucza kryptosystem,

914
00:44:34,284 --> 00:44:36,200
jeśli chcesz, metodologia
za jedyne kodowania

915
00:44:36,200 --> 00:44:40,960
Informacje dwóch osób jest to, że
tylko nadawca i odbiorca tylko

916
00:44:40,960 --> 00:44:46,980
poznać sekret key-- jakąś wartość, niektóre
Sekret fraza, jakiś sekret, liczba, która

917
00:44:46,980 --> 00:44:50,660
pozwala im zarówno szyfrowania
i deszyfrowania informacji.

918
00:44:50,660 --> 00:44:53,470
I kryptografia, naprawdę,
jest po prostu to od tygodnia 0.

919
00:44:53,470 --> 00:44:56,715
>> Jest to problem, gdzie tam wejść,
jak rzeczywiste wiadomości w języku angielskim

920
00:44:56,715 --> 00:44:59,340
czy cokolwiek innego języka, którego
Aby wysłać do kogoś w klasie,

921
00:44:59,340 --> 00:45:00,580
lub przez internet.

922
00:45:00,580 --> 00:45:03,840
Istnieją pewne wyjściowy, który będzie
być zaszyfrowany komunikat, który

923
00:45:03,840 --> 00:45:05,250
odbiorca chce otrzymać.

924
00:45:05,250 --> 00:45:07,405
A nawet jeśli ktoś w
średnim odbiera go też,

925
00:45:07,405 --> 00:45:09,780
nie chcesz ich do
muszą być w stanie odszyfrować,

926
00:45:09,780 --> 00:45:12,840
ponieważ wewnątrz tego
czarna skrzynka, albo algorytm,

927
00:45:12,840 --> 00:45:17,650
jest jakiś mechanizm, niektóre krok po kroku
Instrukcje, że wejście do podejmowania

928
00:45:17,650 --> 00:45:20,710
i przekształcenie go w
Wyjście w miejmy nadzieję bezpieczny sposób.

929
00:45:20,710 --> 00:45:23,640
>> I rzeczywiście, jest trochę
słownictwo w tym świecie, w następujący sposób.

930
00:45:23,640 --> 00:45:26,100
Zwykły tekst jest słowo
informatyk będzie

931
00:45:26,100 --> 00:45:28,449
to opisał wprowadzanie
wiadomości, jak po angielsku

932
00:45:28,449 --> 00:45:31,240
czy cokolwiek innego języka, który faktycznie
chcesz wysłać do innego człowieka.

933
00:45:31,240 --> 00:45:35,450
A potem szyfrogram jest wyścig
do zakodowane lub zaszyfrowane,

934
00:45:35,450 --> 00:45:36,520
jego wersję.

935
00:45:36,520 --> 00:45:38,750
>> Ale jest jeszcze jeden inny składnik tutaj.

936
00:45:38,750 --> 00:45:43,200
Jest jeszcze jedna wejściowe
Sekret kryptografii klucza.

937
00:45:43,200 --> 00:45:45,200
I to jest sam klucz,
który jest na ogół

938
00:45:45,200 --> 00:45:48,930
jak zobaczymy, numer, lub
list, lub słowo, cokolwiek

939
00:45:48,930 --> 00:45:51,980
Algorytm jest faktycznie przewiduje.

940
00:45:51,980 --> 00:45:53,870
>> A jak odszyfrować informacje?

941
00:45:53,870 --> 00:45:55,110
Jak można go rozszyfrować?

942
00:45:55,110 --> 00:45:57,950
Cóż, po prostu w odwrotnej
wyjścia i wejścia.

943
00:45:57,950 --> 00:46:00,900
>> Innymi słowy, gdy ktoś
odbiera zaszyfrowane wiadomości,

944
00:46:00,900 --> 00:46:03,740
on po prostu musi
wiedzieć, że tego samego klucza.

945
00:46:03,740 --> 00:46:05,700
Oni otrzymali szyfrogram.

946
00:46:05,700 --> 00:46:09,530
A podłączając tych dwóch
Wejścia do systemu kryptograficznego,

947
00:46:09,530 --> 00:46:14,260
algorytm, ta czarna skrzynka, z
powinny pochodzić oryginalnego tekstu jawnego.

948
00:46:14,260 --> 00:46:17,830
I tak to jest bardzo wysoki poziom
Widok tego, co jest rzeczywiście kryptografii

949
00:46:17,830 --> 00:46:18,590
wszystko o.

950
00:46:18,590 --> 00:46:20,030
>> Warto więc tam dostać.

951
00:46:20,030 --> 00:46:22,700
Spójrzmy teraz pod spodem
kaptur z czegoś

952
00:46:22,700 --> 00:46:26,000
byliśmy biorąc za pewnik, za
Miniony tydzień, a dla tej sesji

953
00:46:26,000 --> 00:46:27,629
here-- ciąg.

954
00:46:27,629 --> 00:46:30,295
Ciąg na koniec dnia
jest po prostu ciągiem znaków.

955
00:46:30,295 --> 00:46:33,610
>> To może być hello world, lub
witam Zamyla, czy cokolwiek innego.

956
00:46:33,610 --> 00:46:37,050
Ale co to znaczy
będzie ciągiem znaków?

957
00:46:37,050 --> 00:46:41,520
W rzeczywistości daje biblioteki CS50
nam typ danych o nazwie ciąg.

958
00:46:41,520 --> 00:46:45,140
>> Ale faktycznie nie ma
czegoś takiego jak łańcuch w C.

959
00:46:45,140 --> 00:46:49,450
To naprawdę jest po prostu ciągiem
charakter, charakter, charakter,

960
00:46:49,450 --> 00:46:52,180
charakter, do tyłu, do tyłu, do
wstecz, do tyłu, do tyłu w środku

961
00:46:52,180 --> 00:46:54,650
pamięci komputera lub pamięci RAM.

962
00:46:54,650 --> 00:46:58,940
I będziemy szukać głębiej, że w
przyszłości, kiedy patrzymy na samej pamięci,

963
00:46:58,940 --> 00:47:02,030
oraz wykorzystanie i
Zagrożenia, które są zaangażowane.

964
00:47:02,030 --> 00:47:04,100
>> Ale rozważmy ciąg Zamyla.

965
00:47:04,100 --> 00:47:07,480
Więc po prostu nazwa
ludzka tu Zamyla,

966
00:47:07,480 --> 00:47:12,030
to sekwencją
znaków, Z-A-M-T-L-A.

967
00:47:12,030 --> 00:47:16,020
A teraz załóżmy, że nazwa użytkownika Zamyla
są przechowywane wewnątrz komputera

968
00:47:16,020 --> 00:47:16,880
program.

969
00:47:16,880 --> 00:47:20,830
>> Cóż, to ma się rozumieć, że powinniśmy
być w stanie spojrzeć na te znaki

970
00:47:20,830 --> 00:47:21,590
indywidualnie.

971
00:47:21,590 --> 00:47:24,710
Więc jestem po prostu wyciągnąć trochę
ramkę wokół nazwy Zamyla tutaj.

972
00:47:24,710 --> 00:47:31,580
I to jest w przypadku C, że kiedy
mieć ciąg, a może jak Zamyla--

973
00:47:31,580 --> 00:47:34,940
że łańcuch ma wrócić z
funkcja Uzyskaj ciąg,

974
00:47:34,940 --> 00:47:38,540
rzeczywiście można manipulować
to znak po znaku.

975
00:47:38,540 --> 00:47:42,070
>> Teraz jest germane dla
Rozmowa pod ręką, ponieważ

976
00:47:42,070 --> 00:47:46,420
w kryptografii, jeśli chcesz zmienić
A do B, C i B, C, D oraz,

977
00:47:46,420 --> 00:47:49,650
i tak dalej, trzeba być w stanie
spojrzeć na poszczególnych znaków

978
00:47:49,650 --> 00:47:50,190
w ciągu.

979
00:47:50,190 --> 00:47:52,695
Musisz być w stanie zmienić
Z. do czegoś innego, Â

980
00:47:52,695 --> 00:47:55,280
do czegoś innego, m, aby
coś innego, i tak dalej.

981
00:47:55,280 --> 00:47:58,000
A więc musimy znaleźć sposób,
programowo, więc

982
00:47:58,000 --> 00:48:03,020
mówić w C, aby móc zmienić
i spojrzeć na poszczególnych listach.

983
00:48:03,020 --> 00:48:05,690
I możemy to zrobić w następujący sposób.

984
00:48:05,690 --> 00:48:08,340
>> Puść mnie wrócić w CS50 IDE.

985
00:48:08,340 --> 00:48:11,130
I pozwól mi iść do przodu
i utworzyć nowy plik

986
00:48:11,130 --> 00:48:16,134
że zadzwonię do tego czasu string0,
jako nasz pierwszy taki przykład kropka c.

987
00:48:16,134 --> 00:48:18,300
I zamierzam iść do przodu
i bat go w następujący sposób.

988
00:48:18,300 --> 00:48:22,870
>> Więc to CS50.h i
Następnie zawierają standardowe io.h,

989
00:48:22,870 --> 00:48:25,990
której jestem prawie zawsze będzie
używać w swoich programach, przynajmniej

990
00:48:25,990 --> 00:48:26,780
początkowo.

991
00:48:26,780 --> 00:48:32,180
int main pustkę, a potem tu jestem
zamiar zrobić struny staje się łańcuch.

992
00:48:32,180 --> 00:48:35,260
A potem mam zamiar
śmiało i to zrobić.

993
00:48:35,260 --> 00:48:37,460
Chcę iść do przodu
i jako test dla pewności

994
00:48:37,460 --> 00:48:43,607
po prostu powiedzieć cześć, procent s,
średnik, sprawia, że ​​ciąg 0.

995
00:48:43,607 --> 00:48:44,690
Uh oh, co ja tu robić?

996
00:48:44,690 --> 00:48:45,930
Och, nie miałem go podłączyć.

997
00:48:45,930 --> 00:48:48,120
Więc lekcja, że
nie było zamierzone.

998
00:48:48,120 --> 00:48:52,480
>> Więc błędu, bardziej procent
konwersji niż argumentów danych.

999
00:48:52,480 --> 00:48:54,940
I to jest, gdy w
Linia 7-- OK, więc mam,

1000
00:48:54,940 --> 00:48:56,690
cytat cytatu, to
mój ciąg do printf.

1001
00:48:56,690 --> 00:48:58,151
Mam znak procent.

1002
00:48:58,151 --> 00:48:59,650
Ale tęsknię drugi argument.

1003
00:48:59,650 --> 00:49:03,190
>> Brakuje mi przecinek, które s
I miał w poprzednich przykładach.

1004
00:49:03,190 --> 00:49:06,650
Więc to dobra okazja, aby rozwiązać
jeszcze jeden błąd, przypadkowo.

1005
00:49:06,650 --> 00:49:09,950
A teraz pozwól mi działać
string0 wpisz Zamyla.

1006
00:49:09,950 --> 00:49:10,970
OK, cześć Zamyla.

1007
00:49:10,970 --> 00:49:14,144
>> Więc mamy uruchomić ten rodzaj programu
kilka różnych razy.

1008
00:49:14,144 --> 00:49:16,310
Ale zróbmy coś
trochę inaczej tym razem.

1009
00:49:16,310 --> 00:49:19,450
Zamiast po prostu na drukowaniu Zamyla
Cały czas z nazwy printf,

1010
00:49:19,450 --> 00:49:21,350
Zróbmy to znak po znaku.

1011
00:49:21,350 --> 00:49:22,700
>> Zamierzam użyć pętli for.

1012
00:49:22,700 --> 00:49:26,160
I mam zamiar dać sobie
zmienna liczenie, nazywa i.

1013
00:49:26,160 --> 00:49:33,530
I mam zamiar utrzymać Iterowanie, więc
długo, jak długo jest mniejsza od długości s.

1014
00:49:33,530 --> 00:49:35,930
>> Okazuje się, że nie zrobił
zrobić to po raz ostatni,

1015
00:49:35,930 --> 00:49:39,100
że C jest wyposażony w
Funkcja o nazwie Stirling.

1016
00:49:39,100 --> 00:49:42,690
Powrót w dzień, iw ogóle
Nadal przy realizacji zadań,

1017
00:49:42,690 --> 00:49:45,405
ludzie będą bardzo często wybierają
Nazwy zwięzłe ten rodzaj dźwięku

1018
00:49:45,405 --> 00:49:48,280
jak to, co chcesz, nawet jeśli jest to
brakuje kilku samogłosek lub liter.

1019
00:49:48,280 --> 00:49:50,660
Więc Stirling jest
nazwa funkcji, która

1020
00:49:50,660 --> 00:49:53,880
przyjmuje argument między
nawiasy, które powinny być ciągiem.

1021
00:49:53,880 --> 00:49:56,910
I to właśnie zwraca liczbę całkowitą,
długość tego łańcucha.

1022
00:49:56,910 --> 00:50:00,580
>> Więc to dla pętli na linii 7 będzie
aby rozpocząć odliczanie i równa 0.

1023
00:50:00,580 --> 00:50:02,530
To będzie zwiększać
I na każdej iteracji

1024
00:50:02,530 --> 00:50:04,350
o 1, jak robiliśmy kilka razy.

1025
00:50:04,350 --> 00:50:06,780
Ale to będzie tylko zrobić
to aż do momentu

1026
00:50:06,780 --> 00:50:09,660
kiedy to długość
samego łańcucha.

1027
00:50:09,660 --> 00:50:14,520
>> Jest to więc sposób, w ostatecznym rozrachunku,
iteracja ciągu znaków

1028
00:50:14,520 --> 00:50:17,430
w ciągu jak jest następujący.

1029
00:50:17,430 --> 00:50:20,670
Mam zamiar nie wydrukować
Cały ciąg, ale procent c,

1030
00:50:20,670 --> 00:50:22,860
pojedynczy znak
a następnie w nowym wierszu.

1031
00:50:22,860 --> 00:50:24,880
A potem mam zamiar
iść do przodu, a ja potrzebuję

1032
00:50:24,880 --> 00:50:29,080
powiedzieć, że chcesz wydrukować
i-ty znak s.

1033
00:50:29,080 --> 00:50:33,450
>> Więc jeśli jest to zmienna, która wskazuje
indeks łańcucha, gdzie

1034
00:50:33,450 --> 00:50:37,230
jesteś w nim, muszę być w stanie
powiedzieć, daj mi znak-ty s.

1035
00:50:37,230 --> 00:50:40,390
Oraz c ma sposób prowadzenia
to z nawiasami kwadratowymi.

1036
00:50:40,390 --> 00:50:43,679
Wystarczy powiedzieć, nazwę
łańcuchem znaków, który jest w tym przypadku s.

1037
00:50:43,679 --> 00:50:46,970
Następnie należy użyć nawiasów kwadratowych, które są
zwykle tuż nad swoim Return lub Enter

1038
00:50:46,970 --> 00:50:48,110
klawisz na klawiaturze.

1039
00:50:48,110 --> 00:50:52,410
A następnie umieścić indeks
znak, który chcesz wydrukować.

1040
00:50:52,410 --> 00:50:55,960
Więc indeks ma być
number-- 0 lub 1, albo 2, albo 3, albo kropka

1041
00:50:55,960 --> 00:50:57,590
kropka, kropka, jakiś inny numer.

1042
00:50:57,590 --> 00:51:00,920
>> I mamy pewność, że to będzie
mieć odpowiednią liczbę, bo

1043
00:51:00,920 --> 00:51:02,360
rozpocznie odliczanie od 0.

1044
00:51:02,360 --> 00:51:07,020
I domyślnie pierwszy znak
w ciągu jest umownie 0.

1045
00:51:07,020 --> 00:51:09,230
I druga postać jest wspornik 1.

1046
00:51:09,230 --> 00:51:11,120
I trzecia postać jest uchwyt 2.

1047
00:51:11,120 --> 00:51:13,630
A ty nie chcesz iść za
daleko, ale nie dlatego, że jesteśmy

1048
00:51:13,630 --> 00:51:17,780
będzie tylko inkrementacja i dopóki nim
równa długości łańcucha.

1049
00:51:17,780 --> 00:51:20,210
I w tym momencie,
to dla pętli zostanie przerwane.

1050
00:51:20,210 --> 00:51:25,550
>> Więc pozwól mi iść do przodu i zapisać tę
program, a następnie uruchomić make ciąg 0.

1051
00:51:25,550 --> 00:51:28,400
Ale ja spieprzyłem.

1052
00:51:28,400 --> 00:51:35,390
Pośrednio deklarowania funkcji biblioteki
Stirling w rodzaju takiego, a such-- teraz

1053
00:51:35,390 --> 00:51:36,430
brzmi to znajomo.

1054
00:51:36,430 --> 00:51:37,440
Ale to nie jest printf.

1055
00:51:37,440 --> 00:51:38,540
I to nie uzyskać ciąg.

1056
00:51:38,540 --> 00:51:40,480
>> I nie zepsuć się
w ten sam sposób i tym razem.

1057
00:51:40,480 --> 00:51:45,100
Ale zauważmy tu trochę w dół
ponadto zawierać string.h nagłówka,

1058
00:51:45,100 --> 00:51:47,210
wyraźnie zapewnić
zgłoszenie o Stirling.

1059
00:51:47,210 --> 00:51:48,820
Więc nie jest tak naprawdę wskazówką tam.

1060
00:51:48,820 --> 00:51:51,670
>> I rzeczywiście okazuje się,
istnieje inny nagłówek pliku

1061
00:51:51,670 --> 00:51:53,970
że nie używałem
w klasie jeszcze, ale to

1062
00:51:53,970 --> 00:51:56,480
spośród tych dostępnych
do was, zwany string.h.

1063
00:51:56,480 --> 00:52:00,930
I w tym pliku, string.h
Stirling jest zadeklarowana.

1064
00:52:00,930 --> 00:52:05,220
Więc pozwól mi iść do przodu i
zapisz to, aby ciąg

1065
00:52:05,220 --> 00:52:08,040
0-- ładne, żadne komunikaty o błędach i tym razem.

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla i
Mam zamiar naciśnij Enter,

1067
00:52:12,290 --> 00:52:16,710
w którym momencie getString dzieje
aby powrócić ciąg, umieścić go w s.

1068
00:52:16,710 --> 00:52:21,890
Potem, że dla pętli będzie iteracyjne
w ciągu znaków s: po jednym na raz,

1069
00:52:21,890 --> 00:52:28,420
i wydrukować je jeden na linię, ponieważ
Miałem tego ukośnika n na końcu.

1070
00:52:28,420 --> 00:52:34,530
Mogłem więc pominąć ten ukośnik
n, a następnie po prostu wydrukować Zamyla wszystko

1071
00:52:34,530 --> 00:52:37,460
w tym samym wierszu
skutecznie reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf, co nie jest tak użyteczne.

1073
00:52:38,999 --> 00:52:40,540
Ale w tym przypadku, nie zrobiłeś tego.

1074
00:52:40,540 --> 00:52:43,610
Ja faktycznie drukowane
znak naraz, po jednej w wierszu,

1075
00:52:43,610 --> 00:52:45,400
tak, że właściwie zobaczyć efekt.

1076
00:52:45,400 --> 00:52:46,900
>> Ale należy pamiętać, że jedną rzecz tutaj.

1077
00:52:46,900 --> 00:52:48,930
I będziemy wracać do
to w przyszłości tygodnia.

1078
00:52:48,930 --> 00:52:52,650
Okazuje się, że ta
Kod jest potencjalnie wadliwy.

1079
00:52:52,650 --> 00:52:56,560
>> Okazuje się, że ciąg get
i niektóre inne funkcje w życiu

1080
00:52:56,560 --> 00:53:00,280
niekoniecznie zawsze
powrót co czekasz.

1081
00:53:00,280 --> 00:53:03,010
Wiemy z ostatniej klasy
Czas na to, że się

1082
00:53:03,010 --> 00:53:04,960
Łańcuch powinien zwrócić ciąg.

1083
00:53:04,960 --> 00:53:09,900
Ale co zrobić, jeśli użytkownik wpisze taką
długie słowo lub ust lub esej

1084
00:53:09,900 --> 00:53:13,010
że po prostu nie jest wystarczająco
Pamięć w komputerze, aby zmieścił.

1085
00:53:13,010 --> 00:53:15,410
>> Jak, co, jeśli coś pójdzie
złego pod maską?

1086
00:53:15,410 --> 00:53:18,400
Może nie zdarza się często,
ale może się zdarzyć raz

1087
00:53:18,400 --> 00:53:21,520
na jakiś czas, bardzo rzadko.

1088
00:53:21,520 --> 00:53:25,460
I tak okazuje się, że ciąg get
i funkcje, takie jak to zrobić, niekoniecznie

1089
00:53:25,460 --> 00:53:26,380
zawsze zwraca ciągi.

1090
00:53:26,380 --> 00:53:30,680
Mogą powrócić jakąś wartość błędu,
jakaś wartość Sentinel że tak powiem,

1091
00:53:30,680 --> 00:53:32,612
który informuje
coś poszło nie tak.

1092
00:53:32,612 --> 00:53:35,320
A czy wiesz, że to tylko z
dowiedziawszy się go w klasie teraz

1093
00:53:35,320 --> 00:53:37,700
lub po przeczytaniu trochę więcej dokumentacji.

1094
00:53:37,700 --> 00:53:43,120
Okazuje się, że ciąg get
może zwrócić wartość o nazwie NULL.

1095
00:53:43,120 --> 00:53:46,220
Null jest szczególną wartością, że będziesz
wrócić w przyszłym tygodniu.

1096
00:53:46,220 --> 00:53:50,420
Ale teraz, po prostu wiem, że jeśli chcę
być naprawdę właściwa w posuwają się naprzód

1097
00:53:50,420 --> 00:53:52,650
używając get ciąg, I
Nie powinno się nazywać,

1098
00:53:52,650 --> 00:53:56,870
i ślepo użyć jego wartości zwracanej,
ufając, że jest to ciąg znaków.

1099
00:53:56,870 --> 00:53:59,420
>> Najpierw jednak muszę powiedzieć,
hej, chwileczkę tylko

1100
00:53:59,420 --> 00:54:03,380
postępować, jeśli ów nie równa
null, gdzie null, znowu,

1101
00:54:03,380 --> 00:54:04,660
to tylko niektóre specjalną wartość.

1102
00:54:04,660 --> 00:54:07,770
I jest to jedyna wartość specjalnymi
trzeba się martwić o Get ciąg.

1103
00:54:07,770 --> 00:54:10,900
Uzyskaj ciąg jest albo będzie
zwraca ciąg lub null.

1104
00:54:10,900 --> 00:54:17,219
>> A ten wykrzyknik znak równości
Może być może wiesz z lekcji matematyki

1105
00:54:17,219 --> 00:54:20,510
które można wyciągnąć z znak równości
linia przez to, aby wskazać nie równe.

1106
00:54:20,510 --> 00:54:23,135
To nie jest na ogół postać
można wpisać na klawiaturze.

1107
00:54:23,135 --> 00:54:26,480
I tak w większości języków programowania,
gdy chcesz powiedzieć nie jest równa,

1108
00:54:26,480 --> 00:54:29,160
użyć wykrzyknika,
zwie hukiem.

1109
00:54:29,160 --> 00:54:33,180
Więc mówisz Bang równa, co
Oznacza to nie równa się logicznie.

1110
00:54:33,180 --> 00:54:38,060
To tak jak nie jest większa
lub równa lub mniejsza niż

1111
00:54:38,060 --> 00:54:41,270
lub równe klawisz na klawiaturze
że robi to wszystko w jednym symbolu.

1112
00:54:41,270 --> 00:54:44,020
To dlatego w ostatnich przykładach
zrobiłeś otwarty nawias kwadratowy, a następnie

1113
00:54:44,020 --> 00:54:48,670
znak równości, aby zrobić
większa lub, powiedzmy, mniej niż.

1114
00:54:48,670 --> 00:54:49,910
>> Więc co jest tu na wynos?

1115
00:54:49,910 --> 00:54:53,880
To jest po prostu sposobem obecnie z
wprowadzenie tej składni, funkcja ta,

1116
00:54:53,880 --> 00:54:57,390
iteracji na indywidualne
znaków w ciągu.

1117
00:54:57,390 --> 00:55:00,260
I podobnie jak te placu
uchwyty pozwalają uzyskać na nich,

1118
00:55:00,260 --> 00:55:03,790
brać pod uwagę kwadratowych nawiasach
rodzaj podpowiedzi na to bazowy

1119
00:55:03,790 --> 00:55:06,040
projekt, w którym każda
znaków wewnątrz łańcucha

1120
00:55:06,040 --> 00:55:10,180
jest rodzajem zapakowane w gdzieś pod spodem
kaptur w pamięci komputera.

1121
00:55:10,180 --> 00:55:12,340
>> Ale zróbmy wariant tego.

1122
00:55:12,340 --> 00:55:14,880
Okazuje się, że ta
Program jest poprawny.

1123
00:55:14,880 --> 00:55:18,810
Więc na osiach CS50 dla oceny
Kod ten jest poprawny.

1124
00:55:18,810 --> 00:55:22,959
Szczególnie teraz, że jestem sprawdzanie
null, program ten nie powinien upaść.

1125
00:55:22,959 --> 00:55:24,500
A ja po prostu wiem, że z doświadczenia.

1126
00:55:24,500 --> 00:55:28,040
Ale nie ma nic innego,
naprawdę możemy udać się tutaj.

1127
00:55:28,040 --> 00:55:31,860
Ale to nie jest bardzo dobrze zaprojektowane,
bo wróćmy do podstaw.

1128
00:55:31,860 --> 00:55:34,450
>> Najpierw principles--
co robi dla pętli zrobić?

1129
00:55:34,450 --> 00:55:36,290
A dla pętli robi trzy rzeczy.

1130
00:55:36,290 --> 00:55:39,340
Inicjuje niektóre
wartość, jeśli zapytać go.

1131
00:55:39,340 --> 00:55:41,770
Sprawdza warunek.

1132
00:55:41,770 --> 00:55:45,380
A potem po każdym
iteracji, po każdym cyklu

1133
00:55:45,380 --> 00:55:49,330
zwiększa to jakiś
wartość lub wartości, tutaj.

1134
00:55:49,330 --> 00:55:50,600
>> Więc co to znaczy?

1135
00:55:50,600 --> 00:55:52,940
My zainicjować I do 0.

1136
00:55:52,940 --> 00:55:58,610
Mamy sprawdzić i upewnić się, że jest mniejsza niż
Długość S, który jest Z-A-M-T-L-A,

1137
00:55:58,610 --> 00:55:59,900
tak, która jest mniejsza niż 6.

1138
00:55:59,900 --> 00:56:02,590
I rzeczywiście, 0 za mniej niż 6.

1139
00:56:02,590 --> 00:56:05,580
>> Drukujemy z oo od nazwy Zamyla użytkownika.

1140
00:56:05,580 --> 00:56:08,080
Potem inkrementacja i od 0 do 1.

1141
00:56:08,080 --> 00:56:11,290
Następnie sprawdzić, czy jeden mniej
od długości s?

1142
00:56:11,290 --> 00:56:13,270
Długość s wynosi 6.

1143
00:56:13,270 --> 00:56:13,950
Tak to jest.

1144
00:56:13,950 --> 00:56:16,880
>> Więc wydrukować nazwy Zamyla, w ZA.

1145
00:56:16,880 --> 00:56:20,090
Zwiększamy i z 0, 1, do 2.

1146
00:56:20,090 --> 00:56:23,720
Następnie sprawdzamy, czy mniej niż 2
długość nazwy Zamyla użytkownika.

1147
00:56:23,720 --> 00:56:25,380
6- SO2 jest mniejsza niż 6.

1148
00:56:25,380 --> 00:56:30,460
Tak, niech wydrukować teraz M w
Nazwa Zamyla za trzeci znak.

1149
00:56:30,460 --> 00:56:34,110
>> Kluczem jest to, że na każdym
iteracja historii, jestem sprawdzenia,

1150
00:56:34,110 --> 00:56:37,810
i jest mniejsza niż długość Zamyla?

1151
00:56:37,810 --> 00:56:40,350
Ale jest haczyk
Stirling nie jest własnością.

1152
00:56:40,350 --> 00:56:43,100
Ci z was, którzy zaprogramowany
wcześniej w Java lub innych językach

1153
00:56:43,100 --> 00:56:46,310
może znać długość łańcucha jest
własność, tylko niektóre tylko do odczytu wartości.

1154
00:56:46,310 --> 00:56:50,220
>> W ° C, w tym przypadku, jeśli jest to
funkcja, która jest dosłownie

1155
00:56:50,220 --> 00:56:53,520
zliczanie liczby
znaków Zamyla za każdym razem

1156
00:56:53,520 --> 00:56:54,740
nazywamy tę funkcję.

1157
00:56:54,740 --> 00:56:58,500
Za każdym razem zapytać komputer, aby użyć
Stirling, to przyjrzeniu Zamyla,

1158
00:56:58,500 --> 00:57:01,960
mówiąc: Z-A-M-Y-L-A, 6.

1159
00:57:01,960 --> 00:57:02,962
I zwraca 6.

1160
00:57:02,962 --> 00:57:04,920
Następnym razem, kiedy zadzwonić
to, że wewnątrz pętli for,

1161
00:57:04,920 --> 00:57:08,610
to będzie wyglądać w Zamyla
ponownie, np Z-A-M-T-L-A, 6.

1162
00:57:08,610 --> 00:57:10,320
I to się dzieje, aby powrócić 6.

1163
00:57:10,320 --> 00:57:12,980
Więc co jest głupie o tym projekcie?

1164
00:57:12,980 --> 00:57:17,700
>> Dlaczego mój kod nie na 5 z 5
do projektowania teraz, że tak powiem?

1165
00:57:17,700 --> 00:57:20,600
Cóż, pytam
Pytanie niepotrzebnie.

1166
00:57:20,600 --> 00:57:23,030
Robię więcej pracy, niż muszę.

1167
00:57:23,030 --> 00:57:25,370
>> Więc nawet jeśli
odpowiedź jest poprawna, jestem

1168
00:57:25,370 --> 00:57:29,560
zwracając się do komputera, co jest
długość Zamyla ponownie

1169
00:57:29,560 --> 00:57:31,380
i znowu, i znowu, i znowu?

1170
00:57:31,380 --> 00:57:33,980
I że odpowiedź jest
nigdy nie ulegnie zmianie.

1171
00:57:33,980 --> 00:57:35,900
To zawsze będzie 6.

1172
00:57:35,900 --> 00:57:39,730
>> Dlatego lepszym rozwiązaniem niż to
byłaby to kolejna wersja.

1173
00:57:39,730 --> 00:57:43,390
Pozwólcie mi iść do przodu i umieścić go w
oddzielny plik o nazwie string1.c,

1174
00:57:43,390 --> 00:57:44,990
tak aby go rozdzielić.

1175
00:57:44,990 --> 00:57:47,260
I okazuje się w sposób dla
Pętla, można rzeczywiście

1176
00:57:47,260 --> 00:57:50,210
zadeklarować kilka zmiennych jednocześnie.

1177
00:57:50,210 --> 00:57:53,460
>> Więc mam zamiar utrzymać I i ustawić go na 0.

1178
00:57:53,460 --> 00:57:56,190
Ale mam też zamiar
dodaj przecinek, i powiedzieć,

1179
00:57:56,190 --> 00:58:01,050
daj mi zmienną n, którego
wartość jest równa długości ciąg s.

1180
00:58:01,050 --> 00:58:09,410
A teraz, proszę, aby mój stan
tak długo, jak jest mniej niż n.

1181
00:58:09,410 --> 00:58:14,140
>> Tak więc w ten sposób, logika
identyczne pod koniec dnia.

1182
00:58:14,140 --> 00:58:18,280
Ale ja pamiętając
Wartość 6, w tym przypadku.

1183
00:58:18,280 --> 00:58:19,780
Jaka jest długość nazwy Zamyla za?

1184
00:58:19,780 --> 00:58:20,860
A ja wprowadzenie go w n.

1185
00:58:20,860 --> 00:58:23,050
>> A ja wciąż sprawdzając
warunek za każdym razem.

1186
00:58:23,050 --> 00:58:24,300
Czy 0 niecałe 6?

1187
00:58:24,300 --> 00:58:25,600
Czy jeden mniej niż 6?

1188
00:58:25,600 --> 00:58:28,600
Czy 2 mniej niż 6, i tak dalej?

1189
00:58:28,600 --> 00:58:31,914
>> Ale ja nie pytam komputer
znowu, i znowu, co jest

1190
00:58:31,914 --> 00:58:33,080
długość nazwy Zamyla za?

1191
00:58:33,080 --> 00:58:34,320
Jaka jest długość nazwy Zamyla za?

1192
00:58:34,320 --> 00:58:35,986
Jaka jest długość nazwy tego Zamyla za?

1193
00:58:35,986 --> 00:58:40,440
Ja dosłownie pamiętać, że pierwszy i
odpowiedzieć tylko w drugiej zmiennej n.

1194
00:58:40,440 --> 00:58:45,280
Więc to teraz byłby nie tylko
poprawne, ale także dobrze zaprojektowane.

1195
00:58:45,280 --> 00:58:46,670
>> Teraz, co o stylu?

1196
00:58:46,670 --> 00:58:48,866
Mam nazwie moje zmienne
dość dobrze, powiedziałbym.

1197
00:58:48,866 --> 00:58:50,240
Są teraz bardzo zwięzłe.

1198
00:58:50,240 --> 00:58:52,090
I to jest całkowicie w porządku.

1199
00:58:52,090 --> 00:58:55,120
>> Jeśli masz tylko jedno
ciąg w programie,

1200
00:58:55,120 --> 00:58:56,860
równie dobrze można nazwać S łańcucha.

1201
00:58:56,860 --> 00:58:59,370
Jeśli masz tylko jedną zmienną
liczenie w programie

1202
00:58:59,370 --> 00:59:00,710
równie dobrze można nazwać to ja.

1203
00:59:00,710 --> 00:59:03,500
Jeśli mają długość, n
jest super powszechne, jak również.

1204
00:59:03,500 --> 00:59:05,800
Ale nie skomentował żadnej z mojego kodu.

1205
00:59:05,800 --> 00:59:09,200
>> I już nie poinformował reader--
czy to moja TF lub TA,

1206
00:59:09,200 --> 00:59:12,460
lub po prostu colleague-- co ma
się dzieje w tym programie.

1207
00:59:12,460 --> 00:59:15,760
I tak, aby uzyskać dobry styl,
co chcę zrobić

1208
00:59:15,760 --> 00:59:24,580
Jest coś this--
jak poprosić użytkownika o wejściu.

1209
00:59:24,580 --> 00:59:26,670
I mógłbym przepisać
Ten dowolną liczbę sposobów.

1210
00:59:26,670 --> 00:59:35,630
>> Upewnij S- upewnić get
ciąg zwracany ciąg.

1211
00:59:35,630 --> 00:59:40,280
A następnie w here-- i to jest chyba
Najważniejszym comment-- iterate

1212
00:59:40,280 --> 00:59:44,450
ciągu znaków w jedna w danym czasie.

1213
00:59:44,450 --> 00:59:47,060
I mogę użyć dowolnego
Wybór języka angielskiego

1214
00:59:47,060 --> 00:59:49,650
tutaj do opisania każdego
tych fragmentów kodu.

1215
00:59:49,650 --> 00:59:52,740
>> Zauważ, że nie szuka
wypowiedzieć się na temat każdej linii kodu,

1216
00:59:52,740 --> 00:59:55,690
naprawdę tylko na interesujące
z nich, do tych, które

1217
00:59:55,690 --> 00:59:59,460
mają jakieś znaczenie, że może
chcesz mieć bardzo jasne dla kogoś

1218
00:59:59,460 --> 01:00:00,460
przeczytanie mojego kodu.

1219
01:00:00,460 --> 01:00:02,920
I dlaczego nazywasz się
Ciąg poprosić użytkownika o wejściu?

1220
01:00:02,920 --> 01:00:05,450
Mimo, że nie jest koniecznie
wszystko, opisowy.

1221
01:00:05,450 --> 01:00:09,340
Ale to pomaga opowiedzieć historię, ponieważ
Druga linia w tej historii jest to, upewnij się,

1222
01:00:09,340 --> 01:00:10,740
uzyskać ciąg zwracany ciąg.

1223
01:00:10,740 --> 01:00:14,260
>> I trzecia linia w tej historii jest to,
iteracyjne ciągu znaków w jedna

1224
01:00:14,260 --> 01:00:15,380
na czas.

1225
01:00:15,380 --> 01:00:17,920
A teraz po prostu na wszelki wypadek,
Mam zamiar iść do przodu i dodaj

1226
01:00:17,920 --> 01:00:24,560
jeszcze jeden komentarz, który właśnie
mówi druku i-ty znak w s.

1227
01:00:24,560 --> 01:00:26,520
Teraz, co zrobiłem
pod koniec dnia?

1228
01:00:26,520 --> 01:00:29,190
>> Dodałem trochę po angielsku
wyrazy w formie komentarzy.

1229
01:00:29,190 --> 01:00:32,700
Symbol ukośnik ukośnik oznacza, hej,
Komputer jest dla człowieka,

1230
01:00:32,700 --> 01:00:33,820
nie dla ciebie, komputer.

1231
01:00:33,820 --> 01:00:35,119
Więc są one ignorowane logicznie.

1232
01:00:35,119 --> 01:00:35,910
Są po prostu tam.

1233
01:00:35,910 --> 01:00:39,830
>> I rzeczywiście, CS50 IDE pokazuje je jako
szary, jako użyteczne, lecz nie klucz

1234
01:00:39,830 --> 01:00:41,000
do programu.

1235
01:00:41,000 --> 01:00:42,570
Zauważ, co można teraz zrobić.

1236
01:00:42,570 --> 01:00:44,950
Czy znasz C
programowania, czy nie,

1237
01:00:44,950 --> 01:00:47,722
może po prostu stanąć z powrotem na to
program, a następnie przejrzeć komentarze.

1238
01:00:47,722 --> 01:00:50,180
Pytaj użytkownika dla wejścia, upewnij się,
uzyskać ciąg zwracany ciąg,

1239
01:00:50,180 --> 01:00:53,009
iteracyjne ciągu znaków w s
po jednym na raz, drukowanie znaków

1240
01:00:53,009 --> 01:00:55,550
i-ty znak w S- ty nie
nawet spojrzeć na kod

1241
01:00:55,550 --> 01:00:57,270
aby zrozumieć, co czyni ten program.

1242
01:00:57,270 --> 01:01:00,280
A jeszcze lepiej, jeśli wyglądasz
w tym programie w ciągu tygodnia lub dwóch,

1243
01:01:00,280 --> 01:01:02,280
lub miesięcy lub lat,
Ty też nie masz

1244
01:01:02,280 --> 01:01:04,420
gapić się na kodzie,
próbując sobie przypomnieć,

1245
01:01:04,420 --> 01:01:06,630
co ja próbuje zrobić z tym kodem?

1246
01:01:06,630 --> 01:01:07,770
>> Powiedziałeś siebie.

1247
01:01:07,770 --> 01:01:11,660
Opisałeś to dla siebie,
lub jakiś kolega, albo TA lub TF.

1248
01:01:11,660 --> 01:01:14,860
A więc to będzie teraz
poprawne, a dobry projekt,

1249
01:01:14,860 --> 01:01:18,210
i ostatecznie dobry styl, jak również.

1250
01:01:18,210 --> 01:01:19,990
Więc nie miej to na uwadze.

1251
01:01:19,990 --> 01:01:22,200
>> Więc jest jeszcze jedna
co mam zamiar zrobić tutaj

1252
01:01:22,200 --> 01:01:28,240
które mogą ujawnić dokładnie to, co jest
dzieje się pod maską.

1253
01:01:28,240 --> 01:01:30,390
Więc jest ta funkcja
w C i innych języków,

1254
01:01:30,390 --> 01:01:33,010
nazywa typecasting
że albo pośrednio

1255
01:01:33,010 --> 01:01:37,250
lub wyraźnie pozwala na konwersję
danych z jednego do drugiego.

1256
01:01:37,250 --> 01:01:39,800
Mamy więc do czynienia
ile dziś z łańcuchów.

1257
01:01:39,800 --> 01:01:41,250
>> I łańcuchy są znaki.

1258
01:01:41,250 --> 01:01:44,910
Ale pamiętam z tygodnia
0, jakie są znaki?

1259
01:01:44,910 --> 01:01:49,334
Postacie są tylko abstrakcją
na szczycie numbers-- liczb dziesiętnych,

1260
01:01:49,334 --> 01:01:52,500
i cyfry dziesiętne są naprawdę tylko
abstrakcji na górze liczb binarnych,

1261
01:01:52,500 --> 01:01:53,720
jak określił go.

1262
01:01:53,720 --> 01:01:55,540
>> Więc znaki są numery.

1263
01:01:55,540 --> 01:01:58,410
I numery są znaki,
tylko w zależności od kontekstu.

1264
01:01:58,410 --> 01:02:01,250
I okazuje się, że w środku
programu komputerowego

1265
01:02:01,250 --> 01:02:06,830
można określić, jak chcesz wyglądać
u bitów wewnątrz tego programu?

1266
01:02:06,830 --> 01:02:10,400
>> Przypomnijmy, od tygodnia 0, które mieliśmy
ASCII, który jest po prostu ten kod

1267
01:02:10,400 --> 01:02:11,620
mapowania liter do liczb.

1268
01:02:11,620 --> 01:02:13,660
A my powiedzieliśmy, kapitał A jest 65.

1269
01:02:13,660 --> 01:02:15,860
Kapitału B wynosi 66 i tak dalej.

1270
01:02:15,860 --> 01:02:20,500
>> A informacja, że ​​mają zasadniczo na znaki
górny rząd tutaj, jak by je nazwać C,

1271
01:02:20,500 --> 01:02:23,400
znaków, a następnie
int w drugim rzędzie.

1272
01:02:23,400 --> 01:02:28,180
I okazuje się, można konwertować
płynnie między nimi, typowo.

1273
01:02:28,180 --> 01:02:30,042
A jeśli chcemy zrobić
to celowo, mamy

1274
01:02:30,042 --> 01:02:31,750
może chcieć zająć
coś takiego.

1275
01:02:31,750 --> 01:02:33,590
>> Możemy chcesz przekonwertować
wielkie litery, aby obniżyć

1276
01:02:33,590 --> 01:02:35,330
przypadek, czy małe litery na wielkie litery.

1277
01:02:35,330 --> 01:02:38,000
I okazuje się, istnieje
faktycznie wzór tutaj

1278
01:02:38,000 --> 01:02:39,900
możemy przyjąć za chwilę.

1279
01:02:39,900 --> 01:02:44,120
Ale spójrzmy najpierw na
Przykład ten sposób jawny.

1280
01:02:44,120 --> 01:02:46,340
>> Mam zamiar wrócić do CS50 IDE.

1281
01:02:46,340 --> 01:02:50,640
Mam zamiar stworzyć
plik o nazwie ASCII 0.c.

1282
01:02:50,640 --> 01:02:55,960
A ja zamierzam iść dalej i dodać moje
średnia io.h na górze, int main nieważne

1283
01:02:55,960 --> 01:02:57,370
w czubka funkcji.

1284
01:02:57,370 --> 01:03:02,700
I wtedy właśnie jadę zrobić
following-- pętli for z i równa,

1285
01:03:02,700 --> 01:03:04,610
powiedzmy, 65 lat.

1286
01:03:04,610 --> 01:03:10,460
>> I wtedy będzie mniej niż
65, a także 26 liter w alfabecie.

1287
01:03:10,460 --> 01:03:12,640
Więc dam komputer
do matematyki dla mnie tam.

1288
01:03:12,640 --> 01:03:15,100
I wtedy wewnątrz tej pętli
co mam zamiar drukować?

1289
01:03:15,100 --> 01:03:19,230
>> % C% i jest interpretacja odwrotnego ukośnika n.

1290
01:03:19,230 --> 01:03:21,290
A teraz chcę podłączyć dwóch wartości.

1291
01:03:21,290 --> 01:03:24,530
Mam tymczasowo umieścić pytanie
oznacza nie zaprosić na pytanie.

1292
01:03:24,530 --> 01:03:29,940
>> Chcę iteracyjne od 65 dalej
dla 26 liter alfabetu,

1293
01:03:29,940 --> 01:03:35,190
druk na każdej iteracji, które
Integralną równoważne bohatera.

1294
01:03:35,190 --> 01:03:38,299
Innymi słowy, chcę
iteracyjne drukowanie ponad 26 numerów

1295
01:03:38,299 --> 01:03:41,590
co znak ASCII, litera,
a co is-- odpowiadająca jej liczba

1296
01:03:41,590 --> 01:03:44,650
naprawdę tylko odtworzenie
wykres z tego slajdu.

1297
01:03:44,650 --> 01:03:47,010
Więc co powinno być te znaki zapytania?

1298
01:03:47,010 --> 01:03:51,760
>> Cóż, okazuje się, że na sekundę
trzeba po prostu być zmienna i.

1299
01:03:51,760 --> 01:03:53,860
Chcę zobaczyć, że jako liczby.

1300
01:03:53,860 --> 01:03:58,920
A środkowy argumentem
Tutaj mogę powiedzieć komputerowi

1301
01:03:58,920 --> 01:04:03,470
traktować tę liczbę całkowitą
I w postaci, w taki sposób,

1302
01:04:03,470 --> 01:04:05,880
aby go zastąpić tutaj proc C.

1303
01:04:05,880 --> 01:04:07,990
>> Innymi słowy, I,
Ludzki programista wiedzieć

1304
01:04:07,990 --> 01:04:09,865
są to tylko liczby
pod koniec dnia.

1305
01:04:09,865 --> 01:04:12,500
I wiem, że 65 powinna
mapa do pewnego charakteru.

1306
01:04:12,500 --> 01:04:15,310
Dzięki tej wyraźnej obsadzie
w nawiasie,

1307
01:04:15,310 --> 01:04:18,840
nazwa typu danych, które chcesz
przekonwertować oraz zamknięty nawias,

1308
01:04:18,840 --> 01:04:21,200
Można powiedzieć, że
komputer, hej, komputer,

1309
01:04:21,200 --> 01:04:24,130
przekształcić tę liczbę całkowitą char.

1310
01:04:24,130 --> 01:04:26,250
>> Więc kiedy uruchomić to
Program po kompilacji

1311
01:04:26,250 --> 01:04:29,740
Zobaczmy, co get-- robię ASCII 0.

1312
01:04:29,740 --> 01:04:33,020
Cholera to, co zrobiłem źle tutaj?

1313
01:04:33,020 --> 01:04:35,884
Korzystanie z identyfikatorem nierejestrowanej,
Wszystko w porządku, a nie zamierzone,

1314
01:04:35,884 --> 01:04:37,800
ale zobaczymy, jeśli nie możemy
Powodem przez to.

1315
01:04:37,800 --> 01:04:41,220
>> Więc linia five-- więc nie dostać
bardzo daleko przed zakręcania.

1316
01:04:41,220 --> 01:04:42,140
W porządku.

1317
01:04:42,140 --> 01:04:46,560
Więc dla linii 5 i równa 65-- widzę.

1318
01:04:46,560 --> 01:04:50,130
Dlatego należy pamiętać, że w C, w przeciwieństwie do niektórych
Języki, jeśli masz wcześniejsze zaprogramowanie

1319
01:04:50,130 --> 01:04:52,190
Doświadczenie, trzeba
powiedzieć komputerowi,

1320
01:04:52,190 --> 01:04:55,040
W odróżnieniu od zera, co
typ zmiennej jest.

1321
01:04:55,040 --> 01:04:56,860
>> I zapomniałem kluczową frazę tutaj.

1322
01:04:56,860 --> 01:04:59,200
Zgodnie pięciu, ja zacząłem używać i.

1323
01:04:59,200 --> 01:05:01,560
Ale ja nie powiedziałem C
jakich danych typu jest.

1324
01:05:01,560 --> 01:05:04,570
Więc mam zamiar iść tu i
powiedzieć, ah, sprawiają, że jest liczbą całkowitą.

1325
01:05:04,570 --> 01:05:07,050
>> Teraz mam zamiar iść do przodu i rekompilacji.

1326
01:05:07,050 --> 01:05:08,080
To ustalona, ​​że.

1327
01:05:08,080 --> 01:05:12,660
./ascii0 Enter, to niby chłodny.

1328
01:05:12,660 --> 01:05:15,360
Jest to nie tylko bardzo szybko
zwrócić się do komputera na to pytanie,

1329
01:05:15,360 --> 01:05:18,885
zamiast szukać go na szkiełku,
jest drukowany po jednej w wierszu A 65,

1330
01:05:18,885 --> 01:05:24,860
B 66, aż down-- odkąd
uczynił to 26 times-- do litery Z,

1331
01:05:24,860 --> 01:05:25,630
która wynosi 90.

1332
01:05:25,630 --> 01:05:27,790
I rzeczywiście, nieco
bardziej inteligentny będzie

1333
01:05:27,790 --> 01:05:31,030
były dla mnie nie polegać
na komputerze, aby dodać 26.

1334
01:05:31,030 --> 01:05:34,060
Mógłbym tak zrobić
90, a także, o ile

1335
01:05:34,060 --> 01:05:37,390
jak nie popełnić tego samego błędu dwa razy.

1336
01:05:37,390 --> 01:05:41,880
Chcę iść w górę przez
oo, a nie tylko w górę przez y.

1337
01:05:41,880 --> 01:05:44,000
>> Więc to wyraźne obsada.

1338
01:05:44,000 --> 01:05:47,860
Okazuje się, że ta
Nie jest nawet konieczne.

1339
01:05:47,860 --> 01:05:52,480
Pozwólcie mi iść do przodu i ponownie to
Kompilator i powtórka ASCII 0.

1340
01:05:52,480 --> 01:05:54,940
Okazuje się, że C jest dość silny.

1341
01:05:54,940 --> 01:05:57,150
>> I printf w szczególności
jest dość silny.

1342
01:05:57,150 --> 01:06:01,260
Jeśli po prostu zdać I dwa razy
dla obu zastępczych, printf

1343
01:06:01,260 --> 01:06:04,510
uświadomi sobie, och, dobrze cię znam
dał mi integer-- pewną liczbę,

1344
01:06:04,510 --> 01:06:06,380
jak 65 czy 90, czy cokolwiek innego.

1345
01:06:06,380 --> 01:06:10,170
Ale widzę, że chcesz mnie
format, ilość takiego znaku.

1346
01:06:10,170 --> 01:06:16,460
I tak można niejawnie oddanych printf
int do char dla Ciebie.

1347
01:06:16,460 --> 01:06:19,360
Więc to nie jest w ogóle problem.

1348
01:06:19,360 --> 01:06:23,100
>> Zauważmy jednak, z powodu tej równoważności
faktycznie możemy to zrobić również.

1349
01:06:23,100 --> 01:06:26,520
Pozwólcie mi iść do przodu i zrobić jeden
inna wersja this-- ASCII 1.c.

1350
01:06:26,520 --> 01:06:31,800
I zamiast iteracji nad
całkowitymi, może naprawdę zaskakująca

1351
01:06:31,800 --> 01:06:33,610
przez powtarzanie ciągu znaków.

1352
01:06:33,610 --> 01:06:37,660
Jeśli char c dostaje kapitału A, I
chce iść do przodu i to zrobić,

1353
01:06:37,660 --> 01:06:41,740
pod warunkiem, C jest mniejsza niż lub równa
do Z. kapitału iw każdej iteracji

1354
01:06:41,740 --> 01:06:45,690
Chcę zwiększyć C, mogę
Teraz w mojej linii printf tutaj

1355
01:06:45,690 --> 01:06:51,320
powiedzmy, procent C jest
procent i znowu, przecinek C.

1356
01:06:51,320 --> 01:06:57,200
>> A teraz mogę iść w innym kierunku,
oddając charakter jawnie

1357
01:06:57,200 --> 01:06:58,500
do liczby całkowitej.

1358
01:06:58,500 --> 01:07:00,560
Tak więc raz jeszcze, dlaczego chcesz to zrobić?

1359
01:07:00,560 --> 01:07:03,830
To trochę dziwne, aby rodzaj
liczyć w zakresie znaków.

1360
01:07:03,830 --> 01:07:07,430
>> Ale jeśli rozumiesz, co jest
dzieje się pod maską,

1361
01:07:07,430 --> 01:07:08,430
naprawdę nie ma magii.

1362
01:07:08,430 --> 01:07:13,060
Mówisz tak, hej, komputer daje
mi zmienną o nazwie C typu char.

1363
01:07:13,060 --> 01:07:16,520
Inicjalizacja go do kapitału A. A
zauważyć, apostrofów sprawę.

1364
01:07:16,520 --> 01:07:19,580
>> W przypadku znaków w C, wycofanie się z
W zeszłym tygodniu, należy użyć apostrofów.

1365
01:07:19,580 --> 01:07:23,720
Dla ciągów słów,
zwroty, należy użyć cudzysłowia.

1366
01:07:23,720 --> 01:07:27,210
OK, komputer, Rób tak, tak
Dopóki znakowy jest krótszy niż

1367
01:07:27,210 --> 01:07:28,050
lub równe z.

1368
01:07:28,050 --> 01:07:32,640
I wiem, że z mojego tabeli ASCII wszystkich
z tych kodów ASCII są ciągłe.

1369
01:07:32,640 --> 01:07:33,400
>> Nie ma żadnych przerw.

1370
01:07:33,400 --> 01:07:36,737
Więc to tylko od A do Z,
oddzielone jeden numer każdego.

1371
01:07:36,737 --> 01:07:38,820
A potem mogę zwiększyć
char, jeśli naprawdę chcesz.

1372
01:07:38,820 --> 01:07:40,390
Pod koniec dnia,
to tylko liczba.

1373
01:07:40,390 --> 01:07:41,030
Wiem to.

1374
01:07:41,030 --> 01:07:43,670
Więc mogę tylko przypuszczać, aby dodać 1 do niego.

1375
01:07:43,670 --> 01:07:46,940
>> A potem ten czas, mogę wydrukować c,
i równoważne całki.

1376
01:07:46,940 --> 01:07:50,170
I nie trzeba nawet wyraźnej obsady.

1377
01:07:50,170 --> 01:07:52,680
mogę pozwolić printf i tym
rysunek komputerowy rzeczy pomieszczenia

1378
01:07:52,680 --> 01:07:57,300
tak, że teraz, gdy biegnę
dokonać Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
Mam dokładnie to samo jak dobrze.

1380
01:08:01,520 --> 01:08:04,530
>> Bezużyteczny program though-- nikogo
będzie właściwie napisać oprogramowanie

1381
01:08:04,530 --> 01:08:07,549
aby dowiedzieć się, jaki był
numer, który mapuje do A lub B lub Z?

1382
01:08:07,549 --> 01:08:10,340
Po prostu będzie to Google lub
szukać go w Internecie, albo szukać go

1383
01:08:10,340 --> 01:08:11,650
na płytce, lub tym podobne.

1384
01:08:11,650 --> 01:08:13,520
Więc skąd ta rzeczywiście się przydatne?

1385
01:08:13,520 --> 01:08:15,960
>> Cóż, mówiąc, że
zjeżdżalnia, zauważysz tam

1386
01:08:15,960 --> 01:08:20,890
rzeczywisty wzór tutaj między wielkimi
i małe, że nie była przypadkowa.

1387
01:08:20,890 --> 01:08:23,760
Zauważ, że kapitał A jest 65.

1388
01:08:23,760 --> 01:08:25,830
Małe litery a wynosi 97.

1389
01:08:25,830 --> 01:08:29,649
A jak daleko jest niższa to przypadku?

1390
01:08:29,649 --> 01:08:32,649
>> Tak jak wiele jest 65 kroków od 97?

1391
01:08:32,649 --> 01:08:36,210
Tak więc 97 minus 65 jest 32.

1392
01:08:36,210 --> 01:08:37,910
Więc stolicą a wynosi 65.

1393
01:08:37,910 --> 01:08:39,939
Jeśli dodać do tego 32,
masz małe litery a.

1394
01:08:39,939 --> 01:08:43,729
I, równoważnie, jeśli odjąć 32,
wrócisz do kapitału A-- samo z B

1395
01:08:43,729 --> 01:08:46,380
do małej B, duże C do małej c.

1396
01:08:46,380 --> 01:08:50,670
>> Wszystkie te luki są 32 od siebie.

1397
01:08:50,670 --> 01:08:54,450
Teraz będzie się to wydawać, aby umożliwić nam
coś jak Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
Dokumenty Google lub funkcji, gdzie
Można wybrać wszystko, a potem mówią,

1399
01:08:57,729 --> 01:09:00,520
wszystko zmienić na małe litery lub
zmienić wszystko na wielkie litery,

1400
01:09:00,520 --> 01:09:03,840
lub zmienić tylko pierwsze słowo
kary na wielkie litery.

1401
01:09:03,840 --> 01:09:07,390
Możemy faktycznie coś zrobić
tak sobie.

1402
01:09:07,390 --> 01:09:12,645
>> Pozwólcie mi iść do przodu i zapisać plik
nazywany tutaj wykorzystać 0.c.

1403
01:09:12,645 --> 01:09:15,770
I chodźmy naprzód i wzbudzać program
że robi dokładnie to w następujący sposób.

1404
01:09:15,770 --> 01:09:18,460
Więc to biblioteki CS50.

1405
01:09:18,460 --> 01:09:21,430
I obejmują Standardowe we / wy.

1406
01:09:21,430 --> 01:09:22,787
>> I wiem, że to już wkrótce.

1407
01:09:22,787 --> 01:09:24,870
Więc mam zamiar umieścić go w
istnieje już string.h,

1408
01:09:24,870 --> 01:09:26,960
więc mam dostęp do
takie rzeczy jak Stirling,

1409
01:09:26,960 --> 01:09:29,620
a następnie int main pustkę, jak zwykle.

1410
01:09:29,620 --> 01:09:33,420
A potem mam zamiar iść do przodu
i czy dostaje się ciągi znaków,

1411
01:09:33,420 --> 01:09:35,032
tak aby uzyskać ciąg od użytkownika.

1412
01:09:35,032 --> 01:09:36,740
A potem mam zamiar
zrobić mój test dla pewności.

1413
01:09:36,740 --> 01:09:40,510
Jeżeli łańcuch nie równa null
to jest bezpieczne, aby kontynuować.

1414
01:09:40,510 --> 01:09:42,000
I co chcę robić?

1415
01:09:42,000 --> 01:09:48,700
Idę do iteracji od I jest równa 0,
oraz n do długości string s.

1416
01:09:48,700 --> 01:09:51,899
>> I mam zamiar to zrobić, tak długo, jak
I jest mniejsza niż n, a ja plus plusem.

1417
01:09:51,899 --> 01:09:55,060
Do tej pory, jestem naprawdę
pożyczanie pomysłów sprzed.

1418
01:09:55,060 --> 01:09:57,010
A teraz mam zamiar wprowadzić oddział.

1419
01:09:57,010 --> 01:09:59,635
>> Więc wracam do zera, gdzie
mieliśmy te widły w drodze,

1420
01:09:59,635 --> 01:10:05,110
aw zeszłym tygodniu w C. Mam zamiar
powiedzieć, czy i-ty znak w s

1421
01:10:05,110 --> 01:10:09,250
jest większa niż lub
równe małe litery a,

1422
01:10:09,250 --> 01:10:13,340
and-- w Scratch byś dosłownie
powiedzieć i, ale w C mówisz ampersand,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- oraz i-ty znak w s
jest mniejsza niż lub równa Małe litery Z,

1424
01:10:19,830 --> 01:10:21,780
zróbmy coś ciekawego.

1425
01:10:21,780 --> 01:10:27,020
Spójrzmy prawdzie w rzeczywistości wydrukować
znaków bez znaku nowej linii

1426
01:10:27,020 --> 01:10:31,760
to jest znak w ciągu,
i-ty znak w ciągu.

1427
01:10:31,760 --> 01:10:37,420
>> Ale chodźmy naprzód i
32 odjąć od niego.

1428
01:10:37,420 --> 01:10:42,120
Else if postać w
Ciąg, który szukamy

1429
01:10:42,120 --> 01:10:45,950
Nie jest pomiędzy małym a
i niewiele oo, śmiało

1430
01:10:45,950 --> 01:10:48,610
i po prostu wydrukować go bez zmian.

1431
01:10:48,610 --> 01:10:50,840
Dlatego wprowadziliśmy
Zapis ten nawias

1432
01:10:50,840 --> 01:10:53,560
dla naszych ciągi uzyskać u
i-ty znak w ciągu.

1433
01:10:53,560 --> 01:10:57,520
>> Dodałem trochę logiki warunkowej, jak
Scratch w zeszłotygodniowym jednego tygodnia, w którym

1434
01:10:57,520 --> 01:10:59,880
Ja tylko używając moja zasadnicza
zrozumienie tego, co jest

1435
01:10:59,880 --> 01:11:01,130
dzieje się pod maską.

1436
01:11:01,130 --> 01:11:04,190
Czy i-ty znak s
większa niż lub równa?

1437
01:11:04,190 --> 01:11:08,290
Podobnie jak to jest 97 lub 98,
lub 99 i tak dalej?

1438
01:11:08,290 --> 01:11:11,940
>> Ale jest również mniejsza lub równa
do wartości małymi Z?

1439
01:11:11,940 --> 01:11:16,210
A jeśli tak, to co ta linia oznacza?

1440
01:11:16,210 --> 01:11:20,250
14, jest to swego rodzaju
zarodki całej idei,

1441
01:11:20,250 --> 01:11:23,840
wykorzystać pisma,
prostu odejmując 32 od niego,

1442
01:11:23,840 --> 01:11:29,370
w tym przypadku, bo wiem, że za
wykres, jak moje numery są reprezentowane.

1443
01:11:29,370 --> 01:11:33,925
Więc idź naprzód i uruchomić to,
po kompilacji wykorzystać 0.c,

1444
01:11:33,925 --> 01:11:36,210
i uruchomić wykorzystać 0.

1445
01:11:36,210 --> 01:11:40,300
>> Załóżmy, wpisać coś takiego
Zamyla we wszystkich małych liter wejść.

1446
01:11:40,300 --> 01:11:42,780
A teraz mamy Zamyla we wszystkich wielkich liter.

1447
01:11:42,780 --> 01:11:45,050
Załóżmy wpisać Roba we wszystkich małych liter.

1448
01:11:45,050 --> 01:11:46,674
Spróbujmy Jason we wszystkich małych liter.

1449
01:11:46,674 --> 01:11:48,590
I trzymamy uzyskiwanie
zmuszony kapitalizacji.

1450
01:11:48,590 --> 01:11:50,960
Jest to drobny błąd, że
niby nie przewidzieli.

1451
01:11:50,960 --> 01:11:54,050
Zauważ, mój nowy wiersz kończy się
na tej samej linii, co ich nazw,

1452
01:11:54,050 --> 01:11:55,520
który czuje się trochę niechlujnie.

1453
01:11:55,520 --> 01:11:59,170
>> Więc mam zamiar udać się tutaj, a
faktycznie na zakończenie programu

1454
01:11:59,170 --> 01:12:02,110
wydrukować znak nowej linii.

1455
01:12:02,110 --> 01:12:03,160
To wszystko.

1456
01:12:03,160 --> 01:12:06,120
Z printf, nie trzeba
przechodzą w zmiennych lub kodu formatu.

1457
01:12:06,120 --> 01:12:08,460
Można dosłownie po prostu wydrukować
coś w rodzaju nowej linii.

1458
01:12:08,460 --> 01:12:13,529
>> Więc idź naprzód i dokonać
0 wykorzystać ponownie, uruchom go, Zamyla.

1459
01:12:13,529 --> 01:12:14,820
A teraz jest trochę ładniejsza.

1460
01:12:14,820 --> 01:12:17,274
Teraz, mój wiersz jest na osobnej nowej linii.

1461
01:12:17,274 --> 01:12:18,440
Więc to wszystko jest w porządku i dobre.

1462
01:12:18,440 --> 01:12:19,910
Więc to jest dobrym przykładem.

1463
01:12:19,910 --> 01:12:22,700
Ale ja nawet nie koniecznie
trzeba ciężko kodem 32.

1464
01:12:22,700 --> 01:12:23,350
Wiesz co?

1465
01:12:23,350 --> 01:12:26,350
Mógłbym say-- I nie zawsze
Pamiętam, jaka jest różnica.

1466
01:12:26,350 --> 01:12:29,330
>> Ale wiem, że gdybym
mają małą literę,

1467
01:12:29,330 --> 01:12:34,430
I przede wszystkim chcą odjąć off
bez względu na odległość jest między mała

1468
01:12:34,430 --> 01:12:39,160
A i duże A, bo jeśli przyjąć, że
wszystkich pozostałych liter są takie same

1469
01:12:39,160 --> 01:12:41,045
które powinny otrzymać pracę.

1470
01:12:41,045 --> 01:12:42,670
Ale zamiast tego zrobić, wiesz co?

1471
01:12:42,670 --> 01:12:44,240
Jest jeszcze inny sposób.

1472
01:12:44,240 --> 01:12:48,090
>> Jeśli to wykorzystać 1.c-- gdybym
umieścić, że w osobnym pliku.

1473
01:12:48,090 --> 01:12:51,030
Zróbmy 2.C. wykorzystać w następujący sposób.

1474
01:12:51,030 --> 01:12:53,060
Zamierzam tak naprawdę to posprzątać tutaj.

1475
01:12:53,060 --> 01:12:57,420
I zamiast nawet konieczności
wiedzieć, czy dbają o tych niskim poziomie

1476
01:12:57,420 --> 01:13:01,090
Szczegóły realizacji, a nie jestem
prostu wydrukować znak,

1477
01:13:01,090 --> 01:13:04,610
cytat cytatu, procent C i
następnie wywołać inną funkcję, która

1478
01:13:04,610 --> 01:13:09,950
istnieje, że przyjmuje argument,
która to postać, o tak.

1479
01:13:09,950 --> 01:13:12,630
>> Okazuje się w C, nie
kolejna wywołanie funkcji

1480
01:13:12,630 --> 01:13:15,550
do górnej, która jak jej nazwa
Sugeruje wykonuje znak

1481
01:13:15,550 --> 01:13:19,350
i sprawia, że ​​w górnym przypadku
odpowiednik, a następnie zwraca je

1482
01:13:19,350 --> 01:13:21,410
tak, że printf można podłączyć go tam.

1483
01:13:21,410 --> 01:13:25,484
I tak to zrobić, choć,
trzeba wprowadzić jeszcze jeden plik.

1484
01:13:25,484 --> 01:13:28,400
Okazuje się, że jest inny plik
które znasz tylko z klasą,

1485
01:13:28,400 --> 01:13:33,020
lub podręcznik, albo on-line
odniesienia, zwany C type.h.

1486
01:13:33,020 --> 01:13:38,570
>> Więc jeśli dodam, że nawet wśród moich nagłówku
pliki, a teraz ponownie skompilować ten program,

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 Enter.

1488
01:13:43,040 --> 01:13:46,690
Załóżmy wpisać Zamyla we wszystkich
małe, nadal działa tak samo.

1489
01:13:46,690 --> 01:13:48,040
Ale wiesz co?

1490
01:13:48,040 --> 01:13:55,590
Okazuje się, że do górnego
ma jakieś inne funkcjonalności.

1491
01:13:55,590 --> 01:13:58,410
>> I niech mi przedstawić tę
dowodzić tutaj, jakby niezręcznie

1492
01:13:58,410 --> 01:14:00,250
nazwany, ale człowiek w podręczniku.

1493
01:14:00,250 --> 01:14:03,960
Okazuje się, że większość komputerów Linux,
jak używamy here-- operacyjny Linux

1494
01:14:03,960 --> 01:14:06,270
system-- mają polecenie
nazywany człowiekiem, który mówi,

1495
01:14:06,270 --> 01:14:08,530
hej, komputer, daj mi
obsługi komputera.

1496
01:14:08,530 --> 01:14:10,680
Co chcesz
patrzeć w tym podręczniku?

1497
01:14:10,680 --> 01:14:13,840
>> Chcę spojrzeć na funkcję
wezwany do górnej, Enter.

1498
01:14:13,840 --> 01:14:16,070
I to jest trochę tajemniczy
czytać czasami.

1499
01:14:16,070 --> 01:14:18,780
Należy jednak zauważyć, że jesteśmy w
Podręcznik programisty Linuksa.

1500
01:14:18,780 --> 01:14:19,530
I to jest cały tekst.

1501
01:14:19,530 --> 01:14:21,905
I zauważył, że nie jest
nazwa funkcji tutaj.

1502
01:14:21,905 --> 01:14:25,030
Okazuje się, że ma kuzynkę nazwie
obniżyć, która robi coś przeciwnego.

1503
01:14:25,030 --> 01:14:29,710
Oraz zawiadomienie na podstawie streszczenia, aby skorzystać z tej
funkcjonować na stronę man, że tak powiem,

1504
01:14:29,710 --> 01:14:32,220
mówi mi, że
muszą zawierać c type.h.

1505
01:14:32,220 --> 01:14:33,630
I wiedziałem, że z praktyki.

1506
01:14:33,630 --> 01:14:36,210
>> Tutaj, to pokazuje mi dwa
prototypy dla funkcji,

1507
01:14:36,210 --> 01:14:39,070
tak, że jeśli kiedykolwiek chcesz to wykorzystać
Wiem, co oni biorą na wejściu,

1508
01:14:39,070 --> 01:14:40,652
a co wrócą jako wyjście.

1509
01:14:40,652 --> 01:14:42,360
A potem, gdy czytam
opis, widzę

1510
01:14:42,360 --> 01:14:44,820
bardziej szczegółowo, co funkcja nie.

1511
01:14:44,820 --> 01:14:48,100
Ale co ważniejsze, jeśli
Patrzę na podstawie wartości zwracanej,

1512
01:14:48,100 --> 01:14:51,710
mówi wartość zwracana jest
przekształconej litery,

1513
01:14:51,710 --> 01:14:57,880
lub C, oryginalny wejściowy, jeżeli
konwersja nie była możliwa.

1514
01:14:57,880 --> 01:15:01,992
>> Innymi słowy, aby górna postara
przekonwertować do nas na wielkie litery.

1515
01:15:01,992 --> 01:15:03,450
A jeśli tak, to będzie go zwrócić.

1516
01:15:03,450 --> 01:15:07,010
Ale jeśli to nie może dla niektórych reason--
Może to już wielkie litery,

1517
01:15:07,010 --> 01:15:09,550
może to wykrzyknik
lub inne punctuation--

1518
01:15:09,550 --> 01:15:12,200
to po prostu będzie
powrót oryginalnego C,

1519
01:15:12,200 --> 01:15:17,340
co oznacza, że ​​mogę uczynić mój kod
lepiej określone poniżej.

1520
01:15:17,340 --> 01:15:20,580
>> Nie muszę wszystko
linie te darn kodu.

1521
01:15:20,580 --> 01:15:22,610
Wszystkie linie mam
może po prostu podświetlony

1522
01:15:22,610 --> 01:15:28,700
zostać przesunięte do jednej prostej
Linia, która jest this-- procent printf

1523
01:15:28,700 --> 01:15:33,510
c górnego wspornika S I.

1524
01:15:33,510 --> 01:15:36,090
I to byłoby
Przykładem lepszej konstrukcji.

1525
01:15:36,090 --> 01:15:40,040
>> Dlaczego wdrożyć w 7 lub 8 linii
kodu, cokolwiek to było po prostu

1526
01:15:40,040 --> 01:15:44,960
usunięte, kiedy można zamiast zwinąć
wszystkich, że logika i podejmowaniu decyzji

1527
01:15:44,960 --> 01:15:49,620
w jedną linię, 13 Teraz,
opiera się na bibliotece function--

1528
01:15:49,620 --> 01:15:53,430
funkcja, która pochodzi z C, ale to
robi dokładnie to, co chcesz to zrobić.

1529
01:15:53,430 --> 01:15:55,295
I, szczerze mówiąc, nawet jeśli
nie pochodzą z C,

1530
01:15:55,295 --> 01:15:58,880
można to realizować siebie, jak
widzieliśmy z dostać negatywną int

1531
01:15:58,880 --> 01:16:01,700
i uzyskać pozytywne int zeszłym tygodniu, jak również.

1532
01:16:01,700 --> 01:16:03,470
>> Kod ten jest teraz o wiele bardziej czytelny.

1533
01:16:03,470 --> 01:16:06,670
I rzeczywiście, jeśli będziemy przewijać w górę,
wyglądają jak wiele bardziej kompaktowy

1534
01:16:06,670 --> 01:16:08,360
ta wersja jest moim programie.

1535
01:16:08,360 --> 01:16:11,230
To trochę żelaznego teraz
Z tych wszystkich obejmuje.

1536
01:16:11,230 --> 01:16:14,380
Ale to jest OK, bo teraz stoję
na barkach programistów

1537
01:16:14,380 --> 01:16:15,300
przede mną.

1538
01:16:15,300 --> 01:16:18,440
A kto to był, kto
wdrożone do górnej naprawdę

1539
01:16:18,440 --> 01:16:21,470
zrobił mi przysługę, podobnie jak ten, kto
realizowane Stirling naprawdę

1540
01:16:21,470 --> 01:16:24,790
zrobił mi przysługę jakiś czas temu.

1541
01:16:24,790 --> 01:16:26,970
A więc teraz mamy
lepszy program do projektowania

1542
01:16:26,970 --> 01:16:31,680
który implementuje dokładnie taką samą logikę.

1543
01:16:31,680 --> 01:16:35,580
>> Mówiąc o Stirling, niech
mi iść naprzód i to zrobić.

1544
01:16:35,580 --> 01:16:38,320
Pozwólcie mi iść do przodu i zapisać
ten plik jako stirling.c.

1545
01:16:38,320 --> 01:16:43,255
I okazuje się, możemy obrać powrotem
jedna warstwa całkiem po prostu teraz.

1546
01:16:43,255 --> 01:16:45,630
Mam zamiar iść do przodu i bicz
do innego programu w głównym

1547
01:16:45,630 --> 01:16:49,759
tutaj po prostu ponownie narzędzi
Długość w następujący ciąg.

1548
01:16:49,759 --> 01:16:52,300
Tak oto wiersz kodu
dostaje mi ciąg od użytkownika.

1549
01:16:52,300 --> 01:16:53,910
Ciągle to znowu i znowu używać.

1550
01:16:53,910 --> 01:16:58,900
Podam sobie zmienną
n typu int, która przechowuje numer.

1551
01:16:58,900 --> 01:17:02,490
>> I pozwól mi iść do przodu i
wykonaj następującą logikę.

1552
01:17:02,490 --> 01:17:15,610
Podczas gdy n-ty znak w s robi
Nie równa backslash 0, śmiało

1553
01:17:15,610 --> 01:17:17,930
i przyrost n.

1554
01:17:17,930 --> 01:17:23,506
A następnie wydrukować printf procent I n.

1555
01:17:23,506 --> 01:17:29,200
I twierdzą, że ten program tutaj
bez wywoływania Długość łańcucha

1556
01:17:29,200 --> 01:17:31,150
domyśla się długość łańcucha.

1557
01:17:31,150 --> 01:17:34,600
>> A magia jest całkowicie
zawarta w linii 8

1558
01:17:34,600 --> 01:17:39,830
o tym, co wygląda jak nowy składni
Ten backslash 0 w pojedynczych cudzysłowach.

1559
01:17:39,830 --> 01:17:41,360
Ale dlaczego tak jest?

1560
01:17:41,360 --> 01:17:44,100
Cóż, należy rozważyć, co było
dzieje się cały ten czas.

1561
01:17:44,100 --> 01:17:47,990
>> I tak na marginesie, zanim zapomnę, realizować
również, że w uzupełnieniu do stron człowieka

1562
01:17:47,990 --> 01:17:50,920
które pochodzą z typowym
System Linux jak CS50 IDE

1563
01:17:50,920 --> 01:17:53,770
sobie sprawę, że my,
Pracownicy tego szkolenia, mają także

1564
01:17:53,770 --> 01:17:56,030
wykonany w wersji internetowej
tej samej idei zwanej

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net, które ma
wszystkie z tych samych stron podręcznika,

1566
01:17:59,940 --> 01:18:02,020
Wszystkie tego samego
dokumentacji, jak również

1567
01:18:02,020 --> 01:18:05,730
trochę okno na górze, która pozwala
konwertować wszystkie z dość

1568
01:18:05,730 --> 01:18:09,025
Język Arcane się mniej wygodne
Tryb, w którym my, grono pedagogiczne,

1569
01:18:09,025 --> 01:18:12,150
przeszły i starał się uprościć
niektóre z języka utrzymania rzeczy

1570
01:18:12,150 --> 01:18:14,830
koncentruje się na idei, a nie
niektóre szczegóły techniczne.

1571
01:18:14,830 --> 01:18:20,070
Dlatego należy pamiętać, reference.cs50.net
jako innego zasobu, jak również.

1572
01:18:20,070 --> 01:18:23,800
>> Ale dlaczego działa długości łańcucha IN
droga zaproponowałem przed chwilą?

1573
01:18:23,800 --> 01:18:25,160
Oto nazwy Zamyla znowu.

1574
01:18:25,160 --> 01:18:27,690
A oto nazwa Zamyla za
zapakowane w, jak to robić,

1575
01:18:27,690 --> 01:18:31,360
namalować obraz, że chodzi,
Naprawdę, po prostu ciągiem znaków.

1576
01:18:31,360 --> 01:18:34,260
Ale Zamyla nie istnieje
oddzielnie w programie.

1577
01:18:34,260 --> 01:18:37,420
>> Podczas pisania i uruchomienia programu,
używasz komputera Mac lub komputera

1578
01:18:37,420 --> 01:18:40,010
jak pamięć RAM, czy można tak powiedzieć.

1579
01:18:40,010 --> 01:18:42,620
A może myślisz
komputer jako posiadające

1580
01:18:42,620 --> 01:18:44,730
wiele gigabajtów pamięci te dni.

1581
01:18:44,730 --> 01:18:47,700
A koncert oznacza miliardy,
więc miliardy bajtów.

1582
01:18:47,700 --> 01:18:48,910
>> Ale bądźmy tyłu w czasie.

1583
01:18:48,910 --> 01:18:51,530
I załóżmy, że używamy
bardzo stary komputer, który

1584
01:18:51,530 --> 01:18:55,150
ma tylko 32 bajtów pamięci.

1585
01:18:55,150 --> 01:18:59,310
mogłem, na ekranie komputera,
po prostu zwrócić na to uwagę w następujący sposób.

1586
01:18:59,310 --> 01:19:05,240
>> Mogę tylko powiedzieć, że moje
Komputer posiada wszystkie te pamięci.

1587
01:19:05,240 --> 01:19:08,830
I to jest jak kij pamięci, pod warunkiem
pamiętacie nasz obraz z ostatniej chwili.

1588
01:19:08,830 --> 01:19:11,670
A jeśli po prostu podzielić
to na tyle razy,

1589
01:19:11,670 --> 01:19:15,040
I twierdzą, że mam 32 bajtów
pamięci na ekranie.

1590
01:19:15,040 --> 01:19:18,239
>> Teraz, w rzeczywistości, mogę tylko
zwrócić do tej pory na tym ekranie tutaj.

1591
01:19:18,239 --> 01:19:20,280
Więc mam zamiar iść do przodu,
i po prostu zwyczajowo

1592
01:19:20,280 --> 01:19:24,050
wyciągnąć pamięć mojego komputera jako
siatki, nie tylko jako jedna linia prosta.

1593
01:19:24,050 --> 01:19:28,190
Konkretnie, to twierdzą teraz, że
Siatka ta 8 przez 4 siatki,

1594
01:19:28,190 --> 01:19:31,800
po prostu reprezentuje wszystkie 32 bajtów
dostępnej pamięci w moim Macu

1595
01:19:31,800 --> 01:19:33,030
lub dostępny w moim komputerze.

1596
01:19:33,030 --> 01:19:34,780
A oni zawijania
na dwie linie, tak

1597
01:19:34,780 --> 01:19:38,030
dlatego, że pasuje tylko na ekranie.

1598
01:19:38,030 --> 01:19:40,800
Ale to jest pierwszy bajt.

1599
01:19:40,800 --> 01:19:41,990
Jest to drugi bajt.

1600
01:19:41,990 --> 01:19:43,300
Jest to trzeci bajt.

1601
01:19:43,300 --> 01:19:45,310
>> A to 32. bajt.

1602
01:19:45,310 --> 01:19:52,910
Lub, jeśli myślimy jak komputer
naukowca, to bajt 0, 1, 2, 3, 31.

1603
01:19:52,910 --> 01:19:55,950
Więc masz 0 do 31, jeśli
zacząć odliczanie od 0.

1604
01:19:55,950 --> 01:19:59,830
>> Więc jeśli używamy programu
która domaga się łańcuch,

1605
01:19:59,830 --> 01:20:05,280
i otrzymujemy ciąg z ludzkiego
jak ja nazywa Zamyla, Z-A-M-Y-L-A,

1606
01:20:05,280 --> 01:20:09,430
Jak na świecie robi
keep komputer utwór, którego bajt

1607
01:20:09,430 --> 01:20:12,230
którego fragment pamięci,
należący do którego ciąg?

1608
01:20:12,230 --> 01:20:16,270
Innymi słowy, przystępujemy do
wpisz inną nazwę do komputera,

1609
01:20:16,270 --> 01:20:19,890
jak ten Andi, nazywając
uzyskać ciąg po raz drugi,

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I ma się skończyć w
pamięci komputera, jak również.

1611
01:20:23,030 --> 01:20:23,850
Ale jak?

1612
01:20:23,850 --> 01:20:29,700
>> Cóż, okazuje się, że pod spodem
kaptur, co czyni C podczas przechowywania ciągów

1613
01:20:29,700 --> 01:20:35,080
że ludzki typu się lub że
pochodzić z innego źródła, to jest

1614
01:20:35,080 --> 01:20:39,190
wyznacza końcówkę mającą
specjalny character-- backslash

1615
01:20:39,190 --> 01:20:44,750
0, co jest po prostu szczególny sposób
mówić 80 bitów z rzędu.

1616
01:20:44,750 --> 01:20:47,950
>> Więc A-- to wycofanie numer 97.

1617
01:20:47,950 --> 01:20:51,770
Tak więc niektóre wzór 8 bitów
reprezentuje liczbę dziesiętną 97.

1618
01:20:51,770 --> 01:20:58,070
Ten backslash 0 jest dosłownie numer
0, a.k.a. nul, N-U-L, w odróżnieniu od wcześniejszych,

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L, która rozmawialiśmy.

1620
01:20:59,630 --> 01:21:05,700
Ale teraz, po prostu wiem, że ta
backslash 0 jest zaledwie 80 bity w jednym rzędzie.

1621
01:21:05,700 --> 01:21:09,810
>> I to właśnie ta linia w
Piasek, który mówi coś w lewo

1622
01:21:09,810 --> 01:21:12,610
należy do jednej strunie, lub jednego typu danych.

1623
01:21:12,610 --> 01:21:15,480
A wszystko z prawej strony
należący do czegoś innego.

1624
01:21:15,480 --> 01:21:17,440
Andi nazwa, tymczasem
które po prostu wizualnie

1625
01:21:17,440 --> 01:21:21,310
dzieje się owinąć na drugiej linii,
ale to tylko estetyczny szczegół,

1626
01:21:21,310 --> 01:21:23,990
Podobnie jest nul zakończone.

1627
01:21:23,990 --> 01:21:29,290
>> Jest to ciąg znaków a A-N-D-I,
Plus jedna piąta tajny charakter,

1628
01:21:29,290 --> 01:21:33,560
wszystkie 0 bitów, które po prostu rozgranicza
koniec nazwy Andi, jak również.

1629
01:21:33,560 --> 01:21:37,120
A jeśli nazywają się String raz trzeci
w komputerze, aby uzyskać ciąg jak

1630
01:21:37,120 --> 01:21:44,210
Maria, M-A-R-I-A, podobnie jest na Maria
Nazwa nul zakończone backslashem 0.

1631
01:21:44,210 --> 01:21:47,170
>> Jest to zasadniczo różne
od tego, jak komputer typowo

1632
01:21:47,170 --> 01:21:51,850
przechowywać liczbę całkowitą lub pływaka lub inna
Typy danych nadal, bo pamiętam,

1633
01:21:51,850 --> 01:21:57,420
liczbą całkowitą jest zazwyczaj 32 bity lub
4 bajty, a może nawet 64 bitów,

1634
01:21:57,420 --> 01:21:59,100
lub osiem bajtów.

1635
01:21:59,100 --> 01:22:02,620
Ale wielu prymitywów w komputerze
w języku programowania

1636
01:22:02,620 --> 01:22:05,550
mają stałą liczbę
bajty pod hood--

1637
01:22:05,550 --> 01:22:08,100
Może jeden, może dwa, może cztery, może osiem.

1638
01:22:08,100 --> 01:22:13,250
>> Ale łańcuchy, zgodne z projektem, mają
Numer dynamiczna znaków.

1639
01:22:13,250 --> 01:22:16,980
Nie wiem z góry, dopóki
ludzkie typy w Z-A-Y-M-L-A,

1640
01:22:16,980 --> 01:22:21,400
lub M-A-R-I-A lub A-N-D-I. Nie wiem
ile razy użytkownik będzie hit

1641
01:22:21,400 --> 01:22:22,070
klawiatura.

1642
01:22:22,070 --> 01:22:26,490
Dlatego nie wiem jak
wiele znaków z góry

1643
01:22:26,490 --> 01:22:27,540
będziesz potrzebować.

1644
01:22:27,540 --> 01:22:31,840
>> I tak C prostu rodzaj liści jak
Sekret breadcrumb pod maską

1645
01:22:31,840 --> 01:22:32,960
na końcu łańcucha.

1646
01:22:32,960 --> 01:22:39,280
Po przechowywaniu Z-A-M-Y-L-A, w pamięci
ale także po prostu kładzie równowartość

1647
01:22:39,280 --> 01:22:40,210
okresu.

1648
01:22:40,210 --> 01:22:45,060
Na końcu zdania,
stawia 80 bitów, tak

1649
01:22:45,060 --> 01:22:49,120
sobie przypomnieć, gdzie
Zamyla zaczyna i kończy.

1650
01:22:49,120 --> 01:22:51,490
>> Więc co to za gra,
Następnie do tego programu?

1651
01:22:51,490 --> 01:22:55,190
Ten program tutaj, Stirling,
Jest to mechanizm

1652
01:22:55,190 --> 01:22:57,970
uzyskania ciąg
od użytkownika, linia 6.

1653
01:22:57,970 --> 01:23:01,160
Linia 7, oświadczam zmienną
zwanego N i ustaw równe 0.

1654
01:23:01,160 --> 01:23:08,680
>> A następnie w linii 8, po prostu zapytał
Pytanie, natomiast postać n-ty robi

1655
01:23:08,680 --> 01:23:12,120
nie wszystkie równe 0 bits--
Innymi słowy, nie

1656
01:23:12,120 --> 01:23:14,500
równa ten specjalny
charakter, backslash 0, co

1657
01:23:14,500 --> 01:23:18,470
po prostu, że szczególną nul character--
śmiało i po prostu zwiększyć n.

1658
01:23:18,470 --> 01:23:21,460
>> A dalej to robić, i zachować
robi to, i dalej to robić.

1659
01:23:21,460 --> 01:23:23,430
I tak, chociaż w
przeszłości używaliśmy I,

1660
01:23:23,430 --> 01:23:25,181
to perfekcyjnie
semantycznie użyć n

1661
01:23:25,181 --> 01:23:27,430
jeśli jesteś po prostu staramy się
liczy tym razem świadomie,

1662
01:23:27,430 --> 01:23:28,720
i po prostu chcą nazwać n.

1663
01:23:28,720 --> 01:23:34,720
Więc to po prostu utrzymuje pytaniem na pytanie,
jest n-ty znak wszystko 0s?

1664
01:23:34,720 --> 01:23:38,470
Jeśli nie, spójrz na następny wygląd,
odwołać się do następnego, spójrz na następny,

1665
01:23:38,470 --> 01:23:39,460
patrzeć na następny.

1666
01:23:39,460 --> 01:23:45,540
>> Ale tak szybko, jak widać ukośnik 0,
Ten loop-- linii 9 do 11-- zatrzyma.

1667
01:23:45,540 --> 01:23:49,640
Możesz wyrwać się z pętli while,
pozostawiając w środku tej zmiennej n

1668
01:23:49,640 --> 01:23:54,530
całkowita liczba wszystkich?
znaki w ciągu widziałeś,

1669
01:23:54,530 --> 01:23:55,660
co drukuje go.

1670
01:23:55,660 --> 01:23:56,760
Warto więc spróbować.

1671
01:23:56,760 --> 01:23:59,500
>> Pozwólcie mi iść do przodu i bez
przy użyciu funkcji Stirling,

1672
01:23:59,500 --> 01:24:04,240
ale tylko przy użyciu własną wersję uczelnię
tutaj nazywane Stirling, pozwól mi iść do przodu

1673
01:24:04,240 --> 01:24:07,700
i uruchomić Stirling, typ w coś
jak Zamyla, które znam z góry

1674
01:24:07,700 --> 01:24:08,670
Jest sześć znaków.

1675
01:24:08,670 --> 01:24:10,080
Zobaczymy, czy to działa.

1676
01:24:10,080 --> 01:24:10,920
Rzeczywiście, jest to sześć.

1677
01:24:10,920 --> 01:24:15,257
Spróbujmy z Robem, trzy znaki,
trzy znaki, a także, i tak dalej.

1678
01:24:15,257 --> 01:24:17,340
Więc to wszystko, co się dzieje
się pod wyciągiem.

1679
01:24:17,340 --> 01:24:19,548
I zwróć uwagę na połączenia,
Następnie, w pierwszym tygodniu

1680
01:24:19,548 --> 01:24:22,370
klasy, gdzie rozmawialiśmy o
coś w abstrakcji,

1681
01:24:22,370 --> 01:24:26,960
który jest właśnie to nawarstwianie pomysłów lub
Złożoność, oprócz podstawowych zasad.

1682
01:24:26,960 --> 01:24:30,710
Tutaj mamy coś w rodzaju spojrzenie
pod maską Stirling,

1683
01:24:30,710 --> 01:24:33,510
by tak rzec, aby dowiedzieć się,
jak by to być realizowane?

1684
01:24:33,510 --> 01:24:35,232
>> I moglibyśmy ponownie wdrożyć go sami.

1685
01:24:35,232 --> 01:24:37,440
Ale my nigdy nie będzie ponownie
CMC Stirling.

1686
01:24:37,440 --> 01:24:39,780
Jesteśmy po prostu będzie
Aby skorzystać Stirling

1687
01:24:39,780 --> 01:24:42,100
faktycznie trochę długości łańcuchów.

1688
01:24:42,100 --> 01:24:44,200
>> Ale nie ma żadnego magicznego
pod wyciągiem.

1689
01:24:44,200 --> 01:24:46,716
Jeśli wiadomo, że pod spodem
kaptur, ciąg

1690
01:24:46,716 --> 01:24:48,090
jest po prostu ciągiem znaków.

1691
01:24:48,090 --> 01:24:51,090
I to ciąg znaków
wszystkie mogą być adresowane numerycznie

1692
01:24:51,090 --> 01:24:53,330
z uchwytem 0, wspornikiem
1, uchwyt 2, a ty

1693
01:24:53,330 --> 01:24:57,420
że na końcu łańcucha jest
Szczególny charakter, można dowiedzieć się,

1694
01:24:57,420 --> 01:25:01,710
jak to zrobić prawie wszystko w A
Program, ponieważ wszystko sprowadza się do

1695
01:25:01,710 --> 01:25:03,400
jest odczyt i zapis pamięci.

1696
01:25:03,400 --> 01:25:06,130
Oznacza to, że zmienia się i patrząc
w pamięci lub rzeczy ruchomych

1697
01:25:06,130 --> 01:25:10,940
wokół w pamięci, rzeczy drukarskie
na ekranie, i tak dalej.

1698
01:25:10,940 --> 01:25:14,800
>> Więc teraz używać w szał
Zrozumienie tego, co faktycznie struny

1699
01:25:14,800 --> 01:25:17,910
znajdują się pod maską, a
skórki z powrotem jedną inną warstwę

1700
01:25:17,910 --> 01:25:20,080
które do tej pory mamy
została ignorując całkowicie.

1701
01:25:20,080 --> 01:25:22,650
W szczególności, za każdym razem
mamy wdrożony program,

1702
01:25:22,650 --> 01:25:25,930
mieliśmy tego wiersza kodu
u góry deklarując głównym.

1703
01:25:25,930 --> 01:25:27,810
I mamy określone int main pustkę.

1704
01:25:27,810 --> 01:25:31,240
>> I to nieważne w nawiasach
został mówiąc cały ten czas, że głównym

1705
01:25:31,240 --> 01:25:33,440
Sam nie podejmuje żadnych argumentów.

1706
01:25:33,440 --> 01:25:36,210
Każde wejście, które jest głównym
dostanie od użytkownika

1707
01:25:36,210 --> 01:25:39,020
musi pochodzić z innego
Mechanizm ten, podobnie jak get int,

1708
01:25:39,020 --> 01:25:42,040
lub dostać pływaka, lub uzyskać ciąg,
lub inne funkcje.

1709
01:25:42,040 --> 01:25:44,710
Ale okazuje się, że
kiedy piszesz program,

1710
01:25:44,710 --> 01:25:47,690
rzeczywiście można określić
że program ten powinien

1711
01:25:47,690 --> 01:25:51,730
podjąć wejść od człowieka
w wierszu polecenia samego.

1712
01:25:51,730 --> 01:25:56,310
>> Innymi słowy, chociaż dotychczas
zostały uruchomione tylko ./hello komentarzy

1713
01:25:56,310 --> 01:26:00,312
lub podobnych programów, wszystkie
inne programy, które używaliśmy,

1714
01:26:00,312 --> 01:26:02,770
że my sami nie pisać,
mają zostały biorąc, wydaje się,

1715
01:26:02,770 --> 01:26:05,210
Linia komend arguments--
takie rzeczy zrobić.

1716
01:26:05,210 --> 01:26:07,450
Mówisz coś takiego uczynić,
a potem drugie słowo.

1717
01:26:07,450 --> 01:26:10,950
Albo dzyń, dzyń mówisz, a następnie
drugie słowo, nazwę pliku.

1718
01:26:10,950 --> 01:26:14,410
>> Lub nawet RM lub CP, jak może
Widziałeś już używany lub

1719
01:26:14,410 --> 01:26:15,880
usunąć lub skopiować pliki.

1720
01:26:15,880 --> 01:26:18,920
Wszystkie te podejmują tzw
Linia komend arguments--

1721
01:26:18,920 --> 01:26:21,130
Dodatkowe słowa w wierszu terminala.

1722
01:26:21,130 --> 01:26:23,260
Ale aż do teraz,
sami nie mieli

1723
01:26:23,260 --> 01:26:27,080
Ten luksusowy podejmowania wejście od
użytkownika, gdy on lub ona rzeczywiście działa

1724
01:26:27,080 --> 01:26:29,120
sam program w linii poleceń.

1725
01:26:29,120 --> 01:26:33,710
>> Ale możemy to zrobić poprzez ponowne deklarowania
Głównym posuwa się naprzód, a nie konieczności

1726
01:26:33,710 --> 01:26:36,750
unieważnić w nawiasach,
ale te dwa argumenty

1727
01:26:36,750 --> 01:26:40,600
instead-- pierwszej liczby całkowitej,
a drugi coś

1728
01:26:40,600 --> 01:26:44,170
nowego, coś, że mamy zamiar zadzwonić
tablicą, coś podobnego w duchu

1729
01:26:44,170 --> 01:26:49,220
do tego, co widzieliśmy w Scratch postaci listy, ale
Tablica ciągów znaków, a my wkrótce.

1730
01:26:49,220 --> 01:26:51,790
Ale zobaczmy to poprzez
Tytułem przykładu, zanim

1731
01:26:51,790 --> 01:26:53,690
rozróżnić co to dokładnie znaczy.

1732
01:26:53,690 --> 01:26:56,520
>> Więc jeśli pójdę do CS50 IDE
Tutaj Poszedłem do przodu

1733
01:26:56,520 --> 01:27:01,840
i zadeklarowane w pliku o nazwie
argv0.c następujący szablon.

1734
01:27:01,840 --> 01:27:04,120
I zauważył, że jedyną rzeczą
to co innego do tej pory

1735
01:27:04,120 --> 01:27:08,570
jest to, że zmieniłem nieważne na int
argc łańcuch argv wspornik otwarty, zamknij

1736
01:27:08,570 --> 01:27:09,070
wspornik.

1737
01:27:09,070 --> 01:27:11,730
I zauważyć na razie nie ma
nic wewnątrz tych nawiasach.

1738
01:27:11,730 --> 01:27:12,620
>> Nie ma żadnego numeru.

1739
01:27:12,620 --> 01:27:15,070
I nie ma i, lub
n, lub dowolny inny list.

1740
01:27:15,070 --> 01:27:17,010
Jestem po prostu za pomocą
nawiasy kwadratowe teraz,

1741
01:27:17,010 --> 01:27:19,510
ze względów wrócimy
z powrotem za chwilę.

1742
01:27:19,510 --> 01:27:21,330
>> A teraz, co mam zamiar zrobić to.

1743
01:27:21,330 --> 01:27:26,680
Jeśli argc równa równa 2--
i przypomnieć, że równa równych

1744
01:27:26,680 --> 01:27:30,040
jest operatorem równości porównywaniu
lewa i prawa do równości.

1745
01:27:30,040 --> 01:27:31,790
To nie jest przypisanie
Operator, który jest

1746
01:27:31,790 --> 01:27:36,510
pojedynczy znak równości, co oznacza kopię
od prawej do lewej strony, jakąś wartość.

1747
01:27:36,510 --> 01:27:42,840
>> Jeśli argc równa jest równa 2, chcę
powiedzmy, printf, hello, procenty, nowa linia,

1748
01:27:42,840 --> 01:27:47,340
a następnie podłącz in-- i oto nowa
trick-- wspornik argv 1, dla

1749
01:27:47,340 --> 01:27:48,840
że uda nam się wrócić za chwilę.

1750
01:27:48,840 --> 01:27:52,110
Else if argc nie
równe 2, wiesz co?

1751
01:27:52,110 --> 01:27:57,400
Niech po prostu iść do przodu i, jak zwykle, druku
z hello world bez zmiany.

1752
01:27:57,400 --> 01:28:02,710
>> Tak więc wydaje się, że jeśli argc, które
oznacza liczby argumentów jest równy 2,

1753
01:28:02,710 --> 01:28:04,740
Idę do wydrukowania
komentarzy lub coś innego.

1754
01:28:04,740 --> 01:28:07,560
W przeciwnym przypadku, jestem
oddawania do druku komentarzy świat.

1755
01:28:07,560 --> 01:28:08,770
Więc co to znaczy?

1756
01:28:08,770 --> 01:28:15,550
>> Cóż, pozwól mi iść do przodu i zapisać
ten plik, a następnie robią argv0,

1757
01:28:15,550 --> 01:28:18,940
a następnie ./argv0, Enter.

1758
01:28:18,940 --> 01:28:20,300
I to mówi hello world.

1759
01:28:20,300 --> 01:28:21,260
Teraz, dlaczego tak jest?

1760
01:28:21,260 --> 01:28:24,730
>> Cóż, okazuje się, w każdej chwili
uruchomić program z linii poleceń,

1761
01:28:24,730 --> 01:28:29,570
jesteś wypełnienie czego będziesz
ogólnie nazywamy wektor argumentów.

1762
01:28:29,570 --> 01:28:33,100
Innymi słowy, automatycznie
komputer, system operacyjny

1763
01:28:33,100 --> 01:28:38,340
zamierza przekazać do programu
Sama lista wszystkich słów

1764
01:28:38,340 --> 01:28:40,850
że ludzkie wpisane w
monit, w przypadku, gdy

1765
01:28:40,850 --> 01:28:43,790
programista chce zrobić
coś z tym informacji.

1766
01:28:43,790 --> 01:28:48,540
I w tym przypadku, jedynym słowem
Mam wpisane w wierszu jest ./argv0.

1767
01:28:48,540 --> 01:28:55,420
>> A więc liczba argumentów, które jest
są przekazywane do mojego programu jest tylko jeden.

1768
01:28:55,420 --> 01:28:58,880
Innymi słowy, argument
liczą, zwie argc

1769
01:28:58,880 --> 01:29:00,970
tutaj jako liczba całkowita, jest tylko jeden.

1770
01:29:00,970 --> 01:29:03,000
Jeden z nich, oczywiście, nie równa dwa.

1771
01:29:03,000 --> 01:29:05,980
A więc to, co wypisuje, hello świat.

1772
01:29:05,980 --> 01:29:08,170
>> Ale pozwól mi wziąć to gdzieś.

1773
01:29:08,170 --> 01:29:09,930
Pozwól mi powiedzieć, argv0.

1774
01:29:09,930 --> 01:29:12,740
A potem jak o Maria?

1775
01:29:12,740 --> 01:29:14,990
A następnie naciśnij Enter.

1776
01:29:14,990 --> 01:29:18,020
>> I zauważyć, co się dzieje tutaj magicznie.

1777
01:29:18,020 --> 01:29:22,640
Teraz, zamiast Hello World, mam
zmienił zachowanie tego programu

1778
01:29:22,640 --> 01:29:26,310
poprzez wejście nie z get
łańcuch lub inne funkcje,

1779
01:29:26,310 --> 01:29:30,570
lecz z widocznie mój rozkaz
Sam, co pierwotnie wpisana.

1780
01:29:30,570 --> 01:29:35,720
I mogę zagrać jeszcze raz tę grę
zmianie na Stelios, na przykład.

1781
01:29:35,720 --> 01:29:38,400
>> A teraz widzę jeszcze inną nazwę.

1782
01:29:38,400 --> 01:29:40,540
I tu, mogę powiedzieć, Andi.

1783
01:29:40,540 --> 01:29:42,137
I mogę powiedzieć, Zamyla.

1784
01:29:42,137 --> 01:29:45,220
I możemy grać w tę grę przez cały dzień,
po prostu podłączając różne wartości,

1785
01:29:45,220 --> 01:29:49,550
tak długo jak ja dostarczyć dokładnie
dwa słowa w wierszu,

1786
01:29:49,550 --> 01:29:52,260
takie, że argc, liczą mój argument, to 2.

1787
01:29:52,260 --> 01:29:57,240
>> Widzę, że nazwa podłączony do
printf, za ten stan tutaj?

1788
01:29:57,240 --> 01:30:00,550
Tak więc wydaje się, że teraz
zdolność ekspresyjna

1789
01:30:00,550 --> 01:30:04,410
podejmowania wejście z innego mechanizmu,
z tak zwanej linii polecenia

1790
01:30:04,410 --> 01:30:07,000
zamiast czekać
dopóki użytkownik uruchamia program,

1791
01:30:07,000 --> 01:30:10,220
a następnie skłonić go lub ją
używając coś Uzyskaj ciąg.

1792
01:30:10,220 --> 01:30:11,230
>> Więc co to jest?

1793
01:30:11,230 --> 01:30:15,010
Argc, ponownie, jest tylko liczbą całkowitą,
liczba words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
pod warunkiem, że użytkownik u
szybka, w oknie terminala

1795
01:30:18,540 --> 01:30:20,110
w tym nazwę programu.

1796
01:30:20,110 --> 01:30:23,340
Więc nasz ./argv0 jest skuteczne,
Nazwa programu,

1797
01:30:23,340 --> 01:30:24,520
lub jak uruchomić program.

1798
01:30:24,520 --> 01:30:25,810
>> To się liczy jako słowo.

1799
01:30:25,810 --> 01:30:27,080
Tak argc będzie 1.

1800
01:30:27,080 --> 01:30:29,750
Ale gdy piszę Stelios lub
Andi lub Zamyla lub Maria,

1801
01:30:29,750 --> 01:30:31,660
oznacza to, że liczba argument jest dwa.

1802
01:30:31,660 --> 01:30:33,910
I tak teraz jest dwa słowa przeszły w.

1803
01:30:33,910 --> 01:30:36,070
>> A informacja, możemy kontynuować tę logikę.

1804
01:30:36,070 --> 01:30:39,050
Jeśli tak naprawdę powiedzieć,
coś jak Zamyla Chan,

1805
01:30:39,050 --> 01:30:42,200
pełna nazwa, tym samym przechodząc
w sumie trzy argumenty,

1806
01:30:42,200 --> 01:30:47,410
Teraz znów mówi domyślny,
bo, oczywiście, 3 nie równa 2.

1807
01:30:47,410 --> 01:30:54,080
>> I tak w ten sposób, mam
Dostęp poprzez argv to nowy argument

1808
01:30:54,080 --> 01:30:56,080
że mogliśmy technicznie
zadzwonić cokolwiek chcemy.

1809
01:30:56,080 --> 01:30:58,940
Ale zgodnie z przyjętą konwencją, to
argv i argc, odpowiednio.

1810
01:30:58,940 --> 01:31:04,470
Argv, wektor argument jest dobry
stanowi synonim programowaniem

1811
01:31:04,470 --> 01:31:07,140
Funkcja w C nazywany tablicę.

1812
01:31:07,140 --> 01:31:14,410
>> Tablica znajduje się lista podobnych wartościach
wstecz, do tyłu, do tyłu, do tyłu.

1813
01:31:14,410 --> 01:31:17,810
Innymi słowy, jeśli ktoś jest tutaj w
RAM, następny jest tuż obok niego,

1814
01:31:17,810 --> 01:31:18,800
a tuż obok niego.

1815
01:31:18,800 --> 01:31:20,101
Nie są one w każdym miejscu.

1816
01:31:20,101 --> 01:31:23,100
I to ostatni scenariusz, gdzie rzeczy
Są w każdym miejscu w pamięci,

1817
01:31:23,100 --> 01:31:25,082
w rzeczywistości może być potężnym narzędziem.

1818
01:31:25,082 --> 01:31:28,040
Ale wrócimy do tego, kiedy
mówić o bardziej wyszukane struktur danych.

1819
01:31:28,040 --> 01:31:32,260
Na razie tablica jest po prostu
fragment pamięci ciągłej,

1820
01:31:32,260 --> 01:31:36,520
każdy z której elementy są
wstecz, do tyłu, do tyłu, do tyłu,

1821
01:31:36,520 --> 01:31:38,050
i ogólnie tego samego typu.

1822
01:31:38,050 --> 01:31:42,630
>> Więc jeśli myślisz o od A
Chwilę temu, co jest ciągiem?

1823
01:31:42,630 --> 01:31:50,460
Cóż, ciągiem, jak Zamyla,
Z-A-M-Y-L-A, jest technicznie

1824
01:31:50,460 --> 01:31:51,400
właśnie tablicą.

1825
01:31:51,400 --> 01:31:53,700
Jest to tablica znaków.

1826
01:31:53,700 --> 01:31:59,250
>> A więc jeśli naprawdę wyciągnąć to, jak ja
nie wcześniej, jako fragment pamięci,

1827
01:31:59,250 --> 01:32:04,510
Okazuje się, że każdy z
znaków zajmuje bajt.

1828
01:32:04,510 --> 01:32:07,630
A jeszcze, że szczególną
Charakter Sentinel, backslash 0,

1829
01:32:07,630 --> 01:32:12,360
lub wszystkie osiem bitów 0, to
rozgranicza koniec tego łańcucha.

1830
01:32:12,360 --> 01:32:15,090
Zatem ciąg okazuje
out Koniec cytatu ciąg,

1831
01:32:15,090 --> 01:32:20,580
jest tylko tablicą chara--
char jest rzeczywisty typ danych.

1832
01:32:20,580 --> 01:32:24,560
>> A teraz argv, meanwhile--
wróćmy do programu.

1833
01:32:24,560 --> 01:32:29,582
Argv, choć widzimy słowo
Ciąg tu nie jest sam łańcuch.

1834
01:32:29,582 --> 01:32:33,640
Argv, wektor argument
jest tablicą ciągów.

1835
01:32:33,640 --> 01:32:37,620
>> Więc jak można mieć tablicę
znaków, można mieć wyższy poziom,

1836
01:32:37,620 --> 01:32:46,279
tablicą strings-- Tak więc, na przykład,
kiedy wpisany przed chwilą ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0 przestrzeń Z-A-M-T-L-A, i stwierdził, że
argv miał dwa ciągi w it-- ./argv0,

1838
01:33:00,150 --> 01:33:03,185
i Z-A-M-T-L-A. W
Innymi słowy, argc był 2.

1839
01:33:03,185 --> 01:33:03,980
Dlaczego?

1840
01:33:03,980 --> 01:33:08,370
>> Dobrze, skutecznie, co się dzieje
na to, że każdy z tych łańcuchów

1841
01:33:08,370 --> 01:33:13,990
Jest, oczywiście, tablica znaków
Tak jak poprzednio, u których wielkość znaków

1842
01:33:13,990 --> 01:33:15,670
zajmuje jeden bajt.

1843
01:33:15,670 --> 01:33:19,720
I nie mylić rzeczywistej 0
nazwy programu z 0,

1844
01:33:19,720 --> 01:33:22,040
co oznacza, że ​​wszystkie 80 bitów.

1845
01:33:22,040 --> 01:33:27,140
I Zamyla tymczasem nadal jest
również tablica znaków.

1846
01:33:27,140 --> 01:33:31,450
>> Tak więc na koniec dnia, to naprawdę
wygląda pod maską.

1847
01:33:31,450 --> 01:33:38,800
Ale argv, przez naturę, jak główny
Prace, pozwala mi zawinąć wszystko

1848
01:33:38,800 --> 01:33:44,810
aż się, jeśli chcesz, większą tablicę
, Że jeśli mamy nieco ponad uprościć

1849
01:33:44,810 --> 01:33:48,180
co obraz wygląda i nie
dość wyciągnąć go skalować się tam,

1850
01:33:48,180 --> 01:33:56,720
Tablica ta jest tylko o wielkości 2, pierwszy
element, który zawiera fragment,

1851
01:33:56,720 --> 01:33:59,230
drugi element
która zawiera ciąg.

1852
01:33:59,230 --> 01:34:01,687
A z kolei jeśli ciebie
rodzaj powiększyć każde

1853
01:34:01,687 --> 01:34:03,770
z tych ciągów, co
patrz pod maską

1854
01:34:03,770 --> 01:34:07,190
jest to, że każdy łańcuch jest tak
tablica znaków.

1855
01:34:07,190 --> 01:34:11,680
>> Teraz, podobnie jak z łańcuchami,
byliśmy w stanie uzyskać dostęp

1856
01:34:11,680 --> 01:34:15,260
dla i-tego znaku w ciągu
przy użyciu tego uchwytu kwadratowy notacji.

1857
01:34:15,260 --> 01:34:17,320
Podobnie, z tablicami
w ogóle, możemy

1858
01:34:17,320 --> 01:34:22,700
używać notacji nawiasu kwadratowego, aby uzyskać
w dowolnej liczbie strun w tablicy?

1859
01:34:22,700 --> 01:34:25,100
Na przykład, niech mnie
śmiało i to zrobić.

1860
01:34:25,100 --> 01:34:32,420
>> Pozwól mi iść dalej i stworzyć argv1.c,
który jest trochę inaczej tym razem.

1861
01:34:32,420 --> 01:34:35,635
Zamiast sprawdzania argc2,
Idę zamiast tego zrobić.

1862
01:34:35,635 --> 01:34:41,270
Dla int uzyskać 0, I jest mniej
niż argc, ja plus plus

1863
01:34:41,270 --> 01:34:47,920
a następnie wydrukować wewnątrz tego
procent s, nowa linia, a następnie

1864
01:34:47,920 --> 01:34:50,740
argv uchwyt i.

1865
01:34:50,740 --> 01:34:55,220
>> Więc innymi słowy, nie mam do czynienia z
Poszczególne znaki w tej chwili.

1866
01:34:55,220 --> 01:35:00,190
Argv, implikowanych przez te pustym placu
szelki z prawej nazwą argv,

1867
01:35:00,190 --> 01:35:03,320
Oznacza argv jest tablicą łańcuchów.

1868
01:35:03,320 --> 01:35:04,870
I argc jest tylko int.

1869
01:35:04,870 --> 01:35:08,800
>> Linia ta tutaj, 6, jest
mówiąc zbiór wartości i równej 0.

1870
01:35:08,800 --> 01:35:11,980
Hrabia całą drogę aż do,
ale nie w tym, argc.

1871
01:35:11,980 --> 01:35:14,010
A potem na każdej iteracji,
wydrukować ciąg.

1872
01:35:14,010 --> 01:35:14,800
Jaki łańcuch?

1873
01:35:14,800 --> 01:35:17,270
>> Łańcuch i-ty w argv.

1874
01:35:17,270 --> 01:35:19,530
Więc podczas gdy wcześniej byłem
za pomocą wspornika kwadratowy

1875
01:35:19,530 --> 01:35:22,180
Zapis dostać na Ith
znaków w łańcuchu teraz

1876
01:35:22,180 --> 01:35:27,240
Używam notacji nawias kwadratowy
dostać się na ciąg-tej w tablicy.

1877
01:35:27,240 --> 01:35:30,310
Więc jest to rodzaj jednej warstwie
powyżej, pod względem koncepcyjnym.

1878
01:35:30,310 --> 01:35:35,390
>> A więc to, co jest miłe o tym
Program teraz, jeśli mogę skompilować argv1,

1879
01:35:35,390 --> 01:35:42,067
a następnie wykonaj ./argv1, a następnie wpisz
w coś foo bar baz,

1880
01:35:42,067 --> 01:35:45,400
które są trzy domyślne słowa, że
informatyk sięga każdej chwili

1881
01:35:45,400 --> 01:35:51,010
on lub ona potrzebuje zastępcze słowa,
i naciśnij klawisz Enter, każde z tych słów,

1882
01:35:51,010 --> 01:35:54,980
w tym nazwę programu, który
w argv w pierwszym miejscu,

1883
01:35:54,980 --> 01:35:58,320
kończy się drukowane w czasie.

1884
01:35:58,320 --> 01:36:05,290
A jeśli mogę to zmienić, i mówię
coś jak argv1 Zamyla Chan,

1885
01:36:05,290 --> 01:36:08,800
mamy wszystkie trzy z tych
Słowa, które jest argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2, ponieważ w tym
Sprawa argc, hrabia 3.

1887
01:36:14,400 --> 01:36:20,020
>> Ale co jest miłe, jeśli rozumiesz
że argv jest tylko tablicą łańcuchów,

1888
01:36:20,020 --> 01:36:24,910
i zrozumieć, że ciąg
jest tablicą znaków

1889
01:36:24,910 --> 01:36:29,470
rzeczywiście możemy korzystać z tego rodzaju
notacji kwadratowej Wspornik wielokrotnie

1890
01:36:29,470 --> 01:36:33,320
wybrać ciąg, a następnie wybierz
postać w ciągu,

1891
01:36:33,320 --> 01:36:35,730
nurkowania w głębszy sposób następujący.

1892
01:36:35,730 --> 01:36:40,100
W tym przykładzie, pozwól mi odejść
naprzód i nazywają to argv2.c.

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
I w tym przypadku, pozwól mi iść do przodu
i zrobić following-- dla int i uzyskać 0,

1895
01:36:50,180 --> 01:36:53,286
I jest mniejsza niż argc, ja plus
Plus, podobnie jak poprzednio.

1896
01:36:53,286 --> 01:36:55,910
Tak więc w drugiej words-- a teraz to
staje się na tyle skomplikowane.

1897
01:36:55,910 --> 01:36:59,940
Potem powiem
iteracyjne nad ciągów w argv,

1898
01:36:59,940 --> 01:37:01,294
jako komentarz do siebie.

1899
01:37:01,294 --> 01:37:03,960
A potem będę mieć
zagnieżdżonych pętli, którą zapewne

1900
01:37:03,960 --> 01:37:06,290
zrobili lub uznane
robi w Scratch, gdzie

1901
01:37:06,290 --> 01:37:08,600
Idę powiedzieć int-- jestem
Nie będziemy używać ponownie,

1902
01:37:08,600 --> 01:37:12,590
bo nie chcą cień lub
rodzaj zastąpić istniejący i.

1903
01:37:12,590 --> 01:37:15,780
>> Zamierzam natomiast powiedzieć, j, bo
to moja przejdź do zmiennej po I,

1904
01:37:15,780 --> 01:37:18,590
kiedy jestem po prostu staramy się
liczyć prostych liczb.

1905
01:37:18,590 --> 01:37:28,850
Dla j otrzymuje 0--, a także N, ma
dostać surową długość wspornika argv i,

1906
01:37:28,850 --> 01:37:36,030
pod warunkiem, j jest mniejsza niż m,
j Plus Plus, wykonaj następujące czynności.

1907
01:37:36,030 --> 01:37:37,500
A oto interesująca część.

1908
01:37:37,500 --> 01:37:46,330
>> Wydrukować charakter i nową linię,
podłączając wspornika argv I, j wspornika.

1909
01:37:46,330 --> 01:37:47,940
OK, więc dodam kilka uwag tutaj.

1910
01:37:47,940 --> 01:37:54,820
Iteracyjnego znaków
w tym ciągu,

1911
01:37:54,820 --> 01:38:02,290
drukuj j-ty znak w i-tego łańcucha.

1912
01:38:02,290 --> 01:38:04,630
Więc teraz, rozważmy
co te komentarze na myśli.

1913
01:38:04,630 --> 01:38:06,750
>> Iteracja po strunach
w argv-- ilu

1914
01:38:06,750 --> 01:38:09,300
łańcuchy są w argv, która jest tablicą?

1915
01:38:09,300 --> 01:38:13,420
Argc wiele, więc jestem iteracji
od I równa 0 do argc.

1916
01:38:13,420 --> 01:38:20,020
Tymczasem, ile znaków
są w łańcuchu i-tego w argv?

1917
01:38:20,020 --> 01:38:22,880
>> Dobrze, aby ta odpowiedź,
Po prostu zadzwoń długość ciągu

1918
01:38:22,880 --> 01:38:26,810
na bieżące ciąg dbam
temat, który jest argv uchwyt i.

1919
01:38:26,810 --> 01:38:30,090
A ja jadę do tymczasowego przechowywania, które
wartość n, tylko dla celów buforowania,

1920
01:38:30,090 --> 01:38:31,590
pamiętać go do sprawności.

1921
01:38:31,590 --> 01:38:36,330
A potem mam zamiar zainicjować j 0,
poddawać się tak długo, jak j jest mniejsza niż N,

1922
01:38:36,330 --> 01:38:38,430
i na każdej iteracji j przyrostu.

1923
01:38:38,430 --> 01:38:41,030
>> A potem tu, na
mój komentarz na linii 12,

1924
01:38:41,030 --> 01:38:43,390
wydrukować znak,
następnie nowej linii,

1925
01:38:43,390 --> 01:38:48,140
specjalnie argv Wspornik
I daje mi łańcuch i-th

1926
01:38:48,140 --> 01:38:51,690
w argv-- więc pierwszym słowem,
Drugie słowo, trzecie słowo, cokolwiek.

1927
01:38:51,690 --> 01:38:57,370
A następnie nurkowania j głębiej, i dostaje
mnie j-ty znak tego słowa.

1928
01:38:57,370 --> 01:39:02,200
I tak, w rezultacie, można traktować
argv jako wielowymiarowe,

1929
01:39:02,200 --> 01:39:06,050
w dwuwymiarowej tablicy
przy czym każdy rodzaj słowo wygląd

1930
01:39:06,050 --> 01:39:08,580
jak to w wyobraźni
oko, a każda postać

1931
01:39:08,580 --> 01:39:10,930
jest rodzajem skomponowane
kolumna, czy to pomaga.

1932
01:39:10,930 --> 01:39:13,260
>> W rzeczywistości, kiedy dokuczają
Oprócz tego w kolejnych tygodniach

1933
01:39:13,260 --> 01:39:15,580
to będzie trochę
bardziej skomplikowany niż to.

1934
01:39:15,580 --> 01:39:17,800
Ale można naprawdę
pomyśleć, że do tej pory

1935
01:39:17,800 --> 01:39:22,110
jak tylko ten dwuwymiarowy
tablica, przy czym jeden z nich na poziomie

1936
01:39:22,110 --> 01:39:23,260
to wszystkie struny.

1937
01:39:23,260 --> 01:39:26,760
A potem, jeśli nurkowania w głębszy, ciebie
można uzyskać na poszczególnych znaków

1938
01:39:26,760 --> 01:39:29,600
nim za pomocą tego zapisu tutaj.

1939
01:39:29,600 --> 01:39:31,620
>> Więc co jest efektem netto?

1940
01:39:31,620 --> 01:39:34,970
Pozwólcie mi iść do przodu i
dokonać argv2-- cholernie go.

1941
01:39:34,970 --> 01:39:36,210
Popełniłem błąd tutaj.

1942
01:39:36,210 --> 01:39:40,160
Pośrednio uznającej
Biblioteka funkcji Stirling.

1943
01:39:40,160 --> 01:39:42,190
Więc cały ten czas, to
może to właściwe

1944
01:39:42,190 --> 01:39:45,130
że jesteśmy rodzajem wykończenia
dokładnie tam, gdzie zaczęliśmy.

1945
01:39:45,130 --> 01:39:48,160
>> Spieprzyłem, niejawnie deklarowania
Biblioteka funkcji Stirling.

1946
01:39:48,160 --> 01:39:48,987
OK, chwileczkę.

1947
01:39:48,987 --> 01:39:51,070
Pamiętam, że szczególnie
ponieważ to właśnie tutaj.

1948
01:39:51,070 --> 01:39:54,490
Muszę to w string.h
Ta wersja programu.

1949
01:39:54,490 --> 01:40:00,050
>> Pozwól mi iść dalej i obejmują
string.h, chyba że śmiało

1950
01:40:00,050 --> 01:40:04,460
i przekompilować argv2.

1951
01:40:04,460 --> 01:40:08,390
A teraz jedziemy, aby argv2, Enter.

1952
01:40:08,390 --> 01:40:10,590
I choć jest to trochę
tajemnicze na pierwszy rzut oka

1953
01:40:10,590 --> 01:40:15,690
zauważyć, że rzeczywiście to, co
jest drukowana jest kropka argv2.

1954
01:40:15,690 --> 01:40:19,970
>> Ale jeśli mogę wpisać kilka słów po tym,
szybka jak argv2 Zamyla Chan,

1955
01:40:19,970 --> 01:40:22,560
Enter, także trochę
tajemnicze na pierwszy rzut oka.

1956
01:40:22,560 --> 01:40:30,540
Ale jeśli mamy przejść z powrotem,
./argv2 Z-A-M-T-L-C-A-H-N.

1957
01:40:30,540 --> 01:40:32,190
Więc mamy powtórzyć nad każdym słowem.

1958
01:40:32,190 --> 01:40:37,770
A z kolei, mamy potwierdzili ponad
każdy znak w słowie.

1959
01:40:37,770 --> 01:40:40,040
>> Teraz, po tym wszystkim,
sobie sprawę, że nie ma

1960
01:40:40,040 --> 01:40:43,120
jeszcze jeden szczegół byliśmy rodzajem
ignorowania tego cały czas.

1961
01:40:43,120 --> 01:40:46,180
Po prostu drażnił poza to, co
Wejścia głównych może być?

1962
01:40:46,180 --> 01:40:47,780
Co wyjściu Main?

1963
01:40:47,780 --> 01:40:50,540
>> Cały ten czas, byliśmy
po prostu kopiowanie i wklejanie

1964
01:40:50,540 --> 01:40:53,870
int Słowo przed głównym,
choć można zobaczyć on-line,

1965
01:40:53,870 --> 01:40:58,340
czasem niepoprawnie w starszych wersjach
z C i kompilatory, które mówią, że nieważne,

1966
01:40:58,340 --> 01:40:59,410
albo w ogóle nic.

1967
01:40:59,410 --> 01:41:01,580
Ale rzeczywiście, dla wersji
z C, które używamy,

1968
01:41:01,580 --> 01:41:06,180
C 11 lub 2011, realizować
że należy Int.

1969
01:41:06,180 --> 01:41:09,300
I powinno być
nieważne lub argc i argv tutaj.

1970
01:41:09,300 --> 01:41:10,790
>> Ale dlaczego int main?

1971
01:41:10,790 --> 01:41:12,480
Co to właściwie powrót?

1972
01:41:12,480 --> 01:41:16,280
Cóż, okazuje się, przez cały ten czas,
za każdym razem gdy pisałem program główny

1973
01:41:16,280 --> 01:41:18,440
zawsze jest coś powrocie.

1974
01:41:18,440 --> 01:41:19,960
Ale to było robić to w tajemnicy.

1975
01:41:19,960 --> 01:41:23,350
>> Że coś jest
int, jako linia 5 sugeruje.

1976
01:41:23,350 --> 01:41:24,225
Ale co int?

1977
01:41:24,225 --> 01:41:26,100
Cóż, jest to
Konwencja w programowaniu,

1978
01:41:26,100 --> 01:41:29,790
przy czym jeśli nic nie ma
poszło źle i wszystko jest dobrze,

1979
01:41:29,790 --> 01:41:34,250
Programy i funkcje ogólnodostępne
return-- nieco counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0.

1981
01:41:35,230 --> 01:41:38,070
0 ogół oznacza wszystko jest dobrze.

1982
01:41:38,070 --> 01:41:40,610
Więc nawet jeśli myślisz
go jako fałszywe w wielu kontekstach,

1983
01:41:40,610 --> 01:41:42,930
to faktycznie oznacza zazwyczaj coś dobrego

1984
01:41:42,930 --> 01:41:49,560
>> Tymczasem, jeśli program zwraca 1,
lub negatywny 1 lub 5, lub ujemny 42,

1985
01:41:49,560 --> 01:41:52,941
lub jakikolwiek zakaz wartość 0,
oznacza, że ​​na ogół

1986
01:41:52,941 --> 01:41:54,190
że coś poszło nie tak.

1987
01:41:54,190 --> 01:41:56,700
W rzeczywistości, na własnym komputerze Mac lub PC,
mogłeś rzeczywiście widział

1988
01:41:56,700 --> 01:42:01,050
komunikat o błędzie, dzięki czemu
mówi coś lub inny, błąd

1989
01:42:01,050 --> 01:42:04,940
Kod ujemna 42 lub kod błędu
23, czy coś takiego.

1990
01:42:04,940 --> 01:42:08,980
Ta liczba jest na ogół tylko podpowiedź
dla programisty lub firmy

1991
01:42:08,980 --> 01:42:11,174
sprawiło, że oprogramowanie,
co poszło źle i dlaczego,

1992
01:42:11,174 --> 01:42:13,590
tak, że mogą patrzeć przez
ich dokumentacji lub kod,

1993
01:42:13,590 --> 01:42:15,465
i dowiedzieć się, co
Błąd w rzeczywistości oznacza.

1994
01:42:15,465 --> 01:42:18,400
To nie jest na ogół
przydatne dla nas użytkowników końcowych.

1995
01:42:18,400 --> 01:42:20,550
>> Ale kiedy główne zwraca 0, wszystko jest dobrze.

1996
01:42:20,550 --> 01:42:23,770
A jeśli nie podasz
czego głównym powinien powrócić,

1997
01:42:23,770 --> 01:42:26,950
To po prostu automatycznie
zwraca 0 dla ciebie.

1998
01:42:26,950 --> 01:42:30,870
Wracając jednak coś
jeszcze jest rzeczywiście użyteczne.

1999
01:42:30,870 --> 01:42:34,660
>> W tym ostatnim programie, niech mnie
iść dalej i nazywają to exit.c,

2000
01:42:34,660 --> 01:42:38,630
i wprowadzić ostatni dzisiejszy
tematy, znane jako kod błędu.

2001
01:42:38,630 --> 01:42:42,930
Pozwólcie mi iść do przodu i to nasze
znajome pliki nawet góry, czy int main.

2002
01:42:42,930 --> 01:42:49,500
I tym razem, zróbmy int argc,
argv łańcuch, az moich nawiasach

2003
01:42:49,500 --> 01:42:50,836
sugerować, że jest to w tablicy.

2004
01:42:50,836 --> 01:42:52,460
I pozwól mi tylko zrobić test dla pewności.

2005
01:42:52,460 --> 01:42:56,640
Jednocześnie, jeżeli nie argc
równe 2, to wiesz co?

2006
01:42:56,640 --> 01:42:57,520
Zapomnij o tym.

2007
01:42:57,520 --> 01:43:03,170
Mam zamiar powiedzieć, że hej, użytkownik,
brakuje argumentów wiersza poleceń

2008
01:43:03,170 --> 01:43:04,210
backslash n.

2009
01:43:04,210 --> 01:43:05,230
>> A potem to wszystko.

2010
01:43:05,230 --> 01:43:06,130
Chcę wyjść.

2011
01:43:06,130 --> 01:43:11,030
Mam zamiar zapobiegawczo,
i przedwcześnie naprawdę powrót

2012
01:43:11,030 --> 01:43:12,810
czymś innym niż liczba 1.

2013
01:43:12,810 --> 01:43:15,360
Idź do wartości dla pierwszego
Błąd, który może się zdarzyć to 1.

2014
01:43:15,360 --> 01:43:17,860
Jeśli masz jakieś inne błędne
sytuacja może wystąpić,

2015
01:43:17,860 --> 01:43:21,390
można powiedzieć, powrót 2 lub powrotu 3, lub
może nawet ujemna 1 lub ujemna 2.

2016
01:43:21,390 --> 01:43:23,750
>> Są to tylko kody wyjścia
które są, na ogół,

2017
01:43:23,750 --> 01:43:27,770
użyteczne tylko dla programisty lub
Firma, która jest dostarczane oprogramowanie.

2018
01:43:27,770 --> 01:43:30,500
Ale fakt, że jest to
nie 0 to, co jest ważne.

2019
01:43:30,500 --> 01:43:34,310
Więc jeśli w tym programie, chcę
Gwarantujemy, że ten program tylko

2020
01:43:34,310 --> 01:43:38,190
działa, jeśli użytkownik zapewnia mnie
z liczbą argumentów dwóch,

2021
01:43:38,190 --> 01:43:42,880
nazwę programu, a inna
Słowo, mogę wymusić jak następuje,

2022
01:43:42,880 --> 01:43:46,110
krzyczeć na użytkownika z printf powiedzenie,
brakuje argumentu wiersza poleceń,

2023
01:43:46,110 --> 01:43:46,970
zwraca 1.

2024
01:43:46,970 --> 01:43:49,940
To będzie po prostu od razu
zamknąć program.

2025
01:43:49,940 --> 01:43:55,840
>> Tylko wtedy argc równa 2 otrzymamy dół
tu, w którym momencie mam zamiar powiedzieć,

2026
01:43:55,840 --> 01:44:00,410
witam procent s, backslash n, argv1.

2027
01:44:00,410 --> 01:44:03,827
Innymi słowy, jestem
Nie będzie po argv 0,

2028
01:44:03,827 --> 01:44:05,410
który jest po prostu nazwa programu.

2029
01:44:05,410 --> 01:44:09,450
Chcę wydrukować witam, przecinek,
drugie słowo, że ludzkie wpisane.

2030
01:44:09,450 --> 01:44:12,580
I w tym przypadku na
Linia 13, wszystko jest dobrze.

2031
01:44:12,580 --> 01:44:15,920
>> Wiem, że argc jest 2
logicznie z tego programu.

2032
01:44:15,920 --> 01:44:17,770
Mam zamiar iść do przodu i zwraca 0.

2033
01:44:17,770 --> 01:44:21,230
Tak na marginesie, należy pamiętać, że
to jest prawdziwe w Scratch również.

2034
01:44:21,230 --> 01:44:24,760
>> Logicznie rzecz biorąc, mogę to zrobić
i upakować te linie

2035
01:44:24,760 --> 01:44:27,020
kodu w tej klauzuli else tutaj.

2036
01:44:27,020 --> 01:44:29,420
Ale to rodzaj
niepotrzebnie wcięcia kodu.

2037
01:44:29,420 --> 01:44:31,800
I chcę, aby Wspaniały
jasne, że bez względu na to,

2038
01:44:31,800 --> 01:44:34,670
domyślnie komentarzy
coś zostanie wydrukowany,

2039
01:44:34,670 --> 01:44:36,050
tak długo, jak współpracuje użytkownik.

2040
01:44:36,050 --> 01:44:39,360
>> Więc to jest bardzo powszechne w użyciu
warunek, tylko w przypadku,

2041
01:44:39,360 --> 01:44:41,870
złapać niektóre błędne
Sytuacja, a następnie Zakończ.

2042
01:44:41,870 --> 01:44:45,690
A potem, tak długo wszystko
No, może nie mieć innego,

2043
01:44:45,690 --> 01:44:48,060
ale po prostu mieć kod
poza tym, jeśli, bo to

2044
01:44:48,060 --> 01:44:51,060
równowartość w tym
Szczególnym przypadkiem, logicznie.

2045
01:44:51,060 --> 01:44:54,480
Więc wracam 0, po prostu
wyraźnie oznaczać wszystko jest dobrze.

2046
01:44:54,480 --> 01:44:58,480
>> Jeśli pominąłem return 0, to będzie
automatycznie zakłada się dla mnie.

2047
01:44:58,480 --> 01:45:00,890
Ale teraz, gdy wracam
w co najmniej jednym takim przypadku,

2048
01:45:00,890 --> 01:45:04,940
Idę, a na dokładkę
jasność, zwraca 0 w tym przypadku.

2049
01:45:04,940 --> 01:45:09,690
Więc teraz pozwól mi iść do przodu i zrobić zjazd,
co jest idealne segue po prostu zostawić.

2050
01:45:09,690 --> 01:45:14,401
>> Ale aby wyjść i pozwól mi odejść
zrób ./exit, Enter.

2051
01:45:14,401 --> 01:45:16,900
A program krzyczał na mnie,
brakuje argumentu wiersza poleceń.

2052
01:45:16,900 --> 01:45:18,120
OK, niech współpracują.

2053
01:45:18,120 --> 01:45:23,810
>> Pozwól mi, zamiast robić ./exit David, Enter.

2054
01:45:23,810 --> 01:45:25,190
A teraz mówi, cześć Davida.

2055
01:45:25,190 --> 01:45:27,300
I normalnie nie zobaczyć.

2056
01:45:27,300 --> 01:45:30,650
>> Ale okazuje się, że istnieje
Specjalny sposób Linux faktycznie zobaczyć

2057
01:45:30,650 --> 01:45:34,470
co exit code program zakończył.

2058
01:45:34,470 --> 01:45:37,184
Czasami w graficznym
Świat jak Mac OS lub Windows

2059
01:45:37,184 --> 01:45:40,100
widzisz tylko te liczby, gdy
Komunikat o błędzie pojawia się na ekranie

2060
01:45:40,100 --> 01:45:41,940
a programista
pokazuje ten numer.

2061
01:45:41,940 --> 01:45:44,773
Ale jeśli chcemy zobaczyć co to za błąd
Wiadomość jest, możemy to zrobić here--

2062
01:45:44,773 --> 01:45:48,100
tak ./exit, Enter, druk
brakuje argumentu wiersza poleceń.

2063
01:45:48,100 --> 01:45:54,590
>> Jeśli teraz zrobić echo $ ?, która jest
śmiesznie tajemnicze spojrzenie.

2064
01:45:54,590 --> 01:45:56,590
Ale $?

2065
01:45:56,590 --> 01:45:59,220
Jest to magiczne zaklęcia
który mówi, hej, komputer,

2066
01:45:59,220 --> 01:46:01,900
powiedz mi, co poprzedni
Kod programu wyjście było.

2067
01:46:01,900 --> 01:46:03,410
I naciśnij Enter.

2068
01:46:03,410 --> 01:46:07,520
Widzę 1, bo to co ja
powiedział mój główny funkcję powrotu.

2069
01:46:07,520 --> 01:46:12,310
>> Tymczasem, jeśli robię ./exit Dawida,
i naciśnij klawisz Enter, widzę, Hello Dawida.

2070
01:46:12,310 --> 01:46:16,800
I jeśli teraz zrobić echo $ ?, widzę komentarzy 0.

2071
01:46:16,800 --> 01:46:19,080
A więc to będzie w rzeczywistości
za cenne informacje

2072
01:46:19,080 --> 01:46:23,420
w kontekście debugera, nie tak
bardzo, że ludzki, to zależy.

2073
01:46:23,420 --> 01:46:26,060
Ale debugger i innych
Programy użyjemy w tym semestrze

2074
01:46:26,060 --> 01:46:29,420
często patrzeć na ten numer,
mimo to rodzaj ukryty

2075
01:46:29,420 --> 01:46:32,780
chyba spojrzeć na to, aby
określić, czy program na

2076
01:46:32,780 --> 01:46:37,050
Wykonanie było prawidłowe lub nieprawidłowe.

2077
01:46:37,050 --> 01:46:40,450
>> I tak, to prowadzi nas do
to, na koniec dnia.

2078
01:46:40,450 --> 01:46:43,917
Zaczęliśmy dzisiaj patrząc na
debugowanie, az kolei w toku

2079
01:46:43,917 --> 01:46:46,750
Sam, a następnie co ciekawsze,
technicznie pod maską

2080
01:46:46,750 --> 01:46:49,490
w jakim są struny, które trwają
Tydzień po prostu wziął za pewnik,

2081
01:46:49,490 --> 01:46:51,900
a na pewno wziął je
za pewnik w Scratch.

2082
01:46:51,900 --> 01:46:56,040
>> Potem spojrzał w jaki sposób możemy uzyskać dostęp
Poszczególne znaki w ciągu znaków,

2083
01:46:56,040 --> 01:47:00,310
a następnie ponownie wziął wyższy poziom
patrzeć na rzeczy, patrząc na to, jak well--

2084
01:47:00,310 --> 01:47:04,226
jeśli chcemy uzyskać na indywidualne
elementów w liście, jak struktury,

2085
01:47:04,226 --> 01:47:05,850
Nie możemy tego robić z wielu ciągów?

2086
01:47:05,850 --> 01:47:08,050
I możemy z argumentów wiersza poleceń.

2087
01:47:08,050 --> 01:47:12,800
Ale ten obraz tu zaledwie pudełkach
jest poglądowe tej ogólnej idei

2088
01:47:12,800 --> 01:47:14,451
tablicy lub listy lub wektorem.

2089
01:47:14,451 --> 01:47:16,450
I w zależności od
kontekst, wszystkie te słowa

2090
01:47:16,450 --> 01:47:17,880
myśli nieco inne rzeczy.

2091
01:47:17,880 --> 01:47:20,060
Więc w C, jesteśmy tylko będzie
mówić o tablicy.

2092
01:47:20,060 --> 01:47:23,840
A tablica jest kawał
z pamięci, a każdy z nich jest

2093
01:47:23,840 --> 01:47:27,720
elementy przylegają do siebie, z powrotem,
do tyłu, do tyłu, do tyłu.

2094
01:47:27,720 --> 01:47:31,970
>> A te elementy są na ogół
tego samego typu danych, charakter,

2095
01:47:31,970 --> 01:47:35,966
charakter, charakter, charakter, lub
ciąg, string, string, string lub int,

2096
01:47:35,966 --> 01:47:38,600
int, int, cokolwiek to jest
próbujemy sklepie.

2097
01:47:38,600 --> 01:47:42,540
A na koniec dnia, to jest
jak to wygląda pod względem koncepcyjnym.

2098
01:47:42,540 --> 01:47:44,530
Bierzesz swoje
pamięci lub pamięci RAM komputera.

2099
01:47:44,530 --> 01:47:48,590
A ty go do rzeźbienia
identycznie wielkości pudła, z których każda

2100
01:47:48,590 --> 01:47:50,920
są z powrotem, do tyłu, do
powrotem do siebie w ten sposób.

2101
01:47:50,920 --> 01:47:53,200
>> I co jest miłe o
Pomysł ten, oraz fakt

2102
01:47:53,200 --> 01:47:58,580
że możemy wyrazić wartości w ten sposób
od pierwszej struktury danych naszych

2103
01:47:58,580 --> 01:48:02,520
w klasie, oznacza, że ​​możemy zacząć
rozwiązać problemy z kodem

2104
01:48:02,520 --> 01:48:04,079
który przyszedł więc intuicyjnie w tym tygodniu 0.

2105
01:48:04,079 --> 01:48:05,870
Będziesz przypomnieć telefon
Przykładem książka, w której

2106
01:48:05,870 --> 01:48:09,110
użyliśmy dziel i rządź,
lub wyszukiwanie binarne,

2107
01:48:09,110 --> 01:48:13,220
przesiać przez całość
pęczek nazw i numerów.

2108
01:48:13,220 --> 01:48:18,220
Ale założyliśmy, przypominam, że
książka telefoniczna została już posortowane,

2109
01:48:18,220 --> 01:48:21,630
że ktoś inny już
wzorzysty out-- podano listę nazw

2110
01:48:21,630 --> 01:48:24,430
i numbers-- jak je alfabetycznie.

2111
01:48:24,430 --> 01:48:26,950
I teraz, że mamy w C,
również mają zdolność

2112
01:48:26,950 --> 01:48:30,290
położyć rzeczy, a nie
fizycznie w książce telefonicznej

2113
01:48:30,290 --> 01:48:34,220
ale praktycznie w komputerze użytkownika
Pamięć, będziemy mogli w przyszłym tygodniu

2114
01:48:34,220 --> 01:48:38,470
wprowadzić ponownie this-- pierwszy
naszych struktur danych w array--

2115
01:48:38,470 --> 01:48:43,530
ale co ważniejsze, faktyczna komputerowego
algorytmy naukowe realizowane

2116
01:48:43,530 --> 01:48:47,720
w kodzie, z którym możemy przechowywać
Dane w strukturach takich jak ta,

2117
01:48:47,720 --> 01:48:50,730
a następnie zacząć manipulować, a
faktycznie rozwiązania problemów z tym,

2118
01:48:50,730 --> 01:48:53,570
i budować na początku, że
Ostatecznie, programy w języku C,

2119
01:48:53,570 --> 01:48:56,730
w Pythonie, w JavaScripcie,
zapytań baz danych w SQL?

2120
01:48:56,730 --> 01:48:59,980
>> I zobaczymy, że wszystkie z nich
różne pomysły blokad.

2121
01:48:59,980 --> 01:49:04,100
Na razie jednak przypomnieć, że
domeny, który wprowadziliśmy dziś

2122
01:49:04,100 --> 01:49:06,920
było to coś tutaj, i
świat kryptografii.

2123
01:49:06,920 --> 01:49:11,200
A wśród kolejnych problemów ty sam
rozwiąże to sztuka kryptografii

2124
01:49:11,200 --> 01:49:13,630
kodowania i de-kodowania
Informacje i szyfrowanie

2125
01:49:13,630 --> 01:49:15,930
i rozszyfrowania tekstu
i zakładając ostatecznie

2126
01:49:15,930 --> 01:49:18,970
że teraz wie, co
jest pod maską

2127
01:49:18,970 --> 01:49:21,860
tak, że gdy widzisz lub odbierać
komunikat ten sposób, ty

2128
01:49:21,860 --> 01:49:24,060
samemu można go rozszyfrować.

2129
01:49:24,060 --> 01:49:26,740
Wszystko to i wiele więcej następnym razem.

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [ODTWARZANIE]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover Właśnie przybył.

2133
01:49:32,970 --> 01:49:35,146
Zamierzam iść wizytę
Jego profesor college'u.

2134
01:49:35,146 --> 01:49:37,611
Tak.

2135
01:49:37,611 --> 01:49:40,080
Cześć.

2136
01:49:40,080 --> 01:49:40,660
To ty.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
Czekać!

2139
01:49:45,110 --> 01:49:45,610
David.

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
Po prostu staram się zrozumieć
co się z tobą stało.

2142
01:49:56,060 --> 01:49:58,130
Proszę, cokolwiek może pomóc.

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
Byłaś jego uczelni
stancja, prawda?

2145
01:50:08,354 --> 01:50:10,770
Byłaś tam z nim, kiedy
ukończył projekt CS50?

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [MUZYKA]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> -To Był CS50.

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> Uwielbiam to miejsce.

2152
01:50:44,770 --> 01:50:45,854
>> -Zjadać.

2153
01:50:45,854 --> 01:50:47,020
Jedziemy z rynku.

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [KONIEC ODTWARZANIA]

