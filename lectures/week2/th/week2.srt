1
00:00:00,000 --> 00:00:02,970
>> [เสียงเพลง]

2
00:00:02,970 --> 00:00:14,355

3
00:00:14,355 --> 00:00:15,700
>> เดวิดเจลัน: สิทธิทั้งหมด

4
00:00:15,700 --> 00:00:18,832
นี่คือ CS50 และนี่
เป็นจุดเริ่มต้นของสัปดาห์ที่ 2

5
00:00:18,832 --> 00:00:21,040
และคุณจะจำได้ว่าในช่วง
คู่ที่ผ่านมาของสัปดาห์ที่ผ่านมา

6
00:00:21,040 --> 00:00:24,490
เราได้รับการแนะนำคอมพิวเตอร์
วิทยาศาสตร์และในทางกลับกันการเขียนโปรแกรม

7
00:00:24,490 --> 00:00:27,640
>> และเราเริ่มต้นเรื่องราวโดยวิธีการ
รอยขีดข่วนว่าภาษากราฟิก

8
00:00:27,640 --> 00:00:28,990
จากเอ็มไอทีมีเดียแล็บ

9
00:00:28,990 --> 00:00:30,780
และจากนั้นเมื่อเร็ว ๆ นี้
สัปดาห์ที่แล้วเราได้

10
00:00:30,780 --> 00:00:34,450
แนะนำ higher--
ภาษาในระดับต่ำกว่าที่รู้จักกัน

11
00:00:34,450 --> 00:00:36,770
C, บางสิ่งบางอย่างที่เกี่ยวกับใจอย่างหมดจด

12
00:00:36,770 --> 00:00:39,440
และแน่นอนครั้งสุดท้ายที่เรา
การสำรวจในบริบทที่

13
00:00:39,440 --> 00:00:40,450
จำนวนของแนวคิด

14
00:00:40,450 --> 00:00:43,010
>> นี้เรียกเป็นอย่างมาก
โปรแกรมแรกที่เรามองไปที่

15
00:00:43,010 --> 00:00:45,710
และโปรแกรมนี้ค่อนข้างง่าย
พิมพ์ออก "Hello, world."

16
00:00:45,710 --> 00:00:47,730
แต่มีมาก
มายากลดูเหมือนเกิดขึ้น

17
00:00:47,730 --> 00:00:51,460
มี #include นี้เป็น
ด้วยวงเล็บมุมเหล่านี้

18
00:00:51,460 --> 00:00:52,170
มี int เป็น

19
00:00:52,170 --> 00:00:53,020
มี (void)

20
00:00:53,020 --> 00:00:56,330
มีวงเล็บวงเล็บปีกกาของ
กึ่งทวิภาคและอื่น ๆ อีกมากมาย

21
00:00:56,330 --> 00:00:58,480
>> และเพื่อให้จำได้ว่า
เราได้นำรอยขีดข่วน

22
00:00:58,480 --> 00:01:02,110
เพื่อให้เราสามารถนึกคิดเห็นอดีต
ไวยากรณ์ว่าสิ่งที่เป็นจริงไม่

23
00:01:02,110 --> 00:01:04,590
ทุกสิ่งที่สติปัญญา
แต่ที่น่าสนใจในช่วงต้น

24
00:01:04,590 --> 00:01:07,700
คืออย่างบิตหากิน
มัดใจรอบ

25
00:01:07,700 --> 00:01:10,860
และแน่นอนหนึ่งที่พบมากที่สุด
สิ่งที่ในช่วงต้นของการเรียนการเขียนโปรแกรม

26
00:01:10,860 --> 00:01:13,443
โดยเฉพาะอย่างยิ่งสำหรับผู้น้อย
ความสะดวกสบายที่จะได้รับความผิดหวังจากการ

27
00:01:13,443 --> 00:01:17,460
และดีดกลับขึ้นมาจากบางประโยค
ข้อผิดพลาดที่ไม่พูดถึงข้อผิดพลาดเชิงตรรกะ

28
00:01:17,460 --> 00:01:19,800
และในหมู่เป้าหมายของเรา
วันนี้จริงจะ

29
00:01:19,800 --> 00:01:23,280
จะจัดให้คุณกับบางส่วน
เทคนิคการแก้ปัญหาสำหรับวิธีการ

30
00:01:23,280 --> 00:01:26,705
ที่ดีกว่าการแก้ปัญหาตัวเอง
ในรูปแบบของการแก้จุดบกพร่อง

31
00:01:26,705 --> 00:01:29,330
และคุณจะจำได้เหมือนกันว่า
สภาพแวดล้อมที่เราแนะนำ

32
00:01:29,330 --> 00:01:31,780
ครั้งสุดท้ายที่ถูกเรียกว่า CS50 IDE

33
00:01:31,780 --> 00:01:34,850
นี้เป็นซอฟต์แวร์บนเว็บที่
ช่วยให้คุณสามารถเขียนโปรแกรมในเมฆ

34
00:01:34,850 --> 00:01:38,450
เพื่อที่จะพูดในขณะที่เก็บทั้งหมดของคุณ
ไฟล์เข้าด้วยกันในขณะที่เราในวันนี้อีกครั้งจะ

35
00:01:38,450 --> 00:01:41,480
และจำได้ว่าเรา
หัวข้อเหล่านี้มาเยือนที่นี่

36
00:01:41,480 --> 00:01:44,480
ในหมู่พวกเขาฟังก์ชั่นและลูปและ
ตัวแปรและการแสดงออกบูลีน

37
00:01:44,480 --> 00:01:45,110
และเงื่อนไข

38
00:01:45,110 --> 00:01:49,190
และจริงอีกไม่กี่ที่เรา
แปลมาจากโลกของรอยขีดข่วน

39
00:01:49,190 --> 00:01:50,800
สู่โลกของซี

40
00:01:50,800 --> 00:01:53,220
>> แต่อาคารพื้นฐาน
บล็อกเพื่อที่จะพูด

41
00:01:53,220 --> 00:01:55,150
จริงๆยังคงเป็นสัปดาห์ที่ผ่านมาเช่นเดียวกัน

42
00:01:55,150 --> 00:01:57,900
ในความเป็นจริงเราจริงๆเพียงแค่มี
ชิ้นส่วนจิ๊กซอว์ที่แตกต่างกันถ้าคุณจะ

43
00:01:57,900 --> 00:02:00,300
แทนที่จะเป็นสีม่วงว่า
บันทึกบล็อกเราแทน

44
00:02:00,300 --> 00:02:02,940
ได้ printf ซึ่งเป็น
ฟังก์ชั่นนี้ใน C ที่

45
00:02:02,940 --> 00:02:05,890
ช่วยให้คุณพิมพ์บางสิ่งบางอย่าง
และจัดรูปแบบบนหน้าจอ

46
00:02:05,890 --> 00:02:07,950
เราแนะนำ CS50
ห้องสมุดที่คุณ

47
00:02:07,950 --> 00:02:11,420
มีตอนนี้ที่ get_char การกำจัดของคุณ
และ get_int และ get_string,

48
00:02:11,420 --> 00:02:14,610
และฟังก์ชั่นอื่น ๆ ไม่กี่เป็น
ดีผ่านทางที่คุณจะได้รับการป้อนข้อมูล

49
00:02:14,610 --> 00:02:16,260
จากแป้นพิมพ์ของผู้ใช้

50
00:02:16,260 --> 00:02:20,640
และเรายังได้ดูสิ่งที่
เช่นบูล these- และถ่าน

51
00:02:20,640 --> 00:02:22,490
และดับเบิลลอย
int สตริง long_long

52
00:02:22,490 --> 00:02:25,170
และมีแม้กระทั่งชนิดข้อมูลอื่น ๆ ใน C.

53
00:02:25,170 --> 00:02:28,560
>> ในคำอื่น ๆ เมื่อคุณประกาศ
ตัวแปรเพื่อเก็บค่าบางอย่าง

54
00:02:28,560 --> 00:02:32,600
หรือเมื่อคุณใช้ฟังก์ชั่น
ที่ส่งกลับค่าบางอย่าง

55
00:02:32,600 --> 00:02:35,290
คุณสามารถระบุสิ่งที่
ประเภทของค่าที่

56
00:02:35,290 --> 00:02:37,310
มันเป็นสตริงเช่น
ลำดับของตัวอักษร?

57
00:02:37,310 --> 00:02:39,490
มันเป็นตัวเลขเช่นจำนวนเต็ม?

58
00:02:39,490 --> 00:02:41,390
มันเป็นจุดลอย
คุ้มค่าหรือชอบ?

59
00:02:41,390 --> 00:02:46,180
ดังนั้นใน C ซึ่งแตกต่างจากรอยขีดข่วนเราจริง
เริ่มที่จะระบุชนิดของข้อมูล

60
00:02:46,180 --> 00:02:48,330
เรากำลังจะกลับหรือใช้

61
00:02:48,330 --> 00:02:51,910
>> แต่แน่นอนเรายังวิ่งเข้าไป
บางข้อ จำกัด ของการใช้คอมพิวเตอร์พื้นฐาน

62
00:02:51,910 --> 00:02:54,100
และโดยเฉพาะอย่างยิ่ง
นี้ภาษา C การเรียกคืน

63
00:02:54,100 --> 00:02:57,070
ที่เราเอามาดูที่
ล้นจำนวนเต็มในความเป็นจริง

64
00:02:57,070 --> 00:03:00,460
ว่าถ้าคุณมีเพียง
จำนวน จำกัด ของหน่วยความจำ

65
00:03:00,460 --> 00:03:04,600
หรือเฉพาะจำนวน จำกัด
ของบิตคุณสามารถนับสูงมาก

66
00:03:04,600 --> 00:03:08,460
และเพื่อให้เรามองไปที่ตัวอย่างนี้ที่นี่
โดยเคาน์เตอร์ในเครื่องบิน,

67
00:03:08,460 --> 00:03:13,510
ที่จริงถ้าทำงานนานพอที่จะ
ล้นและผลในซอฟต์แวร์

68
00:03:13,510 --> 00:03:15,560
ข้อผิดพลาดที่เกิดขึ้นจริงที่มีศักยภาพทางกายภาพ

69
00:03:15,560 --> 00:03:18,600
>> นอกจากนี้เรายังมองไปที่ลอย
จุดไม่แน่ชัดในความเป็นจริง

70
00:03:18,600 --> 00:03:22,280
ที่มีเพียงจำนวน จำกัด
ของบิตไม่ว่าจะเป็น 32 หรือ 64

71
00:03:22,280 --> 00:03:27,330
คุณสามารถระบุตัวเลขจำนวนมากดังนั้น
หลังจากจุดทศนิยมหลังจากที่คุณ

72
00:03:27,330 --> 00:03:29,110
เริ่มต้นที่จะได้รับไม่แน่ชัด

73
00:03:29,110 --> 00:03:32,360
ดังนั้นสำหรับตัวอย่างเช่นหนึ่งในสามใน
โลกที่นี่ในโลกมนุษย์ของเรา

74
00:03:32,360 --> 00:03:35,360
เรารู้ว่าเป็นเพียงจำนวนอนันต์
ของ 3s หลังจุดทศนิยม

75
00:03:35,360 --> 00:03:38,820
แต่คอมพิวเตอร์ไม่สามารถจำเป็น
แทนจำนวนอนันต์ของตัวเลข

76
00:03:38,820 --> 00:03:42,590
ถ้าคุณจะให้มันบาง
จำนวน จำกัด ของข้อมูล

77
00:03:42,590 --> 00:03:45,900
>> ดังนั้นไม่เพียง แต่เราจัดให้คุณ
ที่มีอำนาจมากขึ้นในแง่

78
00:03:45,900 --> 00:03:49,280
วิธีการที่คุณอาจจะแสดงตัวเองที่
แป้นพิมพ์ในแง่ของการเขียนโปรแกรม

79
00:03:49,280 --> 00:03:51,430
นอกจากนี้เรายัง จำกัด สิ่งที่
คุณสามารถทำได้จริง

80
00:03:51,430 --> 00:03:55,790
และแน่นอนข้อบกพร่องและความผิดพลาดสามารถ
เกิดขึ้นจากชนิดของปัญหา

81
00:03:55,790 --> 00:03:59,900
และแน่นอนในหัวข้อวันนี้
กำลังจะเป็นหัวข้อต่างๆเช่นการแก้จุดบกพร่อง

82
00:03:59,900 --> 00:04:03,699
และที่จริงมองใต้กระโปรงหน้ารถ
ในสัปดาห์ที่ผ่านมาว่าสิ่งที่ถูกนำมาใช้

83
00:04:03,699 --> 00:04:05,490
จะดำเนินการจริง
เพื่อให้คุณดีขึ้น

84
00:04:05,490 --> 00:04:10,530
เข้าใจความสามารถของทั้งสองและ
ข้อ จำกัด ของภาษาเช่นซีที่

85
00:04:10,530 --> 00:04:14,770
>> และในความเป็นจริงเราจะปอกเปลือกกลับชั้น
ของที่ง่ายที่สุดของโครงสร้างข้อมูล

86
00:04:14,770 --> 00:04:17,756
สิ่งที่เรียกว่าอาร์เรย์ซึ่ง
รอยขีดข่วนที่เกิดขึ้นเรียกว่า "รายการ".

87
00:04:17,756 --> 00:04:19,589
มันนิด ๆ หน่อย ๆ
ที่แตกต่างกันในบริบทที่

88
00:04:19,589 --> 00:04:23,340
แล้วเรายังจะแนะนำหนึ่งใน
แรกของปัญหาเฉพาะโดเมนของเรา

89
00:04:23,340 --> 00:04:26,790
ใน CS50 โลกของ
วิทยาการศิลปะของ scrambling

90
00:04:26,790 --> 00:04:29,650
หรือใน ciphering ข้อมูลเพื่อ
ที่คุณสามารถส่งข้อความลับ

91
00:04:29,650 --> 00:04:34,520
และถอดรหัสข้อความลับ
ระหว่างคนสองคน, A และ B

92
00:04:34,520 --> 00:04:37,490
>> ดังนั้นก่อนที่เราจะเปลี่ยนแปลง
เพื่อโลกใหม่ที่

93
00:04:37,490 --> 00:04:42,059
ลองจัดให้คุณกับบางส่วน
เทคนิคที่คุณสามารถกำจัด

94
00:04:42,059 --> 00:04:43,850
หรือลดอย่างน้อยบางส่วน
ของความผิดหวัง

95
00:04:43,850 --> 00:04:46,630
ที่คุณอาจจะได้พบ
ในช่วงสัปดาห์ที่ผ่านมาเพียงอย่างเดียว

96
00:04:46,630 --> 00:04:50,830
ในความเป็นจริงข้างหน้าของคุณจะ such-- บางส่วนของ
ปัญหาที่เกิดขึ้นครั้งแรกของคุณใน C. และราคาเป็น

97
00:04:50,830 --> 00:04:54,010
ถ้าคุณชอบฉันเป็นครั้งแรก
คุณพยายามที่จะพิมพ์ออกโปรแกรม

98
00:04:54,010 --> 00:04:57,330
แม้ว่าคุณจะคิดว่ามีเหตุผล
โปรแกรมคือสวยเรียบง่าย

99
00:04:57,330 --> 00:05:01,200
คุณเป็นอย่างดีอาจจะชนกำแพงและ
คอมไพเลอร์จะไม่ให้ความร่วมมือ

100
00:05:01,200 --> 00:05:03,940
ทำให้เสียงดังกราวหรือไม่ได้ไป
ที่จริงทำตามคำสั่งของคุณ

101
00:05:03,940 --> 00:05:05,450
>> และเหตุผลที่ว่าอาจจะมี?

102
00:05:05,450 --> 00:05:07,950
ดีขอดูที่,
บางทีอาจจะเป็นโปรแกรมที่ง่าย

103
00:05:07,950 --> 00:05:11,190
ฉันจะไปข้างหน้าและบันทึกนี้
ไฟล์จงใจเรียก buggy0.c,

104
00:05:11,190 --> 00:05:13,590
เพราะผมรู้ว่ามันจะ
เป็นข้อบกพร่องล่วงหน้า

105
00:05:13,590 --> 00:05:17,400
แต่ผมอาจจะไม่ทราบว่าถ้านี้
เป็นโปรแกรมแรกหรือครั้งที่สองหรือสาม

106
00:05:17,400 --> 00:05:18,830
ว่าฉันจริงทำให้ตัวเอง

107
00:05:18,830 --> 00:05:23,820
ดังนั้นฉันจะไปข้างหน้าและ
พิมพ์ออก int main (void)

108
00:05:23,820 --> 00:05:28,130
และจากนั้นภายในวงเล็บปีกกาของฉัน
ที่คุ้นเคยมาก ( "สวัสดี world--

109
00:05:28,130 --> 00:05:30,980
ทับขวา, N ") - และ semi-colon

110
00:05:30,980 --> 00:05:32,360
>> ผมเคยบันทึกไฟล์

111
00:05:32,360 --> 00:05:34,850
ตอนนี้ฉันจะไปลง
เพื่อหน้าต่าง terminal ของฉัน

112
00:05:34,850 --> 00:05:40,340
และประเภทแต่งหน้า buggy0 เพราะอีกครั้ง
ชื่อของไฟล์ในวันนี้คือ buggy0.c

113
00:05:40,340 --> 00:05:43,660
ดังนั้นผมจึงทำให้พิมพ์ buggy0 ใส่

114
00:05:43,660 --> 00:05:48,200
>> และโอ้เอ้ยจำจากครั้งสุดท้าย
ว่าข้อความที่ไม่มีข้อผิดพลาดเป็นสิ่งที่ดี

115
00:05:48,200 --> 00:05:49,740
ดังนั้นผลลัพธ์ออกมาเป็นสิ่งที่ดี

116
00:05:49,740 --> 00:05:52,920
แต่ที่นี่ผมมีอย่างชัดเจน
จำนวนผิดพลาดบางอย่าง

117
00:05:52,920 --> 00:05:56,470
>> ดังนั้นบรรทัดแรกของการส่งออก
หลังจากพิมพ์ให้ buggy0 จำ

118
00:05:56,470 --> 00:05:59,540
เป็นผล verbose ค่อนข้างเสียงดังกราวของ

119
00:05:59,540 --> 00:06:02,067
ภายใต้ประทุน
IDE CS50 มีการกำหนดค่า

120
00:06:02,067 --> 00:06:04,150
จะใช้ทั้งกลุ่ม
ตัวเลือกที่มีคอมไพเลอร์นี้

121
00:06:04,150 --> 00:06:05,941
เพื่อให้คุณไม่ได้
ที่จะคิดเกี่ยวกับพวกเขา

122
00:06:05,941 --> 00:06:08,840
และนั่นคือทั้งหมดที่บรรทัดแรก
วิธีการที่เริ่มต้นด้วยเสียงดังกราว

123
00:06:08,840 --> 00:06:11,720
>> แต่หลังจากนั้นปัญหาที่เกิดขึ้น
เริ่มต้นที่จะทำให้ลักษณะของพวกเขา

124
00:06:11,720 --> 00:06:17,390
Buggy0.c ในบรรทัดที่ 3 ตัวอักษร
5 มีขนาดใหญ่สีแดงข้อผิดพลาด

125
00:06:17,390 --> 00:06:18,380
นั่นคืออะไร?

126
00:06:18,380 --> 00:06:23,562
โดยปริยายประกาศฟังก์ชั่นห้องสมุด
printf กับชนิด int (const char *,

127
00:06:23,562 --> 00:06:26,050
... ) [-Werror]

128
00:06:26,050 --> 00:06:28,379
ฉันหมายความว่ามันได้อย่างรวดเร็ว
ได้รับความลับมาก

129
00:06:28,379 --> 00:06:30,170
และแน่นอนว่าในตอนแรก
ได้อย่างรวดเร็วเราจะไม่

130
00:06:30,170 --> 00:06:32,380
คาดหวังว่าคุณจะเข้าใจ
ความสมบูรณ์ของข้อความนั้น

131
00:06:32,380 --> 00:06:34,213
และเพื่อให้เป็นหนึ่งในบทเรียน
สำหรับวันนี้เป็นไป

132
00:06:34,213 --> 00:06:36,919
ที่จะพยายามที่จะแจ้งให้ทราบ
รูปแบบหรือสิ่งที่คล้ายกัน

133
00:06:36,919 --> 00:06:38,960
ข้อผิดพลาดที่คุณอาจมี
พบในอดีตที่ผ่านมา

134
00:06:38,960 --> 00:06:41,335
ดังนั้นขอแซวออกจากกันเท่านั้น
คำพูดเหล่านั้นที่ดูคุ้นเคย

135
00:06:41,335 --> 00:06:44,290
ขนาดใหญ่สีแดงข้อผิดพลาดอย่างชัดเจน
สัญลักษณ์ของบางสิ่งบางอย่างผิด

136
00:06:44,290 --> 00:06:47,940
>> โดยปริยายประกาศ
ห้องสมุด printf ฟังก์ชั่น

137
00:06:47,940 --> 00:06:51,680
ดังนั้นแม้ว่าผมจะไม่เข้าใจสิ่งที่
โดยปริยายประกาศฟังก์ชั่นห้องสมุด

138
00:06:51,680 --> 00:06:54,900
หมายถึงปัญหาที่เกิดขึ้นอย่างแน่นอน
เกี่ยวข้องกับ printf อย่างใด

139
00:06:54,900 --> 00:06:59,130
และแหล่งที่มาของปัญหาว่า
จะทำอย่างไรกับประกาศว่า

140
00:06:59,130 --> 00:07:02,440
>> ประกาศฟังก์ชั่น
กล่าวถึงมันเป็นครั้งแรก

141
00:07:02,440 --> 00:07:06,210
และเราใช้คำศัพท์สัปดาห์ที่ผ่านมา
ประกาศของต้นแบบฟังก์ชั่นของการ

142
00:07:06,210 --> 00:07:11,860
ทั้งที่มีหนึ่งบรรทัดที่ด้านบนของคุณ
ไฟล์ของตัวเองหรือในไฟล์ส่วนหัวที่เรียกว่า

143
00:07:11,860 --> 00:07:15,300
และในสิ่งที่ทำไฟล์ที่เราพูด
สัปดาห์ที่แล้วว่าเป็น printf อ้าง

144
00:07:15,300 --> 00:07:17,080
ได้นำมาอ้างประกาศ?

145
00:07:17,080 --> 00:07:20,950
ในสิ่งที่ไฟล์ต้นแบบของตนหรือไม่

146
00:07:20,950 --> 00:07:24,640
>> ดังนั้นถ้าคุณจำสิ่งแรกที่ผม
พิมพ์เกือบทุกโปรแกรม time-- สุดท้าย

147
00:07:24,640 --> 00:07:30,790
และตั้งใจสักครู่ที่ผ่านมาเริ่มต้น
พิมพ์ myself-- เป็นหนึ่ง here--

148
00:07:30,790 --> 00:07:38,630
hash-- #include <stio-- สำหรับ
อินพุต / output-- จุด H และแน่นอน

149
00:07:38,630 --> 00:07:41,860
ถ้าตอนนี้ผมบันทึกไฟล์นี้ฉันจะ
ไปข้างหน้าและล้างหน้าจอของฉัน

150
00:07:41,860 --> 00:07:44,740
ซึ่งคุณสามารถทำโดยการพิมพ์
ชัดเจนหรือคุณสามารถกด Control L,

151
00:07:44,740 --> 00:07:47,680
เพียงเพื่อล้างหน้าต่าง terminal ของคุณ
เพียงเพื่อขจัดความยุ่งเหยิงบาง

152
00:07:47,680 --> 00:07:51,370
>> ฉันจะไปข้างหน้าและ
Re ชนิดทำให้ buggy0 ใส่

153
00:07:51,370 --> 00:07:53,790
และ voila ฉันยังคงเห็นว่า
คำสั่งที่ยาวจากเสียงดังกราว,

154
00:07:53,790 --> 00:07:55,470
แต่มีข้อผิดพลาดจะไม่มีเวลานี้

155
00:07:55,470 --> 00:07:58,800
และแน่นอนถ้าผมทำ ./buggy0,
เช่นเดียวกับครั้งสุดท้าย

156
00:07:58,800 --> 00:08:01,860
ที่จุดนี้หมายถึง
ไดเรกทอรี Slash เพียงหมายความว่า

157
00:08:01,860 --> 00:08:05,040
นี่มาชื่อของโปรแกรมและ
ชื่อของโปรแกรมที่เป็น buggy0,

158
00:08:05,040 --> 00:08:07,340
ใส่ "Hello, world."

159
00:08:07,340 --> 00:08:09,440
>> ตอนนี้วิธีที่คุณอาจมี
รวบรวมการแก้ปัญหานี้

160
00:08:09,440 --> 00:08:12,017
โดยไม่จำเป็นต้อง
ตระหนักถึงคำให้มากที่สุด

161
00:08:12,017 --> 00:08:14,350
เป็นผมอย่างแน่นอนมี
ทำแบบนี้มาหลายปี?

162
00:08:14,350 --> 00:08:18,720
ดีตระหนักต่อปัญหาที่เกิดขึ้นเป็นครั้งแรก
ชุดเราแนะนำให้คุณคำสั่ง

163
00:08:18,720 --> 00:08:21,175
ที่พนักงานของตัวเองของ CS50
เขียนเรียกว่า help50

164
00:08:21,175 --> 00:08:24,300
และแน่นอน, C ไม่ข้อกำหนดสำหรับ
ปัญหาที่กำหนดเป็นวิธีการที่จะใช้นี้

165
00:08:24,300 --> 00:08:27,210
>> แต่ help50 เป็นหลัก
โปรแกรมที่พนักงานของ CS50

166
00:08:27,210 --> 00:08:30,850
เขียนที่ช่วยให้คุณสามารถเรียกใช้
คำสั่งหรือเรียกใช้โปรแกรม

167
00:08:30,850 --> 00:08:36,169
และถ้าคุณไม่เข้าใจมัน
การส่งออกที่จะผ่านการส่งออกไปยัง help50,

168
00:08:36,169 --> 00:08:38,890
จุดที่ซอฟแวร์
ที่พนักงานของหลักสูตรเขียน

169
00:08:38,890 --> 00:08:42,429
จะมีลักษณะที่การส่งออกของโปรแกรม
ทีละบรรทัดตัวอักษรตัวอักษร

170
00:08:42,429 --> 00:08:46,000
และถ้าเราพนักงานที่รับรู้
ข้อผิดพลาดที่คุณพบ

171
00:08:46,000 --> 00:08:50,580
เราจะพยายามที่จะกระตุ้นให้คุณมีบางส่วน
คำถามเชิงโวหารมีคำแนะนำบางอย่าง

172
00:08:50,580 --> 00:08:54,890
เหมือน TF หรือ CA หรือตัวเอง
จะทำอย่างไรคนที่อยู่ในเวลาราชการ

173
00:08:54,890 --> 00:08:58,320
>> ดังนั้นมองไป help50 ถ้าคุณทำไม่ได้
จำเป็นต้องรับรู้ปัญหา

174
00:08:58,320 --> 00:09:00,790
แต่ไม่ต้องพึ่งพามัน
มากเกินไปเป็นไม้ยันรักแร้

175
00:09:00,790 --> 00:09:03,990
แน่นอนพยายามที่จะเข้าใจมัน
การส่งออกแล้วเรียนรู้จากมัน

176
00:09:03,990 --> 00:09:07,571
เพื่อให้มีเพียงครั้งหรือสองครั้งที่คุณทำ
เคยทำงาน help50 สำหรับข้อผิดพลาดโดยเฉพาะอย่างยิ่ง

177
00:09:07,571 --> 00:09:08,070
ข่าวสาร

178
00:09:08,070 --> 00:09:10,660
หลังจากนั้นคุณควรจะเป็น
การติดตั้งตัวเองดีกว่า

179
00:09:10,660 --> 00:09:13,180
จะคิดออกว่ามันเป็นจริง

180
00:09:13,180 --> 00:09:14,350
>> ให้ทำอย่างใดอย่างหนึ่งอื่น ๆ ที่นี่

181
00:09:14,350 --> 00:09:20,410
ให้ฉันไปข้างหน้าและในอีก
ไฟล์เราจะเรียก buggy1.c นี้

182
00:09:20,410 --> 00:09:23,110
และในแฟ้มนี้ฉัน
จะ deliberately--

183
00:09:23,110 --> 00:09:26,330
แต่แกล้งทำเป็นว่าฉันทำไม่ได้
เข้าใจในสิ่งที่ผิดพลาดที่ผมได้ทำ

184
00:09:26,330 --> 00:09:31,420
>> ฉันจะไปข้างหน้าและทำ this--
#include ตั้งแต่ฉันได้

185
00:09:31,420 --> 00:09:33,660
ได้เรียนรู้บทเรียนของฉันจากช่วงเวลาที่ผ่านมา

186
00:09:33,660 --> 00:09:36,220
int main (void) เป็นมาก่อน

187
00:09:36,220 --> 00:09:40,880
และจากนั้นในที่นี่ฉันจะ
จะทำสตริง - get_string

188
00:09:40,880 --> 00:09:43,770
และจำได้จากครั้งสุดท้ายที่
วิธีนี้ Hey, คอมพิวเตอร์,

189
00:09:43,770 --> 00:09:48,280
ให้ฉันตัวแปรเรียกมันและ
ทำให้ประเภทของตัวแปรที่สตริง

190
00:09:48,280 --> 00:09:50,150
ดังนั้นผมจึงสามารถเก็บหนึ่งหรือมากกว่าคำพูดในนั้น

191
00:09:50,150 --> 00:09:52,191
>> และจากนั้นในขวามือ
ด้านข้างของเครื่องหมายเท่ากับ

192
00:09:52,191 --> 00:09:54,980
เป็น get_string ซึ่งเป็น
ฟังก์ชั่นในห้องสมุด CS50

193
00:09:54,980 --> 00:09:55,980
ที่ไม่ตรงกับที่

194
00:09:55,980 --> 00:09:59,740
จะได้รับฟังก์ชั่นแล้ว
มือมันจากขวาไปซ้าย

195
00:09:59,740 --> 00:10:02,670
ดังนั้นเครื่องหมายเท่ากับนี้ไม่ได้หมายความว่า
"เท่ากับ" ในขณะที่เราอาจจะคิดว่าในวิชาคณิตศาสตร์

196
00:10:02,670 --> 00:10:04,750
มันหมายถึงการโอนจากขวาไปซ้าย

197
00:10:04,750 --> 00:10:09,640
ดังนั้นหมายความใช้สตริงจาก
ผู้ใช้และเก็บไว้ภายในของ s

198
00:10:09,640 --> 00:10:10,460
>> ตอนนี้ขอใช้มัน

199
00:10:10,460 --> 00:10:13,820
ผมขอไปข้างหน้าในขณะนี้และเป็นครั้งที่สอง
บรรทัดให้ฉันไปข้างหน้าและพูดว่า "สวัสดี" -

200
00:10:13,820 --> 00:10:19,330
ไม่ได้เป็น "โลก" แต่ "สวัสดี% s--
ซึ่งเป็นตัวยึดของเราจุลภาค S,

201
00:10:19,330 --> 00:10:22,030
ซึ่งเป็นตัวแปรของเรา
แล้ว semi-colon

202
00:10:22,030 --> 00:10:26,070
ดังนั้นถ้าผมไม่ได้กรูขึ้นมากเกินไป
นี่นี้ดูเหมือนว่ารหัสที่ถูกต้อง

203
00:10:26,070 --> 00:10:28,090
>> และสัญชาตญาณของฉันตอนนี้คือการรวบรวมมัน

204
00:10:28,090 --> 00:10:30,400
ไฟล์จะถูกเรียกว่า buggy1.c

205
00:10:30,400 --> 00:10:33,770
ดังนั้นฉันจะทำอะไรให้ buggy1 ใส่

206
00:10:33,770 --> 00:10:36,377
และสาปมันถ้ามีไม่ได้
แม้จะมีข้อผิดพลาดมากขึ้นกว่าก่อน

207
00:10:36,377 --> 00:10:38,210
ผมหมายถึงมีมากขึ้น
ข้อความผิดพลาดมันจะ

208
00:10:38,210 --> 00:10:40,400
ดูเหมือนกว่าเส้นที่เกิดขึ้นจริงในโปรแกรมนี้

209
00:10:40,400 --> 00:10:42,730
>> แต่ Takeaway ที่นี่คือ
แม้ว่าคุณจะจม

210
00:10:42,730 --> 00:10:45,040
มีสองหรือสามหรือ
สี่ข้อผิดพลาดมากขึ้น

211
00:10:45,040 --> 00:10:48,340
มุ่งเน้นเสมอในมาก
แรกของข้อความเหล่านั้น

212
00:10:48,340 --> 00:10:52,220
มองไปที่ด้านบนสุดหนึ่ง
เลื่อนกลับขึ้นไปเป็นจำเป็นต้องเป็น

213
00:10:52,220 --> 00:10:53,930
ดังนั้นที่นี่ฉันพิมพ์ทำให้ buggy1

214
00:10:53,930 --> 00:10:55,700
นี่คือเสียงดังกราวว่าการส่งออกตามที่คาดไว้

215
00:10:55,700 --> 00:10:57,290
>> และนี่คือความผิดพลาดครั้งแรกสีแดง

216
00:10:57,290 --> 00:11:02,370
การใช้งานของตัวระบุที่ไม่ได้ประกาศ
สตริงไม่ผมหมายถึงมาตรฐานมีอะไรบ้าง?

217
00:11:02,370 --> 00:11:04,260
ดังนั้นในมาตรฐานคือ
บางสิ่งบางอย่างอื่นจริง

218
00:11:04,260 --> 00:11:06,240
มันหมายถึงการใช้งานของ
แป้นพิมพ์เป็นหลัก

219
00:11:06,240 --> 00:11:08,080
>> แต่นั่นไม่ใช่สิ่งที่ผมหมายถึง

220
00:11:08,080 --> 00:11:11,770
ฉันหมายถึงสตริงและฉันหมาย get_string

221
00:11:11,770 --> 00:11:16,200
ดังนั้นมันจึงเป็นสิ่งที่ฉัน
ลืมที่จะทำครั้งนี้หรือไม่

222
00:11:16,200 --> 00:11:20,230
สิ่งที่หายไปครั้งนี้หรือไม่

223
00:11:20,230 --> 00:11:23,600
ฉันมี #include ของฉัน
ดังนั้นผมจึงมีการเข้าถึง printf

224
00:11:23,600 --> 00:11:26,090
>> แต่สิ่งที่ฉันไม่ได้
การเข้าถึงยังเพียง?

225
00:11:26,090 --> 00:11:29,420
ดีเช่นเดียวกับครั้งสุดท้าย
ผมจำเป็นต้องบอกคอมไพเลอร์

226
00:11:29,420 --> 00:11:31,691
เสียงดังกราวสิ่งเหล่านี้มีฟังก์ชั่น

227
00:11:31,691 --> 00:11:33,940
Get_string ไม่ได้มา
กับซีและโดยเฉพาะอย่างยิ่งมัน

228
00:11:33,940 --> 00:11:38,160
ไม่ได้มาใน
ไฟล์ส่วนหัว

229
00:11:38,160 --> 00:11:40,770
มันแทนมาใน
สิ่งที่พนักงานเขียน

230
00:11:40,770 --> 00:11:44,176
ซึ่งเป็นไฟล์ที่แตกต่างกัน
ชื่อ แต่ชื่อ aptly

231
00:11:44,176 --> 00:11:46,990

232
00:11:46,990 --> 00:11:50,861
>> ดังนั้นเพียงโดยการเพิ่มว่าหนึ่งบรรทัด
ของการเรียกคืน code-- จากครั้งสุดท้าย

233
00:11:50,861 --> 00:11:53,610
ว่าเมื่อเสียงดังกราวทำงานก็จะ
จะมองไปที่ด้านบนรหัสของฉันลงล่าง

234
00:11:53,610 --> 00:11:54,193
จากซ้ายไปขวา.

235
00:11:54,193 --> 00:11:57,200
ก็จะแจ้งให้ทราบล่วงหน้า
โอ้คุณต้องการ

236
00:11:57,200 --> 00:11:59,900
ผมขอไปและพบว่า
ทุกที่ที่มันอยู่บนเซิร์ฟเวอร์

237
00:11:59,900 --> 00:12:03,090
คัดลอกและวางเป็นหลัก
ลงไปบนของไฟล์ของคุณเอง

238
00:12:03,090 --> 00:12:06,820
เพื่อให้ที่จุดนี้ในเรื่อง
บรรทัดที่ 1 ส่วนที่เหลือของโปรแกรม

239
00:12:06,820 --> 00:12:11,651
สามารถจริงใช้ใด ๆ ของฟังก์ชั่น
ในนั้นในหมู่พวกเขา get_string

240
00:12:11,651 --> 00:12:13,650
ดังนั้นผมจะไม่สนใจ
ส่วนที่เหลือของข้อผิดพลาดเหล่านั้น

241
00:12:13,650 --> 00:12:17,190
เพราะผมแน่นอนเพียง แต่สงสัยว่า
คนแรกที่สำคัญจริง

242
00:12:17,190 --> 00:12:20,780
และฉันจะไปข้างหน้าและวิ่ง,
หลังจากบันทึกไฟล์ของฉันทำ buggy1

243
00:12:20,780 --> 00:12:22,580
และ voila มันไม่ทำงาน

244
00:12:22,580 --> 00:12:29,200
และถ้าผมทำ ./buggy1 และพิมพ์สำหรับ
เช่น Zamyla ตอนนี้ผมจะได้รับสวัสดี

245
00:12:29,200 --> 00:12:32,000
Zamyla แทน Hello, world

246
00:12:32,000 --> 00:12:32,550
>> ก็ดี

247
00:12:32,550 --> 00:12:35,890
ดังนั้นประเด็นที่นี่จึงจะเป็นไป
หนึ่งพยายามที่จะรวบรวมให้มากที่สุดเท่าที่คุณสามารถ

248
00:12:35,890 --> 00:12:39,140
จากข้อความผิดพลาดเพียงอย่างเดียวมอง
ที่บางส่วนของคำพูดที่เป็นที่รู้จัก

249
00:12:39,140 --> 00:12:43,070
แบริ่งที่ใช้ help50 ต่อ
ปัญหาการตั้งค่าสเปค

250
00:12:43,070 --> 00:12:46,500
แต่ยกเว้นที่มากเกินไปมองเสมอ
ที่ข้อผิดพลาดด้านบนเพียงอย่างน้อย

251
00:12:46,500 --> 00:12:50,051
ในขั้นต้นเพื่อดูว่าข้อมูล
มันอาจจะให้ผลจริง

252
00:12:50,051 --> 00:12:52,300
แต่มันจะเปิดออกมีของ
การทำงานมากยิ่งขึ้นสร้างขึ้น

253
00:12:52,300 --> 00:12:55,030
เข้าไปในห้องสมุด CS50 ที่จะช่วยให้
คุณในช่วงต้นของภาคการศึกษา

254
00:12:55,030 --> 00:12:57,580
และในช่วงต้นในการเขียนโปรแกรม
คิดออกสิ่งที่เกิดผิด

255
00:12:57,580 --> 00:12:59,840
เพื่อขอทำอีกตัวอย่างหนึ่งที่นี่

256
00:12:59,840 --> 00:13:04,350
ฉันจะโทร buggy2 นี้ซึ่ง
อีกครั้งเป็นไปได้ไม่สมบูรณ์ออก

257
00:13:04,350 --> 00:13:05,650
จากประตูจากการออกแบบ

258
00:13:05,650 --> 00:13:09,980
>> และฉันจะไปข้างหน้า
และทำ #include

259
00:13:09,980 --> 00:13:12,580
แล้วฉันจะทำ int main (void)

260
00:13:12,580 --> 00:13:14,840
แล้วฉันจะทำสำหรับห่วง

261
00:13:14,840 --> 00:13:16,690
สำหรับ (int i _ 0

262
00:13:16,690 --> 00:13:18,750
ฉันมีค่าน้อยกว่าหรือเท่ากับ 10

263
00:13:18,750 --> 00:13:24,260
i ++ และจากนั้นในวงเล็บปีกกาฉันจะ
จะพิมพ์ออกมาเป็นเพียงแค่สัญลักษณ์แฮชแท็กที่นี่

264
00:13:24,260 --> 00:13:25,920
และตัวอักษรบรรทัดใหม่

265
00:13:25,920 --> 00:13:29,220
>> ดังนั้นความตั้งใจของฉันกับเรื่องนี้
โปรแกรมค่อนข้างเป็นเพียง

266
00:13:29,220 --> 00:13:33,150
เพื่อย้ำ 10 ครั้ง
และในแต่ละซ้ำ

267
00:13:33,150 --> 00:13:35,260
ของวงว่าทุกครั้งที่
ผ่านวงจร

268
00:13:35,260 --> 00:13:37,660
พิมพ์ออกมาแฮชแท็ก
แฮชแท็ก, แฮชแท็ก

269
00:13:37,660 --> 00:13:40,480
บรรทัดต่อหนึ่งเพราะผม
มีการขึ้นบรรทัดใหม่มี

270
00:13:40,480 --> 00:13:42,787
และจำได้ว่าสำหรับ
ห่วงต่อ week-- สุดท้าย

271
00:13:42,787 --> 00:13:44,620
และคุณจะได้รับเพิ่มเติม
คุ้นเคยกับไวยากรณ์

272
00:13:44,620 --> 00:13:47,170
โดยใช้มันกับการปฏิบัติ
ก่อนที่จะ long-- นี้ให้ฉัน

273
00:13:47,170 --> 00:13:49,740
ตัวแปรที่เรียกว่า I และชุดมันเป็น 0

274
00:13:49,740 --> 00:13:52,650
>> นี้เพิ่มฉันใน
ซ้ำโดยทุก 1

275
00:13:52,650 --> 00:13:54,940
ดังนั้นฉันไปเป็น 1 เพื่อ 2-3

276
00:13:54,940 --> 00:13:57,690
แล้วสภาพนี้ใน
ตรงกลางระหว่างจุดคู่กึ่ง

277
00:13:57,690 --> 00:14:03,010
ได้รับการตรวจสอบในทุกย้ำที่จะทำให้
แน่ใจว่าเรายังคงอยู่ในช่วง

278
00:14:03,010 --> 00:14:06,830
ดังนั้นผมจึงอยากจะย้ำ 10 ครั้งดังนั้นฉัน
มีการจัดเรียงมากสังหรณ์ใจเพียง

279
00:14:06,830 --> 00:14:09,070
ใส่ 10 ขอบเขตบนของฉันมี

280
00:14:09,070 --> 00:14:14,310
>> และยังเมื่อฉันทำงานนี้หลังจาก
รวบรวมกับ Make buggy2--

281
00:14:14,310 --> 00:14:15,440
และมันไม่รวบรวมตกลง

282
00:14:15,440 --> 00:14:17,980
ดังนั้นผมจึงไม่ได้มีการ
ไวยากรณ์ผิดพลาดในครั้งนี้

283
00:14:17,980 --> 00:14:20,940
ผมขอไปข้างหน้าในขณะนี้
และเรียกใช้ buggy2 ใส่

284
00:14:20,940 --> 00:14:22,620
และตอนนี้เลื่อนขึ้น

285
00:14:22,620 --> 00:14:24,890
และแจ้งให้เราเพิ่มขึ้น
ขนาดของหน้าต่าง

286
00:14:24,890 --> 00:14:33,720
>> ฉันดูเหมือนจะมี 1, 2, 3,
4, 5, 6, 7, 8, 9, 10, 11

287
00:14:33,720 --> 00:14:38,891
ดังนั้นจึงมี 11 hashtags แม้ว่า
ฉันชัดเจนใส่ภายใน 10 ของวงนี้

288
00:14:38,891 --> 00:14:42,140
ตอนนี้บางท่านอาจจะเห็นได้ทันที
สิ่งที่ผิดพลาดเป็นเพราะจริงนี้

289
00:14:42,140 --> 00:14:43,720
ไม่ได้เป็นข้อผิดพลาดที่ยากมากที่จะทำให้

290
00:14:43,720 --> 00:14:46,070
แต่มันเป็นบ่อยมาก
ทำมากในช่วงต้น

291
00:14:46,070 --> 00:14:49,820
>> สิ่งที่ผมอยากจะชี้ให้เห็น แต่
คือวิธีที่ผมอาจจะคิดออกนี้?

292
00:14:49,820 --> 00:14:52,300
ดีก็ปรากฎว่า
ห้องสมุด CS50 มา

293
00:14:52,300 --> 00:14:55,380
ไม่เพียง get_string และ get_int
และ get_float และฟังก์ชั่นอื่น ๆ

294
00:14:55,380 --> 00:14:59,980
นอกจากนี้ยังมาพร้อมกับฟังก์ชั่นพิเศษ
เรียกว่า eprintf หรือ printf ข้อผิดพลาด

295
00:14:59,980 --> 00:15:03,270
และมันมีอยู่ แต่เพียงผู้เดียวที่จะทำให้
มันเล็กน้อยง่ายสำหรับคุณ

296
00:15:03,270 --> 00:15:06,310
เมื่อการแก้จุดบกพร่องรหัสของคุณเพียงแค่
พิมพ์ข้อความผิดพลาดบนหน้าจอ

297
00:15:06,310 --> 00:15:07,850
และรู้ว่ามันมาจากไหน

298
00:15:07,850 --> 00:15:11,000
>> ดังนั้นสำหรับตัวอย่างเช่นสิ่งหนึ่งที่ผมอาจจะ
ทำที่นี่ด้วยฟังก์ชั่นนี้เป็น this--

299
00:15:11,000 --> 00:15:20,230
eprintf แล้วฉันจะไปข้างหน้า
และกล่าวว่าตอนนี้ฉันคือ% i, ทับขวา, N

300
00:15:20,230 --> 00:15:22,330
และฉันจะเสียบค่าของฉัน

301
00:15:22,330 --> 00:15:25,400
และขึ้นด้านบนเพราะนี้
อยู่ในห้องสมุด CS50,

302
00:15:25,400 --> 00:15:27,580
ฉันจะไปข้างหน้า
และรวมถึง

303
00:15:27,580 --> 00:15:29,169
ดังนั้นผมจึงมีการเข้าถึงฟังก์ชั่นนี้

304
00:15:29,169 --> 00:15:31,460
แต่ขอพิจารณาสิ่งที่บรรทัด
9 ควรจะทำ

305
00:15:31,460 --> 00:15:32,670
ฉันจะลบนี้ในที่สุด

306
00:15:32,670 --> 00:15:34,670
นี้มีอะไรจะทำอย่างไร
กับเป้าหมายที่ครอบคลุมของฉัน

307
00:15:34,670 --> 00:15:39,090
แต่ eprintf, printf ข้อผิดพลาดที่มีความหมายเพียงแค่
จะให้ฉันข้อมูลการวินิจฉัยบาง

308
00:15:39,090 --> 00:15:42,460
เมื่อฉันเรียกใช้โปรแกรมของฉันฉันต้องการที่จะ
เห็นนี้บนหน้าจอชั่วคราว

309
00:15:42,460 --> 00:15:44,550
จะดีแค่ที่จะเข้าใจ
เกิดอะไรขึ้น.

310
00:15:44,550 --> 00:15:47,330
>> และแน่นอนในแต่ละ
ย้ำที่นี่ของสาย 9

311
00:15:47,330 --> 00:15:49,260
ผมอยากจะเห็นสิ่งที่เป็นคุณค่าของฉันหรือไม่

312
00:15:49,260 --> 00:15:50,290
ค่าของฉันคืออะไร?

313
00:15:50,290 --> 00:15:51,280
ค่าของฉันคืออะไร?

314
00:15:51,280 --> 00:15:55,650
และหวังว่าฉันควร
เห็นข้อความที่ยัง 10 ครั้ง

315
00:15:55,650 --> 00:15:57,780
>> เพื่อให้ฉันไปข้างหน้าและ
คอมไพล์โปรแกรมของฉัน

316
00:15:57,780 --> 00:15:59,905
ขณะที่ผมต้องทำตลอดเวลา
ฉันจะทำให้การเปลี่ยนแปลง ./buggy2

317
00:15:59,905 --> 00:16:02,680

318
00:16:02,680 --> 00:16:03,640
และ now-- ตกลง

319
00:16:03,640 --> 00:16:04,820
มีจำนวนมากขึ้นไปบน

320
00:16:04,820 --> 00:16:07,610
เพื่อให้ฉันเลื่อนขึ้นใน
หน้าต่างที่ยิ่งใหญ่

321
00:16:07,610 --> 00:16:10,190
>> และคุณจะเห็นว่าแต่ละ
แฮชแท็กยังคงพิมพ์

322
00:16:10,190 --> 00:16:15,270
แต่ในระหว่างแต่ละของพวกเขาอยู่ในขณะนี้
เอาท์พุทวินิจฉัยรูปแบบดังนี้

323
00:16:15,270 --> 00:16:17,960
ชื่อของโปรแกรมของฉันที่นี่คือ buggy2

324
00:16:17,960 --> 00:16:20,432
ชื่อของไฟล์ที่เป็น buggy2.c

325
00:16:20,432 --> 00:16:24,080
หมายเลขบรรทัดจากการที่
นี้ถูกตีพิมพ์เป็นสาย 9

326
00:16:24,080 --> 00:16:27,500
และจากนั้นไปทางขวาของที่เป็น
ข้อผิดพลาดที่ฉันคาดหวัง

327
00:16:27,500 --> 00:16:30,701
>> และสิ่งที่ดีเกี่ยวกับเรื่องนี้ก็คือว่า
ตอนนี้ฉันไม่จำเป็นต้องนับ

328
00:16:30,701 --> 00:16:32,200
ในหัวของฉันสิ่งที่โปรแกรมของฉันจะทำ

329
00:16:32,200 --> 00:16:34,240
ฉันจะเห็นว่าบน
ย้ำแรกที่ผมเป็น 0

330
00:16:34,240 --> 00:16:39,420
แล้ว 1 แล้ว 2 แล้ว 3 แล้ว 4 แล้ว
5 แล้ว 6 จากนั้น 7 แล้ว 8 แล้ว 9 แล้ว

331
00:16:39,420 --> 00:16:40,980
10

332
00:16:40,980 --> 00:16:42,050
ดังนั้นรอสักครู่

333
00:16:42,050 --> 00:16:43,740
เกิดอะไรขึ้นที่นี่?

334
00:16:43,740 --> 00:16:48,190
ฉันยังคงดูเหมือนจะนับ
ตามที่ตั้งใจไว้ได้ถึง 10

335
00:16:48,190 --> 00:16:50,550
>> แต่ผมไม่เริ่มต้นอย่างไร

336
00:16:50,550 --> 00:16:53,240
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 10

337
00:16:53,240 --> 00:16:58,040
ดังนั้น 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, 10-- 11 นิ้ว

338
00:16:58,040 --> 00:16:59,990
บ่งบอกถึงปัญหาที่เกิดขึ้น

339
00:16:59,990 --> 00:17:02,850
ฉันดูเหมือนจะได้นับ
ไม่ถูกต้องในวงของฉัน

340
00:17:02,850 --> 00:17:06,599
แทนที่จะไป 10 การทำซ้ำ
ฉันเริ่มที่ 0,

341
00:17:06,599 --> 00:17:09,550
ฉันสิ้นสุดที่ 10 และผ่านการ

342
00:17:09,550 --> 00:17:12,030
แต่เป็นเพราะเช่นเครื่องคอมพิวเตอร์
ฉันเริ่มนับที่ 0,

343
00:17:12,030 --> 00:17:15,250
ฉันควรจะนับ
แต่ไม่ผ่าน 10

344
00:17:15,250 --> 00:17:18,510
>> และเพื่อให้การแก้ไขในที่สุดผม
ตระหนักถึงที่นี่เป็นหนึ่งในสองสิ่ง

345
00:17:18,510 --> 00:17:22,430
ฉันมากเพียงอาจจะบอกว่า
นับถึงน้อยกว่า 10

346
00:17:22,430 --> 00:17:27,260
ดังนั้น 0, 1, 2, 3, 4, 5, 6, 7, 8,
9 ซึ่งเป็นจริงที่ถูกต้อง

347
00:17:27,260 --> 00:17:28,900
แม้ว่ามันจะฟังดูผิดเล็ก ๆ น้อย ๆ

348
00:17:28,900 --> 00:17:35,070
หรือฉันจะทำน้อยกว่าหรือเท่ากับ
9 ตราบใดที่ผมเริ่มต้นที่ 0

349
00:17:35,070 --> 00:17:40,056
หรือถ้าคุณไม่ชอบที่คุณ
สามารถนับขึ้นถึง 10 แต่เริ่มต้นที่ 1

350
00:17:40,056 --> 00:17:41,680
แต่อีกครั้งนี้ก็ไม่ได้เป็นที่พบบ่อย

351
00:17:41,680 --> 00:17:43,977
ใน programming-- แม้ว่า
ไม่มากใน Scratch--

352
00:17:43,977 --> 00:17:45,810
แต่ในการเขียนโปรแกรมใน
ภาษา C และอื่น ๆ

353
00:17:45,810 --> 00:17:47,670
เช่น JavaScript และ
งูหลามและคนอื่น ๆ ก็

354
00:17:47,670 --> 00:17:49,880
เพียงแค่เรื่องธรรมดามากสำหรับ
การอภิปรายของไบนารีของเรา

355
00:17:49,880 --> 00:17:53,450
เพียงแค่เริ่มนับที่
จำนวนมากที่สุดที่คุณสามารถซึ่งเป็น 0

356
00:17:53,450 --> 00:17:53,950
ก็ดี

357
00:17:53,950 --> 00:17:55,160
ดังนั้นที่ eprintf

358
00:17:55,160 --> 00:17:58,600
และอีกครั้งตอนนี้ที่ผมเคยคิดออกของฉัน
ปัญหาและฉันจะกลับไปที่ 0

359
00:17:58,600 --> 00:18:01,470
ผ่านน้อยกว่า 10 ฉันจะ
ไปในการลบ eprintf

360
00:18:01,470 --> 00:18:04,580
>> มันไม่ควรจะมีเมื่อฉัน
จัดส่งรหัสของฉันหรือส่งรหัสของฉัน

361
00:18:04,580 --> 00:18:05,800
หรือแสดงให้คนอื่น

362
00:18:05,800 --> 00:18:07,980
มันจริงๆเพียงแค่ความหมาย
ที่จะนำมาใช้ชั่วคราว

363
00:18:07,980 --> 00:18:11,650
แต่ตอนนี้ฉันได้รับการแก้ไขนี้
ปัญหาเฉพาะเช่นกัน

364
00:18:11,650 --> 00:18:16,780
>> ดีขอทำตัวอย่างหนึ่งที่เพิ่มเติมที่นี่
ว่าฉันจะชักขึ้นดังต่อไปนี้

365
00:18:16,780 --> 00:18:22,850
ฉันจะไปข้างหน้าและ
#include $ 50

366
00:18:22,850 --> 00:18:25,580
และฉันจะไปข้างหน้า
และ #include

367
00:18:25,580 --> 00:18:29,030
>> และฉันจะประหยัด
แฟ้มนี้เป็น buggy3.c

368
00:18:29,030 --> 00:18:31,740
และฉันจะไปข้างหน้า
และประกาศ int main (void)

369
00:18:31,740 --> 00:18:34,186
และจากนั้นภายในมี
ฉันจะทำ int i _ -

370
00:18:34,186 --> 00:18:36,435
ฉันต้องการที่จะใช้โปรแกรม
กับ get_negative_int

371
00:18:36,435 --> 00:18:39,146

372
00:18:39,146 --> 00:18:40,770
นี้ไม่ได้เป็นฟังก์ชั่นที่มีอยู่ยัง

373
00:18:40,770 --> 00:18:42,870
ดังนั้นเรากำลังจะดำเนินการ
ได้ในเพียงสักครู่

374
00:18:42,870 --> 00:18:45,541
แต่เรากำลังจะไปดูว่าทำไม
มันเป็นรถที่ผ่านครั้งแรก

375
00:18:45,541 --> 00:18:47,290
และเมื่อผมเคย
เป็น int จากผู้ใช้

376
00:18:47,290 --> 00:18:53,365
ฉันแค่จะพิมพ์ฉัน% เป็นเชิงลบ
จำนวนเต็มทับขวา, N, จุลภาคฉัน

377
00:18:53,365 --> 00:18:55,240
ในคำอื่น ๆ ทั้งหมดที่ฉัน
ต้องการโปรแกรมนี้จะทำอย่างไร

378
00:18:55,240 --> 00:18:58,000
คือการได้รับ int เชิงลบจาก
ผู้ใช้แล้วพิมพ์ออกมา

379
00:18:58,000 --> 00:18:59,980
ที่ดังกล่าวและเช่นเป็น int เชิงลบ

380
00:18:59,980 --> 00:19:02,080
>> ตอนนี้ผมต้องใช้ฟังก์ชั่นนี้

381
00:19:02,080 --> 00:19:05,740
ดังนั้นต่อมาในแฟ้มของฉันฉันจะไป
ไปข้างหน้าและประกาศฟังก์ชั่นที่เรียกว่า

382
00:19:05,740 --> 00:19:10,670
get_negative_int (void) - และเราจะ
กลับมากับสิ่งที่หมายถึงสายอีกครั้ง

383
00:19:10,670 --> 00:19:18,790
ใน moment-- int n; do-- ทำ
following-- printf n คือ :.

384
00:19:18,790 --> 00:19:26,210
แล้วฉันจะทำ n - get_int,
และทำในขณะนี้ n มากกว่า 0

385
00:19:26,210 --> 00:19:28,310
แล้วกลับ n ;.

386
00:19:28,310 --> 00:19:31,730
>> ดังนั้นมีจำนวนมากที่เกิดขึ้นใน
แต่ไม่มีใครที่เราไม่ได้

387
00:19:31,730 --> 00:19:33,710
มองไปที่สัปดาห์ที่ผ่านมาอย่างน้อยในเวลาสั้น ๆ

388
00:19:33,710 --> 00:19:36,980
ดังนั้นในบรรทัด 10 นี่ผมได้ประกาศให้เป็น
ฟังก์ชั่นที่เรียกว่า get_negative_int,

389
00:19:36,980 --> 00:19:39,620
และฉันได้ใส่ (void) ใน
วงเล็บเหตุผลที่มีนี้

390
00:19:39,620 --> 00:19:40,950
ไม่ใช้การป้อนข้อมูล

391
00:19:40,950 --> 00:19:42,910
ฉันไม่ได้ผ่านอะไร
ฟังก์ชั่นนี้

392
00:19:42,910 --> 00:19:44,690
ฉันแค่สิ่งที่ได้รับกลับมาจากมัน

393
00:19:44,690 --> 00:19:47,270
>> และสิ่งที่ฉันหวังที่จะ
ได้รับกลับเป็นจำนวนเต็ม

394
00:19:47,270 --> 00:19:50,040
ไม่มีชนิดข้อมูลคือ
C เรียกว่า negative_int

395
00:19:50,040 --> 00:19:52,880
มันเป็นเพียงแค่ int เพื่อให้มันเป็นไป
ที่จะอยู่กับเราเพื่อให้แน่ใจว่า

396
00:19:52,880 --> 00:19:55,340
ว่าค่าที่เป็นจริง
กลับไม่ได้เป็นเพียง int

397
00:19:55,340 --> 00:19:56,380
แต่ก็ยังเป็นเชิงลบ

398
00:19:56,380 --> 00:20:02,150
>> On line ที่ 12 ผมประกาศตัวแปร
เรียกว่า n และทำให้มันเป็นชนิด int

399
00:20:02,150 --> 00:20:07,500
และจากนั้นในบรรทัดที่ 13 ถึง 18 ฉัน
ทำอะไรบางอย่างในขณะที่สิ่งที่เป็นความจริง

400
00:20:07,500 --> 00:20:11,040
ฉันจะไปข้างหน้าและการพิมพ์
n คือลำไส้ใหญ่แล้วช่องว่าง

401
00:20:11,040 --> 00:20:12,800
เช่นพรอมต์สำหรับผู้ใช้

402
00:20:12,800 --> 00:20:16,410
>> ฉันแล้วโทร get_int และ
การจัดเก็บค่าตอบแทนของสิ่งที่เรียกว่า

403
00:20:16,410 --> 00:20:18,130
ในตัวแปรที่ n

404
00:20:18,130 --> 00:20:22,600
แต่ฉันจะให้ทำ
ขณะนี้ n มากกว่า 0

405
00:20:22,600 --> 00:20:27,960
ในคำอื่น ๆ หากผู้ใช้ให้ฉัน
int และจำนวนที่มากกว่า 0

406
00:20:27,960 --> 00:20:31,180
Ergo บวกฉันจะ
เพียงแค่ให้ reprompting ผู้ใช้

407
00:20:31,180 --> 00:20:37,160
ให้ reprompting โดยบังคับให้พวกเขา
ความร่วมมือและให้ฉัน int เชิงลบ

408
00:20:37,160 --> 00:20:41,640
>> และเมื่อ n คือ negative-- จริง
สมมติว่าผู้ใช้ที่สุดประเภท -50,

409
00:20:41,640 --> 00:20:46,710
แล้วห่วงขณะนี้ไม่เป็นความจริง
เพราะ -50 ไม่มากกว่า 0

410
00:20:46,710 --> 00:20:51,140
ดังนั้นเราจึงแยกออกจากที่
ห่วงเหตุผลและกลับ n

411
00:20:51,140 --> 00:20:53,520
>> แต่มีคนอื่น ๆ
สิ่งที่ฉันต้องทำ

412
00:20:53,520 --> 00:20:56,190
และฉันก็สามารถทำเช่นนี้
โดยการคัดลอกและวาง

413
00:20:56,190 --> 00:20:58,540
หนึ่งบรรทัดของรหัสที่ด้านบนของไฟล์

414
00:20:58,540 --> 00:21:01,630
ฉันต้องการที่จะสอนให้เสียงดังกราว,
หรือสัญญาว่าจะเสียงดังกราว,

415
00:21:01,630 --> 00:21:04,630
อย่างชัดเจนว่าผมจะ
แน่นอนไปและดำเนินการ

416
00:21:04,630 --> 00:21:06,020
get_negative_int ฟังก์ชั่นนี้

417
00:21:06,020 --> 00:21:07,674
มันก็อาจจะลดลงในแฟ้ม

418
00:21:07,674 --> 00:21:09,840
อีกครั้งจำได้ว่าเสียงดังกราว
อ่านสิ่งบนลงล่าง

419
00:21:09,840 --> 00:21:12,330
จากซ้ายไปขวาคุณจึงไม่สามารถ
เรียกใช้ฟังก์ชันถ้าเสียงดังกราว

420
00:21:12,330 --> 00:21:15,330
ไม่ทราบว่ามันจะมีอยู่

421
00:21:15,330 --> 00:21:18,430
>> ตอนนี้น่าเสียดายที่โปรแกรมนี้
ขณะที่บางท่านอาจจะได้สังเกตเห็น

422
00:21:18,430 --> 00:21:19,590
เป็นรถแล้ว

423
00:21:19,590 --> 00:21:21,400
ให้ฉันไปข้างหน้าและทำให้ buggy3

424
00:21:21,400 --> 00:21:26,904
มันรวบรวมดังนั้นปัญหาของฉันตอนนี้ไม่ได้
ไวยากรณ์ผิดพลาดเช่นข้อผิดพลาดเกี่ยวกับใจ,

425
00:21:26,904 --> 00:21:29,570
จริงมันจะเป็นตรรกะ
ข้อผิดพลาดที่ผมเคยจงใจ

426
00:21:29,570 --> 00:21:32,450
ทำให้เป็นโอกาสต่อไปยัง
ก้าวผ่านสิ่งที่เกิดขึ้น

427
00:21:32,450 --> 00:21:35,540
>> ฉันจะไปข้างหน้า
ในขณะนี้และวิ่ง buggy3

428
00:21:35,540 --> 00:21:37,490
และฉันจะไป
ข้างหน้าและไม่ให้ความร่วมมือ

429
00:21:37,490 --> 00:21:39,494
ฉันจะให้หมายเลข 1

430
00:21:39,494 --> 00:21:41,410
มันไม่ชอบมันดังนั้น
มันกระตุ้นให้ฉันอีกครั้ง

431
00:21:41,410 --> 00:21:42,147
>> วิธีการเกี่ยวกับ 2 หรือไม่?

432
00:21:42,147 --> 00:21:43,021
3 หรือไม่?

433
00:21:43,021 --> 00:21:43,520
50?

434
00:21:43,520 --> 00:21:44,740
ไม่มีของเหล่านี้จะทำงาน

435
00:21:44,740 --> 00:21:46,890
วิธีการเกี่ยวกับ -50?

436
00:21:46,890 --> 00:21:48,560
และโปรแกรมที่ดูเหมือนว่าจะทำงาน

437
00:21:48,560 --> 00:21:49,970
>> ผมขอลองอีกครั้ง

438
00:21:49,970 --> 00:21:53,400
ผมขอลอง -1 ดูเหมือนว่าจะทำงาน

439
00:21:53,400 --> 00:21:56,380
ผมขอลอง -2, ดูเหมือนว่าจะทำงาน

440
00:21:56,380 --> 00:21:59,640
ผมขอลอง 0

441
00:21:59,640 --> 00:22:01,684
อืมมมที่ไม่ถูกต้อง

442
00:22:01,684 --> 00:22:03,350
ตอนนี้เรากำลังถูกอวดความรู้เล็ก ๆ น้อย ๆ ที่นี่

443
00:22:03,350 --> 00:22:07,090
แต่มันเป็นความจริงกรณีที่ 0
เป็นค่าบวกหรือเชิงลบ

444
00:22:07,090 --> 00:22:11,150
และเพื่อให้ความจริงที่ว่าโปรแกรมของฉันคือ
บอกว่า 0 เป็นจำนวนเต็มลบ

445
00:22:11,150 --> 00:22:12,820
ที่ไม่ถูกต้องในทางเทคนิค

446
00:22:12,820 --> 00:22:15,180
>> ตอนนี้ทำไมมันทำเช่นนี้?

447
00:22:15,180 --> 00:22:16,270
ดีก็อาจจะเห็นได้ชัด

448
00:22:16,270 --> 00:22:18,110
และแน่นอนโปรแกรมคือ
หมายถึงการเป็นที่ค่อนข้างง่าย

449
00:22:18,110 --> 00:22:19,670
เพื่อให้เรามีบางสิ่งบางอย่างที่จะสำรวจ

450
00:22:19,670 --> 00:22:25,870
>> แต่ขอแนะนำการแก้จุดบกพร่องที่สาม
เทคนิคที่นี่เรียกว่า debug50

451
00:22:25,870 --> 00:22:27,750
ดังนั้นนี่คือโปรแกรม
ที่เราได้สร้างขึ้น

452
00:22:27,750 --> 00:22:30,770
ปีนี้เรียกว่า debug50
ที่จะทำให้คุณ

453
00:22:30,770 --> 00:22:34,130
ที่จะใช้สิ่งที่เรียกว่าในตัว
กราฟิกดีบักใน CS50 IDE

454
00:22:34,130 --> 00:22:38,400
และดีบักเป็นเพียงโปรแกรมที่
โดยทั่วไปจะช่วยให้คุณสามารถเรียกใช้โปรแกรมของคุณ

455
00:22:38,400 --> 00:22:44,050
แต่ทีละขั้นตอนโดยขั้นตอนสาย
โดยทีละบรรทัดหยุดโผล่

456
00:22:44,050 --> 00:22:47,626
รอบกำลังมองหาที่ตัวแปรเพื่อให้
โปรแกรมไม่เพียงพัดผ่านมาคุณ

457
00:22:47,626 --> 00:22:49,750
ได้อย่างรวดเร็วและพิมพ์บางสิ่งบางอย่าง
หรือไม่สามารถพิมพ์บางสิ่งบางอย่าง

458
00:22:49,750 --> 00:22:53,250
มันทำให้คุณมีโอกาสที่
ความเร็วของมนุษย์ในการโต้ตอบกับมัน

459
00:22:53,250 --> 00:22:55,470
>> และการทำเช่นนี้คุณ
เพียงแค่ทำต่อไปนี้

460
00:22:55,470 --> 00:22:58,479
หลังจากรวบรวมรหัสของคุณ
ซึ่งฉันไม่อยู่แล้ว buggy3,

461
00:22:58,479 --> 00:23:00,020
คุณไปข้างหน้าและเรียก ./buggy debug50

462
00:23:00,020 --> 00:23:03,460

463
00:23:03,460 --> 00:23:06,760
ดังนั้นเหมือน help50 มีคุณเรียก
help50 แล้วคำสั่ง

464
00:23:06,760 --> 00:23:10,120
debug50 มีคุณเรียก debug50 และ
แล้วชื่อของคำสั่ง

465
00:23:10,120 --> 00:23:14,440
>> ตอนนี้ดูสิ่งที่เกิดขึ้นบนหน้าจอของฉัน
อยู่ทางด้านขวามือโดยเฉพาะอย่างยิ่ง

466
00:23:14,440 --> 00:23:19,400
เมื่อกดเรียกใช้ทั้งหมดของ
ฉับพลันแผงนี้ทางด้านขวามือ

467
00:23:19,400 --> 00:23:20,419
เปิดขึ้นบนหน้าจอ

468
00:23:20,419 --> 00:23:22,210
และมีจำนวนมากที่เกิด
บนได้อย่างรวดเร็วก่อน

469
00:23:22,210 --> 00:23:25,110
แต่มีไม่มากเกินไป
มากที่จะต้องกังวลเกี่ยวกับเลย

470
00:23:25,110 --> 00:23:28,570
>> นี้จะแสดงให้ฉันทุกอย่าง
ที่เกิดขึ้นภายในของโปรแกรมของฉัน

471
00:23:28,570 --> 00:23:31,130
ตอนนี้และผ่านทางเหล่านี้
ปุ่มขึ้นด้านบนแล้ว

472
00:23:31,130 --> 00:23:35,910
ช่วยให้ผมก้าวผ่านรห​​ัสของฉัน
ในที่สุดทีละขั้นตอนโดยขั้นตอน

473
00:23:35,910 --> 00:23:37,140
แต่ไม่เพียง แต่

474
00:23:37,140 --> 00:23:38,060
ขอให้สังเกตสิ่งที่เกิดขึ้น

475
00:23:38,060 --> 00:23:40,600
ที่หน้าต่าง terminal ของฉัน
ฉันถูกพร้อมท์สำหรับ n

476
00:23:40,600 --> 00:23:44,560
และฉันจะไปข้างหน้าและ
ความร่วมมือในครั้งนี้และพิมพ์ -1

477
00:23:44,560 --> 00:23:48,770
และแม้จะเล็ก ๆ น้อย ๆ ความลับ, -1
เป็นจำนวนเต็มลบตามที่คาดไว้

478
00:23:48,770 --> 00:23:52,020
>> แล้วเดินออกมาจากเด็กที่มี
สถานะ 0 GDBserver ออก

479
00:23:52,020 --> 00:23:55,180
GDB, GNU ดีบักเป็นชื่อ
ซอฟต์แวร์พื้นฐาน

480
00:23:55,180 --> 00:23:56,620
ที่ดำเนินการดีบักนี้

481
00:23:56,620 --> 00:24:00,500
แต่ทั้งหมดนี้จริงๆหมายถึงดีบัก
เดินออกไปเพราะโปรแกรมของฉันเลิก

482
00:24:00,500 --> 00:24:01,710
และทั้งหมดได้ดี

483
00:24:01,710 --> 00:24:06,020
ถ้าผมต้องการแก้ปัญหาอย่างแท้จริงโปรแกรมของฉัน
ฉันต้องบอก preemptively debug50,

484
00:24:06,020 --> 00:24:08,920
ที่ฉันต้องการที่จะเริ่มต้น
ก้าวผ่านรห​​ัสของฉัน?

485
00:24:08,920 --> 00:24:11,750
>> และอาจจะเป็นวิธีที่ง่ายที่สุด
จะทำอย่างไรที่จะเป็นดังนี้

486
00:24:11,750 --> 00:24:15,300
ถ้าผมเลื่อนเมาส์ไปที่
รางน้ำของการแก้ไขของฉันที่นี่

487
00:24:15,300 --> 00:24:19,090
ดังนั้นจริงๆเพียงแค่ในแถบด้านข้างที่นี่
ด้านซ้ายของจำนวนบรรทัด

488
00:24:19,090 --> 00:24:21,870
ขอให้สังเกตว่าถ้าฉันเพียงแค่คลิก
ครั้งหนึ่งผมใส่จุดสีแดงเล็ก ๆ น้อย ๆ

489
00:24:21,870 --> 00:24:24,460
และที่จุดสีแดงเล็ก ๆ น้อย ๆ
เช่นป้ายหมายความว่าเดี๋ยวก่อน

490
00:24:24,460 --> 00:24:29,430
debug50 การดำเนินการหยุดการทำงานชั่วคราวของรหัสของฉัน
ที่นั่นเมื่อฉันเรียกใช้โปรแกรมนี้

491
00:24:29,430 --> 00:24:30,260
>> ดังนั้นขอให้ทำอย่างนั้น

492
00:24:30,260 --> 00:24:37,340
ให้ฉันไปข้างหน้าและเรียกใช้โปรแกรมของฉัน
อีกครั้งกับ debug50 ./buggy3 ใส่

493
00:24:37,340 --> 00:24:40,110
และตอนนี้แจ้งให้ทราบล่วงหน้าบางสิ่งบางอย่าง
ที่แตกต่างกันได้เกิดขึ้น

494
00:24:40,110 --> 00:24:42,440
ฉันไม่ได้ถาม
ยังอยู่ในหน้าต่าง terminal ของฉัน

495
00:24:42,440 --> 00:24:45,430
สำหรับอะไรเพราะฉันไม่ได้
อากาศยังมีในโปรแกรมของฉัน

496
00:24:45,430 --> 00:24:47,950
ขอให้สังเกตว่าในบรรทัดที่ 8
ซึ่งเป็นไฮไลต์ในขณะนี้

497
00:24:47,950 --> 00:24:51,720
และมีลูกศรเล็ก ๆ ที่
คำกล่าวที่ว่าซ้ายคุณจะหยุดชั่วคราวที่นี่

498
00:24:51,720 --> 00:24:55,030
บรรทัดของรหัสบรรทัดนี้
8 ยังไม่ได้ดำเนินการ

499
00:24:55,030 --> 00:24:58,940
>> และสิ่งที่อยากรู้อยากเห็นถ้าฉันมอง
มากกว่าที่นี่อยู่ทางด้านขวามือ

500
00:24:58,940 --> 00:25:03,530
สังเกตเห็นว่าฉันเป็นท้องถิ่น
ตัวแปรท้องถิ่นในความรู้สึก

501
00:25:03,530 --> 00:25:05,450
ว่ามันเป็นฟังก์ชั่นภายในปัจจุบัน

502
00:25:05,450 --> 00:25:08,920
และความคุ้มค่าของมันเห็นได้ชัดโดยค่าเริ่มต้น
และการเรียงลำดับของความสะดวกคือ 0

503
00:25:08,920 --> 00:25:10,260
แต่ผมไม่ได้พิมพ์ 0

504
00:25:10,260 --> 00:25:13,410
ที่เพิ่งเกิดขึ้นเป็นของตน
ค่าเริ่มต้นในขณะนี้

505
00:25:13,410 --> 00:25:15,490
>> เพื่อให้ฉันไปข้างหน้าและทำเช่นนี้ในขณะนี้

506
00:25:15,490 --> 00:25:18,680
ให้ฉันไปข้างหน้าและใน
ด้านบนขวาที่นี่ผม

507
00:25:18,680 --> 00:25:20,970
จะไปข้างหน้าและ
คลิกที่ไอคอนนี้เป็นครั้งแรกที่

508
00:25:20,970 --> 00:25:25,360
หมายถึงขั้นตอนมากกว่าซึ่งหมายความว่าไม่ข้าม
แต่ก้าวข้ามบรรทัดของรหัสนี้

509
00:25:25,360 --> 00:25:27,770
รันมันไปพร้อมกัน

510
00:25:27,770 --> 00:25:30,710
>> และตอนนี้สังเกตเห็นของฉัน
พรอมต์มีการเปลี่ยนแปลงเพียง

511
00:25:30,710 --> 00:25:31,380
ทำไมเป็นเช่นนั้น?

512
00:25:31,380 --> 00:25:33,639
ฉันบอก debug50,
เรียกใช้บรรทัดของรหัสนี้

513
00:25:33,639 --> 00:25:34,930
สิ่งที่ไม่บรรทัดของรหัสนี้ทำอย่างไร

514
00:25:34,930 --> 00:25:35,960
แจ้งให้ฉันสำหรับ int

515
00:25:35,960 --> 00:25:36,460
ตกลง.

516
00:25:36,460 --> 00:25:37,400
ผมขอความร่วมมือ

517
00:25:37,400 --> 00:25:41,340
ผมขอไปข้างหน้าในขณะนี้และพิมพ์ -1 ใส่

518
00:25:41,340 --> 00:25:42,920
และตอนนี้สังเกตเห็นสิ่งที่มีการเปลี่ยนแปลง

519
00:25:42,920 --> 00:25:46,060
อยู่ทางด้านขวามือ
ตัวแปรท้องถิ่นของฉัน

520
00:25:46,060 --> 00:25:48,200
ถูกระบุว่าเป็น -1 ในขณะนี้

521
00:25:48,200 --> 00:25:49,810
และก็ยังคงชนิด int

522
00:25:49,810 --> 00:25:53,102
>> และแจ้งให้ทราบเกินไปฉันเรียกว่า
โทรสแต็คที่ฉันไม่หยุด?

523
00:25:53,102 --> 00:25:54,810
เราจะพูดคุยเกี่ยวกับ
นี้ในอนาคต

524
00:25:54,810 --> 00:25:58,620
แต่เรียกกองเพียงหมายถึงสิ่งที่
ฟังก์ชั่นที่มีอยู่ในปัจจุบันในการเคลื่อนไหว

525
00:25:58,620 --> 00:26:00,040
ตอนนี้มันเป็นเพียงแค่หลัก

526
00:26:00,040 --> 00:26:03,590
และตอนนี้ในประเทศอื่น
ตัวแปรคือฉันมีค่าเป็น 1

527
00:26:03,590 --> 00:26:09,840
>> และเมื่อในที่สุดผมก็ก้าวข้ามบรรทัดนี้
ที่นี่กับไอคอนที่เดียวกันที่ด้านขวาบน

528
00:26:09,840 --> 00:26:11,410
-1 เป็นจำนวนเต็มเชิงลบ

529
00:26:11,410 --> 00:26:13,580
ตอนนี้ก็หยุดมากกว่าที่วงเล็บปีกกา

530
00:26:13,580 --> 00:26:14,740
ลองปล่อยให้มันทำสิ่งที่ตน

531
00:26:14,740 --> 00:26:17,300
ผมก้าวข้ามเส้นนั้นและ voila

532
00:26:17,300 --> 00:26:20,240
>> ดังนั้นไม่ได้ทั้งหมดที่ชะมัด
enlightening ยัง

533
00:26:20,240 --> 00:26:23,550
แต่มันไม่ให้ผมหยุด
และคิดว่าผ่านเหตุผล

534
00:26:23,550 --> 00:26:24,870
สิ่งที่โปรแกรมนี้จะทำ

535
00:26:24,870 --> 00:26:26,890
แต่นั่นก็ไม่ได้เป็นกรณีที่ผิดพลาด

536
00:26:26,890 --> 00:26:28,510
ลองทำเช่นนี้อีกครั้งดังต่อไปนี้

537
00:26:28,510 --> 00:26:31,340
>> ฉันจะออกจากจุดพักที่
ในบรรทัดที่ 8 มีจุดสีแดง

538
00:26:31,340 --> 00:26:32,830
ฉันจะเรียก debug50

539
00:26:32,830 --> 00:26:34,400
มันหยุดชั่วคราวโดยอัตโนมัติที่นี่

540
00:26:34,400 --> 00:26:37,660
แต่ครั้งนี้แทน
ก้าวข้ามเส้นนี้

541
00:26:37,660 --> 00:26:42,290
ให้ฉันจริงไปภายในของ
get_negative_int และคิดออก

542
00:26:42,290 --> 00:26:45,530
มันเป็นเหตุผลที่ยอมรับ 0 เป็นคำตอบที่ถูกต้อง?

543
00:26:45,530 --> 00:26:47,990
>> ดังนั้นแทนที่จะคลิกขั้นตอนจบ

544
00:26:47,990 --> 00:26:50,630
ฉันจะไปข้างหน้า
และคลิกขั้นตอนไป

545
00:26:50,630 --> 00:26:54,030
และแจ้งให้ทราบว่าเส้นที่ 8
ตอนนี้ไฮไลต์ในขณะนี้อย่างกระทันหัน

546
00:26:54,030 --> 00:26:56,900
กลายเป็นสาย 17

547
00:26:56,900 --> 00:26:59,947
>> ตอนนี้ก็ไม่ได้ว่าการดีบัก
ได้ข้ามเส้น 14 และ 15 และ 16

548
00:26:59,947 --> 00:27:01,780
มันเป็นเพียงแค่ไม่มีอะไร
จะแสดงให้คุณมี

549
00:27:01,780 --> 00:27:04,050
เหล่านี้เป็นเพียงการประกาศตัวแปร
แล้วมีคำว่าทำ

550
00:27:04,050 --> 00:27:05,390
แล้วเปิดวงเล็บปีกกา

551
00:27:05,390 --> 00:27:09,227
บรรทัดเดียวที่ทำงาน
ฉ่ำจริงๆเป็นหนึ่งในที่นี่ 17

552
00:27:09,227 --> 00:27:11,060
และนั่นคือสิ่งที่เราได้
หยุดชั่วคราวโดยอัตโนมัติ

553
00:27:11,060 --> 00:27:13,870
>> ดังนั้น printf ( "n.is:") เพื่อให้ ;,
ที่ยังไม่เกิดขึ้น

554
00:27:13,870 --> 00:27:18,250
ดังนั้นขอให้ไปข้างหน้าและก้าวข้ามคลิก

555
00:27:18,250 --> 00:27:20,326
ตอนนี้พรอมต์ของฉันแน่นอน
เปลี่ยนไป ( "n คือ:")

556
00:27:20,326 --> 00:27:22,450
ตอนนี้ get_int ผมไม่ได้ไป
เพื่อก้าวเข้าสู่รำคาญ,

557
00:27:22,450 --> 00:27:24,750
เพราะฟังก์ชั่นที่ได้รับ
ทำโดย CS50 ในห้องสมุด

558
00:27:24,750 --> 00:27:25,750
มันเป็นเรื่องที่ถูกต้องสันนิษฐานว่า

559
00:27:25,750 --> 00:27:28,440
>> ดังนั้นฉันจะไปข้างหน้าและ
การเรียงลำดับของความร่วมมือโดยให้มัน

560
00:27:28,440 --> 00:27:30,590
เป็น int แต่ไม่ int เชิงลบ

561
00:27:30,590 --> 00:27:32,870
เพื่อให้ฉันไปข้างหน้าและกด 0

562
00:27:32,870 --> 00:27:39,460
และตอนนี้สิ่งที่เกิดขึ้นที่นี่
เมื่อฉันได้รับลงไปที่บรรทัดที่ 21?

563
00:27:39,460 --> 00:27:40,890
ฉันไม่ได้ซ้ำอีกครั้ง

564
00:27:40,890 --> 00:27:43,320
ฉันไม่ได้ดูเหมือนจะติดอยู่ในวงที่

565
00:27:43,320 --> 00:27:45,990
ในคำอื่น ๆ , สีเหลืองนี้
แถบไม่ได้เก็บไปรอบ ๆ

566
00:27:45,990 --> 00:27:47,130
และบริเวณใกล้เคียงและรอบ ๆ

567
00:27:47,130 --> 00:27:48,340
>> ตอนนี้ทำไมเป็นเช่นนั้น?

568
00:27:48,340 --> 00:27:49,920
ดี N, n สิ่งที่ตอนนี้?

569
00:27:49,920 --> 00:27:53,280
ฉันสามารถมองไปที่ท้องถิ่น
ตัวแปรในการดีบัก

570
00:27:53,280 --> 00:27:53,816
n คือ 0

571
00:27:53,816 --> 00:27:55,190
สิทธิทั้งหมดสิ่งที่เป็นไปตามเงื่อนไขของฉันได้อย่างไร

572
00:27:55,190 --> 00:27:58,700
>> 20-- เส้น 20 คือดี
0 มากกว่า 0

573
00:27:58,700 --> 00:27:59,500
ว่าไม่เป็นความจริง

574
00:27:59,500 --> 00:28:01,020
0 ไม่มากกว่า 0

575
00:28:01,020 --> 00:28:02,820
และดังนั้นผมจึงโพล่งออกมานี้

576
00:28:02,820 --> 00:28:06,370
>> และเพื่อที่ว่าทำไมในบรรทัด
21 ถ้าจริงผมดำเนินการต่อ

577
00:28:06,370 --> 00:28:10,370
ฉันจะกลับ 0 แม้
แม้ว่าฉันควรจะได้ปฏิเสธ 0

578
00:28:10,370 --> 00:28:12,484
ที่จะไม่เป็นจริงในเชิงลบ

579
00:28:12,484 --> 00:28:14,650
ดังนั้นตอนนี้ฉันทำไม่ได้จริงๆแม้กระทั่ง
ดูแลเกี่ยวกับการดีบัก

580
00:28:14,650 --> 00:28:16,900
Got มันฉันไม่จำเป็นต้อง
รู้ว่าสิ่งที่มากขึ้นเป็นสิ่งที่เกิดขึ้น

581
00:28:16,900 --> 00:28:19,233
>> ดังนั้นฉันจะไปข้างหน้าและ
เพียงแค่คลิกที่ปุ่ม Play,

582
00:28:19,233 --> 00:28:20,240
และปล่อยให้เรื่องนี้จบลง

583
00:28:20,240 --> 00:28:23,440
ตอนนี้ผมได้ตระหนักว่าฉัน
ข้อผิดพลาดที่เห็นได้ชัดคือในบรรทัด 20

584
00:28:23,440 --> 00:28:25,160
นั่นเป็นข้อผิดพลาดทางตรรกะของฉัน

585
00:28:25,160 --> 00:28:28,100
>> และเพื่อทำในสิ่งที่ฉันต้องการ
ที่จะทำอะไรเพื่อเปลี่ยนแปลงนี้หรือไม่?

586
00:28:28,100 --> 00:28:32,500
ถ้าปัญหาคือว่าฉันไม่ได้
จับ 0 มันเป็นเพียงความผิดพลาดเชิงตรรกะ

587
00:28:32,500 --> 00:28:35,910
และผมสามารถพูดในขณะที่ n คือ
มากกว่าหรือเท่ากับ 0

588
00:28:35,910 --> 00:28:38,330
ให้แจ้งให้ผู้ใช้อีกครั้งและอีกครั้ง

589
00:28:38,330 --> 00:28:41,050
>> ดังนั้นอีกครั้งผิดพลาดง่ายบางที
ที่เห็นได้ชัดแม้เมื่อคุณเห็นฉัน

590
00:28:41,050 --> 00:28:42,410
เขียนเพียงไม่กี่นาทีที่ผ่านมา

591
00:28:42,410 --> 00:28:44,570
แต่ Takeaway ที่นี่
เป็นที่ที่มีการแก้ปัญหา 50,

592
00:28:44,570 --> 00:28:46,850
และมีการแก้จุดบกพร่อง
ซอฟแวร์มากกว่าปกติ

593
00:28:46,850 --> 00:28:51,370
คุณต้องพบพลังงานใหม่เพื่อ
เดินผ่านรห​​ัสของคุณเองดู

594
00:28:51,370 --> 00:28:55,590
ผ่านแผงมือด้านขวาที่สิ่งที่
ค่าตัวแปรของคุณ

595
00:28:55,590 --> 00:28:57,700
ดังนั้นคุณจึงไม่จำเป็นต้อง
มีบางสิ่งบางอย่างที่จะใช้

596
00:28:57,700 --> 00:29:00,630
เช่นเดียวกับคุณ eprintf พิมพ์ค่าเหล่านั้น

597
00:29:00,630 --> 00:29:04,430
จริงๆคุณสามารถเห็นพวกเขา
สายตาบนหน้าจอ

598
00:29:04,430 --> 00:29:08,920
>> ตอนนี้นอกเหนือจากนี้มันเป็นมูลค่า noting
ว่ามีเทคนิคที่อื่น

599
00:29:08,920 --> 00:29:09,890
จริงสุดที่พบบ่อย

600
00:29:09,890 --> 00:29:13,120
และคุณอาจจะสงสัยว่าทำไมนี้เล็ก ๆ น้อย ๆ
ผู้ชายคนที่นี่ได้รับการนั่งอยู่บนเวที

601
00:29:13,120 --> 00:29:16,490
ดังนั้นจึงมีเทคนิคนี้โดยทั่วไป
ที่รู้จักกันเป็นเป็ดยางแก้จุดบกพร่อง

602
00:29:16,490 --> 00:29:18,786
ซึ่งจริงๆเป็นเพียง
ข้อพิสูจน์ถึงความเป็นจริง

603
00:29:18,786 --> 00:29:20,660
ที่มักจะเมื่อโปรแกรมเมอร์
มีการเขียนโค้ด

604
00:29:20,660 --> 00:29:22,650
พวกเขาไม่จำเป็นต้อง
การทำงานร่วมกันกับคนอื่น ๆ

605
00:29:22,650 --> 00:29:24,030
หรือการทำงานในสภาพแวดล้อมที่ใช้ร่วมกัน

606
00:29:24,030 --> 00:29:25,050
>> พวกเขากำลังจัดเรียงของที่บ้าน

607
00:29:25,050 --> 00:29:25,910
บางทีมันอาจจะเป็นในช่วงดึก

608
00:29:25,910 --> 00:29:28,190
พวกเขากำลังพยายามที่จะคิด
จากข้อผิดพลาดบางอย่างในรหัสของพวกเขา

609
00:29:28,190 --> 00:29:29,330
และพวกเขากำลังก็ไม่เห็นมัน

610
00:29:29,330 --> 00:29:30,329
>> และไม่มีเพื่อนร่วมห้อง

611
00:29:30,329 --> 00:29:31,250
ไม่มี TF คือ

612
00:29:31,250 --> 00:29:32,680
มี CA ไม่มีรอบ

613
00:29:32,680 --> 00:29:36,440
ทั้งหมดที่พวกเขามีในการเก็บรักษาของพวกเขา
นี้เป็นยางที่รักเล็ก ๆ น้อย ๆ

614
00:29:36,440 --> 00:29:39,030
>> และเพื่อให้การแก้จุดบกพร่องเป็ดยาง
เป็นเพียงคำเชิญนี้

615
00:29:39,030 --> 00:29:42,780
ที่จะคิดว่าสิ่งที่เป็นความโง่
เช่นนี้เป็นสิ่งมีชีวิตจริง

616
00:29:42,780 --> 00:29:46,940
และที่จริงเดินผ่านรห​​ัสของคุณ
ด้วยวาจาไปยังวัตถุที่ไม่มีชีวิตนี้

617
00:29:46,940 --> 00:29:49,230
ดังนั้นสำหรับตัวอย่างเช่นถ้า
นี่คือตัวอย่างของฉัน here--

618
00:29:49,230 --> 00:29:52,470
และจำได้ว่าก่อนหน้านี้
ปัญหาที่เกิดขึ้นนี้

619
00:29:52,470 --> 00:29:58,140
ถ้าฉันลบบรรทัดแรกนี้ของรหัส
และฉันไปข้างหน้าและทำให้รถ 0 อีกครั้ง

620
00:29:58,140 --> 00:30:01,220
จำได้ว่าผมมีเหล่านี้
ข้อความผิดพลาดที่นี่

621
00:30:01,220 --> 00:30:05,997
ดังนั้นความคิดที่นี่ไร้สาระ แต่ฉัน
รู้สึกว่าในขณะที่การทำเช่นนี้ต่อสาธารณชน

622
00:30:05,997 --> 00:30:06,580
เป็นข้อผิดพลาดที่

623
00:30:06,580 --> 00:30:10,910
>> ตกลงดังนั้นปัญหาของฉันที่ฉันได้
โดยปริยายประกาศให้เป็นฟังก์ชั่นห้องสมุด

624
00:30:10,910 --> 00:30:12,610
และฟังก์ชั่นที่เป็นห้องสมุด printf

625
00:30:12,610 --> 00:30:15,290
Declare-- ตกลงประกาศ
ทำให้ผมนึกถึงต้นแบบ

626
00:30:15,290 --> 00:30:18,930
>> นั่นหมายความว่าฉันต้องการจริง
บอกคอมไพเลอร์ล่วงหน้าว่า

627
00:30:18,930 --> 00:30:19,980
ฟังก์ชั่นที่มีลักษณะดังนี้

628
00:30:19,980 --> 00:30:20,930
เดี๋ยวก่อน.

629
00:30:20,930 --> 00:30:23,580
ฉันไม่ได้มี io.h. มาตรฐาน

630
00:30:23,580 --> 00:30:24,530
ขอบคุณมาก.

631
00:30:24,530 --> 00:30:27,330
>> ดังนั้นเพียงแค่ขั้นตอนนี้ of-- คุณ
ไม่จำเป็นต้องจริงมีเป็ด

632
00:30:27,330 --> 00:30:29,819
แต่ความคิดของการเดินนี้
ตัวเองผ่านรห​​ัสของคุณเอง

633
00:30:29,819 --> 00:30:31,610
เพื่อให้คุณได้ยิน
ตัวเองเพื่อให้คุณ

634
00:30:31,610 --> 00:30:35,620
ตระหนักถึงการละเว้นในของคุณเอง
พูดโดยทั่วไปคือความคิด

635
00:30:35,620 --> 00:30:38,910
>> และบางทีอาจจะมากกว่าเหตุผลไม่ได้ดังนั้น
มากกับที่หนึ่ง แต่ที่เกี่ยวข้องมากขึ้น

636
00:30:38,910 --> 00:30:44,220
ตัวอย่างเช่นเราก็ทำใน 3.c รถ,
คุณอาจจะเดินผ่านมันด้วยตัวคุณเอง

637
00:30:44,220 --> 00:30:45,310
ดังต่อไปนี้

638
00:30:45,310 --> 00:30:49,190
ดังนั้นสิทธิทั้งหมดยาง
Ducky, DDB ถ้าคุณจะ

639
00:30:49,190 --> 00:30:52,350
ที่นี่เรามีฟังก์ชั่นหลักของฉัน
ฉันโทรได้รับ int เชิงลบ

640
00:30:52,350 --> 00:30:54,660
>> และฉันได้รับค่าตอบแทน

641
00:30:54,660 --> 00:31:00,410
ฉันเก็บไว้ทางด้านซ้ายมือ
ในบรรทัดที่ 8 ในตัวแปรที่เรียกว่าฉัน

642
00:31:00,410 --> 00:31:02,380
OK แต่รอไง
ที่ได้รับค่าที่?

643
00:31:02,380 --> 00:31:04,130
ให้ฉันมองไปที่การทำงานในสาย 12

644
00:31:04,130 --> 00:31:05,760
>> ในบรรทัดที่ 12 เรามีได้รับ int เชิงลบ

645
00:31:05,760 --> 00:31:08,190
ไม่ได้ใช้ปัจจัยการผลิตใด ๆ
ไม่กลับมาเป็น int, OK

646
00:31:08,190 --> 00:31:10,929
ผมประกาศบนเส้น 14 A N ตัวแปร

647
00:31:10,929 --> 00:31:12,220
มันเป็นไปได้ในการจัดเก็บเป็นจำนวนเต็ม

648
00:31:12,220 --> 00:31:13,760
นั่นคือสิ่งที่ฉันต้องการ.

649
00:31:13,760 --> 00:31:18,480
>> ดังนั้นต่อไปนี้ขณะ n is-- ให้
ฉันเลิกทำสิ่งที่แก้ไขที่เราทำอยู่แล้ว

650
00:31:18,480 --> 00:31:22,710
ดังนั้นในขณะที่ n มากกว่า
0, พิมพ์ N มีตกลง

651
00:31:22,710 --> 00:31:25,170
แล้วเรียกได้เก็บไว้ใน int n

652
00:31:25,170 --> 00:31:30,160
แล้วตรวจสอบถ้า n เป็น 0
n คือ not-- มีเป็น

653
00:31:30,160 --> 00:31:31,910
ดังนั้นอีกครั้งคุณทำไม่ได้
ต้องเป็ดที่เกิดขึ้นจริง

654
00:31:31,910 --> 00:31:35,650
แต่เพียงแค่เดินผ่านด้วยตัวคุณเอง
รหัสของคุณเป็นการออกกำลังกายทางปัญญา

655
00:31:35,650 --> 00:31:37,720
มักจะช่วยให้คุณ
ตระหนักถึงสิ่งที่เกิดขึ้น

656
00:31:37,720 --> 00:31:41,170
เมื่อเทียบกับเพียงแค่การทำบางสิ่งบางอย่าง
เช่นนี้จ้องมองที่หน้าจอ

657
00:31:41,170 --> 00:31:43,720
และไม่ได้พูดถึงตัวเองผ่าน
มันซึ่งตรงไปตรงมาไม่ได้

658
00:31:43,720 --> 00:31:46,270
เกือบเป็นเทคนิคที่มีประสิทธิภาพ

659
00:31:46,270 --> 00:31:48,620
จึงมีคุณมีมันเป็น
จำนวนเทคนิคที่แตกต่าง

660
00:31:48,620 --> 00:31:52,102
สำหรับการแก้จุดบกพร่องจริงรหัสของคุณ
และค้นหาความผิดซึ่งทั้งหมดนี้

661
00:31:52,102 --> 00:31:54,810
ควรจะเป็นเครื่องมือในชุดเครื่องมือของคุณ
เพื่อให้คุณไม่ได้อยู่ในช่วงดึก

662
00:31:54,810 --> 00:31:57,660
โดยเฉพาะอย่างยิ่งคุณอยู่ในอาหาร
ห้องโถงหรืออย่างเวลาทำการ

663
00:31:57,660 --> 00:32:00,368
ทุบหัวของคุณกับ
ผนังพยายามที่จะแก้ปัญหาบางอย่าง

664
00:32:00,368 --> 00:32:02,020
ทราบว่ามีเครื่องมือซอฟต์แวร์

665
00:32:02,020 --> 00:32:03,720
มีเครื่องมือเป็ดยาง

666
00:32:03,720 --> 00:32:09,630
และมีพนักงานทั้งหมดของ
สนับสนุนการรอคอยที่จะยืมมือ

667
00:32:09,630 --> 00:32:13,120
>> ดังนั้นตอนนี้คำในการแก้ปัญหา
ชุดและในสิ่งที่เราหวังว่าคุณ

668
00:32:13,120 --> 00:32:15,620
ได้รับจากพวกเขาและวิธี
เราไปเกี่ยวกับการประเมิน

669
00:32:15,620 --> 00:32:17,680
ต่อรายวิชาที่
CS50 ของชุดปัญหา

670
00:32:17,680 --> 00:32:22,320
จะมีการประเมินสี่แกนหลักเพื่อ
เพื่อ speak-- ขอบเขตความถูกต้อง, การออกแบบ

671
00:32:22,320 --> 00:32:23,060
และรูปแบบ

672
00:32:23,060 --> 00:32:25,910
และขอบเขตเพียงหมายถึงเท่าไหร่
ของชิ้นคุณกัดปิด?

673
00:32:25,910 --> 00:32:28,080
คุณมีวิธีการมากของปัญหาพยายาม?

674
00:32:28,080 --> 00:32:30,110
สิ่งที่ระดับของความพยายาม
คุณประจักษ์?

675
00:32:30,110 --> 00:32:35,750
>> ความถูกต้องคือไม่ทำงานโปรแกรมเป็น
มันควรจะตามข้อกำหนด CS50

676
00:32:35,750 --> 00:32:38,640
เมื่อคุณให้ปัจจัยการผลิตบางอย่าง
หรือผลบางอย่างกลับมา?

677
00:32:38,640 --> 00:32:41,130
การออกแบบเป็นอัตนัยที่สุดของพวกเขา

678
00:32:41,130 --> 00:32:43,360
และมันก็เป็นหนึ่งที่จะ
ใช้เวลานานที่สุดที่จะเรียนรู้

679
00:32:43,360 --> 00:32:47,220
และยาวที่สุดในการสอนใน
เท่าที่มันเดือดลงไป,

680
00:32:47,220 --> 00:32:49,530
วิธีที่ดีที่เขียนเป็นรหัสของคุณหรือไม่

681
00:32:49,530 --> 00:32:52,920
>> มันเป็นสิ่งหนึ่งที่จะเพียงแค่พิมพ์ที่ถูกต้อง
เอาท์พุทหรือค่าตอบแทนที่เหมาะสม

682
00:32:52,920 --> 00:32:55,400
แต่คุณกำลังทำมันเป็น
มีประสิทธิภาพเป็นไปได้หรือไม่

683
00:32:55,400 --> 00:32:58,210
คุณกำลังทำมันแบ่ง
และพิชิตหรือไบนารี

684
00:32:58,210 --> 00:33:01,500
ค้นหาในขณะที่เราเร็ว ๆ นี้จะเห็นว่าเราไม่ได้ทำ
สองสัปดาห์ที่ผ่านมากับสมุดโทรศัพท์?

685
00:33:01,500 --> 00:33:04,670
จะมีวิธีการที่ดีในการแก้ปัญหา
ปัญหาที่เกิดขึ้นกว่าที่คุณในขณะนี้มีที่นี่?

686
00:33:04,670 --> 00:33:06,380
นั่นเป็นโอกาสสำหรับการออกแบบที่ดีกว่า

687
00:33:06,380 --> 00:33:08,530
>> แล้ว style-- วิธี
สวยเป็นรหัสของคุณหรือไม่

688
00:33:08,530 --> 00:33:12,370
คุณจะสังเกตเห็นว่าฉันสวย
โดยเฉพาะเกี่ยวกับการเยื้องรหัสของฉัน

689
00:33:12,370 --> 00:33:15,300
และทำให้แน่ใจว่าตัวแปรของฉัน
มีชื่อพอสมควร n,

690
00:33:15,300 --> 00:33:19,660
ในขณะที่ระยะสั้นเป็นชื่อที่ดีสำหรับ
จำนวนฉันสำหรับจำนวนเต็มนับ

691
00:33:19,660 --> 00:33:20,727
สำหรับสตริง

692
00:33:20,727 --> 00:33:22,560
และเราจะได้มีอีกต่อไป
สไตล์ชื่อตัวแปร

693
00:33:22,560 --> 00:33:25,500
สไตล์เป็นเพียงวิธีการที่ดี
ไม่รหัสของคุณมอง?

694
00:33:25,500 --> 00:33:26,600
และวิธีการที่สามารถอ่านได้มันคืออะไร?

695
00:33:26,600 --> 00:33:29,650
>> และเมื่อเวลาผ่านไปสิ่งที่ครูของคุณ
และ TFS จะทำในหลักสูตร

696
00:33:29,650 --> 00:33:31,870
จะให้คุณกับที่
ชนิดของข้อมูลเชิงคุณภาพ

697
00:33:31,870 --> 00:33:34,330
เพื่อที่คุณจะได้รับดีกว่า
ในแง่มุมต่าง ๆ เหล่านั้น

698
00:33:34,330 --> 00:33:37,510
และในแง่ของวิธีการที่เรา
ประเมินแต่ละของแกนเหล่านี้

699
00:33:37,510 --> 00:33:40,080
ก็มักจะมีน้อยมาก
บุ้งกี๋เพื่อให้คุณโดยทั่วไป

700
00:33:40,080 --> 00:33:41,680
ได้รับความรู้สึกของวิธีการที่ดีที่คุณทำ

701
00:33:41,680 --> 00:33:45,680
และแน่นอนถ้าคุณได้รับคะแนนใน
ใด ๆ ของผู้ axes-- ความถูกต้อง, การออกแบบ

702
00:33:45,680 --> 00:33:49,659
และสไตล์ especially-- ตัวเลขที่
โดยทั่วไปจะอยู่ระหว่าง 1 และ 5

703
00:33:49,659 --> 00:33:52,450
และตัวอักษรหากคุณได้รับ
3 ในช่วงเริ่มต้นของภาคการศึกษาที่

704
00:33:52,450 --> 00:33:53,977
นี้เป็นสิ่งที่ดีมาก

705
00:33:53,977 --> 00:33:55,810
มันหมายความว่ายังคงมี
ห้องพักสำหรับการปรับปรุง

706
00:33:55,810 --> 00:33:58,490
ที่คุณจะหวังใน
การเรียนเป็นครั้งแรก

707
00:33:58,490 --> 00:34:01,820
มีหวังว่าบิตของเพดานบางส่วน
ที่คุณกำลังต้องการที่จะถึง

708
00:34:01,820 --> 00:34:03,970
และเพื่อให้ได้รับ 3 บน
ชิ้นที่เก่าแก่ที่สุด

709
00:34:03,970 --> 00:34:06,550
ถ้าไม่ได้บางส่วน 2 และ 4 ของ
เป็นจริงเป็นสิ่งที่ดี

710
00:34:06,550 --> 00:34:08,880
มันเป็นอย่างดีในช่วง
อย่างดีในความคาดหวัง

711
00:34:08,880 --> 00:34:11,421
>> และถ้าใจของคุณจะแข่งรอ
นาทีสามในห้า

712
00:34:11,421 --> 00:34:12,620
นั่นคือจริงๆ 6 จาก 10

713
00:34:12,620 --> 00:34:13,560
นั่นคือ 60%

714
00:34:13,560 --> 00:34:14,830
พระเจ้าของฉันที่เป็นเอฟ

715
00:34:14,830 --> 00:34:15,870
>> มันไม่ใช่.

716
00:34:15,870 --> 00:34:17,600
มันไม่ได้ในความเป็นจริงว่า

717
00:34:17,600 --> 00:34:22,710
แต่ก็มีโอกาสที่จะปรับปรุง
ผ่านหลักสูตรของภาคการศึกษา

718
00:34:22,710 --> 00:34:25,580
และถ้าคุณได้รับบาง
Poors เหล่านี้เป็นโอกาส

719
00:34:25,580 --> 00:34:29,199
เพื่อใช้ประโยชน์จากเวลาทำการ
แน่นอนส่วนและทรัพยากรอื่น ๆ

720
00:34:29,199 --> 00:34:32,840
>> ที่ดีที่สุดคือโอกาสจริงๆ
จะเป็นความภาคภูมิใจของได้ไกลแค่ไหนคุณได้

721
00:34:32,840 --> 00:34:34,520
มามากกว่าหลักสูตรของภาคการศึกษา

722
00:34:34,520 --> 00:34:38,199
จึงตระหนักถึงถ้าไม่มีอะไร
อื่นสามเป็นสิ่งที่ดี

723
00:34:38,199 --> 00:34:40,179
และมันช่วยให้ห้องพักสำหรับการเจริญเติบโตในช่วงเวลา

724
00:34:40,179 --> 00:34:43,090
>> เป็นวิธีการที่แกนเหล่านี้จะ
ถ่วงน้ำหนักแนบเนียนคุณ

725
00:34:43,090 --> 00:34:46,745
จะใช้เวลาส่วนใหญ่ของคุณได้รับ
สิ่งที่จะทำงานให้อยู่คนเดียวได้อย่างถูกต้อง

726
00:34:46,745 --> 00:34:49,120
และเพื่อความถูกต้องมีแนวโน้มที่จะ
ให้น้ำหนักมากที่สุดเช่นเดียวกับ

727
00:34:49,120 --> 00:34:51,360
ปัจจัยคูณสาม

728
00:34:51,360 --> 00:34:54,659
การออกแบบยังเป็นสิ่งสำคัญ แต่
บางสิ่งบางอย่างที่คุณไม่จำเป็นต้อง

729
00:34:54,659 --> 00:34:58,220
ใช้จ่ายทั้งหมดของผู้ที่อยู่ในชั่วโมง
พยายามที่จะได้รับสิ่งที่เป็นเพียงแค่การทำงาน

730
00:34:58,220 --> 00:35:00,019
>> และดังนั้นจึงถ่วงน้ำหนัก
เล็ก ๆ น้อย ๆ เบา ๆ

731
00:35:00,019 --> 00:35:01,560
และจากนั้นรูปแบบจะมีน้ำหนักน้อย

732
00:35:01,560 --> 00:35:03,710
แม้ว่ามันจะไม่น้อย
สิ่งสำคัญพื้นฐาน

733
00:35:03,710 --> 00:35:05,990
มันเป็นเพียงแค่บางที
สิ่งที่ง่ายที่สุดที่จะทำขวา

734
00:35:05,990 --> 00:35:08,440
ลอกเลียนแบบตัวอย่างที่เรา
ทำในการบรรยายและส่วน

735
00:35:08,440 --> 00:35:11,080
กับสิ่งอย่าง
เยื้องและแสดงความคิดเห็น

736
00:35:11,080 --> 00:35:14,320
และอื่น ๆ เป็นหนึ่งในที่ง่ายที่สุด
สิ่งที่ต้องทำและได้รับสิทธิ

737
00:35:14,320 --> 00:35:16,960
ดังนั้นเป็นเช่นนี้ตระหนักถึง
ว่าผู้ที่เป็นจุด

738
00:35:16,960 --> 00:35:19,000
ที่ค่อนข้างง่ายต่อการเข้าใจ

739
00:35:19,000 --> 00:35:22,360
>> และตอนนี้คำใน
ซื่อสัตย์ในการศึกษา this--

740
00:35:22,360 --> 00:35:25,150
ดังนั้นต่อหลักสูตร
หลักสูตรคุณจะเห็น

741
00:35:25,150 --> 00:35:27,630
ว่าหลักสูตรมีค่อนข้าง
บิตของภาษารอบนี้

742
00:35:27,630 --> 00:35:31,380
และแน่นอนที่จะเกิดปัญหาของ
ซื่อสัตย์ในการศึกษาค่อนข้างจริงจัง

743
00:35:31,380 --> 00:35:33,450
>> เรามีความแตกต่าง
ดีขึ้นหรือแย่ลง

744
00:35:33,450 --> 00:35:36,570
ของที่ได้ส่งในแต่ละปีมากขึ้น
นักเรียนสำหรับการดำเนินการทางวินัย

745
00:35:36,570 --> 00:35:39,670
มากที่สุดกว่าคนอื่น ๆ
แน่นอนว่าฉันรู้

746
00:35:39,670 --> 00:35:42,580
นี้ไม่จำเป็นต้อง
บ่งบอกถึงความเป็นจริง

747
00:35:42,580 --> 00:35:46,340
ว่านักเรียน CS หรือนักเรียน CS50 เป็น
น้อย ๆ เที่ยงตรงกว่าเพื่อนร่วมชั้นของคุณ

748
00:35:46,340 --> 00:35:49,090
แต่ความเป็นจริงที่ว่าในนี้
โลกอิเล็กทรอนิกส์เราเพียงแค่

749
00:35:49,090 --> 00:35:50,990
มีเทคโนโลยี
หมายถึงการตรวจสอบนี้

750
00:35:50,990 --> 00:35:53,360
>> มันเป็นสิ่งสำคัญเพื่อให้เรา
ความเป็นธรรมทั่วชั้นเรียน

751
00:35:53,360 --> 00:35:58,550
ที่เราทำตรวจสอบนี้และยกระดับ
ปัญหาเมื่อเราเห็นสิ่งที่

752
00:35:58,550 --> 00:36:01,980
และเพียงแค่การวาดภาพและจริงๆ
ที่จะช่วยให้สิ่งที่ชอบอ่างนี้ใน

753
00:36:01,980 --> 00:36:04,600
เหล่านี้เป็นตัวเลขของ
นักเรียนที่ผ่านมา 10 ปี

754
00:36:04,600 --> 00:36:07,610
ที่ได้มีส่วนร่วมในบาง
ปัญหาดังกล่าวของความซื่อสัตย์ทางวิชาการ

755
00:36:07,610 --> 00:36:10,990
มีนักเรียนบางคน 32
จากฤดูใบไม้ร่วงปี 2015 ซึ่ง

756
00:36:10,990 --> 00:36:13,760
คือจะบอกว่าเราไม่ใช้
เรื่องนี้เป็นอย่างมาก

757
00:36:13,760 --> 00:36:18,380
และในที่สุดตัวเลขเหล่านี้เขียน
เมื่อเร็ว ๆ นี้ประมาณ 3%, 4% หรือมากกว่านั้น

758
00:36:18,380 --> 00:36:19,120
ของชั้นเรียน

759
00:36:19,120 --> 00:36:25,220
>> ดังนั้นสำหรับส่วนสุดของนักเรียน
ดูเหมือนว่าเส้นที่มีความชัดเจน

760
00:36:25,220 --> 00:36:27,940
แต่ไม่เก็บไว้ใน
ใจโดยเฉพาะอย่างยิ่งในช่วงปลาย

761
00:36:27,940 --> 00:36:32,080
ในเวลากลางคืนเมื่อดิ้นรนกับ
วิธีการแก้ปัญหาบางอย่างที่จะเป็นชุดที่มีปัญหา

762
00:36:32,080 --> 00:36:34,830
ว่ามีกลไก
สำหรับการเดินทางด้วยตัวเองดีกว่า

763
00:36:34,830 --> 00:36:37,870
สนับสนุนกว่าที่คุณอาจ
คิดว่าแม้ในเวลานั้น

764
00:36:37,870 --> 00:36:40,514
ตระหนักดีว่าเมื่อเราได้รับ
ส่งนักเรียนเราข้าม

765
00:36:40,514 --> 00:36:43,430
เปรียบเทียบการส่งทุกปีนี้
กับการส่งทุกปีที่ผ่านมา

766
00:36:43,430 --> 00:36:47,590
กับการส่งจาก 2007 ทุก
และตั้งแต่มองเป็นอย่างดี

767
00:36:47,590 --> 00:36:49,931
รหัสที่เก็บออนไลน์
กระดานสนทนาเว็บไซต์งาน

768
00:36:49,931 --> 00:36:51,806
และเราพูดถึงนี้
จริงๆทั้งหมดเพราะ

769
00:36:51,806 --> 00:36:56,040
ของการเปิดเผยข้อมูลเต็มรูปแบบว่าถ้า
คนอื่นสามารถค้นหาได้ออนไลน์

770
00:36:56,040 --> 00:36:57,880
แน่นอนดังนั้นเราสามารถเรียนการสอน

771
00:36:57,880 --> 00:37:00,100
แต่จริงๆจิตวิญญาณ
ของหลักสูตรเดือดลง

772
00:37:00,100 --> 00:37:01,650
ข้อนี้ในหลักสูตร

773
00:37:01,650 --> 00:37:03,670
จริงๆมันเป็นเพียงแค่จะเหมาะสม

774
00:37:03,670 --> 00:37:06,680
>> และถ้าเรามีการทำอย่างละเอียดในที่
มีเพียงภาษามากขึ้นอีกนิด

775
00:37:06,680 --> 00:37:09,770
ตระหนักดีว่าสาระสำคัญของทั้งหมด
งานที่คุณส่งไปยังหลักสูตรนี้

776
00:37:09,770 --> 00:37:10,954
จะต้องเป็นของคุณเอง

777
00:37:10,954 --> 00:37:13,870
แต่ภายในนั้นมีแน่นอน
โอกาสและให้กำลังใจ

778
00:37:13,870 --> 00:37:17,300
และความคุ้มค่าในการสอนเปลี่ยนไป
others-- ตัวของเราเอง TFS, คาสิโน,

779
00:37:17,300 --> 00:37:20,760
ครูและคนอื่น ๆ ในชั้นเรียน
ที่ให้การสนับสนุนให้เพื่อนคนเดียว

780
00:37:20,760 --> 00:37:23,547
และเพื่อนร่วมห้องที่มีการศึกษา
บริการลูกค้าและการเขียนโปรแกรมก่อน

781
00:37:23,547 --> 00:37:25,130
และเพื่อให้มีการตั้งค่าเผื่อการว่า

782
00:37:25,130 --> 00:37:28,180
และกฎทั่วไปของหัวแม่มือ
เป็น this-- เมื่อขอความช่วยเหลือ

783
00:37:28,180 --> 00:37:31,470
คุณอาจแสดงรหัสของคุณกับคนอื่น ๆ
แต่คุณอาจไม่ดูพวกเขา

784
00:37:31,470 --> 00:37:34,880
ดังนั้นแม้ว่าคุณจะอยู่ที่เวลาทำการ
หรือในห้องโถง D, หรือที่อื่น

785
00:37:34,880 --> 00:37:37,450
การทำงานในชุดชิ้นบาง
ทำงานร่วมกับเพื่อนที่

786
00:37:37,450 --> 00:37:40,160
ดีทั้งหมดที่
ตอนท้ายของวันทำงานของคุณ

787
00:37:40,160 --> 00:37:43,034
ในท้ายที่สุดควรจะเป็นของแต่ละคน
ของคุณตามลำดับและไม่ได้

788
00:37:43,034 --> 00:37:45,700
เป็นความพยายามร่วมกัน
ยกเว้นโครงการสุดท้ายที่

789
00:37:45,700 --> 00:37:47,410
ได้รับอนุญาตและเป็นกำลังใจให้

790
00:37:47,410 --> 00:37:49,830
>> ตระหนักดีว่าถ้าคุณเป็น
ดิ้นรนกับบางสิ่งบางอย่าง

791
00:37:49,830 --> 00:37:52,520
และเพื่อนของคุณเพิ่งเกิดขึ้น
จะดีกว่าที่นี้แล้วคุณ,

792
00:37:52,520 --> 00:37:55,130
หรือดีกว่าปัญหามากกว่าที่คุณว่า
หรือน้อยไกลไปข้างหน้ากว่าคุณ

793
00:37:55,130 --> 00:37:57,330
ก็สมควรที่จะเปิดทั้งหมด
กับเพื่อนของคุณและพูดว่าเดี๋ยวก่อน

794
00:37:57,330 --> 00:38:00,480
ไม่ใจคุณกำลังมองหาที่รหัสของฉันที่นี่
ช่วยฉันมองเห็นสิ่งที่เป็นปัญหาของฉันเป็นอย่างไร

795
00:38:00,480 --> 00:38:03,760
และหวังว่าใน
ความสนใจของมูลค่าการสอน

796
00:38:03,760 --> 00:38:07,040
เพื่อนที่ไม่ได้เป็นเพียงแค่
กล่าวว่าโอ้ทำเช่นนี้ แต่

797
00:38:07,040 --> 00:38:09,917
สิ่งที่คุณจะหายไปในบรรทัด
6 หรือสิ่งที่ต้องการนั้น

798
00:38:09,917 --> 00:38:12,000
แต่การแก้ปัญหาไม่ได้
สำหรับเพื่อน ๆ ที่อยู่ติดกับคุณ

799
00:38:12,000 --> 00:38:15,617
ที่จะบอกว่าโอ้ดีนี่ให้ฉันดึง
นี้ขึ้นและแสดงวิธีการแก้ปัญหาของฉันกับคุณ

800
00:38:15,617 --> 00:38:16,450
เพื่อให้เป็นเส้น

801
00:38:16,450 --> 00:38:18,670
คุณสามารถแสดงรหัสของคุณ
คนอื่น ๆ แต่คุณอาจไม่ได้

802
00:38:18,670 --> 00:38:22,350
ดูพวกเขาอยู่ภายใต้การอื่น ๆ
ข้อ จำกัด ในหลักสูตรการเรียนการสอนของ

803
00:38:22,350 --> 00:38:24,760
>> ดังนั้นอย่าเก็บไว้ในใจนี้
ที่เรียกว่าข้อเสียใจ

804
00:38:24,760 --> 00:38:27,560
ในหลักสูตรการเรียนการสอนที่เป็นอย่างดี
ว่าถ้าคุณกระทำการบางอย่างที่

805
00:38:27,560 --> 00:38:30,476
ไม่สมเหตุสมผล แต่นำมาให้
ความสนใจของหัวหลักสูตรฯ

806
00:38:30,476 --> 00:38:34,240
ภายใน 72 ชั่วโมงการเรียนการสอน
อาจกำหนดบทลงโทษในท้องถิ่นที่

807
00:38:34,240 --> 00:38:37,380
อาจรวมถึงเป็นที่น่าพอใจหรือ
ความล้มเหลวในชั้นประถมศึกษาปีสำหรับการทำงานที่ส่ง

808
00:38:37,380 --> 00:38:41,410
แต่การเรียนการสอนจะไม่อ้าง
สำคัญสำหรับการดำเนินการทางวินัยต่อไป

809
00:38:41,410 --> 00:38:43,010
ยกเว้นในกรณีของการกระทำซ้ำแล้วซ้ำอีก

810
00:38:43,010 --> 00:38:46,632
ในคำอื่น ๆ ถ้าคุณทำทำให้บาง
โง่ดึกโดยเฉพาะอย่างยิ่งการตัดสินใจ

811
00:38:46,632 --> 00:38:49,340
เช้าวันถัดไปหรือสองวัน
ต่อมาคุณตื่นขึ้นและตระหนักถึง

812
00:38:49,340 --> 00:38:50,870
สิ่งที่ผมคิด?

813
00:38:50,870 --> 00:38:53,890
ที่คุณทำใน CS50 มีทางออก
สำหรับการแก้ไขปัญหาที่

814
00:38:53,890 --> 00:38:57,170
และเป็นเจ้าของขึ้นไปเพื่อให้เรา
จะได้พบคุณครึ่งหนึ่งและจัดการ

815
00:38:57,170 --> 00:39:01,500
กับมันในเรื่องที่เป็นทั้ง
การศึกษาและมีคุณค่าสำหรับคุณ

816
00:39:01,500 --> 00:39:04,200
แต่ยังคงลงโทษในทางใดทางหนึ่ง

817
00:39:04,200 --> 00:39:08,590
และตอนนี้จะใช้ขอบปิดนี้

818
00:39:08,590 --> 00:39:10,570
>> [เล่นวีดีโอ]

819
00:39:10,570 --> 00:39:13,540
>> [เสียงเพลง]

820
00:39:13,540 --> 00:39:58,090

821
00:39:58,090 --> 00:39:58,866
>> [จบ PLAYBACK]

822
00:39:58,866 --> 00:40:00,490
เดวิดเจลัน: สิทธิทั้งหมดที่เราจะกลับมา

823
00:40:00,490 --> 00:40:03,680
และตอนนี้เรามองไปที่หนึ่งใน
ครั้งแรกของโดเมนโลกแห่งความจริงของเรา

824
00:40:03,680 --> 00:40:08,720
ใน CS50 ศิลปะของการเข้ารหัสที่
ศิลปะของการส่งและรับ

825
00:40:08,720 --> 00:40:11,840
ข้อความลับ, การเข้ารหัส
ข้อความถ้าคุณจะ

826
00:40:11,840 --> 00:40:17,060
ที่สามารถถอดรหัสถ้าคุณมี
บางส่วนผสมที่สำคัญที่ผู้ส่งมี

827
00:40:17,060 --> 00:40:18,030
ได้เป็นอย่างดี

828
00:40:18,030 --> 00:40:22,120
ดังนั้นเพื่อกระตุ้นนี้เราจะพา
ดูที่สิ่งนี้ที่นี่

829
00:40:22,120 --> 00:40:26,750
ซึ่งเป็นตัวอย่างของหนึ่ง
แหวนถอดรหัสลับที่

830
00:40:26,750 --> 00:40:34,042
สามารถนำมาใช้ในการสั่งซื้อที่จะคิดออก
สิ่งที่ข้อความลับจริง

831
00:40:34,042 --> 00:40:35,750
ในความเป็นจริงกลับมาอยู่ใน
วันในระดับโรงเรียน

832
00:40:35,750 --> 00:40:38,787
ถ้าคุณเคยส่งข้อความลับไป
เพื่อนบางส่วนหรือปิ๊บางส่วนในชั้นเรียน

833
00:40:38,787 --> 00:40:40,620
คุณอาจจะคิดว่า
คุณเป็นคนฉลาด

834
00:40:40,620 --> 00:40:46,530
โดยชิ้นส่วนของการเปลี่ยนกระดาษ
เช่น A ไป B และ B ไป C, และ C กับ D,

835
00:40:46,530 --> 00:40:47,590
เป็นต้น

836
00:40:47,590 --> 00:40:50,300
แต่คุณเป็นจริงการเข้ารหัส
ข้อมูลของคุณแม้

837
00:40:50,300 --> 00:40:53,300
ถ้ามันเป็นที่น่ารำคาญเล็ก ๆ น้อย ๆ ไม่ได้
ที่ยากสำหรับครูที่จะตระหนักถึง

838
00:40:53,300 --> 00:40:55,675
ดีถ้าคุณเพียงแค่เปลี่ยน
B ไป A และ C กับ B,

839
00:40:55,675 --> 00:40:57,550
คุณคิดจริงออก
สิ่งที่ข้อความเป็น

840
00:40:57,550 --> 00:40:59,700
แต่คุณอยู่ใน ciphering ข้อมูล

841
00:40:59,700 --> 00:41:03,420
>> คุณเป็นเพียงแค่การทำมัน
ก็เหมือนฟี่ที่นี่

842
00:41:03,420 --> 00:41:07,934
ในภาพยนตร์ที่มีชื่อเสียงที่เล่น
nauseum โฆษณาสวยมากในแต่ละฤดูหนาว

843
00:41:07,934 --> 00:41:08,600
[เล่นวีดีโอ]

844
00:41:08,600 --> 00:41:11,180
-Be มันรู้ไปทุกที่
ราล์ฟปาร์กเกอร์เป็นขอ

845
00:41:11,180 --> 00:41:14,070
ได้รับการแต่งตั้งเป็นสมาชิกของเล็ก ๆ น้อย ๆ
เด็กกำพร้าแอนนี่วงกลมลับ

846
00:41:14,070 --> 00:41:17,700
และมีสิทธิที่จะได้รับเกียรตินิยมทั้งหมด
และผลประโยชน์ที่เกิดขึ้นดังกล่าว

847
00:41:17,700 --> 00:41:24,340
>> -Signed, กำพร้าแอนนี่
เคาน์เตอร์ลงนามปิแอร์อังเดรในหมึก

848
00:41:24,340 --> 00:41:27,160
เกียรติประวัติและผลประโยชน์
แล้วที่อายุสิบเก้า

849
00:41:27,160 --> 00:41:30,490

850
00:41:30,490 --> 00:41:31,825
>> [ตะโกน]

851
00:41:31,825 --> 00:41:33,750

852
00:41:33,750 --> 00:41:34,250
-Come บน

853
00:41:34,250 --> 00:41:35,210
ให้ของได้รับกับมัน

854
00:41:35,210 --> 00:41:39,530
ฉันไม่จำเป็นต้องทั้งหมดที่แจ๊ส
เกี่ยวกับการลักลอบและโจรสลัด

855
00:41:39,530 --> 00:41:41,660
>> คืนวันพรุ่งนี้ -Listen สำหรับ
สรุปการผจญภัย

856
00:41:41,660 --> 00:41:43,880
ของเรือโจรสลัดสีดำ

857
00:41:43,880 --> 00:41:46,650
ตอนนี้ก็ถึงเวลาสำหรับ
ข้อความลับของแอนนี่

858
00:41:46,650 --> 00:41:49,840
สำหรับสมาชิกของคุณวงกลมลับ

859
00:41:49,840 --> 00:41:53,570
โปรดจำไว้ว่าเด็กเฉพาะสมาชิกเท่านั้น
ของแอนนี่วงกลมลับ

860
00:41:53,570 --> 00:41:56,140
สามารถถอดรหัสข้อความลับของแอนนี่

861
00:41:56,140 --> 00:42:00,340
>> โปรดจำไว้ว่าแอนนี่ขึ้นอยู่กับคุณ

862
00:42:00,340 --> 00:42:02,880
ตั้งหมุดของคุณเพื่อ B2

863
00:42:02,880 --> 00:42:05,230
นี่คือข้อความ

864
00:42:05,230 --> 00:42:06,090
12 11--

865
00:42:06,090 --> 00:42:10,250
>> -I am ในการประชุมลับครั้งแรกของฉัน

866
00:42:10,250 --> 00:42:13,890
>> -14, 11, 18, 16

867
00:42:13,890 --> 00:42:15,780
>> -Pierre อยู่ในคืนนี้เสียงที่ดี

868
00:42:15,780 --> 00:42:19,000
ผมบอกได้เลยว่าคืนนี้
ข้อความเป็นสิ่งสำคัญจริงๆ

869
00:42:19,000 --> 00:42:22,694
>> -3, 25, ที่ข้อความ
จากแอนนี่ตัวเอง

870
00:42:22,694 --> 00:42:23,860
โปรดจำไว้ว่าอย่าบอกใคร

871
00:42:23,860 --> 00:42:28,760

872
00:42:28,760 --> 00:42:32,930
>> -90 วินาทีต่อมาผมอยู่ในเท่านั้น
ห้องพักในบ้านที่เป็นเด็กเก้า

873
00:42:32,930 --> 00:42:37,040
จะนั่งอยู่ในความเป็นส่วนตัวและถอดรหัส

874
00:42:37,040 --> 00:42:39,730
อ้า B!

875
00:42:39,730 --> 00:42:42,360
ผมไปต่อไปอี

876
00:42:42,360 --> 00:42:44,520
>> คำแรกคือเป็น

877
00:42:44,520 --> 00:42:49,032
S มันก็ง่ายขึ้นมาตอนนี้ U, 25--

878
00:42:49,032 --> 00:42:51,733
>> โอ้มาในฟี่ I gotta ไป!

879
00:42:51,733 --> 00:42:53,688
>> ผมจะไปมีสิทธิลง Ma!

880
00:42:53,688 --> 00:42:54,188
หวือ Gee!

881
00:42:54,188 --> 00:42:58,116

882
00:42:58,116 --> 00:43:04,060
>> -T, O, ให้แน่ใจว่า to-- ให้แน่ใจว่าได้อะไร?

883
00:43:04,060 --> 00:43:05,970
สิ่งที่เป็นเด็กกำพร้าเล็ก ๆ น้อย ๆ
แอนนี่พยายามที่จะพูด?

884
00:43:05,970 --> 00:43:07,264
ให้แน่ใจว่าได้อะไร?

885
00:43:07,264 --> 00:43:09,634
>> -Ralphie แอนดี้ได้มีการ
ไปคุณจะกรุณ​​าออกมา?

886
00:43:09,634 --> 00:43:10,480
>> สิทธิพักแม่!

887
00:43:10,480 --> 00:43:12,880
ฉันจะออกไปทางขวา!

888
00:43:12,880 --> 00:43:14,550
>> -I ได้รับใกล้ชิดในขณะนี้

889
00:43:14,550 --> 00:43:16,620
ความตึงเครียดที่น่ากลัว

890
00:43:16,620 --> 00:43:17,720
มันคืออะไร?

891
00:43:17,720 --> 00:43:20,170
ชะตากรรมของโลก
อาจแขวนอยู่ในสมดุล

892
00:43:20,170 --> 00:43:20,670
>> -Ralphie!

893
00:43:20,670 --> 00:43:23,170
แอนดี้ต้องไป!

894
00:43:23,170 --> 00:43:26,890
>> ผมจะไปมีสิทธิออกร้องไห้ออกมาดัง ๆ !

895
00:43:26,890 --> 00:43:32,680
>> -Almost มีมือของฉันบินใจของฉัน
เป็นกับดักเหล็กทุกขุมขนสั่นสะเทือน

896
00:43:32,680 --> 00:43:37,198
มันก็เกือบจะชัดเจนใช่ใช่ใช่

897
00:43:37,198 --> 00:43:43,091
>> -Be แน่ใจว่าได้ดื่มโอวัลติคุณ

898
00:43:43,091 --> 00:43:43,590
โอวัลติ?

899
00:43:43,590 --> 00:43:48,160

900
00:43:48,160 --> 00:43:49,430
พาณิชย์ crummy?

901
00:43:49,430 --> 00:43:53,046

902
00:43:53,046 --> 00:43:54,227
ไอ้บ้า

903
00:43:54,227 --> 00:43:54,810
[จบ PLAYBACK]

904
00:43:54,810 --> 00:43:57,390
เดวิดเจลัน: ตกลงดังนั้น
ว่าเป็นวิธีที่มีความยาวมาก

905
00:43:57,390 --> 00:44:00,660
ของการแนะนำวิทยาการ
และโอวัลติ

906
00:44:00,660 --> 00:44:04,470
ในความเป็นจริงจากการโฆษณาเก่า
นี่คือเหตุผลที่โอวัลติดีเพื่ออะไร?

907
00:44:04,470 --> 00:44:09,470
มันเป็นสกัดเข้มข้นของสุก
ข้าวบาร์เลย์มอลต์นมวัวครีมบริสุทธิ์ของ

908
00:44:09,470 --> 00:44:14,360
และเตรียมเป็นพิเศษโกโก้เข้าด้วยกัน
กับ phosphatides ธรรมชาติและวิตามิน

909
00:44:14,360 --> 00:44:18,240
มันเป็นเสริมอีกด้วย
วิตามินเพิ่มเติม B และ D ยำ

910
00:44:18,240 --> 00:44:21,600
และคุณยังจะได้รับมันเห็นได้ชัดว่า
ใน Amazon เหมือนเราได้ที่นี่

911
00:44:21,600 --> 00:44:24,810
>> แต่แรงจูงใจของที่นี่คือการ
แนะนำการเข้ารหัสเฉพาะ

912
00:44:24,810 --> 00:44:28,340
ประเภทของการเข้ารหัสที่รู้จักกัน
เป็นคีย์การเข้ารหัสลับ

913
00:44:28,340 --> 00:44:34,284
และเป็นชื่อที่แนะนำทั้งหมด
การรักษาความปลอดภัยของระบบการเข้ารหัสลับที่สำคัญเป็นความลับ

914
00:44:34,284 --> 00:44:36,200
ถ้าคุณจะวิธีการ
เพียง scrambling

915
00:44:36,200 --> 00:44:40,960
ข้อมูลระหว่างคนสองคนก็คือว่า
เฉพาะผู้ส่งและผู้รับเท่านั้น

916
00:44:40,960 --> 00:44:46,980
รู้ key-- ลับค่าบางอย่างบาง
วลีลับบางจำนวนลับว่า

917
00:44:46,980 --> 00:44:50,660
ช่วยให้พวกเขาทั้งเข้ารหัส
และถอดรหัสข้อมูล

918
00:44:50,660 --> 00:44:53,470
และการเข้ารหัสจริงๆ
เป็นเพียงแค่นี้จากสัปดาห์ 0

919
00:44:53,470 --> 00:44:56,715
>> มันเป็นปัญหาที่มีปัจจัยการผลิต,
เช่นข้อความที่เกิดขึ้นจริงในภาษาอังกฤษ

920
00:44:56,715 --> 00:44:59,340
หรืออะไรก็ตามที่คุณภาษา
ต้องการที่จะส่งไปยังคนในชั้นเรียน

921
00:44:59,340 --> 00:45:00,580
หรือผ่านทางอินเทอร์เน็ต

922
00:45:00,580 --> 00:45:03,840
มีการส่งออกบางอย่างที่เป็นไปได้คือ
จะเป็นข้อความที่มีสัญญาณรบกวนที่คุณ

923
00:45:03,840 --> 00:45:05,250
ต้องการผู้รับที่จะได้รับ

924
00:45:05,250 --> 00:45:07,405
และแม้กระทั่งถ้ามีคนใน
ตรงกลางจะได้รับมันมากเกินไป

925
00:45:07,405 --> 00:45:09,780
คุณไม่ต้องการให้พวกเขา
จำเป็นต้องสามารถถอดรหัสมัน

926
00:45:09,780 --> 00:45:12,840
เพราะภายในนี้
กล่องดำหรืออัลกอริทึม

927
00:45:12,840 --> 00:45:17,650
เป็นกลไกบางขั้นตอนโดยขั้นตอนบางอย่าง
คำแนะนำสำหรับการป้อนข้อมูลที่

928
00:45:17,650 --> 00:45:20,710
และการแปลงลงใน
การส่งออกในหวังว่าวิธีการที่ปลอดภัย

929
00:45:20,710 --> 00:45:23,640
>> และในความเป็นจริงมีบางส่วน
คำศัพท์ในโลกนี้ดังต่อไปนี้

930
00:45:23,640 --> 00:45:26,100
ข้อความล้วนเป็นคำว่า
นักวิทยาศาสตร์คอมพิวเตอร์จะ

931
00:45:26,100 --> 00:45:28,449
ใช้เพื่ออธิบายการป้อนข้อมูล
ข้อความเช่นภาษาอังกฤษ

932
00:45:28,449 --> 00:45:31,240
หรือสิ่งที่ภาษาที่คุณจริง
ต้องการที่จะส่งไปบางส่วนอื่น ๆ ของมนุษย์

933
00:45:31,240 --> 00:45:35,450
แล้ว ciphertext คือการแย่งชิง
การเข้ารหัสหรือการเข้ารหัส

934
00:45:35,450 --> 00:45:36,520
รุ่นดังกล่าว

935
00:45:36,520 --> 00:45:38,750
>> แต่มีส่วนผสมอื่น ๆ ที่นี่

936
00:45:38,750 --> 00:45:43,200
มีอยู่คนหนึ่งป้อนข้อมูลอื่น ๆ ที่จะเป็น
คีย์การเข้ารหัสลับ

937
00:45:43,200 --> 00:45:45,200
และนั่นคือกุญแจสำคัญในตัวของมันเอง
ซึ่งเป็นปกติ

938
00:45:45,200 --> 00:45:48,930
ในขณะที่เราจะเห็นตัวเลขหรือ
ตัวอักษรหรือคำใด ๆ ก็ตาม

939
00:45:48,930 --> 00:45:51,980
อัลกอริทึมจะมีการคาดการณ์ว่าจริง

940
00:45:51,980 --> 00:45:53,870
>> และวิธีการที่คุณจะถอดรหัสข้อมูล?

941
00:45:53,870 --> 00:45:55,110
คุณจะทำอย่างไรถอดรหัสมันได้หรือไม่

942
00:45:55,110 --> 00:45:57,950
ดีที่คุณเพิ่งกลับ
เอาท์พุทและปัจจัยการผลิต

943
00:45:57,950 --> 00:46:00,900
>> ในคำอื่น ๆ เมื่อมีคน
ได้รับข้อความที่เข้ารหัสของคุณ

944
00:46:00,900 --> 00:46:03,740
เขาหรือเธอก็มี
ที่จะรู้ว่าคีย์เดียวกันว่า

945
00:46:03,740 --> 00:46:05,700
พวกเขาได้รับข้อความที่เข้ารหัส

946
00:46:05,700 --> 00:46:09,530
และด้วยการเสียบทั้งสอง
ปัจจัยการผลิตเข้ามาในระบบการเข้ารหัสลับที่

947
00:46:09,530 --> 00:46:14,260
อัลกอริทึม, ก​​ล่องดำนี้จาก
ควรมา plaintext เดิม

948
00:46:14,260 --> 00:46:17,830
และเพื่อให้เป็นระดับที่สูงมาก
มุมมองของสิ่งที่เข้ารหัสเป็นจริง

949
00:46:17,830 --> 00:46:18,590
ทั้งหมดเกี่ยวกับ.

950
00:46:18,590 --> 00:46:20,030
>> จึงขอได้มี

951
00:46:20,030 --> 00:46:22,700
ตอนนี้ขอดูใต้
เครื่องดูดควันของบางสิ่งบางอย่าง

952
00:46:22,700 --> 00:46:26,000
เราได้รับการให้ได้รับสำหรับ
สัปดาห์ที่ผ่านมาและสำหรับการประชุมครั้งนี้

953
00:46:26,000 --> 00:46:27,629
here-- สตริง

954
00:46:27,629 --> 00:46:30,295
สตริงในตอนท้ายของวัน
เป็นเพียงลำดับของตัวอักษร

955
00:46:30,295 --> 00:46:33,610
>> มันอาจจะเป็นโลกสวัสดีหรือ
สวัสดี Zamyla หรืออะไรก็ตาม

956
00:46:33,610 --> 00:46:37,050
แต่สิ่งที่หมายความว่าจะ
เป็นลำดับของตัวอักษรหรือไม่?

957
00:46:37,050 --> 00:46:41,520
ในความเป็นจริงจะช่วยให้ห้องสมุด CS50
เราชนิดข้อมูลที่เรียกว่าสตริง

958
00:46:41,520 --> 00:46:45,140
>> แต่มีจริงไม่มี
สิ่งดังกล่าวเป็นสตริงในซี

959
00:46:45,140 --> 00:46:49,450
จริงๆมันเป็นเพียงลำดับของ
ตัวละครตัวละครตัวละคร

960
00:46:49,450 --> 00:46:52,180
ตัวอักษรกลับไปกลับไป
กลับไปด้านหลังจะกลับเข้าไปข้างใน

961
00:46:52,180 --> 00:46:54,650
ของหน่วยความจำของคอมพิวเตอร์ของคุณหรือแรม

962
00:46:54,650 --> 00:46:58,940
และเราจะมองลึกลงไปว่าใน
ในอนาคตเมื่อเรามองไปที่หน่วยความจำตัวเอง

963
00:46:58,940 --> 00:47:02,030
และการใช้ประโยชน์และ
ภัยคุกคามที่มีส่วนร่วม

964
00:47:02,030 --> 00:47:04,100
>> แต่ขอพิจารณาสตริง Zamyla

965
00:47:04,100 --> 00:47:07,480
ดังนั้นเพียงแค่ชื่อของ
มนุษย์นี่ Zamyla,

966
00:47:07,480 --> 00:47:12,030
ที่เป็นลำดับของ
ตัวอักษร Z-A-M-Y-L-A

967
00:47:12,030 --> 00:47:16,020
และตอนนี้สมมติว่าชื่อของ Zamyla
จะถูกเก็บไว้ในคอมพิวเตอร์

968
00:47:16,020 --> 00:47:16,880
โครงการ

969
00:47:16,880 --> 00:47:20,830
>> ดีก็หมายถึงเหตุผลที่เราควรจะ
สามารถที่จะมองไปที่ตัวอักษรเหล่านั้น

970
00:47:20,830 --> 00:47:21,590
เป็นรายบุคคล

971
00:47:21,590 --> 00:47:24,710
ดังนั้นฉันแค่จะไปวาดเล็ก ๆ น้อย ๆ
กล่องรอบ Zamyla ชื่อของที่นี่

972
00:47:24,710 --> 00:47:31,580
และมันก็เป็นกรณีใน C ที่ว่าเมื่อคุณ
มีสตริงเช่น Zamyla-- และอาจ

973
00:47:31,580 --> 00:47:34,940
สตริงที่ได้กลับมาจาก
ฟังก์ชั่นเช่นสตริงได้รับ

974
00:47:34,940 --> 00:47:38,540
คุณจริงสามารถจัดการ
ตัวละครมันด้วยตัวอักษร

975
00:47:38,540 --> 00:47:42,070
>> ตอนนี้เป็นชิดสำหรับ
การสนทนาที่มือเพราะ

976
00:47:42,070 --> 00:47:46,420
ในการเข้ารหัสถ้าคุณต้องการที่จะเปลี่ยน
A ไป B และ B ไป C, และ C กับ D,

977
00:47:46,420 --> 00:47:49,650
และอื่น ๆ ที่คุณจะต้องสามารถ
จะมองไปที่ตัวละครแต่ละคน

978
00:47:49,650 --> 00:47:50,190
ในสตริง

979
00:47:50,190 --> 00:47:52,695
คุณจะต้องสามารถที่จะเปลี่ยน
Z เพื่ออย่างอื่นต่อ A

980
00:47:52,695 --> 00:47:55,280
อย่างอื่นที่ M เพื่อ
อย่างอื่นและอื่น ๆ

981
00:47:55,280 --> 00:47:58,000
และเพื่อให้เราต้องมีวิธีการ
โปรแกรมเพื่อ

982
00:47:58,000 --> 00:48:03,020
ที่จะพูดใน C เพื่อให้สามารถที่จะเปลี่ยน
และมองไปที่ตัวอักษรของแต่ละบุคคล

983
00:48:03,020 --> 00:48:05,690
และเราสามารถทำเช่นนี้ดังต่อไปนี้

984
00:48:05,690 --> 00:48:08,340
>> ให้ฉันไปมุ่งหน้ากลับใน CS50 IDE

985
00:48:08,340 --> 00:48:11,130
และแจ้งให้เราไปข้างหน้า
และสร้างไฟล์ใหม่

986
00:48:11,130 --> 00:48:16,134
ว่าฉันจะเรียก string0 เวลานี้
เป็นตัวอย่างเช่นครั้งแรกของเราจุด C

987
00:48:16,134 --> 00:48:18,300
และฉันจะไปข้างหน้า
และชักขึ้นดังต่อไปนี้

988
00:48:18,300 --> 00:48:22,870
>> ดังนั้นรวม CS50.h และ
แล้วรวม io.h มาตรฐาน

989
00:48:22,870 --> 00:48:25,990
ซึ่งฉันเกือบเสมอไป
จะใช้ในโปรแกรมของฉันอย่างน้อย

990
00:48:25,990 --> 00:48:26,780
ในขั้นต้น

991
00:48:26,780 --> 00:48:32,180
int เป็นโมฆะหลักและจากนั้นในที่นี่ผม
จะทำสายได้รับได้รับสตริง

992
00:48:32,180 --> 00:48:35,260
แล้วฉันจะไป
ไปข้างหน้าและทำเช่นนี้

993
00:48:35,260 --> 00:48:37,460
ฉันต้องการที่จะไปข้างหน้า
และในขณะที่การตรวจสอบสติ

994
00:48:37,460 --> 00:48:43,607
เพียงแค่พูดว่าสวัสดีร้อยละ S,
ลำไส้ใหญ่กึ่งทำให้สตริง 0

995
00:48:43,607 --> 00:48:44,690
อ๊ะทำอะไรที่นี่?

996
00:48:44,690 --> 00:48:45,930
โอ้ผมไม่ได้เสียบ

997
00:48:45,930 --> 00:48:48,120
ดังนั้นบทเรียนที่ได้เรียนรู้ว่า
ไม่ได้เจตนา

998
00:48:48,120 --> 00:48:52,480
>> ข้อผิดพลาดดังนั้นร้อยละ
แปลงกว่าข้อโต้แย้งข้อมูล

999
00:48:52,480 --> 00:48:54,940
และนี่คือที่ใน
สาย 7-- ตกลงดังนั้นฉันมี

1000
00:48:54,940 --> 00:48:56,690
อ้างนำมาอ้างว่าเป็น
สตริงของฉันไป printf

1001
00:48:56,690 --> 00:48:58,151
ฉันมีเครื่องหมายเปอร์เซ็นต์

1002
00:48:58,151 --> 00:48:59,650
แต่ฉันหายไปอาร์กิวเมนต์ที่สอง

1003
00:48:59,650 --> 00:49:03,190
>> ฉันหายไป s จุลภาคซึ่ง
ฉันไม่ได้ในตัวอย่างก่อนหน้านี้

1004
00:49:03,190 --> 00:49:06,650
ดังนั้นเป็นโอกาสที่ดีในการแก้ไขปัญหา
อีกหนึ่งความผิดพลาดโดยไม่ได้ตั้งใจ

1005
00:49:06,650 --> 00:49:09,950
และตอนนี้ให้ฉันทำงาน
string0 พิมพ์ใน Zamyla

1006
00:49:09,950 --> 00:49:10,970
ตกลงสวัสดี Zamyla

1007
00:49:10,970 --> 00:49:14,144
>> ดังนั้นเราจึงได้เรียกใช้ชนิดของโปรแกรมนี้
ครั้งที่แตกต่างกันไม่กี่ตอน

1008
00:49:14,144 --> 00:49:16,310
แต่ขอทำบางสิ่งบางอย่าง
เล็ก ๆ น้อย ๆ ที่แตกต่างกันในครั้งนี้

1009
00:49:16,310 --> 00:49:19,450
แทนที่จะเป็นเพียงการพิมพ์ Zamyla ของ
ชื่อทั้งหมดออกมาพร้อมกับพริทฟ์

1010
00:49:19,450 --> 00:49:21,350
ขอทำทีละอักขระ

1011
00:49:21,350 --> 00:49:22,700
>> ฉันจะใช้สำหรับวง

1012
00:49:22,700 --> 00:49:26,160
และฉันจะให้ตัวเอง
ตัวแปรนับเรียกฉัน

1013
00:49:26,160 --> 00:49:33,530
และฉันจะเก็บ iterating ดังนั้น
ตราบเท่าที่ฉันมีค่าน้อยกว่าความยาวของนั้น

1014
00:49:33,530 --> 00:49:35,930
>> มันจะเปิดออกเราไม่ได้
ทำครั้งสุดท้ายนี้

1015
00:49:35,930 --> 00:49:39,100
ที่ C มาพร้อมกับ
ฟังก์ชั่นที่เรียกว่าสเตอร์ลิง

1016
00:49:39,100 --> 00:49:42,690
ย้อนกลับไปในวันและทั่วไป
ยังคงเมื่อใช้ฟังก์ชั่น

1017
00:49:42,690 --> 00:49:45,405
มนุษย์มักจะเลือกมาก
ชื่อรวบรัดชนิดของเสียงที่

1018
00:49:45,405 --> 00:49:48,280
เหมือนสิ่งที่คุณต้องการแม้ว่าจะเป็น
หายไปไม่กี่สระหรือตัวอักษร

1019
00:49:48,280 --> 00:49:50,660
ดังนั้นสเตอร์ลิงเป็น
ชื่อของฟังก์ชั่นที่

1020
00:49:50,660 --> 00:49:53,880
ใช้เวลาโต้เถียงระหว่าง
วงเล็บที่ควรจะเป็นสตริง

1021
00:49:53,880 --> 00:49:56,910
และมันก็ส่งกลับจำนวนเต็ม
ความยาวของสตริงว่า

1022
00:49:56,910 --> 00:50:00,580
>> ดังนั้นนี้สำหรับวงในบรรทัดที่ 7 เป็นไป
ที่จะเริ่มต้นนับที่ฉันมีค่าเท่ากับ 0

1023
00:50:00,580 --> 00:50:02,530
มันจะเพิ่มขึ้น
ผมในแต่ละซ้ำ

1024
00:50:02,530 --> 00:50:04,350
โดยที่ 1 ในขณะที่เราได้รับการทำไม่กี่ครั้ง

1025
00:50:04,350 --> 00:50:06,780
แต่มันเป็นไปได้เพียง แต่ทำ
ขึ้นนี้จนกว่าจุด

1026
00:50:06,780 --> 00:50:09,660
เมื่อฉันเป็นความยาว
ของสตริงตัวเอง

1027
00:50:09,660 --> 00:50:14,520
>> ดังนั้นนี่คือวิธีการในที่สุด
iterating มากกว่าตัวละคร

1028
00:50:14,520 --> 00:50:17,430
ในสตริงที่เป็นอยู่ต่อไปนี้

1029
00:50:17,430 --> 00:50:20,670
ฉันจะพิมพ์ออกมาไม่ได้เป็น
สตริงทั้ง แต่ร้อยละ C,

1030
00:50:20,670 --> 00:50:22,860
ตัวเดียว
ตามมาด้วยการขึ้นบรรทัดใหม่

1031
00:50:22,860 --> 00:50:24,880
แล้วฉันจะไป
ไปข้างหน้าและฉันต้องการ

1032
00:50:24,880 --> 00:50:29,080
จะบอกว่าผมต้องการพิมพ์
ตัวละครที่ i ของ s

1033
00:50:29,080 --> 00:50:33,450
>> ดังนั้นถ้าฉันเป็นตัวแปรที่บ่งชี้
ดัชนีของสตริงที่

1034
00:50:33,450 --> 00:50:37,230
คุณกำลังอยู่ในนั้นผมจะต้องสามารถที่จะ
พูดให้ฉันตัวละครที่ i ของ s

1035
00:50:37,230 --> 00:50:40,390
และ C มีวิธีการทำ
นี้กับวงเล็บ

1036
00:50:40,390 --> 00:50:43,679
คุณเพียงแค่พูดชื่อของ
สตริงซึ่งในกรณีนี้คือ s

1037
00:50:43,679 --> 00:50:46,970
แล้วคุณใช้วงเล็บซึ่งเป็น
มักจะอยู่เหนือหรือใส่กลับของคุณ

1038
00:50:46,970 --> 00:50:48,110
บนแป้นพิมพ์

1039
00:50:48,110 --> 00:50:52,410
แล้วคุณใส่ดัชนีของ
ตัวอักษรที่คุณต้องการพิมพ์

1040
00:50:52,410 --> 00:50:55,960
ดังนั้นดัชนีจะไปได้
number-- 0 หรือ 1 หรือ 2 หรือ 3 หรือจุด

1041
00:50:55,960 --> 00:50:57,590
จุดจุดบางหมายเลขอื่น

1042
00:50:57,590 --> 00:51:00,920
>> และเรามั่นใจว่ามันจะ
เป็นจำนวนที่เหมาะสมเพราะฉัน

1043
00:51:00,920 --> 00:51:02,360
เริ่มนับที่ 0

1044
00:51:02,360 --> 00:51:07,020
และโดยค่าเริ่มต้นตัวอักษรตัวแรก
ในสตริงเป็น 0 โดยการประชุม

1045
00:51:07,020 --> 00:51:09,230
และตัวอักษรที่สองคือวงเล็บ 1

1046
00:51:09,230 --> 00:51:11,120
และตัวละครที่สามคือขายึด 2

1047
00:51:11,120 --> 00:51:13,630
และคุณไม่ต้องการที่จะไปมากเกินไป
ห่างไกล แต่เราจะไม่เพราะเรา

1048
00:51:13,630 --> 00:51:17,780
จะเพิ่มขึ้นเพียงฉันจนกว่าจะ
เท่ากับความยาวของสตริง

1049
00:51:17,780 --> 00:51:20,210
และที่จุด
สำหรับวงนี้จะหยุด

1050
00:51:20,210 --> 00:51:25,550
>> เพื่อให้ฉันไปข้างหน้าและบันทึกนี้
โปรแกรมและเรียกสตริง 0

1051
00:51:25,550 --> 00:51:28,400
แต่ผมเมาขึ้น

1052
00:51:28,400 --> 00:51:35,390
โดยปริยายประกาศฟังก์ชั่นห้องสมุด
Stirling มีประเภทดังกล่าวและ such-- ตอนนี้

1053
00:51:35,390 --> 00:51:36,430
นี้เสียงที่คุ้นเคย

1054
00:51:36,430 --> 00:51:37,440
แต่ก็ไม่ได้ printf

1055
00:51:37,440 --> 00:51:38,540
และมันก็ไม่ได้รับสตริง

1056
00:51:38,540 --> 00:51:40,480
>> ผมไม่ได้กรูขึ้นใน
เช่นเดียวกับครั้งนี้

1057
00:51:40,480 --> 00:51:45,100
แต่สังเกตเห็นลงที่นี่น้อยลง
เพิ่มเติม ได้แก่ สตริงส่วนหัว

1058
00:51:45,100 --> 00:51:47,210
อย่างชัดเจนให้
ประกาศสำหรับสเตอร์ลิง

1059
00:51:47,210 --> 00:51:48,820
ดังนั้นมีจริงในการมีเงื่อนงำ

1060
00:51:48,820 --> 00:51:51,670
>> และแน่นอนมันจะเปิดออก
มีไฟล์ส่วนหัวอีก

1061
00:51:51,670 --> 00:51:53,970
ที่เราไม่ได้ใช้
ในชั้นเรียน แต่มันเป็น

1062
00:51:53,970 --> 00:51:56,480
ในหมู่ผู้ใช้ได้
ให้คุณเรียกว่าสตริง

1063
00:51:56,480 --> 00:52:00,930
และในการที่ไฟล์สตริง
สเตอร์ลิงจะประกาศ

1064
00:52:00,930 --> 00:52:05,220
เพื่อให้ฉันไปข้างหน้าและ
บันทึกนี้ให้สตริง

1065
00:52:05,220 --> 00:52:08,040
0-- ดีไม่มีข้อผิดพลาดในครั้งนี้

1066
00:52:08,040 --> 00:52:12,290
>> ./string0 Zamyla และ
ฉันจะกด Enter,

1067
00:52:12,290 --> 00:52:16,710
จุดที่เป็นไป GetString
เพื่อกลับสตริงใส่ไว้ใน s

1068
00:52:16,710 --> 00:52:21,890
แล้วที่สำหรับวงเป็นไปย้ำ
มากกว่าตัวอักษร S หนึ่งที่เวลา

1069
00:52:21,890 --> 00:52:28,420
และพิมพ์ต่อหนึ่งบรรทัดเพราะ
ฉันมีที่ทับขวา n ที่สิ้นสุด

1070
00:52:28,420 --> 00:52:34,530
ดังนั้นฉันสามารถละเว้นทับขวาว่า
n และจากนั้นเพียงแค่พิมพ์ Zamyla ทั้งหมด

1071
00:52:34,530 --> 00:52:37,460
ในบรรทัดเดียวกัน
ได้อย่างมีประสิทธิภาพ reimplementing

1072
00:52:37,460 --> 00:52:38,999
printf ซึ่งไม่ได้ทั้งหมดที่มีประโยชน์ที่

1073
00:52:38,999 --> 00:52:40,540
แต่ในกรณีนี้ผมไม่ได้ทำอย่างนั้น

1074
00:52:40,540 --> 00:52:43,610
ผมเคยพิมพ์จริงหนึ่ง
ตัวอักษรในเวลาหนึ่งต่อบรรทัด

1075
00:52:43,610 --> 00:52:45,400
เพื่อให้เราได้จริงเห็นผล

1076
00:52:45,400 --> 00:52:46,900
>> แต่ฉันควรทราบสิ่งหนึ่งที่นี่

1077
00:52:46,900 --> 00:52:48,930
และเราจะกลับมา
ในสัปดาห์อนาคต

1078
00:52:48,930 --> 00:52:52,650
แต่กลับกลายเป็นว่านี้
รหัสอาจเป็นรถ

1079
00:52:52,650 --> 00:52:56,560
>> แต่กลับกลายเป็นว่าสตริง
และบางฟังก์ชั่นอื่น ๆ ในชีวิต

1080
00:52:56,560 --> 00:53:00,280
ไม่จำเป็นต้องเสมอ
กลับสิ่งที่คุณคาดหวัง

1081
00:53:00,280 --> 00:53:03,010
เรารู้จากชั้นเรียนสุดท้าย
ในเวลานี้ที่จะได้รับ

1082
00:53:03,010 --> 00:53:04,960
สตริงควรจะกลับสตริง

1083
00:53:04,960 --> 00:53:09,900
แต่ถ้าผู้ใช้ชนิดดังกล่าวออก
คำยาวหรือวรรคหรือเรียงความ

1084
00:53:09,900 --> 00:53:13,010
ว่ามีเพียงไม่เพียงพอ
หน่วยความจำในเครื่องคอมพิวเตอร์เพื่อให้พอดีกับมัน

1085
00:53:13,010 --> 00:53:15,410
>> เช่นเดียวกับสิ่งที่ถ้าบางสิ่งบางอย่างไป
ที่ไม่ถูกต้องอยู่ภายใต้ฝากระโปรง?

1086
00:53:15,410 --> 00:53:18,400
มันอาจจะไม่เกิดขึ้นบ่อยครั้ง
แต่มันอาจจะเกิดขึ้นเพียงครั้งเดียว

1087
00:53:18,400 --> 00:53:21,520
ในขณะที่ไม่บ่อยมาก

1088
00:53:21,520 --> 00:53:25,460
และดังนั้นจึงเปิดออกสตริงได้รับที่
และฟังก์ชั่นเหมือนมันไม่จำเป็นต้อง

1089
00:53:25,460 --> 00:53:26,380
เสมอกลับสตริง

1090
00:53:26,380 --> 00:53:30,680
พวกเขาอาจจะกลับค่าความผิดพลาดบางอย่าง
บางค่าแมวมองเพื่อที่จะพูด

1091
00:53:30,680 --> 00:53:32,612
ที่บ่งชี้ว่า
บางสิ่งบางอย่างที่ได้ไปผิด

1092
00:53:32,612 --> 00:53:35,320
และคุณจะได้รู้ว่าจากนี้
มีการเรียนรู้ในชั้นเรียนตอนนี้

1093
00:53:35,320 --> 00:53:37,700
หรือมีการอ่านเอกสารเพิ่มเติมบางส่วน

1094
00:53:37,700 --> 00:53:43,120
แต่กลับกลายเป็นว่าสตริง
สามารถกลับไปเรียกค่า null

1095
00:53:43,120 --> 00:53:46,220
Null เป็นค่าพิเศษที่เราจะ
กลับไปมาในสัปดาห์อนาคต

1096
00:53:46,220 --> 00:53:50,420
แต่ตอนนี้เพิ่งรู้ว่าถ้าผมต้องการ
จะเป็นที่เหมาะสมจริงๆในการก้าวไปข้างหน้า

1097
00:53:50,420 --> 00:53:52,650
ใช้สตริงผม
จะไม่เพียง แต่เรียกว่า

1098
00:53:52,650 --> 00:53:56,870
และสุ่มสี่สุ่มห้าใช้ค่าตอบแทนสูง
ไว้วางใจว่ามันเป็นสตริง

1099
00:53:56,870 --> 00:53:59,420
>> ครั้งแรกที่ผมควรจะพูดว่า
เดี๋ยวก่อนรอสักครู่เท่านั้น

1100
00:53:59,420 --> 00:54:03,380
ดำเนินการต่อไปถ้า s ไม่เท่ากับ
null, null ที่อีกครั้ง

1101
00:54:03,380 --> 00:54:04,660
เป็นเพียงบางค่าพิเศษ

1102
00:54:04,660 --> 00:54:07,770
และมันก็เป็นเพียงค่าพิเศษคุณ
จำเป็นต้องกังวลเกี่ยวกับสตริง

1103
00:54:07,770 --> 00:54:10,900
รับสตริงอย่างใดอย่างหนึ่งไป
ที่จะกลับมาเป็นสตริงหรือ null

1104
00:54:10,900 --> 00:54:17,219
>> และเครื่องหมายอัศเจรีย์นี้เท่ากับ
คุณอาจรู้จากชั้นเรียนคณิตศาสตร์อาจจะ

1105
00:54:17,219 --> 00:54:20,510
ที่คุณอาจวาดด้วยเครื่องหมายเท่ากับ
เส้นผ่านมันจะบ่งบอกถึงไม่เท่ากัน

1106
00:54:20,510 --> 00:54:23,135
นั่นคือไม่ได้โดยทั่วไปตัวละคร
คุณสามารถพิมพ์บนแป้นพิมพ์

1107
00:54:23,135 --> 00:54:26,480
และอื่น ๆ มากที่สุดในการเขียนโปรแกรมภาษา
เมื่อคุณต้องการที่จะบอกว่าไม่เท่ากัน

1108
00:54:26,480 --> 00:54:29,160
คุณใช้เครื่องหมายอัศเจรีย์
หรือที่เรียกว่าปัง

1109
00:54:29,160 --> 00:54:33,180
ดังนั้นคุณจะพูดว่าปังเท่ากับซึ​​่ง
หมายความว่าไม่เท่ากับเหตุผล

1110
00:54:33,180 --> 00:54:38,060
มันเหมือนกับมีไม่มากขึ้น
กว่าหรือเท่ากับหรือน้อยกว่า

1111
00:54:38,060 --> 00:54:41,270
หรือเท่ากับบนแป้นพิมพ์
ที่ไม่ได้ทั้งหมดในหนึ่งสัญลักษณ์

1112
00:54:41,270 --> 00:54:44,020
เพื่อที่ว่าทำไมในตัวอย่างที่ผ่านมา
คุณไม่วงเล็บเปิดแล้ว

1113
00:54:44,020 --> 00:54:48,670
เครื่องหมายเท่ากับเพื่อที่จะทำ
มากกว่าหรือพูดน้อยกว่า

1114
00:54:48,670 --> 00:54:49,910
>> ดังนั้นสิ่งที่ Takeaway ที่นี่?

1115
00:54:49,910 --> 00:54:53,880
นี้เป็นเพียงวิธีการที่ตอนนี้
แนะนำไวยากรณ์นี้คุณลักษณะนี้

1116
00:54:53,880 --> 00:54:57,390
iterating มากกว่าบุคคล
ตัวอักษรในสตริง

1117
00:54:57,390 --> 00:55:00,260
และเช่นเดียวกับตารางเหล่านั้น
วงเล็บช่วยให้คุณสามารถที่จะได้รับพวกเขา

1118
00:55:00,260 --> 00:55:03,790
พิจารณาวงเล็บเหล่านั้นเป็น
ชนิดของเค้านี้พื้นฐาน

1119
00:55:03,790 --> 00:55:06,040
ออกแบบโดยทุก
ตัวละครภายในของสตริง

1120
00:55:06,040 --> 00:55:10,180
ถูกบรรจุอยู่ในกล่องชนิดของในที่ไหนสักแห่งที่อยู่ภายใต้
เครื่องดูดควันในหน่วยความจำของคอมพิวเตอร์ของคุณ

1121
00:55:10,180 --> 00:55:12,340
>> แต่ขอให้แตกต่างจากนี้

1122
00:55:12,340 --> 00:55:14,880
แต่กลับกลายเป็นว่านี้
โปรแกรมที่ถูกต้อง

1123
00:55:14,880 --> 00:55:18,810
ดังนั้นต่อแกน CS50 สำหรับการประเมิน
รหัสนี้ถูกต้องในขณะนี้

1124
00:55:18,810 --> 00:55:22,959
โดยเฉพาะตอนที่ผมตรวจสอบ
null โปรแกรมนี้ไม่ควรผิดพลาด

1125
00:55:22,959 --> 00:55:24,500
และฉันก็รู้ว่าจากประสบการณ์

1126
00:55:24,500 --> 00:55:28,040
แต่มีอะไรอย่างอื่นที่
เราจริงๆสามารถไปอย่างผิดปกติท​​ี่นี่

1127
00:55:28,040 --> 00:55:31,860
แต่มันไม่ได้เป็นอย่างการออกแบบที่ดี
เพราะปล่อยให้กลับไปสู่​​พื้นฐาน

1128
00:55:31,860 --> 00:55:34,450
>> แรก principles--
สิ่งที่ไม่ห่วงทำอย่างไร

1129
00:55:34,450 --> 00:55:36,290
สำหรับห่วงไม่สามสิ่ง

1130
00:55:36,290 --> 00:55:39,340
มันเริ่มต้นบางอย่าง
คุ้มค่าถ้าคุณถามมัน

1131
00:55:39,340 --> 00:55:41,770
มันจะตรวจสอบสภาพ

1132
00:55:41,770 --> 00:55:45,380
และแล้วหลังจากที่แต่ละ
ซ้ำหลังจากแต่ละรอบ

1133
00:55:45,380 --> 00:55:49,330
มันเพิ่มขึ้นบางส่วน
คุ้มค่าหรือค่าที่นี่

1134
00:55:49,330 --> 00:55:50,600
>> ดังนั้นสิ่งที่หมายความว่า?

1135
00:55:50,600 --> 00:55:52,940
เราเริ่มต้นฉันถึง 0

1136
00:55:52,940 --> 00:55:58,610
เราตรวจสอบและให้แน่ใจว่าฉันมีค่าน้อยกว่า
ความยาวของ s ซึ่งเป็น Z-A-M-Y-L-A

1137
00:55:58,610 --> 00:55:59,900
ดังนั้นซึ่งน้อยกว่า 6

1138
00:55:59,900 --> 00:56:02,590
และแน่นอน 0 เป็นน้อยกว่า 6

1139
00:56:02,590 --> 00:56:05,580
>> เราพิมพ์ Z จากชื่อของ Zamyla

1140
00:56:05,580 --> 00:56:08,080
จากนั้นเราก็เพิ่มฉัน 0-1

1141
00:56:08,080 --> 00:56:11,290
จากนั้นเราจะตรวจสอบเป็น 1 น้อย
กว่าความยาวของ s หรือไม่?

1142
00:56:11,290 --> 00:56:13,270
ความยาวของ s คือ 6

1143
00:56:13,270 --> 00:56:13,950
ใช่แล้ว.

1144
00:56:13,950 --> 00:56:16,880
>> ดังนั้นเราพิมพ์ในชื่อ Zamyla ของ ZA

1145
00:56:16,880 --> 00:56:20,090
เราเพิ่ม I จาก 0, 1, 2

1146
00:56:20,090 --> 00:56:23,720
จากนั้นเราจะตรวจสอบเป็น 2 น้อยกว่า
ความยาวของชื่อ Zamyla ของ

1147
00:56:23,720 --> 00:56:25,380
6- ดังนั้น 2 เป็นน้อยกว่า 6

1148
00:56:25,380 --> 00:56:30,460
ใช่ลองพิมพ์ออกมาตอนนี้เอ็ม
ชื่อ Zamyla ของตัวละครที่สาม

1149
00:56:30,460 --> 00:56:34,110
>> ที่สำคัญนี่คือว่าในแต่ละ
ย้ำเรื่องที่ผมตรวจสอบ

1150
00:56:34,110 --> 00:56:37,810
คือผมน้อยกว่าความยาวของ Zamyla หรือไม่

1151
00:56:37,810 --> 00:56:40,350
แต่จับได้ว่า
สเตอร์ลิงไม่ได้เป็นสถานที่ให้บริการ

1152
00:56:40,350 --> 00:56:43,100
บรรดาผู้ที่มีโปรแกรม
ก่อน Java หรือภาษาอื่น ๆ

1153
00:56:43,100 --> 00:56:46,310
อาจจะรู้ว่าความยาวของสตริง
สถานที่ให้บริการเพียงบางส่วนเท่านั้นที่อ่านค่า

1154
00:56:46,310 --> 00:56:50,220
>> ใน C ในกรณีนี้ถ้าเป็น
ฟังก์ชั่นที่เป็นอักษร

1155
00:56:50,220 --> 00:56:53,520
การนับจำนวนของ
ตัวละครใน Zamyla ทุกครั้ง

1156
00:56:53,520 --> 00:56:54,740
ที่เราเรียกว่าฟังก์ชั่น

1157
00:56:54,740 --> 00:56:58,500
ทุกครั้งที่คุณถามคอมพิวเตอร์ให้ใช้
สเตอร์ลิงก็การดูที่ Zamyla,

1158
00:56:58,500 --> 00:57:01,960
และพูดว่า Z-A-M-Y-L-A, 6

1159
00:57:01,960 --> 00:57:02,962
และมันจะกลับ 6

1160
00:57:02,962 --> 00:57:04,920
ครั้งต่อไปที่คุณเรียก
ภายในที่ห่วง

1161
00:57:04,920 --> 00:57:08,610
ก็จะไปดูที่ Zamyla
อีกครั้งบอกว่า Z-A-M-Y-L-A, 6

1162
00:57:08,610 --> 00:57:10,320
และมันจะกลับ 6

1163
00:57:10,320 --> 00:57:12,980
ดังนั้นสิ่งที่โง่เกี่ยวกับการออกแบบนี้หรือไม่?

1164
00:57:12,980 --> 00:57:17,700
>> ทำไมไม่เป็นรหัส 5 จาก 5 ของฉัน
สำหรับการออกแบบในขณะนี้เพื่อที่จะพูด?

1165
00:57:17,700 --> 00:57:20,600
ดีฉันถาม
คำถามที่ไม่จำเป็น

1166
00:57:20,600 --> 00:57:23,030
ฉันทำทำงานมากขึ้นกว่าที่ฉันต้อง

1167
00:57:23,030 --> 00:57:25,370
>> ดังนั้นแม้ว่า
คำตอบที่ถูกต้องผม

1168
00:57:25,370 --> 00:57:29,560
ขอให้คอมพิวเตอร์คืออะไร
ความยาวของ Zamyla อีกครั้ง

1169
00:57:29,560 --> 00:57:31,380
และอีกครั้งและอีกครั้งและอีกครั้ง?

1170
00:57:31,380 --> 00:57:33,980
และคำตอบที่เป็น
ไม่เคยไปเปลี่ยน

1171
00:57:33,980 --> 00:57:35,900
มันมักจะเป็น 6

1172
00:57:35,900 --> 00:57:39,730
>> ดังนั้นทางออกที่ดีกว่านี้
จะเป็นรุ่นต่อไปนี้

1173
00:57:39,730 --> 00:57:43,390
ให้ฉันไปข้างหน้าและใส่ไว้ใน
ไฟล์แยกต่างหากที่เรียกว่า string1.c,

1174
00:57:43,390 --> 00:57:44,990
เพียงเพื่อให้มันแยกจากกัน

1175
00:57:44,990 --> 00:57:47,260
และปรากฎในสำหรับ
ห่วงคุณจริงสามารถ

1176
00:57:47,260 --> 00:57:50,210
ประกาศตัวแปรหลายครั้ง

1177
00:57:50,210 --> 00:57:53,460
>> ดังนั้นฉันจะให้ฉันและตั้งค่าให้ 0

1178
00:57:53,460 --> 00:57:56,190
แต่ฉันยังจะ
เพิ่มเครื่องหมายจุลภาคและกล่าวว่า

1179
00:57:56,190 --> 00:58:01,050
ให้ฉันตัวแปรที่เรียกว่า n ซึ่ง
ค่าเท่ากับความยาวของสตริง s

1180
00:58:01,050 --> 00:58:09,410
และตอนนี้โปรดตรวจสภาพของฉัน
ตราบใดที่ฉันมีค่าน้อยกว่า n

1181
00:58:09,410 --> 00:58:14,140
>> ดังนั้นในทางตรรกะคือ
เหมือนกันในตอนท้ายของวัน

1182
00:58:14,140 --> 00:58:18,280
แต่ผมจำ
มูลค่า 6 ในกรณีนี้

1183
00:58:18,280 --> 00:58:19,780
ความยาวของชื่อ Zamyla คืออะไร?

1184
00:58:19,780 --> 00:58:20,860
และฉันวางไว้ที่ n

1185
00:58:20,860 --> 00:58:23,050
>> และฉันยังคงตรวจสอบ
สภาพทุกครั้ง

1186
00:58:23,050 --> 00:58:24,300
คือ 0 น้อยกว่า 6?

1187
00:58:24,300 --> 00:58:25,600
1 น้อยกว่า 6?

1188
00:58:25,600 --> 00:58:28,600
คือ 2 น้อยกว่า 6 และอื่น ๆ ?

1189
00:58:28,600 --> 00:58:31,914
>> แต่ฉันไม่ได้ขอคอมพิวเตอร์
อีกครั้งและอีกครั้งว่ามีอะไร

1190
00:58:31,914 --> 00:58:33,080
ความยาวของชื่อ Zamyla ได้หรือไม่

1191
00:58:33,080 --> 00:58:34,320
อะไรยาวของชื่อ Zamyla ฯ คืออะไร?

1192
00:58:34,320 --> 00:58:35,986
สิ่งที่ความยาวของชื่อ Zamyla นี้คืออะไร?

1193
00:58:35,986 --> 00:58:40,440
ฉันจำได้ว่าตัวอักษรแรกและ
เพียงตอบในเรื่องนี้ n ตัวแปรที่สอง

1194
00:58:40,440 --> 00:58:45,280
ดังนั้นในตอนนี้จะไม่เพียง
ที่ถูกต้อง แต่ยังออกแบบมาอย่างดี

1195
00:58:45,280 --> 00:58:46,670
>> ตอนนี้สิ่งที่เกี่ยวกับรูปแบบ?

1196
00:58:46,670 --> 00:58:48,866
ฉันได้รับการตั้งชื่อตัวแปรของฉัน
สวยดีผมจะบอกว่า

1197
00:58:48,866 --> 00:58:50,240
พวกเขากำลังซุปเปอร์รวบรัดในขณะนี้

1198
00:58:50,240 --> 00:58:52,090
และที่ดีทั้งหมด

1199
00:58:52,090 --> 00:58:55,120
>> หากคุณมีเพียงหนึ่ง
สตริงในโปรแกรม

1200
00:58:55,120 --> 00:58:56,860
คุณเช่นกันอาจจะเรียกมันสตริง

1201
00:58:56,860 --> 00:58:59,370
หากคุณมีเพียงตัวแปรเดียว
สำหรับการนับในโปรแกรม

1202
00:58:59,370 --> 00:59:00,710
คุณเช่นกันอาจจะเรียกมันฉัน

1203
00:59:00,710 --> 00:59:03,500
ถ้าคุณมีความยาว, N
เป็นซุปเปอร์ร่วมกันได้เป็นอย่างดี

1204
00:59:03,500 --> 00:59:05,800
แต่ฉันไม่ได้แสดงความคิดเห็นใด ๆ ของรหัสของฉัน

1205
00:59:05,800 --> 00:59:09,200
>> ฉันไม่ได้แจ้ง reader--
ไม่ว่าจะเป็น TF ฉันหรือ TA,

1206
00:59:09,200 --> 00:59:12,460
หรือเพียงแค่ colleague-- สิ่งที่ควร
ที่จะเกิดขึ้นในโปรแกรมนี้

1207
00:59:12,460 --> 00:59:15,760
และเพื่อที่จะได้รับรูปแบบที่ดี
สิ่งที่ฉันต้องการจะทำ

1208
00:59:15,760 --> 00:59:24,580
เป็นสิ่งที่ this--
เช่นขอให้ผู้ใช้สำหรับการป้อนข้อมูล

1209
00:59:24,580 --> 00:59:26,670
และฉันจะเขียน
นี้จำนวนวิธีใดวิธีหนึ่ง

1210
00:59:26,670 --> 00:59:35,630
>> ตรวจสอบให้แน่ใจ s-- ให้แน่ใจว่าได้รับ
สตริงกลับสตริง

1211
00:59:35,630 --> 00:59:40,280
และจากนั้นใน here-- และนี่อาจจะเป็น
ที่สำคัญที่สุดสำทับ comment--

1212
00:59:40,280 --> 00:59:44,450
มากกว่าตัวอักษรในหนึ่งในช่วงเวลา

1213
00:59:44,450 --> 00:59:47,060
และฉันจะใช้ใด ๆ
ทางเลือกของการใช้ภาษาอังกฤษ

1214
00:59:47,060 --> 00:59:49,650
ที่นี่เพื่ออธิบายแต่ละ
ชิ้นนี้ของรหัส

1215
00:59:49,650 --> 00:59:52,740
>> ขอให้สังเกตว่าผมยังไม่ได้ใส่
แสดงความคิดเห็นในบรรทัดของรหัสทุกครั้ง

1216
00:59:52,740 --> 00:59:55,690
จริงๆเพียงแค่บนที่น่าสนใจ
คนคนที่

1217
00:59:55,690 --> 00:59:59,460
มีความหมายบางอย่างที่ฉันอาจ
ต้องการที่จะทำให้สุดความชัดเจนให้กับใครบางคน

1218
00:59:59,460 --> 01:00:00,460
การอ่านรห​​ัสของฉัน

1219
01:00:00,460 --> 01:00:02,920
และทำไมคุณโทรมาได้รับ
สตริงขอให้ผู้ใช้สำหรับการป้อนข้อมูล?

1220
01:00:02,920 --> 01:00:05,450
แม้ที่หนึ่งไม่จำเป็นต้องเป็น
ทุกสิ่งที่สื่อความหมาย

1221
01:00:05,450 --> 01:00:09,340
แต่มันก็ช่วยบอกเล่าเรื่องราวเพราะ
บรรทัดที่สองในเรื่องที่จะให้แน่ใจว่า

1222
01:00:09,340 --> 01:00:10,740
ได้รับกลับสตริงสตริง

1223
01:00:10,740 --> 01:00:14,260
>> และบรรทัดที่สามในเรื่องคือ
ย้ำกว่าตัวละครใน s หนึ่ง

1224
01:00:14,260 --> 01:00:15,380
ขณะนั้น.

1225
01:00:15,380 --> 01:00:17,920
และขณะนี้เป็นเพียงการวัดที่ดี,
ฉันจะไปข้างหน้าและเพิ่ม

1226
01:00:17,920 --> 01:00:24,560
หนึ่งความคิดเห็นเพิ่มเติมว่าเพียงแค่
บอกว่าตัวอักษรพิมพ์ I-TH ใน s

1227
01:00:24,560 --> 01:00:26,520
ตอนนี้สิ่งที่ฉันได้ทำ
ในตอนท้ายของวัน?

1228
01:00:26,520 --> 01:00:29,190
>> ฉันได้เพิ่มภาษาอังกฤษบางส่วน
คำในรูปแบบของการแสดงความคิดเห็น

1229
01:00:29,190 --> 01:00:32,700
สัญลักษณ์เฉือนเฉือนหมายความว่าเดี๋ยวก่อน
คอมพิวเตอร์เครื่องนี้สำหรับมนุษย์

1230
01:00:32,700 --> 01:00:33,820
ไม่ได้สำหรับคุณคอมพิวเตอร์

1231
01:00:33,820 --> 01:00:35,119
เพื่อให้พวกเขาไม่สนใจเหตุผล

1232
01:00:35,119 --> 01:00:35,910
พวกเขากำลังเพียงมี

1233
01:00:35,910 --> 01:00:39,830
>> และแน่นอน CS50 IDE แสดงให้เห็นว่าพวกเขาเป็น
สีเทาเป็นประโยชน์ แต่ไม่สำคัญ

1234
01:00:39,830 --> 01:00:41,000
ในการเขียนโปรแกรม

1235
01:00:41,000 --> 01:00:42,570
ขอให้สังเกตสิ่งที่ตอนนี้คุณสามารถทำได้

1236
01:00:42,570 --> 01:00:44,950
ไม่ว่าคุณจะรู้ว่า C
การเขียนโปรแกรมหรือไม่คุณ

1237
01:00:44,950 --> 01:00:47,722
ก็สามารถกลับมายืนอยู่ที่นี้
โปรแกรมและหางการแสดงความคิดเห็น

1238
01:00:47,722 --> 01:00:50,180
ขอให้ผู้ใช้สำหรับการป้อนข้อมูลให้แน่ใจว่า
ได้รับกลับสตริงสตริง

1239
01:00:50,180 --> 01:00:53,009
ย้ำกว่าตัวละครใน s
หนึ่งที่เวลาพิมพ์ตัวอักษร

1240
01:00:53,009 --> 01:00:55,550
ตัวอักษร I-TH ใน s-- คุณทำไม่ได้
แม้ต้องมองไปที่รหัส

1241
01:00:55,550 --> 01:00:57,270
ที่จะเข้าใจสิ่งที่โปรแกรมนี้ไม่

1242
01:00:57,270 --> 01:01:00,280
และยังดีกว่าถ้าคุณตัวเองดู
ในโปรแกรมนี้ในหนึ่งหรือสองสัปดาห์

1243
01:01:00,280 --> 01:01:02,280
หรือเดือนหรือปี
คุณก็ไม่ได้มี

1244
01:01:02,280 --> 01:01:04,420
จ้องที่รหัส
พยายามที่จะจำ

1245
01:01:04,420 --> 01:01:06,630
สิ่งที่ผมพยายามจะทำอย่างไรกับรหัสนี้หรือไม่?

1246
01:01:06,630 --> 01:01:07,770
>> คุณเคยบอกตัวเอง

1247
01:01:07,770 --> 01:01:11,660
คุณได้เล่าว่าสำหรับตัวคุณเอง
หรือเพื่อนร่วมงานหรือ TA หรือ TF

1248
01:01:11,660 --> 01:01:14,860
ดังนั้นในตอนนี้จะเป็น
ที่ถูกต้องและการออกแบบที่ดี

1249
01:01:14,860 --> 01:01:18,210
และในที่สุดรูปแบบที่ดีเช่นกัน

1250
01:01:18,210 --> 01:01:19,990
เพื่อทำให้ทราบว่า

1251
01:01:19,990 --> 01:01:22,200
>> ดังนั้นจึงมีคนอื่น ๆ
สิ่งที่ฉันจะทำที่นี่

1252
01:01:22,200 --> 01:01:28,240
ที่ตอนนี้สามารถที่จะเปิดเผยว่าสิ่งที่
ที่เกิดขึ้นภายใต้ฝากระโปรง

1253
01:01:28,240 --> 01:01:30,390
เพื่อให้มีคุณลักษณะนี้
ใน C และภาษาอื่น ๆ

1254
01:01:30,390 --> 01:01:33,010
เรียกว่า Typecasting
อย่างใดอย่างหนึ่งโดยปริยาย

1255
01:01:33,010 --> 01:01:37,250
หรืออย่างชัดเจนช่วยให้คุณแปลง
จากชนิดข้อมูลหนึ่งไปยังอีก

1256
01:01:37,250 --> 01:01:39,800
เราได้รับการติดต่อเพื่อให้
ห่างไกลในวันนี้ด้วยสตริง

1257
01:01:39,800 --> 01:01:41,250
>> และสตริงตัวอักษร

1258
01:01:41,250 --> 01:01:44,910
แต่จำจากสัปดาห์
0 สิ่งที่เป็นตัวอักษร?

1259
01:01:44,910 --> 01:01:49,334
ตัวอักษรเป็นเพียงนามธรรม
ด้านบนของตัวเลขทศนิยมเบอร์,

1260
01:01:49,334 --> 01:01:52,500
และตัวเลขทศนิยมจริงๆเพียง
นามธรรมด้านบนของเลขฐานสอง,

1261
01:01:52,500 --> 01:01:53,720
ในขณะที่เรากำหนดมัน

1262
01:01:53,720 --> 01:01:55,540
>> ดังนั้นตัวอักษรเป็นตัวเลข

1263
01:01:55,540 --> 01:01:58,410
และตัวเลขตัวอักษร
เพียงขึ้นอยู่กับบริบท

1264
01:01:58,410 --> 01:02:01,250
และปรากฎว่าภายใน
ของโปรแกรมคอมพิวเตอร์

1265
01:02:01,250 --> 01:02:06,830
คุณสามารถระบุวิธีการที่คุณต้องการที่จะดู
ที่บิตภายในของโปรแกรมที่?

1266
01:02:06,830 --> 01:02:10,400
>> การเรียกคืนจากสัปดาห์ที่ 0 ที่เรามี
ASCII ซึ่งเป็นเพียงรหัสนี้

1267
01:02:10,400 --> 01:02:11,620
ตัวอักษรทำแผนที่ไปยังหมายเลข

1268
01:02:11,620 --> 01:02:13,660
และเรากล่าวว่าทุนคือ 65

1269
01:02:13,660 --> 01:02:15,860
ทุน B คือ 66, และอื่น ๆ

1270
01:02:15,860 --> 01:02:20,500
>> และแจ้งให้ทราบเราเป็นหลักมีตัวอักษรบน
แถวบนสุดที่นี่เป็น C จะเรียกพวกเขา

1271
01:02:20,500 --> 01:02:23,400
ตัวละครแล้ว
ints ในแถวที่สอง

1272
01:02:23,400 --> 01:02:28,180
และปรากฎคุณสามารถแปลง
ได้อย่างลงตัวระหว่างทั้งสองโดยทั่วไป

1273
01:02:28,180 --> 01:02:30,042
และถ้าเราต้องการที่จะทำ
นี้จงใจเรา

1274
01:02:30,042 --> 01:02:31,750
อาจต้องการที่จะแก้ไขปัญหา
บางอย่างเช่นนี้

1275
01:02:31,750 --> 01:02:33,590
>> เราอาจจะต้องการแปลง
กรณีบนเพื่อลด

1276
01:02:33,590 --> 01:02:35,330
กรณีหรือกรณีที่ต่ำกว่าเพื่อกรณีบน

1277
01:02:35,330 --> 01:02:38,000
และมันจะเปิดออกมีของ
จริงรูปแบบที่นี่

1278
01:02:38,000 --> 01:02:39,900
เราสามารถโอบกอดในเวลาเพียงสักครู่

1279
01:02:39,900 --> 01:02:44,120
แต่ขอดูครั้งแรกที่
ตัวอย่างของการทำเช่นนี้อย่างชัดเจน

1280
01:02:44,120 --> 01:02:46,340
>> ฉันจะกลับไป CS50 IDE

1281
01:02:46,340 --> 01:02:50,640
ฉันจะสร้าง
ไฟล์ที่เรียกว่า Ascii 0.c.

1282
01:02:50,640 --> 01:02:55,960
และฉันจะไปข้างหน้าและเพิ่มของฉัน
io.h มาตรฐานที่ด้านบน int เป็นโมฆะหลัก

1283
01:02:55,960 --> 01:02:57,370
ที่ด้านบนของฟังก์ชั่นของฉัน

1284
01:02:57,370 --> 01:03:02,700
แล้วฉันแค่ไปที่จะทำ
following-- สำหรับห่วงจาก i เท่ากับ

1285
01:03:02,700 --> 01:03:04,610
สมมติว่า 65

1286
01:03:04,610 --> 01:03:10,460
>> แล้วฉันก็เป็นไปได้น้อยกว่า
65 บวก 26 ตัวอักษรในตัวอักษร

1287
01:03:10,460 --> 01:03:12,640
ดังนั้นฉันจะให้คอมพิวเตอร์
ทำคณิตศาสตร์สำหรับฉันมี

1288
01:03:12,640 --> 01:03:15,100
และจากนั้นภายในวงนี้
สิ่งที่ฉันจะพิมพ์เพื่อ?

1289
01:03:15,100 --> 01:03:19,230
>> % c คือ% ฉันทับขวา n

1290
01:03:19,230 --> 01:03:21,290
และตอนนี้ฉันต้องการที่จะเชื่อมต่อสองค่า

1291
01:03:21,290 --> 01:03:24,530
ฉันได้ใส่คำถามชั่วคราว
เครื่องหมายที่นั่นเพื่อเชิญคำถาม

1292
01:03:24,530 --> 01:03:29,940
>> ผมอยากจะย้ำตั้งแต่ 65 เป็นต้นไป
สำหรับ 26 ตัวอักษรของตัวอักษร,

1293
01:03:29,940 --> 01:03:35,190
พิมพ์ออกในแต่ละย้ำว่า
ตัวละครเทียบเท่าหนึ่ง

1294
01:03:35,190 --> 01:03:38,299
ในคำอื่น ๆ ที่ฉันต้องการ
ย้ำพิมพ์กว่า 26 หมายเลข

1295
01:03:38,299 --> 01:03:41,590
สิ่งที่อักขระ ASCII เป็นตัวอักษร
และสิ่งที่เกี่ยวข้องจำนวน is--

1296
01:03:41,590 --> 01:03:44,650
จริงๆเพียงแค่การสร้าง
แผนภูมิจากสไลด์ว่า

1297
01:03:44,650 --> 01:03:47,010
ดังนั้นสิ่งที่เครื่องหมายคำถามเหล่านี้ควรจะเป็นอย่างไร

1298
01:03:47,010 --> 01:03:51,760
>> ดีก็ปรากฎว่าสอง
หนึ่งก็ควรจะเป็นตัวแปรฉัน

1299
01:03:51,760 --> 01:03:53,860
ฉันต้องการที่จะเห็นว่าเป็นตัวเลข

1300
01:03:53,860 --> 01:03:58,920
และอาร์กิวเมนต์กลาง
ที่นี่ผมสามารถบอกได้ว่าเครื่องคอมพิวเตอร์

1301
01:03:58,920 --> 01:04:03,470
ในการรักษาจำนวนเต็มที่
ฉันเป็นตัวอักษรเพื่อให้เป็น

1302
01:04:03,470 --> 01:04:05,880
เพื่อทดแทนได้ที่นี่ร้อยละซี

1303
01:04:05,880 --> 01:04:07,990
>> ในคำอื่น ๆ ถ้าผมที่
โปรแกรมเมอร์มนุษย์รู้

1304
01:04:07,990 --> 01:04:09,865
เหล่านี้เป็นเพียงตัวเลข
ในตอนท้ายของวัน.

1305
01:04:09,865 --> 01:04:12,500
และฉันรู้ว่า 65 ควร
map กับตัวละครบาง

1306
01:04:12,500 --> 01:04:15,310
พร้อมกับโยนอย่างชัดเจนนี้
ด้วยวงเล็บ,

1307
01:04:15,310 --> 01:04:18,840
ชื่อของชนิดข้อมูลที่คุณต้องการไป
แปลงและวงเล็บปิด

1308
01:04:18,840 --> 01:04:21,200
คุณสามารถบอก
คอมพิวเตอร์, Hey, คอมพิวเตอร์,

1309
01:04:21,200 --> 01:04:24,130
แปลงจำนวนเต็มนี้เพื่อถ่าน

1310
01:04:24,130 --> 01:04:26,250
>> ดังนั้นเมื่อผมทำงานนี้
โปรแกรมหลังจากที่รวบรวม

1311
01:04:26,250 --> 01:04:29,740
เรามาดูสิ่งที่ฉัน get-- ทำให้ Ascii 0

1312
01:04:29,740 --> 01:04:33,020
ยี้มันสิ่งที่ฉันได้ทำผิดที่นี่?

1313
01:04:33,020 --> 01:04:35,884
การใช้งานของตัวระบุไม่ได้ประกาศ
สิทธิทั้งหมดไม่ได้เจตนา

1314
01:04:35,884 --> 01:04:37,800
แต่ขอดูว่าเราไม่สามารถ
เหตุผลผ่านทางนี้

1315
01:04:37,800 --> 01:04:41,220
>> ดังนั้นสาย five-- ดังนั้นผมจึงไม่ได้รับ
ไกลมากก่อนที่จะกวดขันขึ้น

1316
01:04:41,220 --> 01:04:42,140
ไม่เป็นไร.

1317
01:04:42,140 --> 01:04:46,560
ดังนั้นสาย 5 เพราะเราเท่ากับ 65-- ฉันเห็น

1318
01:04:46,560 --> 01:04:50,130
ดังนั้นจำไว้ว่าใน C ซึ่งแตกต่างจากบางส่วน
ภาษาถ้าคุณมีการเขียนโปรแกรมก่อน

1319
01:04:50,130 --> 01:04:52,190
ประสบการณ์ที่คุณมี
ที่จะบอกคอมพิวเตอร์

1320
01:04:52,190 --> 01:04:55,040
ซึ่งแตกต่างจากรอยขีดข่วนสิ่งที่
ชนิดของตัวแปรมันเป็น

1321
01:04:55,040 --> 01:04:56,860
>> และฉันลืมวลีที่สำคัญที่นี่

1322
01:04:56,860 --> 01:04:59,200
ในบรรทัดที่ห้าผมได้เริ่มต้นใช้ฉัน

1323
01:04:59,200 --> 01:05:01,560
แต่ผมยังไม่ได้บอก C
ข้อมูลที่พิมพ์เป็น

1324
01:05:01,560 --> 01:05:04,570
ดังนั้นฉันจะไปในที่นี่
พูด ah, ทำให้มันเป็นจำนวนเต็ม

1325
01:05:04,570 --> 01:05:07,050
>> ตอนนี้ฉันจะไปข้างหน้าและคอมไพล์

1326
01:05:07,050 --> 01:05:08,080
ที่คงที่

1327
01:05:08,080 --> 01:05:12,660
./ascii0 ใส่ว่าเป็นชนิดของเย็น

1328
01:05:12,660 --> 01:05:15,360
ไม่เพียง แต่มันเป็นซุปเปอร์รวดเร็ว
ถามคอมพิวเตอร์คำถามนี้

1329
01:05:15,360 --> 01:05:18,885
มากกว่ามองขึ้นบนภาพนิ่ง
มันพิมพ์ออกมาอย่างใดอย่างหนึ่งต่อบรรทัดคือ 65,

1330
01:05:18,885 --> 01:05:24,860
B เป็น 66 ทุกทาง down-- ตั้งแต่ผม
ทำอย่างนี้ 26 times-- กับตัวอักษร Z,

1331
01:05:24,860 --> 01:05:25,630
ซึ่งเป็น 90

1332
01:05:25,630 --> 01:05:27,790
และในความเป็นจริงเล็กน้อย
ฉลาดมากขึ้นจะ

1333
01:05:27,790 --> 01:05:31,030
ได้รับสำหรับฉันที่จะไม่พึ่งพา
บนคอมพิวเตอร์เพื่อเพิ่ม 26

1334
01:05:31,030 --> 01:05:34,060
ฉันจะได้ทำเพียงแค่
90 เช่นกันนานมาก

1335
01:05:34,060 --> 01:05:37,390
ที่ผมไม่ทำผิดพลาดเหมือนครั้งที่สอง

1336
01:05:37,390 --> 01:05:41,880
ฉันต้องการที่จะไปขึ้นผ่าน
Z ไม่เพียงผ่าน Y

1337
01:05:41,880 --> 01:05:44,000
>> เพื่อให้เป็นนักแสดงอย่างชัดเจน

1338
01:05:44,000 --> 01:05:47,860
แต่กลับกลายเป็นว่านี้
ไม่จำเป็นต้องได้

1339
01:05:47,860 --> 01:05:52,480
ให้ฉันไปข้างหน้าและวิ่งนี้
คอมไพเลอร์และวิ่ง Ascii 0

1340
01:05:52,480 --> 01:05:54,940
แต่กลับกลายเป็นว่าซีเป็นสมาร์ทสวย

1341
01:05:54,940 --> 01:05:57,150
>> และ printf โดยเฉพาะอย่างยิ่ง
เป็นสมาร์ทสวย

1342
01:05:57,150 --> 01:06:01,260
หากคุณเพียงแค่ผ่านฉันสองครั้ง
สำหรับทั้งตัวยึด printf

1343
01:06:01,260 --> 01:06:04,510
จะรู้ว่าโอ้ดีฉันรู้ว่าคุณ
ให้ผม integer-- จำนวนบาง

1344
01:06:04,510 --> 01:06:06,380
เช่น 65 หรือ 90 หรืออะไรก็ตาม

1345
01:06:06,380 --> 01:06:10,170
แต่ผมเห็นว่าคุณต้องการให้ฉันไป
จัดรูปแบบตัวเลขที่เหมือนตัวละคร

1346
01:06:10,170 --> 01:06:16,460
และเพื่อให้ printf สามารถลงโดยปริยาย
int เพื่อถ่านสำหรับคุณเช่นกัน

1347
01:06:16,460 --> 01:06:19,360
ดังนั้นที่ไม่ได้เป็นปัญหาที่ทุกคน

1348
01:06:19,360 --> 01:06:23,100
>> แต่สังเกตเห็นเพราะความเท่าเทียมนี้
เราจริงสามารถทำเช่นนี้ได้เป็นอย่างดี

1349
01:06:23,100 --> 01:06:26,520
ให้ฉันไปข้างหน้าและทำให้ใครคนหนึ่ง
รุ่นอื่น ๆ ของ this-- 1.c. Ascii

1350
01:06:26,520 --> 01:06:31,800
และแทนที่จะทำซ้ำมากกว่า
จำนวนเต็มจริงๆสามารถพัดใจของคุณ

1351
01:06:31,800 --> 01:06:33,610
โดยการทำซ้ำตัวละคร

1352
01:06:33,610 --> 01:06:37,660
ถ้าถ่านได้รับทุนผม
ต้องการที่จะไปข้างหน้าและทำเช่นนี้

1353
01:06:37,660 --> 01:06:41,740
ตราบใดที่ C คือน้อยกว่าหรือเท่ากับ
ถึง Z ทุนและในแต่ละซ้ำ

1354
01:06:41,740 --> 01:06:45,690
ฉันต้องการที่จะเพิ่ม C, ฉันสามารถ
ขณะนี้อยู่ในบรรทัด printf ของฉันที่นี่

1355
01:06:45,690 --> 01:06:51,320
พูดร้อยละซี
ร้อยละฉันอีกครั้งจุลภาคซี

1356
01:06:51,320 --> 01:06:57,200
>> และตอนนี้ฉันสามารถไปทิศทางอื่น ๆ
หล่อตัวอักษรอย่างชัดเจน

1357
01:06:57,200 --> 01:06:58,500
เป็นจำนวนเต็ม

1358
01:06:58,500 --> 01:07:00,560
ดังนั้นอีกครั้งว่าทำไมคุณจะทำเช่นนี้?

1359
01:07:00,560 --> 01:07:03,830
มันเป็นเพียงเล็กน้อยแปลกที่จะเรียงลำดับของ
นับในแง่ของตัวละคร

1360
01:07:03,830 --> 01:07:07,430
>> แต่ถ้าคุณเข้าใจสิ่งที่
ที่เกิดขึ้นภายใต้ประทุน

1361
01:07:07,430 --> 01:07:08,430
มีจริงๆไม่มีเวทมนตร์

1362
01:07:08,430 --> 01:07:13,060
คุณเพียงแค่บอกว่าเดี๋ยวก่อนคอมพิวเตอร์ให้
ฉันตัวแปรเรียกว่า C ประเภทถ่าน

1363
01:07:13,060 --> 01:07:16,520
มันเริ่มต้นไปยังเมืองหลวงและ A.
แจ้งให้ทราบว่าราคาเดียว

1364
01:07:16,520 --> 01:07:19,580
>> สำหรับตัวละครใน C, จำจาก
สัปดาห์ที่ผ่านมาคุณใช้ราคาเดียว

1365
01:07:19,580 --> 01:07:23,720
สำหรับสตริงสำหรับคำ
วลีที่คุณใช้คำพูดสอง

1366
01:07:23,720 --> 01:07:27,210
ตกลงคอมพิวเตอร์ให้ทำเช่นนี้เพื่อให้
ตราบใดที่ตัวละครจะน้อยกว่า

1367
01:07:27,210 --> 01:07:28,050
หรือเท่ากับ Z

1368
01:07:28,050 --> 01:07:32,640
และฉันรู้จากตาราง Ascii ของฉันที่ทั้งหมด
ของรหัส Ascii เหล่านี้มีความต่อเนื่องกัน

1369
01:07:32,640 --> 01:07:33,400
>> ไม่มีช่องว่างเป็น

1370
01:07:33,400 --> 01:07:36,737
ดังนั้นมันจึงเป็นเพียงถึง Z
แยกจากกันโดยแต่ละหมายเลขหนึ่ง

1371
01:07:36,737 --> 01:07:38,820
แล้วฉันจะเพิ่มขึ้น
ถ่านถ้าผมต้องการ

1372
01:07:38,820 --> 01:07:40,390
ในตอนท้ายของวัน,
มันเป็นเพียงตัวเลข

1373
01:07:40,390 --> 01:07:41,030
ฉันรู้ว่านี้.

1374
01:07:41,030 --> 01:07:43,670
ดังนั้นผมก็สามารถเข้าใจเพื่อเพิ่ม 1 ถึงมัน

1375
01:07:43,670 --> 01:07:46,940
>> แล้วเวลานี้ผมพิมพ์ C,
แล้วเทียบเท่าหนึ่ง

1376
01:07:46,940 --> 01:07:50,170
และฉันไม่จำเป็นต้องหล่ออย่างชัดเจน

1377
01:07:50,170 --> 01:07:52,680
ฉันสามารถให้ printf และ
รูปคอมพิวเตอร์สิ่งที่ออก

1378
01:07:52,680 --> 01:07:57,300
เพื่อที่ว่าตอนนี้ถ้าผมทำงาน
ทำให้ Ascii1./ascii1,

1379
01:07:57,300 --> 01:08:01,520
ฉันจะได้รับสิ่งเดียวที่แน่นอนเช่นกัน

1380
01:08:01,520 --> 01:08:04,530
>> โปรแกรมไร้ประโยชน์ though-- ไม่มีใคร
เป็นไปได้จริงเขียนซอฟต์แวร์

1381
01:08:04,530 --> 01:08:07,549
เพื่อที่จะคิดออกสิ่งที่เป็น
ตัวเลขที่แผนที่ไปยังหรือ B หรือ Z?

1382
01:08:07,549 --> 01:08:10,340
คุณเพียงแค่ไปที่ Google มันหรือ
มองมันได้ออนไลน์หรือดูมันขึ้น

1383
01:08:10,340 --> 01:08:11,650
บนสไลด์หรือชอบ

1384
01:08:11,650 --> 01:08:13,520
เพื่อที่จะได้รับจริงนี้มีประโยชน์หรือไม่

1385
01:08:13,520 --> 01:08:15,960
>> ดีพูดว่า
สไลด์สังเกตเห็นมี

1386
01:08:15,960 --> 01:08:20,890
รูปแบบที่เกิดขึ้นจริงที่นี่ระหว่างตัวพิมพ์ใหญ่
และตัวพิมพ์เล็กที่ไม่ได้ตั้งใจ

1387
01:08:20,890 --> 01:08:23,760
ขอให้สังเกตว่าทุนคือ 65

1388
01:08:23,760 --> 01:08:25,830
ตัวพิมพ์เล็กเป็น 97

1389
01:08:25,830 --> 01:08:29,649
และวิธีการที่ห่างไกลออกไปเป็นกรณีที่ต่ำกว่าหรือไม่?

1390
01:08:29,649 --> 01:08:32,649
>> ดังนั้น 65 ขั้นตอนวิธีการที่หลายคนให้พ้นจาก 97?

1391
01:08:32,649 --> 01:08:36,210
ดังนั้น 97 ลบ 65 เป็น 32

1392
01:08:36,210 --> 01:08:37,910
ดังนั้นเงินทุนคือ 65

1393
01:08:37,910 --> 01:08:39,939
ถ้าคุณเพิ่ม 32 ถึงว่า
คุณจะได้รับตัวพิมพ์เล็ก

1394
01:08:39,939 --> 01:08:43,729
และเท่ากันถ้าคุณลบ 32,
คุณได้รับกลับไปยังเมืองหลวง A-- เดียวกันกับ B

1395
01:08:43,729 --> 01:08:46,380
น้อย B, C ขนาดใหญ่เพื่อคเล็ก ๆ น้อย ๆ

1396
01:08:46,380 --> 01:08:50,670
>> ทั้งหมดเหล่านี้เป็นช่องว่างห่างกัน 32

1397
01:08:50,670 --> 01:08:54,450
ตอนนี้ก็ดูเหมือนจะช่วยให้เราสามารถ
ทำอะไรเช่น Microsoft Word,

1398
01:08:54,450 --> 01:08:57,729
หรือ Google Docs มีที่คุณ
สามารถเลือกทุกอย่างแล้วพูดว่า

1399
01:08:57,729 --> 01:09:00,520
เปลี่ยนทุกตัวพิมพ์เล็กหรือ
เปลี่ยนทุกกรณีบน

1400
01:09:00,520 --> 01:09:03,840
หรือเปลี่ยนแปลงเพียงคำแรก
ของประโยคกรณี​​ส่วนบน

1401
01:09:03,840 --> 01:09:07,390
เราสามารถทำได้จริงบางสิ่งบางอย่าง
เช่นเดียวกับที่ตัวเอง

1402
01:09:07,390 --> 01:09:12,645
>> ให้ฉันไปข้างหน้าและบันทึกแฟ้ม
นี่เรียกว่าประโยชน์ 0.c.

1403
01:09:12,645 --> 01:09:15,770
และให้ไปข้างหน้าและชักขึ้นโปรแกรม
ที่ไม่ตรงกับที่ดังต่อไปนี้

1404
01:09:15,770 --> 01:09:18,460
ดังนั้น ได้แก่ ห้องสมุด CS50

1405
01:09:18,460 --> 01:09:21,430
และรวมถึงมาตรฐานของ I / O

1406
01:09:21,430 --> 01:09:22,787
>> และฉันรู้ว่านี้จะมาเร็ว ๆ นี้

1407
01:09:22,787 --> 01:09:24,870
ดังนั้นฉันจะใส่ไว้ใน
มีอยู่แล้วสตริง,

1408
01:09:24,870 --> 01:09:26,960
ดังนั้นผมจึงมีการเข้าถึง
สิ่งที่ต้องการสเตอร์ลิง

1409
01:09:26,960 --> 01:09:29,620
แล้ว int เป็นโมฆะหลักตามปกติ

1410
01:09:29,620 --> 01:09:33,420
แล้วฉันจะไปข้างหน้า
และจะได้รับได้รับสตริงสตริง

1411
01:09:33,420 --> 01:09:35,032
เพียงเพื่อให้ได้สตริงจากผู้ใช้

1412
01:09:35,032 --> 01:09:36,740
แล้วฉันจะไป
จะตรวจสอบสุขภาพจิตของฉัน

1413
01:09:36,740 --> 01:09:40,510
ถ้าสตริงไม่ null เท่ากัน
แล้วมันปลอดภัยที่จะดำเนินการต่อไป

1414
01:09:40,510 --> 01:09:42,000
และทำในสิ่งที่ฉันต้องการจะทำอย่างไร?

1415
01:09:42,000 --> 01:09:48,700
ฉันจะย้ำจาก i เท่ากับ 0,
n และขึ้นอยู่กับความยาวของสตริง s

1416
01:09:48,700 --> 01:09:51,899
>> และฉันจะทำเช่นนี้ตราบใดที่
ฉันมีค่าน้อยกว่า n และฉันบวกบวก

1417
01:09:51,899 --> 01:09:55,060
เพื่อให้ห่างไกลฉันจริงๆเพียงแค่
ยืมความคิดจากก่อน

1418
01:09:55,060 --> 01:09:57,010
และตอนนี้ฉันจะแนะนำสาขา

1419
01:09:57,010 --> 01:09:59,635
>> ดังนั้นคิดว่ากลับไปเกาที่
เรามีส้อมผู้ที่อยู่ในท้องถนน

1420
01:09:59,635 --> 01:10:05,110
และสัปดาห์ที่ผ่านมาใน C. ฉันจะ
พูดแบบนี้ถ้าตัวอักษร I-TH ใน s

1421
01:10:05,110 --> 01:10:09,250
มากกว่าหรือ
เท่ากับลดกรณี

1422
01:10:09,250 --> 01:10:13,340
and-- ในรอยขีดข่วนที่คุณต้องการอย่างแท้จริง
พูดและ แต่ใน C คุณพูดเครื่องหมาย,

1423
01:10:13,340 --> 01:10:19,830
ampersand-- และตัวอักษร I-TH ใน s
น้อยกว่าหรือเท่ากับกรณีที่ต่ำกว่า Z,

1424
01:10:19,830 --> 01:10:21,780
ขอทำสิ่งที่น่าสนใจ

1425
01:10:21,780 --> 01:10:27,020
Let 's จริงพิมพ์
ตัวละครที่ไม่มีการขึ้นบรรทัดใหม่

1426
01:10:27,020 --> 01:10:31,760
ว่าเป็นตัวละครในสตริง
ตัวอักษร I-TH ในสตริง

1427
01:10:31,760 --> 01:10:37,420
>> แต่ขอไปข้างหน้าและ
ลบ 32 จากมัน

1428
01:10:37,420 --> 01:10:42,120
อื่นถ้าตัวละครในนั้น
สตริงที่เรากำลังมองหา

1429
01:10:42,120 --> 01:10:45,950
ไม่ได้เล็ก ๆ น้อย ๆ ระหว่าง
และลิตเติ้ล Z ไปข้างหน้า

1430
01:10:45,950 --> 01:10:48,610
และเพียงแค่พิมพ์มันออกมาไม่เปลี่ยนแปลง

1431
01:10:48,610 --> 01:10:50,840
ดังนั้นเราจึงได้แนะนำให้รู้จัก
นี้สัญกรณ์วงเล็บ

1432
01:10:50,840 --> 01:10:53,560
สำหรับสตริงของเราที่จะได้รับที่
ตัวอักษร I-TH ในสตริง

1433
01:10:53,560 --> 01:10:57,520
>> ฉันได้เพิ่มบางตรรกะเงื่อนไขเช่น
รอยขีดข่วนในหนึ่งสัปดาห์เมื่อสัปดาห์ที่แล้วที่

1434
01:10:57,520 --> 01:10:59,880
ฉันเพียงแค่ใช้พื้นฐานของฉัน
เข้าใจในสิ่งที่เป็น

1435
01:10:59,880 --> 01:11:01,130
ที่เกิดขึ้นภายใต้ฝากระโปรง

1436
01:11:01,130 --> 01:11:04,190
เป็นตัวละครที่ i ของ s
มากกว่าหรือเท่ากับหรือไม่?

1437
01:11:04,190 --> 01:11:08,290
เหมือนมันเป็น 97 หรือ 98
หรือ 99 และอื่น ๆ ?

1438
01:11:08,290 --> 01:11:11,940
>> แต่ก็ยังน้อยกว่าหรือเท่ากับ
มูลค่าของตัวพิมพ์เล็ก Z หรือไม่?

1439
01:11:11,940 --> 01:11:16,210
และถ้าเป็นเช่นนั้นสิ่งที่ไม่บรรทัดนี้หมายความว่าอย่างไร

1440
01:11:16,210 --> 01:11:20,250
14 นี้จะเรียงลำดับของ
จมูกของความคิดทั้งหมด

1441
01:11:20,250 --> 01:11:23,840
อักษรตัวโดย
เพียงแค่ลบ 32 จากมัน

1442
01:11:23,840 --> 01:11:29,370
ในกรณีนี้เพราะฉันรู้ว่าต่อว่า
แผนภูมิวิธีหมายเลขของฉันจะเป็นตัวแทนของ

1443
01:11:29,370 --> 01:11:33,925
ดังนั้นขอให้ไปข้างหน้าและทำงานนี้
หลังจากรวบรวมประโยชน์ 0.c,

1444
01:11:33,925 --> 01:11:36,210
และเรียกใช้ประโยชน์ 0

1445
01:11:36,210 --> 01:11:40,300
>> ลองพิมพ์ในสิ่งที่ต้องการ
Zamyla ตัวพิมพ์เล็กทั้งหมด Enter

1446
01:11:40,300 --> 01:11:42,780
และตอนนี้เรามี Zamyla ตัวพิมพ์ใหญ่ทั้งหมด

1447
01:11:42,780 --> 01:11:45,050
ลองพิมพ์ในร็อบในพิมพ์เล็กทั้งหมด

1448
01:11:45,050 --> 01:11:46,674
ลองเจสันในพิมพ์เล็กทั้งหมด

1449
01:11:46,674 --> 01:11:48,590
และเราได้รับ
บังคับตัวพิมพ์ใหญ่

1450
01:11:48,590 --> 01:11:50,960
มีข้อผิดพลาดเล็ก ๆ น้อย ๆ ที่ฉันเป็น
ชนิดของการไม่ได้คาดหวัง

1451
01:11:50,960 --> 01:11:54,050
ขอให้สังเกตพรอมต์ใหม่ของฉันกำลังจะสิ้นสุดลงขึ้น
ในบรรทัดเดียวกับชื่อของพวกเขา

1452
01:11:54,050 --> 01:11:55,520
ที่รู้สึกยุ่งเล็ก ๆ น้อย ๆ

1453
01:11:55,520 --> 01:11:59,170
>> ดังนั้นฉันจะไปที่นี่และ
จริงในตอนท้ายของโปรแกรมนี้

1454
01:11:59,170 --> 01:12:02,110
พิมพ์ออกมาเป็นตัวอักษรขึ้นบรรทัดใหม่

1455
01:12:02,110 --> 01:12:03,160
นั่นคือทั้งหมดที่

1456
01:12:03,160 --> 01:12:06,120
ด้วย printf คุณไม่จำเป็นต้อง
ผ่านในตัวแปรหรือรหัสรูปแบบ

1457
01:12:06,120 --> 01:12:08,460
คุณสามารถแท้จริงเพียงแค่พิมพ์
สิ่งที่ต้องการขึ้นบรรทัดใหม่

1458
01:12:08,460 --> 01:12:13,529
>> ดังนั้นขอให้ไปข้างหน้าและทำให้
ประโยชน์ 0 อีกครั้งเรียกว่า Zamyla

1459
01:12:13,529 --> 01:12:14,820
และตอนนี้ก็เป็นความน่ารักเล็ก ๆ น้อย ๆ

1460
01:12:14,820 --> 01:12:17,274
ตอนนี้พรอมต์ของฉันอยู่บนบรรทัดใหม่ของตัวเอง

1461
01:12:17,274 --> 01:12:18,440
ดังนั้นนั่นคือทั้งหมดที่ดีและดี

1462
01:12:18,440 --> 01:12:19,910
เพื่อให้เป็นตัวอย่างที่ดี

1463
01:12:19,910 --> 01:12:22,700
แต่ผมไม่ได้จำเป็นต้อง
ต้องยากรหัส 32

1464
01:12:22,700 --> 01:12:23,350
คุณรู้ไหมว่า?

1465
01:12:23,350 --> 01:12:26,350
ฉันสามารถ say-- ฉันไม่เคย
จำสิ่งที่แตกต่างกันคือ

1466
01:12:26,350 --> 01:12:29,330
>> แต่ฉันรู้ว่าถ้าผม
มีตัวอักษรกรณีที่ต่ำกว่า

1467
01:12:29,330 --> 01:12:34,430
ผมต้องการที่จะเป็นหลักลบออก
สิ่งที่ระยะห่างระหว่างเล็ก ๆ น้อย ๆ

1468
01:12:34,430 --> 01:12:39,160
และขนาดใหญ่เพราะถ้าฉันคิดว่า
ทั้งหมดของตัวอักษรอื่น ๆ เหมือนกัน

1469
01:12:39,160 --> 01:12:41,045
ที่ควรจะได้งานทำ

1470
01:12:41,045 --> 01:12:42,670
แต่แทนที่จะทำเช่นนั้นคุณรู้อะไรไหม

1471
01:12:42,670 --> 01:12:44,240
ยังคงมีวิธีอื่น

1472
01:12:44,240 --> 01:12:48,090
>> หากเป็นประโยชน์ 1.c-- ถ้าฉันเป็น
ที่จะนำที่เป็นไฟล์แยกต่างหาก

1473
01:12:48,090 --> 01:12:51,030
ขอทำประโยชน์ 2.c ดังต่อไปนี้

1474
01:12:51,030 --> 01:12:53,060
ฉันจะไปจริงๆทำความสะอาดนี้ขึ้นที่นี่

1475
01:12:53,060 --> 01:12:57,420
และแทนที่จะต้องมีการ
รู้หรือสนใจเกี่ยวกับระดับต่ำเหล่านั้น

1476
01:12:57,420 --> 01:13:01,090
รายละเอียดการดำเนินฉันแทน
เพียงแค่จะพิมพ์ตัวอักษร

1477
01:13:01,090 --> 01:13:04,610
อ้างนำมาอ้างร้อยละ C, และ
แล้วเรียกฟังก์ชั่นอื่นที่

1478
01:13:04,610 --> 01:13:09,950
อยู่ที่จะโต้แย้ง
ซึ่งเป็นตัวละครเช่นนี้

1479
01:13:09,950 --> 01:13:12,630
>> มันจะเปิดออกใน C มี
การเรียกใช้ฟังก์ชันอื่น

1480
01:13:12,630 --> 01:13:15,550
ไปบนซึ่งเป็นชื่อของมัน
แสดงให้เห็นตัวละครที่ใช้เวลา

1481
01:13:15,550 --> 01:13:19,350
และทำให้มันกับกรณีบนของ
เทียบเท่าแล้วส่งกลับไป

1482
01:13:19,350 --> 01:13:21,410
ดังนั้น printf ที่สามารถเสียบเข้าที่นั่น

1483
01:13:21,410 --> 01:13:25,484
และเพื่อที่จะทำเช่นนี้แม้ว่าฉัน
ต้องแนะนำหนึ่งไฟล์อื่น ๆ

1484
01:13:25,484 --> 01:13:28,400
มันจะเปิดออกมีไฟล์อื่น
ว่าคุณจะได้รู้จากชั้นเรียน

1485
01:13:28,400 --> 01:13:33,020
หรือตำราหรือออนไลน์
การอ้างอิงที่เรียกว่า type.h. C

1486
01:13:33,020 --> 01:13:38,570
>> ดังนั้นถ้าฉันจะเพิ่มขึ้นในหมู่หัวของฉัน
ไฟล์และตอนนี้รวบรวมอีกครั้งโปรแกรมนี้

1487
01:13:38,570 --> 01:13:43,040
capitalize2, ./capitalize2 ใส่

1488
01:13:43,040 --> 01:13:46,690
ลองพิมพ์ใน Zamyla ในทุก
ตัวพิมพ์เล็กยังคงทำงานเดียวกัน

1489
01:13:46,690 --> 01:13:48,040
แต่คุณรู้อะไรไหม

1490
01:13:48,040 --> 01:13:55,590
แต่กลับกลายเป็นว่าไปด้านบน
มีบางส่วนการทำงานอื่น ๆ

1491
01:13:55,590 --> 01:13:58,410
>> และแจ้งให้เราแนะนำนี้
คำสั่งที่นี่จัดเรียงของเชื่องช้า

1492
01:13:58,410 --> 01:14:00,250
ชื่อ แต่คนสำหรับคู่มือ

1493
01:14:00,250 --> 01:14:03,960
แต่กลับกลายเป็นว่าคอมพิวเตอร์ที่ใช้ Linux ที่สุด
ในขณะที่เรากำลังใช้ here-- ปฏิบัติการ

1494
01:14:03,960 --> 01:14:06,270
system-- มีคำสั่ง
เรียกว่าคนที่ว่า

1495
01:14:06,270 --> 01:14:08,530
Hey, คอมพิวเตอร์, ให้ฉัน
คู่มือของเครื่องคอมพิวเตอร์

1496
01:14:08,530 --> 01:14:10,680
คุณต้องการอะไร
ขึ้นไปดูในคู่มือที่?

1497
01:14:10,680 --> 01:14:13,840
>> ฉันต้องการที่จะมองขึ้นฟังก์ชั่น
เรียกตัวไปบนใส่

1498
01:14:13,840 --> 01:14:16,070
และมันก็เป็นความลับเล็ก ๆ น้อย ๆ
บางครั้งการอ่าน

1499
01:14:16,070 --> 01:14:18,780
แต่สังเกตเห็นเราอยู่ใน
คู่มือลินุกซ์โปรแกรมเมอร์

1500
01:14:18,780 --> 01:14:19,530
และมันก็เป็นทุกข้อความ

1501
01:14:19,530 --> 01:14:21,905
และแจ้งให้ทราบว่ามีเป็น
ชื่อของฟังก์ชันที่ขึ้นที่นี่

1502
01:14:21,905 --> 01:14:25,030
มันจะเปิดออกก็มีญาติที่เรียกว่า
เพื่อลดซึ่งจะตรงข้าม

1503
01:14:25,030 --> 01:14:29,710
และแจ้งให้ทราบภายใต้การสรุปที่จะใช้นี้
ทำงานหน้าคน, เพื่อที่จะพูด

1504
01:14:29,710 --> 01:14:32,220
จะบอกฉันว่าฉัน
ต้องรวม C type.h.

1505
01:14:32,220 --> 01:14:33,630
และผมรู้ว่าจากการปฏิบัติ

1506
01:14:33,630 --> 01:14:36,210
>> นี่ก็แสดงให้ฉันสอง
ต้นแบบสำหรับฟังก์ชั่น

1507
01:14:36,210 --> 01:14:39,070
เพื่อที่ว่าถ้าฉันเคยต้องการที่จะใช้นี้
ฉันรู้ว่าสิ่งที่พวกเขาใช้เป็น input

1508
01:14:39,070 --> 01:14:40,652
และสิ่งที่พวกเขากลับมาเป็นเอาท์พุท

1509
01:14:40,652 --> 01:14:42,360
แล้วถ้าผมอ่าน
คำอธิบายที่ฉันเห็น

1510
01:14:42,360 --> 01:14:44,820
ในรายละเอียดมากขึ้นสิ่งที่ทำงานไม่

1511
01:14:44,820 --> 01:14:48,100
แต่ที่สำคัญกว่าถ้า
ผมมองภายใต้ค่าตอบแทน

1512
01:14:48,100 --> 01:14:51,710
มันบอกว่าค่าที่ส่งกลับคือ
ของตัวอักษรที่แปลง

1513
01:14:51,710 --> 01:14:57,880
หรือ C, การป้อนข้อมูลเดิมถ้า
แปลงเป็นไปไม่ได้

1514
01:14:57,880 --> 01:15:01,992
>> ในคำอื่น ๆ ไปยังมุมบนจะพยายาม
การแปลงจดหมายถึงกรณีที่ส่วนบน

1515
01:15:01,992 --> 01:15:03,450
และถ้าเป็นเช่นนั้นก็จะกลับมา

1516
01:15:03,450 --> 01:15:07,010
แต่ถ้ามันไม่สามารถสำหรับบาง reason--
บางทีมันอาจจะเป็นกรณีบนแล้ว

1517
01:15:07,010 --> 01:15:09,550
บางทีมันอาจจะเป็นเครื่องหมายอัศเจรีย์
หรือบาง punctuation-- อื่น ๆ

1518
01:15:09,550 --> 01:15:12,200
มันเป็นเพียงแค่ไป
กลับ C เดิม

1519
01:15:12,200 --> 01:15:17,340
ซึ่งหมายความว่าฉันสามารถทำให้รหัสของฉัน
การออกแบบที่ดีขึ้นดังต่อไปนี้

1520
01:15:17,340 --> 01:15:20,580
>> ฉันไม่จำเป็นต้องทั้งหมดของ
เหล่านี้สายยี้รหัส

1521
01:15:20,580 --> 01:15:22,610
ทุกสายที่ผมได้
เพียงแค่ไฮไลต์สามารถ

1522
01:15:22,610 --> 01:15:28,700
จะทรุดลงเพียงหนึ่งง่าย
บรรทัดซึ่งเป็น this-- ร้อยละ printf

1523
01:15:28,700 --> 01:15:33,510
C ถึง S วงเล็บบนผม

1524
01:15:33,510 --> 01:15:36,090
และนี่จะเป็น
ตัวอย่างของการออกแบบที่ดีกว่า

1525
01:15:36,090 --> 01:15:40,040
>> ดำเนินการใน 7 หรือ 8 สายทำไม
ของรหัสสิ่งที่มันเป็นฉันเพียงแค่

1526
01:15:40,040 --> 01:15:44,960
ลบเมื่อคุณแทนสามารถยุบ
ทั้งหมดที่ตรรกะและการตัดสินใจ

1527
01:15:44,960 --> 01:15:49,620
เป็นสายเดียว 13 ตอนนี้ที่
อาศัยอยู่กับห้องสมุด function--

1528
01:15:49,620 --> 01:15:53,430
ฟังก์ชั่นที่มาพร้อมกับ C แต่ที่
ไม่ตรงกับสิ่งที่คุณต้องการจะทำ

1529
01:15:53,430 --> 01:15:55,295
และตรงไปตรงมาแม้ว่า
มันไม่ได้มาพร้อมกับ C,

1530
01:15:55,295 --> 01:15:58,880
คุณสามารถใช้มันด้วยตัวคุณเองเป็น
เราได้เห็นกับได้รับ int เชิงลบ

1531
01:15:58,880 --> 01:16:01,700
และได้รับในเชิงบวกในสัปดาห์ที่ผ่าน int เช่นกัน

1532
01:16:01,700 --> 01:16:03,470
>> รหัสนี้ในขณะนี้คืออ่านได้มากขึ้น

1533
01:16:03,470 --> 01:16:06,670
และแน่นอนถ้าเราเลื่อนขึ้น
ดูวิธีการที่มีขนาดกะทัดรัดมากขึ้น

1534
01:16:06,670 --> 01:16:08,360
รุ่นของโปรแกรมของฉันนี้

1535
01:16:08,360 --> 01:16:11,230
มันเป็นหนักบนเล็ก ๆ น้อย ๆ ในขณะนี้
ทั้งหมดเหล่านี้รวมถึง

1536
01:16:11,230 --> 01:16:14,380
แต่ที่ตกลงเพราะตอนนี้ฉันยืนอยู่
บนไหล่ของโปรแกรมเมอร์

1537
01:16:14,380 --> 01:16:15,300
ก่อนฉัน.

1538
01:16:15,300 --> 01:16:18,440
และใครก็ตามที่มันเป็นใคร
ดำเนินการเพื่อให้บนจริงๆ

1539
01:16:18,440 --> 01:16:21,470
ทำฉันหน่อยได้ไหมเหมือนใครก็ตาม
การดำเนินการของสเตอร์ลิงจริงๆ

1540
01:16:21,470 --> 01:16:24,790
ไม่ฉันชอบเวลาที่ผ่านมา

1541
01:16:24,790 --> 01:16:26,970
ดังนั้นตอนนี้เรามี
โปรแกรมออกแบบที่ดีกว่า

1542
01:16:26,970 --> 01:16:31,680
ที่ใช้ตรรกะเดียวกันแน่นอน

1543
01:16:31,680 --> 01:16:35,580
>> การพูดของสเตอร์ลิงให้
ฉันไปข้างหน้าและทำเช่นนี้

1544
01:16:35,580 --> 01:16:38,320
ให้ฉันไปข้างหน้าและบันทึก
แฟ้มนี้เป็น stirling.c

1545
01:16:38,320 --> 01:16:43,255
และมันจะเปิดออกเราสามารถลอกกลับ
ชั้นหนึ่งอื่นสวยเพียงแค่ตอนนี้

1546
01:16:43,255 --> 01:16:45,630
ฉันจะไปข้างหน้าและแส้
ขึ้นอีกโปรแกรมหนึ่งในหลัก

1547
01:16:45,630 --> 01:16:49,759
ที่นี่เป็นที่เรียบง่ายการดำเนินการอีกครั้ง
ความยาวสายดังต่อไปนี้

1548
01:16:49,759 --> 01:16:52,300
ดังนั้นนี่คือบรรทัดของรหัสที่
ได้รับฉันสตริงจากผู้ใช้

1549
01:16:52,300 --> 01:16:53,910
เราให้ใช้นี้อีกครั้งและอีกครั้ง

1550
01:16:53,910 --> 01:16:58,900
ผมขอให้ตัวเองที่เรียกว่าตัวแปร
n ชนิด int ที่เก็บตัวเลข

1551
01:16:58,900 --> 01:17:02,490
>> และแจ้งให้เราไปข้างหน้าและ
ทำตรรกะต่อไปนี้

1552
01:17:02,490 --> 01:17:15,610
ในขณะที่ตัวอักษร N-TH ใน s ไม่
ไม่เท่ากับ 0 ทับขวาไปข้างหน้า

1553
01:17:15,610 --> 01:17:17,930
และเพิ่มขึ้น n

1554
01:17:17,930 --> 01:17:23,506
แล้วพิมพ์ออกร้อยละ printf ฉัน n

1555
01:17:23,506 --> 01:17:29,200
ฉันเรียกร้องว่าโปรแกรมนี้ที่นี่
โดยไม่มีการเรียกความยาวสตริง

1556
01:17:29,200 --> 01:17:31,150
ตัวเลขออกมาตามความยาวของสตริง

1557
01:17:31,150 --> 01:17:34,600
>> และความมหัศจรรย์เป็นอย่างสิ้นเชิง
ห่อหุ้มในบรรทัดที่ 8

1558
01:17:34,600 --> 01:17:39,830
ที่นี่มีสิ่งที่ดูเหมือนว่าไวยากรณ์ใหม่
ทับขวานี้ 0 ในราคาเดียว

1559
01:17:39,830 --> 01:17:41,360
แต่ทำไมเป็นเช่นนั้น?

1560
01:17:41,360 --> 01:17:44,100
ดีพิจารณาสิ่งที่ได้รับ
ที่เกิดขึ้นทั้งหมดในขณะนี้

1561
01:17:44,100 --> 01:17:47,990
>> และเช่นกันก่อนที่ผมจะลืมตระหนัก
เกินไปว่านอกเหนือไปจากหน้าคน

1562
01:17:47,990 --> 01:17:50,920
ที่มาพร้อมกับโดยทั่วไป
ระบบ Linux เช่น CS50 IDE,

1563
01:17:50,920 --> 01:17:53,770
ตระหนักดีว่าเราที่
พนักงานของหลักสูตรมียัง

1564
01:17:53,770 --> 01:17:56,030
ทำรุ่นที่เว็บไซต์
ของความคิดเดียวกันนี้เรียกว่า

1565
01:17:56,030 --> 01:17:59,940
reference.cs50.net ซึ่งมี
ทุกคนหน้าคนเดียวกัน

1566
01:17:59,940 --> 01:18:02,020
ทุกเดียวกันกับที่
เอกสารเช่นเดียวกับ

1567
01:18:02,020 --> 01:18:05,730
กล่องเล็ก ๆ ที่ด้านบนที่ช่วยให้
คุณสามารถแปลงทุกอย่างเป็นธรรม

1568
01:18:05,730 --> 01:18:09,025
ภาษา Arcane เข้าน้อยสบาย
โหมดที่เราพนักงานการเรียนการสอน

1569
01:18:09,025 --> 01:18:12,150
ได้ผ่านและพยายามที่จะลดความซับซ้อน
บางส่วนของภาษาเพื่อให้สิ่งที่

1570
01:18:12,150 --> 01:18:14,830
มุ่งเน้นไปที่ความคิดและไม่ได้
บางส่วนของศัพท์

1571
01:18:14,830 --> 01:18:20,070
ดังนั้นเก็บไว้ในใจ reference.cs50.net
เป็นทรัพยากรอื่นได้เป็นอย่างดี

1572
01:18:20,070 --> 01:18:23,800
>> แต่ทำไมไม่ทำงานสตริง
วิธีการที่ผมนำเสนอช่วงเวลาที่ผ่านมา?

1573
01:18:23,800 --> 01:18:25,160
นี่คือชื่อ Zamyla อีกครั้ง

1574
01:18:25,160 --> 01:18:27,690
และนี่คือชื่อของ Zamyla
บรรจุกล่องในขณะที่ผมให้ทำ

1575
01:18:27,690 --> 01:18:31,360
การวาดภาพของมันถูก,
จริงๆเพียงลำดับของตัวอักษร

1576
01:18:31,360 --> 01:18:34,260
แต่ Zamyla ไม่อยู่
ในการแยกในโปรแกรม

1577
01:18:34,260 --> 01:18:37,420
>> เมื่อคุณเขียนและเรียกใช้โปรแกรม
คุณกำลังใช้ Mac หรือ PC ของคุณ

1578
01:18:37,420 --> 01:18:40,010
เป็นหน่วยความจำหรือแรมเพื่อที่จะพูด

1579
01:18:40,010 --> 01:18:42,620
และคุณอาจจะคิดว่า
คอมพิวเตอร์ของคุณมี

1580
01:18:42,620 --> 01:18:44,730
จำนวนมากกิกะไบต์หน่วยความจำวันนี้

1581
01:18:44,730 --> 01:18:47,700
และกิ๊กหมายถึงพันล้าน
ดังนั้นพันล้านไบต์

1582
01:18:47,700 --> 01:18:48,910
>> แต่ขอย้อนกลับในเวลาที่

1583
01:18:48,910 --> 01:18:51,530
และสมมติว่าเรากำลังใช้
คอมพิวเตอร์เก่าจริงๆว่า

1584
01:18:51,530 --> 01:18:55,150
มีเพียง 32 ไบต์ของหน่วยความจำ

1585
01:18:55,150 --> 01:18:59,310
ที่ฉันสามารถทำได้บนหน้าจอคอมพิวเตอร์ของฉัน
เพียงแค่วาดนี้ออกมาดังต่อไปนี้

1586
01:18:59,310 --> 01:19:05,240
>> ฉันก็อาจกล่าวได้ว่าฉัน
คอมพิวเตอร์มีทั้งหมดของหน่วยความจำนี้

1587
01:19:05,240 --> 01:19:08,830
และนี่ก็เหมือนติดของหน่วยความจำถ้า
คุณจำภาพของเราจากครั้งที่แล้ว

1588
01:19:08,830 --> 01:19:11,670
และถ้าฉันเพียงแค่แบ่ง
นี้ในช่วงเวลาที่เพียงพอ

1589
01:19:11,670 --> 01:19:15,040
ฉันเรียกร้องว่าฉันมี 32 ไบต์
ของหน่วยความจำบนหน้าจอ

1590
01:19:15,040 --> 01:19:18,239
>> ตอนนี้ในความเป็นจริงที่ฉันสามารถทำได้เพียง
วาดเพื่อให้ห่างไกลบนหน้าจอนี้ได้ที่นี่

1591
01:19:18,239 --> 01:19:20,280
ดังนั้นฉันจะไปข้างหน้า
และเพียงแค่การประชุม

1592
01:19:20,280 --> 01:19:24,050
วาดหน่วยความจำของคอมพิวเตอร์ของฉันเป็น
ตารางที่ไม่เพียง แต่เป็นหนึ่งในแนวเส้นตรง

1593
01:19:24,050 --> 01:19:28,190
โดยเฉพาะฉันเรียกร้องในขณะนี้ว่า
ตารางนี้นี้ 8 4 ตาราง

1594
01:19:28,190 --> 01:19:31,800
เพียงแสดงทั้งหมด 32 ไบต์
ของหน่วยความจำที่มีอยู่ในเครื่อง Mac ของฉัน

1595
01:19:31,800 --> 01:19:33,030
หรือที่มีอยู่ในเครื่องคอมพิวเตอร์ของฉัน

1596
01:19:33,030 --> 01:19:34,780
และพวกเขากำลังห่อ
ไปสองบรรทัดเพียง

1597
01:19:34,780 --> 01:19:38,030
เพราะมันพอดีมากขึ้นบนหน้าจอ

1598
01:19:38,030 --> 01:19:40,800
แต่นี้เป็นไบต์แรก

1599
01:19:40,800 --> 01:19:41,990
นี้เป็นครั้งที่สองไบต์

1600
01:19:41,990 --> 01:19:43,300
นี้เป็นไบต์ที่สาม

1601
01:19:43,300 --> 01:19:45,310
>> และนี่คือ 32 ไบต์

1602
01:19:45,310 --> 01:19:52,910
หรือถ้าเราคิดว่าเหมือนคอมพิวเตอร์
นักวิทยาศาสตร์นี้เป็นไบต์ 0, 1, 2, 3, 31

1603
01:19:52,910 --> 01:19:55,950
เพื่อให้คุณมี 0-31 ถ้า
คุณเริ่มนับที่ 0

1604
01:19:55,950 --> 01:19:59,830
>> ดังนั้นหากเราใช้โปรแกรม
ที่ได้รับการโทรสตริง

1605
01:19:59,830 --> 01:20:05,280
และเราได้รับสตริงจากมนุษย์
เหมือนผมเรียกว่า Zamyla, Z-A-M-Y-L-A

1606
01:20:05,280 --> 01:20:09,430
ว่าในโลกไม่
ติดตาม Computer เก็บของซึ่งไบต์

1607
01:20:09,430 --> 01:20:12,230
ซึ่งก้อนของหน่วยความจำ
เป็นของสตริง?

1608
01:20:12,230 --> 01:20:16,270
ในคำอื่น ๆ ถ้าเราดำเนินการต่อไป
พิมพ์ชื่ออื่นเข้ามาในเครื่องคอมพิวเตอร์

1609
01:20:16,270 --> 01:20:19,890
เช่นนี้แล้วล่ะเรียก
ได้รับสตริงเป็นครั้งที่สอง

1610
01:20:19,890 --> 01:20:23,030
A-N-D-I มีที่จะจบลงใน
หน่วยความจำของเครื่องคอมพิวเตอร์ได้เป็นอย่างดี

1611
01:20:23,030 --> 01:20:23,850
แต่อย่างไร

1612
01:20:23,850 --> 01:20:29,700
>> ดีก็ปรากฎว่าอยู่ภายใต้
เครื่องดูดควัน, C สิ่งที่ไม่เมื่อการจัดเก็บสตริง

1613
01:20:29,700 --> 01:20:35,080
ว่าประเภทของมนุษย์หรือว่า
มาจากแหล่งอื่น ๆ บางอย่างก็คือ

1614
01:20:35,080 --> 01:20:39,190
ให้สัตยาบันในตอนท้ายของพวกเขาด้วย
เครื่องหมาย character-- พิเศษ

1615
01:20:39,190 --> 01:20:44,750
0 ซึ่งเป็นเพียงวิธีพิเศษ
บอก 80 บิตในแถว

1616
01:20:44,750 --> 01:20:47,950
>> ดังนั้น A-- นี้คือการเรียกคืนจำนวน 97

1617
01:20:47,950 --> 01:20:51,770
ดังนั้นรูปแบบของ 8 บิตบาง
หมายถึงจำนวนทศนิยม 97

1618
01:20:51,770 --> 01:20:58,070
ทับขวา 0 เป็นอักษรจำนวน
0, NUL หรือที่เรียกว่า N-U-L ซึ่งแตกต่างจากก่อนหน้านี้

1619
01:20:58,070 --> 01:20:59,630
N-U-L-L ซึ่งเราพูดคุยเกี่ยวกับ

1620
01:20:59,630 --> 01:21:05,700
แต่สำหรับตอนนี้เพียงแค่รู้ว่านี้
ทับขวา 0 เป็นเพียง 80 บิตในแถว

1621
01:21:05,700 --> 01:21:09,810
>> และเป็นเพียงบรรทัดนี้ใน
เม็ดทรายที่ว่าอะไรไปทางซ้าย

1622
01:21:09,810 --> 01:21:12,610
เป็นหนึ่งสายหรือชนิดข้อมูลหนึ่ง

1623
01:21:12,610 --> 01:21:15,480
และสิ่งที่ไปทางขวา
เป็นอย่างอื่น

1624
01:21:15,480 --> 01:21:17,440
Andi ชื่อในขณะเดียวกัน
ซึ่งเพียงแค่สายตา

1625
01:21:17,440 --> 01:21:21,310
ที่เกิดขึ้นในการตัดไปสายอื่น ๆ ,
แต่นั่นเป็นเพียงรายละเอียดความงาม

1626
01:21:21,310 --> 01:21:23,990
ในทำนองเดียวกันคือ NUL สิ้นสุด

1627
01:21:23,990 --> 01:21:29,290
>> มันเป็นสตริงของตัวอักษร A-N-D-ฉัน,
บวกกับตัวละครลับที่ห้า

1628
01:21:29,290 --> 01:21:33,560
ทั้งหมด 0 บิตที่เพิ่ง demarcates
ท้ายชื่อของ Andi ได้เป็นอย่างดี

1629
01:21:33,560 --> 01:21:37,120
และถ้าเราได้รับโทรสตริงเป็นครั้งที่สาม
ในเครื่องคอมพิวเตอร์ที่จะได้รับเช่นสตริง

1630
01:21:37,120 --> 01:21:44,210
มาเรีย, M-A-R-I-A, ในทำนองเดียวกันคือมาเรีย
ชื่อ NUL สิ้นสุดลงด้วยเครื่องหมายทับขวา 0

1631
01:21:44,210 --> 01:21:47,170
>> นี่คือพื้นฐานที่แตกต่างกัน
จากวิธีการที่คอมพิวเตอร์จะมักจะ

1632
01:21:47,170 --> 01:21:51,850
เก็บจำนวนเต็มหรือลอยหรืออื่น ๆ
ชนิดข้อมูลยังคงเพราะการเรียกคืน

1633
01:21:51,850 --> 01:21:57,420
จำนวนเต็มมักจะเป็น 32 บิตหรือ
4 ไบต์หรือแม้กระทั่ง 64 บิต

1634
01:21:57,420 --> 01:21:59,100
หรือแปดไบต์

1635
01:21:59,100 --> 01:22:02,620
แต่หลายคนในวิทยาการคอมพิวเตอร์
ในการเขียนโปรแกรมภาษา

1636
01:22:02,620 --> 01:22:05,550
มีจำนวนคงที่ของ
ไบต์ใต้ hood--

1637
01:22:05,550 --> 01:22:08,100
บางทีที่ 1, 2 บางทีอาจจะ 4 อาจจะ 8

1638
01:22:08,100 --> 01:22:13,250
>> แต่สายโดยการออกแบบมี
จำนวนแบบไดนามิกของตัวละคร

1639
01:22:13,250 --> 01:22:16,980
คุณไม่ทราบล่วงหน้าจนกว่า
ประเภทของมนุษย์ใน Z-A-M-Y-L-A

1640
01:22:16,980 --> 01:22:21,400
หรือ M-A-R-I-A หรือ A-N-D-I คุณไม่ทราบว่า
กี่ครั้งที่ผู้ใช้จะได้ไปตี

1641
01:22:21,400 --> 01:22:22,070
คีย์บอร์ด.

1642
01:22:22,070 --> 01:22:26,490
ดังนั้นคุณไม่ทราบวิธีการ
ตัวอักษรหลายล่วงหน้า

1643
01:22:26,490 --> 01:22:27,540
คุณกำลังจะต้อง

1644
01:22:27,540 --> 01:22:31,840
>> และเพื่อให้ C เพียงแค่ชนิดของใบเช่น
แสดงเส้นทางลับใต้ฝากระโปรง

1645
01:22:31,840 --> 01:22:32,960
ในตอนท้ายของสตริง

1646
01:22:32,960 --> 01:22:39,280
หลังจากได้จัดเก็บ Z-A-M-Y-L-A ในหน่วยความจำ
มันก็เป็นเพียงแค่ทำให้เทียบเท่า

1647
01:22:39,280 --> 01:22:40,210
งวด

1648
01:22:40,210 --> 01:22:45,060
ในตอนท้ายของประโยค
มันทำให้ 80 บิตเพื่อให้เป็น

1649
01:22:45,060 --> 01:22:49,120
จำที่
Zamyla เริ่มต้นและสิ้นสุด

1650
01:22:49,120 --> 01:22:51,490
>> ดังนั้นสิ่งที่เชื่อมต่อ
แล้วโปรแกรมนี้?

1651
01:22:51,490 --> 01:22:55,190
โปรแกรมนี้ที่นี่สเตอร์ลิง
เป็นเพียงกลไก

1652
01:22:55,190 --> 01:22:57,970
สำหรับการรับสตริง
จากผู้ใช้ LINE 6

1653
01:22:57,970 --> 01:23:01,160
สาย 7 ผมประกาศตัวแปร
เรียกว่า n และตั้งค่าเท่ากับ 0

1654
01:23:01,160 --> 01:23:08,680
>> และจากนั้นในบรรทัดที่ 8 ผมก็ถาม
คำถามในขณะที่ตัวอักษร N-TH ไม่

1655
01:23:08,680 --> 01:23:12,120
ไม่เท่ากันทั้งหมด 0 bits--
ในคำอื่น ๆ ไม่ได้

1656
01:23:12,120 --> 01:23:14,500
เท่ากับพิเศษนี้
ตัวอักษรทับขวา 0 ซึ่ง

1657
01:23:14,500 --> 01:23:18,470
เป็นเพียงที่ character-- NUL พิเศษ
ไปข้างหน้าและเพิ่มขึ้นเพียง n

1658
01:23:18,470 --> 01:23:21,460
>> และให้ทำมันและให้
ทำมันและให้ทำมัน

1659
01:23:21,460 --> 01:23:23,430
และดังนั้นแม้ว่าใน
ที่ผ่านมาเราได้ใช้ผม

1660
01:23:23,430 --> 01:23:25,181
ก็ปรับได้อย่างสมบูรณ์แบบ
ความหมายที่จะใช้ N,

1661
01:23:25,181 --> 01:23:27,430
ถ้าคุณเพียงแค่พยายามที่จะ
นับเวลานี้จงใจ

1662
01:23:27,430 --> 01:23:28,720
และเพียงแค่ต้องการที่จะเรียกว่า n

1663
01:23:28,720 --> 01:23:34,720
ดังนั้นนี่เป็นเพียงแค่ช่วยถามคำถาม
เป็นตัวละครที่ N-TH ของ s 0s ทั้งหมดหรือไม่

1664
01:23:34,720 --> 01:23:38,470
ถ้าไม่ได้มองไปดูต่อไป
มองไปข้างหน้ามองไปข้างหน้า

1665
01:23:38,470 --> 01:23:39,460
มองไปข้างหน้า

1666
01:23:39,460 --> 01:23:45,540
>> แต่ทันทีที่คุณเห็นทับขวา 0,
ทางรถไฟสายนี้ loop-- 9 ถึงหยุด 11--

1667
01:23:45,540 --> 01:23:49,640
คุณทำลายออกจากวงในขณะที่
ออกจากด้านในของตัวแปรที่ n

1668
01:23:49,640 --> 01:23:54,530
จำนวนรวมทั้งหมดของ
ตัวอักษรในสตริงที่คุณเห็น

1669
01:23:54,530 --> 01:23:55,660
จึงพิมพ์มันออกมา

1670
01:23:55,660 --> 01:23:56,760
ดังนั้นขอลองนี้

1671
01:23:56,760 --> 01:23:59,500
>> ให้ฉันไปข้างหน้าและโดยไม่ต้อง
โดยใช้ฟังก์ชั่นสเตอร์ลิง

1672
01:23:59,500 --> 01:24:04,240
แต่เพียงแค่ใช้รุ่นพื้นบ้านของตัวเอง
เรียกว่าสเตอร์ลิงที่นี่ให้ฉันไปข้างหน้า

1673
01:24:04,240 --> 01:24:07,700
และเรียกใช้สเตอร์ลิงชนิดในบางสิ่งบางอย่าง
เช่น Zamyla ซึ่งผมทราบล่วงหน้า

1674
01:24:07,700 --> 01:24:08,670
เป็นหกตัวอักษร

1675
01:24:08,670 --> 01:24:10,080
ลองมาดูกันว่าการทำงาน

1676
01:24:10,080 --> 01:24:10,920
อันที่จริงมันเป็นหก

1677
01:24:10,920 --> 01:24:15,257
ลองกับร็อบสามตัวอักษร
ตัวละครทั้งสามเป็นอย่างดีและอื่น ๆ

1678
01:24:15,257 --> 01:24:17,340
ดังนั้นนั่นคือทั้งหมดที่เกิดขึ้น
ขึ้นภายใต้ฝากระโปรง

1679
01:24:17,340 --> 01:24:19,548
และแจ้งให้ทราบการเชื่อมต่อ,
แล้วกับสัปดาห์แรก

1680
01:24:19,548 --> 01:24:22,370
ของชั้นเรียนที่เราพูดคุยเกี่ยวกับ
สิ่งที่ต้องการนามธรรม

1681
01:24:22,370 --> 01:24:26,960
ซึ่งเป็นเพียงชั้นของความคิดนี้หรือ
ความซับซ้อนด้านบนของหลักการพื้นฐาน

1682
01:24:26,960 --> 01:24:30,710
นี่เรากำลังมองหาการเรียงลำดับของ
ใต้ฝากระโปรงของสเตอร์ลิง

1683
01:24:30,710 --> 01:24:33,510
เพื่อที่จะพูดจะคิดออก
วิธีการที่จะดำเนินการ?

1684
01:24:33,510 --> 01:24:35,232
>> และเราจะดำเนินการอีกครั้งมันเอง

1685
01:24:35,232 --> 01:24:37,440
แต่เราไม่เคยอีกครั้งไป
ใช้อีกครั้งสเตอร์ลิง

1686
01:24:37,440 --> 01:24:39,780
เรากำลังจะไป
สเตอร์ลิงใช้ในการสั่งซื้อ

1687
01:24:39,780 --> 01:24:42,100
ที่จะได้รับจริงบางสายยาว

1688
01:24:42,100 --> 01:24:44,200
>> แต่มีเวทมนตร์ไม่มี
ใต้ฝากระโปรง

1689
01:24:44,200 --> 01:24:46,716
ถ้าคุณรู้ว่าภายใต้
เครื่องดูดควัน, สตริง

1690
01:24:46,716 --> 01:24:48,090
เป็นเพียงลำดับของตัวอักษร

1691
01:24:48,090 --> 01:24:51,090
และลำดับของตัวอักษรที่
ทุกคนสามารถได้รับการแก้ไขตัวเลข

1692
01:24:51,090 --> 01:24:53,330
ด้วยวงเล็บ 0 วงเล็บ
1 วงเล็บ 2 และคุณ

1693
01:24:53,330 --> 01:24:57,420
รู้ว่าในตอนท้ายของสตริงเป็น
ตัวอักษรพิเศษที่คุณสามารถคิดออก

1694
01:24:57,420 --> 01:25:01,710
วิธีการทำอะไรมากที่สุดใน
โปรแกรมเพราะมันเดือดลงไป

1695
01:25:01,710 --> 01:25:03,400
คือการอ่านและการเขียนหน่วยความจำ

1696
01:25:03,400 --> 01:25:06,130
นั่นคือการเปลี่ยนแปลงและการมอง
ที่หน่วยความจำหรือการเคลื่อนย้ายสิ่ง

1697
01:25:06,130 --> 01:25:10,940
รอบ ๆ หน่วยความจำในสิ่งที่พิมพ์
บนหน้าจอและอื่น ๆ

1698
01:25:10,940 --> 01:25:14,800
>> ดังนั้นตอนนี้ขอใช้ที่เพิ่งค้นนี้
เข้าใจในสิ่งที่สตริงจริง

1699
01:25:14,800 --> 01:25:17,910
อยู่ใต้ฝากระโปรงและ
ปอกเปลือกกลับชั้นหนึ่งอื่น ๆ

1700
01:25:17,910 --> 01:25:20,080
ว่าจนถึงตอนนี้เราได้
ถูกละเลยโดยสิ้นเชิง

1701
01:25:20,080 --> 01:25:22,650
โดยเฉพาะอย่างยิ่งเวลาใดก็ได้
เราได้ดำเนินการโปรแกรม

1702
01:25:22,650 --> 01:25:25,930
ที่เราเคยมีบรรทัดของรหัสนี้
ใกล้หลักประกาศด้านบน

1703
01:25:25,930 --> 01:25:27,810
และเราได้ระบุไว้ int เป็นโมฆะหลัก

1704
01:25:27,810 --> 01:25:31,240
>> และนั่นถือเป็นโมฆะภายในวงเล็บ
มีรับการพูดตลอดเวลาว่าหลัก

1705
01:25:31,240 --> 01:25:33,440
ตัวเองไม่ได้ใช้ข้อโต้แย้งใด ๆ

1706
01:25:33,440 --> 01:25:36,210
ป้อนข้อมูลใด ๆ ที่สำคัญคือ
จะได้รับจากผู้ใช้

1707
01:25:36,210 --> 01:25:39,020
มีการมาจากบางส่วนอื่น ๆ
กลไกเช่นได้รับ int,

1708
01:25:39,020 --> 01:25:42,040
หรือได้รับลอยหรือได้รับสตริง
หรือบางฟังก์ชั่นอื่น ๆ

1709
01:25:42,040 --> 01:25:44,710
แต่มันกลับกลายเป็นว่า
เมื่อคุณเขียนโปรแกรม

1710
01:25:44,710 --> 01:25:47,690
คุณจริงสามารถระบุ
ว่าโปรแกรมนี้จะ

1711
01:25:47,690 --> 01:25:51,730
ใช้ปัจจัยการผลิตจากมนุษย์
ที่บรรทัดคำสั่งของตัวเอง

1712
01:25:51,730 --> 01:25:56,310
>> ในคำอื่น ๆ แม้ว่าเราป่านนี้
มีการทำงานเพียง ./hello สวัสดี

1713
01:25:56,310 --> 01:26:00,312
หรือโปรแกรมที่คล้ายกันทั้งหมดของ
โปรแกรมอื่น ๆ ที่เราได้รับใช้

1714
01:26:00,312 --> 01:26:02,770
ที่เราเองไม่ได้เขียน
ได้รับการดูเหมือนว่า

1715
01:26:02,770 --> 01:26:05,210
arguments-- บรรทัดคำสั่ง
สิ่งที่ต้องการให้

1716
01:26:05,210 --> 01:26:07,450
คุณบอกว่าสิ่งที่ชอบแต่งหน้า,
แล้วสองคำ

1717
01:26:07,450 --> 01:26:10,950
หรือเสียงดังกราวคุณพูดเสียงดังกราวแล้ว
คำที่สองชื่อของไฟล์

1718
01:26:10,950 --> 01:26:14,410
>> หรือแม้กระทั่ง RM หรือซีพีที่คุณอาจ
ได้เห็นหรือใช้แล้ว

1719
01:26:14,410 --> 01:26:15,880
จะลบหรือคัดลอกไฟล์

1720
01:26:15,880 --> 01:26:18,920
ทั้งหมดของผู้ใช้ที่เรียกว่า
arguments-- บรรทัดคำสั่ง

1721
01:26:18,920 --> 01:26:21,130
คำเพิ่มเติมที่พร้อมท์ขั้ว

1722
01:26:21,130 --> 01:26:23,260
แต่จนถึงขณะนี้เรา
ตัวเองไม่ได้

1723
01:26:23,260 --> 01:26:27,080
ความหรูหราของการป้อนข้อมูลจากนี้
ผู้ใช้เมื่อเขาหรือเธอจริงทำงาน

1724
01:26:27,080 --> 01:26:29,120
โปรแกรมเองที่บรรทัดคำสั่ง

1725
01:26:29,120 --> 01:26:33,710
>> แต่เราสามารถทำเช่นนั้นโดยการประกาศ
หลักก้าวไปข้างหน้าไม่ได้ว่ามี

1726
01:26:33,710 --> 01:26:36,750
ช่องว่างในวงเล็บ
แต่ทั้งสองมีปากเสียง

1727
01:26:36,750 --> 01:26:40,600
instead-- แรกจำนวนเต็ม
และบางสิ่งบางอย่างที่สอง

1728
01:26:40,600 --> 01:26:44,170
ใหม่สิ่งที่เรากำลังจะไปเรียก
อาร์เรย์สิ่งที่คล้ายกันในจิตวิญญาณ

1729
01:26:44,170 --> 01:26:49,220
กับสิ่งที่เราเห็นในรอยขีดข่วนเป็นรายการ แต่
อาร์เรย์ของสตริงที่เราจะเห็นทันที

1730
01:26:49,220 --> 01:26:51,790
แต่ขอดูนี้โดย
วิธีการเช่นก่อนที่เราจะ

1731
01:26:51,790 --> 01:26:53,690
แยกแยะว่าสิ่งที่หมายถึง

1732
01:26:53,690 --> 01:26:56,520
>> ดังนั้นถ้าฉันไปเป็น IDE CS50
ที่นี่ผมได้ไปข้างหน้า

1733
01:26:56,520 --> 01:27:01,840
และประกาศในไฟล์ที่เรียกว่า
argv0.c แม่แบบดังต่อไปนี้

1734
01:27:01,840 --> 01:27:04,120
และแจ้งให้ทราบเพียงสิ่งเดียว
ที่แตกต่างกันเพื่อให้ห่างไกล

1735
01:27:04,120 --> 01:27:08,570
คือการที่ฉันได้เปลี่ยนไปเป็นโมฆะ int
สตริง argc argv วงเล็บเปิดปิด

1736
01:27:08,570 --> 01:27:09,070
วงเล็บ

1737
01:27:09,070 --> 01:27:11,730
และแจ้งให้ทราบตอนนี้มี
ไม่มีอะไรที่อยู่ภายในวงเล็บเหล่านั้น

1738
01:27:11,730 --> 01:27:12,620
>> มีจำนวนไม่ได้

1739
01:27:12,620 --> 01:27:15,070
และไม่มีผมหรือ
N, หรือตัวอักษรอื่น ๆ

1740
01:27:15,070 --> 01:27:17,010
ฉันแค่ใช้
วงเล็บสำหรับตอนนี้

1741
01:27:17,010 --> 01:27:19,510
สำหรับเหตุผลที่เราจะมา
กลับไปในเวลาเพียงสักครู่

1742
01:27:19,510 --> 01:27:21,330
>> และตอนนี้สิ่งที่ผมจะทำคือการนี​​้

1743
01:27:21,330 --> 01:27:26,680
ถ้า argc เท่ากับเท่ากับ 2--
และจำได้ว่าเท่ากับเท่ากับ

1744
01:27:26,680 --> 01:27:30,040
เป็นผู้ดำเนินการเปรียบเทียบความเสมอภาค
ด้านซ้ายและขวาเพื่อความเท่าเทียมกัน

1745
01:27:30,040 --> 01:27:31,790
มันไม่ได้เป็นที่ได้รับมอบหมาย
ผู้ประกอบการซึ่งเป็น

1746
01:27:31,790 --> 01:27:36,510
เครื่องหมายเท่ากับเดียวซึ่งหมายถึงการคัดลอก
จากขวาไปซ้ายค่าบางอย่าง

1747
01:27:36,510 --> 01:27:42,840
>> ถ้า argc เท่ากับเท่ากับ 2 ผมต้องการที่จะ
พูด printf สวัสดีร้อยละบรรทัดใหม่

1748
01:27:42,840 --> 01:27:47,340
แล้วเสียบ in-- และนี่คือใหม่
trick-- argv วงเล็บ 1 สำหรับเหตุผล

1749
01:27:47,340 --> 01:27:48,840
ว่าเราจะกลับมาในช่วงเวลาที่

1750
01:27:48,840 --> 01:27:52,110
อื่นถ้า argc ไม่
เท่ากับ 2 คุณรู้อะไรไหม

1751
01:27:52,110 --> 01:27:57,400
ขอเพียงไปข้างหน้าและตามปกติการพิมพ์
ออก Hello World โดยไม่มีการเปลี่ยนตัว

1752
01:27:57,400 --> 01:28:02,710
>> ดังนั้นก็จะดูเหมือนว่าถ้า argc ซึ่ง
ยืนสำหรับการนับอาร์กิวเมนต์เท่ากับ 2

1753
01:28:02,710 --> 01:28:04,740
ฉันจะพิมพ์ออกมา
สวัสดีหรือสิ่งอื่น ๆ

1754
01:28:04,740 --> 01:28:07,560
มิฉะนั้นโดยค่าเริ่มต้นผม
จะพิมพ์ Hello World

1755
01:28:07,560 --> 01:28:08,770
ดังนั้นสิ่งนี้หมายความว่าอย่างไร

1756
01:28:08,770 --> 01:28:15,550
>> ดีให้ฉันไปข้างหน้าและบันทึก
ไฟล์นี้แล้วจะทำให้ argv0,

1757
01:28:15,550 --> 01:28:18,940
แล้ว ./argv0 ใส่

1758
01:28:18,940 --> 01:28:20,300
และกล่าวว่า Hello World

1759
01:28:20,300 --> 01:28:21,260
ตอนนี้ทำไมเป็นเช่นนั้น?

1760
01:28:21,260 --> 01:28:24,730
>> ดีก็จะเปิดออกตลอดเวลาที่คุณ
เรียกใช้โปรแกรมที่บรรทัดคำสั่ง

1761
01:28:24,730 --> 01:28:29,570
คุณกำลังกรอกข้อมูลในสิ่งที่เราจะ
โดยทั่วไปเรียกเวกเตอร์อาร์กิวเมนต์

1762
01:28:29,570 --> 01:28:33,100
ในคำอื่น ๆ โดยอัตโนมัติ
คอมพิวเตอร์ระบบปฏิบัติการ

1763
01:28:33,100 --> 01:28:38,340
เป็นไปมือเพื่อโปรแกรมของคุณ
ตัวเองรายการทั้งหมดของคำว่า

1764
01:28:38,340 --> 01:28:40,850
ว่ามนุษย์ที่พิมพ์
พรอมต์ในกรณีที่คุณ

1765
01:28:40,850 --> 01:28:43,790
โปรแกรมเมอร์ต้องการที่จะทำ
บางสิ่งบางอย่างที่มีข้อมูลว่า

1766
01:28:43,790 --> 01:28:48,540
และในกรณีนี้คำเดียว
ผมเคยพิมพ์ที่พรอมต์เป็น ./argv0

1767
01:28:48,540 --> 01:28:55,420
>> และดังนั้นจำนวนของการขัดแย้งที่มีอยู่
ถูกส่งผ่านไปยังโปรแกรมของฉันเป็นเพียงหนึ่ง

1768
01:28:55,420 --> 01:28:58,880
ในคำอื่น ๆ การโต้แย้ง
นับหรือที่เรียกว่า argc

1769
01:28:58,880 --> 01:29:00,970
ที่นี่เป็นจำนวนเต็มเป็นเพียงหนึ่ง

1770
01:29:00,970 --> 01:29:03,000
หนึ่งของหลักสูตรไม่เท่ากับสอง

1771
01:29:03,000 --> 01:29:05,980
ดังนั้นนี่คือสิ่งที่พิมพ์สวัสดีโลก

1772
01:29:05,980 --> 01:29:08,170
>> แต่ให้ฉันใช้เวลานี้อยู่ที่ไหนสักแห่ง

1773
01:29:08,170 --> 01:29:09,930
ให้ฉันบอกว่า argv0

1774
01:29:09,930 --> 01:29:12,740
แล้ววิธีการเกี่ยวกับมาเรีย?

1775
01:29:12,740 --> 01:29:14,990
แล้วกด Enter

1776
01:29:14,990 --> 01:29:18,020
>> และสังเกตเห็นสิ่งที่น่าอัศจรรย์ที่เกิดขึ้นที่นี่

1777
01:29:18,020 --> 01:29:22,640
ตอนนี้แทนที่จะโลกสวัสดีฉันมี
การเปลี่ยนแปลงพฤติกรรมของโปรแกรมนี้

1778
01:29:22,640 --> 01:29:26,310
โดยการป้อนข้อมูลที่ไม่ได้มาจากการได้รับ
สตริงหรือบางฟังก์ชั่นอื่น ๆ

1779
01:29:26,310 --> 01:29:30,570
แต่จากเห็นได้ชัดว่าคำสั่งของฉัน
ตัวเองในสิ่งที่ฉันเดิมที่พิมพ์ลงใน

1780
01:29:30,570 --> 01:29:35,720
และผมสามารถเล่นเกมนี้อีกครั้งโดย
เปลี่ยนไป Stelios ตัวอย่างเช่น

1781
01:29:35,720 --> 01:29:38,400
>> และตอนนี้ผมเห็นชื่ออื่นยังคง

1782
01:29:38,400 --> 01:29:40,540
และที่นี่ผมอาจจะพูดล่ะ

1783
01:29:40,540 --> 01:29:42,137
และผมอาจจะบอกว่า Zamyla

1784
01:29:42,137 --> 01:29:45,220
และเราสามารถเล่นเกมนี้ได้นานตลอดวัน
เพียงแค่เสียบค่าที่แตกต่างกัน

1785
01:29:45,220 --> 01:29:49,550
ตราบใดที่ผมให้ตรง
คำสองคำที่พรอมต์

1786
01:29:49,550 --> 01:29:52,260
เช่นที่ argc นับอาร์กิวเมนต์ของฉันคือ 2

1787
01:29:52,260 --> 01:29:57,240
>> ฉันเห็นว่าชื่อเสียบเข้า
printf ต่อสภาพนี้ที่นี่?

1788
01:29:57,240 --> 01:30:00,550
ดังนั้นเราจึงดูเหมือนจะมีในขณะนี้
ความสามารถในการแสดงออก

1789
01:30:00,550 --> 01:30:04,410
ของการใช้ข้อมูลจากกลไกอื่น
จากบรรทัดคำสั่งที่เรียกว่า

1790
01:30:04,410 --> 01:30:07,000
แทนที่จะต้องรอ
จนกว่าผู้ใช้รันโปรแกรม

1791
01:30:07,000 --> 01:30:10,220
แล้วแจ้งให้เขาหรือเธอ
ใช้สิ่งที่ต้องการสตริง

1792
01:30:10,220 --> 01:30:11,230
>> ดังนั้นสิ่งนี้คืออะไร?

1793
01:30:11,230 --> 01:30:15,010
argc อีกครั้งเป็นเพียงจำนวนเต็ม
จำนวน words-- arguments--

1794
01:30:15,010 --> 01:30:18,540
ที่ผู้ใช้บริการที่มีให้ที่
พรอมต์ที่หน้าต่าง terminal,

1795
01:30:18,540 --> 01:30:20,110
รวมทั้งชื่อของโปรแกรม

1796
01:30:20,110 --> 01:30:23,340
ดังนั้น ./argv0 ของเราคือการมีประสิทธิภาพ
ชื่อของโปรแกรม

1797
01:30:23,340 --> 01:30:24,520
หรือวิธีการที่ฉันเรียกใช้โปรแกรม

1798
01:30:24,520 --> 01:30:25,810
>> ที่นับว่าเป็นคำ

1799
01:30:25,810 --> 01:30:27,080
ดังนั้น argc จะเป็น 1

1800
01:30:27,080 --> 01:30:29,750
แต่เมื่อผมเขียน Stelios หรือ
Andi หรือ Zamyla หรือมาเรีย

1801
01:30:29,750 --> 01:30:31,660
นั่นหมายความว่านับอาร์กิวเมนต์เป็นสอง

1802
01:30:31,660 --> 01:30:33,910
และอื่น ๆ ตอนนี้มีสองคำผ่าน

1803
01:30:33,910 --> 01:30:36,070
>> และแจ้งให้ทราบเราสามารถดำเนินการต่อตรรกะนี้

1804
01:30:36,070 --> 01:30:39,050
ถ้าผมพูดจริง
สิ่งที่ต้องการ Zamyla จัน

1805
01:30:39,050 --> 01:30:42,200
ชื่อเต็มจึงผ่าน
สามข้อโต้แย้งในทั้งหมด

1806
01:30:42,200 --> 01:30:47,410
ตอนนี้ก็บอกว่าเริ่มต้นอีกครั้ง
เพราะของหลักสูตร 3 ไม่เท่ากับ 2

1807
01:30:47,410 --> 01:30:54,080
>> และอื่น ๆ ในลักษณะนี้ทำฉันมี
การเข้าถึงผ่านทาง argv โต้เถียงครั้งใหม่นี้

1808
01:30:54,080 --> 01:30:56,080
ที่เราจะได้ในทางเทคนิค
เรียกสิ่งที่เราต้องการ

1809
01:30:56,080 --> 01:30:58,940
แต่โดยการประชุมก็
และ argv argc ตามลำดับ

1810
01:30:58,940 --> 01:31:04,470
argv อาร์กิวเมนต์เวกเตอร์เป็นชนิด
ของคำพ้องสำหรับการเขียนโปรแกรมเป็น

1811
01:31:04,470 --> 01:31:07,140
คุณลักษณะใน C เรียกว่าอาร์เรย์

1812
01:31:07,140 --> 01:31:14,410
>> อาร์เรย์คือรายการของค่าที่คล้ายกัน
กลับไปกลับไปกลับไปด้านหลัง

1813
01:31:14,410 --> 01:31:17,810
ในคำอื่น ๆ หากมีที่นี่ใน
RAM, หนึ่งต่อไปอยู่ติดกับมัน

1814
01:31:17,810 --> 01:31:18,800
และขวาถัดไป

1815
01:31:18,800 --> 01:31:20,101
พวกเขาไม่ได้ทั่วทุกสถานที่

1816
01:31:20,101 --> 01:31:23,100
และสถานการณ์หลังสิ่งที่
มีทั่วทุกสถานที่ในหน่วยความจำ

1817
01:31:23,100 --> 01:31:25,082
จริงอาจจะเป็นคุณลักษณะที่มีประสิทธิภาพ

1818
01:31:25,082 --> 01:31:28,040
แต่เราจะกลับมาที่ว่าเมื่อเรา
พูดคุยเกี่ยวกับโครงสร้างข้อมูลนักเล่น

1819
01:31:28,040 --> 01:31:32,260
สำหรับตอนนี้อาร์เรย์เป็นเพียง
หน่วยความจำอันต่อเนื่องกัน

1820
01:31:32,260 --> 01:31:36,520
แต่ละซึ่งเป็นธาตุ
กลับไปกลับไปกลับไปกลับ

1821
01:31:36,520 --> 01:31:38,050
และโดยทั่วไปประเภทเดียวกัน

1822
01:31:38,050 --> 01:31:42,630
>> ดังนั้นหากคุณคิดเกี่ยวกับการจาก
ช่วงเวลาที่ผ่านมาสิ่งที่เป็นสตริง?

1823
01:31:42,630 --> 01:31:50,460
ดีสตริงเช่น Zamyla,
Z-A-M-Y-L-เป็นเทคนิค

1824
01:31:50,460 --> 01:31:51,400
เพียงอาร์เรย์

1825
01:31:51,400 --> 01:31:53,700
มันเป็นอาร์เรย์ของตัวอักษร

1826
01:31:53,700 --> 01:31:59,250
>> ดังนั้นถ้าเราวาดนี้ที่ผม
ก่อนหน้านี้ไม่เป็นก้อนของหน่วยความจำ

1827
01:31:59,250 --> 01:32:04,510
มันกลับกลายเป็นว่าแต่ละเหล่านี้
ตัวละครจะขึ้นไบต์

1828
01:32:04,510 --> 01:32:07,630
แล้วมีที่พิเศษ
ตัวละคร Sentinel, เครื่องหมาย 0,

1829
01:32:07,630 --> 01:32:12,360
หรือทั้งหมดแปด 0 บิตที่
demarcates ปลายสายว่า

1830
01:32:12,360 --> 01:32:15,090
ดังนั้นสตริงก็จะเปิด
ออกมาพูดนำมาอ้างสตริง,

1831
01:32:15,090 --> 01:32:20,580
เป็นเพียงอาร์เรย์ของ chara--
ถ่านเป็นชนิดข้อมูลที่เกิดขึ้นจริง

1832
01:32:20,580 --> 01:32:24,560
>> และตอนนี้ argv, meanwhile--
ขอกลับไปที่โปรแกรม

1833
01:32:24,560 --> 01:32:29,582
argv แม้ว่าเราจะเห็นคำว่า
สตริงที่นี่ไม่เป็นสตริงตัวเอง

1834
01:32:29,582 --> 01:32:33,640
argv อาร์กิวเมนต์เวกเตอร์
เป็นอาร์เรย์ของสตริง

1835
01:32:33,640 --> 01:32:37,620
>> ดังนั้นเพียงแค่เท่าที่คุณสามารถมีอาร์เรย์ของ
ตัวอักษรที่คุณสามารถมีระดับที่สูงขึ้น

1836
01:32:37,620 --> 01:32:46,279
อาร์เรย์ของ strings-- เพื่อตัวอย่างเช่น
เมื่อฉันพิมพ์สักครู่ที่ผ่านมา ./argv0

1837
01:32:46,279 --> 01:33:00,150
argv0 พื้นที่ Z-A-M-Y-L-ผมอ้างว่า
argv มีสองสายใน ./argv0 it--,

1838
01:33:00,150 --> 01:33:03,185
และ Z-A-M-Y-L-A ใน
คำอื่น ๆ argc 2

1839
01:33:03,185 --> 01:33:03,980
ทำไมเป็นเช่นนั้น?

1840
01:33:03,980 --> 01:33:08,370
>> ดีอย่างมีประสิทธิภาพสิ่งที่เกิดขึ้น
ก็คือว่าแต่ละสายเหล่านี้

1841
01:33:08,370 --> 01:33:13,990
เป็นของหลักสูตรอาร์เรย์ของตัวอักษร
เมื่อก่อนแต่ละที่มีตัวอักษร

1842
01:33:13,990 --> 01:33:15,670
ใช้เวลาถึงหนึ่งไบต์

1843
01:33:15,670 --> 01:33:19,720
และไม่สร้างความสับสนให้เกิดขึ้นจริง 0
ในชื่อของโปรแกรมที่มี 0,

1844
01:33:19,720 --> 01:33:22,040
ซึ่งหมายความว่าทุก 80 บิต

1845
01:33:22,040 --> 01:33:27,140
และ Zamyla ขณะที่ยังคง
ยังมีอาร์เรย์ของตัวอักษร

1846
01:33:27,140 --> 01:33:31,450
>> ดังนั้นในตอนท้ายของวันนั้นจริงๆ
ลักษณะเช่นนี้อยู่ภายใต้ฝากระโปรง

1847
01:33:31,450 --> 01:33:38,800
แต่ argv โดยธรรมชาติของวิธีการหลัก
งานช่วยให้ฉันไปห่อทั้งหมดนี้

1848
01:33:38,800 --> 01:33:44,810
ขึ้นไปถ้าคุณจะเป็นอาร์เรย์ที่ใหญ่กว่า
ว่าถ้าเราลดความซับซ้อนน้อยกว่า

1849
01:33:44,810 --> 01:33:48,180
สิ่งที่ภาพดูชอบและไม่
วาดมันค่อนข้างที่จะไต่ขึ้นมี

1850
01:33:48,180 --> 01:33:56,720
อาร์เรย์นี้เป็นเพียงขนาด 2 เป็นครั้งแรก
องค์ประกอบของการที่มีสตริง

1851
01:33:56,720 --> 01:33:59,230
องค์ประกอบที่สองของ
ซึ่งมีสตริง

1852
01:33:59,230 --> 01:34:01,687
และในทางกลับกันถ้าคุณ
ชนิดของการซูมในแต่ละ

1853
01:34:01,687 --> 01:34:03,770
ของสตริงเหล่านั้นสิ่งที่คุณ
ดูใต้ฝากระโปรง

1854
01:34:03,770 --> 01:34:07,190
คือการที่แต่ละสายเป็นเพียง
อาร์เรย์ของตัวละคร

1855
01:34:07,190 --> 01:34:11,680
>> ตอนนี้เช่นเดียวกับสตริง
เราสามารถที่จะได้รับการเข้าถึง

1856
01:34:11,680 --> 01:34:15,260
ไปที่ตัวอักษร I-TH ในสตริง
โดยใช้สัญกรณ์วงเล็บเหลี่ยม

1857
01:34:15,260 --> 01:34:17,320
ในทำนองเดียวกันกับอาร์เรย์
โดยทั่วไปเราสามารถ

1858
01:34:17,320 --> 01:34:22,700
ใช้สัญกรณ์วงเล็บเหลี่ยมที่จะได้รับ
ที่บ้านเลขที่ใด ๆ ของสตริงในอาร์เรย์?

1859
01:34:22,700 --> 01:34:25,100
ยกตัวอย่างให้ฉัน
ไปข้างหน้าและทำเช่นนี้

1860
01:34:25,100 --> 01:34:32,420
>> ให้ฉันไปข้างหน้าและสร้าง argv1.c,
ซึ่งเป็นที่แตกต่างกันเล็ก ๆ น้อย ๆ ในเวลานี้

1861
01:34:32,420 --> 01:34:35,635
แทนการตรวจสอบสำหรับ argc2,
ฉันจะทำเช่นนี้แทน

1862
01:34:35,635 --> 01:34:41,270
สำหรับ int ฉันได้รับ 0 ผมน้อย
กว่า argc ผมบวกบวก

1863
01:34:41,270 --> 01:34:47,920
แล้วพิมพ์ออกมาภายในนี้
ร้อยละ S, บรรทัดใหม่แล้ว

1864
01:34:47,920 --> 01:34:50,740
argv วงเล็บฉัน

1865
01:34:50,740 --> 01:34:55,220
>> ดังนั้นในคำอื่น ๆ ผมไม่ได้ติดต่อกับ
อักขระแต่ละตัวในขณะนี้

1866
01:34:55,220 --> 01:35:00,190
argv เป็นนัยเหล่านี้ตารางที่ว่างเปล่า
วงเล็บด้านขวาของชื่อ argv ที่

1867
01:35:00,190 --> 01:35:03,320
หมายความ argv เป็นอาร์เรย์ของสตริง

1868
01:35:03,320 --> 01:35:04,870
และ argc เป็นเพียง int

1869
01:35:04,870 --> 01:35:08,800
>> บรรทัดนี้ที่นี่ 6, มี
บอกว่าผมตั้งค่าเท่ากับ 0

1870
01:35:08,800 --> 01:35:11,980
นับตลอดทางขึ้นไป,
แต่ไม่รวม argc

1871
01:35:11,980 --> 01:35:14,010
และจากนั้นในแต่ละซ้ำ,
พิมพ์สตริง

1872
01:35:14,010 --> 01:35:14,800
อะไรสตริง?

1873
01:35:14,800 --> 01:35:17,270
>> สตริง I-TH ใน argv

1874
01:35:17,270 --> 01:35:19,530
ดังนั้นในขณะที่ก่อนผมเป็น
โดยใช้วงเล็บเหลี่ยม

1875
01:35:19,530 --> 01:35:22,180
สัญกรณ์ที่จะได้รับที่ i
ตัวละครในสตริงในขณะนี้

1876
01:35:22,180 --> 01:35:27,240
ฉันใช้สัญกรณ์วงเล็บสี่เหลี่ยม
ที่จะได้รับสตริงที่ i ในอาร์เรย์

1877
01:35:27,240 --> 01:35:30,310
ดังนั้นมันจึงเป็นชนิดของชั้นหนึ่ง
ข้างต้นแนวคิด

1878
01:35:30,310 --> 01:35:35,390
>> และเพื่อให้สิ่งที่เรียบร้อยเกี่ยวกับเรื่องนี้
โปรแกรมตอนนี้ถ้าผมรวบรวม argv1,

1879
01:35:35,390 --> 01:35:42,067
แล้วทำ ./argv1 และจากนั้นพิมพ์
ในสิ่งที่ต้องการ foo บาร์ Baz,

1880
01:35:42,067 --> 01:35:45,400
ซึ่งเป็นคำสามคำเริ่มต้นว่า
นักวิทยาศาสตร์คอมพิวเตอร์ถึงเวลาใด ๆ

1881
01:35:45,400 --> 01:35:51,010
เขาหรือเธอต้องการคำยึดบางส่วน
และกด Enter แต่ละคำพูดเหล่านั้น

1882
01:35:51,010 --> 01:35:54,980
รวมทั้งชื่อของโปรแกรมซึ่ง
อยู่ใน argv ที่สถานที่แรก

1883
01:35:54,980 --> 01:35:58,320
จบลงด้วยการถูกพิมพ์ในช่วงเวลาหนึ่ง

1884
01:35:58,320 --> 01:36:05,290
และถ้าผมเปลี่ยนนี้และผมบอกว่า
สิ่งที่ต้องการ argv1 Zamyla จัน

1885
01:36:05,290 --> 01:36:08,800
เราได้รับทั้งสามของคนเหล่านั้น
คำซึ่งเป็น argv0,

1886
01:36:08,800 --> 01:36:14,400
argv1, argv2 เพราะในนี้
กรณี argc นับเป็น 3

1887
01:36:14,400 --> 01:36:20,020
>> แต่สิ่งที่เรียบร้อยคือถ้าคุณเข้าใจ
argv ที่เป็นเพียงอาร์เรย์ของสตริง,

1888
01:36:20,020 --> 01:36:24,910
และคุณเข้าใจว่าสตริง
เป็นอาร์เรย์ของตัวอักษร,

1889
01:36:24,910 --> 01:36:29,470
เราสามารถจริงชนิดของการใช้นี้
สัญกรณ์วงเล็บเหลี่ยมหลายครั้ง

1890
01:36:29,470 --> 01:36:33,320
ให้เลือกสตริงและจากนั้นเลือก
ตัวละครภายในสตริง,

1891
01:36:33,320 --> 01:36:35,730
ดำน้ำลึกดังต่อไปนี้

1892
01:36:35,730 --> 01:36:40,100
ในตัวอย่างนี้ให้ฉันไป
ไปข้างหน้าและเรียก argv2.c นี้

1893
01:36:40,100 --> 01:36:43,920

1894
01:36:43,920 --> 01:36:50,180
และในตัวอย่างนี้ให้ฉันไปข้างหน้า
และทำ following-- สำหรับ int ฉันได้รับ 0,

1895
01:36:50,180 --> 01:36:53,286
ฉันมีค่าน้อยกว่า argc ผมบวก
บวกเหมือนเมื่อก่อน

1896
01:36:53,286 --> 01:36:55,910
ดังนั้นใน words-- อื่น ๆ และตอนนี้
จะได้รับความซับซ้อนพอ

1897
01:36:55,910 --> 01:36:59,940
แล้วฉันจะบอกว่า
ย้ำกว่าสตริงใน argv,

1898
01:36:59,940 --> 01:37:01,294
เป็นความคิดเห็นกับตัวเอง

1899
01:37:01,294 --> 01:37:03,960
แล้วฉันจะมี
สำหรับวงซ้อนกันซึ่งคุณอาจ

1900
01:37:03,960 --> 01:37:06,290
ได้กระทำหรือการพิจารณา
ทำในรอยขีดข่วนที่

1901
01:37:06,290 --> 01:37:08,600
ฉันจะบอกว่าฉัน int--
ไม่ได้ไปใช้ผมอีกครั้ง

1902
01:37:08,600 --> 01:37:12,590
เพราะผมไม่ต้องการที่จะเงาหรือ
การเรียงลำดับของการเขียนทับที่ผมมีอยู่

1903
01:37:12,590 --> 01:37:15,780
>> ฉันจะแทนที่จะพูด J เพราะ
ที่ไปของฉันให้กับตัวแปรหลังจากที่ฉัน,

1904
01:37:15,780 --> 01:37:18,590
เมื่อฉันแค่พยายามที่จะ
นับตัวเลขที่เรียบง่าย

1905
01:37:18,590 --> 01:37:28,850
เจได้รับ 0-- และยัง N, เป็นไปได้
ได้รับความยาวท้าย argv วงเล็บผม

1906
01:37:28,850 --> 01:37:36,030
ตราบใดที่ J น้อยกว่าเมตร
J บวกบวกทำต่อไปนี้

1907
01:37:36,030 --> 01:37:37,500
และนี่คือส่วนที่น่าสนใจ

1908
01:37:37,500 --> 01:37:46,330
>> พิมพ์ออกมาเป็นตัวอักษรและสายใหม่
เสียบในว​​งเล็บ argv I, J วงเล็บ

1909
01:37:46,330 --> 01:37:47,940
ตกลงเพื่อให้ฉันเพิ่มความคิดเห็นบางอย่างที่นี่

1910
01:37:47,940 --> 01:37:54,820
ย้ำผ่านตัวอักษร
ในสตริงปัจจุบัน

1911
01:37:54,820 --> 01:38:02,290
ตัวอักษรพิมพ์ที่ j ในสตริง I-TH

1912
01:38:02,290 --> 01:38:04,630
ดังนั้นตอนนี้ขอพิจารณา
สิ่งเหล่านี้หมายถึงการแสดงความคิดเห็น

1913
01:38:04,630 --> 01:38:06,750
>> ย้ำกว่าสตริง
ใน argv-- หลายวิธี

1914
01:38:06,750 --> 01:38:09,300
สตริงอยู่ใน argv ซึ่งเป็นอาร์เรย์?

1915
01:38:09,300 --> 01:38:13,420
argc จำนวนมากดังนั้นฉันทำซ้ำ
จาก i เท่ากับ 0 ถึง argc

1916
01:38:13,420 --> 01:38:20,020
ในขณะที่จำนวนตัวอักษร
อยู่ในสตริง I-TH ใน argv?

1917
01:38:20,020 --> 01:38:22,880
>> ดีจะได้คำตอบว่า
ฉันเพียงแค่เรียกความยาวสาย

1918
01:38:22,880 --> 01:38:26,810
ในการดูแลผมในปัจจุบันสตริง
เกี่ยวกับซึ​​่งเป็นวงเล็บ argv ฉัน

1919
01:38:26,810 --> 01:38:30,090
และฉันจะเก็บชั่วคราวที่
ค่าใน N, เพียงเพื่อแคช

1920
01:38:30,090 --> 01:38:31,590
จะจำมันได้อย่างมีประสิทธิภาพ

1921
01:38:31,590 --> 01:38:36,330
แล้วฉันจะเริ่มต้น J 0
ให้ไปตราบ J น้อยกว่า N,

1922
01:38:36,330 --> 01:38:38,430
และในแต่ละซ้ำเพิ่ม J

1923
01:38:38,430 --> 01:38:41,030
>> และจากนั้นในที่นี่ต่อ
ความคิดเห็นของฉันในบรรทัดที่ 12

1924
01:38:41,030 --> 01:38:43,390
พิมพ์ตัวอักษร
ตามมาด้วยการขึ้นบรรทัดใหม่,

1925
01:38:43,390 --> 01:38:48,140
วงเล็บ argv เฉพาะ
ฉันให้ฉันสตริง I-TH

1926
01:38:48,140 --> 01:38:51,690
ใน argv-- ดังนั้นคำแรกที่
คำสองคำที่สามสิ่ง

1927
01:38:51,690 --> 01:38:57,370
แล้วดำน้ำใน J ลึกและได้รับ
ฉันเป็นตัวละครที่ j ของคำว่า

1928
01:38:57,370 --> 01:39:02,200
และเพื่อให้มีผลบังคับใช้คุณสามารถรักษา
argv เป็นหลายมิติ

1929
01:39:02,200 --> 01:39:06,050
เป็นสองมิติอาร์เรย์
โดยทุกชนิดทุกคำของรูปลักษณ์

1930
01:39:06,050 --> 01:39:08,580
เช่นนี้ในใจของคุณ
ตาและตัวละครทุกตัว

1931
01:39:08,580 --> 01:39:10,930
ประกอบด้วยชนิดของใน
คอลัมน์ว่าจะช่วย

1932
01:39:10,930 --> 01:39:13,260
>> ในความเป็นจริงเมื่อเราหยอกล้อ
นี้ออกจากกันในสัปดาห์ที่ผ่านมาในอนาคต

1933
01:39:13,260 --> 01:39:15,580
มันจะเป็นเพียงเล็กน้อย
ที่มีความซับซ้อนมากขึ้นกว่าที่

1934
01:39:15,580 --> 01:39:17,800
แต่คุณสามารถจริงๆ
คิดว่าตอนนี้

1935
01:39:17,800 --> 01:39:22,110
เป็นเพียงแค่นี้สองมิติ
อาร์เรย์โดยหนึ่งระดับของมัน

1936
01:39:22,110 --> 01:39:23,260
คือทั้งหมดของสตริง

1937
01:39:23,260 --> 01:39:26,760
แล้วถ้าคุณดำน้ำในลึกคุณ
จะได้รับตัวละครแต่ละคน

1938
01:39:26,760 --> 01:39:29,600
นั้นโดยใช้สัญกรณ์นี้ได้ที่นี่

1939
01:39:29,600 --> 01:39:31,620
>> ดังนั้นสิ่งที่เป็นผลกระทบสุทธิ?

1940
01:39:31,620 --> 01:39:34,970
ให้ฉันไปข้างหน้าและ
ทำให้ยี้ argv2-- มัน

1941
01:39:34,970 --> 01:39:36,210
ฉันทำผิดพลาดที่นี่

1942
01:39:36,210 --> 01:39:40,160
ประกาศโดยปริยาย
ห้องสมุดสเตอร์ลิงฟังก์ชั่น

1943
01:39:40,160 --> 01:39:42,190
ดังนั้นเวลานี้มันเป็น
บางทีอาจจะเหมาะสม

1944
01:39:42,190 --> 01:39:45,130
ที่เรากำลังจัดเรียงของการตกแต่ง
ตรงที่เราเริ่มต้น

1945
01:39:45,130 --> 01:39:48,160
>> ฉันเมาขึ้นโดยปริยายประกาศ
ห้องสมุดสเตอร์ลิงฟังก์ชั่น

1946
01:39:48,160 --> 01:39:48,987
ตกลงรอสักครู่

1947
01:39:48,987 --> 01:39:51,070
ผมจำได้ว่าโดยเฉพาะอย่างยิ่ง
เพราะมันเป็นสิทธิที่นี่

1948
01:39:51,070 --> 01:39:54,490
ฉันต้องการที่จะรวมในสตริง
รุ่นของโปรแกรมนี้

1949
01:39:54,490 --> 01:40:00,050
>> ให้ฉันไปข้างหน้าและรวมถึง
สตริงบันทึกที่ไปข้างหน้า

1950
01:40:00,050 --> 01:40:04,460
และคอมไพล์ argv2

1951
01:40:04,460 --> 01:40:08,390
และตอนนี้ที่นี่เราไปให้ argv2 ใส่

1952
01:40:08,390 --> 01:40:10,590
และแม้ว่ามันจะเป็นเพียงเล็กน้อย
คลุมเครืออย่างรวดเร็วก่อน

1953
01:40:10,590 --> 01:40:15,690
แจ้งให้ทราบว่าแน่นอนสิ่งที่
จะมีการพิมพ์เป็นจุด argv2

1954
01:40:15,690 --> 01:40:19,970
>> แต่ถ้าผมพิมพ์คำบางคำหลัง
พรอมต์เช่น argv2 Zamyla จัน

1955
01:40:19,970 --> 01:40:22,560
ใส่ยังเล็ก ๆ น้อย ๆ
คลุมเครืออย่างรวดเร็วก่อน

1956
01:40:22,560 --> 01:40:30,540
แต่ถ้าเราเลื่อนกลับขึ้น
./argv2 Z-A-M-Y-L-C-H-A-N

1957
01:40:30,540 --> 01:40:32,190
ดังนั้นเราจึงได้ซ้ำมากกว่าทุกคำ

1958
01:40:32,190 --> 01:40:37,770
และในทางกลับกันเราได้ซ้ำมากกว่า
ตัวละครทุกตัวที่อยู่ในคำ

1959
01:40:37,770 --> 01:40:40,040
>> ตอนนี้หลังจากที่ทั้งหมดนี้
ตระหนักดีว่ามี

1960
01:40:40,040 --> 01:40:43,120
หนึ่งในรายละเอียดอื่น ๆ ที่เราได้รับชนิด
ไม่สนใจตลอดเวลานี้

1961
01:40:43,120 --> 01:40:46,180
เราเพียงแค่แกล้งนอกเหนือสิ่งที่
ปัจจัยการผลิตหลักสามารถ?

1962
01:40:46,180 --> 01:40:47,780
สิ่งที่เกี่ยวกับการส่งออกหลักของ?

1963
01:40:47,780 --> 01:40:50,540
>> ทั้งหมดเวลานี้เราได้รับ
เพียงคัดลอกและวาง

1964
01:40:50,540 --> 01:40:53,870
int ตัวคำในด้านหน้าของหลัก
แม้ว่าคุณอาจจะเห็นออนไลน์

1965
01:40:53,870 --> 01:40:58,340
บางครั้งไม่ถูกต้องในรุ่นเก่า
ตัว C และตัวคอมไพเลอร์ที่พวกเขากล่าวว่าเป็นโมฆะ

1966
01:40:58,340 --> 01:40:59,410
หรืออะไรเลย

1967
01:40:59,410 --> 01:41:01,580
แต่ที่จริงแล้วสำหรับรุ่น
ของซีที่เรากำลังใช้อยู่

1968
01:41:01,580 --> 01:41:06,180
C 11 หรือ 2011 ตระหนักถึง
ที่มันควรจะเป็น int

1969
01:41:06,180 --> 01:41:09,300
และมันทั้งที่ควรจะเป็น
เป็นโมฆะหรือ argc และ argv ที่นี่

1970
01:41:09,300 --> 01:41:10,790
>> แต่ทำไม int main?

1971
01:41:10,790 --> 01:41:12,480
มันคืออะไรจริงกลับมา?

1972
01:41:12,480 --> 01:41:16,280
ดีก็จะเปิดออกทั้งหมดของเวลานี้
เวลาที่คุณได้เขียนโปรแกรมหลัก

1973
01:41:16,280 --> 01:41:18,440
อยู่เสมอบางสิ่งบางอย่างกลับมา

1974
01:41:18,440 --> 01:41:19,960
แต่จะได้รับการทำเช่นนั้นแอบ

1975
01:41:19,960 --> 01:41:23,350
>> สิ่งที่เป็น
int เป็นสาย 5 แสดงให้เห็น

1976
01:41:23,350 --> 01:41:24,225
แต่สิ่งที่ int?

1977
01:41:24,225 --> 01:41:26,100
ดีมีนี้
การประชุมในการเขียนโปรแกรม

1978
01:41:26,100 --> 01:41:29,790
ด้วยเหตุนี้ถ้าไม่มีอะไรมี
ผิดไปและทั้งหมดเป็นอย่างดี

1979
01:41:29,790 --> 01:41:34,250
โปรแกรมและฟังก์ชั่นทั่วไป
return-- ค่อนข้าง counterintuitively--

1980
01:41:34,250 --> 01:41:35,230
0

1981
01:41:35,230 --> 01:41:38,070
0 โดยทั่วไปหมายถึงทั้งหมดเป็นอย่างดี

1982
01:41:38,070 --> 01:41:40,610
ดังนั้นแม้ว่าคุณคิดว่าการ
ว่ามันเป็นเท็จในบริบทที่หลาย ๆ

1983
01:41:40,610 --> 01:41:42,930
มันจริงโดยทั่วไปหมายถึงเป็นสิ่งที่ดี

1984
01:41:42,930 --> 01:41:49,560
>> ในขณะเดียวกันถ้าโปรแกรมผลตอบแทนที่ 1
หรือติดลบ 1 หรือ 5 หรือเชิงลบ 42,

1985
01:41:49,560 --> 01:41:52,941
หรือใด ๆ ที่ไม่ใช่ 0 ค่า
ซึ่งโดยทั่วไปหมายถึง

1986
01:41:52,941 --> 01:41:54,190
สิ่งที่ได้ไปผิด

1987
01:41:54,190 --> 01:41:56,700
ในความเป็นจริงบน Mac ของคุณเองหรือพีซี
คุณอาจได้เห็นจริง

1988
01:41:56,700 --> 01:42:01,050
ข้อผิดพลาดโดยมัน
พูดอะไรบางอย่างหรืออื่น ๆ ที่มีข้อผิดพลาด

1989
01:42:01,050 --> 01:42:04,940
รหัสเชิงลบ 42 หรือรหัสข้อผิดพลาด
23 หรือสิ่งที่ต้องการ

1990
01:42:04,940 --> 01:42:08,980
ตัวเลขที่โดยทั่วไปเพียงคำใบ้
โปรแกรมเมอร์หรือ บริษัท

1991
01:42:08,980 --> 01:42:11,174
ที่ทำให้ซอฟแวร์
สิ่งที่ผิดพลาดและทำไม

1992
01:42:11,174 --> 01:42:13,590
เพื่อให้พวกเขาสามารถมองผ่าน
เอกสารหรือรหัสของพวกเขา

1993
01:42:13,590 --> 01:42:15,465
และคิดออกว่า
ข้อผิดพลาดจริงหมายถึง

1994
01:42:15,465 --> 01:42:18,400
จึงมักไม่
ประโยชน์กับเราผู้ใช้ปลายทาง

1995
01:42:18,400 --> 01:42:20,550
>> แต่เมื่อผลตอบแทนหลัก 0 ทั้งหมดเป็นอย่างดี

1996
01:42:20,550 --> 01:42:23,770
และถ้าคุณไม่ได้ระบุ
สิ่งหลักควรกลับ

1997
01:42:23,770 --> 01:42:26,950
มันจะเป็นเพียงแค่โดยอัตโนมัติ
กลับ 0 สำหรับคุณ

1998
01:42:26,950 --> 01:42:30,870
แต่บางสิ่งบางอย่างกลับมา
อื่นจะเป็นประโยชน์จริง

1999
01:42:30,870 --> 01:42:34,660
>> ในโปรแกรมสุดท้ายนี้ให้ฉัน
ไปข้างหน้าและเรียก exit.c นี้

2000
01:42:34,660 --> 01:42:38,630
และแนะนำสุดท้ายของวันนี้
หัวข้อที่รู้จักกันเป็นรหัสข้อผิดพลาด

2001
01:42:38,630 --> 01:42:42,930
ให้ฉันไปข้างหน้าและรวมของเรา
ไฟล์ที่คุ้นเคยขึ้นด้านบนทำ int main

2002
01:42:42,930 --> 01:42:49,500
และในครั้งนี้เราจะมาทำ argc int,
สตริง argv และมีวงเล็บของฉัน

2003
01:42:49,500 --> 01:42:50,836
ที่จะบ่งบอกว่ามันเป็นในอาร์เรย์

2004
01:42:50,836 --> 01:42:52,460
แล้วให้ฉันเพียงแค่จะตรวจสอบสุขภาพจิตดี

2005
01:42:52,460 --> 01:42:56,640
เวลานี้ถ้า argc ไม่
เท่ากับ 2 แล้วคุณรู้อะไรไหม

2006
01:42:56,640 --> 01:42:57,520
ลืมมันไปเถอะ

2007
01:42:57,520 --> 01:43:03,170
ผมกำลังจะบอกว่าเดี๋ยวก่อนผู้ใช้
คุณจะหายไปอาร์กิวเมนต์บรรทัดคำสั่ง

2008
01:43:03,170 --> 01:43:04,210
ทับขวา n

2009
01:43:04,210 --> 01:43:05,230
>> แล้วที่มัน

2010
01:43:05,230 --> 01:43:06,130
ฉันต้องการที่จะออกจาก

2011
01:43:06,130 --> 01:43:11,030
ฉันจะไป preemptively,
และก่อนเวลาอันควรจริงๆกลับมา

2012
01:43:11,030 --> 01:43:12,810
สิ่งอื่นที่ไม่ใช่หมายเลข 1

2013
01:43:12,810 --> 01:43:15,360
ไปที่คุ้มค่าสำหรับครั้งแรก
ข้อผิดพลาดที่อาจเกิดขึ้นได้คือ 1

2014
01:43:15,360 --> 01:43:17,860
ถ้าคุณมีบางอย่างผิดพลาดอื่น ๆ
สถานการณ์ที่อาจเกิดขึ้น

2015
01:43:17,860 --> 01:43:21,390
คุณอาจจะบอกว่าผลตอบแทนที่ 2 หรือ 3 กลับมาหรือ
แม้กระทั่งในเชิงลบหรือเชิงลบ 1 2

2016
01:43:21,390 --> 01:43:23,750
>> เหล่านี้เป็นเพียงรหัสออก
ที่มีทั่วไป

2017
01:43:23,750 --> 01:43:27,770
เพียง แต่มีประโยชน์ในการเขียนโปรแกรมหรือ
บริษัท ที่จัดส่งซอฟแวร์

2018
01:43:27,770 --> 01:43:30,500
แต่ความจริงที่ว่ามันเป็น
ไม่ 0 เป็นสิ่งที่สำคัญ

2019
01:43:30,500 --> 01:43:34,310
ดังนั้นหากในโปรแกรมนี้ผมต้องการที่จะ
รับประกันได้ว่าโปรแกรมนี้เท่านั้น

2020
01:43:34,310 --> 01:43:38,190
ทำงานหากผู้ใช้ให้ฉัน
ด้วยการนับโต้แย้งของทั้งสอง

2021
01:43:38,190 --> 01:43:42,880
ชื่อของโปรแกรมและอื่น ๆ
คำว่าฉันสามารถบังคับใช้มากที่สุดเท่าที่ดังต่อไปนี้

2022
01:43:42,880 --> 01:43:46,110
เสียงโห่ร้องที่ผู้ใช้ที่มีคำกล่าวที่ว่า printf,
อาร์กิวเมนต์บรรทัดคำสั่งที่ขาดหายไป

2023
01:43:46,110 --> 01:43:46,970
กลับ 1

2024
01:43:46,970 --> 01:43:49,940
ที่จะเป็นเพียงแค่การได้ทันที
ออกจากโปรแกรม

2025
01:43:49,940 --> 01:43:55,840
>> เฉพาะในกรณีที่ argc เท่ากับ 2 เราจะได้รับการลง
ที่นี่จุดที่ผมจะพูดว่า

2026
01:43:55,840 --> 01:44:00,410
สวัสดีร้อยละ S, ทับขวา N, argv1

2027
01:44:00,410 --> 01:44:03,827
ในคำอื่น ๆ ฉัน
ไม่ได้ไปหลังจาก argv 0,

2028
01:44:03,827 --> 01:44:05,410
ซึ่งเป็นเพียงแค่ชื่อของโปรแกรม

2029
01:44:05,410 --> 01:44:09,450
ฉันต้องการที่จะพิมพ์ออกมาสวัสดีจุลภาค
คำที่สองที่มนุษย์พิมพ์

2030
01:44:09,450 --> 01:44:12,580
และในกรณีนี้
บรรทัดที่ 13 ทั้งหมดเป็นอย่างดี

2031
01:44:12,580 --> 01:44:15,920
>> ฉันรู้ว่า argc คือ 2
เหตุผลจากโปรแกรมนี้

2032
01:44:15,920 --> 01:44:17,770
ฉันจะไปข้างหน้าและย้อนกลับ 0

2033
01:44:17,770 --> 01:44:21,230
เช่นกันเก็บไว้ในใจว่า
นี้เป็นจริงในรอยขีดข่วนได้เป็นอย่างดี

2034
01:44:21,230 --> 01:44:24,760
>> เหตุผลที่ฉันจะทำเช่นนี้
และห่อหุ้มเส้นเหล่านี้

2035
01:44:24,760 --> 01:44:27,020
ของรหัสในข้ออื่น ๆ ได้ที่นี่

2036
01:44:27,020 --> 01:44:29,420
แต่นั่นคือการเรียงลำดับของ
โดยไม่จำเป็นเยื้องรหัสของฉัน

2037
01:44:29,420 --> 01:44:31,800
และฉันต้องการที่จะทำให้สุด
เห็นได้ชัดว่าไม่ว่าอะไรจะเกิดขึ้น

2038
01:44:31,800 --> 01:44:34,670
โดยค่าเริ่มต้นทักทาย
สิ่งที่จะได้รับการพิมพ์,

2039
01:44:34,670 --> 01:44:36,050
ตราบใดที่ผู้ใช้ให้ความร่วมมือ

2040
01:44:36,050 --> 01:44:39,360
>> ดังนั้นจึงเป็นเรื่องธรรมดามากที่จะใช้
เงื่อนไขเพียงถ้า

2041
01:44:39,360 --> 01:44:41,870
ที่จะจับความผิดพลาดบางอย่าง
สถานการณ์แล้วออกจาก

2042
01:44:41,870 --> 01:44:45,690
แล้วตราบทั้งหมด
ดีไม่ได้มีอะไร

2043
01:44:45,690 --> 01:44:48,060
แต่เพียงแค่มีรหัส
นอกว่าถ้าเพราะมัน

2044
01:44:48,060 --> 01:44:51,060
เทียบเท่าในครั้งนี้
โดยเฉพาะอย่างยิ่งกรณีที่มีเหตุผล

2045
01:44:51,060 --> 01:44:54,480
ดังนั้นฉันกลับ 0, เพียงเพื่อ
มีความหมายอย่างชัดเจนทั้งหมดเป็นอย่างดี

2046
01:44:54,480 --> 01:44:58,480
>> ถ้าผมละเว้นผลตอบแทน 0, มันจะ
สันนิษฐานได้โดยอัตโนมัติสำหรับฉัน

2047
01:44:58,480 --> 01:45:00,890
แต่ตอนนี้ที่ฉันกลับมา
หนึ่งในอย่างน้อยกรณีนี้

2048
01:45:00,890 --> 01:45:04,940
ฉันจะไป, การวัดที่ดีและ
ความชัดเจนผลตอบแทน 0 ในกรณีนี้

2049
01:45:04,940 --> 01:45:09,690
ดังนั้นตอนนี้ให้ฉันไปข้างหน้าและให้ออก
ซึ่งเป็นที่สมบูรณ์แบบเพื่อทำต่อเพียงแค่ปล่อยให้

2050
01:45:09,690 --> 01:45:14,401
>> แต่ให้ออกและปล่อยให้ฉันไป
ข้างหน้าและทำ ./exit ใส่

2051
01:45:14,401 --> 01:45:16,900
และโปรแกรมที่ตะโกนใส่ฉัน
อาร์กิวเมนต์บรรทัดคำสั่งที่ขาดหายไป

2052
01:45:16,900 --> 01:45:18,120
ตกลงให้ฉันให้ความร่วมมือ

2053
01:45:18,120 --> 01:45:23,810
>> ขอให้ฉันแทนทำ ./exit เดวิดใส่

2054
01:45:23,810 --> 01:45:25,190
และตอนนี้ก็พูดว่าสวัสดีเดวิด

2055
01:45:25,190 --> 01:45:27,300
และคุณจะไม่ปกติเห็นนี้

2056
01:45:27,300 --> 01:45:30,650
>> แต่ปรากฎว่ามี
วิธีพิเศษในลินุกซ์ที่จะเห็นจริง

2057
01:45:30,650 --> 01:45:34,470
กับสิ่งที่รหัสออกจากโปรแกรมออก

2058
01:45:34,470 --> 01:45:37,184
บางครั้งในแบบกราฟิก
โลกเช่น Mac OS หรือ Windows,

2059
01:45:37,184 --> 01:45:40,100
คุณจะเห็นตัวเลขเหล่านี้เมื่อมีการ
ข้อผิดพลาดปรากฏขึ้นบนหน้าจอ

2060
01:45:40,100 --> 01:45:41,940
และโปรแกรมเมอร์
แสดงให้คุณเห็นตัวเลขที่

2061
01:45:41,940 --> 01:45:44,773
แต่ถ้าเราต้องการที่จะเห็นสิ่งที่เกิดข้อผิดพลาด
ข้อความคือเราสามารถทำมันได้ here--

2062
01:45:44,773 --> 01:45:48,100
./exit ดังนั้นใส่พิมพ์
อาร์กิวเมนต์บรรทัดคำสั่งที่ขาดหายไป

2063
01:45:48,100 --> 01:45:54,590
>> ถ้าตอนนี้ฉันทำ echo $ ?, ซึ่งเป็น
ขัน​​มองคลุมเครือ

2064
01:45:54,590 --> 01:45:56,590
แต่ $?

2065
01:45:56,590 --> 01:45:59,220
เป็นคาถาที่มีมนต์ขลัง
ที่บอกว่าเดี๋ยวก่อนคอมพิวเตอร์

2066
01:45:59,220 --> 01:46:01,900
บอกฉันว่าก่อนหน้านี้
รหัสออกจากโปรแกรมเป็น

2067
01:46:01,900 --> 01:46:03,410
และฉันกด Enter

2068
01:46:03,410 --> 01:46:07,520
ฉันเห็น 1 เพราะนั่นคือสิ่งที่ฉัน
บอกว่าฟังก์ชั่นหลักของฉันจะกลับมา

2069
01:46:07,520 --> 01:46:12,310
>> ในขณะเดียวกันถ้าฉันทำ ./exit ดาวิด
และกด Enter ผมเห็นสวัสดีเดวิด

2070
01:46:12,310 --> 01:46:16,800
และถ้าตอนนี้ผมทำ $ Echo ?, ฉันเห็นสวัสดี 0

2071
01:46:16,800 --> 01:46:19,080
และอื่น ๆ นี้จะจริง
จะเป็นข้อมูลที่มีคุณค่า

2072
01:46:19,080 --> 01:46:23,420
ในบริบทของการดีบักที่ไม่ได้ดังนั้น
มากที่คุณมนุษย์ที่จะดูแล

2073
01:46:23,420 --> 01:46:26,060
แต่การดีบักเกอร์และอื่น ๆ
โปรแกรมเราจะใช้ภาคการศึกษานี้

2074
01:46:26,060 --> 01:46:29,420
มักจะดูที่จำนวนที่
แม้ว่ามันจะซ่อนการจัดเรียงของออกไป

2075
01:46:29,420 --> 01:46:32,780
เว้นแต่คุณจะมองหามันเพื่อ
กำหนดหรือไม่โปรแกรมของ

2076
01:46:32,780 --> 01:46:37,050
การดำเนินการถูกต้องหรือไม่ถูกต้อง

2077
01:46:37,050 --> 01:46:40,450
>> และเพื่อที่จะนำเราไป
นี้ในตอนท้ายของวัน

2078
01:46:40,450 --> 01:46:43,917
เราเริ่มต้นในวันนี้โดยมองไปที่
แก้จุดบกพร่องและในทางกลับที่แน่นอน

2079
01:46:43,917 --> 01:46:46,750
ตัวเองแล้วน่าสนใจมากขึ้น
ในทางเทคนิคที่อยู่ใต้ฝากระโปรง

2080
01:46:46,750 --> 01:46:49,490
สิ่งที่สตริงซึ่งมีอายุ
สัปดาห์เราก็เอาให้ได้รับ,

2081
01:46:49,490 --> 01:46:51,900
และแน่นอนเอาพวกเขา
สำหรับการรับในรอยขีดข่วน

2082
01:46:51,900 --> 01:46:56,040
>> จากนั้นเราจะมองไปที่วิธีการที่เราสามารถเข้าถึง
ตัวละครแต่ละตัวในสตริง

2083
01:46:56,040 --> 01:47:00,310
และจากนั้นอีกครั้งเอาระดับที่สูงขึ้น
ดูสิ่งที่มองหาวิธี well--

2084
01:47:00,310 --> 01:47:04,226
ถ้าเราต้องการที่จะได้รับของแต่ละบุคคล
องค์ประกอบในรายการเช่นโครงสร้าง

2085
01:47:04,226 --> 01:47:05,850
เราไม่สามารถทำเช่นนั้นกับสตริงหลาย

2086
01:47:05,850 --> 01:47:08,050
และเราสามารถมีข้อโต้แย้งบรรทัดคำสั่ง

2087
01:47:08,050 --> 01:47:12,800
แต่ภาพนี้ที่นี่เพียงกล่อง
เป็นชี้ของความคิดทั่วไปนี้

2088
01:47:12,800 --> 01:47:14,451
ของอาร์เรย์หรือรายการหรือเวกเตอร์

2089
01:47:14,451 --> 01:47:16,450
และขึ้นอยู่กับ
บริบททั้งหมดของคำเหล่านี้

2090
01:47:16,450 --> 01:47:17,880
หมายถึงสิ่งที่แตกต่างกันเล็กน้อย

2091
01:47:17,880 --> 01:47:20,060
ดังนั้นใน C เราเพียงจะ
พูดคุยเกี่ยวกับอาร์เรย์

2092
01:47:20,060 --> 01:47:23,840
และอาร์เรย์เป็นก้อน
ของหน่วยความจำแต่ละคนเป็น

2093
01:47:23,840 --> 01:47:27,720
องค์ประกอบที่ต่อเนื่องกันกลับ
ไปกลับไปกลับไปด้านหลัง

2094
01:47:27,720 --> 01:47:31,970
>> และองค์ประกอบเหล่านั้นโดยทั่วไป
ประเภทข้อมูลเดียวกันตัวละคร

2095
01:47:31,970 --> 01:47:35,966
ตัวละครตัวละครตัวละครหรือ
สตริงสตริงสตริงสตริงหรือ int,

2096
01:47:35,966 --> 01:47:38,600
int, int สิ่งที่เป็น
เรากำลังพยายามที่จะเก็บ

2097
01:47:38,600 --> 01:47:42,540
แต่ในตอนท้ายของวันนี้เป็น
สิ่งที่ดูเหมือนว่าแนวคิด

2098
01:47:42,540 --> 01:47:44,530
คุณกำลังการของคุณ
หน่วยความจำของคอมพิวเตอร์หรือ RAM

2099
01:47:44,530 --> 01:47:48,590
และคุณแกะสลักมันออกไป
กล่องขนาดเหมือนกันซึ่งทั้งหมดนี้

2100
01:47:48,590 --> 01:47:50,920
จะกลับไปกลับไป
กลับไปด้านหลังในลักษณะนี้

2101
01:47:50,920 --> 01:47:53,200
>> และสิ่งที่ดีเกี่ยวกับ
ความคิดนี้และความจริงที่

2102
01:47:53,200 --> 01:47:58,580
ที่เราสามารถแสดงค่าในลักษณะนี้
กับครั้งแรกของโครงสร้างข้อมูลของเรา

2103
01:47:58,580 --> 01:48:02,520
ในชั้นเรียน, หมายความว่าเราสามารถเริ่มต้น
ในการแก้ปัญหาด้วยรหัส

2104
01:48:02,520 --> 01:48:04,079
ที่มาเพื่อให้สังหรณ์ใจในสัปดาห์ 0

2105
01:48:04,079 --> 01:48:05,870
คุณจะจำโทรศัพท์
ตัวอย่างหนังสือที่

2106
01:48:05,870 --> 01:48:09,110
ที่เราใช้ในการแบ่งและพิชิต
หรือการค้นหาแบบทวิภาค,

2107
01:48:09,110 --> 01:48:13,220
ที่จะลอดผ่านทั้งหมด
พวงของชื่อและหมายเลข

2108
01:48:13,220 --> 01:48:18,220
แต่เราสันนิษฐานว่าจำว่า
สมุดโทรศัพท์ถูกเรียงไว้แล้ว

2109
01:48:18,220 --> 01:48:21,630
ว่าคนอื่นได้แล้ว
คิดได้รับ out-- รายชื่อ

2110
01:48:21,630 --> 01:48:24,430
และเบอร์วิธีการเรียงตามลำดับอักษร

2111
01:48:24,430 --> 01:48:26,950
และตอนนี้ที่ใน C เรา
ก็มีความสามารถในการ

2112
01:48:26,950 --> 01:48:30,290
ที่จะวางสิ่งที่ออกไม่ได้
ร่างกายอยู่ในสมุดโทรศัพท์

2113
01:48:30,290 --> 01:48:34,220
แต่ความจริงในคอมพิวเตอร์
หน่วยความจำที่เราจะสามารถที่สัปดาห์ถัดไป

2114
01:48:34,220 --> 01:48:38,470
ที่จะแนะนำอีกครั้ง this-- แรก
ของโครงสร้างข้อมูลของเราใน array--

2115
01:48:38,470 --> 01:48:43,530
แต่ที่สำคัญกว่าคอมพิวเตอร์ที่เกิดขึ้นจริง
ขั้นตอนวิธีการดำเนินการทางวิทยาศาสตร์

2116
01:48:43,530 --> 01:48:47,720
ในรหัสที่เราสามารถจัดเก็บ
ข้อมูลในโครงสร้างเช่นนี้

2117
01:48:47,720 --> 01:48:50,730
และจากนั้นเริ่มที่จะจัดการกับมันและ
ที่จริงการแก้ปัญหากับมัน

2118
01:48:50,730 --> 01:48:53,570
และเพื่อสร้างด้านบนของที่
ในที่สุดโปรแกรมใน C,

2119
01:48:53,570 --> 01:48:56,730
ในหลามใน JavaScript,
สอบถามฐานข้อมูลกับ SQL?

2120
01:48:56,730 --> 01:48:59,980
>> และเราจะเห็นว่าสิ่งเหล่านี้
ความคิดที่แตกต่างกันลูกโซ่

2121
01:48:59,980 --> 01:49:04,100
แต่ตอนนี้จำได้ว่า
โดเมนที่เราได้นำเสนอในวันนี้

2122
01:49:04,100 --> 01:49:06,920
เป็นสิ่งนี้ที่นี่และ
โลกของการเข้ารหัส

2123
01:49:06,920 --> 01:49:11,200
และในหมู่ปัญหาต่อไปที่คุณด้วยตัวคุณเอง
จะแก้เป็นศิลปะของการเข้ารหัส,

2124
01:49:11,200 --> 01:49:13,630
scrambling และ de-หนี
ข้อมูลและการเข้ารหัส

2125
01:49:13,630 --> 01:49:15,930
และถอดรหัสข้อความ
และสมมติว่าในท้ายที่สุด

2126
01:49:15,930 --> 01:49:18,970
ว่าตอนนี้คุณรู้ว่าสิ่งที่
อยู่ภายใต้ฝากระโปรง

2127
01:49:18,970 --> 01:49:21,860
เพื่อที่ว่าเมื่อคุณเห็นหรือรับ
ข้อความเช่นนี้คุณ

2128
01:49:21,860 --> 01:49:24,060
ตัวเองสามารถถอดรหัสมัน

2129
01:49:24,060 --> 01:49:26,740
ทั้งหมดนี้และครั้งต่อไปมากขึ้น

2130
01:49:26,740 --> 01:49:29,890

2131
01:49:29,890 --> 01:49:30,790
>> [เล่นวีดีโอ]

2132
01:49:30,790 --> 01:49:32,970
>> -Mover เพิ่งมาถึง

2133
01:49:32,970 --> 01:49:35,146
ฉันจะไปเยี่ยมชม
อาจารย์ที่วิทยาลัยของเขา

2134
01:49:35,146 --> 01:49:37,611
อ๋อ

2135
01:49:37,611 --> 01:49:40,080
สวัสดี

2136
01:49:40,080 --> 01:49:40,660
เป็นคุณนั้นเอง.

2137
01:49:40,660 --> 01:49:44,125

2138
01:49:44,125 --> 01:49:45,110
รอ!

2139
01:49:45,110 --> 01:49:45,610
เดวิด

2140
01:49:45,610 --> 01:49:53,936

2141
01:49:53,936 --> 01:49:56,060
ฉันแค่พยายามที่จะคิด
สิ่งที่เกิดขึ้นกับคุณ

2142
01:49:56,060 --> 01:49:58,130
โปรดอะไรจะช่วยให้

2143
01:49:58,130 --> 01:50:05,020

2144
01:50:05,020 --> 01:50:08,354
คุณอยู่ที่วิทยาลัยของเขา
เพื่อนร่วมห้องก็ไม่ได้คุณ?

2145
01:50:08,354 --> 01:50:10,770
คุณอยู่ที่นั่นกับเขาเมื่อ
เขาเสร็จสิ้นโครงการ CS50 หรือไม่

2146
01:50:10,770 --> 01:50:13,770

2147
01:50:13,770 --> 01:50:15,765
>> [เสียงเพลง]

2148
01:50:15,765 --> 01:50:32,110

2149
01:50:32,110 --> 01:50:33,150
>> ใช่หรือไม่เพราะเป็น CS50

2150
01:50:33,150 --> 01:50:42,690

2151
01:50:42,690 --> 01:50:44,770
>> ฉันรักที่นี่.

2152
01:50:44,770 --> 01:50:45,854
>> -Eat ขึ้น

2153
01:50:45,854 --> 01:50:47,020
เรากำลังจะออกจากธุรกิจ

2154
01:50:47,020 --> 01:50:52,120

2155
01:50:52,120 --> 01:50:53,970
>> [จบ PLAYBACK]

