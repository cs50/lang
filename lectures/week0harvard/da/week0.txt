[MUSIK AFSPILLER] 

Dette er CS50-- Harvard Universitetets introduktion til den intellektuelle virksomheder af datalogi og kunsten at programmering. Og mit navn er David Malan og Jeg sad lige og tænkte i morges, det har været forbavsende 20 år i dag siden jeg sidst sad hvor du fyre gøre nu. 

Det var 1996. Jeg var en sophomore, og jeg tog CS50 for allerførste gang. Og jeg havde ikke engang fået op nerven at tage det selv freshman år, dels på grund af tiden. Datalogi til mig var slags kan lide, meh. Jeg var lidt af en nørd vokser op, men jeg har ikke rigtig har nogen intellektuel interesse i hvad syntes til bare at være en hel masse mennesker programmering hele tiden. 

Og jeg var bange for at være ærlig. Kurset og datalogi mere havde generelt og i nogen grad, stadig har dette ry af et felt til pas på, hvis blot fordi så mange af os er bekendt med det og usikker på det. Og det var virkelig ikke før jeg handlede denne klasse, sophomore fall-- og selv da, jeg kun tilmeldt fordi professor-- en af ​​mine første mentorer, Brian Kernighan nu på Princeton-- tilladt mig at tage klassen pass mislykkes. Og ja, det er derfor dag vi tillader og tilskynder studerende til at tage denne klasse sad / unsat. 

Og først derefter ved slutningen af ​​semestret gjorde jeg indser ligesom, wow, dette var ikke sådan et ukendt område. Dette var faktisk en meget bemyndigelse felt, og mere spændende, især senere, da jeg tog kurser i Dramatic Arts 101 og latin A og derefter til sidst grad skole arkæologi, jeg virkelig begynde at se skæringspunkter dette område, computer videnskab, med humaniora, naturvidenskab, kunst, medicin, og lignende. Og så det er, hvad der er lige så pæn om datalogi i sidste ende, som vi håber du vil see-- er dens anvendelighed til disse andre områder, og hvordan du kan tage nogle af nutidens og semesters ideer og praktiske færdigheder tilbage til dit eget domæne, og faktisk udforske dette kryds af de liberale kunst og videnskab. 

Så 73% af jer, hvis sidste år er nogen indikation, har aldrig taget en CS kursus før. Så hvis du ligesom mig, du er følelse en lille smule bange, eller helt ærligt du ikke virkelig sikker på, hvorfor du er selv her. Måske du bare fulgte nogle venner over til Sanders lige nu. Det er helt fint. Målet her er at tilslutte dig og berolige dig at hvis man ser på til venstre og til højre, du kommer til at se klassekammerater med så lidt eller så meget erfaring at du selv måtte have. Og ja, vi deler nogle statistikker senere i dag som til hvad demografi af klassen typisk ser ud. 

Og som tilføjet reassurance-- og dette vi kan betyde, siden jeg overtog kurset nogle år ago-- i kursets pensum er denne-- at der i sidste ende forhold i dette kursus er ikke så meget hvor du ender op i forhold til dine klassekammerater, men hvor man i uge 11, i slutningen af ​​den semester, ender i forhold til dig selv i uge 0, som er hvor vi er her i dag. Og det er det, jeg indså alle disse år siden. Og jeg kender en masse klasser siger dette, men det er især i datalogi. I slutningen af ​​dagen, dette felt er uvant som det var for mig og måske til dig, er virkelig bare om problemløsning. Og som sådan, har det denne anvendelighed til at få andre områder. Og i virkeligheden, hvis vi forsøgte at destillere, hvad det betyder, dette er problemløsning i sin essens, jeg daresay. Der er input-- så hvad det er, at du forsøger at løse. Der er udgang, der er forhåbentlig løsningen på dette problem. Og så, som vi ville sige i datalogi, der er denne sorte boks i midten, at du ikke nødvendigvis nødt til at bekymre sig om, hvordan det fungerer. Du selv i sidste ende måske gennemføre hvad der er indeni den kasse. Men til dagens formål og flere generelt i livet, alle interesserer dig er, at disse problemer bliver løst. 

Og hvad dette kursus er i sidste ende om, er at udforske skæringspunktet mellem disse indgange og udgange, og disse såkaldte algoritmer, som vi snart vil se, at gennemføre det, er nedenunder der, hætten. Men disse indgange og disse outputs-- hvad betyder det egentlig? Nå, i slutningen af ​​den dag, vi har brug for en måde at repræsentere information. Dette gælder især i en computer, der som fancy og komplekst som det kan synes, er en temmelig dum enhed. Det tager electricity-- om fra et kabel eller et batteri som input-- og så er det producerer nogle preprogramed svar på skærmen. 

Men hvordan kommer vi fra start til slut der? Nå, hvad er et problem, der skal løses? Nå, måske vi kunne, på starten af ​​enhver semester, forsøger at tage fremmøde i et rum som dette. Så jeg kan gøre som en, to, tre. Eller måske, hvis jeg gjorde det til slags holde styr af myself-- at holde styr på things-- Jeg kunne hurtigt løbe tør for fingre. Så jeg kan bare gøre hash marks-- én person to, tre, fire, fem, seks, syv, otte. Og alle har sikkert gjort dette, uanset om dine hænder eller på et stykke papir. Og det er faktisk bare noget, der hedder unary notation-- hvor, hvis du kun har et bogstav i din alfabet, en eller hash mærke i dette tilfælde, for hver indgang, du vil tælle, du nødt til at sætte ned en af ​​disse letters-- en af ​​disse mærker. 

Okay. Det er alt fint og godt og ikke alt, kompliceret. Men computere er ikke alle at meget mere kompliceret. Faktisk er de fleste af jer sikkert vide, selvom du ikke har virkelig overvejet, hvad det betyder, at computere kun forstår nuller og ones-- det såkaldte binære system. Vi mennesker, derimod, er så langt mere sofistikeret omfang som vi forstår nuller gennem niere. 

Men selv om binære er ved første blik, ikke alt det velkendte, det viser sig det er ligesom systemerne og idéer, som vi allerede kender. Så for eksempel, overveje dette. Dette er blot en sekvens af symboler. Og alle jer, når kigger på det, sandsynligvis tror 123-- intet virkelig interessant der. Men hvorfor er det dette nummer, 123? Disse er blot glyffer på den screen-- bare mønstre at nogen kunne have trukket eller skrevet. Men hvis du ligesom mig, du sikkert huske fra folkeskolen at der er en slags kolonner eller steder her. Der er den ene plads og ti sted og de hundrede sted. Og grunden til, at dette er 123 og ikke blot et mønster af tre symboler er fordi, selvfølgelig, hvis vi har en en i hundredvis sted, du gør det math på 100 gange én, og derefter to i ti sted. Så det er 10 gange 2, og derefter tre i den ene plads, og det er 1 gange 3. Og når du tilføjer alle de op, for kursus, får du 100 plus 20 plus 3. 

Så vi startede med blot et mønster af symbols-- en alphabet-- men derefter kortlagt vi defineret på det ved hjælp af disse kolonner. Tja, det viser sig, at computere er virkelig ikke så forskellig fra dig og mig. Men i stedet for at bruge kræfter på 10, så at speak-- 1, 10, 100, 1000, 10.000 sted og så forth-- de rent faktisk bare bruge kræfter 2-- så en, 2, 4, og derefter hvis vi sætter flere cifre, 8, 16, 32, 64, 128, og så videre. Og så dette er, hvordan en computer ville repræsentere tallet 0, ligesom vi mennesker. 

0, 0, 0-- og du kan sikkert gætte hvad mønster af nuller og ettaller, hvis en computer kan kun taler 0 eller 1-- hvad mønster vil repræsentere de numeriske vi mennesker kender som en? Yeah-- 0, 0, 1. Okay. Så 0, 0, 1, er, hvordan vi repræsenterer 1, så du kan være tilbøjelig derefter at repræsentere nummer 2, hvis du har de fire plads og de to sted som et sted, kan man sige, godt, hvis vi havde en 1 i ens sted, og nu ønsker vi at tælle op til to, måske du gøre dette og overlade dette til at være et nul. Men det er naturligvis ikke hvordan decimaltegnet systemet fungerer enten. Hvis du sætter et ciffer i begge disse kolonner, du har fået til at gøre det aritmetiske. Så hvad nummer gjorde jeg uheld bare repræsenterer? 

Så det er 3, fordi 2 gange 1 plus 1 gange 1 naturligvis giver os tre. Så det ville være to. Bit slags flips, så at sige, som 0 bliver en ene, meget gerne en 9 roller end og bliver en 0, når du bærer en. Dette så ville være tre selvfølgelig. Fire-- anden interessant ting sker, hvor dem rulle rundt og du bærer en, så at sige. Så dette naturligvis er 4. 

Men hvis du hurtigt frem nu, hvad er det største antal går at være, at en computer kan repræsentere? Så det er bare syv i dette tilfælde, ikke? Fordi du har en en i de fire, en en i to, en en i en. Så det er 4 plus 2 plus 1. Så det giver dig syv. Og ja, ville det synes ved første øjekast at computere kan tælle ikke højere end dette. 

Men dette er naturligvis ikke sandt. Hvad gør vi mennesker gør, når vi ønsker at tælle højere end gerne 999? Bare bære én og kun tilføje et fjerde ciffer til venstre. Og så ja vi kunne. Vi kunne have en otte s placere og en 16. plads, og en 32 plads, 64, 128-- og du kan bare holde foregår op til uendeligt. Så disse nuller og ones-- den såkaldte binære system-- er, hvad en datalog ville generelt kalde lidt eller binært ciffer. 

Men nu, hvordan gør vi får fra koncept eller den grafiske udformning af disse ting til en faktisk computer? Vi synes at springe et trin her. Nå, den eneste indgang i slutningen af dagen, til min laptop her er denne strøm af elektricitet. Selv om det har været en lang gang siden du tænkt over eller aldrig tænkt over hvordan elektricitet fungerer, der er elektroner flyder i eller ud, og det er min form for input. 

Så hvis det er alt, vi er komme som input her, hvad kan vi gøre med disse oplysninger? Nå, vi måske tænke på en nul som blot et fravær af elektricitet. Intet er flowinw, intet er bevæger sig, sker der ikke noget. Det er bare standard state-- nul. Men hvis der er elektricitet flyder, hvorfor gør vi ikke bare vilkårligt, men globalt konsekvent, kalder det en en. 

Så blot ved at have nogen magt, vi har en nul, ja magt, vi har en en-- ingen strøm, ja magt. Og på den måde, at bruge noget mere fysisk eller elektronisk vi begynder at gennemføre denne begrebet noget enten være en eller et nul. Faktisk kunne vi bare gøre det herovre. Så her, jeg har ikke tre, men otte pærer, som hver især har sin egen kontakt. 

Og så hvis jeg ønskede at repræsentere nummer syv her, Jeg kunne slå disse tre pærer. Og faktisk, indersiden af min computer er millioner, milliarder af ting, der er lige mindre end det, der kaldes transistorer, afbrydere, at du bare tænde og slukke. Så disse er big-- relativt big-- switche inde i mit laptop-- er mange, mange, mange, mange flere kontakter. Men alle de gør er præcis at-- slå noget på, drej noget fra. Og som sådan, kan en computer repræsentere, med de millioner eller milliarder af transistorer, partier og masser af nuller og ettaller. Og der er andre hardware stadig, at kan du gemme oplysninger langsigtet, så når du trækker plug, du ikke mister det. Men det er en historie til en anden dag. 

Så hvad kan vi gøre med disse bits? Kunne vi bare at tage presset ud af mig-- måske nogen ønsker at komme op her og tilbyde op en demo? Jeg så denne hånd først. Hvad hedder du? Maday: Maday. DAVID MALAN: Maday, kom op. Rart at møde dig. Maday: Rart at møde dig. 

DAVID MALAN: Kom denne måde. Jeg vil ikke have at læbe dig op. Okay. Så her har vi notice-- én, to-- vi vil redigere det out-- en, to, fire, otte, 16, 32, 64, 128. Dette er bevidst. Der er otte bits her-- binær digits-- nuller og ettaller. Og lidt er en nyttig enhed af measure-- ikke så nyttig en måleenhed på sig selv. Normalt du ønsker mindst otte af disse ting, alias en byte. Så vi har en byte af bits her. 

Så hvis vi ønskede at udfordre dig med, for eksempel, uddyber, i binær, denne værdi her-- 42. Ønsker du at tage et stik på det? 

Maday: [uhørligt]. DAVID MALAN: Ja, bare skubbe små hvide afbrydere foran. Og du ønsker at stave ud 42, og på højkant er denne CS50 stress bold, hvis du får dette. Okay. Så du har 32. Vi får brug for 42. Så det er en otte, så det er 40. Og excellent-- meget pænt gjort. Tak. 

[BIFALD] Okay. Så vi har en mere stress bold. Lad os gøre dette én gang mere, hvis vi kan. En anden frivillig? Gratis stress bold, gratis stress bold. OKAY. Herovre i midten, ønsker du at komme ned? Okay. Jeg ved. Sådan der. 

Så tallene her-- kom ned. Hvad er dit navn? 

DAVEY: Davey. 

DAVID MALAN: Davey. OKAY. Kom op, Davey. Rart at møde dig. Og hvad vi vil have dig spell-- hvis du kunne dvæle der for bare en moment-- er antallet 50. Men, men, men, men, men disse er klasse skole magneter for en grund. Lige fik lidt hårdere, okay? Der er stadig otte. Okay. Så hvad har vi på der? Vi har 32. Pæn. 32 plus 16 giver os 48-- så tæt. Og vidunderligt. Tillykke til Davey så godt. 

[BIFALD] 

Okay. Så vi kan gøre dette hele dagen lang, og det får ikke så meget mere interessant og mere udfordrende. Men det er virkelig point-- er, hvor relativt simpel det er, ved slutningen af ​​dagen, hvad en computeren gør at lagre information, at lagre indgange og i sidste ende opbevare eller repræsentere disse udgange. Men tal alene er ikke alt det interessant. 

Så mennesker, for nogle år siden, besluttet, ved du hvad? Det ville være rart, hvis computere var ikke bare regnemaskiner til aritmetiske operationer, men faktisk kunne gøre ting som tekstbehandling, eller e-mail, eller mere moderne inkarnationer af disse former for teknologier. Og så verden besluttede vilkårligt, men universelt, at hvis du ønsker at gemme kapital bogstavet A i en computer, ved du hvad? Lad os bare alle er enige om at gemme nogle mønster af nuller og ones-- bits-- der i sidste ende repræsenterer decimaltallet 65. Vi vil bare alle enige om. 

66 ville repræsentere B, 67 ville repræsentere C, og der er klaser af andre mønstre af nuller og ettaller, eller underliggende tal, der ville repræsentere andre bogstaver stille. Så hvis du slags mentalt absorbere dette for et øjeblik, Jeg bevidst sat A til I, hvor H en 72 og jeg er 73. Hvis en computer derefter, i forbindelse med et tekstbehandlingsprogram eller en e-mail, afsløret under hætten for at have disse mønstre af bits-- mønster af bits, der repræsenterer 72, derefter 73, derefter 33-- hvad kan dette stave i dette program? 

Så hej, og derefter noget. Vi ved ikke nødvendigvis kender, men faktisk 33-- ikke på diagrammet earlier-- var simpelthen et udråbstegn. Så 72 var H, 73 er ​​I, 33 sker at være et udråbstegn stadig. Men det er alt fint og godt, og faktisk i dag, i stedet for bare bruge syv eller otte bits, takket være noget kaldet Unicode i modsætning til ASCII tilbage i dag, vi faktisk kan repræsentere endnu mere interessante karakterer end blot disse originale engelske forudindtaget bogstaver. Men vi kan også repræsentere selv pænere ting som farver. 

Hvis du nogensinde har hørt akronymet RGB, rød, grøn, blå, at bare betyder, at en computer typisk bruger tre sæt bits-- nogle antal bit, repræsenterer et tal for hvor meget rød du ønsker, et andet sæt bits for hvor meget grøn, du ønsker, og et andet sæt tal for hvor meget blå, du ønsker. Så et stort antal betyder masser af rød, lille antal betyder ingen rød. Og så disse er slags af midterste værdier her. 

Så giv mig nogle røde, give mig nogle grøn, og give mig en lille smule af blå. Og hvis du blander disse tre nuancer farver sammen, i dette tilfælde, du får denne skumle skygge af gul eller brun. Men dette mønster af otte plus otte plus eight-- så 24 bits-- venstre til højre, er, hvordan en computer ville repræsentere den pågældende farve. Nu er det bare en prik på en skærm. Hvis man ser virkelig tæt på dit TV dit computer, vil du se prikker eller pixels. Og hvis du har en hel gitter af pixels, horisontalt og vertikalt, du har billeder. Og så hvis du tager et billede og derefter vask vise dig et andet billede, en anden billede, et andet billede, et andet billede, rigtig hurtigt, du selvfølgelig har film. 

Og så mærke til hvor vi startede. Vi startede med disse nuller og ettaller. Vi arbejdede derfra til decimal tal, hvordan vi repræsenterer dem. Nu har vi bogstaver i alfabetet. Men i andre sammenhænge vente, kan vi bruge et par mere bits og repræsenterer farver. Så snart du har den evne til at præsentere farver, du har evnen til at repræsentere billeder og animerede gifs og andre sådanne tegn på skærmen. Og når du har en hel masse billeder fører ved det menneskelige på en gang, det ligner levende billeder, og så får du videoer samt. 

Så bruge disse meget simple primitiver gør vi have måde at repræsentere sidste ende alle disse former for medier. Og vi har abstraheret igen og igen og igen, indtil vi komme fra det laveste niveau til dette højeste niveau. Så det giver os dette generel idé om abstraktion. Men vi begyndte her. 

Her nu, måske vi repræsentere i en computer vores indgange med nuller og ettaller, vores output i nuller og ettaller, men hvad der går inde i boksen? Det er, hvor computeren videnskab bliver interessant. Det er, hvor du rent faktisk bringe din eget sind til at bære at løse problemer. Vi kan nu fastsætte, for resten af ​​semestret, ja. Jeg ved, hvordan binære værker. Jeg husker, hvordan Ascii eller Unicode-- kortlægningen at letters-- værker. Og det helt sikkert står til grund, at vi kunne repræsentere rød og grøn og blå, og repræsenterer multimedia så godt. Men dette er den interessante ting. Dette er hvad der gør en person stand til at løse problemer. 

Og en sådan problem vi gerne gøre, ja, tager fremmøde, eller at gøre dette algoritmisk. Og igen, kan jeg gøre det. Jeg kan gøre en, to, tre, fire fem, seks, syv, otte ni. Og jeg kunne skrive det ned til at holde styr på den. Men det er bare sådan jeg ville repræsentere oplysningerne. Eller jeg kunne gøre dette faster-- to, fire, seks, otte, ti, 12, 14, 16, 18, 20, 22-- det føles to gange så hurtigt, men det er stadig kommer til at tage en hel masse tid. 

Men det viser sig, hvis vi udnytte endnu anden resource-- og faktisk computere disse dage har flere CPU'er eller hjerner. Det viser sig computere kan gøre masser af ting på én gang, og faktisk vi, i dette rum, kan udgøre netop dette. 

Så det er lidt socialt akavet, men hvis du ville humor mig for kun en tre-trins proces, lad mig spørge alle i sted der bare at stå op et øjeblik. Stå op. Så tænk på dig selv, nummer en-- så alle i dette rum, undtagen de mennesker, der ikke gjorde oblige, tænker nummer et. Så det er dit nummer lige nu. Det er det første skridt, eller som en datalog eller en programmør vil typisk gøre, vi kommer at begynde at tælle ved nul. Hvis det mindste tal, vi kan repræsentere med disse pærer er nul, ved blot at lade dem alle off, kunne jeg lige så godt bare begynde at tælle fra nul er stedet for én. Og så det er hvad dataloger gør. Så trin nul, stå op og tænke på nummer et. Det næste skridt er denne-- par ud med nogen stående og tilføje dine tal sammen. Vidunderlig. 

Så på dette tidspunkt, bogstaveligt alle deltager tænker på tallet 2, med undtagelse af for én ulige person, hvis vi har et ulige antal personer i lokalet. Og nu det tredje trin her kommer til at være denne-- en af ​​jer skal sidde ned. En af jer skal sidde ned, og hvis du stadig stående, gå tilbage til trin et. Okay. Okay. Så flere og flere mennesker bør sidde ned. Bemærk, at dette har fremkaldt en loop-- en slags cyklus. Nogle af jer skal være akavet fast, gå frem og tilbage mellem trin et og to, en og to, en og to. Det er ok. Vores første fejl. Vi vil beskæftige sig med det. Okay. Lad mig prøve at anspore tingene sammen. 

I teorien er kun én person, der står som alle fortsætter med at parre off. Men lad mig fremskynde tingene med de mennesker stadig står. Hvilket nummer tænker du på? 46. OKAY. Gå videre og sidde ned. Du fyre står endnu. Hvem er stadig stående? Hvilket nummer tænker du på? OKAY. 

Så vi vil komme tilbage til dig. I ryggen? Hvad er det? 22. OK en anden op top-- ikke? 34. OKAY. Over her på min right-- heroppe? 132, meget flot. 22? 

OKAY. Og hvem er stadig stående? Her ovre? 46, meget flot. 72. Jeg kan ikke gå i stå meget længere. Ja? 30, nice. Her ovre? 23? 23. 

Og jeg tror, ​​det er alle undtagen jer, ingen pres. Oh vent. 28? Blot otte. OKAY. Blot otte. Her nede? 30. 23. 24. 18. Dette er den værste implementering af denne algoritme nogensinde. OKAY. Så andre? Nogen andre? OKAY. En til. 16? OKAY. 16. Okay. Så hvis jeg ikke har savnet nogen i blænding her, når jeg ramte Enter, vi vil se, algoritmisk, det samlede antal personer i Sanders. Fordi igen, det er som om alle som du sad ned, passerede dit nummer off til en anden, til en anden, til en anden, så i teorien, i sidste ende, kun en akavet person, bør overlades stående. Men det er fint. Vi drønede tingene op manuelt. Det er især svært at se i dette særlige rum. 

Og det samlede antal personer Vi tror, ​​der er her er 546. Det samlede antal var jeg afleveret af undervisningen stipendiater, der gjorde det den gamle skole langsom måde, var 820. 

[LAUGHING] 

[BIFALD] 

Det er ok. Så sikkert da, der er disse fejl. Og det er fint. Og så tænker tilbage på dette første gang noget du skriver ikke nødvendigvis arbejde. Dette er sket for mig her. Men lad os nu overveje, hvordan vi kunne anvende denne samme idé til noget du måske har set før, som er denne gamle skole teknologi her-- en virkelig stor telefonbog. Og formoder, at denne telefonbog har 1.000 sider og 1.000 navne og numre alfabetisk inde i den. 

Nå, vi kunne slags anvende en lignende idé til denne meget fysiske problemer, bare bruge mig. Jeg lige slags snydt ved at udnytte alle jer med masser og masser af forskellige CPU'er eller hjerne udfører nogle algoritme. Men hvis det er bare lidt gamle mig, kan jeg stadig udnytte den samme essensen af ​​en idé opdele og erobre dette problem igen og igen, hvorved halvdelen af ​​jer, halvdelen af ​​jer, halvdelen af ​​jer, halvdelen af ​​jer, teoretisk holdes sidder ned, indtil vi var tilbage, teoretisk, med kun én person. 

Så i denne gamle skole teknologiforbedringer vi ikke brug for dette map-- dette gamle skole teknologi, vi måske begynde at lede efter en person gerne Mike Smith, en side ad gangen. Og jeg ser, at ingen, Mike er ikke her. Jeg er stadig i A sektionen. Til sidst finder jeg mig selv i afsnittet B. Og dette er en algorithm-- trin-for-trin instruktion. Start i begyndelsen og én side på et tidspunkt, kigge efter Mike Smith. Er det correct-- dette algoritme eller strategi? 

Ja, det er korrekt. Hvis Mike er her, i sidste ende Jeg vil komme til ham. Men det er ikke effektivt. Det er selvfølgelig meget langsom. Så jeg kan udnytte samme twosies nærmer. Jeg kan gøre slags to, fire, seks, otte, 10, 12. Det er dobbelt så hurtigt. Jeg har tænkt mig at komme til Mike hurtigere, hvis han er der. Er det korrekt? Ja, men jeg hørte en little-- nej. Nu hørte jeg et nej. Ja. Der er en fejl potentielt. Måske Mike bare et uheld får klemt inde mellem to sider, fordi jeg flyver gennem denne to ad gangen. Så i det mindste, vi har brug for nogle form for betinget fix. Jeg har brug for at sige, hey, hvis jeg ramte en person, hvis navn starter med et T i stedet for et S, Jeg bedre dobbelt tilbage mindst én side. Så buggy i starten, men fixable. Men ingen af ​​os kommer til at kigge efter Mike Smith gennem en 1000 side telefon bog en side ad gangen. Hvad er en normal person vil gøre? Du kommer til at gå til S ', Hvis du vidste, hvor S '. Du kan gå nogenlunde til midten eller lidt skæv mod slutningen. Og jeg ser ned her og Jeg er i M sektion. Men hvad ved du om dette problem nu, at vi ikke nødvendigvis ved, før med alle os bare tælle os selv ækvivalent? Nå, Mike vil helt klart at være i denne halvdel af bogen hvis han er her på alle, fordi det er ordnet. 

Og så kan du meget dramatically-- 

[Gisper] 

Jeg ved. 

[BIFALD] 

Det er faktisk rigtig let, hvis du gør det ned ad ryggen der. Men du kan derefter kaste halvdelen af ​​problemet væk. Nu, jeg tilbage med det samme problem-- finde Mike Smith i en telefon book-- men nu telefonbogen starter ved M og går til Z, men det er halvt så stor. 

Men dette er, hvad der er imponerende. Ligesom i teori, gutter, når du alle sad kun halvdelen ad gangen, problemet fik halvt så stor, halvt så stor, igen og igen. Så er dette problem blevet den samme problem, men halvt så store. Nu er det en 250 side problem. Så snart jeg indser, åh, jeg er i T-sektion uheld. Jeg har gået for vidt. Jeg kan kaste, at halvdelen af telefonbogen væk. Nu er jeg ned til en fjerdedel af problemet. 

Og du kan gentage, gentage, Gentag indtil, i teorien, er du efterladt med kun én side. Og hvis Mike er på denne side, Jeg kan nu løse dette problem. Men hvor hurtigt jeg løse det? I det første tilfælde, det tog mig ligesom måske 1.000 trin for at finde Mike Smith. Det kunne have taget mig-- Jeg tog telefonbogen og jeg begyndte at lede én side ad gangen, og Mike kunne være 1.000 sider senere. 

Anden fremgangsmåde måske tager mig 500 trin, fordi jeg flyver gennem to ad gangen. Og den tredje tilgang selv, Det er især stærke. Men lad os overveje, hvad vi rent faktisk gjorde med denne tredje tilgang. Jeg har, hvad jeg vil kalde bare disse udsagn her, en ad gangen. Pick up en telefonbog. Åbn til midten af ​​telefonbogen. Se på navne. Og så tingene bliver lidt mere intellektuelt interessant, hvis stadig enkel. Hvis Smith er blandt de navne på den aktuelle side, så gør noget betinget. Det er ligesom en gaffel i vejen. Ring Mike. Hvis Mike er blandt de navne, på den side, kaldet Mike. Men kun gøre linje fire, hvis linje træ, hvis du vil, er sandt. Svaret på dette spørgsmål er ja. 

Else hvis Smith er tidligere i book-- med andre ord, hvis jeg er i M sektion og jeg leder efter nogen til at venstre, så hvad jeg skal gøre er noget meget lignende. Så skulle jeg åbne til midten af den venstre halvdel af bogen. Så gå til venstre, og derefter gå tilbage til trin to. Kig på navne der. 

Så med andre ord, gøre det samme, men på et problem, der er blevet halveret. Du ved, hvad ellers? Hvis Smith er senere i bogen baseret på den side, jeg ser på, åben til midten af ​​den højre halvdel af bogen og derefter gå tilbage igen til trin to, else-- der er en fjerde mulighed her. Mike enten her eller til venstre eller til højre eller ikke. Og her er vi bedre overveje dette. Og i virkeligheden, hvis du nogensinde har haft computeren bare gå ned på dig, der er nogle gange, men ikke altid, den resultat af blot et humant programmør ikke indse, oh shoot, er der faktisk denne fjerde scenarie. Og hvis du ikke skrive kode til at håndtere dette scenario, nogle gange er du ikke kender hvad computeren kan gøre. Og faktisk et program kan gå ned. 

Men i dette tilfælde, tænkte jeg om det, og jeg sagde, ellers holde op, fordi det er den fjerde logisk muligt scenario. Lad os nu bare tilføje nogle ordforråd så vi kan begynde at kaste rundt vilkår, er ellers temmelig intuitiv. Alle de ting, jeg har bare fremhævet med gult her, Jeg bare til funktioner eller procedurer. De er bare slags handlinger. Så afhente, åben for, se på, ring, åben, åben, quit-- disse er blot handlinger, eller vi får kalde dem mere formelt, funktioner. 

I mellemtiden, nu i gul, Jeg har fremhævet ting at-- lad os bare begynde at kalde dem betingelser eller filialer. Disse er beslutningspunkter hvor du kan gå på denne måde, denne måde, eller en anden retning stadig. Så dem vil være betingelser. Og nu denne ene er lidt mere avanceret. Lad os kalde disse spørgsmål Boolske udtryk, efter en person med en sidste navn Bool. 

Og en boolesk udtryk er bare noget det er enten sandt eller falsk, ja eller nej. Så det er spørgsmålet, hvis svar du holder af, således at i en tilstand gøre en decision-- komme tilbage et svar, og derefter gå til venstre eller højre, eller noget helt andet. 

Og så endelig, disse linjer her-- gå tilbage til trin to, gå tilbage at træde to-- vi kunne gennemføre denne idé på forskellige måder. Og så dem af jer med erfaring med programmering kunne have gjort eller kan forestille sig at gøre dette anderledes. Men for nutidens formål, det er bare tanken om, at der betyder noget. Dette er inducerende hvad vi generelt kalder en loop-- en slags cyklus, fordi det gør mig gøre noget igen. 

Så nu, lad os lige overveje hvor god denne algoritme er. Det er korrekt. Hvis Mike i bogen, det er en af disse fire scenarios-- igen og igen og igen, vil vi finde ham. Men hvor god er den? Nå, har vi ikke at være for formel her. Men lad os bare plot noget, x og y, for at få en følelse af formen af ​​dette problem. 

På x-aksen er her størrelsen af ​​mit problem. Og de en y-aksen her vil være tid til at løse. Så måske er det antal sider. Måske er sekunder eller side turns-- hvad. Men du ønsker at tælle, er hvad dette billede vil repræsentere. Og det første algoritme, jeg har tænkt mig at beskrive som bare en lige linje. Hvis der er n sider i telefonbogen, så er det kan tage mig som mange som n trin for at finde Mike. Hvis Verizon eller teleselskabet tilføjer én side mere næste år, det kan tage mig endnu step-- en mere enhed af tid til at finde Mike. Så der er bare denne ene til en forhold. Det er en lige linje hældning. 

I mellemtiden, at anden algorithm-- hvis jeg han er to ad time-- to, fire, seks, otte eller double-- går gennem siderne to gange på et tidspunkt, to ad gangen, det er stadig lige linje. Der er nu en 01:59 ratio, men en anelse lavere. Så hvis der er så mange sider på kortet her i gul, der kunne tage mig dette mange trin eller sekunder, ellers det vil tage mig dobbelt så mange på den røde linje. 

Men den grønne linje er den virkelige takeaway. Dette er, hvad vi generelt kalde en logorithm-- log af n, hvor n er antallet af sider. Men det er formen, der betyder noget i dag, fordi vi ikke har til selv synes om plotte punkter. 

Tænk en ekstrem situation. Antag Verizon morgen fordobler antallet af sider i den telefonbog, fra 1.000 til 2.000. I den første algoritme, jeg kan spilde en ekstra 1.000 trin efter Mike, bare fordi Verizon fordoblet størrelsen af ​​bogen. Den anden algorithm-- det måske tage mig en ekstra 500 trin. 1.000 flere sider, jeg går to på en time-- 500 flere trin for at finde Mike. 

Men det tredje algoritme er slags magisk. Verizon fordobler antallet sider fra 1000 til 2000, men hvor mange flere skridt gør det tage mig at kigge efter Mike? Det er bare en, fordi jeg kan bare rive telefonbogen én mere tid fra en 2.000 side problem for et 1000 side problem, og voila. Jeg har taget en massiv bid af det. 

Og hvis du går virkelig ekstrem, antage, at telefonbogen Selskabet havde noget crazy ligesom en 4 milliarder side telefonbog. Nå, hvor mange trin kan det tage at finde Mike Smith i en 4 milliarder side telefonbog? Det er et stort tal, men kun 4 milliarder til 2 milliarder til at 1 milliarder til at 500 millioner, 250 million-- stadig lyder som store tal, men jeg er meget hurtigt komme til mindre værdier. 

Og i virkeligheden, hvis jeg gør det math ret, jeg kan kun opdele 4 milliarder med omkring 32 gange før Jeg kommer ned til bare én. Så hvis det telefonbog var 4 milliard sider lang, nogen big deal. Inden for et par sekunder, måske 32 sekund, jeg kunne dele det på midten og til sidst finde Mike eller konkludere, at han ikke er der. Og det er essensen af ​​en algorithm-- en god algoritme. Og det er en af ​​de mål for en klasse som denne, forsøger at finde ud af, hvordan gør jeg løse problemet ikke blot korrekt, som jeg altid vidste, hvordan man gør det ene side, men korrekt og godt på en time--. Hvordan designer jeg godt løsninger på problemer? Så lad os tage et øjeblik her og give dig en fornemmelse nu af CS50 kurset itself-- introducere et par kursets medarbejdere. Lige før 02:00, vil vi tage en kort pause så de af jer der er shopping kan ænder ud og tage en se på nogle andre klasse og se resten af ​​dette online. Men for nu, lad mig præsentere CS50, klassen selv, og især hvad der er nyt. 

Så den sidste forår, vi brugt ganske lidt af time-- kursets personale og jeg-- tænkning om, hvad det er, vi ønsker CS50 at være, og går tilbage til første principper, så at sige, at overveje, hvad det er, vi ønsker dette kursus til at ligne og være lignende for sine elever. Og så kan du se i problemer sæt nul så godt, en invitation at tage et kig på det URL der opsummerer nogle af motiverne bag følgende karakteristika efteråret 2016. 

Så som du måske har forstået fra TL: DR handout, pensum i dag samt fra kursuskataloget, i år i CS50, du kun forventes at deltage today-- så arbejde godt done-- og den sidste forelæsning den 21. November. Og du er velkommen, men forventes ikke at deltage i disse foredrag i midten, fordi det, vi laver i år, er at skyde i realtid kursets materiale. Så alt vil forblive aktuelle og indarbejdet så godt vi can-- aktuelle begivenheder og samtaler, folk måske være at have i industrien i verden, men gør dette materiale rådighed, som et resultat, selv earlier-- komplet med fuld tekst udskrifter og søgning i og links til andre ressourcer. 

Og ja, vi har været hævder i nogen tid og vi nu tro det, at vi kan skabe, digitalt, en mere fordybende, en mere overbevisende pædagogiske erfaring, i modsætning at indsamle her nogle 23 gange personligt, høre en som mig blot taler om datalogi, i modsætning til at engagere sig mere aktivt. Så du kan se i kursets pensum en skitse af semestret her, sammen med, når foredrag vil blive filmet, som du er velkommen, men forventes ikke, og når de vil frigives på kursets hjemmeside. 

Og hvad vi vil gøre her på Onsdage starter næste uge, er meget mere intimt, med kun de folk, der ønsker at deltage, er en såkaldt gåtur gennem, hvor jeg og kursets hoveder vil faktisk gøre tingene lidt mere intim hernede i orkestret afsnit, har stadig nogle teknologi og gå gennem nuværende uges problem sæt, og tilbyder dig particularly-- hvis blandt de mindre comfortable-- desto mere vejledning, som du måske ønsker eller brug for ugens udfordring. Og på samme måde, for dem, der ikke kan deltage dem personligt, nogen big deal. Der vil tilsvarende blive ledet af en af ​​kursets ledende medarbejdere, Zamalya, samme mulighed indlejret i problemet sætter selv. 

Problem sætter i år vil blive frigivet om fredagen og ikke længere gøre syv dage senere, men 10 dage later-- bevidst overlappende med hvert problem indstillet, således at man bedre plads, Vi håber, ebbe og flod i de studerendes skemaer, især når midterms eller atletik eller akademikere eller extracurriculars tendens til at komme og gå især mid-semester. Det burde give dig lidt mere skøn med hensyn til, om du foran indlæse din uge med CS50 eller ryg belastning det på den følgende weekend i stedet. Så se til kursets pensum her for tidsplanen heraf. Og du vil opdage også blandt ændringerne i år, for dem mere fortrolige med programmering i fortiden, vi starter semestret som vi vil i dag i Scratch, fokus især på sproget kaldet C, og derefter overgangen ikke til PHP, men til et sprog kaldet Python mod slutningen af ​​semestret i forbindelse med web programmering, sammen med SQL og JavaScript, HTML, CSS, og endnu mere. 

Og som svar på en FAQ, det er faktisk tilfældet at CS er ikke så skræmmende som jeg engang troede, det var, men det er så meget arbejde som jeg havde hørt det kunne være. Men det er det sige at her er nogle statistik fra efteråret 2015 studerende, hvorved de vandrette blå linjer repræsenterer det gennemsnitlige antal timer rapporteret. Og du vil se et gennemsnit på seks til 10 til 12-- måske 16 eller så og så videre, men med høj varians skal være klar. Og så indse, at der ikke kun er studerende mere komfortabel og mindre behageligt i løbet, men en tilsvarende støtte struktur til at få de studerende gennem semestret med succes. 

Ja, i svar på en FAQ, bør du tager CS50 som første år? Absolut. Og i virkeligheden, jeg fortryder ikke har fundet min vej eller fundet et nyt felt det første år samt. Og skulle du tage CS50 med andre kurser, sikkert som well-- og den generelle råd, vi måske give de studerende, at CS50 er nok ikke den slags klasse eller intro klasse at du bør tage med tre anden eller fire andre p-sæt klasser. Men hvis du tager to andre p-sæt klasser, noget andet, og CS50, absolut overskueligt. Jeg har haft mange studerende i tidligere gjort det ganske vellykket. 

Og for at få dig mod at afslutte linje med succes, har kurset have sections-- forskellige spor for studerende mindre behagelig, mere komfortabel, og midt imellem, hvorved i kursets første problem sæt, vil du blive bedt om at beskrive dig selv. Og hvis du er blandt de mindre behageligt, det er den slags ting at du bare hellere vide. Og ja, der har været den voksende demografisk i CS50 for et par år. 

Som i sidste efterår for eksempel 58% af klassen beskrev sig selv som blandt dem mindre behagelig, med 9% blandt dem mere komfortabel, og derefter de andre studerende der i rød beskriver sig selv som et sted midt imellem. Og du vil se her emnerne samlet og tidsplan af sektioner, som alle udbydes i person, i real tid, med kursets fantastisk personale af undervisning stipendiater og selvfølgelig assistenter, hvoraf nogle du vil mødes på bare et øjeblik. 

Sektioner selv, som du vil se, vil være mandage og tirsdage og onsdage, således at du kan dykke i efter engagerende, hvis du vælger, i kursets foredrag tidligere i denne uge. Og så kontortid, som sikkert, med hvert år, har været ikke mindre af en udfordre for kurset. Og i år, vi planlægger ikke kun i embedet hours-- en på en muligheder for hjælp til studerende på onsdage torsdage og søndage, den sidste af dem, være om eftermiddagen ved design at reducere nogle af de stress, der uvægerligt opstår med sen nat p-settting med frist looming-- men kontortid vil også blive tilbudt på mandage og tirsdage og Onsdage og fredage og lørdage, takket være vores venner på HSA. 

CS50 har nu sin egen plads for studerende og CS50 personale, på toppen 67 Mount Auburn Street, lige der i Harvard Square. Visionen for det er, at CS50 s TF'er og CA'er hele ugen, temmelig meget i det meste dag, vil være der for støtte. Så hvis du har fået nogle spørgsmål på en p-sæt eller du føler lidt blokeret eller lidt forvirret, og dælen, du har fået en time eller en halv time mellem klasser, især i square-- kan du pop i og har dette spørgsmål besvaret af har denne forvirring clarified-- meget i ånden, du er fortrolig, i matematik afdelingens egen matematiske spørgsmål center, men temmelig meget døgnet per rundt [? Gcal?], At vi vil bogføre online. 

Undervisning er også tilgængelig for dem studerende, frit fra kursets eget personale, hvis du ønsker mere intim en på én, eller to eller tre klassekammerater kun, arbejder med en af ​​kursets medarbejdere. Og ja, disse her er bare nogle af kursets medarbejdere, et par af hvem du vil mødes i et øjeblik. Faktisk CS50 egen hoved undervisning fyr, og hoved kursus assistent, og gurus kunne komme videre op, tillade dem til at sige hej. 

[BIFALD] SPEAKER 1: [uhørligt]. 

[BIFALD] SPEAKER 2: [uhørligt]. 

[BIFALD] SPEAKER 3: [uhørligt]. 

[BIFALD] 

DAVID MALAN: Og tillade os at bringe ombord to af CS50 mest ledende medarbejdere, Rob og Zamayla så godt. 

[BIFALD] 

Faktisk både Rob og Zamayla har været med os så længe, ​​at jeg var i stand at gå ind i CS50 arkiv og finde denne meget SD optagelser af dem, der deltager på scenen selv for nogle år siden. ROB: [uhørligt]. 

[BIFALD] ZAMAYLA: [uhørligt] 

[BIFALD] DAVID MALAN: Tak. Så ud over disse teammedlemmer her, CS50 har et team af næsten 100 medarbejdere, som alle vil være til rådighed for sektioner og kontortid og så meget mere. Og som Rob siger også, det er den mest betydningsfulde eftersyn af CS50 i de 10 år, der Jeg har været i [uhørligt]. [Uhørligt] fokuseret specielt i tilvejebringelse af en støttestruktur, trimning væk en masse hovedparten, der har været akkumuleret i 10 år iterative udvikling på kursets problemet sæt. 

Så i år, ikke kun i klassen, men også i form af kurset problem sæt, bør du finde ting til være mere strømlinet, trimmer, meget mere overskueligt end i de forløbne år, som vi kaste noget af den bagage, der er udviklet af natur udviklende år efter år og iteration. Så den nye og forbedrede begynder i dag. 

Du vil møde nogle flere af kursus personale i [uhørligt] 2:30, hvor vi tjener, som en tradition, kage. Der er lidt mere kage end det, men du vil Mød Erin og Tobias og andre stadig. Og lad mig give dig en tur før vi hører fra nogle af de andre ansatte i klassen af ​​hvad der venter så godt. Faktisk starter vi altid CS50 s semester denne kommende lørdag, med det, der hedder CS50 Puzzle Day. 

Det har intet at gøre med datalogi per se, men med ca. problem løse mere generelt. Og hvis du vælger at deltage, pr nogle af invitationer, du måske har set dør tabes eller på scenen her, det er en mulighed i teams af to eller tre eller fire, at deltage for gåder og pizza og præmier og more-- denne lørdag, stay tuned for mere. 

Du kan finde alt for, at alle Fredag ​​på Fire and Ice, gør CS50 bringe en hel masse elever til frokost, for at gøre en stor klasse føler sig mere intimt, og generelt samle alumner og venner fra industrien at tale om, hvad de har været op til siden afgangseksamen. Ligeledes i år, vil vi indvie den første nogensinde CS50 50 kodning contest-- en mid-semester mulighed for at tillade alle på en opt-in grundlag, at have en udfordring for vid og sans over for klassekammerater, igen i hold af to eller tre eller fire, ved hjælp af kun at programmeringen kyndige, at du derefter har under bæltet efter blot seks eller syv uge af klassen, og de deltagende i denne form for konkurrence online-- hvis du ønsker at finpudse din egen færdigheder desto mere i denne udfordring. I slutningen af ​​semestret er den såkaldte CS50 Hackathon-- en mulighed, der begynder ved 7:00 PM slutter ved 7:00, og undervejs er 12 aften timer til at dykke ind kursets endelige project-- en mulighed for at designe og gennemføre de fleste noget af interesse til dig med din undervisning stipendiat vejledning. Omkring 9:00 gør vi typisk tjene pizza, 01:00, Philippes, og de få af os der er stadig vågen på 05:00, er shuttle bussed ned vejen til IHOP til morgenmad. 

Og så et par dage senere er den såkaldte CS50 fare-- en ende af semester udstilling i fejringen af, hvor langt så mange af CS50 studerende er kommet fra uge nul hele vejen til uge, og holde sig for øje, at 73% af dem, klassekammerater og dine år har aldrig taget en CS klasse før. Faktisk igen understreger så meget, her er nogle flere ansigter fra CS50 personale. SPEAKER 4: [uhørligt]. SPEAKER 5: [uhørligt]. SPEAKER 6: [uhørligt]. SPEAKER 7: [uhørligt]. SPEAKER 8: [uhørligt] SPEAKER 9: [uhørligt]. 

SPEAKER 4: [uhørligt]. 

SPEAKER 10: [uhørligt]. SPEAKER 11: [uhørligt]. SPEAKER 12: [uhørligt]. SPEAKER 13: [uhørligt] 

SPEAKER 14: [uhørligt]. 

SPEAKER 13: [uhørligt]. SPEAKER 15: [uhørligt] SPEAKER 16: [uhørligt]. 

SPEAKER 11: [uhørligt] SPEAKER 5: [uhørligt]. DAVID MALAN: Nogle af holdet selv er shopping klasser. Men hvis de medlemmer af CS50 personale er her, kunne komme videre op for bare et øjeblik. CS50 er TF'er og CA og [? personale?] medlemmer her-- disse er blot nogle få af den faces-- en af ​​hvem du bare så, og et par other-- og et par andre stadig. Skal vi ikke gå videre og tillade jer en fem minutters pause. Hvis du skal ænder ud til shop klasser, det er fint. Og i fem minutter, vil vi genoptage, tage et kig på Scratch-- den første af vores programmeringssprog, mødes kursets personalet her nogle flere, og fokus i sidste ende på problemet sæt nul. Så vi vil være tilbage i fem minutter. 

[BIFALD] 

Okay. Så vi er tilbage. Og i vores resterende tid i dag, målet er at skabe lige vilkår i form af nogle terminologi, i form af nogle ideer. Fordi ja, som pr nogle af hitlisterne tidligere, Der vil være en række niveauer af erfaring i klassen, nogle af hvis studerende har taget nogle programmering før, hvoraf nogle har ikke. Og så med denne første problem sæt og med denne første sprog har vi en mulighed for at starte at tage for givet efter i dag nogle fælles ordforråd og idé. 

Og vi vil gøre det ved hjælp af kursets første languages-- udover C og Python og JavaScript og SQL og HTML og CSS, vi vil fokusere oprindeligt og bare for problemet sæt nul på denne grafiske sprog, kaldet Scratch, udviklet af MIT'S Media Lab ned ad vejen, for at hjælpe studerende og børn især udtrykke sig algorithmically-- på en måde, mere i overensstemmelse med, hvad vi kunne kalde beregningsmæssige tænkning. 

Og det er en nyttig sprog, fordi meget hurtigt næste uge i uge en, vi overgangen til en mere traditionelle og mystiske sprog kaldet C, som er rent tekstmæssige. Du bruger kun tastaturet i For at skrive instruktioner som disse på skærmen. Men selv hvis du har aldrig set et programmeringssprog før, i bare et blik på dette, alle være det kryptiske, kan du sikkert gætte, at sandsynligvis udskriver Hello World. Men der er en masse syntaktisk overliggende der. Der er den underlige hash symbol eller hash tag op øverst. Der er de vinkelbeslag, nogle parenteser, krøllede parenteser, semi-colon-- der er bare så meget visuel syntaks, der kommer i vejen. Vi starter kurset med Scratch så for at få forbi alle de intellektuelt uinteressante distraktioner, og i stedet fokusere på ideerne. 

Faktisk kan det være før. Dette, for dette, skal uge være efter. Dette, i denne grafiske sprog Scratch, er, hvordan du vil gennemføre denne samme program-- et program, når det køres, simpelthen siger hej verden. Og hvad er rart om Scratch er at det er denne grafiske programmering miljø, der anvender puslespilsbrikker eller blokke, at kun sammenlåse sammen hvis det giver logisk mening at gøre det. Og med Scratch kan du udvikle animationer og interaktive spil og kunst, samt en række ting, som du kan forestille sig i dit eget sind, og gennemføre dem blot ved trække og slippe puslespilsbrikker. 

Og ja, vi har evnen at udtrykke nogle af de samme ideer at jeg lige har nævnt et øjeblik siden i forbindelse med Mike Smith og søger en telefon book-- ting lignende funktioner, bare handlinger, ting som løkker, der gør ting igen og igen, variabler, som er noget, vi vil indføre, men det er velkendt måske fra algebra-- blot en slags pladsholder at lagre en vis værdi, du måske brug later-- boolske udtryk, hvor dem nej eller sand falske spørgsmål fra før. Betingelser er de gafler i road-- disse filialer så at sige. Og så er der nogle mere avanceret funktioner, vi vil se selv i dag, kaldet arrays og tråde og begivenheder, at vi vil så vende i løbet af tid på forskellige sprog. Men Scratch giver os til at udforske alle disse. Så her i Scratch, denne lilla blok er, hvad en funktion er typisk vil se ud. Denne lilla brik, der har nogle ord som siger, som er den handling, og så kan det have en argument eller en parameter-- anden måde af slags tilpasning hvad denne blok gør så det er ikke på forhånd bestemt af MIT hvad denne lilla blok siger. Faktisk vil du se i en øjeblik, at jeg er i stand til at skrive de ord som hej verden, eller hej David, eller goddag Zamayla, eller hvad jeg vil, i det argument til at puslespillet piece-- den hvide boks der. I mellemtiden, hvis jeg vil have en løkke, vil vi se, at der er puslespilsbrikker, der se en lille orange som denne. Og deres form antyder slags, at der sker noget igen og igen i en cyklus. 

Så hvis jeg wrap en sige hej verden blok med et evigt blokere i Scratch, det bare at gå til med at sige hej verden for altid, helt bogstaveligt. I mellemtiden er der en anden type loop i Scratch at vi vil see-- en gentagelse block-- hvor, hvis du vide på forhånd, hvor mange gange du vil have løkken til at udføre et endeligt antal gange fact-- dig kan angive, at ved at skrive i en række eller endda tilslutte en variabel, ligesom x eller y, som vi vil se. 

Faktisk variabler som Jeg i denne sag, som er en fælles betegnelse for en heltalsvariabel, der bare gemmer en number-- et helt tal måtte være, at bruge denne appelsin blok her til sætte en variabel som jeg til nul. Her er et eksempel på grønne af en Boolsk udtryk i Scratch. Selvom dette ligner en matematik formel, matematiske uligheder som denne virkelig er booleske udtryk. Dette er enten sand eller falsk. Jeg er mindre end 50. Det er enten et ja eller nej svar eller sand eller falsk svar. Og vi vil generelt kalde disse boolske udtryk. Og det behøver ikke at være 50. Det kan være x mindre end y, større end y, lig med y-- hvilket som helst antal andre spørgsmål kan blive bedt om. 

Nu, ved første øjekast, kan det se ud pludselig ganske fed her, og det er. Men konceptet klogt, det er temmelig velkendt fra før. Hvis x er mindre end y, end sige så meget. Else hvis x er større end y, så siger så meget. Else sige x er lig med y. Så vi har et eksempel der af en tredje scenario-- den eneste tredje possibility-- x er enten større end, mindre end eller lig med. Så vi har en tre måde gaffel i vejen. 

Og mærke til, hvad er cool her-- Scratch, det synes, har kun én puslespil brik, i dette tilfælde, i hvis ellers blok. Og dog, der synes at antyde, du kan kun har en to måde gaffel i vejen. Du kan gå til venstre eller højre, men hvad med det tredje scenarie? Hvad hvis x er lig med y? Ikke noget særligt. Tag en puslespilsbrik, sætte en anden inde i den at skabe den semantiske ækvivalent om hvis, ellers hvis, else-- og nu du har din tre måde gaffel i vejen. Og som vi skal se, det Scratch puslespilsbrikker kan strækkes og vokse, så som at proppe flere ting i dem. Du behøver ikke at passe alt på sin standard størrelse. 

Det er noget vi får snart se kaldes et array. Det er ligesom en list-- en måde at lagring af flere stykker information i en variabel, ikke blot et tal. Disse vil vi se en repræsentant for noget, der hedder multi-threading. Faktisk alle dine Mac'er og pc'er i disse dage støtte multi-threading, hvilket betyder at du kan bogstaveligt gøre flere ting ad gangen. Du kan have Microsoft Word op i forgrunden, der arbejder på nogle essay. Du har måske en browser i baggrunden åbning G-mail eller Facebook eller lignende. Din computer kan gøre flere ting dag, fordi det er multi-threaded, og programmer, de er i på Især er også multi-gevind. 

Der er ting kaldet begivenheder som godt i verden af ​​Scratch, og så er der en måde også, at gøre vores egne brugerdefinerede puslespilsbrikker, hvis tingene faktisk ikke eksisterer på forhånd. Så lad os motivere dette som følger. For nogle år siden, da jeg først opdaget Scratch, da jeg var faktisk en grad studerende på MIT, vi selv fik til opgave at lave lektier. Og jeg implemented-- der, set i bakspejlet, var en meget dårlig beslutning, fordi det er den mest oprørende sang i verden at lytte til i otte timer mens du arbejder på din homework-- men noget jeg havde kaldt Oscar Time, der er måske en velkendt sang. 

CS50s ejer Jordan Hayashi, en af vores mere ledende medarbejdere, har opgraderet det for 2015 og nu 2016 da tilbage i dag, Jeg havde alt bare ind i Oscars papirkurven. Nu støtter vi genanvendelse og kompostering. 

Men at male billedet af, hvad vi kan gøre her og at motivere nogle af eksemplerne lavere niveau, kunne vi få en anden frivillige til netop kommet på op og spille min første hjemmeopgave nogensinde? Kom op. Hvad hedder du? 

HENRY: Henry. 

DAVID MALAN: Henry, kom op. Kom op. Gå enten måde, og du kan se i et øjeblik, Jeg har tænkt mig at gå videre og ramte grønt flag i øverste højre hjørnet, hvilket betyder gå. Ikonet lille stopskilt vil sige stop, og det er når du starter og stoppe programmet. Rart at møde dig. Okay. Så vi kommer til at se vejledningen på skærmen i et øjeblik. Og netop ved at spille dette spil for et par seconds-- tro mig, Vi vil ikke ønsker at spille hele vejen til den end-- du vil få en fornemmelse af, hvad programmet gør. Og mere end blot fokusere på Henry være god eller dårlig på dette spil, fokus og hvordan var det gennemført af mig oprindeligt og derefter ved Jordan. Med andre ord, hvor er de variabler? Hvor er loops? Hvor er de funktioner? Og vi vil se, om vi ikke kan se dem under emhætten. 

Bare klik og træk trash til den passende beholder. 

[MUSIK AFSPILLER] Okay. Det er rigtig godt. Hvorfor har vi ikke stoppe det der. Tak. Tillykke til Henry. Tak. 

[BIFALD] 

Forestil debugging programmet. Hvis der er et problem to minutter inde i song-- men så hvad der foregår her egentlig? Så kompliceret som det måske begynder at synes at komme over tid, faktisk mere og mere ting begyndte at falde, hvad der er interessant ved denne form for example-- og vi vil se et par others-- er, at hvis du kigge forbi kompleksitet eller sofistikerede af spillet, der er en meget enkel bygning blokke, der play-- som alle, hvis du destillere dem til dem, byggesten, er meget tilgængelige og implementerbar for sig selv. For eksempel er det været et stykke tid, men jeg er temmelig sikker på, hvad jeg oprindeligt gjorde, da gør dette spil for første gang var jeg helt ligesom forhalet. Jeg fokuserede ikke på alle på logik eller puslespilsbrikker, Jeg fokuserede på grafik og fund gaden post og papirkurven og alt dette. Men de var nødvendige ingredienser i første omgang. Og når jeg færdig procrastinating og udstikker rammerne overordnede, Jeg besluttede, lad mig lige gøre en stykke trash falde fra himlen. Og vi vil se Scratch understøtter ting kaldet sprites-- tegn, der kan har forskellige kostumer på, så de se anderledes ud. 

Og så sætter jeg en papirkurv kostume på en sådan sprite. Og jeg bare havde brug for det at falde fra himlen. Og så viser det sig, Scratch, ligesom de fleste programmeringssprog, understøtter tilfældige tal eller teknisk pseudokode tilfældige tal, således at ved at trække og droppe visse puslespilsbrikker, Jeg var i stand til at have papirkurven kommer fra venstre i første omgang. Og så næste gang det faldt, fra højre og derefter fra midten. Og hele spillet gjorde var bare har papirkurven falder ned fra himlen. Du kunne ikke pege på det, eller klik på det. Du kunne ikke åbne papirkurven. Du kunne ikke gøre noget. Men det var en baby skridt mod min ultimative vision. 

Og efter det, jeg faktisk gennemført en slags af sensing, så hvis du har klik og træk på det stykke af papirkurven over papirkurven, Oscars låg ville åbne og lukke. Intet ville ske til papirkurven, men mindst låget ville åbne og lukke. Så tjek, trin to af to. Og det er, hvad der kommer til at være nøgle i begge problem sæt nul og i programmeringen mere generelt er at tage disse meget bevidste baby skridt. Fordi ikke kun det tillader dig at føler ærligt opnået meget mere quickly-- det er den værste i verden at forsøge at gennemføre alle Oscar Time, derefter timer senere ramte den grønne flag, og intet fungerer som forventet fordi hvor vil du selv begynder at debug eller fejlfinding det program? Det er bare overvældende. 

Og så virkelig omfavne denne idé tage steps-- baby skridt igen og igen-- opbygge noget, der er, i sidste ende, virkelig imponerende og komplekse, men i første omgang, er ikke nær så meget så. Faktisk, lad os gøre det. Lad mig gå videre og-- Scratch selv findes på internettet på Scratch.MIT.edu, og du vil blive fortalt som meget igen i problemer sæt nul, specifikationen for som allerede er på CS50 hjemmeside. 

Men dette er hvad Skrab selv er. Og der er virkelig bare tre primære områder. Øverst til venstre er der er den såkaldte fase. Dette er Scratch. Standard kostume er en kat. Og dette er den rektangulære verden i som du kan move-- op, ned, venstre, højre og nogle andre ting. I midten her er vores kategorier eller vores paller af puslespilsbrikker, og forskellige farver betyde forskellige ting. Og hvis du stikke rundt, vil du se ting som loops og betingelser og variabler og andre ingredienser. 

Og så herovre er scripts område. Det er her, jeg kan trække og slippe disse puslespilsbrikker til at gøre ting. Så lad os gøre en sådan ting. Lad mig gå videre og-- og jeg ved, hvor det er. Så jeg har tænkt mig til straks at klikke på hvor jeg ved tingene er klar til at blive, men pege og klikke og rode rundt er uundgåelige. Så når grønt flag klikkede, hvad ønsker jeg at gøre? Jeg har tænkt mig at gøre dette. Jeg har tænkt mig at trække denne lilla puslespil stykke, sige hej i to sekunder, og lad mig zoome ind. 

Og jeg har tænkt mig at ændre dette at være, hvad jeg vil have det til være-- hej verden i to sekunder er fint. Nu, jeg har tænkt mig at klikke på grønt flag, eller hvis jeg virkelig ønsker, Jeg kan fuldt screene det og derefter vende tilbage. Det vil bare holde alt i ét vindue. Grøn flag-- hej verden. Okay. Ikke alt, interessant. Så lad mig gå videre og gøre dette. Lad mig prøve en anden. Når grønt flag clicked-- lad os gøre noget som en lyd. Og bemærke, at ud af boksen gratis, du får en kat lyd, som er standard sprite. Så nu lade mig gå videre og ramte den grønne flag nu. 

[Mjavende] 

Aw. Det er yndig. Jeg programmering. Så hvad har jeg gjort? Dette svarer til et program. Det er selvfølgelig super enkel. Det gjorde ikke virkelig tage så meget indsats og MIT gjorde det meste af arbejdet, men jeg har kaldt en funktion. Jeg har brugt en funktion. Jeg har lavet nogle foranstaltninger, ved hjælp af blot at en lilla brik. 

Tja, hvis jeg ønsker at gøre tre mijaver i træk? Lad mig gå videre og gøre to og tre. Og bemærke, at når du svæve i nærheden en puslespilsbrik, en lille hvid streg slags magnetisk, og det vil snap sammen, når du giver slip. Lad os se hvad der sker her. 

[Mjavende] 

Der er en fejl. Jeg hører kun én meow. Hvorfor kan det være? Ja? Ja. Vi ved ikke rigtig høre det, men det er godt intuition. De er alle spiller på samme tid. Hvorfor? Nå, er computeren bare at gøre, hvad du fortæller det til at gøre. Så hvis du siger, spille lyd, afspille lyd, afspille lyd, men du behøver ikke fortælle det til at spille, indtil du er færdig, spille, indtil du er færdig, det kommer til at blæse igennem programmet virkelig hurtig og kun hvad du fortæller det til at gøre. 

Så jeg faktisk nødt til at fastsætte dette i et par måder. Jeg kunne bare gøre det, slippe af med dette. Lad mig prøve denne anden puslespil piece-- afspille lyd meow indtil gjort, og derefter trække tre af disse og klik på Afspil. 

[Mjavende] 

Det er egentlig ikke very-- tak du-- meget naturligt. Så hvorfor ikke jeg-- lad mig gå til kontrol her. Pæn. Vent et sekund, og nu lade mig gå tilbage på lyde og spille lyd indtil gjort, og lad mig få vente et sekund. Og så lad mig gå hen og få en mere lyd, og her går vi. 

[Mjavende] 

Lidt mere naturligt, men dette er ikke særlig effektiv. Ligesom jeg var at få keder sig, alle være det kort, klikke frem og tilbage og virkelig duplikere min work-- temmelig meget kopiere og indsætte. Ja, hvis jeg Styr klikkede eller højre klikket, Jeg kunne bare have kopieres og indsættes. Hvad ville være en bedre konstruere at bruge? Hvilken idé fra før? 

Ja, så en løkke. Og i virkeligheden, hvis vi jordet, vi kan finde præcis det. Lad mig gå til begivenheder eller snarere Control. Så repeat-- jeg ikke ønsker det skal være 10 gange. Det kommer til at få irriterende hurtigt. Men jeg vil gentage tre gange. Lad mig gå tilbage til at lyde og afspille lyden, indtil det er gjort. Lad mig gå tilbage til kontrol og bare vente et sekund. Og varsel, kan du synes, det passer ikke, men igen, hvis magnetisk du lader det snap på plads, vil det vokse til at udfylde. Hvordan er det at spille nu? 

[Mjavende] OKAY. Pæn. Og det er, hvad der ville blive kaldt et program, der er også korrekt. Det meowed tre gange temmelig naturligt, men det er bedre designet. Jeg bruger mindre redundans. Jeg har ikke kopiere og indsætte noget. Jeg har lige brugt en bedre idé. 

Nu, er det stadig ikke alt, interessant med Scratch ikke gør noget. Så lad os gøre noget andet i stedet. Lad os gøre noget for evigt. Og ved du hvad? Motion virker interessant. Lad os få ham til at flytte 10 trin og ramte spille nu. 

OKAY. Nå vi kan slags træk ham tilbage, og han er stadig kører fordi han gør dette for evigt. Så sløjfen gør hvad det siger at gøre, men det er ikke alt, interessant. Lad os gøre det. Lad mig tilføje en kontrol blok, og bruge en af disse betingelser for første gang. 

Så det kommer til at flytte 10 steps-- 10 prikker, 10 pixels på screen-- så det kommer til at stille dette spørgsmål. Hvis noget er sandt, så gør noget inde i denne blok. Så det viser sig sensing har en hel bundt af Boolesk expressions-- spørgsmål af ja nej eller sand falsk form-- lade mig gøre det. 

Hvis touching-- og så er der denne lille rullemenu. Jeg kan parametrisere det. Hvis røre edge-- lad os gøre sådan noget. Så hvis rører edge-- lad mig gå tilbage til bevægelse. Og hvorfor gør vi ikke bare vende 180 grader? Okay. Så evigt, flytte 10 trin. Hvis du rører kant, drej 180 grader. Og det er ikke enden af ​​programmet fordi du er i en evigt blokere, så det kommer til at gå igen og igen og igen og igen. Så lad os se hvad der sker. OKAY. Lidt buggy, men lidt cool. 

Og vi kan tilføje til dette nogle dumme ting der er ikke så intellektuelt interessant. Men hvis vi ramte denne lille mikrofon button-- ouch. Lad mig rydde det op. Lad mig styrke dette som de ville sige på TV. Rengør det op, Gem, og nu gå op til scripts. 

Og nu, lad mig gå til lyd. Lad mig give den et navn. Jeg ringer denne ouch. Og nu afspille lyd ouch. Bemærk det vises i lille rullemenu. Lad os se. 

[AV] 

[LAUGHING] Men vi kan ændre t hans på flue. Vi kan være dobbelt så irriterende. 

[AV] 

Eller hvis vi gør det gerne 1.000 trin ved en time-- 

OKAY. Så vi kommer til at forlade, at man alene. Så igen, bygge blocks-- I gang med noget super enkel, og derefter tilsat jeg en funktion, tilføjet en funktion, tilføjet en funktion. Og jeg behøver ikke længere at bekymre sig om hvordan den første af disse funktioner blev gennemført som jeg fortsætter til lag ting på toppen. Så i virkeligheden, så lad mig gøre en anden her. Lad mig gå videre og åbne en fil, der Jeg bragte i forvejen, kaldet Sheep. 

Så det har en lidt anden tegn, der ligner dette. Og lad mig se om jeg ikke kan gøre noget ved anvendelse af en tæller i dette case-- en såkaldt variabel. Jeg har tænkt mig at gå videre og under Events-- lad mig få et grønt flag klikkede. Så lad mig gå til data, som jeg ved fra bare at spille rundt før, er hvor variabler. Og jeg har tænkt mig at gå videre og trække dette. 

Så en variabel kaldet tæller, og Jeg har tænkt mig at initialisere den til nul. Jeg kan kalde det anything-- x eller y eller z-- men i programmering, kalde noget i en semantisk nyttig måde, ligesom tæller, der beskriver, hvad det er, det er en meget nemmere at læse din kode senere. Lad mig gå videre og få et evigt blokere her. Og lad mig gå til udseende side og gøre en Say blok. Men hvad er cool om variabler er jeg behøver ikke at bare skrive noget ligesom goddag verden, som vi har allerede gjort, kan jeg i stedet gå til data og trække min variabel, og selv selvom formen ikke helt ligne det skal passe, det vil vokse til at udfylde. Og jeg vil bare sige tælleren for en second-- spoiler-- han vil tælle. Vi vil sige det i et sekund. Så jeg har tænkt mig at gå og have ham vente et sekund, så det tæller ikke op for hurtigt. Og så endelig ændre counter ved en-- med andre ord, inkrementere tælleren med én yderligere værdi og gøre dette for evigt. 

Så får også, som en programmør, tæller fra 0. Og hvis vi venter længe nok, han vil gøre dette for evigt. Men det er ikke helt sandt, fordi i virkeligheden, så vi vil opdage i uge ét, heltal og computere mere generelt teknisk kun har en finite-- godt, snarere computere, når de repræsenterer heltal, har kun et begrænset antal bit. Disse pærer der kan kun tælle så højt før du er ude af pærer. Og en computer også, kun har så meget hukommelse, kun har så mange transistorer, så det kan kun tælle så højt. 

Så det viser sig, at får, Jeg tror, ​​kan tælle til 2 mia eller noget temmelig store. Så vi kommer ikke til vente på, at det sker. Men til sidst nogle fejl vil ske der kan have nogle meget virkelige verden forgreninger. Men ud over det får, at bare introducerer en variabel. Lad os gå videre og åbne op noget jeg lavede på forhånd her kaldet Pet den Cat-- Pet Cat herovre. Og bemærke her er det kun få blokke, men når grønt flag klikkede, evigt at gøre følgende. Hvis du rører musen pointer-- så markøren på skærmen, den arrow-- play lyd meow og derefter vente to sekunder. Og bare gøre det for evigt. Bare konstant vente at se, om pointer-- hvis katten rører markøren. 

Så jeg ramte play. Intet sker. Men da jeg flytter markøren over katten, 

[Mjavende] 

Og hvis jeg flytter det væk, ikke petting katten længere. Så nogle betingede logik indlejret i en løkke. Hvad med dette eksempel, bevidst kaldet Ikke Pet Cat? Hvad er det kommer til at gøre? 

[Mjavende] 

Hvorfor skal du ikke kæle katten? 

[Mjavende] 

OKAY. Så dette er et eksempel på en if andet. Det er en beslutning, punkt og fordi det sidder i løkken, de er begge få tjekket. Er det sandt? Er det sandt? Er det sandt? Er det sandt? Og til sidst, en af de vil anvende og så du høre enten meow eller brøl af løven i denne sag. 

Nå, lad os gøre en lidt mere fancy én at jeg gjorde på forhånd too-- tråde. Så en tråd er blot én ting, at en computer kan gøre. Så en multi-threaded program er et program der kan gøre flere ting på én gang. Og alle disse eksempler hidtil har haft bare en script, så at speak-- et program som dette op her. Men bemærke dette program har to sprites, to tegn. Den ene er en fugl. Den ene er en kat. 

Og mærke, når jeg klikker på disse ned venstre, de hver især har deres egne scripts eller programmer, der er forbundet med dem. Og begge af dem programmer, varsel, starten med når grønt flag clicked-- lad os se på den cat-- når grønne flag klikkes. Og så ja, da jeg ramte play nu, to ting kommer til at ske på én gang. Katten og fuglen er både vil fungere samtidig at skabe denne effekt. Og du kan forestille dig, hvad der sker. Der er en løkke og fuglen og katten er i en sløjfe. Fuglen er bare hoppende ligesom Jeg var før, da jeg sagde ouch. Men katten har klart en fordel. Der er en anden sensing blok der peger katten bevidst til fuglen i dette tilfælde her. Så vi kunne drille hinanden, ved at se gennem disse blokke, hvad der sker. Men den vigtigste ingrediens her er en. Fuglen, således at dette spil er ikke helt boring-- eller denne animation-- starter ved en tilfældig retning. Og computeren er picking et tal mellem 90 og 180 væsentlige, så det er en lidt forskellige animation hver gang. 

Og så mærke til her, hvis det kat rører fuglen, så spille løven fire sound-- brøl. Men i mellemtiden i fuglens palet, vi har dette. Forever, hvis ikke røre katten, bare holde flytte tre trin. Og så her er en anden brik. Hvis du er på kanten, hoppe. Så fuglen er lige slags pasning sin egen virksomhed, bare flyver rundt og hoppende, og det er virkelig den kat, der havde den betingede logik at afgøre, om den havde fanget fuglen. Okay. Så lad os gøre en anden her, denne ene bliver kaldt Hej Hej Hej. Og denne ene her gør bare dette i et evigt loop. Men notice-- hvordan vi stopper dette meget irriterende program? Hit på mellemrumstasten. For hvis jeg gør det, venstre program-- bemærke det er konstant listening-- er nøglen plads pressen. Hvis mellemrumstasten presset, og hvis ja, hvad gør det? Det gør en meget almindelig teknik. Det sætter en variabel svarende til en vis værdi. Men det skifter denne værdi. [? Så udseende?] baseret på shape-- I har en variabel, som jeg skrev på forhånd kaldet Slået fra, som bare siger ja eller nej. Er lyden slået fra eller ej? Sandt eller falsk? Og varsel, jeg siger denne-- hvis dæmpede er nul, og derefter skifte til en, ellers sæt mute den til nul. Så bare vende værdien fra nul til én. Jeg kunne have done-- ændre det fra to til tre og 01:57 eller 4:56 eller fire til seks. Men det gør ikke noget hvilke tal jeg bruger, så længe jeg holder ændre det modsatte. 

Og de fleste enhver programmør ville bare vælge nul og en-- falsk og sandt, off og on-- at repræsentere dette. Og det kører stadig. Hvis jeg ramte mellemrumstasten igen 

[SEAL SOUNDS] 

Programmet kører stadig. Fordi der er dette andet script der siger, for evigt gøre følgende. Hvis dæmpet variabel lig zero-- så hvis du ikke er slået er logic-- hvis det er falsk eller nej, så spiller lyden, fordi du ikke er slået. Du bør afspille lyden og derefter tror hi hi hi for to sekunder og derefter vente, og gøre det igen og igen og igen. 

Og så på den måde har vi en måde for folk at-- for programmer til at interagere. Og de behøver ikke at være som dateret som andre. Faktisk stikke around-- ingen ordspil intended-- nogen brugt en enorm mængde af tid på internettet gennemføre PokemonGo i Scratch. Det geolocates selv du i Cambridge eller Allston her. Så hvis du ønsker at se alt for, hvad folk kan gøre, er denne-- meget fancy menu. Klik på her. 

Det er mig med min piletasterne nu. Jeg har tænkt mig at gå efter dette. Klik. Og nu klikke dig Pokeball. Jeg mener, jeg tror, ​​du er formodes at klikke på Pokeball. Okay. Så jeg gjorde det. Jeg kan gå over her. Og denne person implementeret nogle flere Pokeballs end her-- tre Pokeballs. 

Vi vil sende et link til denne online, så du kan spille. Men varsel er der bare nogle grundlæggende byggesten. Det ser meget avanceret, og det er. Det er imponerende og mere end vi ville typisk forventer, i hvert fald for problem sæt nul. Jeg har ingen idé om, hvor lang tid denne person brugt online. Men det hele er bare en løkke. Der er en lyd afspilles. Der er en slags løkke lytte efter, om jeg er rammer på pil op eller ned pil eller venstre og højre, og derefter, hvis det er tilfældet, er det at flytte det nogle antallet af pixels. Og derefter, hvis jeg klikker på en anden sprite, der er en slags hvis betingelse der. Ja, det bliver for intens. Vi kommer til at stoppe. Det er alle disse grundlæggende byggesten. Der er ikke andre andre ingredienser end dem, vi har kigget på allerede. 

Og alligevel her, så lad mig gøre en sidste sæt af eksempler der tegner et billede for af hvad du kan gøre her. Her er en meget simpelt program, der bare gør denne-- hoste, hoste, hoste. Og kun baseret på hvad Vi har kigget på hidtil, hvor er det oplagte mulighed for forbedringer. Dette program er korrekt. Det hoster tre gange, hvilket er, hvad jeg hensigten. Men det er dårligt gennemført. Det er dårligt designet. Hvorfor? Ja. Det er ikke en løkke. Og det er ikke så meget at det ikke er en løkke, det er, at der er en masse redundans. Der er kopieret og indsat kode, så at sige. Og løsningen sandsynligvis er faktisk en løkke. Så lad mig gå videre og forbedre det. Og jeg har tænkt mig at trække disse over her. Lad mig gå videre og få en gentagelse blok, ændre dette til tre. Jeg har tænkt mig at smide nogle af disse blokke. 

Og du vil opdage det er temmelig intuitiv. Du trække og slippe, og tingene og forsvinder med tiden. Og jeg kan bare trække dette i her og nu har jeg en renere udgave stadig. Men ved du hvad? Der er denne mulighed nu for abstraction-- at begynde at definere nye ordforråd at MIT ikke forudse. Der er vente og gentag og for evigt, og hvis, men hvad hvis jeg ønsker at indføre ordet hoste som en blok? Hvad hvis jeg ønsker et puslespil brik hvis formål i livet er at hoste? 

Nå, lad os se på denne version her, som jeg gjorde som følger. Magisk, jeg har skabt denne brik her, som Scratch tillader dig at gøre. Og faktisk C og Python og JavaScript er vil tillade dig at gøre det så godt. Du kan oprette dine egne brugerdefinerede stykker, som du kalder det, du ønsker. I dette tilfælde, hoste føles som en rimelig definition. Og så med disse stykker ned Her kan du definere, hvad det betyder. 

Jeg slæbte og faldt fra denne palet her-- mere blocks-- denne store lilla blok, hvor jeg har skrevet i hoste som navnet på min nye brik. Og så jeg siger enhver tid en bruger kalder denne nye hoste puslespilsbrik, gøre indflydelse og en ventetid. Og så heroppe i min gentage blok, Jeg kan bare hoste tre gange. 

Og jeg vil hævde, især Hvis nu du skjule denne detalje. Hvem bekymrer sig, hvordan hoste implementeres? Alt jeg holder af som en programmør, som jeg kan hoste. Jeg er ligeglad hvordan siger implementeres. Jeg ligeglad bare, at den kat kan sige noget. Jeg kan abstrakt væk, at detaljer og kun fokusere på hvad der er på skærmen her. Men jeg kan tage et skridt videre. 

Bemærk, at her, jeg har gennemført sløjfen tre gange. Men hvad hvis man i stedet jeg gribe denne version? Og hvad hvis man i stedet i denne version her, Jeg bare ændre min brik til at tage et argument og input i sig selv? Og at input kan være et tal som tre. Så nu, hvis jeg skriver et program og jeg vil have katten til at hoste, Jeg kan faktisk fortælle puslespillet stykke, hvor mange gange at hoste, fordi der på bunden her, en amatør version af disse brugerdefinerede puslespilsbrikker lader mig præcisere, at hoste faktisk tager en input-- tager et argument som denne. Og ved du hvad? Måske jeg indser, vent et øjeblik. Hoste er same-- det er fundamentalt den samme idé som nysen. Det er bare en anden ord på skærmen. Jeg kan abstrakt væk yderligere og gennemføre denne endelige udgave af et hoste, som ved første øjekast er langt mere kompleks leder. Men mærke til, hvad jeg har gjort. Jeg har nu generalized-- genericized really-- denne puslespilsbrik at blive kaldt sige ord n ​​gange. 

Og nu har jeg to nye puslespilsbrikker hernede definere hoste n gange. Og hvad betyder det hoste funktionen gøre? Hvad betyder min brugerdefinerede puslespilsbrik gøre? Det opfordrer bare sige blok, passerer i det ord, jeg ønsker at sige, passerer i antallet gange jeg ønsker at sige. Fordi nu kan jeg implementere nyse ved blot at sige Achoo, i dette tilfælde nogle antal gange. 

Og så jeg lagdeling og lagdeling. Og igen, det centrale her er ikke hvordan jeg implementeret det, men det faktum, at hvis jeg bare bogstaveligt flytte disse ud af skærmen, se hvordan enkel, hvis ikke temmelig mit program ser ud nu. Fordi det gør, hvad det siger, jeg har abstraheret væk, hvad der er indeni, der sorte boks. Det sker for at være en lilla ramme, men jeg har blokeret væk hvad der er indeni fordi jeg er ligeglad, hvordan det fungerer. Jeg bare ligeglad nu, at det virker. 

Og ja, i problem sæt nul, det er præcis den slags lagdeling af idéer, du har mulighed for at udforske. Det er præcis af muligheden for at anvende problemløsning teknikker, til, hvad der er sandsynligvis en ukendt miljø. Og om du har ikke programmeret før eller programmeret før, du opdage, at der er lidt noget i dette miljø for alle. Og med problemet sæt en i en uges tid, vi vil skiftet til fokusering på et højere niveau sprog kaldet C-- eller snarere en lavere niveau sprog kaldet C-- der er endnu mere kraftfuld, selv om det er lidt mere kryptisk ved første øjekast. 

Og du vil indse per dag TL: DR, at dette problem sæt har en kortere vindue af tid end fremtidige dem, simpelthen fordi du skal finde det rimeligt tilgængelig. Og ikke at bekymre dig, hvis du tilføjer klassen sent. Vi vil tage fat, at inden længe. Og før vi udsætte til kage, lad os slut af med blot to minutters udseende på, hvad der venter dig her i CS50. [MUSIK AFSPILLER] Okay. Det var det for CS50. Vi vil se dig snart. Kage er nu serveret. [MUSIK AFSPILLER] SPEAKER 17: Har du hørt af et sabbatår, chef? SPEAKER 18: Måske er der mere under kølerhjelmen. 