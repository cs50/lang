[МУЗЫКА] DAVID J. Малан: Хорошо, это CS50. И это одна неделя. Так Напомним, что в последний раз в нулевой неделе, мы сосредоточились на вычислительной мышления. И мы перешли от того, чтобы Царапины, графическое программирование язык от наших друзей в медиа-лаборатории Массачусетского технологического института. 

И с нуля, так и мы исследуем идеи, как функции и условия, и петли, и переменные, и даже события и темы, и многое другое. И сегодня, мы будем продолжать использовать эти идеи, и действительно принимая их за как должное, но перевести их на другой язык, известный как C. Теперь, C представляет собой более традиционный язык. Это более низкий уровень язык, если вы будете. 

Это чисто текстуально. И так, на первый взгляд, это все будет выглядеть довольно загадочным если вы никогда не программировали ранее. Мы будем иметь точка с запятой, и круглые скобки, и фигурные скобки, и многое другое. Но поймите, что даже хотя синтаксис о том, чтобы выглядеть немного незнакомой большинству из вас, видеть прошлое. И попытаться увидеть идеи что, действительно, знакомые, потому что здесь, в неделю один, что мы начнем делать это сравнение, Первоначально, Царапины по сравнению с C. 

Так, например, вспомнить, что, когда мы реализован первый из наших программ в прошлый раз, у нас был блок, который выглядел немного что-то вроде this-- когда это зеленый флаг щелкнул, а затем мы имели один или более частей головоломки под ним, в этом случае, скажем, привет мир. Так что, на самом деле, в пустом месте, когда я нажимаю, что зеленый флаг чтобы запустить свою программу, так говорить, это блоки, которые получают выполняются, или бежать. И, в частности, к царапинам сказал, привет, мир. 

Теперь, я мог бы уточнили разные слова здесь. Но мы видим, что, действительно, многие из этих blocks-- и на самом деле, в C много functions-- может быть параметризовано или заказной делать разные вещи. В самом деле, в C, если мы хотите конвертировать, в настоящее время, эта программа Царапина на этот другой язык, мы собираемся написать мало что-то вроде этого. 

Конечно, есть некоторые незнакомые синтаксис там, скорее всего, Int, и круглые скобки и недействительными. Но printf-- даже если вы бы думаю, что это будет просто распечатать. Но печать означает печать отформатирован, как мы скоро увидим. Это в буквальном смысле будет печатать к экрану независимо находится внутри этих скобок, которая Конечно, в данном случае, привет мир. 

Но вы заметите некоторые другие Синтаксис, некоторые двойные кавычки, что круглые скобки в конце, полу-ободочной кишки и тому подобное. Таким образом, есть несколько накладных расходов, так сказать, как познавательно и синтаксически, что мы собираемся чтобы помнить, прежде чем долго. Но понимаю, что с практикой, это начнет выскакивать на вас. 

На самом деле, давайте сосредоточимся на том Функция specifically-- в этом случае, сказать привет мир. Так сказать, это функция. Привет мир является параметром, или аргумент, его настройки. 

И эквивалентность в С просто будет это одна строка здесь, где Printf эквивалентно, скажем, двойной кавычки, привет мир эквивалентно, конечно же, к тому, что в белой коробке там. И обратный слеш н, хоть сколько-нибудь странно и отсутствует на пустом месте, просто будет иметь эффект, мы будем см в компьютере, как мой Mac или PC, просто перемещая курсор на следующую строку. Это как удар Введите на клавиатуре. 

Таким образом, мы видим, что снова в скором времени. Но во-первых, давайте взглянем на это Другой пример, в случае петель. Мы должны были это навсегда петлю в последний раз, который был ряд головоломки что сделал что-то в буквальном смысле forever-- в данном случае, сказать, привет мир, привет мир, привет мир, привет мир. Так что это бесконечный цикл, в соответствии с проектом. 

В C, если мы хотим, чтобы это реализовать Та же идея, мы могли бы просто сделать это. В то время как верно, Printf привет world-- прямо сейчас в то время, как раз семантически, вид навевает мысль делать что-то снова, и снова, и снова, и как долго? Что ж, напомним, что true-- правда, это только на один или. 

И правда, это, конечно же, всегда верно. Так что это своего рода бессмысленная заявление просто сказать, правда. Но на самом деле, это преднамеренное, потому что, если правда, то как раз всегда верно, чем в то время как верно как раз подразумевает, если немного косвенно, что следующие строки кода между этими фигурными скобками нужно просто выполнить снова, и снова, и снова, и никогда не останавливаться. 

Но если вы хотите, чтобы ваши петля, чтобы остановить, как мы в прошлый раз с чем-то вроде это, повторите следующие 50 раз, в С мы можем сделать то же самое с тем, что называется для loop-- ключевое слово не будучи в то время как, но для. И тогда у нас есть некоторый новый синтаксис здесь, с междунар я равен 0, я меньше, чем 50, я ++. И мы вернемся к этому. Но это просто как бы мы перевести множество блоков скреста к набору C строк кода. 

В то же время, рассматривать переменные. И в самом деле, мы просто видел один минуту назад. И в случае нуля, если мы хотел объявить переменную I для я быть целым числом, просто число, и мы хотим, чтобы установить его до некоторого значения, мы будем использовать этот оранжевый блок here-- установить я до 0. 

И мы видим сегодня и за его пределами, так же, как на прошлой неделе, программисты делают почти всегда начать отсчет с нуля, на самом деле условно. Но и потому, что отзывает наше обсуждение двоичной, наименьшее число вы можете представлять с любым количеством битов только собирается быть 0 сама. И поэтому мы как правило, начинают инициализируя даже наши переменные 0. 

А в С, чтобы сделать то же самое, мы будем говорить Int для целого числа, я только по соглашению. Я мог бы назвать эту переменную все, что я хочу, так же, как в пустом месте. И тогда равна 0 только правопреемников значение 0 с правой стороны и помещает его в переменную, или контейнер для хранения там, на левой стороне. И полу-ободочной кишки, как мы see-- и мы уже видели некоторые из этих already-- просто означает конец мысли. Продолжайте делать что-то другое на линиях, которые следуют. 

Теперь, что касается логических выражений? Напомним, что в пустом месте, они были выражением которые являются либо истинными или false-- вопросы, на самом деле, которые являются либо истинными, либо ложными. Таким образом, в случае нуля, мы могли бы задать простой вопрос, как это, это я меньше, чем 50? Так что я, опять же, является целым числом. Может быть, мы используем его в программе Скретч следить за счетом или что-то типа того. Так что этот синтаксис здесь в пустом месте просто означает, это я меньше, чем 50? Ну, к счастью, что-то простой в C. И переводить, это мы бы просто сказать, что я меньше чем 50, используя знакомый ключ на клавиатуре. 

В то же время, если вы хотите сказать что-то более общее, как, хорошо, х меньше у, где каждый х и у сами по себе являются переменными? Мы можем сделать то же самое в С, до тех пор, как мы создали эти переменные уже. И мы увидим, как сделать это в скором времени. Мы просто сказали бы х меньше у. 

Таким образом, вы начинаете увидеть некоторые общие черты. И те люди, которые сделали Царапины были, конечно, вдохновлены некоторые из этих основных идей. И вы увидите, этот вид Синтаксис во многих languages-- а не просто на пустом месте, не просто C, но Python, и JavaScript, и другие языки до сих пор. 

Рассмотрим другую конструкцию от C, понятие состояния, делать что-то условно. Если что-то верно, то это сделать. Если что-то еще, правда, сделать это. Это своего рода программирование эквивалент развилки. Может быть, это двусторонняя вилка, трехходовой вилка, или больше. И в пустом месте, мы могли бы иметь видел что-то вроде этого. 

Так что это одна большая одна. Но рассмотрим относительное Простота логики. Если х меньше у, то говорят х меньше чем у, иначе, если х больше у, то говорят х больше у. И тогда, по логике вещей, если вы вспомните нуля или просто свой собственный человеческой интуиции, хорошо, если х не больше, чем у, и х не меньше, чем у, то, конечно, х будет равен у. Так что в этом случае, по вложенности эти Скретч блоки, мы можем достичь трех способ развилка? 

В то же время, если мы хотим сделать это в C, это возможно выглядит немного simpler-- по крайней мере, как только вы получите знакомы с синтаксисом. Если х меньше у, Printf х меньше у. Иначе, если х больше у, Printf х больше у. Иначе Printf х равно y-- и, опять же, с теми, обратная косая черта заканчивается просто для тех новых линий, так что если вы на самом деле запустили этот вид программы было бы просто переместить курсор в конечном счете, к следующей строке экрана. 

Теперь, тем временем Царапина была другая более сложные функции, только некоторые из которых мы собираемся изначально двигаться по всему миру, С. И один из них был называется списком в пустом месте. И это был особенный тип переменной, позволило хранить несколько вещей в нем назад, к спине, к спине, к спине. 

В C, он не имеет списки, сами по себе, но что-то которые в более общем смысле называется массивы, хотя мы вернуться позже в этом семестре смотреть на что-то называется список, или действительно связанный список. Но сейчас, ближе всего эквивалент в C для нас будет что-то называется массивом. И массив просто особый тип переменной что позволяет хранить данные назад, к спине, к спине, к спине. 

И действительно, в пустом месте, если мы хотим получить доступ первый элемент массива или list-- и я буду называть его, По соглашению, ARGV, аргумент вектор, но об этом в скором времени. Если я хочу, чтобы получить на первом элементе из ARGV, в мире нуля вы на самом деле, как правило, начать отсчет с 1. 

И таким образом я мог бы получить пункт 1 ARGV. Это просто, как реализуется MIT понятие списков. Но в C, я собираюсь проще просто сказать, ARGV, что опять-таки это имя моего list-- или быть ясно, массив. А если я хочу первым элементы, я собираюсь использовать квадратные скобки, которых вы возможно, не часто используется под клавиатурой. 

Но 0 просто означает, поймите меня первым. Так что в некоторых случаях, и как проходит время, мы будем чтобы начать видеть эти дихотомии между нуля и С, в результате чего Царапина использует один. Мы в C использовать 0 здесь. Но вы быстро поймете, как только вы понимаете основы каждого языка, т.е. эти вещи начинают становиться все более знакомую по практике и практике. 

Так что давайте на самом деле теперь посмотрите на программу. Здесь должно быть первым из нашей C Исходный код для полных программ. А программа, которую мы предложить для рассмотрения это тот, который эквивалентен к этому ранее Скретч кусок. 

Так что здесь, у нас есть то, что возможно, самая простая программа C Вы можете написать, что на самом деле что-то делает. Теперь мы рассмотрим прошлое, на данный момент, уже включают в себя, стандарт io.h, и эти угол скобки, и INT, и пустота, и фигурных скобок, и тому подобное. 

И давайте просто сосредоточиться на то, что, по крайней мере, интуитивно, может выскочить на тебя уже. На самом деле, главным образом, я не обязательно знать, что это такое, но так же, как было нуля, что, когда зеленый флаг щелкнул кусок головоломки, так что делает C в качестве языка программирования имеют основную часть кода, который запускается на выполнение по умолчанию. И действительно, это в буквальном смысле будет называться главной. 

Таким образом, основная функция. И это специальная функция, которая существует в C, что при запуске программы, это главный, который получает в ведении по умолчанию. В мире нуля, это, как правило, когда зеленый флаг нажал, что получил по умолчанию запускается. 

В то же время, мы уже видели это раньше, Printf или печать отформатирован, это будет функция, которая поставляется с C, наряду с целым букетом других, что будет время и время от опять же, для того, чтобы сделать точно как предполагает его название, напечатать что-нибудь. Что мы хотим напечатать? Ну, мы увидим, что заключая символов как these-- привет мир, обратная косая п в двойных кавычках, мы можем сказать точно Printf что печатать на экране. 

Но для того, чтобы сделать что мы, к сожалению, нужно взять что-то уже загадочным для нас, людей, но по крайней мере это несколько readable-- острые включают, стандарт io.h, INT, Основной, недействительным, Printf, все магические заговоры мы только что видели на экране. Но мы на самом деле должны пойти более аркан до сих пор. Сначала нужно перевести код что мы пишем в машинный код. И помните из прошлой недели, что машины, по крайней мере, те, которые мы знаем здесь, в конце дня только понимать, нули и единицы. 

И, Боже мой, если бы нам пришлось писать эти нули и единицы на самом деле программы, это было бы очень, очень быстро принять удовольствие от чего-либо. Но оказывается, за последнюю неделю, что эти модели нулей и единиц просто имеют особое значение. В некоторых контекстах, они могут означать число. 

В некоторых случаях, они могут означать буквы, или цвета, или любое количество других абстракций там на. Но так же, как ваш компьютер имеет центральный процессор, центральный процессор, или мозги внутри вашего компьютера. Это, как правило, Intel внутри, потому что это одна из крупнейших компаний что делает процессоры для компьютеров. 

Ну, процессоры Intel и другие просто решили заранее что некоторые модели нулей и из них означают конкретные вещи. Некоторые модели нулей и единиц будет означать, распечатать это на экран, или добавить эти два числа, или вычесть эти два числа, или переместить эту часть данных из память моего компьютера здесь, или любое количество других очень низкого уровня, но в конечном счете, полезно, операции. Но, к счастью, мы, люди не собираются необходимо знать этот уровень детализации. В самом деле, так же, как в прошлый раз, когда мы абстрагируется снова, и снова, и снова, Здание с очень низкого уровня примитивы как нулей и единиц к повышению уровня понятий как цифры и буквы, и цвета, и многое другое, так мы можем как программисты стоять на плечах другие, которые приходят перед нами и использовать программное обеспечение, что и другие люди писали ранее us-- а именно программы называется компиляторы. 

C является языком, который как правило, составляются, что означает преобразованы из Исходный код в машинный код. В частности, это означает, что в том, что если у вас есть свой источник код, который вы сами пишете, как мы скоро будет через мгновение на экране, и вы хотите, чтобы преобразовать его в конечном счете, к машине code-- эти нули и единицы, которые только ваш Mac или ваш компьютер understands-- вы получили первый кормить этот исходный код в качестве вход в специальный Программа под названием компилятор, выход которого мы увидим это машинный код. И, действительно, в прошлый раз мы говорили о, на самом деле, в конце концов, решение проблем. У вас есть входы. И у вас есть выходы. И у вас есть какие-то алгоритма в середине. 

Алгоритмы могут быть, конечно, реализованы в программном обеспечении, как мы видели с псевдокода на прошлой неделе и, как мы увидим, с фактическим кодом на этой неделе. И поэтому компилятор на самом деле просто имеет набор алгоритмов внутри об этом, что знают, как преобразовать специальные ключевые слова, как основной, и Printf, и другие, которые мы просто увидел в узорах и нулей те, что Intel внутри и другие процессоры на самом деле понимает. Итак, как мы это сделаем? Откуда мы получаем компилятор? 

Большинство из нас здесь есть Mac или ПК. И вы работаете Mac OS, или Для Windows или Linux или Solaris, или любое количество других операционные системы. И действительно, мы могли бы выйти на сеть и скачать компилятор для вашего Mac или ПК для конкретной операционной системы. Но мы все были бы на разные страницы, так сказать. Мы должны были бы немного различные конфигурации. И вещи не будут работать все равно. И, действительно, в эти дни многие из нас не используют программное обеспечение, которое работает только на наших ноутбуках. Вместо этого мы используем что-то как в браузере, позволяет нам получить доступ к веб- приложения в облаке. А позже в этом семестре, мы будем делать именно это. Мы будем писать приложения или программного обеспечения с использованием code-- не C, но и другие языки, такие как Python и JavaScript--, которые работают в облаке. 

И сделать это, мы сами в течение семестра будет на самом деле использовать облако основе среда известна как CS50 IDE. Это веб-программирование охрана окружающей среды, или комплексное развитие среда, язь, который построен на вершине некоторых Программное обеспечение с открытым исходным кодом под названием Cloud 9. И мы сделали некоторые педагогические упрощений к нему с тем, чтобы скрыть определенные черты первые недели, которые нам не нужны, после чего вы можете раскрыть их и сделать большинство все, что вы хотите с окружающей средой. 

И это позволяет нам, тоже, чтобы предварительно установить определенное программное обеспечение. Такие вещи, как так называемый CS50 библиотека, которую мы скоро увидим дает нам в C с некоторыми дополнительные функциональные возможности. Так что если вы идете, в конечном счете, CS50.io, Вам будет предложено войти в систему, и как только вы делаете, и создать счет бесплатно, вы будете иметь возможность получения доступа к среда, которая выглядит совсем так. 

Теперь, это находится в режиме по умолчанию. Все красиво и ярко на экране. Многие из нас имеют привычку работающих на CS50 кусок, что это довольно поздно в ночь. И вот некоторые из вас могли бы предпочесть превратить его в ночной режим, если можно так выразиться. 

Но, в конечном счете, что вы собирается увидеть в CS50 IDE есть три различных areas-- область на левой части, где ваши файлы будут в облако, область в правом верхнем углу где ваш код будет редактировать. Вы сможете открыть отдельные вкладки для любой программы что вы пишете в этом семестре внутри этого в верхнем правом углу. И тогда самый arcanely, и тем не менее мощно, будет ли это быть на снизу известный как окно терминала. 

Это старая школа Интерфейс командной строки, или CLI, что позволяет выполнять команды на computer-- в данном случае, компьютер в cloud-- делать такие вещи, как скомпилировать код из исходного кода в машинный код, запускать программы, или начать свой веб-сервер, или для доступа к базе данных, и любое количество других методов что мы начнем использовать в скором времени. Но чтобы попасть туда, мы собирается на самом деле есть выходить в интернет и начать играть. И сделать это, давайте сначала начать мастерить с главной, и написать основную часть программы. И давайте использовать эту функцию Printf, который мы использовали ранее, просто что-то сказать. 

Так вот я уже внутри CS50 IDE. Я вошел заранее. И я полный скрининг окно. И так, в конечном счете, вы тоже в ближайшие проблемы будут следовать аналогичные шаги, предоставит документацию. Так что вам не нужно беспокоиться о поглощая каждый маленький технический шаг что я делаю здесь сегодня. 

Но вы получите экран, как это. Я, случается в ночном режиме. И вы можете украсить все вверх путем отключения ночного режима. И в конце день, вы будете видеть эти три основных areas-- файла браузер слева, кодовые вкладки наверху, и окно терминала в нижней части. 

Позвольте мне идти вперед и написать свою первую программу. Я собираюсь превентивно идти в файл, Сохранить и сохраните свой файл как hello.c. Действительно, в соответствии с соглашением, любая программа, которую мы пишут, что написано на языке C должен быть назван что-то точка с, в соответствии с соглашением. Так что я собираюсь назвать его hello.c, потому что Я просто хочу сказать привет к миру. Теперь я собираюсь увеличить , и нажмите кнопку Сохранить. И все, что я сейчас здесь вкладка в котором я могу начать писать код. 

Это не будет компилировать. Это ничего не значит. И поэтому даже если я преобразовал это нулей и единиц, процессор будет иметь не Идея, что происходит вокруг. Но если я пишу строки, которые соответствуют с conventions-- C представляют собой С, в опять же, это language-- с синтаксисом, как это, Printf привет world-- и я имею получили комфортно делая это в течение долгого времени. Так что я не думаю, что я сделал любые типографские ошибки. 

Но неизменно, самый первый раз, когда вы сделаете это, вы будете. И то, что я собираюсь сделать, может очень а не работать для вас в первый раз. И это совершенно нормально, потому что прямо сейчас вы может просто увидеть целую много новизне, но с течением времени, как только вы освоитесь с этой средой, и этот язык, и другие, вы начнете видеть вещи, которые либо правильно или неправильно. 

И это то, что обучения стипендиатов и конечно помощники получают так хорошо в течение долгого времени, является пятнистость ошибки или ошибки в коде. Но я утверждаю, что есть нет ошибок в этом коде. Так что я теперь хочу, чтобы запустить эту программу. 

Теперь на моем собственном Mac или PC, я в привычка двойных иконок щелкая когда я хочу, чтобы запустить какую-то программу. Но это не модель здесь. В этой среде, которая является CS50 IDE. Мы используем операционную Система под названием Linux. Linux напоминает другое операционная система, как правило, известны в Unix. И Linux особенно известен имеющий командной строки по окружающей среде, CLI. Теперь мы используем специфически вкус Linux под названием Ubuntu. И Ubuntu просто определенная версия Linux. 

Но эти системы Linux в эти дни делают на самом деле поставляются с графическим интерфейсом пользователя. И тот, который мы, случается, использовать здесь веб-. Так что это может выглядеть даже немного отличается от чего-то Вы сами могли бы иметь видел или запустить в прошлом. 

Так что я собираюсь идти вперед сейчас и сделайте следующее. Я сохранил этот файл как hello.c. Я собираюсь идти вперед и Тип clanghello.c Так Clang для языка C является компилятор. Это предварительно установлена ​​в CS50 IDE. И вы можете загрузить и абсолютно установить это на вашем собственном Mac или PC. 

Но, опять же, вы бы не все предварительная конфигурация делается для вас. Так что на данный момент, я просто собирается запустить clanghello.c. А теперь обратите внимание этот синтаксис здесь, в конечном счете понимают, просто означает, что я нахожусь в папку или каталог с именем рабочего пространства. Этот знак доллара просто конвенция смысла, введите ваши команды здесь. 

Это то, что называется быстрое, просто по соглашению является знак доллара. И если я иду вперед сейчас и нажмите Enter, ничего, кажется, не произошло. Но это на самом деле хорошая вещь. Чем меньше, что происходит на ваш экран, тем более вероятно, ваш код должен быть правильным, по крайней мере, синтаксически. 

Так что, если я хочу, чтобы запустить эту программа, что мне делать? Что ж, получается, что имя по умолчанию в соответствии с соглашением для программ, когда вы не укажете Фамилия, имя, ваша программа просто a.out. И этот синтаксис тоже, вы будете ознакомиться с ранее долго. 

Дот слэш просто означает, эй, CS50 IDE, запустите программу под названием a.out что внутри моего текущего каталога. Это точка означает текущий каталог. И мы посмотрим, что другие такие последовательности символов означает, в скором времени. 

Так что здесь мы идем, Enter, привет мир. И вы заметите, что случилось? Мало того, что это напечатать привет мир. Он также переместил курсор на следующую строку. 

И почему это было? Какой код, который мы писали ранее что гарантировал, что курсор будет перейти на следующую строку? Забавно, что про компьютер это только собирается делать буквально то, что вы скажете ей сделать. 

Так что если вы скажите ему PRINTF привет, запятая, пробел, мир, близко цитаты, это буквально только собирается печатать эти символы. Но у меня был этот особый характер в конце, напомним, обратной косой п. И вот что обеспечило что персонаж пошел к следующей строке экрана. 

На самом деле, позвольте мне пойти и сделать это. Позвольте мне идти вперед и удалить это. Теперь, обратите внимание, что Верхняя часть моего экрана есть маленький красный свет в вкладка с указанием, Эй, вы не сохранили файл. Так что я собираюсь идти вперед с контролем S или команду S, сохраните файл. Теперь goes-- пошел на moment-- зеленый. А теперь он вернулся к просто быть рядом значок. 

Если я теперь запустить clanghello.c снова, Enter, точка слэш, a.out, Enter, вы увидите, что она по-прежнему работает. Но это, возможно, немного глючит. Сейчас мой prompt-- рабочее пространство, а затем, что знак доллара, а затем мой фактический prompt-- все в той же строке. Так что это, конечно, эстетическая ошибка, даже если это на самом деле не логическая ошибка. 

Так что я собираюсь отменить то, что я только что сделал. Я собираюсь повторно запустить a.out. Обратите внимание, я добавил символ новой строки обратно. Я сохранил файл. 

Так что я собираюсь повторно запустить a.out, и-- Проклятье, ошибка, ошибка, это означает ошибку. Таким образом, ошибка в том, что несмотря на то, Я добавил обратный слэш н там, повторно сохранены, повторно запустил программу, поведение было то же самое. Почему бы это? 

Я отсутствует шаг, не так ли? Это ключевой шаг раньше было то, что у вас есть когда вы, целью которых изменить исходный код, оказывается также запустить это через компилятор снова так что вы получите новый машинный код. И машинный код, нули и единицы, будут почти идентичны, но не совсем так, потому что нам нужно, конечно, что новая линия. 

Таким образом, чтобы исправить это, я буду нуждаться перезапускать clanghello.c, введите, точка слэш, a.out. И теперь, привет мир вернулся туда, где я ожидаю, что это будет. Так что это все прекрасно и хорошо. Но a.out это довольно глупое имя для программа, даже если это случается, по историческим причинам, default-- означает монтажные выходы. 

Но позвольте мне идти вперед здесь и делать это по-разному. Я хочу, чтобы мой привет мир программа на самом деле можно назвать привет. Так что, если бы это был значок на моем рабочий стол, он не будет a.out. Это будет называться привет. 

Таким образом, чтобы сделать это, оказывается, что Clang, как и многие другие программы, поддерживает аргументы командной строки, или флаги, или переключатели, которые просто влияют на его поведение. В частности, Clang поддерживает тире O флаг, который затем занимает второе слово. В этом случае, я буду как угодно, но разумно, назвать это привет. Но я мог бы назвать это ничего Я хочу, за исключением того, что a.out бы скорее к тому же точки. 

А потом просто указать имя файла я хочу собрать. Так что теперь, даже если в начале команды я до сих пор есть Clang, в конце команды Я до сих пор имя файла, Теперь у меня есть эти командной строки аргументы, эти флаги, которые говорят, ой, кстати, вывод-о, файл называется привет, а не a.out по умолчанию. 

Так что, если я ударил Введите сейчас, ничего по-видимому, произошло. И, тем не менее, теперь я могу сделать точечный слэш привет. Так что это та же программа. Нули и единицы идентичны в конце дня. 

Но они в двух разные files-- a.out, которая является первой версией и просто по-дурацки имени, и теперь алло, который является намного более убедительным название программы. Но, если честно, я никогда будет помнить это снова, и снова, и снова. И, на самом деле, как мы пишем более сложные программы, команды, которые вы будете придется написать собираются получить даже Чем сложнее еще. 

И так, чтобы не волноваться. Оказывается, что люди, прежде чем мы поняли, что они слишком было это точно такая же проблема. Они тоже не получили того, чтобы типа довольно длинные, загадочные команды, не говоря уже помню их. И так люди перед нами сделали другие программы, которые облегчают для компиляции программного обеспечения. 

И в самом деле, одним из таких Программа называется Make. Так что я собираюсь идти вперед и делать это. Я собираюсь отменить все, что я только что сделал следующим образом. Позвольте мне типа LS. И вы заметите три things-- a.out, и звезда, привет и звезда, и hello.c. Будем надеяться, что это должно быть немного интуитивными, поскольку ранее было нет ничего в этом рабочем пространстве. Там не было ничего, что у меня было создан, пока мы не начали класс. 

И я создал hello.c. Затем я скомпилировал его, и назвал его a.out. А потом я скомпилировал его снова слегка по-другому и назвал его привет. Поэтому у меня есть три файла в этом каталоге, в этой папке под названием Workspace. Теперь я могу видеть, что а если я на самом деле уменьшения изображения. 

Если я просигналить здесь и смотреть на эту верхнюю правую руку угол, как и обещал левый правая часть экрана всегда собирается показать вам, что в вашем аккаунте, что внутри CS50 IDE. И есть три файла там. 

Поэтому я хочу, чтобы избавиться от a.out и привет. И, как вы могли бы представьте себе интуитивно, вам может сортировать контрольной мыши или нажмите правой кнопкой мыши на этом. И это маленькое всплывающее меню. Вы можете скачать файл, запустите она, просмотреть его, обновить, переименовать, или что нет. 

И я мог бы просто удалить, и он уйдет. Но давайте делать вещи с командой линия на данный момент, с тем, чтобы получить удобный с этим, и сделайте следующее. Я собираюсь идти вперед и удалить a.out, введя буквально rma.out. Оказывается, команду для удаление или удаление что-то, не удалить или удалить. 

Это более лаконично RM, чтобы сэкономить вы несколько нажатий клавиш, и нажмите Enter. Теперь мы собираемся быть несколько загадочно удалить регулярные a.out файл. Я действительно не знаю, что такое нерегулярные файл будет еще. Но я хочу, чтобы удалить его. 

Так что я собираюсь ввести у для да. Или я мог бы ввести его, и нажать клавишу Enter. И, опять же, ничего не кажется, случается. Но это, как правило, хорошая вещь. 

Если я типа LS на этот раз, что я должен видеть? Будем надеяться, что просто привет и hello.c. Теперь, как в сторону, вы будете заметить эту звезду, звездочки, что это в конце моих программ. И они также демонстрируют в зеленый цвет. Это просто способ CS50 среды IDE из cluing вас в том, что это не исходный код. Это исполняемый файл, запускаемым программа, которую можно реально работать делая точечный слэш, а затем его имя. 

Теперь, позвольте мне идти вперед и удалить это, гт привет, Enter, удалить регулярные подать привет, да. А теперь, если я типа LS, мы вернулись к hello.c. Старайтесь не полностью удалить фактический исходный код. Несмотря на то, есть особенности встроенный в CS50 IDE где вы можете пройти через историю изменений и назад во времени, если вы случайно удалить что-то, делать иметь в виду в соответствии с этими подсказками да или нет, от того, что вы на самом деле хотите сделать. И если я иду к вершине левый угол здесь, все, что остается hello.c. Таким образом, есть сгустки другие команды, которые вы может выполнять в мире Linux, один из которых, опять же, сделать. И мы собираемся сделать моя программа в настоящее время следующим образом. 

Вместо того чтобы делать лязг, вместо того, чтобы делать лязг-о, Я собираюсь просто в буквальном смысле типа, сделать привет. А теперь обратите внимание, я не печатает сделать hello.c. Я печатаю сделать привет. 

И эта программа сделать что поставляется с CS50 IDE и многое другое как правило, с Linux, это программа, которая это собирается сделать программу под названием Hello. И он собирается взять на себя, по соглашению, что если эта программа может быть сделано, это будет сделано из источника код файл, заканчивающийся на дот с, hello.c. 

Так что, если я ударил Enter Теперь, обратите внимание, что команда, которая запускается на выполнение на самом деле даже больше до того, чем раньше. И это потому, что мы предварительно CS50 IDE, чтобы иметь некоторые дополнительные функции, встроенные в том, что нам не нужно просто еще, но скоро будет. Но главное, чтобы понять, Теперь у меня есть программа Hello. 

Если я снова ввести LS, я есть программа приветствия. И я могу запустить его с точка слэш a.out, нет, так как весь смысл этого упражнение было точка слэш привет. А теперь у меня есть свой привет мир программа. Так двигаться вперед, мы почти всегда только собирается собрать наши программы используя команду Make. И тогда мы будем запускать их точка слэш, и название программы. Но понимаю, что делает делает для Вы, это сама не компилятор. Это просто программа удобства что знает, как вызвать компилятор бежать так, что вы сами можете использовать его. 

Какие существуют другие команды в Linux, и в свою очередь CS50 IDE? Мы скоро увидим, что есть Команда CD, Изменить каталог. Это позволяет в считанные ваш интерфейс командной строки чтобы двигаться вперед и назад, и открыть различные папки без использования мыши. 

LS мы видели, который выступает за список файлы в текущем каталоге. Сделайте Dir, вы можете вероятно, начинают вывод что они означают now-- сделать каталог, если вы хотите создать папку. RM для удалить, RM Dir для удалить directory-- и они, опять же, это командная строка эквиваленты того, что вы могли бы сделать в CS50 IDE с помощью мыши. Но вы скоро найдете что иногда это просто намного быстрее, чтобы сделать вещи с клавиатуры, и в конечном счете гораздо более мощным. 

Но это трудно утверждать, что все, что мы делали до сих пор это все, что мощные, когда все мы говорили есть привет мир. И в самом деле, я жестко закодировал Слова привет мир в моей программе. Там нет динамичность еще. Царапина была на порядок более интересным на прошлой неделе. 

И так давайте там. Давайте шаг к что путь некоторых из этих функций. Так что не только C поставляются с Printf, и гроздья других функций некоторые из которых мы увидим в течение долгого времени, это не имеет сделать все, что легко прямо ворот в получении ввод данных пользователем. 

На самом деле, одно из слабых мест таких языков, как C, и даже Java и еще другие, в том, что она не сделать его легко просто получить такие вещи, как целые числа от пользователей или строк, слов, и фразы, не говоря уже о вещи, как значения с плавающей точкой, или действительные числа с десятичными точками, и действительно длинные числа, как мы скоро увидим. Так что этот список функций здесь, эти , как и другие кусочки головоломки к царапинам что мы предварительно установлены в CS50 IDE, который мы будем использовать в течение нескольких недель как тренировочные колеса разного рода, и в конце концов, принять их, и смотреть под капотом, возможно, в как эти вещи реализуются. 

Но чтобы сделать это, давайте на самом деле написать программу. Позвольте мне идти вперед прямо сейчас. И я собираюсь создать новую файл, нажав на эту плюсик, и нажав кнопку New File. 

Я собираюсь сохранить этот следующий один, как, скажем, string.c, потому что я хочу, чтобы играть со строками. И строка в C просто последовательность символов. Так что теперь давайте идти вперед и выполните следующие действия. 

Включают в себя стандартные IO.h-- и оказывается стандартный ввод-вывод, IO просто означает, что вход и выход. Так получается, что эта линия вот что является соседней с нами, чтобы использовать Printf. Printf, конечно, производит вывод. Поэтому для того, чтобы использовать Printf, получается что Вы должны иметь эту строку кода в верхней части файла. 

И мы вернемся к тому, что что на самом деле означает в скором времени. Оказывается, что в любая программа C Я пишу, Я должен начать это с код, который выглядит следующим образом. И вы заметите CS50 IDE и другое комплексное развитие среды, как он, будем стараться как лучше они могут закончить свою мысль. На самом деле, минуту назад, если я отменить что я только что сделал, я ударил Enter. 

Затем я попал открытый фигурные скобка, нажмите Enter еще раз. И он закончил свою мысль. Это дало мне новую линию, не отступом не менее для хороших стилистических причин, почему мы будем видеть. И тогда он автоматически дал мне что фигурной скобки, чтобы закончить свою мысль. Теперь, это не всегда угадать, что вы хотите сделать. Но в большей части, это делает сохранить вам несколько нажатий клавиш. Так что минуту назад, мы запустили этот program-- привет, мир, а затем он был скомпилирован, а затем побежал. Но нет здесь динамизм. Что делать, если мы хотим делать что-то другое? Ну, что если бы я хотел на самом деле получить строку от пользователя? Я собираюсь использовать кусок головоломки называется именно that-- получить строку. 

Оказывается, в C, что, когда вы не хотите внести свой вклад в кусок головоломки, или более правильно к функции, вы буквально только что делать открывающую скобку, закрывающей скобкой. Так что, как будто есть нет белого ящика не вводить в. Скажем блок перед тем была маленькая белая коробка. У нас нет, что белая коробка прямо сейчас. 

Но когда я называю получения строки, я хотите поместить результат где-то. Таким образом, очень распространенная парадигма в C является вызова функции, как здесь получения строки, а затем сохранить его возвращаемое значение. Это результат его усилие в чем-то. 

А что такое построить в программировании, будь то в пустом месте или в настоящее время C, что мы можно использовать на самом деле хранить что-нибудь? Вызывается это переменная, не так ли? А в пустом месте, мы не очень-то все равно, что происходит в переменных. 

Но в данном случае, мы на самом деле делаем. Я собираюсь сказать строку. И тогда я мог бы назвать это все, что я хочу. Я буду называть его имя, получает получить строку. 

И теперь, даже если вы немного новичок в этом, обратите внимание, что я не хватает какой-то детали. Я забыл точка с запятой. Мне нужно, чтобы закончить эту мысль. Так что я буду двигать курсор, и ударил запятой там. И что я только что сделал? В этой строке кода, номер 5 в данный момент, Я звоню получения строки без каких-либо входов. Так что нет маленький белый как коробка Сохранить блок имеет. 

Я просто говорю, эй, компьютер, получить мне строку. Знак равенства не очень знак равенства, само по себе. Это назначение оператор, а это значит, эй, компьютер, переместить значение с правой стороны на левую. А слева, у меня есть следующее. 

Эй, компьютер, дайте мне string-- последовательность символов. И называть эту строку имени. И я даже не называть его имени. 

Я мог бы назвать это, условно, что-то вроде S, так же, как мы использовали, чтобы я вызова переменной I. Но теперь мне нужно сделать что-то с ним. Было бы довольно глупо попробуйте скомпилировать этот код, бег эта программа, несмотря на то, Я получаю строку, потому что это еще только собирается сказать привет мир. 

Но что, если я хочу, чтобы изменить это. Почему бы мне не сделать это? Процент s, запятая s. И это немного загадочными до сих пор. 

Итак, позвольте мне сделать мои переменные более ясным. Позвольте мне назвать имя этой переменной. И давайте посмотрим, если мы не можем дразнить помимо того, что здесь происходит. 

Так что на линии пять, я получаю строку. И я хранить эту строку, независимо от того, как пользователь ввел на его клавиатуре, в переменной с именем Name. И получается, что Printf не просто принять один аргумент в два раза котировки, один вход в двойных кавычках. 

Это может занять два, или три, или больше, например что второй, или третий, или четвертый, все имена переменных, или конкретно ценности, что вы хотите подключиться к, динамически, эта строка в кавычках. Другими словами, то, что было бы неправильно с этим? Если я только что сказал привет имя, обратный слэш п, спас мой файл, составленный мой код, и побежал это, что бы произошло? 

Это просто будет сказать, привет имя, в буквальном смысле N-А-М-Е, который отчасти глупо, потому что она ничем не отличается от мира. Так что ничего в кавычках то, что буквально распечатана. Так что, если я хочу иметь заполнитель там, Я на самом деле нужно использовать какой-то особый синтаксис. И получается, если вы читаете документация для функции PRINTF, он скажет вам, что если вы используете процента с, вы можете заменить значение следующим образом. 

После запятой после этого двойные кавычки, вы просто напишите название из переменная, которую вы хотите подключить в этот формат кода или спецификатор формата, процентов s для строк. И теперь, если я сохранил мой файл, Я возвращаюсь вниз к моему терминалу. И я типа Make String, потому что, опять же, название этого файл, который я выбрал, прежде чем это string.c. 

Так что я собираюсь сказать, сделать строку, введите. О боже мой, посмотри на все ошибки, которые мы сделали уже. И это is--, что это на самом деле как, семь программ шести линии? Так что это, где это может очень быстро получить подавляющее. 

Это окно терминала имеет теперь просто выплюнул огромное количество сообщений об ошибках. Конечно, у меня нет больше ошибка сообщений, чем у меня есть строки кода. Так, что происходит? 

Ну, лучшая стратегия делать в любое время вы действительно сталкиваются с подавляющим Список ошибок, как, что, будет прокрутить назад, искать команды вы просто побежал, что в моем случае это сделать строку. Посмотрите, что делают сделал, и это что долго Clang команда, нет ничего особенного там. 

Но красный плохо. Зеленый пытается быть нежный и полезно. Но это все-таки плохо, в этом случае. Но где же это плохо? 

String.c, линия пять, пять символов. Так что это просто общее соглашение. Что-то значит что-то двоеточие номер строки и номер символа. Ошибка, использование необъявленная Идентификатор строки. Возможно, вы имели в виду стандарт? 

Так что, к сожалению, Clang пытается быть полезным. Но это не так, и в этом случае. Нет, Clang, я не имел в виду стандартный ввод-вывод. Я имел в виду, что на первой линии, да. 

Но линия пять это один здесь. И Clang не понимать, S-T-R-I-N-G. Это необъявленный идентификатор, A Слово это просто никогда не видел раньше. И это потому, что C, язык мы пишем код прямо сейчас, нет переменных, называемых строками. 

Это не произойдет, по умолчанию, поддержка то, что называется строку. Это CS50 кусок жаргон, но весьма условен. Но я могу исправить это следующим образом. 

Если добавить одну строку кода в верхней части этой программы, включают CS50.h, который является другой файл где-то внутри CS50 IDE, где-то на жестком диске, так сказать, операционной системы Ubuntu что я бегу, что это файл, который собирается учить операционной Система какая строка, просто как стандартный io.h является файл в операционной системе, что это буду учить его, что Printf есть. 

Действительно, мы получили бы очень похожее сообщение если IO признал стандарт Io.h и пытался использовать Printf. Так что я собираюсь идти вперед и просто взять под свой контроль L, чтобы очистить экран. Или вы можете ввести ясно, и он будет просто очистить окно терминала. Но вы все еще можете прокручивать назад во времени. 

И я буду перезапускать Сделать String. Крест мои пальцы на этот раз, Enter. Боже мой, это сработало. он показывает мне длинную маскировочную команду то есть то, что делает генерироваться с помощью Clang, но никаких сообщений об ошибках. Так понимают, несмотря на то, вы можете получить полностью завалены количество сообщений об ошибках, он просто может быть это раздражает каскадных эффект, где Clang не понимает одна вещь, которая означает, что он тогда не понимает следующее слово, или следующая строка. А так он просто задыхается от вашего кода. Но исправление может быть простым. И так всегда сосредоточены на Самая первая строка вывода. И если вы этого не сделаете понять это, просто посмотрите для ключевых слов, которые могли бы быть ключи и номер строки, и характер, где эта ошибка может быть. 

Теперь позвольте мне идти вперед и ввести точка слэш, строка, введите. Хм, это не поздоровавшись ничего. Зачем? Ну, помните, где он работает? 

Это, вероятно, застрял в данный момент в цикле, если вы будете, на шестой строке, потому Получить строку дизайн, написаны сотрудниками CS50, буквально означало просто сидеть там ждет, и ждет, и ожидание строки. Все, что мы подразумеваем под строкой ввода является человек. Таким образом, вы знаете, что? Позвольте мне идти вперед. И только по наитию, позвольте мне введите свое имя, Дэвид, введите. Теперь у меня есть более динамичной программы. Он сказал, привет Дэвид. 

Если я иду вперед и запустить это снова, позвольте мне попытаться сказать имя Zamila, введите. И теперь у нас есть динамическая программа. Я не жестко закодированы мир. Я не жестко закодированы имя, или Дэвид или Zamila. 

Теперь это гораздо больше похоже программ мы знаем, где, если принимать входной сигнал, он производит несколько иной вывод. Теперь, это не самый лучший опыт пользователя или UX. Я запустить программу. 

Я не знаю, что я должен делать, если я на самом деле не смотреть на или запомнить исходный код. Так давайте пользователю опыт немного лучше с простейших вещей. Позвольте мне вернуться в этот программы, а просто сказать Printf. 

И позвольте мне идти вперед и сказать имя, двоеточие, и пространство, а затем точка с запятой. И как раз для пинков, не люфтит н. И это преднамеренное, потому что я не хочу приглашение, чтобы перейти к следующей строке. 

Я хочу, вместо того, сделать это, сделать строку перекомпилировать свой код в новую машину Код точка слэш строку. Ах, это гораздо симпатичнее. Теперь я на самом деле знаю, что компьютер хочет, чтобы я, дать ему имя. 

Так что я собираюсь идти вперед и ввести в Робе, войти, и привет, Роб. Таким образом, понимают, что это до сих пор, в конце дня, только программа девять линий. Но мы сделали эти шаги ребенка. 

Мы написали одну строку, с которой мы были знакомы, Printf, привет мир. Тогда мы расстегнула немного этого. И мы на самом деле использовали получения строки. И мы бросили это значение в переменной. А потом мы пошли вперед и совершенствоваться Кроме того, он с третьей линией. И этот повторяющийся процесс написание программного обеспечения является действительно ключом. В CS50, так и в жизни в целом, Вы должны, как правило, не сесть, имеют в виду программу, и попробуйте писать вся хреновина все сразу. 

Это неизбежно будет приводить к пути больше ошибок, чем мы сами видели здесь. Даже я, и по сей день, постоянно делать другие глупые ошибки, на самом деле сложнее ошибки что труднее выяснить. Но вы будете делать больше ошибок, тем больше строк кода вы пишете все сразу. И поэтому эта практика, написать немного кода что вы комфортно, компилировать это, запустить его, протестировать его в более общем плане, затем переместите on-- так же, как мы держали отводками и отводками на прошлой неделе, строительство от чего-то очень просто что-то более сложное, сделать то же самое здесь. Не садитесь, и попытаться написать целую проблему. На самом деле эти шаги ребенка. 

Теперь, строки не все что полезно им самим. Мы бы на самом деле, в идеале, как и в есть кое-что еще в нашем инструментарии. Так что давайте на самом деле сделать именно это. 

Позвольте мне идти вперед сейчас и нагнетать немного другая программа. И мы будем называть этот int.c, для целого числа. Я собираюсь, так же, включают CS550.h. Я собираюсь включать стандартные IO. И это будет довольно распространенным в эти первые несколько дней класса. 

И я буду готов сам с основной функцией. И теперь вместо того, чтобы получить строку, давайте идти вперед и получить Int. Давайте назовем это я и называю это получить INT, близкие круглые скобки, точка с запятой. А теперь давайте сделаем что-то с ним, Printf. 

Скажем, что-то вроде привет, обратная косая п, запятая я. Так что я в значительной степени имитируя что я сделал только минуту назад. У меня есть заполнитель здесь. Я запятая я здесь, потому что я хочу для подключения I в этот заполнитель. 

Так что давайте идти вперед и попробовать компиляции этой программы. Файл называется int.c. Так что я собираюсь сказать, сделать Int, введите. Боже мой, но не большое дело, не так ли? Там ошибка. 

Там в синтаксической ошибке вот такая, что программа не может составляться внутри int.c, линии семь, символ 27, формат ошибка определяет тип полукокса звезда, что бы это ни. Но тип аргумента Int. 

Так что здесь тоже, мы не собираемся, целью которых даже если сегодня много материала, мы будем подавлять вас с абсолютно каждый признак C, и программирование в более общем смысле, всего за эти первые несколько недель. Так что часто будет жаргон с которыми вы не знакомы. И в самом деле, символ звезды что-то мы собираемся вернуться к в течение недели или времени до двух. 

Но сейчас, давайте посмотрим, если мы можем разобрать слова, которые знакомы. Formats-- так что мы слышали формат спецификатор, код формата раньше. Это знакомо. Type-- но аргумент имеет тип Int. Подождите, я это Int. 

Может быть, на самом деле процентов s имеет некоторый определенный смысл. И действительно, это делает. Целое число, если вы хотите PRINTF, чтобы заменить его, вы на самом деле нужно использовать другой формат спецификатор. И вы не знали бы это если кто-то сказал вам, или вы сделали это раньше. Но процентов я есть что может быть широко используется в Printf для подключения целого. Вы можете также использовать процент d для десятичного целого числа. Но я просто и красиво здесь. Таким образом, мы будем идти с этим. 

Теперь позвольте мне идти вперед и перекладка марка INT, Enter. Это не хорошо, никаких ошибок. Дот слэш int-- OK, плохой пользовательский опыт, потому что я не сказал себе что делать. Но это нормально. Я быстро завоевывают. 

А теперь позвольте мне идти вперед и ввести Давида, OK, Zamila, Роб. ОК, так что это хорошая вещь. На этот раз, я использую функцию, головоломка кусок, который называется Get Int. И получается out-- и мы см это позже в term-- персонал CS50 осуществил получить строку таким образом, что она будет только физически получить строку для вас. 

Он реализован в Int Получить таким образом, что это будет только получить целое число для вас. И если вы, человек, не сотрудничают, это буквально только собирается сказать, повторите, повторите, повторите, буквально сидел там зацикливание, пока вы обязывают с каким-то магическим числом, как 50, и привет 50. 

Или, если мы выполним это снова и тип в 42, 42 привет. И поэтому функция Get INT внутри этого кусок головоломки достаточно логики, достаточно мысль, чтобы выяснить, что такое слово? А что такое число? Только принятие, в конечном счете, цифры. 

Так получается, что это не все, что выразительно. так далеко. Так, яй, последний раз, когда мы пошел довольно быстро в исполнителей игр и анимации, и художественные произведения, в пустом месте. И вот, мы довольствуясь с привет мир, и привет 50. 

Это не все, что вдохновляет. И действительно, эти первые несколько примеры займет некоторое время сползать в волнении. Но у нас есть так много больше контролировать сейчас, на самом деле. И мы будем очень быстро начать отводками на верхней части этих основных примитивов. 

Но во-первых, давайте разберемся какие ограничения. На самом деле, одна из вещей, Царапины не легко давайте сделаем это реально смотреть под капотом, и понять, что компьютер, что он может сделать, и каковы его ограничения. И действительно, что отсутствие понимание, потенциально, долгосрочное может привести к нашей собственной mistakes-- письменной форме ошибок, написание небезопасного программного обеспечения, получает взломали в некотором роде. 

Итак, давайте некоторые шаги в направлении понимая это немного лучше способ, скажем, следующий пример. Я собираюсь идти вперед и реализовать реальный быстрый программа под названием Adder. Мол, давайте добавим некоторые цифры вместе. И я собираюсь кодировать некоторые углы здесь, и просто скопировать и вставить где я был раньше, просто так что мы можем начать работать раньше. Так что теперь у меня есть основные начала программы под названием Adder. 

И давайте идти вперед и делать это. Я собираюсь идти вперед и скажем, IntX получает получить Int. И знаешь, что? Давайте сделаем лучший пользовательский опыт. 

Так что давайте просто скажем х, и эффективно подсказать пользователю, чтобы дать нам х. А потом дайте мне идти вперед и сказать, Printf как насчет у есть, на этот раз ожидая два значения от пользователя. А потом давайте просто идти вперед и скажем, Printf, сумма х и у. А теперь я не хочу делать процентов с. Я хочу сделать процент I, обратной косой черты п, а затем подключить значение суммы. 

Так как я могу идти об этом? Знаешь что? Я знаю, как использовать переменные. Позвольте мне просто объявить новый, Int г. 

И я собираюсь сделать предположение здесь. Если имеются равные знаки в этом язык, может быть, я просто не могу сделать х плюс у, до тех пор, как я закончу свою думал с запятой? Теперь я могу вернуться сюда, подключить г, закончить эту мысль с запятой. И давайте посмотрим теперь, если они последовательности lines-- х, это получить Int. Y это получить Int. 

Добавить х и у, сохраняют значение в z-- так, опять же, помните, знак равенства не равна. Это назначение справа налево. И давайте печатать, что сумма х и у не буквально г, но что внутри г. Так давайте сделаем Adder - не красиво, никаких ошибок в этот раз. Дот слэш Adder, введите, х будет 1. 

Y будет 2. А сумма х и у равна 3. Так что это все прекрасно и хорошо. 

Таким образом, вы бы себе представить, что математику должны работать в программе, как это. Но вы знаете, что? Является ли эта переменная, строка 12, даже необходимо? Вам не нужно, чтобы войти в привычку просто хранения вещей в переменных только потому, что вы можете. И в самом деле, это как правило, считается плохой дизайн если вы создаете переменную, называется Z в этом случае, хранение что-то в нем, а затем сразу же используя его, но никогда. Зачем давать что-то имя как г, если вы в буквальном смысле собирается использовать это предмет только один раз, и так проксимальнее где вы создали это, в первую очередь, так близко с точки зрения строк кода? Таким образом, вы знаете, что? Оказывается, что C является довольно гибким. Если я на самом деле хочу плагин значений здесь, Мне не нужно, чтобы объявить новую переменную. Я мог бы просто плагин х плюс у, потому что понимает, C арифметические и математические операторы. 

Так что я могу просто сказать, это сделать математику, х плюс у, какими бы эти значения, подключите результирующий целое число в этой строке. Таким образом, это могло бы быть, если бы только одна строка короче, лучший дизайн, лучшая программа, потому что там меньше кода, поэтому меньше для меня понять. И это также просто чище, постольку, поскольку мы не вводя новые слова, новые символы, как и г, даже если они на самом деле не служить много цели. 

К сожалению, математика не является все, что надежные иногда. Давайте идти вперед и делать это. Я собираюсь идти вперед сейчас и сделайте следующее. 

Давайте сделаем Printf, процент I, плюс процент я, должно быть процентов я, обратная косая п. И я собираюсь сделать this-- хух плюс у. Так что я просто хочу переписать это немного по-другому здесь. Позвольте мне сделать быструю проверку вменяемости. Опять же, давайте не будем забегать вперед. Сделать сумматор, точка слэш гадюка. х равен 1, у 2, 1 плюс 2 равно 3. Так что это хорошо. Но давайте усложнить это сейчас немного, и создать новый файл. 

Я буду называть этот, говорят, Интс, множественное число для целых чисел. Позвольте мне начать, где я был минуту назад. Но теперь давайте сделаем несколько других линий. Позвольте мне идти вперед и делать следующее, Printf, процент я, минус процент я, это процент я, запятая х, запятая ух минус у. Так что я немного делаю другая математика там. Давайте сделаем еще один. Таким образом, процент I раза процентов я это процент я, обратная косая п. Давайте плагин х и у, и х раз у. Мы будем использовать звездочку ваш компьютер в течение времени. 

Вам не нужно использовать х. х имя переменной здесь. Вы можете использовать звезду для умножения. Давайте сделаем еще один. Printf процента I, разделить на процент I, является процент я, обратная косая п. ху, деленная на y-- так что вы используете слэш в C сделать разделение. И давайте сделаем друг друга. Remainder процента I, разделенный на процент I, является процент я. xy-- и теперь осталось это то, что осталось. При попытке деления знаменателя в числитель, сколько осталось над этим Вы не могли бы разделить вне дома? 

Так что не очень, обязательно, символ мы использовали в начальной школе для этого. Но есть в C. Вы можете говорят х по модулю у, где этот знак процента в этом context-- когда вы смутно находитесь внутри двойных кавычках, внутри от Printf, процентов используется в качестве спецификатора формата. 

При использовании процентов за пределами что в математическом выражении, это оператор по модулю для модульного arithmetic-- для наших целей здесь, просто означает, что такое Остальная часть х делится на у? Так х делится на у есть х слэш у. Что остальная часть делится на х у? Это х мод у, как программист мог бы сказать. 

Так что, если я не сделал ни одной ошибки здесь, позвольте мне идти вперед и сделать Интс, множественное число, приятно, и точка слэш Интс. И давайте идти вперед и делать, скажем, 1, 10. Хорошо, 1 плюс 10 равно 11, проверка. 1 минус 10 отрицательный 9, проверьте. 

1 раз в 10: 10, проверка. 1 делится на 10 is-- Хорошо, мы пропустим что один. Остаток 1 делится на 10 равно 1. Правильно. Но есть ошибка здесь. 

Таким образом, тот, который я кладу сдать, не правильно. Я имею в виду, что это близко к 0. 1 делится на 10, вы знаете, если мы резки некоторые углы, конечно, это ноль. Но это должно быть действительно 1/10, 0,1 или 0,10, 0,1000, или тому подобное. 

Она не должна действительно быть равна нулю. Что ж, получается, что компьютер делать буквально то, что мы сказали это сделать. Мы делаем математику как х, деленное на у. И оба х и у, на линии кода ранее, являются целыми числами. 

Кроме того, по линии 15, мы говоря Printf, эй, Printf плагин целое число, вставной целое число, плагин в integer-- специально х, а затем у, а затем х делится на у. х и у Интс. Мы там хорошо. 

Но что х делится на х? х делится на у и должно быть, математически, 1/10, или 0,1, которая представляет собой действительное число, вещественное число имея, потенциально, десятичную точку. Это не является целым числом. 

Но то, что ближе всего целое число, 1/10, или 0,1? Да, это своего рода равна нулю. 0,1, как это много. И 1 это много. Таким образом, 1/10 ближе к 0, чем к одному. 

И так, что C делает для us-- вид, потому что мы сказали это, целью которых является усечения, что целое число. Он принимает значение, что опять-таки является должно быть что-то вроде 0,1000, 0 и так далее. И это все, что усечение после десятичной точки так что все это материал, потому что это не вписывается в понятие целого числа, что это просто число, как отрицательный 1, 0, 1, вверх и вниз, он отбрасывает все после десятичной точки, потому что вы не может соответствовать десятичную точку в целое число, по определению. 

Таким образом, ответ здесь равен нулю. Так как же мы это исправить? Нам нужно другое решение все вместе. И мы можем сделать это следующим образом. 

Позвольте мне идти вперед и создать новый Файл, на этот раз называется floats.c. И сохранить его здесь, в тот же каталог, float.c. И позвольте мне идти вперед и скопировать часть этого кода из ранее. 

Но вместо того, чтобы INT, давайте сделаем это. Дайте мне значение с плавающей запятой называется х. где с плавающей точкой значение только в буквальном смысле что-то с плавающей точкой. Он может перемещаться влево, вправо. Это вещественное число. 

И позвольте мне не называть получить Int, но получить с плавающей точкой, который также был одним из меню опций в библиотеке C250. Давайте изменим у к поплавку. Так что это будет получить с плавающей точкой. 

А теперь, мы не хотим, чтобы подключить Интс. Оказывается, мы должны использовать процентов е для поплавка, процент F для поплавка, и теперь сохранить его. А теперь, скрестив пальцы, сделайте поплавки, красиво, точка слэш поплавки. х будет одним 1. у Будет 10 раз. 

И, хорошо, хорошо мое дополнение является правильным. Я надеялся на более, но я забыл написать. Так что давайте идти и исправить эту логическую ошибку. 

Давайте идти вперед и захватить следующее. Мы просто делаем немного копирования и вставки. И я хочу сказать, минус. 

И я хочу сказать, раз. И я хочу сказать, разделились. И я не буду делать по модулю, которая не является, как релевантный здесь, делится на F, и раз plus-- Хорошо, давайте сделаем это снова. 

Сделать поплавки, точка слэш поплавки, и 1, 10, и-- хорошо, нет, ОК. Так что я идиот. Так что это очень распространенная в информатике чтобы сделать глупые ошибки, как это. 

Для педагогических целей, что я действительно хотел сделать был изменить науку здесь на плюс, в минус, к временам, и разделить, как вы, надеюсь, заметили во время этого упражнения. Итак, теперь давайте заново скомпилировать Программа, делать точечные слэш поплавки. 

И в третий раз, давайте увидеть, если она отвечает моим ожиданиям. 1, 10, введите, да, хорошо, 1.000, разделенный на 10000, это 0,100000. И получается, что мы можем контролировать, сколько цифры после этих знаков после запятой. Мы на самом деле будет. Мы вернемся к этому. 

Но теперь, по сути, математика является правильным. Так что, опять же, что вынос здесь? Оказывается, что в C, есть не только strings-- и, на самом деле, есть не очень, потому что мы добавить те, с библиотекой CS50. Но есть не только Интс. 

Есть также плавает. И получается, кучу других данных типа также, что мы будем использовать в скором времени. Оказывается, если вы хотите один характер, а не строка символов, вы можете использовать только символ. 

Оказывается, что если вы хотите, логическое значение, логическое значение, истина или ложь только, благодаря библиотеке CS50, мы добавляется к C типу данных BOOL, а также. Но это также присутствует в многих других языках, а также. И получается, что иногда вам нужны большие цифры, а затем приходят по умолчанию с Интс и поплавками. 

И, по сути, двойной ряд который использует не 32 бита, но 64 бита. И долго долго это число, использует не 32, биты, но 64 бита, соответственно, операций с плавающей точкой значения и целые числа, соответственно. Так что давайте на самом деле в настоящее время увидеть это в действии. 

Я собираюсь идти вперед здесь и нагнетать одну другую программу. Здесь я собираюсь идти вперед и не включают CS50.h. И позвольте мне идти, включают в себя стандартные IO.h. 

И вы заметите что-то фанки здесь происходит. Это не цветовое кодирование вещи точно так же, как это было раньше. И оказывается, что это потому, что я не дали вещь имя файла. 

Я буду называть этот sizeof.c, и нажмите кнопку Сохранить. И обратите внимание, что происходит с моей очень белый код против этого черный фон. Теперь, по крайней мере есть некоторые фиолетовые там. И это синтаксис выделен. 

Это потому, что довольно просто, у меня есть рассказал, какой тип файла IDE это, давая ему имя, и в частности, расширение файла. Теперь, давайте идти вперед и делать это. Я собираюсь идти вперед и очень просто распечатать following-- Ьоо это процент LU. 

Мы вернемся к что в мгновение. А потом я собираюсь размер печати BOOL. И теперь, чтобы сэкономить я какое-то время, я собирается сделать целое букет из них сразу. И, в частности, я собираюсь изменить это к гольца и голец. Это одно, я собираюсь изменить к двойной и двойной. 

Это одно, я собираюсь изменить к поплавку и поплавком. Это одно, я собираюсь изменится на Int и Int. А это, я собираюсь чтобы изменить долго долго. И он по-прежнему принимает долго, долго долго. 

И тогда, наконец, я дал я слишком много, строка. Оказывается, что в C, есть специальный оператор называется размер, что буквально собирается, при запуске, скажите нам размер каждая из этих переменных. И это путь, в настоящее время, мы можем соединиться назад для обсуждения на прошлой неделе данных и представления. 

Позвольте мне идти вперед и компилировать размер точечного размера Слэш. И давайте посмотрим. Оказывается, что в C, в частности, на CS50 IDE, в частности, на Операционная система Ubuntu, который является 64-разрядной операционной Система в этом случае, логическое значение будет использовать один байт пространства. Вот как измеряется размер, не в битах, а в байтах. И помните, что один байт восемь бит. Так BOOL, даже если вы технически нужно только 0 или 1, это немного расточительно как мы реализовали. Это на самом деле собирается использовать весь byte-- так все нули, являются, возможно, все те, или что-то подобное, или только один 1 из восьми битов. 

Полукокса, тем временем, используется для символа как символ Ascii за последнюю неделю, будет один символ. И это синхронизируется с нашим понятием не будучи не более 256 bits-- а, синхронизируется с ним быть не длиннее, чем 8 бит, что дает нам целых 256 значений. Двойной собирается составляет 8 байт или 64 бита. 

Поплавок 4. ИНТ 4. Длинный, длинный 8. И строка 8. Но не беспокойтесь об этом. Мы собираемся отогните этот слой. Оказывается, строки могут быть длиннее 8 байт. 

И действительно, мы написали строки уже, привет мир, больше, чем 8 байт. Но мы вернемся к что в мгновение. Но заберите здесь заключается в следующем. 

Любой компьютер имеет только конечное объем памяти и пространства. Вы можете только хранить так много файлы на вашем Mac или PC. Вы можете только хранить так много программ RAM работает сразу, обязательно, даже с виртуальной памятью, потому что у вас есть ограниченное количество оперативной памяти. 

И только если picture-- вы никогда не открыли ноутбук или заказать дополнительную память для компьютера, вы может не знать, что внутри вашего компьютера это то, что выглядит немного как это. Так что это просто обычная компания под названием Решающее значение, что делает оперативной памяти для компьютеров. И оперативная память, где программы жить в то время как они работают. 

Так что на каждом Mac или PC, при двойном выберите программу, и она открывает, и это открывает какой-то документ Word, или что-то типа того, он сохраняет ее на некоторое время в RAM, поскольку оперативная память быстрее чем ваш жесткий диск, или ваш твердотельный накопитель. Так что это просто, где программы идут жить, когда они работают, или когда используются файлы. 

Так что у вас есть вещи, которые выглядят как это внутри вашего ноутбука, или немного больше вещей внутри вашего рабочего стола. Но ключ у вас есть только конечное число этих вещей. И есть только конечное количество аппаратное обеспечение, сидя на этом столе правой Вот. 

Так что, конечно же, мы не можем хранить бесконечно длинных чисел. И, тем не менее, если вы думаете, обратно начальной школы, сколько цифр может вы должны права из десятичной точки? В этом отношении, сколько цифр может у вас есть слева от десятичной точки? Действительно, бесконечно много. 

Теперь мы, люди могли бы только знаете, как произносится миллион, и миллиард, триллион, и квадриллионов и квинтильонов. И я раздвигают границы моего understanding-- или my-- Я понимаю, цифры, но мой произношение чисел. Но они могут получить бесконечно большой с бесконечно много цифр слева или справа от десятичной точки. 

Но компьютеры есть только конечное количество памяти, конечное число транзисторов, A конечное число лампочек внутри. Так что же происходит, когда вы бежите из космоса? Другими словами, если вы думаю, что вернуться к прошлой неделе когда мы говорили о цифрах Сами представлены в двоичном виде, Предположим, что у нас есть это 8-битное значение здесь. 

И у нас есть семь 1 и один 0. И предположим, что мы хотим добавить 1 к этому значению. Это действительно большое число прямо сейчас. 

Это 254, если я помню математика с прошлой недели справа. Но что, если я изменить что крайний справа от 0 до 1? Целое число, из Конечно, будет восемь 1-х. Таким образом, мы по-прежнему хорошо. 

И это, вероятно, представляет 255, хотя в зависимости от контекста он может на самом деле представляют отрицательное число. Но об этом в другой раз. Это чувство, что речь идет о столь же высоко, как я могу рассчитывать. 

Теперь, это только 8 бит. И мой Mac, конечно же, есть путь более 8 бит памяти. Но у него есть конечное. Таким образом, тот же аргумент применим, даже если мы имеют более из этих единиц на экране. 

Но что произойдет, если вы хранения этого числа, 255, и вы хотите считать 1 немного выше? Вы хотите перейти от 255 до 256. Проблема, конечно, в том, что если вы начать отсчет с нуля, как на прошлой неделе, вы не можете рассчитывать, как высокий в 256, не говоря уже о 257, не говоря уже о 258, м, потому что происходит, когда вы добавляете 1? Если вы делаете старую начальную школу подход, вы положили 1 здесь, а затем 1 плюс 1 равно 2, но это на самом деле ноль, вы носите 1, нести 1, нести 1. Все эти вещи, эти 1, перейдите к нулю. И ветер, да, как кто-то указал, что в 1 на левой стороне. Но все, что вы можете на самом деле увидеть и помещается в памяти находится всего в восьми 0, который должен сказать, в какой-то момент, если вы, компьютер, судимый подсчета достаточно высоко, вы собирается обернуть вокруг, казалось бы, к нулю, или, может быть даже отрицательным цифры, которые даже ниже нуля. 

И мы можем рода увидеть это. Позвольте мне идти вперед и написать реальная быстрая программа здесь. Позвольте мне идти вперед и написать программа под названием перелива. Включите CS50.h, включите стандарт IO.h-- о, Я действительно пропустил мой подсветку синтаксиса. Так давайте сохраним это как overflow.c. 

А теперь главный INT void-- и до тех пор, мы будем вернуться к объяснению, почему мы продолжаем писать Int основную пустоту. Но сейчас, давайте просто делать она, принимая его как само собой разумеющееся. Давайте дать себе Int, и инициализировать его до 0. 

Давайте тогда сделать для Int я получаю zero-- на самом деле, давайте делать бесконечный цикл и посмотреть, что происходит. В то время как верно, то давайте распечатать п это процент я, обратная косая черта п, плагин п. Но теперь, давайте п получает п плюс 1. 

Итак, другими словами, на каждый итерация этого бесконечного цикла, давайте рассмотрим значения п, в и добавить к нему 1, а затем сохранить результат в п на левой стороне. И в самом деле, мы уже видели синтаксис немного, как это, на короткое время. Прохладный трюк вместо этого писать все это, вы можете сказать, п ​​плюс равен 1. 

Или, если вы действительно хотите быть фантазии, Вы можете сказать, п ​​плюс плюс точка с запятой. Но эти последние два просто то, что мы назвали бы синтаксический сахар для первой вещи. 

Первое, что является более явным, совершенно нормально, совершенно правильно. Но это чаще, я скажу. Таким образом, мы будем делать это на мгновение. 

Давайте теперь сделать переполнение, которая звучит довольно зловеще, точка переполнения косой черты. Давайте посмотрим, п становится довольно большой. Но давайте подумаем, насколько велика может получить п? 

п является Int. Мы видели минуту назад с размером пример, что INT четыре байта. Мы знаем, что с прошлой недели, четыре байта является 32 бита, потому что в 8 раз 4, это 32. Это будет 4 млрд. 

И мы до 800,000. Это будет длиться вечно рассчитывать так высоко, как я, возможно, может. Так что я собираюсь идти вперед, как вы могли бы в скором времени, и ударил управления c-- откровенно, контроль C, много, где управление C в целом средство отмены. К сожалению, так как этот работает в облаке, иногда облако выплевывая так много вещей, так много вывода, он собирается занять некоторое время для моего ввода чтобы добраться до облака. Так что, хотя я ударил Контроль C несколько секунд назад, это, безусловно, сторона эффект бесконечного цикла. 

И поэтому в таких случаях, мы собирается оставить это быть. И мы собираемся добавить еще окно терминала здесь с плюсом, который, конечно, не как это, так как он все еще думает. И давайте идти вперед и быть чуть более разумным. 

Я собираюсь идти вперед и делать это лишь конечное число раз. Давайте использовать цикл, которые я упоминал ранее. Давай сделаем это. Дайте мне другую переменную Int я получает 0. я меньше, чем, скажем, 64 я ++. А теперь позвольте мне идти вперед и печать из п процентов я, запятая п. И тогда это N-, до сих пор собирается взять навсегда. Давай сделаем это. 

п получает п раз 2. Или мы могли бы быть фантазии и делать раз равна 2. Но давайте просто скажем, п равно сама по себе, раз 2. Другими словами, в этом Новая версия программы, Я не хочу ждать вечно от 800 000, как до 4 миллиардов. Давайте просто покончим с этим. 

Давайте на самом деле в два раза п каждый раз. Который, напомним, является удвоением напротив того, конечно. И в то время как на прошлой неделе у нас есть что-то снова и снова, и снова, супер быстрый, Удвоение, безусловно, получить нас от 1 до самой большой возможно значение, которое мы можем рассчитывать, чтобы с междунар. 

Так что давайте делать именно это. И мы вернемся к этому в скором времени. Но это, опять же, как и повтор блока в пустом месте. И вы будете использовать это до тех пор. 

Это просто означает, что отсчет от нуля до, но не равны, до 64 лет. И на каждой итерации этого цикл, просто держать приращением я. Так что я ++ - и эта общая конструкция в строке 7 это просто супер распространенный способ повторять несколько строк код, некоторое количество раз. Какие строки кода? Эти фигурные скобки, как вы возможно, почерпнутые теперь, означает, сделайте следующее. 

Это в такой царапины, когда он имеет желтые блоки и другие цвета, вид принять или обнимают другие блоки. Вот что эти фигурные брекеты делают здесь. Так что, если я получил свой синтаксис right-- вас можно увидеть символ морковь в средствах C вот сколько раз я был пытаясь решить эту проблему. Так что давайте избавиться от этого одного в целом, и закрыть это окно. И мы будем использовать новый. Сделать переполнения, точка слэш Переполнение, Enter, все в порядке, это выглядит плохо на первый взгляд. Но давайте прокручивать назад во времени, потому что я сделал это 64 раз. 

И заметьте, в первый раз, п равно 1. Второй раз, п = 2, затем 4, затем 8, затем 16. И мне кажется, что как только Я получаю примерно 1 млрд, если я снова удвоить ее, что должен дать мне 2 миллиарда долларов. Но оказывается, это прямо на пороге. 

И это на самом деле переливается INT с 1 млрд грубо отрицательное 2 млрд, так как целое число, в отличие от чисел мы принимают на себя на прошлой неделе, может быть как положительным, так и отрицательным на самом деле, и в компьютере. И так по крайней мере, один из тех, биты эффективно украдены. Таким образом, мы действительно только 31 бит, или 2 миллиарда возможных значений. 

Но на данный момент, еда на дом вполне просто, каковы бы ни были эти цифры и независимо от того математика, что-то плохое случается в конце концов, потому что в конце концов, вы пытаетесь переставляют биты слишком много раз. И вы эффективно перейти от всех 1-х, может быть, все 0, или, может быть, просто какой-то другой модели, что оно Очевидно, что в зависимости от контекста, может быть истолковано как отрицательное число. И вот, казалось бы, самый высокий I может рассчитывать в этой конкретной программе составляет всего около 1 млрд. Но есть частичное решение здесь. Знаешь что? 

Позвольте мне изменить из Int на долгое долго. И позвольте мне идти вперед здесь и say-- я буду иметь чтобы изменить это без знака долго. Или, давайте посмотрим, я никогда не помню себя. 

Давайте идти вперед и сделать переполнение. Нет, это не так, ДНУ, спасибо. Так что иногда Clang может быть полезным. Я не помню, какой формат Спецификатор был долго долго. 

Но, на самом деле, Clang сказал мне. Зеленый является своего рода хорошо, по-прежнему означает, что вы сделали ошибку. Это догадываясь, что я имел в виду LLD. 

Итак, позвольте мне взять это совет, длинный длинный десятичное число, кроме того, что. И позвольте мне снова запустить его, точка слэш переполнение, Enter. А теперь, что это круто это. 

Если я прокручиваю назад во времени, мы до сих пор начать считая в то же place-- 1, 2, 4, 8, 16. Обратите внимание, мы получаем все вплоть до 1 млрд. Но тогда мы благополучно добраться до 2 млрд. 

Тогда мы получим 4 млрд, затем 8 млрд, 17 млрд. И мы идем выше, и выше и выше. В конце концов, это тоже ломается. 

В конце концов, с тех пор долго, который является 64-битное значение, а не 32-битное значение, если считать слишком высоко, вы обтекать 0. И в этом случае, мы оказались в конечном итоге с отрицательным числом. 

Так что это проблема. И получается, что это Проблема в том, что не все аркан. Даже если я намеренно подвигло его с этими ошибками, получается, мы видим, что это вроде все вокруг нас, или, по крайней мере, некоторые из нас. 

Так что в Lego Star Wars, если вы когда-либо играли в эту игру, получается, вы можете ходить ломать вещи в LEGO мире, и собирать монеты, по существу. И если вы когда-либо играли эта игра слишком много времени, как это безымянного человека здесь же, общее число монет, которые вы можете получить это, казалось бы, 4 млрд. 

Теперь, когда он на самом деле закруглены. Так что LEGO пытался держать вещи дружественным к пользователю. Они не делали это точно от 2 до 32 мощности, за последнюю неделю. Но 4 млрд причина. Кажется, основываясь на этой информации, что LEGO, и компания, которая сделал это фактическое программное обеспечение, решил что максимальное количество монет пользователь может накапливаться это, по сути, 4 миллиарда, потому что они выбрали в своем коде использовать не долго долго, по-видимому, но только целое число, без знака целое число, только положительное целое число, чьи максимальное значение составляет примерно это. Ну, вот еще забавный. Так что в игре Цивилизация, которая некоторые из вас могут быть знакомы с выясняется, что несколько лет назад там была ошибка в этой игре в результате чего если вы играли роль Ганди в игре, вместо него был очень пацифистом, вместо того, чтобы было невероятно, невероятно агрессивный, в некоторых обстоятельствах. В частности, так, что цивилизация работы является то, что если вы, игрок, принять демократию, ваш Агрессивность оценка получает декрементируется на два, поэтому минус минус, а затем минус минус. 

Таким образом, вы вычесть 2 из фактическая итерация. К сожалению, если ваш итерация является первоначально 1, и вычесть из него 2 после принятия демократии Ганди, как здесь может сделал, потому что он был очень passive-- 1 по шкале агрессивности. Но если он принимает демократию, то он идет от 1 до отрицательного 1. 

К сожалению, они были с помощью чисел без знака, что означает, что они обрабатывают даже отрицательным числа, как если бы они были положительными. И получается, что положительный эквивалент отрицательного 1, в типичных компьютерных программ, составляет 255. Так что если Ганди принимает , И, следовательно, демократия его оценка агрессивности уменьшилась, он на самом деле катается до 255 и делает его самым агрессивный характер в игре. Таким образом, вы Google может на этом. И это было, действительно, случайное программирование ошибка, но это совсем вошел традиционные практические знания до сих пор. 

Это все весело и мило. Страшнее, когда фактическая реального мира устройств, а не игры, имеют те же самые ошибки. На самом деле, всего год назад статья пришла вне о Boeing 787 Dreamliner. 

И статья в первой Взгляд читает немного Arcane. Но это сказал, программное обеспечение Уязвимость в Боинг новый 787 Dreamliner струя имеет потенциал, чтобы вызвать пилотов потерять контроль над самолет, возможно, в середине полета, чиновники FAA предупрежден авиакомпании в последнее время. Это было определение что модель 787 самолет, который был включен непрерывно в течение 248 дней может потерять все переменный ток, переменный ток, электрическая мощность из-за генератора блоки управления, ГПА, одновременно входя в отказоустойчивый режим. Это вроде меня потерять. Но в меморандуме говорится, хорошо, теперь я получил, что, состояние было вызвано программным обеспечением противостоять внутренним по отношению к управление генератором единицы, которые будут переполняться 248 дней непрерывной мощности. Мы выпускаем этот обратите внимание, чтобы предотвратить потерю всего переменного электрического мощность, что может привести к в потере контроля над самолетом. 

Таким образом, в буквальном смысле, есть некоторое целое число, или некоторый эквивалентный тип данных, используется в программном обеспечении в реальном самолете что если вы держите ваш самолет достаточно долго, по-видимому может быть в случае, если вы просто работаете они постоянно и никогда не отсоединив ваш самолет, кажется, или позволяя его батареи умирают, в конечном итоге подсчитать, и вверх, и выше, и выше, и выше, и выше. 

И, по природе, конечное количество памяти переполнится, откате ноль или некоторое отрицательное значение, побочным эффектом которого является пугающе реальная реальность что самолет, возможно, потребуется быть перезагружен, эффективно, или может упасть, что еще хуже, так как она летит. Таким образом, эти виды вопросов все еще с нами, even-- это было 2015 статьи, все более пугающей когда вы не обязательно понимают, ценят, или предвидеть те виды ошибок. 

Так получается, есть еще одна Плохая вещь о представлении данных. Оказывается, что даже поплавки рода недостатки, потому что поплавки тоже, Я предложил 32 бита, или может быть 64, если вы используете двойной. Но это все-таки конечна. 

И улов в том, что если вы можете положить бесконечное число цифр после десятичной точки, нет никакого способа, вы может представлять все возможные числа, которые нас учили в начальной школе может существовать в мире. Компьютер, по существу, должен выбрать подмножество этих чисел для представления точно. 

Теперь, компьютер может раунд может быть, немного, и может позволить вам примерно магазин любое число, которое вы могли бы возможно хотеть. Но только интуитивно, если вы имеют конечное число битов, вы можете только переставлять их во многих конечных путей. Таким образом, вы не можете, возможно, использовать конечное число перестановки битов, шаблоны нулей и единиц, представлять бесконечное количество чисел, который предполагает, что компьютеры могут быть очень хорошо быть лжет нам иногда. 

На самом деле, давайте сделаем это. Позвольте мне вернуться в CS50 IDE. Позвольте мне идти вперед и создать небольшую программу называется Неточность, чтобы показать, что компьютеры, на самом деле, неточны. 

И позвольте мне идти вперед и начать с некоторые из этого кода из ранее, и теперь просто сделать следующее. Позвольте мне идти вперед и делать PRINTF, процент е, обратная косая п, 1 делится на 10. Другими словами, давайте нырять глубже 1/10, как 1 и делится на 10. Конечно, компьютер может представлять 1/10. 

Так что давайте идти вперед и сделать неточностей. Посмотрим. Формат задает тип дважды. Но аргумент имеет тип Int. Что происходит? 

О, интересно, так это Урок, извлеченный из ранее. Я говорю, эй, компьютер шоу я поплавок с процентами ф. Но я даю ему 2 Интс. Так что получается, что я могу исправить это несколькими способами. 

Я мог бы просто превратить один в 1,0 и 10 в 10.0, которая, на самом деле, иметь эффект преобразования их в floats-- все еще надеюсь, то же число. Или оказывается, есть кое-что мы увидим снова в скором времени. Вы могли бы бросить число. 

Вы можете, используя этот вводными выражение, можно сказать, эй, компьютер, возьми 10, который я знаю, является Int. Но относиться к ней, пожалуйста, как будто это поплавок. Но это чувствует себя излишне сложным. 

Для наших целей сегодня, давайте просто буквально делают их значения с плавающей точкой с десятичной точкой, как это. Позвольте мне идти вперед и перекладка, сделать Неточность, хорошо, точка слэш Неточность, введите. Хорошо, мы хорошо выглядеть. 

1 делится на 10, в соответствии с моим Mac здесь, в самом деле, 0,100000. Теперь, я преподавал в начальной школе должно быть бесконечное число 0 '. Итак, давайте по крайней мере попробовать чтобы увидеть некоторые из них. Оказывается, что Printf немного искуснее, чем до сих пор мы использовали. Оказывается, вы не должны указывать только процентов е, или просто процента я. Можно указать на самом деле некоторые опции управления здесь. 

В частности, я собираюсь сказать, эй, Printf, на самом деле показать мне 10 знаков после запятой. Так это выглядит немного странно. Но вы говорите, процентов, Дот, сколько чисел вы хотите видеть после того, как десятичной точки, а затем е для плоских, только потому, что это что говорит документация. Позвольте мне идти вперед и спасти. 

И заметьте тоже, я получаю устал от перепечатывания вещей. Так что я просто установив вверх и стрелка вниз на мои ключи здесь. И если я продолжаю бить, вы может видеть все команды что я сделал, или неправильно сделал. 

И я собираюсь идти вперед сейчас и на самом деле не использовать, что, по-видимому. Сделать неточностей, точка слэш imprecision-- так чему меня учили в класс школы проверяет. Даже если я печатаю его до 10 десятичной ставит его, на самом деле, это 0,10000. Но вы знаете, что? 

Давайте немного жадный. Скажем, как, покажи мне 55 указывает после запятой. Давайте действительно принять это программировать для вращения. Позвольте мне переделать его с макияж Неточность, точка слэш, неточностей. 

И здесь мы идем. Ваше детство было ложью. По-видимому, 1 делится на 10, действительно, 0.100000000000000005551115123-- 

Что происходит? Что ж, получается, если вы вид выглядят достаточно далеко в основной представление этого номер, он на самом деле не точно 1/10, или 0,1 и бесконечное число нулей. Теперь, почему это? 

Что ж, несмотря на то, что это просто число для нас, людей, 1 делится на 10, она по-прежнему один из бесконечно много цифры, которые мы могли бы придумать. Но компьютер может представлять только конечное число так чисел. И так, по сути, то, что Компьютер показывает нам является его ближайшим приближение к числу мы хотим верить в 1/10, или действительно 0,10000 бесконечности. 

Скорее всего, однако, это так близко, как он может получить. И действительно, если посмотреть под капотом, как мы здесь, глядя 55 цифр после запятой, мы действительно видим, что реальность. Теперь, как в сторону, если вы имеете когда-либо видел movie-- большинство из вас, вероятно, haven't-- но Супермен 3 несколько лет назад, Ричард Прайор, по существу заемных средств это на данный момент в его компании, чтобы украсть много фракций и фракций гроши, потому что company-- как я помню, это было while-- было по существу выбрасывая все, что не укладывалось в понятие центов. 

Но если сложить все эти крошечные, крошечные, крошечные числа снова, и снова, и снова, вы можете, как в его дело, сделать хорошую сумму денег. 

Это та же самая идея была сорваны более свежая, но до сих пор в настоящее время старше фильм, который называется Office Space, где ребята в этом фильме, сделал то же самое, напортачил полностью, в конечном итоге с слишком много денег на банковском счете. Все это было очень подозрительно. Но в конце концов, Неточность все вокруг нас. 

И это тоже может быть Пугает дело. Оказывается, что Супермен 3 и офисные помещения в сторону, там может быть какой-то очень реально мировые последствия реалии неточным представление данных что даже мы, люди, к В этот день не обязательно понять, как мы должны, или вспомнить, как часто, как мы должны. И, действительно, следующий клип от взгляда на какой-то очень реальный мир Последствия того, что произойдет, если вы не ценят точностей, может произойти в представлении чисел. 

[ПРОИГРЫВАНИЕ ВИДЕО] 

-Компьютеры, Мы все пришли, чтобы принять что часто расстраивает проблемы, идти с them-- ошибки, вирусы, и программные глюки, за небольшие цены платить для удобства. Но в области высоких технологий и высокой скорости военные и космические программные приложения, самая маленькая проблема может возвеличится в бедствие. 

4 июня 1996 года, ученые подготовили чтобы запустить беспилотный Ariane 5 ракеты. На его борту научно спутники предназначены чтобы точно установить, каким образом взаимодействует магнитное поле Земли с солнечными ветрами. Ракета была построена для Европейское космическое агентство, и оторвался от своего объекта на побережье Французской Гвианы. 

-На Около 37 секунд в полет, они сначала заметил, что что-то происходит не так. Форсунки были в поворотное путь они на самом деле не должны. Около 40 секунд в полете, ясно, что автомобиль был в беде. 

И вот, когда они сделали решение уничтожить его. Офицер безопасности по высоте, с огромные кишки, нажал на кнопку, взорвали ракету, прежде чем она сможет стать угрозой для общественной безопасности. 

-Это Была девичья плавание на Ariane 5. И его разрушение взял место из-за ошибки встроенные в программное обеспечение ракеты. -The Проблема на Ariane была что существует число, требуется 64 бит, чтобы выразить. И они хотели, чтобы преобразовать это до 16-битного числа. Они предположили, что номер никогда не собирался должно быть очень большим, что большинство из тех, цифры в 64-битного числа были нули. Они были не правы. 

-The Неспособность одного программное обеспечение, чтобы принять вид номер, который генерируется другой был в корне сбоя. Разработка программного обеспечения стала очень затратная часть новой технологии. Ariane ракеты были очень успешным, так что большая часть программного обеспечения созданный для него было также используемый в Ariane 5. 

-The Основная проблема заключалась в том, что Ariane 5 был быстрее, ускоряется быстрее. И программное обеспечение не было приходилось за это. 

-The Уничтожение ракеты была огромная финансовая катастрофа, все из-за ошибки минут программного обеспечения. Но это был не первый Проблемы преобразования данных о времени мучило современной ракетной технологии. 

-В 1991, с началом первой войны в Персидском заливе, Патриот Ракетный испытал подобного рода задачи преобразования число. И в результате, 28 человек, 28 американских солдат, были убиты, и около 100 человек получили ранения, когда Patriot, который должен был для защиты от входящих бокоплавов, не удалось выстрелить ракетой. 

-Когда Ирак вторгся в Кувейт, и Америку Буря в пустыне начал в начале 1991 года, Патриот ракетные батареи были развернуты чтобы защитить Саудовскую Аравию и Израиль от иракских ракетных атак Скад. Patriot является американской средней дальности поверхность воздушной системы, производства компанией Raytheon. 

-The Размер перехватчика Patriot сама по себе имеет длину около примерно 20 футов. И весит около 2000 фунтов. И она несет боеголовку около, Я думаю, что это примерно 150 фунтов. А сама боеголовка является высокая взрывчатого вещества, который есть фрагменты вокруг него. Корпус боеголовка разработан, чтобы действовать как картечь. 

-The Ракеты перевозятся четыре в контейнере, и транспортируются полуприцепом. 

-The Patriot системы ПРО восходит по крайней мере, 20 лет. Первоначально он был разработан как противоракетная оборона воздушного чтобы сбивать вражеские самолеты. В первой войне в Персидском заливе, когда эта война пришла вместе, Армия хотела использовать его сбивать бокоплавов, а не самолеты. 

ВВС Ирака было не так много проблем. Но армия волновалась о бокоплавов. И таким образом они пытались обновить Patriot. 

-Intercepting Врага Ракета путешествия в 5М собирается быть сложным достаточно. Но когда Patriot был доставлен в эксплуатацию, Армия не известно о Иракский модификация, которая сделала их бокоплавы почти невозможно попасть. 

-Что Случилось это бокоплавы, что прибывали в неустойчивы. Они были покачиваясь. Причиной этого было иракцы, в порядке чтобы получить 600 километров из 300 км Ракета диапазон, взяли вес из передней боеголовкой. Они сделали боеголовка светлее. 

Так что теперь Патриот пытаясь прийти в Scud. И большую часть времени, Подавляющее большинство времени, было бы просто летать на Scud. После того, как операторы системы Patriot понял, что Patriot пропустил свою цель, они детонировать боеголовку Патриотического чтобы избежать возможных потерь, если она было позволено упасть на землю. 

-Вот Было то, что большинство людей видели, эти большие огненные шары в небе, и не поняли, как перехватывает Скад боеголовок. 

-Хотя В ночное время небо, патриоты появились чтобы быть успешно уничтожая Скада, в Дахране, не может быть никакой ошибки о его исполнении. Там, радиолокационная система Патриотического потерял след входящего Scud, и никогда не запущен из-за к программному изъян. Это было израильтян, которые впервые обнаружен что чем дольше система была включена, тем больше время расхождения стали, из-за часами внедренного в компьютере системы. 

-О За две недели до трагедия в Дахране, Израильтяне сообщили Министерство обороны что система теряет время. Примерно через восемь часов или бега, они заметили, что система становится заметно менее точным. Министерство обороны в ответ говоря все батарейки Patriot не оставлять системы в течение долгого времени. Они никогда не говорили, что долгое время was-- восемь часов, 10 часов, 1000 часов. Никто не знал. 

-The Батареи Patriot размещенных в казарме в Дахране и его недостатки внутренней Часы были на более чем 100 часов в ночь на 25 февраля. 

-Он Отслеживаться время с точностью около одной десятой доли секунды. Теперь, десятую секунды это интересное число, так как оно не может быть выражено в двоичной системе точно, что означает, что она не может быть выражено точно в любом современном цифровом компьютере. В это трудно поверить. 

Но использовать это в качестве примера. Давайте возьмем номер на одну треть. Одна треть не может быть выражается в десятичной системе счисления в точности. Одна треть является 0,333 происходит на бесконечности. 

Там нет никакого способа сделать это с абсолютная точность в десятичной системе счисления. Это именно та проблема что случилось в Patriot. Чем дольше система побежала, хуже стала ошибка времени. 

-После 100 часов работы, Ошибка в то время был только около одной трети секунды. Но с точки зрения ориентируетесь на Ракета путешествия в 5М, это привело к отслеживанию Погрешность более 600 метров. Было бы фатальной ошибкой для солдат на том, что произошло это запуск Scud был детектируется ранних спутников предупреждения и они знали, что Scud был приходят в их общем направлении. Они не знали, откуда он исходит. 

-Это Был теперь до радара компонент системы Patriot защищая Дахране, чтобы найти и сохранить след приближающейся ракеты противника. 

-The Радар был очень умен. Это будет на самом деле трек положение Scud, а затем предсказать, где это возможно будет в следующий раз послал радар импульса вне. Это называется ряд ворот. 

-Тогда, Как только Patriot решает достаточно времени прошел, чтобы вернуться и проверить следующий место для этого обнаруженного объекта, оно восходит. Поэтому, когда он вернулся к неправильному место, тогда не видит объект. И это не решит, что не было объект, это было ложное обнаружение, и капли трек. 

-The Входящий Скад исчез с экрана радара. И через несколько секунд, это врезался в казармы. Скад погибли 28 и был последним один выстрелил во время первой войны в Персидском заливе. 

Трагично, обновленное программное обеспечение прибыл в Дахране на следующий день. Программное обеспечение ошибка была было зафиксировано, закрытие одна глава в мутной История ракеты Patriot. 

[ПРОИГРЫВАНИЕ ВИДЕО] DAVID J. Малан: Так что это все сказать, что эти вопросы переполнения и неточностей все слишком реально. Так как же мы сюда попали? Мы начали с просто говорим о Printf. Опять же, эта функция, печатает что-то на экране, и мы ввели в дальнейшем несколько других функций из так называемой библиотеки CS50 в. И мы будем продолжать увидеть их в свое время. И мы, в частности, используется получения строки, и получить Int, а теперь также получить с плавающей точкой, и все же другие все еще будет мы сталкиваемся и использовать себя в скором времени. 

Но в некоторых случаях, есть мы уже видели необходимость чтобы сохранить то, что эти функции руки обратно? Они раздают нас назад строку, или INT, или с плавающей точкой. И иногда нам нужно положить, что строка, или INT, или с плавающей точкой, где-то. 

И хранить эти вещи, вспомнить, как в пустом месте, у нас есть переменные. Но в отличие от нуля, в C мы имеем фактические типы из данных variables-- типы, больше generally-- среди них, строка, INT, A плавать, и эти другие до сих пор. 

И поэтому, когда мы объявляем переменные в C, мы должны объявить наши типы данных. Это не то, что мы будем должны сделать позже в семестр как мы переход на другие языки. Но сейчас нам нужно к априорно заранее, объяснить компьютеру, какой тип переменной мы хотим, чтобы дать нам. 

Теперь, между тем, чтобы напечатать те виды типов данных, мы должны сказать PRINTF, чего ожидать. И мы увидели процент с для строк, и процент я для целых чисел, и некоторые другие уже. И это просто требования для визуального представления этой информации. 

И каждый из них может быть на самом деле параметризовано или переделаны, в некотором роде, если вы хотите, чтобы в дальнейшем контроль тип вывода, который вы получите. И, на самом деле, оказывается, что не только есть обратная косая п для новой линии. Там кое-что еще называется обратной косой черты г для возврата каретки, которая это больше похоже на старая школа пишущая машинка, а также для Windows используется на протяжении многих лет. 

Там в обратной косой черты т для вкладок. Оказывается, что если вы хотите двойные кавычки внутри строки, напомним, что мы использовали двойные кавычки дважды цитата слева и справа концы наших строк до сих пор. Это, казалось бы, все запутать. 

Если вы хотите поставить двойные кавычки в середина string-- и, действительно, это сбивает с толку, чтобы увидеть. И поэтому вы должны бежать, так говорят, двойные кавычки с чем-то как, в буквальном смысле, обратной косой черты двойные кавычки. И есть несколько других до сих пор. И мы увидим больше тех, в реальных условиях эксплуатации до тех пор. 

Так давайте теперь переход от данных, а также представление, и арифметические операторы, все из которых дал нам некоторые здания блоки, с которыми играть. Но теперь давайте на самом деле дать нам остальная часть словаря что у нас уже было На прошлой неделе с нуля принимая взглянуть на некоторые другие Конструкции в C-- не все из них. Но идеи мы о том, чтобы увидеть на самом деле просто чтобы подчеркнуть перевод с один язык, к царапинам, к другому, C. 

И со временем, мы подберем больше инструментов для нашего инструментария, так сказать, синтаксически. И, на самом деле, вы увидите, что идеи В настоящее время довольно знакомы с прошлой недели. Так давайте сделаем это. 

Давайте идти вперед и нагнетать программу что на самом деле использует некоторые выражения, логическое выражение. Позвольте мне идти вперед здесь и создать новый файл. Я буду называть это condition.c. 

Позвольте мне идти вперед и включают в себя библиотеку CS50. И позвольте мне идти вперед и включают в себя стандарт io.h для наших функций, и Printf, и соответственно больше. Позвольте мне дать себе, что шаблонного из INT главная пустота, чье объяснение, которое мы будем вернуться в будущем. 

Теперь позвольте мне идти вперед и дать сам через INT получите Int. Тогда позвольте мне идти вперед и делать это. Я хочу сказать, если я это less-- давайте различия между положительным, отрицательным, или нулевые значения. 

Так что, если я меньше нуля, дайте мне просто эта программа просто сказать, отрицательный, обратная косая черта п, иначе если я больше нуля. Сейчас я, конечно, хочу сказать, PRINTF положительный результат, обратной косой н. А потом еще if-- я мог бы сделать это. 

Я мог бы сделать, если я равен 0. Но я бы делать на хотя бы одна ошибка уже. Напомним, что знак равенства не равно, как и мы, люди, знаем это. 

Но это оператор присваивания. И мы не хотим принимать 0 на право и положить его в I на левой стороне. Таким образом, чтобы избежать путаницы, или возможно злоупотребление знака равенства, люди решили несколько лет назад что во многих языках программирования если вы хотите, чтобы проверить на равенство между левыми и правыми, вы на самом деле использовать равняется равных. Таким образом, вы попали в знак равенства дважды. Если вы хотите назначить справа налево, использовать один знак равенства. Таким образом, мы могли бы сделать еще this-- если я равен равен нулю. 

Тогда я мог бы пойти и открыть мои фигурные скобки, и сказать, Printf 0, обратная косая черта п, сделано. Но помните, как эти развилок может работать. И, на самом деле, просто подумайте о логике. я это число. Это целое число, в частности. И это означает, что она будет меньше, чем 0 или больше 0, или 0. Таким образом, есть вид этого подразумеваемой случай по умолчанию. 

И таким образом мы могли, так же, как Царапины, обойтись без другого, если, и просто сказать еще. По логике вещей, если ты программист знаю, что есть только три ведра, в которые Сценарий может fall-- первый, второй, или третий в этом case-- не заморачиваться добавляя дополнительную точность и дополнительная логика там. Просто идти вперед с Дело по умолчанию здесь еще. 

Теперь, давайте идти вперед после сохранения этого сделать условия точка слэш conditions-- не большой пользовательский интерфейс, потому что я не побудило пользователь, как я упоминал ранее. Но это нормально. Мы будем держать его просто. Давайте попробуем число 42. И это положительно. Давайте попробуем номер 42 отрицательное, отрицательный. 

Давайте попробуем значение 0. И действительно, она работает. Теперь вы будете видеть проблемы перед длинные, тестирование вещи в три раза, вероятно, не является достаточным. Вы, вероятно, хотите, чтобы проверить некоторые большие числа, некоторые меньше, номера, некоторые частные случаи, как мы приедем, чтобы описать их. 

Но на сегодняшний день это довольно простая программа. И я уверен, что, по логике вещей, что он попадает в трех случаях. И действительно, даже если мы просто сосредоточены на потенциальные недостатки неточностей и переполнения, в реальность, где многие из проблем CS50, в мы не будем беспокоиться о том, все время, эти вопросы переполнения и Неточность, так как, по сути, в C, это на самом деле не все, что легко избежать этих вещей. Если вы хотите, чтобы подсчитать больше, и больше, и больше, оказывается, есть методы, которые Вы можно использовать, часто с участием вещи, называемые библиотеки, коллекции кода, что другие люди писали, что вы можете использовать, и другие языки, такие как Java и другие, на самом деле сделать это намного проще рассчитывать еще выше. Так что на самом деле некоторые из этих опасностей функцией используемого вами языка. И в ближайшие недели, мы будем увидеть, как опасный C действительно может быть, если вы не используете его правильно. Но оттуда, и с Python и JavaScript, будет мы слой на некоторые дополнительные средства защиты, и запустить меньше этих рисков. 

Так давайте сделаем немного больше интересная логика в нашей программе. Итак, позвольте мне идти вперед и создать программа под названием Logical только так я могу играть с некоторыми Фактическая логика, logical.c. Я просто скопировать и вставить некоторые кода из ранее, так что я вернусь к этой хорошей отправной точкой. 

Позвольте мне на этот раз сделать сЬаг C. Я собирается дать ему имя C только потому, что обычные, получить символ от пользователя. А давайте представим, как Я часть реализации из этой программы Rm, то удалить Программа до этого запроса пользователю для удаления файла. Как мы можем это сделать? 

Я хочу сказать, если С равен равно, цитата Unquote, у, то я буду считать, что пользователь выбрал да. Я просто хочу, чтобы напечатать да. Если бы это было на самом деле писать программа удаления, мы могли бы удалить файл с большим количеством строк кода. Но мы будем держать его просто. 

Иначе, если с равно равен N-, и теперь здесь, я собираюсь сказать, пользователь должен иметь в виду нет. А потом еще, вы знаете, что? Я не знаю, что еще пользователь собирается ввести. Так что я просто хочу сказать, что то есть ошибка, то, он или она на самом деле набрали. 

Так что же здесь происходит? Существует принципиальная разница против того, что я сделал в прошлом. Двойные кавычки, двойные кавычки, двойные котировки, и, тем не менее, одиночные кавычки, одиночные кавычки. Оказывается, в C, что, когда Вы хотите написать строку, Вы делаете двойные кавычки, так же, как мы использую все это время с Printf. 

Но если вы хотите иметь дело с просто одиночный символ, так называемый символ, то вы на самом деле использовать одиночные кавычки. Те из вас, кто запрограммирован перед тем, вы не могли бы приходилось беспокоиться об этом Различие в некоторых языках. В C, это действительно имеет значение. И поэтому, когда я получаю полукокса и я хочу для сравнения, что символ с использованием равных равна некоторой буквы как у или п, я, на самом деле, нужно иметь одиночные кавычки. 

Теперь, давайте идти вперед и делать это. Давайте идти вперед и делают логические точка слэш логично. И теперь я быть пробужденным. Так что, по-видимому, лучший пользовательский опыт будет на самом деле сказать, что мне делать здесь. Но я собираюсь просто слепо скажем у для да, хорошо, хорошо. 

Давайте запустим его снова, п для нет, хорошо. Предположим, например, некоторые люди, которых я знаю, мои крышки блокировки ключ на слишком часто. Так что я капитал Y, введите, ошибку. Хорошо, это не совсем то, что я ожидал. В самом деле, компьютер делает то, что в буквальном смысле Я рассказал это do-- проверить в нижнем регистре у и строчные буквы п. Это не чувствует себя хорошо пользовательский интерфейс, хотя. Позвольте мне просить и принять либо в нижнем регистре или в верхнем регистре. Так что получается, вы можете захотеть сказать что-то, как в пустом месте, как буквально или C равна равняется капитала одного цитируемый у. Оказывается, C не имеет это ключевое слово или буквальным. 

Но у него есть две вертикальные полосы. Вам необходимо удерживать клавишу Shift, как правило, если вы используете США клавиатуры, и ударил вертикальную полосу клавишу, расположенную выше вашего возвращения ключа. Но это вертикальная полоса Вертикальная черта означает или. 

Если же, напротив, мы хотим сказать, и, как в пустом месте, мы могли бы сделать амперсанд амперсанд. Это не имеет никакого логического смысла здесь, потому что человек не мог набрали как у и в нижнем регистре у и капитал Y, как тот же характер. Так или то, что мы намерены здесь. 

Так что, если я делаю это в обоих местах, или C равняется капитала равна N, теперь снова запустить, делать логические, перезапускать логично. Теперь я могу ввести у. И я могу сделать это снова капитал Y, или капитал N. И я мог бы добавить в дополнительный Комбинации до сих пор. 

Так что это логично Программа, поскольку в настоящее время Я проверяю логически для это значение или это значение. И я не должен, обязательно, придумать еще два МФС или же МФС. Я могу на самом деле объединить некоторые из связанных с логикой вместе таким образом. Так что это было бы лучше разработаны, чем просто говоря, если С равен строчную у, печать да, иначе, если с равно капитала Y, печать да, иначе, если с равно lower-- другими словами, вы не должны иметь все больше и больше филиалов. Вы можете объединить некоторые из эквивалента ветви логично, так как в этом пути. 

Итак, давайте рассмотрим только один Окончательный ингредиент, один конечная конструкция, что C позволяет. И мы вернемся в будущее другим еще. И тогда мы заключаем, посмотрев при не правильности code-- получение кода work-- но дизайн кода, и посадить эти семена на ранних стадиях. 

Итак, позвольте мне идти вперед и открыть новый файл здесь. Знаешь что? Я собираюсь повторно реализовать та же программа, но используя другую конструкцию. 

Итак, позвольте мне быстро отдамся доступ к включают CS50.h для библиотеки CS50, стандарт io.h для Printf. Дайте мне мою INT главную пустоту. А потом здесь, пусть мне идти вперед и делать это. 

Чар с получает получить символ, так же, как и раньше. И я собираюсь использовать новую конструкцию now-- переключатель, на какой характер? Так переключатель вроде как Переключение железнодорожных путей. Или, на самом деле, это своего рода Условный еще, если еще, если, но написано несколько иначе. 

Переключатель выглядит следующим образом. У вас есть переключатель, и что потом символ или номер, который вы хотите посмотреть, то некоторые фигурные скобки как в Царапины, просто скажем, сделать этот материал. И тогда у вас есть разные случаи. 

Вам не следует использовать, если и еще. Вы в буквальном смысле использовать слово случай. И вы могли бы сказать что-то вроде этого. 

Так что в случае строчной у, или в случае заглавной буквы Y, идти вперед и распечатать да. А потом вспыхнуть переключателя. Вот и все. Были сделаны. 

Иначе, если, так сказать, нижний регистр п, или капитал, N, затем идти вперед и печать вне нет, а затем перерыв. Else-- и этот вид является кейс по умолчанию indeed-- Printf error-- и просто для хорошей мерой, хотя логически этот перерыв не нужен потому что мы находимся в конце переключателя в любом случае, Я сейчас вспыхивают переключателя. Так это выглядит немного по-другому. 

Но, по логике вещей, это на самом деле эквивалентны. И почему бы вы использовать один над другим? Иногда, только личные предпочтения, иногда эстетика, если я смотрю на это Теперь, есть кое-что Надо сказать для читаемость этого кода. Я имею в виду, не говоря уже о том, что это код является новым для многих из нас в комнате. 

Но это только отчасти довольно. Вы видите в нижнем регистре у, капитала Y, нижний регистр N, N капитал по умолчанию, это только отчасти прыжки на вас в пути что, возможно, может быть, предыдущий пример с МСФ и вертикальных стержней, а остальное МФС, не могли бы иметь. Так что это действительно вопрос личного выбор, на самом деле, или читаемость, кода. 

Но с точки зрения функциональности, позвольте мне идти вперед и сделать выключатель, точка слэш переключатель, и теперь ввести в нижнем регистре у, капитал Y, строчные буквы п, капитал N, Дэвид, повторить попытку, потому что это ни одного символа. Давайте сделаем х, ошибка, как и ожидалось. И, logically-- и это то, Я хотел бы призвать в general-- даже хотя мы только поцарапать Поверхность некоторых из этих особенностей. 

И это может быть не очевидно, когда вы самостоятельно сесть за клавиатуру, как это работает? Что бы это сделать? Красивая вещь о том, ноутбук или настольный компьютер, или доступ к компьютеру с помощью компилятора, и с редактором кода, как это, это почти всегда можно ответить на эти вопросы для себя просто попробовать. 

Например, если риторическая Вопрос под рукой были, что произойдет, если вы забыли ваши заявления перерыв? Что на самом деле очень распространенная вещь, чтобы сделать, потому что он не выглядит как вам действительно нужны. Они не действительно завершить думали, как круглые скобки или фигурные скобка делает. Давайте идти вперед и перекомпилировать код и посмотреть. Так сделайте выключатель, точка переключения слэш. Давайте типа в нижнем регистре у, верхний случай, Enter. Таким образом, я напечатал у. 

Программа говорит, да, нет, ошибка, как если бы это было изменение его ум. Но это отчасти было, потому что происходит с переключателем первый случай, Матч по существу означает, эй компьютер, выполнить весь код под ним. И если вы не говорите, перерыв, или не говорите, перерыв, или не говорят перерыв, компьютер будет дуть через все эти линии и не выполнять их все до он получает к этому фигурной скобкой. Поэтому тормоза, действительно, необходимо. Но здесь еда на дом, когда есть сомнения, попробуйте что-нибудь. Может быть, сохранить свой код во-первых, или сохранить его в дополнительный файл если вы действительно обеспокоены Мессинг и того, чтобы восстановить работа, которую вы знаете, работает. 

Но попробовать вещи. И не так страшно, может быть, о том, что компьютер может сделать, или что вы могли бы что-нибудь сломать. Вы всегда можете вернуться назад в какой-то более ранней версии. 

Так что давайте закончим, глядя при проектировании кода. У нас есть эта способность теперь писать условия и циклы записи, и переменные и функции обработки вызовов. Так что, честно говоря, мы вроде обратно в где мы были неделю назад с нуля, хотя и с менее убедительным текстуально Среда, чем нуля позволяет. 

Но обратите внимание, как быстро мы приобрели что словарный запас, даже если это собирается занять некоторое время, чтобы утонуть в, так что теперь мы можем использовать этот словарь писать более интересные программы. И давайте шаг ребенка к что, как следует. Позвольте мне идти вперед и создать новый файл здесь. 

Я буду называть это prototype.c, и ввести в первый раз, способность чтобы сделать свои собственные функции. Некоторые из вас, возможно, сделал это с нуля, в котором вы можете создать свой собственные блоки нуля, а затем перетащить их на место везде, где вы хотели бы в C. И в большинстве программ языки, вы можете сделать именно that-- сделать свои собственные функции, если они уже не существуют. 

Так, например, позвольте мне идти вперед и включают CS50.h, и включают в себя стандарт io.h, INT главный недействительным. И теперь у нас есть заполнителя готов к работе. Я держу печати вещи как имена людей сегодня. И это чувствует себя like-- не было бы неплохо, если бы были функция называется имя печати? Я не должен использовать Printf. Я не должен помнить все коды формата. Почему не я, и почему не сделал кто-то передо мной, создать функцию под названием печати имя, что дано какое-то название, просто печатает его? 

Другими словами, если я говорю, эй, компьютер, дайте мне строку спрашивая у пользователя, например, с помощью функции получения строки CS50 в. Эй, компьютер, поместить эту строку в переменная в левой части, и называют это S. А потом, эй компьютер, идти вперед и печать, что имя человека, сделано. 

Теперь, было бы неплохо, потому что эта программа, метко назвал, говорит мне, что он должен делать путем имен тех, функции. Позвольте мне пойти и сделать прототип, Enter. И, к сожалению, это не будет летать. 

Prototype.c, строка 7, характер 5, ошибка, неявное объявление функции печати имени недопустим в C99, C99 означает версию C который вышел в 1999 году. Это все. 

Так что я не знаю, что все это означает, что до сих пор. Но я признать ошибку в красном цвете. Это довольно очевидно. 

И мне кажется, что с зеленый символ здесь, проблема связана с именем печати, откройте PAREN s, близкие PAREN, полусинтетические толстой кишки. Но неявное декларация функция, которую мы видели кратко ранее. Это означает, просто, что Clang не знает, что я имею в виду. 

Я использовал Кодовое слово, что это никогда не видел и не учили раньше. И поэтому мне нужно, чтобы научить его что значит эта функция. Так что я собираюсь идти вперед и делать это. 

Я собираюсь идти вперед и реализовать моя собственная функция называется Print Name. И я буду говорить, как это следует, что он делает это, PRINTF, привет, процентов s, обратный слэш н, имя, точка с запятой. Так что же я только что сделал? 

Так что получается, чтобы реализовать свою собственную функцию, мы как-то позаимствовать некоторые из та же структура, как главный что мы только что были нечто само собой разумеющееся, и я знаю, просто скопировать и приклеивание довольно много, что Я писал в прошлом. Но обратите внимание на образец здесь. Int, Main, Пустота, мы будем дразнить друг от друга до того долго, что это на самом деле означает. 

Но на сегодняшний день, как раз обратите внимание на параллелизм. Пустота, имя печати, имя строки, так что есть фиолетовое ключевое слово, который мы собираемся начать вызывая тип возвращаемого значения, имя функция, а затем ввод. Так что, на самом деле, мы можем перегонять этот вид, как на прошлой неделе поскольку это имя или алгоритм кода мы находимся собирается write-- алгоритм, лежащий в основе код, который мы собираемся написать. 

Это его вход. Это его выход. Эта функция, имя печати, является разработан, чтобы взять строку с именем имя, или независимо от того, в качестве входных данных, а затем аннулируются. Она не возвращает ничего, как получить строку или получить INT делает. Так что он собирается передать мне что-нибудь. Это просто будет иметь побочный эффект, так сказать, печатать имя человека. Так обратите внимание, строка 7, я можно назвать имя печати. Строка 10, я могу определить или реализуют имя печати. Но, к сожалению, этого недостаточно. 

Позвольте мне идти вперед и перекомпилировать это после сохранения. Вау, теперь, я сделал это хуже, казалось бы. Таким образом, неявное объявление имя функции печати недействителен. И, опять же, есть больше ошибок. Но, как я предупредил ранее, даже если вы получаете завалены, или немного грустно видеть так много Ошибки, сосредоточиться только на первый на начальном этапе, так как это может быть просто имели каскадный эффект. Так C или Clang более конкретно, до сих пор не признает имя печати. 

И это потому, что Clang, дизайн, это своего рода немой. Это только делает то, что вы скажете ей сделать. И это только делает это в порядке в котором вы скажете ей сделать. 

Таким образом, я определил главный на четвертой строке, как мы делали довольно часто. Я определил имя печати в строке 10. Но я пытаюсь использовать печатать имя на линии семь. 

Это слишком рано, пока не существует. Так что я мог быть умным, и быть, как, ОК, так что давайте просто играть вместе, и переместить имя печати вверх здесь, и пересобрать. О мой Бог. Это сработало. Это было так просто. 

Но логика именно это. Вы должны научить Clang, что это является путем определения функции первого. После этого вы можете использовать его. Но, честно говоря, это чувствует как скользкого. 

Так что каждый раз, когда я бегу в проблему, я просто собирается выделить и скопировать код Я написал, вырезать его и вставить его сюда. И, конечно, мы могли бы изловчиться некоторые сценарии где одна функция может нужно позвонить другому. И вы просто не можете поместить каждый функция выше любой другой. 

Так получается, что есть лучшее решение. Мы можем оставить это быть. И, честно говоря, это вообще приятно, и удобно, и хороший дизайн поставить главный во-первых, потому что, опять же, Главным же, как когда зеленый флаг щелкнул, то есть функция, запускается на выполнение по умолчанию. Таким образом, вы можете также поместить она в верхней части файла так что, когда вы или любой другой человек смотрит на файл Вы знаете, что происходит просто прочитав главный первый. Так что получается, мы можем сказать Clang проактивно, эй, Clang, на четвертой строке, Я обещаю реализовать функция называется Print Имя, которое принимает строку называется имя в качестве входных данных и возвращает ничего, пустота. И я обойти реализации его позже. 

Здесь приходит Main. Главное теперь в строке 9 можно использовать Печать имени, потому что Clang надеющийся, что, в конце концов, она будет сталкиваться с определением осуществления печати Название. Таким образом, после сохранения мой файл, пусть мне идти вперед и сделать прототип, выглядит хорошо на этот раз. Дот слэш, прототип, позвольте мне идти вперед и ввести имя. Дэвид, привет David, Zamila, привет Zamila, и, на самом деле, теперь он работает. 

Таким образом, компонент здесь является то, что мы в сделал пользовательскую функцию, как обычай Царапина блок мы называем его. Но в отличие от нуля, где вы можете просто создать его и начать использовать его, Теперь мы должны быть немного более педантичным, и на самом деле поезд Clang использовать, или ожидать его. Теперь, как в сторону, почему все это время мы были просто слепо на веру, включая CS50.h, и в том числе стандартных io.h? 

Что ж, получается, среди нескольких других вещей, все, что в этих точек ч файлы, которые, случается, файлы. Они файлы заголовков, так сказать. Они по-прежнему написаны на C. Но они другой тип файла. 

На данный момент, вы можете в значительной степени предположить, что все, что находится внутри CS50.h это некоторые остротами, как это, не для функций, вызываемых печати Имя, но для получения строки, получить Поплавок, и несколько других. И есть подобные прототипы, лайнеры, внутри стандартного io.h для Printf, который сейчас находится в моя собственная функция печати Имя. Итак, другими словами, все это время мы в просто слепо копируя и вставляя включить это, включают в себя что, что происходит? Это просто вид подсказок звенеть относительно того, что функции которые, действительно, реализованы, просто в других местах в разных файлах в другом месте в системе. 

Таким образом, мы реализовали имя печати. У него есть этот побочный эффект печать что-то на экране. Но это не на самом деле передать мне что-нибудь. Как мы идти о реализации программы, которая это передать мне что-нибудь? 

Что ж, давайте попробуем это. Позвольте мне идти вперед и реализовать файл с именем return.c так что мы можем показать, как что-то как получить строку, или получить Int, на самом деле возвращение что-то обратно пользователю. Давайте идти вперед и определить Int основную пустоту. 

И, опять же, в будущем, мы будем объяснить, что это Int и эту пустоту на самом деле делает. Но на сегодняшний день, мы будем принимать как должное. Я собираюсь идти вперед и Printf, для хорошего пользовательского опыта, х. А потом я буду ждать Пользователь, чтобы дать мне х с GET Int. 

А потом я собираюсь идти вперед и распечатать х на площадь. Поэтому, когда у вас есть только клавиатура, люди часто использовать маленькую морковь символ на клавиатуре представлять к власти из, или показатель. Так что х в квадрате присутствует я. 

А теперь я собираюсь сделать это. Я мог бы просто do-- что х в квадрате? х в квадрате х раз х. 

И мы сделали это некоторые давно уже сегодня. Это не похоже все, что значительный прогресс. Знаешь что? Давайте использовать некоторые из этой идеи от последнего времени абстракции. 

Не было бы хорошо, если есть функция, называемая квадрат, который делает именно это? Он по-прежнему, в конце день, делает то же математику. Но давайте абстрактные прочь идея взятия одно число, умноженное на другой, а просто дать ему имя, как квадрат это значение. 

И, другими словами, в C, давайте создадим функцию называется квадрат, который делает именно это. Это будет называться квадрат. Он собирается принять Int. И мы будем просто называть его п, по умолчанию. 

Но мы могли бы назвать это все, что мы хотим. И все, что он собирается делать, в буквальном смысле, является возвращение результат п раз п. Но так как это возвращая что-то, что является ключевым словом в фиолетовый мы в никогда не видел раньше, я, в строке 11, не может просто сказать, пустота на этот раз. 

Пустота, в примере, который мы только что видели а названия печати, просто означает, сделай что-нибудь. Но не дай мне что-нибудь. В этом случае, я хочу для возврата в п раз п, или независимо от того, что есть, это число. 

Так что я не могу сказать, эй, компьютер, Я не вернусь ничего, пустота. Это собирается вернуться, по своей природе, в Int. И так, что это все, что здесь происходит. 

Вход на площадь собирается быть инт. И так, что мы можем использовать его, он должен есть имя, N. Это собирается выводить INT, который не нужно имя. Мы можем оставить его на главную, или тот, кто используя меня, чтобы помнить это значение, если мы хочет со своей собственной переменной. 

И, опять же, только новый Ключевое слово здесь Return. И я просто делаю некоторые математике. Если бы я действительно хотел быть ненужным, Я мог бы сказать INT продукт получает п раз п. 

И тогда я мог бы сказать, вернуть продукт. Но, опять же, к моей точке ранее из это просто не быть хорошим design-- как, зачем вводить имя, символ, как продукт, просто немедленно вернуть его? Это немного чище, немного жестче, так говорить, просто сказать, возвращение п раз п, чтобы избавиться от этой линии в целом. 

И это как раз меньше кода, чтобы читать, меньше возможностей для ошибок. И давайте посмотрим, если это на самом деле в настоящее время работает. Теперь, я собираюсь пойти вперед и сделать возврат. 

Ой-ой, неявное объявление функции. Я сделал эту ошибку раньше, не составило большого труда. Позвольте мне просто напечатать, или выделить и скопировать, точно такой же прототип функции, или подписи, функции здесь. Или я мог бы переместить всю функцию. 

Но это немного ленивый. Таким образом, мы не будем этого делать. Теперь, позвольте мне сделать возвращение опять же, точка возврата косой черты. 

х в квадрате 2. х 4. х квадрат 3. х 9. И функция кажется Теперь, чтобы работать. Так какая разница здесь? У меня есть функция, которая называется квадрат, в этом случае, который я поставил в качестве вклада. И я получаю обратно выход. И тем не менее, ранее, если Я открываю другой пример от ранее, что был назван prototype.c, У меня было имя печати, который вернулся недействительным, если можно так выразиться, Или это не дал ничего, и просто имел побочный эффект. 

Так что же здесь происходит? Что ж, рассмотрим функцию получить строку на мгновение. Мы используем функцию получить строку следующим образом. 

У нас было функция получить строка, как включать CS50.h, включают в себя стандартные io.h, INT, основной, недействительным. И тогда каждый раз, когда я называется получения строки до сих пор, Я сказал что-то вроде, строка s получает получить строку, потому что string-- Get давайте назовем эту get.c-- строку GET сама возвращает строку, я могу потом использовать, и сказать, привет, запятая, процентов s, обратная косая п, з. 

Так что это тот же самый пример, на самом деле, что у нас было раньше. Так что строка возвращает значение. Но мгновение назад, строка для печати не возвращает значение. Он просто имеет побочный эффект. Так что это принципиальная разница. Мы видели разные типы функций в настоящее время, некоторые из которых вернулись значения, некоторые из которых не делают. Так может быть, это строка, или INT, или с плавающей точкой. Или, может быть, это просто пустота. 

И разница что эти функции, получить данные и возвращает значение, на самом деле в результате чего-то обратно к столу, так сказать. Так что давайте идти вперед и смотреть на один окончательный набор примеров, что дает ощущение, теперь, как мы могли бы, в самом деле, абстрактные лучше, и лучше, и лучше, или больше, и больше, и больше, для того, писать, в конечном счете, лучший код. Давайте идти вперед, и в духе скретч, сделайте следующее. 

Позвольте мне идти вперед и включают в себя CS50.h и стандарт IO.h. Позвольте мне идти вперед и дать я INT, главным образом, пустота. И позвольте мне идти вперед, называем это cough.c. 

И позвольте мне идти вперед и просто как царапина, распечатать кашель / п. И я хочу сделать это три раза. Так что я, конечно, просто собирается скопировать и вставить три раза. Я сейчас собираюсь сделать кашель точка слэш кашель. Давайте дадим себе немного больше места здесь, Enter, кашель, кашель, кашель. 

Там в, очевидно, уже возможность для улучшения. Я скопировал и вставил несколько раз сегодня. Но это было только поэтому я не сделал должны набрать столько символов. Я до сих пор изменилось, что эти строки кода. 

Эти три линии идентичны, который чувствует себя ленивым и в самом деле есть, и, вероятно, не правильный подход. Так с какой ингредиент мы могли бы улучшить этот код? Мы не должны копировать код. 

И действительно, в любое время вы чувствуете самостоятельно копирования и вставки, и даже не меняя код, Шансы есть лучший способ. И, действительно, есть. Позвольте мне идти вперед и сделать цикл, даже при том, что синтаксис не может приходят, естественно, пока нет. 

Сделайте это три раза, просто , делая following-- и я знаю это из практики. Но у нас есть ряд примеров, в настоящее время. И вы увидите онлайн больше ссылок до сих пор. 

Это синтаксис в строке 6, что так же, как нуля, который повторяется блок, повторите следующие три раза. Это немного волшебный сейчас. Но это будет получить больше, и более знакомым. 

И это будет повторяться линия восемь три раза, так что если я перекомпилирует макияж кашель, точка слэш кашель, кашель, кашель, кашель. Он по-прежнему работает точно так же. Так что это все прекрасно и хорошо. Но это не очень абстрактно. 

Это совершенно правильно. Но он чувствует, как там может быть возможность, как и в мире Царапины, чтобы вид старта чтобы добавить некоторую семантику здесь, так что Я не просто какой-то цикл, и функция, которая говорит кашель, или же кашель. Знаешь что? Позвольте мне быть немного холоднее, чем, и на самом деле написать функцию, которая имеет некоторые побочные эффекты, называют его кашель. 

И это не имеет никакого ввода и не возвращает значения в качестве вывода. Но вы знаете, что он делает? Он делает this-- Printf, цитата Unquote, кашель. 

И теперь здесь, я собираюсь идти вперед и для Int, я получает ноль, я меньше, чем 3, я плюс плюс. Я собираюсь не делать Printf, что возможно, реализация низкого уровня подробно. Меня не волнует, как кашель. Я просто хочу, чтобы использовать функцию от кашля. И я просто буду называть кашель. 

Теперь обратите внимание на дихотомии. При вызове функции, если вы этого не сделаете хотят, чтобы дать ему входы, совершенно нормально. Просто сделайте открытые скобка, близко скобка, и вы сделали. 

При определении функции, или объявить прототип функции во, если вы заранее знаете, это не собирается принимать какие-либо аргументы, говорят, пустота в этих скобках там. И это гарантирует, что вам не случайно неправильного обращения с ним. Позвольте мне идти вперед и сделать кашель. И, конечно же, я сделал ошибку. 

Проклятье, есть то, что неявное объявление. Но это нормально. Это легко исправить. Мне просто нужно прототип выше в моем файле, чем я на самом деле использовать его. 

Так что теперь позвольте мне сделать кашель снова, приятно. Теперь она работает. Сделать кашель, кашель, кашель, кашель. Таким образом, вы можете подумать, что мы на самом деле чуть более инженерных эту проблему. И действительно, мы. Это не очень хорошая кандидат программы на данный момент для рефакторинга, и делать то, что называется иерархическое разложение, где вы берете какой-то код, а затем вы вроде фактора вещи, так что, как приписывать больше семантики к ним, и использовать его в конечном счете, более длительный срок. Но это строительный блок в сторону более сложные программы что мы начнем письменной форме до тех пор, что позволяет нам иметь словарный запас с которой лучше писать код. И действительно, давайте посмотрим, если мы не может обобщить это дальше. 

Это кажется немного хромает, что я, главным образом, нужно беспокоиться об этом штопать для цикла, и вызывая кашель снова и снова. Почему я не могу просто сказать кашель, пожалуйста, кашель в три раза? Другими словами, почему я не могу просто дают вклад в кашель и сделать это? 

Почему я не могу просто сказать, в Основной кашель в три раза. И теперь, это своего рода магическое. Это очень итерационный здесь. И это, действительно, шаг ребенка. 

Но только способность говорить на линия восемь, кашель в три раза, это просто так гораздо более удобным для чтения. И, плюс, я не должен знать или все равно, как осуществляется кашель. И действительно, позже в срок и для окончательных проектов, если вы решать проект с одноклассник или два одноклассники, вы поймете, что вы собираетесь должны, или хотите, разделить работу. 

И вы будете хотеть, чтобы решить, заранее, кто будет делать то, что, и в какие части? И не было бы приятно если вы, например, взять на себя ответственность написания главным образом, сделано. А ваш сосед по комнате, или ваш партнер в более общем плане, заботится о реализации кашель. 

И это разделение, эти стены абстракции, или слои абстракции если вы, супер мощный, потому что особенно для больших, более сложные программы и системы, она позволяет нескольким людям строить все вместе, и в конечном счете сшить их совместную работу таким образом. Но, конечно, мы нужно исправить прямо сейчас кашель. Мы должны сказать кашель что, эй, вы знаете, что? Вы будете нуждаться, чтобы взять input-- поэтому не пустота, а INT и теперь. Давайте идти вперед и положить в кашель ИНТ. я получает ноль. 

я меньше, чем во сколько раз. Я сказал три раньше. Но это не то, что я хочу. Я хочу, чтобы кашель быть обобщена поддерживать любое количество итераций. 

Так что, на самом деле, это п, что я хочу, все, что пользователь говорит мне. Теперь я могу идти вперед и сказать печати кашель. И независимо от того, какой номер пользователь переходит в, Я буду повторять, что во много раз. 

Таким образом, в конце концов, Программа идентична. Но обратите внимание на все эти вещи может быть даже в другом файле. На самом деле, я не знаю, на Момент, как Printf реализуется. 

Я не знаю, на данный момент, как получить строка, или получить Int, или получить с плавающей точкой реализуются. И я не хочу увидеть их на моем экране. Как это, я начинаю сосредоточиться на моя программа, а не те функции. 

И так, в самом деле, как только вы начать факторинга код, как это, мы могли бы даже двигаться кашель в отдельный файл? Кто-то другой мог бы осуществить это. И вы и ваша программа стала очень красивый, и очень легко читаются, возможно, на самом деле четыре линии программы прямо там. 

Так что давайте идти вперед прямо сейчас и сделать еще одно изменение. Обратите внимание на то, что мой прототип должен измениться до вершины. Итак, позвольте мне исправить что так Я не получаю кричал на. 

Сделать кашель, позвольте мне бежать кашель один раз Более того, по-прежнему делает то же самое. Но теперь, заметьте, мы имеем ингредиент для одной окончательной версии. Знаешь что? Я не хочу, чтобы просто кашель, обязательно. Я хочу иметь что-то более общее. Таким образом, вы знаете, что? Я хочу сделать это. Я хочу иметь, так же, как нуля делает, блок скажем, но не только сказать что-то некоторое количество раз. Я хочу сказать, очень конкретную строку. И, следовательно, я не хочу, чтобы просто сказать, кашель. Я хочу сказать, что бы ни строка передается в. 

Поэтому обратите внимание, я обобщил это так, что в настоящее время скажем чувствует себя доброе имя для этого, как нуля, принимает два аргумента, в отличие от нуля. Одним из них является строкой. Одним из них является Int. 

И я мог переключаться между ними. Я просто вроде как идея говорят строку, а затем сколько раз позже. Пустота означает, что он до сих пор ничего не возвращает. Это лишь визуальная сторона эффекты, как с [? Джордан,?] словесное побочный эффект орать. Он по-прежнему делает что-то п раз, 0 до, но не равно п. Это означает, что общее время п. А потом просто распечатать что бы это ни строка. Так что я действительно обобщена эта строка кода. Так что теперь, как я могу реализовать функция от кашля? 

Я могу сделать недействительным кашель. И я все еще могу взять в том, много раз вы хотите, чтобы кашель. Но вы знаете, что? Теперь я могу сказать, Пунт. 

Я могу позвонить сказать с слово кашель, переходя в п. И если я хочу также осуществить, просто для удовольствия, функция чиханье, Я могу чиханье некоторое количество раз. И я могу многократно использовать п, потому что обратите внимание, что т в данном контексте или объема существует только внутри этой функции. 

И п в этом контексте только существует в рамках этой функции здесь. Таким образом, мы вернемся к эти вопросы сферы. И вот, я просто хочу сказать, Achoo, а затем п раз, точка с запятой. 

А теперь, мне просто нужно занять эти функции подписи здесь. Так что кашель является правильным. Пустота чих теперь правильно. 

И я до сих пор просто нужно сказать. Так что я буду говорить, скажем строка s, Int N, точка с запятой. Таким образом, я чрезмерно спроектировали черт из этой программы. 

И это не обязательно означает, что это что вы должны сделать при написании даже самые простые программы. Возьмите что-то, что, очевидно, очень просто, очень короткий, и повторно реализовать его используя слишком много кода. Но вы на самом деле видите, и в время оглянуться назад на этих примерах, и осознать, о, это те шаги мы взяли на самом деле обобщать, фактор что-то, до тех пор, пока в конце дня мой код на самом деле довольно разумно. Потому что, если я хочу, чтобы кашель три раз затем чихнуть три раза, Я просто собираюсь запустить повторно, Программа делает кашель, и запустить кашель. И у меня есть три кашляет и три чихает. 

И так это основной парадигма, если вы будете, за то, как мы могли бы идти о на самом деле реализации программы. Но давайте просто посмотрим, что теперь это мы делаем все это время, и то, что некоторые из заключительных частей позади этой простой команды. В конце концов, мы использовали Clang в качестве нашего компилятора. Мы писали источник код, превращая его с помощью Clang в машинный код. 

И мы используем только сделать чтобы облегчить наши нажатия клавиш так что мы не должны помнить, эти заклинания самого Clang. Но что это сделать на самом деле делать? И, в свою очередь, является то, что Clang на самом деле делать? 

Оказывается, хотя мы упростили сегодняшнее обсуждение, сказав, вы берете исходный код, передать его в качестве вход компилятора, который дает вам Выход машины код, оказывается, есть несколько различных шагов внутри там. И компилирование случается зонтик термин для целого ряда шагов. Но давайте просто дразнить на это очень быстро. 

Оказывается, что мы делаем больше вещей, каждый раз, когда я запустить программу, или каждый раз, когда я скомпилировать программу сегодня. Таким образом, предварительная обработка относится к this-- ничего в программе C, как мы увидим снова и снова, который начинается с этой хэш-символа, или символ Хештег здесь, означает, это директива препроцессора. Это означает, что, в данном случае, эй компьютер, сделать что-то с этим файлом прежде чем вы на самом деле скомпилировать мой собственный код. 

В этом случае, хэш включают есть, по сути, путь C способ сказать, эй компьютер, перейдите получить содержимое из CS50.h и вставить их здесь. Эй компьютер, пойти получить содержание стандартного io.h, везде, где это находится на жесткий диск, вставить его здесь. Так что эти вещи случаются сначала во время предварительной обработки. 

И Clang делает все это для нас. И это делает это так штопать быстро, вы даже не увидеть четыре различных вещей происходит. Но это первый такой шаг. 

Что на самом деле происходит дальше? Ну, следующий официальный шаг компиляции. И получается, что составление программы технически означает переход от исходный код, то материал, который мы писал сегодня, к чему-то называется код сборки, что-то что выглядит несколько иначе. 

И в самом деле, мы можем видеть это очень быстро. Позвольте мне на самом деле пойти в мой IDE. Позвольте мне идти вперед и открыть hello.c, который самая первая программа, с которой мы начался сегодня. И позвольте мне идти вперед и запустить Clang A немного по-другому, Clang-s, hello.c, которая на самом деле собирается дайте мне еще один файл hello.s. 

И мы, вероятно, никогда снова увидеть этот вид кода. Если взять более низкий уровень Системы класса, как CS61, вы увидите намного больше из такого кода. Но это язык сборки. Это X86 ассемблере что процессор, который лежит в основе CS50 IDE на самом деле понимает. 

И загадочно, как это делает смотрите, это что-то компьютер понимает очень хорошо. Sub кв, это вычитать. Там в движение. 

Там звонит функций здесь, х ORing, движение, надстройка, поп, возвращение. Так что есть какая-то очень инструкции низкого уровня что процессоры понимают, что Я упоминал ранее. То есть то, что Intel Inside. 

Есть модели нули и единицы, что сопоставить эти arcanely формулировку, однако несколько хорошо имени, инструкции, так сказать. Это то, что происходит, когда компиляции кода. Вы получаете сборки язык из него, который означает, третий шаг заключается в сборке что код сборки в конечном счете, машина code-- нули и единицы, а не текст, который мы только что видели минуту назад. 

Таким образом, предварительная обработка делает, что найти и заменить, и несколько других вещей. Компиляция принимает ваш источник кода из C, исходный код что мы уже писали, в сборе код, который мы только что посмотрел на. Сборка занимает эту сборку код нулей и единиц что процессор действительно будет понять, в конце рабочего дня. И связывание является последним шагом что происходит из-за us-- снова, так быстро мы не делаем даже notice--, что говорит, эй компьютер, взять все нули и единицы, которые в результате компиляции кода Давида, и его основной функцией в этом случае. 

И эй компьютер, иди все нули и единицы что сотрудники CS50 писал внутри библиотеки CS50. Смешайте те, с Дэвида. И эй компьютер, пойти получить все нули и те, что кто-то написал несколько лет назад для Printf. И добавить таких устройств в Все это, так что мы получил мои нули и единицы, тем нули и единицы персонале CS50, в то PRINTF нули и единицы, и все остальное, что мы используем. 

Все они получают объединены в одну Программа под названием, в данном случае, привет. Так что отныне мы будем просто использовать слово компиляции. И мы считаем само собой разумеющимся, что, когда мы говорим, скомпилировать программу, то это означает, эй делать предварительную обработку, монтаж и связь. Но есть на самом деле некоторые сочные вещи там происходит под капотом. И особенно если вы получить любопытную некоторое время, вы можете начать тыкать вокруг на этом более низком уровне. Но сейчас понимаю, что среди на сегодняшний день еды на дом довольно просто начало процесса, получения комфортно что-то вроде привет мир. Действительно, большая часть того, что мы сделали сегодня конечно же, не будет тонуть в супер быстро. И это займет некоторое время, и некоторые практики. И шансы, вы будете сортировать от того, хотят ударить клавиатуры или кричать на экране. И все это нормально. Хотя, возможно, стараюсь не сделать это в библиотеке так много. 

И в конечном счете, вы будете быть в состоянии, хотя, чтобы начать видя картины, как в хорошем коде что вы написали и в ошибках что вы сделали. И так же, как процесс став TF или СА, как, вы начнете становиться все лучше и лучше видеть эти модели, и просто решения ваших собственные проблемы в конечном счете. В то же время, там будет много из нас, чтобы оказать вам поддержку, и вы получите сквозь это. А в записи окна для всех проблем, вы будете руководствоваться через все команды что я, конечно, знаю, из много практики в настоящее время, но, возможно, прилетел над головой на данный момент. И это совершенно нормально. 

Но, в конечном счете, вы собираетесь чтобы начать видеть закономерности. И как только вы пройти все из тупые детали, такие как круглые скобки, и фигурные скобки и точки с запятой, и вещи, честно говоря, что не на всех интеллектуально интересным. И это не цель принимая любой вводный класс. Это идеи, которые идут к материи. 

Это петли, и условий, а также функции, и более мощно абстракция, и факторинговая кода, и хороший дизайн, и хорошее стиль, и в конечном счете правильность вашего кода, что в конечном счете собирается иметь значение больше всего. Так что на следующей неделе, мы будем принимать эти идеи, которые мы впервые увидели в пустом месте и теперь переведены до C. И мы начнем ввести первый из реального мира домены курса. 

Мы сосредоточимся на мир безопасности, и более конкретно криптография, искусство карабкаться информации. И в числе первых проблемы вы сами получите писать дальше играя с некоторыми из синтаксиса и решая некоторые логические проблемы, в конечном счете, в скором времени, это на самом деле засекретить, или зашифровать, и в конечном счете расшифровать информацию. И все, что мы сделали сегодня, будет достаточно низким уровень, только собирается, чтобы позволить нам взять один, и один, и еще один шаг в сторону выше написание самый интересный код еще. 

Так что больше на этом на следующей неделе. 

[ПРОИГРЫВАНИЕ ВИДЕО] 

Что вы можете рассказать мне о в последний раз вы видели его? -Что Я могу сказать, на самом деле? Я имею в виду, это было как и любой другой подготовка производства репетиция, за исключением того, что-то было, он сказал: в самом конце, что застрял со мной. 

-Это Был CS50. 

-Вот Вырезать все, отличная работа на репетиции. 

обед -Вот? 

-Да, Ты и я могу захватить бутерброд немного. Позвольте мне просто опрашивать с Дэвид очень быстро. Дэвид? Дэвид? 

[КОНЕЦ ВОСП] 