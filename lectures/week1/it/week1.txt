[RIPRODUZIONE DI BRANI MUSICALI] David J. MALAN: Va bene, questo è CS50. E questo è uno settimana. Così ricordare che l'ultima volta a settimana pari a zero, ci siamo concentrati sul pensiero computazionale. E noi la transizione da quello a Scratch, una programmazione grafica lingua da parte dei nostri amici al Media Lab del MIT. 

E con Scratch, abbiamo esplorare idee come funzioni e le condizioni, e loop, e variabili, e anche eventi e discussioni, e altro ancora. E oggi, stiamo andando a continuare a usare quelle idee, e davvero li prendere per scontato, ma tradurli in un'altra lingua conosciuta come C. Ora, C è un linguaggio più tradizionale. Si tratta di un livello più basso lingua, se si vuole. 

E 'puramente testuale. E così, a prima vista, è tutto andando a guardare piuttosto criptico se non hai mai programmato prima. Stiamo per avere punto e virgola, e parentesi, e parentesi graffe, e altro ancora. Ma rendersi conto che anche anche se la sintassi è per guardare un po 'sconosciuto per la maggior parte di voi, vedere oltre quello. E cercare di vedere le idee che sono, infatti, familiare, perché qui in settimana una cosa inizieremo a fare è quello di confrontare, Inizialmente, Scratch contro C. 

Così, per esempio, ricordare che quando implementato il primo dei nostri programmi l'ultima volta, abbiamo avuto un blocco che sembrava un po 'di qualcosa come questo-- quando bandiera verde cliccato, e poi abbiamo avuto uno o più pezzi del puzzle sotto di essa, in questo caso, dire, ciao mondo. Così, infatti, in Scratch, quando si sceglie quella bandiera verde per eseguire il mio programma, in modo da parlare, questi sono i blocchi che vengono eseguiti o eseguiti. E, in particolare, Scratch detto, ciao, mondo. 

Ora, avrei potuto specificato parole diverse qui. Ma vedremo che, in effetti, molti di questi blocks-- e in effetti, in C molti functions-- possono essere parametrizzate o personalizzato di fare cose diverse. Infatti, in C se desidera convertire, ora, questo programma Scratch a tale lingua, stiamo andando a dare una po 'di qualcosa di simile. 

Certo, vi è una certa familiarità sintassi lì molto probabilmente, int, e tra parentesi, e vuoto. Ma printf-- anche se si farebbe penso che sarebbe solo di stampa. Ma stampa significa stampa formattato, come vedremo tra poco. Questo letteralmente stamperà alla schermata qualunque è all'interno di quelle parentesi, che Naturalmente in questo caso è, ciao mondo. 

Ma si noterà qualche altro sintassi, alcuni doppi apici, che le parentesi alla fine, il semi-colon e simili. Quindi c'è un po 'di testa, per così dire, sia cognitivamente e sintatticamente, che stiamo andando di dover ricordare in breve tempo. Ma rendersi conto che con la pratica, questo inizierà a saltare fuori di te. 

In effetti, concentriamoci su quello Funzione specifically-- in questo caso, dire ciao mondo. Quindi dire che è la funzione. Ciao mondo è il suo parametro, o argomento, la sua personalizzazione. 

E l'equivalenza in C è solo sta per essere presente una riga qui, dove printf è equivalente a, diciamo, la stringa doppia citato, ciao mondo è equivalente, naturalmente, a ciò che è nel riquadro bianco lì. E il backslash n, anche se un po ' strano e assente da zero, semplicemente sta per avere l'effetto faremo vedere in un computer, come il mio Mac o un PC, di appena spostare il cursore alla riga successiva. E 'come colpire Invio sulla tastiera. 

Così vedremo di nuovo in poco tempo. Ma prima, diamo uno sguardo a questo altro esempio nel caso di loop. Abbiamo avuto questo per sempre anello ultima volta, che era una serie di pezzi del puzzle che ha fatto qualcosa di letteralmente forever-- in questo caso, dire ciao mondo, ciao mondo, Ciao mondo, ciao mondo. Quindi è un ciclo infinito di progettazione. 

In C, se vogliamo attuare questa stessa idea, si potrebbe semplicemente fare questo. Mentre vero, printf ciao world-- ora mentre, solo semanticamente, tipo di evoca l'idea di fare qualcosa di nuovo, e ancora, e ancora, e per quanto tempo? Beh, ricordo che true-- vero è solo su uno o. 

E vero è, ovviamente, sempre vero. Quindi è una specie di un insignificante dichiarazione solo per dire vero. Ma in effetti, questo è intenzionale, perché se è vero è proprio sempre vero, che mentre vero implica solo, se un po indirettamente, che le seguenti righe di codice tra questi parentesi graffe deve solo eseguire di nuovo, e di nuovo, e ancora, e in realtà mai smettere. 

Ma se volete che il vostro ciclo di fermarsi, come noi fatto l'ultima volta con qualcosa di simile questo, ripetere i seguenti 50 volte, in C siamo in grado di fare lo stesso con ciò che è chiamato per loop-- la parola chiave non essendo mentre, ma per. E poi abbiamo un po 'di nuova sintassi qui, con int i è uguale a 0, i meno di 50, i ++. E ci torneremo a questo. Ma questo è semplicemente il modo in cui sarebbe tradurre l'insieme di blocchi Scratch ad un insieme di linee di codice C. 

Nel frattempo, in considerazione variabili. E, infatti, abbiamo appena visto uno un attimo fa. E nel caso di Scratch, se ha voluto dichiarare una variabile denominata i per i essendo intero, solo un numero, e vogliamo impostarlo su un certo valore, useremmo questo arancione bloccare qui-- ho impostato a 0. 

E vedremo oggi e al di là, proprio come la settimana scorsa, i programmatori fanno quasi sempre iniziare a contare da zero, davvero per convenzione. Ma anche perché il richiamo da la nostra discussione di binario, il minor numero possibile rappresentare qualsiasi numero di bit è solo andare a essere 0 se stesso. E così faremo in genere inizia inizializzazione anche le nostre variabili a 0. 

E in C a fare lo stesso, stiamo andando a dire int per intero, ho solo per convenzione. Avrei potuto chiamare questa variabile tutto quello che voglio, proprio come in Scratch. E poi è uguale a 0 solo cessionari il valore 0 da destra e lo mette nella variabile, o contenitore lì, sulla sinistra. E il punto e virgola come vedremo see-- e abbiamo visto alcuni di questi already-- significa solo fine di pensiero. Procedere a fare qualcosa di diverso sulle linee che seguono. 

Ora, per quanto riguarda le espressioni booleane? Ricordiamo che in Scratch, queste erano espressioni che sono o vere o domande false--, in realtà, che sono o vere o false. Quindi, nel caso di Scratch, potremmo fare una semplice domanda come questa, Sono io meno di 50? Così ho, ancora una volta, è un numero intero. Forse stiamo usando in un programma Scratch per tenere traccia di un punteggio o qualcosa di simile. Quindi, questa sintassi qui a Scratch significa semplicemente, è che a meno di 50? Beh, per fortuna, qualcosa è semplice in C. E da tradurre, questo si sarebbe semplicemente dire che sono meno di 50, utilizzando la chiave familiare sulla tastiera. 

Nel frattempo, se si voleva dire qualcosa di più generale, come, beh, è ​​x meno y dove ogni di X e Y sono variabili se stessi? Siamo in grado di fare la stessa cosa in C, fino a quando abbiamo creato queste variabili già. E vedremo come farlo in breve tempo. Vorremmo semplicemente dire x meno y. 

Quindi, si sta iniziando a vedere alcune somiglianze. E quelle persone che hanno fatto Scratch erano certamente ispirato da alcune di queste idee di base. E vedrete questo tipo di sintassi in molti languages-- non solo graffio, non solo C, ma Python, e JavaScript, e altre lingue ancora. 

Prendiamo in considerazione un altro costrutto da C, il concetto di una condizione, fare qualcosa condizionale. Se qualcosa è vero, fare questo. Se qualcosa è vero, farlo. È una specie di programmazione equivalente di un bivio. Forse è una forchetta a due vie, a tre vie forcella, o più. E in Scratch, potremmo avere visto qualcosa di simile. 

Quindi questo è un grande. Ma prendere in considerazione la relativa semplicità della logica. Se x è minore di y, allora dire che x è meno di y, altrimenti se x è maggiore di y, poi dicono x è maggiore di y. E poi, logicamente, se si ripensa a Scratch o semplicemente il proprio intuito umano, bene, se x non è maggiore di y, e x non è minore di y, allora naturalmente x sta per essere uguale a y. Quindi in questo caso, per nesting quei blocchi Scratch, possiamo raggiungere tre modo bivio? 

Nel frattempo, se vogliamo farlo in C, probabilmente sembra un po 'simpler-- almeno Una volta acquisita familiarità con la sintassi. Se x è minore di y, printf x è minore di y. Altrimenti, se x è maggiore di y, printf x è maggiore di y. Else printf x è uguale a y-- e, ancora una volta, con quelli backslash finisce proprio per quelle nuove linee in modo che se si in realtà correva questo tipo di programma sarebbe solo spostare il cursore in ultima analisi, alla riga successiva della schermata. 

Ora, nel frattempo Scratch aveva altra funzioni più sofisticate, solo alcuni dei quali andremo a inizialmente passare al mondo di C. E uno di loro era chiamato una lista in Scratch. E questa era una speciale tipo di variabile che ha permesso di memorizzare più cose in indietro, alla parte posteriore, alla schiena, alla parte posteriore. 

In C, non ha liste, di per sé, ma qualcosa che sono più generalmente chiamato array, anche se ti tornare più tardi questo semestre a guardare qualcosa chiamato una lista, o realmente una lista collegata. Ma per ora, la più vicina equivalente in C per noi sta per essere qualcosa chiamato un array. E un array è semplicemente un speciale tipo di variabile che consente di memorizzare i dati indietro, alla parte posteriore, alla schiena, alla schiena. 

E, in effetti, in Scratch, se volessimo accedere il primo elemento di un array o un list-- e ho intenzione di chiamarlo, per convenzione, argv, argomento vettore, ma più su che tra non molto. Se voglio arrivare al primo elemento di argv, nel mondo di Scratch effettivamente fare tipicamente iniziare il conteggio da 1. 

E così potrei ottenere punto 1 di argv. Questo è solo il modo MIT implementato la nozione di liste. Ma in C, ho intenzione di più semplicemente solo dire, argv, che ancora una volta è il nome del mio list-- o per essere chiari, un array. E se voglio la prima Elementi, sto andando per usare le parentesi quadre, che si potrebbe non spesso usato sotto una tastiera. 

Ma 0 significa solo, mi ottenere il primo. Quindi, in occasione e come il tempo passa, stiamo andando per iniziare a vedere queste dicotomie tra il Gratta e C, per cui Scratch utilizza uno. Siamo in C 0 per questo. Ma vedrete rapidamente una volta capito le fondamenta di ogni lingua, che queste cose cominciano a farsi sempre più familiare attraverso la pratica e la pratica. 

Quindi cerchiamo di guardare in realtà ora ad un programma. Qui sarà il primo della nostra C codice sorgente di programmi completi. E il programma stiamo andando di offrire a titolo oneroso è quello che è equivalente a quel pezzo Scratch in precedenza. 

Così qui, abbiamo ciò che è probabilmente il più semplice programma in C si può scrivere che in realtà fa qualcosa. Ora, vedremo passato, per ora, è comprendere, io.h di serie, e questi l'angolo staffe, e int, e vuoto, e le parentesi graffe, e simili. 

E facciamo solo concentrarsi su ciò, almeno intuitivamente, potrebbe saltare fuori a voi già. In realtà, principale, non lo faccio necessariamente sapere di cosa si tratta, ma molto simile a Scratch avevano che quando bandiera verde cliccato pezzo di puzzle, così fa C come linguaggio di programmazione avere un pezzo principale di codice che viene eseguito per impostazione predefinita. E senza dubbio, è letteralmente sta per essere chiamato principale. 

Così principale è una funzione. Ed è una funzione speciale che esiste in C che quando si esegue un programma, è principale che viene gestito da predefinito. Nel mondo di Scratch, era solito quando bandiera verde cliccato che ha ottenuto eseguito per impostazione predefinita. 

Nel frattempo, abbiamo visto prima, printf o stampare in formato, che è sarà una funzione che viene con C, insieme a tutta una serie di altri, che la volontà da tempo e il tempo di nuovo, al fine di fare esattamente come suggerisce il nome, stampare qualcosa. Cosa vogliamo stampare? Bene, vedremo che da personaggi che racchiudono come these-- mondo ciao, backslash n tra virgolette, possiamo dire esattamente printf quello di stampare sullo schermo. 

Ma per fare che, purtroppo bisogno di prendere qualcosa che è già criptico per noi esseri umani, ma almeno è un po 'readable-- affilato includono, di serie io.h, int, principale, vuoto, printf, tutta la magica incantesimi che abbiamo appena visto sullo schermo. Ma in realtà abbiamo a andare più arcana ancora. In primo luogo abbiamo bisogno di tradurre il codice che scriviamo in codice macchina. E ricordare della settimana scorsa che le macchine, almeno quelli che conosciamo qui, alla fine della giornata solo comprendere zero e uno. 

E il mio Dio, se abbiamo dovuto scrivere questi zero e uno in realtà il programma, sarebbe molto, molto rapidamente togliere il divertimento di qualsiasi cosa. Ma si scopre, per la settimana scorsa, che questi schemi di zero e uno appena hanno un significato speciale. In alcuni contesti, potrebbero significare numeri. 

In alcuni contesti, che potrebbero significare lettere, o colori, o un qualsiasi numero di altre astrazioni lì sopra. Ma proprio come il computer ha una CPU, Central Processing Unit, o il cervello all'interno del computer. Di solito Intel dentro, perché è una delle più grandi aziende che rende le CPU per i computer. 

Beh, le CPU Intel e gli altri semplicemente hanno deciso in anticipo che alcuni modelli di zeri e quelli si intendono cose specifiche. Alcuni modelli di zero e uno significherà, stampare questa sullo schermo, o aggiungere questi due numeri, o sottrarre questi due numeri, o spostare questo pezzo di dati da la memoria del mio computer qui, o un qualsiasi numero di altri livelli molto bassi, ma alla fine utile, le operazioni. Ma, per fortuna, noi esseri umani non stanno andando ad avere bisogno di conoscere questo livello di dettaglio. Infatti, proprio come l'ultima volta, dove abbiamo Sottratto ancora, e ancora, e ancora, edificio da un livello molto basso primitive come zero e uno ai concetti di livello superiore come i numeri e lettere, e colori, e di più, in modo che possiamo come programmatori stare in piedi sulle spalle di altri che sono venuti prima di noi e usare il software che altro persone hanno scritto prima noi-- vale a dire i programmi chiamati compilatori. 

C è un linguaggio che di solito è compilato, che significa convertito da codice sorgente in codice macchina. In particolare, ciò che questo significa è che se hai la tua fonte codice che si scrive da soli, come abbiamo appena sarà in un momento sullo schermo, e volete convertirlo in ultima analisi, di lavorare code-- tali zeri e quelli che solo il vostro Mac o PC understands-- hai una prima alimentare che il codice sorgente come ingresso ad una speciale programma chiamato compilatore, la cui uscita si deve vedere è codice macchina. E, in effetti, l'ultima volta che abbiamo parlato merito, davvero, alla fine della giornata, problem solving. Hai ingressi. E hai uscite. E hai qualche tipo dell'algoritmo nel mezzo. 

Gli algoritmi possono essere sicuramente implementato nel software, come abbiamo visto con pseudocodice la scorsa settimana e come vedremo con codice vero e proprio questa settimana. E così un compilatore in realtà solo ha una serie di algoritmi all'interno di esso che sanno convertire le parole chiave speciali, come principale, e printf, e altri che abbiamo appena ha visto negli schemi di zeri e quelli che Intel Inside e altre CPU in realtà capisce. Quindi, come facciamo questo? Dove possiamo ottenere un compilatore? 

La maggior parte di noi qui hanno un Mac o un PC. E si sta eseguendo Mac OS, o Windows o Linux, o Solaris, o un qualsiasi numero di altri sistemi operativi. E, in effetti, si potrebbe uscire sul web e scaricare un compilatore per il vostro Mac o PC per il sistema operativo. Ma saremmo tutti su diverse pagine, per così dire. Avremmo un po ' diverse configurazioni. E le cose non avrebbero funzionato lo stesso. E, in effetti, in questi giorni molti di noi non utilizzare un software che gira solo su i nostri computer portatili. Invece, usiamo qualcosa come un browser ci permette di accesso basato sul Web applicazioni nel cloud. E più tardi questo semestre, faremo esattamente questo. Scriveremo applicazioni o software utilizzando code-- non C, ma altri linguaggi come Python e Javascript-- che funzionano in the cloud. 

E per farlo, noi stessi durante il semestre effettivamente utilizzare una base di cloud ambiente conosciuto come CS50 IDE. Questa è una programmazione web-based ambiente, o di sviluppo integrato ambiente, IDE, che è costruito in cima ad un certo software open source chiamato Cloud 9. E abbiamo fatto un po 'pedagogica semplificazioni ad esso in modo da nascondere determinate caratteristiche in le prime settimane che non abbiamo bisogno, dopo di che è possibile rivelarli e fare la maggior parte tutto quello che vuoi con l'ambiente. 

E ci permette, anche, per pre-installare determinati programmi. Cose come un cosiddetto CS50 biblioteca, che vedremo tra poco ci fornisce in C con un po ' funzionalità aggiuntive. Quindi, se si va a, in ultima analisi, CS50.io, ti verrà richiesto di accedere, e una volta che fate e creare un account gratuito, si sarà in grado di accedere ad un ambiente che sembra abbastanza come questo. 

Ora, questo è nella modalità predefinita. Tutto è bello e luminoso sullo schermo. Molti di noi hanno l'abitudine di lavorando su un pezzo che è CS50 piuttosto tardi nella notte. E così alcuni di voi potrebbero preferire di trasformarlo in modalità notte, per così dire. 

Ma, in ultima analisi, ciò che sei andando a vedere all'interno CS50 IDE è di tre distinti areas-- un'area sulla cui sinistra i file saranno nel nuvola, una zona in alto a destra dove il codice sta per essere modificabile. Sarete in grado di aprire le schede individuali per ogni programma che si scrive questo semestre all'interno di quella in alto a destra. E poi più arcanamente, e tuttavia potente, sta per essere questa cosa al fondo noto come una finestra di terminale. 

Si tratta di una vecchia scuola Command Line Interface, o CLI, che permette di eseguire comandi sulla computer-- in questo caso, il computer nel cloud-- di fare cose come compilare il codice dal codice sorgente in codice macchina, per eseguire i programmi, o per iniziare la web server, o per accedere al database, e qualsiasi numero di altre tecniche che inizieremo a usare in breve tempo. Ma per arrivarci, siamo andando ad avere in realtà di andare online e iniziare a giocare. E per fare questo, si deve prima iniziare ad armeggiare con principale, e scrivere la parte principale di un programma. E cerchiamo di usare quella funzione printf, che abbiamo utilizzato in precedenza, semplicemente per dire qualcosa. 

Così eccomi qui già dentro di CS50 IDE. Ho effettuato l'accesso in anticipo. E ho piena proiettato alla finestra. E così, in ultima analisi, si Anche in problemi derivanti seguirà una procedura simile che fornirà la documentazione in linea. Quindi non c'è bisogno di preoccuparsi assorbendo ogni piccolo passo tecnico che faccio qui oggi. 

Ma si otterrà una schermata come questa. Mi capita di essere in modalità notturna. E si può illuminare tutto fino disabilitando la modalità notte. E alla fine giorno, si sta andando a vedere questi tre principali areas-- il file del browser a sinistra, le schede di codificare fino in alto, e il terminale nella parte inferiore. 

Lasciami andare avanti e scrivere il mio primo programma. Ho intenzione di andare preventivamente su File, Salva e salvare il mio file come hello.c. Infatti, per convenzione, qualsiasi che il programma scrivere che è scritto in linguaggio C dovrebbe essere chiamato qualcosa dot C, per convenzione. Quindi ho intenzione di nominarlo hello.c, perché Voglio solo dire ciao al mondo. Ora ho intenzione di zoom fuori e fare clic su Salva. E tutto quello che ho qui ora è una scheda in cui posso iniziare a scrivere codice. 

Questo non sta andando per la compilazione. Questo non significa nulla. E quindi, anche se mi sono convertito questo a zero e uno, la CPU sta per avere nessun idea di quello che sta succedendo intorno. Ma se scrivo linee che corrispondono con conventions-- essere di C C, Di nuovo, questo Language, con una sintassi simile questo, printf ciao world-- e ho ottenuto agio con farlo nel tempo. Quindi non penso che ho fatto eventuali errori tipografici. 

Ma, invariabilmente, la prima volta che si esegue questa operazione, si farà. E quello che sto per fare molto potrebbe bene non funzionare per voi la prima volta. E questo è perfettamente OK, perché in questo momento si potrebbe anche vedere un sacco di novità, ma nel corso del tempo, una volta acquisita familiarità con questo ambiente, e questo linguaggio, e gli altri, si inizia a vedere cose che sono sia giusta o sbagliata. 

E questo è ciò che il compagni di insegnamento e corso assistenti ottenere così bravo a nel corso del tempo, è individuare errori o bug nel codice. Ma io sostengo che non ci sono errori in questo codice. Così ora voglio eseguire questo programma. 

Ora sul mio Mac o PC, sono in l'abitudine di doppi icone di clic quando voglio eseguire qualche programma. Ma non è il modello qui. In questo ambiente, che è CS50 IDE. Stiamo utilizzando un operativo sistema chiamato Linux. Linux ricorda di un altro sistema operativo, generalmente noto come Unix. E Linux è particolarmente noto per avere una Command Line Ambiente, CLI. Ora, stiamo usando una specifica sapore di Linux chiamata Ubuntu. E Ubuntu è semplicemente un determinata versione di Linux. 

Ma di questi Linux in questi giorni fanno in realtà sono dotati di interfacce grafiche. E quello ci capita di stia usando qui è web-based. Quindi questo potrebbe apparire anche una po 'diverso da qualcosa lei stesso potrebbe avere visto o eseguire in passato. 

Quindi ho intenzione di andare avanti ora e fare quanto segue. Ho salvato questo file come hello.c. Ho intenzione di andare avanti e Tipo clanghello.c Così Clang per il linguaggio C è un compilatore. E 'pre-installato in CS50 IDE. E si può assolutamente scaricare e installare questo sul proprio Mac o PC. 

Ma, ancora una volta, si potrebbe non avere tutti la pre-configurazione di fatto per voi. Quindi per ora, io sono solo andare a correre clanghello.c. E ora notare questa sintassi qui finirà rendo conto significa solo che io sono in un cartella o directory chiamata di lavoro. Questo simbolo del dollaro è solo convenzione di senso, digitare i comandi qui. 

E 'quello che si chiama un prompt, basta per convenzione è il simbolo del dollaro. E se vado avanti ora e fare clic su Invio, nulla sembra essere accaduto. Ma questo è in realtà una buona cosa. Il meno che accade sulla lo schermo, il più probabile il codice è di essere corretto, almeno sintatticamente. 

Quindi, se voglio correre questo il programma, cosa devo fare? Beh, si scopre che il nome di default per convenzione per i programmi quando non si specifica un un nome per il vostro programma è solo a.out. E questa sintassi troppo, ti acquisire familiarità con poco tempo. 

Dot taglio su significa semplicemente, hey, CS50 IDE, eseguire un programma chiamato a.out che è dentro la mia directory corrente. Questo punto significa che la directory corrente. E vedremo cosa altri tali sequenze di personaggi significa in breve tempo. 

Quindi qui si va, Enter, ciao mondo. E si noterà, che cosa è successo? Non solo la stampa ciao mondo. E 'anche spostato il cursore alla riga successiva. 

E perché è stato? Qual è stato il codice che abbiamo scritto prima che ha assicurato che il cursore sarebbe andare sulla riga successiva? La cosa divertente circa un computer è è solo andare di fare letteralmente quello che gli si dice di fare. 

Quindi, se gli si dice di printf ciao, virgola, spazio, mondo, vicino citazione, E 'letteralmente solo andando per stampare quei personaggi. Ma ho avuto questo carattere speciale alla fine, richiamo, backslash n. Ed è quello che garantisce che il personaggio è andato alla riga successiva della schermata. 

In realtà, mi permetta di andare a fare questo. Lasciami andare avanti e cancellare questo. Ora, si noti che la parte superiore del mio schermo non c'è un po 'di luce rossa Nella scheda che indica, Ehi, non hai salvato il file. Quindi ho intenzione di andare avanti con il controllo S o comando S, salvare il file. Ora goes-- andato per un verde moment--. E ora si torna a solo di essere l'icona di un vicino. 

Se ora corro di nuovo clanghello.c, Invio, barra di punti, a.out, Enter, vedrai che funzionava ancora. Ma è senza dubbio un po 'buggy. In questo momento, il mio lavoro prompt--, e poi che il simbolo del dollaro, e poi il mio prompt-- reale è tutto sulla stessa linea. Quindi, questo è certamente un bug di estetica, anche se non è proprio un errore logico. 

Quindi ho intenzione di disfare ciò che ho appena fatto. Ho intenzione di eseguire nuovamente a.out. Notate ho aggiunto il carattere indietro a capo. Ho salvato il file. 

Quindi ho intenzione di eseguire nuovamente a.out, e- dannazione, un insetto, un bug che significa errore. Così il bug è che anche se Ho aggiunto il backslash n lì, ri-salvato, ri-corse del programma, il comportamento era lo stesso. Perché sarebbe? 

Mi manca un passo, giusto? Questo passo fondamentale prima è che bisogna a-- quando si modifica il codice sorgente, si scopre anche gestito attraverso il compilatore ancora una volta in modo da ottenere un nuovo codice macchina. E il codice macchina, le zero e uno, stanno per essere quasi identica, ma non perfettamente così, perché abbiamo bisogno, naturalmente, che la nuova linea. 

Quindi, per risolvere questo problema, ho intenzione di bisogno rieseguire clanghello.c, entrare, dot tagliare, a.out. E ora, ciao mondo è tornato al punto in cui mi aspettavo che fosse. Quindi questo è tutto bello e buono. Ma a.out è un nome abbastanza stupido per un programma, anche se si trova, per ragioni storiche, la default-- significa uscite di montaggio. 

Ma mi permetta di andare avanti qui e farlo in modo diverso. Voglio che il mio programma ciao mondo in realtà essere chiamato ciao. Quindi, se si trattasse di una icona sul mio desktop, non sarebbe a.out. Si sarebbe chiamato ciao. 

Quindi, per fare questo, si scopre che Clang, come molti programmi, sostiene gli argomenti della riga di comando, o bandiere, o interruttori, che si limita a influenzare il suo comportamento. In particolare, Clang supporta un trattino o bandiera, che poi prende una seconda parola. In questo caso, io arbitrariamente, ma ragionevolmente, lo chiamano ciao. Ma potrei chiamarlo nulla Io voglio, tranne a.out, che sarebbe piuttosto oltre il punto. 

E poi basta specificare il nome del file che voglio per la compilazione. Così ora, anche se all'inizio del comando ho ancora Clang, alla fine del comando Ho ancora il nome del file, Ora ho questi riga di comando argomenti, questi flag che stanno dicendo, Oh, a proposito, uscita-o, un file chiamato ciao, non il a.out di default. 

Quindi, se ho colpito Inserisci ora, niente sembra essere accaduto. E, tuttavia, ora posso fare barra dot ciao. Quindi è lo stesso programma. Gli zero e uno sono identica alla fine della giornata. 

Ma sono in due diverso a.out files--, che è la prima versione e solo stupidamente di nome, e ora ciao, che è un gran altro nome interessante per un programma. Ma, onestamente, non sono mai andando a ricordare di nuovo, e ancora, e ancora. E, in realtà, mentre scriviamo programmi più complicati, i comandi sei andando ad avere per scrivere stanno per arrivare anche più complicata ancora. 

E così non preoccuparsi. Si scopre che gli esseri umani prima Ci siamo resi conto anche loro avuto questo stesso problema. Anche loro non godere dover tipo piuttosto lunghi, comandi arcani, per non parlare di ricordare. E così gli esseri umani prima di noi hanno fatto altri programmi che rendono più facile per compilare il software. 

E, in effetti, una tale programma si chiama fare. Quindi ho intenzione di andare avanti e fare questo. Io vado a disfare tutto quello che ho appena fatto nel modo seguente. Mi permetta di tipo LS. E si noterà tre things-- a.out, e una stella, ciao e una stella, e hello.c. Speriamo che questo dovrebbe essere un po intuitiva, nella misura in cui in precedenza non vi era nulla in questo spazio di lavoro. Non c'era niente che ho avuto creato fino a quando abbiamo iniziato classe. 

E ho creato hello.c. Poi ho compilato, e lo ha chiamato a.out. E poi ho compilato di nuovo un po ' diversamente e lo ha chiamato ciao. Così ho tre file in questa directory, in questa cartella denominata Area di lavoro. Ora, posso vedere che pure se io diminuire in realtà. 

Se io diminuire qui e guarda che la mano in alto a destra angolo, come promesso sinistra lato dello schermo è sempre intenzione di mostrare cosa c'è nel tuo account, che cosa è all'interno di CS50 IDE. E ci sono tre file lì. 

Quindi voglio sbarazzarsi di a.out e ciao. E come si potrebbe immaginare intuitivamente, è potrebbe sorta di controllo click o fare clic destro su questo. E questo piccolo menu si apre. È possibile scaricare il file, esegue essa, in anteprima, aggiornamento, rinominare, o cosa no. 

E ho potuto solo cancellare, e sarebbe andato via. Ma facciamo le cose con un comando Linea per ora, in modo da ottenere confortevole con questo, e fare quanto segue. Ho intenzione di andare avanti e rimuovere a.out digitando letteralmente rma.out. Si scopre, il comando per la rimozione o l'eliminazione di qualcosa, non rimuovere o cancellare. 

E 'più succintamente RM, solo per salvare alcune combinazioni di tasti, e premi invio. Ora stiamo andando a essere un po ' cripticamente rimuovere file regolare a.out. Io non so davvero che cosa un file di irregolare sarebbe ancora. Ma io voglio rimuoverlo. 

Quindi ho intenzione di digitare Y per sì. O potrei scrivere fuori, e premere Invio. E, ancora una volta, nulla sembra accadere. Ma questo è, in generale, una buona cosa. 

Se scriv LS questa volta, cosa devo vedere? Si spera, solo ciao e hello.c. Ora, come un a parte, ti notare questa stella, asterisco, che è alla fine dei miei programmi. E stanno anche mostrando in verde. Questo è solo il modo di CS50 IDE di voi cluing nella realtà che questo non è il codice sorgente. Questo è un eseguibile, un eseguibile programma che si può effettivamente eseguire facendo barra di punti, e quindi il suo nome. 

Ora, mi permetta di andare avanti e rimuovere questo, RM ciao, Enter, rimuovere regolare presentare ciao, sì. E ora, se digito LS, siamo tornati a hello.c. Cercate di non cancellare il tuo codice sorgente. Anche se ci sono caratteristiche integrato nel CS50 IDE dove si può passare attraverso la tua cronologia delle revisioni e riavvolgere in tempo se accidentalmente cancellare qualcosa, fare essere consapevoli come da queste richieste sì o no, di ciò che si vuole realmente fare. E se vado fino alla cima sinistra angolo mano qui, tutto ciò che rimane è hello.c. Quindi c'è grappoli d' altri comandi che si può eseguire nel mondo di Linux, uno dei quali è, ancora una volta, Make. E stiamo andando a fare il mio programma ora come segue. 

Invece di fare clang, invece di fare clang-o, Ho intenzione di semplicemente letteralmente tipo, fare ciao. E ora notato, io sono Non digitando fare hello.c. Sto scrivendo fanno ciao. 

E questo programma make che viene fornito con CS50 IDE, e altro ancora generalmente con Linux, è un programma che è andando a fare un programma chiamato Ciao. E sta andando ad assumere, per convenzione, che se questo programma può essere fatto, sta andando essere fatta da una fonte file di codice che termina con punto c, hello.c. 

Quindi, se ho colpito Entra subito, si noti che il comando che viene eseguito è in realtà ancora più a lungo prima di prima. E questo perché abbiamo preconfigurato CS50 IDE di avere alcune funzionalità aggiuntive integrate in quel non abbiamo bisogno di appena ancora, ma presto sarà. Ma la cosa fondamentale da realizzare è ora ho un programma Ciao. 

Se scrivo di nuovo LS, ho avere un programma ciao. E posso eseguirlo con dot taglio su a.out, no, perché il punto di questo esercizio è stato dot ciao barra. E ora ho il mio programma ciao mondo. Quindi andare avanti, ci siamo quasi sempre solo andare per compilare i nostri programmi utilizzando il comando Crea. E allora stiamo andando a correre per loro dot slash, e il nome del programma. Ma realizzare ciò che fanno è facendo per si, è che è in sé non un compilatore. E 'solo un programma di convenienza che sa innescare un compilatore per eseguire in modo che lei stesso può utilizzare. 

Quello che esistono altri comandi Linux, ed a sua volta il CS50 IDE? Presto vedremo che c'è un comando CD, Cambia directory. Ciò consente all'interno l'interfaccia a riga di comando ad andare avanti, e indietro, e di aprire cartelle diverse senza utilizzare il mouse. 

LS abbiamo visto, che sta per lista i file nella directory corrente. Fare Dir, è possibile probabilmente iniziare a dedurre ciò che questi significano now-- fare directory, se si desidera creare una cartella. RM per rimuovere, RM Dir per rimuovere directory-- e questi, ancora una volta, sono la linea di comando equivalenti di ciò che si potrebbe fare in CS50 IDE con il mouse. Ma troverai subito che a volte è solo molto più veloce da fare le cose con una tastiera, e infine molto più potente. 

Ma è difficile sostenere che tutto ciò che abbiamo fatto finora è tutto ciò che potente, quando tutti abbiamo detto è, ciao mondo. E, infatti, ho hardcoded il parole ciao mondo nel mio programma. Non vi è ancora alcuna dinamismo. Scratch è un ordine di grandezza più interessante la scorsa settimana. 

E così andiamo lì. Facciamo un passo verso che, modo di alcune di queste funzioni. Quindi non solo C sono dotati di printf, e mazzi di altre funzioni alcune delle quali vedremo nel tempo, non è così rendere il tutto così facile a destra fuori della porta a ottenere l'input dell'utente. 

In effetti, uno dei punti deboli di linguaggi come C, e anche Java e ancora altri, è che non fa rendere più facile per ottenere solo le cose come interi degli utenti, o stringhe, parole, e le frasi, lasciare che le cose da soli, come valori di punto, o numeri reali galleggiante con punti decimali, e davvero numeri lunghi, come vedremo tra poco. Quindi questo elenco di funzioni qui, questi sono come gli altri pezzi del puzzle Scratch che abbiamo pre-installato in CS50 IDE che useremo per alcune settimane come ruote di formazione di sorta, e alla fine li decollare, e guardare sotto la cappa, forse, come queste cose siano applicate. 

Ma per fare questo, andiamo in realtà scrivere un programma. Lasciami andare avanti ora. E ho intenzione di creare una nuova il file cliccando questo piccolo vantaggio, e facendo clic su Nuovo file. 

Io vado a salvare questo prossimo uno come, diciamo, string.c, perché voglio giocare con le stringhe. E stringa in C è solo una sequenza di caratteri. Così ora andiamo avanti e procedere come segue. 

Include di serie IO.h-- e si scopre IO standard, IO significa solo ingresso e uscita. Così si scopre che questa linea qui è ciò che Gli Stati Uniti sono vicini da utilizzare printf. Printf, ovviamente, produce output. Quindi, al fine di utilizzare printf, risulta out devi avere questa riga di codice nella parte superiore del file. 

E torneremo a quello che questo significa che in realtà non molto. Risulta che in qualsiasi programma C che scrivo, Ho avuto modo di iniziare con codice che assomiglia a questo. E si noterà CS50 IDE e altro sviluppo integrato ambienti come esso, stanno andando a cercare come meglio il possibile per finire il pensiero. In realtà, un momento fa, se mi annullare quello che ho appena fatto, mi ha colpito Invio. 

Ho poi ha colpito ricci aperta brace, premere Invio di nuovo. Ed è finito il mio pensiero. Mi ha dato una nuova linea, non meno frastagliata per belle ragioni stilistiche vedremo. E poi mi ha dato automaticamente che graffa per terminare il mio pensiero. Ora, non sempre indovinare che cosa si vuole fare. Ma in gran parte, lo fa risparmiare alcuni tasti. Quindi un momento fa, abbiamo fatto questo program-- ciao, mondo, e quindi compilato, e poi corse esso. Ma non c'è dinamismo qui. E se volessimo fare qualcosa di diverso? Beh, e se volevo davvero ottenere una stringa da parte dell'utente? Ho intenzione di usare un pezzo di puzzle chiamato esattamente che-- ottenere stringa. 

Risulta in C che, quando non si vuole di fornire un contributo ad un pezzo di puzzle, o più propriamente ad una funzione, letteralmente fare parentesi aperta, parentesi chiusa. Quindi è come se ci fosse nessuna scatola bianca per digitare in. Il blocco dire prima aveva una piccola scatola bianca. Non abbiamo quella scatola bianca ora. 

Ma quando chiamo stringa get, io vuole mettere il risultato in qualche luogo. Quindi, un paradigma molto comune in C è quello di chiamare una funzione, come stringa di arrivare qui, e quindi memorizzare il suo valore di ritorno. È il risultato della sua sforzo in qualcosa. 

E qual è il costruire in programmazione, sia in Scratch o adesso C, che abbiamo possono utilizzare per memorizzare in realtà qualcosa? Chiamato una variabile, giusto? E in Scratch, non lo facciamo davvero cura che cosa stava succedendo nelle variabili. 

Ma in questo caso, abbiamo effettivamente facciamo. Sto per dire stringa. E poi ho potuto chiamare questo tutto quello che voglio. Ho intenzione di chiamarlo nome, ottiene ottenere stringa. 

E ora anche se sei un po 'di nuovo a questo, Noto che mi manca qualche dettaglio. Sto dimenticando un punto e virgola. Ho bisogno di finire questo pensiero. Quindi ho intenzione di spostare il mio cursore, e ha colpito virgola lì. E quello che ho appena fatto? In questa linea di codice, numero 5 in questo momento, Sto chiamando stringa get senza ingressi. Quindi non c'è po 'di bianco box come il blocco Salva ha. 

Sto solo dicendo, hey, calcolatore, portami una stringa. Il segno di uguale non è davvero un segno di uguale, di per sé. E 'l'assegnazione operatore, il che significa, Hey, computer, spostare il valore da destra verso sinistra. E a sinistra, ho il seguente. 

Hey, computer, dammi un string-- una sequenza di caratteri. E chiamare quel Nome stringa. E non hanno nemmeno bisogno di chiamarla Nome. 

Potrei chiamarla, convenzionalmente, qualcosa di simile a S, molto simile a noi ho usato per chiamare la variabile i. Ma ora ho bisogno di fare qualcosa con esso. Sarebbe piuttosto stupido provare a compilare questo codice, in esecuzione questo programma, anche se Sto diventando una stringa, perché è ancora solo andare a dire ciao mondo. 

Ma cosa succede se voglio cambiare questo. Perché non fare questo? Percentuale s, comma s. E questo è un po 'criptico ancora. 

Quindi, mi permetta di fare le mie variabili più chiaro. Ne posso citare questo nome di variabile. E vediamo se non possiamo prendere in giro A parte quello che sta succedendo qui. 

Quindi, sulla linea cinque, sto diventando una stringa. E sto memorizzare la stringa, qualunque sia l'utente ha digitato a sua tastiera, in una variabile denominata Nome. E si scopre che printf non solo prendere un argomento in camera doppia citazioni, un ingresso tra virgolette. 

Si può prendere due, o tre, o più, tale che il secondo, o il terzo o il quarto, sono tutti i nomi di variabili, o valori specificamente, che si desidera collegare in, dinamicamente, che stringa tra virgolette. In altre parole, ciò che sarebbe sbagliato in questo? Se ho appena detto ciao nome, backslash n, salvato il mio file, compilato il mio codice, e corse questo, che cosa accadrebbe? 

E 'solo andando a dire, ciao nome, letteralmente N-A-M-E, che è una specie di stupido perché non è diverso da mondo. Quindi, qualsiasi cosa tra virgolette è ciò che letteralmente viene stampata. Quindi, se voglio avere un segnaposto lì, Io in realtà bisogno di usare una sintassi speciale. E si scopre se si legge la documentazione per la funzione printf, vi dirà che se si utilizza per cento s, è possibile sostituire un valore come segue. 

Dopo una virgola dopo che virgolette, è sufficiente scrivere il nome del variabile che si desidera di collegare in quel formato codice, o di formato, cento s per le stringhe. E ora se ho salvato il mio file, Torno giù a mio terminale. E scrivo Fai String, perché, ancora una volta, il nome di questa il file che ho scelto prima è string.c. 

Quindi ho intenzione di dire fare String, digitare. Oh mio Dio, guarda tutti gli errori che abbiamo fatto già. E questo è-- cosa, questo è davvero come una, sette programma a linea di sei? Quindi questo è dove molto può ottenere rapidamente schiacciante. 

Questa finestra di terminale ha ora appena rigurgitato un numero enorme di messaggi di errore. Di certo, non ho più l'errore Messaggi di quanto ho righe di codice. Quindi cosa sta succedendo? 

Ebbene, la strategia migliore di fare in qualsiasi momento non incontrare uno schiacciante elenco degli errori del genere, è scorrere indietro, cercare il comando appena eseguito, che nel mio caso è rendere stringa. Guarda a quello rendono fatto, e questo è tutto lungo comando Clang, un grosso problema lì. 

Ma il rosso è male. Verde sta cercando di essere gentile e disponibile. Ma è ancora male, in questo caso. Ma dove è male? 

String.c, la linea cinque, carattere cinque. Quindi questo è solo convenzione comune. Qualcosa del colon qualcosa significa numero di riga e il numero di carattere. Errore, l'uso di non dichiarato stringa di identificazione. Cercavi standard? 

Così, purtroppo, Clang sta cercando di essere utile. Ma è sbagliato, in questo caso. No, Clang, non intendevo IO standard. Volevo dire che sulla linea uno, sì. 

Ma la linea cinque è questa qui. E non lo fa Clang capire S-T-R-I-N-G. Si tratta di un identificatore non dichiarato, un parola semplicemente non ha mai visto prima. E questo perché C, il linguaggio stiamo scrivendo il codice in questo momento, non ha variabili chiamate stringhe. 

E non, per impostazione predefinita, il supporto una cosa chiamata una stringa. Questo è un pezzo di CS50 gergo, ma molto convenzionale. Ma posso risolvere questo problema come segue. 

Se posso aggiungere una riga di codice all'inizio del programma, includere CS50.h, che è un altro file da qualche parte dentro di CS50 IDE, da qualche parte sul disco rigido, per così dire, del sistema operativo Ubuntu che sto correndo, che è il file che è andando a insegnare il funzionamento Sistema di quello che una stringa è, semplicemente come io.h standard è il file nel sistema operativo che è andando ad insegnare ciò che è printf. 

Anzi, avremmo ottenuto un messaggio molto simile se IO aveva ammesso di serie Io.h e ha cercato di usare printf. Quindi ho intenzione di andare avanti e basta Prendi il controllo L per cancellare il mio schermo. Oppure si può digitare chiaro e sarà basta cancellare la finestra di terminale. Ma si può ancora scorrere indietro nel tempo. 

E ho intenzione di eseguire nuovamente fare String. Incrocio le dita questa volta, Invio. Oh mio Dio, ha funzionato. mi mostra un comando lungo criptico questo è ciò che rende generato tramite Clang, ma nessun messaggio di errore. Quindi realizzare, anche se si potrebbe ottenere completamente sopraffatto con la il numero di messaggi di errore, che potrebbe essere solo questo a cascata fastidioso effetto, dove Clang non capisce una cosa, il che significa che poi non capisce la parola successiva, o la linea successiva. E così appena soffoca sul vostro codice. Ma la correzione potrebbe essere semplice. E concentrarsi così sempre sulla prima linea di uscita. E se non lo fai capirlo, basta guardare per le parole chiave che potrebbe essere indizi, e il numero di riga, e il carattere, dove questo errore potrebbe essere. 

Ora lasciatemi andare avanti e digitare dot taglio su, stringhe, entrare. Hm, non sta dicendo ciao nulla. Perché? Ebbene, ricordo, in cui è in esecuzione? 

Probabilmente è bloccato al momento in un ciclo, se si vuole, in linea di sei, perché Ottenere String in base alla progettazione, scritto da personale CS50, è letteralmente significava solo per sedersi lì in attesa, e in attesa, e in attesa di una stringa. Tutto quello che intendiamo per stringa è input umano. Allora sai cosa? Lasciami andare avanti. E proprio per un capriccio, mi permetta digitare il mio nome, David, entrare. Ora ho un programma più dinamico. Ha detto, ciao David. 

Se vado avanti e correre di nuovo, mi permetta di provare dire il nome Zamila, entrare. E ora abbiamo un programma dinamico. Non ho codificato duro mondo. Non ho codificato duro nome, o David, o Zamila. 

Ora è molto più simile ai programmi sappiamo, dove se ci vuole di ingresso, produce uscita leggermente diverso. Ora, questa non è la migliore l'esperienza degli utenti, o UX. Corro il programma. 

Non so cosa dovrei da fare, a meno che io in realtà guardo o ricordare il codice sorgente. Quindi cerchiamo di rendere l'utente sperimentare un po 'meglio con la più semplice delle cose. Lasciami andare di nuovo in questo il programma, e dire semplicemente printf. 

E mi permetta di andare avanti e dire il nome, del colon, e uno spazio, e poi una virgola. E solo per i calci, senza gioco n. E questo è intenzionale, perché io non voglio la richiesta di passare alla riga successiva. 

Voglio, invece, fare questo, fare stringa ricompilare il mio codice in nuova macchina Codice dot taglio su stringa. Ah, questo è molto più bella. Ora io in realtà so che cosa il computer vuole che io faccia, dargli un nome. 

Quindi ho intenzione di andare avanti e digitare a Rob, entrare, e ciao, Rob. Così, realizzare, questo è ancora, alla fine del giorno, solo un programma di nove linea. Ma abbiamo preso questi piccoli passi. 

Abbiamo scritto una riga con cui si erano familiare, printf, ciao mondo. Poi abbiamo annullato un po 'di quello. E abbiamo effettivamente usato stringa get. E abbiamo gettato quel valore in una variabile. E poi siamo andati avanti e migliorato ulteriormente con una terza linea. E questo processo iterativo di la scrittura di software è veramente fondamentale. In CS50, e nella vita in generale, non si dovrebbe in genere sedersi, avere un programma in mente, e provare a scrivere il tutto maledettamente tutto in una volta. 

Sarà, inevitabilmente, provocare modo più errori di quanto noi stessi visto qui. Anche io, fino ad oggi, in costante fare altri errori stupidi, sono errori in realtà più difficile che sono più difficili da capire. Ma si farà più errori più righe di codice si scrive tutto in una volta. E così questa pratica di, scrivere un po 'di codice che sei a tuo agio con, compila esso, eseguirlo, testarlo, più in generale, passa poi on-- così come abbiamo mantenuto stratificazione e stratificazione della scorsa settimana, la costruzione di qualcosa di molto semplice da qualcosa di più complesso, fare lo stesso qui. Non sedersi, e cercare di scrivere un intero problema. In realtà prendere questi piccoli passi. 

Ora, le stringhe non sono tutti che utile a se stessi. Avevamo in realtà, idealmente, come ad hanno qualcosa di diverso nel nostro toolkit. Quindi cerchiamo di realtà fanno esattamente questo. 

Lasciami andare avanti ora e montare un programma leggermente diverso. E chiameremo questo int.c, per intero. Io vado a, allo stesso modo, includere CS550.h. Ho intenzione di includere IO standard. E che sta per essere abbastanza comune in questi primi giorni della classe. 

E ho intenzione di pronto me stesso con una funzione principale. E ora invece di ottenere una stringa, andiamo avanti e ottenere un int. Chiamiamolo i, e lo chiamano ottenere int, chiudere parens, punto e virgola. Ed ora facciamo qualcosa con esso, printf. 

Diciamo che qualcosa di simile ciao, backslash n, comma i. Così sto praticamente mimando quello che ho fatto solo un momento fa. Ho un segnaposto qui. Ho virgola i qui, perché voglio per collegare io per quel segnaposto. 

Quindi cerchiamo di andare avanti e provare compilazione di questo programma. Il file si chiama int.c. Quindi ho intenzione di dire, fare int, entrare. Oh mio Dio, ma niente di grave, giusto? C'è un errore. 

C'è un errore sintattico qui in modo che il programma non può essere compilato all'interno int.c, linea sette, carattere 27, formato di errore specifica il tipo char Star, qualunque essa sia. Ma il tipo di argomento è int. 

Quindi anche qui, non stiamo andando a-- anche se oggi è un sacco di materiale, stiamo andando a sopraffare con assolutamente ogni caratteristica di C, e programmazione più in generale, in appena queste prime settimane. Quindi c'è spesso sarà gergo con cui non hai familiarità. E, infatti, char stella è qualcosa stiamo per tornare a in una settimana o tempo di due. 

Ma per ora, vediamo se possiamo analizzare le parole che sono familiari. così disposizioni-- abbiamo sentito formato identificatore, codice del formato prima. Questo è familiare. Type-- ma l'argomento è di tipo int. Aspetta un minuto, i è un int. 

Forse per cento s in realtà ha un significato definito. E, in effetti, lo fa. Un numero intero, se si desidera printf di sostituirlo, in realtà si deve utilizzare un diverso identificatore di formato. E non si sa questo a meno che qualcuno ti ha detto, o si era fatto prima. Ma per cento i è ciò che può essere comunemente usato in printf per collegare un numero intero. È inoltre possibile utilizzare per cento d per un intero decimale. Ma i è piacevole e semplice qui. Quindi andremo con quello. 

Ora lasciami andare avanti e replica make int, Invio. Questo è un bene, senza errori. Dot taglio su OK int--, brutta esperienza utente, perché non mi sono detto Cosa fare. Ma va bene. Sto prendendo piede rapidamente. 

E ora lasciami andare avanti e digitare David, OK, Zamila, Rob. OK, quindi questa è una buona cosa. Questa volta, sto usando una funzione, un pezzo di puzzle, chiamato get int. E si scopre fuori-- e ti vedere questo più avanti nella term-- il personale CS50 ha implementato ottenere corda in modo tale che lo farà solo fisicamente ottenere una stringa per voi. 

Esso ha implementato get int in modo tale che solo sarà ottenere un numero intero per voi. E se si, l'umano, non cooperare, è letteralmente solo andando a dire riprovare, riprovare, riprovare, letteralmente seduto lì loop, fino a quando costringesse con qualche numero magico, come 50, e ciao 50. 

Oppure, se corriamo di nuovo e digitare 42, ciao 42. E così la funzione get int all'interno di quel pezzo di puzzle è abbastanza logica, basta il pensiero, per capire, ciò che è una parola? E che è un numero? Solo accettando, in definitiva, i numeri. 

Così si scopre che questo non è poi così espressiva. finora. Così, yay, ultima volta che abbiamo è andato abbastanza rapidamente in giochi di attuazione, e l'animazione, e opere artistiche a zero. E qui, ci viene contenuti con il mondo ciao, ciao e 50. 

Non è tutto ciò che stimolante. E, in effetti, queste prime esempi ci vorrà del tempo a far decollare l'eccitazione. Ma noi abbiamo molto di più controllare ora, in effetti. E stiamo per molto avviare rapidamente stratificazione in cima a questi primitive di base. 

Ma in primo luogo, cerchiamo di capire quali sono i limiti. Infatti, una delle cose Scratch non è così facile facciamo è davvero guardare sotto la cappa, e capire che cosa un computer è, che cosa può fare, e quali sono i suoi limiti. E, infatti, che la mancanza di comprensione, potenzialmente, a lungo termine può portare alla nostra scrittura mistakes-- insetti, la scrittura di software insicuro che viene violato in qualche modo. 

Quindi cerchiamo di prendere alcuni passi verso la comprensione di questo un po 'meglio modo, per esempio, il seguente esempio. Ho intenzione di andare avanti e mettere in atto reale veloce un programma chiamato Adder. Come, aggiungiamo alcuni numeri insieme. E ho intenzione di codificare alcuni angoli qui, e basta copiare e incollare dove ero prima, appena in modo che possiamo andare avanti prima. Così ora ho gli inizi di base di un programma chiamato Adder. 

E andiamo avanti e fare questo. Ho intenzione di andare avanti e per esempio, IntX ottiene ottenere int. E sai una cosa? Facciamo una migliore esperienza utente. 

Quindi diciamo solo che x è, e in modo efficace richiedere all'utente di darci x. E poi mi permetta di andare avanti e dire, printf Che ne dite di y è, questa volta in attesa due valori da parte dell'utente. E poi cerchiamo di andare avanti e per esempio, printf, la somma di x ed y è. E ora non voglio fare cento s. Voglio fare i cento, backslash n, e quindi collegare valore della somma. 

Così come posso fare per fare questo? Sai cosa? Io so come usare le variabili. Vorrei solo dichiarare una nuova, int z. 

E ho intenzione di prendere una supposizione qui. Se ci sono segni di uguale in questo lingua, forse posso solo fare x più y, fino a quando finisco il mio pensato con un punto e virgola? Ora posso tornare quaggiù, collegare z, finire questo pensiero con un punto e virgola. E vediamo ora, se questi sequenze di x lines-- è ottenere int. Y è ottenere int. 

Aggiungere xey, memorizzare il valore in z-- così, ancora una volta, ricordare il segno di uguale Non è uguale. E 'assegnazione da destra a sinistra. E cerchiamo di stampare fuori che la somma di X e Y non è letteralmente z, ma cosa c'è dentro di z. Quindi cerchiamo di fare Adder - bello, nessun errore questa volta. Dot taglio su Adder, entrare, x sta per essere 1. 

Y sta per essere 2. E la somma di x ed y è 3. Ecco, questo è tutto bello e buono. 

Quindi, si potrebbe immaginare che la matematica dovrebbe funzionare in un programma come questo. Ma sai una cosa? È questa variabile, la linea 12, anche necessario? Non è necessario per ottenere l'abitudine di appena memorizzare le cose in variabili solo perché si può. E, infatti, è generalmente Considered Design Bad se si sta creando una variabile, chiamata z in questo caso, memorizzare qualcosa in esso, e poi subito usarlo, ma mai più. Perché dare qualcosa di un nome come z se siete letteralmente intenzione di utilizzare tale cosa sola volta, e così prossimale al punto in cui si è creato in primo luogo, così vicini in termini di linee di codice? Allora sai cosa? Si scopre che C è abbastanza flessibile. Se Io in realtà voglio plug-in valori qui, Non ho bisogno di dichiarare una nuova variabile. Ho potuto solo plug-in di x più y, perché capisce C aritmetica, e gli operatori matematici. 

Così posso semplicemente dire, fare questo per la matematica, x + y, qualunque questi valori sono, collegare il risultante intero in quella stringa. Quindi questo potrebbe essere, anche se solo una linea più breve, una migliore progettazione, un programma migliore, perché c'è meno codice, quindi, meno per me capire. Ed è anche appena più pulito, nella misura in cui non siamo l'introduzione di nuove parole, nuovi simboli, come z, anche se in realtà non servire molto di uno scopo. 

Purtroppo, la matematica non è tutto ciò che a volte affidabili. Andiamo avanti e fare questo. Ho intenzione di andare avanti ora e fare quanto segue. 

Facciamo printf, cento i, oltre cento I sono cento i, backslash n. E ho intenzione di fare questo-- xyx più y. Così Sto solo andando a riscrivere questo in modo leggermente diverso qui. Vorrei solo fare un controllo di integrità rapido. Anche in questo caso, cerchiamo di non andare avanti di noi stessi. Fai la vipera, dot barra vipera. x è 1, y è 2, 1 + 2 fa 3. Quindi, questo è un bene. Ma cerchiamo di complicare questo ora un po ', e creare un nuovo file. 

Ho intenzione di chiamare questa, dire, int, plurali per gli interi. Permettetemi di iniziare dove ero un attimo fa. Ma ora facciamo un paio di altre linee. Mi permetta di andare avanti e fare quanto segue, printf, cento i, meno per cento i, è cento i, comma x, comma YX meno y. Così sto facendo un po ' matematica diverso lì. Facciamo un altro. Così per cento i tempi per cento i è cento i, backslash n. Facciamo plug-in x, y, e tempi di X Y. Useremo l'asterisco su il computer per i tempi. 

Non si utilizza x. x è un nome di variabile qui. Si utilizza la stella per la moltiplicazione. Facciamo un altro. Printf per cento I, diviso per cento i, è cento i, n backslash. xy diviso per y-- in modo da utilizzare la barra in C a fare la divisione. E facciamo un altro. Resto di cento i, diviso per cento i, è cento i. xy-- e ora resto è ciò che rimane. Quando si tenta un dividendo denominatore in un numeratore quanto è rimasto che non si poteva dividere fuori? 

Quindi non c'è davvero, necessariamente, un simbolo abbiamo usato in grado di scuola per questo. Ma c'è in C. Si può dire x modulo y, dove questo segno per cento in questo context-- confusamente quando sei dentro delle virgolette, all'interno di printf, per cento viene utilizzato come identificatore di formato. 

Quando si utilizza per cento al di fuori di che in un'espressione matematica, è l'operatore modulo per modulare arithmetic-- per i nostri scopi qui, significa semplicemente, che cosa è la restante x diviso per y? Quindi x diviso per y è x barra y. Nei il resto di x diviso per y? E 'x y mod, come programmatore direbbe. 

Quindi, se ho commesso errori qui, mi permetta andare avanti e fare interi, plurali, bello, e int oblique punti. E andiamo avanti e fare, diciamo, 1, 10. Va bene, 1 più 10 è 11, di controllo. 1 meno 10 è negativo 9, controllare. 

1 volte 10 è 10, di controllo. 1 diviso 10 è-- OK, ci salteremo che uno. Resto di 1 diviso 10 è 1. È corretto. Ma c'è un bug in qui. 

Quindi quello che ho messo la mia consegnare, non è corretto. Voglio dire, è vicino a 0. 1 diviso per 10, si sa, se siamo taglio alcuni angoli, certo, è pari a zero. Ma in realtà dovrebbe essere 1/10, 0.1 o 0.10, 0.1000, o così via. 

Non dovrebbe essere veramente zero. Beh, si scopre che il computer è fare letteralmente quello che abbiamo detto di fare. Stiamo facendo la matematica come x diviso per y. Ed entrambi X e Y, per le linee di codice in precedenza, sono interi. 

Inoltre, sulla linea 15, siamo dicendo printf, ehi, printf plug-in un numero intero, plug-in un numero intero, plug-in integer-- specificamente x, quindi y, e poi x diviso per y. xey sono interi. Siamo a posto lì. 

Ma ciò che è x diviso per x? x diviso per y dovrebbe essere, matematicamente, 1/10, o 0.1, che è un numero reale, un numero reale avere, potenzialmente, un punto decimale. Non è un numero intero. 

Ma ciò che è la più vicina integer a 1/10, o 0.1? Sì, che tipo di è pari a zero. 0.1 è così tanto. E 1 è così tanto. Quindi, è più vicino al 1/10 0 piuttosto che uno. 

E così quello che C sta facendo per noi-- tipo di perché abbiamo detto che a-- è troncando quella intero. E 'prendendo il valore, che è ancora doveva essere qualcosa di simile a 0.1000, 0 e così via. Ed è troncare tutto dopo il punto decimale in modo che tutto questo roba, perché non è così inserire nella nozione di un numero intero, che è solo un numero come negativo 1, 0, 1, su e giù, si butta via tutto dopo il punto decimale perché Non può andare bene un punto decimale in un numero intero per definizione. 

Quindi la risposta qui è zero. Quindi, come possiamo risolvere questo problema? Abbiamo bisogno di un'altra soluzione tutti insieme. E possiamo farlo, come segue. 

Lasciami andare avanti e creare un nuovo il file, questo chiamato floats.c. E salvarlo qui in stessa directory, float.c. E mi permetta di andare avanti e copiare alcuni di tale codice precedente. 

Ma invece di ottenere un int, facciamolo. Datemi un valore in virgola mobile chiamato x. qualora un punto floating il valore è solo letteralmente qualcosa con una virgola mobile. Può spostarsi a sinistra, a destra. Si tratta di un numero reale. 

E mi permetta di non chiamo ottenere int, ma ottenere galleggiante, che era anche tra i menu di opzioni nella libreria C250. Cambiamo y ad un galleggiante. Così questo diventa ottenere galleggiante. 

E ora, non vogliamo collegare int. Si scopre che dobbiamo usare per cento f per galleggiare, cento f per float, e ora salvarlo. E ora, incrociamo le dita, fanno galleggianti, bello, carri oblique punti. x sta per essere uno 1. y Sta per essere di nuovo 10. 

E, bello, OK mia aggiunta è corretta. Speravo in più, ma ho dimenticato di scriverlo. Quindi andiamo a correggere questo errore logico. 

Andiamo avanti e afferrare quanto segue. Dobbiamo solo fare un po 'di copia e incolla. E io vado a dire meno. 

E ho intenzione di dire volte. E io vado a dire divisi. E io non ho intenzione di fare modulo, che non è così germano qui, divisi da f, e tempi plus-- OK, facciamolo di nuovo. 

Rendere carri, carri oblique punti, e 1, 10, e- bello, no, OK. Quindi sono un idiota. Quindi questo è molto comune in informatica di fare errori stupidi come questo. 

Ai fini pedagogici, quello che volevo veramente fare è stato cambiare la scienza qui al più, a meno, a volte, e di dividere, come si spera notato nel corso di questo esercizio. Così ora cerchiamo di ri-compilare questo il programma, fare carri oblique punti. 

E per la terza volta, facciamo vedere se soddisfa le mie aspettative. 1, 10, entrare, sì, OK, 1.000, diviso per 10.000, è 0.100000. E si scopre che possiamo controllare il numero di numeri sono dopo quei punti decimali. Abbiamo effettivamente sarà. Torneremo a questo. 

Ma ora, infatti, la matematica è corretta. Così, ancora una volta, qual è l'asporto qui? Risulta che in C, ci sono Non appena strings-- e, di fatto, Non ci sono davvero, perché noi aggiungere quelli con la libreria CS50. Ma non ci sono solo int. 

Ci sono anche galleggia. E si scopre una serie di altri dati tipi di troppo, che useremo in poco tempo. Si scopre che se si vuole un unico carattere, non è una stringa di caratteri, è possibile utilizzare solo un carattere. 

Scopre che se si desidera un bool, un valore booleano, vero o solo falso, grazie alla biblioteca CS50, abbiamo aggiunto alla C il tipo di dati bool pure. Ma è presente anche in molte altre lingue. E si scopre che a volte si bisogno di numeri più grandi poi vengono di default con interi e galleggianti. 

E, infatti, un doppio è un numero che utilizza non a 32 bit, ma 64 bit. E un lungo tempo è un numero che usa non 32, ma 64 bit bit, rispettivamente, per virgola mobile valori e numeri interi, rispettivamente. Quindi cerchiamo di realtà ora vedere questo in azione. 

Ho intenzione di andare avanti qui e montare un altro programma. Qui, ho intenzione di andare avanti e non comprendono CS50.h. E lasciami andare, includere standard di io.h. 

E si noterà qualcosa funky sta accadendo qui. Non è la codifica a colori le cose in allo stesso modo come prima. E si scopre, è perché io Non hanno dato la cosa un nome di file. 

Ho intenzione di chiamare questo uno sizeof.c, e ha colpito Salva. E cosa succede al mio molto codice bianco contro quello sfondo nero. Ora, almeno c'è un po 'di viola in là. Ed è sintassi evidenziata. 

Questo perché, molto semplicemente, non ho ha detto l'IDE tipo di file è dandogli un nome, e in particolare l'estensione del file. Ora, andiamo avanti e fare questo. Ho intenzione di andare avanti e molto semplicemente stampare il bool following-- è cento LU. 

Torneremo a che in un attimo. E poi ho intenzione di formato di stampa di bool. E ora, solo per risparmiare io stesso un po 'di tempo, sono andando a fare un intero mazzo di questi immediatamente. E, in particolare, ho intenzione di cambiare questo ad un char e char. Questo, ho intenzione di cambiare per una matrimoniale e una doppia. 

Questo, ho intenzione di cambiare ad un galleggiante e un galleggiante. Questo, ho intenzione di cambiare per un int e un int. E questo, ho intenzione cambiare per un lungo tempo. Ed è ancora in corso un lungo tempo, molto lungo. 

E poi, infine, ho dato io stesso uno di troppo, stringa. Si scopre che in C, non c'è l'operatore speciale chiamato dimensioni che è letteralmente andando a, quando viene eseguito, dirci che il formato di ciascuna di queste variabili. E questo è un modo, ora, ci si può collegare indietro alla discussione della scorsa settimana di dati e di rappresentanza. 

Lasciami andare avanti e compilare dimensione della dimensione barra di punti di. E vediamo. Si scopre che in C, in particolare sulla CS50 IDE, in particolare sulla sistema operativo Ubuntu, che è operativo a 64 bit sistema in questo caso, un bool sta per utilizzare un byte di spazio. Ecco come dimensioni è misurato, non in bit, ma in byte. E ricordare che un byte è otto bit. Quindi un bool, anche se si tecnicamente solo bisogno di un 0 o 1, è un po 'uno spreco come abbiamo implementato esso. In realtà intenzione di utilizzare un intero byte-- così tutti gli zeri, sono forse tutti quelli, o qualcosa del genere, o solo uno tra 1 otto bit. 

Un char, nel frattempo, utilizzato per un personaggio come un carattere ASCII per la scorsa settimana, sta per essere un personaggio. E che sincronizza con il nostro concetto di essendo non più di 256 bits-- piuttosto, sincronizza con esso non essendo più di 8 bit, che ci dà fino a 256 valori. Un doppio sta per essere di 8 byte o 64 bit. 

Un galleggiante è 4. Un int è 4. Una lunga, lunga è 8. E una stringa è 8. Ma non ti preoccupare di questo. Stiamo andando a buccia indietro quel livello. Si scopre, le stringhe possono essere più lungo di 8 byte. 

E, in effetti, abbiamo scritto stringhe già, ciao mondo, più di 8 byte. Ma torneremo a che in un attimo. Ma il take via qui è il seguente. 

Ogni computer ha soltanto una limitata quantità di memoria e di spazio. È possibile memorizzare solo così tante file sul vostro Mac o PC. È possibile memorizzare solo tanti programmi in RAM in esecuzione in una sola volta, necessariamente, anche con memoria virtuale, perché si dispone di una quantità limitata di RAM. 

E proprio per un'Immagine-- se non hai mai aperto un computer portatile o ordinato memoria aggiuntiva per un computer, potrebbe non sapere che all'interno del computer è qualcosa che sembra un po 'come questo. Quindi questa è solo una società comune denominata Fondamentale che rende RAM per i computer. E la RAM è dove i programmi vivere mentre sono in esecuzione. 

Così su ogni Mac o PC, quando si fa doppio fare clic su un programma e si apre, e si apre qualche documento Word o qualcosa di simile, memorizza temporaneamente nella RAM, perché la RAM è più veloce di disco rigido, o il disco a stato solido. Quindi è proprio dove i programmi vanno a vivere quando sono in esecuzione, o quando vengono utilizzati i file. 

In modo da avere le cose che sembrano come questo all'interno del vostro computer portatile, o cose un po 'più grandi all'interno del desktop. Ma la chiave è che si hanno solo una numero finito di queste cose. E c'è solo una quantità finita di hardware seduto su questa scrivania a destra Qui. 

Quindi, sicuramente, non possiamo immagazzinare numeri infinitamente lunghi. E, tuttavia, se si pensa di nuovo a scuola elementare, quante cifre può si ha a destra di un punto decimale? Del resto, quante cifre può si deve alla sinistra di un punto decimale? In realtà, infiniti. 

Ora, noi esseri umani solo potrebbe Sai come pronunciare milioni, e miliardi, miliardi di dollari, e quadrilioni, e quintilioni. E sto spingendo i limiti della mia understanding-- o my-- ho capito i numeri, ma il mio Pronuncia di numeri. Ma possono ottenere infinitamente grande con un numero infinito di cifre a sinistra oa destra del punto decimale. 

Ma i computer hanno solo un quantità limitata di memoria, un numero finito di transistor, un numero finito di lampadine all'interno. Che cosa succede quando si esaurisce lo spazio? In altre parole, se ripensare a settimana scorsa quando abbiamo parlato di numeri stessi di essere rappresentato in binario, supponiamo che abbiamo questo valore a 8 bit qui. 

E abbiamo sette 1 e uno 0. E supponiamo che vogliamo aggiungere 1 a questo valore. Questo è davvero un grande numero di adesso. 

Si tratta di 254, se non ricordo la matematica dalla settimana scorsa destra. Ma cosa succede se cambio che più a destra 0 a 1? Il numero intero, di Naturalmente, diventa otto 1 di. Quindi siamo ancora buono. 

E che rappresenta probabilmente 255, anche se a seconda del contesto potrebbe effettivamente rappresentare un numero negativo. Ma più su che un'altra volta. Questo si sente come se fosse su il più in alto che posso contare. 

Ora, è solo 8 bit. E il mio Mac, sicuramente, ha senso più di 8 bit di memoria. Ma ha finito. Così lo stesso argomento vale, anche se avere più di questi sullo schermo. 

Ma cosa succede se si è memorizzare questo numero, 255, e si desidera contare 1 po 'più alto? Vuoi andare 255-256. Il problema, naturalmente, è che se si iniziare a contare da zero come la settimana scorsa, Non si può contare più in alto come 256, per non parlare di 257, per non parlare di 258, m perché ciò che accade quando si aggiunge un 1? Se fate la vecchia scuola elementare approccio, si mette un 1 qui, e poi 1 più 1 è 2, ma questo è davvero uno zero, si portano il 1, portare il 1, trasportare il 1. Tutte queste cose, questi 1 di, vanno a zero. E si finisce, sì, come qualcuno sottolineato, un 1 sul lato sinistro. Ma tutto è possibile effettivamente vedere e montare in memoria è appena otto 0 di, vale a dire ad un certo punto, se si, un computer, provato a contare abbastanza in alto, sei andando ad avvolgere intorno, sembrerebbe, a zero, o forse addirittura negativo numeri, che sono ancora minore di zero. 

E possiamo tipo di vedere questo. Lasciami andare avanti e scrivere un vero e proprio programma veloce qui. Lasciami andare avanti e scrivere un programma chiamato overflow. Includi CS50.h, comprendono standard di IO.h-- oh, Mi mancava la mia evidenziazione della sintassi. Quindi cerchiamo di salvare questo come overflow.c. 

E ora int void-- principale e in poco tempo, ci tornare a spiegare perché continuiamo a scrivere int void main. Ma per ora, facciamo solo fare esso, dando per scontato. Diamo me un int, e inizializzare a 0. 

Facciamo quindi fare per int ottengo zero-- in realtà, cerchiamo di fare un ciclo infinito e vedere cosa succede. Mentre vero, allora cerchiamo di stampare fuori n è cento i, backslash n, plug-in n. Ma, ora, facciamo n ottiene più 1 n. 

In altre parole, su ciascun iterazione di questo ciclo infinito, diamo il valore di n, e aggiungere 1 ad esso, e poi memorizzare il risultato nel n a sinistra. E, infatti, abbiamo visto sintassi un po 'come questo, per breve tempo. Un trucco fresco è invece di scrivere tutto questo fuori, si può effettivamente dire un n più uguale a 1. 

Oppure, se si vuole veramente essere di fantasia, si può dire n plus plus e virgola. Ma questi ultimi due sono appena quello che noi chiameremmo zucchero sintattico per la prima cosa. 

La prima cosa è più esplicito, tutto bene, del tutto corretta. Ma questo è più comune, dirò. Quindi faremo questo solo per un momento. 

Vediamo ora fare troppo pieno, che suona piuttosto inquietante, troppo pieno barra dot. Vediamo, n sta facendo abbastanza grande. Ma pensiamo, quanto grande può ottenere n? 

n è un int. Abbiamo visto un momento fa, con le dimensioni di esempio che un int è di quattro byte. Sappiamo dalla settimana scorsa, quattro byte è 32 bit, per 8 volte 4, che di 32. Che sta per essere 4 miliardi. 

E siamo fino a 800.000. Si tratta di andare a prendere per sempre a contare su quanto mi sarà possibile. Quindi ho intenzione di andare avanti, come si potrebbe in breve tempo, e ha colpito di controllo C-- francamente, di controllo C, un sacco, dove il controllo C in generale mezzi annullare. Sfortunatamente, poiché questo è in esecuzione nel cloud, a volte la nube è sputando tanta roba, così tanto l'uscita, sta andando a prendere un po 'di tempo per il mio ingresso per arrivare al cloud. Così, anche se mi ha colpito Controllo C pochi secondi fa, questo è sicuramente il lato effetto di un ciclo infinito. 

E così in questi casi, siamo intenzione di lasciare che si tratti. E stiamo per aggiungere un altro finestra di terminale qui con il plus, che ovviamente non lo fa così, dal momento che è ancora pensando. E andiamo avanti ed essere un po 'più ragionevole. 

Ho intenzione di andare avanti e fare questo solo un numero finito di volte. Usiamo un ciclo for, che ho accennato in precedenza. Facciamolo. Dammi un'altra variabile int mi viene 0. i è inferiore, diciamo, 64 i ++. E ora lasciami andare avanti e di stampa out n è cento i, comma n. E poi n-- questo è ancora andando a prendere per sempre. Facciamolo. 

n ottiene n volte 2. O potremmo essere di fantasia e fanno volte è uguale a 2. Ma diciamo solo che n è uguale a se stessa, volte 2. In altre parole, in questo nuova versione del programma, Non voglio aspettare per sempre da come 800.000 a 4 miliardi. Diciamo solo farla finita. 

Facciamo in realtà matrimoniale n ogni volta. Il che, ricordo, è il raddoppio opposta di avere, ovviamente. E che la settimana scorsa abbiamo qualcosa di nuovo, e di nuovo, e di nuovo, super veloce, raddoppio sicuramente sarà farci dal 1 al più grande possibile valore che siamo in grado di contare fino a int. 

Quindi cerchiamo di fare esattamente questo. E torneremo a questa prima lunga. Ma questo, ancora una volta, è proprio come il blocco di ripetizione in Scratch. E potrai utilizzare questo in poco tempo. 

Questo significa solo conteggio da zero fino a, ma non uguale, a 64. E su ciascuna iterazione di questo ciclo, continua incrementando i. Così i ++ - e questo costrutto generale sulla linea 7 è solo un modo super comune di ripetere alcune linee di codice, un numero di volte. Quali linee di codice? Queste parentesi graffe, come si potrebbe essere raccolte da ora, significa, effettuare le seguenti operazioni. 

E 'in Scratch come, quando ha i blocchi gialli e altri colori che tipo di abbracciare o abbracciare altri blocchi. Questo è ciò che quei ricci bretelle stanno facendo qui. Quindi, se ho preso la mia sintassi destra- sopra voi può vedere il simbolo di carota in C mezzi questo è quante volte sono stato cercare di risolvere questo problema. Quindi cerchiamo di sbarazzarsi di quella del tutto, e chiudere quella finestra. E useremo quello nuovo. Fare troppo pieno, barra dot troppo pieno, Enter, va bene, sembra male in un primo momento. Ma facciamo scorrere indietro nel tempo, perché ho fatto questo 64 volte. 

E notare la prima volta, n è 1. Seconda volta, n è 2, poi 4, poi 8, poi 16. E sembra che appena Arrivare a circa 1 miliardo, se raddoppio di nuovo, che dovrebbe darmi 2 miliardi. Ma si scopre, è proprio sulla cuspide. 

E così è in realtà trabocca un int da 1 miliardo a circa 2 negativo miliardi, perché un numero intero, a differenza del numeri che sono state assumendo la scorsa settimana, può essere sia positivo che negativo in realtà e in un computer. E così almeno uno di quelli bit è effettivamente rubati. Così abbiamo davvero solo 31 bit, o 2 miliardi di possibili valori. 

Ma per ora, l'asporto è abbastanza semplicemente, qualunque siano questi numeri sono e tutto ciò che la matematica è, succede qualcosa di brutto alla fine, perché alla fine si sta tentando di permutare i bit di una volta di troppo. E in modo efficace va da tutti 1 di a forse tutti i 0 del, o forse solo qualche altro modello che chiaramente, a seconda del contesto, può essere interpretato come un numero negativo. E così sembrerebbe la più alta I può contare in questo particolare programma è solo approssimativamente 1 miliardo. Ma c'è una soluzione parziale qui. Sai cosa? 

Vorrei cambiare da un int per un lungo tempo. E mi permetta di andare avanti qui e say-- ho intenzione di avere per cambiare l'accaduto a un unsigned long. Oppure, vediamo, non mi ricordo mai me stesso. 

Andiamo avanti e fare troppo pieno. No, non è questo, LLD, grazie. Così a volte Clang può essere utile. Non mi ricordo cosa il formato specificatore è stato per lungo tempo. 

Ma, in effetti, Clang mi ha detto. Il verde è una sorta di bene, significa che ancora hai fatto un errore. E 'indovinando che volevo dire LLD. 

Quindi, mi permetta di prendere è un consiglio, un lungo numero decimale lungo, salvo che. E mi permetta di eseguire di nuovo esso, dot tagliare troppo pieno, Invio. E ora che cosa è cool è questo. 

Se ho scorrere indietro nel tempo, abbiamo ancora iniziamo contando allo stesso posto-- 1, 2, 4, 8, 16. Avviso, otteniamo tutto il fino a 1 miliardo. Ma poi abbiamo tranquillamente arriva a 2 miliardi. 

Poi si arriva a 4 miliardi, poi 8 miliardi, 17 miliardi. E andiamo più in alto, e sempre più alto. Alla fine, anche questo, si rompe. 

Alla fine, con un lungo tempo, che è il valore a 64-bit, non un valore a 32 bit, se si conta troppo alto, si avvolge intorno a 0. E in questo caso, ci capita di finire con un numero negativo. 

Quindi questo è un problema. E si scopre che questo problema non è poi così arcana. Anche se ho deliberatamente indotto con questi errori, si scopre lo vediamo genere di tutto intorno a noi, o almeno alcuni di noi fare. 

Quindi, in Lego Star Wars, se avete mai giocato al gioco, si scopre che si può andare in giro rompere le cose in mondo LEGO, e la raccolta delle monete, in sostanza. E se hai mai giocato questo gioco troppo tempo, come questo individuo senza nome qui ha fatto, il numero totale di monete che si possono raccogliere è, a quanto pare, 4 miliardi. 

Ora, con in realtà è arrotondato. Così LEGO stava cercando di mantenere le cose user friendly. Non hanno fatto esattamente 2 a il 32 di potenza, per la settimana scorsa. Ma 4 miliardi è una ragione. Sembra, sulla base di queste informazioni, che LEGO, e la società che reso questo software vero e proprio, ha deciso che il numero massimo di monete l'utente può accumulare è, infatti, 4 miliardi, perché hanno scelto nel loro codice da utilizzare non un lungo tempo, apparentemente, ma solo un numero intero, un unsigned integer, solo un numero intero positivo, cui valore massimo o meno è così. Bene, ecco un altro divertente. Quindi, nel gioco Civilization, che alcuni di voi potrebbero avere familiarità con si scopre che anni fa ci era un bug in questo gioco in cui se hai giocato il ruolo di Gandhi nel gioco, invece di essere molto pacifista, invece era incredibilmente, incredibilmente aggressivo, in alcune circostanze. In particolare, il modo in cui civiltà opere è che se si, il giocatore, adottare la democrazia, la vostra punteggio aggressività ottiene decrementato di due, in modo meno minus, e quindi meno meno. 

Così si sottrae 2 dal il vostro iterazione attuale. Purtroppo, se il vostro è l'iterazione inizialmente 1, e si sottrae 2 da esso dopo aver adottato la democrazia come Gandhi qui potrebbe hanno fatto, perché era molto passive-- 1 sulla scala di aggressività. Ma se egli adotta la democrazia, allora va da 1 a negativo 1. 

Purtroppo, erano utilizzando i numeri senza segno, il che significa che hanno trattato addirittura negativo i numeri come se fossero positivi. E si scopre che il equivalente positivo di negativo 1, nei programmi tipici di computer, è 255. Quindi, se Gandhi adotta la democrazia ha, e quindi il suo punteggio di aggressività è diminuito, in realtà rotola intorno a 255 e lui la maggior parte delle marche carattere aggressivo nel gioco. Così si può google su questo. E 'stato, infatti, un accidentale bug di programmazione, ma che è entrato abbastanza la tradizione da allora. 

Questo è tutto divertente e simpatico. Più spaventoso è quando attuale dispositivi del mondo reale, e non giochi, hanno gli stessi errori. Infatti, appena un anno fa, un articolo è venuto conoscere il Boeing 787 Dreamliner. 

E l'articolo in prima sguardo legge un po 'arcano. Ma ha detto questo, un software vulnerabilità in Boeing nuovo 787 Dreamliner jet ha il potenziale di causare piloti a perdere il controllo della dell'aeromobile, possibilmente in pieno volo, i funzionari della FAA compagnie aeree avvertito di recente. Era la determinazione che un modello 787 aereo che è stato alimentato ininterrottamente per 248 giorni può perdere tutto in corrente alternata, AC, potenza elettrica dovuta al generatore centraline, GCUs, simultaneamente entrare in modalità sicura sicuro. E 'una specie di perdermi. Ma il memo dichiarato, OK, ora ho ottenuto che, la condizione è stata causata da un software contatore interno a il controllo del generatore unità che traboccherà dopo 248 giorni di potenza continua. Stiamo promuovendo il presente notare per prevenire la perdita di tutti AC elettrica alimentazione, che potrebbe risultare la perdita di controllo del velivolo. 

Quindi, letteralmente, c'è qualche intero, o qualche tipo di dati equivalente, utilizzato nel software in un velivolo reale che se si mantiene il vostro aereo abbastanza a lungo, che apparentemente può essere il caso se si sta solo in esecuzione loro costantemente e mai scollegare il vostro aereo, a quanto pare, o lasciando che le sue batterie morire, alla fine contare su, e su, e su, e su, e su, e su. 

E, per sua natura, un quantità limitata di memoria traboccherà, sul ritorno alla zero o un valore negativo, un effetto collaterale dei quali è il la realtà spaventosamente reale che il piano potrebbe essere necessario essere riavviato, in modo efficace, o potrebbe cadere, peggio, come si vola. Così questi tipi di problemi sono ancora con noi, even-- questo è stato un articolo 2015, tanto più spaventoso quando non si necessariamente capire, apprezzare, o anticipare quei tipi di errori. 

Così si scopre c'è un altro cosa negativa di rappresentazione dei dati. Si scopre che anche i galleggianti sono sorta di imperfetto, perché galleggia, troppo, Ho proposto sono a 32 bit, o forse 64 se si utilizza un doppio. Ma questo è ancora finita. 

E il problema è che se si può mettere un numero infinito di numeri dopo il punto decimale, non vi è alcun modo di può rappresentare tutte le possibili numeri che ci è stato insegnato nel grado scuola può esistere nel mondo. Un computer, essenzialmente, deve scegliere un sottoinsieme di questi numeri per rappresentare accuratamente. 

Ora, il computer può tondo forse un po ', e può permettere di circa negozio qualsiasi numero si potrebbe desiderare. Ma solo intuitivamente, se si hanno un numero finito di bit, è possibile permutare solo in tanti modi finiti. Così non si può forse utilizzare un numero finito di permutazione di bit, modelli di zero e uno, rappresentare un infinito numero di numeri, il che suggerisce che i computer potrebbero benissimo essere sdraiato a noi a volte. 

In realtà, cerchiamo di fare questo. Torniamo in CS50 IDE. Lasciami andare avanti e creare un piccolo programma L'imprecisione chiamato, per mostrare che computer sono, infatti, imprecise. 

E mi permetta di andare avanti e iniziare con alcuni di quel codice da prima, e ora solo fare quanto segue. Mi permetta di andare avanti e fare printf, per cento f, backslash n, 1 diviso per 10. In altre parole, cerchiamo di tuffo nel profondo a 1/10, come 1 e diviso per 10. Sicuramente, un computer può rappresentare 1/10. 

Quindi cerchiamo di andare avanti e fare l'imprecisione. Vediamo. Formato specifica tipo double. Ma l'argomento è di tipo int. Cosa sta succedendo? 

Oh, interessante, quindi è un lezione imparata da prima. Sto dicendo, hey, computer di spettacolo me un galleggiante con cento f. Ma io sto dando 2 int. Così si scopre, posso risolvere questo in un paio di modi. 

Ho potuto solo girare uno in 1.0, e 10 in 10.0, che sarebbe, in effetti, avere l'effetto di conversione li in floats-- ancora si spera lo stesso numero. Oppure si scopre che c'è qualcosa vedremo di nuovo in poco tempo. Si potrebbe lanciare i numeri. 

È possibile, utilizzando questa parentesi espressione, si può dire, Hey, computer, prendere questa 10, che so essere un int. Ma trattare, per favore, come se fosse un galleggiante. Ma questo si sente inutilmente complesso. 

Per i nostri scopi di oggi, facciamo solo letteralmente rendono loro i valori in virgola mobile con un punto decimale, come questo. Lasciami andare avanti e replica, fare imprecisioni, buono, barra dot imprecisioni, entrare. OK, stiamo guardando bene. 

1 diviso 10, secondo il mio Mac qui, è, infatti, 0.100000. Ora, mi è stato insegnato nella scuola elementare lì deve essere un numero infinito di 0 di. Quindi cerchiamo di almeno provare per vedere alcuni di questi. Si scopre che printf è un po ' amatore ancora che abbiamo usato. Si scopre che non è necessario specificare proprio per cento f, o semplicemente per cento i. Si può effettivamente specificare alcune opzioni di controllo qui. 

In particolare, sto andando per dire, ehi, printf, in realtà mi mostra 10 punti decimali. Quindi sembra un po 'strano. Ma che dici per cento, punti, quanti numeri vuoi vedere dopo il punto decimale, e quindi f per piatta, proprio perché è quello che dice la documentazione. Lasciami andare avanti e salvare questo. 

E notare troppo, sto diventando stanco di riscrivere le cose. Così sto solo impostando l'alto e freccia verso il basso le chiavi qui. E se continuo a colpire in su, può vedere tutti i comandi che ho fatto, o non correttamente fatto. 

E ho intenzione di andare avanti ora e in realtà non usare quella, a quanto pare. Fare imprecisioni, dot tagliare imprecision-- così quello che mi è stato insegnato a scuola elementare estrae. Anche se stampo a 10 decimale lo colloca, infatti, è 0.10000. Ma sai una cosa? 

Prendiamo un po 'avido. Diciamo che, come, mostrarmi 55 punti dopo la virgola. Facciamo davvero prendere questo programmare fuori per un giro. Mi permetta di rifarlo con make imprecisioni, barra di punti, imprecisioni. 

E qui andiamo. La vostra infanzia era una bugia. Apparentemente, 1 diviso 10 è infatti 0.100000000000000005551115123-- 

Cosa sta succedendo? Beh, si scopre, se tipo di guardare abbastanza lontano nel sottostante rappresentazione di questo il numero, in realtà non è esattamente 1/10, o 0,1 e un numero infinito di zeri. Ora, perché? 

Bene, anche se questo è un semplice numero per noi esseri umani, 1 diviso per 10, è ancora uno di infiniti numeri che si potrebbe pensare su. Ma un computer può rappresentare solo un numero finito di numeri così. E così, di fatto, cosa computer mostra a noi è il suo più vicino approssimazione al numero vogliamo credere è 1/10, o realmente 0.10000 all'infinito. 

Piuttosto, però, questo è il più vicino come si può ottenere. E, in effetti, se si guarda sotto la cappa, come noi siamo qui, cercando 55 cifre dopo la virgola, in realtà vediamo che la realtà. Ora, come un a parte, se hai mai visto la movie-- la maggior parte di voi probabilmente haven't-- ma Superman 3 alcuni anni fa, Richard Pryor essenzialmente sfruttato questo la realtà in sua compagnia per rubare un sacco di frazioni e frazioni di centesimi, perché il Company-- come ricordo, è stato un while-- era essenzialmente buttare via tutto ciò che non si adattava nella nozione di centesimi. 

Ma se si sommano tutti questi piccoli, piccoli, piccoli numeri ancora una volta, e ancora, e ancora, è possibile, come in il suo caso, fare una buona quantità di denaro. 

La stessa idea è stata strappato via da un più recente, ma ancora oggi più vecchio film, chiamato Office Space, dove i ragazzi in quel film, ha fatto la stessa cosa, avvitata in su completamente, si è conclusa con modo troppo soldi nel loro conto in banca. E 'stato tutto molto sospetto. Ma alla fine della giornata, imprecisione è tutto intorno a noi. 

E che, inoltre, può essere Spaventosamente il caso. Si scopre che Superman 3 e Office Space a parte, ci può essere un po 'molto reale ramificazioni mondiali delle realtà imprecisa rappresentazione dei dati che anche noi esseri umani a questo giorno non necessariamente capire come dovremmo, o ricordare come spesso come dovremmo. E, in effetti, il seguente clip è da uno sguardo ad alcuni mondo molto reale ramificazioni di ciò che accade se si non apprezzano l'imprecisione che può accadere nella rappresentazione dei numeri. 

[RIPRODUZIONE VIDEO] 

-Computers, Tutti abbiamo imparato ad accettare i problemi spesso frustrante che andare con them-- bug, virus, e anomalie nel software, per i piccoli prezzi da pagare per la comodità. Ma in alta tecnologia e ad alta velocità applicazioni programmi spaziali militari e, il più piccolo problema può essere ingrandita nel disastro. 

Il 4 giugno del 1996, gli scienziati preparati per lanciare un razzo Ariane 5 senza equipaggio. Si stava trasportando scientifica satelliti progettati per stabilire con precisione come la interagisce campo magnetico della terra con venti solari. Il razzo è stato costruito per l'Agenzia spaziale europea, e sollevato fuori dal suo stabilimento sulla costa della Guyana francese. 

-A Circa 37 secondi in il volo, in primo luogo notato qualcosa stava andando storto. Gli ugelli sono orientabili in un modo che davvero non dovrebbe. Circa 40 secondi dall'inizio del volo, chiaramente, il veicolo era in difficoltà. 

Ed è allora che hanno fatto la decisione di distruggerla. Il responsabile della sicurezza gamma, con enormi coraggio, preme il pulsante, fatto saltare in aria il razzo, prima che potesse diventare un pericolo per la sicurezza pubblica. 

-Questo Era la fanciulla viaggio del Ariane 5. E la sua distruzione ha preso posizionare causa di un difetto incorporato nel software del razzo. -Il Problema sul Ariane era che c'era un numero che necessaria 64 bit per esprimere. E volevano convertire in un numero a 16 bit. Si presume che il numero avrebbe mai essere molto grande, che la maggior parte di quelli cifre in un numero a 64 bit erano zeri. Si sbagliavano. 

-La Incapacità di una programma software per accettare il tipo di numero generato da un altro era alla radice del fallimento. Lo sviluppo del software era diventato un parte molto costosa delle nuove tecnologie. Il razzo Ariane sono stati molto successo, tanto del software creata per era anche utilizzato nella Ariane 5. 

-Il Problema di fondo era che il Ariane 5 è stato più veloce, più veloce accelerato. E il software non ha avuto spiega che cosa. 

-La Distruzione del razzo è stato un grande disastro finanziario, tutto a causa di un errore di software minuto. Ma questo non era il primo problemi di conversione dei dati in tempo aveva afflitto tecnologia dei razzi moderna. 

-In 1991 con l'avvio della prima Guerra del Golfo, il Patriot Missile sperimentato una specie simile del problema di conversione numero. E come risultato, 28 persone, 28 soldati americani, sono stati uccisi, e circa altri 100 feriti, quando il Patriot, che avrebbe dovuto per la protezione contro rincoramenti arrivo, omesso di sparare un missile. 

-Quando Iraq invase il Kuwait, e in America Desert Storm lanciato all'inizio del 1991, batterie Patriot Missile sono stati schierati per proteggere l'Arabia Saudita e Israele da attacchi missilistici iracheni Scud. La Patriot è un medio raggio US superficie per aria, prodotto dalla società Raytheon. 

-La Dimensione del intercettore Patriot di per sé è di circa circa 20 piedi. E pesa circa 2.000 chili. E porta una testata di circa, Penso che sia più o meno 150 libbre. E la testata stessa è un alto esplosivo, che ha frammenti intorno ad esso. L'involucro della testata è progettato per agire come pallettoni. 

-Le Missili sono svolte quattro per contenitore, e sono trasportati da un semirimorchio. 

-Il Sistema Patriot antimissile risale subito almeno 20 anni. È stato originariamente progettato come un missile di difesa aerea di abbattere gli aerei nemici. Nella prima Guerra del Golfo, quando la guerra è arrivato, l'esercito voleva usarlo per abbattere Scud, non aerei. 

L'Air Force iracheno era non tanto di un problema. Ma l'esercito era preoccupato per Scud. E così hanno cercato di aggiornare il Patriot. 

-Intercepting Un nemico missile viaggiando a Mach 5 stava per essere abbastanza impegnativo. Ma quando il Patriot è stato ricoverato in servizio, l'esercito non era a conoscenza di un modifica irachena che ha fatto i loro scudi quasi impossibile da colpire. 

-Cosa È successo è il Scud che stavano entrando erano instabili. Erano dondolavano. La ragione di questo è stato gli iracheni, in ordine per ottenere 600 chilometri su un chilometro 300 gamma di missili, ha preso di peso dalla testata anteriore. Hanno fatto la testata più leggero. 

Così ora il Patriot è cercando di venire al Scud. E la maggior parte del tempo, la stragrande maggioranza del tempo, sarebbe solo volare dal Scud. Una volta che i gestori del sistema Patriot ha realizzato il Patriot mancato il suo obiettivo, hanno fatto esplodere testata del Patriot al fine di evitare possibili incidenti, se si è stato permesso di cadere a terra. 

-Che Era quello che la maggior parte delle persone hanno visto, quei grandi palle di fuoco nel cielo, e fraintesa come intercettazioni di testate Scud. 

-Anche Se nella notte cieli, Patriots apparve di essere con successo distruggendo Scud, a Dhahran, ci potrebbe essere nessun errore sulle sue prestazioni. Lì, il sistema radar del Patriot perso le tracce di un Scud in arrivo, e mai lanciato a causa ad un difetto del software. E 'stato gli israeliani che per primo ha scoperto che più il sistema era acceso, maggiore è il tempo di discrepanza divenne, a causa di un orologio incorporato nel computer del sistema. 

-A Proposito di due settimane prima la tragedia di Dhahran, gli israeliani riferito a il Dipartimento della Difesa che il sistema perdeva tempo. Dopo circa otto ore o in esecuzione, hanno notato che il sistema stava diventando decisamente meno precise. Il Dipartimento della Difesa ha risposto raccontando tutte le batterie Patriot di non lasciare i sistemi per lungo tempo. Non hanno mai detto quello che un lungo periodo di tempo era-- otto ore, 10 ore, 1.000 ore. Nessuno sapeva. 

-La Batteria Patriot di stanza presso la caserma a Dhahran e la sua viziata interna orologio era stato in più di 100 ore la notte del 25 febbraio. 

-E Monitorati tempo con una precisione di circa un decimo di secondo. Ora, un decimo di secondo è un numero interessante, perché non può essere espressa in binario esattamente, che significa che non può essere espressa esattamente in qualsiasi moderno computer digitale. È difficile da credere. 

Ma utilizzare questo come esempio. Prendiamo il numero di un terzo. Un terzo non può essere espresso in decimali esattamente. Un terzo è 0.333 in corso per l'infinito. 

Non c'è modo di farlo con precisione assoluta in decimale. Questo è esattamente il tipo di problema quello che è successo nel Patriot. Più lungo è il sistema di corse, il peggio l'errore di tempo è diventato. 

-Dopo 100 ore di funzionamento, la errore nel tempo era solo circa un terzo di un secondo. Ma in termini di mira un missile viaggiando a Mach 5, si è tradotto in un inseguimento errore di oltre 600 metri. Sarebbe un errore fatale per i soldati su cosa successo è un lancio Scud era rilevato dai satelliti di preallarme e sapevano che il Scud era venendo nella loro direzione generale. Non sapevano dove venisse. 

-Era Ora fino al radar componente del sistema Patriot difendere Dhahran per individuare e mantenere traccia del missile nemico in arrivo. 

-Il Radar era molto intelligente. Sarebbe in realtà tenere traccia la posizione del Scud, e poi prevedere dove probabilmente sarebbe la prossima volta radar inviato Un impulso fuori. Che è stato chiamato un cancello gamma. 

-Poi, Una volta che il Patriot decide il tempo ha passato a tornare indietro e controllare il prossimo posizione per questo oggetto rilevato, risale. Così, quando si tornò al sbagliata posto, poi vede nessun oggetto. E decide che non c'era oggetto, si trattava di un falso rilevamento, e scende in pista. 

-Il Scud in entrata scomparso dallo schermo radar. E pochi secondi dopo, è sbattuto in caserma. Il Scud ucciso 28, ed è stato l'ultimo uno sparato durante la prima Guerra del Golfo. 

Tragicamente, il software aggiornato arrivati ​​a Dhahran il giorno seguente. Il difetto del software aveva stato, chiusura fisso un capitolo nella travagliata la storia del missile Patriot. 

[RIPRODUZIONE VIDEO] David J. MALAN: Quindi questo è tutto da dire che questi problemi di trabocco e l'imprecisione sono fin troppo reale. Così come siamo arrivati ​​qui? Abbiamo iniziato con solo parlando di printf. Anche questa funzione che stampa qualcosa sullo schermo, e abbiamo introdotto successivamente alcune altre funzioni dalla cosiddetta biblioteca di CS50. E noi continueremo a vedere questi a tempo debito. E noi, in particolare, usato stringa di ottenere, e ottenere int, e ora anche ottenere galleggiante, e altri ancora saranno ancora che incontrano e utilizzare noi stessi in breve tempo. 

Ma a volte, avere abbiamo già visto un bisogno per memorizzare ciò che quelle funzioni mano indietro? ci riporta una stringa Essi mano, o un int, o di un galleggiante. E a volte abbiamo bisogno di mettere che stringa o int, float o, in qualche luogo. 

E per memorizzare quelle cose, ricordare solo come in Scratch, abbiamo variabili. Ma a differenza di Scratch, in C abbiamo tipi effettivi dei dati variables-- tipi, più generally-- tra questi, una stringa, un int, un float, e questi altri ancora. 

E così, quando dichiariamo le variabili in C, saremo costretti a dichiarare i nostri tipi di dati. Questo non è qualcosa faremo hanno a che fare più avanti nel semestre come abbiamo transizione ad altre lingue. Ma per ora, abbiamo bisogno a priori in anticipo, spiegare al computer che tipo di variabili vogliamo che darci. 

Ora, nel frattempo, per la stampa questi tipi di tipi di dati, dobbiamo dire printf cosa aspettarsi. E abbiamo visto per cento s per le stringhe, e cento i per interi, e pochi altri già. E quelli sono semplicemente requisiti per la presentazione visiva di tali informazioni. 

E ciascuno di questi può effettivamente essere parametrizzata o ottimizzato in qualche modo, se si vuole ulteriormente il controllo il tipo di output che si ottiene. E, infatti, si scopre che non solo c'è backslash n per una nuova linea. C'è qualcos'altro chiamato backslash R per un ritorno a capo, che è più simile a un vecchia macchina da scrivere scuola, e anche di Windows utilizzato per molti anni. 

C'è t backslash per le schede. Si scopre, che se si vuole doppio apice all'interno di una stringa, Ricordiamo che abbiamo usato doppia doppia citazione citazione a sinistra e destra estremità delle nostre corde finora. Ciò sembrerebbe confondere le cose. 

Se si vuole mettere un doppio apice in mezzo di una string-- e, anzi, è fonte di confusione per vedere. E quindi bisogna sfuggire, in modo da dire, un doppio apice con qualcosa come, letteralmente, la barra inversa virgolette. E c'è qualche altro ancora. E vedremo più di quelli nell'uso reale non molto. 

Quindi cerchiamo di passaggio da ora dei dati, e la rappresentazione, e gli operatori aritmetici, tutto di cui ci ha dato un po 'di costruzione blocchi con cui giocare. Ma ora diamo effettivamente dare noi il resto del vocabolario che abbiamo già avuto la settimana scorsa con Scratch per dare un'occhiata a qualche altro costrutti in C-- non tutti. Ma le idee noi siamo per vedere in realtà solo per sottolineare la traduzione dal una lingua, Scratch, ad un altro, C. 

E nel corso del tempo, ci prendiamo più strumenti per il nostro toolkit, per così dire, sintatticamente. E, in effetti, si vedrà che le idee sono ormai piuttosto familiare della scorsa settimana. Quindi cerchiamo di fare questo. 

Andiamo avanti e improvvisare un programma che in realtà utilizza alcune espressioni, una espressione booleana. Lasciami andare avanti qui e creare un nuovo file. Chiamerò questo condition.c. 

Lasciami andare avanti e includere la libreria CS50. E mi permetta di andare avanti e includo standard di io.h per le nostre funzioni, e printf, e altro ancora, rispettivamente. Permettetemi di fare a me stesso che boilerplate di int void main, la cui spiegazione faremo tornare in futuro. 

Ora vorrei andare avanti e dare io stesso un int tramite get int. Allora mi permetta di andare avanti e fare questo. Voglio dire se i è less-- facciamo distinguere tra positivo, negativo, o valori zero. 

Quindi, se i è minore di zero, mi permetta basta questo programma semplicemente dire, negativo, backslash n, altro se i è maggiore di zero. Ora sto, ovviamente, andando a dire printf positivo, backslash n. E poi altro se: avrei potuto fare questo. 

Ho potuto fare se è uguale a 0. Ma io avrei fatto a Almeno un errore già. Ricordiamo che il segno di uguale è non uguale, come noi esseri umani sanno. 

Ma è l'operatore di assegnazione. E noi non vogliamo prendere sul 0 destra e metterlo in i sulla sinistra. Quindi, per evitare questa confusione, o forse cattivo uso del segno di uguale, gli esseri umani hanno deciso alcuni anni fa, che in molti linguaggi di programmazione quando si desidera controllare per l'uguaglianza tra la sinistra e la destra, che effettivamente utilizzate è pari a pari. Così si colpisce il segno di uguale due volte. Quando si desidera assegnare da destra a sinistra, è possibile utilizzare un unico segno di uguale. Così abbiamo potuto fare altro questo-- se è uguale a è uguale a zero. 

Potrei poi andare a aprire le mie parentesi graffe, e dire, printf 0, backslash n, fatto. Ma ricordare come questi forchette in mezzo alla strada in grado di lavorare. E, in realtà, basta pensare alla logica. i è un numero. Si tratta di un intero, in particolare. E questo significa che sta andando ad essere meno di 0 o maggiore di 0 o 0. Quindi non vi è una specie di questo caso di default implicito. 

E così abbiamo potuto, proprio come Scratch, a meno della else if, e solo dire altro. Logicamente, se la programmatore sa c'è solo tre secchi in cui un scenario può fall-- il primo, il secondo, o il terzo in questo case-- non lo fanno fastidio aggiungendo la precisione aggiuntivo e la logica aggiuntiva lì. Basta andare avanti con il caso di default qui di altro. 

Ora, andiamo avanti dopo aver salvato questo, fare condizioni dot tagliare conditions-- Non una grande interfaccia utente, perché io non sto spingendo la utente, come ho detto prima. Ma va bene. Terremo le cose semplici. Proviamo il numero 42. E questo è positivo. Proviamo il numero negativo 42, negativo. 

Proviamo il valore 0. E, in effetti, funziona. Ora, si vedrà con problemi prima lunghe, le cose di prova tre volte, Probabilmente non è sufficiente. Probabilmente si desidera testare alcuni numeri più grandi, un po 'più piccolo numeri, alcuni casi angolo, come verremo a descriverli. 

Ma per ora, questo è un programma piuttosto semplice. E sono abbastanza sicuro che, logicamente, che cade in tre casi. E, in effetti, anche se abbiamo solo concentrati sui potenziali aspetti negativi di imprecisione e troppo pieno, in realtà dove molti dei problemi di CS50, non stiamo andando a preoccuparsi A proposito, per tutto il tempo, questi problemi di troppo pieno e imprecisioni, perché, infatti, in C, non è poi così facile da evitare quelle cose. Se si desidera contare fino più grande, e più grande, e più grande, si scopre ci sono tecniche che può usare, che spesso coinvolgono cose chiamate biblioteche, collezioni di codice, che altre persone hanno scritto che è possibile utilizzare, e altri linguaggi come Java e altri, in realtà rendere molto più facile a contare ancora più in alto. Così è davvero alcuni di questi pericoli una funzione del linguaggio che si usa. E nelle prossime settimane, ci vedere come pericoloso C davvero può essere se non si utilizza in modo corretto. Ma da lì, e con Python, e JavaScript, sarà abbiamo strato su alcune protezioni aggiuntive, ed eseguire meno di tali rischi. 

Quindi cerchiamo di fare un po 'di più logica interessante nel nostro programma. Quindi, mi permetta di andare avanti e di creare un programma denominato Logical solo così posso giocare con alcuni la logica attuale, logical.c. Mi limiterò a copiare e incollare un po ' codice da così presto torno a questo bel punto di partenza. 

Lasciami fare questa volta C. char Sono andare a dargli un nome di C solo perché è convenzionale, ottenere un carattere dall'utente. E facciamo finta come Sto implementando parte di quel programma Rm, la rimozione programma prima che ha spinto l'utente per rimuovere un file. Come potremmo fare questo? 

Voglio dire, se è uguale a C è uguale, tra virgolette, y, quindi ho intenzione di assumere che l'utente ha scelto sì. Sto solo andando a stampare sì. Se fosse in realtà la scrittura il programma di rimozione, potremmo rimuovere il file con più linee di codice. Ma noi terremo le cose semplici. 

Altrimenti, se c è uguale uguale n-- e ora qui, ho intenzione di dire, l'utente deve aver significato no. E poi gli altri, sai una cosa? Non so che altro l'utente sta per digitare. Così sto solo andando a dire che che è un errore, qualunque lui o lei in realtà digitato. 

Allora, cosa sta succedendo qui? Vi è una differenza fondamentale rispetto a quello che ho fatto in passato. doppi apici, doppi apici, doppio citazioni, e, tuttavia, virgolette singole, apici. Risulta in C, che quando si vuole scrivere una stringa, si fa usare le virgolette, proprio come abbiamo state utilizzando tutto questo tempo con printf. 

Ma se si vuole affrontare con un solo singolo carattere, un cosiddetto char, poi effettivamente utilizzati apici. Quelli di voi che hanno programmato prima, non si potrebbe avere ha dovuto preoccuparsi di questo distinzione in alcune lingue. In C, esso non importa. E così, quando ho un carattere e voglio per confrontare che char utilizzando eguali è uguale a qualche lettera, come Y o N, lo faccio, anzi, devono avere le virgolette singole. 

Ora, andiamo avanti e fare questo. Andiamo avanti e facciamo dot logiche tagliano logico. E ora sto venga richiesto. Quindi, presumibilmente, una migliore esperienza utente sarebbe in realtà mi dica cosa fare qui. Ma ho intenzione di ciecamente y dire per Sì, OK, bello. 

Corriamo ancora, n per no, bello. Supponiamo come certe persone che conosco, i miei tasto Bloc Maiusc è su troppo spesso. Così faccio capitale Y, immettere, errore. OK, non è esattamente quello che mi aspetto. Infatti, il computer sta facendo letteralmente ciò Ho detto che per verificare la presenza di fare-- minuscole y e minuscole n. Questo non si sente come bene l'esperienza degli utenti, però. Mi permetta di chiedere e accetto sia minuscolo o maiuscolo. Così si scopre, si potrebbe desiderare a dire qualcosa di simile a Scratch, come letteralmente o uguale a C è uguale a capitale singolo y citato. Risulta, C non ha questa parola chiave letterale o. 

Ma ha due barre verticali. È necessario tenere premuto Shift solito, se si sta utilizzando una tastiera americana, e ha colpito la barra verticale chiave sopra il tasto invio. Ma questa barra verticale barra verticale significa o. 

Se, invece, volevamo a dire e, come in Scratch, potremmo fare e commerciale e commerciale. Questo non ha senso logico qui, perché un essere umano non poteva digitato sia y e y minuscola e il capitale Y come lo stesso carattere. Quindi, o è quello che vogliamo qui. 

Quindi, se faccio questo in entrambi i luoghi, o c è uguale a equals capitale N, ora eseguire di nuovo, rendere logico, eseguire nuovamente logico. Ora, posso digitare y. E posso farlo di nuovo con capitale Y, o al capitale N. E potrei aggiungere ulteriore combinazioni ancora. 

Quindi questa è una logica programma nella misura in cui la società Sto controllando logicamente questo valore o questo valore. E io non devo, necessariamente, venire con altri due IFS oppure IFS. Posso effettivamente combinare alcuni dei correlate logica insieme in questo modo. Quindi questo sarebbe meglio progettata che semplicemente dicendo, se è uguale a C minuscola y, stampare sì, altrimenti se c è uguale a capitale Y, stampare sì, altrimenti se c è uguale lower-- in altre parole, non si deve avere sempre più rami. È possibile combinare alcuni dei equivalente rami logicamente, come in questo modo. 

Quindi, diamo uno sguardo a un solo ingrediente finale, una costruzione finale, che permette C. E ci torneremo in futuro per altri ancora. E poi ci concludiamo, cercando di non la correttezza della code-- ottenere il codice per work-- ma il design di codice, e piantare quei semi nella fase iniziale. 

Quindi, mi permetta di andare avanti e aprire un nuovo file qui. Sai cosa? Ho intenzione di re-implementare quello stesso programma, ma utilizzando un costrutto diverso. 

Quindi, mi permetta rapidamente donarmi l'accesso per includere CS50.h per la biblioteca CS50, standard di io.h per printf. Dammi il mio int void main. E poi qui, lasciare me andare avanti e fare questo. 

Char c ottiene ottenere char, proprio come prima. E ho intenzione di utilizzare un nuovo costrutto now-- passare, su ciò che carattere? Così interruttore è un po 'come commutazione a binari del treno. Oppure, in realtà, è una specie di un altro caso, se il resto se, ma scritta in modo diverso. 

Un interruttore simile a questa. Hai interruttore, e poi cosa carattere o il numero che si desidera guardare, poi alcune parentesi graffe come in Scratch, basta dire fare questa roba. E poi ci sono diversi casi. 

Non si utilizza se e altro. È letteralmente utilizzare il caso di parola. E si potrebbe dire qualcosa di simile. 

Così, nel caso di un minuscolo y, o nel caso di un capitale Y, andare avanti e stampare sì. E poi uscire l'interruttore. Questo è tutto. Sono state fatte. 

Altrimenti, se, per così dire, minuscolo n, o il capitale N, poi andare avanti e di stampa fuori no, e poi pausa. Else-- e questo tipo di è il caso di default indeed-- printf error-- e per buona misura, anche se logicamente questa rottura non è necessario perché siamo alla fine dell'interruttore comunque, Ora sto rompendo fuori dello switch. Quindi, questo sembra un po 'diverso. 

Ma, logicamente, è in realtà equivalente. E perché useresti uno sopra l'altro? A volte, solo preferenze personali, a volte l'estetica, se Guardo questo Ora, c'è qualcosa da dire per la la leggibilità del codice. Voglio dire, non importa il fatto che questo il codice è nuovo per molti di noi nella stanza. 

Ma è solo un po 'è abbastanza. Vedete minuscolo Y, Y capitale, minuscolo n, di default N maiuscola, solo tipo di salti fuori a voi in modo che, probabilmente, forse Nell'esempio precedente con i se, e le barre verticali, e le IFS altro, non potrebbero avere. Quindi questo è veramente una questione di personale scelta, in realtà, o la leggibilità, del codice. 

Ma in termini di funzionalità, mi permetta andare avanti e fare un interruttore, barra dot interruttore, e ora digitare y minuscolo, capitale Y, minuscolo n, N maiuscola, David, riprovare perché è Non un singolo carattere. Facciamo x, l'errore, come previsto. E, logically-- e questo è qualcosa Vorrei incoraggiare a general-- anche anche se siamo solo graffiare la superficie di alcune di queste caratteristiche. 

E potrebbe non essere evidente quando si te sedersi alla tastiera, come funziona? Cosa sarebbe questo fare? La cosa bella di avere un computer portatile, o desktop, o l'accesso a un computer con un compilatore, e con un editor di codice come questo, è che si può quasi sempre rispondere a queste Domande per te solo per provare. 

Per esempio, se la retorica domanda a portata di mano erano, cosa succede se si dimentica le sue dichiarazioni pausa? Che è in realtà un cosa molto comune da fare, perché non sembra come si ha realmente bisogno di loro. In realtà non completano la vostra pensato come una parentesi o un riccio brace fa. Andiamo avanti e ricompilare il codice e vedere. Quindi, fare interruttore, interruttore barra dot. Facciamo digitare in minuscolo y, il bauletto, Enter. Così ho digitato y. 

Il programma ha detto sì, no, errore, come se stava cambiando la sua mente. Ma che tipo di stato, perché ciò che accade con un interruttore è il primo caso partita significa essenzialmente, hey di computer, eseguire tutto il codice sottostante. E se non dici pausa, o non dire rompere, o non dire pausa, il computer sta per soffiare attraverso tutte quelle linee ed eseguire tutti loro fino a quando si arriva a quella parentesi graffa. Così i freni sono, infatti, necessario. Ma un take-away qui è, quando Nel dubbio, provare qualcosa. Forse salvare il codice prima, o salvarlo in un file in più se siete veramente preoccupati incasinare e di dover recuperare il lavoro che si sa sta lavorando. 

Ma provare cose. E non essere così paura, forse, di ciò che il computer potrebbe fare, o che si potrebbe rompere qualcosa. Si può sempre ritornare indietro a qualche versione precedente. 

Così finiamo cercando alla progettazione di codice. Abbiamo questa capacità ora di scrivere le condizioni, e cicli di scrittura, e variabili, e le funzioni di chiamata. Quindi, francamente, siamo sorta di indietro dove siamo stati una settimana fa con Scratch, anche se con un testo meno convincente ambiente di Scratch permette. 

Ma notiamo quanto velocemente abbiamo acquisito quel vocabolario, anche se è andando a prendere un po 'di tempo per affondare in, così che ora possiamo utilizzare questo vocabolario scrivere programmi più interessanti. E facciamo un passo bambino verso quella, come segue. Lasciami andare avanti e creare un nuovo file qui. 

Ho intenzione di chiamare questo prototype.c, e di introdurre per la prima volta, la capacità per rendere le proprie funzioni. Alcuni di voi potrebbero avere fatto questo con Scratch, per cui è possibile creare il propri blocchi personalizzati in Scratch, e poi trascinarli in luogo ovunque si desidera in C. E in più di programmazione lingue, si può fare esattamente che-- fare le proprie funzioni, se non esistono già. 

Così, per esempio, mi permetta di andare avanti e comprendono CS50.h, e comprendono standard di io.h, int void main. E ora abbiamo un segnaposto pronto ad andare. Continuo a cose di stampa come i nomi delle persone di oggi. E che si sente like-- Non sarebbe bello se ci erano una funzione chiamata nome di stampa? Non devo usare printf. Non devo ricordare tutti i codici di formato. Perché non, o perché non l'ha fatto qualcuno prima di me, creare una stampa funzione chiamata nome, che dato qualche nome, semplicemente lo stampa fuori? 

In altre parole, se io dico, hey, calcolatore, dammi una stringa chiedendo all'utente per tali, tramite la funzione di stringa get del CS50. Hey, computer, messo quella stringa in la variabile nel lato sinistro, e chiamare s. E poi, ehi computer, andare avanti e stampa che il nome della persona, fatto. 

Ora, sarebbe bello, perché questo programma, giustamente intitolato, mi dice che cosa dovrebbe fare a titolo di nomi quelli della funzione. Lasciami andare e fare prototipi, Enter. E, purtroppo, questo non sta andando a volare. 

Prototype.c, linea 7, carattere 5, l'errore, dichiarazione implicita della funzione nome di stampa è invalido in C99, C99 cioè una versione di C che è venuto fuori nel 1999. È tutto. 

Quindi io non so cosa tutto questo significa ancora. Ma lo faccio riconoscere l'errore in rosso. Questo è abbastanza ovvio. 

E sembra che con il carattere verde qui, il problema è con il nome di stampa, aperto paren s, vicino paren, punto e virgola. Ma dichiarazione implicita di Funzione abbiamo visto brevemente in precedenza. Questo significa, semplicemente, che Clang non so se mi spiego. 

Ho usato una parola del vocabolario che è mai visto o stato insegnato prima. E quindi ho bisogno di insegnare che cosa significa questa funzione. Quindi ho intenzione di andare avanti e farlo. 

Ho intenzione di andare avanti e mettere in atto la mia funzione chiamata Stampa Nome. E ho intenzione di dire, come segue, che lo fa, printf, ciao, cento s, backslash n, nome, punto e virgola. Così che cosa faccio e basta? 

Così si scopre, a implementare la propria funzione, abbiamo tipo di prestito alcuni dei la stessa struttura principale che abbiamo appena stati dato per scontato, e io conoscere semplicemente copiando e incollando più o meno quello Ho scritto in passato. Ma notare il modello qui. Int, principale, Vuoto, dovremo prendere in giro a parte fra non molto che cosa significa in realtà. 

Ma per oggi, proprio notare il parallelismo. Void, nome di stampa, string name, quindi non c'è una parola chiave viola, che stiamo per iniziare chiamando un tipo di ritorno, il nome la funzione, e quindi l'ingresso. Quindi, in realtà, siamo in grado di distillare questo tipo di come la settimana scorsa come, questo è il nome o Algoritmo del codice siamo andando a write-- la algoritmo sottostante il codice che andremo a scrivere. 

Questo è il suo ingresso. Questa è la sua uscita. Questa funzione, nome di stampa, è progettato per prendere una stringa chiamata nome, o qualunque, come input, e quindi nulla. Esso non restituisce nulla, come ottenere stringa o ottenere int fa. Così sta andando a consegnare me qualcosa di nuovo. E 'solo andando ad avere un effetto collaterale, per così dire, di stampare il nome di una persona. Così Noto, linea 7, I può chiamare il nome di stampa. Linea 10, posso definire o implementare nome di stampa. Ma, purtroppo, questo non è sufficiente. 

Lasciami andare avanti e ricompilare questo dopo il salvataggio. Wow, ora, ce l'ho fatta peggio, sembrerebbe. Dichiarazione Così implicita della Nome funzione di stampa non è valido. E, ancora una volta, non c'è più errori. Ma, come ho ammonito in precedenza, anche se si ottiene sopraffatto con, o un po 'triste vedere così tanti errori, si concentrano solo sulla prima inizialmente, perché potrebbe solo hanno avuto un effetto a cascata. Quindi C, o Clang più specificamente, ancora non riconosce il nome di stampa. 

E questo perché Clang, dal disegno, è una specie di muto. Lo fa solo quello che gli si dice di fare. E lo fa solo in ordine in cui gli si dice di fare. 

Così ho definito principale sulla linea di quattro, come abbiamo fatto abbastanza spesso. Ho definito nome di stampa on line 10. Ma sto cercando di usare nome di stampa on line sette. 

E 'troppo presto, non esiste ancora. Così ho potuto essere intelligente, e come, Ok, facciamo solo giocare insieme, e spostare il nome di stampa fino qui, e ricompilare. Dio mio. Ha funzionato. E 'stato così semplice. 

Ma la logica è esattamente questo. Dovete insegnare Clang cosa è definendo la funzione prima. Quindi è possibile utilizzarlo. Ma, francamente, questo si sente come un pendio scivoloso. 

Così ogni volta che corro in un problema, io sono solo andando ad evidenziare e copiare il codice Ho scritto, tagliarlo e incollarlo qui. E, sicuramente, potremmo escogitare alcuni scenari dove una funzione potrebbe bisogno di chiamare un altro. E non si può mettere ogni funzione di sopra di ogni altra. 

Così si scopre c'è una soluzione migliore. Possiamo lasciare che questo sia. E, francamente, è generalmente bello, e comodo, e buon design mettere principale prima, perché, di nuovo, principale, proprio come quando la bandiera verde cliccato, cioè la funzione che viene eseguito per impostazione predefinita. Così si potrebbe anche mettere nella parte superiore del file in modo che quando si o qualsiasi altro essere umano guarda il file si sa che cosa sta succedendo solo leggendo prima principale. Così si scopre, possiamo dire Clang in modo proattivo, ehi, Clang, sulla linea quattro, Prometto di implementare una funzione chiamata Stampa Nome che prende il nome di stringa denominata come input, e restituisce nulla, nulla. E io andare in giro a implementazione in un secondo momento. 

Ecco che arriva principale. Principali ora in linea 9 può usare Nome in stampatello perché Clang è fiducioso che, alla fine, si incontrerà la definizione dell'attuazione della stampa Nome. Così, dopo aver salvato il mio file, lasciate andare avanti e fare il prototipo, guarda bene questa volta. Dot taglio su, prototipo, mi permetta andare avanti e digitare un nome. David, ciao David, Zamila, ciao Zamila, e, anzi, ora funziona. 

Quindi, l'ingrediente è che abbiamo fatto una funzione personalizzata, come un costume blocco Scratch stiamo chiamando. Ma a differenza di Scratch dove è possibile basta crearlo e iniziare ad usarlo, ora dobbiamo essere un poco più pedante, ed effettivamente formare Clang da utilizzare o aspettarselo. Ora, come un a parte, perché tutto questo tempo hanno siamo stati solo ciecamente sulla fede compreso CS50.h, e compresi di serie io.h? 

Beh, si scopre, Tra un paio di altre cose, tutto ciò che è in quelle dot h file, che si trovano ad essere i file. Stanno File di intestazione, per così dire. Stanno ancora scritte in C. Ma sono un altro tipo di file. 

Per ora, si può tranquillamente supporre che tutto ciò che si trova all'interno di CS50.h è alcune battute come questo, non per le funzioni di chiamata Print Nome, ma per Get String, Get Float, e pochi altri. E ci sono prototipi simili, uno fodere, all'interno di standard di io.h per printf, che ora è in la mia funzione di stampa Nome. Quindi, in altre parole, tutto questo tempo abbiamo appena stato ciecamente copiare e incollare includere questo, includere che, cosa sta succedendo? Queste sono solo tipo di indizi per clang da quali funzioni sono, infatti, implementato, solo altrove in file diversi altrove nel sistema. 

Così abbiamo implementato nome di stampa. Lo fa avere questo effetto collaterale di stampa qualcosa sullo schermo. Ma in realtà non passami qualcosa di nuovo. Come facciamo a l'attuazione di un programma che Mi fa consegnare qualcosa di nuovo? 

Bene, proviamo questo. Lasciami andare avanti e realizzare un file chiamato return.c in modo che possiamo dimostrare come qualcosa come Get String, o Get Int, è in realtà il ritorno qualcosa di nuovo per l'utente. Andiamo avanti e definire int void main. 

E, ancora, in futuro, faremo spiegare ciò che int e quel vuoto è in realtà facendo. Ma per oggi, ci prendilo per buono. Ho intenzione di andare avanti e printf, per una buona esperienza utente, x è. E poi ho intenzione di aspettare il utente di darmi x con get int. 

E poi ho intenzione di andare avanti e stampare x al quadrato. Così, quando hai solo un tastiera, la gente comunemente usare la piccola carota simbolo sulla tastiera rappresentare al potere , o l'esponente. Quindi x ^ è presente i. 

E ora ho intenzione di farlo. Ho potuto solo fare-- ciò che è x al quadrato? x squared è x volte x. 

E abbiamo fatto questo un po ' tempo fa già oggi. Questo non si sente come tutto ciò che molti progressi. Sai cosa? Facciamo leva alcuni di quell'idea dall'ultima volta di astrazione. 

Non sarebbe bello se c'è una funzione chiamata piazza che fa esattamente questo? Ancora, alla fine del giorno, fa la stessa matematica. Ma andiamo astratto via l'idea di prendere un numero moltiplicato per un'altra, e solo dargli un nome, come Piazza di questo valore. 

E, in altre parole, C, creiamo una funzione chiamato piazza che fa esattamente questo. E 'intenzione di essere chiamati quadrato. Sta andando a prendere un int. E faremo sarà solo chiamarla n, per impostazione predefinita. 

Ma potremmo chiamare tutto ciò che vogliamo. E tutto ciò che sta andando a fare, letteralmente, è il ritorno il risultato di n volte n. Ma perché è tornando qualcosa, che è la parola chiave in viola Abbiamo mai visto prima, che, sulla linea 11, non si può solo dire nulla questa volta. 

Void, nell'esempio che abbiamo appena visto piuttosto di nome di stampa, significa semplicemente, Fai qualcosa. Ma non mi consegnare qualcosa in cambio. In questo caso, voglio per tornare n volte n, o qualunque cosa sia, quel numero. 

Quindi non posso dire, ehi, computer, Torno nulla, nulla. E 'intenzione di tornare, per sua natura, un int. E così questo è tutto quello che sta succedendo qui. 

L'ingresso al quadrato sta per essere un int. E in modo che possiamo usare, deve avere un nome, N. E 'intenzione di uscita un int che non ha bisogno di un nome. Siamo in grado di lasciare a principale, o chiunque sia con me per ricordare questo valore se noi vuole con la propria variabile. 

E, ancora, l'unica nuova parola chiave qui è di ritorno. E sto solo facendo un po 'di matematica. Se volevo davvero essere inutile, Potrei dire int prodotto ottiene n volte n. 

E poi potrei dire, prodotto di ritorno. Ma, ancora una volta, al mio punto precedente di Questo semplicemente non essere buono design-- Come, perché introdurre un nome, un simbolo, come il prodotto, solo per tornare immediatamente? E 'un po' più pulito, un po 'più stretto, così a parlare, solo per dire i tempi di ritorno n n, sbarazzarsi di questa linea del tutto. 

Ed è solo meno codice per leggere, meno opportunità per gli errori. E vediamo se questo in realtà ora funziona. Ora, ho intenzione di andare avanti e fare ritorno. 

Uh-oh, implicita dichiarazione di funzione. Ho fatto questo errore prima, un grosso problema. Vorrei solo tipo, o evidenziare e copiare, la stessa identica funzione di prototipo, o la firma, della funzione di quassù. Oppure avrei potuto spostare l'intera funzione. 

Ma questo è un po 'pigro. In modo da non farlo. Ora, permettetemi di fare ritorno ancora una volta, dot ritorno barra. 

x è 2. x Squared è 4. x è 3. x Squared è 9. E la funzione sembra ora di lavorare. Allora, qual è la differenza qui? Ho una funzione che si chiama piazza, in questo caso, che ho messo in un ingresso. E torno un'uscita. Eppure, in precedenza, se Apro l'altro esempio da prima, che è stato chiamato prototype.c, Ho avuto il nome di stampa, che restituito vuoto, per così dire, O è tornato nulla, e semplicemente ha avuto un effetto collaterale. 

Allora, cosa sta succedendo qui? Beh, si consideri la funzione ottenere corda solo per un momento. Abbiamo utilizzato la funzione ottenere stringa nel modo seguente. 

Abbiamo avuto una funzione get stringa, come includono CS50.h, includere standard di io.h, int, principale, vuoto. E poi ogni volta che ho chiamato stringa di ottenere finora, Ho detto qualcosa di simile, stringa s ottiene ottenere stringa, perché get string-- chiamiamolo questa stringa get get.c-- si restituisce una stringa che posso poi usare, e dire ciao, virgola, cento s, backslash n, s. 

Quindi questo è lo stesso esempio, in realtà, che abbiamo avuto in precedenza. Quindi, ottenere stringa restituisce un valore. Ma un momento fa, stringa di stampa non restituisce un valore. Essa ha semplicemente un effetto collaterale. Quindi questa è una differenza fondamentale. Abbiamo visto diversi tipi di funzioni ora, alcuni dei quali sono tornati valori, alcuni dei quali non lo fanno. Quindi forse è stringa o int o float. O forse è solo vuoto. 

E la differenza è che tali funzioni che ottenere i dati e restituire un valore sono in realtà portare qualcosa di nuovo al tavolo, per così dire. Quindi andiamo avanti e guardare un set finale esempi che dà un senso, ora, Come possiamo, anzi, astratto meglio, e meglio, e meglio, o più, e più, e più, al fine scrivere, in ultima analisi, codice migliore. Andiamo avanti, e nello spirito di Scratch, effettuare le seguenti operazioni. 

Lasciami andare avanti e includo CS50.h e standard di io.h. Mi permetta di andare avanti e dare io stesso un int, principale, vuoto. E mi permetta di andare avanti, chiamo questo cough.c. 

E mi permetta di andare avanti e basta come Scratch, stampare tosse / n. E io voglio fare questo per tre volte. Quindi sono, ovviamente, solo andando copiare e incollare tre volte. Ora sto andando a fare tosse dot tosse barra. Diamo me stesso un po 'più spazio qui, Enter, tosse, tosse, tosse. 

C'è, ovviamente, già possibilità di miglioramento. Ho copiato e incollato un paio di volte oggi. Ma questo era solo così non l'ho fatto necessario digitare il maggior numero di caratteri. Ho ancora cambiato ciò che quelle righe di codice sono. 

Queste tre linee sono identiche, che si sente pigro e in effetti è, e probabilmente non è l'approccio giusto. Quindi, con quello che l'ingrediente potremmo migliorare questo codice? Non abbiamo per copiare e incollare il codice. 

E, in effetti, ogni volta che si sente te copia e incolla, e nemmeno modificare il codice, probabilità sono c'è un modo migliore. E, in effetti, c'è. Mi permetta di andare avanti e fare un ciclo for, anche se la sintassi non potrebbe ancora venuto naturalmente. 

Fate questo per tre volte, semplicemente facendo il following-- e mi capita di conoscere questo dalla pratica. Ma abbiamo un certo numero di esempi ora. E vedrete on-line più riferimenti ancora. 

Questa è la sintassi sulla linea 6, che molto simile a Scratch che si ripete blocco, ripetere le seguenti tre volte. E 'un po' magica, per ora. Ma questo otterrà di più, e più familiare. 

E sta andando a ripetere linea di otto per tre volte, in modo che se ho ri-compilare make tosse, dot taglio su tosse, tosse, tosse, tosse. Ancora funziona allo stesso modo. Ecco, questo è tutto bello e buono. Ma non è molto astratto. 

E 'perfettamente corretto. Ma ci si sente come se ci potrebbe essere l'occasione, come nel mondo Scratch, al tipo di avvio aggiungere alcune semantiche qui in modo che Non mi resta che un po 'per il ciclo, e una funzione che dice tosse, o che tossire. Sai cosa? Vorrei cercare di essere un po 'più fresco di quello, ed effettivamente scrivere una funzione che ha alcuni effetti collaterali, lo chiamano tosse. 

E ci vuole nessun ingresso e restituisce alcun valore come output. Ma sai cosa fa? Lo fa questo-- printf, tra virgolette, tosse. 

E ora qui, sto andando di andare avanti e per int, mi viene a zero, i meno di 3, i plus plus. Ho intenzione di non fare printf, che è senza dubbio una implementazione a basso livello dettaglio. Non mi importa come tossire. Voglio solo usare la funzione di tosse. E sto solo andando a chiamare la tosse. 

Ora, si noti la dicotomia. Quando si chiama una funzione, se non lo fai voler dare ingressi, tutto bene. Basta fare paren aperte, chiudere paren, e il gioco è fatto. 

Quando si definisce una funzione, o dichiarare il prototipo di una funzione, se si sa in anticipo che non è andando a prendere qualsiasi argomento, dire nulla in quelle parentesi lì. E questo fa certo che si non abusare accidentalmente. Mi permetta di andare avanti e fare la tosse. E, naturalmente, ho fatto un errore. 

Dannazione, c'è quella dichiarazione implicita. Ma va bene. Si tratta di una soluzione semplice. Ho solo bisogno il prototipo più in alto nel mio file di realtà sto usando. 

Così ora lasciatemi fare tosse di nuovo, piacevole. Ora funziona. Fai la tosse, tosse, tosse, tosse. Quindi, si potrebbe pensare che siamo veramente poco più di ingegneria questo problema. E, in effetti, ci sono. Questo non è un buon candidato di un programma al momento per refactoring, e fare ciò che è chiamato scomposizione gerarchica, dove si prende un po 'di codice, e quindi Si tipo di fattore di cose fuori, così come attribuire più semantica per loro, e riutilizzarlo in ultima analisi, a più lungo termine. Ma si tratta di un blocco di costruzione verso programmi più sofisticati che inizieremo scrivere in breve tempo che ci permette di avere il vocabolario con cui scrivere codice migliore. E, in effetti, vediamo se ci Non si può generalizzare questo ulteriore. 

Sembra un po 'zoppo che io, principale, bisogno di preoccuparsi di questo dannato ciclo for, e chiamando ancora e ancora la tosse. Perché non posso solo dire tosse, Si prega di tosse tre volte? In altre parole, perché non posso semplicemente dare un contributo a tossire e fare questo? 

Perché non posso solo dire, in tosse principale tre volte. E ora, questo è una specie di magico. E 'molto iterativo qui. Ed è, infatti, un bambino passo. 

Ma solo la capacità di dire su linea di otto, tosse tre volte, è solo così molto più leggibile. E, in più, non devo sapere o interessa come la tosse è implementato. E, in effetti, più avanti nel termine e per i progetti finali, se affrontare un progetto con un compagno di classe o due compagni di classe, vi renderete conto che si sta andando a devono, o vogliono, dividere il lavoro. 

E si sta andando a voler decidere in anticipo, che sta per fare che cosa, e in cui i pezzi? E non sarebbe bello se, per esempio, farsi carico di scrittura principale, fatto. E il tuo compagno di stanza, o il vostro Partner più in generale, si occupa di attuare la tosse. 

E questa divisione, questi pareti di astrazione, o strati di astrazione, se si, sono super potente, perché soprattutto per i più grandi, più programmi complessi e sistemi, permette a più persone di costruire le cose insieme, e in ultima analisi, cucire il loro lavoro insieme in questo modo. Ma, naturalmente, bisogno di risolvere ora la tosse. Dobbiamo dire tosse che, ehi, sai una cosa? Si sta andando ad avere bisogno di prendere un input-- quindi non vuoto, ma int e ora. Andiamo avanti e mettere in tosse il int. mi viene a zero. 

i è inferiore a quante volte. Ho detto tre prima. Ma non è quello che voglio. Io voglio tosse essere generalizzato a supportare qualsiasi numero di iterazioni. 

Così, in effetti, si tratta di n che voglio, qualunque sia l'utente mi dice. Ora, posso andare avanti e dire la tosse stampa. E non importa quale numero l'utente passa, Io iterare che molte volte. 

Così, alla fine della giornata, programma è identico. Ma notare tutte queste cose potrebbe anche essere in un altro file. Anzi, non so al momento come printf è implementato. 

Non so al momento come arrivare stringa, o ottenere int, float o ottenere sono implementati. E io non voglio vederli sul mio schermo. Così com'è, sto iniziando a concentrarsi su il mio programma, non quelle funzioni. 

E così, in effetti, non appena avviare factoring codice come questo fuori, potremmo anche spostare la tosse in un file separato? Qualcun altro potrebbe attuarlo. E voi e il vostro programma di diventare il molto bello, e molto leggibile, senza dubbio, in realtà quattro programma a riga proprio lì. 

Quindi cerchiamo di andare avanti ora e fare un ulteriore cambiamento. Si noti che il mio prototipo deve cambiare sulla parte superiore. Così mi permetta di risolvere che così Io non vengo sgridato. 

Fai la tosse, mi permetta di correre tosse volta di più, ancora facendo la stessa cosa. Ma ora, notare abbiamo un ingrediente per una versione finale. Sai cosa? Non voglio tossire solo, necessariamente. Voglio avere qualcosa di più generale. Allora sai cosa? Voglio farlo. Voglio avere, molto simile a Scratch fa, un blocco per esempio, ma non solo dire qualcosa di un po 'di numero di volte. Lo voglio dire una stringa molto specifico. E, di conseguenza, non lo faccio Lo voglio dire solo colpo di tosse. Lo voglio dire qualunque cosa stringa viene passato. 

Così notare, ho generalizzato questo modo che ora per esempio si sente come un buon nome per questo, come Scratch, prende due argomenti, a differenza di Scratch. Uno è una stringa. Uno è un int. 

E ho potuto passare. Ho solo un po 'come l'idea di dire la stringa prima, e poi quante volte successive. Void significa che ancora non restituisce nulla. Questi sono solo lato visivo effetti, come con [? Jordan,?] un effetto collaterale verbale di urlare. Lo fa ancora qualcosa di volte n, 0 fino a, ma non uguale a n. Questo significa che i tempi n totali. E poi basta stampare qualunque essa stringa è. Così ho davvero generalizzato questa riga di codice. Così ora, come faccio a implementare la funzione di tosse? 

Posso fare tosse vuoto. E posso ancora prendere nel modo in cui molte volte si desidera a tossire. Ma sai una cosa? Ora posso punt da dire. 

Posso chiamare dire con la parola tosse, passando n. E se voglio implementare anche, solo per divertimento, una funzione di starnuto, Posso starnuto un determinato numero di volte. E posso tenere il riutilizzo n, perché notare che m, in questo contesto e la portata esiste solo all'interno di questa funzione. 

E n in questo contesto solo esiste all'interno di questa funzione qui. Quindi torneremo a questi problemi di portata. E qui, sto solo andando a dire, Achoo, e poi n volte, punto e virgola. 

E ora, ho solo bisogno di prendere in prestito queste funzioni firme qui. Così tosse è corretta. starnuto Void è corretto ora. 

E ho ancora solo bisogno di dire. Quindi ho intenzione di dire, per esempio stringa s, int n, punto e virgola. Così ho Engineered over-the heck fuori di questo programma. 

E questo non lo fa necessariamente che questo è cosa si deve fare quando si scrive anche il più semplice dei programmi. Prendere qualcosa che è, ovviamente, molto semplice, molto breve, e ri-attuarlo utilizzando modo troppo codice. Ma vi si può vedere, e in ora guardare indietro a questi esempi, e realizzare, oh, questi sono i passi abbiamo preso a generalizzare in realtà, di fattore qualcosa, fino alla fine della giornata il mio codice è in realtà piuttosto ragionevole. Perché se voglio tosse tre volte poi starnutiscono tre volte, Sto semplicemente andando a rieseguire questo, programma di rendere la tosse, ed eseguire la tosse. E ho tre colpi di tosse e tre starnuti. 

E quindi questa è una base paradigma, se si vuole, per come potremmo fare per in realtà attuazione di un programma. Ma facciamo solo vedere ora che cosa si tratta abbiamo fatto tutto questo tempo, e ciò che alcuni dei pezzi finali sono alla base di questo semplice comando. Alla fine della giornata, abbiamo stato usando Clang come il nostro compilatore. Abbiamo scritto fonte codice, convertendolo via Clang in codice macchina. 

E abbiamo usato Fai solo per facilitare le nostre battute così che non abbiamo da ricordare quegli incantesimi di Clang stesso. Ma ciò che è fare effettivamente fare? E, a sua volta, ciò che è Clang effettivamente facendo? 

Si scopre, anche se abbiamo semplificato la discussione di oggi dicendo, si prende il codice sorgente, passarlo come ingresso a un compilatore, che vi dà uscita della macchina codice, risulta non c'è a pochi passi differenti dentro. E la compilazione sembra essere l'ombrello termine per tutta una serie di passaggi. Ma facciamo solo prendere in giro questo fuori molto velocemente. 

Si scopre che abbiamo fatto più cose ogni volta che eseguire un programma, o ogni volta che compilare un programma di oggi. Quindi pre-elaborazione si riferisce a Questa poi qualsiasi cosa in un programma C, come vedremo ancora e ancora, che inizia con questo simbolo cancelletto, o il simbolo hashtag qui, significa si tratta di una direttiva del preprocessore. Ciò significa che, in questo caso, hey del computer, fare qualcosa con questo file prima che realmente compila il mio codice. 

In questo caso, hash includono IS, in sostanza, il modo di C per dire, Ehi del computer, andare a prendere i contenuti di CS50.h e incollarli qui. Ehi del computer, andare a prendere il il contenuto della norma io.h, dovunque sia sulla disco rigido, incollarlo qui. Quindi, queste cose succedono prima durante la pre-elaborazione. 

E Clang fa tutto questo per noi. E lo fa così maledettamente veloce, non è necessario nemmeno vedere quattro cose distinte che accadono. Ma questo è il primo passo del genere. 

Cosa succede in realtà dopo? Bene, la prossima ufficiale passo è la compilazione. E si scopre che compilazione di un programma tecnicamente significa andare da il codice sorgente, la roba che abbiamo state scrivendo oggi, a qualcosa chiamato codice assembly, qualcosa che sembra un po 'diverso. 

E, infatti, possiamo vedere questa veloce reale. Mi permetta effettivamente andare nel mio IDE. Lasciami andare avanti e ciao.c aperta, che è il primo programma con cui ha cominciato oggi. E mi permetta di andare avanti e correre Clang a po 'diverso, Clang-s, hello.c, che in realtà è di andare a datemi un altro file hello.s. 

E probabilmente ci sarà mai ancora una volta vedere questo tipo di codice. Se si prende un livello più basso classe di sistemi come CS61, si vedrà molto di più di questo tipo di codice. Ma questo è il linguaggio assembly. Questo è X86 linguaggio assembly che la CPU che è sotteso CS50 IDE in realtà capisce. 

E criptico come fa guardare, si tratta di qualcosa il computer capisce abbastanza bene. Sub q, questa è una sottrazione. Ci sono movimenti. 

Ci sta chiamando delle funzioni qui, x oring, un movimento, un componente aggiuntivo, un pop, un ritorno. Quindi c'è un po 'di molto istruzioni di basso livello che le CPU capire che Ho accennato in precedenza. Questo è ciò che Intel Inside. 

Ci sono modelli di zeri e quelli che mappa a questi arcanamente formulata, ma un po 'ben di nome-, istruzioni, per così dire. Questo è ciò che succede quando si compila il codice. Si ottiene assemblaggio lingua fuori di esso, che indica il terzo passo è assemblare tale codice assemblaggio in, in ultima analisi, macchine zeri code-- e quelli, non le testo che abbiamo appena visto un momento fa. 

Quindi pre-trattamento non che trovano e sostituire, e poche altre cose. Compilazione prende la vostra fonte codice C, codice sorgente che abbiamo scritto, al montaggio codice che abbiamo appena guardò. Assemblaggio prende quell'assemblea codice a zero e uno che la CPU sarà davvero capire alla fine della giornata. E il collegamento è l'ultimo passo ciò accade per noi-- di nuovo, così in fretta, non facciamo nemmeno notice-- che dice, Hey, adottare tutti gli zeri e quelli che il risultato di compilazione del codice di David, e la sua funzione principale in questo caso. 

E hey del computer, andare a prendere tutti gli zeri e che il personale ha scritto CS50 all'interno della libreria CS50. Mescolare quelli con il David di. E hey del computer, andare a prendere tutti gli zeri e quelli che qualcun altro ha scritto anni fa per printf. E aggiungere quelli in tutto, in modo che abbiamo ha ottenuto i miei zero e uno, il zero e uno del personale CS50, gli zeri printf e quelli, e qualsiasi altra cosa che stiamo usando. 

Tutti vengono combinati insieme in un unico programma chiamato, in questo caso, ciao. Quindi d'ora in poi, ci sarà solo usare la parola compilazione. E noi dare per scontato che quando diciamo, compilare il proprio programma, significa, hey fare il pre-processing, l'assemblaggio, e il collegamento. Ma c'è in realtà un po 'di roba succosa succedendo lì sotto la cappa. E soprattutto se si ottenere curioso po 'di tempo, si può iniziare a frugare intorno a questo livello più basso. Ma per ora, rendersi conto che tra i takeaway per oggi sono semplicemente la inizio di un processo, di prendere confidenza con qualcosa di simile ciao mondo. In effetti, la maggior parte di quello che abbiamo fatto oggi di certo non andranno affondare in super veloce. E ci vorrà un po 'di tempo, e una certa pratica. E le probabilità sono, si ordinerà di voler colpire la tastiera o urlare verso lo schermo. E tutto questo è OK. Anche se, forse, cercare di non farlo nella biblioteca così tanto. 

E alla fine, ti essere in grado, però, di avviare vedere modelli, sia in buono codice che hai scritto e in errori che hai fatto. E molto simile al processo di diventando una TF o di una CA è come, inizierete a ottenere una migliore e meglio a vedere quei modelli, e solo risolvere il vostro problemi in definitiva. Nel frattempo, ci sarà abbondanza di noi a dare un supporto, e farti attraverso questo. E nelle rivalutazioni per tutti i problemi si sarà guidati attraverso tutti i comandi che certamente so da un sacco di pratica, ormai, ma potrebbe aver volato sopra la testa, per ora. E questo è tutto bene. 

Ma, in ultima analisi, si sta andando per iniziare a vedere i modelli emergere. E una volta passato tutto il stupidi dettagli, come parentesi, e parentesi graffe, e punti e virgola, e la roba, francamente, che non è affatto intellettualmente interessante. E non è l'obiettivo di prendere qualsiasi corso introduttivo. Sono le idee che stanno alla materia. 

È loop, e le condizioni, e le funzioni, e più potentemente l'astrazione, e il factoring di codice, e il buon design, e il buon stile, e in ultima analisi, la correttezza del codice, che è in ultima analisi, andando a contano di più. Così la prossima settimana, ci vorrà questi idee che abbiamo visto la prima volta in Scratch e sono ora tradotti a C. E cominceremo per introdurre il primo della i domini del mondo reale del corso. 

Ci concentriamo sul mondo della sicurezza, e più specificamente crittografia, l'arte di scrambling informazioni. E tra i primi problemi Tu stesso si arriva a scrivere oltre giocando con alcuni dei sintassi e risolvere alcuni logico problemi, in ultima analisi, in breve tempo, è quello di arrampicarsi in realtà, o cifrare, e, infine, decifrare le informazioni. E tutto quello che abbiamo fatto oggi, sarà piuttosto bassa livello, è solo andare a permettere noi a prendere uno, e uno, e un altro passo verso sopra scrivere ancora il codice più interessante. 

Quindi, più che la prossima settimana. 

[RIPRODUZIONE VIDEO] 

-Cosa Mi puoi raccontare l'ultima volta che l'hai visto? -Cosa Posso dire, davvero? Voglio dire, era come qualsiasi altro le prove di pre-produzione, tranne che c'era qualcosa che ha detto proprio alla fine che mi è rimasta. 

-Questo Era CS50. 

-Che È un taglio a tutti, grande lavoro su prove. 

pranzo di -Che? 

Si ', voi ed io possiamo prendere un panino in un po '. Vorrei solo debriefing con David molto velocemente. David? David? 

[FINE RIPRODUZIONE] 