1
00:00:00,000 --> 00:00:00,000

2
00:00:00,000 --> 00:00:00,000
[RIPRODUZIONE DI BRANI MUSICALI]

3
00:00:00,000 --> 00:00:13,950

4
00:00:13,950 --> 00:00:16,240
>> David J. MALAN: Va bene, questo è CS50.

5
00:00:16,240 --> 00:00:18,010
E questo è uno settimana.

6
00:00:18,010 --> 00:00:22,050
Così ricordare che l'ultima volta a settimana pari a zero,
ci siamo concentrati sul pensiero computazionale.

7
00:00:22,050 --> 00:00:25,440
E noi la transizione da quello a
Scratch, una programmazione grafica

8
00:00:25,440 --> 00:00:27,360
lingua da parte dei nostri amici
al Media Lab del MIT.

9
00:00:27,360 --> 00:00:31,730
>> E con Scratch, abbiamo esplorare
idee come funzioni e le condizioni,

10
00:00:31,730 --> 00:00:35,210
e loop, e variabili, e anche
eventi e discussioni, e altro ancora.

11
00:00:35,210 --> 00:00:37,880
E oggi, stiamo andando a
continuare a usare quelle idee,

12
00:00:37,880 --> 00:00:40,630
e davvero li prendere per
scontato, ma tradurli

13
00:00:40,630 --> 00:00:44,220
in un'altra lingua conosciuta come C. Ora,
C è un linguaggio più tradizionale.

14
00:00:44,220 --> 00:00:46,020
Si tratta di un livello più basso
lingua, se si vuole.

15
00:00:46,020 --> 00:00:47,300
>> E 'puramente testuale.

16
00:00:47,300 --> 00:00:49,910
E così, a prima vista, è
tutto andando a guardare piuttosto criptico

17
00:00:49,910 --> 00:00:51,430
se non hai mai programmato prima.

18
00:00:51,430 --> 00:00:53,530
Stiamo per avere
punto e virgola, e parentesi,

19
00:00:53,530 --> 00:00:55,150
e parentesi graffe, e altro ancora.

20
00:00:55,150 --> 00:00:57,240
Ma rendersi conto che anche
anche se la sintassi è

21
00:00:57,240 --> 00:01:00,600
per guardare un po 'sconosciuto
per la maggior parte di voi, vedere oltre quello.

22
00:01:00,600 --> 00:01:03,220
E cercare di vedere le idee
che sono, infatti, familiare,

23
00:01:03,220 --> 00:01:06,750
perché qui in settimana una cosa
inizieremo a fare è quello di confrontare,

24
00:01:06,750 --> 00:01:08,980
Inizialmente, Scratch contro C.

25
00:01:08,980 --> 00:01:12,350
>> Così, per esempio, ricordare che quando
implementato il primo dei nostri programmi

26
00:01:12,350 --> 00:01:16,220
l'ultima volta, abbiamo avuto un blocco che sembrava
un po 'di qualcosa come questo-- quando

27
00:01:16,220 --> 00:01:19,990
bandiera verde cliccato, e poi abbiamo avuto
uno o più pezzi del puzzle sotto di essa,

28
00:01:19,990 --> 00:01:22,150
in questo caso, dire, ciao mondo.

29
00:01:22,150 --> 00:01:24,870
Così, infatti, in Scratch,
quando si sceglie quella bandiera verde

30
00:01:24,870 --> 00:01:27,390
per eseguire il mio programma, in modo da
parlare, questi sono

31
00:01:27,390 --> 00:01:29,520
i blocchi che vengono eseguiti o eseguiti.

32
00:01:29,520 --> 00:01:32,230
E, in particolare, Scratch
detto, ciao, mondo.

33
00:01:32,230 --> 00:01:35,377
>> Ora, avrei potuto specificato
parole diverse qui.

34
00:01:35,377 --> 00:01:37,960
Ma vedremo che, in effetti, molti
di questi blocks-- e in effetti,

35
00:01:37,960 --> 00:01:41,880
in C molti functions-- possono essere
parametrizzate o personalizzato

36
00:01:41,880 --> 00:01:43,150
di fare cose diverse.

37
00:01:43,150 --> 00:01:45,520
Infatti, in C se
desidera convertire, ora,

38
00:01:45,520 --> 00:01:47,567
questo programma Scratch
a tale lingua,

39
00:01:47,567 --> 00:01:49,650
stiamo andando a dare una
po 'di qualcosa di simile.

40
00:01:49,650 --> 00:01:52,540
>> Certo, vi è una certa familiarità
sintassi lì molto probabilmente, int,

41
00:01:52,540 --> 00:01:54,380
e tra parentesi, e vuoto.

42
00:01:54,380 --> 00:01:57,740
Ma printf-- anche se si farebbe
penso che sarebbe solo di stampa.

43
00:01:57,740 --> 00:02:00,120
Ma stampa significa stampa
formattato, come vedremo tra poco.

44
00:02:00,120 --> 00:02:02,140
Questo letteralmente stamperà
alla schermata qualunque

45
00:02:02,140 --> 00:02:05,990
è all'interno di quelle parentesi, che
Naturalmente in questo caso è, ciao mondo.

46
00:02:05,990 --> 00:02:09,290
>> Ma si noterà qualche altro
sintassi, alcuni doppi apici,

47
00:02:09,290 --> 00:02:11,890
che le parentesi alla fine,
il semi-colon e simili.

48
00:02:11,890 --> 00:02:15,027
Quindi c'è un po 'di testa,
per così dire, sia cognitivamente

49
00:02:15,027 --> 00:02:17,860
e sintatticamente, che stiamo andando
di dover ricordare in breve tempo.

50
00:02:17,860 --> 00:02:20,720
Ma rendersi conto che con la pratica,
questo inizierà a saltare fuori di te.

51
00:02:20,720 --> 00:02:24,920
>> In effetti, concentriamoci su quello
Funzione specifically-- in questo caso,

52
00:02:24,920 --> 00:02:26,290
dire ciao mondo.

53
00:02:26,290 --> 00:02:27,560
Quindi dire che è la funzione.

54
00:02:27,560 --> 00:02:31,320
Ciao mondo è il suo parametro,
o argomento, la sua personalizzazione.

55
00:02:31,320 --> 00:02:34,320
>> E l'equivalenza in C è solo
sta per essere presente una riga qui,

56
00:02:34,320 --> 00:02:38,710
dove printf è equivalente a, diciamo,
la stringa doppia citato, ciao

57
00:02:38,710 --> 00:02:41,470
mondo è equivalente, naturalmente,
a ciò che è nel riquadro bianco lì.

58
00:02:41,470 --> 00:02:45,680
E il backslash n, anche se un po '
strano e assente da zero,

59
00:02:45,680 --> 00:02:49,380
semplicemente sta per avere l'effetto faremo
vedere in un computer, come il mio Mac o un PC,

60
00:02:49,380 --> 00:02:51,660
di appena spostare il
cursore alla riga successiva.

61
00:02:51,660 --> 00:02:53,970
E 'come colpire
Invio sulla tastiera.

62
00:02:53,970 --> 00:02:55,580
>> Così vedremo di nuovo in poco tempo.

63
00:02:55,580 --> 00:02:58,640
Ma prima, diamo uno sguardo a questo
altro esempio nel caso di loop.

64
00:02:58,640 --> 00:03:02,830
Abbiamo avuto questo per sempre anello ultima volta,
che era una serie di pezzi del puzzle

65
00:03:02,830 --> 00:03:05,490
che ha fatto qualcosa di letteralmente
forever-- in questo caso,

66
00:03:05,490 --> 00:03:08,360
dire ciao mondo, ciao mondo,
Ciao mondo, ciao mondo.

67
00:03:08,360 --> 00:03:10,350
Quindi è un ciclo infinito di progettazione.

68
00:03:10,350 --> 00:03:14,580
>> In C, se vogliamo attuare questa
stessa idea, si potrebbe semplicemente fare questo.

69
00:03:14,580 --> 00:03:19,570
Mentre vero, printf ciao world-- ora
mentre, solo semanticamente, tipo di

70
00:03:19,570 --> 00:03:23,090
evoca l'idea di fare
qualcosa di nuovo, e ancora, e ancora,

71
00:03:23,090 --> 00:03:23,980
e per quanto tempo?

72
00:03:23,980 --> 00:03:27,990
Beh, ricordo che true--
vero è solo su uno o.

73
00:03:27,990 --> 00:03:30,660
>> E vero è, ovviamente, sempre vero.

74
00:03:30,660 --> 00:03:33,060
Quindi è una specie di un insignificante
dichiarazione solo per dire vero.

75
00:03:33,060 --> 00:03:36,890
Ma in effetti, questo è intenzionale,
perché se è vero è proprio sempre vero,

76
00:03:36,890 --> 00:03:40,850
che mentre vero implica solo,
se un po indirettamente,

77
00:03:40,850 --> 00:03:44,070
che le seguenti righe di codice
tra questi parentesi graffe

78
00:03:44,070 --> 00:03:48,320
deve solo eseguire di nuovo, e di nuovo,
e ancora, e in realtà mai smettere.

79
00:03:48,320 --> 00:03:50,230
>> Ma se volete che il vostro
ciclo di fermarsi, come noi

80
00:03:50,230 --> 00:03:54,500
fatto l'ultima volta con qualcosa di simile
questo, ripetere i seguenti 50 volte,

81
00:03:54,500 --> 00:03:57,700
in C siamo in grado di fare lo stesso con ciò che è
chiamato per loop-- la parola chiave

82
00:03:57,700 --> 00:03:59,330
non essendo mentre, ma per.

83
00:03:59,330 --> 00:04:03,290
E poi abbiamo un po 'di nuova sintassi qui,
con int i è uguale a 0, i meno di 50,

84
00:04:03,290 --> 00:04:03,880
i ++.

85
00:04:03,880 --> 00:04:05,430
E ci torneremo a questo.

86
00:04:05,430 --> 00:04:09,660
Ma questo è semplicemente il modo in cui sarebbe
tradurre l'insieme di blocchi Scratch

87
00:04:09,660 --> 00:04:13,079
ad un insieme di linee di codice C.

88
00:04:13,079 --> 00:04:14,450
>> Nel frattempo, in considerazione variabili.

89
00:04:14,450 --> 00:04:16,540
E, infatti, abbiamo appena
visto uno un attimo fa.

90
00:04:16,540 --> 00:04:21,220
E nel caso di Scratch, se
ha voluto dichiarare una variabile denominata i

91
00:04:21,220 --> 00:04:24,590
per i essendo intero, solo un numero,
e vogliamo impostarlo su un certo valore,

92
00:04:24,590 --> 00:04:28,410
useremmo questo arancione
bloccare qui-- ho impostato a 0.

93
00:04:28,410 --> 00:04:30,800
>> E vedremo oggi e
al di là, proprio come la settimana scorsa,

94
00:04:30,800 --> 00:04:33,850
i programmatori fanno quasi sempre
iniziare a contare da zero, davvero

95
00:04:33,850 --> 00:04:34,950
per convenzione.

96
00:04:34,950 --> 00:04:37,250
Ma anche perché il richiamo da
la nostra discussione di binario,

97
00:04:37,250 --> 00:04:39,990
il minor numero possibile
rappresentare qualsiasi numero di bit

98
00:04:39,990 --> 00:04:41,640
è solo andare a essere 0 se stesso.

99
00:04:41,640 --> 00:04:45,190
E così faremo in genere inizia
inizializzazione anche le nostre variabili a 0.

100
00:04:45,190 --> 00:04:47,710
>> E in C a fare lo stesso,
stiamo andando a dire int

101
00:04:47,710 --> 00:04:50,110
per intero, ho solo per convenzione.

102
00:04:50,110 --> 00:04:53,390
Avrei potuto chiamare questa variabile
tutto quello che voglio, proprio come in Scratch.

103
00:04:53,390 --> 00:04:57,770
E poi è uguale a 0 solo cessionari
il valore 0 da destra

104
00:04:57,770 --> 00:05:01,319
e lo mette nella variabile, o
contenitore lì, sulla sinistra.

105
00:05:01,319 --> 00:05:04,360
E il punto e virgola come vedremo see-- e
abbiamo visto alcuni di questi already--

106
00:05:04,360 --> 00:05:06,530
significa solo fine di pensiero.

107
00:05:06,530 --> 00:05:09,430
Procedere a fare qualcosa di diverso
sulle linee che seguono.

108
00:05:09,430 --> 00:05:11,330
>> Ora, per quanto riguarda le espressioni booleane?

109
00:05:11,330 --> 00:05:14,320
Ricordiamo che in Scratch,
queste erano espressioni

110
00:05:14,320 --> 00:05:16,740
che sono o vere
o domande false--,

111
00:05:16,740 --> 00:05:18,910
in realtà, che sono o vere o false.

112
00:05:18,910 --> 00:05:21,960
Quindi, nel caso di Scratch, potremmo
fare una semplice domanda come questa,

113
00:05:21,960 --> 00:05:24,586
Sono io meno di 50?

114
00:05:24,586 --> 00:05:25,710
Così ho, ancora una volta, è un numero intero.

115
00:05:25,710 --> 00:05:27,210
Forse stiamo usando
in un programma Scratch

116
00:05:27,210 --> 00:05:29,310
per tenere traccia di un punteggio
o qualcosa di simile.

117
00:05:29,310 --> 00:05:33,810
Quindi, questa sintassi qui a Scratch
significa semplicemente, è che a meno di 50?

118
00:05:33,810 --> 00:05:37,330
Beh, per fortuna, qualcosa è
semplice in C. E da tradurre,

119
00:05:37,330 --> 00:05:41,780
questo si sarebbe semplicemente dire che sono meno
di 50, utilizzando la chiave familiare

120
00:05:41,780 --> 00:05:42,850
sulla tastiera.

121
00:05:42,850 --> 00:05:45,141
>> Nel frattempo, se si voleva
dire qualcosa di più generale,

122
00:05:45,141 --> 00:05:49,890
come, beh, è ​​x meno y dove ogni
di X e Y sono variabili se stessi?

123
00:05:49,890 --> 00:05:52,280
Siamo in grado di fare la stessa cosa
in C, fino a quando abbiamo

124
00:05:52,280 --> 00:05:53,942
creato queste variabili già.

125
00:05:53,942 --> 00:05:55,650
E vedremo come
farlo in breve tempo.

126
00:05:55,650 --> 00:05:58,590
Vorremmo semplicemente dire x meno y.

127
00:05:58,590 --> 00:06:00,530
>> Quindi, si sta iniziando a
vedere alcune somiglianze.

128
00:06:00,530 --> 00:06:03,490
E quelle persone che hanno fatto
Scratch erano certamente

129
00:06:03,490 --> 00:06:05,250
ispirato da alcune di queste idee di base.

130
00:06:05,250 --> 00:06:10,350
E vedrete questo tipo di
sintassi in molti languages--

131
00:06:10,350 --> 00:06:12,160
non solo graffio, non
solo C, ma Python,

132
00:06:12,160 --> 00:06:14,790
e JavaScript, e
altre lingue ancora.

133
00:06:14,790 --> 00:06:18,270
>> Prendiamo in considerazione un altro costrutto
da C, il concetto di una condizione,

134
00:06:18,270 --> 00:06:20,370
fare qualcosa condizionale.

135
00:06:20,370 --> 00:06:22,720
Se qualcosa è vero, fare questo.

136
00:06:22,720 --> 00:06:24,457
Se qualcosa è vero, farlo.

137
00:06:24,457 --> 00:06:27,040
È una specie di programmazione
equivalente di un bivio.

138
00:06:27,040 --> 00:06:29,730
Forse è una forchetta a due vie,
a tre vie forcella, o più.

139
00:06:29,730 --> 00:06:32,800
E in Scratch, potremmo avere
visto qualcosa di simile.

140
00:06:32,800 --> 00:06:34,010
>> Quindi questo è un grande.

141
00:06:34,010 --> 00:06:36,750
Ma prendere in considerazione la relativa
semplicità della logica.

142
00:06:36,750 --> 00:06:44,010
Se x è minore di y, allora dire che x è meno
di y, altrimenti se x è maggiore di y,

143
00:06:44,010 --> 00:06:46,230
poi dicono x è maggiore di y.

144
00:06:46,230 --> 00:06:48,300
E poi, logicamente, se
si ripensa a Scratch

145
00:06:48,300 --> 00:06:52,610
o semplicemente il proprio intuito umano,
bene, se x non è maggiore di y, e x

146
00:06:52,610 --> 00:06:57,000
non è minore di y, allora naturalmente
x sta per essere uguale a y.

147
00:06:57,000 --> 00:06:59,690
Quindi in questo caso, per nesting
quei blocchi Scratch,

148
00:06:59,690 --> 00:07:02,580
possiamo raggiungere tre
modo bivio?

149
00:07:02,580 --> 00:07:04,980
>> Nel frattempo, se vogliamo
farlo in C, probabilmente

150
00:07:04,980 --> 00:07:08,420
sembra un po 'simpler-- almeno
Una volta acquisita familiarità con la sintassi.

151
00:07:08,420 --> 00:07:12,050
Se x è minore di y,
printf x è minore di y.

152
00:07:12,050 --> 00:07:16,140
Altrimenti, se x è maggiore di y,
printf x è maggiore di y.

153
00:07:16,140 --> 00:07:21,210
Else printf x è uguale a y-- e,
ancora una volta, con quelli backslash finisce proprio

154
00:07:21,210 --> 00:07:24,160
per quelle nuove linee in modo che se si
in realtà correva questo tipo di programma

155
00:07:24,160 --> 00:07:25,940
sarebbe solo spostare
il cursore in ultima analisi,

156
00:07:25,940 --> 00:07:28,100
alla riga successiva della schermata.

157
00:07:28,100 --> 00:07:31,270
>> Ora, nel frattempo Scratch aveva altra
funzioni più sofisticate, solo

158
00:07:31,270 --> 00:07:34,320
alcuni dei quali andremo a
inizialmente passare al mondo di C.

159
00:07:34,320 --> 00:07:37,010
E uno di loro era
chiamato una lista in Scratch.

160
00:07:37,010 --> 00:07:39,100
E questa era una speciale
tipo di variabile che

161
00:07:39,100 --> 00:07:42,840
ha permesso di memorizzare più cose
in indietro, alla parte posteriore, alla schiena, alla parte posteriore.

162
00:07:42,840 --> 00:07:45,540
>> In C, non ha
liste, di per sé, ma qualcosa

163
00:07:45,540 --> 00:07:48,090
che sono più generalmente
chiamato array, anche se ti

164
00:07:48,090 --> 00:07:50,590
tornare più tardi questo semestre
a guardare qualcosa

165
00:07:50,590 --> 00:07:52,780
chiamato una lista, o realmente una lista collegata.

166
00:07:52,780 --> 00:07:55,510
Ma per ora, la più vicina
equivalente in C per noi

167
00:07:55,510 --> 00:07:57,345
sta per essere qualcosa
chiamato un array.

168
00:07:57,345 --> 00:07:59,740
E un array è semplicemente un
speciale tipo di variabile

169
00:07:59,740 --> 00:08:03,160
che consente di memorizzare i dati
indietro, alla parte posteriore, alla schiena, alla schiena.

170
00:08:03,160 --> 00:08:05,840
>> E, in effetti, in Scratch,
se volessimo accedere

171
00:08:05,840 --> 00:08:09,030
il primo elemento di un array o
un list-- e ho intenzione di chiamarlo,

172
00:08:09,030 --> 00:08:13,600
per convenzione, argv, argomento
vettore, ma più su che tra non molto.

173
00:08:13,600 --> 00:08:17,090
Se voglio arrivare al primo elemento
di argv, nel mondo di Scratch

174
00:08:17,090 --> 00:08:20,930
effettivamente fare tipicamente
iniziare il conteggio da 1.

175
00:08:20,930 --> 00:08:22,850
>> E così potrei ottenere punto 1 di argv.

176
00:08:22,850 --> 00:08:26,310
Questo è solo il modo MIT implementato
la nozione di liste.

177
00:08:26,310 --> 00:08:29,860
Ma in C, ho intenzione di
più semplicemente solo dire, argv,

178
00:08:29,860 --> 00:08:32,758
che ancora una volta è il nome del mio
list-- o per essere chiari, un array.

179
00:08:32,758 --> 00:08:34,549
E se voglio la prima
Elementi, sto andando

180
00:08:34,549 --> 00:08:37,890
per usare le parentesi quadre, che si
potrebbe non spesso usato sotto una tastiera.

181
00:08:37,890 --> 00:08:40,150
>> Ma 0 significa solo, mi ottenere il primo.

182
00:08:40,150 --> 00:08:42,160
Quindi, in occasione e come
il tempo passa, stiamo andando

183
00:08:42,160 --> 00:08:44,570
per iniziare a vedere queste dicotomie
tra il Gratta e C,

184
00:08:44,570 --> 00:08:46,070
per cui Scratch utilizza uno.

185
00:08:46,070 --> 00:08:47,670
Siamo in C 0 per questo.

186
00:08:47,670 --> 00:08:49,420
Ma vedrete rapidamente
una volta capito

187
00:08:49,420 --> 00:08:52,920
le fondamenta di ogni lingua, che
queste cose cominciano a farsi sempre più

188
00:08:52,920 --> 00:08:56,860
familiare attraverso la pratica e la pratica.

189
00:08:56,860 --> 00:08:59,700
>> Quindi cerchiamo di guardare in realtà ora ad un programma.

190
00:08:59,700 --> 00:09:04,031
Qui sarà il primo della nostra C
codice sorgente di programmi completi.

191
00:09:04,031 --> 00:09:06,280
E il programma stiamo andando
di offrire a titolo oneroso

192
00:09:06,280 --> 00:09:09,340
è quello che è equivalente
a quel pezzo Scratch in precedenza.

193
00:09:09,340 --> 00:09:13,210
>> Così qui, abbiamo ciò che è
probabilmente il più semplice programma in C

194
00:09:13,210 --> 00:09:15,410
si può scrivere che
in realtà fa qualcosa.

195
00:09:15,410 --> 00:09:18,250
Ora, vedremo passato,
per ora, è comprendere,

196
00:09:18,250 --> 00:09:21,190
io.h di serie, e questi l'angolo
staffe, e int, e vuoto,

197
00:09:21,190 --> 00:09:22,840
e le parentesi graffe, e simili.

198
00:09:22,840 --> 00:09:25,390
>> E facciamo solo concentrarsi su
ciò, almeno intuitivamente,

199
00:09:25,390 --> 00:09:26,860
potrebbe saltare fuori a voi già.

200
00:09:26,860 --> 00:09:30,300
In realtà, principale, non lo faccio
necessariamente sapere di cosa si tratta,

201
00:09:30,300 --> 00:09:34,580
ma molto simile a Scratch avevano che quando
bandiera verde cliccato pezzo di puzzle,

202
00:09:34,580 --> 00:09:39,070
così fa C come linguaggio di programmazione
avere un pezzo principale di codice che

203
00:09:39,070 --> 00:09:43,380
viene eseguito per impostazione predefinita. E senza dubbio,
è letteralmente sta per essere chiamato principale.

204
00:09:43,380 --> 00:09:44,720
>> Così principale è una funzione.

205
00:09:44,720 --> 00:09:48,720
Ed è una funzione speciale che esiste
in C che quando si esegue un programma,

206
00:09:48,720 --> 00:09:52,720
è principale che viene gestito da
predefinito. Nel mondo di Scratch,

207
00:09:52,720 --> 00:09:56,970
era solito quando bandiera verde
cliccato che ha ottenuto eseguito per impostazione predefinita.

208
00:09:56,970 --> 00:10:01,130
>> Nel frattempo, abbiamo visto prima,
printf o stampare in formato, che è

209
00:10:01,130 --> 00:10:05,620
sarà una funzione che viene con
C, insieme a tutta una serie di altri,

210
00:10:05,620 --> 00:10:10,140
che la volontà da tempo e il tempo
di nuovo, al fine di fare esattamente

211
00:10:10,140 --> 00:10:12,450
come suggerisce il nome, stampare qualcosa.

212
00:10:12,450 --> 00:10:13,500
Cosa vogliamo stampare?

213
00:10:13,500 --> 00:10:15,770
Bene, vedremo che
da personaggi che racchiudono

214
00:10:15,770 --> 00:10:18,680
come these-- mondo ciao,
backslash n tra virgolette,

215
00:10:18,680 --> 00:10:23,040
possiamo dire esattamente printf
quello di stampare sullo schermo.

216
00:10:23,040 --> 00:10:26,430
>> Ma per fare
che, purtroppo

217
00:10:26,430 --> 00:10:30,010
bisogno di prendere qualcosa che è
già criptico per noi esseri umani,

218
00:10:30,010 --> 00:10:34,510
ma almeno è un po 'readable--
affilato includono, di serie io.h, int,

219
00:10:34,510 --> 00:10:39,340
principale, vuoto, printf, tutta la magica
incantesimi che abbiamo appena visto sullo schermo.

220
00:10:39,340 --> 00:10:42,470
Ma in realtà abbiamo a
andare più arcana ancora.

221
00:10:42,470 --> 00:10:47,140
In primo luogo abbiamo bisogno di tradurre il codice
che scriviamo in codice macchina.

222
00:10:47,140 --> 00:10:51,370
E ricordare della settimana scorsa che le macchine,
almeno quelli che conosciamo qui,

223
00:10:51,370 --> 00:10:54,450
alla fine della giornata solo
comprendere zero e uno.

224
00:10:54,450 --> 00:10:58,100
>> E il mio Dio, se abbiamo dovuto scrivere questi
zero e uno in realtà il programma,

225
00:10:58,100 --> 00:11:01,260
sarebbe molto, molto rapidamente
togliere il divertimento di qualsiasi cosa.

226
00:11:01,260 --> 00:11:05,150
Ma si scopre, per la settimana scorsa,
che questi schemi di zero e uno

227
00:11:05,150 --> 00:11:06,400
appena hanno un significato speciale.

228
00:11:06,400 --> 00:11:08,500
In alcuni contesti,
potrebbero significare numeri.

229
00:11:08,500 --> 00:11:11,840
>> In alcuni contesti, che potrebbero significare
lettere, o colori, o un qualsiasi numero

230
00:11:11,840 --> 00:11:14,710
di altre astrazioni lì sopra.

231
00:11:14,710 --> 00:11:18,450
Ma proprio come il computer ha
una CPU, Central Processing Unit,

232
00:11:18,450 --> 00:11:20,390
o il cervello all'interno del computer.

233
00:11:20,390 --> 00:11:22,240
Di solito Intel
dentro, perché è

234
00:11:22,240 --> 00:11:24,900
una delle più grandi aziende
che rende le CPU per i computer.

235
00:11:24,900 --> 00:11:28,910
>> Beh, le CPU Intel e gli altri
semplicemente hanno deciso in anticipo

236
00:11:28,910 --> 00:11:33,970
che alcuni modelli di zeri e
quelli si intendono cose specifiche.

237
00:11:33,970 --> 00:11:37,040
Alcuni modelli di zero e uno
significherà, stampare questa sullo schermo,

238
00:11:37,040 --> 00:11:39,710
o aggiungere questi due numeri, o
sottrarre questi due numeri,

239
00:11:39,710 --> 00:11:43,310
o spostare questo pezzo di dati da
la memoria del mio computer qui,

240
00:11:43,310 --> 00:11:47,870
o un qualsiasi numero di altri livelli molto bassi,
ma alla fine utile, le operazioni.

241
00:11:47,870 --> 00:11:53,022
Ma, per fortuna, noi esseri umani non stanno andando
ad avere bisogno di conoscere questo livello di dettaglio.

242
00:11:53,022 --> 00:11:56,230
Infatti, proprio come l'ultima volta, dove abbiamo
Sottratto ancora, e ancora, e ancora,

243
00:11:56,230 --> 00:11:58,930
edificio da un livello molto basso
primitive come zero e uno

244
00:11:58,930 --> 00:12:01,160
ai concetti di livello superiore
come i numeri e lettere,

245
00:12:01,160 --> 00:12:04,330
e colori, e di più,
in modo che possiamo come programmatori

246
00:12:04,330 --> 00:12:07,080
stare in piedi sulle spalle di
altri che sono venuti prima di noi

247
00:12:07,080 --> 00:12:11,260
e usare il software che altro
persone hanno scritto prima noi--

248
00:12:11,260 --> 00:12:14,340
vale a dire i programmi chiamati compilatori.

249
00:12:14,340 --> 00:12:17,770
>> C è un linguaggio che
di solito è compilato,

250
00:12:17,770 --> 00:12:22,130
che significa convertito da
codice sorgente in codice macchina.

251
00:12:22,130 --> 00:12:25,230
In particolare, ciò che questo significa
è che se hai la tua fonte

252
00:12:25,230 --> 00:12:29,530
codice che si scrive da soli, come abbiamo appena
sarà in un momento sullo schermo,

253
00:12:29,530 --> 00:12:33,140
e volete convertirlo
in ultima analisi, di lavorare code--

254
00:12:33,140 --> 00:12:37,100
tali zeri e quelli che
solo il vostro Mac o PC

255
00:12:37,100 --> 00:12:41,230
understands-- hai una prima
alimentare che il codice sorgente come

256
00:12:41,230 --> 00:12:46,340
ingresso ad una speciale
programma chiamato compilatore,

257
00:12:46,340 --> 00:12:48,974
la cui uscita si
deve vedere è codice macchina.

258
00:12:48,974 --> 00:12:51,890
E, in effetti, l'ultima volta che abbiamo parlato
merito, davvero, alla fine della giornata,

259
00:12:51,890 --> 00:12:52,610
problem solving.

260
00:12:52,610 --> 00:12:53,360
Hai ingressi.

261
00:12:53,360 --> 00:12:54,318
E hai uscite.

262
00:12:54,318 --> 00:12:56,560
E hai qualche tipo
dell'algoritmo nel mezzo.

263
00:12:56,560 --> 00:12:59,830
>> Gli algoritmi possono essere sicuramente
implementato nel software,

264
00:12:59,830 --> 00:13:02,900
come abbiamo visto con pseudocodice la scorsa settimana
e come vedremo con codice vero e proprio

265
00:13:02,900 --> 00:13:03,490
questa settimana.

266
00:13:03,490 --> 00:13:06,430
E così un compilatore in realtà solo
ha una serie di algoritmi all'interno

267
00:13:06,430 --> 00:13:10,060
di esso che sanno
convertire le parole chiave speciali,

268
00:13:10,060 --> 00:13:12,180
come principale, e printf,
e altri che abbiamo appena

269
00:13:12,180 --> 00:13:17,620
ha visto negli schemi di zeri e
quelli che Intel Inside e altre CPU

270
00:13:17,620 --> 00:13:20,020
in realtà capisce.

271
00:13:20,020 --> 00:13:22,460
Quindi, come facciamo questo?

272
00:13:22,460 --> 00:13:24,470
Dove possiamo ottenere un compilatore?

273
00:13:24,470 --> 00:13:26,400
>> La maggior parte di noi qui hanno un Mac o un PC.

274
00:13:26,400 --> 00:13:29,152
E si sta eseguendo Mac OS, o
Windows o Linux, o Solaris,

275
00:13:29,152 --> 00:13:30,860
o un qualsiasi numero di altri
sistemi operativi.

276
00:13:30,860 --> 00:13:32,568
E, in effetti, si potrebbe
uscire sul web

277
00:13:32,568 --> 00:13:35,710
e scaricare un compilatore
per il vostro Mac o PC

278
00:13:35,710 --> 00:13:37,360
per il sistema operativo.

279
00:13:37,360 --> 00:13:39,617
Ma saremmo tutti su
diverse pagine, per così dire.

280
00:13:39,617 --> 00:13:41,450
Avremmo un po '
diverse configurazioni.

281
00:13:41,450 --> 00:13:43,210
E le cose non avrebbero funzionato lo stesso.

282
00:13:43,210 --> 00:13:45,280
E, in effetti, in questi giorni
molti di noi non utilizzare

283
00:13:45,280 --> 00:13:47,516
un software che gira solo su i nostri computer portatili.

284
00:13:47,516 --> 00:13:49,390
Invece, usiamo qualcosa
come un browser

285
00:13:49,390 --> 00:13:52,930
ci permette di accesso basato sul Web
applicazioni nel cloud.

286
00:13:52,930 --> 00:13:55,630
E più tardi questo semestre,
faremo esattamente questo.

287
00:13:55,630 --> 00:13:59,660
Scriveremo applicazioni o
software utilizzando code-- non C,

288
00:13:59,660 --> 00:14:02,860
ma altri linguaggi come Python e
Javascript-- che funzionano in the cloud.

289
00:14:02,860 --> 00:14:05,860
>> E per farlo, noi stessi
durante il semestre

290
00:14:05,860 --> 00:14:11,890
effettivamente utilizzare una base di cloud
ambiente conosciuto come CS50 IDE.

291
00:14:11,890 --> 00:14:16,030
Questa è una programmazione web-based
ambiente, o di sviluppo integrato

292
00:14:16,030 --> 00:14:20,610
ambiente, IDE, che è costruito in cima ad un certo
software open source chiamato Cloud 9.

293
00:14:20,610 --> 00:14:22,966
E abbiamo fatto un po 'pedagogica
semplificazioni ad esso

294
00:14:22,966 --> 00:14:25,840
in modo da nascondere determinate caratteristiche in
le prime settimane che non abbiamo bisogno,

295
00:14:25,840 --> 00:14:27,770
dopo di che è possibile
rivelarli e fare la maggior parte

296
00:14:27,770 --> 00:14:29,400
tutto quello che vuoi con l'ambiente.

297
00:14:29,400 --> 00:14:32,470
>> E ci permette, anche, per
pre-installare determinati programmi.

298
00:14:32,470 --> 00:14:35,330
Cose come un cosiddetto CS50
biblioteca, che vedremo tra poco

299
00:14:35,330 --> 00:14:39,210
ci fornisce in C con un po '
funzionalità aggiuntive.

300
00:14:39,210 --> 00:14:44,392
Quindi, se si va a, in ultima analisi, CS50.io,
ti verrà richiesto di accedere,

301
00:14:44,392 --> 00:14:46,350
e una volta che fate e creare
un account gratuito,

302
00:14:46,350 --> 00:14:52,150
si sarà in grado di accedere ad un
ambiente che sembra abbastanza come questo.

303
00:14:52,150 --> 00:14:53,760
>> Ora, questo è nella modalità predefinita.

304
00:14:53,760 --> 00:14:55,650
Tutto è bello e
luminoso sullo schermo.

305
00:14:55,650 --> 00:14:57,941
Molti di noi hanno l'abitudine di
lavorando su un pezzo che è CS50

306
00:14:57,941 --> 00:14:59,150
piuttosto tardi nella notte.

307
00:14:59,150 --> 00:15:02,400
E così alcuni di voi potrebbero preferire di
trasformarlo in modalità notte, per così dire.

308
00:15:02,400 --> 00:15:05,550
>> Ma, in ultima analisi, ciò che sei
andando a vedere all'interno CS50 IDE

309
00:15:05,550 --> 00:15:08,340
è di tre distinti areas--
un'area sulla cui sinistra

310
00:15:08,340 --> 00:15:12,604
i file saranno nel
nuvola, una zona in alto a destra

311
00:15:12,604 --> 00:15:14,270
dove il codice sta per essere modificabile.

312
00:15:14,270 --> 00:15:16,650
Sarete in grado di aprire
le schede individuali per ogni programma

313
00:15:16,650 --> 00:15:19,670
che si scrive questo semestre all'interno
di quella in alto a destra.

314
00:15:19,670 --> 00:15:23,070
E poi più arcanamente,
e tuttavia potente,

315
00:15:23,070 --> 00:15:26,610
sta per essere questa cosa al
fondo noto come una finestra di terminale.

316
00:15:26,610 --> 00:15:29,450
>> Si tratta di una vecchia scuola
Command Line Interface,

317
00:15:29,450 --> 00:15:32,240
o CLI, che permette
di eseguire comandi

318
00:15:32,240 --> 00:15:35,260
sulla computer-- in questo caso,
il computer nel cloud--

319
00:15:35,260 --> 00:15:39,090
di fare cose come compilare il codice
dal codice sorgente in codice macchina,

320
00:15:39,090 --> 00:15:43,600
per eseguire i programmi, o per iniziare la
web server, o per accedere al database,

321
00:15:43,600 --> 00:15:47,454
e qualsiasi numero di altre tecniche
che inizieremo a usare in breve tempo.

322
00:15:47,454 --> 00:15:49,370
Ma per arrivarci, siamo
andando ad avere in realtà

323
00:15:49,370 --> 00:15:51,240
di andare online e iniziare a giocare.

324
00:15:51,240 --> 00:15:54,399
E per fare questo, si deve prima
iniziare ad armeggiare con principale,

325
00:15:54,399 --> 00:15:55,940
e scrivere la parte principale di un programma.

326
00:15:55,940 --> 00:15:59,170
E cerchiamo di usare quella funzione
printf, che abbiamo utilizzato in precedenza,

327
00:15:59,170 --> 00:16:01,050
semplicemente per dire qualcosa.

328
00:16:01,050 --> 00:16:04,910
>> Così eccomi qui già dentro di CS50 IDE.

329
00:16:04,910 --> 00:16:05,930
Ho effettuato l'accesso in anticipo.

330
00:16:05,930 --> 00:16:07,360
E ho piena proiettato alla finestra.

331
00:16:07,360 --> 00:16:09,670
E così, in ultima analisi, si
Anche in problemi derivanti

332
00:16:09,670 --> 00:16:12,960
seguirà una procedura simile che
fornirà la documentazione in linea.

333
00:16:12,960 --> 00:16:16,360
Quindi non c'è bisogno di preoccuparsi
assorbendo ogni piccolo passo tecnico

334
00:16:16,360 --> 00:16:17,730
che faccio qui oggi.

335
00:16:17,730 --> 00:16:19,222
>> Ma si otterrà una schermata come questa.

336
00:16:19,222 --> 00:16:20,430
Mi capita di essere in modalità notturna.

337
00:16:20,430 --> 00:16:22,944
E si può illuminare tutto
fino disabilitando la modalità notte.

338
00:16:22,944 --> 00:16:24,860
E alla fine
giorno, si sta andando a vedere

339
00:16:24,860 --> 00:16:30,090
questi tre principali areas-- il file
del browser a sinistra, le schede di codificare fino in alto,

340
00:16:30,090 --> 00:16:32,430
e il terminale nella parte inferiore.

341
00:16:32,430 --> 00:16:34,890
>> Lasciami andare avanti e
scrivere il mio primo programma.

342
00:16:34,890 --> 00:16:42,300
Ho intenzione di andare preventivamente su File,
Salva e salvare il mio file come hello.c.

343
00:16:42,300 --> 00:16:46,850
Infatti, per convenzione, qualsiasi che il programma
scrivere che è scritto in linguaggio C

344
00:16:46,850 --> 00:16:49,739
dovrebbe essere chiamato qualcosa
dot C, per convenzione.

345
00:16:49,739 --> 00:16:53,030
Quindi ho intenzione di nominarlo hello.c, perché
Voglio solo dire ciao al mondo.

346
00:16:53,030 --> 00:16:54,820
Ora ho intenzione di zoom
fuori e fare clic su Salva.

347
00:16:54,820 --> 00:16:58,180
E tutto quello che ho qui ora è una scheda
in cui posso iniziare a scrivere codice.

348
00:16:58,180 --> 00:16:59,490
>> Questo non sta andando per la compilazione.

349
00:16:59,490 --> 00:17:00,300
Questo non significa nulla.

350
00:17:00,300 --> 00:17:02,750
E quindi, anche se mi sono convertito
questo a zero e uno,

351
00:17:02,750 --> 00:17:05,390
la CPU sta per avere nessun
idea di quello che sta succedendo intorno.

352
00:17:05,390 --> 00:17:14,170
Ma se scrivo linee che corrispondono
con conventions-- essere di C C,

353
00:17:14,170 --> 00:17:20,150
Di nuovo, questo Language, con una sintassi simile
questo, printf ciao world-- e ho

354
00:17:20,150 --> 00:17:22,210
ottenuto agio con
farlo nel tempo.

355
00:17:22,210 --> 00:17:24,510
Quindi non penso che ho fatto
eventuali errori tipografici.

356
00:17:24,510 --> 00:17:27,910
>> Ma, invariabilmente, la prima
volta che si esegue questa operazione, si farà.

357
00:17:27,910 --> 00:17:31,090
E quello che sto per fare molto potrebbe
bene non funzionare per voi la prima volta.

358
00:17:31,090 --> 00:17:33,610
E questo è perfettamente OK,
perché in questo momento si

359
00:17:33,610 --> 00:17:37,662
potrebbe anche vedere un sacco di novità,
ma nel corso del tempo, una volta acquisita familiarità

360
00:17:37,662 --> 00:17:39,870
con questo ambiente, e
questo linguaggio, e gli altri,

361
00:17:39,870 --> 00:17:42,370
si inizia a vedere cose che
sono sia giusta o sbagliata.

362
00:17:42,370 --> 00:17:44,369
>> E questo è ciò che il
compagni di insegnamento e corso

363
00:17:44,369 --> 00:17:48,780
assistenti ottenere così bravo a nel corso del tempo, è
individuare errori o bug nel codice.

364
00:17:48,780 --> 00:17:52,110
Ma io sostengo che non ci
sono errori in questo codice.

365
00:17:52,110 --> 00:17:53,990
Così ora voglio eseguire questo programma.

366
00:17:53,990 --> 00:17:57,440
>> Ora sul mio Mac o PC, sono in
l'abitudine di doppi icone di clic

367
00:17:57,440 --> 00:17:59,350
quando voglio eseguire qualche programma.

368
00:17:59,350 --> 00:18:01,080
Ma non è il modello qui.

369
00:18:01,080 --> 00:18:04,570
In questo ambiente, che è CS50 IDE.

370
00:18:04,570 --> 00:18:07,192
Stiamo utilizzando un operativo
sistema chiamato Linux.

371
00:18:07,192 --> 00:18:09,900
Linux ricorda di un altro
sistema operativo, generalmente noto

372
00:18:09,900 --> 00:18:10,850
come Unix.

373
00:18:10,850 --> 00:18:16,340
E Linux è particolarmente noto per
avere una Command Line Ambiente, CLI.

374
00:18:16,340 --> 00:18:20,070
Ora, stiamo usando una specifica
sapore di Linux chiamata Ubuntu.

375
00:18:20,070 --> 00:18:22,770
E Ubuntu è semplicemente un
determinata versione di Linux.

376
00:18:22,770 --> 00:18:27,900
>> Ma di questi Linux in questi giorni fanno in realtà
sono dotati di interfacce grafiche.

377
00:18:27,900 --> 00:18:30,360
E quello ci capita di
stia usando qui è web-based.

378
00:18:30,360 --> 00:18:32,735
Quindi questo potrebbe apparire anche una
po 'diverso da qualcosa

379
00:18:32,735 --> 00:18:35,310
lei stesso potrebbe avere
visto o eseguire in passato.

380
00:18:35,310 --> 00:18:37,910
>> Quindi ho intenzione di andare avanti
ora e fare quanto segue.

381
00:18:37,910 --> 00:18:40,950
Ho salvato questo file come hello.c.

382
00:18:40,950 --> 00:18:47,350
Ho intenzione di andare avanti e
Tipo clanghello.c Così Clang

383
00:18:47,350 --> 00:18:49,850
per il linguaggio C è un compilatore.

384
00:18:49,850 --> 00:18:51,952
E 'pre-installato in CS50 IDE.

385
00:18:51,952 --> 00:18:54,910
E si può assolutamente scaricare e
installare questo sul proprio Mac o PC.

386
00:18:54,910 --> 00:18:57,910
>> Ma, ancora una volta, si potrebbe non avere tutti
la pre-configurazione di fatto per voi.

387
00:18:57,910 --> 00:19:00,940
Quindi per ora, io sono solo
andare a correre clanghello.c.

388
00:19:00,940 --> 00:19:03,240
E ora notare questa sintassi
qui finirà

389
00:19:03,240 --> 00:19:06,930
rendo conto significa solo che io sono in un
cartella o directory chiamata di lavoro.

390
00:19:06,930 --> 00:19:11,030
Questo simbolo del dollaro è solo convenzione
di senso, digitare i comandi qui.

391
00:19:11,030 --> 00:19:14,560
>> E 'quello che si chiama un prompt, basta
per convenzione è il simbolo del dollaro.

392
00:19:14,560 --> 00:19:19,130
E se vado avanti ora e fare clic su
Invio, nulla sembra essere accaduto.

393
00:19:19,130 --> 00:19:20,930
Ma questo è in realtà una buona cosa.

394
00:19:20,930 --> 00:19:23,650
Il meno che accade sulla
lo schermo, il più probabile

395
00:19:23,650 --> 00:19:26,710
il codice è di essere corretto,
almeno sintatticamente.

396
00:19:26,710 --> 00:19:29,120
>> Quindi, se voglio correre questo
il programma, cosa devo fare?

397
00:19:29,120 --> 00:19:33,770
Beh, si scopre che il
nome di default per convenzione

398
00:19:33,770 --> 00:19:38,854
per i programmi quando non si specifica un
un nome per il vostro programma è solo a.out.

399
00:19:38,854 --> 00:19:41,270
E questa sintassi troppo, ti
acquisire familiarità con poco tempo.

400
00:19:41,270 --> 00:19:47,500
>> Dot taglio su significa semplicemente, hey, CS50
IDE, eseguire un programma chiamato a.out

401
00:19:47,500 --> 00:19:49,400
che è dentro la mia directory corrente.

402
00:19:49,400 --> 00:19:51,520
Questo punto significa che la directory corrente.

403
00:19:51,520 --> 00:19:55,040
E vedremo cosa altri tali sequenze
di personaggi significa in breve tempo.

404
00:19:55,040 --> 00:19:58,430
>> Quindi qui si va, Enter, ciao mondo.

405
00:19:58,430 --> 00:20:00,080
E si noterà, che cosa è successo?

406
00:20:00,080 --> 00:20:01,580
Non solo la stampa ciao mondo.

407
00:20:01,580 --> 00:20:05,990
E 'anche spostato il
cursore alla riga successiva.

408
00:20:05,990 --> 00:20:07,160
>> E perché è stato?

409
00:20:07,160 --> 00:20:12,400
Qual è stato il codice che abbiamo scritto prima
che ha assicurato che il cursore sarebbe

410
00:20:12,400 --> 00:20:14,882
andare sulla riga successiva?

411
00:20:14,882 --> 00:20:16,840
La cosa divertente circa un
computer è è solo andare

412
00:20:16,840 --> 00:20:18,570
di fare letteralmente quello che gli si dice di fare.

413
00:20:18,570 --> 00:20:26,050
>> Quindi, se gli si dice di printf ciao,
virgola, spazio, mondo, vicino citazione,

414
00:20:26,050 --> 00:20:29,090
E 'letteralmente solo andando
per stampare quei personaggi.

415
00:20:29,090 --> 00:20:31,980
Ma ho avuto questo carattere speciale
alla fine, richiamo, backslash n.

416
00:20:31,980 --> 00:20:34,230
Ed è quello che garantisce
che il personaggio è andato

417
00:20:34,230 --> 00:20:36,570
alla riga successiva della schermata.

418
00:20:36,570 --> 00:20:38,097
>> In realtà, mi permetta di andare a fare questo.

419
00:20:38,097 --> 00:20:39,430
Lasciami andare avanti e cancellare questo.

420
00:20:39,430 --> 00:20:41,180
Ora, si noti che la
parte superiore del mio schermo non c'è

421
00:20:41,180 --> 00:20:42,890
un po 'di luce rossa
Nella scheda che indica,

422
00:20:42,890 --> 00:20:45,047
Ehi, non hai salvato il file.

423
00:20:45,047 --> 00:20:47,880
Quindi ho intenzione di andare avanti con il controllo
S o comando S, salvare il file.

424
00:20:47,880 --> 00:20:51,130
Ora goes-- andato per un verde moment--.

425
00:20:51,130 --> 00:20:53,760
E ora si torna a
solo di essere l'icona di un vicino.

426
00:20:53,760 --> 00:21:01,860
>> Se ora corro di nuovo clanghello.c,
Invio, barra di punti, a.out, Enter,

427
00:21:01,860 --> 00:21:04,110
vedrai che funzionava ancora.

428
00:21:04,110 --> 00:21:06,020
Ma è senza dubbio un po 'buggy.

429
00:21:06,020 --> 00:21:08,714
In questo momento, il mio lavoro prompt--,
e poi che il simbolo del dollaro,

430
00:21:08,714 --> 00:21:10,880
e poi il mio prompt-- reale
è tutto sulla stessa linea.

431
00:21:10,880 --> 00:21:14,540
Quindi, questo è certamente un bug di estetica,
anche se non è proprio un errore logico.

432
00:21:14,540 --> 00:21:16,250
>> Quindi ho intenzione di disfare ciò che ho appena fatto.

433
00:21:16,250 --> 00:21:18,560
Ho intenzione di eseguire nuovamente a.out.

434
00:21:18,560 --> 00:21:22,710
Notate ho aggiunto il
carattere indietro a capo.

435
00:21:22,710 --> 00:21:24,280
Ho salvato il file.

436
00:21:24,280 --> 00:21:31,630
>> Quindi ho intenzione di eseguire nuovamente a.out, e-
dannazione, un insetto, un bug che significa errore.

437
00:21:31,630 --> 00:21:35,020
Così il bug è che anche se
Ho aggiunto il backslash n lì,

438
00:21:35,020 --> 00:21:41,180
ri-salvato, ri-corse del programma,
il comportamento era lo stesso.

439
00:21:41,180 --> 00:21:42,640
Perché sarebbe?

440
00:21:42,640 --> 00:21:43,910
>> Mi manca un passo, giusto?

441
00:21:43,910 --> 00:21:47,620
Questo passo fondamentale prima è che bisogna
a-- quando si modifica il codice sorgente,

442
00:21:47,620 --> 00:21:49,610
si scopre anche gestito
attraverso il compilatore

443
00:21:49,610 --> 00:21:51,102
ancora una volta in modo da ottenere un nuovo codice macchina.

444
00:21:51,102 --> 00:21:52,810
E il codice macchina,
le zero e uno,

445
00:21:52,810 --> 00:21:56,260
stanno per essere quasi identica, ma
non perfettamente così, perché abbiamo bisogno,

446
00:21:56,260 --> 00:21:57,510
naturalmente, che la nuova linea.

447
00:21:57,510 --> 00:22:02,640
>> Quindi, per risolvere questo problema, ho intenzione di bisogno
rieseguire clanghello.c, entrare, dot

448
00:22:02,640 --> 00:22:03,800
tagliare, a.out.

449
00:22:03,800 --> 00:22:08,402
E ora, ciao mondo è tornato
al punto in cui mi aspettavo che fosse.

450
00:22:08,402 --> 00:22:09,610
Quindi questo è tutto bello e buono.

451
00:22:09,610 --> 00:22:13,150
Ma a.out è un nome abbastanza stupido per un
programma, anche se si trova,

452
00:22:13,150 --> 00:22:16,530
per ragioni storiche, la
default-- significa uscite di montaggio.

453
00:22:16,530 --> 00:22:20,780
>> Ma mi permetta di andare avanti qui
e farlo in modo diverso.

454
00:22:20,780 --> 00:22:24,760
Voglio che il mio programma ciao mondo
in realtà essere chiamato ciao.

455
00:22:24,760 --> 00:22:28,320
Quindi, se si trattasse di una icona sul mio
desktop, non sarebbe a.out.

456
00:22:28,320 --> 00:22:29,730
Si sarebbe chiamato ciao.

457
00:22:29,730 --> 00:22:33,660
>> Quindi, per fare questo, si scopre
che Clang, come molti programmi,

458
00:22:33,660 --> 00:22:37,980
sostiene gli argomenti della riga di comando,
o bandiere, o interruttori,

459
00:22:37,980 --> 00:22:39,600
che si limita a influenzare il suo comportamento.

460
00:22:39,600 --> 00:22:45,160
In particolare, Clang supporta un trattino o
bandiera, che poi prende una seconda parola.

461
00:22:45,160 --> 00:22:48,190
In questo caso, io arbitrariamente,
ma ragionevolmente, lo chiamano ciao.

462
00:22:48,190 --> 00:22:50,710
Ma potrei chiamarlo nulla
Io voglio, tranne a.out, che

463
00:22:50,710 --> 00:22:52,390
sarebbe piuttosto oltre il punto.

464
00:22:52,390 --> 00:22:55,640
>> E poi basta specificare il nome
del file che voglio per la compilazione.

465
00:22:55,640 --> 00:22:59,190
Così ora, anche se all'inizio
del comando ho ancora Clang,

466
00:22:59,190 --> 00:23:01,410
alla fine del comando
Ho ancora il nome del file,

467
00:23:01,410 --> 00:23:05,520
Ora ho questi riga di comando
argomenti, questi flag che stanno dicendo,

468
00:23:05,520 --> 00:23:11,180
Oh, a proposito, uscita-o, un file
chiamato ciao, non il a.out di default.

469
00:23:11,180 --> 00:23:13,810
>> Quindi, se ho colpito Inserisci ora, niente
sembra essere accaduto.

470
00:23:13,810 --> 00:23:17,900
E, tuttavia, ora posso fare barra dot ciao.

471
00:23:17,900 --> 00:23:19,089
Quindi è lo stesso programma.

472
00:23:19,089 --> 00:23:21,380
Gli zero e uno sono
identica alla fine della giornata.

473
00:23:21,380 --> 00:23:24,210
>> Ma sono in due
diverso a.out files--,

474
00:23:24,210 --> 00:23:26,490
che è la prima versione
e solo stupidamente di nome,

475
00:23:26,490 --> 00:23:30,250
e ora ciao, che è un gran
altro nome interessante per un programma.

476
00:23:30,250 --> 00:23:33,195
Ma, onestamente, non sono mai
andando a ricordare di nuovo,

477
00:23:33,195 --> 00:23:34,070
e ancora, e ancora.

478
00:23:34,070 --> 00:23:36,411
E, in realtà, mentre scriviamo
programmi più complicati,

479
00:23:36,411 --> 00:23:38,160
i comandi sei
andando ad avere per scrivere

480
00:23:38,160 --> 00:23:40,920
stanno per arrivare anche
più complicata ancora.

481
00:23:40,920 --> 00:23:41,940
>> E così non preoccuparsi.

482
00:23:41,940 --> 00:23:46,220
Si scopre che gli esseri umani prima
Ci siamo resi conto anche loro

483
00:23:46,220 --> 00:23:47,530
avuto questo stesso problema.

484
00:23:47,530 --> 00:23:50,900
Anche loro non godere dover
tipo piuttosto lunghi, comandi arcani,

485
00:23:50,900 --> 00:23:52,200
per non parlare di ricordare.

486
00:23:52,200 --> 00:23:56,070
E così gli esseri umani prima di noi hanno fatto
altri programmi che rendono più facile

487
00:23:56,070 --> 00:23:57,670
per compilare il software.

488
00:23:57,670 --> 00:24:01,609
>> E, in effetti, una tale
programma si chiama fare.

489
00:24:01,609 --> 00:24:03,150
Quindi ho intenzione di andare avanti e fare questo.

490
00:24:03,150 --> 00:24:05,691
Io vado a disfare tutto quello che ho
appena fatto nel modo seguente.

491
00:24:05,691 --> 00:24:07,690
Mi permetta di tipo LS.

492
00:24:07,690 --> 00:24:10,980
E si noterà tre things--
a.out, e una stella, ciao

493
00:24:10,980 --> 00:24:12,810
e una stella, e hello.c.

494
00:24:12,810 --> 00:24:14,730
Speriamo che questo dovrebbe
essere un po intuitiva,

495
00:24:14,730 --> 00:24:18,220
nella misura in cui in precedenza non vi era
nulla in questo spazio di lavoro.

496
00:24:18,220 --> 00:24:21,240
Non c'era niente che ho avuto
creato fino a quando abbiamo iniziato classe.

497
00:24:21,240 --> 00:24:22,840
>> E ho creato hello.c.

498
00:24:22,840 --> 00:24:24,544
Poi ho compilato, e lo ha chiamato a.out.

499
00:24:24,544 --> 00:24:27,460
E poi ho compilato di nuovo un po '
diversamente e lo ha chiamato ciao.

500
00:24:27,460 --> 00:24:32,830
Così ho tre file in questa directory,
in questa cartella denominata Area di lavoro.

501
00:24:32,830 --> 00:24:35,005
Ora, posso vedere che pure
se io diminuire in realtà.

502
00:24:35,005 --> 00:24:37,530
>> Se io diminuire qui e
guarda che la mano in alto a destra

503
00:24:37,530 --> 00:24:39,940
angolo, come promesso sinistra
lato dello schermo

504
00:24:39,940 --> 00:24:42,990
è sempre intenzione di mostrare
cosa c'è nel tuo account, che cosa è

505
00:24:42,990 --> 00:24:44,790
all'interno di CS50 IDE.

506
00:24:44,790 --> 00:24:46,680
E ci sono tre file lì.

507
00:24:46,680 --> 00:24:49,070
>> Quindi voglio sbarazzarsi di a.out e ciao.

508
00:24:49,070 --> 00:24:51,275
E come si potrebbe
immaginare intuitivamente, è

509
00:24:51,275 --> 00:24:53,400
potrebbe sorta di controllo click
o fare clic destro su questo.

510
00:24:53,400 --> 00:24:54,590
E questo piccolo menu si apre.

511
00:24:54,590 --> 00:24:57,170
È possibile scaricare il file, esegue
essa, in anteprima, aggiornamento, rinominare,

512
00:24:57,170 --> 00:24:57,700
o cosa no.

513
00:24:57,700 --> 00:25:00,260
>> E ho potuto solo cancellare,
e sarebbe andato via.

514
00:25:00,260 --> 00:25:05,260
Ma facciamo le cose con un comando
Linea per ora, in modo da ottenere confortevole

515
00:25:05,260 --> 00:25:07,010
con questo, e fare quanto segue.

516
00:25:07,010 --> 00:25:12,345
Ho intenzione di andare avanti e rimuovere
a.out digitando letteralmente rma.out.

517
00:25:12,345 --> 00:25:14,890
Si scopre, il comando per
la rimozione o l'eliminazione di qualcosa,

518
00:25:14,890 --> 00:25:16,280
non rimuovere o cancellare.

519
00:25:16,280 --> 00:25:21,260
>> E 'più succintamente RM, solo per salvare
alcune combinazioni di tasti, e premi invio.

520
00:25:21,260 --> 00:25:24,707
Ora stiamo andando a essere un po '
cripticamente rimuovere file regolare a.out.

521
00:25:24,707 --> 00:25:27,040
Io non so davvero che cosa un
file di irregolare sarebbe ancora.

522
00:25:27,040 --> 00:25:28,660
Ma io voglio rimuoverlo.

523
00:25:28,660 --> 00:25:30,150
>> Quindi ho intenzione di digitare Y per sì.

524
00:25:30,150 --> 00:25:31,940
O potrei scrivere fuori, e premere Invio.

525
00:25:31,940 --> 00:25:33,440
E, ancora una volta, nulla sembra accadere.

526
00:25:33,440 --> 00:25:35,840
Ma questo è, in generale, una buona cosa.

527
00:25:35,840 --> 00:25:40,490
>> Se scriv LS questa volta,
cosa devo vedere?

528
00:25:40,490 --> 00:25:44,930
Si spera, solo ciao e hello.c.

529
00:25:44,930 --> 00:25:47,286
Ora, come un a parte, ti
notare questa stella, asterisco,

530
00:25:47,286 --> 00:25:48,660
che è alla fine dei miei programmi.

531
00:25:48,660 --> 00:25:50,201
E stanno anche mostrando in verde.

532
00:25:50,201 --> 00:25:53,970
Questo è solo il modo di CS50 IDE
di voi cluing nella realtà

533
00:25:53,970 --> 00:25:55,280
che questo non è il codice sorgente.

534
00:25:55,280 --> 00:25:58,880
Questo è un eseguibile, un eseguibile
programma che si può effettivamente eseguire

535
00:25:58,880 --> 00:26:01,020
facendo barra di punti, e quindi il suo nome.

536
00:26:01,020 --> 00:26:05,860
>> Ora, mi permetta di andare avanti e rimuovere
questo, RM ciao, Enter, rimuovere regolare

537
00:26:05,860 --> 00:26:08,010
presentare ciao, sì.

538
00:26:08,010 --> 00:26:11,180
E ora, se digito LS,
siamo tornati a hello.c.

539
00:26:11,180 --> 00:26:13,917
Cercate di non cancellare il tuo
codice sorgente.

540
00:26:13,917 --> 00:26:16,250
Anche se ci sono caratteristiche
integrato nel CS50 IDE dove

541
00:26:16,250 --> 00:26:19,870
si può passare attraverso la tua cronologia delle revisioni
e riavvolgere in tempo se accidentalmente

542
00:26:19,870 --> 00:26:23,660
cancellare qualcosa, fare essere consapevoli
come da queste richieste sì o no,

543
00:26:23,660 --> 00:26:25,381
di ciò che si vuole realmente fare.

544
00:26:25,381 --> 00:26:27,380
E se vado fino alla cima
sinistra angolo mano qui,

545
00:26:27,380 --> 00:26:30,696
tutto ciò che rimane è hello.c.

546
00:26:30,696 --> 00:26:32,570
Quindi c'è grappoli d'
altri comandi che si

547
00:26:32,570 --> 00:26:37,550
può eseguire nel mondo di Linux,
uno dei quali è, ancora una volta, Make.

548
00:26:37,550 --> 00:26:40,180
E stiamo andando a fare
il mio programma ora come segue.

549
00:26:40,180 --> 00:26:43,270
>> Invece di fare clang,
invece di fare clang-o,

550
00:26:43,270 --> 00:26:45,860
Ho intenzione di semplicemente
letteralmente tipo, fare ciao.

551
00:26:45,860 --> 00:26:49,630
E ora notato, io sono
Non digitando fare hello.c.

552
00:26:49,630 --> 00:26:50,910
Sto scrivendo fanno ciao.

553
00:26:50,910 --> 00:26:54,840
>> E questo programma make che
viene fornito con CS50 IDE, e altro ancora

554
00:26:54,840 --> 00:26:57,090
generalmente con Linux,
è un programma che è

555
00:26:57,090 --> 00:26:59,120
andando a fare un programma chiamato Ciao.

556
00:26:59,120 --> 00:27:03,680
E sta andando ad assumere, per convenzione,
che se questo programma può essere fatto,

557
00:27:03,680 --> 00:27:09,030
sta andando essere fatta da una fonte
file di codice che termina con punto c, hello.c.

558
00:27:09,030 --> 00:27:12,210
>> Quindi, se ho colpito Entra subito, si noti che
il comando che viene eseguito

559
00:27:12,210 --> 00:27:14,340
è in realtà ancora più a lungo
prima di prima.

560
00:27:14,340 --> 00:27:16,670
E questo perché abbiamo
preconfigurato CS50 IDE di avere

561
00:27:16,670 --> 00:27:19,878
alcune funzionalità aggiuntive integrate in quel
non abbiamo bisogno di appena ancora, ma presto sarà.

562
00:27:19,878 --> 00:27:23,470
Ma la cosa fondamentale da realizzare
è ora ho un programma Ciao.

563
00:27:23,470 --> 00:27:27,080
>> Se scrivo di nuovo LS, ho
avere un programma ciao.

564
00:27:27,080 --> 00:27:32,070
E posso eseguirlo con
dot taglio su a.out, no,

565
00:27:32,070 --> 00:27:35,590
perché il punto di questo
esercizio è stato dot ciao barra.

566
00:27:35,590 --> 00:27:38,089
E ora ho il mio programma ciao mondo.

567
00:27:38,089 --> 00:27:39,880
Quindi andare avanti,
ci siamo quasi sempre solo

568
00:27:39,880 --> 00:27:42,088
andare per compilare i nostri programmi
utilizzando il comando Crea.

569
00:27:42,088 --> 00:27:45,300
E allora stiamo andando a correre per loro
dot slash, e il nome del programma.

570
00:27:45,300 --> 00:27:49,610
Ma realizzare ciò che fanno è facendo per
si, è che è in sé non un compilatore.

571
00:27:49,610 --> 00:27:53,310
E 'solo un programma di convenienza
che sa innescare un compilatore

572
00:27:53,310 --> 00:27:56,470
per eseguire in modo che lei stesso può utilizzare.

573
00:27:56,470 --> 00:28:00,220
>> Quello che esistono altri comandi
Linux, ed a sua volta il CS50 IDE?

574
00:28:00,220 --> 00:28:03,107
Presto vedremo che c'è un
comando CD, Cambia directory.

575
00:28:03,107 --> 00:28:05,190
Ciò consente all'interno
l'interfaccia a riga di comando

576
00:28:05,190 --> 00:28:07,610
ad andare avanti, e indietro,
e di aprire cartelle diverse

577
00:28:07,610 --> 00:28:08,860
senza utilizzare il mouse.

578
00:28:08,860 --> 00:28:12,470
>> LS abbiamo visto, che sta per lista
i file nella directory corrente.

579
00:28:12,470 --> 00:28:14,650
Fare Dir, è possibile
probabilmente iniziare a dedurre

580
00:28:14,650 --> 00:28:18,150
ciò che questi significano now-- fare directory,
se si desidera creare una cartella.

581
00:28:18,150 --> 00:28:21,270
RM per rimuovere, RM Dir per
rimuovere directory-- e questi,

582
00:28:21,270 --> 00:28:24,160
ancora una volta, sono la linea di comando
equivalenti di ciò che si

583
00:28:24,160 --> 00:28:26,945
potrebbe fare in CS50 IDE con il mouse.

584
00:28:26,945 --> 00:28:28,820
Ma troverai subito
che a volte è solo

585
00:28:28,820 --> 00:28:30,610
molto più veloce da fare
le cose con una tastiera,

586
00:28:30,610 --> 00:28:33,690
e infine molto più potente.

587
00:28:33,690 --> 00:28:36,440
>> Ma è difficile sostenere che
tutto ciò che abbiamo fatto finora

588
00:28:36,440 --> 00:28:39,990
è tutto ciò che potente, quando tutti
abbiamo detto è, ciao mondo.

589
00:28:39,990 --> 00:28:43,740
E, infatti, ho hardcoded il
parole ciao mondo nel mio programma.

590
00:28:43,740 --> 00:28:45,530
Non vi è ancora alcuna dinamismo.

591
00:28:45,530 --> 00:28:49,320
Scratch è un ordine di grandezza
più interessante la scorsa settimana.

592
00:28:49,320 --> 00:28:51,220
>> E così andiamo lì.

593
00:28:51,220 --> 00:28:55,310
Facciamo un passo verso che,
modo di alcune di queste funzioni.

594
00:28:55,310 --> 00:28:59,470
Quindi non solo C sono dotati di printf,
e mazzi di altre funzioni

595
00:28:59,470 --> 00:29:01,850
alcune delle quali vedremo
nel tempo, non è così

596
00:29:01,850 --> 00:29:05,760
rendere il tutto così facile a destra fuori
della porta a ottenere l'input dell'utente.

597
00:29:05,760 --> 00:29:08,140
>> In effetti, uno dei punti deboli
di linguaggi come C,

598
00:29:08,140 --> 00:29:10,140
e anche Java e ancora
altri, è che non fa

599
00:29:10,140 --> 00:29:15,860
rendere più facile per ottenere solo le cose come
interi degli utenti, o stringhe, parole,

600
00:29:15,860 --> 00:29:19,970
e le frasi, lasciare che le cose da soli, come
valori di punto, o numeri reali galleggiante

601
00:29:19,970 --> 00:29:23,240
con punti decimali, e davvero
numeri lunghi, come vedremo tra poco.

602
00:29:23,240 --> 00:29:27,000
Quindi questo elenco di funzioni qui, questi
sono come gli altri pezzi del puzzle Scratch

603
00:29:27,000 --> 00:29:31,090
che abbiamo pre-installato in CS50
IDE che useremo per alcune settimane

604
00:29:31,090 --> 00:29:34,010
come ruote di formazione di sorta, e
alla fine li decollare, e guardare

605
00:29:34,010 --> 00:29:37,210
sotto la cappa, forse,
come queste cose siano applicate.

606
00:29:37,210 --> 00:29:40,460
>> Ma per fare questo, andiamo
in realtà scrivere un programma.

607
00:29:40,460 --> 00:29:41,770
Lasciami andare avanti ora.

608
00:29:41,770 --> 00:29:44,750
E ho intenzione di creare una nuova
il file cliccando questo piccolo vantaggio,

609
00:29:44,750 --> 00:29:45,970
e facendo clic su Nuovo file.

610
00:29:45,970 --> 00:29:49,250
>> Io vado a salvare questo prossimo
uno come, diciamo, string.c,

611
00:29:49,250 --> 00:29:50,750
perché voglio giocare con le stringhe.

612
00:29:50,750 --> 00:29:53,990
E stringa in C è solo
una sequenza di caratteri.

613
00:29:53,990 --> 00:29:56,090
Così ora andiamo avanti
e procedere come segue.

614
00:29:56,090 --> 00:30:01,204
>> Include di serie IO.h-- e
si scopre IO standard,

615
00:30:01,204 --> 00:30:03,360
IO significa solo ingresso e uscita.

616
00:30:03,360 --> 00:30:05,920
Così si scopre che
questa linea qui è ciò che

617
00:30:05,920 --> 00:30:08,140
Gli Stati Uniti sono vicini da utilizzare printf.

618
00:30:08,140 --> 00:30:10,410
Printf, ovviamente, produce output.

619
00:30:10,410 --> 00:30:15,000
Quindi, al fine di utilizzare printf, risulta
out devi avere questa riga di codice

620
00:30:15,000 --> 00:30:16,040
nella parte superiore del file.

621
00:30:16,040 --> 00:30:18,456
>> E torneremo a quello che
questo significa che in realtà non molto.

622
00:30:18,456 --> 00:30:20,400
Risulta che in
qualsiasi programma C che scrivo,

623
00:30:20,400 --> 00:30:23,640
Ho avuto modo di iniziare con
codice che assomiglia a questo.

624
00:30:23,640 --> 00:30:26,860
E si noterà CS50 IDE e
altro sviluppo integrato

625
00:30:26,860 --> 00:30:30,050
ambienti come esso,
stanno andando a cercare come meglio

626
00:30:30,050 --> 00:30:31,780
il possibile per finire il pensiero.

627
00:30:31,780 --> 00:30:35,930
In realtà, un momento fa, se mi annullare
quello che ho appena fatto, mi ha colpito Invio.

628
00:30:35,930 --> 00:30:39,160
>> Ho poi ha colpito ricci aperta
brace, premere Invio di nuovo.

629
00:30:39,160 --> 00:30:40,430
Ed è finito il mio pensiero.

630
00:30:40,430 --> 00:30:45,140
Mi ha dato una nuova linea, non meno frastagliata
per belle ragioni stilistiche vedremo.

631
00:30:45,140 --> 00:30:48,559
E poi mi ha dato automaticamente
che graffa per terminare il mio pensiero.

632
00:30:48,559 --> 00:30:50,600
Ora, non sempre
indovinare che cosa si vuole fare.

633
00:30:50,600 --> 00:30:53,620
Ma in gran parte, lo fa
risparmiare alcuni tasti.

634
00:30:53,620 --> 00:30:59,560
Quindi un momento fa, abbiamo fatto questo program--
ciao, mondo, e quindi compilato,

635
00:30:59,560 --> 00:31:00,460
e poi corse esso.

636
00:31:00,460 --> 00:31:01,867
Ma non c'è dinamismo qui.

637
00:31:01,867 --> 00:31:03,700
E se volessimo
fare qualcosa di diverso?

638
00:31:03,700 --> 00:31:07,630
Beh, e se volevo davvero
ottenere una stringa da parte dell'utente?

639
00:31:07,630 --> 00:31:11,250
Ho intenzione di usare un pezzo di puzzle
chiamato esattamente che-- ottenere stringa.

640
00:31:11,250 --> 00:31:15,860
>> Risulta in C che, quando non si vuole
di fornire un contributo ad un pezzo di puzzle,

641
00:31:15,860 --> 00:31:19,360
o più propriamente ad una funzione,
letteralmente fare parentesi aperta,

642
00:31:19,360 --> 00:31:20,430
parentesi chiusa.

643
00:31:20,430 --> 00:31:25,540
Quindi è come se ci fosse
nessuna scatola bianca per digitare in.

644
00:31:25,540 --> 00:31:27,720
Il blocco dire prima
aveva una piccola scatola bianca.

645
00:31:27,720 --> 00:31:29,660
Non abbiamo quella scatola bianca ora.

646
00:31:29,660 --> 00:31:33,310
>> Ma quando chiamo stringa get, io
vuole mettere il risultato in qualche luogo.

647
00:31:33,310 --> 00:31:37,680
Quindi, un paradigma molto comune in C è quello di
chiamare una funzione, come stringa di arrivare qui,

648
00:31:37,680 --> 00:31:41,070
e quindi memorizzare il suo valore di ritorno.

649
00:31:41,070 --> 00:31:44,450
È il risultato della sua
sforzo in qualcosa.

650
00:31:44,450 --> 00:31:47,630
>> E qual è il
costruire in programmazione,

651
00:31:47,630 --> 00:31:53,450
sia in Scratch o adesso C, che abbiamo
possono utilizzare per memorizzare in realtà qualcosa?

652
00:31:53,450 --> 00:31:55,990
Chiamato una variabile, giusto?

653
00:31:55,990 --> 00:32:00,320
E in Scratch, non lo facciamo davvero
cura che cosa stava succedendo nelle variabili.

654
00:32:00,320 --> 00:32:02,170
>> Ma in questo caso, abbiamo effettivamente facciamo.

655
00:32:02,170 --> 00:32:03,719
Sto per dire stringa.

656
00:32:03,719 --> 00:32:05,510
E poi ho potuto chiamare
questo tutto quello che voglio.

657
00:32:05,510 --> 00:32:08,340
Ho intenzione di chiamarlo
nome, ottiene ottenere stringa.

658
00:32:08,340 --> 00:32:10,250
>> E ora anche se sei
un po 'di nuovo a questo,

659
00:32:10,250 --> 00:32:11,984
Noto che mi manca qualche dettaglio.

660
00:32:11,984 --> 00:32:13,150
Sto dimenticando un punto e virgola.

661
00:32:13,150 --> 00:32:14,400
Ho bisogno di finire questo pensiero.

662
00:32:14,400 --> 00:32:17,480
Quindi ho intenzione di spostare il mio cursore,
e ha colpito virgola lì.

663
00:32:17,480 --> 00:32:19,130
E quello che ho appena fatto?

664
00:32:19,130 --> 00:32:21,440
In questa linea di codice,
numero 5 in questo momento,

665
00:32:21,440 --> 00:32:23,799
Sto chiamando stringa get senza ingressi.

666
00:32:23,799 --> 00:32:26,090
Quindi non c'è po 'di bianco
box come il blocco Salva ha.

667
00:32:26,090 --> 00:32:28,590
>> Sto solo dicendo, hey,
calcolatore, portami una stringa.

668
00:32:28,590 --> 00:32:31,390
Il segno di uguale non è davvero
un segno di uguale, di per sé.

669
00:32:31,390 --> 00:32:33,790
E 'l'assegnazione
operatore, il che significa,

670
00:32:33,790 --> 00:32:37,860
Hey, computer, spostare il valore
da destra verso sinistra.

671
00:32:37,860 --> 00:32:40,480
E a sinistra, ho il seguente.

672
00:32:40,480 --> 00:32:43,580
>> Hey, computer, dammi un string--
una sequenza di caratteri.

673
00:32:43,580 --> 00:32:45,637
E chiamare quel Nome stringa.

674
00:32:45,637 --> 00:32:47,220
E non hanno nemmeno bisogno di chiamarla Nome.

675
00:32:47,220 --> 00:32:49,970
>> Potrei chiamarla, convenzionalmente,
qualcosa di simile a S,

676
00:32:49,970 --> 00:32:52,900
molto simile a noi ho usato per
chiamare la variabile i.

677
00:32:52,900 --> 00:32:54,829
Ma ora ho bisogno di fare qualcosa con esso.

678
00:32:54,829 --> 00:32:57,370
Sarebbe piuttosto stupido
provare a compilare questo codice, in esecuzione

679
00:32:57,370 --> 00:32:59,410
questo programma, anche se
Sto diventando una stringa,

680
00:32:59,410 --> 00:33:01,580
perché è ancora solo
andare a dire ciao mondo.

681
00:33:01,580 --> 00:33:06,140
>> Ma cosa succede se voglio cambiare questo.

682
00:33:06,140 --> 00:33:07,940
Perché non fare questo?

683
00:33:07,940 --> 00:33:11,632
Percentuale s, comma s.

684
00:33:11,632 --> 00:33:13,090
E questo è un po 'criptico ancora.

685
00:33:13,090 --> 00:33:15,560
>> Quindi, mi permetta di fare le mie variabili più chiaro.

686
00:33:15,560 --> 00:33:17,510
Ne posso citare questo nome di variabile.

687
00:33:17,510 --> 00:33:20,230
E vediamo se non possiamo prendere in giro
A parte quello che sta succedendo qui.

688
00:33:20,230 --> 00:33:22,770
>> Quindi, sulla linea cinque, sto diventando una stringa.

689
00:33:22,770 --> 00:33:25,620
E sto memorizzare la stringa,
qualunque sia l'utente ha digitato

690
00:33:25,620 --> 00:33:28,430
a sua tastiera,
in una variabile denominata Nome.

691
00:33:28,430 --> 00:33:30,590
E si scopre che
printf non solo

692
00:33:30,590 --> 00:33:34,220
prendere un argomento in camera doppia
citazioni, un ingresso tra virgolette.

693
00:33:34,220 --> 00:33:39,100
>> Si può prendere due, o tre, o più, tale
che il secondo, o il terzo o il quarto,

694
00:33:39,100 --> 00:33:42,320
sono tutti i nomi di variabili,
o valori specificamente,

695
00:33:42,320 --> 00:33:48,610
che si desidera collegare in,
dinamicamente, che stringa tra virgolette.

696
00:33:48,610 --> 00:33:52,110
In altre parole, ciò che
sarebbe sbagliato in questo?

697
00:33:52,110 --> 00:33:57,920
Se ho appena detto ciao nome, backslash
n, salvato il mio file, compilato il mio codice,

698
00:33:57,920 --> 00:34:01,660
e corse questo, che cosa accadrebbe?

699
00:34:01,660 --> 00:34:05,139
>> E 'solo andando a dire, ciao
nome, letteralmente N-A-M-E,

700
00:34:05,139 --> 00:34:07,900
che è una specie di stupido perché
non è diverso da mondo.

701
00:34:07,900 --> 00:34:10,400
Quindi, qualsiasi cosa tra virgolette è
ciò che letteralmente viene stampata.

702
00:34:10,400 --> 00:34:12,520
Quindi, se voglio avere
un segnaposto lì,

703
00:34:12,520 --> 00:34:14,422
Io in realtà bisogno di usare
una sintassi speciale.

704
00:34:14,422 --> 00:34:17,380
E si scopre se si legge la
documentazione per la funzione printf,

705
00:34:17,380 --> 00:34:21,320
vi dirà che
se si utilizza per cento s,

706
00:34:21,320 --> 00:34:23,920
è possibile sostituire un valore come segue.

707
00:34:23,920 --> 00:34:27,190
>> Dopo una virgola dopo che
virgolette, è sufficiente

708
00:34:27,190 --> 00:34:29,179
scrivere il nome del
variabile che si desidera

709
00:34:29,179 --> 00:34:33,790
di collegare in quel formato
codice, o di formato,

710
00:34:33,790 --> 00:34:35,469
cento s per le stringhe.

711
00:34:35,469 --> 00:34:39,190
E ora se ho salvato il mio file,
Torno giù a mio terminale.

712
00:34:39,190 --> 00:34:42,870
E scrivo Fai String,
perché, ancora una volta, il nome di questa

713
00:34:42,870 --> 00:34:45,510
il file che ho scelto prima è string.c.

714
00:34:45,510 --> 00:34:48,510
>> Quindi ho intenzione di dire fare String, digitare.

715
00:34:48,510 --> 00:34:51,550
Oh mio Dio, guarda tutti
gli errori che abbiamo fatto già.

716
00:34:51,550 --> 00:34:55,540
E questo è-- cosa, questo è davvero
come una, sette programma a linea di sei?

717
00:34:55,540 --> 00:34:57,790
Quindi questo è dove molto può
ottenere rapidamente schiacciante.

718
00:34:57,790 --> 00:35:00,890
>> Questa finestra di terminale ha
ora appena rigurgitato

719
00:35:00,890 --> 00:35:03,230
un numero enorme di messaggi di errore.

720
00:35:03,230 --> 00:35:07,560
Di certo, non ho più l'errore
Messaggi di quanto ho righe di codice.

721
00:35:07,560 --> 00:35:08,680
Quindi cosa sta succedendo?

722
00:35:08,680 --> 00:35:10,920
>> Ebbene, la strategia migliore
di fare in qualsiasi momento

723
00:35:10,920 --> 00:35:13,710
non incontrare uno schiacciante
elenco degli errori del genere,

724
00:35:13,710 --> 00:35:16,690
è scorrere indietro, cercare il comando
appena eseguito, che nel mio caso

725
00:35:16,690 --> 00:35:18,020
è rendere stringa.

726
00:35:18,020 --> 00:35:21,630
Guarda a quello rendono fatto, e questo è tutto
lungo comando Clang, un grosso problema lì.

727
00:35:21,630 --> 00:35:22,950
>> Ma il rosso è male.

728
00:35:22,950 --> 00:35:24,750
Verde sta cercando di essere
gentile e disponibile.

729
00:35:24,750 --> 00:35:26,140
Ma è ancora male, in questo caso.

730
00:35:26,140 --> 00:35:27,510
Ma dove è male?

731
00:35:27,510 --> 00:35:31,450
>> String.c, la linea cinque, carattere cinque.

732
00:35:31,450 --> 00:35:32,930
Quindi questo è solo convenzione comune.

733
00:35:32,930 --> 00:35:36,060
Qualcosa del colon qualcosa significa
numero di riga e il numero di carattere.

734
00:35:36,060 --> 00:35:41,080
Errore, l'uso di non dichiarato
stringa di identificazione.

735
00:35:41,080 --> 00:35:42,900
Cercavi standard?

736
00:35:42,900 --> 00:35:45,530
>> Così, purtroppo, Clang
sta cercando di essere utile.

737
00:35:45,530 --> 00:35:46,850
Ma è sbagliato, in questo caso.

738
00:35:46,850 --> 00:35:49,350
No, Clang, non intendevo IO standard.

739
00:35:49,350 --> 00:35:51,070
Volevo dire che sulla linea uno, sì.

740
00:35:51,070 --> 00:35:53,420
>> Ma la linea cinque è questa qui.

741
00:35:53,420 --> 00:35:57,040
E non lo fa Clang
capire S-T-R-I-N-G.

742
00:35:57,040 --> 00:36:01,490
Si tratta di un identificatore non dichiarato, un
parola semplicemente non ha mai visto prima.

743
00:36:01,490 --> 00:36:05,730
E questo perché C, il linguaggio
stiamo scrivendo il codice in questo momento,

744
00:36:05,730 --> 00:36:08,070
non ha variabili chiamate stringhe.

745
00:36:08,070 --> 00:36:11,380
>> E non, per impostazione predefinita, il supporto
una cosa chiamata una stringa.

746
00:36:11,380 --> 00:36:16,750
Questo è un pezzo di CS50
gergo, ma molto convenzionale.

747
00:36:16,750 --> 00:36:18,600
Ma posso risolvere questo problema come segue.

748
00:36:18,600 --> 00:36:22,090
>> Se posso aggiungere una riga di codice
all'inizio del programma,

749
00:36:22,090 --> 00:36:27,890
includere CS50.h, che è un altro file
da qualche parte dentro di CS50 IDE, da qualche parte

750
00:36:27,890 --> 00:36:30,820
sul disco rigido, per così dire,
del sistema operativo Ubuntu

751
00:36:30,820 --> 00:36:33,590
che sto correndo, che
è il file che è

752
00:36:33,590 --> 00:36:38,740
andando a insegnare il funzionamento
Sistema di quello che una stringa è, semplicemente

753
00:36:38,740 --> 00:36:41,930
come io.h standard è il file
nel sistema operativo che è

754
00:36:41,930 --> 00:36:44,430
andando ad insegnare ciò che è printf.

755
00:36:44,430 --> 00:36:46,810
>> Anzi, avremmo ottenuto
un messaggio molto simile

756
00:36:46,810 --> 00:36:50,600
se IO aveva ammesso di serie
Io.h e ha cercato di usare printf.

757
00:36:50,600 --> 00:36:53,632
Quindi ho intenzione di andare avanti e basta
Prendi il controllo L per cancellare il mio schermo.

758
00:36:53,632 --> 00:36:56,340
Oppure si può digitare chiaro e sarà
basta cancellare la finestra di terminale.

759
00:36:56,340 --> 00:36:58,020
Ma si può ancora scorrere indietro nel tempo.

760
00:36:58,020 --> 00:37:01,100
>> E ho intenzione di eseguire nuovamente fare String.

761
00:37:01,100 --> 00:37:03,660
Incrocio le dita questa volta, Invio.

762
00:37:03,660 --> 00:37:05,380
Oh mio Dio, ha funzionato.

763
00:37:05,380 --> 00:37:09,280
mi mostra un comando lungo criptico
questo è ciò che rende generato tramite Clang,

764
00:37:09,280 --> 00:37:10,460
ma nessun messaggio di errore.

765
00:37:10,460 --> 00:37:12,460
Quindi realizzare, anche se
si potrebbe ottenere completamente

766
00:37:12,460 --> 00:37:14,480
sopraffatto con la
il numero di messaggi di errore,

767
00:37:14,480 --> 00:37:17,540
che potrebbe essere solo questo a cascata fastidioso
effetto, dove Clang non capisce

768
00:37:17,540 --> 00:37:19,620
una cosa, il che significa che poi
non capisce la parola successiva,

769
00:37:19,620 --> 00:37:20,560
o la linea successiva.

770
00:37:20,560 --> 00:37:22,850
E così appena soffoca sul vostro codice.

771
00:37:22,850 --> 00:37:24,440
Ma la correzione potrebbe essere semplice.

772
00:37:24,440 --> 00:37:27,822
E concentrarsi così sempre sulla
prima linea di uscita.

773
00:37:27,822 --> 00:37:29,530
E se non lo fai
capirlo, basta guardare

774
00:37:29,530 --> 00:37:32,480
per le parole chiave che potrebbe essere
indizi, e il numero di riga,

775
00:37:32,480 --> 00:37:34,650
e il carattere, dove
questo errore potrebbe essere.

776
00:37:34,650 --> 00:37:40,328
>> Ora lasciatemi andare avanti e digitare
dot taglio su, stringhe, entrare.

777
00:37:40,328 --> 00:37:44,340
Hm, non sta dicendo ciao nulla.

778
00:37:44,340 --> 00:37:46,210
Perché?

779
00:37:46,210 --> 00:37:48,170
Ebbene, ricordo, in cui è in esecuzione?

780
00:37:48,170 --> 00:37:53,730
>> Probabilmente è bloccato al momento
in un ciclo, se si vuole, in linea di sei,

781
00:37:53,730 --> 00:37:56,950
perché Ottenere String in base alla progettazione,
scritto da personale CS50,

782
00:37:56,950 --> 00:38:00,350
è letteralmente significava solo per sedersi
lì in attesa, e in attesa,

783
00:38:00,350 --> 00:38:01,850
e in attesa di una stringa.

784
00:38:01,850 --> 00:38:03,792
Tutto quello che intendiamo per stringa è input umano.

785
00:38:03,792 --> 00:38:04,500
Allora sai cosa?

786
00:38:04,500 --> 00:38:05,166
Lasciami andare avanti.

787
00:38:05,166 --> 00:38:08,704
E proprio per un capriccio, mi permetta
digitare il mio nome, David, entrare.

788
00:38:08,704 --> 00:38:10,120
Ora ho un programma più dinamico.

789
00:38:10,120 --> 00:38:11,240
Ha detto, ciao David.

790
00:38:11,240 --> 00:38:16,280
>> Se vado avanti e correre di nuovo,
mi permetta di provare dire il nome Zamila, entrare.

791
00:38:16,280 --> 00:38:17,940
E ora abbiamo un programma dinamico.

792
00:38:17,940 --> 00:38:19,380
Non ho codificato duro mondo.

793
00:38:19,380 --> 00:38:21,760
Non ho codificato duro
nome, o David, o Zamila.

794
00:38:21,760 --> 00:38:25,350
>> Ora è molto più simile ai programmi
sappiamo, dove se ci vuole di ingresso,

795
00:38:25,350 --> 00:38:27,870
produce uscita leggermente diverso.

796
00:38:27,870 --> 00:38:31,020
Ora, questa non è la migliore
l'esperienza degli utenti, o UX.

797
00:38:31,020 --> 00:38:33,000
Corro il programma.

798
00:38:33,000 --> 00:38:35,830
>> Non so cosa dovrei
da fare, a meno che io in realtà guardo

799
00:38:35,830 --> 00:38:37,290
o ricordare il codice sorgente.

800
00:38:37,290 --> 00:38:39,640
Quindi cerchiamo di rendere l'utente
sperimentare un po 'meglio

801
00:38:39,640 --> 00:38:41,240
con la più semplice delle cose.

802
00:38:41,240 --> 00:38:44,782
Lasciami andare di nuovo in questo
il programma, e dire semplicemente printf.

803
00:38:44,782 --> 00:38:48,870
>> E mi permetta di andare avanti e dire il nome, del colon,
e uno spazio, e poi una virgola.

804
00:38:48,870 --> 00:38:51,170
E solo per i calci, senza gioco n.

805
00:38:51,170 --> 00:38:52,980
E questo è intenzionale,
perché io non voglio

806
00:38:52,980 --> 00:38:54,590
la richiesta di passare alla riga successiva.

807
00:38:54,590 --> 00:38:58,800
>> Voglio, invece, fare questo, fare stringa
ricompilare il mio codice in nuova macchina

808
00:38:58,800 --> 00:39:00,980
Codice dot taglio su stringa.

809
00:39:00,980 --> 00:39:02,460
Ah, questo è molto più bella.

810
00:39:02,460 --> 00:39:05,780
Ora io in realtà so che cosa il computer
vuole che io faccia, dargli un nome.

811
00:39:05,780 --> 00:39:10,020
>> Quindi ho intenzione di andare avanti e digitare
a Rob, entrare, e ciao, Rob.

812
00:39:10,020 --> 00:39:13,640
Così, realizzare, questo è ancora, alla fine
del giorno, solo un programma di nove linea.

813
00:39:13,640 --> 00:39:15,090
Ma abbiamo preso questi piccoli passi.

814
00:39:15,090 --> 00:39:18,380
>> Abbiamo scritto una riga con cui si
erano familiare, printf, ciao mondo.

815
00:39:18,380 --> 00:39:19,980
Poi abbiamo annullato un po 'di quello.

816
00:39:19,980 --> 00:39:21,560
E abbiamo effettivamente usato stringa get.

817
00:39:21,560 --> 00:39:23,362
E abbiamo gettato quel valore in una variabile.

818
00:39:23,362 --> 00:39:26,070
E poi siamo andati avanti e migliorato
ulteriormente con una terza linea.

819
00:39:26,070 --> 00:39:29,220
E questo processo iterativo di
la scrittura di software è veramente fondamentale.

820
00:39:29,220 --> 00:39:33,420
In CS50, e nella vita in generale,
non si dovrebbe in genere sedersi,

821
00:39:33,420 --> 00:39:36,800
avere un programma in mente, e provare a scrivere
il tutto maledettamente tutto in una volta.

822
00:39:36,800 --> 00:39:40,810
>> Sarà, inevitabilmente, provocare modo
più errori di quanto noi stessi visto qui.

823
00:39:40,810 --> 00:39:44,070
Anche io, fino ad oggi, in costante
fare altri errori stupidi,

824
00:39:44,070 --> 00:39:47,480
sono errori in realtà più difficile
che sono più difficili da capire.

825
00:39:47,480 --> 00:39:52,095
Ma si farà più errori più
righe di codice si scrive tutto in una volta.

826
00:39:52,095 --> 00:39:54,220
E così questa pratica di,
scrivere un po 'di codice

827
00:39:54,220 --> 00:39:57,930
che sei a tuo agio con, compila
esso, eseguirlo, testarlo, più in generale,

828
00:39:57,930 --> 00:40:01,370
passa poi on-- così come abbiamo mantenuto
stratificazione e stratificazione della scorsa settimana,

829
00:40:01,370 --> 00:40:04,190
la costruzione di qualcosa di molto
semplice da qualcosa di più complesso,

830
00:40:04,190 --> 00:40:05,200
fare lo stesso qui.

831
00:40:05,200 --> 00:40:08,500
Non sedersi, e cercare di
scrivere un intero problema.

832
00:40:08,500 --> 00:40:10,780
In realtà prendere questi piccoli passi.

833
00:40:10,780 --> 00:40:15,100
>> Ora, le stringhe non sono tutti
che utile a se stessi.

834
00:40:15,100 --> 00:40:18,210
Avevamo in realtà, idealmente, come ad
hanno qualcosa di diverso nel nostro toolkit.

835
00:40:18,210 --> 00:40:20,990
Quindi cerchiamo di realtà fanno esattamente questo.

836
00:40:20,990 --> 00:40:24,900
>> Lasciami andare avanti ora e montare
un programma leggermente diverso.

837
00:40:24,900 --> 00:40:28,320
E chiameremo questo int.c, per intero.

838
00:40:28,320 --> 00:40:30,870
Io vado a, allo stesso modo,
includere CS550.h.

839
00:40:30,870 --> 00:40:33,060
Ho intenzione di includere IO standard.

840
00:40:33,060 --> 00:40:36,630
E che sta per essere abbastanza comune
in questi primi giorni della classe.

841
00:40:36,630 --> 00:40:39,050
>> E ho intenzione di pronto
me stesso con una funzione principale.

842
00:40:39,050 --> 00:40:43,370
E ora invece di ottenere una stringa,
andiamo avanti e ottenere un int.

843
00:40:43,370 --> 00:40:49,285
Chiamiamolo i, e lo chiamano ottenere
int, chiudere parens, punto e virgola.

844
00:40:49,285 --> 00:40:51,410
Ed ora facciamo
qualcosa con esso, printf.

845
00:40:51,410 --> 00:40:56,190
>> Diciamo che qualcosa di simile
ciao, backslash n, comma i.

846
00:40:56,190 --> 00:41:00,010
Così sto praticamente mimando
quello che ho fatto solo un momento fa.

847
00:41:00,010 --> 00:41:01,660
Ho un segnaposto qui.

848
00:41:01,660 --> 00:41:05,150
Ho virgola i qui, perché voglio
per collegare io per quel segnaposto.

849
00:41:05,150 --> 00:41:07,250
>> Quindi cerchiamo di andare avanti e provare
compilazione di questo programma.

850
00:41:07,250 --> 00:41:10,060
Il file si chiama int.c.

851
00:41:10,060 --> 00:41:12,920
Quindi ho intenzione di dire, fare int, entrare.

852
00:41:12,920 --> 00:41:16,420
Oh mio Dio, ma niente di grave, giusto?

853
00:41:16,420 --> 00:41:17,230
C'è un errore.

854
00:41:17,230 --> 00:41:19,810
>> C'è un errore sintattico
qui in modo che il programma non può

855
00:41:19,810 --> 00:41:25,460
essere compilato all'interno int.c, linea
sette, carattere 27, formato di errore

856
00:41:25,460 --> 00:41:28,400
specifica il tipo char
Star, qualunque essa sia.

857
00:41:28,400 --> 00:41:30,020
Ma il tipo di argomento è int.

858
00:41:30,020 --> 00:41:33,110
>> Quindi anche qui, non stiamo andando a--
anche se oggi è un sacco di materiale,

859
00:41:33,110 --> 00:41:35,710
stiamo andando a sopraffare con
assolutamente ogni caratteristica di C,

860
00:41:35,710 --> 00:41:38,070
e programmazione più in generale,
in appena queste prime settimane.

861
00:41:38,070 --> 00:41:40,400
Quindi c'è spesso sarà gergo
con cui non hai familiarità.

862
00:41:40,400 --> 00:41:43,350
E, infatti, char stella è qualcosa
stiamo per tornare a

863
00:41:43,350 --> 00:41:44,830
in una settimana o tempo di due.

864
00:41:44,830 --> 00:41:47,530
>> Ma per ora, vediamo se possiamo
analizzare le parole che sono familiari.

865
00:41:47,530 --> 00:41:50,750
così disposizioni-- abbiamo sentito formato
identificatore, codice del formato prima.

866
00:41:50,750 --> 00:41:51,840
Questo è familiare.

867
00:41:51,840 --> 00:41:53,840
Type-- ma l'argomento è di tipo int.

868
00:41:53,840 --> 00:41:55,980
Aspetta un minuto, i è un int.

869
00:41:55,980 --> 00:41:59,230
>> Forse per cento s in realtà
ha un significato definito.

870
00:41:59,230 --> 00:42:00,230
E, in effetti, lo fa.

871
00:42:00,230 --> 00:42:03,101
Un numero intero, se si desidera
printf di sostituirlo,

872
00:42:03,101 --> 00:42:05,350
in realtà si deve utilizzare un
diverso identificatore di formato.

873
00:42:05,350 --> 00:42:06,890
E non si sa questo
a meno che qualcuno ti ha detto,

874
00:42:06,890 --> 00:42:07,973
o si era fatto prima.

875
00:42:07,973 --> 00:42:10,490
Ma per cento i è ciò che
può essere comunemente usato

876
00:42:10,490 --> 00:42:12,240
in printf per collegare un numero intero.

877
00:42:12,240 --> 00:42:14,920
È inoltre possibile utilizzare per cento
d per un intero decimale.

878
00:42:14,920 --> 00:42:16,490
Ma i è piacevole e semplice qui.

879
00:42:16,490 --> 00:42:17,590
Quindi andremo con quello.

880
00:42:17,590 --> 00:42:21,160
>> Ora lasciami andare avanti e
replica make int, Invio.

881
00:42:21,160 --> 00:42:23,328
Questo è un bene, senza errori.

882
00:42:23,328 --> 00:42:27,260
Dot taglio su OK int--, brutta esperienza utente,
perché non mi sono detto

883
00:42:27,260 --> 00:42:27,760
Cosa fare.

884
00:42:27,760 --> 00:42:28,426
Ma va bene.

885
00:42:28,426 --> 00:42:29,480
Sto prendendo piede rapidamente.

886
00:42:29,480 --> 00:42:36,260
>> E ora lasciami andare avanti e
digitare David, OK, Zamila, Rob.

887
00:42:36,260 --> 00:42:37,820
OK, quindi questa è una buona cosa.

888
00:42:37,820 --> 00:42:41,710
Questa volta, sto usando una funzione,
un pezzo di puzzle, chiamato get int.

889
00:42:41,710 --> 00:42:44,230
E si scopre fuori-- e ti
vedere questo più avanti nella term--

890
00:42:44,230 --> 00:42:47,730
il personale CS50 ha implementato
ottenere corda in modo tale

891
00:42:47,730 --> 00:42:50,350
che lo farà solo fisicamente
ottenere una stringa per voi.

892
00:42:50,350 --> 00:42:54,340
>> Esso ha implementato get int in
modo tale che solo sarà

893
00:42:54,340 --> 00:42:55,590
ottenere un numero intero per voi.

894
00:42:55,590 --> 00:42:57,830
E se si, l'umano,
non cooperare, è

895
00:42:57,830 --> 00:43:00,590
letteralmente solo andando a
dire riprovare, riprovare, riprovare,

896
00:43:00,590 --> 00:43:05,200
letteralmente seduto lì loop, fino a quando
costringesse con qualche numero magico,

897
00:43:05,200 --> 00:43:07,670
come 50, e ciao 50.

898
00:43:07,670 --> 00:43:11,440
>> Oppure, se corriamo di nuovo
e digitare 42, ciao 42.

899
00:43:11,440 --> 00:43:15,750
E così la funzione get int
all'interno di quel pezzo di puzzle

900
00:43:15,750 --> 00:43:19,050
è abbastanza logica, basta il pensiero,
per capire, ciò che è una parola?

901
00:43:19,050 --> 00:43:20,330
E che è un numero?

902
00:43:20,330 --> 00:43:23,165
Solo accettando, in definitiva, i numeri.

903
00:43:23,165 --> 00:43:25,690

904
00:43:25,690 --> 00:43:30,230
>> Così si scopre che questo
non è poi così espressiva.

905
00:43:30,230 --> 00:43:30,910
finora.

906
00:43:30,910 --> 00:43:33,690
Così, yay, ultima volta che abbiamo
è andato abbastanza rapidamente

907
00:43:33,690 --> 00:43:38,320
in giochi di attuazione, e l'animazione,
e opere artistiche a zero.

908
00:43:38,320 --> 00:43:42,260
E qui, ci viene contenuti
con il mondo ciao, ciao e 50.

909
00:43:42,260 --> 00:43:43,696
>> Non è tutto ciò che stimolante.

910
00:43:43,696 --> 00:43:46,070
E, in effetti, queste prime
esempi ci vorrà del tempo

911
00:43:46,070 --> 00:43:47,510
a far decollare l'eccitazione.

912
00:43:47,510 --> 00:43:49,854
Ma noi abbiamo molto di più
controllare ora, in effetti.

913
00:43:49,854 --> 00:43:51,770
E stiamo per molto
avviare rapidamente stratificazione

914
00:43:51,770 --> 00:43:53,870
in cima a questi primitive di base.

915
00:43:53,870 --> 00:43:56,370
>> Ma in primo luogo, cerchiamo di capire
quali sono i limiti.

916
00:43:56,370 --> 00:43:58,620
Infatti, una delle cose
Scratch non è così facile

917
00:43:58,620 --> 00:44:00,990
facciamo è davvero guardare
sotto la cappa,

918
00:44:00,990 --> 00:44:03,740
e capire che cosa un
computer è, che cosa può fare,

919
00:44:03,740 --> 00:44:05,250
e quali sono i suoi limiti.

920
00:44:05,250 --> 00:44:08,580
E, infatti, che la mancanza di
comprensione, potenzialmente, a lungo termine

921
00:44:08,580 --> 00:44:12,520
può portare alla nostra scrittura mistakes--
insetti, la scrittura di software insicuro che

922
00:44:12,520 --> 00:44:13,880
viene violato in qualche modo.

923
00:44:13,880 --> 00:44:17,130
>> Quindi cerchiamo di prendere alcuni passi verso la
comprensione di questo un po 'meglio

924
00:44:17,130 --> 00:44:19,710
modo, per esempio, il seguente esempio.

925
00:44:19,710 --> 00:44:23,550
Ho intenzione di andare avanti e mettere in atto
reale veloce un programma chiamato Adder.

926
00:44:23,550 --> 00:44:25,134
Come, aggiungiamo alcuni numeri insieme.

927
00:44:25,134 --> 00:44:27,800
E ho intenzione di codificare alcuni angoli
qui, e basta copiare e incollare

928
00:44:27,800 --> 00:44:30,270
dove ero prima, appena
in modo che possiamo andare avanti prima.

929
00:44:30,270 --> 00:44:33,090
Così ora ho gli inizi di base
di un programma chiamato Adder.

930
00:44:33,090 --> 00:44:34,670
>> E andiamo avanti e fare questo.

931
00:44:34,670 --> 00:44:38,680
Ho intenzione di andare avanti e
per esempio, IntX ottiene ottenere int.

932
00:44:38,680 --> 00:44:39,430
E sai una cosa?

933
00:44:39,430 --> 00:44:40,990
Facciamo una migliore esperienza utente.

934
00:44:40,990 --> 00:44:45,740
>> Quindi diciamo solo che x è, e in modo efficace
richiedere all'utente di darci x.

935
00:44:45,740 --> 00:44:50,600
E poi mi permetta di andare avanti e dire, printf
Che ne dite di y è, questa volta in attesa

936
00:44:50,600 --> 00:44:53,140
due valori da parte dell'utente.

937
00:44:53,140 --> 00:44:59,759
E poi cerchiamo di andare avanti e
per esempio, printf, la somma di x ed y è.

938
00:44:59,759 --> 00:45:01,300
E ora non voglio fare cento s.

939
00:45:01,300 --> 00:45:09,080
Voglio fare i cento, backslash
n, e quindi collegare valore della somma.

940
00:45:09,080 --> 00:45:10,620
>> Così come posso fare per fare questo?

941
00:45:10,620 --> 00:45:11,270
Sai cosa?

942
00:45:11,270 --> 00:45:12,840
Io so come usare le variabili.

943
00:45:12,840 --> 00:45:15,140
Vorrei solo dichiarare una nuova, int z.

944
00:45:15,140 --> 00:45:16,770
>> E ho intenzione di prendere una supposizione qui.

945
00:45:16,770 --> 00:45:21,470
Se ci sono segni di uguale in questo
lingua, forse posso solo fare x più y,

946
00:45:21,470 --> 00:45:23,660
fino a quando finisco il mio
pensato con un punto e virgola?

947
00:45:23,660 --> 00:45:28,170
Ora posso tornare quaggiù, collegare z,
finire questo pensiero con un punto e virgola.

948
00:45:28,170 --> 00:45:33,160
E vediamo ora, se questi
sequenze di x lines-- è ottenere int.

949
00:45:33,160 --> 00:45:34,770
Y è ottenere int.

950
00:45:34,770 --> 00:45:37,980
>> Aggiungere xey, memorizzare il valore in z--
così, ancora una volta, ricordare il segno di uguale

951
00:45:37,980 --> 00:45:38,560
Non è uguale.

952
00:45:38,560 --> 00:45:41,100
E 'assegnazione da destra a sinistra.

953
00:45:41,100 --> 00:45:45,180
E cerchiamo di stampare fuori che la somma
di X e Y non è letteralmente z,

954
00:45:45,180 --> 00:45:46,830
ma cosa c'è dentro di z.

955
00:45:46,830 --> 00:45:50,090
Quindi cerchiamo di fare Adder -
bello, nessun errore questa volta.

956
00:45:50,090 --> 00:45:53,030
Dot taglio su Adder, entrare,
x sta per essere 1.

957
00:45:53,030 --> 00:45:55,380
>> Y sta per essere 2.

958
00:45:55,380 --> 00:45:58,964
E la somma di x ed y è 3.

959
00:45:58,964 --> 00:46:00,130
Ecco, questo è tutto bello e buono.

960
00:46:00,130 --> 00:46:03,260
>> Quindi, si potrebbe immaginare che la matematica
dovrebbe funzionare in un programma come questo.

961
00:46:03,260 --> 00:46:04,040
Ma sai una cosa?

962
00:46:04,040 --> 00:46:06,904
È questa variabile, la linea
12, anche necessario?

963
00:46:06,904 --> 00:46:09,820
Non è necessario per ottenere l'abitudine
di appena memorizzare le cose in variabili

964
00:46:09,820 --> 00:46:10,980
solo perché si può.

965
00:46:10,980 --> 00:46:13,550
E, infatti, è generalmente
Considered Design Bad

966
00:46:13,550 --> 00:46:18,100
se si sta creando una variabile, chiamata
z in questo caso, memorizzare qualcosa in esso,

967
00:46:18,100 --> 00:46:21,390
e poi subito
usarlo, ma mai più.

968
00:46:21,390 --> 00:46:24,700
Perché dare qualcosa di un nome
come z se siete letteralmente

969
00:46:24,700 --> 00:46:26,770
intenzione di utilizzare tale
cosa sola volta, e così

970
00:46:26,770 --> 00:46:29,380
prossimale al punto in cui si è creato
in primo luogo,

971
00:46:29,380 --> 00:46:31,052
così vicini in termini di linee di codice?

972
00:46:31,052 --> 00:46:31,760
Allora sai cosa?

973
00:46:31,760 --> 00:46:34,480
Si scopre che C è abbastanza flessibile.

974
00:46:34,480 --> 00:46:36,586
Se Io in realtà voglio
plug-in valori qui,

975
00:46:36,586 --> 00:46:38,210
Non ho bisogno di dichiarare una nuova variabile.

976
00:46:38,210 --> 00:46:41,680
Ho potuto solo plug-in di x più
y, perché capisce C

977
00:46:41,680 --> 00:46:43,390
aritmetica, e gli operatori matematici.

978
00:46:43,390 --> 00:46:47,140
>> Così posso semplicemente dire, fare questo per la matematica,
x + y, qualunque questi valori sono,

979
00:46:47,140 --> 00:46:50,780
collegare il risultante
intero in quella stringa.

980
00:46:50,780 --> 00:46:53,730
Quindi questo potrebbe essere, anche se
solo una linea più breve,

981
00:46:53,730 --> 00:46:58,480
una migliore progettazione, un programma migliore,
perché c'è meno codice, quindi,

982
00:46:58,480 --> 00:46:59,921
meno per me capire.

983
00:46:59,921 --> 00:47:01,920
Ed è anche appena più pulito,
nella misura in cui non siamo

984
00:47:01,920 --> 00:47:04,620
l'introduzione di nuove parole,
nuovi simboli, come z,

985
00:47:04,620 --> 00:47:07,510
anche se in realtà non
servire molto di uno scopo.

986
00:47:07,510 --> 00:47:12,890
>> Purtroppo, la matematica non è
tutto ciò che a volte affidabili.

987
00:47:12,890 --> 00:47:15,270
Andiamo avanti e fare questo.

988
00:47:15,270 --> 00:47:18,200
Ho intenzione di andare avanti
ora e fare quanto segue.

989
00:47:18,200 --> 00:47:27,650
>> Facciamo printf, cento i, oltre cento
I sono cento i, backslash n.

990
00:47:27,650 --> 00:47:32,240
E ho intenzione di fare questo-- xyx più y.

991
00:47:32,240 --> 00:47:34,821
Così Sto solo andando a riscrivere
questo in modo leggermente diverso qui.

992
00:47:34,821 --> 00:47:36,320
Vorrei solo fare un controllo di integrità rapido.

993
00:47:36,320 --> 00:47:37,986
Anche in questo caso, cerchiamo di non andare avanti di noi stessi.

994
00:47:37,986 --> 00:47:41,420
Fai la vipera, dot barra vipera.

995
00:47:41,420 --> 00:47:44,950
x è 1, y è 2, 1 + 2 fa 3.

996
00:47:44,950 --> 00:47:45,870
Quindi, questo è un bene.

997
00:47:45,870 --> 00:47:49,060
Ma cerchiamo di complicare questo ora
un po ', e creare un nuovo file.

998
00:47:49,060 --> 00:47:53,350
>> Ho intenzione di chiamare questa,
dire, int, plurali per gli interi.

999
00:47:53,350 --> 00:47:55,980
Permettetemi di iniziare dove ero un attimo fa.

1000
00:47:55,980 --> 00:47:57,770
Ma ora facciamo un paio di altre linee.

1001
00:47:57,770 --> 00:48:03,430
Mi permetta di andare avanti e fare quanto segue,
printf, cento i, meno per cento i,

1002
00:48:03,430 --> 00:48:08,959
è cento i, comma x, comma YX meno y.

1003
00:48:08,959 --> 00:48:10,750
Così sto facendo un po '
matematica diverso lì.

1004
00:48:10,750 --> 00:48:11,624
Facciamo un altro.

1005
00:48:11,624 --> 00:48:16,610
Così per cento i tempi per cento
i è cento i, backslash n.

1006
00:48:16,610 --> 00:48:21,430
Facciamo plug-in x, y, e tempi di X Y.

1007
00:48:21,430 --> 00:48:24,530
Useremo l'asterisco su
il computer per i tempi.

1008
00:48:24,530 --> 00:48:26,390
>> Non si utilizza x. x è
un nome di variabile qui.

1009
00:48:26,390 --> 00:48:28,270
Si utilizza la stella per la moltiplicazione.

1010
00:48:28,270 --> 00:48:29,020
Facciamo un altro.

1011
00:48:29,020 --> 00:48:34,580
Printf per cento I, diviso
per cento i, è cento i,

1012
00:48:34,580 --> 00:48:40,460
n backslash. xy diviso per y--
in modo da utilizzare la barra in C

1013
00:48:40,460 --> 00:48:41,502
a fare la divisione.

1014
00:48:41,502 --> 00:48:42,460
E facciamo un altro.

1015
00:48:42,460 --> 00:48:47,920

1016
00:48:47,920 --> 00:48:55,240
Resto di cento i, diviso
per cento i, è cento i.

1017
00:48:55,240 --> 00:48:59,550
xy-- e ora resto
è ciò che rimane.

1018
00:48:59,550 --> 00:49:02,980
Quando si tenta un dividendo
denominatore in un numeratore

1019
00:49:02,980 --> 00:49:05,570
quanto è rimasto che
non si poteva dividere fuori?

1020
00:49:05,570 --> 00:49:07,910
>> Quindi non c'è davvero,
necessariamente, un simbolo

1021
00:49:07,910 --> 00:49:09,470
abbiamo usato in grado di scuola per questo.

1022
00:49:09,470 --> 00:49:13,830
Ma c'è in C. Si può
dire x modulo y, dove

1023
00:49:13,830 --> 00:49:18,000
questo segno per cento in questo context--
confusamente quando sei dentro

1024
00:49:18,000 --> 00:49:20,170
delle virgolette,
all'interno di printf, per cento

1025
00:49:20,170 --> 00:49:21,830
viene utilizzato come identificatore di formato.

1026
00:49:21,830 --> 00:49:25,420
>> Quando si utilizza per cento al di fuori di
che in un'espressione matematica,

1027
00:49:25,420 --> 00:49:29,910
è l'operatore modulo per modulare
arithmetic-- per i nostri scopi

1028
00:49:29,910 --> 00:49:33,650
qui, significa semplicemente, che cosa è la
restante x diviso per y?

1029
00:49:33,650 --> 00:49:36,130
Quindi x diviso per y è x barra y.

1030
00:49:36,130 --> 00:49:38,220
Nei il resto di x diviso per y?

1031
00:49:38,220 --> 00:49:41,780
E 'x y mod, come programmatore direbbe.

1032
00:49:41,780 --> 00:49:48,300
>> Quindi, se ho commesso errori qui, mi permetta
andare avanti e fare interi, plurali, bello,

1033
00:49:48,300 --> 00:49:50,010
e int oblique punti.

1034
00:49:50,010 --> 00:49:55,270
E andiamo avanti e
fare, diciamo, 1, 10.

1035
00:49:55,270 --> 00:49:58,390
Va bene, 1 più 10 è 11, di controllo.

1036
00:49:58,390 --> 00:50:01,240
1 meno 10 è negativo 9, controllare.

1037
00:50:01,240 --> 00:50:03,420
>> 1 volte 10 è 10, di controllo.

1038
00:50:03,420 --> 00:50:07,090
1 diviso 10 è--
OK, ci salteremo che uno.

1039
00:50:07,090 --> 00:50:09,480
Resto di 1 diviso 10 è 1.

1040
00:50:09,480 --> 00:50:10,680
È corretto.

1041
00:50:10,680 --> 00:50:12,630
Ma c'è un bug in qui.

1042
00:50:12,630 --> 00:50:15,390
>> Quindi quello che ho messo la mia
consegnare, non è corretto.

1043
00:50:15,390 --> 00:50:16,670
Voglio dire, è vicino a 0.

1044
00:50:16,670 --> 00:50:20,670
1 diviso per 10, si sa, se siamo
taglio alcuni angoli, certo, è pari a zero.

1045
00:50:20,670 --> 00:50:28,050
Ma in realtà dovrebbe essere 1/10,
0.1 o 0.10, 0.1000, o così via.

1046
00:50:28,050 --> 00:50:30,600
>> Non dovrebbe essere veramente zero.

1047
00:50:30,600 --> 00:50:35,990
Beh, si scopre che il computer è
fare letteralmente quello che abbiamo detto di fare.

1048
00:50:35,990 --> 00:50:39,460
Stiamo facendo la matematica come x diviso per y.

1049
00:50:39,460 --> 00:50:44,680
Ed entrambi X e Y, per le linee
di codice in precedenza, sono interi.

1050
00:50:44,680 --> 00:50:50,440
>> Inoltre, sulla linea 15, siamo
dicendo printf, ehi, printf plug-in

1051
00:50:50,440 --> 00:50:54,230
un numero intero, plug-in un numero intero,
plug-in integer-- specificamente

1052
00:50:54,230 --> 00:50:57,580
x, quindi y, e poi x
diviso per y. xey sono interi.

1053
00:50:57,580 --> 00:50:59,060
Siamo a posto lì.

1054
00:50:59,060 --> 00:51:01,250
>> Ma ciò che è x diviso per x?

1055
00:51:01,250 --> 00:51:06,790
x diviso per y dovrebbe essere,
matematicamente, 1/10, o 0.1,

1056
00:51:06,790 --> 00:51:11,600
che è un numero reale, un numero reale
avere, potenzialmente, un punto decimale.

1057
00:51:11,600 --> 00:51:13,230
Non è un numero intero.

1058
00:51:13,230 --> 00:51:18,290
>> Ma ciò che è la più vicina
integer a 1/10, o 0.1?

1059
00:51:18,290 --> 00:51:21,114
Sì, che tipo di è pari a zero.

1060
00:51:21,114 --> 00:51:22,030
0.1 è così tanto.

1061
00:51:22,030 --> 00:51:22,890
E 1 è così tanto.

1062
00:51:22,890 --> 00:51:25,870
Quindi, è più vicino al 1/10
0 piuttosto che uno.

1063
00:51:25,870 --> 00:51:30,800
>> E così quello che C sta facendo per noi--
tipo di perché abbiamo detto che a--

1064
00:51:30,800 --> 00:51:32,600
è troncando quella intero.

1065
00:51:32,600 --> 00:51:40,540
E 'prendendo il valore, che è ancora
doveva essere qualcosa di simile a 0.1000,

1066
00:51:40,540 --> 00:51:41,800
0 e così via.

1067
00:51:41,800 --> 00:51:45,320
Ed è troncare tutto
dopo il punto decimale

1068
00:51:45,320 --> 00:51:47,510
in modo che tutto questo
roba, perché non è così

1069
00:51:47,510 --> 00:51:51,910
inserire nella nozione di un numero intero, che
è solo un numero come negativo 1, 0, 1,

1070
00:51:51,910 --> 00:51:55,830
su e giù, si butta via tutto
dopo il punto decimale perché

1071
00:51:55,830 --> 00:51:59,020
Non può andare bene un punto decimale
in un numero intero per definizione.

1072
00:51:59,020 --> 00:52:01,290
>> Quindi la risposta qui è zero.

1073
00:52:01,290 --> 00:52:02,600
Quindi, come possiamo risolvere questo problema?

1074
00:52:02,600 --> 00:52:04,400
Abbiamo bisogno di un'altra soluzione tutti insieme.

1075
00:52:04,400 --> 00:52:06,880
E possiamo farlo, come segue.

1076
00:52:06,880 --> 00:52:12,820
>> Lasciami andare avanti e creare un nuovo
il file, questo chiamato floats.c.

1077
00:52:12,820 --> 00:52:16,500
E salvarlo qui in
stessa directory, float.c.

1078
00:52:16,500 --> 00:52:19,360

1079
00:52:19,360 --> 00:52:23,260
E mi permetta di andare avanti e copiare
alcuni di tale codice precedente.

1080
00:52:23,260 --> 00:52:27,690
>> Ma invece di ottenere
un int, facciamolo.

1081
00:52:27,690 --> 00:52:31,037
Datemi un valore in virgola mobile
chiamato x. qualora un punto floating

1082
00:52:31,037 --> 00:52:33,370
il valore è solo letteralmente
qualcosa con una virgola mobile.

1083
00:52:33,370 --> 00:52:34,410
Può spostarsi a sinistra, a destra.

1084
00:52:34,410 --> 00:52:35,530
Si tratta di un numero reale.

1085
00:52:35,530 --> 00:52:38,050
>> E mi permetta di non chiamo
ottenere int, ma ottenere galleggiante,

1086
00:52:38,050 --> 00:52:41,420
che era anche tra i menu
di opzioni nella libreria C250.

1087
00:52:41,420 --> 00:52:43,220
Cambiamo y ad un galleggiante.

1088
00:52:43,220 --> 00:52:45,000
Così questo diventa ottenere galleggiante.

1089
00:52:45,000 --> 00:52:47,620
>> E ora, non vogliamo collegare int.

1090
00:52:47,620 --> 00:52:53,130
Si scopre che dobbiamo usare per cento
f per galleggiare, cento f per float,

1091
00:52:53,130 --> 00:52:54,560
e ora salvarlo.

1092
00:52:54,560 --> 00:53:01,220
E ora, incrociamo le dita, fanno
galleggianti, bello, carri oblique punti.

1093
00:53:01,220 --> 00:53:04,280
x sta per essere uno 1. y
Sta per essere di nuovo 10.

1094
00:53:04,280 --> 00:53:08,240
>> E, bello, OK mia aggiunta è corretta.

1095
00:53:08,240 --> 00:53:10,240
Speravo in più,
ma ho dimenticato di scriverlo.

1096
00:53:10,240 --> 00:53:13,250
Quindi andiamo a correggere questo errore logico.

1097
00:53:13,250 --> 00:53:16,280
>> Andiamo avanti e afferrare quanto segue.

1098
00:53:16,280 --> 00:53:18,080
Dobbiamo solo fare un po 'di copia e incolla.

1099
00:53:18,080 --> 00:53:20,080
E io vado a dire meno.

1100
00:53:20,080 --> 00:53:21,890
>> E ho intenzione di dire volte.

1101
00:53:21,890 --> 00:53:24,060
E io vado a dire divisi.

1102
00:53:24,060 --> 00:53:28,240
E io non ho intenzione di fare modulo,
che non è così germano qui,

1103
00:53:28,240 --> 00:53:33,690
divisi da f, e tempi plus--
OK, facciamolo di nuovo.

1104
00:53:33,690 --> 00:53:44,210
>> Rendere carri, carri oblique punti,
e 1, 10, e- bello, no, OK.

1105
00:53:44,210 --> 00:53:45,250
Quindi sono un idiota.

1106
00:53:45,250 --> 00:53:47,000
Quindi questo è molto comune
in informatica

1107
00:53:47,000 --> 00:53:49,780
di fare errori stupidi come questo.

1108
00:53:49,780 --> 00:53:53,100
>> Ai fini pedagogici,
quello che volevo veramente fare

1109
00:53:53,100 --> 00:53:57,410
è stato cambiare la scienza qui
al più, a meno, a volte,

1110
00:53:57,410 --> 00:54:01,140
e di dividere, come si spera
notato nel corso di questo esercizio.

1111
00:54:01,140 --> 00:54:04,700
Così ora cerchiamo di ri-compilare questo
il programma, fare carri oblique punti.

1112
00:54:04,700 --> 00:54:07,950
>> E per la terza volta, facciamo
vedere se soddisfa le mie aspettative.

1113
00:54:07,950 --> 00:54:21,480
1, 10, entrare, sì, OK, 1.000,
diviso per 10.000, è 0.100000.

1114
00:54:21,480 --> 00:54:24,952
E si scopre che possiamo controllare il numero di
numeri sono dopo quei punti decimali.

1115
00:54:24,952 --> 00:54:25,660
Abbiamo effettivamente sarà.

1116
00:54:25,660 --> 00:54:26,790
Torneremo a questo.

1117
00:54:26,790 --> 00:54:28,440
>> Ma ora, infatti, la matematica è corretta.

1118
00:54:28,440 --> 00:54:30,090
Così, ancora una volta, qual è l'asporto qui?

1119
00:54:30,090 --> 00:54:33,050
Risulta che in C, ci sono
Non appena strings-- e, di fatto,

1120
00:54:33,050 --> 00:54:36,120
Non ci sono davvero, perché noi
aggiungere quelli con la libreria CS50.

1121
00:54:36,120 --> 00:54:37,710
Ma non ci sono solo int.

1122
00:54:37,710 --> 00:54:38,990
>> Ci sono anche galleggia.

1123
00:54:38,990 --> 00:54:42,810
E si scopre una serie di altri dati
tipi di troppo, che useremo in poco tempo.

1124
00:54:42,810 --> 00:54:46,270
Si scopre che se si vuole un unico
carattere, non è una stringa di caratteri,

1125
00:54:46,270 --> 00:54:47,610
è possibile utilizzare solo un carattere.

1126
00:54:47,610 --> 00:54:52,350
>> Scopre che se si desidera un bool,
un valore booleano, vero o solo falso,

1127
00:54:52,350 --> 00:54:56,840
grazie alla biblioteca CS50, abbiamo
aggiunto alla C il tipo di dati bool pure.

1128
00:54:56,840 --> 00:54:59,180
Ma è presente anche in
molte altre lingue.

1129
00:54:59,180 --> 00:55:04,130
E si scopre che a volte si
bisogno di numeri più grandi poi vengono di default

1130
00:55:04,130 --> 00:55:05,210
con interi e galleggianti.

1131
00:55:05,210 --> 00:55:10,590
>> E, infatti, un doppio è un numero
che utilizza non a 32 bit, ma 64 bit.

1132
00:55:10,590 --> 00:55:14,990
E un lungo tempo è un numero che
usa non 32, ma 64 bit bit,

1133
00:55:14,990 --> 00:55:19,190
rispettivamente, per virgola mobile
valori e numeri interi, rispettivamente.

1134
00:55:19,190 --> 00:55:22,780
Quindi cerchiamo di realtà ora
vedere questo in azione.

1135
00:55:22,780 --> 00:55:26,150
>> Ho intenzione di andare avanti qui
e montare un altro programma.

1136
00:55:26,150 --> 00:55:32,020
Qui, ho intenzione di andare avanti
e non comprendono CS50.h.

1137
00:55:32,020 --> 00:55:34,910
E lasciami andare, includere standard di io.h.

1138
00:55:34,910 --> 00:55:37,320
>> E si noterà qualcosa
funky sta accadendo qui.

1139
00:55:37,320 --> 00:55:40,592
Non è la codifica a colori le cose in
allo stesso modo come prima.

1140
00:55:40,592 --> 00:55:43,550
E si scopre, è perché io
Non hanno dato la cosa un nome di file.

1141
00:55:43,550 --> 00:55:47,270
>> Ho intenzione di chiamare questo uno
sizeof.c, e ha colpito Salva.

1142
00:55:47,270 --> 00:55:51,039
E cosa succede al mio molto
codice bianco contro quello sfondo nero.

1143
00:55:51,039 --> 00:55:52,830
Ora, almeno c'è
un po 'di viola in là.

1144
00:55:52,830 --> 00:55:54,490
Ed è sintassi evidenziata.

1145
00:55:54,490 --> 00:55:57,700
>> Questo perché, molto semplicemente, non ho
ha detto l'IDE tipo di file

1146
00:55:57,700 --> 00:56:01,060
è dandogli un nome, e
in particolare l'estensione del file.

1147
00:56:01,060 --> 00:56:03,620
Ora, andiamo avanti e fare questo.

1148
00:56:03,620 --> 00:56:08,910
Ho intenzione di andare avanti e molto
semplicemente stampare il bool following--

1149
00:56:08,910 --> 00:56:11,080
è cento LU.

1150
00:56:11,080 --> 00:56:12,950
>> Torneremo a
che in un attimo.

1151
00:56:12,950 --> 00:56:15,840
E poi ho intenzione di
formato di stampa di bool.

1152
00:56:15,840 --> 00:56:18,170
E ora, solo per risparmiare
io stesso un po 'di tempo, sono

1153
00:56:18,170 --> 00:56:20,280
andando a fare un intero
mazzo di questi immediatamente.

1154
00:56:20,280 --> 00:56:24,620
E, in particolare, ho intenzione di
cambiare questo ad un char e char.

1155
00:56:24,620 --> 00:56:27,760
Questo, ho intenzione di cambiare
per una matrimoniale e una doppia.

1156
00:56:27,760 --> 00:56:31,440
>> Questo, ho intenzione di cambiare
ad un galleggiante e un galleggiante.

1157
00:56:31,440 --> 00:56:35,670
Questo, ho intenzione di
cambiare per un int e un int.

1158
00:56:35,670 --> 00:56:38,660
E questo, ho intenzione
cambiare per un lungo tempo.

1159
00:56:38,660 --> 00:56:40,840
Ed è ancora in corso
un lungo tempo, molto lungo.

1160
00:56:40,840 --> 00:56:44,572
>> E poi, infine, ho dato
io stesso uno di troppo, stringa.

1161
00:56:44,572 --> 00:56:47,030
Si scopre che in C, non c'è
l'operatore speciale chiamato

1162
00:56:47,030 --> 00:56:50,260
dimensioni che è letteralmente
andando a, quando viene eseguito,

1163
00:56:50,260 --> 00:56:52,099
dirci che il formato di
ciascuna di queste variabili.

1164
00:56:52,099 --> 00:56:53,890
E questo è un modo, ora,
ci si può collegare indietro

1165
00:56:53,890 --> 00:56:57,140
alla discussione della scorsa settimana
di dati e di rappresentanza.

1166
00:56:57,140 --> 00:57:00,330
>> Lasciami andare avanti e compilare
dimensione della dimensione barra di punti di.

1167
00:57:00,330 --> 00:57:01,210
E vediamo.

1168
00:57:01,210 --> 00:57:05,210
Si scopre che in C,
in particolare sulla CS50 IDE,

1169
00:57:05,210 --> 00:57:08,170
in particolare sulla
sistema operativo Ubuntu,

1170
00:57:08,170 --> 00:57:11,100
che è operativo a 64 bit
sistema in questo caso,

1171
00:57:11,100 --> 00:57:14,189
un bool sta per
utilizzare un byte di spazio.

1172
00:57:14,189 --> 00:57:16,480
Ecco come dimensioni è misurato,
non in bit, ma in byte.

1173
00:57:16,480 --> 00:57:18,690
E ricordare che un byte è otto bit.

1174
00:57:18,690 --> 00:57:22,030
Quindi un bool, anche se si
tecnicamente solo bisogno di un 0 o 1,

1175
00:57:22,030 --> 00:57:24,092
è un po 'uno spreco
come abbiamo implementato esso.

1176
00:57:24,092 --> 00:57:26,800
In realtà intenzione di utilizzare un intero
byte-- così tutti gli zeri, sono forse

1177
00:57:26,800 --> 00:57:31,050
tutti quelli, o qualcosa del genere,
o solo uno tra 1 otto bit.

1178
00:57:31,050 --> 00:57:34,962
>> Un char, nel frattempo, utilizzato per un personaggio
come un carattere ASCII per la scorsa settimana,

1179
00:57:34,962 --> 00:57:36,170
sta per essere un personaggio.

1180
00:57:36,170 --> 00:57:42,340
E che sincronizza con il nostro concetto di
essendo non più di 256 bits-- piuttosto,

1181
00:57:42,340 --> 00:57:45,360
sincronizza con esso non essendo
più di 8 bit, che

1182
00:57:45,360 --> 00:57:47,450
ci dà fino a 256 valori.

1183
00:57:47,450 --> 00:57:49,680
Un doppio sta per
essere di 8 byte o 64 bit.

1184
00:57:49,680 --> 00:57:50,510
>> Un galleggiante è 4.

1185
00:57:50,510 --> 00:57:51,690
Un int è 4.

1186
00:57:51,690 --> 00:57:52,980
Una lunga, lunga è 8.

1187
00:57:52,980 --> 00:57:54,716
E una stringa è 8.

1188
00:57:54,716 --> 00:57:55,840
Ma non ti preoccupare di questo.

1189
00:57:55,840 --> 00:57:57,340
Stiamo andando a buccia indietro quel livello.

1190
00:57:57,340 --> 00:57:59,940
Si scopre, le stringhe possono
essere più lungo di 8 byte.

1191
00:57:59,940 --> 00:58:02,310
>> E, in effetti, abbiamo scritto
stringhe già, ciao mondo,

1192
00:58:02,310 --> 00:58:03,700
più di 8 byte.

1193
00:58:03,700 --> 00:58:06,270
Ma torneremo a
che in un attimo.

1194
00:58:06,270 --> 00:58:09,690
Ma il take via qui è il seguente.

1195
00:58:09,690 --> 00:58:15,320
>> Ogni computer ha soltanto una limitata
quantità di memoria e di spazio.

1196
00:58:15,320 --> 00:58:17,860
È possibile memorizzare solo così tante
file sul vostro Mac o PC.

1197
00:58:17,860 --> 00:58:23,030
È possibile memorizzare solo tanti programmi in
RAM in esecuzione in una sola volta, necessariamente, anche

1198
00:58:23,030 --> 00:58:26,360
con memoria virtuale, perché
si dispone di una quantità limitata di RAM.

1199
00:58:26,360 --> 00:58:28,990
>> E proprio per un'Immagine-- se
non hai mai aperto un computer portatile

1200
00:58:28,990 --> 00:58:31,300
o ordinato memoria aggiuntiva
per un computer,

1201
00:58:31,300 --> 00:58:33,670
potrebbe non sapere che
all'interno del computer

1202
00:58:33,670 --> 00:58:36,590
è qualcosa che sembra
un po 'come questo.

1203
00:58:36,590 --> 00:58:40,540
Quindi questa è solo una società comune denominata
Fondamentale che rende RAM per i computer.

1204
00:58:40,540 --> 00:58:43,620
E la RAM è dove i programmi
vivere mentre sono in esecuzione.

1205
00:58:43,620 --> 00:58:46,630
>> Così su ogni Mac o PC, quando si fa doppio
fare clic su un programma e si apre,

1206
00:58:46,630 --> 00:58:48,921
e si apre qualche documento Word
o qualcosa di simile,

1207
00:58:48,921 --> 00:58:51,764
memorizza temporaneamente nella
RAM, perché la RAM è più veloce

1208
00:58:51,764 --> 00:58:53,680
di disco rigido, o
il disco a stato solido.

1209
00:58:53,680 --> 00:58:56,600
Quindi è proprio dove i programmi vanno
a vivere quando sono in esecuzione,

1210
00:58:56,600 --> 00:58:58,060
o quando vengono utilizzati i file.

1211
00:58:58,060 --> 00:59:00,890
>> In modo da avere le cose che sembrano
come questo all'interno del vostro computer portatile,

1212
00:59:00,890 --> 00:59:03,320
o cose un po 'più grandi
all'interno del desktop.

1213
00:59:03,320 --> 00:59:07,440
Ma la chiave è che si hanno solo una
numero finito di queste cose.

1214
00:59:07,440 --> 00:59:11,230
E c'è solo una quantità finita di
hardware seduto su questa scrivania a destra

1215
00:59:11,230 --> 00:59:11,730
Qui.

1216
00:59:11,730 --> 00:59:15,920
>> Quindi, sicuramente, non possiamo immagazzinare
numeri infinitamente lunghi.

1217
00:59:15,920 --> 00:59:19,030
E, tuttavia, se si pensa di nuovo a
scuola elementare, quante cifre può

1218
00:59:19,030 --> 00:59:21,400
si ha a destra
di un punto decimale?

1219
00:59:21,400 --> 00:59:24,680
Del resto, quante cifre può
si deve alla sinistra di un punto decimale?

1220
00:59:24,680 --> 00:59:26,300
In realtà, infiniti.

1221
00:59:26,300 --> 00:59:30,840
>> Ora, noi esseri umani solo potrebbe
Sai come pronunciare milioni,

1222
00:59:30,840 --> 00:59:34,990
e miliardi, miliardi di dollari, e
quadrilioni, e quintilioni.

1223
00:59:34,990 --> 00:59:39,370
E sto spingendo i limiti della mia
understanding-- o my-- ho capito

1224
00:59:39,370 --> 00:59:41,110
i numeri, ma il mio
Pronuncia di numeri.

1225
00:59:41,110 --> 00:59:44,720
Ma possono ottenere infinitamente grande con
un numero infinito di cifre a sinistra

1226
00:59:44,720 --> 00:59:47,050
oa destra del punto decimale.

1227
00:59:47,050 --> 00:59:50,040
>> Ma i computer hanno solo un
quantità limitata di memoria,

1228
00:59:50,040 --> 00:59:53,510
un numero finito di transistor, un
numero finito di lampadine all'interno.

1229
00:59:53,510 --> 00:59:57,350
Che cosa succede quando
si esaurisce lo spazio?

1230
00:59:57,350 --> 00:59:59,620
In altre parole, se
ripensare a settimana scorsa

1231
00:59:59,620 --> 01:00:03,160
quando abbiamo parlato di numeri
stessi di essere rappresentato in binario,

1232
01:00:03,160 --> 01:00:05,480
supponiamo che abbiamo
questo valore a 8 bit qui.

1233
01:00:05,480 --> 01:00:08,290
>> E abbiamo sette 1 e uno 0.

1234
01:00:08,290 --> 01:00:10,827
E supponiamo che vogliamo
aggiungere 1 a questo valore.

1235
01:00:10,827 --> 01:00:12,410
Questo è davvero un grande numero di adesso.

1236
01:00:12,410 --> 01:00:16,610
>> Si tratta di 254, se non ricordo
la matematica dalla settimana scorsa destra.

1237
01:00:16,610 --> 01:00:19,480
Ma cosa succede se cambio
che più a destra 0 a 1?

1238
01:00:19,480 --> 01:00:22,800
Il numero intero, di
Naturalmente, diventa otto 1 di.

1239
01:00:22,800 --> 01:00:24,050
Quindi siamo ancora buono.

1240
01:00:24,050 --> 01:00:27,204
>> E che rappresenta probabilmente
255, anche se a seconda del contesto

1241
01:00:27,204 --> 01:00:29,120
potrebbe effettivamente rappresentare
un numero negativo.

1242
01:00:29,120 --> 01:00:31,240
Ma più su che un'altra volta.

1243
01:00:31,240 --> 01:00:34,220
Questo si sente come se fosse su
il più in alto che posso contare.

1244
01:00:34,220 --> 01:00:35,290
>> Ora, è solo 8 bit.

1245
01:00:35,290 --> 01:00:38,170
E il mio Mac, sicuramente, ha senso
più di 8 bit di memoria.

1246
01:00:38,170 --> 01:00:39,170
Ma ha finito.

1247
01:00:39,170 --> 01:00:43,230
Così lo stesso argomento vale, anche se
avere più di questi sullo schermo.

1248
01:00:43,230 --> 01:00:47,020
>> Ma cosa succede se si è
memorizzare questo numero, 255,

1249
01:00:47,020 --> 01:00:49,290
e si desidera contare 1 po 'più alto?

1250
01:00:49,290 --> 01:00:51,600
Vuoi andare 255-256.

1251
01:00:51,600 --> 01:00:55,800
Il problema, naturalmente, è che se si
iniziare a contare da zero come la settimana scorsa,

1252
01:00:55,800 --> 01:00:59,670
Non si può contare più in alto
come 256, per non parlare di 257,

1253
01:00:59,670 --> 01:01:02,584
per non parlare di 258, m perché ciò che
accade quando si aggiunge un 1?

1254
01:01:02,584 --> 01:01:05,000
Se fate la vecchia scuola elementare
approccio, si mette un 1 qui,

1255
01:01:05,000 --> 01:01:08,150
e poi 1 più 1 è 2, ma questo è
davvero uno zero, si portano il 1,

1256
01:01:08,150 --> 01:01:09,695
portare il 1, trasportare il 1.

1257
01:01:09,695 --> 01:01:12,620
Tutte queste cose,
questi 1 di, vanno a zero.

1258
01:01:12,620 --> 01:01:17,820
E si finisce, sì, come qualcuno
sottolineato, un 1 sul lato sinistro.

1259
01:01:17,820 --> 01:01:22,540
Ma tutto è possibile
effettivamente vedere e montare in memoria

1260
01:01:22,540 --> 01:01:27,960
è appena otto 0 di, vale a dire
ad un certo punto, se si, un computer,

1261
01:01:27,960 --> 01:01:32,490
provato a contare abbastanza in alto, sei
andando ad avvolgere intorno, sembrerebbe,

1262
01:01:32,490 --> 01:01:35,850
a zero, o forse addirittura negativo
numeri, che sono ancora minore di zero.

1263
01:01:35,850 --> 01:01:37,260
>> E possiamo tipo di vedere questo.

1264
01:01:37,260 --> 01:01:39,900
Lasciami andare avanti e scrivere
un vero e proprio programma veloce qui.

1265
01:01:39,900 --> 01:01:43,690
Lasciami andare avanti e scrivere
un programma chiamato overflow.

1266
01:01:43,690 --> 01:01:49,980
Includi CS50.h, comprendono
standard di IO.h-- oh,

1267
01:01:49,980 --> 01:01:51,730
Mi mancava la mia evidenziazione della sintassi.

1268
01:01:51,730 --> 01:01:54,440
Quindi cerchiamo di salvare questo come overflow.c.

1269
01:01:54,440 --> 01:01:57,084
>> E ora int void-- principale
e in poco tempo, ci

1270
01:01:57,084 --> 01:01:59,500
tornare a spiegare perché
continuiamo a scrivere int void main.

1271
01:01:59,500 --> 01:02:02,080
Ma per ora, facciamo solo fare
esso, dando per scontato.

1272
01:02:02,080 --> 01:02:06,200
Diamo me un int,
e inizializzare a 0.

1273
01:02:06,200 --> 01:02:11,716
>> Facciamo quindi fare per int ottengo zero--
in realtà, cerchiamo di fare un ciclo infinito

1274
01:02:11,716 --> 01:02:12,590
e vedere cosa succede.

1275
01:02:12,590 --> 01:02:22,440
Mentre vero, allora cerchiamo di stampare fuori n
è cento i, backslash n, plug-in n.

1276
01:02:22,440 --> 01:02:27,200
Ma, ora, facciamo n ottiene più 1 n.

1277
01:02:27,200 --> 01:02:29,660
>> In altre parole, su ciascun
iterazione di questo ciclo infinito,

1278
01:02:29,660 --> 01:02:32,550
diamo il valore di n,
e aggiungere 1 ad esso, e poi

1279
01:02:32,550 --> 01:02:34,350
memorizzare il risultato nel n a sinistra.

1280
01:02:34,350 --> 01:02:37,150
E, infatti, abbiamo visto sintassi
un po 'come questo, per breve tempo.

1281
01:02:37,150 --> 01:02:39,730
Un trucco fresco è invece
di scrivere tutto questo fuori,

1282
01:02:39,730 --> 01:02:42,770
si può effettivamente dire un n più uguale a 1.

1283
01:02:42,770 --> 01:02:47,480
>> Oppure, se si vuole veramente essere di fantasia,
si può dire n plus plus e virgola.

1284
01:02:47,480 --> 01:02:50,130
Ma questi ultimi due sono appena
quello che noi chiameremmo zucchero sintattico

1285
01:02:50,130 --> 01:02:50,790
per la prima cosa.

1286
01:02:50,790 --> 01:02:53,456
>> La prima cosa è più esplicito,
tutto bene, del tutto corretta.

1287
01:02:53,456 --> 01:02:55,470
Ma questo è più comune, dirò.

1288
01:02:55,470 --> 01:02:57,210
Quindi faremo questo solo per un momento.

1289
01:02:57,210 --> 01:03:01,685
>> Vediamo ora fare troppo pieno, che suona
piuttosto inquietante, troppo pieno barra dot.

1290
01:03:01,685 --> 01:03:04,380

1291
01:03:04,380 --> 01:03:09,852
Vediamo, n sta facendo abbastanza grande.

1292
01:03:09,852 --> 01:03:11,310
Ma pensiamo, quanto grande può ottenere n?

1293
01:03:11,310 --> 01:03:12,870
>> n è un int.

1294
01:03:12,870 --> 01:03:16,400
Abbiamo visto un momento fa, con le dimensioni di
esempio che un int è di quattro byte.

1295
01:03:16,400 --> 01:03:22,070
Sappiamo dalla settimana scorsa, quattro byte è
32 bit, per 8 volte 4, che di 32.

1296
01:03:22,070 --> 01:03:23,460
Che sta per essere 4 miliardi.

1297
01:03:23,460 --> 01:03:25,802
>> E siamo fino a 800.000.

1298
01:03:25,802 --> 01:03:28,510
Si tratta di andare a prendere per sempre a
contare su quanto mi sarà possibile.

1299
01:03:28,510 --> 01:03:30,635
Quindi ho intenzione di andare avanti,
come si potrebbe in breve tempo,

1300
01:03:30,635 --> 01:03:34,910
e ha colpito di controllo C-- francamente, di controllo
C, un sacco, dove il controllo C in generale

1301
01:03:34,910 --> 01:03:36,034
mezzi annullare.

1302
01:03:36,034 --> 01:03:38,200
Sfortunatamente, poiché questo
è in esecuzione nel cloud,

1303
01:03:38,200 --> 01:03:41,190
a volte la nube è
sputando tanta roba,

1304
01:03:41,190 --> 01:03:44,180
così tanto l'uscita, sta andando a
prendere un po 'di tempo per il mio ingresso

1305
01:03:44,180 --> 01:03:45,630
per arrivare al cloud.

1306
01:03:45,630 --> 01:03:49,240
Così, anche se mi ha colpito
Controllo C pochi secondi fa,

1307
01:03:49,240 --> 01:03:53,110
questo è sicuramente il lato
effetto di un ciclo infinito.

1308
01:03:53,110 --> 01:03:56,070
>> E così in questi casi, siamo
intenzione di lasciare che si tratti.

1309
01:03:56,070 --> 01:03:59,050
E stiamo per aggiungere un altro
finestra di terminale qui

1310
01:03:59,050 --> 01:04:03,186
con il plus, che ovviamente non lo fa
così, dal momento che è ancora pensando.

1311
01:04:03,186 --> 01:04:05,310
E andiamo avanti ed essere
un po 'più ragionevole.

1312
01:04:05,310 --> 01:04:07,768
>> Ho intenzione di andare avanti e fare
questo solo un numero finito di volte.

1313
01:04:07,768 --> 01:04:10,047
Usiamo un ciclo for,
che ho accennato in precedenza.

1314
01:04:10,047 --> 01:04:10,630
Facciamolo.

1315
01:04:10,630 --> 01:04:13,430
Dammi un'altra variabile int mi viene 0.

1316
01:04:13,430 --> 01:04:17,430
i è inferiore, diciamo, 64 i ++.

1317
01:04:17,430 --> 01:04:24,010
E ora lasciami andare avanti e di stampa
out n è cento i, comma n.

1318
01:04:24,010 --> 01:04:27,547
E poi n-- questo è ancora
andando a prendere per sempre.

1319
01:04:27,547 --> 01:04:28,130
Facciamolo.

1320
01:04:28,130 --> 01:04:30,620
>> n ottiene n volte 2.

1321
01:04:30,620 --> 01:04:34,140
O potremmo essere di fantasia
e fanno volte è uguale a 2.

1322
01:04:34,140 --> 01:04:37,120
Ma diciamo solo che n
è uguale a se stessa, volte 2.

1323
01:04:37,120 --> 01:04:39,321
In altre parole, in questo
nuova versione del programma,

1324
01:04:39,321 --> 01:04:41,820
Non voglio aspettare per sempre
da come 800.000 a 4 miliardi.

1325
01:04:41,820 --> 01:04:43,070
Diciamo solo farla finita.

1326
01:04:43,070 --> 01:04:44,920
>> Facciamo in realtà matrimoniale n ogni volta.

1327
01:04:44,920 --> 01:04:47,660
Il che, ricordo, è il raddoppio
opposta di avere, ovviamente.

1328
01:04:47,660 --> 01:04:50,035
E che la settimana scorsa abbiamo
qualcosa di nuovo, e di nuovo,

1329
01:04:50,035 --> 01:04:52,200
e di nuovo, super veloce,
raddoppio sicuramente sarà

1330
01:04:52,200 --> 01:04:58,080
farci dal 1 al più grande possibile
valore che siamo in grado di contare fino a int.

1331
01:04:58,080 --> 01:04:59,750
>> Quindi cerchiamo di fare esattamente questo.

1332
01:04:59,750 --> 01:05:01,720
E torneremo a questa prima lunga.

1333
01:05:01,720 --> 01:05:04,180
Ma questo, ancora una volta, è proprio come
il blocco di ripetizione in Scratch.

1334
01:05:04,180 --> 01:05:05,600
E potrai utilizzare questo in poco tempo.

1335
01:05:05,600 --> 01:05:10,170
>> Questo significa solo conteggio da zero
fino a, ma non uguale, a 64.

1336
01:05:10,170 --> 01:05:14,285
E su ciascuna iterazione di questo
ciclo, continua incrementando i.

1337
01:05:14,285 --> 01:05:18,990
Così i ++ - e questo costrutto generale
sulla linea 7 è solo un modo super comune

1338
01:05:18,990 --> 01:05:22,290
di ripetere alcune linee di
codice, un numero di volte.

1339
01:05:22,290 --> 01:05:23,362
Quali linee di codice?

1340
01:05:23,362 --> 01:05:25,570
Queste parentesi graffe, come si
potrebbe essere raccolte da ora,

1341
01:05:25,570 --> 01:05:26,780
significa, effettuare le seguenti operazioni.

1342
01:05:26,780 --> 01:05:29,510
>> E 'in Scratch come, quando
ha i blocchi gialli

1343
01:05:29,510 --> 01:05:32,680
e altri colori che tipo di
abbracciare o abbracciare altri blocchi.

1344
01:05:32,680 --> 01:05:34,750
Questo è ciò che quei ricci
bretelle stanno facendo qui.

1345
01:05:34,750 --> 01:05:40,200
Quindi, se ho preso la mia sintassi destra- sopra voi
può vedere il simbolo di carota in C mezzi

1346
01:05:40,200 --> 01:05:42,706
questo è quante volte sono stato
cercare di risolvere questo problema.

1347
01:05:42,706 --> 01:05:45,330
Quindi cerchiamo di sbarazzarsi di quella
del tutto, e chiudere quella finestra.

1348
01:05:45,330 --> 01:05:46,520
E useremo quello nuovo.

1349
01:05:46,520 --> 01:05:51,980
Fare troppo pieno, barra dot
troppo pieno, Enter, va bene,

1350
01:05:51,980 --> 01:05:53,090
sembra male in un primo momento.

1351
01:05:53,090 --> 01:05:56,200
Ma facciamo scorrere indietro nel tempo,
perché ho fatto questo 64 volte.

1352
01:05:56,200 --> 01:05:58,700
>> E notare la prima volta, n è 1.

1353
01:05:58,700 --> 01:06:03,110
Seconda volta, n è 2,
poi 4, poi 8, poi 16.

1354
01:06:03,110 --> 01:06:09,450
E sembra che appena
Arrivare a circa 1 miliardo,

1355
01:06:09,450 --> 01:06:12,800
se raddoppio di nuovo, che
dovrebbe darmi 2 miliardi.

1356
01:06:12,800 --> 01:06:14,980
Ma si scopre, è
proprio sulla cuspide.

1357
01:06:14,980 --> 01:06:18,930
>> E così è in realtà trabocca
un int da 1 miliardo

1358
01:06:18,930 --> 01:06:23,514
a circa 2 negativo
miliardi, perché un numero intero,

1359
01:06:23,514 --> 01:06:25,430
a differenza del numeri che
sono state assumendo la scorsa settimana,

1360
01:06:25,430 --> 01:06:28,397
può essere sia positivo che negativo
in realtà e in un computer.

1361
01:06:28,397 --> 01:06:30,730
E così almeno uno di quelli
bit è effettivamente rubati.

1362
01:06:30,730 --> 01:06:34,190
Così abbiamo davvero solo 31 bit,
o 2 miliardi di possibili valori.

1363
01:06:34,190 --> 01:06:38,220
>> Ma per ora, l'asporto è abbastanza
semplicemente, qualunque siano questi numeri sono

1364
01:06:38,220 --> 01:06:42,280
e tutto ciò che la matematica è,
succede qualcosa di brutto alla fine,

1365
01:06:42,280 --> 01:06:46,980
perché alla fine si sta tentando di
permutare i bit di una volta di troppo.

1366
01:06:46,980 --> 01:06:51,060
E in modo efficace va da tutti
1 di a forse tutti i 0 del, o forse

1367
01:06:51,060 --> 01:06:54,260
solo qualche altro modello che
chiaramente, a seconda del contesto,

1368
01:06:54,260 --> 01:06:56,342
può essere interpretato come un numero negativo.

1369
01:06:56,342 --> 01:06:59,300
E così sembrerebbe la più alta I
può contare in questo particolare programma

1370
01:06:59,300 --> 01:07:01,210
è solo approssimativamente 1 miliardo.

1371
01:07:01,210 --> 01:07:02,760
Ma c'è una soluzione parziale qui.

1372
01:07:02,760 --> 01:07:03,480
Sai cosa?

1373
01:07:03,480 --> 01:07:07,600
>> Vorrei cambiare da un
int per un lungo tempo.

1374
01:07:07,600 --> 01:07:10,633
E mi permetta di andare avanti qui
e say-- ho intenzione di avere

1375
01:07:10,633 --> 01:07:12,290
per cambiare l'accaduto a un unsigned long.

1376
01:07:12,290 --> 01:07:16,860
Oppure, vediamo, non mi ricordo mai me stesso.

1377
01:07:16,860 --> 01:07:19,920
>> Andiamo avanti e fare troppo pieno.

1378
01:07:19,920 --> 01:07:21,860
No, non è questo, LLD, grazie.

1379
01:07:21,860 --> 01:07:23,430
Così a volte Clang può essere utile.

1380
01:07:23,430 --> 01:07:27,550
Non mi ricordo cosa il formato
specificatore è stato per lungo tempo.

1381
01:07:27,550 --> 01:07:28,950
>> Ma, in effetti, Clang mi ha detto.

1382
01:07:28,950 --> 01:07:31,570
Il verde è una sorta di bene,
significa che ancora hai fatto un errore.

1383
01:07:31,570 --> 01:07:33,190
E 'indovinando che volevo dire LLD.

1384
01:07:33,190 --> 01:07:38,750
>> Quindi, mi permetta di prendere è un consiglio, un lungo
numero decimale lungo, salvo che.

1385
01:07:38,750 --> 01:07:43,190
E mi permetta di eseguire di nuovo esso, dot
tagliare troppo pieno, Invio.

1386
01:07:43,190 --> 01:07:45,020
E ora che cosa è cool è questo.

1387
01:07:45,020 --> 01:07:49,140
>> Se ho scorrere indietro nel tempo, abbiamo ancora iniziamo
contando allo stesso posto-- 1, 2, 4,

1388
01:07:49,140 --> 01:07:50,220
8, 16.

1389
01:07:50,220 --> 01:07:54,860
Avviso, otteniamo tutto il
fino a 1 miliardo.

1390
01:07:54,860 --> 01:07:57,070
Ma poi abbiamo tranquillamente arriva a 2 miliardi.

1391
01:07:57,070 --> 01:08:01,300
>> Poi si arriva a 4 miliardi,
poi 8 miliardi, 17 miliardi.

1392
01:08:01,300 --> 01:08:03,340
E andiamo più in alto, e
sempre più alto.

1393
01:08:03,340 --> 01:08:05,740
Alla fine, anche questo, si rompe.

1394
01:08:05,740 --> 01:08:09,350
>> Alla fine, con un lungo tempo,
che è il valore a 64-bit, non

1395
01:08:09,350 --> 01:08:13,660
un valore a 32 bit, se si conta
troppo alto, si avvolge intorno a 0.

1396
01:08:13,660 --> 01:08:16,410
E in questo caso, ci capita di
finire con un numero negativo.

1397
01:08:16,410 --> 01:08:17,550
>> Quindi questo è un problema.

1398
01:08:17,550 --> 01:08:20,439
E si scopre che questo
problema non è poi così arcana.

1399
01:08:20,439 --> 01:08:23,060
Anche se ho deliberatamente
indotto con questi errori,

1400
01:08:23,060 --> 01:08:26,149
si scopre lo vediamo genere di tutto
intorno a noi, o almeno alcuni di noi fare.

1401
01:08:26,149 --> 01:08:28,939
>> Quindi, in Lego Star Wars, se
avete mai giocato al gioco,

1402
01:08:28,939 --> 01:08:33,830
si scopre che si può andare in giro
rompere le cose in mondo LEGO,

1403
01:08:33,830 --> 01:08:36,640
e la raccolta delle monete, in sostanza.

1404
01:08:36,640 --> 01:08:39,200
E se hai mai giocato
questo gioco troppo tempo,

1405
01:08:39,200 --> 01:08:42,630
come questo individuo senza nome
qui ha fatto, il numero totale

1406
01:08:42,630 --> 01:08:46,700
di monete che si possono raccogliere
è, a quanto pare, 4 miliardi.

1407
01:08:46,700 --> 01:08:48,240
>> Ora, con in realtà è arrotondato.

1408
01:08:48,240 --> 01:08:50,239
Così LEGO stava cercando di
mantenere le cose user friendly.

1409
01:08:50,239 --> 01:08:53,779
Non hanno fatto esattamente 2 a
il 32 di potenza, per la settimana scorsa.

1410
01:08:53,779 --> 01:08:55,310
Ma 4 miliardi è una ragione.

1411
01:08:55,310 --> 01:08:58,979
Sembra, sulla base di queste informazioni,
che LEGO, e la società che

1412
01:08:58,979 --> 01:09:02,624
reso questo software vero e proprio, ha deciso
che il numero massimo di monete

1413
01:09:02,624 --> 01:09:04,540
l'utente può accumulare
è, infatti, 4 miliardi,

1414
01:09:04,540 --> 01:09:12,069
perché hanno scelto nel loro codice
da utilizzare non un lungo tempo, apparentemente,

1415
01:09:12,069 --> 01:09:16,140
ma solo un numero intero, un unsigned
integer, solo un numero intero positivo, cui

1416
01:09:16,140 --> 01:09:18,089
valore massimo o meno è così.

1417
01:09:18,089 --> 01:09:19,380
Bene, ecco un altro divertente.

1418
01:09:19,380 --> 01:09:23,500
Quindi, nel gioco Civilization, che
alcuni di voi potrebbero avere familiarità con

1419
01:09:23,500 --> 01:09:26,660
si scopre che anni fa ci
era un bug in questo gioco in cui

1420
01:09:26,660 --> 01:09:28,750
se hai giocato il ruolo
di Gandhi nel gioco,

1421
01:09:28,750 --> 01:09:34,020
invece di essere molto pacifista,
invece era incredibilmente, incredibilmente

1422
01:09:34,020 --> 01:09:36,399
aggressivo, in alcune circostanze.

1423
01:09:36,399 --> 01:09:40,529
In particolare, il modo in cui civiltà
opere è che se si, il giocatore,

1424
01:09:40,529 --> 01:09:44,680
adottare la democrazia, la vostra
punteggio aggressività ottiene

1425
01:09:44,680 --> 01:09:48,130
decrementato di due, in modo meno
minus, e quindi meno meno.

1426
01:09:48,130 --> 01:09:50,569
>> Così si sottrae 2 dal
il vostro iterazione attuale.

1427
01:09:50,569 --> 01:09:56,650
Purtroppo, se il vostro è l'iterazione
inizialmente 1, e si sottrae 2 da esso

1428
01:09:56,650 --> 01:09:59,050
dopo aver adottato la democrazia
come Gandhi qui potrebbe

1429
01:09:59,050 --> 01:10:02,200
hanno fatto, perché era molto passive--
1 sulla scala di aggressività.

1430
01:10:02,200 --> 01:10:04,830
Ma se egli adotta la democrazia, allora
va da 1 a negativo 1.

1431
01:10:04,830 --> 01:10:11,470
>> Purtroppo, erano
utilizzando i numeri senza segno,

1432
01:10:11,470 --> 01:10:15,400
il che significa che hanno trattato addirittura negativo
i numeri come se fossero positivi.

1433
01:10:15,400 --> 01:10:19,780
E si scopre che il
equivalente positivo di negativo 1,

1434
01:10:19,780 --> 01:10:23,480
nei programmi tipici di computer, è 255.

1435
01:10:23,480 --> 01:10:27,250
Quindi, se Gandhi adotta
la democrazia ha, e quindi

1436
01:10:27,250 --> 01:10:32,470
il suo punteggio di aggressività è diminuito,
in realtà rotola intorno a 255

1437
01:10:32,470 --> 01:10:35,470
e lui la maggior parte delle marche
carattere aggressivo nel gioco.

1438
01:10:35,470 --> 01:10:36,930
Così si può google su questo.

1439
01:10:36,930 --> 01:10:39,380
E 'stato, infatti, un
accidentale bug di programmazione,

1440
01:10:39,380 --> 01:10:43,010
ma che è entrato abbastanza
la tradizione da allora.

1441
01:10:43,010 --> 01:10:44,360
>> Questo è tutto divertente e simpatico.

1442
01:10:44,360 --> 01:10:47,760
Più spaventoso è quando attuale
dispositivi del mondo reale, e non giochi,

1443
01:10:47,760 --> 01:10:48,820
hanno gli stessi errori.

1444
01:10:48,820 --> 01:10:54,500
Infatti, appena un anno fa, un articolo è venuto
conoscere il Boeing 787 Dreamliner.

1445
01:10:54,500 --> 01:10:56,850
>> E l'articolo in prima
sguardo legge un po 'arcano.

1446
01:10:56,850 --> 01:11:01,480
Ma ha detto questo, un software
vulnerabilità in Boeing

1447
01:11:01,480 --> 01:11:04,790
nuovo 787 Dreamliner jet ha
il potenziale di causare piloti

1448
01:11:04,790 --> 01:11:07,220
a perdere il controllo della
dell'aeromobile, possibilmente

1449
01:11:07,220 --> 01:11:11,750
in pieno volo, i funzionari della FAA
compagnie aeree avvertito di recente.

1450
01:11:11,750 --> 01:11:14,520
Era la determinazione
che un modello 787

1451
01:11:14,520 --> 01:11:19,770
aereo che è stato alimentato
ininterrottamente per 248 giorni

1452
01:11:19,770 --> 01:11:24,880
può perdere tutto in corrente alternata, AC,
potenza elettrica dovuta al generatore

1453
01:11:24,880 --> 01:11:28,892
centraline, GCUs, simultaneamente
entrare in modalità sicura sicuro.

1454
01:11:28,892 --> 01:11:29,850
E 'una specie di perdermi.

1455
01:11:29,850 --> 01:11:35,390
Ma il memo dichiarato, OK, ora ho ottenuto che,
la condizione è stata causata da un software

1456
01:11:35,390 --> 01:11:38,590
contatore interno a
il controllo del generatore

1457
01:11:38,590 --> 01:11:44,860
unità che traboccherà dopo
248 giorni di potenza continua.

1458
01:11:44,860 --> 01:11:47,070
Stiamo promuovendo il presente
notare per prevenire la perdita

1459
01:11:47,070 --> 01:11:49,300
di tutti AC elettrica
alimentazione, che potrebbe risultare

1460
01:11:49,300 --> 01:11:50,980
la perdita di controllo del velivolo.

1461
01:11:50,980 --> 01:11:55,380
>> Quindi, letteralmente, c'è qualche intero,
o qualche tipo di dati equivalente,

1462
01:11:55,380 --> 01:11:57,960
utilizzato nel software
in un velivolo reale

1463
01:11:57,960 --> 01:12:00,756
che se si mantiene il vostro aereo
abbastanza a lungo, che apparentemente

1464
01:12:00,756 --> 01:12:03,880
può essere il caso se si sta solo in esecuzione
loro costantemente e mai scollegare

1465
01:12:03,880 --> 01:12:06,810
il vostro aereo, a quanto pare, o
lasciando che le sue batterie morire,

1466
01:12:06,810 --> 01:12:09,840
alla fine contare su, e su,
e su, e su, e su, e su.

1467
01:12:09,840 --> 01:12:12,150
>> E, per sua natura, un
quantità limitata di memoria

1468
01:12:12,150 --> 01:12:15,880
traboccherà, sul ritorno alla
zero o un valore negativo,

1469
01:12:15,880 --> 01:12:19,920
un effetto collaterale dei quali è il
la realtà spaventosamente reale

1470
01:12:19,920 --> 01:12:23,970
che il piano potrebbe essere necessario
essere riavviato, in modo efficace,

1471
01:12:23,970 --> 01:12:27,290
o potrebbe cadere, peggio, come si vola.

1472
01:12:27,290 --> 01:12:29,230
Così questi tipi di problemi
sono ancora con noi,

1473
01:12:29,230 --> 01:12:33,130
even-- questo è stato un articolo 2015,
tanto più spaventoso

1474
01:12:33,130 --> 01:12:36,100
quando non si necessariamente
capire, apprezzare, o anticipare

1475
01:12:36,100 --> 01:12:38,640
quei tipi di errori.

1476
01:12:38,640 --> 01:12:42,030
>> Così si scopre c'è un altro
cosa negativa di rappresentazione dei dati.

1477
01:12:42,030 --> 01:12:47,080
Si scopre che anche i galleggianti sono
sorta di imperfetto, perché galleggia, troppo,

1478
01:12:47,080 --> 01:12:51,440
Ho proposto sono a 32 bit, o
forse 64 se si utilizza un doppio.

1479
01:12:51,440 --> 01:12:53,070
Ma questo è ancora finita.

1480
01:12:53,070 --> 01:12:57,070
>> E il problema è che se si può
mettere un numero infinito di numeri

1481
01:12:57,070 --> 01:12:59,460
dopo il punto decimale,
non vi è alcun modo di

1482
01:12:59,460 --> 01:13:02,690
può rappresentare tutte le possibili
numeri che ci è stato insegnato

1483
01:13:02,690 --> 01:13:04,990
nel grado scuola può esistere nel mondo.

1484
01:13:04,990 --> 01:13:08,870
Un computer, essenzialmente, deve
scegliere un sottoinsieme di questi numeri

1485
01:13:08,870 --> 01:13:10,200
per rappresentare accuratamente.

1486
01:13:10,200 --> 01:13:12,450
>> Ora, il computer può
tondo forse un po ',

1487
01:13:12,450 --> 01:13:17,900
e può permettere di circa negozio
qualsiasi numero si potrebbe desiderare.

1488
01:13:17,900 --> 01:13:20,940
Ma solo intuitivamente, se si
hanno un numero finito di bit,

1489
01:13:20,940 --> 01:13:24,560
è possibile permutare solo
in tanti modi finiti.

1490
01:13:24,560 --> 01:13:26,570
Così non si può forse
utilizzare un numero finito

1491
01:13:26,570 --> 01:13:29,880
di permutazione di bit,
modelli di zero e uno,

1492
01:13:29,880 --> 01:13:32,940
rappresentare un infinito
numero di numeri,

1493
01:13:32,940 --> 01:13:37,370
il che suggerisce che i computer potrebbero
benissimo essere sdraiato a noi a volte.

1494
01:13:37,370 --> 01:13:38,770
>> In realtà, cerchiamo di fare questo.

1495
01:13:38,770 --> 01:13:41,239
Torniamo in CS50 IDE.

1496
01:13:41,239 --> 01:13:43,030
Lasciami andare avanti e
creare un piccolo programma

1497
01:13:43,030 --> 01:13:47,940
L'imprecisione chiamato, per mostrare che
computer sono, infatti, imprecise.

1498
01:13:47,940 --> 01:13:51,910
>> E mi permetta di andare avanti e iniziare con
alcuni di quel codice da prima,

1499
01:13:51,910 --> 01:13:53,830
e ora solo fare quanto segue.

1500
01:13:53,830 --> 01:14:03,640
Mi permetta di andare avanti e fare printf, per cento
f, backslash n, 1 diviso per 10.

1501
01:14:03,640 --> 01:14:07,430
In altre parole, cerchiamo di tuffo nel profondo
a 1/10, come 1 e diviso per 10.

1502
01:14:07,430 --> 01:14:09,760
Sicuramente, un computer può rappresentare 1/10.

1503
01:14:09,760 --> 01:14:13,620
>> Quindi cerchiamo di andare avanti e fare l'imprecisione.

1504
01:14:13,620 --> 01:14:14,390
Vediamo.

1505
01:14:14,390 --> 01:14:16,210
Formato specifica tipo double.

1506
01:14:16,210 --> 01:14:18,160
Ma l'argomento è di tipo int.

1507
01:14:18,160 --> 01:14:19,040
Cosa sta succedendo?

1508
01:14:19,040 --> 01:14:21,970
>> Oh, interessante, quindi è un
lezione imparata da prima.

1509
01:14:21,970 --> 01:14:26,050
Sto dicendo, hey, computer di spettacolo
me un galleggiante con cento f.

1510
01:14:26,050 --> 01:14:28,200
Ma io sto dando 2 int.

1511
01:14:28,200 --> 01:14:31,120
Così si scopre, posso risolvere
questo in un paio di modi.

1512
01:14:31,120 --> 01:14:38,430
>> Ho potuto solo girare uno in 1.0, e
10 in 10.0, che sarebbe, in effetti,

1513
01:14:38,430 --> 01:14:42,390
avere l'effetto di conversione
li in floats-- ancora si spera

1514
01:14:42,390 --> 01:14:43,180
lo stesso numero.

1515
01:14:43,180 --> 01:14:45,880
Oppure si scopre che c'è qualcosa
vedremo di nuovo in poco tempo.

1516
01:14:45,880 --> 01:14:47,170
Si potrebbe lanciare i numeri.

1517
01:14:47,170 --> 01:14:49,880
>> È possibile, utilizzando questa parentesi
espressione, si può dire,

1518
01:14:49,880 --> 01:14:52,560
Hey, computer, prendere questa
10, che so essere un int.

1519
01:14:52,560 --> 01:14:54,660
Ma trattare, per favore,
come se fosse un galleggiante.

1520
01:14:54,660 --> 01:14:56,680
Ma questo si sente inutilmente complesso.

1521
01:14:56,680 --> 01:14:59,040
>> Per i nostri scopi di oggi,
facciamo solo letteralmente

1522
01:14:59,040 --> 01:15:02,700
rendono loro i valori in virgola mobile
con un punto decimale, come questo.

1523
01:15:02,700 --> 01:15:07,060
Lasciami andare avanti e replica, fare
imprecisioni, buono, barra dot

1524
01:15:07,060 --> 01:15:08,870
imprecisioni, entrare.

1525
01:15:08,870 --> 01:15:10,990
OK, stiamo guardando bene.

1526
01:15:10,990 --> 01:15:18,194
>> 1 diviso 10, secondo il mio
Mac qui, è, infatti, 0.100000.

1527
01:15:18,194 --> 01:15:21,360
Ora, mi è stato insegnato nella scuola elementare lì
deve essere un numero infinito di 0 di.

1528
01:15:21,360 --> 01:15:23,151
Quindi cerchiamo di almeno provare
per vedere alcuni di questi.

1529
01:15:23,151 --> 01:15:26,770
Si scopre che printf è un po '
amatore ancora che abbiamo usato.

1530
01:15:26,770 --> 01:15:30,890
Si scopre che non è necessario specificare
proprio per cento f, o semplicemente per cento i.

1531
01:15:30,890 --> 01:15:33,830
Si può effettivamente specificare
alcune opzioni di controllo qui.

1532
01:15:33,830 --> 01:15:36,470
>> In particolare, sto andando
per dire, ehi, printf,

1533
01:15:36,470 --> 01:15:39,660
in realtà mi mostra 10 punti decimali.

1534
01:15:39,660 --> 01:15:40,820
Quindi sembra un po 'strano.

1535
01:15:40,820 --> 01:15:42,845
Ma che dici per cento,
punti, quanti numeri

1536
01:15:42,845 --> 01:15:44,970
vuoi vedere dopo il
punto decimale, e quindi f

1537
01:15:44,970 --> 01:15:48,340
per piatta, proprio perché è
quello che dice la documentazione.

1538
01:15:48,340 --> 01:15:50,080
Lasciami andare avanti e salvare questo.

1539
01:15:50,080 --> 01:15:52,460
>> E notare troppo, sto diventando
stanco di riscrivere le cose.

1540
01:15:52,460 --> 01:15:55,900
Così sto solo impostando l'alto e
freccia verso il basso le chiavi qui.

1541
01:15:55,900 --> 01:15:58,710
E se continuo a colpire in su,
può vedere tutti i comandi

1542
01:15:58,710 --> 01:16:01,090
che ho fatto, o non correttamente fatto.

1543
01:16:01,090 --> 01:16:04,630
>> E ho intenzione di andare avanti ora e
in realtà non usare quella, a quanto pare.

1544
01:16:04,630 --> 01:16:11,416
Fare imprecisioni, dot
tagliare imprecision-- così

1545
01:16:11,416 --> 01:16:13,290
quello che mi è stato insegnato a
scuola elementare estrae.

1546
01:16:13,290 --> 01:16:19,010
Anche se stampo a 10 decimale
lo colloca, infatti, è 0.10000.

1547
01:16:19,010 --> 01:16:19,840
Ma sai una cosa?

1548
01:16:19,840 --> 01:16:21,150
>> Prendiamo un po 'avido.

1549
01:16:21,150 --> 01:16:23,990
Diciamo che, come, mostrarmi 55
punti dopo la virgola.

1550
01:16:23,990 --> 01:16:26,160
Facciamo davvero prendere questo
programmare fuori per un giro.

1551
01:16:26,160 --> 01:16:31,170
Mi permetta di rifarlo con make
imprecisioni, barra di punti, imprecisioni.

1552
01:16:31,170 --> 01:16:32,390
>> E qui andiamo.

1553
01:16:32,390 --> 01:16:34,420
La vostra infanzia era una bugia.

1554
01:16:34,420 --> 01:16:48,410
Apparentemente, 1 diviso 10 è infatti
0.100000000000000005551115123--

1555
01:16:48,410 --> 01:16:49,740
>> Cosa sta succedendo?

1556
01:16:49,740 --> 01:16:53,360
Beh, si scopre, se tipo di
guardare abbastanza lontano nel sottostante

1557
01:16:53,360 --> 01:16:55,950
rappresentazione di questo
il numero, in realtà

1558
01:16:55,950 --> 01:17:00,400
non è esattamente 1/10, o 0,1 e
un numero infinito di zeri.

1559
01:17:00,400 --> 01:17:01,630
Ora, perché?

1560
01:17:01,630 --> 01:17:06,250
>> Bene, anche se questo è un semplice
numero per noi esseri umani, 1 diviso per 10,

1561
01:17:06,250 --> 01:17:10,910
è ancora uno di infiniti
numeri che si potrebbe pensare su.

1562
01:17:10,910 --> 01:17:14,490
Ma un computer può rappresentare solo
un numero finito di numeri così.

1563
01:17:14,490 --> 01:17:18,710
E così, di fatto, cosa
computer mostra a noi è il suo più vicino

1564
01:17:18,710 --> 01:17:22,940
approssimazione al numero
vogliamo credere è 1/10,

1565
01:17:22,940 --> 01:17:27,760
o realmente 0.10000 all'infinito.

1566
01:17:27,760 --> 01:17:30,425
>> Piuttosto, però, questo è
il più vicino come si può ottenere.

1567
01:17:30,425 --> 01:17:32,300
E, in effetti, se si guarda
sotto la cappa,

1568
01:17:32,300 --> 01:17:37,050
come noi siamo qui, cercando
55 cifre dopo la virgola,

1569
01:17:37,050 --> 01:17:39,990
in realtà vediamo che la realtà.

1570
01:17:39,990 --> 01:17:42,610
Ora, come un a parte, se hai
mai visto la movie--

1571
01:17:42,610 --> 01:17:45,780
la maggior parte di voi probabilmente haven't--
ma Superman 3 alcuni anni fa,

1572
01:17:45,780 --> 01:17:49,500
Richard Pryor essenzialmente sfruttato questo
la realtà in sua compagnia per rubare un sacco

1573
01:17:49,500 --> 01:17:53,500
di frazioni e frazioni di centesimi,
perché il Company-- come ricordo,

1574
01:17:53,500 --> 01:17:57,210
è stato un while-- era essenzialmente
buttare via tutto ciò che non si adattava

1575
01:17:57,210 --> 01:17:58,790
nella nozione di centesimi.

1576
01:17:58,790 --> 01:18:01,480
>> Ma se si sommano tutti questi
piccoli, piccoli, piccoli numeri ancora una volta,

1577
01:18:01,480 --> 01:18:04,960
e ancora, e ancora, è possibile, come in
il suo caso, fare una buona quantità di denaro.

1578
01:18:04,960 --> 01:18:08,010
>> La stessa idea è stata strappato via da
un più recente, ma ancora oggi più vecchio

1579
01:18:08,010 --> 01:18:10,500
film, chiamato Office Space,
dove i ragazzi in quel film,

1580
01:18:10,500 --> 01:18:13,501
ha fatto la stessa cosa, avvitata in su
completamente, si è conclusa con modo troppo

1581
01:18:13,501 --> 01:18:14,666
soldi nel loro conto in banca.

1582
01:18:14,666 --> 01:18:15,800
E 'stato tutto molto sospetto.

1583
01:18:15,800 --> 01:18:19,290
Ma alla fine della giornata,
imprecisione è tutto intorno a noi.

1584
01:18:19,290 --> 01:18:22,240
>> E che, inoltre, può essere
Spaventosamente il caso.

1585
01:18:22,240 --> 01:18:25,590
Si scopre che Superman 3
e Office Space a parte, ci

1586
01:18:25,590 --> 01:18:28,460
può essere un po 'molto reale
ramificazioni mondiali

1587
01:18:28,460 --> 01:18:32,290
delle realtà imprecisa
rappresentazione dei dati

1588
01:18:32,290 --> 01:18:34,770
che anche noi esseri umani a
questo giorno non necessariamente

1589
01:18:34,770 --> 01:18:38,230
capire come dovremmo,
o ricordare come spesso come dovremmo.

1590
01:18:38,230 --> 01:18:42,950
E, in effetti, il seguente clip è
da uno sguardo ad alcuni mondo molto reale

1591
01:18:42,950 --> 01:18:47,730
ramificazioni di ciò che accade se si
non apprezzano l'imprecisione che

1592
01:18:47,730 --> 01:18:50,065
può accadere nella rappresentazione dei numeri.

1593
01:18:50,065 --> 01:18:51,300
>> [RIPRODUZIONE VIDEO]

1594
01:18:51,300 --> 01:18:55,620
>> -Computers, Tutti abbiamo imparato ad accettare
i problemi spesso frustrante che

1595
01:18:55,620 --> 01:19:00,310
andare con them-- bug, virus,
e anomalie nel software,

1596
01:19:00,310 --> 01:19:03,130
per i piccoli prezzi da pagare
per la comodità.

1597
01:19:03,130 --> 01:19:07,800
Ma in alta tecnologia e ad alta velocità
applicazioni programmi spaziali militari e,

1598
01:19:07,800 --> 01:19:12,800
il più piccolo problema può
essere ingrandita nel disastro.

1599
01:19:12,800 --> 01:19:18,900
>> Il 4 giugno del 1996, gli scienziati preparati
per lanciare un razzo Ariane 5 senza equipaggio.

1600
01:19:18,900 --> 01:19:21,220
Si stava trasportando scientifica
satelliti progettati

1601
01:19:21,220 --> 01:19:24,600
per stabilire con precisione come la
interagisce campo magnetico della terra

1602
01:19:24,600 --> 01:19:27,410
con venti solari.

1603
01:19:27,410 --> 01:19:30,800
Il razzo è stato costruito per
l'Agenzia spaziale europea,

1604
01:19:30,800 --> 01:19:34,370
e sollevato fuori dal suo stabilimento
sulla costa della Guyana francese.

1605
01:19:34,370 --> 01:19:37,540
>> -A Circa 37 secondi in
il volo, in primo luogo

1606
01:19:37,540 --> 01:19:39,270
notato qualcosa stava andando storto.

1607
01:19:39,270 --> 01:19:42,250
Gli ugelli sono orientabili in
un modo che davvero non dovrebbe.

1608
01:19:42,250 --> 01:19:46,580
Circa 40 secondi dall'inizio del volo,
chiaramente, il veicolo era in difficoltà.

1609
01:19:46,580 --> 01:19:48,850
>> Ed è allora che hanno fatto
la decisione di distruggerla.

1610
01:19:48,850 --> 01:19:52,780
Il responsabile della sicurezza gamma, con
enormi coraggio, preme il pulsante,

1611
01:19:52,780 --> 01:19:58,150
fatto saltare in aria il razzo, prima che potesse
diventare un pericolo per la sicurezza pubblica.

1612
01:19:58,150 --> 01:20:01,060
>> -Questo Era la fanciulla
viaggio del Ariane 5.

1613
01:20:01,060 --> 01:20:03,960
E la sua distruzione ha preso
posizionare causa di un difetto

1614
01:20:03,960 --> 01:20:05,822
incorporato nel software del razzo.

1615
01:20:05,822 --> 01:20:08,280
-Il Problema sul Ariane era
che c'era un numero che

1616
01:20:08,280 --> 01:20:10,600
necessaria 64 bit per esprimere.

1617
01:20:10,600 --> 01:20:13,590
E volevano convertire
in un numero a 16 bit.

1618
01:20:13,590 --> 01:20:15,610
Si presume che il
numero avrebbe mai

1619
01:20:15,610 --> 01:20:20,980
essere molto grande, che la maggior parte di quelli
cifre in un numero a 64 bit erano zeri.

1620
01:20:20,980 --> 01:20:22,440
Si sbagliavano.

1621
01:20:22,440 --> 01:20:25,060
>> -La Incapacità di una
programma software per accettare

1622
01:20:25,060 --> 01:20:29,510
il tipo di numero generato da
un altro era alla radice del fallimento.

1623
01:20:29,510 --> 01:20:34,350
Lo sviluppo del software era diventato un
parte molto costosa delle nuove tecnologie.

1624
01:20:34,350 --> 01:20:38,140
Il razzo Ariane sono stati molto
successo, tanto del software

1625
01:20:38,140 --> 01:20:41,550
creata per era anche
utilizzato nella Ariane 5.

1626
01:20:41,550 --> 01:20:47,940
>> -Il Problema di fondo era che il Ariane
5 è stato più veloce, più veloce accelerato.

1627
01:20:47,940 --> 01:20:51,450
E il software non ha avuto
spiega che cosa.

1628
01:20:51,450 --> 01:20:55,060
>> -La Distruzione del razzo
è stato un grande disastro finanziario,

1629
01:20:55,060 --> 01:20:58,790
tutto a causa di un errore di software minuto.

1630
01:20:58,790 --> 01:21:01,210
Ma questo non era il primo
problemi di conversione dei dati in tempo

1631
01:21:01,210 --> 01:21:04,820
aveva afflitto tecnologia dei razzi moderna.

1632
01:21:04,820 --> 01:21:08,050
>> -In 1991 con l'avvio
della prima Guerra del Golfo,

1633
01:21:08,050 --> 01:21:10,570
il Patriot Missile
sperimentato una specie simile

1634
01:21:10,570 --> 01:21:12,800
del problema di conversione numero.

1635
01:21:12,800 --> 01:21:16,090
E come risultato, 28 persone,
28 soldati americani,

1636
01:21:16,090 --> 01:21:19,080
sono stati uccisi, e circa
altri 100 feriti,

1637
01:21:19,080 --> 01:21:22,780
quando il Patriot, che avrebbe dovuto
per la protezione contro rincoramenti arrivo,

1638
01:21:22,780 --> 01:21:25,830
omesso di sparare un missile.

1639
01:21:25,830 --> 01:21:31,670
>> -Quando Iraq invase il Kuwait, e in America
Desert Storm lanciato all'inizio del 1991,

1640
01:21:31,670 --> 01:21:35,780
batterie Patriot Missile sono stati schierati
per proteggere l'Arabia Saudita e Israele

1641
01:21:35,780 --> 01:21:39,230
da attacchi missilistici iracheni Scud.

1642
01:21:39,230 --> 01:21:43,810
La Patriot è un medio raggio US
superficie per aria, prodotto

1643
01:21:43,810 --> 01:21:45,770
dalla società Raytheon.

1644
01:21:45,770 --> 01:21:52,340
>> -La Dimensione del intercettore Patriot
di per sé è di circa circa 20 piedi.

1645
01:21:52,340 --> 01:21:55,230
E pesa circa 2.000 chili.

1646
01:21:55,230 --> 01:21:59,320
E porta una testata di circa,
Penso che sia più o meno 150 libbre.

1647
01:21:59,320 --> 01:22:03,930
E la testata stessa è
un alto esplosivo, che

1648
01:22:03,930 --> 01:22:07,330
ha frammenti intorno ad esso.

1649
01:22:07,330 --> 01:22:11,680
L'involucro della testata è
progettato per agire come pallettoni.

1650
01:22:11,680 --> 01:22:14,110
>> -Le Missili sono svolte
quattro per contenitore,

1651
01:22:14,110 --> 01:22:17,130
e sono trasportati da un semirimorchio.

1652
01:22:17,130 --> 01:22:24,930
>> -Il Sistema Patriot antimissile
risale subito almeno 20 anni.

1653
01:22:24,930 --> 01:22:28,420
È stato originariamente progettato
come un missile di difesa aerea

1654
01:22:28,420 --> 01:22:30,720
di abbattere gli aerei nemici.

1655
01:22:30,720 --> 01:22:34,500
Nella prima Guerra del Golfo,
quando la guerra è arrivato,

1656
01:22:34,500 --> 01:22:39,745
l'esercito voleva usarlo per
abbattere Scud, non aerei.

1657
01:22:39,745 --> 01:22:43,620
>> L'Air Force iracheno era
non tanto di un problema.

1658
01:22:43,620 --> 01:22:46,670
Ma l'esercito era preoccupato per Scud.

1659
01:22:46,670 --> 01:22:50,170
E così hanno cercato di
aggiornare il Patriot.

1660
01:22:50,170 --> 01:22:52,800
>> -Intercepting Un nemico
missile viaggiando a Mach 5

1661
01:22:52,800 --> 01:22:55,830
stava per essere abbastanza impegnativo.

1662
01:22:55,830 --> 01:22:58,490
Ma quando il Patriot
è stato ricoverato in servizio,

1663
01:22:58,490 --> 01:23:02,860
l'esercito non era a conoscenza di un
modifica irachena che ha fatto

1664
01:23:02,860 --> 01:23:05,930
i loro scudi quasi impossibile da colpire.

1665
01:23:05,930 --> 01:23:10,740
>> -Cosa È successo è il Scud che
stavano entrando erano instabili.

1666
01:23:10,740 --> 01:23:11,692
Erano dondolavano.

1667
01:23:11,692 --> 01:23:14,910
La ragione di questo è stato
gli iracheni, in ordine

1668
01:23:14,910 --> 01:23:18,280
per ottenere 600 chilometri
su un chilometro 300

1669
01:23:18,280 --> 01:23:21,700
gamma di missili, ha preso di peso
dalla testata anteriore.

1670
01:23:21,700 --> 01:23:23,390
Hanno fatto la testata più leggero.

1671
01:23:23,390 --> 01:23:27,330
>> Così ora il Patriot è
cercando di venire al Scud.

1672
01:23:27,330 --> 01:23:30,230
E la maggior parte del tempo, la
stragrande maggioranza del tempo,

1673
01:23:30,230 --> 01:23:32,940
sarebbe solo volare dal Scud.

1674
01:23:32,940 --> 01:23:37,260
Una volta che i gestori del sistema Patriot
ha realizzato il Patriot mancato il suo obiettivo,

1675
01:23:37,260 --> 01:23:41,690
hanno fatto esplodere testata del Patriot
al fine di evitare possibili incidenti, se si

1676
01:23:41,690 --> 01:23:44,570
è stato permesso di cadere a terra.

1677
01:23:44,570 --> 01:23:48,790
>> -Che Era quello che la maggior parte delle persone hanno visto,
quei grandi palle di fuoco nel cielo,

1678
01:23:48,790 --> 01:23:54,550
e fraintesa come
intercettazioni di testate Scud.

1679
01:23:54,550 --> 01:23:56,630
>> -Anche Se nella notte
cieli, Patriots apparve

1680
01:23:56,630 --> 01:24:00,370
di essere con successo
distruggendo Scud, a Dhahran,

1681
01:24:00,370 --> 01:24:03,360
ci potrebbe essere nessun errore
sulle sue prestazioni.

1682
01:24:03,360 --> 01:24:07,970
Lì, il sistema radar del Patriot
perso le tracce di un Scud in arrivo,

1683
01:24:07,970 --> 01:24:10,721
e mai lanciato a causa
ad un difetto del software.

1684
01:24:10,721 --> 01:24:14,090

1685
01:24:14,090 --> 01:24:18,940
E 'stato gli israeliani che per primo ha scoperto
che più il sistema era acceso,

1686
01:24:18,940 --> 01:24:22,690
maggiore è il tempo di discrepanza
divenne, a causa di un orologio incorporato

1687
01:24:22,690 --> 01:24:24,810
nel computer del sistema.

1688
01:24:24,810 --> 01:24:28,210
>> -A Proposito di due settimane prima
la tragedia di Dhahran,

1689
01:24:28,210 --> 01:24:30,770
gli israeliani riferito a
il Dipartimento della Difesa

1690
01:24:30,770 --> 01:24:32,590
che il sistema perdeva tempo.

1691
01:24:32,590 --> 01:24:35,360
Dopo circa otto ore o in esecuzione,
hanno notato che il sistema

1692
01:24:35,360 --> 01:24:37,720
stava diventando decisamente meno precise.

1693
01:24:37,720 --> 01:24:41,900
Il Dipartimento della Difesa ha risposto
raccontando tutte le batterie Patriot

1694
01:24:41,900 --> 01:24:44,950
di non lasciare i sistemi
per lungo tempo.

1695
01:24:44,950 --> 01:24:49,160
Non hanno mai detto quello che un lungo periodo di tempo era--
otto ore, 10 ore, 1.000 ore.

1696
01:24:49,160 --> 01:24:51,360
Nessuno sapeva.

1697
01:24:51,360 --> 01:24:53,380
>> -La Batteria Patriot
di stanza presso la caserma

1698
01:24:53,380 --> 01:24:58,350
a Dhahran e la sua viziata interna
orologio era stato in più di 100 ore

1699
01:24:58,350 --> 01:25:01,670
la notte del 25 febbraio.

1700
01:25:01,670 --> 01:25:05,917
>> -E Monitorati tempo con una precisione
di circa un decimo di secondo.

1701
01:25:05,917 --> 01:25:08,000
Ora, un decimo di secondo
è un numero interessante,

1702
01:25:08,000 --> 01:25:11,920
perché non può essere espressa
in binario esattamente, che

1703
01:25:11,920 --> 01:25:16,820
significa che non può essere espressa esattamente
in qualsiasi moderno computer digitale.

1704
01:25:16,820 --> 01:25:18,540
È difficile da credere.

1705
01:25:18,540 --> 01:25:21,210
>> Ma utilizzare questo come esempio.

1706
01:25:21,210 --> 01:25:23,540
Prendiamo il numero di un terzo.

1707
01:25:23,540 --> 01:25:27,350
Un terzo non può essere
espresso in decimali esattamente.

1708
01:25:27,350 --> 01:25:32,080
Un terzo è 0.333
in corso per l'infinito.

1709
01:25:32,080 --> 01:25:36,480
>> Non c'è modo di farlo con
precisione assoluta in decimale.

1710
01:25:36,480 --> 01:25:39,560
Questo è esattamente il tipo di problema
quello che è successo nel Patriot.

1711
01:25:39,560 --> 01:25:44,100
Più lungo è il sistema di corse, il
peggio l'errore di tempo è diventato.

1712
01:25:44,100 --> 01:25:48,890
>> -Dopo 100 ore di funzionamento, la
errore nel tempo era solo circa un terzo

1713
01:25:48,890 --> 01:25:50,600
di un secondo.

1714
01:25:50,600 --> 01:25:54,210
Ma in termini di mira un
missile viaggiando a Mach 5,

1715
01:25:54,210 --> 01:25:58,710
si è tradotto in un inseguimento
errore di oltre 600 metri.

1716
01:25:58,710 --> 01:26:02,120
Sarebbe un errore fatale
per i soldati su cosa

1717
01:26:02,120 --> 01:26:08,940
successo è un lancio Scud era
rilevato dai satelliti di preallarme

1718
01:26:08,940 --> 01:26:12,860
e sapevano che il Scud era
venendo nella loro direzione generale.

1719
01:26:12,860 --> 01:26:15,320
Non sapevano dove venisse.

1720
01:26:15,320 --> 01:26:18,250
>> -Era Ora fino al radar
componente del sistema Patriot

1721
01:26:18,250 --> 01:26:23,190
difendere Dhahran per individuare e mantenere
traccia del missile nemico in arrivo.

1722
01:26:23,190 --> 01:26:24,609
>> -Il Radar era molto intelligente.

1723
01:26:24,609 --> 01:26:26,650
Sarebbe in realtà tenere traccia
la posizione del Scud,

1724
01:26:26,650 --> 01:26:30,350
e poi prevedere dove probabilmente
sarebbe la prossima volta radar inviato

1725
01:26:30,350 --> 01:26:31,420
Un impulso fuori.

1726
01:26:31,420 --> 01:26:33,110
Che è stato chiamato un cancello gamma.

1727
01:26:33,110 --> 01:26:37,660
>> -Poi, Una volta che il Patriot
decide il tempo ha

1728
01:26:37,660 --> 01:26:42,450
passato a tornare indietro e controllare il prossimo
posizione per questo oggetto rilevato,

1729
01:26:42,450 --> 01:26:43,600
risale.

1730
01:26:43,600 --> 01:26:48,650
Così, quando si tornò al sbagliata
posto, poi vede nessun oggetto.

1731
01:26:48,650 --> 01:26:52,160
E decide che non c'era
oggetto, si trattava di un falso rilevamento,

1732
01:26:52,160 --> 01:26:53,930
e scende in pista.

1733
01:26:53,930 --> 01:26:57,030
>> -Il Scud in entrata scomparso
dallo schermo radar.

1734
01:26:57,030 --> 01:27:00,260
E pochi secondi dopo, è
sbattuto in caserma.

1735
01:27:00,260 --> 01:27:06,150
Il Scud ucciso 28, ed è stato l'ultimo
uno sparato durante la prima Guerra del Golfo.

1736
01:27:06,150 --> 01:27:11,960
>> Tragicamente, il software aggiornato
arrivati ​​a Dhahran il giorno seguente.

1737
01:27:11,960 --> 01:27:14,930
Il difetto del software aveva
stato, chiusura fisso

1738
01:27:14,930 --> 01:27:19,806
un capitolo nella travagliata
la storia del missile Patriot.

1739
01:27:19,806 --> 01:27:20,729
>> [RIPRODUZIONE VIDEO]

1740
01:27:20,729 --> 01:27:23,520
David J. MALAN: Quindi questo è tutto da
dire che questi problemi di trabocco

1741
01:27:23,520 --> 01:27:25,860
e l'imprecisione sono fin troppo reale.

1742
01:27:25,860 --> 01:27:26,920
Così come siamo arrivati ​​qui?

1743
01:27:26,920 --> 01:27:28,895
Abbiamo iniziato con solo parlando di printf.

1744
01:27:28,895 --> 01:27:31,270
Anche questa funzione che
stampa qualcosa sullo schermo,

1745
01:27:31,270 --> 01:27:33,450
e abbiamo introdotto successivamente
alcune altre funzioni

1746
01:27:33,450 --> 01:27:34,945
dalla cosiddetta biblioteca di CS50.

1747
01:27:34,945 --> 01:27:36,910
E noi continueremo a
vedere questi a tempo debito.

1748
01:27:36,910 --> 01:27:40,760
E noi, in particolare, usato stringa di ottenere,
e ottenere int, e ora anche ottenere galleggiante,

1749
01:27:40,760 --> 01:27:44,410
e altri ancora saranno ancora che incontrano
e utilizzare noi stessi in breve tempo.

1750
01:27:44,410 --> 01:27:47,220
>> Ma a volte, avere
abbiamo già visto un bisogno

1751
01:27:47,220 --> 01:27:50,520
per memorizzare ciò che quelle funzioni mano indietro?

1752
01:27:50,520 --> 01:27:52,920
ci riporta una stringa Essi mano,
o un int, o di un galleggiante.

1753
01:27:52,920 --> 01:27:56,070
E a volte abbiamo bisogno di mettere che
stringa o int, float o, in qualche luogo.

1754
01:27:56,070 --> 01:28:00,100
>> E per memorizzare quelle cose, ricordare solo
come in Scratch, abbiamo variabili.

1755
01:28:00,100 --> 01:28:03,260
Ma a differenza di Scratch,
in C abbiamo tipi effettivi

1756
01:28:03,260 --> 01:28:05,530
dei dati variables--
tipi, più generally--

1757
01:28:05,530 --> 01:28:08,640
tra questi, una stringa, un int, un
float, e questi altri ancora.

1758
01:28:08,640 --> 01:28:12,321
>> E così, quando dichiariamo le variabili in C,
saremo costretti a dichiarare i nostri tipi di dati.

1759
01:28:12,321 --> 01:28:14,820
Questo non è qualcosa faremo
hanno a che fare più avanti nel semestre

1760
01:28:14,820 --> 01:28:16,810
come abbiamo transizione ad altre lingue.

1761
01:28:16,810 --> 01:28:19,610
Ma per ora, abbiamo bisogno
a priori in anticipo,

1762
01:28:19,610 --> 01:28:24,370
spiegare al computer che tipo
di variabili vogliamo che darci.

1763
01:28:24,370 --> 01:28:27,290
>> Ora, nel frattempo, per la stampa
questi tipi di tipi di dati,

1764
01:28:27,290 --> 01:28:29,570
dobbiamo dire printf cosa aspettarsi.

1765
01:28:29,570 --> 01:28:32,450
E abbiamo visto per cento s per le stringhe,
e cento i per interi,

1766
01:28:32,450 --> 01:28:33,790
e pochi altri già.

1767
01:28:33,790 --> 01:28:37,237
E quelli sono semplicemente requisiti
per la presentazione visiva

1768
01:28:37,237 --> 01:28:38,070
di tali informazioni.

1769
01:28:38,070 --> 01:28:42,080
>> E ciascuno di questi può effettivamente essere
parametrizzata o ottimizzato in qualche modo,

1770
01:28:42,080 --> 01:28:45,370
se si vuole ulteriormente il controllo
il tipo di output che si ottiene.

1771
01:28:45,370 --> 01:28:49,604
E, infatti, si scopre che non solo
c'è backslash n per una nuova linea.

1772
01:28:49,604 --> 01:28:52,520
C'è qualcos'altro chiamato backslash
R per un ritorno a capo, che

1773
01:28:52,520 --> 01:28:54,360
è più simile a un
vecchia macchina da scrivere scuola,

1774
01:28:54,360 --> 01:28:57,690
e anche di Windows utilizzato per molti anni.

1775
01:28:57,690 --> 01:28:59,690
>> C'è t backslash per le schede.

1776
01:28:59,690 --> 01:29:03,170
Si scopre, che se si vuole
doppio apice all'interno di una stringa,

1777
01:29:03,170 --> 01:29:05,000
Ricordiamo che abbiamo usato
doppia doppia citazione

1778
01:29:05,000 --> 01:29:07,900
citazione a sinistra e destra
estremità delle nostre corde finora.

1779
01:29:07,900 --> 01:29:09,420
Ciò sembrerebbe confondere le cose.

1780
01:29:09,420 --> 01:29:12,503
>> Se si vuole mettere un doppio apice in
mezzo di una string-- e, anzi,

1781
01:29:12,503 --> 01:29:13,670
è fonte di confusione per vedere.

1782
01:29:13,670 --> 01:29:17,120
E quindi bisogna sfuggire, in modo da
dire, un doppio apice con qualcosa

1783
01:29:17,120 --> 01:29:18,860
come, letteralmente, la barra inversa virgolette.

1784
01:29:18,860 --> 01:29:20,230
E c'è qualche altro ancora.

1785
01:29:20,230 --> 01:29:24,540
E vedremo più di quelli
nell'uso reale non molto.

1786
01:29:24,540 --> 01:29:27,930
>> Quindi cerchiamo di passaggio da ora
dei dati, e la rappresentazione,

1787
01:29:27,930 --> 01:29:30,820
e gli operatori aritmetici, tutto
di cui ci ha dato un po 'di costruzione

1788
01:29:30,820 --> 01:29:32,070
blocchi con cui giocare.

1789
01:29:32,070 --> 01:29:34,481
Ma ora diamo effettivamente dare
noi il resto del vocabolario

1790
01:29:34,481 --> 01:29:36,230
che abbiamo già avuto
la settimana scorsa con Scratch

1791
01:29:36,230 --> 01:29:39,350
per dare un'occhiata a qualche altro
costrutti in C-- non tutti.

1792
01:29:39,350 --> 01:29:41,680
Ma le idee noi siamo
per vedere in realtà solo

1793
01:29:41,680 --> 01:29:45,610
per sottolineare la traduzione dal
una lingua, Scratch, ad un altro, C.

1794
01:29:45,610 --> 01:29:48,470
>> E nel corso del tempo, ci prendiamo
più strumenti per il nostro toolkit,

1795
01:29:48,470 --> 01:29:49,820
per così dire, sintatticamente.

1796
01:29:49,820 --> 01:29:54,190
E, in effetti, si vedrà che le idee
sono ormai piuttosto familiare della scorsa settimana.

1797
01:29:54,190 --> 01:29:55,200
Quindi cerchiamo di fare questo.

1798
01:29:55,200 --> 01:29:58,870
>> Andiamo avanti e improvvisare un programma
che in realtà utilizza alcune espressioni,

1799
01:29:58,870 --> 01:30:00,720
una espressione booleana.

1800
01:30:00,720 --> 01:30:02,810
Lasciami andare avanti qui
e creare un nuovo file.

1801
01:30:02,810 --> 01:30:06,090
Chiamerò questo condition.c.

1802
01:30:06,090 --> 01:30:09,350
>> Lasciami andare avanti e
includere la libreria CS50.

1803
01:30:09,350 --> 01:30:12,640
E mi permetta di andare avanti e includo
standard di io.h per le nostre funzioni,

1804
01:30:12,640 --> 01:30:14,690
e printf, e altro ancora, rispettivamente.

1805
01:30:14,690 --> 01:30:18,900
Permettetemi di fare a me stesso che boilerplate di
int void main, la cui spiegazione faremo

1806
01:30:18,900 --> 01:30:20,360
tornare in futuro.

1807
01:30:20,360 --> 01:30:23,820
>> Ora vorrei andare avanti e dare
io stesso un int tramite get int.

1808
01:30:23,820 --> 01:30:25,970
Allora mi permetta di andare avanti e fare questo.

1809
01:30:25,970 --> 01:30:30,150
Voglio dire se i è less-- facciamo
distinguere tra positivo, negativo,

1810
01:30:30,150 --> 01:30:31,260
o valori zero.

1811
01:30:31,260 --> 01:30:36,630
>> Quindi, se i è minore di zero, mi permetta
basta questo programma semplicemente dire,

1812
01:30:36,630 --> 01:30:42,370
negativo, backslash n, altro
se i è maggiore di zero.

1813
01:30:42,370 --> 01:30:47,030
Ora sto, ovviamente, andando a dire
printf positivo, backslash n.

1814
01:30:47,030 --> 01:30:50,690
E poi altro se: avrei potuto fare questo.

1815
01:30:50,690 --> 01:30:53,410
>> Ho potuto fare se è uguale a 0.

1816
01:30:53,410 --> 01:30:55,840
Ma io avrei fatto a
Almeno un errore già.

1817
01:30:55,840 --> 01:30:59,480
Ricordiamo che il segno di uguale è
non uguale, come noi esseri umani sanno.

1818
01:30:59,480 --> 01:31:01,010
>> Ma è l'operatore di assegnazione.

1819
01:31:01,010 --> 01:31:05,640
E noi non vogliamo prendere sul 0
destra e metterlo in i sulla sinistra.

1820
01:31:05,640 --> 01:31:11,810
Quindi, per evitare questa confusione, o
forse cattivo uso del segno di uguale,

1821
01:31:11,810 --> 01:31:14,740
gli esseri umani hanno deciso alcuni anni fa,
che in molti linguaggi di programmazione

1822
01:31:14,740 --> 01:31:18,000
quando si desidera controllare per l'uguaglianza
tra la sinistra e la destra,

1823
01:31:18,000 --> 01:31:19,635
che effettivamente utilizzate è pari a pari.

1824
01:31:19,635 --> 01:31:21,010
Così si colpisce il segno di uguale due volte.

1825
01:31:21,010 --> 01:31:25,600
Quando si desidera assegnare da destra
a sinistra, è possibile utilizzare un unico segno di uguale.

1826
01:31:25,600 --> 01:31:29,360
Così abbiamo potuto fare altro questo--
se è uguale a è uguale a zero.

1827
01:31:29,360 --> 01:31:31,710
>> Potrei poi andare a
aprire le mie parentesi graffe,

1828
01:31:31,710 --> 01:31:36,087
e dire, printf 0, backslash n, fatto.

1829
01:31:36,087 --> 01:31:38,170
Ma ricordare come questi
forchette in mezzo alla strada in grado di lavorare.

1830
01:31:38,170 --> 01:31:39,836
E, in realtà, basta pensare alla logica.

1831
01:31:39,836 --> 01:31:41,510
i è un numero.

1832
01:31:41,510 --> 01:31:43,320
Si tratta di un intero, in particolare.

1833
01:31:43,320 --> 01:31:48,600
E questo significa che sta andando ad essere meno
di 0 o maggiore di 0 o 0.

1834
01:31:48,600 --> 01:31:51,600
Quindi non vi è una specie di questo
caso di default implicito.

1835
01:31:51,600 --> 01:31:54,920
>> E così abbiamo potuto, proprio come
Scratch, a meno della else if,

1836
01:31:54,920 --> 01:31:55,747
e solo dire altro.

1837
01:31:55,747 --> 01:31:57,830
Logicamente, se la
programmatore sa c'è solo

1838
01:31:57,830 --> 01:32:01,635
tre secchi in cui un
scenario può fall-- il primo,

1839
01:32:01,635 --> 01:32:03,510
il secondo, o il terzo
in questo case-- non lo fanno

1840
01:32:03,510 --> 01:32:07,100
fastidio aggiungendo la precisione aggiuntivo
e la logica aggiuntiva lì.

1841
01:32:07,100 --> 01:32:09,690
Basta andare avanti con il
caso di default qui di altro.

1842
01:32:09,690 --> 01:32:11,950
>> Ora, andiamo avanti
dopo aver salvato questo, fare

1843
01:32:11,950 --> 01:32:15,760
condizioni dot tagliare conditions--
Non una grande interfaccia utente,

1844
01:32:15,760 --> 01:32:18,914
perché io non sto spingendo la
utente, come ho detto prima.

1845
01:32:18,914 --> 01:32:19,580
Ma va bene.

1846
01:32:19,580 --> 01:32:20,454
Terremo le cose semplici.

1847
01:32:20,454 --> 01:32:21,890
Proviamo il numero 42.

1848
01:32:21,890 --> 01:32:23,240
E questo è positivo.

1849
01:32:23,240 --> 01:32:26,120
Proviamo il numero
negativo 42, negativo.

1850
01:32:26,120 --> 01:32:28,244
>> Proviamo il valore 0.

1851
01:32:28,244 --> 01:32:29,160
E, in effetti, funziona.

1852
01:32:29,160 --> 01:32:33,900
Ora, si vedrà con problemi prima
lunghe, le cose di prova tre volte,

1853
01:32:33,900 --> 01:32:34,980
Probabilmente non è sufficiente.

1854
01:32:34,980 --> 01:32:37,438
Probabilmente si desidera testare alcuni
numeri più grandi, un po 'più piccolo

1855
01:32:37,438 --> 01:32:40,520
numeri, alcuni casi angolo, come
verremo a descriverli.

1856
01:32:40,520 --> 01:32:42,500
>> Ma per ora, questo è un
programma piuttosto semplice.

1857
01:32:42,500 --> 01:32:45,160
E sono abbastanza sicuro che, logicamente,
che cade in tre casi.

1858
01:32:45,160 --> 01:32:49,360
E, in effetti, anche se abbiamo solo
concentrati sui potenziali aspetti negativi

1859
01:32:49,360 --> 01:32:53,480
di imprecisione e troppo pieno, in
realtà dove molti dei problemi di CS50,

1860
01:32:53,480 --> 01:32:56,000
non stiamo andando a preoccuparsi
A proposito, per tutto il tempo,

1861
01:32:56,000 --> 01:32:59,050
questi problemi di troppo pieno e
imprecisioni, perché, infatti, in C,

1862
01:32:59,050 --> 01:33:01,889
non è poi così
facile da evitare quelle cose.

1863
01:33:01,889 --> 01:33:04,180
Se si desidera contare fino
più grande, e più grande, e più grande,

1864
01:33:04,180 --> 01:33:07,510
si scopre ci sono tecniche che
può usare, che spesso coinvolgono cose chiamate

1865
01:33:07,510 --> 01:33:11,240
biblioteche, collezioni di codice, che
altre persone hanno scritto che è possibile utilizzare,

1866
01:33:11,240 --> 01:33:13,910
e altri linguaggi come
Java e altri, in realtà

1867
01:33:13,910 --> 01:33:15,800
rendere molto più facile
a contare ancora più in alto.

1868
01:33:15,800 --> 01:33:19,810
Così è davvero alcuni di questi pericoli
una funzione del linguaggio che si usa.

1869
01:33:19,810 --> 01:33:22,710
E nelle prossime settimane, ci
vedere come pericoloso C davvero

1870
01:33:22,710 --> 01:33:24,950
può essere se non si utilizza in modo corretto.

1871
01:33:24,950 --> 01:33:27,610
Ma da lì, e con
Python, e JavaScript, sarà

1872
01:33:27,610 --> 01:33:32,620
abbiamo strato su alcune protezioni aggiuntive,
ed eseguire meno di tali rischi.

1873
01:33:32,620 --> 01:33:35,820
>> Quindi cerchiamo di fare un po 'di più
logica interessante nel nostro programma.

1874
01:33:35,820 --> 01:33:39,110
Quindi, mi permetta di andare avanti e di creare
un programma denominato Logical

1875
01:33:39,110 --> 01:33:43,804
solo così posso giocare con alcuni
la logica attuale, logical.c.

1876
01:33:43,804 --> 01:33:46,870
Mi limiterò a copiare e incollare un po '
codice da così presto torno

1877
01:33:46,870 --> 01:33:49,950
a questo bel punto di partenza.

1878
01:33:49,950 --> 01:33:53,980
>> Lasciami fare questa volta C. char Sono
andare a dargli un nome di C

1879
01:33:53,980 --> 01:33:58,510
solo perché è convenzionale,
ottenere un carattere dall'utente.

1880
01:33:58,510 --> 01:34:00,730
E facciamo finta come
Sto implementando parte

1881
01:34:00,730 --> 01:34:04,130
di quel programma Rm, la rimozione
programma prima che ha spinto l'utente

1882
01:34:04,130 --> 01:34:05,400
per rimuovere un file.

1883
01:34:05,400 --> 01:34:06,750
Come potremmo fare questo?

1884
01:34:06,750 --> 01:34:11,090
>> Voglio dire, se è uguale a C
è uguale, tra virgolette,

1885
01:34:11,090 --> 01:34:16,304
y, quindi ho intenzione di assumere
che l'utente ha scelto sì.

1886
01:34:16,304 --> 01:34:17,470
Sto solo andando a stampare sì.

1887
01:34:17,470 --> 01:34:19,440
Se fosse in realtà la scrittura
il programma di rimozione,

1888
01:34:19,440 --> 01:34:21,420
potremmo rimuovere il file
con più linee di codice.

1889
01:34:21,420 --> 01:34:22,461
Ma noi terremo le cose semplici.

1890
01:34:22,461 --> 01:34:25,950

1891
01:34:25,950 --> 01:34:31,250
>> Altrimenti, se c è uguale uguale n--
e ora qui, ho intenzione di dire,

1892
01:34:31,250 --> 01:34:32,980
l'utente deve aver significato no.

1893
01:34:32,980 --> 01:34:34,360
E poi gli altri, sai una cosa?

1894
01:34:34,360 --> 01:34:36,200
Non so che altro
l'utente sta per digitare.

1895
01:34:36,200 --> 01:34:38,533
Così sto solo andando a dire che
che è un errore, qualunque

1896
01:34:38,533 --> 01:34:40,070
lui o lei in realtà digitato.

1897
01:34:40,070 --> 01:34:41,180
>> Allora, cosa sta succedendo qui?

1898
01:34:41,180 --> 01:34:44,530
Vi è una differenza fondamentale
rispetto a quello che ho fatto in passato.

1899
01:34:44,530 --> 01:34:49,300
doppi apici, doppi apici, doppio
citazioni, e, tuttavia, virgolette singole,

1900
01:34:49,300 --> 01:34:50,170
apici.

1901
01:34:50,170 --> 01:34:52,860
Risulta in C, che quando
si vuole scrivere una stringa,

1902
01:34:52,860 --> 01:34:56,680
si fa usare le virgolette, proprio come abbiamo
state utilizzando tutto questo tempo con printf.

1903
01:34:56,680 --> 01:35:02,030
>> Ma se si vuole affrontare con un solo
singolo carattere, un cosiddetto char,

1904
01:35:02,030 --> 01:35:03,780
poi effettivamente utilizzati apici.

1905
01:35:03,780 --> 01:35:05,450
Quelli di voi che hanno programmato
prima, non si potrebbe avere

1906
01:35:05,450 --> 01:35:07,850
ha dovuto preoccuparsi di questo
distinzione in alcune lingue.

1907
01:35:07,850 --> 01:35:09,450
In C, esso non importa.

1908
01:35:09,450 --> 01:35:12,560
E così, quando ho un carattere e voglio
per confrontare che char utilizzando eguali

1909
01:35:12,560 --> 01:35:18,350
è uguale a qualche lettera, come Y o N, lo faccio,
anzi, devono avere le virgolette singole.

1910
01:35:18,350 --> 01:35:19,770
>> Ora, andiamo avanti e fare questo.

1911
01:35:19,770 --> 01:35:26,180
Andiamo avanti e facciamo
dot logiche tagliano logico.

1912
01:35:26,180 --> 01:35:27,305
E ora sto venga richiesto.

1913
01:35:27,305 --> 01:35:30,638
Quindi, presumibilmente, una migliore esperienza utente
sarebbe in realtà mi dica cosa fare qui.

1914
01:35:30,638 --> 01:35:33,030
Ma ho intenzione di ciecamente
y dire per Sì, OK, bello.

1915
01:35:33,030 --> 01:35:35,780
>> Corriamo ancora, n per no, bello.

1916
01:35:35,780 --> 01:35:39,610
Supponiamo come certe persone che conosco,
i miei tasto Bloc Maiusc è su troppo spesso.

1917
01:35:39,610 --> 01:35:43,740
Così faccio capitale Y, immettere, errore.

1918
01:35:43,740 --> 01:35:46,130
OK, non è esattamente quello che mi aspetto.

1919
01:35:46,130 --> 01:35:48,170
Infatti, il computer
sta facendo letteralmente ciò

1920
01:35:48,170 --> 01:35:51,794
Ho detto che per verificare la presenza di fare--
minuscole y e minuscole n.

1921
01:35:51,794 --> 01:35:53,960
Questo non si sente come bene
l'esperienza degli utenti, però.

1922
01:35:53,960 --> 01:35:59,010
Mi permetta di chiedere e accetto
sia minuscolo o maiuscolo.

1923
01:35:59,010 --> 01:36:02,090
Così si scopre, si potrebbe desiderare
a dire qualcosa di simile a Scratch,

1924
01:36:02,090 --> 01:36:08,150
come letteralmente o uguale a C
è uguale a capitale singolo y citato.

1925
01:36:08,150 --> 01:36:11,400
Risulta, C non ha
questa parola chiave letterale o.

1926
01:36:11,400 --> 01:36:12,880
>> Ma ha due barre verticali.

1927
01:36:12,880 --> 01:36:15,463
È necessario tenere premuto Shift solito,
se si sta utilizzando una tastiera americana,

1928
01:36:15,463 --> 01:36:18,910
e ha colpito la barra verticale
chiave sopra il tasto invio.

1929
01:36:18,910 --> 01:36:22,410
Ma questa barra verticale
barra verticale significa o.

1930
01:36:22,410 --> 01:36:26,220
>> Se, invece, volevamo
a dire e, come in Scratch,

1931
01:36:26,220 --> 01:36:28,180
potremmo fare e commerciale e commerciale.

1932
01:36:28,180 --> 01:36:31,330
Questo non ha senso logico qui,
perché un essere umano non poteva

1933
01:36:31,330 --> 01:36:37,110
digitato sia y e y minuscola
e il capitale Y come lo stesso carattere.

1934
01:36:37,110 --> 01:36:39,470
Quindi, o è quello che vogliamo qui.

1935
01:36:39,470 --> 01:36:46,280
>> Quindi, se faccio questo in entrambi i luoghi, o c
è uguale a equals capitale N, ora eseguire di nuovo,

1936
01:36:46,280 --> 01:36:49,390
rendere logico, eseguire nuovamente logico.

1937
01:36:49,390 --> 01:36:51,200
Ora, posso digitare y.

1938
01:36:51,200 --> 01:36:53,920
E posso farlo di nuovo con
capitale Y, o al capitale N.

1939
01:36:53,920 --> 01:36:56,630
E potrei aggiungere ulteriore
combinazioni ancora.

1940
01:36:56,630 --> 01:36:58,810
>> Quindi questa è una logica
programma nella misura in cui la società

1941
01:36:58,810 --> 01:37:01,940
Sto controllando logicamente
questo valore o questo valore.

1942
01:37:01,940 --> 01:37:06,420
E io non devo, necessariamente,
venire con altri due IFS oppure IFS.

1943
01:37:06,420 --> 01:37:09,960
Posso effettivamente combinare alcuni dei
correlate logica insieme in questo modo.

1944
01:37:09,960 --> 01:37:11,950
Quindi questo sarebbe meglio
progettata che semplicemente

1945
01:37:11,950 --> 01:37:17,490
dicendo, se è uguale a C minuscola y,
stampare sì, altrimenti se c è uguale a capitale Y,

1946
01:37:17,490 --> 01:37:20,074
stampare sì, altrimenti se c è uguale
lower-- in altre parole,

1947
01:37:20,074 --> 01:37:21,990
non si deve avere
sempre più rami.

1948
01:37:21,990 --> 01:37:28,840
È possibile combinare alcuni dei equivalente
rami logicamente, come in questo modo.

1949
01:37:28,840 --> 01:37:34,150
>> Quindi, diamo uno sguardo a un solo
ingrediente finale, una costruzione finale,

1950
01:37:34,150 --> 01:37:34,847
che permette C.

1951
01:37:34,847 --> 01:37:36,930
E ci torneremo in
futuro per altri ancora.

1952
01:37:36,930 --> 01:37:41,400
E poi ci concludiamo, cercando
di non la correttezza della code--

1953
01:37:41,400 --> 01:37:46,070
ottenere il codice per work-- ma il design
di codice, e piantare quei semi nella fase iniziale.

1954
01:37:46,070 --> 01:37:51,337
>> Quindi, mi permetta di andare avanti e
aprire un nuovo file qui.

1955
01:37:51,337 --> 01:37:51,920
Sai cosa?

1956
01:37:51,920 --> 01:37:54,450
Ho intenzione di re-implementare
quello stesso programma,

1957
01:37:54,450 --> 01:37:55,940
ma utilizzando un costrutto diverso.

1958
01:37:55,940 --> 01:38:00,110
>> Quindi, mi permetta rapidamente donarmi
l'accesso per includere CS50.h

1959
01:38:00,110 --> 01:38:04,150
per la biblioteca CS50,
standard di io.h per printf.

1960
01:38:04,150 --> 01:38:06,510
Dammi il mio int void main.

1961
01:38:06,510 --> 01:38:09,310
E poi qui, lasciare
me andare avanti e fare questo.

1962
01:38:09,310 --> 01:38:12,010
>> Char c ottiene ottenere char, proprio come prima.

1963
01:38:12,010 --> 01:38:16,770
E ho intenzione di utilizzare un nuovo costrutto
now-- passare, su ciò che carattere?

1964
01:38:16,770 --> 01:38:19,820
Così interruttore è un po 'come
commutazione a binari del treno.

1965
01:38:19,820 --> 01:38:22,070
Oppure, in realtà, è una specie di
un altro caso, se il resto se,

1966
01:38:22,070 --> 01:38:23,980
ma scritta in modo diverso.

1967
01:38:23,980 --> 01:38:25,490
>> Un interruttore simile a questa.

1968
01:38:25,490 --> 01:38:29,060
Hai interruttore, e poi cosa
carattere o il numero che si desidera guardare,

1969
01:38:29,060 --> 01:38:32,000
poi alcune parentesi graffe come in
Scratch, basta dire fare questa roba.

1970
01:38:32,000 --> 01:38:33,480
E poi ci sono diversi casi.

1971
01:38:33,480 --> 01:38:34,830
>> Non si utilizza se e altro.

1972
01:38:34,830 --> 01:38:37,050
È letteralmente utilizzare il caso di parola.

1973
01:38:37,050 --> 01:38:38,790
E si potrebbe dire qualcosa di simile.

1974
01:38:38,790 --> 01:38:43,820
>> Così, nel caso di un minuscolo y,
o nel caso di un capitale Y,

1975
01:38:43,820 --> 01:38:47,350
andare avanti e stampare sì.

1976
01:38:47,350 --> 01:38:49,020
E poi uscire l'interruttore.

1977
01:38:49,020 --> 01:38:49,580
Questo è tutto.

1978
01:38:49,580 --> 01:38:50,880
Sono state fatte.

1979
01:38:50,880 --> 01:38:57,270
>> Altrimenti, se, per così dire,
minuscolo n, o il capitale N,

1980
01:38:57,270 --> 01:39:02,560
poi andare avanti e di stampa
fuori no, e poi pausa.

1981
01:39:02,560 --> 01:39:08,022
Else-- e questo tipo di è il
caso di default indeed-- printf error--

1982
01:39:08,022 --> 01:39:10,980
e per buona misura, anche se
logicamente questa rottura non è necessario

1983
01:39:10,980 --> 01:39:12,896
perché siamo alla fine
dell'interruttore comunque,

1984
01:39:12,896 --> 01:39:14,520
Ora sto rompendo fuori dello switch.

1985
01:39:14,520 --> 01:39:16,280
Quindi, questo sembra un po 'diverso.

1986
01:39:16,280 --> 01:39:18,272
>> Ma, logicamente, è
in realtà equivalente.

1987
01:39:18,272 --> 01:39:19,980
E perché useresti
uno sopra l'altro?

1988
01:39:19,980 --> 01:39:23,220
A volte, solo preferenze personali,
a volte l'estetica,

1989
01:39:23,220 --> 01:39:25,420
se Guardo questo
Ora, c'è qualcosa

1990
01:39:25,420 --> 01:39:27,510
da dire per la
la leggibilità del codice.

1991
01:39:27,510 --> 01:39:30,690
Voglio dire, non importa il fatto che questo
il codice è nuovo per molti di noi nella stanza.

1992
01:39:30,690 --> 01:39:33,515
>> Ma è solo un po 'è abbastanza.

1993
01:39:33,515 --> 01:39:37,760
Vedete minuscolo Y, Y capitale,
minuscolo n, di default N maiuscola,

1994
01:39:37,760 --> 01:39:40,150
solo tipo di salti
fuori a voi in modo

1995
01:39:40,150 --> 01:39:42,200
che, probabilmente, forse
Nell'esempio precedente

1996
01:39:42,200 --> 01:39:45,780
con i se, e le barre verticali,
e le IFS altro, non potrebbero avere.

1997
01:39:45,780 --> 01:39:51,600
Quindi questo è veramente una questione di personale
scelta, in realtà, o la leggibilità,

1998
01:39:51,600 --> 01:39:52,360
del codice.

1999
01:39:52,360 --> 01:39:58,230
>> Ma in termini di funzionalità, mi permetta
andare avanti e fare un interruttore, barra dot

2000
01:39:58,230 --> 01:40:05,830
interruttore, e ora digitare y minuscolo,
capitale Y, minuscolo n, N maiuscola,

2001
01:40:05,830 --> 01:40:09,250
David, riprovare perché è
Non un singolo carattere.

2002
01:40:09,250 --> 01:40:12,050
Facciamo x, l'errore, come previsto.

2003
01:40:12,050 --> 01:40:15,640
E, logically-- e questo è qualcosa
Vorrei incoraggiare a general-- anche

2004
01:40:15,640 --> 01:40:17,790
anche se siamo solo graffiare la
superficie di alcune di queste caratteristiche.

2005
01:40:17,790 --> 01:40:20,560
>> E potrebbe non essere evidente quando si
te sedersi alla tastiera,

2006
01:40:20,560 --> 01:40:21,370
come funziona?

2007
01:40:21,370 --> 01:40:22,240
Cosa sarebbe questo fare?

2008
01:40:22,240 --> 01:40:25,630
La cosa bella di avere
un computer portatile, o desktop, o l'accesso

2009
01:40:25,630 --> 01:40:29,290
a un computer con un compilatore,
e con un editor di codice come questo,

2010
01:40:29,290 --> 01:40:32,990
è che si può quasi sempre rispondere a queste
Domande per te solo per provare.

2011
01:40:32,990 --> 01:40:36,570
>> Per esempio, se la retorica
domanda a portata di mano erano,

2012
01:40:36,570 --> 01:40:39,540
cosa succede se si dimentica
le sue dichiarazioni pausa?

2013
01:40:39,540 --> 01:40:41,400
Che è in realtà un
cosa molto comune da fare,

2014
01:40:41,400 --> 01:40:43,540
perché non sembra
come si ha realmente bisogno di loro.

2015
01:40:43,540 --> 01:40:46,790
In realtà non completano la vostra
pensato come una parentesi o un riccio

2016
01:40:46,790 --> 01:40:47,714
brace fa.

2017
01:40:47,714 --> 01:40:49,630
Andiamo avanti e
ricompilare il codice e vedere.

2018
01:40:49,630 --> 01:40:53,690
Quindi, fare interruttore, interruttore barra dot.

2019
01:40:53,690 --> 01:40:56,435
Facciamo digitare in minuscolo
y, il bauletto, Enter.

2020
01:40:56,435 --> 01:40:59,390

2021
01:40:59,390 --> 01:41:00,700
Così ho digitato y.

2022
01:41:00,700 --> 01:41:04,420
>> Il programma ha detto sì, no, errore,
come se stava cambiando la sua mente.

2023
01:41:04,420 --> 01:41:09,280
Ma che tipo di stato, perché ciò che accade
con un interruttore è il primo caso

2024
01:41:09,280 --> 01:41:13,899
partita significa essenzialmente, hey di computer,
eseguire tutto il codice sottostante.

2025
01:41:13,899 --> 01:41:16,690
E se non dici pausa, o
non dire rompere, o non dire pausa,

2026
01:41:16,690 --> 01:41:19,540
il computer sta per soffiare
attraverso tutte quelle linee

2027
01:41:19,540 --> 01:41:22,779
ed eseguire tutti loro fino a quando
si arriva a quella parentesi graffa.

2028
01:41:22,779 --> 01:41:24,320
Così i freni sono, infatti, necessario.

2029
01:41:24,320 --> 01:41:27,120
Ma un take-away qui è, quando
Nel dubbio, provare qualcosa.

2030
01:41:27,120 --> 01:41:29,510
Forse salvare il codice prima,
o salvarlo in un file in più

2031
01:41:29,510 --> 01:41:32,930
se siete veramente preoccupati
incasinare e di dover recuperare

2032
01:41:32,930 --> 01:41:34,430
il lavoro che si sa sta lavorando.

2033
01:41:34,430 --> 01:41:35,410
>> Ma provare cose.

2034
01:41:35,410 --> 01:41:38,074
E non essere così paura, forse,
di ciò che il computer potrebbe fare,

2035
01:41:38,074 --> 01:41:39,490
o che si potrebbe rompere qualcosa.

2036
01:41:39,490 --> 01:41:42,790
Si può sempre ritornare indietro
a qualche versione precedente.

2037
01:41:42,790 --> 01:41:45,640
>> Così finiamo cercando
alla progettazione di codice.

2038
01:41:45,640 --> 01:41:49,020
Abbiamo questa capacità ora di scrivere
le condizioni, e cicli di scrittura,

2039
01:41:49,020 --> 01:41:50,850
e variabili, e le funzioni di chiamata.

2040
01:41:50,850 --> 01:41:54,590
Quindi, francamente, siamo sorta di indietro
dove siamo stati una settimana fa con Scratch,

2041
01:41:54,590 --> 01:42:00,120
anche se con un testo meno convincente
ambiente di Scratch permette.

2042
01:42:00,120 --> 01:42:03,990
>> Ma notiamo quanto velocemente abbiamo acquisito
quel vocabolario, anche se è

2043
01:42:03,990 --> 01:42:07,570
andando a prendere un po 'di tempo per affondare in,
così che ora possiamo utilizzare questo vocabolario

2044
01:42:07,570 --> 01:42:10,320
scrivere programmi più interessanti.

2045
01:42:10,320 --> 01:42:12,940
E facciamo un passo bambino
verso quella, come segue.

2046
01:42:12,940 --> 01:42:14,890
Lasciami andare avanti e
creare un nuovo file qui.

2047
01:42:14,890 --> 01:42:17,750
>> Ho intenzione di chiamare questo
prototype.c, e di introdurre

2048
01:42:17,750 --> 01:42:20,954
per la prima volta, la capacità
per rendere le proprie funzioni.

2049
01:42:20,954 --> 01:42:22,870
Alcuni di voi potrebbero avere
fatto questo con Scratch,

2050
01:42:22,870 --> 01:42:25,430
per cui è possibile creare il
propri blocchi personalizzati in Scratch,

2051
01:42:25,430 --> 01:42:27,892
e poi trascinarli in luogo
ovunque si desidera in C.

2052
01:42:27,892 --> 01:42:30,100
E in più di programmazione
lingue, si può fare esattamente

2053
01:42:30,100 --> 01:42:33,580
che-- fare le proprie funzioni,
se non esistono già.

2054
01:42:33,580 --> 01:42:38,660
>> Così, per esempio, mi permetta di andare avanti
e comprendono CS50.h, e comprendono

2055
01:42:38,660 --> 01:42:43,110
standard di io.h, int void main.

2056
01:42:43,110 --> 01:42:46,020
E ora abbiamo un
segnaposto pronto ad andare.

2057
01:42:46,020 --> 01:42:48,550
Continuo a cose di stampa
come i nomi delle persone di oggi.

2058
01:42:48,550 --> 01:42:51,910
E che si sente like--
Non sarebbe bello se ci

2059
01:42:51,910 --> 01:42:53,936
erano una funzione chiamata nome di stampa?

2060
01:42:53,936 --> 01:42:55,060
Non devo usare printf.

2061
01:42:55,060 --> 01:42:56,976
Non devo ricordare
tutti i codici di formato.

2062
01:42:56,976 --> 01:43:00,050
Perché non, o perché
non l'ha fatto qualcuno prima di me,

2063
01:43:00,050 --> 01:43:02,980
creare una stampa funzione chiamata
nome, che dato qualche nome,

2064
01:43:02,980 --> 01:43:03,980
semplicemente lo stampa fuori?

2065
01:43:03,980 --> 01:43:08,700
>> In altre parole, se io dico, hey,
calcolatore, dammi una stringa

2066
01:43:08,700 --> 01:43:11,870
chiedendo all'utente per tali,
tramite la funzione di stringa get del CS50.

2067
01:43:11,870 --> 01:43:15,090
Hey, computer, messo quella stringa in
la variabile nel lato sinistro,

2068
01:43:15,090 --> 01:43:16,150
e chiamare s.

2069
01:43:16,150 --> 01:43:22,150
E poi, ehi computer, andare avanti
e stampa che il nome della persona, fatto.

2070
01:43:22,150 --> 01:43:26,240
>> Ora, sarebbe bello, perché
questo programma, giustamente intitolato,

2071
01:43:26,240 --> 01:43:29,170
mi dice che cosa dovrebbe fare
a titolo di nomi quelli della funzione.

2072
01:43:29,170 --> 01:43:32,930
Lasciami andare e fare prototipi, Enter.

2073
01:43:32,930 --> 01:43:34,930
E, purtroppo,
questo non sta andando a volare.

2074
01:43:34,930 --> 01:43:39,430
>> Prototype.c, linea 7, carattere
5, l'errore, dichiarazione implicita

2075
01:43:39,430 --> 01:43:42,960
della funzione nome di stampa
è invalido in C99, C99

2076
01:43:42,960 --> 01:43:45,130
cioè una versione di C
che è venuto fuori nel 1999.

2077
01:43:45,130 --> 01:43:45,730
È tutto.

2078
01:43:45,730 --> 01:43:48,780
>> Quindi io non so cosa
tutto questo significa ancora.

2079
01:43:48,780 --> 01:43:50,810
Ma lo faccio riconoscere l'errore in rosso.

2080
01:43:50,810 --> 01:43:51,770
Questo è abbastanza ovvio.

2081
01:43:51,770 --> 01:43:53,769
>> E sembra che con
il carattere verde qui,

2082
01:43:53,769 --> 01:43:57,520
il problema è con il nome di stampa, aperto
paren s, vicino paren, punto e virgola.

2083
01:43:57,520 --> 01:44:01,800
Ma dichiarazione implicita di
Funzione abbiamo visto brevemente in precedenza.

2084
01:44:01,800 --> 01:44:04,880
Questo significa, semplicemente, che Clang
non so se mi spiego.

2085
01:44:04,880 --> 01:44:09,000
>> Ho usato una parola del vocabolario che è
mai visto o stato insegnato prima.

2086
01:44:09,000 --> 01:44:11,950
E quindi ho bisogno di insegnare
che cosa significa questa funzione.

2087
01:44:11,950 --> 01:44:13,590
Quindi ho intenzione di andare avanti e farlo.

2088
01:44:13,590 --> 01:44:17,970
>> Ho intenzione di andare avanti e mettere in atto
la mia funzione chiamata Stampa Nome.

2089
01:44:17,970 --> 01:44:24,720
E ho intenzione di dire, come segue, che
lo fa, printf, ciao, cento

2090
01:44:24,720 --> 01:44:27,760
s, backslash n, nome, punto e virgola.

2091
01:44:27,760 --> 01:44:29,250
Così che cosa faccio e basta?

2092
01:44:29,250 --> 01:44:31,325
>> Così si scopre, a
implementare la propria funzione,

2093
01:44:31,325 --> 01:44:33,845
abbiamo tipo di prestito alcuni dei
la stessa struttura principale

2094
01:44:33,845 --> 01:44:35,720
che abbiamo appena stati
dato per scontato, e io

2095
01:44:35,720 --> 01:44:37,730
conoscere semplicemente copiando e
incollando più o meno quello

2096
01:44:37,730 --> 01:44:39,170
Ho scritto in passato.

2097
01:44:39,170 --> 01:44:40,570
Ma notare il modello qui.

2098
01:44:40,570 --> 01:44:43,750
Int, principale, Vuoto, dovremo prendere in giro a parte
fra non molto che cosa significa in realtà.

2099
01:44:43,750 --> 01:44:46,160
>> Ma per oggi, proprio
notare il parallelismo.

2100
01:44:46,160 --> 01:44:48,210
Void, nome di stampa,
string name, quindi non c'è

2101
01:44:48,210 --> 01:44:50,310
una parola chiave viola, che
stiamo per iniziare

2102
01:44:50,310 --> 01:44:54,067
chiamando un tipo di ritorno, il nome
la funzione, e quindi l'ingresso.

2103
01:44:54,067 --> 01:44:56,400
Quindi, in realtà, siamo in grado di distillare
questo tipo di come la settimana scorsa

2104
01:44:56,400 --> 01:44:59,030
come, questo è il nome o
Algoritmo del codice siamo

2105
01:44:59,030 --> 01:45:00,761
andando a write-- la
algoritmo sottostante

2106
01:45:00,761 --> 01:45:02,010
il codice che andremo a scrivere.

2107
01:45:02,010 --> 01:45:03,180
>> Questo è il suo ingresso.

2108
01:45:03,180 --> 01:45:04,670
Questa è la sua uscita.

2109
01:45:04,670 --> 01:45:08,730
Questa funzione, nome di stampa, è
progettato per prendere una stringa chiamata nome,

2110
01:45:08,730 --> 01:45:11,350
o qualunque, come input, e quindi nulla.

2111
01:45:11,350 --> 01:45:13,904
Esso non restituisce nulla,
come ottenere stringa o ottenere int fa.

2112
01:45:13,904 --> 01:45:15,570
Così sta andando a consegnare me qualcosa di nuovo.

2113
01:45:15,570 --> 01:45:17,960
E 'solo andando ad avere un
effetto collaterale, per così dire,

2114
01:45:17,960 --> 01:45:19,570
di stampare il nome di una persona.

2115
01:45:19,570 --> 01:45:22,260
Così Noto, linea 7, I
può chiamare il nome di stampa.

2116
01:45:22,260 --> 01:45:25,920
Linea 10, posso definire
o implementare nome di stampa.

2117
01:45:25,920 --> 01:45:28,450
Ma, purtroppo, questo non è sufficiente.

2118
01:45:28,450 --> 01:45:31,230
>> Lasciami andare avanti e
ricompilare questo dopo il salvataggio.

2119
01:45:31,230 --> 01:45:33,910
Wow, ora, ce l'ho fatta
peggio, sembrerebbe.

2120
01:45:33,910 --> 01:45:37,027
Dichiarazione Così implicita della
Nome funzione di stampa non è valido.

2121
01:45:37,027 --> 01:45:38,360
E, ancora una volta, non c'è più errori.

2122
01:45:38,360 --> 01:45:41,430
Ma, come ho ammonito in precedenza, anche
se si ottiene sopraffatto con,

2123
01:45:41,430 --> 01:45:44,850
o un po 'triste vedere così tanti
errori, si concentrano solo sulla prima

2124
01:45:44,850 --> 01:45:47,500
inizialmente, perché potrebbe solo
hanno avuto un effetto a cascata.

2125
01:45:47,500 --> 01:45:51,970
Quindi C, o Clang più specificamente,
ancora non riconosce il nome di stampa.

2126
01:45:51,970 --> 01:45:54,580
>> E questo perché Clang,
dal disegno, è una specie di muto.

2127
01:45:54,580 --> 01:45:56,280
Lo fa solo quello che gli si dice di fare.

2128
01:45:56,280 --> 01:46:00,950
E lo fa solo in ordine
in cui gli si dice di fare.

2129
01:46:00,950 --> 01:46:05,270
>> Così ho definito principale sulla linea di quattro,
come abbiamo fatto abbastanza spesso.

2130
01:46:05,270 --> 01:46:07,980
Ho definito nome di stampa on line 10.

2131
01:46:07,980 --> 01:46:11,793
Ma sto cercando di usare
nome di stampa on line sette.

2132
01:46:11,793 --> 01:46:13,670
>> E 'troppo presto, non esiste ancora.

2133
01:46:13,670 --> 01:46:19,150
Così ho potuto essere intelligente, e come,
Ok, facciamo solo giocare insieme,

2134
01:46:19,150 --> 01:46:23,680
e spostare il nome di stampa fino
qui, e ricompilare.

2135
01:46:23,680 --> 01:46:24,550
Dio mio.

2136
01:46:24,550 --> 01:46:25,260
Ha funzionato.

2137
01:46:25,260 --> 01:46:26,670
E 'stato così semplice.

2138
01:46:26,670 --> 01:46:28,120
>> Ma la logica è esattamente questo.

2139
01:46:28,120 --> 01:46:30,870
Dovete insegnare Clang cosa
è definendo la funzione prima.

2140
01:46:30,870 --> 01:46:31,920
Quindi è possibile utilizzarlo.

2141
01:46:31,920 --> 01:46:33,940
Ma, francamente, questo si sente
come un pendio scivoloso.

2142
01:46:33,940 --> 01:46:35,773
>> Così ogni volta che corro
in un problema, io sono solo

2143
01:46:35,773 --> 01:46:39,450
andando ad evidenziare e copiare il codice
Ho scritto, tagliarlo e incollarlo qui.

2144
01:46:39,450 --> 01:46:41,370
E, sicuramente, potremmo
escogitare alcuni scenari

2145
01:46:41,370 --> 01:46:43,286
dove una funzione potrebbe
bisogno di chiamare un altro.

2146
01:46:43,286 --> 01:46:46,030
E non si può mettere ogni
funzione di sopra di ogni altra.

2147
01:46:46,030 --> 01:46:47,930
>> Così si scopre c'è
una soluzione migliore.

2148
01:46:47,930 --> 01:46:50,100
Possiamo lasciare che questo sia.

2149
01:46:50,100 --> 01:46:53,677
E, francamente, è generalmente bello,
e comodo, e buon design

2150
01:46:53,677 --> 01:46:56,760
mettere principale prima, perché, di nuovo,
principale, proprio come quando la bandiera verde cliccato,

2151
01:46:56,760 --> 01:46:59,027
cioè la funzione che
viene eseguito per impostazione predefinita.

2152
01:46:59,027 --> 01:47:01,110
Così si potrebbe anche mettere
nella parte superiore del file

2153
01:47:01,110 --> 01:47:03,560
in modo che quando si o qualsiasi
altro essere umano guarda il file

2154
01:47:03,560 --> 01:47:06,360
si sa che cosa sta succedendo
solo leggendo prima principale.

2155
01:47:06,360 --> 01:47:15,360
Così si scopre, possiamo dire Clang
in modo proattivo, ehi, Clang, sulla linea quattro,

2156
01:47:15,360 --> 01:47:17,940
Prometto di implementare
una funzione chiamata Stampa

2157
01:47:17,940 --> 01:47:22,600
Nome che prende il nome di stringa denominata
come input, e restituisce nulla, nulla.

2158
01:47:22,600 --> 01:47:24,770
E io andare in giro a
implementazione in un secondo momento.

2159
01:47:24,770 --> 01:47:25,680
>> Ecco che arriva principale.

2160
01:47:25,680 --> 01:47:29,130
Principali ora in linea 9 può usare
Nome in stampatello perché Clang

2161
01:47:29,130 --> 01:47:32,600
è fiducioso che, alla fine,
si incontrerà la definizione

2162
01:47:32,600 --> 01:47:34,880
dell'attuazione della stampa Nome.

2163
01:47:34,880 --> 01:47:37,390
Così, dopo aver salvato il mio file, lasciate
andare avanti e fare il prototipo,

2164
01:47:37,390 --> 01:47:38,498
guarda bene questa volta.

2165
01:47:38,498 --> 01:47:43,470
Dot taglio su, prototipo, mi permetta
andare avanti e digitare un nome.

2166
01:47:43,470 --> 01:47:48,440
David, ciao David, Zamila, ciao
Zamila, e, anzi, ora funziona.

2167
01:47:48,440 --> 01:47:52,200
>> Quindi, l'ingrediente è che abbiamo
fatto una funzione personalizzata, come un costume

2168
01:47:52,200 --> 01:47:54,219
blocco Scratch stiamo chiamando.

2169
01:47:54,219 --> 01:47:57,010
Ma a differenza di Scratch dove è possibile
basta crearlo e iniziare ad usarlo,

2170
01:47:57,010 --> 01:47:59,330
ora dobbiamo essere un
poco più pedante,

2171
01:47:59,330 --> 01:48:03,410
ed effettivamente formare Clang
da utilizzare o aspettarselo.

2172
01:48:03,410 --> 01:48:09,140
Ora, come un a parte, perché tutto questo tempo hanno
siamo stati solo ciecamente sulla fede compreso

2173
01:48:09,140 --> 01:48:12,170
CS50.h, e compresi di serie io.h?

2174
01:48:12,170 --> 01:48:15,190
>> Beh, si scopre,
Tra un paio di altre cose,

2175
01:48:15,190 --> 01:48:18,550
tutto ciò che è in quelle dot h
file, che si trovano ad essere i file.

2176
01:48:18,550 --> 01:48:20,460
Stanno File di intestazione, per così dire.

2177
01:48:20,460 --> 01:48:23,270
Stanno ancora scritte in C. Ma
sono un altro tipo di file.

2178
01:48:23,270 --> 01:48:28,690
>> Per ora, si può tranquillamente supporre
che tutto ciò che si trova all'interno di CS50.h

2179
01:48:28,690 --> 01:48:33,360
è alcune battute come questo, non
per le funzioni di chiamata Print Nome,

2180
01:48:33,360 --> 01:48:36,840
ma per Get String, Get
Float, e pochi altri.

2181
01:48:36,840 --> 01:48:41,510
E ci sono prototipi simili,
uno fodere, all'interno di standard di io.h

2182
01:48:41,510 --> 01:48:46,241
per printf, che ora è in
la mia funzione di stampa Nome.

2183
01:48:46,241 --> 01:48:49,490
Quindi, in altre parole, tutto questo tempo abbiamo
appena stato ciecamente copiare e incollare

2184
01:48:49,490 --> 01:48:51,780
includere questo, includere
che, cosa sta succedendo?

2185
01:48:51,780 --> 01:48:55,310
Queste sono solo tipo di indizi
per clang da quali funzioni

2186
01:48:55,310 --> 01:49:00,170
sono, infatti, implementato, solo
altrove in file diversi

2187
01:49:00,170 --> 01:49:02,440
altrove nel sistema.

2188
01:49:02,440 --> 01:49:05,160
>> Così abbiamo implementato nome di stampa.

2189
01:49:05,160 --> 01:49:07,910
Lo fa avere questo effetto collaterale di
stampa qualcosa sullo schermo.

2190
01:49:07,910 --> 01:49:10,170
Ma in realtà non
passami qualcosa di nuovo.

2191
01:49:10,170 --> 01:49:12,200
Come facciamo a
l'attuazione di un programma che

2192
01:49:12,200 --> 01:49:14,510
Mi fa consegnare qualcosa di nuovo?

2193
01:49:14,510 --> 01:49:15,580
>> Bene, proviamo questo.

2194
01:49:15,580 --> 01:49:21,360
Lasciami andare avanti e realizzare
un file chiamato return.c

2195
01:49:21,360 --> 01:49:24,530
in modo che possiamo dimostrare come qualcosa
come Get String, o Get Int,

2196
01:49:24,530 --> 01:49:27,340
è in realtà il ritorno
qualcosa di nuovo per l'utente.

2197
01:49:27,340 --> 01:49:29,840
Andiamo avanti e definire int void main.

2198
01:49:29,840 --> 01:49:33,230
>> E, ancora, in futuro, faremo
spiegare ciò che int e quel vuoto

2199
01:49:33,230 --> 01:49:34,090
è in realtà facendo.

2200
01:49:34,090 --> 01:49:35,840
Ma per oggi, ci
prendilo per buono.

2201
01:49:35,840 --> 01:49:39,970
Ho intenzione di andare avanti e printf,
per una buona esperienza utente, x è.

2202
01:49:39,970 --> 01:49:44,360
E poi ho intenzione di aspettare il
utente di darmi x con get int.

2203
01:49:44,360 --> 01:49:48,459
>> E poi ho intenzione di andare avanti
e stampare x al quadrato.

2204
01:49:48,459 --> 01:49:50,500
Così, quando hai solo un
tastiera, la gente comunemente

2205
01:49:50,500 --> 01:49:52,600
usare la piccola carota
simbolo sulla tastiera

2206
01:49:52,600 --> 01:49:55,330
rappresentare al potere
, o l'esponente.

2207
01:49:55,330 --> 01:49:58,960
Quindi x ^ è presente i.

2208
01:49:58,960 --> 01:50:00,660
>> E ora ho intenzione di farlo.

2209
01:50:00,660 --> 01:50:03,940
Ho potuto solo fare-- ciò che è x
al quadrato? x squared è x volte x.

2210
01:50:03,940 --> 01:50:06,690
>> E abbiamo fatto questo un po '
tempo fa già oggi.

2211
01:50:06,690 --> 01:50:08,730
Questo non si sente come
tutto ciò che molti progressi.

2212
01:50:08,730 --> 01:50:09,570
Sai cosa?

2213
01:50:09,570 --> 01:50:13,100
Facciamo leva alcuni di quell'idea
dall'ultima volta di astrazione.

2214
01:50:13,100 --> 01:50:16,080
>> Non sarebbe bello se
c'è una funzione chiamata

2215
01:50:16,080 --> 01:50:18,460
piazza che fa esattamente questo?

2216
01:50:18,460 --> 01:50:20,640
Ancora, alla fine del
giorno, fa la stessa matematica.

2217
01:50:20,640 --> 01:50:22,410
Ma andiamo astratto
via l'idea di prendere

2218
01:50:22,410 --> 01:50:25,280
un numero moltiplicato per
un'altra, e solo dargli un nome,

2219
01:50:25,280 --> 01:50:27,360
come Piazza di questo valore.

2220
01:50:27,360 --> 01:50:29,560
>> E, in altre parole,
C, creiamo una funzione

2221
01:50:29,560 --> 01:50:32,660
chiamato piazza che fa esattamente questo.

2222
01:50:32,660 --> 01:50:34,600
E 'intenzione di essere chiamati quadrato.

2223
01:50:34,600 --> 01:50:35,790
Sta andando a prendere un int.

2224
01:50:35,790 --> 01:50:37,820
E faremo sarà solo
chiamarla n, per impostazione predefinita.

2225
01:50:37,820 --> 01:50:39,403
>> Ma potremmo chiamare tutto ciò che vogliamo.

2226
01:50:39,403 --> 01:50:42,900
E tutto ciò che sta andando a
fare, letteralmente, è il ritorno

2227
01:50:42,900 --> 01:50:45,810
il risultato di n volte n.

2228
01:50:45,810 --> 01:50:48,980
Ma perché è
tornando qualcosa, che

2229
01:50:48,980 --> 01:50:53,690
è la parola chiave in viola Abbiamo
mai visto prima, che, sulla linea 11,

2230
01:50:53,690 --> 01:50:55,410
non si può solo dire nulla questa volta.

2231
01:50:55,410 --> 01:51:01,320
>> Void, nell'esempio che abbiamo appena visto
piuttosto di nome di stampa, significa semplicemente,

2232
01:51:01,320 --> 01:51:02,190
Fai qualcosa.

2233
01:51:02,190 --> 01:51:04,170
Ma non mi consegnare qualcosa in cambio.

2234
01:51:04,170 --> 01:51:06,790
In questo caso, voglio
per tornare n volte n,

2235
01:51:06,790 --> 01:51:08,460
o qualunque cosa sia, quel numero.

2236
01:51:08,460 --> 01:51:12,460
>> Quindi non posso dire, ehi, computer,
Torno nulla, nulla.

2237
01:51:12,460 --> 01:51:16,166
E 'intenzione di tornare, per sua natura, un int.

2238
01:51:16,166 --> 01:51:17,790
E così questo è tutto quello che sta succedendo qui.

2239
01:51:17,790 --> 01:51:20,070
>> L'ingresso al quadrato
sta per essere un int.

2240
01:51:20,070 --> 01:51:24,760
E in modo che possiamo usare, deve
avere un nome, N. E 'intenzione di uscita

2241
01:51:24,760 --> 01:51:26,240
un int che non ha bisogno di un nome.

2242
01:51:26,240 --> 01:51:29,590
Siamo in grado di lasciare a principale, o chiunque sia
con me per ricordare questo valore se noi

2243
01:51:29,590 --> 01:51:31,120
vuole con la propria variabile.

2244
01:51:31,120 --> 01:51:33,230
>> E, ancora, l'unica nuova
parola chiave qui è di ritorno.

2245
01:51:33,230 --> 01:51:34,480
E sto solo facendo un po 'di matematica.

2246
01:51:34,480 --> 01:51:41,825
Se volevo davvero essere inutile,
Potrei dire int prodotto ottiene n volte n.

2247
01:51:41,825 --> 01:51:44,170
>> E poi potrei dire, prodotto di ritorno.

2248
01:51:44,170 --> 01:51:47,360
Ma, ancora una volta, al mio punto precedente di
Questo semplicemente non essere buono design--

2249
01:51:47,360 --> 01:51:50,060
Come, perché introdurre un nome,
un simbolo, come il prodotto,

2250
01:51:50,060 --> 01:51:51,570
solo per tornare immediatamente?

2251
01:51:51,570 --> 01:51:53,670
E 'un po' più pulito,
un po 'più stretto, così

2252
01:51:53,670 --> 01:51:59,380
a parlare, solo per dire i tempi di ritorno n
n, sbarazzarsi di questa linea del tutto.

2253
01:51:59,380 --> 01:52:02,860
>> Ed è solo meno codice per leggere,
meno opportunità per gli errori.

2254
01:52:02,860 --> 01:52:05,180
E vediamo se questo
in realtà ora funziona.

2255
01:52:05,180 --> 01:52:09,380
Ora, ho intenzione di andare
avanti e fare ritorno.

2256
01:52:09,380 --> 01:52:11,460
>> Uh-oh, implicita dichiarazione di funzione.

2257
01:52:11,460 --> 01:52:14,080
Ho fatto questo errore prima, un grosso problema.

2258
01:52:14,080 --> 01:52:18,950
Vorrei solo tipo, o evidenziare e
copiare, la stessa identica funzione di prototipo,

2259
01:52:18,950 --> 01:52:21,342
o la firma, della funzione di quassù.

2260
01:52:21,342 --> 01:52:22,800
Oppure avrei potuto spostare l'intera funzione.

2261
01:52:22,800 --> 01:52:23,841
>> Ma questo è un po 'pigro.

2262
01:52:23,841 --> 01:52:24,870
In modo da non farlo.

2263
01:52:24,870 --> 01:52:27,960
Ora, permettetemi di fare ritorno
ancora una volta, dot ritorno barra.

2264
01:52:27,960 --> 01:52:32,790
>> x è 2. x Squared è 4.
x è 3. x Squared è 9.

2265
01:52:32,790 --> 01:52:35,300
E la funzione sembra
ora di lavorare.

2266
01:52:35,300 --> 01:52:36,550
Allora, qual è la differenza qui?

2267
01:52:36,550 --> 01:52:42,520
Ho una funzione che si chiama piazza,
in questo caso, che ho messo in un ingresso.

2268
01:52:42,520 --> 01:52:43,830
E torno un'uscita.

2269
01:52:43,830 --> 01:52:46,210
Eppure, in precedenza, se
Apro l'altro esempio

2270
01:52:46,210 --> 01:52:51,640
da prima, che
è stato chiamato prototype.c,

2271
01:52:51,640 --> 01:52:54,770
Ho avuto il nome di stampa, che
restituito vuoto, per così dire,

2272
01:52:54,770 --> 01:52:58,730
O è tornato nulla, e
semplicemente ha avuto un effetto collaterale.

2273
01:52:58,730 --> 01:53:00,230
>> Allora, cosa sta succedendo qui?

2274
01:53:00,230 --> 01:53:03,520
Beh, si consideri la funzione
ottenere corda solo per un momento.

2275
01:53:03,520 --> 01:53:06,570
Abbiamo utilizzato la funzione
ottenere stringa nel modo seguente.

2276
01:53:06,570 --> 01:53:10,464
>> Abbiamo avuto una funzione get
stringa, come includono CS50.h,

2277
01:53:10,464 --> 01:53:16,624
includere standard di io.h, int, principale, vuoto.

2278
01:53:16,624 --> 01:53:18,790
E poi ogni volta che ho
chiamato stringa di ottenere finora,

2279
01:53:18,790 --> 01:53:23,260
Ho detto qualcosa di simile, stringa s
ottiene ottenere stringa, perché get string--

2280
01:53:23,260 --> 01:53:27,880
chiamiamolo questa stringa get get.c--
si restituisce una stringa che posso poi

2281
01:53:27,880 --> 01:53:32,050
usare, e dire ciao, virgola,
cento s, backslash n, s.

2282
01:53:32,050 --> 01:53:35,660
>> Quindi questo è lo stesso esempio,
in realtà, che abbiamo avuto in precedenza.

2283
01:53:35,660 --> 01:53:37,920
Quindi, ottenere stringa restituisce un valore.

2284
01:53:37,920 --> 01:53:41,260
Ma un momento fa, stringa di stampa
non restituisce un valore.

2285
01:53:41,260 --> 01:53:42,721
Essa ha semplicemente un effetto collaterale.

2286
01:53:42,721 --> 01:53:44,220
Quindi questa è una differenza fondamentale.

2287
01:53:44,220 --> 01:53:46,710
Abbiamo visto diversi
tipi di funzioni ora,

2288
01:53:46,710 --> 01:53:49,490
alcuni dei quali sono tornati
valori, alcuni dei quali non lo fanno.

2289
01:53:49,490 --> 01:53:51,890
Quindi forse è stringa o int o float.

2290
01:53:51,890 --> 01:53:53,480
O forse è solo vuoto.

2291
01:53:53,480 --> 01:53:55,710
>> E la differenza è
che tali funzioni che

2292
01:53:55,710 --> 01:53:59,940
ottenere i dati e restituire un valore sono in realtà
portare qualcosa di nuovo al tavolo,

2293
01:53:59,940 --> 01:54:01,110
per così dire.

2294
01:54:01,110 --> 01:54:03,710
Quindi andiamo avanti e
guardare un set finale

2295
01:54:03,710 --> 01:54:09,129
esempi che dà un senso, ora,
Come possiamo, anzi, astratto meglio,

2296
01:54:09,129 --> 01:54:11,670
e meglio, e meglio, o più,
e più, e più, al fine

2297
01:54:11,670 --> 01:54:13,810
scrivere, in ultima analisi, codice migliore.

2298
01:54:13,810 --> 01:54:16,860
Andiamo avanti, e nello spirito
di Scratch, effettuare le seguenti operazioni.

2299
01:54:16,860 --> 01:54:21,700
>> Lasciami andare avanti e includo
CS50.h e standard di io.h.

2300
01:54:21,700 --> 01:54:24,010
Mi permetta di andare avanti e dare
io stesso un int, principale, vuoto.

2301
01:54:24,010 --> 01:54:27,380
E mi permetta di andare avanti, chiamo questo cough.c.

2302
01:54:27,380 --> 01:54:35,510
>> E mi permetta di andare avanti e basta
come Scratch, stampare tosse / n.

2303
01:54:35,510 --> 01:54:37,170
E io voglio fare questo per tre volte.

2304
01:54:37,170 --> 01:54:39,670
Quindi sono, ovviamente, solo andando
copiare e incollare tre volte.

2305
01:54:39,670 --> 01:54:46,440
Ora sto andando a fare
tosse dot tosse barra.

2306
01:54:46,440 --> 01:54:50,120
Diamo me stesso un po 'più spazio
qui, Enter, tosse, tosse, tosse.

2307
01:54:50,120 --> 01:54:53,970
>> C'è, ovviamente, già
possibilità di miglioramento.

2308
01:54:53,970 --> 01:54:55,679
Ho copiato e incollato
un paio di volte oggi.

2309
01:54:55,679 --> 01:54:58,261
Ma questo era solo così non l'ho fatto
necessario digitare il maggior numero di caratteri.

2310
01:54:58,261 --> 01:55:00,250
Ho ancora cambiato ciò che
quelle righe di codice sono.

2311
01:55:00,250 --> 01:55:04,240
>> Queste tre linee sono identiche,
che si sente pigro e in effetti è,

2312
01:55:04,240 --> 01:55:07,110
e probabilmente non è l'approccio giusto.

2313
01:55:07,110 --> 01:55:11,029
Quindi, con quello che l'ingrediente
potremmo migliorare questo codice?

2314
01:55:11,029 --> 01:55:12,570
Non abbiamo per copiare e incollare il codice.

2315
01:55:12,570 --> 01:55:15,070
>> E, in effetti, ogni volta che si sente
te copia e incolla,

2316
01:55:15,070 --> 01:55:17,700
e nemmeno modificare il codice,
probabilità sono c'è un modo migliore.

2317
01:55:17,700 --> 01:55:19,470
E, in effetti, c'è.

2318
01:55:19,470 --> 01:55:22,510
Mi permetta di andare avanti e fare un ciclo for,
anche se la sintassi non potrebbe

2319
01:55:22,510 --> 01:55:24,570
ancora venuto naturalmente.

2320
01:55:24,570 --> 01:55:29,494
>> Fate questo per tre volte, semplicemente
facendo il following--

2321
01:55:29,494 --> 01:55:31,160
e mi capita di conoscere questo dalla pratica.

2322
01:55:31,160 --> 01:55:32,810
Ma abbiamo un certo numero di esempi ora.

2323
01:55:32,810 --> 01:55:34,950
E vedrete on-line
più riferimenti ancora.

2324
01:55:34,950 --> 01:55:37,790
>> Questa è la sintassi sulla linea 6, che
molto simile a Scratch che si ripete

2325
01:55:37,790 --> 01:55:40,090
blocco, ripetere le seguenti tre volte.

2326
01:55:40,090 --> 01:55:41,340
E 'un po' magica, per ora.

2327
01:55:41,340 --> 01:55:43,050
Ma questo otterrà di più,
e più familiare.

2328
01:55:43,050 --> 01:55:45,050
>> E sta andando a ripetere
linea di otto per tre volte,

2329
01:55:45,050 --> 01:55:52,390
in modo che se ho ri-compilare make tosse,
dot taglio su tosse, tosse, tosse, tosse.

2330
01:55:52,390 --> 01:55:54,030
Ancora funziona allo stesso modo.

2331
01:55:54,030 --> 01:55:55,550
Ecco, questo è tutto bello e buono.

2332
01:55:55,550 --> 01:55:58,200
Ma non è molto astratto.

2333
01:55:58,200 --> 01:55:59,371
>> E 'perfettamente corretto.

2334
01:55:59,371 --> 01:56:01,370
Ma ci si sente come se ci
potrebbe essere l'occasione,

2335
01:56:01,370 --> 01:56:03,750
come nel mondo
Scratch, al tipo di avvio

2336
01:56:03,750 --> 01:56:07,530
aggiungere alcune semantiche qui in modo che
Non mi resta che un po 'per il ciclo,

2337
01:56:07,530 --> 01:56:09,867
e una funzione che dice
tosse, o che tossire.

2338
01:56:09,867 --> 01:56:10,450
Sai cosa?

2339
01:56:10,450 --> 01:56:12,620
Vorrei cercare di essere un
po 'più fresco di quello,

2340
01:56:12,620 --> 01:56:16,090
ed effettivamente scrivere una funzione che
ha alcuni effetti collaterali, lo chiamano tosse.

2341
01:56:16,090 --> 01:56:20,830
>> E ci vuole nessun ingresso e
restituisce alcun valore come output.

2342
01:56:20,830 --> 01:56:22,680
Ma sai cosa fa?

2343
01:56:22,680 --> 01:56:29,370
Lo fa questo-- printf,
tra virgolette, tosse.

2344
01:56:29,370 --> 01:56:32,380
>> E ora qui, sto andando
di andare avanti e per int,

2345
01:56:32,380 --> 01:56:36,070
mi viene a zero, i meno di 3, i plus plus.

2346
01:56:36,070 --> 01:56:39,770
Ho intenzione di non fare printf, che è
senza dubbio una implementazione a basso livello

2347
01:56:39,770 --> 01:56:40,270
dettaglio.

2348
01:56:40,270 --> 01:56:41,353
Non mi importa come tossire.

2349
01:56:41,353 --> 01:56:43,240
Voglio solo usare la funzione di tosse.

2350
01:56:43,240 --> 01:56:44,840
E sto solo andando a chiamare la tosse.

2351
01:56:44,840 --> 01:56:46,204
>> Ora, si noti la dicotomia.

2352
01:56:46,204 --> 01:56:49,370
Quando si chiama una funzione, se non lo fai
voler dare ingressi, tutto bene.

2353
01:56:49,370 --> 01:56:51,780
Basta fare paren aperte, chiudere
paren, e il gioco è fatto.

2354
01:56:51,780 --> 01:56:56,271
>> Quando si definisce una funzione, o
dichiarare il prototipo di una funzione,

2355
01:56:56,271 --> 01:56:58,770
se si sa in anticipo che non è
andando a prendere qualsiasi argomento,

2356
01:56:58,770 --> 01:57:01,170
dire nulla in quelle parentesi lì.

2357
01:57:01,170 --> 01:57:05,660
E questo fa certo che si
non abusare accidentalmente.

2358
01:57:05,660 --> 01:57:07,020
Mi permetta di andare avanti e fare la tosse.

2359
01:57:07,020 --> 01:57:08,540
E, naturalmente, ho fatto un errore.

2360
01:57:08,540 --> 01:57:10,410
>> Dannazione, c'è quella
dichiarazione implicita.

2361
01:57:10,410 --> 01:57:11,325
Ma va bene.

2362
01:57:11,325 --> 01:57:12,590
Si tratta di una soluzione semplice.

2363
01:57:12,590 --> 01:57:18,240
Ho solo bisogno il prototipo più in alto
nel mio file di realtà sto usando.

2364
01:57:18,240 --> 01:57:20,070
>> Così ora lasciatemi fare tosse di nuovo, piacevole.

2365
01:57:20,070 --> 01:57:20,790
Ora funziona.

2366
01:57:20,790 --> 01:57:22,930
Fai la tosse, tosse, tosse, tosse.

2367
01:57:22,930 --> 01:57:25,930
Quindi, si potrebbe pensare che siamo veramente
poco più di ingegneria questo problema.

2368
01:57:25,930 --> 01:57:26,763
E, in effetti, ci sono.

2369
01:57:26,763 --> 01:57:28,870
Questo non è un buon
candidato di un programma

2370
01:57:28,870 --> 01:57:31,930
al momento per
refactoring, e fare ciò che è

2371
01:57:31,930 --> 01:57:35,645
chiamato scomposizione gerarchica,
dove si prende un po 'di codice, e quindi

2372
01:57:35,645 --> 01:57:38,790
Si tipo di fattore di cose fuori, così come
attribuire più semantica per loro,

2373
01:57:38,790 --> 01:57:40,930
e riutilizzarlo in ultima analisi, a più lungo termine.

2374
01:57:40,930 --> 01:57:43,490
Ma si tratta di un blocco di costruzione verso
programmi più sofisticati

2375
01:57:43,490 --> 01:57:45,600
che inizieremo
scrivere in breve tempo che

2376
01:57:45,600 --> 01:57:50,090
ci permette di avere il vocabolario
con cui scrivere codice migliore.

2377
01:57:50,090 --> 01:57:52,920
E, in effetti, vediamo se ci
Non si può generalizzare questo ulteriore.

2378
01:57:52,920 --> 01:57:57,984
>> Sembra un po 'zoppo che io, principale,
bisogno di preoccuparsi di questo dannato ciclo for,

2379
01:57:57,984 --> 01:57:59,400
e chiamando ancora e ancora la tosse.

2380
01:57:59,400 --> 01:58:03,050
Perché non posso solo dire tosse,
Si prega di tosse tre volte?

2381
01:58:03,050 --> 01:58:08,170
In altre parole, perché non posso semplicemente
dare un contributo a tossire e fare questo?

2382
01:58:08,170 --> 01:58:11,270
>> Perché non posso solo dire, in
tosse principale tre volte.

2383
01:58:11,270 --> 01:58:13,150
E ora, questo è una specie di magico.

2384
01:58:13,150 --> 01:58:14,540
E 'molto iterativo qui.

2385
01:58:14,540 --> 01:58:15,940
Ed è, infatti, un bambino passo.

2386
01:58:15,940 --> 01:58:19,250
>> Ma solo la capacità di dire su
linea di otto, tosse tre volte,

2387
01:58:19,250 --> 01:58:20,730
è solo così molto più leggibile.

2388
01:58:20,730 --> 01:58:24,210
E, in più, non devo sapere
o interessa come la tosse è implementato.

2389
01:58:24,210 --> 01:58:26,460
E, in effetti, più avanti nel
termine e per i progetti finali,

2390
01:58:26,460 --> 01:58:29,150
se affrontare un progetto con
un compagno di classe o due compagni di classe,

2391
01:58:29,150 --> 01:58:32,370
vi renderete conto che si sta andando a
devono, o vogliono, dividere il lavoro.

2392
01:58:32,370 --> 01:58:34,650
>> E si sta andando a voler decidere
in anticipo, che sta per fare che cosa,

2393
01:58:34,650 --> 01:58:35,483
e in cui i pezzi?

2394
01:58:35,483 --> 01:58:37,520
E non sarebbe bello
se, per esempio,

2395
01:58:37,520 --> 01:58:40,100
farsi carico di scrittura principale, fatto.

2396
01:58:40,100 --> 01:58:43,470
E il tuo compagno di stanza, o il vostro
Partner più in generale,

2397
01:58:43,470 --> 01:58:45,230
si occupa di attuare la tosse.

2398
01:58:45,230 --> 01:58:49,540
>> E questa divisione, questi
pareti di astrazione,

2399
01:58:49,540 --> 01:58:52,310
o strati di astrazione, se
si, sono super potente,

2400
01:58:52,310 --> 01:58:55,480
perché soprattutto per i più grandi,
più programmi complessi e sistemi,

2401
01:58:55,480 --> 01:59:00,070
permette a più persone di costruire
le cose insieme, e in ultima analisi,

2402
01:59:00,070 --> 01:59:02,680
cucire il loro lavoro insieme in questo modo.

2403
01:59:02,680 --> 01:59:05,332
Ma, naturalmente,
bisogno di risolvere ora la tosse.

2404
01:59:05,332 --> 01:59:07,290
Dobbiamo dire tosse
che, ehi, sai una cosa?

2405
01:59:07,290 --> 01:59:11,230
Si sta andando ad avere bisogno di prendere un
input-- quindi non vuoto, ma int e ora.

2406
01:59:11,230 --> 01:59:15,170
Andiamo avanti e mettere in
tosse il int. mi viene a zero.

2407
01:59:15,170 --> 01:59:16,890
>> i è inferiore a quante volte.

2408
01:59:16,890 --> 01:59:18,550
Ho detto tre prima.

2409
01:59:18,550 --> 01:59:20,420
Ma non è quello che voglio.

2410
01:59:20,420 --> 01:59:25,520
Io voglio tosse essere generalizzato a
supportare qualsiasi numero di iterazioni.

2411
01:59:25,520 --> 01:59:28,800
>> Così, in effetti, si tratta di n che voglio,
qualunque sia l'utente mi dice.

2412
01:59:28,800 --> 01:59:31,620
Ora, posso andare avanti e dire la tosse stampa.

2413
01:59:31,620 --> 01:59:34,750
E non importa quale numero
l'utente passa,

2414
01:59:34,750 --> 01:59:36,890
Io iterare che molte volte.

2415
01:59:36,890 --> 01:59:39,160
>> Così, alla fine della giornata,
programma è identico.

2416
01:59:39,160 --> 01:59:42,820
Ma notare tutte queste cose
potrebbe anche essere in un altro file.

2417
01:59:42,820 --> 01:59:45,620
Anzi, non so al
momento come printf è implementato.

2418
01:59:45,620 --> 01:59:47,980
>> Non so al momento come arrivare
stringa, o ottenere int, float o ottenere

2419
01:59:47,980 --> 01:59:48,646
sono implementati.

2420
01:59:48,646 --> 01:59:50,930
E io non voglio
vederli sul mio schermo.

2421
01:59:50,930 --> 01:59:55,320
Così com'è, sto iniziando a concentrarsi su
il mio programma, non quelle funzioni.

2422
01:59:55,320 --> 01:59:59,070
>> E così, in effetti, non appena
avviare factoring codice come questo fuori,

2423
01:59:59,070 --> 02:00:01,397
potremmo anche spostare la tosse
in un file separato?

2424
02:00:01,397 --> 02:00:02,730
Qualcun altro potrebbe attuarlo.

2425
02:00:02,730 --> 02:00:06,810
E voi e il vostro programma di diventare il
molto bello, e molto leggibile,

2426
02:00:06,810 --> 02:00:10,830
senza dubbio, in realtà quattro
programma a riga proprio lì.

2427
02:00:10,830 --> 02:00:13,510
>> Quindi cerchiamo di andare avanti ora
e fare un ulteriore cambiamento.

2428
02:00:13,510 --> 02:00:16,180
Si noti che il mio prototipo
deve cambiare sulla parte superiore.

2429
02:00:16,180 --> 02:00:18,390
Così mi permetta di risolvere che così
Io non vengo sgridato.

2430
02:00:18,390 --> 02:00:22,580
>> Fai la tosse, mi permetta di correre tosse volta
di più, ancora facendo la stessa cosa.

2431
02:00:22,580 --> 02:00:26,010
Ma ora, notare abbiamo un
ingrediente per una versione finale.

2432
02:00:26,010 --> 02:00:26,940
Sai cosa?

2433
02:00:26,940 --> 02:00:29,040
Non voglio tossire solo, necessariamente.

2434
02:00:29,040 --> 02:00:30,802
Voglio avere qualcosa di più generale.

2435
02:00:30,802 --> 02:00:31,510
Allora sai cosa?

2436
02:00:31,510 --> 02:00:32,450
Voglio farlo.

2437
02:00:32,450 --> 02:00:37,140
Voglio avere, molto simile a Scratch
fa, un blocco per esempio, ma non solo

2438
02:00:37,140 --> 02:00:38,680
dire qualcosa di un po 'di numero di volte.

2439
02:00:38,680 --> 02:00:41,510
Lo voglio dire una stringa molto specifico.

2440
02:00:41,510 --> 02:00:43,850
E, di conseguenza, non lo faccio
Lo voglio dire solo colpo di tosse.

2441
02:00:43,850 --> 02:00:47,660
Lo voglio dire qualunque cosa
stringa viene passato.

2442
02:00:47,660 --> 02:00:49,960
>> Così notare, ho generalizzato
questo modo che ora

2443
02:00:49,960 --> 02:00:53,110
per esempio si sente come un buon nome
per questo, come Scratch,

2444
02:00:53,110 --> 02:00:55,530
prende due argomenti, a differenza di Scratch.

2445
02:00:55,530 --> 02:00:56,570
Uno è una stringa.

2446
02:00:56,570 --> 02:00:57,300
Uno è un int.

2447
02:00:57,300 --> 02:00:58,130
>> E ho potuto passare.

2448
02:00:58,130 --> 02:01:00,713
Ho solo un po 'come l'idea di
dire la stringa prima, e poi

2449
02:01:00,713 --> 02:01:01,940
quante volte successive.

2450
02:01:01,940 --> 02:01:03,970
Void significa che ancora
non restituisce nulla.

2451
02:01:03,970 --> 02:01:06,428
Questi sono solo lato visivo
effetti, come con [? Jordan,?]

2452
02:01:06,428 --> 02:01:08,240
un effetto collaterale verbale di urlare.

2453
02:01:08,240 --> 02:01:12,630
Lo fa ancora qualcosa di volte n,
0 fino a, ma non uguale a n.

2454
02:01:12,630 --> 02:01:14,540
Questo significa che i tempi n totali.

2455
02:01:14,540 --> 02:01:16,540
E poi basta stampare
qualunque essa stringa è.

2456
02:01:16,540 --> 02:01:19,060
Così ho davvero generalizzato
questa riga di codice.

2457
02:01:19,060 --> 02:01:22,460
Così ora, come faccio a implementare
la funzione di tosse?

2458
02:01:22,460 --> 02:01:25,520
>> Posso fare tosse vuoto.

2459
02:01:25,520 --> 02:01:28,501
E posso ancora prendere nel modo in cui
molte volte si desidera a tossire.

2460
02:01:28,501 --> 02:01:29,250
Ma sai una cosa?

2461
02:01:29,250 --> 02:01:31,240
Ora posso punt da dire.

2462
02:01:31,240 --> 02:01:36,540
>> Posso chiamare dire con la
parola tosse, passando n.

2463
02:01:36,540 --> 02:01:40,410
E se voglio implementare anche,
solo per divertimento, una funzione di starnuto,

2464
02:01:40,410 --> 02:01:42,290
Posso starnuto un determinato numero di volte.

2465
02:01:42,290 --> 02:01:47,300
E posso tenere il riutilizzo n, perché
notare che m, in questo contesto e la portata

2466
02:01:47,300 --> 02:01:49,470
esiste solo all'interno di questa funzione.

2467
02:01:49,470 --> 02:01:52,767
>> E n in questo contesto solo
esiste all'interno di questa funzione qui.

2468
02:01:52,767 --> 02:01:54,600
Quindi torneremo a
questi problemi di portata.

2469
02:01:54,600 --> 02:02:01,160
E qui, sto solo andando a dire,
Achoo, e poi n volte, punto e virgola.

2470
02:02:01,160 --> 02:02:04,340
>> E ora, ho solo bisogno di prendere in prestito
queste funzioni firme qui.

2471
02:02:04,340 --> 02:02:06,290
Così tosse è corretta.

2472
02:02:06,290 --> 02:02:10,090
starnuto Void è corretto ora.

2473
02:02:10,090 --> 02:02:12,390
>> E ho ancora solo bisogno di dire.

2474
02:02:12,390 --> 02:02:18,990
Quindi ho intenzione di dire, per esempio
stringa s, int n, punto e virgola.

2475
02:02:18,990 --> 02:02:22,010
Così ho Engineered over-the
heck fuori di questo programma.

2476
02:02:22,010 --> 02:02:23,760
>> E questo non lo fa
necessariamente che questo è

2477
02:02:23,760 --> 02:02:26,343
cosa si deve fare quando si scrive
anche il più semplice dei programmi.

2478
02:02:26,343 --> 02:02:29,280
Prendere qualcosa che è, ovviamente,
molto semplice, molto breve,

2479
02:02:29,280 --> 02:02:31,800
e ri-attuarlo
utilizzando modo troppo codice.

2480
02:02:31,800 --> 02:02:34,560
Ma vi si può vedere, e in
ora guardare indietro a questi esempi,

2481
02:02:34,560 --> 02:02:38,610
e realizzare, oh, questi sono i passi
abbiamo preso a generalizzare in realtà,

2482
02:02:38,610 --> 02:02:40,797
di fattore qualcosa,
fino alla fine della giornata

2483
02:02:40,797 --> 02:02:42,380
il mio codice è in realtà piuttosto ragionevole.

2484
02:02:42,380 --> 02:02:45,960
Perché se voglio tosse tre
volte poi starnutiscono tre volte,

2485
02:02:45,960 --> 02:02:50,420
Sto semplicemente andando a rieseguire questo,
programma di rendere la tosse, ed eseguire la tosse.

2486
02:02:50,420 --> 02:02:53,620
E ho tre colpi di tosse
e tre starnuti.

2487
02:02:53,620 --> 02:02:55,990
>> E quindi questa è una base
paradigma, se si vuole,

2488
02:02:55,990 --> 02:03:00,110
per come potremmo fare per
in realtà attuazione di un programma.

2489
02:03:00,110 --> 02:03:03,220
Ma facciamo solo vedere ora che cosa si tratta
abbiamo fatto tutto questo tempo,

2490
02:03:03,220 --> 02:03:06,940
e ciò che alcuni dei pezzi finali
sono alla base di questo semplice comando.

2491
02:03:06,940 --> 02:03:09,620
Alla fine della giornata, abbiamo
stato usando Clang come il nostro compilatore.

2492
02:03:09,620 --> 02:03:11,494
Abbiamo scritto fonte
codice, convertendolo

2493
02:03:11,494 --> 02:03:12,820
via Clang in codice macchina.

2494
02:03:12,820 --> 02:03:15,540
>> E abbiamo usato Fai solo
per facilitare le nostre battute così

2495
02:03:15,540 --> 02:03:20,740
che non abbiamo da ricordare
quegli incantesimi di Clang stesso.

2496
02:03:20,740 --> 02:03:22,640
Ma ciò che è fare effettivamente fare?

2497
02:03:22,640 --> 02:03:24,750
E, a sua volta, ciò che è
Clang effettivamente facendo?

2498
02:03:24,750 --> 02:03:28,790
>> Si scopre, anche se abbiamo semplificato
la discussione di oggi dicendo,

2499
02:03:28,790 --> 02:03:33,090
si prende il codice sorgente, passarlo come
ingresso a un compilatore, che vi dà

2500
02:03:33,090 --> 02:03:35,750
uscita della macchina
codice, risulta non c'è

2501
02:03:35,750 --> 02:03:37,420
a pochi passi differenti dentro.

2502
02:03:37,420 --> 02:03:41,940
E la compilazione sembra essere l'ombrello
termine per tutta una serie di passaggi.

2503
02:03:41,940 --> 02:03:43,970
Ma facciamo solo prendere in giro
questo fuori molto velocemente.

2504
02:03:43,970 --> 02:03:48,070
>> Si scopre che abbiamo fatto
più cose ogni volta che eseguire un programma,

2505
02:03:48,070 --> 02:03:50,990
o ogni volta che compilare un programma di oggi.

2506
02:03:50,990 --> 02:03:55,020
Quindi pre-elaborazione si riferisce a
Questa poi qualsiasi cosa in un programma C,

2507
02:03:55,020 --> 02:03:58,720
come vedremo ancora e ancora,
che inizia con questo simbolo cancelletto,

2508
02:03:58,720 --> 02:04:03,320
o il simbolo hashtag qui, significa
si tratta di una direttiva del preprocessore.

2509
02:04:03,320 --> 02:04:07,330
Ciò significa che, in questo caso, hey
del computer, fare qualcosa con questo file

2510
02:04:07,330 --> 02:04:09,430
prima che realmente compila il mio codice.

2511
02:04:09,430 --> 02:04:15,220
>> In questo caso, hash includono IS,
in sostanza, il modo di C per dire,

2512
02:04:15,220 --> 02:04:19,325
Ehi del computer, andare a prendere i contenuti
di CS50.h e incollarli qui.

2513
02:04:19,325 --> 02:04:22,170
Ehi del computer, andare a prendere il
il contenuto della norma io.h,

2514
02:04:22,170 --> 02:04:24,690
dovunque sia sulla
disco rigido, incollarlo qui.

2515
02:04:24,690 --> 02:04:27,390
Quindi, queste cose succedono
prima durante la pre-elaborazione.

2516
02:04:27,390 --> 02:04:28,880
>> E Clang fa tutto questo per noi.

2517
02:04:28,880 --> 02:04:30,510
E lo fa così maledettamente
veloce, non è necessario nemmeno

2518
02:04:30,510 --> 02:04:32,000
vedere quattro cose distinte che accadono.

2519
02:04:32,000 --> 02:04:34,100
Ma questo è il primo passo del genere.

2520
02:04:34,100 --> 02:04:35,560
>> Cosa succede in realtà dopo?

2521
02:04:35,560 --> 02:04:38,320
Bene, la prossima ufficiale
passo è la compilazione.

2522
02:04:38,320 --> 02:04:40,385
E si scopre che
compilazione di un programma

2523
02:04:40,385 --> 02:04:44,060
tecnicamente significa andare da
il codice sorgente, la roba che abbiamo

2524
02:04:44,060 --> 02:04:47,890
state scrivendo oggi, a qualcosa
chiamato codice assembly, qualcosa

2525
02:04:47,890 --> 02:04:49,260
che sembra un po 'diverso.

2526
02:04:49,260 --> 02:04:51,050
>> E, infatti, possiamo vedere questa veloce reale.

2527
02:04:51,050 --> 02:04:53,890
Mi permetta effettivamente andare nel mio IDE.

2528
02:04:53,890 --> 02:04:58,050
Lasciami andare avanti e ciao.c aperta, che
è il primo programma con cui

2529
02:04:58,050 --> 02:04:59,120
ha cominciato oggi.

2530
02:04:59,120 --> 02:05:04,130
E mi permetta di andare avanti e correre Clang a
po 'diverso, Clang-s, hello.c,

2531
02:05:04,130 --> 02:05:07,720
che in realtà è di andare a
datemi un altro file hello.s.

2532
02:05:07,720 --> 02:05:10,330
>> E probabilmente ci sarà mai
ancora una volta vedere questo tipo di codice.

2533
02:05:10,330 --> 02:05:13,030
Se si prende un livello più basso
classe di sistemi come CS61,

2534
02:05:13,030 --> 02:05:14,920
si vedrà molto di più
di questo tipo di codice.

2535
02:05:14,920 --> 02:05:17,020
Ma questo è il linguaggio assembly.

2536
02:05:17,020 --> 02:05:22,050
Questo è X86 linguaggio assembly
che la CPU che è sotteso

2537
02:05:22,050 --> 02:05:24,460
CS50 IDE in realtà capisce.

2538
02:05:24,460 --> 02:05:27,060
>> E criptico come fa
guardare, si tratta di qualcosa

2539
02:05:27,060 --> 02:05:29,180
il computer capisce abbastanza bene.

2540
02:05:29,180 --> 02:05:30,790
Sub q, questa è una sottrazione.

2541
02:05:30,790 --> 02:05:31,660
Ci sono movimenti.

2542
02:05:31,660 --> 02:05:35,730
>> Ci sta chiamando delle funzioni qui,
x oring, un movimento, un componente aggiuntivo, un pop,

2543
02:05:35,730 --> 02:05:36,430
un ritorno.

2544
02:05:36,430 --> 02:05:38,850
Quindi c'è un po 'di molto
istruzioni di basso livello

2545
02:05:38,850 --> 02:05:41,280
che le CPU capire che
Ho accennato in precedenza.

2546
02:05:41,280 --> 02:05:43,100
Questo è ciò che Intel Inside.

2547
02:05:43,100 --> 02:05:45,030
>> Ci sono modelli di
zeri e quelli che

2548
02:05:45,030 --> 02:05:51,800
mappa a questi arcanamente formulata, ma
un po 'ben di nome-, istruzioni,

2549
02:05:51,800 --> 02:05:52,780
per così dire.

2550
02:05:52,780 --> 02:05:54,780
Questo è ciò che succede quando
si compila il codice.

2551
02:05:54,780 --> 02:05:58,560
Si ottiene assemblaggio
lingua fuori di esso, che

2552
02:05:58,560 --> 02:06:04,680
indica il terzo passo è assemblare
tale codice assemblaggio in, in ultima analisi,

2553
02:06:04,680 --> 02:06:09,080
macchine zeri code-- e quelli, non le
testo che abbiamo appena visto un momento fa.

2554
02:06:09,080 --> 02:06:13,370
>> Quindi pre-trattamento non che trovano
e sostituire, e poche altre cose.

2555
02:06:13,370 --> 02:06:16,430
Compilazione prende la vostra fonte
codice C, codice sorgente

2556
02:06:16,430 --> 02:06:18,980
che abbiamo scritto, al montaggio
codice che abbiamo appena guardò.

2557
02:06:18,980 --> 02:06:22,170
Assemblaggio prende quell'assemblea
codice a zero e uno

2558
02:06:22,170 --> 02:06:24,680
che la CPU sarà davvero
capire alla fine della giornata.

2559
02:06:24,680 --> 02:06:27,630
E il collegamento è l'ultimo passo
ciò accade per noi-- di nuovo,

2560
02:06:27,630 --> 02:06:29,830
così in fretta, non facciamo nemmeno
notice-- che dice,

2561
02:06:29,830 --> 02:06:32,460
Hey, adottare tutti
gli zeri e quelli che

2562
02:06:32,460 --> 02:06:36,750
il risultato di compilazione del codice di David,
e la sua funzione principale in questo caso.

2563
02:06:36,750 --> 02:06:39,160
>> E hey del computer, andare a prendere
tutti gli zeri e

2564
02:06:39,160 --> 02:06:42,180
che il personale ha scritto CS50
all'interno della libreria CS50.

2565
02:06:42,180 --> 02:06:43,440
Mescolare quelli con il David di.

2566
02:06:43,440 --> 02:06:46,648
E hey del computer, andare a prendere tutti gli zeri
e quelli che qualcun altro ha scritto anni

2567
02:06:46,648 --> 02:06:47,470
fa per printf.

2568
02:06:47,470 --> 02:06:49,880
E aggiungere quelli in
tutto, in modo che abbiamo

2569
02:06:49,880 --> 02:06:52,870
ha ottenuto i miei zero e uno, il
zero e uno del personale CS50,

2570
02:06:52,870 --> 02:06:55,370
gli zeri printf e quelli,
e qualsiasi altra cosa che stiamo usando.

2571
02:06:55,370 --> 02:07:00,410
>> Tutti vengono combinati insieme in un unico
programma chiamato, in questo caso, ciao.

2572
02:07:00,410 --> 02:07:03,141
Quindi d'ora in poi, ci sarà solo
usare la parola compilazione.

2573
02:07:03,141 --> 02:07:06,390
E noi dare per scontato che quando
diciamo, compilare il proprio programma, significa,

2574
02:07:06,390 --> 02:07:08,849
hey fare il pre-processing,
l'assemblaggio, e il collegamento.

2575
02:07:08,849 --> 02:07:11,890
Ma c'è in realtà un po 'di roba succosa
succedendo lì sotto la cappa.

2576
02:07:11,890 --> 02:07:13,723
E soprattutto se si
ottenere curioso po 'di tempo,

2577
02:07:13,723 --> 02:07:15,900
si può iniziare a frugare
intorno a questo livello più basso.

2578
02:07:15,900 --> 02:07:19,660
Ma per ora, rendersi conto che
tra i takeaway per oggi

2579
02:07:19,660 --> 02:07:23,420
sono semplicemente la
inizio di un processo,

2580
02:07:23,420 --> 02:07:26,700
di prendere confidenza con
qualcosa di simile ciao mondo.

2581
02:07:26,700 --> 02:07:29,575
In effetti, la maggior parte di quello che abbiamo fatto oggi
di certo non andranno affondare in super veloce.

2582
02:07:29,575 --> 02:07:31,491
E ci vorrà un po 'di
tempo, e una certa pratica.

2583
02:07:31,491 --> 02:07:33,864
E le probabilità sono, si ordinerà
di voler colpire la tastiera

2584
02:07:33,864 --> 02:07:34,780
o urlare verso lo schermo.

2585
02:07:34,780 --> 02:07:35,880
E tutto questo è OK.

2586
02:07:35,880 --> 02:07:38,320
Anche se, forse, cercare di non
farlo nella biblioteca così tanto.

2587
02:07:38,320 --> 02:07:40,820
>> E alla fine, ti
essere in grado, però, di avviare

2588
02:07:40,820 --> 02:07:44,580
vedere modelli, sia in buono codice
che hai scritto e in errori

2589
02:07:44,580 --> 02:07:45,370
che hai fatto.

2590
02:07:45,370 --> 02:07:48,965
E molto simile al processo di
diventando una TF o di una CA è come,

2591
02:07:48,965 --> 02:07:51,590
inizierete a ottenere una migliore e
meglio a vedere quei modelli,

2592
02:07:51,590 --> 02:07:53,774
e solo risolvere il vostro
problemi in definitiva.

2593
02:07:53,774 --> 02:07:56,940
Nel frattempo, ci sarà abbondanza
di noi a dare un supporto, e farti

2594
02:07:56,940 --> 02:07:57,481
attraverso questo.

2595
02:07:57,481 --> 02:07:59,450
E nelle rivalutazioni
per tutti i problemi

2596
02:07:59,450 --> 02:08:01,366
si sarà guidati attraverso
tutti i comandi

2597
02:08:01,366 --> 02:08:05,330
che certamente so da
un sacco di pratica, ormai,

2598
02:08:05,330 --> 02:08:07,380
ma potrebbe aver volato
sopra la testa, per ora.

2599
02:08:07,380 --> 02:08:08,580
E questo è tutto bene.

2600
02:08:08,580 --> 02:08:11,230
>> Ma, in ultima analisi, si sta andando
per iniziare a vedere i modelli emergere.

2601
02:08:11,230 --> 02:08:14,260
E una volta passato tutto il
stupidi dettagli, come parentesi,

2602
02:08:14,260 --> 02:08:16,710
e parentesi graffe, e punti e virgola,
e la roba, francamente,

2603
02:08:16,710 --> 02:08:19,360
che non è affatto
intellettualmente interessante.

2604
02:08:19,360 --> 02:08:22,690
E non è l'obiettivo di
prendere qualsiasi corso introduttivo.

2605
02:08:22,690 --> 02:08:24,410
Sono le idee che stanno alla materia.

2606
02:08:24,410 --> 02:08:26,659
>> È loop, e
le condizioni, e le funzioni,

2607
02:08:26,659 --> 02:08:30,552
e più potentemente l'astrazione,
e il factoring di codice,

2608
02:08:30,552 --> 02:08:33,510
e il buon design, e il buon
stile, e in ultima analisi, la correttezza

2609
02:08:33,510 --> 02:08:37,330
del codice, che è in ultima analisi,
andando a contano di più.

2610
02:08:37,330 --> 02:08:40,925
Così la prossima settimana, ci vorrà questi
idee che abbiamo visto la prima volta in Scratch

2611
02:08:40,925 --> 02:08:42,800
e sono ora tradotti
a C. E cominceremo

2612
02:08:42,800 --> 02:08:45,740
per introdurre il primo della
i domini del mondo reale del corso.

2613
02:08:45,740 --> 02:08:50,140
>> Ci concentriamo sul mondo della sicurezza,
e più specificamente crittografia,

2614
02:08:50,140 --> 02:08:51,980
l'arte di scrambling informazioni.

2615
02:08:51,980 --> 02:08:54,000
E tra i primi
problemi Tu stesso

2616
02:08:54,000 --> 02:08:56,840
si arriva a scrivere oltre
giocando con alcuni dei sintassi

2617
02:08:56,840 --> 02:08:59,880
e risolvere alcuni logico
problemi, in ultima analisi, in breve tempo,

2618
02:08:59,880 --> 02:09:03,960
è quello di arrampicarsi in realtà, o cifrare,
e, infine, decifrare le informazioni.

2619
02:09:03,960 --> 02:09:06,470
E tutto quello che abbiamo fatto
oggi, sarà piuttosto bassa

2620
02:09:06,470 --> 02:09:09,190
livello, è solo andare a permettere
noi a prendere uno, e uno,

2621
02:09:09,190 --> 02:09:13,550
e un altro passo verso sopra
scrivere ancora il codice più interessante.

2622
02:09:13,550 --> 02:09:15,050
>> Quindi, più che la prossima settimana.

2623
02:09:15,050 --> 02:09:17,834

2624
02:09:17,834 --> 02:09:18,762
>> [RIPRODUZIONE VIDEO]

2625
02:09:18,762 --> 02:09:19,690

2626
02:09:19,690 --> 02:09:22,006
>> -Cosa Mi puoi raccontare
l'ultima volta che l'hai visto?

2627
02:09:22,006 --> 02:09:26,041

2628
02:09:26,041 --> 02:09:27,040
-Cosa Posso dire, davvero?

2629
02:09:27,040 --> 02:09:30,500

2630
02:09:30,500 --> 02:09:35,340
Voglio dire, era come qualsiasi altro
le prove di pre-produzione,

2631
02:09:35,340 --> 02:09:40,510
tranne che c'era qualcosa che ha detto
proprio alla fine che mi è rimasta.

2632
02:09:40,510 --> 02:09:44,810

2633
02:09:44,810 --> 02:09:46,640
>> -Questo Era CS50.

2634
02:09:46,640 --> 02:09:49,440

2635
02:09:49,440 --> 02:09:52,190
>> -Che È un taglio a tutti,
grande lavoro su prove.

2636
02:09:52,190 --> 02:09:53,070
>> pranzo di -Che?

2637
02:09:53,070 --> 02:09:54,986
>> Si ', voi ed io possiamo
prendere un panino in un po '.

2638
02:09:54,986 --> 02:09:58,380
Vorrei solo debriefing con
David molto velocemente.

2639
02:09:58,380 --> 02:09:59,160
David?

2640
02:09:59,160 --> 02:10:01,260
David?

2641
02:10:01,260 --> 02:10:03,110
>> [FINE RIPRODUZIONE]

