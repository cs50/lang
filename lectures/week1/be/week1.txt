[МУЗЫКА] DAVID J. малая: Добра, гэта CS50. І гэта адна тыдзень. Так Нагадаем, што ў апошні раз у нулявы тыдні, мы засяродзіліся на вылічальнай мыслення. І мы перайшлі ад таго, каб Драпіны, графічнае праграмаванне мову ад нашых сяброў ў медыя-лабараторыі Масачусецкага тэхналагічнага інстытута. 

І з нуля, так і мы даследуем ідэі, як функцыі і ўмовы, і петлі, і зменныя, і нават падзеі і тэмы, і многае іншае. І сёння, мы будзем працягваць выкарыстоўваць гэтыя ідэі, і сапраўды прымаючы іх за як належнае, але перавесці іх на іншую мову, вядомы як C. Цяпер, C ўяўляе сабой больш традыцыйны мову. Гэта больш нізкі ўзровень мову, калі вы будзеце. 

Гэта чыста тэкстава. І так, на першы погляд, гэта усё будзе выглядаць даволі загадкавым калі вы ніколі не праграмавалі раней. Мы будзем мець кропка з коскі, і круглыя ​​дужкі, і фігурныя дужкі, і многае іншае. Але зразумейце, што нават хоць сінтаксіс аб тым, каб выглядаць крыху незнаёмай большасці з вас, бачыць мінулае. І паспрабаваць убачыць ідэі што, сапраўды, знаёмыя, таму што тут, на тыдзень адзін, што мы пачнем рабіць гэта параўнанне, Першапачаткова, Драпіны у параўнанні з C. 

Так, напрыклад, успомніць, што, калі мы рэалізаваны першы з нашых праграм ў мінулы раз, у нас быў блок, які выглядаў трохі нешта накшталт this-- калі гэта зялёны сьцяг пстрыкнуў, а затым мы мелі адзін ці больш частак галаваломкі пад ім, у гэтым выпадку, скажам, прывітанне свет. Так што, на самай справе, у пустым месцы, калі я націскаю, што зялёны сьцяг каб запусціць сваю праграму, так казаць, гэта блокі, якія атрымліваюць выконваюцца, ці бегчы. І, у прыватнасці, да драпін сказаў, прывітанне, свет. 

Цяпер, я мог бы ўдакладнілі розныя словы тут. Але мы бачым, што, сапраўды, многія з гэтых blocks-- і на самай справе, ў C шмат functions-- можа быць параметризовано або заказной рабіць розныя рэчы. На самай справе, у C, калі мы хочаце канвертаваць, у цяперашні час, гэтая праграма драпіна на гэты іншую мову, мы збіраемся напісаць мала што-нешта накшталт гэтага. 

Вядома, ёсць некаторыя незнаёмыя сінтаксіс там, хутчэй за ўсё, Int, і круглыя ​​дужкі і несапраўднымі. Але printf-- нават калі вы б думаю, што гэта будзе проста раздрукаваць. Але друк азначае друк адфарматаваны, як мы хутка ўбачым. Гэта ў літаральным сэнсе будзе друкаваць да экрана незалежна знаходзіцца ўнутры гэтых дужак, якая Вядома, у дадзеным выпадку, прывітанне свет. 

Але вы заўважыце некаторыя іншыя Сінтаксіс, некаторыя падвойныя двукоссі, што круглыя ​​дужкі ў канцы, паў-абадковай кішкі і таму падобнае. Такім чынам, ёсць некалькі накладных расходаў, так бы мовіць, як пазнавальна і сінтаксічна, што мы збіраемся каб памятаць, перш чым доўга. Але разумею, што з практыкай, гэта пачне выскокваць на вас. 

На самай справе, давайце засяродзімся на тым Функцыя specifically-- у гэтым выпадку, сказаць прывітанне свет. Так бы мовіць, гэта функцыя. Прывітанне свет з'яўляецца параметрам, або аргумент, яго налады. 

І эквівалентнасць ў С проста будзе гэта адна радок тут, дзе Printf эквівалентна, скажам, двайны двукоссі, прывітанне свет эквівалентна, вядома ж, да таго, што ў белай скрынцы там. І зваротны слеш н, хоць колькі-небудзь дзіўна і адсутнічае на пустым месцы, проста будзе мець эфект, мы будзем см у кампутары, як мой Mac ці PC, проста перамяшчаючы курсор на наступны радок. Гэта як удар Калі ласка, увядзіце на клавіятуры. 

Такім чынам, мы бачым, што зноў у хуткім часе. Але па-першае, давайце зірнем на гэта Іншы прыклад, у выпадку завес. Мы павінны былі гэта назаўжды пятлю ў апошні раз, які быў шэраг галаваломкі што зрабіў нешта ў літаральным сэнсе forever-- у дадзеным выпадку, сказаць, прывітанне свет, прывітанне свет, прывітанне свет, прывітанне свет. Так што гэта бясконцы цыкл, у адпаведнасці з праектам. 

У C, калі мы хочам, каб гэта рэалізаваць Тая ж ідэя, мы маглі б проста зрабіць гэта. У той час як дакладна, Printf прывітанне world-- прама цяпер у той час, як раз семантычна, выгляд навявае думка рабіць нешта зноў, і зноў, і зноў, і як доўга? Што ж, нагадаем, што true-- праўда, гэта толькі на адзін ці. 

І праўда, гэта, вядома ж, заўсёды дакладна. Так што гэта свайго роду бессэнсоўная заява проста сказаць, праўда. Але на самой справе, гэта наўмыснае, таму што, калі праўда, то як раз заўсёды дакладна, чым у той час як дакладна як раз мае на ўвазе, калі крыху ўскосна, што наступныя радкі кода паміж гэтымі фігурнымі дужкамі трэба проста выканаць зноў, і зноў, і зноў, і ніколі не спыняцца. 

Але калі вы хочаце, каб вашы пятля, каб спыніць, як мы у мінулы раз з чымсьці накшталт гэта, паўторыце наступныя 50 раз, у З мы можам зрабіць тое ж самае з тым, што называецца для loop-- ключавое слова не будучы ў той час як, але для. І тады ў нас ёсць некаторы новы сінтаксіс тут, з міжнар я роўны 0, я менш, чым 50, я ++. І мы вернемся да гэтага. Але гэта проста як бы мы перавесці мноства блокаў скрыжаваўшы да набору C радкоў кода. 

У той жа час, разглядаць зменныя. І на самай справе, мы проста бачыў адзін хвіліну таму. І ў выпадку нуля, калі мы хацеў абвясціць зменную I для я быць цэлым лікам, проста лік, і мы хочам, каб усталяваць яго да некаторага значэння, мы будзем выкарыстоўваць гэты аранжавы блок here-- ўсталяваць я да 0. 

І мы бачым сёння і за яго межамі, гэтак жа, як на мінулым тыдні, праграмісты робяць амаль заўсёды пачаць адлік з нуля, на самай справе у адпаведнасці з пагадненнем. Але і таму, што адклікае наша абмеркаванне двайковай, найменшая колькасць вы можаце прадстаўляць з любой колькасцю бітаў толькі збіраецца быць 0 сама. І таму мы як правіла, пачынаюць ініцыялізуючы нават нашы зменныя 0. 

А ў З, каб зрабіць тое ж самае, мы будзем казаць Int для цэлага ліку, я толькі па пагадненні. Я мог бы назваць гэтую зменную усё, што я хачу, гэтак жа, як у пустым месцы. І тады роўная 0 толькі правапераемнікаў значэнне 0 з правага боку і змяшчае яго ў зменную, або кантэйнер для захоўвання там, на левым баку. І паў-абадковай кішкі, як мы see-- і мы ўжо бачылі некаторыя з гэтых already-- проста азначае канец думкі. Працягвайце рабіць нешта іншае на лініях, якія вынікаюць. 

Цяпер, што тычыцца лагічных выразаў? Нагадаем, што ў пустым месцы, яны былі выразам якія з'яўляюцца альбо праўдзівымі або false-- пытанні, на самай справе, якія з'яўляюцца альбо праўдзівымі, альбо ілжывымі. Такім чынам, у выпадку нуля, мы маглі б задаць простае пытанне, як гэта, гэта я менш, чым 50? Так што я, зноў жа, з'яўляецца цэлым лікам. Можа быць, мы выкарыстоўваем яго у праграме Скрэтч сачыць за рахункам ці нешта ў гэтым родзе. Так што гэты сінтаксіс тут у пустым месцы проста азначае, гэта я менш, чым 50? Ну, на шчасце, нешта просты ў C. І перакладаць, гэта мы б проста сказаць, што я менш чым 50, выкарыстоўваючы знаёмы ключ на клавіятуры. 

У той жа час, калі вы хочаце сказаць нешта больш агульнае, як, добра, х менш у, дзе кожны х і ў самі па сабе з'яўляюцца зменнымі? Мы можам зрабіць тое ж самае у С, да тых часоў, як мы стварылі гэтыя зменныя ўжо. І мы ўбачым, як зрабіць гэта ў хуткім часе. Мы проста сказалі б х менш у. 

Такім чынам, вы пачынаеце ўбачыць некаторыя агульныя рысы. І тыя людзі, якія зрабілі Драпіны былі, вядома, натхнёныя некаторыя з гэтых асноўных ідэй. І вы ўбачыце, гэты від Сінтаксіс ў многіх languages-- а не проста на пустым месцы, не проста C, але Python, і JavaScript, і іншыя мовы да гэтага часу. 

Разгледзім іншую канструкцыю ад C, паняцце стану, рабіць нешта ўмоўна. Калі нешта дакладна, то гэта зрабіць. Калі нешта яшчэ, праўда, зрабіць гэта. Гэта свайго роду праграмаванне эквівалент развілкі. Можа быць, гэта двухбаковая відэлец, троххадовых відэлец, або больш. І ў пустым месцы, мы маглі б мець бачыў нешта накшталт гэтага. 

Так што гэта адна вялікая адна. Але разгледзім адноснае Прастата логікі. Калі х менш у, то кажуць х менш чым у, інакш, калі х больш у, то кажуць х больш у. І тады, па логіцы рэчаў, калі вы ўспомніце нуля ці проста свой уласны чалавечай інтуіцыі, добра, калі х не болей, чым у, і х ня менш, чым у, то, вядома, х будзе роўны у. Так што ў гэтым выпадку, па ўкладзенасці гэтыя Скрэтч блокі, мы можам дасягнуць трох спосаб скрыжаванне? 

У той жа час, калі мы хочам зрабіць гэта ў C, гэта магчыма выглядае трохі simpler-- па меншай меры, як толькі вы атрымаеце знаёмыя з сінтаксісам. Калі х менш у, Printf х менш у. Інакш, калі х больш у, Printf х больш у. Інакш Printf х роўна y-- і, зноў жа, з тымі, зваротная касая рыса сканчаецца проста для тых новых ліній, так што калі вы на самай справе запусцілі гэты від праграмы было б проста перанесьці курсор у канчатковым рахунку, да наступнай радку экрана. 

Цяпер, тым часам драпіна была іншая больш складаныя функцыі, толькі некаторыя з якіх мы збіраемся першапачаткова рухацца па ўсім свеце, С. І адзін з іх быў называецца спісам у пустым месцы. І гэта быў асаблівы тып зменнай, дазволіла захоўваць некалькі рэчаў у ім назад, да спіны, да спіны, да спіны. 

У C, ён не мае спісы, самі па сабе, але нешта якія ў больш агульным сэнсе называецца масівы, хоць мы вярнуцца пазней у гэтым семестры глядзець на што-то называецца спіс, або сапраўды звязаны спіс. Але цяпер, бліжэй за ўсё эквівалент у C для нас будзе нешта называецца масівам. І масіў проста асаблівы тып зменнай што дазваляе захоўваць дадзеныя назад, да спіны, да спіны, да спіны. 

І сапраўды, у пустым месцы, калі мы хочам атрымаць доступ першы элемент масіва або list-- і я буду называць яго, Паводле пагаднення, ARGV, аргумент вектар, але пра гэта ў хуткім часе. Калі я хачу, каб атрымаць на першым элеменце з ARGV, у свеце нуля вы на самой справе, як правіла, пачаць адлік з 1. 

І такім чынам я мог бы атрымаць пункт 1 ARGV. Гэта проста, як рэалізуецца MIT паняцце спісаў. Але ў C, я збіраюся прасцей проста сказаць, ARGV, што зноў-такі гэтае імя майго list-- або быць ясна, масіў. А калі я хачу першым элементы, я збіраюся выкарыстоўваць квадратныя дужкі, якіх вы магчыма, не часта выкарыстоўваецца пад клавіятурай. 

Але 0 проста азначае, зразумейце мяне першым. Так што ў некаторых выпадках, і як праходзіць час, мы будзем каб пачаць бачыць гэтыя дыхатаміі паміж нуля і С, у выніку чаго драпіна выкарыстоўвае адзін. Мы ў C выкарыстоўваць 0 тут. Але вы хутка зразумееце, як толькі вы разумееце асновы кожнай мовы, г.зн. гэтыя рэчы пачынаюць станавіцца ўсё больш знаёмую па практыцы і практыцы. 

Так што давайце на самай справе цяпер паглядзіце на праграму. Тут павінна быць першым з нашай C Зыходны код для поўных праграм. А праграма, якую мы прапанаваць для разгляду гэта той, які эквівалентны да гэтага раней Скрэтч кавалак. 

Так што тут, у нас ёсць тое, што магчыма, самая простая праграма C Вы можаце напісаць, што на самай справе нешта робіць. Цяпер мы разгледзім мінулае, на дадзены момант, ужо ўключаюць у сябе, стандарт io.h, і гэтыя кут дужкі, і INT, і пустата, і фігурных дужак, і таму падобнае. 

І давайце проста засяродзіцца на тое, што, па меншай меры, інтуітыўна, можа выскачыць на цябе ўжо. На самай справе, галоўным чынам, я не абавязкова ведаць, што гэта такое, але гэтак жа, як было нуля, што, калі зялёны сьцяг пстрыкнуў кавалак галаваломкі, так што робіць C у якасці мовы праграмавання маюць асноўную частку кода, які запускаецца на выкананне па змаўчанні. І сапраўды, гэта ў літаральным сэнсе будзе называцца галоўнай. 

Такім чынам, асноўная функцыя. І гэта спецыяльная функцыя, якая існуе ў C, што пры запуску праграмы, гэта галоўны, які атрымлівае ў падпарадкаванні па змаўчанні. У свеце нуля, гэта, як правіла, калі зялёны сцяг націснуў, што атрымаў па змаўчанні запускаецца. 

У той жа час, мы ўжо бачылі гэта раней, Printf або друк адфарматаваны, гэта будзе функцыя, якая пастаўляецца з C, нароўні з цэлым букетам іншых, што будзе час і час ад зноў жа, для таго, каб зрабіць сапраўды як мяркуе яго назва, надрукаваць што-небудзь. Што мы хочам надрукаваць? Ну, мы ўбачым, што складаючы сімвалаў як these-- прывітанне свет, зваротная касая п у падвойных двукоссях, мы можам сказаць дакладна Printf што друкаваць на экране. 

Але для таго, каб зрабіць што мы, на жаль, трэба ўзяць нешта ўжо загадкавым для нас, людзей, але па меншай меры гэта некалькі readable-- вострыя ўключаюць, стандарт io.h, INT, Асноўны, несапраўдным, Printf, усе магічныя змовы мы толькі што бачылі на экране. Але мы на самай справе павінны пайсці больш аркан да гэтага часу. Спачатку трэба перавесці код што мы пішам у машынны код. І памятаеце з мінулага тыдня, што машыны, па меншай меры, тыя, якія мы ведаем тут, ў канцы дня толькі разумець, нулі і адзінкі. 

І, Божа мой, калі б нам прыйшлося пісаць гэтыя нулі і адзінкі на самай справе праграмы, гэта было б вельмі, вельмі хутка прыняць задавальненне ад чаго-небудзь. Але аказваецца, за апошні тыдзень, што гэтыя мадэлі нулёў і адзінак проста маюць асаблівае значэнне. У некаторых кантэкстах, яны могуць азначаць лік. 

У некаторых выпадках, яны могуць азначаць літары, або колеру, або любую колькасць іншых абстракцый там на. Але гэтак жа, як ваш кампутар мае цэнтральны працэсар, цэнтральны працэсар, або мазгі ўнутры вашага кампутара. Гэта, як правіла, Intel ўнутры, таму што гэта адна з найбуйнейшых кампаній што робіць працэсары для кампутараў. 

Ну, працэсары Intel і іншыя проста вырашылі загадзя што некаторыя мадэлі нулёў і з іх азначаюць канкрэтныя рэчы. Некаторыя мадэлі нулёў і адзінак будзе азначаць, раздрукаваць гэта на экран, або дадаць гэтыя два ліку, або адняць гэтыя два ліку, або перамясціць гэтую частку дадзеных з памяць майго кампутара тут, або любую колькасць іншых вельмі нізкага ўзроўню, але ў канчатковым рахунку, карысна, аперацыі. Але, на шчасце, мы, людзі не збіраюцца неабходна ведаць гэты ўзровень дэталізацыі. На самай справе, гэтак жа, як у мінулы раз, калі мы абстрагуюцца зноў, і зноў, і зноў, Будынак з вельмі нізкага ўзроўню прымітывы як нулёў і адзінак да павышэння ўзроўню паняццяў як лічбы і літары, і колеры, і многае іншае, так мы можам як праграмісты стаяць на плячах іншыя, якія прыходзяць перад намі і выкарыстоўваць праграмнае забеспячэнне, што і іншыя людзі пісалі раней us-- а менавіта праграмы называецца кампілятары. 

C з'яўляецца мовай, які як правіла, складаюцца, што азначае ператвораныя з Зыходны код у машынны код. У прыватнасці, гэта азначае, што у тым, што калі ў вас ёсць свой крыніца код, які вы самі пішаце, як мы хутка будзе праз імгненне на экране, і вы хочаце, каб пераўтварыць яго у канчатковым рахунку, да машыны code-- гэтыя нулі і адзінкі, якія толькі ваш Mac ці ваш кампутар understands-- вы атрымалі першы карміць гэты зыходны код у якасці ўваход у спецыяльны Праграма пад назвай кампілятар, выхад якога мы ўбачым гэта машынны код. І, сапраўды, у мінулы раз мы гаварылі о, на самай справе, у рэшце рэшт, рашэнне праблем. У вас ёсць ўваходы. І ў вас ёсць выхады. І ў вас ёсць нейкія алгарытму ў сярэдзіне. 

Алгарытмы могуць быць, вядома, рэалізаваны ў праграмным забеспячэнні, як мы бачылі з псевдокода на мінулым тыдні і, як мы ўбачым, з фактычным кодам гэты тыдзень. І таму кампілятар на самой справе проста мае набор алгарытмаў ўнутры пра гэта, што ведаюць, як пераўтварыць спецыяльныя ключавыя словы, як асноўны, і Printf, і іншыя, якія мы проста ўбачыў у узорах і нулёў тыя, што Intel ўнутры і іншыя працэсары на самой справе разумее. Так як жа мы гэта робім? Адкуль мы атрымліваем кампілятар? 

Большасць з нас тут ёсць Mac або ПК. І вы працуеце Mac OS, або Для Windows або Linux ці Solaris, або любую колькасць іншых аперацыйныя сістэмы. І сапраўды, мы маглі б выйсці на сетку і спампаваць кампілятар для вашага Mac або ПК для канкрэтнай аперацыйнай сістэмы. Але мы ўсе былі б на розныя старонкі, так бы мовіць. Мы павінны былі б трохі розныя канфігурацыі. І рэчы не будуць працаваць усё роўна. І, сапраўды, у гэтыя дні многія з нас не выкарыстоўваюць праграмнае забеспячэнне, якое працуе толькі на нашых наўтбуках. Замест гэтага мы выкарыстоўваем нешта як у браўзэры, дазваляе нам атрымаць доступ да вэб- прыкладання ў воблаку. А пазней у гэтым семестры, мы будзем рабіць менавіта гэта. Мы будзем пісаць прыкладання або праграмнага забеспячэння з выкарыстаннем code-- ня C, але і іншыя мовы, такія як Python і JavaScript--, якія працуюць у воблаку. 

І зрабіць гэта, мы самі на працягу семестра будзе на самой справе выкарыстаць воблака аснове сярод вядомых як CS50 IDE. Гэта вэб-праграмаванне ахова навакольнага асяроддзя, або комплекснае развіццё серада, язь, які пабудаваны на вяршыні некаторых Праграмнае забеспячэнне з адкрытым зыходным кодам пад назвай Cloud 9. І мы зрабілі некаторыя педагагічныя спрашчэнняў да яго з тым, каб схаваць пэўныя рысы першыя тыдні, якія нам не патрэбныя, пасля чаго вы можаце раскрыць іх і зрабіць большасць усё, што вы хочаце з навакольным асяроддзем. 

І гэта дазваляе нам, таксама, каб папярэдне ўсталяваць пэўны праграмнае забеспячэнне. Такія рэчы, як так званы CS50 бібліятэка, якую мы хутка ўбачым дае нам у C з некаторымі дадатковыя функцыянальныя магчымасці. Так што калі вы ідзяце, у канчатковым рахунку, CS50.io, Вам будзе прапанавана ўвайсці ў сістэму, і як толькі вы робіце, і стварыць кошт бясплатна, вы будзеце мець магчымасць атрымання доступу да асяроддзе, якое выглядае зусім так. 

Цяпер, гэта знаходзіцца ў рэжыме па змаўчанні. Усё прыгожа і ярка на экране. Многія з нас маюць звычку якія працуюць на CS50 кавалак, што гэта даволі позна ў ноч. І вось некаторыя з вас маглі б аддаць перавагу ператварыць яго ў начны рэжым, калі можна так выказацца. 

Але, у канчатковым рахунку, што вы збіраецца ўбачыць у CS50 IDE ёсць тры розных areas-- вобласць на левай частцы, дзе вашыя файлы будуць у воблака, вобласць у правым верхнім куце дзе ваш код будзе рэдагаваць. Вы зможаце адкрыць асобныя ўкладкі для любой праграмы што вы пішаце ў гэтым семестры ўнутры гэтага ў верхнім правым куце. І тады самы arcanely, і тым не менш магутна, ці будзе гэта быць на знізу вядомы як акно тэрмінала. 

Гэта старая школа Інтэрфейс каманднага радка, або CLI, што дазваляе выконваць каманды на computer-- у дадзеным выпадку, кампутар у cloud-- рабіць такія рэчы, як скампіляваць код з зыходнага кода ў машынны код, запускаць праграмы, або пачаць свой вэб-сервер, або для доступу да базы дадзеных, і любую колькасць іншых метадаў што мы пачнем выкарыстоўваць у хуткім часе. Але каб трапіць туды, мы збіраецца на самай справе ёсць выходзіць у інтэрнэт і пачаць гуляць. І зрабіць гэта, давайце спачатку пачаць майстраваць з галоўнай, і напісаць асноўную частку праграмы. І давайце выкарыстоўваць гэтую функцыю Printf, які мы выкарыстоўвалі раней, проста нешта сказаць. 

Дык вось я ўжо ўнутры CS50 IDE. Я ўвайшоў загадзя. І я поўны скрынінг акно. І так, у канчатковым рахунку, вы таксама ў бліжэйшыя праблемы будуць прытрымлівацца аналагічныя крокі, прадаставіць дакументацыю. Так што вам не трэба турбавацца аб паглынаючы кожны маленькі тэхнічны крок што я раблю тут сёння. 

Але вы атрымаеце экран, як гэта. Я, здараецца ў начным рэжыме. І вы можаце ўпрыгожыць усё уверх шляхам адключэння начнога рэжыму. І ў рэшце дзень, вы будзеце бачыць гэтыя тры асноўных areas-- файла браўзэр злева, кодавыя ўкладкі наверсе, і акно тэрмінала ў ніжняй часткі. 

Дазвольце мне ісці наперад і напісаць сваю першую праграму. Я збіраюся прэвентыўна ісці ў файл, Захаваць і захавайце свой файл як hello.c. Сапраўды, у адпаведнасці з пагадненнем, любая праграма, якую мы пішуць, што напісана на мове C павінен быць названы нешта кропка с, у адпаведнасці з пагадненнем. Так што я збіраюся назваць яго hello.c, таму што Я проста хачу сказаць прывітанне да міру. Цяпер я збіраюся павялічыць , І націсніце кнопку Захаваць. І ўсё, што я зараз тут ўкладка у якім я магу пачаць пісаць код. 

Гэта не будзе кампіляваць. Гэта нічога не значыць. І таму нават калі я ператварыў гэта нулёў і адзінак, працэсар будзе мець не Ідэя, што адбываецца навокал. Але калі я пішу радкі, якія адпавядаюць з conventions-- C ўяўляюць сабой С, у зноў жа, гэта language-- з сінтаксісам, як гэта, Printf прывітанне world-- і я маю атрымалі камфортна робячы гэта на працягу доўгага часу. Так што я не думаю, што я зрабіў любыя друкарскія памылкі. 

Але нязменна, самы першы раз, калі вы зробіце гэта, вы будзеце. І тое, што я збіраюся зрабіць, можа вельмі а не працаваць для вас у першы раз. І гэта цалкам нармальна, таму што прама цяпер вы можа проста ўбачыць цэлую шмат навізне, але з цягам часу, як толькі вы асвоіць з гэтай асяроддзем, і гэтая мова, і іншыя, вы пачнеце бачыць рэчы, якія альбо правільна ці няправільна. 

І гэта тое, што навучання стыпендыятаў і вядома памочнікі атрымліваюць так добра на працягу доўгага часу, з'яўляецца плямістасць памылкі або памылкі ў кодзе. Але я сцвярджаю, што ёсць няма памылак у гэтым кодзе. Так што я цяпер хачу, каб запусціць гэтую праграму. 

Цяпер на маім ўласным Mac ці PC, я ў звычка падвойных абразкоў пстрыкаючы калі я хачу, каб запусціць нейкую праграму. Але гэта не мадэль тут. У гэтым асяроддзі, якая з'яўляецца CS50 IDE. Мы выкарыстоўваем аперацыйную Сістэма пад назвай Linux. Linux нагадвае іншае аперацыйная сістэма, як правіла, вядомыя у Unix. І Linux асабліва вядомы які мае каманднага радка па навакольным асяроддзі, CLI. Цяпер мы выкарыстоўваем спецыфічна густ Linux пад назвай Ubuntu. І Ubuntu проста пэўная версія Linux. 

Але гэтыя сістэмы Linux у гэтыя дні робяць на самай справе пастаўляюцца з графічным інтэрфейсам карыстальніка. І той, які мы, здараецца, выкарыстоўваць тут вэб-. Так што гэта можа выглядаць нават трохі адрозніваецца ад чаго-то Вы самі маглі б мець бачыў ці запусціць у мінулым. 

Так што я збіраюся ісці наперад зараз і зрабіце наступнае. Я захаваў гэты файл як hello.c. Я збіраюся ісці наперад і Тып clanghello.c Так Clang для мовы C з'яўляецца кампілятар. Гэта папярэдне ўстаноўлена ў CS50 IDE. І вы можаце загрузіць і абсалютна усталяваць гэта на вашым уласным Mac ці PC. 

Але, зноў жа, вы б не ўсе папярэдняя канфігурацыя робіцца для вас. Так што на дадзены момант, я проста збіраецца запусціць clanghello.c. А цяпер звярніце ўвагу гэты сінтаксіс тут, у канчатковым рахунку разумеюць, проста азначае, што я знаходжуся ў тэчку або каталог з імем працоўнай прасторы. Гэты знак даляра проста канвенцыя сэнсу, увядзіце вашы каманды тут. 

Гэта тое, што называецца хуткае, проста па пагадненні з'яўляецца знак даляра. І калі я іду наперад цяпер і націсніце Enter, нічога, здаецца, не адбылося. Але гэта на самай справе добрая рэч. Чым менш, што адбываецца на ваш экран, тым больш верагодна, ваш код павінен быць правільным, па меншай меры, сінтаксічна. 

Так што, калі я хачу, каб запусціць гэтую праграма, што мне рабіць? Што ж, атрымліваецца, што імя па змаўчанні ў адпаведнасці з пагадненнем для праграм, калі вы не пакажаце Прозвішча, імя, ваша праграма проста a.out. І гэты сінтаксіс таксама, вы будзеце азнаёміцца ​​з раней доўга. 

Дот слэш проста азначае, эй, CS50 IDE, запусціце праграму пад назвай a.out што ўнутры майго бягучага каталога. Гэта кропка азначае бягучы каталог. І мы паглядзім, што іншыя такія паслядоўнасці сімвалаў азначае, у хуткім часе. 

Так што тут мы ідзем, Enter, прывітанне свет. І вы заўважыце, што здарылася? Мала таго, што гэта надрукаваць прывітанне свет. Ён таксама перамясціў курсор на наступны радок. 

І чаму гэта было? Які код, які мы пісалі раней што гарантаваў, што курсор будзе перайсці на наступны радок? Пацешна, што пра кампутар гэта толькі збіраецца рабіць літаральна тое, што вы скажаце ёй зрабіць. 

Так што калі вы скажыце яму PRINTF прывітанне, коска, прабел, свет, блізка цытаты, гэта літаральна толькі збіраецца друкаваць гэтыя сімвалы. Але ў мяне быў гэты асаблівы характар у канцы, нагадаем, зваротнай касой п. І вось што забяспечыла што персанаж пайшоў да наступнай радку экрана. 

На самай справе, дазвольце мне пайсці і зрабіць гэта. Дазвольце мне ісці наперад і выдаліць гэта. Цяпер, звярніце ўвагу, што Верхняя частка майго экрана ёсць маленькі чырвоны святло ў ўкладка з указаннем, Эй, вы не захавалі файл. Так што я збіраюся ісці наперад з кантролем S або каманду S, захавайце файл. Цяпер goes-- пайшоў на moment-- зялёны. А цяпер ён вярнуўся да проста быць побач значок. 

Калі я цяпер запусціць clanghello.c зноў, Enter, кропка слэш, a.out, Enter, вы ўбачыце, што яна па-ранейшаму працуе. Але гэта, магчыма, трохі глючыць. Цяпер мой prompt-- працоўная прастора, а затым, што знак даляра, а затым мой фактычны prompt-- усё ў той жа радку. Так што гэта, вядома, эстэтычная памылка, нават калі гэта на самай справе не лагічная памылка. 

Так што я збіраюся адмяніць тое, што я толькі што зрабіў. Я збіраюся паўторна запусціць a.out. Звярніце ўвагу, я дадаў сімвал новага радка назад. Я захаваў файл. 

Так што я збіраюся паўторна запусціць a.out, и-- Праклён, памылка, памылка, гэта азначае памылку. Такім чынам, памылка ў тым, што нягледзячы на ​​тое, Я дадаў зваротны слэш н там, паўторна захаваны, паўторна запусціў праграму, паводзіны было тое ж самае. Чаму б гэта? 

Я адсутнічае крок, ці не так? Гэта ключавы крок раней было тое, што ў вас ёсць калі вы, мэтай якіх змяніць зыходны код, аказваецца таксама запусціць гэта праз кампілятар зноў так што вы атрымаеце новы машынны код. І машынны код, нулі і адзінкі, будуць амаль ідэнтычныя, але не зусім так, таму што нам трэба, вядома, што новая лінія. 

Такім чынам, каб выправіць гэта, я буду мець патрэбу перазапускаць clanghello.c, увядзіце, кропка слэш, a.out. І зараз, прывітанне свет вярнуўся туды, дзе я чакаю, што гэта будзе. Так што гэта ўсё выдатна і добра. Але a.out гэта даволі дурное імя для праграма, нават калі гэта здараецца, па гістарычных прычынах, default-- азначае мантажныя выхады. 

Але дазвольце мне ісці наперад тут і рабіць гэта па-рознаму. Я хачу, каб мой прывітанне свет праграма на самай справе можна назваць прывітанне. Так што, калі б гэта быў значок на маім працоўны стол, ён не будзе a.out. Гэта будзе называцца прывітанне. 

Такім чынам, каб зрабіць гэта, аказваецца, што Clang, як і многія іншыя праграмы, падтрымлівае аргументы каманднага радка, або сцягі, або перамыкачы, якія проста ўплываюць на яго паводзіны. У прыватнасці, Clang падтрымлівае працяжнік O сцяг, які затым займае другое слова. У гэтым выпадку, я буду як заўгодна, але разумна, назваць гэта прывітанне. Але я мог бы назваць гэта нічога Я хачу, за выключэннем таго, што a.out бы хутчэй да таго ж кропкі. 

А потым проста паказаць імя файла я хачу сабраць. Так што цяпер, нават калі ў пачатку каманды я да гэтага часу ёсць Clang, у канцы каманды Я да гэтага часу імя файла, Цяпер у мяне ёсць гэтыя каманднага радка аргументы, гэтыя сцягі, якія кажуць, ой, дарэчы, выснова-о, файл называецца прывітанне, а не a.out па змаўчанні. 

Так што, калі я ударыў Калі ласка, увядзіце зараз, нічога па-відаць, адбылося. І, тым не менш, зараз я магу зрабіць кропкавы слэш прывітанне. Так што гэта тая ж праграма. Нулі і адзінкі ідэнтычныя ў канцы дня. 

Але яны ў двух розныя files-- a.out, якая з'яўляецца першай версіяй і проста па-дурному імя, і цяпер алё, які з'яўляецца нашмат больш пераканаўчым назва праграмы. Але, калі шчыра, я ніколі будзе памятаць гэта зноў, і зноў, і зноў. І, на самай справе, як мы пішам больш складаныя праграмы, каманды, якія вы будзеце прыйдзецца напісаць збіраюцца атрымаць нават Чым складаней яшчэ. 

І так, каб не хвалявацца. Аказваецца, што людзі, перш чым мы зразумелі, што яны занадта было гэта сапраўды такая ж праблема. Яны таксама не атрымалі таго, каб тыпу даволі доўгія, загадкавыя каманды, не кажучы ўжо памятаю іх. І так людзі перад намі зрабілі іншыя праграмы, якія палягчаюць для кампіляцыі праграмнага забеспячэння. 

І на самай справе, адным з такіх Праграма называецца Make. Так што я збіраюся ісці наперад і рабіць гэта. Я збіраюся адмяніць усе, што я толькі што зрабіў наступным чынам. Дазвольце мне тыпу LS. І вы заўважыце тры things-- a.out, і зорка, прывітанне і зорка, і hello.c. Будзем спадзявацца, што гэта павінна быць трохі інтуітыўным, паколькі раней было няма нічога ў гэтым працоўным прасторы. Там не было нічога, што ў мяне было створаны, пакуль мы не пачалі клас. 

І я стварыў hello.c. Затым я скампіляваў яго, і назваў яго a.out. А потым я скампіляваў яго зноў злёгку па-іншаму і назваў яго прывітанне. Таму ў мяне ёсць тры файла ў гэтым каталогу, у гэтай тэчцы пад назвай Workspace. Цяпер я магу бачыць, што а калі я на самой справе памяншэнні малюнка. 

Калі я прасігналіць тут і глядзець на гэтую верхнюю правую руку кут, як і абяцаў левы правая частка экрана заўсёды збіраецца паказаць вам, што ў Вашым рахунку, што ўнутры CS50 IDE. І ёсць тры файла там. 

Таму я хачу, каб пазбавіцца ад a.out і прывітанне. І, як вы маглі б уявіце сабе інтуітыўна, вам можа сартаваць кантрольнай мышы або націсніце правай кнопкай мышы на гэтым. І гэта маленькае ўсплывальнае меню. Вы можаце спампаваць файл, запусціце яна, прагледзець яго, абнавіць, перайменаваць, або што не. 

І я мог бы проста выдаліць, і ён сыдзе. Але давайце рабіць рэчы з камандай лінія на дадзены момант, з тым, каб атрымаць зручны з гэтым, і зрабіце наступнае. Я збіраюся ісці наперад і выдаліць a.out, увёўшы літаральна rma.out. Аказваецца, каманду для выдаленне або выдаленне нешта, ня выдаліць або выдаліць. 

Гэта больш лаканічна RM, каб зэканоміць вы некалькі націскаў клавіш, і націсніце Enter. Цяпер мы збіраемся быць некалькі загадкава выдаліць рэгулярныя a.out файл. Я сапраўды не ведаю, што такое нерэгулярныя файл будзе яшчэ. Але я хачу, каб выдаліць яго. 

Так што я збіраюся ўвесці к для так. Ці я мог бы ўвесці яго, і націснуць клавішу Enter. І, зноў жа, нічога не здаецца, здараецца. Але гэта, як правіла, добрая рэч. 

Калі я тыпу LS на гэты раз, што я павінен бачыць? Будзем спадзявацца, што проста прывітанне і hello.c. Цяпер, як у бок, вы будзеце заўважыць гэтую зорку, зорачкі, што гэта ў канцы маіх праграм. І яны таксама дэманструюць у зялёны колер. Гэта проста спосаб CS50 асяроддзя IDE з cluing вас у тым, што гэта не зыходны код. Гэта выкананы файл, які запускаецца праграма, якую можна рэальна працаваць робячы кропкавы слэш, а затым яго імя. 

Зараз, дазвольце мне ісці наперад і выдаліць гэта, ГТ прывітанне, Enter, выдаліць рэгулярныя падаць прывітанне, так. А цяпер, калі я тыпу LS, мы вярнуліся да hello.c. Старайцеся не цалкам выдаліць фактычны зыходны код. Нягледзячы на ​​тое, ёсць асаблівасці убудаваны ў CS50 IDE дзе вы можаце прайсці праз гістарычныя версіі і назад у часе, калі вы выпадкова выдаліць нешта, рабіць мець на ўвазе у адпаведнасці з гэтымі падказкамі так ці не, ад таго, што вы на самай справе хочаце зрабіць. І калі я іду да вяршыні левы кут тут, усё, што застаецца hello.c. Такім чынам, ёсць згусткі іншыя каманды, якія вы можа выконваць у свеце Linux, адзін з якіх, зноў жа, зрабіць. І мы збіраемся зрабіць мая праграма ў цяперашні час наступным чынам. 

Замест таго каб рабіць ляск, замест таго, каб рабіць ляск-о, Я збіраюся проста у літаральным сэнсе тыпу, зрабіць прывітанне. А цяпер звярніце ўвагу, я ня друкуе зрабіць hello.c. Я друкую зрабіць прывітанне. 

І гэтая праграма зрабіць што пастаўляецца з CS50 IDE і многае іншае як правіла, з Linux, гэта праграма, якая гэта збіраецца зрабіць праграму пад назвай Hello. І ён збіраецца ўзяць на сябе, па дамове, што калі гэтая праграма можа быць зроблена, гэта будзе зроблена з крыніцы код файл, які сканчаецца на дот з, hello.c. 

Так што, калі я ударыў Enter Цяпер, звярніце ўвагу, што каманда, якая запускаецца на выкананне на самай справе нават больш да таго, чым раней. І гэта таму, што мы папярэдне CS50 IDE, каб мець некаторыя дадатковыя функцыі, убудаваныя ў тым, што нам не трэба проста яшчэ, але хутка будзе. Але галоўнае, каб зразумець, Цяпер у мяне ёсць праграма Hello. 

Калі я зноў ўвесці LS, я ёсць праграма прывітання. І я магу запусціць яго з кропка слэш a.out, няма, так як увесь сэнс гэтага практыкаванне было кропка слэш прывітанне. А зараз у мяне ёсць свой прывітанне свет праграма. Так рухацца наперад, мы амаль заўсёды толькі збіраецца сабраць нашы праграмы выкарыстоўваючы каманду Make. І тады мы будзем запускаць іх кропка слэш, і назва праграмы. Але разумею, што робіць робіць для Вы, гэта сама не кампілятар. Гэта проста праграма выгоды што ведае, як выклікаць кампілятар бегчы так, што вы самі можаце выкарыстоўваць яго. 

Якія існуюць іншыя каманды ў Linux, і ў сваю чаргу CS50 IDE? Мы хутка ўбачым, што ёсць Каманда CD, Змяніць каталог. Гэта дазваляе ў лічаныя ваш інтэрфейс каманднага радка каб рухацца наперад і назад, і адкрыць розныя тэчкі без выкарыстання мышы. 

LS мы бачылі, які выступае за спіс файлы ў бягучым каталогу. Зрабіце Dir, вы можаце верагодна, пачынаюць выснову што яны азначаюць now-- зрабіць каталог, калі вы хочаце стварыць тэчку. RM для выдаліць, RM Dir для выдаліць directory-- і яны, зноў жа, гэта камандны радок эквіваленты таго, што вы маглі б зрабіць у CS50 IDE з дапамогай мышы. Але вы хутка знойдзеце што часам гэта проста нашмат хутчэй, каб зрабіць рэчы з клавіятуры, і ў канчатковым рахунку значна больш магутным. 

Але гэта цяжка сцвярджаць, што усё, што мы рабілі да гэтага часу гэта ўсё, што магутныя, калі ўсе мы казалі ёсць прывітанне свет. І на самай справе, я жорстка закадзіраваў Словы прывітанне свет у маёй праграме. Там няма дынамічнасць яшчэ. Драпіна была на парадак больш цікавым на мінулым тыдні. 

І так давайце там. Давайце крок да што шлях некаторых з гэтых функцый. Так што не толькі C пастаўляюцца з Printf, і гроздья іншых функцый некаторыя з якіх мы ўбачым на працягу доўгага часу, гэта не мае зрабіць усё, што лёгка прама варот ў атрыманні ўвод дадзеных карыстальнікам. 

На самай справе, адно з слабых месцаў такіх моў, як C, і нават Java і яшчэ іншыя, у тым, што яна не зрабіць яго лёгка проста атрымаць такія рэчы, як цэлыя лікі ад карыстальнікаў або радкоў, слоў, і фразы, не кажучы ўжо пра рэчы, як значэння з якая плавае кропкай, ці сапраўдныя лікі з дзесятковымі кропкамі, і сапраўды доўгія колькасці, як мы хутка ўбачым. Так што гэты спіс функцый тут, гэтыя , Як і іншыя кавалачкі галаваломкі да драпін што мы папярэдне ўстаноўлены ў CS50 IDE, які мы будзем выкарыстоўваць на працягу некалькіх тыдняў як трэніровачныя колы рознага роду, і у рэшце рэшт, прыняць іх, і глядзець пад капотам, магчыма, у як гэтыя рэчы рэалізуюцца. 

Але каб зрабіць гэта, давайце на самай справе напісаць праграму. Дазвольце мне ісці наперад прама цяпер. І я збіраюся стварыць новую файл, націснуўшы на гэтую плюсік, і націснуўшы кнопку New File. 

Я збіраюся захаваць гэты наступны адзін, як, скажам, string.c, таму што я хачу, каб гуляць з радкамі. І радок у C проста паслядоўнасць знакаў. Так што цяпер давайце ісці наперад і выканайце наступныя дзеянні. 

Ўключаюць у сябе стандартныя IO.h-- і аказваецца стандартны ўвод-выснова, IO проста азначае, што ўваход і выхад. Так атрымліваецца, што гэтая лінія вось што з'яўляецца суседняй з намі, каб выкарыстоўваць Printf. Printf, вядома, вырабляе выснову. Таму для таго, каб выкарыстоўваць Printf, атрымліваецца што Вы павінны мець гэты радок кода у верхняй частцы файла. 

І мы вернемся да таго, што што на самой справе азначае ў хуткім часе. Аказваецца, што ў любая праграма C Я пішу, Я павінен пачаць гэта з код, які выглядае наступным чынам. І вы заўважыце CS50 IDE і іншае комплекснае развіццё асяроддзя, як ён, будзем старацца як лепш яны могуць скончыць сваю думку. На самай справе, хвіліну назад, калі я адмяніць што я толькі што зрабіў, я ўдарыў Enter. 

Затым я трапіў адкрыты фігурныя дужка, націсніце Enter яшчэ раз. І ён скончыў сваю думку. Гэта дало мне новую лінію, не водступам не менш для добрых стылістычных прычын, чаму мы будзем бачыць. І тады ён аўтаматычна даў мне што фігурнай дужкі, каб скончыць сваю думку. Цяпер, гэта не заўсёды адгадаць, што вы хочаце зрабіць. Але ў большай частцы, гэта робіць захаваць вам некалькі націскаў клавіш. Так што хвіліну назад, мы запусцілі гэты program-- прывітанне, свет, а затым ён быў скампіляваны, а затым пабег. Але няма тут дынамізм. Што рабіць, калі мы хочам рабіць нешта іншае? Ну, што калі б я хацеў на самай справе атрымаць радок ад карыстальніка? Я збіраюся выкарыстоўваць кавалак галаваломкі называецца менавіта that-- атрымаць радок. 

Аказваецца, у C, што, калі вы не хочаце ўнесці свой уклад у кавалак галаваломкі, ці больш правільна да функцыі, вы літаральна толькі што рабіць адкрывалую дужку, закрывае дужкай. Так што, як быццам ёсць няма белага скрыні не ўводзіць у. Скажам блок перад тым была маленькая белая скрынка. У нас няма, што белая скрынка прама цяпер. 

Але калі я называю атрымання радкі, я хочаце змясціць вынік недзе. Такім чынам, вельмі распаўсюджаная парадыгма ў C з'яўляецца выкліку функцыі, як тут атрымання радкі, а затым захаваць яго вяртаецца значэнне. Гэта вынік яго высілак у нечым. 

А што такое пабудаваць у праграмаванні, няхай гэта будзе ў пустым месцы або ў цяперашні час C, што мы можна выкарыстоўваць на самай справе захоўваць што-небудзь? Выклікаецца гэта зменная, ці не так? А ў пустым месцы, мы не вельмі-то ўсё роўна, што адбываецца ў зменных. 

Але ў дадзеным выпадку, мы на самай справе робім. Я збіраюся сказаць радок. І тады я мог бы назваць гэта ўсё, што я хачу. Я буду называць яго імя, атрымлівае атрымаць радок. 

І цяпер, нават калі вы трохі пачатковец у гэтым, звярніце ўвагу, што я не хапае нейкай дэталі. Я забыўся кропка з коскі. Мне трэба, каб скончыць гэтую думку. Так што я буду рухаць курсор, і ўдарыў коскі там. І што я толькі што зрабіў? У гэтым радку кода, нумар 5 у дадзены момант, Я тэлефаную атрымання радкі без якіх-небудзь уваходаў. Так што няма маленькі белы як скрынка Захаваць блок мае. 

Я проста кажу, эй, кампутар, атрымаць мне радок. Знак роўнасці не вельмі знак роўнасці, само па сабе. гэта прызначэнне аператар, а гэта значыць, эй, кампутар, перамясціць значэнне з правага боку на левую. А злева, у мяне ёсць наступнае. 

Эй, кампутар, дайце мне string-- паслядоўнасць знакаў. І называць гэты радок імя. І я нават не называць ягонага імя. 

Я мог бы назваць гэта, умоўна, нешта накшталт S, гэтак жа, як мы выкарыстоўвалі, каб я выкліку зменнай I. Але цяпер мне трэба зрабіць што-то з ім. Было б даволі дурное паспрабуйце скампіляваць гэты код, бег гэтая праграма, нягледзячы на ​​тое, Я атрымліваю радок, таму што гэта яшчэ толькі збіраецца сказаць прывітанне свет. 

Але што, калі я хачу, каб змяніць гэта. Чаму б мне не зрабіць гэта? Працэнт s, коска s. І гэта крыху загадкавымі да гэтага часу. 

Такім чынам, дазвольце мне зрабіць мае зменныя больш ясным. Дазвольце мне назваць імя гэтай зменнай. І давайце паглядзім, калі мы не можам дражніць акрамя таго, што тут адбываецца. 

Так што на лініі пяць, я атрымліваю радок. І я захоўваць гэты радок, незалежна ад таго, як карыстач увёў на яго клавіятуры, у зменнай з імем Name. І атрымліваецца, што Printf не проста прыняць адзін аргумент у два разы каціроўкі, адзін уваход у падвойных двукоссях. 

Гэта можа заняць два, ці тры, ці больш, напрыклад што другі, або трэці, ці чацвёрты, усе імёны зменных, або канкрэтна каштоўнасці, што вы хочаце падключыцца да, дынамічна, гэты радок у двукоссі. Іншымі словамі, тое, што было б няправільна з гэтым? Калі я толькі што сказаў прывітанне імя, зваротны слэш п, выратаваў мой файл, складзены мой код, і пабег гэта, што б адбылося? 

Гэта проста будзе сказаць, прывітанне імя, у літаральным сэнсе N-А-М-Е, які збольшага па-дурному, таму што яна нічым не адрозніваецца ад свету. Так што нічога ў двукоссях тое, што літаральна раздрукавана. Так што, калі я хачу мець запаўняльнік там, Я на самой справе трэба выкарыстоўваць нейкі адмысловы сінтаксіс. І атрымліваецца, калі вы чытаеце дакументацыя для функцыі PRINTF, ён скажа вам, што калі вы выкарыстоўваеце адсотка з, вы можаце замяніць значэнне наступным чынам. 

Пасля коскі пасля гэтага падвойныя двукоссі, вы проста напішыце назву з зменная, якую вы хочаце падключыць ў гэты фармат кода або спецификатор фармату, адсоткаў s для радкоў. І зараз, калі я захаваў мой файл, Я вяртаюся ўніз да майго тэрміналу. І я тыпу Make String, таму што, зноў жа, назва гэтага файл, які я абраў, перш чым гэта string.c. 

Так што я збіраюся сказаць, зрабіць радок, увядзіце. Аб божа мой, паглядзі на ўсё памылкі, якія мы зрабілі ўжо. І гэта is--, што гэта на самай справе як, сем праграм шасці лініі? Так што гэта, дзе гэта можа вельмі хутка атрымаць пераважная. 

Гэта акно тэрмінала мае зараз проста выплюнуў велізарная колькасць паведамленняў пра памылкі. Вядома, у мяне няма больш памылка паведамленняў, чым у мяне ёсць радкі кода. Дык што ж адбываецца? 

Ну, лепшая стратэгія рабіць у любы час вы сапраўды сутыкаюцца з пераважнай Спіс памылак, як, што, будзе пракруціць назад, шукаць каманды вы проста пабег, што ў маім выпадку гэта зрабіць радок. Паглядзіце, што робяць зрабіў, і гэта што доўга Clang каманда, няма нічога асаблівага там. 

Але чырвоны дрэнна. Зялёны спрабуе быць пяшчотны і карысна. Але гэта ўсё ж такі дрэнна, у гэтым выпадку. Але дзе ж гэта дрэнна? 

String.c, лінія пяць, пяць знакаў. Так што гэта проста агульнае пагадненне. Нешта значыць нешта двукроп'е нумар радка і нумар знака. Памылка, выкарыстанне неабвешчаная Ідэнтыфікатар радка. Магчыма, вы мелі на ўвазе стандарт? 

Так што, на жаль, Clang спрабуе быць карысным. Але гэта не так, і ў гэтым выпадку. Няма, Clang, я не меў на ўвазе стандартны ўвод-выснова. Я меў на ўвазе, што на першай лініі, так. 

Але лінія пяць гэта адзін тут. І Clang ня разумець, S-T-R-I-N-G. Гэта неаб'яўленай ідэнтыфікатар, A Слова гэта проста ніколі не бачыў раней. І гэта таму, што C, мова мы пішам код прама зараз, няма зменных, званых радкамі. 

Гэта не адбудзецца, па змаўчанні, падтрымка тое, што называецца радок. Гэта CS50 кавалак жаргон, але вельмі ўмоўны. Але я магу выправіць гэта наступным чынам. 

Калі дадаць адзін радок кода у верхняй частцы гэтай праграмы, ўключаюць CS50.h, які з'яўляецца іншы файл недзе ўнутры CS50 IDE, дзе-то на цвёрдым дыску, так бы мовіць, аперацыйнай сістэмы Ubuntu што я бягу, што гэта файл, які збіраецца вучыць аперацыйнай Сістэма якая радок, проста як стандартны io.h з'яўляецца файл у аперацыйнай сістэме, што гэта буду вучыць яго, што Printf ёсць. 

Сапраўды, мы атрымалі б вельмі падобнае паведамленне калі IO прызнаў стандарт Io.h і спрабаваў выкарыстаць Printf. Так што я збіраюся ісці наперад і проста ўзяць пад свой кантроль L, каб ачысціць экран. Ці вы можаце ўвесці ясна, і ён будзе проста ачысціць акно тэрмінала. Але вы ўсё яшчэ можаце пракручваць назад у часе. 

І я буду перазапускаць Зрабіць String. Крыж мае пальцы на гэты раз, Enter. Божа мой, гэта спрацавала. ён паказвае мне доўгую маскіровачную каманду гэта значыць тое, што робіць генеравацца з дапамогай Clang, але ніякіх паведамленняў пра памылкі. Так разумеюць, нягледзячы на ​​тое, вы можаце атрымаць цалкам заваленыя колькасць паведамленняў пра памылкі, ён проста можа быць гэта раздражняе каскадных эфект, дзе Clang не разумее адна рэч, якая азначае, што ён тады не разумее наступнае слова, або наступная радок. А так ён проста задыхаецца ад вашага кода. Але выпраўленне можа быць простым. І так заўсёды сканцэнтраваны на Самая першая радок высновы. І калі вы гэтага не зробіце зразумець гэта, проста паглядзіце для ключавых слоў, якія маглі б быць ключы і нумар радка, і характар, дзе гэтая памылка можа быць. 

Цяпер дазвольце мне ісці наперад і ўвесці кропка слэш, радок, увядзіце. Хм, гэта не павітаўшыся нічога. Чаму? Ну, памятаеце, дзе ён працуе? 

Гэта, верагодна, затрымаўся ў дадзены момант у цыкле, калі вы будзеце, на шостым радку, таму Атрымаць радок дызайн, напісаныя супрацоўнікамі CS50, літаральна азначала проста сядзець там чакае, і чакае, і чаканне радка. Усё, што мы маем на ўвазе пад радком уводу з'яўляецца чалавек. Такім чынам, вы ведаеце, што? Дазвольце мне ісці наперад. І толькі па натхненні, дазвольце мне увядзіце сваё імя, Дэвід, увядзіце. Цяпер у мяне ёсць больш дынамічнай праграмы. Ён сказаў, прывітанне Дэвід. 

Калі я іду наперад і запусціць гэта зноў, дазвольце мне паспрабаваць сказаць імя Zamila, увядзіце. І зараз у нас ёсць дынамічная праграма. Я не жорстка закадаваныя свет. Я не жорстка закадаваныя імя, або Дэвід або Zamila. 

Зараз гэта значна больш падобна праграм мы ведаем, дзе, калі прымаць ўваходны сігнал, ён вырабляе некалькі іншай выснову. Цяпер, гэта не самы лепшы вопыт карыстальніка або UX. Я запусціць праграму. 

Я не ведаю, што я павінен рабіць, калі я на самой справе не глядзець на або запомніць зыходны код. Так давайце карыстачу вопыт трохі лепш з найпростых рэчаў. Дазвольце мне вярнуцца ў гэты праграмы, а проста сказаць Printf. 

І дазвольце мне ісці наперад і сказаць імя, двукроп'е, і прастора, а затым кропка з коскі. І як раз для пінкоў, не люфт н. І гэта наўмыснае, таму што я не хачу запрашэнне, каб перайсці да наступнай радку. 

Я хачу, замест таго, зрабіць гэта, зрабіць радок перакампіляваць свой код у новую машыну Код кропка слэш радок. Ах, гэта значна сімпотней. Цяпер я на самой справе ведаю, што кампутар хоча, каб я, даць яму імя. 

Так што я збіраюся ісці наперад і ўвесці у робе, увайсці, і прывітанне, Роб. Такім чынам, разумеюць, што гэта да гэтага часу, у канцы дня, толькі праграма дзевяць ліній. Але мы зрабілі гэтыя крокі дзіцяці. 

Мы напісалі адзін радок, з якой мы былі знаёмыя, Printf, прывітанне свет. Тады мы расшпіліла трохі гэтага. І мы на самай справе выкарыстоўвалі атрымання радка. І мы кінулі гэта значэнне ў зменнай. А потым мы пайшлі наперад і ўдасканальвацца Акрамя таго, ён з трэцяй лініяй. І гэты паўтаральны працэс напісанне праграмнага забеспячэння з'яўляецца сапраўды ключом. У CS50, так і ў жыцці ў цэлым, Вы павінны, як правіла, не сесці, маюць на ўвазе праграму, і паспрабуйце пісаць ўся бадзяга ўсё адразу. 

Гэта непазбежна будзе прыводзіць да шляху больш памылак, чым мы самі бачылі тут. Нават я, і па гэты дзень, пастаянна рабіць іншыя дурныя памылкі, на самай справе складаней памылкі што цяжэй высветліць. Але вы будзеце рабіць больш памылак, тым больш радкоў кода вы пішаце ўсё адразу. І таму гэтая практыка, напісаць трохі кода што вы камфортна, кампіляваць гэта, запусціць яго, пратэставаць яго ў больш агульным плане, затым перамесціце on-- гэтак жа, як мы трымалі адводкамі і адводкамі на мінулым тыдні, будаўніцтва ад чаго-то вельмі проста нешта больш складанае, зрабіць тое ж самае тут. Не садзіцеся, і паспрабаваць напісаць цэлую праблему. На самай справе гэтыя крокі дзіцяці. 

Цяпер, радкі не ўсе што карысна ім самім. Мы б на самой справе, у ідэале, як і ў ёсць сёе-тое яшчэ ў нашым інструментары. Так што давайце на самай справе зрабіць менавіта гэта. 

Дазвольце мне ісці наперад цяпер і нагнятаць крыху іншая праграма. І мы будзем называць гэты int.c, для цэлага ліку. Я збіраюся, гэтак жа, ўключаюць CS550.h. Я збіраюся ўключаць стандартныя IO. І гэта будзе даволі распаўсюджаным у гэтыя першыя некалькі дзён класа. 

І я буду гатовы сам з асноўнай функцыяй. І цяпер замест таго, каб атрымаць радок, давайце ісці наперад і атрымаць Int. Давайце назавем гэта я і называю гэта атрымаць INT, блізкія круглыя ​​дужкі, кропка з коскі. А цяпер давайце зробім што-то з ім, Printf. 

Скажам, нешта накшталт прывітанне, зваротная касая п, коска я. Так што я ў значнай ступені імітуючы што я зрабіў толькі хвіліну таму. У мяне ёсць запаўняльнік тут. Я коска я тут, таму што я хачу для падлучэння I ў гэты запаўняльнік. 

Так што давайце ісці наперад і паспрабаваць кампіляцыі гэтай праграмы. Файл называецца int.c. Так што я збіраюся сказаць, зрабіць Int, увядзіце. Божа мой, але не вялікая справа, ці не так? Там памылка. 

Там у сінтаксічнай памылцы вось такая, што праграма не можа складацца ўнутры int.c, лініі сем, сімвал 27, фармат памылка вызначае тып паўкокс зорка, што б гэта ні. Але тып аргументу Int. 

Так што тут таксама, мы не збіраемся, мэтай якіх нават калі сёння шмат матэрыялу, мы будзем душыць вас з абсалютна кожны прыкмета C, і праграмаванне ў больш агульным сэнсе, усяго за гэтыя першыя некалькі тыдняў. Так што часта будзе жаргон з якімі вы не знаёмыя. І на самай справе, сімвал зоркі нешта мы збіраемся вярнуцца да на працягу тыдня ці часу да двух. 

Але цяпер, давайце паглядзім, калі мы можам разабраць словы, якія знаёмыя. Formats-- так што мы чулі фармат спецификатор, код фармату раней. Гэта знаёма. Type-- але аргумент мае тып Int. Пачакайце, я гэта Int. 

Можа быць, на самой справе адсоткаў s мае некаторы пэўны сэнс. І сапраўды, гэта робіць. Цэлы лік, калі вы хочаце PRINTF, каб замяніць яго, вы на самой справе трэба выкарыстоўваць іншы фармат спецификатор. І вы не ведалі б гэта калі нехта сказаў вам, ці вы зрабілі гэта раней. Але адсоткаў я ёсць што можа быць шырока выкарыстоўваецца у Printf для падлучэння цэлага. Вы можаце таксама выкарыстоўваць працэнт d для дзесятковага цэлага ліку. Але я проста і прыгожа тут. Такім чынам, мы будзем ісці з гэтым. 

Цяпер дазвольце мне ісці наперад і перакладка марка INT, Enter. Гэта не добра, ніякіх памылак. Дот слэш int-- OK, дрэнны карыстацкі вопыт, таму што я не сказаў сабе што рабіць. Але гэта нармальна. Я хутка заваёўваюць. 

А цяпер дазвольце мне ісці наперад і ўвесці Давіда, OK, Zamila, Роб. ОК, так што гэта добрая рэч. На гэты раз, я выкарыстоўваю функцыю, галаваломка кавалак, які называецца Get Int. І атрымліваецца out-- і мы см гэта пазней у term-- персанал CS50 ажыццявіў атрымаць радок такім чынам, што яна будзе толькі фізічна атрымаць радок для вас. 

Ён рэалізаваны ў Int Атрымаць такім чынам, што гэта будзе толькі атрымаць цэлы лік для вас. І калі вы, чалавек, не супрацоўнічаюць, гэта літаральна толькі збіраецца сказаць, паўторыце, паўторыце, паўторыце, літаральна сядзеў там зацыкленне, пакуль вы абавязваюць з нейкім магічным лікам, як 50, і прывітанне 50. 

Ці, калі мы выканаем гэта зноў і тып у 42, 42 прывітанне. І таму функцыя Get INT ўнутры гэтага кавалак галаваломкі дастаткова логікі, дастаткова думка, каб высветліць, што такое слова? А што такое лік? Толькі прыняцце, у канчатковым рахунку, лічбы. 

Так атрымліваецца, што гэта не ўсе, што выразна. дагэтуль. Так, яй, апошні раз, калі мы пайшоў даволі хутка у выканаўцаў гульняў і анімацыі, і мастацкія творы, у пустым месцы. І вось, мы задавальняючыся з прывітанне свет, і прывітанне 50. 

Гэта не ўсё, што натхняе. І сапраўды, гэтыя першыя некалькі прыклады зойме некаторы час спаўзаць у хваляванні. Але ў нас ёсць так шмат больш кантраляваць зараз, на самай справе. І мы будзем вельмі хутка пачаць адводкамі на верхняй часткі гэтых асноўных прымітываў. 

Але па-першае, давайце разбярэмся якія абмежаванні. На самай справе, адна з рэчаў, Драпіны ня лёгка давайце зробім гэта рэальна глядзець пад капотам, і зразумець, што кампутар, што ён можа зрабіць, і якія яго абмежаванні. І сапраўды, што адсутнасць разуменне, патэнцыйна, доўгатэрміновае можа прывесці да нашай уласнай mistakes-- пісьмовай форме памылак, напісанне небяспечнага праграмнага забеспячэння, атрымлівае узламалі ў некаторым родзе. 

Такім чынам, давайце некаторыя крокі ў кірунку разумеючы гэта крыху лепш спосаб, скажам, наступны прыклад. Я збіраюся ісці наперад і рэалізаваць рэальны хуткі праграма пад назвай Adder. Маўляў, давайце дадамо некаторыя лічбы разам. І я збіраюся кадзіраваць некаторыя куты тут, і проста скапіяваць і ўставіць дзе я быў раней, проста так што мы можам пачаць працаваць раней. Так што цяпер у мяне ёсць асноўныя пачатку праграмы пад назвай Adder. 

І давайце ісці наперад і рабіць гэта. Я збіраюся ісці наперад і скажам, IntX атрымлівае атрымаць Int. І вы ведаеце, што? Давайце зробім лепшы карыстацкі досвед. 

Так што давайце проста скажам х, і эфектыўна падказаць карыстачу, каб даць нам х. А потым дайце мне ісці наперад і сказаць, Printf як наконт ля ёсць, на гэты раз чакаючы два значэнні ад карыстальніка. А потым давайце проста ісці наперад і скажам, Printf, сума х і у. А цяпер я не хачу рабіць адсоткаў с. Я хачу зрабіць працэнт I, патрэбна ўжыць зваротны слэш п, а затым падлучыць значэнне сумы. 

Так як я магу ісці пра гэта? Вы ведаеце, што? Я ведаю, як выкарыстоўваць зменныя. Дазвольце мне проста аб'явіць новы, Int г. 

І я збіраюся зрабіць здагадку тут. Калі маюцца роўныя знакі ў гэтым мову, можа быць, я проста не магу зрабіць х плюс у, да таго часу, як я скончу сваю думаў з коскай? Цяпер я магу вярнуцца сюды, падключыць г, скончыць гэтую думку з коскі. І давайце паглядзім цяпер, калі яны паслядоўнасці lines-- х, гэта атрымаць Int. Y гэта атрымаць Int. 

Дадаць х і у, захоўваюць значэнне ў z-- так, зноў жа, памятаеце, знак роўнасці не роўная. Гэта прызначэнне справа налева. І давайце друкаваць, што сума х і у не літаральна г, але што ўнутры г. Дык давайце зробім Adder - не прыгожа, ніякіх памылак у гэты раз. Дот слэш Adder, увядзіце, х будзе 1. 

Y будзе 2. А сума х і ў роўная 3. Так што гэта ўсё выдатна і добра. 

Такім чынам, вы б сабе ўявіць, што матэматыку павінны працаваць у праграме, як гэта. Але вы ведаеце, што? Ці з'яўляецца гэтая пераменная, радок 12, нават неабходна? Вам не трэба, каб увайсці ў звычку проста захоўвання рэчаў у зменных толькі таму, што вы можаце. І на самай справе, гэта як правіла, лічыцца дрэнны дызайн калі вы ствараеце зменную, называецца Z ў гэтым выпадку, захоўванне нешта ў ім, а затым адразу ж выкарыстоўваючы яго, але ніколі. Навошта даваць што-то імя як г, калі вы ў літаральным сэнсе збіраецца выкарыстоўваць гэта прадмет толькі адзін раз, і так праксімальней дзе вы стварылі гэта, у першую чаргу, так блізка з пункту гледжання радкоў кода? Такім чынам, вы ведаеце, што? Аказваецца, што C з'яўляецца даволі гнуткім. Калі я на самой справе хачу убудова значэнняў тут, Мне не трэба, каб абвясціць новую зменную. Я мог бы проста убудова х плюс у, таму што разумее, C арыфметычныя і матэматычныя аператары. 

Так што я магу проста сказаць, гэта зрабіць матэматыку, х плюс у, якімі б гэтыя значэння, падключыце выніковы цэлы лік у гэтым радку. Такім чынам, гэта магло б быць, калі б толькі адзін радок карацей, лепшы дызайн, лепшая праграма, таму што там менш кода, таму менш для мяне зразумець. І гэта таксама проста чысцей, пастолькі, паколькі мы не уводзячы новыя словы, новыя сімвалы, як і г, нават калі яны на самой справе не служыць шмат мэты. 

На жаль, матэматыка не з'яўляецца усё, што надзейныя часам. Давайце ісці наперад і рабіць гэта. Я збіраюся ісці наперад зараз і зрабіце наступнае. 

Давайце зробім Printf, працэнт I, плюс працэнт я, павінна быць адсоткаў я, зваротная касая п. І я збіраюся зрабіць this-- Хух плюс у. Так што я проста хачу перапісаць гэта крыху па-іншаму тут. Дазвольце мне зрабіць хуткую праверку наяўнасці свядомасці. Зноў жа, давайце не будзем забягаць наперад. Зрабіць суматар, кропка слэш гадзюка. х роўны 1, у 2, 1 плюс 2 роўна 3. Так што гэта добра. Але давайце ўскладніць гэта цяпер трохі, і стварыць новы файл. 

Я буду называць гэты, кажуць, Інтс, множны лік для цэлых лікаў. Дазвольце мне пачаць, дзе я быў хвіліну таму. Але цяпер давайце зробім некалькі іншых ліній. Дазвольце мне ісці наперад і рабіць наступнае, Printf, працэнт я, мінус працэнт я, гэта адсотак я, коска х, коска ух мінус у. Так што я крыху раблю іншая матэматыка там. Давайце зробім яшчэ адзін. Такім чынам, працэнт I разы адсоткаў я гэта адсотак я, зваротная касая п. Давайце убудова х і у, і х раз у. Мы будзем выкарыстоўваць зорачку ваш кампутар на працягу часу. 

Вам не трэба выкарыстоўваць х. х імя зменнай тут. Вы можаце выкарыстоўваць зорку для множання. Давайце зробім яшчэ адзін. Printf адсотка I, падзяліць на працэнт I, з'яўляецца працэнт я, зваротная касая п. ху, дзялення на y-- так што вы карыстаецеся слэш ў C зрабіць падзел. І давайце зробім адзін аднаго. Remainder адсотка I, падзелены на працэнт I, з'яўляецца працэнт я. xy-- і цяпер засталося гэта тое, што засталося. Пры спробе дзялення назоўніка ў лічнік, колькі засталося над гэтым Вы не маглі б падзяліць па-за домам? 

Так што не вельмі, абавязкова, сімвал мы выкарыстоўвалі ў пачатковай школе для гэтага. Але ёсць у C. Вы можаце кажуць х па модулю у, дзе гэты знак працэнта ў гэтым context-- калі вы цьмяна знаходзіцеся ўнутры падвойных двукоссях, ўнутры ад Printf, адсоткаў выкарыстоўваецца ў якасці спецификатора фармату. 

Пры выкарыстанні працэнтаў за межамі што ў матэматычным выразе, гэта аператар па модулю для модульнага arithmetic-- для нашых мэтаў тут, проста азначае, што такое Астатняя частка х дзеліцца на у? Так х дзеліцца на ў ёсць х слэш у. Што астатняя частка дзеліцца на х у? Гэта х мод у, як праграміст мог бы сказаць. 

Так што, калі я не зрабіў ніводнай памылкі тут, дазвольце мне ісці наперад і зрабіць Інтс, множны лік, прыемна, і кропка слэш Інтс. І давайце ісці наперад і рабіць, скажам, 1, 10. Добра, 1 плюс 10 роўна 11, праверка. 1 мінус 10 адмоўны 9, праверце. 

1 раз у 10: 10, праверка. 1 дзеліцца на 10 is-- Добра, мы прапусцім што адзін. Рэшту 1 дзеліцца на 10 роўна 1. Гэта правільна. Але ёсць памылка тут. 

Такім чынам, той, які я кладу здаць, ня правільна. Я маю на ўвазе, што гэта блізка да 0. 1 дзеліцца на 10, вы ведаеце, калі мы рэзкі некаторыя куты, вядома, гэта нуль. Але гэта павінна быць сапраўды 1/10, 0,1 або 0,10, 0,1000, ці таму падобнае. 

Яна не павінна сапраўды быць роўная нулю. Што ж, атрымліваецца, што кампутар рабіць літаральна тое, што мы сказалі гэта зрабіць. Мы робім матэматыку як х, падзеленае на у. І абодва х і у, на лініі кода раней, з'яўляюцца цэлымі лікамі. 

Акрамя таго, па лініі 15, мы кажучы Printf, эй, Printf убудова цэлы лік, ўстаўны цэлы лік, убудова ў integer-- спецыяльна х, а затым у, а затым х дзеліцца на у. х і ў Інтс. Мы там добра. 

Але што х дзеліцца на х? х дзеліцца на к і павінна быць, матэматычна, 1/10, або 0,1, якая ўяўляе сабой сапраўдны лік, рэчыўны лік маючы, патэнцыйна, дзесятковую кропку. Гэта не з'яўляецца цэлым лікам. 

Але тое, што бліжэй за ўсё цэлы лік, 1/10, або 0,1? Так, гэта свайго роду роўная нулю. 0,1, як гэта шмат. І 1 гэта шмат. Такім чынам, 1/10 бліжэй да 0, чым да аднаго. 

І так, што C робіць для us-- выгляд, таму што мы сказалі гэта, мэтай якіх з'яўляецца ўсячэння, што цэлы лік. Ён прымае значэнне, што зноў-такі з'яўляецца павінна быць нешта накшталт 0,1000, 0 і гэтак далей. І гэта ўсё, што ўсячэнне пасля дзесятковай кропкі так што ўсё гэта матэрыял, таму што гэта не ўпісваецца ў паняцце цэлага ліку, што гэта проста лік, як адмоўны 1, 0, 1, уверх і ўніз, ён адкідвае ўсё пасля дзесятковай кропкі, таму што вы не можа адпавядаць дзесятковую кропку ў цэлы лік, па азначэнні. 

Такім чынам, адказ тут роўны нулю. Так як жа мы гэта выправіць? Нам трэба іншае рашэнне ўсё разам. І мы можам зрабіць гэта наступным чынам. 

Дазвольце мне ісці наперад і стварыць новы Файл, на гэты раз называецца floats.c. І захаваць яго тут, у той жа каталог, float.c. І дазвольце мне ісці наперад і скапіяваць частка гэтага кода з раней. 

Але замест таго, каб INT, давайце зробім гэта. Дайце мне значэнне з якая плавае коскі называецца х. дзе з якая плавае кропкай значэнне толькі ў літаральным сэнсе нешта з якая плавае кропкай. Ён можа перамяшчацца налева, направа. Гэта рэчыўны лік. 

І дазвольце мне не называць атрымаць Int, але атрымаць з якая плавае кропкай, які таксама быў адным з меню опцый у бібліятэцы C250. Давайце зменім у да паплаўка. Так што гэта будзе атрымаць з якая плавае кропкай. 

А цяпер, мы не хочам, каб падключыць Інтс. Аказваецца, мы павінны выкарыстоўваць адсоткаў е для паплаўка, працэнт F для паплаўка, і зараз захаваць яго. А цяпер, скрыжаваўшы пальцы, зрабіце паплаўкі, прыгожа, кропка слэш паплаўкі. х будзе адным 1. у Будзе 10 разоў. 

І, добра, добра мой дадатак з'яўляецца правільным. Я спадзяваўся на больш, але я забыўся напісаць. Так што давайце ісці і выправіць гэтую лагічную памылку. 

Давайце ісці наперад і захапіць наступнае. Мы проста робім трохі капіявання і ўстаўкі. І я хачу сказаць, мінус. 

І я хачу сказаць, раз. І я хачу сказаць, падзяліліся. І я не буду рабіць па модулю, якая не з'яўляецца, як рэлевантны тут, дзеліцца на F, і раз plus-- Добра, давайце зробім гэта зноў. 

Зрабіць паплаўкі, кропка слэш паплаўкі, і 1, 10, и-- добра, няма, ОК. Так што я ідыёт. Так што гэта вельмі распаўсюджаная ў інфарматыцы каб зрабіць дурныя памылкі, як гэта. 

Для педагагічных мэт, што я сапраўды хацеў зрабіць быў змяніць навуку тут на плюс, у мінус, да часоў, і падзяліць, як вы, спадзяюся, заўважылі падчас гэтага практыкаванні. Такім чынам, цяпер давайце зноўку скампіляваць Праграма, рабіць кропкавыя слэш паплаўкі. 

І ў трэці раз, давайце убачыць, калі яна адказвае маім чаканням. 1, 10, увядзіце, так, добра, 1.000, падзелены на 10000, гэта 0,100000. І атрымліваецца, што мы можам кантраляваць, колькі лічбы пасля гэтых знакаў пасля коскі. Мы на самай справе будзе. Мы вернемся да гэтага. 

Але цяпер, па сутнасці, матэматыка з'яўляецца правільным. Так што, зноў жа, што вынас тут? Аказваецца, што ў C, ёсць не толькі strings-- і, на самай справе, ёсць не вельмі, таму што мы дадаць тыя, з бібліятэкай CS50. Але ёсць не толькі Інтс. 

Ёсць таксама плавае. І атрымліваецца, кучу іншых дадзеных тыпу таксама, што мы будзем выкарыстоўваць у хуткім часе. Аказваецца, калі вы хочаце адзін характар, а не радок знакаў, вы можаце выкарыстоўваць толькі сімвал. 

Аказваецца, што калі вы хочаце, лагічнае значэнне, лагічнае значэнне, ісціна або хлусня толькі, дзякуючы бібліятэцы CS50, мы дадаецца да C тыпу дадзеных BOOL, а таксама. Але гэта таксама прысутнічае ў многіх іншых мовах, а таксама. І атрымліваецца, што часам вам патрэбныя вялікія лічбы, а затым прыходзяць па змаўчанні з Інтс і паплаўкамі. 

І, па сутнасці, двайны шэраг які выкарыстоўвае не 32 біта, але 64 біта. І доўга доўга гэты лік, выкарыстоўвае не 32, біты, але 64 біта, адпаведна, аперацый з якая плавае кропкай значэння і цэлыя лікі, адпаведна. Так што давайце на самай справе ў цяперашні час ўбачыць гэта ў дзеянні. 

Я збіраюся ісці наперад тут і нагнятаць адну іншую праграму. Тут я збіраюся ісці наперад і не ўключаюць CS50.h. І дазвольце мне ісці, ўключаюць у сябе стандартныя IO.h. 

І вы заўважыце нешта фанкі тут адбываецца. Гэта не каляровае кадаваньне рэчы сапраўды гэтак жа, як гэта было раней. І аказваецца, што гэта таму, што я не далі рэч імя файла. 

Я буду называць гэты sizeof.c, і націсніце кнопку Захаваць. І да вашага ведама, што адбываецца з маёй вельмі белы код супраць гэтага чорны фон. Цяпер, па меншай меры ёсць некаторыя фіялетавыя там. І гэта сінтаксіс выдзелены. 

Гэта таму, што даволі проста, у мяне ёсць распавёў, які тып файла IDE гэта, даючы яму імя, і у прыватнасці, пашырэнне файла. Цяпер, давайце ісці наперад і рабіць гэта. Я збіраюся ісці наперад і вельмі проста раздрукаваць following-- Ьоо гэта адсотак LU. 

Мы вернемся да што ў імгненне. А потым я збіраюся памер друку BOOL. І цяпер, каб зэканоміць я нейкі час, я збіраецца зрабіць цэлае букет з іх адразу. І, у прыватнасці, я збіраюся змяніць гэта да гольца і голец. Гэта адно, я збіраюся змяніць да двайны і двайны. 

Гэта адно, я збіраюся змяніць да паплаўка і паплаўком. Гэта адно, я збіраюся зменіцца на Int і Int. А гэта, я збіраюся каб змяніць доўга доўга. І ён па-ранейшаму прымае доўга, доўга доўга. 

І тады, нарэшце, я даў я занадта шмат, радок. Аказваецца, што ў C, ёсць спецыяльны аператар называецца памер, што літаральна збіраецца, пры запуску, скажыце нам памер кожная з гэтых зменных. І гэта шлях, у цяперашні час, мы можам злучыцца назад для абмеркавання на мінулым тыдні дадзеных і прадстаўлення. 

Дазвольце мне ісці наперад і кампіляваць памер кропкавага памеру Слэш. І давайце паглядзім. Аказваецца, што ў C, у прыватнасці, на CS50 IDE, у прыватнасці, на Аперацыйная сістэма Ubuntu, які з'яўляецца 64-разраднай аперацыйнай Сістэма ў гэтым выпадку, лагічнае значэнне будзе выкарыстоўваць адзін байт прасторы. Вось як вымяраецца памер, не ў бітах, а ў байтах. І памятайце, што адзін байт восем біт. Так BOOL, нават калі вы тэхнічна трэба толькі 0 або 1, гэта крыху марнатраўна як мы рэалізавалі. Гэта на самай справе збіраецца выкарыстоўваць увесь byte-- так усё нулі, з'яўляюцца, магчыма, усе тыя, ці нешта падобнае, або толькі адзін 1 з васьмі бітаў. 

Паўкокс, тым часам, выкарыстоўваецца для сімвала як сімвал Ascii за апошні тыдзень, будзе адзін знак. І гэта сінхранізуецца з нашым паняццем не будучы не больш за 256 bits-- а, сінхранізуецца з ім быць не даўжэй, чым 8 біт, што дае нам цэлых 256 значэнняў. двайны збіраецца складае 8 байт або 64 біта. 

Паплавок 4. ИНТ 4. Доўгі, доўгі 8. І радок 8. Але не турбуйцеся пра гэта. Мы збіраемся адхіліце гэты пласт. Аказваецца, радкі могуць быць даўжэй 8 байт. 

І сапраўды, мы напісалі радкі ўжо, прывітанне свет, больш, чым 8 байт. Але мы вернемся да што ў імгненне. Але забярыце тут заключаецца ў наступным. 

Любы кампутар мае толькі канчатковае аб'ём памяці і прасторы. Вы можаце толькі захоўваць так шмат файлы на вашым Mac ці PC. Вы можаце толькі захоўваць так шмат праграм RAM працуе адразу, абавязкова, нават з віртуальнай памяццю, таму што ў вас ёсць абмежаваную колькасць аператыўнай памяці. 

І толькі калі picture-- вы ніколі не адкрылі ноўтбук ці замовіць дадатковую памяць для кампутара, вы можа не ведаць, што ўнутры вашага кампутара гэта тое, што выглядае трохі як гэта. Так што гэта проста звычайная кампанія пад назвай Вырашальнае значэнне, што робіць аператыўнай памяці для кампутараў. І аператыўная памяць, дзе праграмы жыць у той час як яны працуюць. 

Так што на кожным Mac ці PC, пры падвойным выберыце праграму, і яна адкрывае, і гэта адкрывае нейкі дакумент Word, ці нешта падобнае, ён захоўвае яе на некаторы час у RAM, паколькі аператыўная памяць хутчэй чым ваш жорсткі дыск, або ваш цвёрдацельны назапашвальнік. Так што гэта проста, дзе праграмы ідуць жыць, калі яны працуюць, ці калі выкарыстоўваюцца файлы. 

Так што ў вас ёсць рэчы, якія выглядаюць як гэта ўнутры вашага ноўтбука, або трохі больш рэчаў ўнутры вашага працоўнага стала. Але ключ у вас ёсць толькі канчатковае лік гэтых рэчаў. І ёсць толькі канчатковае колькасць апаратнае забеспячэнне, седзячы на ​​гэтым стале правай тут. 

Так што, вядома ж, мы не можам захоўваць бясконца доўгіх лікаў. І, тым не менш, калі вы думаеце, назад пачатковай школы, колькі лічбаў можа вы павінны правы з дзесятковай кропкі? У гэтых адносінах, колькі лічбаў можа ў вас ёсць злева ад дзесятковай кропкі? Сапраўды, бясконца шмат. 

Цяпер мы, людзі маглі б толькі ведаеце, як вымаўляецца мільён, і мільярд, трыльён, і квадрыльёнаў і квінцільёнаў. І я рассоўваюць мяжы майго understanding-- або my-- Я разумею, лічбы, але мой вымаўленне лікаў. Але яны могуць атрымаць бясконца вялікі з бясконца шмат лічбаў злева ці справа ад дзесятковай кропкі. 

Але кампутары ёсць толькі канчатковае колькасць памяці, канчатковае лік транзістараў, A канчатковае лік лямпачак ўнутры. Так што ж адбываецца, калі вы бяжыце з космасу? Іншымі словамі, калі вы думаю, што вярнуцца да мінулым тыдні калі мы казалі пра лічбы Самі прадстаўлены ў двайковым выглядзе, Выкажам здагадку, што ў нас ёсць гэта 8-бітнае значэнне тут. 

І ў нас ёсць сем 1 і адзін 0. І выкажам здагадку, што мы хочам дадаць 1 да гэтага значэння. Гэта сапраўды вялікі лік прама цяпер. 

Гэта 254, калі я памятаю матэматыка з мінулага тыдня справа. Але што, калі я змяніць што крайні справа ад 0 да 1? Цэлы лік, з Вядома, будзе восем 1-х. Такім чынам, мы па-ранейшаму добра. 

І гэта, верагодна, уяўляе 255, хоць у залежнасці ад кантэксту ён можа на самай справе ўяўляюць адмоўны лік. Але пра гэта ў іншы раз. Гэта пачуццё, што гаворка ідзе пра гэтак жа высока, як я магу разлічваць. 

Цяпер, гэта толькі 8 біт. І мой Mac, вядома ж, ёсць шлях больш за 8 біт памяці. Але ў яго ёсць канчатковае. Такім чынам, той жа аргумент выкарыстоўваецца і ў дачыненні, нават калі мы маюць больш з гэтых адзінак на экране. 

Але што адбудзецца, калі вы захоўвання гэтага ліку, 255, і вы жадаеце лічыць 1 трохі вышэй? Вы хочаце перайсці ад 255 да 256. Праблема, вядома, у тым, што калі вы пачаць адлік з нуля, як на мінулым тыдні, вы не можаце разлічваць, як высокі у 256, не кажучы ўжо пра 257, не кажучы ўжо пра 258, м, таму што адбываецца, калі вы дадаеце 1? Калі вы робіце старую пачатковую школу падыход, вы паклалі 1 тут, а затым 1 плюс 1 роўна 2, але гэта на самай справе нуль, вы носіце 1, несці 1, несці 1. Усе гэтыя рэчы, гэтыя 1, перайдзіце да нуля. І вецер, ды, як нехта паказаў, што ў 1 на левай баку. Але ўсё, што вы можаце на самай справе ўбачыць і змяшчаецца ў памяці знаходзіцца ўсяго ў васьмі 0, які павінен сказаць, у нейкі момант, калі вы, кампутар, судзімы падліку досыць высока, вы збіраецца абгарнуць вакол, здавалася б, да нуля, або, можа быць нават адмоўным лічбы, якія нават ніжэй за нуль. 

І мы можам роду убачыць гэта. Дазвольце мне ісці наперад і напісаць рэальная хуткая праграма тут. Дазвольце мне ісці наперад і напісаць праграма пад назвай пераліву. Уключыце CS50.h, уключыце стандарт IO.h-- о, Я сапраўды прапусціў мой падсвятленне сінтаксісу. Так давайце захаваем гэта як overflow.c. 

А зараз галоўны INT void-- і да таго часу, мы будзем вярнуцца да тлумачэння, чаму мы працягваем пісаць Int асноўную пустэчу. Але цяпер, давайце проста рабіць яна, прымаючы яго як само сабой разумеецца. Давайце даць сабе Int, і ініцыялізаваць яго да 0. 

Давайце тады зрабіць для Int я атрымліваю zero-- на самай справе, давайце рабіць бясконцы цыкл і паглядзець, што адбываецца. У той час як дакладна, то давайце раздрукаваць п гэта адсотак я, зваротная касая рыса п, убудова п. Але цяпер, давайце п атрымлівае п плюс 1. 

Такім чынам, іншымі словамі, на кожны ітэрацыя гэтага бясконцага цыклу, давайце разгледзім значэння п, у і дадаць да яго 1, а затым захаваць вынік у п на левай баку. І на самай справе, мы ўжо бачылі сінтаксіс трохі, як гэта, на кароткі час. Прахалодны трук замест гэтага пісаць усё гэта, вы можаце сказаць, п плюс роўны 1. 

Ці, калі вы сапраўды хочаце быць фантазіі, Вы можаце сказаць, п плюс плюс кропка з коскі. Але гэтыя апошнія два проста тое, што мы назвалі б сінтаксічны цукар для першай рэчы. 

Першае, што з'яўляецца больш відавочным, цалкам нармальна, зусім правільна. Але гэта часцей, я скажу. Такім чынам, мы будзем рабіць гэта на імгненне. 

Давайце зараз зрабіць перапаўненне, якая гучыць даволі злавесна, кропка перапаўнення касой рысы. Давайце паглядзім, п становіцца даволі вялікі. Але давайце падумаем, наколькі вялікая можа атрымаць п? 

п з'яўляецца Int. Мы бачылі хвіліну назад з памерам прыклад, што INT чатыры байта. Мы ведаем, што з мінулага тыдня, чатыры байта з'яўляецца 32 біта, таму што ў 8 разоў 4, гэта 32. Гэта будзе 4 млрд. 

І мы да 800,000. Гэта будзе доўжыцца вечна разлічваць так высока, як я, магчыма, можа. Так што я збіраюся ісці наперад, як вы маглі б у хуткім часе, і ўдарыў кіравання c-- адкрыта, кантроль C, шмат, дзе кіраванне C у цэлым сродак адмены. На жаль, так як гэты працуе ў воблаку, часам воблака выплёўваючы так шмат рэчаў, так шмат вываду, ён збіраецца заняць некаторы час для майго ўводу каб дабрацца да воблака. Так што, хоць я ўдарыў Кантроль C некалькі секунд таму, гэта, безумоўна, бок эфект бясконцага цыклу. 

І таму ў такіх выпадках, мы збіраецца пакінуць гэта быць. І мы збіраемся дадаць яшчэ акно тэрмінала тут з плюсам, які, вядома, не як гэта, так як ён усё яшчэ думае. І давайце ісці наперад і быць крыху больш за разумным. 

Я збіраюся ісці наперад і рабіць гэта толькі канчатковае лік раз. Давайце выкарыстоўваць цыкл, якія я згадваў раней. Давайце зробім гэта. Дайце мне іншую зменную Int я атрымлівае 0. я менш, чым, скажам, 64 я ++. А цяпер дазвольце мне ісці наперад і друк з п адсоткаў я, коска п. І тады гэта N-, да гэтага часу збіраецца ўзяць назаўжды. Давайце зробім гэта. 

п атрымлівае п раз 2. Ці мы маглі б быць фантазіі і рабіць раз роўная 2. Але давайце проста скажам, п роўна сама па сабе, раз 2. Іншымі словамі, у гэтым Новая версія праграмы, Я не хачу чакаць вечна ад 800 000, як да 4 мільярдаў. Давайце проста скончым з гэтым. 

Давайце на самай справе ў два разы п кожны раз. Які, нагадаем, з'яўляецца падваеннем насупраць таго, вядома. І ў той час як на мінулым тыдні ў нас ёсць нешта зноў і зноў, і зноў, супер хуткі, Падваенне, безумоўна, атрымаць нас ад 1 да самай вялікай магчыма значэнне, якое мы можам разлічваць, каб з міжнар. 

Так што давайце рабіць менавіта гэта. І мы вернемся да гэтага ў хуткім часе. Але гэта, зноў жа, як і паўтор блока ў пустым месцы. І вы будзеце выкарыстоўваць гэта да тых часоў. 

Гэта проста азначае, што адлік ад нуля да, але не роўныя, да 64 гадоў. І на кожнай ітэрацыі гэтага цыкл, проста трымаць прырашчэннем я. Так што я ++ - і гэтая агульная канструкцыя у радку 7 гэта проста супер распаўсюджаны спосаб паўтараць некалькі радкоў код, некаторы колькасць разоў. Якія радкі кода? Гэтыя фігурныя дужкі, як вы магчыма, запазычаныя цяпер, азначае, зрабіце наступнае. 

Гэта ў такой драпіны, калі ён мае жоўтыя блокі і іншыя колеры, выгляд прыняць або абдымаюць іншыя блокі. Вось што гэтыя фігурныя брекеты робяць тут. Так што, калі я атрымаў свой сінтаксіс right-- вас можна ўбачыць сімвал моркву ў сродках C вось колькі разоў я быў спрабуючы вырашыць гэтую праблему. Так што давайце пазбавіцца ад гэтага аднаго ў цэлым, і зачыніць гэта акно. І мы будзем выкарыстоўваць новы. Зрабіць перапаўнення, кропка слэш Перапаўненне, Enter, усё ў парадку, гэта выглядае дрэнна на першы погляд. Але давайце пракручваць назад у часе, таму што я зрабіў гэта 64 разоў. 

І заўважце, у першы раз, п роўна 1. Другі раз, п = 2, затым 4, затым 8, затым 16. І мне здаецца, што як толькі Я атрымліваю прыкладна 1 млрд, калі я зноў падвоіць яе, што павінен даць мне 2 мільярды даляраў. Але аказваецца, гэта прама на парозе. 

І гэта на самай справе пераліваецца INT з 1 млрд груба адмоўнае 2 млрд, так як цэлы лік, у адрозненне ад лікаў мы прымаюць на сябе на мінулым тыдні, можа быць як станоўчым, так і адмоўным на самай справе, і ў кампутары. І так па меншай меры, адзін з тых, біты эфектыўна скрадзеныя. Такім чынам, мы сапраўды толькі 31 біт, або 2 мільярды магчымых значэнняў. 

Але на дадзены момант, ежа на дом цалкам проста, якія б ні былі гэтыя лічбы і незалежна ад таго матэматыка, нешта дрэннае здараецца ў рэшце рэшт, таму што ў рэшце рэшт, вы спрабуеце перастаўляюць біты занадта шмат разоў. І вы эфектыўна перайсці ад усіх 1-х, можа быць, усё 0, або, можа быць, проста нейкай іншай мадэлі, што яно Відавочна, што ў залежнасці ад кантэксту, можа быць вытлумачана як адмоўны лік. І вось, здавалася б, самы высокі I можа разлічваць у гэтай канкрэтнай праграме складае ўсяго каля 1 млрд. Але ёсць частковае рашэнне тут. Вы ведаеце, што? 

Дазвольце мне змяніць з Int на доўгі доўга. І дазвольце мне ісці наперад тут і say-- я буду мець каб змяніць гэта без знака доўга. Або, давайце паглядзім, я ніколі не памятаю сябе. 

Давайце ісці наперад і зрабіць перапаўненне. Не, гэта не так, дне, дзякуй. Так што часам Clang можа быць карысным. Я не памятаю, які фармат Спецификатор быў доўга доўга. 

Але, на самой справе, Clang сказаў мне. Зялёны з'яўляецца свайго роду добра, па-ранейшаму азначае, што вы зрабілі памылку. Гэта здагадваючыся, што я меў на ўвазе LLD. 

Такім чынам, дазвольце мне ўзяць гэта савет, доўгі доўгі дзесятковы лік, акрамя таго, што. І дазвольце мне зноў запусціць яго, кропка слэш перапаўненне, Enter. А цяпер, што гэта крута гэта. 

Калі я пракручваю назад у часе, мы да гэтага часу пачаць лічачы ў той жа place-- 1, 2, 4, 8, 16. Звярніце ўвагу, мы атрымліваем усё аж да 1 млрд. Але тады мы паспяхова дабрацца да 2 млрд. 

Тады мы атрымаем 4 млрд, затым за 8 млрд, 17 млрд. І мы ідзем вышэй, і вышэй, і вышэй. У рэшце рэшт, гэта таксама ламаецца. 

У рэшце рэшт, з тых часоў доўга, які з'яўляецца 64-бітнае значэнне, а не 32-бітнае значэнне, калі лічыць занадта высока, вы абгарнуць 0. І ў гэтым выпадку, мы апынуліся у канчатковым выніку з адмоўным лікам. 

Так што гэта праблема. І атрымліваецца, што гэта Праблема ў тым, што не ўсе аркан. Нават калі я наўмысна падштурхнула яго з гэтымі памылкамі, атрымліваецца, мы бачым, што гэта накшталт усё вакол нас, ці, па меншай меры, некаторыя з нас. 

Так што ў Lego Star Wars, калі вы калі-небудзь гулялі ў гэтую гульню, атрымліваецца, вы можаце хадзіць ламаць рэчы ў LEGO свеце, і збіраць манеты, па сутнасці. І калі вы калі-небудзь гулялі гэтая гульня занадта шмат часу, як гэта безназоўнага чалавека тут жа, агульная колькасць манет, якія вы можаце атрымаць гэта, здавалася б, 4 млрд. 

Цяпер, калі ён на самай справе закруглены. Так што LEGO спрабаваў трымаць рэчы дружалюбным да карыстача. Яны не рабілі гэта дакладна ад 2 да 32 магутнасці, за апошні тыдзень. Але 4 млрд прычына. Здаецца, грунтуючыся на гэтай інфармацыі, што LEGO, і кампанія, якая зрабіў гэта фактычнае праграмнае забеспячэнне, вырашыў што максімальная колькасць манет элемент можа назапашвацца гэта, па сутнасці, 4 мільярды, таму што яны выбралі ў сваім кодзе выкарыстаць не доўга доўга, па-відаць, але толькі цэлы лік, без знака цэлы лік, толькі станоўчае цэлы лік, чые максімальнае значэнне складае прыкладна гэта. Ну, вось яшчэ забаўны. Так што ў гульні Цывілізацыя, якая некаторыя з вас могуць быць знаёмыя з высвятляецца, што некалькі гадоў таму там была памылка ў гэтай гульні у выніку чаго калі вы гулялі ролю Гандзі ў гульні, замест яго быў вельмі пацыфістам, замест таго, каб было неверагодна, неверагодна агрэсіўны, у некаторых абставінах. У прыватнасці, так, што цывілізацыя працы з'яўляецца тое, што калі вы, гулец, прыняць дэмакратыю, ваш Агрэсіўнасць адзнака атрымлівае декрементируется на два, таму мінус мінус, а затым мінус мінус. 

Такім чынам, вы адняць 2 з фактычная ітэрацыя. На жаль, калі ваш ітэрацыя з'яўляецца першапачаткова 1, і адняць з яго 2 пасля прыняцця дэмакратыі Гандзі, як тут можа зрабіў, таму што ён быў вельмі passive-- 1 па шкале агрэсіўнасці. Але калі ён прымае дэмакратыю, то ён ідзе ад 1 да адмоўнага 1. 

На жаль, яны былі з дапамогай лікаў без знака, што азначае, што яны апрацоўваюць нават адмоўным колькасці, як калі б яны былі станоўчымі. І атрымліваецца, што станоўчы эквівалент адмоўнага 1, ў тыповых кампутарных праграм, складае 255. Так што калі Гандзі прымае , І, такім чынам, дэмакратыя яго ацэнка агрэсіўнасці паменшылася, ён на самай справе катаецца да 255 і робіць яго самым агрэсіўны характар ​​у гульні. Такім чынам, вы Google можа на гэтым. І гэта было, пэўна, выпадковае праграмаванне памылка, але гэта зусім увайшоў традыцыйныя практычныя веды да гэтага часу. 

Гэта ўсё весела і міла. Страшней, калі фактычная рэальнага свету прылад, а не гульні, маюць тыя ж самыя памылкі. На самай справе, усяго год таму артыкул прыйшла па-за аб Boeing 787 Dreamliner. 

І артыкул у першай Погляд чытае трохі Arcane. Але гэта сказаў, праграмнае забеспячэнне Ўразлівасць у Боінг новы 787 Dreamliner бруя мае патэнцыял, каб выклікаць пілотаў страціць кантроль над самалёт, магчыма, у сярэдзіне палёту, чыноўнікі FAA папярэджаны авіякампаніі ў апошні час. Гэта было вызначэнне што мадэль 787 самалёт, які быў уключаны бесперапынна на працягу 248 дзён можа страціць усё пераменны ток, пераменны ток, электрычная магутнасць з-за генератара блокі кіравання, гПа, адначасова уваходзячы ў адказаўстойлівы рэжым. Гэта накшталт мяне страціць. Але ў мемарандуме гаворыцца, добра, цяпер я атрымаў, што, стан было выклікана праграмным забеспячэннем супрацьстаяць унутраным ў адносінах да кіраванне генератарам адзінкі, якія будуць перапаўняцца 248 дзён бесперапыннай магутнасці. Мы выпускаем гэты звярніце ўвагу, каб прадухіліць страту усяго пераменнага электрычнага магутнасць, што можа прывесці да ў страты кантролю над самалётам. 

Такім чынам, у літаральным сэнсе, ёсць некаторы цэлы лік, ці некаторы эквівалентны тып дадзеных, выкарыстоўваецца ў праграмным забеспячэнні у рэальным самалёце што калі вы трымаеце ваш самалёт дастаткова доўга, па-відаць можа быць у выпадку, калі вы проста працуеце яны ўвесь час і ніколі не адлучыўшы ваш самалёт, здаецца, або дазваляючы яго батарэі паміраюць, у канчатковым выніку падлічыць, і ўверх, і вышэй, і вышэй, і вышэй, і вышэй. 

І, па прыродзе, канчатковае колькасць памяці перапоўніў, адкаце нуль ці некаторы адмоўнае значэнне, пабочным эфектам якога з'яўляецца палохала рэальная рэальнасць што самалёт, магчыма, спатрэбіцца быць перазагружаны, эфектыўна, ці можа ўпасці, што яшчэ горш, так як яна ляціць. Такім чынам, гэтыя віды пытанняў ўсё яшчэ з намі, even-- гэта было 2015 артыкулы, ўсё больш палохалай калі вы не абавязкова разумеюць, цэняць, ці прадбачыць тыя віды памылак. 

Так атрымліваецца, ёсць яшчэ адна Дрэнная рэч аб прадстаўленні дадзеных. Аказваецца, што нават паплаўкі роду недахопы, таму што паплаўкі таксама, Я прапанаваў 32 біта, або можа быць 64, калі вы выкарыстоўваеце двайны. Але гэта ўсё ж такі канчатковая. 

І ўлоў у тым, што калі вы можаце пакласці бясконцую колькасць лічбаў пасля дзесятковай кропкі, няма ніякага спосабу, вы можа прадстаўляць усе магчымыя колькасці, якія нас вучылі у пачатковай школе можа існаваць у свеце. Кампутар, па сутнасці, павінен выбраць падмноства гэтых лікаў для прадстаўлення дакладна. 

Цяпер, кампутар можа раўнд можа быць, трохі, і можа дазволіць вам прыкладна магазін любы лік, якое вы маглі б магчыма хацець. Але толькі інтуітыўна, калі вы маюць канчатковае лік бітаў, вы можаце толькі перастаўляць іх ў многіх канчатковых шляхоў. Такім чынам, вы не можаце, магчыма, выкарыстоўваць канчатковае лік перастаноўкі бітаў, шаблоны нулёў і адзінак, прадстаўляць бясконцае колькасць лікаў, які прадугледжвае, што кампутары могуць быць вельмі добра быць хлусіць нам часам. 

На самай справе, давайце зробім гэта. Дазвольце мне вярнуцца ў CS50 IDE. Дазвольце мне ісці наперад і стварыць невялікую праграму называецца Недакладнасць, каб паказаць, што кампутары, на самай справе, недакладныя. 

І дазвольце мне ісці наперад і пачаць з некаторыя з гэтага кода з раней, і зараз проста зрабіць наступнае. Дазвольце мне ісці наперад і рабіць PRINTF, працэнт е, зваротная касая п, 1 дзеліцца на 10. Іншымі словамі, давайце ныраць глыбей 1/10, як 1 і дзеліцца на 10. Вядома, кампутар можа прадстаўляць 1/10. 

Так што давайце ісці наперад і зрабіць недакладнасцяў. Пабачым. Фармат задае тып двойчы. Але аргумент мае тып Int. Што адбываецца? 

О, цікава, дык гэта Урок, выняты з раней. Я кажу, эй, кампутар шоў я паплавок з працэнтамі ф. Але я даю яму 2 Інтс. Так што атрымліваецца, што я магу выправіць гэта некалькімі спосабамі. 

Я мог бы проста ператварыць адзін у 1,0 і 10 у 10.0, якая, на самай справе, мець эфект пераўтварэнні іх у floats-- ўсё яшчэ спадзяюся, тое ж лік. Або аказваецца, ёсць сёе-тое мы ўбачым зноў у хуткім часе. Вы маглі б кінуць лік. 

Вы можаце, выкарыстоўваючы гэты ўводнымі выраз, можна сказаць, эй, кампутар, вазьмі 10, які я ведаю, з'яўляецца Int. Але ставіцца да яе, калі ласка, як быццам гэта паплавок. Але гэта адчувае сябе залішне складаным. 

Для нашых мэтаў сёння, давайце проста літаральна робяць іх значэння з якая плавае кропкай з дзесятковай кропкай, як гэта. Дазвольце мне ісці наперад і перакладка, зрабіць Недакладнасць, добра, кропка слэш Недакладнасць, увядзіце. Добра, мы добра выглядаць. 

1 дзеліцца на 10, у адпаведнасці з маім Mac тут, на самай справе, 0,100000. Зараз, я выкладаў у пачатковай школе павінна быць бясконцую колькасць 0 '. Такім чынам, давайце па меншай меры паспрабаваць каб убачыць некаторыя з іх. Аказваецца, што Printf трохі спрактыкаваней, чым да гэтага часу мы выкарыстоўвалі. Аказваецца, вы не павінны ўказваць толькі адсоткаў е, ці проста адсотка я. Можна паказаць на самай справе некаторыя опцыі кіравання тут. 

У прыватнасці, я збіраюся сказаць, эй, Printf, на самай справе паказаць мне 10 знакаў пасля коскі. Так гэта выглядае крыху дзіўна. Але вы кажаце, адсоткаў, Дот, колькі лікаў вы хочаце бачыць пасля таго, як дзесятковай кропкі, а затым е для плоскіх, толькі таму, што гэта што кажа дакументацыя. Дазвольце мне ісці наперад і выратаваць. 

І заўважце таксама, я атрымліваю стаміўся ад перадрук рэчаў. Так што я проста усталяваўшы ўверх і стрэлка ўніз на мае ключы тут. І калі я працягваю біць, вы можа бачыць усе каманды што я зрабіў, або няправільна зрабіў. 

І я збіраюся ісці наперад цяпер і на самай справе не выкарыстоўваць, што, па-відаць. Зрабіць недакладнасцяў, кропка слэш imprecision-- так чаму мяне вучылі ў клас школы правярае. Нават калі я друкую яго да 10 дзесятковай ставіць яго, на самай справе, гэта 0,10000. Але вы ведаеце, што? 

Давайце трохі прагны. Скажам, як, пакажы мне 55 паказвае пасля коскі. Давайце сапраўды прыняць гэта праграмаваць для кручэння. Дазвольце мне перарабіць яго з макіяж Недакладнасць, кропка слэш, недакладнасцяў. 

І тут мы ідзем. Ваша дзяцінства было хлуснёй. Па-відаць, 1 дзеліцца на 10, сапраўды, 0.100000000000000005551115123-- 

Што адбываецца? Што ж, атрымліваецца, калі вы выгляд выглядаюць досыць далёка ў асноўны прадстаўленне гэтага нумар, ён на самай справе не дакладна 1/10, або 0,1 і бясконцую колькасць нулёў. Цяпер, чаму гэта? 

Што ж, нягледзячы на ​​тое, што гэта проста лік для нас, людзей, 1 дзеліцца на 10, яна па-ранейшаму адзін з бясконца шмат лічбы, якія мы маглі б прыдумаць. Але кампутар можа прадстаўляць толькі канчатковае лік так лікаў. І так, па сутнасці, тое, што Кампутар паказвае нам з'яўляецца яго бліжэйшым набліжэнне да ліку мы хочам верыць у 1/10, ці сапраўды 0,10000 бясконцасці. 

Хутчэй за ўсё, аднак, гэта так блізка, як ён можа атрымаць. І сапраўды, калі паглядзець пад капотам, як мы тут, гледзячы 55 лічбаў пасля коскі, мы сапраўды бачым, што рэальнасць. Цяпер, як у бок, калі вы маеце калі-небудзь бачыў movie-- большасць з вас, верагодна, haven't-- але Супермэн 3 некалькі гадоў таму, Рычард Прайор, па сутнасці пазыковых сродкаў гэта на дадзены момант у яго кампаніі, каб скрасці шмат фракцый і фракцый драбяза, таму што company-- як я памятаю, гэта было while-- было па сутнасці выкідваючы ўсе, што не ўкладвалася у паняцце цэнтаў. 

Але калі скласці ўсе гэтыя малюсенькія, малюсенькія, малюсенькія колькасці зноў, і зноў, і зноў, вы можаце, як у яго справа, зрабіць добрую суму грошай. 

Гэта тая ж самая ідэя была сарваныя больш свежая, але да гэтага часу ў цяперашні час старэй фільм, які называецца Office Space, дзе хлопчыкі і дзяўчынкі ў гэтым фільме, зрабіў тое ж самае, нашкодзіла цалкам, у канчатковым выніку з занадта шмат грошай на банкаўскім рахунку. Усё гэта было вельмі падазрона. Але ў рэшце рэшт, Недакладнасць ўсе вакол нас. 

І гэта таксама можа быць Палохае справа. Аказваецца, што Супермэн 3 і офісныя памяшканні ў бок, там можа быць нейкі вельмі рэальна сусветныя наступствы рэаліі недакладным прадстаўленне даных што нават мы, людзі, да У гэты дзень не абавязкова зразумець, як мы павінны, ці ўспомніць, як часта, як мы павінны. І, сапраўды, наступны кліп ад погляду на нейкі вельмі рэальны свет Наступствы таго, што адбудзецца, калі вы ня цэняць дакладнасць, можа адбыцца ў прадстаўленні лікаў. 

[ВИДЕОВОСПРОИЗВЕДЕНИЕ] 

-Компьютеры, Мы ўсе прыйшлі, каб прыняць што часта хвалюе праблемы, ісці з them-- памылкі, вірусы, і праграмныя глюкі, за невялікія кошты плаціць для выгоды. Але ў галіне высокіх тэхналогій і высокай хуткасці ваенныя і касмічныя праграмныя прыкладання, самая маленькая праблема можа праславіцца ў нягоды. 

4 чэрвеня 1996 г., навукоўцы падрыхтавалі каб запусціць беспілотны Ariane 5 ракеты. На яго борце навукова спадарожнікі прызначаныя каб сапраўды ўсталяваць, якім чынам ўзаемадзейнічае магнітнае поле Зямлі з сонечнымі вятрамі. Ракета была пабудавана для Еўрапейскае касмічнае агенцтва, і адарваўся ад свайго аб'екта на ўзбярэжжы Французскай Гвіяны. 

-На Каля 37 секунд у палёт, яны спачатку заўважыў, што нешта адбываецца не так. Фарсункі былі ў паваротная шлях яны на самай справе не павінны. Каля 40 секунд у палёце, ясна, што аўтамабіль быў у бядзе. 

І вось, калі яны зрабілі рашэнне знішчыць яго. Афіцэр бяспекі па вышыні, з велізарныя кішкі, націснуў на кнопку, ўзарвалі ракету, перш чым яна зможа стаць пагрозай для грамадскай бяспекі. 

-Гэта Была дзявочае плаванне на Ariane 5. І яго разбурэнне ўзяў месца з-за памылкі убудаваныя ў праграмнае забеспячэнне ракеты. -The Праблема на Ariane была што існуе лік, патрабуецца 64 біт, каб выказаць. І яны хацелі, каб пераўтварыць гэта да 16-бітнага ліку. Яны выказалі здагадку, што нумар ніколі не збіраўся павінна быць вельмі вялікім, што большасць з тых, лічбы ў 64-бітнага ліку былі нулі. Яны былі не правы. 

-The Няздольнасць аднаго праграмнае забеспячэнне, каб прыняць выгляд нумар, які генеруецца іншы быў у корані збою. Распрацоўка праграмнага забеспячэння стала вельмі затратная частка новай тэхналогіі. Ariane ракеты былі вельмі паспяховым, так што вялікая частка праграмнага забеспячэння створаны для яго было таксама які выкарыстоўваецца ў Ariane 5. 

-The Асноўная праблема складалася ў тым, што Ariane 5 быў хутчэй, паскараецца хутчэй. І праграмнае забеспячэнне не было даводзілася за гэта. 

-The Знішчэнне ракеты была велізарная фінансавая катастрофа, ўсё з-за памылкі хвілін праграмнага забеспячэння. Але гэта быў не першы Праблемы пераўтварэння дадзеных пра час мучыла сучаснай ракетнай тэхналогіі. 

-У 1991, с пачаткам першай вайны ў Персідскім заліве, патрыёт Ракетны выпрабаваў падобнага роду задачы пераўтварэнні лік. І ў выніку, 28 чалавек, 28 амерыканскіх салдат, былі забітыя, і каля 100 чалавек атрымалі раненні, калі Patriot, які павінен быў для абароны ад ўваходзяць бокоплавов, не ўдалося стрэліць ракетай. 

-Калі Ірак уварваўся ў Кувейт, і Амерыку Бура ў пустыні пачаў у пачатку 1991 года, Патрыёт ракетныя батарэі былі разгорнутыя каб абараніць Саудаўскую Аравію і Ізраіль ад ірацкіх ракетных нападаў Скад. Patriot з'яўляецца амерыканскай сярэдняй далёкасці паверхню паветранай сістэмы, вытворчасці кампаніяй Raytheon. 

-The Памер перахопніка Patriot сама па сабе мае даўжыню каля прыкладна 20 футаў. І важыць каля 2000 фунтаў. І яна нясе боегалоўку каля, Я думаю, што гэта прыкладна 150 фунтаў. А сама боегалоўка з'яўляецца высокая выбуховага рэчыва, які ёсць фрагменты вакол яго. корпус боегалоўка распрацаваны, каб дзейнічаць як карцеч. 

-The Ракеты перавозяцца чатыры ў кантэйнеры, і транспартуюцца паўпрычэпам. 

-The Patriot сістэмы ПРА ўзыходзіць па меншай меры, 20 гадоў. Першапачаткова ён быў распрацаваны як супрацьракетная абарона паветранага каб збіваць варожыя самалёты. У першай вайне ў Персідскім заліве, калі гэтая вайна прыйшла разам, Армія хацела выкарыстоўваць яго збіваць бокоплавов, а не самалёты. 

ВПС Ірака было не так шмат праблем. Але армія хвалявалася пра бокоплавов. І такім чынам яны спрабавалі абнавіць Patriot. 

-Intercepting Ворага Ракета падарожжа ў 5М збіраецца быць складаным дастаткова. Але калі Patriot быў дастаўлены ў эксплуатацыю, Армія не вядома пра Іракскі мадыфікацыя, якая зрабіла іх бокоплавы амаль немагчыма патрапіць. 

-Што Здарылася гэта бокоплавы, што прыбывалі ў няўстойлівыя. Яны былі пагойдваючыся. Прычынай гэтага было іракцы, у парадку каб атрымаць 600 кіламетраў з 300 км Ракета дыяпазон, узялі вага з пярэдняй боегалоўкай. Яны зрабілі боегалоўка святлей. 

Так што цяпер Патрыёт спрабуючы прыйсці ў Scud. І большую частку часу, Пераважная большасць часу, было б проста лётаць на Scud. Пасля таго, як аператары сістэмы Patriot зразумеў, што Patriot прапусціў сваю мэту, яны дэтанаваць боегалоўку Патрыятычнага каб пазбегнуць магчымых страт, калі яна было дазволена ўпасці на зямлю. 

-вот Было тое, што большасць людзей бачылі, гэтыя вялікія вогненныя шары ў небе, і не зразумелі, як перахапляе Скад боегаловак. 

-хоць У начны час неба, патрыёты з'явіліся каб быць паспяхова знішчаючы Скад, у Дахране, не можа быць ніякай памылкі аб яго выкананні. Там, радыёлакацыйная сістэма Патрыятычнага страціў след якое ўваходзіць Scud, і ніколі не запушчаны з-за да праграмнага хіба. Гэта было ізраільцян, якія упершыню выяўлены што чым даўжэй сістэма была ўключана, тым больш час разыходжанні сталі, з-за гадзінамі ўкаранёнага ў кампутары сістэмы. 

-О За два тыдні да трагедыя ў Дахране, ізраільцяне паведамілі Міністэрства абароны што сістэма губляе час. Прыкладна праз восем гадзін або бегу, яны заўважылі, што сістэма становіцца прыкметна менш дакладным. Міністэрства абароны ў адказ кажучы ўсё батарэйкі Patriot не пакідаць сістэмы на працягу доўгага часу. Яны ніколі не казалі, што доўгі час was-- восем гадзiн, 10 гадзін, 1000 гадзін. Ніхто не ведаў. 

-The Батарэі Patriot размешчаных у казарме у Дахране і яго недахопы ўнутранай Гадзіны былі на больш чым 100 гадзін у ноч на 25 лютага. 

-Ён Адсочваў час з дакладнасцю каля адной дзесятай долі секунды. Цяпер, дзясятую секунды гэта цікавае лік, так як яно не можа быць выказана у двайковай сістэме дакладна, што азначае, што яна не можа быць выказана дакладна у любым сучасным лічбавым кампутары. Цяжка паверыць. 

Але выкарыстаць гэта ў якасці прыкладу. Давайце возьмем нумар на адну траціну. Адна траціна не можа быць выяўляецца ў дзесятковай сістэме злічэння ў дакладнасці. Адна трэць з'яўляецца 0,333 адбываецца на бясконцасці. 

Там няма ніякага спосабу зрабіць гэта з абсалютная дакладнасць у дзесятковай сістэме злічэння. Гэта менавіта тая праблема што здарылася ў Patriot. Чым даўжэй сістэма пабегла, горш стала памылка часу. 

-пасля 100 гадзін працы, Памылка ў той час быў толькі каля адной траціны секунды. Але з пункту гледжання арыентуецеся на Ракета падарожжа ў 5М, гэта прывяло да адсочванню Хібнасць больш за 600 метраў. Было б фатальнай памылкай для салдат на тым, што адбылося гэта запуск Scud быў дэтэктуецца ранніх спадарожнікаў папярэджання і яны ведалі, што Scud быў прыходзяць у іх агульным кірунку. Яны не ведалі, адкуль ён зыходзіць. 

-Гэта Быў цяпер да радара кампанент сістэмы Patriot абараняючы Дахране, каб знайсці і захаваць след надыходзячай ракеты праціўніка. 

-The Радар быў вельмі разумны. Гэта будзе на самой справе трэк становішча Scud, а затым прадказаць, дзе гэта магчыма будзе ў наступны раз паслаў радар імпульсу па-за. Гэта называецца шэраг варот. 

-Тады, Як толькі Patriot вырашае дастаткова часу прайшоў, каб вярнуцца і праверыць наступны месца для гэтага знойдзенага аб'екта, ўстае. Таму, калі ён вярнуўся да няправільнага месца, тады не бачыць аб'ект. І гэта не вырашыць, што не было аб'ект, гэта было ілжывае выяўленне, і кроплі трэк. 

-The Уваходны Скад знік з экрана радара. І праз некалькі секунд, гэта урэзаўся ў казармы. Скад загінулі 28 і быў апошнім адзін стрэліў падчас першай вайны ў Персідскім заліве. 

Трагічна, абноўленае праграмнае забеспячэнне прыбыў у Дахране на наступны дзень. Праграмнае забеспячэнне памылка была было зафіксавана, закрыццё адзін раздзел у каламутнай Гісторыя ракеты Patriot. 

[ВИДЕОВОСПРОИЗВЕДЕНИЕ] DAVID J. малая: Так што гэта ўсё сказаць, што гэтыя пытанні перапаўнення і недакладнасцяў усё занадта рэальна. Дык як жа мы сюды трапілі? Мы пачалі з проста гаворым пра Printf. Зноў жа, гэтая функцыя, друкуе нешта на экране, і мы ўвялі ў далейшым некалькі іншых функцый з так званай бібліятэкі CS50 ст. І мы будзем працягваць убачыць іх у свой час. І мы, у прыватнасці, выкарыстоўваецца атрымання радкі, і атрымаць Int, а цяпер таксама атрымаць з якая плавае кропкай, і ўсё ж іншыя ўсё яшчэ будзе мы сутыкаемся і выкарыстоўваць сябе ў хуткім часе. 

Але ў некаторых выпадках, ёсць мы ўжо бачылі неабходнасць каб захаваць тое, што гэтыя функцыі рукі назад? Яны раздаюць нас назад радок, або INT, або з якая плавае кропкай. І часам нам трэба пакласці, што радок, або INT, або з якая плавае кропкай, недзе. 

І захоўваць гэтыя рэчы, успомніць, як у пустым месцы, у нас ёсць зменныя. Але ў адрозненне ад нуля, ў C мы маем фактычныя тыпы з дадзеных variables-- тыпы, больш generally-- сярод іх, радок, INT, A плаваць, і гэтыя іншыя да гэтага часу. 

І таму, калі мы аб'яўляем зменныя ў C, мы павінны абвясьціць нашы тыпы дадзеных. Гэта не тое, што мы будзем павінны зрабіць пазней у семестр як мы пераход на іншыя мовы. Але цяпер нам трэба да апрыёрна загадзя, растлумачыць кампутара, які тып зменнай мы хочам, каб даць нам. 

Цяпер, між тым, каб надрукаваць тыя віды тыпаў дадзеных, мы павінны сказаць PRINTF, чаго чакаць. І мы ўбачылі працэнт з для радкоў, і адсотак я для цэлых лікаў, і некаторыя іншыя ўжо. І гэта проста патрабаванні для візуальнага прадстаўлення гэтай інфармацыі. 

І кожны з іх можа быць на самой справе параметризовано або пераробленыя, у пэўным сэнсе, калі вы хочаце, каб у далейшым кантроль тып вываду, які вы атрымаеце. І, на самай справе, аказваецца, што не толькі ёсць зваротная касая п для новай лініі. Там сёе-тое яшчэ называецца зваротнай касой рысы г для вяртання карэткі, якая гэта больш падобна на старая школа пішучая машынка, а таксама для Windows выкарыстоўваецца на працягу многіх гадоў. 

Там у ўжыць зваротны слэш т для ўкладак. Аказваецца, што калі вы хочаце падвойныя двукоссі ўнутры радка, нагадаем, што мы выкарыстоўвалі падвойныя двукоссі двойчы цытата злева і справа канцы нашых радкоў да гэтага часу. Гэта, здавалася б, усё заблытаць. 

Калі вы хочаце паставіць падвойныя двукоссі ў сярэдзіна string-- і, сапраўды, гэта збівае з толку, каб убачыць. І таму вы павінны бегчы, так кажуць, падвойныя двукоссі з чымсьці як, у літаральным сэнсе, патрэбна ўжыць зваротны слэш падвойныя двукоссі. І ёсць некалькі іншых да гэтага часу. І мы ўбачым больш тых, ў рэальных умовах эксплуатацыі датуль. 

Так давайце зараз пераход ад дадзеных, а таксама прадстаўленне, і арыфметычныя аператары, усе з якіх даў нам некаторыя будынкі блокі, з якімі гуляць. Але цяпер давайце на самай справе даць нам астатняя частка слоўніка што ў нас ужо было На мінулым тыдні з нуля прымаючы зірнуць на некаторыя іншыя Канструкцыі ў C-- не ўсе з іх. Але ідэі мы пра тое, каб убачыць на самай справе проста каб падкрэсліць пераклад з адна мова, да драпін, да іншага, C. 

І з часам, мы падбярэм больш прылад для нашага інструментара, так бы мовіць, сінтаксічна. І, на самай справе, вы ўбачыце, што ідэі У цяперашні час даволі знаёмыя з мінулага тыдня. Дык давайце зробім гэта. 

Давайце ісці наперад і нагнятаць праграму што на самой справе выкарыстоўвае некаторыя выразы, лагічнае выраз. Дазвольце мне ісці наперад тут і стварыць новы файл. Я буду называць гэта condition.c. 

Дазвольце мне ісці наперад і ўключаюць у сябе бібліятэку CS50. І дазвольце мне ісці наперад і ўключаюць у сябе стандарт io.h для нашых функцый, і Printf, і адпаведна больш. Дазвольце мне даць сабе, што шаблоннага з INT галоўная пустата, чыё тлумачэнне, якое мы будзем вярнуцца ў будучыні. 

Цяпер дазвольце мне ісці наперад і даць сам праз INT атрымаеце Int. Тады дазвольце мне ісці наперад і рабіць гэта. Я хачу сказаць, калі я гэта less-- давайце адрозненні паміж станоўчым, адмоўным, або нулявыя значэння. 

Так што, калі я менш за нуль, дайце мне проста гэтая праграма проста сказаць, адмоўны, зваротная касая рыса п, інакш калі я больш за нуль. Цяпер я, вядома, хачу сказаць, PRINTF станоўчы вынік, зваротнай касой н. А потым яшчэ if-- я мог бы зрабіць гэта. 

Я мог бы зрабіць, калі я роўны 0. Але я б рабіць на хоць бы адна памылка ўжо. Нагадаем, што знак роўнасці ня роўнае, як і мы, людзі, ведаем гэта. 

Але гэта аператар прысвойвання. І мы не хочам прымаць 0 на права і пакласці яго ў I на левай баку. Такім чынам, каб пазбегнуць блытаніны, або магчыма злоўжыванне знака роўнасці, людзі вырашылі некалькі гадоў таму што ў шматлікіх мовах праграмавання калі вы хочаце, каб праверыць на роўнасць паміж левымі і правымі, вы на самой справе выкарыстаць раўняецца роўных. Такім чынам, вы патрапілі ў знак роўнасці двойчы. Калі вы хочаце прызначыць справа налева, выкарыстоўваць адзін знак роўнасці. Такім чынам, мы маглі б зрабіць яшчэ this-- калі я роўны роўны нулю. 

Тады я мог бы пайсці і адкрыць мае фігурныя дужкі, і сказаць, Printf 0, зваротная касая рыса п, зроблена. Але памятайце, як гэтыя скрыжаваньняў можа працаваць. І, на самай справе, проста падумайце аб логіцы. я гэты лік. Гэта цэлы лік, у прыватнасці. І гэта азначае, што яна будзе менш, чым 0 або больш 0, або 0. Такім чынам, ёсць выгляд гэтага разумеецца выпадак па змаўчанні. 

І такім чынам мы маглі, гэтак жа, як Драпіны, абысціся без другога, калі, і проста сказаць яшчэ. Па логіцы рэчаў, калі ты праграміст ведаю, што ёсць толькі тры вядры, у якія Сцэнар можа fall-- першы, другі, або трэці у гэтым case-- ня затлумляцца дадаючы дадатковую дакладнасць і дадатковая логіка там. Проста ісці наперад з Справа па змаўчанні тут яшчэ. 

Цяпер, давайце ісці наперад пасля захавання гэтага зрабіць ўмовы кропка слэш conditions-- не вялікі карыстацкі інтэрфейс, таму што я не заахвоціла карыстальнік, як я згадваў раней. Але гэта нармальна. Мы будзем трымаць яго проста. Давайце паспрабуем лік 42. І гэта станоўча. Давайце паспрабуем нумар 42 адмоўнае, адмоўны. 

Давайце паспрабуем значэнне 0. І сапраўды, яна працуе. Цяпер вы будзеце бачыць праблемы перад доўгія, тэставанне рэчы ў тры разы, верагодна, не з'яўляецца дастатковым. Вы, верагодна, хочаце, каб праверыць некаторыя вялікія ліку, некаторыя менш, нумары, некаторыя прыватныя выпадкі, як мы прыедзем, каб апісаць іх. 

Але на сённяшні дзень гэта даволі простая праграма. І я ўпэўнены, што, па логіцы рэчаў, што ён трапляе ў трох выпадках. І сапраўды, нават калі мы проста сканцэнтраваны на патэнцыйныя недахопы недакладнасцяў і перапаўнення, у рэальнасць, дзе многія з праблем CS50, у мы не будзем турбавацца аб тым, увесь час, гэтыя пытанні перапаўнення і Недакладнасць, бо, па сутнасці, у C, гэта на самай справе не ўсё, што лёгка пазбегнуць гэтых рэчаў. Калі вы хочаце, каб падлічыць больш, і больш, і больш, аказваецца, ёсць метады, якія Вы можна выкарыстоўваць, часта з удзелам рэчы, званыя бібліятэкі, калекцыі кода, што іншыя людзі пісалі, што вы можаце выкарыстоўваць, і іншыя мовы, такія як Java і іншыя, на самай справе зрабіць гэта нашмат прасцей разлічваць яшчэ вышэй. Так што на самай справе некаторыя з гэтых небяспекаў функцыяй выкарыстоўванага вамі мовы. І ў бліжэйшыя тыдні, мы будзем ўбачыць, як небяспечны C сапраўды можа быць, калі вы не выкарыстоўваеце яго правільна. Але адтуль, і з Python і JavaScript, будзе мы пласт на некаторыя дадатковыя сродкі абароны, і запусціць менш гэтых рызык. 

Дык давайце зробім трохі больш цікавая логіка ў нашай праграме. Такім чынам, дазвольце мне ісці наперад і стварыць праграма пад назвай Logical толькі так я магу гуляць з некаторымі Фактычная логіка, logical.c. Я проста скапіяваць і ўставіць некаторыя кода з раней, так што я вярнуся да гэтай добрай адпраўной кропкай. 

Дазвольце мне на гэты раз зрабіць сЬаг C. Я збіраецца даць яму імя C толькі таму, што звычайныя, атрымаць сімвал ад карыстальніка. А давайце прадставім, як Я доля рэалізацыі з гэтай праграмы Rm, то выдаліць Праграма да гэтага запыту карыстачу для выдалення файла. Як мы можам гэта зрабіць? 

Я хачу сказаць, калі З роўны роўна, цытата Unquote, у, то я буду лічыць, што карыстальнік абраў так. Я проста хачу, каб надрукаваць так. Калі б гэта было на самай справе пісаць праграма выдалення, мы маглі б выдаліць файл з вялікай колькасцю радкоў кода. Але мы будзем трымаць яго проста. 

Інакш, калі з роўна роўны N-, і цяпер тут, я збіраюся сказаць, карыстальнік павінен мець на ўвазе не. А потым яшчэ, вы ведаеце, што? Я не ведаю, што яшчэ карыстальнік збіраецца ўвесці. Так што я проста хачу сказаць, што то ёсць памылка, то, ён ці яна на самай справе набралі. 

Дык што ж тут адбываецца? Існуе прынцыповая розніца супраць таго, што я зрабіў у мінулым. Падвойныя двукоссі, падвойныя двукоссі, двайныя каціроўкі, і, тым не менш, адзінкавыя двукоссі, адзінкавыя двукоссі. Аказваецца, у C, што, калі Вы хочаце напісаць радок, Вы робіце падвойныя двукоссі, гэтак жа, як мы выкарыстоўваю ўвесь гэты час з Printf. 

Але калі вы хочаце мець справу з проста адзіночны сімвал, так званы сімвал, то вы на самой справе выкарыстаць адзінкавыя двукоссі. Тыя з вас, хто запраграмаваны перад тым, вы не маглі б даводзілася турбавацца пра гэта Адрозненне ў некаторых мовах. У C, гэта сапраўды мае значэнне. І таму, калі я атрымліваю паўкокс і я хачу для параўнання, што сімвал з выкарыстаннем роўных роўная некаторай літары як у альбо п, я, на самой справе, трэба мець адзінкавыя двукоссі. 

Цяпер, давайце ісці наперад і рабіць гэта. Давайце ісці наперад і робяць лагічныя кропка слэш лагічна. І зараз я быць абуджэння. Так што, па-відаць, лепшы карыстацкі досвед будзе на самой справе сказаць, што мне рабіць тут. Але я збіраюся проста слепа скажам у для так, добра, добра. 

Давайце запусцім яго зноў, п для не, добра. Выкажам здагадку, напрыклад, некаторыя людзі, якіх я ведаю, мае вечка блакавання ключ на занадта часта. Так што я капітал Y, увядзіце, памылку. Добра, гэта не зусім тое, што я чакаў. На самай справе, кампутар робіць тое, што ў літаральным сэнсе Я расказаў гэта do-- праверыць у ніжнім рэгістры у і малыя літары п. Гэта не адчувае сябе добра карыстацкі інтэрфейс, хоць. Дазвольце мне прасіць і прыняць альбо ў ніжнім рэгістры або ў верхнім рэгістры. Так што атрымліваецца, вы можаце захацець сказаць нешта, як у пустым месцы, як літаральна або C роўная раўняецца капіталу аднаго цытуемы у. Аказваецца, C не мае гэта ключавое слова або літаральным. 

Але ў яго ёсць дзве вертыкальныя паласы. Вам неабходна ўтрымліваць клавішу Shift, як правіла, калі вы выкарыстоўваеце ЗША клавіятуры, і ўдарыў вертыкальную паласу клавішу, размешчаную вышэй вашага вяртання ключа. Але гэта вертыкальная паласа Вертыкальная рыса азначае або. 

Калі ж, наадварот, мы хочам сказаць, і, як у пустым месцы, мы маглі б зрабіць Ампэрсанд Ампэрсанд. Гэта не мае ніякага лагічнага сэнсу тут, таму што чалавек не мог набралі як у і ў ніжнім рэгістры ў і капітал Y, як той жа характар. Так ці тое, што мы маем намер тут. 

Так што, калі я раблю гэта ў абодвух месцах, або C раўняецца капіталу роўная N, зараз зноў запусціць, рабіць лагічныя, перазапускаць лагічна. Цяпер я магу ўвесці у. І я магу зрабіць гэта зноў капітал Y, або капітал N. І я мог бы дадаць у дадатковы Камбінацыі да гэтага часу. 

Так што гэта лагічна Праграма, паколькі ў цяперашні час Я правяраю лагічна для гэта значэнне ці гэта значэнне. І я не павінен, абавязкова, прыдумаць яшчэ два МФС ці ж МФС. Я магу на самой справе аб'яднаць некаторыя з звязаных з логікай разам такім чынам. Так што гэта было б лепш распрацаваны, чым проста кажучы, калі З роўны маленькую у, друк ды, інакш, калі з роўна капіталу Y, друк ды, інакш, калі з роўна lower-- іншымі словамі, вы не павінны мець усё больш і больш філіялаў. Вы можаце аб'яднаць некаторыя з эквівалента галіны лагічна, так як у гэтым шляху. 

Такім чынам, давайце разгледзім толькі адзін Канчатковы інгрэдыент, адзін канчатковая канструкцыя, што C дазваляе. І мы вернемся ў будучыню другім яшчэ. І тады мы заключаем, паглядзеўшы пры ня правільнасці code-- атрыманне кода work-- але дызайн кода, і пасадзіць гэтае насенне на ранніх стадыях. 

Такім чынам, дазвольце мне ісці наперад і адкрыць новы файл тут. Вы ведаеце, што? Я збіраюся паўторна рэалізаваць тая ж праграма, але выкарыстоўваючы іншую канструкцыю. 

Такім чынам, дазвольце мне хутка отдамся доступ да ўключаюць CS50.h для бібліятэкі CS50, стандарт io.h для Printf. Дайце мне маю INT галоўную пустэчу. А потым тут, хай мне ісці наперад і рабіць гэта. 

Чар з атрымлівае атрымаць сімвал, гэтак жа, як і раней. І я збіраюся выкарыстоўваць новую канструкцыю now-- перамыкач, на які характар? Так перамыкач накшталт як Пераключэнне чыгуначных шляхоў. Або, на самай справе, гэта свайго роду Умоўны яшчэ, калі яшчэ, калі, але напісана некалькі інакш. 

Перамыкач выглядае наступным чынам. У вас ёсць перамыкач, і што потым знак ці нумар, які вы хочаце паглядзець, то некаторыя фігурныя дужкі як у Драпіны, проста скажам, зрабіць гэты матэрыял. І тады ў вас ёсць розныя выпадкі. 

Вам не варта выкарыстоўваць, калі і яшчэ. Вы ў літаральным сэнсе выкарыстоўваць слова выпадак. І вы маглі б сказаць нешта накшталт гэтага. 

Так што ў выпадку маленькай у, або ў выпадку загалоўнай літары Y, ісці наперад і раздрукаваць ды. А потым ўспыхнуць перамыкача. Вось і ўсё. Мы скончылі. 

Інакш, калі, так бы мовіць, ніжні рэгістр п, або капітал, N, затым ісці наперад і друк па-за няма, а затым перапынак. Else-- і гэты выгляд з'яўляецца кейс па змаўчанні indeed-- Printf error-- і проста для добрай мерай, хаця лагічна гэты перапынак не патрэбны таму што мы знаходзімся ў канцы перамыкача ў любым выпадку, Я зараз ўспыхваюць перамыкача. Так гэта выглядае крыху па-іншаму. 

Але, па логіцы рэчаў, гэта на самай справе эквівалентныя. І чаму б вы выкарыстоўваць адзін над іншым? Часам, толькі асабістыя перавагі, часам эстэтыка, калі я гляджу на гэта Цяпер, ёсць сёе-тое Трэба сказаць для чытальнасць гэтага кода. Я маю на ўвазе, не кажучы ўжо пра тое, што гэта код з'яўляецца новым для многіх з нас у пакоі. 

Але гэта толькі збольшага даволі. Вы бачыце ў ніжнім рэгістры у, капіталу Y, ніжні рэгістр N, N капітал па змаўчанні, гэта толькі часткова скачкі на вас у шляху што, магчыма, можа быць, папярэдні прыклад з МСФ і вертыкальных стрыжняў, а астатняе МФС, не маглі б мець. Так што гэта сапраўды пытанне асабістага выбар, на самай справе, ці чытальнасць, кода. 

Але з пункту гледжання функцыянальнасці, дазвольце мне ісці наперад і зрабіць выключальнік, кропка слэш перамыкач, і цяпер ўвесці ў ніжнім рэгістры у, капітал Y, малыя літары п, капітал N, Дэвід, паўтарыць спробу, таму што гэта ні аднаго знака. Давайце зробім х, памылка, як і чакалася. І, logically-- і гэта тое, Я хацеў бы заклікаць у general-- нават хоць мы толькі падрапаць Паверхню некаторых з гэтых асаблівасцяў. 

І гэта можа быць не відавочна, калі вы самастойна сесці за клавіятуру, як гэта працуе? Што б гэта зрабіць? Прыгожая рэч аб тым, ноўтбук або настольны кампутар, або доступ да кампутара з дапамогай кампілятара, і з рэдактарам кода, як гэта, гэта амаль заўсёды можна адказаць на гэтыя пытанні для сябе проста паспрабаваць. 

Напрыклад, калі рытарычная Пытанне пад рукой былі, што адбудзецца, калі вы забыліся вашы заявы перапынак? Што на самой справе вельмі распаўсюджаная рэч, каб зрабіць, таму што ён не выглядае як вам сапраўды патрэбныя. Яны не сапраўды завяршыць думалі, як круглыя ​​дужкі або фігурныя дужка робіць. Давайце ісці наперад і перакампіляваць код і паглядзець. Так зрабіце выключальнік, кропка пераключэння слэш. Давайце тыпу ў ніжнім рэгістры у, верхні выпадак, Enter. Такім чынам, я надрукаваў у. 

Праграма кажа, так, не, памылка, як калі б гэта было змяненне яго розум. Але гэта збольшага было, таму што адбываецца з перамыкачом першы выпадак, Матч па сутнасці азначае, эй кампутар, выканаць увесь код пад ім. І калі вы не кажаце, перапынак, або не кажаце, перапынак, ці не кажуць перапынак, кампутар будзе дзьмуць праз усе гэтыя лініі і ня выконваць іх усё да ён атрымлівае да гэтага фігурнай дужкай. Таму тармазы, сапраўды, неабходна. Але тут ежа на дом, калі ёсць сумненні, паспрабуйце што-небудзь. Можа быць, захаваць свой код па-першае, або захаваць яго ў дадатковы файл калі вы сапраўды занепакоеныя Месінга і таго, каб аднавіць праца, якую вы ведаеце, працуе. 

Але паспрабаваць рэчы. І не так страшна, можа быць, аб тым, што кампутар можа зрабіць, або што вы маглі б што-небудзь зламаць. Вы заўсёды можаце вярнуцца назад у нейкай больш ранняй версіі. 

Так што давайце скончым, гледзячы пры праектаванні кода. У нас ёсць гэтая здольнасць зараз пісаць ўмовы і цыклы запісу, і зменныя і функцыі апрацоўкі выклікаў. Так што, шчыра кажучы, мы накшталт назад у дзе мы былі тыдзень таму з нуля, хоць і з менш пераканаўчым тэкстава Серада, чым нуля дазваляе. 

Але зьвярніце ўвагу, як хутка мы набылі што слоўнікавы запас, нават калі гэта збіраецца заняць некаторы час, каб патануць у, так што зараз мы можам выкарыстоўваць гэты слоўнік пісаць больш цікавыя праграмы. І давайце крок дзіцяці да што, як мае быць. Дазвольце мне ісці наперад і стварыць новы файл тут. 

Я буду называць гэта prototype.c, і ўвесці у першы раз, здольнасць каб зрабіць свае ўласныя функцыі. Некаторыя з вас, магчыма, зрабіў гэта з нуля, у якім вы можаце стварыць свой ўласныя блокі нуля, а затым перацягнуць іх на месца ўсюды, дзе вы хацелі б у C. І ў большасці праграм мовы, вы можаце зрабіць менавіта that-- зрабіць свае ўласныя функцыі, калі яны ўжо не існуюць. 

Так, напрыклад, дазвольце мне ісці наперад і ўключаюць CS50.h, і ўключаюць у сябе стандарт io.h, INT галоўны несапраўдным. І зараз у нас ёсць запаўняльніка гатовы да працы. Я трымаю друку рэчы як імёны людзей сёння. І гэта адчувае сябе like-- не было б нядрэнна, калі б былі функцыя называецца імя друку? Я не павінен выкарыстоўваць Printf. Я не павінен памятаць усе коды фармату. Чаму не я, і чаму не зрабiў нехта перада мной, стварыць функцыю пад назвай друку імя, што дадзена нейкую назву, проста друкуе яго? 

Іншымі словамі, калі я кажу, эй, кампутар, дайце мне радок пытаючыся ў карыстальніка, напрыклад, з дапамогай функцыі атрымання радкі CS50 ст. Эй, кампутар, змясціць гэты радок у пераменная у левай частцы, і называюць гэта S. А потым, эй кампутар, ісці наперад і друк, што імя чалавека, зроблена. 

Цяпер, было б нядрэнна, таму што гэтая праграма, трапна назваў, кажа мне, што ён павінен рабіць шляхам імёнаў тых, функцыі. Дазвольце мне пайсці і зрабіць прататып, Enter. І, на жаль, гэта не будзе лётаць. 

Prototype.c, радок 7, характар 5, памылка, невідавочнае аб'яву функцыі друку імя недапушчальны ў C99, C99 азначае версію C які выйшаў у 1999 годзе. Гэта ўсе. 

Так што я не ведаю, што усё гэта азначае, што да гэтага часу. Але я прызнаць памылку ў чырвоным колеры. Гэта даволі відавочна. 

І мне здаецца, што з зялёны сімвал тут, праблема звязаная з імем друку, адкрыйце PAREN s, блізкія PAREN, паўсінтэтычныя тоўстай кішкі. Але няяўнае дэкларацыя функцыя, якую мы бачылі коратка раней. Гэта азначае, проста, што Clang не ведае, што я маю на ўвазе. 

Я выкарыстаў Кодавае слова, што гэта ніколі не бачыў і не вучылі раней. І таму мне трэба, каб навучыць яго што значыць гэтая функцыя. Так што я збіраюся ісці наперад і рабіць гэта. 

Я збіраюся ісці наперад і рэалізаваць мая ўласная функцыя называецца Print Name. І я буду казаць, як гэта вынікае, што ён робіць гэта, PRINTF, прывітанне, адсоткаў s, зваротны слэш н, імя, кропка з коскі. Дык што ж я толькі што зрабіў? 

Так што атрымліваецца, каб рэалізаваць сваю ўласную функцыю, мы неяк запазычыць некаторыя з тая ж структура, як галоўны што мы толькі што былі нешта само сабой разумеецца, і я ведаю, проста скапіяваць і прыклейванне даволі шмат, што Я пісаў у мінулым. Але зьвярніце ўвагу на ўзор тут. Int, Main, Пустэча, мы будзем дражніць адзін ад аднаго да таго доўга, што гэта на самай справе азначае. 

Але на сённяшні дзень, як раз звярніце ўвагу на паралелізм. Пустата, імя друку, імя радкі, так што ёсць фіялетавае ключавое слова, які мы збіраемся пачаць выклікаючы тып якое вяртаецца значэння, імя функцыя, а затым ўвод. Так што, на самай справе, мы можам пераганяць гэты від, як на мінулым тыдні паколькі гэтае імя або алгарытм кода мы знаходзімся збіраецца write-- алгарытм, які ляжыць у аснове код, які мы збіраемся напісаць. 

Гэта яго ўваход. Гэта яго выхад. Гэтая функцыя, імя друку, з'яўляецца распрацаваны, каб узяць радок з імем імя, або незалежна ад таго, у якасці ўваходных дадзеных, а затым анулююцца. Яна не вяртае нічога, як атрымаць радок або атрымаць INT робіць. Так што ён збіраецца перадаць мне што-небудзь. Гэта проста будзе мець пабочны эфект, так бы мовіць, друкаваць імя чалавека. Так звярніце ўвагу, радок 7, я можна назваць імя друку. Радок 10, я магу вызначыць або рэалізуюць імя друку. Але, на жаль, гэтага недастаткова. 

Дазвольце мне ісці наперад і перакампіляваць гэта пасля захавання. Вау, цяпер, я зрабіў гэта горш, здавалася б. Такім чынам, невідавочнае аб'яву імя функцыі друку ня дзейнічае. І, зноў жа, ёсць больш памылак. Але, як я папярэдзіў раней, нават калі вы атрымліваеце заваленыя, або трохі сумна бачыць так шмат Памылкі, засяродзіцца толькі на першы на пачатковым этапе, так як гэта можа быць проста мелі каскадны эфект. Так C або Clang больш канкрэтна, да гэтага часу не прызнае імя друку. 

І гэта таму, што Clang, дызайн, гэта свайго роду нямы. Гэта толькі робіць тое, што вы скажаце ёй зрабіць. І гэта толькі робіць гэта ў парадку у якім вы скажаце ёй зрабіць. 

Такім чынам, я вызначыў галоўны на чацвёртым радку, як мы рабілі даволі часта. Я вызначыў імя друку ў радку 10. Але я спрабую выкарыстоўваць друкаваць імя на лініі сем. 

Гэта занадта рана, пакуль не існуе. Так што я мог быць разумным, і быць, як, ОК, так што давайце проста гуляць разам, і перамясціць імя друку уверх тут, і перасабраць. О Божухна. Гэта спрацавала. Гэта было так проста. 

Але логіка менавіта гэта. Вы павінны навучыць Clang, што гэта з'яўляецца шляхам вызначэння функцыі першага. Пасля гэтага вы можаце выкарыстоўваць яго. Але, шчыра кажучы, гэта адчувае як слізкага. 

Так што кожны раз, калі я бягу ў праблему, я проста збіраецца вылучыць і скапіяваць код Я напісаў, выразаць яго і ўставіць яго сюды. І, вядома, мы маглі б злаўчыцца некаторыя сцэнары дзе адна функцыя можа трэба патэлефанаваць іншаму. І вы проста не можаце змясціць кожны функцыя вышэй любы іншы. 

Так атрымліваецца, што ёсць лепшае рашэнне. Мы можам пакінуць гэта быць. І, шчыра кажучы, гэта наогул прыемна, і зручна, і добры дызайн паставіць галоўны па-першае, таму што, зноў жа, Галоўным жа, як калі зялёны сцяг пстрыкнуў, то ёсць функцыя, запускаецца на выкананне па змаўчанні. Такім чынам, вы можаце таксама змясціць яна ў верхняй часткі файла так што, калі вы або любы іншы чалавек глядзіць на файл Вы ведаеце, што адбываецца проста прачытаўшы галоўны першы. Так што атрымліваецца, мы можам сказаць Clang проактивно, эй, Clang, на чацвёртым радку, Я абяцаю рэалізаваць функцыя называецца Print Імя, якое прымае радок называецца імя у якасці ўваходных дадзеных і вяртае нічога, пустата. І я абысці рэалізацыі яго пазней. 

Тут прыходзіць Main. Галоўнае зараз у радку 9 можна выкарыстоўваць Друк імя, таму што Clang хто спадзяецца, што, у рэшце рэшт, яна будзе сутыкацца з вызначэннем ажыццяўлення друку Назва. Такім чынам, пасля захавання мой файл, хай мне ісці наперад і зрабіць прататып, выглядае добра на гэты раз. Дот слэш, прататып, дазвольце мне ісці наперад і ўвесці імя. Дэвід, прывітанне David, Zamila, прывітанне Zamila, і, на самай справе, цяпер ён працуе. 

Такім чынам, кампанент тут з'яўляецца тое, што мы ў зрабіў карыстацкую функцыю, як звычай Драпіна блок мы называем яго. Але ў адрозненне ад нуля, дзе вы можаце проста стварыць яго і пачаць выкарыстоўваць яго, Зараз мы павінны быць трохі больш педантычным, і на самай справе цягнік Clang выкарыстоўваць, ці чакаць яго. Цяпер, як у бок, чаму ўвесь гэты час мы былі проста слепа на веру, уключаючы CS50.h, і ў тым ліку стандартных io.h? 

Што ж, атрымліваецца, сярод некалькіх іншых рэчаў, усё, што ў гэтых кропак ч файлы, якія, здараецца, файлы. Яны файлы загалоўкаў, так бы мовіць. Яны па-ранейшаму напісаны на C. Але яны іншы тып файла. 

На дадзены момант, вы можаце ў значнай ступені выказаць здагадку, што ўсё, што знаходзіцца ўнутры CS50.h гэта некаторыя жартамі, як гэта, не для функцый, выкліканых друку Імя, але для атрымання радкі, атрымаць Паплавок, і некалькі іншых. І ёсць падобныя прататыпы, лайнеры, ўнутры стандартнага io.h для Printf, які цяпер знаходзіцца ў мая ўласная функцыя друку Імя. Такім чынам, іншымі словамі, увесь гэты час мы ў проста слепа капіюючы і ўстаўляючы ўключыць гэта, ўключаюць у сябе што, што адбываецца? Гэта проста выгляд падказак звінець адносна таго, што функцыі якія, сапраўды, рэалізаваны, проста у іншых месцах у розных файлах у іншым месцы ў сістэме. 

Такім чынам, мы рэалізавалі імя друку. У яго ёсць гэты пабочны эфект друк што-то на экране. Але гэта не на самай справе перадаць мне што-небудзь. Як мы ісці аб рэалізацыі праграмы, якая гэта перадаць мне што-небудзь? 

Што ж, давайце паспрабуем гэта. Дазвольце мне ісці наперад і рэалізаваць файл з імем return.c так што мы можам паказаць, як нешта як атрымаць радок, або атрымаць Int, на самай справе вяртанне нешта назад карыстальніку. Давайце ісці наперад і вызначыць Int асноўную пустэчу. 

І, зноў жа, у будучыні, мы будзем растлумачыць, што гэта Int і гэтую пустэчу на самой справе робіць. Але на сённяшні дзень, мы будзем прымаюць гэта як належнае. Я збіраюся ісці наперад і Printf, для добрага карыстацкага досведу, х. А потым я буду чакаць Карыстальнік, каб даць мне х з GET Int. 

А потым я збіраюся ісці наперад і раздрукаваць х на плошчу. Таму, калі ў вас ёсць толькі клавіятура, людзі часта выкарыстоўваць маленькую моркву сімвал на клавіятуры прадстаўляць да ўлады з, або паказчык. Так што х у квадраце прысутнічае я. 

А цяпер я збіраюся зрабіць гэта. Я мог бы проста do-- што х у квадраце? х у квадраце х раз х. 

І мы зрабілі гэта некаторыя даўно ўжо сёння. Гэта не падобна усё, што значны прагрэс. Вы ведаеце, што? Давайце выкарыстоўваць некаторыя з гэтай ідэі ад апошняга часу абстракцыі. 

Не было б добра, калі ёсць функцыя, званая квадрат, які робіць менавіта гэта? Ён па-ранейшаму, у канцы дзень, робіць тое ж матэматыку. Але давайце абстрактныя прэч ідэя ўзяцця адно лік, памножанае на іншы, а проста даць яму імя, як квадрат гэта значэнне. 

І, іншымі словамі, у C, давайце створым функцыю называецца квадрат, які робіць менавіта гэта. Гэта будзе называцца квадрат. Ён збіраецца прыняць Int. І мы будзем проста называць яго п, па змаўчанні. 

Але мы маглі б назваць гэта ўсё, што мы хочам. І ўсё, што ён збіраецца рабіць, у літаральным сэнсе, з'яўляецца вяртанне вынік п раз п. Але так як гэта вяртаючы нешта, што з'яўляецца ключавым словам у фіялетавы мы ў ніколі не бачыў раней, я, у радку 11, не можа проста сказаць, пустата на гэты раз. 

Пустата, у прыкладзе, які мы толькі што бачылі а назвы друку, проста азначае, зрабіць што-то. Але не дай мне што-небудзь. У гэтым выпадку, я хачу для вяртання ў п раз п, або незалежна ад таго, што ёсць, гэта лік. 

Так што я не магу сказаць, эй, кампутар, Я не вярнуся нічога, пустата. Гэта збіраецца вярнуцца, па сваёй прыродзе, у Int. І так, што гэта ўсё, што тут адбываецца. 

Уваход на плошчу збіраецца быць инт. І так, што мы можам выкарыстоўваць яго, ён павінен ёсць імя, N. Гэта збіраецца выводзіць INT, які не трэба імя. Мы можам пакінуць яго на галоўную, або той, хто выкарыстоўваючы мяне, каб памятаць гэта значэнне, калі мы хоча са сваёй уласнай зменнай. 

І, зноў жа, толькі новы Ключавое слова тут Return. І я проста раблю некаторыя матэматыцы. Калі б я сапраўды хацеў быць непатрэбным, Я мог бы сказаць INT прадукт атрымлівае п раз п. 

І тады я мог бы сказаць, вярнуць прадукт. Але, зноў жа, да маёй кропцы раней з гэта проста не быць добрым design-- як, навошта ўводзіць імя, сімвал, як прадукт, проста неадкладна вярнуць яго? Гэта трохі чысцей, крыху больш жорстка, так казаць, проста сказаць, вяртанне п раз п, каб пазбавіцца ад гэтай лініі ў цэлым. 

І гэта як раз менш кода, каб чытаць, менш магчымасцяў для памылак. І давайце паглядзім, калі гэта на самай справе ў цяперашні час працуе. Зараз, я збіраюся пайсці наперад і зрабіць вяртанне. 

Ой-ой, невідавочнае аб'яву функцыі. Я зрабіў гэтую памылку раней, не склала вялікай працы. Дазвольце мне проста надрукаваць, або вылучыць і скапіяваць, сапраўды такі жа прататып функцыі, або подпісы, функцыі тут. Ці я мог бы перамясціць ўсю функцыю. 

Але гэта крыху лянівы. Такім чынам, мы не будзем гэтага рабіць. Зараз, дазвольце мне зрабіць вяртанне зноў жа, кропка вяртання касой рысы. 

х у квадраце 2. х 4. х квадрат 3. х 9. І функцыя здаецца Зараз, каб працаваць. Так якая розьніца тут? У мяне ёсць функцыя, якая называецца квадрат, у гэтым выпадку, які я паставіў у якасці ўкладу. І я атрымліваю назад выхад. І тым не менш, раней, калі Я адкрываю іншы прыклад ад раней, што быў названы prototype.c, У мяне было імя друку, які вярнуўся несапраўдным, калі можна так выказацца, Ці гэта ня даў нічога, і проста меў пабочны эфект. 

Дык што ж тут адбываецца? Што ж, разгледзім функцыю атрымаць радок на імгненне. Мы выкарыстоўваем функцыю атрымаць радок наступным чынам. 

У нас было функцыя атрымаць радок, як уключаць CS50.h, ўключаюць у сябе стандартныя io.h, INT, асноўны, несапраўдным. І тады кожны раз, калі я называецца атрымання радкі да гэтага часу, Я сказаў нешта накшталт, радок s атрымлівае атрымаць радок, таму што string-- Get давайце назавем гэтую get.c-- радок GET сама вяртае радок, я магу потым выкарыстоўваць, і сказаць, прывітанне, коска, адсоткаў s, зваротная касая п, в е. 

Так што гэта той жа самы прыклад, на самай справе, што ў нас было раней. Так што радок вяртае значэнне. Але імгненне таму, радок для друку не вяртае значэнне. Ён проста мае пабочны эфект. Так што гэта прынцыповая розніца. Мы бачылі розныя тыпы функцый у цяперашні час, некаторыя з якіх вярнуліся значэння, некаторыя з якіх не робяць. Так можа быць, гэта радок, або INT, або з якая плавае кропкай. Ці, можа быць, гэта проста пустэча. 

І розніца што гэтыя функцыі, атрымаць дадзеныя і вяртае значэнне, на самай справе у выніку чаго-то назад да стала, так бы мовіць. Так што давайце ісці наперад і глядзець на адзін канчатковы набор прыкладаў, што дае адчуванне, цяпер, як мы маглі б, на самай справе, абстрактныя лепш, і лепш, і лепш, або больш, і больш, і больш, для таго, пісаць, у канчатковым рахунку, лепшы код. Давайце ісці наперад, і ў духу скрэтч, зрабіце наступнае. 

Дазвольце мне ісці наперад і ўключаюць у сябе CS50.h і стандарт IO.h. Дазвольце мне ісці наперад і даць я INT, галоўным чынам, пустата. І дазвольце мне ісці наперад, называем гэта cough.c. 

І дазвольце мне ісці наперад і проста як драпіна, раздрукаваць кашаль / п. І я хачу зрабіць гэта тры разы. Так што я, вядома, проста збіраецца скапіяваць і ўставіць тры разы. Я зараз збіраюся зрабіць кашаль кропка слэш кашаль. Давайце дамо сабе трохі больш месцы тут, Enter, кашаль, кашаль, кашаль. 

Там у, відавочна, ужо магчымасць для паляпшэння. Я скапіяваў і ўставіў некалькі разоў сёння. Але гэта было толькі таму я не зрабіў павінны набраць столькі знакаў. Я да гэтага часу змянілася, што гэтыя радкі кода. 

Гэтыя тры лініі ідэнтычныя, які адчувае сябе гультаяватым і на самай справе ёсць, і, верагодна, не правільны падыход. Так з якой інгрэдыент мы маглі б палепшыць гэты код? Мы не павінны капіяваць код. 

І сапраўды, у любы час вы адчуваеце самастойна капіявання і ўстаўкі, і нават не змяняючы код, Шанцы ёсць лепшы спосаб. І, сапраўды, ёсць. Дазвольце мне ісці наперад і зрабіць цыкл, нават пры тым, што сінтаксіс не можа прыходзяць, натуральна, пакуль няма. 

Зрабіце гэта тры разы, проста , Робячы following-- і я ведаю гэта з практыкі. Але ў нас ёсць шэраг прыкладаў, у цяперашні час. І вы ўбачыце онлайн больш спасылак да гэтага часу. 

Гэта сінтаксіс ў радку 6, што гэтак жа, як нуля, які паўтараецца блок, паўторыце наступныя тры разы. Гэта крыху чароўны цяпер. Але гэта будзе атрымаць больш, і больш знаёмым. 

І гэта будзе паўтарацца лінія восем тры разы, так што калі я перекомпилирует макіяж кашаль, кропка слэш кашаль, кашаль, кашаль, кашаль. Ён па-ранейшаму працуе сапраўды гэтак жа. Так што гэта ўсё выдатна і добра. Але гэта не вельмі абстрактна. 

Гэта зусім правільна. Але ён адчувае, як там можа быць магчымасць, як і ў свеце Драпіны, каб выгляд старту каб дадаць некаторую семантыку тут, так што Я не проста нейкі цыкл, і функцыя, якая кажа кашаль, ці ж кашаль. Вы ведаеце, што? Дазвольце мне быць трохі халадней, чым, і на самай справе напісаць функцыю, якая мае некаторыя пабочныя эфекты, называюць яго кашаль. 

І гэта не мае ніякага ўводу і не вяртае значэння ў якасці высновы. Але вы ведаеце, што ён робіць? Ён робіць this-- Printf, цытата Unquote, кашаль. 

І цяпер тут, я збіраюся ісці наперад і для Int, я атрымлівае нуль, я менш, чым 3, я плюс плюс. Я збіраюся не рабіць Printf, што магчыма, рэалізацыя нізкага ўзроўню падрабязна. Мяне не хвалюе, як кашаль. Я проста хачу, каб выкарыстоўваць функцыю ад кашлю. І я проста буду называць кашаль. 

Зараз звернеце ўвагу на дыхатаміі. Пры выкліку функцыі, калі вы гэтага не зробіце хочуць, каб даць яму ўваходы, цалкам нармальна. Проста зрабіце адкрытыя дужка, блізка дужка, і вы зрабілі. 

Пры вызначэнні функцыі, або абвясціць прататып функцыі ва, калі вы загадзя ведаеце, гэта не збіраецца прымаць якія-небудзь аргументы, кажуць, пустата ў гэтых дужках там. І гэта гарантуе, што вам не выпадкова няправільнага звароту з ім. Дазвольце мне ісці наперад і зрабіць кашаль. І, вядома ж, я зрабіў памылку. 

Праклён, ёсць тое, што невідавочнае аб'яву. Але гэта нармальна. Гэта лёгка выправіць. Мне проста трэба прататып вышэй ў маім файле, чым я на самой справе выкарыстаць яго. 

Так што цяпер дазвольце мне зрабіць кашаль зноў, прыемна. Цяпер яна працуе. Зрабіць кашаль, кашаль, кашаль, кашаль. Такім чынам, вы можаце падумаць, што мы на самай справе крыху больш за інжынерных гэтую праблему. І сапраўды, мы. Гэта не вельмі добрая кандыдат праграмы на дадзены момант для рэфактарынгу, і рабіць тое, што называецца іерархічнае разлажэнне, дзе вы бераце нейкі код, а затым вы, здаецца, фактару рэчы, так што, як прыпісваць больш семантыкі да іх, і выкарыстоўваць яго ў канчатковым рахунку, больш працяглы тэрмін. Але гэта будаўнічы блок у бок больш складаныя праграмы што мы пачнем пісьмовай форме да таго часу, што дазваляе нам мець слоўнікавы запас з якой лепш пісаць код. І сапраўды, давайце паглядзім, калі мы не можа абагульніць гэта далей. 

Гэта здаецца трохі кульгае, што я, галоўным чынам, трэба турбавацца пра гэта цыраваць для цыклу, і выклікаючы кашаль зноў і зноў. Чаму я не магу проста сказаць кашаль, калі ласка, кашаль ў тры разы? Іншымі словамі, чаму я не магу проста даюць ўклад у кашаль і зрабіць гэта? 

Чаму я не магу проста сказаць, у Асноўны кашаль у тры разы. І зараз, гэта свайго роду магічнае. Гэта вельмі ітэрацыйныя тут. І гэта, сапраўды, крок дзіцяці. 

Але толькі здольнасць гаварыць на лінія восем, кашаль у тры разы, гэта проста так значна больш зручным для чытання. І, плюс, я не павінен ведаць ці ўсё роўна, як ажыццяўляецца кашаль. І сапраўды, пазней у тэрмін і для канчатковых праектаў, калі вы вырашаць праект з аднакласнік ці два аднакласнікі, вы зразумееце, што вы збіраецеся павінны, або хочаце, падзяліць працу. 

І вы будзеце жадаць, каб вырашыць, загадзя, хто будзе рабіць тое, што, і ў якія часткі? І не было б прыемна калі вы, напрыклад, ўзяць на сябе адказнасць напісання галоўным чынам, зроблена. А ваш сусед па пакоі, ці ваш партнёр у больш агульным плане, клапоціцца аб рэалізацыі кашаль. 

І гэта падзел, гэтыя сцены абстракцыі, або пласты абстракцыі калі вы, супер магутны, таму што асабліва для вялікіх, больш складаныя праграмы і сістэмы, яна дазваляе некалькім людзям будаваць ўсе разам, і ў канчатковым рахунку пашыць іх сумесную працу такім чынам. Але, вядома, мы трэба выправіць прама зараз кашаль. Мы павінны сказаць кашаль што, эй, вы ведаеце, што? Вы будзеце мець патрэбу, каб узяць input-- таму не пустата, а INT і цяпер. Давайце ісці наперад і пакласці ў кашаль ИНТ. я атрымлівае нуль. 

я менш, чым у колькі разоў. Я сказаў тры раней. Але гэта не тое, што я хачу. Я хачу, каб кашаль быць абагульненая падтрымліваць любую колькасць ітэрацый. 

Так што, на самай справе, гэта п, што я хачу, усё, што карыстальнік кажа мне. Цяпер я магу ісці наперад і сказаць друку кашаль. І незалежна ад таго, які нумар карыстальнік пераходзіць у, Я буду паўтараць, што ў шмат разоў. 

Такім чынам, у рэшце рэшт, Праграма ідэнтычная. Але зьвярніце ўвагу на ўсе гэтыя рэчы можа быць нават у іншым файле. На самай справе, я не ведаю, на Момант, як Printf рэалізуецца. 

Я не ведаю, на дадзены момант, як атрымаць радок, або атрымаць Int, або атрымаць з якая плавае кропкай рэалізуюцца. І я не хачу ўбачыць іх на маім экране. Як гэта, я пачынаю засяродзіцца на мая праграма, а не тыя функцыі. 

І так, на самай справе, як толькі вы пачаць факторынгу код, як гэта, мы маглі б нават рухацца кашаль у асобны файл? Нехта іншы мог бы ажыццявіць гэта. І вы і ваша праграма стала вельмі прыгожы, і вельмі лёгка чытаюцца, магчыма, на самой справе чатыры лініі праграмы прама там. 

Так што давайце ісці наперад прама цяпер і зрабіць яшчэ адно змяненне. Звярніце ўвагу на тое, што мой прататып павінен змяніцца да вяршыні. Такім чынам, дазвольце мне выправіць што так Я не атрымліваю крычаў на. 

Зрабіць кашаль, дазвольце мне бегчы кашаль адзін раз Больш за тое, па-ранейшаму робіць тое ж самае. Але цяпер, заўважце, мы маем інгрэдыент для адной канчатковай версіі. Вы ведаеце, што? Я не хачу, каб проста кашаль, абавязкова. Я хачу мець нешта больш агульнае. Такім чынам, вы ведаеце, што? Я хачу, каб гэта зрабіць. Я хачу мець, гэтак жа, як нуля робіць, блок скажам, але не толькі сказаць нешта некаторы колькасць разоў. Я хачу сказаць, вельмі канкрэтную радок. І, такім чынам, я не хачу, каб проста сказаць, кашаль. Я хачу сказаць, што б ні радок перадаецца ст. 

Таму звярніце ўвагу, я абагульніў гэта так, што ў цяперашні час скажам адчувае сябе добрае імя для гэтага, як нуля, прымае два аргументу, у адрозненне ад нуля. Адным з іх з'яўляецца радком. Адным з іх з'яўляецца Int. 

І я мог пераключацца паміж імі. Я проста накшталт як ідэя кажуць радок, а затым колькі раз пазней. Пустата азначае, што ён да гэтага часу нічога не вяртае. Гэта толькі візуальная бок эфекты, як з [? Джордан ,?] слоўнае пабочны эфект гарлапаніць. Ён па-ранейшаму робіць нешта п раз, 0 да, але не роўна п. Гэта азначае, што агульны час п. А потым проста раздрукаваць што б гэта ні радок. Так што я сапраўды абагульненая гэты радок кода. Так што цяпер, як я магу рэалізаваць функцыя ад кашлю? 

Я магу зрабіць несапраўдным кашаль. І я ўсё яшчэ магу ўзяць у тым, шмат разоў вы хочаце, каб кашаль. Але вы ведаеце, што? Цяпер я магу сказаць, Пунт. 

Я магу патэлефанаваць сказаць з слова кашаль, пераходзячы ў п. І калі я хачу таксама ажыццявіць, проста для задавальнення, функцыя чханне, Я магу чханне некаторы колькасць разоў. І я магу шматкроць выкарыстоўваць п, таму што звярніце ўвагу, што т у дадзеным кантэксце або аб'ёму існуе толькі ўнутры гэтай функцыі. 

І п ў гэтым кантэксце толькі існуе ў рамках гэтай функцыі тут. Такім чынам, мы вернемся да гэтыя пытанні сферы. І вось, я проста хачу сказаць, Achoo, а затым п раз, кропка з коскі. 

А цяпер, мне проста трэба заняць гэтыя функцыі подпісы тут. Так што кашаль з'яўляецца правільным. Пустата чых зараз выкарыстоўваюцца правільныя. 

І я да гэтага часу проста трэба сказаць. Так што я буду казаць, скажам радок s, Int N, кропка з коскі. Такім чынам, я празмерна спраектавалі чорт з гэтай праграмы. 

І гэта не абавязкова азначае, што гэта што вы павінны зрабіць пры напісанні нават самыя простыя праграмы. Вазьміце нешта, што, відавочна, вельмі проста, вельмі кароткі, і паўторна рэалізаваць яго выкарыстоўваючы занадта шмат кода. Але вы на самой справе бачыце, і ў час азірнуцца назад на гэтых прыкладах, і ўсвядоміць, о, гэта тыя крокі мы ўзялі на самай справе абагульняць, фактар ​​нешта, да таго часу, пакуль у канцы дня мой код на самай справе даволі разумна. Таму што, калі я хачу, каб кашаль тры раз затым чхнуць тры разы, Я проста збіраюся запусціць паўторна, Праграма робіць кашаль, і запусціць кашаль. І ў мяне ёсць тры кашляе і тры чхае. 

І так гэта асноўнай парадыгма, калі вы будзеце, за тое, як мы маглі б ісці аб на самай справе рэалізацыі праграмы. Але давайце проста паглядзім, што зараз гэта мы робім ўвесь гэты час, і тое, што некаторыя з заключных частак ззаду гэтай простай каманды. У рэшце рэшт, мы выкарыстоўвалі Clang ў якасці нашага кампілятара. Мы пісалі крыніца код, ператвараючы яго з дапамогай Clang ў машынны код. 

І мы выкарыстоўваем толькі зрабіць каб палегчыць нашы націску клавіш так што мы не павінны памятаць, гэтыя заклінанні самага Clang. Але што гэта зрабіць на самай справе рабіць? І, у сваю чаргу, з'яўляецца тое, што Clang на самай справе рабіць? 

Аказваецца, хоць мы спрасцілі сённяшняе абмеркаванне, сказаўшы, вы бераце зыходны код, перадаць яго ў якасці уваход кампілятара, які дае вам выхад машыны код, аказваецца, ёсць некалькі розных крокаў ўнутры там. І компилирование здараецца парасон тэрмін для цэлага шэрагу крокаў. Але давайце проста дражніць на гэта вельмі хутка. 

Аказваецца, што мы робім больш рэчаў, кожны раз, калі я запусціць праграму, або кожны раз, калі я скампіляваць праграму сёння. Такім чынам, папярэдняя апрацоўка ставіцца да this-- нічога ў праграме C, як мы ўбачым зноў і зноў, які пачынаецца з гэтай хэш-сімвала, або сімвал Хештег тут, азначае, гэта дырэктыва препроцессора. Гэта азначае, што, у дадзеным выпадку, эй кампутар, зрабіць што-то з гэтай старонкай перш чым вы на самой справе скампіляваць мой уласны код. 

У гэтым выпадку, хэш ўключаюць ёсць, па сутнасці, шлях C спосаб сказаць, эй кампутар, перайдзіце атрымаць змесціва з CS50.h і ўставіць іх тут. Эй кампутар, пайсці атрымаць ўтрыманне стандартнага io.h, ўсюды, дзе гэта знаходзіцца на жорсткі дыск, уставіць яго тут. Так што гэтыя рэчы здараюцца спачатку падчас папярэдняй апрацоўкі. 

І Clang робіць усё гэта для нас. І гэта робіць гэта так цыраваць хутка, вы нават не убачыць чатыры розных рэчаў адбываецца. Але гэта першы такі крок. 

Што на самой справе адбываецца далей? Ну, наступны афіцыйны крок кампіляцыі. І атрымліваецца, што складанне праграмы тэхнічна азначае пераход ад зыходны код, то матэрыял, які мы пісаў сёння, да чаго-то называецца код зборкі, нешта што выглядае некалькі інакш. 

І на самай справе, мы можам бачыць гэта вельмі хутка. Дазвольце мне на самай справе пайсці ў мой IDE. Дазвольце мне ісці наперад і адкрыць hello.c, які самая першая праграма, з якой мы пачаўся сёння. І дазвольце мне ісці наперад і запусціць Clang A крыху па-іншаму, Clang-s, hello.c, якая на самой справе збіраецца дайце мне яшчэ адзін файл hello.s. 

І мы, верагодна, ніколі зноў убачыць гэты від кода. Калі ўзяць больш нізкі ўзровень Сістэмы класа, як CS61, вы ўбачыце нашмат больш з такога кода. Але гэта мова зборкі. Гэта X86 асэмблеры што працэсар, які ляжыць у аснове CS50 IDE на самой справе разумее. 

І загадкава, як гэта робіць глядзіце, гэта нешта кампутар разумее вельмі добра. Sub кв, гэта вычытаць. Там у рух. 

Там тэлефануе функцый тут, х ORing, рух, надбудова, поп, вяртанне. Так што ёсць нейкая вельмі інструкцыі нізкага ўзроўню што працэсары разумеюць, што Я згадваў раней. Гэта значыць тое, што Intel Inside. 

ёсць мадэлі нулі і адзінкі, што супаставіць гэтыя arcanely фармулёўку, аднак некалькі добра імя, інструкцыі, так бы мовіць. Гэта тое, што адбываецца, калі кампіляцыі кода. Вы атрымліваеце зборкі мова з яго, які азначае, трэці крок заключаецца ў зборцы што код зборкі ў канчатковым рахунку, машына code-- нулі і адзінкі, а не тэкст, які мы толькі што бачылі хвіліну таму. 

Такім чынам, папярэдняя апрацоўка робіць, што знайсці і замяніць, і некалькі іншых рэчаў. Кампіляцыя прымае ваш крыніца кода з C, зыходны код што мы ўжо пісалі, у зборы код, які мы толькі што паглядзеў на. Зборка займае гэтую зборку код нулёў і адзінак што працэсар сапраўды будзе зразумець, у канцы працоўнага дня. І звязванне з'яўляецца апошнім крокам што адбываецца з-за us-- зноў, так хутка мы не робім нават notice--, што кажа, эй кампутар, узяць усё нулі і адзінкі, якія у выніку кампіляцыі кода Давіда, і яго асноўнай функцыяй ў гэтым выпадку. 

І эй кампутар, ідзі усе нулі і адзінкі што супрацоўнікі CS50 пісаў ўнутры бібліятэкі CS50. Змяшайце тыя, з Дэвіда. І эй кампутар, пайсці атрымаць усе нулі і тыя, што нехта напісаў некалькі гадоў таму для Printf. І дадаць такіх прылад у Усё гэта, так што мы атрымаў мае нулі і адзінкі, тым нулі і адзінкі персанале CS50, у то PRINTF нулі і адзінкі, і ўсё астатняе, што мы выкарыстоўваем. 

Усе яны атрымліваюць аб'яднаны ў адну Праграма пад назвай, у дадзеным выпадку, прывітанне. Так што з гэтага часу мы будзем проста выкарыстоўваць слова кампіляцыі. І мы лічым само сабой якія разумеюцца, што, калі мы кажам, скампіляваць праграму, то гэта азначае, эй рабіць папярэднюю апрацоўку, мантаж і сувязь. Але ёсць на самай справе некаторыя сакавітыя рэчы там адбываецца пад капотам. І асабліва калі вы атрымаць цікавую некаторы час, вы можаце пачаць тыкаць вакол на гэтым больш нізкім узроўні. Але цяпер разумею, што сярод на сённяшні дзень ежы на дом даволі проста пачатак працэсу, атрымання камфортна нешта накшталт прывітанне свет. Сапраўды, вялікая частка таго, што мы зрабілі сёння вядома ж, не будзе тануць у супер хутка. І гэта зойме некаторы час, і некаторыя практыкі. І шанцы, вы будзеце сартаваць ад таго, хочуць стукнуць клавіятуры ці крычаць на экране. І ўсё гэта нармальна. Хоць, магчыма, стараюся не зрабіць гэта ў бібліятэцы так шмат. 

І ў канчатковым рахунку, вы будзеце быць у стане, хоць, каб пачаць бачачы карціны, як у добрым кодзе што вы напісалі і ў памылках што вы зрабілі. І гэтак жа, як працэс стаўшы TF або СА, як, вы пачнеце станавіцца ўсё лепш і лепш бачыць гэтыя мадэлі, і проста вырашэння вашых ўласныя праблемы ў канчатковым рахунку. У той жа час, там будзе шмат з нас, каб аказаць вам падтрымку, і вы атрымаеце праз гэта. А ў запісе вокны для ўсіх праблем, вы будзеце кіравацца праз усе каманды што я, вядома, ведаю, з шмат практыкі ў цяперашні час, але, магчыма, прыляцеў над галавой на дадзены момант. І гэта цалкам нармальна. 

Але, у канчатковым рахунку, вы збіраецеся каб пачаць бачыць заканамернасці. І як толькі вы прайсці ўсе з тупыя дэталі, такія як круглыя ​​дужкі, і фігурныя дужкі і кропкі з коскай, і рэчы, шчыра кажучы, што не на ўсіх інтэлектуальна цікавым. І гэта не мэта прымаючы любы ўводны клас. Гэта ідэі, якія ідуць да матэрыі. 

Гэта завесы, і умоў, а таксама функцыі, і больш магутна абстракцыя, і факторынгавыя кода, і добры дызайн, і добрае стыль, і ў канчатковым рахунку правільнасць вашага кода, што ў канчатковым рахунку збіраецца мець значэнне больш за ўсё. Так што на наступным тыдні, мы будзем прымаць гэтыя ідэі, якія мы ўпершыню ўбачылі ў пустым месцы і цяпер пераведзеныя да C. І мы пачнем ўвесці першы з рэальнага свету дамены курса. 

Мы засяродзімся на свет бяспекі, і больш канкрэтна крыптаграфія, мастацтва караскацца інфармацыі. І ў ліку першых праблемы вы самі атрымаеце пісаць далей гуляючы з некаторымі з сінтаксісу і вырашаючы некаторыя лагічныя праблемы, у канчатковым рахунку, у хуткім часе, гэта на самай справе засакрэціць, або зашыфраваць, і ў канчатковым рахунку расшыфраваць інфармацыю. І ўсё, што мы зрабілі сёння, будзе дастаткова нізкім ўзровень, толькі збіраецца, каб дазволіць нам ўзяць адзін, і адзін, і яшчэ адзін крок у бок вышэй напісанне самы цікавы код яшчэ. 

Так што больш на гэта на наступным тыдні. 

[ВИДЕОВОСПРОИЗВЕДЕНИЕ] 

Што вы можаце расказаць мне аб ў апошні раз вы бачылі яго? -Што Я магу сказаць, на самай справе? Я маю на ўвазе, гэта было як і любы іншы падрыхтоўка вытворчасці рэпетыцыя, за выключэннем таго, што нешта было, ён сказаў: у самым канцы, што затрымаўся са мной. 

-Гэта Быў CS50. 

-вот Выразаць усе, выдатная праца на рэпетыцыі. 

абед -Вось? 

-Так, Ты і я магу захапіць бутэрброд няшмат. Дазвольце мне проста апытваць з Дэвід вельмі хутка. Дэвід? Дэвід? 

[КАНЕЦ засьпяваю] 