1
00:00:00,000 --> 00:00:00,000

2
00:00:00,000 --> 00:00:00,000
[เสียงเพลง]

3
00:00:00,000 --> 00:00:13,950

4
00:00:13,950 --> 00:00:16,240
>> เดวิดเจลันสิทธิทั้งหมดนี้เป็น CS50

5
00:00:16,240 --> 00:00:18,010
และนี่คือหนึ่งสัปดาห์

6
00:00:18,010 --> 00:00:22,050
ดังนั้นจำได้ว่าครั้งสุดท้ายในสัปดาห์ที่ศูนย์
เรามุ่งเน้นการคิดคำนวณ

7
00:00:22,050 --> 00:00:25,440
และเราเปลี่ยนจากการที่
เริ่มต้นเขียนโปรแกรมกราฟิก

8
00:00:25,440 --> 00:00:27,360
ภาษาจากเพื่อนของเรา
ที่ MIT Media Lab ของ

9
00:00:27,360 --> 00:00:31,730
>> และมีรอยขีดข่วนเราไม่สำรวจ
ความคิดเช่นฟังก์ชั่นและเงื่อนไข

10
00:00:31,730 --> 00:00:35,210
และลูปและตัวแปรและแม้กระทั่ง
เหตุการณ์และกระทู้, และอื่น ๆ

11
00:00:35,210 --> 00:00:37,880
และวันนี้เรากำลังจะไป
ยังคงใช้ความคิดเหล่านั้น

12
00:00:37,880 --> 00:00:40,630
และจริงๆพวกเขาสำหรับการ
รับ แต่แปลพวกเขา

13
00:00:40,630 --> 00:00:44,220
ภาษาอื่นที่รู้จักในฐานะซีตอนนี้
C เป็นภาษาดั้งเดิมมากขึ้น

14
00:00:44,220 --> 00:00:46,020
มันเป็นระดับที่ต่ำกว่า
ภาษาถ้าคุณจะ

15
00:00:46,020 --> 00:00:47,300
>> มันเป็นเรื่องเกี่ยวกับใจอย่างหมดจด

16
00:00:47,300 --> 00:00:49,910
และอื่น ๆ ได้อย่างรวดเร็วก่อนมัน
ทุกคนจะต้องมองที่ค่อนข้างคลุมเครือ

17
00:00:49,910 --> 00:00:51,430
ถ้าคุณไม่เคยตั้งโปรแกรมก่อน

18
00:00:51,430 --> 00:00:53,530
เรากำลังจะมี
กึ่งทวิภาคและวงเล็บ

19
00:00:53,530 --> 00:00:55,150
และวงเล็บปีกกาและอื่น ๆ

20
00:00:55,150 --> 00:00:57,240
แต่ตระหนักว่าแม้
แม้ว่าไวยากรณ์คือ

21
00:00:57,240 --> 00:01:00,600
เกี่ยวกับการที่จะดูเล็ก ๆ น้อย ๆ ที่ไม่คุ้นเคย
ส่วนใหญ่ของคุณให้ดูที่ผ่านมาว่า

22
00:01:00,600 --> 00:01:03,220
และพยายามที่จะเห็นความคิด
ที่มีความจริงที่คุ้นเคย

23
00:01:03,220 --> 00:01:06,750
เพราะที่นี่ในสัปดาห์หนึ่งสิ่ง
เราจะเริ่มต้นที่จะทำคือการเปรียบเทียบ

24
00:01:06,750 --> 00:01:08,980
แรกรอยขีดข่วนเมื่อเทียบกับซี

25
00:01:08,980 --> 00:01:12,350
>> ดังนั้นสำหรับตัวอย่างเช่นจำได้ว่าเมื่อเรา
การดำเนินการครั้งแรกของโปรแกรมของเรา

26
00:01:12,350 --> 00:01:16,220
ครั้งสุดท้ายที่เรามีบล็อกที่มอง
บางสิ่งบางอย่างเล็ก ๆ น้อย ๆ เช่น this-- เมื่อ

27
00:01:16,220 --> 00:01:19,990
ธงสีเขียวคลิกแล้วเรามี
หรือมากกว่าหนึ่งชิ้นส่วนปริศนาด้านล่างมัน

28
00:01:19,990 --> 00:01:22,150
ในกรณีนี้การพูด, Hello World

29
00:01:22,150 --> 00:01:24,870
ดังนั้นแท้จริงในเกา
เมื่อฉันคลิกที่ธงสีเขียว

30
00:01:24,870 --> 00:01:27,390
เพื่อเรียกใช้โปรแกรมของฉันดังนั้น
ที่จะพูดเหล่านี้เป็น

31
00:01:27,390 --> 00:01:29,520
บล็อกที่ได้รับการดำเนินการหรือเรียกใช้

32
00:01:29,520 --> 00:01:32,230
และโดยเฉพาะรอยขีดข่วน
กล่าวว่า Hello, world

33
00:01:32,230 --> 00:01:35,377
>> ตอนนี้ฉันจะได้ระบุไว้
คำพูดที่แตกต่างกันที่นี่

34
00:01:35,377 --> 00:01:37,960
แต่เราจะเห็นว่าจริง ๆ อีกมากมาย
ของ blocks-- เหล่านี้และแน่นอน

35
00:01:37,960 --> 00:01:41,880
ใน C functions-- จำนวนมากสามารถ
parametrized หรือที่กำหนดเอง

36
00:01:41,880 --> 00:01:43,150
ที่จะทำสิ่งที่แตกต่างกัน

37
00:01:43,150 --> 00:01:45,520
ในความเป็นจริงใน C ถ้าเรา
ต้องการแปลงตอนนี้

38
00:01:45,520 --> 00:01:47,567
โปรแกรม Scratch นี้
ภาษาอื่น ๆ นี้

39
00:01:47,567 --> 00:01:49,650
เรากำลังจะเขียน
บางสิ่งบางอย่างเล็ก ๆ น้อย ๆ เช่นนี้

40
00:01:49,650 --> 00:01:52,540
>> จริงอยู่ที่มีบางที่ไม่คุ้นเคย
ไวยากรณ์มีแนวโน้มมากที่สุด, int,

41
00:01:52,540 --> 00:01:54,380
และวงเล็บและถือเป็นโมฆะ

42
00:01:54,380 --> 00:01:57,740
แต่ printf-- แม้ว่าคุณจะ
คิดว่ามันก็จะพิมพ์

43
00:01:57,740 --> 00:02:00,120
แต่หมายถึงการพิมพ์การพิมพ์
รูปแบบที่เราจะเห็นทันที

44
00:02:00,120 --> 00:02:02,140
นี้อย่างแท้จริงจะพิมพ์
ไปที่หน้าจอใดก็ตาม

45
00:02:02,140 --> 00:02:05,990
อยู่ภายในวงเล็บเหล่านั้นซึ่ง
แน่นอนในกรณีนี้คือโลกสวัสดี

46
00:02:05,990 --> 00:02:09,290
>> แต่คุณจะสังเกตเห็นอื่น ๆ บาง
ไวยากรณ์บางราคาคู่

47
00:02:09,290 --> 00:02:11,890
ที่วงเล็บที่สิ้นสุด,
กึ่งลำไส้ใหญ่และชอบ

48
00:02:11,890 --> 00:02:15,027
ดังนั้นจึงมีบิตของค่าใช้จ่าย
เพื่อที่จะพูดทั้งรับรู้

49
00:02:15,027 --> 00:02:17,860
และไวยากรณ์ที่เรากำลังจะไป
ที่จะต้องจำไว้ก่อนที่จะยาว

50
00:02:17,860 --> 00:02:20,720
แต่ทราบว่ามีการปฏิบัติ
นี้จะเริ่มที่จะกระโดดออกจากที่คุณ

51
00:02:20,720 --> 00:02:24,920
>> ในความเป็นจริงขอเน้นที่หนึ่ง
ฟังก์ชั่น specifically-- ในกรณีนี้

52
00:02:24,920 --> 00:02:26,290
ทักทายโลก

53
00:02:26,290 --> 00:02:27,560
ดังนั้นพูดได้ก็คือฟังก์ชั่น

54
00:02:27,560 --> 00:02:31,320
สวัสดีชาวโลกเป็นพารามิเตอร์ของตน
หรือโต้แย้งการปรับแต่ง

55
00:02:31,320 --> 00:02:34,320
>> และความเท่าเทียมกันใน C เป็นเพียง
จะเป็นหนึ่งบรรทัดนี้ที่นี่

56
00:02:34,320 --> 00:02:38,710
ที่ printf จะเทียบเท่ากับการพูด
สตริงที่ยกมาคู่สวัสดี

57
00:02:38,710 --> 00:02:41,470
โลกจะเทียบเท่าของหลักสูตร
กับสิ่งที่อยู่ในกล่องสีขาวมี

58
00:02:41,470 --> 00:02:45,680
และ n ทับขวาแม้เพียงเล็กน้อย
ที่แปลกและขาดจากรอยขีดข่วน

59
00:02:45,680 --> 00:02:49,380
ก็จะมีผลกระทบที่เราจะ
เห็นในคอมพิวเตอร์เช่น Mac หรือ PC ของฉัน

60
00:02:49,380 --> 00:02:51,660
เพียงย้าย
เคอร์เซอร์บรรทัดถัดไป

61
00:02:51,660 --> 00:02:53,970
มันก็เหมือนกับการกดปุ่ม
Enter บนแป้นพิมพ์ของคุณ

62
00:02:53,970 --> 00:02:55,580
>> ดังนั้นเราจะเห็นว่าอีกไม่นาน

63
00:02:55,580 --> 00:02:58,640
แต่ก่อนอื่นลองมาดูที่นี้
ตัวอย่างอื่น ๆ ในกรณีของลูป

64
00:02:58,640 --> 00:03:02,830
เรามีนี้ห่วงตลอดเวลาที่ผ่านมา
ซึ่งเป็นชุดของชิ้นส่วนจิ๊กซอว์

65
00:03:02,830 --> 00:03:05,490
ว่าทำอะไรบางอย่างแท้จริง
forever-- ในกรณีนี้

66
00:03:05,490 --> 00:03:08,360
บอกว่าโลกสวัสดีโลก
Hello World, Hello World

67
00:03:08,360 --> 00:03:10,350
ดังนั้นจึงเป็นห่วงอนันต์โดยการออกแบบ

68
00:03:10,350 --> 00:03:14,580
>> ใน C ถ้าเราต้องการที่จะดำเนินการนี​​้
ความคิดเดียวกันเราก็อาจจะทำเช่นนี้

69
00:03:14,580 --> 00:03:19,570
ในขณะที่ความจริง printf สวัสดี world-- ในขณะนี้
ในขณะที่เพียงความหมายชนิดของ

70
00:03:19,570 --> 00:03:23,090
เสกขึ้นมาความคิดของการทำ
บางสิ่งบางอย่างอีกครั้งและอีกครั้งและอีกครั้ง

71
00:03:23,090 --> 00:03:23,980
และนานเท่าไหร่?

72
00:03:23,980 --> 00:03:27,990
ดีเรียกคืน true-- ว่า
ความจริงเป็นเพียงหนึ่งหรือ

73
00:03:27,990 --> 00:03:30,660
>> และเป็นความจริงเป็นของหลักสูตรจริงเสมอ

74
00:03:30,660 --> 00:03:33,060
ดังนั้นมันจึงเป็นชนิดของความหมาย
คำสั่งเพียงเพื่อบอกความจริง

75
00:03:33,060 --> 00:03:36,890
แต่แท้จริงนี้คือเจตนา
เพราะถ้าเป็นจริงเป็นความจริงเพียงแค่เสมอ

76
00:03:36,890 --> 00:03:40,850
กว่าในขณะที่ความจริงเพียงหมายถึง
ถ้าเล็ก ๆ น้อย ๆ โดยอ้อม

77
00:03:40,850 --> 00:03:44,070
ว่าสายของรหัสต่อไป
ในระหว่างวงเล็บปีกกาเหล่านั้น

78
00:03:44,070 --> 00:03:48,320
ก็ควรจะดำเนินการอีกครั้งและอีกครั้ง
และอีกครั้งและไม่เคยหยุดจริง

79
00:03:48,320 --> 00:03:50,230
>> แต่ถ้าคุณไม่ต้องการของคุณ
ห่วงจะหยุดที่เรา

80
00:03:50,230 --> 00:03:54,500
ทำครั้งสุดท้ายกับสิ่งที่ต้องการ
นี้ซ้ำต่อไปนี้ 50 ครั้ง

81
00:03:54,500 --> 00:03:57,700
ใน C เราสามารถทำเช่นเดียวกันกับสิ่งที่
เรียกว่าสำหรับ loop-- คำหลัก

82
00:03:57,700 --> 00:03:59,330
ในขณะที่ไม่ได้ แต่สำหรับ

83
00:03:59,330 --> 00:04:03,290
แล้วเรามีบางไวยากรณ์ใหม่ที่นี่
กับ int i เท่ากับ 0, ฉันน้อยกว่า 50

84
00:04:03,290 --> 00:04:03,880
i ++

85
00:04:03,880 --> 00:04:05,430
และเราจะกลับมาที่

86
00:04:05,430 --> 00:04:09,660
แต่นี้เป็นเพียงวิธีการที่เราจะ
แปลชุดของบล็อกรอยขีดข่วน

87
00:04:09,660 --> 00:04:13,079
ชุดสาย C ของรหัส

88
00:04:13,079 --> 00:04:14,450
>> ในขณะเดียวกันให้พิจารณาตัวแปร

89
00:04:14,450 --> 00:04:16,540
และในความเป็นจริงเราเพียงแค่
เห็นชายคนหนึ่งสักครู่ที่ผ่านมา

90
00:04:16,540 --> 00:04:21,220
และในกรณีของรอยขีดข่วนถ้าเรา
อยากจะประกาศตัวแปรที่เรียกว่าฉัน

91
00:04:21,220 --> 00:04:24,590
เพราะเราเป็นจำนวนเต็มเพียงตัวเลข
และเราต้องการที่จะตั้งค่าให้ค่าบางอย่าง

92
00:04:24,590 --> 00:04:28,410
เราจะใช้สีส้มนี้
กันโดยตั้ง here-- ฉัน 0

93
00:04:28,410 --> 00:04:30,800
>> และเราจะเห็นในวันนี้และ
ไกลออกไปเช่นเดียวกับสัปดาห์ที่ผ่านมา

94
00:04:30,800 --> 00:04:33,850
โปรแกรมเมอร์ทำเกือบเสมอ
เริ่มนับจากศูนย์จริงๆ

95
00:04:33,850 --> 00:04:34,950
โดยการประชุม

96
00:04:34,950 --> 00:04:37,250
แต่ยังเป็นเพราะการเรียกคืนจาก
การสนทนาของเราของไบนารี

97
00:04:37,250 --> 00:04:39,990
จำนวนที่น้อยที่สุดที่คุณสามารถ
แทนด้วยจำนวนบิตใด ๆ

98
00:04:39,990 --> 00:04:41,640
เป็นเพียงการไปเป็น 0 ตัวเอง

99
00:04:41,640 --> 00:04:45,190
และเพื่อให้เราโดยทั่วไปจะเริ่มต้น
เริ่มต้นแม้ตัวแปรของเราให้เป็น 0

100
00:04:45,190 --> 00:04:47,710
>> และใน C จะทำเช่นเดียวกัน
เรากำลังจะบอกว่า int

101
00:04:47,710 --> 00:04:50,110
สำหรับจำนวนเต็มฉันเพียงแค่โดยการประชุม

102
00:04:50,110 --> 00:04:53,390
ฉันจะได้เรียกว่าตัวแปรนี้
อะไรที่ฉันต้องการเช่นเดียวกับในรอยขีดข่วน

103
00:04:53,390 --> 00:04:57,770
และแล้วเท่ากับ 0 เพียงแค่กำหนด
ค่า 0 จากด้านขวา

104
00:04:57,770 --> 00:05:01,319
และทำให้มันเป็นตัวแปรหรือ
ภาชนะที่เก็บมีอยู่ทางซ้ายมือ

105
00:05:01,319 --> 00:05:04,360
และลำไส้ใหญ่กึ่งที่สุดเท่าที่เราจะ see-- และ
ที่เราเคยเห็นไม่กี่ already-- เหล่านี้

106
00:05:04,360 --> 00:05:06,530
เพียงหมายถึงการสิ้นสุดของความคิด

107
00:05:06,530 --> 00:05:09,430
ดำเนินการต่อไปทำอย่างอื่น
บนเส้นที่เป็นไปตาม

108
00:05:09,430 --> 00:05:11,330
>> ตอนนี้สิ่งที่เกี่ยวกับนิพจน์บูลีน?

109
00:05:11,330 --> 00:05:14,320
จำได้ว่าในเกา
เหล่านี้มีการแสดงออก

110
00:05:14,320 --> 00:05:16,740
ที่มีความจริง แต่อย่างใด
หรือคำถาม false--,

111
00:05:16,740 --> 00:05:18,910
จริงๆที่มีทั้งจริงหรือเท็จ

112
00:05:18,910 --> 00:05:21,960
ดังนั้นในกรณีของการเริ่มต้นเราอาจจะ
ถามคำถามง่ายๆเช่นนี้

113
00:05:21,960 --> 00:05:24,586
คือผมน้อยกว่า 50?

114
00:05:24,586 --> 00:05:25,710
ดังนั้นฉันอีกครั้งเป็นจำนวนเต็ม

115
00:05:25,710 --> 00:05:27,210
บางทีเรากำลังใช้มัน
ในโปรแกรมรอยขีดข่วน

116
00:05:27,210 --> 00:05:29,310
ในการติดตามของคะแนน
หรือสิ่งที่ต้องการ

117
00:05:29,310 --> 00:05:33,810
ดังนั้นรูปแบบนี้ที่นี่ในรอยขีดข่วน
ก็หมายความว่าเป็นฉันน้อยกว่า 50?

118
00:05:33,810 --> 00:05:37,330
ดีโชคดีที่มีอะไรบางอย่าง
ที่เรียบง่ายในซีและการแปล

119
00:05:37,330 --> 00:05:41,780
นี้เราก็จะบอกว่าผมน้อย
กว่า 50, ใช้คีย์คุ้นเคย

120
00:05:41,780 --> 00:05:42,850
บนแป้นพิมพ์

121
00:05:42,850 --> 00:05:45,141
>> ในขณะเดียวกันถ้าคุณต้องการ
พูดอะไรบางอย่างทั่วไปมากขึ้น

122
00:05:45,141 --> 00:05:49,890
เหมือนกันคือ x น้อยกว่าปีที่แต่ละ
ของ x และ y เป็นตัวตัวแปร?

123
00:05:49,890 --> 00:05:52,280
เราสามารถทำในสิ่งเดียวกัน
ใน C ตราบใดที่เราได้

124
00:05:52,280 --> 00:05:53,942
สร้างตัวแปรเหล่านี้อยู่แล้ว

125
00:05:53,942 --> 00:05:55,650
และเราจะเห็นวิธีการ
ทำอย่างนั้นไม่นาน

126
00:05:55,650 --> 00:05:58,590
เราก็จะบอกว่าน้อยกว่า X Y

127
00:05:58,590 --> 00:06:00,530
>> ดังนั้นคุณเริ่มที่จะ
ดูคล้ายคลึงกันบางอย่าง

128
00:06:00,530 --> 00:06:03,490
และคนเหล่านั้นที่ทำ
รอยขีดข่วนได้อย่างแน่นอน

129
00:06:03,490 --> 00:06:05,250
แรงบันดาลใจจากบางส่วนของความคิดพื้นฐานเหล่านี้

130
00:06:05,250 --> 00:06:10,350
และคุณจะเห็นชนิดนี้
ไวยากรณ์ในหลาย languages​​--

131
00:06:10,350 --> 00:06:12,160
ไม่ได้เป็นเพียงรอยขีดข่วนไม่
เพียงแค่ C แต่งูหลาม

132
00:06:12,160 --> 00:06:14,790
และ JavaScript และ
ภาษาอื่น ๆ ยังคง

133
00:06:14,790 --> 00:06:18,270
>> ลองพิจารณาสร้างอีก
จาก C, ความคิดของเงื่อนไขที่

134
00:06:18,270 --> 00:06:20,370
ทำสิ่งที่มีเงื่อนไข

135
00:06:20,370 --> 00:06:22,720
หากสิ่งที่เป็นความจริงทำเช่นนี้

136
00:06:22,720 --> 00:06:24,457
ถ้าอย่างอื่นเป็นความจริงทำอย่างนั้น

137
00:06:24,457 --> 00:06:27,040
มันเรียงลำดับของการเขียนโปรแกรม
เทียบเท่าส้อมในถนน

138
00:06:27,040 --> 00:06:29,730
บางทีมันอาจจะเป็นทางแยกสองทาง
ส้อมสามทางหรือมากกว่า

139
00:06:29,730 --> 00:06:32,800
และในเกาเราอาจจะมี
บางสิ่งบางอย่างที่เห็นเช่นนี้

140
00:06:32,800 --> 00:06:34,010
>> ดังนั้นหนึ่งในนี้เป็นขนาดใหญ่

141
00:06:34,010 --> 00:06:36,750
แต่พิจารณาญาติ
ความเรียบง่ายของตรรกะ

142
00:06:36,750 --> 00:06:44,010
ถ้า x น้อยกว่าปีแล้วบอกว่า x น้อย
กว่า Y, อื่นถ้า x มากกว่า Y,

143
00:06:44,010 --> 00:06:46,230
แล้วบอกว่า x มากกว่า Y

144
00:06:46,230 --> 00:06:48,300
แล้วมีเหตุผลถ้า
คุณคิดว่ากลับไปรอยขีดข่วน

145
00:06:48,300 --> 00:06:52,610
หรือเพียงแค่สัญชาตญาณของมนุษย์ของคุณเอง
ดีถ้า x ไม่เกิน Y และ X

146
00:06:52,610 --> 00:06:57,000
ไม่น้อยกว่าปีแล้วแน่นอน
X เป็นไปได้เท่ากับ Y

147
00:06:57,000 --> 00:06:59,690
ดังนั้นในกรณีนี้โดยการทำรัง
บรรดาบล็อกเกา

148
00:06:59,690 --> 00:07:02,580
เราสามารถบรรลุสาม
ส้อมวิธีการในถนนหรือไม่

149
00:07:02,580 --> 00:07:04,980
>> ในขณะเดียวกันถ้าเราต้องการที่จะ
ทำอย่างนั้นใน C มันเนื้อหา

150
00:07:04,980 --> 00:07:08,420
ดู simpler-- เล็ก ๆ น้อย ๆ อย่างน้อย
เมื่อคุณได้รับคุ้นเคยกับไวยากรณ์

151
00:07:08,420 --> 00:07:12,050
ถ้า x น้อยกว่า Y,
printf x น้อยกว่า Y

152
00:07:12,050 --> 00:07:16,140
อื่นถ้า x มากกว่า Y,
printf x มากกว่า Y

153
00:07:16,140 --> 00:07:21,210
อื่น printf x เท่ากับ y-- และ
อีกครั้งด้วย backslash ผู้ที่จบลงเพียงแค่

154
00:07:21,210 --> 00:07:24,160
สำหรับสายใหม่เหล่านั้นเพื่อว่าถ้าคุณ
จริงวิ่งชนิดของโปรแกรมนี้

155
00:07:24,160 --> 00:07:25,940
มันก็จะย้าย
เคอร์เซอร์ของคุณในท้ายที่สุด

156
00:07:25,940 --> 00:07:28,100
ยังบรรทัดถัดไปของหน้าจอ

157
00:07:28,100 --> 00:07:31,270
>> ตอนนี้ในขณะที่มีรอยขีดข่วนอื่น ๆ
คุณสมบัติที่ซับซ้อนมากขึ้นเท่านั้น

158
00:07:31,270 --> 00:07:34,320
บางอย่างที่เรากำลังจะไป
แรกย้ายไปยังโลกของซี

159
00:07:34,320 --> 00:07:37,010
และหนึ่งในนั้นคือ
เรียกว่ารายการในรอยขีดข่วน

160
00:07:37,010 --> 00:07:39,100
และเรื่องนี้เป็นพิเศษ
ประเภทของตัวแปรที่

161
00:07:39,100 --> 00:07:42,840
อนุญาตให้คุณสามารถเก็บสิ่งที่หลาย ๆ
ในการกลับไปกลับไปกลับไปด้านหลัง

162
00:07:42,840 --> 00:07:45,540
>> ใน C, มันไม่ได้มี
รายการต่อ se แต่บางสิ่งบางอย่าง

163
00:07:45,540 --> 00:07:48,090
ที่มีมากขึ้นโดยทั่วไป
เรียกว่าอาร์เรย์แม้ว่าเราจะ

164
00:07:48,090 --> 00:07:50,590
กลับมาในภายหลังภาคการศึกษานี้
เพื่อมองหาที่บางสิ่งบางอย่าง

165
00:07:50,590 --> 00:07:52,780
เรียกว่ารายการหรือจริงๆรายการที่เชื่อมโยง

166
00:07:52,780 --> 00:07:55,510
แต่ตอนนี้ที่อยู่ใกล้ที่สุด
เทียบเท่าใน C สำหรับเรา

167
00:07:55,510 --> 00:07:57,345
เป็นไปได้บางสิ่งบางอย่าง
เรียกว่าอาร์เรย์

168
00:07:57,345 --> 00:07:59,740
และอาร์เรย์เป็นเพียง
ชนิดพิเศษของตัวแปร

169
00:07:59,740 --> 00:08:03,160
ที่ช่วยให้คุณสามารถเก็บข้อมูล
กลับไปกลับไปกลับไปด้านหลัง

170
00:08:03,160 --> 00:08:05,840
>> และแน่นอนในเกา
ถ้าเราต้องการที่จะเข้าถึง

171
00:08:05,840 --> 00:08:09,030
องค์ประกอบแรกของอาร์เรย์หรือ
list-- และฉันจะเรียกว่า

172
00:08:09,030 --> 00:08:13,600
โดยการประชุม, argv อาร์กิวเมนต์
เวกเตอร์ แต่เพิ่มเติมว่าอีกไม่นาน

173
00:08:13,600 --> 00:08:17,090
ถ้าผมต้องการที่จะได้รับองค์ประกอบแรก
ของ argv ในโลกของรอยขีดข่วน

174
00:08:17,090 --> 00:08:20,930
คุณมักจะทำจริง
เริ่มนับตั้งแต่วันที่ 1

175
00:08:20,930 --> 00:08:22,850
>> และดังนั้นผมจึงอาจได้รับข้อ 1 ของ argv

176
00:08:22,850 --> 00:08:26,310
นั่นเป็นเพียงวิธีการดำเนินการที่เอ็มไอที
ความคิดของรายการ

177
00:08:26,310 --> 00:08:29,860
แต่ใน C, ฉันจะไป
อื่น ๆ อีกมากมายเพียงแค่พูดว่า argv,

178
00:08:29,860 --> 00:08:32,758
อีกครั้งซึ่งเป็นชื่อของฉัน
list-- หรือเพื่อจะชัดเจนอาร์เรย์

179
00:08:32,758 --> 00:08:34,549
และถ้าผมต้องการเป็นคนแรก
องค์ประกอบที่ฉันจะ

180
00:08:34,549 --> 00:08:37,890
การใช้วงเล็บที่คุณ
อาจจะไม่ได้ใช้บ่อยภายใต้แป้นพิมพ์

181
00:08:37,890 --> 00:08:40,150
>> แต่เพียง 0 หมายถึงได้รับฉันแรก

182
00:08:40,150 --> 00:08:42,160
ดังนั้นในโอกาสและ
เวลาผ่านไปเราจะ

183
00:08:42,160 --> 00:08:44,570
ที่จะเริ่มต้นที่จะเห็นทุกอย่างเหล่านี้
ระหว่างรอยขีดข่วนและ C

184
00:08:44,570 --> 00:08:46,070
โดย Scratch ใช้อย่างใดอย่างหนึ่ง

185
00:08:46,070 --> 00:08:47,670
เราใช้ใน C 0 ที่นี่

186
00:08:47,670 --> 00:08:49,420
แต่คุณจะเห็นได้อย่างรวดเร็ว
เมื่อคุณเข้าใจ

187
00:08:49,420 --> 00:08:52,920
รากฐานของแต่ละภาษาที่
สิ่งเหล่านี้เริ่มที่จะได้รับทั้งหมดเพิ่มเติม

188
00:08:52,920 --> 00:08:56,860
คุ้นเคยผ่านการปฏิบัติและการปฏิบัติ

189
00:08:56,860 --> 00:08:59,700
>> ดังนั้นขอให้เป็นจริงการมองในขณะนี้ที่โปรแกรม

190
00:08:59,700 --> 00:09:04,031
นี่จะเป็นครั้งแรกของซีของเรา
ซอร์สโค้ดของโปรแกรมที่สมบูรณ์

191
00:09:04,031 --> 00:09:06,280
และโปรแกรมที่เรากำลังจะไป
ที่จะนำเสนอเพื่อประกอบการพิจารณา

192
00:09:06,280 --> 00:09:09,340
เป็นหนึ่งในที่เทียบเท่า
เพื่อว่าชิ้นส่วนก่อนหน้านี้รอยขีดข่วน

193
00:09:09,340 --> 00:09:13,210
>> ดังนั้นในที่นี่เรามีสิ่งที่เป็น
เนื้อหาที่ง่ายโปรแกรม C

194
00:09:13,210 --> 00:09:15,410
คุณสามารถเขียนว่า
บางสิ่งบางอย่างที่ไม่จริง

195
00:09:15,410 --> 00:09:18,250
ตอนนี้เราจะดูที่ผ่านมา
สำหรับตอนนี้ยังรวมถึง

196
00:09:18,250 --> 00:09:21,190
io.h มาตรฐานและมุมเหล่านี้
วงเล็บและ int และเป็นโมฆะ

197
00:09:21,190 --> 00:09:22,840
และวงเล็บปีกกาและไม่ชอบ

198
00:09:22,840 --> 00:09:25,390
>> และขอเพียงมุ่งเน้น
สิ่งที่อย่างน้อยสังหรณ์ใจ

199
00:09:25,390 --> 00:09:26,860
อาจจะกระโดดออกจากที่คุณมีอยู่แล้ว

200
00:09:26,860 --> 00:09:30,300
ในความเป็นจริงหลักฉันทำไม่ได้
จำเป็นต้องรู้ว่าสิ่งนี้คือ

201
00:09:30,300 --> 00:09:34,580
แต่เหมือนรอยขีดข่วนได้ว่าเมื่อ
ธงสีเขียวคลิกชิ้นส่วนจิ๊กซอว์

202
00:09:34,580 --> 00:09:39,070
เพื่อไม่ C เป็นภาษาโปรแกรม
มีชิ้นส่วนหลักของรหัสที่

203
00:09:39,070 --> 00:09:43,380
ได้รับการดำเนินการไปโดยปริยาย และแน่นอน
มันอย่างแท้จริงจะถูกเรียกว่าหลัก

204
00:09:43,380 --> 00:09:44,720
>> ดังนั้นหลักคือฟังก์ชั่น

205
00:09:44,720 --> 00:09:48,720
และมันเป็นฟังก์ชั่นพิเศษที่มีอยู่
ใน C ที่ว่าเมื่อคุณรันโปรแกรม

206
00:09:48,720 --> 00:09:52,720
มันเป็นหลักที่ได้รับการดำเนินการโดย
ค่าเริ่มต้น. ในโลกของรอยขีดข่วน

207
00:09:52,720 --> 00:09:56,970
มันเป็นปกติเมื่อธงสีเขียว
คลิกที่ได้ดำเนินการโดยเริ่มต้น

208
00:09:56,970 --> 00:10:01,130
>> ในขณะเดียวกันเราเคยเห็นแบบนี้มาก่อน
printf หรือพิมพ์รูปแบบที่

209
00:10:01,130 --> 00:10:05,620
จะเป็นฟังก์ชั่นที่มาพร้อมกับ
C พร้อมกับทั้งกลุ่มของคนอื่น ๆ

210
00:10:05,620 --> 00:10:10,140
จะจากเวลาและเวลาที่
อีกครั้งเพื่อที่จะทำว่า

211
00:10:10,140 --> 00:10:12,450
เป็นชื่อของมันบ่งบอกอะไรบางอย่างที่พิมพ์

212
00:10:12,450 --> 00:10:13,500
เราทำอะไรต้องการพิมพ์?

213
00:10:13,500 --> 00:10:15,770
ดีเราจะเห็นว่า
โดยตัวละครที่ล้อมรอบ

214
00:10:15,770 --> 00:10:18,680
เหมือนโลกสวัสดี these--,
ทับขวา n ในราคาคู่

215
00:10:18,680 --> 00:10:23,040
เราสามารถบอกได้ว่า printf
สิ่งที่จะพิมพ์บนหน้าจอ

216
00:10:23,040 --> 00:10:26,430
>> แต่เพื่อที่จะทำ
ว่าเราโชคไม่ดี

217
00:10:26,430 --> 00:10:30,010
จำเป็นต้องใช้สิ่งที่เป็น
แล้วความลับให้เรามนุษย์

218
00:10:30,010 --> 00:10:34,510
แต่อย่างน้อยก็ค่อนข้าง readable--
คมชัดรวมถึง io.h มาตรฐาน int,

219
00:10:34,510 --> 00:10:39,340
หลักโมฆะ printf ทั้งหมดของวิเศษ
คาถาที่เราเพิ่งเห็นบนหน้าจอ

220
00:10:39,340 --> 00:10:42,470
แต่เราจริงต้อง
ไปยังความลับมากขึ้น

221
00:10:42,470 --> 00:10:47,140
แรกที่เราต้องแปลรหัส
ที่เราเขียนลงในรหัสเครื่อง

222
00:10:47,140 --> 00:10:51,370
และเรียกคืนจากสัปดาห์ที่แล้วว่าเครื่อง
อย่างน้อยคนที่เรารู้ว่าที่นี่

223
00:10:51,370 --> 00:10:54,450
ในตอนท้ายของวันเท่านั้น
เข้าใจศูนย์และคน

224
00:10:54,450 --> 00:10:58,100
>> และพระเจ้าของข้าพเจ้าถ้าเรามีการเขียนเหล่านี้
ศูนย์และคนในการเขียนโปรแกรมจริง

225
00:10:58,100 --> 00:11:01,260
มันจะมากอย่างรวดเร็ว
ใช้เวลาสนุกออกจากอะไร

226
00:11:01,260 --> 00:11:05,150
แต่ปรากฎต่อสัปดาห์ที่ผ่านมา
ว่ารูปแบบนี้ของศูนย์และคน

227
00:11:05,150 --> 00:11:06,400
เพียงแค่มีความหมายพิเศษ

228
00:11:06,400 --> 00:11:08,500
ในบริบทบางอย่าง
พวกเขาอาจจะหมายถึงตัวเลข

229
00:11:08,500 --> 00:11:11,840
>> ในบริบทบางพวกเขาอาจหมายถึง
ตัวอักษรหรือสีหรือหมายเลขใด ๆ

230
00:11:11,840 --> 00:11:14,710
ของแนวคิดอื่น ๆ ที่มีอยู่บน

231
00:11:14,710 --> 00:11:18,450
แต่ในขณะที่คอมพิวเตอร์ของคุณมี
ซีพียู, หน่วยประมวลผลกลาง

232
00:11:18,450 --> 00:11:20,390
หรือสมองภายในของเครื่องคอมพิวเตอร์ของคุณ

233
00:11:20,390 --> 00:11:22,240
มันมักจะเป็น Intel
ภายในเพราะนั่นคือ

234
00:11:22,240 --> 00:11:24,900
หนึ่งใน บริษัท ที่ใหญ่ที่สุด
ที่ทำให้ซีพียูสำหรับคอมพิวเตอร์

235
00:11:24,900 --> 00:11:28,910
>> ดี CPU ของ Intel และอื่น ๆ
เพียงแค่ได้ตัดสินใจล่วงหน้า

236
00:11:28,910 --> 00:11:33,970
ว่ารูปแบบหนึ่งของศูนย์และ
คนที่จะหมายถึงสิ่งที่เฉพาะเจาะจง

237
00:11:33,970 --> 00:11:37,040
บางรูปแบบของศูนย์และคน
จะหมายถึงการพิมพ์นี้เพื่อหน้าจอ

238
00:11:37,040 --> 00:11:39,710
หรือเพิ่มทั้งสองตัวเลขหรือ
ลบทั้งสองหมายเลข

239
00:11:39,710 --> 00:11:43,310
หรือเคลื่อนย้ายชิ้นส่วนของข้อมูลนี้จาก
หน่วยความจำของคอมพิวเตอร์ของฉันมากกว่าที่นี่

240
00:11:43,310 --> 00:11:47,870
หรือจำนวนของระดับต่ำมาก ๆ ๆ ๆ ,
แต่มีประโยชน์ในท้ายที่สุดการดำเนินงาน

241
00:11:47,870 --> 00:11:53,022
แต่โชคดีที่มนุษย์เราจะไม่ได้ไป
จะต้องรู้รายละเอียดในระดับนี้

242
00:11:53,022 --> 00:11:56,230
แท้จริงเช่นเดียวกับครั้งสุดท้ายที่เรา
ใจลอยอีกครั้งและอีกครั้งและอีกครั้ง

243
00:11:56,230 --> 00:11:58,930
อาคารจากระดับที่ต่ำมาก
วิทยาการเช่นศูนย์และคน

244
00:11:58,930 --> 00:12:01,160
กับแนวคิดระดับที่สูงขึ้น
เช่นตัวเลขและตัวอักษร

245
00:12:01,160 --> 00:12:04,330
และสีและอื่น ๆ
เพื่อให้เราสามารถเป็นโปรแกรมเมอร์

246
00:12:04,330 --> 00:12:07,080
ยืนอยู่บนไหล่ของ
คนอื่น ๆ ที่มีมาก่อนเรา

247
00:12:07,080 --> 00:12:11,260
และใช้ซอฟต์แวร์ที่อื่น ๆ
คนได้เขียนขึ้นก่อน us--

248
00:12:11,260 --> 00:12:14,340
คือโปรแกรมที่เรียกว่าคอมไพเลอร์

249
00:12:14,340 --> 00:12:17,770
>> ซีเป็นภาษาที่
มักจะมีการรวบรวม

250
00:12:17,770 --> 00:12:22,130
ซึ่งหมายถึงการดัดแปลงมาจาก
รหัสที่มารหัสเครื่อง

251
00:12:22,130 --> 00:12:25,230
โดยเฉพาะอย่างยิ่งสิ่งนี้หมายความว่า
คือว่าถ้าคุณได้มีแหล่งที่มาของ

252
00:12:25,230 --> 00:12:29,530
รหัสที่คุณเองเขียนในขณะที่เราเร็ว ๆ นี้
จะอยู่ในช่วงเวลาเพียงแค่บนหน้าจอ,

253
00:12:29,530 --> 00:12:33,140
และคุณต้องการแปลง
ในท้ายที่สุดไปยังเครื่อง code--

254
00:12:33,140 --> 00:12:37,100
ศูนย์เหล่านั้นและคนที่
เพียง Mac หรือ PC ของคุณ

255
00:12:37,100 --> 00:12:41,230
understands-- ที่คุณได้เป็นครั้งแรก
ฟีดรหัสที่มาว่าในขณะที่

256
00:12:41,230 --> 00:12:46,340
การป้อนข้อมูลให้เป็นพิเศษ
โปรแกรมที่เรียกว่าคอมไพเลอร์,

257
00:12:46,340 --> 00:12:48,974
การส่งออกของที่เรา
จะเห็นเป็นรหัสเครื่อง

258
00:12:48,974 --> 00:12:51,890
และแน่นอนครั้งสุดท้ายที่เราได้พูดคุยกัน
เกี่ยวกับมันในตอนท้ายของวัน

259
00:12:51,890 --> 00:12:52,610
การแก้ปัญหา.

260
00:12:52,610 --> 00:12:53,360
คุณได้มีปัจจัยการผลิต

261
00:12:53,360 --> 00:12:54,318
และคุณได้มีเอาท์พุท

262
00:12:54,318 --> 00:12:56,560
และคุณได้มีบางชนิด
ขั้นตอนวิธีการที่อยู่ตรงกลาง

263
00:12:56,560 --> 00:12:59,830
>> ขั้นตอนวิธีการก็สามารถ
ดำเนินการในซอฟต์แวร์

264
00:12:59,830 --> 00:13:02,900
อย่างที่เราเห็นกับสัปดาห์ที่ผ่านมา pseudocode
และในขณะที่เราจะเห็นด้วยรหัสที่เกิดขึ้นจริง

265
00:13:02,900 --> 00:13:03,490
ในสัปดาห์นี้.

266
00:13:03,490 --> 00:13:06,430
และเพื่อให้คอมไพเลอร์จริงๆเพียงแค่
มีชุดของขั้นตอนวิธีการภายใน

267
00:13:06,430 --> 00:13:10,060
ของมันที่ทราบวิธีการ
แปลงคำหลักพิเศษ

268
00:13:10,060 --> 00:13:12,180
เช่นหลักและ printf,
และอื่น ๆ ที่เราเพียงแค่

269
00:13:12,180 --> 00:13:17,620
เห็นในรูปแบบของศูนย์และ
คนที่อินเทลภายในและอื่น ๆ ซีพียู

270
00:13:17,620 --> 00:13:20,020
จริงเข้าใจ

271
00:13:20,020 --> 00:13:22,460
ดังนั้นทำอย่างไรเราทำเช่นนี้?

272
00:13:22,460 --> 00:13:24,470
ที่เราจะได้รับคอมไพเลอร์หรือไม่?

273
00:13:24,470 --> 00:13:26,400
>> ส่วนใหญ่ของเราที่นี่มี Mac หรือ PC

274
00:13:26,400 --> 00:13:29,152
และคุณใช้ Mac OS หรือ
Windows หรือลินุกซ์หรือโซลาริส

275
00:13:29,152 --> 00:13:30,860
หรือจำนวนอื่น ๆ
ระบบปฏิบัติการ.

276
00:13:30,860 --> 00:13:32,568
และแน่นอนที่เราจะทำได้
ออกไปสู่​​เว็บ

277
00:13:32,568 --> 00:13:35,710
และดาวน์โหลดคอมไพเลอร์
สำหรับ Mac หรือ PC ของคุณ

278
00:13:35,710 --> 00:13:37,360
สำหรับระบบปฏิบัติการของคุณโดยเฉพาะ

279
00:13:37,360 --> 00:13:39,617
แต่เราทุกคนจะอยู่บน
หน้าเว็บที่แตกต่างกันเพื่อที่จะพูด

280
00:13:39,617 --> 00:13:41,450
เราจะต้องออกไปเล็กน้อย
การกำหนดค่าที่แตกต่างกัน

281
00:13:41,450 --> 00:13:43,210
และสิ่งที่จะไม่ทำงานเหมือนกันทั้งหมด

282
00:13:43,210 --> 00:13:45,280
และแน่นอนวันนี้
พวกเราหลายคนไม่ได้ใช้

283
00:13:45,280 --> 00:13:47,516
ซอฟต์แวร์ที่ทำงานเฉพาะในแล็ปท็อปของเรา

284
00:13:47,516 --> 00:13:49,390
แต่เราใช้สิ่งที่
เช่นเดียวกับเบราว์เซอร์ที่

285
00:13:49,390 --> 00:13:52,930
ช่วยให้เราสามารถเข้าถึง Web-based
การใช้งานในระบบคลาวด์

286
00:13:52,930 --> 00:13:55,630
และต่อมาภาคการศึกษานี้
เราจะทำตรงนั้น

287
00:13:55,630 --> 00:13:59,660
เราจะเขียนโปรแกรมหรือ
ซอฟแวร์ที่ใช้ไม่ได้ code-- C,

288
00:13:59,660 --> 00:14:02,860
แต่ภาษาอื่น ๆ เช่นงูหลามและ
JavaScript-- ที่ทำงานในระบบคลาวด์

289
00:14:02,860 --> 00:14:05,860
>> และจะทำอย่างไรที่ตัวเราเอง
ช่วงปิดเทอม

290
00:14:05,860 --> 00:14:11,890
จริงจะใช้เมฆตาม
สภาพแวดล้อมที่รู้จักในฐานะ CS50 IDE

291
00:14:11,890 --> 00:14:16,030
นี่คือการเขียนโปรแกรมบนเว็บ
สภาพแวดล้อมหรือการพัฒนาแบบบูรณาการ

292
00:14:16,030 --> 00:14:20,610
สิ่งแวดล้อม IDE, ที่สร้างอยู่บนบาง
ซอฟแวร์โอเพนซอร์สที่เรียกว่า Cloud 9

293
00:14:20,610 --> 00:14:22,966
และเราได้ทำให้การเรียนการสอนบางส่วน
simplifications กับมัน

294
00:14:22,966 --> 00:14:25,840
เพื่อให้เป็นไปซ่อนคุณลักษณะบางอย่างใน
สัปดาห์แรกที่เราไม่ต้องการ

295
00:14:25,840 --> 00:14:27,770
หลังจากที่คุณสามารถ
เปิดเผยพวกเขาและทำมากที่สุด

296
00:14:27,770 --> 00:14:29,400
สิ่งที่คุณต้องการกับสภาพแวดล้อม

297
00:14:29,400 --> 00:14:32,470
>> และมันช่วยให้เรามากเกินไปที่จะ
ก่อนติดตั้งซอฟต์แวร์บางอย่าง

298
00:14:32,470 --> 00:14:35,330
สิ่งที่ต้องการสิ่งที่เรียกว่า CS50
ห้องสมุดซึ่งเราจะเห็นทันที

299
00:14:35,330 --> 00:14:39,210
ให้เราใน C กับบางส่วน
ฟังก์ชันการทำงานเพิ่มเติม

300
00:14:39,210 --> 00:14:44,392
ดังนั้นถ้าคุณไปในที่สุด CS50.io,
คุณจะได้รับแจ้งให้เข้าสู่ระบบ

301
00:14:44,392 --> 00:14:46,350
และเมื่อคุณทำและสร้าง
บัญชีฟรีที่

302
00:14:46,350 --> 00:14:52,150
คุณจะสามารถเข้าถึง
สภาพแวดล้อมที่มีลักษณะมากเช่นนี้

303
00:14:52,150 --> 00:14:53,760
>> ตอนนี้อยู่ในโหมดเริ่มต้น

304
00:14:53,760 --> 00:14:55,650
ทุกอย่างเป็นสิ่งที่ดีและ
สว่างบนหน้าจอ

305
00:14:55,650 --> 00:14:57,941
พวกเราหลายคนมีนิสัยของ
ทำงานเกี่ยวกับชิ้นส่วนที่ CS50

306
00:14:57,941 --> 00:14:59,150
ค่อนข้างดึก

307
00:14:59,150 --> 00:15:02,400
และเพื่อให้บางส่วนของคุณอาจต้องการ
ทำให้มันกลายเป็นโหมดกลางคืนเพื่อที่จะพูด

308
00:15:02,400 --> 00:15:05,550
>> แต่ท้ายที่สุดสิ่งที่คุณกำลัง
จะไปดูภายใน CS50 IDE

309
00:15:05,550 --> 00:15:08,340
สาม areas-- ที่แตกต่างกัน
ในพื้นที่ที่เหลือ

310
00:15:08,340 --> 00:15:12,604
ไฟล์ของคุณจะไปได้ใน
เมฆพื้นที่ด้านบนขวา

311
00:15:12,604 --> 00:15:14,270
ที่รหัสของคุณเป็นไปได้ที่สามารถแก้ไขได้

312
00:15:14,270 --> 00:15:16,650
คุณจะสามารถที่จะเปิด
แต่ละแท็บสำหรับโปรแกรมใด ๆ

313
00:15:16,650 --> 00:15:19,670
ที่คุณเขียนภายในภาคการศึกษานี้
ของมุมขวาด้านบนว่า

314
00:15:19,670 --> 00:15:23,070
แล้วส่วนใหญ่ arcanely,
และยังมีอำนาจ

315
00:15:23,070 --> 00:15:26,610
เป็นไปได้สิ่งที่
ด้านล่างเป็นที่รู้จักกันเป็นหน้าต่าง terminal

316
00:15:26,610 --> 00:15:29,450
>> นี้เป็นโรงเรียนเก่า
บรรทัดคำสั่งอินเตอร์เฟซ

317
00:15:29,450 --> 00:15:32,240
หรือ CLI ที่ช่วยให้
คุณสามารถรันคำสั่ง

318
00:15:32,240 --> 00:15:35,260
ใน computer-- ในกรณีนี้
คอมพิวเตอร์ใน cloud--

319
00:15:35,260 --> 00:15:39,090
ทำสิ่งที่ต้องการรวบรวมรหัสของคุณ
จากซอร์สโค้ดรหัสเครื่อง

320
00:15:39,090 --> 00:15:43,600
เพื่อเรียกใช้โปรแกรมของคุณหรือการเริ่มต้นของคุณ
เว็บเซิร์ฟเวอร์หรือการเข้าถึงฐานข้อมูลของคุณ

321
00:15:43,600 --> 00:15:47,454
และจำนวนของเทคนิคอื่น ๆ
ที่เราจะเริ่มต้นที่จะใช้ก่อนที่จะยาว

322
00:15:47,454 --> 00:15:49,370
แต่การที่จะได้รับมีเรา
จะมีจริง

323
00:15:49,370 --> 00:15:51,240
ไปออนไลน์และเริ่มเล่น

324
00:15:51,240 --> 00:15:54,399
และจะทำอย่างไรที่ให้แรก
เริ่ม tinkering กับหลัก

325
00:15:54,399 --> 00:15:55,940
และเขียนส่วนหลักของโปรแกรม

326
00:15:55,940 --> 00:15:59,170
และให้ใช้ฟังก์ชั่นที่
printf ซึ่งเรานำมาใช้ก่อนหน้านี้

327
00:15:59,170 --> 00:16:01,050
เพียงแค่จะบอกว่าบางสิ่งบางอย่าง

328
00:16:01,050 --> 00:16:04,910
>> ดังนั้นที่นี่ฉันทำไปแล้วภายในของ CS50 IDE

329
00:16:04,910 --> 00:16:05,930
ผมเคยลงทะเบียนล่วงหน้า

330
00:16:05,930 --> 00:16:07,360
และฉันเต็มมุ้งลวดหน้าต่าง

331
00:16:07,360 --> 00:16:09,670
และเพื่อให้ในท้ายที่สุดคุณ
เกินไปในปัญหาที่เกิดขึ้นมา

332
00:16:09,670 --> 00:16:12,960
จะเป็นไปตามขั้นตอนที่คล้ายกันที่
จะให้เอกสารออนไลน์

333
00:16:12,960 --> 00:16:16,360
ดังนั้นคุณจึงไม่ต้องกังวลเกี่ยวกับ
การดูดซับทุกขั้นตอนทางเทคนิคเล็ก ๆ น้อย ๆ

334
00:16:16,360 --> 00:16:17,730
ที่ผมทำที่นี่ในวันนี้

335
00:16:17,730 --> 00:16:19,222
>> แต่คุณจะได้รับหน้าจอเช่นนี้

336
00:16:19,222 --> 00:16:20,430
ฉันจะเกิดขึ้นในโหมดกลางคืน

337
00:16:20,430 --> 00:16:22,944
และคุณสามารถปรับความสว่างทุกอย่าง
โดยปิดการใช้งานโหมดกลางคืน

338
00:16:22,944 --> 00:16:24,860
และในตอนท้ายของ
วันคุณกำลังจะไปดู

339
00:16:24,860 --> 00:16:30,090
ทั้งสามหลัก areas-- ไฟล์
เบราว์เซอร์ที่ด้านซ้าย, แท็บรหัสขึ้นด้านบน

340
00:16:30,090 --> 00:16:32,430
และหน้าต่าง terminal ที่ด้านล่าง

341
00:16:32,430 --> 00:16:34,890
>> ให้ฉันไปข้างหน้าและ
เขียนโปรแกรมครั้งแรกของฉัน

342
00:16:34,890 --> 00:16:42,300
ฉันจะ preemptively ไปที่ File,
บันทึกและบันทึกแฟ้มของฉันเป็น hello.c

343
00:16:42,300 --> 00:16:46,850
อันที่จริงตามแบบแผนใด ๆ ที่เราโปรแกรม
เขียนว่าเขียนในภาษา C

344
00:16:46,850 --> 00:16:49,739
ควรตั้งชื่อบางสิ่งบางอย่าง
จุด C, โดยการประชุม

345
00:16:49,739 --> 00:16:53,030
ดังนั้นฉันจะตั้งชื่อให้มัน hello.c เพราะ
ผมแค่อยากจะทักทายกับโลก

346
00:16:53,030 --> 00:16:54,820
ตอนนี้ผมกำลังจะไปซูม
และคลิกบันทึก

347
00:16:54,820 --> 00:16:58,180
และทั้งหมดที่ฉันมีที่นี่ในขณะนี้คือแท็บ
ที่ฉันสามารถเริ่มต้นการเขียนโค้ด

348
00:16:58,180 --> 00:16:59,490
>> นี้ไม่ได้ไปรวบรวม

349
00:16:59,490 --> 00:17:00,300
นี้หมายถึงอะไร

350
00:17:00,300 --> 00:17:02,750
ดังนั้นแม้ว่าผมจะแปลง
นี้ศูนย์และคน,

351
00:17:02,750 --> 00:17:05,390
ซีพียูเป็นไปได้ไม่มี
คิดสิ่งที่เกิดขึ้นรอบ ๆ

352
00:17:05,390 --> 00:17:14,170
แต่ถ้าผมเขียนเส้นที่ไม่ตรงกับ
ขึ้นกับ C conventions-- C เป็นอยู่

353
00:17:14,170 --> 00:17:20,150
อีกครั้งนี้ language-- มีไวยากรณ์เช่น
นี้ printf สวัสดี world-- และฉันได้

354
00:17:20,150 --> 00:17:22,210
อากาศสบายกับ
การทำเช่นนี้เมื่อเวลาผ่านไป

355
00:17:22,210 --> 00:17:24,510
ดังนั้นผมจึงไม่คิดว่าฉันทำ
พิมพ์ผิดพลาดใด ๆ

356
00:17:24,510 --> 00:17:27,910
>> แต่อย่างสม่ำเสมอเป็นครั้งแรกมาก
เวลาที่คุณทำเช่นนี้คุณจะ

357
00:17:27,910 --> 00:17:31,090
และสิ่งที่ฉันจะทำอาจจะมาก
ดีไม่ทำงานให้คุณเป็นครั้งแรก

358
00:17:31,090 --> 00:17:33,610
และที่ตกลงอย่างสมบูรณ์แบบ
เพราะตอนนี้คุณ

359
00:17:33,610 --> 00:17:37,662
ก็อาจจะดูมากทั้งความแปลก,
แต่เมื่อเวลาผ่านไปเมื่อคุณได้รับคุ้นเคย

360
00:17:37,662 --> 00:17:39,870
กับสภาพแวดล้อมนี้และ
ภาษานี้และอื่น ๆ

361
00:17:39,870 --> 00:17:42,370
คุณจะเริ่มเห็นสิ่งที่
มีทั้งที่ถูกต้องหรือไม่ถูกต้อง

362
00:17:42,370 --> 00:17:44,369
>> และนี่คือสิ่งที่
ทุนเรียนการสอนและการเรียนการสอน

363
00:17:44,369 --> 00:17:48,780
ผู้ช่วยได้รับดีเพื่อที่เมื่อเวลาผ่านไปเป็น
จำข้อผิดพลาดหรือข้อบกพร่องในรหัสของคุณ

364
00:17:48,780 --> 00:17:52,110
แต่ผมอ้างว่ามี
ข้อบกพร่องในรหัสนี้

365
00:17:52,110 --> 00:17:53,990
ดังนั้นตอนนี้ฉันต้องการที่จะเรียกใช้โปรแกรมนี้

366
00:17:53,990 --> 00:17:57,440
>> ตอนนี้บน Mac ของตัวเองหรือ PC ฉันอยู่ใน
นิสัยของไอคอนดับเบิลคลิก

367
00:17:57,440 --> 00:17:59,350
เมื่อฉันต้องการที่จะเรียกใช้โปรแกรมบางอย่าง

368
00:17:59,350 --> 00:18:01,080
แต่นั่นไม่ใช่รูปแบบที่นี่

369
00:18:01,080 --> 00:18:04,570
ในสภาพแวดล้อมนี้ซึ่งเป็น IDE CS50

370
00:18:04,570 --> 00:18:07,192
เราจะใช้ในการดำเนินงาน
ระบบที่เรียกว่าลินุกซ์

371
00:18:07,192 --> 00:18:09,900
ลินุกซ์เป็นที่ระลึกอีก
ระบบปฏิบัติการที่รู้จักโดยทั่วไป

372
00:18:09,900 --> 00:18:10,850
เป็นระบบปฏิบัติการยูนิกซ์

373
00:18:10,850 --> 00:18:16,340
และลินุกซ์เป็นที่รู้จักกันโดยเฉพาะอย่างยิ่งสำหรับ
มีสายสิ่งแวดล้อมสั่ง CLI

374
00:18:16,340 --> 00:18:20,070
ตอนนี้เรากำลังใช้ที่เฉพาะเจาะจง
รสชาติของลินุกซ์ที่เรียกว่าอูบุนตู

375
00:18:20,070 --> 00:18:22,770
และ Ubuntu เป็นเพียง
รุ่นหนึ่งของลินุกซ์

376
00:18:22,770 --> 00:18:27,900
>> แต่ลินุกซ์เหล่านี้ทำวันนี้จริง
มาพร้อมกับอินเตอร์เฟซผู้ใช้แบบกราฟิก

377
00:18:27,900 --> 00:18:30,360
และคนที่เราเกิดขึ้นกับ
จะใช้ที่นี่เป็น web-based

378
00:18:30,360 --> 00:18:32,735
ดังนั้นนี่อาจจะดูแม้กระทั่ง
ที่แตกต่างกันเล็ก ๆ น้อย ๆ จากบางสิ่งบางอย่าง

379
00:18:32,735 --> 00:18:35,310
คุณเองอาจจะมี
เห็นหรือทำงานในอดีตที่ผ่านมา

380
00:18:35,310 --> 00:18:37,910
>> ดังนั้นฉันจะไปข้างหน้า
ในขณะนี้และทำต่อไปนี้

381
00:18:37,910 --> 00:18:40,950
ผมเคยบันทึกแฟ้มนี้เป็น hello.c

382
00:18:40,950 --> 00:18:47,350
ฉันจะไปข้างหน้าและ
ประเภท clanghello.c ดังนั้นเสียงดังกราว

383
00:18:47,350 --> 00:18:49,850
สำหรับภาษา C เป็นคอมไพเลอร์

384
00:18:49,850 --> 00:18:51,952
มันติดตั้งใน CS50 IDE

385
00:18:51,952 --> 00:18:54,910
และคุณอย่างแน่นอนสามารถดาวน์โหลดและ
ติดตั้งบน Mac ของคุณเองหรือเครื่องคอมพิวเตอร์

386
00:18:54,910 --> 00:18:57,910
>> แต่อีกครั้งคุณจะไม่ได้ทั้งหมดของ
ก่อนการกำหนดค่าทำเพื่อคุณ

387
00:18:57,910 --> 00:19:00,940
ดังนั้นตอนนี้ฉันแค่
จะไปทำงาน clanghello.c

388
00:19:00,940 --> 00:19:03,240
และตอนนี้สังเกตเห็นรูปแบบนี้
ที่นี่จะมีในที่สุด

389
00:19:03,240 --> 00:19:06,930
ตระหนักถึงเพียงหมายความว่าผมอยู่ใน
โฟลเดอร์หรือไดเรกทอรีที่เรียกว่าพื้นที่ทำงาน

390
00:19:06,930 --> 00:19:11,030
เครื่องหมายดอลลาร์นี่เป็นเพียงการประชุม
สำหรับความหมายพิมพ์คำสั่งของคุณที่นี่

391
00:19:11,030 --> 00:19:14,560
>> มันเป็นสิ่งที่เรียกว่าพรอมต์เพียง
โดยการประชุมเป็นเครื่องหมายดอลลาร์

392
00:19:14,560 --> 00:19:19,130
และถ้าผมไปข้างหน้าในขณะนี้และคลิก
ใส่ดูเหมือนจะไม่มีอะไรเกิดขึ้น

393
00:19:19,130 --> 00:19:20,930
แต่ที่จริงเป็นสิ่งที่ดี

394
00:19:20,930 --> 00:19:23,650
น้อยกว่าที่เกิดขึ้นใน
หน้าจอของคุณมีโอกาสมากขึ้น

395
00:19:23,650 --> 00:19:26,710
รหัสของคุณถูกต้อง
อย่างน้อย syntactically

396
00:19:26,710 --> 00:19:29,120
>> ดังนั้นถ้าผมต้องการที่จะทำงานนี้
โปรแกรมฉันจะทำอย่างไร?

397
00:19:29,120 --> 00:19:33,770
ดีก็ปรากฎว่า
ชื่อเริ่มต้นโดยการประชุม

398
00:19:33,770 --> 00:19:38,854
สำหรับโปรแกรมเมื่อคุณไม่ได้ระบุ
ชื่อสำหรับโปรแกรมของคุณเป็นเพียง a.out

399
00:19:38,854 --> 00:19:41,270
และรูปแบบนี้มากเกินไปที่คุณจะ
ได้คุ้นเคยกับก่อนที่จะยาว

400
00:19:41,270 --> 00:19:47,500
>> Dot เฉือนก็หมายความว่าเดี๋ยวก่อน CS50
IDE เรียกใช้โปรแกรมที่เรียกว่า a.out

401
00:19:47,500 --> 00:19:49,400
ที่อยู่ภายในไดเรกทอรีปัจจุบันของฉัน

402
00:19:49,400 --> 00:19:51,520
จุดที่หมายถึงไดเรกทอรีปัจจุบัน

403
00:19:51,520 --> 00:19:55,040
และเราจะเห็นสิ่งอื่น ๆ เช่นลำดับ
ของตัวละครหมายความว่าอีกไม่นาน

404
00:19:55,040 --> 00:19:58,430
>> ดังนั้นที่นี่เราไปใส่, Hello World

405
00:19:58,430 --> 00:20:00,080
และคุณจะสังเกตเห็นว่าสิ่งที่เกิดขึ้น?

406
00:20:00,080 --> 00:20:01,580
ไม่เพียง แต่มันพิมพ์ Hello World

407
00:20:01,580 --> 00:20:05,990
นอกจากนี้ยังย้าย
เคอร์เซอร์บรรทัดถัดไป

408
00:20:05,990 --> 00:20:07,160
>> และทำไมเป็นเช่นนั้น?

409
00:20:07,160 --> 00:20:12,400
สิ่งที่เป็นรหัสที่เราเขียนก่อน
ที่ทำให้มั่นใจได้ว่าเคอร์เซอร์จะ

410
00:20:12,400 --> 00:20:14,882
ไปในบรรทัดถัดไป?

411
00:20:14,882 --> 00:20:16,840
สิ่งที่ตลกเกี่ยวกับ
คอมพิวเตอร์คือมันเพียงจะ

412
00:20:16,840 --> 00:20:18,570
ที่จะทำอย่างแท้จริงสิ่งที่คุณบอกว่าจะทำอย่างไร

413
00:20:18,570 --> 00:20:26,050
>> ดังนั้นถ้าคุณบอกให้ printf สวัสดี
จุลภาค, พื้นที่, โลกใกล้อ้าง

414
00:20:26,050 --> 00:20:29,090
มันอย่างแท้จริงเท่านั้นจะ
พิมพ์ตัวอักษรเหล่านั้น

415
00:20:29,090 --> 00:20:31,980
แต่ฉันมีตัวละครพิเศษนี้
ในตอนท้ายจำทับขวาเอ็น

416
00:20:31,980 --> 00:20:34,230
และนั่นคือสิ่งที่ทำให้มั่นใจได้
ว่าตัวละครไป

417
00:20:34,230 --> 00:20:36,570
ยังบรรทัดถัดไปของหน้าจอ

418
00:20:36,570 --> 00:20:38,097
>> ในความเป็นจริงให้ฉันไปและทำเช่นนี้

419
00:20:38,097 --> 00:20:39,430
ให้ฉันไปข้างหน้าและลบ

420
00:20:39,430 --> 00:20:41,180
ตอนนี้สังเกตเห็นว่า
ด้านบนของหน้าจอของฉันมี

421
00:20:41,180 --> 00:20:42,890
แสงสีแดงเล็ก ๆ น้อย ๆ ใน
แสดงให้เห็นแท็บ

422
00:20:42,890 --> 00:20:45,047
เดี๋ยวก่อนคุณไม่ได้บันทึกไฟล์ของคุณ

423
00:20:45,047 --> 00:20:47,880
ดังนั้นฉันจะไปข้างหน้ากับการควบคุม
S หรือคำสั่ง S บันทึกแฟ้ม

424
00:20:47,880 --> 00:20:51,130
ตอนนี้มัน goes-- ไปสำหรับสีเขียว moment--

425
00:20:51,130 --> 00:20:53,760
และตอนนี้ก็กลับไป
เป็นเพียงไอคอนใกล้

426
00:20:53,760 --> 00:21:01,860
>> ถ้าตอนนี้ผมทำงาน clanghello.c อีกครั้ง
ใส่จุดเฉือน a.out, Enter,

427
00:21:01,860 --> 00:21:04,110
คุณจะเห็นว่ามันจะยังคงทำงาน

428
00:21:04,110 --> 00:21:06,020
แต่มันเป็นเนื้อหาที่รถม้าชนิดเล็ก ๆ น้อย ๆ

429
00:21:06,020 --> 00:21:08,714
ตอนนี้พื้นที่ทำงาน prompt-- ของฉัน
แล้วที่เครื่องหมายดอลลาร์

430
00:21:08,714 --> 00:21:10,880
แล้ว prompt-- ที่เกิดขึ้นจริงของฉัน
คือทั้งหมดในบรรทัดเดียวกัน

431
00:21:10,880 --> 00:21:14,540
ดังนั้นนี้อย่างแน่นอนข้อผิดพลาดความงาม
ถึงแม้ว่ามันจะไม่ได้จริงๆข้อผิดพลาดเชิงตรรกะ

432
00:21:14,540 --> 00:21:16,250
>> ดังนั้นฉันจะเลิกทำสิ่งที่ผมก็ไม่ได้

433
00:21:16,250 --> 00:21:18,560
ฉันจะเรียก a.out

434
00:21:18,560 --> 00:21:22,710
สังเกตเห็นฉันได้เพิ่ม
อักขระ newline กลับ

435
00:21:22,710 --> 00:21:24,280
ผมเคยบันทึกไฟล์

436
00:21:24,280 --> 00:21:31,630
>> ดังนั้นฉันจะเรียก a.out, and--
บ้า, ข้อผิดพลาด, ความผิดพลาดข้อผิดพลาดความหมาย

437
00:21:31,630 --> 00:21:35,020
ดังนั้นข้อผิดพลาดคือว่าถึงแม้
ฉันเพิ่มเครื่องหมาย n มี

438
00:21:35,020 --> 00:21:41,180
อีกครั้งที่บันทึกไว้อีกครั้งวิ่งโปรแกรม
ลักษณะการทำงานได้เหมือนกัน

439
00:21:41,180 --> 00:21:42,640
ทำไมว่าจะเป็นอย่างไร

440
00:21:42,640 --> 00:21:43,910
>> ฉันหายไปขั้นตอนใช่มั้ย?

441
00:21:43,910 --> 00:21:47,620
ว่าขั้นตอนสำคัญก่อนหน้านี้คือการที่คุณมี
to-- เมื่อคุณเปลี่ยนรหัสที่มาของคุณ

442
00:21:47,620 --> 00:21:49,610
มันจะเปิดออกก็วิ่ง
มันผ่านคอมไพเลอร์

443
00:21:49,610 --> 00:21:51,102
อีกครั้งเพื่อให้คุณได้รับรหัสเครื่องใหม่

444
00:21:51,102 --> 00:21:52,810
และรหัสเครื่อง
เลขศูนย์และคน

445
00:21:52,810 --> 00:21:56,260
เป็นไปได้เหมือนกันเกือบ แต่
ไม่ได้อย่างสมบูรณ์แบบนั้นเพราะเราต้องการ

446
00:21:56,260 --> 00:21:57,510
แน่นอนว่าการขึ้นบรรทัดใหม่

447
00:21:57,510 --> 00:22:02,640
>> ดังนั้นการแก้ไขปัญหานี้ผมจะต้อง
เพื่อเรียก clanghello.c ป้อนจุด

448
00:22:02,640 --> 00:22:03,800
เฉือน a.out

449
00:22:03,800 --> 00:22:08,402
และตอนนี้ Hello World จะกลับมา
ไปที่ผมคาดหวังให้เป็น

450
00:22:08,402 --> 00:22:09,610
ดังนั้นนี่เป็นสิ่งที่ดีและดี

451
00:22:09,610 --> 00:22:13,150
แต่ a.out เป็นชื่อที่โง่สวยสำหรับ
โปรแกรมแม้ว่ามันจะเกิดขึ้นจะเป็น

452
00:22:13,150 --> 00:22:16,530
สำหรับเหตุผลทางประวัติศาสตร์
default-- หมายถึงผลประกอบ

453
00:22:16,530 --> 00:22:20,780
>> แต่ให้ฉันไปข้างหน้านี่
และทำเช่นนี้แตกต่างกัน

454
00:22:20,780 --> 00:22:24,760
ฉันต้องการให้โปรแกรม Hello World ของฉัน
ที่จริงจะเรียกว่าสวัสดี

455
00:22:24,760 --> 00:22:28,320
ดังนั้นถ้าเป็นไอคอนบนของฉัน
สก์ท็อปก็จะไม่ได้รับการ a.out

456
00:22:28,320 --> 00:22:29,730
มันจะเรียกว่าสวัสดี

457
00:22:29,730 --> 00:22:33,660
>> ดังนั้นการทำเช่นนี้ก็จะเปิดออก
ที่เสียงดังกราวเหมือนหลายโปรแกรม

458
00:22:33,660 --> 00:22:37,980
สนับสนุนข้อโต้แย้งบรรทัดคำสั่ง
หรือธงหรือสวิทช์

459
00:22:37,980 --> 00:22:39,600
ซึ่งก็มีอิทธิพลต่อพฤติกรรมของมัน

460
00:22:39,600 --> 00:22:45,160
โดยเฉพาะเสียงดังกราวสนับสนุนรีบ o
ธงซึ่งจากนั้นจะใช้เวลาสองคำ

461
00:22:45,160 --> 00:22:48,190
ในกรณีนี้ผมจะพล
แต่พอสมควรเรียกว่าสวัสดี

462
00:22:48,190 --> 00:22:50,710
แต่ผมสามารถเรียกมันว่าอะไร
ฉันต้องการยกเว้น a.out ซึ่ง

463
00:22:50,710 --> 00:22:52,390
จะค่อนข้างนอกเหนือจากจุด

464
00:22:52,390 --> 00:22:55,640
>> แล้วเพียงแค่ระบุชื่อ
ของไฟล์ที่ผมไม่ต้องการที่จะรวบรวม

465
00:22:55,640 --> 00:22:59,190
ดังนั้นตอนนี้แม้ว่าที่จุดเริ่มต้น
ของคำสั่งฉันยังคงมีเสียงดังกราว,

466
00:22:59,190 --> 00:23:01,410
ในตอนท้ายของคำสั่ง
ฉันยังคงมีชื่อไฟล์

467
00:23:01,410 --> 00:23:05,520
ตอนนี้ผมมีบรรทัดคำสั่งเหล่านี้
ข้อโต้แย้งธงเหล่านี้ที่จะพูดว่า

468
00:23:05,520 --> 00:23:11,180
โอ้โดยวิธีการที่การส่งออก-O ไฟล์
เรียกว่าสวัสดีไม่ a.out เริ่มต้น

469
00:23:11,180 --> 00:23:13,810
>> ดังนั้นถ้าฉันกด Enter ตอนนี้ไม่มีอะไร
ดูเหมือนจะเกิดขึ้น

470
00:23:13,810 --> 00:23:17,900
และยังตอนนี้ฉันสามารถทำจุดเฉือนสวัสดี

471
00:23:17,900 --> 00:23:19,089
ดังนั้นจึงเป็นโปรแกรมเดียวกัน

472
00:23:19,089 --> 00:23:21,380
เลขศูนย์และคนที่มี
เหมือนกันในตอนท้ายของวัน

473
00:23:21,380 --> 00:23:24,210
>> แต่พวกเขากำลังอยู่ในสอง
a.out files-- ที่แตกต่างกัน

474
00:23:24,210 --> 00:23:26,490
ซึ่งเป็นรุ่นแรก
และเพียงแค่ชื่อเขลา

475
00:23:26,490 --> 00:23:30,250
และตอนนี้สวัสดีซึ่งเป็นมาก
ชื่อน่าสนใจมากขึ้นสำหรับโปรแกรมที่

476
00:23:30,250 --> 00:23:33,195
แต่ตรงไปตรงมาผมไม่เคย
จะจำไว้ว่านี้อีกครั้ง

477
00:23:33,195 --> 00:23:34,070
และอีกครั้งและอีกครั้ง

478
00:23:34,070 --> 00:23:36,411
และในความเป็นจริงที่เราเขียน
โปรแกรมที่ซับซ้อนมากขึ้น

479
00:23:36,411 --> 00:23:38,160
คำสั่งที่คุณ
จะต้องมีการเขียน

480
00:23:38,160 --> 00:23:40,920
จะได้รับแม้กระทั่ง
ยังคงความซับซ้อนมากขึ้น

481
00:23:40,920 --> 00:23:41,940
>> จึงไม่ต้องกังวล

482
00:23:41,940 --> 00:23:46,220
แต่กลับกลายเป็นว่ามนุษย์ก่อน
เราได้ตระหนักว่าพวกเขามากเกินไป

483
00:23:46,220 --> 00:23:47,530
มีปัญหาเดียวกันนี้แน่นอน

484
00:23:47,530 --> 00:23:50,900
พวกเขาก็ไม่ได้สนุกกับต้อง
พิมพ์นานพอสมควรคำสั่งลับ

485
00:23:50,900 --> 00:23:52,200
นับประสาจำของพวกเขา

486
00:23:52,200 --> 00:23:56,070
และเพื่อให้มนุษย์ก่อนที่เราได้ทำ
โปรแกรมอื่น ๆ ที่ทำให้มันง่ายขึ้น

487
00:23:56,070 --> 00:23:57,670
เพื่อรวบรวมซอฟต์แวร์ของคุณ

488
00:23:57,670 --> 00:24:01,609
>> และแน่นอนหนึ่งเช่น
โปรแกรมที่เรียกว่าทำให้

489
00:24:01,609 --> 00:24:03,150
ดังนั้นฉันจะไปข้างหน้าและทำเช่นนี้

490
00:24:03,150 --> 00:24:05,691
ฉันจะเลิกทำทุกอย่างที่ฉัน
ก็ไม่ได้ในทางดังต่อไปนี้

491
00:24:05,691 --> 00:24:07,690
ให้ฉันพิมพ์ LS

492
00:24:07,690 --> 00:24:10,980
และคุณจะสังเกตเห็นสาม things--
a.out และดาวสวัสดี

493
00:24:10,980 --> 00:24:12,810
และเป็นดาวและ hello.c

494
00:24:12,810 --> 00:24:14,730
หวังว่านี้ควร
จะใช้งานง่ายเพียงเล็กน้อย

495
00:24:14,730 --> 00:24:18,220
ตราบเท่าที่ก่อนหน้านี้มี
ไม่มีอะไรในพื้นที่นี้

496
00:24:18,220 --> 00:24:21,240
ไม่มีอะไรที่ผมมีคือ
สร้างจนกว่าเราจะเริ่มต้นระดับ

497
00:24:21,240 --> 00:24:22,840
>> และฉันสร้าง hello.c

498
00:24:22,840 --> 00:24:24,544
จากนั้นผมก็รวบรวมมันและเรียกมันว่า a.out

499
00:24:24,544 --> 00:24:27,460
และจากนั้นผมรวบรวมอีกครั้งเล็กน้อย
ที่แตกต่างกันและเรียกมันว่าสวัสดี

500
00:24:27,460 --> 00:24:32,830
ดังนั้นผมจึงมีสามไฟล์ในไดเรกทอรีนี้
ในโฟลเดอร์ที่เรียกว่าพื้นที่ทำงานนี้

501
00:24:32,830 --> 00:24:35,005
ตอนนี้ผมสามารถมองเห็นเช่นกันว่า
ถ้าฉันซูมออกจริง

502
00:24:35,005 --> 00:24:37,530
>> ถ้าฉันซูมออกที่นี่และ
มองไปที่มือข้างขวาที่ด้านบน

503
00:24:37,530 --> 00:24:39,940
มุมเป็นสัญญาทางด้านซ้าย
ด้านซ้ายมือของหน้าจอ

504
00:24:39,940 --> 00:24:42,990
มักจะแสดงให้คุณ
สิ่งที่อยู่ในบัญชีของคุณคืออะไร

505
00:24:42,990 --> 00:24:44,790
ภายในของ CS50 IDE

506
00:24:44,790 --> 00:24:46,680
และมีสามไฟล์มี

507
00:24:46,680 --> 00:24:49,070
>> ดังนั้นผมจึงต้องการที่จะกำจัดของ a.out และสวัสดี

508
00:24:49,070 --> 00:24:51,275
และในขณะที่คุณอาจ
นึกสังหรณ์ใจคุณ

509
00:24:51,275 --> 00:24:53,400
สามารถเรียงลำดับของการควบคุมการคลิก
หรือคลิกขวาบนนี้

510
00:24:53,400 --> 00:24:54,590
และเมนูเล็ก ๆ นี้ปรากฏขึ้น

511
00:24:54,590 --> 00:24:57,170
คุณสามารถดาวน์โหลดไฟล์เรียกใช้
มันดูตัวอย่างรีเฟรช, เปลี่ยนชื่อ

512
00:24:57,170 --> 00:24:57,700
หรือสิ่งที่ไม่

513
00:24:57,700 --> 00:25:00,260
>> และฉันก็สามารถลบ
และมันก็จะหายไป

514
00:25:00,260 --> 00:25:05,260
แต่ขอทำสิ่งที่มีคำสั่ง
สายสำหรับตอนนี้เพื่อให้ได้รับความสะดวกสบาย

515
00:25:05,260 --> 00:25:07,010
กับเรื่องนี้และทำต่อไปนี้

516
00:25:07,010 --> 00:25:12,345
ฉันจะไปข้างหน้าและลบ
a.out โดยการพิมพ์ตัวอักษร rma.out

517
00:25:12,345 --> 00:25:14,890
มันจะเปิดออกคำสั่งสำหรับ
การลบหรือลบบางสิ่งบางอย่าง

518
00:25:14,890 --> 00:25:16,280
ไม่ได้ลบหรือลบ

519
00:25:16,280 --> 00:25:21,260
>> มันขึ้นชัดถ้อยชัดคำ RM, เพียงเพื่อประหยัด
คุณกดแป้นพิมพ์บางส่วนและกด Enter

520
00:25:21,260 --> 00:25:24,707
ตอนนี้เรากำลังจะได้รับบ้าง
ความลับเอา a.out แฟ้มปกติ

521
00:25:24,707 --> 00:25:27,040
ผมไม่ทราบจริงๆสิ่งที่เป็น
ไฟล์ที่ผิดปกติจะยัง

522
00:25:27,040 --> 00:25:28,660
แต่ฉันไม่ต้องการที่จะเอามันออกไป

523
00:25:28,660 --> 00:25:30,150
>> ดังนั้นฉันจะพิมพ์ Y สำหรับใช่

524
00:25:30,150 --> 00:25:31,940
หรือฉันสามารถพิมพ์ออกมาและกด Enter

525
00:25:31,940 --> 00:25:33,440
และอีกครั้งดูเหมือนจะไม่มีอะไรเกิดขึ้น

526
00:25:33,440 --> 00:25:35,840
แต่นั่นคือโดยทั่วไปเป็นสิ่งที่ดี

527
00:25:35,840 --> 00:25:40,490
>> ถ้าฉันพิมพ์ LS เวลานี้
สิ่งที่ฉันควรจะเห็น?

528
00:25:40,490 --> 00:25:44,930
หวังเพียงแค่สวัสดีและ hello.c

529
00:25:44,930 --> 00:25:47,286
ตอนนี้เช่นกันคุณจะ
แจ้งให้ทราบล่วงหน้าแห่งนี้เครื่องหมายดอกจัน

530
00:25:47,286 --> 00:25:48,660
ที่ในตอนท้ายของโปรแกรมของฉัน

531
00:25:48,660 --> 00:25:50,201
และพวกเขายังแสดงในสีเขียว

532
00:25:50,201 --> 00:25:53,970
นั่นเป็นเพียงวิธี CS50 IDE ของ
ของ cluing คุณเข้าสู่ความเป็นจริง

533
00:25:53,970 --> 00:25:55,280
ว่าที่ไม่ได้รหัสที่มา

534
00:25:55,280 --> 00:25:58,880
นั่นคือปฏิบัติการเป็นที่ทำงาน
โปรแกรมที่คุณสามารถทำงานได้จริง

535
00:25:58,880 --> 00:26:01,020
โดยทำจุดเฉือนและจากนั้นชื่อของมัน

536
00:26:01,020 --> 00:26:05,860
>> ตอนนี้ให้ฉันไปข้างหน้าและลบ
นี้ RM สวัสดีป้อนลบปกติ

537
00:26:05,860 --> 00:26:08,010
ยื่นสวัสดีใช่

538
00:26:08,010 --> 00:26:11,180
และตอนนี้ถ้าผมพิมพ์ LS,
เรากลับไป hello.c

539
00:26:11,180 --> 00:26:13,917
พยายามที่จะไม่ลบ
รหัสที่มาที่เกิดขึ้นจริง

540
00:26:13,917 --> 00:26:16,250
ถึงแม้ว่าจะมีคุณสมบัติ
ที่สร้างขึ้นใน CS50 IDE ที่

541
00:26:16,250 --> 00:26:19,870
คุณสามารถไปถึงประวัติการแก้ไขของคุณ
และย้อนกลับในเวลาที่ถ้าคุณตั้งใจ

542
00:26:19,870 --> 00:26:23,660
ลบสิ่งที่ทำจะมีสติ
ตามที่ระบบแจ้งเหล่านี้ใช่หรือไม่

543
00:26:23,660 --> 00:26:25,381
สิ่งที่คุณต้องการจะทำจริง

544
00:26:25,381 --> 00:26:27,380
และถ้าเราไปขึ้นไปด้านบน
มุมซ้ายมือนี่

545
00:26:27,380 --> 00:26:30,696
ทั้งหมดที่ยังคงเป็น hello.c

546
00:26:30,696 --> 00:26:32,570
เพื่อให้มีที่อัดแน่นของ
คำสั่งอื่น ๆ ที่คุณ

547
00:26:32,570 --> 00:26:37,550
สามารถดำเนินการในโลกของลินุกซ์
ซึ่งหนึ่งในนั้นคืออีกครั้งให้

548
00:26:37,550 --> 00:26:40,180
และเรากำลังจะทำให้
โปรแกรมของฉันตอนนี้ดังต่อไปนี้

549
00:26:40,180 --> 00:26:43,270
>> แทนการทำเสียงดังกราว,
แทนการทำเสียงดังกราว-O,

550
00:26:43,270 --> 00:26:45,860
ฉันจะเพียงแค่
ตัวอักษรพิมพ์ให้สวัสดี

551
00:26:45,860 --> 00:26:49,630
และตอนนี้สังเกตเห็นผม
ไม่ได้ทำให้การพิมพ์ hello.c

552
00:26:49,630 --> 00:26:50,910
ฉันพิมพ์ให้สวัสดี

553
00:26:50,910 --> 00:26:54,840
>> และโปรแกรมนี้ทำให้
มาพร้อมกับ IDE CS50 และอื่น ๆ

554
00:26:54,840 --> 00:26:57,090
โดยทั่วไปกับลินุกซ์
เป็นโปรแกรมที่เป็น

555
00:26:57,090 --> 00:26:59,120
จะทำให้โปรแกรมที่เรียกว่าสวัสดี

556
00:26:59,120 --> 00:27:03,680
และก็จะถือว่าโดยการประชุม
ว่าถ้าโปรแกรมนี้สามารถทำ

557
00:27:03,680 --> 00:27:09,030
มันจะทำจากแหล่งที่มา
ไฟล์โค้ดสิ้นสุดในจุด C, hello.c

558
00:27:09,030 --> 00:27:12,210
>> ดังนั้นถ้าฉันกด Enter ตอนนี้ขอให้สังเกตว่า
คำสั่งที่ได้รับการดำเนินการ

559
00:27:12,210 --> 00:27:14,340
เป็นจริงได้อีกต่อไป
ก่อนที่จะขึ้นกว่า แต่ก่อน

560
00:27:14,340 --> 00:27:16,670
และนั่นเป็นเพราะเราได้
ที่กำหนดไว้ล่วงหน้า CS50 IDE ที่จะมี

561
00:27:16,670 --> 00:27:19,878
คุณสมบัติเพิ่มเติมบางอย่างในตัวว่า
เราไม่จำเป็นต้องเพียง แต่เร็ว ๆ นี้จะ

562
00:27:19,878 --> 00:27:23,470
แต่สิ่งที่สำคัญที่จะตระหนักถึง
คือตอนนี้ผมมีโปรแกรมสวัสดี

563
00:27:23,470 --> 00:27:27,080
>> ถ้าฉันพิมพ์ LS อีกครั้งฉัน
มีโปรแกรมทักทาย

564
00:27:27,080 --> 00:27:32,070
และฉันสามารถเรียกใช้มันด้วย
จุดเฉือน a.out ไม่มี

565
00:27:32,070 --> 00:27:35,590
เพราะจุดทั้งนี้
การออกกำลังกายเป็นจุดเฉือนสวัสดี

566
00:27:35,590 --> 00:27:38,089
และตอนนี้ฉันมีโปรแกรม Hello World ของฉัน

567
00:27:38,089 --> 00:27:39,880
ดังนั้นก้าวไปข้างหน้า
เราเกือบเสมอเพียง

568
00:27:39,880 --> 00:27:42,088
จะรวบรวมโปรแกรมของเรา
โดยใช้คำสั่งทำให้เป็น

569
00:27:42,088 --> 00:27:45,300
และจากนั้นเราจะเรียกพวกเขาโดย
จุดเฉือนและชื่อของโปรแกรม

570
00:27:45,300 --> 00:27:49,610
แต่ตระหนักถึงสิ่งที่ทำคือทำ
คุณคือมันไม่ได้เป็นตัวคอมไพเลอร์

571
00:27:49,610 --> 00:27:53,310
มันเป็นเพียงโปรแกรมอำนวยความสะดวก
ที่รู้วิธีที่จะเรียกคอมไพเลอร์

572
00:27:53,310 --> 00:27:56,470
ที่จะทำงานเพื่อที่คุณเองสามารถใช้งานได้

573
00:27:56,470 --> 00:28:00,220
>> สิ่งที่คำสั่งอื่น ๆ ที่มีอยู่ใน
ลินุกซ์และในการเปิด CS50 IDE?

574
00:28:00,220 --> 00:28:03,107
อีกไม่นานเราจะเห็นว่ามี
คำสั่งซีดี, เปลี่ยนไดเรกทอรี

575
00:28:03,107 --> 00:28:05,190
นี้ช่วยให้คุณภายใน
อินเตอร์เฟซบรรทัดคำสั่งของคุณ

576
00:28:05,190 --> 00:28:07,610
ก้าวไปข้างหน้าและด้านหลัง
และเปิดโฟลเดอร์ที่แตกต่างกัน

577
00:28:07,610 --> 00:28:08,860
โดยไม่ต้องใช้เมาส์ของคุณ

578
00:28:08,860 --> 00:28:12,470
>> LS เราเห็นซึ่งย่อมาจากรายการ
ไฟล์ในไดเรกทอรีปัจจุบัน

579
00:28:12,470 --> 00:28:14,650
ทำให้ผบ. คุณสามารถ
อาจจะเริ่มต้นที่จะสรุป

580
00:28:14,650 --> 00:28:18,150
สิ่งเหล่านี้หมายถึง now-- ทำให้ไดเรกทอรี
ถ้าคุณต้องการสร้างโฟลเดอร์

581
00:28:18,150 --> 00:28:21,270
RM สำหรับลบ, RM Dir สำหรับ
ลบ directory-- และเหล่านี้

582
00:28:21,270 --> 00:28:24,160
อีกครั้งเป็นบรรทัดคำสั่ง
เทียบเท่าของสิ่งที่คุณ

583
00:28:24,160 --> 00:28:26,945
สามารถทำใน CS50 IDE ด้วยเมาส์ของคุณ

584
00:28:26,945 --> 00:28:28,820
แต่เร็ว ๆ นี้จะได้พบกับ
ว่าบางครั้งมันก็เป็นเพียง

585
00:28:28,820 --> 00:28:30,610
เร็วมากที่จะทำ
สิ่งที่มีแป้นพิมพ์

586
00:28:30,610 --> 00:28:33,690
และท้ายที่สุดเป็นจำนวนมากมีประสิทธิภาพมากขึ้น

587
00:28:33,690 --> 00:28:36,440
>> แต่มันก็ยากที่จะยืนยันว่า
สิ่งที่เราได้รับการทำเพื่อให้ห่างไกล

588
00:28:36,440 --> 00:28:39,990
เป็นสิ่งที่มีประสิทธิภาพเมื่อทุก
เราได้รับการบอกว่ามีที่ Hello World

589
00:28:39,990 --> 00:28:43,740
และในความเป็นจริงผม hardcoded
คำ Hello World ลงในโปรแกรมของฉัน

590
00:28:43,740 --> 00:28:45,530
ไม่มีชีวิตชีวายัง

591
00:28:45,530 --> 00:28:49,320
รอยขีดข่วนเป็นลำดับความสำคัญ
สัปดาห์ที่ผ่านมาน่าสนใจมากขึ้น

592
00:28:49,320 --> 00:28:51,220
>> และเพื่อให้ได้รับมี

593
00:28:51,220 --> 00:28:55,310
ลองมาขั้นตอนต่อว่าโดย
วิธีการบางส่วนของฟังก์ชั่นเหล่านี้

594
00:28:55,310 --> 00:28:59,470
ดังนั้นไม่เพียง แต่ C มาพร้อมกับพริทฟ์
และอัดแน่นของฟังก์ชั่นอื่น ๆ

595
00:28:59,470 --> 00:29:01,850
บางอย่างที่เราจะเห็น
เมื่อเวลาผ่านไปก็ไม่ได้

596
00:29:01,850 --> 00:29:05,760
ทำให้มันง่ายที่ออกทางด้านขวา
ประตูในการได้รับการป้อนข้อมูลของผู้ใช้

597
00:29:05,760 --> 00:29:08,140
>> ในความเป็นจริงหนึ่งในจุดอ่อน
ของภาษาเช่น C,

598
00:29:08,140 --> 00:29:10,140
และแม้กระทั่ง Java และยัง
คนอื่น ๆ ก็คือว่ามันไม่ได้

599
00:29:10,140 --> 00:29:15,860
ทำให้ง่ายต่อการเพียงแค่ได้รับสิ่งที่ต้องการ
จำนวนเต็มจากผู้ใช้หรือสตริงคำ

600
00:29:15,860 --> 00:29:19,970
และวลีปล่อยให้สิ่งที่อยู่คนเดียวเช่น
ค่าจุดหรือตัวเลขจริงลอย

601
00:29:19,970 --> 00:29:23,240
ที่มีจุดทศนิยมและจริงๆ
หมายเลขนานที่สุดเท่าที่เราจะเห็นทันที

602
00:29:23,240 --> 00:29:27,000
ดังนั้นรายชื่อของฟังก์ชั่นนี้ได้ที่นี่เหล่านี้
เป็นเหมือนชิ้นส่วนปริศนา Scratch อื่น ๆ

603
00:29:27,000 --> 00:29:31,090
ที่เราได้ติดตั้งใน CS50
IDE ที่เราจะใช้เพียงไม่กี่สัปดาห์

604
00:29:31,090 --> 00:29:34,010
เป็นล้อการฝึกอบรมของแปลกและ
ในที่สุดก็จะนำพวกเขาออกและมอง

605
00:29:34,010 --> 00:29:37,210
ใต้ฝากระโปรงบางทีที่
ว่าสิ่งเหล่านี้จะถูกนำมาใช้

606
00:29:37,210 --> 00:29:40,460
>> แต่การที่จะทำเช่นนี้ขอ
จริงเขียนโปรแกรม

607
00:29:40,460 --> 00:29:41,770
ผมขอไปข้างหน้าในขณะนี้

608
00:29:41,770 --> 00:29:44,750
และฉันจะสร้างใหม่
โดยการคลิกที่ไฟล์นี้บวกเล็กน้อย

609
00:29:44,750 --> 00:29:45,970
และคลิกแฟ้มใหม่

610
00:29:45,970 --> 00:29:49,250
>> ฉันจะบันทึกต่อไปนี้
อย่างใดอย่างหนึ่งเช่นสมมติว่า string.c,

611
00:29:49,250 --> 00:29:50,750
เพราะผมต้องการที่จะเล่นกับสตริง

612
00:29:50,750 --> 00:29:53,990
และสตริงใน C เป็นเพียง
ลำดับของตัวอักษร

613
00:29:53,990 --> 00:29:56,090
ดังนั้นตอนนี้เราไปข้างหน้า
และทำต่อไปนี้

614
00:29:56,090 --> 00:30:01,204
>> รวมถึงมาตรฐานและ IO.h--
มันจะเปิดออกมาตรฐานการ IO

615
00:30:01,204 --> 00:30:03,360
IO ก็หมายความเข้าและส่งออก

616
00:30:03,360 --> 00:30:05,920
ดังนั้นมันกลับกลายเป็นว่า
บรรทัดนี้นี่คือสิ่งที่

617
00:30:05,920 --> 00:30:08,140
เป็นเพื่อนบ้านเราใช้ printf

618
00:30:08,140 --> 00:30:10,410
printf ของหลักสูตรผลิตออก

619
00:30:10,410 --> 00:30:15,000
ดังนั้นเพื่อที่จะใช้ printf ก็จะเปิด
ออกคุณต้องมีบรรทัดของรหัสนี้

620
00:30:15,000 --> 00:30:16,040
ที่ด้านบนของไฟล์ของคุณ

621
00:30:16,040 --> 00:30:18,456
>> และเราจะกลับมากับสิ่งที่
ที่จริงหมายความว่าอีกไม่นาน

622
00:30:18,456 --> 00:30:20,400
ปรากฎว่าใน
โปรแกรม C ใด ๆ ที่ฉันเขียน

623
00:30:20,400 --> 00:30:23,640
ฉันจะเริ่มต้นด้วย
รหัสที่มีลักษณะเช่นนี้

624
00:30:23,640 --> 00:30:26,860
และคุณจะสังเกตเห็น CS50 IDE และ
พัฒนาแบบบูรณาอื่น ๆ

625
00:30:26,860 --> 00:30:30,050
สภาพแวดล้อมเช่นนั้น
จะพยายามอย่างดีที่สุด

626
00:30:30,050 --> 00:30:31,780
พวกเขาสามารถที่จะจบความคิดของคุณ

627
00:30:31,780 --> 00:30:35,930
ในความเป็นจริงสักครู่ที่ผ่านมาถ้าผมเลิกทำ
สิ่งที่ฉันก็ไม่ได้ผมกด Enter

628
00:30:35,930 --> 00:30:39,160
>> จากนั้นผมก็ตีเปิดหยิก
รั้งกด Enter อีกครั้ง

629
00:30:39,160 --> 00:30:40,430
และจะเสร็จสิ้นการคิดของผม

630
00:30:40,430 --> 00:30:45,140
มันทำให้ผมเส้นใหม่เยื้องไม่น้อย
ด้วยเหตุผลโวหารดีเราจะเห็น

631
00:30:45,140 --> 00:30:48,559
และแล้วมันจะให้ฉัน
ที่วงเล็บปีกกาที่จะจบความคิดของฉัน

632
00:30:48,559 --> 00:30:50,600
ตอนนี้ก็ไม่เคย
คาดเดาสิ่งที่คุณต้องการจะทำ

633
00:30:50,600 --> 00:30:53,620
แต่ส่วนใหญ่ก็ไม่ได้
ช่วยให้คุณประหยัดการกดแป้นพิมพ์บาง

634
00:30:53,620 --> 00:30:59,560
ดังนั้นช่วงเวลาที่ผ่านมาเราวิ่ง program-- นี้
สวัสดีโลกและเรียบเรียงแล้วมัน

635
00:30:59,560 --> 00:31:00,460
และจากนั้นก็วิ่งมัน

636
00:31:00,460 --> 00:31:01,867
แต่ไม่มีชีวิตชีวาที่นี่

637
00:31:01,867 --> 00:31:03,700
เกิดอะไรขึ้นถ้าเราต้องการที่จะ
ทำสิ่งที่แตกต่างกันอย่างไร

638
00:31:03,700 --> 00:31:07,630
ดีสิ่งที่ถ้าฉันต้องการจริง
ได้รับสตริงจากผู้ใช้หรือไม่?

639
00:31:07,630 --> 00:31:11,250
ฉันจะใช้ชิ้นส่วนจิ๊กซอว์
เรียกว่าในปัจจุบันผู้ได้รับสตริง

640
00:31:11,250 --> 00:31:15,860
>> ปรากฎใน C ที่ว่าเมื่อคุณไม่ต้องการ
เพื่อให้เข้ากับชิ้นส่วนจิ๊กซอว์

641
00:31:15,860 --> 00:31:19,360
หรือมากกว่าฟังก์ชั่นอย่างถูกต้องเพื่อคุณ
แท้จริงเพียงแค่ทำเปิดวงเล็บ

642
00:31:19,360 --> 00:31:20,430
ใกล้วงเล็บ

643
00:31:20,430 --> 00:31:25,540
ดังนั้นจึงเป็นประหนึ่งว่ามี
ไม่มีกล่องสีขาวที่จะพิมพ์ลงใน

644
00:31:25,540 --> 00:31:27,720
กล่าวว่าก่อนที่จะบล็อก
มีกล่องสีขาวเล็ก ๆ น้อย ๆ

645
00:31:27,720 --> 00:31:29,660
เราไม่ได้ว่ากล่องสีขาวตอนนี้

646
00:31:29,660 --> 00:31:33,310
>> แต่เมื่อผมเรียกสตริงผม
ต้องการที่จะนำผลที่ได้จากที่ไหนสักแห่ง

647
00:31:33,310 --> 00:31:37,680
ดังนั้นกระบวนทัศน์ที่พบบ่อยมากใน C คือการ
เรียกฟังก์ชันเช่นสตริงได้รับที่นี่

648
00:31:37,680 --> 00:31:41,070
แล้วเก็บค่าตอบแทนของ

649
00:31:41,070 --> 00:31:44,450
มันเป็นผลมาจากมัน
ความพยายามในการบางสิ่งบางอย่าง

650
00:31:44,450 --> 00:31:47,630
>> และสิ่งที่เป็น
สร้างในการเขียนโปรแกรม

651
00:31:47,630 --> 00:31:53,450
ไม่ว่าจะเป็นรอยขีดข่วนหรือตอนนี้ซีว่าเรา
สามารถใช้ในการจัดเก็บจริงอะไร?

652
00:31:53,450 --> 00:31:55,990
เรียกมันว่าตัวแปรใช่มั้ย?

653
00:31:55,990 --> 00:32:00,320
และรอยขีดข่วนที่เราทำไม่ได้จริงๆ
สนใจสิ่งที่เกิดขึ้นในตัวแปร

654
00:32:00,320 --> 00:32:02,170
>> แต่ในกรณีนี้เราทำจริง

655
00:32:02,170 --> 00:32:03,719
ฉันจะบอกว่าสตริง

656
00:32:03,719 --> 00:32:05,510
แล้วฉันจะเรียก
สิ่งที่ฉันต้องการ

657
00:32:05,510 --> 00:32:08,340
ฉันจะเรียกมันว่า
ชื่อที่ได้รับได้รับสตริง

658
00:32:08,340 --> 00:32:10,250
>> และตอนนี้แม้ว่าคุณ
ใหม่เล็ก ๆ น้อย ๆ นี้

659
00:32:10,250 --> 00:32:11,984
แจ้งให้ทราบว่าผมขาดรายละเอียดบาง

660
00:32:11,984 --> 00:32:13,150
ฉันลืม semi-colon

661
00:32:13,150 --> 00:32:14,400
ฉันต้องการที่จะจบความคิดนี้

662
00:32:14,400 --> 00:32:17,480
ดังนั้นฉันจะเลื่อนเคอร์เซอร์ของฉัน
และกดกึ่งลำไส้ใหญ่มี

663
00:32:17,480 --> 00:32:19,130
และสิ่งที่ฉันได้เพียงแค่ทำ?

664
00:32:19,130 --> 00:32:21,440
ในสายของรหัสนี้
หมายเลข 5 ในขณะนี้

665
00:32:21,440 --> 00:32:23,799
ฉันโทรสตริงไม่มีปัจจัยการผลิต

666
00:32:23,799 --> 00:32:26,090
จึงไม่มีสีขาวเล็ก ๆ น้อย ๆ
กล่องเช่นบันทึกบล็อกมี

667
00:32:26,090 --> 00:32:28,590
>> ฉันแค่บอกเดี๋ยวก่อน
คอมพิวเตอร์ได้รับฉันสตริง

668
00:32:28,590 --> 00:32:31,390
เครื่องหมายเท่ากับไม่ได้จริงๆ
เครื่องหมายเท่ากับต่อ se

669
00:32:31,390 --> 00:32:33,790
มันเป็นเรื่องที่ได้รับมอบหมาย
ผู้ประกอบการซึ่งหมายถึง

670
00:32:33,790 --> 00:32:37,860
Hey, คอมพิวเตอร์, ย้ายค่า
จากขวาไปซ้าย

671
00:32:37,860 --> 00:32:40,480
และซ้ายที่ฉันมีดังต่อไปนี้

672
00:32:40,480 --> 00:32:43,580
>> Hey, คอมพิวเตอร์, ให้ฉัน string--
ลำดับของตัวอักษร

673
00:32:43,580 --> 00:32:45,637
และเรียกว่าสตริงชื่อ

674
00:32:45,637 --> 00:32:47,220
และผมก็ไม่ได้มีการเรียกชื่อ

675
00:32:47,220 --> 00:32:49,970
>> ฉันจะเรียกว่าอัตภาพ
บางอย่างเช่น S,

676
00:32:49,970 --> 00:32:52,900
เหมือนเราใช้ i เพื่อ
เรียกฉันตัวแปร

677
00:32:52,900 --> 00:32:54,829
แต่ตอนนี้ผมต้องทำอะไรกับมัน

678
00:32:54,829 --> 00:32:57,370
มันจะสวยโง่
พยายามรวบรวมรหัสนี้ทำงาน

679
00:32:57,370 --> 00:32:59,410
โปรแกรมนี้แม้ว่า
ฉันได้รับสตริง

680
00:32:59,410 --> 00:33:01,580
เพราะมันยังคงเป็นเพียง
จะบอกว่า Hello World

681
00:33:01,580 --> 00:33:06,140
>> แต่สิ่งที่ถ้าฉันไม่ต้องการที่จะเปลี่ยนแปลงนี้

682
00:33:06,140 --> 00:33:07,940
ทำไมถึงไม่ทำเช่นนี้?

683
00:33:07,940 --> 00:33:11,632
ร้อยละ S, s จุลภาค

684
00:33:11,632 --> 00:33:13,090
และนี่คือความลับเล็ก ๆ น้อย ๆ ยังคง

685
00:33:13,090 --> 00:33:15,560
>> ดังนั้นให้ฉันให้ฉันตัวแปรชัดเจนมากขึ้น

686
00:33:15,560 --> 00:33:17,510
ผมขอชื่อนี้ชื่อตัวแปร

687
00:33:17,510 --> 00:33:20,230
และขอให้ดูว่าเราไม่สามารถหยอกล้อ
นอกเหนือสิ่งที่เกิดขึ้นที่นี่

688
00:33:20,230 --> 00:33:22,770
>> ดังนั้นในบรรทัดห้าฉันได้รับสตริง

689
00:33:22,770 --> 00:33:25,620
และฉันเก็บสตริงที่
สิ่งที่ผู้ใช้มีการพิมพ์ใน

690
00:33:25,620 --> 00:33:28,430
ที่แป้นพิมพ์ของเขาหรือเธอ
ในตัวแปรเรียกชื่อ

691
00:33:28,430 --> 00:33:30,590
และปรากฎว่า
printf ไม่เพียง แต่

692
00:33:30,590 --> 00:33:34,220
ใช้เวลาหนึ่งในการโต้แย้งคู่
คำพูดหนึ่งในการป้อนข้อมูลคำพูดคู่

693
00:33:34,220 --> 00:33:39,100
>> มันสามารถใช้เวลาสองหรือสามหรือมากกว่าเช่น
ว่าที่สองหรือที่สามหรือสี่

694
00:33:39,100 --> 00:33:42,320
มีชื่อทั้งหมดของตัวแปร
หรือเฉพาะค่า

695
00:33:42,320 --> 00:33:48,610
ที่คุณต้องการที่จะเสียบเข้า
แบบไดนามิกที่สตริงในเครื่องหมายคำพูด

696
00:33:48,610 --> 00:33:52,110
ในคำอื่น ๆ สิ่งที่
จะมีความผิดกับเรื่องนี้?

697
00:33:52,110 --> 00:33:57,920
ถ้าฉันเพียงแค่กล่าวว่าสวัสดีชื่อทับขวา
N, บันทึกไฟล์ของฉันรวบรวมรหัสของฉัน

698
00:33:57,920 --> 00:34:01,660
และวิ่งไปนี้สิ่งที่จะเกิดขึ้น?

699
00:34:01,660 --> 00:34:05,139
>> มันเป็นเพียงแค่จะบอกว่าสวัสดี
ชื่ออักษร N-A-M-E

700
00:34:05,139 --> 00:34:07,900
ซึ่งเป็นชนิดของโง่เพราะ
ก็ไม่แตกต่างจากโลก

701
00:34:07,900 --> 00:34:10,400
ดังนั้นอะไรในคำพูดเป็น
สิ่งที่ได้รับการพิมพ์ตัวอักษร

702
00:34:10,400 --> 00:34:12,520
ดังนั้นถ้าฉันต้องการที่จะมี
ตัวยึดที่นั่น

703
00:34:12,520 --> 00:34:14,422
ที่จริงผมจำเป็นต้องใช้
บางไวยากรณ์พิเศษ

704
00:34:14,422 --> 00:34:17,380
และปรากฎถ้าคุณอ่าน
เอกสารสำหรับฟังก์ชั่น printf ที่

705
00:34:17,380 --> 00:34:21,320
มันจะบอกคุณว่า
ถ้าคุณใช้ร้อยละ S,

706
00:34:21,320 --> 00:34:23,920
คุณสามารถใช้แทนค่าดังต่อไปนี้

707
00:34:23,920 --> 00:34:27,190
>> หลังจากจุลภาคหลังจากที่
ราคาคู่คุณก็

708
00:34:27,190 --> 00:34:29,179
เขียนชื่อของ
ตัวแปรที่คุณต้องการ

709
00:34:29,179 --> 00:34:33,790
ในการเชื่อมต่อเป็นรูปแบบที่
รหัสหรือรูปแบบระบุ,

710
00:34:33,790 --> 00:34:35,469
ร้อยละ s สำหรับสตริง

711
00:34:35,469 --> 00:34:39,190
และตอนนี้ถ้าเราได้บันทึกไฟล์ของฉัน
ผมจะกลับไปลงไปยังสถานีของฉัน

712
00:34:39,190 --> 00:34:42,870
และฉันพิมพ์สตริง,
เพราะอีกชื่อนี้

713
00:34:42,870 --> 00:34:45,510
แฟ้มที่ผมเลือกก่อนที่จะเป็น string.c

714
00:34:45,510 --> 00:34:48,510
>> ดังนั้นฉันจะพูดสตริงป้อน

715
00:34:48,510 --> 00:34:51,550
โอ้ความดีให้ดูที่ทั้งหมดของ
ผิดพลาดที่เราได้ทำแล้ว

716
00:34:51,550 --> 00:34:55,540
และนี่ is-- สิ่งนี้เป็นจริง
เหมือนหกโปรแกรมบรรทัดเจ็ด?

717
00:34:55,540 --> 00:34:57,790
ดังนั้นนี่เป็นที่ที่มันสามารถมาก
ได้อย่างรวดเร็วอย่างท่วมท้น

718
00:34:57,790 --> 00:35:00,890
>> หน้าต่าง terminal นี้มี
ขณะนี้เป็นเพียงซาก

719
00:35:00,890 --> 00:35:03,230
เป็นจำนวนมากของข้อความผิดพลาด

720
00:35:03,230 --> 00:35:07,560
แน่นอนผมไม่ได้มีข้อผิดพลาดมากขึ้น
ข้อความกว่าที่ฉันมีสายรหัส

721
00:35:07,560 --> 00:35:08,680
ดังนั้นสิ่งที่เกิดขึ้น?

722
00:35:08,680 --> 00:35:10,920
>> ดีกลยุทธ์ที่ดีที่สุด
ที่จะทำทุกเวลาที่คุณ

723
00:35:10,920 --> 00:35:13,710
ไม่พบการครอบงำ
รายการข้อผิดพลาดเช่นนั้น

724
00:35:13,710 --> 00:35:16,690
จะเลื่อนกลับมองหาคำสั่ง
คุณเพียงแค่ขับรถซึ่งในกรณีของฉัน

725
00:35:16,690 --> 00:35:18,020
จะทำให้สตริง

726
00:35:18,020 --> 00:35:21,630
มองไปที่สิ่งที่ทำให้เขาและที่ว่า
คำสั่งเสียงดังกราวยาวไม่มีเรื่องใหญ่มี

727
00:35:21,630 --> 00:35:22,950
>> แต่สีแดงจะไม่ดี

728
00:35:22,950 --> 00:35:24,750
สีเขียวจะพยายามที่จะเป็น
อ่อนโยนและเป็นประโยชน์

729
00:35:24,750 --> 00:35:26,140
แต่ก็ยังคงไม่ดีในกรณีนี้

730
00:35:26,140 --> 00:35:27,510
แต่ที่มันไม่ดี?

731
00:35:27,510 --> 00:35:31,450
>> String.c สายห้าห้าตัวอักษร

732
00:35:31,450 --> 00:35:32,930
ดังนั้นนี้เป็นเพียงการประชุมร่วมกัน

733
00:35:32,930 --> 00:35:36,060
บางสิ่งบางอย่างบางสิ่งบางอย่างลำไส้ใหญ่หมายความว่า
หมายเลขบรรทัดและจำนวนตัวอักษร

734
00:35:36,060 --> 00:35:41,080
ข้อผิดพลาดที่ไม่ได้ประกาศใช้
สตริงระบุ

735
00:35:41,080 --> 00:35:42,900
คุณหมายถึงมาตรฐานมีอะไรบ้าง?

736
00:35:42,900 --> 00:35:45,530
>> ดังนั้นน่าเสียดายที่เสียงดังกราว
พยายามที่จะเป็นประโยชน์

737
00:35:45,530 --> 00:35:46,850
แต่มันเป็นเรื่องที่ไม่ถูกต้องในกรณีนี้

738
00:35:46,850 --> 00:35:49,350
ไม่มีเสียงดังกราวผมไม่ได้หมายความว่ามาตรฐาน IO

739
00:35:49,350 --> 00:35:51,070
ฉันหมายความว่าในบรรทัดเดียวใช่

740
00:35:51,070 --> 00:35:53,420
>> แต่บรรทัดห้าเป็นหนึ่งในที่นี่

741
00:35:53,420 --> 00:35:57,040
และเสียงดังกราวไม่
เข้าใจ S-T-R-I-N-G

742
00:35:57,040 --> 00:36:01,490
มันเป็นตัวระบุที่ไม่ได้ประกาศเป็น
คำมันก็ไม่เคยเห็นมาก่อน

743
00:36:01,490 --> 00:36:05,730
และนั่นเป็นเพราะ C, ภาษา
เรากำลังเขียนโค้ดในตอนนี้

744
00:36:05,730 --> 00:36:08,070
ไม่ได้เรียกว่าตัวแปรสตริง

745
00:36:08,070 --> 00:36:11,380
>> มันไม่ได้โดยเริ่มต้นการสนับสนุน
สิ่งที่เรียกว่าสตริง

746
00:36:11,380 --> 00:36:16,750
นั่นเป็นชิ้นส่วนของ CS50
ศัพท์แสง แต่เดิมมาก

747
00:36:16,750 --> 00:36:18,600
แต่ฉันสามารถแก้ไขปัญหานี้ดังต่อไปนี้

748
00:36:18,600 --> 00:36:22,090
>> ถ้าผมเพิ่มหนึ่งบรรทัดของรหัส
ไปด้านบนของโปรแกรมนี้

749
00:36:22,090 --> 00:36:27,890
รวม CS50.h ซึ่งเป็นไฟล์อื่น
ที่ไหนสักแห่งภายในของ CS50 IDE ที่ไหนสักแห่ง

750
00:36:27,890 --> 00:36:30,820
บนฮาร์ดไดรฟ์เพื่อที่จะพูด
ของระบบปฏิบัติการอูบุนตู

751
00:36:30,820 --> 00:36:33,590
ที่ผมทำงานที่
คือแฟ้มที่

752
00:36:33,590 --> 00:36:38,740
จะสอนปฏิบัติการ
ระบบสิ่งสตริงเป็นเพียงแค่

753
00:36:38,740 --> 00:36:41,930
เช่น io.h มาตรฐานคือไฟล์
ในระบบปฏิบัติการที่

754
00:36:41,930 --> 00:36:44,430
จะสอนว่าสิ่งที่เป็น printf

755
00:36:44,430 --> 00:36:46,810
>> แท้จริงเราจะได้รับ
ข้อความที่คล้ายกันมาก

756
00:36:46,810 --> 00:36:50,600
ถ้า IO ได้เข้ารับการรักษามาตรฐาน
IO.h และพยายามที่จะใช้ printf

757
00:36:50,600 --> 00:36:53,632
ดังนั้นฉันจะไปข้างหน้าและเพียงแค่
ใช้การควบคุม L เพื่อล้างหน้าจอของฉัน

758
00:36:53,632 --> 00:36:56,340
หรือคุณสามารถพิมพ์ชัดเจนและมันจะ
เพียงแค่ล้างหน้าต่าง terminal

759
00:36:56,340 --> 00:36:58,020
แต่คุณก็ยังสามารถเลื่อนกลับในเวลา

760
00:36:58,020 --> 00:37:01,100
>> และฉันจะเรียกสตริง

761
00:37:01,100 --> 00:37:03,660
ข้ามมือของฉันเวลานี้ใส่

762
00:37:03,660 --> 00:37:05,380
โอ้พระเจ้าของฉันมันทำงาน

763
00:37:05,380 --> 00:37:09,280
มันแสดงให้เห็นฉันคำสั่งลับยาว
นั่นคือสิ่งที่ทำให้สร้างผ่านเสียงดังกราว,

764
00:37:09,280 --> 00:37:10,460
แต่ไม่มีข้อผิดพลาด

765
00:37:10,460 --> 00:37:12,460
ดังนั้นตระหนักถึงแม้ว่า
คุณอาจได้รับสมบูรณ์

766
00:37:12,460 --> 00:37:14,480
จมกับ
จำนวนข้อความผิดพลาด

767
00:37:14,480 --> 00:37:17,540
มันก็อาจจะน่ารำคาญนี้ซ้อน
ผลกระทบที่เสียงดังกราวไม่เข้าใจ

768
00:37:17,540 --> 00:37:19,620
สิ่งหนึ่งซึ่งหมายความว่ามันแล้ว
ไม่เข้าใจคำถัดไป

769
00:37:19,620 --> 00:37:20,560
หรือบรรทัดถัดไป

770
00:37:20,560 --> 00:37:22,850
และดังนั้นจึงเพียงฉายาในรหัสของคุณ

771
00:37:22,850 --> 00:37:24,440
แต่การแก้ไขอาจจะง่าย

772
00:37:24,440 --> 00:37:27,822
และอื่น ๆ มักจะมุ่งเน้นไปที่
บรรทัดแรกของการส่งออกมาก

773
00:37:27,822 --> 00:37:29,530
และถ้าคุณทำไม่ได้
เข้าใจว่ามันเพียงแค่มอง

774
00:37:29,530 --> 00:37:32,480
สำหรับคำหลักที่อาจจะมี
เบาะแสและหมายเลขบรรทัด

775
00:37:32,480 --> 00:37:34,650
และตัวอักษรที่
ความผิดพลาดที่อาจจะ

776
00:37:34,650 --> 00:37:40,328
>> ตอนนี้ให้ฉันไปข้างหน้าและพิมพ์
จุดเฉือนสตริงป้อน

777
00:37:40,328 --> 00:37:44,340
อืมก็ไม่ได้พูดอะไรสวัสดี

778
00:37:44,340 --> 00:37:46,210
ทำไม?

779
00:37:46,210 --> 00:37:48,170
ดีจำได้ว่ามันเป็นที่ที่ทำงานอยู่หรือไม่

780
00:37:48,170 --> 00:37:53,730
>> มันอาจจะติดอยู่ในขณะนี้
ในวง, ถ้าคุณจะอยู่บนเส้นหก

781
00:37:53,730 --> 00:37:56,950
เพราะได้รับ String โดยการออกแบบ
เขียนโดยพนักงาน CS50,

782
00:37:56,950 --> 00:38:00,350
มีความหมายที่แท้จริงเพียงแค่นั่ง
มีรอและรอ

783
00:38:00,350 --> 00:38:01,850
และรอให้สตริง

784
00:38:01,850 --> 00:38:03,792
ทั้งหมดที่เราหมายถึงโดยสตริงคือการใส่มนุษย์

785
00:38:03,792 --> 00:38:04,500
เพื่อให้คุณรู้อะไรไหม

786
00:38:04,500 --> 00:38:05,166
ผมขอไปข้างหน้า

787
00:38:05,166 --> 00:38:08,704
และเพียงแค่ในราชประสงค์ให้ฉัน
พิมพ์ชื่อของฉันเดวิดป้อน

788
00:38:08,704 --> 00:38:10,120
ตอนนี้ผมมีโปรแกรมแบบไดนามิกมากขึ้น

789
00:38:10,120 --> 00:38:11,240
มันบอกว่าสวัสดีเดวิด

790
00:38:11,240 --> 00:38:16,280
>> ถ้าฉันไปข้างหน้าและทำงานนี้อีกครั้ง
ให้ฉันลองพูดชื่อ Zamila ป้อน

791
00:38:16,280 --> 00:38:17,940
และตอนนี้เรามีโปรแกรมแบบไดนามิก

792
00:38:17,940 --> 00:38:19,380
ฉันยังไม่ได้เขียนยากโลก

793
00:38:19,380 --> 00:38:21,760
ฉันยังไม่ได้เขียนยาก
ชื่อหรือเดวิดหรือ Zamila

794
00:38:21,760 --> 00:38:25,350
>> ตอนนี้ก็มากขึ้นเช่นโปรแกรม
เรารู้ว่าถ้ามันที่ใช้การป้อนข้อมูล

795
00:38:25,350 --> 00:38:27,870
มันผลิตออกแตกต่างกันเล็กน้อย

796
00:38:27,870 --> 00:38:31,020
ตอนนี้จะไม่ดีที่สุด
ประสบการณ์การใช้งานหรือ UX

797
00:38:31,020 --> 00:38:33,000
ฉันเรียกใช้โปรแกรม

798
00:38:33,000 --> 00:38:35,830
>> ผมไม่ทราบว่าสิ่งที่ฉันควร
ที่จะทำจริงเว้นแต่ฉันมองไปที่

799
00:38:35,830 --> 00:38:37,290
หรือจำรหัสที่มา

800
00:38:37,290 --> 00:38:39,640
ดังนั้นขอให้ผู้ใช้
ประสบการณ์ที่ดีขึ้นเล็กน้อย

801
00:38:39,640 --> 00:38:41,240
กับสิ่งที่ง่ายที่สุดของ

802
00:38:41,240 --> 00:38:44,782
ผมขอกลับไปเป็นแบบนี้
โปรแกรมและเพียงแค่พูด printf

803
00:38:44,782 --> 00:38:48,870
>> และแจ้งให้เราไปข้างหน้าและพูดชื่อของลำไส้ใหญ่
และพื้นที่แล้วเซมิโคลอน

804
00:38:48,870 --> 00:38:51,170
และเพียงเพื่อลูกไม่มีฟันเฟือง n

805
00:38:51,170 --> 00:38:52,980
และนั่นคือเจตนา
เพราะฉันไม่ต้องการ

806
00:38:52,980 --> 00:38:54,590
พรอมต์ที่จะย้ายไปบรรทัดถัดไป

807
00:38:54,590 --> 00:38:58,800
>> ฉันต้องการที่จะแทนการทำเช่นนี้ทำให้สตริง
คอมไพล์รหัสของฉันลงในเครื่องใหม่

808
00:38:58,800 --> 00:39:00,980
รหัส dot เฉือนสตริง

809
00:39:00,980 --> 00:39:02,460
Ah นี้เป็นสวยมาก

810
00:39:02,460 --> 00:39:05,780
ตอนนี้ที่จริงผมรู้ว่าสิ่งที่คอมพิวเตอร์
อยากให้ผมทำให้มันชื่อ

811
00:39:05,780 --> 00:39:10,020
>> ดังนั้นฉันจะไปข้างหน้าและพิมพ์
ในร็อบป้อนและสวัสดีร็อบ

812
00:39:10,020 --> 00:39:13,640
ดังนั้นตระหนักถึงนี้ยังคงเป็นที่สิ้นสุด
ในวันนี้เพียงโปรแกรมเก้าเส้น

813
00:39:13,640 --> 00:39:15,090
แต่เราได้ดำเนินการขั้นตอนทารกเหล่านี้

814
00:39:15,090 --> 00:39:18,380
>> เราเขียนบรรทัดเดียวกับที่เรา
เป็นที่คุ้นเคย printf, Hello World

815
00:39:18,380 --> 00:39:19,980
จากนั้นเราก็ undid เล็กน้อยว่า

816
00:39:19,980 --> 00:39:21,560
และเราใช้จริงสตริง

817
00:39:21,560 --> 00:39:23,362
และเราโยนค่านั้นในตัวแปร

818
00:39:23,362 --> 00:39:26,070
และจากนั้นเราเดินไปข้างหน้าและการปรับปรุง
มันต่อกับสายที่สาม

819
00:39:26,070 --> 00:39:29,220
และนี้กระบวนการซ้ำของ
การเขียนซอฟแวร์เป็นกุญแจสำคัญอย่างแท้จริง

820
00:39:29,220 --> 00:39:33,420
ใน CS50 และในชีวิตโดยทั่วไป
คุณควรทั่วไปไม่นั่งลง

821
00:39:33,420 --> 00:39:36,800
มีโปรแกรมในใจและลองเขียน
สิ่งแช่งทั้งทั้งหมดในครั้งเดียว

822
00:39:36,800 --> 00:39:40,810
>> มันจะย่อมส่งผลในทาง
ข้อผิดพลาดมากกว่าที่เราเห็นตัวเองที่นี่

823
00:39:40,810 --> 00:39:44,070
แม้ฉันไปในวันนี้อย่างต่อเนื่อง
ทำผิดพลาดโง่อื่น ๆ

824
00:39:44,070 --> 00:39:47,480
มีความผิดพลาดจริงยาก
ที่มีความยากที่จะคิดออก

825
00:39:47,480 --> 00:39:52,095
แต่คุณจะทำผิดพลาดมากขึ้นมากขึ้น
บรรทัดของรหัสที่คุณเขียนทั้งหมดในครั้งเดียว

826
00:39:52,095 --> 00:39:54,220
และเพื่อให้การปฏิบัตินี้
เขียนเล็กน้อยของรหัส

827
00:39:54,220 --> 00:39:57,930
ที่คุณสะดวกสบายกับการรวบรวม
มันเรียกใช้ทดสอบมากกว่าปกติ

828
00:39:57,930 --> 00:40:01,370
แล้วย้าย on-- เพื่อให้เหมือนกับที่เราเก็บไว้
layering และ layering สัปดาห์ที่ผ่านมา

829
00:40:01,370 --> 00:40:04,190
สร้างจากบางสิ่งบางอย่างมาก
ง่ายต่อการบางสิ่งบางอย่างที่ซับซ้อนมากขึ้น

830
00:40:04,190 --> 00:40:05,200
ทำเช่นเดียวกันที่นี่

831
00:40:05,200 --> 00:40:08,500
อย่านั่งลงและพยายามที่จะ
เขียนปัญหาทั้งหมด

832
00:40:08,500 --> 00:40:10,780
จริงใช้ขั้นตอนทารกเหล่านี้

833
00:40:10,780 --> 00:40:15,100
>> ตอนนี้สายจะไม่ทั้งหมด
ที่เป็นประโยชน์แก่ตนเอง

834
00:40:15,100 --> 00:40:18,210
เราต้องการจริงนึกคิดเหมือน
มีอย่างอื่นในชุดเครื่องมือของเรา

835
00:40:18,210 --> 00:40:20,990
ดังนั้นขอจริงทำตรงนั้น

836
00:40:20,990 --> 00:40:24,900
>> ผมขอไปข้างหน้าในขณะนี้และชักขึ้น
โปรแกรมที่แตกต่างกันเล็กน้อย

837
00:40:24,900 --> 00:40:28,320
และเราจะเรียก int.c นี้สำหรับจำนวนเต็ม

838
00:40:28,320 --> 00:40:30,870
ฉันกำลังจะไปเหมือนกัน
รวม CS550.h

839
00:40:30,870 --> 00:40:33,060
ฉันจะรวมถึงมาตรฐาน IO

840
00:40:33,060 --> 00:40:36,630
และที่เป็นไปได้รักกัน
ในอีกไม่กี่วันแรกเหล่านี้ของชั้นเรียน

841
00:40:36,630 --> 00:40:39,050
>> และฉันจะพร้อม
ตัวเองด้วยฟังก์ชั่นหลัก

842
00:40:39,050 --> 00:40:43,370
และตอนนี้แทนการรับสตริง
ให้เป็นไปข้างหน้าและได้รับ int

843
00:40:43,370 --> 00:40:49,285
ขอเรียกว่า i และเรียกมันว่าจะได้รับ
int ใกล้ parens กึ่งลำไส้ใหญ่

844
00:40:49,285 --> 00:40:51,410
และตอนนี้ขอทำ
บางสิ่งบางอย่างกับมัน printf

845
00:40:51,410 --> 00:40:56,190
>> สมมติว่าสิ่งที่ต้องการ
สวัสดีทับขวา N, จุลภาคฉัน

846
00:40:56,190 --> 00:41:00,010
ดังนั้นผมสวยมากลอกเลียนแบบ
สิ่งที่ฉันได้เพียงแค่ช่วงเวลาที่ผ่านมา

847
00:41:00,010 --> 00:41:01,660
ฉันมีตัวยึดที่นี่

848
00:41:01,660 --> 00:41:05,150
ฉันได้จุลภาคฉันที่นี่เพราะผมต้องการ
ฉันจะเสียบเข้าไปในตัวยึดที่

849
00:41:05,150 --> 00:41:07,250
>> ดังนั้นขอไปข้างหน้าและลอง
รวบรวมโปรแกรมนี้

850
00:41:07,250 --> 00:41:10,060
ไฟล์จะถูกเรียกว่า int.c.

851
00:41:10,060 --> 00:41:12,920
ดังนั้นฉันจะพูดให้ int ป้อน

852
00:41:12,920 --> 00:41:16,420
โอ้พระเจ้าของฉัน แต่ไม่มีเรื่องใหญ่ใช่ไหม?

853
00:41:16,420 --> 00:41:17,230
มีความผิดพลาดคือ

854
00:41:17,230 --> 00:41:19,810
>> มีความผิดพลาดเป็นประโยค
ที่นี่เช่นว่าโปรแกรมไม่สามารถ

855
00:41:19,810 --> 00:41:25,460
จะรวบรวมภายใน int.c สาย
เจ็ดตัวอักษร 27 รูปแบบข้อผิดพลาด

856
00:41:25,460 --> 00:41:28,400
ระบุชนิดถ่าน
ดาว, สิ่งที่เป็น

857
00:41:28,400 --> 00:41:30,020
แต่ประเภทอาร์กิวเมนต์เป็น int

858
00:41:30,020 --> 00:41:33,110
>> ดังนั้นที่นี่ก็เช่นกันเราจะไม่ to--
แม้ว่าในวันนี้เป็นจำนวนมากของวัสดุ

859
00:41:33,110 --> 00:41:35,710
เรากำลังจะครอบงำคุณด้วย
อย่างคุณลักษณะของ C ทุก

860
00:41:35,710 --> 00:41:38,070
และการเขียนโปรแกรมมากขึ้นโดยทั่วไป
ในเวลาเพียงไม่กี่สัปดาห์แรกเหล่านี้

861
00:41:38,070 --> 00:41:40,400
ดังนั้นจึงมีมักจะเป็นศัพท์แสง
ที่คุณไม่คุ้นเคย

862
00:41:40,400 --> 00:41:43,350
และในความเป็นจริงถ่านดาวเป็นสิ่งที่
เรากำลังจะกลับมา

863
00:41:43,350 --> 00:41:44,830
ในช่วงเวลาหนึ่งหรือสองสัปดาห์ของ

864
00:41:44,830 --> 00:41:47,530
>> แต่ตอนนี้ขอดูว่าเราสามารถทำได้
แยกคำที่มีความคุ้นเคย

865
00:41:47,530 --> 00:41:50,750
Formats-- ดังนั้นเราจึงได้ยินเสียงรูปแบบ
ระบุรหัสรูปแบบก่อน

866
00:41:50,750 --> 00:41:51,840
นั่นเป็นที่คุ้นเคย

867
00:41:51,840 --> 00:41:53,840
Type-- แต่อาร์กิวเมนต์มีชนิด int

868
00:41:53,840 --> 00:41:55,980
รอสักครู่ผมเป็น int

869
00:41:55,980 --> 00:41:59,230
>> บางทีร้อยละจริง
มีความหมายบางอย่างที่กำหนดไว้

870
00:41:59,230 --> 00:42:00,230
และแน่นอนมันไม่

871
00:42:00,230 --> 00:42:03,101
จำนวนเต็มถ้าคุณต้องการ
printf เพื่อทดแทนมัน

872
00:42:03,101 --> 00:42:05,350
คุณจริงต้องใช้
ระบุรูปแบบที่แตกต่างกัน

873
00:42:05,350 --> 00:42:06,890
และคุณจะไม่ทราบเรื่องนี้
ยกเว้นในกรณีที่มีคนบอกคุณ

874
00:42:06,890 --> 00:42:07,973
ท่านได้ทำไว้ก่อน

875
00:42:07,973 --> 00:42:10,490
แต่ร้อยละคือสิ่งที่ฉัน
สามารถนำมาใช้กันทั่วไป

876
00:42:10,490 --> 00:42:12,240
ใน printf สำหรับเสียบจำนวนเต็ม

877
00:42:12,240 --> 00:42:14,920
นอกจากนี้คุณยังสามารถใช้ร้อยละ
D สำหรับจำนวนเต็มทศนิยม

878
00:42:14,920 --> 00:42:16,490
แต่ฉันเป็นสิ่งที่ดีและง่ายที่นี่

879
00:42:16,490 --> 00:42:17,590
ดังนั้นเราจะไปกับที่

880
00:42:17,590 --> 00:42:21,160
>> ตอนนี้ให้ฉันไปข้างหน้าและ
วิ่งให้ int ใส่

881
00:42:21,160 --> 00:42:23,328
ที่ดีไม่มีข้อผิดพลาด

882
00:42:23,328 --> 00:42:27,260
Dot เฉือนตกลง int-- ประสบการณ์การใช้งานที่ไม่ดี
เพราะผมยังไม่ได้บอกกับตัวเอง

883
00:42:27,260 --> 00:42:27,760
สิ่งที่ต้องทำ

884
00:42:27,760 --> 00:42:28,426
แต่ที่ดี

885
00:42:28,426 --> 00:42:29,480
ฉันจับได้อย่างรวดเร็ว

886
00:42:29,480 --> 00:42:36,260
>> และตอนนี้ให้ฉันไปข้างหน้าและ
พิมพ์ในเดวิด, OK, Zamila ร็อบ

887
00:42:36,260 --> 00:42:37,820
ตกลงดังนั้นนี้เป็นสิ่งที่ดี

888
00:42:37,820 --> 00:42:41,710
เวลานี้ผมใช้ฟังก์ชั่น
ชิ้นส่วนจิ๊กซอว์ที่เรียกว่าได้รับ int

889
00:42:41,710 --> 00:42:44,230
และมันจะเปิด out-- และเราจะ
ได้เห็นต่อไปนี้ใน term--

890
00:42:44,230 --> 00:42:47,730
พนักงาน CS50 ได้ดำเนินการ
ได้รับสตริงในลักษณะดังกล่าว

891
00:42:47,730 --> 00:42:50,350
ว่ามันจะมีเพียงร่างกาย
ได้รับสตริงสำหรับคุณ

892
00:42:50,350 --> 00:42:54,340
>> จะได้ดำเนินการรับ int ใน
ลักษณะที่ว่าก็จะ

893
00:42:54,340 --> 00:42:55,590
ได้รับจำนวนเต็มสำหรับคุณ

894
00:42:55,590 --> 00:42:57,830
และถ้าคุณมนุษย์
ไม่ให้ความร่วมมือก็

895
00:42:57,830 --> 00:43:00,590
แท้จริงแค่ไป
บอกว่าลองใหม่ลองใหม่ลองใหม่

896
00:43:00,590 --> 00:43:05,200
แท้จริงนั่งอยู่ที่นั่นวนลูปจนกว่า
คุณต้องมีภาระหน้าที่ที่มีจำนวนบางขลัง,

897
00:43:05,200 --> 00:43:07,670
เช่น 50, 50 และสวัสดี

898
00:43:07,670 --> 00:43:11,440
>> หรือถ้าเราทำงานนี้อีกครั้ง
และพิมพ์ 42, 42 สวัสดี

899
00:43:11,440 --> 00:43:15,750
และเพื่อให้ได้รับฟังก์ชั่น int
ภายในของชิ้นส่วนปริศนาที่

900
00:43:15,750 --> 00:43:19,050
ตรรกะพอคิดพอ
ที่จะคิดออกว่าอะไรคือคำ?

901
00:43:19,050 --> 00:43:20,330
และสิ่งที่เป็นจำนวน?

902
00:43:20,330 --> 00:43:23,165
เพียงยอมรับในที่สุดตัวเลข

903
00:43:23,165 --> 00:43:25,690

904
00:43:25,690 --> 00:43:30,230
>> ดังนั้นจึงปรากฎว่านี้
ไม่ได้ทั้งหมดที่แสดงออก

905
00:43:30,230 --> 00:43:30,910
ป่านฉะนี้

906
00:43:30,910 --> 00:43:33,690
ดังนั้นยายครั้งสุดท้ายที่เรา
ไปสวยได้อย่างรวดเร็ว

907
00:43:33,690 --> 00:43:38,320
เข้าสู่เกมการดำเนินการและภาพเคลื่อนไหว
และผลงานศิลปะในรอยขีดข่วน

908
00:43:38,320 --> 00:43:42,260
และที่นี่เราจะเป็นเนื้อหา
กับโลกสวัสดีและทักทาย 50

909
00:43:42,260 --> 00:43:43,696
>> มันไม่ได้เป็นสิ่งที่สร้างแรงบันดาลใจ

910
00:43:43,696 --> 00:43:46,070
และแน่นอนไม่กี่เหล่านี้ก่อน
ตัวอย่างจะใช้เวลา

911
00:43:46,070 --> 00:43:47,510
ทางลาดขึ้นในความตื่นเต้น

912
00:43:47,510 --> 00:43:49,854
แต่เราก็มีมากขึ้น
ควบคุมตอนนี้ในความเป็นจริง

913
00:43:49,854 --> 00:43:51,770
และเรากำลังจะไปมาก
ได้อย่างรวดเร็วเริ่มต้น layering

914
00:43:51,770 --> 00:43:53,870
ด้านบนของวิทยาการพื้นฐานเหล่านี้

915
00:43:53,870 --> 00:43:56,370
>> แต่ก่อนอื่นเรามาทำความเข้าใจ
สิ่งที่เป็นข้อ จำกัด

916
00:43:56,370 --> 00:43:58,620
ในความเป็นจริงหนึ่งในสิ่งที่
รอยขีดข่วนไม่ได้อย่างง่ายดาย

917
00:43:58,620 --> 00:44:00,990
ให้เราทำคือจริงๆมอง
ใต้ฝากระโปรง

918
00:44:00,990 --> 00:44:03,740
และทำความเข้าใจกับสิ่งที่
คอมพิวเตอร์เป็นสิ่งที่มันสามารถทำ

919
00:44:03,740 --> 00:44:05,250
และสิ่งที่เป็นข้อ จำกัด ของมัน

920
00:44:05,250 --> 00:44:08,580
และแน่นอนที่ขาด
ความเข้าใจที่อาจเกิดขึ้นในระยะยาว

921
00:44:08,580 --> 00:44:12,520
สามารถนำไปสู่​​การเขียน mistakes-- ของเราเอง
ข้อบกพร่องการเขียนซอฟแวร์ที่ไม่ปลอดภัย

922
00:44:12,520 --> 00:44:13,880
ได้รับการแฮ็กในบางวิธี

923
00:44:13,880 --> 00:44:17,130
>> ดังนั้นลองมาขั้นตอนบางอย่างที่มีต่อ
ความเข้าใจนี้ดีขึ้นเล็กน้อยโดย

924
00:44:17,130 --> 00:44:19,710
วิธีการพูด, ตัวอย่างต่อไปนี้

925
00:44:19,710 --> 00:44:23,550
ฉันจะไปข้างหน้าและการดำเนินการ
จริงอย่างรวดเร็วโปรแกรมที่เรียกว่า Adder

926
00:44:23,550 --> 00:44:25,134
เช่นขอเพิ่มตัวเลขร่วมกัน

927
00:44:25,134 --> 00:44:27,800
และฉันจะให้รหัสบางมุม
ที่นี่และเพียงแค่คัดลอกและวาง

928
00:44:27,800 --> 00:44:30,270
ที่ผมมาก่อนเพียง
เพื่อให้เราสามารถได้รับไปไม่ช้าก็เร็ว

929
00:44:30,270 --> 00:44:33,090
ดังนั้นตอนนี้ฉันได้มีจุดเริ่มต้นพื้นฐาน
ของโปรแกรมที่เรียกว่า Adder

930
00:44:33,090 --> 00:44:34,670
>> และให้ไปข้างหน้าและทำเช่นนี้

931
00:44:34,670 --> 00:44:38,680
ฉันจะไปข้างหน้าและ
พูด INTX ได้รับได้รับ int

932
00:44:38,680 --> 00:44:39,430
และคุณรู้อะไรไหม

933
00:44:39,430 --> 00:44:40,990
ขอให้ประสบการณ์การใช้งานที่ดีขึ้น

934
00:44:40,990 --> 00:44:45,740
>> ดังนั้นขอเพียงบอกว่าเป็น X และมีประสิทธิภาพ
แจ้งให้ผู้ใช้ที่จะให้เรา X

935
00:44:45,740 --> 00:44:50,600
แล้วปล่อยให้ฉันไปข้างหน้าและพูดว่า printf
วิธีการเกี่ยวกับ Y คือครั้งนี้คาดหวังว่า

936
00:44:50,600 --> 00:44:53,140
สองค่าจากผู้ใช้

937
00:44:53,140 --> 00:44:59,759
แล้วให้เพียงไปข้างหน้าและ
พูด printf ผลรวมของ x และ y คือ

938
00:44:59,759 --> 00:45:01,300
และตอนนี้ฉันไม่ต้องการที่จะทำร้อยละ s

939
00:45:01,300 --> 00:45:09,080
ฉันต้องการจะทำผมร้อยละทับขวา
n แล้​​วเสียบในมูลค่ารวม

940
00:45:09,080 --> 00:45:10,620
>> ดังนั้นฉันจะไปเกี่ยวกับการทำเช่นนี้?

941
00:45:10,620 --> 00:45:11,270
คุณรู้ไหมว่า?

942
00:45:11,270 --> 00:45:12,840
ฉันรู้วิธีการใช้ตัวแปร

943
00:45:12,840 --> 00:45:15,140
ผมขอประกาศใหม่ int Z

944
00:45:15,140 --> 00:45:16,770
>> และฉันจะใช้การคาดเดาที่นี่

945
00:45:16,770 --> 00:45:21,470
หากมีสัญญาณที่เท่าเทียมกันในเรื่องนี้
ภาษาบางทีฉันก็สามารถทำ x บวก Y,

946
00:45:21,470 --> 00:45:23,660
ตราบใดที่ฉันท้ายของฉัน
คิดกับลำไส้ใหญ่กึ่ง?

947
00:45:23,660 --> 00:45:28,170
ตอนนี้ผมสามารถกลับไปลงที่นี่เสียบ Z,
จบความคิดนี้กับลำไส้ใหญ่กึ่ง

948
00:45:28,170 --> 00:45:33,160
และเรามาดูตอนนี้ถ้าเหล่านี้
ลำดับของ lines-- X คือการได้รับ int

949
00:45:33,160 --> 00:45:34,770
Y คือการได้รับ int

950
00:45:34,770 --> 00:45:37,980
>> เพิ่ม x และ y เก็บค่าใน z--
ดังนั้นอีกครั้งจำเครื่องหมายเท่ากับ

951
00:45:37,980 --> 00:45:38,560
ไม่เท่ากับ

952
00:45:38,560 --> 00:45:41,100
มันเป็นเรื่องที่ได้รับมอบหมายจากขวาไปซ้าย

953
00:45:41,100 --> 00:45:45,180
และให้พิมพ์ออกมาว่าผลรวม
ของ x และ y ไม่ได้เป็นตัวอักษร Z,

954
00:45:45,180 --> 00:45:46,830
แต่สิ่งที่อยู่ภายในของ Z

955
00:45:46,830 --> 00:45:50,090
ดังนั้นขอให้ Adder -
ดีไม่มีข้อผิดพลาดในครั้งนี้

956
00:45:50,090 --> 00:45:53,030
Dot เฉือน Adder ป้อน,
X เป็นไปได้ที่ 1

957
00:45:53,030 --> 00:45:55,380
>> Y เป็นไปได้ 2

958
00:45:55,380 --> 00:45:58,964
และผลรวมของ x และ y คือ 3

959
00:45:58,964 --> 00:46:00,130
ดังนั้นนั่นคือทั้งหมดที่ดีและดี

960
00:46:00,130 --> 00:46:03,260
>> ดังนั้นคุณจะคิดว่าคณิตศาสตร์
ควรจะทำงานในโปรแกรมเช่นนี้

961
00:46:03,260 --> 00:46:04,040
แต่คุณรู้อะไรไหม

962
00:46:04,040 --> 00:46:06,904
คือตัวแปรนี้สาย
12 แม้จำเป็น?

963
00:46:06,904 --> 00:46:09,820
คุณไม่จำเป็นต้องได้รับในนิสัย
เพียงการจัดเก็บสิ่งที่อยู่ในตัวแปร

964
00:46:09,820 --> 00:46:10,980
เพียงเพราะคุณสามารถ

965
00:46:10,980 --> 00:46:13,550
และในความเป็นจริงมันโดยทั่วไป
การออกแบบที่ไม่ดีการพิจารณา

966
00:46:13,550 --> 00:46:18,100
ถ้าคุณกำลังสร้างตัวแปรที่เรียกว่า
Z ในกรณีนี้การจัดเก็บบางสิ่งบางอย่างในนั้น

967
00:46:18,100 --> 00:46:21,390
และจากนั้นทันที
ใช้มัน แต่ไม่เคยอีกครั้ง

968
00:46:21,390 --> 00:46:24,700
ให้สิ่งที่ทำไมชื่อ
เช่น Z ถ้าคุณอย่างแท้จริง

969
00:46:24,700 --> 00:46:26,770
จะใช้ว่า
สิ่งที่ได้เพียงครั้งเดียวและอื่น ๆ

970
00:46:26,770 --> 00:46:29,380
ใกล้เคียงกับตำแหน่งที่คุณสร้างขึ้น
ในสถานที่แรก

971
00:46:29,380 --> 00:46:31,052
เพื่อให้ใกล้เคียงในแง่ของสายรหัส?

972
00:46:31,052 --> 00:46:31,760
เพื่อให้คุณรู้อะไรไหม

973
00:46:31,760 --> 00:46:34,480
แต่กลับกลายเป็นว่า C มีความยืดหยุ่นสวย

974
00:46:34,480 --> 00:46:36,586
ถ้าจริงผมต้องการที่จะ
plug-in ค่าที่นี่

975
00:46:36,586 --> 00:46:38,210
ผมไม่จำเป็นต้องประกาศตัวแปรใหม่

976
00:46:38,210 --> 00:46:41,680
ฉันสามารถ plug-in x บวก
Y เพราะ C เข้าใจ

977
00:46:41,680 --> 00:46:43,390
การคำนวณทางคณิตศาสตร์และผู้ประกอบการ

978
00:46:43,390 --> 00:46:47,140
>> ดังนั้นฉันก็สามารถพูดได้ว่าทำคณิตศาสตร์นี้
X Y บวกสิ่งที่ค่าเหล่านั้น

979
00:46:47,140 --> 00:46:50,780
เสียบที่เกิด
จำนวนเต็มเป็นสตริงที่

980
00:46:50,780 --> 00:46:53,730
ดังนั้นนี้อาจจะมี แต่
เพียงหนึ่งเส้นที่สั้นกว่า

981
00:46:53,730 --> 00:46:58,480
การออกแบบที่ดีขึ้นซึ่งเป็นโปรแกรมที่ดีกว่า
เพราะมีโค้ดน้อยลงดังนั้น

982
00:46:58,480 --> 00:46:59,921
น้อยกว่าสำหรับผมที่จะเข้าใจ

983
00:46:59,921 --> 00:47:01,920
และมันก็เป็นเพียงแค่ทำความสะอาด
ตราบเท่าที่เราไม่ได้

984
00:47:01,920 --> 00:47:04,620
แนะนำคำศัพท์ใหม่
สัญลักษณ์ใหม่เช่น Z,

985
00:47:04,620 --> 00:47:07,510
ถึงแม้ว่าพวกเขาไม่ได้จริงๆ
ให้บริการมากของวัตถุประสงค์

986
00:47:07,510 --> 00:47:12,890
>> แต่น่าเสียดายที่ไม่ได้เป็นคณิตศาสตร์
ทุกสิ่งที่บางครั้งมีความน่าเชื่อถือ

987
00:47:12,890 --> 00:47:15,270
Let 's ไปข้างหน้าและทำเช่นนี้

988
00:47:15,270 --> 00:47:18,200
ฉันจะไปข้างหน้า
ในขณะนี้และทำต่อไปนี้

989
00:47:18,200 --> 00:47:27,650
>> ขอทำ printf ผมเปอร์เซ็นต์บวกร้อยละ
ฉันจะเป็นร้อยละ i, n ทับขวา

990
00:47:27,650 --> 00:47:32,240
และฉันจะทำ xyx this-- บวก Y

991
00:47:32,240 --> 00:47:34,821
ดังนั้นฉันแค่ไปที่จะเขียน
นี้แตกต่างกันเล็กน้อยที่นี่

992
00:47:34,821 --> 00:47:36,320
ให้ฉันเพียงแค่จะตรวจสอบสติได้อย่างรวดเร็ว

993
00:47:36,320 --> 00:47:37,986
อีกครั้งให้ไม่ได้รับล่วงหน้าของตัวเอง

994
00:47:37,986 --> 00:47:41,420
ทำให้ Adder จุดเฉือน Adder

995
00:47:41,420 --> 00:47:44,950
X คือ 1, Y คือ 2, 1 บวก 2 คือ 3

996
00:47:44,950 --> 00:47:45,870
ดังนั้นที่ดี

997
00:47:45,870 --> 00:47:49,060
แต่ขอให้มีความซับซ้อนในตอนนี้
บิตและสร้างไฟล์ใหม่

998
00:47:49,060 --> 00:47:53,350
>> ฉันจะโทรห​​าคนนี้
พูด ints พหูพจน์สำหรับจำนวนเต็ม

999
00:47:53,350 --> 00:47:55,980
ผมขอเริ่มต้นที่ฉันเป็นช่วงเวลาที่ผ่านมา

1000
00:47:55,980 --> 00:47:57,770
แต่ตอนนี้ขอทำสายอื่น ๆ ไม่กี่

1001
00:47:57,770 --> 00:48:03,430
ให้ฉันไปข้างหน้าและทำต่อไปนี้
printf ผมเปอร์เซ็นต์ลบร้อยละ i,

1002
00:48:03,430 --> 00:48:08,959
คือผมร้อยละจุลภาค x, y จุลภาค YX ลบ

1003
00:48:08,959 --> 00:48:10,750
ดังนั้นฉันทำเล็กน้อย
คณิตศาสตร์ที่แตกต่างกันมี

1004
00:48:10,750 --> 00:48:11,624
ขอทำอีกคนหนึ่ง

1005
00:48:11,624 --> 00:48:16,610
ดังนั้นร้อยละร้อยละฉันครั้ง
ฉันเป็นฉันเปอร์เซ็นต์ทับขวา n

1006
00:48:16,610 --> 00:48:21,430
Let 's plug-in x และ y, x ครั้ง Y

1007
00:48:21,430 --> 00:48:24,530
เราจะใช้เครื่องหมายดอกจันบน
คอมพิวเตอร์ของคุณสำหรับครั้ง

1008
00:48:24,530 --> 00:48:26,390
>> คุณไม่ได้ใช้ X x คือ
ชื่อตัวแปรที่นี่

1009
00:48:26,390 --> 00:48:28,270
คุณสามารถใช้ดาวคูณ

1010
00:48:28,270 --> 00:48:29,020
ให้ทำอย่างใดอย่างหนึ่งมากขึ้น

1011
00:48:29,020 --> 00:48:34,580
ผมร้อยละ printf แบ่ง
โดย I ร้อยละร้อยละ i,

1012
00:48:34,580 --> 00:48:40,460
ทับขวา n XY หารด้วย y--
เพื่อให้คุณใช้ทับใน C

1013
00:48:40,460 --> 00:48:41,502
ส่วนจะทำอย่างไร

1014
00:48:41,502 --> 00:48:42,460
และขอทำคนอื่น ๆ

1015
00:48:42,460 --> 00:48:47,920

1016
00:48:47,920 --> 00:48:55,240
ที่เหลือของผมร้อยละหาร
โดยร้อยละฉันเป็นฉันร้อยละ

1017
00:48:55,240 --> 00:48:59,550
xy-- และตอนนี้ที่เหลือ
เป็นสิ่งที่เหลือกว่า

1018
00:48:59,550 --> 00:49:02,980
เมื่อคุณพยายามแบ่ง
หารลงในเศษที่

1019
00:49:02,980 --> 00:49:05,570
วิธีการมากที่เหลือว่า
คุณไม่สามารถแบ่งออก?

1020
00:49:05,570 --> 00:49:07,910
>> จึงมีไม่ได้จริงๆ
จำเป็นสัญลักษณ์

1021
00:49:07,910 --> 00:49:09,470
เราได้นำมาใช้ในโรงเรียนประถมศึกษาสำหรับเรื่องนี้

1022
00:49:09,470 --> 00:49:13,830
แต่มีใน C. คุณสามารถ
พูดแบบโมดูโล X Y ที่

1023
00:49:13,830 --> 00:49:18,000
เครื่องหมายเปอร์เซ็นต์ใน context-- นี้
ทำให้เกิดความสับสนเมื่อคุณอยู่ภายใน

1024
00:49:18,000 --> 00:49:20,170
ของราคาคู่
ภายในของ printf ร้อยละ

1025
00:49:20,170 --> 00:49:21,830
จะถูกใช้เป็นตัวระบุรูปแบบ

1026
00:49:21,830 --> 00:49:25,420
>> เมื่อคุณใช้ร้อยละนอก
ว่าในการแสดงออกทางคณิตศาสตร์

1027
00:49:25,420 --> 00:49:29,910
มันเป็นผู้ประกอบการโมดูโลสำหรับโมดูลาร์
arithmetic-- สำหรับวัตถุประสงค์ของเรา

1028
00:49:29,910 --> 00:49:33,650
นี่ก็หมายความว่าสิ่งที่เป็น
ที่เหลือของ x หารด้วย Y?

1029
00:49:33,650 --> 00:49:36,130
ดังนั้น x หารด้วย Y คือ X เฉือน Y

1030
00:49:36,130 --> 00:49:38,220
มีอะไรที่เหลือของ x หารด้วย Y?

1031
00:49:38,220 --> 00:49:41,780
มัน X Y MOD, เป็นโปรแกรมเมอร์จะบอกว่า

1032
00:49:41,780 --> 00:49:48,300
>> ดังนั้นถ้าฉันทำผิดพลาดที่นี่ไม่มีให้ฉัน
ไปข้างหน้าและทำให้ ints, พหูพจน์ดี

1033
00:49:48,300 --> 00:49:50,010
และ ints เฉือนจุด

1034
00:49:50,010 --> 00:49:55,270
และให้ไปข้างหน้าและ
ไม่ขอบอก, 1, 10

1035
00:49:55,270 --> 00:49:58,390
สิทธิทั้งหมด 1 บวก 10 เป็น 11 ตรวจสอบ

1036
00:49:58,390 --> 00:50:01,240
1 ลบ 10 เป็นลบ 9 ตรวจสอบ

1037
00:50:01,240 --> 00:50:03,420
>> 1 ครั้งที่ 10 คือ 10 การตรวจสอบ

1038
00:50:03,420 --> 00:50:07,090
1 หารด้วย 10 is--
ตกลงเราจะข้ามที่หนึ่ง

1039
00:50:07,090 --> 00:50:09,480
ที่เหลือของ 1 หารด้วย 10 คือ 1

1040
00:50:09,480 --> 00:50:10,680
ถูกต้อง.

1041
00:50:10,680 --> 00:50:12,630
แต่มีข้อผิดพลาดในที่นี่

1042
00:50:12,630 --> 00:50:15,390
>> ดังนั้นหนึ่งฉันใส่ของฉัน
มอบไม่ถูกต้อง

1043
00:50:15,390 --> 00:50:16,670
ฉันหมายความว่ามันใกล้เคียงกับ 0

1044
00:50:16,670 --> 00:50:20,670
1 หารด้วย 10 คุณรู้ว่าถ้าเรา
ตัดมุมบางแน่ใจว่ามันเป็นศูนย์

1045
00:50:20,670 --> 00:50:28,050
แต่จริงๆมันควรจะเป็น 1/10
0.1 หรือ 0.10 0.1000 หรืออื่น ๆ

1046
00:50:28,050 --> 00:50:30,600
>> มันไม่ควรจะเป็นศูนย์จริงๆ

1047
00:50:30,600 --> 00:50:35,990
ดีก็ปรากฎว่าคอมพิวเตอร์คือ
ทำอย่างแท้จริงสิ่งที่เราบอกว่ามันจะทำ

1048
00:50:35,990 --> 00:50:39,460
เรากำลังทำทางคณิตศาสตร์เช่น x หารด้วย Y

1049
00:50:39,460 --> 00:50:44,680
และทั้งสอง x และ y ต่อเส้น
รหัสก่อนหน้านี้เป็นจำนวนเต็ม

1050
00:50:44,680 --> 00:50:50,440
>> นอกจากนี้ในบรรทัดที่ 15 เรามี
บอก printf เดี๋ยวก่อน printf Plug-in

1051
00:50:50,440 --> 00:50:54,230
จำนวนเต็ม plug-in จำนวนเต็ม
plug-ใน integer-- เฉพาะ

1052
00:50:54,230 --> 00:50:57,580
x แล้ว Y และ X
หารด้วย Y x และ y เป็น ints

1053
00:50:57,580 --> 00:50:59,060
เรามีดี

1054
00:50:59,060 --> 00:51:01,250
>> แต่สิ่งที่เป็น x หารด้วย X?

1055
00:51:01,250 --> 00:51:06,790
x หารด้วย Y ควรจะเป็น
คณิตศาสตร์ 1/10 หรือ 0.1,

1056
00:51:06,790 --> 00:51:11,600
ซึ่งเป็นจำนวนจริงจำนวนจริง
มีอาจเป็นจุดทศนิยม

1057
00:51:11,600 --> 00:51:13,230
มันไม่ได้เป็นจำนวนเต็ม

1058
00:51:13,230 --> 00:51:18,290
>> แต่สิ่งที่อยู่ใกล้ที่สุด
จำนวนเต็ม 1/10 หรือ 0.1?

1059
00:51:18,290 --> 00:51:21,114
ใช่มันชนิดของการเป็นศูนย์

1060
00:51:21,114 --> 00:51:22,030
0.1 เป็นเหมือนมากขนาดนี้

1061
00:51:22,030 --> 00:51:22,890
1 และเป็นมากขนาดนี้

1062
00:51:22,890 --> 00:51:25,870
ดังนั้น 1/10 จะอยู่ใกล้กับ
0 กว่าก็คือการอย่างใดอย่างหนึ่ง

1063
00:51:25,870 --> 00:51:30,800
>> และเพื่อให้สิ่งที่ C จะทำสำหรับ us--
ชนิดของเพราะเราบอกว่ามัน to--

1064
00:51:30,800 --> 00:51:32,600
จะถูกตัดทอนจำนวนเต็มที่

1065
00:51:32,600 --> 00:51:40,540
ก็สละค่าอีกครั้งซึ่งเป็น
ควรจะเป็นสิ่งที่ชอบ 0.1000,

1066
00:51:40,540 --> 00:51:41,800
0 และอื่น ๆ

1067
00:51:41,800 --> 00:51:45,320
และจะตัดทอนทุกอย่าง
หลังจุดทศนิยม

1068
00:51:45,320 --> 00:51:47,510
ดังนั้นสิ่งที่นี้
สิ่งเพราะมันไม่ได้

1069
00:51:47,510 --> 00:51:51,910
พอดีกับความคิดของจำนวนเต็มซึ่ง
เป็นเพียงตัวเลขเช่นติดลบ 1 0, 1,

1070
00:51:51,910 --> 00:51:55,830
ขึ้นและลงมันจะพ่นไปทุกอย่าง
หลังจุดทศนิยมเพราะคุณ

1071
00:51:55,830 --> 00:51:59,020
ไม่สามารถใส่จุดทศนิยม
ในจำนวนเต็มโดยความหมาย

1072
00:51:59,020 --> 00:52:01,290
>> ดังนั้นคำตอบที่นี่เป็นศูนย์

1073
00:52:01,290 --> 00:52:02,600
ดังนั้นวิธีที่เราจะแก้ไขปัญหานี้หรือไม่?

1074
00:52:02,600 --> 00:52:04,400
เราต้องแก้ไขปัญหาอื่นทั้งหมดเข้าด้วยกัน

1075
00:52:04,400 --> 00:52:06,880
และเราสามารถทำเช่นนี้ดังต่อไปนี้

1076
00:52:06,880 --> 00:52:12,820
>> ให้ฉันไปข้างหน้าและสร้างใหม่
ไฟล์หนึ่งนี้เรียกว่า floats.c

1077
00:52:12,820 --> 00:52:16,500
และบันทึกไว้ที่นี่ใน
ไดเรกทอรีเดียวกัน float.c

1078
00:52:16,500 --> 00:52:19,360

1079
00:52:19,360 --> 00:52:23,260
และแจ้งให้เราไปข้างหน้าและคัดลอก
บางส่วนของรหัสที่มาจากก่อนหน้านี้

1080
00:52:23,260 --> 00:52:27,690
>> แต่แทนที่จะได้รับ
เป็น int ขอทำเช่นนี้

1081
00:52:27,690 --> 00:52:31,037
ให้ฉันค่าจุดลอย
เรียกว่า x ที่จุดลอย

1082
00:52:31,037 --> 00:52:33,370
คุ้มค่าเป็นเพียงตัวอักษร
บางสิ่งบางอย่างที่มีจุดลอย

1083
00:52:33,370 --> 00:52:34,410
มันสามารถย้ายไปทางซ้ายไปทางขวา

1084
00:52:34,410 --> 00:52:35,530
มันเป็นจำนวนจริง

1085
00:52:35,530 --> 00:52:38,050
>> และแจ้งให้เราโทรหาไม่ได้
ได้รับ int แต่ได้รับลอย

1086
00:52:38,050 --> 00:52:41,420
ซึ่งยังเป็นหนึ่งในเมนู
ตัวเลือกในห้องสมุด C250

1087
00:52:41,420 --> 00:52:43,220
ลองเปลี่ยน Y เพื่อลอย

1088
00:52:43,220 --> 00:52:45,000
ดังนั้นนี้จะกลายเป็นได้รับลอย

1089
00:52:45,000 --> 00:52:47,620
>> และตอนนี้เราไม่ต้องการที่จะเสียบ ints

1090
00:52:47,620 --> 00:52:53,130
มันจะเปิดออกเราจะต้องใช้ร้อยละ
F สำหรับลอย F ร้อยละลอย

1091
00:52:53,130 --> 00:52:54,560
และตอนนี้บันทึกไว้

1092
00:52:54,560 --> 00:53:01,220
และตอนนี้นิ้วข้ามให้
ลอยดีลอยเฉือนจุด

1093
00:53:01,220 --> 00:53:04,280
X เป็นไปได้หนึ่ง 1. Y
เป็นไปได้ 10 อีกครั้ง

1094
00:53:04,280 --> 00:53:08,240
>> และมีความสุข, OK นอกจากของฉันถูกต้อง

1095
00:53:08,240 --> 00:53:10,240
ผมก็หวังว่าสำหรับข้อมูลเพิ่มเติม
แต่ฉันลืมที่จะเขียนมัน

1096
00:53:10,240 --> 00:53:13,250
ดังนั้นขอไปและแก้ไขข้อผิดพลาดตรรกะนี้

1097
00:53:13,250 --> 00:53:16,280
>> Let 's ไปข้างหน้าและคว้าดังต่อไปนี้

1098
00:53:16,280 --> 00:53:18,080
เราก็จะทำสำเนาเล็ก ๆ น้อย ๆ และวาง

1099
00:53:18,080 --> 00:53:20,080
และฉันจะบอกว่าลบ

1100
00:53:20,080 --> 00:53:21,890
>> และฉันจะบอกว่าครั้ง

1101
00:53:21,890 --> 00:53:24,060
และฉันจะบอกว่าแบ่ง

1102
00:53:24,060 --> 00:53:28,240
และฉันจะไม่ทำแบบโมดูโล,
ซึ่งไม่เป็นที่ใกล้ชิดที่นี่

1103
00:53:28,240 --> 00:53:33,690
หารด้วย F และเวลา plus--
ตกลงให้ทำเช่นนี้อีกครั้ง

1104
00:53:33,690 --> 00:53:44,210
>> ลอยให้ลอยเฉือนจุด
และวันที่ 1, 10, and-- ดีไม่ตกลง

1105
00:53:44,210 --> 00:53:45,250
ดังนั้นฉันงี่เง่า

1106
00:53:45,250 --> 00:53:47,000
ดังนั้นนี่เป็นเรื่องธรรมดามาก
วิทยาการคอมพิวเตอร์

1107
00:53:47,000 --> 00:53:49,780
จะทำผิดพลาดโง่เช่นนี้

1108
00:53:49,780 --> 00:53:53,100
>> เพื่อวัตถุประสงค์ในการสอน
สิ่งที่ผมอยากจะทำ

1109
00:53:53,100 --> 00:53:57,410
ถูกเปลี่ยนวิทยาศาสตร์ที่นี่
จะบวกไปลบเพื่อครั้ง

1110
00:53:57,410 --> 00:54:01,140
และจะแบ่งตามที่คุณหวังว่า
สังเกตเห็นระหว่างการออกกำลังกายนี้

1111
00:54:01,140 --> 00:54:04,700
ดังนั้นตอนนี้ขอรวบรวมอีกครั้งนี้
โปรแกรมทำลอยเฉือนจุด

1112
00:54:04,700 --> 00:54:07,950
>> และเป็นครั้งที่สามขอ
ดูว่ามันตรงกับความคาดหวังของฉัน

1113
00:54:07,950 --> 00:54:21,480
1, 10, ใส่ใช่, OK, 1.000,
โดยแบ่งออกเป็น 10.000 เป็น 0.100000

1114
00:54:21,480 --> 00:54:24,952
และปรากฎว่าเราสามารถควบคุมจำนวน
ตัวเลขหลังจุดทศนิยมเหล่านั้น

1115
00:54:24,952 --> 00:54:25,660
เราจริงจะ

1116
00:54:25,660 --> 00:54:26,790
เราจะกลับมาที่

1117
00:54:26,790 --> 00:54:28,440
>> แต่ตอนนี้ในความเป็นจริงทางคณิตศาสตร์ที่ถูกต้อง

1118
00:54:28,440 --> 00:54:30,090
ดังนั้นอีกครั้งสิ่งที่ Takeaway ที่นี่?

1119
00:54:30,090 --> 00:54:33,050
ปรากฎว่าใน C มี
ไม่เพียงเท่านั้น strings-- และในความเป็นจริง

1120
00:54:33,050 --> 00:54:36,120
มีไม่ได้จริงๆเพราะเรา
เพิ่มผู้ที่มีห้องสมุด CS50

1121
00:54:36,120 --> 00:54:37,710
แต่มีไม่ได้เป็นเพียง ints

1122
00:54:37,710 --> 00:54:38,990
>> นอกจากนี้ยังมีลอย

1123
00:54:38,990 --> 00:54:42,810
และมันจะเปิดออกพวงของข้อมูลอื่น ๆ
ประเภทเกินไปที่เราจะใช้ก่อนที่จะยาว

1124
00:54:42,810 --> 00:54:46,270
เปิดออกถ้าคุณต้องการเป็นหนึ่งเดียว
ตัวอักษรไม่ใช่สตริงของตัวอักษร

1125
00:54:46,270 --> 00:54:47,610
คุณสามารถใช้เพียงถ่าน

1126
00:54:47,610 --> 00:54:52,350
>> ปรากฎว่าถ้าคุณต้องการบูลที่
ค่าบูลีน, จริงหรือเท็จเท่านั้น

1127
00:54:52,350 --> 00:54:56,840
ขอบคุณไปยังห้องสมุด CS50 เราได้
เพิ่มไปที่ C บูลชนิดข้อมูลได้เป็นอย่างดี

1128
00:54:56,840 --> 00:54:59,180
แต่มันก็ยังนำเสนอใน
ภาษาอื่น ๆ จำนวนมากเช่นกัน

1129
00:54:59,180 --> 00:55:04,130
และปรากฎว่าบางครั้งคุณ
ต้องตัวเลขใหญ่แล้วมาโดยค่าเริ่มต้น

1130
00:55:04,130 --> 00:55:05,210
กับ ints และลอย

1131
00:55:05,210 --> 00:55:10,590
>> และในความเป็นจริงคู่เป็นจำนวน
ที่ใช้ไม่ได้ 32 บิต แต่ 64 บิต

1132
00:55:10,590 --> 00:55:14,990
และนานเป็นตัวเลขที่
ใช้ไม่ได้ 32 บิต แต่ 64 บิต

1133
00:55:14,990 --> 00:55:19,190
ตามลำดับสำหรับจุดลอย
ค่านิยมและจำนวนเต็มตามลำดับ

1134
00:55:19,190 --> 00:55:22,780
ดังนั้นขอจริงในขณะนี้
เห็นนี้ในการดำเนินการ

1135
00:55:22,780 --> 00:55:26,150
>> ฉันจะไปข้างหน้านี่
และชักขึ้นโปรแกรมอื่นอย่างใดอย่างหนึ่ง

1136
00:55:26,150 --> 00:55:32,020
ที่นี่ฉันจะไปข้างหน้า
และไม่รวมถึง CS50.h.

1137
00:55:32,020 --> 00:55:34,910
และแจ้งให้เราไปรวมถึงมาตรฐาน IO.h.

1138
00:55:34,910 --> 00:55:37,320
>> และคุณจะสังเกตเห็นบางสิ่งบางอย่าง
ขี้ขลาดที่เกิดขึ้นที่นี่

1139
00:55:37,320 --> 00:55:40,592
มันไม่ได้เป็นรหัสสีสิ่งที่อยู่ใน
เช่นเดียวกับมันก่อน

1140
00:55:40,592 --> 00:55:43,550
และปรากฎว่าเป็นเพราะฉัน
ยังไม่ได้ให้สิ่งที่ชื่อไฟล์

1141
00:55:43,550 --> 00:55:47,270
>> ฉันจะโทรห​​าคนนี้
sizeof.c และกดบันทึก

1142
00:55:47,270 --> 00:55:51,039
และสังเกตเห็นสิ่งที่เกิดขึ้นกับฉันมาก
รหัสสีขาวกับสีดำที่ฉากหลัง

1143
00:55:51,039 --> 00:55:52,830
ตอนนี้อย่างน้อยมี
บางม่วงในการมี

1144
00:55:52,830 --> 00:55:54,490
และมันก็เป็นไวยากรณ์ที่ไฮไลต์

1145
00:55:54,490 --> 00:55:57,700
>> นั่นเป็นเพราะค่อนข้างเพียงฉันได้
IDE บอกสิ่งที่ชนิดของไฟล์

1146
00:55:57,700 --> 00:56:01,060
มันเป็นโดยให้มันชื่อและ
เฉพาะไฟล์นามสกุล

1147
00:56:01,060 --> 00:56:03,620
ตอนนี้ขอไปข้างหน้าและทำเช่นนี้

1148
00:56:03,620 --> 00:56:08,910
ฉันจะไปข้างหน้าและมาก
เพียงแค่พิมพ์บูล following--

1149
00:56:08,910 --> 00:56:11,080
คิดเป็นร้อยละ LU

1150
00:56:11,080 --> 00:56:12,950
>> เราจะกลับมา
ว่าในสักครู่

1151
00:56:12,950 --> 00:56:15,840
แล้วฉันจะไป
ขนาดการพิมพ์ของบูล

1152
00:56:15,840 --> 00:56:18,170
และตอนนี้เพียงเพื่อประหยัด
ตัวเองบางครั้งฉัน

1153
00:56:18,170 --> 00:56:20,280
จะทำทั้งหมด
พวงของเหล่านี้ได้ในครั้งเดียว

1154
00:56:20,280 --> 00:56:24,620
และโดยเฉพาะอย่างฉันจะไป
เปลี่ยนเป็นถ่านและถ่าน

1155
00:56:24,620 --> 00:56:27,760
หนึ่งนี้ผมจะมีการเปลี่ยนแปลง
ไปเป็นคู่และคู่

1156
00:56:27,760 --> 00:56:31,440
>> หนึ่งนี้ผมจะมีการเปลี่ยนแปลง
จะลอยและลอย

1157
00:56:31,440 --> 00:56:35,670
หนึ่งนี้ผมกำลังจะไป
เปลี่ยนไปเป็น int และ int

1158
00:56:35,670 --> 00:56:38,660
และหนึ่งนี้ฉันจะ
จะเปลี่ยนไปนานนาน

1159
00:56:38,660 --> 00:56:40,840
และก็ยังคงได้รับ
เป็นเวลานานนาน

1160
00:56:40,840 --> 00:56:44,572
>> และแล้วในที่สุดผมให้
ตัวเองหนึ่งมากเกินไปสตริง

1161
00:56:44,572 --> 00:56:47,030
ปรากฎว่าใน C มี
ผู้ประกอบการพิเศษที่เรียกว่า

1162
00:56:47,030 --> 00:56:50,260
ขนาดของตัวอักษรที่
จะเรียกใช้เมื่อ

1163
00:56:50,260 --> 00:56:52,099
บอกให้เราทราบขนาดของ
แต่ละตัวแปรเหล่านี้

1164
00:56:52,099 --> 00:56:53,890
และนี่คือวิธีการในขณะนี้
เราสามารถเชื่อมต่อกลับ

1165
00:56:53,890 --> 00:56:57,140
เพื่อการสนทนาสัปดาห์สุดท้ายของ
ของข้อมูลและการเป็นตัวแทน

1166
00:56:57,140 --> 00:57:00,330
>> ให้ฉันไปข้างหน้าและรวบรวม
ขนาดของขนาดเฉือนจุดของ

1167
00:57:00,330 --> 00:57:01,210
และขอดู

1168
00:57:01,210 --> 00:57:05,210
ปรากฎว่าใน C,
เฉพาะใน CS50 IDE,

1169
00:57:05,210 --> 00:57:08,170
โดยเฉพาะใน
ระบบปฏิบัติการอูบุนตู

1170
00:57:08,170 --> 00:57:11,100
ซึ่งเป็นปฏิบัติการ 64 บิต
ระบบในกรณีนี้

1171
00:57:11,100 --> 00:57:14,189
บูลเป็นไป
ใช้หนึ่งไบต์ของพื้นที่

1172
00:57:14,189 --> 00:57:16,480
นั่นเป็นวิธีที่ขนาดเป็นวัด
ไม่ได้อยู่ในบิต แต่ในไบต์

1173
00:57:16,480 --> 00:57:18,690
และจำได้ว่าเป็นหนึ่งไบต์แปดบิต

1174
00:57:18,690 --> 00:57:22,030
ดังนั้นบูลแม้ว่าคุณ
ในทางเทคนิคจะต้อง 0 หรือ 1

1175
00:57:22,030 --> 00:57:24,092
มันสิ้นเปลืองน้อย
วิธีการที่เราได้ใช้มัน

1176
00:57:24,092 --> 00:57:26,800
จริง ๆ แล้วมันจะใช้ทั้ง
byte-- ดังนั้นศูนย์ทั้งหมดเป็นบางที

1177
00:57:26,800 --> 00:57:31,050
ทุกคนหรือสิ่งที่ต้องการที่
หรือเพียงหนึ่งในหมู่ 1 แปดบิต

1178
00:57:31,050 --> 00:57:34,962
>> ถ่านขณะที่ใช้สำหรับตัวละคร
เหมือนอักขระ ASCII ต่อสัปดาห์ที่ผ่านมา

1179
00:57:34,962 --> 00:57:36,170
เป็นไปได้ที่ตัวละครตัวหนึ่ง

1180
00:57:36,170 --> 00:57:42,340
และที่ synchs ขึ้นด้วยความคิดของเรา
มันเป็นไม่เกิน 256 bits-- ค่อนข้าง

1181
00:57:42,340 --> 00:57:45,360
ซิงค์กับมันไม่ถูก
นานกว่า 8 บิตซึ่ง

1182
00:57:45,360 --> 00:57:47,450
จะช่วยให้เราเป็นจำนวนมากถึง 256 ค่า

1183
00:57:47,450 --> 00:57:49,680
คู่เป็นไป
8 ไบต​​์หรือ 64 บิต

1184
00:57:49,680 --> 00:57:50,510
>> ลอยคือ 4

1185
00:57:50,510 --> 00:57:51,690
เป็น int คือ 4

1186
00:57:51,690 --> 00:57:52,980
ยาวยาว 8

1187
00:57:52,980 --> 00:57:54,716
และสตริงคือ 8

1188
00:57:54,716 --> 00:57:55,840
แต่ไม่ต้องกังวลเกี่ยวกับว่า

1189
00:57:55,840 --> 00:57:57,340
เรากำลังจะไปลอกกลับชั้นที่

1190
00:57:57,340 --> 00:57:59,940
มันจะเปิดออกสตริงสามารถ
จะนานกว่า 8 ไบต​​์

1191
00:57:59,940 --> 00:58:02,310
>> และแน่นอนเราได้เขียน
สตริงแล้ว Hello World,

1192
00:58:02,310 --> 00:58:03,700
นานกว่า 8 ไบต​​์

1193
00:58:03,700 --> 00:58:06,270
แต่เราจะกลับมา
ว่าในสักครู่

1194
00:58:06,270 --> 00:58:09,690
แต่ใช้ไปนี่คือต่อไปนี้

1195
00:58:09,690 --> 00:58:15,320
>> คอมพิวเตอร์ใด ๆ เพียง แต่มี จำกัด
จำนวนหน่วยความจำและพื้นที่

1196
00:58:15,320 --> 00:58:17,860
คุณสามารถจัดเก็บจำนวนมาก
ไฟล์บน Mac หรือ PC

1197
00:58:17,860 --> 00:58:23,030
คุณสามารถเก็บโปรแกรมจำนวนมากดังนั้นใน
RAM ทำงานในครั้งเดียวจำเป็นต้องแม้

1198
00:58:23,030 --> 00:58:26,360
มีหน่วยความจำเสมือนเพราะ
คุณมีจำนวน จำกัด ของแรม

1199
00:58:26,360 --> 00:58:28,990
>> และเพียงเพื่อ picture-- ถ้า
ที่คุณไม่เคยเปิดแล็ปท็อป

1200
00:58:28,990 --> 00:58:31,300
หรือสั่งหน่วยความจำเสริม
สำหรับคอมพิวเตอร์ของคุณ

1201
00:58:31,300 --> 00:58:33,670
อาจจะไม่ทราบว่า
ภายในเครื่องคอมพิวเตอร์ของคุณ

1202
00:58:33,670 --> 00:58:36,590
เป็นสิ่งที่มีลักษณะ
เล็ก ๆ น้อย ๆ เช่นนี้

1203
00:58:36,590 --> 00:58:40,540
ดังนั้นนี้เป็นเพียง บริษัท ที่ร่วมกันตั้งชื่อ
สิ่งสำคัญที่ทำให้ RAM สำหรับคอมพิวเตอร์

1204
00:58:40,540 --> 00:58:43,620
และแกะเป็นที่ที่โปรแกรม
มีชีวิตอยู่ในขณะที่พวกเขากำลังทำงาน

1205
00:58:43,620 --> 00:58:46,630
>> ดังนั้นในทุก Mac หรือ PC เมื่อคุณเป็นสองเท่า
คลิกโปรแกรมและจะเปิดขึ้น

1206
00:58:46,630 --> 00:58:48,921
และจะเปิดบางเอกสาร Word
หรือสิ่งที่ต้องการที่

1207
00:58:48,921 --> 00:58:51,764
มันเก็บไว้ชั่วคราว
RAM, RAM เพราะจะเร็ว

1208
00:58:51,764 --> 00:58:53,680
กว่าฮาร์ดดิสก์ของคุณหรือ
ดิสก์ของรัฐที่มั่นคงของคุณ

1209
00:58:53,680 --> 00:58:56,600
จึงเป็นเพียงที่โปรแกรมไป
จะมีชีวิตอยู่เมื่อพวกเขากำลังทำงาน

1210
00:58:56,600 --> 00:58:58,060
หรือเมื่อไฟล์ที่มีการใช้

1211
00:58:58,060 --> 00:59:00,890
>> เพื่อให้คุณมีสิ่งที่มีลักษณะ
เช่นภายในของแล็ปท็อปของคุณนี้

1212
00:59:00,890 --> 00:59:03,320
หรือสิ่งที่ใหญ่กว่าเล็กน้อย
ภายในของเดสก์ทอปของคุณ

1213
00:59:03,320 --> 00:59:07,440
แต่ที่สำคัญคือคุณมีเพียง
จำนวน จำกัด ของสิ่งเหล่านี้

1214
00:59:07,440 --> 00:59:11,230
และมีเพียงจำนวน จำกัด
ฮาร์ดแวร์นั่งอยู่บนโต๊ะทำงานนี้ได้

1215
00:59:11,230 --> 00:59:11,730
ที่นี่

1216
00:59:11,730 --> 00:59:15,920
>> ดังนั้นแน่นอนเราไม่สามารถจัดเก็บ
ตัวเลขยาวเพียบ

1217
00:59:15,920 --> 00:59:19,030
และยังถ้าคุณคิดว่ากลับไป
โรงเรียนประถมศึกษาวิธีการหลายตัวเลขสามารถ

1218
00:59:19,030 --> 00:59:21,400
คุณต้องไปทางขวา
ของจุดทศนิยม?

1219
00:59:21,400 --> 00:59:24,680
สำหรับเรื่องที่ว่าหลายตัวเลขสามารถ
คุณมีทางด้านซ้ายของจุดทศนิยม?

1220
00:59:24,680 --> 00:59:26,300
จริงๆหลายอย่างมากมาย

1221
00:59:26,300 --> 00:59:30,840
>> ตอนนี้มนุษย์เราอาจเพียง
ทราบวิธีการออกเสียงล้าน

1222
00:59:30,840 --> 00:59:34,990
และพันล้านล้านล้านและ
quadrillion และ Quintillion

1223
00:59:34,990 --> 00:59:39,370
และฉันผลักดันขีด จำกัด ของฉัน
understanding-- หรือ my-- ฉันเข้าใจ

1224
00:59:39,370 --> 00:59:41,110
ตัวเลข แต่ของฉัน
การออกเสียงของตัวเลข

1225
00:59:41,110 --> 00:59:44,720
แต่พวกเขาจะได้รับการขนาดใหญ่ที่มีเพียบ
ตัวเลขหลายอย่างมากมายไปทางซ้าย

1226
00:59:44,720 --> 00:59:47,050
หรือไปทางขวาของจุดทศนิยม

1227
00:59:47,050 --> 00:59:50,040
>> แต่คอมพิวเตอร์มีเพียง
จำนวน จำกัด ของหน่วยความจำ

1228
00:59:50,040 --> 00:59:53,510
จำนวน จำกัด ของทรานซิสเตอร์เป็น
จำนวน จำกัด ของหลอดไฟภายใน

1229
00:59:53,510 --> 00:59:57,350
ดังนั้นสิ่งที่เกิดขึ้นเมื่อ
คุณทำงานออกจากพื้นที่?

1230
00:59:57,350 --> 00:59:59,620
ในคำอื่น ๆ ถ้าคุณ
คิดว่ากลับไปเมื่อสัปดาห์ที่แล้ว

1231
00:59:59,620 --> 01:00:03,160
เมื่อเราได้พูดคุยเกี่ยวกับตัวเลข
ตัวเองเป็นตัวแทนในไบนารี

1232
01:00:03,160 --> 01:00:05,480
สมมติว่าเรามี
นี้มูลค่า 8 บิตที่นี่

1233
01:00:05,480 --> 01:00:08,290
>> และเรามีเจ็ด 1 และ 0

1234
01:00:08,290 --> 01:00:10,827
และสมมติว่าเราต้องการ
เพื่อเพิ่ม 1 ค่านี้

1235
01:00:10,827 --> 01:00:12,410
นี้เป็นจำนวนมากจริงๆตอนนี้

1236
01:00:12,410 --> 01:00:16,610
>> นี่คือ 254 ถ้าผมจำได้ว่า
คณิตศาสตร์จากสัปดาห์ที่ผ่านมาทางด้านขวา

1237
01:00:16,610 --> 01:00:19,480
แต่สิ่งที่ถ้าฉันจะเปลี่ยน
ที่ขวาสุด 0 ถึง 1?

1238
01:00:19,480 --> 01:00:22,800
จำนวนทั้งหมดของ
แน่นอนจะกลายเป็นแปด 1

1239
01:00:22,800 --> 01:00:24,050
ดังนั้นเรายังคงดี

1240
01:00:24,050 --> 01:00:27,204
>> และนั่นอาจจะหมายถึง
255 แต่ขึ้นอยู่กับบริบท

1241
01:00:27,204 --> 01:00:29,120
จริง ๆ แล้วมันจะเป็นตัวแทน
จำนวนลบ

1242
01:00:29,120 --> 01:00:31,240
แต่เพิ่มเติมว่าเวลาอื่น

1243
01:00:31,240 --> 01:00:34,220
นี้รู้สึกเหมือนว่ามันจะเป็นเรื่องของ
สูงที่สุดเท่าที่ผมสามารถนับ

1244
01:00:34,220 --> 01:00:35,290
>> ตอนนี้ก็เป็นเพียง 8 บิต

1245
01:00:35,290 --> 01:00:38,170
และ Mac ของฉันก็มีวิธี
มากกว่า 8 บิตของหน่วยความจำ

1246
01:00:38,170 --> 01:00:39,170
แต่จะมี จำกัด

1247
01:00:39,170 --> 01:00:43,230
ดังนั้นอาร์กิวเมนต์เดียวกันแม้ว่าเรา
มีมากขึ้นของคนเหล่านี้บนหน้าจอ

1248
01:00:43,230 --> 01:00:47,020
>> แต่สิ่งที่เกิดขึ้นถ้าคุณ
การจัดเก็บจำนวนนี้ 255

1249
01:00:47,020 --> 01:00:49,290
และคุณต้องการที่จะนับ 1 บิตที่สูงขึ้น?

1250
01:00:49,290 --> 01:00:51,600
คุณต้องการที่จะไป 255-256

1251
01:00:51,600 --> 01:00:55,800
ปัญหาของหลักสูตรคือว่าถ้าคุณ
เริ่มนับที่ศูนย์เช่นสัปดาห์ที่ผ่านมา

1252
01:00:55,800 --> 01:00:59,670
คุณไม่สามารถนับสูงถึง
256 ให้อยู่คนเดียว 257

1253
01:00:59,670 --> 01:01:02,584
นับประสา 258 เมตรเพราะสิ่งที่
ที่เกิดขึ้นเมื่อคุณเพิ่ม 1?

1254
01:01:02,584 --> 01:01:05,000
ถ้าคุณทำโรงเรียนชั้นประถมศึกษาปีเก่า
วิธีการที่คุณใส่ 1 ที่นี่

1255
01:01:05,000 --> 01:01:08,150
และจากนั้น 1 บวก 1 คือ 2 แต่ที่
จริงๆศูนย์คุณดำเนินการ 1

1256
01:01:08,150 --> 01:01:09,695
ดำเนินการ 1 ดำเนินการ 1

1257
01:01:09,695 --> 01:01:12,620
ทุกสิ่งเหล่านี้
เหล่านี้ 1 ให้ไปที่ศูนย์

1258
01:01:12,620 --> 01:01:17,820
และคุณลมขึ้นใช่เป็นคน
ชี้ให้เห็นเป็นที่ 1 ด้านซ้ายมือ

1259
01:01:17,820 --> 01:01:22,540
แต่ทุกอย่างที่คุณสามารถ
เห็นจริงและเหมาะสมในหน่วยความจำ

1260
01:01:22,540 --> 01:01:27,960
เป็นเพียงแปด 0 ซึ่งคือการพูด
ในบางจุดถ้าคุณคอมพิวเตอร์

1261
01:01:27,960 --> 01:01:32,490
พยายามนับสูงพอขึ้นคุณ
จะห่อรอบมันจะดูเหมือน

1262
01:01:32,490 --> 01:01:35,850
ให้เป็นศูนย์หรืออาจจะติดลบ
ตัวเลขที่ต่ำกว่าศูนย์

1263
01:01:35,850 --> 01:01:37,260
>> และเราชนิดของสามารถดูนี้

1264
01:01:37,260 --> 01:01:39,900
ให้ฉันไปข้างหน้าและเขียน
โปรแกรมอย่างรวดเร็วจริงที่นี่

1265
01:01:39,900 --> 01:01:43,690
ให้ฉันไปข้างหน้าและเขียน
โปรแกรมที่เรียกว่ามากเกิน

1266
01:01:43,690 --> 01:01:49,980
รวม CS50.h รวม
มาตรฐาน IO.h-- โอ้

1267
01:01:49,980 --> 01:01:51,730
ผมพลาดการเน้นไวยากรณ์ของฉัน

1268
01:01:51,730 --> 01:01:54,440
จึงขอบันทึกเป็น overflow.c

1269
01:01:54,440 --> 01:01:57,084
>> และตอนนี้ int void-- หลัก
และอีกไม่นานเราจะ

1270
01:01:57,084 --> 01:01:59,500
กลับมาอธิบายว่าทำไม
เราให้เขียน int เป็นโมฆะหลัก

1271
01:01:59,500 --> 01:02:02,080
แต่สำหรับตอนนี้ขอเพียงแค่ทำ
มันเอามันให้ได้รับ

1272
01:02:02,080 --> 01:02:06,200
ขอให้ตัวเองเป็น int,
และเริ่มต้นมันเป็น 0

1273
01:02:06,200 --> 01:02:11,716
>> ลองมาแล้วทำเพื่อฉันได้รับ int zero--
จริงให้ทำวง จำกัด

1274
01:02:11,716 --> 01:02:12,590
และดูสิ่งที่เกิดขึ้น

1275
01:02:12,590 --> 01:02:22,440
ในขณะที่ความจริงแล้วลองพิมพ์ n
คิดเป็นร้อยละ i, ทับขวา N, plug-in n

1276
01:02:22,440 --> 01:02:27,200
แต่ตอนนี้ขอทำ n n ได้รับบวก 1

1277
01:02:27,200 --> 01:02:29,660
>> ดังนั้นในคำอื่น ๆ ในแต่ละ
ทวนของวง จำกัด นี้

1278
01:02:29,660 --> 01:02:32,550
ขอใช้เวลาคุ้มค่า n ของ
และเพิ่ม 1 ถึงมันแล้ว

1279
01:02:32,550 --> 01:02:34,350
เก็บผลที่ได้กลับมาอยู่ใน n ด้านซ้าย

1280
01:02:34,350 --> 01:02:37,150
และในความเป็นจริงที่เราเคยเห็นไวยากรณ์
เล็กน้อยเช่นนี้ในเวลาสั้น ๆ

1281
01:02:37,150 --> 01:02:39,730
เคล็ดลับเด็ดแทน
การเขียนออกมาทั้งหมดนี้

1282
01:02:39,730 --> 01:02:42,770
คุณจริงสามารถพูด n บวกเท่ากับ 1

1283
01:02:42,770 --> 01:02:47,480
>> หรือถ้าคุณอยากจะเป็นแฟนซี
ที่คุณสามารถพูด n บวกบวกกึ่งลำไส้ใหญ่

1284
01:02:47,480 --> 01:02:50,130
แต่สองคนหลังนี้เป็นเพียง
สิ่งที่เราต้องการโทรน้ำตาลประโยค

1285
01:02:50,130 --> 01:02:50,790
สำหรับสิ่งแรก

1286
01:02:50,790 --> 01:02:53,456
>> สิ่งแรกคืออย่างชัดเจนมากขึ้น
ปรับทั้งหมดที่ถูกต้องทั้งหมด

1287
01:02:53,456 --> 01:02:55,470
แต่นี่เป็นเรื่องธรรมดามากขึ้นผมจะบอกว่า

1288
01:02:55,470 --> 01:02:57,210
ดังนั้นเราจะทำเช่นนี้เพื่อรอสักครู่

1289
01:02:57,210 --> 01:03:01,685
>> ตอนนี้ขอให้ล้นซึ่งเสียง
ค่อนข้างเป็นลางไม่ดีล้นเฉือนจุด

1290
01:03:01,685 --> 01:03:04,380

1291
01:03:04,380 --> 01:03:09,852
ลองมาดู, N ได้รับใหญ่สวย

1292
01:03:09,852 --> 01:03:11,310
แต่ให้คิดว่าวิธีการใหญ่ n จะได้รับ?

1293
01:03:11,310 --> 01:03:12,870
>> n เป็น int

1294
01:03:12,870 --> 01:03:16,400
เราเห็นช่วงเวลาที่ผ่านมากับขนาดของ
ตัวอย่างที่เป็น int สี่ไบต์

1295
01:03:16,400 --> 01:03:22,070
เรารู้จากสัปดาห์ที่ผ่านมาสี่ไบต์
32 บิตเพราะ 8 ครั้งที่ 4 ที่ 32

1296
01:03:22,070 --> 01:03:23,460
ว่าจะเป็น 4 พันล้าน

1297
01:03:23,460 --> 01:03:25,802
>> และเรามีถึง 800,000

1298
01:03:25,802 --> 01:03:28,510
นี้จะใช้ตลอดไป
นับให้สูงที่สุดเท่าที่จะทำได้

1299
01:03:28,510 --> 01:03:30,635
ดังนั้นฉันจะไปข้างหน้า
ที่คุณอาจไม่นาน

1300
01:03:30,635 --> 01:03:34,910
และกดปุ่มควบคุม C-- ตรงไปตรงมา, การควบคุม
C, มากที่ C ควบคุมทั่วไป

1301
01:03:34,910 --> 01:03:36,034
หมายถึงการยกเลิก

1302
01:03:36,034 --> 01:03:38,200
แต่น่าเสียดายเพราะนี้
ทำงานในระบบคลาวด์

1303
01:03:38,200 --> 01:03:41,190
บางครั้งเมฆเป็น
สิ่งที่คายออกมาก

1304
01:03:41,190 --> 01:03:44,180
การส่งออกมากก็จะ
ใช้เวลาสักครู่สำหรับการป้อนข้อมูลของฉัน

1305
01:03:44,180 --> 01:03:45,630
ที่จะได้รับไปยังเมฆ

1306
01:03:45,630 --> 01:03:49,240
ดังนั้นแม้ว่าฉันตี
C ควบคุมไม่กี่วินาทีที่ผ่านมา

1307
01:03:49,240 --> 01:03:53,110
นี้แน่นอนด้านข้าง
ผลกระทบของวง จำกัด

1308
01:03:53,110 --> 01:03:56,070
>> และเพื่อให้ในกรณีดังกล่าวเรา
จะออกจากที่เป็น

1309
01:03:56,070 --> 01:03:59,050
และเรากำลังจะเพิ่มอีก
หน้าต่าง terminal มากกว่าที่นี่

1310
01:03:59,050 --> 01:04:03,186
กับบวกซึ่งแน่นอนไม่ได้
เช่นนั้นเพราะมันยังคงคิด

1311
01:04:03,186 --> 01:04:05,310
และให้ไปข้างหน้าและจะ
เล็ก ๆ น้อย ๆ ที่เหมาะสม

1312
01:04:05,310 --> 01:04:07,768
>> ฉันจะไปข้างหน้าและทำ
นี้เฉพาะขอบเขตหลายครั้ง

1313
01:04:07,768 --> 01:04:10,047
ลองใช้สำหรับห่วง
ซึ่งผมพูดพาดพิงถึงก่อนหน้านี้

1314
01:04:10,047 --> 01:04:10,630
ลงมือทำกันเถอะ.

1315
01:04:10,630 --> 01:04:13,430
ให้ฉัน int อีกตัวแปรหนึ่งที่ผมได้รับ 0

1316
01:04:13,430 --> 01:04:17,430
ฉันมีค่าน้อยกว่าสมมติว่า 64 ผม ++

1317
01:04:17,430 --> 01:04:24,010
และตอนนี้ให้ฉันไปข้างหน้าและการพิมพ์
ออก n เป็นร้อยละฉันจุลภาค n

1318
01:04:24,010 --> 01:04:27,547
แล้ว n-- นี้ยังคงเป็น
จะใช้เวลาตลอด

1319
01:04:27,547 --> 01:04:28,130
ลงมือทำกันเถอะ.

1320
01:04:28,130 --> 01:04:30,620
>> n n ได้รับครั้งที่ 2

1321
01:04:30,620 --> 01:04:34,140
หรือเราอาจจะแฟนซี
และทำครั้งเท่ากับ 2

1322
01:04:34,140 --> 01:04:37,120
แต่ขอเพียงแค่พูดว่า n
เท่ากับตัวเองครั้งที่ 2

1323
01:04:37,120 --> 01:04:39,321
ในคำอื่น ๆ ในเรื่องนี้
รุ่นใหม่ของโปรแกรม

1324
01:04:39,321 --> 01:04:41,820
ฉันไม่ต้องการที่จะรอตลอดไป
จาก 800,000 เช่น 4 พันล้าน

1325
01:04:41,820 --> 01:04:43,070
ขอเพียงได้รับนี้ไปด้วย

1326
01:04:43,070 --> 01:04:44,920
>> Let 's จริงคู่ n ในแต่ละครั้ง

1327
01:04:44,920 --> 01:04:47,660
ซึ่งการเรียกคืนเป็นสองเท่า
ตรงข้ามของการมีของหลักสูตร

1328
01:04:47,660 --> 01:04:50,035
และในขณะที่สัปดาห์ที่ผ่านมาเรามี
บางสิ่งบางอย่างอีกครั้งและอีกครั้ง

1329
01:04:50,035 --> 01:04:52,200
และอีกครั้งเร็วสุด,
ก็จะเพิ่มขึ้น

1330
01:04:52,200 --> 01:04:58,080
ได้รับเราจาก 1 ถึงที่ใหญ่ที่สุดที่เป็นไปได้
ค่าที่เราสามารถนับถึงกับ int

1331
01:04:58,080 --> 01:04:59,750
>> เพื่อขอทำตรงนี้

1332
01:04:59,750 --> 01:05:01,720
และเราจะกลับไปที่นี้มาก่อนที่จะยาว

1333
01:05:01,720 --> 01:05:04,180
แต่นี้อีกครั้งเป็นเช่นเดียวกับ
บล็อกซ้ำรอยขีดข่วน

1334
01:05:04,180 --> 01:05:05,600
และคุณจะใช้นี้ก่อนที่จะยาว

1335
01:05:05,600 --> 01:05:10,170
>> เพียงแค่นี้ก็หมายความว่านับจากศูนย์
ขึ้นไป แต่ไม่เท่ากันถึง 64

1336
01:05:10,170 --> 01:05:14,285
และทวนของแต่ละ
ห่วงเพียงให้การเพิ่มฉัน

1337
01:05:14,285 --> 01:05:18,990
ดังนั้น i ++ - และนี่สร้างทั่วไป
ในบรรทัดที่ 7 เป็นเพียงวิธีที่พบบ่อยสุด

1338
01:05:18,990 --> 01:05:22,290
ของการทำซ้ำเส้นบาง
รหัสจำนวนครั้งบาง

1339
01:05:22,290 --> 01:05:23,362
ซึ่งสายรหัส?

1340
01:05:23,362 --> 01:05:25,570
เหล่านี้วงเล็บปีกกาเป็นคุณ
อาจจะมีการรวบรวมได้จากตอนนี้

1341
01:05:25,570 --> 01:05:26,780
หมายถึงการทำต่อไปนี้

1342
01:05:26,780 --> 01:05:29,510
>> มันอยู่ในรอยขีดข่วนเช่นเมื่อ
มันมีบล็อกสีเหลือง

1343
01:05:29,510 --> 01:05:32,680
และสีอื่น ๆ ที่ชนิดของ
โอบกอดหรือกอดบล็อกอื่น ๆ

1344
01:05:32,680 --> 01:05:34,750
นั่นคือสิ่งที่หยิก
การจัดฟันจะทำอะไรที่นี่

1345
01:05:34,750 --> 01:05:40,200
ดังนั้นถ้าผมได้ไวยากรณ์ของฉัน right-- คุณ
สามารถมองเห็นสัญลักษณ์แครอทใน C หมายถึง

1346
01:05:40,200 --> 01:05:42,706
ว่าเป็นวิธีที่หลายครั้งที่ฉันเป็น
พยายามที่จะแก้ปัญหานี้

1347
01:05:42,706 --> 01:05:45,330
จึงขอกำจัดที่หนึ่ง
ทั้งหมดและปิดหน้าต่างที่

1348
01:05:45,330 --> 01:05:46,520
และเราจะใช้ใหม่

1349
01:05:46,520 --> 01:05:51,980
ทำให้ล้นเฉือนจุด
ล้นใส่ขวาทั้งหมด

1350
01:05:51,980 --> 01:05:53,090
มันดูไม่ดีในตอนแรก

1351
01:05:53,090 --> 01:05:56,200
แต่ขอเลื่อนกลับในเวลา
เพราะผมทำอย่างนี้ 64 ครั้ง

1352
01:05:56,200 --> 01:05:58,700
>> และแจ้งให้ทราบเป็นครั้งแรกที่ n คือ 1

1353
01:05:58,700 --> 01:06:03,110
ครั้งที่สอง, N คือ 2
แล้ว 4 แล้ว 8 แล้ว 16

1354
01:06:03,110 --> 01:06:09,450
และดูเหมือนว่าเร็วที่สุดเท่าที่
ฉันได้รับการประมาณ 1 พันล้าน,

1355
01:06:09,450 --> 01:06:12,800
ถ้าฉันเป็นสองเท่าอีกครั้งว่า
ควรให้ฉัน 2 พันล้าน

1356
01:06:12,800 --> 01:06:14,980
แต่มันจะเปิดออกก็
ขวาบนยอด

1357
01:06:14,980 --> 01:06:18,930
>> และเพื่อให้มันจริงล้น
เป็น int จาก 1 พันล้าน

1358
01:06:18,930 --> 01:06:23,514
ลบประมาณ 2
พันล้านเพราะจำนวนเต็ม

1359
01:06:23,514 --> 01:06:25,430
ซึ่งแตกต่างจากตัวเลขเรา
ถูกสมมติว่าสัปดาห์ที่ผ่านมา

1360
01:06:25,430 --> 01:06:28,397
สามารถเป็นได้ทั้งบวกและลบ
ในความเป็นจริงและในเครื่องคอมพิวเตอร์

1361
01:06:28,397 --> 01:06:30,730
และเพื่อให้อย่างน้อยหนึ่งในบรรดา
บิตถูกขโมยได้อย่างมีประสิทธิภาพ

1362
01:06:30,730 --> 01:06:34,190
ดังนั้นเราจริงๆมีเพียง 31 บิต
หรือ 2 พันล้านค่าที่เป็นไป

1363
01:06:34,190 --> 01:06:38,220
>> แต่ตอนนี้ Takeaway ที่ค่อนข้าง
เพียงแค่ตัวเลขเหล่านี้เป็นสิ่งที่

1364
01:06:38,220 --> 01:06:42,280
คณิตศาสตร์และสิ่งที่เป็น
สิ่งที่ไม่ดีที่เกิดขึ้นในที่สุด

1365
01:06:42,280 --> 01:06:46,980
เพราะในที่สุดคุณกำลังพยายามที่จะ
เปลี่ยนรูปบิตหนึ่งหลายครั้งเกินไป

1366
01:06:46,980 --> 01:06:51,060
และคุณได้อย่างมีประสิทธิภาพไปจากทั้งหมด
1 ที่จะอาจจะทั้งหมด 0 หรืออาจจะ

1367
01:06:51,060 --> 01:06:54,260
เพียงบางรูปแบบอื่น ๆ ที่
อย่างชัดเจนขึ้นอยู่กับบริบท

1368
01:06:54,260 --> 01:06:56,342
สามารถตีความได้ว่าเป็นจำนวนลบ

1369
01:06:56,342 --> 01:06:59,300
และอื่น ๆ ก็จะดูเหมือนฉันสูงสุด
สามารถนับในโปรแกรมนี้โดยเฉพาะอย่างยิ่ง

1370
01:06:59,300 --> 01:07:01,210
เป็นเพียงประมาณ 1 พันล้าน

1371
01:07:01,210 --> 01:07:02,760
แต่มีวิธีการแก้ปัญหาบางส่วนที่นี่

1372
01:07:02,760 --> 01:07:03,480
คุณรู้ไหมว่า?

1373
01:07:03,480 --> 01:07:07,600
>> ผมขอเปลี่ยนจาก
int ไปนาน

1374
01:07:07,600 --> 01:07:10,633
และแจ้งให้เราไปข้างหน้านี่
และ say-- ฉันจะมี

1375
01:07:10,633 --> 01:07:12,290
การเปลี่ยนแปลงนี้จะไม่ได้ลงนามยาว

1376
01:07:12,290 --> 01:07:16,860
หรือขอดูผมไม่เคยจำได้ว่าตัวเอง

1377
01:07:16,860 --> 01:07:19,920
>> Let 's ไปข้างหน้าและทำให้น้ำล้น

1378
01:07:19,920 --> 01:07:21,860
ไม่มีที่ไม่ได้แนวหน้าขอขอบคุณ

1379
01:07:21,860 --> 01:07:23,430
ดังนั้นบางครั้งเสียงดังกราวจะมีประโยชน์

1380
01:07:23,430 --> 01:07:27,550
ผมจำไม่ได้ว่าสิ่งที่รูปแบบ
ระบุเป็นสำหรับระยะยาว

1381
01:07:27,550 --> 01:07:28,950
>> แต่ที่จริงแล้วเสียงดังกราวบอกฉัน

1382
01:07:28,950 --> 01:07:31,570
สีเขียวเป็นชนิดของดีบางอย่าง
ยังหมายความว่าคุณทำผิดพลาด

1383
01:07:31,570 --> 01:07:33,190
มันคาดเดาว่าฉันหมายถึงแนวหน้า

1384
01:07:33,190 --> 01:07:38,750
>> เพื่อให้ฉันใช้มันเป็นคำแนะนำที่มีความยาว
เลขทศนิยมยาวประหยัด

1385
01:07:38,750 --> 01:07:43,190
และแจ้งให้เราเรียกมันดอท
เฉือนล้นใส่

1386
01:07:43,190 --> 01:07:45,020
และตอนนี้สิ่งที่เย็นนี้

1387
01:07:45,020 --> 01:07:49,140
>> ถ้าผมเลื่อนกลับในเวลาที่เรายังคงเริ่มต้น
นับในเวลาเดียวกันกิจกรรมดังนั้นเล็กน้อย 1, 2, 4,

1388
01:07:49,140 --> 01:07:50,220
8, 16

1389
01:07:50,220 --> 01:07:54,860
แจ้งให้ทราบว่าเราได้รับทั้งหมด
ทางขึ้นไป 1 พันล้าน

1390
01:07:54,860 --> 01:07:57,070
แต่แล้วเราได้อย่างปลอดภัยได้รับไป 2 พันล้าน

1391
01:07:57,070 --> 01:08:01,300
>> จากนั้นเราจะได้ 4 พันล้าน
แล้ว 8 พันล้าน, 17 พันล้าน

1392
01:08:01,300 --> 01:08:03,340
และเราไปที่สูงขึ้นและ
สูงขึ้นและสูงขึ้น.

1393
01:08:03,340 --> 01:08:05,740
ในที่สุดนี้มากเกินไปแบ่ง

1394
01:08:05,740 --> 01:08:09,350
>> ในที่สุดด้วยความยาวยาว
ซึ่งเป็นมูลค่า 64 บิตไม่

1395
01:08:09,350 --> 01:08:13,660
ค่า 32 บิตถ้าคุณนับ
สูงเกินไปคุณห่อรอบ 0

1396
01:08:13,660 --> 01:08:16,410
และในกรณีนี้เราเกิดขึ้นกับ
จบลงด้วยจำนวนลบ

1397
01:08:16,410 --> 01:08:17,550
>> ดังนั้นปัญหานี้เป็นปัญหา

1398
01:08:17,550 --> 01:08:20,439
และปรากฎว่านี้
ปัญหาไม่ได้ทั้งหมดที่เป็นความลับ

1399
01:08:20,439 --> 01:08:23,060
แม้ว่าฉันจะได้จงใจ
เหนี่ยวนำด้วยความผิดพลาดเหล่านี้

1400
01:08:23,060 --> 01:08:26,149
มันจะเปิดออกที่เราเห็นมันทุกชนิด
รอบตัวเราหรืออย่างน้อยบางส่วนของเราทำ

1401
01:08:26,149 --> 01:08:28,939
>> ดังนั้นในเลโก้สตาร์วอถ้า
คุณเคยเล่นเกม

1402
01:08:28,939 --> 01:08:33,830
มันจะเปิดออกคุณสามารถไปรอบ ๆ
ทำลายสิ่งขึ้นในโลกเลโก้

1403
01:08:33,830 --> 01:08:36,640
และเก็บเหรียญเป็นหลัก

1404
01:08:36,640 --> 01:08:39,200
และถ้าคุณเคยเล่น
เกมนี้ทางเวลามากเกินไป

1405
01:08:39,200 --> 01:08:42,630
เป็นบุคคลที่ไม่มีชื่อนี้
ที่นี่ได้จำนวนทั้งหมด

1406
01:08:42,630 --> 01:08:46,700
ของเหรียญที่คุณสามารถเก็บ
คือมันจะดูเหมือน 4 พันล้าน

1407
01:08:46,700 --> 01:08:48,240
>> ขณะนี้มีมันกลมจริง

1408
01:08:48,240 --> 01:08:50,239
ดังนั้น LEGO ได้พยายามที่จะ
ให้ผู้ใช้สิ่งที่เป็นมิตร

1409
01:08:50,239 --> 01:08:53,779
พวกเขาไม่ได้ทำมันตรง 2
32 อำนาจต่อสัปดาห์ที่ผ่านมา

1410
01:08:53,779 --> 01:08:55,310
แต่ 4 พันล้านเหตุผล

1411
01:08:55,310 --> 01:08:58,979
ดูเหมือนว่าบนพื้นฐานของข้อมูลนี้
ที่เลโก้และ บริษัท ดังกล่าว

1412
01:08:58,979 --> 01:09:02,624
ทำซอฟต์แวร์ที่เกิดขึ้นจริงนี้ตัดสินใจ
ว่าจำนวนสูงสุดของเหรียญ

1413
01:09:02,624 --> 01:09:04,540
ผู้ใช้สามารถสะสม
เป็นแท้จริง 4 พันล้าน

1414
01:09:04,540 --> 01:09:12,069
เพราะพวกเขาเลือกในรหัสของพวกเขา
จะใช้เวลานานไม่นานเห็นได้ชัด

1415
01:09:12,069 --> 01:09:16,140
แต่เพียงจำนวนเต็มไม่ได้ลงนาม
จำนวนเต็มเท่านั้นที่เป็นจำนวนเต็มบวกที่มี

1416
01:09:16,140 --> 01:09:18,089
ค่าสูงสุดคือประมาณว่า

1417
01:09:18,089 --> 01:09:19,380
ดีที่นี่เป็นอีกหนึ่งตลก

1418
01:09:19,380 --> 01:09:23,500
ดังนั้นในเกมอารยธรรมซึ่ง
บางท่านอาจจะคุ้นเคยกับ

1419
01:09:23,500 --> 01:09:26,660
ปรากฎว่าปีที่ผ่านมามี
เป็นข้อผิดพลาดในเกมนี้โดย

1420
01:09:26,660 --> 01:09:28,750
ถ้าคุณเล่นบทบาท
ของคานธีในเกม

1421
01:09:28,750 --> 01:09:34,020
แทนของเขาเป็นความสงบมาก
แทนที่จะเป็นอย่างไม่น่าเชื่ออย่างไม่น่าเชื่อ

1422
01:09:34,020 --> 01:09:36,399
ก้าวร้าวในบางสถานการณ์

1423
01:09:36,399 --> 01:09:40,529
โดยเฉพาะอย่างยิ่งวิธีการที่อารยธรรม
ผลงานก็คือว่าถ้าคุณเล่นการพนัน

1424
01:09:40,529 --> 01:09:44,680
นำมาใช้ในการปกครองระบอบประชาธิปไตยของคุณ
คะแนนที่ได้รับความแข็งขัน

1425
01:09:44,680 --> 01:09:48,130
decremented สองเพื่อลบ
ลบแล้วลบลบ

1426
01:09:48,130 --> 01:09:50,569
>> ดังนั้นคุณลบ 2 จาก
iterating ที่แท้จริงของคุณ

1427
01:09:50,569 --> 01:09:56,650
แต่ถ้าคุณเป็น iterating
ในขั้นต้นที่ 1 และ 2 คุณลบจากมัน

1428
01:09:56,650 --> 01:09:59,050
หลังจากการนำประชาธิปไตย
เป็นคานธีที่นี่อาจจะ

1429
01:09:59,050 --> 01:10:02,200
ได้ทำเพราะเขาเป็น passive-- มาก
1 โยแข็งขัน

1430
01:10:02,200 --> 01:10:04,830
แต่ถ้าเขาทำผิดกฎหมายการปกครองระบอบประชาธิปไตยแล้ว
เขาจะไปจาก 1 ถึง 1 ในแง่ลบ

1431
01:10:04,830 --> 01:10:11,470
>> แต่น่าเสียดายที่พวกเขา
โดยใช้ตัวเลขที่ไม่ได้ลงชื่อ

1432
01:10:11,470 --> 01:10:15,400
ซึ่งหมายความว่าพวกเขาได้รับการรักษาในเชิงลบแม้กระทั่ง
หมายเลขราวกับว่าพวกเขาเป็นบวก

1433
01:10:15,400 --> 01:10:19,780
และปรากฎว่า
เทียบเท่าในเชิงบวกของติดลบ 1

1434
01:10:19,780 --> 01:10:23,480
ในโปรแกรมคอมพิวเตอร์ทั่วไปคือ 255

1435
01:10:23,480 --> 01:10:27,250
ดังนั้นถ้าคานธี adopts
ประชาธิปไตยและดังนั้นจึงมี

1436
01:10:27,250 --> 01:10:32,470
คะแนนความก้าวร้าวของเขาลดลง
มันจริงม้วนรอบ 255

1437
01:10:32,470 --> 01:10:35,470
และทำให้เขามากที่สุด
ตัวละครในเชิงรุกในเกม

1438
01:10:35,470 --> 01:10:36,930
เพื่อให้คุณสามารถ Google ขึ้นเกี่ยวกับเรื่องนี้

1439
01:10:36,930 --> 01:10:39,380
และมันก็เป็นจริงนัก
ข้อผิดพลาดในการเขียนโปรแกรมโดยไม่ได้ตั้งใจ

1440
01:10:39,380 --> 01:10:43,010
แต่ที่เข้ามาค่อนข้าง
ตำนานนับตั้งแต่

1441
01:10:43,010 --> 01:10:44,360
>> นั่นคือทั้งหมดที่สนุกและน่ารัก

1442
01:10:44,360 --> 01:10:47,760
น่ากลัวมากขึ้นคือเมื่อเกิดขึ้นจริง
อุปกรณ์โลกแห่งความจริงและไม่เกม

1443
01:10:47,760 --> 01:10:48,820
มีข้อบกพร่องเหล่านี้เหมือนกัน

1444
01:10:48,820 --> 01:10:54,500
ในความเป็นจริงเพียงหนึ่งปีที่ผ่านมาบทความมา
เกี่ยวกับโบอิ้ง 787

1445
01:10:54,500 --> 01:10:56,850
>> และบทความในตอนแรก
ได้อย่างรวดเร็วอ่านความลับเล็ก ๆ น้อย ๆ

1446
01:10:56,850 --> 01:11:01,480
แต่ก็กล่าวว่านี้ซอฟแวร์
ช่องโหว่ในของโบอิ้ง

1447
01:11:01,480 --> 01:11:04,790
ใหม่ 787 เจ็ทมี
มีศักยภาพที่จะทำให้เกิดนักบิน

1448
01:11:04,790 --> 01:11:07,220
การสูญเสียการควบคุม
เครื่องบินอาจจะเป็น

1449
01:11:07,220 --> 01:11:11,750
ในช่วงกลางเดือนเที่ยวบิน, เจ้าหน้าที่จอห์นฟา
สายการบินเตือนเมื่อเร็ว ๆ นี้

1450
01:11:11,750 --> 01:11:14,520
มันเป็นความมุ่งมั่น
ว่ารุ่น 787

1451
01:11:14,520 --> 01:11:19,770
เครื่องบินที่ได้รับการขับเคลื่อน
ต่อเนื่องเป็นเวลา 248 วัน

1452
01:11:19,770 --> 01:11:24,880
จะสูญเสียทุกกระแสสลับ AC,
พลังงานไฟฟ้าเนื่องจากเครื่องกำเนิดไฟฟ้า

1453
01:11:24,880 --> 01:11:28,892
หน่วยควบคุม GCUs พร้อมกัน
ที่จะเข้าสู่โหมด Fail Safe

1454
01:11:28,892 --> 01:11:29,850
มันเป็นชนิดของการสูญเสียผม

1455
01:11:29,850 --> 01:11:35,390
แต่บันทึกกล่าวว่าตกลงตอนนี้ผมได้ที่
สภาพที่เกิดจากซอฟแวร์

1456
01:11:35,390 --> 01:11:38,590
ตอบโต้ภายใน
การควบคุมเครื่องกำเนิดไฟฟ้า

1457
01:11:38,590 --> 01:11:44,860
หน่วยงานที่จะล้นหลัง
248 วันของการใช้พลังงานอย่างต่อเนื่อง

1458
01:11:44,860 --> 01:11:47,070
เราจะออกนี้
ทราบเพื่อป้องกันการสูญหาย

1459
01:11:47,070 --> 01:11:49,300
ทุก AC ไฟฟ้า
พลังงานซึ่งอาจส่งผล

1460
01:11:49,300 --> 01:11:50,980
สูญเสียการควบคุมเครื่องบิน

1461
01:11:50,980 --> 01:11:55,380
>> ดังนั้นตัวอักษรมีจำนวนเต็มบาง
หรือเทียบเท่าชนิดข้อมูล

1462
01:11:55,380 --> 01:11:57,960
ถูกนำมาใช้ในซอฟแวร์
ในเครื่องบินที่เกิดขึ้นจริง

1463
01:11:57,960 --> 01:12:00,756
ว่าถ้าคุณเก็บเครื่องบินของคุณ
ในนานพอซึ่งเห็นได้ชัด

1464
01:12:00,756 --> 01:12:03,880
สามารถเป็นกรณีที่หากคุณกำลังใช้งานเพียงแค่
พวกเขาอย่างต่อเนื่องและไม่เคยถอด

1465
01:12:03,880 --> 01:12:06,810
เครื่องบินของคุณดูเหมือนว่าหรือ
ปล่อยให้แบตเตอรี่ตาย

1466
01:12:06,810 --> 01:12:09,840
ในที่สุดก็จะนับขึ้นและขึ้น
และขึ้นและขึ้นและขึ้นและขึ้น

1467
01:12:09,840 --> 01:12:12,150
>> และโดยธรรมชาติเป็น
จำนวน จำกัด ของหน่วยความจำ

1468
01:12:12,150 --> 01:12:15,880
จะล้นกลิ้งกลับไป
ศูนย์หรือบางค่าลบ

1469
01:12:15,880 --> 01:12:19,920
ผลข้างเคียงของซึ่งเป็น
ความเป็นจริงที่แท้จริงตระหนก

1470
01:12:19,920 --> 01:12:23,970
ว่าเครื่องบินอาจต้อง
จะได้รับการรีบูตมีประสิทธิภาพ

1471
01:12:23,970 --> 01:12:27,290
หรืออาจจะตกแย่ลงในขณะที่มันบิน

1472
01:12:27,290 --> 01:12:29,230
ดังนั้นเหล่านี้ชนิดของปัญหา
ยังคงอยู่กับเรา

1473
01:12:29,230 --> 01:12:33,130
even-- นี้เป็นบทความปี 2015
ทั้งหมดน่ากลัวมากขึ้น

1474
01:12:33,130 --> 01:12:36,100
เมื่อคุณไม่จำเป็นต้อง
เข้าใจชื่นชมหรือคาดหวัง

1475
01:12:36,100 --> 01:12:38,640
ผู้ที่ชนิดของข้อผิดพลาด

1476
01:12:38,640 --> 01:12:42,030
>> ดังนั้นจึงปรากฎว่ามีคนอื่น ๆ
สิ่งที่ไม่ดีเกี่ยวกับการแสดงข้อมูล

1477
01:12:42,030 --> 01:12:47,080
แต่กลับกลายเป็นว่าแม้จะลอยอยู่
ชนิดของข้อบกพร่องเพราะลอยเกินไป

1478
01:12:47,080 --> 01:12:51,440
ผมเสนอ 32 บิตหรือ
อาจจะ 64 ถ้าคุณใช้คู่

1479
01:12:51,440 --> 01:12:53,070
แต่ที่ยังคง จำกัด

1480
01:12:53,070 --> 01:12:57,070
>> และจับคือว่าถ้าคุณสามารถ
ใส่จำนวนอนันต์ของตัวเลข

1481
01:12:57,070 --> 01:12:59,460
หลังจากจุดทศนิยม
มีวิธีที่คุณไม่มี

1482
01:12:59,460 --> 01:13:02,690
สามารถเป็นตัวแทนเป็นไปได้ทั้งหมด
ตัวเลขที่เราได้รับการสอน

1483
01:13:02,690 --> 01:13:04,990
ในชั้นประถมศึกษาโรงเรียนสามารถอยู่ในโลก

1484
01:13:04,990 --> 01:13:08,870
คอมพิวเตอร์เป็นหลักมีการ
เลือกกลุ่มย่อยของตัวเลขเหล่านั้น

1485
01:13:08,870 --> 01:13:10,200
เพื่อเป็นตัวแทนอย่างถูกต้อง

1486
01:13:10,200 --> 01:13:12,450
>> ตอนนี้คอมพิวเตอร์สามารถ
รอบอาจจะนิด ๆ หน่อย ๆ

1487
01:13:12,450 --> 01:13:17,900
และช่วยให้คุณสามารถจัดเก็บประมาณ
จำนวนใด ๆ ที่คุณอาจต้องการ

1488
01:13:17,900 --> 01:13:20,940
แต่เพียงอย่างสังหรณ์ใจถ้าคุณ
มีจำนวน จำกัด ของบิต

1489
01:13:20,940 --> 01:13:24,560
คุณสามารถเปลี่ยนรูปพวกเขา
ในรูปแบบที่แน่นอนจำนวนมากดังนั้น

1490
01:13:24,560 --> 01:13:26,570
ดังนั้นคุณจึงไม่อาจ
ใช้จำนวน จำกัด

1491
01:13:26,570 --> 01:13:29,880
ของการเปลี่ยนแปลงของบิต
รูปแบบของศูนย์และคน,

1492
01:13:29,880 --> 01:13:32,940
เพื่อเป็นตัวแทนของอนันต์
จำนวนของตัวเลข

1493
01:13:32,940 --> 01:13:37,370
ซึ่งแสดงให้เห็นว่าคอมพิวเตอร์อาจ
เป็นอย่างดีจะโกหกเราบางครั้ง

1494
01:13:37,370 --> 01:13:38,770
>> ในความเป็นจริงเรามาทำเช่นนี้

1495
01:13:38,770 --> 01:13:41,239
ผมขอกลับไปเป็น IDE CS50

1496
01:13:41,239 --> 01:13:43,030
ให้ฉันไปข้างหน้าและ
สร้างโปรแกรมเล็ก ๆ น้อย ๆ

1497
01:13:43,030 --> 01:13:47,940
เรียกว่าไม่แน่ชัดเพื่อแสดงให้เห็นว่า
คอมพิวเตอร์เป็นจริงไม่แน่ชัด

1498
01:13:47,940 --> 01:13:51,910
>> และแจ้งให้เราไปข้างหน้าและเริ่มต้นด้วย
บางส่วนของรหัสที่ก่อนหน้านี้เท่านั้น

1499
01:13:51,910 --> 01:13:53,830
และตอนนี้ก็ทำต่อไปนี้

1500
01:13:53,830 --> 01:14:03,640
ให้ฉันไปข้างหน้าและทำ printf ร้อยละ
F, ทับขวา N, 1 หารด้วย 10

1501
01:14:03,640 --> 01:14:07,430
ในคำอื่น ๆ ลองดำน้ำลึก
1/10 เช่น 1 และหารด้วย 10

1502
01:14:07,430 --> 01:14:09,760
แท้จริงคอมพิวเตอร์สามารถเป็นตัวแทน 1/10

1503
01:14:09,760 --> 01:14:13,620
>> ดังนั้นขอให้ไปข้างหน้าและทำให้ไม่แน่ชัด

1504
01:14:13,620 --> 01:14:14,390
มาดูกัน.

1505
01:14:14,390 --> 01:14:16,210
รูปแบบระบุประเภทคู่

1506
01:14:16,210 --> 01:14:18,160
แต่ข้อโต้แย้งที่มีชนิด int

1507
01:14:18,160 --> 01:14:19,040
เกิดอะไรขึ้น?

1508
01:14:19,040 --> 01:14:21,970
>> โอ้น่าสนใจจึงเป็น
บทเรียนที่ได้เรียนรู้จากก่อน

1509
01:14:21,970 --> 01:14:26,050
ฉันพูดเดี๋ยวก่อนโชว์คอมพิวเตอร์
ฉันลอยกับร้อยละ F

1510
01:14:26,050 --> 01:14:28,200
แต่ฉันให้มัน 2 ints

1511
01:14:28,200 --> 01:14:31,120
ดังนั้นมันจะเปิดออกผมสามารถแก้ไข
ในสองวิธี

1512
01:14:31,120 --> 01:14:38,430
>> ฉันเพียงแค่อาจจะเปลี่ยนหนึ่งไป 1.0 และ
10 เข้า 10.0 ซึ่งจะแน่นอน

1513
01:14:38,430 --> 01:14:42,390
มีผลของการแปลง
พวกเขาเข้าไปใน floats-- ยังคงหวังว่า

1514
01:14:42,390 --> 01:14:43,180
หมายเลขเดียวกัน

1515
01:14:43,180 --> 01:14:45,880
หรือมันจะเปิดออกมีบางสิ่งบางอย่าง
เราจะได้เห็นอีกครั้งก่อนที่จะยาว

1516
01:14:45,880 --> 01:14:47,170
คุณสามารถโยนตัวเลข

1517
01:14:47,170 --> 01:14:49,880
>> คุณสามารถใช้สอดนี้
การแสดงออกของคุณสามารถพูดได้ว่า

1518
01:14:49,880 --> 01:14:52,560
Hey, คอมพิวเตอร์, ใช้เวลานี้
10 ซึ่งฉันรู้ว่าเป็น int

1519
01:14:52,560 --> 01:14:54,660
แต่รักษามันโปรด
ราวกับว่ามันเป็นลอย

1520
01:14:54,660 --> 01:14:56,680
แต่ตอนนี้ความรู้สึกที่ซับซ้อนโดยไม่จำเป็น

1521
01:14:56,680 --> 01:14:59,040
>> สำหรับวัตถุประสงค์ของเราในวันนี้
ขอเพียงแค่ตัวอักษร

1522
01:14:59,040 --> 01:15:02,700
ทำให้พวกเขาลอยค่าจุด
มีจุดทศนิยมเช่นนี้

1523
01:15:02,700 --> 01:15:07,060
ให้ฉันไปข้างหน้าและวิ่งให้
ไม่แน่ชัดดีเฉือนจุด

1524
01:15:07,060 --> 01:15:08,870
ไม่แน่ชัดป้อน

1525
01:15:08,870 --> 01:15:10,990
ตกลงเรากำลังมองหาที่ดี

1526
01:15:10,990 --> 01:15:18,194
>> 1 หารด้วย 10 ตามที่ของฉัน
Mac ที่นี่เป็นแท้จริง 0.100000

1527
01:15:18,194 --> 01:15:21,360
ตอนนี้ผมได้รับการสอนในโรงเรียนประถมศึกษามี
ควรจะเป็นจำนวนอนันต์ของ 0

1528
01:15:21,360 --> 01:15:23,151
ดังนั้นขออย่างน้อยพยายาม
จะเห็นบางส่วนของคนเหล่านั้น

1529
01:15:23,151 --> 01:15:26,770
แต่กลับกลายเป็นว่า printf เป็นเพียงเล็กน้อย
ยังคงเป็นนักเล่นกว่าที่เราได้รับใช้

1530
01:15:26,770 --> 01:15:30,890
แต่กลับกลายเป็นคุณไม่ได้มีการระบุ
เพียงแค่ร้อยละ F หรือเพียงแค่ร้อยละฉัน

1531
01:15:30,890 --> 01:15:33,830
จริงๆคุณสามารถระบุ
บางตัวเลือกการควบคุมที่นี่

1532
01:15:33,830 --> 01:15:36,470
>> โดยเฉพาะผมจะ
ที่จะบอกว่าเดี๋ยวก่อน printf,

1533
01:15:36,470 --> 01:15:39,660
แสดงให้ฉันจริง 10 คะแนนทศนิยม

1534
01:15:39,660 --> 01:15:40,820
ดังนั้นมันจึงดูแปลกเล็กน้อย

1535
01:15:40,820 --> 01:15:42,845
แต่คุณบอกว่าร้อยละ
จุดตัวเลขหลายวิธี

1536
01:15:42,845 --> 01:15:44,970
คุณต้องการที่จะเห็นหลังจากที่
จุดทศนิยมแล้ว F

1537
01:15:44,970 --> 01:15:48,340
สำหรับแบนเพียงเพราะนั่นคือ
สิ่งที่เอกสารกล่าวว่า

1538
01:15:48,340 --> 01:15:50,080
ให้ฉันไปข้างหน้าและประหยัด

1539
01:15:50,080 --> 01:15:52,460
>> และแจ้งให้ทราบเกินไปฉันได้รับ
เหนื่อยกับการพิมพ์ดีดครั้งใหม่สิ่ง

1540
01:15:52,460 --> 01:15:55,900
ดังนั้นฉันแค่การตั้งค่าและ
ลูกศรชี้ลงบนแป้นของฉันที่นี่

1541
01:15:55,900 --> 01:15:58,710
และถ้าผมให้กดปุ่มขึ้นคุณ
สามารถดูคำสั่ง

1542
01:15:58,710 --> 01:16:01,090
ที่ฉันทำหรือทำไม่ถูกต้อง

1543
01:16:01,090 --> 01:16:04,630
>> และฉันจะไปข้างหน้าในขณะนี้และ
ไม่ได้ใช้งานจริงที่เห็นได้ชัด

1544
01:16:04,630 --> 01:16:11,416
ทำให้ไม่แน่ชัดจุด
เฉือน imprecision-- ดังนั้น

1545
01:16:11,416 --> 01:16:13,290
สิ่งที่ฉันได้รับการสอนใน
ตรวจสอบโรงเรียนเกรดออก

1546
01:16:13,290 --> 01:16:19,010
แม้ว่าผมจะพิมพ์ได้ถึง 10 ทศนิยม
สถานที่ที่มันแน่นอนคือ 0.10000

1547
01:16:19,010 --> 01:16:19,840
แต่คุณรู้อะไรไหม

1548
01:16:19,840 --> 01:16:21,150
>> ให้ของได้รับโลภน้อย

1549
01:16:21,150 --> 01:16:23,990
สมมติว่าเหมือนแสดงให้ฉัน 55
ชี้หลังจุดทศนิยม

1550
01:16:23,990 --> 01:16:26,160
ลองใช้เวลานี้จริงๆ
โปรแกรมออกสำหรับสปิน

1551
01:16:26,160 --> 01:16:31,170
ผมขอรีเมคมันด้วยการแต่งหน้า
ไม่แน่ชัดจุดเฉือนไม่แน่ชัด

1552
01:16:31,170 --> 01:16:32,390
>> และที่นี่เราไป

1553
01:16:32,390 --> 01:16:34,420
วัยเด็กของคุณเป็นเรื่องโกหก

1554
01:16:34,420 --> 01:16:48,410
เห็นได้ชัดว่า 1 หารด้วย 10 เป็นที่แน่นอน
0.100000000000000005551115123--

1555
01:16:48,410 --> 01:16:49,740
>> เกิดอะไรขึ้น?

1556
01:16:49,740 --> 01:16:53,360
ดีก็จะเปิดออกถ้าคุณชนิดของ
มองไกลพอออกมาในพื้นฐาน

1557
01:16:53,360 --> 01:16:55,950
เป็นตัวแทนของนี้
จำนวนก็จริง

1558
01:16:55,950 --> 01:17:00,400
ไม่ว่า 1/10 หรือ 0.1 และ
จำนวนอนันต์ของศูนย์

1559
01:17:00,400 --> 01:17:01,630
ตอนนี้ทำไมเป็นเช่นนั้น?

1560
01:17:01,630 --> 01:17:06,250
>> ดีแม้ว่านี้เป็นที่เรียบง่าย
จำนวนมนุษย์เรา 1 หารด้วย 10

1561
01:17:06,250 --> 01:17:10,910
ก็ยังคงเป็นหนึ่งในหลาย ๆ เพียบ
ตัวเลขที่เราจะได้คิดขึ้น

1562
01:17:10,910 --> 01:17:14,490
แต่คอมพิวเตอร์เท่านั้นที่สามารถเป็นตัวแทนของ
ขีดดังนั้นหลายหมายเลข

1563
01:17:14,490 --> 01:17:18,710
และเพื่อให้มีประสิทธิภาพว่า
คอมพิวเตอร์แสดงให้เราเป็นที่ใกล้เคียงที่สุด

1564
01:17:18,710 --> 01:17:22,940
ประมาณไปยังหมายเลขที่
เราต้องการที่จะเชื่อว่าเป็น 1/10

1565
01:17:22,940 --> 01:17:27,760
หรือจริงๆไม่มีที่สิ้นสุด 0.10000

1566
01:17:27,760 --> 01:17:30,425
>> แต่แม้ว่านี้เป็น
ใกล้ที่สุดเท่าที่จะได้รับ

1567
01:17:30,425 --> 01:17:32,300
และแน่นอนถ้าคุณดู
ใต้ฝากระโปรง

1568
01:17:32,300 --> 01:17:37,050
ในขณะที่เราอยู่ที่นี่โดยการมอง
55 หลักหลังทศนิยม

1569
01:17:37,050 --> 01:17:39,990
เราจริงเห็นความจริงว่า

1570
01:17:39,990 --> 01:17:42,610
ตอนนี้เช่นกันถ้าคุณได้
เคยเห็น movie--

1571
01:17:42,610 --> 01:17:45,780
ส่วนใหญ่ของคุณอาจจะ haven't--
แต่ซูเปอร์แมน 3 บางปีที่ผ่านมา

1572
01:17:45,780 --> 01:17:49,500
ริชาร์ดไพรเออร์หลัก leveraged นี้
ความเป็นจริงใน บริษัท ของเขาจะขโมยมาก

1573
01:17:49,500 --> 01:17:53,500
เศษส่วนและเศษส่วนของเพนนี,
เพราะ company-- เท่าที่ผมจำได้

1574
01:17:53,500 --> 01:17:57,210
จะได้รับ while-- เป็นหลัก
ทิ้งสิ่งที่ไม่เหมาะสม

1575
01:17:57,210 --> 01:17:58,790
เข้ามาในความคิดของเซ็นต์

1576
01:17:58,790 --> 01:18:01,480
>> แต่ถ้าคุณเพิ่มขึ้นทั้งหมดเหล่านี้
เล็ก ๆ เล็ก ๆ จำนวนเล็ก ๆ อีกครั้ง

1577
01:18:01,480 --> 01:18:04,960
และอีกครั้งและอีกครั้งที่คุณสามารถเป็นใน
กรณีของเขาทำให้จำนวนเงินที่ดี

1578
01:18:04,960 --> 01:18:08,010
>> ที่ความคิดเดียวกันก็ถูกฉีกออกโดย
ขึ้นเมื่อเร็ว ๆ นี้ แต่ยังคงตอนที่มีอายุมากกว่า

1579
01:18:08,010 --> 01:18:10,500
ภาพยนตร์ที่เรียกว่าพื้นที่สำนักงาน
ที่คนในหนังเรื่องนั้น

1580
01:18:10,500 --> 01:18:13,501
ทำสิ่งเดียวกันเมาขึ้น
สมบูรณ์จบลงด้วยวิธีที่มากเกินไป

1581
01:18:13,501 --> 01:18:14,666
เงินในบัญชีธนาคารของพวกเขา

1582
01:18:14,666 --> 01:18:15,800
มันเป็นที่น่าสงสัยมาก

1583
01:18:15,800 --> 01:18:19,290
แต่ในตอนท้ายของวัน
ไม่แน่ชัดเป็นสิ่งที่อยู่รอบตัวเรา

1584
01:18:19,290 --> 01:18:22,240
>> และที่มากเกินไปสามารถ
ใจหายกรณี

1585
01:18:22,240 --> 01:18:25,590
แต่กลับกลายเป็นว่าซูเปอร์แมน 3
และพื้นที่สำนักงานกันมี

1586
01:18:25,590 --> 01:18:28,460
สามารถเป็นจริงบางอย่างมาก
มีเครือข่ายทั่วโลก

1587
01:18:28,460 --> 01:18:32,290
ของความเป็นจริงของแน่ชัด
เป็นตัวแทนของข้อมูล

1588
01:18:32,290 --> 01:18:34,770
ว่าแม้เรามนุษย์
ในวันนี้ไม่จำเป็นต้อง

1589
01:18:34,770 --> 01:18:38,230
เข้าใจเช่นเดียวกับที่เราควร
หรือจำได้บ่อยเท่าที่เราควร

1590
01:18:38,230 --> 01:18:42,950
และจริงคลิปต่อไปนี้
จากการมองโลกจริงมากบาง

1591
01:18:42,950 --> 01:18:47,730
เครือข่ายของสิ่งที่เกิดขึ้นถ้าคุณ
ไม่ได้ชื่นชมไม่แน่ชัดว่า

1592
01:18:47,730 --> 01:18:50,065
สามารถเกิดขึ้นได้ในการเป็นตัวแทนตัวเลข

1593
01:18:50,065 --> 01:18:51,300
>> [เล่นวีดีโอ]

1594
01:18:51,300 --> 01:18:55,620
>> -Computers เราได้มาทั้งหมดจะยอมรับ
ปัญหาที่มักจะทำลาย

1595
01:18:55,620 --> 01:19:00,310
ไปกับข้อบกพร่อง them-- ไวรัส
และบกพร่องซอฟต์แวร์

1596
01:19:00,310 --> 01:19:03,130
สำหรับราคาขนาดเล็กจ่าย
เพื่อความสะดวก

1597
01:19:03,130 --> 01:19:07,800
แต่ในเทคโนโลยีชั้นสูงและความเร็วสูง
ทหารและโครงการอวกาศของการใช้งาน

1598
01:19:07,800 --> 01:19:12,800
ปัญหาที่เกิดขึ้นมีขนาดเล็กที่สุดสามารถ
จะขยายเข้าไปในภัยพิบัติ

1599
01:19:12,800 --> 01:19:18,900
>> เมื่อวันที่ 4 มิถุนายน 1996 นักวิทยาศาสตร์เตรียม
ที่จะเปิดตัวกำลังใจ Ariane 5 จรวด

1600
01:19:18,900 --> 01:19:21,220
มันได้รับการดำเนินการทางวิทยาศาสตร์
ดาวเทียมได้รับการออกแบบ

1601
01:19:21,220 --> 01:19:24,600
ที่จะสร้างได้อย่างแม่นยำว่า
ปฏิสัมพันธ์ของโลกสนามแม่เหล็ก

1602
01:19:24,600 --> 01:19:27,410
กับลมพลังงานแสงอาทิตย์

1603
01:19:27,410 --> 01:19:30,800
จรวดถูกสร้างขึ้นสำหรับ
องค์การอวกาศยุโรป

1604
01:19:30,800 --> 01:19:34,370
และยกออกจากโรงงาน
บนชายฝั่งของฝรั่งเศสกิอานา

1605
01:19:34,370 --> 01:19:37,540
>> -At ประมาณ 37 วินาทีใน
เที่ยวบินที่พวกเขาเป็นครั้งแรก

1606
01:19:37,540 --> 01:19:39,270
สิ่งที่สังเกตเห็นก็จะไม่ถูกต้อง

1607
01:19:39,270 --> 01:19:42,250
หัวถูกหมุนใน
วิธีการที่พวกเขาไม่ควร

1608
01:19:42,250 --> 01:19:46,580
ประมาณ 40 วินาทีในการบิน
เห็นได้ชัดว่ารถอยู่ในฐานะลำบาก

1609
01:19:46,580 --> 01:19:48,850
>> และที่ว่าเมื่อพวกเขาทำ
การตัดสินใจที่จะทำลายมัน

1610
01:19:48,850 --> 01:19:52,780
เจ้าหน้าที่ความปลอดภัยในช่วงที่มี
ความกล้าอย่างมากกดปุ่ม

1611
01:19:52,780 --> 01:19:58,150
พัดขึ้นจรวดก่อนที่มันจะ
กลายเป็นอันตรายต่อความปลอดภัยของประชาชน

1612
01:19:58,150 --> 01:20:01,060
>> -This เป็นหญิงสาว
การเดินทางของ Ariane 5

1613
01:20:01,060 --> 01:20:03,960
และการทำลายล้างของมันเอา
วางเพราะข้อบกพร่อง

1614
01:20:03,960 --> 01:20:05,822
ที่ฝังอยู่ในซอฟท์แวจรวด

1615
01:20:05,822 --> 01:20:08,280
-The ปัญหาในอาริอานคือ
ว่ามีตัวเลขที่

1616
01:20:08,280 --> 01:20:10,600
จำเป็นต้องใช้ 64 บิตในการแสดง

1617
01:20:10,600 --> 01:20:13,590
และพวกเขาต้องการที่จะแปลง
มันเป็นจำนวน 16 บิต

1618
01:20:13,590 --> 01:20:15,610
พวกเขาสันนิษฐานได้ว่า
จำนวนก็ไม่เคยไป

1619
01:20:15,610 --> 01:20:20,980
จะต้องมีขนาดใหญ่มากว่าส่วนใหญ่ของผู้ที่
ตัวเลขในจำนวน 64 บิตเป็นศูนย์

1620
01:20:20,980 --> 01:20:22,440
พวกเขาผิด

1621
01:20:22,440 --> 01:20:25,060
>> -The ไร้ความสามารถของหนึ่ง
โปรแกรมซอฟแวร์ที่จะยอมรับ

1622
01:20:25,060 --> 01:20:29,510
ชนิดของหมายเลขที่สร้างขึ้นโดย
อีกคนหนึ่งคือที่รากของความล้มเหลว

1623
01:20:29,510 --> 01:20:34,350
การพัฒนาซอฟต์แวร์ได้กลายเป็น
ส่วนค่าใช้จ่ายสูงมากของเทคโนโลยีใหม่

1624
01:20:34,350 --> 01:20:38,140
จรวดอาริอานได้รับมาก
ที่ประสบความสำเร็จมากของซอฟต์แวร์

1625
01:20:38,140 --> 01:20:41,550
ที่สร้างขึ้นสำหรับมันก็ยัง
ใช้ใน Ariane 5

1626
01:20:41,550 --> 01:20:47,940
>> -The ปัญหาพื้นฐานคือการที่อาริอาน
5 เร็วเร่งได้เร็วขึ้น

1627
01:20:47,940 --> 01:20:51,450
และซอฟต์แวร์ที่ไม่ได้
คิดว่า

1628
01:20:51,450 --> 01:20:55,060
>> -The ทำลายจรวด
เป็นภัยพิบัติทางการเงินขนาดใหญ่

1629
01:20:55,060 --> 01:20:58,790
อันเนื่องมาจากความผิดพลาดของซอฟต์แวร์นาที

1630
01:20:58,790 --> 01:21:01,210
แต่ตอนนี้ไม่ได้เป็นครั้งแรก
ปัญหาเวลาแปลงข้อมูล

1631
01:21:01,210 --> 01:21:04,820
ได้ plagued เทคโนโลยีจรวดที่ทันสมัย

1632
01:21:04,820 --> 01:21:08,050
>> -in ปี 1991 ด้วยการเริ่มต้น
ของสงครามอ่าวครั้งแรก,

1633
01:21:08,050 --> 01:21:10,570
รักชาติขีปนาวุธ
ประสบการณ์ชนิดที่คล้ายกัน

1634
01:21:10,570 --> 01:21:12,800
ของปัญหาการแปลงจำนวน

1635
01:21:12,800 --> 01:21:16,090
และเป็นผลให้ 28 คน
28 ทหารอเมริกัน

1636
01:21:16,090 --> 01:21:19,080
ถูกฆ่าตายและประมาณ
100 คนอื่น ๆ ได้รับบาดเจ็บ

1637
01:21:19,080 --> 01:21:22,780
เมื่อรักชาติซึ่งควร
เพื่อป้องกัน scuds เข้ามา

1638
01:21:22,780 --> 01:21:25,830
ล้มเหลวในการยิงขีปนาวุธ

1639
01:21:25,830 --> 01:21:31,670
>> เมื่อมีอิรักบุกคูเวตและอเมริกา
เปิดตัวพายุทะเลทรายในช่วงต้นปี 1991

1640
01:21:31,670 --> 01:21:35,780
แบตเตอรี่รักชาติขีปนาวุธถูกนำไปใช้
เพื่อปกป้องซาอุดีอาระเบียและอิสราเอล

1641
01:21:35,780 --> 01:21:39,230
จากอิรักสกั๊ดขีปนาวุธโจมตี

1642
01:21:39,230 --> 01:21:43,810
ต่อต้านการก่อการร้ายเป็นสหรัฐช่วงกลาง
พื้นผิวที่อากาศระบบการผลิต

1643
01:21:43,810 --> 01:21:45,770
โดย บริษัท Raytheon

1644
01:21:45,770 --> 01:21:52,340
>> -The ขนาดของ Interceptor ต่อต้านการก่อการร้าย
ตัวเองเป็นเรื่องเกี่ยวกับประมาณ 20 ฟุตยาว

1645
01:21:52,340 --> 01:21:55,230
และน้ำหนักประมาณ 2,000 ปอนด์

1646
01:21:55,230 --> 01:21:59,320
และจะดำเนินการรบประมาณ,
ฉันคิดว่ามันประมาณ 150 ปอนด์

1647
01:21:59,320 --> 01:22:03,930
และหัวรบที่ตัวเองเป็น
ระเบิดสูงซึ่ง

1648
01:22:03,930 --> 01:22:07,330
มีชิ้นส่วนที่อยู่รอบ ๆ

1649
01:22:07,330 --> 01:22:11,680
ปลอกของจรวดคือ
ออกแบบมาเพื่อทำหน้าที่เหมือน Buckshot

1650
01:22:11,680 --> 01:22:14,110
>> -The ขีปนาวุธจะดำเนินการ
ต่อภาชนะสี่

1651
01:22:14,110 --> 01:22:17,130
และมีการขนส่งโดยรถพ่วงเทลเลอร์

1652
01:22:17,130 --> 01:22:24,930
>> -The Patriot ระบบป้องกันขีปนาวุธ
กลับไปอย่างน้อย 20 ปีในขณะนี้

1653
01:22:24,930 --> 01:22:28,420
มันถูกออกแบบมา
เป็นป้องกันขีปนาวุธอากาศ

1654
01:22:28,420 --> 01:22:30,720
จะยิงลงเครื่องบินศัตรู

1655
01:22:30,720 --> 01:22:34,500
ในสงครามอ่าวครั้งแรก,
เมื่อสงครามที่มาพร้อม

1656
01:22:34,500 --> 01:22:39,745
กองทัพอยากจะใช้มันเพื่อ
ยิงลง scuds ไม่เครื่องบิน

1657
01:22:39,745 --> 01:22:43,620
>> อิรักกองทัพอากาศ
ไม่มากของปัญหา

1658
01:22:43,620 --> 01:22:46,670
แต่กองทัพเป็นห่วงเกี่ยวกับ scuds

1659
01:22:46,670 --> 01:22:50,170
ดังนั้นพวกเขาจึงพยายามที่จะ
อัพเกรดต่อต้านการก่อการร้าย

1660
01:22:50,170 --> 01:22:52,800
>> -Intercepting ศัตรู
วิถีการเดินทางที่ Mach 5

1661
01:22:52,800 --> 01:22:55,830
กำลังจะถูกท้าทายพอ

1662
01:22:55,830 --> 01:22:58,490
แต่เมื่อรักชาติ
ก็รีบวิ่งเข้าไปในบริการ

1663
01:22:58,490 --> 01:23:02,860
กองทัพไม่ได้ตระหนักถึงของ
การปรับเปลี่ยนที่ทำให้อิรัก

1664
01:23:02,860 --> 01:23:05,930
scuds ของพวกเขาไปไม่ได้เกือบจะตี

1665
01:23:05,930 --> 01:23:10,740
>> อะไรเกิดขึ้นก็คือ scuds ที่
ที่กำลังจะมาในก็ไม่เสถียร

1666
01:23:10,740 --> 01:23:11,692
พวกเขาถูกโยกเยก

1667
01:23:11,692 --> 01:23:14,910
เหตุผลของเรื่องนี้ก็คือ
ชาวอิรักในการสั่งซื้อ

1668
01:23:14,910 --> 01:23:18,280
ที่จะได้รับ 600 กิโลเมตร
ออกจาก 300 กิโลเมตร

1669
01:23:18,280 --> 01:23:21,700
ขีปนาวุธพิสัยเอาน้ำหนัก
ออกจากจรวดด้านหน้า

1670
01:23:21,700 --> 01:23:23,390
พวกเขาทำให้จรวดเบา

1671
01:23:23,390 --> 01:23:27,330
>> ดังนั้นตอนนี้รักชาติ
พยายามที่จะมาที่สกั๊ด

1672
01:23:27,330 --> 01:23:30,230
และส่วนใหญ่เวลาที่
ส่วนใหญ่ที่ครอบงำของเวลา

1673
01:23:30,230 --> 01:23:32,940
มันก็จะบินจากสกั๊ด

1674
01:23:32,940 --> 01:23:37,260
เมื่อผู้ประกอบการระบบต่อต้านการก่อการร้าย
ตระหนักถึงความรักชาติพลาดเป้าหมายของตน

1675
01:23:37,260 --> 01:23:41,690
พวกเขาระเบิดจรวดต่อต้านการก่อการร้ายของ
เพื่อหลีกเลี่ยงการบาดเจ็บล้มตายไปได้ถ้ามัน

1676
01:23:41,690 --> 01:23:44,570
ได้รับอนุญาตให้ตกอยู่กับพื้นดิน

1677
01:23:44,570 --> 01:23:48,790
>> ใช่หรือไม่เพราะเป็นสิ่งที่คนส่วนใหญ่เห็น
ผู้บั้งไฟขนาดใหญ่ในท้องฟ้า

1678
01:23:48,790 --> 01:23:54,550
และเข้าใจผิดว่าเป็น
ดักขีปนาวุธสกั๊ดของ

1679
01:23:54,550 --> 01:23:56,630
>> -Although ในเวลากลางคืน
ท้องฟ้าปรากฏรักชาติ

1680
01:23:56,630 --> 01:24:00,370
ที่จะประสบความสำเร็จ
ทำลาย Scuds ที่ Dhahran,

1681
01:24:00,370 --> 01:24:03,360
อาจจะมีผิดพลาดไม่
เกี่ยวกับผลการปฏิบัติงาน

1682
01:24:03,360 --> 01:24:07,970
มีระบบเรดาร์ต่อต้านการก่อการร้ายของ
สูญหายติดตามของสกั๊ดที่เข้ามา

1683
01:24:07,970 --> 01:24:10,721
และไม่เคยเปิดตัวเนื่องจาก
ข้อบกพร่องซอฟต์แวร์

1684
01:24:10,721 --> 01:24:14,090

1685
01:24:14,090 --> 01:24:18,940
มันเป็นอิสราเอลที่ค้นพบครั้งแรก
ว่าอีกต่อไปเป็นระบบบน

1686
01:24:18,940 --> 01:24:22,690
ยิ่งเวลาที่แตกต่าง
กลายเนื่องจากนาฬิกาฝังตัว

1687
01:24:22,690 --> 01:24:24,810
ในเครื่องคอมพิวเตอร์ของระบบ

1688
01:24:24,810 --> 01:24:28,210
>> -About สองสัปดาห์ก่อน
โศกนาฏกรรมใน Dhahran,

1689
01:24:28,210 --> 01:24:30,770
อิสราเอลรายงานไปยัง
กระทรวงกลาโหม

1690
01:24:30,770 --> 01:24:32,590
ว่าระบบที่ได้รับการสูญเสียเวลา

1691
01:24:32,590 --> 01:24:35,360
หลังจากนั้นประมาณแปดชั่วโมงหรือทำงาน
พวกเขาสังเกตเห็นว่าระบบ

1692
01:24:35,360 --> 01:24:37,720
ได้กลายเป็นที่เห็นได้ชัดแม่นยำน้อยลง

1693
01:24:37,720 --> 01:24:41,900
กระทรวงกลาโหมตอบสนองโดยการ
บอกทั้งหมดของแบตเตอรี่ต่อต้านการก่อการร้าย

1694
01:24:41,900 --> 01:24:44,950
จะไม่ปล่อยให้ระบบ
มาเป็นเวลานาน

1695
01:24:44,950 --> 01:24:49,160
พวกเขาไม่เคยกล่าวว่าสิ่งที่เป็นเวลานาน was--
แปดชั่วโมง 10 ชั่วโมง 1,000 ชั่วโมง

1696
01:24:49,160 --> 01:24:51,360
ไม่มีใครรู้ว่า

1697
01:24:51,360 --> 01:24:53,380
>> -The แบตเตอรี่ต่อต้านการก่อการร้าย
ประจำการอยู่ที่ค่ายทหาร

1698
01:24:53,380 --> 01:24:58,350
ที่ Dhahran และข้อบกพร่องภายใน
นาฬิกาที่ได้รับมากกว่า 100 ชั่วโมง

1699
01:24:58,350 --> 01:25:01,670
เมื่อคืนวันที่ 25 กุมภาพันธ์

1700
01:25:01,670 --> 01:25:05,917
>> -IT เวลาที่จะติดตามความถูกต้อง
ประมาณสิบวินาที

1701
01:25:05,917 --> 01:25:08,000
ตอนนี้หนึ่งในสิบของวินาที
เป็นตัวเลขที่น่าสนใจ

1702
01:25:08,000 --> 01:25:11,920
เพราะมันไม่สามารถจะแสดงออก
ในไบนารีตรงที่

1703
01:25:11,920 --> 01:25:16,820
หมายความว่ามันไม่สามารถแสดงได้ว่า
ในเครื่องคอมพิวเตอร์ดิจิตอลใด ๆ ที่ทันสมัย

1704
01:25:16,820 --> 01:25:18,540
มันยากที่จะเชื่อ.

1705
01:25:18,540 --> 01:25:21,210
>> แต่ใช้สิ่งนี้เป็นตัวอย่าง

1706
01:25:21,210 --> 01:25:23,540
ลองมาจำนวนหนึ่งในสาม

1707
01:25:23,540 --> 01:25:27,350
หนึ่งในสามไม่สามารถ
แสดงในทศนิยมตรง

1708
01:25:27,350 --> 01:25:32,080
หนึ่งในสามเป็น 0.333
ไปในอินฟินิตี้

1709
01:25:32,080 --> 01:25:36,480
>> ไม่มีทางที่จะทำด้วยความไม่เป็น
ความถูกต้องสมบูรณ์ในทศนิยม

1710
01:25:36,480 --> 01:25:39,560
นั่นคือสิ่งที่ชนิดของปัญหาที่เกิดขึ้น
ที่เกิดขึ้นในผู้รักชาติ

1711
01:25:39,560 --> 01:25:44,100
อีกต่อไประบบวิ่งที่
ที่เลวร้ายยิ่งผิดพลาดเวลากลาย

1712
01:25:44,100 --> 01:25:48,890
>> หลังการ 100 ชั่วโมงของการดำเนินงาน
ข้อผิดพลาดในเวลาที่เป็นเพียงประมาณหนึ่งในสาม

1713
01:25:48,890 --> 01:25:50,600
วินาที

1714
01:25:50,600 --> 01:25:54,210
แต่ในแง่ของการกำหนดเป้​​าหมาย
วิถีการเดินทางที่ Mach 5

1715
01:25:54,210 --> 01:25:58,710
มันมีผลในการติดตาม
ข้อผิดพลาดกว่า 600 เมตร

1716
01:25:58,710 --> 01:26:02,120
มันจะเป็นความผิดพลาดร้ายแรง
สำหรับทหารในสิ่งที่เป็น

1717
01:26:02,120 --> 01:26:08,940
เกิดขึ้นก็คือการเปิดตัวสกั๊ดเป็น
ตรวจพบโดยดาวเทียมเตือนภัยล่วงหน้า

1718
01:26:08,940 --> 01:26:12,860
และพวกเขารู้ว่าสกั๊ดเป็น
มาในทิศทางทั่วไปของพวกเขา

1719
01:26:12,860 --> 01:26:15,320
พวกเขาไม่รู้ว่ามันอยู่ที่ไหนมา

1720
01:26:15,320 --> 01:26:18,250
>> -IT ตอนนี้ถึงเรดาร์
ส่วนประกอบของระบบต่อต้านการก่อการร้าย

1721
01:26:18,250 --> 01:26:23,190
ปกป้อง Dhahran เพื่อค้นหาและเก็บ
ติดตามขีปนาวุธของศัตรูที่เข้ามา

1722
01:26:23,190 --> 01:26:24,609
>> -The เรดาร์เป็นสมาร์ทมาก

1723
01:26:24,609 --> 01:26:26,650
มันจริงจะติดตาม
ตำแหน่งของสกั๊ดที่

1724
01:26:26,650 --> 01:26:30,350
และจากนั้นคาดการณ์ที่มันอาจจะ
จะเป็นครั้งต่อไปเรดาร์ส่ง

1725
01:26:30,350 --> 01:26:31,420
ชีพจรออก

1726
01:26:31,420 --> 01:26:33,110
ที่ถูกเรียกว่าประตูช่วง

1727
01:26:33,110 --> 01:26:37,660
>> -Then เมื่อรักชาติ
ตัดสินใจที่มีเวลามากพอ

1728
01:26:37,660 --> 01:26:42,450
ผ่านที่จะกลับไปและตรวจสอบต่อไป
สถานที่สำหรับวัตถุที่ตรวจพบนี้

1729
01:26:42,450 --> 01:26:43,600
มันจะไปกลับ

1730
01:26:43,600 --> 01:26:48,650
ดังนั้นเมื่อมันเดินกลับไปทางที่ผิด
สถานที่มันก็เห็นไม่มีวัตถุ

1731
01:26:48,650 --> 01:26:52,160
และตัดสินใจว่าไม่มี
วัตถุก็คือการตรวจจับเท็จ

1732
01:26:52,160 --> 01:26:53,930
และลดลงติดตาม

1733
01:26:53,930 --> 01:26:57,030
>> -The สกั๊ดที่เข้ามาหายไป
จากหน้าจอเรดาร์

1734
01:26:57,030 --> 01:27:00,260
และวินาทีต่อมามัน
กระแทกเข้าค่ายทหาร

1735
01:27:00,260 --> 01:27:06,150
สกั๊ดถูกฆ่าตาย 28 และเป็นคนสุดท้าย
หนึ่งยิงในช่วงสงครามอ่าวครั้งแรก

1736
01:27:06,150 --> 01:27:11,960
>> น่าเศร้าที่การปรับปรุงซอฟต์แวร์
มาถึงที่ Dhahran ในวันรุ่งขึ้น

1737
01:27:11,960 --> 01:27:14,930
ข้อบกพร่องที่มีซอฟแวร์
รับการแก้ไขปิด

1738
01:27:14,930 --> 01:27:19,806
บทหนึ่งในทุกข์
ประวัติศาสตร์ของขีปนาวุธต่อต้านการก่อการร้าย

1739
01:27:19,806 --> 01:27:20,729
>> [เล่นวีดีโอ]

1740
01:27:20,729 --> 01:27:23,520
เดวิดเจลัน: ดังนั้นนี่คือทุกคนที่จะ
บอกว่าปัญหาเหล​​่านี้ของล้น

1741
01:27:23,520 --> 01:27:25,860
และไม่แน่ชัดเป็นจริงทั้งหมดเกินไป

1742
01:27:25,860 --> 01:27:26,920
ดังนั้นวิธีการที่เราได้รับที่นี่?

1743
01:27:26,920 --> 01:27:28,895
เราเริ่มต้นด้วยเพียงการพูดคุยเกี่ยวกับ printf

1744
01:27:28,895 --> 01:27:31,270
อีกครั้งที่ฟังก์ชั่นนี้
สิ่งที่จะพิมพ์หน้าจอ

1745
01:27:31,270 --> 01:27:33,450
และเราแนะนำหลังจากนั้น
ฟังก์ชั่นอื่น ๆ ไม่กี่

1746
01:27:33,450 --> 01:27:34,945
จากสิ่งที่เรียกว่าห้องสมุดของ CS50

1747
01:27:34,945 --> 01:27:36,910
และเราจะดำเนินการต่อไป
เห็นเหล่านี้ในเวลาที่กำหนด

1748
01:27:36,910 --> 01:27:40,760
และเราโดยเฉพาะอย่างยิ่งใช้สตริงได้รับ
และได้รับ int และตอนนี้ยังได้รับการลอย

1749
01:27:40,760 --> 01:27:44,410
และยังคนอื่น ๆ เรายังจะได้พบกับ
และใช้ตัวเองก่อนที่จะยาว

1750
01:27:44,410 --> 01:27:47,220
>> แต่ในบางโอกาสมี
เราเห็นแล้วต้อง

1751
01:27:47,220 --> 01:27:50,520
ในการจัดเก็บสิ่งที่มือของฟังก์ชั่นเหล่านั้นกลับมา?

1752
01:27:50,520 --> 01:27:52,920
มือพวกเขาเรากลับสตริง
หรือ int หรือลอย

1753
01:27:52,920 --> 01:27:56,070
และบางครั้งเราจำเป็นต้องใส่ว่า
สตริงหรือ int หรือลอยอยู่ที่ไหนสักแห่ง

1754
01:27:56,070 --> 01:28:00,100
>> และการจัดเก็บสิ่งเหล่านั้นจำได้เพียงแค่
เช่นเดียวกับใน Scratch เรามีตัวแปร

1755
01:28:00,100 --> 01:28:03,260
แต่แตกต่างจากในเกา
ใน C เรามีประเภทที่เกิดขึ้นจริง

1756
01:28:03,260 --> 01:28:05,530
ข้อมูล variables--
ประเภท generally-- เพิ่มเติม

1757
01:28:05,530 --> 01:28:08,640
ในหมู่พวกเขาสตริงเป็น int เป็น
ลอยและอื่น ๆ เหล่านี้ยังคง

1758
01:28:08,640 --> 01:28:12,321
>> และดังนั้นเมื่อเราประกาศตัวแปรใน C,
เราจะมีการประกาศประเภทข้อมูลของเรา

1759
01:28:12,321 --> 01:28:14,820
นี่ไม่ใช่สิ่งที่เราจะ
ต้องทำต่อไปในภาคการศึกษา

1760
01:28:14,820 --> 01:28:16,810
ในขณะที่เราเปลี่ยนไปใช้ภาษาอื่น ๆ

1761
01:28:16,810 --> 01:28:19,610
แต่ตอนนี้เราจะต้อง
การนิรนัยล่วงหน้า

1762
01:28:19,610 --> 01:28:24,370
อธิบายให้คอมพิวเตอร์สิ่งที่ประเภท
ของตัวแปรที่เราต้องการที่จะให้เรา

1763
01:28:24,370 --> 01:28:27,290
>> ตอนนี้ในขณะเดียวกันในการพิมพ์
ผู้ที่ชนิดของชนิดข้อมูล

1764
01:28:27,290 --> 01:28:29,570
เราจะต้องบอก printf สิ่งที่คาดหวัง

1765
01:28:29,570 --> 01:28:32,450
และเราเห็น s ร้อยละสตริง
และร้อยละ I สำหรับจำนวนเต็ม

1766
01:28:32,450 --> 01:28:33,790
และอีกสองสามคนแล้ว

1767
01:28:33,790 --> 01:28:37,237
และผู้ที่มีเพียงความต้องการ
สำหรับการนำเสนอภาพ

1768
01:28:37,237 --> 01:28:38,070
ของข้อมูลที่

1769
01:28:38,070 --> 01:28:42,080
>> และแต่ละเหล่านี้สามารถจริงจะ
parametrized หรือเอ็นดูในบางวิธี

1770
01:28:42,080 --> 01:28:45,370
ถ้าคุณต้องการที่จะส่งเสริมการควบคุม
ประเภทของการส่งออกที่คุณได้รับ

1771
01:28:45,370 --> 01:28:49,604
และในความเป็นจริงก็ปรากฎว่าไม่เพียง แต่
จะมีทับขวา n สำหรับบรรทัดใหม่

1772
01:28:49,604 --> 01:28:52,520
มีอย่างอื่นที่เรียกว่าทับขวาเป็น
R สำหรับกลับรถซึ่ง

1773
01:28:52,520 --> 01:28:54,360
เป็นมากขึ้นคล้ายกับผู้
เครื่องพิมพ์ดีดโรงเรียนเก่า

1774
01:28:54,360 --> 01:28:57,690
และยังใช้ Windows ใช้เวลาหลายปี

1775
01:28:57,690 --> 01:28:59,690
>> มีเสื้อทับขวาสำหรับแท็บ

1776
01:28:59,690 --> 01:29:03,170
ปรากฎว่าถ้าคุณต้องการที่จะ
ราคาคู่ภายในของสตริง

1777
01:29:03,170 --> 01:29:05,000
จำได้ว่าเราได้ใช้
คู่ราคาคู่

1778
01:29:05,000 --> 01:29:07,900
อ้างด้านซ้ายและด้านขวา
ปลายสายของเราป่านนี้

1779
01:29:07,900 --> 01:29:09,420
ที่ดูเหมือนจะสร้างความสับสนให้สิ่ง

1780
01:29:09,420 --> 01:29:12,503
>> หากคุณต้องการที่จะนำคำพูดคู่ใน
ตรงกลางของ string-- และแน่นอนที่

1781
01:29:12,503 --> 01:29:13,670
มันจะทำให้เกิดความสับสนที่จะเห็น

1782
01:29:13,670 --> 01:29:17,120
และเพื่อให้คุณจะต้องหลบหนีเพื่อที่จะ
พูดอ้างคู่กับบางสิ่งบางอย่าง

1783
01:29:17,120 --> 01:29:18,860
เช่นตัวอักษรราคาคู่ทับขวา

1784
01:29:18,860 --> 01:29:20,230
และมีไม่กี่อื่น ๆ ยังคง

1785
01:29:20,230 --> 01:29:24,540
และเราจะเห็นมากขึ้นของคนเหล่านั้น
ในการใช้งานจริงก่อนที่จะยาว

1786
01:29:24,540 --> 01:29:27,930
>> ดังนั้นตอนนี้ขอเปลี่ยนจาก
ข้อมูลและการแสดง

1787
01:29:27,930 --> 01:29:30,820
และผู้ประกอบการทางคณิตศาสตร์ทั้งหมด
ซึ่งทำให้เรามีอาคารบางส่วน

1788
01:29:30,820 --> 01:29:32,070
บล็อกด้วยซึ่งในการเล่น

1789
01:29:32,070 --> 01:29:34,481
แต่ตอนนี้ขอให้จริง
เราส่วนที่เหลือของคำศัพท์

1790
01:29:34,481 --> 01:29:36,230
ที่เรามีอยู่แล้ว
สัปดาห์ที่ผ่านมาที่มีรอยขีดข่วน

1791
01:29:36,230 --> 01:29:39,350
โดยการดูที่บางส่วนอื่น ๆ
สร้างใน C-- ไม่ทั้งหมดของพวกเขา

1792
01:29:39,350 --> 01:29:41,680
แต่ความคิดเรา
เกี่ยวกับการดูจริงๆเพียงแค่

1793
01:29:41,680 --> 01:29:45,610
จะเน้นการแปลจาก
หนึ่งภาษาเกาไปยังอีกซี

1794
01:29:45,610 --> 01:29:48,470
>> และช่วงเวลาที่เราจะรับ
เครื่องมือเพิ่มเติมสำหรับชุดเครื่องมือของเรา

1795
01:29:48,470 --> 01:29:49,820
เพื่อที่จะพูดไวยากรณ์

1796
01:29:49,820 --> 01:29:54,190
และแน่นอนคุณจะเห็นว่าความคิด
ตอนนี้ค่อนข้างคุ้นเคยจากสัปดาห์ที่ผ่านมา

1797
01:29:54,190 --> 01:29:55,200
ดังนั้นขอให้ทำเช่นนี้

1798
01:29:55,200 --> 01:29:58,870
>> Let 's ไปข้างหน้าและชักขึ้นโปรแกรม
ที่จริงใช้การแสดงออกบางอย่าง

1799
01:29:58,870 --> 01:30:00,720
นิพจน์บูลีน

1800
01:30:00,720 --> 01:30:02,810
ผมขอไปข้างหน้านี่
และสร้างไฟล์ใหม่

1801
01:30:02,810 --> 01:30:06,090
ฉันจะเรียก condition.c นี้

1802
01:30:06,090 --> 01:30:09,350
>> ให้ฉันไปข้างหน้าและ
รวมถึงห้องสมุด CS50

1803
01:30:09,350 --> 01:30:12,640
และแจ้งให้เราไปข้างหน้าและรวมถึง
มาตรฐาน IO.h สำหรับการทำงานของเรา

1804
01:30:12,640 --> 01:30:14,690
และ printf และอื่น ๆ ตามลำดับ

1805
01:30:14,690 --> 01:30:18,900
ผมขอให้ตัวเองสำเร็จรูปที่
เป็นโมฆะหลัก int ซึ่งมีคำอธิบายที่เราจะ

1806
01:30:18,900 --> 01:30:20,360
กลับมาในอนาคต

1807
01:30:20,360 --> 01:30:23,820
>> ตอนนี้ให้ฉันไปข้างหน้าและให้
ตัวเองเป็น int ผ่านได้รับ int

1808
01:30:23,820 --> 01:30:25,970
ก็ขอให้ข้าไปข้างหน้าและทำเช่นนี้

1809
01:30:25,970 --> 01:30:30,150
ผมอยากจะบอกว่าถ้าผมเป็น less-- ขอ
ความแตกต่างระหว่างบวกลบ

1810
01:30:30,150 --> 01:30:31,260
หรือค่าเป็นศูนย์

1811
01:30:31,260 --> 01:30:36,630
>> ดังนั้นถ้าฉันมีค่าน้อยกว่าศูนย์ให้ฉัน
เพียงแค่มีโปรแกรมนี้เพียงแค่พูดว่า

1812
01:30:36,630 --> 01:30:42,370
ลบทับขวา N, อื่น ๆ
ถ้าฉันมีค่ามากกว่าศูนย์

1813
01:30:42,370 --> 01:30:47,030
ตอนนี้ฉันกำลังของหลักสูตรจะพูด
printf บวก n ทับขวา

1814
01:30:47,030 --> 01:30:50,690
แล้วอื่น if-- ฉันสามารถทำเช่นนี้

1815
01:30:50,690 --> 01:30:53,410
>> ฉันจะทำอย่างไรถ้าฉันมีค่าเท่ากับ 0

1816
01:30:53,410 --> 01:30:55,840
แต่ผมต้องการจะทำที่
อย่างน้อยหนึ่งข้อผิดพลาดอยู่แล้ว

1817
01:30:55,840 --> 01:30:59,480
จำได้ว่าเป็นเครื่องหมายเท่ากับ
ไม่เท่ากับเป็นมนุษย์เรารู้ว่ามัน

1818
01:30:59,480 --> 01:31:01,010
>> แต่มันเป็นผู้ประกอบการที่ได้รับมอบหมาย

1819
01:31:01,010 --> 01:31:05,640
และเราไม่ต้องการที่จะใช้ 0 บน
ที่เหมาะสมและใส่ไว้ในผมด้านซ้าย

1820
01:31:05,640 --> 01:31:11,810
ดังนั้นเพื่อหลีกเลี่ยงความสับสนนี้หรือ
บางทีอาจจะผิดวัตถุประสงค์ของเครื่องหมายเท่ากับ,

1821
01:31:11,810 --> 01:31:14,740
มนุษย์ตัดสินใจบางปีที่ผ่านมา
ว่าในหลายภาษาโปรแกรม

1822
01:31:14,740 --> 01:31:18,000
เมื่อคุณต้องการที่จะตรวจสอบเพื่อความเท่าเทียมกัน
ระหว่างด้านซ้ายและด้านขวา

1823
01:31:18,000 --> 01:31:19,635
คุณใช้จริงเท่ากับเท่ากับ

1824
01:31:19,635 --> 01:31:21,010
ดังนั้นคุณจะตีเท่ากับสองเท่า

1825
01:31:21,010 --> 01:31:25,600
เมื่อคุณต้องการที่จะกำหนดจากขวา
ไปทางซ้ายคุณใช้เครื่องหมายเท่ากับเดียว

1826
01:31:25,600 --> 01:31:29,360
ดังนั้นเราจึงสามารถทำ this-- อื่น
ถ้าฉันเท่ากับเท่ากับศูนย์

1827
01:31:29,360 --> 01:31:31,710
>> จากนั้นผมก็จะไป
เปิดวงเล็บปีกกาของฉัน

1828
01:31:31,710 --> 01:31:36,087
และพูดว่า printf 0, n ทับขวาทำ

1829
01:31:36,087 --> 01:31:38,170
แต่จำไว้ว่าวิธีการเหล่านี้
ส้อมในถนนสามารถทำงานได้

1830
01:31:38,170 --> 01:31:39,836
และจริงๆเพียงแค่คิดว่าเกี่ยวกับตรรกะ

1831
01:31:39,836 --> 01:31:41,510
ฉันเป็นตัวเลข

1832
01:31:41,510 --> 01:31:43,320
มันเป็นจำนวนเต็มโดยเฉพาะ

1833
01:31:43,320 --> 01:31:48,600
และนั่นหมายความว่ามันเป็นไปได้น้อย
กว่า 0 หรือมากกว่า 0 หรือ 0

1834
01:31:48,600 --> 01:31:51,600
จึงมีชนิดของนี้
กรณีที่เริ่มต้นโดยนัย

1835
01:31:51,600 --> 01:31:54,920
>> และเพื่อให้เราสามารถเช่นเดียวกับ
รอยขีดข่วนแจกจ่ายกับอื่นถ้า

1836
01:31:54,920 --> 01:31:55,747
และเพียงแค่พูดอื่น

1837
01:31:55,747 --> 01:31:57,830
เหตุผลถ้าคุณ
โปรแกรมเมอร์รู้ว่ามีเพียง

1838
01:31:57,830 --> 01:32:01,635
สามถังเข้าไปที่
สถานการณ์สามารถ fall-- แรก

1839
01:32:01,635 --> 01:32:03,510
ที่สองหรือที่สาม
ในเรื่องนี้ case-- ไม่

1840
01:32:03,510 --> 01:32:07,100
ต้องเพิ่มความแม่นยำเพิ่มเติม
และตรรกะเพิ่มเติมมี

1841
01:32:07,100 --> 01:32:09,690
เพียงแค่ไปข้างหน้ากับ
กรณีที่เริ่มต้นที่นี่อื่น

1842
01:32:09,690 --> 01:32:11,950
>> ตอนนี้ขอไปข้างหน้า
หลังจากบันทึกนี้ให้

1843
01:32:11,950 --> 01:32:15,760
เงื่อนไขดอทเฉือน conditions--
ไม่ได้เป็นส่วนติดต่อผู้ใช้ที่ดี

1844
01:32:15,760 --> 01:32:18,914
เพราะฉันไม่ได้กระตุ้น
ผู้ใช้ที่ผมกล่าวถึงก่อนหน้านี้

1845
01:32:18,914 --> 01:32:19,580
แต่ที่ดี

1846
01:32:19,580 --> 01:32:20,454
เราจะให้มันง่าย

1847
01:32:20,454 --> 01:32:21,890
ลองหมายเลข 42

1848
01:32:21,890 --> 01:32:23,240
และที่เป็นบวก

1849
01:32:23,240 --> 01:32:26,120
ลองจำนวน
เชิงลบ 42 ลบ

1850
01:32:26,120 --> 01:32:28,244
>> ลองค่า 0

1851
01:32:28,244 --> 01:32:29,160
และแน่นอนว่าการทำงาน

1852
01:32:29,160 --> 01:32:33,900
ตอนนี้คุณจะเห็นมีปัญหาก่อน
ยาวทดสอบสิ่งสามครั้ง

1853
01:32:33,900 --> 01:32:34,980
อาจจะไม่เพียงพอ

1854
01:32:34,980 --> 01:32:37,438
คุณอาจต้องการที่จะทดสอบบางอย่าง
ตัวเลขขนาดใหญ่บางส่วนที่มีขนาดเล็ก

1855
01:32:37,438 --> 01:32:40,520
ตัวเลขบางกรณีมุมเช่น
เราจะมาอธิบายให้พวกเขา

1856
01:32:40,520 --> 01:32:42,500
>> แต่สำหรับตอนนี้เป็น
โปรแกรมใช้งานง่ายสวย

1857
01:32:42,500 --> 01:32:45,160
และผมค่อนข้างมั่นใจว่าเหตุผล
ว่ามันตกอยู่ในสามกรณี

1858
01:32:45,160 --> 01:32:49,360
และแน่นอนแม้ว่าเราเพียง
มุ่งเน้นไปที่ข้อเสียที่อาจเกิดขึ้น

1859
01:32:49,360 --> 01:32:53,480
ของไม่แน่ชัดและไหลท่วมใน
ความเป็นจริงที่หลายปัญหา CS50 ของ

1860
01:32:53,480 --> 01:32:56,000
เราจะไม่ต้องกังวล
เกี่ยวกับตลอดเวลา

1861
01:32:56,000 --> 01:32:59,050
ปัญหาเหล​​่านั้นล้นและ
ไม่แน่ชัดเพราะในความเป็นจริงใน C,

1862
01:32:59,050 --> 01:33:01,889
จริง ๆ แล้วมันไม่ได้ทั้งหมดที่
ง่ายต่อการหลีกเลี่ยงสิ่งเหล่านั้น

1863
01:33:01,889 --> 01:33:04,180
หากคุณต้องการที่จะนับขึ้น
ขนาดใหญ่และขนาดใหญ่และขนาดใหญ่

1864
01:33:04,180 --> 01:33:07,510
มันจะเปิดออกมีเทคนิคคุณ
สามารถใช้มักเกี่ยวข้องกับสิ่งที่เรียกว่า

1865
01:33:07,510 --> 01:33:11,240
ห้องสมุดคอลเลกชันของรหัสที่
คนอื่น ๆ ที่เขียนว่าคุณสามารถใช้

1866
01:33:11,240 --> 01:33:13,910
และภาษาอื่น ๆ เช่น
Java และอื่น ๆ จริง

1867
01:33:13,910 --> 01:33:15,800
ทำให้มันง่ายขึ้นมาก
จะนับที่สูงยิ่งขึ้น

1868
01:33:15,800 --> 01:33:19,810
ดังนั้นมันคือเรื่องจริงบางส่วนของอันตรายเหล่านี้
ฟังก์ชั่นของภาษาที่คุณใช้

1869
01:33:19,810 --> 01:33:22,710
และในสัปดาห์ที่ผ่านมาเราจะ
ดูวิธีการที่อันตรายจริงๆ C

1870
01:33:22,710 --> 01:33:24,950
สามารถหากคุณไม่ได้ใช้มันอย่างถูกต้อง

1871
01:33:24,950 --> 01:33:27,610
แต่จากที่นั่นและมี
งูหลามและ JavaScript จะ

1872
01:33:27,610 --> 01:33:32,620
เราชั้นบนคุ้มครองเพิ่มเติมบางอย่าง
และเรียกใช้น้อยลงของความเสี่ยงเหล่านั้น

1873
01:33:32,620 --> 01:33:35,820
>> ดังนั้นขอให้เล็ก ๆ น้อย ๆ
ตรรกะที่น่าสนใจในโปรแกรมของเรา

1874
01:33:35,820 --> 01:33:39,110
เพื่อให้ฉันไปข้างหน้าและสร้าง
โปรแกรมที่เรียกว่าตรรกะ

1875
01:33:39,110 --> 01:33:43,804
เพียงเพื่อให้ฉันสามารถเล่นกับบางส่วน
ตรรกะที่เกิดขึ้นจริง logical.c

1876
01:33:43,804 --> 01:33:46,870
ฉันเพิ่งจะคัดลอกและวางบาง
รหัสจากก่อนหน้านี้ดังนั้นฉันได้รับกลับมา

1877
01:33:46,870 --> 01:33:49,950
ไปยังจุดเริ่มต้นที่ดีนี้

1878
01:33:49,950 --> 01:33:53,980
>> ผมขอเวลานี้ทำซีถ่านฉัน
จะให้ชื่อของซี

1879
01:33:53,980 --> 01:33:58,510
เพียงเพราะมันเป็นธรรมดา
ได้รับตัวอักษรจากผู้ใช้

1880
01:33:58,510 --> 01:34:00,730
และให้แสร้งว่า
ผมดำเนินการส่วนหนึ่ง

1881
01:34:00,730 --> 01:34:04,130
ของโปรแกรม Rm นั้นลบ
โปรแกรมก่อนที่ได้รับแจ้งผู้ใช้

1882
01:34:04,130 --> 01:34:05,400
จะลบไฟล์

1883
01:34:05,400 --> 01:34:06,750
วิธีการที่เราสามารถทำเช่นนี้?

1884
01:34:06,750 --> 01:34:11,090
>> ผมอยากจะบอกว่าถ้า C เท่ากับ
เท่ากับอ้างนำมาอ้าง,

1885
01:34:11,090 --> 01:34:16,304
Y แล้วฉันจะถือว่า
ที่ผู้ใช้เลือกที่ใช่

1886
01:34:16,304 --> 01:34:17,470
ฉันแค่จะพิมพ์ใช่

1887
01:34:17,470 --> 01:34:19,440
ถ้ามันถูกเขียนจริง
โปรแกรมกำจ​​ัด

1888
01:34:19,440 --> 01:34:21,420
เราสามารถลบไฟล์
มีเส้นมากขึ้นของรหัส

1889
01:34:21,420 --> 01:34:22,461
แต่เราจะให้มันง่าย

1890
01:34:22,461 --> 01:34:25,950

1891
01:34:25,950 --> 01:34:31,250
>> อื่นถ้า C เท่ากับเท่ากับ n--
และตอนนี้ที่นี่ฉันจะบอกว่า

1892
01:34:31,250 --> 01:34:32,980
ผู้ใช้จะต้องมีความหมายไม่มี

1893
01:34:32,980 --> 01:34:34,360
และจากนั้นก็ได้ที่คุณรู้อะไรไหม

1894
01:34:34,360 --> 01:34:36,200
ผมไม่ทราบว่าสิ่งที่คนอื่น
ผู้ใช้จะไปพิมพ์

1895
01:34:36,200 --> 01:34:38,533
ดังนั้นฉันเพียงแค่จะบอกว่า
ที่เป็นข้อผิดพลาดใด ๆ ก็ตาม

1896
01:34:38,533 --> 01:34:40,070
เขาหรือเธอพิมพ์จริง

1897
01:34:40,070 --> 01:34:41,180
>> ดังนั้นสิ่งที่เกิดขึ้นที่นี่?

1898
01:34:41,180 --> 01:34:44,530
มีความแตกต่างพื้นฐานคือ
เมื่อเทียบกับสิ่งที่ผมเคยทำมาในอดีต

1899
01:34:44,530 --> 01:34:49,300
ราคาคู่ราคาคู่สองครั้ง
คำพูดและยังราคาเดียว

1900
01:34:49,300 --> 01:34:50,170
ราคาเดียว

1901
01:34:50,170 --> 01:34:52,860
มันจะเปิดออกใน C ว่าเมื่อ
คุณต้องการเขียนสตริง

1902
01:34:52,860 --> 01:34:56,680
คุณใช้คำพูดสองเช่นเดียวกับเราได้
ได้ใช้ตลอดเวลานี้กับ printf

1903
01:34:56,680 --> 01:35:02,030
>> แต่ถ้าคุณต้องการที่จะจัดการกับเพียง
ตัวเดียวที่เรียกว่าถ่าน

1904
01:35:02,030 --> 01:35:03,780
แล้วคุณจริงใช้ราคาเดียว

1905
01:35:03,780 --> 01:35:05,450
บรรดาผู้ที่ได้ตั้งโปรแกรม
ก่อนที่คุณอาจไม่ได้

1906
01:35:05,450 --> 01:35:07,850
จะต้องกังวลเกี่ยวกับเรื่องนี้
ความแตกต่างในบางภาษา

1907
01:35:07,850 --> 01:35:09,450
ใน C มันไม่สำคัญ

1908
01:35:09,450 --> 01:35:12,560
และอื่น ๆ เมื่อฉันได้รับถ่านและฉันต้องการ
เพื่อเปรียบเทียบถ่านที่ใช้เท่ากับ

1909
01:35:12,560 --> 01:35:18,350
เท่ากับตัวอักษรบางอย่างเช่น Y หรือ N, ที่ฉันทำ
แน่นอนจะต้องมีราคาเดียว

1910
01:35:18,350 --> 01:35:19,770
>> ตอนนี้ขอไปข้างหน้าและทำเช่นนี้

1911
01:35:19,770 --> 01:35:26,180
Let 's ไปข้างหน้าและจะทำให้
จุดตรรกะเฉือนตรรกะ

1912
01:35:26,180 --> 01:35:27,305
และตอนนี้ฉันถาม

1913
01:35:27,305 --> 01:35:30,638
ดังนั้นน่าจะเป็นประสบการณ์ใช้งานที่ดี
จริงจะบอกฉันว่าจะทำที่นี่

1914
01:35:30,638 --> 01:35:33,030
แต่ฉันจะเพียงสุ่มสี่สุ่มห้า
พูด Y สำหรับใช่ตกลงที่ดี

1915
01:35:33,030 --> 01:35:35,780
>> ลองเรียกใช้อีกครั้ง, N ไม่ดี

1916
01:35:35,780 --> 01:35:39,610
สมมติว่าเหมือนคนบางคนที่ผมรู้
หมวกล็อคกุญแจของฉันอยู่บนทั้งหมดบ่อยเกินไป

1917
01:35:39,610 --> 01:35:43,740
ดังนั้นผมจึงทำทุน Y ป้อนข้อผิดพลาด

1918
01:35:43,740 --> 01:35:46,130
ตกลงมันไม่ได้เป็นสิ่งที่ฉันคาดหวัง

1919
01:35:46,130 --> 01:35:48,170
แท้จริงคอมพิวเตอร์
จะทำในสิ่งที่ตัวอักษร

1920
01:35:48,170 --> 01:35:51,794
ผมบอกว่ามัน do-- ตรวจสอบ
ตัวพิมพ์เล็กและตัวพิมพ์เล็ก Y n

1921
01:35:51,794 --> 01:35:53,960
นี้ไม่ได้รู้สึกเหมือนดี
ประสบการณ์ของผู้ใช้ แต่

1922
01:35:53,960 --> 01:35:59,010
ให้ฉันถามหาและยอมรับ
ทั้งกรณีที่ต่ำกว่าหรือกรณีบน

1923
01:35:59,010 --> 01:36:02,090
ดังนั้นมันจะเปิดออกคุณอาจต้องการ
จะพูดอะไรเหมือนในเกา

1924
01:36:02,090 --> 01:36:08,150
เช่นตัวอักษรหรือ C เท่ากับ
เท่ากับทุน Y ยกมาเพียงครั้งเดียว

1925
01:36:08,150 --> 01:36:11,400
เปิดออก, C ไม่ได้
คำหลักที่แท้จริงนี้หรือ

1926
01:36:11,400 --> 01:36:12,880
>> แต่มันจะมีแถบแนวตั้งสอง

1927
01:36:12,880 --> 01:36:15,463
คุณจะต้องกด Shift ค้างไว้มักจะ
ถ้าคุณกำลังใช้แป้นพิมพ์ของสหรัฐ

1928
01:36:15,463 --> 01:36:18,910
และกดแถบแนวตั้ง
ที่สำคัญดังกล่าวข้างต้นที่สำคัญผลตอบแทน

1929
01:36:18,910 --> 01:36:22,410
แต่แถบแนวตั้งนี้
แถบแนวตั้งหรือหมายความว่า

1930
01:36:22,410 --> 01:36:26,220
>> หากตร​​งกันข้ามเราต้องการ
ที่จะพูดและเหมือนในเกา

1931
01:36:26,220 --> 01:36:28,180
เราสามารถทำเครื่องหมายสัญลักษณ์

1932
01:36:28,180 --> 01:36:31,330
ที่ทำให้ไม่รู้สึกตรรกะที่นี่
เพราะมนุษย์ไม่อาจ

1933
01:36:31,330 --> 01:36:37,110
พิมพ์ทั้ง Y และ Y ตัวพิมพ์เล็ก
เงินทุนและ Y เป็นตัวละครเดียวกัน

1934
01:36:37,110 --> 01:36:39,470
ดังนั้นหรือเป็นสิ่งที่เราตั้งใจที่นี่

1935
01:36:39,470 --> 01:36:46,280
>> ดังนั้นถ้าฉันทำเช่นนี้ในสถานที่ทั้งสองหรือ C
เท่ากับเท่ากับทุน N, วิ่งตอนนี้

1936
01:36:46,280 --> 01:36:49,390
ทำให้ตรรกะตรรกะรันใหม่อีกครั้ง

1937
01:36:49,390 --> 01:36:51,200
ตอนนี้ผมสามารถพิมพ์ Y

1938
01:36:51,200 --> 01:36:53,920
และผมสามารถทำมันได้อีกครั้งกับ
ทุน Y หรือเอ็นทุน

1939
01:36:53,920 --> 01:36:56,630
และฉันจะเพิ่มในการเพิ่มเติม
ยังคงอยู่รวมกัน

1940
01:36:56,630 --> 01:36:58,810
>> ดังนั้นนี่คือตรรกะ
โปรแกรมเท่าตอนนี้

1941
01:36:58,810 --> 01:37:01,940
ผมตรวจสอบเหตุผลสำหรับ
ค่านี้หรือค่านี้

1942
01:37:01,940 --> 01:37:06,420
และฉันไม่จำเป็นต้องจำเ​​ป็น
เกิดขึ้นกับอีกสองไอเอฟเอหรืออื่น ๆ ที่ไอเอฟเอ

1943
01:37:06,420 --> 01:37:09,960
ที่จริงผมสามารถรวมบางส่วนของ
ตรรกะที่เกี่ยวข้องร่วมกันในลักษณะนี้

1944
01:37:09,960 --> 01:37:11,950
ดังนั้นนี้จะดีกว่า
มากกว่าเพียงแค่การออกแบบ

1945
01:37:11,950 --> 01:37:17,490
ว่าถ้า C เท่ากับ Y กรณีที่ต่ำกว่า
พิมพ์ใช่อื่นถ้า C เท่ากับทุน Y,

1946
01:37:17,490 --> 01:37:20,074
พิมพ์ใช่อื่นถ้า C เท่ากับ
lower-- ในคำอื่น ๆ

1947
01:37:20,074 --> 01:37:21,990
คุณไม่จำเป็นต้องมี
สาขามากขึ้น

1948
01:37:21,990 --> 01:37:28,840
คุณสามารถรวมบางส่วนของเทียบเท่า
สาขาเหตุผลเป็นในลักษณะนี้

1949
01:37:28,840 --> 01:37:34,150
>> ดังนั้นลองมาดูที่เพียงหนึ่ง
ส่วนผสมสุดท้ายหนึ่งสร้างสุดท้าย

1950
01:37:34,150 --> 01:37:34,847
ที่ C ช่วยให้

1951
01:37:34,847 --> 01:37:36,930
และเราจะกลับมาใน
ในอนาคตอื่น ๆ ยังคง

1952
01:37:36,930 --> 01:37:41,400
และจากนั้นเราจะสรุปโดยการมอง
ที่ไม่ถูกต้องของ code--

1953
01:37:41,400 --> 01:37:46,070
ได้รับรหัส work-- แต่การออกแบบ
ของรหัสและเมล็ดพืชเหล่านั้นในช่วงต้น

1954
01:37:46,070 --> 01:37:51,337
>> เพื่อให้ฉันไปข้างหน้าและ
เปิดไฟล์ใหม่ที่นี่

1955
01:37:51,337 --> 01:37:51,920
คุณรู้ไหมว่า?

1956
01:37:51,920 --> 01:37:54,450
ฉันจะใช้อีกครั้ง
ว่าโปรแกรมเดียวกัน

1957
01:37:54,450 --> 01:37:55,940
แต่ใช้สร้างที่แตกต่างกัน

1958
01:37:55,940 --> 01:38:00,110
>> เพื่อให้ฉันได้อย่างรวดเร็วให้ตัวเอง
รวมถึงการเข้าถึง CS50.h

1959
01:38:00,110 --> 01:38:04,150
สำหรับห้องสมุด CS50,
มาตรฐาน Io.h สำหรับ printf

1960
01:38:04,150 --> 01:38:06,510
ให้ฉันเป็นโมฆะหลักของฉัน int

1961
01:38:06,510 --> 01:38:09,310
แล้วที่นี่ให้
ฉันไปข้างหน้าและทำเช่นนี้

1962
01:38:09,310 --> 01:38:12,010
>> ถ่านที่ได้รับได้รับถ่านเหมือนเมื่อก่อน

1963
01:38:12,010 --> 01:38:16,770
และฉันจะใช้โครงสร้างใหม่
now-- สลับในสิ่งที่ตัวละคร?

1964
01:38:16,770 --> 01:38:19,820
ดังนั้นสวิทช์เป็นชนิดเช่น
สลับรางรถไฟ

1965
01:38:19,820 --> 01:38:22,070
หรือจริงๆมันเป็นชนิดของ
ถ้ามิฉะนั้นถ้าอื่นถ้า,

1966
01:38:22,070 --> 01:38:23,980
แต่เขียนค่อนข้างแตกต่าง

1967
01:38:23,980 --> 01:38:25,490
>> สวิทช์มีลักษณะเช่นนี้

1968
01:38:25,490 --> 01:38:29,060
คุณมีสวิทช์และแล้วสิ่งที่
ตัวอักษรหรือหมายเลขที่คุณต้องการที่จะมอง

1969
01:38:29,060 --> 01:38:32,000
แล้วบางส่วนวงเล็บปีกกาชอบใน
เริ่มต้นเพียงแค่พูดว่าทำสิ่งนี้

1970
01:38:32,000 --> 01:38:33,480
แล้วคุณมีกรณีที่แตกต่าง

1971
01:38:33,480 --> 01:38:34,830
>> คุณไม่ได้ใช้ถ้าและอื่น ๆ

1972
01:38:34,830 --> 01:38:37,050
คุณอักษรใช้กรณีที่คำว่า

1973
01:38:37,050 --> 01:38:38,790
และคุณจะพูดอะไรเช่นนี้

1974
01:38:38,790 --> 01:38:43,820
>> ดังนั้นในกรณีของ Y ตัวพิมพ์เล็ก,
หรือในกรณีของเงินทุน Y ที่

1975
01:38:43,820 --> 01:38:47,350
ไปข้างหน้าและพิมพ์ออกมาใช่

1976
01:38:47,350 --> 01:38:49,020
และจากนั้นแยกออกจากสวิทช์

1977
01:38:49,020 --> 01:38:49,580
แค่นั้นแหละ.

1978
01:38:49,580 --> 01:38:50,880
เรากำลังทำ

1979
01:38:50,880 --> 01:38:57,270
>> อื่นถ้า, เพื่อที่จะพูด
กรณีที่ต่ำกว่า n หรือร่วมทุน N,

1980
01:38:57,270 --> 01:39:02,560
แล้วไปข้างหน้าและพิมพ์
ไม่ออกแล้วทำลาย

1981
01:39:02,560 --> 01:39:08,022
Else-- และชนิดของนี้เป็น
กรณีที่เริ่มต้น indeed-- printf error--

1982
01:39:08,022 --> 01:39:10,980
และเพียงแค่การวัดที่ดีแม้ว่า
เหตุผลพักนี้ไม่จำเป็น

1983
01:39:10,980 --> 01:39:12,896
เพราะเราในตอนท้าย
สวิทช์อยู่แล้ว

1984
01:39:12,896 --> 01:39:14,520
ตอนนี้ผมกำลังจะหมดจากสวิทช์

1985
01:39:14,520 --> 01:39:16,280
ดังนั้นนี้มีลักษณะแตกต่างกันเล็กน้อย

1986
01:39:16,280 --> 01:39:18,272
>> แต่เหตุผลมัน
เทียบเท่าจริง

1987
01:39:18,272 --> 01:39:19,980
และเหตุผลที่คุณจะใช้
หนึ่งในช่วงอื่น ๆ ?

1988
01:39:19,980 --> 01:39:23,220
บางครั้งเพียงแค่ความชอบส่วนบุคคล
บางครั้งความงาม,

1989
01:39:23,220 --> 01:39:25,420
ถ้าผมเหลือบนี้
ตอนนี้มีบางสิ่งบางอย่าง

1990
01:39:25,420 --> 01:39:27,510
ที่จะกล่าวว่าสำหรับ
การอ่านรห​​ัสนี้

1991
01:39:27,510 --> 01:39:30,690
ผมหมายถึงไม่เคยคิดจริงที่ว่านี้
รหัสใหม่ให้พวกเราหลายคนในห้องพัก

1992
01:39:30,690 --> 01:39:33,515
>> แต่เพียงแค่ชนิดของมันสวย

1993
01:39:33,515 --> 01:39:37,760
คุณจะเห็นตัวพิมพ์เล็ก Y เมืองหลวง Y,
n กรณีที่ต่ำกว่าค่าเริ่มต้นทุน N,

1994
01:39:37,760 --> 01:39:40,150
มันเป็นเพียงแค่ชนิดของการกระโดด
ออกจากที่คุณในทางที่

1995
01:39:40,150 --> 01:39:42,200
ว่าเนื้อหาอาจจะ
ตัวอย่างก่อนหน้านี้

1996
01:39:42,200 --> 01:39:45,780
กับไอเอฟเอและแถบแนวตั้ง
และอื่น ๆ ที่ไอเอฟเอที่ไม่อาจมี

1997
01:39:45,780 --> 01:39:51,600
ดังนั้นนี้เป็นจริงเรื่องของส่วนบุคคล
ทางเลือกจริงๆหรืออ่าน

1998
01:39:51,600 --> 01:39:52,360
ของรหัส

1999
01:39:52,360 --> 01:39:58,230
>> แต่ในแง่ของการทำงานให้ฉัน
ไปข้างหน้าและทำให้สวิทช์เฉือนจุด

2000
01:39:58,230 --> 01:40:05,830
สวิทช์และตอนนี้พิมพ์ Y พิมพ์เล็ก
ทุน Y พิมพ์เล็ก N, ทุน N,

2001
01:40:05,830 --> 01:40:09,250
เดวิดลองใหม่อีกครั้งเพราะนั่นคือ
ไม่ได้เป็นตัวเดียว

2002
01:40:09,250 --> 01:40:12,050
ขอทำ X ข้อผิดพลาดเป็นไปตามคาด

2003
01:40:12,050 --> 01:40:15,640
และ logically-- และนี่คือสิ่งที่
ฉันอยากจะแนะนำใน general-- แม้กระทั่ง

2004
01:40:15,640 --> 01:40:17,790
แม้ว่าเราจะมีเพียงรอยขีดข่วน
พื้นผิวของบางส่วนของคุณสมบัติเหล่านี้

2005
01:40:17,790 --> 01:40:20,560
>> และมันอาจจะไม่ชัดเจนเมื่อคุณ
ตัวเองนั่งลงที่แป้นพิมพ์

2006
01:40:20,560 --> 01:40:21,370
วิธีการทำงานนี้หรือไม่?

2007
01:40:21,370 --> 01:40:22,240
สิ่งนี้จะทำอย่างไร?

2008
01:40:22,240 --> 01:40:25,630
สิ่งที่สวยงามเกี่ยวกับการมี
แล็ปท็อปหรือคอมพิวเตอร์ตั้งโต๊ะหรือการเข้าถึง

2009
01:40:25,630 --> 01:40:29,290
กับคอมพิวเตอร์คอมไพเลอร์,
และมีการแก้ไขรหัสเช่นนี้

2010
01:40:29,290 --> 01:40:32,990
คือคุณมักจะสามารถตอบเหล่านี้
คำถามสำหรับตัวคุณเองเพียงแค่พยายาม

2011
01:40:32,990 --> 01:40:36,570
>> ตัวอย่างเช่นถ้าวาทศิลป์
คำถามที่อยู่ในมือเขา

2012
01:40:36,570 --> 01:40:39,540
เกิดอะไรขึ้นถ้าคุณลืม
งบแบ่งของคุณหรือไม่

2013
01:40:39,540 --> 01:40:41,400
ที่เป็นจริง
สิ่งที่พบมากที่จะทำ

2014
01:40:41,400 --> 01:40:43,540
เพราะมันไม่ได้ดู
เหมือนที่คุณต้องการพวกเขาจริงๆ

2015
01:40:43,540 --> 01:40:46,790
พวกเขาไม่ได้จริงๆเสร็จสมบูรณ์ของคุณ
คิดเหมือนวงเล็บหรือหยิก

2016
01:40:46,790 --> 01:40:47,714
รั้งไม่

2017
01:40:47,714 --> 01:40:49,630
Let 's ไปข้างหน้าและ
คอมไพล์รหัสและดู

2018
01:40:49,630 --> 01:40:53,690
เพื่อให้สวิทช์, สวิทช์ดอทเฉือน

2019
01:40:53,690 --> 01:40:56,435
ลองพิมพ์ในกรณีที่ต่ำกว่า
Y กรณีด้านบนใส่

2020
01:40:56,435 --> 01:40:59,390

2021
01:40:59,390 --> 01:41:00,700
ดังนั้นผมจึงพิมพ์ Y

2022
01:41:00,700 --> 01:41:04,420
>> โปรแกรมที่กล่าวว่าใช่ไม่มีข้อผิดพลาด
ราวกับว่ามันก็เปลี่ยนความคิดของตน

2023
01:41:04,420 --> 01:41:09,280
แต่ชนิดของมันเป็นเพราะสิ่งที่เกิดขึ้น
มีสวิทช์เป็นกรณีแรกที่

2024
01:41:09,280 --> 01:41:13,899
การแข่งขันเป็นหลักหมายถึงเฮ้คอมพิวเตอร์
การดำเนินการทั้งหมดของรหัสที่อยู่ข้างใต้

2025
01:41:13,899 --> 01:41:16,690
และถ้าคุณไม่ได้บอกว่าการแบ่งหรือ
ไม่ได้บอกว่าการแบ่งหรือไม่พูดทำลาย

2026
01:41:16,690 --> 01:41:19,540
คอมพิวเตอร์เป็นไปเป่า
ผ่านทุกเส้นที่

2027
01:41:19,540 --> 01:41:22,779
และดำเนินการทั้งหมดของพวกเขาจนกว่า
ได้รับไปที่วงเล็บปีกกา

2028
01:41:22,779 --> 01:41:24,320
ดังนั้นเบรกเป็นจริงที่จำเป็น

2029
01:41:24,320 --> 01:41:27,120
แต่ Takeaway นี่คือเมื่อ
มีข้อสงสัยลองอะไร

2030
01:41:27,120 --> 01:41:29,510
บางทีบันทึกรหัสแรกของคุณ
หรือบันทึกไว้ในแฟ้มพิเศษ

2031
01:41:29,510 --> 01:41:32,930
ถ้าคุณกังวลมากเกี่ยวกับ
ล้อขึ้นและมีการกู้คืน

2032
01:41:32,930 --> 01:41:34,430
งานที่คุณรู้ว่าเป็นคนที่ทำงาน

2033
01:41:34,430 --> 01:41:35,410
>> แต่ลองสิ่ง

2034
01:41:35,410 --> 01:41:38,074
และไม่กลัวที่จะเป็นบางที
ของสิ่งที่คอมพิวเตอร์อาจทำ

2035
01:41:38,074 --> 01:41:39,490
หรือว่าคุณอาจทำลายบางสิ่งบางอย่าง

2036
01:41:39,490 --> 01:41:42,790
คุณสามารถเปลี่ยนกลับ
บางรุ่นก่อนหน้านี้

2037
01:41:42,790 --> 01:41:45,640
>> ดังนั้นขอจบด้วยการมอง
ที่การออกแบบของรหัส

2038
01:41:45,640 --> 01:41:49,020
เรามีความสามารถนี้ในขณะนี้ที่จะเขียน
เงื่อนไขและเขียนลูป

2039
01:41:49,020 --> 01:41:50,850
และตัวแปรและฟังก์ชั่นการโทร

2040
01:41:50,850 --> 01:41:54,590
ดังนั้นตรงไปตรงมาเราชนิดของการกลับมาที่
ว่าเราอยู่ที่ไหนสัปดาห์ที่ผ่านมากับการเกา

2041
01:41:54,590 --> 01:42:00,120
แม้ว่ามีต้นฉบับเดิมที่น่าสนใจน้อย
สภาพแวดล้อมกว่า Scratch ช่วยให้

2042
01:42:00,120 --> 01:42:03,990
>> แต่สังเกตเห็นวิธีการอย่างรวดเร็วเราได้ที่ได้มา
คำศัพท์ที่แม้ว่าจะเป็น

2043
01:42:03,990 --> 01:42:07,570
จะใช้เวลาสักครู่จะจมลงไปใน
เพื่อที่ว่าตอนนี้เราสามารถใช้คำศัพท์นี้

2044
01:42:07,570 --> 01:42:10,320
การเขียนโปรแกรมที่น่าสนใจมากขึ้น

2045
01:42:10,320 --> 01:42:12,940
และให้ใช้ขั้นตอนทารก
ไปยังที่ดังต่อไปนี้

2046
01:42:12,940 --> 01:42:14,890
ให้ฉันไปข้างหน้าและ
สร้างไฟล์ใหม่ที่นี่

2047
01:42:14,890 --> 01:42:17,750
>> ฉันจะเรียกสิ่งนี้ว่า
prototype.c และแนะนำ

2048
01:42:17,750 --> 01:42:20,954
เป็นครั้งแรกที่ความสามารถในการ
ที่จะทำให้การทำงานของคุณเอง

2049
01:42:20,954 --> 01:42:22,870
บางท่านอาจจะมี
การกระทำเช่นนี้มีรอยขีดข่วน

2050
01:42:22,870 --> 01:42:25,430
โดยคุณสามารถสร้างของคุณ
บล็อกกำหนดเองในเกา

2051
01:42:25,430 --> 01:42:27,892
แล้วลากเข้าไปในสถานที่
ทุกที่ที่คุณต้องการใน C.

2052
01:42:27,892 --> 01:42:30,100
และในการเขียนโปรแกรมมากที่สุด
ภาษาคุณสามารถทำตรง

2053
01:42:30,100 --> 01:42:33,580
ในปัจจุบันผู้ให้ฟังก์ชั่นของคุณเอง
ถ้าพวกเขาไม่ได้อยู่แล้ว

2054
01:42:33,580 --> 01:42:38,660
>> ดังนั้นสำหรับตัวอย่างให้ฉันไปข้างหน้า
และรวมถึง CS50.h และรวมถึง

2055
01:42:38,660 --> 01:42:43,110
มาตรฐาน IO.h โมฆะหลัก int

2056
01:42:43,110 --> 01:42:46,020
และตอนนี้เรามี
ตัวยึดพร้อมที่จะไป

2057
01:42:46,020 --> 01:42:48,550
ผมให้สิ่งที่พิมพ์
เช่นชื่อของผู้คนในวันนี้

2058
01:42:48,550 --> 01:42:51,910
และที่รู้สึก like--
จะไม่ดีถ้ามี

2059
01:42:51,910 --> 01:42:53,936
มีฟังก์ชั่นที่เรียกว่าพิมพ์ชื่อ?

2060
01:42:53,936 --> 01:42:55,060
ฉันไม่ได้มีการใช้ printf

2061
01:42:55,060 --> 01:42:56,976
ฉันไม่ต้องจำ
ทุกรหัสรูปแบบ

2062
01:42:56,976 --> 01:43:00,050
ทำไมฉันจึงไม่หรือทำไม
ไม่ได้มีใครบางคนก่อนที่ฉัน

2063
01:43:00,050 --> 01:43:02,980
สร้างฟังก์ชั่นที่เรียกว่าพิมพ์
ชื่อที่ได้รับชื่อบาง

2064
01:43:02,980 --> 01:43:03,980
เพียงแค่พิมพ์ออก?

2065
01:43:03,980 --> 01:43:08,700
>> ในคำอื่น ๆ ถ้าผมบอกว่าเดี๋ยวก่อน
คอมพิวเตอร์ให้ฉันสตริง

2066
01:43:08,700 --> 01:43:11,870
โดยขอให้ผู้ใช้สำหรับการดังกล่าว
ผ่านฟังก์ชั่นสตริง CS50 ของ

2067
01:43:11,870 --> 01:43:15,090
Hey, คอมพิวเตอร์, ใส่สตริงที่ใน
ตัวแปรในด้านซ้ายมือ

2068
01:43:15,090 --> 01:43:16,150
และเรียกมัน

2069
01:43:16,150 --> 01:43:22,150
แล้วเฮ้คอมพิวเตอร์ไปข้างหน้า
และพิมพ์ว่าชื่อของคนทำ

2070
01:43:22,150 --> 01:43:26,240
>> ตอนนี้มันจะดีเพราะ
โปรแกรมนี้ชื่อเหมาะเจาะ

2071
01:43:26,240 --> 01:43:29,170
บอกฉันสิ่งที่มันควรจะทำอย่างไร
โดยวิธีการที่ชื่อของฟังก์ชั่นเหล่านั้น

2072
01:43:29,170 --> 01:43:32,930
ผมขอไปและทำให้ต้นแบบใส่

2073
01:43:32,930 --> 01:43:34,930
และโชคไม่ดี
นี้จะไม่บิน

2074
01:43:34,930 --> 01:43:39,430
>> Prototype.c สาย 7 ตัวอักษร
5 ข้อผิดพลาดการประกาศโดยปริยาย

2075
01:43:39,430 --> 01:43:42,960
ชื่อฟังก์ชั่นการพิมพ์
ไม่ถูกต้องใน C99, C99

2076
01:43:42,960 --> 01:43:45,130
หมายถึงรุ่นของซี
ที่ออกมาในปี 1999

2077
01:43:45,130 --> 01:43:45,730
นั่นคือทั้งหมดที่

2078
01:43:45,730 --> 01:43:48,780
>> ดังนั้นผมจึงไม่ทราบว่า
ทั้งหมดนี้หมายความว่ายัง

2079
01:43:48,780 --> 01:43:50,810
แต่ฉันจะตระหนักถึงความผิดพลาดในสีแดง

2080
01:43:50,810 --> 01:43:51,770
ที่เห็นได้ชัดสวย

2081
01:43:51,770 --> 01:43:53,769
>> และดูเหมือนว่ามี
ตัวอักษรสีเขียวที่นี่

2082
01:43:53,769 --> 01:43:57,520
ปัญหาคือมีชื่อพิมพ์เปิด
วงเล็บ S, วงเล็บใกล้กึ่งลำไส้ใหญ่

2083
01:43:57,520 --> 01:44:01,800
แต่การประกาศโดยนัยของ
ฟังก์ชั่นที่เราไม่เห็นในเวลาสั้น ๆ ก่อนหน้านี้

2084
01:44:01,800 --> 01:44:04,880
ซึ่งหมายความเพียงว่าเสียงดังกราว
ไม่ทราบว่าผมหมายถึง

2085
01:44:04,880 --> 01:44:09,000
>> ผมเคยใช้คำศัพท์ว่ามันเป็น
ไม่เคยเห็นหรือได้รับการสอนมาก่อน

2086
01:44:09,000 --> 01:44:11,950
และดังนั้นผมจึงจำเป็นต้องสอน
สิ่งที่ฟังก์ชั่นนี้หมายถึง

2087
01:44:11,950 --> 01:44:13,590
ดังนั้นฉันจะไปข้างหน้าและทำอย่างนั้น

2088
01:44:13,590 --> 01:44:17,970
>> ฉันจะไปข้างหน้าและการดำเนินการ
ฟังก์ชั่นที่เรียกว่าตัวเองชื่อพิมพ์ของฉัน

2089
01:44:17,970 --> 01:44:24,720
และผมจะต้องพูดดังนี้ว่า
มันไม่นี้ printf สวัสดีร้อยละ

2090
01:44:24,720 --> 01:44:27,760
S, ทับขวา n ชื่อกึ่งลำไส้ใหญ่

2091
01:44:27,760 --> 01:44:29,250
ดังนั้นสิ่งที่ฉันไม่เพียงแค่ทำอย่างไร

2092
01:44:29,250 --> 01:44:31,325
>> ดังนั้นมันจะเปิดออกไป
ใช้ฟังก์ชั่นของคุณเอง

2093
01:44:31,325 --> 01:44:33,845
ชนิดที่เรายืมบางส่วนของ
โครงสร้างเดียวกันเป็นหลัก

2094
01:44:33,845 --> 01:44:35,720
ที่เราได้รับเพียง
สำหรับรับและฉัน

2095
01:44:35,720 --> 01:44:37,730
รู้เพียงคัดลอกและ
วางสิ่งที่สวยมาก

2096
01:44:37,730 --> 01:44:39,170
ฉันได้รับการเขียนในอดีตที่ผ่านมา

2097
01:44:39,170 --> 01:44:40,570
แต่สังเกตเห็นรูปแบบที่นี่

2098
01:44:40,570 --> 01:44:43,750
int หลักเป็นโมฆะเราจะหยอกล้อออกจากกัน
อีกไม่นานสิ่งที่จริงหมายถึง

2099
01:44:43,750 --> 01:44:46,160
>> แต่สำหรับวันนี้เพียงแค่
ทราบขนาน

2100
01:44:46,160 --> 01:44:48,210
โมฆะชื่อพิมพ์
ชื่อสตริงเพื่อให้มี

2101
01:44:48,210 --> 01:44:50,310
คำหลักสีม่วงซึ่ง
เรากำลังจะเริ่มต้น

2102
01:44:50,310 --> 01:44:54,067
โทรชนิดกลับเป็นชื่อของ
ฟังก์ชั่นและจากนั้นการป้อนข้อมูล

2103
01:44:54,067 --> 01:44:56,400
ดังนั้นในความเป็นจริงเราสามารถกลั่น
ชนิดของสัปดาห์ที่ผ่านมาเช่นนี้

2104
01:44:56,400 --> 01:44:59,030
เป็นนี้เป็นชื่อหรือที่
อัลกอริทึมของรหัสเรา

2105
01:44:59,030 --> 01:45:00,761
จะ write--
อัลกอริทึมพื้นฐาน

2106
01:45:00,761 --> 01:45:02,010
รหัสที่เรากำลังจะเขียน

2107
01:45:02,010 --> 01:45:03,180
>> นี่คือปัจจัยการผลิต

2108
01:45:03,180 --> 01:45:04,670
นี่คือผลลัพธ์ของมัน

2109
01:45:04,670 --> 01:45:08,730
ฟังก์ชั่นนี้ชื่อพิมพ์คือ
ออกแบบมาเพื่อใช้สตริงเรียกชื่อ

2110
01:45:08,730 --> 01:45:11,350
หรือสิ่งที่เป็น input และจากนั้นเป็นโมฆะ

2111
01:45:11,350 --> 01:45:13,904
มันไม่กลับอะไร
เหมือนได้รับสตริงหรือได้รับ int ไม่

2112
01:45:13,904 --> 01:45:15,570
ดังนั้นมันจะมอบอะไรบางอย่างกลับมา

2113
01:45:15,570 --> 01:45:17,960
มันเป็นเพียงแค่จะมี
ผลข้างเคียงเพื่อที่จะพูด

2114
01:45:17,960 --> 01:45:19,570
ในการพิมพ์ชื่อของบุคคล

2115
01:45:19,570 --> 01:45:22,260
ดังนั้นสังเกตเห็นสาย 7 ผม
สามารถเรียกชื่อพิมพ์

2116
01:45:22,260 --> 01:45:25,920
สาย 10 ผมสามารถกำหนด
หรือใช้ชื่อพิมพ์

2117
01:45:25,920 --> 01:45:28,450
แต่โชคไม่ดีที่ไม่เพียงพอ

2118
01:45:28,450 --> 01:45:31,230
>> ให้ฉันไปข้างหน้าและ
คอมไพล์นี้หลังจากบันทึก

2119
01:45:31,230 --> 01:45:33,910
โอ้โฮตอนนี้ผมได้ทำมัน
เลวก็จะดูเหมือน

2120
01:45:33,910 --> 01:45:37,027
ประกาศดังนั้นโดยนัยของ
พิมพ์ชื่อฟังก์ชั่นไม่ถูกต้อง

2121
01:45:37,027 --> 01:45:38,360
และอีกครั้งมีข้อผิดพลาดขึ้น

2122
01:45:38,360 --> 01:45:41,430
แต่ที่ผมเตือนก่อนหน้านี้แม้
ถ้าคุณได้รับจมกับ

2123
01:45:41,430 --> 01:45:44,850
หรือเศร้าเล็ก ๆ น้อย ๆ ที่จะเห็นจำนวนมากดังนั้น
ข้อผิดพลาดมุ่งเน้นเฉพาะในวันแรก

2124
01:45:44,850 --> 01:45:47,500
ในตอนแรกเพราะมันอาจเป็นเพียงแค่
มีผลซ้อน

2125
01:45:47,500 --> 01:45:51,970
ดังนั้น C หรือเสียงดังกราวมากขึ้นโดยเฉพาะ
ยังไม่รู้จักชื่อพิมพ์

2126
01:45:51,970 --> 01:45:54,580
>> และนั่นเป็นเพราะเสียงดังกราว,
โดยการออกแบบเป็นชนิดของใบ้

2127
01:45:54,580 --> 01:45:56,280
มันเพียง แต่สิ่งที่คุณบอกว่าจะทำอย่างไร

2128
01:45:56,280 --> 01:46:00,950
และมันไม่ให้ในการสั่งซื้อ
ในที่ที่คุณบอกว่าจะทำอย่างไร

2129
01:46:00,950 --> 01:46:05,270
>> ดังนั้นผมจึงได้กำหนดหลักในสายสี่
เหมือนที่เราได้รับการทำมักจะสวย

2130
01:46:05,270 --> 01:46:07,980
ฉันได้กำหนดชื่อพิมพ์บนเส้น 10

2131
01:46:07,980 --> 01:46:11,793
แต่ฉันพยายามที่จะใช้
พิมพ์ชื่อในบรรทัดเจ็ด

2132
01:46:11,793 --> 01:46:13,670
>> มันเร็วเกินไปยังไม่มี

2133
01:46:13,670 --> 01:46:19,150
ดังนั้นผมอาจจะฉลาดและเป็นเช่น
ตกลงดังนั้นขอเพียงแค่เล่นไปตาม

2134
01:46:19,150 --> 01:46:23,680
และย้ายชื่อพิมพ์ขึ้น
ที่นี่และรวบรวมอีกครั้ง

2135
01:46:23,680 --> 01:46:24,550
โอ้พระเจ้า.

2136
01:46:24,550 --> 01:46:25,260
มันทำงาน

2137
01:46:25,260 --> 01:46:26,670
มันเป็นง่ายๆเป็นว่า

2138
01:46:26,670 --> 01:46:28,120
>> แต่ตรรกะเป็นว่าที่

2139
01:46:28,120 --> 01:46:30,870
คุณจะต้องสอนสิ่งที่มันเสียงดังกราว
โดยกำหนดฟังก์ชั่นเป็นครั้งแรก

2140
01:46:30,870 --> 01:46:31,920
จากนั้นคุณสามารถใช้มัน

2141
01:46:31,920 --> 01:46:33,940
แต่ตรงไปตรงมานี้รู้สึก
เหมือนลื่นลาด

2142
01:46:33,940 --> 01:46:35,773
>> ดังนั้นทุกครั้งที่ผมทำงาน
เป็นปัญหาผมเพียง

2143
01:46:35,773 --> 01:46:39,450
จะเน้นและคัดลอกโค้ด
ผมเขียนตัดและวางขึ้นที่นี่

2144
01:46:39,450 --> 01:46:41,370
และแน่นอนเราสามารถ
ประดิษฐ์บางสถานการณ์

2145
01:46:41,370 --> 01:46:43,286
ฟังก์ชั่นที่หนึ่งอาจจะ
ต้องเรียกอีก

2146
01:46:43,286 --> 01:46:46,030
และคุณก็ไม่สามารถใส่ทุก
ฟังก์ชั่นข้างต้นอื่น ๆ ทุกคน

2147
01:46:46,030 --> 01:46:47,930
>> ดังนั้นมันจะเปิดออกมีของ
เป็นทางออกที่ดี

2148
01:46:47,930 --> 01:46:50,100
เราสามารถออกจากนี้จะเป็น

2149
01:46:50,100 --> 01:46:53,677
และตรงไปตรงมาโดยทั่วไปดี
และความสะดวกสบายและการออกแบบที่ดี

2150
01:46:53,677 --> 01:46:56,760
ที่จะนำหลักแรกเพราะอีกครั้ง
หลักเช่นเดียวกับเมื่อธงสีเขียวคลิก

2151
01:46:56,760 --> 01:46:59,027
ที่มีฟังก์ชั่นที่
ได้รับการดำเนินการไปโดยปริยาย

2152
01:46:59,027 --> 01:47:01,110
ดังนั้นคุณอาจจะเป็นดีใส่
ไว้ที่ด้านบนของไฟล์

2153
01:47:01,110 --> 01:47:03,560
เพื่อที่ว่าเมื่อคุณหรือ
อื่น ๆ ของมนุษย์มีลักษณะที่ไฟล์

2154
01:47:03,560 --> 01:47:06,360
คุณรู้ว่าสิ่งที่เกิดขึ้น
เพียงแค่อ่านหลักแรก

2155
01:47:06,360 --> 01:47:15,360
ดังนั้นมันจะเปิดออกเราสามารถบอกเสียงดังกราว
เชิงรุก, Hey, เสียงดังกราวบนสายสี่

2156
01:47:15,360 --> 01:47:17,940
ฉันสัญญาว่าจะดำเนินการ
ฟังก์ชั่นที่เรียกว่าพิมพ์

2157
01:47:17,940 --> 01:47:22,600
ชื่อที่ใช้เรียกชื่อสตริง
เป็น input และผลตอบแทนที่ไม่มีอะไรเป็นโมฆะ

2158
01:47:22,600 --> 01:47:24,770
และฉันจะได้รับรอบเพื่อ
การดำเนินการได้ในภายหลัง

2159
01:47:24,770 --> 01:47:25,680
>> ที่นี่มาหลัก

2160
01:47:25,680 --> 01:47:29,130
ที่สำคัญตอนนี้ในบรรทัด 9 สามารถใช้
พิมพ์ชื่อเพราะเสียงดังกราว

2161
01:47:29,130 --> 01:47:32,600
เป็นที่ไว้วางใจที่สุด
ก็จะพบความหมาย

2162
01:47:32,600 --> 01:47:34,880
การดำเนินงานของชื่อพิมพ์

2163
01:47:34,880 --> 01:47:37,390
ดังนั้นหลังจากการบันทึกไฟล์ของฉันให้
ฉันไปข้างหน้าและทำให้ต้นแบบ

2164
01:47:37,390 --> 01:47:38,498
ดูดีในเวลานี้

2165
01:47:38,498 --> 01:47:43,470
Dot เฉือนต้นแบบให้ฉัน
ไปข้างหน้าและพิมพ์ในชื่อ

2166
01:47:43,470 --> 01:47:48,440
ดาวิดสวัสดีเดวิด Zamila สวัสดี
Zamila และแน่นอนตอนนี้ก็ทำงาน

2167
01:47:48,440 --> 01:47:52,200
>> ดังนั้นส่วนผสมที่นี่คือที่เราได้
ทำให้ฟังก์ชั่นที่กำหนดเองเช่นเดียวกับที่กำหนดเอง

2168
01:47:52,200 --> 01:47:54,219
รอยขีดข่วนบล็อกเราจะเรียกมันว่า

2169
01:47:54,219 --> 01:47:57,010
แต่แตกต่างจากรอยขีดข่วนที่คุณสามารถ
เพียงแค่สร้างมันและเริ่มใช้มัน

2170
01:47:57,010 --> 01:47:59,330
ตอนนี้เราจำเป็นต้องเป็น
เล็ก ๆ น้อย ๆ อวดความรู้มากขึ้น

2171
01:47:59,330 --> 01:48:03,410
และจริงในการฝึกอบรมดังกราว
ที่จะใช้หรือคาดหวังว่ามัน

2172
01:48:03,410 --> 01:48:09,140
ตอนนี้เช่นกันว่าทำไมทุกเวลานี้มี
เรารับเพียงสุ่มสี่สุ่มห้าบนความเชื่อรวมทั้ง

2173
01:48:09,140 --> 01:48:12,170
CS50.h และรวมทั้งมาตรฐาน IO.h?

2174
01:48:12,170 --> 01:48:15,190
>> ดีก็จะเปิดออก
ในหมู่สิ่งอื่น ๆ เพียงไม่กี่

2175
01:48:15,190 --> 01:48:18,550
ทุกสิ่งที่อยู่ในบรรดา dot H
ไฟล์ที่เกิดขึ้นจะเป็นไฟล์

2176
01:48:18,550 --> 01:48:20,460
พวกเขากำลังไฟล์ส่วนหัวเพื่อที่จะพูด

2177
01:48:20,460 --> 01:48:23,270
พวกเขากำลังเขียนยังคงอยู่ในซี แต่
พวกเขากำลังเป็นประเภทที่แตกต่างกันของไฟล์

2178
01:48:23,270 --> 01:48:28,690
>> สำหรับตอนนี้คุณสวยมากสามารถสันนิษฐานได้ว่า
ว่าสิ่งที่อยู่ภายในของ CS50.h

2179
01:48:28,690 --> 01:48:33,360
บางหนึ่งสมุทรเช่นนี้ไม่ได้
สำหรับฟังก์ชั่นที่เรียกว่าพิมพ์ชื่อ

2180
01:48:33,360 --> 01:48:36,840
แต่สำหรับรับ String, Get
Float, และอื่น ๆ น้อย

2181
01:48:36,840 --> 01:48:41,510
และมีต้นแบบที่คล้ายกัน
หนึ่งสมุทรภายในของ IO.h มาตรฐาน

2182
01:48:41,510 --> 01:48:46,241
สำหรับ printf ซึ่งขณะนี้อยู่ใน
ฟังก์ชั่นของตัวเองพิมพ์ชื่อของฉัน

2183
01:48:46,241 --> 01:48:49,490
ดังนั้นในคำอื่น ๆ ตลอดเวลานี้เราได้
รับเพียงแค่สุ่มสี่สุ่มห้าคัดลอกและวาง

2184
01:48:49,490 --> 01:48:51,780
รวมถึงนี้ ได้แก่
ว่าสิ่งที่เกิดขึ้น?

2185
01:48:51,780 --> 01:48:55,310
เหล่านี้เป็นเพียงชนิดของเบาะแส
จะเสียงดังกราวเป็นสิ่งที่ฟังก์ชั่น

2186
01:48:55,310 --> 01:49:00,170
จะจริงดำเนินการเพียง
อื่น ๆ ในไฟล์ที่แตกต่างกัน

2187
01:49:00,170 --> 01:49:02,440
ที่อื่น ๆ บนระบบ

2188
01:49:02,440 --> 01:49:05,160
>> พิมพ์ชื่อดังนั้นเราจึงได้ดำเนินการ

2189
01:49:05,160 --> 01:49:07,910
มันจะมีผลข้างเคียงนี้
พิมพ์บางสิ่งบางอย่างบนหน้าจอ

2190
01:49:07,910 --> 01:49:10,170
แต่มันไม่จริง
มือฉันบางสิ่งบางอย่างกลับมา

2191
01:49:10,170 --> 01:49:12,200
ทำอย่างไรเราจะไปเกี่ยวกับ
การใช้โปรแกรมที่

2192
01:49:12,200 --> 01:49:14,510
ไม่มือฉันบางสิ่งบางอย่างกลับมา?

2193
01:49:14,510 --> 01:49:15,580
>> ดีขอลองนี้

2194
01:49:15,580 --> 01:49:21,360
ให้ฉันไปข้างหน้าและการดำเนินการ
ไฟล์ที่เรียกว่า return.c

2195
01:49:21,360 --> 01:49:24,530
เพื่อให้เราสามารถแสดงให้เห็นถึงวิธีการบางอย่าง
เช่นรับสตริงหรือรับ Int,

2196
01:49:24,530 --> 01:49:27,340
เป็นจริงกลับมา
บางสิ่งบางอย่างกลับไปยังผู้ใช้

2197
01:49:27,340 --> 01:49:29,840
Let 's ไปข้างหน้าและกำหนด int เป็นโมฆะหลัก

2198
01:49:29,840 --> 01:49:33,230
>> และอีกครั้งในอนาคตเราจะ
อธิบายสิ่งที่ int และถือเป็นโมฆะว่า

2199
01:49:33,230 --> 01:49:34,090
คือทำจริง

2200
01:49:34,090 --> 01:49:35,840
แต่สำหรับวันนี้เราจะ
ใช้มันเพื่อรับ

2201
01:49:35,840 --> 01:49:39,970
ฉันจะไปข้างหน้าและ printf,
เพื่อประสบการณ์การใช้งานที่ดี, X คือ

2202
01:49:39,970 --> 01:49:44,360
แล้วฉันจะรอ
ผู้ใช้ที่จะให้ฉันได้รับ X กับ int

2203
01:49:44,360 --> 01:49:48,459
>> แล้วฉันจะไปข้างหน้า
และพิมพ์ x เพื่อตาราง

2204
01:49:48,459 --> 01:49:50,500
ดังนั้นเมื่อคุณมีเพียง
แป้นพิมพ์คนทั่วไป

2205
01:49:50,500 --> 01:49:52,600
ใช้แครอทเล็ก ๆ น้อย ๆ
สัญลักษณ์บนแป้นพิมพ์

2206
01:49:52,600 --> 01:49:55,330
เพื่อเป็นตัวแทนของอำนาจ
ของหรือตัวแทนของ

2207
01:49:55,330 --> 01:49:58,960
ดังนั้น x ยกกำลังสองเป็นปัจจุบันฉัน

2208
01:49:58,960 --> 01:50:00,660
>> และตอนนี้ฉันจะทำเช่นนี้

2209
01:50:00,660 --> 01:50:03,940
ฉันสามารถ do-- สิ่งที่ X
ยกกำลังสอง? X Squared เป็น X X ครั้ง

2210
01:50:03,940 --> 01:50:06,690
>> และเราทำอย่างนี้บาง
เวลาที่ผ่านมาแล้วในวันนี้

2211
01:50:06,690 --> 01:50:08,730
นี้ไม่ได้รู้สึกเหมือน
ทุกสิ่งที่คืบหน้ามาก

2212
01:50:08,730 --> 01:50:09,570
คุณรู้ไหมว่า?

2213
01:50:09,570 --> 01:50:13,100
ลองใช้ประโยชน์จากบางส่วนของความคิดที่ว่า
จากครั้งสุดท้ายของนามธรรม

2214
01:50:13,100 --> 01:50:16,080
>> มันจะไม่ดีถ้า
มีฟังก์ชั่นที่เรียกว่า

2215
01:50:16,080 --> 01:50:18,460
ตารางที่ไม่ตรงกับที่?

2216
01:50:18,460 --> 01:50:20,640
มันก็ยังคงที่ส่วนท้ายของ
วันไม่คณิตศาสตร์เดียวกัน

2217
01:50:20,640 --> 01:50:22,410
แต่ขอเป็นนามธรรม
ออกไปความคิดของการ

2218
01:50:22,410 --> 01:50:25,280
จำนวนหนึ่งคูณด้วย
อื่นและเพียงแค่ให้มันชื่อ

2219
01:50:25,280 --> 01:50:27,360
เช่นตารางค่านี้

2220
01:50:27,360 --> 01:50:29,560
>> และในคำอื่น ๆ
C, ขอสร้างฟังก์ชั่น

2221
01:50:29,560 --> 01:50:32,660
เรียกว่าตารางที่ไม่ตรงกับที่

2222
01:50:32,660 --> 01:50:34,600
มันจะถูกเรียกว่าตาราง

2223
01:50:34,600 --> 01:50:35,790
มันเป็นไปได้ที่จะใช้เป็น int

2224
01:50:35,790 --> 01:50:37,820
และเราจะจะเพียง
เรียกว่า n โดยค่าเริ่มต้น

2225
01:50:37,820 --> 01:50:39,403
>> แต่เราสามารถเรียกมันว่าอะไรที่เราต้องการ

2226
01:50:39,403 --> 01:50:42,900
และสิ่งที่มันเป็นไป
ทำอย่างแท้จริงคือการกลับไป

2227
01:50:42,900 --> 01:50:45,810
ผลครั้งที่ n n

2228
01:50:45,810 --> 01:50:48,980
แต่เพราะมันเป็น
บางสิ่งบางอย่างกลับมาซึ่ง

2229
01:50:48,980 --> 01:50:53,690
คำหลักคือสีม่วงเราได้
ไม่เคยเห็นมาก่อนผมในบรรทัดที่ 11

2230
01:50:53,690 --> 01:50:55,410
ไม่สามารถเพียงแค่บอกว่าเวลานี้เป็นโมฆะ

2231
01:50:55,410 --> 01:51:01,320
>> เป็นโมฆะในตัวอย่างที่เราเพิ่งเห็น
แทนการพิมพ์ชื่อเพียงหมายความว่า

2232
01:51:01,320 --> 01:51:02,190
ทำอะไรสักอย่าง.

2233
01:51:02,190 --> 01:51:04,170
แต่ไม่ได้มือฉันบางสิ่งบางอย่างกลับมา

2234
01:51:04,170 --> 01:51:06,790
ในกรณีนี้ผมไม่ต้องการ
เพื่อกลับ n N ครั้ง

2235
01:51:06,790 --> 01:51:08,460
หรืออะไรก็ตามที่เป็นตัวเลขที่

2236
01:51:08,460 --> 01:51:12,460
>> ดังนั้นผมจึงไม่สามารถพูดได้, Hey, คอมพิวเตอร์,
เราจะกลับมาไม่มีอะไรเป็นโมฆะ

2237
01:51:12,460 --> 01:51:16,166
มันจะกลับมาโดยธรรมชาติเป็น int

2238
01:51:16,166 --> 01:51:17,790
และเพื่อให้เป็นสิ่งที่เกิดขึ้นที่นี่

2239
01:51:17,790 --> 01:51:20,070
>> การป้อนข้อมูลตาราง
เป็นไปได้เป็น int

2240
01:51:20,070 --> 01:51:24,760
และเพื่อให้เราสามารถใช้มันก็มีการ
มีชื่อเอ็นมันจะเอาท์พุท

2241
01:51:24,760 --> 01:51:26,240
เป็น int ที่ไม่จำเป็นต้องชื่อ

2242
01:51:26,240 --> 01:51:29,590
เราสามารถที่จะปล่อยให้มันเป็นหลักหรือใครก็ตามที่อยู่
ใช้ผมจะจำค่านี้ถ้าเรา

2243
01:51:29,590 --> 01:51:31,120
ต้องการกับตัวแปรของตัวเอง

2244
01:51:31,120 --> 01:51:33,230
>> และอีกครั้งใหม่เท่านั้น
คำหลักที่นี่คือการกลับไป

2245
01:51:33,230 --> 01:51:34,480
และฉันแค่ทำคณิตศาสตร์บาง

2246
01:51:34,480 --> 01:51:41,825
ถ้าผมอยากจะเป็นที่ไม่จำเป็น
ผมอาจจะบอกว่าสินค้าที่ได้รับครั้ง int n n

2247
01:51:41,825 --> 01:51:44,170
>> และจากนั้นผมอาจจะบอกว่าผลิตภัณฑ์กลับ

2248
01:51:44,170 --> 01:51:47,360
แต่อีกครั้งไปยังจุดของฉันก่อนหน้านี้
เพียงแค่นี้ไม่เป็น design-- ดี

2249
01:51:47,360 --> 01:51:50,060
เช่นทำไมแนะนำชื่อ
สัญลักษณ์เช่นผลิตภัณฑ์

2250
01:51:50,060 --> 01:51:51,570
เพียงเพื่อให้ทันทีกลับได้หรือไม่

2251
01:51:51,570 --> 01:51:53,670
มันทำความสะอาดเล็ก ๆ น้อย ๆ
เล็ก ๆ น้อย ๆ ที่เข้มงวดมากขึ้นเพื่อให้

2252
01:51:53,670 --> 01:51:59,380
จะพูดเพียงเพื่อบอกว่าการกลับมาครั้ง n
N, ได้รับการกำจัดของสายนี้โดยสิ้นเชิง

2253
01:51:59,380 --> 01:52:02,860
>> และมันก็เป็นรหัสเพียงน้อยที่จะอ่าน
โอกาสน้อยสำหรับความผิดพลาด

2254
01:52:02,860 --> 01:52:05,180
และขอให้ดูว่านี้
ตอนนี้ทำงานจริง

2255
01:52:05,180 --> 01:52:09,380
ตอนนี้ฉันจะไป
ข้างหน้าและให้ผลตอบแทน

2256
01:52:09,380 --> 01:52:11,460
>> อ๊ะประกาศโดยนัยของฟังก์ชั่น

2257
01:52:11,460 --> 01:52:14,080
ฉันทำผิดพลาดนี้ก่อนที่จะไม่มีเรื่องใหญ่

2258
01:52:14,080 --> 01:52:18,950
ผมขอเพียงแค่พิมพ์หรือเน้นและ
คัดลอกแน่นอนฟังก์ชั่นต้นแบบเดียวกัน

2259
01:52:18,950 --> 01:52:21,342
หรือลายเซ็นของฟังก์ชั่นได้ที่นี่

2260
01:52:21,342 --> 01:52:22,800
หรือฉันจะย้ายทั้งฟังก์ชั่น

2261
01:52:22,800 --> 01:52:23,841
>> แต่ที่ขี้เกียจเล็กน้อย

2262
01:52:23,841 --> 01:52:24,870
ดังนั้นเราจะไม่ทำอย่างนั้น

2263
01:52:24,870 --> 01:52:27,960
ตอนนี้ให้ฉันทำให้ผลตอบแทน
อีกครั้งกลับมาเฉือนจุด

2264
01:52:27,960 --> 01:52:32,790
>> X คือ 2 x ยกกำลัง 4
X คือ 3 x ยกกำลัง 9

2265
01:52:32,790 --> 01:52:35,300
และฟังก์ชั่นที่ดูเหมือนว่า
ตอนนี้ที่จะได้ทำงาน

2266
01:52:35,300 --> 01:52:36,550
ดังนั้นสิ่งที่แตกต่างกันที่นี่?

2267
01:52:36,550 --> 01:52:42,520
ฉันมีฟังก์ชั่นที่เรียกว่าสี่เหลี่ยม
ในกรณีนี้ซึ่งผมใส่ในการป้อนข้อมูล

2268
01:52:42,520 --> 01:52:43,830
และผมได้รับกลับมาส่งออก

2269
01:52:43,830 --> 01:52:46,210
และยังก่อนหน้านี้ถ้า
ฉันเปิดตัวอย่างอื่น ๆ

2270
01:52:46,210 --> 01:52:51,640
จากก่อนหน้านี้ที่
ถูกเรียก prototype.c,

2271
01:52:51,640 --> 01:52:54,770
ผมมีชื่อพิมพ์ซึ่ง
กลับเป็นโมฆะเพื่อที่จะพูด

2272
01:52:54,770 --> 01:52:58,730
หรือมันกลับไม่มีอะไรและ
ก็มีผลข้างเคียง

2273
01:52:58,730 --> 01:53:00,230
>> ดังนั้นสิ่งที่เกิดขึ้นที่นี่?

2274
01:53:00,230 --> 01:53:03,520
ดีพิจารณาฟังก์ชัน
ได้รับสตริงเพื่อรอสักครู่

2275
01:53:03,520 --> 01:53:06,570
เราได้ใช้ฟังก์ชั่น
ได้รับสตริงในลักษณะดังต่อไปนี้

2276
01:53:06,570 --> 01:53:10,464
>> ที่เราเคยมีฟังก์ชั่นได้รับ
สตริงเช่น ได้แก่ CS50.h,

2277
01:53:10,464 --> 01:53:16,624
รวมถึงมาตรฐาน IO.h, int หลักเป็นโมฆะ

2278
01:53:16,624 --> 01:53:18,790
แล้วทุกครั้งที่ผมได้
เรียกว่าสตริงป่านนี้

2279
01:53:18,790 --> 01:53:23,260
ฉันได้กล่าวว่าสิ่งที่ต้องการสตริง
ได้รับได้รับสายเพราะได้รับ string--

2280
01:53:23,260 --> 01:53:27,880
ขอเรียกสตริงได้รับนี้ get.c--
ตัวเองกลับสตริงที่ฉันสามารถแล้ว

2281
01:53:27,880 --> 01:53:32,050
การใช้งานและพูดว่าสวัสดีจุลภาค
ร้อยละ S, ทับขวา n, s

2282
01:53:32,050 --> 01:53:35,660
>> ดังนั้นนี่คือตัวอย่างเช่นเดียวกัน
จริงๆที่เรามีก่อนหน้านี้

2283
01:53:35,660 --> 01:53:37,920
เพื่อให้ได้รับสตริงส่งกลับค่า

2284
01:53:37,920 --> 01:53:41,260
แต่ช่วงเวลาที่ผ่านมาสายการพิมพ์
ไม่คืนค่า

2285
01:53:41,260 --> 01:53:42,721
มันก็มีผลข้างเคียง

2286
01:53:42,721 --> 01:53:44,220
ดังนั้นนี่คือความแตกต่างพื้นฐาน

2287
01:53:44,220 --> 01:53:46,710
เราได้เห็นที่แตกต่างกัน
ประเภทฟังก์ชั่นในขณะนี้

2288
01:53:46,710 --> 01:53:49,490
ซึ่งบางส่วนได้กลับมา
ค่านิยมบางอย่างที่ทำไม่ได้

2289
01:53:49,490 --> 01:53:51,890
ดังนั้นอาจจะเป็นสตริงหรือ int หรือลอย

2290
01:53:51,890 --> 01:53:53,480
หรืออาจจะเป็นเพียงความว่างเปล่า

2291
01:53:53,480 --> 01:53:55,710
>> และความแตกต่างคือ
ที่ฟังก์ชั่นเหล่านี้ที่

2292
01:53:55,710 --> 01:53:59,940
ได้รับข้อมูลและคืนค่าเป็นจริง
นำบางสิ่งบางอย่างกลับไปที่โต๊ะ

2293
01:53:59,940 --> 01:54:01,110
เพื่อที่จะพูด

2294
01:54:01,110 --> 01:54:03,710
ดังนั้นขอให้ไปข้างหน้าและ
มองไปที่ชุดสุดท้ายหนึ่ง

2295
01:54:03,710 --> 01:54:09,129
ตัวอย่างที่ให้ความรู้สึกตอนนี้
วิธีที่เราอาจแน่นอนนามธรรมที่ดีกว่า

2296
01:54:09,129 --> 01:54:11,670
และดีกว่าและดีกว่าหรือมากกว่า
และมากขึ้นและมากขึ้นในการสั่งซื้อ

2297
01:54:11,670 --> 01:54:13,810
ที่จะเขียนในที่สุดรหัสที่ดีกว่า

2298
01:54:13,810 --> 01:54:16,860
Let 's ไปข้างหน้าและในจิตวิญญาณ
รอยขีดข่วนทำต่อไปนี้

2299
01:54:16,860 --> 01:54:21,700
>> ให้ฉันไปข้างหน้าและรวมถึง
CS50.h และมาตรฐาน IO.h.

2300
01:54:21,700 --> 01:54:24,010
ให้ฉันไปข้างหน้าและให้
ตัวเองเป็น int หลักเป็นโมฆะ

2301
01:54:24,010 --> 01:54:27,380
และแจ้งให้เราไปข้างหน้าโทร cough.c นี้

2302
01:54:27,380 --> 01:54:35,510
>> และแจ้งให้เราไปข้างหน้าและเพียง
เช่นรอยขีดข่วนพิมพ์ออกไอ / n

2303
01:54:35,510 --> 01:54:37,170
และฉันต้องการที่จะทำเช่นนี้สามครั้ง

2304
01:54:37,170 --> 01:54:39,670
ดังนั้นฉันแน่นอนแค่ไป
คัดลอกและวางสามครั้ง

2305
01:54:39,670 --> 01:54:46,440
ตอนนี้ผมกำลังจะทำ
ไอดอทเฉือนไอ

2306
01:54:46,440 --> 01:54:50,120
ขอให้ตัวเองเป็นห้องเล็ก ๆ น้อย ๆ
นี่ใส่ไอไอ, ไอ

2307
01:54:50,120 --> 01:54:53,970
>> นอกจากนี้เห็นได้ชัดแล้ว
โอกาสในการปรับปรุง

2308
01:54:53,970 --> 01:54:55,679
ผมได้คัดลอกและวาง
ไม่กี่ครั้งในวันนี้

2309
01:54:55,679 --> 01:54:58,261
แต่นั่นก็เป็นเพียงดังนั้นฉันไม่ได้
ต้องพิมพ์ตัวอักษรเป็นจำนวนมาก

2310
01:54:58,261 --> 01:55:00,250
ฉันยังคงมีการเปลี่ยนแปลงสิ่งที่
เส้นที่มีรหัส

2311
01:55:00,250 --> 01:55:04,240
>> ทั้งสามเส้นเหมือนกัน
ที่รู้สึกขี้เกียจและแน่นอนมี

2312
01:55:04,240 --> 01:55:07,110
และอาจจะไม่ได้เป็นวิธีการที่เหมาะสม

2313
01:55:07,110 --> 01:55:11,029
ดังนั้นกับสิ่งที่ส่วนผสม
เราสามารถปรับปรุงรหัสนี้หรือไม่?

2314
01:55:11,029 --> 01:55:12,570
เราไม่ได้มีการคัดลอกและวางโค้ด

2315
01:55:12,570 --> 01:55:15,070
>> และแน่นอนทุกครั้งที่คุณรู้สึก
ด้วยตัวคุณเองคัดลอกและวาง,

2316
01:55:15,070 --> 01:55:17,700
และไม่ได้เปลี่ยนรหัส
อัตราต่อรองจะมีวิธีที่ดีกว่า

2317
01:55:17,700 --> 01:55:19,470
และแน่นอนมี

2318
01:55:19,470 --> 01:55:22,510
ให้ฉันไปข้างหน้าและทำห่วง
แม้ว่าไวยากรณ์อาจจะไม่

2319
01:55:22,510 --> 01:55:24,570
มาตามธรรมชาติเลย

2320
01:55:24,570 --> 01:55:29,494
>> ทำเช่นนี้สามครั้งเพียงแค่
โดยการทำ following--

2321
01:55:29,494 --> 01:55:31,160
และผมก็เพิ่งรู้เรื่องนี้จากการปฏิบัติ

2322
01:55:31,160 --> 01:55:32,810
แต่เรามีจำนวนตัวอย่างในขณะนี้

2323
01:55:32,810 --> 01:55:34,950
และคุณจะเห็นออนไลน์
ยังคงอ้างอิงเพิ่มเติม

2324
01:55:34,950 --> 01:55:37,790
>> นี่คือไวยากรณ์ในบรรทัดที่ 6 ที่
เหมือนรอยขีดข่วนที่ซ้ำ

2325
01:55:37,790 --> 01:55:40,090
บล็อกทำซ้ำสามครั้งต่อไป

2326
01:55:40,090 --> 01:55:41,340
มันมีมนต์ขลังเล็ก ๆ น้อย ๆ สำหรับตอนนี้

2327
01:55:41,340 --> 01:55:43,050
แต่นี้จะได้รับมากขึ้น
และมีความคุ้นเคยมากขึ้น

2328
01:55:43,050 --> 01:55:45,050
>> และก็จะต้องทำซ้ำ
สายแปดสามครั้ง

2329
01:55:45,050 --> 01:55:52,390
เพื่อที่ว่าถ้าผมรวบรวมอีกครั้งทำให้ไอ
จุดเฉือนไอ, ไอ, ไอ, ไอ

2330
01:55:52,390 --> 01:55:54,030
มันก็ยังคงทำงานในลักษณะเดียวกัน

2331
01:55:54,030 --> 01:55:55,550
ดังนั้นนั่นคือทั้งหมดที่ดีและดี

2332
01:55:55,550 --> 01:55:58,200
แต่ที่ไม่ใจลอยมาก

2333
01:55:58,200 --> 01:55:59,371
>> มันเป็นเรื่องที่ถูกต้องได้อย่างสมบูรณ์แบบ

2334
01:55:59,371 --> 01:56:01,370
แต่มันให้ความรู้สึกเหมือนมี
อาจจะมีโอกาส

2335
01:56:01,370 --> 01:56:03,750
เช่นเดียวกับในโลกของ
รอยขีดข่วนกับชนิดของการเริ่มต้น

2336
01:56:03,750 --> 01:56:07,530
เพื่อเพิ่มความหมายบางอย่างที่นี่เพื่อให้
ผมไม่เพียงแค่มีบางอย่างสำหรับห่วง

2337
01:56:07,530 --> 01:56:09,867
และฟังก์ชั่นที่บอกว่า
ไอหรือไม่ไอ

2338
01:56:09,867 --> 01:56:10,450
คุณรู้ไหมว่า?

2339
01:56:10,450 --> 01:56:12,620
ให้ฉันพยายามที่จะเป็น
เย็นน้อยกว่านั้น

2340
01:56:12,620 --> 01:56:16,090
และที่จริงเขียนฟังก์ชั่นที่
มีผลข้างเคียงบางอย่างเรียกว่าไอ

2341
01:56:16,090 --> 01:56:20,830
>> และจะใช้เวลาไม่มีการป้อนข้อมูลและ
ไม่มีการคืนค่าเป็นผลผลิต

2342
01:56:20,830 --> 01:56:22,680
แต่คุณรู้ว่าสิ่งที่มันไม่?

2343
01:56:22,680 --> 01:56:29,370
มันไม่ printf this--,
อ้างนำมาอ้างไอ

2344
01:56:29,370 --> 01:56:32,380
>> และตอนนี้ขึ้นที่นี่ฉันจะ
ไปข้างหน้าและสำหรับ int,

2345
01:56:32,380 --> 01:56:36,070
ฉันได้รับเป็นศูนย์ผมน้อยกว่า 3 ผมบวกบวก

2346
01:56:36,070 --> 01:56:39,770
ฉันจะไม่ทำ printf ซึ่งเป็น
เนื้อหาการดำเนินงานในระดับต่ำ

2347
01:56:39,770 --> 01:56:40,270
รายละเอียด

2348
01:56:40,270 --> 01:56:41,353
ฉันไม่สนใจวิธีการไอ

2349
01:56:41,353 --> 01:56:43,240
ผมแค่อยากจะใช้ฟังก์ชั่นไอ

2350
01:56:43,240 --> 01:56:44,840
และฉันแค่จะเรียกอาการไอ

2351
01:56:44,840 --> 01:56:46,204
>> ตอนนี้ทราบขั้ว

2352
01:56:46,204 --> 01:56:49,370
เมื่อคุณเรียกใช้ฟังก์ชันถ้าคุณทำไม่ได้
ต้องการที่จะให้มันปัจจัยการผลิตทั้งหมดที่ดี

2353
01:56:49,370 --> 01:56:51,780
เพียงแค่ทำวงเล็บเปิดปิด
วงเล็บและคุณทำเสร็จแล้ว

2354
01:56:51,780 --> 01:56:56,271
>> เมื่อคุณกำหนดฟังก์ชั่นหรือ
ประกาศต้นแบบฟังก์ชั่นของการ

2355
01:56:56,271 --> 01:56:58,770
ถ้าคุณรู้ล่วงหน้าก็ไม่ได้
จะใช้ข้อโต้แย้งใด ๆ

2356
01:56:58,770 --> 01:57:01,170
บอกว่าเป็นโมฆะในวงเล็บนั้นไม่มี

2357
01:57:01,170 --> 01:57:05,660
และที่ทำให้แน่ใจว่าคุณ
จะไม่ได้ตั้งใจมันในทางที่ผิด

2358
01:57:05,660 --> 01:57:07,020
ให้ฉันไปข้างหน้าและทำให้ไอ

2359
01:57:07,020 --> 01:57:08,540
และแน่นอนผมเคยทำผิดพลาด

2360
01:57:08,540 --> 01:57:10,410
>> บ้ามีว่า
ประกาศโดยปริยาย

2361
01:57:10,410 --> 01:57:11,325
แต่ที่ดี

2362
01:57:11,325 --> 01:57:12,590
มันแก้ไขได้ง่าย

2363
01:57:12,590 --> 01:57:18,240
ฉันเพียงแค่ต้องต้นแบบที่สูงขึ้น
ในแฟ้มของฉันกว่าฉันจริงใช้มัน

2364
01:57:18,240 --> 01:57:20,070
>> ดังนั้นตอนนี้ให้ฉันให้ไออีกครั้งดี

2365
01:57:20,070 --> 01:57:20,790
ตอนนี้ก็ทำงาน

2366
01:57:20,790 --> 01:57:22,930
ทำให้ไอ, ไอ, ไอ, ไอ

2367
01:57:22,930 --> 01:57:25,930
ดังนั้นคุณอาจจะคิดว่าเรากำลังจริงๆ
เพียงวิศวกรรมปัญหานี้

2368
01:57:25,930 --> 01:57:26,763
และแน่นอนเรามี

2369
01:57:26,763 --> 01:57:28,870
นี้ไม่ได้เป็นสิ่งที่ดี
ผู้สมัครของโปรแกรม

2370
01:57:28,870 --> 01:57:31,930
ในขณะที่สำหรับ
refactoring และทำในสิ่งที่เป็น

2371
01:57:31,930 --> 01:57:35,645
เรียกว่าการสลายตัวตามลำดับชั้น
ที่คุณใช้โค้ดบางส่วนแล้ว

2372
01:57:35,645 --> 01:57:38,790
คุณชนิดของปัจจัยสิ่งที่ออกเพื่อให้เป็น
ให้เหตุผลความหมายมากขึ้นกับพวกเขา

2373
01:57:38,790 --> 01:57:40,930
และนำมาใช้มันในระยะท้ายที่สุดอีกต่อไป

2374
01:57:40,930 --> 01:57:43,490
แต่มันเป็นกลุ่มอาคารที่มีต่อ
โปรแกรมที่มีความซับซ้อนมากขึ้น

2375
01:57:43,490 --> 01:57:45,600
ว่าเราจะเริ่มต้น
เขียนก่อนนานแล้วว่า

2376
01:57:45,600 --> 01:57:50,090
ช่วยให้เรามีคำศัพท์
ด้วยซึ่งในการเขียนโค้ดที่ดีกว่า

2377
01:57:50,090 --> 01:57:52,920
และแน่นอนเราจะมาดูว่าเรา
ไม่สามารถพูดคุยต่อไปนี้

2378
01:57:52,920 --> 01:57:57,984
>> ดูเหมือนว่าง่อยเล็ก ๆ น้อย ๆ ที่ผมหลัก
จำเป็นต้องกังวลเกี่ยวสาปนี้ได้ห่วง

2379
01:57:57,984 --> 01:57:59,400
และเรียกไออีกครั้งและอีกครั้ง

2380
01:57:59,400 --> 01:58:03,050
ทำไมฉันไม่สามารถเพียงแค่บอกไอ
กรุณาไอสามครั้ง

2381
01:58:03,050 --> 01:58:08,170
ในคำอื่น ๆ ทำไมฉันไม่สามารถเพียงแค่
ให้เข้ากับไอและทำเช่นนี้?

2382
01:58:08,170 --> 01:58:11,270
>> ทำไมฉันไม่สามารถเพียงแค่พูดใน
ไอหลักสามครั้ง

2383
01:58:11,270 --> 01:58:13,150
และตอนนี้เป็นชนิดที่มีมนต์ขลังของ

2384
01:58:13,150 --> 01:58:14,540
มันซ้ำแล้วซ้ำอีกมากที่นี่

2385
01:58:14,540 --> 01:58:15,940
และมันก็เป็นจริงขั้นตอนทารก

2386
01:58:15,940 --> 01:58:19,250
>> แต่ความสามารถในการพูด
สายแปดไอสามครั้ง

2387
01:58:19,250 --> 01:58:20,730
มันเป็นเพียงเพื่อให้สามารถอ่านได้มากขึ้น

2388
01:58:20,730 --> 01:58:24,210
และบวกกับผมไม่ต้องรู้ว่า
หรือวิธีการดูแลที่ไอจะดำเนินการ

2389
01:58:24,210 --> 01:58:26,460
และแน่นอนในภายหลัง
ระยะและโครงการสุดท้าย

2390
01:58:26,460 --> 01:58:29,150
ถ้าคุณรับมือกับโครงการที่มี
เพื่อนร่วมชั้นหรือสองเพื่อนร่วมชั้น

2391
01:58:29,150 --> 01:58:32,370
คุณจะรู้ว่าคุณกำลังจะไป
ต้องหรือต้องการที่จะแบ่งการทำงาน

2392
01:58:32,370 --> 01:58:34,650
>> และคุณจะต้องการที่จะตัดสินใจ
ล่วงหน้าว่าใครจะทำอะไร

2393
01:58:34,650 --> 01:58:35,483
และในชิ้น?

2394
01:58:35,483 --> 01:58:37,520
และมันจะไม่ดี
ถ้าคุณตัวอย่างเช่น

2395
01:58:37,520 --> 01:58:40,100
ใช้ค่าใช้จ่ายของการเขียนหลักทำ

2396
01:58:40,100 --> 01:58:43,470
และเพื่อนร่วมห้องของคุณหรือของคุณ
พันธมิตรมากกว่าปกติ

2397
01:58:43,470 --> 01:58:45,230
ดูแลการดำเนินการไอ

2398
01:58:45,230 --> 01:58:49,540
>> และกองนี้เหล่านี้
ผนังของนามธรรม

2399
01:58:49,540 --> 01:58:52,310
หรือชั้นของนามธรรมถ้า
คุณจะมีพลังซุปเปอร์

2400
01:58:52,310 --> 01:58:55,480
เพราะโดยเฉพาะอย่างยิ่งที่มีขนาดใหญ่
โปรแกรมที่ซับซ้อนมากขึ้นและระบบ

2401
01:58:55,480 --> 01:59:00,070
มันจะช่วยให้คนหลายคนที่จะสร้าง
สิ่งที่ร่วมกันและในที่สุด

2402
01:59:00,070 --> 01:59:02,680
ตะเข็บทำงานของพวกเขาร่วมกันในลักษณะนี้

2403
01:59:02,680 --> 01:59:05,332
แต่แน่นอนเรา
จำเป็นที่จะต้องแก้ไขในขณะนี้ไอ

2404
01:59:05,332 --> 01:59:07,290
เราจำเป็นต้องบอกไอ
ว่าเดี๋ยวก่อนคุณรู้อะไรไหม

2405
01:59:07,290 --> 01:59:11,230
คุณจะต้องใช้เวลา
input-- จึงไม่เป็นโมฆะ แต่ int และตอนนี้

2406
01:59:11,230 --> 01:59:15,170
Let 's ไปข้างหน้าและใส่ลงไปใน
ไอนั้น int ฉันได้รับเป็นศูนย์

2407
01:59:15,170 --> 01:59:16,890
>> ฉันมีค่าน้อยกว่ากี่ครั้ง

2408
01:59:16,890 --> 01:59:18,550
ผมบอกว่าสามก่อน

2409
01:59:18,550 --> 01:59:20,420
แต่นั่นไม่ใช่สิ่งที่ฉันต้องการ

2410
01:59:20,420 --> 01:59:25,520
ฉันต้องการที่จะได้รับไอทั่วไปเพื่อ
สนับสนุนจำนวนซ้ำใด ๆ

2411
01:59:25,520 --> 01:59:28,800
>> ดังนั้นแน่นอนมันเป็น n ที่ฉันต้องการ
สิ่งที่ผู้ใช้บอกฉัน

2412
01:59:28,800 --> 01:59:31,620
ตอนนี้ผมสามารถไปข้างหน้าและพูดว่าไอพิมพ์

2413
01:59:31,620 --> 01:59:34,750
และไม่ว่าสิ่งจำนวน
ผู้ใช้ผ่านใน

2414
01:59:34,750 --> 01:59:36,890
ผมจะย้ำว่าหลายครั้ง

2415
01:59:36,890 --> 01:59:39,160
>> ดังนั้นในตอนท้ายของวัน
โปรแกรมเป็นเหมือนกัน

2416
01:59:39,160 --> 01:59:42,820
แต่สังเกตเห็นทั้งหมดของสิ่งนี้
แม้อาจจะอยู่ในแฟ้มอื่น

2417
01:59:42,820 --> 01:59:45,620
อันที่จริงผมไม่ทราบว่าที่
ขณะที่วิธีการที่จะดำเนินการ printf

2418
01:59:45,620 --> 01:59:47,980
>> ผมไม่ทราบว่าในขณะที่วิธีการที่จะได้รับ
สตริงหรือได้รับ int หรือได้รับลอย

2419
01:59:47,980 --> 01:59:48,646
จะดำเนินการ

2420
01:59:48,646 --> 01:59:50,930
และผมไม่ต้องการที่จะ
เห็นพวกเขาในหน้าจอของฉัน

2421
01:59:50,930 --> 01:59:55,320
มันเป็นฉันเริ่มที่จะมุ่งเน้นไปที่
โปรแกรมของฉันไม่ได้ฟังก์ชั่นเหล่านั้น

2422
01:59:55,320 --> 01:59:59,070
>> ดังนั้นแน่นอนทันทีที่คุณ
เริ่มต้นรหัสเช่นนี้แฟออก

2423
01:59:59,070 --> 02:00:01,397
เรายังสามารถย้ายไอ
เป็นไฟล์แยกกันได้อย่างไร

2424
02:00:01,397 --> 02:00:02,730
คนอื่นอาจจะใช้มัน

2425
02:00:02,730 --> 02:00:06,810
และคุณและโปรแกรมของคุณกลายเป็น
สวยงามมากและสามารถอ่านได้มาก

2426
02:00:06,810 --> 02:00:10,830
เนื้อหาจริงๆสี่
โปรแกรมบรรทัดที่นั่น

2427
02:00:10,830 --> 02:00:13,510
>> ดังนั้นขอให้ไปข้างหน้าในขณะนี้
และทำให้หนึ่งในการเปลี่ยนแปลงมากขึ้น

2428
02:00:13,510 --> 02:00:16,180
ขอให้สังเกตว่าต้นแบบของฉัน
มีการเปลี่ยนแปลงขึ้นด้านบน

2429
02:00:16,180 --> 02:00:18,390
ดังนั้นขอให้ฉันแก้ไขปัญหาที่ทำให้
ฉันไม่ได้รับการตะโกนใส่

2430
02:00:18,390 --> 02:00:22,580
>> ทำให้ไอให้ฉันทำงานไอครั้งเดียว
อื่น ๆ อีกมากมายที่ยังคงทำในสิ่งเดียวกัน

2431
02:00:22,580 --> 02:00:26,010
แต่ตอนนี้ทราบเรามี
ส่วนผสมสำหรับรุ่นสุดท้าย

2432
02:00:26,010 --> 02:00:26,940
คุณรู้ไหมว่า?

2433
02:00:26,940 --> 02:00:29,040
ฉันไม่ได้ต้องการเพียงแค่ไอจำเป็นต้อง

2434
02:00:29,040 --> 02:00:30,802
ฉันต้องการจะมีบางสิ่งบางอย่างที่กว้างขึ้น

2435
02:00:30,802 --> 02:00:31,510
เพื่อให้คุณรู้อะไรไหม

2436
02:00:31,510 --> 02:00:32,450
ผมต้องการที่จะทำเช่นนี้

2437
02:00:32,450 --> 02:00:37,140
ฉันต้องการจะมีมากเช่นรอยขีดข่วน
ไม่บล็อกพูด แต่ไม่ได้เป็นเพียง

2438
02:00:37,140 --> 02:00:38,680
พูดอะไรบางอย่างจำนวนครั้งบาง

2439
02:00:38,680 --> 02:00:41,510
ฉันต้องการที่จะพูดสตริงที่เฉพาะเจาะจงมาก

2440
02:00:41,510 --> 02:00:43,850
และดังนั้นฉันทำไม่ได้
ต้องการให้เพียงแค่พูดว่าไอ

2441
02:00:43,850 --> 02:00:47,660
ฉันต้องการที่จะพูดอะไรก็ตาม
สตริงจะถูกส่งใน

2442
02:00:47,660 --> 02:00:49,960
>> ดังนั้นสังเกตเห็นฉันได้ทั่วไป
นี้เพื่อให้ในขณะนี้

2443
02:00:49,960 --> 02:00:53,110
พูดความรู้สึกเหมือนเป็นชื่อที่ดี
สำหรับเรื่องนี้เหมือนเกา

2444
02:00:53,110 --> 02:00:55,530
ใช้เวลาสองขัดแย้งแตกต่างจากรอยขีดข่วน

2445
02:00:55,530 --> 02:00:56,570
หนึ่งคือสตริง

2446
02:00:56,570 --> 02:00:57,300
หนึ่งคือเป็น int

2447
02:00:57,300 --> 02:00:58,130
>> และฉันจะเปลี่ยนพวกเขา

2448
02:00:58,130 --> 02:01:00,713
ฉันเพียงแค่ชนิดเช่นความคิดของ
พูดสตริงแรกแล้ว

2449
02:01:00,713 --> 02:01:01,940
กี่ครั้งในภายหลัง

2450
02:01:01,940 --> 02:01:03,970
เป็นโมฆะหมายความว่ามันยังคง
ไม่เกิดสิ่งใด

2451
02:01:03,970 --> 02:01:06,428
เหล่านี้เป็นเพียงภาพด้านข้าง
ผลกระทบเช่นเดียวกับ [? จอร์แดน?]

2452
02:01:06,428 --> 02:01:08,240
ผลข้างเคียงทางวาจาตะโกน

2453
02:01:08,240 --> 02:01:12,630
ก็ยังไม่เท่าสิ่งที่ N,
0 ถึง แต่ไม่เท่ากับ n

2454
02:01:12,630 --> 02:01:14,540
ซึ่งหมายความ N ครั้งรวม

2455
02:01:14,540 --> 02:01:16,540
แล้วก็พิมพ์ออกมา
สิ่งที่เป็นสตริง

2456
02:01:16,540 --> 02:01:19,060
ดังนั้นผมจึงได้ทั่วไปจริงๆ
บรรทัดของรหัสนี้

2457
02:01:19,060 --> 02:01:22,460
ดังนั้นตอนนี้ฉันจะดำเนินการ
ฟังก์ชั่นไอ?

2458
02:01:22,460 --> 02:01:25,520
>> ฉันจะทำไอโมฆะ

2459
02:01:25,520 --> 02:01:28,501
และฉันยังคงสามารถใช้ในวิธีการ
หลายครั้งคุณต้องการที่จะมีอาการไอ

2460
02:01:28,501 --> 02:01:29,250
แต่คุณรู้อะไรไหม

2461
02:01:29,250 --> 02:01:31,240
ตอนนี้ผมสามารถที่จะพูดถ่อ

2462
02:01:31,240 --> 02:01:36,540
>> ฉันจะโทรบอกด้วย
ไอคำผ่านใน n

2463
02:01:36,540 --> 02:01:40,410
และถ้าผมต้องการที่จะยังใช้
เพียงเพื่อความสนุกสนานฟังก์ชั่นจาม

2464
02:01:40,410 --> 02:01:42,290
ฉันสามารถจามจำนวนครั้งบาง

2465
02:01:42,290 --> 02:01:47,300
และฉันสามารถให้การนำ n เพราะ
ทราบเมตรในบริบทนี้หรือขอบเขตที่

2466
02:01:47,300 --> 02:01:49,470
มีอยู่เพียงภายในฟังก์ชั่นนี้

2467
02:01:49,470 --> 02:01:52,767
>> n และในบริบทนี้เท่านั้น
มีอยู่ในฟังก์ชั่นนี้ได้ที่นี่

2468
02:01:52,767 --> 02:01:54,600
ดังนั้นเราจะกลับไปมา
ปัญหาเหล​​่านี้ของขอบเขต

2469
02:01:54,600 --> 02:02:01,160
และที่นี่ฉันแค่ไปที่จะพูดว่า
Achoo แล้วครั้ง N กึ่งลำไส้ใหญ่

2470
02:02:01,160 --> 02:02:04,340
>> และตอนนี้ผมก็ต้องไปขอยืม
ฟังก์ชั่นเหล่านี้ลายเซ็นขึ้นที่นี่

2471
02:02:04,340 --> 02:02:06,290
ดังนั้นไอถูกต้อง

2472
02:02:06,290 --> 02:02:10,090
จามโมฆะถูกต้องในขณะนี้

2473
02:02:10,090 --> 02:02:12,390
>> และฉันยังคงเพียงแค่ต้องบอกว่า

2474
02:02:12,390 --> 02:02:18,990
ดังนั้นฉันจะบอกว่าการพูด
สตริง S, int n กึ่งลำไส้ใหญ่

2475
02:02:18,990 --> 02:02:22,010
ดังนั้นผมจึงได้มากกว่าวิศวกรรม
ห่าออกจากโปรแกรมนี้

2476
02:02:22,010 --> 02:02:23,760
>> และนี้ไม่ได้
หมายความว่านี้ก็คือ

2477
02:02:23,760 --> 02:02:26,343
สิ่งที่คุณควรทำเมื่อเขียน
แม้ที่ง่ายที่สุดของโปรแกรม

2478
02:02:26,343 --> 02:02:29,280
นำสิ่งที่เห็นได้ชัด
ง่ายจริงๆสั้นจริงๆ

2479
02:02:29,280 --> 02:02:31,800
และอีกครั้งที่จะใช้มัน
ใช้รหัสวิธีที่มากเกินไป

2480
02:02:31,800 --> 02:02:34,560
แต่คุณจะเห็นจริงและใน
เวลามองย้อนกลับไปในตัวอย่างเหล่านี้

2481
02:02:34,560 --> 02:02:38,610
และตระหนักถึงโอ้เหล่านี้เป็นขั้นตอน
เราเอาไปคุยจริง

2482
02:02:38,610 --> 02:02:40,797
เพื่อสะท้อนอะไรบางอย่างออกมา
จนกระทั่งในตอนท้ายของวัน

2483
02:02:40,797 --> 02:02:42,380
รหัสของฉันเป็นจริงเหมาะสมสวย

2484
02:02:42,380 --> 02:02:45,960
เพราะถ้าผมต้องการที่จะไอสาม
ครั้งแล้วจามสามครั้ง

2485
02:02:45,960 --> 02:02:50,420
ฉันก็จะไปวิ่งนี้
โปรแกรมทำให้ไอและเรียกใช้ไอ

2486
02:02:50,420 --> 02:02:53,620
และฉันมีสามอาการไอ
และสามจาม

2487
02:02:53,620 --> 02:02:55,990
>> และเพื่อให้เป็นพื้นฐาน
กระบวนทัศน์ถ้าคุณจะ

2488
02:02:55,990 --> 02:03:00,110
สำหรับวิธีการที่เราอาจจะไปเกี่ยวกับ
การดำเนินการจริงโปรแกรม

2489
02:03:00,110 --> 02:03:03,220
แต่ขอเพียงแค่เห็นในขณะนี้ว่ามันคืออะไร
เราได้รับการทำทั้งหมดเวลานี้

2490
02:03:03,220 --> 02:03:06,940
และสิ่งที่บางชิ้นสุดท้าย
อยู่เบื้องหลังคำสั่งง่ายๆนี้

2491
02:03:06,940 --> 02:03:09,620
ในตอนท้ายของวันที่เราได้
รับการใช้เสียงดังกราวเป็นคอมไพเลอร์ของเรา

2492
02:03:09,620 --> 02:03:11,494
เราได้รับการเขียนแหล่งที่มา
รหัสแปลง

2493
02:03:11,494 --> 02:03:12,820
ผ่านเสียงดังกราวเป็นรหัสเครื่อง

2494
02:03:12,820 --> 02:03:15,540
>> และเราได้รับใช้ให้เพียง
เพื่ออำนวยความสะดวกการกดแป้นพิมพ์ของเราเพื่อให้

2495
02:03:15,540 --> 02:03:20,740
ที่เราไม่ต้องจำ
คาถาเหล่านั้นของตัวเองเสียงดังกราว

2496
02:03:20,740 --> 02:03:22,640
แต่สิ่งที่ทำให้ทำจริง?

2497
02:03:22,640 --> 02:03:24,750
และในทางกลับกันสิ่งที่เป็น
เสียงดังกราวทำจริง?

2498
02:03:24,750 --> 02:03:28,790
>> มันจะเปิดออกแม้ว่าเราได้ง่าย
การอภิปรายในวันนี้โดยกล่าวว่า

2499
02:03:28,790 --> 02:03:33,090
คุณใช้รหัสที่มาผ่านเป็น
เข้ากับคอมไพเลอร์ที่ช่วยให้คุณ

2500
02:03:33,090 --> 02:03:35,750
การส่งออกของเครื่อง
รหัสเปิดออกมีของ

2501
02:03:35,750 --> 02:03:37,420
ขั้นตอนที่แตกต่างกันไม่กี่ภายในมี

2502
02:03:37,420 --> 02:03:41,940
และรวบรวมเกิดขึ้นเป็นร่ม
ระยะสำหรับทั้งกลุ่มของขั้นตอน

2503
02:03:41,940 --> 02:03:43,970
แต่ขอเพียงแค่หยอกล้อ
นี้ออกมาได้อย่างรวดเร็วจริงๆ

2504
02:03:43,970 --> 02:03:48,070
>> แต่กลับกลายเป็นว่าเราได้รับการทำ
สิ่งที่มากขึ้นทุกครั้งที่ผมรันโปรแกรม

2505
02:03:48,070 --> 02:03:50,990
หรือทุกครั้งที่ผมรวบรวมโปรแกรมวันนี้

2506
02:03:50,990 --> 02:03:55,020
ดังนั้น preprocessing หมายถึง
this-- อะไรในโปรแกรม C,

2507
02:03:55,020 --> 02:03:58,720
ในขณะที่เราจะเห็นอีกครั้งและอีกครั้ง
ที่เริ่มต้นด้วยสัญลักษณ์กัญชานี้

2508
02:03:58,720 --> 02:04:03,320
หรือสัญลักษณ์ hashtag ที่นี่หมายถึง
มันเป็นคำสั่ง preprocessor

2509
02:04:03,320 --> 02:04:07,330
นั่นหมายความว่าในกรณีนี้เดี๋ยวก่อน
คอมพิวเตอร์ทำอะไรกับไฟล์นี้

2510
02:04:07,330 --> 02:04:09,430
ก่อนที่จะรวบรวมรหัสของตัวเอง

2511
02:04:09,430 --> 02:04:15,220
>> ในกรณีนี้รวมถึงกัญชามี
หลักวิธีการของซีว่า

2512
02:04:15,220 --> 02:04:19,325
เฮ้คอมพิวเตอร์ไปได้รับเนื้อหา
ของ CS50.h และวางพวกเขาที่นี่

2513
02:04:19,325 --> 02:04:22,170
เฮ้คอมพิวเตอร์ให้ไปรับ
เนื้อหาของมาตรฐาน IO.h,

2514
02:04:22,170 --> 02:04:24,690
ที่ใดก็ตามที่อยู่บน
ฮาร์ดไดรฟ์วางไว้ที่นี่

2515
02:04:24,690 --> 02:04:27,390
ดังนั้นสิ่งเหล่านั้นเกิดขึ้น
ครั้งแรกในช่วง preprocessing

2516
02:04:27,390 --> 02:04:28,880
>> และเสียงดังกราวไม่ทั้งหมดนี้สำหรับเรา

2517
02:04:28,880 --> 02:04:30,510
และมันไม่ได้ดังนั้นยี้
ได้อย่างรวดเร็วคุณทำไม่ได้

2518
02:04:30,510 --> 02:04:32,000
เห็นสี่สิ่งที่แตกต่างที่เกิดขึ้น

2519
02:04:32,000 --> 02:04:34,100
แต่นั่นเป็นขั้นตอนดังกล่าวครั้งแรก

2520
02:04:34,100 --> 02:04:35,560
>> สิ่งที่เกิดขึ้นจริงต่อไปหรือไม่

2521
02:04:35,560 --> 02:04:38,320
ดีอย่างเป็นทางการต่อไป
ขั้นตอนการรวบรวม

2522
02:04:38,320 --> 02:04:40,385
และปรากฎว่า
คอมไพล์โปรแกรม

2523
02:04:40,385 --> 02:04:44,060
ในทางเทคนิคหมายถึงไปจาก
รหัสที่มาของสิ่งที่เราได้

2524
02:04:44,060 --> 02:04:47,890
รับการเขียนวันนี้เพื่ออะไร
เรียกว่ารหัสการชุมนุมบางสิ่งบางอย่าง

2525
02:04:47,890 --> 02:04:49,260
ที่มีลักษณะแตกต่างกันเล็กน้อย

2526
02:04:49,260 --> 02:04:51,050
>> และในความเป็นจริงเราสามารถมองเห็นได้อย่างรวดเร็วจริง

2527
02:04:51,050 --> 02:04:53,890
ให้ฉันจริงไปเป็น IDE ของฉัน

2528
02:04:53,890 --> 02:04:58,050
ให้ฉันไปข้างหน้าและเปิด hello.c ซึ่ง
เป็นโปรแกรมแรกมากกับการที่เรา

2529
02:04:58,050 --> 02:04:59,120
เริ่มวันนี้

2530
02:04:59,120 --> 02:05:04,130
และแจ้งให้เราไปข้างหน้าและเรียกเสียงดังกราว
แตกต่างกันเล็กน้อยเสียงดังกราว-S hello.c,

2531
02:05:04,130 --> 02:05:07,720
ซึ่งเป็นจริงไป
ให้ฉัน hello.s ไฟล์อื่น

2532
02:05:07,720 --> 02:05:10,330
>> และเราอาจจะไม่เคย
อีกครั้งดูชนิดของรหัสนี้

2533
02:05:10,330 --> 02:05:13,030
ถ้าคุณใช้เวลาในระดับที่ต่ำ
ระดับระบบเช่น CS61,

2534
02:05:13,030 --> 02:05:14,920
คุณจะเห็นมากขึ้น
ของชนิดของรหัสนี้

2535
02:05:14,920 --> 02:05:17,020
แต่นี้เป็นภาษาประกอบ

2536
02:05:17,020 --> 02:05:22,050
นี่คือ X86 ภาษาประกอบ
ว่าซีพียูที่มีพื้นฐาน

2537
02:05:22,050 --> 02:05:24,460
IDE CS50 จริงเข้าใจ

2538
02:05:24,460 --> 02:05:27,060
>> และความลับมันไม่
ดูมันเป็นบางสิ่งบางอย่าง

2539
02:05:27,060 --> 02:05:29,180
คอมพิวเตอร์เข้าใจสวยดี

2540
02:05:29,180 --> 02:05:30,790
Sub Q นี้เป็นลบ

2541
02:05:30,790 --> 02:05:31,660
มีการเคลื่อนไหวเป็น

2542
02:05:31,660 --> 02:05:35,730
>> มีการเรียกฟังก์ชั่นที่นี่
X oring, การเคลื่อนไหว, การเพิ่ม, ป๊อป,

2543
02:05:35,730 --> 02:05:36,430
ผลตอบแทน

2544
02:05:36,430 --> 02:05:38,850
ดังนั้นจึงมีบางมาก
คำแนะนำในระดับต่ำ

2545
02:05:38,850 --> 02:05:41,280
ที่ซีพียูเข้าใจว่า
ฉันพูดพาดพิงถึงก่อนหน้านี้

2546
02:05:41,280 --> 02:05:43,100
นั่นคือสิ่งที่ Intel Inside

2547
02:05:43,100 --> 02:05:45,030
>> มีรูปแบบของการเป็น
ศูนย์และคนที่

2548
02:05:45,030 --> 02:05:51,800
แผนที่เหล่านี้คำ arcanely แต่
ค่อนข้างดีชื่อคำแนะนำ

2549
02:05:51,800 --> 02:05:52,780
เพื่อที่จะพูด

2550
02:05:52,780 --> 02:05:54,780
นั่นคือสิ่งที่เกิดขึ้นเมื่อ
คุณรวบรวมรหัสของคุณ

2551
02:05:54,780 --> 02:05:58,560
คุณจะได้รับการชุมนุม
ภาษาออกมาจากมันซึ่ง

2552
02:05:58,560 --> 02:06:04,680
หมายถึงขั้นตอนที่สามคือการรวบรวม
รหัสการชุมนุมที่เป็นที่สุด

2553
02:06:04,680 --> 02:06:09,080
เครื่องศูนย์ code-- และคนที่ไม่ได้
ข้อความที่เราเพิ่งเห็นสักครู่ที่ผ่านมา

2554
02:06:09,080 --> 02:06:13,370
>> ดังนั้นก่อนการประมวลผลที่ไม่พบ
และแทนที่และสิ่งอื่น ๆ น้อย

2555
02:06:13,370 --> 02:06:16,430
รวบรวมใช้เวลาแหล่งที่มาของ
รหัส C จากซอร์สโค้ด

2556
02:06:16,430 --> 02:06:18,980
ที่เราเขียนในการชุมนุม
รหัสที่เราเพียงแค่เหลือบมองไปที่

2557
02:06:18,980 --> 02:06:22,170
ประกอบใช้เวลาการชุมนุมว่า
รหัสเลขศูนย์และคน

2558
02:06:22,170 --> 02:06:24,680
ที่ซีพียูจริงๆจะ
เข้าใจในตอนท้ายของวัน

2559
02:06:24,680 --> 02:06:27,630
และการเชื่อมโยงเป็นขั้นตอนสุดท้าย
ที่เกิดขึ้นสำหรับ us-- อีกครั้ง

2560
02:06:27,630 --> 02:06:29,830
ได้อย่างรวดเร็วเพื่อให้เราไม่ได้
notice-- ที่บอกว่า

2561
02:06:29,830 --> 02:06:32,460
เฮ้คอมพิวเตอร์ใช้เวลาทั้งหมดของ
เลขศูนย์และคนที่

2562
02:06:32,460 --> 02:06:36,750
เป็นผลมาจากการรวบรวมรหัสของดาวิด
และฟังก์ชั่นหลักของเขาในกรณีนี้

2563
02:06:36,750 --> 02:06:39,160
>> และ hey คอมพิวเตอร์ไปได้รับ
ทั้งหมดของศูนย์และคน

2564
02:06:39,160 --> 02:06:42,180
ว่าพนักงาน CS50 เขียน
ภายในห้องสมุด CS50

2565
02:06:42,180 --> 02:06:43,440
ผสมกับผู้ที่อยู่ในของดาวิด

2566
02:06:43,440 --> 02:06:46,648
และ hey คอมพิวเตอร์ไปได้รับศูนย์ทั้งหมด
และคนที่คนอื่นเขียนปี

2567
02:06:46,648 --> 02:06:47,470
ที่ผ่านมาสำหรับ printf

2568
02:06:47,470 --> 02:06:49,880
และเพิ่มผู้เข้ามา
สิ่งที่ทั้งเพื่อให้เราได้

2569
02:06:49,880 --> 02:06:52,870
มีศูนย์และคนของฉัน
ศูนย์พนักงาน CS50 และคน

2570
02:06:52,870 --> 02:06:55,370
เลขศูนย์ printf และคน
และสิ่งอื่น ๆ ที่เรากำลังใช้

2571
02:06:55,370 --> 02:07:00,410
>> พวกเขาทั้งหมดได้รับการรวมกันเป็นหนึ่ง
โปรแกรมที่เรียกว่าในกรณีนี้สวัสดี

2572
02:07:00,410 --> 02:07:03,141
ดังนั้นต่อจากนี้ไปเราจะเป็นเพียงแค่
ใช้คำว่าการรวบรวม

2573
02:07:03,141 --> 02:07:06,390
และเราจะใช้สำหรับการรับว่าเมื่อ
เราบอกว่ารวบรวมโปรแกรมของคุณมันหมายถึง

2574
02:07:06,390 --> 02:07:08,849
เฮ้ทำก่อนการประมวลผล
การประกอบและการเชื่อมโยง

2575
02:07:08,849 --> 02:07:11,890
แต่มีบางสิ่งที่จริงฉ่ำ
ที่เกิดขึ้นมีอยู่ภายใต้ฝากระโปรง

2576
02:07:11,890 --> 02:07:13,723
และโดยเฉพาะอย่างยิ่งถ้าคุณ
ได้รับความอยากรู้อยากเห็นบางครั้ง

2577
02:07:13,723 --> 02:07:15,900
คุณสามารถเริ่มต้นการพูดล้อ
รอบในระดับที่ต่ำกว่านี้

2578
02:07:15,900 --> 02:07:19,660
แต่ตอนนี้ทราบว่า
ในหมู่คบสำหรับวันนี้

2579
02:07:19,660 --> 02:07:23,420
ค่อนข้างเพียง
จุดเริ่มต้นของกระบวนการ

2580
02:07:23,420 --> 02:07:26,700
ในการได้รับความสะดวกสบายด้วย
บางสิ่งบางอย่างเหมือนโลกสวัสดี

2581
02:07:26,700 --> 02:07:29,575
อันที่จริงส่วนใหญ่ของสิ่งที่เราทำในวันนี้
แน่นอนจะไม่จมอยู่ใน Super Fast

2582
02:07:29,575 --> 02:07:31,491
และมันจะใช้เวลาบางส่วน
เวลาและการปฏิบัติบาง

2583
02:07:31,491 --> 02:07:33,864
และราคาที่คุณจะเรียงลำดับ
ของต้องการที่จะตีแป้นพิมพ์ของคุณ

2584
02:07:33,864 --> 02:07:34,780
หรือตะโกนใส่หน้าจอ

2585
02:07:34,780 --> 02:07:35,880
และทั้งหมดที่ตกลง

2586
02:07:35,880 --> 02:07:38,320
แม้ว่าอาจจะพยายามที่จะไม่
ทำมันในห้องสมุดมาก

2587
02:07:38,320 --> 02:07:40,820
>> และในที่สุดคุณจะ
สามารถแม้ว่าจะเริ่มต้น

2588
02:07:40,820 --> 02:07:44,580
เห็นรูปแบบทั้งในรหัสที่ดี
ที่คุณเขียนและในความผิดพลาด

2589
02:07:44,580 --> 02:07:45,370
ที่คุณทำ

2590
02:07:45,370 --> 02:07:48,965
และเหมือนกระบวนการของ
กลายเป็น TF หรือ CA เป็นเหมือน

2591
02:07:48,965 --> 02:07:51,590
คุณจะเริ่มต้นที่จะได้รับที่ดีขึ้นและ
ดีกว่าที่เห็นรูปเหล่านั้น

2592
02:07:51,590 --> 02:07:53,774
และเพียงแค่การแก้ของคุณ
ปัญหาของตัวเองในที่สุด

2593
02:07:53,774 --> 02:07:56,940
ในขณะเดียวกันจะมีปริมาณมาก
ของเราที่จะให้ยืมคุณสนับสนุนและให้คุณได้รับ

2594
02:07:56,940 --> 02:07:57,481
ผ่านทางนี้

2595
02:07:57,481 --> 02:07:59,450
และในการเขียนอัพ
สำหรับทุกปัญหาที่เกิดขึ้น

2596
02:07:59,450 --> 02:08:01,366
คุณจะได้รับคำแนะนำผ่าน
ทุกคำสั่ง

2597
02:08:01,366 --> 02:08:05,330
ที่แน่นอนฉันรู้จาก
จำนวนมากของการปฏิบัติโดยขณะนี้

2598
02:08:05,330 --> 02:08:07,380
แต่อาจจะมีการบิน
เหนือหัวของคนสำหรับในตอนนี้

2599
02:08:07,380 --> 02:08:08,580
และที่ดีทั้งหมด

2600
02:08:08,580 --> 02:08:11,230
>> แต่ในท้ายที่สุดคุณจะ
เริ่มต้นที่จะเห็นรูปแบบโผล่ออกมา

2601
02:08:11,230 --> 02:08:14,260
และเมื่อคุณได้รับในอดีตทั้งหมดของ
รายละเอียดโง่เหมือนวงเล็บ

2602
02:08:14,260 --> 02:08:16,710
และวงเล็บปีกกาและกึ่งทวิภาค,
และสิ่งที่ตรงไปตรงมา

2603
02:08:16,710 --> 02:08:19,360
ที่ไม่ได้เลย
ที่น่าสนใจทางสติปัญญา

2604
02:08:19,360 --> 02:08:22,690
และมันก็ไม่ใช่วัตถุประสงค์ของ
การเรียนเบื้องต้นใด ๆ

2605
02:08:22,690 --> 02:08:24,410
มันเป็นความคิดที่จะไปสำคัญ

2606
02:08:24,410 --> 02:08:26,659
>> มันเป็นลูปและ
เงื่อนไขและฟังก์ชั่นที่

2607
02:08:26,659 --> 02:08:30,552
และอื่น ๆ ที่มีประสิทธิภาพนามธรรม,
และแฟของรหัส

2608
02:08:30,552 --> 02:08:33,510
และการออกแบบที่ดีและคนดี
รูปแบบและในที่สุดความถูกต้อง

2609
02:08:33,510 --> 02:08:37,330
ของรหัสของคุณที่ในท้ายที่สุด
จะสำคัญที่สุด

2610
02:08:37,330 --> 02:08:40,925
ดังนั้นในสัปดาห์หน้าเราจะนำเหล่านี้
ความคิดที่เราเห็นครั้งแรกในรอยขีดข่วน

2611
02:08:40,925 --> 02:08:42,800
และในขณะนี้มีการแปล
ซีและเราจะเริ่มต้น

2612
02:08:42,800 --> 02:08:45,740
ที่จะแนะนำเป็นครั้งแรกของ
หลักสูตรโดเมนโลกแห่งความจริง

2613
02:08:45,740 --> 02:08:50,140
>> เราจะมุ่งเน้นไปที่โลกของการรักษาความปลอดภัย
และมากขึ้นโดยเฉพาะการเข้ารหัส

2614
02:08:50,140 --> 02:08:51,980
ศิลปะของข้อมูล scrambling

2615
02:08:51,980 --> 02:08:54,000
และในหมู่คนแรก
ปัญหาคุณเอง

2616
02:08:54,000 --> 02:08:56,840
จะได้รับการเขียนเกิน
เล่นกับบางส่วนของไวยากรณ์

2617
02:08:56,840 --> 02:08:59,880
และการแก้ตรรกะ
ปัญหาที่เกิดขึ้นในท้ายที่สุดก่อนที่จะนาน

2618
02:08:59,880 --> 02:09:03,960
คือการช่วงชิงจริงหรือเข้ารหัส
และท้ายที่สุดการถอดรหัสข้อมูล

2619
02:09:03,960 --> 02:09:06,470
และทุกอย่างที่เราเคยทำ
วันนี้ค่อนข้างจะต่ำ

2620
02:09:06,470 --> 02:09:09,190
ระดับเป็นเพียงการไปเพื่อให้
เราจะใช้เวลาหนึ่งและหนึ่ง

2621
02:09:09,190 --> 02:09:13,550
และเป็นหนึ่งในขั้นตอนอื่น ๆ ดังกล่าวข้างต้นที่มีต่อ
การเขียนโค้ดที่น่าสนใจที่สุดเลย

2622
02:09:13,550 --> 02:09:15,050
>> เพื่อให้มากขึ้นในสัปดาห์หน้าว่า

2623
02:09:15,050 --> 02:09:17,834

2624
02:09:17,834 --> 02:09:18,762
>> [เล่นวีดีโอ]

2625
02:09:18,762 --> 02:09:19,690

2626
02:09:19,690 --> 02:09:22,006
>> อะไรที่คุณสามารถบอกฉันเกี่ยวกับ
ครั้งสุดท้ายที่คุณเห็นเขา?

2627
02:09:22,006 --> 02:09:26,041

2628
02:09:26,041 --> 02:09:27,040
อะไรที่ฉันสามารถพูดจริงเหรอ?

2629
02:09:27,040 --> 02:09:30,500

2630
02:09:30,500 --> 02:09:35,340
ฉันหมายความว่ามันเป็นเหมือนคนอื่น ๆ
การฝึกซ้อมก่อนการผลิต

2631
02:09:35,340 --> 02:09:40,510
ยกเว้นมีบางอย่างที่เขากล่าวว่า
ที่ปลายมากที่ติดอยู่กับฉัน

2632
02:09:40,510 --> 02:09:44,810

2633
02:09:44,810 --> 02:09:46,640
>> -This เป็น CS50

2634
02:09:46,640 --> 02:09:49,440

2635
02:09:49,440 --> 02:09:52,190
>> ใช่หรือไม่เพราะเป็นทุกคนตัด
งานที่ดีในการฝึกซ้อม

2636
02:09:52,190 --> 02:09:53,070
>> อาหารกลางวันใช่หรือไม่เพราะหรือไม่?

2637
02:09:53,070 --> 02:09:54,986
>> -Yeah คุณและฉันสามารถ
คว้าแซนวิชในบิต

2638
02:09:54,986 --> 02:09:58,380
ให้ฉันเพียงแค่สอบถามกับ
เดวิดได้อย่างรวดเร็วจริงๆ

2639
02:09:58,380 --> 02:09:59,160
ดาวิด

2640
02:09:59,160 --> 02:10:01,260
ดาวิด

2641
02:10:01,260 --> 02:10:03,110
>> [จบ PLAYBACK]

