[МУЗИКА] Дейвид Дж Малан: Добре, това е CS50. И това е една седмица. Така се припомни, че за последен път в нула седмица, ние се фокусирахме върху изчислителната мислене. И ние прехвърлихме от които да Scratch, графично програмиране език от нашите приятели в Media Lab на Масачузетския технологичен институт. 

И с Scratch, не сме проучи идеи като функции, както и условия, и примки, и променливи, а дори и събития и теми, и повече. И днес, ние ще продължите да използвате тези идеи, и наистина да ги приемате за даденост, но ги преведат на друг език, известен като C. Сега, C е по-традиционен език. Това е по-ниско ниво език, ако щете. 

Това е чисто текстова. И така, на пръв поглед, това е всичко ще изглежда по-скоро загадъчен ако никога не сте програмирани преди. Отиваме да имат точка и запетая и скоби, и фигурни скоби и др. Но осъзнавам, че дори макар че синтаксисът е за да изглежда малко по-незапознатите за повечето от вас, вижте покрай това. И се опитват да видят идеите че всъщност са запознати, защото тук, в една седмица какво ще започнем да направите, е да се сравни, първоначално, Scratch срещу C. 

Така, например, припомни, че когато ние изпълнена първата от нашите програми последно време, имахме един блок, който изглеждаше малко нещо като this-- когато зелен флаг кликнали, и след това имахме един или повече парчета под него пъзел, в този случай, да кажем, здравей свят. Така че, наистина, в Scratch, когато кликна, че зелен флаг да тече моята програма, така че да се каже, те са блоковете, които се изпълняват, или план. И по-конкретно, Scratch каза, здравей, свят. 

Сега, бих могъл да е посочено различни думи тук. Но ще видим, че, наистина, много на тези blocks-- И наистина, в C много functions-- могат да бъдат parametrized или потребителски да направим различни неща. Всъщност в C, ако ние искате да конвертирате, сега, това Scratch програма до този друг език, ние ще напише малко нещо като това. 

Разбира се, има някои непознати синтаксис там най-вероятно, INT, и скоби, както и невалидни. Но printf-- въпреки че бихте мисля, че това ще бъде само за печат. Но печат означава печат форматирани, както ние скоро ще видите. Това буквално ще отпечата на екрана каквото е вътре в тези скоби, които Разбира се в този случай е, здравей свят. 

Но вие ще забележите някои други синтаксис, някои двойни кавички, че скобите в края, полу-дебелото черво и други подобни. Така че там е малко на режийни, така да се каже, както познавателно и синтактично, че отиваме да трябва да помните, преди дълго. Но осъзнавам, че с практиката, това ще започне да скочи от вас. 

Всъщност, нека да се съсредоточи върху това един функция specifically-- в този случай, поздрави свят. Така се каже, е функцията. Здравей, свят е неговата параметър, или аргумент, нейното персонализиране. 

И равностойността в C е просто ще бъде този един ред тук, където ФОРМАТ е еквивалентна на, да речем, двойната цитиран низ, здравей свят е еквивалент, разбира се, за това, което е в бялото поле там. И обратно наклонена черта N, макар и малко странен и отсъства от нулата, просто няма да има ефект, ние ще виж в един компютър, като моя Mac или PC, от просто преместване на курсора на следващия ред. Това е като да удря Въведете от клавиатурата. 

Така че ние ще видим, че отново не след дълго. Но първо, нека да погледнем на този друг пример в случая на цикли. Имахме тази завинаги линия последно време, който беше серия от пъзел парчета че е направил нещо буквално forever-- в този случай, се каже, здравей свят, здравей свят, Здравей, свят, здравей свят. Така че това е един безкраен цикъл от дизайн. 

В C, ако искаме да се приложи това същата идея, бихме могли просто да направите това. Докато е вярно, ФОРМАТ здравей world-- сега а, просто семантично, вид внушава идеята за правене нещо отново и отново и отново, и за колко време? Е, true-- припомни, че Вярно е само на или един. 

И вярно е, разбира се, винаги е вярно. Така че това е нещо като безсмислен изявление просто да каже вярно. Но наистина, това е умишлено, защото ако е вярно е просто винаги е вярно, отколкото докато вярно само предполага, ако малко непряко че следващите редове с код между тези фигурни скоби просто трябва да се изпълни отново, и отново, и отново, и всъщност никога не спира. 

Но ако искате вашия контур да се спре, тъй като ние Направих последен път с нещо подобно това, повторете следните 50 пъти, в C можем да направим същото и с това, което е нарича за loop-- ключова дума не е време, но за. И тогава имаме някакъв нов синтаксис тук, с инт аз равна на 0, аз по-малко от 50, I ++. И ние ще се върнем към това. Но това е просто начина, по който ще превежда на снимачната площадка на надраскване блокове с набор от C реда код. 

В същото време, помисли променливи. И, всъщност, ние просто Видях един преди малко. И в случай на Scratch, ако ние Исках да декларира променлива, наречена I защото е число, само няколко, и ние искаме да го постави в някаква стойност, ние ще използваме този портокал блокират here-- зададете аз до 0. 

И ние ще видим днес и отвъд, точно както миналата седмица, програмисти правят почти винаги започне броенето от нулата, наистина по конвенция. Но също така, защото изземване от нашата дискусия на двоичен, най-малкият брой можете представляват, с произволен брой битове е просто ще бъде 0 самия. И така, ние ще обикновено започнете инициализиране дори нашите променливи до 0. 

И в C да направят същото, ние ще кажем, инт за число, аз просто по споразумение. Можех да нарича тази променлива всичко, което искам, точно като в Scratch. И след това се равнява на 0 само правоприемници стойност 0 отдясно и го слага в променливата, или на контейнер за съхранение там, в ляво. И точка и запетая, тъй като ние ще see-- и сме виждали някои от тези already-- просто означава край на мисълта. Продължете да направи нещо друго по линиите, които следват. 

Сега, какво да кажем за булеви изрази? Припомнете си, че в самото начало, това са изрази, че са или истина или false-- въпроси, наистина, че са или вярно или невярно. Така че, в случай на Scratch, можем да попитам един прост въпрос като този, е аз по-малко от 50? Така че, отново, е цяло число. Може би ние го използвате в програма Scratch за да следите на полувремето Или нещо такова. Така че този синтаксис тук в Scratch просто означава, е, че по-малко от 50? Е, за щастие, нещо е просто в C. И да превежда, това ние просто ще кажа, че по-малко от 50, като се използва познат ключ на клавиатурата. 

В същото време, ако искате да каже нещо по-общо, като, добре, е х-малко от Y, където всеки на х и у самите променливи са? Ние можем да направим същото нещо в C, толкова дълго, тъй като ние сме създадени тези променливи вече. И ние ще видим как да направя, че не след дълго. Ние просто ще кажа, х-малко от ш. 

Така че ако започне да виж някои прилики. И тези хора, които са направили Scratch със сигурност са били вдъхновена от някои от тези основни идеи. И ще видите на този вид синтаксис в много languages-- не само нулата, не само C, но Python, и JavaScript, и други езици на едно място. 

Нека разгледаме още един конструкт от С, понятието на състояние, прави нещо условно. Ако нещо е вярно, направи това. Ако нещо друго е вярно, прави това. Това е нещо програмирането еквивалент на разклонение на пътя. Може би това е двупосочна вилица, трипътен вилица, или повече. И в Scratch, да имаме виждал нещо подобно. 

Така че това е една голяма. Но се разгледа относителната простота на логиката. Ако X е по-малко от Y, тогава X е по-малко каже от Y, иначе, ако х е по-голяма от у, след това казват, х е по-голямо, отколкото у. И след това, логично, ако мислите, че обратно на Scratch или просто свой собствен човешката интуиция, и, ако X е не по-голяма от у и х е не по-малко от Y, тогава, разбира се, х ще е равно на х. Така че в този случай, от гнездене тези Scratch блокове, можем да постигнем три начин разклонение на пътя? 

В същото време, ако искаме да направи това в C, то може би изглежда малко simpler-- най-малко след като се запознае с синтаксиса. Ако X е по-малко от Y, ФОРМАТ х е по-малко от Y. Иначе, ако х е по-голяма от у, ФОРМАТ х е по-голяма от у. Иначе ФОРМАТ х е равно на y-- и, отново, с тези, наклонена черта завършва просто за тези нови линии, така че ако ви всъщност изтича този вид програма той просто ще се премести курсора в края на краищата на следващия ред на екрана. 

Сега, междувременно Scratch имаше друга по-сложни функции, само някои от които ние ще първоначално насочат към света на C. И един от тях е наречен списък в Scratch. И това беше специален тип на променлива, която да ви е позволено да се съхранява няколко неща в това обратно, за да архивирате, за да архивирате, за да архивирате. 

В C, че не разполага с списъци, само по себе си, но нещо които са по-общо наречен масиви, въпреки че ние ще да се върне по-късно този семестър да гледаш нещо нарича списък, или наистина списък свързан. Но за сега, най-близо еквивалент в C за нас ще бъде нещо наречен масив. И масив е просто специален вид променлива която ви позволява да съхранявате данните обратно, за да архивирате, за да архивирате, да върне. 

И наистина, в Scratch, ако искахме да получите достъп до първият елемент на масив или а list-- и аз ще го наричаме, по силата на споразумение, argv, аргумент вектор, но повече за това не след дълго. Ако аз искам да отида в първия елемент на argv, в света на Scratch вие всъщност правите обикновено започнем да броим от 1. 

И така, аз може да получите т.1 от argv. Това е просто как изпълнява MIT понятието списъци. Но в C, аз ще по-просто само да кажа, argv, който отново е името на моя list-- или да бъде ясен, масив. И ако искам първият елементи, аз ще съм да използвате квадратни скоби, които ви може често не се използва при по-клавиатура. 

Но 0 просто означава, ме първата. Така че от време на време и като с течение на времето, ние ще да започнете да виждате тези противопоставяния между Scratch и C, при което Scratch използва един. Ние в C използвайте 0 тук. Но вие бързо ще видите след като разберете основите на всеки език, това тези неща започват да се получи още по- запознат чрез практика и практика. 

Така че нека действително изглежда сега в една програма. Тук ще бъде първият от нашата C изходния код за цялостни програми. И програмата отиваме да предложи за разглеждане е този, който е еквивалентен за които по-рано Scratch парче. 

Така че тук, ние имаме това, което е може би най-простият програмата C можете да напишете, че всъщност прави нещо. Сега, ние ще разгледаме минало, за сега, е да включват, стандарт io.h, и тези ъгъл скоби, и INT, и нищожен, и фигурните скоби и други подобни. 

И нека просто се съсредоточи върху какво, поне интуитивно, може да скочи върху вас вече. Всъщност, основната, аз не правя непременно знае какво е това, но много прилича Scratch имаше, че когато зелен флаг кликнали пъзел парче, така че няма C като език за програмиране има основна част от код, който се изпълни по подразбиране. И, наистина, това е буквално ще се нарича основна. 

Така че основното е функция. И това е специална функция, която съществува в C, че когато стартирате програмата, това е основната, които получава, управляван от по подразбиране. В света на Scratch, то обикновено е, когато зелено знаме кликнали, че имам работи по подразбиране. 

В същото време, ние сме виждали това и преди, ФОРМАТ или печат форматиран, че е ще бъде функция, която идва с C, заедно с цял куп други, че волята от време и времето отново, за да се направи точно както подсказва името му, отпечатате нещо. Какво искаме да печата? Е, ще видим, че от ограждащи герои като these-- свят здравей, наклонена черта н в двойни кавички, ние можем да кажем ФОРМАТ точно какво да се отпечата на екрана. 

Но, за да се направи че, за съжаление, трябва да се вземе нещо, което е вече загадъчен за нас, хората, но поне е малко по-readable-- остър включва стандартен io.h, INT, Основната, нищожен, ФОРМАТ, всички магически заклинания ние просто видяха на екрана. Но ние всъщност трябва да отида по-тайнствена все още. Ние първо трябва да се преведат на кода че пишем в машинен код. И припомнят от миналата седмица, че машините, най-малко тези, които познаваме тук, в края на деня само разбере нули и единици. 

И моят Бог, ако ние трябваше да пиша тези нули и единици до действително програма, тя би много, много бързо вземат на шега от нищо. Но се оказва, за миналата седмица, че тези модели на нули и единици Просто трябва специално значение. В някои контексти, те може да означава номера. 

В някои контексти, те може да означава, букви или цветове, или произволен брой на други абстракции там върху. Но точно както на компютъра ви има на CPU, Централен процесор, или мозъците вътре на вашия компютър. Това е обикновено Intel вътре, защото това е един от най-големите компании че прави процесори за компютри. 

Е, Intel процесори и др просто са решили предварително че някои модели на нули и такива означава конкретни неща. Някои модели на нули и единици ще означава, отпечатайте тази на екрана, или добавете тези две числа, или извадим тези две числа, или премести тази част от данните от памет на компютъра ми тук, или произволен брой други много ниско ниво, но в крайна сметка полезно, операции. Но, за щастие, ние, хората са не вървеше да трябва да знаете това ниво на детайлност. Всъщност, точно като последния път, когато ние абстрахира отново, и отново, и отново, сграда от много ниско ниво примитиви като нули и единици за концепции по-високо ниво като цифри и букви, и цветове, както и повече, така можем и ние като програмисти стои на раменете на други, които са дошли преди нас и използвате софтуер, който друга хора са писали преди us-- а именно програми, наречени компилатори. 

C е език, който обикновено се компилира, което означава да преобразува от изходния код на машинен код. По-конкретно, какво означава това е, че ако имаш източник код, който вие сами пишат, тъй като ние скоро ще в един момент на екрана, и искате да го превърнете в крайна сметка да се машина code-- тези нули и единици, които само вашия Mac или вашия компютър understands-- имаш първи хранят, че изходния код в като въвеждане на специален програма, наречена компилатор, на изхода на който трябва да видите е машинен код. И наистина, за последен път говорихме за, наистина, в края на деня, разрешаване на проблем. Имаш входове. И имаш изходи. И имаш някакъв вид на алгоритъм в средата. 

Алгоритми със сигурност могат да бъдат приложени в областта на софтуера, както видяхме с Псевдокод миналата седмица и както ще видим с действителния код тази седмица. И така компилатор наистина просто има набор от алгоритми вътре на това, че знаят как да превръщане на специални ключови думи, като основна, и ФОРМАТ, и други, които ние просто Видях в моделите на нули и Тези, които Intel вътре и други процесори всъщност разбира. И как ще стане това? Къде ще стигнем компилатор? 

Повечето от нас тук имат Mac или PC. И сте с Mac OS, или Windows или Linux, или Solaris, или произволен брой други операционна система. И наистина, бихме могли излезеш в интернет и изтегляне на компилатор за вашия Mac или вашия компютър за вашата операционна система. Но всички ние ще бъдем на различни страници, така да се каже. Ние ще трябва леко различни конфигурации. И нещата няма да работи все едно. И наистина, тези дни много от нас не използвайте софтуер, който работи само на нашите лаптопи. Вместо това, ние използваме нещо като браузър, който ни позволява да получите достъп до уеб-базирани приложения в облака. И по-късно този семестър, ние ще направим точно това. Ние ще пишат приложения или софтуер, използвайки code-- не C, но други езици като Python и JavaScript--, които работят в облака. 

И за да направим това, ние се по време на семестъра всъщност ще се използва, базирана на облак среда, известна като CS50 IDE. Това е уеб-базирано програмиране среда, или интегрирано развитие среда, IDE, която е изградена на върха на някои софтуер с отворен код, наречен Cloud 9. И сме направили някои педагогически опростявания към него така че да се скрие, определени функции в първите седмици, че ние не се нуждаят, след което можете да ги разкрие и да направим най- всичко, което искате с околната среда. 

И това ни позволява също да предварително инсталиран определен софтуер. Неща като т.нар CS50 библиотека, която ние скоро ще видите, ни предоставя в C с някои допълнителна функционалност. Така че, ако отидете да, в крайна сметка, CS50.io, Вие ще бъдете подканени да влезете в системата, и след като се направи и да се създаде сметка за свободен, ще бъде в състояние за достъп до среда, която изглежда доста подобно на това. 

Сега, това е в режим по подразбиране. Всичко е хубаво и ярко на екрана. Много от нас имат навика работи по CS50 парче, че е доста късно през нощта. И така, някои от вас може да предпочетат да да го превърне в нощен режим, така да се каже. 

Но, в крайна сметка, това, което сте ще видим в рамките на CS50 IDE е три отделни areas-- площ в ляво, където е вашите файлове ще бъдат в облак, на площ в горния десен ъгъл където си код ще бъде може да се редактира. Вие ще бъдете в състояние да се отвори отделните раздели за всяка програма че ти пиша този семестър вътре на която горния десен ъгъл. И тогава най-arcanely, и все още силно, ще бъде това нещо в отдолу, известна като терминален прозорец. 

Това е старата школа Command Line Interface, или CLI, която позволява можете да изпълнява команди на computer-- в този случай, компютъра в cloud-- да направя неща, като съставят своя код от изходния код на машинен код, да тече си програми, или да започнат свой уеб сървър, или за достъп до база данни, и всякакъв брой други техники че ние ще започнем да използваме преди дълго. Но за да стигнем до там, ние сме Ще всъщност имат да отидете онлайн и да започнете да играете. И да се направи това, нека първо започнете бърникането с основната, и пише основната част от програмата. И нека да използвате тази функция ФОРМАТ, който се използва по-рано, просто да каже нещо. 

Така че тук вече съм вътре на CS50 IDE. Аз съм регистриран в аванс. И аз пълен пресява през прозореца. И така, в края на краищата, вие прекалено през следващите проблеми ще следват подобни стъпки, които ще осигури онлайн документация. Така че не е нужно да се притеснявате за абсорбиране на всяко малко техническа стъпка че правя тук днес. 

Но вие ще получите екран като този. Аз се случи да бъде в нощен режим. И вие може да се проясни всичко от блокирането нощен режим. И в края на ден, ти започваш да се види тези три основни areas-- файла браузъра в ляво, кодови разделите до върха, и на терминал прозореца в дъното. 

Нека да вървим напред и да напише първата си програма. Отивам да изпреварващо да отидете на File, Запазване и запазете файла ми като hello.c. В действителност, по силата на споразумение, всяка програма ние пишат, че е написана на езика на C трябва да бъде наречена нещо точка С, по споразумение. Така че аз ще го наречете hello.c, защото Просто искам да кажа здравей на света. Сега аз ще я увеличите навън и натиснете Save. И всичко, което имам тук, сега е раздела в които мога да започнете да пишете код. 

Това няма да се компилира. Това не означава нищо. И така, дори и да преобразува това да нули и единици, процесора ще има не представа какво става наоколо. Но ако аз пиша линии, които съвпадат с conventions-- C същество C е, отново, този language-- с синтаксис като това, ФОРМАТ здравей world-- и съм намерила удобно с прави това с течение на времето. Така че аз не мисля, че съм направил всички печатни грешки. 

Но, неизменно, самото начало път, когато направите това, вие ще. И това, което аз съм на път да направи много вероятно добре да не работи за вас за първи път. И това е напълно ОК, защото точно сега може просто да видите един куп новост, но с течение на времето, след като се запознае с тази на околната среда, и този език, и други, вие ще започнете да виждате неща, които са или правилен или неправилен. 

И това е, което преподаване събратя и разбира се помощници получават толкова добри в течение на времето, се зацапване грешки или грешки в кода си. Но аз твърдя, че има не са грешки в този код. Така че сега искате да използвате тази програма. 

Сега на моята собствена Mac или PC, аз съм в навика двойни икони кликвания когато искате да стартирате някоя програма. Но това не е моделът тук. В тази среда, която е CS50 IDE. Ние се използва оперативен система, наречена Linux. Linux напомня на друг операционна система, известна като Unix. И Linux е особено известен имащ Command Line околната среда, CLI. Сега, ние сме с помощта на специален вкус на Linux, наречена Ubuntu. И Ubuntu е просто определена версия на Linux. 

Но тези на Linux тези дни да направя всъщност дойде с графичен потребителски интерфейс. И този, който се случи с се използване тук е уеб-базирана. Така че това може да изглежда дори по- малко по-различна от нещо Вие сами може да се наложи виждал или тече в миналото. 

Така че аз ще отида напред сега и направете следното. Аз бях спасен този файл като hello.c. Отивам да се продължи напред и тип clanghello.c Така звън за езика на C е компилатор. Това е предварително инсталиран в CS50 IDE. И вие можете да абсолютно изтегляне и инсталиране на тази на собствения си Mac или PC. 

Но, отново, бихте няма всички предварително конфигурация направил за вас. Така че за сега, аз съм просто ще избяга clanghello.c. И сега забележи този синтаксис тук в крайна сметка ще осъзнае просто означава, че аз съм в по- папка или директория, наречена Workspace. Този знак за долар е просто конвенция за смисъл, въведете вашите команди тук. 

Това е, което се нарича бързо, просто По споразумение е знак за долар. И ако аз отида напред сега и кликнете Въведете, нищо не изглежда да се е случило. Но това е всъщност нещо добро. Колкото по-малко, което се случва на екрана, толкова по-вероятно кода си е да бъде вярна, най-малко синтактично. 

Така че, ако искате да стартирате тази програма, какво да правя? Е, оказва се, че подразбиране име по споразумение за програми, когато не конкретизират име за вашата програма е само a.out. И този синтаксис прекалено, ще се запознаят с преди дълго. 

Dot наклонена черта просто означава, хей, CS50 IDE, стартирайте програма, наречена a.out че е вътре в сегашната ми директория. Това дот означава текущата директория. И ние ще видим какви други такива последователности на знака означава преди дълго. 

Така че тук ние отивам, Enter, здравей свят. И вие ще забележите, че това, което се е случило? Не само, че го отпечатате здравей свят. Той също така разви курсора на следващия ред. 

И защо беше това? Какво е кодът, който писахме преди че се гарантира, че ще курсора отидете на следващия ред? Странно нещо за компютър е тя само ще да направи буквално каквото го кажа, за да се направи. 

Така че, ако го кажа, за да ФОРМАТ здравей, запетая, пространство, свят, в близост цитат, това е буквално само ще за отпечатване на тези символи. Но аз имах този специален символ в края, изземване, наклонена черта п. И това е, което гарантира че характерът отиде на следващия ред на екрана. 

Всъщност, нека отида и да направите това. Нека да вървим напред и да изтриете това. Сега, забележете, че горната част на екрана ми има малко червена светлина в В раздела се посочва, хей, вие не сте запазили файла. Така че аз ще отида напред с контрол S или команда S, запишете файла. Сега тя goes-- отиде за moment-- зелено. И сега тя се е върнала на просто е близо икона. 

Ако аз сега отново тече clanghello.c, Enter, точка наклонена черта, a.out, Enter, ще видите, че тя все още работи. Но това е може би малко бъги. Точно сега, ми prompt-- работно пространство, и след това, че знака за долар, и след това ми действителната prompt-- е на една и съща линия. Така че това със сигурност естетически бъг, дори и ако това не е наистина логично бъг. 

Така че аз отивам да отмените това, което току-що е направил. Отивам да се повтаря отново, a.out. Забележете, че съм добавя символ за нов ред обратно. Аз бях спасен файла. 

Така че аз ще се преиграва a.out, and-- по дяволите, е грешка, грешка означава грешка. Така че грешката е, че въпреки че Добавих наклонената черта н там, ре-запазена, повторно се завтече на програмата, поведението е същата. Защо, че ще бъде? 

Липсва ми стъпка, нали? Това ключова стъпка по-рано беше, че имате to-- когато смените изходния код, Оказва се също тече то чрез компилатора отново, така че можете да получите нов код машина. И кода на машина, единиците и нулите, Ще бъде почти идентичен, но не съвсем така, защото имаме нужда, разбира се, че новата линия. 

Така че, за да се определи това, аз отивам да се наложи да преиграва clanghello.c, влиза, точка наклонена черта, a.out. И сега, здравей свят е обратно до мястото, където се очаква тя да бъде. Така че всичко това е фин и добър. Но a.out е доста глупаво име за програма, въпреки че това се случва да бъде, по исторически причини, за default-- означава монтажни изходи. 

Но нека да вървим напред тук и да направите това по различен начин. Искам си здравей свят програма да всъщност се нарича здравей. Така че, ако беше икона на моя десктоп, че не би се a.out. Тя ще се нарича здравей. 

Така че, за да направите това, се оказва, че звън, подобно на много програми, подкрепя аргументи на командния ред, или флагове, или ключове, които просто въздействие върху поведението му. По-конкретно, звън подкрепя пробив о флаг, който след това се взема втора дума. В този случай, аз ще произволно, но разумно, наричаме го поздрави. Но мога да го наречем нещо Искам, освен a.out, които Би било по-скоро, освен най-важното. 

И след това просто да посочите името на файла, който искате да се съберат. Така че сега, въпреки че в началото на командата Аз все още имам звън, в края на командата Аз все още имам името на файла, Сега имам тези команди аргументи, тези флагове, които казват, О, между другото, на изхода-о, а файл наречен здравей, не a.out по подразбиране. 

Така че, ако се удари Въведете сега, нищо Изглежда, че се е случило. И, все пак, сега мога да направя точка наклонена черта здравей. Така че това е една и съща програма. Единиците и нулите са идентичен в края на деня. 

Но те са в две различен files-- a.out, която е първата версия и просто глупаво име, и сега здравей, която е много по- по-наложителна име за дадена програма. Но, честно казано, аз никога не съм Ще помня този път, и отново и отново. И, всъщност, като пишем по-сложни програми, команди, които ви ще трябва да се напише Ще получите още по-сложно все още. 

И така, за да не се тревожи. Оказва се, че хората преди ни са осъзнали, твърде имаше тази точно същия проблем. Те също не се ползва да се налага да въведете доста дълги, тайнствени команди, камо ли да ги помня. И така хората преди нас са направили други програми, които го правят по-лесно за съставяне на вашия софтуер. 

И, наистина, едно такова Програмата се нарича производител. Така че аз ще отида напред и да направим това. Отивам да отмените всичко, което Току-що е по следния начин. Нека да въведете LS. И вие ще забележите три things-- a.out, и една звезда, здравей и една звезда, и hello.c. Надяваме се, това трябва да е малко интуитивен, доколкото по-рано не е нищо в това работно пространство. Нямаше нищо, че имах създаден, докато ние започнахме клас. 

И съм създал hello.c. След това аз го компилира, и го нарича a.out. И тогава аз го компилира отново леко по различен начин и да го нарича здравей. Така че имам три файлове в тази директория, в тази папка, наречена Workspace. Сега, аз може да се види, че както ако аз отдалечаване всъщност. 

Ако намалите тук и погледнете, че горния десен ъгъл, както е обещано в ляво ръката страна на вашия екран винаги ще ви покажа това, което е в профила си, това, което е вътре на CS50 IDE. И там е три файлове там. 

Така че аз искам да се отърва от a.out и здравей. И както може да се представете си интуитивно, вие може да се справи с контрола кликване или десен бутон върху това. И това малко меню се появява. Можете да изтеглите файла, стартирайте това, да го визуализирате, опресняване, преименувате, или какво не. 

И аз може просто да изтриете, и тя ще си отиде. Но нека да направим нещата с команда линия за сега, така че да се удобно с това, и направете следното. Отивам да вървим напред и да се премахне a.out като напишете буквално rma.out. Оказва се, командата за премахването или изтриването нещо, е не премахват или изтриване. 

Това е по-кратко и ясно RM, само за да спаси ви някои клавиши, и удари Enter. Сега отиваме да бъде до известна степен загадъчно премахнете обикновен файл a.out. Аз наистина не знам какво е нередовен файл ще бъде още. Но аз искам да го отстранят. 

Така че аз ще се у написали за да. Или мога да го напишете, и удари Enter. И, отново, нищо не изглежда да се случи. Но това е, общо взето, е нещо добро. 

Ако този път пиша LS, какво трябва да видим? Надяваме се, че само здравей и hello.c. Сега, като се отмени, ще забележите тази звезда, звезда, това е в края на моите програми. И те също се показва в зелено. Това е просто начин CS50 IDE е на вас cluing в обстоятелството, че това не е изходния код. Това е изпълним, а изпълнима програма, която всъщност можете да стартирате чрез правене точка наклонена черта, и след това е име. 

Сега, нека да вървим напред и да се премахне това, RM здравей, Enter, премахнете редовен подаде здравей, да. И сега, ако ми пишете LS, ние сме назад към hello.c. Опитайте се да не я изтрие действителната изходния код. Въпреки че има функции вградена в CS50 IDE, където можете да мине през историята си редакция и назад във времето, ако случайно изтриете нещо, правя да се забравя, по тези подкани да или не, от това, което всъщност искам да правя. И като отида до върха ляв ъгъл тук, всичко, което остава е hello.c. Така че има букети от други команди, които ви може да се изпълни в света на Linux, една от които е, отново, Направете. И ние ще направим моята програма сега, както следва. 

Вместо това трясък, вместо да правиш трясък-о, Отивам да се просто буквално написали, да здравей. И сега забележи, аз съм Не пишете направи hello.c. Аз съм типичен направи здравей. 

И тази програма Направи че идва с CS50 IDE, и по- обикновено с Linux, е програма, която е ще направи една програма, наречена Здравейте. И това се случва, за да се предположи, по силата на споразумение, че ако може да се направи тази програма, това ще бъде направено от източник код файл завършващ в точка C, hello.c. 

Така че, ако се удари Въведете сега, предупреждение, че командата, която се изпълни всъщност е още по-дълго преди, отколкото преди. И това е, защото сме предварително конфигуриран CS50 IDE да има някои допълнителни функции, вградени в които ние просто все още не е нужно, но скоро ще го направя. Но важното нещо да се реализира Сега е имам програма Hello. 

Ако аз отново въведете LS, I има програма, здравей. И мога да го изпълним с дот наклонена черта a.out, не, защото целият смисъл на тази упражнение е точка наклонена черта здравей. И сега имам моя здравей свят програма. Така че да се движим напред, ние сме почти винаги само ще съставят нашите програми използване на командния правите. И тогава ние ще ги експлоатират от дот наклонена черта, и името на програмата. Но осъзнае какво Уверете се прави за ви, е, че не се е компилатор. Това е просто една програма удобство че знае как да предизвика съставител да тече, така че можете сами да го използвате. 

Какво съществуват други команди в Linux, и на свой ред на CS50 IDE? Ние скоро ще видите, че има CD команда, Change Directory. Това ви позволява в рамките на вашия интерфейс на командния ред да се движи напред, и назад, и да се отворят различни папки без помощта на мишката. 

LS видяхме, което е съкращение от списъка файловете в текущата директория. Направи Dir, можете вероятно да започне да се направи извод, Какви са тия now-- направи директория, ако искате да създадете папка. RM за премахване, RM Dir за премахнете directory-- и тези, отново, са командния ред еквиваленти на това, което може да се направи в CS50 IDE с мишката. Но скоро ще се намери че понякога това е просто много по-бързо, за да се направи неща, с клавиатура, и в крайна сметка много по-мощен. 

Но това е трудно да се спори, че всичко, което сме правили досега е всичко, което мощно, когато всички ние сме били казвам е, здравей свят. И, всъщност, аз кодиран на думи здравей свят в моята програма. Не е динамика, все още. Scratch е един порядък по-интересно от миналата седмица. 

И така, нека да стигнем до там. Нека да се върнем към това, като начин на някои от тези функции. Така че не само C дойде с ФОРМАТ, и букети от други функции някои от които ще видим с течение на времето, това не е така направи всичко, което лесно направо на портата в получаване на потребителски вход. 

В действителност, един от най-слабите страни на езици като C, и дори Java и още други, е, че не да я направи лесно просто да получите неща като числа от потребителите, или низове, думи, и фрази, да не говорим такива неща плаваща запетая стойности, или реални числа с десетични точки, и наистина дълги числа, тъй като ние скоро ще видим. Така че този списък от функции, тук, те са като другите парчета Scratch пъзел че сме предварително инсталиран в CS50 IDE, че ние ще използваме за няколко седмици като помощни колела на видове, както и в крайна сметка ги свали, и с нетърпение под капака, може би, най- как се изпълняват тези неща. 

Но за да направи това, нека всъщност се напише програма. Нека вървим напред сега. И аз отивам да се създаде нова файла с натискане този малък плюс, и кликнете върху New File. 

Отивам да се спаси този следващия едно като, да речем, string.c, защото искам да играя с низове. И низ в C е просто поредица от символи. Така че сега да вървим напред и направете следното. 

Включват стандартни IO.h-- и Оказва се, стандартен IO, IO просто означава, вход и изход. Така се оказва, че тази линия тук е това, което е на нас съседните да използва ФОРМАТ. ФОРМАТ, разбира се, произвежда продукция. Така че, за да използвате ФОРМАТ, тя се превръща вън трябва да имаш този ред на код в горната част на вашия файл. 

И ние ще се върнем към това, което че наистина означава преди дълго. Оказва се, че в всяко C програма пиша, Аз трябва да го започнете с код, който изглежда така. И вие ще забележите, CS50 IDE и друга интегрирано развитие среди като това, ще се опитаме по най-добрия те могат да довърши мисълта си. Всъщност, преди малко, ако отмените това, което току-що е направил, аз удари Enter. 

тогава ударих отворена къдрава презрамки, удари Въведете отново. И го завърши мисълта си. Той ми даде нов ред, разчленена не по-малко за хубави стилистични причини ще видим. И тогава той автоматично ми даде че фигурна скоба, за да завърши мисълта си. Сега, това не винаги Предполагам, че това, което искате да направите. Но в голямата си част, тя не ви спести някои клавиши. Така че преди малко, ние се завтече този program-- здравей, свят, и след това да го съставя, и след това избяга. Но няма динамика тук. Какво става, ако искахме да направя нещо по-различно? Е, какво, ако исках да всъщност получите низ от потребителя? Отивам да се използва един пъзел парче нарича точно that-- получите низ. 

Оказва се, че в C, че когато не искате да даде своя принос за един пъзел парче, или по-правилно да се функция, можете буквално просто правя отворена скоба, близо скоби. Така че това е така, сякаш има не бяла кутия, за да въведете в полето. Блокът на речем преди имаше малка бяла кутия. Ние не разполагаме с това бяло поле сега. 

Но когато аз наричам GET низ, I Искам да сложа резултата някъде. Така че много често парадигма в C е да извикате функция, като GET низ тук, и след това се съхранява неговото връщане стойност. Това е резултат от неговата усилия в нещо. 

И това, което е най- изгради в програмирането, дали в Scratch или сега C, че ние може да се използва, за да всъщност се съхранява нещо? Наречен го променлива, нали? И в Scratch, ние наистина не пука какво се случва в променливи. 

Но в този случай, ние всъщност правим. Отивам да се каже, низ. И тогава може да се нарече това нещо, което искам. Отивам да го наречем име, получава се низ. 

И сега дори ако сте малко нови за това, забележите, че аз съм липсват някои детайли. Аз съм се забравя и запетая. Аз трябва да завърши тази мисъл. Така че аз ще преместя курсора, и удари и запетая там. И това, което съм просто направи? В този ред на код, номер 5 в момента, Обаждам GET низ, без входове. Така че няма малко бяло боксира като Save блок има. 

Просто казвам, хей, компютър, да ме низ. Знакът равно не е наистина знак за равенство, сам по себе си. Това е задачата оператор, което означава, хей, компютър, да се премести на стойност отдясно над наляво. И в ляво, имам следното. 

Хей, компютър, дайте ми string-- поредица от символи. И се обади, че низ име. А аз дори не трябва да го наричаме Име. 

Можех да го наречем, условно, нещо като S, много като използвахме аз да наричам аз променливата. Но сега трябва да направя нещо с него. Би било доста глупаво да опитайте съставянето на този код, бягане тази програма, въпреки че Аз съм се низ, защото това е все още само щях да кажа здравей свят. 

Но какво, ако аз искам да променя това. Защо не мога да направя това? Процент ите, запетая и. И това е малко загадъчен все още. 

Така че нека да ми променливи по-ясно. Нека да назовем тази променлива име. И нека да видим дали не можем да дразни освен това, което се случва тук. 

Така че по линия пет, аз съм се низ. И аз съм съхраняване че низ, каквото и потребителят е въвел в неговата или нейната клавиатура, в променлива наречена име. И се оказва, че ФОРМАТ не само отнеме един аргумент в двойна кавички, един вход в двойни кавички. 

Това може да отнеме два или три, или повече, като че втората, или третата, или четвъртата, са всички имена на променливи, или специфично стойности, която искате да включите в, динамично, че низ в кавички. С други думи, това, което Би било погрешно с това? Ако току-що казах здравей име, наклонена черта п, ми спаси файл, компилиран моя код, и изтича това, какво ще се случи? 

Това е просто ще кажа, здравей име, буквално N-А-М-E, което е един вид глупаво, защото това е по-различно от света. Така че нищо в кавички е това, което буквално ще бъде отпечатан. Така че, ако искате да имате контейнер там, Аз всъщност трябва да се използва някакъв специален синтаксис. И се оказва, ако прочетете документацията за функцията ФОРМАТ, тя ще ви каже, че ако използвате процента ите, можете да заместите стойност, както следва. 

След запетая след това двойни кавички, просто напишете името на променлива, която искате да включите в този формат код, или формат спецификатор, процента и за струни. И сега, ако съм спасен моето досие, Аз се върнем на моя терминал. И аз въведете Направи String, защото, отново, името на този файл, който аз избрах преди е string.c. 

Така че аз ще кажа Направи String, влиза. О боже мой, погледнете всички грешките, които вече сте направили. И това is-- какво, това е наистина като шест, седем Онлайн програма? Така че това е мястото, където много да бързо да се поразителен. 

Това терминален прозорец има Сега просто повтаряната огромен брой съобщения за грешки. Разбира се, аз не разполагат с повече грешки съобщения от мен реда код. И така, какво се случва? 

Е, най-добрата стратегия да се направи по всяко време се срещнете непреодолимо списък с грешки, а именно, че, се превъртите назад, търсят командата вие просто избяга, които в моя случай е да низ. Вижте какво правят направил, и това е, че дълго звън команда, не е голяма работа там. 

Но червеното е лош. Green се опитва да бъде нежна и полезно. Но тя все още е лошо, в този случай. Но там, където това е лошо? 

String.c, линия пет, характер и пет. Така че това е само обща конвенция. Нещо дебелото черво нещо означава, линия номер и номер характер. Грешка, използване на недекларирания идентификатор низ. Може би имахте предвид стандарт в? 

Така че, за съжаление, звън се опитва да бъде от полза. Но това не е наред, в този случай. Не, звън, не исках стандарт IO. Имах предвид, че на първа линия, да. 

Но линия пет е този тук. И звън не прави разбере S-T-R-I-N-G. Това е една необявена идентификатор, а Думата тя просто никога не е виждал преди. И това е, защото C, на езика пишем код в момента, не разполага с променливи, наречени струни. 

Това не е така, по подразбиране, поддръжка нещо, наречено низ. Това е CS50 парче жаргон, но много конвенционален. Но мога да поправя това, както следва. 

Ако добавите един ред код в началото на тази програма, включва CS50.h, което е друг файл някъде вътре на CS50 IDE, някъде на твърдия диск, така да се каже, на операционната система Ubuntu че Бягам, че е файла, който е Ще научи оперативната система какво низ е, просто като стандарт io.h е файла в операционната система, която е Ще го науча какво ФОРМАТ е. 

В действителност, ние би намерила много подобен съобщение ако IO е признал стандарт IO.h и се опитаха да използват ФОРМАТ. Така че аз ще отида напред и просто поеме контрола L, за да изчистите екрана си. Или можете да въведете ясна и тя ще просто изчистване на терминала. Но все още можете да превъртите назад във времето. 

И аз ще се преиграва Направи String. Стискам палци този път, Enter. О, Боже мой, той е работил. тя ми показва дълъг загадъчен команда че е това, което правят, генерирани чрез звън, но няма съобщения за грешки. Така че осъзнаваш, въпреки че вие може да получите напълно претоварени с брой съобщения за грешки, тя просто може да бъде това досадно каскаден ефект, където звън не разбира едно нещо, което значи след това не разбира следващата дума, или на следващия ред. И така, той просто дросели на вашия код. Но поправката може да се прости. И така, винаги се фокусира върху Първата линия на изхода. И ако не го направите го разбирам, просто погледнете за ключови думи, които биха могли да бъдат улики, и номера на реда, и характера, където тази грешка може да бъде. 

Сега нека да вървим напред и да въведете дот наклонена черта, низ, влиза. Хм, тя не казва здравей нищо. Защо? Е, припомни, където е тя да се пускат? 

Това е вероятно заби в момента в една линия, ако щете, на линия шест, защото Get String с дизайн, написана от персонала CS50, е буквално означава просто да си седи там и те чака, и чака, и в очакване на низ. Всичко, което разбираме под низ е човешко вход. Така ли какво? Нека да вървим напред. И просто по прищявка, нека въведете името ми, Дейвид, влиза. Сега имам по-динамична програма. Той каза, здравей Дейвид. 

Ако аз отида напред и да тичам отново, Нека се опитам да кажа Zamila име, въведете. И сега имаме динамична програма. Не съм твърд кодирани свят. Не съм твърд кодирани име, или David, или Zamila. 

Сега е много по-скоро като на програмите ние знаем, къде, ако го вземат вход, тя произвежда малко по-различен изход. Сега, това не е най-добрият потребителски опит, или UX. Аз стартирате програмата. 

Аз не знам какво трябва да се направи, освен ако аз действително погледнем или си спомня изходния код. Така че нека да се направи на потребителя изпитат малко по-добре с най-простите неща. Нека да се върнем в тази програма, и просто да се каже, ФОРМАТ. 

И нека да вървим напред и да кажа името, на дебелото черво, и пространство, а след това и запетая. И само за ритници, не хлабина п. И това е умишлено, защото аз не искам подканата да се премине към следващия ред. 

Искам да, вместо да, правя това, направи низ да компилирате кода си в нова машина код точка наклонена черта низ. Ах, това е много по-хубава. Сега аз всъщност знам какво компютъра иска от мен да направя, да го даде име. 

Така че аз ще отида напред и да въведете в Роб, влиза, и здравей, Роб. Така че, да разбере, че това е все още в края на ден, само програма за девет линия. Но сме взели тези малки стъпки. 

Писахме една линия, с които ние бяха запознати, ФОРМАТ, здравей свят. Тогава ние разкопча малко от това. И ние всъщност използва GET низ. И ние подхвърли, че стойността на една променлива. И след това отидохме напред и да се подобри това допълнително с трета линия. И този повтарящ се процес на писането на софтуер е наистина ключов. В CS50, и в живота като цяло, Вие по принцип не трябва да седне, има програма, в ума, и се опитват писане цялото проклето нещо наведнъж. 

Това неизбежно ще доведе до по начин, повече грешки, отколкото самите ние видяхме тук. Дори и аз, и до ден днешен, постоянно правят други глупави грешки, всъщност са по-трудни грешки които са по-трудно да разбера. Но ще направи повече грешки още по- реда код можете да напишете всички наведнъж. И така, тази практика на, напиши малко код че сте доволни, съставят това, стартирайте го, го тестваме по-общо, след това се премести on-- толкова просто като ние продължавахме наслояване и наслояване на миналата седмица, изграждане от нещо много лесна за нещо по-сложно, направим същото тук. Не сядайте, и се опитват да напише цяла проблем. Всъщност предприеме тези стъпки бебето. 

Сега, струни не са всичко че полезно за себе си. Ние бихме всъщност, в идеалния случай, като за има нещо друго в нашия инструментариум. Така че нека да всъщност правят точно това. 

Нека вървим напред сега и привличам малко по-различна програма. И ние ще наричаме това int.c, за цяло число. Отивам да, по същия начин, включва CS550.h. Отивам да се включва стандартен IO. И това ще е доста често срещано в тези първи няколко дни за съответния клас. 

И аз ще се готови себе си с една основна функция. И сега вместо да се низ, да вървим напред и да получите едно цяло число. Нека го наречем аз, и наричаме го получи INT, близки parens, точка и запетая. А сега нека да направим нещо с него, ФОРМАТ. 

Да кажем, че нещо подобно здравей, наклонена черта п, запетая аз. Така че аз съм доста много имитира това, което направих само преди миг. Имам запазено място тук. Аз запетая аз тук, защото искам да включите и в това контейнер. 

Така че нека да вървим напред и да се опитаме съставянето на тази програма. Файлът се нарича int.c. Така че аз отивам да се каже, да инт, влиза. О, Боже мой, но не е голяма работа, нали? Има една грешка. 

Има една синтактична грешка тук, така че програмата не може да се изготвя вътре int.c, линия седем, характер 27, формат грешка определя типа Чар звезда, каквото и да е. Но тип аргумент е инт. 

Така че и тук, ние не започваш to-- макар че днес е много материал, ние ще ви затрупвам с абсолютно всяка функция на C, и програмирането по-общо, само за тези първи няколко седмици. Така че там често се случва да бъде жаргон с които не сте запознати. И, всъщност, Чар звезда е нещо, ние ще се върнем към за една седмица или след две години. 

Но за сега, нека да видим дали можем да разбор на думите, които са запознати. Формати-- така чухме формат спецификатор, формат код преди. Това е познато. Type-- но аргументът, има тип Int. Чакай малко, аз е едно цяло число. 

Може би на сто всъщност е има някои определено значение. И наистина, го прави. Едно цяло число, ако искате ФОРМАТ да го замени, всъщност трябва да се използва различен формат спецификатор. И вие няма да знае това освен ако някой ви каже, или сте го и преди. Но процента аз е това, което може да се използва често в ФОРМАТ за включване в цяло число. Можете също да използвате процента г за десетична число. Но аз е хубаво и просто тук. Така че ние ще отидем с това. 

Сега нека да вървим напред и да разясняване изработка INT, Enter. Това е добре, няма грешки. Dot наклонена черта int-- ОК, лошо потребителски опит, защото не съм си аз какво да правя. Но това е добре. Аз съм улавяне на бързо. 

А сега нека да продължа напред и да въведете Дейвид, OK, Zamila, Роб. ОК, така че това е нещо добро. Този път, аз съм с помощта на функцията, пъзел парче, наречено GET вътр. И се оказва out-- и ние ще виж това по-късно в term-- Персоналът на CS50 е изпълнила получите низ по такъв начин, че тя ще само физически получите низ за вас. 

Тя е изпълнила GET инт в такъв начин, че тя само ще получите цяло число за вас. И ако вие, човекът, не си сътрудничат, това е буквално просто ще казват, опитайте, опитайте, опитайте отново, буквално седи там примка, докато ви задължава с някакъв магически номера, като 50, и здравей 50. 

Или ако бягаме това отново и тип в 42, здравей 42. И така функцията GET инт вътре в които пъзел парче е достатъчно логика, достатъчно мисъл, за да разбера, какво е дума? И това, което е число? Само за приемане, в крайна сметка, цифри. 

Така се оказва, че този не е всичко, което изразителен. до тук. Така че, Уау, за последен път сме мина доста бързо в игри за изпълнение, както и анимация, и художествени произведения в нулата. И тук, ние сме като съдържание с здравей свят, и здравей 50. 

Това не е всичко, което вдъхновяващо. И наистина, тези първи няколко примери ще отнеме известно време да засили в вълнение. Но ние имаме много повече контролира сега, в действителност. И ние ще се много бързо да започнете наслояване на върха на тези основни примитиви. 

Но първо, нека да се разбере какви ограничения са. Всъщност, едно от нещата, Scratch не прави лесно нека да направим, е наистина изглежда под капака, и да разберат какво е компютър е, какво може да направи, и какви са неговите ограничения. И, наистина, че липсата на разбиране, потенциално, в дългосрочен план може да доведе до нашата собствена mistakes-- писане бъгове, писане несигурен софтуер, който бъде хакнат по някакъв начин. 

Така че нека да се вземат някои стъпки към разбирането на това малко по-добре от начин на, да речем, на следния пример. Отивам да вървим напред и да приложат недвижими бърза програма, наречена Адер. Подобно, нека добавим някои числа заедно. И аз отивам да се кодират някои ъгли тук, и просто да копирате и поставяте където бях преди, просто за да можем да се върви по-рано. Така че сега аз имам основните началото на програма, наречена Адер. 

И да вървим напред и да направим това. Отивам да се продължи напред и да речем, intx получава получите вътр. И знаеш ли какво? Нека да направим един по-добър потребителски опит. 

Така че нека просто кажем, х е и ефективно напомни на потребителя, за да ни даде х. И тогава нека вървим напред и да се каже, ФОРМАТ как за Y е, този път очаквах две стойности от потребителя. И тогава нека просто отидете напред и например, ФОРМАТ, сумата на х и у е. И сега аз не искам да се правя на сто ите. Искам да направя процента аз, наклонена черта п, и след това включете стойност сума. 

И така, как мога да го направим? Знаеш ли какво? Знам как да се използват променливи. Нека само да обяви нов, инт Z. 

И аз ще взема предположение тук. Ако има еднакви знаци в тази език, може би аз просто могат да направят х плюс Y, толкова дълго, колкото да прекратя моят мислеше с точка и запетая? Сега мога да се върна тук, включете Z, завърша тази мисъл с точка и запетая. И нека да видим сега, ако те последователности на lines-- Х се получи вътр. Y е да се инт. 

Добави х и у, съхраняване на стойността в z-- така, отново, не забравяйте, знака за равенство не е равно. Това е задача от дясно на ляво. И нека да разпечатате, че сумата на х и у, не е буквално Z, но това, което е вътре на Z. Така че нека да направим Адер - хубаво, няма грешки и този път. Dot наклонена черта Адер, влиза, х ще бъде 1. 

Y ще бъде 2. И сумата на х и у е 3. Така че всичко е наред и добра. 

Така че можете да си представите, че математиката трябва да работи в програма като тази. Но знаете ли какво? Дали тази променлива, линия 12, дори е необходимо? Не е нужно да получите в навик от просто съхраняване неща в променливи просто защото можете. И в действителност, това е като цяло смята за лош дизайн ако желаете да създадете променлива, наречена Z в този случай, съхраняване нещо в нея, и след това веднага да го използвате, но никога отново. Защо се получи нещо име като Z, ако сте буквално Ще използваме, че нещо само веднъж, и така близкия до мястото, където сте създали че на първо място, толкова близо по отношение на реда код? Така ли какво? Оказва се, че C е доста гъвкав. Ако действително искате да плъг-ин ценности тук, Не ми трябва да обяви нова променлива. Можех само да включите в х плюс Y, защото C разбира аритметика, и математически оператори. 

Така че аз може просто да се каже, да направите това по математика, х плюс Y, независимо от тези стойности са, включете получения число в тази поредица. Така че това може да се окаже, че само един ред по-кратък, по-добър дизайн, по-добра програма, защото там е по-малко код, следователно по-малко за мен да се разбере. И това е също само по-чист, дотолкова, доколкото ние не сме въвеждане на нови думи, нови символи, като Z, въпреки че те наистина не служат много на целта. 

За съжаление, математиката не е всички, че надеждни понякога. Да вървим напред и да направим това. Отивам да се продължи напред сега и направете следното. 

Нека да направим ФОРМАТ, процента аз, плюс процента аз, ще бъде процента аз, наклонена черта п. И аз ще направя this-- xyx плюс ш. Така че аз съм просто ще пренапише това малко по-различно тук. Нека само да се направи бърза проверка здрав разум. Отново, нека да не го изпревари на себе си. Направи ехидна, точка наклонена черта ехидна. х е 1, Y е 2, 1 плюс 2 е 3. Така че това е добро. Но нека да усложни това сега малко, и да се създаде нов файл. 

Отивам да наричаме това един, се каже, цели числа, множествено число за числа. Позволете ми да започна, когато бях преди малко. Но сега нека да направим няколко други линии. Нека да вървим напред и да направите следното, ФОРМАТ, процента аз, минус процента аз, е процента аз, запетая х, запетая YX минус у. Така че аз съм това леко различна математика там. Нека да направим още един. Така процента I пъти процента аз е процента аз, наклонена черта п. Нека приставки х и у, и х пъти у. Ще използваме звездичката на вашия компютър за пъти. 

Не използвайте х. х е променлива име тук. Можете да използвате звездата за умножение. Нека да направим още един. ФОРМАТ процента I, раздели от процента аз, е процента аз, наклонена черта п. XY, разделено на y-- така че можете да използвате наклонената черта в C да се направи разделение. И нека да направим един друг. Останалата част от процента аз, разделена от процента аз, е процента аз. xy-- и сега остатък е това, което е останало. Когато се опитате раздели знаменател в числител колко е останало, че Вие не може да се разделят навън? 

Така че там не е наистина, непременно, символ сме използвали в началното училище за това. Но има в C. Можете каже х модул Y, където този знак за процент в този context-- объркващо, когато сте вътре на двойните кавички, вътре на ФОРМАТ, процента се използва като спецификатор на формат. 

При използване на сто извън че в математически израз, това е операторът на модул за модулна arithmetic-- за нашите цели тук, просто означава, това, което е най- остатък от х, разделено на Y? Така х разделено на у е х черта у. Какво е остатъка от х, разделено на Y? Това е х мод Y, като програмист ще каже. 

Така че, ако аз направих никакви грешки тук, нека давай напред и да направи цели числа, множествено число, хубаво, и дот наклонена черта цели числа. И да вървим напред и да направя, да речем, 1, 10. Добре, 1 плюс 10 е 11, чек. 1 минус 10 е отрицателен 9, провери. 

1 пъти 10 е 10, чек. 1 делено на 10 is-- ОК, ние ще пропусна, че един. Остатък от 1 делено на 10 е 1. Това е правилното. Но има бъг в тук. 

Така че този, който аз си сложа предадат, не е вярна. Искам да кажа, че е близо до 0. 1 делено на 10, знаеш ли, ако сме рязане на някои ъгли, сигурен, че е нула. Но тя наистина трябва да е 1/10, 0.1 или 0.10, 0,1000, или др. 

Тя не трябва наистина да бъде нула. Е, оказва се, че компютърът е прави буквално това, което ние го каза да направя. Ние правим математика като х разделени от ш. И двете х и у, на линиите от код по-рано, са цели числа. 

Освен това, по линия 15, ние сме казва ФОРМАТ, хей, ФОРМАТ приставка цяло число, плъг-ин цяло число, приставки в integer-- конкретно X, Y и след това, след х разделен Y. х и у са цели числа. Ние сме добре там. 

Но това, което се х делено на х? X разделен Y трябва да бъде, математически, 1/10, или 0.1, което е реално число, реално число като потенциално десетична запетая. Това не е цяло число. 

Но това, което е най-близо число на 1/10, или 0,1? Да, това вид е равна на нула. 0.1 е като този много. А 1 е това много. Така че 1/10 е по-близо до 0, отколкото е една. 

И така, какво C върши за us-- вид, защото ние го каза to-- се съкращава това число. То е като стойността, която отново е Предполага се, че нещо подобно 0.1000, 0 и така нататък. И това е съкращаване всичко след десетичната запетая така че цялата неща, защото това не е така поберат в представата на цяло число, което е просто номер като отрицателна 1, 0, 1, нагоре и надолу, да го изхвърля всичко след десетичната запетая, защото не може да се побере десетична запетая в цяло число, по дефиниция. 

Така че отговорът тук е равна на нула. И как ще се определи това? Имаме нужда от друго решение всички заедно. И ние можем да направим това, както следва. 

Нека да вървим напред и да се създаде нова файл, това се нарича floats.c. И го спаси тук в същата директория, float.c. И нека да вървим напред и да копирате някои от които код от по-рано. 

Но вместо да се пад, нека да направим това. Дай ми една плаваща точка стойност нарича х. където с плаваща точка стойност е просто буквално нещо с плаваща запетая. Тя може да се движи наляво, надясно. Това е реално число. 

И нека да не се обадя получите инт, но се поплавък, който също бе сред менюто на опции в библиотеката C250. Нека у смените с поплавък. Така че това става получите плувка. 

И сега, ние не искаме да се включите в цели числа. Оказва се, че трябва да използвате на сто е за плувка, процента е за плувка, и сега го спаси. И сега, стискаме палци, да поплавъци, Ница, дот наклонена черта плувки. х ще бъде един 1. Y Ще бъде 10 отново. 

А, хубаво, OK допълнение ми е правилен. Надявах се за повече, но аз забравих да го напиша. Така че нека да отиде и да се фиксира тази логическа грешка. 

Да вървим напред и да вземете следното. Ние просто ще направя малко копиране и поставяне. И аз ще кажа минус. 

И аз ще кажа пъти. И аз отивам да се каже, разделена. И аз няма да направя модул, който не е уместен тук, разделена от F, и пъти plus-- ОК, нека да направим това отново. 

Направи плувки, дот наклонена черта поплавъци, и 1, 10, and-- хубаво, не, OK. Така че аз съм идиот. Така че това е много често по компютърни науки да направи глупави грешки като тази. 

За педагогически цели, това, което аз наистина исках да направя се променят науката тук до плюс, минус, за да пъти, и да се разделят, както можете да се надяваме забелязал по време на това упражнение. Така че сега нека отново да се съберат тази програма, направете дот наклонена черта плувки. 

И за трети път, нека да видим дали тя отговаря на очакванията ми. 1, 10, влиза, да, ОК, 1.000, разделена от 10.000, е 0,100000. И се оказва, ние може да контролира колко номера са след тези десетични точки. Ние всъщност няма. Ще се върнем към това. 

Но сега, в действителност, по математика е правилно. Така че, отново, това, което е храна за вкъщи тук? Оказва се, че в C, има не само просто strings-- и, всъщност, там не са много, защото ние добавете тези с библиотеката CS50. Но там не са само цели числа. 

Има също така плува. И се оказва, един куп други данни видове прекалено, които ще използваме, преди дълго. Оказва се, че ако искате един-единствен характер, не низ от знаци, можете да използвате само един знак. 

Оказва се, че ако искате булев, булева стойност, вярно или само неверни, благодарение на библиотеката CS50, ние сме прибавя към С типа BOOL данни, както и. Но също така е да представи в много други езици, както добре. И се оказва, че понякога нужда от по-големи числа след това идват по подразбиране с цели числа и плувки. 

И, всъщност, двойно е число който използва не 32 бита, но в 64-бита. И много, много дълго е номер, който употреби не 32, бита, но в 64-бита, съответно, за плаваща запетая ценности и цели числа, съответно. Така е нека всъщност сега виж това в действие. 

Отивам да се продължи напред тук и привличам една друга програма. Ето, аз ще отида напред и не включва CS50.h. И да ме пусне, включват стандартни IO.h. 

И вие ще забележите нещо фънки се случва тук. Това не е цветово кодиране неща в по същия начин, както преди. И се оказва, че е така, защото аз не са дали нещо на име на файл. 

Отивам да наричаме това един sizeof.c, и удари Save. И забележи какво се случва с моя много бяло код срещу това черен фон. Сега, най-малко има някои лилаво в там. И това е синтаксис подчертани. 

Това е, защото, честно казано, аз съм заяви пред IDE какъв тип файл тя е като му дава име, и специфично разширение на файл. Сега, нека да вървим напред и да направим това. Отивам да се продължи напред и много просто разпечатате на following-- Булева е процента LU. 

Ще се върнем към че в един момент. И тогава аз ще размер на печат на булев. И сега, само за да спаси себе си известно време, аз съм ще направим цяло куп от тях наведнъж. И по-конкретно, аз ще промените това до Чар и Чар. Това едно, аз отивам да се промени до едно двойно и едно двойно. 

Това едно, аз отивам да се промени на плувка и на плувка. Това едно, аз ще Сменете на инт и пад. А това, аз ще съм да се промени, за да дълго дълго. И това е още като дълго време, дълго, дълго. 

И тогава, накрая, дадох себе си твърде много, низ. Оказва се, че в C, има специален оператор, наречен размер на която е буквално ще, когато стартирате, ни каже размера на всяка от тези променливи. И това е начин, сега, ние може да се свърже обратно за обсъждане от миналата седмица на данни и представителство. 

Нека да вървим напред и да съставят размер на дот размер черта на. И нека да видим. Оказва се, че в C, специално на CS50 IDE, специално на операционна система Ubuntu, който е 64-битова операционна а система в този случай, на булев ще използвате пространство от един байт. Ето как се измерва размера, не в бита, но в байтове. И припомни, че един байт е осем бита. Така че един булев, въпреки че технически само се нуждаят от 0 или 1, това е малко разточителни как сме го реализира. Това всъщност ще използваме цяло byte-- така всички нули, са може би всички хора, или нещо подобно, или просто един 1 сред осем бита. 

А Чар, междувременно, се използва за герой като Ascii характер на миналата седмица, ще бъде един символ. И това синхронизира с нашето разбиране за да е не повече от 256 bits---скоро, синхронизира с него е не повече от 8 бита, които ни дава толкова, колкото 256 стойности. Двойно ще се да е 8 байта или 64 бита. 

А плувка е 4. Пад е 4. А дълго, дълго е 8. И низ е 8. Но не се тревожи за това. Отиваме да се бели обратно този слой. Оказва се, струни могат да бъде по-дълъг от 8 байта. 

И наистина, ние написахме струни вече, здравей свят, повече от 8 байта. Но ние ще се върнем към че в един момент. Но отнеме тук е следното. 

Всеки компютър има само ограничен количество памет и пространство. Можете да съхранявате само толкова много файлове на вашия Mac или PC. Можете да съхранявате само толкова много програми в RAM работи наведнъж, непременно, дори с виртуална памет, защото имате ограничен размер на RAM. 

И само за да picture-- ако никога не сте отворени за лаптоп или поръча допълнителна памет за компютър, можете може и да не знаят, че вътрешността на компютъра си е нещо, което изглежда малко като този. Така че това е само една обща компания, наречена Решаващо значение, че прави RAM за компютри. И RAM е мястото, където програми живеят, докато те вървят. 

Така че за всеки Mac или PC, когато се удвои кликнете програма, и тя се отваря, и тя се отваря някакъв документ Word Или нещо такова, то тя съхранява временно в RAM, защото RAM е по-бързо от вашия твърд диск, или Вашата твърдо състояние диск. Така че това е точно там, където програми вървят да живее, когато те се изпълняват, или когато се използват файлове. 

Така че има неща, които изглеждат като тази във вътрешността на вашия лаптоп, или малко по-големи неща вътре на вашия работен плот. Но ключът е имате само един краен брой от тези неща. И има само ограничен брой хардуер седи на това бюро полето тук. 

Така че, разбира се, не можем да се съхранява безкрайно дълги числа. И, все пак, ако мислите, че обратно на началното училище, колко цифри могат имате в дясно на десетична точка? За този въпрос, колко цифри могат имате в ляво на десетичната точка? Наистина, безкрайно много. 

Сега, ние, хората само мощ Как се произнася милиона, и милиард, трилион, и квадрилиона, и квинтилиона. И аз съм бутане на границите на моя understanding-- или my-- Разбирам номера, но ми произношение на номера. Но те могат да получат безкрайно голяма с безкрайно много Цифрите от ляво или отдясно на десетичната запетая. 

Но компютри имат само ограничен размер на паметта, краен брой транзистори, а краен брой крушки вътре. Така че това, което се случва, когато да изтече на пространството? С други думи, ако сте мисля, обратно на миналата седмица когато ние говорихме за номера самите са представени в двоичен, Предполагам, че ние имаме този 8-битова стойност тук. 

И ние имаме седем 1 и една 0. И предполагам, че искаме да се добави 1 до тази стойност. Това е наистина голям брой точно сега. 

Това е 254, ако си спомням по математика от миналата полето седмица. Но какво, ако сменя че дясната 0 до 1? Цялото число, на Разбира се, става осем 1 е. Така че ние все още сме добри. 

И това вероятно представлява 255, въпреки че в зависимост от контекста тя действително може да представлява отрицателно число. Но повече за това друг път. Това се чувства като това е за толкова високо, колкото мога да разчитам. 

Сега, това е само 8 бита. И ми Mac, със сигурност, има начин повече от 8 бита памет. Но тя има ограничен. Така че същия аргумент се прилага, дори ако ние има повече от тези хора на екрана. 

Но какво се случва, ако сте съхраняване на този номер, 255, и искате да брои 1 малко по-висока? Вие искате да отидете от 255 до 256. Проблемът, разбира се, е, че ако започне преброяване на нула, като през миналата седмица, Вие не може да се брои за високо 256, да не говорим за 257, да не говорим за 258, m, защото това, което се случва, когато добавите 1? Ако го направите стария клас училището подход, ти сложи 1 тук, и след 1 плюс 1 е 2, но това е наистина е нула, което носите на 1, извършване на 1, носи 1. Всички тези неща, тези 1 е, отиват до нула. И вие внесено, да, както някой изтъкна, а 1 на лявата ръка. Но всичко, което може всъщност се види и се поберат в паметта е само на осем 0, която е да се каже, в един момент, ако, компютър, Опитах се да броим достатъчно високо, вие сте ще обгърне, изглежда, до нула, или може би дори отрицателен числа, които са дори по-ниски от нула. 

И ние можем да вид видите това. Нека да вървим напред и да напише истински бърз програма тук. Нека да вървим напред и да напише програма, наречена от преливане. Включи CS50.h, включете стандарт IO.h-- о, Аз наистина липсваше ми оцветяване на синтаксиса. Така че нека да спаси това, както overflow.c. 

И сега INT главната void-- и не след дълго, ние ще се върне към обяснява защо пазим написването INT главната невалидни. Но за сега, нека просто да се направи това, да го приемате за даденост. Нека да се даде едно цяло число, и го инициализира на 0. 

Нека тогава да направим за инт да получа zero-- Всъщност, нека да направим един безкраен цикъл и да видим какво ще стане. Докато е вярно, тогава нека да разпечатате п е процента аз, наклонена черта п, плъг-ин п. Но, сега, нека да направим п получава п плюс 1. 

С други думи, на всеки повторение на този безкраен цикъл, нека да стойност н е, и се добавя 1 към него, и след това съхранява резултата обратно в н в ляво. И, всъщност, ние сме виждали синтаксис леко като това, за кратко. Готин трик е вместо от написването всичко това, Всъщност може да се каже за п плюс е равно на 1. 

Или, ако наистина искате да се фантазия, може да се каже п плюс плюс точка и запетая. Но тези последните две са само това, което ние бихме се обадя синтактична захар за първото нещо. 

Първото нещо, което е по-ясно, напълно глоба, напълно правилно. Но това е по-често, което ще кажа. Така че ние ще направим това само за миг. 

Нека сега да преливат, което звучи -скоро зловещо, точка наклонена черта преливник. Нека да видим, п Става доста голям. Но нека помислим, колко голям може да п получите? 

п е Int. Видяхме преди малко с размера на Например, че едно цяло число е четири байта. Ние знаем от миналата седмица, четири байта е 32 бита, защото 8 пъти 4, това е 32. Това ще бъде 4 милиарда. 

И ние сме до 800,000. Това ще отнеме цяла вечност, за да брои толкова висока, колкото евентуално може. Така че аз ще отида напред, както може би не след дълго, и натиснете Control C-- честно казано, Control C, много, където Control C обикновено средства анулират. За съжаление, поради тази работи в облака, понякога облакът е плюе толкова много неща, толкова много продукция, то се случва да отнеме малко повече време за моя вход да стигнем до облака. Така че, въпреки че аз се удари Control C преди няколко секунди, това определено е на страната ефект на един безкраен цикъл. 

И така, в такива случаи, ние сме Ще оставим това да бъде. И ние ще се добавят още терминален прозорец тук с плюса, което разбира се не е така по този начин, тъй като тя все още мисли. И да вървим напред и да бъде малко по-разумен. 

Отивам да вървим напред и да се направи това само краен брой пъти. Нека да се използва за линия, които споменах по-рано. Да го направим. Дай ми още една променлива INT I получава 0. аз е по-малко, отколкото, да речем, 64 аз ++. А сега нека да вървим напред и печат от п е процента аз, запетая п. И тогава, N- това все още е ще отнеме завинаги. Да го направим. 

п получава п пъти 2. Или можем да се фантазия и правя пъти е равно на 2. Но нека просто кажем, п Самата равнява, пъти 2. С други думи, в тази Новата версия на програмата, Аз не искам да чакам вечно от подобно 800,000 до 4 милиарда. Нека просто да приключваме с. 

Нека всъщност удвои н всяко време. Което, изземване, удвояване е противоположна на като, разбира се. И докато миналата седмица имаме нещо отново и отново, и отново, супер бързо, удвояване със сигурност ще ни получи от 1 до възможно най-голям стойност, че можем да разчитаме на с вътр. 

Така че нека да направим точно това. И ние ще се върнем към това, преди дълго. Но това, отново, е точно като на повторение блок в Scratch. И вие ще използвате този преди дълго. 

Това просто означава, броене от нула до, но не е равна, до 64. И на всяка итерация на тази контур, само имайте увеличаване аз. Така че аз ++ - и тази обща структура по линия 7 е просто супер общ начин от повтаряне на някои линии на код, някои брой пъти. Кои реда код? Тези фигурни скоби, както ви може да са придобит от предприятието, означава, направете следното. 

Това е в подобно Scratch, когато тя има жълтите блокове и други цветове, които вид прегърне или прегърне други блокове. Ето какви са тези къдрава скоби правят тук. Така че, ако аз имам синтаксис ми right-- ви може да видите символа на моркови в C средства това е колко пъти съм бил опитвайки се да реши този проблем. Така че нека да се отървете от това един напълно, и да затворите този прозорец. И ние ще използваме новия. Направи преливник, точка наклонена черта преливник, Enter, всичко е наред, тя изглежда зле в началото. Но нека да превъртите назад във времето, защото аз направих това 64 пъти. 

И забележи първи път, п е 1. За втори път, п е 2, след 4 и след това 8, след това 16. И изглежда, че веднага след като Да стигна до приблизително 1 милиард, ако го удвои отново, че трябва да ми даде 2 млрд. Но се оказва, че е полето на прага. 

И така, тя всъщност е залято пад от 1 милиард до приблизително отрицателна 2 милиарда, защото цяло число, за разлика от номера ние, бяха предположи миналата седмица, може да бъде както положителен и отрицателен в действителност и в компютър. И така, най-малко един от тези, бита, е действително откраднати. Така че ние наистина имаме само 31 бита, или 2 милиарда възможни стойности. 

Но за сега, на храна за вкъщи е доста просто, независимо от тези номера са и каквото и математиката е, нещо лошо се случва в крайна сметка, защото в крайна сметка, който се опитвате да пермутиране на битовете един твърде много пъти. И действително премине от всичко 1, за да може би всички 0 е, или може би просто някакъв друг модел, който го Ясно е, че в зависимост от контекста, може да се тълкува като отрицателно число. И така, това би изглеждало най-високата I може да разчита в този конкретен програма е само около 1 млрд. Но има частично решение тук. Знаеш ли какво? 

Нека да се промени от INT за дълго дълго. И нека да вървим напред тук и say-- Отивам да имат да се промени това да неподписан дълго. Или, нека да видим, никога не съм се помня. 

Да вървим напред и да преливат. Не, не е това, LLD, благодаря ви. Така че понякога звън може да бъде полезно. Аз не помня какво формат спецификатор е за дълго дълго. 

Но, наистина, звън ми каза. Green е някакво добро, все още означава, че сте направили грешка. Тя се познае, че имах предвид LLD. 

Така че нека да вземе това е съвет, дълго дълго десетичен номер, освен това. И нека да го повтаря отново, с точка наклонена черта преливник, Enter. А сега какво е готино е това. 

Ако превъртите назад във времето, ние все още се започне преброяване в същото place-- 1, 2, 4, 8, 16. Забележете, ние получаваме всички начин до 1 млрд. Но след това спокойно можем да стигнем до 2 млрд. 

След това стигаме до 4 милиарда, След 8 милиарда, 17 милиарда. И да отидем по-висока, а по-висока и по-висока. В крайна сметка, това също паузи. 

В крайна сметка, с дълъг дълго, който е 64-битова стойност, не стойност на 32-битова, ако броим твърде висока, можете увийте около 0. И в този случай, ние се случи да в крайна сметка с отрицателно число. 

Така че това е проблем. И се оказва, че този проблем не е всичко, което тайнствена. Въпреки, че аз съм умишлено то индуцира с тези грешки, Оказва се, ние го видите вид всички около нас, или поне някои от нас правят. 

Така че в Lego Star Wars, ако което някога съм играл играта, Оказва се, можете да отидете около чупене неща в LEGO свят, и събиране на монети, по същество. И ако някога сте се играе тази игра твърде много време, като този безименен индивид тук е направил, от общия брой на монети, които можете да събирате е, изглежда, 4000000000. 

Сега, с това е всъщност закръглено. Така LEGO се опитва да пазят нещата удобни за ползване. Те не го е направил точно 2 до на 32 мощност, за миналата седмица. Но 4000000000 е причина. Изглежда, въз основа на тази информация, че LEGO, и компанията, която направи това действителното софтуер, реши че максималният брой на монети потребителят може да се натрупват е, наистина, 4 милиарда, защото те са избрали в техния код да се използват не по-дълго, дълго, очевидно, но само цяло число, неподписана цяло число, само положително цяло число, чиято макс стойност приблизително е, че. Е, тук е друга забавна един. Така в игра цивилизация, която някои от вас може да е запознат, с Оказва се, че преди години там е бъг в тази игра, при която ако играе ролята на Ганди в играта, вместо него е много пацифист, вместо беше невероятно, невероятно агресивен, при някои обстоятелства. По-специално, начинът, по който Civilization произведения е, че ако играчът, приеме демокрацията, си агресивност на полувремето получава декрементирани от две, така минус минус, а след това минус минус. 

Така че ви извадим 2 от действителната следващите стъпки. За съжаление, ако си следващите стъпки е първоначално 1, и изваждате 2 от него след приемането на демокрацията като Ганди тук, може да са направили, защото той беше много passive-- 1 по скалата на агресивност. Но ако той приеме демокрацията, тогава той отива от 1 до отрицателен 1. 

За съжаление, те бяха използване на неподписани номера, което означава, че те третират дори отрицателен номера, като че ли те са били положителни. И се оказва, че положителен еквивалент на отрицателна 1, в типичните компютърни програми, е 255. Така че, ако Ганди приема И следователно демокрация има неговата агресивност полувремето намалял, тя всъщност се търкаля около 255 и го прави най- агресивен характер в играта. Така че ви Може ли Google нагоре по този въпрос. И това е, наистина, един случайно програмен бъг, но че е влязъл доста ерудиция и досега. 

Това е всичко, забавно и сладко. По-страшно е, когато действителното реалния свят устройства, а не игри, имат същите тези грешки. В действителност, само преди година беше една статия повече за Dreamliner Boeing 787. 

И статията на първа поглед чете малко тайнствена. Но той каза, че това, софтуер уязвимост в Боинг Новият 787 Dreamliner струя има потенциала да предизвика пилоти да загуби контрол над въздухоплавателното средство, евентуално в средата на полета, служителите на FAA предупредени авиокомпаниите наскоро. Беше определяне че един модел 787 самолет, който е задвижван непрекъснато в продължение на 248 дни може да загуби всичко променлив ток, AC, електрическа енергия поради генератора уреди за управление, GCUs, едновременно навлиза в провалят безопасен режим. Това е нещо ме губи. Но бележката заяви, ОК, сега аз имам това, условието е бил причинен от софтуер противодействие на вътрешната да контрол на генератор единици, които ще се преливат след 248 дни на непрекъснато захранване. Ние се издава този забележите, за да се предотврати загуба на всички AC електрически мощност, което може да доведе до загуба на контрол на самолета. 

Така че, буквално, има известно число, или някакъв подобен вид данни, се използва в софтуер в действителен самолет че ако продължаваш да си самолет за достатъчно дълго време, което очевидно може да бъде случаят, ако сте само тичане ги постоянно и никога не изключвате вашия самолет, изглежда, или отдаване под наем на своите батерии умират, в крайна сметка ще брои, и нагоре, и нагоре, и нагоре, и нагоре, и нагоре. 

И, по природа, а ограничен размер на паметта ще прелее, подвижен гръб към нула или някаква отрицателна стойност, страничен ефект от които е плашещо реалната действителност че самолетът може да се наложи да се рестартира, ефективно, или може да падне, по-лошо, тъй като мухи. Така че тези видове проблеми са все още с нас, even-- това беше 2015 статия, още по-страшно когато не е задължително разбираме, оценяваме, или предвиждане тези видове грешки. 

Така се оказва, че има един друг Лошото представяне на данни. Оказва се, че дори и плувки са вид на погрешна, защото плувки, твърде, Предложих са 32 бита, или може би 64, ако използвате два пъти. Но това е все още ограничен. 

И уловката е, че ако можеш сложи един безкраен брой на номера след десетичната точка, не е ли начин може да представлява всичко възможно номера, които ни учеха в началното училище може да съществува в света. Компютър, по същество, трябва да изберете подмножество от тези номера да представлява точно. 

Сега, че компютърът може да кръг може би малко, и може да ви позволи да се грубо магазин всеки номер, който може да искате. Но просто интуитивно, ако да има краен брой битове, можете да ги пермутиране само в толкова много крайни начини. Така че не може да използват краен брой на пермутация на битовете, модели на нули и единици, да представлява една безкрайна брой номера, което предполага, че компютрите мощ много добре да бъде разположена на нас понякога. 

Всъщност, нека да направим това. Нека да се върнем в CS50 IDE. Нека да вървим напред и да създаване на малка програма наречен неточност, за да покаже, че компютри са, наистина, неточни. 

И нека да вървим напред и да се започне с някои от които код от преди, и сега просто направете следното. Нека да вървим напред и да направим ФОРМАТ, процента е, наклонена черта п, 1 делено на 10. С други думи, нека да се потопите още по-дълбоко 1/10, като 1 и делено на 10. Разбира се, един компютър може да представлява 1/10. 

Така че нека да вървим напред и да направи неточност. Да видим. Формат уточнява въведете двойно. Но аргументът, има тип Int. Какво става? 

О, интересно, така че това е поука от преди. Аз казвам, хей, компютър шоу ми с плаваща запетая с процента е. Но аз съм го даде 2 цели числа. Така се оказва, че може да се определи това в няколко начина. 

Мога просто да се превърне един в 1.0, и 10 в 10.0, което би, наистина, има ефект на превръщане ги в floats-- все още се надяваме, същия номер. Или се оказва, че има нещо ще видим отново след дълго. Може да се хвърли на номерата. 

Можете да използвате това в скоби, израз, може да се каже, хей, компютър, да вземе това 10, което знам, е едно цяло число. Но това лечение, моля, като че ли това е поплавък. Но това се чувства ненужно сложни. 

За нашите цели днес, нека просто буквално точкови стойности да ги направи плаващ с десетична запетая, като този. Нека да вървим напред и разясняване, направи неточност, добър, точка наклонена черта неточност, влиза. ОК, ние не търсим добър. 

1 делено на 10, според моето Mac тук, е, наистина, 0,100000. Сега, аз се преподава в началното училище има трябва да бъде безкраен брой 0 на. Така че нека поне да опита за да видите някои от тези. Оказва се, че ФОРМАТ е малко любител все още, отколкото ние сме били използване. Оказва се, че не е нужно да се уточни Просто процента е, или просто процента аз. Всъщност можете да укажете някои опции за контрол тук. 

По-конкретно, аз ще съм да се каже, хей, ФОРМАТ, всъщност ми покаже 10 знака след десетичната запетая. Така че изглежда малко странно. Но вие казвате процента, DOT, колко много номера искате да видите, след като на десетична запетая, а след това е за плосък, просто защото това е това, което се казва в документацията. Нека да вървим напред и да спаси това. 

И забележите също, аз съм се уморени от преписва неща. Така че аз съм просто определяне на състава и стрелка надолу на ключовете си тук. И ако аз да потегля нагоре, вие може да видите всички команди че съм направил, или неправилно направени. 

И аз ще отида напред сега и всъщност не използва това, очевидно. Направи неточност, точка наклонена черта imprecision-- така това, което се преподава в началното училище проверява навън. Дори и да го отпечатате до 10 десетични тя поставя, наистина, е 0,10000. Но знаете ли какво? 

Нека да се получи малко алчни. Да кажем, като, покажи ми 55 точки след десетичната. Нека наистина да вземе това програмира се за въртене. Нека да го правя отново с грим неточност, точка наклонена черта, неточност. 

И тук отиваме. Вашето детство беше лъжа. Очевидно, 1, разделен на 10 е наистина 0.100000000000000005551115123-- 

Какво става? Е, оказва се, ако ви вид изглежда достатъчно далеч в базисния представителство на тази брой, то всъщност не е точно 1/10, или 0.1 и безкраен брой нули. Сега, защо е това? 

Е, въпреки че това е проста брой на нас, хората, 1 делено на 10, тя все още е една от безкрайно много числа, които бихме могли да измислят. Но един компютър може само да представлява краен брой, така номера. И така, ефективно, това, което компютър се показва ни е нейната най-близо приближение до броя ние искаме да вярваме, че е 1/10, или наистина 0,10000 до безкрайност. 

По-скоро, обаче, това е толкова близо, колкото той може да получи. И наистина, ако се вгледате под капака, тъй като ние сме тук като погледнете 55 цифри след десетичната, ние всъщност виждаме, че реалността. Сега като настрана, ако сте виждал на movie-- повечето от вас вероятно haven't-- но преди Супермен 3 от няколко години, Ричард Прайър същество отнесена тази реалността в компанията му да открадне много на фракции и части от стотинката, защото company-- доколкото си спомням, това е било while-- е по същество изхвърлите всичко, което не се вписва в понятието цента. 

Но ако добавите всички тези малки, малки, малки номера отново и отново, и отново, можете, като в неговия случай, направи добра сума пари. 

Същата идея беше излъган от по-нова, но все пак сега по-стари филм, наречен Office Space, където момчетата в този филм, направи същото нещо, го прецаках напълно, завърши с твърде много пари в тяхната банкова сметка. Всичко беше много подозрителен. Но в края на деня, неточност е навсякъде около нас. 

И това също може да бъде плашещо случая. Оказва се, че Супермен 3 и офис площи под угар, там могат да бъдат някои много реален световни последици на реалностите на неточни представяне на данни че дори и ние, хората, към този ден не е задължително разбере, както и ние трябва, или си спомня толкова често, колкото би трябвало. И наистина, на следващия клип е от разгледаме някои много реален свят Последиците от това, което се случва, ако не ценят неточността, че може да се случи в числа представителство. 

[Възпроизвеждане на видео] 

-Computers, Ние всички сме дойде да приеме най-често разочароващ проблемите, които отида с them-- бъгове, вируси, и софтуерни проблеми, за малки цени да плащат За удобство. Но в високите технологии и висока скорост военни и космическата програма приложения, най-малкият проблем може се възвеличи в бедствие. 

На 4 юни, 1996 г., изготвени учени да започне безпилотен Ariane 5 ракета. Тя носеше научна спътници, предназначени за да се установи как точно магнитното поле взаимодейства Земята със слънчеви ветрове. Ракетата е построен за Европейската космическа агенция, и излетя от неговото съоръжение на брега на Френска Гвиана. 

-При Около 37 секунди след началото полета, те за първи път Забелязах, че нещо не е наред. Дюзите са въртящи се в начин те наистина не трябва. Около 40 секунди след началото на полета, Ясно е, че превозното средство е в беда. 

И това е, когато те направиха решение, за да го унищожи. Служителят по безопасността гама, с огромни вътрешности, натисна бутона, взриви ракетата, преди да може да се превърне в опасност за обществената безопасност. 

-Това Беше девойката плаване на Ариана 5. И неговото унищожение пое поставете заради дефект вградена в софтуера на ракетата. -В Проблем на Ариана беше че има номер, изисква 64 бита да изразят. И те искаха да конвертирате то на номер 16-битов. Те Предполага се, че номер никога не се случва да бъде много голяма, че повечето от тези, цифри в номера на 64-битов са нули. Те са били погрешни. 

-В Неспособността на една софтуерна програма, за да приемете вида на номер, генериран от друг е в основата на провала. Разработка на софтуер се е превърнала в много скъпо част от новата технология. The Ариана ракетата са били много успешно, така че голяма част от софтуера създаден за това е също използвана в Ариана 5. 

-В Основен проблем е, че Ариана 5 е по-бързо, по-бързо се ускори. И софтуерът не е имал отчита, че. 

-В Унищожаване на ракетата Беше огромна финансова катастрофа, всичко се дължи на грешка на минута софтуер. Но това не е първият, проблеми за преобразуване на данни време бе измъчван модерна ракета технология. 

-В 1991 г., с началото на първата война в Залива, на Patriot ракети преживя подобен вид на проблем номер преобразуване. И като резултат, 28 души, 28 американски войници, са били убити, а около 100 ранени, когато Patriot, които е трябвало за защита срещу входящи ракети Скъд, не успя да изстреля ракета. 

-Когато Ирак нападна Кувейт, и Америка стартира Пустинна буря в началото на 1991 г., Patriot ракетни батареи бяха разгърнати да защити Саудитска Арабия и Израел от иракските нападения с ракети Скъд. Патриотът е среден обсег на САЩ повърхност на въздуха система, произведен от компанията Raytheon. 

-В Размер на прехващача Patriot себе си е дълъг около приблизително 20 фута. И тя тежи около 2000 кг. И носи бойна глава на около, Мисля, че това е грубо 150 паунда. И самата бойна част е високо експлозивни, които има фрагменти около него. Корпусът на бойна част е проектирана да действа като едри сачми. 

-В Ракети са проведени четири на контейнер, и се транспортират с полуремарке. 

-В Система Patriot противоракетна датира предприятието най-малко 20 години. Той първоначално е бил проектиран като за противоракетна отбрана на въздуха да свалят вражески самолети. В първата война в Залива, когато тази война се появи, Армията иска да го използва, за да свалят ракети Скъд, а не самолети. 

Иракското ВВС беше не толкова голям проблем. Но армията се тревожеше за Скъд. И така, те се опитаха да ъпгрейд патриотът. 

-Intercepting Враг ракета пътуване в Mach 5 щеше да бъде достатъчно голямо предизвикателство. Но когато Patriot е изпратена в експлоатация, Армията не е бил наясно с едно Иракският модификация, която прави техните Скъд почти невъзможно да се удари. 

-Какво Се е случило е най Скъд че идват в са нестабилни. Те бяха клатушка. Причината за това е, иракчаните, с цел за да получите 600 км от една 300 км обсег, взе тегло от предната бойна глава. Те направиха бойна запалка. 

Така че сега на Patriot е опитвайки се да влезе в Скъд. И през повечето време, на Преобладаващото мнозинство от времето, той просто ще лети от Скъд. След като системните оператори Пейтриът осъзнал Патриотът пропусна целта си, те взриви бойна глава на Патриотичния за да се избегнат евентуални жертви, ако тя се оставя да падне на земята. 

-Това Е това, което видяха, че повечето хора, тези големи огнени топки в небето, и неразбрани като прихваща от Скъд бойни глави. 

-Although През нощта небе, Patriots появили да бъде успешно унищожаване на ракети Скъд, в Dhahran, не може да има грешка за неговото изпълнение. Там, радарна система на Патриотичния изгубили следите на входящо Скъд, и никога не стартира поради до софтуерен недостатък. Беше израелците, които първи открили че вече системата е било включено, по-голямата несъответствието време става поради часовник вграден в компютъра на системата. 

-За Две седмици преди трагедията в Dhahran, израелците докладвани Министерството на отбраната че системата се губи време. След около осем часа или тичане, те забелязали, че системата се превръща в значително по-малко точни. Министерството на отбраната отговори, като казва всичко на батериите Пейтриът да не оставят системите за дълго време. Те никога не каза какво дълго време was-- осем часа, 10 часа, 1000 часа. Никой не знаеше. 

-В Батерия Patriot разположени в казармите в Dhahran и неговата погрешна вътрешна часовник е бил на над 100 часа в нощта на 25-ти февруари. 

-Това Проследява времето с точност на около една десета от секундата. Сега, една десета от секундата е интересен номер, тъй като не може да се изрази в двоичен точно, което означава, че не може да се изрази точно във всеки модерен цифров компютър. Трудно е да се повярва. 

Но да използваме това като пример. Нека вземем номер едно трето място. Една трета не може да бъде изразена в десетични точно. Една трета е 0.333 става за безкрайност. 

Няма начин да се направи това с абсолютна точност в десетична. Това е точно вида на проблем което се е случило в Patriot. Колкото по-дълго системата изтича г. по-лошо стана грешката време. 

-След 100 часа работа, на грешка във времето е само около една трета от секундата. Но от гледна точка на насочване на ракета пътуване в Mach 5, тя се превърна в проследяването грешка на повече от 600 метра. Това би било фатална грешка за войниците на това, което случило се на старта Скъд е открити от началото на сателити Предупредителни и те са знаели, че Скъд е идва като цяло тяхната посока. Те не знаеха къде идва. 

-Това Е сега до радара компонент на системата Patriot защитавайки Dhahran да се локализира и да запази следите на входящо вражески ракети. 

-В Радар беше много умен. Това всъщност ще проследят позицията на Скъд, и след това се предскаже, където вероятно ще бъде следващия път радара изпратен пулс навън. Това се нарича гама порта. 

-Then, След като Patriot решава достатъчно време има преминал да се върна и да се провери на следващия място за това открива обект, той се връща. Така че, когато той се върна в грешното място, то тогава не вижда обект. И тя реши, че не е имало обект, той е фалшив откриване, и пада на пистата. 

-В Входящо Скъд изчезна от екрана на радара. И секунди по-късно, тя заби в казармата. The Скъд убит 28, и е последният един изстрел по време на първата война в Залива. 

Трагично е, че се обновява софтуера пристигнал в Dhahran на следващия ден. недостатък на софтуера имаше бил фиксиран, затваряне една глава в разтревожените История на ракетата Patriot. 

[Възпроизвеждане на видео] Дейвид Дж Малан: Така че това е всичко, за да се каже, че тези въпроси от преливане и неточности са твърде реална. И така, как стигнахме до тук? Започнахме с просто говоря за ФОРМАТ. Отново, тази функция отпечатва нещо на екрана, и след това въведени няколко други функции от т.нар библиотеката CS50 на. И ние ще продължим да виж това своевременно. И ние, особено, използвани GET низ, и да получите INT, и сега също се поплавък, и още други все още ще се сблъскваме и се използва преди дълго. 

Но от време на време, да има ние вече видяхме нужда да съхранява това, което ръката тези функции обратно? Те ни върне низ страна, или едно цяло число, или с плаваща запетая. А понякога ние трябва да се сложи, че низ, или инт, или поплавък, някъде. 

И за съхранение на тези неща, спомням точно като в самото начало, ние имаме променливи. Но за разлика от нулата, в C имаме реални типове на variables-- данни видове, повече generally-- сред тях, низ, едно цяло число, а плувка, и тези други все още. 

И така, когато ние декларираме променливи в C, ние ще трябва да декларират нашите типове данни. Това не е нещо, което ще трябва да се направи по-късно през семестъра както ние преход към други езици. Но за сега, ние трябва да априори предварително, обясни на компютъра какъв тип на променлива искаме тя да ни даде. 

Сега, междувременно, за да отпечатате тези видове типове данни, ние трябва да се каже, ФОРМАТ какво да очакваме. И видяхме процента и за струни, и процента и за цели числа, и няколко вече други. И тези, които са просто изисквания за визуалното представяне на тази информация. 

И всеки от тях всъщност може да бъде parametrized или променени по някакъв начин, ако искате да се увеличи контрола вида на продукцията, която ще получите. И, всъщност, се оказва, че не само има наклонена черта п за нов ред. Има и още нещо, наречено обратно наклонена черта R за нов ред, който е по-близко до старото училище пишеща машина, и Windows използва за много години. 

Има наклонена черта тон за разделите. Оказва се, че ако искате да двойни кавички вътре на низ, припомни, че сме използвали двойни кавички двойно цитат от ляво и дясно завършва на нашите струни до този момент. Това би било да обърка нещата. 

Ако искате да се сложи двойни кавички в средата на string-- и, наистина, това е объркващо да се види. И така, вие трябва да избяга, така че да говори, двойно цитат с нещо като, буквално, обратно наклонена черта двойни кавички. А има и няколко други все още. И ние ще видим повече от тези, в реална употреба преди дълго. 

Така че нека сега преход от данни, и представителство, и аритметични оператори, всички на който ни даде някаква сграда блокове, с които да играят. Но сега нека действително да даде ни останалата част от речника че ние вече са имали миналата седмица с Scratch , като разгледаме някои други конструкции в C-- не всички от тях. Но идеите, които сме за да видите наистина просто да се наблегне на превода от един език, Scratch, към друга, C. 

И с течение на времето, ние ще вземем повече инструменти за нашия инструментариум, така да се каже, синтактично. И наистина, ще видите, че идеите Сега са по-скоро запознати от миналата седмица. Така че нека да направим това. 

Да вървим напред и да привличам програма че действително използва някои изрази, булева изразяване. Нека вървим напред тук и да се създаде нов файл. Ще се обадя на този condition.c. 

Нека да вървим напред и да включва CS50 библиотеката. И нека да вървим напред и да включва стандарт IO.h за нашите функции, и ФОРМАТ и повече съответно. Позволете ми да се даде, че шаблон на INT главната нищожен, чието обяснение ние ще да се върне в бъдещето. 

Сега нека да вървим напред и да даде себе си едно цяло число чрез GET вътр. Тогава нека вървим напред и да направим това. Искам да кажа, ако аз е less-- нека разлика между положителни, отрицателни, или нулеви стойности. 

Така че, ако аз е по-малко от нула, нека Просто трябва тази програма просто да кажем, отрицателна, наклонена черта п, друго ако аз е по-голяма от нула. Сега, разбира се, ще кажа ФОРМАТ положителен, наклонена черта п. И след това друг if-- мога да направя това. 

Мога да направя, ако е равна на 0. Но бих се прави най- поне един вече грешка. Припомнете си, че знакът за равно е не е равна, като ние, хората го знаят. 

Но това е оператор за присвояване. И ние не искаме да се вземат 0 На полето и го сложи в I в ляво. Така че, за да се избегне това объркване, или може би неправилно използване на знака за равенство, хората решиха преди няколко години че в много програмни езици когато искате да проверите за равенство между ляво и дясно, всъщност използват се равнява на равни. Така че ви удари знака за равенство два пъти. Когато искате да зададете от полето наляво, вие използвате само един знак за равенство. Така че бихме могли да направим this-- останало ако аз се равнява се равнява на нула. 

След това мога да отида и отвори ми фигурни скоби, и да кажа, ФОРМАТ 0, наклонена черта п, направено. Но не забравяйте, как те вилици в пътя могат да работят. И, наистина, просто мисля за логиката. I е число. Това е цяло число, по-специално. А това означава, че ще бъде по-малко от 0, или по-голяма от 0, или 0. Така че има вид на този мълчалив случай подразбиране. 

И така можем да, точно като Scratch, да освободи от друго, ако, и само да кажа друго. Логично е, ако на програмист знае само там три кофи в които сценарий може fall-- първият, втората, или третата в този case-- не правя притеснява добавяне на допълнителна прецизност и допълнително логика там. Просто върви напред с подразбиране случай тук на друго. 

Сега, нека да вървим напред след като запазите тази, направи условия са разпръснати наклонена черта conditions-- не голям потребителски интерфейс, защото аз не съм накара потребителя, както споменах по-рано. Но това е добре. Ние ще го прости. Нека се опитаме броя 42. И това е положителен. Нека се опитаме броя отрицателна 42, отрицателна. 

Нека се опитаме стойност 0. И наистина, тя работи. Сега, ще видите с проблеми преди дълги, тестване неща три пъти, вероятно не е достатъчно. Може би искате да тествате някои по-големи числа, някои по-малки числа, някои случаи ъгъл, като ние ще дойдем да ги опише. 

Но за сега, това е доста проста програма. И аз съм сигурен, логично, че попада в три случая. И наистина, въпреки че ние просто фокусирани върху потенциалните негативи на неточности и преливник, в реалност, където много от проблемите CS50 е, ние няма да се притеснявате за цялото време, тези въпроси от преливане и неточност, тъй като в действителност, С, тя всъщност не е всичко, което лесно да се избегнат тези неща. Ако искате да брои до по-големи, и по-големи, и по-голяма, Оказва се, че има техники, които можете да използвате, често е свързана с неща, наречени библиотеки, сборници с код, това други хора пишат, че можете да използвате, и други езици като Java и други, всъщност да го направи много по-лесно да брои дори по-висока. Така че това наистина е някои от тези опасности функция на езика, който използвате. И през следващите седмици, ние ще вижте колко опасно C наистина може да бъде, ако не го използвате правилно. Но от там, и с Python, и JavaScript, ще ние слой върху някои допълнителни защити, и работи по-малко от тези рискове. 

Така че нека да направим малко по- интересна логика в нашата програма. Така че нека да вървим напред и да се създаде програма, наречена Logical само за да мога да играя с някои действителната логика, logical.c. Аз просто ще копирате и поставите някои код от по-рано, така че аз се върна за тази хубава отправна точка. 

Нека този път направи Чар C. съм ще му се даде име на C Просто защото това е конвенционален, получите знак от страна на потребителя. И нека да се преструвам, като Аз съм за прилагане на част на които Rm програма, Премахване програма преди тази подкана на потребителя да изтриете даден файл. Как бихме могли да направим това? 

Искам да кажа, ако C е равна се равнява на, цитирам цитата, Y, тогава аз ще приемем че потребителят е избрал да. Аз съм просто ще отпечатате да. Ако го бяха действително написването програмата за отстраняване, бихме могли да премахнете файла с повече реда код. Но ние ще го прости. 

Иначе, ако в равнява равнява, N- и сега тук, аз отивам да се каже, потребителят трябва да означава не. И след това друг, знаете ли какво? Аз не знам какво друго потребителят няма да пишете. Така че аз съм просто ще кажа, че че е грешка, независимо от той или тя всъщност въвели. 

И така, какво става тук? Има една основна разлика в сравнение с това, което съм направил в миналото. Двойни кавички, двойни кавички, двойно кавички, и, все пак, единични кавички, единични кавички. Оказва се, в C, че когато искате да напишете низ, все пак използвате двойни кавички, точно както ние сме Използвам цялото това време с ФОРМАТ. 

Но ако искате да се справят само с един символ, а така наречените Чар, тогава вие всъщност използвате единични кавички. Тези от вас, които са програмирани преди, че не може да има трябваше да се тревожи за това разграничение в някои езици. В C, това е от значение. И така, когато получа Чар и аз искам за сравнение, че Чар използване равни се равнява на някои писмо като у или п, което правя, Наистина, трябва да имаме единични кавички. 

Сега, нека да вървим напред и да направим това. Да вървим напред и да се направи логически точка наклонена черта логически. И сега съм питане. Така че, най-вероятно, по-добър потребителски опит всъщност ще ми каже какво да правя тук. Но аз ще просто сляпо казват, Y за да, ОК, хубаво. 

Нека да го стартирате отново, п за никой, хубаво. Да предположим, че подобно на някои хора, които познавам, шапки ми клавиш за блокиране на всички твърде често. Така че аз правя капитал Y, влиза, грешка. ОК, това не е точно това, което аз очаквах. Всъщност, компютърът прави буквално каквото Аз го казах да do-- проверява за с малки букви Y и малки букви п. Това не се чувствам като добър потребителски опит, все пак. Нека да поиска и го приемам или малки букви или главни букви. Така се оказва, че може да искате да каже нещо като в Scratch, като буквално или С е равно на се равнява на капитала единствен цитиран у. Оказва се, C не трябва това буквално дума или. 

Но тя има две вертикални ленти. Трябва да се държи Shift обикновено, ако сте с помощта на US клавиатура, и удари вертикална лента ключ горе вашият ключ връщане. Но тази вертикална лента вертикална лента означава или. 

Ако, от друга страна, ние искахме да се каже, и, като в самото начало, бихме могли да направим амперсанд амперсанд. Това не прави логически смисъл тук, защото човек не би могъл да сте написали както у и малки букви Y и капитал Y като същия характер. Така или е това, което ние възнамеряваме тук. 

Така че, ако аз направя това и на двете места, или в равнява се равнява капитал N, сега проведена отново, правят логично, проведена отново логично. Сега, аз може да въведете у. И мога да го направя отново с капитал Y, или капитал N. И аз може да добавите в допълнителен комбинации на едно място. 

Така че това е логична програма, доколкото сега Аз съм проверка логично за тази стойност или настоящата стойност. И не е нужно да, задължително, излезе с още две IFS или IFS друго. всъщност мога да комбинирате някои от свързани логика заедно по този начин. Така че това би било по-добре проектирана от просто казвайки, ако C е равен на по-ниска случай Y, отпечатате, да, иначе ако в равнява на капитала Y, отпечатате, да, иначе ако в равнява lower-- с други думи, че не трябва да има все повече и повече клонове. Можете да комбинирате някои от равностойността клонове Логично, като по този начин. 

Така че нека да разгледаме само един крайния съставка, един последен конструкт, че C позволява. И ние ще се върнем в бъдеще на други неподвижни. И тогава ние ще се заключи, като погледнете при не правилността на code-- получаване на код за work-- но дизайна на код, и засадят тези семена в началото на деня. 

Така че нека да вървим напред и да отвори нов файл тук. Знаеш ли какво? Отивам да се приведе отново в действие че същата програма, но при използване на различна конструкция. 

Така че ми позволи бързо да се предам достъп за включване CS50.h за библиотеката CS50, стандарт Io.h за ФОРМАТ. Дай ми ми INT главната невалидни. И след това тук, нека ми давай напред и да направим това. 

Чар в получава получите материала, който точно като преди. И аз ще се използва нова конструкция now-- преминете, за какво характер? Така че ключът е нещо като превключване на железопътните линии. Или, наистина, това е вид един, ако друго, ако друго, ако, но написана малко по различен начин. 

Преминаването изглежда по този начин. Вие имате ключ, и след това, характер или номер, който искате да погледнете, След това някои големи скоби искали в Scratch, просто казват, направи тези неща. И тогава ще има различни случаи. 

Не използвайте, ако и другаде. Вие буквално използва случая дума. А ти би казал нещо подобно. 

Така че в случая на малки букви Y, или в случай на капитала Y, давай напред и да разпечатате да. И след това да се измъкнат от ключа. Това е. Ние сме направили. 

Иначе, ако, така да се каже, малки букви п, или капитал N, След това отидете напред и печат навън не, и след това почивка. Else-- и този вид е При неизпълнение indeed-- ФОРМАТ error-- и просто за добра мярка, макар и логично тази почивка не е необходимо защото ние сме в края на ключа, така или иначе, Аз съм сега се счупи от ключа. Така че това изглежда малко по-различно. 

Но, логично, това е всъщност еквивалент. И защо да използвате една върху друга? Понякога, просто лични предпочитания, понякога естетиката, ако Поглеждам това Сега, има нещо да се каже за разпознаваемост на този код. Искам да кажа, да не говорим за факта, че този код е нов за много от нас в залата. 

Но това просто вид е доста. Вие виждате малки букви Y, капитал Y, малки букви п, капитал N подразбиране тя просто вид скокове при вас по начин, че, може би, може би предходния пример с ИС, както и вертикалните линии, и ИС на друго, не може да има. Така че това е наистина въпрос на личен избор, наистина, или четливост, на кода. 

Но от гледна точка на функционалност, нека давай напред и да направи ключ, точка наклонена черта ключ, а сега писане с малки букви Y, капитал Y, с малки букви п, капитал N, Дейвид, опитайте отново, защото това е Не един символ. Нека да направим х, грешка, както се очаква. И, logically-- и това е нещо Аз ще насърчи в general-- дори въпреки че ние сме само чесане на повърхността на някои от тези характеристики. 

И това може да не е очевидно, когато себе си седнат на клавиатурата, как работи това? Какво това ще правим? Най-красивото нещо, за да се налага лаптоп или настолен компютър, или достъп към компютър с компилатор, и с код редактор, подобен на този, е почти може винаги да отговорим на тези въпроси за себе си просто като се опитва. 

Например, ако риторичен въпрос на ръка са били, какво се случва, ако сте пропуснали Вашите почивка твърдения? Което всъщност е много често нещо да се направи, защото тя не изглежда като наистина имате нужда от тях. Те наистина не завършите помислих, като скоби или къдрава скоба прави. Да вървим напред и компилирате кода и да видите. Така че се превключвател, точка превключвател наклонена черта. Нека да въведете малки букви Y, в началото на делото, Enter. Така че аз напечатани у. 

Програмата каза да, не, грешка, като че ли се променя мнението си. Но това нещо е, защото това, което се случва, с превключвател е първият случай, че мач по същество означава, хей компютър, изпълни всички от кода под него. И ако не ви кажа, почивка, или да не кажа почивка, или да не кажа почивка, компютърът ще се взриви през всички тези линии и изпълни всички от тях, докато той получава за това фигурна скоба. Така че спирачките са наистина необходими. Но храна за вкъщи тук е, когато съмнявате, опитайте нещо. Може би спаси своя код на първо място, или да го запишете в допълнително файл ако сте наистина притеснен за каша и се налага да се възстанови работата, че знаете работи. 

Но опитайте неща. И не е, както е страх, може би, на какво може да се направи на компютъра, или, че може да се счупи нещо. Винаги можете да се върнете обратно за някои по-ранна версия. 

Така че нека да завърша, като търси при проектирането на код. Ние имаме тази способност сега да пиша условия и напиши линии, и променливи и функции при повиквания. Така че, честно казано, ние сме вид обратно в където бяхме преди седмица с Scratch, макар и с описание, по-малко завладяваща среда от Scratch позволява. 

Но забележете колко бързо сме придобито че лексика, дори ако това е Ще отнеме малко повече време, за да потъне в, така че сега можем да използваме тази лексика да напише по-интересни програми. И нека да стъпка бебе към това, както следва. Нека да вървим напред и да създаване на нов файл тук. 

Отивам да наричаме това prototype.c, и да се въведат за първи път, способността да направите свои собствени функции. Някои от вас може да има направил това с Scratch, чрез която можете да създадете свой собствени блокове в самото начало, и след това ги плъзнете на място където искате в C. И в най-програмиране езици, които можете да направите точно that-- направите свои собствени функции, ако те не са вече налице. 

Така, например, нека да вървим напред и включва CS50.h, и включва стандарт IO.h, INT главната невалидни. И сега ние имаме Заместител готов да отида. Държа печат неща като имената на хората днес. И че се чувства like-- Не би било хубаво, ако има са функция, наречена на името на печат? Не трябва да се използва ФОРМАТ. Не трябва да забравяме, всички кодове по формат. Защо не мога, или защо не е направил някой преди мен, създаде функция, наречена печат име, че дадено някакво име, просто го отпечатва? 

С други думи, ако кажа, хей, компютър, дай ми низ чрез задаване на потребителя за такъв, чрез GET функция низ CS50 е. Хей, компютър, сложи това низ в променливата в лявата страна, и наричаме това е. И тогава, хей компютър, давай и печат, че името на човека, направил. 

Сега, че би било хубаво, защото тази програма, ловко име, ми казва това, което е трябвало да се направи по пътя на имената на тези функции е. Нека да отидем и да направи прототип, Enter. И, за съжаление, това няма да лети. 

Prototype.c, линия 7, характер 5, грешка, имплицитно декларация на име функция за печат е невалиден в C99, C99 което означава, че една версия на C които се появиха през 1999. Това е всичко. 

Така че аз не знам какво Всичко това означава, все още. Но аз правя признае грешка в червено. Това е доста очевидно. 

И изглежда, че с зеления характер тук, въпросът е с име на печат, отворен скоба ите, в близост скоба, точка и запетая. Но имплицитно декларация на функция, което направихме видим накратко по-рано. Това означава, просто, че звън не знам какво искам да кажа. 

Ползвал съм лексика дума, че това е никога не е виждал или учили преди. И така, аз трябва да го научи какво означава тази функция. Така че аз ще отида напред и да направи това. 

Отивам да вървим напред и да приложат собствената си функция, наречена Print име. И аз ще кажа, както следва, че тя прави това, ФОРМАТ, здравей, процента ите, наклонена черта п, име, точка и запетая. Така че това, което съм просто правя? 

Така се оказва, че за да приложи своя собствена функция, ние вид назаем някои от същата структура като основна че ние току-що бил се приема за даденост, и аз знам просто копиране и поставите почти това, което Пиша в миналото. Но забележете модела тук. Int, Main, Void, ние ще дразни освен не след дълго това, че всъщност означава. 

Но за днес, просто забележите паралелизма. Void, име на печат, име низ, така че има лилава ключова дума, която ние ще започнем наричайки тип връщане, на името на функцията, и след това на входа. Така че, всъщност, ние можем да дестилират този вид като миналата седмица като, това е името, или алгоритъм на кода сме Ще write-- на алгоритъм се основава кода ние ще пиша. 

Това е входа. Това е неговата продукция. Тази функция, име на печат, е предназначена да отнеме низ, наречен на името, или каквото и да, като вход, а след това нищожно. Той не се връща нищо, като получите низ или да получите инт прави. Така че тя ще ме предаде нещо обратно. Това е просто няма да има страничен ефект, така да се каже, за отпечатване на име на човек. Така че забележите, линия 7, I може да наречеш печат. Линия 10, не мога да се определи или изпълнение на име печат. Но, за съжаление, това не е достатъчно. 

Нека да вървим напред и да прекомпилирате това след спестяване. Уау, сега, аз съм го направил по-лошо, то ще изглежда. Така че имплицитно декларация на Име на функция за печат е невалиден. И, отново, има повече грешки. Но тъй като аз предупреди по-рано, дори ако получите претоварени с, или малко тъжно да се види толкова много грешки, се съсредоточават само върху първата първоначално, тъй като той може просто да са имали каскаден ефект. Така C, или звън по-специално, все още не признава името на печат. 

И това е, защото звън, от дизайн, е вид ням. Тя само прави това, което ти го кажа, за да се направи. И го прави само така в реда в която го кажа, за да се направи. 

Така че аз определено основната на линия четири, като ние сме били прави доста често. Аз определено име печат на линия 10. Но аз се опитвам да използвам име печат на линия седем. 

Това е твърде рано, все още не съществува. Така че може да бъде умен, и ще бъда като, ОК, така че нека просто да играят заедно, и да се премести име печат нагоре тук, и отново да се съберат. Боже мой. Проработи. Тя беше толкова просто. 

Но логиката е точно това. Трябва да се научи звън какво е чрез определяне на функцията на първо място. След това можете да го използвате. Но, честно казано, това се чувства като хлъзгав наклон. 

Така че всеки път, когато стартирате в проблем, аз съм просто ще подчертае и копирайте кода Аз написах, тя го копирате и поставите тук. И, разбира се, бихме могли планират някои сценарии където една функция мощ Трябва да се обадите на друг. И просто не може да постави всеки функция над всеки друг. 

Така се оказва, че има по-добро решение. Ние можем да оставим това да бъде. И, честно казано, това е обикновено приятно, и удобно, и добър дизайн да постави главния първо, защото, отново, Основната точно като при зелен флаг кликнали, че е функция, се изпълни по подразбиране. Така че може и да постави че в началото на файла така че, когато вие или който и да е друг човек гледа на файла Знаете ли какво се случва просто чрез четене основната първия. Така се оказва, че ние можем да кажем звън проактивно, хей, звън, по линия четири, Обещавам да приложат функция, наречена Print Името, което се низ, наречен име като вход, и се връща нищо, за невалидни. И аз ще се придвижва към прилагането му по-късно. 

Тук идва на Майн. Главна сега на ред 9 може да използвате Print Наименование защото звън е доверчив, че, в крайна сметка, той ще се натъкне на определението на изпълнението на Print име. Така че, след като запазите файла ми, нека ми давай напред и да направи прототип, изглежда добре този път. Dot наклонена черта, прототип, нека давай напред и въведете име. Дейвид, здравей Дейвид, Zamila, здравей Zamila, и, наистина, сега тя работи. 

Така че съставката тук е, че ние сме направена потребителска функция, като по поръчка Scratch блок ние сме го вика. Но за разлика от нулата, където можете да просто да го създаде и започнете да го използвате, Сега ние трябва да бъдем по- Малко по-педантичен, и всъщност се обучават звън да се използва, или да го очакваме. Сега, като настрана, защо през цялото това време да има ние е просто сляпо на вярата включително CS50.h, и включително стандарт IO.h? 

Е, оказва се, сред няколко други неща, всичко, което е в тези, точка з файлове, които се случи да бъде файлове. Те заглавни файлове, така да се каже. Те все още са написани на C. Но те са различен тип файл. 

За сега, можете да почти приемем че всичко, което е вътре в CS50.h е някои реплики като тази, а не за функции, наречени Print Наименование, но за да получавате String, Get Float, и няколко други. И там са подобни прототипи, една лайнери, отвътре на стандарт IO.h за ФОРМАТ, който в момента е в моята собствена функция за печат име. Така че, с други думи, цялото това време ние сме току-що беше сляпо копиране и поставяне включва този, включва че, какво се случва? Това са просто вид на улики да звън като до какви функции са, наистина, изпълнява, просто другаде в различни файлове другаде в системата. 

Така че ние сме изпълнени име печат. Той вече има този страничен ефект на отпечатване на нещо на екрана. Но това не е така в действителност Подай ми нещо обратно. Как да отида за изпълнение на програма, която не ме предаде нещо обратно? 

Е, нека се опитаме това. Нека да вървим напред и да приложат файл, наречен return.c така че ние може да покаже как нещо като Get String, или Get Int, всъщност връщане нещо обратно към потребителя. Да вървим напред и да се определи INT главната невалидни. 

И, отново, за в бъдеще, ние ще обясни какво, че инт и тази празнина е всъщност прави. Но за днес, ние ще го приемаме за даденост. Отивам да се продължи напред и ФОРМАТ, за добър потребителски опит, х е. И тогава аз ще чакам за потребител, за да ми даде х с GET вътр. 

И тогава аз ще отида напред и разпечатате х до площада. Така че, когато имате само един клавиатура, хората често използвате малко морков символ на клавиатурата да представлява до властта на, или експонентата на. Така х квадрат присъства аз. 

И сега аз ще направя това. Можех само do-- какво е х квадрат? х на квадрат е х пъти х. 

И ние направихме това някои Преди време вече днес. Това не се чувствам като всички, че много напредък. Знаеш ли какво? Нека да се наберат някои от които идея от последния път на абстракция. 

Не би ли било хубаво, ако има една функция, наречена квадрат, че прави точно това? Тя все още е, в края на ден, върши същата математика. Но нека абстрактно далеч от идеята за поемане един брой, умножен по друго, а просто му се даде име, като квадрат на тази стойност. 

А, с други думи, в C, нека да се създаде функция нарича квадрат, че прави точно това. Това ще се нарича квадрат. Това ще отнеме едно цяло число. И ние ще просто ще го наричат ​​п, по подразбиране. 

Но бихме могли да го наречем нещо, което искаме. И всичко, което то се случва да направя, буквално, е завръщане в резултат на N пъти п. Но, тъй като е връщане на нещо, което е ключовата дума в лилаво ние сме никога не е виждал преди, аз, по линия 11, Не може просто да се каже, нищожен този път. 

Void, в примера, който току-що видяхте по-скоро от името на печат, просто означава, направи нещо. Но не ме предаде нещо обратно. В този случай, аз искам да се върнат п пъти п, или каквото и да е, че номер. 

Така че аз не мога да кажа, хей, компютър, Аз се върне нищо, за невалидни. Това ще се върне, от природата, с вътр. И така, това е всичко, което се случва тук. 

Входът за квадрат ще бъде едно цяло число. И за да можем да го използваме, тя трябва да има име, N. Това ще изход пад, че не се нуждае от име. Ние можем да го оставим на основното, или който и да е използване на мен да си спомня тази стойност, ако ние Искам със собствен променлива. 

И, отново, единствената нова ключовата дума тук е връщане. И аз съм просто правят някои математика. Ако аз наистина исках да бъде излишно, Мога да кажа, инт продукт получава п пъти п. 

И тогава може да се каже, върнете продукта. Но, отново, за да ми точка по-рано от това просто не е добра design-- като, защо се въведе име, символ, като продукт, Просто незабавно да го върне? Това е малко по-чист, малко по-строг, така че да се говори, само за да се каже, връщане н пъти п, да се отървем от тази линия напълно. 

И това е просто по-малко код, за да се чете, по-малка възможност за грешки. И нека да видим дали това всъщност сега работи. Сега, аз ще отида напред и да направи завръщане. 

Охо, имплицитно декларация на функция. Направих тази грешка преди, не е голяма работа. Нека само да въведете, или маркирайте и копирате, точно същата функция прототип, или подпис, на функцията до тук. Или мога да се премести цялата функция. 

Но това е малко мързелив. Така че ние няма да го направя. Сега, нека да направи завръщане отново, точка, наклонена черта връщане. 

х е квадрат 2. х е 4. х е квадрат 3. х е 9. И функцията изглежда Сега трябва да се работи. Така че каква е разликата тук? Имам функция, която се нарича квадрат, в този случай, който сложих в един вход. И аз да се върна на изход. И все пак, по-рано, ако Отварям друга примера от по-рано, което беше наречен prototype.c, Имах име печат, който върнати нищожен, така да се каже, Или го върна нищо, и просто имаше страничен ефект. 

И така, какво става тук? Е, помисли функцията получите низ само за миг. Ние сме били с помощта на функцията получите низ по следния начин. 

Ние сме имали функция получите низ, като включва CS50.h, включва стандартен IO.h, INT, основната, невалидна. И тогава всеки път, когато съм наречен GET низ до този момент, Аз бях казал нещо подобно, низ ите получава се низ, защото GET string-- нека наречем това get.c-- GET низ Самата връща низ, че мога след това използвате, и да кажа, здравей, запетая, процента ите, наклонена черта N, S. 

Така че това е същия пример, наистина, че сме имали по-рано. Така се получи низ връща стойност. Но преди малко, печат низ не връща стойност. Тя просто има страничен ефект. Така че това е една основна разлика. Виждали сме различни видове функции сега, някои от които са се върнали ценности, някои от които не го правят. Така че може би това е низ, или инт, или поплавък. Или може би това е просто нищожни. 

И разликата е че тези функции, получите данни и връща стойност са всъщност привеждане нещо обратно на масата, така да се каже. Така че нека да вървим напред и да Посетете един краен набор на примера, който дава смисъл, сега, на как можем да, наистина, абстрактно-добре, и по-добре и по-добре, или повече, и още, и още, за да да пише, в крайна сметка, по-добре код. Да вървим напред, и в духа от нулата, направете следното. 

Нека да вървим напред и да включва CS50.h и стандарт IO.h. Нека да вървим напред и да даде себе си едно цяло число, основна, за невалидни. И нека да вървим напред, наричаме това cough.c. 

И нека да вървим напред и просто като Scratch, разпечатате кашлица / п. И аз искам да направя това три пъти. Така че аз съм, разбира се, просто ще да копирате и поставите три пъти. Аз сега ще направи кашлица точка наклонена черта кашлица. Нека да се даде малко повече място тук, Enter, кашлица, кашлица, кашлица. 

Има, разбира се, вече е възможност за подобрение. Аз бях копира и на няколко пъти днес. Но това беше само, така че не е направил Трябва да въведете най-много герои. Аз все още се промени това, което тези редове код са. 

Тези три линии са идентични, който се чувства мързелив и наистина е, и най-вероятно не е правилният подход. Така че с това, което съставка бихме могли да подобрим този код? Ние не трябва да копирате и поставяте код. 

И наистина, всеки път, когато се чувстват себе копиране и поставяне, и дори не се променя код, шансовете са, че има по-добър начин. И, наистина, има. Нека да вървим напред и да се направи за контур, въпреки че синтаксисът не вали идва естествено, все още. 

Направете това три пъти, просто като направите following-- и аз се случи да се знае това от практиката. Но ние имаме редица примери сега. И ще видите онлайн повече препратки неподвижно. 

Това е синтаксиса на линия 6, че много прилича на надраскване, който се повтаря блок, повторете следните три пъти. Това е малко магически за сега. Но това ще получите повече, и по-запознати. 

И това ще се повтаря Онлайн осем три пъти, така, че ако мога отново да се съберат изработка кашлица, дот наклонена черта кашлица, кашлица, кашлица, кашлица. Той все още работи по същия начин. Така че всичко е наред и добра. Но това не е много разсеян. 

Това е съвсем верен. Но тя се чувства като има би могло да бъде една възможност, както в света на Scratch, за да вид старт да се добавят някои семантика тук, така че Аз не просто има някои за контур, и функция, която казва, кашлица, или не кашля. Знаеш ли какво? Нека се опитаме да бъдем по- малко по-хладно, отколкото това, и всъщност напише функция, която има някои странични ефекти, наричаме го кашлица. 

И тя не се вход и връща никаква стойност като продукция. Но знаете ли какво прави той? Той прави this-- ФОРМАТ, цитат цитата, кашлица. 

И сега тук, аз ще съм да се продължи напред и за инт, аз стане нула, аз по-малко от 3, аз плюс плюс. Отивам да не правя ФОРМАТ, което е спорно изпълнение на ниско ниво детайл. Не ме интересува как да кашля. Аз просто искам да използвате функцията за кашлица. И аз съм просто ще наричаме кашлица. 

Сега, забележете, дихотомията. Когато се обадите функция, ако не го направите искам да дам го входове, напълно глоба. Просто направете отворени скоба, близо скоба, и сте готови. 

Когато дефинирате функция, или Декларирам на функционални прототипи, ако знаете предварително, че не е ще вземе някакви аргументи, кажа нищожни в тези скоби там. И това прави сигурни, че не ще случайно да злоупотребят с него. Нека да вървим напред и да направи кашлица. И, разбира се, че съм направил грешка. 

По дяволите, има, че имплицитно декларация. Но това е добре. Това е един лесен оправя. Трябва ми само прототип по-нагоре в досието ми, отколкото аз всъщност го използва. 

Така че сега нека да направим кашлица отново, хубаво. Сега, тя работи. Направи кашлица, кашлица, кашлица, кашлица. Така че може би си мислите, че ние сме наистина малко над инженерни този проблем. И наистина, ние сме. Това не е добра кандидат на програма в момента на рефакториране, и прави това, което е нарича йерархична разлагане, където можете да отнеме известно код, а след това някак фактор нещата, така че да приписваме повече семантиката им, и да го използвате отново в крайна сметка по-дългосрочен план. Но това е градивен елемент към по-сложни програми че ние ще започнем писането преди дълго време, че ни позволява да има речника с които да пишат по-добре код. И, наистина, нека да видим дали можем не може да се обобщи това допълнително. 

Изглежда малко куц, че аз, основната, трябва да се тревожи за това дяволски за контур, и призовава кашлица отново и отново. Защо не мога да просто кажете кашлица, моля кашлица три пъти? С други думи, защо не мога просто даде вход да кашля и да направите това? 

Защо не мога да кажа точно, в Основната кашлица три пъти. И сега, това е един вид магически. Това е много повтарящ тук. И това е, наистина, стъпка едно бебе. 

Но просто способността да се каже за Онлайн осем, кашлица три пъти, това е просто толкова по-разбираемо. И, плюс, че не е нужно да знаете или пука как се изпълнява кашлица. И наистина, по-късно в Терминът и за окончателните проекти, ако се справи с един проект с съученик или две съученици, ще разбереш, че ти започваш да се Трябва да, или искате да разделя работата. 

И вие ще искате да се реши предварително, кой ще направи това, което, и в която парчета? И не би ли било хубаво ако, например, поемане на отговорност за писане основна, направено. И си съквартирант, или си партньор по-общо, се грижи за прилагането на кашлица. 

И това разделение, те стени на абстракция, или слоеве на абстракция ако Ще ви, са супер мощен, защото особено за по-голям, по-сложни програми и системи, това позволява на много хора да изградят неща заедно, и в крайна сметка бод съвместната им работа по този начин. Но, разбира се, ние Трябва да сега се определи кашлица. Трябва да кажа, кашлица че, хей, знаеш ли какво? Ти ще трябва да се вземат input-- така не нищожен, но инт и сега. Да вървим напред и пуснати в кашлица на Int. аз стане нула. 

I е по-малко от колко пъти. Казах три преди. Но това не е това, което искам. Аз искам кашлица да се обобщи, да поддържа произволен брой повторения. 

Така че, наистина, това е п че искам, каквото и потребителят ми казва. Сега, аз може да вървим напред и да се каже за печат кашлица. И без значение какъв номер потребителят минава, Аз ще обхождане, че много пъти. 

Така в края на деня, програма е идентична. Но забележете всички тези неща дори може да бъде в друг файл. Всъщност, аз не знам в миг как ФОРМАТ се изпълнява. 

Аз не знам в момента как да получите низ, или да получите INT, или да получите плувка са изпълнени. И аз не искам да ги виждате на екрана си. Както и да е, аз съм се започне да се съсредоточи върху моята програма, а не тези функции. 

И така, наистина, веднага след като си започнете факторинг код, подобен на този от, Дори може да се движим кашлица в отделен файл? Някой друг може да го приложи. И вие и вашата програма се превърне в много красива, и много се чете, може би, наистина четири Онлайн програма точно там. 

Така че нека да вървим напред сега и направи още една промяна. Забележете, че ми прототип трябва да се промени до върха. Така че нека да се определи, че толкова Аз не се развика. 

Направи кашлица, нека тичам кашлица веднъж повече, все още прави същото нещо. Но сега, забележете, ние имаме съставка за една последна версия. Знаеш ли какво? Аз не искам да кашля само, непременно. Искам да има нещо по-общо. Така ли какво? Искам да направя това. Аз искам да имам, който много прилича на надраскване прави, а да речем блок, но не само каже нещо някакъв брой пъти. Искам това да се каже много специфичен низ. И, следователно, не знам искам просто да кажа, кашлица. Искам тя да каже каквото и низ е преминал инча 

Така че забележите, че съм генерализирана това, така че сега да речем чувства като добро име за това, като Scratch, отнема два аргумента, за разлика от нулата. Един от тях е низ. Един от тях е едно цяло число. 

И мога да ги включите. Аз просто нещо като идеята за каже низа първо, и след това колко пъти по-късно. Void това означава още не връща нищо. Това са само визуална страна ефекти, като с [? Йордания,?] вербална страничен ефект от викане. Той все още прави нещо н пъти, 0 до, но не е равно на п. Това означава N Общо пъти. И след това просто да отпечатате независимо, че низ е. Така че аз съм наистина генерализирана този ред код. Така че сега, как да приложат функцията за кашлица? 

Мога да направя невалидни кашлица. И аз все още могат да се вземат в това как много пъти, които искате да кашля. Но знаете ли какво? Сега мога да шута да се каже. 

Мога да се обадя да кажа с Думата кашлица, преминаваща през п. И ако искам да се прилагат, просто за забавление, функция кихане, Мога да кихат някои брой пъти. И мога да продължа повторно използване на п, защото забележите, че м в този контекст или обхват съществува само в рамките на тази функция. 

И п в този контекст само съществува в рамките на тази функция тук. Така че ние ще се върнем към тези въпроси от обхвата. И тук, аз съм просто ще кажа, achoo, и тогава п пъти, точка и запетая. 

И сега, аз просто трябва да се заемат тези функции подписи до тук. Така че кашлицата е вярна. Void кихане е вярна сега. 

И аз все още просто трябва да кажа. Така че аз ще кажа, да речем низ ите, INT N, точка и запетая. Така че аз съм над инженерство на чесало на тази програма. 

И това не е така непременно, че това е какво трябва да направите, когато пишете дори най-простите програми. Вземете нещо, което е очевидно много проста, наистина кратко, и повторното изпълнение на това използване на прекалено много код. Но вие всъщност ще видите, и в път погледна назад към тези примери, усетят, о, това са стъпките, взехме да всъщност правят обобщения, да фактор нещо, докато в края на деня кода ми всъщност е доста разумно. Защото, ако искам да кашля три пъти след това кихат три пъти, Аз съм просто ще преиграва това, Програма направи кашлица, и тичам кашлица. И аз имам три кашлица и три кихане. 

И така, това е основен парадигма, ако щете, за това как можем да отида за всъщност се прилага програма. Но нека просто видим сега какво е ние сме били прави всичко на този път, и това, което някои от най-крайните части са зад тази проста команда. В края на деня, ние сме Използвам звън като нашата компилатор. Ние сме били писмено източник код, конвертиране го чрез звън в машинен код. 

И ние сме били с помощта на Направи просто За улеснение на нашите клавиши така че ние не трябва да се помни, тези заклинания на себе си звън. Но това, което е Направи всъщност прави? И, от своя страна, това, което е Звън всъщност прави? 

Оказва се, че ние сме опростени днешната дискусия, като казва, вземете изходния код, да го давате като въвеждане на компилатор, който дава изхода на машината код, оказва се, че има няколко различни стъпки вътре има. И съставяне случва да бъде чадъра термин за цял куп стъпки. Но нека просто дразни това се наистина бързо. 

Оказва се, че ние сме били прави повече неща, всеки път, когато стартирате програмата, или всеки път, когато се състави програма днес. Така предварителна обработка се отнася до this-- нищо в програма на С, както ще видим отново и отново, който започва с тази хеш символ, или символ таг тук, означава, това е директива на предпроцесорни. Това означава, че, в този случай, хей компютър, направи нещо с този файл преди да се съберат моя собствен код. 

В този случай, хеш включва означава, същество, начин да се каже на C, хей компютър, иди се съдържанието на CS50.h и ги поставете тук. Ей компютър, отидете получите съдържание на стандартен IO.h, където и че е на твърд диск, го поставете тук. Така че тези неща се случват първо време предварителна обработка. 

И звън прави всичко това за нас. И това го прави толкова дяволски бързо, не е нужно дори виж четири различни неща, които се случват. Но това е първата подобна стъпка. 

Какво всъщност се случва след това? Е, на следващия длъжностното стъпка е съставянето. И се оказва, че съставяне на програма технически средства става от изходен код, нещата, които съм пише днес, за нещо наречена монтаж код, нещо че изглежда малко по-различно. 

И в действителност, ние можем да видим това доста бързо. Нека действително отиде в моя IDE. Нека да вървим напред и отворен hello.c, които е първата програма, с която ние започва днес. И нека да вървим напред и да тичам звън на малко по-различно, звън-ите, hello.c, което всъщност ще дайте ми друг файл hello.s. 

И ние може би никога няма да отново видя този вид код. Ако сте приели по-ниско ниво системи клас като CS61, вие ще видите много повече на този вид на код. Но това е асемблер. Това е X86 асемблер че процесора, който е в основата CS50 IDE всъщност разбира. 

И загадъчен, както го прави изглежда, че е нещо, компютърът разбира доста добре. Под Q, това е изваждане. Има движения. 

Там се обажда на функции тук, х oring, едно движение, една добавка, поп, връщане. Така че има някои много инструкции ниско ниво че процесорите да разберат, че Аз споменах по-рано. Това е, което Intel Inside. 

Има модели на нули и единици, които Карта на тези arcanely формулирана, но донякъде добре име, инструкции, така да се каже. Това е, което се случва, когато компилирате кода си. Можете да получите монтаж език от това, което означава Третата стъпка е да се съберат че сглобяване код в крайна сметка, машини code-- нули и единици, не на текст, който ние просто видях преди малко. 

Така предварителна обработка се, че се намери и замени, и няколко други неща. Съставяне поема своя източник код от C, изходния код че сме писали, да сглобяване код, който ние просто погледна. Сглобяване отнема че сглобяване код за нули и единици че процесора наистина ще разбере в края на деня. И свързване е последната стъпка , което се случва за us-- отново, толкова бързо, ние дори не notice--, която казва, хей компютър, да вземе всички единиците и нулите, че е резултат от съставянето на код на Давид, и основната му функция в този случай. 

И хей ​​компютър, иди всички от единиците и нулите че персоналът CS50 пише вътре в библиотеката CS50. Смесете тези в с Дейвид. И хей ​​компютър, отидете получите всички нули и такива, които някой друг е написал години Преди за ФОРМАТ. И добавите тези в цялата работа, така че ние сме Трябва ми нули и единици, за нули и единици персонала CS50, нулите на ФОРМАТ и тези, и всичко друго, което използваме. 

Всички те се комбинират заедно в едно програма, наречена, в този случай, здравей. Така че отсега нататък, ние просто ще използвайте дума съставянето. И ние ще приемем за даденост, че когато ние казваме, компилирате вашата програма, това означава, хей направя предварителната обработка, монтаж и свързване. Но всъщност има някои сочни неща става там под предния капак. И особено ако получите любопитни известно време, можете да започнете да изпълзяват около в тази по-ниско ниво. Но за сега, да разбере, че сред храна за вкъщи за днес са просто най- началото на процеса, за получаване на комфортно с нещо като здравей свят. Всъщност, повечето от това, което направихме днес със сигурност няма да потъне в супер бързо. И това ще отнеме известно време, а някои практики. И шансовете са, че ще се справи от искаме да удари вашата клавиатура или крещи на екрана. И всичко това е ОК. Макар, че може би не се опитват да го направи в библиотеката толкова много. 

И в крайна сметка, ще бъде в състояние все пак, за да започнете виждайки модели, както в добро код че вие ​​сте писали и в грешки че сте направили. И много прилича на процеса на стане TF или CA е като, ще започне да се получи по-добре и по-добре, когато видя тези модели, и точно решаване на вашия собствени проблеми в крайна сметка. В същото време, ще има много на нас, за да заемаш ви подкрепа, и ще получите чрез това. И в писане прозорци за всички проблеми ще ви бъдат преведени през всички команди че аз със сигурност знам от много практика до сега, но може да е летял над главата за сега. И това е напълно наред. 

Но, в крайна сметка, ти започваш да започне да видите модели се появяват. И след като преминем през всички по- глупави подробности, като скоби, и фигурни скоби, и точка и запетая, и неща, честно казано, че изобщо не е интелектуално интересен. И това не е целта на като всяка уводна клас. Това е идеите, които се случва да има значение. 

Това е примките, и условия и функциите, и по-силно черпене, и факторинга на код, и добър дизайн, и за доброто стил, и в крайна сметка на точността на кода си, че това е в крайна сметка Ще има значение най-много. Така че през следващата седмица, ние ще вземем тези идеи, които за първи път се видяхме в Scratch и сега са преведени да C. И ние ще започнем да се въведе първият от реалния свят домейни курса. 

Ние ще се съсредоточим върху света на сигурността, и по-специално криптография, изкуството на кодиране на информация. И сред първите проблеми ти сам Ще си да напише отвъд играе с някои от синтаксиса и решаване на някои логически проблеми, в крайна сметка след дълго, е действително да се катеря, или криптиране, и в крайна сметка да декриптира информация. И всичко, което сме направили Днес, по-скоро ще ниско ниво, е просто ще позволи нас, за да вземе един, и един, и още една стъпка по-горе към написването на най-интересното кода си. 

Така че повече от това през следващата седмица. 

[Възпроизвеждане на видео] 

-Какво Може да ми кажете за последния път, когато го видя? -Какво Мога да кажа, наистина? Искам да кажа, че е като всяка друга предварително производство репетиция, освен там беше нещо, което той каза, в самия край, който остана с мен. 

-Това Е CS50. 

-Това Е нарязан на всички, чудесна работа по репетиция. 

обяд -Това е? 

-Да, Ти и аз мога вземете сандвич в малко. Нека само да разпиташ с Дейвид наистина бързо. Дейвид? Дейвид? 

[END PLAYBACK] 